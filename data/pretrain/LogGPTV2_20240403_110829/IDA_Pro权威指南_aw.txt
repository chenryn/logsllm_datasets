0000000C vfunc4          dd ?  
00000010 vfunc5          dd ?  
00000014 SubClass_vtable ends
这个结构体允许将虚表引用操作重新格式化成以下形式：
.text:004010AB                 mov     eax, [edx+SubClass_vtable.vfunc3]
8.7.3 对象生命周期
了解对象的构建和撤销机制，有助于明确对象的层次结构和嵌套对象关系，并有助于迅速确定类构造函数和析构函数2
 。
2. 类构造函数是一个初始化函数，它在创建对象时被自动调用。对应的析构函数为可选函数，它在对象脱离作用域或类似情况下被调用。
对全局和静态分配的对象来说，构造函数在程序启动并进入 main
 函数之前被调用。栈分配的对象的构造函数在对象进入声明对象的函数作用域中时被调用。许多时候，对象一进入声明它的函数，它的构造函数就被调用。但是，如果对象在一个块语句中声明，那么，它的构造函数直到这个块被输入时才被调用（如果它确实被输入的话）。如果对象在程序堆中动态分配，则创建对象分为两个步骤。第一步，调用 new
 操作符分配对象的内存。第二步，调用构造函数来初始化对象。微软的Visual C++与GNU的g++ 的主要区别在于，Visual C++可确保在调用构造函数之前，new
 的结果不为空值（null
 ）。
执行一个构造函数时，将会发生以下操作。
如果类拥有一个超类，则调用超类的构造函数。
如果类包含任何虚函数，则初始化虚表指针，使其指向类的虚表。注意，这样做可能会覆盖一个在超类中初始化的虚表指针，这实际上是希望的结果。
如果类拥有本身就是对象的数据成员，则调用这些数据成员的构造函数。
最后，执行特定于代码的构造函数。这些是程序员指定的、表示构造函数 C++ 行为的代码。
构造函数并未指定返回类型，但由 Microsoft Visual C++生成的构造函数实际上返回到 EAX寄存器中的this
 指针。无论如何，这是一个 Visual C++ 实现细节，并不允许 C++ 程序员访问返回值。
析构函数基本上按相反的顺序调用。对于全局和静态对象，析构函数由在 main
 函数结束后执行的清理代码调用。栈分配的对象的析构函数在对象脱离作用域时被调用。堆分配的对象的析构函数在分配给对象的内存释放之前通过 delete
 操作符调用。
析构函数执行的操作与构造函数执行的操作大致相同，唯一不同的是，它以大概相反的顺序执行这些操作。
如果类拥有任何虚函数，则还原对象的虚表指针，使其指向相关类的虚表。如果一个子类在创建过程中覆盖了虚表指针，就需要这样做。
执行程序员为析构函数指定的代码。
如果类拥有本身就是对象的数据成员，则执行这些成员的析构函数。
最后，如果对象拥有一个超类，则调用超类的析构函数。
通过了解超类的构造函数和析构函数何时被调用，我们可以通过相关超类函数的调用链，跟踪一个对象的继承体系。有关虚表的最后一个问题涉及它们在程序中如何被引用。一个类的虚表被直接引用，只存在两种情况：在该类的构造函数中引用和在析构函数中引用。定位一个虚表后，你可以利用IDA 的数据交叉引用功能（参见第9 章）迅速定位相关类的所有构造函数和析构函数。
8.7.4 名称改编
名称改编
 也叫做名称修饰
 （name decoration ），是 C++ 编译器用于区分重载函数3
 的机制。为了给重载函数生成唯一的名称，编译器用其他字符来修饰函数名称，用来编码关于函数的各种信息。编码后的信息通常描述函数的返回类型、函数所属的类、调用该函数所需的参数序列（类型和顺序）。
3. 在C++ 中，函数重载
 情况下，程序员可以对几个函数使用相同的名称。这样做的唯一要求是，重载函数的每个版本在函数接受的参数类型的顺序和数量上各不相同。换言之，每个函数的原型必须是唯一的。
名称改编是 C++ 程序的一个编译器实现细节，其本身并不属于 C++ 语言规范。因此，毫不奇怪，编译器供应商已经开发出他们自己的、通常并不互相兼容的名称改编约定。幸好，IDA 理解Microsoft Visual C++、GNU g++ 以及其他一些编译器使用的名称改编约定。默认情况下，在程序中遇到一个改编名称时，IDA 会在反汇编代码清单中该名称出现的位置以注释的形式显示该名称的原始名称。使用 Options ▶Demangled Names 打开如图8-15 所示的对话框，可以选择 IDA 的名称取消改编选项。
图8-15 取消改编名称的显示选项
对话框中有3 个主要选项，用于控制是否以注释的形式显示取消改编的名称（demangled name），是否对名称本身进行取消改编，或者根本不执行取消改编。以注释的形式显示改编名称可得到以下代码：
  .text:00401050 ; protected: __thiscall SubClass::SubClass(void)  
➊ text:00401050 ??0SubClass@@IAE@XZ  proc near  
   ...  
  .text:004010DC              ➋ call  ??0SubClass@@IAE@XZ  ; SubClass::SubClass(void)
同样，以名称显示改编名称得到以下代码：
➊ .text:00401050 protected: __thiscall SubClass::SubClass(void) proc near  
   ...  
   .text:004010DC  ➋ call    SubClass::SubClass(void)  
其中，➊表示一个函数的反汇编代码清单的第一行，➋表示调用该函数。
Assume GCC v3.x（采用 GCC v3.x名称）复选框用于区分 g++ 2.9.x 版本与g++ 3.x及更高版本使用的改编方案。在正常情况下，IDA 应自动检测 g++ 编译代码中使用的命名约定。Setup short names （设置短名称）和 Setup long names （设置长名称）按钮为取消改编名称的格式化提供了细化控制，其中包括大量选项，相关信息请查询 IDA 的帮助系统。
因为改编名称能提供大量与函数签名有关的信息，它们减少了 IDA 为理解传递给函数的参数的数量和类型所需的时间。如果一个二进制文件使用了改编名称，IDA 的取消改编功能会立即揭示所有名称被改编的函数的参数类型和返回类型。相反，如果函数并未使用改编名称，你必须花费大量时间，对进出函数的数据流进行分析，从而确定函数的签名。
8.7.5 运行时类型识别
C++ 提供各种操作符，可进行运行时检测，以确定（typeid
 ）和检查（dynamic_cast
 ）一个对象的数据类型。为实现这些操作，C++ 编译器必须将类型信息嵌入到一个程序的二进制文件中，并执行能够百分之百确定一个多态对象的类型的过程，而不管为访问该对象被取消引用的指针类型。然而，与名称改编一样，RTTI（Runtime Type Identification ，运行时类型识别）也是一个编译器实现细节，而不是一个语言问题，因此，编译器没有标准的方法来实现 RTTI功能。
我们将简要介绍 Microsoft Visual C++与GNU g++ 的RTTI实现之间的异同。具体来说，我们介绍的内容仅仅涉及如何定位 RTTI信息，并以此为基础，了解与这些信息有关的类名称。有关微软的RTTI实现的详细讨论，请参阅 8.7.7 节，其中详细说明了如何遍历一个类的继承体系，包括如何在存在多继承的情况下跟踪继承体系。
以下面这个利用多态的简单程序为例：
class abstract_class{  
public:  
   virtual int vfunc() = 0;  
};  
class concrete_class : public abstract_class {  
public:  
   concrete_class();  
   int vfunc();  
};   
void print_type(abstract_class *p) {  
   cout << typeid(*p).name() << endl;  
}  
int main() {  
   abstract_class *sc = new concrete_class();  
   print_type(sc);  
}
print_type
 函数必须正确打印指针 p
 所指向的对象的类型。在这个例子中，基于 main
 函数创建了一个concrete_class
 对象这个事实，我们立即意识到，concrete_class
 必须被打印。这里我们需要回答的问题是：print_type
 ，更具体的说是typeid
 ，如何知道p
 指向的对象的类型？
问题的答案非常简单。因为每个多态对象都包含一个指向虚表的指针，编译器将类的类型信息与类虚表存储在一起。具体来说，编译器在类虚表之前放置一个指针，这个指针指向一个结构体，其中包含用于确定拥有虚表的类的名称所需的信息。在 g++ 代码中，这个指针指向一个type_info
 结构体，其中包含一个指向类名称的指针。在 Visual C++ 代码中，指针指向一个微软RTTICompleteObjectLocator
 结构体，其中又包含一个指向 TypeDescriptor
 结构体的指针。TypeDescriptor
 结构体中则包含一个指定多态类名称的字符数组。
需要注意的是，只有使用 typeid
 或dynamic_cast
 操作符的C++ 程序才需要 RTTI信息。多数编译器都提供一些选项，禁止不需要 RTTI的二进制文件生成 RTTI。因此，如果 RTTI信息碰巧丢失，你不应感到奇怪。
8.7.6 继承关系
如果深入 RTTI实现，你会发现，你可以弄清继承关系。但是，要了解继承关系，你必须理解编译器的特殊 RTTI实现。而且，如果一个程序不使用 typeid
 或dynamic_cast
 运算符，RTTI信息可能并不存在。缺少 RTTI信息，又该使用什么技巧来确定 C++ 类中的继承关系呢？
确定某个继承体系的最简单方法是，观察在创建对象时被调用的超类构造函数的调用链。内联4
 构造函数是这种方法成功与否的唯一最大障碍。如果使用了内联构造函数，我们就不可能知道一个超类构造函数实际上已经被调用。
4. 在C/C++ 程序中，一个声明为 inline
 的函数将被编译器作为宏处理，并且该函数的代码将被扩展，以替代一个显式函数调用。由于存在汇编语言调用语句是一个函数被调用的确凿证据，使用内联函数则倾向于隐藏了函数被调用这一事实。
分析和比较虚表是另一种用于确定继承关系的方法。例如，如图 8-14 所示，在比较虚表的过程中，我们注意到，SubClass 的虚表中包含两个相同的指针，它们也出现在类 BaseClass的虚表中。为此，我们可以轻易得出结论，BaseClass与SubClass 之间必定存在着某种关系，但到底SubClass 是BaseClass的子类，还是BaseClass是SubClass 的子类呢？遇到这类情况，我们可以应用下面的一条或多条指导原则，设法了解它们之间的关系。
如果两个虚表包含相同数量的条目，则与这两个虚表对应的类之间可能存在着某种继承关系。
如果类X 的虚表包含的条目比类 Y 多，则 X 可能是Y 的子类。
如果X 包含的条目也可以在 Y 的虚表中找到，则必定存在下面一种关系：X 是Y 的子类，Y 是X 的子类，或者 X 和Y 全都是同一个超类 Z 的子类。
如果X 包含的条目也可以在类 Y 的虚表中找到，并且 X 的虚表中至少包含一个纯调用条目，而Y 的虚表中并没有这个条目，那么 Y 是X 的子类。
虽然上面罗列的并不全面，但是我们可以使用这些指导原则来推断图 8-14 中BaseClass与SubClass 之间的关系。上面的后 3 条原则全都适用于这个例子，但仅仅根据对虚表的分析，由最后一条原则可得出结论：SubClass 是BaseClass的子类。
8.7.7 C++ 逆向工程参考文献
有关逆向工程已编译 C++ 代码的补充阅读内容，请参阅下面这些详尽的参考文献。
Igor Skochinsky 的文章“Reversing Microsoft Visual C++ Part II: Classes, Mehtods and RTTI”，地址是http://www.openrce.org/articles/full_view/23
 。
Paul Vincent Sabanal 和Mark Vincent Yason的论文“Reversing C++”，访问地址是 http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf
 。
虽然这些文章中的许多细节主要适用于使用 Microsoft Visual C++编译的程序，但许多概念也同样适用于使用其他 C++ 编译器编译的程序。
8.8 小结
除了最简单的程序外，你可能会在各种程序中遇到复杂的数据类型。了解如何访问复杂数据结构中的数据，以及如何收集有关这些复杂数据结构的布局的线索，是一项基本的逆向工程技巧。IDA 提供大量功能，专门用于满足你在处理复杂数据结构方面的需求。熟悉这些功能将大大提高你在理解数据类型方面的能力，从而将更多的精力放在理解如何及为何操纵数据上。
在下一章中，我们介绍交叉引用和图形，并结束对 IDA 基本功能的讨论。随后，我们将讨论IDA 的高级功能，正是这些功能将 IDA 与其他逆向工程工具区别开来。
第9章 交叉引用与绘图功能
在对二进制文件进行逆向工程时，人们提出的一些常见问题包括：“这个函数是从什么地方调用的”和“哪些函数访问了这个数据”。这些及其他类似的问题其实是对程序中各种资源的引用进行分类。有两个例子可说明这类问题的用处。
假设你已经确定了一个函数的位置，该函数包含一个栈分配的可溢出的缓冲区，你可对此加以利用。由于这个函数可能深深隐藏在一个复杂的应用程序中，因此，下一步你需要确定到底如何访问该函数。除非你能够执行这个函数，否则它就对你毫无用处。我们会提出这样一个问题：哪些函数会调用这个易受攻击的函数呢？而数据是由哪些函数传递给易受攻击的函数的呢。在你回溯潜在的调用链，查找那个有助于你利用缓冲区溢出的函数调用时，你必须继续上述推理过程。
另外，如果一个二进制文件包含大量 ASCII 字符串，你会觉得其中至少有一个字符串值得怀疑，如“Executing Denial of Service attack! ”（拒绝服务攻击）。存在这个字符串表明这个二进制文件确实会拒绝服务攻击吗？不是，它只是表示该二进制文件碰巧包含上述特殊的 ASCII 序列。你可能会据此推断，这条消息可能会在实施攻击之前以某种方式显示出来。但是，你需要查找相关代码，以证实自己的怀疑。那么，“程序从什么地方引用这个字符串呢？”这个问题将有助于你迅速跟踪到利用该字符串的程序位置，进而确定具体的拒绝服务攻击代码。
通过强大的交叉引用功能，IDA 将帮助你回答这些问题。IDA 提供大量显示和访问交叉引用数据的机制，包括图形生成功能，它以更加直观的方式显示代码与数据之间的关系。在本章中，我们将讨论IDA 提供的各种交叉引用信息和访问交叉引用数据的工具，以及解释这些数据的方法。
9.1 交叉引用
首先，需要指出的是，IDA 中的交叉引用通常简称为xref 。如果引用的是一个IDA 菜单项或对话框中的内容，我们称这种引用为xref 。对于其他引用，我们仍然使用 交叉引用
 这一术语。
在IDA 中有两类基本的交叉引用：代码交叉引用和数据交叉引用。这两种引用又分别包含几种不同的交叉引用。每种交叉引用都与一种方向表示法有关。所有的交叉引用都是在一个地址引用另一个地址。这些地址可能是代码地址或数据地址。如果你熟悉图论，可以把这里的地址看做是一个有向图（directed graph ）中的节点，而把交叉引用看做是图中的边。图 9-1 可帮助你迅速了解有关图形的术语。在这个简单的图形中，两条有向边（➋）连接了 3 个节点（➊）。
图9-1 基本的图形组件
需要注意的是，节点也叫做顶点
 （vertice ）。有向边则使用箭头表示这条边可以指向的方向。在图9-1 中，从上面的节点可以到达下面的两个节点之一，但从下面的两个节点却无法到达上面的节点。
代码交叉引用是一个非常重要的概念，因为它可帮助 IDA 生成控制流图形
 和函数调用图形
 ，我们将在本章后面讨论这些图形。
在深入讨论交叉引用之前，先来了解 IDA 如何在反汇编代码清单中显示交叉引用信息。某反汇编函数（sub_401000
 ）的标题行如图 9-2 所示。该函数的常规注释（图右侧）中包含一个交叉引用。
图9-2 基本的交叉引用
文本CODE XREF
 表示这是一个代码交叉引用，而非数据交叉引用（DATA XREF
 ）。后面的地址（这里为_main+2A
 ）是交叉引用的源头地址。注意，这个地址比.text:0040154A
 之类的地址更具描述性。虽然这里的两个地址都可以表示同一个程序位置，但交叉引用中使用的地址提供了额外的信息，指出交叉引用是在一个名为_main
 的函数中提出的，具体而言是_main
 函数中的第 0x2A（42 ）字节。地址后面总是有一个上行或下行箭头，表示引用位置的相对方向。在图 9-2 中，下行箭头表示_main+2A