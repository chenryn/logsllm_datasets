the presence of faults,” J. ACM, vol. 27, no. 2, pp. 228–234, 1980.
[43] D. Kravitz, “Digital signature algorithm,” jul 1993, uS Patent 5,231,668.
[44] Y. Lindell, “Fast secure two-party ecdsa signing,” in CRYPTO 2017.
[45] G. Castagnos, D. Catalano, F. Laguillaumie, F. Savasta, and I. Tucker,
“Two-party ECDSA from hash proof systems and efﬁcient instantia-
tions,” in CRYPTO 2019, 2019.
[46] D. Boneh, B. Lynn, and H. Shacham, “Short signatures from the weil
pairing,” J. Cryptology, vol. 17, no. 4, pp. 297–319, 2004.
[47] J. Doerner, Y. Kondi, E. Lee, and a. shelat, “Secure two-party threshold
ecdsa from ecdsa assumptions,” in IEEE S&P, 2018.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
621
[48] M. Keller, E. Orsini, and P. Scholl, “Actively secure OT extension with
optimal overhead,” in CRYPTO, 2015.
[49] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank, “Extending oblivious
transfers efﬁciently,” in CRYPTO ’03, 2003, pp. 145–161.
[50] O. Goldreich, S. Micali, and A. Wigderson, “Proofs that yield nothing
but their validity or all languages in np have zero-knowledge proof
systems,” J. ACM, vol. 38, no. 3, p. 690–728, Jul. 1991.
[51] M. Stadler, “Publicly veriﬁable secret sharing,” in EUROCRYPT ’96,
1996.
[52] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai, “Universally com-
posable two-party and multi-party secure computation,” in ACM STOC,
2002.
APPENDIX A
FULL PROOF OF MULTIPARTY IMPOSSIBILITY
Before giving the formal
theorem and proof, we build
intuition for the argument by examining an instructive (3,4)
case. In particular, we argue that it is impossible for only three
online parties to proactivize the system, while simultaneously
tolerating two mobile corruptions. Assume that P0, P1, P2 are
online, and Poﬀ is ofﬂine. As the system is resilient to two
corruptions (say P1, P2), we can not rely on any private
communication from P1, P2 to Poﬀ; i.e. all the information
that Poﬀ requires to refresh must be contained in P0’s view.
Note that this includes information that P0 may not be able
to interpret itself, such as ciphertexts that encrypt messages to
Poﬀ under a key that P0 does not possess. We use this fact to
argue that an adversary who corrupts P0 continuously but Poﬀ
only for a single epoch is able to derive Poﬀ’s private state even
in subsequent epochs. The adversary can then corrupt P1 in a
subsequent epoch (after un-corrupting Poﬀ) and use P0, P1’s
obtained private state in conjunction with Poﬀ’s derived private
state to completely retrieve the signing key (this is feasible as
any three parties should be able to sign a message).
Translating this intuition to a formal proof, or even a well-
formed theorem, sees a number of subtle issues arise. For
instance, we can not unconditionally prove that it is impossible
to realize F n,t
ECDSA with ofﬂine refresh for t > 2; doing
so would require proving that ECDSA itself is a signature
scheme. To see why, consider a ‘signature scheme’ where the
veriﬁcation algorithm Vrfy outputs 1 on all inputs. Clearly,
realizing a threshold version of this ‘signature scheme’, even
with proactive security, is trivial; all parties simply output “0”
when instructed to sign a message, then there is no private
state to refresh. Therefore we formulate our theorem more
carefully: we prove that if it possible to ofﬂine-refresh a given
threshold signature scheme (t > 2) with a dishonest online
majority, then the given signature scheme itself is succeptible
to forgery.
We state our theorem in the (GLedger,FRO) model, for the
• GLedger represents that this barrier can not be circum-
vented even with a consensus primitive as strong as an
ideal ledger.
• FRO gives the power to compute any efﬁciently com-
putable function [52] and so represents the ability to
produce arbitrary correlated randomness during the pre-
processing phase (i.e. during key generation) and also
following reasons:
compute any function securely (albeit without robust-
ness [35]) during the refresh protocol itself.
Additionally both ideal oracles are trivial to implement when
running the environment in a reduction.
Theorem A.1. Let Sig = (KeyGen, Sign, Vrfy) be a triple
of algorithms that satisﬁes the completeness deﬁnition of
signature schemes. If there exists a protocol π(t,n)
ρ-sign in the
(GLedger,FRO)-hybrid model that UC-realizes F n,t
Sign with n >
tρ ≥ t > 2 in the presence of a mobile adversary actively
corrupting t− 1 parties where tρ  tρ ≥ t ≥ 2
such that tρ  (cid:98)tρ/2(cid:99) + 1 it holds that the adversary may corrupt
more than h parties. For ease of exposition, assume 2h+1 = tρ
(m, state(cid:48)
oﬀ ,{state(cid:48)
(cid:20)
Pr
oﬀ
(cid:21)
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
622
Consider the same experiment EXECπ(t,n)
so that the adversary may corrupt up to h + 1 parties and only
h parties in the refresh protocol are honest in the worst case.
ρ-sign ,Z∗ run with an
alternative environment Z∗
n,tρ that corrupts each Pi for i ∈
[h + 1, 2h + 1] and issues the same commands as Zn,tρ, with
the caveat that corrupt parties do not transmit anything on their
private channels to Poﬀ, i.e. (τi,oﬀ = ⊥)i∈[h+1,2h+1].
Observe that the view of the honest parties P1,··· , Ph is
distributed identically in both executions. This is because the
private channel between each corrupt Pi for i ∈ [h + 1, 2h + 1]
to Poﬀ is hidden by deﬁnition, and Poﬀ itself does not send
any messages in this experiment. This fact has the following
implications:
• The transcript of honest parties’ private channels to Poﬀ,
i.e. (τi,oﬀ )i∈[h] is distributed in both executions.
• The collection of private states of honest parties at the
end of the experiment, i.e. (state(cid:48)
i)i∈[h], is distributed the
same in both experiments. In particular, at the end of both
experiments, parties P1,··· , Ph successfully advance to
the next epoch. As all honest parties must agree on the
epoch when activated, it holds that Poﬀ advances to the
next epoch in both experiments. In particular, for any
I ⊂ [n] \ oﬀ such that |I| = t − 1, it must hold that
implementing the instruction (sign, m, I ∪ {oﬀ}) via
ρ-sign produces a valid signature σ of m under pk.
π(t,n)
the view of Poﬀ is characterized entirely by
the private channel communication from P1,··· , Ph,
i.e.
(τi,oﬀ )i∈[h] which is the same in both experiments, and stateoﬀ
its own private state from the start of the experiment (also the
same in both experiments).
Note that
As we have argued that Poﬀ must successfully advance to
the next epoch in both experiments, we are ready to deﬁne
Ext and Sign
∗ as follows:
• Ext implements the wake instruction for Poﬀ via π(t,n)
ρ-sign,
using as input the entire view of Poﬀ, characterized by
(τi,oﬀ )i∈[h], stateoﬀ, and outputs the private state of Poﬀ
for the next epoch, state(cid:48)
∗ implements the (sign, m, I ∪ {oﬀ}) instruction
ρ-sign, using as input the private
for (Pi)i∈I and Poﬀ via π(t,n)
states of all of these parties (state(cid:48)
• Sign
oﬀ.
i)i∈I∪{oﬀ}
By completeness and unanimous erasure of the protocol
ρ-sign, both the above algorithms succeed with overwhelming
π(t,n)
probability. This completes the proof of this lemma.
We now construct the environment that will actually be used
by the forger. Consider an instantiation with the same param-
eters as earlier, n > tρ ≥ t ≥ 2 such that t > (cid:98)tρ/2(cid:99) + 1, i.e.
less than half the parties in the refresh protocol are guaranteed
to be honest, and deﬁne oﬀ = tρ + 1 and h = tρ − t + 1 as
earlier. Deﬁne the environment Z∗ controlling adversary A as
follows:
1) Instruct A to corrupt P1, P2,··· , Ph and Poﬀ.
2) Send init to all parties.
3) Instruct A to uncorrupt Poﬀ.
4) Send (refresh, [1, tρ]) to each party Pi where i ∈ [1,
tρ].
Deﬁne τi,j, statei, state(cid:48)
i)i∈[h], stateoﬀ, and state(cid:48)
5) Send (wake) to all parties.
6) Instruct A to corrupt Ph+1.
7) The adversary A outputs its entire view.
8) Z∗ outputs whatever A outputs.
Note that unlike the usual speciﬁcation for the real/ideal
process in UC [14] in which the environment only outputs a
bit, the output of Z∗ here is a more complex string. This is
done for ease of exposition as the output of Z∗ will be used by
the forger (Z∗ acts as a passthrough for the output of A), there
is no meaningful advantage in the real/ideal distinguishing
game.
i for i, j ∈ [n] as earlier. The output
of A at the end of this experiment is the complete views of
parties P1, P2,··· , Ph, the view of Poﬀ prior to the refresh
instruction, and the view of Ph+1 after the refresh instruction.
These values are sufﬁciently characterized by (τi,oﬀ , statei,
state(cid:48)
When the instructions of Z∗ are implemented with the
protocol π(t,n)
ρ-sign, we denote the output of the resulting ex-
ρ-sign UC-realizes F n,t
periment as REALπ(t,n)
Sign,
there must exist a simulator SSign which interacts with Z∗
in place of A, and queries F n,t
Sign instead of interacting with
honest parties, with the output of the resulting experiment de-
ρ-sign ,A,Z∗ ≈
noted IDEALF n,t
Sign ,SSign,Z∗. We make use of this fact when construct-
IDEALF n,t
ing the forger, i.e. the forger will run the simulator SSign
with the adversary to sample from IDEALF n,t
Sign ,SSign,Z∗, as it
can not sample from REALπ(t,n)
ρ-sign ,A,Z∗ without instantiating
honest parties in π(t,n)
ρ-sign, for which their secret states (and hence
the secret key) must be known. Additionally the challenger’s
public key pk can be embedded in the ideal computation using
F n,t
Sign.
We are ﬁnally ready to construct the forger for the signature
scheme, which forges a signature on a given message m
under a public key pk received from the challenger.
Sign ,SSign,Z∗. It must hold that REALπ(t,n)
ρ-sign ,A,Z∗. As π(t,n)
h+1 respectively.
Forge(1κ, pk, m):
1) Sample
i)i∈[h],
stateoﬀ,
Sign ,SSign,Z∗ with the caveat
(τi,oﬀ , statei, state(cid:48)
← IDEALF n,t
h+1
Sign is
programmed to output pk as the public key when init
is queried by SSign. The ideal oracle GLedger if used, is
implemented as per its speciﬁcation.
state(cid:48)
that F n,t
oﬀ ← Ext((τi,oﬀ )i∈[h], stateoﬀ )
2) Compute state(cid:48)
3) Compute σ ← Sign
∗
4) Output σ
Lemma A.3. For all m ∈ {0, 1}∗, the following probability
is overwhelming in κ:
oﬀ , (state(cid:48)
(m, state(cid:48)
i)i∈[h+1])
(cid:21)
(cid:20)
Pr
Vrfy (pk,σ,m)=1 :
(sk, pk) ← KeyGen(1κ)
σ ← Forge(pk, m)
Proof. We have previously shown in Lemma A.2 that it is
(cid:48) produced
possible to forge a message under a public key pk
by running the real protocol π(t,n)
ρ-sign. We now show how to
translate this ability in order to forge a message under a public
623
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
key pk received from an external challenger (i.e. the signature
experiment) using SSign to replace honest parties from π(t,n)
ρ-sign
as well as program pk into the view of the adversary. We prove
this lemma via a sequence of hybrid experiments.
Hybrid H1 . In this hybrid experiment, Forge is run as speci-
ﬁed, except that Step 1 is implemented using REALπ(t,n)
ρ-sign ,A,Z∗.
Let the public key produced by running π(t,n)