two traces to compromise the CTR_DRBG state. However, any
request for PRG output causes at least three encryptions, and
four when AES-256 is used as the underlying block cipher.
Our attack can be trivially extended to use the extra
encryptions to more efﬁciently eliminate candidates, which
aids in reducing the impact of noisy measurements.
Related Attacks.
Roche et al. [73] demonstrate that a
powerful attacker who can generate arbitrary faults in the
key schedule can perform a blind attack on AES. Jaffe [39]
attacked counter mode encryption with an unknown nonce,
requiring 216 consecutive block encryptions. Ronen et al.
[74] demonstrated a blind attack on counter mode encryption
targeting the authentication MAC.
C. Evaluation
The Victim. We ran our experiments on a laptop equipped
with 16 GB of RAM and an Intel i7-6820HQ CPU clocked
at 2.7GHZ with an 8 MB L3 cache, running Ubuntu 16.04.
Similar to [89], we demonstrate the attack against mbedTLS-
SGX [96], an SGX port of the widely-used mbedTLS library.
To our knowledge, mbedTLS-SGX is the only library currently
available with a functional SGX-based HTTPS client.
Attack Procedure. We demonstrate an end-to-end attack
on a connection between the TLS client and www.cia.gov,
with all of the client’s cryptographic operations taking place
within the enclave. We ﬁrst mounted a Prime+Probe attack to
recover the CTR_DRBG state used to generate the 256 bits
of the ECDH ephemeral private key (a total of ﬁve AES256
encryptions of an incrementing counter). Using the recovered
private key, we were able to calculate the premaster key and
subsequently decrypt the HTTPS communication. The details
of the side-channel attack are left to Appendix C.
Results.
Due to high noise levels in some traces, our
attack recovered the PRG state in approximately 36% of
our 1000 trials. The online phase, during which we mounted
the Prime+Probe attack, took less than two seconds. The
ofﬂine phase, in which we recovered the state of the PRG
and decrypted the TLS stream, took negligible time. After
recovering the PRG state, we recovered the TLS symmetric
encryption keys and GCM IVs, and subsequently decrypted
the HTTPS request.
Attack Complexity.
The complexity of the attack is
dominated by calculating the set of key candidates. Generating
each candidate requires 218 T-Table look-ups for each trace.
Eliminating candidates by decryption required negligible work.
We tested the number of remaining candidates in each step
experimentally, both in the noise-free case (via simulation over
500 random keys) and in the noisy case (1000 SGX attacks).
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1252
Performing the attack with two traces yields 1.13 ·29 and 1.52 ·
211 candidates for the noise-free and noisy cases respectively.
In simulation, three traces are sufﬁcient for the analysis to
isolate the single correct key in each list. However, noise in
the real-world setting requires us to use an additional trace to
isolate the correct candidate, totaling to four traces.
V I I I . I M PA C T
In order to evaluate the impact of our ﬁndings, we scraped a
public database of security certiﬁcates released under NIST’s
Cryptographic Module Validation Program (CMVP).
Government Certiﬁcation. The CMVP allows vendors to
certify that their cryptographic modules meet minimal require-
ments to sell to the United States and Canadian governments.
In order to comply with FIPS 140-2, implementations must
use one of the PRGs described in SP 800-90A.
Certiﬁcation can apply narrowly to a speciﬁc product model,
or apply to a product line. Most major vendors of network
devices and operating systems certify their products.
Database Scraping. We scraped a public-facing database of
CMVP certiﬁcations on May 13, 2019 to assess the potential
impact of our ﬁndings. CTR_DRBG was the most popular
design, supported by 67.8% of the implementations in the
database. Of 2498 implementations present, 1694 (67.8%)
supported CTR_DRBG. Of these, 461 (25%) exclusively sup-
ported AES-128, 1163 (69%) supported AES-128 along with
other ciphers, and 1227 (72%) supported AES-256. The CMVP
database also lists whether the manufacturer enabled prediction
resistance for the DRBG implementation. Of the 1694 total
implementations that supported CTR_DRBG, 66 provided no
information about prediction resistance, 618 supported use
of the DRBG in either mode with the default unspeciﬁed,
433 explicitly enabled prediction resistance, and 577 did
not support prediction resistance. Among the CTR_DRBG
implementations, 85 did not use a derivation function and
1137 did not support an alternate DRBG algorithm.
I X . D I S C U S S I O N
Limitations. Our results rely on a victim’s use of T-Table
AES, which has long been known to leak information via side
channels. However, as illustrated in this work, T-Table AES
is still used by many modern implementations. In the non-
SGX setting, our TLS attack requires code execution on the
client, and succeeds only after thousands of handshakes. This
potentially allows for detection of an on-going attack. While
we demonstrate our SGX attack against the only library that
provides a working end-to-end example of an HTTPS client,
the Intel-supported SGX-SSL library [37] (which does not
provide support for TLS) uses SGX’s hardware-based RDRAND
PRG and therefore is not vulnerable to a T-Table based attack.
Countermeasures.
CTR_DRBG’s ﬂaws, both theoretical
and practical, suggest that implementations need to take great
care when choosing this design. Where FIPS compliance is
required, HASH_DRBG and HMAC_DRBG give better secu-
rity guarantees [87]. Where CTR_DRBG cannot be replaced,
implementers should use AES hardware instructions, limit the
quantity of data that can be requested in a single call, reseed
frequently, and populate addin with high quality entropy,
to provide defense in depth against our attacks. In general,
constant-time code should be used for all cryptographic appli-
cations, unless hardware support (e.g., AES-NI) is available.
Mismatches Between Theory and Practice.
Signiﬁcant
effort has been dedicated to formalizing PRG security prop-
erties and designing provably secure constructions. However,
theoretical analyses of many of the most commonly-used de-
signs in practice (the Linux RNG [22], CTR_DRBG [87]) have
found that these designs do not meet basic security properties,
such as robustness against state compromise. Unfortunately,
implementers are often hesitant
to adopt countermeasures
without a concrete demonstration of vulnerability.
The Fragility of ECDSA. The fragility of DSA and ECDSA
in the face of random number generation and implementation
ﬂaws has been repeatedly demonstrated in the literature [12,
92]. Random number generation failure inevitably compro-
mises a single session or a signature, but DSA/ECDSA are
particularly vulnerable to compromise of long-term secrets. De-
terministic ECDSA [70] is the recommended countermeasure.
Future of FIPS.
FIPS 140-3 is expected to contain
requirements for side-channel mitigations from the inclusion
of NIST SP 800-140F, which has yet to be issued and becomes
effective in September 2019. FIPS 140-2 CMVP certiﬁcations
will continue to be issued at least through 2021 [59]. This
is a promising step towards widespread deployment of side-
channel-resistant cryptography; however, it remains to be seen
how improved requirements for certifying modules will feed
back into the design and standardization of secure primitives.
Using RDRAND without a PRG. Using the built-in CPU
PRG to mitigate concerns with software PRGs is not a panacea.
In several SGX ports we have reviewed (including Intel’s
ofﬁcial port for OpenSSL [37]) the software PRG was replaced
with calls to the RDRAND instruction. While using the CPU’s
generator avoids software side-channels, the existence of hard-
to-discover bugs in PRGs integrated into CPUs [51, 88] mean
this feature is better used as one of many sources of entropy
for a provably secure software PRG.
A C K N O W L E D G E M E N T S
This work was supported by the National Science Founda-
tion under grant no. CNS-1651344, by the ISF under grant
number 1523/14, by gifts from Intel and AMD corporations,
and by the Defense Advanced Research Projects Agency
(DARPA) under contract FA8750-19-C-0531. Eyal Ronen is a
member of CPIIS.
R E F E R E N C E S
[1] T. Allan, B. B. Brumley, K. Falkner, J. van de Pol, and Y.
Yarom, “Amplifying side channels through performance
degradation,” in ACSAC, 2016.
J.-P. Aumasson and A. Vennard, Audit of OpenSSL’s
randomness generation, 2018.: ostif.org/wp- content/
uploads/2018/09/opensslrng-audit-report.pdf.
J. Austen, Pride and Prejudice. 1813.
[2]
[3]
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1253
[4] N. Benger, J. van de Pol, N. P. Smart, and Y. Yarom,
“‘‘Ooh aah... just a little bit” : A small amount of side
channel can go a long way,” in CHES, 2014.
[5] D. J. Bernstein, Cache-timing attacks on AES, https :
//cr.yp.to/antiforgery/cachetiming-20050414.pdf, 2005.
[6] ——, Fast-key-erasure random-number generators,
2017.: blog.cr.yp.to/20170723-random.html.
[7] E. Biham and A. Shamir, “Differential fault analysis of
secret key cryptosystems,” in CRYPTO, 1997.
[8] A. Biryukov, “Substitution–permutation (SP) network,”
in Encyclopedia of Cryptography and Security, H. C. A.
van Tilborg and S. Jajodia, Eds. 2011.
[9] D. Bleichenbacher, “Chosen ciphertext attacks against
protocols based on the RSA encryption standard
PKCS# 1,” in CRYPTO, 1998.
J. Bonneau, Robust ﬁnal-round cache-trace attacks
against AES, IACR ePrint archive 2006/374, 2006.
[10]
[11] F. Brasser, U. Müller, A. Dmitrienko, K. Kostiainen, S.
Capkun, and A.-R. Sadeghi, “Software grand exposure:
SGX cache attacks are practical,” in WOOT, 2017.
J. Breitner and N. Heninger, “Biased nonce sense:
Lattice attacks against weak ECDSA signatures in
cryptocurrencies,” in FC, 2019.
[12]
[13] S. Briongos, P. Malagón, J.-M. de Goyeneche, and J.
Moya, “Cache misses and the recovery of the full AES
256 key,” Applied Sciences, no. 5, 2019.
[14] Y. Cai, S. Ghose, Y. Luo, K. Mai, O. Mutlu, and
E. F. Haratsch, “Vulnerabilities in MLC NAND ﬂash
memory programming: Experimental analysis, exploits,
and mitigation techniques,” in HPCA, 2017.
[15] M. J. Campagna, Security bounds for the NIST codebook-
based deterministic random bit generator. IACR ePrint
archive 2006/379, 2006.
[16] C. Canella, J. Van Bulck, M. Schwarz, M. Lipp, B.
von Berg, P. Ortner, F. Piessens, D. Evtyushkin, and D.
Gruss, “A systematic evaluation of transient execution
attacks and defenses,” in USENIX Security, 2019.
[17] C. Canella, D. Genkin, L. Giner, D. Gruss, M. Lipp,
M. Minkin, D. Moghimi, F. Piessens, M. Schwarz, B.
Sunar, J. Van Bulck, and Y. Yarom, “Fallout: Leaking
data on Meltdown-resistant CPUs,” in CCS, 2019.
[18] S. Checkoway, R. Niederhagen, A. Everspaugh, M.
Green, T. Lange, T. Ristenpart, D. J. Bernstein, J.
Maskiewicz, H. Shacham, and M. Fredrikson, “On the
practical exploitability of dual EC in TLS implementa-
tions,” in USENIX Security, 2014.
[19] S. Checkoway, J. Maskiewicz, C. Garman, J. Fried, S.
Cohney, M. Green, N. Heninger, R.-P. Weinmann, E.
Rescorla, and H. Shacham, “A systematic analysis of
the Juniper dual EC incident,” in CCS, 2016.
[20] S. N. Cohney, M. D. Green, and N. Heninger, “Practical
state recovery attacks against legacy RNG implementa-
tions,” in CCS, 2018.
[21] C. Disselkoen, D. Kohlbrenner, L. Porter, and D. M.
Tullsen, “Prime+Abort: A timer-free high-precision L3
cache attack using Intel TSX,” in USENIX Security,
2017.
[22] Y. Dodis, D. Pointcheval, S. Ruhault, D. Vergniaud, and
D. Wichs, “Security analysis of pseudo-random number
generators with input,” in CCS, 2013.
[23] GnuPG Project, GnuPG, 2019.: www.gnupg.org.
[24] M. D. Green, Twitter thread on OpenSSL.: https://twitter.
com/matthew_d_green/status/1115013260783255558.
[25] ——, The strange story of “extended random”, 2017.:
blog . cryptographyengineering . com / 2017 / 12 / 19 / the -
strange-story-of-extended-random/.
[26] ——, Wonk post: Chosen ciphertext security in public-
key encryption (part 2), 2018.: blog.cryptographyengin
eering.com/2018/07/20/wonk-post-chosen-ciphertext-
security-in-public-key-encryption-part-2/.
[27] L. Groot Bruinderink, A. Hülsing, T. Lange, and Y.
Yarom, “Flush, Gauss, and reload – a cache attack on the
BLISS lattice-based signature scheme,” in CCS, 2016.
[28] D. Gruss, R. Spreitzer, and S. Mangard, “Cache tem-
plate attacks: Automating attacks on inclusive last-level
caches,” in USENIX Security, 2015.
[29] D. Gruss, C. Maurice, K. Wagner, and S. Mangard,
“Flush+Flush: A fast and stealthy cache attack,” in
DIMVA, 2016.
[30] S. Gueron, A memory encryption engine suitable for gen-
eral purpose processors, IACR ePrint archive 2016/204,
2016.
[31] S. Gueron and Y. Lindell, “GCM-SIV,” in CCS, 2015.
[32] D. Gullasch, E. Bangerter, and S. Krenn, “Cache games -
bringing access-based cache attacks on AES to practice,”
in IEEE SP, 2011.
[33] M. H., Intel SGX for dummies (Intel SGX design
objectives), 2013.: software.intel.com/en-us/blogs/2013/
09/26/protecting-application-secrets-with-intel-sgx.
[34] M. Hähnel, W. Cui, M. Peinado, and T. Dresden, “High-
resolution side channels for untrusted operating systems,”
in USENIX ATC, 2017.
[35] N. Heninger, Z. Durumeric, E. Wustrow, and J. A.
Halderman, “Mining your Ps and Qs: Detection of
widespread weak keys in network devices,” in USENIX
Security, 2012.
[36] S. Hirose, “Security analysis of DRBG using HMAC in
[37]
NIST SP 800-90,” in WISA, 2009.
Intel, Intel software guard extensions SSL, 2017.: github.
com/intel/intel-sgx-ssl.
[38] G. Irazoqui, M. S. Inci, T. Eisenbarth, and B. Sunar,
“Wait a minute! a fast, cross-VM attack on AES,” in
RAID, 2014.
J. Jaffe, “A ﬁrst-order DPA attack against AES in
counter mode with unknown initial counter,” in CHES,
2007.