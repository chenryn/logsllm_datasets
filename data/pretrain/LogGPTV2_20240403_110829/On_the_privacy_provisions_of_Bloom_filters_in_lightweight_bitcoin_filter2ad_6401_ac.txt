sertion of Bitcoin addresses into the Bloom ﬁlter (with and without
restart of the SPV client).
leakage due to the acquisition of two Bloom ﬁlters, we distinguish
two cases.
1) B1 and B2 pertain to different users.
Recall that each Bloom ﬁlter is initialized with a random seed,
chosen uniformly at random from {0, 1}64. Therefore, if B1 and
B2 pertain to different users, then it is highly likely that they are
initialized with different random seeds. This means that the false
positives generated by each ﬁlter are highly likely to correspond
to different addresses. Moreover, since different users will have
different Bitcoin addresses, B1 and B2 will contain different ele-
ments. Therefore, B1 ∩ B2 is likely to be comprised of only few
addresses, if any. Notably, when B1 and B2 pertain to different
users, then |B1 ∩ B2| can be computed as follows:
1
E[|B1 ∩ B2|] ≈ (|B1| − N1)|B2|
(6)
|B| − N1
≈ Pf (m1)Pf (m2)|B|2
≈ Pf (m1)Pf (m2)|B|,
|B| − N1
(7)
(8)
where N1 corresponds to the number of elements inserted in B1.
E[|B1 ∩ B2|] is the expected number of elements which match B2
and B1. The number of elements in B which match B2 is given
by Pf (m2)|B|. Then, E[|B1 ∩ B2|] can be computed by assuming
a binomial distribution with success probability Pf (m2), and with
Pf (m2)|B| number of trials.
Note that the adversary can compute m1 (using Equation 4); if
m1 > |B1 ∩ B2|, then this offers a clear distinguisher for the ad-
versary that the two acquired Bloom ﬁlters B1 and B2 pertain to
different user wallets.
2) B1 and B2 pertain to the same user.
On the other hand, in the case where B1 and B2 correspond to
the same SPV client, three sub-cases emerge:
Two Bloom Filters.
We start by analyzing the case where the adversary acquires two
different Bloom ﬁlters B1 and B2. In the sequel, we focus on com-
puting Ph(.) corresponding to ﬁlter B1, which we assume to be the
smallest of the two ﬁlters (in size). In analyzing the information
B1 and B2 use the same size/seed: This is the case when users,
e.g., create additional Bitcoin addresses and need to update
their outsourced Bloom ﬁlters to include those addresses. In
this case, B1 and B2 are likely to comprise of similar Bitcoin
addresses. This includes both the actual elements of the ﬁl-
ters, i.e., the Bitcoin addresses of the user, and the false pos-
10−1510−1010−5100105Number of addresses in walletExpected number of false positives  05010015020000.20.40.60.81Ph(1)S (Empirical)S (Analytical)S (Analytical, restart)|B|PtPh(1)N
Pt
1
3
19
49
54
8,999
Ph(1)
(0.05%)
1(±0)
1(±0)
0.76(±0.03)
0.004(± 0.00032)
0.36(±0.02)
0.35(±0.002)
Ph(1)
(0.1%)
1(±0)
1(±0)
0.42(±0.03)
0.0021(±0.00019)
0.14(±0.0059)
0.21(±0.00075)
Ph(1)
(0.5%)
1(±0)
1(±0)
0.03(±0.002)
0.00035(±0.00002)
0.01(±0.00089)
0.05(±0.00032)
Ph((cid:100)N/2(cid:101)) Ph((cid:100)N/2(cid:101)) Ph((cid:100)N/2(cid:101))
(0.05%)
(0.5%)
(0.1%)
Ph(N )
(0.05%)
Ph(N )
(0.1%)
Ph(N )
(0.5%)
0.0433
-
1
0
0
0
0.000026
-
1
0
0
0
-
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
Table 2: Ph(.) with respect to Pt and N. Each data point is averaged over 10 independent runs; we also show the corresponding 95%
conﬁdence intervals.
itives generated by the Bloom ﬁlter. In this case, |B1 ∩ B2|
can be computed as follows:
E[|B1 ∩ B2|] ≈ N1 + Pf (2N1)|B|
N1 − k
Ph(j) ≈ j−1(cid:89)
N1 + Pf (2N1)|B| − k
k=0
(9)
(10)
Notice that |B1 ∩ B2| = S1 + N1 = |B1| (since B1 ⊂
B2); therefore, Ph(j) is not affected by the acquisition of the
second ﬁlter B2.
B1 and B2 use different seeds: In existing SPV clients, the ran-
dom nonce r used to instantiate the Bloom ﬁlter is stored
in volatile memory. Therefore, each time the SPV client is
restarted (e.g., smartphone reboots), a new ﬁlter will be cre-
ated with a new seed chosen uniformly at random.
If the
adversary acquires two Bloom ﬁlters of the same user which
are initialized with different seeds, then these ﬁlters are likely
to exhibit different false positives. B1 and B2 will however
comprise of a number of identical elements (which map to
the Bitcoin addresses of the user). More speciﬁcally,
E[|B1 ∩ B2|] ≈ N1 + (|B1| − N1)
|B2|
(11)
|B| − N1
Ph(j) ≈ j−1(cid:89)
k=0
≈ N1 + Pf (m1)Pf (m2)|B|
N1 − k
N1 + Pf (m1)Pf (m2)|B| − k
(12)
(13)
As we show in Section 5.2, the obtained Ph(j) is consider-
ably large in this case, when compared to the case where the
adversary has access to only one ﬁlter.
B1 and B2 use the same seed, but have different sizes: This is
the case when users, e.g., create additional Bitcoin addresses
beyond the capacity of their current Bloom ﬁlters. SPV clients
therefore need to resize their Bloom ﬁlters. Note that ﬁl-
ter resizing typically shufﬂes the bits of the Bloom ﬁlters;
the resulting distribution of bits in the new resized ﬁlter is
not necessarily pseudo-random (since the same seed is used)
and depends on the sizes of the ﬁlters. As such, only the
lower bound on |B1∩B2| can be estimated using Equation 12
(which estimates the worst case where ﬁlter resizing causes a
pseudo-random permutation of the bits of the ﬁlters); in Sec-
tion 5.2, we conﬁrm our analysis by means of experiments.
Recall that since there are only few tens of millions of addresses
in Bitcoin, the adversary can brute-force search the entire list of Bit-
coin addresses in order to acquire B1 and B2 and compute B1 ∩B2.
Given any two Bloom ﬁlters B1 and B2, the adversary can easily
guess whether these two Bloom ﬁlters contain Bitcoin addresses
from the same wallet. Indeed, if |B1 ∩B2| is small, then it is highly
likely that B1 and B2 map to different elements (if m1 and m2 are
not small), and therefore pertain to different users. On the other
hand, when |B1 ∩ B2| (cid:29) 0, it is highly likely that all the Bitcoin
addresses in the set B1 ∩ B2 belong to the same SPV client.
Multiple Bloom Filters.
In the previous paragraphs, we discussed the case where the ad-
versary is equipped with only two Bloom ﬁlters. We point out that
our analysis equally applies to the case where the adversary pos-
sesses any number b > 2 of Bloom ﬁlters pertaining to the same
entity.
As mentioned earlier, by computing the intersection between
each pair of ﬁlters, the adversary can ﬁnd common elements to dif-
ferent ﬁlters; this also enables the adversary to guess with high con-
ﬁdence whether different ﬁlters have been generated by the same
client. Given b ﬁlters which belong to the same SPV client, the ad-
versary can compute the number of elements inserted within each
ﬁlter using Equation 4. In the sequel, we assume that ﬁlters B1, . . . ,
Bb are sorted by increasing number of elements (i.e., Bb contains
the largest number of elements), and that ﬁlters are constructed us-
ing different seeds. Let Kj = Bj ∩ ··· ∩ B(b−1),∀j ∈ [1, b − 1].
Note that |K1| ≤ |K2|··· ≤ |K(b−1)|. Here, the larger the num-
ber of Bloom ﬁlters at the disposal of the adversary, the smaller is
the error of the adversary in correctly classifying the genuine ad-
dresses of the SPV client, and the larger is Ph(.). That is, the larger
is b, the smaller are the number of common false positives that are
exhibited by the different ﬁlters, and the higher is the conﬁdence
of the adversary in identifying the false positives of Bj. Following
Equation 12,
E[|K1|] = min(|B1|,|B2|, . . . ) ≈ N1 + |B|(cid:89)
Ph(j) ≈ j−1(cid:89)
Ni − k + |B|(cid:81)
Ni − k
∀j Pf (mj)
∀j
k=0
Pf (mj)
(14)
(15)
Moreover, as j increases, Kj will contain more false positives,
and Ph(j) will decrease.
5.2 Experimental Evaluation
In what follows, we validate our analysis in Section 5.1 by ex-
periments using existing SPV clients. For that purpose, we rely on
a similar setup to the one used in Section 4.2, and we perform four
different experiments. We perform all four experiments by setting
the target false positive rate Pt to 0.05%, 0.1% and 0.5%, respec-
tively.
In our ﬁrst experiment (Experiment 1), we create 10 different
user wallets, each generating ﬁve different Bloom ﬁlter B1,B2,. . . ,
B5 with the same size and using the same random seed r, but each
having a different number of elements N = {25, 30, 35, 40, 45}.
This corresponds to the case where 10 different users constantly
Ni, Nj
Pt
(%)
|Bi ∩ Bj|
Ph(1)
(b = 2)
Ph(1)
(b = 1)
Ph(N/2)
(b = 2)
Ph(N ) Ni, Nj
(b = 2)
Pt
(%)
|Bi ∩ Bj|
Ph(1)
(b = 2)
Ph(1)
(b = 1)
Ph(N/2)
(b = 2)
Ph(N )
(b = 2)
25,45
25,45
25,45
Experiment 1 (Same client, same seed, same size)
0.05
0.1
0.5
83.6(±10.88)
245.0(±15.36)
3192.90(±230.79)
0.2990
0.1020
0.0078
0.2910
0.1070
0.0075
Experiment 2 (Same client, same seed, different size)
0
0
0
0
0
0
70,270
70,270
70,270
0.05
0.1
0.5
70.3(±0.28)
71.70(±0.48)
671.20(±46.54)
0.9957
0.9762
0.1043
0.0678
0.0266
0.0031
0.8145
0.3177
0
0.2502
0.0011
0
0.05
0.05
0.05
0.05
0.1
0.1
10.0(±0.0)
100.0(±0.0)
1004.70(±1.54)
5007.30(±1.96)