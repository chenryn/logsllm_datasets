所以是非常重要的列。当然，GROUP BY子句也和SELECT子句一样，
●分组列
可以通过逗号分隔指定多列。
如果用画线的方式来切分表中数据的话，就会得到图3-5那样以商品
种类为界线的三组数据。然后再计算每种商品的数据行数，就能得到相应
的结果了。
3-2 对表进行分组 93 ●
图3-5 按照商品种类对表进行切分
product_type product_name product_id sale_price purchase_price regist_date
（商品种类） （商品名称） （商品编号）（销售单价） （进货单价） （登记日期）
T恤衫 0001 1000 500 2009-09-20
衣服
运动T恤 0003 4000 2800
打孔器 0002 500 320 2009-09-11
办公用品
圆珠笔 0008 100 2009-11-11
菜刀 0004 3000 2800 2009-09-20
高压锅 0005 6800 5000 2009-01-15
厨房用具
叉子 0006 500 2009-09-20
擦菜板 0007 880 790 2008-04-28
法则3-6
GROUP BY就像是切分表的一把刀。
此外，GROUP BY子句的书写位置也有严格要求，一定要写在
FROM语句之后（如果有WHERE子句的话需要写在WHERE子句之后）。
如果无视子句的书写顺序，SQL就一定会无法正常执行而出错。目前
SQL的子句还没有全部登场，已经出现的各子句的暂定顺序如下所示。
子句的书写顺序（暂定） ▲
1. SELECT → 2. FROM → 3. WHERE → 4. GROUP BY
法则3-7
SQL子句的顺序不能改变，也不能互相替换。
聚合键中包含 的情况
NULL
接下来我们将进货单价（purchase_price）作为聚合键对表进
行切分。在GROUP BY子句中指定进货单价的结果请参见代码清单3-14。
代码清单3-14 按照进货单价统计数据行数
SELECT purchase_price, COUNT(*)
FROM Product
GROUP BY purchase_price;
● 94 第3章 聚合与排序
上述SELECT语句的结果如下所示。
执行结果
p urchase_price | count
----------------+-------
聚合键为NULL的结果
| 2
320 | 1
500 | 1
5000 | 1
2800 | 2
790 | 1
像790日元或者500日元这样进货单价很清楚的数据行不会有什么问
题，结果与之前的情况相同。问题是结果中的第一行，也就是进货单价为
NULL的组。从结果我们可以看出，当聚合键中包含NULL时，也会将
NULL作为一组特定的数据，如图3-6所示。
图3-6 按照进货单价对表进行切分
320日元(1条) 2800日元(2条)
打孔器 运动T恤
菜刀 790日元(1条)
500日元(1条) 擦菜板
T恤衫
NULL(2条)
5000日元(1条)
叉子
高压锅
圆珠笔
这里的NULL，大家可以理解为“不确定”。
法则3-8
聚合键中包含NULL时，在结果中会以“不确定”行（空行）的形式表现出来。
使用 子句时 的执行结果
WHERE GROUP BY
在使用了GROUP BY子句的SELECT语句中，也可以正常使用
WHERE子句。子句的排列顺序如前所述，语法结果如下所示。
3-2 对表进行分组 95 ●
语法3-2 使用WHERE子句和GROUP BY子句进行汇总处理
SELECT , , , ……
FROM 
WHERE
GROUP BY , , , ……;
像这样使用WHERE子句进行汇总处理时，会先根据WHERE子句指
定的条件进行过滤，然后再进行汇总处理。请看代码清单3-15。
代码清单3-15 同时使用 子句和 子句
WHERE GROUP BY
SELECT purchase_price, COUNT(*)
FROM Product
WHERE product_type = '衣服'
GROUP BY purchase_price;
因为上述SELECT语句首先使用了WHERE子句对记录进行过滤，
所以实际上作为聚合对象的记录只有2行，如表3-1所示。
表3-1 WHERE子句过滤的结果
product_type product_name product_id sale_price purchase_price regist_date
（商品种类） （商品名称） （商品编号）（销售单价） （进货单价） （登记日期）
衣服 T恤衫 0001 1000 500 2009-09-20
衣服 运动T恤 0003 4000 2800
使用进货单价对这2条记录进行分组，就得到了如下的执行结果。
执行结果
p urchase_price | count
----------------+------
500 | 1
2800 | 1
GROUP BY和WHERE并用时，SELECT语句的执行顺序如下所示。
GROUP BY和WHERE并用时SELECT语句的执行顺序 ▲
FROM → WHERE → GROUP BY → SELECT
这与之前语法3-2中的说明顺序有些不同，这是由于在SQL语句中，
书写顺序和DBMS内部的执行顺序并不相同。这也是SQL难以理解的原
因之一。
● 96 第3章 聚合与排序
与聚合函数和 子句有关的常见错误
GROUP BY
截至目前，我们已经学习了聚合函数和GROUP BY子句的基本使用
方法。虽然由于使用方便而经常被使用，但是书写SQL时却很容易出错，
希望大家特别小心。
■常见错误① ——在 子句中书写了多余的列
SELECT
在使用COUNT这样的聚合函数时，SELECT子句中的元素有严格
的限制。实际上，使用聚合函数时，SELECT子句中只能存在以下三种
元素。
● 常数
● 聚合函数
● GROUP BY子句中指定的列名（也就是聚合键）
第1章中我们介绍过，常数就是像数字123，或者字符串'测试'这
样写在SQL语句中的固定值，将常数直接写在SELECT子句中没有任何
问题。此外还可以书写聚合函数或者聚合键，这些在之前的示例代码中都
已经出现过了。
这里经常会出现的错误就是把聚合键之外的列名书写在SELECT子
句之中。例如代码清单3-16中的SELECT语句就会发生错误，无法正常
执行。
代码清单3-16 在SELECT子句中书写聚合键之外的列名会发生错误
SELECT product_name, purchase_price, COUNT(*)
FROM Product
GROUP BY purchase_price;
执行结果（使用PostgreSQL的情况）
ERROR：列"product,product_name"必须包含在GROUP BY子句之中，或者必须在聚合 
函数内使用
注A 行 1: SELECT product_name, purchase_price, COUNT(*)
不过，只有MySQL认同这种语法，
所以能够执行，不会发生错误（在 表示下一行接续本行，只是由于版面所限而换行。
多列候补中只要有一列满足要求
就可以了）。但是MySQL以外的 列名product_name并没有包含在GROUP BY子句当中。因此，
DBMS都不支持这样的语法，因此
请不要使用这样的写法。 该列名也不能书写在SELECT子句之中A。
3-2 对表进行分组 97 ●
不支持这种语法的原因，大家仔细想一想应该就明白了。通过某个聚
合键将表分组之后，结果中的一行数据就代表一组。例如，使用进货单价
将表进行分组之后，一行就代表了一个进货单价。问题就出在这里，聚合
键和商品名并不一定是一对一的。
例如，进货单价是2800日元的商品有“运动T恤”和“菜刀”两种，
但是2800日元这一行应该对应哪个商品名呢（图3-7）？如果规定了哪种
商品优先表示的话则另当别论，但其实并没有这样的规则。
图3-7 聚合键和商品名不是一对一的情况
p roduct_name | purchase_price | count
-------------+---------------+------
| 2800 | 2
这里应该显示什么好呢？
像这样与聚合键相对应的、同时存在多个值的列出现在SELECT子
句中的情况，理论上是不可能的。
法则3-9
使用GROUP BY子句时，SELECT子句中不能出现聚合键之外的列名。
■常见错误② ——在 子句中写了列的别名
GROUP BY
这也是一个非常常见的错误。在2-2节中我们学过，SELECT子句中
的项目可以通过AS关键字来指定别名。但是，在GROUP BY子句中是
注A 不能使用别名的。代码清单3-17中的SELECT语句会发生错误A。
需要注意的是，虽然这样的写法
在PostgreSQL和MySQL都不会发 代码清单3-17 GROUP BY子句中使用列的别名会引发错误
生执行错误，但是这并不是通常
的使用方法 SELECT product_type AS pt, COUNT(*)
FROM Product
GROUP BY pt; 在GROUP BY子句中使用在
SELECT子句中定义的别名
上述语句发生错误的原因之前已经介绍过了，是SQL语句在DBMS
内部的执行顺序造成的——SELECT子句在GROUP BY子句之后执行。
在执行GROUP BY子句时，SELECT子句中定义的别名，DBMS还并
不知道。
使用本书提供的PostgreSQL执行上述SQL语句并不会发生错误，而
● 98 第3章 聚合与排序
会得到如下结果。但是这样的写法在其他DBMS中并不是通用的，因此
请大家不要使用。
执行结果（使用PostgreSQL的情况）
pt | count
-------------+------
衣服 | 2
办公用品 | 2
厨房用具 | 4
法则3-10
在GROUP BY子句中不能使用SELECT子句中定义的别名。
■常见错误③ —— 子句的结果能排序吗
GROUP BY
GROUP BY子句的结果通常都包含多行，有时可能还会是成百上千
行。那么，这些结果究竟是按照什么顺序排列的呢？
答案是：“随机的。”
我们完全不知道结果记录是按照什么规则进行排序的。可能乍一看是
按照行数的降序或者聚合键的升序进行排列的，但其实这些全都是偶然的。
当你再次执行同样的SELECT语句时，得到的结果可能会按照完全不同
的顺序进行排列。
通常SELECT语句的执行结果的显示顺序都是随机的，因此想要按
KEYWORD 照某种特定顺序进行排序的话，需要在SELECT语句中进行指定。具体
●排序
的方法将在本章第4节中学习。
法则3-11
GROUP BY子句结果的显示是无序的。
■常见错误④ ——在 子句中使用聚合函数
WHERE
最后要介绍的是初学者非常容易犯的一个错误。我们还是先来看一下
之前提到的按照商品种类（product_type列）对表进行分组，计算
每种商品数据行数的例子吧。SELECT语句如代码清单3-18所示。
3-2 对表进行分组 99 ●
代码清单3-18 按照商品种类统计数据行数
SELECT product_type, COUNT(*)
FROM Product
GROUP BY product_type;
执行结果
product_type | count
--------------+-------
衣服 | 2
办公用品 | 2
厨房用具 | 4
如果我们想要取出恰好包含2行数据的组该怎么办呢？满足要求的是
“办公用品”和“衣服”。
想要指定选择条件时就要用到WHERE子句，初学者通常会想到使用
代码清单3-19中的SELECT语句吧。
代码清单3-19 在WHERE子句中使用聚合函数会引发错误
SELECT product_type, COUNT(*)
FROM Product
WHERE COUNT(*) = 2
GROUP BY product_type;
遗憾的是，这样的SELECT语句在执行时会发生错误。
执行结果（使用PostgreSQL的情况）
ERROR: 不能在WHERE子句中使用聚合
行 3: WHERE COUNT(*) = 2
^
实际上，只有SELECT子句和HAVING子句（以及之后将要学到的
ORDER BY子句）中能够使用COUNT等聚合函数。并且， HAVING子
句可以非常方便地实现上述要求。下一节我们将会学习HAVING子句。
法则3-12
只有SELECT子句和HAVING子句（以及ORDER BY子句）中能够使用聚合函数。
● 100 第3章 聚合与排序
专 栏
和
DISTINCT GROUP BY
细心的读者可能会发现，3-1节中介绍的DISTINCT和3-2节介绍的GROUP
BY子句，都能够删除后续列中的重复数据。例如，代码清单3-A中的2条SELECT
语句会返回相同的结果。
代码清单3-A DISTINCT和GROUP BY能够实现相同的功能
SELECT DISTINCT product_type
FROM Product;
SELECT product_type
FROM Product
GROUP BY product_type;
执行结果
product_type
--------------
衣服
办公用品
厨房用具
除此之外，它们还都会把NULL作为一个独立的结果返回，对多列使用时也会
注A 得到完全相同的结果。其实不仅处理结果相同，执行速度也基本上差不多A ，那
它们都是数据的内部处理，都是 么到底应该使用哪一个呢？