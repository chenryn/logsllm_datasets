# 24｜条形、饼状、柱状图最适合用在什么场景下？你好，我是尹会生。 提起图表，你一定会想到 Excel 和 PPT中的条形图、饼状图、柱状图，这在我们进行工作汇报的时候会经常用到，是我们最经常打交道的图表了。除此之外，还有很多其他种类的图表，比如折线图、热力图等等。 但是，不管你通过哪一种图表，它们都是为了让你能够更直观、更简洁地表达自己的想法，也能让我们更好地从一堆杂乱无章的数字中找出规律。 虽然图表比直接展示数据多了这么多优势，但是也存在一个问题，那就是使用Excel制作一张精美的图表，需要消耗大量的时间。而且这些精美的图表，如果因为临时需要再加载新的数据，又要重复花费时间来制作。别担心，这些问题都可以通过Python 中的 seaborn 库来解决。 所以在今天这节课当中，我就来教你怎么使用 seaborn库实现图表的重复生成，并根据不同的场景使用不同类型的图表。 生成统一风格的图表在 Python 的图表库中，最著名的库叫做matplotlib，它的语法简单，而且支持的图表类型丰富，是数据分析场景中经常用到的图表工具。 但是如果你直接把它应用到办公自动化场景中，虽然 matplotlib的功能是强大的，不过美观程度相对就比较差了。因此，我今天就带你学习一个基于matplotlib 库，并且在外观上进行了优化的扩展库，叫做 seaborn，它能弥补matplotlib 在外观上的不足。 那么接下来，我就以为鸢尾花分类为例，为你讲解一下 seaborn库的安装，以及绘图的基本流程。 鸢尾花分类是深度学习用于自动分类的经典问题。我们使用它的数据集是因为它的数据量适中，而且包含了必备的花萼和花瓣的长宽数据，以及长宽数据对应的三个品种的鸢尾花。既能通过seaborn观察到分类结果，又能将用于绘图的代码应用到自己的工作场景中。 用 seaborn 生成图表的基本流程seaborn 库的安装非常简单，由于它的安装包和软件同名，所以使用 pip命令安装即可。安装之后，就可以使用它来生成图表了。你可以按照导入库、设置图表样式、绘制图形三个步骤来实现图表绘制功能。我们来依次学习一下。 **首先是导入库**。在这一步骤中，你需要格外注意**导入 seaborn库的名称，以及导入的方法。** 由于 seaborn 的功能是基于 matplotlib实现的图表基本绘制功能，所以这两个库必须都要导入，否则就没法生成图表。 在导入的方法上，我发现导入库的名字很长，这就意味这你在调用库的时候也需要输入比较长的字符。因此我在导入的时候增加了一个"as"关键字，它可以将库的名称简写为更简单的"别名"，以此来简化代码的编写。你需要注意，别名要尽可能有意义，而且不要和保留字或当前代码中的变量重复，以免引发运行时的报错。 在导入库的代码中，我为名字比较长的两个库分别起了新的名字叫"sns"和"plt"，那么当前代码就可以利用"sns.XXX"和"plt.XXX"的方式导入这两个库的代码了，这样会比使用原始的名字更精简。 我把导入库的代码写在下方，供你参考。     import seaborn as sns    import matplotlib.pyplot as plt**接下来是设置图表样式**。图表样式是由工作场景确定的，包括背景样式和图表的类型。同时在这一步骤，你还要为图表加载数据。所以设置图表样式是seaborn 库绘图最关键的部分。 图表样式由背景风格和图表类型两部分组成。 我们先来说风格。风格其实包含了背景色、字体、字形等样式，它们是图表展示时最底层的样子。而这些风格样式通通由seaborn.set()函数的参数控制，所以一旦其中任意一个参数发生了变化，那绘图的效果也会发生变化。 不过由于设置风格的参数比较多，自由组合并展示到用户面前的话，界面不一定会美观，这也会违背我们使用seaborn生成图表的初衷，因此我们需要经过精心调整样式的搭配。那怎么来搭配它们最合理呢？ 其实你不必纠结，去逐一尝试每个参数，因为在 seaborn 的 set()函数的参数中提供了五种默认风格，这五种风格不说满足特别高的审美要求，但是在一般绘图中，它的美观程度还是可圈可点的。五种默认风格分别是："darkgrid""whitegrid""dark""white""ticks"，它们分别代表了"暗黑网格""白色网格""暗黑无网格""白色无网格""空白背景"，这五种风格可以通过set() 函数的 style关键字参数来指定。 如果你想在这五种默认风格上继续修改，就可以在指定风格后，通过 set()函数的其他参数继续进行修改。我把 set()函数的参数提供给你，方便你在工作中找到适合你的图表风格。如下：     seaborn.set(context='notebook', style=''darkgrid', palette=''deep'', font='sans-serif', font_scale=1, color_codes=True, rc=None)我们再来看图表类型。图表类型是由工作场景来决定的。例如：我想根据花瓣的长宽度，以及花萼的长宽度数据，通过图表来区分三种花的类型。因此我需要一种图形来表示花瓣和花萼的长短分布情况。 显然，我们是希望能根据花瓣和花萼的长短宽窄来得到分布情况，而不是观察变化趋势，因此我会采用散点图，而不是折线图来表达花的数据。那么散点图的绘制，是通过函数seaborn.pairplot()来实现图表类型的设定的。 seaborn.pairplot()函数不但能够指定图表类型，还能为图表加载数据和设置图表的类型、点样式。主要包括三部分，分别是加载的数据源、指定图表类型以及该类型需要绘制的点的样式。 第一部分，加载的数据源，数据源可以由二维元组组成类似 Excel一样的多行多列的数据，数据中的第一行和第一列会作为标题，被 seaborn自动处理。我在代码中使用了示例数据"鸢尾花分类"来为你展示数据的加载。 它的示例数据是通过 seaborn.load_dataset()函数导入的，这个函数会自动访问 GitHub 下载数据。如果你无法访问GitHub，我就再为你提供一个示例数据的镜像站。除了鸢尾花数据外，镜像站这里还包括房产价格预测等经典示例数据，你可以利用它们来学习不同的图表。我把示例数据的地址slate-object="inline"放在这里，另外，我把部分示例数据也贴在下方，供你参考：        sepal_length  sepal_width  petal_length  petal_width    species    0             5.1          3.5           1.4          0.2     setosa    1             4.9          3.0           1.4          0.2     setosa    2             4.7          3.2           1.3          0.2     setosa    3             4.6          3.1           1.5          0.2     setosa    4             5.0          3.6           1.4          0.2     setosa    ..            ...          ...           ...          ...        ...    145           6.7          3.0           5.2          2.3  virginica    146           6.3          2.5           5.0          1.9  virginica    147           6.5          3.0           5.2          2.0  virginica    148           6.2          3.4           5.4          2.3  virginica    149           5.9          3.0           5.1          1.8  virginica我再来为你解释一下示例数据。它是由五列组成的，分别表示鸢尾花的花萼长度、宽度，鸢尾花的花瓣长度、宽度（你可以通过百度来搜索鸢尾花的图片，来了解什么是花萼的长宽，什么是花瓣的长宽），以及三种鸢尾花品种（setosa山鸢尾，versicolor 杂色鸢尾，virginica维吉尼亚鸢尾）。我通过散点图的方式采用不同维度展示花的特性，让你能根据颜色把三种花区分出来。 第二部分是指定图表类型，它是由"kind = \'scatter\'"参数指定的。因为pairplot() 函数支持散点图和回归图(kind=\'reg\')，我们需要关注分布情况，所以使用了散点图的方式来展示数据。 第三部分是点的样式。绘制的散点图中的每个点，也可以单独设置它们的样式。例如我指定了每个点的大小"height=2"，以及指定了色彩样式"palette=\'husl\'"，并为每个列指定不同的颜色"hue= \'species\'"。 以上是如何设置图表的样式的核心代码，为了让你更好地理解设置的参数，我将这一步骤的代码一并写在下方，供你参考。     
# 设置背景    sns.set(style="darkgrid", color_codes=True)    
# 使用示例数据    iris = sns.load_dataset('iris',data_home='seaborn-data',cache=True)    