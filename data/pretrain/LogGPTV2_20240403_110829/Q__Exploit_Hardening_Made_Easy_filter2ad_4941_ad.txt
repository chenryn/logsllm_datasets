The symbolic jump expression from symbolic execution
of the program is 2 ∗ s1. α for this program would be
2 ∗ s1 = targetExp.
For a typical
stack exploit, targetExp =
&(shellcode), where & means the address of. With
a return oriented payload,
this would usually be
targetExp = &(ret). This assumes that the ROP
payload is located in memory at the address in %esp.
If not, Q can use a pivot, which its ROP system
can automatically ﬁnd. For instance, targetExp =
&(xchg %eax, %esp; ret) would transfer control
to the ROP payload pointed to by %eax.
5.2.2 Assuring Computation
Computation constraints
Computation constraints ensure that the computation pay-
load is available in memory at the proper address at
the time of exploitation. For instance, computation con-
straints for a strcpy buffer overﬂow would be unsatisﬁ-
able for a payload containing a null byte, since this would
result in only part of the payload being copied.
take the form Σ =
(mem[payloadBase] = payload[0] ∧ . . . ∧
mem[payloadBase + n] = payload[n]), where
payloadBase denotes the starting address of the pay-
load in memory, and payload denotes the bytes in the
payload (e.g., the ROP payload from Section 4). When
using a basic ROP payload, payloadBase will be set
to %esp, since that is where a ret will start executing.
When using a pivot, this value will depend on the pivot in
the natural way.
5.2.3 Finding an Exploit
By combining these constraints with Π, which only holds
for inputs following the vulnerable path, we can create a
10
constraint formula that only describes exploits along the
vulnerable path:
Π ∧ α ∧ Σ.
(2)
Any assignment to the initial program state that satisﬁes
this constraint formula is an exploit for the program se-
mantics recorded in the trace. We use an off the shelf
decision procedure, STP [19], to solve the formulas.
6
Implementation
The ROP component (Section 4) of Q is built on top
of the BAP framework [3]. The implementation for the
gadget discovery, arrangement, and assignment phases
comprises 4,585 lines of ML code. The ROP system uses
the STP [19] decision procedure to determine the validity
of generated weakest preconditions.
Q’s exploit hardening component (Section 5) itself con-
sists of a tracing (recording) component and an analysis
component. We implemented the tracing tool using the
Pin [28] framework, which allows analysis code to in-
strument a running process and take measurements in
between instruction execution. Our tool is optimized to
only record instructions that are considered to be user-
derived; the user can mark any input coming from ﬁles,
network sockets, environment variables, or program ar-
guments as being user-derived, and can record processes
that fork (e.g., network daemons). The tracing component
is written in C++, and includes 2,102 lines of code written
for this project.
The analysis portion of the hardening system is imple-
mented in the BAP [3] framework. It consists of com-
ponents that 1) lift the recorded assembly instructions
into the BAP intermediate language, 2) symbolically exe-
cute the trace, obtaining the constraint formula Π, and 3)
compute the constraints α and Σ. Our analysis tool then
uses STP [19] to ﬁnd a satisfying answer to the resulting
constraint formula, and uses the result to build an exploit.
It also fully understands Windows SEH (structured excep-
tion handler) exploits, in which the exception handler is
overwritten. The analysis implementation is written in
ML, and includes 1,090 new lines of code for this project.
All components of Q are fully capable of reasoning
about Windows and Linux binaries.
7 Evaluation
7.1 Return Oriented Programming
Applicability We would like to know how often Q can
build ROP payloads when given a random source program
P . To evaluate this, we ran Q on all of the 1,298 ELF
programs in /usr/bin on an author’s Ubuntu 9.10 desk-
top machine and tried to generate various return oriented
payloads. We then discarded the results for the 66 pro-
grams that were marked as ASLR-compatible (PIE). We
used Linux programs for our corpus because it is easier to
gather a typical set of Linux programs than for Windows.
For each program P , we consider if Q can create a ROP
payload to:
Call functions also called by P External
functions
called by P have an entry in the program’s Proce-
dure Linkage Table (PLT). Q calls the PLT entries
directly; if the external function has not been loaded,
the dynamic loader will be invoked to load it before
transferring control to the called function.
Call external functions in libc Calling external func-
tions that do not have a PLT entry is more com-
plicated. For this, we build on a technique for cal-
culating the address of functions in libc even when
libc is randomized [39]. This involves more compu-
tation than the above case, and so is more likely to
be unsatisﬁable.
Write to memory We consider a payload that writes
four bytes to an arbitrary address.
For each of the target programs above, we measure
whether our system can create a payload for it using in-
struction sequences taken from each source program in
our corpus. We consider an attempt successful if our sys-
tem successfully builds a payload. Note that the attacker
must still ﬁnd a way to load the payload into memory and
redirect control to it for it to be used as an exploit.
The results of this experiment are shown in Figure 4.
The probability of success for the above payload types is
plotted as a function of source program size. The Call/-
Store line represents the Call functions also called by P
and Write to memory cases above, since the results are
visually indistinguishable. The Call (libc) line represents
Call external functions in libc.
The results support the claim that ROP is more difﬁcult
when there is less binary code. Even so, Q is able to
call linked functions and store arbitrary memory bytes
to arbitrary locations in 80% of binaries that are at least
20KB. Q can also call any function in libc in 80% of
binaries 100KB or larger6.
We evaluate Q’s capabilities to produce ROP payloads
and harden exploits in this section.
6The fact that Q generated payloads for so many binaries was dis-
turbing to the author whose machine the programs came from.
11
Figure 4: The probability that Q can generate various payload types, shown as a function of source ﬁle size. As expected,
the probability grows with ﬁle size. The percentage is calculated over non position independent executables. Q can call
linked functions in 80% of programs that are 20KB or larger, and can call any function in linked shared libraries in 80%
of programs that are at least 100KB in size.
Efﬁciency While we found that semantic gadget discov-
ery techniques are useful for ﬁnding gadgets, they are not
very fast. In our implementation, we found that adding a
concrete randomized testing stage increased Q’s perfor-
mance. To measure this, we collected a random sample of
32 programs from our /usr/bin dataset and ran gadget
discovery. For each program, we ran Q twice, once with
randomized testing enabled, and once disabled. Figure 5
shows a boxplot of the elapsed wall times when running
with 16 active threads. (The time difference would be
greater with fewer threads, but the experiment would take
a very long time to complete for the non-randomized
cases.) As expected, Q runs faster when randomized
testing is enabled.
Figure 5: Boxplots of the time it takes to discover gadgets
from a program for a random sample of 32 programs,
when randomized testing is enabled and disabled.
Sizes Our results from Figure 4 show that larger pro-
grams are generally easier to build return oriented pro-
grams from. Figure 6 shows the sizes of the programs in
our experiments, and compares them to the binaries used
in prior research, libc [38], the iPhone library [16], and
12
the windows kernel [21]. We note that these binaries are
signiﬁcantly larger than most /usr/bin programs.
Gadget Frequency Figure 7 shows the frequency of
various types of gadgets in programs larger than 20KB.7
It offers some insight on why ROP on small binaries
is difﬁcult. The most useful gadget types, like STORE-
MEMG and LOADMEMG, are not very common. Instead,
combined gadgets like ARITHMETICSTOREG are more
prevalent. This is not surprising, given that compilers
try to combine operations to optimize efﬁciency. These
results are what inspired Q’s gadget arrangement system,
which can cope with missing gadget types.
7.2 Exploit Hardening
To evaluate exploit hardening, we tested it with a variety
of publicly available exploits for Linux and Windows.
We consider each experiment a success if Q can harden
a public exploit for real software by producing working
exploits that bypass W⊕X and ASLR. We do not expect
that our system will always produce a hardened exploit.
We compiled each vulnerable program from source
when possible, disabled all defenses (including ASLR and
W⊕X), and then veriﬁed that the exploit at least crashed
the vulnerable program. We then ran the exploit through
the exploit hardening component of Q, and created two
payloads that bypass W⊕X and ASLR. These payloads
1) call a linked function and 2) call system(‘‘w’’)
7These results are after a pre-processing step that throws away re-
dundant gadgets. A gadget g1 is redundant to g2 if they both have the
same type and input registers, and g1 clobbers a superset of the registers
that g2 clobbers. This is why there is only one NOOPG gadget type
listed for all programs, even though every ret instruction can be used
as a NOOPG.
1e+042e+045e+041e+052e+055e+051e+060.30.50.70.9File Size (Bytes)P(Success)Call/StoreCall (libc)GGGW/ Rand.WO/ Rand.05001500SecondsFigure 6: The empirical cumulative distribution function of the ﬁle sizes in /usr/bin. In this graph, a point at (x, y)
means that 100y percent of the ﬁles in /usr/bin have a size less than or equal to x bytes. We also show the sizes of
the iPhone libsystem library [16], libc [38] and the windows kernel [21], which prior work has targeted. libc and the
iPhone library are both larger than 95% of the programs in our corpus, while the windows kernel is larger than 99%.
We plot dotted lines at 20 and 100KB for reference; these are the sizes at which Q works well, as shown in Figure 4.
Figure 7: The frequency of various types of gadgets in /usr/bin programs larger than 20KB.
on Linux or WinExec(‘‘calc.exe’’) on Windows.
We tested these two exploits with ASLR and W⊕X en-
abled. The results of these experiments are shown in
Table 4.
We found that our system was able to harden exploits
for several large, real programs.
In general, our sys-
tem performed as expected: it only output exploits that
worked, and in some cases reported it could not produce
a hardened exploit.
8 Discussion
Ret-less ROP When we designed Q, no one had shown
that ROP was possible without using ret-like instruc-
tions. Since then, Checkoway, et al. have shown [8] that
it is possible to create a Turing-complete gadget set that
does not use ret instructions. Their gadgets have control
ﬂow preservation preconditions. For example, the gadget
pop %eax; jmp *%edx only preserves control ﬂow
if %edx is preset to the next gadget address. Q does not
make any assumptions about the preconditions for a gad-
get when considering control ﬂow preservation, which
prevents it from ﬁnding gadgets of the above form. We
leave it as future work to determine whether it is possible
to automatically construct ROP exploit payloads that do
not use ret instructions.
Side effects Q conservatively handles side effects by
discarding any instruction sequence that might cause
the program to crash, such as a pointer dereference.
As one example, pushl %eax; popl %ebx; ret
will move the value in %eax to %ebx.
Since a
MOVEREGG gadget does not intentionally use memory,
however, Q would discard this gadget. We plan to add a
more advanced memory analysis that can statically detect
when a memory access will be safe, which will allow Q
to use more gadgets.
Turing completeness Q’s language for describing tar-
get programs, QooL, is not Turing-complete. Our early
tests revealed that the ARITHMETICG gadgets needed
for conditional jumps, such as equality tests, were often
unavailable in small programs. As a result, we focused on
the gadgets needed for practical exploitation, rather than
13
0e+001e+062e+063e+064e+065e+066e+060.00.40.8File Size (Bytes)Ratio <= Sizelibcwindows kerneliPhonelibQProgram
Free CD to MP3 Converter
FatPlayer
A-PDF Converter
A-PDF Converter
MP3 CD Converter Pro
rsync
opendchub
gv
proftpd
Reference
OSVDB-69116
CVE-2009-4962
OSVDB-67241
OSVDB-68132
OSVDB-69951
CVE-2004-2093
CVE-2010-1147
CVE-2004-1717
CVE-2006-6563
Tracing
89s
90s
238s
215s
103s
60s
195s
113s
30s
Analysis
41s
43s
140s
142s
55s
5s
30s
124s
10s
Call Linked
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Call System OS
Win
Yes
Win
Yes
Win
Yes
Yes
Win
Win
Yes
Lin
Yes
No
Lin
Lin
Yes
Yes
Lin
SEH
No
Yes
No