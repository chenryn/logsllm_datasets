title:Security Policy Enforcement at the File System Level in the Windows
NT Operating System Family
author:Stephen D. Wolthusen
Security Policy Enforcement at the File System Level in the Windows NT
Operating System Family
Stephen D. Wolthusen
Fraunhofer-IGD
Security Technology Department
Rundeturmstr. 6, Darmstadt 64283, Germany
PI:EMAIL
Abstract
This paper describes the implementation of an enforce-
ment module for ﬁle system security implemented as part
of a security architecture for distributed systems which en-
forces a centrally administered security policy under the
Windows NT operating system platform. The mechanism
provides mandatory access control, encryption, and audit-
ing on an individual ﬁle basis across distributed systems
while being fully transparent to both users and application
programs and functioning regardless of the type of ﬁle sys-
tem or its attachment mechanism.
1. Introduction
Providing security at the ﬁle system level is part of
the basic security functionality provided by virtually all
general-purpose operating systems; however, the limita-
tions of ﬁle system protection only via data structures main-
tained by the operating system have long been obvious. One
problem is that such protection mechanisms require the op-
erating system providing the service to be active. This as-
sumption can be violated in non-networked conﬁgurations
in at least two cases. One case occurs when storage media
are accessed at the local node, but with an operating sys-
tem other than the one enforcing the security mechanisms
(possibly just another instance of the same operating sys-
tem, only conﬁgured differently), the other occurs when the
storage media are exposed; typically another system will
not honor protections set for removable media.
The latter is part of a larger problem one is faced with in
a heterogeneous distributed environment, namely the lack
of enforced conformance to a consistent, centrally enforced
security policy focused on individual data objects instead of
node interrelations. While this can be achieved partially us-
ing current COTS operating systems, it typically requires a
homogeneous network environment and uniﬁed administra-
tion of all nodes in such a network.
What we therefore consider desirable is an architecture
to provide access and use control over data objects at a suf-
ﬁciently high level of abstraction that can be enforced even
if the object (e.g. document) is moved across network node
boundaries, combined with a comprehensive audit trail en-
compassing all operations on these objects. To ensure that
the enforcement mechanisms are honored in case of a ﬁle
system — other areas that must be dealt with are network
and general I/O mechanisms — we propose to use object
labeling in conjunction with encryption at this level as the
tool to achieve this goal.
This enforcement mechanism is part of a larger system
that segregates security policy determination and decisions
based on such policy rules from enforcement [18, 10, 12],
but does so at the level of network nodes, i.e. there exists a
set of servers that provide consistent policy information to
all systems within the protected set of nodes.
This paper concentrates on a description of the imple-
mentation of the ﬁle system security enforcement compo-
nent on the Microsoft Windows NT family of operating sys-
tems; this mechanism has been under ongoing development
by our group since early 1998. First working prototypes
were ﬁnished in 1998; the mechanisms and implementation
have been evolving constantly since.
The background and basic concepts of the system are
discussed in section 2, followed by an overview of the Mi-
crosoft Windows NT ﬁle system I/O architecture in section
3 and a discussion of the implementation of the enforcement
mechanism in section 4.
2. Background
Security architectures and mechanisms reaching beyond
addressing problems found in individual areas such as net-
work security or ﬁle system security have mainly been pur-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:43 UTC from IEEE Xplore.  Restrictions apply. 
sued as implementations of entire operating environments
with security as their focus [13]. While this is desirable
for a number of reasons, particularly a high degree of as-
surance that can be achieved with such an architecture such
as the Flask/Fluke [16] architecture, such an approach is
limited in its immediate appeal since a migration of hosts
and especially application programs to the new environment
would be required. It is, however, imperative that security
mechanims are implemented at the operating system level
to be meaningful [5].
In the design of the architecture described here we have
therefore attempted to ensure that the required security
mechanisms can be retroﬁtted to existing operating sys-
tems. To ensure interoperability with existing COTS and
custom applications, these modiﬁcations and security en-
hancements must be kept invisible to both applications and
users — at least while they are operating within the limits
set by the security policy; due to typically less than robust
error management one must also ensure that failures closely
mimic behavior in case of failures that such applications ex-
pect.
Since the security architecture must function in a hetero-
geneous, networked environment, it is necessary to protect
a number of aspects of the system, namely the ﬁle system,
network, and general I/O mechanisms. One must assume
that each individual node is exposed to a potentially hos-
tile environment and peer nodes which are not necessarily
equipped with the same security enhancements. At the same
time it is necessary to enforce a consistent and concurrent
view of a security policy that is identical across all nodes,
principals and objects under the nominal control of such a
policy.
The architecture described here deals with these issues in
a two-pronged approach. The ﬁrst guiding principle is the
separation of policy from enforcement; consistent enforce-
ment is assured by performing this separation within the
network: nodes called ERMs (externally controlled refer-
ence monitor) provide consistent policy information while
all other nodes enforce this policy at the operating system
level based on decisions either related to the enforcement
subsystem directly from a node distributing policy data and
decisions or as a result of a delegated derived security pol-
icy.
This separation of concern between end nodes enforc-
ing security policy and nodes controlling policy data can
be performed using externally controlled reference moni-
tors (ECRM). Using a proper balance between centralized
decisions and locally delegated security policies, the overall
network load — which is limited by latency, not bandwidth
— can be kept at an acceptable level. Details on the ECRM
mechanism can be found in [18].
The second element of the architectural approach is to
use a layering of abstraction levels when dealing with spec-
General I/O Layer
File System Layer
System Call Layer
Applications/
User/System
Behavior
Network Layer
Figure 1. Layering of Protection Elements
ifying a security policy. To permit a basic protection mech-
anism that can be speciﬁed easily, an outer layer of coarse
granularity is necessary that surrounds the entire node. This
implies all inputs and outputs that are handled by a node,
particularly all network trafﬁc and ﬁle systems regardless
of their type or physical location. Reﬁnement of the lower
granularity controls can then occur by analyzing, modify-
ing, and controlling activities at higher semantical levels
such as sequence analyses of application and user behavior
(see ﬁgure 1). This has several pragmatic beneﬁts, the most
important of which is the reduction in the required mini-
mum complexity of the security policy and the default-deny
stance that can be implemented easily. Other approaches
[2] require a detailed speciﬁcation of permitted behavior of
principals; this can become an issue once reasonably com-
plex application programs (e.g. COTS word processors)
must be ﬁtted into a policy. Details on the layering approach
as well as on networking aspects of this architecture can be
found in [19].
In case of the system component described here, the se-
curity architecture must detect the use of ﬁle systems as op-
posed to direct access to lower-layer interfaces or other ac-
cess semantics and permit ﬁle system mechanisms to cross
the general I/O protection layer (and if necessary, as is e.g.
in the case of ﬁle servers or network attached storage, the
network layer) since policy control in such cases is best en-
forced with the semantic information at the ﬁle system layer
unless an even higher level abstraction layer can be identi-
ﬁed for an operation.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:43 UTC from IEEE Xplore.  Restrictions apply. 
2.1. File System Protection Mechanisms
In the architecture described here, ﬁles (as well as other
objects such as network streams) are afﬁxed with a label
that is handled by the security subsystem and is transparent
to the remainder of the system (i.e. both lower and upper
layer drivers of the host operating system as well as ap-
plication programs and users are oblivious to the labeling
mechanism). These labels are protected against manipula-
tion by being tied to the content (i.e. unique identifying
characteristics) of the object; the actual policy information
is contained in either the ERM node providing policy infor-
mation or is temporarily delegated to the (protected) secu-
rity subsystem, the ECRM. To ensure enforcement even if
the security subsystem is inoperative, automatic encryption
can and should be used on the contents of thus labeled ob-
jects. The encryption mechanism also necessitates the pro-
vision of policy information in case an object is transferred
to another node.
There is one category of ﬁle objects to which labels must
not be afﬁxed; this category consists mainly of ﬁles which
are required for bootstrapping the entire system and which
are accessed prior to the enforcement system being loaded.
Even if such ﬁles were only labeled and not encrypted, this
could lead to unpredictable results.
As a general rule, however, each ﬁle object must carry
an object label even if only to identify the object. Based
on the identity of the ﬁle object, the ECRM can then deter-
mine what – if any – actions must be applied to a given ﬁle
based on the security policy or security policies applicable
to either the object or to an operation.
In a simple implementation this policy could consist only
of enforcing access controls (e.g. discretionary access con-
trol) that are independent of the host operating system and
enforced consistently for identiﬁed objects across an entire
distributed system. An application program or other pro-
cess attempting to access such a ﬁle would be confronted
with an error code matching regular error codes for the op-
erating system.
Security models requiring classiﬁcation can be imple-
mented by specifying a security which requires rewriting
or creation of object labels that assign an object label iden-
tity belonging to an identity class hierarchy reﬂecting the
classiﬁcation level. Other models and mechanisms such as
RBAC and domain and type enforcement are also subsumed
by this mechanism.
However, if enforcing information ﬂow controls is of
concern, mere access control is, as described in section 1,
insufﬁcient even when coupled with mandatory labeling and
classiﬁcation.
Instead, encryption must be used under such circum-
stances. This can be done transparently within the ﬁle sys-
tem protection mechanism, ensuring that only after passing
through a trusted subsystem information is made available
to a process (subject) also under the control of the security
policies being enforced.
For this purpose, as with other decisions regarding op-
erations, the ECRM can – depending on what the overall
security policy dictates – either query an authoritative ERM
for a decision, possibly including key material, or it can re-
sort to consulting a local cache of policy decisions and rules
for which an authoritative ERM has speciﬁed a lifetime.
The ﬁle system layer has access to other important in-
formation. This information correlates users and ﬁles they
are using. We need to distinguish three types of ﬁles. The
ﬁrst type of ﬁle is the executable ﬁle as seen by the op-
erating system. Such executables, which usually consist
of several parts (a main ﬁle and a number of dynamically
loaded shared objects or dynamically linked libraries), can
be identiﬁed and matched against security policy rules con-
taining approved applications. The second type of ﬁle is
harder to identify when located at the ﬁle (operating) sys-
tem layer and involves all scripting languages, i.e. mecha-
nisms that involve ﬁles classiﬁed as non-executable by the
operating system but executed by an intermediate applica-
tion program. This class of applications includes macro lan-
guages found in many applications and has been the source
of a large number of successful attacks. Here only heuris-
tics and elaborate checks can attempt to identify and protect
against malicious code. The third type of ﬁle consists of
plain data objects. This information can be combined with
other information collected at different layers. In particular,
the integration of the ﬁle system layer permits the dynamic
“sandboxing” of applications.
One example of such sandboxing in case of a MLS-like
policy is the dynamic restriction of a process from making
certain network connections once it has accessed a data ob-
ject whose classiﬁcation label does not match with the clas-
siﬁcation of a given network peer. The same mechanism
obviously also is applicable to operations within the node