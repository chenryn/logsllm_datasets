libart.so are totally diﬀerent. Because each base address is uniformly distrib-
uted, the output will have a probability of 0.1. At last, the entropy for the
libart.so library is H(Xlibart.so) = 1. This means, for the ten times execu-
tion of this app, libart.so is mapped into diﬀerent addresses. We calculate
the average entropy for all loaded libraries in application A. It is deﬁned as
. We measure R(A) on a simple app (A) (generated by
R(A) =
(cid:2)
m∈M H(Xm)
|M|
474
M. Sun et al.
Table 3. Entropy analysis results.
App entropy R(A)
Mode
0.005
Original App
BlenderLRM only
0.981
BlenderLRM and BlenderART 0.991
Original App
BlenderLRM
App Redelegation
BlenderLRM+BlenderART
Orginal App
BlenderLRM
BlenderLRM+BlenderART
(with cache)
App Redelegation
BlenderLRM+BlenderART
(without cache)
2,000
1,500
1,000
500
)
s
d
n
o
c
e
s
i
l
l
i
M
(
i
e
m
T
p
u
t
r
a
t
S
s
’
p
p
A
7. 3
9
1, 5
1. 1
4. 3
4. 9
7. 3
4
2
0
8
7
6
5
3
·10
4
5.5
5
4.5
4
3.5
)
B
k
(
e
l
i
F
s
u
t
a
t
s
/
]
d
i
p
[
/
c
o
r
p
/
e
h
t
n
i
S
S
R
m
V
0
2
4
Execution Index
6
8
10
0
1,500
500
Elapsed Time (Milliseconds)
1,000
2,000
Fig. 8. App’s startup time.
Fig. 9. Memory usages at the startup
of apps for diﬀerent setups.
the blank app template of Android Gradle 1.2.3 [2]). App A contains 109 native
libraries at runtime, and 108 of them are shared libraries which are inherited
from zygote. We execute the app without and with Blender protection ten
times respectively, and record the memory layout after the startup stage. Table 3
shows the results of the average entropy. The average entropy of original app,
app with BlenderLRM only, and app with full Blender support are 0.005,
0.981, and 0.991 respectively. The average entropy of the original system is quite
low, which shows that there is nearly no randomness in the original app. After
using Blender with library randomization module, the entropy increases signif-
icantly. When adding with the ART runtime randomization module, the entropy
increases about 0.1. Although the increased entropy of BlenderART is small,
but the security gain is considerably high because of the large range of executable
regions.
5.2 Performance
Startup Time. Because Blender conducts the library and ART randomiza-
tion when app is ﬁrst started, we want to evaluate its overhead in terms of the
startup time delay, which is crucial for user experience. To quantify the startup
time, we conduct experiments on a simple app. We create the app targeting
Android 5.1 with one activity (generated by the app template of Android Gradle
1.2.3 [2]). In the app, we override attachBaseContext methods in the activity
Blender: Self-randomizing Address Space Layout for Android Apps
475
Original App
App with Blender
Table 4. Benchmark scores.
Baseline BlenderLRM Full Blender
CPU
35915
Memory
13900
I/O
2D
3D
5874
330
1967
36480
13846
5893
330
2019
Total
57986
58568
35969
14653
5900
298
1981
58801
0
100
200
300
400
500
Number of Executions
100
95
90
85
)
%
(
e
l
i
F
y
t
i
c
a
p
a
c
/
y
l
p
p
u
s
r
e
w
o
p
e
h
t
n
i
y
t
i
c
a
p
a
C
y
r
e
t
t
a
B
Fig. 10. Battery capacity after multiple
executions.
and log the current time (t1). To accurately calculate the startup elapsed time,
we use a UI/application exerciser (monkey tool) to launch this application and
record the time (t0) by reading the $EPOCHREALTIME value. t1− t0 represents the
elapsed time from launch time into application context. We measure the startup
time of the original app, app only with the bootstrap module (app re-delegation),
app with BlenderLRM, app with the whole Blender without BlenderART
cache, and ﬁnally, app with the optimized Blender with cache. We execute the
app for ten times and record the results. Figure 8 illustrates the startup time
(in millisecond) for each launch and the average numbers of diﬀerent setups.
First, because app re-delegation needs to load the app at runtime, it introduces
about 120 ms overhead. Second, without using the cache, BlenderART needs
to execute code patching for each time. The startup time is about 1.5 s, which is
noticeable by normal users. For the system with cache, the startup time is about
740 ms and incurs about 360 ms overhead, which is comparable with Morula [32].
It is worth noting that, this overhead only aﬀects at the app’s ﬁrst startup time