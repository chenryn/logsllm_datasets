below. Whenever we refer to Mohawk below, we mean
Mohawk conﬁgured with aggressive abstraction-reﬁnement,
unless speciﬁed otherwise. For the policies in Table 2, on av-
erage we needed 2 reﬁnements. The worst-case was for the
policy from our case study, for which we needed 7 reﬁne-
ments.
5.4.1 Results on Complex Policies
The results of our evaluation on complex policies (Set 1)
are contained in Table 2. Our results indicate that Mohawk
scales better than all the competing tools, irrespective of the
complexity of the input policy. BMC scales better than MC,
but still runs out of memory for large policies. RBAC-PAT’s
forward reachability, although slower compared to BMC, is
eﬀective for test suite 1, whose policies are veriﬁable in poly-
nomial time. However, RBAC-PAT’s forward reachability
times out for large policies in test suites 2 and 3. The for-
ward reachability algorithm in RBAC-PAT can be consid-
ered as a specialized model checking algorithm for ARBAC
policies, and scales better than symbolic model checking.
RBAC-PAT’s backward reachability algorithm was faster
compared RBAC-PAT’s forward algorithm for a few small
policies, but gave a segmentation fault for majority of the
policies in all the test suites. It is unclear whether this is be-
cause of a bug in the implementation or if the tool ran out of
memory. Mohawk scales better compared to all the tools,
and is orders of magnitude faster than competing tools for
the larger and more complex policies.
Mohawk (with aggressive abstraction-reﬁnement)
is
slower compared to MC and BMC for small size policies.
This is because these policies are so small that BMC can
analyze them easily, but Mohawk takes multiple iterations
to arrive at the same answer. In other words, the policies
are too simple, and the abstraction-reﬁnement step creates
unnecessary overhead. However, Mohawk’s abstraction-
reﬁnement step can be conﬁgured to be less aggressive
for such policies. We ran Mohawk with less aggressive
abstraction-reﬁnement for the smaller policies and got per-
formance comparable to BMC.
Mohawk is very eﬃcient in ﬁnding errors in all the three
test suites, although each of them belong to a diﬀerent com-
plexity class. This further underlines the eﬀectiveness of the
abstraction-reﬁnement based technique in Mohawk. Also,
having a single technique that can perform well on large real-
world policies that belong to diﬀerent complexity classes is
also useful from the point of view of maintaining and ex-
tending the tool. Furthermore, since our technique is not
tied to speciﬁc model-checking algorithms, it can be used
in conjunction with other algorithms such as RBAC-PAT’s
forward reachability.
5.4.2 Results on Simple Policies
The results of our evaluation on simple policies are sum-
marized in Table 2. The ﬁrst and second policies did not
satisfy separate administration restriction, so we removed
172can assign roles that have the administrative roles as target
and used the modiﬁed policies in our evaluation.
BMC, RBAC-PAT, and Mohawk were eﬀective for all
the three policies. The absolute diﬀerences in time taken to
verify are not very signiﬁcant because they are less than a
second.
Mohawk with aggressive abstraction-reﬁnement is faster
compared to RBAC-PAT’s forward reachability, but slower
compared to BMC and RBAC-PAT’s backward reachabil-
ity for these policies. However, the absolute slow down in
each case is less than a second and is imperceptible to the
user. Mohawk’s slowdown when compared to BMC is ex-
pected because of the small size of the policies. For the third
test case, MC timed out. Both RBAC-PAT and Mohawk
with aggressive abstraction-reﬁnement are slower compared
to BMC, and Mohawk is faster compared to RBAC-PAT’s
forward reachability algorithm and slightly slower compared
to RBAC-PAT’s backward reachability.
6. RELATED WORK
Counter-example guided abstraction reﬁnement was orig-
inally developed in the context of model checking [6]. Since
then the basic idea has been adapted in diﬀerent ways in
the context of bounded model-checking for hardware ver-
iﬁcation [27] and program analysis [4] to verify computer
programs. The idea of abstraction reﬁnement has also
been adapted in the context of solvers for various theories
such as modular and integer linear arithmetic [12]. To the
best of our knowledge, Mohawk is the ﬁrst tool to adapt
the paradigm of abstraction-reﬁnement for ﬁnding errors in
access-control policies.
We can classify veriﬁcation problems in the context of
access control broadly into two categories: state-only, and
with state changes.
The work that falls in state-only considers only a given
state, and veriﬁcation of properties within that state. Ex-
amples of work that fall in this category include those of Jha
et al. [22, 23], Hughes et al. [20], Hu et al. [18], Martin and
Xie [31], Rao et al. [34], Kolovski [26], Zhao et al. [48], and
Fisler et al. [11]. It is conceivable that our approach can be
used in state-only contexts. Indeed, the work of Martin and
Xie [31] considers testing of XACML policies by introduc-
ing what they call faults that are used to simulate common
errors in authoring such policies. However, in this paper,
we focus on access control systems that are characterized as
state-change systems. Consequently, we focus on work that
considers veriﬁcation of such systems.
Plain model-checking approach has also been proposed
for some state-change schemes [47]. As we have shown in
Section 5, plain model checking does not scale adequately
for verifying policies of very large sizes.
Work on safety analysis dates back to the mid-1970’s; the
work by Harrison et al. [17] is considered foundational work
in access control. They were the ﬁrst to provide a charac-
terization of safety. They show also, that safety analysis
for an access matrix scheme with state changes speciﬁed as
commands in a particular syntax is undecidable. Since then,
there has been considerable interest and work in safety, and
more generally, security analysis in the context of various
access control schemes.
Safety analysis in monotonic versions of the HRU scheme
has been studied in [16]. Jones et al. [24] introduced the
Take-Grant scheme, in which safety is decidable in linear
time. Amman and Sandhu consider safety in the context
of the Extended Schematic Protection Model (ESPM) [3]
and the Typed Access Matrix model [37]. Budd [5] and
Motwani et al. [32] studied grammatical protection systems.
Soshi et al. [45] studied safety analysis in Dynamic-Typed
Access Matrix model. These models all have subcases where
safety is decidable. Solworth and Sloan [44] introduced dis-
cretionary access control model in which safety is decidable.
This thread of research has proposed many new access con-
trol schemes, but has had limited impact on access control
systems used in practice. This is potentially because the pro-
posals were either too simplistic or too arcane to be useful.
The focus of this paper is ARBAC, which was primarily pro-
posed to meet the need of expressive access control schemes
required for large-scale real-world deployments.
To our knowledge, Li and Tripunitara [29] were the ﬁrst
to consider security analysis in the context of ARBAC. Jha
et al. [21] were the ﬁrst to consider the use of model check-
ing to for the veriﬁcation problem of ARBAC. That work
also identiﬁes that the veriﬁcation problem for ARBAC is
PSPACE-complete. Subsequently, Stoller et al. [46] estab-
lished that user-role reachability analysis is ﬁxed parameter
tractable with respect to number of mixed roles, irrevocable
roles, positive preconditions, and goal size. Furthermore,
they have proposed new model-checking algorithms for sim-
ilar veriﬁcation problems and implemented them in a tool
called RBAC-PAT [13].
RBAC-PAT contains two algorithms for analyzing AR-
BAC policies, namely forward reachability and backward
reachability. As we have shown in Section 5, forward reach-
ability algorithm scales better compared to plain model
checking, is eﬀective for polynomial time veriﬁable policies,
but does not scale adequately with complexity of the poli-
cies. We could not extensively evaluate the backward reach-
ability algorithm because the implementation gave a seg-
mentation fault for even moderately sized policies. In con-
trast, Mohawk scales better and is eﬃcient for identifying
errors irrespective of the complexity of the policies. The
key reason for Mohawk’s eﬀectiveness is the abstraction-
reﬁnement approach that is goal oriented and optimally
looks short paths that lead from the start path to the er-
ror state (Section 4.2).
Gofman et. al. [14] proposes incremental algorithms for
analyzing the impact of changes to ARBAC policies by tak-
ing advantage of previous analysis results. Such incremental
analysis is outside the scope of this paper.
7. CONCLUSION
We presented an abstraction-reﬁnement based technique,
and its implementation, the Mohawk tool, for ﬁnding er-
rors in ARBAC access-control policies. Mohawk accepts
an access-control policy and a safety question as input, and
outputs whether or not an error is found. We extensively
evaluated Mohawk against current state-of-the-art tools for
policy analysis. Our experiments show that in comparison
with the current tools, Mohawk scales very well with the
complexity of policies and is also orders of magnitude faster.
Analysis tools such as Mohawk enable policy administra-
tors to quickly analyze policies prior to deployment, thereby
increasing the assurance of the system.
173Acknowledgements
We thank Mikhail Gofman, Scott Stoller, C. R. Ramakrish-
nan, and Ping Yang for providing access to the RBAC-PAT
tool and their experimental data.
8. REFERENCES
[1] Aveska. http://www.aveksa.com/solutions/access-control-
automation.cfm.
[2] SailPoint. http://www.sailpoint.com/product/compliance-
manager/policy-enforcement.php.
[3] P. Ammann and R. Sandhu. Safety analysis for the extended
schematic protection model. IEEE Symposium on Security
and Privacy, 1991.
[4] T. Ball and S. K. Rajamani. The SLAM project: debugging
system software via static analysis. In POPL ’02: Proc. of the
29th ACM symposium on Principles of programming
languages, New York, NY, USA, 2002. ACM.
[5] T. A. Budd. Safety in grammatical protection systems. Intl.
Journal of Parallel Programming, 12(6):413–431, 1983.
[6] E. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith.
Counterexample-guided abstraction reﬁnement for symbolic
model checking. J. ACM, 50(5):752–794, 2003.
[7] E. Clarke, D. Kroening, J. Ouaknine, and O. Strichman. The
completeness threshold for bounded model checking.
[8] E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking.
The MIT Press, 1999.
[9] J. Crampton and G. Loizou. Administrative scope: A
foundation for role-based administrative models. ACM Trans.
Inf. Syst. Secur., 6(2):201–231, 2003.
[10] D. F. Ferraiolo, D. R. Kuhn, and R. Chandramouli. Role-Based
Access Control. Artech House, Inc., Norwood, MA, USA, 2003.
Annual Symposium on Foundations of Computer Science,
Washington, DC, USA, 1976. IEEE Computer Society.
[25] A. Kern. Advanced features for enterprise-wide role-based
access control. In ACSAC ’02: Proc. of the 18th Annual
Computer Security Applications Conference, Washington,
DC, USA, 2002. IEEE Computer Society.
[26] V. Kolovski, J. Hendler, and B. Parsia. Analyzing web access
control policies. In WWW ’07: Proc. of the 16th Intl.
conference on World Wide Web, 2007. ACM.
[27] D. Kroening. Computing over-approximations with bounded
model checking. Electron. Notes Theor. Comput. Sci.,
144:79–92, January 2006.
[28] N. Li, J. C. Mitchell, and W. H. Winsborough. Beyond
proof-of-compliance: security analysis in trust management. J.
ACM, 52(3):474–514, 2005.
[29] N. Li and M. V. Tripunitara. Security analysis in role-based
access control. In SACMAT ’04: Proc. of the ninth ACM
symposium on Access control models and technologies, New
York, NY, USA, 2004. ACM.
[30] N. Li and M. V. Tripunitara. Security analysis in role-based
access control. ACM Trans. Inf. Syst. Secur., 9(4):391–420,
2006.
[31] E. Martin and T. Xie. A fault model and mutation testing of
access control policies. In WWW ’07: Proc. of the 16th Intl.
conference on World Wide Web, 2007. ACM.
[32] R. Motwani, R. Panigrahy, V. Saraswat, and
S. Ventkatasubramanian. On the decidability of accessibility
problems (extended abstract). In STOC ’00: Proc. of the
thirty-second annual ACM symposium on Theory of
computing, New York, NY, USA, 2000. ACM.
[33] NuSMV. http://nusmv.irst.itc.it/.
[34] P. Rao, D. Lin, and E. Bertino. XACML function annotations.
In POLICY ’07: Proc. of the Eighth IEEE Intl. Workshop
on Policies for Distributed Systems and Networks,
Washington, DC, USA, 2007. IEEE Computer Society.
[11] K. Fisler, S. Krishnamurthi, L. A. Meyerovich, and M. C.
[35] J. H. Saltzer and M. D. Schroeder. The protection of
Tschantz. Veriﬁcation and change-impact analysis of
access-control policies. In ICSE ’05: Proc. of the 27th Intl.
conference on Software engineering, 2005. ACM.
[12] V. Ganesh and D. L. Dill. A decision procedure for bitvectors
and arrays. In Computer Aided Veriﬁcation,LNCS, 2007.
information in computer systems. Proc. of the IEEE, 1975.
[36] R. Sandhu, V. Bhamidipati, and Q. Munawer. The arbac97
model for role-based administration of roles. ACM Trans. Inf.
Syst. Secur., 2(1):105–135, 1999.
[37] R. S. Sandhu. The typed access matrix model. In Proc. IEEE
[13] M. I. Gofman, R. Luo, A. C. Solomon, Y. Zhang, P. Yang, and
Symposium on Research in Security and Privacy, 1992.
S. D. Stoller. Rbac-pat: A policy analysis tool for role based
access control. In Proc. of the 15th Intl. Conference on Tools
and Algorithms for the Construction and Analysis of
Systems (TACAS), volume 5505, Springer-Verlag, 2009.
[14] M. I. Gofman, R. Luo, and P. Yang. User-role reachability
analysis of evolving administrative role based access control. In
Proc. of the 15th European conference on Research in
computer security, Berlin, Heidelberg, 2010. Springer-Verlag.
[15] G. S. Graham and P. J. Denning. Protection — principles and
practice. In Proc. of the AFIPS Spring Joint Computer
Conference, volume 40, AFIPS Press, May 1972.
[16] M. A. Harrison and W. L. Ruzzo. Monotonic protection
systems. Foundations of Secure Computation, 1978.
[17] M. A. Harrison, W. L. Ruzzo, and J. D. Ullman. On protection
in operating systems. In SOSP ’75: Proc. of the ﬁfth ACM
symposium on Operating systems principles, 1975. ACM.
[18] H. Hu and G. Ahn. Enabling veriﬁcation and conformance
testing for access control model. In SACMAT ’08: Proc. of
the 13th ACM symposium on Access control models and
technologies, New York, NY, USA, 2008. ACM.
[19] V. C. Hu, D. R. Kuhn, and T. Xie. Property veriﬁcation for
generic access control models. In EUC ’08: Proc. of the 2008
IEEE/IFIP Intl. Conference on Embedded and Ubiquitous
Computing, 2008. IEEE Computer Society.
[20] G. Hughes and T. Bultan. Automated veriﬁcation of access
control policies using a sat solver. Int. J. Softw. Tools
Technol. Transf., 10(6):503–520, 2008.
[21] S. Jha, N. Li, M. Tripunitara, Q. Wang, and W. Winsborough.
Towards formal veriﬁcation of role-based access control
policies. IEEE Trans. Dependable Secur. Comput.,
5(4):242–255, 2008.
[22] S. Jha and T. W. Reps. Model Checking SPKI/SDSI. Journal
of Computer Security, 12(3–4):317–353, 2004.
[23] S. Jha, S. Schwoon, H. Wang, and T. Reps. Weighted
Pushdown Systems and Trust-Management Systems. In Proc.
of TACAS, New York, NY, USA, 2006. Springer-Verlag.
[24] A. K. Jones, R. J. Lipton, and L. Snyder. A linear time
algorithm for deciding security. In SFCS ’76: Proc. of the 17th
[38] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman.
Role-based access control models. IEEE Computer,
29(2):38–47, 1996.
[39] A. Sasturkar, P. Yang, S. D. Stoller, and C. Ramakrishnan.
Policy analysis for administrative role based access control. In
Proc. of the 19th Computer Security Foundations Workshop.
IEEE Computer Society Press, July 2006.
[40] A. Sasturkar, P. Yang, S. D. Stoller, and C. Ramakrishnan.
Policy analysis for administrative role based access control.
Technical report, Stony Brook University, 2006.
[41] A. Schaad, J. Moﬀett, and J. Jacob. The role-based access
control system of a european bank: a case study and
discussion. In SACMAT ’01: Proc. of the sixth ACM
symposium on Access control models and technologies, New
York, NY, USA, 2001. ACM.
[42] Security Architect of a Leading Bank. Personal
communication, 2010.
[43] K. Sohr, M. Drouineaud, G.-J. Ahn, and M. Gogolla.
Analyzing and managing role-based access control policies.
IEEE Transactions on Knowledge and Data Engineering,
20:924–939, 2008.
[44] J. A. Solworth and R. H. Sloan. A layered design of
discretionary access controls with decidable safety properties.
IEEE Symposium on Security and Privacy, 2004.
[45] M. Soshi. Safety analysis of the dynamic-typed access matrix
model. In Computer Security - ESORICS 2000, LNCS,
Springer Berlin / Heidelberg, 2000.
[46] S. D. Stoller, P. Yang, C. R. Ramakrishnan, and M. I. Gofman.
Eﬃcient policy analysis for administrative role based access
control. In CCS ’07: Proc. of the 14th ACM conference on
Computer and communications security, 2007. ACM.
[47] N. Zhang, M. Ryan, and D. P. Guelev. Synthesising veriﬁed
access control systems through model checking. J. Comput.
Secur., 16(1):1–61, 2008.
[48] C. Zhao, N. Heilili, S. Liu, and Z. Lin. Representation and
reasoning on rbac: A description logic approach. In ICTAC’05:
Proc. of the 2nd Intl. Colloquium on Theoretical Aspects of
Computing, LNCS, Springer, 2005.
174