## 协议约定问题然而 RESTful 可不仅仅是指 API，而是一种架构风格，全称 RepresentationalStateTransfer，表述性状态转移，来自一篇重要的论文《架构风格与基于网络的软件架构设计》（ArchitecturalStyles and the Design of Network-based Software Architectures）。这篇文章从深层次，更加抽象地论证了一个互联网应用应该有的设计要点，而这些设计要点，成为后来我们能看到的所有高并发应用设计都必须要考虑的问题，再加上REST API 比较简单直接，所以后来几乎成为互联网应用的标准接口。因此，和 SOAP 不一样，REST不是一种严格规定的标准，它其实是一种设计风格。如果按这种风格进行设计，RESTful接口和 SOAP 接口都能做到，只不过后面的架构是 REST 倡导的，而 SOAP相对比较关注前面的接口。而且由于能够通过 WSDL 生成客户端的 Stub，因而 SOAP 常常被用于类似传统的RPC 方式，也即调用远端和调用本地是一样的。然而本地调用和远程跨网络调用毕竟不一样，这里的不一样还不仅仅是因为有网络而导致的客户端和服务端的分离，从而带来的网络性能问题。更重要的问题是，客户端和服务端谁来维护状态。所谓的状态就是对某个数据当前处理到什么程度了。这里举几个例子，例如，我浏览到哪个目录了，我看到第几页了，我要买个东西，需要扣减一下库存，这些都是状态。本地调用其实没有人纠结这个问题，因为数据都在本地，谁处理都一样，而且一边处理了，另一边马上就能看到。当有了 RPC之后，我们本来期望对上层透明，就像上一节说的"远在天边，尽在眼前"。于是使用RPC 的时候，对于状态的问题也没有太多的考虑。就像 NFS一样，客户端会告诉服务端，我要进入哪个目录，服务端必须要为某个客户端维护一个状态，就是当前这个客户端浏览到哪个目录了。例如，客户端输入cd hello，服务端要在某个地方记住，上次浏览到 /root/liuchao了，因而客户的这次输入，应该给它显示 /root/liuchao/hello下面的文件列表。而如果有另一个客户端，同样输入 cdhello，服务端也在某个地方记住，上次浏览到 /var/lib，因而要给客户显示的是/var/lib/hello。不光 NFS，如果浏览翻页，我们经常要实现函数next()，在一个列表中取下一页，但是这就需要服务端记住，客户端 A上次浏览到 20～30 页了，那它调用 next()，应该显示 30～40 页，而客户端 B上次浏览到 100～110 页了，调用 next() 应该显示 110～120 页。上面的例子都是在 RPC 场景下，由服务端来维护状态，很多 SOAP接口设计的时候，也常常按这种模式。这种模式原来没有问题，是因为客户端和服务端之间的比例没有失衡。因为一般不会同时有太多的客户端同时连上来，所以NFS 还能把每个客户端的状态都记住。公司内部使用的 ERP 系统，如果使用 SOAP的方式实现，并且服务端为每个登录的用户维护浏览到报表那一页的状态，由于一个公司内部的人也不会太多，把ERP 放在一个强大的物理机上，也能记得过来。但是互联网场景下，客户端和服务端就彻底失衡了。你可以想象"双十一"，多少人同时来购物，作为服务端，它能记得过来吗？当然不可能，只好多个服务端同时提供服务，大家分担一下。但是这就存在一个问题，服务端怎么把自己记住的客户端状态告诉另一个服务端呢？或者说，你让我给你分担工作，你也要把工作的前因后果给我说清楚啊！那服务端索性就要想了，既然这么多客户端，那大家就分分工吧。服务端就只记录资源的状态，例如文件的状态，报表的状态，库存的状态，而客户端自己维护自己的状态。比如，你访问到哪个目录了啊，报表的哪一页了啊，等等。这样对于 API也有影响，也就是说，当客户端维护了自己的状态，就不能这样调用服务端了。例如客户端说，我想访问当前目录下的hello路径。服务端说，我怎么知道你的当前路径。所以客户端要先看看自己当前路径是/root/liuchao，然后告诉服务端说，我想访问 /root/liuchao/hello 路径。再比如，客户端说我想访问下一页，服务端说，我怎么知道你当前访问到哪一页了。所以客户端要先看看自己访问到了100～110 页，然后告诉服务器说，我想访问 110～120 页。这就是服务端的无状态化。这样服务端就可以横向扩展了，一百个人一起服务，不用交接，每个人都能处理。所谓的无状态，其实是服务端维护资源的状态，客户端维护会话的状态。对于服务端来讲，只有资源的状态改变了，客户端才调用POST、PUT、DELETE方法来找我；如果资源的状态没变，只是客户端的状态变了，就不用告诉我了，对于我来说都是统一的GET。虽然这只改进了GET，但是已经带来了很大的进步。因为对于互联网应用，大多数是读多写少的。而且只要服务端的资源状态不变，就给了我们缓存的可能。例如可以将状态缓存到接入层，甚至缓存到CDN 的边缘节点，这都是资源状态不变的好处。按照这种思路，对于 API的设计，就慢慢变成了以资源为核心，而非以过程为核心。也就是说，客户端只要告诉服务端你想让资源状态最终变成什么样就可以了，而不用告诉我过程，不用告诉我动作。还是文件目录的例子。客户端应该访问哪个绝对路径，而非一个动作，我就要进入某个路径。再如，库存的调用，应该查看当前的库存数目，然后减去购买的数量，得到结果的库存数。这个时候应该设置为目标库存数（但是当前库存数要匹配），而非告知减去多少库存。这种 API的设计需要实现幂等，因为网络不稳定，就会经常出错，因而需要重试，但是一旦重试，就会存在幂等的问题，也就是同一个调用，多次调用的结果应该一样，不能一次支付调用，因为调用三次变成了支付三次。不能进入cd a，做了三次，就变成了 cda/a/a。也不能扣减库存，调用了三次，就扣减三次库存。当然按照这种设计模式，无论 RESTful API 还是 SOAP API都可以将架构实现成无状态的，面向资源的、幂等的、横向扩展的、可缓存的。但是 SOAP 的 XML 正文中，是可以放任何动作的。例如 XML 里面可以写 \，\ 等。这就方便使用 SOAP 的人，将大量的动作放在 API 里面。RESTful 没这么复杂，也没给客户提供这么多的可能性，正文里的 JSON基本描述的就是资源的状态，没办法描述动作，而且能够出发的动作只有CRUD，也即 POST、GET、PUT、DELETE，也就是对于状态的改变。所以，从接口角度，就让你死了这条心。当然也有很多技巧的方法，在使用RESTful API 的情况下，依然提供基于动作的有状态请求，这属于反模式了。
## 服务发现问题对于 RESTful API 来讲，我们已经解决了传输协议的问题------基于HTTP，协议约定问题------基于 JSON，最后要解决的是服务发现问题。有个著名的基于 RESTful API 的跨系统调用框架叫 Spring Cloud。在 SpringCloud 中有一个组件叫Eureka。传说，阿基米德在洗澡时发现浮力原理，高兴得来不及穿上裤子，跑到街上大喊："Eureka（我找到了）！"所以Eureka 是用来实现注册中心的，负责维护注册的服务列表。服务分服务提供方，它向 Eureka做服务注册、续约和下线等操作，注册的主要数据包括服务名、机器IP、端口号、域名等等。另外一方是服务消费方，向 Eureka获取服务提供方的注册信息。为了实现负载均衡和容错，服务提供方可以注册多个。当消费方要调用服务的时候，会从注册中心读出多个服务来，那怎么调用呢？当然是RESTful 方式了。Spring Cloud 提供一个 RestTemplate 工具，用于将请求对象转换为JSON，并发起 Rest 调用，RestTemplate 的调用也是分 POST、PUT、GET、DELETE 的，当结果返回的时候，根据返回的 JSON 解析成对象。通过这样封装，调用起来也很方便。
## 小结好了，这一节就到这里了，我们来总结一下。-   SOAP    过于复杂，而且设计是面向动作的，因而往往因为架构问题导致并发量上不去。-   RESTful 不仅仅是一个    API，而且是一种架构模式，主要面向资源，提供无状态服务，有利于横向扩展应对高并发。最后，给你留两个思考题：1.  在讨论 RESTful    模型的时候，举了一个库存的例子，但是这种方法有很大问题，那你知道为什么要这样设计吗？2.  基于文本的 RPC    虽然解决了二进制的问题，但是它本身也有问题，你能举出一些例子吗？我们的专栏更新到第 34讲，不知你掌握得如何？每节课后我留的思考题，你都有没有认真思考，并在留言区写下答案呢？我会从**已发布的文章中选出一批认真留言的同学**，赠送[学习奖励礼券]{.orange}和我整理的[独家网络协议知识图谱]{.orange}。欢迎你留言和我讨论。趣谈网络协议，我们下期见！![](Images/55417b60e9c8040807daf07e6bd9cb4b.png){savepage-src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg"}
# 第35讲 \| 二进制类RPC协议：还是叫NBA吧，总说全称多费劲前面我们讲了两个常用文本类的 RPC 协议，对于陌生人之间的沟通，用 NBA、CBA这样的缩略语，会使得协议约定非常不方便。在讲 CDN 和 DNS的时候，我们讲过接入层的设计，对于静态资源或者动态资源静态化的部分都可以做缓存。但是对于下单、支付等交易场景，还是需要调用API。对于微服务的架构，API 需要一个 API 网关统一的管理。API网关有多种实现方式，用 Nginx 或者 OpenResty 结合 Lua脚本是常用的方式。在上一节讲过的 Spring Cloud 体系中，有个组件 Zuul也是干这个的。
## 数据中心内部是如何相互调用的？API 网关用来管理 API，但是 API 的实现一般在一个叫作**Controller层**的地方。这一层对外提供API。由于是让陌生人访问的，我们能看到目前业界主流的，基本都是 RESTful 的API，是面向大规模互联网应用的。![](Images/695708543f3fda8f7d91ac4b47087ff5.png){savepage-src="https://static001.geekbang.org/resource/image/f0/b8/f08ef51889add2c26c57c9edd3db93b8.jpg"}在 Controller 之内，就是咱们互联网应用的业务逻辑实现。上节讲 RESTful的时候，说过业务逻辑的实现最好是无状态的，从而可以横向扩展，但是资源的状态还需要服务端去维护。资源的状态不应该维护在业务逻辑层，而是在最底层的持久化层，一般会使用分布式数据库和ElasticSearch。``{=html}这些服务端的状态，例如订单、库存、商品等，都是重中之重，都需要持久化到硬盘上，数据不能丢，但是由于硬盘读写性能差，因而持久化层往往吞吐量不能达到互联网应用要求的吞吐量，因而前面要有一层缓存层，使用Redis 或者 memcached将请求拦截一道，不能让所有的请求都进入数据库"中军大营"。缓存和持久化层之上一般是**基础服务层**，这里面提供一些原子化的接口。例如，对于用户、商品、订单、库存的增删查改，将缓存和数据库对再上层的业务逻辑屏蔽一道。有了这一层，上层业务逻辑看到的都是接口，而不会调用数据库和缓存。因而对于缓存层的扩容，数据库的分库分表，所有的改变，都截止到这一层，这样有利于将来对于缓存和数据库的运维。再往上就是**组合层**。因为基础服务层只是提供简单的接口，实现简单的业务逻辑，而复杂的业务逻辑，比如下单，要扣优惠券，扣减库存等，就要在组合服务层实现。这样，Controller层、组合服务层、基础服务层就会相互调用，这个调用是在数据中心内部的，量也会比较大，还是使用RPC 的机制实现的。由于服务比较多，需要一个单独的注册中心来做服务发现。服务提供方会将自己提供哪些服务注册到注册中心中去，同时服务消费方订阅这个服务，从而可以对这个服务进行调用。调用的时候有一个问题，这里的 RPC调用，应该用二进制还是文本类？其实文本的最大问题是，占用字节数目比较多。比如数字123，其实本来二进制 8 位就够了，但是如果变成文本，就成了字符串123。如果是 UTF-8 编码的话，就是三个字节；如果是UTF-16，就是六个字节。同样的信息，要多费好多的空间，传输起来也更加占带宽，时延也高。因而对于数据中心内部的相互调用，很多公司选型的时候，还是希望采用更加省空间和带宽的二进制的方案。这里一个著名的例子就是 Dubbo 服务化框架二进制的 RPC 方式。![](Images/23b1d1e3087ac84896910d1f7229e427.png){savepage-src="https://static001.geekbang.org/resource/image/c6/c2/c622af64f47e264453088e79c3e631c2.jpg"}Dubbo 会在客户端的本地启动一个 Proxy，其实就是客户端的Stub，对于远程的调用都通过这个 Stub 进行封装。接下来，Dubbo会从注册中心获取服务端的列表，根据路由规则和负载均衡规则，在多个服务端中选择一个最合适的服务端进行调用。调用服务端的时候，首先要进行编码和序列化，形成 Dubbo头和序列化的方法和参数。将编码好的数据，交给网络客户端进行发送，网络服务端收到消息后，进行解码。然后将任务分发给某个线程进行处理，在线程中会调用服务端的代码逻辑，然后返回结果。这个过程和经典的 RPC 模式何其相似啊！
## 如何解决协议约定问题？接下来我们还是来看 RPC的三大问题，其中注册发现问题已经通过注册中心解决了。我们下面就来看协议约定问题。Dubbo 中默认的 RPC 协议是 Hessian2。为了保证传输的效率，Hessian2将远程调用序列化为二进制进行传输，并且可以进行一定的压缩。这个时候你可能会疑惑，同为二进制的序列化协议，Hessian2和前面的二进制的 RPC 有什么区别呢？这不绕了一圈又回来了吗？Hessian2是解决了一些问题的。例如，原来要定义一个协议文件，然后通过这个文件生成客户端和服务端的Stub，才能进行相互调用，这样使得修改就会不方便。Hessian2不需要定义这个协议文件，而是自描述的。什么是自描述呢？所谓自描述就是，关于调用哪个函数，参数是什么，另一方不需要拿到某个协议文件、拿到二进制，靠它本身根据Hessian2 的规则，就能解析出来。原来有协议文件的场景，有点儿像两个人事先约定好，0 表示方法add，然后后面会传两个数。服务端把两个数加起来，这样一方发送012，另一方知道是将 1 和 2 加起来，但是不知道协议文件的，当它收到 012的时候，完全不知道代表什么意思。而自描述的场景，就像两个人说的每句话都带前因后果。例如，传递的是"函数：add，第一个参数1，第二个参数2"。这样无论谁拿到这个表述，都知道是什么意思。但是只不过都是以二进制的形式编码的。这其实相当于综合了XML 和二进制共同优势的一个协议。Hessian2 是如何做到这一点的呢？这就需要去看 Hessian2的序列化的[语法描述文件](http://hessian.caucho.com/doc/hessian-serialization.html)。![](Images/5a53563bea794f0b29a7f708ad42375c.png){savepage-src="https://static001.geekbang.org/resource/image/61/66/618bad147f6933f61ef56cf73d671166.jpg"}看起来很复杂，编译原理里面是有这样的语法规则的。我们从 Top 看起，下一层是value，直到形成一棵树。这里面的有个思想，为了防止歧义，每一个类型的起始数字都设置成为独一无二的。这样，解析的时候，看到这个数字，就知道后面跟的是什么了。这里还是以加法为例子，"add(2,3)"被序列化之后是什么样的呢？    H x02 x00     