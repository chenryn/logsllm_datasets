得到内容： **Android_scheme_is_FUN**  
搜索 **scheme** ，发现这是一种安卓中有的一种交互协议，用于从浏览器中跳转到这个应用，配置信息在 **Manifest** 中
找到关键信息：
构造连接： **sh0w://p4th/70/1nput?secret=Android_scheme_is_FUN**  
在模拟器的浏览器中访问，就会跳转到应用中执行，并且给出了flag格式
这里input就真是整个链接…所以逆向so也没啥用。
**flag{sh0w://p4th/70/1nput?secret=Android_scheme_is_FUN_1635b71e036d}**
###  anniu
下载之后有一个灰色的按钮，用一些控件助手，把按钮解禁即可得到flag。
###  warmup
第一次做这种数独的题目，观察程序逻辑，发现是16*16的数独。
谷歌找到一个解数独的网站：
发现网站是要一个一个输入，有点慢，利用fd抓包之后，发现网站上传了一个数独的数据。
编写程序输出内容（0xFF相当于为空，也就是要填的，再把输出内容”256”替换成””即可）：
    #include 
    #include 
    unsigned char byte_40A0[16][16] =
    {
      0x08, 0x0E, 0xFF, 0x0C, 0x09, 0x0D, 0xFF, 0x01, 0x0A, 0x0F,
      0x03, 0x0B, 0x00, 0x02, 0xFF, 0x04, 0x01, 0x06, 0x03, 0x02,
      0x05, 0x0A, 0x07, 0x00, 0x08, 0x09, 0xFF, 0x04, 0x0F, 0x0E,
      0x0B, 0x0D, 0x0A, 0x00, 0xFF, 0x0D, 0x04, 0x0F, 0x03, 0x0B,
      0x07, 0x05, 0x0E, 0x02, 0x06, 0x08, 0x0C, 0x01, 0x04, 0x0B,
      0x05, 0x0F, 0xFF, 0x02, 0xFF, 0x0C, 0x06, 0x0D, 0x01, 0x00,
      0xFF, 0x0A, 0x03, 0x09, 0x02, 0x0A, 0xFF, 0x03, 0x0D, 0x00,
      0x0B, 0x05, 0x0C, 0xFF, 0x09, 0x01, 0xFF, 0x0F, 0x07, 0x0E,
      0x0D, 0x07, 0x0C, 0x0B, 0x0F, 0x0E, 0x0A, 0x08, 0x00, 0xFF,
      0x05, 0x03, 0x09, 0x06, 0x01, 0x02, 0xFF, 0x01, 0x0F, 0xFF,
      0x0C, 0x09, 0x04, 0x06, 0x02, 0x0E, 0x0D, 0xFF, 0xFF, 0x03,
      0x0A, 0xFF, 0x09, 0x04, 0x06, 0x0E, 0x02, 0x07, 0x01, 0x03,
      0x0B, 0x08, 0x0A, 0x0F, 0x05, 0xFF, 0x00, 0x0C, 0xFF, 0x03,
      0x0A, 0x07, 0x0E, 0x08, 0x0C, 0x04, 0x09, 0xFF, 0x00, 0x0D,
      0x02, 0xFF, 0x06, 0xFF, 0x0C, 0x09, 0x01, 0xFF, 0x0B, 0x03,
      0x0F, 0x0D, 0x0E, 0x0A, 0xFF, 0xFF, 0x08, 0x00, 0x04, 0x07,
      0x06, 0x0D, 0x00, 0x08, 0x0A, 0x01, 0x02, 0xFF, 0xFF, 0x07,
      0x04, 0x05, 0x0C, 0x0B, 0xFF, 0x0F, 0x0B, 0x02, 0x0E, 0xFF,
      0x00, 0xFF, 0x05, 0xFF, 0x0F, 0x01, 0xFF, 0x0C, 0x0A, 0x09,
      0x0D, 0x03, 0xFF, 0x0F, 0x0B, 0xFF, 0x03, 0x0C, 0xFF, 0x0E,
      0x05, 0xFF, 0xFF, 0x09, 0xFF, 0x04, 0x08, 0x0A, 0x0E, 0x08,
      0xFF, 0xFF, 0x07, 0x05, 0x0D, 0x0F, 0x04, 0x03, 0xFF, 0xFF,
      0x01, 0x0C, 0x09, 0x00, 0xFF, 0x05, 0x0D, 0x09, 0x06, 0x04,
      0x08, 0x0A, 0x01, 0x0C, 0x0F, 0x0E, 0xFF, 0x07, 0x02, 0x0B,
      0x03, 0xFF, 0x04, 0x0A, 0xFF, 0x0B, 0x09, 0x02, 0x0D, 0x00,
      0xFF, 0x08, 0x0E, 0xFF, 0x0F, 0x06
    };
    int main()
    {
        for (int i = 0; i 
    int main()
    {
        for(;;)
        {
            int t;
            scanf("%d", &t);
            if (t  10) printf("%c", t - 11 + 'a');
        }
        return 0;
    }
**flag{765c98e78644507b8dfb1552693e467871026d26ba03c175}**
### **e**
这道题因为ida调试不起来一直没做，没想到这么简单。
用gdb可以调试，用gdbserver来与ida连接（重度ida依赖，做pwn的时候就是重度gdb依赖）
先下个断点
启动调试，跟进去
一直单步到 **jmp eax** ，跳转到另一个区域
进入到 **第二个call**
这个函数的代码相当复杂，但是我们需要注意的就是什么时候输出 **NONONO**
观察到：
如果进入下面的分支就会输出 **NONONO** ，所以猜测上面的分支就是会输出正确的flag。
所以如何让v6 == true呢？
发现v6就在我下的断点那一行赋值了（红色那行），点进去那个调用的函数
盲测是strcmp。
由于是gdbserver调试，所以不能直接在伪代码看内容，所以我们转回汇编
发现流程图也是非常清晰的分支，在x86就是栈传参，所以eax就是比较的内容之一，查看数据
尝试输入 **DDDJJJBBBRRREEE**
成功！
**flag{DDDJJJBBBRRREEE}**
###  UnrealFlag
这道题虽然拿了一血，但其实还可以更快，因为找工具用了大部分的时间。
主要思路是参照：。这篇文章的
用IDA载入关键文件 **FindFlag-Win64-Shipping.exe** ，查找字符串关键词 **index offset** （时间有点久）
双击进去之后按X查找引用
发现有两个引用，我们都过去看看，并且都下断点
这个if有点长，找到他上面的下断点，其实大概猜到这里已经不是了。
设置调试，并且跑起来
程序成功跑起来了，接下来就是一些盲目的寻找
发现图中黄色的函数里面有点玄机
因为他这个函数内部似乎有打印key的一个异常输出
我们可以走到他附近看看，由于这块的伪代码效果不是很好，我们直接去汇编看，每一个调用函数都进去看看
会走到这样的一个函数
发现这里有个memcpy，而且copy的size也是0x20，虽然这部分没有走到，不过我大胆地猜测这里应该就是用于前面异常报错的部分，所以查看对应的
**a1** 内容，先按 ***** 设置为数组
并且 **Shift + E** 导出
在之前的教程里面用的工具在这道题里面似乎不行，所以我一直没搞清楚要用什么来解包，然后查看 **umodel**
的官网，本来想找找怎么输入AES的格式是怎么样的，也没有找到，最后出题人告诉我AES输入的格式是前导0x的16进制字符串（其他软件都是base64）
还有就是记得要用最新版的
选择PAK包之后，输入AES秘钥
就可以成功解包了
找到 **flag.uasset** ，并双击打开，这是一个材质文件
但是似乎有些变形了，有些字符看不清楚，不过多试几次就能试出来。
## WEB
###  虎山行
非预期，似乎直接RCE了，看到文件的时候我还一脸懵逼。
刚开始对这个系统进行了搜索，发现了先知社区的一篇文章，不过有些繁琐，而且也不能直接RCE，故手动寻找了这个系统的文件。
发现系统存在文件 **install.php**
来让我们可以对文件进行手动的安装，所以就尝试对这个文件进行分析，之前也了解过dz论坛的一些漏洞，发现在安装文件中出现问题的可能性还是蛮大的，经过分析发现下处漏洞：
发现在安装文件的此处，没有对输入的信息进行任何的过滤，这导致我们可以直接通过输入的内容来往该文件中写入shell，例如我们可以构造payload，使得数据内容闭合，并且把后续的内容都注释掉。
    wjh');eval($_POST[a]);//
之后使用蚁剑进行连接
看到挺多莫名奇妙的文件的，估计是因为我是非预期的缘故。
## MISC
###  十八般兵器
下载之后得到一个压缩包文件，发现压缩包存在密码，从旁边的注释信息得到密码进行尝试
解压后得到文件：
猜测是对文件的隐写，且因为其实jpg文件，尝试用JPHS来得到隐藏内容
对每个兵器都进行读取：
可以得到多个文件，把下面的数字都连接起来，前十种兵器对应10进制，后八种对应8进制，
最后转字符串信息就可以得到
**flag{CTFshow_10_bA_Ban_b1ng_Q1}**
###  请问大吉杯的签到是在这里签吗
下载得到一个二维码文件，尝试扫码，发现没有重要信息。
于是尝试观察文件，发现在末尾处有一个PK压缩包，尝试解压，有多个套娃，得到全部的二维码之后，对其内容进行分析，发现在第二个二维码处有提示，于是猜测第二个二维码存在隐写。
通过 **Stegsolve** 打开进行查看
发现在0通道和1通道切换的时候，图片内容会变化，猜测有隐写内容，但是查看无果。
再继续查看的时候，发现这些内容都被显示出来
猪圈密码解密，得到
**flag{dajiadoaidjb}**
###  牛年大吉
丢进binwalk跑了一下，发现有一张图片和一个压缩包信息。
使用
    binwalk -D png test.vhd
    binwalk -D 7-zip test.vhd
进行分离，得到压缩包和图片：  
修改其扩展名使得能被windows识别：
解压压缩包需要密码，密码在图片头里面，说实话这真的不好猜
解压后得到
**flag{CTFshow_The_Year_of_the_Ox}**
###  碑寺六十四卦
发现文件很大，相对于size来说不匹配，猜测有隐写。
根据提示把图片反色，并查看
发现存在一个png文件，导出后查看
把开头的无用内容删除后，得到：
发现文件
猜测从上到下依次对应着 **base64编码** 的索引，之前UNCTF2020也考过一道类似的。
手动对应了一下，发现开头就是flag，加强了信心。
最后得到
**flag{Le1bnizD0uShuoH4o}**
###  AA86
刚开始无思路，在仔细看题目之后，决定去装个DOS看看，发现内容可以在DOS中执行，最后得到flag
**flag{https://utf-8.jp/public/sas/index.html}**