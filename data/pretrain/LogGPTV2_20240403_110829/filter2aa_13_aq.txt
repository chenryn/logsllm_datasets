只要关注图中标记的三个部分：
1）checksum：文件校验码，使用alder32算法校验文件除去maigc、checksum外余下的所有文件区域，用于检查文件错误。
2）signature：使用SHA-1算法hash除去magic、checksum和signature外余下的所有文件区域，用于唯一识别本文件。
3）file_size：dex文件的大小。
为什么说只需要关注这三个字段呢？因为需要将一个文件（加密之后的源apk）写入到dex文件中，那么肯定需要修改文件校验码（checksum）。因为它检查文件是否有错误。signature也是一样，也是唯一识别文件的算法。还需要修改dex文件的大小。
不过这里还需要一个操作，就是标注一下加密的apk的大小，因为在脱壳的时候，需要知道apk的大小，才能正确得到apk。那么这个值放到哪呢？直接放到文件的末尾就可以了。
总结一下需要做的步骤：修改dex的三个文件头，将源apk的大小追加到新的dex末尾就可以了。修改之后得到新的dex文件样式如图13-3所示。
图13-3 apk加固原理图
知道原理后就来看代码实现，这里有三个项目：
·源程序项目（需要加密的apk）
·加壳项目（对源apk进行加密，和脱壳项目的dex进行合并）
·脱壳项目（解密源apk和加载apk）
13.2 案例分析
根据上节分析得知，加固后新的dex文件中有三个项目，本节来依次看一下这三个项目的代码实现。
1.需要加密的源程序apk项目：ForceApkObj
需要一个Application类，如图13-4所示。
图13-4 加固apk项目结构图
下面来分析一下MyApplication源码：
就是打印一下onCreate方法。继续来分析一下MainActivity源码：
也是简单地打印一下内容。
2.加壳程序项目：DexShellTools
加壳程序其实就是一个Java项目，它的工作就是加密源apk，然后将其写入脱壳dex文件中，修改文件头，得到一个新的dex文件即可，如图13-5所示。
图13-5 加壳项目说明
下面来分析一下具体代码：
下面来详细分析一下具体代码逻辑：
实框部分其实就是最核心的工作。
1）加密源程序apk文件：
加密算法如下所示：
对每个字节进行异或一下即可。
提示：这里是为了简单起见，就用了很简单的加密算法。其实为了增加破解难度，应该使用更高效的加密算法，同时最好将加密操作放到native层去做。
2）合并文件：将加密之后的apk和原脱壳dex进行合并：
3）在文件的末尾追加源程序apk的长度：
4）修改新dex文件的文件头信息：file_size；sha1；check_sum：
具体修改可以参照之前说的文件头格式，修改指定位置的字节值即可。
这里还需要两个输入文件：
·源apk文件：ForceApkObj.apk
·脱壳程序的dex文件：ForceApkObj.dex
第一个文件都知道，就是上面的源程序编译之后的apk文件，第二个文件怎么得到呢？这个就是要讲到的第三个项目：脱壳程序项目。
3.脱壳项目：ReforceApk
脱壳项目是一个Android项目，在编译之后，能够得到它的classes.dex文件，然后修改一下名称就可，如图13-6所示。
图13-6 脱壳项目结构图
在讲解这个项目之前，先来了解一下这个脱壳项目的工作。
1）通过反射置换android.app.ActivityThread中的mClassLoader是加载解密出apk的DexClassLoader，该DexClassLoader一方面加载了源程序，另一方面以原mClassLoader为父节点，这就保证了既加载了源程序又没有放弃原先加载的资源与系统代码。
关于这部分内容，不了解的可以看一下ActivityThread.java的源码：
2）找到源程序的Application，通过反射建立并运行。
这里需要注意的是，现在是加载一个完整的apk，让它运行起来，一个apk程序运行的时候都是有一个Application对象的，这个也是一个程序运行之后的全局类。所以必须找到解密之后的源apk的Application类，运行它的onCreate方法，这样源apk才开始它的运行生命周期。这里如何得到源apk的Application的类呢？这个后面会说到。使用meta标签进行设置。
下面来看一下整体的流程图，如图13-7所示。
图13-7 加载流程
首先来看一下具体步骤的代码实现逻辑：
1）得到脱壳apk中的dex文件，然后从这个文件中得到源程序apk，进行解密，最后进行加载，代码如下：
这里需要注意的一个问题是，需要找到一个时机在脱壳程序还没有运行起来的时候来加载源程序的apk，执行它的onCreate方法，那么这个时机不能太晚，不然的话，就是运行脱壳程序，而不是源程序了。查看源码知道Application中有一个方法即attachBaseContext方法，它在Application的onCreate方法执行前就会执行了，那么所有的工作就需要在这里进行。
2）从脱壳程序apk中找到源程序apk，并且进行解密操作：
脱壳解密操作一定要和之前的加壳以及加密操作对应，不然就会出现dex加载错误问题。
从apk中获取到dex文件：
其实就是解压apk文件，直接得到dex文件即可。
从脱壳Dex中得到源apk文件：
解密源程序apk：
解密算法和加密算法是一致的。
3）加载解密之后的源程序apk：
4）找到源程序的Application程序，让其运行：
直接在脱壳的Application中的onCreate方法中进行就可以了。这里还可以看到是通过AndroidManifest.xml中的meta标签获取源程序apk中的Application对象的。
下面来看一下AndoridManifest.xml文件中的内容，如下所示：
在这里定义了源程序apk的Application类名。
提示：项目下载为http://download.csdn.net/detail/jiangwei0910410003/9102741
13.3 运行项目
上节介绍了这三个项目，下面就来看看如何运行吧。
第一步：得到源程序apk文件和脱壳程序的dex文件
运行源程序项目和脱壳程序项目，得到源程序apk文件和脱壳程序的dex文件，如图13-8所示。
图13-8 项目结构图
之后得到这两个文件（记得将classes.dex文件改名ForceApkObj.dex），然后使用加壳程序进行加壳，如图13-9所示。
这里的ForceApkObj.apk文件和ForceApkObj.dex文件是输入文件，输出的是classes.dex文件。
第二步：替换脱壳程序中的classes.dex文件
在第一步中得到加壳之后的classes.dex文件之后，并且在第一步运行脱壳项目的时候得到一个ReforceApk.apk文件，这时候使用解压缩软件进行替换，如图13-10所示。
图13-9 加壳程序
图13-10 压缩软件查看apk内容
第三步：得到替换之后的ReforceApk.apk文件
这个文件因为被修改了，所以需要重新对它签名，不然运行也是报错的。这里可以使用jarsigner工具对apk进行重签名：
这里最主要的命令就是中间的一条签名的命令，关于命令的参数说明如下：
例如：
那么通过上面的三个步骤之后得到一个签名之后的最终文件：ReforceApk_des.apk。安装这个apk，然后运行，效果如图13-11所示。
图13-11 运行效果图
这个时候再去反编译一下源程序apk，如下所示（这个文件是脱壳出来的payload.apk，看ReforeceApk中的代码就知道它的位置了）：
发现dex文件格式是不正确的。说明加固是成功的。
总结遇到的问题如下：
·研究的过程中遇到签名不正确的地方，开始的时候替换dex文件，就直接运行了apk，但是总是提示签名不正确。
·运行的过程中说找不到源程序中的Activity，需要在脱壳程序中的AndroidManifest.xml中查看一下源程序中的Activity，如下所示：
通过上面的过程可以看到，关于apk加固的工作还是挺复杂的，涉及的东西也挺多，下面就来总结一下。
加壳程序：
·任务：对源程序apk进行加密，合并脱壳程序的dex文件，然后输入一个加壳之后的dex文件。
·语言：任何语言都可以，不限于Java语言。
·技术点：对dex文件格式的解析。
脱壳程序：
·任务：获取源程序apk，进行解密，然后动态加载进来，运行程序。
·语言：Android项目（Java）。
·技术点：如何从apk中获取dex文件，动态加载apk，使用反射运行Application。
13.4 本章小结
Android中的apk反编译可能是每个开发者都会经历的事，但是源程序的开发者对apk加固应运而生，即使是加固，也还是做不到那么安全，现在网上也有很多文章在解析某品牌加固的原理了，而且有人破解成功了，那么加固还不是怎么安全。最后一句话：逆向和加固是一个永不停息的战争。
第14章 Android中的so加固原理
前一章已经介绍了Android中dex加固原理，虽然dex加固是一种防护策略，但是它仍然存在被破解的风险，所以本章就来介绍另外一种加固方法，对so文件的加固防护，这种加固方式和dex加固方式来比较的话，安全性会更高，因为native层的代码会比较难以破解和阅读。
14.1 基于对so中的section加密实现so加固
在前面章节中已经详细介绍了so文件格式，有了这个知识作为基础，下面就来讲解如何对so文件进行加密。
14.1.1 技术原理
加密过程：找到so文件中一个section的起始地址和大小就可以对这个section进行加密了。
解密过程：因为对section进行加密之后，肯定需要解密，不然运行肯定报错，这里的重点是什么时候去进行解密。对于一个so文件，当被加载到程序之后，在运行程序之前可以从哪个时间点来突破？这里就需要一个知识点：__attribute__（（constructor））；关于这个属性的用法这里就不做介绍了，网上有相关资料，它的作用是优先于main方法之前执行，类似于Java中的构造函数，当然C++中的构造函数是基于这个属性实现的，在之前第4章介绍ELF文件格式的时候，有两个section会引起注意，如图14-1所示。
图14-1 ELF文件的段信息