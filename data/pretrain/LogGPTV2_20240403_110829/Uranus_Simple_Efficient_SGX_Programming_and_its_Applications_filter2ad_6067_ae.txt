attacker may try to rollback encrypted data outside enclaves. Prior
work [53] shows that this attack can be tackled by SGX monotonic
counters in enclaves. Uranus tackles this attack by providing API
for trusted code to access these counters and to compare their value
with the value of the counters in the decrypted data.
Iago attacks. In this paper, we consider Iago attacks that break
the type-safety or control flow integrity of the trusted code when
running a JVM within an enclave. Specifically, an attacker may
manipulate values or object references passed to JECall or return
results from JOCall during enclave transitions to conduct three
kinds of attacks. First, an attacker may try to forge a field of OU
in order to change the control flow of enclaves. Uranus prevents
such attacks as it forbids enclave code from reading objects outside
enclaves, and asks developers to use Uranus’s API to read and
verify the legitimacy of the content. Second, an attacker may change
the pointers stored in a field of OU to memory stack within enclaves,
so that subsequent writes to the forged pointer will poison the
call stack. Uranus prevents such attacks, since Uranus’s API of
reading from OU checks if the pointer read into enclave is within
the enclave memory. Third, an attacker may forge the class of OU
to change the control flow when executing its member functions.
Uranus prevents such attacks by forbidding executing OU’s member
functions within enclaves. Overall, attackers cannot poison enclave
memory during enclave transitions or during proactive/mistaken
cross-boundary memory access, so Uranus prevents Iago attacks
from compromising type-safety and integrity of the trusted Java
code. Verifying the content of JOCall to prevent application-level
Iago attacks is application developers’ responsibility, as Uranus do
not know the semantic and actual return results of JOCall.
Information leakage via AEX and OCall. An attacker may try
to observe the number of AEX or OCall in JVM components during
the execution of trusted code. Specifically, he can observe the OS
signals thrown from enclaves and infer the number of exceptions or
GC during a JECall, so he may infer the plaintext data being pro-
cessed in enclaves. Uranus prevents this leakage by isolating its GC
and exception handler components from OS, so that the execution
flows of the same trusted code on processing different encrypted
data will produce roughly the same numbers of AEX/OCall. Han-
dling applications-level side-channels (e.g., the number of JOCall)
is developers’ responsibility.
Java exceptions and dynamic checks. We tested the robustness
of Uranus’s dynamic checks (§4.3) by writing buggy code that
writes enclave data to outside. Uranus threw an EnclaveException
with encrypted stack traces without revealing any plaintext. To
continue executions of the enclave, we wrote a handler in enclave
code for EnclaveException that logs the exception and contin-
ues handling user requests. The program then continued, wrote
encrypted exception logs and returned null to us without leaking
any sensitive data.
6.6 Limitation and Future Work
Our current implementation of Uranus supports Java and Scala,
and Uranus can be extended to run other dynamic languages such
as Python [7] and JavaScript [8] in the future, because JVM can inter-
pret these languages. More TEE implementations such as TrustZone
enclave [27, 32] and Sanctum [30] can also be integrated in Uranus
with proper engineering to gain cross-platform compatibility.
Since Uranus implements an easy-to-verify JIT compiler based
on Hotspot’s interpreter. Spark-Uranus’s performance overhead
on large big-data dataset is not negligible (§6.3), because Uranus’s
JIT does not contain IR optimizations in order to maintain a small
TCB. Nevertheless, Spark-Uranus is the first SGX work that has
shown to work with typical big-data dataset sizes, and ZooKeeper-
Uranus’s performance overheads is low. In future work, Uranus’s
JIT can incorporate easy-to-verify IR optimizations [52] to improve
efficiency, and type-safety formal verification [74] for correctness.
Our current evaluation focuses on Spark and Zookeeper, and
Uranus can be also used to protect other data-handling applications
(e.g., Storm [1]) and web servers (e.g., Tomcat [2]) in the future with
proper engineering work. For Spark and Zookeeper, the partition
of trusted and untrusted code is already clear in their relevant SGX
systems (e.g., SGX-Spark and SecureKeeper). Inferring a partition
between the trusted code and untrusted code automatically for an
arbitrary application is not the main task of this paper, and static
analysis (e.g., Glamdring [51] and [57]) can work as Uranus’s
orthogonal tools to achieve this task. Uranus’s boundary checking
protocol can completely enforce the trusted and untrusted code
partition at runtime, which can complement unsound assumptions
in Java static data flow analysis (§4.3). Differential privacy [35, 49]
and data shuffling [77] can also be integrated into Spark-Uranus
to provide better data protections.
7 RELATED WORK
TEE. TEE provides a strong confidentiality and integrity guarantees
for applications with efficiency, as it effectively removes BIOS, hy-
pervisor, and OS out of TCB. There are diverse TEE implementations
such as Intel SGX [38], AMD SEV [42], ARM TrustZone [17], and
IBM SecureBlue [25]. Komodo [32] and Sanctum [30, 64] propose
verifiable TEEs on ARM and RISC-V respectively. Timber-V [73]
and and Ginseng [75] are two recent TEE implementations for mem-
ory efficiency and low-TCB. OpenSGX [39] is an SGX emulator for
research. TLR [58] proposes a .NET framework running on ARM
TrustZone. TLR is not designed for the client-server model, as it
needs a trusted third party to do attestations. Moreover, the secure
OS in TLR must be trusted while Uranus assumes an untrusted
OS, so Uranus proposes OS-decoupled components to tackle IaGo
attacks and side-channel leakage.
SGX-based Systems. SGX systems can be classified into two cate-
gories according to the code running in SGX. First, the shielding
category (e.g., Haven [21], SCONE [18], Graphene-SGX [67], Pe-
sos [47], and SGX-Kernel [66]) runs all application code in SGX en-
clave. Second, the customizing category (e.g., Opaque [77], VC3 [59],
SecureKeeper [28], S-NFV [61], SGX-Tor [45], Panoply [62], SGX-
BigMatrix [60], SGX-Log [43], MiniBox [50], ShieldStore [46], En-
claveDB [56], SGX-Spark [11], and Ryoan [37]) runs only the code
processing secret plaintext data in SGX. Uranus belongs to the
customizing category, as it annotates and protects sensitive func-
tions. Panoply [62] proposes the abstraction Micron, which provides
POSIX API such as multi-threading and multi-processing to run
parts of C/C++ applications in enclaves. SGX-BigMatrix [60] is a
Python-based secure and oblivious data analytic system for ma-
trix computation. SGXElide [20] loads encrypted code at runtime
to provide confidentiality of enclave code, but it does not tackle
dynamic loaded code as in Uranus. JIT-Guard [33] uses SGX to
protect a JIT compiler, not applications. Several recent systems
(e.g., RustSGX [71], GoTEE [34] and ScriptShield [70]) try to run
Rust, Go and script languages in enclaves. They focus on specific
security challenges in their own languages, including Rust memory
safety, secure GO channels and script code compatibility, respec-
tively. Uranus tackles specific security challenges in Java, including
dynamic code loading and GC. CordaSGX [4] is an industry project
developed for Java applications; currently it evaluates only key
management in enclaves. CordaSGX lacks an integrity attestation
protocol for dynamic loaded code, and Uranus can help.
Civet [16] is a recent system that automatically partitions and
executes Java code. Uranus and Civet are largely complementary
in three major aspects. First, Civet uses static analysis for infer-
ring the trusted code partition and requires manual annotation for
dynamically loaded code (e.g., reflection). Uranus can help Civet
reduce its manual annotation efforts for dynamically loaded code,
as Uranus supports loading dynamically loaded code automatically
using loadClass (§4.1). Second, to enforce a safe enclave bound-
ary, Civet uses dynamic flow tracking (Phosphor [23]) to prevent
sensitive data leaking out of the enclave, which has high memory
consumption for data-intensive applications and produces prohib-
ited performance and memory overhead when enabling the check-
ing of implicit control flows [40]. Uranus presents Read-integrity
and WriteConfidentiality (§4.1), an efficient approach to enforce a
safe enclave boundary. Third, Civet’s GC protocol optimizes the
performance of the traditional generational GC by proposing a
three-generation GC to reduce L3 cache misses and EPC page swap-
ping in doing GC. Uranus proposes a region-based GC optimized
for data-handling applications, enabling them to run efficiently with
typical big-data datasets. Moreover, Uranus tackles information
leakage from AEX and OCall, while Civet does not discuss these
leakage cases.
Regional GC. Regional-based JVM GC has been used for big-
data platforms (Yak [55]), or real-time applications(RTSJ [22, 26]).
Uranus’s GC differs from these works in two aspects. First, none
of these GC systems is fully-automated. For instance, Yak requires
developers to provide region hints in Java code. Uranus is fully-
automated by leveraging the enclave boundary. Second, and more
importantly, these GC protocols are all OS-assisted and not suitable
for managing enclave memory.
8 CONCLUSION
We have presented Uranus, an easy-to-use, efficient, and secure
SGX programming system for Java applications. Uranus explores
a new high-level SGX programming method, which hides the de-
tails of low-level TEE implementations. We identified security and
efficiency challenges during designing Uranus; we presented two
new secure and efficient protocols for dynamic code loading and
GC. Extensive evaluations show that Uranus is practical for data-
handling applications. Uranus source code and evaluation results
are released on https://github.com/hku-systems/uranus.
ACKNOWLEDGMENTS
We thank our shepherd, Lucas Davi, and all anonymous AsiaCCS
reviewers for their helpful comments. This work is funded in part
by the research grants from Huawei Innovation Research Program
Flagship 2018, HK RGC GRF (17202318, 17207117), HK RGC ECS
(27200916), and a Croucher innovation award.
REFERENCES
[1] Apache Storm. http://storm.apache.org/.
[2] Apache Tomcat. http://tomcat.apache.org/.
[3] ChronicleMap. https://github.com/OpenHFT/Chronicle-Map.
[4] Corda SGX JVM. https://github.com/corda/sgxjvm-public.
[5] Java ASM Package. https://asm.ow2.io/.
[6] JVM Runtime. http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.
html.
[7] The Jython Project. www.jython.org.
[8] Multi-threaded JavaScript on the JVM. ringojs.org.
[9] SecureWorker. https://www.npmjs.com/package/secureworker.
[10] SGX-LKL. https://github.com/lsds/sgx-lkl.
[11] SGX-Spark. https://github.com/lsds/sgx-spark.
[12] SpiderMonkey.
SpiderMonkey.
https://developer.mozilla.org/en-US/docs/Mozilla/Projects/
[13] ZooKeeper. https://zookeeper.apache.org/.
[14] Zookeeper Smoketest. https://github.com/phunt/zk-smoketest.
[15] Handling segfault in SGX enclaves. https://software.intel.com/en-us/forums/
intel-software-guard-extensions-intel-sgx/topic/734597.
[16] Civet: An Efficient Java Partitioning Framework for Hardware Enclaves. In 29th
USENIX Security Symposium (USENIX Security 20). USENIX Association, Boston,
MA. https://www.usenix.org/conference/usenixsecurity20/presentation/tsai
[17] ARM. Security technology building a secure system using TrustZone technology
(white paper).
[18] Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andre Martin,
Christian Priebe, Joshua Lind, Divya Muthukumaran, Dan O’Keeffe, Mark Still-
well, et al. SCONE: Secure Linux Containers with Intel SGX.. In OSDI. 689–703.
[19] Pierre-Louis Aublin, Peter Pietzuch, and Valerio Schiavoni. Using Trusted Execu-
tion Environments for Secure Stream Processing of Medical Data. In Distributed
Applications and Interoperable Systems: 19th IFIP WG 6.1 International Conference,
DAIS 2019, Held as Part of the 14th International Federated Conference on Dis-
tributed Computing Techniques, DisCoTec 2019, Kongens Lyngby, Denmark, June
17–21, 2019, Proceedings. Springer, 91.
[20] Erick Bauman, Huibo Wang, Mingwei Zhang, and Zhiqiang Lin. SGXElide:
enabling enclave code secrecy via self-modification. In Proceedings of the 2018
International Symposium on Code Generation and Optimization. ACM, 75–86.
[21] Andrew Baumann, Marcus Peinado, and Galen Hunt. Shielding Applications
from an Untrusted Cloud with Haven. In Proceedings of the Eleventh Symposium
on Operating Systems Design and Implementation (OSDI ’14). 267–283.
[22] William S Beebee and Martin Rinard. An implementation of scoped memory
for Real-Time Java. In International Workshop on Embedded Software. Springer,
289–305.
[23] Jonathan Bell and Gail Kaiser. Phosphor: Illuminating Dynamic Data Flow
in Commodity Jvms. In Proceedings of the 2014 ACM International Conference
on Object Oriented Programming Systems Languages & Applications (Portland,
Oregon, USA) (OOPSLA ’14). ACM, New York, NY, USA, 83–101.
[24] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso Frassetto, and Ahmad-Reza
Sadeghi. The Guard’s Dilemma: Efficient Code-Reuse Attacks Against Intel SGX.
In 27th USENIX Security Symposium USENIX Security 18). 1213–1227.
[25] Rick Boivie and Peter Williams. SecureBlue++: CPU support for secure execution.
Technical report (2012).
[26] Chandrasekhar Boyapati, Alexandru Salcianu, William Beebee Jr, and Martin
Rinard. Ownership types for safe region-based memory management in real-time
Java. In ACM SIGPLAN Notices, Vol. 38. ACM, 324–337.
[27] Ferdinand Brasser, David Gens, Patrick Jauernig, Ahmad-Reza Sadeghi, and
Emmanuel Stapf. SANCTUARY: ARMing TrustZone with User-space Enclaves..
In NDSS.
[28] Stefan Brenner, Colin Wulf, David Goltzsche, Nico Weichbrodt, Matthias Lorenz,
Christof Fetzer, Peter R Pietzuch, and Rüdiger Kapitza. SecureKeeper: Confidential
ZooKeeper using Intel SGX.. In Middleware. 14.
[29] Stephen Checkoway and Hovav Shacham. Iago attacks: Why the system call api
is a bad untrusted rpc interface. Vol. 41. ACM.
[30] Victor Costan, Ilia A Lebedev, and Srinivas Devadas. Sanctum: Minimal Hardware
Extensions for Strong Software Isolation.. In USENIX Security Symposium. 857–
874.
[31] Whitfield Diffie and Martin Hellman. New directions in cryptography. IEEE
transactions on Information Theory 22, 6 (1976), 644–654.
[32] Andrew Ferraiuolo, Andrew Baumann, Chris Hawblitzel, and Bryan Parno. Ko-
modo: Using verification to disentangle secure-enclave hardware from software.
In Proceedings of the 26th Symposium on Operating Systems Principles. ACM,
287–305.
[33] Tommaso Frassetto, David Gens, Christopher Liebchen, and Ahmad-Reza Sadeghi.
JITGuard: Hardening Just-in-time Compilers with SGX. (2017).
[34] Adrien Ghosn, James R Larus, and Edouard Bugnion. Secured routines: language-
based construction of trusted execution environments. In 2019 USENIX Annual
Technical Conference (USENIX ATC 19). 571–586.
[35] Xueyang Hu, Mingxuan Yuan, Jianguo Yao, Yu Deng, Lei Chen, Qiang Yang,
Haibing Guan, and Jia Zeng. Differential Privacy in Telco Big Data Platform.
Proc. VLDB Endow. 8, 12 (Aug. 2015), 1692–1703.
[36] Patrick Hunt, Mahadev Konar, Flavio P. Junqueira, and Benjamin Reed.
ZooKeeper: Wait-free Coordination for Internet-scale Systems. In Proceedings of
the 2010 USENIX Conference on USENIX Annual Technical Conference (USENIX
ATC’10).
[37] Tyler Hunt, Zhiting Zhu, Yuanzhong Xu, Simon Peter, and Emmett Witchel.
Ryoan: A Distributed Sandbox for Untrusted Computation on Secret Data.. In
OSDI. 533–549.
[38] Intel. Software Guard Extensions Programming Reference. https://software.intel.
com/sites/default/files/329298-001.pdf.
[39] Prerit Jain, Soham Jayesh Desai, Ming-Wei Shih, Taesoo Kim, Seong Min Kim,
Jae-Hyuk Lee, Changho Choi, Youjung Shin, Brent Byunghoon Kang, and Dongsu
Han. OpenSGX: An Open Platform for SGX Research.. In NDSS.
[40] Jiang Jianyu, Zhao Shixiong, Alsayed Danish, Wang Yuexuan, Cui Heming, Liang
Feng, and Gu Zhaoquan. Kakute: A Precise, Unified Information Flow Analysis
System for Big-data Security. In Proceedings of the Annual Computer Security
Applications Conference (ACSAC ’17).
[41] Simon Johnson, Vinnie Scarlata, Carlos Rozas, Ernie Brickell, and Frank Mckeen.
Intel® Software Guard Extensions: EPID Provisioning and Attestation Services.
White Paper 1 (2016), 1–10.
[42] David Kaplan, Jeremy Powell, and Tom Woller. AMD memory encryption. White
[43] Vishal Karande, Erick Bauman, Zhiqiang Lin, and Latifur Khan. SGX-Log: Secur-
ing system logs with SGX. In Proceedings of the 2017 ACM on Asia Conference on
Computer and Communications Security. ACM, 19–30.
[44] Daniel Kästner, Xavier Leroy, Sandrine Blazy, Bernhard Schommer, Michael
Schmidt, and Christian Ferdinand. Closing the gap–the formally verified opti-
mizing compiler CompCert. In SSS’17: Safety-critical Systems Symposium 2017.
CreateSpace, 163–180.
[45] Seong Min Kim, Juhyeng Han, Jaehyeong Ha, Taesoo Kim, and Dongsu Han.
Enhancing Security and Privacy of Tor’s Ecosystem by Using Trusted Execution
Environments.. In NSDI. 145–161.
[46] Taehoon Kim, Joongun Park, Jaewook Woo, Seungheun Jeon, and Jaehyuk Huh.
ShieldStore: Shielded In-memory Key-value Storage with SGX. In Proceedings of
the Fourteenth EuroSys Conference 2019. ACM, 14.
paper (2016).
[47] Robert Krahn, Bohdan Trach, Anjo Vahldiek-Oberwagner, Thomas Knauth,
Pramod Bhatotia, and Christof Fetzer. Pesos: Policy Enhanced Secure Object
Store. In Proceedings of the Twelfth European Conference on Computer Systems
(EuroSys).
[48] Jaehyuk Lee, Jinsoo Jang, Yeongjin Jang, Nohyun Kwak, Yeseul Choi, Changho
Choi, Taesoo Kim, Marcus Peinado, and Brent ByungHoon Kang. Hacking in
darkness: Return-oriented programming against secure enclaves. In 26th USENIX
Security Symposium (USENIX Security 17). 523–539.
[49] Tsz On Li, Jianyu Jiang, Ji Qi, Chi Chiu So, Jiacheng Ma, Tianxiang Shen, Heming