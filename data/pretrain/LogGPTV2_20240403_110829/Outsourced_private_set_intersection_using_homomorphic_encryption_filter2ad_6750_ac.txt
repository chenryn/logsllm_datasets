e that it only shares with the server S. All elements are
(RSA) encrypted using this exponent before added to the
Bloom ﬁlter. Nevertheless, we do not require the RSA as-
sumption to hold as [10] does, since the client does not know
e. Figure 2 shows the key generation and distribution by the
trusted third party.
In the M P SI protocol the trusted third party certiﬁes the
client set and submits signatures to the client. The client
submits the signature S(E(b1), . . . , E(bm)) to the server for
veriﬁcation during the P SI protocol. Of course, the server
also encrypts his set with the secret exponent by the trusted
third party before performing the encrypted Bloom ﬁlter test
operation. Figure 3 shows the interaction between client and
trusted third party.
4.3.1 Security Proof
We prove the security of the M P SI protocol variant. Note
that while the server may not adhere to the prescribed com-
putation, e.g. by returning an encrypted element El(si)
without testing the Bloom ﬁlter, it does not attack correct-
ness of the computation. The client always locally performs
the intersection with its input set. The server can only vio-
late its own privacy by revealing additional input and there-
fore in most practical situations where privacy is relevant
he is not even inclined to do so. Therefore there is always
a server in the real model leading to the same output in
:
C
b =Create(m)
i = 1, . . . v : b.Add(ci)
: n, u, E(b1), . . . , E(bm)
:
i = 1, . . . , w : El(s′
w)
1, . . . , s′
1), . . . , El(s′
{c1, . . . , cv} ∩ {s′
C −→ S
S
S −→ C : El(s′
C
:
w}
i) = El(si) ×Qk−1
j=0 Expand(E(bhj (si)))
Figure 1: Private Set Intersection Protocol P SI
: n, u, e
T
T −→ C : n, u
T −→ S
: n, u, e
Figure 2: Key Distribution in the M P SI Protocol
C −→ T :
:
T
c1, . . . , cv
b =Create(m)
i = 1, . . . , v : b.Add(ci
e mod n)
T −→ C : E(b1), . . . , E(bm), S(E(b1), . . . , E(bm))
C −→ S
: E(b1), . . . , E(bm), S(E(b1), . . . , E(bm))
. . .
S
. . .
i) = El(si) ×Qk−1
i = 1, . . . , w : El(s′
:
j=0 Expand(E(bhj (si
e mod n)))
Figure 3: Malicious Private Set Intersection Protocol M P SI
the ideal model. Loosely speaking, there is no diﬀerence
between the server choosing s′ as an input and the server
“sneaking” s′ into the result.
We again prove security by comparison between real and
ideal model. The real model is the execution of the M P SI
protocol this time. Furthermore, client and server may now
behave arbitrarily during protocol execution (except proto-
col abortion).
Theorem 2. If the quadratic residuosity assumption holds,
then protocol M P SI implements certiﬁed private set inter-
section in the malicious model.
Proof.
Conﬁdentiality of the client:
All inputs are encrypted using IND-CPA secure encryp-
tion (under the quadratic residuosity assumption).
Conﬁdentiality of the server:
The client cannot predict the encrypted element se for
any element s of the server.
It is indistinguishable from
a random number without the knowledge of e. Therefore
the client cannot force a hash collision – even if the hash
functions of the Bloom ﬁlter are reversible – with a chosen
set presented to the trusted third party. The occurrence of
any collision is random.
Hence, the probability for a false positive match between
the Bloom ﬁlter and an element in the server’s set is
2−k + 2−l
The probability of falsely revealing an element by the server
is therefore negligible in k or l.
To ensure security against a malicious client (server), it
must be shown that for any possible client (server) behavior
in the real model, there is an input that the client (server)
provides to the TTP in the ideal model, such that his view
in the real protocol is eﬃciently simulatable from his view
in the ideal model.
Construction of a simulator SIMS from a malicious real-
world server ˆS:
1. The simulator SIMS executes KeyGen(κ) in the GM
encryption.
2. The simulator SIMS creates an all 1s Bloom ﬁlter
b, i.e. bi = 1 (i = 1, . . . , m). The simulator sends
n, u, E(b1), . . . , E(bm) and simulates the signature S(E(b1),
. . ., E(bm)).
3. After receiving El(s′
1), . . . , El(s′
w) from the malicious
server ˆS, the simulator SIMS decrypts s′
1, . . . , s′
w.
4. The simulator SIMS now plays the role of the ideal
server interacting with the TTP (and the ideal client).
The simulator submits s′
w to the TTP.
1, . . . , s′
Since GM encryption is IND-CPA secure under the quadratic
residuosity assumption, the view of the malicious server ˆS
in the simulation by SIMS and in the real protocol are in-
distinguishable.
Output of (honest) real client C interacting with ˆS:
1, . . . , s′
For each set s′
w the client C receives, there is an
input set s1, . . . , sw by the server ˆS. The client builds the
intersection {c1, . . . , cv} ∩ {s′
w} and each elements s′
i
has been used by the simulator in the ideal model, such that
the outputs are identical.
Construction of a simulator SIMC from a malicious real-
world client ˆC:
1, . . . , s′
1. The simulator SIMC now plays the role of the trusted
third party T performing the certiﬁcation. After re-
ceiving c1, . . . , cv the simulator computes the encrypted
Bloom ﬁlter. It records the set C = {c1, . . . , cv} and
returns the encrypted and signed Bloom ﬁlter E(b1),
. . ., E(bm), S(E(b1), . . ., E(bm)).
2. The simulator SIMC now plays the role of the real-
world server. After receiving E(b1), . . ., E(bm), S(E(b1),
. . ., E(bm)) the simulator veriﬁes the signature. If it
does not check, it aborts.
3. The simulator SIMC now plays the role of the ideal
client interacting with the TTP (and the ideal server).
The simulator submits C.
4. After receiving the intersection I, the simulator SIMC
creates w − |I| random elements and adds them and
the elements in I to S ′ = {s′
It encrypts
each bit of each s′
w,l) to
the client ˆC.
i and sends E(s′
1,1), . . . , E(s′
1, . . . , s′
w}.
Since the set C equals the client set {c1, . . . , cv} and the
set S only contains the elements in I and randomly chosen
elements, the view of the malicious client ˆC in the simulation
by SIMC and in the real protocol are indistinguishable.
4.4 Data Transfer
It is often required to transfer additional data di (e.g. a
database tuple) along with a matching element si. Our pro-
tocols can be easily extended to accommodate data transfer.
Let EKi (x) denote the symmetric encryption with key Ki.
The server chooses a random key Ki in the symmetric en-
cryption system for each element si. It uses the (bit-wise)
expanded ciphertext El(Ki) of the key instead of the ex-
panded ciphertext El(si) of the element in preparing its re-
sponse and also returns EKi (si, di) to the client. The client
can now recover the key Ki, if it used to be able to recover
the element si (i.e. in case of a match). Using the key it can
decrypt the data.
4.5 Comparison
We compare our M P SI protocol to the best known pri-
vate set intersection protocol in the malicious model in [10].
We compare correctness, communication complexity and com-
putational performance. Nevertheless, diﬀerently from [10]
we do not require random oracles or any assumption stronger
than hardness of determining quadratic residuosity.
4.5.1 Correctness
Bloom ﬁlter may produce false positives. In our case the
probability of a false positive is 2−k + 2−l. Note that the pa-
rameters can be chosen to make this probability arbitrarily
small.
In [10] there is no correctness parameter stated, but it has
an implicit one depending on its security parameter κ. In
their case the probability of a false positive is 2−κ.
4.5.2 Communication
Depending on the correctness parameters we also increase
communication complexity. We transfer m + lw group ele-
ments. Assuming m is chosen depending on the client’s set
size, we transfer O(kv + lw) group elements.
The protocol of [10] requires less communication, such
that it is beneﬁcial in congested networks. It transfers 7v +3
group elements and w + 1 cryptographic hashes. Although
we achieve better performance for very large client set sizes
(and k < 7ln22 < 4), these seem unreasonable assumptions
in practice.
4.5.3 Performance
We now compare the performance of our M P SI protocol
to the performance of the best variant in [10]. A detailed
analysis of the performance of all P SI protocols can be also
found in [10]. They conclude that the protocol in [10] has
the lowest constants of the linear complexity protocols. This
is underpinned by several implementations in [12].
GM encryption only uses modular multiplication and we
can prepare in a pre-computation phase all quadratic residues
r2 for randomizing the ciphertexts. The client does not need
to perform any encryption – this is done during certiﬁcation
by the trusted third party. The server needs to expand the
ciphertexts and therefore compute the negation (k modular
multiplications). It does not need to randomize each cipher-
text in the expanded ciphertext, but only the result (l mod-
ular multiplications). Then it needs to compute the product
of the expanded ciphertexts and the element (kl + l modu-
lar multiplications). The server performs this operations for
each of its w elements. In summary, we have w(kl + k + 2l)
modular multiplications.
De Cristofaro et al.
[10] achieve 240w + 960v modular
multiplications. If we instantiate k = 16 and l = 32, then
we achieve 592w modular multiplications.
We emphasize that the analysis in [10] ignores v + w full-
domain hash functions. If we – following their convention
– estimate each full domain hash function as 240 modular
multiplications, then their cost increases to 480w + 1200v.
Our protocol is more eﬃcient, if the client set size v is at
least one tenth of the server set size w. Furthermore, in any
case the computational load on the client using our proto-
cols is signiﬁcantly smaller and therefore better suitable for
computationally weak devices.
De Cristofaro et al.
[10] also assume pre-computation of
ﬁxed-base modular exponentiations. This may become a
problem when dealing with multiple protocol instances with
diﬀerent parameters. If we ignore those (and, of course, our
pre-computation of quadratic residues), then our protocol is
more eﬃcient, if the client set size v is at least 6% of the
server set size w.
We conclude that our protocol has similar constants to
the most eﬃcient, linear-complexity version of [10]. We re-
mind the reader that our protocol is secure in the standard
model whereas [10] requires random oracles. As the ﬁrst
P SI protocol we show an outsourced variant in the next
section.
5. OUTSOURCING
A novel and useful feature of using Bloom ﬁlter for private
set intersection is that the computation can be outsourced to
an oblivious service provider, e.g. in cloud computing. The
goal of an oblivious service provider – as opposed to the
trusted third party in the ideal model – is that the provider
does not learn anything about the inputs or the intersection
(including its size). We modify our protocol as follows. The
client still submits its encrypted Bloom ﬁlter b for its set
{c1, . . . , cv}, but the server now submits a Bloom ﬁlter b′
i for
each si. Note that the service provider does not have access
to the hash function results hj (si). The service provider
C
:
b =Create(m)
i = 1, . . . v : b.Add(ci)
:
C −→ P : n, u, E1(b1), . . . , E1(bm)
S
i = 1, . . . , w : b′
b′