**CVE-2015-1062**
**MobileStorageMounter – Fixed in iOS 8.2**
Available for: iPhone 4s and later, iPod touch (5th generation) and later,
iPad 2 and later
Impact: A malicious application may be able to create folders in trusted
locations in the file system
Description: **An issue existed in the developer disk mounting logic which
resulted in invalid disk image folders not being deleted.** This was addressed
through improved error handling.
CVE-ID
**CVE-2015-1062** : TaiG Jailbreak Team  
---  
表8:CVE-2015-1062
**Payload 说明**
Payload 有两个,即两个 dmg 文件。
第一个 dmg 有三个分区:
1、DeveloperDiskImage,空分区
2、DeveloperCaches,后续会被 mount 到 /System/Library/Caches
3、DeveloperLib,后续会被 mount 到 /usr/lib
具体内容如下:
├── Developer-Caches
│ └── com.apple.dyld
│ └── **enable-dylibs-to-override-cache**
├── Developer-Lib
│ ├── FDRSealingMap.plist
│ ├── StandardDMCFiles
│ │ ├── N51_Audio.dmc
│ │ ├── N51_Coex.dmc
│ │ ├── N51_Default.dmc
│ │ ├── N51_Flower.dmc
│ │ ├── N51_FullPacket.dmc
│ │ ├── N51_GPS.dmc
│ │ ├── N51_Powerlog.dmc
│ │ ├── N51_SUPL.dmc
│ │ ├── N51_Sleep.dmc
│ │ └── N51_Tput.dmc
│ ├── dyld
│ ├── libDHCPServer.dylib -> libDHCPServer.A.dylib
│ ├── libMatch.dylib -> libMatch.1.dylib
│ ├── libexslt.dylib -> libexslt.0.dylib
│ ├── **libmis.dylib**
│ ├── libsandbox.dylib -> libsandbox.1.dylib
│ ├── libstdc++.dylib -> libstdc++.6.dylib
│ ├── system
│ │ └── introspection
│ │ └── libdispatch.dylib
│ └── xpc
│ └── support.bundle
│ ├── Info.plist
│ ├── ResourceRules.plist
│ ├── _CodeSignature
│ │ └── CodeResources
│ └── support
└── DeveloperDiskImage
10 directories, 24 files  
---  
表9:contents of 1stdmg
第一个 dmg 中有两个文件比较重要需要说明下:
1、enable-dylibs-to-override-cache:我们知道 iOS 中几乎所有的 dylib 都被 Prelink 到一个 Cache
文件中,程序默认都是从 Cache 中加载 dylib,而忽略文件系统中的 dylib。当文件系统中存在 enable-dylibs-to-override-cache 时,dyld(Image Loader)才会优先加载文件系统中的
dylib。苹果可能是利用这个机制为自己留条后路或者说支持系统组件的热更新。
2、libmis.dylib,malformed 的 dylib,用于过代码签名,后续会具体说明。
第二个 dmg 的内容如下,主要是越狱相关的内容:
├── Library
│ └── Lockdown
│ └── ServiceAgents
│ ├── com.apple.load_amfi.plist
│ ├── com.apple.mount_cache_1.plist
│ ├── com.apple.mount_cache_2.plist
│ ├── com.apple.mount_cache_3.plist
│ ├── com.apple.mount_cache_4.plist
│ ├── com.apple.mount_cache_5.plist
│ ├── com.apple.mount_cache_6.plist
│ ├── com.apple.mount_cache_7.plist
│ ├── com.apple.mount_cache_8.plist
│ ├── com.apple.mount_lib_1.plist
│ ├── com.apple.mount_lib_2.plist
│ ├── com.apple.mount_lib_3.plist
│ ├── com.apple.mount_lib_4.plist
│ ├── com.apple.mount_lib_5.plist
│ ├── com.apple.mount_lib_6.plist
│ ├── com.apple.mount_lib_7.plist
│ ├── com.apple.mount_lib_8.plist
│ ├── com.apple.ppinstall.plist
│ ├── com.apple.remove_amfi.plist
│ ├── com.apple.umount_cache.plist
│ └── com.apple.umount_lib.plist
├── bin
│ └── ppunmount
├── pploader
└── pploader.idb
4 directories, 24 files  
---  
表10:contents of 2nddmg
这个 dmg 会被 mount 到 /Developer,这其中的内容会被系统统一考虑,具体来说就是:假设 /Developer/bin
中的程序默认在系统的查找路径中。
**漏洞解析**
苹果对这个漏洞的描述相对比较简单,网络上对这个问题的描述是可以利用竟态条件替换 dmg,竟态条件是主要问题,但是竟态条件问题苹果根本没有
Fix,也很难修复。但是 DDI 还存在另外一个问题,下面我们一起看下。
触发漏洞之前,/dev 中的内容:
brw-r—– 1 root operator 1, 0 Jun 26 19:07 /dev/disk0
brw-r—– 1 root operator 1, 1 Jun 26 19:07 /dev/disk0s1
brw-r—– 1 root operator 1, 3 Jun 26 19:07 /dev/disk0s1s1
brw-r—– 1 root operator 1, 2 Jun 26 19:07 /dev/disk0s1s2
brw-r—– 1 root operator 1, 4 Jun 26 19:07 /dev/disk1
brw-r—– 1 root operator 1, 5 Jun 26 19:07 /dev/disk2
brw-r—– 1 root operator 1, 6 Jun 26 19:07 /dev/disk3
brw-r—– 1 root operator 1, 7 Jun 26 19:07 /dev/disk4
brw-r—– 1 root operator 1, 8 Jun 26 19:08 /dev/disk5  
---  
表11:mount dmg 前
触发漏洞之后,/dev 中的内容:
brw-r—– 1 root operator 1, 0 Jun 26 19:22 /dev/disk0
brw-r—– 1 root operator 1, 1 Jun 26 19:22 /dev/disk0s1
brw-r—– 1 root operator 1, 2 Jun 26 19:22 /dev/disk0s1s1
brw-r—– 1 root operator 1, 3 Jun 26 19:22 /dev/disk0s1s2
brw-r—– 1 root operator 1, 4 Jun 26 19:22 /dev/disk1
brw-r—– 1 root operator 1, 5 Jun 26 19:22 /dev/disk2
brw-r—– 1 root operator 1, 6 Jun 26 19:22 /dev/disk3
brw-r—– 1 root operator 1, 7 Jun 26 19:22 /dev/disk4
brw-r—– 1 root operator 1, 8 Jun 26 19:23 /dev/disk5
**brw-r—– 1 root operator 1, 9 Jun 26 19:26 /dev/disk6**
**brw-r—– 1 root operator 1, 10 Jun 26 19:26 /dev/disk6s1**
**brw-r—– 1 root operator 1, 11 Jun 26 19:26 /dev/disk6s2**
**brw-r—– 1 root operator 1, 12 Jun 26 19:26 /dev/disk6s3**  
---  
表12:mount dmg 后
上面是利用竟态条件 mount 第一个 dmg 之前与之后的结果,上面已经提到第一个 dmg 的 DeveloperDiskImage
分区是空的,不存在内容替换问题。
从上面的对比可以看到 MobileStorageMounter 还存在另外一个问题就是:在 mount 非法的 dmg 时,即使 mount
失败,相应的分区还在设备目录中存在,在越狱过程中这些 disk 会被挂载:
disk6s3 被 mount 到 /System/Library/Caches
disk6s2被 mount 到 /usr/lib
**触发竟态条件**
在触发竟态条件做 dmg 替换前,需要找到 dmg 的临时目录,下面会说明 dmg 临时目录的构造规则。
先看真实的路径,然后再说明构造方法:
/var/run/mobile_image_mounter/
**6d55c2edf0583c63adc540dbe8bf8547b49d54957ce9dc8032d1a9f9ad759e2b**
**1fe99fcb2baeb3db5348ab322cb65c7fc38b59cb75697cbc29221dce1ecd120d** /
**909b75240921fc3f2d96ff08d317e199e033a7f8a8ff430b0c97bf3c6210fc39**
**f35e1c239d1bf7d568be613aafef53104f3bc1801eda87ef963a7abeb57b8369** /  
---  
表13:mount dmg 生成的临时目录
如上表,蓝色是路径的第一部分,绿色是路径的第二部分,下面看下 dmg 对应的签名文件内容:
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/iOSJB812-DDI-SIG.png)
图3:DeveloperDiskImage.dmg.signature
对比之后可以看到临时路径的生成规则是:将签名文件的内容转换为十六进制字符串,然后将前64个字节作为路径的第一部分,将后64个字节作为路径的第二部分,之后在拼接上一个随机生成文件名的
dmg 文件,如:1Nm843.dmg。
在找到 dmg 文件后,触发竟态条件就相对容易些,具体方法为:首先检查 DDI 是否已经 mount 了(开发设备很可能已经 mount 了),如果已经
mount 了,重启设备。如果没有 mount,首先加载真实的 DDI 与签名,然后创建临时目录,上传假的 DDI,再调用相关服务mount 真实的
DDI,紧接着用假的 DDI 去替换上面提到的临时文件(1Nm843.dmg)。
**利用结果**
完成利用 DDI 的漏洞后,第一个 dmg 的分区在设备上保留,第二个 dmg 的内容被挂载到 /Developer:
/Developer/Library
/Developer/bin
/Developer/ **pploader**
/Developer/Library/Lockdown
/Developer/Library/Lockdown/ **ServiceAgents**
/Developer/Library/Lockdown/ServiceAgents/com.apple. **load_amfi**.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple. **mount_cache** _1.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_cache_2.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_cache_3.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_cache_4.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_cache_5.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_cache_6.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_cache_7.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_cache_8.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple. **mount_lib** _1.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_lib_2.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_lib_3.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_lib_4.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_lib_5.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_lib_6.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_lib_7.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.mount_lib_8.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple. **ppinstall**.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple. **remove_amfi**.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.umount_cache.plist
/Developer/Library/Lockdown/ServiceAgents/com.apple.umount_lib.plist