### 取消对上下文和未定义子程序的检查

要取消对上下文和未定义子程序的检查，可以使用以下命令：
```perl
$ perl -MO=Lint,-context,-undefined-subs myperlprogram
```
如需了解更多选项信息，请参阅 `B::Lint`。

### 简化的C后端

该模块用于将Perl程序的内部编译状态存储到一个C代码文件中。生成的C代码可以通过特定平台上的C编译器转换为可执行文件。最终的程序会与Perl解释器库静态链接，因此不会节省磁盘空间（除非你的Perl是用共享库创建的），也不会减小程序大小。然而，程序启动速度会更快。

默认情况下，`perlcc` 工具生成如下可执行文件：
```bash
perlcc myperlprogram.pl
```

### 字节码后端

该模块在能够找到方法加载并运行其生成的字节码时才有用。`ByteLoader` 模块提供了这项功能。

要将Perl转换成可执行的字节码，可以使用 `perlcc` 的 `-B` 选项：
```bash
perlcc -B myperlprogram.pl
```

字节码与机器类型无关，因此一旦编译了一个模块或程序，它就像Perl源代码一样具有可移植性（假设用户有一个足够新的Perl解释器来解码字节码）。

有关生成字节码的性质和优化参数的详细信息，请参考 `B::Bytecode`。

### 优化的C后端

优化的C后端将Perl程序转换为等效但经过优化的C代码文件，按照语法树中运行时代码的路径进行操作。这个C程序直接操作Perl的数据结构，并且会链接Perl解释器的库文件，以支持 `eval()`, `s///e`, `require` 等功能。

`perlcc` 工具使用 `-O` 选项生成这种可执行文件。要编译一个Perl程序（以 `.pl` 或 `.p` 结尾）：
```bash
perlcc -O myperlprogram.pl
```

从Perl模块创建一个共享库文件（以 `.pm` 结尾）：
```bash
perlcc -O Myperlmodule.pm
```

更多详细信息，请参阅 `perlcc` 和 `B::CC`。

### 编译套件的模块列表

- **B**: 该模块是一个自省模块，允许Perl程序查看自己的内部结构。后端模块通过此模块访问语法分析树。
- **O**: 这个模块是编译器前端，通常这样调用：
  ```perl
  $ perl -MO=Deparse myperlprogram
  ```
  这与在Perl程序中使用 `use O 'Deparse'` 相同。
- **B::Asmdata**: 被 `B::Assembler` 模块使用，而 `B::Assembler` 又被 `B::Bytecode` 模块使用，用于存储语法分析树以便以后加载。
- **B::Assembler**: 将语法树转换为适合存储和恢复的数据形式。它是某个后端的一个组件。
- **B::Bblock**: 被 `B::CC` 后端使用，用于处理基本块。
- **B::Bytecode**: 从程序的语法树生成字节码。具体用法请参考“字节码后端”部分。
- **B::C**: 根据语法树和其他一些解释器的内部数据结构生成C代码。具体用法请参考“简化的C后端”部分。
- **B::CC**: 生成不包含解释器的C程序，因此运行速度更快。具体用法请参考“优化的C后端”部分。
- **B::Concise**: 输出简洁但完整的Perl分析树。对于编写自己的后端或学习Perl实现的人非常有用。
- **B::Debug**: 将Perl语法分析树详细输出到标准输出。对于编写自己的后端或深入研究Perl内部机制的人非常有用。
- **B::Deparse**: 将编译后的语法树反向解析为Perl源代码。具体用法请参考“反编译后端”部分。
- **B::Disassembler**: 将字节码恢复成语法树。它是某个后端的一个组件。
- **B::Lint**: 检查代码编译后的格式，标记那些容易引起问题的地方。具体用法请参考“Lint后端”部分。
- **B::Showlex**: 打印 `my()` 中的变量在函数或文件中的使用情况。具体用法请参考相关示例。
- **B::Stackobj**: 被 `B::CC` 模块调用。它是某个后端的一个组件。
- **B::Stash**: 被 `perlcc` 程序调用，用于阻止 `B::CC` 为某些模块生成C代码。它是某个后端的一个组件。
- **B::Terse**: 打印语法树的内容，但信息比 `B::Debug` 少得多。对于编写自己的后端或深入研究Perl内部机制的人非常有用。
- **B::Xref**: 打印报表列出程序中定义和使用的变量、子程序或格式。具体用法请参考“交叉引用后端”部分。

### 已知的问题

- 简单 C 后端目前只保存以字符和数字命名的类型说明。
- 优化的 C 后端会为一些不该为之输出的模块（例如 `DirHandle`）生成代码，并且可能无法正确处理外部 `goto` 语句。此外，它还会生成巨大的初始化函数，导致C编译器难以处理。
- `BEGIN{}` 块会在编译时执行，可能会导致外部状态初始化不正确。为解决这个问题，可以使用 `INIT{}` 块，在程序正式运行之前执行初始化代码。

### 作者

本文最初由 Nathan Torkington 编写，现由邮件列表 (perl5-porters@perl.org) 维护。

### 译者

郭锐 (sunny65535)