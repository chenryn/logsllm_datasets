要取消对上下文和没有定义的子程序的检查：
.PP
.Vb 1
\&  $ perl -MO=Lint,-context,-undefined-subs myperlprogram
.Ve
.PP
要知道更多的选项信息，请看 B::Lint 
.Sh "The Simple C Back End 简化的C后端"
.IX Subsection "The Simple C Back End"
这个模块用来把你的Perl程序的内部编译状态存储到一个C代码文件中去，而生成的C代码就可以被特定平台上的C编译器转换成一个可执行文件了。最后的程序还会和Perl解释器的库文件静态链接起来，所以它不会节省你的磁盘空间（除非你的Perl是用共享的库文件创建的）或是程序大小，然而，另一方面，程序启动起来会快一些。
.PP
\f(CW\*(C`perlcc\*(C'\fR 工具缺省是生成以下的可执行文件。
.PP
.Vb 1
\&  perlcc myperlprogram.pl
.Ve
.Sh "The Bytecode Back End 字节码后端"
.IX Subsection "The Bytecode Back End"
这个模块只有在你能够找到一种方法来装入并运行它生成的字节码时才会显得有用。ByteLoader模块提供了这项功能。
.PP
要把Perl转换成可执行的字节码，你可以使用 \f(CW\*(C`perlcc\*(C'\fR 的 \f(CW\*(C`\-B\*(C'\fR 开关:
.PP
.Vb 1
\&  perlcc -B myperlprogram.pl
.Ve
.PP
字节码是和机器类型无关的，所以一旦你编译了一个模块或是程序，它就可以像Perl源代码一样具有可移植性。（假设那个模块或者程序的使用者有一个足够新的Perl解释器来对字节码进行解码）
.PP
有一些选项用来控制要生成的字节码的性质和关于优化方面的参数，要知道这些选项的详细情况，请参考 \fBB::Bytecode\fR
.Sh "The Optimized C Back End 优化的C后端"
.IX Subsection "The Optimized C Back End"
优化的C后端按照语法树中运行期代码的路径将你的Perl程序转换成等效的(但是被优化了的)C代码文件。这个C程序会直接对Perl的数据结构进行操作，而且也会链接Perl的解释器的库文件，以支持 \fIeval()\fR, \f(CW\*(C`s///e\*(C'\fR, \&\f(CW\*(C`require\*(C'\fR  等等。
.PP
\f(CW\*(C`perlcc\*(C'\fR 工具使用 \-O 开关生成这种可执行文件。要编译一个Perl程序（以\f(CW\*(C`.pl\*(C'\fR 或者\f(CW\*(C`.p\*(C'\fR 结尾）：
.PP
.Vb 1
\&  perlcc -O myperlprogram.pl
.Ve
.PP
从Perl模块创建一个共享库文件（以 \f(CW\*(C`.pm\*(C'\fR 结尾）：
.PP
.Vb 1
\&  perlcc -O Myperlmodule.pm
.Ve
.PP
知道更多，请参考 perlcc 和 B::CC.
.SH "Module List for the Compiler Suite 编译套件的模块列表"
.IX Header "Module List for the Compiler Suite"
.IP "B" 4
.IX Item "B"
这个模块是一个自省的（introspective，用Java的术语说就是“reflective”）模块，允许Perl程序审视自己的内部。后端模块都是通过这个模块来访问语法分析树的。而你，后端模块的用户，就不用和B模块打交道了。
.IP "O" 4
.IX Item "O"
这个模块是编译器的那些后端的前端，一般像这样进行调用：
.Sp
.Vb 1
\&  $ perl -MO=Deparse myperlprogram
.Ve
.Sp
这与在这个Perl程序中使用 \f(CW\*(C`use O 'Deparse'\*(C'\fR 相同。
.IP "B::Asmdata" 4
.IX Item "B::Asmdata"
这个模块被 B::Assembler 模块使用，而 B::Assembler 又接着被 B::Bytecode 模块使用，B::Bytecode中有一个字节码形式存放的语法分析树以便以后装入。B::Asmdata自己并不算是一个后端，也许说它是后端的一个组件比较好。
.IP "B::Assembler" 4
.IX Item "B::Assembler"
这个模块可以将语法树转为适合存储和恢复的数据形式。它本身不是一个后端，但是算是某个后端的一个组件。 assemble  程序用它来生成字节码。
.IP "B::Bblock" 4
.IX Item "B::Bblock"
这个模块被 B::CC 后端使用。它被用来运行“基本块”。一个基本块就是一段从头到尾的操作，中间是不可能停下来或出现分支的。
.IP "B::Bytecode" 4
.IX Item "B::Bytecode"
这个模块可以由程序的语法树生成字节码。生成的字节码会被写入到文件中，以后还能被重新恢复成语法树。总的目标就是为了只进行一次费时的程序编译工作，然后把解释器的状态存入文件中，运行程序时再把状态从文件中恢复。 具体的用法请参考 \*(L"The Bytecode Back End\*(R" 。
.IP "B::C" 4
.IX Item "B::C"
这个模块按照语法树和其他一些解释器的内部数据结构生成C代码。然后你再编译生成的C代码，就可以得到一个可执行文件了。运行时这个可执行文件会恢复解释器和内部的数据结构来转动程序。要知道细节请参考 \*(L"The Simple C Back End\*(R"。
.IP "B::CC" 4
.IX Item "B::CC"
这个模块按照你程序中的操作生成C代码。不像 B::C 模块只是把解释和它的状态存入C程序中， B::CC 模块生成的是不包含解释器的C 程序，所以用 B::CC 翻译的C 程序运行速度比一般的解释执行的程序速度要快，具体用法请参考 \*(L"The Optimized C Back End\*(R" 。
.IP "B::Concise" 4
.IX Item "B::Concise"
这个模块输出一个简洁的 (但是完整的) Perl 分析树。它的输出比 B::Terse 或者 B::Debug 的结果更容易定制 (并且也可以模仿它们)。这个模块对书写自己的后端，或者学习 Perl 实现的人有用。它对一般的程序员没有用处。
.IP "B::Debug" 4
.IX Item "B::Debug"
这个模块把Perl语法分析树非常详细地输出到标准输出上去。这对正在编写自己的后端程序，或正在深入Perl内部机制的人们来说是非常有用的。对普通程序员来说则没什么用。
.IP "B::Deparse" 4
.IX Item "B::Deparse"
这个模块将编译了的语法树反向分析得出Perl源代码，这在调试或是反编译他人代码的时候会是非常有用的。另外让它为你自己的代码做一些美化工作也是可以的。要知道细节请参考 \&\*(L"The Decompiling Back End\*(R"。
.IP "B::Disassembler" 4
.IX Item "B::Disassembler"
这个模块把字节码恢复成语法树，它本身不是一个后端，而是某个后端的一个组件。它会被和字节码在一起的 disassemble 程序使用。
.IP "B::Lint" 4
.IX Item "B::Lint"
这个模块审视你的代码编译后的格式，并且找到那些容易让人皱眉，却又不至于引起警告的地方。举例来说，使用一个标量内容（scalar context）的数组，而不显式地申明成 \f(CW\*(C`scalar(@array)\*(C'\fR 。这种情况是会被 Lint 标示出来的。要知道细节请参考  \*(L"The Lint Back End\*(R"。
.IP "B::Showlex" 4
.IX Item "B::Showlex"
这个模块打印出 \fImy()\fR 中的变量在函数或是文件中的使用情况，以得到一份关于 \fImy()\fR 中的变量在定义于文件 myperlprogram 中的子程序 \fImysub()\fR 中的使用情况的列表：
.Sp
.Vb 1
\&  $ perl -MO=Showlex,mysub myperlprogram
.Ve
.Sp
要得到一份关于 my() 中的变量在文件myperlprogram中的使用情况的列表：
.Sp
.Vb 1
\&  $ perl -MO=Showlex myperlprogram
.Ve
.Sp
[\s-1BROKEN\s0]
.IP "B::Stackobj" 4
.IX Item "B::Stackobj"
这个模块被 B::CC 模块调用。它本身不是后端，但是是某个后端的一个组件。
.IP "B::Stash" 4
.IX Item "B::Stash"
这个模块被 perlcc  程序调用，而perlcc可以把一个模块编译成可执行文件。B::Stash 把程序使用的符号表打印出来，并被用来阻止 B::CC 为 B::* 或是 O 模块生成C 代码。它本身不是后端，但是是某个后端的一个组件。
.IP "B::Terse" 4
.IX Item "B::Terse"
这个模块用来打印语法树的内容，但是信息不会有B::Debug打印的那么多。对比来说，\f(CW\*(C`print "Hello, world."\*(C'\fR 会让 B::Debug 产生96行输出， 但是 B::Terse只会有6行。
.Sp
这个模块对正在编写自己的后端程序，或正在深入Perl内部机制的人们来说是非常有用的。对普通程序员来说则没什么用。
.IP "B::Xref" 4
.IX Item "B::Xref"
这个模块打印一个报表列出在程序中哪里定义和使用了哪些变量，子程序或格式，报表还会列出程序装入的模块。要知道详细的使用方法，请参考 \*(L"The Cross Referencing Back End\*(R" 。
.SH "KNOWN PROBLEMS 已知的问题"
.IX Header "KNOWN PROBLEMS"
简单 C 后端目前只保存以字符和数字命名的类型说明
.PP
优化的 C 后端会为一些不该为之输出的模块（比如说 DirHandle）输出代码。而且它不太可能正确地处理正在执行的子程序外部的goto语句（goto &sub is OK）。目前 \f(CW\*(C`goto LABEL\*(C'\fR 语句在这个后端中完全不会工作。他还会生成让C 编译器头痛无比的巨大的初始化函数。如果把这个初始化函数分割开是能得到比目前更好的效果的。另外的问题包括：处理无符号的数学问题时不能正确工作；一些操作码如果按照默认的操作码机制处理也会有非正常的结果。
.PP
BEGIN{} 块会在编译你的代码的时候被执行。所有的在BEGIN{} 中初始化的外部状态，如打开的文件，初始的数据库连结等等，会有不正确的表现。为了解决这个问题，Perl中又提供了一个 INIT{} 块来对应程序编译之后，正式运行之前要执行的那段代码。执行的顺序是：BEGIN{}, (后端编译程序可能这时会保存状态), INIT{}, 程序运行, END{}。
.SH "AUTHOR 作者"
.IX Header "AUTHOR"
这篇文章最初是由 Nathan Torkington 编写，现在由邮件列表(perl5\-porters@perl.org.)维护
.SH "译者"
.B 郭锐(sunny65535) 