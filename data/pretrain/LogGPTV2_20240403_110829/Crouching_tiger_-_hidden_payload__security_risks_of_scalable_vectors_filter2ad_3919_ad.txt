ﬁer is very well maintained, receives frequent updates and
security ﬁxes. Another reason is the quality of ﬁltering: we
have only identiﬁed a few bypasses for this tool and every
single one of them was ﬁxed very quickly upon having con-
tacted the developers. Still, most importantly, HTMLPur-
ﬁer’s internal API allows to ﬁlter arbitrary XML data and is
not limited to HTML by design, unlike the other tested tools.
This knowledge allowed us to create an SVGPuriﬁer branch,
a software that is using the HTMLPuriﬁer API, but is not
touching the core components. Our SVGPuriﬁer has been
supplied with a large array of data based on the SVG speciﬁ-
cations deﬁning which tags and attributes should be allowed
in the user-generated SVG ﬁles. We explicitly whitelist tags
and attributes, as well as the tag-attribute combinations and
speciﬁc value ranges for attributes. Uncommon sources for
cross-site scripting attacks, such as the  tag on older
Webkit-based browsers, are limited by SVGPuriﬁer.
The  tag can be used in SVG ﬁles, similarly to the
timing driven equivalent , although the
attributeName value can only consist of a limited amount
of values. Speciﬁcally, we only allow those values which can-
not be used to initiate or overwrite event handlers, change
xlink:href values on the ﬂy, or reposition elements and ele-
ment groups on a website. Our tests showed that the 
and  tags can be used to assign javascript: and
data: URIs to existing elements. This can either enable
attacks by initiating malicious remote inclusions, or apply
malicious URL schemes to the existing elements.
Attacks like the one just portrayed, as well as those shown
in Listing 4, can be no longer carried out. Take account of
the fact that the / functionality is not re-
moved completely, only the remote includes and the assign-
ment of malicious URL handlers have been blocked. Fur-
thermore, the resulys of our evaluation show that only two
ﬁles out of more than 100,000 tested instances from the
Wikipedia servers made use of the / feature
at all (see Section 5 for details).
SVGPuriﬁer completely forbids and removes 
as well as  tags and event handler usage.
Later versions of our puriﬁcation approach might prove to
add a supplementary scripting layer to allow basic Java-
Script execution, but hinder scripts from reading, and over-
writing sensitive data, or conduct other activities capable
of leaking sensitive data or deploying malicious code [26].
As further elaborated on in Section 5, our tests showed that
none of the analyzed and puriﬁed SVG used actual 
tags. Surprisingly, a large percentage of the test ﬁles were
making use of  tags. The reason behind it
is that the software Adobe Illustrator uses this tag to hide
proprietary meta-info in the SVG images generated by this
tool [7]. Removing these tags does not aﬀect the visual in-
formation provided by the SVG ﬁle.
Similar problems can be caused by maliciously crafted
SVG Cascading Stylesheets (SVGCSS). SVG styles support
more properties than classic CSS for (X)HTML documents
and speciﬁcally extend the feature set with font formatting,
typographic features, extended pointer event behavior, and
the possibility to reference to other SVG elements containing
deﬁnitions and visual eﬀects. Arbitrary SVG elements can
constitute reference to other SVG elements or even let exter-
nal SVG ﬁles to borrow visual information or functionality
including event handling. Those references can be deﬁned
via FunctionIRI or the fully qualiﬁed paths via protocol
schemes such as data, HTTP and others. SVGPuriﬁer guar-
antees that no external references can be loaded by elements
allowing script execution. The  tag on modern Opera
browser versions is conversely problematic. This tag can be
utilized to include external resources executing JavaScript
or providing links with potentially malicious URL handlers.
Currently, SVGPuriﬁer scans style elements and attributes
of the puriﬁed SVG for potentially malicious patterns and
neutralizes them by overwriting certain parts of the payload.
This includes replacing strings indicating the use of CSS ex-
pressions, Opera link and link target properties, as well as,
data binding approaches with the placeholder INVALID. List-
ing 5 demonstrates an example for a puriﬁcation result. Be
assured that we do not forbid dangerous tags such as ,
but analyze the attribute values and remove them in case
an attack could be initiated by their contents.
// before
// after
Listing 5: A malicious SVG before and after
puriﬁcation
246Section 5 will further build upon the results of this pu-
riﬁcation process and furnish insight into how far this (for
XML data unconventional) approach aﬀects the visual in-
formation provided by the SVG test set.
SVGPuriﬁer itself has undergone substantial testing from
the security community during a public demonstration over
a time-frame of several months [24]. The results helped us
to reﬁne the ﬁltering mechanism and spot all the less ob-
vious and diﬃcult to ﬁnd browser behaviors requiring dedi-
cated ﬁxes to deliver eﬀective ﬁltering and keep the security
promise that the tool poses. During the testing phase we
logged about 500 attempts targeted to break the ﬁlter func-
tionality of the SVGPuriﬁer and inject malicious content.
Of those, about 15 were successful and resulted in the re-
ﬁnement of our algorithms. The SVGPuriﬁer performance
scales with the number of SVG tags and elements to sani-
tize, but can be considered uncritical since the main use case
for the tool is on the server-side (e.g., each uploaded SVG
image is transformed to remove suspicious content).
A server-side solution has the advantage that a website
owner can performantly protect its users from attacks using
SVGs and not requiring all users to upgrade their client-
software. Our evaluation showed that the SVGPuriﬁer was
capable of removing malicious code in all of the discussed
test cases. We examined possibilities to craft a purely client-
side SVG ﬁlter combined with the possibility of limiting
down DOM elements and their capabilities. Our initial re-
search showed that this is feasible and considered as future
work.
4.3 Unexpected Browser Behavior
We also found several cases of unusual and (depending on
the execution context) often problematic browser behaviors
that forced us to adapt SVGPuriﬁer to address them:
• The Opera AII attacks mentioned in Section 3.5 have
not been ﬁxed by the vendor despite several bug re-
ports from our side. This problem complicates the im-
plementation of SVGPuriﬁer since basically any exter-
nal image resource loaded by an SVG ﬁle could contain
suspicious plugin code and initiate an attack.
• Most browsers support the SVG  tag, but so far
only Opera allows to include external SVG resources
containing script code to execute, or links to show and
point to possibly malicious URIs via URL handlers
such as javascript and data. Most browsers tested
permit utilizing the  as well as the  tag
to transform xlink:href attributes and set them with
JavaScript and data URIs, too. This should be re-
stricted by browsers for the sake of avoiding injection
attacks via , , and . However,
none of the over 100.000 SVG ﬁles we have tested dur-
ing our evaluation actually used this feature.
• Plain text tags inside SVG images such as ,
, , and similar tags allow to use
HTML entities, giving them an equivalent syntacti-
cal meaning as their canonical forms. This was rele-
vant for several of the XSS ﬁlter bypasses we described
in Section 3.4. Especially the automated decoding of
entities such as &lt; and &gt; could be used to by-
pass XSS ﬁlters and common protection mechanisms.
Browsers therefore need to be more selective in deter-
mining which entities get automatically decoded and
which do not. For example, Google Chrome went as
far as to completely disable the automated decoding.
Some of these behaviors forced us to customize SVGPuriﬁer
and reduce the available feature set. Later versions of the
tool might be less restrictive, assuming that the browser
bugs get ﬁxed and the market share of the aﬀected browser
versions shrinks to an insigniﬁcant level. Future versions of
the tool will also be capable of handling external entities
and place their proper value at the desired locations.
5. EVALUATION
We have implemented a prototype of SVGPuriﬁer, con-
sisting of 5,663 lines of PHP code. To evaluate the tool, we
compiled a test set of SVG images obtained from Wikipedia.
We chose this platform for several reasons: SVG images are
widely used within Wikipedia, the content of the platform
consists of the contributions from a large community, and
among the contributors, the employment of a diverse set of
tools to create the images can be observed. As a result, we
have a heterogeneous test set that enables us to study the
robustness and versatility of SVGPuriﬁer.
To download the ﬁles, we used wikix, a tool that uses a
snapshot of Wikipedia (exported as XML) to generate the
URLs of the SVG ﬁles hosted at upload.wikimedia.org.
The latest snapshot of the english Wikipedia at the time
of writing has referenced a total of 112,646 SVG images.
105,509 were actually available for download at that time
and we used those ﬁles for our evaluation.
5.1 Evaluation Setup
In order to minimize the impact of SVGPuriﬁer on us-
ability, the tool should not alter the visual appearance of an
image since this would decrease the user experience. Our
implementation only removes elements from an SVG ﬁle,
thus (by construction) no new image element will appear
in a puriﬁed image. However, the cleaning process might
be too aggressive, i.e., cases where we remove elements that
have a visual impact on the resulting image might occur.
To evaluate this eﬀect, we compare the original image with
the puriﬁed one and determine if the ﬁle was altered during
the process. Since the size of our test set is too large for a
manual evaluation, we developed an approach to compare
SVG ﬁles in an automated way.
Comparing two SVG images for similarity is diﬃcult, re-
sulting from the fact that there are countless ways of achiev-
ing the same visual appearance. Consequently, contrasting
only the XML markup does not enable us to determine if a
pair of images has the same visual appearance. Therefore,
we decided to convert the SVG ﬁles to Portable Network
Graphics (PNG) format and then perform the comparative
step. PNG is a raster graphics format providing lossless data
compression. Each pixel is deﬁned in an 24 bit RGB color-
space with an optional 8 bit alpha channel (32 bit RGBA).
Comparing two PNG ﬁles for similarity can thus be achieved
by matching the value of each channel for each pair of pixels,
which in turn results in a numerical value representing the
absolute error a. A value of a = 0 indicates that no diﬀer-
ence between the two images was found, while a > 0 denotes
some discrepancy. Note that this evaluation measures the
visual impact of our tool and approximates the deviation
caused by the transformation process.
247We tested the following four tools regarding their capabil-
ity to convert SVG images to PNG format:
• Apache batik (http://xml.apache.org/batik/)
• rSVG (http://librsvg.sourceforge.net/)
• GIMP (http://www.gimp.org/)
• Inkscape (http://inkscape.org/)
Based on our test set, we have empirically found that the
Apache batik toolkit was able to convert the largest number
of ﬁles: only 23 of the 105,509 ﬁles could not be converted
by the tool, prompting us to remove them from the test
set. All ﬁles from the resulting evaluation set were con-
verted to a PNG image with a ﬁxed width, assuring the
aspect ratio’s preservation. As batik does not fully sup-
port declarative animations, we create static PNG images
from the SVG ﬁles.
In this manner, if an image was an-
imated beforehand, we will only consider the visual state
it is in before the animation begins. There are ﬁve diﬀer-
ent elements within a SVG ﬁle to accomplish animation:
, , , , and
. A close analysis showed that only two
SVG ﬁles in our test set actually contained one of these ele-
ments, which indicates that this feature is not (yet) widely
used. We therefore consider comparison of static images ex-
clusively to be only a minor limitation of our evaluation.
After converting images to PNGs, we compare the origi-
nal and the puriﬁed image using the ImageMagick toolkit,
which provides methods for a pixel-wise comparison of raster
images, as well as, for gathering statistics on the amount
of aberration. Furthermore, the tool is capable of creating
diﬀerence images that visually indicate what regions of an
image contain an error, which eventually enables us to man-
ually examine cases in which actual changes occur. Other
than determining the absolute number of pixels that diﬀer
between the two images, we calculate the normalized mean
absolute error for each pair of images as metrics. We con-
sider the normalized mean absolute error to be more relevant
in our scenario than the root mean square error, as the for-
mer weights every aberration equally. Moreover, we log both
the size of the original ﬁle, and that of the puriﬁed one, fac-
tually determining the compression ratio resulting from the
puriﬁcation process.
5.2 Evaluation Results
Based on the procedure outlined above, we analyzed all
105,486 ﬁles belonging to the evaluation set. For 98.5% of
the samples, no visual diﬀerence exists in the appearance
of the original versus the puriﬁed image (i.e., absolute error
a is 0 and, therefore, all other error metrics are 0 as well).
The 99th percentile of the normalized mean absolute error
is 0.00000474877, where 0 represents no error at all and 1
indicates completely dissimilar images.
When investigating the error cases and the corresponding
diﬀerent images, we often found that although the image