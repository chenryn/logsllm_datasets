1) and (ğ‘â€²
2) in ğº with ğ‘â€²
1 âˆˆ Antichains[ ğ‘—] and ğ‘â€²
First we iterate through Antichains; At iteration ğ‘–, we look at
Antichains[ ğ‘—] for all ğ‘— < ğ‘– until we find an edge (ğ‘1, ğ‘2) in ğº such
that ğ‘1 âˆˆ Antichains[ ğ‘—] and ğ‘2 âˆˆ Antichains[ğ‘–]. If there is another
edge (ğ‘â€²
2 âˆˆ Antichains[ğ‘–],
then we check if the edges in the antichains ğ‘– and ğ‘— are consistent.
E.g, if the orderings are (ğ‘1, ğ‘â€²
2, ğ‘2) in Antichains[ ğ‘—] and
Antichains[ğ‘–], respectively, then we flip Antichains[ğ‘–].
Once the chains are fixed, we add edges for anti-dominance re-
lationships. We iterate through Antichains[ğ‘–] and Antichains[ ğ‘—]
for ğ‘– < ğ‘— and look at each pair of elements ğ‘ğ‘–, ğ‘ ğ‘— such that ğ‘ğ‘– âˆˆ
Antichains[ğ‘–] and ğ‘ ğ‘— âˆˆ Antichains[ ğ‘—]. For each ğ‘ğ‘– and ğ‘ ğ‘— we com-
pute all their successors and all predecessors in ğº. If there exists
a path from some successor of ğ‘ ğ‘— to some predecessor of ğ‘ğ‘–, then
we add (ğ‘ ğ‘— , ğ‘ğ‘–) to ğºâ€². Similarly, if there exists a path from some
predecessor of ğ‘ ğ‘— to some successor of ğ‘ğ‘–, we add (ğ‘ğ‘–, ğ‘ ğ‘—) to ğºâ€².
The last thing that remains is to identify colinearities. For each
edge (ğ‘, ğ‘) in ğºâ€² find the smallest response ğ‘† containing ğ‘ and ğ‘. If
there exists some ğ‘˜ âˆˆ ğ‘† such that ğ‘˜ and ğ‘ are not connected in ğºâ€²,
then they must be colinear and so we add (ğ‘˜, ğ‘) to ğºâ€². We similarly
check if there exists a colinearity between ğ‘˜ and ğ‘ and add those
edges to ğºâ€². The final step is to remove all transitive edges in ğºâ€² (if
they exist) to keep only minimal anti-dominance relationship and
return the anti-dominance graph ğºâ€².
Lemma 5.4. Let D be a database and RS(D) be its response set.
Given RS(D), the dominance graph ğº of D, and the ordered an-
tichains of D, Algorithm 3 returns the anti-dominance graph of D in
ğ‘‚(ğ‘…3|RS(D)|). [Proof in Appendix C]
5.6 Order Reconstruction
We have already given algorithms for computing the extreme points,
the dominance graph, the antichains, and the anti-dominance graph.
We now put these pieces together to achieve OR of a database D
given its response set RS(D). Algorithm 4 performs OR by taking
the following steps. First it runs Algorithm 9 (FindExtremePairs) to
compute all candidate configurations of the extreme points. There
is a constant number of such configurations and at least one of them
corresponds to a correct arrangement of the extreme points in D
(up to rotation/reflection). For each candidate configuration, it then
computes the dominance graph using Algorithm 1 (DomGraph)
and the anti-dominance graph using Algorithm 3 (AntiDomGraph).
Incorrect configurations result in graphs that are either of an in-
correct form or result in a pair of dominance and anti-dominance
graphs (ğº, ğºâ€²) such that databases with orders described by (ğº, ğºâ€²)
are not compatible with RS(D). Algorithm 4 continues to iterate
through the configurations until a correct pair of graphs (ğº, ğºâ€²) is
found and returned. Given a response set RS(D) of some database
D as input, Algorithm 4 (OrderReconstruction) is guaranteed to
terminate and output a correct graph pair.
Theorem 5.5. Given the response set RS(D) of a 2D database D
with ğ‘… records, Algorithm 4 (OrderReconstruction) returns an ğ‘‚(ğ‘…)-
space representation of the set Eo(D) of all possible orderings of the
points of databases equivalent to D with respect to the response set.
The algorithm runs in time ğ‘‚(ğ‘…3|RS(D)|), which is ğ‘‚(ğ‘…7).
The proof of Theorem 5.5 can be found in the Appendix.
5.7 Experiments
In the previous subsections, we discussed the limitations of OR
and described an algorithm that succeeds at OR when given the
response set of a database. We now support our theoretical results
with experimental results. We have deployed our OR attack on
three real-world databases (Table 2): California, Spitz and HCUP.
The California Road Network dataset [31] comprises 21, 047 road
network intersections indexed by longitude and latitude. Our Cali-
fornia dataset is a random sample of 1000 points with coordinates
truncated to one decimal place and scaled by a factor of 10. The
resulting domain is [102] Ã— [102]. We generated the response set
for this dataset and then ran our OR attack (Algorithm 4) on it.
In Figure 1a, we depict our resulting reconstruction. Although, in
theory, we only recover the relative orders of all the points, the
actual reconstruction leaks additional information about the overall
â€œshapeâ€ of the data. For our reconstruction, after finding the order
of the points, each point is assigned coordinates corresponding
Algorithm 3: AntiDomGraph(RS(D), ğº, Antichains)
1: Initialize empty graph ğºâ€²
2: // Fix chain orientation
3: for ğ‘– âˆˆ [1, |Antichains|] do
4: Add an edge in ğºâ€² between consecutive points in Antichains[ğ‘– âˆ’ 1]
Find (ğ‘1, ğ‘2) âˆˆ ğº, where ğ‘1 is the first point in Antichains[ğ‘˜], ğ‘˜ < ğ‘–
5:
in an edge with a point from Antichains[ğ‘–]. If there are multiple
options for ğ‘2, pick the smallest one in order.
if âˆƒ(ğ‘â€²
1 âˆˆ Antichains[ğ‘˜], ğ‘˜ < ğ‘–, which is
after ğ‘1 in order, and ğ‘â€²
and there is no path from ğ‘â€²
Flip the order of Antichains[ğ‘–]
2 âˆˆ Antichains[ğ‘–], which is before ğ‘2 in order,
7:
8: Add an edge in ğºâ€² between consecutive points in the last antichain
9: // All chains are fixed; Now add edges between them.
10: for ğ´ğ‘– = Antichains[ğ‘–] and ğ´ğ‘— = Antichains[ ğ‘—], such that
2) âˆˆ ğº, for a point ğ‘â€²
1 to ğ‘2 in ğº then
1, ğ‘â€²
6:
11:
12:
13:
14:
ğ‘–, ğ‘— âˆˆ [|Antichains|] and ğ‘– < ğ‘— do
for ğ‘ğ‘– âˆˆ ğ´ğ‘– and ğ‘ ğ‘— âˆˆ ğ´ğ‘— do
if ğ‘ğ‘– and ğ‘ ğ‘— not connected in ğº then
Find successors of ğ‘ ğ‘— , ğ‘† ğ‘— âŠ† ğ´ğ‘— , and all predecessors of ğ‘ ğ‘— ,
ğ‘ƒ ğ‘— âŠ† ğ´ğ‘— . Add ğ‘ ğ‘— to ğ‘† ğ‘— , ğ‘ƒ ğ‘— .
Find successors of ğ‘ğ‘–, ğ‘†ğ‘– âŠ† ğ´ğ‘–, and all predecessors of ğ‘ğ‘–,
ğ‘ƒğ‘– âŠ† ğ´ğ‘–. Add ğ‘ğ‘– to ğ‘†ğ‘–, ğ‘ƒğ‘–.
if âˆƒ path from ğ‘ to ğ‘ in ğº, s.t. ğ‘ âˆˆ ğ‘† ğ‘— , ğ‘ âˆˆ ğ‘ƒğ‘– then
Add edge (ğ‘ ğ‘— , ğ‘ğ‘–) to ğºâ€²
else if âˆƒ path from ğ‘ to ğ‘ ğ‘— in ğº, s.t. ğ‘ âˆˆ ğ‘ƒğ‘– then
Add edge (ğ‘ ğ‘— , ğ‘ğ‘–) to ğºâ€²
else if âˆƒ path from ğ‘ to ğ‘ in ğº, s.t. ğ‘ âˆˆ ğ‘ƒ ğ‘— , ğ‘ âˆˆ ğ‘†ğ‘– then
Add edge (ğ‘ğ‘–, ğ‘ ğ‘—) to ğºâ€²
15:
16:
17:
18:
19:
20:
21: // Find any collinearities.
22: // The pseudocode for Boxes can be found in the Appendix.
23: Let ğ¸ be an empty list.
24: for (ğ‘, ğ‘) âˆˆ ğºâ€² do
25:
26:
27:
28:
29:
30:
31: Add all edges in ğ¸ to ğºâ€²
32: Remove transitive edges from ğºâ€²
33: Return ğºâ€²
ğ‘ƒğ‘,ğ‘, ğ‘†ğ‘,ğ‘, ğ‘ƒğ‘,ğ‘ = Boxes(ğ‘, ğ‘)
Let ğ‘† = ğ‘ƒğ‘,ğ‘ âˆª ğ‘†ğ‘,ğ‘ âˆª ğ‘ƒğ‘,ğ‘
if âˆƒğ‘˜ âˆˆ ğ‘†, where there is no path from ğ‘˜ to ğ‘ in ğºâ€² then
Add an appropriate edge between ğ‘˜ and ğ‘ in ğºâ€²
if âˆƒğ‘˜ âˆˆ ğ‘†, where there is no path from ğ‘˜ to ğ‘ in ğ¸ then
Add an appropriate edge between ğ‘˜ and ğ‘ in ğ¸
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2251Algorithm 4: OrderReconstruction(RS(D))
1: PossibleConfigs = FindExtremePairs(RS(D))
2: for config âˆˆ PossibleConfigs do
3: ğº, ğ´0 = DomGraph(RS(D), config)
4: ğºâ€² = AntiDomGraph(RS(D), ğº, Antichains(RS(D), ğº, ğ´0))
Let closePairs and antipodalPairs be empty lists.
5:
Find the smallest response that contains top and bottom. If it
6:
contains no other points, then add (top, bottom) to antipodalPairs.
Find the smallest response that contains left and right. If it contains
no other points, then add (left, right) to antipodalPairs.
for each edge (ğ‘, ğ‘) âˆˆ ğº do
if (ğ‘, ğ‘) satisfy Definition 3.3 then
Add (ğ‘, ğ‘) to closePairs
if response set of points with orders (ğº, ğºâ€²) is RS(D) then
Return (ğº, ğºâ€², antipodalPairs, closePairs)
7:
8:
9:
10:
11:
12:
Figure 6: Dominance (right) and anti-dominance (left)
graphs of the (top) California and (bottom) Spitz datasets.
to its index in each dimensionâ€™s ordering. The figure shows each
antichain in a different color, illustrating the height increase, as well
as an ğ›¼-shape [11] of the point-set, illustrating the overall shape.
Malte Spitz is a German politician who published his phone
location between 8/31/2009 and 2/21/2010 [43]. Our Spitz dataset
comprises longitude and latitude information from the first day,
truncating it to one decimal place, and scaling it by a factor of 10.
We also ran our order reconstruction attack on the Healthcare
Cost and Utilization Project (HCUP) Nationwide Inpatient Sam-
ple (NIS) 2008 and 2009 medical datasets [1], but we are unable
to share images of the reconstructions, per the HCUP data usage
agreement. The HCUP dataset has been previously used in other
reconstruction attacks [13, 28, 29]. The reconstructed dominance
graph and anti-dominance graph of the California and Spitz datasets
are shown in Figure 6.
Order reconstruction in two-dimensions is significantly more
enlightening than in one-dimension. We conjectured that the geom-
etry of the data is more observable when data is more dense in one
or both of the domains. Our results from the California dataset sup-
port this: we can clearly see that this location data comes from the
state of California. In the Spitz case, we can still recover the shape
of the dataset and see that it is a deeply diagonal database with a
number of collinearities and reflectable components (Figure 6).
We further note that to compute the correct order from the set of
possible equivalent orders, one can extend the symmetry breaking
method from [13] by using auxiliary information about the database,
such as known values of some records or statistical information.
6 Estimating the Query Density Functions
Recall that the query density, ğœŒğ‘†, of a set of records ğ‘† corresponds
to the number of unique range queries that contain all records in ğ‘†.
One of the challenges of reconstructing a database D with partial
knowledge of the search pattern, is that the adversary can no longer
compute the exact ğœŒ values by constructing RM(D). Thus, the two-
dimensional FDR attack [13] no longer applies. To reconstruct with
missing queries, we draw inspiration from [27] and use statistical
estimators to estimate the ğœŒ values.
In Section 7 we show how these ğœŒ estimates can be used to con-
struct a system of non-linear equations whose solution corresponds
to an approximate reconstruction of the target database.
Formally, let D be a database of ğ‘… records and let ğ‘€ = {{(ğ‘¡1, ğ´1),
. . . , (ğ‘¡ğ‘š, ğ´ğ‘š) : ğ´ğ‘– âˆˆ RS(D)}} be a sample (i.e. multiset) of ğ‘š token-
response pairs that are leaked when queries are issued according
to an arbitrary distribution. Let ğ¿ âŠ† ğ‘€ be a subsample of ğ‘€ of size
ğ‘›. Given a sample (multiset) ğ‘€ of ğ‘š token-response pairs, we show
how one may compute the appropriate submultisets ğ¿ âŠ† ğ‘€ that
correspond to the ğœŒ functions of interest. Each of these submultisets
is used to approximate the value of its respective ğœŒ value.
6.1 Non-parametric Estimators
Sampling-based estimators have been used in various domains
ranging from databases [21] to ecology (e.g. [2, 3]). Non-parametric
estimators do not require prior knowledge of the query distribution,
yet their success hinges upon the underlying distribution from
which queries are drawn. Indeed, for skewed distributions, it may be
information theoretically impossible to obtain a reasonable estimate.
Recently, non-parametric estimators have been used for database
reconstruction to estimate the support size of the given conditional
probability distribution of a particular record identifier [27].
For our reconstruction attack, we have considered the estima-
tors by Chao and Lee [8] and by Shlosser [42], and the jackknife
estimators described in [2, 3].
For more details about the above estimators, see Appendix D.
We initially considered also the Valiant-Valiant estimator [45] as it
was used in [27]. However, it did not perform as well in our case.
6.2 Experiments
We ran our estimators against two datasets with domain sizes 25Ã—25
and 18 Ã— 33. The first dataset is the first day of the Spitz dataset (de-