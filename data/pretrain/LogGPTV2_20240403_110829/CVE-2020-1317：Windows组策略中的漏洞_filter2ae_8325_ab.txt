      14    B 0002DA90 GenerateGroupPolicyFolders
      15    C 0002DF70 GenerateGroupPolicyIniFile
      21   12 0002E6C0 GenerateGroupPolicyPrinters
      22   13 0002FCB0 GenerateGroupPolicyRegionOptions
      29   1A 0002EED0 ProcessGroupPolicyDataSources
      30   1B 0002F140 ProcessGroupPolicyDevices
      31   1C 0002D8E0 ProcessGroupPolicyDrives
      32   1D 0002D670 ProcessGroupPolicyEnviron
      33   1E 0002E5E0 ProcessGroupPolicyExApplications
      34   1F 0002EFA0 ProcessGroupPolicyExDataSources
      35   20 0002F210 ProcessGroupPolicyExDevices
      36   21 0002D9B0 ProcessGroupPolicyExDrives
      38   23 0002DE90 ProcessGroupPolicyExFiles
      39   24 0002F480 ProcessGroupPolicyExFolderOptions
      40   25 0002DC20 ProcessGroupPolicyExFolders
      41   26 0002E100 ProcessGroupPolicyExIniFile
      42   27 0002EAC0 ProcessGroupPolicyExInternet
      43   28 0002F6F0 ProcessGroupPolicyExLocUsAndGroups
      54   33 0002DDC0 ProcessGroupPolicyFiles
      55   34 0002F3B0 ProcessGroupPolicyFolderOptions
      56   35 0002DB50 ProcessGroupPolicyFolders
      59   38 0002F620 ProcessGroupPolicyLocUsAndGroups
      1    39 000407E0 ProcessGroupPolicyMitigationOptions
      60   3A 00030730 ProcessGroupPolicyNetShares
      61   3B 0002F890 ProcessGroupPolicyNetworkOptions
      62   3C 0002FB00 ProcessGroupPolicyPowerOptions
      63   3D 0002E780 ProcessGroupPolicyPrinters
      2    3E 00040AC0 ProcessGroupPolicyProcessMitigationOptions
      67   42 00030250 ProcessGroupPolicyServices
      68   43 0002EC60 ProcessGroupPolicyShortcuts
      69   44 000304C0 ProcessGroupPolicyStartMenu
所有导出函数都会返回一个apmCse::PolicyMain类型的新对象。
    return apmCse::PolicyMain(
    a1,
            (__int64)&`GetCseVersionPrinters'::`2'::s_wVersion,
            (__int64)L"GenerateGroupPolicyPrinters",
            (__int64)L"Group Policy Printers");
PolicyMain()函数的职责是应用GPO。对每个不同的Applied-Object，随方法的第三个参数不同，其行为会有些不同。内部随后的一个动态调用会使用之。gpprefcl.dll中有66个导出方法，几乎所有方法都是这样实现的，唯一的不同就是第三和第四个参数不同。
除此之外，PolicyMain()中还有几个函数调用，其中有一个调用用于初始化主对象apmCSE，有25个初始化参数。
这之后，又有个apmCse::StartClient()的调用，漏洞函数就在这里。我无意逆向apmCse类以及和它关联的方法。我们可以列出带有感兴趣的关键字的所有方法，比如Read、Write、Delete这些关键字。如果某个函数签名中有这些关键字，它就很可能会进行文件操作。可以用windbg的有用的[grep](https://github.com/long123king/grep)扩展来列出列表。
    !silent; x gpprefcl!apm*; !igrep "DeleteFile|WriteFile|textfile"
结果如下：
    00007ffd`ba4355f8 gpprefcl!apmDeleteFile(long __cdeclapmDeleteFile(unsigned short const *))
    00007ffd`ba4333cc gpprefcl!apmWriteTextFile (long __cdecl apmWriteTextFile(class apmString const &,unsigned short const *,bool))
    00007ffd`ba4332b8 gpprefcl!apmWriteFile (long __cdecl apmWriteFile(unsigned char *,unsigned long,unsigned short const *,bool))
    00007ffd`ba407d74 gpprefcl!apmConfigFile::deleteFiles (private: long __cdecl apmConfigFile::deleteFiles(unsigned short const *,bool))
    00007ffd`ba434008 gpprefcl!apmDeleteFileSystemItem (long __cdecl apmDeleteFileSystemItem(unsigned short const *,unsigned short const *,struct _WIN32_FIND_DATAW *,bool,bool,bool,bool))
得出列表后就可以在这些方法下断点了，因为很可能这些方法中进行了文件操作，这就给我们提供了文件系统攻击的好机会。
结果看来十分喜人，似乎每个方法里都有一个文件操作。除了下断点之外，还可以检查下有没有调用线程模拟API，如果没有，那就完美。
apmClientContext类中有一个对impersonateLoggedOnUser()的wrapper（包装）函数，叫做apmClientContext::impersonate()。因此，要检查上面提到的文件系统方法中有没有调用apmClientContext::impersonate()。
这个模拟函数在gpprefcl.dll中被多次调用，这也是应该的。但是，如果查看对这个函数的交叉引用，就发现没有来自上述方法的引用。还要再进一步继续检查方法的调用者，比如gpprefcl!apmWriteFile()和gpprefcl!apmDeleteFile()的调用者：
  * apmClient::cseApplyGpoPolicies() → apmClient::UpdateGph() → gpprefcl!apmWriteFile()
  * apmClient::cseRemoveLastGpoPolicies()→ apmClient::PurgeGph() → gpprefcl!apmDeleteFile()
这些方法里没有一个调用了apmClientContext::impersonate()。负责应用GPO的方法是apmClient::cseApplyGpoPolicies()和apmClient::cseRemoveLastGpoPolicies()。我是在Windbg于gpprefcl!apmWriteFile()断下时，查看调用栈意识到的：
    00 000000dd`d27fc3a8 00007ffd`ba3f413f gpprefcl!apmWriteFile01
     000000dd`d27fc3b0 00007ffd`ba3f2867 gpprefcl!apmClient::UpdateGph+0x13702
     000000dd`d27fc490 00007ffd`ba3f54ee
     gpprefcl!apmClient::cseApplyGpoPolicies+0x2a703 000000dd`d27fc5a0
     00007ffd`ba3f3e3a gpprefcl!apmClient::processGpoLists+0x4ca04
     000000dd`d27fc710 00007ffd`ba41d49a gpprefcl!apmClient::Main+0x1a05
     000000dd`d27fc740 00007ffd`ba41d310
     gpprefcl!apmCse::StartClient+0xee06 000000dd`d27fdc00
     00007ffd`ba41e911 gpprefcl!apmCse::PolicyMain+0x25007
     000000dd`d27fdf40 00007ffd`c9c89ce2
     gpprefcl!ProcessGroupPolicyExPrinters+0xc108 000000dd`d27fe010
     00007ffd`c9c50b25 gpsvc!ProcessGPOList+0x88209 000000dd`d27fe3d0
     00007ffd`c9c5caf5 gpsvc!ProcessGPOs+0x227c5
那么剩下的唯一的事就是利用漏洞了。
## 0x02 利用
利用过程如下：
  * 列出C:UsersuserAppDataLocalMicrosoftGroup PolicyHistory中的所有组策略GUID。
  * 如果有多个GUID，看看哪个目录最近更新了。
  * 进入该目录，再进入名为用户SID的子目录。
  * 找到最后修改的目录，每个人机器上不同，我这里是Printers。
  * 删除Printers目录里的xml文件。
  * 创建NTFS解析点，指向RPC Control，再创建由xml指向C:WindowsSystem32任意文件.dll的符号链接。
  * 打开命令行，运行gpupdate。
成功了，在任意位置创建任意文件。通过这个漏洞还可以删除修改系统保护的文件。根据GPO对象的不同，步骤有些许不同，但是都可以导致提权漏洞。
## 0x03 总结
组策略的结构很复杂。Windows支持许多老式代码和自定义选项，其中包括不同的GPOLink类型。尽管在几乎所有代码路径上都调用了线程模拟API，但还是有路径没调用的。当组策略应用于组织单位，而服务又将GPO写入磁盘时就发生漏洞。
数以百万计的Windows机器在未更新补丁的情况下都会受此漏洞影响，但是将来微软应该会提供缓解措施，在创建挂载点/目录链接时要求管理员权限。这将阻止整类文件系统攻击。
更多细节可以看这个演示：  
感谢队员Elyda Barak，他对组策略有广泛的认识，给我解释了组策略的许多细节，省了我很多时间。
## 0x04 漏洞披露时间线
2019年6月17日 – 漏洞报告给微软。
2019年6月17日 – 官方接收。
2019年9月18日 – 微软确认漏洞，说明了补丁的复杂度。
2020年1月9日 – 微软承诺2020年第二季度下发补丁。
2020年6月9日 – 补丁发布：CVE-2020-1317。