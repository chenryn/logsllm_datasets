## 0x01 漏洞分析

### 导出函数
以下是 `gpprefcl.dll` 中的导出函数列表，这些函数主要用于生成和处理组策略对象 (GPO)：

- `GenerateGroupPolicyFolders` (0002DA90)
- `GenerateGroupPolicyIniFile` (0002DF70)
- `GenerateGroupPolicyPrinters` (0002E6C0)
- `GenerateGroupPolicyRegionOptions` (0002FCB0)
- `ProcessGroupPolicyDataSources` (0002EED0)
- `ProcessGroupPolicyDevices` (0002F140)
- `ProcessGroupPolicyDrives` (0002D8E0)
- `ProcessGroupPolicyEnviron` (0002D670)
- `ProcessGroupPolicyExApplications` (0002E5E0)
- `ProcessGroupPolicyExDataSources` (0002EFA0)
- `ProcessGroupPolicyExDevices` (0002F210)
- `ProcessGroupPolicyExDrives` (0002D9B0)
- `ProcessGroupPolicyExFiles` (0002DE90)
- `ProcessGroupPolicyExFolderOptions` (0002F480)
- `ProcessGroupPolicyExFolders` (0002DC20)
- `ProcessGroupPolicyExIniFile` (0002E100)
- `ProcessGroupPolicyExInternet` (0002EAC0)
- `ProcessGroupPolicyExLocUsAndGroups` (0002F6F0)
- `ProcessGroupPolicyFiles` (0002DDC0)
- `ProcessGroupPolicyFolderOptions` (0002F3B0)
- `ProcessGroupPolicyFolders` (0002DB50)
- `ProcessGroupPolicyLocUsAndGroups` (0002F620)
- `ProcessGroupPolicyMitigationOptions` (000407E0)
- `ProcessGroupPolicyNetShares` (00030730)
- `ProcessGroupPolicyNetworkOptions` (0002F890)
- `ProcessGroupPolicyPowerOptions` (0002FB00)
- `ProcessGroupPolicyPrinters` (0002E780)
- `ProcessGroupPolicyProcessMitigationOptions` (00040AC0)
- `ProcessGroupPolicyServices` (00030250)
- `ProcessGroupPolicyShortcuts` (0002EC60)
- `ProcessGroupPolicyStartMenu` (000304C0)

所有导出函数都会返回一个 `apmCse::PolicyMain` 类型的新对象。例如：

```cpp
return apmCse::PolicyMain(
    a1,
    (__int64)&`GetCseVersionPrinters'::`2'::s_wVersion,
    (__int64)L"GenerateGroupPolicyPrinters",
    (__int64)L"Group Policy Printers");
```

### `PolicyMain()` 函数
`PolicyMain()` 函数的职责是应用 GPO。对于每个不同的 Applied-Object，方法的第三个参数会有所不同，从而导致行为的不同。内部会进行动态调用。`gpprefcl.dll` 中有 66 个导出方法，几乎所有方法都是这样实现的，唯一的不同在于第三和第四个参数。

此外，`PolicyMain()` 中还有几个函数调用，其中一个用于初始化主对象 `apmCSE`，该初始化过程涉及 25 个参数。随后，会调用 `apmCse::StartClient()`，这就是漏洞所在的地方。

### 文件操作相关的方法
为了找到可能进行文件操作的方法，可以列出包含关键字（如 `Read`、`Write`、`Delete`）的所有方法。使用 Windbg 的 `grep` 扩展可以列出这些方法：

```plaintext
!silent; x gpprefcl!apm*; !igrep "DeleteFile|WriteFile|textfile"
```

结果如下：

```plaintext
00007ffd`ba4355f8 gpprefcl!apmDeleteFile(long __cdecl apmDeleteFile(unsigned short const *))
00007ffd`ba4333cc gpprefcl!apmWriteTextFile (long __cdecl apmWriteTextFile(class apmString const &,unsigned short const *,bool))
00007ffd`ba4332b8 gpprefcl!apmWriteFile (long __cdecl apmWriteFile(unsigned char *,unsigned long,unsigned short const *,bool))
00007ffd`ba407d74 gpprefcl!apmConfigFile::deleteFiles (private: long __cdecl apmConfigFile::deleteFiles(unsigned short const *,bool))
00007ffd`ba434008 gpprefcl!apmDeleteFileSystemItem (long __cdecl apmDeleteFileSystemItem(unsigned short const *,unsigned short const *,struct _WIN32_FIND_DATAW *,bool,bool,bool,bool))
```

在这些方法下设置断点，因为它们很可能进行了文件操作，这为我们提供了文件系统攻击的机会。

### 线程模拟检查
`apmClientContext` 类中有一个对 `impersonateLoggedOnUser()` 的包装函数 `apmClientContext::impersonate()`。需要检查上述文件系统方法是否调用了 `apmClientContext::impersonate()`。

通过交叉引用发现，`apmClientContext::impersonate()` 在 `gpprefcl.dll` 中被多次调用，但没有来自上述方法的引用。进一步检查这些方法的调用者，例如 `gpprefcl!apmWriteFile()` 和 `gpprefcl!apmDeleteFile()` 的调用者：

- `apmClient::cseApplyGpoPolicies() → apmClient::UpdateGph() → gpprefcl!apmWriteFile()`
- `apmClient::cseRemoveLastGpoPolicies() → apmClient::PurgeGph() → gpprefcl!apmDeleteFile()`

这些方法都没有调用 `apmClientContext::impersonate()`。负责应用 GPO 的方法是 `apmClient::cseApplyGpoPolicies()` 和 `apmClient::cseRemoveLastGpoPolicies()`。

## 0x02 利用

利用过程如下：
1. 列出 `C:\Users\user\AppData\Local\Microsoft\Group Policy\History` 中的所有组策略 GUID。
2. 如果有多个 GUID，查看哪个目录最近更新了。
3. 进入该目录，再进入名为用户 SID 的子目录。
4. 找到最后修改的目录（例如 `Printers`）。
5. 删除 `Printers` 目录中的 XML 文件。
6. 创建 NTFS 解析点，指向 RPC Control，并创建由 XML 指向 `C:\Windows\System32\任意文件.dll` 的符号链接。
7. 打开命令行，运行 `gpupdate`。

成功后，可以在任意位置创建任意文件。通过这个漏洞还可以删除或修改受系统保护的文件。根据 GPO 对象的不同，步骤可能会有所变化，但都可能导致提权漏洞。

## 0x03 总结

组策略的结构非常复杂。Windows 支持许多老式代码和自定义选项，包括不同的 GPOLink 类型。尽管在几乎所有代码路径上都调用了线程模拟 API，但仍有一些路径未调用。当组策略应用于组织单位且服务将 GPO 写入磁盘时，就会发生漏洞。

数以百万计的 Windows 机器在未更新补丁的情况下都会受到此漏洞的影响。未来，微软可能会提供缓解措施，在创建挂载点/目录链接时要求管理员权限，以阻止整类文件系统攻击。

更多细节可以参考以下演示：
感谢队友 Elyda Barak，他对组策略有广泛的认识，为我解释了许多细节，节省了很多时间。

## 0x04 漏洞披露时间线
- 2019年6月17日 – 漏洞报告给微软。
- 2019年6月17日 – 官方接收。
- 2019年9月18日 – 微软确认漏洞，说明了补丁的复杂度。
- 2020年1月9日 – 微软承诺2020年第二季度下发补丁。
- 2020年6月9日 – 补丁发布：CVE-2020-1317。