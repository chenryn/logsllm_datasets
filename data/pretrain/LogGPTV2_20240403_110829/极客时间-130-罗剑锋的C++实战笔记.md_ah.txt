# 04 \| 编译阶段能做什么：属性和静态断言你好，我是 Chrono。前面我讲了 C++程序生命周期里的"编码阶段"和"预处理阶段"，它们的工作主要还是"文本编辑"，生成的是**人类可识别的源码**（sourcecode）。而"编译阶段"就不一样了，它的目标是**生成计算机可识别的机器码**（machine instructioncode）。 今天，我就带你来看看在这个阶段能做些什么事情。编译阶段编程编译是预处理之后的阶段，它的输入是（经过预处理的）C++源码，输出是**二进制可执行文件**（也可能是汇编文件、动态库或者静态库）。这个处理动作就是由编译器来执行的。和预处理阶段一样，在这里你也可以"面向编译器编程"，用一些指令或者关键字让编译器按照你的想法去做一些事情。只不过，这时你要面对的是庞大的C++语法，而不是简单的文本替换，难度可以说是高了好几个数量级。编译阶段的特殊性在于，它看到的都是 C++ 语法实体，比如typedef、using、template、struct/class这些关键字定义的类型，而不是运行阶段的变量。所以，这时的编程思维方式与平常大不相同。我们熟悉的是CPU、内存、Socket，但要去理解编译器的运行机制、知道怎么把源码翻译成机器码，这可能就有点"强人所难"了。比如说，让编译器递归计算斐波那契数列，这已经算是一个比较容易理解的编译阶段数值计算用法了：    template    struct fib                   // 递归计算斐波那契数列    {        static const int value =            fib::value + fib::value;    };    template<>    struct fib                // 模板特化计算fib    {        static const int value = 1;    };    template<>    struct fib               // 模板特化计算fib    {        static const int value = 1;    };    // 调用后输出2，3，5，8    cout ::value ::value ::value ::value  0 && "i must be greater than zero");    assert(p != nullptr);    assert(!str.empty());当程序（也就是 CPU）运行到 assert 语句时，就会计算表达式的值，如果是false，就会输出错误消息，然后调用 abort()终止程序的执行。注意，assert虽然是一个宏，但在预处理阶段不生效，而是在运行阶段才起作用，所以又叫"**动态断言**"。有了"动态断言"，那么相应的也就有"静态断言"，名字也很像，叫"**static_assert**"，不过它是一个专门的关键字，而不是宏。因为它只在编译时生效，运行阶段看不见，所以是"静态"的。"静态断言"有什么用呢？类比一下assert，你就可以理解了。它是编译阶段里检测各种条件的"断言"，编译器看到static_assert 也会计算表达式的值，如果值是false，就会报错，导致编译失败。比如说，这节课刚开始时的斐波拉契数列计算函数，可以用静态断言来保证模板参数必须大于等于零：    template    struct fib    {        static_assert(N >= 0, "N >= 0");        static const int value =            fib::value + fib::value;    };再比如说，要想保证我们的程序只在 64位系统上运行，可以用静态断言在编译阶段检查 long 的大小，必须是 8个字节（当然，你也可以换个思路用预处理编程来实现）。    static_assert(      sizeof(long) >= 8, "must run on x64");          static_assert(      sizeof(int)  == 4, "int must be 32bit");这里你一定要注意，static_assert运行在编译阶段，只能看到编译时的常数和类型，看不到运行时的变量、指针、内存数据等，是"静态"的，所以不要简单地把assert 的习惯搬过来用。比如，下面的代码想检查空指针，由于变量只能在运行阶段出现，而在编译阶段不存在，所以静态断言无法处理。    char* p = nullptr;    static_assert(p == nullptr, "some error.");  // 错误用法说到这儿，你大概对 static_assert的"编译计算"有点感性认识了吧。在用"静态断言"的时候，你就要在脑子里时刻"绷紧一根弦"，把自己代入编译器的角色，**像编译器那样去思考**，看看断言的表达式是不是能够在编译阶段算出结果。不过这句话说起来容易做起来难，计算数字还好说，在泛型编程的时候，怎么检查模板类型呢？比如说，断言是整数而不是浮点数、断言是指针而不是引用、断言类型可拷贝可移动......这些检查条件表面上看好像是"不言自明"的，但要把它们用 C++语言给精确地表述出来，可就没那么简单了。所以，想要更好地发挥静态断言的威力，还要配合标准库里的"type_traits"，它提供了对应这些概念的各种编译期"函数"。    // 假设T是一个模板参数，即template    static_assert(      is_integral::value, "int");    static_assert(      is_pointer::value, "ptr");    static_assert(      is_default_constructible::value, "constructible");你可能看到了，"static_assert"里的表达式样子很奇怪，既有模板符号"\"，又有作用域符号"::"，与运行阶段的普通表达式大相径庭，初次见到这样的代码一定会吓一跳。这也是没有办法的事情。因为 C++本来不是为编译阶段编程所设计的。受语言的限制，编译阶段编程就只能"魔改"那些传统的语法要素了：把类当成函数，把模板参数当成函数参数，把"::"当成return返回值。说起来，倒是和"函数式编程"很神似，只是它运行在编译阶段。由于"type_traits"已经初步涉及模板元编程的领域，不太好一下子解释清楚，所以，在这里我就不再深入介绍了，你可以课后再看看这方面的其他资料，或者是留言提问。小结好了，今天我和你聊了 C++程序在编译阶段能够做哪些事情。编译阶段的"主角"是编译器，它依据 C++语法规则处理源码。在这个过程中，我们可以用一些手段来帮助编译器，让它听从我们的指挥，优化代码或者做静态检查，更好地为运行阶段服务。但要当心，毕竟只有编译器才能真正了解 C++程序，所以我们还是要充分信任它，不要过分干预它的工作，更不要有意与它作对。我们来小结一下今天的要点。1.       "属性"相当于编译阶段的"标签"，用来标记变量、函数或者类，让编译器发出或者不发出警告，还能够手工指定代码的优化方式。        2.       官方属性很少，常用的只有"deprecated"。我们也可以使用非官方的属性，需要加上名字空间限定。        3.       static_assert    是"静态断言"，在编译阶段计算常数和类型，如果断言失败就会导致编译错误。它也是迈向模板元编程的第一步。        4.       和运行阶段的"动态断言"一样，static_assert    可以在编译阶段定义各种前置条件，充分利用 C++    静态类型语言的优势，让编译器执行各种检查，避免把隐患带到运行阶段。        课下作业最后是课下作业时间，给你留两个思考题：1.       预处理阶段可以自定义宏，但编译阶段不能自定义属性标签，这是为什么呢？        2.       你觉得，怎么用"静态断言"，才能更好地改善代码质量？        欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎把它分享给你的朋友。我们下节课见。![](Images/50d220cdecbdcb9c7c0f28caf17d255c.png)savepage-src="https://static001.geekbang.org/resource/image/25/39/25232468a72b55a41bf7af90583ae239.jpg"}