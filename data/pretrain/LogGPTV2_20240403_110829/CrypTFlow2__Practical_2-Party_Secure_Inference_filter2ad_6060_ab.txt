GC [62, 63]
This work
GC [62, 63]
This work
GC [62, 63]
This work
Comm. (bits)
8ğœ†â„“ âˆ’ 4ğœ†
< ğœ†â„“ + 18â„“
18ğœ†ğœ‚ âˆ’ 6ğœ†
2 ğœ†(ğœ‚ + 1) + 31ğœ‚
< 3
2
Rounds
log â„“ + 2
log ğœ‚ + 4
2
32256
3298
72960
5288
2
7
2
9
Table 2: Comparison of communication with garbled cir-
cuits for ReLU. We define ğœ‚ = âŒˆlog ğ‘›âŒ‰. For concrete bits of
communication we use ğœ† = 128.
Layer
Avgpoolğ‘‘
Avgpoolğ‘‘
Z2â„“
Zğ‘›
Protocol
GC [62, 63]
This work
GC [62, 63]
This work
GC [62, 63]
This work
GC [62, 63]
This work
Comm. (bits)
2ğœ†(â„“2 + 5â„“ âˆ’ 3)
< (ğœ† + 21) Â· (â„“ + 3ğ›¿)
2ğœ†(ğœ‚2 + 9ğœ‚ âˆ’ 3)
2 ğœ† + 34) Â· (ğœ‚ + 2ğ›¿)
< ( 3
2
Rounds
log(â„“ğ›¿) + 4
log(ğœ‚ğ›¿) + 6
2
302336
5570
335104
7796
Avgpool49
Z2â„“ , â„“ = 32
Avgpool49
Zğ‘›, ğœ‚ = 32
Table 3: Comparison of communication with garbled cir-
cuits for Avgpoolğ‘‘. We define ğœ‚ = âŒˆlog ğ‘›âŒ‰ and ğ›¿ = âŒˆlog(6 Â· ğ‘‘)âŒ‰.
For concrete bits of communication we use ğœ† = 128. Choice
of ğ‘‘ = 49 corresponds to average pool filter of size 7 Ã— 7.
2
10
2
14
ğ‘¥ < ğ‘¦ is the same as checking if either ğ‘¥1 < ğ‘¦1 or ğ‘¥1 = ğ‘¦1 and
ğ‘¥0 < ğ‘¦0. Now, the original problem is reduced to computing two
millionairesâ€™ instances over smaller length strings (ğ‘¥1 < ğ‘¦1 and
ğ‘¥0 < ğ‘¦0) and one equality test (ğ‘¥1 = ğ‘¦1). By continuing recursively,
one could build a tree all the way where the leaves are individual
bits, at which point one could use 1-out-of-2 OT-based protocols
to perform the comparison/equality. However, the communication
complexity of this protocol is still quite large. We make several
important modifications to this approach. First, we modify the tree
so that the recursion is done log(â„“/ğ‘š) times to obtain leaves with
strings of size ğ‘š, for a parameter ğ‘š. We then use 1-out-of-2ğ‘š OT
to compute the comparison/equality at the leaves, employing the
lookup-table based approach of [25]. Second, we observe that by
carefully setting up the receiverâ€™s and senderâ€™s messages in the
OT protocols for leaf comparisons and equality, multiple 1-out-
of-2ğ‘š OT instances can be combined to reduce communication.
Next, recursing up from the leaves to the root, requires securely
computing the AND functionality6 that uses Beaver bit triples [8].
We observe that the same secret value is used in 2 AND instances.
Hence, we construct correlated pairs of bit triples using 1-out-of-8
OT protocols [44] to reduce this cost to ğœ† + 8 bits (amortized) per
triple, where ğœ† is the security parameter and typically 128. Some
more work is needed for the above technique to work efficiently for
the general case when ğ‘š does not divide â„“ or â„“/ğ‘š is not a power
of 2. Finally, by picking ğ‘š appropriately, we obtain a protocol for
millionairesâ€™ whose concrete communication (in bits) is nearly 5
times better than prior work.
0, ğ‘â€²
0 + ğ‘â€²
1 â‰¥ 2â„“âˆ’1, where ğ‘â€²
DReLU. Let ğ‘ be additively secret shared as ğ‘0, ğ‘1 over the ap-
propriate ring. DReLU(ğ‘) is 1 if ğ‘ â‰¥ 0 and 0 otherwise; note that
ğ‘ â‰¥ 0 is defined differently for â„“âˆ’bit integers and general rings.
Over Zğ¿, where values are encoded using 2â€™s complement notation,
DReLU(ğ‘) = 1 âŠ• MSB(ğ‘), where MSB(ğ‘) is the most significant
bit of ğ‘. Moreover, MSB(ğ‘) = MSB(ğ‘0) âŠ• MSB(ğ‘1) âŠ• carry. Here,
carry = 1 if ğ‘â€²
1 denotes the integer repre-
sented by the lower â„“ âˆ’ 1 bits of ğ‘0, ğ‘1. We compute this carry bit
using a call to our millionairesâ€™ protocol. Over Zğ‘›, DReLU(ğ‘) = 1
if ğ‘ âˆˆ [0, âŒˆğ‘›/2âŒ‰). Given the secret shares ğ‘0, ğ‘1, this is equivalent to
(ğ‘0 + ğ‘1) âˆˆ [0, âŒˆğ‘›/2âŒ‰) âˆª [ğ‘›, âŒˆ3ğ‘›/2âŒ‰) over integers. While this can be
naÃ¯vely computed by making 3 calls to the millionairesâ€™ protocol,
we show that by carefully selecting the inputs to the millionairesâ€™
protocol, one can do this with only 2 calls. Finally, we set things
up so that the two calls to millionairesâ€™ have correlated inputs that
reduces the overall cost to â‰ˆ 1.5 instances of millionairesâ€™ over Zğ‘›.
Division and Truncation. As a technical result, we provide a cor-
rect decomposition of division of a secret ring element in Zğ¿ or Zğ‘›
by a public integer into division of secret shares by the same public
integer and correction terms (Theorem 4.1). These correction terms
consist of multiple inequalities on secret values. As a corollary, we
also get a much simpler expression for the special case of trunca-
tion, i.e., dividing â„“-bit integers by a power-of-2 (Corollary 4.2). We
believe that the general theorem as well as the corollary can be
of independent interest. Next, we give efficient protocols for both
general division (used for Avgpool, Table 3) as well as division by a
power-of-2 (used for multiplication in fixed-point arithmetic). The
inequalities in the correction term are computed using our new
protocol for millionairesâ€™ and the division of shares can be done
locally by the respective parties. Our technical theorem is the key
to obtaining secure implementation of DNN inference tasks that
are bitwise equivalent to cleartext fixed-point execution.
1.3 Other Related Work
Perhaps the first work to consider the secure computation of ma-
chine learning inference algorithms was that of [14]. SecureML [51]
was the first to consider secure neural network inference and train-
ing. Apart from the works mentioned earlier, other works include
6This functionality takes as input shares of bits ğ‘¥, ğ‘¦ from the two parties and outputs
shares of ğ‘¥ AND ğ‘¦ to both parties.
3
those that considered malicious adversaries [20, 36, 64] (for sim-
pler ML models like linear models, regression, and polynomials)
as well as specialized DNNs with 1 or 2 bit weights [4, 55, 57]. Re-
cently, [26] gave protocols for faithful truncation (but not division)
over â„“-bit integers and prime fields in various adversarial settings.
For 2-party semi-honest setting, our protocols have up to 20Ã— less
communication for the truncations required in our evaluation.
1.4 Organisation
We begin with the details on security and cryptographic primi-
tives used in Section 2 on preliminaries. In Section 3 we provide our
protocols for millionairesâ€™ (Section 3.1) and DReLU (Section 3.2, 3.3),
over both Zğ¿ and general ring Zğ‘›. In Section 4, we present our
protocols for division and truncation. We describe the various com-
ponents of DNN inference in Section 5 and show how to construct
secure protocols for all these components given our protocols from
Sections 3 and 4. We present our implementation details in Section 6
and our experiments in Section 7. Finally, we conclude and discuss
future work in Section 8.
2 PRELIMINARIES
Notation. For a set W, ğ‘¤ $â† W denotes sampling an element
ğ‘¤, uniformly at random from W. [â„“] denotes the set of integers
{0, Â· Â· Â· , â„“ âˆ’1}. Let 1{ğ‘} denote the indicator function that is 1 when
ğ‘ is true and 0 when ğ‘ is false.
2.1 Threat Model and Security
We provide security in the simulation paradigm [18, 32, 47]
against a static semi-honest probabilistic polynomial time (PPT)
adversary A. That is, a computationally bounded adversary A cor-
rupts either ğ‘ƒ0 or ğ‘ƒ1 at the beginning of the protocol and follows
the protocol specification honestly. Security is modeled by defin-
ing two interactions: a real interaction where ğ‘ƒ0 and ğ‘ƒ1 execute
the protocol in the presence of A and the environment Z and an
ideal interaction where the parties send their inputs to a trusted
functionality that performs the computation faithfully. Security
requires that for every adversary A in the real interaction, there
is an adversary S (called the simulator) in the ideal interaction,
such that no environment Z can distinguish between real and ideal
interactions. Many of our protocols invoke multiple sub-protocols
and we describe these using the hybrid model. This is similar to a
real interaction, except that sub-protocols are replaced by the in-
vocations of instances of corresponding functionalities. A protocol
invoking a functionality F is said to be in â€œF -hybrid model.â€
2.2 Cryptographic Primitives
Secret Sharing Schemes. Throughout this work, we use 2-out-
2.2.1
of-2 additive secret sharing schemes over different rings [11, 59].
The 3 specific rings that we consider are the field Z2, the ring Zğ¿,
where ğ¿ = 2â„“ (â„“ = 32, typically), and the ring Zğ‘›, for a positive
integer ğ‘› (this last ring includes the special case of prime fields used
in the works of [43, 49]). We let Shareğ¿(ğ‘¥) denote the algorithm
that takes as input an element ğ‘¥ in Zğ¿ and outputs shares over
Zğ¿, denoted by âŸ¨ğ‘¥âŸ©ğ¿
1 . Shares are generated by sampling
random ring elements âŸ¨ğ‘¥âŸ©ğ¿
1 , with the only constraint that
1 = ğ‘¥ (where + denotes addition in Zğ¿). Additive secret
âŸ¨ğ‘¥âŸ©ğ¿
0 and âŸ¨ğ‘¥âŸ©ğ¿
0 and âŸ¨ğ‘¥âŸ©ğ¿
0 + âŸ¨ğ‘¥âŸ©ğ¿
4
1
1
sharing schemes are perfectly hiding, i.e., given a share âŸ¨ğ‘¥âŸ©ğ¿
0 or âŸ¨ğ‘¥âŸ©ğ¿
1 ,
the value ğ‘¥ is completely hidden. The reconstruction algorithm
Reconstğ¿(âŸ¨ğ‘¥âŸ©ğ¿
1 ) takes as input the two shares and outputs
0 , âŸ¨ğ‘¥âŸ©ğ¿
ğ‘¥ = âŸ¨ğ‘¥âŸ©ğ¿
0 + âŸ¨ğ‘¥âŸ©ğ¿
1 . Shares (along with their corresponding Share()
and Reconst() algorithms) are defined in a similar manner for Z2
and Zğ‘› with superscripts ğµ and ğ‘›, respectively. We sometimes refer
to shares over Zğ¿ and Zğ‘› as arithmetic shares and shares over Z2
as boolean shares.
(cid:1)-OTâ„“ denote the 1-out-of-ğ‘˜ Obliv-
2.2.2 Oblivious Transfer. Let(cid:0)ğ‘˜
ious Transfer (OT) functionality [16] (which generalizes 1-out-of-2
OT [27, 54]). The senderâ€™s inputs to the functionality are the ğ‘˜
strings ğ‘š0, Â· Â· Â· , ğ‘šğ‘˜âˆ’1, each of length â„“ and the receiverâ€™s input is
a value ğ‘– âˆˆ [ğ‘˜]. The receiver obtains ğ‘šğ‘– from the functionality
and the sender receives no output. We use the protocols from [44],
which are an optimized and generalized version of the OT exten-
sion framework proposed in [9, 41]. This framework allows the
sender and receiver, to â€œreduceâ€ ğœ†ğ‘ number of oblivious transfers
to ğœ† â€œbaseâ€ OTs. We also use the notion of correlated 1-out-of-2
OT [5], denoted by(cid:0)2
depending on ğ‘. The protocols for(cid:0)ğ‘˜
ğœ† + â„“, respectively. Moreover, simpler(cid:0)2
(cid:1)-COTâ„“. In our context, this is a functionality
(cid:1)-OTâ„“ [44] and(cid:0)2
(cid:1)-COTâ„“ [5]
(cid:1)-OTâ„“ has a communication
where the senderâ€™s input is a ring element ğ‘¥ and the receiverâ€™s
input is a choice bit ğ‘. The sender receives a random ring element
ğ‘Ÿ as output and the receiver obtains either ğ‘Ÿ or ğ‘¥ + ğ‘Ÿ as output
execute in 2 rounds and have total communication7 of 2ğœ† + ğ‘˜â„“ and
of ğœ† + 2â„“ bits [5, 41].
2.2.3 Multiplexer and B2A conversion. The functionality F ğ‘›
MUX
takes as input arithmetic shares of ğ‘ over ğ‘› and boolean shares of
choice bit ğ‘ from ğ‘ƒ0, ğ‘ƒ1, and returns shares of ğ‘ if ğ‘ = 1, else returns
shares of 0 over the same ring. A protocol for F ğ‘›
MUX can easily be im-
complexity is 2(ğœ† + 2ğœ‚), where ğœ‚ = âŒˆlog ğ‘›âŒ‰.
plemented by 2 simultaneous calls to(cid:0)2
via one call to(cid:0)2
(cid:1)-OTğœ‚ and communication
(cid:1)-COTğœ‚ and hence, its communication is ğœ† + ğœ‚. For
B2A (for boolean to arithmetic conversion)
takes boolean (i.e., over Z2) shares as input and gives out arithmetic
(i.e., over Zğ‘›) shares of the same value as output. It can be realized
completeness, we provide the protocols realizing F ğ‘›
F ğ‘›
B2A formally in Appendix A.3 and Appendix A.4, respectively.
2.2.4 Homomorphic Encryption. A homomorphic encryption of ğ‘¥
allows computing encryption of ğ‘“ (ğ‘¥) without the knowledge of the
decryption key. In this work, we require an additively homomorphic
encryption scheme that supports addition and scalar multiplication,
i.e. multiplication of a ciphertext with a plaintext. We use the addi-
tively homomorphic scheme of BFV [15, 28] (the scheme used in the
recent works of Gazelle [43] and Delphi [49]) and use the optimized
algorithms of Gazelle for homomorphic matrix-vector products and
homomorphic convolutions. The BFV scheme uses the batching
optimization [46, 60] that enables operation on plaintext vectors
over the field Zğ‘›, where ğ‘› is a prime plaintext modulus of the form
2ğ¾ğ‘ + 1, ğ¾ is some positive integer and ğ‘ is scheme parameter
7The protocol of(cid:0)ğ‘˜
that is a power-of-2.
(cid:1)-COTâ„“ . In concrete terms, therefore, we write the cost as 2ğœ† + ğ‘˜â„“.
(cid:0)2
(cid:1)-OTâ„“ [44] incurs a communication cost of ğœ† + ğ‘˜â„“. However, to
achieve the same level of security, their security parameter needs to be twice that of
1
The functionality F ğ‘›
MUX as well as
1