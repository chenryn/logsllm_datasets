cryption. In CCS, 2015.
[13] Anrin Chakraborti and Radu Sion. Concuroram: High-
throughput stateless parallel multi-client oram. In NDSS,
2019.
[14] Zhao Chang, Dong Xie, and Feifei Li. Oblivious ram: a
dissection and experimental evaluation. VLDB, 2016.
[15] Ciphercloud. http://www.ciphercloud.com/.
[16] Jacob Willem Cohen and Anthony Browne. The single
server queue. 1982.
[17] Brian F Cooper, Adam Silberstein, Erwin Tam, Raghu
Ramakrishnan, and Russell Sears. Benchmarking Cloud
Serving Systems with YCSB. In SoCC, 2010.
[18] Natacha Crooks, Matthew Burke, Ethan Cecchetti, Sitar
Harel, Rachit Agarwal, and Lorenzo Alvisi. Obladi:
Oblivious serializable transactions in the cloud. In OSDI,
2018.
[19] Giuseppe DeCandia, Deniz Hastorun, Madan Jampani,
Gunavardhan Kakulapati, Avinash Lakshman, Alex
Pilchin, Swaminathan Sivasubramanian, Peter Vosshall,
and Werner Vogels. Dynamo: Amazon’s Highly Avail-
able Key-value Store. In SOSP, 2007.
[20] Deep Learning Meets Heterogeneous Computing.
https://bit.ly/3hCoPz8.
[21] Peter X Gao, Akshay Narayan, Sagar Karandikar, Joao
Carreira, Sangjin Han, Rachit Agarwal, Sylvia Rat-
nasamy, and Scott Shenker. Network requirements for
resource disaggregation. In OSDI, 2016.
[22] Oded Goldreich, Shafﬁ Goldwasser, and Silvio Micali.
How to construct random functions. JACM, 1986.
[23] Oded Goldreich and Rafail Ostrovsky. Software protec-
tion and simulation on oblivious rams. JACM, 1996.
[24] How Google Search works. https://bit.ly/3hGWt70.
[25] Paul Grubbs, Anurag Khandelwal, Marie-Sarah Lachar-
ité, Lloyd Brown, Lucy Li, Rachit Agarwal, and Thomas
Ristenpart. Pancake: Frequency smoothing for en-
crypted data stores. Technical report, 2020. https:
//github.com/pancake-security.
[26] Paul Grubbs, Marie-Sarah Lacharité, Brice Minaud, and
Kenneth G Paterson. Learning to reconstruct: Statistical
learning theory and encrypted database attacks. In IEEE
S&P, 2019.
[27] Paul Grubbs, Thomas Ristenpart, and Vitaly Shmatikov.
Why your encrypted database is not secure. In HotOS,
2017.
[28] Jaehyun Hwang, Qizhe Cai, Ao Tang, and Rachit Agar-
wal. TCP≈RDMA: Cpu-efﬁcient remote storage access
with i10. In NSDI, 2020.
[29] MS Islam, Mehmet Kuzu, and Murat Kantarcioglu. Ac-
cess pattern disclosure on searchable encryption: ramiﬁ-
cation, attack and mitigation. In NDSS, 2012.
[30] Michael Kearns, Yishay Mansour, Dana Ron, Ronitt Ru-
binfeld, Robert E. Schapire, and Linda Sellie. On the
learnability of discrete distributions. In STOC, 1994.
2464    29th USENIX Security Symposium
USENIX Association
[31] Georgios Kellaris, George Kollios, Kobbi Nissim, and
Adam O’Neill. Generic attacks on secure outsourced
databases. In CCS, 2016.
[32] Anurag Khandelwal, Rachit Agarwal, and Ion Stoica.
Blowﬁsh: Dynamic storage-performance tradeoff in data
stores. In NSDI, 2016.
[47] Neo4j. http://neo4j.com/.
[48] Antonis Papadimitriou, Ranjita Bhagwan, Nishanth
Chandran, Ramachandran Ramjee, Andreas Haeberlen,
Harmeet Singh, Abhishek Modi, and Saikrishna Badri-
narayanan. Big data analytics over encrypted datasets
with Seabed. In OSDI, 2016.
[33] Anurag Khandelwal, Zongheng Yang, Evan Ye, Rachit
Agarwal, and Ion Stoica. Zipg: A memory-efﬁcient
graph store for interactive queries. In SIGMOD, 2017.
[49] Sarvar Patel, Giuseppe Persiano, and Kevin Yeo. What
storage access privacy is achievable with small over-
head? In PODS, 2019.
[34] Daniel Kifer, Shai Ben-David, and Johannes Gehrke.
Detecting change in data streams. In VLDB, 2004.
[50] Giuseppe Persiano and Kevin Yeo. Lower bounds for
differentially private rams. In EUROCRYPT 2019, 2019.
[35] Ana Klimovic, Heiner Litz, and Christos Kozyrakis. Re-
ﬂex: Remote ﬂash ≈ local ﬂash. SIGARCH, 2017.
[36] Andrey Kolmogorov. Sulla determinazione empirica
di una lgge di distribuzione. Inst. Ital. Attuari, Giorn.,
1933.
[37] Evgenios M Kornaropoulos, Charalampos Papaman-
thou, and Roberto Tamassia. Data recovery on encrypted
databases with k-nearest neighbor query leakage. In
IEEE S&P, 2019.
[38] Marie-Sarah Lacharité and Kenneth G. Paterson.
Frequency-smoothing encryption: preventing snapshot
attacks on deterministically-encrypted data.
IACR
ePrint, 2017. https://eprint.iacr.org/2017/1068.
[39] Kasper Green Larsen, Tal Malkin, Omri Weinstein, and
Kevin Yeo. Lower bounds for oblivious near-neighbor
search. arXiv preprint arXiv:1904.04828, 2019.
[40] Kasper Green Larsen and Jesper Buus Nielsen. Yes,
there is an oblivious ram lower bound!
In Hovav
Shacham and Alexandra Boldyreva, editors, CRYPTO.
Springer International Publishing, 2018.
[41] Xiaozhou Li, David G. Andersen, Michael Kaminsky,
and Michael J. Freedman. Algorithmic improvements
for fast concurrent cuckoo hashing. In EuroSys, 2014.
[42] Charalampos Mavroforakis, Nathan Chenette, Adam
O’Neill, George Kollios, and Ran Canetti. Modular
In SIGMOD,
order-preserving encryption, revisited.
2015.
[43] MongoDB. http://www.mongodb.org.
[44] InnoDB memcached Plugin. https://bit.ly/3edTmRD.
[45] Navajo Systems. http://tinyurl.com/y85obds6.
[46] Muhammad Naveed, Seny Kamara, and Charles V
Wright. Inference attacks on property-preserving en-
crypted databases. In CCS, 2015.
[51] Perspecsys: A Blue Coat Company.
perspecsys.com/.
http : / /
[52] Rishabh Poddar, Tobias Boelter, and Raluca Ada Popa.
Arx: an encrypted database using semantically secure
encryption. VLDB, 2019.
[53] Raluca Popa, Catherine Redﬁeld, Nickolai Zeldovich,
and Hari Balakrishnan. CryptDB: Protecting conﬁden-
tiality with encrypted query processing. In SOSP, 2011.
[54] Redis. http://www.redis.io.
[55] RocksDB. http://rocksdb.org.
[56] Phillip Rogaway and Thomas Shrimpton. A provable-
security treatment of the key-wrap problem. In EURO-
CRYPT, 2006.
[57] Cetin Sahin, Victor Zakhary, Amr El Abbadi, Huijia
Lin, and Stefano Tessaro. Taostore: Overcoming asyn-
In IEEE S&P,
chronicity in oblivious data storage.
2016.
[58] A uniﬁed testbed for evaluating different Oblivious
RAM. https://github.com/InitialDLab/SEAL-ORAM.
[59] Rocco A Servedio. Lower bounds for learning discrete
distributions.
[60] Skyhigh Networks. https://www.skyhighnetworks.
com/.
[61] Nikolai V Smirnov. Estimate of deviation between em-
pirical distribution functions in two independent sam-
ples. Bulletin Moscow University, 1939.
[62] Emil Stefanov and Elaine Shi. Oblivistore: High perfor-
mance oblivious cloud storage. In IEEE S&P, 2013.
[63] Emil Stefanov, Marten Van Dijk, Elaine Shi, Christopher
Fletcher, Ling Ren, Xiangyao Yu, and Srinivas Devadas.
Path ORAM: an extremely simple oblivious ram proto-
col. In CCS, 2013.
USENIX Association
29th USENIX Security Symposium    2465
[64] The Infrastructure Behind Twitter: Scale. https://bit.
ly/2zLrDsI.
[65] Midhul Vuppalapati, Justin Miron, Rachit Agarwal, Dan
Truong, Ashish Motivala, and Thierry Cruanes. Building
an elastic query engine on disaggregated storage. In
NSDI, 2020.
For an AEAD scheme E and adversary A, we deﬁne the
real-or-random (ROR) advantage of A against E relative to
two games, ROR1 and ROR0. In the ﬁrst A has access to an
E.Enc oracle with uniformly random key, and in the second
A’s oracle returns uniformly random bit strings of length
len(|m|) where |m| is the length of the input. We deﬁne A’s
ROR advantage against E as
[66] Mor Weiss and Daniel Wichs. Is there an oblivious ram
lower bound for online reads? In TCC, 2018.
Advror
E (A) =
(cid:105)(cid:12)(cid:12)(cid:12) .
(cid:105)(cid:12)(cid:12)(cid:12) .
[67] Frank Wilcoxon. Individual comparisons by ranking
methods. Biometrics Bulletin, 1945.
[68] Yupeng Zhang, Jonathan Katz, and Babis Papamanthou.
All your queries are belong to us: the power of ﬁle in-
jection attacks. In USENIX Security, 2016.
[69] Wenting Zheng, Frank Li, Raluca Ada Popa, Ion Stoica,
and Rachit Agarwal. MiniCrypt: Reconciling encryption
and compression for big data stores. In EuroSys, 2017.
A Security Proofs
In this appendix, we give some technical preliminaries and
then prove Theorems 1 and 2.
Technical preliminaries. Throughout, we will use the con-
crete security approach [6]. For a (keyed) function F : K×
{0,1}∗ → {0,1}m and adversary A, we deﬁne the pseudo-
random function (PRF) advantage relative to two games. In
game PRF1, A has access to an oracle that accepts inputs
from {0,1}∗ and outputs the PRF value on that point and a
uniformly random key (which is the same for all queries). In
game PRF0, A’s oracle is a (lazy-sampled) random function
from {0,1}∗ to {0,1}m. We deﬁne A’s PRF advantage to be
(cid:105)
(cid:104)
Advprf
F (A) =
PRF1A ⇒ 1
− Pr
PRF0A ⇒ 1
(cid:104)
(cid:12)(cid:12)(cid:12)Pr
(cid:105)(cid:12)(cid:12)(cid:12)
where the probability is taken over the random choice of key
(in PRF1) or lazy-sampled random function (in PRF0) and
the adversary’s internal random coins. Below, we will leave
implicit the coin spaces involved in probabilities.
An authenticated encryption with associated data (AEAD)
scheme E = (KeyGen, Enc, Dec) is a triple of algorithms. The
function E.KeyGen takes no inputs and outputs elements of
K. The function E.Enc takes a key from K, a plaintext from
M, (optionally) some associated data from A, and outputs
ciphertexts in C. The function E.Dec takes a key from K, a
ciphertext from C, (optionally) some associated data from A,
and outputs a plaintext in M or ⊥.
We additionally require AEAD schemes to have a function
len which takes a positive integer (cid:96) representing a plaintext
length and outputs the length of any ciphertext of a plaintext
of length (cid:96). Essentially, the length of any plaintext’s cipher-
text must be computable given only the plaintext length and
nothing else. Most natural AEAD schemes have this property.
(cid:104)
(cid:12)(cid:12)(cid:12)Pr
(cid:105)
(cid:104)
ROR1A ⇒ 1
− Pr
ROR0A ⇒ 1
For a distribution π and adversary D that outputs a bit,
let DISTD
q,π be the game that samples q times from π, runs
D on the resulting outputs, and outputs D’s output. For two
distributions π,π(cid:48) with supp(π) = supp(π(cid:48)), we measure their
q-sample indistinguishability from an adversary D via the
advantage measure
(cid:104)
(cid:12)(cid:12)(cid:12)Pr
(cid:105)
(cid:104)
Advdist
q,π,π(cid:48)(D) =
DISTD
q,π ⇒ 1
− Pr
DISTD
q,π(cid:48)
This just captures the computational indistinguishability of
the two distributions, given q samples from them.
Frequency smoothing KV schemes. Recall from §4 that
PANCAKE has two algorithms: Init and Batch. To model dis-
tribution estimation errors and adjustments made when distri-
butions change (as per §5), we extend our formalism by intro-
ducing two further algorithms. More precisely, an encrypted
KV scheme EKV = (Init,Batch) is a pair of algorithms:
• A randomized initialization algorithm Init that takes
as input an estimated distribution ˆπ, a KV store KV,
and a threshold α, and outputs an encrypted KV store
KV(cid:48), a fake distribution π f , a function R, and a real
query probability δ. We denote running this algorithm
by (KV(cid:48),π f ,R,δ)←$ Init(ˆπ, KV,α).
• A randomized, stateful batch query algorithm Batch that
takes as input a key k, the function R that maps keys to
replica counts, and outputs a batch of B labels. We denote
running this algorithm by ((cid:96)1, . . . , (cid:96)B)←$ Batch(k). Note
that to avoid notational clutter we omit from the notation
the values ˆπ,π f ,δ and the state that Batch relies upon.
We have assumed distributions have efﬁcient representations,
and abuse notation by using the same variables π, ˆπ, π f , etc.,
as both distributions and their representations. For any ﬁxed
distribution π, we assume that Init always outputs an en-
crypted KV store of a constant size n(cid:48). PANCAKE satisﬁes
these assumptions; its algorithms were described in the body.
Notice that our formalization here only handles read
queries. As discussed in the body, we perform writes by
always doing write-backs. Thus, security analysis can be
reduced to the read-only case, greatly simplifying our for-
malization and security deﬁnitions.
Security for static distributions. We now formalize our
ROR-CDA deﬁnition for a ﬁxed scheme EKV = (Init,Batch).
2466    29th USENIX Security Symposium
USENIX Association
q,π,ˆπ:
ROR-CDA1A
KV←$ A1
(KV(cid:48),π f ,δ)←$ Init(ˆπ, KV,α)
kF ←$ K;kAE ←$ K
For i in 1 to q: