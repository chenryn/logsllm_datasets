这种类似的编译器的优化会对我们分析系统软件背后的机制带来很多障碍，使得很多问
题不能一目了然，本书将尽量避开这些优化过程，还原机制和原理本身。
3.3.4
其他段
除了.text、.data、.bss 这3个最常用的段之外，ELF文件也有可能包含其他的段，用来
保存与程序相关的其他信息。表3-2中列举了ELF的一些常见的段。
表3-2
常用的段名
说明
.rodata1
Readonly Data，这种段里存放的是只读数据，比如字符串常量、全局const
支量。跟“rodata”一样
.comment
存效的是编译器版本信息，比如字符串：“GCC：（GNU）4.2.0"
debug
调试信息
.dynamic
动态链接信惠，详见本书第2部分
.hash
符号哈希表
Jine
调试时的行号表，即源代码行号与编译后指令的对应表
.note
额外的编译器信息，比如程序的公司名、发布版本号等
.strtab
StringTable.字基事表，用于存储ELF文件中用到的各种字符事
-symtab
Symbol Table.符号表
shstrtab
Section String Table.及名表
-plt
动态链接的距转表和全局入口表，详见本书第2部分
go
init
程序初始化与终结代码段，见“C++全局构造与析构”一节
fini
这些段的名字都是由“”作为前缀，表示这些表的名字是系统保留的，应用程序也可
段，里面存放了一首MP3音乐，当ELF文件运行起来以后可以读取这个段播放这首MP3。
一个
ELF文件也可以拥有几个相同段名的段，比如一个ELF文件中可能有两个或两个以上叫做
名字如.sdata、.ldesc、sbss、lit4、lit8、.reginfo、gptab、liblist、confict。可以不用理会
这些段，它们已经被遗弃了。
程序员的自我修养一—链接、装载与库
---
## Page 91
68
第3章目标文件里有什么
Q8A
Q：如果我们要将一个二进制文件，比如图片、MP3音乐、词典一类的东西作为目标文件
中的一个段，该怎么做？
A：可以使用objcopy工具，比如我们有一个图片文件“image-jpg”，大小为0x82100宇节：
$objdump
-ht inage.o
image.0:
fi1e format elf32-i386
Sect ions1
Idx Name
0.data
Size
00081200
000000000000000000000034
VMA
LMA
File off Algn
CONTENTS, ALLOC, LOAD, DATA
2**0
SYMBOL TABLE:
00000000g
00000000 1
.data
data
00000000.data
00081200 g
00000000
_binary_inage_ipg_start
00081200g
, data
000ooooo _binary_image_Jpg_size
00000000
_binary_image_jpg_end
*ABS*
_azis3deuKmeu",  pus8dsewKeu”。 _ues8d8euKmu"。 
分别表示该图片文件在内存中的起始地址、结束地址和大小，我们可以在程序里面直接声明
并使用它们。
自定义段
正常情况下，GCC编译出来的目标文件中，代码会被放到“.text”段，全局变量和静态
变量会被放到“data”和“.bss”段，正如我们前面所分析的。但是有时候你可能希望变量或
某些部分代码能够放到你所指定的段中去，以实现某些特定的功能。比如为了满足某些硬件
的内存和IO的地址布局，或者是像Limux操作系统内核中用来完成一些初始化和用户空间复
制时出现页错误异常等。GCC提供了一个扩展机制，使得程序员可以指定变量所处的段：
__attribute_((section(*roo*)>)int global - 42;
_attribute__ ( (section (*BAR*))) void foo (1
1
1
我们在全局变量或函数之前加上“_atribute_(（section(name"）)”属性就可以把相应
的变量或函数放到以“name”作为段名的段中。
3.4
ELF文件结构描述
我们已经通过SimpleSection.o的结构大致了解了ELF文件的轮廓，接着就来看看ELF
程序员的自我修养一链接、装载与库
---
## Page 92
3.4ELF文件结构描述
69
文件的结构格式。图3-4描述的是ELF目标文件的总体结构，我们省去了ELF些繁琐的
结构，把最重要的结构提取出来，形成了如图3-4所示的ELF文件基本结构图，随着我们
讨论的展开，ELF文件结构会在这个基本结构之上慢慢变得复杂起来。
ELF Header
.fext
data
.bss
ofher sections
Section header table
Symbol Tables
String Tables
图 3-4ELF 结构
ELF目标文件格式的最前部是ELF文件头（ELFHeader），它包含了描述整个文件的
基本属性，比如ELF文件版本、目标机器型号、程序入口地址等。紧接着是ELF文件各个
段。其中ELF文件中与段有关的重要结构就是段表（SectionHeaderTable），该表捕述了
ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限
及段的其他属性。接着将详细分析ELF文件头、段表等ELF关键的结构。另外还会介绍一
些ELF中辅助的结构，比如字符串表、符号表等，这些结构我们在本节只是简单介绍一下，
到相关章节中再详细展开。
3.4.1文件头
我们可以用readelf命令来详细查看ELF文件，代码如清单3-2所示。
清单3-2查看ELF文件头
$readelf -h SinpleSection.o
ELF Header:
Kagic:
7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
C1ass1
2*s complement, 1ittle endian
ELF32
Data1
Version1
UNIX - System V
1(current)
OS/ABI:
ABI Version:
Type:
REL (Relocatable fi1e)
Kachine:
Intel 80386
Version1
Entry point address:
0x1
Start of progran headers:
0(bytes into file)
0x0
程序员的自我修养一—链接、装载与库
---
## Page 93
70
第3章
目标文件里有什么
Start of section headers:
280 (bytes into fi1e)
Flags:
Size of this header:
52 (bytes)
0x0
Size of program headers:
Nunber of program headers:
0(bytes)
Size of section headers:
40(bytes)
0
Section header string table index1
Number of section headers:
1.1
8
从上面输出的结果可以看到，ELF的文件头中定义了ELF魔数、文件机器字节长度、
数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、
入口地址、程序头入口和长度、段表的位置和长度及段的数量等。这些数值中有关描述ELF
目标平台的部分，与我们常见的32位Intel的硬件平台基本上一样。
ELF文件头结构及相关常数被定义在“/usr/include/elf.h”里，因为 ELF 文件在各种平
台下都通用，ELF文件有32位版本和64位版本。它的文件头结构也有这两种版本，分别叫
做“EIf32_Ehdr”和“Elf64_Ehdr”，32位版本与64位版本的 ELF 文件的文件头内容是一样
的，只不过有些成员的大小不一样。为了对每个成员的大小做出明确的规定以便于在不同的
编译环境下都拥有相同的字段长度，“elfh”使用typedef定义了一套白已的变量体系，如表
3-3所示。
表3-3
自定义类型
描述
原始类型
长度（字节）
Elf32_Addr
32位版本程序地址
uint32_1
4
Elf32_Half
32位版本的无符号短整形
uint16_1
2
Ef32_Off
32位版本的偏移地址
uint32_1
4
Elf32_Sword
32位版本有符号整形
uint32_t
4
EIf32_Word
32位版本无符号整形
int32_1
4
EIf64_Addr
64位版本程序地址
1“g1en
8
Elf64_Half
64位版本的无符号经整形
uint16_t
2
Elf64_Off
64位版本的偏移地址
uint64_t
8
Elf64_Sword
64位版本有符号整形
uint32_t
4
Elf64_Word
64位版本无符号整形
int32_t
我们这里以32位版本的文件头结构“Elf32_Ehdr”作为例子来描述，它的定义如下：
typedef struct (
unsigned char o_ident [16] :
E1f32_Half e_type;
E1r32_word e_version;
E1r32_Half e_nachine;
E1f32_Addr e_entry:
程序员的自我修养—链接、装载与库
---
## Page 94
3.4ELF文件结构描述
71
g1f32_off
e_phoff;
E1f32_word e_flags;
E1f32_off
e_shoff;
E1f32_Half e_ehsize;
E1f32_Half e_phnum;
E1f32_Half e_phentsize;
E1f32_Half e_shnun;