Each partition object, which we described in Chapter 5 of Part 1, contains an executive partition, 
which is the portion of the partition object relevant to the executiveâ€”namely, the system worker 
thread logic. It contains a data structure tracking the work queue manager for each NUMA node part 
of the partition (a queue manager is made up of the deadlock detection timer, the work queue item 
reaper, and a handle to the actual thread doing the management). It then contains an array of pointers 
to each of the eight possible work queues (EX_WORK_QUEUE). These queues are associated with an 
individual index and track the number of minimum (guaranteed) and maximum threads, as well as how 
many work items have been processed so far.
CHAPTER 8 System mechanisms
83
Every system includes two default work queues: the ExPool queue and the IoPool queue. The former 
is used by drivers and system components using the ExQueueWorkItem API, whereas the latter is meant 
for IoAllocateWorkItem
meant to be used by the internal (non-exported) ExQueueWorkItemToPrivatePool API, which takes in 
a pool identifier
Store Manager (see Chapter 5 of Part 1 for more information) leverages this capability.
The executive tries to match the number of critical worker threads with changing work-
loads as the system executes. Whenever work items are being processed or queued, a check is 
made to see if a new worker thread might be needed. If so, an event is signaled, waking up the 
ExpWorkQueueManagerThread for the associated NUMA node and partition. An additional worker 
thread is created in one of the following conditions:
I 
There are fewer threads than the minimum number of threads for this queue.
I 
pending work items in the queue, or the last attempt to try to queue a work item failed.
Additionally, once every second, for each worker queue manager (that is, for each NUMA node on 
each partition) the ExpWorkQueueManagerThread can also try to determine whether a deadlock may 
matching increase in the number of work items processed. If this is occurring, an additional worker 
thread will be created, regardless of any maximum thread limits, hoping to clear out the potential 
deadlock. This detection will then be disabled until it is deemed necessary to check again (such as if 
the maximum number of threads has been reached). Since processor topologies can change due to hot 
add
keep track of the new processors as well.
worker thread timeout minutes (by default 10, so once every 20 
minutes), this thread also checks if it should destroy any system worker threads. Through the same 
WorkerThreadTimeoutInSeconds. This is called reaping and ensures that system worker thread counts 
do not get out of control. A system worker thread is reaped if it has been waiting for a long time 
(meaning the current number of threads are clearing them all out in a timely fashion).
EXPERIMENT: Listing system worker threads
-
ity (which is no longer per-NUMA node as before, and certainly no longer global), the kernel 
!exqueue command can no longer be used to see a listing of system worker threads 
Since the EPARTITION, EX_PARTITION, and EX_WORK_QUEUE data structures are all available 
in the public symbols, the debugger data model can be used to explore the queues and their 
EXPERIMENT: Listing system worker threads
-
ity (which is no longer per-NUMA node as before, and certainly no longer global), the kernel 
!exqueue command can no longer be used to see a listing of system worker threads 
Since the EPARTITION, EX_PARTITION, and EX_WORK_QUEUE data structures are all available 
EX_WORK_QUEUE data structures are all available 
EX_WORK_QUEUE
in the public symbols, the debugger data model can be used to explore the queues and their 
84 
CHAPTER 8 System mechanisms
for the main (default) system partition:
lkd> dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)->  
    WorkQueueManagers[0] 
((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)-> 
    WorkQueueManagers[0]
: 0xffffa483edea99d0 [Type: _EX_WORK_QUEUE_MANAGER *] 
    [+0x000] Partition
: 0xffffa483ede51090 [Type: _EX_PARTITION *] 
    [+0x008] Node
: 0xfffff80467f24440 [Type: _ENODE *] 
    [+0x010] Event
[Type: _KEVENT] 
    [+0x028] DeadlockTimer    [Type: _KTIMER] 
    [+0x068] ReaperEvent
[Type: _KEVENT] 
    [+0x080] ReaperTimer
[Type: _KTIMER2] 
    [+0x108] ThreadHandle     : 0xffffffff80000008 [Type: void *] 
    [+0x110] ExitThread
: 0x0 [Type: unsigned long] 
    [+0x114] ThreadSeed
: 0x1 [Type: unsigned short]
Alternatively, here is the ExPool for NUMA Node 0, which currently has 15 threads and has 
processed almost 4 million work items so far! 
lkd> dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)-> 
    WorkQueues[0][0],d 
((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)-> 
    WorkQueues[0][0],d
: 0xffffa483ede4dc70 [Type: _EX_WORK_QUEUE *] 
    [+0x000] WorkPriQueue     [Type: _KPRIQUEUE] 
    [+0x2b0] Partition
: 0xffffa483ede51090 [Type: _EX_PARTITION *] 
    [+0x2b8] Node
: 0xfffff80467f24440 [Type: _ENODE *] 
    [+0x2c0] WorkItemsProcessed : 3942949 [Type: unsigned long] 
    [+0x2c4] WorkItemsProcessedLastPass : 3931167 [Type: unsigned long] 
    [+0x2c8] ThreadCount
: 15 [Type: long] 
    [+0x2cc (30: 0)] MinThreads
: 0 [Type: long] 
    [+0x2cc (31:31)] TryFailed
: 0 [Type: unsigned long] 
    [+0x2d0] MaxThreads
: 4096 [Type: long] 
    [+0x2d4] QueueIndex
: ExPoolUntrusted (0) [Type: _EXQUEUEINDEX] 
    [+0x2d8] AllThreadsExitedEvent : 0x0 [Type: _KEVENT *]
You could then look into the ThreadListWorkPriQueue to enumerate the worker 
threads associated with this queue:
lkd> dx -r0 @$queue = ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)-> 
    ExPartition)->WorkQueues[0][0] 
@$queue = ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)-> 
    WorkQueues[0][0]
: 0xffffa483ede4dc70 [Type: _EX_WORK_QUEUE *] 
lkd> dx Debugger.Utility.Collections.FromListEntry(@$queue->WorkPriQueue.ThreadListHead, 
    "nt!_KTHREAD", "QueueListEntry") 
Debugger.Utility.Collections.FromListEntry(@$queue->WorkPriQueue.ThreadListHead, 
    "nt!_KTHREAD", "QueueListEntry")
    [0x0]
[Type: _KTHREAD] 
    [0x1]
[Type: _KTHREAD] 
    [0x2]
[Type: _KTHREAD] 
    [0x3]
[Type: _KTHREAD] 
    [0x4]
[Type: _KTHREAD] 
    [0x5]
[Type: _KTHREAD] 
    [0x6]
[Type: _KTHREAD] 
for the main (default) system partition:
lkd> dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)->  
    WorkQueueManagers[0]
((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)->
    WorkQueueManagers[0]
: 0xffffa483edea99d0 [Type: _EX_WORK_QUEUE_MANAGER *]
    [+0x000] Partition
: 0xffffa483ede51090 [Type: _EX_PARTITION *]
    [+0x008] Node
: 0xfffff80467f24440 [Type: _ENODE *]
    [+0x010] Event
[Type: _KEVENT]
    [+0x028] DeadlockTimer    [Type: _KTIMER]
    [+0x068] ReaperEvent
[Type: _KEVENT]
    [+0x080] ReaperTimer
[Type: _KTIMER2]
    [+0x108] ThreadHandle     : 0xffffffff80000008 [Type: void *]
    [+0x110] ExitThread
: 0x0 [Type: unsigned long]
    [+0x114] ThreadSeed
: 0x1 [Type: unsigned short]
Alternatively, here is the ExPool for NUMA Node 0, which currently has 15 threads and has 
processed almost 4 million work items so far! 
lkd> dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)->
    WorkQueues[0][0],d
((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)->
    WorkQueues[0][0],d
: 0xffffa483ede4dc70 [Type: _EX_WORK_QUEUE *]
    [+0x000] WorkPriQueue     [Type: _KPRIQUEUE]
    [+0x2b0] Partition
: 0xffffa483ede51090 [Type: _EX_PARTITION *]
    [+0x2b8] Node
: 0xfffff80467f24440 [Type: _ENODE *]
    [+0x2c0] WorkItemsProcessed : 3942949 [Type: unsigned long]
    [+0x2c4] WorkItemsProcessedLastPass : 3931167 [Type: unsigned long]
    [+0x2c8] ThreadCount
: 15 [Type: long]
    [+0x2cc (30: 0)] MinThreads
: 0 [Type: long]
    [+0x2cc (31:31)] TryFailed
: 0 [Type: unsigned long]
    [+0x2d0] MaxThreads
: 4096 [Type: long]
    [+0x2d4] QueueIndex
: ExPoolUntrusted (0) [Type: _EXQUEUEINDEX]
    [+0x2d8] AllThreadsExitedEvent : 0x0 [Type: _KEVENT *]
You could then look into the ThreadList
ThreadList
ThreadList
WorkPriQueue to enumerate the worker 
threads associated with this queue:
lkd> dx -r0 @$queue = ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->
    ExPartition)->WorkQueues[0][0]
@$queue = ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)->
    WorkQueues[0][0]
: 0xffffa483ede4dc70 [Type: _EX_WORK_QUEUE *]
lkd> dx Debugger.Utility.Collections.FromListEntry(@$queue->WorkPriQueue.ThreadListHead, 
    "nt!_KTHREAD", "QueueListEntry")
Debugger.Utility.Collections.FromListEntry(@$queue->WorkPriQueue.ThreadListHead, 
    "nt!_KTHREAD", "QueueListEntry")
    [0x0]
[Type: _KTHREAD]
    [0x1]
[Type: _KTHREAD]
    [0x2]
[Type: _KTHREAD]
    [0x3]
[Type: _KTHREAD]
    [0x4]
[Type: _KTHREAD]
    [0x5]
[Type: _KTHREAD]
    [0x6]
[Type: _KTHREAD]
CHAPTER 8 System mechanisms
85
    [0x7]
[Type: _KTHREAD] 
    [0x8]
[Type: _KTHREAD] 
    [0x9]
[Type: _KTHREAD] 
    [0xa]
[Type: _KTHREAD] 
    [0xb]
[Type: _KTHREAD] 
    [0xc]
[Type: _KTHREAD] 
    [0xd]
[Type: _KTHREAD] 
    [0xe]
[Type: _KTHREAD] 
    [0xf]
[Type: _KTHREAD]
That was only the ExPool. Recall that the system also has an IoPool, which would be the next 
index (1) on this NUMA Node (0). You can also continue the experiment by looking at private 
lkd> dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)-> 
    WorkQueues[0][1],d 
((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)-> 
    WorkQueues[0][1],d
: 0xffffa483ede77c50 [Type: _EX_WORK_QUEUE *] 
    [+0x000] WorkPriQueue     [Type: _KPRIQUEUE] 
    [+0x2b0] Partition
: 0xffffa483ede51090 [Type: _EX_PARTITION *] 
    [+0x2b8] Node
: 0xfffff80467f24440 [Type: _ENODE *] 
    [+0x2c0] WorkItemsProcessed : 1844267 [Type: unsigned long] 
    [+0x2c4] WorkItemsProcessedLastPass : 1843485 [Type: unsigned long] 
    [+0x2c8] ThreadCount
: 5 [Type: long] 
    [+0x2cc (30: 0)] MinThreads
: 0 [Type: long] 
    [+0x2cc (31:31)] TryFailed
: 0 [Type: unsigned long] 
    [+0x2d0] MaxThreads
: 4096 [Type: long] 
    [+0x2d4] QueueIndex
: IoPoolUntrusted (1) [Type: _EXQUEUEINDEX] 
    [+0x2d8] AllThreadsExitedEvent : 0x0 [Type: _KEVENT *]
Exception dispatching
In contrast to interrupts, which can occur at any time, exceptions are conditions that result directly from 
the execution of the program that is running. Windows uses a facility known as structured exception 
handling, which allows applications to gain control when exceptions occur. The application can then 
execution of the subroutine that raised the exception), or declare back to the system that the exception 
-
book Windows via C/C++
exception handling is made accessible through language extensions (for example, the __try construct 
-
respond to the entry in the IDT that points to the trap handler for a particular exception. Table 8-12 shows 
used for exceptions, hardware interrupts are assigned entries later in the table, as mentioned earlier.
    [0x7]
[Type: _KTHREAD]
    [0x8]
[Type: _KTHREAD]
    [0x9]
[Type: _KTHREAD]
    [0xa]
[Type: _KTHREAD]
    [0xb]
[Type: _KTHREAD]
    [0xc]
[Type: _KTHREAD]
    [0xd]
[Type: _KTHREAD]
    [0xe]
[Type: _KTHREAD]
    [0xf]
[Type: _KTHREAD]
That was only the ExPool. Recall that the system also has an IoPool, which would be the next 
index (1) on this NUMA Node (0). You can also continue the experiment by looking at private 
lkd> dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)-> 
    WorkQueues[0][1],d
((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&nt!PspSystemPartition)->ExPartition)->
    WorkQueues[0][1],d
: 0xffffa483ede77c50 [Type: _EX_WORK_QUEUE *]
    [+0x000] WorkPriQueue     [Type: _KPRIQUEUE]
    [+0x2b0] Partition
: 0xffffa483ede51090 [Type: _EX_PARTITION *]
    [+0x2b8] Node
: 0xfffff80467f24440 [Type: _ENODE *]
    [+0x2c0] WorkItemsProcessed : 1844267 [Type: unsigned long]
    [+0x2c4] WorkItemsProcessedLastPass : 1843485 [Type: unsigned long]
    [+0x2c8] ThreadCount
: 5 [Type: long]
    [+0x2cc (30: 0)] MinThreads
: 0 [Type: long]
    [+0x2cc (31:31)] TryFailed
: 0 [Type: unsigned long]
    [+0x2d0] MaxThreads
: 4096 [Type: long]