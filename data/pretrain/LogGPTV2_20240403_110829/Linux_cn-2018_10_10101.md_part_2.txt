由于函数调用是非常常见的操作，因此 CPU 设计师一直在努力优化此过程，但他们无法消除开销。
函调固有开销，或重于泰山，或轻于鸿毛，这取决于函数做了什么。
减少函数调用开销的解决方案是  内联   Inlining 。
[![Gocon 2014 (17)](/data/attachment/album/201810/11/150652uuujpp2n2j1aaija.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-17.jpg)
Go 编译器通过将函数体视为调用者的一部分来内联函数。
内联也有成本，它增加了二进制文件大小。
只有当调用开销与函数所做工作关联度的很大时内联才有意义，因此只有简单的函数才能用于内联。
复杂的函数通常不受调用它们的开销所支配，因此不会内联。
[![Gocon 2014 (18)](/data/attachment/album/201810/11/150652lz3rohlo1fwfznre.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-18.jpg)
这个例子显示函数 `Double` 调用 `util.Max`。
为了减少调用 `util.Max` 的开销，编译器可以将 `util.Max` 内联到 `Double` 中，就象这样
[![Gocon 2014 (19)](/data/attachment/album/201810/11/150653t1pqkwl9p3qx715l.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-19.jpg)
内联后不再调用 `util.Max`，但是 `Double` 的行为没有改变。
内联并不是 Go 独有的。几乎每种编译或及时编译的语言都执行此优化。但是 Go 的内联是如何实现的？
Go 实现非常简单。编译包时，会标记任何适合内联的小函数，然后照常编译。
然后函数的源代码和编译后版本都会被存储。
[![Gocon 2014 (20)](/data/attachment/album/201810/11/150654jfib7uow88irskks.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-20.jpg)
此幻灯片显示了 `util.a` 的内容。源代码已经过一些转换，以便编译器更容易快速处理。
当编译器编译 `Double` 时，它看到 `util.Max` 可内联的，并且 `util.Max` 的源代码是可用的。
就会替换原函数中的代码，而不是插入对 `util.Max` 的编译版本的调用。
拥有该函数的源代码可以实现其他优化。
[![Gocon 2014 (21)](/data/attachment/album/201810/11/150654gznekmbrxrznnwvm.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-21.jpg)
在这个例子中，尽管函数 `Test` 总是返回 `false`，但 `Expensive` 在不执行它的情况下无法知道结果。
当 `Test` 被内联时，我们得到这样的东西。
[![Gocon 2014 (22)](/data/attachment/album/201810/11/150655p4unqyhiy4pwly4c.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-22.jpg)
编译器现在知道 `Expensive` 的代码无法访问。
这不仅节省了调用 `Test` 的成本，还节省了编译或运行任何现在无法访问的 `Expensive` 代码。
Go 编译器可以跨文件甚至跨包自动内联函数。还包括从标准库调用的可内联函数的代码。
[![Gocon 2014 (23)](/data/attachment/album/201810/11/150655l55lfealhh5h5he7.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-23.jpg)
 强制垃圾回收   Mandatory Garbage Collection  使 Go 成为一种更简单，更安全的语言。
这并不意味着垃圾回收会使 Go 变慢，或者垃圾回收是程序速度的瓶颈。
这意味着在堆上分配的内存是有代价的。每次 GC 运行时都会花费 CPU 时间，直到释放内存为止。
[![Gocon 2014 (24)](/data/attachment/album/201810/11/150656atntr2lril1luinz.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-24.jpg)
然而，有另一个地方分配内存，那就是栈。
与 C 不同，它强制您选择是否将值通过 `malloc` 将其存储在堆上，还是通过在函数范围内声明将其储存在栈上；Go 实现了一个名为  逃逸分析   Escape Analysis  的优化。
[![Gocon 2014 (25)](/data/attachment/album/201810/11/150657q9km2eddaoo2mss0.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-25.jpg)
逃逸分析决定了对一个值的任何引用是否会从被声明的函数中逃逸。
如果没有引用逃逸，则该值可以安全地存储在栈中。
存储在栈中的值不需要分配或释放。
让我们看一些例子
[![Gocon 2014 (26)](/data/attachment/album/201810/11/150657tujyftyuvvs1yrzy.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-26.jpg)
`Sum` 返回 1 到 100 的整数的和。这是一种相当不寻常的做法，但它说明了逃逸分析的工作原理。
因为切片 `numbers` 仅在 `Sum` 内引用，所以编译器将安排到栈上来存储的 100 个整数，而不是安排到堆上。
没有必要回收 `numbers`，它会在 `Sum` 返回时自动释放。
[![Gocon 2014 (27)](/data/attachment/album/201810/11/150658s5t7pmtzjxchjtm4.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-27.jpg)
第二个例子也有点尬。在 `CenterCursor` 中，我们创建一个新的 `Cursor` 对象并在 `c` 中存储指向它的指针。
然后我们将 `c` 传递给 `Center()` 函数，它将 `Cursor` 移动到屏幕的中心。
最后我们打印出那个 ‘Cursor` 的 X 和 Y 坐标。
即使 `c` 被 `new` 函数分配了空间，它也不会存储在堆上，因为没有引用 `c` 的变量逃逸 `CenterCursor` 函数。
[![Gocon 2014 (28)](/data/attachment/album/201810/11/150659rpjcxvtppaqpffpa.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-28.jpg)
默认情况下，Go 的优化始终处于启用状态。可以使用 `-gcflags = -m` 开关查看编译器的逃逸分析和内联决策。
因为逃逸分析是在编译时执行的，而不是运行时，所以无论垃圾回收的效率如何，栈分配总是比堆分配快。
我将在本演讲的其余部分详细讨论栈。
[![Gocon 2014 (30)](/data/attachment/album/201810/11/150659yks7u1k7umjmqluk.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-30.jpg)
Go 有 goroutine。 这是 Go 并发的基石。
我想退一步，探索 goroutine 的历史。
最初，计算机一次运行一个进程。在 60 年代，多进程或  分时   Time Sharing  的想法变得流行起来。
在分时系统中，操作系统必须通过保护当前进程的现场，然后恢复另一个进程的现场，不断地在这些进程之间切换 CPU 的注意力。
这称为 进程切换。
[![Gocon 2014 (29)](/data/attachment/album/201810/11/150700qhz95mv7jzjimb69.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-29.jpg)
进程切换有三个主要开销。
首先，内核需要保护该进程的所有 CPU 寄存器的现场，然后恢复另一个进程的现场。
内核还需要将 CPU 的映射从虚拟内存刷新到物理内存，因为这些映射仅对当前进程有效。
最后是操作系统  上下文切换   Context Switch  的成本，以及  调度函数   Scheduler Function  选择占用 CPU 的下一个进程的开销。
[![Gocon 2014 (31)](/data/attachment/album/201810/11/150701xy6za0cvfk6yy3wb.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-31.jpg)
现代处理器中有数量惊人的寄存器。我很难在一张幻灯片上排开它们，这可以让你知道保护和恢复它们需要多少时间。
由于进程切换可以在进程执行的任何时刻发生，因此操作系统需要存储所有寄存器的内容，因为它不知道当前正在使用哪些寄存器。
[![Gocon 2014 (32)](/data/attachment/album/201810/11/150702fxfxxffyfevrnr56.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-32.jpg)
这导致了线程的出生，这些线程在概念上与进程相同，但共享相同的内存空间。
由于线程共享地址空间，因此它们比进程更轻，因此创建速度更快，切换速度更快。
[![Gocon 2014 (33)](/data/attachment/album/201810/11/150702ca7lvt23h6vuhs22.jpg)](https://dave.cheney.net/wp-content/uploads/2014/06/Gocon-2014-33.jpg)
Goroutine 升华了线程的思想。
Goroutine 是  协作式调度   Cooperative Scheduled   的，而不是依靠内核来调度。
当对 Go  运行时调度器   Runtime Scheduler  进行显式调用时，goroutine 之间的切换仅发生在明确定义的点上。
编译器知道正在使用的寄存器并自动保存它们。