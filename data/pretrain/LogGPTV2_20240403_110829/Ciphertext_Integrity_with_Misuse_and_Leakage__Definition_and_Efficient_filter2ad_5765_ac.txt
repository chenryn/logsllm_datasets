cannot just ignore that leakage, as removing it would make
it trivial for the adversary to distinguish the real world with
leakages, from the random/ideal world.
In this context, one tempting solution is to posit that
leakages can be simulated, namely, that there would be a
leakage simulator that, given a pair (ğ¼ğ‘‰, ğ‘š) and the random
output of the $(ğ¼ğ‘‰, ğ‘š) oracle, can produce a leakage that
is indistinguishable from the one produced during the real
encryption. This would somehow assume that leakages are
zero-knowledge functions.
Such an assumption about leakages has been proposed
by Standaert et al. [43], and variants have been explored
by Fuller and Hamlin [21]. Informally, the implementation
of a block cipher is said to have ğ‘-simulatable leakages if it
is possible to simulate the leakages of this implementation,
given public inputs and outputs but no key, for at most ğ‘
evaluations of this block cipher with any key.
It is well known that such an assumption can only be
fulfilled under strong restrictions. Indeed, a side-channel
attack typically reduces the computational secrecy of the
state manipulated by a device at a rate that is exponential
in the number of leakages. In this context, the only hope to
have simulatable leakages is to strongly limit their number
(typically, ğ‘ = 2) and to make them noisy. As discussed
in [27], even simulating a small number of noisy leakages is
difficult. Hence, assuming simulatability without such strong
restrictions appears to be completely unrealistic.
Still, this is exactly what the context of MR would require:
given that the adversary is in control of the ğ¼ğ‘‰ , nothing
prevents him from querying the EncL oracle with a single
(ğ¼ğ‘‰, ğ‘š) pair as many times as desired, precisely in order
to be able to remove all the noise of the leakages (through
averaging), opening the door to attacks such as described
in [8]. (In Section 7, we will analyze the LR CPA security of
our schemes using the assumption of 2-simulatable leakages.
The crucial difference, there, is that the adversary will not
be in control of the ğ¼ğ‘‰ anymore, which will make averaging
strategies fail as long as there is no ğ¼ğ‘‰ collision.)
As a result of this central difficulty coming from MR, we
need to adopt a different approach, one that would not in-
clude any requirement of random-looking ciphertexts. To this
purpose, we turn back to the standard security requirements
of AE schemes (without misuse), of which one formulation
is the combination of ciphertext integrity (INT-CTXT) and
indistinguishability under CPA [9].
CIML security. We propose a notion of ciphertext integrity
in the presence of misuse and leakages. The traditional INT-
CTXT property requires that an adversary, who can query
an encryption oracle on chosen messages, is unable to pro-
duce a ciphertext that is different from those received from
the encryption oracle, but would still pass the decryption
algorithm without error.
Asking that this property remains satisfied in the presence
of IV misuse can be expressed, by letting the adversary select
the ğ¼ğ‘‰ â€™s that are submitted to the encryption oracle. And
capturing encryption leakages can be expressed by letting
the encryption oracle return the leakage corresponding to the
encryption that is performed. This results in the following
security definition.
Definition 3.1. An authenticated encryption AE with en-
cryption leakage function L provides (ğ‘, ğ‘¡, ğœ–)-ciphertext in-
tegrity with coin misuse and leakage on encryption if for all
(ğ‘, ğ‘¡)-bounded adversaries ğ’œ, we have
Pr [CIMLAE,L,ğ’œ â‡’ 1] â‰¤ ğœ–.
As usual, ğ‘ is an upper bound on the total number of queries
made to oracles.
CIMLAE,L,ğ’œ experiment
Initialization:
Finalization:
ğ‘˜ $â† ğ’¦
ğ’® â† âˆ…
ğ¶ â† ğ’œEncLğ‘˜(Â·,Â·),Decğ‘˜(Â·)
If ğ¶ âˆˆ ğ’®, return âŠ¥
If âŠ¥ = Decğ‘˜(ğ¶), re-
turn âŠ¥
return 1
Oracle EncLğ‘˜(ğ‘Ÿ, ğ‘š):
ğ¶ = Encğ‘˜(ğ‘Ÿ, ğ‘š)
ğ’® â† ğ’® âˆª {ğ¶}
return (ğ¶, L(ğ‘Ÿ, ğ‘š; ğ‘˜))
Oracle ğ’ªDecğ‘˜(ğ¶):
return Decğ‘˜(ğ¶)
Conferenceâ€™17, July 2017, Washington, DC, USA
As for LR CPA security, we will simply use the LMCPA
security notion already defined in [37]. We defer the treatment
of this second security goal to Section 7.
4 PREVIOUSLY PROPOSED
CONSTRUCTIONS
In this section, we review some constructions of MR AE
schemes, and explain how they would fail to offer CIML
security.
Rather than focusing on a specific type of leakage functions
(bounded leakages, indistinguishable leakages, simulatable
leakages, hard to invert leakages, . . . ) [21] that would require
much formalism, we explain how practical side-channel at-
tacks could be mounted against these schemes, focusing on
two standard attack methods: simple power analysis (SPA)
and differential power analysis (DPA). Informally, DPAs are
the most commonly exploited side-channel attacks and take
advantage of the leakage about a secret from a computa-
tion based on multiple (different) inputs [30]. They reduce
the computational secrecy of the state manipulated by a
device at a rate that is exponential in the number of leak-
ages, by combining the information of these different inputs
(e.g., plaintexts). SPAs are side-channel attacks taking ad-
vantage of the leakage of a single input, possibly measured
multiple times to reduce the measurement noise, e.g., by
exploiting powerful (yet less practical) algebraic/analytical
techniques [44].
We also consider that the adversary is in possession of a
copy of the targeted device, which he can feed with any choice
of plaintexts and keys in order to obtain outputs and leakages.
This is traditionally used for profiling (i.e., learning how to
interpret leakages) [15], but can also be used for efficient
matching attacks. Indeed, even if it is sometimes difficult to
extract a secret key from a power consumption trace (which
can take gigabytes of data for the encryption of a single
message block), it is typically easier to recognize whether a
candidate secret is correct, by matching the leakage from
the attacked device and the one obtained from the training
device when fed with the candidate values [43]. Note that the
latter can be viewed as a type of SPA with (much) simplified
adversarial goal.
Summarizing, whenever a DPA is possible, it is the most
devastating attack due to the exponentional rate at which
it reduces the secrecy of the device state. When only SPA
is possible, key extraction is more challenging than leakage
matching, and the difference will be especially large when
the noise is the measurements is limited.
4.1 The SIV construction
The SIV construction was introduced by Rogaway and Shrimp-
ton [42] and is a popular approch for the construction of MR
AE schemes. Encryption proceeds by applying a PRF (with
a first key ğ‘˜1) to the message (and to the associated data,
if there are some) in order to obtain an ğ¼ğ‘‰ , and using this
ğ¼ğ‘‰ as input to an IV-based encryption scheme, which uses a
second key ğ‘˜2 and returns a ciphertext ğ‘. The output is then
Francesco Berti, FranÂ¸cois Koeune, Olivier Pereira,
Thomas Peters, FranÂ¸cois-Xavier Standaert.
the (ğ¼ğ‘‰, ğ‘) pair. This construction has been instantiated into
the SIV and GCM-SIV modes for example [23, 42]. These
two instances offer the same angle of attack.
First, a DPA is used to recover ğ‘˜1. It is fairly easy on
these schemes, because the constant value ğ‘˜1 is used on each
block of each message that is encrypted, and these blocks are
adversarially chosen.
Then, based on ğ‘˜1, it is possible to use the properties of
the underlying PRF (or universal hash function in the case
of GCM-SIV) to build two messages ğ‘š, ğ‘š* that have the
same ğ¼ğ‘‰ . In the case of SIV, the PRF is CMAC, a close
variant of CBC MAC. Simply put, if we have a message
ğ‘š = (ğ‘š1â€–Â·Â·Â·â€–ğ‘šâ„“) made of â„“ full blocks, a block ğ‘š0 is set
to 0ğ‘›, tags ğ‘¡1, . . . , ğ‘¡â„“ are computed as ğ‘¡ğ‘– = ğ¹ğ‘˜1 (ğ‘šğ‘– âŠ• ğ‘¡ğ‘–âˆ’1),
and the output is ğ¼ğ‘‰ = ğ‘¡â„“. Now, if ğ‘˜1 has been obtained
through DPA, we can modify the ğ‘–-th block into ğ‘šâ€²
ğ‘–, compute
the updated value ğ‘¡â€²
ğ‘–+1 as
ğ‘šğ‘–+1 âŠ• ğ‘¡ğ‘– âŠ• ğ‘¡â€²
ğ‘–+1 = ğ‘¡ğ‘–+1, and so
on for all the next tags. A similar process can be applied to
GCM-SIV, which uses the GHASH universal hash function
instead of CMAC.
ğ‘–, and adjust the ğ‘– + 1-th block ğ‘šâ€²
ğ‘–, which will guarantee that ğ‘¡â€²
Eventually, since both SIV and GCM-SIV use the counter
mode for their IV-based encryption part, we can adapt a
ciphertext (ğ¼ğ‘‰, ğ‘) encrypting ğ‘š into a different ciphertext
(ğ¼ğ‘‰, ğ‘ âŠ• ğ‘š âŠ• ğ‘š*) that decrypts to ğ‘š*, hence breaking CIML
security.
As for LR CPA security, similar issues show up. Indeed, as
soon as ğ‘˜1 has been recovered by DPA, a leakage matching
attack is easy to mount on the test query. Indeed, when the
adversary asks to encrypt one message out of ğ‘š0 and ğ‘š1
and receives an encryption of ğ‘šğ‘ (for a random ğ‘) together
with the corresponding leakage, the adversary can use his
own device to produce the leakages corresponding to the
evaluation of the PRF on ğ‘š0 and ğ‘š1: he can do so because
he knows ğ‘˜1. Then, he can compare these two leakages with
the one received from his test query, and decide which is the
correct one.
This strategy works even when nonce-based variants of
these schemes are used, as the nonces are always returned as
part of the ciphertext, and the adversary can therefore use
them as part of his leakage matching attack.
These attacks are made easy through two main aspects:
(1) Long term keys are reused on each message block, which
supports DPA attacks. This can be avoided by using
LR operation modes, which use re-keying strategies to
limit the number of leakages on any specific secret.
(2) Keyed functions are applied to values that are known to
the adversary, which makes leakage matching attacks
easy.
These suggests important ingredients for the design of CIML
secure schemes.
4.2 Combining LR MAC and encryption
modes
Given that the LR part is problematic in the MR AE con-
structions described above, one could be tempted to build
Ciphertext Integrity with Misuse and Leakage
Conferenceâ€™17, July 2017, Washington, DC, USA
CIML secure schemes in the opposite direction, that is start-
ing from LR primitives and turning them into a MR AE
scheme, in the hope that CIML security will follow.
This is however not necessarily the case, as we demonstrate
now from the combination of recent constructions of LR
MACs and encryption schemes from Pereira et al. [37], which
we call PSV-MAC and PSV-ENC.
PSV-MAC and PSV-ENC are based on two block-ciphers
F and F*, with the distinction that F is assumed to be cheap
and efficiently implemented but leaking, while F* is assumed
to be an expensive (in terms of power and speed), heavily
protected, and leak-free component. In other words, formally
F* is just a standard PRP without leakage while F is a leaking
PRP. The purpose of this distinction is to design schemes
that make minimal use of the expensive F*: one or two calls
per message to be encrypted, independently of the number
of blocks of the message, while the bulk of the computation
is performed by the cheap F.
We note that making a distinction between F and F* would
make little sense in the case of the SIV constructions above,
because all message blocks are treated with the long-term
keys, so that it would only be helpful to process all blocks
using the expensive F*.
as follows if ğ‘š = ğ‘š1â€–Â·Â·Â·â€–ğ‘šâ„“:
PSV-MACğ‘˜(ğ¼ğ‘‰, ğ‘š) is an IV-based MAC, and is evaluated
âˆ™ ğ‘˜0 â† F*
ğ‘˜(ğ¼ğ‘‰ )
âˆ™ ğ‘˜ğ‘– â† Fğ‘˜ğ‘–âˆ’1 (ğ‘šğ‘–), âˆ€ğ‘– âˆˆ [1, â„“]
âˆ™ return ğœ â† ğ‘˜â„“
Vrfyğ‘˜(ğ¼ğ‘‰, ğ‘š, ğœ ) proceeds in the natural way.
PSV-ENC is an IV-based encryption scheme, which we
will be using in the next sections as well. Its description is
available in Figure 1.
PSV-ENC
Encğ‘˜(ğ¼ğ‘‰, ğ‘š), where ğ‘š = ğ‘š1â€–Â·Â·Â·â€–ğ‘šâ„“
ğ‘˜(ğ¼ğ‘‰ )
1. ğ‘˜0 â† F*
2. âˆ€ğ‘– âˆˆ [1, â„“] : ğ‘˜ğ‘– â† Fğ‘˜ğ‘–âˆ’1 (ğ‘ğ´), ğ‘¦ğ‘– â† Fğ‘˜ğ‘–âˆ’1 (ğ‘ğµ),
ğ‘ğ‘– â† ğ‘¦ğ‘–âŠ•ğ‘šğ‘–, where ğ‘ğ´, ğ‘ğµ are public and distinct
constants
3. return ğ¶ = ğ‘1||ğ‘2||Â·Â·Â·||ğ‘â„“
Decğ‘˜(ğ¼ğ‘‰, ğ¶) proceeds in the natural way
Figure 1: The PSV-ENC encryption scheme.
Based on our findings in the analysis of SIV, we build
our MR AE scheme using a slightly different construction,