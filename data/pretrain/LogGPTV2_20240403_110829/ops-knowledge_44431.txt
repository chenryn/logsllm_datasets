User: 请回答以下安全问题我的开发人员的homebrew密码安全性是对是错，为什么？一位开发人员，我们称他为“Dave”，坚持使用自制脚本来实现密码安全。见下面Dave的提议。
他的团队花了几个月的时间采用了使用Bcrypt的行业标准协议。该协议中的软件和方法并不是新的，而是基于支持数百万用户的久经考验的实现。该协议是一组规范，详细说明了当前的技术状态、使用的软件组件以及它们应该如何实现。该实施基于已知的良好实施。
戴夫从第一天起就反对这项协议。他的理由是，像Bcrypt这样的算法，因为它们已经发布，所以对黑客的可见性更高，更有可能成为攻击的目标。他还认为该协议本身过于庞大，难以维护，但我认为Dave的主要问题是Bcrypt已经发布。
我希望通过在这里分享他的代码来达成共识：
为什么自制啤酒不是一个好主意，以及
他的剧本到底出了什么问题
/**Dave's自制哈希*/
//用户数据
$user=''；
$密码=“”；
//时间戳，随机#
$time=日期（'mdYHis'）；
$rand=mt_rand（）。'\n’；
//地下室
$crypt=密码（$user.$time.$rand）；
//散列
函数hash_it（$string1，$string2）{
$pass=md5（$string1）；
$nt=子字符串（$pass，0.8）；
$th=子字符串（$pass，8,8）；
$ur=子字符串（$pass，16,8）；
$ps=子字符串（$pass，24,8）；
$hash='H'.sha1（$string2.$ps.$ur.$nt.$th）；
返回$hash
}
$hash=hash_it（$password，$crypt）；

Assistant: /**Dave的自制哈希^H^H^H^H^H有点愚蠢的算法*/
//用户数据
$user=''；
$密码=“”；
//时间戳，“随机”#
$time=日期（'mdYHis'）；//攻击者知道——完全没有意义
//同样，正如jdm在评论中指出的，这种情况每天都在变化。看起来坏了！
//不同的日子有不同的话题？嗯？或者这是作为盐储存的？
$rand=mt_rand（）。'\n’；//mt_rand作为随机数生成器是不安全的
//^如果你只要求一个31位的数字，那就更不安全了。为什么？
//如果配置/腌制正确，crypt就很好
//。。。除了你在用户名上使用过crypt？重量百分比。
$crypt=密码（$user.$time.$rand）；
//散列
函数hash_it（$string1，$string2）{
$pass=md5（$string1）；//当crypt可用时，为什么我们使用相同的MD5密码？
$nt=子字符串（$pass，0.8）；//&lt；---坏坏坏-为什么要打乱MD5哈希？！？！？
$th=子字符串（$pass，8,8）；
$ur=子字符串（$pass，16,8）；
$ps=子字符串（$pass，24,8）；//认真地我不知道。为什么？
//^shuffling带来_zero_额外的安全性。这样做毫无意义。
//另外，变量名是怎么回事？
//现在我们也和其他垃圾一起分享？wtf？
$hash='H'.sha1（$string2.$ps.$ur.$nt.$th）；
返回$hash
}
$hash=hash_it（$password，$crypt）；//。。。请停下来。它伤了我的头。
调用_ thulhu（）；
戴夫，你不是密码学家。住手。
这种自制方法对暴力攻击没有真正的抵抗力，给人一种“复杂”安全的错误印象。事实上，你所做的只是sha1（md5（pass）+salt），可能是一个破碎且过于复杂的散列。您似乎有一种错觉，认为复杂的代码可以提供更好的安全性，但事实并非如此。无论攻击者是否知道算法，强密码系统都是强的——这一事实被称为Kerckhoff原理。我意识到，重新发明轮子并以自己的方式完成它很有趣，但你正在编写进入业务关键型应用的代码，该应用必须保护客户凭据。你有责任正确地做这件事。
坚持使用PBKDF2或bcrypt等久经考验的密钥推导算法，这些算法经过了专业和业余密码学家多年的深入分析和审查。
如果你想在正确的密码存储上接受良好的教育，请查看以下链接：
如何储存盐？
有安全专家建议使用bcrypt存储密码吗？
如何安全地存储密码？