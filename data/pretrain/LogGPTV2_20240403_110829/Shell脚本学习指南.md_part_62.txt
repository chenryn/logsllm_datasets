while ((getline 1ise  0)
sub(* *#.*$*, **, line)
截去前置空白字符
截去注释
+[2\]}qns
*", line)
www.TopSage.com
---
## Page 369
拼写检查
357
sub（*[\t]+$*，，1ine）截去结尾空白字符
if (line -- **)
n • split (line, parts)
continue
Suffixes[parts[1]]++
Replacement [parts[1]]= parts [2]
for （k =3;k  0) && (ARGV[ARGC-1] = **))
ARGC--
function spel1_check_1ine(
k, word)
gsub(NonHordChars,**)
for (k = 1; k <= NF; k++)
消除非单词字符
word = Sk
sub(*^'+*,
**,word)
截去前置的撤号字符
sub(**+$*,**，word）
if (word 1= **)
截去结尾的撤号字符
function spel1_check_word (word,
key, 1c_word, location, v, wordlist)
if (le_word in Dictionary)
1c_word = tolower(word)
可接受的拼写
return
else
可能的异常
if (strip)
strip_suffixes (1c_word, wordlist)
for (w in wordlist)
If (v in Dictionary)
return
if (1c_word in Exception)
Exception[1c_mord] - Exception[1c_word] *\n* 1ocation word
else
www.TopSage.com
---
## Page 371
拼写检查
359
Exception [lc_word] = locaticn vord
function strip_suffixes (word, vordlist,
ending, k, n, regexp)
split(**, vordliat)
for (k = 1; K <= NOrderedSuffix; k++)
regexp = OrderedSut[ix[x]
if (match(word, regexp))
word = substr (word, 1, R5TART - 1)
if (Replacement [regexp]s **)
else
wordlist[word] = 1
sp1it (Replacement [regexp] , ending)
for (n in ending)
if (ending[n]  *\*\**)
vordlist [word ending[n]] = 1
ending [n] = *a
oreak
function swap(a, i. j.
temp)
tenp = a[1]
a[5] = teep
a[5] = a[5]
12.4.13回顾拼写检查程序
UNIX拼写检查程序第一版所使用的就是我们在本章一开始所呈现的管道处理。在文件
TheUNIXHeritageSociety（注7）中，可以找到第一版以C写成的UNIX拼写程序，
此即为1975Version6UNIX的typo命令，约为350行的C代码，spel1首次出现是
在1979 Version 7 UNIX版本，大约 700 行的C代码。spe11在1995 4.4 BSD-Lite 的
源代码版本中遗删除，推测可能是因为商业机密或者版权上的问题。
现代的OpenBSDspe11约有1100行C代码，在它的三个基本字典中各有30多个单词。
注7：
见 http://www.tahs.org/.
www.TopSage.com
---
## Page 372
360
第12章
GNUspel1版本3.2约为13500行的C代码，及GNU的aspel1版本0.60则约为29500
行的C++与C代码。这两个程序都已国际化，都附有10至40种语言的字典。ispe11
拥有相当大的英文字典，约80000个一般单词，搭配3750个左右美语与英语的变化体。
aspe11字典就更大了：142000个英文单词，辅以4200个来自美国、英国与加拿大语
系的变体。
我们的拼写检查程序sDe11，awk是一个真正卓越的程序，你会觉得幸好有它，如果你
重新以其他程序语言编写这样的程序，就会了解awk真的比较好，就如同Johnson在1975
年的原始spe11命令，我们的设计与实例不到一个下午就完成。
约190行代码，搭配三组模式/操作的单命令行程序与11个函数，它能微到传统UNIX
的spel1能做的所有事，甚至更多：
·具有-Verbose选项，程序会报告拼写异常的位置信息。
用户可控制字典，让程序可立即应用于复杂的技术文件及以英文以外的语言所写成
的文章上。
用户可定义后缓列表，有助于拼写检查国际化，以及提供用户控制后缓缩减，就像
所有平台都提供的一些拼写检查程序一样。
所有相关联的字典与后缓文件都为简单的文本文件，可使用任何文本编辑器修改，
且大部分UNIX文本工具都能处理。部分拼写检查程序仍保留二进制形式的字典文
件，这会使单词列表难以检阅、维护与更新，也很难再用作其他目的。
主要依赖字符集的是，这是低于128以下的ASCII顺序的初始化假设。尽管不再支
持IBM大型主机EBCDIC，European8-bit字符集也不会带来什么间题，甚至以多
字节UTF-8编码的两百万字符Unicode字集也可适当处理它，但要确切认知与删除
非ASCIIUnicode的标点符号仍需多费心思。由于多字节字符集的复杂性，且可能
在任何地方都需要用到，这部分的功能应另以独立工具实现，作为使用spel1.awk
前的预先过滤程序。
输出排序的顺序，对某些语言来说是个复杂议题，这个操作完全由sort命令决定，
面该命令又受当前环境的locale设置所影响，最好的情况就是；某个独立工具本地
化处理排序的复杂问题，这么一来其他软件，包括我们的程序，便无须理会这个争
议了。这也就是我们在1.2节里所说的：“让别人去做困难的部分”。
虽然是以解释式语言编写，我们的程序算是相当快的了。在2GHzPentium4的
工作站上，使用mawk，它只需要一秒便能检查本书所有文件的拼写，时间仅为
OpenBSD 的 spe11 的 1.3 倍及 GNU ipse11 的 2.0 倍。
以执行上的概况来看（见12.4.14节），载人字典需花费总时间的5%，而每15个单
www.TopSage.com
---
## Page 373
h
拼写检查
词就有一个在字典上找不到。加人-strip选项会增加约25%的执行期及减少相同
量的输出大小。每70个单词里有一个通过strip_suffixes（）里的match（）测试。
后缓支持在这190行的代码里约占去90，所以我们可以说，写这个方便好用的多语
言拼写检查程序大约只用了100行的awk代码。
上述特性列表以及我们的程序，最明显缺乏的功能就是截去文件标记（markup），有些
拼写检查提供此功能。我们故意不这么做，是因为它完全违背了UNIX的传统：一个（小）
工具只做一件事。标记删除其实是很有用的，所以值得另写一个独立的过滤程序，例如
dehtml、deroff、desgml、detex以及dexml，这之中，只有deroff在大部分UNIX
系统下我得到，不过其他的实现也只要儿行awk就办得到。
撤开三个简单的substr（）调用不谈，我们的程序另缺的就是独立字符的处理。在C里
这类处理的需求，很多其他语言也是，正是主要的bug来源。
该程序只剩这些事待完成：累积适当数量的字典集与其他语言的后级列表，通过Shell脚
本包装（wrapper）的提供，让它的用户界面看起来更像传统的UNIX程序，还有编写手
册页。虽然我们在这里没有将它们呈现出来，不过本书范例程序已提供包装程序与手册
页。
12.4.14awk程序的性能
我们以几个与awk程序性能有关的评论作总结，awk程序就像其他脚本语言，先被编译
为简洁的内部表示，再将该表示在执行期时，通过小型虚拟机器（virtualmachine）解
释。内置函数是以底层实现语言写成，现行的C为通用版本，执行速度等同于本地软件
的速度。
程序的性能不单单指计算机上的时间，人们花在上头的时间也算，如果是花一个小时，
以awk写一个只要执行几秒的程序，相对于以编译语言花数个小时编写、调试所写成的
相同程序，结果只是少几秒的执行期，那么人们花在上头的时间就是性能的重点考虑了。
对许多软件工具面言，awk赢在它有大量的手段与方法足以完成任务。
传统像是Fortran与C这类的编译语言，内层代码会与底层机器语言息息相关，程序设
计老手们马上感觉得到敦优熟劣。算法与内存操作的数量、循环嵌套设计有多深，都为
重点，且易于计算，并与执行期直接相关。以数字方面的程序为例，一般法则是代码的
10%，耗费90%的执行期：而这10%的代码就称为热点（hotspot）.像是将最内部循
环的常用表达式拉出来，还有重新排列运算以符合存健配置等，这些最佳化的操作，有
时可大大促进执行时间。然而，高级语言、使用大量函数调用的语言（例如Lisp，它的
每条语句都是函数）或解释式语言，它们的执行期都较难以估算，也很难识别出它们的
热点。
www.TopSage.com
---
## Page 374
362
第12章
做许多模式匹配的awk程序，通常也被该运算的复杂度所限制，其完全是以原始的递度
执行。这类程序很少能够通过编译程序，像C或C++的重写，再做点什么改善。我们所
提及的三种awk实例，都各自独立编写面成，且对于特定语句，也有完金不同的执行时
间。
由于我们使用awk写了很多软件工具，有部分用以处理动辑以GB计的数据，执行期性
能对我们来说有时是相当重要的。几年前，我们之中有人（NHFB）想做的是pawk
（注8），它其实是最小型的实例，nawk的探测版。pawk会报告语句计数与时间，我们
其他人（AR），也自动自发将类似的语句计数支持加人到GNU的gawk，因此，Dgawk
已自3.1.0版开始成为标准配备。pgawk会产生输出探测（profile）至awkprof.out，
再搭配带有语句执行计数评注的程序列表。计数很快便会识别出热点。计数为零（或空）
即表示代码完全未执行，所以输出探测还可以当作测试涵盖范围（testcoverage）的报
告。当测试文件是用以验证所有程序语句是否在检测期间都被执行时，这样的报告就很
重要了：潜藏于代码中的bug可能很少或甚至从未执行过。
精准的执行时间是很难取得的，因为典型的CPU计时器（timer）仅能得到每秒60到100
次的核对，这在GHz处理器的时代完全不够用。幸好，已有部分UNIX系统提供低成本
的十亿分之一秒解析计时器，而pawk在这些平台上都使用它们，
12.5小结
原始的拼写检查维型，展现了UNIX软件工具应用的优雅与能力。只花一个下午的时间，
就能做出这样一个方便又有用的单一目的程序。在体验过以Shell写成的维型后，再以
C重写一份在线版本也是常有的事。
私有字典的使用，是UNIXspell里一个强而有力的功能，虽然UNIX环境后台下的locale
设置，很可能导出奇怪的行为模式，但字典的使用仍有其价值，事实上本书的各个章节，
我们都建立了私有字典，以便管理拼写检查的工作，
可自由取用的ispel1与aspel1程序相当大，功能也很强，但却缺乏一些让批处理模式
更好用的功能。我们展示过如何封装简单的Shell脚本，所以我们可以解决这样的不足，
让程序更适于我们的需求。此是Sbell脚本的最传统用法：取一个几乎能完成所有所需
工作的程序，然后稍微修改它的结果，以完成剩下的工作，这也符合我们在软件工具设
计原则里所说的：“让别人完成围难的部分”。
最后，awk拼写检查程序完美展现了该语言的优雅与强大功能。就在某个午后，NHFB
完成了低于200行，可以（已经是）正式使用于拼写检查的程序。
注 8:可在hrtp://www.math.utah.edu/pub/pawk/取得。
www.TopSage.com
---
## Page 375