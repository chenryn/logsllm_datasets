数组方法有很多，下面我们将选取最常用的几种方法，并把具有相同功能的方法归纳在一起来分别加以介绍。
**为数组添加元素**
- `a.unshift (item)`
    将 item 元素添加到数组的开头。
    ```ruby
    a = [1, 2, 3, 4, 5]
    a.unshift(0)
    p a    #=> [0, 1, 2, 3, 4, 5]
    ```
- `a  [1, 2, 3, 4, 5, 6]
    ```
- `a.concat (b)`
- `a + b`
    连接数组 a 和数组 b。`concat` 是具有破坏性的方法，而 `+` 则会根据原来的数组元素创建新的数组。
    ```ruby
    a = [1, 2, 3, 4, 5]
    a.concat([8, 9])
    p a    #=> [1, 2, 3, 4, 5, 8, 9]
    ```
- `a [n] = item`
- `a [n..m] = item`
- `a [n, len] = item`
    把数组 a 指定的部分的元素替换为 item。
    ```ruby
    a = [1, 2, 3, 4, 5, 6, 7, 8]
    a[2..4] = 0
    p a    #=> [1, 2, 0, 6, 7, 8]
    a[1, 3] = 9
    p a    #=> [1, 9, 7, 8]
    ```
**具有破坏性的方法**
像 `pop` 方法、`shift` 方法那样，会改变接收者对象值的方法称为具有破坏性的方法。在使用具有破坏性的方法时需要特别小心，因为当有变量也引用了接收者对象时，如果接受者对象值发生了改变，变量值也会随之发生变化。我们来看看下面的例子。
```ruby
a = [1, 2, 3, 4]
b = a
p b.pop    #=> 4
p b        #=> [1, 2, 3]
p a        #=> [1, 2, 3]
```
执行 `pop` 方法删除元素后，变量 `a` 引用的数组的元素也被删除，从 `[1, 2, 3, 4]` 变为了 `[1, 2, 3]`，同时变量 `b` 引用的数组元素也被删除了。这是由于执行 `b = a` 后，并不是将变量 `a` 的内容复制给了变量 `b`，而是让变量 `b` 和变量 `a` 同时引用了一个对象。
在 Ruby 的方法中，有像 `sort` 和 `sort!` 这样，在相同方法名后加上 `!` 的方法。为了区分方法是否具有破坏性，在具有破坏性的方法末尾添加 `!` 这一做法目前已经成为了通用的规则。
**从数组中删除元素**
根据某些条件从数组中删除元素。
- `a.compact`
- `a.compact!`
    从数组 a 中删除所有 `nil` 元素。`compact` 方法会返回新的数组，`compact!` 则直接替换原来的数组。`compact!` 方法返回的是删除 `nil` 元素后的 `a`，但是如果什么都没有删除的话就会返回 `nil`。
    ```ruby
    a = [1, nil, 3, nil, nil]
    a.compact!
    p a    #=> [1, 3]
    ```
- `a.delete(x)`
    从数组 a 中删除 x 元素。
    ```ruby
    a = [1, 2, 3, 2, 1]
    a.delete(2)
    p a #=> [1, 3, 1]
    ```
- `a.delete_at(n)`
    从数组中删除 a[n] 元素。
    ```ruby
    a = [1, 2, 3, 4, 5]
    a.delete_at(2)
    p a    #=> [1, 2, 4, 5]
    ```
- `a.delete_if{|item| … }`
- `a.reject{|item| … }`
- `a.reject!{|item| … }`
    判断数组 a 中的各元素 item，如果块的执行结果为真，则从数组 a 中删除 item。`delete_if` 和 `reject!` 方法都是具有破坏性的方法。
    ```ruby
    a = [1, 2, 3, 4, 5]
    a.delete_if{|i| i > 3}
    p a    #=> [1, 2, 3]
    ```
- `a.slice!(n)`
- `a.slice!(n..m)`
- `a.slice!(n, len)`
    删除数组 a 中指定的部分，并返回删除部分的值。`slice!` 是具有破坏性的方法。
    ```ruby
    a = [1, 2, 3, 4, 5]
    p a.slice!(1, 2)    #=> [2, 3]
    p a                 #=> [1, 4, 5]
    ```
- `a.uniq`
- `a.uniq!`
    删除数组 a 中重复的元素。`uniq!` 是具有破坏性的方法。
    ```ruby
    a = [1, 2, 3, 4, 3, 2, 1]
    a.uniq!
    p a    #=> [1, 2, 3, 4]
    ```
- `a.shift`
    删除数组 a 开头的元素，并返回删除的值。
    ```ruby
    a = [1, 2, 3, 4, 5]
    a.shift    #=> 1
    p a        #=> [2, 3, 4, 5]
    ```
- `a.pop`
    删除数组 a 末尾的元素，并返回删除的值。
    ```ruby
    a = [1, 2, 3, 4, 5]
    a.pop    #=> 5
    p a      #=> [1, 2, 3, 4]
    ```
**替换数组元素**
将数组元素替换为别的元素的方法中，也分为带 `!` 的和不带 `!` 的方法，前者是具有破坏性的会改变接收者对象值的方法，后者则是直接返回新数组的方法。
- `a.collect{|item| … }`
- `a.collect!{|item| … }`
- `a.map{|item| … }`
- `a.map!{|item| … }`
    将数组 a 的各元素 item 传给块，并用块处理过的结果创建新的数组。从结果来看，数组的元素个数虽然不变，但由于经过了块处理，因此数组的元素和之前会不一样。
    ```ruby
    a = [1, 2, 3, 4, 5]
    a.collect!{|item| item * 2}
    p a    #=> [2, 4, 6, 8, 10]
    ```
- `a.fill(value)`
- `a.fill(value, begin)`
- `a.fill(value, begin, len)`
- `a.fill(value, n..m)`
    将数组 a 的元素替换为 value。参数为一个时，数组 a 的所有元素值都会变为 value。参数为两个时，从 begin 到数组末尾的元素值都会变为 value。参数为三个时，从 begin 开始 len 个元素的值会变为 value。另外，当第 2 个参数指定为 [n..m] 时，则指定范围内的元素值都会变为 value。
    ```ruby
    p [1, 2, 3, 4, 5].fill(0)        #=> [0, 0, 0, 0 ,0]
    p [1, 2, 3, 4, 5].fill(0, 2)     #=> [1, 2, 0, 0, 0]
    p [1, 2, 3, 4, 5].fill(0, 2, 2)  #=> [1, 2, 0, 0, 5]
    p [1, 2, 3, 4, 5].fill(0, 2..3)  #=> [1, 2, 0, 0, 5]
    ```
- `a.flatten`
- `a.flatten!`
    平坦化数组 a。所谓平坦化是指展开嵌套数组，使嵌套数组变为一个大数组。
    ```ruby
    a = [1, [2, [3]], [4], 5]
    a.flatten!
    p a    #=> [1, 2, 3, 4, 5]
    ```
- `a.reverse`
- `a.reverse!`
    反转数组 a 的元素顺序。
    ```ruby
    a = [1, 2, 3, 4, 5]
    a.reverse!