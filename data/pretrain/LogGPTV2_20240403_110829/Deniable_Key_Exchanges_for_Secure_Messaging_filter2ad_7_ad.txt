ﬁrst message of the conversation is encrypted under this key and
attached to the same ﬂow. Even if I is ofﬂine when this message is
sent, and R then goes ofﬂine forever, I will still be able to decrypt
this message when it comes back online. It is important to note that
I does not know the identity of the party that will respond to the
prekeys it produces, but R knows the identity of the party to whom
it wishes to send a message. In this sense, the key exchange has a
Similarly to F IncProc
single post-speciﬁed peer. Concretely, the identity of R should be
part of the output for I, while the identity of I is an input for R.
Neither F IncProc
post-keia captures this notion.
keia nor F IncProc
post-keia, information generated by IncProc in-
criminates the responder R, and IncProc is called after the shared
secret k is generated. We deﬁne ideal functionality F IncProc
1psp-keia (sin-
gle post-speciﬁed peer key exchange with incriminating abort) to
capture the desired properties. F IncProc
1psp-keia takes place between two
or more parties. The functionality is given in Algorithm 2.
In the normal case, a party informs F IncProc
1psp-keia that it would like
to solicit a connection. Without loss of generality, we call this party
I. Only one party solicits a connection per session. Later, another
party asks the functionality to complete an exchange with I. With-
out loss of generality, we call this party R. F IncProc
1psp-keia generates
a shared secret k, and then waits for the adversary S to issue a
set-key request. If S has not corrupted R, then F IncProc
1psp-keia in-
stantly sends k to R and then sends k and the identity of R as a
delayed message to I.
S can choose to withhold the ﬁnal message sent to I, causing
R to complete and I to stall. If S corrupts R before the protocol
halts, then it can cause I to receive an adversarially chosen secret
k(cid:48) and the identity of any corrupted party P . Finally, S is also al-
lowed to abort the protocol after I has solicited a connection, and
it can choose whether or not I should be informed of this abort.
In any case, if the protocol is aborted, S can cause R to generate
incriminating information that proves R was attempting to commu-
nicate with I. S cannot cause I to output a key if the protocol was
aborted, but it can still cause R to output a key.
F IncProc
1psp-keia is parameterized with an incriminating abort proce-
dure IncProc that accepts the as parameters the session identiﬁer,
the identities of I and R, the long-term public keys of I and R, the
secret key of R, and the shared secret k.
In practice, at most one honest respondent replies to each ini-
tial message from I. If dishonest parties send multiple responses
to I, then I processes only the ﬁrst response received. F IncProc
1psp-keia
captures this situation by binding each instance of the functional-
ity (i.e., each protocol “session”) to a distinct solicit message
sent by I. Therefore, at most one party is labeled as “R” for each
session; subsequent establish messages to F IncProc
1psp-keia are ig-
nored. The GUC framework spawns a new instance of F IncProc
1psp-keia
for each session within the network, while still supporting shared
state between them through the use of shared functionalities.
6.2 Spawn∗
We now deﬁne a one-round DAKE, Spawn∗, that can be used
in interactive or non-interactive settings. Spawn∗ provides both of-
ﬂine and online message and participation repudiation (with limited
exceptions that we discuss later) while also providing forward se-
crecy for completed sessions.4 Figure 3 depicts the protocol, which
takes place between an initiator I and a responder R.
P , SK Sig
) ← DRGen() as well as (P K RS
Before any sessions begin, all parties register long-term public
keys with a PKI. Each party P generates a master signing keypair
P ) ← SigGen(), and two scheme-speciﬁc keypairs:
(P K Sig
P ) ←
(P K DRE
, SK DRE
RSGen(). P binds the keys together by computing a signature
P ← Sig(P K Sig
P ) and uploading
σP KI
P KP = (P K Sig
) to the PKI along with
proofs of knowledge of the corresponding secret keys. When re-
trieving P KP from the PKI, parties verify the trustworthiness of
P , P K DRE
P
, P K RS
P , P K DRE
P , SK Sig
(cid:107)P K RS
P , SK RS
P , σP KI
P
P
P
P
4 In a well-known result, Bellare et al. have previously shown that
no one-round protocol can achieve the strongest notion of forward
secrecy [1]. Here, we discuss “weak forward secrecy”.
(pk, sk) ← SigGen()
(npk, nsk) ← NCGen()
(rpk, rsk) ← RSGen()
I
R
“I” (cid:107) pk (cid:107) npk (cid:107) rpk (cid:107) Sig(pk, sk, npk(cid:107)rpk)
“R” (cid:107) NCEnc(npk, DREnc(P K DRE
(cid:107) RSig(P K RS
R ,{P K RS
R , SK RS
I
, P K RS
, P K DRE
R , rpk}, γ)
R
I
, “I”(cid:107)pk(cid:107)k))
k $←− {0, 1}λ
Figure 3: Spawn∗. The shared secret is k. γ denotes “R” concatenated with the output of NCEnc. Spawn replaces NCGen with
PKGen and NCEnc with PKEnc. In all other ways, Spawn is identical to Spawn∗.
using a scheme-speciﬁed key veriﬁcation mechanism. This
P K Sig
trust is extended to P K DRE
P
P
and P K RS
P by verifying σP KI
P
.
When starting a session, I uses a standard signature scheme to
generate an ephemeral key pair (pk, sk). This key pair is then used
to sign ephemeral public keys for other schemes: one pair for non-
committing encryption, and one pair for ring signatures. This sig-
nature binds both ephemeral keys to pk. In an interactive setting,
I immediately sends its identity, the ephemeral public keys, and
the signature binding them to pk to R as message ψ1. In a non-
interactive setting, I instead uploads this information to a central
server as a prekey. Later, when R wishes to send a message to I,
the central server relays a prekey to R. I expects only one response
for each prekey. Thus, the role of the central server is merely to pre-
vent prekey collisions; the server is not trusted—while it can attack
the availability of the protocol by going ofﬂine or by distributing
non-genuine or repeated prekeys, it is not entrusted with any infor-
mation that could be used to attack the security of the protocol.
Irrespective of the interactivity mode, R subsequently veriﬁes
the consistency of ψ1 and then uses the ephemeral keys to formu-
late a response ψ2 to I. At a high level, this response consists
of R’s identity, a wrapped session key k, and a signature to au-
thenticate the ciphertext. The session key is ﬁrst encrypted us-
ing dual-receiver encryption for the long-term public keys of I
and R. The resulting ciphertext is then encrypted once more us-
ing non-committing encryption for npk. Consequently, the session
}
key can only be decrypted by a party knowing {nsk, SK DRE
}. In the normal case (when both I and R are
or {nsk, SK DRE
honest), the only party satisfying these requirements is I. In inter-
active settings, a misinformant in the presence of an online judge
will be able to learn k—misinformants simulating I have access
to {nsk, SK DRE
}, and misinformants simulating R generate k
themselves—and thus they can fully simulate conversations.
, P K RS
R also encrypts pk and the identiﬁer for I alongside k. This
binds both the non-committing encryption and the dual-receiver en-
cryption to the current session, preventing replay attacks.
As part of the response ψ2, R also includes a ring signature of
the ciphertext. The ring, {P K RS
R , rpk}, includes the long-
term public keys of both I and R, as well as the ephemeral key rpk
associated with pk. In the case where both I and R are honest, R
creates the signature using its long-term secret SK RS
R . An honest I
is assured that only R could have produced the signature, because I
knows that it has not revealed SK RS
or rsk to any other party. The
inclusion of both long-term keys in the ring allows misinformants
to simulate signatures for online judges. The inclusion of rpk in
the ring allows an ofﬂine forger to create transcripts for exchanges
between arbitrary parties.
R
R
I
I
I
krk
Assuming the existence of a signature scheme, a ring signature
scheme that is secure under full-key exposure, a dual-receiver en-
cryption scheme, and a non-committing public-key cryptosystem,
1psp-keia within the non-erasure ¯GSpawn∗
Spawn∗ GUC-realizes F IncProc
-
hybrid model with fully adaptive corruptions. For brevity, we omit
proof of this claim here; the complete formal proof can be found in
the thesis [27, §3.8.4].
6.3
Implications of Incriminating Abort
Like Φdre and RSDAKE, Spawn∗ can leak incriminating infor-
mation if an adversary causes the protocol to abort in a speciﬁc
manner. When Spawn∗ is aborted, the adversary can receive a valid
R . There
ψ2 message created and signed using R’s secret key SK RS
is a critical difference between Spawn∗, Φdre, and RSDAKE in
this respect: when incriminating information is released, one of the
honest parties (R) does not abort. This leads to a potential attack.
If Mallory, an active network adversary, is attempting to con-
vince Justin that Bob is communicating with Alice using Spawn∗,
she can cause the protocol to abort. Justin begins by generating
1 using (npk(cid:48), nsk(cid:48)) ← NCGen() and sending ψ(cid:48)
ψ(cid:48)
1 to Mallory,
while ensuring that nsk(cid:48) is kept private. When Alice sends ψ1 to
Bob, Mallory intercepts this message and replaces it with ψ(cid:48)
1. Bob
responds with ψ2 containing an encryption γ of session key k and
B , rpk}. Mallory
a ring signature σ signed by ring {P K RS
relays ψ2 to Justin, but either causes Alice to stall by withholding
ψ2, or causes Alice to abort by delivering ψ2. Justin now instructs
Mallory to corrupt Bob. When Mallory corrupts Bob, she recovers
k(cid:48). Mallory sends k(cid:48) and SKB to Justin. Justin uses his knowledge
to decrypt γ, ensuring that k = k(cid:48). In this
of nsk and SK DRE
case, Justin will be convinced that Bob attempted to communicate
with Alice as long as he believes that Mallory did not corrupt Alice
or Bob until after ψ2 was sent. This attack does not apply in settings
where it is unreasonable for Justin to make this assumption.
6.4 Weakness of Online Repudiation
A , P K RS
B
When choosing to implement a cryptographic scheme, it is ex-
tremely important to consider the security assumptions of the cor-
responding security proof; when the assumptions do not hold, at-
tacks may be possible. The security of Spawn∗ relies on the ac-
curacy of the GUC model, which makes an assumption that is not
necessarily true in all real-world scenarios. If the distinguishing
environment Z has previously corrupted some party P and gained
access to SK RS
P , it may instruct the adversary to cause a corrupted
party R (cid:54)= P to identify itself as P in response to I. In our secu-
rity model, we assume that since P is corrupted, S can also access
in order to decrypt the response sent by R. When this
SK DRE
assumption fails in practice, it yields a potential attack in which
P
Z can distinguish between simulated and real protocol executions.
We will now consider how such an attack might proceed in practice.
Alice is a whistleblower that has previously provided secret in-
formation to Bob, a journalist, using Spawn∗ over the Internet.
Justin is an agent for a group that has some leverage over Bob.
Justin wishes to prevent further whistleblowing by demanding that
Bob asks Alice to send him some new information that will incrim-
inate her. Bob agrees, but refuses to reveal his long-term secret key
B to Justin since it would allow Justin to impersonate Bob in
SK RS
all conversations. However, Bob does not actually want to incrimi-
nate Alice; instead, he would like to secretly simulate Alice.
Bob computes a message ψ1, and reports to Justin that he has re-
ceived ψ1 from Alice. However, Justin has covertly stolen the long-
term secrets SKC from Alice’s friend Charlie in the past. Justin
constructs a response ψ2 containing session key k that purportedly
comes from Charlie, and signs the ring signature using SK RS
C . He
then instructs Bob to send ψ2 to Alice, along with a message, en-
crypted under k, asking Alice to meet Charlie for coffee (or some
other innocuous message). Justin expects Alice to respond to Char-
lie’s message using a protocol that requires her to know k. If Bob
has access to SKC, as is assumed by the GUC framework, then he