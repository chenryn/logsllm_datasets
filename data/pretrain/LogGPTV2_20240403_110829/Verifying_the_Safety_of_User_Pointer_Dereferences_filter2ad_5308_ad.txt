31:
32:
33:
34:
35:
36:
37:
38:
39:
40: }
if (err msg_name = address;
}
} else {
}
...
m->msg_name = NULL;
err = move_addr_to_kernel(m->msg_name,
m->msg_namelen,
address);
Figure 3. From net/sys.c, net/core/iovec.c
ψ ≡ ¬(mode = VERIFY READ ∧ err msg name
was only may-modiﬁed under the guard ψ(cid:1) ≡ false.
While ψ(cid:1)
is a sound choice for the must-modify guard,
as it underapproximates the exact guard ψ, using the
more precise guard ψ is important because it prevents
the analysis from concluding that msg sys.msg name
is a user pointer on entry to sock recvmsg.
Consequently, we augment the alias analysis with a
must-modify analysis that tracks a guard ψ as the con-
dition under which a location is must-modiﬁed by the
procedure. Then, to keep the guard small in the interest
of scalability, we use a special abstraction function (see
Section 5.7) called the correlation abstraction function,
αcorr , to compute a conservative underapproximation of
ψ described in [5]. Tracking these more precise must-
modify conditions in the alias analysis substantially re-
duces the number of false alarms.
335
6 Evaluation
This section evaluates an implementation of the
unchecked user pointer dereferences analysis. The im-
plementation uses the Saturn program analysis frame-
work [1].
6.1 Setup
We ran our implementation over the entire Linux
2.6.17.1 distribution built for the x86 architecture. The
distribution contains over 6.2 million lines of code
with 91,543 procedures, 40,760 global variables, 14,794
composite types, and 35,317 initializers. Our implemen-
tation transforms the 33,886 loops into tail recursive pro-
cedures. The abstract syntax trees are stored in several
databases totaling 1.7 GB in size.
We ran the Saturn alias analysis over the abstract
syntax trees to compute the memory model for each
procedure as described in Section 4, and then we ran
our unchecked user pointer dereferences analysis over
the abstract syntax trees and memory models. The
unchecked user pointer dereferences analysis consists of
two phases. The ﬁrst phase determines which expres-
sions in a procedure may evaluate to a user location, and
the second phase determines which of those expressions
identiﬁed in the ﬁrst phase are not guarded by a check.
Decomposing the analysis into two phases aids scalabil-
ity by allowing the ﬁrst phase to identify the minimum
set of expressions that need to tracked by the second
phase.
Because our analysis is compositional and each pro-
cedure is analyzed independently, we parallelized our
implementation by distributing the analyses of individ-
ual procedures over a cluster consisting of 25 nodes
where each node consists of 4 cores and 6 GB of
memory. The implementation allotted 3 minutes to
each procedure before timing out and moving on to
the next procedure. The implementation times out on
154 procedures, or 0.17%. The total running time of
the unchecked user pointer dereferences analysis is 3.5
hours.
6.2 Results
A user pointer source is a pointer parameter to a sys-
tem call. A user pointer sink is a pointer dereference
site. The Linux distribution we analyzed has 627 sources
and 867,544 sinks. Our analysis discharges 616 out
of the 627 user pointer sources (or 98.2% of sources)
and 851,686 of the 852,092 user pointer sinks that do
int sound_ioctl(..., uint cmd,
ulong /*user*/ arg) {
if (_SIOC_DIR(cmd) != _SIOC_NONE &&
_SIOC_DIR(cmd) != 0) {
if(_SIOC_DIR(cmd) & _SIOC_WRITE) {
if (!access_ok(..., arg,...)) {
return -EFAULT;
}
}
}
...
return sound_mixer_ioctl(..., cmd, arg);
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14: }
void /*user*/ *arg) {
...
return aci_mixer_ioctl(...,cmd, arg);
15: int sound_mixer_ioctl(uint cmd,
16:
17:
18:
19: }
20:
21: int aci_mixer_ioctl(..., uint cmd,
22:
23:
24:
25:
26:
27: }
case SOUND_MIXER_WRITE_IGAIN:
...*arg...;
switch(cmd)
void /*user*/ *arg) {
...
Figure 4. From sound/oss/soundcard.c
not appear in procedures that time out (or 99.95% of
sinks). There were 11 warnings on user pointer sources
(1 source warning for approximately 560,000 lines of
code) and 406 warnings on user pointer sinks (1 sink
warning for approximately 15,000 lines of code) all of
which can be discharged by 22 additional, simple anno-
tations. Almost all false alarms can be classiﬁed into two
categories: lack of interprocedural path sensitivity and
imprecision in analyzing function pointers. The annota-
tions discharging the false alarms due to interprocedural
path-insensitivity reﬁne the guard associated with a state
in a summary state environment with additional program
predicates, while those discharging the false alarms due
to function pointer imprecision reﬁne the set of possible
targets computed for function pointer call statements.
6.3
Interprocedural Path Insensitivity
is
The analysis presented in this paper
fully
intraprocedurally path-sensitive but interprocedurally
path-insensitive. Within a procedure the analysis rea-
sons about all branch correlations, however, the context
variable abstraction performed on the preliminary sum-
mary eliminates all path information in the ﬁnal sum-
mary of the procedure, which prevents the analysis from
correlating branches and return values across procedure
boundaries. Interprocedural path sensitivity is used in a
few places in Linux, causing the analysis to fail to dis-
charge 5 user pointer sources and 265 user pointer sinks.
struct { char *name; ...} map[] = ...,
{[NFSCTL_GETFD] = {.name = ".getfd", ...},
[NFSCTL_GETFS] = {.name = ".getfs", ...},};
long sys_nfsservctl(int cmd, ..., void *res) {
...
struct file *file = do_open(map[cmd].name);
...
int err = file->f_op->read(file, res, ...);
...
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11: }
Figure 5. From fs/nfsctl.c
on
the
the
3
and
is
4,
lines
Consider
procedure
sound ioctl
from Linux
of
2.6.17.1
sound/oss/soundcard.c
(see Figure 4) where the formal parameter arg
is a user pointer passed from the system call
Line 7 performs a check on the
sys ioctl.
user pointer using the special checking primitive
the condition φ ≡ φ1 ∧ φ2
access ok under
where φ1 ≡
SIOC DIR(cmd) != SIOC NONE
con-
&& SIOC DIR(cmd) != 0
≡
ditional
the
SIOC DIR(cmd) & SIOC WRITE) != 0
conditional on line 6.
to
sound mixer ioctl on line 13, arg is checked
under the condition φ. Consequently, any subsequent
dereference of arg must be guarded by a condition that
implies φ. Line 18 in procedure aci mixer ioctl
dereferences the user pointer arg under the condition
cmd == SOUND MIXER WRITE IGAIN which implies
φ, and thus the user pointer is checked before it is
dereferenced and therefore safe. Adding relevant guards
to procedure summaries to express interprocedural
path sensitivity would enable the analysis to prove this
dereference safe.
Thus, before the call
and φ2
is
6.4 Function Pointers
Four user pointer sources and 130 user pointer sinks
could not be discharged because the set of targets for
some function pointers inferred by the alias analysis
is too coarse. Consider the function pointer invoca-
tion in procedure sys nfsservctl of fs/nfsctl.c,
shown in Figure 5. This single site is responsible for
the analysis failing to discharge 1 user pointer source
and 111 user pointer sinks. On line 1, the global ar-
ray map maps integer constants to ﬁle names. On line
7, sys nfsservctl performs a lookup into map for a
ﬁle name and uses the ﬁle name to open a ﬁle repre-
sented by a struct file object. The struct file
object has a ﬁeld called f op which points to a func-
tion pointer table of type struct file operations
336
int notifier_call_chain(struct notifier_block **nl,
unsigned long val, void *v) {
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15: }
int ret = NOTIFY_DONE;
struct notifier_block *nb;
nb = *nl;
while (nb) {
ret = nb->notifier_call(nb, val, v);
...
nb = nb->next;
}
return ret;
Figure 6. From fs/nfsctl.c
one of whose entries is a ﬁeld read.
The mem-
ory model imprecisely reports that the targets of the
function pointer file->f op->read points to the tar-
gets of any read ﬁeld from any instance of struct
file operations rather than only the instances that
can actually be pointed to by the file returned by this
call to do open.
6.5 Manual Summaries
We manually summarized several commonly used
assembly statements.
In particular, we summarized
each inline assembly statement to specify that the state-
ment dereferences each of its operands. These deref-
erence summaries allow the analysis to handle more
conservatively some inline assembly statements such
copy to user which dereference
as
some of their operands but do not check whether these
operands point into user space.
memcpy and
We also summarized several inline assembly state-
ments and procedures designated by Linux developers
as primitives that check whether a user pointer points
into user space. These checker inline assembly state-
ments include range ok, get user, and put user,
and the checker procedures include copy from user
and copy to user.
6.6 Manual Annotations
We used two annotations that soundly restrict which
locations are tracked as user at particular program
points. These two annotations increase the precision of
the analysis which prevents the user state from prop-
agating to many times more locations than necessary.
Without these two annotations, the analysis fails to ter-
minate in a reasonable amount of time because an ex-
cessive number of locations are tracked.
337
We placed one of these scalability annotations in
notifier call chain, a generic procedure shown in
Figure 6 whose ﬁrst parameter nl is a linked list of func-
tion pointers and whose third parameter v is a void*
pointer. The procedure iterates over nl and invokes
each of its function pointers on v. The pointer v is
a user pointer in some calling contexts but not oth-
ers. Because our analysis does not track the correla-
tion between the possible targets of the function point-
ers in nl and whether v is a user pointer, it concludes
that notifier call chain passes a user pointer to
all possible targets of function pointers in nl. We
placed the other scalability annotation in procedure
HiSax command. This annotation reﬁnes the guard un-
der which a particular location is tracked as being user
with additional interprocedural, path-sensitive informa-
tion.
7 Conclusion
We have presented a scalable and precise analysis for
ﬁnite-state safety properties and reported on our expe-
rience in attempting to verify the absence of unchecked
user pointer dereferences in the Linux operating system.
We believe that our analysis can be adapted to verify
other important security properties as well.
8 Acknowledgment
The authors would like to thank Isil Dillig, Thomas
Dillig, Brian Hackett, and Peter Hawkins for their com-
ments on earlier drafts of this paper. This work was sup-
ported by NSF grants CCF-0430378 and NSF SA4899-
10808PG-1 with additional support from DARPA.
References
[1] A. Aiken, S. Bugrara, I. Dillig, T. Dillig, B. Hackett,
and P. Hawkins. An Overview of the Saturn Project.
In Proceeding of the 7th ACM Workshop on Program
Analysis for Software Tools and Engineering, New York,
NY, USA, 2007. ACM Press.
[2] T. Ball and S. K. Rajamani. The SLAM Project: Debug-
ging System Software via Static Analysis. In Proceed-
ings of the 29th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, pages 1–3, New
York, NY, USA, 2002. ACM Press.
[3] B. Blanchet, P. Cousot, R. Cousot,
J. Feret,
L. Mauborgne, A. Mine, D. Monniaux, and X. Ri-
val. Design and Implementation of a Special-Purpose
Static Program Analyzer for Safety-Critical Real-Time
Embedded Software. pages 85–108, 2002.
the 10th ACM Conference on Computer and Communi-
cations Security, pages 321–334, New York, NY, USA,
2003. ACM Press.
[4] M. Das, S. Lerner, and M. Seigle. ESP: Path-sensitive
Program Veriﬁcation in Polynomial Time. In Proceed-
ings of the ACM SIGPLAN 2002 Conference on Pro-
gramming Language Design and Implementation, pages
57–68, New York, NY, USA, 2002. ACM Press.
[5] I. Dillig, T. Dillig, and A. Aiken. Static Error Detection
Using Semantic Inconsistency Inference. In Proceedings
of the ACM SIGPLAN 2007 Conference on Program-
ming Language Design and Implementation, volume 42,
pages 435–445, New York, NY, USA, 2007. ACM Press.
[6] N. Dor, S. Adams, M. Das, and Z. Yang. Software Vali-
dation via Scalable Path-sensitive Value Flow Analysis.
In Proceedings of the ACM SIGSOFT 2004 International
Symposium on Software Testing and Analysis, pages 12–
22, New York, NY, USA, 2004. ACM Press.
[7] S. Fink, E. Yahav, N. Dor, G. Ramalingam, and E. Geay.
Effective Typestate Veriﬁcation in the Presence of Alias-
ing.
In Proceedings of the 2006 International Sympo-
sium on Software Testing and Analysis, pages 133–144,
New York, NY, USA, 2006. ACM Press.
[8] J. Foster, M. Fahndrich, and A. Aiken. A Theory of Type
Qualiﬁers. In Proceedings of the ACM SIGPLAN 1999
Conference on Programming Language Design and Im-
plementation, pages 192–203, New York, NY, USA,
1999. ACM Press.
[9] B. Hackett and A. Aiken. How is Aliasing Used in Sys-
tems Software? In Proceedings of the 14th ACM SIG-
SOFT International Symposium on Foundations of Soft-
ware Engineering, pages 69–80, New York, NY, USA,
2006. ACM Press.
[10] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A Sys-
tem and Language for Building System-Speciﬁc, Static
Analyses. In Proceedings of the ACM SIGPLAN 2002
Conference on Programming Language Design and Im-
plementation, pages 69–82, New York, NY, USA, 2002.
ACM Press.
[11] T. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy
Abstraction. In Proceedings of the 29th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Lan-
guages, pages 58–70, New York, NY, USA, 2002. ACM
Press.
[12] R. Johnson and D. Wagner. Finding User/Kernel Pointer
Bugs with Type Inference. In Proceedings of the 13th
USENIX Security Symposium, pages 119–134, 2004.
[13] R. E. Strom and S. Yemini. Typestate: A Programming
Language Concept for Enhancing Software Reliability.
volume 12, pages 157–171, Piscataway, NJ, USA, 1986.
IEEE Press.
[14] L. Torvalds. Sparse.
[15] Y. Xie and A. Aiken. Scalable Error Detection us-
ing Boolean Satisﬁability.
In Proceedings of the 32nd
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, pages 351–363, New York,
NY, USA, 2005. ACM Press.
[16] J. Yang, T. Kremenek, Y. Xie, and D. Engler. MECA: An
Extensible, Expressive System and Language for Stati-
cally Checking Security Properties.
In Proceedings of
338