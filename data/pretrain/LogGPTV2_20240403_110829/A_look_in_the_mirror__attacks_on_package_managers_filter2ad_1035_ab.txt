to install an old package with security vulnerabilities
1A version of ports used by NetBSD did support package
signatures at one time [7], but this has been obsoleted and
is not maintained or used.
4.2 Package Signatures
YUM and urpmi rely solely on signatures embedded in
packages to provide security. There is no protection of pack-
age metadata or the root metadata. As a result, an at-
tacker can launch replay or freeze attacks and have clients
install vulnerable packages. An attacker can choose to in-
clude any vulnerable versions of signed packages they wish
on the repository.
However, neither YUM nor urpmi verify that the package
metadata they initially received for dependency resolution
matches the embedded package metadata of subsequently
downloaded packages. This allows an attacker to forge pack-
age metadata to launch an extraneous dependencies attack.
This means that if there exists a package that the attacker
knows how to exploit and which the user does not have in-
stalled, the attacker can cause it to be installed whenever
any other package is installed by the user. The result is that
an attacker can compromise essentially every client that in-
stalls or updates a package.
Both YUM and urpmi are also vulnerable to endless data
attacks. For example, when YUM is given a repomd.xml
ﬁle of unlimited size, it exits without printing an error af-
ter the ﬁlesystem is full — leaving the huge ﬁle on disk.
Since no information is logged or printed about the error,
this makes discovering the problem complicated (especially
if YUM runs via auto-update).
Fixing the package managers Even without chang-
ing the signature methods, it is possible to modify these
package managers to prevent the extraneous dependencies
attack. Doing so requires verifying that downloaded pack-
age metadata is the same as the embedded metadata in any
downloaded package. Furthermore, endless data attacks can
be prevented by capping the size of downloaded data. How-
ever, these changes are not adequate to protect against re-
play or freeze attacks. Given the large number of packages
that need to be re-signed to prevent replay or freeze attacks,
we believe that adding root metadata signing is the most
practical way to address this issue.
4.3 Package Metadata Signatures
The Portage and Stork package managers use signatures
on package metadata; however, they do so in diﬀerent ways.
Each package in Portage has a separate, signed package
metadata ﬁle for each version of the package. The package
metadata contains the secure hash of the package (possibly
along with hashes of related ﬁles such as patches). In con-
trast, Stork users create a single ﬁle that contains a times-
tamp and the secure hash of the package metadata for all of
the packages that the user trusts. Users can also delegate
trust to other users and all users typically delegate trust to
a single “distribution” user. The analysis of Stork therefore
focuses on the security of the packages trusted by the dis-
tribution user because the security of the distribution user
aﬀects all clients.
These package managers are not vulnerable to extrane-
ous dependencies attacks because the signatures protect the
package metadata. However, resistance to metadata tam-
pering does not imply that the package manager is resistant
to all attacks. Both package managers are vulnerable to
endless data attacks.
In both Portage and Stork, an attacker can launch freeze
attacks. In Portage, since each package has a diﬀerent ﬁle
for metadata signatures, an attacker can choose to have any
combination of packages (such as those that include only
older versions with known vulnerabilities) available on the
mirror. Portage is vulnerable to replay attacks in the same
way as freeze attacks.
In Stork, all of the package metadata hashes are in the
same signed ﬁle. This prevents an attacker from choosing
package metadata that existed on the repository at diﬀerent
times. Stork checks that timestamps on ﬁles are increasing
to prevent replay attacks but does not prevent freeze attacks.
It is possible to add re-
play attack protection to Portage through timestamp check-
ing and to add protection against endless data attacks to
both Portage and Stork. However, both package managers
will still be vulnerable to freeze attacks.
Fixing the package managers
4.4 Root Metadata Signatures
The package managers APT, APT-RPM, and YaST use
signatures on the root metadata. All three of these package
managers optionally support package signatures as well, but
this functionality is not widely used in practice.
Package metadata is stored in compressed ﬁles and the se-
cure hashes of those ﬁles are stored in the root metadata ﬁle.
As the root metadata is protected by a signature, the pack-
age metadata is protected from tampering which prevents
extraneous dependencies attacks. In addition, the signature
on the root metadata prevents a mirror from hosting ver-
sions of packages that were on the main repository during
diﬀerent time periods. The attacker must choose a time pe-
riod of the main repository to copy and provide exactly those
ﬁles when launching a replay attack. Unfortunately, none of
these package managers check the order of timestamps to
prevent replay attacks or have any mechanisms to prevent
freeze attacks or endless data attacks.
Fixing the package managers
It is easy for these
package managers to protect against endless data attacks
as well as to prevent replay attacks. Replay attacks can
be prevented by adding a timestamp to the root metadata
and checking that any newly downloaded root metadata is
not older than the version the client last obtained. In fact,
all three package managers have a timestamp available and
merely need to add this check.
To mitigate the eﬀectiveness of freeze attacks, package
managers could add an expiration time to the root metadata.
Clients would refuse to use a root metadata ﬁle if the current
time is greater than the expiration time. Since the root
metadata is a single, small ﬁle, it is feasible to re-sign this
ﬁle often and require every mirror to be frequently updated
(most distributions already require their public mirrors to
update at least once a day).
4.5 Classiﬁcation
The security mechanisms and vulnerabilities of the pack-
age managers are summarized in Figure 2. All of the pack-
age managers studied are vulnerable to endless data attacks
as well as freeze attacks. Diﬀerent package managers have
varying resistance to other attacks such as replay attacks.
Depending on the package manager’s security mechanisms,
the result can be any of the following, where those listed ﬁrst
also imply those listed after: arbitrary packages created by
the attacker are installed, any vulnerable package can be
installed alongside non-vulnerable packages a client installs
using an extraneous dependencies attack, mismatched out-
dated packages are installed (in that they existed on the
Name
Pacman
ports
Slaktool
YUM
urpmi
Portage
Stork
APT
YaST
APT-RPM (1)*, (3)*
Signature Package Installation Metadata Abuse
nothing
nothing
nothing
(1)
(1)
(2)*
(1)*, (2)
(1)*, (3)
(1)*, (3)
arbitrary
arbitrary
arbitrary
arbitrary
arbitrary
replay / freeze
freeze
replay / freeze
replay / freeze
replay / freeze
arbitrary
arbitrary
arbitrary
alongside
alongside
mismatch
snapshot
snapshot
snapshot
snapshot
Figure 2: Package managers, their protection mech-
anisms and vulnerabilities. The protection mecha-
nisms are numbered (1) packages, (2) package meta-
data, (3) root metadata. ’*’ indicates that support
exists but is not in common use.
Signatures
Protecting
Package
Best Case
Common Case
No Security
Package
arbitrary
mismatch
Package Meta-
data
Root Meta-
data
mismatch /
snapshot
current
Metadata
Abuse
arbitrary
replay
/
freeze
freeze
Package
arbitrary
alongside
mismatch
none
snapshot
Metadata
Abuse
arbitrary
arbitrary
replay
freeze
replay
freeze
/
/
Figure 3: Classiﬁcation of package manager protec-
tion schemes. This demonstrates both the security
that is possible to achieve using a scheme as well as
what is commonly provided by existing implemen-
tations.
main repository at diﬀerent times), or installed packages will
come from a collection of outdated packages that all existed
at the same time on the main repository (i.e.
in the same
snapshot).
Based on the observation and analysis of the security in
existing package managers, it is possible to similarly classify
the security mechanisms. As Figure 3 shows, one can obtain
an ordering of the security of the mechanisms. Clearly, hav-
ing no signatures allows the most attacks and is the most
vulnerable. Signatures on packages provide a deﬁnite im-
provement over no signatures, but gives the attacker the
ability to manipulate metadata arbitrarily and provides at-
tackers the ability to populate a mirror with packages of mis-
matched versions, or, if package metadata isn’t veriﬁed using
the signed packages, the ability to cause vulnerable pack-
ages to be installed alongside any non-vulnerable packages.
Signatures on package metadata prevent the attacker from
doing more than replaying or freezing the package metadata,
but if the signatures are in separate ﬁles, the attacker can
still mismatch versions of packages. By preventing replay
and freeze attacks in package managers that sign the root
metadata, a package manager will only install current pack-
ages and is immune to metadata tampering.
5. ADDITIONAL USABILITY NEEDS
This section focuses on additional usability requirements
users have for package management. Most importantly, the
use case where a user has an uninstalled package on their
computer they need to verify.
The standard use case of the package managers and their
security mechanisms is where a user needs to securely install
software from a repository or mirror. However, it is not
uncommon for a user to have a stand-alone package that was
created by a party they trust and that they need to verify
is free from tampering. Stand-alone packages are packages
that are not obtained through the package manager’s normal
channels at install time. Stand-alone packages may have
been obtained manually from unoﬃcial sources or may even
be packages a user has created. Another source provides an
extended discussion [29] describing why stand-alone package
veriﬁcation is an important and desirable feature.
The signing of only root metadata does not allow any
practical way to verify stand-alone packages. Package man-
agers that use signed root metadata could be modiﬁed to
keep copies of all metadata obtained from the repository
for future veriﬁcation of stand-alone packages, but this only
helps for packages a user manually downloads from the same
repository that they access through their package manager.
This also fails to satisfy one of the primary reasons given
for being able to verify stand-alone package signatures: ver-
ifying signatures for ﬁles when they are only available for
manual download and installation, not through a repository.
Package managers that sign package metadata tend to be
more able to meet the needs of stand-alone package veriﬁ-
cation than the package managers who only sign root meta-
data. However, the way in which package metadata is stored
has a major impact on usability in this case. Similarly with
package managers that sign only root metadata, package
managers would need to store old package metadata and this
would only be of use for verifying stand-alone packages that
came from a repository the user normally uses.
In other
cases, the user would need to be sure to always keep the
signed package metadata with the package for veriﬁcation
purposes. This is far from an ideal option.
Signatures embedded in packages are thus the most practi-
cal option and provide the greatest ease of use when stand-
alone packages must be veriﬁed. All that a user needs in
order to verify a package is the package itself. A drawback
with having signatures in the package is that signatures are
constrained by the limits of the package format so multiple
signatures may not be supported.
Using signatures embedded in packages for stand-alone
package veriﬁcation does have complications, though. No-
tably, users must have the requisite public keys available in
order to verify package signatures. They must also ensure on
their own that packages they are installing are not outdated
or have vulnerabilities. However, there are many scenarios
where a user can use embedded package signatures in a way
that increases security in their speciﬁc situation.
6. DEPLOYMENT EXPERIENCE
To gain more experience with what security mechanisms
work well in practice, we modiﬁed the package manager
Stork and added root metadata signing. We added an expi-
ration time to the root metadata to prevent freeze attacks.
Since Stork already supported both package signatures and
package metadata signatures, this allowed us to experiment
with all types of signatures in a single package manager.
The changes to Stork for root metadata signing were tested
and beta-deployed and ﬁnally incorporated into the produc-
tion release. Interestingly, Stork diﬀered from all other se-
cure package managers in that there was no key already
trusted by clients to validate communication from the repos-
itory. As the only signed ﬁles in Stork were the package
metadata ﬁles signed by individual users, there had never
been a need for the repository to have its own key that the
clients trusted. This required distributing a repository key
to clients in order for them to make use of the new root
metadata signatures. The key was included with the ini-
tial release of the updated version of Stork. This initial
key distribution was secure because the majority of users,
through their trusted packages ﬁles, delegate trust to the
Stork team to provide them updated Stork packages. Stork’s
design meant that users would not be using this key for
trusting packages, but rather only verifying metadata ﬁles
downloaded from the repository.
The resulting changes were transparent to the users both
in terms of performance and usability. The overhead of using
package metadata signing along with root metadata signing
was measured and found to be negligible (between 2-5%).
Ultimately, there were few comments about the addition of
root metadata signatures since the existing security mech-
anism (package metadata signatures) was retained without
modiﬁcation. Though transparent to the users, they gained
increased security through the addition of root metadata
signatures.
We examined packages on the Stork repository to ﬁnd that
user-uploaded packages did not include package signatures,
indicating that researchers were not using the optional pack-