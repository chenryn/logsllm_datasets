and a ciphertext ct and outputs the decryption msg or ⊥.
A PKE scheme PKE is correct if for all λ and msg ∈ ℳ,
(cid:12)(cid:12)(cid:12)msg∗ (cid:60) query
S.Verify(vk, σ
, msg∗
) = 1
∗
(cid:20)
(cid:18)
(cid:19)
(cid:12)(cid:12)(cid:12)(cid:12)
(cid:103)
Pr
PKE.Dec
sk, PKE.Enc(pk, msg)
(cid:44) msg
(pk, sk) ← PKE.KeyGen(1λ )
= negl(λ)
where the probability is taken over the random coins of the proba-
bilistic algorithms KeyGen, Enc.
A PKE scheme provides confidentiality to the encrypted message.
Formally, a PKE scheme PKE is said to have indistinguishability
security under adaptively chosen ciphertext attack (IND-CCA2) if
there is no polynomial time adversary 𝒜 which can guess b′ = b in
the following game with probability non-negligible in λ, plus half.
Definition B.3. (IND-CCA2 security of PKE). We define the fol-
lowing game between a challenger 𝒞 and an adversary 𝒜.
sk) and gives pk to the adversary.
(1) 𝒞 runs the PKE.KeyGen algorithm to obtain a key pair (pk,
(2) 𝒜 provides adaptively chosen ct and get back PKE.Dec(sk,
(3) 𝒜 provides msg0, msg1 to 𝒞.
(4) 𝒞 then runs PKE.Enc(pk) to obtain ct∗ = PKE.Enc(pk, msgb )
(5) 𝒜 continues to provide adaptively chosen ct and get back
(6) 𝒜 outputs its guess b′.
A PKE scheme may also be “weakly robust” [1]. Informally, this
means that a ciphertext when decrypted with an “incorrect” secret
key should output ⊥ when all the algorithms are honestly run.
for b
PKE.Dec(sk, ct), with a restriction that ct (cid:44) ct∗.
$← {0, 1}. 𝒞 provides ct∗ to 𝒜.
ct).
Definition B.4. ((Weak) robustness property of PKE). A PKE
scheme PKE has the (weak) robustness property if for all λ and
msg ∈ ℳ,
Pr
, PKE.Enc(pk, msg)
= negl(λ)
PKE.Dec
(cid:44)⊥
sk′
(cid:18)
(cid:19)
(cid:20)
(cid:21)
where (pk, sk) and (pk′, sk′) are generated by running PKE.KeyGen(1λ )
twice, and the probability is taken over the random coins of the
probabilistic algorithms PKE.KeyGen, PKE.Enc.
C SECURITY PROOF LEMMATA
Lemma C.1. If the signature scheme S is existentially unforgeable
as in Definition B.2, then Hybrid 2 is indistinguishable from Hybrid 1.
Proof. Let 𝒜 be an adversary which distinguishes between
Hybrid 1 and Hybrid 2. We will use it to break the EUF-CMA
security of S. We will get a verification key vk∗
sign and an access to
S.Sign(sk∗
sign,·) oracle from the EUF-CMA challenger. 𝒮 sets this
vk∗
sign as part of the mpk. Whenever 𝒮 has to sign a message using
sign, it uses the S.Sign(sk∗
sk∗
sign,·) oracle. Also, our construction
does not ever need a direct access to sk∗
sign; it is used only to sign
messages for which the oracle provided by the challenger can be
used. Now, if 𝒜 can distinguish between the two hybrids, as we
argued earlier, it is only because 𝒜 makes a “provision” query to
the HW.Run&Report(hdlDE ,·) oracle with a hdlDE ∈ 𝒟 that has
vk∗
sign in its , and with a valid signature sig on a tagP (cid:60) 𝒦. We will
output (tagP , sig) as our forgery to the EUF-CMA challenger. □
Lemma C.2. If the signature scheme S is existentially unforge-
able as in Definition B.2, then Hybrid 3.0 is indistinguishable from
Hybrid 2.
Proof. Let 𝒜 be an adversary which distinguishes between
Hybrid 2 and Hybrid 3.0. We will use it to break the EUF-CMA
security of S. We will get a verification key vk∗
sign and an access to
S.Sign(sk∗
sign,·) oracle from the EUF-CMA challenger. 𝒮 sets this
vk∗
sign as part of the mpk. Whenever 𝒮 has to sign a message with
sk∗
sign, it uses the S.Sign(sk∗
sign,·) oracle. As mentioned in the proof
of Lemma C.1, 𝒮 never needs a direct access to sk∗
sign. Now, if 𝒜 can
distinguish between the two hybrids, as we argued earlier, it is only
because 𝒜 makes a “complete setup” query to the HW.Run(hdlDE ,
·) oracle with a valid signature σsk for (sid, ctsk ) (cid:60) LK M but sid
has an entry in , . Also, hdlDE ∈ 𝒟 and hence has vk∗
sign in its , .
We will output ((sid, ctsk ), σsk ) as our forgery to the EUF-CMA
challenger.
□
Lemma C.3. If the Local Attestation process of HW is secure as in
Definition A.1, then Hybrid 3.1 is indistinguishable from Hybrid 3.0.
The proof of this lemma is similar to Lemma C.2, since skreport
is not used by 𝒮 other than to produce a report.
Lemma C.4. If Remote Attestation is secure as in Definition A.2,
then Hybrid 5.0 is indistinguishable from Hybrid 4.
The proof of this lemma is similar to Lemma C.2 since skquote is
not used by 𝒮 except for producing a quote.
Lemma C.5. If Local Attestation is secure as in Definition A.1, then
Hybrid 5.1 is indistinguishable from Hybrid 5.0.
The proof of this lemma is again similar to Lemma C.2 since
skreport is not used by 𝒮 except for producing a report.
Lemma C.6. If PKE is an IND-CCA2 secure encryption scheme,
then Hybrid 5.2 is indistinguishable from Hybrid 5.1.
Session D1:  Functional Encryption and ObfuscationCCS’17, October 30-November 3, 2017, Dallas, TX, USA779Proof. We will run two IND-CCA2 games in parallel, one for
ctsk and another for ctkey. It can be easily shown that this vari-
ant is equivalent to the regular IND-CCA2 security game. The
IND-CCA2 challenger provides two challenge public keys pk∗
1 and
2. 𝒮 sets pkra = pk∗
pk∗
is
provided as the challenge message pair for both the games. The
challenger returns ct∗
2, which are encryptions of either the
left messages or the right messages from the each pair. Note that
we use the same challenge bit for both the games. 𝒮 sets ctsk = ct∗
1
and ctkey = ct∗
2.
1 and pkla = pk∗
1 and ct∗
skpke, 0|skpke|(cid:41)
2. Now,
(cid:40)
Now we argue that when the left messages are encrypted, the
view of 𝒜 is equivalent to Hybrid 5.1, and when the right messages
are encrypted, the view is equivalent to Hybrid 5.2. This is because
the other information that 𝒜 gets do not depend on the value en-
coded in ctsk or ctkey. We argue this as follows. We have already
established that 𝒜 only gets ctsk encrypted with a pkra generated
in DE from KME. Similarly, 𝒜 only gets ctkey encrypted with a
pkla generated in a valid F E from DE. In addition to these, when
interacting with messages from a valid QDE or QF E (·), 𝒮 either
uses the skpke from msk or the Umsg oracle to answer the queries
and not the decryption of ctkey.
Hence, when 𝒜 decides between the two hybrids we forward
the corresponding answer to the IND-CCA2 challenger. If 𝒜 can
distinguish between these two hybrids with non-negligible prob-
ability, then the IND-CCA2 security of PKE can be broken with
non-negligible probability.
□
Lemma C.7. If PKE is an IND-CCA2 secure encryption scheme,
then Hybrid 6 is indistinguishable from Hybrid 5.2.
Proof. The IND-CCA2 challenger provides the challenge public
key pk∗. During FE.Setup 𝒮 sets pkpke = pk∗. Now, msg and 0|msg|
are provided as the challenge messages. The challenger returns ct∗,
which is an encryption of either of those with equal probability. 𝒮
sets ctmsд = ct∗. When HW.Run(hdlP , “run”, reportsk , ctmsд ) is
called with a valid reportsk to hdlP ∈ 𝒦 with the honest bit set, 𝒮
uses the Umsg∗ oracle for a challenge ciphertext ctmsд ∈ ℛ from
Hybrid 4. Now, for any ctmsд (cid:60) ℛ, 𝒮 neither has the oracles nor has
the sk∗ corresponding to pk∗ in msk. But, the decryption oracle pro-
vided by the IND-CCA2 challenger can be used for any ctmsд (cid:60) ℛ.
Hence, 𝒮 can answer all the HW.Run(hdlP , “run”, reportsk , ctmsд )
queries. Thus, the view of 𝒜 is identical to Hybrid 5 when msg
is encrypted in ct∗ and Hybrid 6 when zeros are encrypted in ct∗.
So we can forward the answer corresponding to 𝒜’s answer to
the IND-CCA2 challenger. If 𝒜 can distinguish between these two
hybrids with non-negligible probability, the IND-CCA2 security of
PKE can be broken with non-negligible probability.
□
D STRONGER HW SIMULATION MODEL
Definition D.1 (StrongSimSecurity-FE). Consider a stateful simu-
lator 𝒮 and a stateful adversary 𝒜. Let Umsg (·) denote a universal
oracle, such that Umsg (P ) = P (msg).
Both games begin with a pre-processing phase executed by the
environment. In the ideal game, pre-processing is simulated by 𝒮.
Now, consider the following experiments.
Exprealℱℰ (1λ ) :
(1) (mpk, msk) ← FE.Setup(1λ )
(2) (msg) ← 𝒜FE.Keygen(msk,·) (mpk)
(3) ct ← FE.Enc(mpk, msg)
(4) α ← 𝒜FE.Keygen(msk,·),𝒪msk (·) (mpk, ct)
(5) Output (msg, α )
Expidealℱℰ (1λ ) :
(1) (mpk, msk) ← FE.Setup(1λ )
(2) (msg) ← 𝒜𝒮 (msk,·) (mpk)
(3) ct ← 𝒮Umsg (·) (1λ, 1|msg| )
(4) α ← 𝒜HW,𝒮Umsg (·) (·) (mpk, ct)
(5) Output (msg, α )
In the above experiment, oracle calls by 𝒜 to the key-generation
and KM oracles are simulated by the simulator 𝒮Umsg (·) (·). But the
simulator does not simulate the HW algorithms, except HW.Setup.
We call a simulator admissible if on each input P, it just queries its
oracle Umsg (·) on P (and hence learn just P (msg)).
The F E scheme is said to be simulation-secure against adaptive
adversaries if there is an admissible stateful probabilistic polyno-
mial time simulator 𝒮 such that for every probabilistic polynomial
time adversary 𝒜 the following distributions are computationally
indistinguishable.
Exprealℱℰ (1λ )
c≈ Expidealℱℰ (1λ )
E FE CONSTRUCTION IN THE STRONGER
SECURITY MODEL
We present here the formal description of our second FE construc-
tion which can be proven secure in the stronger security models
of HW and FE. The trusted authority platform T A and decryption
node platform DN each have access to instances of HW. We as-
sume HW.Setup(1λ ) has been called for each of these instances
before they are used in the protocol and the output params was
recorded. Let PKE denote an IND-CCA2 secure public key encryp-
tion scheme (Definition B.3) with the weak robustness property11,
let S denote an existentially unforgeable signature scheme (Defini-
tion B.2) and E denote an IND-CPA secure secret key encryption
scheme (Definition B.1).
FE.Setup(1λ ). The key manager enclave program QK ME is de-
fined as follows. Let state denote an internal state variable.
QK ME:
• On input (“init", 1λ ):
(1) Run (pkpke, skpke) ← PKE.KeyGen(1λ ) and (vksign, sksign) ← S.KeyGen(1λ )
(2) Update state to (skpke, sksign, vksign) and output (pkpke, vksign)
• On input (“provision", quote, params):
(1) Parse quote =(cid:0)mdhdl, tagP , in, out, σ(cid:1), and parse out = (sid, pk1, pk2,
skP , ctk ).
skpke and vksign from state. If b = 0 output ⊥.
(2) Run b ← HW.QuoteVerify(params, quote) on quote. If b = 1, retrieve
(3) Run b ← S.Verify(vksign, skP , tagP ). If b = 0, output ⊥.
(4) Run (ek, h) ← PKE.Dec(skpke, ctk )
(5) Compute ct1
ek||vksign)
sk
= PKE.Enc(pk1, ek||vksign) and ct2
= PKE.Enc(pk2,
sk
11We actually need one PKE scheme with IND-CPA security and weak robustness
property and another PKE scheme with IND-CCA2 security
Session D1:  Functional Encryption and ObfuscationCCS’17, October 30-November 3, 2017, Dallas, TX, USA780sk, ct2
ct2
sk, h, σsk ).
sk, h)) and output (sid, ct1
sk,
Compute sig ← S.Sign(sksign, msg) and output sig.
(6) Compute σsk = S.Sign(sksign, (sid, ct1
• On input (“sign", msg):
Run hdlK ME ← HW.Load(params, QK ME ) and (pkpke, vksign) ←
HW.Run(hdlK ME , (“init", 1λ )). Output the master public key mpk :=
pkpke and the master secret key msk := hdlK ME.
FE.Keygen(msk, P ). Parse msk as a handle to HW.Run. De-
rive tagP and call sig ← HW.Run(hdlK ME , (“sign", tagP )). Output
skp := sig.
FE.Enc(mpk, msg). Parse mpk = (pk, vk). Sample an ephemeral
key ek ← E.KeyGen(1λ ) and use it to encrypt the message ctm ←
E.Enc(ek, msg). Then, encrypt the ephemeral key under pk along
with the hash of ctm: ctk ← PKE.Enc(pk, [ek, H (ctm )]). Output
ct := (ctk , ctm ).
FE.DecHW,KM(·) (skP , ct). The decryption enclave program QDE
parametrized by P is defined as follows. The security parameter λ
is hardcoded into the program. The QDE here can be seen as the
merge of the QDE and QF E in our first construction.
ra, sk1
ra) and (pk2
ra, pk2
ra), and output (sid, pk1
sk, ct2
QDE (P ):
• On input (“init dec", skP , ctk ):