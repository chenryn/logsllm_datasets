and a ciphertext ct and outputs the decryption msg or âŠ¥.
A PKE scheme PKE is correct if for all Î» and msg âˆˆ â„³,
(cid:12)(cid:12)(cid:12)msgâˆ— (cid:60) query
S.Verify(vk, Ïƒ
, msgâˆ—
) = 1
âˆ—
(cid:20)
(cid:18)
(cid:19)
(cid:12)(cid:12)(cid:12)(cid:12)
(cid:103)
Pr
PKE.Dec
sk, PKE.Enc(pk, msg)
(cid:44) msg
(pk, sk) â† PKE.KeyGen(1Î» )
= negl(Î»)
where the probability is taken over the random coins of the proba-
bilistic algorithms KeyGen, Enc.
A PKE scheme provides confidentiality to the encrypted message.
Formally, a PKE scheme PKE is said to have indistinguishability
security under adaptively chosen ciphertext attack (IND-CCA2) if
there is no polynomial time adversary ğ’œ which can guess bâ€² = b in
the following game with probability non-negligible in Î», plus half.
Definition B.3. (IND-CCA2 security of PKE). We define the fol-
lowing game between a challenger ğ’ and an adversary ğ’œ.
sk) and gives pk to the adversary.
(1) ğ’ runs the PKE.KeyGen algorithm to obtain a key pair (pk,
(2) ğ’œ provides adaptively chosen ct and get back PKE.Dec(sk,
(3) ğ’œ provides msg0, msg1 to ğ’.
(4) ğ’ then runs PKE.Enc(pk) to obtain ctâˆ— = PKE.Enc(pk, msgb )
(5) ğ’œ continues to provide adaptively chosen ct and get back
(6) ğ’œ outputs its guess bâ€².
A PKE scheme may also be â€œweakly robustâ€ [1]. Informally, this
means that a ciphertext when decrypted with an â€œincorrectâ€ secret
key should output âŠ¥ when all the algorithms are honestly run.
for b
PKE.Dec(sk, ct), with a restriction that ct (cid:44) ctâˆ—.
$â† {0, 1}. ğ’ provides ctâˆ— to ğ’œ.
ct).
Definition B.4. ((Weak) robustness property of PKE). A PKE
scheme PKE has the (weak) robustness property if for all Î» and
msg âˆˆ â„³,
Pr
, PKE.Enc(pk, msg)
= negl(Î»)
PKE.Dec
(cid:44)âŠ¥
skâ€²
(cid:18)
(cid:19)
(cid:20)
(cid:21)
where (pk, sk) and (pkâ€², skâ€²) are generated by running PKE.KeyGen(1Î» )
twice, and the probability is taken over the random coins of the
probabilistic algorithms PKE.KeyGen, PKE.Enc.
C SECURITY PROOF LEMMATA
Lemma C.1. If the signature scheme S is existentially unforgeable
as in Definition B.2, then Hybrid 2 is indistinguishable from Hybrid 1.
Proof. Let ğ’œ be an adversary which distinguishes between
Hybrid 1 and Hybrid 2. We will use it to break the EUF-CMA
security of S. We will get a verification key vkâˆ—
sign and an access to
S.Sign(skâˆ—
sign,Â·) oracle from the EUF-CMA challenger. ğ’® sets this
vkâˆ—
sign as part of the mpk. Whenever ğ’® has to sign a message using
sign, it uses the S.Sign(skâˆ—
skâˆ—
sign,Â·) oracle. Also, our construction
does not ever need a direct access to skâˆ—
sign; it is used only to sign
messages for which the oracle provided by the challenger can be
used. Now, if ğ’œ can distinguish between the two hybrids, as we
argued earlier, it is only because ğ’œ makes a â€œprovisionâ€ query to
the HW.Run&Report(hdlDE ,Â·) oracle with a hdlDE âˆˆ ğ’Ÿ that has
vkâˆ—
sign in its , and with a valid signature sig on a tagP (cid:60) ğ’¦. We will
output (tagP , sig) as our forgery to the EUF-CMA challenger. â–¡
Lemma C.2. If the signature scheme S is existentially unforge-
able as in Definition B.2, then Hybrid 3.0 is indistinguishable from
Hybrid 2.
Proof. Let ğ’œ be an adversary which distinguishes between
Hybrid 2 and Hybrid 3.0. We will use it to break the EUF-CMA
security of S. We will get a verification key vkâˆ—
sign and an access to
S.Sign(skâˆ—
sign,Â·) oracle from the EUF-CMA challenger. ğ’® sets this
vkâˆ—
sign as part of the mpk. Whenever ğ’® has to sign a message with
skâˆ—
sign, it uses the S.Sign(skâˆ—
sign,Â·) oracle. As mentioned in the proof
of Lemma C.1, ğ’® never needs a direct access to skâˆ—
sign. Now, if ğ’œ can
distinguish between the two hybrids, as we argued earlier, it is only
because ğ’œ makes a â€œcomplete setupâ€ query to the HW.Run(hdlDE ,
Â·) oracle with a valid signature Ïƒsk for (sid, ctsk ) (cid:60) LK M but sid
has an entry in , . Also, hdlDE âˆˆ ğ’Ÿ and hence has vkâˆ—
sign in its , .
We will output ((sid, ctsk ), Ïƒsk ) as our forgery to the EUF-CMA
challenger.
â–¡
Lemma C.3. If the Local Attestation process of HW is secure as in
Definition A.1, then Hybrid 3.1 is indistinguishable from Hybrid 3.0.
The proof of this lemma is similar to Lemma C.2, since skreport
is not used by ğ’® other than to produce a report.
Lemma C.4. If Remote Attestation is secure as in Definition A.2,
then Hybrid 5.0 is indistinguishable from Hybrid 4.
The proof of this lemma is similar to Lemma C.2 since skquote is
not used by ğ’® except for producing a quote.
Lemma C.5. If Local Attestation is secure as in Definition A.1, then
Hybrid 5.1 is indistinguishable from Hybrid 5.0.
The proof of this lemma is again similar to Lemma C.2 since
skreport is not used by ğ’® except for producing a report.
Lemma C.6. If PKE is an IND-CCA2 secure encryption scheme,
then Hybrid 5.2 is indistinguishable from Hybrid 5.1.
Session D1:  Functional Encryption and ObfuscationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA779Proof. We will run two IND-CCA2 games in parallel, one for
ctsk and another for ctkey. It can be easily shown that this vari-
ant is equivalent to the regular IND-CCA2 security game. The
IND-CCA2 challenger provides two challenge public keys pkâˆ—
1 and
2. ğ’® sets pkra = pkâˆ—
pkâˆ—
is
provided as the challenge message pair for both the games. The
challenger returns ctâˆ—
2, which are encryptions of either the
left messages or the right messages from the each pair. Note that
we use the same challenge bit for both the games. ğ’® sets ctsk = ctâˆ—
1
and ctkey = ctâˆ—
2.
1 and pkla = pkâˆ—
1 and ctâˆ—
skpke, 0|skpke|(cid:41)
2. Now,
(cid:40)
Now we argue that when the left messages are encrypted, the
view of ğ’œ is equivalent to Hybrid 5.1, and when the right messages
are encrypted, the view is equivalent to Hybrid 5.2. This is because
the other information that ğ’œ gets do not depend on the value en-
coded in ctsk or ctkey. We argue this as follows. We have already
established that ğ’œ only gets ctsk encrypted with a pkra generated
in DE from KME. Similarly, ğ’œ only gets ctkey encrypted with a
pkla generated in a valid F E from DE. In addition to these, when
interacting with messages from a valid QDE or QF E (Â·), ğ’® either
uses the skpke from msk or the Umsg oracle to answer the queries
and not the decryption of ctkey.
Hence, when ğ’œ decides between the two hybrids we forward
the corresponding answer to the IND-CCA2 challenger. If ğ’œ can
distinguish between these two hybrids with non-negligible prob-
ability, then the IND-CCA2 security of PKE can be broken with
non-negligible probability.
â–¡
Lemma C.7. If PKE is an IND-CCA2 secure encryption scheme,
then Hybrid 6 is indistinguishable from Hybrid 5.2.
Proof. The IND-CCA2 challenger provides the challenge public
key pkâˆ—. During FE.Setup ğ’® sets pkpke = pkâˆ—. Now, msg and 0|msg|
are provided as the challenge messages. The challenger returns ctâˆ—,
which is an encryption of either of those with equal probability. ğ’®
sets ctmsĞ´ = ctâˆ—. When HW.Run(hdlP , â€œrunâ€, reportsk , ctmsĞ´ ) is
called with a valid reportsk to hdlP âˆˆ ğ’¦ with the honest bit set, ğ’®
uses the Umsgâˆ— oracle for a challenge ciphertext ctmsĞ´ âˆˆ â„› from
Hybrid 4. Now, for any ctmsĞ´ (cid:60) â„›, ğ’® neither has the oracles nor has
the skâˆ— corresponding to pkâˆ— in msk. But, the decryption oracle pro-
vided by the IND-CCA2 challenger can be used for any ctmsĞ´ (cid:60) â„›.
Hence, ğ’® can answer all the HW.Run(hdlP , â€œrunâ€, reportsk , ctmsĞ´ )
queries. Thus, the view of ğ’œ is identical to Hybrid 5 when msg
is encrypted in ctâˆ— and Hybrid 6 when zeros are encrypted in ctâˆ—.
So we can forward the answer corresponding to ğ’œâ€™s answer to
the IND-CCA2 challenger. If ğ’œ can distinguish between these two
hybrids with non-negligible probability, the IND-CCA2 security of
PKE can be broken with non-negligible probability.
â–¡
D STRONGER HW SIMULATION MODEL
Definition D.1 (StrongSimSecurity-FE). Consider a stateful simu-
lator ğ’® and a stateful adversary ğ’œ. Let Umsg (Â·) denote a universal
oracle, such that Umsg (P ) = P (msg).
Both games begin with a pre-processing phase executed by the
environment. In the ideal game, pre-processing is simulated by ğ’®.
Now, consider the following experiments.
Exprealâ„±â„° (1Î» ) :
(1) (mpk, msk) â† FE.Setup(1Î» )
(2) (msg) â† ğ’œFE.Keygen(msk,Â·) (mpk)
(3) ct â† FE.Enc(mpk, msg)
(4) Î± â† ğ’œFE.Keygen(msk,Â·),ğ’ªmsk (Â·) (mpk, ct)
(5) Output (msg, Î± )
Expidealâ„±â„° (1Î» ) :
(1) (mpk, msk) â† FE.Setup(1Î» )
(2) (msg) â† ğ’œğ’® (msk,Â·) (mpk)
(3) ct â† ğ’®Umsg (Â·) (1Î», 1|msg| )
(4) Î± â† ğ’œHW,ğ’®Umsg (Â·) (Â·) (mpk, ct)
(5) Output (msg, Î± )
In the above experiment, oracle calls by ğ’œ to the key-generation
and KM oracles are simulated by the simulator ğ’®Umsg (Â·) (Â·). But the
simulator does not simulate the HW algorithms, except HW.Setup.
We call a simulator admissible if on each input P, it just queries its
oracle Umsg (Â·) on P (and hence learn just P (msg)).
The F E scheme is said to be simulation-secure against adaptive
adversaries if there is an admissible stateful probabilistic polyno-
mial time simulator ğ’® such that for every probabilistic polynomial
time adversary ğ’œ the following distributions are computationally
indistinguishable.
Exprealâ„±â„° (1Î» )
câ‰ˆ Expidealâ„±â„° (1Î» )
E FE CONSTRUCTION IN THE STRONGER
SECURITY MODEL
We present here the formal description of our second FE construc-
tion which can be proven secure in the stronger security models
of HW and FE. The trusted authority platform T A and decryption
node platform DN each have access to instances of HW. We as-
sume HW.Setup(1Î» ) has been called for each of these instances
before they are used in the protocol and the output params was
recorded. Let PKE denote an IND-CCA2 secure public key encryp-
tion scheme (Definition B.3) with the weak robustness property11,
let S denote an existentially unforgeable signature scheme (Defini-
tion B.2) and E denote an IND-CPA secure secret key encryption
scheme (Definition B.1).
FE.Setup(1Î» ). The key manager enclave program QK ME is de-
fined as follows. Let state denote an internal state variable.
QK ME:
â€¢ On input (â€œinit", 1Î» ):
(1) Run (pkpke, skpke) â† PKE.KeyGen(1Î» ) and (vksign, sksign) â† S.KeyGen(1Î» )
(2) Update state to (skpke, sksign, vksign) and output (pkpke, vksign)
â€¢ On input (â€œprovision", quote, params):
(1) Parse quote =(cid:0)mdhdl, tagP , in, out, Ïƒ(cid:1), and parse out = (sid, pk1, pk2,
skP , ctk ).
skpke and vksign from state. If b = 0 output âŠ¥.
(2) Run b â† HW.QuoteVerify(params, quote) on quote. If b = 1, retrieve
(3) Run b â† S.Verify(vksign, skP , tagP ). If b = 0, output âŠ¥.
(4) Run (ek, h) â† PKE.Dec(skpke, ctk )
(5) Compute ct1
ek||vksign)
sk
= PKE.Enc(pk1, ek||vksign) and ct2
= PKE.Enc(pk2,
sk
11We actually need one PKE scheme with IND-CPA security and weak robustness
property and another PKE scheme with IND-CCA2 security
Session D1:  Functional Encryption and ObfuscationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA780sk, ct2
ct2
sk, h, Ïƒsk ).
sk, h)) and output (sid, ct1
sk,
Compute sig â† S.Sign(sksign, msg) and output sig.
(6) Compute Ïƒsk = S.Sign(sksign, (sid, ct1
â€¢ On input (â€œsign", msg):
Run hdlK ME â† HW.Load(params, QK ME ) and (pkpke, vksign) â†
HW.Run(hdlK ME , (â€œinit", 1Î» )). Output the master public key mpk :=
pkpke and the master secret key msk := hdlK ME.
FE.Keygen(msk, P ). Parse msk as a handle to HW.Run. De-
rive tagP and call sig â† HW.Run(hdlK ME , (â€œsign", tagP )). Output
skp := sig.
FE.Enc(mpk, msg). Parse mpk = (pk, vk). Sample an ephemeral
key ek â† E.KeyGen(1Î» ) and use it to encrypt the message ctm â†
E.Enc(ek, msg). Then, encrypt the ephemeral key under pk along
with the hash of ctm: ctk â† PKE.Enc(pk, [ek, H (ctm )]). Output
ct := (ctk , ctm ).
FE.DecHW,KM(Â·) (skP , ct). The decryption enclave program QDE
parametrized by P is defined as follows. The security parameter Î»
is hardcoded into the program. The QDE here can be seen as the
merge of the QDE and QF E in our first construction.
ra, sk1
ra) and (pk2
ra, pk2
ra), and output (sid, pk1
sk, ct2
QDE (P ):
â€¢ On input (â€œinit dec", skP , ctk ):