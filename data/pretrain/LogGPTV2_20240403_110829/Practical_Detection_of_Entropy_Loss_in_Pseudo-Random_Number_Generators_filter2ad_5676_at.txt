against memory attacks, having n-bit state and ‘-bit output, where t0 ≈ t.
5.5 Instantiation
Table 5.1 – Security Bounds for the Robustness of G
against Memory Attacks
qs ∈ {1, 2, 4}
k ∈ {40, 64} λ = 32, 64
1
2
4
40
64
40
64
40
64
32
64
32
64
32
64
32
64
32
64
32
64
n
599
631
863
895
631
665
895
959
695
823
959
1087
γ∗
559
591
799
831
591
625
831
895
655
783
895
1023
We recall that our construction is based on Section 4.3: refresh(S, I) = S · X + I ∈ F2n and
next(S) = G(U), with U = [X0 · S]m1 . In Section 4.3, the standard pseudo-random generator G
is deﬁned by G(U) = AESU(0)k . . .kAESU(ν − 1), where ν is the number of calls to AES with a
128-bit key U, and thus m = 128. For a security parameter k = 40, the security analysis leads to
n = 489, γ∗ = 449, and ν = 5. We now apply Theorem 14 and we obtain the following bounds:
• For k = 40, n = 567 + qsλ, γ∗ = 527 + qsλ.
• For k = 64, n = 831 + qsλ, γ∗ = 767 + qsλ.
Finally, for qs ∈ {1, 2, 4}, k ∈ {40, 64} and λ ∈ {32, 64}, concrete security bounds for G are given
in Table 5.1. Hence:
• for qs = 1, λ = 32, G is ((t0, 240, 240, 1), 32, 559, 2−40)-robust against memory attacks, if
n = 599,
— 88 —
• for qs = 4, λ = 64, G is ((t0, 264, 264, 4), 64, 1023, 2−64)-robust against memory attacks, if
n = 1087 (based on the discussion about the security of AES in Section 4.5).
5.5. Instantiation
— 89 —
Chapter 5. Robustness Against Memory Attacks
— 90 —
Chapter 6
Robustness Against Side-Channel
Attacks
6.1 Model Description
In this chapter we give a syntactic formalization for security of pseudo-random number genera-
tors with input against memory attacks. All statements are part of [ABP+15]. We use Deﬁnition
27 for pseudo-random number generator with input in all this chapter.
Recall that in the robustness security model ROB, in Section 4.1, the distribution sampler D
generates the external inputs used to refresh the generator and already gives the adversary A
some information about how the environment of the generator leaks when it generates these
inputs. This information is modelled by z. In order to model information leakage during the
executions of the algorithms refresh and next, we give the adversary the choice of the leakage
functions, that we globally name f, associated to each algorithm, or even each small block. Since
we restrict our model to non-adaptive leakage, we ask the adversary to choose them beforehand.
So they are provided as input to the initialize procedure by the adversary (see Figure 6.1). Then,
each leakage function will be implicitly used by our two new procedures named leak-refresh
and leak-next that, in addition to the usual outputs, also provide some leakage L about the
manipulated data, as described in Section 3.7.1. We thus have a new parameter λ, that bounds
the output length of the leakage function. Our new Leakage-Resilient Robustness security game
LROB(γ∗, λ) makes use of the procedures described in Figure 6.1 and is described in details
below:
• The parameter γ∗, the variable c, and the Boolean ﬂag/function compromised are the same
as for the basic robustness ROB;
• The new parameter λ sets the maximal information leakage which can be collected during
the execution of operations refresh and next. Namely, for each operation (refresh or next),
the leakage functions globally output at most λ bits. Such a leakage will be available when
querying the leaking procedures leak-refresh and leak-next below;
• The new parameter α is an integer that models the minimal expected entropy of S after
a leak-next (next with leakage) call, in a safe case (compromised is false), that is when the
entropy of the internal state was assumed greater than γ∗. This captures both the creation
of computational entropy during a next execution and the smaller loss of entropy caused by
the leakage. We could expect α = n − λ, but it may depend on the explicit construction;
— 91 —
Chapter 6. Robustness Against Side-Channel Attacks
proc. initialize(D, f)
seed $← setup
σ ← 0;
S ← 0;
c ← 0;
$← {0, 1}
b
OUTPUT seed
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
proc. get-state
c ← 0;
OUTPUT S
)
proc. set-state(S∗)
c ← 0;
S ← S∗
proc. D-refresh
(σ, I, γ, z) $← D(σ)
S ← refresh(S, I)
IF compromised
c ← min(c + γ, n)
OUTPUT (γ, z)
proc. leak-refresh
(
(σ, I, γ, z) $← D(σ)
L ← f(S, I, seed)
S ← refresh(S, I; seed)
c ← max{0, c − λ}
IF cγ∗
c ← 0
OUTPUT (L, γ, z)
proc. next-ror
(S, R0) ← next(S)
IF cγ∗,
c ← 0
RETURN R0
ELSE
$← {0, 1}‘
R1
RETURN Rb
proc. leak-next
L ← f(S, seed)
(S, R) ← next(S; seed)
)
(
IF cγ∗
ELSE
c ← 0
c ← α
OUTPUT (L, R)
Figure 6.1 – Procedures in the Security Game LROB(γ∗, λ)
• The procedures initialize(D, f)/ﬁnalize(b∗) initiate the security game with the additional
leakage function f, check whether the adversary has won the game and output 1 in this
case or 0 otherwise. As in the security game ROB, the initial state S is here set to zero (as
well as the entropy counter) so that no assumption needs to be made on its initialization;
• The procedures get-state/set-state, D-refresh, and next-ror are the same as for the basic
robustness ROB;
• The procedure leak-refresh runs the refresh algorithm but additionally provides some in-
formation leakage L on the input (S, I) and seed, as above. As for the next-ror-queries,
the leakage can reveal non-trivial information about a weak internal state even before the
eﬀectiveness of the refresh, and then we reduce c by λ bits. And if it drops below the
threshold γ∗, it is reset to 0. Again, we could have strengthened this deﬁnition, but we
preferred to keep a conservative notion. Furthermore, this strict notion is important w.r.t.
our new deﬁnitions of recovering and preserving security with leakage. Note that if the
D-refresh algorithm is complex, several leakage functions can be deﬁned at every step,
but the global leakage is limited to λ bits, hence the notation {. . .}, since they can be
interleaved.
• The procedure leak-next runs the next algorithm but additionally provides some informa-
tion leakage L on the input S and seed, according to the leakage function f provided to
the initialize procedure. If the status was safe, then the new entropy estimate c is set to α,
otherwise, it is reset to 0 (as for the next-ror). As above, if the next algorithm is complex,
several leakage functions can be deﬁned at each step, but the global leakage is limited to
λ bits.
As in the security game ROB, attackers have two parts: a distribution sampler and a classical
attacker with the former only used to generate seed-independent inputs (potentially partially
biased) from device activities. Examples of the entropy traces for the procedures deﬁned in
our new model are provided in Figure 6.2 (to be compared with the traces presented in Figure
4.3). The threshold γ∗ has to be slightly higher in our new model, because for a similar next
algorithm, we need to accumulate a bit more of entropy to maintain security even in presence
of leakage. Typically, it has to be increased by λ. Now we detailed the new security game, we
can deﬁne the notion of leakage-resilient robustness of a pseudo-random number generator with
input.
— 92 —
6.2. Analysis and Limitation of the Original Construction
entropy estimate c
threshold γ∗
state length n
entropy α
y
p
o
r
t
n
e
d
e
t
a
m
i
t
s
e
n
o
d
n
u
o
b
-
r
e
w
o
l
n
α
γ∗
0
D-refresh
D-refresh
next-ror
D-refresh
leak-refresh
leak-refresh
D-refresh
Figure 6.2 – Entropy Estimates in LROB(γ∗, λ)
leak-next
D-refresh
leak-next
get-state
set-state
next-ror
Deﬁnition 37 (Leakage-Resilient Robustness of Pseudo-Random Number Generator with In-
put). A pseudo-random number generator with input G = (setup, refresh, next) is called (t, qr, qn,
qs, γ∗, λ, ε)-leakage-resilient robust, if for any adversary A running in time t, that ﬁrst gener-
ates a legitimate distribution sampler D (for the D-refresh/ leak-refresh procedure), that after
makes at most qr calls to D-refresh/leak-refresh, qn calls to next-ror/leak-next, and qs calls to
get-state/set-state with a leakage bounded by λ, the advantage of A in game LROB(γ∗, λ) is at
most ε.
6.2 Analysis and Limitation of the Original Construction
Let us recall the robust construction described in Section 4.3, named G.
It makes use of a
(t, ε)-secure standard pseudo-random generator G : {0, 1}m → {0, 1}n+‘. The seed is a pair
(X, X0) of length 2n, n is the state length, ‘ is the output length, and p = n is the input length.
This construction uses iterated multiplication and addition in the ﬁnite ﬁeld F2n to refresh the
internal state because it gives a proven seeded extractor that accumulates entropy, which we do
not know how to do with a hash function. Plus, it is more eﬃcient:
• setup() outputs seed = (X, X0) ← {0, 1}2n;
• S0 = refresh(S, I; X) = S · X + I, where all operations are over F2n;
• (S0, R) = next(S; X0) = G(U), where U = [X0 · S]m1 , the truncation of X0 · S.
Unfortunately, even a secure standard pseudo-random generator is not enough to resist to infor-