realworld.lit
jabber.org
服务器
服务器
Sister
Mother
Narrator
图7-1
XMPP网络的分布式结构：客户机从不同的域连接到相互
连接的服务器
Message节
提供了把信息从一个实体传递到另一个实体的基本机制。如名字所
示，message节主要用于彼此发送（文本）消息。
Presence节
是一种从网络上的一个实体发送到多个实体的"广播"信息。例如，
如果Alice想通知她的所有朋友她现在不可以聊天，那么她可以发送
下面的presence节：
away
Down the rabbit hole!
1900
---
## Page 1902
她的服务器会把这个节转发给她所有的联系人，通知他们Alice现在
不能聊天。Info/query(IQ)节提供了一种实体间的请求/应答机制，主
要用于在特定实体上查询或改变信息。例如，Alice也许想知道她妹
妹使用的客户端软件的版本，于是她发送下面的节给她的妹妹：
pe,P!o=db>
from="PI:EMAIL/RabbitHole"
to="PI:EMAIL/Home">
0节的唯一标识符，用于匹配接收到的IQ结果与初始的IQ请求。
②特定名字空间中的空白元素（载荷）指明所请求信息的类型（在
这个例子中是软件的版本信息）。
收到这个请求以后，她妹妹的客户软件立刻应答名字和她的客户端
软件的版本号：
from="PI:EMAIL/Home"
to="PI:EMAIL/RabbitHole">
@
Swift
1.0
1901
---
## Page 1903
O应答的id与请求的id相符。
应答的载荷部分包含了查询的结果。
节使用“载荷”（payload）部分来传输信息，这个部分作为子元素加
入到节中。例如，一条消息可以使用body载荷来包含该消息的主体
文本。不同类型的载荷处理方式也是不同的。对载荷添加XML名字
空间后，XMPP协议能够很容易地扩展支持儿乎无限的信息类型，而
不必担心载荷元素名字的冲突。例如，很多早期的XMPP协议扩展
（包括例子中使用的软件版本协议）使用query载荷。通过使用诸如
jabber:iq:version这样的名字空间，当收到一个query载荷的时候，实
体知道它们正在处理的协议是什么类型，并且知道怎么解释这个载
荷。
本节仅仅触及了XMPP的表面，只够帮助你理解本章剩下的内容。如
果你想更深入地了解和使用XMPP，不妨看一看[XMPPTDG]（参看
本章最后的"参考文献"），或者访问http://xmpp.org。
XMPP协议测试
XMIPP应用的一个重要方面，不管是客户程序还是服务器程序，就是
XMPP协议的实际实现。每一个XMPP实现都需要至少包含XMPP核
心协议，IETF在[RFC3920]和[RFC3921]中将其标准化。这些协议为
XMPP提供基本的构造单元，它们描述了XMPP连接如何建立，以及
哪些东西可以通过该连接发送。在这些核心协议之上，XMIPP标准基
金会（XMPPStandardsFoundation）创建了一个不断增加的XMPP扩
展协议（XMPPExtensionProtocol,XEP）列表。这些规范描述了如何
扩展核心协议来实现特定的功能，从简单的功能，例如请求另一个
客户程序的软件版本（在[XEP-0092]中标准化），到复杂的协议，
例如在客户端之间协商语音/视频电话会议、传输文件等。
本章着眼于测试XMPP协议实现的功能，回答诸如“我的客户端正确
问题。我们从讨论最简单的请求-响应协议开始，然后逐步讨论越来
越复杂的协议。随着协议复杂性的增加，我们创建的测试的层次也
越高，从非常特定的单元测试上开到完整的系统测试。尽管我们主
1902
---
## Page 1904
要从客户端开发者的角度来描述测试，但本章使用的很多方法也同
样适用于服务器测试。
简单请求-响应协议的单元测试
许多XMPP协议是很简单的：一端发送一个IQ请求，另一端接收请
求、处理，并响应一个IQ结果。前面讨论的软件版本协议就是一个
简单请求-响应协议的例子。这个协议的实现包含两个部分：
发起者（initiator）发送一个软件版本请求并接收和处理相应的响
应。
·响应者（responder）监听到来的软件版本请求并响应。
通常我们用一个类来实现发起者，另一个类来实现响应者山。例7-1
显示了客户端软件如何创建一个VersionResponder类的实例来响应收
到的软件版本请求。这个类所做的所有工作就是监听到来的属于
jabber:iq:version类型的IQ请求，并且以通过setVersion所设定的值响
应。这个类使用集中的XMPPClient类来发送数据到XMPP连接并接收
来自XMPP连接的数据。
例7-1：使用VersionResponder来监听和响应软件版本请求
class MyClient
MyClientO{
xmppClient=new XMPPClient("PI:EMAIL","mypass");
versionResponder=newVersionResponder(xmppClient);
versionResponder->setVersion("Swift","0.1");
xmppClient->connectO;
1
1;
1903
---
## Page 1905
因为这种请求-响应协议是在本地类中实现的，所以，单元测试是测
试这个协议实现的功能的好方法。下面我们来看看如何对这个
VersionResponder类进行单元测试。
首先，我们需要确定可以创建Responder的一个独立的实例。这个类
的唯一依赖是XMPPClient，它是用来建立和管理XMPP连接的类。建
立和管理连接包含许多工作，并且也依赖于其他的类，如网络交
互、认证、加密机制等。幸运的是，VersionResponder所需要做的所
有工作就是从数据流发送和接收数据。因此，它仅需依赖一个
DataChannel接口，这个接口提供了发送数据的方法和接收数据的信
令，如例7-2所示。在我们的单元测试中，客户端可以很容易地虚拟
这个接口。
例7-2：抽象化DataChannel接口中的数据交互：XMPPClient类是这个
接口的具体实现
classDataChannel
public:
virtual void sendData(const string& data)=0;
boost:signalonDataReceived;
O信令onDataReceived有一个字符串参数（但没有返回值）。当信令
发出以后，包含有接收数据的这个字符串将被传递给相连时槽的处
理函数。
现在已经万事俱备，我们来试着写一个单元测试。例7-3显示了我们
将如何测试响应者的基本行为，分别使用一个虚拟数据信道来产生
接收数据和获取发送数据。
例7-3：使用原始的序列化XML数据来测试VersionResponder
1904
---
## Page 1906
void VersionResponderTest:testHandleIncomingRequestO 
/Set up the test fxture
MockDataChannel dataChannel;
VersionResponder responder(& dataChannel);
responder.setVersion("Swif","1.0");
/Fake incoming request data on the data channel
dataChannel.onDataReceived(
""
""
"");
 /Verify the outcome
ASSERT_EQUAL(
""
"Swift"
<>"
"",
dataChannel.sentData);
1905
---
## Page 1907
乍一看，这个单元测试似乎还不错：短小，易于理解，具有单元测
试风格的结构，并且将协议测试与XMPP的低层网络细节分离开来。
然而，它仅仅是看起来不错，因为它非常脆弱。为了理解这一点，
我们需要看看XMPP实现是如何对一个请求进行响应的。
当XMPP客户端创建XML节的时候，它通常生成一个结构化的文档
（例如，使用文档对象模型[DocumentObjectModel,DOM]API），然
后把这个文档序列化为XML文本，然后再发送到网络上。例7-3中，
我们的测试精确记录了被测响应者所产生的序列化XML节，然后把
它与期待的XML片段进行比较。这种方法的问题在于，相同的XML
元素可以用不同的正确方式来序列化。例如，我们可以交换
元素中的from和type属性的次序，而仍然得到逻辑上等同的节。这意
味着节的序列化过程中的一个最小的变化都可以导致所有测试的失
败。
避免这种由XML序列化所导致的脆弱性的一种解决方法是确保序列
化后的节始终保持规范XML（CanonicalXML）的形式（参见[XML
C14n）。在移除了诸如属性次序和空格符等无意义的属性以后，这
个XML子集保证了两个等价的XML节可以用一种稳定的方式进行比
较，从而解决了测试的脆弱性问题。可惜的是，由于XMPP实现通常
会使用现成的XML的实现，它们通常不会直接控制XML的序列化，
所以我们无法使用这个技巧来进行节的比较。
多数XMPP实现用来验证响应的方法是检查响应的结构化DOM形
式，而不是比较序列化形式。如例7-4所示，这意味着我们的
VersionResponder不再通过接口发送原始数据，而是依赖一个更为结
构化的XMLElementChannel接口来发送和接收以XML元素的数据结构
形式表示的节。
例7-4：使用结构化的XML表示来测试VersionResponder；这个测试不
再受到XMIL节的序列化方式变化的影响（例如，不同的属性次序、
多余的空格）
voidVersionResponderTest:testHandlelncomingRequest()