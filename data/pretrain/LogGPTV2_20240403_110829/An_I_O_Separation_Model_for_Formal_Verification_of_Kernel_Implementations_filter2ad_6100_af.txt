I/OMMU vulnerability,” in Proc. Int. Conf. on Malicious and Unwanted
Software, MALWARE, 2010, pp. 7–14.
[11] A. Markuze, A. Morrison, and D. Tsafrir, “True IOMMU protection
from DMA attacks: When copy is faster than zero copy,” in ASPLOS,
2016, pp. 249–262.
[12] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell,
H. Tuch, and S. Winwood, “sel4: Formal veriﬁcation of an os kernel,”
in ACM SOSP, 2009, pp. 207–220.
[13] A. Vasudevan, S. Chaki, L. Jia, J. McCune, J. Newsome, and A. Datta,
“Design, implementation and veriﬁcation of an eXtensible and Modular
Hypervisor Framework,” in IEEE S&P, 2013, pp. 430–444.
[14] A. Vasudevan, S. Chaki, P. Maniatis, L. Jia, and A. Datta, “¨uberspark:
Enforcing veriﬁable object abstractions for automated compositional
security analysis of a hypervisor,” in USENIX Security, 2016, pp. 87–
104.
[15] A. Ferraiuolo, A. Baumann, C. Hawblitzel, and B. Parno, “Komodo: Us-
ing veriﬁcation to disentangle secure-enclave hardware from software,”
in ACM SOSP, 2017, pp. 287–305.
[16] I. GreenHills Software, “Integrity-178b separation kernel security tar-
get,” https://www.commoncriteriaportal.org/ﬁles/epﬁles/st vid10362-st.
pdf [Accessed on 2 Dec 2020], 2010.
[17] J. M. Rushby, “Separation and integration in MILS (The MILS Consti-
tution),” in Technical Report SRI-CSL-08-XX, February 2008.
[18] P. Colp, M. Nanavati, J. Zhu, W. Aiello, G. Coker, T. Deegan,
P. Loscocco, and A. Warﬁeld, “Breaking up is hard to do: Security
and functionality in a commodity hypervisor,” in ACM SOSP, 2011, pp.
189–202.
[19] Z. Zhou, V. D. Gligor, J. Newsome, and J. M. McCune, “Building
veriﬁable trusted path on commodity x86 computers,” in IEEE S&P,
2012.
[20] K. R. M. Leino, “Dafny: An automatic program veriﬁer for functional
correctness,” in LPAR’10, 2010, pp. 348–370. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1939141.1939161
[21] Z. Zhou, M. Yu, and V. D. Gligor, “Dancing with giants: Wimpy kernels
for on-demand isolated I/O,” in IEEE S&P, 2014, pp. 308–323.
[22] B. Bond, C. Hawblitzel, M. Kapritsos, K. R. M. Leino, J. R. Lorch,
B. Parno, A. Rane, S. Setty, and L. Thompson, “Vale: Verifying high-
performance cryptographic assembly code,” in USENIX Security, 2017,
pp. 917–934.
[23] R. Achermann, N. Hossle, L. Humbel, D. Schwyn, D. Cock, and
T. Roscoe, “A least-privilege memory protection model for modern
hardware,” 2019.
[24] T. Shanley and D. Anderson, PCI System Architecture, 4th ed. Addison-
Wesley Professional, 1999.
[25] The System Management Interface Forum (SMIF), Inc., “System Man-
agement Bus (SMBus) Speciﬁcation Version 2.0,” 2000.
[26] K. Koscher, A. Czeskis, F. Roesner, S. Patel, T. Kohno, S. Checkoway,
D. McCoy, B. Kantor, D. Anderson, H. Shacham, and S. Savage,
“Experimental security analysis of a modern automobile,” in IEEE S&P,
2010, pp. 447–462.
[27] ARM, “ARM AMBA 5 AHB Protocol Speciﬁcation,” 2015.
[28] O. Peleg, A. Morrison, B. Serebrin, and D. Tsafrir, “Utilizing the
IOMMU scalably,” in USENIX ATC, 2015, pp. 549–562.
[29] J. Zaddach, A. Kurmus, D. Balzarotti, E. Blass, A. Francillon, T. Good-
spped, M. Gupta, and I. Koltsidas, “Implementation and implications of
a stealth hard-drive backdoor,” in ACM ACSAC, 2013.
[30] C. L. Rothwell, “Exploitation from malicious PCI Express peripherals,
PhD Thesis, University of Cambridge, Computer Laboratory, UCAM-
CL-TR-934,” Feb 2019.
[31] T. Markettos, C. Rothwell, B. Gutstein, A. Pearce, P. Neumann,
S. Moore, and R. Watson, “Thunderclap: Exploring vulnerabilities in
operating system IOMMU protection via DMA from untrustworthy
peripherals,” in NDSS, 2019.
[32] J. Applebaum,
Back Doors
J. Horchert, and C. Stocker, “Catalog Reveals
2013.
https://www.spiegel.de/international/world/
NSA Has
[Online].
catalog-reveals-nsa-has-back-doors-for-numerous-devices-a-940994.
html
for Numerous Devices,”
Available:
[33] S. Anthony, “Massive, undetectable security ﬂaw in USB: It’s time to
get your PS/2 keyboard out of the cupboard,” Extreme Tech, no. July
31, 2014. [Online]. Available: https://www.extremetech.com
[34] L. Mearian, “There’s no way of knowing if the NSA’s spyware is on
your hard drive,” Computerworld, vol. 2, 2015.
[35] L. Constantin, “What is a “Supply Chain Attack?”,” in Motherboard,
Sept. 2017. [Online]. Available: https://motherboard.vice.com/en us/
article/d3y48v/what-is-a-supply-chain-attack
[36] V. Gligor and M. Woo, “Establishing software root of trust uncondition-
ally,” in NDSS, 2019.
Identiﬁer
[37] Trusted Computing Group,
a
[Online].
Device
Available:
https://trustedcomputinggroup.org/wp-content/uploads/
Hardware-Requirements-for-Device-Identiﬁer-Composition-Engine-r78
For-Publication.pdf
“Hardware Requirements
Composition
Engine,”
2018.
for
[38] M. Yu, V. D. Gligor, and Z. Zhou, “Trusted display on untrusted
commodity platforms,” in ACM CCS, 2015, pp. 989–1003.
[39] D. Cerdeira, N. Santos, P. Fonseca, and S. Pinto, “SoK: Understanding
the prevailing security vulnerabilities in TrustZone-assisted TEE sys-
tems,” in IEEE S&P, May 2020.
[40] J. M. McCune, Y. Li, N. Qu, Z. Zhou, A. Datta, V. Gligor, and A. Perrig,
“TrustVisor: Efﬁcient TCB reduction and attestation,” in IEEE S&P,
2010.
[41] V. Costan and S. Devadas, “Intel SGX explained,” Cryptology ePrint
Archive, Report 2016/086, 2016, https://eprint.iacr.org/2016/086.
[42] Wikipedia, “CAN bus,” 2019. [Online]. Available: https://en.wikipedia.
org/wiki/CAN bus
[43] P. Barham, B. Dragovic, K. Fraser, S. Hand, T. Harris, A. Ho, R. Neuge-
bauer, I. Pratt, and A. Warﬁeld, “Xen and the art of virtualization,” in
ACM SOSP, 2003.
[44] J. M. Rushby, “Design and veriﬁcation of secure systems,” vol. 15, no. 5,
pp. 12–21, 1981.
[45] K. Tian, Y. Dong, and D. Cowperthwaite, “A full GPU virtualization
solution with mediated pass-through,” in USENIX ATC, 2014, pp. 121–
132.
[46] M. Peinado, Y. Chen, P. Engl, and J. Manferdelli, “NGSCB: A Trusted
Open System,” in Proc. Australasian Conference on Information Security
and Privacy, 2004.
[47] Y. Cheng and X. Ding, “Guardian: Hypervisor as security foothold for
personal computers,” in TRUST, 2013.
[48] Z. Zhou, J. Han, Y.-H. Lin, A. Perrig, and V. Gligor, “Kiss: Key it simple
and secure corporate key management,” in TRUST, 2013.
[49] S. Weiser and M. Werner, “SGXIO: Generic trusted i/o path for Intel
SGX,” in CODASPY, 2017, pp. 261–268.
[50] P. Loscocco and S. Smalley, “Integrating ﬂexible support for security
policies into the linux operating system,” in USENIX ATC, 2001, pp.
29–42.
[51] T. Murray, D. Matichuk, M. Brassil, P. Gammie, T. Bourke, S. Seefried,
C. Lewis, X. Gao, and G. Klein, “Sel4: From general purpose to a proof
of information ﬂow enforcement,” in IEEE S&P, 2013, pp. 415–429.
[52] H. Mai, E. Pek, H. Xue, S. T. King, and P. Madhusudan, “Verifying
security invariants in ExpressOS,” in ASPLOS, 2013, pp. 293–304.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
585
APPENDIX A
A. Operations for I/O Separation Model
Each operation in the I/O separation model takes the current
state k and the operation arguments and returns the resulting
state k(cid:2) as well as a boolean (decision) value d, indicating
whether the operation is successful. When d is true, the oper-
ation completes successfully; when d is false, the operation is
denied and k(cid:2) = k. We present the transition deﬁned by each
operation below.
(1) Driver Write:
DrvWrite(drv id , td id val , fddo id val ). The driver with
ID drv id attempts to update TDs with new values td id val
and the FDs and DOs with new values fddo id val. The
I/O kernel performs the following two checks: (1) the driver
must be in the same partition as all the objects speciﬁed by
td id val and fddo id val; and (2) for the transitive closure,
tc of the TD state in the updated system state, knew , all the
objects to which transfers could be issued by any active device
in knew must be in the same partition as the device and must
not include a hardcoded TD.
(2) Device Write:
DevWrite(dev id , td id val , fddo id val ). Like drivers, a
device can also issue write requests. The state is updated
without any checks. This is because device writes can only
occur either as deﬁned by the device’s hardcoded TD, which
references device’s object only, or after appropriate driver
write operations, which have already been allowed by the I/O
kernel; see Section IV-B1.
(3) Driver Read:
DrvRead (drv id , read objs id , obj dst src). The driver
with ID drv id attempts to read objects identiﬁed by their
IDs in read objs and stores a subset of the read values to
objects with IDs speciﬁed by the last parameter obj dst src,
which maps destination object IDs to source object IDs. The
I/O kernel checks that (1) the driver is in same partition as
all objects in read objs; and (2) the writes to the destination
objects are allowed by the same checks as those speciﬁed in
the Driver Write operation.
(4) Device Read:
DevRead(dev id, read objs, obj dst src). Device
read
performs similar functions as Driver Read, and is always
allowed under the same conditions for Device write.
(5) Create Empty Partition:
EmptyPartitionCreate(new pid ). To create a new I/O par-
tition with ID new pid, the ID new pid must be a fresh ID;
i.e., an ID that has not been used before.
(6) Destroy Empty Partition:
EmptyPartitionDestroy(pid ). This operation destroys an
empty I/O partition pid. The partition ID pid must not be
NULL and in the set of existing partition IDs in the current
state. Furthermore, no subject or object can exist
in the
partition pid.
(7, 8, 9) Driver/Device/External Objects Activation:
DrvActivate(drv id , pid ), DevActivate(dev id , pid ), and
ids, pid ). These operations acti-
ExternalObjsActivate(obj
vate the given subject and external objects into the partition
with ID pid. The I/O kernel checks that in the current state:
(1) The given subject and external objects must be inactive,
and (2) the partition pid exists in the set of non-NULL
partition IDs. Then, to fulﬁll the security property SP2, the
kernel clears the subject’s objects and all external objects to
prevent object reuse between partitions, but not modifying
any given device’s (immutable) hardcoded TD. Finally, the
given subject’s partition ID, its objects’ partition ID and given
external objects’ partition ID are updated to pid.
(10, 11, 12) Driver/Device/External Objects Deactiva-
tion: DrvDeactivate(drv id ), DevDeactivate(dev id ), and
ids, pid ). These operations de-
ExternalObjsDeactivate(obj
activate the given subject and external objects. The I/O kernel
ﬁrst checks that they are active. Then the I/O kernel computes
the transitive closure (tc) of the TD state in the current system
state. The kernel checks tc to ensure that no active device
can issue transfers to any objects of the given subject, nor
to the given external objects. On success checks, the kernel
updates the partition ID of the given subject and its objects to
be NULL.
B. Dafny Speciﬁcation Example
Simpliﬁed Speciﬁcations of Operations. Figure 9 presents a
simpliﬁed Dafny speciﬁcation of the Device Write operation.
The operation takes the current state k, the ID of the device
issuing the write transfer, and IDs of objects to be modiﬁed
together with the new values to be written. The operation
returns the resulting state k(cid:2), as well as a boolean value d
to indicate whether the operation is allowed or denied. Then
the speciﬁcation presents the preconditions and postconditions
of the operation. The operation requires the current state k
fulﬁlling all the state invariants. The device must be active, and
the write transfers must be deﬁned in TDs. After the operation
returns, it ensures that the result state k(cid:2) fulﬁlls all the state
invariants, and the operation fulﬁlls all transition properties.
The body of the operation speciﬁes the operation implementa-
tion ﬁrst, then proves the implementation against all speciﬁed
postconditions of the operation given the preconditions. All
other operations are formally speciﬁed under the same schema.
State Transition.
The model calls K CALCNEWSTATE
function to apply a single transition; that is, an operation on
the state k. As shown in Figure 10, the function takes a state
k, and the operation name op corresponding to the transition
taking place. After the transition is done, it returns the result
state and the boolean decision value d. The function requires
state k secure; i.e., fulﬁlling all state invariants, because all
operations taking a secure state ends up at a secure state only.
The function further requires operations’ preconditions always
imply operations’ postconditions, and the preconditions hold
for the given operation op. The ﬁrst statement is always true
according to the speciﬁcations of operations. And the second
statement is also always true, because operations can only take
place after their preconditions are met.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
586
method DevWrite (
k: State ,
dev sid : Subject
ID ,
ID of
the device issues the w r i t e access
td id val map: map,
IDs of TDs , and values to be w r i t t e n
fd id val map: map,
IDs of FDs , and values to be w r i t t e n
do id val map: map
IDs of DOs, and values to be w r i t t e n
returns ( k ’ : State , d: bool )
/ /
/ /
/ /
/ /
/ / Return k ’ as new state , d as allow / deny decision
requires I s V a l i d S t a t e ( k ) ∧ IsSecureState ( k )
/ / Requirement: k f u l f i l l s a l l SIs
requires Dev ID ( dev sid )
requires SubjPID ( k , dev sid ) (cid:4)= NULL
in k . s u b j e c t s . devs
/ / Requirement: Device i s i n s t a t e and i s a c t i v e
requires ∀ t d i d 2 • t d i d 2 in td id val map
=⇒ DevWrite WriteTDWithValMustBeInATransfer (
k , dev sid ,
td id2 ,
td id val map [ t d i d 2 ] )
requires ∀ f d i d 2 • f d i d 2 in fd id val map
=⇒ DevWrite WriteFDWithValMustBeInATransfer (
k , dev sid ,
fd id2 ,
fd id val map [ f d i d 2 ] )
requires ∀ do id2 • do id2 in do id val map
=⇒ DevWrite WriteDOWithValMustBeInATransfer (
k , dev sid , do id2 , do id val map [ do id2 ] )
/ / Requirement:
/ / TDs f i r s t
Issued t r a n s f e r s must be defined i n
ensures I s V a l i d S t a t e ( k ’ ) ∧ IsSecureState ( k ’ )
/ / Property : k ’
f u l f i l l s a l l SIs
ensures IsSecureOps ( k , k ’ )
/ / Property : DevWrite f u l f i l l s a l l TCs defined i n
/ /
IsSecureOps
ensures (∀ t d i d • t d i d in td id val map
(∀ f d i d • f d i d in fd id val map
(∀ do id • do id in do id val map
=⇒ t d i d in k . o b j e c t s . tds ) ∧
=⇒ f d i d in k . o b j e c t s . fds ) ∧
=⇒ do id in k . o b j e c t s . dos )
/ / Property : W r i t t e n o b j e c t s are i n the I /O s t a t e
ensures SubjWrite ObjsToWriteMustHaveSamePIDWithSubj (
fd id val map ,
td id val map ,
k , dev sid ,
do id val map )
/ / Property : A l l w r i t t e n o b j e c t s must be i n the
/ / same p a r t i t i o n w i t h the device
. . ..
/ / A d d i t i o n a l proved p r o p e r t i e s , e . g . ,
/ / always r e t u r n s t r u e
the operation
/ / Operation implementation
var tds ’
var fds ’
var dos ’
td id val map ) ;
:= WriteTDsVals ( k . o b j e c t s . tds ,
:= WriteFDsVals ( k . o b j e c t s . fds ,
fd id val map ) ;
:= WriteDOsVals ( k . o b j e c t s . dos , do id val map ) ;
var k ’ subjects := k . s u b j e c t s ;
var k ’ objects := Objects ( tds ’ ,
fds ’ , dos ’ ) ;
:= State ( k ’ subjects , k ’ objects , k . pids ) ;
k ’
d := true ;
/ / Proof of operation p r o p e r t i e s
. . .
Fig. 9. Simpliﬁed Device Write Operation in Dafny
)
{
}
The body of the K CALCNEWSTATE function returns an
arbitrary state fulﬁlling the post-conditions of operation op.
Note that, this function does not compute the result state k(cid:2)
by applying the implementations of operations. The operation
correctness properties are not used in proving the theorem 1,
2 and Corollary 1, as long as the result state k(cid:2) fulﬁlls
the postconditions of operations. The K CALCNEWSTATE
function is deﬁned as Dafny function to enable its use in the
proof of the theorems and the corollary.
function K CalcNewState ( k: State , op: Op)
( r e s u l t : ( State , bool ) )
requires I s V a l i d S t a t e ( k ) ∧ IsSecureState ( k )
: