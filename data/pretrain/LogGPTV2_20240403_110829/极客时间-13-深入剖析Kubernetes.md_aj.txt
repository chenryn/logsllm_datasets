# 在容器内部新建了一个文件root@4ddf4638572d:/app
# touch test.txtroot@4ddf4638572d:/app
# exit 
# 将这个新建的文件提交到镜像中保存$ docker commit 4ddf4638572d geektime/helloworld:v2这里，我使用了 docker exec 命令进入到了容器当中。在了解了 LinuxNamespace 的隔离机制后，你应该会很自然地想到一个问题：[docker exec是怎么做到进入容器里的呢？]{.orange}实际上，Linux Namespace 创建的隔离空间虽然看不见摸不着，但一个进程的Namespace 信息在宿主机上是确确实实存在的，并且是以一个文件的方式存在。比如，通过如下指令，你可以看到当前正在运行的 Docker容器的进程号（PID）是 25686：    $ docker inspect --format '{{ .State.Pid }}'  4ddf4638572d25686这时，你可以通过查看宿主机的 proc 文件，看到这个 25686 进程的所有Namespace 对应的文件：    $ ls -l  /proc/25686/nstotal 0lrwxrwxrwx 1 root root 0 Aug 13 14:05 cgroup -> cgroup:[4026531835]lrwxrwxrwx 1 root root 0 Aug 13 14:05 ipc -> ipc:[4026532278]lrwxrwxrwx 1 root root 0 Aug 13 14:05 mnt -> mnt:[4026532276]lrwxrwxrwx 1 root root 0 Aug 13 14:05 net -> net:[4026532281]lrwxrwxrwx 1 root root 0 Aug 13 14:05 pid -> pid:[4026532279]lrwxrwxrwx 1 root root 0 Aug 13 14:05 pid_for_children -> pid:[4026532279]lrwxrwxrwx 1 root root 0 Aug 13 14:05 user -> user:[4026531837]lrwxrwxrwx 1 root root 0 Aug 13 14:05 uts -> uts:[4026532277可以看到，一个进程的每种 Linux Namespace，都在它对应的/proc/\[进程号\]/ns 下有一个对应的虚拟文件，并且链接到一个真实的Namespace 文件上。有了这样一个可以"hold 住"所有 Linux Namespace 的文件，我们就可以对Namespace 做一些很有意义事情了，比如：加入到一个已经存在的 Namespace当中。**这也就意味着：一个进程，可以选择加入到某个进程已有的 Namespace当中，从而达到"进入"这个进程所在容器的目的，这正是 docker exec的实现原理。**而这个操作所依赖的，乃是一个名叫 setns() 的 Linux系统调用。它的调用方法，我可以用如下一段小程序为你说明：    #define _GNU_SOURCE#include #include #include #include #include  #define errExit(msg) do { perror(msg); exit(EXIT_FAILURE);} while (0) int main(int argc, char *argv[]) {    int fd;        fd = open(argv[1], O_RDONLY);    if (setns(fd, 0) == -1) {        errExit("setns");    }    execvp(argv[2], &argv[2]);     errExit("execvp");}这段代码功能非常简单：它一共接收两个参数，第一个参数是argv\[1\]，即当前进程要加入的 Namespace 文件的路径，比如/proc/25686/ns/net；而第二个参数，则是你要在这个 Namespace里运行的进程，比如 /bin/bash。这段代码的的核心操作，则是通过 open() 系统调用打开了指定的 Namespace文件，并把这个文件的描述符 fd 交给 setns() 使用。在 setns()执行后，当前进程就加入了这个文件对应的 Linux Namespace 当中了。现在，你可以编译执行一下这个程序，加入到容器进程（PID=25686）的 NetworkNamespace 中：    $ gcc -o set_ns set_ns.c $ ./set_ns /proc/25686/ns/net /bin/bash $ ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:02            inet addr:172.17.0.2  Bcast:0.0.0.0  Mask:255.255.0.0          inet6 addr: fe80::42:acff:fe11:2/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:12 errors:0 dropped:0 overruns:0 frame:0          TX packets:10 errors:0 dropped:0 overruns:0 carrier:0   collisions:0 txqueuelen:0           RX bytes:976 (976.0 B)  TX bytes:796 (796.0 B) lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0  collisions:0 txqueuelen:1000           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)正如上所示，当我们执行 ifconfig命令查看网络设备时，我会发现能看到的网卡"变少"了：只有两个。而我的宿主机则至少有四个网卡。这是怎么回事呢？实际上，在 setns() 之后我看到的这两个网卡，正是我在前面启动的 Docker容器里的网卡。也就是说，我新创建的这个 /bin/bash进程，由于加入了该容器进程（PID=25686）的 NetworkNamepace，它看到的网络设备与这个容器里是一样的，即：/bin/bash进程的网络设备视图，也被修改了。而一旦一个进程加入到了另一个 Namespace 当中，在宿主机的 Namespace文件上，也会有所体现。在宿主机上，你可以用 ps 指令找到这个 set_ns 程序执行的 /bin/bash进程，其真实的 PID 是 28499：    
# 在宿主机上ps aux | grep /bin/bashroot     28499  0.0  0.0 19944  3612 pts/0    S    14:15   0:00 /bin/bash这时，如果按照前面介绍过的方法，查看一下这个 PID=28499 的进程的Namespace，你就会发现这样一个事实：    $ ls -l /proc/28499/ns/netlrwxrwxrwx 1 root root 0 Aug 13 14:18 /proc/28499/ns/net -> net:[4026532281] $ ls -l  /proc/25686/ns/netlrwxrwxrwx 1 root root 0 Aug 13 14:05 /proc/25686/ns/net -> net:[4026532281在 /proc/\[PID\]/ns/net 目录下，这个 PID=28499 进程，与我们前面的 Docker容器进程（PID=25686）指向的 Network Namespace文件完全一样。这说明这两个进程，共享了这个名叫 net:\[4026532281\] 的Network Namespace。此外，Docker还专门提供了一个参数，可以让你启动一个容器并"加入"到另一个容器的 NetworkNamespace 里，这个参数就是 -net，比如:    $ docker run -it --net container:4ddf4638572d busybox ifconfig这样，我们新启动的这个容器，就会直接加入到 ID=4ddf4638572d的容器，也就是我们前面的创建的 Python 应用容器（PID=25686）的 NetworkNamespace 中。所以，这里 ifconfig返回的网卡信息，跟我前面那个小程序返回的结果一模一样，你也可以尝试一下。而如果我指定--net=host，就意味着这个容器不会为进程启用 NetworkNamespace。这就意味着，这个容器拆除了 Network Namespace的"隔离墙"，所以，它会和宿主机上的其他普通进程一样，直接共享宿主机的网络栈。这就为容器直接操作和使用宿主机网络提供了一个渠道。**转了一个大圈子，我其实是为你详细解读了 docker exec 这个操作背后，LinuxNamespace 更具体的工作原理。****这种通过操作系统进程相关的知识，逐步剖析 Docker容器的方法，是理解容器的一个关键思路，希望你一定要掌握。**现在，我们再一起回到前面提交镜像的操作 docker commit 上来吧。dockercommit，实际上就是在容器运行起来后，把最上层的"可读写层"，加上原先容器镜像的只读层，打包组成了一个新的镜像。当然，下面这些只读层在宿主机上是共享的，不会占用额外的空间。而由于使用了联合文件系统，你在容器里对镜像 rootfs所做的任何修改，都会被操作系统先复制到这个可读写层，然后再修改。这就是所谓的：Copy-on-Write。而正如前所说，Init 层的存在，就是为了避免你执行 docker commit 时，把Docker 自己对 /etc/hosts 等文件做的修改，也一起提交掉。有了新的镜像，我们就可以把它推送到 Docker Hub 上了：    $ docker push geektime/helloworld:v2你可能还会有这样的问题：我在企业内部，能不能也搭建一个跟 Docker Hub类似的镜像上传系统呢？当然可以，这个统一存放镜像的系统，就叫作 DockerRegistry。感兴趣的话，你可以查看[Docker的官方文档](https://docs.docker.com/registry/)，以及[VMware 的 Harbor项目](https://github.com/goharbor/harbor)。最后，我再来讲解一下 Docker项目另一个重要的内容：Volume（数据卷）。]{.orange}前面我已经介绍过，容器技术使用了 rootfs 机制和 MountNamespace，构建出了一个同宿主机完全隔离开的文件系统环境。这时候，我们就需要考虑这样两个问题：1.  容器里进程新建的文件，怎么才能让宿主机获取到？2.  宿主机上的文件和目录，怎么才能让容器里的进程访问到？这正是 Docker Volume 要解决的问题：**Volume机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。**在 Docker 项目里，它支持两种 Volume声明方式，可以把宿主机目录挂载进容器的 /test 目录当中：    $ docker run -v /test ...$ docker run -v /home:/test ...而这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进了容器的/test 目录。只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker就会默认在宿主机上创建一个临时目录/var/lib/docker/volumes/\[VOLUME_ID\]/\_data，然后把它挂载到容器的 /test目录上。而在第二种情况下，Docker 就直接把宿主机的 /home 目录挂载到容器的/test 目录上。那么，Docker又是如何做到把一个宿主机上的目录或者文件，挂载到容器里面去呢？难道又是Mount Namespace 的黑科技吗？实际上，并不需要这么麻烦。在《白话容器基础（三）：深入理解容器镜像》的分享中，我已经介绍过，当容器进程被创建之后，尽管开启了Mount Namespace，但是在它执行 chroot（或者pivot_root）之前，容器进程一直可以看到宿主机上的整个文件系统。而宿主机上的文件系统，也自然包括了我们要使用的容器镜像。这个镜像的各个层，保存在/var/lib/docker/aufs/diff 目录下，在容器进程启动后，它们会被联合挂载在/var/lib/docker/aufs/mnt/ 目录中，这样容器所需的 rootfs 就准备好了。所以，我们只需要在 rootfs 准备好之后，在执行 chroot 之前，把 Volume指定的宿主机目录（比如 /home 目录），挂载到指定的容器目录（比如 /test目录）在宿主机上对应的目录（即 /var/lib/docker/aufs/mnt/\[可读写层ID\]/test）上，这个 Volume 的挂载工作就完成了。更重要的是，由于执行这个挂载操作时，"容器进程"已经创建了，也就意味着此时Mount Namespace已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就**保证了容器的隔离性不会被Volume 打破**。> 注意：这里提到的 \" 容器进程 \"，是 Docker 创建的一个容器初始化进程> (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit> 会负责完成根目录的准备、挂载设备和目录、配置 hostname> 等一系列需要在容器内进行的初始化操作。最后，它通过 execv()> 系统调用，让应用进程取代自己，成为容器里的 PID=1 的进程。而这里要使用到的挂载技术，就是 Linux 的**绑定挂载（bindmount）机制**。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。其实，如果你了解 Linux 内核的话，就会明白，绑定挂载实际上是一个 inode替换的过程。在 Linux 操作系统中，inode可以理解为存放文件内容的"对象"，而 dentry，也叫目录项，就是访问这个inode 所使用的"指针"。![](Images/ee090e202de9a17c13618d128f39b386.png){savepage-src="https://static001.geekbang.org/resource/image/95/c6/95c957b3c2813bb70eb784b8d1daedc6.png"}\正如上图所示，mount \--bind /home /test，会将 /home 挂载到 /test上。其实相当于将 /test 的 dentry，重定向到了 /home 的inode。这样当我们修改 /test 目录时，实际修改的是 /home 目录的inode。这也就是为何，一旦执行 umount 命令，/test目录原先的内容就会恢复：因为修改真正发生在的，是 /home 目录里。**所以，在一个正确的时机，进行一次绑定挂载，Docker就可以成功地将一个宿主机上的目录或文件，不动声色地挂载到容器中。**这样，进程在容器里对这个 /test目录进行的所有操作，都实际发生在宿主机的对应目录（比如，/home，或者/var/lib/docker/volumes/\[VOLUME_ID\]/\_data）里，而不会影响容器镜像的内容。那么，这个 /test 目录里的内容，既然挂载在容器 rootfs的可读写层，它会不会被 docker commit 提交掉呢？也不会。这个原因其实我们前面已经提到过。容器的镜像操作，比如 dockercommit，都是发生在宿主机空间的。而由于 Mount Namespace的隔离作用，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的/test 目录（/var/lib/docker/aufs/mnt/\[可读写层ID\]/test），**始终是空的。**不过，由于 Docker 一开始还是要创建 /test 这个目录作为挂载点，所以执行了docker commit 之后，你会发现新产生的镜像里，会多出来一个空的 /test目录。毕竟，新建目录操作，又不是挂载操作，Mount Namespace对它可起不到"障眼法"的作用。结合以上的讲解，我们现在来亲自验证一下：首先，启动一个 helloworld 容器，给它声明一个 Volume，挂载在容器里的/test 目录上：    $ docker run -d -v /test helloworldcf53b766fa6f容器启动之后，我们来查看一下这个 Volume 的 ID：    $ docker volume lsDRIVER              VOLUME NAMElocal               cb1c2f7221fa9b0971cc35f68aa1034824755ac44a034c0c0a1dd318838d3a6d然后，使用这个 ID，可以找到它在 Docker 工作目录下的 volumes 路径：    $ ls /var/lib/docker/volumes/cb1c2f7221fa/_data/这个 \_data 文件夹，就是这个容器的 Volume 在宿主机上对应的临时目录了。接下来，我们在容器的 Volume 里，添加一个文件 text.txt：    $ docker exec -it cf53b766fa6f /bin/shcd test/touch text.txt这时，我们再回到宿主机，就会发现 text.txt已经出现在了宿主机上对应的临时目录里：    $ ls /var/lib/docker/volumes/cb1c2f7221fa/_data/text.txt可是，如果你在宿主机上查看该容器的可读写层，虽然可以看到这个 /test目录，但其内容是空的（关于如何找到这个 AuFS文件系统的路径，请参考我上一次分享的内容）：    $ ls /var/lib/docker/aufs/mnt/6780d0778b8a/test可以确认，容器 Volume 里的信息，并不会被 docker commit提交掉；但这个挂载点目录 /test 本身，则会出现在新的镜像当中。以上内容，就是 Docker Volume 的核心原理了。