Qualcomm and Google in June 2016, and received the des-
ignation CVE-2016-5349. We are actively working with both
COMMAND_DISPATCHER(request_buffer)command_code = request_buffer->field1;command_data = (void*) request_buffer->field2; switch(command_code){    case ‘1’:        COMMAND_HANDLER1(command_data);        break;    case ‘2’:        COMMAND_HANDLER2(command_data);        break;    case ‘3’:        COMMAND_HANDLER3(command_data);        break;    case ‘4’:        COMMAND_HANDLER4(command_data);        break;}request_buffer(from untrusted world)read_syscall( address,              length,              output);       write_syscall( address,               length,               content);        COMMAND_HANDLER1(command_data)read_syscall((void*)command_data->field1, length, output);COMMAND_HANDLER2(command_data)write_syscall((void*)command_data->field1, length, content);COMMAND_HANDLER3(command_data)address = (int*)command_data->field1;output_data = *address;COMMAND_HANDLER4(command_data)address = (int*)command_data->field1;*address = data;SourceSink   Attacker Controlled0x3c6b: COMMAND DISPATCHERUSER INPUT0x37aa: COMMAND HANDLER(import_key_pair command)0x4a02: SYSCALL WRAPPER 1(prepare_read_buffer)0x6e80: SYSCALLcompanies on a ﬁx and, as of December 2016, this critical
patch is still in development. Our tool also identiﬁed memory
write functionality in the WideVine TA, which could, in theory,
be leveraged into a full exploit; however, we did not invest the
engineering time at this point to verify this exploit.
C. Vulnerabilities in Huawei
For our analysis of Huawei, we were able to obtain a
set of 10 TAs. Using our static-analysis tool, we found out
that only 6 of them accepted commands and all of these
6 TAs were vulnerable to BOOMERANG. We were able to
locate both arbitrary read and write functionality, which allows
us to gain root privileges on any device running this TEE
implementation. We use a technique based on ret2dir [22],
which allows the execution of code as the root user, by
overwriting kernel memory structures to include a malicious
return-oriented programming (ROP) payload. This technique
has been implemented and tested on Android 5.0.1, and works
regardless of Privileged eXecute Never (PXN) protections
deployed by the hardware.
These vulnerabilities were reported to Huawei, as part of
our submission to the GeekPwn 2016 hacking contest [18], and
received the designations CVE-2016-8762, CVE-2016-8763,
and CVE-2016-8764. We were able to develop a full exploit,
which leveraged BOOMERANG and other techniques to obtain
full root privileges, as well as code execution within the TEE
itself2. Huawei has implemented a ﬁx, and as of December
2016, updates to various Huawei devices are available to
address the problem.
VII. DEFENSES
Before discussing the examined defenses, we ﬁrst outline
the requirements that we set forth to ensure that our proposed
defense would be both practical to implement and usable for
developers. We identify the following minimum requirements
that any solution to BOOMERANG must satisfy to be usable:
• Independence from the untrusted OS: The TEE imple-
mentation should not be dependent on the untrusted OS
(i.e., it should not leverage OS-speciﬁc functionality). For
example, the trusted OS should be unaffected if the untrusted
OS is upgraded or changed entirely. This requirement forces
the solution to be generic, rather than depending on a
particular feature within the untrusted OS implementation.
• Minimal or no changes to user applications (untrusted
and trusted): Changes to trusted and untrusted applications
should be minimal or none at all. This requirement eases the
adoption of the solution and ensures that existing applica-
tions will be automatically protected, without burdening the
developers to re-write their applications.
• Minimal changes to the trusted kernel: No major archi-
tectural changes should be required within the secure world.
This ensures that the TCB will remain small and that all
modiﬁcations can be sufﬁciently audited. Since minimal is
subjective, we specify that any modiﬁcations to the trusted
OS abide by a soft ceiling of 100 lines of code.
2A video demonstrating the exploit can be found at https://www.youtube.c
om/watch?v=XjbGTZrg9DA
A. Page Table Introspection
An obvious and simple method capable of defending
against BOOMERANG is to leverage the trusted OS’s visibility
into the non-secure world to verify the ownership of the mem-
ory being accessed by simply reading the same page tables
that are used by the untrusted OS. A variant of this approach is
taken by NVIDIA’s Trusted Little Kernel (TLK), the TEE used
by Tegra processors [34]. This defense requires the trusted OS
to have a complete understanding of the page table structure
within the untrusted OS. Thus, when an untrusted application
passes a memory reference, the trusted OS would ﬁrst verify
that the memory actually belongs to the untrusted application
that made the call by doing a page-table walk, and, only then,
map that memory into the memory space of the requested TA.
This approach has a few notable advantages. It is entirely
invisible to the untrusted OS, as the entire PTRSAN function
is implemented within the secure world. Additionally, it does
not require any extra memory copy operations, which is an
improvement over shared-memory defenses, which we explain
in Section VII-B. However, the Achilles’ heel of this approach
is the amount of work that must be performed by the trusted
OS to interpret the untrusted OS’s page table structure, and
then make security decisions based on that interpretation. Re-
searchers have shown that page table walks can be extremely
dangerous. For example, since the trusted OS is performing
a walk on a page table controlled by the untrusted OS, a
malicious untrusted OS could potentially craft a malicious page
table and obtain arbitrary code execution within the trusted
OS [5], [20].
Furthermore, this defense, while relatively easy to imple-
ment, does not satisfy our ﬁrst requirement, as the trusted OS
must be aware of the page table structure managed by the
untrusted OS. This approach is not generalizable and would
likely require a customized trusted OS to accompany each
untrusted OS, or at least a different instantiation based on
the page table structure. Finally, this defense is likely not
possible to implement while satisfying our third requirement
of a minimal TCB, as an elegant and correct page table walk
requires a considerable amount of code, likely far more than
100 lines.
This approach works well for TLK, where the trusted OS
is a derivative of Linux and is therefore able to manage Linux
page tables using the same code as the untrusted OS. However,
we do not consider it a viable generic approach since it violates
two of our requirements. Thus, we did not evaluate its efﬁcacy
in practice in Section VIII; however, we do not discredit its
viability as a defense against BOOMERANG, and we believe
that it could be a reasonable defense in speciﬁc instances.
B. Dedicated Shared Memory Region
The heart of the BOOMERANG ﬂaw stems from the fact
that the secure world can read from and write to any non-
secure memory it wishes. In the dedicated shared mem-
ory region defense, a special physical memory region (e.g.,
common-memory in the case of OP-TEE) is deﬁned, which
is the only region of memory that is readable and writable
by both worlds. To verify any pointers that are passed from
the non-secure world, the secure world then needs only to
verify that the memory is within the common-memory, which
11
will protect both worlds. Note that this is the exact method
employed by OP-TEE (see Figure 5).
This defense is easy to implement in the secure world. In
fact, this defense actually makes the secure world’s PTRSAN
function extremely simple, as it needs only to conﬁrm that the
memory is within the shared region. Nevertheless, this defense
has numerous drawbacks in the non-secure world:
• The untrusted OS is burdened with handling all of the
shared memory regions (i.e., sections of common-memory)
amongst the various untrusted user applications. This mem-
ory management can be exceptionally complicated, and,
indeed, we found at least 4 bugs [29]–[32] in different
components of this mechanism in OP-TEE.
• For high-throughput applications (e.g., DRM video decryp-
tion), this defense adds an undesirable overhead, since it
requires all of the data to be copied into a special buffer,
which is not in the requesting application’s memory space.
This global memory region also requires a global lock on
memory, which can become a serious bottleneck in multi-
threaded applications. In our tests (Section VIII-A), this
global locking mechanism alone consumed approximately
36% of the total overhead.
• Shared memory makes it extremely difﬁcult, and in some
cases impossible, to implement certain types of applications.
For example, a popular use of TrustZone is memory integrity
checking [11], where an untrusted application requests that
a TA monitors its memory, which does not work with shared
memory.
• This defense only thwarts the general BOOMERANG attack,
but can still permit applications to leverage BOOMERANG
to read from and write to arbitrary regions within the shared
memory, which may contain sensitive data.
We show in Section VIII-C how this currently advocated
defense compares against our proposed solution.
C. Cooperative Semantic Reconstruction
Due to the limitations of existing BOOMERANG defenses,
we propose a novel defense (CSR), which is capable of bridg-
ing the semantic gap between the two worlds with minimal
modiﬁcation and minimal overhead. In this defense, the trusted
OS and the untrusted OS both cooperate to verify memory
pointers that are passed into the secure world to ensure that
the untrusted application indeed has permission to access the
referenced memory region. This implementation was based
on one key insight:
the untrusted OS already adequately
implements memory protection mechanisms; however,
this
information is not currently easily accessible to the trusted
OS. Thus, to implement this defense, the untrusted OS needs
only to expose a simple callback to the secure world that
permits the trusted OS to query the untrusted OS’s PTRSAN
function, where the memory address can be trivially veriﬁed.
This callback can be used from within the secure world any
time that non-secure memory is to be accessed, thus thwarting
any unintended BOOMERANG vulnerabilities. Fundamentally,
this defense bridges the semantic gap by allowing the secure
world, which has no insight into the layout of non-secure
memory, to query the untrusted OS as a security oracle, which
is able to correctly respond. An overview of the approach can
be seen in Figure 8
12
Fig. 8: Cooperative Semantic Reconstruction data-ﬂow and
pointer resolution technique.
it. The call
In this defense, the untrusted applications prepare requests
to TAs exactly as they would without
to the
TA would similarly be handled by an exposed kernel driver
or TEE 1 , which would handle the world switching. Note
the there is no proactive PTRSAN necessary by either the
daemon or the kernel driver. In fact, the buffer is passed
directly into the secure world with the non-secure world virtual
memory address intact. The only addition is that the process
identiﬁcation number (PID) of the requesting process (we refer
to this as the req_pid) is now appended to the request
structure by the untrusted OS during the SMC call
2 . Now,
in the secure world, when a TA needs to access a pointer that
was passed as an argument, which is a virtual address that
belongs to the untrusted application that initiated the call, the
TA must ﬁrst query the trusted OS to resolve the physical
4 . This query is implemented as a callback to the
address
untrusted kernel with the pointer value (virtual address), the
length of the buffer, and the corresponding req_pid 5 .
The untrusted OS kernel can trivially handle the callback by
checking that the buffer indeed belongs to the address space
of req_pid 6 . If the veriﬁcation is successful, the untrusted
OS then locks the corresponding pages (to avoid them being
paged out) and sends the physical addresses back to the secure
world 7 . At this point, the trusted OS will then implement
its own PTRSAN function to verify that the physical address
from the untrusted OS is, in fact, in the non-secure world 8 .
Then, the trusted OS will map it into the TA’s memory space
or allow the TA to access the physical address directly 9 . If
veriﬁcation fails, a corresponding error code is returned.
Given that every TEE implementation already has callback
support for high-level operations (e.g., ﬁle operations, network
communication), this exact same channel can be leveraged to
implement CSR. Note that CSR provides a generic mechanism
to bridge the semantic gap between the two worlds, and that
it can also be extended to verify access to ﬁles, or other
peripherals by the secure world.
At ﬁrst glance,
it may appear that
this defense would
require modiﬁcations to all of
the
untrusted application, the untrusted kernel, the trusted ker-
nel, and the trusted application). However, since all of the
library,
trusted applications that we observed use a client
we believe that simply updating this client
library would
be enough in practice. Similar to untrusted applications, ex-
the components (i.e.,
Non-secure MemorySecure MemoryNon-secure WorldSecure WorldUser ModeSupervisor ModeSupervisor ModeUser ModeUntrusted ApplicationTrusted ApplicationUntrusted App. MemoryShared BufferTrusted App. MemoryVirtual MemoryPhysical MemoryTEE Daemon/DriverTrusted OSPTRSANPTRSANAppend PID1236Shared Buffer75498isting TAs would not require any modiﬁcation, as this de-
fense could be implemented in the trusted kernel functions
(e.g., qsee_register_shared_buffer() in the case
of QSEE) that are already used to access non-secure world
memory. The only real modiﬁcations that would have to be
deployed would be the modiﬁcations to the untrusted and
trusted kernels, which would add the functionality to handle
and perform the required callback, respectively.
The main overhead introduced by CSR is the addi-
tional veriﬁcation path (i.e.,
4 - 9 ). However, we show in
Section VIII-B that this overhead is minimal and comparable
to other defenses.
VIII. EVALUATION OF DEFENSES
We evaluated the two most promising proposed defenses:
Dedicated Shared Memory Region (DSMR) and CSR. We
decided not
to include Page Table Introspection (PTI) in
our analysis, as it does not satisfy our requirements as a
general BOOMERANG defense. Similarly, we did not explicitly
compare our defenses against a vanilla TEE implementation,
as we do not see no defense as an option. We performed our
evaluation on the OP-TEE platform [51], with Linux as our
untrusted OS. OP-TEE was chosen because it is completely
open source, has a very well-maintained code base with clear
documentation, and includes an exhaustive test suite, which we
used to evaluate the performance overhead of our defenses.
We chose the HiKey development board (Lemaker Version)
as the hardware platform for testing, which is one of the
boards recommended by the OP-TEE developers [51]. This
board includes a traditional ARM processor and associated
hardware, which are almost identical to what would be found
on a consumer Android handset [26]. OP-TEE has an extensive
test suite with 63 tests called xtest [50]. These tests cover
both sanity and functionality check of various TAs, TEE
benchmarking, and Global Platform compliance. We modiﬁed
the test driver to record timings for each of the tests as well
as proﬁling information for the different phases of DSMR and
CSR. All reported timing data are averaged across 30 runs of
xtest on the HiKey board, where the system was rebooted
between runs to avoid caching-related inconsistencies.
A. Dedicated Shared Memory Region
As explained in Section V-C, OP-TEE’s default conﬁgura-
tion uses the DSMR method as the only mechanism for passing
memory arguments. In this implementation, the untrusted OS’s
client library handles the allocation of the shared memory
region, which consists of assigning an identiﬁer (shmid),
copying of data to and from the corresponding shared buffer,
and ultimately releasing it. Recall that this shared memory
management within the untrusted OS is the main overhead
in this implementation. There is virtually no overhead in the
trusted OS, as it just needs to check that the pointer argument
is contained within the common-memory region. On average,
allocating shared memory took 13.795 µs, releasing memory
took 7.982 µs, and the time it took to copy memory contents
was negligible. Thus, the total incurred overhead was 21.777
µs per secure-world query. This low overhead is partially
attributed to the fact that the maximum size being copied in the
tests was only 4,097 bytes; however, we would expect these
numbers to rise signiﬁcantly with larger memory regions.
TABLE II: Total modiﬁcations required to implement CSR in
OP-TEE, measured in LOC.
Component
Added LOC Modiﬁed LOC
Total LOC
Trusted OS
Untrusted OS
Client Library
88
273
39
3
2
0
91
275
39
TABLE III: Summary of benchmark results, showing the
overhead of CSR over DSMR.
Category
Overhead
Avg. %
Avg. Time (ms)
Basic Functionality
Trusted-Untrusted Communication
Crypto operations
Secure File Storage
Total for all Tests