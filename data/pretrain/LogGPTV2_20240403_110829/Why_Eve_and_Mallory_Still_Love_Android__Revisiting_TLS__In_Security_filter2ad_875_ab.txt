production purposes. As of Android 7, user-installed CA cer-
tiﬁcates are no longer trusted roots by default. Trust is in-
stead limited to the set of pre-installed system root CA cer-
tiﬁcates [44, 60]. However, developers can re-enable user-
installed certiﬁcates by setting the user ﬂag (cf. Listing 4),
which is a security downgrade comparable to the situation
before Android 7.
Debug Settings Allow developers to conﬁgure CA certiﬁ-
cates – e.g., locally issued or self-signed certiﬁcates – for
debugging purposes. In contrast to manually implemented
code to switch between debug and production logic, it is not
possible to have debug settings active in production when
publishing apps in Google Play. [28]
Limits of NSC The introduction of NSC did not come
along with the deprecation, suspension, or even removal of
certiﬁcate validation APIs in the Android SDK. Developers
are still allowed to write the same erroneous certiﬁcate valida-
tion code as in earlier Android versions. This is particularly
critical since custom certiﬁcate validation code overrides NSC
settings in some cases (e.g. a vulnerable TrustManager im-
plementation makes NSC certiﬁcate pinning conﬁgurations
useless).
USENIX Association
30th USENIX Security Symposium    4349
2.2 Google Play
In addition to NSC for Android, Google Play implemented a
set of policy changes and safeguards.
In 2016 and 2017, Google added safeguards that pre-
vented new apps or app updates
to include unsafe
X509Trustmanager and HostnameVerifier interfaces and
onReceivedSslError methods in WebViews. Google did
not provide further details of the safeguards. However, they
are executed as part of an app’s review process before pub-
lishing the app [62]. Since August 2018, Google Play has
only accepted apps and updates that target Android 8 [49],
which enforces that user-installed certiﬁcates are not trusted
by default. From late 2019 new apps and updates have been
forced to target Android 9 or higher and therefore enforced
HTTPS by default [65].
3 Related Work
section, we discuss
In this
related work regarding
measurement studies of insecure TLS certiﬁcation validation
code in Android apps.
In 2012 Fahl et al. [54] analyzed 13,500 popular, free An-
droid apps and found 8% to be susceptible to Man-in-the-
Middle-attack (MitMA)s because of insecure TLS certiﬁcate
validation code. In follow-up work in 2013, Fahl et al. [56]
extended their previous analysis to iOS and manually investi-
gated 1,009 applications. They reported that 14% of the apps
suffer from similar issues as apps on Android.
Like Fahl et al., Georgiev et al. [58] uncovered a variety
of vulnerabilities in TLS certiﬁcate veriﬁcation logic in non-
browser software, including mobile apps in 2012. As root
causes, they identiﬁed poorly designed APIs which confused
developers, as well as a lack of safe defaults. In 2014 Soun-
thiraraj et al. [84] presented SMV-HUNTER, an automated,
large-scale analysis tool utilizing a combination of static and
dynamic analysis to detect vulnerabilities in the certiﬁcate val-
idation logic of Android applications. They performed a study
of 23,418 apps, identiﬁed 1,453 as potentially vulnerable, and
were able to conﬁrm this for 726. In 2015, Onwuzurike and
De Cristofaro [77] conducted static and dynamic analyses on
100 popular Android apps and found 32 to implement unsafe
TLS certiﬁcate validation logic. Furthermore, 91 applications
were vulnerable if attackers installed root CAs on a victim’s
device. In 2015 He et al. [69] presented SSLINT, a tool to
detect incorrect use of TLS APIs. They found 27 previously
unknown TLS-related vulnerabilities in Ubuntu applications.
Fischer et al. [57] classiﬁed security-related code snippets
from the platform Stack Overﬂow and assessed their preva-
lence in Android applications in 2017. They found the most
dominant insecure code to be related to unsafe custom TLS.
While they could not determine whether or not developers di-
rectly copied detected code snippets from Stack Overﬂow, the
authors argue that the platform has a signiﬁcant impact and
responsibility due to its popularity. Razaghpanah et al. [81]
conducted a dynamic network trafﬁc analysis with data for
1,364,420 TLS handshakes from 7,258 Android apps using
the the Lumen Privacy Monitor framework for 5,000 users in
2017. They ﬁnd that 2% of the apps in their data set implement
custom certiﬁcate validation logic.
In contrast to the previous work above, our work focuses
on the security of custom NSC settings in deployed Android
apps.
Oltrogge et al. [75] analyzed 13 online application gen-
erators for Android, of which six failed to implement TLS
certiﬁcate validation code correctly in 2018. In 2019 Kaﬂe
et al. [70] conducted a security analysis of the Google Nest
and Philips Hue smart home platforms. They analyzed 761
smart home management apps from Google Play and Nest
and found that 20.61% respectively 19.82% of the apps im-
plemented insecure TLS certiﬁcate validation. Rahaman et
al. [80] present the static analysis tool CryptoGuard, analyzed
6,181 Android apps in 2019 and found insecure TrustMan-
ager implementations in 25.30% of the apps. They conclude
that Google Play’s inspection safeguards are insufﬁcient. Re-
cently, in 2020, Weir et al. [86] performed an online survey
with Google Play developers about their access to security ex-
perts and developer assurance techniques and analyzed their
participants’ apps using MalloDroid [54], CogniCrypt [72]
and FlowDroid [40]. They found SSL issues in 70% of the
apps. While previous work found that apps with vulnerable
certiﬁcate validation logic have been published after 2016 in
Google Play, our work is the ﬁrst that conducts controlled ex-
periments to investigate loopholes in Google Play’s safeguard
mechanism.
In 2020, Possemato and Fratantonio [79] analyzed the se-
curity of NSC settings in 16,332 apps. They ﬁnd that many
apps do not take full advantage of the NSC feature and allow
insecure network protocols. In a root cause exploration they
discover that developers copy & paste vulnerable settings
from online resources and that several popular third-party li-
braries require developers to weaken their NSC settings. They
conclude their work with a novel NSC extension that allows
developers to include insecure libraries without weakening
the security of the entire app. In contrast, our NSC analysis
is based on a larger set of Android apps (99,212 instead of
16,332) and more detailed analyses (e.g. of certiﬁcate pinning
issues and across app categories and download counts) and a
manual analysis of 40 apps. Additionally, we perform a static
code analysis on 15,000 apps and investigate the efﬁcacy of
Google Play’s safeguards against vulnerable certiﬁcate val-
idation logic in apps, providing a more complete picture of
the current state of TLS security in Android apps.
Previous works suggested alternative approaches to custom
TLS. As an example, in 2013, Fahl et al. [56] proposed a
conﬁguration approach to custom TLS behavior on Android,
removing the need for developers to write any code. In a
more recent approach in 2017, O’Neill et al. [76] introduced
4350    30th USENIX Security Symposium
USENIX Association
TrustBase, a centralized approach to move TLS certiﬁcate
validation to an OS service that intercepts all connections and
enforces policies.
However, in contrast of providing another approach or re-
search prototype for the custom certiﬁcate validation issue,
our work focuses on the security analysis of NSC settings in
Android apps and the efﬁcacy of Google Play’s safeguards.
4 NSC Adoption and Security
Table 2: Body of Android apps: Total Apps vs. Apps with
NSC
Target SDK
= Android 7
>= Android 8
>= Android 9
Total
Total Apps
Apps w. NSC
236,843
1,098,479
963,750
565,910
1,335,322
68
96,332
95,826
88,854
96,400
In this section, we illustrate the methodology of our NSC
analyses and report their ﬁndings.
(cid:63) Though NSC is only supported for Android 7 and higher, apps with lower
target SDKs can use backport-libraries (e.g., TrustKit. [25]) to implement
NSC.
September 2016 with Android 7 (cf. Table 1), widespread
adoption was delayed until early 2019 (cf. Figure 2). This
correlates with Android 9 introducing HTTPS as the default
protocol for web requests in late 2018 (cf. Table 1).
4.1 Security Analysis of Custom NSC Settings
Below, we analyze the security of custom NSC settings. Fig-
ure 3 illustrates our ﬁndings across app categories and down-
load counts.
Measuring the Adoption of Custom NSC Settings: We
begin with the detection of apps that include custom NSC
settings. If an Android app contains custom NSC settings,
a reference to the respective settings ﬁle is included in
the android:networkSecurityConfig property of the An-
droidManifest.xml. In cases of a missing reference, we check
for the android:usesCleartextTraffic attribute to assess
whether cleartext trafﬁc is permitted for all network connec-
tions without using NSC. [6]
NSC Settings Analysis: Since we aim to gain insights on
how NSC settings are used by developers 4, we extract and
analyze all relevant information from the NSC ﬁles. First,
we examine the high-level NSC features which are used by
traversing the NSC ﬁle’s XML document tree, starting with
the root tag .
NSC ﬁles with  elements include global
options that affect connections for all hosts. The presence
of  elements indicates custom settings for
speciﬁc hosts. Each  element may include
a set of custom settings for a list of hosts that can each be
speciﬁed in a particular  element. Table 3 provides
an overview of the NSC elements and attributes we analyzed.
The table also illustrates secure and insecure options for each
attribute and explains why the given examples are insecure.
Overall, we analyzed 96,400 apps that included a NSC set-
tings ﬁle. 95,940 of these implemented at least one custom
NSC setting, while 460 apps contained an empty NSC ﬁle.
Regarding app demographics, we ﬁnd popular apps with more
4Cf. Section 2.1 for an overview of all possible NSC settings developers
can conﬁgure.
Figure 2: Adoption of NSC over time. The release of Android
9 had a signiﬁcant contribution.
Body of Android Applications. We base our research on a
body of 1,335,322 free Android apps available in Google Play
that had received at least one update since August 2016 when
Google introduced NSC (cf. Section 2) for Android 7. We
downloaded the set of Android applications from Google Play
using the unofﬁcial Google Play protobuf API [13]. To grow
the number of apps, we added apps from the "similar" apps
section of an app’s details website recursively. Overall, we
collected apps between 2016/08/22 2 and 2020/03/18 using
Oltrogge et. al’s Android app crawler [75].
Of the 1,335,322 free Android apps we analyzed, 99,212
implemented custom NSC settings. We used the OBFUSCAN
tool [87] to detect obfuscation and excluded 2,812 (2,83%) ob-
fuscated apps to improve our analysis quality. We conducted
further analyses on the remaining 96,400 apps.3
Table 2 gives an overview of the target SDKs and custom
NSC settings of the apps. Figure 2 illustrates the adoption
of custom NSC settings: We see a signiﬁcant increase with
the release of Android 9. Similarly, we ﬁnd that custom NSC
settings are more frequently implemented in popular Android
apps (cf. Figure 3). Even though Android rolled out NSC in
2The release date of Android 7.
3We provide the full list of apps on this link.
USENIX Association
30th USENIX Security Symposium    4351
2016-092017-012017-052017-092018-012018-052018-092019-012019-052019-092020-01Time0100002000030000400005000060000Apps to adopt NSC Android 7 Android 8 Android 9 Android 9 enforcedTable 3: Security impact of NSC-settings for  and . A (cid:88)denotes that an element or attribute
can be used in the respective environment. The secure and insecure columns show which attribute values are considered (in)secure.
The reason column gives a brief explanation why values are considered insecure.
base-conﬁg domain-conﬁg element
attribute
cleartextTrafﬁcPermitted
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
 src
overridePins
expiration
a Recommendation as checked by Android LINT (cf. [22])
than 50,000 downloads to be more likely to include a custom
NSC ﬁle (11-47%, cf. Figure 3). Below, we discuss the results
of our analysis for the use of cleartext trafﬁc, certiﬁcate pin-
ning, custom CA certiﬁcates and debug conﬁgurations. Since
apps may contain the same attributes in both base and domain
speciﬁc environments, the numbers in the following sections
may not always add up.
4.1.1 Cleartext Trafﬁc
section, we
analyze
all
apps
this
from the
standard and explicitly declare
In
that devi-
ate
the
cleartextTrafficPermitted ﬂag in the NSC ﬁle.
Since Android 9, cleartext trafﬁc is disabled by default
(cf. Table 1). Therefore, we distinguish apps that target
Android 9 or higher from apps that target Android 8 or
lower. We also distinguish apps with global settings from
apps with domain-speciﬁc settings. In both 
and  environments we check for the
presence of the cleartextTrafficPermitted ﬂag. De-
pending on the environment, an application allows HTTP
connections for all or only speciﬁc domains if this ﬂag
is set to true. Table 4 illustrates the frequency the use of
the cleartextTrafficPermitted ﬂag across different
Android versions.
Altogether, we
that used the
cleartextTrafficPermitted ﬂag. This element was
present uniformly across all apps that used NSC settings in
our dataset, with 89-97% of apps in all download categories
using it. 88,769 (98.98%) used it to re-enable HTTP. However,
only 4,093 (4.56%) apps used the ﬂag to enforce HTTPS
by setting cleartextTrafficPermitted="false". In our
dataset, 565,910 apps target Android 9 or higher. Of those,
84,060 (14.85%) – 57,123 globally and 34,246 for speciﬁc
domains – allow HTTP connections, therefore downgrading
the security for these applications. In 3,908 apps that target
Android 9 or higher the cleartextTrafficPermitted
ﬂag is set to false, which has no security beneﬁt, as
HTTPS is enforced by default. These conﬁgurations have