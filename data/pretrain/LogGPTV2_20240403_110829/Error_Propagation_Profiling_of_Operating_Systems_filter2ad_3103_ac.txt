### 关系和可能的返回值信息

对于某些服务，在MSDN数据库中没有找到相应的条目。在这种情况下，我们仅通过系统头文件搜索来查找这些服务的规范说明。遗憾的是，头文件中除了C类型外，并未包含关于返回值等其他信息。这些头文件是目标SDK的一部分，访问它们并不违反我们的黑盒方法。

### 服务错误渗透率估计

服务错误渗透率 \( \hat{P}_{DS}^{i_{x.y}} \) 和 \( \hat{P}_{OS}^{i_{x.z}} \) 是指在操作系统服务级别检测到的错误数量与每个位置注入的错误数量之间的比率。操作系统的错误暴露度（\( \hat{E}_j \)）和驱动程序的错误扩散度（\( \hat{D}_j \)）可以通过使用公式3和公式4，基于估计的服务错误渗透率进行计算。

### 错误传播结果

| 驱动器 | 串行 | 以太网 |
| --- | --- | --- |
| 导入服务数量 | 50 | 12 |
| 导出服务数量 | 42 | 10 |
| 测试用例 | 411 | 414 |
| 激活用例百分比 | 43% | 55% |

表3概述了本研究中使用的两个驱动程序。这两个驱动程序在其接口中具有类似数量的服务（分别为60和54个），这导致测试用例的数量也相似。测试用例的数量取决于服务数量、目标参数数量以及为每种类型定义的测试用例。每种类型的错误选择在第3.1节及表1和表2中有详细讨论。驱动程序在激活测试用例的数量上有所不同，即当注入的错误实际执行时，网络驱动程序的激活率更高（55%对43%）。激活率仅仅是衡量实际执行错误实验的数量的一个指标。实验执行时间取决于所执行的实验数量。目前，使用四个并行的独立板卡，整个实验时间大约为五到六小时，包括设置时间。

#### 表4：串行驱动程序cerfio serial.Dll的服务错误

| 操作系统服务 | 测试次数 | 失败类别 | NF |
| --- | --- | --- | --- |
| CreateThread | 13 | 2 | 6 |
| CreateEventW | 6 | 3 | 4 |
| InterruptInitialize | 14 | 2 | 3 |
| memcpy | 11 | 1 | 7 |
| Sleep | 5 | 1 | 4 |
| LeaveCriticalSection | 1 | 1 | 0 |
| LocalAlloc | 9 | 1 | 0 |
| EnterCriticalSection | 1 | 0 | 0 |
| InitializeCriticalSection | 1 | 0 | 0 |
| memset | 15 | 0 | 14 |
| 累计 | 76 | 9 | 42 |
| 无失败 | 0 | 0 | 0 |

#### 表5：以太网驱动程序91C111.Dll的服务错误

| 操作系统服务 | 测试次数 | 失败类别 | NF |
| --- | --- | --- | --- |
| FreeLibrary | 3 | 2 | 1 |
| LoadLibraryW | 3 | 0 | 2 |
| NdisAllocateMemory | 20 | 0 | 19 |
| VirtualCopy | 16 | 1 | 2 |
| KernelIoControl | 18 | 0 | 5 |
| VirtualAlloc | 18 | 0 | 7 |
| memset | 15 | 0 | 6 |
| NdisMSetAttributesEx | 16 | 0 | 10 |
| NdisMRegisterInterrupt | 17 | 0 | 10 |
| RegOpenKeyExW | 17 | 0 | 11 |
| NdisOpenConfiguration | 3 | 0 | 0 |
| memcpy | 11 | 0 | 8 |
| CreateMutexW | 5 | 0 | 3 |
| NKDbgPrintfW | 3 | 0 | 2 |
| GetProcAddressW | 6 | 0 | 5 |
| 累计 | 187 | 14 | 103 |
| 无失败 | 3 | 0 | 0 |

根据第3.1节中的错误模型，表4展示了针对串行端口驱动程序cerfio serial.Dll的实验结果，特别是涉及该驱动程序使用的操作系统服务。我们只选择了那些导致失败的服务，并指出错误传播的观察次数，而不是其位置。表5显示了针对以太网驱动程序91C111.Dll的相应结果，后者有更多的服务导致错误。表格中的行按故障严重性排序。对于cerfio serial.Dll，没有任何服务会导致系统崩溃。然而，对于91C111.Dll，FreeLibrary和LoadLibrary都是易受攻击的服务（见表5）。91C111.Dll的累计Class 2故障较少（只有一个，而cerfio serial.Dll有九个），这表明使用少量包装器可以消除所有严重的错误传播路径（Class 2和Class 3故障）。

从操作系统服务的角度来看，表6和表7展示了测试的操作系统服务及其实验结果，即使用公式3计算的操作系统服务错误暴露度。此外，还列出了Class 1故障的数量和无故障观察（NF）。Class 2（故障和规范违反）和Class 3（崩溃/挂起）对列出的每个操作系统服务的影响相同。这种影响特定于所进行的实验，并不代表操作系统的一般行为。对于Class 2故障，只有特定的驱动程序测试应用程序受到影响。因此，操作系统服务错误暴露度仅使用Class 1故障计算。从这些表中，可以找出更容易受到系统中错误传播影响的服务。对于某些服务，传播的错误数量为零，表明该函数未受到任何注入的错误（Class 1）的影响。除了测试的操作系统服务（表6）外，我们还包括了正确性断言，用于检测是否从主机计算机接收到正确的信息。在这种情况下，Correctness 1失败了27次，表明应用程序中的第一轮测试失败，而第二轮（Correctness 2）则没有失败。考虑到每个错误只注入一次，这是意料之中的。

如表所示，结果分为两类。这表明实验结果“聚类”，即一个服务中的错误意味着另一个服务中的错误。这表明服务之间存在依赖关系，以及非依赖关系（或至少表明依赖较弱）。一些依赖关系是预期的，例如CreateFile会影响ReadFile和WriteFile（表6）。一些（非）依赖关系较为意外，例如SetCommState不受CreateFile的影响。对于两个驱动程序，都只出现了一个集群，其中串行驱动程序cerfio serial.Dll有7个服务共27个案例，以太网驱动程序91C111.Dll有三个服务共85个案例。

在本案例研究的实验中，没有操作系统服务（si）因超过一个驱动程序的错误而失败，即操作系统服务错误暴露度等于每个驱动程序的服务错误渗透率之和。这表明在两个驱动程序测试的操作系统服务之间几乎没有相关性。

表8展示了目标驱动程序的驱动程序错误扩散度。不同故障类别的值分别呈现，因为它们具有不同的故障影响。显然，Class 3故障的影响高于Class 1故障。

#### 表6：操作系统服务测试结果

| 操作系统服务 | 正确性1 | CreateFile | GetCommState | GetCommTimeouts | SetCommTimeouts | ReadFile | WriteFile | CloseHandle | 正确性2 | SetCommState | strlen |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 失败类别 | NF | 384 | 384 | 384 | 384 | 384 | 384 | 384 | 411 | 411 | 411 | 411 |
| 1 | 27 | 27 | 27 | 27 | 27 | 27 | 27 | 0 | 0 | 0 | 0 |
| 2 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 0 | 0 | 0 | 0 |

希望这些优化后的文本能更好地传达您的意图。如果有任何进一步的需求，请告诉我！