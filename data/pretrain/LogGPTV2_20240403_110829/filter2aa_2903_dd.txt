tm0
2
时间戳（timestamp）寄存器
1101b
fc#.#
39
流程控制（flow control）寄存器
表11-3中的第1列代表该类型寄存器的引用编码。EU指令中有一个
名叫RegNum的字节用于索引架构寄存器，其中的高4位（RegNum
[7:4]）用于指定寄存器类型，取值便是表11-3中第1列的内容。
表11-3中的部分寄存器与CPU上的类似，比如ip和sp，前者代表当
前的指令位置，后者用来描述当前线程所使用的栈，并且分成两部分，
一部分描述栈顶，另一部分描述边界（limit）。
在英特尔为Gen定制的GDB调试器开源代码中，有一份很详细的
Gen寄存器列表，位于gdb/features/intel-gen子目录下，分三组描述
Gen75、Gen8和Gen9的寄存器。每一组有两个文件，一个是xml文件，
另一个是.c文件。例如，下面两行代码是关于通用寄存器r0的。
tdesc_create_reg (feature, "r0", 0, 1, NULL, 256, "vec256");
这样的代码有128行，与Gen的128个通用寄存器对应。下面两行代
码是关于控制寄存器cr0和程序指针寄存器的。
tdesc_create_reg (feature, "cr0", 144, 1, NULL, 128, "control_reg");
tdesc_create_reg (feature, "ip", 145, 1, NULL, 32, "uint32");
函数tdesc_create_reg是GDB中用于创建调试目标描述信息的函数之
一，用来创建寄存器描述。第一个参数是描述调试目标特征的
tdesc_feature结构体指针，然后是寄存器名字，名字后面是寄存器的编
号，接着是保存和恢复标志（save_restore），而后是寄存器组的名字，
再后是寄存器的位数，最后是寄存器类型描述。
11.8.2 寄存器区块
GEN支持把EU的128个通用寄存器拼接成一个二维的方形区域使
用，并定义了非常灵活的方式来寻址这个区域中的单个或者多个单元。
图11-14画出了通用寄存器区的一种组织方式。在这个区域的水平
方向，每个寄存器一行，从r0开始，依次递增。在垂直方向，每一列的
宽度是一字节，一共32列，刚好是256位，从右往左，从字节0到字节
31。
GEN定义了两种格式来索引寄存器区域中的元素。一种叫源操作数
区域描述格式，其一般形式如下。
rm.n:type
其中，type用来指定元素的类型，可以是ub | b | uw | w | ud | d | f |
v，分别代表无符号字节、有符号字节、无符号字（16位）、有符号字
（16位）、无符号双字（32位）、有符号双字（32位）、单精度浮点数
和打包形式的半字节向量。最前面的rm.n用来指定寄存器区域的起始点
（origin），m代表寄存器号，n代表子寄存器号（SubRegNum），用来
指定数据从256位寄存器n的哪个部分起始，以元素大小为单位。尖括号
中包含三个部分，以分号和逗号分隔。分号前面是垂直步长
（VertStride），表示垂直方向上两个相邻元素的距离。逗号后面是水平
步长（HorzStride），用来指定水平方向上两个相邻元素的距离，仍以
元素的宽度为单位。可以把这个步长值理解为GEN在操作完一个元素
后，要操作下一个元素时需要移动的幅度。分号和逗号之间的部分是宽
度（Width），用来描述每一行的元素个数。
有了上面的约定后，就可以使用r4.1:w这样的魔法表示来
索引图11-14中标有0，1，2，3，…，15的16个字（Word，双字节）
了。
图11-14 寄存器区块示例（图片来自GEN PRM）
在r4.1:w中，r4.1表示从r4寄存器的第1个字起始，水平步长
为2，这意味着处理好第0个元素后，步进两个字便是下一个元素。16代
表垂直方向上两个相邻元素的距离是16个字。
上面介绍的格式是用于描述源操作数的。另一种类似的格式用于描
述目标操作数，其一般形式如下。
rm.n:type
与源操作数区块格式相比，这里少了垂直步长和宽度。
11.8.3 指令语法
EU的指令很长，普通情况下，所有指令都是128位，即16字节，4
个DWORD。在紧缩（compact）格式中，部分指令可以是64位。本书只
讨论普通格式。
在普通格式中，一般用DW0～DW3来表示一条指令的4个DWORD
，它们的分工如下。
DW0包含指令的操作码（opcode）和通用的控制位，比如后面介绍
的调试控制位（见11.11节）。
DW1用于指定目标操作数（dst）和源操作数的寄存器文件与类
型。
DW2包含第一个源操作数（src0）。
DW3包含第二个源操作数（src1），或者用来存放32位的立即数
（Imm32），这个立即数可以作为第一个源操作数，也可以作为第
二个源操作数。
EU指令的一般格式如下。
[pred] opcode (exec_size) dst src0 [src1]
第一部分是可选的谓词修饰，用来指定执行执行这条指令的前提条
件，目的是让当前线程可以轻易地跳过这条指令。第二部分是操作码，
比如mov等。第三部分是用于描述指令级别并行度的执行宽度
（exec_size），稍后将详细介绍该内容。后面三个部分分别用来指定一
个目标操作数和两个源操作数，这很好理解。
11.8.4 VLIW和指令级别并行
EU指令是典型的VLIW风格，具有很强的指令级别并行能力。在一
条EU指令中，可以定义一套并行度很高的操作。
以执行加法操作的add指令为例，其内部逻辑的伪代码
（pseudocode）如下。
for (n = 0; n :f   r4:f   r14:f  // dst.x = src0.y + src1
.z
add (16)   r20:f   r6:f   r16:f  // dst.y = src0.z + src1
.w
add (16)   r22:f   r8:f   r10:f  // dst.z = src0.w + src1
.x
其中，add指令后面以小括号包围的（16）就是用来指定执行宽度
的，也就是前面提到过的exec_size，有时也写作ExecSize，代表逻辑通
道数量，在这里是16。因为元素是在寄存器中连续存放的，所以源操作
数和目标操作数的水平步长都为1。
再举一个更有趣的例子，图11-15呈现了寄存器区域的另一种组织
方式，每行16字节，一个通用寄存器占两行。图中标出了Src0和Src1两
个区块，各自有16个元素，分为两行，每行8个元素。假设要把它们累
加到一起，并且为了防止溢出，要把相加结果保存为双字节，那么便可
以使用下面这样一条加法指令。
add (16) r6.0:w r1.7:b r2.17:b
图11-15 加法指令示例（图片来自GEN PRM）
图11-15中，源操作数区块内的数字代表要计算的数据，目标操作
数区块内的数字表示计算结果。例如，r1.7 = 3，r2.17=9，相加的结果
放在r6.0中，3 + 9 = 0xC。
补充一点，细心的读者可能注意图11-14下方的加法指令，其中，
Src1为r2.1，与本书上面的代码不一致。这幅插图来自公开的PRM文
档，图中所画Src1区域与下方文字不匹配，是个小错误，本书引用时将
其纠正过来。
11.9 内存管理
因为多任务和不断增加的内存需求，今天的主流GPU都支持虚拟内
存技术，简单来说，就是以页表的形式来把物理内存映射为虚拟内存。
为了与CPU端的页表相区分，GPU所用的页表一般称为图形翻译页表
（Graphics Translation Table，GTT）。GEN也不例外，在经典的
G965（Gen4）PRM中，就可以看到很强大的虚拟内存支持，包括全局
的图形翻译页表（Globle GTT，GGTT）以及与进程相关的图形翻译页
表（Per-Process GTT，PPGTT）。
11.9.1 GGTT
GGTT用于映射所有图形任务都可见的虚拟地址空间。或者说这套
页表不会因为任务切换而切换。桌面显示、光标更新等高优先级的公共
任务通常使用GGTT映射的虚拟内存。
在G965的MMIO寄存器中，有一个名为PGTBL_CTL的寄存器（地
址为0x2020），它用于控制GGTT，它的宽度为32位，包含了如下几个
字段。
高20位（Bit 12～31）为GGTT所在物理地址的第12～31位。
第4～7位为GGTT所在物理地址的第32～35位。
第1～3位为GGTT的大小，000代表512KB，100代表2MB，等等。
第0位为启用位，用来启用GGTT。
从Gen5开始，配置GGTT的方法有所变化，因此在i915驱动的
i915_ggtt_probe_hw函数中，使用如下代码分别处理。
if (INTEL_GEN(dev_priv) 0），M代表同时映射到了CPU端
（mm.mapping为真）。
标志部分后面是内存块的大小。其后是这个内存区的访问状态，以
两个整数表示，第一个是读者（obj->base.read_domains），第二个是写
者（obj->base.write_domain）。二者都是以置位的方式表示的，位定义
在include/uapi/drm/i915_drm.h中，比如下面的定义。
#define I915_GEM_DOMAIN_CPU        0x00000001
接下来是缓存属性，来自i915_cache_level_str(dev_priv, obj-
>cache_level)。而后还可能出现“dirty”描述，代表该内存被写过。也可
能出现“purgeable”，表示可以删除。相关的代码如下。
obj->mm.dirty ? " dirty" : "",
obj->mm.madv == I915_MADV_DONTNEED ? " purgeable" : "");
接下来的小括号中的内容（ggtt offset: 00040000, size: 00300000,
normal）是内存节点的信息，是如下函数输出的。
seq_printf(m, " (%sgtt offset: %08llx, size: %08llx, pages: %s",
               i915_vma_is_ggtt(vma) ? "g" : "pp",
               vma->node.start, vma->node.size,
               stringify_page_sizes(vma->page_sizes.gtt, NULL, 0));
第一部分的ggtt表示该内存块是从GGTT分配的，后面是偏移量，
然后是十六进制表示的内存块大小（3MB），最后的normal来自其他函
数，代表内存块属性是普通内存块（I915_GGTT_VIEW_NORMAL），
特殊内存块有旋转内存块（I915_GGTT_VIEW_ROTATED）和局部内
存块（I915_GGTT_VIEW_PARTIAL）等。
最后再解释一下最后一部分（stolen: 00012000）。集成显卡一般没
有独立的显存，需要从CPU的主内存“偷”来一部分用作显存。一般是系
统的固件（EFI/BIOS）在系统启动时划出一部分主内存给集成的GPU。