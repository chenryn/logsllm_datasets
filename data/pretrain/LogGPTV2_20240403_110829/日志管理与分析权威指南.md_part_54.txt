ConsoleAppender">
程序员使用的日志记录API
%d[HH:mm:ss.SSS} [%thread]%-51eve1%1ogger{36}-%msg%n
一个经验法则参考列表。这是很好的一组应该始终记录的日志消息类型。你的
encoder.PatternLayoutEncoder by default-->
影响应用程序可用性的错误；以及影响可用性的备份成功和失败
问题
程序和组件安装与更改
问；以及远程访问，包括分布式环境中一个应用程序组件对另一个组件的访问
系统、应用程序、应用程序模块或者组件的启动与关闭；故障和错误，特别是
资源耗尽、超过容量等；连接性问题；到达限值
无效输人和其他可能的应用程序违规使用；其他已知会影响应用程序的安全
系统或者应用程序更改（特别是权限更改）；数据更改（包括创建和销毁）；应用
成功和失败的身份认证或者授权决策；系统访问、数据访问和应用程序组件访
表18.3
日志类型基本原则
Unix/Shell
C/C++
Perl
Java
语
言
表18.4常见语言的日志记录库摘要
Logger(man logger)
Log4C(http:/log4c.sourceforge.net)
Log4Perl(http://mschilli.github.com/log4perl/)
Logback(http://logback.qos.ch/)
Log4j (http://logging.apache.org/log4j)
---
## Page 278
18.3.3
而没有必要重新编译代码或者重启应用程序。
辑该文件，做出更改并保存。Logback基础设施负责其余的工作。你可以“即时”做出更改，
始使用修改后的配置。这一特性通过在configuration块中使用scan参数来实现：
应用程序。首先，API检测到更改，然后将更改加载到文件，在运行中的应用程序里自动开
好的特性是可以配置为在配置文件变化时发出通知。这很有用，因为你没有必要停止和重启
Logback的完整细节请参见Logback手册。
默认扫描周期是1分钟。这在你希望更改日志消息格式时很方便。你所必要做的就是编
日志轮转值得稍作讨论。虽然程序员通常不需要负责日志轮转，
这一配置很容易理解，这是使用Logback之类的API的关键优势。Logback的另一个很
■%msg%n:%msg是提供给日志记录（由程序员提供）调用的原始日志消息。%n是平台
■[%thread]：左右括号是字面量字符串，意味着它们将会出现在日志消息中。%thread
■%d{HH:mm:ss.SSS}：%d输出日志事件的日期。左右花括号告诉Logback接受ISO
%d{HH:mm:ss.SSS] [%thread]%-51eve1%1ogger{36}-%msg%n
配置中驱动这一格式的是下面这一行：
17:44:58.828 [main] INF0 chapters.configuration.MyApp2-Entering
我们按照顺序看看每个参数：
利用上述配置，从应用程序中用库生成的日志消息格式如下：
上面的例子将日志记录到标准输出（STDOUT），是最简单的例子。
1%logger{36}：这个参数打印日志记录器，最多36个字符。本例中日志记录器就是应
■
用程序本身。
8601日期格式。
application.
相关的行分隔符。
%-5level：输出日志记录级别并左对齐，最小宽度为5，没有最大宽度。
将打印线程名（如果设置的话）或者调用日志记录消息的方法。
日志轮转
，但是如果你对此有所理
第18章供程序员使用的日志257
---
## Page 279
258
第三方日志记录库的内建功能处理。
解，将是很好的事情。首先，日志轮转机制有两种基本类型：
和场外存档及存储时很有价值。
用程序创建一个新的空文件，开始写入。这种技术在日志文件保存多个拷贝，用于短期分析
但是，什么是日志轮转？日志文件轮转方案中，活动日志文件被移到存档副本，并为应
2）应用程序本身负责处理日志轮转，这可以通过定制编写的应用程序代码，或者使用
1）使用日志轮转脚本管理日志何时轮转，何时存档到某个外部存储位置。
这个配置文件示例将在每天或者日志达到100MB时轮转。这对于记录大量消息的应用
我们来简单地看看Logback的基于时间和基于大小轮转配置：
从应用程序的立场出发，它并不知道日志轮转的发生。可以采用多种日志轮转方案：
■
基于时间：日志文件根据某个时间周期轮转，例如每个小时、每天、每周等。
RollingFileAppender">
mylog.txt
%msg%n
TimeBasedRollingPolicy">
mylog-%dIyyyy-MM-dd).%i.txt
100MB
class="ch.qos.logback.core.rolling.
SizeAndTimeBasedFNATP">
---
## Page 280
的含义。下面的列表提供了实用的日志条目中应该包含的部分：
它就不应该包含在日志条目中。
我们来看一些不好的日志消息（Chuvakin，2010）。第一条消息包含了遗漏了年的时间戳：
索！）的日志数据。
程序来说是实用的技术。不等到日志文件增长到1GB 就进行轮转，就能得到可管理（也可搜
18.3.5
没有唯一的消息类型标识符
没有唯一的消息标识符
没有源/目标IP/主机名和端口
描述模糊或者没有描述
神秘数字
遗漏时间戳和时区
18.3.4
最佳的日志消息适合于人工和自动分析。日志消息的各个组成部分放在一起会有更重要
如果不谈及日志消息的坏习惯，对于有关程序员日志记录的章节来说就不完整。首先，
这位程序员直率得可怕：她决定放弃，告诉我们这里没有任何说明。
userenv[error]1040 xYZcoRP\wsupx No description available
最后，日志记录中常常会看到下面这样的例子：
表18.5概述了你应该如避瘟神的常见坏习惯。
“魔法”或者秘密数字（本例中的202）的使用很不好。
Message 202User transitioning priv1evel
下面看到的消息不仅完全遗漏了时间戳，还包含正在过渡到某个权限级别的人的用户名：
上述消息还遗漏了时区信息和其他有意义的内容。
Aug 11 09:11:19xxnullpif ?exit!0
坏习惯
不好的日志消息
日志消息格式
个问题的方法之一是将日志消息的常见部分连接起来
识符通常由解析日志消息的系统或者工具生成
程语言有预定义的例程以生成全局唯一标识符（UUID）。尽管如此，唯一消息标
端口信息必须包含在日志条目中
工具难以解读消息，在调查系统停机或者潜在安全问题时还会浪费宝贵的时间
这不仅导致误导日志审核人员，而且令他们感到沮丧
索等
这不同于唯一的ID，通常是标识消息所述类型或者级别的字母数字值。解决这
不是所有应用程序都面向连接。但是对于客户-服务器系统，源和目标IP以及
日志条目必须清晰、简洁和容易理解。模糊或者遗漏描述不仅使人们和自动化
日志消息中常常出现神秘的数字。问题是许多时候这些数字没有支持的文档。
一描述某条消息的方法，对于日志消息的搜索和其他应用程序很有价值。
每条日志消息有唯一的标识符很重要。这个ID通常是递增的整数值。拥有唯
没有这些信息，难以知道日志实际发生的时间，这可能损害调查规程、数据搜
表18.5日志记录坏习惯摘要
解释
如果没有关于该数字含义的文档，
第18章供程序员使用的日志259
许多编
---
## Page 281
的名称及取值。
得到一个名称／取值配对的列表。然后，从等号处分离，得到每个名称/取值配对为你提供
配对之间的分隔。你还应该看到，对于如何解析消息没有任何歧义。你首先从逗号处分离，
用的技术使用等号创建一个名称和取值的映射。然后，用逗号作为分隔符，标记名称/取值
消息：
我们看到，这条消息有刚刚讨论的许多组件。每个组件使用了名称/取值配对。这种常
2010/12/31 10:00:01AM GMT+7priority=3,system=mainserver，
好了，那么根据上述原则，实用的日志消息是什么样子呢？我们来考虑下面这条虚构的
action=login,object=database，status=failed,reason="password
module=authentication,source=127.0.0.1,user=kjschmidt（idp:solar),
■用户名有助于回答与用户或者管理员活动相关的活动是由“谁”发起的。此外，包含
有其他类型的状态，例如“延期”）
状态也有助于回答“什么”的问题，它说明针对对象的操作成功还是失败。（也可能
以由分析系统使用，检测何时试图传输超过预期大小的数据批次。
或者其他应用程序，将数据从一个位置传输到另一个位置，对这个组件的日志记录可
活动度量不是所有应用程序都需要记录的组件。例如，如果你的应用程序代表某个人
记录。如果你的应用程序写人与其他应用程序共享的日志文件，这就很实用。
进程ID（PID）和线程ID（TID）对日志都很有用，可以关联运行应用程序及其日志
唯一的会话ID有助于集合不同线程和进程中的相关消息。
的，因为不同的组织有不同的优先级。（例如，不同公司对于信息可用性和机密性有
优先级有助于表明事件的重要性。但是，按照重要性对事件进行统一的评级是不可能
操作有助于回答“如何”的问题，它提供了事件的特性。
记住，日志的客户是安全和审计人员。
原因有助于回答“为什么”的问题，这样日志分析就不需要深人地挖掘潜在的原因。
和时区，某些高容量系统还使用事务ID。
时间戳和时区回答“何时”的问题。时区对于分布式应用是不可或缺的。除了时间戳
决于你的应用程序，包括目标、源端口和目标端口。
的问题。源可以是互联网协议（IP）地址或者主机名的形式。应该使用的相关组件取
对于和网络连接性或者分布式应用程序操作相关的消息，源有助于回答“来自何处”
文，例如发起者和目标系统、应用程序或者组件。
系统、应用程序或者组件有助于回答“何地”的问题，必须提供相关的应用程序上下
答“什么”的问题。
对象有助于指出受到影响的系统组件或者对象（如用户账户、数据资源或者文件），回
身份提供者的名称或者担保用户名的安全领域也很有帮助（如果这些信息可用的话)。
incorrect"
不同的策略）
---