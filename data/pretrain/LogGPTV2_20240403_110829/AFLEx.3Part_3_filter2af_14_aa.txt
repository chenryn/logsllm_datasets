# AFL源码分析（Ex.3）——附录（Part 3）
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0\. 写在前面
**本文全文参考了[da1234cao](https://github.com/da1234cao)师傅的`Github`仓库
的相关内容，我对全文中机翻程度过高以致未正确表达原文语义、异译程度过高以致偏离原文语义、语句不通顺或不合语法的大量文本进行了修改，特此说明。以下文章中的“原译者”即代指[da1234cao](https://github.com/da1234cao)师傅。**
此文章主要是对`AFL`仓库中`doc`目录下的所有文档进行翻译。
  * [x] env_variables.txt(环境变量手册) —— 历史文章(Part 1)
  * [ ] historical_notes.txt(历史记录)
  * [ ] INSTALL(安装说明)
  * [x] life_pro_tips.txt(使用技巧) —— 历史文章(Part 1)
  * [x] notes_for_asan.txt(`ASAN`模式手册) —— 历史文章(Part 2)
  * [x] parallel_fuzzing.txt(同步`fuzz`模式手册) —— 历史文章(Part 2)
  * [x] perf_tips.txt(故障排除手册) —— 本文
  * [x] QuickStartGuide.txt(快速上手) —— 本文
  * [ ] sister_projects.txt
  * [x] status_screen.txt(GUI手册) —— 本文
  * [ ] technical_details.txt
后续附录将继续翻译以上列表中的文章。
## 1\. perf_tips.txt(故障排除手册)
此文件提供了对缓慢或资源浪费的模糊测试作业进行故障排除的提示。 有关一般说明手册，请参阅自述文件。
###  1.1 保持你的输入样例为小型文件
这可能是最重要的一步！大型输入文件不仅需要更多的时间和内存来让待测的二进制文件顺利解析此输入，而且还会在其他的几个方面显着降低模糊测试过程的效率。
为了说明这一点，假设您的样本变异规则是随机对种子文件中的内容进行位翻转操作，一次操作一位。 那么假设如果你翻转第`47`位，你会遇到一个安全漏洞；
翻转任何其他位只会导致被测程序抛出一个”无效文档”的异常。
现在，如果您的种子测试用例的长度为`100`个字节，那么您将有`71％`的机会在前`1,000`个exec中触发错误——针不戳！
但是，如果测试用例的长度为`1 KB`，则我们将在同一时间范围内随机触发错误的可能性将降低至`11％`。那么进一步的，如果它具有`10
KB`的非必需杂内容，则触发错误的可能性将下降到`1％`。
最重要的是，在输入样例较大的情况下，待测目标的运行速度可能比以前慢`5`到`10`倍——因此，模糊效率的总体下降可能很容易高达`500`倍左右。
在实践中，这意味着您不应该直接使用您使用手机等专业设备拍摄的照片来模糊测试图像解析器。
而是生成一张很小的`16x16`图片，并通过`jpegtran`或`pngcrunch`运行该图片以取得良好效果。 大多数其他类型的文档也是如此。
`../testcases/*`中有很多小型的种子测试用例——试试看使用他们或提交新的测试用例！
如果要以更大的第三方语料库启动测试，请首先在该数据集上运行`afl-cmin`以缩小输入样例并设置有效的超时时间。
###  1.2 使用一个简单的目标
请考虑在您的模糊测试工作中使用更简单的目标二进制文件。
例如，对于图像格式，轻量的实用程序(如`djpeg`、`readpng`或`gifhisto`)比`ImageMagick`的转换工具快得多(`10-20`倍)——尽管他们都使用大致相同的库级图像解析代码。
即使您没有针对特定目标的轻量级工具，也请记住，您始终可以使用另一个相关的库来生成语料库，然后稍后将其手动输入到耗费更多资源的程序中。
[原译者注：对于目标中使用的二进制文件，选择尽量小的，且可以达到需要的功能。测试一个程序的时候，能不能不一个大程序分开来测试，不同的阶段有不同的输出。类似于流水线的方式测试，加快测试速度。]
###  1.3 启用基于 LLVM 的检测模式
当对慢速目标进行模糊处理时，可以使用`llvm_mode/README.llvm`中介绍的基于`LLVM`的检测模式，`fuzzer`的性能将被提高2倍。
请注意，此模式需要使用`clang`，不适用于`GCC`。
`LLVM`模式还提供了两种额外的模糊测试模式：
  * `persistent mode`：进程内持久化`fuzz`模式，该模式对于某些类型的自有库文件可以很好地工作，对于快速目标，可以将性能提高5-10倍。
  * `deferred fork server`模式：延迟`fork`模式，该模式可以为启动开销高的程序提供巨大的增益。两种模式都要求您能编辑待测程序的源代码，但更改通常只是策略性地增加一两行。
###  1.4 对待测文件进行前置的分析和优化
检查是否有任何明显改善性能的参数或设置。 例如，可以使用以下命令调用`IJG jpeg`和`libjpeg-turbo`随附的`djpeg`实用程序：
    -dct fast -nosmooth -onepass -dither none -scale 1/4
这将加快此程序的运行速度，尽管这伴随着解码图像的质量相应下降的代价，但这可能并不是您关心的问题。
在某些程序中，可以完全禁用程序的输出流，或者至少使用计算成本较低的输出格式。 例如，使用图像转码工具，转换为`BMP`文件将比转换为`PNG`快很多。
对于某些可以忽略错误的解析器，启用更为严格的模式(即，在发生第一个错误后退出)可能会导致生成的样例输入文件更小并改善运行时间，而不会牺牲覆盖率。例如，对于`sqlite`，您可能需要指定`-bail`。
如果程序仍然太慢，您可以使用`strace -tt`或等效的性能分析工具来查看测试目标文件是否正在在做任何会导致运行变慢的事情。
有时，您可以通过将目标文件的`stdin/stdout/stderr`等交互流设置为`/dev/null`或禁用某些实际测试并不真正需要的编译时功能来加快速度(尝试`./configure
--help`)。 众所周知，会大量消耗资源的事情之一是通过`exec*()、popen()、system()`或其等效函数去调用其他实用程序。
例如，当`tar`确定输入文件是压缩档案时，它可以调用外部解压缩工具去解压此文件。
一些程序还可能故意调用`sleep()`、`usleep()`或`nanosleep()`，`vim`就是一个很好的例子。
其他程序可能会尝试`fsync()`等。
有第三方库可以帮助您轻松删除此类代码，例如：
[原译者注：这个挺好]
在测试由于不可避免的初始化开销而导致缓慢的程序时，您可能想尝试使用带`LLVM`延迟的`forkserver`模式(请参阅
`llvm_mode/README.llvm`)，此模式可以使您的测试速度提高高达`10`倍。
最后，很重要的是，如果您正在使用`ASAN`并且发现其运行的性能不可接受，请考虑暂时将其关闭，稍后使用启用`ASAN`的二进制文件手动检查其生成的语料库。[译者注：这里相当于把检查内存的功能摘出来。如果检查的内容可以分类，每次运行检查不同的内容，并行运行检查？感觉有点得不偿失。那对于过于消耗时间的内容检查，是不是可以摘出来做？以什么合适的尺度来判读是不是适合摘出来做。]
###  1.5 确保只检测真正想要测试的库
只检测您现在真正想要进行测试的库，一次只测试一个库。 `fuzzer`不会将系统范围的、非检测目标的库用于此次测试。
例如，在大多数情况下，`fuzzer`不会仅仅因为您正在测试依赖于`bignum`数学的加密测试目标而对`libgmp`进行检测。
当心那些把奇怪的第三方库和他们的源代码捆绑在一起的程序(`Spidermonkey`就是一个很好的例子)。
检查并调整`./configure`选项来将程序调整到最佳状态。
###  1.6 尝试并行化运行 fuzzer
`fuzzer`被设计为每个作业需要大约`1`个`CPU`核心。 这意味着在`4`核系统上，您可以轻松地运行四个并行的模糊测试作业，而性能损失相对较小。
有关如何执行此操作的提示，请参阅`parallel_fuzzing.txt`。
`afl-gotcpu`实用程序可以帮助您了解系统上是否仍有空闲`CPU`资源。(它不会告诉您内存带宽情况、缓存丢失情况或类似的资源信息，但这些不太可能成为问题。)
###  1.7 检查内存限制和超时限制是否不合适
如果您启用了`-m`或`-t`限制，且这个限制超过了`fuzzer`的实际需要，请考虑将它们置为合理值。
对于理论上应当非常迅速但在某些输入样例上实际变得缓慢的程序，您还可以尝试使用`-t`额外设置一个超时限制，这个额外的超时限制应当比`fuzzer`默认的超时时间更短。
在快速和空闲的机器上，将超时时间降低到`-t 5`可能是一个可行的计划。
`-m`参数也值得检查。 当出现异常的输入样例时，待测程序最终可能会花费大量时间来分配和初始化兆字节量级的内存。
使用`-m`设置更加严格的内存限制可以使`fuzzer`更快地放弃此异常的输入样例并且不会浪费`CPU`时间。[原译者注：程序是如何通过`-m`，起限制作用？]
###  1.8 检查系统设置
有几个操作系统级别的因素可能会影响模糊测试速度：
  * 避免高系统负载。尽可能使用闲置机器进行系统测试。并杀死任何非必要的会消耗 CPU 的进程（空闲的浏览器窗口、媒体播放器、复杂的屏幕保护程序等）。
  * 避免将网络文件系统用于`fuzzer`的`IO`或由待测目标访问以读取其所需的配置文件（请特别注意`home`目录，许多程序在其中搜索`.`文件）。
  * 按需进行`CPU`扩展。`Linux`的`CPU`需求调度器按特定时间表执行分析，并且众所周知它往往会低估由`afl-fuzz`(或任何其他模糊器)发出的短期进程的需求。在`Linux`上，这可以通过以下方式缓解： 
        cd /sys/devices/system/cpu
    echo performance | tee cpu*/cpufreq/scaling_governor
在其他系统上，`CPU`扩展的影响会有所不同；模糊测试时，可以使用特定于操作系统的工具来确定是否所有内核都在全速运行。
  * 禁用透明大内存页(`Transparent huge pages`,`THP`)机制当在内核中启用THP时，某些内存分配器(例如`jemalloc`)可能会导致严重的模糊测试性能损失。您可以通过以下方式禁用此功能： 
        echo never > /sys/kernel/mm/transparent_hugepage/enabled
  * 选择次优的调度策略。 这个设置的重要性要视测试目标情况而定，但是在`Linux`上，您可能需要确保设置了以下选项： 
          echo 1 >/proc/sys/kernel/sched_child_runs_first
      echo 1 >/proc/sys/kernel/sched_autogroup_enabled
为`fuzzer`进程设置不同的调度策略(例如`SCHED_RR`)通常也可以加快速度，但是需要格外小心异常的发生。
###  1.9 最后的解决方案，使用 -d
对于真的很慢的程序，如果您确实无法使用任何工具对巨大的输入样例进行转义或其他处理，或者当您只想尽早获得快速但是混乱的检测结果时，您可以使用于 -d 模式。
该模式会导致`afl-fuzz`跳过所有确定性检查的模糊测试步骤，这将使得输出变得不那么整洁，并且会使测试的最终深度降低一些，但它会给你一种比其他模糊测试工具更舒适的体验。[原译者注：？？？]
## 2\. QuickStartGuide.txt(快速上手)