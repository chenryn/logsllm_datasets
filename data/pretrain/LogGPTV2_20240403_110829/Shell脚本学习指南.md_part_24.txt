---
## Page 146
134
第6章
来说，在许多语言中，你可能会写x=X+2，以为x增加2。但+=运算符可以让你
使用更简洁的写法：S（（x+=2)），指的是为x增加2，且将得到的结果存储到x，
由于加1或减1的使用相当频繁，因此++与--运算符提供缩写形式完成它们。也就是：
++是增加1，而--是减1。这些都属于单元运算符（unaryoperator），现在就来看看它
们的作用：
S 1=5
S ecbo $((1++)) $1
5 6
S ecbo $((++i)) $1
发生什么情况呢？这两种情况，都是1的值加1。但是，运算符返回的值会根据它与变
量的相对位置而定。后缓式（postfix）的运算符（运算符出现在变量之后），在结果产生
后，将旧值返回给变量，再执行变量加1的操作。相对地，前缓式（prefix）中，运算数
则是放在变量的前面，先将变量加1，再返回新值给变量。--的工作方式和++类似，只
不过它的操作是将变量减1，而不是加1。
注章：++与--运算符是可选的：实际上，不必非支持它们。但bash与ksh93都支持此功能，
标准规范里，允许实现时可支持额外运算符，ksh93的所有版本都支持C的逗点运算符，
最近的版本还可以使用*支持取幂功能：bash也支持这两者。
标准疑范中仅描述使用常数值的算术，当参数计算先完成时-例如5i，算术计算程序就只
看到信数值。实际上，所有支持S（（...)）的Shell，都可以让用户在提供变量名称时，无
须前置s符号。
根据POSIX规定，算术运算使用的是C的带有正负号的长整数。ksh93支持浮点运算，
不过如果你对程序的可移植性有所要求，建议不要依赖它们。
6.2退出状态
每一条命令，不管是内置的、Shell函数，还是外部的，当它退出时，都会返回一个小的
整数值给引用它的程序，这就是大家所熟知的程序的退出状态（exit statu）。在Shell下
执进程序时，有许多方式可取用程序的退出状态。
6.2.1退出状态值
以惯例来说，退出状态为0表示“成功”，也就是，程序执行完成且未遭遇任何问题。其
www.TopSage.com
---
## Page 147
变量、判断、重复动作
135
他任何的退出状态都为失败（注1）（我们稍后将介绍如何使用退出状态）。内置变量？
（以$？访问它）包括了Shell最近一次所执行的一个程序的退出状态。
例如，当你输人1s时，Shell找到ls并执行该程序。当ls结束时，Shell会恢复1s的
退出状态。请见下面的例子：
S 1s -1 /dev/mul1
1 root root 1, 3 Aug 30 2001 /dev/nul1
18一个存在的文件
cIW-TW-IV-
1s的输出
出状志为成功
显示退出状态
$ 1efoo
18: foo: No such f11e or directory
现在1s一个不存在的文件
19的错误信息
显示退出状态
通出状态指出：失败
POSIX标准定义了退出状态及其含义，见表6-5。
表6-5：POSIX的结束状态
值
意义
0
命令成功地退出。
> 0
在重定向或单词展开期间（~、变量、命令、算术展开，以及单词切割）失败。
1-125
命令不成功地退出。特定的退出值的含义，是由各个单独的命令定义的。
126
命令找到了，但文件无法执行。
127
命令找不到，
> 128
命令因收到信号而死亡。
令人好奇的是，POSIX留下退出状态128未定义，仅要求它表示某种失败。因为只有低
位（low-order）的8个位会返回给父进程，所以大于255的退出状态都会替换成该值除
以256之后的余数。
你的Shell脚本可以使用exit命令传递一个退出值给它的调用者，只要将一个数字传递
给它，作为第一个参数即可。脚本会立即退出，并且调用者会收到该数字且作为期本的
退出值：
exit 42
给最后一个问题返目答案
注 1;
C与C++的程序员请注意，这个部分与你财使用的程序完全相反，请花点时间连应，
www.TopSage.com
---
## Page 148
136
exit
语法
exit [ exit-value ]
用途
目的是从Shell脚本返回一个退出状态给脚本的调用者。
主要选项
无
行为模式
如果没有提供，则以最后一个执行命令的追出状态作为联认的退出状态。如
果这就是你要的，则最好明自地在Shell脚本里这么写：
exit $?
6.2.2
if-elif-else-fi语句
使用程序的退出状态，最简单的方式就是使用if语句。一般语法如下：
if pipeline
[pipeline ...1
then
[elif pipeline
statements-if-true-1
[pipeline ...]
then
statements-if-true-2
..1
statements-if-all-else-fails1
fL
（方括号表示的是可选的部分，并非逐字输入。）Shell的语法是松散地建立在Algol68
之上，而后者是V7Shell的作者StevenBourne相当推崇的。Algol68最有名的地方是
在于：使用以方括号作为开始与结束的关键字将语句组织起来，而不是使用Algol60与
Pascal所使用的begin与end定界符，也不是使用因C而普及化并且也常出现在其他可
程序化的UNIX工具里使用的（和）。
以我们手边的例子来看，你应该大致猜得到它的工作方式：Shell执行第一组介于if与
then之间的语句块，如果最后一条执行的语句成功地退出，它便执行statements-if-
true-1，否则，如果有elif，它会尝试下一组语句块。如果最后一条语句成功地退出，
则会执行statements-if-true-2.它会以这种方式继续，执行相对应的语句块，直到
它碰到一个成功退出的命令为止。
www.TopSage.com
---
## Page 149
变量、判断、重复动作
137
如果if或elif语句里没有一个为真，并且else子句存在，它会执行statements-
if-all-else-fails。否则，它什么事也不做，整个if...fi语句的退出状态，就是
在then或else后面的最后一个被执行命令的退出状态。如果无任何命令执行，则遇
出状态为0。举例如下：
if grep pattern myfile > /der/nul1
then
模式在这里
else
模式不在这里
如果myfile含有模式pattern，则grep的退出状态为0.如果无任何的行匹配此模
式，则退出状态的值为1，且如果发生一个错误，则会具有一个大于1的值，Shcll会根
据grep的退出状态，选择要执行哪一组语句块。
6.2.3逻辑的NOT、AND与OR
有时，以否定状态表达测试操作会比较容易些：“如果John不在家，则…”，在Shell下，
这种情况的做法是：将惊叹号放在管道（pipeline）前：
if 1 grep pattern myfile > /dev/nu11
Chen
f1
模式不在这里
POSIX在1992标准中引进这种标记方式。你可能会看到较旧的Shell脚本使用冒号（：）
命令，其实并没有微任何事，它只是为了处理下面的情况：
if grep pattern myfile > /dev/nu11
then
不做任何事
else
模式不在这里
f1
除了以！来测试事情的相反面之外，你也常会需要以AND与OR结构来测试多重子条件
（如果John在家，且他不忙，则…），当你以&&将两个命令分隔时，Shell会先执行第
一个。如果它成功地退出，则Shell执行第二个。如果第二个命令也或功地遇出，则整
个语句块视为已经成功：
if grep pattern1 myf11e 66 grep patterm2 myf11e
then
myfile包含两种模式
fi
相对的，11运算符则是用乘测试两种条件中是否有一个结果为真：
www.TopSage.com
---
## Page 150
138
第6章
if gxep pattexnl myfile 11 grep pattern2 myfile
then
一个成是另一个模式出现
f1
这两种都是快捷（short-circuit）运算符，即当判断出整个语句块的真伪时，Shell会立
即停止执行命令.举例来说，在command1&command2下，如果commandl失败，则
整个结果不可能为真，所以command2也不会被执行，以此类推，command211
command2指的就是：如果commandl成功，那么也投有理由执行command2
不要会试过度“简练”而使用&&和11取代if语句。我们不反对简短且简单的事情，
如下：
$.who 1grep tolatoy > /dev/nul1 s& echo toletoy 1s 1ogged on
tolstoy 1s logged on
上面的实际做法是：执行who1grep...，且如果成功，就显示信息。而我们曾见
过有厂商提供Shell脚本，所使用的是这样的结构：
some_conmand &5 (
one command
and a third command
a second command
花括号将所有命令语句块在一起，只有在some_command成功时它们才被执行。使用if
可以让它更为简洁：
if some_conmand
then
cne command
a second comand
and a third command
fi
6.2.4test命令
test命令可以处理Shell脚本里的各类工作。它产生的不是一般输出，而是可使用的退
出状态。test接受各种不同的参数，可控制它要执行哪一种测试。
test命令有另一种形式：（...]，这种用法的作用完全与test命令一样。因此，下面
是测试两个字符串是否相等的两个语句：
then
f1
+ 1 *
www.TopSage.com
---
## Page 151
变量、判断、重复动作
test,[... ]
语法
test[expression ]
[[expression ]]
用途
为了测试Shell脚本里的条件，通过退出状态返回其结果，要特别注意的是：
这个命令的第二种形式，方括号根据字面意艾运字地输入，且必须与括起来
的expression以空白马开
主要选项与表达式
见表6-6与内文。
行为模式
test用来测试文件属性、比较字符事及比较数字。
登告
POSIX风格的表达式只是在真实系统上是可用表达式的一个子集，需留意可
移植性的问题。要了解更多信息，可参考14.3.2节。
除了极旧的UNIX系统外，test都已内置于Shell中。由于内置命令会比外
部命令先被找到，所以，要写一个简单的测试程序并将其执行文件命名为
test会有点麻烦，这种情况下你必须以，/test引用这样的程序（假设它们
在当前目录内）。
达式。通常，一元的表达式由看似一个选项的部分（例如，-d用来测试文件是否为目
录）与一个相对应的运算数组成，后者基本上（但不一定）是一个文件名。二元的表达
式则有两个运算数与一个内嵌的运算符，以执行某种比较操作。再者，当只有一个参数
时，test会检查它是否为null字符串。完整的列表参见表6-6.
表6-6：test表达式
运算符
如果.…则为真
string
string不是null
-b file
file是块设备文件
-c file
file是字符设备文件
-d file
file是目录
-efile
file存在
www.TopSage.com
---
## Page 152
140
第6章
表6-6：test表达式（续）
运算符
如果...则为真
-f file