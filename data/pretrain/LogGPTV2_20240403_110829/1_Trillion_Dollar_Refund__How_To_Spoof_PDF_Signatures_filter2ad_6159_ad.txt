PDF documents can be automated and outsourced to these services.
One of the most prominent vendors of validation services is
DocuSign. Aside from its online validation service, DocuSign also
offers a cloud PDF viewer and a signing application used by most
companies of the Fortune 500 list. Prominent examples include Dell,
eBay, VISA, Microsoft, Nike, and the USENIX Association [4, 13].
We additionally evaluated services used in different EU countries
(e.g., Austria [38] or Slovenia [10]) to evaluate multiple signatures
types (PAdES, CAdES, and XAdES) for the eIDAS regulation [48].
Test Setup. We evaluated each online validation service as follows.
First, we uploaded a validly signed PDF file (document_signed.pdf)
to the service by using the available upload functionality. The ser-
vice then generates a report containing details regarding the signa-
ture validity status. Another output was not provided in any case,
especially the content of the PDF file is not displayed.
We then modified the signed PDF file using different variants
of all three attack classes successively. If one of these attack vec-
tors results in a report that is indistinguishable from the report
of document_signed.pdf, we classify the attack as successful. An
example of a successful attack is presented in Figure 11.
Results. We analyzed eight free and publicly available validation
services against all three attack classes. The signature validation
could be bypassed on six services (cf. Table 2).
To summarize, two of the analyzed services [9, 38] were vulner-
able to SWA and five services [9, 10, 12, 14, 20] could be bypassed
using the ISA class. This is contrary to the results from the evalua-
tion of viewer applications, where we could find more applications
vulnerable to SWA.
One interesting challenge during the evaluation was to find
a clear indication in the report whether a signature is valid. For
example, the DSS Demonstration WebApp [14] prints out two fields
containing the verification report: Indication and Signature scope, see
Figure 11: Validation report created by the Digital Signing
Service for a manipulated but signed PDF file [14].
Figure 11. The Indication field summarizes the results of the digital
signature validation. In our case, the result is: TOTAL PASSED. With
respect to USF and SWA we received a warning or a error message if
the attacks are detected. Regarding ISA, the Signature Scope contains
information indicating whether the complete document is signed
or not. In case that the ISA attack is detected, the validation service
should print out that the scope is partial and only parts of the
document are signed. According to our evaluation, version 5.2 of
the DSS Demonstration WebApp is susceptible against ISA since
it returns a Full PDF as Signature scope even if the document was
modified via incremental saving in Variant 2. Along with all EU
validation services, we analyzed DocuSign – one of the worldwide
leading cloud services – was the only service vulnerable against
both attacks ISA and SWA.
6 HOW TO FIX PDF SIGNATURES
In this section, we propose concrete countermeasures to fix the
previously introduced attacks. We,therefore, carefully studied the
main reasons for the attacks on PDF signatures and were able to
identify two root causes: (1) The specification does not provide
any information with a concrete procedure on how to validate
signatures. There is no description of pitfalls and any security
considerations. Thus, developers must implement the validation
on their own without best-common-practice information. (2) The
error tolerance of the PDF viewer is abused to create non-valid
documents bypassing the validation, yet is correctly displayed to
the user.
The Verification Algorithm. When considering a proper coun-
termeasure, we defined an algorithm which addresses USF, ISA,
and SWA but does not negatively affect the error tolerance of the
PDF viewers (cf. Listing 2). It describes a concrete approach on
how to compute the values necessary for the verification and how
to detect manipulations after the PDF file was signed. The speci-
fied algorithm must be applied for each signature within the PDF
document.
Session 1A: Attack ICCS ’19, November 11–15, 2019, London, United Kingdom10Signature Validation Service
Version
USF
PDF Signature
ISA
SWA
Comments
DocuSign [9]
eRTR Validation Service [38]
DSS Demonstration WebApp [14]
DSS Demonstration WebApp [7]
Evrotrust (free) [12]
Ellis [20]
VEP.si [10]
SiVa Sample Application [11]
Total Successful Attacks
v1 REST API with
PDFKit.NET
18.3.200.9768
v 2.0.3
WebApp 5.2
WebApp 5.3.1
12.0.20
version 0.9.1, build
1526594400
2017-06-26
release-2.0.1
✓
✓
✓
✓
✓
✓
✓
–
(cid:32)
(cid:32)
(cid:32)
✓
(cid:32)
(cid:32)
(cid:32)
–
(cid:32)
(cid:32)
✓
✓
✓
✓
✓
–
0/8
Summary Signature Vulnerabilities: 6/8
5/8
2/8
✓: Secure/Attack fails;
(cid:32): Insecure/Attack successful;
(cid:72)(cid:35): Limited attack success
Table 2: Evaluation results of eight online signature validation services showing six of them vulnerable.
Could not be evaluated since valid documents
were shown invalid due to PKI issues
As an input, it requires the PDF file as a byte stream and the
signature object.
INPUT: PDFBytes, SigObj
// ByteRange is mandatory and must be well−formated
// Preventing USF:
if (byteRange == null OR byteRange.isEmpty) return false
// Parse byteRange
if (byteRange.length(cid:44)4) return false
for each x in byteRange { if x (cid:44) instanceof(int) return false}
// BytRange must cover start of file
if (a (cid:44) 0) return false;
// Ensure that more than zero bytes are protected in hashpart1
if (b ≤ 0) return false
// Ensure that sencond hashpart starts after first hashpart
if (c ≤ b) return false
// Ensure that more than zero bytes are protected in hashpart2
if (d ≤ 0) return false
// Preventing ISA. ByteRange must cover the entire file.
if ((c + d) (cid:44) P DF Bytes .lenдth) return false;
// The pkcs7 blob starts at byte offset (a+b) and goes to offset c
1
2
3
4 byteRange = SigObj.getByteRange
5
6
7
8
9
10 a, b, c, d = byteRange
11
12
13
14
15
16
17
18
19
20
21
22 pkcs7Blob = PDFBytes[(a+b):c]
23
24
25
26
27
28
29
30 hashpart1=PDFBytes[a:(a+b)]
31
32 hashpart2=PDFBytes[c:(c+d)]
33
34 return pkcs7.verify(sig, cert, hashpart1||hashpart2)
// Preventing USF. Pkcs7Blob value is not allowed to be null or empty.
if (pkcs7Blob == null OR pkcs7Blob.isEmpty) return false
// pkcs7Blob must be a hexadecimal string [0−9,a−f,A−F]
if (pkcs7Blob contains other chars than [0−9,a−f,A−F]) return false
// Parse the PKCS#7 Blob
sig, cert = pkcs7.parse(pkcs7Blob)
// Select (a+b) bytes from input PDF begining at byte a=0, i.e. 0 ... a+b−1
// Select (c+d) bytes from input PDF begining at byte c, i.e. c ... c+d−1
// Verify signature
Listing 2: Pseudo-code preventing USF, ISA and SWA.
In Line 4, we first extract the ByteRange from the signature
object. To prevent USF, we ensure that ByteRange is not null or
empty in Line 7.
Lines 9-22 then validate the values a, b, c, and d of the ByteRange.
First, Line 10 ensures that it contains exactly four values to minimize
an attacker’s attack surface. Line 11 additionally ensures that each
ByteRange value is an integer. Lines 14 to 20 ensure that ByteRange
satisfies the following condition: 0=a  0 and c > b and d > 0. Enforcing this
condition ensures that the signature always covers the beginning of
the file (a = 0), prevents signed blocks of length zero (b > 0, d > 0),
and ensures that both signed blocks are non-overlapping (c > b).
Finally, we verify that ByteRange covers the entire file (Line 22) in
order to detect ISA. Lines 24-29 parse the Contents parameter of
the signature object, which is a PKCS#7 blob.
The critical aspect is that we interpret everything that is not
covered by the ByteRange as the Contents parameter of the PDF
signature. Theoretically, the check in Line 27 should never fail,
because we previously verified (a+b)=b and b  0. Nevertheless, we leave this line here
due to its importance for preventing SWA. Line 29 additionally
ensures that only hex characters can be in the unprotected part of
the PDF file, preventing further unwanted modifications of the file.
Lines 31-32 parse the PKCS#7 blob and extract the information
to be used for the signature verification. Lines 34-38 determine the
bytes of the input PDF that are signed.
Finally, Line 41 calls the PKCS#7 verification function and returns
the validity status of the signature.
Drawback. Specifying the algorithm in Listing 2 requires a change
in the PDF specification which defines ByteRange as an optional
parameter [21, Section 8.7]. In this case, the signature value will
be computed only over the signature dictionary leaving the en-
tire document unprotected. Such a feature allows an even more
powerful attack since the attacker can create validly signed docu-
ments by only injecting the signed signature dictionary without
a /ByteRange. Currently, none of the evaluated viewers supports
this feature.
Additionally, the algorithm leads to one usability issue if multiple
signatures are provided. Although these signatures are valid, only
the one covering the entire document will be displayed as valid.
This problem can be addressed by providing additional information
to the user that some of the signatures are valid but cover only a
specific revision and not the entire document. Adobe uses a similar
approach for the signature validation. All Adobe viewers show
information about the document revision protected by a signature
and allow only to open this revision. Thus, a user can easily verify
which information is signed and which is not.
Responsible Disclosure. After discovering the vulnerabilities we
created a security report containing the description of the attacks,
Session 1A: Attack ICCS ’19, November 11–15, 2019, London, United Kingdom11a list with the affected implementations, a proof-of-concept exploit
for each successful attack vector, and the pseudo-code preventing
the attacks [34]. On the 8th of November, we sent the report to
the BSI-CERT team who distributed it to all affected vendors and
governmental organizations dealing with PDF [34]. During the
responsible disclosure process, we supported BSI-CERT and the
vendors to fix the issues. The complete information relating to our
research on PDF signatures was published February 25, 2019 on
https://www.pdf-insecurity.org/. To support all vendors, we also
published all available exploits. Some vendors already integrated
these files in their test environments.
7 RELATED WORK
At the beginning of our research phase, we gathered and studied
the existing related work to PDF and file format security. This work
can be separated into the following four categories.
PDF Malware and PDF Masking. In 2010, Raynal et al. provided a
comprehensive study on malicious PDFs abusing legitimate features
in PDFs leading to Denial-of-Service (DoS), Server-Side-Request-
Forgery (SSRF), and information leakage [37]. Additionally, the
authors considered potential security issues regarding the signa-
ture verification by criticizing the design of the certificate trust
establishment. In 2012, Hamon et al. published a study revealing
weaknesses in PDFs leading to malicious URI invocation [49]. In
2013 and 2014, multiple vulnerabilities in Adobe Reader were re-
ported abusing the support of insecure PDF features, JavaScript,
and XML [22, 40]. Inführ [23] published a summary of the sup-
ported languages, file formats and features in PDFs leading to these
security issues. In 2018, Franken et al. evaluated the security of
third-party cookies policies [16]. Part of the evaluation revealed
weaknesses in two PDF reader by forcing them to call arbitrary
URIs. In the same year, multiple vulnerabilities in Adobe Reader
and different Microsoft products were discovered leading to URI
invocation and NTLM credentials leakage [24, 39].
Besides PDF malware, research has been provided on content
masking. In 2014, Albertini discovered new attack classes by com-
bining a PDF and a JPEG into a single polyglot file [2]. In 2017,
Markwood et al. introduced a novel attack related to content mask-
ing by using font encoding [31].
PDF Malware Detection. As a result of the discovered attacks
during the recent years, different security tools were implemented
detecting maliciously crafted documents [8, 26, 28, 30, 41, 43]. Such
tools rely on the detection of known attack patterns and structural
analysis of PDFs.
In 2016, Carmony et al. build a JavaScript reference extractor
for detecting parsing confusion attacks [6]. In 2017, Tong et al.
introduced a concept for a robust PDF malware detection based
on machine learning algorithms [46]. In the same year, Tong et al.
published a framework based on these algorithms and capable of
detecting PDF malware [47]. Maiorca et al. provided an overview
of the current PDF malware techniques and analyzed the existing
security tools by comparing them [29]. This paper mentions the
Incremental Saving (IS) feature for the first time in conjunction
with attacks, but up until our research, the feature has not been
combined with attacks on PDF signatures.
In 2012, Popescu et al. presented a proof-of-concept bypass for a
specific digital signature [36]. The attack is based on a polymorphic
file containing two different files – a PDF and TIFF. The risk ex-
ists if a victim signs the document unaware of the hidden content
inside the file. In 2015, Lax et al. documented potential security
topics related to digitally signed documents [27]. The authors con-
centrated on issues related to the signature generation process
like malware, signed documents containing dynamic content like
macros or JavaScript, and polymorphic documents similar to [36].
In 2017, Stevens et al. discovered an attack against SHA-1 [45] break-
ing the collision resistance. For the proof-of-concept, the authors
created two different PDF files containing the same digest value.
As a result, an attacker could create a PDF file with new content