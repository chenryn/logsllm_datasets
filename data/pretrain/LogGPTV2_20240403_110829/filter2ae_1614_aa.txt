**作者：Gh0u1L5**  
**本文为作者投稿，Seebug Paper 期待你的分享，凡经采用即有礼品相送！  
投稿邮箱：PI:EMAIL **
9月27号，黑客 ani0mX
在推特上公布了苹果公司的“史诗级安全漏洞”。该漏洞的影响范围极其广泛，囊括了绝大部分型号的苹果手机、平板、手表及智能电视等。而且由于它是一个“半硬件层”的漏洞，所以苹果永远无法通过软件更新修补这个漏洞。
漏洞发布当天，我在推特上看到另一名黑客 littlelailo 公布了一段30多行的草稿，简略聊了聊 checkm8
的攻击原理。我以为接下来很快国内安全社区也会有人放出更多细节，然而等了很久也没等到，索性自己开篇文章聊聊吧。我希望这篇文章：
  1. 能够让读者对 iPhone 启动机制有简单的了解。
  2. 能够让读者初步掌握如何逆向 iPhone 的 Secure ROM 。
  3. 能够讲明白 checkm8 漏洞攻击的基本思路和相关技术。
只要不以盈利为目的，任何个人或组织均可在注明出处的情况下自由转载，转载前通过评论区/私信简单告知本人即可。
* * *
## 0x00 iOS 安全启动机制简介
_已熟知 iOS 安全启动链与 Secure ROM 防护机制的读者可直接跳过本节。_
为了保证 iOS 系统的代码不被恶意篡改，苹果公司使用了一套名为 **安全启动链（Secure Boot Chain）**
的技术。他们将开机过程分为四到五个阶段，每个阶段负责检查下个阶段的代码，如果检查出任何问题，比如签名错误、安全模式不符，就立马中止开机。
在一些过时的资料里， iPhone 的开机过程分为以下五个阶段：
![iOS Secure Boot Chain
Outdated](https://images.seebug.org/content/images/2019/10/29/1572329500000-Boot-Chain-Outdated.png-w331s)
虽然这五个阶段被人引用过很多次，但其实它已经错了三年多了。从 A10
处理器以来，苹果就已经放弃了双阶段加载，也就是说上图的那个`LLB`已经被删掉了，更新后的启动流程如下：
![iOS Secure Boot Chain
Latest](https://images.seebug.org/content/images/2019/10/29/1572329501000-Boot-Chain-Latest.png-w331s)
这四个阶段从左到右分别是：
  * **ROM / Secure ROM** ：开机启动时执行的第一段程序，负责检查并加载接下来的 iBoot 。
  * **iBoot** ：苹果开发的引导程序，负责检查并加载系统内核。
  * **Kernel** ：iOS 系统内核。
  * **OS** ：iOS 系统的用户界面、后台服务等非核心组件。
**Secure ROM 作为系统启动时执行的第一段程序，扮演着整个安全启动链技术的信任基石。**
一旦攻破了它，接下来所有阶段的代码都能随意篡改，因此苹果公司下了很大功夫来保护这段 ROM 程序：
**封杀写权限** ：这段程序烧写在 CPU 的硅片内部，无法拆解，无法替换。在工厂里一次性烧录完之后，就连苹果自己都没办法改动它。
**封杀读权限**
：这段程序完成工作后，会直接把自己所在的储存器锁掉，再没有任何办法能读取它。也就是说，启动之后哪怕你攻陷了整个系统，也读不到这段程序的内容。
苹果的想法很单纯——如果一段程序黑客读都读不到，改也改不了，那么这段程序应该就会很安全。等到文章结尾的时候，我会再花点笔墨聊聊这个想法为什么不现实。但现在，苹果的这些安全措施确实给我们造成了一点麻烦：我们连程序内容都看不到，怎么分析程序漏洞？
* * *
## 0x01 抓取 Secure ROM
刚刚我们提到， Secure ROM 完成工作后，才会把储存器锁住。换句话说，只要 Secure ROM 还没完成工作，我们就有机会从内存里读到它的内容。
如何抓住这个机会呢？这就轮到 checkm8 出场了。
checkm8 是一个任意代码执行漏洞，允许我们在 ROM 运行期间植入 payload。更贴心的是， ani0mX 还在自己发布的
[exploit](https://github.com/axi0mX/ipwndfu) 里附上了一段高质量的 payload 。允许我们通过 USB 给
payload 发送指令，执行各种高权限的操作，比如：
  * `./ipwndfu --dump-rom`： **将 iPhone 的 Secure ROM 直接从内存里抓取出来，保存为文件。**
  * `./ipwndfu --demote`：启用 JTAG 模式。配合一条5800多元的 Bonobo 线，你就可以用 gdb 随意调试 iPhone 内核了。如果公司或者实验室给报销的话，我真的强烈建议买一条（笑）。
另外， axi0mX 的 payload 里还有一个 execute 命令非常好用，但是没有放出命令行接口，只能自己写 Python
代码来调用。这个命令允许你调用内存里存在的任意函数，能传递参数，还能拿到返回值。但他的代码有个问题，传第8个参数的时候会传成第7个，用之前需要自己动手改一下。
好了，书归正传， **在 checkm8 的帮助下，窃取苹果公司层层保护的代码仅需三步：**
  1. 使用网上搜到的按键组合，把 iPhone 手机重启到 DFU 模式（固件升级模式）。
  2. 执行`./ipwndfu -p`命令植入 payload，如果显示漏洞利用失败的话就多试几次。
  3. 执行`./ipwndfu --dump-rom`命令读取 ROM 并保存到当前文件夹下，完工。
这套操作，真的，猴子训练一下都能做。checkm8 光靠这一个功能，我觉得就无愧于“史诗级”这个评价了。
成功拿到 ROM 的二进制机器码之后，接下来扔给反编译器就可以了。
苹果的 CPU 从 A7 开始都是 AArch64 架构， little-endian 字序， ROM
的起始地址都是`0x100000000`，设定好这三项之后，反编译器就能直出正确的汇编代码了。
![iOS Secure ROM Decompile
Result](https://images.seebug.org/content/images/2019/10/29/1572329501000-Ghidra-Secure-ROM.png-w331s)
除了反编译得到的这些代码外，网上还有一些开源的 iBoot 项目，以及苹果某实习生泄露出来的一份四五年前的旧版 Secure ROM
代码，这些材料对我们的逆向分析都非常有帮助。
但是，由于发布这些泄露代码铁定会吃一张苹果的律师函，所以我不会在这篇文章里引用或发布那份泄露代码，有需要的读者还请自己动手搜索一下。
最后要说的是，刚才那套轻松的招数最多只能用到 iPhone X 上，从 Xs / Xr 开始 checkm8
漏洞就没法用了。对于这些手机，目前我们也没有什么好办法，只能用黑盒测试、旧 ROM 代码和 iBoot 代码这三样凑活着挖漏洞。
iBoot 的代码能用来挖 ROM 的漏洞，是因为 iBoot 和 ROM 有一部分功能重叠，所以代码也有重叠。比如这次的 checkm8 漏洞，就是
ani0mX 在分析一个 iBoot 补丁的时候发现的。
至于解密 iBoot 的具体方法，因为好像有点偏题了，所以将来有机会的话再开篇文章讲讲吧。有兴趣的读者可以先自行了解一下 iOS 的 GID
Key、IMG3/IMG4、KBAG 这几个概念。
* * *
## 0x02 漏洞原理解析
我前文中提到过，利用 checkm8 前需要先把手机重启到 DFU 模式，因为这次的漏洞正是出在这个 DFU 模式上。
苹果的 DFU 模式大致相当于一个“应急启动模式”，重启到这个模式后，用户可以用 USB
传入一个临时系统，用临时系统开机启动。（当然，这个临时系统必须是苹果官方系统。）
基于 littlelailo 的草稿、 iPhone 8 的逆向结果，以及一些“开源”的 iBoot 项目，我整理出了 DFU 应急启动的八个步骤：