                                   P  Si  Gr  Pr   Lo
Sel    Base     Limit    Type      l  ze  an  es   ng   Flags
---- -------- -------- ---------- - -- -- -- -- --------
001B 00000000 ffffffff Code RE Ac  3  Bg  Pg  P    Nl   00000cfb
其中Sel代表选择子（Selector），Base和Limit分别是基地址和边
界，Type是段的类型，RE代表只读（Read Only）和可以执行
（Executable），Ac代表被访问过。Type后面的Pl代表特权级别
（Privilege Level），数值3代表用户特权级，Size代表代码的长度，
Bg（Big）意味着32位代码，Gran代表粒度，Pg意味着粒度的单位是内
存页（4KB），Pres代表Present，即这个段是否在内存中，因为
Windows系统使用分页机制来实现虚拟内存，所以段的存在标志不再起
重要作用，Long下的Nl表示Not Long，意味着这不是64位代码。
以下是DS和ES所代表描述符的信息：
0:000> dg 23
                                  P   Si   Gr   Pr  Lo
Sel   Base      Limit     Type    l   ze   an   es  ng   Flags
---- -------- -------- ---------- - -- -- -- -- --------
0023 00000000 ffffffff Data RW Ac 3   Bg   Pg   P   Nl   00000cf3
因为DS和ES是用来选择数据段的，所以可以看到类型属性中有数
据（Data）和读写（RW）。另外，值得注意的是，以上两个段的基地
址都是0，边界都是4GB1，像这样将段的基地址设为0，长度设为整个
内存空间大小（4GB）的段使用方式称为平坦模型（Flat Model）。
下面再观察一下FS寄存器所指向的段描述符：
0:001> dg 38
                                  P   Si   Gr  Pr   Lo
Sel    Base     Limit     Type    l   ze   an  es   ng    Flags
---- -------- -------- ---------- - -- -- -- -- --------
0038 7ffde000 00000fff Data RW Ac 3   Bg   By  P    Nl    000004f3
易见这个段的基地址不再为0，边界也不是4GB1，而是
4KB1（4095）。事实上，在Windows系统中，FS段是用来存放当前线
程的线程环境块，即TEB结构的。TEB结构是在内核中创建，然后映射
到用户空间的。
使用～命令列出线程的基本信息，可以看到线程1的TEB结构地址
正是FS所代表段的基地址。
0:001> ~
   0 Id: fd4.1e10 Suspend: 1 Teb: 7ffdf000 Unfrozen
.  1 Id: fd4.1294 Suspend: 1 Teb: 7ffde000 Unfrozen
TEB中保存着当前线程的很多重要信息，很多系统函数和API是依
赖这些信息工作的，包括著名的GetLastError() API，其反汇编代码如
下：
0:000> u kernel32!GetLastError
kernel32!GetLastError: 
7c8306c9 64a118000000    mov     eax,dword ptr fs:[00000018h] 
7c8306cf 8b4034          mov     eax,dword ptr [eax+34h] 
7c8306d2 c3              ret
把上面的指令翻译成C语言的代码，应该是：
return NtCurrentTeb()->LastErrorValue;
因为偏移0x34的字段刚好是LastErrorValue：
0:018> dt _TEB -y LastE
ntdll!_TEB
   +0x034 LastErrorValue : Uint4B
上面的汇编指令还隐含了一种约定：函数的返回值（不要与函数返
回地址混淆）如果是整数，通用寄存器可以容纳，那么通常是使用寄存
器来返回的，x86架构中，一般使用的是EAX寄存器。明白了这种约定
后，在调试时，我们便可以通过观察EAX寄存器来了解函数的返回值，
通常应该在子函数即将返回或者刚刚返回到父函数时观察，因为在其他
地方，EAX寄存器可能被用作其他用途。
观察同一个Windows系统中的其他进程，我们会发现，其他进程的
CS、DS、ES、GS寄存器的值和上面的是一模一样的，这说明多个进程
是共享GDT表中的段描述符的。这是因为使用了平坦模型后，它们的基
地址、边界都一样，属性也一样，因此没有必要建立多个。
除了上面介绍的代码段和数据段描述符（S位为1），另一类重要的
描述符是系统描述符（S位为0），包括描述LDT所在段的段描述符、描
述TSS段的段描述符、调用门描述符、中断门描述符、陷阱门描述符和
任务门描述符，后4种通称门描述符，3.5节将做进一步介绍。
总的来说，段机制使保护模式下的所有任务都在系统分配给它的段
空间中执行。每个任务的代码（函数）和数据（变量）地址都是相对于
它所在段的一个段内偏移。处理器根据段选择子在段描述符表（LDT、
GDT或IDT）中找到该段的段描述符，然后再根据段描述符定位这个
段。每个段具有自己的特权级别以实现对代码和数据的保护。
2.7 分页机制
IA处理器从386开始支持分页机制（paging）。分页机制的主要目
的是高效地利用内存，按页来组织和管理内存空间，把暂时不用的数据
交换到空间较大的外部存储器（通常是硬盘）上（称为page out，换
出），需要时再交换回来（称为page in，换进）。在启用分页机制后，
操作系统将线性地址空间划分为固定大小的页面（4KB、2MB、4MB
等）。每个页面可以被映射到物理内存或外部存储器上的虚拟内存文件
中。尽管原则上操作系统也可以利用段机制来实现虚拟内存，但是因为
页机制具有功能更强大、灵活性更高等特点，今天的操作系统大多都是
利用分页机制来实现虚拟内存和管理内存空间的。深入理解分页机制是
理解现代计算机软硬件的一个重要基础。
 老雷评点  
分页技术在20世纪60年代萌生并逐渐成熟，对现代计算机发
展之贡献不胜枚举，对计算机系统影响之广无有出其右者。
本节将以x86架构为例详细介绍分页机制。2.9节将扩展到ARM架
构。
首先，操作系统在创建进程时，就会为这个进程创建页表，从本质
上讲，页表是进程空间的物理基础，所谓的进程空间隔离主要因为每个
进程都有一套相对独立的页表，进程空间的切换实质上就是页表的切
换。x86处理器中的CR3寄存器便是用来记录当前任务的页表位置的。
当程序访问某一线性地址时，CPU会根据CR3寄存器找到当前任务使用
的页表，然后根据预先定义的规则查找物理地址。在这个过程中，如果
CPU找不到有效的页表项或者发现这次内存访问违反规则，便会产生页
错误异常（#PF）。该异常的处理程序通常是操作系统的内存管理器。
内存管理器得到异常报告后会根据CR2寄存器中记录的线性地址，将所
需的内存页从虚拟内存加载到物理内存中，并更新页表。做好以上工作
后，CPU从异常处理例程返回，重新执行导致页错误异常的那条指令，
再次查找页表。这便是虚拟内存技术的基本工作原理。要深入学习，还
有很多细节需要了解。
下面我们来看一下控制寄存器中3个与分页机制关系密切的标志
位。
CR0的PG（Paging）标志（Bit 31）：用于启用分页机制，从386开
始的所有IA-32处理器都支持该标志。通常，操作系统在启动早
期，初始化内存设施，并通过这一位正式启用页机制。
CR4的PAE（Physical Address Extension）标志（Bit 5）：启用物理
地址扩展（简称PAE），可以最多寻址64GB物理内存，否则最多
寻址4GB物理内存。Pentium Pro处理器引入此标志。
CR4的PSE（Page Size Extension）标志（Bit 4）：用于启用大页面
支持。在32位保护模式下，当PAE=1时，大页面为2MB，当PAE=0
时，大页面为4MB。奔腾处理器引入此标志。
接下来，我们将深入到页表内部，探索其中蕴藏的奥秘。页表是地
址翻译的依据，决定着线性地址到物理地址的映射关系，它的作用就像
是字典的检字表一样，地位非同寻常。CPU的运行模式不同，页表的结
构可能也会不同。进一步说，x86 CPU的页表结构主要与是否启用PAE
和是否运行在64位模式有关。下面先介绍最简单的没有启用PAE的32位
情况。
2.7.1 32位经典分页
当CR0的PG标志为1、CR4的PAE为0时，CPU使用32位经典分页模
式。所谓经典模式，是相对于后来的PAE模式而言的，它是80386所引
入的。在这个模式下，页表结构为两级，第一级称为页目录（Page
Directory）表，第二级称为页表（Page Table）。
 老雷评点  
“经典”二字极恰。此模式之二级表结构，有张有弛，增之则
过繁，删之则过简，可谓尽善尽美。与其相比，后来引入之扩展
皆逊色。
页目录表是用来存放页目录表项（Page-Directory Entry，PDE）的
线性表。每个页目录占一个4KB的内存页，每个PDE的长度为32个比特
位（4字节），因此每个页目录中最多包含1024个PDE。每个PDE中内
容可能有两种格式，一种用于指向4KB的下一级页表，另一种用于指向
4MB的大内存页。图2-9所示的是指向4KB页表的PDE的格式。其中高20
位代表该PDE所指向页表的起始物理地址的高20位，该起始物理地位的
低12位固定为0，所以页表一定是按照4KB边界对齐的。
图2-9 指向页表的页目录表项（PDE）的格式（未启用PAE）
图2-10所示的是用于指向4MB内存页的PDE格式，其中高10位代表
的是4MB内存页的起始物理地址的高10位，该起始物理地址的低22位固
定为0，因此4MB的内存页一定是按4MB进行边界对齐的。
图2-10 指向4MB内存页的页目录表项（PDE）的格式（未启用PAE）
页表是用来存放页表表项（Page-Table Entry，PTE）的线性表。每
个页表占一个4KB的内存页，每个PTE的长度为32个比特位，因此每个
页表中最多包含1024个PTE。2MB和4MB的大内存页是直接映射到页目
录表项，不需要使用页表的。图2-11所示的是PTE的具体格式，其中高
20位代表的是4KB内存页的起始物理地址的高20位，该起始物理地址的
低12位假定为0，所以4KB内存页都是按4KB进行边界对齐的。
图2-11 页表表项（PTE）的格式（未启用PAE）
有了前面的基础后，下面来看一下CPU是如何利用页目录和页表等
数据结构将一个32位的虚拟地址翻译为32位的物理地址的。其过程可以
概括为如下步骤。
① 通过CR3寄存器定位到页目录的起始地址，正因如此，CR3寄存
器又称为页目录基地址寄存器（PDBR）。取线性地址的高10位作为索
引选取页目录的一个表项，也就是PDE。
② 判断PDE的PS位，如果为1，代表这个PDE指向的是一个4MB的
大内存页，PDE的高10位便是4MB内存页的基地址的高10位，线性地址
的低22位是页内偏移。将二者合并到一起便得到了物理地址。如果PS位
为0，那么根据PDE中的页表基地址（取PDE的高20位，低12位设为0）
定位到页表。
③ 取线性地址的12位到21位（共10位）作为索引选取页表的一个
表项，也就是PTE。
④ 取出PTE中的内存页基地址（取PTE的高20位，低12位设为
0）。
⑤ 取线性地址的低12位作为页中偏移与上一步的内存页基地址相
加便得到物理地址。
将线性地址映射到物理内存的过程如图2-12所示。
图2-12 将线性地址映射到4KB内存页的过程（32位经典分页）
值得说明的是，页表本身也可能被交换到虚拟内存中，这时PDE的
P位会为0，CPU会产生缺页异常，促使内存管理器将页表交换回物理内
存。然后再重新执行访问内存的指令和地址翻译过程。与页表不同，每
个进程的页目录是永久驻留在物理内存中的。
 格物致知
 老雷评点  
朱熹有言，“言理则无可捉摸，物有时而离。言物则理自
在，自是离不得。”理之妙在于以一摄万，但却抽象，“无可捉
摸”，不易掌握。因此朱熹非常推重格物。格物者，躬行实践
也。朱子又言，“知与行，功夫须著并到。知之愈明，则行之
笃；行之愈笃，则知之愈明。二者皆不可偏废。如人两足相先后
行，便会渐渐行得到。”是故本书特增“格物致知”环节，作者用
心良苦也。
下面通过试验来加深大家对以上内容的理解，建议根据配套网站中
的提示建立好实验环境，然后按照以下提示亲自实践。
① 启动WinDBG，单击菜单File→Open Crash Dump，打开DUMP文
件C:\swdbg2e\dumps\xpsp3nop\MEMORY.DMP。加载文件后，WinDBG
会显示一系列信息，包括转储类型（Kernel Summary Dump File）、目
标系统版本（XP SP3）、32位（x86）以及产生转储的时间：
Debug session time: Sun Jul 21 10:30:02.779 2013
 老雷评点  
软件环境千差万别，如用活动调试目标，初学者难免遇到各
种不同处，心生困惑。转储文件截取时空之一瞬，化不定为固
定，实学习之佳径。此文件是作者在上海静安图书馆写作时产
生，时值盛夏。
② 执行r cr4，显示控制寄存器CR4的内容：
kd> r cr4
cr4=000006d9
执行.formats 6d9，得到对应的二进制：
Binary:  00000000 00000000 00000110 11011000
查阅本章的表2-2，可以知道每一位的含义，我们重点看PAE位和
PSE位，即Bit 5和Bit 4，Bit 5为0代表没有启用PAE，Bit 4为1代表启用
了大内存页支持。
③ 执行.symfix c:\symbols命令，并执行.reload命令加载符号信息。
如果是第一次做这个试验，需要验证机器有互联网连接，这样WinDBG
才能从微软的符号服务器自动下载Windows系统模块的符号文件。