      v9 = v12;
      *((_BYTE *)v9 + 134) ^= ((*(_BYTE *)(*(_DWORD *)v8 + 1115) >> 5) & 1 ^ *((_BYTE *)v12 + 134)) & 1;
      SP::operator=(0);
      return v9;
    }
可以看到这里构造了一个空对象，再看`CreateTableGridBoxBuilder`函数，这个是理解整个过程很重要的函数，为了看的更加清晰一点，我截图+注释
在`Layout::TableGridBox::InitializeColumnData`中初始化了`TableGridBox`对象，跟踪进入
在`Layout::TableGridBoxBuilder::Constructor`中
再跟进`Layout::ContainerBoxBuilder::Constructor`
捋一下，大概的关系是这样的
    TableGridBoxBuilder
        |
        |--> +4 =>存储 TableGrideBox
                        |
                        |--> +136 => 得到Array数组
再回到`Layout::MultiColumnBoxBuilder::HandleColumnBreakOnColumnSpanningElement`函数，出错的情况下，各个对象是这样的
上面的整个过程是我们理论分析出来的，看看实际执行情况，是不是这样
创建数组这里，`windbg`符号发生了错误，可以通过`IDA`看一下真正的函数
可以发现，我们理论推测的和实际执行情况是一致的。出错的原因是，由于参数是个数组，但是`Readable`把它当成对象，导致`Type Confusion`。
出错的具体原因找到了，来看看能不能利用，接下来分析一下攻击面，看看通过控制哪个参数，能够控制`EIP`
## 利用构建
再来看一下出错附近的函数使用情况
其中有一个虚表函数调用，可以发现我们只要能够控制`ArrayObject_1+4`位置的值，就可以造成命令执行。
整体的过程大概是这样的
    TableGridBoxBuilder
        |
        |--> +4 =>存储 TableGrideBox
                        |
                        |--> +136 存储ArrayObject_1
                                    |
                                    |-> +4 存储p_vftable
                                                |
                                                |-> +0x1A4 存储一个虚表函数
如果想控制`p_vftable`，就需要控制`ArrayObject_1`，然而`ArrayObject_1`是在`TableGrideBox`初始化函数`Layout::TableGridBox::InitializeColumnData`初始化的。
可以看到数组中的值，来自于`TableBoxBuilder`的对象`+165`位移处。为了不产生歧义，这里为以后的分析，解释一下，`165`是双字表示的，换成字节表示，位移应该是`660/0x294`。
这里我们需要分析一下`TableBoxBuilder+165`处的具体数据，其实就像我们上面分析`TableGridBoxBuilder`一样。
与其相关的构建函数
    Layout::TableBoxBuilder::TableBoxBuilder    
    Layout::TableBoxBuilder::CreateTableBoxBuilder
    Layout::TableBoxBuilder::Constructor
经过多次分析，其实可以直接猜到会利用这三个函数进行构建，所以根据上面的分析，直接看`Layout::TableBoxBuilder::CreateTableBoxBuilder`
跟进`Constructor`
通过两处标注出来的地方，发现`TableBoxBuilderObject`，在中途被改变了，动态跟踪一下
确实被改变了，说明通过直接分析`TableBoxBuilder`对象的方式，分析出`TableBoxBuilder+0x294`位移处的数据有点不太方便，这里先暂时放一放，如果别的方法不行的话，再来分析这个。
换一种方法，直接再次分析`Layout::TableGridBox::InitializeColumnData`
    ArrayObject = (Layout::TableGridBox *)((char *)TableGridBoxObject + 136);
      v5 = *(_DWORD *)(*((_DWORD *)v4 + 7) + 80) + 1;
      v6 = Array::Create((int *)&v12, v5);
      SArray::operator=((_DWORD *)TableGridBoxObject + 34, v6);// 将数组v6赋值给TableGridBoxObject+136位置(readable读取对象->数组)
      v7 = 0;
      if ( !*((_DWORD *)TableGridBoxObject + 34) )
        goto LABEL_18;
      if ( !(*((_BYTE *)TableGridBoxObject + 132) & 8) )
      {
        index = 0;
        if ( v5 > 0 )
        {
          ArrayObject_copy = ArrayObject;
          do
          {
            *(_DWORD *)(*ArrayObject_copy + 4 * index) = *(_DWORD *)(*((_DWORD *)TableBoxBuildObject + 165) + 4 * index); // 跟踪TableBoxBuilder对象的构建过程
            ++index;
          }
          while ( index  其实这里可以一直往下分析的，最后也可以成功找到具体数据生成的方法，而且还会少走很多的弯路！
先来介绍我走的弯路，其中有很多分析的方法和经验还是很好的
跟踪`TableBoxBuilder+0x294`数据
在`TableBoxBuilder`对应的空间被创建后下断点，断下来后，在`+0x294`被写入时，再次下写入断点
    bu 66146DF8 ".echo ======Change 0x294 Data======;r @$t0=eax; bc 1; ba w1 @$t0+0x294 "dd poi(@$t0+0x294) L4;r eip;kb; g";g"
结果
在`Layout::TableBoxBuilder::InitializeBoxSizing`中
`+0x294`被`a4+0xc`改变了，所以再回溯，进入`Layout::FlowBoxBuilder::OnChildBoxEntry`函数，这个函数特别长，只截取用到的部分
可以发现`[FloBoxBuilder+136]+0xc`的值存储了`TableBoxBuilder+0x294`的值。为了分析`FlowBoxBuilder`，我又分析了`FlowBoxBuilder`的结构，这个过程比较恶心，很复杂，只说个结果吧
    CreateTableBoxBuilder+136 
        |
        | => TableBoxBuilder+0x294 
                |
                | => (FlowBoxBuilder+0x114)+0xc
其中
    FlowBoxBuilder+0x114 
        |
        | =>  存储 SBoxModel
                    | 
                    | => +0xc 存储 Layout::STableBoxSizeCalculator + 0x4数据
最终的结果是`Layout::STableBoxSizeCalculator+0x4`中存储了我们最终的数组。
    Layout::STableBoxSizeCalculator *__thiscall Layout::STableBoxSizeCalculator::STableBoxSizeCalculator(Layout::STableBoxSizeCalculator *this, int a2, int a3, int a4)
    {
      Layout::STableBoxSizeCalculator *v4; // edi
      int v5; // ecx
      v4 = this;
      *(_DWORD *)this = 0;
      *((_DWORD *)this + 1) = 0;
      *((_DWORD *)this + 2) = 0;
      *((_DWORD *)this + 3) = 0;
      *((_DWORD *)this + 4) = 0;
      *((_DWORD *)this + 5) = 0;
      *((_DWORD *)this + 6) = 0;
      SArray::operator=(this, (int)this);
      SArray::operator=((_DWORD *)v4 + 1, v5);
      *((_DWORD *)v4 + 2) = 0;
      *((_DWORD *)v4 + 3) = 0;
      *((_DWORD *)v4 + 4) = 0;
      *((_DWORD *)v4 + 5) = 0;
      *((_DWORD *)v4 + 6) = 0;
      Layout::STableBoxSizeCalculator::CalculateTableUsedWidth(v4, a2, a3, a4);
      return v4;
    }
而在`Layout::STableBoxSizeCalculator::CalculateTableUsedWidth`中，更改了`+0x4`位置的数据
    void __thiscall Layout::STableBoxSizeCalculator::CalculateTableUsedWidth(Layout::STableBoxSizeCalculator *this, int a2, int a3, int a4)
    {
      Layout::STableBoxSizeCalculator *v4; // edi
      struct Tree::TableGridBlock *v5; // ebx
      int v6; // esi
      char v7; // [esp+Ch] [ebp-28h]
      char v8; // [esp+14h] [ebp-20h]
      int v9; // [esp+18h] [ebp-1Ch]
      int v10; // [esp+24h] [ebp-10h]
      int v11; // [esp+28h] [ebp-Ch]
      int v12; // [esp+2Ch] [ebp-8h]
      v4 = this;
      v5 = *(struct Tree::TableGridBlock **)(a2 + 28);
      Tree::TableGridBlock::EnsureTableStructureRelatedFormatsAreReadyToUse(*(Tree::TableGridBlock **)(a2 + 28));
      Layout::STableBoxSizeCalculator::STableWidthCalculator::STableWidthCalculator(&v7, a2, a3, a4);
      *((_DWORD *)v4 + 2) = v11;
      *((_DWORD *)v4 + 3) = v9;
      *((_DWORD *)v4 + 4) = v10;
      Layout::STableBoxSizeCalculator::CalculateColumnUsedWidthAndOffset(// 改变值
        v4,
        v5,
        (enum System::MemoryAllocationResultEnum *)&v12);
      if ( v12 )
      {
        v6 = 0;
        for ( *((_DWORD *)v4 + 6) = 0; v6 = *((_DWORD *)v5 + 20) + 1 )
            break;
          if ( Tree::TableGridBlock::IsColumnVisibilityCollapse(v5, v6) )
            *((_DWORD *)v4 + 6) += *((_DWORD *)v4 + 4) + *(_DWORD *)(*(_DWORD *)v4 + 4 * v6);
        }
        *((_DWORD *)v4 + 5) = *((_DWORD *)v4 + 3) + *((_DWORD *)v4 + 2);
      }
      SP::~SP((System::SmartObject **)&v8);
    }
而其调用的函数`Layout::STableBoxSizeCalculator::CalculateColumnUsedWidthAndOffset`更改了目标值
可以看到`v14`影响着最终结果数组，而`v14`又被`v13`所更改，跟踪`Layout::STableBoxSizeCalculator::STableColumnDistributor::STableColumnDistributor`
    Layout::STableBoxSizeCalculator::STableColumnDistributor *__thiscall Layout::STableBoxSizeCalculator::STableColumnDistributor::STableColumnDistributor(_DWORD *this, int a2, int a3, _DWORD *a4)
    {
      Layout::STableBoxSizeCalculator::STableColumnDistributor *v4; // ebx
      _DWORD *v5; // edi
      int *v6; // eax
      char v8; // [esp+10h] [ebp-4h]
      v4 = (Layout::STableBoxSizeCalculator::STableColumnDistributor *)this;
      *this = 0;
      v5 = this + 2;
      this[1] = 0;
      this[2] = 0;
      this[6] = 0;
      this[7] = 0;
      this[9] = 0;
      this[10] = 0;
      this[11] = 0;
      this[12] = 0;
      this[13] = 0;
      this[14] = 0;
      *a4 = 1;
      SP>>::operator=(this, a2);
      *((_DWORD *)v4 + 1) = a3;
      *((_DWORD *)v4 + 3) = 0;
      *((_DWORD *)v4 + 4) = 0;
      *((_DWORD *)v4 + 5) = 0;
      *((_DWORD *)v4 + 6) = 0;
      *((_DWORD *)v4 + 7) = 0;
      *((_DWORD *)v4 + 11) = 0;
      *((_DWORD *)v4 + 9) = 0;
      *((_DWORD *)v4 + 10) = 0;
      *((_DWORD *)v4 + 12) = 0;
      *((_DWORD *)v4 + 13) = 0;