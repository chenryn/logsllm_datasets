and comment explaining the error. This leads to syntacti-
cally correct code, but not semantically equivalent.
The ratio of syntactically correct decompiled code
ranges from 85.7% for Procyon on javac inputs (the best),
down to 44% for Krakatau on ecj (the worst). All decom-
8
https://github.com/castor-software/yajta
Page 5 of 19
Java Decompiler Diversity and its Application to Meta-decompilation
NEW Lang$LangRule
DUP
ALOAD 10 //pattern
NEW HashSet
DUP
ALOAD 11 //langs
INVOKESTATIC Arrays.asList
invokespecial HashSet.
ILOAD 12 // accept
ACONST_NULL
1 //Bytecode
2
3
4
5
6
7
8
9
10
11
12 -aaINVOKESPECIAL Lang$LangRule.
13 -aaaa(LPattern;LSet;Z LLang$1)V
14 +aaINVOKESPECIAL Lang$LangRule.
15 +aaaa(LPattern;LSet;Z LLang$LangRule)V
16
17 //Decompiled sources
18 //Usage of private static inner class LangRule
[...]
Figure 2: Outcome of the decompilation for each pair of com-
piler and decompiler for the 1887 classes compilable by both ecj
and javac. From left to right are presented the percentages of
classes that were syntactically correct (in green), syntactically
incorrect (in blue), and empty (in red)
1 public interface Bag extends Collection {
2 +aa@Override
3 +aapublic boolean add(E var1);
4 -aapublic boolean add(E Object);
5
6 }Listing 5: Excerpt of diﬀerences in Bag original (in red
marked with a -) and decompiled with CFR (in green
marked with a +).
pilers failed to produce syntactically correct output for 137
classes. Overall, no decompiler is capable of correctly han-
dling the complete dataset. This illustrates the challenges of
Java bytecode decompilation, even for bytecode that has not
been obfuscated.
We note that syntactically incorrect decompilation can
still be useful for reverse engineering. However, an empty
output is useless: the ratio of class ﬁles for which the de-
compilation completely fails is never higher than 8.6% for
Dava on javac bytecode.
In the following paragraphs we investigate the impact
of the compiler on decompilation eﬀectiveness. Over the
10912 syntactically incorrect decompilation (over all de-
compilers), 712 can be attributed to compiler diﬀerences
because the decompiler produces syntactically incorrect
sources for one compiler and not for the other. These cases
break down as follows: 596 failures occur only on ecj byte-
code and 116 cases only on javac code.
Listing 5 shows an excerpt of the diﬀerences be-
tween the original source code of the Bag interface from
commons-collections and its decompiled sources pro-
duced by CFR. This is an example where both javac and ecj
produce the same bytecode, yet recompilation of the sources
produced by CFR succeed with javac and fail with ecj. The
commons-collections library is compiled targeting Java
6:
constructor's wrapper generated by the compiler
19 -aanew LangRule(pattern, new HashSet(
20 -aaaaaaaaArrays.asList(langs)), accept)
21 +aanew LangRule(pattern, new HashSet(
22 +aaaaaaaaArrays.asList(langs)), accept, null)
Listing
Excerpt
of diﬀerences when compiling org/apache/commons/
codec/language/bm/Lang with javac (in red marked
with a -) and with ecj (in green marked with a +). Top
part of listing illustrates diﬀerences in bytecode, while
bottom part shows diﬀerences in source code decompiled
by Procyon.
1.5, in our experiment. In these conditions, ecj fails in the
presence of the @Override annotation to override a method
inherited from an interface such as Collection. It is only
accepted for inheritance from a class (abstract or concrete).
Meanwhile, javac compiles the decompiled sources without
any error. Note that specifying Java 1.6 as target solves the
error with ecj. This illustrates how the notion of syntactic
correctness depends on the actual compiler as well as on the
targeted Java version.
Listing 6 shows an excerpt of the bytecode generated
by javac and ecj for class org/apache/commons/codec/
language/bm/Lang as well as the corresponding decom-
piled sources generated by Procyon in both cases. The ex-
cerpt shows a call to the private constructor of a private
static nested class of Lang called LangRule. Since the
nested class is static the outer class and the inner class
interact as if both were top-level classes9 in the bytecode.
But as the constructor of the nested class is private, the
enclosing class cannot access it. To bypass this problem,
both javac and ecj create a synthetic public wrapper for
this constructor. In Java bytecode, a synthetic element is an
element created by the compiler that does not correspond
to any element present in the original sources (implicitly or
not). Thiswrapperisapublicconstructorforthenestedclass
LangRule. As the signature for this wrapper cannot be the
sameastheprivateconstructor,itmusthavediﬀerentparam-
eters. javacand ecjhandlethiscasediﬀerently. javaccreates
a synthetic anonymous class Lang$1 and adds an additional
parameter typed with this anonymous class to the wrapper
9https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
Harrand et al.: Preprint submitted to Elsevier
Page 6 of 19
73.9%26%0.1%83.4%12.9%3.7%44.5%48.3%7.2%44.4%46.9%8.6%67.7%29.4%3%67.9%28.4%3.7%70.6%29.2%0.2%68.7%27.4%3.8%65.8%30%4.1%69.8%24.9%5.2%65.7%34.3%65.2%34.8%44%52%4%44.8%47.9%7.3%81.2%18.8%85.7%14.3%CFRDavaFernflowerJADXJD−CoreJodeKrakatauProcyon0%25%50%75%100%ecjjavacecjjavacecjjavacecjjavacecjjavacecjjavacecjjavacecjjavacCompilerCategoryEmptyDoesn't recompileRecompileJava Decompiler Diversity and its Application to Meta-decompilation
parameters. Since the value of this parameter is never used,
null is passed as additional parameter when the wrapper is
called. ecj does almost the same thing, but the additional
parameter is of type Lang$LangRule. Procyon is able to
reverse the javac transformation correctly, but not the ecj
one. It decompiles the ecj version literally, conserving the
null parameter. Yet, the synthetic wrapper does not exist in
thedecompiledsources. Consequently,thedecompiledcode
that refers to an absent constructor is syntactically incorrect.
This example illustrates the decompilation challenge intro-
duced by synthetic elements that are generated by a com-
piler. Note that synthetic elements in bytecode do carry a
ﬂag indicating their nature. But, (i) it does not change the
diﬃculty of reversing an unforeseen pattern and (ii) this ﬂag
could be abused by an obfuscator as it does not change the
semantic of the bytecode but rather gives indication to drive
potential tools modifying the bytecode. In the case of Pro-
cyon and CFR, their common test suite did not include code
generated by ecj at the time of this experiment. Since then,
theauthorof CFRhasupdatedthetestsuitecommonto CFR
and Procyon with test covering bytecode from ecj10
We have shown that the compiler impact decompilation
eﬀectiveness for two reasons: (i) it changes the oracle for
syntactic correctness; (ii) it produces diﬀerent bytecode
structure that decompilers might not expect.
Toassessthesigniﬁcanceofthisimpact, weusea 2 test
on the ratio of classﬁles decompiled into syntactically cor-
rectsourcecodedependingonthecompiler, javacversus ecj.
The compiler variable has an impact for three decompilers
and no impact for the remaining ﬁve, with 99% conﬁdence
level. The test rejects that the compiler has no impact on the
decompilation syntactic correctness ratio for CFR, Procyon
and JD-Core (p-value 10−14, 0.00027 and 0.006444). For
the ﬁve other decompilers we do not observe a signiﬁcant
diﬀerence between javac and ecj (p-values: Dava 0.15, Fer-
nﬂower 0.47, JADX 0.17, Jode 0.50, and Krakatau 0.09).
Note that beyond syntactic correctness, the compiler may
impact the correctness of the decompiled code, this is dis-
cussed in more details in Section 4.3.
To sum up, Procyon and CFR are the decompilers
that score the highest on syntactic correctness. The three
decompilers ranking the lowest are Jode, Krakatau and
Dava. It is interesting to note that those three are no longer
actively maintained.
Answer to RQ1: Nosingledecompilerisabletoproduce
syntacticallycorrectsourcesformorethan 85.7%ofclass
ﬁles in our dataset. The implication for decompiler users
is that decompilation of Java bytecode cannot be blindly
applied and does require some additional manual eﬀort.
Onlyfewcasesmakealldecompilersfail, whichsuggests
that using several decompilers in conjunction could help
to achieve better results.
10Commit:
https://github.com/leibnitz27/cfr_tests/
commit/b4f0b01e34a953a1fd57e52f508c9c02c58e6dee Discus-
sion: https://github.com/leibnitz27/cfr/issues/50
1 -aaaIFEQ L2
2 +aaaIFNE L2
3 +aaaGOTO L0
4 + L2
5
6
ALOAD 5
INVOKESTATIC Lang$LangRule.access$100
7
8
9
10
(LLang$LangRule;)Z
IFEQ L3
ALOAD 3
ALOAD 5
INVOKESTATIC Lang$LangRule.access$200
(Lang$LangRule;)Ljava/util/Set;
(itf)
POP
11 -aaaINVOKEINTERFACE Set.retainAll (LCollection;)Z
12 +aaaINVOKEVIRTUAL HashSet.retainAll (LCollection;)Z
13
14
15 -aaaGOTO L2
16 +aaaGOTO L0
Listing 7: Excerpt of bytecode from class org/apache/
commons/codec/language/bm/Lang.class,
compiled with javac and decompiled with CFR: Lines in
red, marked with a -, are in the original bytecode, while
lines in green, marked with a +, are from the recompiled
sources.
4.2. RQ2: (semantic equivalence) To what extent
is decompiled Java code semantically
equivalent modulo inputs?
To answer this research question, we focus on the 2397
class ﬁles, regrouping bytecode generated by both javac and
ecj, that are covered by at least one test case. This ex-
cludes all types which contain no executable code, such as
interfaces. Whendecompilersproducesourcesthatcompile,
we investigate the semantic equivalence of the decompiled
source and their original. To do so, we split recompilable
outputs in three categories: (i) semantically equivalent: the
code is recompiled into bytecode that is strictly identical to
the original (modulo reordering of the constant pool, as ex-
plained in Section 3.1), (ii) semantically equivalent modulo
inputs: the output is recompilable and passes the original
project’s test suite (i.e. we cannot prove that the decom-
piled code is semantically diﬀerent), and (iii) semantically
diﬀerent: the output is recompilable but it does not pass the
original test suite (deceptive decompilation, as explained in
Deﬁnition 4).
Let us ﬁrst discuss an example of semantic equivalence
ofdecompiledcode. Listing7showsanexampleofbytecode
that is diﬀerent when decompiled-recompiled but equivalent
modulo inputs to the original. Indeed, we can spot two dif-
ferences: the control ﬂow blocks are not written in the same
order (L2 becomes L0) and the condition evaluated is re-
versed (IFEQ becomes IFNEQ), which leads to an equivalent
control ﬂow graph. The second diﬀerence is that the type of
a variable originally typed as a Set and instantiated with an
HashSet has been transformed into a variable typed as an
HashSet,henceonce remainAllisinvokedonthevariable
INVOKEINTERFACE becomes directly INVOKEVIRTUAL.
Thisexampleillustrateshowbytecodemaybechanged(here
withaslightlydiﬀerentbutequivalentcontrolﬂowgraphand
a change in the precision of the type information) yet still be
Harrand et al.: Preprint submitted to Elsevier
Page 7 of 19
Java Decompiler Diversity and its Application to Meta-decompilation
Figure 3: Equivalence results for each decompiler on all the
2397 classes of the studied projects covered by at least one
test, (both compilers combined).
Table 3
Cause of non-equivalence for each decompiler.
n
o
y
c
o
r
P
33
495
528
R
F
C
22
662
684
r
e
w
o
ﬂ
n
r
e
F
21
941
962
e
r
o
C
-
D
J
44
994
1038
X
D
A
J
78
911
989
e
d
o
J
142
1094
1236
a
v
a
D
36
1599
1635
u
a
t
a
k
a
r
K
97
1576
1673
#Deceptive
#!Recompile
#Failures
semantically equivalent modulo inputs.
Now we discuss the results globally. Figure 3 shows the
recompilation outcomes of decompilation regarding seman-
tic equivalence for the 2397 classes under study. The hori-
zontal axis shows the eight diﬀerent decompilers. The ver-
tical axis shows the number of classes decompiled success-
fully. Strictly equivalent output is shown in blue, equiva-
lent classes modulo input are shown in orange. For example,
CFR (second bar) is able to correctly decompile 1713 out of
2397 classes (71%), including 1114 classes that are recom-
pilable into strictly equivalent bytecode, and 599 that are re-
compilable into equivalent bytecode modulo inputs. When
thedecompilerfailstoproduceanoutputthatissemantically
equivalentmoduloinputs,itiseitherbecausethedecompiled
sourceswerenotsyntacticallycorrectanddidnotrecompile,
or because they did recompile but did not pass the original
test suite (deceptive decompilation). Table 3 gives this in-
formation for each decompiler.
The three decompilers that are not actively maintained
any more (Jode, Dava and Krakatau) handle less than 50%
of the cases correctly (recompilable and pass tests). On the
otherhand, Procyonand CFRhavethehighestratioofequiv-
alence modulo inputs of 78% and 71%, respectively.
Answer to RQ2: The number of classes for which the
decompiler produces equivalent sources modulo input
varies signiﬁcantly from one decompiler to another. The
result of decompilation is usually not strictly identical
to the original source code. Five decompilers generate
equivalent modulo input source code for more than 50%
of the classes. For end users, it means that the state of
the art of Java decompilation does not guarantee seman-
tically correct decompilation, and care must be taken not
Figure 4: Deceptive decompilation results per decompiler.
From left to right, deceptive decompilation occurring after
javac compilation, ecj and both.
to blindly trust the behavior of decompiled code.
4.3. RQ3: (bug ﬁnding) To what extent do
decompilers produce deceptive decompilation
results?
As explained by Hamilton and colleagues [15], while