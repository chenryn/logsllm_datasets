[^ii]: 感谢 Flink 社群的 Kostas Kloudas 提出这个比喻。
将事件时间和处理时间搞混会导致错误的资料。例如，假设你有一个流处理器用于测量请求速率（计算每秒请求数）。如果你重新部署流处理器，它可能会停止一分钟，并在恢复之后处理积压的事件。如果你按处理时间来衡量速率，那么在处理积压日志时，请求速率看上去就像有一个异常的突发尖峰，而实际上请求速率是稳定的（[图 11-7](../img/fig11-7.png)）。
![](../img/fig11-7.png)
**图 11-7 按处理时间分窗，会因为处理速率的变动引入人为因素**
#### 知道什么时候准备好了
用事件时间来定义视窗的一个棘手的问题是，你永远也无法确定是不是已经收到了特定视窗的所有事件，还是说还有一些事件正在来的路上。
例如，假设你将事件分组为一分钟的视窗，以便统计每分钟的请求数。你已经计数了一些带有本小时内第 37 分钟时间戳的事件，时间流逝，现在进入的主要都是本小时内第 38 和第 39 分钟的事件。什么时候才能宣布你已经完成了第 37 分钟的视窗计数，并输出其计数器值？
在一段时间没有看到任何新的事件之后，你可以超时并宣布一个视窗已经就绪，但仍然可能发生这种情况：某些事件被缓冲在另一台机器上，由于网路中断而延迟。你需要能够处理这种在视窗宣告完成之后到达的 **滞留（straggler）** 事件。大体上，你有两种选择【1】：
1. 忽略这些滞留事件，因为在正常情况下它们可能只是事件中的一小部分。你可以将丢弃事件的数量作为一个监控指标，并在出现大量丢讯息的情况时报警。
2. 释出一个 **更正（correction）**，一个包括滞留事件的更新视窗值。你可能还需要收回以前的输出。
在某些情况下，可以使用特殊的讯息来指示 “从现在开始，不会有比 t 更早时间戳的讯息了”，消费者可以使用它来触发视窗【81】。但是，如果不同机器上的多个生产者都在生成事件，每个生产者都有自己的最小时间戳阈值，则消费者需要分别跟踪每个生产者。在这种情况下，新增和删除生产者都是比较棘手的。
#### 你用的是谁的时钟？
当事件可能在系统内多个地方进行缓冲时，为事件分配时间戳更加困难了。例如，考虑一个移动应用向伺服器上报关于用量的事件。该应用可能会在装置处于离线状态时被使用，在这种情况下，它将在装置本地缓冲事件，并在下一次网际网路连线可用时向伺服器上报这些事件（可能是几小时甚至几天）。对于这个流的任意消费者而言，它们就如延迟极大的滞留事件一样。
在这种情况下，事件上的事件戳实际上应当是使用者交互发生的时间，取决于移动装置的本地时钟。然而使用者控制的装置上的时钟通常是不可信的，因为它可能会被无意或故意设定成错误的时间（请参阅 “[时钟同步与准确性](ch8.md#时钟同步与准确性)”）。伺服器收到事件的时间（取决于伺服器的时钟）可能是更准确的，因为伺服器在你的控制之下，但在描述使用者互动方面意义不大。
要校正不正确的装置时钟，一种方法是记录三个时间戳【82】：
* 事件发生的时间，取决于装置时钟
* 事件传送往伺服器的时间，取决于装置时钟
* 事件被伺服器接收的时间，取决于伺服器时钟
透过从第三个时间戳中减去第二个时间戳，可以估算装置时钟和伺服器时钟之间的偏移（假设网路延迟与所需的时间戳精度相比可忽略不计）。然后可以将该偏移应用于事件时间戳，从而估计事件实际发生的真实时间（假设装置时钟偏移在事件发生时与送往伺服器之间没有变化）。
这并不是流处理独有的问题，批处理有著完全一样的时间推理问题。只是在流处理的上下文中，我们更容易意识到时间的流逝。
#### 视窗的型别
当你知道如何确定一个事件的时间戳后，下一步就是如何定义时间段的视窗。然后视窗就可以用于聚合，例如事件计数，或计算视窗内值的平均值。有几种视窗很常用【79,83】：
* 滚动视窗（Tumbling Window）
  滚动视窗有著固定的长度，每个事件都仅能属于一个视窗。例如，假设你有一个 1 分钟的滚动视窗，则所有时间戳在 `10:03:00` 和 `10:03:59` 之间的事件会被分组到一个视窗中，`10:04:00` 和 `10:04:59` 之间的事件被分组到下一个视窗，依此类推。透过将每个事件时间戳四舍五入至最近的分钟来确定它所属的视窗，可以实现 1 分钟的滚动视窗。
* 跳动视窗（Hopping Window）
  跳动视窗也有著固定的长度，但允许视窗重叠以提供一些平滑。例如，一个带有 1 分钟跳跃步长的 5 分钟视窗将包含 `10:03:00` 至 `10:07:59` 之间的事件，而下一个视窗将覆盖 `10:04:00` 至 `10:08:59` 之间的事件，等等。透过首先计算 1 分钟的滚动视窗（tunmbling window），然后在几个相邻视窗上进行聚合，可以实现这种跳动视窗。
* 滑动视窗（Sliding Window）
  滑动视窗包含了彼此间距在特定时长内的所有事件。例如，一个 5 分钟的滑动视窗应当覆盖 `10:03:39` 和 `10:08:12` 的事件，因为它们相距不超过 5 分钟（注意滚动视窗与步长 5 分钟的跳动视窗可能不会把这两个事件分组到同一个视窗中，因为它们使用固定的边界）。透过维护一个按时间排序的事件缓冲区，并不断从视窗中移除过期的旧事件，可以实现滑动视窗。
* 会话视窗（Session window）
  与其他视窗型别不同，会话视窗没有固定的持续时间，而定义为：将同一使用者出现时间相近的所有事件分组在一起，而当用户一段时间没有活动时（例如，如果 30 分钟内没有事件）视窗结束。会话切分是网站分析的常见需求（请参阅 “[分组](ch10.md#分组)”）。
### 流连线
在 [第十章](ch10.md) 中，我们讨论了批处理作业如何透过键来连线资料集，以及这种连线是如何成为资料管道的重要组成部分的。由于流处理将资料管道泛化为对无限资料集进行增量处理，因此对流进行连线的需求也是完全相同的。
然而，新事件随时可能出现在一个流中，这使得流连线要比批处理连线更具挑战性。为了更好地理解情况，让我们先来区分三种不同型别的连线：**流 - 流** 连线，**流 - 表** 连线，与 **表 - 表** 连线【84】。我们将在下面的章节中透过例子来说明。