Y si
i
k;i=1
k;i=1
and reveals these to V. (Note the places of ri and si
have been swapped from what might have been antic-
ipated. Note also that P needs only k + 1 exponentia-
tions to compute P and Q since the ratio of their logs
is known to be d.)
9. P and V execute a SILMPP (or Chaum-Pedersen proof)
for the values (P, Q, D, C).
10. The protocol succeeds (V accepts) if and only if
(a) V accepts the simple k-shuﬄe in step 5 (including
the computation of Ui and Vi via equation (26)).
(b) V accepts that for all 1 ≤ i ≤ k
gsi = AiU λ
i
gri = BiV λ
i
(30)
(c) V accepts the proof in step 9.
Theorem 4. The general k-shuﬄe proof protocol is a seven-
move, public coin proof of knowledge for the relationship in
equation (23) which is computational zeroknowledge – that
is, distinguishing between real and simulated proofs is as hard
as the decision Diﬃe-Hellman problem. The number of ex-
ponentiations required to construct the proof is 8k + 5, and
the number of exponentiations required to verify it is 9k + 2.
If V generates challenges randomly, the probability of a
forged proof is at most
1/q + (qk − k + 1)/q2 + 1/q + 1/q
= (qk + 5q − k + 1)/q2 < (k + 4)/q
(31)
Proof: The protocol is seven-move since the steps can be
executed in parallel. (We have presented them sequentially
for clarity.) It is obviously public coin.
Completeness and Soundness
Both of these properties follow immediately from lemma 2
and the corresponding properties of the simple k-shuﬄe in
step 5.
Computational Zeroknowledge
A simulated proof is generated in much the same way as a
real proof, the only diﬀerence is that in step 5, a simulator
does not have knowledge of π. At this point, the simulator
generates instead, Ui and Vi by the same rules as equa-
tion (25), except that a random permutation, σ, is chosen
instead of π. The simple k-shuﬄe proof can be simulated,
and the remaining steps can also be simulated in essentially
the same way. A distinguisher can then distinguish between
real and simulated proofs only if it can distinguish between
and
distributions of the form
(Gi) ; (Gd
π(i))
(Gi) ; (Gd
σ(i))
This problem can be reduced to the decision Diﬃe-Hellman
problem by induction. Further, if these distributions can be
distinguished, the original encryption of the shuﬄe is not
sound.
1226. K-SHUFFLES OF DSA PUBLIC KEYS
The general k-shuﬄe is ideally suited to veriﬁably permut-
ing a set of DSA, or Diﬃe-Hellman public keys. By this we
mean that a new set of DSA public keys is produced, which
is computationally unlinkable to the original set, but which
veriﬁably represents the same set of private keys. This can
be extremely valuable when one wishes to anonymize a set
of authenticated keys while still protecting the integrity of
the original group of private keys – the election setting is
just one such example.
We only sketch the technique here, but the details should
then be completely obvious to the reader. It is assumed that
initially all the public keys are of the form (g, H), H = gs,
where g is some ﬁxed generator and s is the private key.
That is, loosely, “all the keys use the same base”. The
protocol proceeds as follows:
1. Shuﬄer, or mixer, is presented with g and the list of
keys Hi.
2. Shuﬄer executes the general k-shuﬄe with C = g, and
i (the new public keys), implementing the V
Yi = H(cid:48)
via the Fiat-Shamir heuristic.
3. Shuﬄer “returns” the entire proof transcript.
4. Assuming the transcript veriﬁes, set g = C, and Hi =
i. By changing the common base to C, the private
H(cid:48)
keys all remain the same since
H = gs ⇐⇒ H
(cid:48)
= C s
(32)
6.1 Anonymous Voters
In the voting application, it is often said that for election
integrity one must know “who voted”, but for privacy, one
must not know “how voted”. The technique of this section
solves the privacy/integrity dilemma in a new way. Instead
of knowing “who voted”, one only knows that the person
who voted is a member of a set of authorized voters! As a
consequence, we are left with a voting solution that
1. Does not require key sharing to implement a distributed
trust tabulation scheme.
2. Guarantees computational privacy to the voter, rather
than threshold privacy, which is a necessary evil of
other voting solutions based on distributed trust tab-
ulation. (If a threshold number of authorities agree to
collude, all voters’ votes can be decrypted.)
3. Does not require encryption or decryption of voted bal-
lots.
Of course, one must look after the problem of “double
voting”, but the technique of this section is easily modiﬁed
to take care of that as follows. (For simplicity, we describe
the protocol as executed at vote time, with the voter playing
the role of the shuﬄer, however, numerous obvious modiﬁ-
cations exist allowing it to be executed separately.)
• In step 3, the voter (shuﬄer) – who knows one of the
private keys s0 in this case – signs his voted ballot
0) and base C of course. (H(cid:48)
using the DSA pair (s0, H(cid:48)
0
is the “post shuﬄe” public key which belongs to the
voter. The voter knows its place in the new sequence,
since he/she executed the shuﬄe.)
• In step 4, assuming that the shuﬄe transcript checks,
and that the ballot signature checks, the vote center
simply removes H(cid:48)
0 from the list of authorized keys,
and starts the process again waiting for the next ballot
request. The new list of public keys is now one smaller,
and unless the voter (shuﬄer) knew more than one
private key in the ﬁrst place, he/she now knows none
of the new private keys, and hence can not vote again.
The resulting election protocol is Universally Veriﬁable if
all the transcripts and signatures are maintained.
7. K-SHUFFLES OF TUPLES
It should be clear that in section 5, the simple shuﬄe
generated essentially “froze” the permutation that could be
proved. This makes it easy to see how to extend the previous
section to shuﬄes of k tuples of elements of (cid:104)g(cid:105). Thinking
of a sequence of k l-tuples as a k × l array, a single simple
k shuﬄe can serve to prove that all columns have been per-
muted according to the same permutation.
In particular,
this extends to tuples of ElGamal pairs.
7.1 DSA key shufﬂes without common base
The observation of this section also allows a generaliza-
tion of the DSA key shuﬄe protocol of section 6. Rather
than maintaining the entire set of public keys to the same
base, g ↔ C, the keys are maintained as independent pairs
(gi, Hi). The shuﬄer can pick an arbitrary subset of key
pairs, (Gi, Hi), shuﬄe them “as 2-tuples”, and return the
result. This makes shuﬄing more manageable if the original
set is large, at the cost of increasing the work per key by
about 50%.
8. THE MULTI-AUTHORITY VOTING AP-
PLICATION
Much of the setting for the conventional voting applica-
tion can be found in [7]. Votes are submitted as ElGamal
pairs of the form (gαi , hαi m) (or a sequence of these pairs
if more data is required), where m is some standard encod-
ing of the voter choices, the αi are generated secretly by
the voters, and h is a public parameter constructed via a
dealerless secret sharing scheme ([21]). Once the polls are
closed (voting ﬁnished), an independent collection of author-
ities sequentially shuﬄes the ballots. On output of the ﬁnal
shuﬄe, the ﬁnal collection of encrypted ballots is decrypted
in accordance with the threshold scheme, and the clear text
votes are tabulated in full view by normal election rules.
The authorities who participate in the sequential shuﬄes,
may be arbitrary in number, and they may be completely
diﬀerent from those who hold shares of the election private
key. The sequence of ballots which are ﬁnally decrypted can
only be matched with the original sequence of submitted
ballots if all of the shuﬄing authorities collude, since each
of their permutations is completely arbitrary.
Each shuﬄe is performed by an individual authority as fol-
lows:
1. βi are chosen secretly, randomly and independently.
2. Each vote vi = (gαi , hαi m) is replaced, in sequence, by
(gαi+βi , hαi+βi m). A Chaum-Pedersen proof is pub-
lished without revealing the secrets.
1233. A shuﬄe with secret exponent c is performed on the
[7] R. Cramer, R. Gennaro, B. Schoenmakers. A secure
resulting encrypted votes.
4. Step 1-2 are repeated.
5. At this point, the messages that are encrypted are the
c-th power of the original messages. This is easily
ﬁxed by raising each coordinate of each vote to the
1/c power. A Chaum-Pedersen proof of this operation
is equally easy to provide, thus keeping c secret while
convincing veriﬁers, by simply reversing roles of g and
C = gc.
9. CONCLUSION
The protocols presented oﬀer a practical method for per-
forming shuﬄes, or mixes, of data and proving their correct-
ness. They considerably improve the eﬃciency of previous
methods both in theory and practice. The structured nature
of the protocols lend themselves well to implementation. In
a future version of this paper, we expect to improve fur-
ther on the complexity and size. We also believe the general
shuﬄe proof can be modiﬁed to achieve honest-veriﬁer zero-
knowledge.
10. ACKNOWLEDGMENTS
The author wishes to acknowledge the advice and wis-
dom of several important cryptographers who both moti-
vated, and helped to improve this result. In random order,
they are: Dan Boneh, Josh Benaloh, Moti Yung and Berry
Schoenmakers. Without them, this paper might have been
lost in the shuﬄe.
11. REFERENCES
[1] M. Abe. Mix-Networks on Permutation Networks -
ASIACRYPT 99, Lecture Notes in Computer Science,
pp. 258-273, Springer-Verlag, 1999.
[2] M. Abe and F. Hoshino. Remarks on Mix-Network
Based on Permutation Networks. Proceedings 4th
International Workshop on Practice and Theory in
Public Key Cryptography PKC 2001, Lecture Notes in
Computer Science, pages 317-324, Springer-Verlag,
2001.
[3] J. Benaloh. Secret Sharing Homomorphisms: Keeping
Shares of a Secret Secret. Advances in Cryptology -
CRYPTO ’86, Lecture Notes in Computer Science,
pp. 251-260, Springer-Verlag, Berlin, 1987.
[4] J. Benaloh, M. Yung. Distributing the power of a
government to enhance the privacy of voters. ACM
Symposium on Principles of Distributed Computing,
pp. 52-62, 1986.
[5] R. Cramer, I. Damgrd, B. Schoenmakers. Proofs of
partial knowledge and simpliﬁed design of witness
hiding protocols. Advances in Cryptology - CRYPTO
’94, Lecture Notes in Computer Science, pp. 174-187,
Springer-Verlag, Berlin, 1994.
[6] R. Cramer, M. Franklin, B. Schoenmakers, M. Yung.
Multi-authority secret-ballot elections with linear
work. Advances in Cryptology - EUROCRYPT ’96,
Lecture Notes in Computer Science, Springer-Verlag,
Berlin, 1996.
and optimally eﬃcient multi-authority election
scheme. Advances in Cryptology - EUROCRYPT ’97,
Lecture Notes in Computer Science, Springer-Verlag,
1997.
[8] D. Chaum. Untraceable electronic mail, return
addresses, and digital pseudonyms. Communications
of the ACM, 24(2):84-88, 1981.
[9] D. Chaum. Zero-knowledge undeniable signatures.
Advances in Cryptology - EUROCRYPT ’90, Lecture
Notes in Computer Science, volume 473, pages
458-464, Springer-Verlag, 1991.
[10] D. Chaum and T.P. Pedersen. Wallet databases with
observers. Advances in Cryptology - CRYPTO ’92,
volume 740 of Lecture Notes in Compute Science,
pages 89-105, Berlin, 1993. Springer-Verlag.
[11] A. De Santis, G. Di Crescenzo, G. Persiano and
M. Yung. On Monotone Formula Closure of SZK.
FOCS 94, pp. 454-465.
[12] W. Diﬃe, M. E. Hellman. New directions in
cryptography. IEEE Transactions on Information
Theory, 22(6):644-654, 1976.
[13] T. ElGamal. A public-key cryptosystem and a
signature scheme based on discrete logarithms. IEEE
Transactions on Information Theory,
IT-31(4):469-472, 1985.
[14] A. Fujioka, T. Okamoto, K. Ohta. A practical secret
voting scheme for large scale elections. Advances in
Cryptology - AUSCRYPT ’92, Lecture Notes in
Computer Science, pp. 244-251, Springer-Verlag, 1992.
[15] A. Fiat, A. Shamir. How to prove yourself: Practical
solutions to identiﬁcation and signature problems.
Advances in Cryptology - CRYPTO ’86, Lecture Notes
in Computer Science, pp. 186-194, Springer-Verlag,
New York, 1987.
[16] J. Furukawa and K. Sako. An Eﬃcient Scheme for
Proving a Shuﬄe. To appear in CRYPTO 2001.
[17] R. Gennaro. Achieving independence eﬃciently and
securely. Proceedings 14th ACM Symposium on
Principles of Distributed Computing (PODC ’95),
New York, 1995.
[18] A.J. Menezes, P.C. van Oorschot, and S.A. Vanstone.
Handbook of Applied Cryptography, CRC Press, 1997.
[19] N. Koblitz, A Course in Number Theory and
Cryptography, 2nd edition, Springer, 1994.
[20] A. M. Odlyzko, Discrete logarithms in ﬁnite ﬁelds and
their cryptographic signiﬁcance, Advances in
Cryptology - EUROCRYPT ’84, Lecture Notes in
Computer Science, Springer-Verlag, 1984.
[21] T. Pedersen. A threshold cryptosystem without a
trusted party, Advances in Cryptology - EUROCRYPT
’91, Lecture Notes in Computer Science, pp. 522-526,
Springer-Verlag, 1991.
[22] C. Park, K. Itoh, K. Kurosawa. Eﬃcient anonymous
channel and all/nothing election scheme. Advances in
Cryptology - EUROCRYPT ’93, Lecture Notes in
Computer Science, pp. 248-259, Springer-Verlag, 1993.
[23] C. P. Schnorr. Eﬃcient signature generation by smart
cards. Journal of Cryptology, 4(3):161-174, 1991.
124[24] A. Shamir. How to share a secret. Communications of
the ACM, 22(11):612-613, 1979.
[25] K. Sako, J. Kilian. Secure voting using partially
compatible homomorphisms, Advances in Cryptology -
CRYPTO ’94, Lecture Notes in Computer Science,
Springer-Verlag, 1994.
[26] K. Sako, J. Kilian. Receipt-free mix-type voting
scheme – A practical solution to the implementation
of a voting booth, Advances in Cryptology -
EUROCRYPT ’95, Lecture Notes in Computer
Science, Springer-Verlag, 1995.
[27] J. Kilian, K. Sako, Secure electronic voting using
partially compatible homomorphisms, awarded
2/27/1996, ﬁled 8/19/1994.
[28] J. Kilian, K. Sako, Secure anonymous message
transfer and voting scheme, awarded 10/28/1997, ﬁled
1/23/1995.
125