### Table 3. Evaluation Results on Efficiency

| Name          | IR Size    | Traversing Time (seconds) |
|---------------|------------|---------------------------|
| GDI32.dll     | 7.61 MB   | 574                       |
| comctl32.dll  | 13.7 MB   | 0.1                       |
| QEMU         | 12.8 MB   | 358                       |
| Xine         | 116 KB    | 26                        |
| Mplayer      | 12.9 MB   | 327                       |
| MPD          | 36.8 KB   | 0.3                       |
| GOOM         | 2.74 MB   | 667                       |
| faad2        | 1.42 MB   | 445                       |
| Hamsterdb    | 693 KB    | 113                       |
| Average      | 3.46 MB   | 293.6                     |

### 6. Related Work

#### 6.1 Integer Misuse Detection and Protection
To prevent integer-based vulnerabilities, several techniques such as compiler extensions and safe C++ integer classes have been proposed. For example, the GCC compiler with the `-ftrapv` option inserts additional calls (e.g., `_addvsi3`) before signed addition operations to catch overflow errors. Similarly, RICH [32] inserts runtime checks with low overhead based on formal semantics for safe C integer operations. However, these runtime check techniques can generate false positives due to benign integer overflows.

Using safe C++ classes (such as SafeInt, IntSafe) or arbitrary precision arithmetic packages (such as GMP [9], CLN [3]) can mitigate integer security problems, but they introduce non-trivial performance overhead.

Taint analysis has proven effective in detecting integer misuse vulnerabilities in C programs [29, 37, 49]. For instance, Ebrima N. Ceesay et al. [37] implemented a static analysis tool on top of Cqual [41] to track untrusted data. The tool uses a dataflow-insensitive analysis and generates an alarm when an untrusted integer variable is used to access memory.

Ashcraft and Engler [29] presented a range checker that tracks whether an untrusted value is bounds checked before it is used in trusting sinks. Since the range checker only cares about bounds checking, untrusted data after bounds checking are considered safe, which may miss subtle integer overflow bugs.

Sarkar et al. [49] proposed a constraint graph to describe sanitization checks. The nodes represent integer expressions, and the edges represent ordering relationships between the expressions. For an expression used in memory allocation, its sub-expressions are iteratively walked. If any sub-expression is unverified, it reports an alarm.

UQBTng [53] is a tool that automatically finds integer overflows in Win32 binaries. It first translates binaries into C code using UQBT [21], then inserts assert statements before calls to memory allocation functions, and finally uses CBMC [39], a Bounded Model Checker, to verify program properties. UQBTng's effectiveness depends on the translator's accuracy, which is still challenging. Unlike UQBTng, IntScope simulates program execution according to the semantics of low-level instructions.

#### 6.2 Binary Analysis
Vine [22] is a static analysis component in the BitBlaze [2] project. Vine accurately translates each x86 instruction into a RISC-like intermediate representation (IR) and implements dataflow and control flow analysis on that IR. We believe our techniques for detecting integer overflows can be implemented on top of Vine.

CodeSurfer/x86 [48, 47, 31, 30] is a binary analysis platform that uses both IDA Pro and the CodeSurfer system [4]. CodeSurfer/x86 employs the Value-Set Analysis (VSA) algorithm [30] to recover variable-like entities in binaries and translates x86 binary code into an IR that can be accepted by the CodeSurfer system.

Chevarista [1] is a project for automated vulnerability analysis on SPARC binary code. Chevarista demonstrates how to translate binary code into SSA form and model variable bounds by interval analysis to detect buffer overflows or integer overflows. It also mentions techniques to check race conditions based on model checking theory.

#### 6.3 Symbolic Execution
Symbolic execution is widely used in many projects, such as EXE [36], CUTE [50], DART [43], SAGE [44], BitScope [33], and Archer [54]. These tools insert a symbolic execution engine into program source code and use mixed execution to generate test inputs or find potential bugs on feasible paths. SAGE, unlike DART and CUTE, first runs the target program and collects a real trace, then virtually re-executes the recorded trace to collect input-related constraints and generate new inputs. BitScope implements mixed execution to analyze malicious binaries.

### 7. Conclusion
In this paper, we presented the use of symbolic execution to automatically detect integer overflow vulnerabilities in x86 binaries, aiming to identify vulnerabilities before attackers do. Our approach simulates program execution, tracks the propagation of tainted data, and checks whether a tainted symbolic expression used in a sink can overflow under path constraints. We implemented our approach in a system called IntScope and applied it to analyze several real-world binaries. Experimental results show that our approach is highly effective and practical. We found more than 20 zero-day integer overflow vulnerabilities in popular software packages, including QEMU, Xen, and Xine.

### 8. Acknowledgements
We are grateful to our shepherd Michael Locasto and the anonymous reviewers for their hard work, insightful comments, and suggestions. We also thank Ryan Riley and Jianwei Zhuge for their feedback in preparing this paper. This research was supported in part by the National High Technology Research and Development Program of China (No. 2006AA01Z402 and No. 2006AA01Z410) and a National Development and Reform Commission Project of China.

### References
[References are listed as provided, without changes.]

This version of the text is more structured and professional, with clear headings and a consistent format for the table and references.