Horst,Robert,and Tim Chou."The hardware architecture and linear
1985.http://www.hpl.hp.com/techreports/tandem/TR-85.3.html.
第9章JPC：一个纯Java的x86PC模拟程序
Rhys Newman Christopher Dennis
原则与特性
结构
功能多样性
√模块
概念完整性
依赖关系
修改独立性
√进程
√自动传播
数据访问
可构建性
V增长适应性
V熵增抵抗力
“模拟程序很慢，Java也很慢；因此，两者的结合只能意味着以蜗牛
一样的速度进行计算。”正如这个传统智者所说，第一个JPC原型比
真的机器慢10000倍。
1095
---
## Page 1097
不过，纯Javax86PC模拟程序是一个引人注意的想法一想象一下，
在一个安全的Java沙箱内启动Linux和Windows时速度仍然保持快到
足于实际使用。这个任务可能不容易，因为它需要复制人类已经创
造的最复杂的机器之一的内核。仿制物理x86PC的设计、部署在
Java虚拟机之上，然后在JavaApplet沙箱的安全限制之内装配这些
成果，完成这个任务将是一个困难重重的探索之旅。
我们在这个过程中体验了现代软件工程师很少遇到的运算的挑战，
但是这也对那些通常认为理所当然的基础提出了适时的提醒。现
在，我们拥有了一个架构，它表明了纯Java的x86硬件模拟程序是可
行的且速度最终能够快到足于实际使用。
9.1简介
随着处理器速度的加快以及家用计算机用户使用的网络性能的提
高，越来越多在几年前还认为是不切实际的事情正变得平常。十年
前，当一家名为VMWare的技术小公司在加利福尼亚成立时，把一
台完全虚拟的计算机作为软件运行在一台物理计算机内，这种观点
还被认为相当滩以理解。毕竞，如果你拥有一台计算机，为什么仪
仅为了要运行你已经在运行的系统而增加一个虚拟层，从而使计算
机变慢呢？你使用的软件需要硬件全力来运行，如果需要，可以直
接买更多的机器来做更多的工作，为什么这样做呢？
十年后我们都看到了虚拟机的好处。硬件的速度如此快，以致现代
的机器可以运行许多虚拟机而对整体的性能没有大的影响，软件服
务的重要性如此显而易见，以致在虚拟机中完全隔离软件服务的安
全性和可靠性的优点非常明显。
然而，纯虚拟化也有它的问题，因为纯虚拟化在一定程度上依赖硬
件的支持来运行，因此，它也受到与物理机器如此紧密地连接而
导致的不稳定性的影响。与此相比较，模拟程序是完全用软件构建
的虚拟计算机，因此，对底层的硬件没有特别的要求。这意味着模
拟的计算机和实际的硬件完全分开。与通常的应用程序软件相比，
它在系统上的存在既不遭受也不引起额外的不稳定性。正如最初运
行应用程序软件是计算机存在的原因一样，模拟程序将始终是创建
虚拟机的最稳定和最安全的方式。
正如十年前对虚拟化一样，目前对模拟程序的批评集中在它引起的
速度损失上，这通常很明显。然而，历史证明，速度问题会随着技
1096
---
## Page 1098
术的进步而得到解决，即使是现代日益复杂的硬件和软件栈，甚至
在硬件、操作系统和应用程序软件之间微妙交互而引起的更困难的
问题。在非常低的层次以非常强壮和安全的方式分开系统，与此同
时仍然共享物理资源，这已经变得日益必要，但也日益困难。模拟
程序提供了必需的强壮性、安全性和灵活性，因此，它会成为一个
日益令人注意的选择。
目前有许多模拟程序可以使用，Bochs和QEMU是模拟x86PC最著名
的例子。两者都开发了很多年，都能够准确地启动现在的操作系统
并运行应用程序软件。然而，两者都是用本机码（C/C++）编写
的，如果它们要运行在新的底层硬件架构/OS栈上（例如，一个新
型的宿主系统），就需要重新编译。此外，对于安全级别非常高的
应用程序，总是有这样的担忧：模拟程序已经被恶意纂改了，或让
访客的代码做恶意的事情，或包含一个容许这些问题的缺陷。例
如，QEMU使用动态二进制转换来达到可接受的速度，如果这个进
程被损坏或被发现有一个缺陷，那么，这个软件就会变得不可靠或
破坏安全保护措施。
如果用户能够接受模拟程序在安全可以绝对保证的时候的速度损
失，那么，为什么不在部署最广泛和最安全的Java虚拟机（Java
VMLJVM）上建造一个虚拟程序呢？JVM作为运行代码的一个安全
方式已经测试了十多年，用户通常愿意让从因特网下载下来的未认
证代码在Applet沙箱（JVM提供的安全容器）中执行。这是因为
JVM提防基础的编程错误，例如内存溢出和读取未分派内存中的数
据。此外，安装了安全管理器以加强沙箱的JVM可以禁止访客软件
尝试的任何敏感操作。
JPC完全是用Java编写的一个x86PC模拟程序。在JPC中没有本机
码；它模拟了一个x86PC的所有标准硬件组件且完全在JavaApplet
沙箱内。因此，只要不越出这些安全约束，在JPC内运行的x86操作
系统和软件就完全和底层的硬件隔离，甚至连硬件也不必是一台
x86PC。[2l-从宿主的角度来看，JPC代表的仅仅是一个Java应用程
序/Applet，因此，宿主可以确信运行的代码（无论它是什么）是安
全的。JPC可以启动DOS和现代的Linux，让访客的软件和操作系统
完全无拘无束地访问虚拟机中的所有硬件，包括root/admin的权限，
而所有的这些都在Java的沙箱内。
为了攻破JIPC，攻击者必须在JPC的代码中发现与JIVM中缺陷相符的
缺陷，这可以使一个敏感的动作在一台也在运行这个八VM的用户的
1097
---
## Page 1099
权限之内的宿主计算机上运行。这意味着打破了3个完全独立的安
全层。通常每一层都是由完全不同的公司构建的，而且因为在如此
多不同的环境中每一层都是必需的，它们的安全一直在不停地进行
独立的测试和检查。还要注意在破坏这些层中的一致性要求。在
JPC中发现一个缺陷后接着去攻破IVM是行不通的：黑客必须在JPC
发现一个直接（且已经）连接到正使用的IVM内的一个相配安全缺
陷的缺陷。由于JPC是开源的，检查代码并构建一个“干净”的版本
是一个相对简单的任务，可以把一个安全性增强的IVM用于要求高
安全性的应用程序。因此，JIPC成为有恶意的x86代码无法攻破的屏
障，而且真正提供了最可靠、便捷和安全的方式来检查运行中的恶
意x86代码。
和虚拟化一样，当硬件的速度加快时，模拟的应用程序可以从安全
领域延伸到需要保证健壮性的负责重要任务的系统。无论模拟的机
器如何崩溃（或如何损坏），宿主都可以不受影响并能够继续运行
其他模拟的实例。这个技术可以避免在现代的硬件支持虚拟化的有
用特征中即使经过最仔细的思考还可能存在的问题。[3]
在这一章的其余部分，我们将讨论用于构建原型和开发JPC的进
程，我们还将说明如何对设计进行许多逐步改进才形成今大这个可
用的JIPC。然后，我们再略述一些应用程序和JPC呈现的独特技术的
含义。
[1]最起码你需要和“虚拟化的硬件"相同的硬件。因此，像Xen和
VMWare这样的产品使虚拟的x86PC只能创建在x86硬件上。
[2]JPC已经适合在J2ME环境中运行并能够在一个基于ARM11的移
动电话上启动最初的和未更改的DOS！
[3]_例如，硬件支持的x86CPU虚拟化（IntelVT、AMDPacifica）由
于多核芯片的L1/L2高速缓冲寄存器共享而具有安全弱点。
9.2概念验证
x86PC已经存在了三十多年，并从许多不同代的硬件中发展而来。
在每一个时期，它都一直保持向后兼容，所以，即使在今天，最初
的8086程序也可以运行在一台新的PC上。虽然这具有毋庸置疑的优
点且导致这个平台空前的成功，但是，这也意味着它为了避免破环
1098
---
## Page 1100
现有的代码，在合并新技术时变得非常复杂。如果现在重新构建一
台PC，硬件的许多方面都会截然不同，而且几乎肯定会简单得多。
然而，x86平台到处存在，当今世界有超过10亿台，并且每年生产
超过2亿台。因此，最有用的模拟程序将是以x86PC架构为目标的
模拟程序。
然而，这不是一项容易的工作。必须用软件模拟的硬件就包括x86
处理器、磁盘（和它的控制器）、键盘和鼠标、VGA图形显卡、
DMA控制器、PCI总线、PCI主桥、内部定时器、实时时钟、中断控
制器和PCIISA桥。每个设备都有它自已的规范说明书，必须阅读它
们并翻译成软件。x86处理器手册有1500多页，技术手册总共大概
有2000页。x86指令集非常大，一个程序代码中可能用到多至65000
条指令，在内存页上设置有4个不同的保护级别，4个不同的处理器
“模式”，在每个模式中，指令都可能（而且确实）有不同的效果。
所以，在着手这项巨大的任务之前，评估预期的成果是否值得，这
很重要。Bochs和QEMU项目都完成了这个壮举，通过检查他们解决
这些问题的途径，我们可以获得一些信心。然而，这两个项目都是
C/C++的程序，因此，只能获得有限的帮助，因为JIPC必须运行在有
额外设计约束和性能考虑的纯Java环境中。
通过选择模拟一组简单的硬件进行一些简化是有可能的。因为处理
器模拟将是系统中的主要瓶颈，模拟一个复杂但快速的硬盘控制器
（或驱动器）没有多大用处。一个简单并可靠的硬盘模拟程序就可
以容易地满足，这对于其他的硬件组件同样适用。即使在考虑处理
器的时候，可以选择奔腾Ⅱ作为目标，那就没有必要模拟最新芯片
中出现的扩展指令集。因为现在的软件，包括操作系统，即使没有
这些指令保证向后的兼容性，但也能运行得相当好，这个决定没有
明显的局限性。
然而，模拟程序的速度仍然是主要的挑战。获得最好性能的显而易
见的方式是使用某种形式的动态二进制转换从不流畅的按部就班的
软件模拟程序变成一个编译模式，在编译模式中，底层硬件的自身
速度可以更有效地使用。这种技术使用在许多不同的外表下；现代
的x86处理器把首次使用的x86指令分解为更小的微码，然后缓存下
来以便快速地重复执行。即时编辑的Java环境同样把字节码编译成
本机码以提高重复许多次的代码的执行速度。这种技术的效率是基
1099
---
## Page 1101
时间。!1找到提高重复这10%"热"代码的速度的简单的方法可以显
著地提高整体的速度。还要注意，应用这种技术并不意味着编译所
有的代码；选择性的优化可以导致巨大的性能提升而不会引起无法
接受的延迟，如果所有代码都进行优化，就可能发生这种情况。
几乎所有的软件（无论是从C/C++或Java字节码编译到本机的x86）
在执行前都由现代的计算机进行或多或少的动态二进制转换，这个
事实显示了这种技术的能力和效果。因此，当着手处理创建JPC的
这个任务时，如果可以使用相似的技术，获得合理的速度是有希望
的。
通过从现有的模拟程序获得这项工作是可行的信心，通过选择一个
简单的PC架构作为最初的目标，我们把最初的范围降低到一个可完
成的级别。然后，我们需要评估动态二进制转换提高速度并确保达
到一个（即使在大体上）实际可用的性能的可能性。如果JPC在应
用了所有的编程技巧后的最优结果是以1%的速度运行，那么，这个
项目将是不值得做的。
潜在的处理器性能测试
为了估计使用各种模拟策略后能获得的潜在性能级别，作为一个简
单的模型，一个"Toy"处理器发明了出来。这个Toy处理器有13个指
令、2个寄存器和128字节的RAM。用Toy的汇编语言编写了一个相
当于下面这段C代码的简单程序以进行速度测试：
for (int i=0: i<10: i++)