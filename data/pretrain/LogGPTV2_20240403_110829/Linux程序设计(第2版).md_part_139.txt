的跳动次数；它的第四列表明该中断是如何被处理的。中断的处理方式与我们将要学习的内容
没有太大的关系一你只要知道在SMP环境里IO-APIC表示中断是在CPU之间分布处理的，而
XT-PIC是标准的中断处理器就足够了。
另外一个值得看看的文件是/proc/stat。这个文件的内容有一部分是已经发生过的中断的总次
数。我们要查的那一行是intr，它的格式是“intr totalirq0irqlirq2...”，其中的total是所有中断
的总次数，irq0是0号中断的总次数，以此类推。这个文件还会列出没有注册处理器的中断的触
发次数-—而/proc/interrupts里就没有这个数字，当你打算测试自己的第一个中断驱动的设备驱
动程序时，这个文件就很有方便了。
1.分配-个中断
知道了怎样查看/proc里收集的中断统计情况之后，我们再来看看如何申请注册你自己的IRQ。
下面是IRQ申请函数的语法定义，参数的解释在下面的表格里：
unsigned 1ong irqflags,
const char devnane.
void *dev_id)
request_irq成功时返回“o”；失败时返词一个相应的负错误值—其中最值得注意的是：
如果申请的IRQ超出允许范围，返回“-EINVAL”；如果申请的是一个共享处理器面irqflags标
志又不能匹配上某个已安装处理器，返回“-EBUSY"。表21-16是对参数的解释。
表21-16
irq
你希望实际处理的IRQ编号
handler(int irg, void *dev_id,
中断发生时将被调用的函数。这就是我们所说的IRQ中断处理器
struct pt_rege *regs)
ixqflags
它控制奢中断的行为。我们稍后会做深入的讲解
devname
将出现在/procinterupts文件清单里的名字
dev_1d
用于支持中断的共享。它将被传递到我们自己编写的中新处理器里去，所
以你可以利用它来传递一些必要的信息。比如说，IDE子系统在中断发生
硬盘）
加入jaVa编程群：524621833
---
## Page 753
736
6Linux程序设计
irqflags参数是以下儿个标志的组合见表21-17：
表21-17
SA_INTRRR/PT
如果中断处理器在注册时带有这个标志，它在运行时就将黎止所有的IRQ。如果没有设
置这个标志，就只禁止由它自已提供服务的IRQ
SA _SHTRQ
允许这个IRQ链被一个以上的设备共享。驱动程序必须符合irqflags标志望其他掩码设
置的要求并提供正确的dev_id，否则共卓将不能成功
Linux内核里有·个由random设备管理的随机数发生池。如果某个中断处理器负资骨理
的设备不按固定赖率产生中断，它就能对这个池的“随机”概念做点页献，也就应该设置
上这个标志，很明缺，这对被驱动的实际硬件有很强的依赖性
注册之后的中断处理器在被调用时需要有三个参数。它们是：中断号irq-它只有在中断
处理器负责管理个以上的IRQ时才有点用处，否则你就已经知道发生的是哪个中断了：中断发
生时各个CPU寄存器的映象regs-一它的用处很少，定义见asm/ptrace.h文件：设备号dev_id---
这是中断处理器的第二个参数，我们刚才介绍过了。
取消IRQ处理器的注册要使用frcc_irq来完成。它的参数类似于request_irq，我们就不再解
释了。
void frea_irq(umaigned Int irq, void *dev_id)
2.获得一个适当的IRQ
在开始为驱动程序注册一个中断处理器之前，需要先查清楚哪些个IRQ是可以让我们来使用
的。这对硬件的依赖程度很高，主要涉及外部设备和设备总线两方面问题。设备总线分为ISA、
PCI或SBUS（SPARC机器上使用的-种设备总线）等。在外部设备方面，有些设备允许你从--
个状态端口读取它的配置信息；其他的则需要进行试测。如果你真的需要为实际硬件编写一个
驱动程序，就需要从它的供应商那里了解它的程序设计指标，他们会告诉你怎样才能正确地查
出硬件本身必要的信息资料。
地加上即插即用的功能，可它毕竞是在即插即用概念出现以前发明的，它既没有真正的标准，
速度也让人无法恭维，所以如今新出的设备已经很少有使用ISA总线的了。PCI设备在其配置信
息的检索方面准备了个简洁而又标准化的手段，我们不再需要对它进行繁杂的试测和推断。
如何管理控制PCI设备超出了我们这本书的讨论范围，如果你想对PCI做进-步研究，linux/pcih
是一个很不错的出发点，在Linux源代码里也有大量的实际例子。这一小节的其他内容将主要讨
论传统意义上的设备。
如果硬件允许直接检索其配置信息，我们就不需要自已去做任何试测工作。我们前面也提
到过，这个信息一般都列在硬件设备的使用手册里，对它们我们没有什么可讲的。如果没有对
设备更有效的中断检测办法，我们就只能使用Linux提供的手段了：
int proba_irq_off(unsigned long unused)
unsigned 1ong probe_irg_on(void)
probe_irq_on表示IRQ试测工作由此展开，而probe_irq_off表示试测结束。你要把触发设备
产生一个IRQ的代码放在它们中间，probe_irq_off的返回值就将是我们想要确定的IRQ编号。如
加入jaVa编程群：524621833
---
## Page 754
第21章设备驱动程序
737
集设备产生了一个以上的IRQ，probe_irq_off会返间一个负数值（这个值与找到并被触发的第一
个IRQ有关，我们可以从中找出点线索来）。试测代码的典型写法如下所示：
unsigned 1ong foo;
int irq:
probe_irq_off (probe_irq_on(1) ;
/*clear dangling interrupts */
foo = probe_irq_on():
/* this should provoke an interrupt from the device */
outb(TRIGGER_IRQ. PORT) :
irq = probe_irq_off(uu) ;
if (irq > 0)
printk(*irq d detected\n*,irq);
这是一个纯理论意义上的例子，具体的IRQ试测操作需要在它的基础上增加针对具体情况的
代码。probe_irq_on并没有实际的用途，因此probe_irq_of把它标记为未使用。我们感兴趣的是
试测工作结束后的返回值-一它就是我们想查的中断编号。
21.6.3IRQ处理器
查到可用的IRQ之后，就需要由你来编写一段代码来处理设备产生的中断，这段代码就是人
们说的中断处理器。中断处理器的作用是响应中断并提供相应的服务。设备在产生中断时通常
根据SA_INTERRUPT标志的设置情况，中断处理器在运行时或者只禁止它自已负资处理的中断
（使能其他所有中断），或者禁止所有的中断：也就是说，在中断处理器结束运行前，来自同一
个设备的后续中断都将丢失。我们后面会将到如何解决这一问题。
中断发生时正常的执行流将被停止一一内核停下它正在做的工作去启动相应的已注册处理
器。中断处理器与普通的驱动程序人口点是有区别的，它们运行在中断期间、不代表任何特定
的进程。这就意味着current当前进程与驱动程序并没有任何联系，也不应该去管驱动程序的事
情一一这也包括对用户空间的任何访问，比如数据的来回拷贝等。
中断处理器应该尽快完成执行，要不然就有可能丢失来自设备的另一个中断。如果这个中
断是与其他设备共享的，来自其他设备的中断也将无法得到服务。我们前面已经说过，但这里
再强调一下：在中断期间你不应该阻塞。如果你坚持这样做，就可能会启动调度器，面这是决
不允许的。你会在控制台上看到一条Oop信息，告诉你发生“Schedulingin interrupt”（中断期间
调度）错误。在中断处理器里也不允许体眠。作为一个基本原则，你必须在中断期间的运行里
充分考虑如何与系统的其他部分搞好协调。
除了上面提到的这些事项，中断处理器再也没有什么特殊之处了，所以我们也就不准备给
出一个它详细的编写示例。下面是中断处理器方面类似于中断号试测情况的一个理论性示例：
void our_intr(int irq, void *dev_id, struct pt_regs *regs)
int status;
printk(*received interrupt ed\n*. irg):
加入jaVa编程群：524621833
---
## Page 755
738
Linux程序设计
reading status from board*/
inb(STATUS_PORT, statu8) ;
/* we are sharing izq. check if it was our board */
if [status & MY_IRQ_STAT]
return;
/ *acknowledge IRQ */
outb (STATUS_PORT, MY_ACK_IRQ) :
>transfer Gata from the device, if needed<
/schedule bottom half for execution →/
our_taskqueue.routine ={void*)(veid*jour_bh;
our_taskqueue.data =(void*)dev_id;
queue_task(&our_tagkqueue,&tq_irmcdiate):
nark_bh (IMNEDIATE_BH) ;
1
return;
我们做的第一件事情是检查IRQ是否产生自这个驱动程序负责管理的设备，具体做法是从硬
件上的预定端口读取个状态信息。这是处理中断共享的一个办法。如果这个处理器控制着同
一硬件设备的多个实例.就需要使用dev_id来区分它们。
21.6.4中断的后处理
上面的处理器引人了一个新概念：中断的后处理。我们在任务队列部分对这个概念做过简
单的介绍，但它们值得我们多加关注。在程序设计实践中，我们很少把全部工作都放在中断处
理器里完成。相反，我们会定义一个任务队列并把它添加到immediate（立刻执行）队列里去
一一这样可以保证我们的队列能够很快地得到执行。our_bh就是这个设备上中断的后处理部分，
当我们从中断的前处理部分（即真正的中断处理器）返回时，排在immediate队列里的our_bh将
尽快得到执行。前处理部分的工作基本上只是把数据从设备拷贝到一个内部的缓冲区里，而对
这些数据的必要处理则交给后处理部分来完成。
是否值得另外设置一个后处理部分取决于你需要在前处理部分花费多长的时间以及这个IRQ
是否是共享的。只要中断处理器从执行中返回，设备的IRQ就将重新被使能。这就意味着中断的
后处理部分是在中断处于激活状态的情况下运行的一—与不采用这种做法相比，中断处理器将能
够为更多的中断提供服务。后处理部分彼此都是原子化的，因此你不必担心会出现重人方面的
问题。前处理部分可以在后处理部分正在执行的时候被再次调用。如果一个后处理部分在它运
行的时候又被加上了执行标记，它会尽快地再次得到运行机会：但如果它还排在队列里的时候
给加上了两次执行标记，它就会只运行一次。
因为后处理部分是对来自前处理部分的数据进行处理，所以它们之间通常都需要共享一些
东西。这需要我们认真对待。我们将在专门的章节里对原子性操作和可重人问题进行讨论。
我们并不是非得使用tq_immediate队列，但这个队列用得最多；原因很简单一它能够最快
地得到运行。因为常用的后处理部分都是在内核里预先定义好的，所以你可以在需要的时候用
它们来完成自己的工作。
加入jaVa编程群：524621833
---
## Page 756
第21章设备疆动程序739
21.6.5可置入性
可重人性是设备驱动程序必须要注意解决的重要问题之一。我们已经在学习过程中零零散
散地介绍过一些这方面的内容，但基本上都是一笔带过；现在，这个问题正式地摆在了我们的
面前。我们来看一下你的驱动程序被儿个进程同时打开时的情况。通常，在-个驱动程序的内
部需要用到多个保存在不同地方的数据结构。问题是这些结构的完整性并不是不可侵犯的，那
么，你怎样才能保证那几个进程不会同时对同一个结构进行修改呢？随着SMP系统的日益范行，
机器里有两个CPU已经不是什么少见的事情，这就更增加了问题的严重性。Linux2.0对这个问
题的解决方案是用一把大锁把整个内核空间都监控起来，确保任一时刻只有一个CPU在内核里
活动。这个解决方案倒是很有效，但随着CPU数量的增加，它就会越来越力不从心。
如果我们想让Linux有能力控制有两个以上CPU的机器并控制得好，就必须采用更精细的加
锁机制，这在Linux2.1版的开发周期里得到了共识。最终结果是舍弃了采用一把大锁并让进程
们在进入内核空间之前申请这把大锁的做法，引人了新的加锁指令。内核里重要的数据结构现
在是用一把单独的操作锁监控着的，让无数进程运行在内核里的想法如今成为了现实、如果某
段代码准备修改的数据结构可能会被其他进程同时修改，这段代码就被称为关键节，面它就是
我们需要在重人时加以保护的代码段落。
我们别才已经提到，要想运行一个内核空间里的进程必须先提出申请，因此你可以放心
current不会在你的眼皮子底下被愉梁换柱一它们必须明确地放弃执行。这条规定基本上是正确
的一一因为还有中断可以在任何时间进入并打断当前的执行流。当然还存在让进程休眠和在驱
动程序里明确地进行进程调度等方面的问题—我们必须在这些情况发生时把可重入性问题的处
理安排好。那么，这是不是意味着我们必须把所有变量都监控起来呢？当然不是，因为只有全
局性的数据结构共享着同样的地址空间。函数的本地变量都存放在各进程专用的内核堆栈里，
每个访问进程都有它自己的变量存放地点。
int global;
int device_open(struct inode *inode,struct file *fi1e)
Lnt local:
printk(“global =0xkp.local=0xepn*,&global,&iocal):
这是某个模块里的一段代码。它的输出证实了全局变量是共享的，而本地变量则是些彼此
独立的拷贝：
pid = 909 :globa1+0xc18005tc,1oca1 =0xc08d3f2c
pid =910:g1oba1 =0xc18005fc.1oca1=0xc098df2c
把本地变量放到内核堆栈里的做法是一-种解脱，但对能够在其中存放多少东西又不可避免
地会有一个限度。Linux2.2为每个进程保留了大约7KB的内核维栈，这对大多数应用来说都足
够了。这里面有一部分是为中断处理或类似情况保留的一一注意不要超越了这个限度。如果你
的需要超过了大约6KB，就应该对它进行动态分配。
加入jaVa编程群：524621833
---
## Page 757
Linux程序设计
预防可重人向题的老式做法是：全面禁止所有的中断，做自已的工作，然后重新使能中断。
中断处理器们以及运行在中断期间的其他一切事物都必须工作在与你的驱动程序保持着异步的
状态下，可能会被这些处理器改变的数据结构必须在你使用它们的时候受到保护。如下所示：
unsigned 1ong flags;
/* save processor flags and disable interrupts */
save_flags (flags) :
cli():
_read/modify structures. critical section,
restore_flags (flags) ;
这个办法是有效的，但它禁止了所有CPU比的所有中断，因面是一种低效率且又非合作性
质的保护措施。如果目标机器确定是UP系统（单CPU系统），因为它只有一个可以执行内核代码
的CPU，所以你这样做当然无可厚非。在这种情况下，指令将依次进人CPU执行，彼此之间保
特为原子化状态。
21.6.6单独禁止一个中断
如果你知道只有你自已的中断处理器会修改某个内部数据结构，把系统上的所有中断都禁
止掉未免有些小题大做。其实你只需保证当你在修改那些数据结构的时候你自己的中渐处理器
不会再次运行就足可以了。针对这样的情况，Linux提供了用来禁止单条IRQ链的函数，如下
所示：
void disable_irg(unsigned int irq);
void enable_irq(unsigmed int irg);
代码的关键部分可以放在中断的disable和enable之间，中断的前处理部分在这条中断链动作
的同时将不会被再次调用。正常的disable_irq函数和变体的disable_irq_nosync版本之间的区别在
于：前者能够保证在返回之前指定的IRQ在任何CPU上的都不会被执行；而后者在禁止了指定的
中断之后会立刻返回，不理会前处理器是否正在运行。
21.6.7原子化操作
如果指令的执行是一次性完成，中间没有间断—即你在完成之前不会被中断打扰，我们就
说它是原子化的。我们已经知道：只要禁止了中断，就没有入能够在关键节里中断我们的操作，
因而达到原子化操作的目的。Linux还提供了一些对变量进行操作的原子化指令，它们在执行时
不把其他人锁在外面。这些指令都是在asm/atomic.h文件里定义的。
void atomlc_add(int i,volatile atomic_t *v)
void atomic_wub（int 1, volatile atomic_t *v)
int atomic_dec_and_test(volatile atcmic_t *v)
这些指令的操作对象都是atomic_t类型的数据。这是一个只包含着一个计数器成员的结构，
具体包含的是什么东西并不重要，因为你只会通过atomic_x系列函数来访问它。只有这样才能保
加入jaVa编程群：524621833
---
## Page 758
第21章设备驱动程序741
证操作的原子性。它们的主要用途是对信号量进行加减，但你可以把它们用在任何地方。
原子化操作通常用来防止出现竞争现象。假设某个进程决定需要休眠在一个事件上，休眠
与否要根据某个表达式的求值结果来决定，但如果对这个表达式进行的求值操作是非原子化的，
就可能出现竞争现象。Schar用不眷这样的构造，但因为这个问题很常见，所以我们在下面给出
个使用示例：