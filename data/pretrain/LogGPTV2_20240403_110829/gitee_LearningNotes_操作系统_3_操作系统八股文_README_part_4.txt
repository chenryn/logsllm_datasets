*Linux*采用的“一对一”的线程模型，即一个*LWP*对应一个线程。这个模型最大的好处是线程调度由内核完成了，而其他线程操作（同步、取消）等都是核外的线程库函数完成的。
在*LinuxThreads*中，专门为**每一个进程构造了一个管理线程**，负责处理线程相关的管理工作。
**进程VS线程**
- 进程是资源分配的基本单位，所有与该进程有关的资源分配情况，进程也是分配主存的基本单位，它拥有一个完整的虚拟地址空间。而线程与资源分配无关，它属于某一个进程，并与该进程内的其它线程一起共享进程的资源。
- 不同的进程拥有**不同的虚拟地址空间**，而同一进程中的多个线程**共享同一地址空间**。
- 进程调度的切换将涉及到有关**资源指针**的保存及**进程地址空间的转换等**问题。而线程的切换将**不涉及资源指针的保存和地址空间的变化**。所以，线程切换的开销要比进程切换的开销小得多。
- 进程的调度与切换都是由操作系统内核完成，而线程则既可由操作系统内核完成，也可由用户程序进行。
**进程间的通信**
关注点：
- 进程如何把信息传递给另一个进程（共享同一片空间）
- 进程在关键点直接不会出现交叉
- 正确的顺序
进程同步：在多个进程执行次序上的协调；相互合作的一组并发进程在一些**关键点**上可能需要相互等待与互通信息，保证这种关系的就叫进程同步
**竞争条件**：多个进程对共享资源，导致最后的结果与操作的顺序有关
**互斥**：保证进程在使用共享资源的时候，其他进程不能进行相同的操作
##### **保证互斥的四个条件**
- 任何两个进程不能同时处于临济区
- 不应对cpu的速度和数量作任何假设
- 临界区域外进程不能阻塞其他进程
- 不能使进程无限期等待进入临界区
###### **忙等待的互斥**
**信号屏蔽**
- 信号屏蔽
  - 多核中不好用，是针对操作系统的，忘记开启有问题
- 锁变量
  - 获取并将其变成1，但是会有问题，因为进程可能随时切换，还是会卡进去
- 严格轮换法
  - 忙等待，属于自己的就进去，但是违反了条件3，阻塞了别的进程
**睡眠与唤醒**
- 信号量：控制进去临界区域的进层数；如果失败就在该位置睡眠，然后等待信号量增加后，系统随机选取一个唤醒
信号量可以实现进程间的通信，但是由于信号量的控制分布在整个程序中，正确性难分析
- 管程：引入了条件变量，wait和signal，当发现无法继续运行时会在变量上wait，导致进程阻塞；它存在于内存中，进程可以对它进行读写，它提供流控制，保证进程的正确读写，即管道为空时读进程会阻塞，管道为满时写进程会阻塞，以此实现进程之间的通信。
##### 进程间的通信方式
要么是陷入内核，要么是涉及外设
1. 管道( pipe )：
   管道是一种**半双工**的通信方式，数据**只能单向流动**，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。**以内存文件的形式存在**
2. 匿名管道：克服了亲缘的限制，**以磁盘文件的形式存在**，先进先出，可以任意进程间通信
3. 信号量(semophore ) ：
   信号量是一个计数器，可以用来控制**多个进程对共享资源的访问**。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
4. 消息队列( message queue ) ：
   消息队列是由消息的链表，存放在**内核中**并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。存在内核中说明其内核重启或者显式删除的时候才被删除
5. 信号 (sinal ) ：
   信号是一种比较复杂的通信方式**，用于通知接收进程某个事件已经发生。**
6. 共享内存(shared memory ) ：
   共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。**就是拿出一块虚拟地址空间来，映射到相同的物理内存中**。需要某种同步操作来保证，例如**信号量**
7. 套接字(socket ) ：
   套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。
理解：**共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，但是多进程竞争同个共享资源会造成**数据的错乱**；
###### 线程间通信方式
1. 锁机制：包括互斥锁、条件变量、读写锁：只有**拥有互斥对象的线程才有访问公共资源的权限**
   - 互斥锁提供了以排他方式防止数据结构被并发修改的方法。
   - 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
   - 条件变量可以以原子的方式阻塞进程，**直到某个特定条件为真为止**。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
2. 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
3. 信号机制(Signal)：类似进程间的信号处理
   线程间的通信目的主要是用于线程同步，**所以线程没有像进程通信中的用于数据交换的通信机制**。
#### 用户态切换到内核态的方式
1. 系统调用
   这是用户态进程**主动**要求切换到内核态的一种方式，**用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作**，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
2. 异常
   当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到**处理此异常**的内核相关程序中，也就转到了内核态，比如**缺页异常**。
3. 外围设备的中断
   当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
###### **调度**
**发生调度的时间**
- 新的进程被创建
- 进行的进程退出
- 进行的进程被阻塞
- IO中断
- 时钟中断
调度算法
- FIFO：队列、链表
- 最短作业优先：优先队列
- 最短剩余时间优先
- 优先级调度（优先级的静态和动态）
- 多级队列（不同队列的时间片不同，2幂增）
- 保证调度（跟踪已经使用的时间）
- 彩票调度（优先级高拥有的票多）
#### 存储管理
**地址的抽象**
多个应用程序处于内存中互补影响，要满足**保护和重定位**的问题
**交换技术和虚拟内存**
**空间的分配问题**（交换中引起了空洞问题）
- 位图
  - 但是内存很大时，位图也很大
- 链表的方式
  - 算法
    - 首次适配
    - 最佳适配（要遍历一遍）
**虚拟空间**
将程序切割成片段，但是前期时由程序员完成，将这个工作交给系统过去完成；
讲程序中的逻辑地址通过**内存管理单元**MMU进行转换，
虚拟空间中的页面=物理地址中的页框
虚拟地址=虚拟地址页号+偏移量
页表项
![image-20210717232227535](C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210717232227535.png)
通过虚拟地址页号去**页表**找对应的页框同时判断其在不在内存中
**TLB**
在页表也很大时时候；以及**映射得不够快**
相当于给页表再做一个**缓存**
**多级页表**
从页号去找二级页表号，从二级页表号根据第二段找到框号，再加上偏移量
**倒查页表**
根据物理地址页框数量作为哈希数组长度，然后进行哈希
**页表置换算法**
- 最近未使用算法NRU:
  - 两位（是否被访问，是否被修改），定期抹除访问标志（变成0）
- FIFO
- 第二次机会置换算法
  - FIFO的优化，如果被访问过就将其痕迹抹掉重新入队
- 时钟置换算法
  - 相当于给第二次置换算法，用循环链表来实现