### Metadata and Memory Region Manipulation

Before calling `XAtomicExec`, the metadata (METADATA) can be set to different values of `ERmin` and `ERmax`.

#### Case 1.3
Similar to Case 1.2, this scenario involves `ERAdv` being the same region specified by `Vrf` on `XRequest`, but it contains a different executable (`SAdv`).

We demonstrate that an adversary who succeeds in any of these cases can be used to win VRASED’s security game. This is because APEX’s `XProve` function is implemented using VRASED’s `SW-Att`. `SW-Att` covers memory regions `MR` (challenge memory) and `AR` (attested region). Therefore, APEX instantiates these memory regions as follows:

1. `MR = C_hal`
2. `ER ⊂ AR`
3. `OR ⊂ AR`
4. `METADATA ⊂ AR`

This ensures that all sensitive memory regions used by APEX are included among the inputs to VRASED’s attestation.

Let \( X(t) \) denote the content in memory region \( X \) at time \( t \). The adversary \( AdvRA \) can be constructed using \( AdvPoX \) as follows:

1. **Receiving Challenge:**
   - \( AdvRA \) receives \( C_hal \) from the challenger in step (2) of the RA security game (Definition 7).

2. **Writing to Attested Region:**
   - At an arbitrary time \( t \), \( AdvRA \) has three options to write \( AR(t) = AR_{\text{Adv}} \) and call \( AdvPoX \):
     1. **Modify `ER(t)` or `OR(t)` or `METADATA(t)`:**
        - Modify \( ER(t) \neq S \) or \( OR(t) \neq O \) or \( METADATA(t) \neq METADATA_{\text{Vrf}} \).
        - Call \( AdvPoX \) in Case 1.1.
     2. **Modify `ER` Range:**
        - Modify \( ER \) to be different from the range chosen by \( Vrf \).
        - Therefore, \( METADATA(t) \neq METADATA_{\text{Vrf}} \).
        - Call \( AdvPoX \) in Case 1.2.
     3. **Modify `ER(t)` to be Different from `S`:**
        - Modify \( ER(t) \neq S \).
        - Call \( AdvPoX \) in Case 1.3.

In any of these options, \( AdvRA \) will produce \( (H_{\text{Adv}}, O_{\text{Adv}}) \) such that \( XVerify(H_{\text{Adv}}, O_{\text{Adv}}, S, C_{\text{hal}}, \cdot) = 1 \) with non-negligible probability.

3. **Replying to the Challenger:**
   - \( AdvRA \) replies to the challenger with the pair \( (M, H_{\text{Adv}}) \), where \( M \) corresponds to the values of \( S \), \( O \), and \( METADATA_{\text{Vrf}} \), matching \( H_{\text{Adv}} \) and \( O_{\text{Adv}} \) generated by \( AdvPoX \).
   - By construction, \( M \neq AR_{\text{Adv}} = AR(t) \), as required by Definition 7.

4. **Challenger Acceptance:**
   - The challenger will accept \( (M, H_{\text{Adv}}) \) with the same non-negligible probability that \( AdvPoX \) has of producing \( (H_{\text{Adv}}, O_{\text{Adv}}) \) such that \( XVerify(H_{\text{Adv}}, O_{\text{Adv}}, S, C_{\text{hal}}, \cdot) = 1 \).

### Software Transformation

Recall that the notion of successful execution (in Section 5.1) requires the executable’s entry point to be at the first instruction in `ER` and the exit point to be at the last instruction in `ER`. In this section, we discuss how to efficiently transform arbitrary software to conform with this requirement.

Lines 10-17 of Figure 8.a show a partial implementation of the `ReadSensor` function described in Section 7.3. This implementation, when converted to an executable, does not meet APEX’s executable requirement, as the compiler may choose to place one of its sub-functions (instead of `ReadSensor`) as the entry and/or exit points of the executable. One way to fix this issue is to implement all of its sub-functions as inline functions. However, this may be inefficient; in this example, it would duplicate the code of the same sub-functions (e.g., `digitalWrite`) inside the executable.

Instead, we create dedicated functions for the entry (Lines 1-4) and exit (Lines 6-8) points, and assign those functions to separate executable sections: “.exec.entry” for the entry and “.exec.exit” for the exit. Then, we label all sub-functions used by `ReadSensor` as well as `ReadSensor` itself to the same section – “.exec.body” – and modify the MSP430 linker to place “.exec.body” between “.exec.entry” and “.exec.exit” sections. The modified linker script is shown in Figure 8.b.

---

This optimized text provides a clearer and more professional explanation of the scenarios and transformations involved in the security game and software transformation.