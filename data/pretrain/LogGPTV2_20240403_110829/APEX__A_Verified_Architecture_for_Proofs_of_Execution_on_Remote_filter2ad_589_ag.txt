METADATA to different values of ERmin and ERmax before
calling XAtomicExec).
Case1.3 Similar to Case1.2, with ERAdv being the same region
speciﬁed by V rf on XRequest, but instead containing a different
executable SAdv.
We show that an adversary that succeeds in any of these cases
can be used win VRASED’s security game. To see why this is the
case, we note that APEX’s XProve function is implemented by using
VRASED’s SW-Att. SW-Att covers memory regions MR (challenge
memory) and AR (attested region). Hence, APEX instantiates these
memory regions as:
USENIX Association
29th USENIX Security Symposium    787
P4IN
P4OUT
P4DIR
P4SEL
BIT4
# d e f i n e
# d e f i n e
# d e f i n e
# d e f i n e
# d e f i n e
# d e f i n e MAXTIMINGS
# d e f i n e OR
# d e f i n e HIGH
# d e f i n e LOW
# d e f i n e INPUT
# d e f i n e OUTPUT
_ _ a t t r i b u t e _ _ ( ( s e c t i o n ( ".exec.entry" ) , naked ) ) void R e a d S e n s o r E n t r y
( * ( v o l a t i l e u n s i g n e d c h a r * ) 0x001C )
( * ( v o l a t i l e u n s i g n e d c h a r * ) 0x001D )
( * ( v o l a t i l e u n s i g n e d c h a r * ) 0x001E )
( * ( v o l a t i l e u n s i g n e d c h a r * ) 0 x001F )
( 0 x0010 )
85
0xEEE0 / / OR i s
0x1
0x0
0x0
0x1
i n AR
( ) {
// ERmin
ReadSensor ( ) ;
__asm__ volatile ( "br #__exec_leave" "\n\t" ) ;
}
_ _ a t t r i b u t e _ _ ( ( s e c t i o n ( ".exec.body" ) ) ) int d i g i t a l R e a d ( ) {
if ( P3IN & BIT4 ) return HIGH ;
else return LOW;
}
_ _ a t t r i b u t e _ _ ( ( s e c t i o n ( ".exec.body" ) ) ) void d i g i t a l W r i t e ( u i n t 8 _ t v a l
}
_ _ a t t r i b u t e _ _ ( ( s e c t i o n ( ".exec.body" ) ) ) void pinMode ( u i n t 8 _ t v a l ) {
) {
if ( v a l == LOW)
P3OUT &= ~BIT4 ;
else
P3OUT | = BIT4 ;
if ( v a l ==
INPUT )
P3DIR &= ~BIT4 ;
else if ( v a l == OUTPUT)
P3DIR | = BIT4 ;
}
_ _ a t t r i b u t e _ _ ( ( s e c t i o n ( ".exec.body" ) ) ) void ReadSensor ( ) {
// Tell the sensor that we are about to read
d i g i t a l W r i t e (HIGH) ;
delayMS ( 2 5 0 ) ;
pinMode (OUTPUT) ;
d i g i t a l W r i t e (LOW) ;
delayMS ( 2 0 ) ;
d i g i t a l W r i t e (HIGH) ;
d e l a y M i c r o s e c o n d s ( 4 0 ) ;
pinMode ( INPUT ) ;
u i n t 8 _ t
u i n t 8 _ t d a t a [ 5 ] = { 0 } ;
// Read the sensor’s value
for (
l a s t s t a t e = HIGH ,
i = 4 ) && ( i%2 == 0 ) ) {
d a t a [ j / 8 ]  100) {
d a t a [ j / 8 ]
| = 1 ;
avg += c o u n t e r ;
k ++;
}
j ++;
}
}
// Copy the reading to OR
memcpy (OR, d a t a , 5 ) ;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
_ _ a t t r i b u t e _ _ ( ( s e c t i o n ( ".exec.exit" ) , naked ) ) void R e a d S e n s o r E x i t ( )
{
__asm__ volatile ( "ret" "\n\t" ) ;
// ERmax
(a) Fire Sensor’s code written in C
. . .
SECTIONS
{
. . .
. t e x t
{
:
}
. . .
}
. . .
. . .
* ( . exec . e n t r y )
. = ALIGN ( 2 ) ;
* ( . exec . body )
. = ALIGN ( 2 ) ;
PROVIDE ( _ _ e x e c _ l e a v e = . ) ;
* ( . exec . e x i t )
> REGION_TEXT
(b) Linker script
Figure 8: Code snippets for (a) ﬁre sensor described in Sec-
tion 7.3 (b) linker script
1. MR = C hal;
2. ER ⊂ AR;
3. OR ⊂ AR;
4. METADATA ⊂ AR;
Doing so ensures that all sensitive memory regions used by APEX
are included among the inputs to VRASED’s attestation. Let X(t)
denote the content in memory region X at time t. AdvRA can then be
constructed using AdvPoX as follows:
1. AdvRA receives C hal from the challenger in step (2) of RA
security game of Deﬁnition 7.
2. At arbitrary time t, AdvRA has 3 options to write AR(t) = ARAdv
and call AdvPoX:
(a) Modify ER(t) (cid:54)= S or OR(t) (cid:54)= O or METADATA(t) (cid:54)=
METADATAV rf. It then calls AdvPoX in Case1.1.
(b) Modify ER to be different from the range chosen by
V rf. Therefore, METADATA(t) (cid:54)= METADATAV rf. It
then calls AdvPoX in Case1.2.
(c) Modify ER(t) to be different from S. It then calls AdvPoX
in Case1.3.
In any of these options, AdvRA will produce (HAdv,OAdv), such
that XVerify(HAdv,OAdv,S ,C hal,·) = 1 with non-negligible
probability.
3. AdvRA replies to the challenger with the pair (M,HAdv), where
M corresponds to the values of S, O and METADATAV rf,
matching HAdv and OAdv generated by AdvPoX. By construc-
tion M (cid:54)= ARAdv = AR(t), as required by Deﬁnition 7.
4. Challenger will accept (M,HAdv) with the same non-negligible
probability that AdvPoX has of producing (HAdv,OAdv) such
that XVerify(HAdv,OAdv,S ,C hal,·) = 1.
C Software Transformation
Recall that the notion of successful execution (in Section 5.1)
requires the executable’s entry point to be at the ﬁrst instruction
in ER and the exit point to be at the last instruction in ER. In
this section, we discuss how to efﬁciently transform arbitrary
software to conform with this requirement.
Lines 10-17 of Figure 8.a show a (partial) implementation of
the ReadSensor function described in Section 7.3. This im-
plementation, when converted to an executable, does not meet
APEX’s executable requirement, since the compiler may choose
to place one of its sub-functions (instead of ReadSensor)
as the entry and/or exit points of the executable. One way to
ﬁx this issue is to implement all of its sub-functions as inline
functions. However, this may be inefﬁcient; in this example,
it would duplicate the code of the same sub-functions (e.g.,
digitalWrite) inside the executable.
Instead, we create dedicated functions for entry (Line 1-
4) and exit (Line 6-8) points, and assign those functions to
separate executable sections: “.exec.entry” for the entry and
“.exec.exit” for the exit. Then, we label all sub-functions used
by ReadSensor as well as ReadSensor itself to the same
section – “.exec.body” – and modify the MSP430 linker to
place “.exec.body” between “.exec.entry” and “.exec.exit” sec-
tions. The modiﬁed linker script is shown in Figure 8.b.
788    29th USENIX Security Symposium
USENIX Association