在我的定义里，爬虫在速度上一般有两种级别：在短时间内把你爬死的和鬼子进村悄悄滴慢慢爬你的。  
前一种爬虫步子迈得太大，容易扯到蛋，被运维同学通过突发资源消耗或者简单频控就能识别出来。  
后一种爬虫比较恶心，它爬取的速度很慢，隐藏在滚滚业务洪流中，隐蔽性极强，危害极高，识别难度也很高，就十分气人，我通常称呼它为慢速爬虫。
当然了，还有一些爬虫用了Headless的浏览器模拟人类请求，或者干脆就透过某些垃圾公司的客户端软件在屏幕(9999,9999)坐标处显示一个“不可见”的浏览器偷偷搞分布式“爬虫”。这种公司臭不要脸，迟早要倒闭，我们先鄙视它一下。
同志们，我每次要谈论的话题都很沉重，都涉及到程序员的相爱相杀（我觉得主要责任在于PM和运营）。虽说本是同根生，但是不搞你我就没饭吃了。下面就来说一下我在做慢速爬虫识别过程中遇到的曲折道路和艰难探索。
* * *
# 一、慢速爬虫的共性特征
慢速爬虫为什么恶心呢，就是因为它太慢了。
我们历史上通过一些人工的方式发现了几个慢速爬虫，当时我们对慢速爬虫做了一点简单的提炼，这里摘录一部分——
以我司全站为例（因数据保密需要，本文涉及到的所有运营数据都随机做了加减乘除，连标点符号都别信哈）平均每天有8亿个请求，发现的慢速爬虫每秒的平均请求数在0.1个左右，相差悬殊。
因为日志量比较多，我们的访问日志中有48小时左右的热数据在ELK上可供实时分析。所以我们把时间维度从分钟拉到24小时，试图从更久的时间上看看爬虫的访问情况：
（图片：在24小时时间维度内，某慢速爬虫的访问分布）
显然，在中短期时间维度内，爬虫访问较无规律，似乎有随机因子在干扰。不过在中长期的时间维度内，我们发现慢速爬虫的访问丰度较高。即，在一段时间的每个时间切片内，慢速爬虫活跃程度与一般用户有显著区别。
从此前的提炼上可以得知， **慢速爬虫的访问分布和访问丰度和正常用户相比都不太科学** ，我们以此入手尝试分析看看。
很快我们上线测试了第一个带有明显A股特色（T+1天）的分析小程序，通过分析前一天的日志，建立5分钟级别的时间切片，然后筛选出可能的慢速爬虫以供运维大哥封IP。
一天后，结果出来，近1万个IP被程序归类到慢速爬虫中。顿时美滋滋的心情就不复存在，心里就咯噔一下——量级不对，完了，别是识别错了。
随后的抽样检查结果证实了这个判断。原因很简单， _我们有一部分客户端程序可能会被切到后台中运行，后台运行的程序的确会定时发起请求_
，这样在访问日志上体现出来的结果就和慢速爬虫高度一致。
让PM改掉这个功能？不可能的，改功能是不可能改的，这辈子都不可能改了。那这样又不能用，只能靠加大数据量这个办法才能维持得了准确率这个样子。
（PM听到我妄图砍功能时候的表情）
欸……我刚刚是不是说了加大数据量？如果1天不行，那我就把时间放大到30天如何？总不至于有用户连续30天不关机不杀进程吧？
# 二、海量数据带来的可行方案讨论：滑动时间窗口计数
30天啊！240亿条请求啊！我要查找一个IP的访问情况我是不是得遍历这240亿条？我每隔5分钟是不是要重新在内存中淘汰掉前五分钟的数据是不是又要遍历一次？
我要是一天光遍历就要8亿次（假设每次请求都校验一下），这……太湖之光了解一下？
虽说数据是海量的，但在这个场景中，我们有效信息只有IP和IP访问分布情况。仔细想想，24小时内5分钟切片的话共有288块，那扩展到30天之后是不是还需要5分钟切一次呢？一小时切一次可不可以？
这时候我想到一个非常“绝妙”的方法，如果以小时为单位进行切片，可以将时间戳降为一个不超过720（30天*24小时）的索引。计算方法为：
`(int)({Timestamp} / 3600) % 721`
我们可以为每一个IP建立一个长度是721的无符号整形数组，这个数组内每一个元素代表这个IP在对应小时索引内的访问次数。我这里画一下图——
如图所示，我们通过建立这个滑动计数窗口，使得整个计数过程变得如丝般顺滑，非常优美。
**（思考题：为什么这里是取余数用的是721而不是720？）**
而且这样一来，我们需要维护的信息被降维了，省去了原先记录每个访问时间戳时不可避免的排序过程。而且对于任意一个IP，我们需要维护的核心数据长度变为 721 *
4字节 = 2884字节，1亿条独立IP所消耗的内存空间约为270G。
等等，我们最早不是说目标的数据集合预估会有240亿条，怎么这里按照1亿条独立IP计算？
大哥，IPv4的地址空间只有2^32，除去保留地址之后全世界能用的不到37亿条，还有不少IP被机构、学校、政府、ISP搞走了。根据16年末某国内互联网发展报告显示，全国网民独立IP数为2.2亿个……1亿个已经占了50%好不好，我们是小厂啊大哥。
（P.S: 事实上，我们对240亿条IP去重后，发现独立IP数在千万这个级别）
# 三、算法与数据结构的比拼：哈希表拯救世界
那有了上面这么优美的数据结构，我们赶紧去实现呗~
于是我们定义一个数据结构：
    struct ip_tree {
        uint8_t ip_addr[4];
        uint32_t timeline[721];
    };
然后做个链表链一下，感觉依然十分优美……吧。
再于是我们就喂了下数据……刚开始还好，但是随着时间的增加程序变得越来越慢。艾玛卧槽，我咋写了个时间复杂度是O(n)的玩意儿？
那就些不太优美了，得优化一下，O(n)复杂度接受不了啊。回想一下，IP地址本身即是一个高度为4的256叉树，点分位已经替我们完成了层级的分割。
**因为固定高度的256叉树的存在，我们把IP查找问题就转换成了一个“哈希表查找”，时间复杂度变成了O(1)，十分优美。**
经过改造后的数据结构变成这样：
    struct last_node {
        unsigned char ip_addr;
        uint16_t timeline[721];
        struct last_node *next;
    };
    struct tree_node {