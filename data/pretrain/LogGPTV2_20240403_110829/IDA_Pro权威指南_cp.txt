 函数，你需要了解如何构建可执行文件。如果你遇到困难，你可以利用构建你所分析的二进制文件所使用的工具，构建一些简单的可执行文件（例如，引用main
 函数中的一个易于识别的字符串）。通过分析这些简单的文件，你将逐步了解使用一组特定的工具构建的二进制文件的基本结构，并利用这些知识，进一步分析使用同一组工具构建的更加复杂的二进制文件。
20.4 调试版与发行版二进制文件
通常，微软的 Visual Studio项目能够构建调试版本或发行版本的二进制程序。要了解这两个版本之间的差异，可以比较一个项目的调试版本和发行版本所指定的构建选项。二者之间的细微差异包括：发行版本通常经过优化1
 ，而调试版本则没有；调试版本链接有其他符号信息和运行库，而发行版本则没有。增加与调试有关的符号，有助于调试器将汇编语言语句转换成它们对应的源代码，还有助于确定局部变量的名称2
 。通常，这些信息会在编译过程中丢失。在编译调试版本的微软运行库时，我们还可以包含调试符号、禁用优化并启用其他安全检查，以核实一些函数参数是否有效。
1. 优化通常是指删除代码中的多余代码，或选择更快但可能更大的代码序列，以满足开发者的期望，即创建更快或更小的可执行文件。与未优化代码相比，分析经过优化的代码要困难一些，因此，在程序的开发和调试阶段，使用优化代码被视为是一个错误的选择。
2. 在编译过程中，gcc 也能够插入调试符号。
使用IDA 进行反汇编时，Visual Studio项目的调试版本与发行版本之间存在着明显的差异。这是仅调试版本指定了编译器和链接器选项的结果，如基本的运行时检查（/RTCx3
 ）选项，它在最终的二进制文件中引入了额外的代码。这些额外的代码会造成一个“副作用”：它会破坏IDA的启动签名匹配过程，导致 IDA 总是无法自动定位调试版本的二进制文件中的 main
 函数。
3. 参见http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx
 。
在调试版本的二进制文件中，一个明显的不同是几乎所有的函数都通过 jump
 函数（也叫做thunk
 函数）调用，如下面的代码片段所示：
➎ .text:00411050 sub_411050      proc near               ; CODE XREF: start_0+3↓p  
   .text:00411050               ➏jmp     sub_412AE0  
   .text:00411050 sub_411050     endp  
   ...  
➊ .text:0041110E start           proc near  
   .text:0041110E               ➋jmp     start_0  
   .text:0041110E start          endp  
   ...  
➌ .text:00411920 start_0         proc near               ; CODE XREF: start↑j  
   .text:00411920                push    ebp  
   .text:00411921                mov     ebp, esp  
   .text:00411923               ➌call    sub_411050  
   .text:00411928                call    sub_411940  
   .text:0041192D                pop     ebp  
   .text:0041192E                retn  
   .text:0041192E start_0        endp
在这个例子中，程序入口点（➊ ）除了跳转（➋ ）到真正的启动函数（➌ ）外，其他什么也不做。启动函数又调用（➍ ）另一个函数（➎ ），而后者则跳转到（➏ ）启动函数的实现位置。➊ 和➎ 这两个函数中没有其他内容，只有一个叫做thunk 函数的跳转语句。在调试版本的二进制文件中大量使用thunk 函数给IDA 的签名匹配过程造成一个很大的障碍。虽然thunk
 函数会大大减慢你的分析进程，但使用前一节中描述的技巧，你仍然可以跟踪到二进制文件的main
 函数。
在调试版本的二进制文件中进行基本的运行时检查，会导致在执行任何函数时都增加其他一些操作。一个调试版本的二进制文件的扩充版“序言”如下所示：
.text:00411500                  push    ebp  
.text:00411501                  mov     ebp, esp  
.text:00411503                ➊ sub     esp, 0F0h  
.text:00411509                  push    ebx  
.text:0041150A                  push    esi  
.text:0041150B                  push    edi  
.text:0041150C                 ➋lea     edi, [ebp+var_F0]  
.text:00411512                  mov     ecx, 3Ch  
.text:00411517                  mov     eax, 0CCCCCCCCh  
.text:0041151C                  rep stosd  
.text:0041151E                ➌ mov     [ebp+var_8], 0  
.text:00411525                  mov     [ebp+var_14], 1  
.text:0041152C                  mov     [ebp+var_20], 2  
.text:00411533                  mov     [ebp+var_2C], 3
这个例子中的函数使用 4 个局部变量，它们仅仅需要 16 个字节的栈空间。但是，我们看到，这个函数分配了 240 个字节（➊）的栈空间，然后用 0xCC
 这个值填充这 240 个字节。从➋开始的4 行代码等同于下面的函数调用：
memset(&var_F0, 0xCC, 240);
字节值0xCC
 对应于int
 3 的x86 操作码，int 3
 是一个软件中断，它会使一个程序进入调试器中。用大量 0xCC
 值填充栈帧，是为了确保当程序试图执行栈中的指令时（在调试版本的二进制文件中可能会遇到的错误条件），调试器将被调用。
这个函数的局部变量从➌处开始初始化，从那里我们注意到，这些变量并不是彼此相邻。它们之间的多余空间由前面的 memset
 操作用0xC
 C值填充。但是，变量之间的额外空间会使我们更易于检测出一个变量的溢出情况，这种溢出可能会波及另一个变量，并给它造成破坏。在正常情况下，任何已声明变量之外用作填充符的 0xCC
 值，绝不可能被覆写。为了便于比较，上面代码的发行版本如下所示：
.text:004018D0                  push    ebp  
.text:004018D1                  mov     ebp, esp  
.text:004018D3                 ➊ sub     esp, 10h  
.text:004018D6                 ➋ mov     [ebp+var_4], 0  
.text:004018DD                  mov     [ebp+var_C], 1  
.text:004018E4                  mov     [ebp+var_8], 2  
.text:004018EB                  mov     [ebp+var_10], 3
我们看到，发行版本仅为局部变量分配了所需的空间（➊），而且所有 4 个变量彼此相邻（➋）。还要注意的是，这时已不再需要使用 0xCC
 作为填充值。
20.5 其他调用约定
在第6 章中，我们讨论了C 和C++ 代码常用的许多调用约定。虽然在连接两个已编译模块时，我们必须遵循一个已发布的调用约定，但是在单独一个模块中，函数使用自定义调用约定并不会受到任何限制。高度优化的函数常常使用自定义调用约定，不过，这些函数不能从它们所在的模块之外调用。
下面的代码是一个使用非标准调用约定的函数的前 4 行：
    .text:000158AC sub_158AC       proc near  
    .text:000158AC  
➊  .text:000158AC arg_0           = dword ptr  4  
    .text:000158AC  
    .text:000158AC                 push    [esp+arg_0]  
    .text:000158B0              ➋ mov     edx, [eax+118h]  
    .text:000158B6                 push    eax  
    .text:000158B7              ➌ movzx   ecx, cl  
    .text:000158BA                 mov     cl, [edx+ecx+0A0h]
根据IDA 的分析，该函数的栈帧中只有一个参数（➊）存在。但是，经过仔细分析，我们发现，这个函数使用了 EAX寄存器（➋）和 CL寄存器（➌），但没有进行任何初始化。据此，我们得出的唯一结论是，EAX和CL寄存器应由调用方初始化。因此，我们应把这个函数看成是一个包含3 个参数的函数，而不是仅包含一个参数的函数。在调用它时，你必须特别小心，以确保它的3 个参数都处在正确的位置。
通过设置函数的“类型”，IDA 能够指定任何函数的自定义调用约定。通过Edit ▶ Functions ▶Set function type （编辑▶函数▶设置函数类型）菜单项输入函数的原型并使用 IDA 的_usercall 调用约定，即可做到这一点。用于为上一个示例中的 sub_158AC 设置类型的对话框如图20-1 所示。
图20-1 将函数指定为_usercall
为清楚起见，下面再次提供了函数声明：
int __usercall sub_158AC(struc_1 *, unsigned __int8 index, int)
其中，IDA 关键字_usercall
 用于替代_cdecl
 或_stdcall
 等标准调用约定。要使用_usercall
 ，我们需要将保存函数的返回值的寄存器名称附加到函数名称之前（此例中得到sub_158AC
 ），告知IDA 该寄存器的名称。如果函数不返回值，则可以省略返回寄存器。在参数列表中，还必须在将对应的寄存器名称附加到参数的数据类型之前，为每个基于寄存器的参数提供注释。设置函数的类型后，IDA 将向实施调用的函数传播参数信息，清楚说明函数调用顺序，如下面的代码所示：
.text:00014B9F        ➊  lea     eax, [ebp+var_218] ; struc_1 *  
.text:00014BA5        ➋  mov     cl, 1           ; index  
.text:00014BA7        ➌  push    edx             ; int  
.text:00014BA8            call    sub_158AC
从上述代码中可以明显看出，IDA 识别出：EAX将保存函数的第一个参数（➊），CL将保存第二个参数（➋），第三个参数将位于栈上（➌）。
即使在一个可执行文件中，调用约定也可能截然不同。为说明这一点，我们提供了另一个取自同一个二进制文件的、使用自定义调用约定的示例，如下所示：
    .text:0001669E sub_1669E       proc near  
    .text:0001669E  
➊  .text:0001669E arg_0           = byte ptr  4  
    .text:0001669E  
    .text:0001669E              ➋ mov     eax, [esi+18h]  
    .text:000166A1                add     eax, 684h  
    .text:000166A6                cmp     [esp+arg_0], 0
在这个例子中，IDA 同样指出，函数仅访问了栈帧中的一个参数（➊）。仔细分析代码后会发现，在调用这个函数之前，还应对 ESI 寄存器（➋）进行初始化。这个例子说明，即使对同一个二进制文件而言，保存与寄存器有关的参数的寄存器也可能因函数而异。
通过这些例子，我们得到的教训是：你必须了解一个函数如何初始化它所使用的每一个寄存器。如果一个函数在初始化一个寄存器之前使用了该寄存器，那么这个寄存器是用来传递一个参数的。请参阅第 6 章，了解各种编译器和调用约定使用哪些寄存器。
20.6 小结
特定于编译器的行为的数量非常庞大，仅仅一章内容（甚至相关主题的一本书）并不足以完全介绍所有行为。除其他行为差异外，编译器还选择不同的算法来实现各种高级结构，并选择不同的方式来优化生成的代码。在很大程度上，编译器的行为取决于在构建过程中传递给它的参数，因此，使用相同的源代码但采用不同的构建选项，一个编译器可能会生成截然不同的二进制文件。要学会如何处理所有这些不同的变体，你需要不断积累经验。使问题更加复杂的是，关于特定的汇编语言结构，你很难搜索到相关帮助，因为要想构建一个搜索表达式，生成符合你的特殊要求的结果，可能会非常困难。通常，遇到这种情况时，各种专门讨论逆向工程的论坛是你可以利用的最佳资源，你可以将相关代码粘贴在这些论坛上，利用那些和你具有相同经历的人的经验。
第21章 模糊代码分析
即使在理想情况下，理解一个反汇编代码清单也相当困难。对于任何计划深入挖掘二进制文件内部机制的人来说，高质量的反汇编工作都非常重要，这也正是我们用前面整整20章内容讨论IDA Pro 及其功能的原因。你可能会说，IDA 如此高效，它降低了人们进入二进制分析领域的门槛。虽然这并不完全归功于IDA ，但近些年来，二进制逆向工程领域已经取得了长足的进步，而希望保护软件不被分析的程序员也同样不甘示弱。于是，过去几年中，逆向工程人员与希望保护他们代码的程序员之间展开了某种“军备竞赛”。在这一章中，我们将分析IDA 在其中扮演的角色，并讨论人们为保护代码而采取的措施，以及IDA 如何战胜这些措施。
各种字典定义指出，模糊是一种使某物变得模糊、混乱，令人困惑、迷惑，以防止他人理解被模糊的项目的行为。另一方面，反逆向工程包括一系列旨在阻止他人分析某个项目的技巧（模糊为其中之一）。在本书中及使用 IDA 的情形下，我们认为这些反逆向工程技巧所适用的项目为二进制可执行文件（例如，相对于源文件或硅芯片）。
为了研究模糊以及反逆向工程对于 IDA 应用的总体影响，我们首先将这些技巧分类，以了解每一种技巧的作用。需要注意的是，对每一种技巧进行分类，并没有唯一正确的方法，因为这些分类往往会相互重叠。此外，新的反逆向工程技巧不断涌现，我们在这里不可能讨论所有这些技术。
21.1 反静态分析技巧
反静态分析技巧的主要目的是防止分析人员不必运行程序就知道该程序的用途。这些技巧所针对的目标恰恰是 IDA 之类的反汇编器。因此，如果你选择使用 IDA 逆向工程二进制文件，它们应引起你的极大关注。下面介绍几种反静态分析技巧。
21.1.1 反汇编去同步
这是一种较为古老的技巧，它专门破坏反汇编过程，即创造性地使用指令和数据，以阻止反汇编器找到一条或多条指令的起始地址。通常，这种方法将令反汇编器“迷失自己”，无法生成反汇编代码清单，或者至少生成错误的反汇编代码清单。
在下面的代码中，IDA 正努力反汇编 Shiva1
 反逆向工程工具：
1. 2003 年，Shaun Clowes 和Neel Mehta 首次在CanSecWest上推出Shiva。参见：http://www.cansecwest.com/core03/shiva.ppt
 。
    LOAD:0A04B0D1               call  ➊ near ptr loc_A04B0D6+1  
    LOAD:0A04B0D6  
    LOAD:0A04B0D6 loc_A04B0D6:                       ; CODE XREF: start+11 ↓ p
➋  LOAD:0A04B0D6                 mov     dword ptr [eax-73h], 0FFEB0A40h  
    LOAD:0A04B0D6 start          endp  
    LOAD:0A04B0D6  
    LOAD:0A04B0DD  
    LOAD:0A04B0DD loc_A04B0DD:                       ; CODE XREF: LOAD:0A04B14C↓ j  
    LOAD:0A04B0DD                loopne  loc_A04B06F  
    LOAD:0A04B0DF                mov     dword ptr [eax+56h], 5CDAB950h  
➌  LOAD:0A04B0E6                iret  
    LOAD:0A04B0E6 ;---------------------------------------------------------------  
➍  LOAD:0A04B0E7                db 47h  
    LOAD:0A04B0E8               db 31h, 0FFh, 66h  
    LOAD:0A04B0EB ;---------------------------------------------------------------  
    LOAD:0A04B0EB  