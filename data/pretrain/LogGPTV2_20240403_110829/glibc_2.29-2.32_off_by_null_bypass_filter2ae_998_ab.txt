**在glibc 2.29以上版本** 加入了一个key结构用于检测doube
free，所以tcache的方法不再可行了，因为这个key的位置正好就是在bk（fake size）的位置，这会导致我们的fake
size被复写。而我们又因为要用部分写入来改写next指针，所以无法还原fake size的内容。
**方案2：使用fastbin**
使用fastbin就没有key结构来干扰fake
size了，但是由于fastbin的申请size有限，所以如果使用这个方法，需要保证能够申请出fastbin size的堆块。
如果可以申请出堆块，操作方法和tcache一样就可以。
这种方法是早期经常使用的方法，但是犹豫限制条件过多并且比较繁琐。所以现在的题目一般都无法使用这种方法。
###  2.利用unsorted bin和large bin链机制
这部分内容如果利用得当，可以在题目的苛刻的条件下（如会在末尾写入\x00等…）也可以无需爆破伪造堆块，属于本文的重头戏。
本部分演示使用的例题是来自NepCTF的由FMYY师傅所出的 **NULL_FXCK**
，该题目做法多样化且构造堆块技巧性强，是一道非常完美的压轴pwn题，在比赛中也只有cnitlrt师傅（orz）一人完成。
官方wp采用large
bin链机制来伪造FD和BK，爆破1/16几率成功，我在这里讲解的做法，不需要爆破就可以成功，大大提高了效率。由于后续部分脱离本篇的主题，故这里只讲解构造unlink的方法。之后的利用部分也是非常的有意思，让我不禁感叹
FMYY YYDS，如果之后有时间的话，也会对后面的内容的多种做法进行讲解。
###  基本思路
**1.在fd和bk写堆地址**
如下图所示，堆块0x55555555bc00是我们要用于构造的堆块地址。
通过unsorted bin 链表我们让这个堆块的fd和bk都写了一个堆地址
**构造图：**
其中辅助堆块的作用在之后会提及
**构造代码：**
    add(0x418) #0 fd
    add(0x108) #1
    add(0x418) #2
    add(0x438) #3
    add(0x108) #4
    add(0x428) # 5 bk 
    add(0x108) # 6
    delete(0)
    delete(3)
    delete(5)
**2.在伪造堆块附近申请堆块**
由于我们要通过部分写入的方法来绕过检测，而在堆空间中，只有低三字节是固定的。
所以我们为了逃避爆破，希望能够找到只需要覆盖最低一字节就可以修改成fake
chunk的地址，于是我们应该利用在fake堆块附近0x100内的堆块来作为辅助堆块写地址，
**之前申请的辅助堆块就是起到了这个作用，我们可以利用这个堆块来进行重分配，使得分配的地址非常贴近利用堆块** 。
**构造图：**
可以发现，我们先让辅助堆块和利用堆块合并之后再对空间进行重新分配，使得堆块2恰好可以覆盖到之前利用堆块的size，且堆块3的0x55555555bc20，十分贴近之前0x55555555bc00，只需要抹去最低一字节即可。
**构造代码：**
    delete(2) #2 & 3 unlink
    add(0x438, 'a' * 0x418 + p64(0xA91))  # 0 set size
    add(0x418)  # 2 c20
    add(0x428)  # 3 bk 150
    add(0x418)  # 5 fd 2b0
**注意：**
分配完成之后，我们再把全部堆块申请回来，这可能并不是步骤最少的做法，但是全部申请回来可以使得操作有条理，使得我们构造过程中出现的问题减少。
**3.修复 fake fd**
**修复思路：**
我们在之前的状态下，先删除 **fake- >FD堆块**，再删除 **重分配堆块2（辅助堆块）** 。我们就可以在 **fake->FD堆块的BK位置**写入一个 **重分配堆块2（辅助堆块）** 的值
再用部分写入一字节来覆盖，覆盖成 **利用堆块** 的指针
最后再把bc20这个辅助堆块申请回来，方便下一次使用。
**构造代码：**
    # partial overwrite fd -> bk by unsorted bin list
    delete(5)
    delete(2)
    add(0x418, 'a' * 9)  # 2 partial overwrite bk
    add(0x418)  # 5 c20
**4.修复 fake bk**
**修复思路：**
在我示例的这道题下，使用unsorted bin来修复另外 **fake bk** 是很难的，这是因为这道题如果要进unsorted
bin的堆块，size大小要大于等于0x418，而这个size是在largebin范围内的。
所以如果我使用不同size申请的方法，错开 **辅助堆块** 去直接申请 **fake bk堆块（因为如果要在fake bk->fd的位置写堆值，那么在遍历的时候一定是先遍历到辅助堆块，所以需要错开辅助堆块先去申请fake
bk堆块，我想到的方法就是申请一个辅助堆块无法提供的size来错开。但事实上，错开辅助堆块会使得辅助堆块进入largebin中，从而与原来的fake
bk断链，这样原来已经写上的堆地址也不复存在）**，因为这个原因所以这部分我要先让堆块进入largebin再用 **类似于修复fake
fd的方法进行修复。**
先删除 **重分配堆块2（辅助堆块）** ，再删除 **fake- >BK堆块**（注意：这里和上面顺序不一致，这是因为想要写入堆块地址的位置不一致）
再让堆块进入到largebin 中
再使用部分写入恢复 **fake bk**
构造代码：
    # partial overwrite bk -> fd by largebin list
    delete(5)
    delete(3)
    add(0x9F8)  # 3 chunk into largebin
    add(0x428, 'a')  # 5 partial overwrite fd
    add(0x418)  # 7 c20
**5.伪造prev_size，off by null修改size的p标志位**
这部分内容不是本文重点故略过
**构造代码：**
    # off by null
    add(0x108, p64(0) + p64(0x111))  # 8
    edit(6, 'a' * 0x100 + p64(0xA90))
    delete(3)  # unlink
###  小结
不可泄露堆块地址伪造的根本思想就是通过部分写入来篡改地址到另一个位置。在这个过程中，应当要灵活应变，不能死板的套代码。在必要的时候，牺牲爆破时间来提高调试速度和exp编写速度也是有必要的。
## 总结
通过对本篇文章的学习，相信各位师傅已经能够对于高版本glibc的构造堆块重叠部分得心应手了，但新版glibc的魅力远远只是这篇文章所描述的那么简单，仍然还有很多方法和技巧值得我们去挖掘，希望可以通过这篇文章来引导各位师傅走向探索新版glibc的道路，也希望各位师傅能够把自己在题目中学到的知识能够总结共享出来，这样既可以加深自己的理解，也可以为对相同内容有疑问的师傅答疑解惑。