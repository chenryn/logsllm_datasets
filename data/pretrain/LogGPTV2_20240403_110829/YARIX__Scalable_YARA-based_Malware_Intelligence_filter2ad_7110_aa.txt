title:YARIX: Scalable YARA-based Malware Intelligence
author:Michael Brengel and
Christian Rossow
YarIx: Scalable YARA-based Malware Intelligence
Michael Brengel and Christian Rossow, 
CISPA Helmholtz Center for Information Security
https://www.usenix.org/conference/usenixsecurity21/presentation/brengel
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.YARIX: Scalable YARA-based Malware Intelligence
Michael Brengel
michael.brengel@cispa.saarland
CISPA Helmholtz Center for Information Security
Christian Rossow
PI:EMAIL
CISPA Helmholtz Center for Information Security
Abstract
YARA is the industry standard to search for patterns in mal-
ware data sets. Malware analysts heavily rely on YARA rules
to identify speciﬁc threats, e.g., by scanning unknown mal-
ware samples for patterns that are characteristic for a certain
malware strain. While YARA is tremendously useful to in-
spect individual ﬁles, its run time grows linearly with the
number of input ﬁles, resulting in prohibitive performance
penalties in large malware corpora.
We present YARIX, a methodology to efﬁciently reveal
ﬁles matching arbitrary YARA rules. In order to scale to large
malware corpora, YARIX uses an inverted n-gram index that
maps ﬁxed-length byte sequences to lists of ﬁles in which
they appear. To efﬁciently query such corpora, YARIX op-
timizes YARA searches by transforming YARA rules into
index lookups to obtain a set of candidate ﬁles that potentially
match the rule. Given the storage demands that arise when
indexing binary ﬁles, YARIX compresses the disk footprint
with variable byte delta encoding, abstracts from ﬁle offsets,
and leverages a novel grouping-based compression methodol-
ogy. This completeness-preserving approximation will then
be scanned using YARA to get the actual set of matching ﬁles.
Using 32M malware samples and 1404 YARA rules, we
show that YARIX scales in both disk footprint and search
performance. The index requires just ≈74% of the space
required for storing the malware samples. Querying YARIX
with a YARA rule in our test setup is ﬁve orders of magnitude
faster than using standard sequential YARA scans.
1 Introduction
As a core part of their threat intelligence, the security industry
closely monitors both known and new malware samples. To
this end, anti-virus and threat intelligence companies heavily
leverage their long-term malware archives to inspect mal-
ware threats. These gigantic malware databases quickly span
hundreds of millions or billions of samples [3]. The security
industry uses these archives to search for patterns of known
malware variants. While not following a strict deﬁnition, a
malware family usually groups together malware ﬁles that
follow the same semantics, e.g., because they share the same
code basis. By monitoring these variants, we learn when a cer-
tain threat has been active, what it aimed for, and ultimately,
indications that manifest the responsible actors. Obtaining
a complete malware picture is fundamentally important to
create accurate threat intelligence reports, and gives valuable
insights into both consumer malware and Advanced Persistent
Threats (APT) [10, 15, 21].
The inherent challenge in this process is to classify mal-
ware samples into variants. To close this gap, YARA [2] has
matured to the community and industry de facto standard to
express patterns that are characteristic for a malware vari-
ant. YARA rules capture structural and semantic patterns of a
malware variant. Such rules determine if a malware sample
matches the known variant, and hence, are a vital driver for
automated malware inspection. YARA signatures help to iden-
tify and classify malware samples based on arbitrary binary
patterns speciﬁed in a YARA-speciﬁc syntax. Analysts create
YARA rules as part of their exploratory threat intelligence and
apply them to sample archives. YARA signature repositories,
both free [33, 40] and commercial, are frequently updated
to keep up with newest threats. To keep up with the rapidly
growing malware ecosystem, analysts also use signature gen-
erators [8, 12] to create these rules. Consequently, a diverse
and ever-changing set of YARA rules has to be (re-)applied
to large and continuously growing sample databases.
Unfortunately, the growing number of new malware sam-
ples (e.g., ≈ 105 of new malware samples daily [3]) is a great
challenge to YARA users. While YARA has a reasonable
runtime performance on small data sets, it does not scale to
larger data sets. For example, applying a standard YARA sig-
nature on 32M malware samples takes multiple days, and this
runtime increases linearly with the number of samples. While
parallelism mitigates the problem to a certain extent, it does
not solve the need to scan each and every sample regardless of
the YARA rule. This is stark contrast to the need of malware
analysts, who want to efﬁciently scan malware samples using
USENIX Association
30th USENIX Security Symposium    3541
0. YARA Rule
1. Search Term Extraction
2. Candidate Files Generation
3. Candidate Validation
"a.exe" and "exit"
or
or
and
and
"\\x10tes[0-9]" and pe.dll
and
"exit"
"\x10tes" pe.dll
"a.ex"".exe"
inverted
4-gram
index
∩
∩
,
,
∪
∩
,
(cid:62)
Figure 1: YARIX queries an inverted malware ﬁle index with search terms extracted from a YARA rule.
arbitrary YARA rules. Analysts regularly need to (i) adapt
and re-evaluate YARA signatures on large malware data sets,
(ii) efﬁciently search for known rules in new malware corpora,
or (iii) apply and ﬁne-tune ad hoc YARA signatures, e.g., to
quickly reveal the existence of emerging threats. They thus
have to scan for patterns that are not known a priori, showing
the need for an efﬁcient yet generic search methodology.
In this paper, we propose YARIX, the ﬁrst generic YARA
search engine that is both scalable and space efﬁcient. YARIX
ﬁnds ﬁles that match a YARA rule several orders of magnitude
faster than off-the-shelf YARA scans. This performance opti-
mization is achieved by transforming YARA rules into search
terms that can be efﬁciently searched for using an inverted
n-gram index. YARIX parses the YARA rule and extracts all
the n-grams (n consecutive bytes in a search string) contained
in the strings of the rule. YARIX then uses the index to enable
for efﬁcient and sub-linear searches for these terms.
The index is independent from the YARA rules. That is, the
index supports arbitrary new YARA rules without requiring
an update. Index updates are only required when adding new
malware ﬁles to the corpus—a one-time effort per indexed
ﬁle. YARIX is fully compatible to YARA and does not require
modiﬁcations to the YARA standard or rules. It signiﬁcantly
optimizes the YARA search and can handle advanced features
such as regular expressions and library import speciﬁcations.
Furthermore, YARIX returns sound and complete results.
Our exact YARA rule transformation guarantees that queries
return complete results, i.e., all ﬁles that match the search
criteria. To retain soundness, i.e., to reliably rule out false
positives, as a ﬁnal step, we scan the set of candidate ﬁles
returned by querying the inverted index—a superset of all
actually matching ﬁles—with YARA signatures. YARIX thus
reliably replaces traditional YARA scans with an efﬁcient
search strategy, which signiﬁcantly reduces the set of malware
samples that have to be scanned.
YARIX’s back-end, the inverted ﬁle index, extends the gen-
eral idea of an inverted n-gram index [4]. The index consists
of 28·n posting lists, i.e., sets of malware sample IDs that
contain a given n-gram. To reduce the disk footprint of the
index, we employ (i) variable-length encoding, (ii) compress
posting lists using delta encoding, and (iii) propose an over-
approximating grouping-based compression methodology.
We evaluate YARIX by building an index with 4-grams over
32M malware samples. Our compression methods reduce the
index disk footprint effectively. While a naive inverted index
would have a high overhead (e.g., 400% for 232 indexed ﬁles,
due to 4B-wide ﬁle IDs) compared to the sample size, variable
length and delta encoding shrink this overhead to 149.5%.
Grouping reduces this even further to about 74% overhead,
showing a signiﬁcant gain over standard compression. At the
same time, YARIX reduces the runtime to search for YARA
signatures signiﬁcantly. To assess the search performance,
we process 1404 publicly available YARA rules [33] with
YARIX. On average, YARIXis ﬁve orders of magnitude faster
than full sequential YARA search.
To summarize, our contributions are as follows:
• We present YARIX, a fully YARA compatible search
engine that uses an inverted ﬁle index to efﬁciently reveal
all samples matching a given YARA rule.
• We provide a fully-automated methodology that trans-
forms off-the-shelf YARA signatures into search terms
that can be used to efﬁciently query the index, resulting
in sound and complete results.
• We evaluate the effectiveness of space compression algo-
rithms and are able to shrink the index’s disk footprint to
less than the size of the malware samples being indexed.
• We evaluate our prototype based on 32M malware sam-
ples and 1404 YARA rules.1. YARIX reduces the search
time by ﬁve orders of magnitude.
2 Extracting YARA Search Terms
YARIX receives a YARA rule as input and utilizes a prepro-
cessed inverted (malware) ﬁle index to efﬁciently search for
all indexed ﬁles matching this rule. At the same time, YARIX
1The YARIX reference implementation can be obtained at https://
github.com/mbrengel/yarix
3542    30th USENIX Security Symposium
USENIX Association
YARArule foo {
strings :
$str_a = " calc . exe "
$str_b = " IsDebuggerPresent "
$str2_a = / [\/ a -zA -Z0 -9\.]{0 ,64}\. png /
$str2_b = /\ xC7 \ x45 \ xC3 \ x41 [A -Za -z -_ \/\\ ]/
$op_a = { 01 01 01 01 ?? 5? [2 -8] C1 (E ?| F ?) 02 }
$op_b = { F3 AB 88 12 83 (E ?| F ?) 03 F3 AA }
condition :
$op_b
or (2 of $str_ * and 1 of $str2_ * and 1 of $op_ *)
}
Figure 2: YARA Rule Example.
retains the strong capabilities of the feature-rich YARA lan-
guage. To this end, we automatically extract n-grams from
the strings provided by the YARA rule and use the index
according to the logic provided by the rule to ﬁnd a set of
candidate ﬁles that will then be scanned using YARA. This
optimization is done in a completeness-preserving manner,
i.e., we do not miss ﬁles that would be found by standard
YARA. At the same time, we want to extract as much preﬁlter
information as possible to minimize the set of candidate ﬁles
that will be scanned with YARA to improve performance.
This optimization leads to large speedup factor, as the number
of ﬁles that need to be scanned by YARA can be reduced by
multiple orders of magnitude.
and
) and "exit" (found in
Figure 1 shows the general system overview of YARIX
using an exemplary YARA rule. In the ﬁrst step, YARIX parses
the rule to extract the condition expression and its 4-grams
(substrings of size four) of all strings. In the second step,
these 4-grams are searched for in the inverted 4-gram index of
YARIX. For instance, "a.exe" and "exit" is processed by
and ), ".exe"
feeding the 4-grams "a.ex" (found in ﬁle
(found in
) to the index.
The regular expression "\x10tes[0-9]" is—without losing
completeness—simpliﬁed to "\x10tes" (found in
and ).
Some YARA features, such as the expression pe.dll, are
not indexed and thus cannot be further optimized ((cid:62), i.e.,
found in all ﬁles)—again, without loosing completeness. The
resulting sets of ﬁles are intersected according to the logic
dictated by the rule (∪ for or and ∩ for and), which yields the
candidate ﬁles
and . In the third and ﬁnal step, these
candidate ﬁles are validated with the standard YARA tool
which eliminates ﬁle
as the ﬁnal
results.
,
and returns ﬁles
and
In the following, we will describe the details of this opti-
mization process and outline how YARIX supports all YARA
features. We will start with a short introduction into YARA
rules.
2.1 YARA Rules Overview
The YARA framework [2] features complex and feature-rich
ﬁle searches. To this end, YARA deﬁnes its own pattern match-
ing language that relies on common constructs such as strings,
regular expressions and context-sensitive grammars. In addi-
tion, YARA features semantic capabilities, such as checking
the list of exported functions of a Portable Executable ﬁle. Op-
timizing all these features is an impossible endeavor, as they
partially require heavy ﬁle parsing (e.g., imported/exported
functions) or ad hoc computations (e.g., checksums over parts
of the ﬁle). Having said this, YARIX optimizes the most com-
mon YARA language constructs, and supports the remaining
features by considering the full set of indexed ﬁles without
ﬁltering. For a detailed list of the individual YARA language
features and module extensions that YARIX leverages for
its optimizations, we refer to the technical documentation of
YARIX2.
Figure 2 shows an example of a YARA rule named foo.
YARA rules consist of strings and a condition that dictates
the searching logic. The three basic types of strings in YARA
are normal plain strings ($str_a and $str_b), regular expres-
sions ($str2_a and $str2_b) and hex strings ($op_a and
$op_b). Hex strings support wildcard and grouping mecha-
nisms. For example, ?? matches any byte, whereas 5? matches
any byte where the upper nibble is 5. The wildcard expression
[2-8] matches an arbitrary sequence of at least 2 and at most
8 bytes. The group expression (E?|F?) matches any byte
where the upper nibble is either 14 or 15.
The condition of the rule governs the matching logic. Con-
ditions are expressions of boolean type and support standard
logic operators such as and, or and not. The most simple
boolean expression is a string identiﬁer. For example, $op_b