Operating System Kernel
Figure 1: Runtime environment of the tool.
The actual instrumentation of an application is per-
formed by the monitoring daemon, which is a privileged
user-space process. The daemon manages two reposito-
ries: a patch repository and an audit repository. The patch
repository contains the code for instrumenting the moni-
tored applications. The audit repository contains the audit-
ing code to be inserted into an application. The code in both
the audit and the patch repositories is in the form of dy-
namic libraries. By using dynamic libraries, it is possi-
ble to update the code in the libraries while the daemon
is still running. In addition, multiple versions of the li-
braries can exist at the same time.
Figure 1 describes the runtime environment. The mon-
itoring daemon is invoked at system startup time. When a
monitored application is invoked by calling the execve()
system call (step 1, in the ﬁgure), the kernel module inter-
cepts the call, stops the application, and then simulates the
PTRACE TRACEME semantics by setting the process’s par-
ent to the monitoring daemon and stopping the process by
sending a SIGTRAP signal to it. By doing this, it is pos-
sible to achieve non-bypassability without having to mod-
ify the application binaries. We extended the Dyninst API
to support the modiﬁed ptrace attach procedure.
Then, the kernel module notiﬁes the user-space daemon
that a monitored application has started (step 2). The mon-
itoring daemon performs an “attach” operation to the pro-
cess. Then, it consults its conﬁguration ﬁle to locate the
patch and audit libraries that are appropriate for the appli-
cation (step 3). The patch libraries are loaded into the dae-
mon process’s address space and the instrumentation code
in the patch libraries is executed (step 4). The instrumenta-
tion code loads the audit libraries into the application’s ad-
dress space and inserts audit function calls at certain points
in the application’s code. Once the application has been in-
strumented, the daemon “detaches” and resumes the execu-
tion of the instrumented application.
3.2. Auditing Speciﬁcation Language
The language component of the tool supports the devel-
opment of application-speciﬁc audit routines. The devel-
opment of patch and audit libraries is complex and error-
prone. Therefore, a simple language has been developed to
support the instrumentor and to hide the details of the instru-
mentation from the developer of the auditing code. Thus,
the programmer can focus on important issues, such as what
data is needed, where the data should be collected, and what
to do with the data.
Figure 2 gives an overview of the audit routine develop-
ment process. An audit programmer writes an audit routine
for an application in a superset of the C language. The au-
dit routine contains auditing code and speciﬁes the points in
the application where the auditing code is called. A trans-
lator takes the audit routine as input and generates two C
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Audit
Routine
Translator
Audit
Module
Compile
Audit
Library
Patch
Module
Compile
Patch
Library
Figure 2: Off-line procedure.
modules: an auditing module and a patching module. These
two modules are compiled separately into an audit library
and a patch library, respectively.
The challenging part of the off-line component was to
design a simple language that could be easily translated into
C, and, at the same time, that would give enough ﬂexibility
for instrumentation, hiding the details of binary rewriting
from audit programmers. The Dyninst API [3] provides a
rich set of instrumentation primitives, such as variable al-
location, arithmetic operations, if-then-else statement con-
struction, and function replacement. In fact, it is possible
to insert almost arbitrary code at an instrumentation point.
However, this would complicate the translation process, as
it would be necessary to translate the inserted code into dif-
ferent Dyninst API calls. In addition, these primitives are
not uniformly implemented on different platforms. There-
fore, it is desirable to use a minimal set of the primitives to
achieve compatibility and ﬂexibility.
The current tool implementation allows instrumentation
at a function’s entry and exit point only. At an instrumen-
tation point, only a function call can be used. The function
call must declare a subset of the parameters of the instru-
mented function. Experience with the tool so far has shown
that this approach provides enough ﬂexibility in the instru-
mentation of applications.
Figure 3 shows an example audit routine for the Apa-
che web server. The routine contains two sections: an au-
dit section and a patch section. The audit section is com-
posed of the audit functions and associated data structures
(lines 1-20). The patch section speciﬁes which audit func-
tions are called and where they are called (lines 22-26).
The audit section is translated into an auditing mod-
ule, which is then compiled into a shared library. In the
example, the audit section deﬁnes two functions. Func-
tion audit function 1 logs the request URI. Function
audit function 2 logs the mapped path, ﬁle name, and
handler name for the request. Note that both functions use
the parameter of the ap run log transaction func-
tion. Function init is the initialization function for the
shared library, which is called when the audit library is
loaded into an application. In the example, the function is
used to open a log ﬁle.
The patch section is introduced by the keywords “At
Function” followed by a function signature, an optional en-
try declaration, and an optional exit declaration. The func-
tion signature is a function of the application to be instru-
mented. An entry declaration is speciﬁed by the keyword
“entry” followed by a code block. The code block con-
tains the function to be called at the entry point of the in-
strumented function. A similar syntax is used for the exit
declaration. In the example, audit function 1 is in-
serted at the entry point of ap run log transaction
and audit function 2 is inserted at the function’s exit
point.
The patch section is translated into a patching module
that uses the Dyninst API to create code snippets and patch-
ing code. A pseudo-code example of the patching module is
given in Figure 4. The patching module is extracted by the
translator and compiled into a patch library.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
/∗ a u d i t
FILE *fp = NULL;
s e c t i o n ∗ /
void _init()
{
fp = fopen("/var/applogd/apache.log", "a");
}
void audit_function_1(request_rec *r)
{
fprintf(fp, "Original URI: %s\n", r->uri);
fflush(fp);
}
void audit_function_2(request_rec *r)
{
fprintf(fp, "Mapped path %s, file %s, handler %s\n",
r->path_info, r->filename, r->handler);
fflush(fp);
}
/∗ p a t c h s e c t i o n ∗ /
At Function int
ap_run_log_transaction(request_rec *r)
entry { audit_function_1(r); }
exit{ audit_function_2(r); }
Figure 3: Example of the language.
4. Case Studies
The binary rewriting technique has been tested on two
complex real-world applications: Apache and OpenSSH.
Each application is susceptible to one or more attacks that
exploit application-logic errors. For each attack, the audit
data requirements have been identiﬁed, audit routines to
collect the data have been written, and rules for attack de-
tection have been developed. These case studies exemplify
the inadequacies of existing application-level logging and
show how binary rewriting overcomes these problems.
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
i n t o Apache ∗ /
/∗ l o a d t h e a u d i t
load_audit_lib();
/∗ g e n e r a t e a u d i t code s n i p p e t s ∗ /
p1=find_func_entry("ap_run_log_transaction");
p2=find_func_exit("ap_run_log_transaction");
i n s t r u m e n t e d f u n c . ∗ /
/∗ 0 : 1 s t p a r a m e t e r o f
param = new func_param(0);
func_1 = find_function("audit_function_1");
call_1 = new func_call(func_1, param);
func_2 = find_function("audit_function_2");
call_2 = new func_call(func_2, param);
r i g h t p l a c e s ∗ /
/∗ i n s e r t
insert_snippet(p1, call_1);
insert_snippet(p2, call_2);
l i b r a r y
s n i p p e t s a t
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
Figure 4: Example of pseudo-code of the patching library.
4.1. Apache
According to the NetCraft survey (http://www.net-
craft.com/survey/), Apache is used in 67.70% of
the Internet web servers as of August, 2004. Because of its
wide deployment, Apache is the target of various types of
attacks. Some of these attacks can be detected by examin-
ing the network trafﬁc directed to the server. Other attacks
can be detected by analyzing the application-level audit-
ing produced by the application.
mod log config,
mod log referer,
Apache’s logging is provided by several modules,
and
i.e.,
mod log agent. In the following sections,
three at-
tacks are presented together with the audit requirement for
each of them. Our analysis found that, in every case con-
sidered, the logging provided by Apache is insufﬁcient for
effective intrusion detection.
4.1.1. CGI Script Source Code Disclosure Attack. The
CGI script source code disclosure attack allows an attacker
to access the source code of a CGI script 1. The problem is
that if a directory has both the WebDAV and the CGI be-
havior enabled, Apache will incorrectly consider the script
as WebDAV content for an HTTP POST request and send
back the script’s source code in the reply.
In order to detect this attack, it is necessary to know
whether the Apache server is considering a requested URL
to be a CGI script or not. Unfortunately, none of the stan-
dard Apache logging modules provides this information.
Therefore, an auditing routine that logs what handler Apa-
che uses for a request has been developed (see Figure 3,
lines 17-18). Note that, in this case, the instrumented func-
tion is Apache’s logging routine. Thus, each time Apache
performs logging, the auditing functions are executed.
A rule for detecting this attack is: An Apache CGI script
has to be handled by the “cgi-script” handler. Apache
was tested with the developed audit routine and the results
showed that when the attack happened, the handler Apache
used was “dav-handler,” instead of the usual “cgi-script”.
This information allows one to easily detect the attack us-
ing a simple Perl script that analyzes the information pro-
duced by the auditing routine introduced through binary in-
strumentation. Note that, during the attack, Apache’s stan-
dard access log contains an HTTP POST request only. That
is, there is no information to infer that the attack occurred.
4.1.2. Signals to Non-Apache Process Attack. This at-
tack exploits a vulnerability in Apache’s shared memory
scoreboard 2. The attack allows code running with the Apa-
che UID to send a signal (SIGUSR1) to any process as root.
This privilege can be obtained by exploiting a vulnerability
in Apache, particularly in a web-based application that uses
scripting (e.g., PHP and Perl scripts). Any local user with
a legitimate Apache scripting resource can perform this at-
tack. When the target process receives the signal, it will re-
act according to the corresponding signal handler. By de-
fault, the signal will terminate the process.
To detect this attack, the audit data should contain the
process IDs of both the signal sender and the signal re-
ceiver, as well as the signal number. Unfortunately this in-
formation is not provided by the Apache logging facility.
Because Apache sends signals by calling libc’s kill()
function, an audit routine has been developed to log the data
at kill()’s entry point, as shown in Figure 5.
1
2
3
4
5
6
7
8
9
10
void kill_logging(int pid, int sig)
{
int self = getpid();
fprintf(log_fd,
"PROCESS %d KILL (%d) WITH SIG = %d\n",
self, pid, sig);
}
At Function int kill(pid_t pid, int sig)
entry { kill_logging(pid, sig); }
Figure 5: Audit routine for the signal attack.
A rule that detects this attack is: Apache should not send
signals to processes other than its children. We tested this
audit routine by performing the attack and found that the
signal being sent was the alarm signal (SIGALRM), not the
SIGUSR1 as reported by the advisory. By looking into Apa-
che’s source code, we found that the actual signal being
sent depends on a compile-time ﬂag. If Apache is compiled
with OPTIMIZE TIMEOUTS ﬂag, then the signal sent is
SIGALRM, otherwise it is SIGUSR1.
4.1.3. Slow Client Connection DoS Attack. This Denial-
of-Service (DoS) attack is outlined in [28]. The idea is to
1 CVE entry CAN-2002-1156, http://www.cve.mitre.org/
2 CVE entry CAN-2002-0839, http://www.cve.mitre.org/
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
create a TCP connection that is as slow as possible. Be-
cause the server can only handle a limited amount of TCP
connections, an attacker can exhaust all the server resources
without ﬂooding the server. Apache deﬁnes a time limit for
receiving requests and sending out responses. The default
value is 300 seconds, i.e., 5 minutes. Thus, a single request
can tie up the server for about 10 minutes by using both slow
send and slow receive. In addition, Apache supports HTTP
1.1 persistent connections and by default it allows 100 client
requests per connection, with a 15 seconds idle timeout be-
tween two requests. Therefore, a single client connection
can tie up the server for 10 * 100 + 15 * 99 / 60 ≈ 1025
minutes.
The Apache log entries contain the total time for a re-
quest. However, the logging system does not provide ﬁne-
grained information about a request’s reading time, process-
ing time, and result-sending time. The breakdown of the
server cycle time for a request can help to identify the at-