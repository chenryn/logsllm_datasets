# CVE-2021-42287/CVE-2021-42278 Windows域提权漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
这两天Log4j的余波还未过去，就看到windows爆了个提权漏洞，从域用户直接到域控（从此翻身做主人了），趁热学习一下。
## 0x01 环境搭建
###  0x1 域环境
    域环境
    AD：192.168.1.2
    win7：192.168.1.3
###  0x2 域用户配置
**1.创建域用户**
**2.配置域用户远程登陆权限**
这里有个小坑，如果不配置这个设置的话，将无法通过远程桌面访问域内主机，需要配置的点有两个，一个是DC上配置testuser1到Remote Desktop
Users组
第二步是到域内主机上添加testuser1到允许登陆的账户
最终效果如下
## 0x02 漏洞复现及原理分析
###  0x1 python脚本复现
复现完了发现没有能够弹回来shell，去git上看到如下issue，脚本在ubuntuserver上执行的，从目前的结果来看是成功的拿到了DC的ticket
###  0x2 原理分析
**1.Kerberos 基础概念**
复现到这可以看到这个漏洞的核心其实是以一个普通域用户来冒充DC拿到DC的ticket，进而实现对DC的仿冒，完成提权的操作。上述过程的核心是获取DC的ticket，这里简述一下ticket的概念
在域环境中，Kerberos协议被用来作身份认证，上图所示即为一次简单的身份认证流程，具体细节可以参考相关资料，这里仅介绍几个名词：
  * KDC(Key Distribution Center)： 密钥分发中心，里面包含两个服务：AS和TGS
  * AS(Authentication Server)： 身份认证服务
  * TGS(Ticket Granting Server)： 票据授予服务
  * TGT(Ticket Granting Ticket): 由身份认证服务授予的票据，用于身份认证，存储在内存，默认有效期为10小时
> TGT票据包含 Client/TGS Session Key （AS 生成的随机字符串）、 Client Info（PAC？） 和 Timestamp  
>  TGT票据由TGS 密钥(krbtgt 用户的 NTLM Hash)进行加密，用户无法解密。
  * ST(Server Ticket) 服务端票据，用户使用该票据请求对应的服务，通过验证后获得服务访问权限
  * Pass The Ticket： 如果我们能够拿到用户的TGT，并将其导入到内存，就可以冒充该用户获得其访问权限
网上很多版本的kerberos的流程（上面记录的流程）是
1.用户向KDC发起AS_REQ,请求凭据是用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt
hash加密的TGT票据  
2.用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash
加密的TGS票据  
3.用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，就允许用户访问。
上面这个流程看起来没错，却忽略一个最重要的因素，那就是用户有没有权限访问该服务，在上面的流程里面，只要用户的hash正确，那么就可以拿到TGT，有了TGT，就可以拿到TGS，有了TGS，就可以访问服务，任何一个用户都可以访问任何服务。也就是说上面的流程解决了”Who
am i?”的问题，并没有解决 “What can I do?”的问题。
为了解决上面的这个问题，微软引进了PAC，引进PAC之后的kerberos流程变成
用户向KDC发起AS_REQ,请求凭据是用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt
hash加密的TGT票据，TGT里面包含PAC,PAC包含用户的sid，用户所在的组。
1.用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash
加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据，这也是kerberoating能利用的原因，任何一个用户，只要hash正确，可以请求域内任何一个服务的TGS票据，具体内容可以参考[Windows内网协议学习Kerberos篇之TGSREQ&
TGSREP](https://www.anquanke.com/post/id/190625))  
2.用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边询问用户有没有访问权限，域控解密PAC。获取用户的sid，以及所在的组，再判断用户是否有访问服务的权限，有访问权限(有些服务并没有验证PAC这一步，这也是白银票据能成功的前提，因为就算拥有用户hash，可以制作TGS，也不能制作PAC，PAC当然也验证不成功，但是有些服务不去验证PAC，这是白银票据成功的前提）就允许用户访问。
特别说明的是，PAC对于用户和服务全程都是不可见的。只有KDC能制作和查看PAC。
**2.换个说法讲Kerberos流程**
一个 **认证服务器（Authentication Server，简称
AS）：验证Client端的身份（确定你是身份证上的本人），验证通过就会给一张票证授予票证（Ticket Granting Ticket，简称 TGT）给
Client。**  
一个 **票据授权服务器（Ticket Granting Server，简称 TGS）：通过 TGT（AS 发送给 Client 的票）获取访问
Server 端的票（Server Ticket，简称 ST）。ST（Service Ticket）也有资料称为 TGS Ticket。**
**3.漏洞原理**
  * CVE-2021-42278，机器账户的名字一般来说应该以`$`结尾，但AD没有对域内机器账户名做验证。
该漏洞就导致了AS会以签发一个机器名末尾不以$结尾的TGT（伪装域控主机名的TGT）  
正常域控TGT内Client info里的机器名信息比如说时 MachineName$  
该漏洞伪造的域控TGT内的Client info内的机器名信息就是 MachineName（并不合法）  
因为TGT本身是被KDC用TGS 密钥进行加密的，因此当后续用户使用TGT向TGS请求服务票据时TGS是信任TGT内的信息的。
  * CVE-2021-42287，与上述漏洞配合使用，该漏洞核心在于： **当请求服务 ST 的账户没有被 KDC 找到时，KDC 会自动在尾部添加**`**$**` **重新搜索** 。创建与DC机器账户名字相同的机器账户（不以$结尾），账户请求一个TGT后，更名账户，然后通过S4U2self申请TGS Ticket，接着DC在`TGS_REP`阶段，这个账户不存在的时候，DC会使用自己的密钥加密`TGS Ticket`，提供一个属于该账户的`PAC`，然后我们就得到了一个高权限ST。
在请求到TGT之后，攻击者将机器名修改为其他机器名，然后用该TGT向TGS请求S4U2self服务，这里要先理解ST票据生成的流程才能明白攻击得以完成的原因。
**TGS_request 、TGS_reply**
**TGS-REQ（请求）：**  
当TGS服务收到到client请求体KRB_TGS_REQ时，因为TGS端并没有session key，只能先利用TGS 密钥(krbtgt 的 NTLM
Hash)去解TGT部分内容，得到session key，再去解Session key(client
info+时间戳)部分，从而验证该用户是否是AS颁发给该client的。验证通过后，给client回复KRB_TGS_REP给client
**TGS-REP（返回）：**  
TGS 收到请求后，检查 KDC 数据库中是否存在所请求的服务(Service ID)。如果存在，TGS 使用 TGS 密钥(krbtgt 的 NTLM
Hash)解密 TGT，得到 Client/TGS Session Key、timestamp、Client info；同时使用从 TGT 中解密得到的
Client/TGS Session Key去解密 Authenticator2，得到 Client info 和 timestamp。比对
Authenticator2 和TGT 的解密内容以验证通过。
  * TGS 比对 Authenticator2 包含的 Client ID 和 TGT 中的 Client ID
  * 比较时间戳（误差范围在2分钟）