ﬁcation of protocol implementations and attacks, as shown
in Figure 3.
6. DISCUSSION AND RELATED WORK
Starting with the early work of Carlsen [11], a lot of eﬀorts
have been made to formalize security protocol descriptions
or to devise semantics for them [10, 9, 13]. As pointed out by
Abadi [1], how principals check incoming messages is an es-
sential part of protocols, which is often neglected in protocol
narrations.
Accordingly, many approaches from this line of research
have striven to make such checks explicit. The treatments,
however, are often either ad hoc and/or made in a case-by-
case fashion, specialized for the Dolev-Yao style primitives.
Carlsen [11] deﬁnes four primitive security-relevant inter-
nal actions that can be generated from protocol narrations
in a straightforward way. Even so, the actions checkvalue,
which require accompanying type information to each word,
are not always feasible. Caleiroa et al. [10] enumerate rules
to characterize a principal’s view of a message. Checks can
be done on a message that is viewed as “reachable”. The
whole procedure is rather complex, which involves further
concepts such as analyzable position and inner facial pattern
face. Briais and Nestmann [9] identify three types of checks,
which can be reduced to normal equality tests. The core
technical innovation is to saturate a knowledge set ﬁrst us-
ing Analysis rules and then compare it with the knowledge
set obtained by Synthesis rules. The procedure coincides
with the one given in [24] to decide recognizability under
Dolev-Yao model. However, since the Analysis and Synthe-
sis rules are specialized for Dolev-Yao model, it is not clear
how to generalize the results to support algebraic properties
in protocol narrations [30]. In [28, 8] checks are discussed
informally and thus they do not automate this process. Be-
sides, same as in [11] only structured data rather than bit
strings are considered, which raises implementation issues in
practice.
A major drawback of these approaches has been the lack
of an intuitive, yet general, justiﬁcation for such checks in
a protocol narration. Thus, it is far from clear that all nec-
essary checks are properly found in these approaches. Even
though it is claimed in [9] that the maximum checks are
derived from protocol narrations, there is no consensus on
what are the maximum checks.
The main reason for the lack of intuitive justiﬁcations is
that, compared to one’s ability to interpret a message, a
principal’s inability to interpret a message is not well under-
stood. In [17, 28, 5, 19], messages that cannot be interpreted
with the principal’s knowledge are treated as “black-boxes”.
This simpliﬁcation may fail to give a precise semantics to
a protocol, because relationship between those messages,
such as hash(Nb) and Nb in the ASW protocol, could be
missed. In [10], the notion of transparent and opaque mes-
sages resemble our notions of recognizable and unrecogniz-
able terms, respectively. However, the deﬁnition of these no-
tions is sound but not complete in a sense that a transparent
message is recognizable but not vice versa. As an example,
suppose that Alice knows {{Nb}Kbs} and she receive a mes-
sage that is intended to be Nb · Kbs. Then, Nb · Kbs is recog-
nizable, that is, (cid:104){{Nb}Kbs , x}, [Nb · Kbs/x](cid:105) Edy Nb · Kbs.
This is because senc(fst(x), snd(x))σ =Edy {Nb}Kbs holds
iﬀ x =Edy Nb · Kbs. This is usually referred as the “per-
fect encryption” assumption [4]. On the other hand, by the
}(Nb · Kbs) =
deﬁnition of vD(M ) in [10], we have v{{Nb}Kbs
}(Kbs) and hence Nb · Kbs is not
v{{Nb}Kbs
}(Nb); v{{Nb}Kbs
{{Nb}Kbs}-transparent.
We build our work upon the concept of recognizability
[24], which formalizes a principal’s ability/inability to verify
a message. Although it is initially proposed to understand
type ﬂaw attacks, the problem is similar to ours from a cogni-
tive perspective. Nonetheless, for our purpose here, several
extensions are required so as to provide a more ﬁne-grained
characterization of ambiguous terms.
It is fair to mention that the concept of static equivalence
(on frames) in the applied pi calculus [3, 2] is similar in
spirit to our operational equivalence (on markup term sets,
Deﬁnition 3.2). But there is one essential diﬀerence: we dis-
criminate unambiguous (ground term) and ambiguous (free
variable) messages, whereas in static equivalence all mes-
sages are ambiguous. Naturally, the concept observational
equivalence on processes corresponds to that of operational
equivalence on strands.
Only recently, by Chevalier and Rusinowitch [13], has
static equivalence been related to giving semantics to pro-
tocol narrations. To the best of our knowledge, this is the
ﬁrst result, with a convincing justiﬁcation, that ensures all
the possible checks are performed. However, since it only
Note: reﬁned implementation = prudent implementations - type II attacks
Attacks
Type-I Type-II Type-III
Ideal implementation
Prudent implementation
Reﬁned implementation
Coarse implementation
(cid:88)
(cid:88)
(cid:88)
(cid:88)
×
(cid:88)
×
(cid:88)
×
×
×
(cid:88)
Figure 3: Classiﬁcation of protocol implementations and attacks
allows equality checks, it does not support implementation
reﬁnement, as we do here.
7. CONCLUSION AND FUTURE WORK
In this paper, we provide a consensus view of security
protocols for each group of people that amounts to the at-
tacker’s view. Speciﬁcally, we give ideal semantics to pro-
tocol narrations, by rigorously examining a principal’s abil-
ity or inability to cope with potentially ambiguous incoming
messages. The semantics are then used to guide protocol im-
plementations in two complimentary ways. First, we derive
a prudent implementation of a protocol, which performs all
necessary equality checks and prevents type-III attacks. Sec-
ond, we use type-II attacks to further reﬁne a prudent imple-
mentation by performing additional new inequality checks.
As such reﬁnements are not feasible by either the protocol
designers or the protocol veriﬁers alone, we motivate the in-
terplay between protocol design and protocol veriﬁcation via
a semi-automated reﬁnement process.
There are three major limitations of this study. First,
although our results are not specialized for the Dolev-Yao
intruder model, the accuracy of the semantics depends on
how we model the principal’s deduction capabilities. Failing
to model the capabilities properly may result in unrealistic
semantics. Second, the following questions arising in Section
3.3 are not answered:
(i). Under what conditions does there exist a constraint
base of a markup term set (cid:126)T ?
(ii). How to determine and solve a constraint base if it
exists?
Third, to simplify our discussion, we have treated fresh val-
ues (e.g., nonces and timestamps) as invariant data in one’s
initial knowledge. This is unrealistic in practice especially
when a protocol execution involves multiple sessions.
Our future work will be aimed at addressing these limi-
tations. In particular, we plan to investigate the problem
of ﬁnding and solving constraint bases under more general
equational theories. Besides, to overcome the inability of
coping with fresh values, we will introduce a new event/node
in extended strands; this would not aﬀect our main results
signiﬁcantly.
8. REFERENCES
[1] M. Abadi. Security protocols and their properties. In
Foundations of Secure Computation, NATO Science
Series, pages 39–60. IOS Press, 2000.
[2] M. Abadi and V. Cortier. Deciding knowledge in
security protocols under equational theories. Theor.
Comput. Sci., 367(1):2–32, 2006.
[3] M. Abadi and C. Fournet. Mobile values, new names,
and secure communication. In POPL ’01: Proceedings
of the 28th ACM SIGPLAN-SIGACT symposium on
Principles of programming languages, pages 104–115,
New York, NY, USA, 2001. ACM.
[4] M. Abadi and M. R. Tuttle. A semantics for a logic of
authentication (extended abstract). In Proceedings of
the tenth annual ACM symposium on Principles of
distributed computing, PODC ’91, pages 201–216, New
York, NY, USA, 1991. ACM.
[5] A. Armando, D. A. Basin, M. Bouallagui,
Y. Chevalier, L. Compagna, S. M¨odersheim,
M. Rusinowitch, M. Turuani, L. Vigan`o, and
L. Vigneron. The aviss security protocol analysis tool.
In CAV ’02: Proceedings of the 14th International
Conference on Computer Aided Veriﬁcation, pages
349–353, London, UK, 2002. Springer-Verlag.
[6] N. Asokan, V. Shoup, and M. Waidner. Asynchronous
protocols for optimistic fair exchange. In Security and
Privacy, 1998. Proceedings. 1998 IEEE Symposium
on, pages 86 –99, May 1998.
[7] B. Blanchet. Automatic veriﬁcation of
correspondences for security protocols. J. Comput.
Secur., 17(4):363–434, 2009.
283:333–380, June 2002.
[23] Z. Li and W. Wang. Rethinking about type-ﬂaw
attacks. In GLOBECOM 2010, pages 1 –5, 2010.
[24] Z. Li and W. Wang. Deciding recognizability under
dolev-yao intruder model. In M. Burmester,
G. Tsudik, S. Magliveras, and I. Ilic, editors,
Information Security, volume 6531 of Lecture Notes in
Computer Science, pages 416–429. Springer Berlin /
Heidelberg, 2011.
[8] C. Bodei, M. Buchholtz, P. Degano, F. Nielson, and
H. R. Nielson. Static validation of security protocols.
J. Comput. Secur., 13(3):347–390, 2005.
[25] G. Lowe. An attack on the needham-schroeder
public-key authentication protocol. Inf. Process. Lett.,
56:131–133, November 1995.
[9] S. Briais and U. Nestmann. A formal semantics for
[26] G. Lowe. Breaking and ﬁxing the needham-schroeder
protocol narrations. Theor. Comput. Sci.,
389(3):484–511, 2007.
public-key protocol using fdr. In TACAs ’96, pages
147–166, 1996.
[10] C. Caleiro, L. Vigan`o, and D. Basin. On the semantics
[27] G. Lowe. Some new attacks upon security protocols.
of alice&bob speciﬁcations of security protocols.
Theor. Comput. Sci., 367(1):88–122, 2006.
[11] U. Carlsen. Generating formal cryptographic protocol
speciﬁcations. In Proceedings of the 1994 IEEE
Symposium on Security and Privacy, SP ’94, pages
137–146, Washington, DC, USA, 1994. IEEE
Computer Society.
[12] P. Ceelen, S. Mauw, and S. Radomirovi´c.
Chosen-name attacks: An overlooked class of
type-ﬂaw attacks. Electron. Notes Theor. Comput.
Sci., 197:31–43, February 2008.
In Proceedings of the 9th IEEE workshop on Computer
Security Foundations, CSFW ’96, pages 162–,
Washington, DC, USA, 1996. IEEE Computer Society.
[28] G. Lowe. Casper: a compiler for the analysis of
security protocols. J. Comput. Secur., 6(1-2):53–84,
1998.
[29] J. Millen and V. Shmatikov. Constraint solving for
bounded-process cryptographic protocol analysis. In
CCS ’01: Proceedings of the 8th ACM conference on
Computer and Communications Security, pages
166–175, New York, NY, USA, 2001. ACM.
[13] Y. Chevalier and M. Rusinowitch. Compiling and
[30] S. Modersheim. Algebraic properties in alice and bob
securing cryptographic protocols. Inf. Process. Lett.,
110(3):116–122, 2010.
notation. Availability, Reliability and Security,
International Conference on, 0:433–440, 2009.
[14] J. Clark and J. Jacob. A survey of authentication
[31] R. M. Needham and M. D. Schroeder. Using
encryption for authentication in large networks of
computers. Commun. ACM, 21:993–999, December
1978.
[32] D. Otway and O. Rees. Eﬃcient and timely mutual
authentication. SIGOPS Oper. Syst. Rev., 21(1):8–10,
1987.
[33] J. Robinson. Handbook of Automated Reasoning (2
Volume Set). MIT Press, Cambridge, MA, USA, 2001.
[34] D. X. Song, S. Berezin, and A. Perrig. Athena: a novel
approach to eﬃcient automatic security protocol
analysis. J. Comput. Secur., 9(1-2):47–74, 2001.
protocol literature: Version 1.0, 1997.
[15] R. Corin and S. Etalle. An improved constraint-based
system for the veriﬁcation of security protocols. In
Proceedings of the 9th International Symposium on
Static Analysis, pages 326–341, London, UK, 2002.
Springer-Verlag.
[16] C. J. Cremers. Unbounded veriﬁcation, falsiﬁcation,
and characterization of security protocols by pattern
reﬁnement. In CCS ’08: Proceedings of the 15th ACM
conference on Computer and communications security,
pages 119–128, New York, NY, USA, 2008. ACM.
[17] G. Denker and J. Millen. Capsl intermediate language.
In Proceedings of the Workshop on Formal Methods
and Security Protocols — FMSP, 1999.
[18] D. Dolev and A. Yao. On the security of public key
protocols. Information Theory, IEEE Transactions on,
29(2):198–208, Mar 1983.
[19] A. Durante, R. Focardi, and R. Gorrieri. A compiler
for analyzing cryptographic protocols using
noninterference. ACM Trans. Softw. Eng. Methodol.,
9(4):488–528, 2000.
[20] F. Fabrega, J. Herzog, and J. Guttman. Strand spaces:
why is a security protocol correct? In Security and
Privacy, 1998. Proceedings. 1998 IEEE Symposium
on, pages 160 –171, May 1998.
[21] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.
Reasoning About Knowledge, volume 1 of MIT Press
Books. The MIT Press, December 2003.
[22] J. D. Guttman and F. J. Thayer. Authentication tests
and the structure of bundles. Theor. Comput. Sci.,