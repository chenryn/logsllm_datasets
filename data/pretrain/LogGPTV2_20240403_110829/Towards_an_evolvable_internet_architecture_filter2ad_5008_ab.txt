M
A
C:Z
N:Z
B:N:Z
M:B:N:Z
A:M:B:N:Z
yes
no
yes
no
yes
C:Z
–
B:C:Z
–
A:B:C:Z
Table 1: BGPv(N-1) and BGPvN routing entries corresponding to Fig-
ure 4 advertising by proxy leads A and B to route to Z through IPvN do-
main C
routers add this information in their IPvN route advertisements.
The above is an improvement but does not ensure that all possi-
ble IPvN paths to the destination have been considered. For exam-
ple, consider the scenario in Figure 4. For simplicity, we assume
here that the BGPvN protocol uses a path-vector protocol similar
to the current BGP. Here, Z is the non-IPvN destination domain, A,
B and C are IPvN domains and M and O are non-IPvN domains.
Each domain’s BGPv(N-1) entries to Z and their BGPvN entries
are shown in Table 1. With the routing we’ve developed this far,
domain A is ignorant of the path from C to Z (because C does not
lie on A’s BGPv(N-1) path to Z) and hence will not route through C
to Z. To rectify this we propose the following “advertise-by-proxy”
BGPvN rule: an IPvN border router advertises an IPv(N-1) destina-
tion preﬁx if it is the only IPvN domain along the BGPv(N-1) path
from itself to the destination domain. This can be done by having
an IPvN router include a list of “on-behalf-of” IPv(N-1) domains
in its IPvN inter-domain route advertisements. Note that this is ac-
tually a minor change to the above proposal – in addition to its own
IPv(N-1) domain, an IPvN router merely adds a list of additional
IPv(N-1) domains for which it serves as proxy. In making routing
decisions, an IPvN router can now combine this IPv(N-1) level in-
formation with its IPvN information. In our example, one could
simply add the number of (domain-level) hops. Hence, both B and
C would inject route advertisements for Z with distances of 2 and
1 respectively and regular BGPvN inter-domain routing can then
compute routes to Z as normal. Note that effectively, the routing
“distance” in this case is the sum of the (1) BGPvN routing dis-
tance on the vN-Bone and, (2) the domain-level hops between the
IPvN egress and the destination on the IPv(N-1) topology with ties
broken (as in our example) to favor IPvN paths. While this met-
ric is certainly open to adjustment, this would seem to achieve a
good tradeoff between maximizing routing through IPvN domains,
while avoiding excessively long routes in order to do so. Note that
our example here was an easy case because the notion of routing
distance at the BGPvN and BGPv(N-1) level were easily compat-
ible. In general, the appropriate manner in which the two routing
metrics might be combined would have to be determined based on
the speciﬁc BGPvN and BGPv(N-1).
In summary, for a destination in an IPvN domain, routing is ef-
fected using its IPvN address and IPvN routing information. For an
IPvN destination in an IPv(N-1) domain, routing is on the destina-
tion’s IPv(N-1) address using a combination of IPvN and IPv(N-1)
routing information. Thus (under this design!) the requirement on
IPvN that allow smooth transitioning are: (1) hosts must be able to
create temporary and unique IPvN addresses, (2) a temporary ad-
dress should reveal the host’s IPv(N-1) address or the IPvN header
should allow that information to be carried, and (3) IPvN routers
should be able to annotate their route advertisements with IPv(N-
1) topology information.
Note that, unlike in typical overlays, our routing does not guar-
antee a unique egress point to a destination and nor should it. For
example, routes from domain C to Z should exit the vN-Bone at C
while those in B should exit at N. This can lead to route asymme-
try because routes from C will always select the same ingress point
(because the anycast mechanism will always select the closest IPvN
router independent of the destination). Thus, while asymmetry is
not unusual even today, our proposal is likely to exacerbate asym-
metric routing in the early stages of deployment.
3.4 Forwarding
We now brieﬂy review the end-to-end data path taken by a
packet. Assume IPv(N-1) is the current ubiquitously deployed
version of IP, IPvN is the next generation IP and all IPvN routers
form a virtual vN-Bone. We use An−1 to denote the IPv(N-1)
anycast address assigned to the deployment of IPvN. Then,
end-to-end forwarding of an IPvN packet works as follows:
routers to the closest IPvN router, R1.
header with destination An−1.
(cid:127) the source S encapsulates the IPvN packet in an IPv(N-1)
(cid:127) using anycast, the packet is forwarded over legacy IPv(N-1)
(cid:127) R1 strips off the IPv(N-1) header, processes the packet as
needed, looks up the next hop (R2) to the destination us-
ing the vN-Bone forwarding tables, and forwards the packet
to R2, once again encapsulating the packet in an IPv(N-1)
header if required.
(cid:127) this is repeated until the packet reaches the egress IPvN
router which tunnels the packet through to the destination.
In addition, the source, either through conﬁguration or an ARP-
like protocol, discovers whether its ﬁrst hop router supports IPvN
and, if so, does not encapsulate the packet. Similarly, every inter-
mediate router will only invoke encapsulation if its next hop IPvN
router is not an immediate (i.e., physical layer) neighbor. Thus,
as deployment spreads, the use of IPv(N-1) is gradually phased out.
3.5 Discussion
This section described a series of mechanisms that, taken to-
gether, provide a framework for transitioning between successive
generations of IP. Supporting these mechanisms places additional
demands on future generations of routers. Speciﬁcally, an IPvN
router must: (1) participate in the IPv(N-1) unicast and anycast
routing algorithms, (2) perform IPv(N-1) forwarding, (3) partici-
pate in the construction of the virtual vN-Bone network, (4) partic-
ipate in IPvN unicast and anycast routing and ﬁnally, (5) perform
IPvN forwarding.
Participation in IPv(N-1) and IPvN routing and forwarding
seems unavoidable for any transition path and hence the speciﬁc
additions here involve support for anycast routing and the construc-
tion of the virtual IPvN network which, as described here, do not
seem unduly complex.
We stress two crucial features of our framework:
the ﬁrst is
that we do not require that all routers support the above mecha-
nisms; rather, to evolve from IPv(N-1) to IPvN, only IPvN routers
need support the entire suite of mechanisms. This means that our
framework for evolvability is not itself gated by issues of non-
cooperation from ISPs with no interest in deploying IPvN. Second,
we point out that our framework adheres to the general design style
of the existing Internet with no per-client state within the network,
no signiﬁcant complexity on the packet forwarding path, decentral-
ized control and so forth.
Unfortunately, our approach does not assist in the deployment of
architectures that, by deﬁnition, require support from every router
along the path. This includes certain QoS proposals though re-
cent work on supporting such features in overlays might assist in
this regard [19]. Also unclear, is whether the potential routing in-
efﬁciencies due to anycast (at least in the early stages of deploy-
ment), might diminish the usefulness of certain IPvN architectures.
Of particular concern here would be architectures with the primary
goal of improving performance properties such as path loss or de-
lay. However, this is likely to be less of an issue for the (many)
proposals that seek to add IP-level support for security, mobility,
addressing, robustness, and so forth [2, 3, 7, 12, 13, 16, 17, 35–37].
Our discussion in this paper addresses how IPvN packets are
delivered between two IPvN endhosts across networks with lim-
ited support for IPvN. A related open question is whether general
guidelines exist for how an IPvN endhost may inter-operate with an
IPv(N-1) endhost over IPvN. This requires support from the end-
points and, depending on the speciﬁcs of an IPvN, may range in
complexity from simple header translation to more complex trans-
lations of even higher-layer protocols. Depending on their com-
plexity, such translations might be effected by simple NAT-like
functionality in IPvN routers, client-side proxies or special IPvN
transition boxes. A detailed discussion on endhost interoperability
is beyond the scope of this paper; for a relevant discussion, we refer
the interested reader to the work on OCALA [27], a proxy-based
solution for supporting legacy applications over overlay networks.
Finally, it is worth pondering what, in the larger network archi-
tecture, must remain “invariant” in the sense of functionality that
must be retained through successive architectural generations to en-
sure continued evolvability. Examination of our mechanisms would
suggest just two: support for global unicast and anycast routing.
4. DEPLOYING SOURCE-SPECIFIC
MULTICAST
The previous section presented an overall framework for evolv-
ability based on the use of IP Anycast. In this section, we take IP
Multicast as an example of a new IP service and work through its
deployment under this framework. In so doing, we quite deliber-
ately do not attempt to innovate on the details of the multicast pro-
tocols themselves; instead we take existing standards and describe
how our framework might support their deployment.
We focus our discussion on the deployment of source-speciﬁc
multicast. A detailed description of deploying any-source multicast
which uses a somewhat larger suite of protocols (IGMP, MSDP,
MBGP, PIM-SM and PIM-DM), while we believe would follow
along similar lines, is beyond the most masochistic tendencies of
the authors.
Source Speciﬁc Multicast. Source Speciﬁc Multicast (SSM),
a restricted form of the more general IP Multicast service [38],
provides one-to-many packet delivery between a designated source
node and zero or more receivers [39]. As deﬁned by RFC 3569 [40]
and Holbrook [29, 41], source-speciﬁc multicast is implemented
through the combined use of the Internet Gateway Multicast Proto-
col (IGMP) [42] and a reduced form of Sparse Mode PIM (Protocol
Independent Multicast), denoted PIM-SSM. Through IGMP, a Des-
ignated Router (DR) on a local network tracks group membership
on each of its network interfaces and participates in the wide-area
multicast routing on behalf of the endhosts on its network. PIM-
SSM is then used to construct a tree rooted at the source DR to all
receivers’ DRs. For simplicity, we use endhosts to mean their DRs
and focus only on the mechanics of the wide-area routing.
In SSM, a multicast group, called a channel,
is deﬁned by
the combination (S,G) of a multicast group address (G) and the
(cid:127)
(cid:127)
(cid:127)
(cid:127)
r
o
u
t
e
r
R
n
i
n
w
h
i
c
h
c
a
s
e
R
n
u
n
i
c
a
s
t
s
t
h
e
p
a
c
k
e
t
P
3
f
r
o
m
F
i
g
-
a
l
r
e
a
d
y
o
n
t
h
e
d
i
s
t
r
i
b
u
t
i
o
n
t
r
e
e
f
o
r
(
,
G
S
)
o
r
t
h
e
e
g
r
e
s
s
T
h
e
a
b
o
v
e
i
s
r
e
p
e
a
t
e
d
u
n
t
i
l
t
h
e
p
a
c
k
e
t
h
i
t
s
a
n
I
P
v
M
I
P
v
M
r
o
u
t
e
r
n
e
i
g
h
b
o
r
s
t
h
e
n
e
n
c
a
p
s
u
l
a
t
i
o
n
i
s
b
y
p
a
s
s
e
d
.
l
i
v
e
r
y
t
r
e
e
f
o
r
(
,
G
S
)
.
O
n
c
e
a
g
a
i
n
,
i
f
R
1
a
n
d
R
2
a
r
e
i
m
m
e
d
i
a
t
e
I
J
O
N
o
p
e
r
a
t
i
o
n
i
s
t
e
r
m
i
n
a
t
e
d
s
i
n
c
e
R
1
i
s
a
l
r
e
a
d
y
o
n
t
h
e
a
s
t
o
(
P
2
)
i
n
F
i
g
u
r
e
5
d
e
s
t
i
n
a
t
i
o
n
S
o
n
a
n
d
t
h
e
u
n
i
c
a
s
t
s
P
2
t
o
R
2
.
O
t
h
e
r
w
i
s
e
,
-
v
M
B
o
n
e
,
e
n
c
a
p
s
u
l
a
t
e
s
t
h
e
p
a
c
k
e
t
i
n
g
e
n
t
r
y
f
o
r
(
,
G
S
)
t
h
e
n
R
1
l
o
o
k
s
u
p
t
h
e
n
e
x
t
h
o
p
,
s
a
y
R
2
,
m
u
l
t
i
c
a
s
t
f
o
r
w
a
r
d
i
n
g
t
a
b
l
e
.
I
f
t
h
i
s
i
s
R
1
’
s
ﬁ
r
s
t
m
u
l
t
i
c
a
s
t
r
o
u
t
-
R
1
s
t
r
i
p
s
o
f
f
t
h
e
o
u
t
e
r
I
P
v
4
h
e
a
d
e
r
,
a
n
d
a
d
d
s
(
,
G
S
C
,
)
t
o
i
t
s
l
i
v
e
r
s
t
h
i
s
P
I
M
I
J
O
N
m
e
s
s
a
g
e
t
o
R
1
,
t
h
e
I
P
v
M
c
l
o
s
e
s
t
t
o
C
.
D
e
s
i
g
n
a
t
e
d
R
o
u
t
e
r
r
a
t
h
e
r
t
h
a
n
C
i
t
s
e
l
f
.
A
n
y
c
a
s
t
r
o
u
t
i
n
g
s
o
u
r
c
e
s
h
o
w
n
a
d
d
r
e
s
s
d
e
n
o
t
e
d
a
s
C
w
o
u
l
d
b
e
t
h
e
I
P
a
d
d
r
e
s
s
o
f
a
s
p
a
c
k