pointer. The program transformations in this paper fall in the
ﬁrst category; these assist developers in writing secure code
as they are coding, similar to refactorings. A few hardware
based approaches have explored non-executable stacks, e.g.,
Linux Openwall project [49], but it requires the OS kernel to
be patched. Other approaches have split the control and data
stack [66], but it is hard to calculate the function return address.
Besides, these approaches focus on stack-based buffer overﬂow
only. Most dynamic analysis solutions fall in the third or
the fourth categories. Array bounds checking approaches [29],
[30], [35], [37] provide better protection, but these have high
performance overhead. Some code pointer integrity checking
approaches, such as StackGuard [12], PointGuard [11], and
ProPolice [17], use markers (canaries) to check for buffer
integrity; others store the copy of the return address in a
safe place, e.g., Stack Shield [61] and GMM [39]. However,
133133133
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:01:43 UTC from IEEE Xplore.  Restrictions apply. 
these tools provide a partial solution [64] that can be cir-
cumvented [6]. The performance overhead is lower but still
signiﬁcant.
B. Safe Library Replacement Transformation
Bartaloo and colleagues’ [3] libsafe library and the GMM
library [39] are dynamically loaded libraries that replace
unsafe library functions. These use the LD_PRELOAD feature to
dynamically load the libraries. Once preloaded by a vulnerable
process, the libraries intercept all C library functions, and
allows functions to execute only if the arguments respect their
bounds. These approaches work as binary patches and the ap-
plication does not have to be recompiled. The SAFE LIBRARY
REPLACEMENT transformation allows the developer to add
similar protection at source code level; they have the additional
advantage of allowing a developer to understand and learn how
to write secure code. They are similar to refactorings [20],
but they are security-oriented program transformations [24],
[25] that push refactorings beyond behavior preservation. Most
importantly, they introduce actual solutions to buffer overﬂow
as opposed to patches that only cover potential overﬂow
vulnerabilities in source code, but do not actually ﬁx them.
The SAFE LIBRARY REPLACEMENT transformation is not
limited to preventing buffer overﬂows. The REPLACE ARITH-
METIC OPERATOR transformation [7] replaces an arithmetic
operation in a C program with a call
to a safe library
function that correctly handles integer overﬂow and underﬂow.
SQL injection attacks can be prevented by replacing all in-
stances of string concatenation based SQL queries with SQL
PreparedStatement [4], [16], [58]
C. Safe Type Replacement Transformation
SAFE TYPE REPLACEMENT replaces an unsafe datatype
with a safe data structure [23], [26]. Another approach to
replace unsafe types is explored by the Gemini tool [14].
Interestingly, Gemini is the only program transformation ap-
proach to introduce protection against buffer overﬂow. Gemini,
written in TXL [9], transforms all stack-allocated buffers in
a C program to heap-allocated buffers, because exploiting a
heap overﬂow is more difﬁcult. But it does not remove the
actual vulnerabilities. Some approaches that explored new C
dialects, most notably CCured [8] and Cyclone [34], combined
static analysis and runtime checks: these checked source code
for safety and added runtime checks where safety cannot
be guaranteed statically. Both require manual
intervention
in the form of annotations and source code changes. Both
are C dialects; on the contrary, SAFE TYPE REPLACEMENT
introduces an automated protection that is also pure C.
Many options of safe library and safe data structure are
available. Table I lists some safe library options. Some of
these safe functions trim the resultant destination buffer to ﬁt
its size [32], [45], while other functions dynamically resize
the destination buffer [33], [43]. Some examples of safe data
structures are stralloc data structure used in qmail [26], sm_str_s
data structure used in MeTA1 [1], and the data structure
described by Narayanan [47].
VI. FUTURE WORKS AND CONCLUSION
Why do we need another research work on buffer overﬂow?
Despite the extensive research on detecting and ﬁxing buffer
overﬂows, there continues to be a lot of overﬂow vulnerabili-
ties that are reported even in mature software. Studies have also
revealed that the detection tools are not used in practice and the
overhead of manually ﬁxing the detected vulnerabilities is too
much. Our program transformation based approach naturally
ﬁts into the programming chore, much like the refactoring
tools. Therefore, these tools have a better chance to be adopted.
We provide the power tools missing from developers’ toolkit.
We made several design decisions while implementing the
transformations, e.g., which library to use as alternatives, or
which safe data type to use. The choices are all supported by
latest research; but we plan to validate these decisions with
usability studies in future.
Our transformation based approach improves security, but
has a more signiﬁcant
impact on improving dependability
since the transformations can be applied as a batch to ﬁx the
root cause behind buffer overﬂows. The transformations are
supported by sophisticated analyses and empirical data that
they do not break original programs. They are not silver bullets,
but have nearly the same effect on ﬁxing the targeted root
causes.
VII. ACKNOWLEDGEMENTS
We thank Paul Adamczyk, Ralph Johnson, Jeffrey Overbey,
and the anonymous reviewers. This work was supported by the
NSF grants CCF-1217271 and CCF-1340124.
REFERENCES
[1] C. Aßmann. MeTA1 README. Technical report, Sendmail Inc., Jan
2007.
[2] D. Babic and A. Hu. Calysto: scalable and precise extended static
In ICSE ’08, pages 211–220, New York, NY, USA, 2008.
checking.
ACM.
[3] A. Baratloo, N. Singh, and T. Tsai. Transparent run-time defense against
stack-smashing attacks. In 2000 USENIX Annual Technical Conference:
San Diego, CA, USA, 2000.
[4] P. Bisht, A. P. Sistla, and V. Venkatakrishnan. Automatically preparing
safe SQL queries. In FC ’10, pages 272–288, Berlin, Heidelberg, 2010.
Springer-Verlag.
[5] Bugtraq ID 18331. LibTIFF tiff2pdf remote buffer overﬂow vulnera-
bility.
http://www.securityfocus.com/bid/18331, 2006.
[6] Bulba and Kil3r. Bypassing StackGuard and Stack Shield. Phrack
Magazine, 10(56):File 5, 2000.
[7] Z. Coker and M. Haﬁz. Program transformations to ﬁx C integers. In
[8]
[9]
ICSE ’13, pages 792–801, Piscataway, NJ, USA, 2013. IEEE Press.
J. Condit, M. Harren, S. McPeak, G. Necula, and W. Weimer. CCured
in the real world. In PLDI ’03, pages 232–244, New York, NY, USA,
2003. ACM.
J. R. Cordy. Source transformation, analysis and generation in TXL.
In PEPM ’06, pages 1–11. ACM, 2006.
[10] P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Miné, D. Monniaux,
and X. Rival. The ASTRéE analyzer. In PLDI ’05, volume 3444 of
Lecture Notes in Computer Science, pages 21–30. Springer, 2005.
[11] C. Cowan, S. Beattie, J. Johansen, and P. Wagle.
Protecting pointers from buffer overﬂow vulnerabilities.
SECURITY Symposium ’03, pages 91–104. USENIX, Aug. 2003.
PointGuardTM:
In USENIX
134134134
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:01:43 UTC from IEEE Xplore.  Restrictions apply. 
[12] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier,
P. Wagle, Q. Zhang, and H. Hinton. StackGuard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks. In USENIX SECU-
RITY Symposium ’98. USENIX, 1998.
[13] C. Cowan, P. Wagle, C. Pu, S. Beattie, and J. Walpole. Buffer overﬂows:
Attacks and defenses for the vulnerability of the decade. In DISCEX
’00). IEEE Computer Society Press, Jan. 2000.
[14] C. Dahn and S. Mancoridis. Using program transformation to secure C
programs against buffer overﬂows. In WCRE ’03, page 323, Washington
DC, USA, 2003. IEEE Comp. Society.
[15] N. Dor, M. Rodeh, and S. Sagiv. CSSV: Towards a realistic tool for
statically detecting all buffer overﬂows in C. In PLDI ’03, pages 155–
167. ACM, 2003.
[16] F. Dysart and M. Sherriff. In ISSRE ’08.
[17] H. Etoh. GCC extension for protecting applications from stack-
http://www.research.ibm.com/trl/projects/security/
smashing attacks.
ssp/, 2000.
[18] D. Evans and D. Larochelle.
Improving security using extensible
lightweight static analysis. IEEE Software, 19:42–51, January 2002.
[19] F. Cavalier III.
Libmib allocated string functions.
mibsoftware.com/libmib/astring/.
http://www.
[20] M. Fowler. Refactoring: Improving The Design of Existing Code.
Addison-Wesley, Jun 1999.
[21] V. Ganapathy, S. Jha, D. Chandler, D. Melski, and D. Vitek. Buffer
overrun detection using linear programming and static analysis. In CCS
’03, pages 345–354. ACM, 2003.
[22] B. Hackett, M. Das, D. Wang, and Z. Yang. Modular checking for
buffer overﬂows in the large. In ICSE ’06, pages 232–241, New York,
NY, USA, 2006. ACM.
[23] M. Haﬁz. Security architecture of Mail Transfer Agents. Master’s
thesis, University of Illinois at Urbana-Champaign, 2005.
[24] M. Haﬁz. Security On Demand. PhD thesis, University of Illinois at
Urbana-Champaign, 2010.
[25] M. Haﬁz, P. Adamczyk, and R. Johnson. Systematically eradicating
data injection attacks using security-oriented program transformations.
In ESSoS ’09, Feb 2009.
[26] M. Haﬁz and R. Johnson. Evolution of the MTA architecture: The
impact of security. Software—Practice and Experience, 38(15):1569–
1599, Dec 2008.
[27] M. Haﬁz, J. Overbey, F. Behrang, and J. Hall. OpenRefactory/C: An
infrastructure for building correct and complex C transformations. In
WRT ’13, 2013.
[28] B. Hardekopf and C. Lin. The ant and the grasshopper: Fast and
accurate pointer analysis for millions of lines of code. In PLDI ’07,
pages 290–299, New York, NY, USA, 2007. ACM.
[29] R. Hastings and B. Joyce. Purify: Fast detection of memory leaks and
access errors. In USENIX ’92, pages 125–136, 1992.
[30] E. Haugh and M. Bishop. Testing C programs for buffer overﬂow
[31]
[32]
vulnerabilities. In NDSS. The Internet Society, 2003.
International Organization for Standardization. ISO/IEC 24731: Speci-
ﬁcation For Secure C Library Functions. 2004.
International Organization for Standardization.
Programming Languages — C. Sep 2007.
ISO/IEC 14882. C++ std::string.
[33]
[34] T. Jim, J. G. Morrisett, D. Grossman, M. Hicks, J. Cheney, and Y. Wang.
Cyclone: A safe dialect of C. In USENIX ATEC ’02, pages 275–288,
Berkeley, CA, USA, 2002. USENIX Association.
ISO/IEC 9899:TC3:
[35] R. Jones and P. Kelly. Bounds checking for C. http://www.doc.ic.ac.
uk/~phjk/BoundsChecking.html, July 1995.
[64]
[36] W. Le and M. L. Soffa. Marple: A demand-driven path-sensitive buffer
In FSE-16, pages 272–282, New York, NY, USA,
overﬂow detector.
2008. ACM.
[37] K. Lhee and S. Chapin.
Type-assisted dynamic buffer overﬂow
detection. In USENIX 2002, pages 81–88, 2002.
[38] L. Li, C. Cifuentes, and N. Keynes. Practical and effective symbolic
analysis for buffer overﬂow detection. In FSE ’10, pages 317–326, New
York, NY, USA, 2010. ACM.
135135135
[39] D. Libenzi. Guarded memory move (GMM), Feb. 10 2004.
[40] C. Liu, J. Yang, L. Tan, and M. Haﬁz. R2Fix: Automatically generating
bug ﬁxes from bug reports. In ICSE ’13, pages 282–291, 2013.
[41] M. Lovell. Repel attacks on your code with the Visual Studio 2005
safe C and C++ libraries. MSDN Magazine, May 2005.
[42] M. Méndez-Lojo, A. Mathew, and K. Pingali. Parallel inclusion-based
points-to analysis. In OOPSLA ’10, pages 428–443. ACM, 2010.
[43] M. Messier and J. Viega. Safe C string library v1.0.3.
http://www.zork.org/safestr/safestr.html.
[44] Microsoft Developer Network. Using the Strsafe.h functions.
[45] T. Miller and T. de Raadt. strlcpy and strlcat — Consistent, safe,
string copy and concatenation. In USENIX ’99, 1999.
[46] S. Nagarakatte, J. Zhao, M. Martin, and S. Zdancewic. Softbound:
highly compatible and complete spatial memory safety for c. In PLDI
’09, pages 245–258, New York, NY, USA, 2009. ACM.
[47] A. Narayanan. Design of a safe string library for C. Software—Practice
and Experience, 24(6):565–578, 1994.
[48] National Institute of Standards and Technology (NIST). SAMATE -
Software Assurance Metrics and Tool Evaluation, 2012.
[49] Openwall Project. Linux kernel patch from the Openwall project. http:
//www.openwall.com/linux/.
[50] S. Özkan.
CVE Details: The ultimate security vulnerability
http://www.cvedetails.com/
datasource—Vulnerabilities By Type.
vulnerabilities-by-types.php.
[51] K. Pingali, D. Nguyen, M. Kulkarni, M. Burtscher, M. Hassaan,
R. Kaleem, T. Lee, A. Lenharth, R. Manevich, M. Méndez-Lojo,
D. Prountzos, and X. Sui. The Tao of parallelism in algorithms.
In
PLDI ’11, pages 12–25. ACM, 2011.
qmail home page. Maintained by Daniel Julius Bernstein. http://cr.yp.
to/qmail.html.
[52]
[53] M. Rinard, C. Cadar, and H. H. Nguyen. Exploring the acceptability
envelope. In OOPSLA ’05, pages 21–30. ACM, 2005.
[54] R. Rugina and M. Rinard. Symbolic bounds analysis of pointers, array
indices, and accessed memory regions. In PLDI ’00, pages 182–195,
New York, NY, USA, 2000. ACM.
[55] O. Ruwase and M. Lam. A practical dynamic buffer overﬂow detector.
In DSSS 11, pages 159–169, 2004.
[56] R. Seacord. The CERT C secure coding standard. Addison-Wesley,
2009.
J. Seward and N. Nethercote. Using Valgrind to detect undeﬁned value
errors with bit-precision. In USENIX 2005, year = 2005, pages = 17-
30,.
[57]
[58] S. Thomas, L. Williams, and T. Xie. On automated prepared statement
generation to remove SQL injection vulnerabilities. Inf. Softw. Technol.,
51(3):589–598, Mar. 2009.
[59] US-CERT. National vulnerability database version 2.2.
[60] M. Vakilian, N. Chen, S. Negara, B. A. Rajkumar, B. P. Bailey, and
R. E. Johnson. Use, disuse, and misuse of automated refactorings. In
ICSE ’12, pages 233–243. IEEE, 2012.
[62]
[61] Vendicator. Stack Shield: A stack smashing technique protection tool
for Linux. http://www.angelﬁre.com/sk/stackshield/, 2000.
J. Viega, J. Bloch, T. Kohno, and G. McGraw.
ITS4: A static
vulnerability scanner for C and C++ code. In ACSAC ’00. ACM, 2000.
[63] D. Wagner, J. Foster, E. Brewer, and A. Aiken. A ﬁrst step towards
In NDSS. The
automated detection of buffer overrun vulnerabilities.
Internet Society, 2000.
J. Wilander and M. Kamkar. A comparison of publicly available tools
for dynamic buffer overﬂow prevention. In Proceedings of the Network
and Distributed System Security Symposium, NDSS 2003, San Diego,
California, USA. The Internet Society, 2003.
[65] Y. Xie, A. Chou, and D. Engler. ARCHER: Using symbolic, path-
sensitive analysis to detect memory access errors. SIGSOFT Softw.
Eng. Notes, 28:327–336, September 2003.
J. Xu, Z. Kalbarczyk, S. Patel, and R. Iyer. Architecture support for
defending against buffer overﬂow attacks. In EASY ’02, 2002.
[66]
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:01:43 UTC from IEEE Xplore.  Restrictions apply.