# 【技术分享】手把手教你如何构造office漏洞EXP（第二期）
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
**作者：**[ **维一零** ****](http://bobao.360.cn/member/contribute?uid=32687245)
**稿费：700RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**传送门**
* * *
[**【技术分享】手把手教你如何构造office漏洞EXP（第一期）**
****](http://bobao.360.cn/learning/detail/3003.html)
[**【技术分享】手把手教你如何构造office漏洞EXP（第三期）**
****](http://bobao.360.cn/learning/detail/3049.html)
[**【技术分享】手把手教你如何构造office漏洞EXP（第四期）**](http://bobao.360.cn/learning/detail/3246.html)
**前言**
上一期本人分享了office经典漏洞CVE-2012-0158，演示了如何基于栈缓冲区溢出原理构造触发漏洞的攻击文档。本期分享的漏洞是CVE-2013-3906，也是一个典型的溢出型office文档漏洞。该漏洞的背景带有一定的传奇色彩，从技术框架的开发到军方相关的APT攻击，以及安全公司持续的追踪过程，都具备许多值得深究的意义。下面本文仅对其技术框架进行详解，演示如何基于漏洞原理构造出攻击文档，并进一步拓展演示如何绕过office
2010开启的dep保护机制。
**  
**
**漏洞原理**
这个漏洞发生的位置是OGL.DLL模块，此模块是office用来解析图形图像的动态库，比如一个文档里面如果包含一些图表或者图片，当使用office打开这个文档的时候OGL.DLL就会自动被载入进程空间被调用来解析这些图形元素。而这个漏洞发生的原因是OGL.DLL在解析TIFF这类格式的图片数据时动态计算分配的内存大小，计算结果由于发生整数溢出且没有进行校验，从而导致堆内存缓冲区溢出。漏洞发生过程如下所示：
可以看出关键问题在于文档中包含的这张TIFF格式图片计算size数据的过程，这个过程可以从IDA中的这个子函数找到：
这里展示的是OGL.DLL在对经过JPEG算法压缩过的TIFF格式图片解析时，动态计算压缩数据大小的过程，看得出数据大小主要是由多个数组的数值循环累加而成，而其中每个数组的数值其实代表的是一个压缩块数据的大小。计算完总数据大小后，可以看到函数并没有进行任何检查就马上进行了内存分配，这也是导致此漏洞发生的重要原因，当然其根本原因还在于多个数值叠加后发生了32位整数溢出。此后，进行分配0字节的内存，这个调用将会成功并且返回内存堆块的句柄，只是其堆块内存的容量为0，所以当后面进行数据拷贝的时候，缓冲区就必然会发生溢出，破坏原始堆块的数据结构，这样就导致后面的程序轻易的会发生异常而崩溃。以下是对winword进程开启页堆后运行POC看到的堆内存越界访问，看得出拷贝的目标堆块size为0：
****
**  
**
**构造触发漏洞的POC**
经过上面对漏洞成因的分析，知道漏洞是由于office解析压缩的TIFF图片时计算不严格导致的。为了验证以上的分析并触发漏洞，我们需要往office文档插入一张特殊构造的TIFF图片。这张特殊的图片当然不会是正常的TIFF图片，而是要满足我们前面所说的经过JPEG算法压缩且压缩块size数组叠加后整数溢出。具体地，我们需要参考TIFF文件格式手册，对正常的经JPEG压缩的TIFF图片进行改造，改造过程需要涉及的主要字段为：Compression（压缩标志字段）、StripOffsets（压缩数据偏移数组）和StripByteCounts（压缩数据size数组）、JPEGInterchangeFormat（JPEG压缩格式的数据头SOI）和JPEGInterchangeFormatLength（数据头的长度SOI_SIZE）、ImageLength（图像数据的长度）和RowsPerStrip（压缩块容量），其中，Compression=6（代表使用JPEG压缩），如下图：
而总的size要满足计算结果为32位整数0，总size的计算公式如下：
size=SOI_SIZE+strip_size[1]+strip_size[2]+…+strip_size[n]+n*2+8（SOI_SIZE=JPEGInterchangeFormatLength，n=ImageLength/RowsPerStrip，n
> 1）
根据此公式对size数组数据进行修改，使其累加后能够发生32位整数溢出，如下图所示：
构造好满足条件公式的图片后，将图片嵌入文档中（可以先嵌入一张正常的图片后再替换成构造的图片）保存，之后再通过office打开文档，文档即可华丽地崩溃：
**  
**
**漏洞利用**
至此，我们得到的是一个由于整数溢出导致的堆内存越界拷贝漏洞，异常分配的0字节堆块原本是要用来拷贝SOI数据，现在由于越界拷贝破坏了堆块后面的内存数据导致程序出现异常。那么，为了能够利用这个漏洞来做一些事情，我们的首要目标就是接管程序的控制权，拿到eip。当然，这一步是仁者见仁智者见智，所谓条条道路通罗马，下面就介绍一种可行的方式进行利用。
由于SOI数据在TIFF图片中可控，所以间接的就可以控制越界拷贝的内存数据，而这部分数据是处于堆内存里面，不清楚拷贝数据后破坏了什么样的内存数据结构。因此，通过构造可以预测的内存对象，再借助对象的虚表指针进行跳转来争夺eip是一种比较能够预期的方法。具体地，我在插入TIFF图片之前，先插入一个图表，再插入正常待替换的图片，紧接着再插入一个复制的图表，最后再替换图片为构造好的TIFF图片。这样，相当于在解析TIFF图片的前后，都会解析插入的图表对象：