2016-9, EECS Department, UC Berkeley (2016).
[46] LO, D., CHEN, T., ISMAIL, M., AND SUH, G. E. Run-time
monitoring with adjustable overhead using dataﬂow-guided
ﬁltering. In Proceedings of the International Symposium on
High Performance Computer Architecture (HPCA) (2015).
[47] LUK, C.-K., COHN, R., MUTH, R., PATIL, H., KLAUSER,
A., LOWNEY, G., WALLACE, S., REDDI, V. J., AND HAZEL-
WOOD, K. Pin: building customized program analysis tools
with dynamic instrumentation. In Proceedings of the Confer-
ence on Programming Language Design and Implementation
(PLDI) (2005).
[48] MIJAT, R. Better trace for better software: introducing the new
ARM CoreSight system trace macrocell and trace memory
controller. ARM, White Paper (2010).
[49] MOON, H. Hardware techniques against memory corruption
attacks. PhD thesis, Seoul National University, 2017.
[50] NAGARAJAN, V., KIM, H.-S., WU, Y., AND GUPTA, R. Dy-
namic information ﬂow tracking on multicores. In Proceedings
of the Workshop on Interaction Between Compilers and Com-
puter Architectures (INTERACT) (2008).
[51] NAGARAKATTE, S., MARTIN, M. M., AND ZDANCEWIC,
S. Watchdog: hardware for safe and secure manual memory
management and full memory safety. In Proceedings of the
International Symposium on Computer Architecture (ISCA)
(2012).
[52] NAGARAKATTE, S., MARTIN, M. M., AND ZDANCEWIC, S.
Watchdoglite: hardware-accelerated compiler-based pointer
checking. In Proceedings of the International Symposium on
Code Generation and Optimization (CGO) (2014).
[53] NAGARAKATTE, S., ZHAO, J., MARTIN, M. M., AND
ZDANCEWIC, S. Softbound: highly compatible and complete
spatial memory safety for C. In Proceedings of the Confer-
ence on Programming Language Design and Implementation
(PLDI) (2009).
822    29th USENIX Security Symposium
USENIX Association
[54] NEWSOME, J., AND SONG, D. Dynamic taint analysis: auto-
matic detection, analysis, and signature generation of exploit
attacks on commodity software. In Proceedings of the Network
and Distributed Systems Security Symposium (NDSS) (2005).
[55] OLEKSENKO, O., KUVAISKII, D., BHATOTIA, P., FELBER,
P., AND FETZER, C. Intel MPX explained: a cross-layer anal-
ysis of the Intel MPX system stack. In Proceedings of the
ACM on Measurement and Analysis of Computing Systems
(SIGMETRICS) (2018).
[56] OZDOGANOGLU, H., VIJAYKUMAR, T., BRODLEY, C. E.,
KUPERMAN, B. A., AND JALOTE, A. SmashGuard: a hard-
ware solution to prevent security attacks on the function return
address. IEEE Transactions on Computers (TC) 55, 10 (2006).
[57] OZSOY, M., DONOVICK, C., GORELIK, I., ABU-GHAZALEH,
N., AND PONOMAREV, D. Malware-aware processors: a
In Pro-
framework for efﬁcient online malware detection.
ceedings of the International Symposium on High Performance
Computer Architecture (HPCA) (2015).
[58] PAPPAS, V., POLYCHRONAKIS, M., AND KEROMYTIS, A. D.
Transparent ROP exploit mitigation using indirect branch trac-
In Proceedings of the USENIX Security Symposium
ing.
(2013).
[59] QIN, F., WANG, C., LI, Z., KIM, H.-S., ZHOU, Y., AND WU,
Y. Lift: a low-overhead practical information ﬂow tracking
system for detecting security attacks. In Proceedings of the In-
ternational Symposium on Microarchitecture (MICRO) (2006).
[60] REDDI, V. J., SETTLE, A., CONNORS, D. A., AND COHN,
R. S. Pin: a binary instrumentation tool for computer architec-
ture research and education. In Proceedings of the Workshop
on Computer Architecture Education (WCAE) (2004).
[61] ADVANCED MICRO DEVICES. AMD64 architecture pro-
grammer’s manual volume 2: system programming. https:
//support.amd.com/techdocs/24593.pdf, 2006.
[62] ARM.
ARM security technology, building a se-
http:
system using TrustZone
cure
//infocenter.arm.com/help/topic/com.arm.
doc.prd29-genc-009492c/PRD29-GENC-009492C_
trustzone_security_whitepaper.pdf, 2009.
technology.
[63] DIGILENT’S ZEDBOARD ZYNQ FPGA. Development
http://www.digilentinc.com/
board documentation.
Products/Detail.cfm?Prod=ZEDBOARD/, 2017.
[64] INTEL CORPORATION.
Intel
trusted execution tech-
https://www.intel.com/content/dam/
nology.
www/public/us/en/documents/white-papers/
trusted-execution-technology-security-paper.pdf,
2006.
[65] INTEL CORPORATION.
Introduction
protection
tel memory
//software.intel.com/en-us/articles/
introduction-to-intel-memory-protection-extensions/,
2013.
extensions.
to
In-
https:
[67] INTEL CORPORATION.
Control-ﬂow enforce-
https://software.
preview.
technology
ment
intel.com/sites/default/files/managed/4d/2a/
control-flow-enforcement-technology-preview.pdf,
2017.
[68] MICROSOFT CORPORATION. Microsoft security develop-
ment lifecycle. https://www.microsoft.com/en-us/sdl/
process/verification.aspx/, 2017.
[69] NANGATE, SUNNYVALE, CALIFORNIA. 45nm open cell li-
brary.
[70] SCHNEIDER, F. B. Enforceable security policies. ACM Trans-
actions on Information and System Security (TISSEC) 3, 1
(2000).
[71] SCHUMILO, S., ASCHERMANN, C., GAWLIK, R., SCHINZEL,
S., AND HOLZ, T. kAFL: hardware-assisted feedback fuzzing
for OS kernels. In Proceedings of the USENIX Security Sym-
posium (2017).
[72] SCHUSTER, F., TENDYCK, T., PEWNY, J., MAASS, A.,
STEEGMANNS, M., CONTAG, M., AND HOLZ, T. Evaluating
the effectiveness of current anti-ROP defenses. In Proceed-
ings of the International Symposium on Research in Attacks,
Intrusions and Defenses (RAID) (2014).
[73] SINGH, B., EVTYUSHKIN, D., ELWELL, J., RILEY, R., AND
CERVESATO, I. On the detection of kernel-level rootkits us-
ing hardware performance counters. In Proceedings of the
Asia Conference on Computer and Communications Security
(AsiaCCS) (2017).
[74] SINHA, K., AND SETHUMADHAVAN, S. Practical memory
safety with REST. In Proceedings of the International Sympo-
sium on Computer Architecture (ISCA) (2018).
[75] SINNADURAI, S., ZHAO, Q., AND
runtime
Transparent
against malicious
W.
tion
http://citeseerx.ist.psu.edu/viewdoc/download?
doi=10.1.1.120.5702&rep=rep1&type=pdf, 2008.
shadow stack:
return
FAI WONG,
protec-
address modiﬁcations.
[76] SONG, C., MOON, H., ALAM, M., YUN, I., LEE, B., KIM, T.,
LEE, W., AND PAEK, Y. HDFI: hardware-assisted data-ﬂow
isolation. In Proceedings of the Symposium on Security and
Privacy (S&P) (2016).
[77] STEPHENS, N., GROSEN, J., SALLS, C., DUTCHER, A.,
WANG, R., CORBETTA, J., SHOSHITAISHVILI, Y., KRUEGEL,
C., AND VIGNA, G. Driller: augmenting fuzzing through se-
lective symbolic execution. In Proceedings of the Network and
Distributed System Security Symposium (NDSS) (2016).
[78] SUH, G. E., LEE, J. W., ZHANG, D., AND DEVADAS, S. Se-
cure program execution via dynamic information ﬂow tracking.
In Proceedings of the International Conference on Architec-
tural Support for Programming Languages and Operating Sys-
tems (ASPLOS) (2004).
[79] SZEKERES, L., PAYER, M., WEI, T., AND SONG, D. SoK:
Eternal war in memory. In Proceedings of the Symposium on
Security and Privacy (S&P) (2013).
[66] INTEL CORPORATION. Intel 64 and IA-32 architectures soft-
ware developer’s manual. System Programming Guide, Part
3C (2016).
[80] THOZIYOOR, S., MURALIMANOHAR, N., AHN, J. H., AND
JOUPPI, N. P. CACTI 5.1. Tech. rep., HPL-2008-20, HP Labs,
2008.
USENIX Association
29th USENIX Security Symposium    823
[81] VENKATARAMANI, G., DOUDALIS, I., SOLIHIN, Y., AND
PRVULOVIC, M. Flexitaint: A programmable accelerator for
In Proceedings of the Interna-
dynamic taint propagation.
tional Symposium on High Performance Computer Architec-
ture (HPCA) (2008).
[82] VENKATARAMANI, G., ROEMER, B., SOLIHIN, Y., AND
PRVULOVIC, M. Memtracker: efﬁcient and programmable
support for memory access monitoring and debugging. In Pro-
ceedings of the International Symposium on High Performance
Computer Architecture (HPCA) (2007).
[83] WATERMAN, A., LEE, Y., PATTERSON, D. A., AND
ASANOVI ´C, K. The RISC-V instruction set manual, volume i:
Base user-level ISA. Tech. Report UCB/EECS-2011-62, EECS
Department, UC Berkeley (2011).
[84] YUAN, P., ZENG, Q., AND DING, X. Hardware-assisted ﬁne-
In Proceedings of the
grained code-reuse attack detection.
International Symposium on Research in Attacks, Intrusions
and Defenses (RAID) (2015).
[85] ZALEWSKI, M. American fuzzy lop (AFL) fuzzer. http:
//lcamtuf.coredump.cx/afl/, 2017.
[86] ZHANG, M., QIAO, R., HASABNIS, N., AND SEKAR, R. A
platform for secure static binary instrumentation. In Proceed-
ings of the International Conference on Virtual Execution En-
vironments (VEE) (2014).
[87] ZHOU, B., GUPTA, A., JAHANSHAHI, R., EGELE, M., AND
JOSHI, A. Hardware performance counters can detect mal-
ware: myth or fact? In Proceedings of the Asia Conference on
Computer and Communications Security (ASIACCS) (2018).
[88] ZHOU, P., QIN, F., LIU, W., ZHOU, Y., AND TORRELLAS,
J.
iWatcher: efﬁcient architectural support for software de-
bugging. In Proceedings of the International Symposium on
Computer Architecture (ISCA) (2004).
[89] ZHOU, P., TEODORESCU, R., AND ZHOU, Y.
HARD:
hardware-assisted lockset-based race detection. In Proceed-
ings of the International Symposium on High Performance
Computer Architecture (HPCA) (2007).
A Appendix
In this appendix, we present the microarchitectural details of PH-
Mon’s Action Unit (AU) design. As discussed in Section 4.1, PHMon
receives the commit log from the RoCC interface and then PHMon
applies the conﬁgured monitoring rules to the commit log to detect
events and perform follow-up actions. Once an MU ﬁnds a match,
the MU sends an activation signal alongside a match packet to
the AU. The match packet consists of an address (MU_addr), data
(MU_data), and an MU identiﬁcation number (MU_id). The MU_addr
contains the address of the instruction in the commit log (i.e., pc_src
element), while MU_data is programmable and can contain the con-
tents of any one of the commit log entries. The MU_id speciﬁes
the index of the MU that triggered the activation signal. The AU
enqueues an incoming match packet from the MU into the Match
Queue while it performs actions for the packets arrived earlier. To
perform actions, as shown in Figure 3, the AU consists of four dis-
tinct microarchitectural components: Conﬁg Units (CFUs), Local
Register File, Arithmetic and Logic Unit (ALU), and Control Unit
(CU). In the next subsections, we explain each of AU’s microarchi-
tectural components in detail.
A.1 Conﬁg Units (CFUs)
In the PHMon design, each MU is paired with a CFU. Each CFU
consists of three main components: an Action Config Table, a
conf_ctr, and a conf_ptr. The Action Config Table contains
the list of actions (programmed by the user) that PHMon should
perform after the MU ﬁnds a match and triggers the activation signal.
The conf_ctr and conf_ptr preserve the index of the total number
of actions and the current action, respectively. Each entry in the Ac-
tion Conﬁg Table, called action description, consists of Type,
In1, In2, Fn, Out, and Data elements (see Figure 3).
Type speciﬁes one of the following four types: ALU operation,
memory operation, interrupt, and skip actions. In case of an ALU
operation, In1 and In2 act as programmable input arguments of the
ALU whereas for memory operations, In1 and In2 are interpreted
as data and address of the memory request. In both cases, In1 and
In2 can be programmed to hold the local register values (maintained
in Local Register File) or an immediate value. The Out element
speciﬁes where the output of the ALU/memory operation is stored.
The Fn element determines the functionality of an ALU operation or
the type of the memory request. The Data element only applies to
an ALU operation as immediate data. Note that in case of a memory
operation, PHMon sends a memory request through the L1 data
cache using the RoCC interface. The interrupt action triggers an
interrupt, which will be handled by the OS. The skip actions provide
the option of early action termination. In this case, when the result
of an ALU operation is equal to zero, the AU will skip the remaining
actions of the current event.
A.2 Local Register File
The Local Register File consists of three dedicated registers for
memory requests and their responses: Mem_addr, Mem_data, and
Mem_resp, and three general-purpose registers: Local_1, Local_2,
and Local_3. Memory operations occur using Mem_addr and
Mem_data registers as the addr and data of the request while the re-
sult gets stored in the Mem_resp register. The user can use Local_1,
Local_2, and Local_3 registers for ALU operations.
A.3 Arithmetic and Logic Unit (ALU)
We include a small ALU in PHMon to support a variety of actions.
The ALU operations are restricted inside PHMon; however, these
operations can be combined with other PHMon’s actions (i.e., mem-
ory operations and interrupts) to provide the user with the capability
to inﬂuence the process’ execution. The input and output arguments
of our ALU (including In1, In2, Fn, and Out) are programmable.
The Fn argument determines the ALU function out of the following
10 different operations: Addition, Subtraction, Logical Shift
Left, Logical Shift Right, Set Less Than, Set Equal, AND,
OR, XOR, and NOP.
A.4 Control Unit (CU)
The CU handles all the tasks related to performing actions. Our CU
consists of a small FSM with three states: ready, wait, and busy.
Depending on the current state of the CU, it performs one or more of
the following tasks: dequeue a match packet from the Match Queue,
update the Local Register File, receive the next action description,
and perform an action. Once all of the listed actions are performed,
the CFU notiﬁes the CU. In this case, the CU enters the ready state,
repeating all of the described tasks for the next element stored in the
Match Queue.
824    29th USENIX Security Symposium
USENIX Association