雷问题的效果一样，会对测试的质量有所提升。山]
2072
---
## Page 2074
备注
测试用例：编辑摘要一输入第二个摘要
wait_for_element_present_ok
steditsummarytextarea
30000
click ok
steditsummarvtextarea
图17-1用户模块的思维导图
此外，应用思维导图将方便你更新文档。当测试人员在执行测试的
时候，他们经常会有一些有趣的测试思路。如果使用传统的测试管
理工具，为了增加一个测试思路可能会涉及许多的界面甚至是一些
向导。但如果你使用思维导图，那么你仅需要在图上增加一个新的
节点。
我曾经成功地通过让整个小组使用思维导图从而增加了测试的覆盖
率。之前我带领一个小组进行一个产品版本的开发，我们接到了许
多新的需求，这些需求马上就要分到各个开发人员和测试人员的手
中。这时候，我让大家每个人为自己所接手的领域画一张思维导
图。紧接着，我们所有小组的成员坐到一起，轮流查看每个领域的
思维导图。这时候，曾经有过一些技术经验的人就会为思维导图增
加很棒的分支节点。通过这种方式，一方面我们很早就发现了测试
中的疏忽点。另外一方面我们也让大家的知识得到了共享。这对测
试人员将来进行测试是非常有帮助的。
2073
---
## Page 2075
当然，思维导图不是完美的。在我看来如果一个新的小组想要使用
思维导图，必须注意以下三点：
认同
思维导图对于管理团队来说是相当新的概念。他们可能会指着一大
堆的测试用例说：“这才是我们要测试的。”像思维导图这样没有具
体的测试用例的测试方法也许可以从一个小的模块开始。这样更容
易让人接受并最终了解到它所带来的好处。
命名和组织
层级的测试用例安排方法就像目录的安排一样可以使得测试用例命
名相当有逻辑（如文件夹_文件夹_文件夹_序号）。而思维导图的组
织就显得复杂一点。此外，缺乏实际的测试数据使得思维导图的每
个叶子节点所代表的是“一对多"的测试思路与测试用例关系。当测
试用例失败的时候，你的回答应该是某一个种类的测试用例失败而
不是单纯的某一个测试用例失败了。
多用户
类似QualityCenter这样的测试管理系统既可以让单用户使用也支持
多用户。然而思维导图更适合单用户使用。当多个测试人员同时修
改一张思维导图的时候就会比较混乱。解决的办法是你可以将不同
的功能模块制作成不同的思维导图。虽然最终你发现会有一些重叠
的部分，但一般来说会非常少。
虽然使用思维导图存在一些问题，但我认为，对于一个中小型的开
发测试小组来说，运用思维导图带来的好处远大于诸如组织测试思
路等所付出的代价。
[http://www.satisfice.com/repeatable.shtml
效能提升
通过在测试工作中使用SLIME方法、多目标的脚本语言以及思维导
图，我逐步成功地给产品发布组提供更科学更系统更及时的有关产
品质量的信息。正是这些成功的运用使得我（或者产品组）认同了
这些都可以帮助你进行高效的测试。或许，高效测试也是一种测试
之美。
2074
---
## Page 2076
第三部分工具之美
对于一个使用锤子的人来说，所有东西看起来都像一颗钉子。
一马克吐温
第18章通过植入缺陷来发现缺陷：变异测
试之美
AndreasZellerDavidSchuler
假设你是一个软件项目的测试管理人员。现在，你处于整个软件开
发周期的最后一个环节：所有的新功能都已经实现，所有的测试用
例也都已经通过了。现在需要你来决定：产品可以发布了吗？
理论上讲，既然所有的测试用例都通过了，应该一切都没问题了。
但问题是：如果你的测试集不够好，即使所有的测试用例都运行通
过了，也不能说明什么问题。假设在测试集中没有去测试程序的输
出，即使输出的结果是错的，你的测试用例仍然会通过。那么怎么
才能知道你的测试用例能否有效地检查出缺陷呢？在本章中，我们
将介绍一种简单、优雅、漂亮的方法来测试整个测试集的质量
系统化地植入人为的缺陷，然后看测试集能否发现它们。
评估测试集的质量
工程师和管理人员喜欢对事物进行量化，这里也不例外。为了量化
一个测试集的质量，实践中人们发展出了多种覆盖率指标。其中最
有名的是测试集的代码覆盖率，代码覆盖率指的是检查测试集是否
执行了程序的每一种状态。显然，在整个测试集中，如果有一种状
态没有被测试到，就有可能出现问题。假设在某种状态下有一个缺
陷，只要每次程序执行到这种状态就会发生失效。如果整个测试集
从来没有运行到达过这种状态，这个缺陷就可能永远也不会被发
现，至少在整个测试过程中不会被发现。
除了代码覆盖率，还有其他几种更高级的标准：
2075
---
## Page 2077
1.分支覆盖率：分支覆盖率保证代码中的每一个分支至少被执行一
次。
2.条件覆盖率：条件覆盖率保证代码中的每个条件分支（包括子条
件）都经历过是和否的状态。
所有这些指标都很容易检验并得到了广泛的应用。人们可以设置一
个很明确的目标：“我们要求对于任何一个模块，代码覆盖率都达到
90%以上！”
当然，所有的这些测试的度量标准也会有一些不足之处。第一个问
题是缺陷在程序中并不是平均分布的。举例来说，根据我们从
Aspectu的缺陷数据库中提取到的信息，图18-1显示了AspectU编译器
的漏洞分布情况。每一个长方形代表一个类文件（文件中的代码行
数越多，则对应的长方形面积越大）。长方形的亮度表示此类中的
缺陷数目：颜色越深，则说明此类中发现的缺陷越多。在某些类中
（如类BcelWeaver），在发布之后，我们仍发现了32个缺陷，而在
另一些类中（那些白色的长方形），则根本没有发现问题。就像帕
累托准则（Paretoeffect）所描述的，80%的缺陷都集中在20%的模块
中。显然，你希望你的测试集可以更侧重在那些容易产生漏洞的模
块，而不是为了达到90%的代码覆盖率而花大量的精力在那些根本
没有缺陷的模块中。
2076
---
## Page 2078
备注
测试用例：编辑摘要—输入第二个摘要
wait_for_element_present_ok
steditsummarytextarea
30000
click.ok
steditsummarytextarea
图18-1AspectU中的缺陷分布
另一个问题是：不但缺陷的分布不平均，风险的分布也同样很不平
均。在每一个项目中，都会有一些关键模块，它们要么是被非常频
繁地调用，要么是一些关键功能的依赖。在这些模块中的缺陷往往
会导致非常严重的后果。同样地，你也希望你的测试集可以更侧重
在那些高风险的模块而不是简单的平均分布。例如，如果要你来测
试一架客机，显然你会更多地测试引擎而不是那些座椅。
作为一个好的测试人员，你可能也已经注意到了漏洞和风险的不平
均分布，可这里还有第三个问题，也是最后一个问题。覆盖率只告
诉你测试的执行情况，而没有测试集本身的信息。我们来看一下例
18-1。我们创建了一个文件，在里面写入一些文本，然后关闭这个
文件。如果其中出了错，这个方法就会抛出一个异常，测试就会失
败。
例18-1：不完备的文件读写单元测试
2077
---
## Page 2079
import static org.junit.Assert.*;
void testFileWriteO
BufferedWriter out=new BufferedWriter(new FileWriter("outflename");
out.write("aString");
out.closeO);
在实际操作中，有很多系统都是这么进行测试的：只要系统没有崩
溃，我们就认为它工作正常。不幸的是，这些测试往往是不够的，
因为在这个测试中没有检查结果。如果这个方法创建了一个错误的
文件，写入了一些随机的输出，或甚至于什么都没做。在刚才的这
个测试中，我们可能也可以达到100%的代码覆盖率，却漏掉了如此
简单的一个漏洞。
在这个测试中，我们至少应该再次打开这个文件并检查它的内容。
但是在一般的测试中，我们怎么来对它进行判断？我们怎么判定一
个测试的优劣？这是柏拉图论（Platosproblem）的又一个例子：
“谁看管那些看管者？”。幸运的是，我们有方法来对一个测试进行
测试，我们有一个非常简单直接的方法来判断一个测试是不是“漂
亮”。
2078
---
## Page 2080
监督看管者
通常用来监测质量管理（QA）质量的方法是模拟一种情景，在这种
情景下，质量管理会触发警告。比如要测试一只看门狗，就可以看
它在面对一个（假扮的）闯入者时是不是会发出警告。要测试一个
服装公司的质量管理，就可以在生产线上放入一件有问题的服装，
看看质量管理能不能发现它。要测试一个安全系统，一般总是使用
入侵测试，去模拟发起一次恶意的攻击。
1971年，RichardLipton将仿真的概念引入了测试。他在论文"计算机
程序的故障诊断"中，介绍了通过在软件中植入人为的漏洞（变
异），并检测测试集能否发现它们。人为引入的漏洞可以通过改变
一个变量的值，删除一个方法的调用或者对一个条件分支进行取反
操作来实现。如果测试集不能发现这些变异，那么在实际的测试
中，它也很可能会漏过一些漏洞，这一测试集就需要进行完善。
我们再回头看一下例18-1，我们可以改变BufferedWriter.writeO的实
现，在这个方法的最前面加入一句return，让它什么都不做。如果用
例18-1中的测试，它不能发现这一变异，也表示它可能会漏掉真实
的漏洞（事实上也的确如此）。例18-2是一个改进以后的测试。新
的测试就不会被欺骗。如果BufferedWriter.writeO的实现有问题，例
18-2的测试马上就能发现这一变异。
例18-2：改进后的文件读写单元测试
import static org.junit.Assert.*;
void testFileWriteO
out.write("aString");
out.close();
BufferedReader in=new BufferedReader(new FileReader("outflename"));