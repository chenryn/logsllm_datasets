liseconds per evaluation.
In the LAN setting, 8 evaluations were performed in
parallel and achieved an amortized time of 0.26ms per
evaluation for bucket size B = 2. A bucket size of 2
can be obtained by performing a modest number (say
N = 256) of executions with κb = 20, or a very large
number of executions with κb = 40. We further tested our
prototype in the WAN setting where we obtain a slightly
decreased throughput of 0.72ms per AES evaluation with
40-bit security.
References
[1] AFSHAR, A., MOHASSEL, P., PINKAS, B., AND RIVA,
B. Non-interactive secure computation based on cut-and-
choose. In EUROCRYPT 2014 (May 2014), P. Q. Nguyen
USENIX Association  
25th USENIX Security Symposium  309
13
and E. Oswald, Eds., vol. 8441 of LNCS, Springer, Hei-
delberg, pp. 387–404.
[2] BEAVER, D.
Precomputing oblivious transfer.
In
CRYPTO’95 (Aug. 1995), D. Coppersmith, Ed., vol. 963
of LNCS, Springer, Heidelberg, pp. 97–109.
[3] BELLARE, M., HOANG, V. T., KEELVEEDHI, S., AND
ROGAWAY, P. Efﬁcient garbling from a ﬁxed-key block-
cipher. In 2013 IEEE Symposium on Security and Privacy
(May 2013), IEEE Computer Society Press, pp. 478–492.
[4] BELLARE, M., HOANG, V. T., AND ROGAWAY, P.
Adaptively secure garbling with applications to one-time
programs and secure outsourcing. In ASIACRYPT 2012
(Dec. 2012), X. Wang and K. Sako, Eds., vol. 7658 of
LNCS, Springer, Heidelberg, pp. 134–153.
[5] BELLARE, M., HOANG, V. T., AND ROGAWAY, P. Foun-
dations of garbled circuits. In ACM CCS 12 (Oct. 2012),
T. Yu, G. Danezis, and V. D. Gligor, Eds., ACM Press,
pp. 784–796.
[6] CANETTI, R. Universally composable security: A new
paradigm for cryptographic protocols.
In 42nd FOCS
(Oct. 2001), IEEE Computer Society Press, pp. 136–145.
[7] CHOU, T., AND ORLANDI, C. The simplest protocol
for oblivious transfer. In Progress in Cryptology - LAT-
INCRYPT 2015 (2015), K. E. Lauter and F. Rodr´ıguez-
Henr´ıquez, Eds., vol. 9230 of Lecture Notes in Computer
Science, Springer, pp. 40–58.
[8] DAMGAARD, I., LAURITSEN, R., AND TOFT, T. An
empirical study and some improvements of the Mini-
Mac protocol for secure computation. Cryptology ePrint
Archive, Report 2014/289, 2014.
http://eprint.
iacr.org/2014/289.
[9] DAMG ˚ARD, I., PASTRO, V., SMART, N. P., AND ZA-
KARIAS, S. Multiparty computation from somewhat ho-
momorphic encryption. In CRYPTO 2012 (Aug. 2012),
R. Safavi-Naini and R. Canetti, Eds., vol. 7417 of LNCS,
Springer, Heidelberg, pp. 643–662.
[10] DAMG ˚ARD, I., AND ZAKARIAS, R. W. Fast oblivi-
ous AES: a dedicated application of the MiniMac proto-
col. Cryptology ePrint Archive, Report 2015/989, 2015.
ia.cr/2015/989.
[11] DAMG ˚ARD, I., AND ZAKARIAS, S. Constant-overhead
secure computation of boolean circuits using preprocess-
ing. In TCC 2013 (Mar. 2013), A. Sahai, Ed., vol. 7785
of LNCS, Springer, Heidelberg, pp. 621–641.
[12] FREDERIKSEN, T. K., JAKOBSEN, T. P., AND NIELSEN,
J. B. Faster maliciously secure two-party computation
using the GPU. In SCN 14 (Sept. 2014), M. Abdalla and
R. D. Prisco, Eds., vol. 8642 of LNCS, Springer, Heidel-
berg, pp. 358–379.
[13] HUANG, Y., KATZ, J., AND EVANS, D. Efﬁcient secure
two-party computation using symmetric cut-and-choose.
In CRYPTO 2013, Part II (Aug. 2013), R. Canetti and
J. A. Garay, Eds., vol. 8043 of LNCS, Springer, Heidel-
berg, pp. 18–35.
[14] HUANG, Y., KATZ, J., KOLESNIKOV, V., KUMARESAN,
R., AND MALOZEMOFF, A. J. Amortizing garbled cir-
cuits. In CRYPTO 2014, Part II (Aug. 2014), J. A. Garay
and R. Gennaro, Eds., vol. 8617 of LNCS, Springer, Hei-
delberg, pp. 458–475.
[15] KELLER, M., ORSINI, E., AND SCHOLL, P. Ac-
tively secure OT extension with optimal overhead.
In
CRYPTO 2015, Part I (Aug. 2015), R. Gennaro and
M. J. B. Robshaw, Eds., vol. 9215 of LNCS, Springer,
Heidelberg, pp. 724–741.
[16] KOLESNIKOV, V., MOHASSEL, P., RIVA, B., AND RO-
SULEK, M. Richer efﬁciency/security trade-offs in 2PC.
In TCC 2015, Part I (Mar. 2015), Y. Dodis and J. B.
Nielsen, Eds., vol. 9014 of LNCS, Springer, Heidelberg,
pp. 229–259.
[17] KOLESNIKOV, V., AND SCHNEIDER, T. Improved gar-
bled circuit: Free XOR gates and applications.
In
ICALP 2008, Part II (July 2008), L. Aceto, I. Damg˚ard,
L. A. Goldberg, M. M. Halld´orsson, A. Ing´olfsd´ottir, and
I. Walukiewicz, Eds., vol. 5126 of LNCS, Springer, Hei-
delberg, pp. 486–498.
[18] KREUTER, B., SHELAT, A., AND SHEN, C. Billion-gate
secure computation with malicious adversaries. In Pro-
ceedings of the 21th USENIX Security Symposium (2012),
T. Kohno, Ed., USENIX Association, pp. 285–300.
[19] LINDELL, Y. Fast cut-and-choose based protocols for
malicious and covert adversaries. In CRYPTO 2013, Part
II (Aug. 2013), R. Canetti and J. A. Garay, Eds., vol. 8043
of LNCS, Springer, Heidelberg, pp. 1–17.
[20] LINDELL, Y., AND PINKAS, B. An efﬁcient protocol
for secure two-party computation in the presence of ma-
licious adversaries. In EUROCRYPT 2007 (May 2007),
M. Naor, Ed., vol. 4515 of LNCS, Springer, Heidelberg,
pp. 52–78.
[21] LINDELL, Y., AND PINKAS, B.
Secure two-party
computation via cut-and-choose oblivious transfer.
In
TCC 2011 (Mar. 2011), Y. Ishai, Ed., vol. 6597 of LNCS,
Springer, Heidelberg, pp. 329–346.
[22] LINDELL, Y., AND RIVA, B. Cut-and-choose Yao-based
secure computation in the online/ofﬂine and batch set-
tings. In CRYPTO 2014, Part II (Aug. 2014), J. A. Garay
and R. Gennaro, Eds., vol. 8617 of LNCS, Springer, Hei-
delberg, pp. 476–494.
[23] LINDELL, Y., AND RIVA, B. Blazing fast 2PC in the
ofﬂine/online setting with security for malicious adver-
saries. In Proceedings of the 22nd ACM SIGSAC Confer-
ence on Computer and Communications Security (2015),
I. Ray, N. Li, and C. Kruegel, Eds., ACM, pp. 579–590.
[24] MALKHI, D., NISAN, N., PINKAS, B., AND SELLA, Y.
Fairplay - secure two-party computation system. In Pro-
ceedings of the 13th USENIX Security Symposium (2004),
M. Blaze, Ed., USENIX, pp. 287–302.
[25] MOHASSEL, P., AND FRANKLIN, M. Efﬁciency trade-
offs for malicious two-party computation. In PKC 2006
(Apr. 2006), M. Yung, Y. Dodis, A. Kiayias, and
T. Malkin, Eds., vol. 3958 of LNCS, Springer, Heidelberg,
pp. 458–473.
[26] MOHASSEL, P., AND RIVA, B. Garbled circuits check-
ing garbled circuits: More efﬁcient and secure two-party
computation.
In CRYPTO 2013, Part II (Aug. 2013),
R. Canetti and J. A. Garay, Eds., vol. 8043 of LNCS,
Springer, Heidelberg, pp. 36–53.
[27] NIELSEN, J. B., NORDHOLT, P. S., ORLANDI, C., AND
BURRA, S. S. A new approach to practical active-secure
310  25th USENIX Security Symposium 
USENIX Association
14
two-party computation. In CRYPTO 2012 (Aug. 2012),
R. Safavi-Naini and R. Canetti, Eds., vol. 7417 of LNCS,
Springer, Heidelberg, pp. 681–700.
[28] PEIKERT, C., VAIKUNTANATHAN, V., AND WATERS,
B. A framework for efﬁcient and composable oblivious
transfer. In CRYPTO 2008 (Aug. 2008), D. Wagner, Ed.,
vol. 5157 of LNCS, Springer, Heidelberg, pp. 554–571.
[29] PINKAS, B., SCHNEIDER, T., SMART, N. P., AND
WILLIAMS, S. C. Secure two-party computation is prac-
tical. In ASIACRYPT 2009 (Dec. 2009), M. Matsui, Ed.,
vol. 5912 of LNCS, Springer, Heidelberg, pp. 250–267.
intersection based on OT extension.
[30] PINKAS, B., SCHNEIDER, T., AND ZOHNER, M. Faster
private set
In
Proceedings of the 23rd USENIX Security Symposium
(2014), K. Fu and J. Jung, Eds., USENIX Association,
pp. 797–812.
[31] SHELAT, A., AND SHEN, C.-H. Two-output secure
computation with malicious adversaries.
In EURO-
CRYPT 2011 (May 2011), K. G. Paterson, Ed., vol. 6632
of LNCS, Springer, Heidelberg, pp. 386–405.
[32] SHELAT, A., AND SHEN, C.-H. Fast two-party secure
computation with minimal assumptions. In ACM CCS 13
(Nov. 2013), A.-R. Sadeghi, V. D. Gligor, and M. Yung,
Eds., ACM Press, pp. 523–534.
[33] SMART, N. Personal communication, November 2015.
[34] YAO, A. C.-C. Protocols for secure computations (ex-
tended abstract). In 23rd FOCS (Nov. 1982), IEEE Com-
puter Society Press, pp. 160–164.
[35] ZAHUR, S., ROSULEK, M., AND EVANS, D. Two halves
make a whole - reducing data transfer in garbled circuits
using half gates.
In EUROCRYPT 2015, Part II (Apr.
2015), E. Oswald and M. Fischlin, Eds., vol. 9057 of
LNCS, Springer, Heidelberg, pp. 220–250.
A Adaptively Secure Garbling Schemes
A garbling scheme
algorithms
(Gb, En, Ev, De) with the following syntax and se-
mantics. All algorithms accept a security parameter as
explicit input, which we leave implicit.
tuple of
is
a
• Gb( f ,d) → (F,e); Here f is a boolean circuit with
m inputs and n outputs; d is an n× 2 array of (out-
put) wire labels; F is a garbled circuit; and e is an
m× 2 array of input wire labels.
By wire labels, we simply mean strings (i.e., ele-
ments of {0,1}κc). We deviate from [5] in requiring
the output wire labels d to be chosen by the caller of
Gb, rather than chosen by Gb itself. In the notation
of [5], we assume that the scheme is projective in
both its input and output encodings, meaning that e
and d consist of two possible wire labels for each
wire.
• En(e,x) → X takes an m × 2 array of wire la-
bels e and a plaintext input x ∈ {0,1}m and out-
puts a garbled encoding X of x. By assuming
that the scheme is projective, we assume that X =
(X1, . . . ,Xm) where Xi = e[i,xi].
• Ev(F,X) → Y ; takes a garbled circuit F and garbled
encoding X of an input, and returns a garbled en-
coding of the output Y .
• (cid:31)De(Y ) → y. We assume a way to decode a garbled
output to a plaintext value. It is a deviation from [5]
to allow this to be done without the decoding infor-
mation d. Rather, we may assume that the garbled
outputs contain the plaintext value, say, as the last
bit of each wire label.
Our correctness condition is that for the variables de-
ﬁned above, we have Ev(F, En(e,x)) = En(d, f (x)) and
(cid:31)De(Ev(F, En(e,x))) = f (x) for all inputs x to the circuit
f . In other words, evaluating the garbled circuit should
result in the garbled output that encodes f (x) under the
encoding d.
In our construction, an adversary sees the garbled cir-
cuit F ﬁrst, then it receives some of the garbled inputs
(corresponding to the k-probe matrix encoded inputs).
Finally in the online phase it is allowed to choose the
rest of its input to the ciruict and receive the rest of the
garbled inputs. Hence, our security game considers an
adversary that can obtain the information in this order.
We overload the syntax of the encoding algorithm En.
Since En is projective, we write En(e,i,b) to denote the
component ei,b — that is, the garbled input for the ith
wire corresponding to truth value b. Recall that we also
garble a circuit with output wire labels d speciﬁed (rather
than chosen by the Gb algorithm). Our security deﬁnition
lets the adversary choose d.
Deﬁnition 6. For a garbling scheme (Gb, En, Ev, De),
an interactive oracle program Adv,
and algo-
rithms S = (S0,S1,S2), we deﬁne the following two
games/interactions:
G Adv
real :
get f ,d from AdvH
(F,e) ← Gb( f ,d)
give F to AdvH
for i = 1 to m:
get xi from AdvH
Xi ← En(e,i,xi)
give Xi to AdvH
AdvH outputs a bit
:
G Adv,S
ideal
get f ,d from AdvS0
F ← S1( f )
give F to AdvS0
for i = 1 to m− 1:
get xi from AdvS0
Xi ← S2(i)
give Xi to AdvS0
get xm from AdvS0
y = f (x1···x m)
Y ← En(d,y)
Xm ← S2(m,y,Y )
give Xm to AdvS0
AdvS0 outputs a bit
In Gideal, H is a random oracle.
In Gideal, the tuple
S = (S0,S1,S2) all share state. All algorithms receive
the security parameter as implicit input.
15
USENIX Association  
25th USENIX Security Symposium  311
Then the garbling scheme is adaptively secure if there
exists a simulator S such that for all polynomial-time ad-
versaries Adv, we have that
is negligible in the security parameter.
Adv,S
ideal outputs 1](cid:31)(cid:31)
real outputs 1]− Pr[G
(cid:31)(cid:31)Pr[G Adv
Note that in the Gideal game, the simulator receives no
information about the input x as it produces the garbled
circuit F and all but one of the garbled input components.
Finally when producing the last garbled input compo-
nent, the simulator learns f (x) and its garbled output en-
coding En(d, f (x)). In particular, the simulator receives
no information about x, so its outputs carry no informa-
tion about x beyond f (x). The game also implies an
authenticity property for garbled outputs of values other
than f (x) — the simulator’s total output contains no in-
formation about the rest of the garbled outputs d.
In Figure 9 we describe a generic, random-oracle
transformation from a standard (static-secure) garbling
scheme to one with this ﬂavor of adaptive security. The
construction is quite similar to the transformations in
[4], with some small changes. First, since we know in
advance which order the adversary will request its gar-
bled inputs, we include the random oracle nonce R in the
last garbled input value (rather than secret-sharing across
all garbled inputs). Second, since we garble a circuit
with particular garbled output values in mind, we provide
“translation values” that will map the garbled outputs of
the static scheme to the desired ones. These translation
values also involve the random oracle, so they can be
equivocated by the simulator.
If
Theorem 7.
is a doubly-
projective garbling scheme satisfying the (static) prv and
aut properties of [5] then the scheme in Figure 9 satisﬁes
adaptive security notion of Deﬁnition 6 in the random or-
acle model.
(Gb, En, Ev, De,(cid:30)De)
The proof is very similar to analogous proofs in [4].
The main idea is that the simulator can choose the
“masked” (cid:29)F and δ translation values upfront. Then it
is only with negligible probability that an adversary will
call the random oracle on the secret nonce R, so the rel-
evant parts of the oracle are still free to be programmed