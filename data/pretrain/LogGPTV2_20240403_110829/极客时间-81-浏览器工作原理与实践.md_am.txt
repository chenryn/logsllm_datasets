## 思考时间最后，看下面这段代码：    showName()var showName = function() {    console.log(2)}function showName() {    console.log(1)}你能按照 JavaScript 的执行流程，来分析最终输出结果吗？欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png){savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 08 \| 调用栈：为什么JavaScript代码会出现栈溢出？在[上篇文章](https://time.geekbang.org/column/article/119046)中，我们讲到了，当一段代码被执行时，JavaScript引擎先会对其进行编译，并创建执行上下文。但是并没有明确说明到底什么样的代码才算符合规范。那么接下来我们就来明确下，哪些情况下代码才算是"一段"代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况：1.  当 JavaScript    执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。2.  当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。3.  当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。好了，又进一步理解了执行上下文，那本节我们就在这基础之上继续深入，一起聊聊**调用栈**。学习调用栈至少有以下三点好处：1.  可以帮助你了解 JavaScript 引擎背后的工作原理；2.  让你有调试 JavaScript 代码的能力；3.  帮助你搞定面试，因为面试过程中，调用栈也是出境率非常高的题目。比如你在写 JavaScript代码的时候，有时候可能会遇到栈溢出的错误，如下图所示：![](Images/b6aba56f229285a823d9e237bafd6697.png){savepage-src="https://static001.geekbang.org/resource/image/0c/70/0c9e2c4f7ee8ca59cfa99a6f51510470.png"}```{=html}```栈溢出的错误]{.reference}```{=html}```那为什么会出现这种错误呢？这就涉及到了**调用栈**的内容。你应该知道JavaScript中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，**调用栈就是用来管理函数调用关系的一种数据结构**。因此要讲清楚调用栈，你还要先弄明白**函数调用**和**栈结构**。``{=html}
## 什么是函数调用函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面我们看个简单的示例代码：    var a = 2function add(){var b = 10return  a+b}add()这段代码很简单，先是创建了一个 add函数，接着在代码的最下面又调用了该函数。那么下面我们就利用这段简单的代码来解释下函数调用的过程。在执行到函数 add() 之前，JavaScript引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，你可以参考下图：![](Images/38e0fde6ec8f07f97e96bc350b717c64.png){savepage-src="https://static001.geekbang.org/resource/image/7f/da/7fa2ed18e702861890d767ea547533da.png"}```{=html}```全局执行上下文]{.reference}```{=html}```从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。执行上下文准备好之后，便开始执行全局代码，当执行到 add这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：-   首先，从**全局执行上下文**中，取出 add 函数代码。-   其次，对 add    函数的这段代码进行编译，并创建**该函数的执行上下文**和**可执行代码**。-   最后，执行代码，输出结果。完整流程你可以参考下图：![](Images/79f4ae9cd801794602f360172c269147.png){savepage-src="https://static001.geekbang.org/resource/image/53/ca/537efd9e96771dc50737117e615533ca.png"}```{=html}```函数调用过程]{.reference}```{=html}```就这样，当执行到 add函数的时候，我们就有了两个执行上下文了------全局执行上下文和 add函数的执行上下文。也就是说在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript引擎是如何管理这些执行上下文的呢？答案是**通过一种叫栈的数据结构来管理的**。那什么是栈呢？它又是如何管理这些执行上下文呢？
## 什么是栈关于栈，你可以结合这么一个贴切的例子来理解，一条单车道的单行线，一端被堵住了，而另一端入口处没有任何提示信息，堵住之后就只能后进去的车子先出来，这时这个堵住的单行线就可以被看作是一个**栈容器**，车子开进单行线的操作叫做**入栈**，车子倒出去的操作叫做**出栈**。在车流量较大的场景中，就会发生反复的入栈、栈满、出栈、空栈和再次入栈，一直循环。所以，栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足**后进先出**的特点。你可以参看下图：![](Images/01ac631f2040065859ecb11f261a3f45.png){savepage-src="https://static001.geekbang.org/resource/image/5e/05/5e2bb65019053abfd5e7710e41d1b405.png"}```{=html}```栈示意图]{.reference}```{=html}```
## 什么是 JavaScript 的调用栈JavaScript引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为**执行上下文栈**，又称**调用栈**。为便于你更好地理解调用栈，下面我们再来看段稍微复杂点的示例代码：    var a = 2function add(b,c){  return b+c}function addAll(b,c){var d = 10result = add(b,c)return  a+result+d}addAll(3,6)在上面这段代码中，你可以看到它是在 addAll 函数中调用了 add函数，那在整个代码的执行过程中，调用栈是怎么变化的呢？下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。**第一步，创建全局上下文，并将其压入栈底**。如下图所示：![](Images/c62c0388e61693daec2ac19e44a858f1.png){savepage-src="https://static001.geekbang.org/resource/image/a5/1d/a5d7ec1f8f296412acc045835b85431d.png"}```{=html}```全局执行上下文压栈]{.reference}```{=html}```从图中你也可以看出，变量 a、函数 add 和 addAll都保存到了全局上下文的变量环境对象中。全局执行上下文压入到调用栈后，JavaScript引擎便开始执行全局代码了。首先会执行 a=2的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为2。设置后的全局上下文的状态如下图所示：![](Images/d8e27fcf44304c46e91927fc9e8b4bcd.png){savepage-src="https://static001.geekbang.org/resource/image/1d/1d/1d50269dbc5b4c69f83662ecdd977b1d.png"}```{=html}```赋值操作改变执行上下文中的值]{.reference}```{=html}```接下来，**第二步是调用 addAll 函数**。当调用该函数时，JavaScript引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：![](Images/4333dac8aa0a75ec00be7d751fddea18.png){savepage-src="https://static001.geekbang.org/resource/image/7d/52/7d6c4c45db4ef9b900678092e6c53652.png"}```{=html}```执行 addAll 函数时的调用栈]{.reference}```{=html}```addAll函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined变成了 10。然后接着往下执行，**第三步，当执行到 add函数**调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：![](Images/5814d9a7c0d1cb6507ce6453f8f9a2d2.png){savepage-src="https://static001.geekbang.org/resource/image/cc/37/ccfe41d906040031a7df1e4f1bce5837.png"}```{=html}```执行 add 函数时的调用栈]{.reference}```{=html}```当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result的值设置为 add 函数的返回值，也就是 9。如下图所示：![](Images/3ca0b675b448569e028b2cd4a32b084b.png){savepage-src="https://static001.geekbang.org/resource/image/03/96/03ca801a5372f941bf17d6088fee0f96.png"}```{=html}```add 函数执行结束时的调用栈]{.reference}```{=html}```紧接着 addAll 执行最后一个相加操作后并返回，addAll的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：![](Images/fba3be1813a338b749d6cdd4f993eb21.png){savepage-src="https://static001.geekbang.org/resource/image/d0/7b/d0ac1d6e77735338fa97cc9a3f6c717b.png"}```{=html}```addAll 函数执行结束时的调用栈]{.reference}```{=html}```至此，整个 JavaScript 流程执行结束了。好了，现在你应该知道了**调用栈是 JavaScript引擎追踪函数执行的一个机制**，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。
## 在开发中，如何利用好调用栈鉴于调用栈的重要性和实用性，那么接下来我们就一起来看看在实际工作中，应该如何查看和利用好调用栈。
### 1. 如何利用浏览器查看调用栈的信息当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。这么说可能有点抽象，这里我们拿上面的那段代码做个演示，你可以打开"开发者工具"，点击"Source"标签，选择JavaScript 代码的页面，然后在第 3行加上断点，并刷新页面。你可以看到执行到 add函数时，执行流程就暂停了，这时可以通过右边"callstack"来查看当前的调用栈的情况，如下图：![](Images/98794d121f41107bd548c8cbabdd333c.png){savepage-src="https://static001.geekbang.org/resource/image/c0/a2/c0d303a289a535b87a6c445ba7f34fa2.png"}```{=html}```查看函数调用关系]{.reference}```{=html}```从图中可以看出，右边的"callstack"下面显示出来了函数的调用关系：栈的最底部是anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add函数。这就清晰地反映了函数的调用关系，所以**在分析复杂结构代码，或者检查Bug 时，调用栈都是非常有用的**。除了通过断点来查看调用栈，你还可以使用 console.trace()来输出当前的函数调用关系，比如在示例代码中的 add 函数里面加上了console.trace()，你就可以看到控制台输出的结果，如下图：![](Images/185d4b22a692c45746d51f1b2898bc1a.png){savepage-src="https://static001.geekbang.org/resource/image/ab/ce/abfba06cd23a7704a6eb148cff443ece.png"}```{=html}```使用 trace 函数输出当前调用栈信息]{.reference}```{=html}```