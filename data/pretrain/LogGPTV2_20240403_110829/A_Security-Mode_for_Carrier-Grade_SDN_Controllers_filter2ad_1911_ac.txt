RuntimePermission
ModifyThread
1 
2
USER
16
17 
Figure 3: The developer-specified application policy must in-
clude the application role and a list of required permissions.
1 
2
3
4
5
6
7
8
...
...
9
10 
Figure 4: An optional application network policy file is used
to specify the HeaderSpacePermissions or TopologyPermis-
sions, which constrain an application’s network access capa-
bility.
To enforce the application network policy, the ONOS operator
places the application network policy file into the ONOS config-
uration folder. The file must use a name that matches the name
of its corresponding application. During the application installa-
tion phase, the application subsystem uses this common filename
to augment the application’s security policy with these additional
network security constraints.
5.3 Extensions to application loading
In ONOS, the application subsystem allows hot deployment of ONOS
applications to an ONOS cluster. When an ONOS operator installs
an application onto one of any ONOS nodes within a cluster, the
application subsystem will replicate the application to every ONOS
node in the cluster. That is, ONOS applications can be installed to
an ONOS cluster from anywhere as if the whole cluster was one
single monolithic system.
To enable this feature, the application subsystem maintains a
global state, or an application state, which can either be INSTALLED
or ACTIVE, as shown in Figure 5(top). application states allow the
application subsystem to deploy and manage applications across all
Figure 5: A comparison of the standard ONOS application
loading state diagram versus the security-mode application
loading state diagram. The additional Review Pending and
Reviewed states track whether the application has been re-
viewed and explicitly approved by the ONOS operator prior
to loading.
ONOS nodes in a cluster. These states are maintained via a gossip-
based [15] eventually consistent distributed store, and hence, the
application state may transition from an inconsistent to a consistent
state. Application state transition is triggered by a user input event
via the CLI interface.
The lower panels of Figure 5 illustrate the application state tran-
sition when ONOS is operating in security-mode. There are three
objectives to the security-mode extensions to application activation:
(i) to ensure the ONOS operator reviews the policy prior to activa-
tion, (ii) to verify positive acceptance, and (iii) to ensure that the
application and policy are associated during runtime. The appli-
cation subsystem is modified to manage applications based on the
state diagram shown in Figure 5 (bottom). When security-mode is
enabled, the application subsystem refers to the security state of the
application to make all application state transition decisions.
We have integrated a security subsystem into ONOS, which en-
forces the application security state during runtime, as shown in
Figure 5 (middle). Like the application subsystem, the security sub-
system operates based on the security state of each application.
When the ONOS operator attempts to activate an application
with application state being INSTALLED, the security subsystem
captures the this event ahead of the application subsystem, and
changes the application’s security state to INSTALLED. When the
application subsystem subsequently receives this event (the applica-
tion’s Security State is SECURED), the application will remain in
the INSTALLED state, and the application is not activated. At this
moment, the ONOS operator must choose to either uninstall the
application or review the application.
Application State Machine (ONOS)STARTENDINSTALLEDACTIVEdeactivateactivateinstalluninstalluninstallApplication State Machine (ONOS in Security Mode)STARTENDACTIVEdeactivateactivate(SecurityState == SECURED)installuninstalluninstallactivate(SecurityState != SECURED)INSTALLEDSecurity State Machine (ONOS in Security Mode)STARTENDINSTALLEDREVIEWEDdeactivatereviewactivateuninstalluninstallSECUREDREJECTEDaccept policypolicyviolationuninstallA Security-Mode for Carrier-Grade SDN Controllers
ACSAC 2017, December 4–8, 2017, Orlando, FL, USA
If the operator chooses to review the application, the security
subsystem transitions the application to the REVIEWED state. This
accomplishes our first objective. While in the REVIEWED state,
the operator cannot activate the application, as it is not yet in the
SECURED state. Here, the operator must accept the policy to tran-
sition the application to a SECURED state, from which activation
may commence. This transition completes our second objective.
Finally, when the policy is accepted and the application transitions
to SECURED state, this triggers the security system to enforce
our third objective, the runtime association of the application to
its security policy. Application transitions to the REJECTED state,
when triggered by a policy violation (excludes network policy vio-
lation), results in the immediate deactivation and deinstallation of
the application.
5.4 The security service distributed store
While the application subsystem employs a gossip-based (eventu-
ally consistent) distributed store to maintain the application state
throughout an ONOS cluster, the security subsystem must also em-
ploy a distributed store to maintain security policies. However,
the security states and security policies must maintain strong con-
sistency within an ONOS cluster. Figure 6 illustrates one of the
problems that may arise when the security states of an application
are synchronized using an eventually consistent distributed store.
Figure 6: An illustration of the problem that may arise
when Security States were synchronized using a gossip-
based eventually consistent distributed store. Inconsistent
security state could lead to an ONOS node activating an ap-
plication that must not be activated.
In order to avoid such problems, we employ a strongly consistent
distributed store, which is implemented using the RAFT consensus
algorithm [20]. Briefly, RAFT’s consensus algorithm ensures that
if a state machine applies set x to 3 as the nth command, no other
state machine will ever apply a different nth command. As a result,
each state machine processes the same series of commands and
thus produces the same series of results and arrives at the same
series of states.
Figure 7 illustrates the use of the consistent distributed store by
the policy building services previously described and the runtime
permission enforcement services that inserted by the API dispatch
service. It is through this mechanism that transition-consistency
is ensured between the policy builder and the policy enforcement
services.
When an ONOS operator attempts to review the security policy
of an application, the security state of the application changes to
REVIEWED state. This state transition is done within the security
distributed store. Accordingly, the store generates the StateUpdat-
edEvent to notify the Manager module of the change in the security
state of the application to REVIEWED.
Figure 7: An illustration of the security subsystem design.
Permissions are defined per application within the Pol-
icy builder, distributed to all application instances using a
strongly consistent distributed store, and enforced by the
policy enforcement module within the security subsystem.
In response to the StateUpdatedEvent flagged as REVIEWED, the
Policy builder module in the Manager builds a set of permissions
that are granted to the application. This permission-set building
process is one of the key features of SM-ONOS as all the access
control mechanisms introduced in Section 4 are applied. We next
elaborate on how the Policy builder module applies each of the
access control mechanisms.
Policy Building. The Policy builder cumulatively collects a set
of required permissions based on the access control mechanisms
and security policies for the given application. In order to build the
bundle-level RBAC policy, the Policy builder takes advantage of the
property of the PermissionAdmin service [21]. On the Karaf [17]
platform, where OSGi security is enabled and all permissions are
granted to all the OSGi bundles, it is possible to impose a least priv-
ileged access policy to a desired OSGi bundle using the Permission
Admin Service.
If at least one permission is granted to an OSGi bundle via the
Permission Admin Service, all the other permissions are taken away
from that bundle. This is to ensure that the Policy builder provides
the ONOS application with the minimum permissions to run as on
an ONOS instance to its local permission set. The least permissions
required to ONOS application to properly operate includes basic
OSGi PackagePermission and AdaptPermission. In fact, the appli-
cation permission set acquired from the bundle-level RBAC stage
is the base set of permissions that must be granted to any ONOS
applications by default. Furthermore, at this level, the Builder not
only adds permissions but also removes permissions from the policy
file. It is possible to specify known Java permissions and OSGi per-
missions on the policy file using ’Java-perm’ as shown in Figure 3.
The Builder makes sure that these explicitly granted permissions
do not include permissions that should never be granted to ONOS
applications. For example, the Builder removes FilePermission to
read or access the ONOS configuration folder and the files in it, and
also removes RuntimePermission that allows executing the ’exitVM’
command, which shuts down the entire Java Virtual Machine.
At the application-level RBAC policy building stage, the Policy
builder selectively adds the predefined set of permissions based
on the application’s role specified in the policy file. If the given
application has admin role, OSGi ServicePermissions to access all
Node 1Node 2logical termApplication StateSecurity StateApplication StateSecurity StateSECUREDACTIVE1SECUREDACTIVEPOLICY_VIOLATEDINSTALLEDSECUREDACTIVEPOLICY_VIOLATEDINSTALLEDSECUREDINSTALLED23policy violationat Node 1applicationcan be re-activated@ Node 2ManagerPolicy builderFelix Security-enabled OSGi Framework Security Distributed Storesync &persistPolicy enforcerPermissionsPolicyViolatedEventStateUpdatedEventPermissionsGossip-based eventually consistent distributed storeRAFT-based strongly consistent distributed storeStateUpdatedEventACSAC 2017, December 4–8, 2017, Orlando, FL, USA
C. Yoon et al.
the ONOS Northbound Services are added to the application per-
mission set. For an application that is assigned the user role, the
permissions to access all Northbound Services except for Admin-
istrative Northbound Services are added to its permission sets. In
order to enable API-level PBAC policy enforcement, a custom type
of permission, called AppPermission, is implemented by extending
Java’s BasicPermission class. At this level, all the permissions that
are listed as ’app-perm’ in the policy file (Figure 3) added to the
application permission set.
The network-level PBAC also requires custom types of permis-
sion, and HeaderSpacePermission and TopologyPermission are im-
plemented by extending Java’s Permission class. HeaderSpacePer-
mission instances are created using the various header field values
specified in the network policy file (e.g. ipv4_dst, tcp_dst, and ac-
tions values; see Figure 4), and TopologyPermission instances are
created using the virtual network names specified in the policy
file (the network permission is template is shown in Figure 4). The
permissions created at this level are also added to the application
permission set.
The final task of the security subsystem is to print out all per-
missions that the Policy builder has process when the application’s
security state transitions to the REVIEWED state. This step allows
the ONOS operator to evaluate the permissions that will be granted
to the application upon acceptance.
Policy Acceptance and Enforcement. If the set of permissions
that were printed on the console are found acceptable, the operator
may accept the policy by entering the accept command via CLI
interface. Upon the acceptance, the Manager pushes the permission
set and the security state SECURED to the distributed store. Once
the entry is pushed, the Manager module on every ONOS instance
forming a cluster receives the StateUpdatedEvent flagged as SE-
CURED with the application identifier. The event triggers the Policy
enforcer module to grant the permission set to the application via
OSGi’s Permission Admin service.
5.5 Runtime security policy violation detection
and response
Once the ONOS operator accepts the policy, the permissions are im-
mediately granted to each OSGi bundles comprising the ONOS ap-
plication at each ONOS instance. The permission checking is rather
simple, because the Felix framework sets its security extension to
the Java Virtual Machine’s (JVM) default security provider. There-
fore, Java’s System.getSecurityManager.checkPermission method is
used to check if the application has the required permission. That is,
the permissions granted to enforce the bundle and application-level
RBAC policy are checked without any modification of system code,
as these permissions include the permissions to access Java APIs
and to perform OSGi-related tasks.
In order to monitor ONOS Northbound API access, we inserted
software extensions to check permission using the checkPermis-
sion at the beginning of each Northbound API implementation.
This enables the security subsystem to monitor and detect unautho-
rized Northbound API calls, and to short circuit attempts when a
permission violation occurs.
Permission checking for network-level access control is also
done in SM-ONOS using the checkPermission method. This exten-
sion checks whether the caller is attempting to invoke an API that
includes a parameter that references network header space. All such
header space parameter references are then evaluated against the
operator defined header space criteria, and if these match then the
API is filtered without execution. The software extensions that eval-
uate API parameters, include the use of HeaderSpacePermissions,
and are inserted into those parts of the ONOS API implementations
that issue flow mods, or generate network packets.
The TopologyPermission checks will be released with the API
implementations of the virtual network service when the service
is officially released. This virtual network feature is inspired from
the virtual network model of OpenVirtex[3], where we construct
a virtual network as a collection of virtual devices and virtual
links into a topology. Virtual devices are slices and splices of other
devices by virtue of their ports mapping to other device ports. In
this approach, there is no implied connectivity. Rather, the network
graph can be traversed just as one would traverse the underlying
physical network graph and connectivity can be programmed using
intents and flow objectives. In this approach, the mechanism for
isolation is completely independent from the model.
When the checkPermission method throws an AccessControlEx-
ception for an OSGi bundle that is designated as an ONOS applica-
tion, it considers this as an application policy violation. The security
subsystem leverages the log listener within the Felix framework,
which provides logging and notification services to report the excep-
tion. When the Security Manager detects that an ONOS application
is lacking any of the Java API, OSGi or ONOS Northbound API
permission, it immediately deactivates the application to avoid pos-
sible odd application behavior that may harm ONOS or manipulate
the managed network.
5.6 Performance considerations
Unlike bundle-level and application-level RBAC policies, the API-