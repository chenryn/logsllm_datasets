from such an interaction is not considered a successful forgery. Though it may seem at ﬁrst
that we are increasing the attack surface (note that direct encryption queries are already
counted towards this), the extra information leakage may not make a signiﬁcant diﬀerence in
practice, especially when applications restrict and/or log who initiates decryption and what
can be decrypted by whom.
One can modify our construction to satisfy an even stronger notion where even decryption
queries initiated by the adversary are not counted towards its forgery budget. For example,
in parallel to evaluating the DPRF on j(cid:107)α, a threshold signature on the same input can be
computed. Then, during decryption, parties ﬁrst check the validity of the signature before
responding with their partial share of the DPRF value. However, adding an invocation of a
threshold signature scheme to DiSE would be a signiﬁcant overhead and would eliminate the
possibility of a symmetric-key only solution.
7 Our Construction: DiSE
In this section, we put forward our main construction DiSE, based on any DPRF. A full
description of the construction is provided in Figure 2. (See Section 2.2 for an overview.) We
prove that if the DPRF is (strongly) secure, then DiSE is (strongly) secure too. We provide
concrete DPRF instantiations in Section 8.
Theorem 7.1 The TSE scheme DiSE of Figure 2 is (strongly)-secure if the underlying
DPRF DP is (strongly)-secure.
Proof. We show each property of DiSE separately.
Consistency. Recall that consistency is required only when all the parties behave honestly.
Thus, consistency of DiSE follows easily from the consistency of DP.
22
Ingredients:
− An (n, t)-DPRF protocol DP := (DP.Setup, Eval, Combine) (Def. 5.1).
− A pseudorandom generator PRG of polynomial stretch.
− A commitment scheme Σ := (Σ.Setup, Com) (Def. A.2).
Setup(1κ, n, t) →(cid:16)(cid:74)sk(cid:75)[n], pp
(cid:17)
to get ppcom. Set ski := rki for i ∈ [n] and pp := (ppDP, ppcom).
DistEnc((cid:74)sk(cid:75)[n], [j : m, S], pp) → [j : c/⊥]: To encrypt a message m with the help of parties in S:
: Run DP.Setup(1κ, n, t) to get ((rk1, . . . , rkn), ppDP) and Σ.Setup(1κ)
− Party j computes α := Com(m, ppcom; ρ) for a randomly chosen ρ and sends α to all parties in S.
− For every i ∈ S, party i runs Eval(ski, j(cid:107)α, pp) to get zi, and sends it to party j.
− Party j runs Combine({(i, zi)}i∈S, pp) to get w or ⊥. In the latter case, it outputs ⊥. Otherwise,
it computes e := PRG(w) ⊕ (m(cid:107)ρ) and then outputs c := (j, α, e).
DistDec((cid:74)sk(cid:75)[n], [j(cid:48) : c, S], pp) → [j(cid:48) : m/⊥]: To decrypt a ciphertext c with the help of parties in S:
− Party j(cid:48) ﬁrst parses c into (j, α, e). Then it sends j(cid:107)α to all the parties in S.
− For i ∈ S, party i receives x and checks if it is of the form j(cid:63)(cid:107)α(cid:63) for some j(cid:63) ∈ [n]. If not, then
it sends ⊥ to party j(cid:48). Else, it runs Eval(ski, x, pp) to get zi, and sends it to party j(cid:48).
− Party j(cid:48) runs Combine({(i, zi)}i∈S, pp) to get w or ⊥. In the latter case, it outputs ⊥. Otherwise,
it computes m(cid:107)ρ := PRG(w) ⊕ e and checks if α = Com(m, ppcom; ρ). If the check succeeds, it
outputs m; otherwise, it outputs ⊥.
Figure 2: DiSE: our threshold symmetric-key encryption protocol.
Lemma 7.2 (Correctness) DiSE is a correct TSE scheme.
Proof. A TSE scheme is correct if whenever an honest party j initiates DistEnc on a message
m to obtain a ciphertext c (i.e., DistEnc does not fail), any honest party j(cid:48) recovers m itself
(or ⊥) when it runs DistDec with c as input (except with negligible probability).
In the
protocol DiSE, c is of the form (j, α, e) where α := Com(m, ppcom; ρ) is generated locally. Any
decryptor must verify that the message m(cid:48) and randomness ρ(cid:48) that it recovers (if Combine
does not fail) satisfy α = Com(m(cid:48), ppcom; ρ(cid:48)) or not. If Σ is a binding commitment scheme,
then this veriﬁcation succeeds only if m = m(cid:48), except with negligible probability.
Lemma 7.3 (Strong-correctness) If DP satisﬁes the correctness property, then DiSE is
a strongly-correct TSE scheme.
Proof. For a TSE scheme to be strongly-correct, we also need that if all the parties involved
in decryption behave honestly, then a ciphertext c := (j, α, e), where e := PRG(w) ⊕ (m(cid:107)ρ),
generated by an honest party (possibly involving some corrupt parties) should decrypt to the
right message with high probability. Now the correctness property of DP guarantees that if all
the parties involved in decryption are honest w(cid:48) obtained through Combine during decryption
will be the same as the w obtained during encryption except with negligible probability (as
the input to the DPRF is the same j(cid:107)α). Therefore, PRG(w(cid:48))⊕e in the last step of decryption
would give PRG(w(cid:48)) ⊕ PRG(w) ⊕ (m(cid:107)ρ) = m(cid:107)ρ.
23
For the following three lemma, we provide a sketch here and defer formal proofs to Ap-
pendix C.
Lemma 7.4 (Message privacy) If DP is a secure DPRF, then DiSE is a message-private
TSE scheme.
Proof sketch. The challenge ciphertext c(cid:63) has the form (j(cid:63), α(cid:63), e(cid:63)) where e(cid:63) = PRG(w(cid:63)) ⊕
(mb(cid:107)ρ(cid:63)), α(cid:63) = Com(mb, ppcom; ρ(cid:63)) and w(cid:63) is the output of DPRF DP on j(cid:63)(cid:107)α(cid:63). One can
think about the masking with PRG as a symmetric-key encryption using a stream cipher.
So, an adversary A will ﬁnd it computationally hard to guess b if w(cid:63) is indistinguishable
from random. The pseudorandomness property of DP ensures this as long as A has no way
of evaluating the DPRF on j(cid:63)(cid:107)α(cid:63) itself. (Note that α(cid:63) does not reveal information about mb
due to the hiding property of Σ.)
If a corrupt party initiates an encryption protocol, then A can learn j(cid:107)α(cid:63) for any j because
α(cid:63) is not hidden from it, but j would never be equal to j(cid:63) since j(cid:63) is an honest party. On
the other hand, even if A asks party j(cid:63) to initiate encryption, j(cid:63) would compute DPRF on
a value α (cid:54)= α(cid:63) due to the binding property of Σ. As a result, no matter how an encryption
query is crafted, A cannot compute the DPRF on j(cid:63)(cid:107)α(cid:63). See Appendix C.1 for a detailed
proof.
Lemma 7.5 (Authenticity) If DP is a secure DPRF, then DiSE is a TSE scheme that
satisﬁes authenticity.
Proof sketch. Among the forged ciphertexts output by adversary, suppose there are two
ciphertexts c1, c2 (c1 (cid:54)= c2) with the same j and commitment α. When these two are decrypted
with possibly diﬀerent sets of parties, the DPRF value recovered would be the same due to
the consistency property of DP (it is assumed that all parties involved in decryption behave
honestly). As a result, (m1, ρ1) and (m2, ρ2) recovered from c1 and c2, respectively, would
be diﬀerent. Due to the binding property of Σ, α cannot be a commitment to both. Hence,
decryption of at least one of c1, c2 fails, and AUTH outputs 0. Therefore, if an adversary
must succeed, each of the k + 1 ciphertexts must have unique (j, α).
Recall that a valid adversary is allowed to contact honest parties strictly less than k · g
number of times. So one can ﬁnd at least one (j, α) among the forged ciphertexts for which
adversary has not contacted g parties. Due to the pseudorandomness property of DP, the
adversary does not know the value of DPRF on (j, α). Hence, it can not produce a valid
ciphertext with it.
A detailed proof can be found in Appendix C.2. Note that if parties involved in the
decryption of forged ciphertexts are allowed to act maliciously, we cannot invoke DPRF’s
consistency property. However, the adversary would still not be able to make sure that c1, c2
decrypt successfully to two distinct messages because the commitment is binding. Thus, DiSE
can be shown to satisfy a strong notion of an INT-PTXT-style deﬁnition in the distributed
setting (see Remark 6.10).
Lemma 7.6 (Strong-authenticity) If DP is a strongly-secure DPRF, then DiSE is a TSE
scheme that satisﬁes strong-authenticity.
Proof sketch. Strong authenticity gives additional power to the adversary. In the decryption
of forged ciphertexts, corrupt parties can deviate from the protocol arbitrarily. Thus, unlike
24
above, consistency of DP alone would not suﬃce. Using both consistency and correctness
though, one can argue that even if c1, c2 are decrypted with diﬀerent sets of parties, the
recovered DPRF values w1, w2 are either the same or ⊥. In the latter case, AUTH clearly
outputs 0, and, in the former, it outputs 0 for the same reason as above.
The rest of the proof is similar to the one for weak-authenticity with some minor changes
in how the pseudorandomness guarantee is reduced to authenticity. See Appendix C.3 for
more details.
Remark 7.7 (Key-management application) As discussed in the introduction (c.f. Sec-
tion 1), a main motivation of this work is to strengthen the security of key-management
applications like Hashicorp Vault [vaub]. For such applications, DiSE should be viewed as
distributing the role of the key-manager itself. Multiple servers would keep shares of the mas-
ter secret key (which is used to encrypt various types of secrets) and know about each other’s
identity. Clients of the key-management application would need to authenticate via a separate
mechanism.
Remark 7.8 (Other deﬁnitions of security) Through Theorem 7.1, we study two forms
of security for TSE in this paper. The stronger form combines strong correctness with strong
authenticity and the normal form combines their normal versions. One could consider other
possibilities too like combining strong correctness with normal authenticity. The exact re-
quirements would depend on the application for which TSE is being used (see remarks 6.5
and 6.9).
8
Instantiations of Distributed Pseudorandom Functions
In this section, we revisit the distributed pseudo-random function (DPRF) constructions of
Naor, Pinkas, and Reingold [NPR99] (henceforth NPR) and study the properties deﬁned in
Section 5.
NPR proposed two diﬀerent instantiations of DPRF, one based on the decisional Diﬃe-
Hellman assumption (DDH) and another based on any PRF. They showed that their con-
structions are secure against semi-honest adversaries, and brieﬂy discussed how the ﬁrst
construction (DDH-based) could be extended to the malicious setting. Below, we present
the two instantiations in their original form, and show that both achieve our pseudorandom-
ness requirement against malicious adversaries (Def. 5.3). As discussed in Section 5, our
deﬁnition captures several attacks that were not considered before. Thus, the proofs require
signiﬁcantly more care. Further, building on the idea mentioned in NPR, we strengthen the
DDH-based construction with a NIZK proof (speciﬁcally, Schnorr’s proof [Sch90, CV90] via
the Fiat-Shamir transform [FS87]) to obtain strong security. However, it turns out that in
addition to the application of NIZKs, we need to use trapdoor commitments to commit to
secret key shares of parties in order to achieve our stronger pseudorandomness property. We
also brieﬂy discuss how to strengthen the PRF-based construction to make it strongly secure
using only symmetric-key primitives.
8.1 DDH-based construction
NPR’s ﬁrst DPRF is based on any multiplicative group G of prime order p in which DDH
holds. The PRF functionality being computed collectively can be written as fs(x) = H(x)s,
25
where H : {0, 1}∗ → G is a hash function (modeled as a random oracle) and the key is s ∈ Zp.
To distribute the evaluation of f , the secret key s must be secret shared between the parties.
In the setup phase, a trusted party samples a master key s ←$ Zp and uses Shamir’s secret
sharing scheme with a threshold t to create n shares s1, . . . , sn of s. Share si is given privately
to the party i. We know that for any set S of (cid:96) ≥ t parties S := {i1, ..., i(cid:96)} ⊆ [n], there
j∈S sij λ0,j,S = s.
exists integers (i.e. Lagrange coeﬃcients) λ0,1,S, . . . , λ0,(cid:96),S ∈ Zp such that(cid:80)
(cid:0)H(x)sij(cid:1)λ0,j,S ,
Therefore, it holds that
fs(x) = H(x)s = H(x)
j=1 λ0,j,S sij =
(cid:80)(cid:96)
(cid:96)(cid:89)
which can be computed in a distributed manner running the protocol ΠDDH-DP as shown in
Figure 3. This protocol satisﬁes the pseudorandomness deﬁnition (Def. 5.3), but not the
correctness deﬁnition (Def. 5.4). Formally we show that:
i=1
Parameters: Let G = (cid:104)g(cid:105) be a multiplicative cyclic group of prime order p in which the DDH
assumption holds and H : {0, 1}∗ → G be a hash function modeled as a random oracle. Let SSS
be Shamir’s secret sharing scheme (Def. A.5).
− Setup(1κ, n, t) → ((cid:74)sk(cid:75)[n], pp) : Sample s ←$ Zp and get (s1, . . . , sn) ← SSS(n, t, p, s). Set
Output(cid:81)
pp := (p, g, G) and ski := si and give (ski, pp) to party i, for i ∈ [n].
− Eval(ski, x, pp) → zi : Compute w := H(x), hi := wski and output hi.
− Combine({(i, zi)}i∈S, pp) =: z/⊥ : If |S| < t, output ⊥. Else, parse zi as (hi) for i ∈ S.
.
i∈S hλ0,i,S
i
Figure 3: A secure DPRF protocol ΠDDH-DP based on DDH.
Theorem 8.1 Protocol ΠDDH-DP in Figure 3 is a secure DPRF under the DDH assumption
in the programmable random oracle model.
We provide a detailed formal analysis in Appendix C.4. Here we provide a brief sketch.
Consistency follows from Shamir’s secret sharing in a straightforward way. The pseudoran-
domness property can be reduced from the hardness of DDH assumption. Intuitively, since
the attacker is restricted to get at most t − 1 evaluations of the secret polynomial for the
challenge x(cid:63), it does not have enough information whether the returned value in the challenge
phase lies on the secret polynomial or not. However, subtleties arise due to the fact that the
adversary may obtain more than t − 1 evaluations through queries on x (cid:54)= x(cid:63), and hence
the above argument must hold conditioned on those values. Fortunately, via a sequence of
hybrids, we can gradually move to a game in which a fresh random polynomial is selected
for each diﬀerent x that is correlated with the secret polynomial on up to (cid:96) ≤ t − 1 points,
where (cid:96) is the number of corrupt parties (as those many secrets can be obtained by the ad-
versary via corruption). Clearly, t− 1 evaluations point give no information about the secret
(t − 1)-degree polynomial. Therefore, the response on challenge x(cid:63) is indistinguishable from
random.
Strong security Adding trapdoor commitments and NIZK proofs in the RO model (for a
statement slightly diﬀerent from the one suggested by NPR) appropriately to ΠDDH-DP, we
obtain the protocol ΠZK-DDH-DP, described in detail in Figure 4. This protocol also satisﬁes
correctness and hence achieves strong security. Formally:
26
Theorem 8.2 Protocol ΠZK-DDH-DP in Figure 4 is a strongly secure DPRF under the DDH
assumption in the programmable random oracle model.
A detailed proof is provided in Appendix C.5. The proof for pseudorandomness follows
the same structure as before. However, to accommodate the changes (trapdoor commitments
and NIZK proofs), some additional eﬀort is needed. Note that NIZK proofs are used by each
party i to show that they use the correct secret-share si which is committed as γi in the public
parameters. However, since the adversary is allowed to corrupt the parties after obtaining the
public parameters, we need trapdoor commitments to make sure that the commitments can
be opened to some diﬀerent values later by the simulator with a trapdoor. The correctness
property follows from the extractability of NIZK and binding of commitments.
Parameters: Let G = (cid:104)g(cid:105) be a multiplicative cyclic group of prime order p in which the DDH
: {0, 1}∗ → {0, 1}poly(κ) be two hash functions
assumption holds, H : {0, 1}∗ → G and H(cid:48)
modeled as random oracles. Let SSS be Shamir’s secret sharing scheme (Def. A.5), TDC :=
H(cid:48)
(Setupcom, Com) be a trapdoor commitment scheme (Def. A.3) and NIZK := (Prove
)
be a simulation-sound NIZK proof system (Def. A.6).
− Setup(1κ, n, t) → ((cid:74)sk(cid:75)[n], pp). Sample s ←$ Zp and get (s1, . . . , sn) ← SSS(n, t, p, s). Run
Setupcom(1κ) to get ppcom. Compute a commitment γi := Com(si, ppcom; ri) by picking ri
at random. Set pp = (p, g, G, γ1, . . . , γn, ppcom), ski := (si, ri) and give ski to party i, for
i ∈ [n].
, Verify
H(cid:48)
− Eval(ski, x, pp) → zi. Compute w := H(x) and hi := wsi. Run Prove
with the statement
stmti: {∃s, r s.t. hi = ws ∧ γi = Com(s, ppcom; r)} and witness (si, ri) to obtain a proof πi.
Output ((w, hi), πi).
− Combine({(i, zi)}i∈S, pp) =: z/⊥. If |S| < t, output ⊥. Else, parse zi as ((w, hi), πi) and
(stmti, πi) = 1 for all i ∈ S. If check fails for any i, output ⊥. Else, output
check if Verify
H(cid:48)
H(cid:48)
(cid:81)
i∈S hλ0,i,S
i
.
Figure 4: A strongly secure DPRF protocol ΠZK-DDH-DP based on DDH. Diﬀerences from
ΠDDH-DP are highlighted in blue.
Parameters: Let G = (cid:104)g(cid:105) be a multiplicative cyclic group of prime order p in which the DDH assump-
tion holds, H : {0, 1}∗ → G and H(cid:48) : {0, 1}∗ → Zp be hash functions. Let SSS be Shamir’s secret
sharing scheme (Def. A.5).
generator h of G at random. Compute a commitment γi := gsi · hri to si by picking ri ←$ Zp.
Set pp = (p, g, G,H,H(cid:48), γ1, . . . , γn, h), ski := (si, ri) and give ski to party i, for i ∈ [n].
− Setup(1κ, n, t) → ((cid:74)sk(cid:75)[n], pp). Sample s ←$ Zp and get (s1, . . . , sn) ← SSS(n, t, p, s). Sample a