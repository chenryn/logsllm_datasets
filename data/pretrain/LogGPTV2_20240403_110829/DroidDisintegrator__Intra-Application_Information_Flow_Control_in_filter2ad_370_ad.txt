output. This graph provides information about the behavior of the application to the DroidDisinte-
grator user. These can help a developer identify possible changes in app structure and component
interaction so that a tighter policy can be enforced. DroidDisintegrator can thus help a motivated
app developer to express security assurances with a structured and enforceable language.
4.8 Repackaging
We unpack the app binary (a signed zip ﬁle with the.apk extension, or an APK ), and edit the
app manifest. A “process” attribute is added to each component tag in the manifest, specifying
under which process it runs. Further tags are added to the manifest, encoding allowed inter-process
communication and process permissions. We then repackage the app into an APK.
4.9
Enforcement
Package installation. During app installation of a repackaged app on our modiﬁed Android platform,
when users are prompted to approve app permissions, they are also informed about information
ﬂows guaranteed not to occur in the app (see Figure 4). These simple-to-understand guarantees
are derived from the app’s embedded policy, and end-users are not burdened with implementation
details about decomposition, components and processes.
17
Figure 4: Scrolling down the app permission view, presented on app installation for user approval
and accessible also from the “Application Management” menu.
App runtime. To run components in diﬀerent processes, we utilize the optional and rarely used
(standard Android-API) “process” attribute, added to component declarations in the repackaged
app’s manifest. This allows running a component or a set of components in a separate, uniquely
named, process. To enforce the IFC policy, we modify Android’s ActivityManager service to monitor
all cross-process ICC and resource use at process granularity (rather than app granularity). The
monitor allows or denies events according to the policy in the app’s Manifest.xml ﬁle, and based
on the operation initiator’s process UID as well as its PID (identifying the process within the
app). Operations requiring permissions are allowed if the policy grants the process this permission.
Components are protected with an extra permission to send ICC to their containing process, granted
to the appropriate processes. The monitor does not, itself, handle information ﬂow between the
processes via Linux system calls; this challenge is well-studied and addressed in prior systems such
as Flume [KYB+07], ASM’s Aquifer hooks [HNES14, NE13], and others [XSA12, BDD+12]. Thus,
we have reduced the hard intra-app IFC problem to the well-studied inter-process IFC problem.
4.10
Implications of Analysis Error
As previously discussed, the dynamic analysis guiding the policy generation is imperfect and relies on
some heuristics for handling corner cases or critical performance issues. It is essential to understand
their implications. Missed ﬂows (false negatives) can result in overly-restrictive generated policies,
possibly breaking app functionality. Reported ﬂows that do not really occur (false positives) can
result in too-permissive generated policies, which the app curators/reviewers/users may not approve.
But neither break security guarantees: if a policy is approved, the information ﬂow it speciﬁes will
be enforced.
Thus, we err on the side of caution: impaired functionality (especially on the relatively coarse
whole-component level) can be discovered with manual or automated testing of the app, e.g., by re-
running the app analysis and acceptance tests after the decomposition; unsound policy enforcement
would have been much less noticeable and harder to analyze.
Notably, we only aim at capturing ﬂows which are forms of inter-component communication
intended by the developer or important for the app’s legitimate operation. In particular, tracking
implicit ﬂows would be of very little beneﬁt to us: they’re rarely used for intentional inter-component
18
communication, and most techniques for tracking them would simply incur a vast number of false
positives [KHHJ08], making our generated policies trivially permissive. Not tracking implicit ﬂows
does not make DroidDisintegrator more vulnerable, but rather the opposite:
if an app developer
uses implicit ﬂows to smuggle information to circumvent app vetting techniques, DroidDisintegrator
will not report this ﬂow in the analysis stage, and simply prevent it in the enforcement stage.
5 Empirical Results
We evaluated DroidDisintegrator on third-party apps from the Android app market, as follows.
We used a snapshot of the Android app market from 2011 (for compatibility with Appsplay-
ground), and chose the 100 apps which use the largest number of permissions. These had 20–48
permissions each, typical for popular apps (e.g., the average number of permissions requested across
the 10 most popular free non-game apps as of 11.2014 was ∼34). We ran DroidDisintegrator on
these apps. In 84 of the cases, our fuzzer successfully ﬁnished the experiment. Some of the remain-
ing 16 apps crashed multiple times, suggesting problems more serious than unwanted information
ﬂows; in a few cases the fuzzer itself malfunctioned. For these 84 apps, we generated policies and
repackaged them.
Most (43) of the successfully fuzzed apps utilized more than 5 permissions, as detected by
fuzzing. DroidDisintegrator identiﬁed and enforced preventable information ﬂows in 20 of these
apps (∼46%). We re-ran these apps under the fuzzer after repackaging, and there was no change
in app behavior as far as fuzzing could tell. We manually and heuristically operated them, and did
not observe any broken functionality either. The remaining cases were detected to have information
ﬂows from all sources to all sinks used; in these cases DroidDisintegrator’s policy still revoked the
permissions which aren’t used at all by the app.
The remaining (41) successfully-fuzzed apps utilized very few permissions (5 or less), as detected
by fuzzing, so there were few potential information ﬂows to block. Nonetheless, DroidDisintegrator
identiﬁed and enforced preventable information ﬂows in 6 of them.
The apps used 15.2 permissions on average, and after decomposition each component process
only used 4.2 permissions on average. Thus, we greatly reduced decomposed app permissions (to
less than a third of their original number).
The most commonly observed type of a preventable ﬂow is from the RECEIVE SMS source to
various sinks (internet, storage, etc.). Inspecting these apps, we observe that the entry points and
control ﬂow that handle incoming SMSs indeed have little interaction with the rest of the app.
That means the app could (under Android’s normal permission semantics) forward users’ SMS
messages to rogue parties, but actually do not exploit that capability; DroidDisintegrator enforces
this behavior and conveys it to the user. This is demonstrated in Figure 5.
Policy Learning Performance. Generaring the policy, including fuzzing and dynamic analysis, took
43min (averaged over 100 apps), running inside a Ubuntu 11.10 VM with 4 cores and 8 GB of RAM,
on an Intel Core i7-3720QM 2.6GHz CPU, 32GB of RAM. This is trivially parallelizable, and seems
quite practical for developers, app stores, or CISOs.
Enforcement Performance. The enforcement itself, which is performed on the decomposed version
of apps, has negligible overhead (merely checking membership of a permission in a set, in a code
path that already contains heavyweight RPC). The app decomposition does add an overhead, since
it increases the number of app processes (repackaged apps deﬁne, on average, 3.8 processes, instead
of the typical single process), and causes Android to use serialization for some ICC that originally
19
Figure 5: Inter-component communication and component resource use graph for “Executive Assist”
(“com.appventive.ActiveLock”), a productivity utility. See Figure 3 for notation.
passed its arguments as pointers. Systematic evaluation of these overheads is diﬃcult, due to the
interactive behavior of apps, but we provide the following anecdotal evidence that the overhead is
low.
We performed quantitative comparisons between two environments: one is an emulator with 10
decomposed apps installed (the decomposed environment), and the other is an emulator with the
original (non-decomposed) packages installed (non-decomposed environment). In terms of process
count: when exercising 3 of the installed apps in sequence under the fuzzer, we observe an average
over time of 51.1 active processes in the decomposed environment, versus 50.0 in the non-decomposed
environment. Device and app responsiveness: 8 of the installed apps are registered to the “boot
complete” broadcast event, and 6 of them are registered to the “SMS received” broadcast events.
Handling of these events is sequential: one app must ﬁnish before the other begins. Averaged over
10 reboots, the handling time for the “boot complete” event (time from event dispatch until the last
app ﬁnishes) is 309 seconds in both environments. Averaged over 100 received SMSs, the handling
time for the “SMS received” event was 0.57 seconds for the non-decomposed environment and 0.61
seconds for the decomposed environment (a 6.5% increase).
6 Conclusions and Future Directions
In this work, we showed how to constrain the behavior and reduce the risk of Android apps, based on
a key observation that the modular component-centered design of apps oﬀers a natural granularity at
which to apply Information Flow Control. In our implemented workﬂow, apps are ﬁrst dynamically
analyzed to deduce a policy about their internal information ﬂows, and this policy is embedded in
the app installation package. After installation, the device enforces the policy. We implemented
the analysis tools required by this process, building and improving upon prior research eﬀorts. We
ran our analysis on real-world apps and produced useful enforcement policies for many of them,
reducing both the number of possible information ﬂows within the app and the privileges under
which each component runs.
Our approach and ﬁndings open myriad research directions for extensions to new applications
and platforms.
Fuzzing. Policy generation uses dynamic analysis, which relies on exploration of the app’s behavior
using fuzzing. Code coverage and performance may be improved using state-of-the-art fuzzing mech-
anisms such as PUMA [HLN+14] and Brahmastra [BHJ+14], once adapted to triggering information
ﬂows.
20
android.permission.WRITE_SMSandroid.permission.RECEIVE_SMSsmsSMSReceiverandroid.permission.INTERNETandroid.permission.WRITE_SETTINGSandroid.permission.READ_SMSdataDBProviderdataAlarmServicedataAlarmReceiverActiveLockGettingStartedandroid.permission.ACCESS_COARSE_LOCATIONandroid.permission.GET_ACCOUNTSTaint tracking. Better heuristics and taint-tracking would reduce falsely-reported ﬂows and detect
decomposable ﬂows (see Section 4.1.1), and thus tighten the generated policies. Likewise, static
analysis can be used. Our system is based on the Android 2.1 branch of TaintDroid, and adapting
it to the latest TaintDroid will improve app compatibility and taint accuracy. Analysis support for
Android’s ART runtime is desirable(and probably feasible [Gro]).
Beyond Android. Our approach may be applicable to other platforms, especially modern mobile de-
vice platforms that use event-driven frameworks. While Android’s explicit “component” abstraction
is especially convenient, units of similar granularity may deﬁned by the programmer or synthesized
by analyzing data ﬂow from the app’s entry points.
DIFC. Our approach can be extended to Decentralized Information Flow Control, allowing dis-
cretionary access controls and ﬁner-grained, application-dependent labeling of components and
data [KYB+07, KNK+12, JAF+].
Side channels and covert channels. As in most works on information ﬂow control and mandatory
access controls, our system does not address the risk of covert platform channels [Hu92], or side
channels such as cache attacks [OST06, Per05]. We note that covert exploitation of such channels
is harder in the context of curated app stores.
Enhanced Enforcement Capabilities. It is natural to consider building an Android Security Mod-
ule (ASM [HNES14]) to enhance DroidDisintegrator’s enforcement abilities. Alternatively, Aura-
sium [XSA12] can be used to embed policy enforcement in the app bundle itself.
Android M Dynamic Permissions. In upcoming Android Version 6 (Marshmallow), some app per-
missions are granted at runtime and on-demand. Component process separation can be extended
to leverage such a dynamic security label model, where dangerous information ﬂows are reported
at runtime and approved by the user on-demand.
Declassiﬁers. Declassiﬁers are a powerful feature in IFC, allowing otherwise forbidden information
ﬂows to occur under speciﬁc, explicit, and carefully-reviewed conditions. For example, the constraint
that “information must not ﬂow from the contact list into outgoing SMS messages” is desirable
but often too restrictive (e.g., it might forbid the application from auto-completing a contact’s
phone number when the user composes an SMS). This may be relaxed into the constraint “contact
information ﬂowing into outgoing SMS messages must be approved by the user before sending”.
The relaxation requires a piece of trusted code (e.g., an Activity) that presents to the user whatever
the application wants to send in an SMS and (upon user approval) invokes the SMS-sending API.
The declassiﬁer’s simple, trusted code can be explicitly designated as such, and bundled in source
form with the app (along with requisite evidence of consistency with the binary) for inspection by
users and app curators.
Acknowledgments.
This work was supported by the Check Point Institute for Information
Security; by a Google Faculty Research Award; by the Israeli Ministry of Science and Technology;
by the Israeli Centers of Research Excellence I-CORE program (center 4/11); and by the Leona M.
& Harry B. Helmsley Charitable Trust.
References
[AGL+12]
Owen Arden, Michael D George, Jed Liu, K Vikram, Aslan Askarov, and Andrew C
Myers. Sharing mobile code securely with information ﬂow control. In IEEE Sympo-
21
[ARB13]
[ARF+14]
[AZHL12]
[BBC+13]
[BDD+]
[BDD+12]
[BHJ+14]
[BJM+15]
[CFB+15]
[CFGW11]
[CGL+14]
[CLM+07]
sium on Security and Privacy 2012. IEEE, 2012.
Steven Arzt, Siegfried Rasthofer, and Eric Bodden. SuSi: A tool for the fully au-
tomated classiﬁcation and categorization of Android sources and sinks. Technical
Report TUD-CS-2013-0114, EC SPRIDE, 2013.
Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick McDaniel. Flowdroid:
Precise context, ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for an-
droid apps.
In Programming Language Design and Implementation (PLDI) 2014.
ACM, 2014.
Kathy Wain Yee Au, Yi Fan Zhou, Zhen Huang, and David Lie. Pscout: analyzing
the Android permission speciﬁcation. In ACM Conference on Computer and Com-
munications Security (CCS) 2012. ACM, 2012.
Aline Bousquet, J´er´emy Briﬀaut, Laurent Cl´evy, Christian Toinard, Benjamin
Venelle, et al. Mandatory access control for the android dalvik virtual machine.
In ESOS 2013, 2013.
Sven Bugiel, Lucas Davi, Alexandra Dmitrienko, Thomas Fischer, and Ahmad-Reza
Sadeghi. Xmandroid: A new android evolution to mitigate privilege escalation attacks.
Technische Universit¨at Darmstadt, Technical Report TR-2011-04.
Sven Bugiel, Lucas Davi, Alexandra Dmitrienko, Thomas Fischer, Ahmad-Reza
Sadeghi, and Bhargava Shastry. Towards taming privilege-escalation attacks on An-
droid. In Network and Distributed System Security Symposium (NDSS) 2012, 2012.
Ravi Bhoraskar, Seungyeop Han, Jinseong Jeon, Tanzirul Azim, Shuo Chen, Jaeyeon
Jung, Suman Nath, Rui Wang, and David Wetherall. Brahmastra: Driving apps to
test the security of third-party components. In USENIX Security Symposium 2014.
USENIX Association, 2014.
Paulo Barros, Ren´e Just, Suzanne Millstein, Paul Vines, Werner Dietl, Marcelo
d’Amorim, and Michael D Ernst. Static analysis of implicit control ﬂow: Resolv-
ing java reﬂection and android intents. In IEEE/ACM International Conference on
Automated Software Engineering (ASE 2015) 2015, 2015.
Yinzhi Cao, Yanick Fratantonio, Antonio Bianchi, Manuel Egele, Christopher
Kruegel, Giovanni Vigna, and Yan Chen. Edgeminer: Automatically detecting im-
plicit control ﬂow transitions through the android framework. In Network and Dis-
tributed System Security Symposium (NDSS) 2015, 2015.
Erika Chin, Adrienne Porter Felt, Kate Greenwood, and David Wagner. Analyzing
inter-application communication in Android. In International Conference on Mobile
systems, applications, and services (MobiSys) 2011. ACM, 2011.
Landon P Cox, Peter Gilbert, Geoﬀrey Lawler, Valentin Pistol, Ali Razeen, Bi Wu,
and Sai Cheemalapati. Spandex: Secure password tracking for android. In USENIX
Security Symposium 2014, 2014.
Stephen Chong, Jed Liu, Andrew C Myers, Xin Qi, Krishnaprasad Vikram, Lantian