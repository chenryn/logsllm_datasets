title:JGRE: An Analysis of JNI Global Reference Exhaustion Vulnerabilities
in Android
author:Yacong Gu and
Kun Sun and
Purui Su and
Qi Li and
Yemian Lu and
Lingyun Ying and
Dengguo Feng
2017 47th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
JGRE: An Analysis of JNI Global Reference
Exhaustion Vulnerabilities in Android
Yacong Gu∗†, Kun Sun‡, Purui Su∗§, Qi Li†, Yemian Lu∗, Dengguo Feng∗, Lingyun Ying∗§
∗Institute of Software, Chinese Academy of Sciences †Graduate School at Shenzhen, Tsinghua University
‡Department of Information Sciences and Technology, George Mason University
§University of Chinese Academy of Sciences
{guyacong, luyemian, feng}@tca.iscas.ac.cn, PI:EMAIL, {purui, lingyun}@iscas.ac.cn, PI:EMAIL
Abstract—Android system applies a permission-based security
model
to restrict unauthorized apps from accessing system
services; however, this security model cannot constrain autho-
rized apps from sending excessive service requests to exhaust
the limited system resource allocated for each system service.
As references from native code to a Java object, JNI Global
References (JGR) are prone to memory leaks, since they are not
automatically garbage collected. Moreover, JGR exhaustion may
lead to process abort or even Android system reboot when the
victim process could not afford the JGR requests triggered by
malicious apps through inter-process communication.
In this paper, we perform a systematic study on JGR exhaus-
tion (JGRE) attacks against all system services in Android. Our
experimental results show that among the 104 system services
in Android 6.0.1, 32 system services have 54 vulnerabilities.
Particularly, 22 system services can be successfully attacked
without any permission support. After reporting those vulnera-
bilities to Android security team and getting conﬁrmed, we study
the existing ad hoc countermeasures in Android against JGRE
attacks. Surprisingly, among the 10 system services that have
been protected, 8 system services are still vulnerable to JGRE
attacks. Finally, we develop an effective defense mechanism to
defeat all identiﬁed JGRE attacks by adopting Androids low
memory killer (LMK) mechanism.
I. INTRODUCTION
Smartphones are playing an increasingly important role in
our daily life. As one of the two most popular mobile OSes
on smartphones, Android has been actively used by over one
billion users. Due to its popularity and open source feature,
Android becomes the target for various malicious attacks
such as private data leakage [23], [27], [38], [47], application
repackaging [26], [32], [49], and components hijacking [20],
[25], [36].
Android system adopts a permission-based security model
to restrict unauthorized requests from accessing the critical
system services. However, this permission model can only
provide a coarse-grained access control on if an app is allowed
to access system resources, but it cannot enforce a ﬁne-grained
control on how many system resources one app may consume.
Due to this limitation, Android system suffers from resource
exhaustion based Denial of Service (DoS) attacks [16], [24],
[33], [35], [42].
Java Native Interface (JNI) [8] is a programming framework
that enables Java code to call and be called by native applica-
tions and libraries written in other languages such as C, C++,
or assembly. JNI enables programmers to write native methods
to handle situations when an application cannot be written
entirely in Java. Java objects are passed by reference between
Java and native code. The Java VM uses those references to
keep track of all objects that have been passed to the native
code.
There are two types of JNI references. JNI local references
are valid for the duration of a native method call, and they
are automatically freed after the native method returns. JNI
global references (JGR) remain valid until they are explicitly
freed, which makes the use of JGR prone to memory leaks.
What makes it worse is that malicious apps may exhaust JGR
of victim processes via inter-process communication (IPC),
and system services in Android provide thousands of IPC
interfaces that can be misused by malicious apps. When the
number of JGR in one process’s runtime exceeds a system
upper bound threshold (i.e., 51200), this victim process aborts.
This JGR exhaustion (JGRE) attack poses a serious threat to
Android, since it may lead to process abort or even Android
system reboot. The Android team has noticed this problem
and has ﬁxed a few JGRE vulnerabilities in system services
such as WiFi service [3] and Notiﬁcation service [2]. However,
those ad hoc defenses cannot guarantee to identify and ﬁx all
potential JGRE vulnerabilities.
In this paper, we ﬁrst perform a systematic analysis of
all potential JGRE vulnerabilities in Android. We develop a
four-step JGRE analysis method to identify all vulnerable IPC
methods in system services and apps that can be exploited by
malicious apps. We ﬁrst ﬁnd all IPC interfaces from Android
source code. Next, we identify all the operations of adding
JGR entries in both Java code and native code. After obtaining
both IPC methods and JGR entry adding points, we can build a
call graph and then use static analysis to ﬁlter out all potential
vulnerable IPC methods. Finally, we perform dynamic tests on
each vulnerable IPC method to further verify its correctness.
We study the JGRE vulnerabilities in Android 6.0.1 and
ﬁnd that 32 out of 104 (30.8%) system services contain 54
vulnerable IPC interfaces that may be exploited by third-party
apps to launch JGRE based DoS attacks. In addition, we ﬁnd
2 pre-built core apps contain 3 vulnerable IPC interfaces. 44
out of the total 57 vulnerable IPC interfaces have not been
ﬁxed; even among the 13 vulnerable interfaces that have been
2158-3927/17 $31.00 © 2017 IEEE
DOI 10.1109/DSN.2017.40
427
protected by Android, 10 interfaces still suffer from JGRE
attacks. We have submitted all the vulnerabilities to Android
Security Team and received multiple Android Bug ID.
it
their limitations. We also point out
Next we perform a study on why Android team has not
succeeded on completely ﬁxing the JGRE attacks. We classify
those threshold based ad hoc defenses into two categories,
either performing JGR checking in system service helpers or
performing JGR checking in the system services, and then
point out
two major
challenges. First, due to the fragmentation of the Android
ecosystem,
is challenging to choose speciﬁc thresholds
suitable for all apps and all devices. Moreover, since different
interfaces provide different functions, the thresholds vary in
those interfaces. If the thresholds cannot be correctly set,
Android system will have a severe usability problem. Second,
since most system services run in the system server process
and share one JGR table, one vulnerable interface in any
system service can abort the system server process and crash
the system.
Finally, we propose a real time defense mechanism against
JGRE attacks. It consists of three phases. First, we dynam-
ically capture a victim process incurring creation of a large
number of its JGR entries that exceeds an alarm threshold.
According to our observation, the number of JGR for each
system service used by benign apps is stable and small, we
can safely set a ﬁxed alarm threshold on JGR entry creation.
Second, we rank each app’s impact on victim process’s JGR
creation by performing correlation analysis on the runtime log
that records the time when the corresponding IPC method
is invoked and the time of JGR entry creation and deletion,
which is based on another observation that, for all vulnerable
IPC interfaces, the duration from invoking an IPC call to
creating a JGR entry varies within a small value. Finally,
we recover the system by killing the top ranking apps before
the victim process’s JGR entries are exhausted. The recovery
phase is similar to Android’s low memory killer (LMK) [41]
and comply with the Android system speciﬁcation [13] that
speciﬁes that any app can be killed to release the resources if
certain system resources are almost exhausted. We implement
our solution on an Nexus 5X phone installed Android 6.0.1.
The experimental results show that it can successfully defend
against all the identiﬁed 57 vulnerabilities and can even detect
the JGRE attacks from multiple colluding malicious apps.
In summary, we make the following contributions.
• We systematically study the JNI global resource ex-
haustion (JGRE) vulnerabilities in Android. We develop
a toolset
to analyze the newest Android system. We
discover 54 JGRE vulnerabilities in 32 system services
and 3 JGRE vulnerabilities in 2 pre-built apps. We also
ﬁnd some vulnerable apps in Google Play.
• We study the state-of-the-art defense mechanism against
JGRE attacks. We ﬁnd out that current Android system
adopts an ad hoc way to selectively ﬁx a small number
of vulnerable system services, and it lacks a defense
solution to efﬁciently protect all system services from
JGRE attacks.
• We develop a new defense mechanism that can prevent
JGRE attacks with small performance overhead. The
experimental results show that it can defend against all
identiﬁed vulnerabilities and can detect multiple collud-
ing malicious apps.
II. JGRE ATTACKS
A. Background
The Java Native Interface (JNI) is part of the Java Software
Development Kit (SDK). It allows Java code use code and
code libraries written in other languages. On the other hand,
the Invocation API, which is part of JNI, can be used to embed
a Java virtual machine (JVM) into native applications, thereby
allowing native code to call Java code [8]. JNI divides the
objects referenced by native code into two categories: local
reference and global references [8]. JNI local references are
valid for the duration of a native method call, and they are
automatically freed after the native method returns. JNI global
references (JGR) remain valid until they are explicitly freed.
System services are the core components of Android to
support various functions to apps, and Android provides
Binder mechanism to achieve inter-process communication
(IPC) between apps and system services. A number of IPC
interfaces opened by system services to third-party apps
will create new JGR entries after receiving service requests
from third-party apps. In Android, each process has its own
dedicated Android runtime (Dalvik VM or ART runtime)
along with individual runtime resource management. There
is an upper bound JGR threshold (i.e., 51200), hard-coded
in art/runtime/java vm ext.cc, on the number of JNI Global
Reference (JGR) that each Android Runtime can sustain.
Therefore, when a malicious app can make one victim process
have more JGR entries than the upper bound threshold, the
victim process’s runtime will abort. We name this type of DoS
attack as JNI Global Reference Exhaustion (JGRE) attack.
We know that most system services run as threads inside
the system server process, so the total number of JGR entries
created by all those system services is constrained by the JGR
threshold of system server, which is also 51200. When the
runtime of the system server process aborts, the entire Android
system crashes, followed by a soft reboot. For instance, clip-
board service runs in system server process as a thread, and it
has one vulnerable IPC interface addPrimaryClipChangedLis-
tener(), which adds a clipboard listener that will be notiﬁed
when the content in system’s primary clipboard changes. Once
an app invokes this interface, the clipboard service allocates
new JGR entries in its own process, and those JGR entries
will not be released until the corresponding app process exits.
Therefore, a malicious app can invoke a large number of IPC
calls to exhaust the JGR entries of the system server process,
leading to soft reboot of Android system.
B. Challenges on Defeating JGRE
Android permission-based security model cannot success-
fully prevent JGRE attacks since it does not provide a ﬁne-
grained control on the process resources such as JNI global
428
reference that may be consumed by each authorized app.
Android team has noticed JGRE attacks and ﬁxed a few
vulnerable system services such as WiFi service [3] and
Notiﬁcation service [2]. However, JGRE attacks have not been
well studied. Since there is no systematic work on identifying
potential JGRE attacks against all system services in Android,
the threat of JGRE attacks has not been fully recognized.
There are three challenges to discover all JGRE vulnera-
bilities in a given Android system. First, we should ﬁnd all
IPC methods that may be accessed by third-party apps. The
number of system services and prebuilt apps increases along
with the evolvement of the Android system. For instance,
Android version 6.0.1 contains 104 system services and 88
prebuilt apps, which provide thousands of IPC methods. Most
IPC interfaces are deﬁned in AIDL ﬁles and can be easily
located; however, some IPC interfaces are not, and we have
to analyze both Java code and native code, since 5 system
services are implemented in native code. Second, we need to
identify all attack paths on JGR. JGR’s add entry and remove
entry interfaces are implemented in native code; however, most
of the real call stack that triggers add and remove operations
are from Java code. Thus, it is important to investigate all Java
code and native code to ﬁnd the operations on JGR. Third, we
should identify the vulnerable IPC methods. There may exist
a large number of interfaces that may allocate JGR resources;
however, since JGRE can succeed only when a large number
of JGR can be allocated but cannot be released quickly, we
need to develop a mechanism to narrow down to the real JGRE
vulnerabilities.
Due to the lack of fully understanding of JGRE attacks,
existing solutions against JGRE attacks are ad hoc and only
pertinent to speciﬁc system services. Android has not provided
one generic countermeasures against all JGRE attacks.
III. JGRE ANALYSIS METHODOLOGY
Figure 1 shows the methodology for systematically analyz-
ing JGRE vulnerabilities that may be exploited by malicious
third-party apps to launch DoS attacks in Android system.
We target at identifying all vulnerable IPC methods, which
can be accessed by third-party apps to exhaust JNI global
references. Our analysis consists of four major components,
namely IPC method extractor, JGR entry extractor, Vulnerable
IPC detector, and JGRE Veriﬁcation. IPC method extractor
is responsible for locating all IPC interfaces from Android
source code. JGR entry extractor focuses on identifying all the
add operations of JGR entries in both Java code and native
code. After obtaining both IPC methods and JGR entry adding
points, we can build a call graph and then use static analysis in
the vulnerable IPC detector to ﬁnd out all potential vulnerable
JGRE locations. Since only JGR entries that cannot be revoked
efﬁciently may lead to JGRE attacks, we further ﬁlter out
those innocent JGR operations. Finally, to improve the report
accuracy on JGRE locations, we perform dynamic tests on
each vulnerable JGRE location to verify its correctness in the
JGRE veriﬁcation step.
429
(cid:2)(cid:22)(cid:17)(cid:24)(cid:23)(cid:20)(cid:17)(cid:1)(cid:12)(cid:23)(cid:27)(cid:24)(cid:16)(cid:18)(cid:1)(cid:3)(cid:23)(cid:17)(cid:18)
(cid:7)(cid:10)(cid:3)(cid:1)(cid:9)(cid:18)(cid:26)(cid:19)(cid:23)(cid:17)(cid:25)(cid:1)
(cid:5)(cid:28)(cid:26)(cid:24)(cid:14)(cid:16)(cid:26)(cid:23)(cid:24)
(cid:8)(cid:6)(cid:11)(cid:1)(cid:5)(cid:22)(cid:26)(cid:24)(cid:29)
(cid:5)(cid:28)(cid:26)(cid:24)(cid:14)(cid:16)(cid:26)(cid:23)(cid:24)
(cid:13)(cid:27)(cid:21)(cid:22)(cid:18)(cid:24)(cid:14)(cid:15)(cid:21)(cid:18)(cid:1)(cid:7)(cid:10)(cid:3)(cid:1)(cid:4)(cid:18)(cid:26)(cid:18)(cid:16)(cid:26)(cid:23)(cid:24)
(cid:8)(cid:6)(cid:11)(cid:5)(cid:1)(cid:1)(cid:13)(cid:18)(cid:24)(cid:20)(cid:30)(cid:16)(cid:14)(cid:26)(cid:20)(cid:23)(cid:22)
(cid:4)(cid:3)(cid:5)(cid:2)(cid:1)(cid:6)(cid:16)(cid:11)(cid:12)(cid:9)(cid:13)(cid:7)(cid:8)(cid:10)(cid:11)(cid:10)(cid:15)(cid:10)(cid:9)(cid:14)
Fig. 1. JGRE analysis methodology
A. IPC Method Extractor
The goal of this component
is to ﬁnd out a complete
list of IPC methods provided by both system services and
prebuilt apps. First, we can ﬁnd most IPC interfaces from
ServiceManager, which records the IPC interfaces from the
registered system services. We use SOOT [46] to study the
compiled class ﬁles of Android Open Source Project (AOSP)
version 6.0.1. We extract all classes’ hierarchy and each class’s
methods. Particularly, we ﬁnd out all the system services’
classes that register IPC interfaces to ServiceManager through
the addService and publishBinderService Java methods. In ad-
dition, we discover 5 native system services whose classes pro-
vide IPC interfaces through the ServiceManager::addService
native method. Next, we ﬁnd IPC interfaces from the classes in
both Java code and native code. Among all classes that have
AIDL deﬁnitions or are inherit classes based on IInterface
class, if one class has one method overriding AIDL deﬁnition
or IInterface, we consider this method as one IPC method.
Second, some base service class for app extension provides
some default IPC interface implementation. Several pre-built
core apps (e.g. Bluetooth, TTS) extend those base service class
and can provide services to third-party apps through IPC inter-
faces. To ﬁnd this type of IPC methods, we locate all abstract
service classes and look up the IBinder interface returned from
asBinder(). The methods contained in the IBinder interface are
marked as IPC methods.
B. JGR Entry Extractor
JGR entry extractor
that call
targets at ﬁnding all
IndirectReferenceTable::Add(uint32 t
Java and
the JGR add method in the
native methods
code. The method to add JGR entry in the
native
code
native
cookie,
mirror::Object* obj). However,
IPC
methods are implemented in Java code, which calls the
“IndirectReferenceTable::Add()” method through JNI mecha-
nism. For instance, as Figure 2 shows, since the JNI method
android os Parcel::android os Parcel readStrongBinder()
calls
chain, we
Parcel.nativeReadStrongBinder() as an JGR entry.
IndirectReferenceTable::Add()
in Android, most
through
a
call
Java method
record
the
corresponding