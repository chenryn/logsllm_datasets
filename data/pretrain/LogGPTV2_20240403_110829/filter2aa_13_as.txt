2）通过Elf32_Phdr中的p_type字段，找到DYNAMIC。从下图可以看出，其实DYNAMIC就是.dynamic section。从p_offset和p_filesz字段得到文件中的起始位置和长度。
3）遍历.dynamic，找到.dynsym、.dynstr、.hash section文件中的偏移和.dynstr的大小。在我的测试环境下，fedora 14和windows7 Cygwin x64中elf.h定义.hash的d_tag标示是：DT_GNU_HASH；而安卓源码中的是：DT_HASH。
4）根据函数名称，计算hash值。
5）根据hash值，找到下标hash%nbuckets的bucket；根据bucket中的值，读取.dynsym中对应索引的Elf32_Sym符号；从符号的st_name索引找到在.dynstr中对应的字符串与函数名进行比较。若不等，则根据chain[hash%nbuckets]找下一个Elf32_Sym符号，直到找到或者chain终止为止。这里叙述得有些复杂，直接上代码表示：
6）找到函数对应的Elf32_Sym符号后，即可根据st_value和st_size字段找到函数的位置和大小。
7）后面的步骤就和上节相同了，这里就不赘述。
2.解密流程
解密流程为加密逆过程，大体相同，只有一些细微的区别，具体如下：
·找到so文件在内存中的起始地址。
·通过so文件头找到Phdr；从Phdr找到PT_DYNAMIC后，需取p_vaddr和p_filesz字段，并非p_offset，这里需要注意。
·对内存区域数据的解密，也需要注意读写权限问题。
14.2.3 代码实现
1.native程序
代码如下：
代码逻辑和前一节的加密section中的代码类似，只是在寻找函数的地方有点不同，在加密的代码中说明一下。
2.加密程序
代码如下：
解密程序需要说明一下。
1）定位到.dynamic的segment，解析成elf32_dyn结构信息：
这里有一个解析elf32_dyn结构：
需要注意的是，elf32_dyn中用到了联合体union结构，Java中是不存在这个类型的，所以需要了解这个联合体的含义，虽然是三个字段，但是大小是8个字节，而不是12字节。dyn.d_val和dyn.d_val是在一个联合体中的。
2）计算目标函数的hash值，得到函数的偏移值和大小：
逻辑有点绕，了解原理即可。其中nbucket和nchain、bucket[i]和chain[i]都是4个字节，它们的值就是目标函数在.dynsym中的位置。
上面对so中的函数加密成功了，那么下面来验证加密，直接使用IDA进行查看，如图14-10所示。
可以看到，加密的函数内容已经面目全非了，看不到信息了。比较加密前的文件，如图14-11所示。
提示：案例下载地址为http://download.csdn.net/detail/jiangwei0910410003/9289009
3.测试Android项目
用加密之后的so文件来测试一下：
图14-10 IDA查看so文件
图14-11 加密前so的内容
运行结果如图14-12所示。
图14-12 运行结果
14.3 本章小结
本章主要介绍了通过加密so中的section和函数来实现加固功能，有了这个so加固方案之后，可以让App开发更加安全，破解难度加大。但是也不能说是绝对安全了，比如现在破解者在init_getString函数下断点，然后动态调试一下，就可以很轻易地破解了，而且通过dump出内存中运行的dex也是可以做到的。所以，没有绝对的安全，只有相对的攻防。
工具篇
第15章 Android逆向分析基础
第16章 反编译神器apktool和Jadx
第17章 Hook神器Xposed
第18章 脱壳神器ZjDroid
第19章 Native层Hook神器Cydia Substrate
第15章 Android逆向分析基础
Android逆向技术不是陌生的话题，网上已经有很多资料，本章主要介绍一下关于逆向分析apk的时候需要做些什么。在逆向之前必须有好工具，其次是还需要掌握逆向的基本知识：smali语法和arm指令，能够大致读懂程序。
15.1 逆向工具
这里介绍几个工具，而且这几个工具在后面的章节中都会用到。
1.反编译利器apktool
这个工具用Java语言写的，而且也是开源的，同时它是逆向的金钥匙，所以非常重要，而且现在很多apk为了防止被这个工具反编译，就针对这个工具的漏洞做了一层防护策略，如果要成功反编译各个apk的话，那么就必须看懂它的源码，然后针对具体反编译异常具体分析，修复异常即可。
2.反编译姐妹花dex2jar+jd-gui
这两个工具其实是辅助使用的，一般是直接解压apk得到classes.dex文件，使用dex2jar转化成jar文件，使用jd-gui来直接查看Java源码。
3.反编译友好工具JEB和Jadx
这两个工具其实是整合了上面两个工具的功能，让反编译实现了可视化操作，而且高效快捷，适合在快速分析apk内部信息的场景，也是不可或缺的工具。
4.Hook神器Xposed框架
这个工具主要用于编写游戏外挂，获取应用关键数据此工具也可以算得上神器，有了它，逆向App就是手到擒来的事，用它可以把每个App的关键逻辑分析得非常清楚。
5.Native Hook神器Cydia Substrate
这个工具和上面的Xposed框架非常类似，但是这个工具除了可以Hook Java层功能，还可以很方便地Hook Native层功能。对于一些游戏和应用有so文件，可以利用这个框架进行hook so中的指定函数功能。
6.脱壳神器ZjDroid工具
现在很多应用为了安全，做了加固策略，那么逆向中有一个技术是脱壳就是针对加固策略的。所谓脱壳就是要把原本加固的应用进行解密，那么ZjDroid工具就是一款脱壳神器。这个工具其实是基于前面的Xposed框架编写的。
7.堪称神器的工具IDA
这个工具不用多解释了，如果说搞逆向不知道这个工具，那就等于还没有进入逆向的大门，比较可惜的是它是收费的。这个工具最厉害的地方就是它能够分析so文件，同时可以动态调试so，而且可以打开apk文件，dex文件也是不在话下的。
15.2 逆向基本知识
要学习逆向，除了有利的工具，还需要了解一些基本知识，比如smali语法、arm指令、Android中的NDK开发等，因为这些都是在逆向过程中经常会用到的知识。
smali语法是逆向的基础核心知识，有的人觉得这个是否是一门新的语言？其实不然，它的语法非常简单，熟悉起来非常方便。比如后面章节会利用smali语法手动插入代码，而并不是需要手动编写smali代码，可以先用Java编写好功能，再反编译成smali代码，再手动插入即可。但是简单的smali语法还是需要看懂，比如赋值、方法调用等操作，具体smali语法知识，在后面章节会详细介绍。
arm指令就不多说了，在大学期间就有这门课，不过很多人可能在项目开发中并没有用到，但是arm指令知识对于逆向来说也是至关重要，也是最为复杂的，现在很多应用为了更加安全就把代码都放到了so中，这样在逆向so文件的时候就必须要了解arm指令，才能大致看懂逻辑代码，才能继续后面工作。arm指令也并非那么复杂，多看多读就会慢慢熟练了。相关命令在后面章节会详细介绍。
15.3 打开系统调试总开关
本节将介绍如何在不需要反编译的情况下添加android：debuggable属性，就可以进行调试。现在已经有很多工具可以做这件事了，先来说说具体的原理吧。
其实Android中有一些常用的配置信息都是存放在一个文件中，如下所示，比如设备的系统、版本号、CPU型号等信息，这个文件位置在：/system/build.prop。
查看文件的内容，可以看到很多设备的信息，而且这些ro开头的文件表示这些属性值是只读的，不能进行修改的。
同时Android中提供了两个命令来操作这些信息：getprop和setprop命令，如下所示：
查看系统的sdk版本号如下所示：
设置系统的sdk版本号为22，可是这里并没有修改成功，原因是因为ro开头的属性是不允许后期修改的。如果修改，需要重新编译系统镜像文件boot.img，但是这里并不是本节介绍的重点。
既然Android中的一些系统属性值存放在一个文件中，而且这些值是只读的，当然不仅可以通过getprop命令读取，有一个API也是可以直接读取的，就是：
其实这个方法是native层实现的，具体就不分析了。那么这个文件是存储这些属性值的，是谁来进行解析加载到内存中，能够给每个App都能访问到呢？
这个工作就是init.rc进程操作的，系统启动时第一步就是解析init.rc文件，这个文件是在系统的根目录下，这里会做很多初始化操作，同时会做属性文件的解析工作，所以Android属性系统通过系统服务提供系统配置和状态的管理。为了让运行中的所有进程共享系统运行时所需要的各种设置值，系统会开辟一个属性存储区域，并提供访问该内存区域的API。所有进程都可以访问属性值，但是只有init进程可以修改属性值，其他进程若想修改属性值，需要向init进程发出请求，最终由init进程负责修改属性值。
上面说到的是system/build.prop文件。里面主要是系统的配置信息，其实还有一个重要文件在根目录下面：default.prop，如下所示：
这里有一个重要属性ro.debuggable，关系到系统中每个应用是否能够被调试的关键。在Android系统中一个应用能否被调试是这么判断的：当Dalvik虚拟机从Android应用框架中启动时，系统属性ro.debuggable为1，如果该值被置1，系统中所有的程序都是可以调试的。如果系统中的ro.debuggable为0，则会判断程序的AndroidManifest.xml中application标签中的android：debuggable元素是否为true，如果为true则开启调试支持。
这相当于Android系统中有一个开关，即根目录中default.prop文件中的ro.debuggable属性值，可用于调试所有设备中的应用。如果把这个属性值设置成1，设备中所有应用都可以被调试，即使在AndroidManifest.xml中没有android：debuggable=true，还是可以调试的。而这些系统属性的文件system/build.prop和default.prop，都是init进程来进行解析的，系统启动的时候就会去解析init.rc文件，这个文件中有配置关于系统属性的解析工作信息。然后会把这些系统属性信息解析到内存中，提供给所有App进行访问，这块信息也是内存共享的。但是这些ro开头的属性信息只能init进程进行修改。下面来分析一下修改这个属性值的三种方式。
第一种方式：直接修改default.prop文件中的值，然后重启设备。那么现在如果按照上面的目的：就是不需要反编译apk，添加android：debuggable属性的话，直接修改default.prop文件，把ro.debuggable属性改成1即可，但是通过上面的分析，修改完成之后肯定需要重启设备的，因为需要让init进程重新解析属性文件，把属性信息加载内存中方可起作用的。但是并没有那么顺利，在实践的过程中，修改了这个属性，结果会发现设备死机了，其实想想也是正常的，如果属性能够通过这些文件来修改的话，那就感觉系统会出现各种问题了，系统是不会允许修改这些文件的。
第二种方式：改写系统文件，重新编译系统镜像文件，然后刷入到设备中。前面已经提到过，这些属性文件是在系统镜像文件boot.img系统启动的时候，释放到具体目录中的，也就是说如果能够直接修改boot.img中的这个属性即可，那么这个操作是可以进行的。理论上是可以的，但是我没成功操作过。而且这种方式如果成功了，那么这个设备就是永远可以进行各种应用的调试了。
第三种方式：注入init进程，修改内存中的属性值。上面分析了，init进程会解析这个属性文件，然后把这些属性信息解析到内存中，给所有App进行访问使用，所以在init进程的内存块中是存在这些属性值的，那么这时候就好办了，有一个技术可以做到，就是进程注入技术。可以使用ptrace注入到init进程，然后修改内存中的这些属性值，只要init进程不重启的话，那么这些属性值就会起效。好了，这个方法可以尝试，但是这个方法有一个弊端，就是如果init进程挂了重启的话，那么设置就没有任何效果了，必须重新操作了，所以有效期不是很长，但是一般情况下只要保证设备不重启的话，init进程会一直存在的，而且如果发生了init进程挂掉的情况，那么设备肯定会重启的。到时候再重新操作一下即可。
上面的三种方式设置系统中的调试属性总开关，最后一种方式是最靠谱的。而且思路也很简单，但是不用重新去写这个代码逻辑的，因为网上已经有这个工具了，这个工具叫做mprop，是一个执行文件。用法很简单，首先把可执行文件mprop拷贝到设备中的目录下，然后运行命令，如下所示：
这个工具可以修改内存中所有的属性值，包括机型信息。修改完成之后，使用getprop命令再查看值，发现修改成功了，但是需要注意的是，修改的是内存的值，而不是文件中的值。所以default.prop文件中的内容是没有发生变化：
这时候，可以使用Eclipse的DDMS来查看可以调试的应用列表，如图15-1所示。
图15-1 Eclipse中DDMS查看应用列表
当然也可以使用adb jdwp命令来查看可以调试的进程id，如下所示：
但是可惜的是，发现还是没有展示设备中所有的应用，其实这里是有一个细节问题，虽然修改了内存值，但是有一个进程需要重启一下，哪个进程呢？就是adbd这个进程，这个进程是adb的守护进程，就是设备连接信息传输后台进程，所以想看到可以调试的进程信息的话，那么需要重启这个进程，这样连接信息才会更新。
重启这个进程很简单，直接使用命令即可，如下所示：
其实这是两个命令，用分号隔开，首先是干掉进程，然后重启。运行完命令之后，再去看DDMS窗口信息，如图15-2所示。
图15-2  Eclipse 中DDMS界面展示可调式应用列表
这时候所有的应用进程都是可以调试的了，再使用dumpsys package命令查看一个应用的包信息，如下所示：
可以看到，这个应用的flags标志中并没有debuggable属性值，但是这个应用是可以调试的。
15.4 本章小结
本章主要简单介绍了，在做逆向工作之前，要先准备一些基础知识，主要从三个方面介绍了基本知识点：首先是逆向工具，包括apktool、Jadx、Xposed、ZjDroid等相关信息，其次是逆向的基本语法知识，主要包括smali和arm语法，最后是逆向的辅助功能，通过修改系统调试开关，便于后续逆向应用。
第16章 反编译神器apktool和Jadx
apktool工具是开源的，也是用Java语言开发的，代码相对简单，本章就来分析一下它的大体逻辑。分析这个工具的原因只有一个，就是在之前的反编译过程中可以发现，总是有一些apk应用不那么轻易地被反编译，它们利用apktool的漏洞对apk做了一定的混淆工作，所以需要通过分析源码来解决这些异常，从而对每个apk的反编译都能如鱼得水。本章还介绍一个分析工具Jadx，它能更高效地分析apk。
16.1 逆向操作惯例
当对一个apk进行破解之前，会做如下两件事：
·用压缩软件解压apk，得到classes.dex，然后使用dex2jar+jd-gui工具查看代码逻辑。但是这里会发现资源文件如AndroidManifest.xml和res下面的XML文件都是乱码的，因为它们遵循Android中的arsc文件格式，关于这个文件格式在之前几章已经详细介绍过了。其实不管是什么文件格式，都有文件格式的说明文档，只要按照说明文档去做解析即可。
·使用apktool工具反编译apk，得到smali源码和资源文件。smali语法是Android虚拟机识别执行的指令代码，和dex文件可以相互转化，使用baksmali.jar和smali.jar这两个工具即可。当然这里还可以得到所有的资源文件，即arsc格式解析之后的内容，而且这个工具可以实现回编译，这个功能也是很强大的，不过后面分析源码就知道了，回编译其实是借助aapt这个强大的系统命令来完成的。可以看到如果想要完全分析一个apk，apktool工具是不可或缺的，它是开启破解大门的钥匙，这个工具也是逆向领域的敲门砖，而且现在很多可视化的破解工具的核心都是使用apktool+dex2jar+jd-gui这三个工具组成的，只是后期做了一定的界面优化。
16.2 反编译常见的问题
apktool工具在反编译的过程中总会遇到一些问题，下面介绍最常见的两类问题。
1.第一类问题
错误提示：
主要是因为利用了apktool的一个漏洞，做了属性id的混淆，如下所示。
2.第二类问题
错误提示：
这是在使用apktool工具时报错最多的错误，主要是利用apktool的漏洞，修改了resource.arsc的头部信息，如下所示：