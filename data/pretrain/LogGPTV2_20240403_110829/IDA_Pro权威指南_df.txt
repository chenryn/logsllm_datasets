➊ netnode stats("$ stats", 0, true);  
int idaapi init(void) {  
   hook_to_notification_point(HT_DBG, dbg_hook, NULL);  
   return PLUGIN_KEEP;  
}  
void idaapi term(void) {  
   unhook_from_notification_point(HT_DBG, dbg_hook, NULL);  
}
注意，我们还声明了一个全局网络节点（➊），用来收集统计信息。接下来需要考虑，使用分配的热键激活插件后，我们希望它执行什么任务。示例插件的 run
 函数如下所示：
    void idaapi run(int arg) {  
        stats.altdel();   //clear any existing stats  
➊      request_enable_step_trace();  
➋      request_step_until_ret();  
➌      run_requests();  
    }
在这个例子中，由于我们使用的是异步技巧，首先我们必须提供一个请求，启动单步跟踪（➊ ），然后提交一个请求恢复被调试的进程。为了简化，我们仅收集与当前函数有关的统计信息，因此我们将提出一个请求，要求运行进程，直到当前函数返回（➋）对请求正确排序后，我们调用run_requests
 处理当前请求的队列（➌），开始运行这个插件。
接下来创建HT_DBG
 回调函数，处理我们希望收到的通知。下面是一个仅处理两条消息的简单回调函数：
int idaapi dbg_hook(void *user_data, int notification_code, va_list va) {  
   switch (notification_code) {  
➊         case dbg_trace:  //notification arguments are detailed in dbg.hpp  
             va_arg(va, thid_t);  
➋            ea_t ea = va_arg(va, ea_t);  
             //increment the count for this address  
➌            stats.altset(ea, stats.altval(ea) + 1);  
             return 0;  
➍         case dbg_step_until_ret:  
             //print results  
➎            for (nodeidx_t i = stats.alt1st(); i != BADNODE; i = stats.altnxt(i)) {
                  msg("%x: %d\n", i, stats.altval(i));  
             }  
             //delete the netnode and stop tracing  
➏            stats.kill();  
➐            request_disable_step_trace();  
➑            run_requests();          break;  
   }  
}
对于执行的每一条指令，我们将收到 dbg_trace
 通知（➊ ），直到我们关闭跟踪。收到一个跟踪通知时，从参数列表（➋ ）中获取跟踪点的地址，用于更新相应的网络节点数组索引（➌）。进程到达 return
 语句，离开我们最初启动的函数时将发送 dbg_step_until_ret
 通知（➍ ）。这个通知是一个信号，表示我们应停止跟踪，并打印我们收集到的任何统计信息。接下来，我们使用一个循环（➎ ）遍历 stats
 网络节点的所有有效索引值，然后销毁该网络节点（➏ ），并请求禁用单步跟踪（➐ ）。由于这个例子使用的是异步命令，禁用跟踪的请求被添加到队列中，这意味着我们必须调用 run_requests
 （➑）来处理队列。关于与调试器的同步交互和异步交互，有一个重要的警告：在处理异步通知消息时，你绝不能调用一个函数的同步版本。
使用SDK 与调试器进行同步交互的方式，与为调试器操作编写脚本的做法非常类似。和我们在前几章中讨论的许多 SDK 函数一样，与调试器有关的函数名称通常与相关的脚本函数名称并不匹配，因此，你可能需要花一些时间搜索 dbg.hpp文件，查找你需要的函数。脚本函数与SDK在名称上的最大差异表现在 SDK 的GetDebuggerEvent
 函数上，在 SDK 中，它叫做wait_for_ next_event
 。脚本函数与 SDK 的另一个主要差异在于 SDK 并不为你自动声明与 CPU 寄存器对应的变量。为了从 SDK 中访问 CPU 寄存器的值，你必须分别使用 get_reg_val
 和set_reg_val
 函数读取和写入寄存器。
24.5 小结
IDA 在调试器市场中并没有占有最大的市场份额，但它的调试器非常强大，能够与 IDA 的反汇编器无缝集成。和任何调试器一样，你需要一段时间来熟悉这个调试器的用户界面，它提供了用户在一个基本的调试器中所需要的全部重要功能。它的优点包括：脚本和插件功能、与IDA的反汇编窗口类似的用户界面以及强大的分析功能。反汇编器/ 调试器的完美结合，将为我们提供一个可靠的工具，用于执行静态分析、动态分析，或者同时执行这两种分析。
第25章 反汇编器/ 调试器集成
像IDA 这样的集成式反汇编器/调试器组合是一个非常强大的工具，可用于操纵二进制文件，并在逆向工程过程中无缝应用静态和动态分析技巧。当然，如果你了解这两款工具单独使用以及结合使用的功能和限制，你同样可以实现相同的目的。
本章将讨论一些重要的问题，说明 IDA 的静态功能如何与它的动态功能交互。为了给这方面的讨论提供启示，我们将研究可被 IDA 调试器采用、用于在恶意软件分析时破坏某些反调试（及反“反汇编”）技巧的方法。在这方面，需要记住的是，我们分析恶意软件的目的通常并不是运行恶意软件，而是获得一个质量足够好的反汇编代码清单，以供静态分析工具使用。如第21章所述，有许多技巧专门用于阻止反汇编正常运行，而调试器只是破坏这些技巧的一种手段。通过在调试器的控制下运行模糊程序，我们将设法获得该程序的去模糊版本，然后使用反汇编器进行分析。
25.1 背景知识
首先，我们有必要了解一些有关调试器辅助去模糊的背景知识。众所周知，在发挥作用之前，一个模糊程序必须先对自身去模糊。下面的步骤提供一个简单的基本指南，说明如何对二进制文件进行动态去模糊。
使用调试器打开一个模糊程序。
在去模糊例程的结束部分搜索并设置一个断点。
从调试器中启动程序，等待断点被触发。
利用调试器的内存转储功能捕获进程的当前状态，并将其保存到一个文件中。
在进程实施任何恶意行为之前终止进程。
对捕获到的进程映像执行静态分析。
大多数现代调试器都足以执行上述任务。OllyDbg1
 是Windows 平台上的一款非常流行的调试器，常用于完成这些任务。步骤2并不总是像看起来那样简单。在这个步骤中，你可能需要使用许多工具，包括长时间使用 IDA 之类的反汇编器，或者进行许多单步操作，才能正确识别去模糊算法。许多时候，去模糊过程以一个行为（而不是一条特定指令）作为结束标记。这样的行为可能是指令指针值的明显变化，用以标明一个指向远离去模糊代码位置的跳转。例如，在 UPX
 打包的二进制文件中，你所需要做的是观察指令指针保存的值。如果这个值小于程序的入口点地址，则说明去模糊已经完成，程序已经跳转到新的、去模糊后的代码部分。通常，这个过程叫做初始入口点（OEP ）识别
 ，这里的 OEP 是程序在经过模糊处理之前开始执行的地址。
1. 参见http://www.ollydbg.de/
 。
使事情更复杂的是，一些现代模糊器能够将输入的可执行文件转换为等效的字节码程序，然后在由该模糊器2
 生成的自定义虚拟机上运行。在分析这类受虚拟化模糊器保护的可执行文件时，你不能像执行传统的分析那样期待发现原始二进制文件或定位原始入口点。这是因为原始的 x86（或其他处理器）指令并未嵌入到经过模糊处理的二进制文件中，因此你根本找不到这类指令。
2. 有关此类模糊器VMProtect的讨论，参阅Rolf Rooles 的“ Unpacking Virtualization Obfuscators”，地址为：http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf
 。
如果你不够小心，步骤3可能会带来危险。任何时候，在允许一个恶意软件不受阻碍地运行之前，你都应该三思，保证你已经正确设置了断点或断点条件。如果恶意程序设法避开你的断点，它可能会悄悄地执行恶意代码。因此，如果你要在调试器的控制下对恶意软件去模糊，你应该始终在一个沙盒环境中执行这项操作，这样，即使出现错误，你也不用担心因此导致的不良后果。
步骤4可能需要你付出一定的努力，这是因为虽然调试器通常支持内存转储，但它并不支持整个进程的内存映像转储。Gigapede 开发的 OllyDump3
 插件为 OllyDbg提供了进程转储功能。需要注意的是，从内存中转储的映像包含一个正在运行的进程的内容，并不一定能够反映位于磁盘文件中的静态二进制文件的初始状态。但是，在恶意软件分析中，我们的目的并不是创建一个经过去模糊处理的可执行文件，而是创建一个结构正确的映像文件，以便将它加载到反汇编器中进行深入分析。
3. 参见http://www.woodmann.com/collaborative/tools/index.php/OllyDump
 。
由模糊进程重建一个二进制映像，最困难的是如何恢复该程序的导入函数表。在模糊过程中，程序的导入表也往往被模糊处理。因此，去模糊过程还必须考虑将新近经过去模糊处理的进程链接到它正常运行所需的所有共享库和函数。通常，这个进程的唯一线索是该进程内存映像中的一个导入函数地址表。一般来说，在将一个经过去模糊处理的进程映像转储到一个文件中时，你需要采取步骤，设法在转储的进程映像中重建一个有效的导入表。为此，你需要修改转储映像的头部，使它指向一个新的导入表结构，这个导入表必须正确反映经过去模糊处理的原始程序的共享库依赖关系。MackT 开发的ImpREC4
 （Import REConstruction ）实用工具是一款广受欢迎的工具，可用于自动完成这个任务。和进程转储一样，请记住，提取独立的可执行文件可能并不是你分析恶意程序的主要目的。相比于重建有效的头部和工作导入表，了解哪些函数已被解析以及这些函数的地址的存储位置要更为重要。
4. 参见http://www.woodmann.com/collaborative/tools/index.php/ImpREC
 。
25.2 IDA 数据库与IDA 调试器
首先，我们需要了解，当你启动（和终止）一个调试器会话时，调试器如何处理数据库。调试器需要使用一个进程映像。通常，调试器通过依附一个现有的进程，或由可执行文件创建新的进程，从而获得进程映像。IDA 数据库并不包含有效的进程映像，多数情况下，你也不可能由一个数据库重建一个有效的进程映像（如果你可以，使用 File▶Produce File▶Create EXE File 命令即可）。当你在 IDA 中启动一个调试器会话时，反汇编器会告知调试器初始输入文件的名称，调试器再使用这个文件创建并依附于一个新的进程。反汇编器提供给调试器的信息反汇编器格式化、符号名、数据格式化以及任何你输入到数据库中的注释。重要的是，你对数据库进行的任何修补（字节内容的变化）都不会在被调试的进程中反映出来。换言之，即使你对数据库进行了修补，也不能在启动调试器时观察到这些修补产生的效果。
反之也是如此。当你调试完一个进程并返回反汇编模式时，默认情况下，数据库反映出来的仅有的变化全都属于表面上的变化（如重命名变量或函数）。任何内存变化（如自修改代码），都不会在数据库中反映出来，使你能够对其分析。如果你希望将所有新近经过去模糊处理的代码从调试器移回到反汇编数据库中，可以使用 IDA 的Debugger ▶Take Memory Snapshot（拍摄内存快照）命令来实现。它生成的确认对话框如图 25-1 所示。
图25-1 内存快照确认对话框
默认选项是将加载器段由正在运行的进程复制到数据库中。加载器段
 （loader segment）是指那些由IDA 的一个加载器模块加载到数据库中的段。在模糊程序中，一个或几个这样的段可能包含一些已经被模糊处理，因而几乎不可能在反汇编器中分析的数据。这些段恰恰是你想要从正在运行的进程映像中复制的段，用来利用在调试器控制下该进程执行的去模糊工作。
单击All segments按钮，则调试器创建的所有段都被复制到数据库中。这些段包括为支持该进程而加载的所有共享库的内容，以及其他进程相关的段，如栈内容和堆内容。
如果调试器被用于依附一个没有相关数据库的现有进程，那么将没有任何调试器段被标记为加载器段，因为该文件并不是由IDA 的加载器加载的。这时，你可以选择将所有可用的段捕获到一个新的数据库中。此外，你也可以选择编辑段属性，并且将一个或几个段指定为加载器段。要编辑段属性，你首先需要打开 Segments 窗口（View▶Open Subviews▶ Segments）。任何标记为加载器段的段将包含 Program Segmentation窗口中L 列中的L
 右击一个感兴趣的段，并在出现的菜单中选择 Edit Segment，这时生成的段属性对话框如图 25-2 所示。
图25-2 具有 Loader segment 复选框的段编辑对话框
选择Loader segment复选框会将一个段标记为加载器段，并将它和所有其他加载器段一起复制到数据库中。
当你已从打开的数据库创建了进程，并希望在拍摄内存快照之前添加其他加载器段时，“段属性”对话框也非常有用。例如，如果模糊进程将原始代码提取到位于堆中的内存块（或内存映射的块）中，你会希望在拍摄内存快照前将该内存块标记为加载器段，否则，去模糊代码将不会被复制到数据库中。
25.3 调试模糊代码
我们已经多次提到：在调试器中加载一个模糊程序，使它继续运行，直到去模糊过程完成，然后拍摄该程序经过去模糊处理后的内存快照，这似乎是一个不错的策略，可以帮助我们获得程序的去模糊版本。但是，与调试相比，以受控执行（controlled execution）的方式实施这个策略可能要更好一些，因为这时我们只需要观察代码的运行状态，然后在适当的时候拍摄一张内存快照。调试器这种工具正好可以帮助我们完成这个任务，至少它是我们正在寻找的工具。在第21章中，我们了解到一系列反“反汇编”和反调试技巧，模糊器正是利用这些技巧阻止我们清楚了解程序的行为。现在，我们来看 IDA 调试器如何帮助我们避开其中一些技巧。
在本章中，假定我们所处理的模糊程序全都对二进制文件的相关部分进行了某种形式的加密或压缩。了解模糊代码的用途的困难程度，完全取决于模糊过程所使用的反分析技巧，以及为避开这些技巧而采取的措施的复杂程度。但是，在开始讨论之前，我们首先说明在调试环境中分析恶意软件需要遵循的一些规则。
保护网络和主机环境。始终在一个沙盒环境中进行分析。
在初始分析时，尽可能使用单步分析。这样做可能有些烦琐，但这是防止程序脱离你的控制的最佳方法。
在执行允许执行多条指令的调试器命令之前，请三思而行。如果控制不当，你调试的程序可能会执行代码的恶意部分。
如有可能，使用硬件断点。你很难在模糊代码中设置软件断点，因为去模糊算法可能会修改你插入的断点指令并计算代段区域的校验和1
 。
1. 请记住，调试器插入的软件断点指令将导致校验和计算，以生成一个非预期的结果。
在初次分析程序时，最好让调试器处理该程序生成的所有异常，以便于你明智地决定将哪些异常交由程序处理，哪些异常应由调试器继续捕获。
做好经常重新开始调试的准备，因为一步出错，可能会导致整个调试过程失败（例如，如果你允许进程检测调试器）。请详细记录你确定安全的地址，以便迅速找到这些地址，重新开始调试过程。
一般来说，当你第一次开始分析一个特殊的模糊程序时，你应该始终保持谨慎。多数情况下，你的主要目标是获得该程序的去模糊版本。然后，你的下一个目标是在设置断点之前，了解你到底能够“走多远”，从而加快去模糊过程；在你第一次成功去模糊一个程序后，最好将这整个过程保存下来，便于以后演练。
25.3.1 启动进程
无论你是否已花费数分钟或数小时使用 IDA 来研究某个恶意可执行程序，你都希望在调试器中初次启动该程序时就能控制它。控制进程的最简单方法之一是，在进程的入口点——创建进程的内存镜像后执行的第一条指令——设置一个断点。许多时候，入口点带有符号标记 start
 ，但有时则没有。例如，PE 文件格式允许为每个线程的数据指派用于执行初始化和解构任务的TLS6回调函数2
 ，且这些 TLS6回调函数会在控制权转交到 start
 之前被调用。
2. 有关TLS 回调函数的更多信息，参见PE 文件格式规范：http://msdn.microsoft.com/en-us/windows/hardware/gg-463119.aspx
 。
恶意软件开发者深知 TLS 回调函数的特点，并利用这些函数在程序的主入口点代码开始运行之前执行一些代码。他们希望任何分析恶意软件的人将不会注意到 TLS 回调函数，因此也就无法了解所分析程序的真实意图。IDA 能够正确解析 PE文件头并识别 PE文件中的任何 TLS 回调函数，同时将任何此类函数添加到 Exports窗口内的二进制文件入口点列表中。包含一个 TLS回调函数的可执行程序的 Exports窗口如图 25-3 所示。
图25-3 Exports窗口显示一个TLS 回调函数
对于TLS 回调函数而言，关键在于确定它们确实存在，然后在每个 TLS 回调函数的起始位置设置断点，以确保你能够及时获得进程的控制权。
许多调试器都提供了选项，用于指定调试器应在创建进程后于何时暂停，IDA 也不例外。IDA的Debugger Setup对话框（Debugger ▶Debugger Options）的一部分如图 25-4 所示。
图25-4 调试器暂停事件
每个可用的选项都为你提供了机会，以便于在发生特定事件时自动暂停所调试的进程。这些事件汇总如下。
Stop on debugging start （在调试开始时停止）
 。此选项允许你在创建进程后尽早暂停调试器。例如，在 Windows 7中，此选项将暂停 ntdll.dll中RtlUserThreadStart
 函数起始位置的进程。调试器将在任何程序代码（包括 TLS 回调函数）执行之前暂停。
Stop on process entry point （在进程入口点停止）
 。一旦到达程序入口点，即暂停调试器。通常，此选项的作用与 IDA 数据库中的 start
 符号（或类似符号）的作用相同。所有TLS回调函数已在此事件发生之前执行。
Stop on thread start/exit（线程启动/退出时停止）
 。每次新线程启动或现有线程终止时暂停调试器。在 Windows 系统中，如果发生此类事件，调试器将在 kernel32.dll 的某个位置暂停。
Stop on library load/unload （库加载/卸载时停止）
 。每次加载新库或卸载现有库时暂停调试器。在 Windows 系统中，如果发生此类事件，调试器将在kernel32.dll 的某个位置暂停。
Stop on debugging message （在输出调试消息时停止）
 。每次进程使用调试打印设备输出消息时暂停调试器。在 Windows 系统中，此选项对应于调用 OutputDebugString
 ，调试器将在kernel32.dll 中暂停。
为了防止你所调试的进程继续执行，超出你预想的位置，了解进程在发生这些调试器事件时可能的暂停位置非常重要。确定能够以可预见的方式控制进程后，你就可以使用调试器执行其他任务。
25.3.2 简单的解密和解压循环
这里说的简单解密和解压循环
 是指没有采用嵌入式模糊技巧的循环，你可以轻易确定其中所有可能的退出点。如果你遇到这样的循环，分析它们的最简单方法是在所有可能的退出点设置断点，然后让循环开始执行。你可以考虑单步执行这些循环一到两次，以初步了解它们，然后再相应地设置断点。如果在一个循环结束后立即设置一个断点，你必须确保你设置的断点所在地址处的字节在整个循环过程中不会发生变化，否则，你可能无法触发软件断点。如果不能肯定，可以使用一个硬件断点。
如果你的目标是建立一个完全自动化的去模糊过程，那么你需要开发一个算法，用于确定去模糊过程何时完成。如果这个条件得到满足，你的自动化解决方案将能够使进程暂停，这时你就可以拍摄一张内存快照。对于简单的去模糊例程，要确定去模糊阶段是否已经结束，你只需要观察指令指针的一个明显变化，或者某个指令的执行。例如，模糊Windows 可执行文件 UPX
 解压例程的开始和结束部分如下所示：
  UPX1:00410370 start proc near  