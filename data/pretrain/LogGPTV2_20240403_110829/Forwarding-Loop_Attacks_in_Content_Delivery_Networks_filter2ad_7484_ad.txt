a loop among one CloudFront node, one CDN77 node and
one KeyCDN node. The CDN77 node resets the Via header
used by CloudFront for loop detection. The KeyCDN node
resets the X-Forwarded-For header, which appears to be the
only header whose size would otherwise steadily increase by
CloudFront and CDN77. KeyCDN itself does not detect loops,
nor does it increase header sizes. In addition, because CDN77
does not adopt abort forwarding, forwarding timeouts will not
terminate the forwarding loop. In principle, such loops could
last indeﬁnitely.
Experiments. We created a forwarding loop among 4 sys-
tems: CloudFlare, CDN77, MaxCDN and a server under our
8
Fig. 6. The process of a CDN Dam Flooding Attack: 1) the attacker client
sends a request to A; 2) A queries attacker.com to forward the request,
and is directed to B; 3) the request circulates across B, C, and back to
A; 4) the attacker points attacker.com to his server; 5) the next DNS
query for attacker.com from A is mapped to the attacker’s server; 6) A
forwards the request to the attacker’s server; 7) the attacker’s server replies
with a streaming response; 8) the streaming response ﬂows through C and B,
then back to A, repeating many times; 9) A ﬁnally relays the response to the
attacker client.
control. We conﬁgured MaxCDN to delete any header that
detects loops or increases header size. We use the CDN77
node’s no-abort-forwarding to counter the effect of forwarding
timeouts. Again, we used our server as a transparent HTTP
proxy with a delay of 0.6 seconds to collect data and limit
the resource load imposed by the loop. We initiated the loop
using a single request; it lasted more than 5 hours, passing
17,266 requests through our server. When the loop ﬁnally
stopped, a 522 error was received, indicating that CloudFlare
could not connect
to our server. Our server also received
many retransmitted TCP packets, from which we infer that the
loop ceased because of network connectivity issues between
CloudFlare and our server.
E. The CDN Dam Flooding Attack
We call
As presented in Section III-A, HTTP streaming makes
forwarding-loop attacks more potent by enabling them to “ﬁll
the pipe” with trafﬁc. However, for the attacks discussed above,
Azure (China) is the only applicable target for streaming loops,
because it
is the only CDN that both supports streaming
requests and does not deploy loop detection (per Table III
and Table VII). Since all CDNs we examined support HTTP
streaming for responses, we can extend the attacks by employ-
ing responses rather than requests to create streaming loops.
this attack “CDN Dam Flooding” because it
involves two phases analogous to the ﬁlling and ﬂooding of
a dam. Figure 6 shows how the attack works. In the ﬁlling
phase, the attacker launches a number of forwarding loops
via the strategies described in Section III-C or Section III-D,
using domain names as forwarding destinations. In the ﬂooding
phase, the attacker changes the resolution of these names to
direct the forwarding destinations to a server of the attacker’s
that replies to incoming requests with a large ﬁle transmitted
using HTTP streaming. For each forwarding loop, a streaming
response ﬂows along the CDN nodes in reverse order, for
multiple rounds, until reaching a broken connection caused
by a forwarding timeout at some CDN node, or the client
9
Fig. 7.
attack. The ﬂooding event occurs at 50 seconds).
Trafﬁc generated by three forwarding loops in a “dam ﬂooding”
that initiated the loop. While the ﬁlling phase itself generates
some attacking trafﬁc, the ﬂooding phase bursts the trafﬁc by
utilizing HTTP streaming with large and continuous chunks,
with the impact of each chunk magniﬁed by the number of
turns it makes around the forwarding loop. The attacker can
also coordinate DNS resolution to ﬂood all ﬁlled forwarding
loops simultaneously. The overlap of multiple streaming loops
serves to enlarge the trafﬁc burst.
We note that dynamically changing forwarding destinations
using DNS is not a necessary condition to create streaming
loops. For instance, in the example given in Section III-C,
instead of chaining the attacking account An back to A1, the
attacker can alter the entry for An to point to their server, so
that a request becomes forwarded to his server after n hops
between CDN nodes, with a streaming response then fed back
along the ﬂow in reverse. That said, using DNS provides the
attacker with more control on how and when to “ﬂood” the
ﬁlled loops.
Experiments. To assess the efﬁcacy of this attack in
practice without unduly stressing a production CDN, we set up
our own VPS as the victim CDN node, imposing a strict trafﬁc
limitation of no more than 100Mb/s. On CDN77, we conﬁgure
the forwarding destination to a domain under our control. On
our VPS, we conﬁgure the forwarding destination to a CDN77
IP address. In this way, we create a forwarding loop between
our VPS and the CDN77 node. Note that our VPS has the
abort-forwarding feature, does not support request streaming,
but does support response streaming.
In the ﬁlling phase, we respond to DNS queries with the
IP address of our VPS and then send a single 366-byte request
to the CDN77 node 3 times spaced 10 seconds apart. Thus,
the attack uses a total of three small initial requests. We then
wait for the three requests to loop between the CDN77 node
and our CDN node for 30 seconds.
In the ﬂooding phase, we change the DNS replies to direct
the three loops to our web server. Our server replies to any
request with a 1 MB ﬁle, sent using HTTP streaming.
Figure 7 shows the HTTP trafﬁc on our VPS during the
ﬁlling and ﬂooding phases. The burst attack lasts in total for
about 69 seconds. During the ﬁrst phase, the three forwarding
loops slowly increase the trafﬁc volume from zero to 7 KB/s
over 50 seconds. In the second phase,
the trafﬁc volume
immediately peaks, reaching about 9.2MB/s. While we as the
CDN Node AAttackerClientCDN NodeBCDN NodeCRequestForwardingexample.comattacker.comAttackerServer1attacker.comDNS ServerRequestForwardingexample.comARequestForwardingexample.comC23.13.23.35678.18.28.394010203040506070Seconds10-1100101102103104KBytesTraffic generated by all three requestsTraffic generated by the first two requestsTraffic generated by the first requestattacker sent out three requests and three responses totaling
about 3MB trafﬁc, our VPS as a victim received about 224MB,
an ampliﬁcation factor of 74.
Combining with gzip bombs. This attack can be substan-
tially enhanced if the attacker incorporates gzip bombs. In
step 7 of Figure 6, the attacker needs to send a large response
to the CDN as quickly as possible to increase the peak burst
of the attack. gzip bombs, which are small compressed ﬁles
easy to transport across a network, can help a great deal to
achieve this goal. When unpacked by a CDN, they balloon
into extremely large output.
A key factor of this attack is whether CDNs will de-
compress gzip’d responses. To assess this, we conducted a
measurement of the 16 commercial CDNs. First, our client sent
a request to the CDN indicating that it does not accept gzip-
encoded HTTP replies. Next, our original server returned a
gzip’d response. If the client receives decompressed content,
this means that the CDN will decompress gzip’d responses.
We found that 3 (Akamai, Baidu and CloudFlare) out of the
16 CDNs will decompress gzip’d responses for clients that
do not support “gzip” encoding.
Although only 3 CDNs can be exploited by gzip bombs,
we emphasize that adding one gzip-decompressing node into
a loop sufﬁces to attack all involved nodes with the effect of
gzip bombs, even if the other nodes do not support gzip
decompression. For example, in the scenario of Figure 6, even
if the three nodes A, B, C do not support gzip decompres-
sion, the attacker can direct step 6 to a gzip-decompressing
node, which forwards the request to the attack server and is
fed a gzip bomb in return. The gzip-decompressing node
then forwards the large unpacked response to node A, where
it further loops among the three nodes.
To estimate the maximum ampliﬁcation factor a gzip
bomb can provide, we performed a simple local experiment.
We ﬁrst use dd to generate a 100GB ﬁle containing only
the character ’1’. We then compressed it using gzip with
compression level 9, yielding a 96.2MB ﬁle, reﬂecting a
compression ratio of 1,064. The compression ratio serves as
an extra ampliﬁcation factor (in addition to the number of
times that the response loops) to signiﬁcantly enlarge the attack
trafﬁc.
With Baidu’s permission, we used the Baidu CDN to
conduct
two experiments to verify the feasibility and the
efﬁcacy of dam ﬂooding attacks with gzip bombs. We set
up two local CDN servers using Nginx; created a forwarding
loop between them; and set their network latency to 200 ms.
In the ﬁlling phase, we sent a single GET request into the
loop. After 10 seconds, we pointed the forwarding destination
to our web server, sited behind Baidu. In the ﬁrst experiment,
our server replied to the request with a uncompressed 1MB ﬁle
consisting of a single repeated character. We then repeated the
procedure with a 1KB ﬁle reﬂecting a gzip’d version of the
previous 1MB ﬁle.
In the ﬁrst experiment, the 1MB response looped 16 times,
with the trafﬁc received at one local server totaling 16.6MB,
an ampliﬁcation factor of approximately 17. In comparison, in
the second experiment the 1KB response looped 17 times, and
at one server induced a total trafﬁc volume of 17.7MB. This
Fig. 8. Trafﬁc generated by one request due to CloudFront’s retransmission.
results in an ampliﬁcation factor of approximately 17,000—
1,000 times that of the ﬁrst experiment.
F. Other CDN Quirks
We also observed two rare behaviors that can further
enhance the efﬁcacy of forwarding-loop attacks.
Aggressive active probing. We found that Azure (China)
proactively and frequently issues HTTP requests to forwarding
destinations, presumably for availability testing. We conﬁgured
a forwarding destination on Azure (China) and monitored
for 36 hours. In total we received 106,764 requests from
69 different IP addresses. This behavior—if intended rather
than a bug or misconﬁguration—would allow attackers to
generate forwarding loops without even using an initiator.
the server then retransmits the request
Forwarding retries. We also found that when the origin
does not give a response in certain time, CloudFront and
Akamai will retransmit requests to the origin websites. Upon
receiving a request from a client, a CloudFront server forwards
the request to its forwarding destination. If it does not receive
a response,
twice,
30 seconds and 60 seconds after ﬁrst sending it, respectively,
before returning a timeout error to the client after 90 seconds.
Akamai servers also retry one time at 120 seconds before
a ﬁnal timeout at 240 seconds. In forwarding-loop attacks,
each request retransmission kicks off a new loop. In addition,
even if the server closes the previous forwarding connection
before issuing a retransmission, the original loop will still
continue if any node in the loop does not implement abort
forwarding. Together, these behaviors can make the number
of loops increase exponentially.
To examine these possibilities, we created a forwarding
loop between a CloudFront server and our HTTP forwarder.
Our forwarder did not support abort forwarding or request
streaming. We sent a single request (376 bytes) to the Cloud-
Front server and captured HTTP trafﬁc at our forwarder. After
156 seconds, we manually stopped the loop by killing the
process of our forwarder,
to avoid adversely affecting the
CloudFront platform. Figure 8 shows the results. We see that
the number of requests starts to increase at 30 seconds and
does so much quickly every subsequent 30 seconds, reaching
200 at the end of the experiment. During the experiment,
our forwarder received a total of 3,096 requests sent by the
CloudFront server, even though we only sent one request.
10
020406080100120140160Seconds050100150200Requests numberTABLE VIII.
CDN REGISTRATION REQUIREMENTS AND COST.
Register Requirements
Price
Anonymity
Akamai
Alibaba
Azure
(China)
Baidu
CDN77
CDNlion
CDN.net
CDNsun
CloudFlare
CloudFront
Fastly
Incapsula
KeyCDN
Level3
MaxCDN
Tencent
Email address
Credit card
Email address
Phone number
Bank card
Email address
Phone number
Email address
Email address
Email address
Email address
Email address
Email address
Email address
Credit card
Email address
Email address
Email address
Email address
Email address
Email address
Phone number
Bank card
Free trial
Free trial
Free trial
(1 CNY)
Free service
Free trial
Free trial
Free trial
Free trial
Free service
Free trial
Free service
Free service
Free trial
Free trial
Free trial
Free trial
















G. Anonymity and Cost
One may argue that these attacks cannot be launched in the
real world because of the associated costs and risk of exposing
the attacker’s identity. However, CDN providers, presumably
for competitive reasons, provide much convenience for their
prospective customers (and thus for attackers). Table VIII
shows the registration information required to begin using the
free or free-trial services of the CDN providers in our study.
11 out of 16 CDNs require only a valid email address. Akamai
and CloudFront CDNs require valid credit cards (could be gift
cards, or stolen), Azure (China) requires valid phone number
(could be anonymous). Alibaba and Tencent require users to
verify their identity through a valid bank card, which takes an
attacker more effort to keep anonymous.
H. Disclosure and Response
We attempted to contact all 16 CDN vendors. For 4 CDNs
(CDNlion, CDN.net, CDNsun and KeyCDN), we could not
ﬁnd speciﬁc security contacts, and our messages to the general
email addresses found on their websites or WHOIS informa-
tion did not receive any reply. For the other 12 CDNs, we were
able to provide detailed report to their security contacts, and
9 replied (all but Incapsula, Level3 and MaxCDN). In addition,
Verizon (EdgeCast) contacted us to discuss the problem after
11
learning of this issue from one of their clients, even though
we did not include their service in our study because they
do not offer anonymous customer accounts. We also reported
the problem to CNCERT/CC and the CERT coordination
center (CERT/CC) through the HackerOne platform.2 Below
we summarize the discussions.
CloudFlare: acknowledged our report and particularly
thanked us for reporting the problem of gzip bombs. They
also actively discussed with us the potential consequences and