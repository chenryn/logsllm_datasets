signed. An RSA key pair in TPM called AIK (Attestation
Identity Key) serves as the signing key. Its public part is
signed by TPM’s unique key (Endorsement Key, aka. EK,
generated by the manufacturer and never leaves the chip in
any operations) and certiﬁed by a CA in a separate process
(e.g., during setup). This ensures the validity of the signa-
ture. The data to be signed is the requested PCR values. In
TXT, the initial PCR value is set to 0, and all subsequent
extend operations will update the PCR values in an unforge-
able manner (via SHA1). As a result, as long as the quote
matches the expected one, the genuine copy of the program
must have been executed, and thus AG1 is achieved.
4.
IMPLEMENTATION
In this section, we discuss our implementation of Hypno-
guard under Linux using Intel TXT as the trusted exe-
cution provider. Note that Hypnoguard’s design is OS-
independent, but our current implementation is Linux spe-
ciﬁc; the only component that must be developed for other
OSes is HypnoOSService (see below). We also performed
an experimental evaluation of Hypnoguard’s user experi-
ence (for 8GB RAM); no noticeable latency was observed
at wakeup-time (e.g., when the user sees the lit-up screen).
We assume that a delay under a second before entering sleep
and during wakeup is acceptable. For larger memory sizes
(e.g., 32GB), we implement two variants to quickly encrypt
selected memory regions.
4.1 Overview and execution steps
The Hypnoguard tool consists of three parts: Hypno-
Core (the unlocking logic and cipher engine), HypnoDrivers
(device drivers used at wakeup-time), and HypnoOSService
(kernel service to prepare for S3 and HypnoCore). Hyp-
noCore and HypnoDrivers operate outside of the OS, and
HypnoOSService runs within the OS. The approximate code
size of our implementation is: HypnoCore, 7767 LOC (in
C/C++/assembly, including reused code for TPM, AES, RSA,
SHA1); HypnoDrivers, 3263 LOC (in C, including reused
code for USB); HypnoOSService, 734 LOC in C; GCM,
2773 LOC (in assembly, including both the original and our
adapted constructions); and a shared framework between
the components, 639 LOC in assembly.
Execution steps. Figure 2 shows the generalized exe-
cution steps needed to achieve the designed functionalities
on an x86 platform. (a) The preparation is done by Hyp-
noOSService at any time while the OS is running before S3
is triggered. HypnoCore, HypnoDrivers, ACM module for
TXT, and the TXT policy ﬁle are copied into ﬁxed mem-
ory locations known by Hypnoguard (see Section 4.3). Also,
HypnoOSService registers itself to the OS kernel so that if
the user or a system service initiates S3, it can be invoked.
(b) Upon entry, necessary parameters for S3/TXT are pre-
pared and stored (those that must be passed from the active
OS to Hypnoguard), and the kernel’s memory tables are re-
placed with ours, mapped for HypnoCore and HypnoDrivers.
(c) Then, HypnoCore encrypts the whole memory in a very
quick manner through multi-core processing with AES CTR
mode using SK. SK is then encrypted by HGpub (an RSA-
2048 key). Before triggering the actual S3 action by sending
commands to ACPI, Hypnoguard must replace the original
OS waking vector to obtain control back when the machine
is waken up. (d) At S3 wakeup, the 16-bit realmode entry,
residing below 1MB, of Hypnoguard waking vector is trig-
gered.
It calls HypnoDrivers to re-initialize the keyboard
and display, and prepares TXT memory structures (TXT
Figure 2: Simpliﬁed execution steps of Hypnoguard
heap) and page tables. (e) Then the user is prompted for
a password, which is used to unlock TPM NVRAM indices
one by one. Based on the outcome and the actual unlocking
policy, either deletion of HGpriv happens right away and a
quote is generated for further veriﬁcation (and the system
is restarted), or if the password is correct, HGpriv is un-
locked into memory. After decrypting SK, HGpriv is erased
promptly from memory. HypnoCore then uses SK to de-
crypt the whole memory. (f) TXT is torn down, and the OS
is resumed by calling the original waking vector.
Machine conﬁguration. We use an Intel platform running
Ubuntu 15.04 (kernel version: 3.19.0). The development
machine’s conﬁguration includes: an Intel Core i7-4771 pro-
cessor (3.50 GHz, 4 physical cores), with Intel’s integrated
HD Graphics 4600, Q87M-E chipset, 8GB RAM (Kingston
DDR3 4GBx2, clock speed 1600 MHz), and 500GB Seagate
self-encrypting drive.
In theory, our tool should work on
most machines with TPM, AES-NI and Intel TXT (or AMD
SVM) support, with minor changes, such as downloading the
corresponding SINIT module.
4.2 Instrumenting the S3 handler
Hypnoguard needs to gain control at wakeup-time before
the OS resume process begins. For simplicity, we follow
the method as used in a similar scenario in Intel tboot [31].
An x86 system uses ACPI tables to communicate with the
system software (usually the OS) about power management
parameters. The ﬁrmware waking vector, contained in the
Firmware ACPI Control Structure (FACS), stores the ad-
dress of the ﬁrst instruction to be executed after wakeup;
and to actually put the machine to sleep, certain platform-
speciﬁc data, found in the Fixed ACPI Description Table
(FADT), must be written to corresponding ACPI registers.
We must register Hypnoguard with an OS callback for re-
placing the waking vector, so as not to interfere with normal
acpi os prepare sleep() call-
OS operations. In Linux, the
back can be used, which will be invoked in the kernel space
before entering sleep. However, we cannot just replace the
waking vector in this callback and return to the OS, as Linux
overwrites the waking vector with its own at the end of S3
preparation, apparently, to ensure a smooth resume. Fortu-
nately, the required data to be written to ACPI registers is
already passed in as arguments by the kernel, and as the OS
is ready to enter sleep, we put the machine to sleep without
returning to the OS.
4.3 Memory considerations
To survive across various contexts (Linux, non-OS native,
initial S3 wakeup and TXT), and not to be concerned with
paging and virtual memory addressing, we reserve a region
from the system memory by providing a custom version of
the e820 map, so that Linux will not touch it afterwards.
This is done by appending a kernel command line param-
eter memmap.
In Windows, this can be done by adding
those pages to BadMemoryList. 1 MB space at 0x900000 is
allocated for HypnoCore, HypnoDrivers and miscellaneous
parameters to be passed between diﬀerent states, e.g., the
SINIT module, original waking vector of Linux, policy data,
stack space for each processor core, and Intel AES-NI library
(see Section 5).
Full memory coverage in 64-bit mode. To support
more than 4GB memory sizes, we need to make Hypnoguard
64-bit addressable. However, we cannot simply compile the
Hypnoguard binary into 64-bit mode as most other mod-
ules, especially those for TXT and TPM access, are only
available in 32-bit mode, and adapting them to 64-bit will
be non-trivial (if possible), because of the signiﬁcantly dif-
ferent nature of 64-bit mode (e.g., mandatory paging).
We keep HypnoCore and HypnoDrivers unchanged, and
write a trampoline routine for the 64-bit AES-NI library,
where we prepare paging and map the 8GB memory before
switching to the long mode (64-bit). After the AES-NI li-
brary call, we go back to 32-bit mode. Also, the x86 calling
conventions may be diﬀerent than x86-64 (e.g., use of stack
space vs. additional registers). A wrapper function, before
the trampoline routine goes to actual functions, is used to
extract those arguments from stack and save them to corre-
sponding registers. In this way, the 64-bit AES-NI library
runs as if the entire HypnoCore and HypnoDrivers binary is
64-bit, and thus we can access memory regions beyond 4GB,
while the rest of Hypnoguard still remains in 32-bit mode.
4.4 User interaction
In a regular password-based wakeup-time authentication,
the user is shown the password prompt dialog to enter the
password. In addition to the password input, we also need
to display information in several instances, e.g., interacting
with the user to set up various parameters during deploy-
ment, indicating when deletion is triggered, and displaying
the quote (i.e., proof of deletion). Providing both standard
input and output is easy at boot-time (with BIOS support),
and within the OS. However, resuming from S3 is a special
situation: no BIOS POST is executed, and no OS is ac-
tive. At this time, peripherals (e.g., PCI, USB) are left in
an uninitialized state, and unless some custom drivers are
implemented, display and keyboard remain nonfunctional.
For display, we follow a common practice as used in Linux
for S3 resume (applicable for most VGA adapters). Hypn-
oDrivers invoke the legacy BIOS video routine using “lcallw
0xc000,3” (0xc0000 is the start of the VGA RAM where the
video BIOS is copied to; the ﬁrst 3 bytes are the signature
and size of the region, and 0xc0003 is the entry point).
For keyboard support, the S3 wakeup environment is more
challenging (PS/2 keyboards can be easily supported via a
simple driver). Most desktop keyboards are currently con-
nected via USB, and recent versions of BIOS usually have
a feature called “legacy USB support”. Like a mini-OS, as
part of the power-on check, the BIOS (or the more recent
UEFI services) would set up the PCI conﬁguration space,
perform USB enumeration, and initialize the class drivers
(e.g., HID and Mass Storage). But when we examined the
USB EHCI controller that our USB keyboard was connected
to, we found that its base address registers were all zeros at
wakeup-time, implying that it was uninitialized (same for
video adapters). As far as we are aware, no reliable mecha-
nisms exist for user I/O after wakeup. TreVisor [46] resorted
to letting the user input in a blank screen (i.e., keyboard was
active, but VGA was uninitialized). Note that the actual
situation is motherboard-speciﬁc, determined mostly by the
BIOS. We found that only one out of our ﬁve test machines
has the keyboard initialized at wakeup-time.
Loading a lightweight Linux kernel might be an option,
which would increase the TCB size and (potentially) intro-
duce additional attack surface. Also, we must execute the
kernel in the limited Hypnoguard-reserved space. Instead,
we enable USB keyboard support as follows:
1. Following the Linux kernel functions pci save state() and
pci restore conﬁg space(), we save the PCI conﬁguration
space before entering S3, and restore it at wakeup-time
to enable USB controllers in Hypnoguard.
2. We borrow a minimal set of functions from the USB stack
of the GRUB project, to build a tiny USB driver only for
HID keyboards operating on the “boot protocol” [61].
3. There are a few unique steps performed at boot-time
for USB initialization that cannot be repeated during S3
wakeup. For instance, a suspended hub port (connect-
ing the USB keyboard) is ready to be waken up by the
host OS driver and does not accept a new round of enu-
meration (e.g., getting device descriptor, assigning a new
address). We thus cannot reuse all boot-time USB ini-
tialization code from GRUB. At the end, we successfully
reconﬁgure the USB hub by initiating a port reset ﬁrst.
With the above approach, we can use both the USB key-
board and VGA display at wakeup-time. This is hardware-
agnostic, as restoring PCI conﬁguration simply copies exist-
ing values, and the USB stack as reused from GRUB follows
a standard USB implementation. We also implement an
i8042 driver (under 100 LOC) to support PS/2 keyboards.
Our approach may help other projects that cannot rely on
the OS/BIOS for input/output support, e.g., [46, 15].
4.5 Moving data around
Hypnoguard operates at diﬀerent stages, connected by
jumping to an address without contextual semantics. Con-
ventional parameter passing in programming languages and
shared memory access are unavailable between these stages.
Therefore, we must facilitate binary data transfer between
the stages. To seamlessly interface with the host OS, we
apply a similar method as in Flicker [40] to create a sysfs
object in a user-space ﬁle system. It appears in the directory
“/sys/kernel” as a few subdirectories and two ﬁles: data (for
accepting raw data) and control (for accepting commands).
In HypnoOSService, the sysfs handlers write the received
data to the 1MB reserved memory region. When S3 is trig-
gered, HypnoDrivers will be responsible for copying the re-
quired (portion of) binary to a proper location, for instance,
the real-mode wakeup code to 0x8a000, SINIT to the BIOS-
determined location SINIT.BASE and the LCP policy to the
OsMleData table, which resides in the TXT heap prepared
by HypnoDrivers before entering TXT.
4.6 Unencrypted memory regions
In our full memory encryption, the actual encrypted ad-
dresses are not contiguous. We leave BIOS/hardware re-
served regions unencrypted, which fall under two categories.
(a) MMIO space: platform-mapped memory and registers of
I/O devices, e.g., the TPM locality base starts at 0xfed40000.
(b) Platform conﬁguration data: memory ranges used by
BIOS/UEFI/ACPI; the properties of such regions vary sig-
niﬁcantly, from read-only to non-volatile storage.
Initially, when we encrypted the whole RAM, including
the reserved regions, we observed infrequent unexpected sys-
tem behaviors (e.g., system crash). As much as we are aware
of, no user or OS data is stored in those regions (cf. [33]), and
thus there should be no loss of conﬁdentiality due to keep-
ing those regions unencrypted. Hypnoguard parses the e820
(memory mapping) table to determine the memory regions
accessible by the OS. In our test system, there is approxi-
mately 700MB reserved space, spread across diﬀerent ranges
below 4GB. The amount of physical memory is compensated
by shifting the addresses, e.g., for our 8GB RAM, the actual
addressable memory range goes up to 8.7GB.
5. HIGH-SPEED FULL MEMORY ENCRYP-