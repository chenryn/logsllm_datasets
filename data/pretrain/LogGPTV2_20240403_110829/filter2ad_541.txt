title:HDiff: A Semi-automatic Framework for Discovering Semantic Gap Attack
in HTTP Implementations
author:Kaiwen Shen and
Jianyu Lu and
Yaru Yang and
Jianjun Chen and
Mingming Zhang and
Haixin Duan and
Jia Zhang and
Xiaofeng Zheng
HDiff: A Semi-automatic Framework for Discovering 
Semantic Gap Attack in HTTP Implementations
Kaiwen Shen, Jianyu Lu, Yaru Yang, Jianjun Chen, 
Mingming Zhang, Haixin Duan, Jia Zhang, Xiaofeng Zheng 
Delegated Presenter : Shuai Hao
DSN 2022 - June 28, 2022
Middleboxes are widely deployed with semantic gaps
❖ Middleboxes: intermediate devices deployed for security or
performance benefits (e.g., firewall, cache proxy, and CDN).
❖ Different middleboxes may interpret messages differently, causing 
semantic gaps.
Middlebox
Cache
Client
Firewall
Cache Proxy 
CDN
Server
An end-to-end HTTP request is processed by multiple middleboxes.
A Case Study for Semantic Gap Attack
HTTP Request Smuggling
Attacker
POST / HTTP/1.1
Host: example.com
Content-Length: 43
Transfer-Encoding: chunked
0
GET /admin HTTP/1.1
Malicious-Header: value
POST / HTTP/1.1
Host: example.com
Content-Length: 43
Transfer-Encoding: chunked
0
GET /admin HTTP/1.1
Malicious-Header: value
Front-end Server
Back-end Server
The smuggled 
malicious request
Semantic gap in parsing more than one Content-Length or 
Transfer-Encoding header fields to smuggle a hidden request
Bypass Front-end Security Controls
Exploit Reflected XSS
Web Cache Poisoning
Semantic Gap Attack: a Serious Threat to the Internet
❖ Semantic Gap Attack: Inconsistent Interpretation of an Ambiguous HTTP Request
Ø Host of Troubles [CCS’16]
Ø HTTP Request Smuggling [BHUSA’19]
Ø Cache-Poisoned Denial-of-Service Attack [CCS’19]
Firewall Bypass Cache Poisoning DoS Attack
Cache
Client
Firewall
Cache Proxy 
CDN
Server
Most previous studies relied on fully manual analysis
How to automatically discover semantic gap attacks
The Root Causes of Semantic Gap Attacks
❖ Implementations not following RFCs: 
Ø Intended relaxation for robustness principle
Be conservative in what you send, be liberal in what you accept.
- Robustness Principle
Ø Programming mistakes due to the misunderstanding of RFCs
❖ Different implementations of optional requirements:
Ø RFC defines optional requirements allowing developers to use their discretion
HDiff: a Semi-automatic Testing Framework
New Detecting Framework: Discovering semantic gaps with RFC-directed 
differential testing
T
NLP
R
RFCs
Documentation 
Analyzer 
Differential 
Testing
HTTP
Implementations
Bugs
Ø Syntax Rule: ABNF Grammar
ABNF rules defining HTTP grammar from RFC 7230.
HDiff: a Semi-automatic Testing Framework
New Detecting Framework: Discovering semantic gaps with RFC-directed 
differential testing
T
NLP
R
RFCs
Documentation 
Analyzer 
Differential 
Testing
HTTP
Implementations
Bugs
Ø Syntax Rule: ABNF Grammar
Ø Semantic Rule: Specification Requirements 
Informal descriptions to define HTTP semantic actions
•
• Guide developers to implement the protocol correctly 
and ensure security
If a Transfer-Encoding header field is present in a request 
and the chunked transfer coding is not the final encoding, 
the server MUST respond with the 400 (Bad Request) 
status code and then close the connection.
- RFC 7230
An example of Specification Requirement (SR)
HDiff: a Semi-automatic Testing Framework
New Detecting Framework: Discovering semantic gaps with RFC-directed 
differential testing
T
NLP
R
RFCs
Documentation 
Analyzer 
Differential 
Testing
HTTP
Implementations
Bugs
Ø Semantic Metrics:     𝐻𝑀𝑒𝑡𝑟𝑖𝑐𝑠=⟨𝑢𝑢𝑖𝑑, 𝑠𝑡𝑎𝑡𝑢𝑠_𝑐𝑜𝑑𝑒, ℎ𝑜𝑠𝑡, 𝑑𝑎𝑡𝑎, ...⟩
Differential Testing
Ø Detecting Bugs:        users can define different detection rules based on HMetrics 
to discover semantic gap attacks.
HDiff: Design and Implementation
❖ Documentation Analyzer :
❖ Differential Testing : 
Ø Using NLP techniques to extract
rules from RFCs
Ø Utilizing differential testing to 
discover semantic gap attacks
Documentation Analyzer
Differential Testing
ABNF rule extractor
ABNF rule adaption
ABNF generator 
RFCs
predefined 
ABNF rules
SR 
template
User 
SR finder
Text2Rule converter
SR semantic definition
The Architecture of HDiff
SR
Request
SR translator
log, 
req, res 
Difference analysis
Bugs
HTTP implementations
Detection model
An End-to-End Example for 
HTTP Request Smuggling Attack
Research Challenges for Documentation Analyzer
❖ Automatic extraction of Specification Requirements (SR) from RFC is not easy
Ø Manually extracting SRs needs significant human efforts and is error-prone:
Ø HTTP RFC specifications are lengthy (RFC 7230 includes 89 pages in total) 
Ø Traditional regular templates or keyword-based approaches do not work well
Ø RFC documents are described in natural language rather than formal 
language, in which the sentences are complex and flexible in expression.
Ø The same semantics can be expressed in multiple forms, including 
synonym substitution and grammatical variations (e.g., passive tense)
Step 1: Sentiment-based Specification Requirement Finder
❖ Key Observation:
Ø All SRs are characterized by a strong sentiment to stress the constraints
If a Transfer-Encoding header field is present in a request and the chunked transfer coding 
is not the final encoding, the server MUST respond with the 400 (Bad Request) status 
code and then close the connection.
- RFC 7230
An example of Specification Requirement (SR)
❖ Sentiment-based Specification Requirement Finder:
Ø Automatically identify strong sentiment sentences with potential SRs
RFC Documents
SR Finder
Specification Requirements
Step 2: Text2Rule Converter
❖ Key Observation: All specification requirements tend to follow a specific semantic structure
Ø A message description: [field-name] header is [represent/valid/invalid/multiple]
Ø A role action: [role] respond [200/302/400] status code
❖ Dependency Tree Analysis:
If a Transfer-Encoding header field is present in a request and the chunked transfer coding 
is not the final encoding, the server MUST respond with the 400 (Bad Request) status 
code and then close the connection.
- RFC 7230
Message
Description
a Transfer-Encoding header field is present in a request and the chunked 
transfer coding is not the final encoding
Role 
Action
the server MUST respond with the 400 (Bad Request) status code and 
then close the connection.
Step 2: Text2Rule Converter
❖ Key Observation: All specification requirements tend to follow a specific semantic structure
Ø A message description: [field-name] header is [represent/valid/invalid/multiple]
Ø A role action: [role] respond [200/302/400] status code
❖ Part-of-speech tagging:
NN
Message
Description
a Transfer-Encoding header field is present in a request and the chunked 
transfer coding is not the final encoding
Key Messages
Dictionary of 
Header Names
The header names
defined in ABNF rules
Transfer-Encoding
Transfer-coding
The extracted field-name
Step 2: Text2Rule Converter
❖ Key Observation: All specification requirements tend to follow a specific semantic structure
Ø A message description: [field-name] header is [represent/valid/invalid/multiple]
Ø A role action: [role] respond [200/302/400] status code
❖ Textual Entailment Analysis:
Message
Description
a Transfer-Encoding header field is present in a request and the chunked 
transfer coding is not the final encoding
Specification 
Requirement Template
Q1: Transfer-Encoding header is represent ? 
Q2: Transfer-Encoding header is not represent ?
Q3: Transfer-Encoding header is valid ?
Q4: Transfer coding header is the final encoding ?
Q5: Transfer coding header is not the final encoding ? 
……
Yes
No 
No
No
Yes
Step 2: Text2Rule Converter
❖ Key Observation: All specification requirements tend to follow a specific semantic structure
Ø A message description: [field-name] header is [represent/valid/invalid/multiple]
Ø A role action: [role] respond [200/302/400] status code
❖ Textual Entailment Analysis:
Role 
Action
The server MUST respond with the 400 (Bad Request) status code and then 
close the connection.
Specification 
Requirement Template
Q1: Server respond 200 status code ? 
Q2: Server respond 302 status code?
Q3: Server respond 400 status code?
Q4: Server respond 403 status code?
Q5: Server respond 500 status code?
……
No
No 
Yes
No
No
Step 2: Text2Rule Converter
❖ Key Observation: All specification requirements tend to follow a specific semantic structure
Ø A message description: [field-name] header is [represent/valid/invalid/multiple]
Ø A role action: [role] respond [200/302/400] status code
❖ Text2Rule Converter:
If a Transfer-Encoding header field is present in a request and the chunked transfer coding is 
not the final encoding, the server MUST respond with the 400 (Bad Request) status code and 
then close the connection.
- RFC 7230
Role:
Message: 
Assertion: 
Server
Transfer-Encoding: present, transfer coding: not final 
Status_code: 400
Text2Rule Converter
The Converted Specification Requirement (SR) 
Research Challenges for Differential Testing
❖ Generating efficient test cases is not easy:
❖ Too distorted test cases are easy to be rejected by the target server
❖ Randomly generated test cases are not efficient
❖ Semantic gap bugs are hard to detect：
Ø No explicitly erroneous behavior, like crashes or memory corruption 
Application Crashes
Memory Corruption 
Step 3: Specification Requirement Translator
❖ SR Translator:
Ø Translate the converted specification requirement into test cases with assertions
ABNF rules
converted SR
ABNF generator
SR semantics
Basic Requests
Mutation
Test cases
The Workflow of SR translator
Role:
Message: 
Assertion: 
Server
Transfer-Encoding: present, transfer coding: not final 
Status_code: 400
The Converted SR
Assertion: Status_code: 400
An example of Test Cases
Step 4: Difference Analysis
❖ Semantic Metrics: 𝐻𝑀𝑒𝑡𝑟𝑖𝑐𝑠 =⟨𝑢𝑢𝑖𝑑,𝑠𝑡𝑎𝑡𝑢𝑠_𝑐𝑜𝑑𝑒,ℎ𝑜𝑠𝑡,𝑑𝑎𝑡𝑎, ...⟩
❖ Utilizing difference analysis to discover semantic gap attacks:
Assertion: status_code : 400
HTTP Implementations
Status_code : 200
violating the assertion
user 
check
CVE-2020-14589：
HTTP Request Smuggling 
The Test Workflow
Findings & Summary
Experiments and Findings
❖ Extracting 117 specification requirements and 269 ABNF rules from the HTTP
❖ Evaluating the effectiveness of discovering three representative semantic gap
1.1 core specifications (RFC 7230-7235)
attacks in 10 popular HTTP implementations
Ø Host of Troubles [CCS’16]
Ø HTTP Request Smuggling [BHUSA’19]
Ø Cache-Poisoned Denial-of-Service Attack [CCS’19]
Experiments and Findings
❖ Found 14 vulnerabilities, including three new types of attack payloads.
Attacker
Front-end Server
Back-end Server
GET /?id=1 HTTP/1.1
Host: example.com
Expect: 100-continue
malicious 
request
HTTP/1.1 400 Bad Request 
Content-Type: text/html; 
….
HTTP Response
victim
normal 
request
GET /?id=1 HTTP/1.1
Host: example.com
…
HTTP/1.1 400 Bad Request 
Content-Type: text/html; 
….
return the malicious response,
leading to the CPDoS attack
GET /?id=1 HTTP/1.1
Host: example.com
Expect: 100-continue
forward
 request
HTTP/1.1 400 Bad Request 
Content-Type: text/html; 
….
storage malicious
Cache resources.
HTTP/1.1 200 OK
Content-Type: text/html; 
….
The expected response
Hit the polluted 
cache resource
Case Study: the inconsistent processing of Expect header leading to the CPDoS attack
Experiments and Findings
❖ Found 29 exploitable server pairs
❖ Obtained 7 new CVEs
CVE-2019-17569, CVE-2020-1935
CVE-2020-0645
CVE-2020-14588       
CVE-2020-2867, CVE-2020-14589
CVE-2020-1944
❖ New Detecting Framework:
Summary
Ø HDiff, a novel detecting framework, exploring semantic gap attacks in HTTP
implementations
❖ New Findings:
Ø Finding 14 vulnerabilities and 29 vulnerable server pairs in 10 popular HTTP
implementations
❖ Responsible Disclosure:
Ø Receiving 7 new CVEs from IIS, Apache, Tomcat, and Weblogic
Thank you!
Q & A
HDiff: A Semi-automatic Framework for Discovering Semantic Gap 
Attack in HTTP Implementations
Kaiwen Shen, Jianyu Lu, Yaru Yang, Jianjun Chen, Mingming Zhang, Haixin
Duan, Jia Zhang, Xiaofeng Zheng 
Delegated Presenter: Shuai Hao
(Old Dominion University)
DSN 2022 - June 28, 2022
Tsinghua University Qi An Xin Group Corp