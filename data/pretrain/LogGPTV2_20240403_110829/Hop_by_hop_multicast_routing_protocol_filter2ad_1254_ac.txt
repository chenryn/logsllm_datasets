ulations. The curves show that HBH is eﬀectively able to
generate better quality routes than REUNITE in the pres-
ence of asymmetric unicast routing.
Figure 8(a) shows two unexpected results. First, PIM-
SM performs better that PIM-SS in terms of delay for the
ISP topology (in other words, the shared trees have a bet-
ter delay performance than the source trees). This fact is
explained because PIM-SS tree is a reverse SPT and not a
SPT. So delay is not minimized. Delay is not minimized
either in the shared tree constructed by PIM-SM. But in
the shared tree, the paths from the source to the diﬀerent
receivers all have one common portion, namely, the path
between the source and the RP. As data is encapsulated in
unicast between the source and the RP, delay is minimized
between the source and the RP. Consequently, paths in the
PIM-SM tree have two parts:
from the source to the RP
where delay is minimized and from the RP to the receiver
where it is not minimized since it is a reverse shortest path.
This explains the advantage of PIM-SM over PIM-SS. The
same was not observed for the 50-node topology because this
topology is larger and has a higher connectivity. Therefore
going through the RP is likely to result in a longer path than
going directly from the source to the receiver. The expected
result is observed, the shared tree having the worst delay
performance in this case.
The second important remark for the ISP topology is that
the eﬀect of the network asymmetries in the quality of RE-
UNITE trees may be strong, as REUNITE performed worse
than PIM-SM when the receiver set is large. REUNITE per-
forms better than PIM-SM in the 50-node topology, as this
topology has a higher connectivity.
The delay performance of HBH is better than that of RE-
UNITE for all group sizes, in both topologies. The advan-
tage becomes larger as the number of receivers grows, being
of 14% in average for the ISP topology. The absolute values
for the 50-node topology are smaller as this topology has a
higher connectivity. On the other hand, the advantage ob-
tained by HBH over REUNITE for this topology is larger
(30% in average). This is a consequence of its richer connec-
tivity, as the routing protocol has more choices to construct
the distribution tree, and is consequently more vulnerable
to unicast routing asymmetries.
5. CONCLUSIONS
We presented HBH, a multicast routing protocol that im-
plements multicast distribution through recursive unicast
trees, idea originally proposed in REUNITE [21]. HBH al-
lows the incremental deployment of the multicast service as
unicast routers inside the network are transparently sup-
ported. The observation of the strengths and weaknesses of
REUNITE and EXPRESS directed the design of HBH. The
objectives of HBH are:
• to go through unicast clouds;
• member departure should have minimum impact on
the tree structure;
• to provide lower cost trees in the cases where RE-
UNITE tree construction fails;
• to guarantee that members receive data through the
shortest path from the source.
HBH has an original tree management algorithm that is
based on three messages. Join messages are periodically
sent to the source by the receivers. The source periodically
)
s
t
i
n
u
e
m
i
t
(
y
a
l
e
D
)
s
t
i
n
u
e
m
i
t
(
y
a
l
e
D
18
17
16
15
14
13
12
11
10
16
14
12
10
8
6
4
2
0
Receiver Average delay
PIM−SM
PIM−SS
REUNITE
HBH
2
4
6
8
10
12
14
16
Number of receivers
(a) ISP topology.
Receiver average delay
PIM-SM
PIM-SS
REUNITE
HBH
5
10
15
25
30
20
Number of receivers
35
40
45
(b) 50-node random topology.
Figure 8: Average delay experienced by the re-
ceivers.
produces tree messages that are multicast to the receivers.
As the tree messages travels in the tree the intermediate
nodes may generate fusion messages that are responsible of
reﬁning the tree structure.
HBH is able to construct a Shortest-Path Tree even in the
presence of asymmetric unicast routing. HBH also provides
a better network utilization as it is able to construct recur-
sive unicast trees minimizing packet duplication. This is an
advantage if the network bandwidth is scarce. Addition-
ally, HBH’s delay performance makes it a routing protocol
adapted to applications that do not support large delays
such as interactive ones.
The results obtained through simulation show that the
unicast routing asymmetries aﬀect the performance of the
multicast routing protocol. Additionally, HBH is a promis-
ing approach as its tree construction algorithm outperformed
REUNITE in terms of the tree cost and the delay experi-
enced by the receivers. The advantage of HBH grows with
larger and more connected networks. Our future work in-
cludes the formal deﬁnition of the interface between HBH
and classical IP Multicast, and to study the possibility of
including QoS parameters inside HBH’s tree construction
algorithm.
6. ACKNOWLEDGMENTS
We insist to express our sincere gratitude to Supratik
Bhattacharyya (Sprint Labs.), Mark Handley (ACIRI), Luigi
Rizzo (Univ. of Pisa), and Lorenzo Vicisano (Cisco Systems)
for their constructive comments on this work, as well as the
SIGCOMM reviewers for their insightful remarks.
7. REFERENCES
[1] G. Apostolopoulos, R. Guerin, S. Kamat, and S. K.
Tripathi. Quality of service based routing: A
performance perspective. In ACM SIGCOMM’98,
pages 17–28, Sept. 1998.
[2] T. Bates, R. Chandra, D. Katz, and Y. Rekhter.
Multiprotocol Extensions for BGP-4. RFC 2283, Feb.
1998.
[3] S. Bhattacharyya, C. Diot, L. Giuliano, R. Rockell,
J. Meylor, D. Meyer, G. Shepherd, and B. Haberman.
An Overview of Source-Speciﬁc Multicast (SSM)
Deployment, May 2001. Work in progress:
draft-ietf-ssm-overview-00.txt.
[4] B. Cain, S. Deering, W. Fenner, I. Kouvelas, and
A. Thyagarajan. Internet Group Management
Protocol, Version 3, Mar. 2001. Work in progress:
draft-ietf-idmr-igmp-v3-07.txt.
[5] S. Deering. Host Extensions for IP Multicasting. RFC
1112, Aug. 1989.
[6] S. Deering, D. L. Estrin, D. Farinacci, V. Jacobson,
C.-G. Liu, and L. Mei. The PIM architecture for
wide-area multicast routing. IEEE/ACM Transactions
on Networking, 4(2):153–162, Apr. 1996.
[7] C. Diot, W. Dabbous, and J. Crowcroft. Multipoint
communication: A survey of protocols, functions and
mechanisms. IEEE Journal on Selected Areas in
Communications, 15(3):277–290, Apr. 1997.
[8] C. Diot, B. N. Levine, B. Liles, H. Kassem, and
D. Balensiefen. Deployment issues for the IP multicast
service and architecture. IEEE Network, pages 78–88,
Jan. 2000.
[9] D. Estrin, D. Farinacci, A. Helmy, D. Thaler,
S. Deering, M. Handley, V. Jacobson, C. Liu,
P. Sharma, and L. Wei. Protocol Independent
Multicast-Sparse Mode (PIM-SM): Protocol
Speciﬁcation. RFC 2362, June 1998.
[10] K. Fall and K. Varadhan. The ns Manual. UC
Berkeley, LBL, USC/ISI, and Xerox PARC, Jan. 2001.
Available at http://www.isi.edu/nsnam/ns/ns-
documentation.html.
[11] B. Fenner, M. Handley, H. Holbrook, and I. Kouvelas.
Protocol Independent Multicast - Sparse Mode
(PIM-SM): Protocol Speciﬁcation (Revised), Mar.
2001. Work in progress:
draft-ietf-pim-sm-v2-new-02.txt.
[12] W. Fenner. Internet Group Management Protocol,
Version 2. RFC 2236, Nov. 1997.
[13] R. Finlayson. The UDP Multicast Tunneling Protocol,
Mar. 2001. Work in progress:
draft-ﬁnlayson-umtp-06.txt.
[14] R. Finlayson, R. Perlman, and D. Rajwan.
Accelerating the Deployment of Multicast Using
Automatic Tunneling, Feb. 2001. Work in progress:
draft-ﬁnlayson-mboned-autotunneling-00.txt.
[15] S. Hanks, T. Li, D. Farinacci, and P. Traina. Generic
Routing Encapsulation (GRE). RFC 1701, Oct. 1994.
[16] H. W. Holbrook and D. R. Cheriton. IP multicast
channels: EXPRESS support for large-scale
single-source applications. In ACM SIGCOMM’99,
Sept. 1999.
[17] P. Liefooghe and M. Goossens. An architecture for
seamless access to multicast content. In IEEE
Conference on Local Computer Networks, Nov. 2000.
[18] D. Meyer (Editor) and B. Fenner (Editor). Multicast
Source Discovery Protocol (MSDP), May 2001. Work
in progress: draft-ietf-msdp-spec-10.txt.
[19] J. Moy. Multicast Extensions to OSPF. RFC 1584,
Mar. 1994.
[20] V. Paxson. End-to-end routing behavior in the
internet. IEEE/ACM Transactions on Networking,
5(5):601–615, Oct. 1997.
[21] I. Stoica, T. S. E. Ng, and H. Zhang. REUNITE: A
recursive unicast approach to multicast. In IEEE
INFOCOM’2000, Mar. 2000.
[22] D. Thaler, M. Talwar, L. Vicisano, and D. Ooms. IPv4
Automatic Multicast Without Explicit Tunnels, Feb.
2001. Work in progress:
draft-ietf-mboned-auto-multicast-00.txt.
[23] D. Waitzman, C. Partridge, and S. Deering. Distance
Vector Multicast Routing Protocol. RFC 1075, Nov.
1988.
APPENDIX
A. MESSAGE PROCESSING IN HBH
Figure 9 presents the processing rules of the three message
types used by HBH to construct the distribution tree. Each
receiver r periodically sends a join(S, r) in unicast to the
source. The source periodically multicasts a tree message
for each  channel.
Join message (Figure 9(a)) - When router B receives a
join(S, R), it should forward this message unchanged if B
has no MFT (1) or if R is not in B’s MFT (2). Only if B’s
MFT has a R entry, B intercepts the join(S, R) and sends a
join(S, B) afterwards. It means that B is a branching node
of the channel  (3).
Tree message (Figure 9(c)) - A tree(S, R) message re-
ceived by router B is treated and forwarded in multicast.
If B is a branching node, it may receive a tree message
addressed to B.
In this case B discards the message and
sends a tree message to each node present in its MFT (1).
If B is a branching node and tree(S, R) is not addressed to
B, there is two possibilities: R is a new receiver (in which
case B inserts R in its MFT and sends a f usion message
upstream) (2) or R is present in B’s MFT - which means
that B does not receive join(S, R) messages from R - and
in this case B simply has to refresh the R entry in its MFT
and to send a f usion message upstream (3). If B is not a
branching node, there is two possible cases: B was not in S’s
distribution tree in which case B creates a MCT containing
R (4), or B was already in the distribution tree but was not
a branching node (in which case B has a MCT) (5).
If R was already present in B’s MCT, nothing has changed
and B simply refreshes its MCT (6).
If R is not present
in the MCT, then maybe the MCT is stale in which case
R replaces the previous MCT entry, or the MCT is up to
date which means that there is a second receiver that will
receive data through B, so B becomes a branching node.
This implies the creation of a MFT, the destruction of the
MCT, and a f usion message to be sent upstream (8). The
f usion messages produced by B contain all the nodes that
B maintains in its MFT - the nodes for which B is branch-
ing node.
Fusion message (Figure 9(b)) - Suppose router B receives
a f usion(S, R, ...Rn) from node Bp. If the message is not
addressed to B, then B simply forwards it upstream (1). If
the message is addressed to B, then B marks the receiver
entries in its MFT that are listed in the f usion message
(2). A marked entry in the MFT is used to tree message
forwarding but not for data distribution. Bp is added to B’s
MFT if it was not previously present. In addition, Bp’s t1
timer is expired - Bp becomes stale (3). Consequently, Bp
will be used for data forwarding, but not for tree message
If Bp was already present in B’s MFT, then
forwarding.
Bp’s t2 timer is refreshed (it avoids the destruction of the
Bp entry), but its t1 timer is kept expired (4).
If afterwards Bp (the node that produced the f usion for
R, ...Rn) receives the join messages produced by any of
R, ...Rn, it intercepts them and send a join(S, Bp) upstream.
In this case the R, ...Rn entries in B’s MFT will eventually
timeout and be destroyed, while the Bp entry in B’s MFT
is refreshed by the join(S, Bp). If Bp does not receive join
messages from R, ...Rn, the emission of f usion messages
continues since there is another node upper in the tree that
receives the join(S, R, ...Rn) and periodically produce the
tree(S, R, ...Rn) messages to these receivers. Nevertheless,
this node will not forward data to these receivers, but to
Bp instead since the receivers’ entries are marked. Bp is
responsible for data duplication. It is in this way that HBH
is able to manage the second asymmetry problem presented
in Section 2.3.
(a) Join message.
(b) Fusion message.
(c) Tree message.
Figure 9: Message processing in HBH.