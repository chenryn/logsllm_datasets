## Page 131
指定元素等。表11-1总结如下。
CommonLisp还是提供了一个庞大的序列函数库。
11.4
一样，ELT也将把一个带有填充指针的向量视为其具有该填充指针所指定的长度。
度（左闭右开区间）的整数索引，并返回对应的元素。ELT将在索引超出边界时报错。和LENGTH
指针的向量，这些是填充指针的值。ELT是元素（element）的简称，它接受序列和从O到序列长
来访问个别元素。LENGTH接受序列作为其唯一的参数并返回它含有的元素数量。对于带有填充
有函数都是序列函数：除了可以应用于向量（无论是通用还是特化的）之外，它们还可应用于列表。
11.3作为序列的向量
COUNT
尽管理论上所有的序列操作都可归结于LENGTH、ELT和ELT的SETF操作的某种组合，但
两个最基本的序列函数是LENGTH，其返回一个序列的长度；ELT，其允许通过一个整数索引
114
SUBSTITUTE
REMOVE
POSITION
FIND
一组序列函数允许你无需编写显式循环就可以表达一些特定的序列操作，比如说查找或过滤
ELT也是一个支持SETF的位置，因此可以像这样来设置一个特定元素的值：
正如早先所提到的，向量和列表是抽象类型序列的两种具体子类型。接下来几节里讨论的所
(remove 1 #(1 2 12 3 1 2 3 4))
(count 1 #(1 2 1 2 3 1 2 3 4))
下面是一些关于如何使用这些函数的简单例子：
名
*x*→ #(10 2 3)
(setf (elt *x* 0) 10)
(elt*x*
(elt *x* 0)
(length *x*) →
(defparameter *x* (vector 1 2 3))
(remove
(remove
序列迭代函数
1t*x*
第11章集合
称
2
L
(12
→ error
↑
↑
2
3
新项、项和序列
项和序列
项和序列
项和序列
项和序列
所需参数
www.TopSage.com
表11-1
基本序列函数
()#
→3
“foobrbz"
项的实项被新项替换后的序列
项的实例被移除后的序列
序列中的索引NIL
项或NIL
序列中出现某项的次数
返
回
---
## Page 132
函数的元素的顺序，这些函数可能带有副作用。例如：
的：count，那么从哪一端开始显然至关重要：
个参数一起使用时可能影响REMOVE和SUBSTITUTE的行为。如果指定了一个低于匹配元素数量
单独使用只能影响FIND和POSITION的结果。例如：
边界指示。为：end传递NIL或是省略它与指定该序列的长度具有相同的效果。?
取出的关键值。
进行比对。但请注意，诸如FIND这类返回序列元素的函数将仍然返回实际的元素而不只是被抽
代替默认的对象等价性测试EQL来比较序列中的每个元素。“其次，使用：key关键字可以传递单
关键字来传递一个接受两个参数并返回一个布尔值的函数。如果有了这一函数，它将使用该函数
查看序列中与其项参数相同的对象。你可以用两种方式改变这一行为。首先，你可以使用：test
① 另一个形参：test-not指定了一个两参数谓词，它可以像：test参数那样使用除了带有逻辑上相反的布尔结果。
如果你使用非NIL的：from-end参数，那些序列的元素将以相反的顺序被检查。：from-end
②
尽管：from-end无法改变couNT函数的结果，但它确实可以影响传递给任何：test和:key
而：from-end参数和另一个关键字参数:count用于指定有多少个元素被移除或替换，这两
(find 'a #((a 10) (b 20) (a 30) (b 40)) :key #'first)
为了将这些函数的效果限制在序列实参的特定子序列上，你可以用：start和：end参数提供
CL-USER> (defparameter *v* #((a 10) (b 20) (a 30) (b 40)))
(=6uas:# as: ("ze μ "0)# u00u uno)
可以使用关键字参数以多种方式修改这五个函数的行为。例如，在默认情况下，这些函数会
注意，尽管如此，：Start和：end在REMOVE和SUBSTITUTE的效果仅限于它们所考虑移除或替换的元素，
注意，REMOVE和SUBSTITUTE总是返回与其序列实参相同类型的序列。
在:start之前和:end之后的元素将原封不动地传递。
(position 1#(1 212312 34))
(find10 #(121231234))
(substitute #\x #\b "foobarbaz")
substitute
(substitute 10 1 #(1 2 1 2 3 1 2 
(count x sequence :test-not #'some-test)
而不是这样：
count x sequence :test (complement #'some-test))
同数量参数的函数，其返回与原先函数逻辑上相反的结果。因此你可以而且也应该写成这样：
(b 20) (a 30)
2
www.TopSage.com
34)）
3
4）)
↑
→ #(10 210 2 310 2 3 4)
↑
I→
NIL
"fooxarxaz"
→"foobrbaz"
↓1
11.4序列选代函数
→ (A 10)
115
---
## Page 133
虑。不过，如果再次修订标准，更有可能被去掉的是-IF而非-IF-NOT系列。比如说，有个叫
另一类变体以-IF-NOT后缀命名并计数、查找、移除以及替换函数参数不返回真的元素。
有一个追加的-IF。这些函数用于计数、查找、移除以及替换序列中那些函数参数返回真的元素。
每个序列元素上调用的函数，以此来代替项参数。一组变体被命名为与基本函数相同的名字并带
11.5
对于每个刚刚讨论过的函数，
116
根据语言标准，这些-IF-NOT变体已经过时了。但这种过时通常被认为是由于标准本身欠考
(count-if #'evenp #(1 2 3 4 5))
表11-2总结了这些参数。
Looking
CL-USER> (count 'a *v* :key #'verbose-first :from-end t)
Looking
CL-USER> (count 'a *v* :key #'verbose-first)
VERBOSE-FIRST
((x as1ty) (x u%~s 2e 6uTyoo: a 4ewnoy) (x) asxts-asoqxaa u0gap) <a5-1
← (αtoo0poqe: d-xeuo-2t6tp,# J-uotatsod)
(count-if-not #'evenp #(1 2 3 4 5))
:count
: from-end
:start
:key
Looking
Looking at
Looking at
Looking
#{"foo"
:end 
:test
参
 高阶函数变体
第11章
数
at
at
at
"bar" "baz"
(A
(B 40)
(B40）
10
20
30）
30)
20)
10)
REMOVE和SUBSTITETE)
集合
NIL表示原样采用序列元素
数字代表需要移除或替换的元素个数，NIL代表全部。（仅用于
如果为真，序列将以相反的顺序遍历，从尾到头
子序列的终止索引(不含)。NIL表示到序列的结尾
子序列的起始索引（含）
单参数函数用来从实际的序列元素中解出用于比较的关键字值
两参数函数用来比较元素（或由：key函数解出的值）和项
"foom")）→#("foo"
，Common Lisp都提供了两种高阶函数变体，它们接受一个将在
表11-2
www.TopSage.com
标准序列函数关键字参数
含
↑
↓2
义
#foom"）
3
默认值
NIL
EQL
---
## Page 134
MARE-ARRAY的:element-type参数。这里最常用到的类型描述符是符号vECTOR、LIST和
产生何种类型的序列，因为其参数可能是不同类型的。它的第一个参数是类型描述符，就像是
COPY-SEQ简单地返回与其单一参数相同类型序列有所不同的是，CONCATENATE必须被显式指定
元素。注意，这两个函数都不会复制元素本身，只有返回的序列是一个新对象。
COPY-SEQ返回的序列包含与其参数相同的元素，而REVERSE返回的序列则含有顺序相反的相同
简单一些。例如，COPY-SEQ和REVERSE都接受单一的序列参数并返回一个相同类型的新序列。
11.6整个序列上的操作
字参数，因为它总是移除所有重复的元素。
数，并将其中每个重复的元素移除到只剩下一个实例。除：count外，它与REMOVE有相同的关键
代替实际元素传递给该函数。
REMOVE-IF-NOT的变体就比REMOVE-IF更经常使用。尽管它有一个听起来具有否定意义的名字，
但REMOVE-IF-NOT实际上是一个具有肯定意义的变体一
有一些函数每次在整个序列（或多个序列）上进行操作。这些函数比目前已描述的其他函数
③ 如果让CONCATENATE返回一个特化的向量，例如一个字符串，那么参数序列的所有元素都必须是该向量元素类
函数CONCATENATE创建一个将任意数量序列连接在一起的新序列。不过，跟REVERSE和
除了：test，这些-IF和-IF-NOT变体都接受和它们的原始版本相同的关键字参数，：test
?
① 同样的功能由Perl中的grep和Python中的filter所实现。
(remove-duplicates #(1 2 1 2 3 1 2 3 4)) → #(1 2 3 4)
REMOVE函数家族还支持第四个变体REMOVE-DUPLICATES，它接受序列作为仅需的必要参
((9  ).(  )# , )
(remove-if-not #'alpha-char-p
(count-if-not #'evenp #((1 a)(2 b) (3 c)(4 d)(5 e)):key #'first) → 3
(count-if #'evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #'first)
型的实例。
始变体不存在，你可以通过将一个特定的项嵌入到测试函数中，从而用-IF版本来实现它们。
来将序列元素与特定项相比较的两参数谓词，而-IF和-IF-NOT谓词是简单测试序列元素的单参数函数。如果原
作为：test参数传递的谓词与作为函数参数传递给-IF和-IF-NOT函数的谓词之间的区别在于：：test谓词是用
concatenate
(count char
(count char string =)