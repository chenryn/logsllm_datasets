h
g
i
H
Figure 1: Example payload for storing memValue to
memAddr for the scenario described in the text. This
payload will transfer control to address nextAddr after
writing to memory.
2.3 Return Oriented Programming
Return Oriented Programming is a generalization of the
return-to-libc attack. In a return-to-libc attack the attacker
reuses entire functions from libc. With ROP, the attacker
uses instruction sequences found in memory, called gad-
gets, and chains them together. ROP attacks are desir-
able because they allow the attacker to perform compu-
tations beyond the functions of libc (or whatever code
is unrandomized). This is especially important in the
context of modern systems, because the unrandomized
code may not contain useful funcions for the attacker.
Researchers [16, 21, 41] have shown that it is possible to
ﬁnd gadgets for performing Turing-complete operations
in libc, the windows kernel, and mobile phone libraries.
Example 2.1 (Return Oriented Programming). Assume
that the following instruction sequences are in memory
at addr1: pop %eax; ret; at addr2: pop %ebp;
ret; and at addr3: movl %eax, (%ebp); ret.
The ﬁrst two sequences pop a 32-bit value from the stack,
store it into a register, and then jump to the address stored
on the stack. If the attacker controls the stack and can
cause one of these instruction sequences to execute, then
the attacker can put values in %eax and %ebp and transfer
control to another address. By chaining together all three
instruction sequences, the attacker can write to memory
(and still transfer control to the next gadget). The at-
tacker’s payload for writing memValue to memAddr is
shown in Figure 1.
It is possible to execute arbitrary
programs by stringing together gadgets of different types.
3 System Overview
In the next two sections, we describe Q4, our system for
automatic exploit hardening. Figure 2 shows the end-to-
end workﬂow of Q, which is divided into two phases. The
ﬁrst phase automatically generates ROP payloads (Sec-
tion 4). The second phase is exploit hardening (Section 5).
In exploit hardening, Q takes the ROP payloads gener-
ated in the ﬁrst stage and transplants them into existing
exploits which do not bypass defenses. The resulting
exploit can then bypass W⊕X and ASLR.
4 Automatically
Oriented Payloads
Generating
Return-
Q’s end-to-end return oriented programming system con-
sists of a number of different stages. Previous research
on automated ROP has typically focused on one speciﬁc
stage; for instance, gadget discovery [16, 24, 38] or com-
pilation [6]. Since Q is an end-to-end ROP system, it has
multiple stages. We describe each stage in the context of
a user’s potential interaction with the system below.
4.1 Example Usage Scenario
Assume that Alice wants to create a ROP payload that
calls system (her target program) using instructions
from rsync’s unrandomized code (her source program).
Here, source program means the program from which Q
takes instruction sequences to construct gadgets (e.g., the
program with a vulnerability), and target program means
the program Alice wants to run (using ROP). Alice would
use the following stages of Q, which are depicted in the
top half of Figure 2:
Gadget Discovery The ﬁrst stage of Q is to ﬁnd gad-
gets in the source program that Alice provides — in this
case, rsync. The gadgets will be the building blocks for
the ROP payloads that are ultimately created, and thus it is
important to ﬁnd as many as possible. Q ﬁnds gadgets of
various types (speciﬁed in Table 2) by using semantic pro-
gram veriﬁcation techniques on the instruction sequences
found in rsync.
Q’s semantic engine allows it to ﬁnd gadgets that hu-
mans might miss. For instance, Q can automatically
determine that lea (%ebx,%ecx,1),%eax; ret
adds %ebx with %ecx and stores the result in %eax.
Likewise it discovers that sbb %eax, %eax; neg
%eax; ret moves the carry ﬂag (CF) to %eax.
4We name our system after Q from the James Bond movies, who cre-
ates, modiﬁes, and combines gadgets to help Bond meet his objectives.
4
Figure 2: An overview of Q’s design.
Input Alice writes the target program that she wants to
execute in Q’s high level language, QooL (shown in Table
3). The target program calls system with the desired
arguments (e.g., /bin/sh).
Gadget Arrangement Q builds a list of gadget ar-
rangements. Each gadget arrangement is a way of im-
plementing the target program using different types of
gadgets. For example, we show a gadget arrangement
for writing to memory in Figure 3; this arrangement is
the most natural way of storing to memory, but will not
work if Q can not ﬁnd a STOREMEMG gadget. Gadget
arrangement is somewhat analogous to instruction selec-
tion in a compiler. A major difference is that a regular
compiler can use whichever instructions it chooses, but
Q is limited to the gadget types that were found during
gadget discovery.
Gadget arrangement allows Q to cope with missing
gadgets. If the most natural choice of gadget is not avail-
able, Q effectively tries to synthesize a combination of
other gadgets that will have the same semantics. We are
not aware of other ROP compilers that consider this.
Gadget Assignment Gadget assignment takes gadgets
found during discovery, and assigns them in the arrange-
ments that Q generated. The difﬁculty is that assignments
must be compatible. This means that the output register of
one gadget must match the input register on the receiving
gadget. Likewise, gadgets cannot clobber a register if that
value is waiting to be used by a future gadget. This phase
is roughly analogous to register allocation in a traditional
compiler. Unlike a traditional compiler, Q cannot spill
registers to memory, since this usually increases register
pressure instead of decreasing it. As an example, Q as-
signs the following gadgets from rsync to implement
the gadget arrangement in Figure 3:
; Load value into %eax
pop %ebp; ret; xchg %eax, %ebp; ret
; Load address-0x14 into %ebx
pop %ebx; pop %ebp; ret
; Store memory
mov %eax, 0x14(%ebx); ret
Output Finally, as long as at least one of the gadget
arrangements has been assigned compatible gadgets, Q
prints out payload bytes that Alice can use in her exploit.
If Alice already has an exploit that no longer works be-
cause of W⊕X and ASLR, she can feed in the generated
ROP payload along with her old exploit to the second
phase of Q (see Section 5) to harden her exploit against
these defenses.
We now explain each stage of Q in more detail.
4.2 Gadget Discovery
Not every instruction sequence can be used as a gadget.
Q requires each gadget to satisfy four properties:
Functional Each gadget has a type (from Table 2) that
deﬁnes its function. In our system, a gadget’s type
is speciﬁed semantically by a boolean predicate that
must always be true after executing the gadget.
Control Preserving Each gadget must be capable of
transferring control to another gadget. In our system,
this means that the gadget must end with ret or
some semantically equivalent instruction sequence
(e.g., pop %eax; jmp *%eax).
Known Side-effects The gadget must not have unknown
side-effects. For instance, the gadget must not write
to any undesired memory locations.
Constant Stack Offset Most gadget types require the
stack pointer to increase by a constant offset after
each execution.
Although we found these requirements to work well,
we discuss alternatives to the control preservation and
5
Gadget DiscoveryGadget ArrangementGadget AssignmentExploit ConstraintGenerationDynamic Taint AnalysisSymbolic Execution SMT SolverSource Program(binary)TargetProgram(QooL)QPayload GenerationExploit HardeningHardenedExploitsSeed/BrokenExploitsROPPayloadsPayload Printerknown side-effects requirements in Section 8.
4.2.1 Gadget Types
The set of gadget types in Q deﬁnes a new instruction
set architecture (ISA) in which each gadget type func-
tions as an instruction. At a high-level, we specify the
meaning of each gadget type with a postcondition B that
must be true after executing it. Prior work has used dif-
ferent mechanisms for specifying gadget types, including
pattern matching on assembly instructions [21, 38] and
expression tree matching [16]. We found postconditions
to be more natural than these mechanisms. An instruction
sequence I satisﬁes a postcondition B if and only if the
post condition is true after running I from any starting
state. The starting state consists of assignments to reg-
isters and memory. The full list of gadget types that Q
can recognize is in Table 2, along with the corresponding
semantic deﬁnition postconditions.
4.2.2 Semantic Analysis
Given an instruction sequence I and a semantic deﬁnition
B, Q must decide if I will satisfy B. For this, we use a
well-known technique from program veriﬁcation for com-
puting the weakest precondition of a program [15, 17, 23].
At a high level, the weakest precondition WP(I,B) for
instructions I and postcondition B is a boolean precon-
dition that describes when I will terminate in a state
satisfying B.
We use weakest preconditions in Q to verify whether
the semantic deﬁnition of a gadget always holds after
executing the instruction sequence I. To do this, we
check if
WP(I,B) ≡ true.
(1)
If this formula is valid, then B always holds after execut-
ing I, and we can conclude that I is a gadget with the
semantic type B.
Our ﬁrst prototype used only this semantic analysis.
We found that it was too slow to be practical. We sped
up the entire process by performing a number of random
concrete executions, and evaluating each B concretely to
see if it was true. If B was false for any concrete input,
then the instruction sequence could not be a gadget for
that gadget type. Thus, we only need to invoke the more
expensive weakest precondition process when B is true
for every random concrete execution.
Random concrete execution can also be used to infer
possible parameter values (shown in Table 2) using dy-
namic analysis. For instance, by looking at the values
of all registers, and the addresses that memory was read
from, Q can compute a set of possible offsets for the
LOADMEMG gadget type.
As an example of how a gadget type is tested, con-
sider the LOADMEMG gadget type in Table 2. LOAD-
MEMG gadgets operate on two registers: the output reg-
ister and the address register. Each LOADMEMG gadget
has two parameters that are speciﬁc to a particular in-
struction sequence I. These will be found using dynamic
analysis as described above. For instance, the instruc-
tion sequence movl 0xc(%eax), %ebx; ret is a
LOADMEMG gadget with parameters {# Bytes ← 4} and
{Offset ← 12} and registers {OutReg ← %ebx} and
{AddrReg ← %eax}. The semantics for this instruction
sequence would be %ebx ← M[%eax + 12]. Q converts
this to final(%ebx) = initial(M [%eax + 12]),
which is the postcondition B that is checked for validity.
4.2.3 Gadget Discovery Algorithm
Our techniques for gadget discovery consist of two algo-
rithms. The ﬁrst, shown in Algorithm 1, tests whether
or not the semantics of an instruction sequence I match
those of any gadget type using randomized concrete test-
ing and validity checking of the weakest precondition. Al-
gorithm 1 also outputs some metadata (not shown) about
each gadget for use in other Q algorithms, including the
gadget’s address, stack offset, and any registers that the
gadget clobbers. The second algorithm iterates over the
executable bytes of the source program, disassembles
them, and calls the ﬁrst algorithm as a subroutine. This
is similar to the Galileo [41] algorithm, and so we do not
replicate it here.
Algorithm 1 Automatically test an instruction sequence
I for gadgets
Input: I, numRuns, gadgetT ypes[]
for i = 1 to numRuns do
outState[i] ← I(Random input)
end for
5: for gtype ∈ gadgetT ypes do
B ← postconditions[gtype]
consistent ← true
for j = 1 to numRuns do
consistent ← false
if B(outState[j]) ≡ false then
end if
end for
if consistent = true then {Possibly a gadget of type gtype}
F ← wp(I, B)
if decisionP roc(F ≡ true) = Valid then
output {Output gadget I as type gtype}
10:
15:
6
end if
end if
end for
Name
NOOPG
JUMPG
MOVEREGG
LOADCONSTG
ARITHMETICG
LOADMEMG
STOREMEMG
ARITHMETICLOADG
ARITHMETICSTOREG
Input
—
AddrReg
InReg, OutReg
OutReg, Value
InReg1, InReg2, OutReg
AddrReg, OutReg
AddrReg, InReg
OutReg, AddrReg
InReg, AddrReg
Semantic Deﬁnition
Parameters
Does not change memory or registers
—
EIP ← AddrReg + Offset
Offset
OutReg ← InReg
—
OutReg ← Value
—
OutReg ← InReg1 ♦b InReg2
♦b
OutReg ← M[AddrReg + Offset]
# Bytes, Offset
M[AddrReg + Offset] ← InReg
# Bytes, Offset
OutReg ♦b← M[AddrReg + Offset]
# Bytes, Offset, ♦b
# Bytes, Offset, ♦b M[AddrReg + Offset] ♦b← InReg
Table 2: Types of gadgets that Q can ﬁnd. M[addr] means accessing memory at address addr. ♦b means an arbitrary
binary operation. a ← b denotes that ﬁnal value of a equals the initial value of b. X ♦b← Y is short for X ← X ♦b Y.
4.3 Gadget Arrangement
Q acts similar to a compiler — it reads in programs written
in QooL (discussed below) and tries to implement them in
terms of the gadgets shown in Table 2. The gadgets deﬁne
an instruction set architecture. Thus, we can use some
techniques from compiler theory. However, Q must deal
with several hard problems not faced by most compilers:
• Only a few registers can be used for moving, access-
ing memory, and performing arithmetic operations.
• Most instructions will clobber (modify) the majority
• Some instruction types may not be available at all.
Although we use existing compiler techniques when
possible, many of the standard compiler techniques break
down.