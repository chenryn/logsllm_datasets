that the OS knows where to find it on the system. When using su on a Linux system, it asks for the target user’s
password to authenticate the action. However, on Android a different approach is commonly taken because the
root user does not have a password. Different root manager application developers use different technical
methods but they both come down to the same concept for the user. When an application executes su, an
activity is displayed to the user requesting the user’s permission to grant the requesting application root context.
These applications usually display information about the application requesting root and what it is attempting
to execute. Figure 6.10 shows an example of a prompt from the SuperSU application.
Figure 6.10 The prompt displayed by SuperSU to allow an application access to root context.
This application works by using a custom version of su that sends a broadcast directly to a broadcast receiver in
the SuperSU application. This broadcast contains the requesting application’s information as well as relevant
details about which command will be executed as root. After this broadcast is received by the application it
displays a prompt to the user with the supplied information. The su binary then polls a file in the private data
directory to find out whether permission was granted by the user. According to the user’s decision, su decides to
setuid(0) or not.
The information just presented explains how you can allow applications to execute commands as root in a user-
controlled manner that in theory is safe. Another objective that an attacker may pursue is gaining persistent
root access on a device under his control without the user noticing. For this purpose, a completely unprotected
custom version of su is included with drozer as part of the tools.setup.minimalsu module. This su version is
meant to be used for post-exploitation on older devices and should not be used for everyday purposes. Here is
the code for it:
#include 
#include 
int main(int argc, char **argv)
{
if (setgid(0) || setuid(0))
fprintf(stderr, "su: permission denied\n");
else
{
char *args[argc + 1];
args[0] = "sh";
args[argc] = NULL;
int i;
for (i = 1; i  
where  was a set of predefined values. Using command injection found in the code handling the
parsing of user input, the author of the exploit could run the following command and gain a root shell on
the device:
$ cmdclient misc_command ';sh'
#
This and other variations have been reported to work on other devices as well, including a family of
Motorola devices and any other device that contains this vulnerable binary.
MASTER KEY BUGS—EXPLOITING ANDROID AOSP SYSTEM CODE
The “master key” code signing bug explained earlier in the “Code Signing” section has far-reaching
consequences for Android. Not only can it allow you to repackage an application without breaking its
signatures but you can also use it to obtain system access on a device. This level of access can translate to
root access on a device, depending on the version. The method used is to pull an existing system
application off the device that runs under the system context (by specifying a sharedUserId of
android.uid.system in its manifest), change the file’s manifest (making it debuggable), and then install it
back onto the device. It is then possible with ADB access to inject new classes into the newly debuggable
application, essentially executing code as the system user. On versions of Android prior to 4.2 (Jelly Bean)
converting this to root access is possible by adding configuration commands to /data/local.prop that
force the ADB daemon to be started as root.
This method works on all versions of Android that are vulnerable to these code-signing issues, which at
the time of writing was the large majority. A tool named Cydia Impactor was created by Jay Freeman
(saurik) that automates this process (see http://www.cydiaimpactor.com/). Figure 6.11 shows the
functionality available.
Figure 6.11 The options available on Cydia Impactor to make use of code-signing bugs to obtain system
and root.
More information about the exact method used by this tool to exploit such code signing issues appears at
http://www.saurik.com/id/17.
TOWELROOT—EXPLOITING LINUX KERNEL VULNERABILITIES ON ANDROID
In addition to having its own attack surface, Android also inherits many of the exploitable kernel bugs
found in the main Linux kernel tree. An example of this is CVE-2014-3153. This vulnerability is in the
futex (fast userspace mutex) mechanism in the Linux kernel that is responsible for the management of
locks used when threading. The vulnerability was discovered by a talented bug-hunter named Nicholas
Allegra (comex) and exploited by George Hotz (geohot) in his widely known exploit dubbed Towelroot (see
https://towelroot.com/). The Towelroot exploit can be used to gain root access on many Android devices
but was famous for being the first to allow the rooting of a Samsung Galaxy S5. Any device with a kernel
build date prior to 16 June 2014 and a kernel version greater than 2.6.29 is vulnerable to this issue
according to Bill Anderson (see http://www.all-things-android.com/content/android-and-linux-
kernel-towelroot-exploit). The exploitation of this vulnerability is very involved and various security
researchers have written in-depth reviews of this vulnerability and exploitation techniques that achieve a
full privilege escalation to root from a completely unprivileged context. Exploits for this vulnerability can
be used to gain root access from an ADB shell or any application with no specific permissions which
makes it very dangerous.
Using an Unlocked Bootloader
Some devices come with a user-unlockable bootloader that allows you to flash new firmware onto it. Various
methods can be used to obtain root using an unlocked bootloader. The most common ways are flashing a new
recovery image or flashing a pre-rooted kernel image that already contains the su binary. This may void the
warranty of your device or if you do not know what you are doing, you may leave your device in an irrecoverable
state.
FLASHING A CUSTOM RECOVERY IMAGE ONTO A NEXUS DEVICE
The bootloader on Google Nexus devices makes use of a protocol named fastboot, which allows a user to
perform a number of low-level operations on the device such as flashing new firmware, erasing partitions,
and unlocking and locking the bootloader. To get into the bootloader of a Nexus device, hold both volume
buttons and the power button when the device is powered off. Alternatively, perform the following
command with the device attached to your computer:
$ adb reboot bootloader
This should boot the device directly into the bootloader, showing options like Start, Restart Bootloader,
Recovery mode, and Power off that can be toggled with the volume keys. You can now interact with
fastboot from your computer. To check whether the device is connected, use the fastboot utility that came
with the Android SDK and make sure that an entry appears:
$ sudo fastboot devices
014691490900600D fastboot
Unlock the bootloader using the following command:
$ sudo fastboot oem unlock
...
OKAY [ 55.995s]
finished. total time: 55.995s
This displays a screen asking whether you are sure you want to unlock the bootloader and that you may
void your warranty. If you agree to the information presented, after a few seconds the screen returns to
the bootloader. It should now show “LOCK STATE - UNLOCKED” in the bottom left of the device’s screen.
At this stage you can load a custom recovery image that allows you to perform privileged operations on
your device, such as place a su binary on your filesystem.
A very popular recovery image that has an extensive list of functionality is ClockWorkMod. To find the
supported devices and downloads for each, go to http://www.clockworkmod.com/rommanager. However, for
the purposes of obtaining root on a Samsung or Nexus device in the simplest manner, you can use a
custom recovery firmware image named CF-Autoroot. CF-Autoroot is made by Chainfire who is the creator
of SuperSU. By downloading CF-Autoroot, which contains a recovery firmware image that automatically
places SuperSU and the su binary on your filesystem and reboots the phone, you obtain a rooted device in
minimal time and steps. You can find the download at http://autoroot.chainfire.eu/#fastboot for your
Nexus device. Download and unzip the archive until you find a file with an extension of .img. This
recovery image is flashed onto the device using the following command:
$ sudo fastboot flash recovery CF-Auto-Root-maguro-yakju-galaxynexus.img
sending 'recovery' (6084 KB)...
OKAY [ 0.816s]
writing 'recovery'...
OKAY [ 0.669s]
finished. total time: 1.485s
Scroll to the Recovery Mode option in the bootloader and press the power button to boot into CF-Autoroot.
A screen appears that shows you the details of the rooting process, and then it reboots the device. At this
point, all the required files for root access have been placed on the device and it is rooted. If possible,
locking your bootloader again after flashing is generally a good idea. If you leave it unlocked, you are
opening up your device to attack if someone gains physical access to it. On devices that use fastboot you
can perform the following command to lock your bootloader again:
$ sudo fastboot oem lock
...
OKAY [ 0.126s]
finished. total time: 0.126s
Other device manufacturers may also provide unlocked bootloaders but different tools and protocols to perform
flashing operations. A good example of this is Samsung; you can use a tool named ODIN to flash any Samsung
device. A vast number of guides are on the Internet on how to use tools from each manufacturer and where to
get custom system and recovery images.
Reverse-Engineering Applications
Reverse-engineering is the process of gaining a deep understanding of a system or application by only having
the finished product at hand. Being able to understand what is happening under the hood of an application that
you do not have the source code of is the basis of reverse-engineering. A very different mindset and set of skills
is needed when compared to performing source code review of an application. This section covers the multiple
techniques and tools required to reverse engineer Android applications. First, having the APK file of your target
application is crucial. This may be an application that is already installed on a device you have or one that is
available on the Play Store (or some other app store).
Retrieving APK Files
If the application you are targeting is on a device that you are able to get ADB access to, you can use this access
to retrieve the APK file. Sometimes, finding the package name of a target application can be tricky. For example,
look at the twitter application. The following approach lists all installed packages on the device and looks
specifically for the word twitter:
$ adb shell pm list packages | grep twitter
package:com.twitter.android
This package was easy to find because it had a predictable word in the package name. However, this may not
always be the case. For example, to find the package that is started when you click the Terminal Emulator
launcher icon, run your search in drozer using the app.packages.list command with a filter for this
application’s label.
dz> run app.package.list -f "Terminal Emulator"
jackpal.androidterm (Terminal Emulator)
This application would not have been found using the ADB method. To pull this application off the device you
first need to find the path where the APK is stored, which you can do using ADB as follows:
$ adb shell pm path jackpal.androidterm
package:/data/app/jackpal.androidterm-2.apk
Or using drozer’s app.package.info module and observing the APK Path line in the output:
dz> run app.package.info -a jackpal.androidterm
Package: jackpal.androidterm
Application Label: Terminal Emulator
Process Name: jackpal.androidterm
Version: 1.0.59
Data Directory: /data/data/jackpal.androidterm
APK Path: /data/app/jackpal.androidterm-2.apk
UID: 10215
GID: [3003, 1015, 1023, 1028]
Shared Libraries: null
Shared User ID: null
Uses Permissions:
- android.permission.INTERNET
- android.permission.WRITE_EXTERNAL_STORAGE
- android.permission.ACCESS_SUPERUSER
- android.permission.WAKE_LOCK
- android.permission.READ_EXTERNAL_STORAGE
Defines Permissions:
- jackpal.androidterm.permission.RUN_SCRIPT
- jackpal.androidterm.permission.APPEND_TO_PATH
- jackpal.androidterm.permission.PREPEND_TO_PATH
To reverse engineer applications from the Play Store, you would need to install them onto a device you own and
then use the preceding method. However, sometimes the application you are targeting is not available in the
Play Store from your country. You can overcome this issue by using sites to which you provide the package
name or Play Store link to your target application, and they provide a direct APK download. Two such sites are
http://apkleecher.com/
http://apps.evozi.com/apk-downloader/
Viewing Manifests
A big part of understanding an Android application is obtaining and reviewing the AndroidManifest.xml file
associated with the package. A number of tools are available to do this, and this section discusses three of them.
aapt
The Android Asset Packaging Tool (aapt) that comes with the Android SDK can be used to dump binary resource
files included in an APK. To dump the manifest of the drozer agent using aapt, perform the following command:
$ aapt dump xmltree /path/to/agent.apk AndroidManifest.xml
N: android=http://schemas.android.com/apk/res/android