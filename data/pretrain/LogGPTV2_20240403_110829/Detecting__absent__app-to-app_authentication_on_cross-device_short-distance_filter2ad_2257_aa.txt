title:Detecting (absent) app-to-app authentication on cross-device short-distance
channels
author:Stefano Cristalli and
Long Lu and
Danilo Bruschi and
Andrea Lanzi
Detecting (Absent) App-to-app Authentication on Cross-device
Short-distance Channels
Stefano Cristalli
PI:EMAIL
University of Milan
Milan, Italy
Danilo Bruschi
PI:EMAIL
University of Milan
Milan, Italy
Long Lu
PI:EMAIL
Northeastern University
Boston, Massachusetts
Andrea Lanzi
PI:EMAIL
University of Milan
Milan, Italy
ABSTRACT
Short-distance or near-field communication is increasingly used by
mobile apps for interacting or exchanging data in a cross-device
fashion. In this paper, we identify a security issue, namely cross-
device app-to-app communication hijacking (or CATCH), that affect
Android apps using short-distance channels (e.g., Bluetooth and
Wi-Fi-Direct). This issue causes unauthenticated or malicious app-
to-app interactions even when the underlying communication chan-
nels are authenticated and secured. In addition to discovering the
security issue, we design an algorithm based on data-flow analysis
for detecting the presence of CATCH in Android apps. Our algo-
rithm checks if a given app contains an app-to-app authentication
scheme, necessary for preventing CATCH. We perform experiments
on a set of Android apps and show the CATCH problem is always
present on the whole analyzed applications set. We also discuss
the impact of the problem in real scenarios by presenting two real
case studies. At the end of the paper we reported limitations of our
model along with future improvements.
CCS CONCEPTS
• Security and privacy → Authentication; Mobile and wireless
security; Software and application security.
KEYWORDS
android, data-flow analysis, authentication protocols, mobile secu-
rity
ACM Reference Format:
Stefano Cristalli, Long Lu, Danilo Bruschi, and Andrea Lanzi. 2019. Detect-
ing (Absent) App-to-app Authentication on Cross-device Short-distance
Channels. In 2019 Annual Computer Security Applications Conference (ACSAC
’19), December 9–13, 2019, San Juan, PR, USA. ACM, New York, NY, USA,
11 pages. https://doi.org/10.1145/3359789.3359814
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
© 2019 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-7628-0/19/12.
https://doi.org/10.1145/3359789.3359814
1 INTRODUCTION
Cross-device communications allow nearby devices to directly com-
municate bypassing cellular base stations (BSs) or access points
(APs) [13, 17, 18] . Such a paradigm can bring many benefits, such
as spectral efficiency improvement, energy saving, and delay reduc-
tion. Without the need for infrastructure, such a technology enables
mobile users (e.g., Android) to instantly share information (e.g., pic-
tures and videos) with each other, even in areas without cellular
coverage or access points [21]. It is also becoming an important
technology for mobile social networks [12]: friends close to each
other can be automatically identified and paired up. Moreover, this
technology is used to establish the so-called mobile ad-hoc clouds,
which take advantage of unused resources of nearby devices to
provide cloud services, such as data and computation offloading.
This is also a typical case of IoT environment, where IoT devices
communicate with each other on short-distance channels [10].
Several solutions exist for securing cross-device communication.
In the Android environment, they allow authentication of devices
and communication channels [11, 20]. However, these solutions are
not sufficient to protect the entire communication flow. Specifically,
the proposed protection system in [11] restricts apps’ access to
external resources, such as Bluetooth, SMS and NFC, by defining
new SEAndroid types to represent the resources based upon their
identities observed from their channels. The policies bind an app to
a particular device on a specific channel. In this case, a malicious
app installed on one device, which is allowed to communicate with
a paired phone, can interfere with the communication and inject
data on the channel. This problem is due to the fact that the authen-
tication between apps is missing, and such authentication is needed
in addition to the device-level and channel-level authentication.
One can solve this problem by designing Android access control
at system level for preventing an unauthorized access to commu-
nication channel (e.g, Bluetooth) during security operations, and
removing public resources for stopping side-channel attacks [20].
This, however, makes the system less usable and compatible for the
apps that already use the public resources for legitimate purposes.
Moreover, these systems do not handle channels such as: SMS,
Audio, Wi-Fi and NFC. We name this security issue cross-device
app-to-app communication hijacking, or CATCH. We argue that
CATCH is critical and is due to the fact that no APIs or mechanisms
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
Stefano Cristalli, Long Lu, Danilo Bruschi, and Andrea Lanzi
are made available to Android programmers for performing app-
level authentication on short-distance channels (e.g., Bluetooth,
Wi-Fi-Direct).
In this paper, we study the problem of mutual authentication
between two apps running on two different devices and commu-
nicating over a short-distance channel. Although such channels
already provide device pairing and authentication methods, these
methods only operate at the device or channel level. They are obliv-
ious to the apps running on the devices. In this study, we first define
the authentication scheme for short-distance channels. We then
design a new tool that is able to analyze a given Android app and
detect potential CATCH vulnerabilities (i.e., the lack of app-to-app
authentication). Our tool uses several data-flow analysis techniques
and is able to recognize specific if-statement conditions in the code
related to the authentication scheme. Such particular conditions
can be precisely recognized since, in our context, the analyzed
authentication model must be performed with some sort of dynam-
ically generated secret (out-of- band authentication) (Section 3.1)
that is usually stored in the dynamic memory (e.g. heap, stack).
We perform some experiments to show the flexibility of our tool
on detecting authentication schemes, even when the target app
has been manipulated with the ProGuard obfuscator, one on the
most used obfuscators for Android [3]. Our tool can be deployed in
several contexts: it can serve as a tool for the developer, or it can
scan apps in distributing environments (e.g. Google Play) for de-
tecting potential vulnerabilities on Android apps that communicate
by using short-distance channels.
In summary, this paper makes the following contributions:
• We identify a security problem called cross-device app-to-
app communication hijacking (CATCH), which commonly
exists in Android apps that use short-distance channels, and
afflicts all the tested Android versions. We perform experi-
ments on a dataset that contains 662 Android apps that use
Bluetooth technology, collected in the Androzoo repository.
• We provide a solution to the CATCH problem by design-
ing and developing an authentication scheme detector that
analyzes Android apps to discover potential vulnerabilities.
We tackle several challenges in identifying code boundaries
of the authentication scheme, along with the authentication
checks.
• We validate the results of our system on Android apps with
manual analysis, and test its resilience in detecting the au-
thentication scheme. The results show that our approach
produces 0% of false positives and false negatives. We also
show two case studies on real Android apps.
2 BACKGROUND
In this section we provide the necessary background to understand
the security vulnerabilities in Android apps performing peer-to-
peer communication.
2.1 Authentication for Cross-device
App-to-app Communication
In this paper we study the problem of mutual authentication be-
tween two apps running on different devices and communicating
over a short-distance channel. Although such channels already
provide device pairing and authentication methods, these meth-
ods only operate at the channel level: they allow two devices to
be paired and mutually authenticated (i.e., establishing a channel)
but they are oblivious of the apps running on the devices (i.e., all
apps on these devices share this established channel). As a result,
when two devices are paired and authenticated at the channel level,
it is possible for a malicious app on one device to interfere in a
communication on the channel between two legitimate apps.
Currently, most cross-device, peer-to-peer communications chan-
nels are authenticated by using an out-of-band scheme that works
as follows. A user (requesting user) A initiates a communication
from his device to a nearby device, whose user (accepting user) B
is then prompted with confirmation. The confirmation is requested
either with a secret PIN that B has to communicate to A via a sepa-
rate channel (e.g., verbally), or as a simple “accept” button presented
along with information that enables the identification of the de-
vice trying to initiate the communication. These steps are already
implemented in Android; one never needs to re-implement authen-
tication for the communication channel. Once authentication has
passed, communication can begin. Bluetooth uses encryption to
protect the channel. It is important to note two points related to
authentication in this scenario:
(1) Authentication occurs via sharing of out-of-band informa-
tion/secret.
(2) Authentication performed on the channel (Figure 1) is not
sufficient to guarantee authentication between higher level
applications communicating over the channel.
Point 1) is important as a general property of authentications
performed in our scenario. The exchanged information needed to
confirm authentication is, in practice, visual and verbal contact
between the two users, and the out-of-band element is a constant
in all this type of authentications. More strongly, we exclude the
possibility of authentication being carried out exclusively via infor-
mation passed on the same channel being authenticated, as a result
of previous research [8, 26].
Figure 1: Authentication of A2A communication is not guar-
anteed by channel authentication
To understand why the lack of app-level authentication is dan-
gerous, let us consider the following example (Figure 2): a chat
app using Wi-Fi-Direct opens a ServerSocket, accepting commu-
nication through it and display incoming messages to the final
user.
The intended use of the app is to be installed on two devices
that communicate with each other in a peer-to-peer fashion. We
also consider the presence of a malicious app on one device, this
is a common threat model, as shown in [20]. Since the devices are
Detecting (Absent) App-to-app Authentication on Cross-device Short-distance Channels
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
authenticated, and not the apps, the malicious app has permission
to communicate over the channel, as any other app installed on the
device. The malicious app can therefore craft custom messages to
send to the other device, which are displayed as if they were sent
from the original app. If there is no code performing authentication
in the benign app, there is no possibility of detecting this sort of
action.
Depending on the particular context, there are some scenarios
in which the attack can become very dangerous:
• Phishing: in cases like the example described above, the ma-
licious app could send phishing material to the other app.
The user will be likely to trust and open the content, as he
will have no means to distinguish it from benign content
sent from the device communicating with him.
• Malware delivery: the same system could be used to deliver
malware to the user, in the form of malicious files that would
trigger a vulnerability upon opening (for instance, a mali-
cious PDF file that targets a vulnerable PDF reader).
• Exploitation: if the target app performs internal operations
depending on commands received from the communication
channel, the malicious app could send commands that could
change the execution flow and trigger unwanted behavior.
For instance, a command to delete the user data could be
issued to a file manager app that accepts operations via
Bluetooth device.
It is important to note that other network attacks such as MiTM
are difficult to accomplish in this context, since the attacker should
be physically close to the devices in order to hijack the commu-
nication, and would also need to overcome or bypass the channel
protections, such as encryption. For this reason we believe that
the attack explained above is the most realistic in this environ-
ment. We name the underlying problem common to all these sce-
narios cross-device app-to-app communication hijacking, or
CATCH. Having established the potential impact of the problem,
we aim at building a system for automatic analysis of Android apps,
targeted at detecting the presence (or lack thereof) of authentica-
tion on particular communication channels. The purpose of our
system is to provide a tool that will help app developers to secure
their software. Moreover, our detector can also be used as a security
scanner on app markets (e.g., Google Play) for detecting potential
authentication vulnerabilities.
Figure 2: Malicious app sending content to chat app
3 APPROACH OVERVIEW
This section describes the design and structure of our approach. We
build our system with the goal of automatically verifying the exis-
tence of app-to-app authentication in Android apps. To detect app
authentication in an automated way, we mainly face the following
challenges:
C1) We need to define a generic scheme that captures the es-
sential logic of app-to-app authentication. Such a scheme is
necessary for identifying and evaluating the implementation
of authentication in apps. (Section 3.1)
C2) We need to define a strategy for differentiating between an if-
statement that does not operate on security critical data and
an if-statement that is a part of the authentication scheme.
(Section 3.2)
C3) Additionally, the authentication scheme can be implemented
in several ways according to the developer experience. This
adds an additional layer of difficulty for our analysis, that
should be general enough to also capture such cases. (Section
3.2)
We now proceed to illustrate our approach for building an analysis
tool that is able to tackle these challenges and provide accurate
results in terms of detection.
3.1 Authentication Definition
In this section we define an authentication scheme for cross-device
communication in Android environment. More specifically our au-
thentication model considers two devices, D1 and D2, with apps A1
and A2 respectively installed. The two devices establish an authenti-
cated channel, on top of which A1 and A2 initiate a communication.
Such form of authentication proposes authenticated information
exchange between mobile devices using several methods different
than the standard RF channel [26]. These are called out-of-band,
side-channels or location-limited channels (LLCs) [28], and include
audio, visual, infrared, ultrasound, and other forms of transmis-
sion [7, 23, 24, 27]. Such techniques allow the receiver to physically
verify the source of the transmission. Using this information, the
devices are mutually authenticated, and a secure shared key can be
established. More precisely in such an authentication scheme we
recognize the following steps:
(1) A2 obtains a secret that will be used to authenticate commu-
nication. This secret is either generated on device D2, and
then communicated to app A1, or it is generated by D1 and
then shared with A2. Such a communication uses an out-of-
band channel which is also called a “human assisted channel”.
Such a channel cannot be manipulated by an attacker, and
thus it is considered trusted by definition.
(2) Once A1 and A2 share the same secret, they can start send-
ing data, using the secret as authenticator. Depending on
what the secret is and the application protocol, the data
could be encrypted with a key derived from the secret (e.g.,
Hash(Secret)), or the secret could be sent as plaintext along
with the data for authenticating the transmission.
(3) In both cases (encryption with key derived from the secret,
or secret sent with data as a simple pass-phrase/PIN), app
A2 needs to perform authentication checks on the received