to emulate the vulnerabilities of diﬀerent operating systems and computer archi-
tectures on a single machine and during a single attack (i.e., an emulation can
mimic the generic parts of a network conversation and depending on the network
traﬃc decide whether it wants to be a Linux or a Win32 machine for example).
This improves the scalability. We report on experiments showing that nepenthes
is also scalable by emulating more than 16.000 diﬀerent IP addresses on a sin-
gle physical machine. Furthermore, through its ﬂexible reporting mechanisms,
nepenthes can be deployed in a hierarchical manner increasing scalability even
further. Automation is further supported through the modularity of nepenthes,
which oﬀers the possibility to add specialized analysis and reporting modules.
With the help of the nepenthes platform, we are able to collect malware that
is currently spreading in the wild on a large-scale. Since we focus on malware
that is currently spreading, we can carry out a vulnerability assessment based on
live data. Furthermore, the collected malware samples enable us to examine the
eﬀectiveness of current anti-virus engines. Furthermore, since we collect malware
on a large-scale, we can also detect new trends or attack patterns. We will present
more results in Section 3.
In summary, nepenthes is a unique novel combination of expressiveness, scal-
ability and ﬂexibility in honeypot-based research.
Related work. Large-scale measurements of malicious network traﬃc have been
the focus of previous research. With the help of approaches like the network
telescope [11] or darknets [4] it is possible to observe large parts of the Internet
and monitor malicious activities. In contrast to nepenthes, these approaches
passively collect information about the network status and can infere further
information from it, e.g., inferring the amount of Distributed Denial-of-Service
attacks [12]. By not responding to the packets, it is not possible to learn more
about full attacks. Slightly more expressive approaches like the Internet Motion
Sensor [2] diﬀerentiate services by replying to a TCP SYN paket with TCP
SYN-ACK pakets. However, their expressiveness is also limited and only with
further extensions it is possible to also learn more about spreading malware.
honeyd [14] is a prominent example of a low-interaction honeypot. This dae-
mon creates virtual hosts on a network. It simulates the TCP/IP stack of arbi-
trary operating systems and can be conﬁgured to run arbitrary services. These
services are generally small scripts that emulate real services, and oﬀer only
168
P. Baecher et al.
a limited expressiveness. Honeyd can simulate arbitrary network topologies in-
cluding dedicated routes and routers, and can be conﬁgured to feign latency
and packet loss. In summary, this tool can emulate complex networks by simu-
lating diﬀerent hosts with any kind of services and help to learn about attacks
from a high-level point of view. In contrast to nepenthes, honeyd does not oﬀer
as much expressiveness since the reply capabilities of honeyd are limited from
a network point of view. Nepenthes can be used as a subsystem for honeyd,
however. This extends honeyd and enables a way to combine both approaches:
nepenthes acts then as a component of honeyd and is capable of dealing with
automated downloading of malware.
The Collapsar platform [9] is a virtual-machine-based architecture for network
attack detention. It allows to host and manage several high-interaction virtual
honeypots in a local dedicated network. Malicious traﬃc is redirected from other
networks (decentralized honeypot presence) to this central network which hosts
all honeypots (centralized honeypot management). This enables a way to build
a honeyfarm. Note that the idea of a honeyfarm is not tied to the notion of a
high-interaction honeypot: It is also possible to deploy nepenthes as a honey-
farm system by redirecting traﬃc from remote locations to a central nepenthes
server.
Internet Sink (iSink) [23] is a system that passively monitors network traf-
ﬁc and is also able to actively respond to incoming connection requests. The
design is stateless and therefore the expressiveness of the responses is limited.
Similarly, HoneyTank [19] is a system that implements stateless responders to
network probes. This allows to collect information about malicious activties to
a limited amount. Statelessness implies that the expressiveness is limited. In
contrast to these systems, nepenthes implements a ﬁnite state machine to em-
ulate vulnerabilities. This allows us to collect more detailed information about
an attack.
Closest to our work is the Potemkin virtual honeyfarm by Vrable et al. [20].
Potemkin exploits virtual machines, aggressive memory sharing, and late bind-
ing of resources to emulate more than 64,000 high-interaction honeypots using
ten physical servers. This approach is promising, but has currently several draw-
backs compared to nepenthes: Firstly, each honeypot within Potemkin has to
be a ﬁxed system in a ﬁxed conﬁguration. In contrast to this, the vulnerability
modules of nepenthes allow greater ﬂexibility. As mentioned above, nepenthes
can react for example on exploitation attempts against Windows 2000 and Win-
dows XP, even regardless of service pack. It would even be possible to emulate
on a single nepenthes honeypot vulnerabilities for diﬀerent operating systems
and even diﬀerent processor architectures. Secondly, the scalability of nepenthes
is at least as good as the scalability of Potemkin. Thirdly, there are currently
only preliminary results for the scalability of Potemkin. In [20], the authors give
only results for a representative 10 minutes period. Since the implementation of
Potemkin is not publicly available, we can not verify these results. In contrast
to this, nepenthes runs stable for weeks and the source code is available under
the GNU General Public License.
The Nepenthes Platform: An Eﬃcient Approach to Collect Malware
169
Roadmap. This paper is outlined as follows: Section 2 presents the nepenthes
platform in detail and in Section 3 we show the results of our work, especially
focusing on the eﬀectiveness of this approach. We give an overview of future
work in Section 4 and conclude the paper in Section 5.
2 The Nepenthes Platform
In this section we introduce the nepenthes platform in detail. We show how the
concept of low-interaction honeypots can be extended to eﬀectively develop a
method to collect malware. In addition, this platform can be used to learn more
about attack patterns. Moreover, we present a technique to use this platform in
a distributed way, similar to the concepts introduced by Collapsar [9].
The main idea behind nepenthes is emulation of vulnerable services. Cur-
rently, there are two main concepts in this area: honeyd scripts simply emulate
the necessary parts of a service to fool automated tools or very low-skilled at-
tackers. This allows a large-scale deployment with thousands of low-interaction
honeypots in parallel. But this approach has some limits: with honeyd it is not
possible to emulate more complex protocols, e.g., a full emulation of FTP data
channels is not possible. In contrast to this, high-interaction GenIII honeypots
use a real system and thus do not have to emulate a service. The drawback of this
approach is the poor scalability. Deploying several thousand of these honeypots
is not possible due to limitations in maintenance and hardware requirements.
Virtual approaches like Potemkin [20] are in an early stage of development and
it is currently not clear how they will perform in real-world scenarios, although
preliminary results look very promising.
The gap between these two approaches can be ﬁlled with the help of the
nepenthes platform. It allows to deploy several thousands of honeypots in parallel
with only moderate requirements in hardware and maintenance. This platform
enables us to eﬃciently deploy thousands of honeypots in parallel and collect
information about malicious network traﬃc.
2.1 Architecture of the Nepenthes Platform
nepenthes is based upon a very ﬂexible and modularized design. The core – the
actual daemon – handles the network interface and coordinates the actions of
the other modules. The actual work is carried out by several modules, which
register themselves in the nepenthes core. Currently, there are several diﬀerent
types of modules:
– Vulnerability modules emulate the vulnerable parts of network services.
– Shellcode parsing modules analyze the payload received by one of the vulner-
ability modules. These modules analyze the received shellcode, an assembly
language program, and extract information about the propagating malware
from it.
– Fetch modules use the information extracted by the shellcode parsing mod-
ules to download the malware from a remote location.
170
P. Baecher et al.
Fig. 1. Concept behind nepenthes platform
– Submission modules take care of the downloaded malware, e.g., by saving
the binary to a hard disc, storing it in a database, or sending it to anti-virus
vendors.
– Logging modules log information about the emulation process and help in
getting an overview of patterns in the collected data.
In addition, several further components are important for the functionality
and eﬃciency of the nepenthes platform: shell emulation, a virtual ﬁlesystem for
each emulated shell, geolocation modules, sniﬃng modules to learn more about
new activity on speciﬁed ports, and asynchronous DNS resolution.
The schematic interaction between the diﬀerent components is depicted in
Figure 1 and we introduce the diﬀerent building blocks in the next paragraphs.
Vulnerability modules are the main factor of the nepenthes platform. They en-
able an eﬀective mechanism to collect malware. The main idea behind these mod-
ules is the following observation: in order to get infected by autonomous spreading
malware, it is suﬃcient to only emulate the necessary parts of a vulnerable ser-
vice. So instead of emulating the whole service, we only need to emulate the relevant
parts and thus are able to eﬃciently implement this emulation. Moreover, this con-
cepts leads to a scalable architecture and the possibility of large-scale deployment
due to only moderate requirements on processing resources and memory. Often the
emulation can be very simple: we just need to provide some minimal information at
certain oﬀsets in the network ﬂow during the exploitation process. This is enough
to fool the autonomous spreading malware and make it believe that it can actu-
ally exploit our honeypot. This is an example of the deception techniques used in
honeypot-based research. With the help of vulnerability modules we trigger an in-
coming exploitation attempt and eventually we receive the actual payload, which
is then passed to the next type of modules.
Shellcode parsing modules analyze the received payload and extract automat-
ically relevant information about the exploitation attempt. Currently, only one
The Nepenthes Platform: An Eﬃcient Approach to Collect Malware
171
shellcode parsing module is capable of analyzing all shellcodes we have found
in the wild. The module works in the following way: ﬁrst, it tries to decode
the shellcode. Most of the shellcodes are encrypted with an XOR encoder. An
XOR decoder is a common way to encrypt the actual shellcode in order to evade
intrusion detection systems and avoid string processing functions. Afterwards
the module decodes the code itself according to the computed key and then
applies some pattern detection, e.g., CreateProcess() or generic URL detec-
tion patterns. The results are further analyzed (e.g., to extract credentials) and
if enough information can be reconstructed to download the malware from the
remote location, this information is passed to the next kind of modules. A shell-
code module that parses shellcodes in an even more generic way by emulating a
Windows operating system environment is currently in development.
Fetch modules have the task of downloading ﬁles from the remote location.
Currently, there are seven diﬀerent fetch modules. The protocols TFTP, HTTP,
FTP and csend/creceive (an IRC-based submission method) are supported. Since
some kinds of autonomous spreading malware use custom protocols for propa-
gation, there are also fetch modules to handle these custom protocols. Fetching
ﬁles from a remote location implies that the system running nepenthes contacts
other machines in the Internet. From an ethical point of view, this could be a
problem since systems not under our control are contacted. A normal computer
system that is infected by autonomous spreading malware would react in the
same way, therefore we have no concerns fetching the malware from the remote
location. However, it is possible to turn oﬀ the fetch modules. Then the system
collects information about exploitation attempts and can still be useful as some
kind of warning system.
Finally, submission modules handle successfully downloaded ﬁles. Currently
there are four diﬀerent types of submission modules:
– A module that stores the ﬁle in a conﬁgurable location on the ﬁlesystem and
is also capable of changing the ownership.
– A module that submits the ﬁle to a central database to enable distributed
sensors with central logging interface.
– A module that submits the ﬁle to another nepenthes instance to enable a
hierarchical structure of nepenthes sensors.
– A module that submits the ﬁle to an antivirus vendor for further analysis.
Certain malware does not spread by downloading shellcodes, but by providing
a shell to the attacker. Therefore it is sometimes required to spawn and emulate
a Windows shell. nepenthes oﬀers shell emulation by emulating a rudimentary
Windows shell to enable a shell interaction for the attacker. Several commands
can be interpreted and batch ﬁle execution is supported. Such a limited sim-
ulation has proven to be suﬃcient to trick automated attacks. Based on the
collected information from the shell session, it is then possible to also download
the corresponding malware.
A common technique to infect a host via a shell is to write commands for
downloading and executing malware into a temporary batch ﬁle and then execute
172
P. Baecher et al.
Fig. 2. Setup of distributed nepenthes platform
it. Therefore, a virtual ﬁlesystem is implemented to enable this type of attacks.
This helps in scalability since ﬁles are only created on demand, similar to copy-
on-write: when the incoming attack tries to create a ﬁle, this ﬁle is created
on demand and subsequently, the attacking process can modify and access it.
All this is done virtually, to enable a higher eﬃciency. Every shell session has
its own virtual ﬁlesystem, so that concurrent infection sessions using similar
exploits do not infere with each other. The temporary ﬁle is analyzed after the
attacking process has ﬁnished and based on this information, the malware is
downloaded from the Internet automatically. This mechanism is similar to cages
in Symantec’s ManTrap honeypot solution [18].
Nepenthes has several advantages compared to other solutions to automati-
cally collect malware. On the one hand, nepenthes is a very stable architecture.
A wrong oﬀset or a broken exploit will not lead to crashes, as opposed to other
attempts in this area. On the other hand, nepenthes scales well to even a large
number of IP addresses in parallel. By hierarchical deployment, it is very easy
to cover even larger parts of the network space with only limited resources.
2.2 Flexible Deployment
Nepenthes oﬀers a very ﬂexible design that allows a wide array of possible setups.
The most simple setup is a local nepenthes sensor, deployed in a LAN. It collects
information about malicious, local traﬃc and stores the information on the local
hard disc. More advanced uses of nepenthes are possible with a distributed ap-
proach. Figure 2 illustrates a possible setup of a distributed nepenthes platform:
a local nepenthes sensor in a LAN collects information about suspicious traﬃc
The Nepenthes Platform: An Eﬃcient Approach to Collect Malware
173
there. This sensor stores the collected information in a local database and also
forwards all information to another nepenthes sensor.
A second setup is a hierarchical one (depicted in the middle of Figure 2): a
distributed structure with several levels is build and each level sends the col-
lected information to the sensor at the higher level. In such a way, load can be
distributed across several sensor or information about diﬀerent network ranges
can be collected in a central and eﬃcient way.
Thirdly, traﬃc can be re-routed from a LAN to a remote nepenthes sensor
with the help of a VPN tunnel (depicted on the right). This approach is similar
to the network setup of the Collapsar project [9]. It enables a ﬂexible setup for
network attack detention. Furthermore, it simpliﬁes deployment and requires
less maintenance.
2.3 Capturing New Exploits
An important factor of a honeypot-based system is also the ability to detect
and respond to zero-day (0day) attacks, e.g., attack that exploit an unknown
vulnerability or at least a vulnerability for which no patch is available. The
nepenthes platform also has the capability to respond to this kind of threat. The
two basic blocks for this ability are the portwatch and bridging modules. These
modules can track network traﬃc at network ports and help in the analysis of
new exploits. By capturing the traﬃc with the help of the portwatch module,
we can at least learn more about any new threat since we have already a full
network capture of the ﬁrst few packets. In addition, nepenthes can be extended
to really handle 0day attacks. If a new exploit targets the nepenthes platform,
it will trigger the ﬁrst steps of a vulnerability module. At some point, the new
exploit will diverge from the emulation. This divergence can be detected and
then we perform a switch (hot swap) to either a real honeypot or some kind of
specialized system for dynamic taint analysis, e.g. Argos [13]. This second system
is an instance of the system nepenthes is emulating vulnerabilities for and shares
the internal state with it. This approach is similar to shadow honeypots [1].
With the help of the nepenthes platform, we can eﬃciently handle all known
exploits. Once something new is propagating in the wild, we switch from our
emulation to a real honeypot to capture all aspects of the new attack. From
the captured information, we are also able to respond to this new threat and
automatically extract response patterns. The mechanism behind this is rather
simple, but eﬀective. We record the network ﬂow and extract from this ﬂow the
necessary information to build a full vulnerability module. The whole mechanism
could presumably also be extended to build a fully automated system to respond
to new threats. Since the honeypot has by deﬁnition no false positives, we can
assume that all traﬃc is malicious. For known malicious traﬃc, we can respond
with the correct replies. For unknown malicious code, we need to learn the correct
replies with the help of a shadow honeypot. Based on the correct replies, a
learning algorithm could be used to extract all dynamic data inside the replies
(e.g., timestamps) and a correct vulnerability module could be built on-the-ﬂy.
These ideas are currently in development.
174
P. Baecher et al.
2.4 Limitations
We also identiﬁed several limitations of the nepenthes platform which we present
in this section. First, nepenthes is only capable of collecting malware that is au-
tonomously spreading, i.e., that propagates further by scanning for vulnerable
systems and then exploits them. This is a limitation that nepenthes has in com-
mon with most honeypot-based approaches: a web site that contains a browser
exploit which is only triggered when the web site is accessed will not be de-
tected with ordinary honeypots due to their passive nature. The way out of
this dilemma is to use client-side honeypots like HoneyMonkeys [22] or Kathy
Wang’s honeyclient [21] to detect this kind of attacks. The modular architecture
of nepenthes would enable this kind of vulnerability modules, but this is not the
aim of the nepenthes platform. The results in Section 3.2 show that nepenthes
is rather able to collect many diﬀerent types of bots [7].
Secondly, malware that propagates by using a hitlist to ﬁnd vulnerable systems
[17] is hard to detect with nepenthes. This is a limitation that nepenthes has in
common with all current honeypot-based systems and also other approaches in
the area of vulnerability assessment. Here, the solution of the problem would be
to become part of the hitlist. If for example the malware generates its hitlist by
querying a search engine for vulnerable systems, the trick would be to smuggle
a honeypot system in the index of the search engine. Currently it is unclear how
such an advertisement could be implemented within the nepenthes platform.
Thirdly, it is possible to remotely detect the presence of nepenthes: since a ne-