created partial arborescences that could not be ﬁxed locally,
i.e., which would require a non-trivial amount of restructuring.
Stretch on AS graphs. The stretch of the arborescence
packings T generated by greedy and RR-swap is shown in
Fig. 10, where we depict the median stretch for the different
connectivities, along with the 5th to 95th percentiles. As can
be seen, RR-swap performs clearly better than greedy, where in
many cases not even the 5th to 95th percentile ranges overlap.
On the other hand, the differences are not as prominent as for
0
200
400
size
600
Fig. 11. Median computation time for the arborescence packings T (up to
20 each) of the different algorithms on the well-connected cores of different
ASes, plotted over the size of the graphs. The (very small) bars display the
5th to 95th percentile. For each AS and algorithm, we have up to four data
points, representing the different sizes for |T | ∈ {4, 5, 6, 7}.
random regular graphs, and in some cases, the RR-swap results
are missing. Another interesting observation is that higher
connectivity not always implies better stretch. For example in
AS1221, the stretch goes up with lower connectivity whereas
in AS1239, lower connectivity implies lower stretch.
Computation time for AS graphs. The computation time (in
seconds) of the arborescence packings T is shown in Fig. 11.
We used the machine employed for the random regular graphs.
We note that for better visibility, the y-axis (the computation
time) is depicted on a logarithmic scale. Similar as for random
regular graphs, the RR-swap method greatly outperforms the
greedy method: the reason is (again) that the runtime of greedy
is dominated by the connectivity computations, whereas RR-
swap needs to perform relatively few swaps, as swaps are
heavily optimized as well, recall the end of Section IV.
8
C. Concluding Remarks
While the round robin approach can still get stuck despite
swapping, it reaches much better stretch than the random and
greedy approach. Consequently, it makes sense to combine them
in practice: if round robin with swapping returns k complete
arborescences, they are taken (this is also the fastest algorithm
without the connectivity condition); otherwise greedy is run,
which in turn outperforms the random approach.
VI. GUARANTEES BEYOND k − 1 FAILURES
In the ﬁrst few sections, we implicitly restricted ourselves to
a resiliency of at most k − 1 failures in in k-connected graphs.
For a general adversarial failure model this is a natural choice,
as no more than k disjoint arborescences can be used if the
graph is not (k + 1)-connected, along with the observation that
k failures might disconnect the graph.
In this section, we will theoretically analyze how good stretch
properties can allow us to cope with situations that go beyond
k − 1 failures, by assuming that these failures are distributed
over the network, in the sense that they are clustered [31],
respectively only few appear locally.6 This will allow us to
leverage the locality properties of our failover schemes, as, in
some sense, past failures stop to matter after a certain point.
To this end, we will next ﬁrst deﬁne a parametrized spatial
failure distribution in Section VI-A, followed by its application
to circular arborescence routing schemes in Section VI-B.
A. Failure Ball Distribution
We begin by introducing so-called b-balls, which will contain
at most b failed links, also deﬁning their pairwise distance.
Deﬁnition 1: Let G = (V, E) be a graph with a set of failed
links F ⊂ E. We call a set of at most b ≤ |F | links from F a
b-ball. The distance dist(B, B′) between two b-balls B, B′ is
deﬁned as mine∈B,e′∈B ′ dist(e, e′).
We now use these b-balls to cover all failures of a graph,
where the existence of such a cover requires that the balls can
be chosen in such a way that they maintain a minimum speciﬁed
distance to each other. The idea is to parametrize the spatial
distribution of failures over the graph, so only a pre-deﬁned
amount of failures may be locally clustered.
Deﬁnition 2: Let G = (V, E) be a graph with a set of failed
links F ⊂ E. We say that G has a (b, c)-failure cover, if there
exists a set B of b-balls, with ∪B∈BB = F , such that for any
two b−balls B, B′ ∈ B, B 6= B′, the following two conditions
hold: 1) B ∩ B′ = ∅, 2) dist(B, B′) ≥ c.
In other words, the b-balls in B cover all failures, are pairwise
disjoint, and have minimum distance of c from each other. An
example is shown in Figure 12. Furthermore, if c > 0, then
Condition 2) also includes Condition 1), i.e., B ∩ B′ = ∅.
Note that so far, we only speciﬁed the term resiliency for
arbitrary link failures. In addition, we can also deﬁne resiliency
of an algorithm to a speciﬁc set of failures on a given graph.
6For example in data centers, “Corruption has weak spatial locality” [38].
B1
← c →
B2
← c →
B3
G
Fig. 12. Illustration of a (b, c)-failure cover with b = 2 and {B1, B2, B3} =
B. Only the failed links (dotted) and their incident nodes are depicted. All
remaining links in the graph G are free from failures.
Deﬁnition 3: Let A be a routing scheme with default and
(conditional) failover ﬂow rules, as speciﬁed in Section II. Let
G = (V, E) be a graph with a set of failed links F ⊂ E. If
A successfully routes packets on G under link failure set F ,
then we say A is F -resilient for G.
We now apply these deﬁnitions to circular arborescence
routing schemes to be resilient to arbitrarily many failures
under certain conditions.
B. Usage in Circular Arborescence Routing
To cope with spatially distributed failures, we need routing
schemes that do not deviate too much from the shortest
path after encountering a failed link. An illustration for the
contrary is the Hamiltonian cycle technique described in [15,
§B.6]. Consider that packets follow Hamiltonian cycles. When
encountering the ﬁrst failure on the current cycle, they start
traversing it in the opposite direction. This approach can induce
an additive stretch of Ω(n) after a single failure, as a single
failure close to the destination can lead to touring nearly the
entire graph.
Instead, we desire circular arborescence techniques that
impose a small additive stretch of x ∈ N, i.e., for each
arborescence it holds that routing from a node v to t along an
arborescence leads to the traversal of at most dist(v, t)+x hops,
if no failures occur. We now show that circular arborescence
routing with small stretch is resilient to arbitrarily many failures,
as long as we can partition the failures into balls of large enough
distance. Conceptually, our ideas take some inspiration from
geometric ad-hoc/local routing paradigms [39], [40]
Theorem 2: Let A be a r-resilient circular arc-disjoint
arborescence routing scheme for a graph family G, where
each of its r′ > r arborescences imposes an additive stretch of
at most x. Let G ∈ G with a link failure set F . If there exists
an (r, xr + x + r + 1)-failure cover for G w.r.t. F , then A is
F -resilient for G.
The proof idea can be roughly summarized as follows: each
hit failure can derail a packet only by a certain amount from its
course to the destination, namely at most the additive stretch of
the next arborescence picked. Thus, if there exists a failure ball
coverage s.t. the failure balls have a distance slightly greater
than the total detour possible by a single ball, the packet will
not return to a previous failure.
At ﬁrst glance, it might seem as if a distance between balls
that is only slightly larger than the detour caused by a single
arborescence would be a sufﬁcient distance between two failure
balls. However, note that the Deﬁnition 1 of failure balls did
9
B2
B1
(cid:0) c (cid:1)
B2
Fig. 13. Visual representation of a (b, c)-failure cover where a b-ball B2
surrounds another b-ball B1. A valid routing, going from top to bottom for
example, might hit errors in B2, then route towards B1 where additional
failures are encountered, and then hit failures in B2 again. If the routing
scheme and the (b, c)-failure cover are improperly speciﬁed, this could result
in an inﬁnite loop where packets bounce between failures inside of B1, B2.
not include any convexity structure, only an upper limit on the
number of contained failures. Hence, one failure ball B1 could
surround a link failure from another failure ball B2, inducing
a loop where the packet bounces between failure sequences
in B1 and B2, see Figure 13 for an example. Similarly, we
would like to point out that Theorem 2 holds as long as any
such speciﬁed failure cover exists.
Proof of Theorem 2: We prove in the following that A
is F -resilient for G. To this end, we show that A cannot loop
indeﬁnitely on G if an (r, xr + x + r + 1)-failure cover exists
for F . Observe that if G is ﬁnite, the only way to prevent a
packet from looping is allowing it to reach its destination. We
now consider for contradictory purposes the last loop that a
packet ends up in, that is, the shortest closed walk W that is
eventually repeated indeﬁnitely. As A is deterministic, such
a walk W must exist. If the packet never hits a failed link
in W , triggering a conditional failover ﬂow rule, then the
packet must reach the destination: as no failure is hit, the
packet never changes its arborescence, but that implies that the
arborescence has a loop, a contradiction. Thus, the remaining
case to be analyzed concerns a packet hitting failures, and
changing arborescences accordingly. Should the walk W be
conﬁned to only hitting failures from a single r-ball, then we
arrive at a contradiction again: the ball has at most r failures,
i.e., by starting appropriately at one of these failures, we must
either reach the destination or hit a failure from another r-ball.
Recall that we have r′ > r arc-disjoint arborescences.
Hence, if a packet loops, it must hit failures from different
r-balls, where W may hit at most r failures, possibly once
from each of the up to 2r incident nodes, in a single ball
before encountering a failure in another ball. For each such
r-ball traversal, we can deﬁne the (node, in-port7)-pair where
the last error is hit before a change to another ball occurs.
Note that such a pair is unique in W , as A is deterministic. So
far, we may have many of these pairs for a single ball, as W
could traverse a single ball multiple times, especially since we
did not require the r-balls to form some sort of local cluster.
From this pair set, pick w1 where the contained node, w.l.o.g.
v1 ∈ B1 ∈ B8 is of minimum distance to the destination, and
7When starting at a node emitting a packet, we assume the in-port to belong
to the initially chosen arborescence.
8We slightly abuse notation here, by also including incident nodes.
10
denote the next such pair when following W by w2, where its
contained node is v2 ∈ B1 ∈ B (not necessarily of minimum
distance to t).
After w1, let the next pair along W which contains a node
v′
2 ∈ B2 be denoted by w′
2. As B2 has at most ℓ failures,
where each may be hit once from each incident node, we
obtain dist(v2, t) ≤ dist(v′
2, t) + 2xr, due to the fact that
every arborescence change can increase the distance to the
destination by at most x. We can improve this bound. While
each failure hit can detour the packet by x, summing up these
hops is only important for the stretch (see the later Corollary 2),
not for the distance from v′
2. When a failed link (u1, v1) = e1
is hit from u1, and we later hit it again from v1, we increased
the distance at most by one. Hence, we achieve the following
improved bound: dist(v2, t) ≤ dist(v′
2, t) + xr + r. A will
route (uninterrupted by hitting failures) along an arborescence
between w1 and w′
2) ≥ xr + x + r + 1. As
each arborescence has a stretch of at most x it holds that:
dist(v′
2, t) ≤ dist(v1, t) − (xr + x + r + 1) + x = dist(v1, t) −
xr − r − 1.
2, with dist(v1, v′
Combining the inequalities yields: dist(v2, t) ≤ dist(v1, t)−
xr − r − 1 + xr + r = dist(v1, t) − 1.
However, we chose w1 s.t. dist(v1, t) ≤ dist(v2, t), a
contradiction to earlier inequalities. Hence, we have shown
that A cannot loop as w1 is the last (node,in-port)-pair visited
where a failure is hit, i.e., we obtained F -resiliency for G.
As such, circular arborescence routing can tolerate arbitrarily
many failures, assuming that the failure distribution is spatially
appropriate. The total additive stretch remains bounded by the
product of the total number of possible failure hits and the
additive stretch of the arborescences:
Corollary 2: Let A be a F -resilient circular arc-disjoint
arborescence routing scheme for G, where each arborescence
imposes an additive stretch of at most x. The additive stretch
of A on G under F is at most 2x|F |.
Proof: As circular arborescence routing changes the
arborescence after each failure hit, A incurs only an additive
stretch of at most x each time. Note that the combination of
node and in-port results in a unique next routing decision, for
a given set of failures. Assume that we change arborescences
more than 2|F | times. Then, due to the pigeonhole principle,
we hit some link failure twice with the same (node,in-port)
combination, which results in a forwarding loop. However,
we showed in Theorem 2 that A is F -resilient for G, a
contradiction which completes the proof of Corollary 2.
We would like to note that the circular property is crucial
to the results of this section, as it properly deﬁnes how the
routing scheme reacts after r failures were hit. Observe that
by just following the deﬁnition of resilience, no proper routing
has to be deﬁned after r failures were encountered. As such,
we can envision to extend the resiliency beyond r failures for
other routing schemes, by appropriately specifying the routing
behavior after r failures.
VII. RELATED WORK
Failures are common. Many network outages have been
attributed to link failures and are well-documented in the
literature, e.g., [41], [42], [43], [44], and there is also much
literature on the empirical characterization of failures, e.g., in
backbone networks [3], [45], [46], [47].
Fast failover. A key challenge in designing resilient networks
is that ensuring connectivity via the control plane can be
slow [7], [48]. Hence, many networks (additionally) provide
data plane mechanisms to preserve connectivity [9], [11], [12]
and allowing the deﬁnition of planned backup paths. The
preferred mechanism depends on the network: datacenters often
rely on the ECMP data plane algorithm (see also [49] for a
recent study of datacenter network reliability) while many
WAN networks rely on MPLS Fast Reroute [7]; supporting a
faster failover was one of the main reasons for Google’s move
to SDN [50].
Single vs multiple failures. Much existing fault-tolerant and
robust routing solutions revolve around single failures [51],
[52], [53], [54], which however may be insufﬁcient to provide
high availability in more complex scenarios, e.g., shared risk
link groups [55], attacks [56], node failures [2], [5], [9], [24].
A well-known example in the literature is the Internet outage
in Pakistan in 2011 which was due to a failure in both a link
and its backup [41].
Dynamic tables. A classic approach to deal with multiple
failures, which has been studied intensively in the literature,
is to use Gafni and Bertsekas’ link reversal algorithm [21], or
one of its extensions [57], [58], [59]. However, link reversal
algorithms require dynamic tables which are not always
supported; furthermore, the approach can introduce non-trivial
delays [60]. An interesting recent contribution in this area is
by Liu et al. [7] who proposed a link reversal algorithm suited
for the data plane: DCC provides provable connectivity and
can tolerate arbitrary delays and losses.
Alternative approaches: duplication, header modiﬁcation,
scaling. Other approaches to deal with multiple link failures
require packet header rewriting [25], [61] (e.g., packets relay
failure information [62], [63]) or packet-duplication [64], which
however consumes header space or introduces additional loads,
respectively. Yet another approach is to pre-compute multiple
ﬂow paths s.t. even in the event of multiple failures, the
ingress switches can rescale the trafﬁc load efﬁciently without
additional computational overhead [65].
What-if analysis tools. Not only the design of robust al-
gorithms has been studied intensively in the literature, but
also the question how to efﬁciently verify the robustness of a