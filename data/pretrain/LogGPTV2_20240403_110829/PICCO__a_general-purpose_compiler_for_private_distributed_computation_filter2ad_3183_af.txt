[ mergesort(l, m); ]
[ mergesort(m + 1, r); ]
for (i = size >> 1; i > 0; i = i >> 1)
for (j = 0; j  A[k+i+l]) {
A[k+l] = A[k+i+l];
A[k+i+l] = tmp[k];
}
]
]
}
}
Figure 5: Mergesort median program that uses concurrent
computation (the difference from basic program).
public int main() {
public int i, M;
smcinput(M, 1, 1);
private int A[M], B[M];
private int dist = 0;
smcinput(A, 1, M);
smcinput(B, 1, M);
for (i = 0; i  A[M], B[M];
private int dist;
smcinput(A, 1, M);
smcinput(B, 1, M);
dist = A @ B;
dist = -2*dist;
for (i = 0; i < M; i++) {
dist += A[i] + B[i];
}
smcoutput(dist, 1);
return 0;
}
Figure 7: Hamming distance program that uses concurrent
computation.
the input strings. Each cell at position (i, j) is computed as the
minimum of three distances computed from the distances at cells
(i − 1, j), (i, j − 1), (i − 1, j − 1) and the result of comparison
of the characters at positions i and j. The optimized version of the
program processes all cells on a diagonal in parallel, resulting in
2m − 3 rounds that compute the minimum function.
Lastly, the ﬁngerprint program compares one minutia of ﬁnger-
print A to all minutiae of ﬁngerprint B, and among those that
matched (i.e., within close Euclidean distance and small angle)
chooses the one with the closest distance. The chosen minutia in
ﬁngerprint B is marked as no longer available. The process is re-
peated with all other minutiae of ﬁngerprint A, where all minutiae
marked as no longer available are ignored in ﬁnding a matching.
The output of the algorithm is the number of minutiae marked as
having a mate in the other ﬁngerprint. The optimized version of this
program runs all distance and orientation comparisons for a minu-
tia in ﬁngerprint A in parallel. It then also computes the minimum
and its location using a tree with log m rounds of comparisons for
m-minutia ﬁngerprints. Note that the computation cannot reveal if
a minutia in B already has a mate or not close enough to a minutia
in A, and thus for each minutia in A we have to treat all minutiae
in B in the same way.
For comparison, we also provide performance of secure two-
party computation compiler from [29] and Sharemind [10]. The
former is a general-purpose compiler for ANSI C for the two-party
setting and it is informative to compare performance of programs
produced using the compiler. In Table 2 we list runtimes for sim-
ilar programs when available as reported in [29]. The latter is a
framework that allows a program written in language called Se-
creC to be compiled into secure distributed implementation for 3
computational parties. The tool is constantly evolving and well op-
timized, while the language currently has a few limitations such as
no support for if-statements with a private condition4. We chose
Sharemind for its speed, as other general secure multi-party com-
putation tools and compilers such as FairplayMP and VIFF result
in slower performance. We run Sharemind experiments in the same
setups as our LAN and WAN experiments.
From Table 2, it is clear that despite using more computational
parties and highly interactive techniques, the performance of pro-
grams compiled using PICCO compares very favorably to those
4SecreC allows for comparisons and other basic predicates to be
evaluated on private values outside of if-statements. This has sim-
ilar expressiveness to using if-statements with arbitrary conditions
over private variables, but results in degradation of usability, as the
programmer has to expand and rewrite all if-statements by hand.
Figure 8: Performance of selected programs with a varying
number of computational parties on a LAN.
compiled using the two-party approach of [29]. In particular, the
largest difference we observe is by more than 3 orders of magni-
tude for some LAN experiments. Performance of the programs
executed through Sharemind is also slower than with PICCO, es-
pecially for simple programs on a LAN. In our Sharemind experi-
ments we were unable to match the performance reported in [11],
despite extensive use of the available (batch) optimization mecha-
nisms. Furthermore, we experience a large 4-fold reduction in exe-
cution time of arithmetic operations programs by replacing opera-
tions of the form a = a + a with operations of the form b = a + a,
where a and b are vectors. This could be in part due to excessive
logging (which we were unable to disable) and is not the expected
behavior. The execution of interactive multiplication operations is
more costly and execution of local addition operations should take
a small fraction of the overall time, regardless of how addition op-
erations are handled in the user program. We conclude that Share-
mind was optimized for massively-parallel computation with low
amortized cost per operation, but not general-purpose computation
where sequential execution is common. Furthermore, Sharemind is
likely to outperform PICCO when a large number of homogeneous
operations are to be run in parallel, but we expect our tool to result
in lower execution time for general-purpose functionalities.
To investigate the impact of varying the number of computa-
tional parties on the performance, we conducted additional exper-
iments. The programs that we chose are unoptimized 1000 arith-
metic operations, optimized 1000 arithmetic operations, and 32-
element mergesort, which provide insights into the performance
of plain multiplications, batch multiplications, and combination of
batch and multi-threaded implementation, respectively. To perform
multiplication, each computational party transmits n − 1 messages
and performs Lagrange interpolation that in the most general form
involves quadratic (in the number of parties) computation. On a
LAN, this computation contributes a substantial portion of the over-
all time and [25] reports that the growth in multiplication time can
be best described by function f (n) = 0.009n2 + 0.006n + 0.799.
We, however, observe that in the semi-honest setting all parties send
their data as prescribed and the set of available shares is known.
This means that Lagrange coefﬁcients used during interpolation
can be precomputed, resulting in linear computation time. Further-
more, we reconstruct only the free coefﬁcient of the polynomial
that encodes the secret as opposed to the entire polynomial. This
gives us that the work a computational party performs for a single
interactive operation is linear in n, but the total volume of commu-
nication placed on the network is quadratic in n. Our LAN results
(using a new set of machines) are given in Figure 8, where opti-
mized arithmetic operations’ time is scaled up by a factor of 20.
We can observe linear or slightly higher than linear growth in n.
 0 50 100 150 200 250 300 350 400 450 3 5 7 9 11Time (ms)Number of computational partiesarith ops (basic)arith ops (optimized)mergesort (optimized)8246. CONCLUSIONS
The goal of this is work is to enable secure execution of general-
purpose programs in not fully trusted environments. Toward this
goal, we introduce PICCO — a suite of programs for compiling a
user program written in an extension of C with variables that need
be protected marked as private, into its secure distributed imple-
mentation, and running it in a distributed setting. Our implementa-
tion uses techniques based on secret sharing with several optimiza-
tions to improve the runtime. This results in efﬁcient secure execu-
tion suitable for sizeable computations in a variety of settings.
Acknowledgments
We are grateful to Ethan Blanton for valuable suggestions on the
design of the compiler, Dan Bogdanov for the help with Sharemind
experiments, and anonymous reviewers for their valuable feedback.
This work was supported in part by grants CNS-1319090 and CNS-
1223699 from the National Science Foundation and FA9550-13-1-
0066 from the Air Force Ofﬁce of Scientiﬁc Research. Any opin-
ions, ﬁndings, and conclusions or recommendations expressed in
this publication are those of the authors and do not necessarily
reﬂect the views of the funding agencies. We also acknowledge
the NSF-sponsored Global Environment for Network Innovations
(GENI) test bed, which allowed us to run WAN experiments.
7. REFERENCES
[1] Bison – GNU parser generator.
http://www.gnu.org/software/bison.
[2] Boost C++ libraries. http://www.boost.org.
[3] ﬂex: The Fast Lexical Analyzer. http://ﬂex.sourceforge.net.
[4] GENI: Global environment for network innovations.
http://www.geni.net.
[5] GMP – The GNU Multiple Precision Arithmetic Library.
http://gmplib.org.
[6] OpenSSL: The open source toolkit for SSL/TLS.
http://www.openssl.org.
[7] M. Aliasgari, M. Blanton, Y. Zhang, and A. Steele. Secure
computation on ﬂoating point numbers. In NDSS, 2013.
[8] A. Ben-David, N. Nisan, and B. Pinkas. FairplayMP: A
system for secure multi-party computation. In CCS, 2008.
[9] M. Blanton. Empirical evaluation of secure two-party
computation models. Technical Report TR 2005-58,
CERIAS, Purdue University, 2005.
[10] D. Bogdanov, S. Laur, and J. Willemson. Sharemind: A
framework for fast privacy-preserving computations. In
ESORICS, pages 192–206, 2008.
[11] D. Bogdanov, M. Niitsoo, T. Toft, and J. Willemson.
High-performance secure multi-party computation for data
mining applications. IJIS, 11(6):403–418, 2012.
[12] J. Boyar and R. Peralta. A new combinational logic
minimization technique with applications to cryptology. In
Symposium on Experimental Algorithms, 2010.
[13] J. Boyar and R. Peralta. A small depth-16 circuit for the AES
S-box. In Information Security and Privacy Research, pages
287–298, 2012.
[14] M. Burkhart, M. Strasser, D. Many, and X. Dimitropoulos.
SEPIA: Privacy-preserving aggregation of multi-domain
network events and statistics. In USENIX Security
Symposium, pages 223–240, 2010.
[15] R. Canetti. Security and composition of multiparty
cryptographic protocols. Journal of Cryptology,
13(1):143–202, 2000.
[16] O. Catrina and S. de Hoogh. Improved primitives for secure
multiparty integer computation. In Security and
Cryptography for Networks (SCN), pages 182–199, 2010.
[17] O. Catrina and A. Saxena. Secure computation with
ﬁxed-point numbers. In FC, pages 35–50, 2010.
[18] R. Cramer, I. Damgård, and Y. Ishai. Share conversion,
pseudorandom secret-sharing and applications to secure
computation. In TCC, pages 342–362, 2005.
[19] I. Damgård, M. Geisler, and M. Krøigård. Asynchronous
multiparty computation: Theory and implementation. In
PKC, pages 160–179, 2009.
[20] I. Damgård and M. Keller. Secure multiparty AES. In FC,
pages 367–374, 2010.
[21] I. Damgård, M. Keller, E. Larraia, C. Miles, and N. Smart.
Implementing AES via an actively/covertly secure
dishonest-majority MPC protocol. IACR Cryptology ePrint
Archive Report 2012/262, 2012.
[22] I. Damgård and J. Nielsen. Scalable and unconditionally
secure multiparty computation. In CRYPTO, 2007.
[23] V. Dimakopoulos, E. Leontiadis, and G. Tzoumas. A
portable C compiler for OpenMP V.2.0. In European
Workshop on OpenMP (EWOMP), pages 5–11, 2003.
[24] M. Frigo, C. Leiserson, and K. Randall. The implementation
of the Cilk-5 multithreaded language. In PLDI, pages
212–223, 1998.
[25] M. Geisler. Cryptographic protocols: Theory and
implementation. PhD thesis, Aarhus University, 2010.
[26] R. Gennaro, M. Rabin, and T. Rabin. Simpliﬁed VSS and
fast-track multiparty computations with applications to
threshold cryptography. In PODC, pages 101–111, 1998.
[27] O. Goldreich. Towards a theory of software protection and
simulation by oblivious RAMs. In STOC, 1987.
[28] W. Henecka, S. Kogl, A.-R. Sadeghi, T. Schneider, and
I. Wehrenberg. TASTY: Tool for Automating Secure
Two-partY computations. In CCS, pages 451–462, 2010.
[29] A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith. Secure
two-party computations in ANSI C. In CCS, 2012.
[30] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster secure
two-party computation using garbled circuits. In USENIX
Security Symposium, 2011.
[31] R. Jagomägis. SecreC: A privacy-aware programming
language with applications in data mining. Master’s thesis,
University of Tartu, 2010.
[32] F. Kerschbaum. Automatically optimizing secure
computation. In CCS, pages 703–714, 2011.
[33] J. Launchbury, I. Diatchki, T. DuBuisson, and
A. Adams-Moran. Efﬁcient lookup-table protocol in secure
multiparty computation. In ICFP, pages 189–200, 2012.
[34] S. Laur, R. Talviste, and J. Willemson. From oblivious AES
to efﬁcient and secure database join in the multiparty setting.
In ACNS, pages 84–101, 2013.
[35] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay – a
secure two-party computation system. In USENIX Security
Symposium, pages 287–302, 2004.
[36] B. Pinkas, T. Schneider, N. Smart, and S. Williams. Secure
two-party computation is practical. In ASIACRYPT, 2009.
[37] A. Schroepfer, F. Kerschbaum, and G. Mueller. L1 – An
intermediate language for mixed-protocol secure
computation. In COMPSAC, pages 298–307, 2011.
[38] A. Shamir. How to share a secret. Communications of the
ACM, 22(11):612–613, 1979.
825