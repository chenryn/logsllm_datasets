Finally, we deﬁne the behavior and the interactions for
the trivial DPM AET, which periodically shuts down the
server even if this is busy:
ELEM_TYPE DPM_Type(void)
BEHAVIOR
DPM_Beh(void; void) =
 . DPM_Beh()
INPUT_INTERACTIONS
void
OUTPUT_INTERACTIONS
UNI send_shutdown
In the second section of the Æmilia speciﬁcation we de-
scribe the system topology by declaring the instances of the
previously deﬁned AETs:
ARCHI_TOPOLOGY
ARCHI_ELEM_INSTANCES
: Server_Type();
S
RCS : Radio_Channel_Type();
RSC : Radio_Channel_Type();
C
DPM : DPM_Type()
: Sync_Client_Type();
as well as the attachments between their interactions:
ARCHI_ATTACHMENTS
FROM C.send_rpc_packet
TO RCS.get_packet;
FROM RCS.deliver_packet
TO S.receive_rpc_packet;
FROM S.send_result_packet
TO RSC.get_packet;
FROM RSC.deliver_packet
TO C.receive_result_packet;
FROM DPM.send_shutdown
TO S.receive_shutdown
END
The topology is the same as shown in Fig. 2.a), up to the
busy and idle triggers.
Then we deﬁne the behavior and the interactions for the
3. Comparing the Functional Models
ideal radio channel AET:
ELEM_TYPE Radio_Channel_Type(void)
BEHAVIOR
Radio_Channel(void; void) =
 .  .
 . Radio_Channel()
INPUT_INTERACTIONS
UNI get_packet
OUTPUT_INTERACTIONS
UNI deliver_packet
Afterwards we have the deﬁnition of the behavior and
the interactions of the blocking client AET:
ELEM_TYPE Sync_Client_Type(void)
BEHAVIOR
Sync_Client(void; void) =
 .
 .
 . Sync_Client()
The ﬁrst model considered in the methodology of Fig. 1 de-
scribes the functional behavior of the system and is used
to verify that the DPM is transparent, i.e. that its introduc-
tion does not have any inﬂuence on the system functional
behavior as it is perceived by the client of the service pro-
vided by the system.
In order to assess the transparency of the DPM, we resort
to the noninterference analysis approach [8] based on equiv-
alence checking [7]. The general idea behind this approach
is to view a system execution as an information ﬂow and
to consider that a group of system users (high users), using
a certain set of commands, is noninterfering with another
group of system users (low users), if what the ﬁrst group
does with those commands has no effect on what the sec-
ond group of users can see. This approach has traditionally
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:20 UTC from IEEE Xplore.  Restrictions apply. 
been used for security purposes, as noninterference analy-
sis can reveal direct and indirect information ﬂows that vio-
late the access policies based on assigning different access
clearances to different user groups.
Within our methodology, the noninterference analysis is
used to check whether the high system components, i.e. the
DPM, interferes with the functional behavior of the system
as observed by the low system components, i.e. the client.
In our case studies, the actions of the DPM that modify the
state of the power-manageable device are the only high ac-
tions, whereas all the actions of the client are the only low
actions. Checking for noninterference amounts to verifying
whether – from the client standpoint – the functional model
of the system with the high actions being made unobserv-
able (i.e. with the DPM being hidden to the client) is weakly
bisimulation equivalent [11] to the functional model of the
system with the high actions being made impossible (i.e.
with the DPM being removed).
3.1. Application to rpc
The simpliﬁed version of rpc described in Sect. 2.3 fails the
noninterference check. More precisely, when submitting the
corresponding Æmilia speciﬁcation to the security analyzer
of TwoTowers, the outcome is negative and the following
modal logic formula is returned:
EXISTS_WEAK_TRANS(
LABEL(C.send_rpc_packet#
RCS.get_packet);
REACHED_STATE_SAT(
NOT(EXISTS_WEAK_TRANS(
LABEL(RSC.deliver_packet#
C.receive_result_packet);
REACHED_STATE_SAT(TRUE)
)
)
)
)
of
logic formula above means that
the func-
The modal
tional model of
the simpliﬁed version of rpc with
the high actions being hidden admits a computation
is returned to the client
path along which no result
RSC.deliver packet with
(synchronization
C.receive result packet) after that the client has
issued an rpc (synchronization of C.send rpc packet
with RCS.get packet), whereas this path does not ex-
ist in the functional model of the simpliﬁed version of rpc
with the high actions being prevented from occurring. Re-
called that the high actions are those performed by the
DPM, the reason why the modal logic formula above dis-
tinguishes the two functional models is that in the latter
model the DPM is not active, while in the former model the
DPM is active and can shut the server down while it is pro-
cessing an rpc. Since the client is blocking and does not use
any timeout mechanism after sending an rpc, it may hap-
pen that it will be forever waiting for a response that will
never arrive – only an rpc can wake the server up, but this
cannot be issued by the client as long as it does not re-
ceive the response to its previous rpc.
Based on the modal logic formula and the considerations
above, in order to make the DPM transparent to the client
we ﬁrst recognize that the client must implement a timeout
mechanism – which by the way allows the client to cope
with a more realistic radio channel that can lose packets –
at the cost of complicating the server and the client, as they
must now be able to discard old packets due to useless re-
transmissions. Second, we recognize that the DPM cannot
shut down the server while it is busy, which is achieved by
making the server inform the DPM about its state. As a con-
sequence, we modify the AETs in the Æmilia speciﬁcation
of Sect. 2.3 as follows:
ELEM_TYPE Server_Type(void)
BEHAVIOR
Idle_Server(void; void) =
choice {
 .  .
Busy_Server(),
 . Sleeping_Server()
};
Busy_Server(void; void) =
choice {
 .
Responding_Server(),
 .
 . Busy_Server()
};
Responding_Server(void; void) =
choice {
 .  .
Idle_Server(),
 .
 .
Responding_Server()
};
Sleeping_Server(void; void) =
 . Awaking_Server();
Awaking_Server(void; void) =
choice {
 . Busy_Server(),
 .
 . Awaking_Server()
}
INPUT_INTERACTIONS
UNI receive_rpc_packet; receive_shutdown
OUTPUT_INTERACTIONS
UNI send_result_packet;
notify_busy; notify_idle
ELEM_TYPE Radio_Channel_Type(void)
BEHAVIOR
Radio_Channel(void; void) =
 .  .
choice {
 .  .
Radio_Channel(),
 . Radio_Channel()
}
INPUT_INTERACTIONS
UNI get_packet
OUTPUT_INTERACTIONS
UNI deliver_packet
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:20 UTC from IEEE Xplore.  Restrictions apply. 
ELEM_TYPE Sync_Client_Type(void)
BEHAVIOR
Requesting_Client(void; void) =
choice {
 . Waiting_Client(),
 .
 .
Requesting_Client()
};
Waiting_Client(void; void) =
choice {
 .
Processing_Client(),
 . Resending_Client()
};
Processing_Client(void; void) =
choice {
 .
Requesting_Client(),
 .
 .
Processing_Client()
};
Resending_Client(void; void) =
choice {
 . Waiting_Client(),
 .
Processing_Client()
}
INPUT_INTERACTIONS
UNI receive_result_packet
OUTPUT_INTERACTIONS
UNI send_rpc_packet
ELEM_TYPE DPM_Type(void)
BEHAVIOR
Enabled_DPM(void; void) =
choice
{
 . Disabled_DPM(),
 . Disabled_DPM()
};
Disabled_DPM(void; void) =
 . Enabled_DPM()
INPUT_INTERACTIONS
UNI receive_busy_notice; receive_idle_notice
OUTPUT_INTERACTIONS
UNI send_shutdown
and we introduce the following additional attachments:
FROM S.notify_busy TO DPM.receive_busy_notice;
FROM S.notify_idle TO DPM.receive_idle_notice;
thus faithfully reproducing the topology shown in Fig. 2.a).
We have veriﬁed through the security analyzer of
TwoTowers that the revised Æmilia speciﬁcation of the rpc
case study meets noninterference, i.e. the DPM does not in-
terfere with the functional behavior of the system as per-
ceived by the client.
4. Comparing the Markovian Models
The second model considered in the methodology of Fig. 1
is a Markovian model obtained from the functional one by
attaching exponentially distributed durations to its actions.
In addition to that, further exponentially timed actions re-
sulting in self-loops may be introduced in order to monitor
the residence in certain states.
The Markovian model is thus consistent by construction
with the functional one, in the sense that their underlying
state spaces are isomorphic up to the possible additional
self-loops and the action rates (which occur only in the la-
bels of the transitions underlying the Markovian model). As
a consequence, whenever the functional model meets non-
interferce, then so does the Markovian model.
In the speciﬁc case of Æmilia, it is also possible to
express inﬁnite rates – equipped with priority levels and
weights – which are useful to model activities whose tim-
ing is negligible. Since the resulting immediate actions take
precedence over exponentially timed actions, the use of
immediate rates may alter the state space of the Marko-
vian model with respect to the state space of the functional
model. Therefore, whenever immediate actions come into
play, the noninterference analysis must be repeated on the
Markovian model.
The Markovian models with and without DPM can be
solved through standard numerical techniques. The aver-
age performance measures of interest, which are related to
the power consumption and the overall system efﬁciency,
can easily be expressed by means of reward structures. In
the speciﬁc case of Æmilia, which is based on stochastic
process algebra, the reward-based measures are expressed
by means of an auxiliary speciﬁcation language inspired
by [3]. By combining the solution of the Markovian mod-
els with and without DPM together with the reward struc-
tures deﬁning the performance measures of interest, we can
ﬁnally assess the impact of the introduction of the DPM on
the system efﬁciency, aiming at ﬁnding a tradeoff between
the power consumption and the quality of the delivered ser-
vice.
Due to lack of space,
in the following we leave
out
the Æmilia speciﬁcations of the Markovian mod-
els of the two case studies. Such speciﬁcations can be found
at www.sti.uniurb.it/bernardo/twotowers/
4.1. Application to rpc
3.2. Application to streaming
Due to lack of space, we do not show the Æmilia speciﬁca-
tion of the functional model for the streaming case study,
which satisﬁes noninteference and can be retrieved from
www.sti.uniurb.it/bernardo/twotowers/
In order to evaluate the performance measure of interest for
rpc, ﬁrst of all we have to provide some values for the pa-
rameters of its Markovian models. Here we assume that the
average server service time is 0.2 msec, the average server
awaking time is 3 msec, the average packet propagation
time is 0.8 msec, the packet loss probability is 0.02, the av-
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:20 UTC from IEEE Xplore.  Restrictions apply. 
t
s
e
u
q
e
r
/
y
g
r
e
n
e
0.03
0.02
0.01
e
m
i
t
g
n
i
t
i
a
w
t
u
p
h
g
u
o
r
h
t
0.004
0.002
0.008
0.007
0.006
0
5
Markov model
General model
DPM
NO-DPM
0.03
0.02
0.01
t
s
e
u
q
e
r
/
y
g
r
e
n
e
e
m
i
t
g
n
i
t
i
a
w
0.004
0.002
0.008
0.007
t
u
p
h
g
u
o
r
h
t
10
15
20
shutdown timeout
25
0
5
10
15
20
shutdown timeout
25
0.006
30
e
m
a
r
f
r
e
p
y
g
r
e
n
e
200
150
100
50
0
0.6
s
s
i
m
0.4
0.2
0
0
NO-DPM
DPM
200
400
600
800
0
awake period [ms]
0.200
s
s
o
l
0.100
0.000
0.8
0.6
0.4
y
t
i
l
a
u
q
0.2
0.0
800
200