**作者：[启明星辰ADLab](https://mp.weixin.qq.com/s/NYwYDX8ajqePgbZGnXWwrw
"启明星辰ADLab")**
### 1\. 研究背景
Chakra是一个由微软为Microsoft
Edge浏览器开发的JavaScript引擎。它在一个独立的CPU核心上即时编译脚本，与浏览器并行。本文主要对Chakra引擎中JIT编译优化过程中的数组类型混淆漏洞进行分析。
JavaScript引擎的性能对整个浏览器的影响至关重要，
JIT编译优化是为了提高Chakra引擎性能。当在循环语句中反复执行同一段脚本代码时，如果解释器反复执行相关的字节码，效率会很低。JIT可以将源代码直接生成机器指令，在下一次执行时直接执行机器指令。在Chakra中只有当目标函数或者循环语句被频繁调用时才会启用JIT编译，JIT编译后生成了相应的机器指令，下一次调用到这个语句或是函数时就会直接执行机器指令。
一旦JIT生成完成，程序就可以直接调用JIT生成的机器指令。因为JIT是直接编译为机器指令的，所以需要预先假定操作目标的类型。如果不满足JIT的假设的话，此JIT代码就不能执行，否则就会发生类型混淆的错误。因此JIT代码中设计了bailout功能，一旦发现不满足假设就进行bailout，bailout会放弃执行JIT代码转回使用解释器继续执行字节码。
### 2\. 数组类型混淆思路
Chakra数组可以分为三类，分别是NativeIntArray、NativeFloatArray和VarArray。NativeIntArray和NativeFloatArray数组转化成VarArray数组过程中会将数组中的原数据通过异或0xfffc000000000000转化为VarArray中的数据。也就是说VarArray会通过数组中元素的高位来判断数组中的元素是数据还是对象。
NativeIntArray和NativeFloatArray之间混淆一般不能带来安全问题，但是当这二者和VarArray混淆之后就会出现数据和对象无法区分的问题。
先看一段简单代码。
这段代码在JIT优化后的表现形式是这样的。
如果在xxx操作过程中将NativeArray的类型改变成了VarArray，并且JIT的优化过程并没有检测到这种变化的话，2.3023e-320就会被当作float数据存放进入VarArray的元素中，由于这个过程中数组的变化是始料未及的，所以2.3023e-320并没有通过与0xfffc000000000000异或而变成一个可以被VarArray识别的float，所以VarArray对象在读取该元素时会将其当成一个对象来处理。
为了实现数组的类型混淆，xxx操作主流的思路有两种，一种是通过没有检测的回调来修改数组的类型，第二种是通过合理的函数来修改数组的类型。下面通过一些实例进行简要分析。
#### 2.1. 思路一：通过回调修改数组类型
先来看一个简单的例子，通过回调修改数组类型。
func的JIT主要片段如下：
根据上述代码，可以看到call rax之后并没有验证数组a是否合法就直接进行了赋值。那么如何改变数组a的类型呢？我们来看最后一次对func的调用。
漏洞脚本将一个对象直接赋值给了参数c，并且在这个对象上挂了一个valueOf回调，c要赋值给typed数组b，而b中的元素只能是Uint32类型，所以JIT会对参数c进行一个转换（用到ToInt32），这会触发c的valueOf回调，在回调函数中通过a[0]={}给数组a赋值，这会将a由NativeFloatArray变成VarArray，而后续代码因为没有检查a数组改变所以继续将其当作NativeFloatArray赋值造成了类型混淆。
补丁后代码如下。
一般来说，Chakra引擎在对JIT中的回调进行优化时会考虑一个叫做ImplicitCallFlags的标志位，通过这个标志位，就可以检测用户函数是否可能被调用，如果是的话就会启动bailout或进行相关检测。但是这种机制存在一些问题，比如ImplicitCallFlags标志位到底在什么位置会被置位，它是否能保护所有存在回调函数的位置？
一个典型的例子：CVE-2017-11802
这个漏洞比较简单，存在于RegexHelper::StringReplace函数中，regexp的replace方法，可以定义一个回调函数，但是在其实现中并没有对回调函数进行保护，也就是说可以直接在regexp的replace方法中修改数组类型而不被JIT检测到。
该漏洞的补丁也比较简单，通过对两处调用回调的位置添加ExecuteImplicitCall验证，就可以修补该漏洞。这个补丁同时修补了一处位于JavascriptArray::ArraySpeciesCreate中的由于创建新对象而导致的回调。
![
](https://images.seebug.org/content/images/2018/12/acd6d3b7-9e92-45c4-bb32-0a3d8b47de63.png-w331s)
这种机制在实现和优化过程中有没有瑕疵呢？下面来看另一个例子[CVE-2018-0840](https://bugs.chromium.org/p/project-zero/issues/list?q=label:CVE-2018-0840)。
这是一个直接对ExecuteImplicitCall函数进行对抗的漏洞，其问题本身在于ExecuteImplicitCall函数的实现，其代码片段如下。
函数首先会执行implicitCall然后才会更新ImplicitCallFlags，单纯从函数本身来考虑好像没什么问题，但是这里面忽略了一个可能就是回调在执行过程中如果出现了一个异常该怎么处理，POC中的typeof实现位于JavascriptOperators::TypeofElem函数中，和漏洞有关的代码如下。
回调会通过ExecuteImplicitCall函数进行调用，但是回调函数会触发一个异常，该异常会被TypeofElem捕获，也就是说ExecuteImplicitCall函数中更新ImplicitCallFlags的操作被跳过了，由于标志位没有被更新，所以优化过程中的相应排错机制也就没有被生成，最终导致了漏洞的产生。
另外一个问题是CVE-2018-8556，通过补丁信息可以知道漏洞存在于GlobOptBailOut.cpp的MayNeedBailOnImplicitCall函数中，从名字可以推测，这个函数主要负责判断JIT优化过程中是否对ImplicitCall生成bailout代码。
在该函数对对象的length属性进行获取的操作中，判断返回值的逻辑出现了问题。
从逻辑上看，string和满足IsAnyArray并且不等于ObjectWithArray的对象都是可以通过验证的，也就是说typedarray也是满足条件的。
如果要给对象获取length的操作加回调或者过滤操作，对象的length属性的configurable特性必须为true，string和array的length都符合这个假定，但是typedarray却是个例外，所以可以通过给typedarray的length属性加回调的操作，去执行用户定义的代码来触发类型混淆漏洞。
#### 2.2. 思路二：通过合理的函数调用修改数组类型
接下来看第二种思路，通过合理函数调用来触发数组类型改变。在一些函数处理中，由于功能原因会调用ToVarArray函数对数组类型进行改变。
下面举例说明。
opt函数的JIT优化代码如下：
可以看到，在call
rax之后并没有进行数组类型的检测就直接赋值了，那么这个call中到底发生了什么呢？这个call调用了JavascriptOperators::OP_InitProto函数来初始化proto，在最后一次opt调用时，将array当作proto给了属性链，在对属性链赋值时，如果赋值参数是一个Native数组的话会将其转换为VarArray（调用了ToVarArray函数）。其调用函数栈如下。