Code Changes. Apart from the application indepen-
dent code, we required no changes to the code. The
parent and child shims make the redesign seamless. We
Separation. We
3Due to a bug in Chrome, the current Awesome Screenshot exten-
sion uses a NPAPI binary to save big (> 2MB) images. We used the
HTML5 version (which doesn’t allow saving large ﬁles) for the pur-
poses of this work. This is just a temporary limitation.
10
manually tested the application functionality thoroughly
and did not observe any incompatibilities.
Unbundling.
In the original version of Awesome
Screenshot, the image editor (editor.html) accepts the
image from background.html and allows the user to
edit it, but runs with the full privileges of the extension—
an example of bundling. Similarly, the popup.html only
needs to forward the user’s choice to background.html
but runs with all of the extension’s privileges.
In our privilege-separated implementation of Awe-
some Screenshot, the editor code, stored in editor.txt
now, runs within a temporary origin. The policy only
gives it access to the sendRequest API to send the exit
and ready messages as well as receive the image data
message from the background page.
TCB Reduction. The image editor in the original
Awesome Screenshot extension uses UI and image ma-
nipulation libraries (more than 500KB of complex code),
which run within the same origin as the extension. As
a result, these libraries run with the ambient privileges
to take screenshots of any page, log the user’s browsing
history, and access the user’s data on any website. While
some functions in the extension do need these privileges,
the complete codebase does not need to run with these
privileges.
In our privilege-separated implementation of Awe-
some Screenshot, the amount of code running with full
privileges (TCB) decreased by a factor of 58. We found
the UI and image manipulation libraries, speciﬁcally
jQuery UI, used dynamic constructs like innerHTML and
eval. Our design moves these potentially vulnerable
constructs to an unprivileged child.
The code in the child can still request privileged func-
tion calls via the interface provided by the parent. How-
ever, this interface is thin, well deﬁned and easily au-
ditable.
In contrast, in the non-privilege separated de-
sign, the UI and image libraries run with ambient privi-
leges. In contrast, in the original extension all the code
needs to be audited.
Example Policy.
In addition to unbundling the im-
age editor from the screenshot component, the parent
can enforce stronger, temporal policies on the appli-
cation.
In particular, the parent can require that the
captureVisibleTab function is only called once after
the user clicks the capture button. Any subsequent calls
have to be preceded by another button click. Such tem-
poral policies are impossible to express and enforce in
current permission-based systems.
5.2 SourceKit Text Editor
The SourceKit text editor is an HTML5 text editor for
a user’s documents stored on the Dropbox cloud ser-
vice [36].
It uses open source components like the
Ajax.org cloud editor [37] and Dojo toolkit [38], in con-
junction with the Dropbox REST APIs [36].
SourceKit is a powerful text editor. It includes a ﬁle-
browser pane and can open multiple ﬁles at the same
time. The text editor component supports themes and
syntax highlighting. The application consists of 15MB
of JavaScript code, all of which runs with full privileges.
Privilege Separation.
In our least privilege design, the
whole application runs in a single child. Redesigning
SourceKit to move code to an unprivileged temporary
origin was seamless because of the library shims (Sec-
tion 4.1). One key change was replacing the included
Dojo toolkit with its asynchronous version. The included
Dojo toolkit uses synchronous XMLHttpRequest calls,
which the asynchronous postMessage cannot proxy.
The asynchronous version of Dojo is freely available on
the Dojo website. We do not include this change in the
number of lines modiﬁed in Table 1.
Unbundling. Functionally, SourceKit
is a single
Chrome application, and no bundling has occurred in its
design. Popular Web sites (like GitHub [39]), use the
text editor module as an online text editor [37]. In such
cases, the text editor runs bundled with the main applica-
tion, inheriting the application’s privileges and increas-
ing its attack surface. While we focus only on SourceKit
for this case study, our redesign directly applies to these
online text editors.
TCB Reduction.
In our privilege separated SourceKit,
the amount of code running with full privileges reduced
from 15MB to 5KB. A large part of this reduction is
due to moving the Dojo Toolkit, the syntax highlight-
ing code and other UI libraries to an unprivileged prin-
cipal. Again, we found the included libraries, speciﬁ-
cally the Dojo Toolkit, relying on dangerous, dynamic
constructs like eval, string arguments to setInterval,
and innerHTML. In our redesign, this code executes un-
privileged.
Code Change.
In addition to the switch to asyn-
chronous APIs, we also had to modify one internal
function in SourceKit to use asynchronous APIs.
In
particular, SourceKit relied on synchronous requests to
load ﬁles from the dropbox.com server. We modi-
ﬁed SourceKit to use an asynchronous mechanism in-
stead. The change was minor; only 13 lines of code were
changed.
Example Policy.
In the original application, all code
runs with the tabs permission, which allows access to
the user’s browsing history, and permission to access
dropbox.com. In our privilege-separated design, the pol-
icy only allows the child access to the tabs.open and
tabs.close Chrome APIs for accessing dropbox.com.
Similarly, it only forwards tab events for dropbox.com
URIs. Thus, after the redesign, the child has access to the
user’s browsing history only for dropbox.com, and not
for all websites. Implementing this policy requires only
two lines of code—an if condition that forwards events
only for dropbox.com domains sufﬁces.
SourceKit accesses Dropbox using the Dropbox
OAuth APIs [36]. At ﬁrst run, SourceKit opens Drop-
box in a new tab, where the user can grant SourceKit the
requisite OAuth access token [40]. The parent can only
allow access to the tabs privileges at ﬁrst run, and disable
it once the child receives the OAuth token. Such tempo-
ral policies cannot be expressed by install-time permis-
sions implemented in existing platforms.
We can also enforce stronger policies to provide a
form of data separation [41]. By default, the Dropbox
JS API [42] stores the OAuth access token in localStor-
age, accessible by all the code in the application.
In-
stead, the policy code can store the OAuth token in the
parent and append it to all dropbox.com requests. This
mitigates data exﬁltration attacks where the attacker can
steal the OAuth token to bypass the parent’s policy.4
Such application-speciﬁc data-separation policies cannot
be expressed in present permission systems.
5.3 SQL Buddy
SQL Buddy is an open source tool to administer the
MySQL database using a Web browser. Written in PHP,
SQL Buddy is functionally similar to phpMyAdmin and
supports creating, modifying, or deleting databases, ta-
bles, ﬁelds, or rows; SQL queries; and user management.
SQL Buddy uses the MooTools JS library to create an
AJAX front-end for MySQL administration. It uses the
MySQL user table for authentication and logged-in users
maintain authentication via PHP session cookies.
Privilege Separation. We modiﬁed SQL Buddy to ex-
ecute all its code in an unprivileged child. To en-
sure that no code is interpreted by the browser, we re-
quired all PHP ﬁles to return a Content-Type header of
text/plain, as discussed in Section 3.3. Only two
new ﬁles: buddy.html and login.html execute in the
browser; these are initialized by the bootstrap code.
Unbundling. A typical SQL Buddy installation runs at
www.example.net/sqlbuddy, and helps ease database
management for the application at www.example.net.
Classic operating system mechanisms can isolate SQL
Buddy and the main application on the server side. But
SQL Buddy runs with the full privileges of the applica-
tion on the client-side. In particular, an XSS vulnerabil-
ity in SQL Buddy is equivalent to an XSS vulnerability
on the main application: it is not isolated from the ap-
plication at the client-side. SQL Buddy inherits all the
4For example, to prevent malware, the parent can require that all
ﬁles accessed using SourceKit have non-binary ﬁle extensions.
11
privileges of the application, including special client-side
privileges such as access to camera, geolocation, and am-
bient privileges granted to the web origin such as the abil-
ity to do cross-origin XMLHttpRequests [43].
is
available
In our privilege-separated redesign, a restrictive
policy on the child mitigates SQL Buddy bundling.
The parent allows the child XMLHttpRequest ac-
to only /sqlbuddy/.php URIs.
cess
No other privilege
to SQL Buddy
code, including document.cookie, localStorage, or
XMLHttpRequest to the main application’s pages. This
policy isolates SQL Buddy from any other application
executing on the same domain, a hitherto unavailable op-
tion.
Code Change. The key change we made to the SQL
Buddy client side code was to convert the login script at
the server. The original SQL Buddy system returned a
new login page on a failed login. Instead, we changed it
to only return an error code over XMLHttpRequest. The
client-side code utilized this response to show the user
the new login page, thereby preserving the application
behavior. This change required modiﬁcation of only 11
lines of code.
TCB Reduction. SQL Buddy utilizes the MooTools
JavaScript library, which runs with the full privileges
of the application site (e.g., www.example.net). Over
100KB of JavaScript code runs with full privileges of
the www.example.net origin. This code uses danger-
ous, dynamic constructs such as innerHTML and eval.
In our design, the total amount of code running in the
www.example.net origin is 2.5KB, with the JavaScript
code utilizing dynamic constructs running in an unprivi-
leged temporary origin
Example Policy. Privilege separation reduces the am-
bient authority from these libraries. For example, the
session cookie for www.example.net, is never sent to
the child: all HTTP trafﬁc requiring the cookie needs
to go through the parent. Note that the cookie for
the www.example.net principal includes both, the SQL
Buddy session cookie as well as the cookie for the
main www.example.net application.
In case of suc-
cessful code injection, the attacker cannot exﬁltrate this
cookie. Furthermore, the policy strictly limits privileged
API access to those calls required by SQL Buddy. The
SQL Buddy code does not have ambient authority to
make privileged calls in the www.example.net princi-
pal. Again, implementing this policy requires two lines
of JavaScript code in our architecture.
5.4 Top 50 Google Chrome extensions
Finally, we measure the opportunity available to our
technique by quantifying the extent of TCB inﬂation and
bundling in Chrome extensions. To perform this analy-
12
sis, we developed a syntactic static analysis engine for
JavaScript using an existing JavaScript engine called Py-
narcissus [44] and performed a manual review for addi-
tional conﬁdence. We report our results on 46 out of the
top 50 extensions we study.5 In our analysis, we (conser-
vatively) identify all calls to privileged APIs (i.e., calls
to the chrome object) and list them in Figure 1. We be-
lieve that our analysis is overly conservative, being syn-
tactic, so these numbers represent only an undercount of
the over-privileging in these applications.6
TCB Reduction. We show the distribution of the num-
ber of functions requiring any privileges as a percentage
of the total number of functions. TCB inﬂation is per-
vasive in the extensions studied. In half the extensions,
less than 5% of the total functions require any ambient
privileges. In the current architecture the remaining 95%
run with full privileges, inﬂating the TCB.
Bundling. We manually analyzed the 20 most popular
Google Chrome extensions, and found 19 of them exhib-
ited bundling. The most common form of bundling oc-
curred when the options page or popup window of an ex-
tension runs with full privileges, in spite of not requiring
any privileges at all. While the Google Chrome archi-
tecture does enable privilege separation between content
scripts and extension code, running all code in an exten-
sion with the same privileges is unnecessary.
Another form of over-privileging occurs due to the
bundling of privileges in Chrome’s permission system.
Google Chrome’s extension system bundles multiple
privileges into one coarse-grained install-time permis-
sion. For example, the tabs permission in Chrome ex-
tension API, required by 42 of the 46 extensions ana-
lyzed, bundles together a number of related, powerful
privileges. This install-time permission includes the abil-
ity to listen to eight events related to tabs and windows,
access users’ browsing history, and call 20 other miscel-
laneous functions. Figure 5 measures the percentage of
the tabs API actually used by extensions as a percent-
age of the total API granted by tabs for the 42 exten-
sions analyzed. As can be seen, no extension requires
the full privileges granted by the tabs permission, with
one extension requiring 44.83% of the permitted API be-
ing the highest. More than half of the extensions require
only 6.9% of the API available, which indicates over-
privileging. In our design, the policy acts on ﬁne-grained
function calls and replaces coarse-grained permissions.
6 Performance Benchmarks
Our approach has two possible overheads: run-time over-
head caused by the parent’s mediation on privileged APIs
5Due to limitations of Pynarcissus, it was unable to completely
parse code in 4 out of the top 50 extensions.
6More precise analysis can be used in the future.
tension. For example, Awesome Screenshot could be
broken up into two extensions: a screenshot extension
and an image editor extension. In addition to requiring
two install decisions from the user, each additional ex-
tension runs in its own process on the Chrome platform.
We measured the memory consumption of creating two
extensions over a single extension and found an increase
in memory consumption of 20MB. This demonstrates
that our approach has no memory overhead as opposed
to the 20MB overhead of creating a new extension.
7 Related Work
The concept of privilege separation was ﬁrst formalized
by Saltzer and Schroeder [13]. Several have used priv-
ilege separation for increased security. We discuss the
most closely related works in the space.
Privilege Separation in Commodity OS Platforms.
Notable examples of user-level applications utilizing
privilege separation include QMail [18], OpenSSH [17]
and Google Chrome [19]. Brumley and Song investi-
gated automatic privilege separation of programmer an-
notated C programs and implemented data separation as
well [41]. More recently, architectures like Wedge [45]
identiﬁed subtleties in privilege separating binary appli-
cations and enforcing a default-deny model. Our work
shows how to achieve privilege separation in emerging
HTML5 applications, which are fuelling a convergence
between commodity OS applications and web applica-
tions, without requiring any changes to the browser plat-
form.
Re-architecting Browser Platforms. Several previ-
ous works on compartmentalizing web applications have
suggested re-structuring the browser or the underly-
ing execution platform altogether. Some examples in-
clude the Google Chrome extension platform [23], Es-
cudo [12], MashupOS [46], Gazelle [47], OP [48], IPC
Inspection [49], and CLAMP [50]. Our work advo-
cates that we can achieve strong privilege separation us-
ing abstractions provided by modern browsers. This ob-
viates the need for further changes to underlying plat-
forms. We point out that temporary origins is similar
to MashupOS’s “null-principal SERVICEINSTANCE” pro-