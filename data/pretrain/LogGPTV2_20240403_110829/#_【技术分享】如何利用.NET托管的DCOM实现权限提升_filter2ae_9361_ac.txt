比较器对象在通用.NET集合类中被大量使用，许多这些集合类也有自定义反序列化代码。在这种情况下，我们可以滥用[SortedSet
](https://msdn.microsoft.com/en-us/library/dd412070\(v=vs.110\).aspx)类，反序列化使用内部比较器对象重建其集合以确定排序顺序。传递给比较器的值是集合中的条目，这完全在我们的控制之下。我们来写一些测试代码来检查其是否和我们预期的一样有效：
有关这个代码唯一奇怪的是TypeConfuseDelegate。这是一个长期存在的问题，.NET代理并不总是强制执行其类型签名，特别是返回值。在这种情况下，我们创建一个两个条目的多播代理（按顺序运行多个单个代理的委托），将一个委托设置为返回一个int的String
::
Compare，将另一个设置为返回Process类实例的Process::Start。即使在反序列化和调用两种单独的方法时这也有效。然后其将返回创建的作为整数的进程对象，这意味着其会将指针返回到进程对象的实例。所以我们最终得到如下链条：
虽然这是一个非常简单的链，但它有一些问题，因此对于我们的用途其不太理想：
1\. Comparer  :: Create方法和相应的类仅在.NET 4.5中引入，涵盖Windows 8及更高版本，但不涵盖Windows 7。
2\. 漏洞利用部分依赖于代理的返回值的类型混淆。虽然其只是将Process对象转换为一个整数，但这有点不太理想，可能会有意想不到的副作用。
3\. 启动一个流程略显嘈杂，从内存加载我们的代码更好。
所以我们需要找到更好的东西。我们需要一些至少在.NET 3.5上有效的东西，这是Windows 7上Windows
Update会自动更新到的版本。此外，其不应该依赖于未定义的行为或从DCOM通道外部加载我们的代码，例如通过HTTP连接。这对我似乎是个挑战。
**改善链条**
在查看可序列化的其他一些类时，我在[System.Workflow.ComponentModel.Serialization](https://msdn.microsoft.com/en-us/library/system.workflow.componentmodel.serialization\(v=vs.110\).aspx)命名空间中注意到了一些。该命名空间包含属于[Windows
Workflow Foundation](https://msdn.microsoft.com/en-us/library/jj684582.aspx)的一部分的类，其是用于构建执行管道以执行一系列任务的一组库。这一点有点意思，事实证明，我之前利用过核心功能——作为[Windows
Powershell中代码完整性](http://www.exploit-monday.com/2013/07/WinRT-ARM-Shellcode.html?showComment=1376669197806#c4072135924776553338)的一个绕过。
这使我找到了[ObjectSerializedRef](https://github.com/Microsoft/referencesource/blob/4fe4349175f4c5091d972a7e56ea12012f1e7170/System.Workflow.ComponentModel/AuthoringOM/Serializer/ActivitySurrogateSelector.cs#L135)类。这看起来很像一个将反序列化任何对象类型的类。而不仅仅是序列化的。如果是这样的话，那么这是一个用于建立功能更强大的反序列化链的非常强大的原语。
查看实现后可知，该类被用作通过ActivitiySurrogateSelector类暴露的序列化替代。这是.NET序列化API的一个特性，您可以在序列化过程中指定“代理选择器”，其将用代理类替换对象。当流反序列化时，此代理类包含足够的信息来重建原始对象。一个用例是处理非可序列化类的序列化，但是ObjectSerializedRef超出了特定的用例，并允许您反序列化任何内容。按顺序进行的测试：
ObjectSurrogate类似乎没任何问题。这个类完全毁灭了确保不可信的BinaryFormatter流的任何希望，其可以从.NET
3.0获得。任何没有标记为可序列化的类现在都是目标。在反序列化过程中调用一个任意委托很简单，因为开发人员不会做任何事情来防范这种攻击方式。
现在选择一个目标来建立我们的反序列化链。我本可以选择进一步探讨Workflow类，但是API是可怕的（实际上在.NET
4中，微软用一个新的、稍微更好一些的API代替了旧的）。相反，我会选择一个非常易于使用的目标，语言集成查询（LINQ）。
LINQ作为核心语言特性在.NET
3.5中引入。一种类似于SQL的新语法引入了C＃和VB编译器，以跨可枚举对象执行查询，比如列表或字典。基于长度过滤名称列表并返回大写列表的语法示例如下：
您也可以不将LINQ视作查询语法，而是视作在.NET中执行列表推导的一种方法。将“select”视为等同于“map”，将“where”
视为等同于“filter”可能更有意义。查询语法下是在System.Linq.Enumerable类中实现的一系列方法。您可以使用正常的C＃语法而不是查询语言编写，如果这样做，则前面的例子变成如下所示：
方法（如Where）需要两个参数、一个列表对象（这在上面的例子中是隐藏的）及一个委托来调用枚举列表中的每个条目。委托通常由应用程序提供，但是没有什么可以阻止您使用系统方法替换委托。要记住的重要事情是在枚举列表之前不会调用委托。这意味着我们可以使用LINQ方法构建一个枚举列表，使用ObjectSurrogate进行序列化（LINQ类本身不是可序列化的），然后，如果我们能强制反序列化列表被枚举，其将执行任意代码。
使用LINQ作为原语，我们可以创建一个列表，当枚举时，该列表按以下顺序将字节数组映射到该字节数组中的一个类型的实例：
唯一棘手的部分是第2步，我们想提取一个特定的类型，但我们唯一真正的选择是使用Enumerable.Join方法，这需要投机取巧才能使其有效。一个更好的选择是使用Enumerable.Zip，但这只在.NET
4中引入。所以，我们将获取加载的程序集中的所有类型，并全部创建，如果我们只有一个类型，那么这不会有什么区别。以C#实现是怎样的？
C＃实现中唯一不明显的部分是Assembly ::
GetTypes的委托。我们需要的是一个接受一个Assembly对象并返回一个Type对象的列表的委托。然而，由于GetTypes是一个实例方法，默认是捕获Assembly类并将其存储在委托对象内，这将导致一个不接收参数并返回一个Type列表的委托。我们可以通过使用反射API为实例成员创建一个开放委托来解决这个问题。一个开放的委托不存储对象实例，而是将其作为额外的Assembly参数公开，这正是我们想要的。
使用我们的枚举列表，我们可以让程序集加载及让我们自己的代码执行，但是我们如何枚举列表启动链？为此，我尝试找到一个当调用ToString（一个很常见的方法）时会枚举列表的类。这在Java中很简单，几乎所有的集合类都有这个确切的行为。可悲的是，似乎.NET在这方面与Java不同。所以我修改了我的分析工具，以尝试寻找可以帮我们达到目的的小工具。长话短说，我通过三个单独的类发现了一个从ToString到IEnumerable的链。该链如下所示：
我们完成了吗？还没有，还差一步，我们需要在反序列化期间调用任意对象上的ToString。当然，如果我不是已经有一个方法来完成，我不会选择ToString。在这最后一个案例中，我会回到滥用Hashtable。在Hashtable类的反序列化期间，其将重建其密钥集，我们对此已有了解，因为这是我利用本地EoP的序列化的方法。如果两个密钥相同，则反序列化将会失败，Hashtable会抛出异常，导致运行以下代码：
该密钥被传递到值数组中的GetResourceString，以及对资源字符串的引用。资源字符串以及传递到String.Format的密钥被查找。生成的资源字符串具有格式化代码，因此当String.Format遇到非字符串值时，其调用对象上的ToString将其格式化。这导致在反序列化期间调用ToString，从而会踢掉事件链，从而引发我们从内存中加载任意.NET组件并在WMI客户端的上下文中执行代码。
您可以查看我添加到[问题跟踪器](https://bugs.chromium.org/p/project-zero/issues/detail?id=1081#c5)的最新PoC中的最终实现。
**结论**
微软通过确保System.Management类从不直接为WMI对象创建RCW修复了RCE（远程代码执行）问题。但是，此修复程序不会影响.NET中任何其他DCOM的使用，因此特权.NET
DCOM服务器仍然存在漏洞，其他远程DCOM应用程序也可能受到攻击。
此外，这应该是一个教训，切勿使用.NET
BinaryFormatter类反序列化不受信任的数据。无论如何这样做也是危险的，但开发人员似乎放弃了制作安全的可序列化类的任何希望。ObjectSurrogate的存在实际上意味着，运行时中的每个类都是可序列化的，无论原始开发人员希望与否。
最后一个想法，您应该始终对中间件的安全性实施持怀疑态度，尤其是当您不能检查其所作所为时。IManagedObject的问题是与生俱来的，难以移除，所以正确修复很难。