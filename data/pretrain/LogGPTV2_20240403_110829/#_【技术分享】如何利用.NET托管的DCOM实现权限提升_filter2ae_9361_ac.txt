### 比较器对象与.NET集合类中的反序列化

在.NET通用集合类中，比较器对象被广泛使用，并且许多这些集合类还包含自定义的反序列化代码。在这种情况下，我们可以利用`SortedSet`类，通过其内部比较器对象重建集合以确定排序顺序。传递给比较器的值完全由我们控制。为了验证这一点，我们可以编写一些测试代码来检查其有效性。

#### 问题和挑战

1. **TypeConfuseDelegate**：这是一个长期存在的问题，.NET代理并不总是强制执行其类型签名，特别是在返回值方面。我们可以通过创建一个多播代理（按顺序运行多个单个代理）来利用这一点。例如，一个委托返回`int`类型的`String::Compare`结果，另一个委托返回`Process`类实例的`Process::Start`结果。即使在反序列化和调用这两种方法时，这仍然有效。最终，它将返回一个整数形式的进程对象指针。

2. **局限性**：
   - `Comparer::Create`方法及其相关类仅在.NET 4.5中引入，这意味着它不适用于Windows 7。
   - 利用代理返回值的类型混淆可能会导致意外副作用。
   - 启动进程的方法略显嘈杂，从内存加载代码更为理想。

我们需要找到一种更好的方法，至少在.NET 3.5上有效，并且不依赖于未定义的行为或外部加载代码。

### 改善反序列化链

在探索其他可序列化的类时，我发现了一些有趣的类，位于`System.Workflow.ComponentModel.Serialization`命名空间中。该命名空间属于Windows Workflow Foundation (WF)的一部分，用于构建执行管道以执行一系列任务。我之前曾在Windows PowerShell中利用过WF的核心功能来绕过代码完整性检查。

#### ObjectSerializedRef 类

`ObjectSerializedRef`类看起来像是可以反序列化任何对象类型的类，而不仅仅是序列化的对象。如果确实如此，那么它是一个非常强大的原语，可以用来建立更强大的反序列化链。

查看其实现后发现，该类通过`ActivitiySurrogateSelector`类暴露为序列化替代。这是.NET序列化API的一个特性，允许在序列化过程中指定“代理选择器”，用代理类替换对象。当流反序列化时，此代理类包含足够的信息来重建原始对象。`ObjectSerializedRef`超出了特定的用例，允许反序列化任何内容。

#### 测试和验证

`ObjectSurrogate`类似乎没有任何问题。这个类彻底破坏了确保不可信的`BinaryFormatter`流的希望，因为从.NET 3.0开始就可以使用它。现在，任何没有标记为可序列化的类都成为目标。在反序列化过程中调用任意委托变得非常简单，开发人员通常不会防范这种攻击方式。

#### 选择目标

虽然可以选择进一步探讨Workflow类，但其API在.NET 4中已经被新的、稍微好一些的API取代。因此，我选择了一个更易于使用的目标：语言集成查询（LINQ）。

#### LINQ 作为反序列化链的一部分

LINQ作为核心语言特性在.NET 3.5中引入，提供了一种类似于SQL的新语法，用于跨可枚举对象执行查询。例如，基于长度过滤名称列表并返回大写列表的语法如下：

```csharp
var result = names.Where(n => n.Length > 5).Select(n => n.ToUpper());
```

实际上，`Where`方法需要两个参数：一个列表对象和一个委托，用于枚举列表中的每个条目。委托通常由应用程序提供，但我们也可以使用系统方法替换委托。重要的是，在枚举列表之前不会调用委托。这意味着我们可以使用LINQ方法构建一个枚举列表，使用`ObjectSurrogate`进行序列化，然后强制反序列化列表被枚举，从而执行任意代码。

#### 枚举列表

使用LINQ作为原语，我们可以创建一个列表，当枚举时，该列表按以下顺序将字节数组映射到该字节数组中的一个类型的实例：

1. 将字节数组转换为`Assembly`对象。
2. 提取特定类型。
3. 创建该类型的实例。

唯一棘手的部分是第2步，我们想提取一个特定的类型，但我们唯一的选择是使用`Enumerable.Join`方法，这需要一些技巧才能使其有效。更好的选择是使用`Enumerable.Zip`，但这只在.NET 4中引入。因此，我们将获取加载的程序集中的所有类型，并全部创建它们。如果只有一个类型，这不会有什么区别。

#### C# 实现

C#实现中唯一不明显的地方是`Assembly::GetTypes`的委托。我们需要一个接受`Assembly`对象并返回`Type`对象列表的委托。然而，由于`GetTypes`是一个实例方法，默认会捕获`Assembly`类并将其存储在委托对象内，这会导致一个不接收参数并返回`Type`列表的委托。我们可以通过使用反射API为实例成员创建一个开放委托来解决这个问题。开放的委托不存储对象实例，而是将其作为额外的`Assembly`参数公开。

#### 枚举列表以启动链

为了枚举列表以启动链，我尝试找到一个在调用`ToString`方法时会枚举列表的类。在Java中，几乎所有的集合类都有这种行为，但在.NET中情况不同。因此，我修改了我的分析工具，以寻找可以帮助我们达到目的的小工具。最终，我通过三个单独的类发现了一个从`ToString`到`IEnumerable`的链。

#### 最后的一步

我们需要在反序列化期间调用任意对象上的`ToString`。为此，我可以利用`Hashtable`类。在`Hashtable`类的反序列化期间，它会重建其键集。如果两个键相同，则反序列化会失败，并抛出异常，从而运行以下代码：

```csharp
key = GetResourceString(valueArray, resourceString);
formattedKey = String.Format(resourceString, key);
```

生成的资源字符串具有格式化代码，因此当`String.Format`遇到非字符串值时，会调用对象上的`ToString`将其格式化。这导致在反序列化期间调用`ToString`，从而触发事件链，从内存中加载任意.NET组件并在WMI客户端的上下文中执行代码。

### 结论

微软通过确保`System.Management`类从不直接为WMI对象创建RCW修复了远程代码执行（RCE）问题。然而，此修复不影响.NET中其他DCOM的使用，因此特权.NET DCOM服务器仍然存在漏洞，其他远程DCOM应用程序也可能受到攻击。

此外，这应该是一个教训，永远不要使用.NET `BinaryFormatter`类反序列化不受信任的数据。无论如何这样做都是危险的，但开发人员似乎放弃了制作安全的可序列化类的任何希望。`ObjectSurrogate`的存在实际上意味着，运行时中的每个类都是可序列化的，无论原始开发人员希望与否。

最后，您应该始终对中间件的安全性实施持怀疑态度，尤其是当您不能检查其所作所为时。IManagedObject的问题是与生俱来的，难以移除，所以正确修复很难。