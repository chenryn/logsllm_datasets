keyword matches  583 
347 
80 
related 
Number of bugs 
12.5k 
Table 2. Bug counts for different 
analysis. 
stages of the 
bugs. We analyzed 
the bug reports 
(including 
code of the application. 
several 
Bug reports 
contain 
the bugs using information 
contained 
as well as the source 
in 
the patches), 
out non-concurrency 
types of information 
that are 
bugs, and for under­
their characteristics. 
In particular, 
of the bug, but also discussion 
bug reports 
con­
is often important 
useful for filtering 
standing 
tain not only the description 
among the developers 
and solve the problem. 
discussions 
particular 
and to understand 
also include 
the bug; sometimes 
before developers 
also include additional 
the status, 
version 
and the software 
their effects. 
to determine 
and debuggers 
about how to diagnose 
The information 
contained 
in these 
to understand 
the bugs, in 
whether they are concurrency 
bugs, 
the bug report will 
Typically 
the patch, and even the method to reproduce 
more than one  patch 
attempt 
is made 
agree on a definitive 
patch. Bug reports 
fields such as the perceived 
severity, 
analyze. 
ficult to successfully 
are likely to be underreported, 
out of a total of about 12.5k bugs in the bug database 
only found 80 concurrency 
bugs. 
bugs 
Second, concurrency 
which would explain 
why 
we 
2.3 Manual analysis of bug reports 
We manually 
analyzed 
the bug reports 
of the sampled list 
the effects 
of the 
of bugs, focusing 
on trying to understand 
reports 
to gain an understanding 
of how bugs are triggered 
We used all 
affected. 
these types of information 
contained 
in bug 
978-1-4244-7501-8/10/$26.00 
©20lO IEEE 
223 
DSN 20lO: Fonseca et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:03:53 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
and when they are what are their effects 
of this information 
of fixing concurrency 
bugs and their severity. 
was also used to estimate 
the complexity 
2. In addition, some 
3 MySQL 
In this section 
we provide 
a brief overview 
of the char­
acteristics 
of MySQL that are relevant 
for this study. 
mem­
Despite 
for other types 
the problems 
primitives 
and improving 
of recent proposals 
such as transactional 
the existence 
of synchronization 
ory [17], there is value in studying 
ods that address 
tion. This is not only because we still run many applications 
that use locks, which will benefit from being made more 
bust for years to come, but also because the vision behind 
such proposals 
to use these new primitives 
where the possible 
of the code 
impact would be lower. 
with lock-based 
is not to entirely 
locks, but instead 
synchroniza­
performance 
in smaller 
sections 
replace 
the meth­
ro­
3.1  Internal structure 
3.3  Request vs. transaction concurrency 
MySQL is a complex code base where the state of the 
that are 
data structures 
server is spread  across 
stored both in memory and persistently. 
some of the main data structures 
later sections. 
that will be referred 
multiple 
to in 
Here we describe 
An important 
class of stored structures 
are data  files 
of different 
that contain the contents 
database. 
In addition, 
dexes of the tables are also maintained, 
lookups by the contents 
tables stored in the 
a series of files containing 
which allow for fast 
columns of the tables. 
of certain 
the in­
To correctly 
understand 
the meaning of concurrency 
and transaction-level 
needs to be clear. In a database 
system, 
client 
grouped into transactions, each 
of requests 
(e.g., 
requests 
read or write to the database, 
of 
to 
and com­
There is often some confusion 
between request 
of a sequence 
are logically 
bugs the distinction 
concurrency 
operations 
which consists 
begin a transaction, 
mit or abort the 
transaction). 
between the notion of concurrent 
rent requests, 
interested 
in. 
and which kinds of concurrency 
transactions 
and concur­
bugs are we 
Another important  persistent 
structure 
is the binary log 
which is used for two 
is used, in which the pri­
to as the binlog structure), 
purposes. 
writes to the binlog the statements 
that modify the database 
The log is mainly useful when primary­
of the database 
(referred 
different 
backup replication 
mary replica 
ing to all client 
backup replicas 
contained 
lated to other recovery 
state from a backup file, in which case some events  that 
were logged after the backup operation 
must be re-executed. 
The other use of the binlog is re­
such as restoring 
requests 
then sequentially 
the statements 
in the binlog. 
operations 
re-execute 
correspond­
database 
state. 
The 
MySQL contains 
a series of caches that speed 
to persistent 
structures 
or processing 
table cache holds the descriptors 
of requests. 
of recently 
Finally, 
up access 
For instance, a 
accessed 
recently 
tables, 
executed 
while a query cache holds the results 
queries. 
of 
We will only analyze 
bugs that are triggered 
since these are the ones that reflect 
by concur­
problems 
Bugs that are triggered 
requests, 
concurrency 
rent individual 
the traditional 
programs. 
tions but can be reproduced 
quence of requests 
this study. 
are not considered 
deterministically 
transac­
by concurrent 
by a given se­
concurrency 
bugs in 
that arise in parallel 
Thus we define a concurrency 
from the intended 
deviates 
bug as one where the ap­
given a cer­
but it must be the case that the bug 
behavior, 
of inputs, 
plication 
tain pattern 
is only manifested 
definition 
(e.g., 
problems 
is general 
(e.g., 
under specific 
thread interleavings. 
This 
enough to include 
both safety problems 
server crash or issuing 
wrong replies) 
deadlocks 
or even performance 
and liveness 
bugs). 
4 Results 
3.2  Concurrent programming 
The use of concurrency 
in MySQL is typical 
of a server 
Clients 
issue several 
to the database 
(called 
is handled by a separate 
requests 
which are grouped into sessions 
Each connection 
application. 
server, 
tions). 
the server side, and different 
many shared data structures, 
above. To synchronize 
mostly resort to locks but also use condition 
threads 
such as the ones we mentioned 
threads 
variables. 
thread on 
contend for access to 
access to these  structures, 
connec­
2The raw data gathered from this manual analysis can 
be  found at  http://www .mpi-sws.org/-pfonseca/ 
dsn2010-bug-study.tgz 
In this section 
we present 
of 
bugs that we found in the MySQL bug 
the results 
of our analysis 
A summary of these results 
and their main impli­
the 80 concurrency 
database. 
cations 
are also presented 
in Table 1. 
4.1 Evolution of concurrency bugs 
We investigated 
the proportion 
of concurrency 
bugs 
in the bug database 
and how this proportion 
present 
We were interested 
are becoming more prevalent. 
tified the opening and closing 
that we analyzed 
bugs 
this, we iden­
bugs 
as well as of all closed bugs within the 
To determine 
year of the concurrency 
in knowing whether concurrency 
evolves. 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
224 
DSN 2010: Fonseca et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:03:53 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
25 
15 
---)(---
bugs --+--
Proportion 
# Concurrency 
25 
on  20 
" .D 
>. 
u " 
g 
" 
10 
u " 
0 
u  5 
"" 
0 
2003 2004  2005 2006 2007 2008  2009 
_______ K--____ -->E __ ---__ .x.. ....... 
§ 
! 
15 
10 0 
" 
'e 
8. 
5 
Ie 
"-
20 
0 
25 
bugs --+--
Proportion 
# Concurrency 
---)(---
25 
on  20 
" .D 
>. 
u " 
15 
g 
"  10 
u 
6 
u  5 
"" 
0 
2003 2004  2005 2006 2007 2008 2009 
-
___ ,.._-_---
x--------)( -----
/ 
__ )( _____ ---x 
§ 
! 
" 
10 .Q 
8. 
Ie 
"-
15 
20 
5 
0 
Time (year) 
Time (year) 
Figure 1. Evolution of bugs (by open date). 
Figure 2. Evolution of bugs (by close date). 
To obtain the set containing 
all 
the keyword part of the search together 
phase explained 
in Section 
2. For each 
with generic bugs). We looked at 
(compared 
MySQL server category. 
bugs we excluded 
with the sampling 
year we counted the number of concurrency 
proportion 
both the opening date and closing 
mers typically 
many months) to solve the bugs under analysis. 
are presented 
see that there has been a trend  of 
proportion 
this trend does not seem to be very prominent. 
of concurrency 
a significant 
increasing 
in Figures 
require 
1 and 2. From these results 
we can 
number and 
amount of time (i.e., 
The results 
bugs over the years. However, 
date because program­
bugs and their 
The data that we collect 
does not allow us to determine 
reasons 
however we can think of 
is that the advent of multi-core 
this finding, 
for this slight increase. 
the causes underlying 
two possible 
explanation 
users and developers 
ten than they used to in the past. Another explanation 
we cannot rule out is that developers, 
ther parallelize 
concurrency 
hardware 
to stumble upon these bugs more of­
while trying to fur­
the number of 
bugs that they introduce. 
the code, actually 
increase 
causes 
that 
One possible 
Of the concurrency 
bugs that we sampled, 
the oldest con­
bug was opened in March 2nd, 2003, while the 
was closed in September 
16th, 2009. Therefore, 
fair, we excluded 
this range from the list of generic 
the bugs that were 
bugs used to com­
currency 
youngest 
to make the comparison 
outside 
pute the proportions. 
To interpret 
these results 
it should also be taken into con­
4.7, the time it takes 
that, as we show in Section 
bug can be quite long (e.g., 
why the ab­
sideration 
to close a concurrency 
bugs took more than a year to fix). This explains 
solute number of bugs opened in the last year is low: many 
concurrency 
in 2009 have not 
yet been fixed, which means they are not yet closed and 
were therefore 
bugs potentially 
for in this study. 
not accounted 
discovered 
some 
4.2 External effects 
We analyzed 
the concurrency 
bugs with respect 
to the 
effects that are exposed to the clients, 
external 
these effects into six categories. 
and divided 
are presented 
The results 
in 
is larger than 
Table 3. Note that the sum of all occurrences 
the total number of bugs because some bugs fit into more 
than one category. 
We can see that there are slightly 
more bugs that cause 
(63%) than deadlock 
non-deadlock  conditions 
(40%), and among the non-deadlock 
lent consequences 
(28%) or providing 
term semantic 
bugs the most preva­
are either causing the server to crash 
the wrong results 
to the user, which we 
bugs (15%). 
conditions 
failures, 
where the applica­
that violates 
the intended 
This is  an interesting 
class 
Semantic 
bugs are Byzantine 
the user with a result 
of the application. 
tion provides 
semantics 
of bugs since masking their effects requires 
(and possibly 
fault-tolerant 
behavior 
system [30]. We discuss 
tion 4.4. 
techniques 
[10] or run-time 
expensive) 
replication 
of the application 
against 
such as Byzantine­
verification 
a specification 
of the 
of the 
these bugs in more detail in Sec­
The high percentage 
of deadlock 
bugs that we encoun­
that, despite 
bugs, in practice 
tered leads us to believe 
to address deadlock 
constitutes 
ware. The percentage 
is in line with results 
a significant 
of deadlock 
from other studies 
bugs that 
[22]. 
problem for the 
robustness 
of soft­
our study found 
this class of bugs still 
significant 
research 
sophisticated 
We distinguish 
The remaining 
three classes 
of external 
effects 
were 
to the 
These are error messages (9%), 
is explicitly 
result is also returned. 
from the class of semantic 
by the server and therefore 
bugs, de­
are provided 
less prevalent. 
slightly 
which we distinguish 
spite the fact that when error messages 
user an unexpected 
error bugs from semantic 
detected 
the reply to the client request, 
client application 
(bug #42519) when a  restore 
currently 
returned 
in which client 
reply), 
thread or a series of  threads 
pendency. 
to release 
bugs by the fact that an error is 
flagged in 
and can be handled by the 
in one bug 
is performed 
con­
with an insert 
error message is 
to the user. We also found a number of bugs (8%) 
operation 
a generic 
Typically 
a certain 
which differs from a deadlock 
appropriately. 
For instance, 
thread that tries to 
lock, causing 
operation 
situation 
are waiting in a circular 
hang (the client does not receive 
these are caused by a thread that fails 
requests 
another 
where one 
de­
a 
978-1-4244-7501-8/10/$26.00 
©2010 IEEE 
225 
DSN 2010: Fonseca et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:03:53 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
effect  Number of bugs 
effect  Number of bugs 
External 
Crash 
Deadlock 
Error 
Hang 
Performance 
Semantic 
22 
32 
7 
6 
5 
External 
Crash 
Deadlock 
Error 
Hang 
Performance 
Semantic 
1 