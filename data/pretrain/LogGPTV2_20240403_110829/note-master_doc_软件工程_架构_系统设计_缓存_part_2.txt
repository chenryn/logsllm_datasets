- 缓存击穿
对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题：
如果这个key的计算不能在短时间完成，那么在这个 key 在效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞
#### 解决方案
- 锁
  - 在重建缓存时 只允许一个线程重建 其他线程必须等待
- 不设置过期时间，而将过期时间设置在数据中，如果检测到数据过期了，再清除掉 或者当发现超过逻辑过期时间后，会使用单独的线程去构建缓存
- 读写分离 使用如canal等中间件从数据库同步数据到缓存
### 缓存穿透
指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，请求穿透到了数据库，然后返回空。这样就会导致每次查询不存在的数据都会绕过缓存去查询数据库
#### 解决
1. 把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透
  - 这种方案对空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 同时也会有一定的数据不一致性
2. 也可以使用布隆过滤器直接对这类请求进行过滤
  - 这种方法适用于数据命中不高、数据相对固定、实时性低（通常是数据集较大）的应用场景
#### 布隆过滤器
![布隆过滤器](/assets/2022712144645.webp)
一串数据通过n个散列函数将一个位图的n位设置为1，当要查询时，对数据进行散列 判断对应的n位是否都为1 若为1, 则就是可能存在
所以布隆过滤器也没有足够的信息可以删除指定的key，为了应对缓存数据过期，可以采用定期重建的方法，重建完保持两个过滤器的双写，一段时间后，就把全部请求都给到较新的这个过滤器上，清除老的过滤器
#### 布谷鸟过滤器
- 布谷鸟哈希：使用两个哈希函数对一个key进行哈希，得到桶中的两个位置，如果有空位，key就放在空位里，否则就要随机踢掉一个元素，踢出的元素再计算哈希找到相应的存储位置
![2022817204730](/assets/2022817204730.jpg)
哈希表的基本单位称为条目（entry）。 每个条目存储一个指纹（fingerprint），指纹指的是使用一个哈希函数生成的n位比特位
相比布隆过滤器，布谷鸟过滤器可以通过从哈希表删除相应的指纹删除插入的项，由于哈希的特性，是存在误删的可能的，同时，只要不发生桶溢出，在查询的时候就不会出现假阳
### 缓存一致性
缓存中的数据与真实数据源中的数据不一致的现象
#### 解决
- 当数据更新的同时立即去更新缓存
  - 读请求和写请求串行化，串到一个内存队列里去
- 读缓存之前判断缓存是否是最新，否则先进行更新缓存
- 更新数据时，先更新数据库，再删除缓存（旁路写策略）
  - 为什么要删除缓存，而非更新缓存，如果缓存采用更新的方式，可能这个缓存压根就不会被用到，应该是用到缓存才去写入缓存
保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。或者直接使用类似于canal的中间件，直接同步数据库，这样不仅能解耦业务代码，也能拥有最终一致性
### 缓存无底洞
随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作
#### 解决
- 优化细粒度的远程调用
- 减少网络通信次数
- 使用长连接或者连接池
![屏幕截图 2020-10-12 142253](/assets/屏幕截图%202020-10-12%20142253.png)
## 客户端缓存
### 浏览器缓存
![批注 2020-07-06 092632](/assets/批注%202020-07-06%20092632.png)
- ETag
```
ETag: "5d8c4a06-a0fc"
```
ETag 用来校验用户请求的资源是否有变化
- **Cache-Control**、 Last-Modified 、Expires
Last-Modified : 表示文档最后修改时间，浏览器在访问重复资源的时候会发送`IF-Modified-Since` 携带此时间去服务器验证，如果时间匹配则返回304，浏览器加载本地资源
Expires： 文档过期时间，在浏览器内可以通过这个时间来判断是否发送请求
Cache-Control ：http1.1的规范，使用max-age表示文件可以在浏览器中缓存的时间以秒为单位
- **Cache-Control和ETag的区别**
Cache-Control直接是通过不请求来实现，而ETag是会发请求的，只不过服务器根据请求的东西的内容有无变化来判断是否返回请求的资源
##### Age
是CDN添加的属性表示在CDN中缓存了多少秒
##### **via**
用来标识CDN缓存经历了哪些服务器，缓存是否命中，使用的协议
#### 浏览器缓存原则
- **首页**可以看做是框架 应该禁用缓存，以保证加载的资源都是最新的
- 还有一些场景下我们希望禁用浏览器缓存。比如轮训api上报数据数据
- 浏览器缓存很难彻底禁用，大家的做法是加版本号，随机数等方法。
- 只缓存200响应头的数据，像3XX这类跳转的页面不需要缓存。
- 对于js，css这类可以缓存很久的数据，可以通过加版本号的方式更新内容
- 不需要强一致性的数据，可以缓存几秒
- 异步加载的接口数据，可以使用ETag来校验。
- 在服务器添加Server头，有利于排查错误
### 应用缓存
分为手机APP和Client以及是否遵循http协议
在没有联网的状态下可以展示数据
流量消耗过多
- 漂亮的加载过程
- 提前下发  避免秒杀时同时下发数据造成流量短时间暴增
- 兜底数据 在服务器崩溃和网络不可用的时候展示
- 临时缓存  退出即清理
- 固定缓存  展示框架这种，可能很长时间不会更新，可以随客户端下发
- 父子连接 页面跳转时有一部分内容不需要重新加载，可用从父菜单带过来
- 预加载     某些逻辑可用判定用户接下来的操作，那么可用异步加载那些资源
- 异步加载 先展示框架，然后异步加载内容，避免主线程阻塞
## 数据分布
### 哈希分布
哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上
传统的哈希分布算法存在一个问题：当节点数量变化时，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移
### 顺序分布
将数据划分为多个连续的部分，每个节点固定存放一定范围内的数据，按数据的 ID 或者时间分布到不同节点上
可以保持数据的顺序，并且可以控制服务器的数据量
## 一致性哈希
Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题，当然不仅可以用在存储上，也能用在请求的负载均衡上
将哈希空间看做一个环，服务器节点分布在这些环上，当一个数据计算出哈希值后，找出这个哈希值后面最近的一台服务器，将数据存放到这台服务器上
![2020317153322](/assets/2020317153322.jpg)
当服务器节点发生变更，受到影响的，只是变更节点的后一台服务器，只需对这台服务器的数据进行重新再计算哈希即可
![2020317153440](/assets/2020317153440.jpg)
### 虚拟节点
一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同
那么就可以通过增加虚拟节点的方式，把这些节点映射到真正的服务器节点，使得数据分布更加均匀
## 静态化
### 全量静态化
对于小型网站，页面不多，可以采用这个方式
![批注 2020-03-22 100728](/assets/批注%202020-03-22%20100728.png)
### 按需静态化
当数据发生变更，往MQ推送一条消息，消费者消费数据并进行渲染
![批注 2020-03-22 101628](/assets/批注%202020-03-22%20101628.png)