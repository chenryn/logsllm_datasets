---
## Page 223
若干简单的例子
197
不过，这个例子也能用来说明，看起来正确的正则表达式如何会匹配意料之外的文本，它
虽然看起来正确，但不是任何情况下都正确。我们希望它匹配下面这个无聊的例子中的划
线部分：
Darth Symbol:/1-\or*[^-^]*
但它匹配的是：
Darth Symbol:/-1-\\*or[^-]*
这是因为，第一个闭引号之前的确存在一个反斜线。但这个反斜线本身是被转义的，它不
是用来转义之后的双引号的（也就是说这个引号其实是表示引用文本的结束）。而逆序环视
无法识别这个被转义的反斜线，如果在这个引号之前有任意多个‘\\’，用逆序环视只会把
事情弄得更槽。原来的表达式的真正问题在于，如果反斜线是用来转义引号的，在我们第
一次处理它时，不会认为它是表示转义的反斜线。所以，我们得用别的办法来解决。
仔细想想我们想要匹配的位于开始分隔符和结束分隔符之间的文本，我们知道，其中可以
包括转义的字符（\.)，也可以包括非引号的任何字符（"]。于是我们得到（\\.1（"]）
*"。不错，现在这个问题解决了。不幸的是，这个表达式还有问题。不期望的匹配仍然会
发生，比如对这个文本，它应该是无法匹配的，因为其中没有结束分隔符。
Youneeda2\"x3\Photo.
达式一开始匹配到了引号之后的文本，如果找不到结束的引号，它就会回溯，到达
….2x\·3\…
（\.1[]）
从这里开始，（]匹配到反斜线，之后的那个引号被认为是一个结束的引号。
这个例子给我们的重要启示是：
如果回溯会导致不期望，与多选结构有关的匹配结果，问题很可能在于，任何成功的
匹配都不过是多选分支的排列顺序造成的偶然结果。
实际上，如果我们把这个正则表达式的多选分支反过来排列，它就会错误地匹配任何包含
转义双引号的字符串。真正的问题在于，各个多选分支能够匹配的内容发生了重叠。
那么，应该如何解决这个问题呢？就像第186页的那个连续行的例子一样，我们必须确保，
这个反斜线不能以其他的方式匹配，也就是说把（"]改为\\"]。这样就能识别双引
---
## Page 224
198
第5章：正则表达式实用技巧
号和文本中的“特殊”反斜线，必须根据情况分别处理。结果就是“（\\.1[\\"1）*"，它
工作得很好（尽管这个正则表达式能够正常工作，但对于NFA引擎来说，仍然有提升效率
的改进，我们会在下一章更详细地看这个例子，222）。
这个例子告诉我们一条重要的原理：
不应该忘记考虑这样的“特殊”情形：例如针对“糟糕（bad）”的数据，正则表达式
不应该能够匹配。
我们的修改是正确的，但是有意思的是，如果有占有优先量词（142）或者是固化分组
（139)，这个正则表达式可以重新写作"（\\.1[^"]）*+"和"（?>（\\.1[^"]）*）"。这
两个正则表达式禁止引擎回溯到可能出问题的地方，所以它们都可以满足要求。
理解占有优先量词和固化分组解决此问题的原理非常有价值，但是我仍然要继续之前的修
正，因为对读者来说它更具描述性（更直观）。其实在这个问题上，我也愿意使用占有优先
量词和固化分组一一不是为了解决之前的问题，而是为了效率，因为这样报告匹配失败的
速度更快。
了解数据，做出假设
KnooingYourDataandMakingAssumptions
现在是时候强调我曾经数次提到过的关于构建和使用正则表达式的一般规则了。知道正则
表达式会在什么情况中应用，关于自标数据文有什么样的假设，这非常董要。即使简单如'a
这样的数据也假设目标数据使用的是作者预期的字符编码（105）。这都是一些很基本的
常识，所以我一直没有过分细致地介绍。
但是，许多对某个人来说明显的常识，可能对其他人来说并不明显。例如，前一节的解决
办法假设转义的换行符不会被匹配，或者会被应用于点号通配模式（111）。如果我们真的
想要保证点号可以匹配换行符、同时流派也支持，我们应该使用（？s：.）。
前一节中我们还假设了正则表达式将应用的数据类型，它不能处理表示其他用途的双引号。
如果用这个正则表达式来处理任何程序的源代码，就可能出错，因为注释中可能包括双引
号。
对数据做出假设，对正则表达式的应用方式做出假设，都无可厚非。问题在于，假设如果
---
## Page 225
若干简单的例子
199
存在，通常会过分乐观，也会低估了作者的意图和正则表达式最终应用间的差异。记录下
这些假设会有帮助。
去除文本首尾的空白字符
StrippingLeadingandTrailingWlitespace
去除文本首尾的空白字符并不难做到，这是经常要完成的任务。总的来说最好的办法是使
用下面两个替换：
s/^\s+// ;
s/\s+S//;
为了增加效率，我们用+而不是*，因为如果事实上没有需要删除的空白字符，就不用做
替换。
出于某些考虑，人们似乎更希望用一个正则表达式来解决整个问题，所以我会提供一些方
法供比较。我不推荐这些办法，但对理解这些正则表达式的工作原理及其问题所在，非常
有意义。
S/$/SS\(+）S\/S
这个正则表达式曾被用作降解忽略优先量词的绝佳例子，但现在不是了，因为人们认
识到它比普通的办法慢得多（在Perl中要慢5倍）。之所以效率这么低，是因为忽略优
先约束的点号每次应用时都要检查s*$1。这需要大量的回溯。
S/^\s*((?:. *\S)?)\s*$/$1/S
这个表达式看起来比上一个要复杂，不过它的匹配倒是很容易理解，而且所花的时间
也只是普通方法的2倍。在\s*匹配了文本开头的空格之后，.*马上匹配到文本的
末尾。后面的S强迫它回溯直到找到一个非空的字符，把剩下的空白字符留给最后
的s*S，捕获括号之外的。
问号在这里是必须的，因为如果一行数据只包含空白字符的行，必须出现问号，表达
式才能正常工作。如果没有问号，可能会无法匹配，错过这种只有空白字符的行。
s/^\s+1\s+$//g
这是最容易想到的正则表达式，但它不正确（其实这三个正则表达式都不正确），这种
顶极的（top-leveled）多选分支排列严重影响本来可能使用的优化措施（参见下一章）。
/g这个修饰符是必须的，它容许每个多选分支匹配，去掉开始和结束的空格。看起来，
用/g是多此一举，因为我们知道我们只希望去掉最多两部分空白字符，每部分对应单
独的子表达式。这个正则表达式所用的时间是简单办法的4倍。
---
## Page 226
200
第5章：正则表达式实用技巧
测试时我提到了相对速度，但是实际的相对速度取决于所用的软件和数据。例如，如果目
标文本非常非常长，而且在首尾只有很少的空格，中间的那个表达式甚至会比简单的方法
更快。不过，我自己在程序中仍然使用下面两种形式的正则表达式：
S/\S+//;
S/\S+$//;
因为它几乎总是最快的，而且显然最容易理解。
HTML相关范例
HTML-Relnted Examples
在第2章，我们曾讨论过把纯文本转换为HTML的例子（67），其中要使用正则表达式从
文本中提取E-mail地址和httpURL。本节来看些与HTML相关的其他处理。
匹配HTMLTag
Matclting an HTML Tag
最常见的办法就是用]+>来匹配HTML标签。它通常都能工作，例如下面这段用来
去除标签的Perl语句：
Shtml =~s/]+>//g;
如果tag中含有‘>'，它就不能正常匹配了，而这样的tag明明是合乎HTML规范的：">。虽然这种情况很少见，也不为大家推荐，但HTML语言确实容许
在引号内的tag属性中出现非转义的‘’。这样，简单的]+>就无法匹配了，
得想个聪明点的办法。
‘’中能够出现引用文本和非引用形式的“其他文本（otherstuff)”，其中包括除了‘>’
和引号之外的任意字符。HTML的引文可以用单引号，也可以用双引号。但不容许转义嵌
套的引号，所以我们可以直接用[~"]*"和[~]*来匹配。
把这些和“其他文本”表达式~">]合起来，我们得到：
{
这个表达式可能有点难看懂，那么加上注释，按宽松排列格式来看：
#开始尖括号“]
#
其他文本”
*
#
#结束尖括号">”
---
## Page 227
HTML相关范例
201
这个表达式相当漂亮，它会把每个引用部分单作为一个单元，而且清楚地说明了在匹配的
什么位置容许出现什么字符。这个表达式的各部分不会匹配重复的字符，因此不存在模糊
性，也就不需要担心发生前面例子中出现的，“不小心冒出来（sneakingin）”非期望匹配。
不知你是否注意到了，最开始的两个多选分支的引号中使用了*，而不是+1。引用字符事
可能为空（例如‘alt=""'），所以要用*来处理这种情况。但不要在第三个多选分支中用
“取代+，因为"[^">]只接受括号外的"*的限定。给它添加一个加号得到"（[^"">]+）*，
可能导致非常奇怪的结果，我不期望读者现在就能理解，下一章（226）会详细讲解它。
在使用NFA引擎时，我们还需要考虑关于效率的问题：既然没有用到括号匹配的文本，我
们可以把它们改为非捕获型括号（137)。因为多选分支之间不存在重复，如果最后的‘>
无法匹配，那么回头来尝试其他的多选分支也是徒劳的。如果一个多选分支能够在某个位
置匹配，那么其他多选分支肯定无法在这里匹配。所以，不保存状态也无所谓，这样做还
可以更快地导致失败，如果找不到匹配结果的话。我们可以用固化分组（？>）而不是非
捕获型括号（或者用占有优先的星号限定）。
匹配HTMLLink
MatclhinginHTMLLink
假设我们需要从一份文档中提取URL和链接文本，例如下面的文本中标记的内容：
"0·Rei1ly Media"
因为tag的内容可能相当复杂，我会分两步实现这个任务。第一个是提取tag内部
的内容，也就是链接文本，然后从tag中提取URL地址。
实现第一步有个简单办法，就是在点号通配模式下应用不区分大小写的]+)>（.*？）
i，这里使用了忽略优先量词。它会把的内容放入$1，把链接文本放入$2。当然，
像之前一样，我不应该用（^>]+，而应该使用前几节中的表达式。不过在本节，我会继续
使用这个简单的形式，因为这样正则表达式更短，也更容易讲解。
的内容存人字符串之后，就可以用独立的正则表达式来检查它们。其中，URL是
href=value属性的值。之前已经说过，HTML容许等号的任意一侧出现空白字符，值可以
---
## Page 228
202
第5章：正则表达式实用技巧
以引I用形式出现，也可以以非引用形式出现。下面的Perl代码用来输出变量SHtm1中的链
接。
#请注意：while（...）中的正则表达式是简化的形式，请参见正文
while (SHtml =~ m(a\b([^>]+)>(.*?)}ig)
my SGuts=S1；#把匹配结果存入..
mySLink=S2;#....对应变量
if (SGuts =~ m(
\b HREF
#“href"属性
\s*=\s*
#“=两端可能出现空白宇符
(?：
#其值为..
"([=] *） *
#
双引号字将串
#
或者是..
'([·]*)
#
单引号字符串
1
#
或者是...
([">\s]+)
#
“其他文本"
）
)xi)
mySUr1=S+；#获得S1、S2等中实际参与匹配的编号最大的捕获型括号的内容
print "SUrl with iink text: $Link\n";
）
有几点需要注意：
我们为匹配值的每个多选结构都添加了括号，来捕获确切的文本。
因为我使用了某些括号来捕获文本，在不需要捕获的地方我使用非捕获型括号，这样
做既清楚又高效。
“其他字符”部分排除了空白字符，也排除了引号和‘>’。
因为需要捕获整个href的值，这里使用了‘+来限制“其他文本”多选分支。这是否
没有直接作用于整个多选结构的量词。其中的细节同样会在下一章讨论。
根据具体文本的不同，最后，URL可能保存在S1、$2或者S3中。此时其他捕获型括号就
为空或是未定义。Perl提供了特殊变量$+，代表s1、$2之类中编号最靠后的捕获文本。在
本例中，这就是我们真正需要的URL。
Perl中的S+很方便，其他语言也提供了其他办法来选择捕获的URL。常用的程序语言结构
就可以检查捕获型括号，找到需要的内容。如果能够支持，命名捕获（138）最适用于干
这个，就像204页的VB.NET的例子那样（幸亏.NET提供了命名捕获，因为它的S+有问题，
424)。
---
## Page 229
HTML相关范例
203
检查HTTPURL
Examining an HTTP UIRL
现在我们得到了URL地址，来看看它是否是HTTPURL，如果是，就把它分解为主机名
（hostname）和路径（path）两部分。因为已经有了URL，任务就比从随机文本中识别URL
要简单许多，识别的程序要难许多，这将在后文介绍。
所以，如果拿到一个URL，我们需要能够将它拆分为各个部分。主机名是http：//之后
和第一个反斜线（如果有的话）之前的内容，而路径就是除此之外的内容：
[http://（[/]+）(/.*）?$1。
URL中有可能包含端口号，它位于主机名和路径之间，以一个冒号开头：^http：//
({~/:]+)(:(\d+))？(/. *)？$1