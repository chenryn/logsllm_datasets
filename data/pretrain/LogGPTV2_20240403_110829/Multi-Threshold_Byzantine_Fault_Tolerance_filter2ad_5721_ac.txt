ple equivocation check achieves consistency because a replica stops
outputting if it detects equivocation. A faulty sender can exploit this
to break liveness (in particular totality): after some honest repica
outputs a value, the sender rushes to send a conflicting proposal
to another honest replica to stop it from outputting. To prevent
this attack, we perform equivocation check on both proposals and
certificates. We first perform equivocation check on proposal to
rule out conflicting votes among honest replicas. Then, after re-
ceiving a certificate, we perform equivocation check on certificates
to rule out conflicting decisions. The latter easily achieves consis-
tency with an arbitrary ğ›½ğ‘   ğ›¾ğ‘ , both values must have been voted by honest replicas.
Let ğ‘Ÿ and ğ‘Ÿâ€² be the first honest replicas that have voted for ğ‘ and ğ‘â€²
at time ğ‘¡ and ğ‘¡â€², respectively. Without loss of generality, we assume
ğ‘¡ â‰¤ ğ‘¡â€². As ğ‘Ÿ votes for ğ‘ at ğ‘¡, it must have received and broadcast
âŸ¨propose, ğ‘âŸ©ğ‘Ÿğ‘  at ğ‘¡ âˆ’ Î”. Then, all honest replicas including ğ‘Ÿâ€² must
have received it by ğ‘¡ â‰¤ ğ‘¡â€². Therefore, ğ‘Ÿâ€² could not have voted for
ğ‘â€² â‰  ğ‘ at ğ‘¡â€², a contradiction.
An honest designated sender broadcasts âŸ¨propose, ğ‘ğ‘–ğ‘›âŸ©ğ‘Ÿğ‘  , and all
ğ‘› âˆ’ ğ›¾ğ‘  honest replicas vote for ğ‘ğ‘–ğ‘› forming a certificate C(ğ‘ğ‘–ğ‘›). As
no conflicting certificate exists, all honest replicas output the value
ğ‘ğ‘–ğ‘›. Thus, the validity holds.
If an honest replica outputs a value ğ‘, then it must have received
and broadcast C(ğ‘), which is received by all honest replicas. As no
conflicting certificate exists, all honest replicas output the value ğ‘.
Thus, the totality holds.
â–¡
Lemma 3.4 (Safety). If the network is asynchronous and there are
at most ğ›½ğ‘ faults, then safety holds.
Proof. Integrity proof is identical to Lemma 3.2. We prove con-
sistency. Suppose for the sake of contradiction that honest replicas
output two different values ğ‘ and ğ‘â€², then two certificates C(ğ‘)
and C(ğ‘â€²) are both formed. Let ğ¶ and ğ¶â€² be the two sets of ğ‘› âˆ’ ğ›¾ğ‘ 
replicas that have voted for ğ‘ and ğ‘â€². As ğ¶ and ğ¶â€² intersect at
2(ğ‘› âˆ’ğ›¾ğ‘ ) âˆ’ ğ‘› = ğ›½ğ‘ + 1 replicas, at least an honest replicas must have
voted for both values, a contradiction.
â–¡
Lemma 3.5 (Liveness). If the network is under asynchrony and
there are at most ğ›¾ğ‘ faults, then liveness holds.
Proof. Due to a quorum-intersection argument like the proof of
Lemma 3.4 in the presence of ğ›¾ğ‘ â‰¤ ğ›½ğ‘ faults, there cannot be conflict-
ing certificates. The rest of the proof is identical to Lemma 3.3. â–¡
Efficiency. When the leader is honest, the latency of the protocol is
two rounds plus 2Î” time; under synchrony, it can be written as 2Î”+
2ğ›¿ where ğ›¿ is the actual network delay and is usually significantly
smaller than the conservative delay bound Î”. Our protocol requires
ğ‘‚(ğ‘›2) messages, matching that of the Brachaâ€™s broadcast [10]. The
communication complexity (in bits) of our protocol is ğ‘‚(ğ‘›3) as
replicas send certificates containing ğ‘‚(ğ‘›) signatures. This is more
expensive than Brachaâ€™s ğ‘‚(ğ‘›2) RBC. It can be reduced to ğ‘‚(ğ‘›2)
using threshold signatures [13, 25].
4 TIGHT FAULT TOLERANCE BOUND ON
MT-BFT SMR IN THE PSYNC-SYNC MODEL
This section establishes a tight bound on the fault thresholds of
MT-BFT for state machine replication in the psync-sync model.
4.1 Fault Tolerance Limit of MT-BFT SMR
As mentioned before, a SMR protocol can solve RBC under the
same condition. Suppose we have a SMR protocol. The ğ‘› replicas
participating in the RBC execution run the SMR protocol. The
designated sender ğ‘Ÿğ‘  generates a transaction containing the signed
input value âŸ¨ğ‘ğ‘–ğ‘›âŸ©ğ‘Ÿğ‘  . A replica outputs the first transaction in the
SMR log that is signed by the sender ğ‘Ÿğ‘ . That is, when a replica
outputs in SMR a log [ğ‘¡ğ‘¥1, ğ‘¡ğ‘¥2, ..ğ‘¡ğ‘¥ğ‘™] where ğ‘¡ğ‘¥ğ‘– is âŸ¨ğ‘âŸ©ğ‘Ÿğ‘  and no ğ‘¡ğ‘¥ ğ‘—
(ğ‘—  0, its threshold parameters satisfy ğ›½ğ‘  + ğ›¾ğ‘  â‰¥ ğ‘›.
Proof. Suppose for the sake of contradiction there exists a MT-
BFT PVRBC protocol whose threshold parameters satisfy ğ›½ğ‘ +ğ›¾ğ‘  = ğ‘›
for a certain ğ‘› > 0 (trivially extended for ğ›½ğ‘  + ğ›¾ğ‘  > ğ‘›). Suppose the
Session 6A: Consensus and Attacks CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1690network consists of two partitions ğ‘ƒ and ğ‘„ with size ğ›¾ğ‘  > 0 and
ğ›½ğ‘  > 0, respectively. A designated sender ğ‘Ÿğ‘  is in ğ‘„. In this setting,
there are three possible executions below.
In the first execution (W1), all replicas are honest. The sender ğ‘Ÿğ‘ 
has an input value ğ‘. By the liveness, every honest replica outputs
ğ‘, i.e., obtains a proof ğœ‹ such that Verify(ğ‘, ğœ‹) = 1.
In the second execution (W2), all ğ›¾ğ‘  replicas in ğ‘ƒ crash. The
sender ğ‘Ÿğ‘  has an input value ğ‘â€² â‰  ğ‘. By the liveness in the presence
of ğ›¾ğ‘  faults, every honest replica outputs ğ‘â€², i.e., obtains a proof ğœ‹â€²
such that Verify(ğ‘â€², ğœ‹â€²) = 1.
In the third execution (W3), all ğ›½ğ‘  replicas in ğ‘„ are Byzantine. ğ‘„
behave towards ğ‘ƒ as in W1. Replicas in ğ‘ƒ cannot distinguish W1
and W3, so they behave as in W1. Thus, Byzantine replicas in ğ‘„
can obtain ğœ‹ such that Verify(ğ‘, ğœ‹) = 1. On the other hand, ğ‘„ can
simulate the execution of W2 in which ğ‘ƒ crash. Thus, Byzantine
replicas in ğ‘„ can also generate ğœ‹â€² such that Verify(ğ‘â€², ğœ‹) = 1. This
means honest replicas can receive proofs ğœ‹ and ğœ‹â€² for two different
values ğ‘ â‰  ğ‘â€² such that Verify(ğ‘, ğœ‹) = 1 and Verify(ğ‘â€², ğœ‹â€²) = 1. This
violates consistency. However, as the number of faults is |ğ‘„| = ğ›½ğ‘ ,
consistency should hold. This is a contradiction.
â–¡
The extra constraint shows that BFT SMR can achieve higher
(though not perfect) synchronous safety at the cost of synchronous
liveness. This observation helps us find new improvements to classic
asynchronous and partially synchronous protocols to potentially
tolerate ğ›½ğ‘  < 2ğ‘›/3 for synchronous safety.
A remark on Schneider [45]. It has been stated, without a proof,
that BFT SMR can tolerate only ğ‘“ < ğ‘›/2 faults due to the need
for public verifiability [45]. While intuition is clear for this claim,
we are not aware of a rigorous proof for it. We observe that it is a
special form of our Theorem 4.1 with a restriction of ğ‘¡ = ğ›½ğ‘  = ğ›¾ğ‘ .
So we have provided a rigorous proof for this well-known result.
4.2 A MT-BFT SMR Protocol with Optimal
Fault Tolerance
We present a MT-BFT SMR protocol with optimal fault tolerance in
the psync-sync model. Our protocol allows any parameter choice
within the optimal trade-offs. Namely, a protocol designer can first
pick ğ›¾ğ‘  < ğ‘›/2. Then, other parameters are determined as follows
(1) ğ›½ğ‘ = ğ‘› âˆ’ 2ğ›¾ğ‘  âˆ’ 1
(2) ğ›½ğ‘  = ğ‘› âˆ’ ğ›¾ğ‘  âˆ’ 1
(3) ğ›¾ğ‘ = min{ğ›½ğ‘, ğ›¾ğ‘ }
This is optimal given Theorem 3.1 and 4.1 and also establish the
tightness of the bounds for MT-BFT SMR in the psync-sync model.
Commit and public verifiability. When proving a negative re-
sult, we had to use the most general definition of SMR. But in de-
signing a protocol, we can use a set of safety and liveness conditions
convenient for us as long as they are sufficient for SMR. Towards this
end, we introduce the batching technique and the commit operation
that are widely used in the SMR literature [2, 11, 14, 31, 35, 45, 47].
Note that batching transactions into blocks is compatible with
the SMR definition in Section 2.1 where each position contains
a single transaction. Transactions within a block are totally or-
dered, so a log of blocks can be flattened into a log of transactions.
For example, suppose we have a log of blocks [ğµ0, ğµ1, . . .] with
ğµ0 = [ğ‘¡ğ‘¥0,1, ğ‘¡ğ‘¥0,2, . . . , ğ‘¡ğ‘¥0,â„“0] and ğµ1 = [ğ‘¡ğ‘¥1,1, ğ‘¡ğ‘¥1,2, . . . , ğ‘¡ğ‘¥1,â„“1]. This
can be interpreted as a log of transactions [ğ‘¡ğ‘¥0,1, ğ‘¡ğ‘¥0,2, . . . , ğ‘¡ğ‘¥0,â„“0,
ğ‘¡ğ‘¥1,1, ğ‘¡ğ‘¥1,2, . . . , ğ‘¡ğ‘¥1,â„“1, . . .]. The publicly verifiable proof for a block
serves as the publicly verifiable proof for each transaction in that
block.
When a replica commits a new block, it broadcasts a signature on
the block. With some foresight, we will adopt the recent paradigm
of chained SMR in which the last block of a log uniquely identifies
the entire log, and hence signing a block is equivalent to signing the
the entire log up to the block. Then, a set of signatures on a block
from ğ‘› âˆ’ ğ›¾ğ‘  = ğ›½ğ‘  + 1 replicas forms a publicly verifiable proof for
the log up to that block. Hereafter, when designing new protocols,
we aim at achieving the following safety and liveness properties.
(1) Safety. If two honest replicas commit two logs [ğµ0, ğµ1, ..., ğµ ğ‘—]
ğ‘—â€²], then ğµğ‘– = ğµâ€²
ğ‘– for all ğ‘– â‰¤ min( ğ‘—, ğ‘—â€²).
(2) Liveness. Every transaction is eventually committed by all
0, ğµâ€²
and [ğµâ€²
1, ..., ğµâ€²
honest replicas.
The above safety and liveness allow us to focus on replicas and
deal with clients and public verifiability easily in a single extra step.
This is sufficient for the safety and liveness for SMR defined in
Section 2.1. Simply observe that at least one honest replica must
commit a log in order for the log to have a publicly verifiable proof;
If all honest replicas commit a log, all honest replicas will obtain a
publicly verifiable proof for it.
Intuitive overview of the protocol. At a high level, we combine a
partially synchronous SMR protocol (PBFT [14]) and a synchronous
SMR protocol (Sync HotStuff [2]). These two protocols share a
similar view-by-view construction. In the steady state of each view,
a leader ğ¿ proposes a value to the next log position and replicas vote
and commit the value. When no progress is being made (possibly
because of a faulty leader), replicas replace the leader and enter the
next view using a view change procedure.