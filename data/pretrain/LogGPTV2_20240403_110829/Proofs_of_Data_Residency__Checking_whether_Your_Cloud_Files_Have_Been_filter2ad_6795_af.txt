a considerable portion of the blocks is lost, the veriﬁer can
detect this incident with overwhelming probability.
A PoR scheme is executed in a challenge-response fashion.
The veriﬁer V may issue a random challenge (which may con-
tain one or various queries) at any time, and to which the
prover P has to respond correctly to assert for its posses-
sion and the retrievability of the ﬁle. The ﬁrst construction
by Juels and Kaliski [26] has been followed by various vari-
ants [20, 38] and is also extended to the dynamic setting [37].
A similar notion known as Provable Data Possession (PDP)
is proposed by Ateniese et al. [13]. It is commonly believed
that PDP provides weaker security guarantees than PoR in
a sense that even if the prover passes the PDP audit, there
is still a non-negligible probability that the veriﬁer cannot
fully recover the original outsourced ﬁle [37].
B.2 Host Geolocation
While the notion of data residency concerns over the fact
that the data are kept intact on local drives of a storage
server, it implicitly assumes that the geographic location
of the storage server is known to the veriﬁer. Thus, also
of interest are techniques to geographically locate an on-
line party. Since machines/systems on the Internet can be
uniquely identiﬁed by IP addresses, this problem asks for a
mapping from an IP address to a geographic location.
It
would have been trivial if the IP address system was de-
signed to incorporate geographic information, unfortunately,
it was not the case. Several proposals have been presented to
address this problem [29, 24, 18]. Common among them are
observations that major backbone Internet providers usually
associate their host names with geographical clues, and that
data travelling across the Internet are often routed via these
backbone Internet providers’ nodes. Moreover, a route that
a data packet travels through can be identiﬁed using trace
engines such as Traceroute utility [11]. When matching the
intermediary computer nodes in the routing information of
a packet against those of the backbone Internet providers, a
target host (the destination of the packet in question) can
be roughly located [18]. However, this technique alone does
not oﬀer ﬁne granularity. When the packet is approaching its
destination, it will be transferred using smaller networks to
which geographical clues are not associated. At that gran-
ularity, the WHOIS servers [23] are queried to infer more
precise location of the host. Other approaches rely on a
premise that the latency in transmitting a packet between a
pair of hosts is a function of the geographical distance among
them, or a combination of partial IP-to-location and BGP
preﬁx information to derive the target host’s location [29].
B.3
Intel SGX
Intel SGX [6] is a set of extensions that provision the pro-
tected execution environments (aka trusted environments or
enclaves). The TCB of such enclaves comprises solely the
processors and the code that the enclaves’ owner places in-
side them, which is arguably minimal. Each enclave is as-
sociated with a region on physical memory, which we shall
call enclave memory. All accesses to enclave memory are
protected by the processor. In another word, code and data
loaded to the enclave cannot be disclosed or modiﬁed by the
untrusted OS or any other processes/software; any attempt
to read or write the enclave’s memory by a non-enclave code
will be blocked. On the other hand, enclave code may access
enclave memory as well as memory outside of the enclave re-
gion (if the OS permits). Originally, memory pages can only
be added to the enclave during its creation; however since
revision 2 of the SGX speciﬁcation, enclave pages can be
added via a cooperation of the enclave and the (untrusted)
OS [6] at any time during its lifetime. We note that the
enclave code has to be loaded into the enclave during its
creation.
Enclaves cannot directly execute OS-provided services
such as I/O. In order to access those services, enclaves have
to employ OCalls (calls executed by the enclave code to
transfer the control to non-enclave code) and ECalls (API
for untrusted applications to call in). These ECalls and
OCalls constitute the enclave boundary interface, enabling a
communication between the enclave code and the untrusted
application to service OS-provided functions. Care should
be taken on each and every ECall exposed to the untrusted
application, as it may open up an attack surface to the pro-
tected execution environment.
SGX enables CPU-based attestation, enabling a remote
veriﬁer to check if a speciﬁc software has been loaded within
the enclave by means of cryptography. Via such mecha-
nism, the veriﬁer can establish shared secrets with the en-
clave, thus bootstrapping an end-to-end encrypted channel
via which sensitive data can be communicated.
13
P AOC ADQ
1. The local server redirects the challenge to the three
P AOC ADQ
)
s
d
n
o
c
e
s
(
e
m
T
i
1
0.8
0.6
1.8
1.6
1.4
1.2
1
)
s
d
n
o
c
e
s
(
e
m
T
i
300
500
700
300
500
700
Audit Size (v)
Audit Size (v)
(a) Block size: 160
(b) Block size: 320
Figure 10: Response latencies incurred P, AOC and ADQ in
SW-PoR based residency checking. The error bars represent
one standard deviation.
P
AOCADQ
1
0.8
0.6
0.4
0.2
)
e
m
i
t
(
F
D
C
0
0.2 0.4 0.6 0.8 1 1.2 1.4 1.6
Time (seconds)
P
AOCADQ
)
e
m
i
t
(
F
D
C
1
0.8
0.6
0.4
0.2
0
1
1.5
2
Time (seconds)
(a) Block size: 160
(b) Block size: 320
Figure 11: CDF of the response latencies incurred by P,
AOC and ADQ in SW-PoR based residency checking.
C. VULNERABLE
CONSTRUCTIONS
AND POTENTIAL ATTACKS
We investigate an ability to evade detection of an adver-
sary A by comparing the two distributions: TP , the distri-
bution of response latencies incurred by an honest prover P,
and TA - that of the response latencies incurred by A. If the
cumulative distribution function (CDF) of TA stochastically
dominates that of TP , that is,
P r(TA ≤ t) ≥ P r(TP ≤ t) ∀t
then A could intentionally add delays so that these two dis-
tributions are identical, thus successfully evading detection.
C.1 SW-PoR based data residency checking
Protocol.
We ﬁrst consider a data residency checking
constructed on top of the PoR scheme by Shacham and
Waters (SW-PoR) [36].
In this PoR scheme, the audit
asks for v data blocks and their associated homomorphic
authentication tags. The response is aggregated from the
requested data blocks, resulting in a much smaller size. In
a SW-PoR based residency checking protocol, the veriﬁer
V measures the response latency, and accepts the prover as
passing the audit if the response is valid (with respect to
the SW-PoR scheme) and the response latency is within an
expected threshold.
Dishonest Prover. We consider two adversaries who re-
locate the data to three remote storage servers and attempt
to reduce response latency by speeding up the computation
time required to generating the response. The ﬁrst adver-
sary – denoted by AOC – over-clocks its processor in order
to evade the detection. AOC carries out the following steps
upon receiving the challenge from the veriﬁer:
remote servers.
2. The three remote servers concurrently load the data,
and send them to the local server.
3. The local server over-clocks its processor to aggregate
the data.
The second adversary – denoted by ADQ – parallelises the
aggregation in the following steps:
1. The local server redirects the challenge to the three
remote servers.
2. The three remote servers concurrently load the data,
aggregate them and send the intermediate results to
the local server.
3. The local server aggregates the received intermediate
results.
We conduct experimental studies to inspect the response
latencies of the honest prover in comparison with those of
the two adversaries. In these experiments, provers compute
the responses using a vCPU Intel Xeon Family running at
base clock speed of 2.5GHz, except for AOC who over-clocks
its processor, running at Turbo Boost speed of 3.3GHz.
Empirical results. We vary the block size (number of group
elements in each data block) as well as the number of data
blocks requested (i.e., audit size) in each challenge. We ob-
serve that the response latencies of the three provers gen-
erally follow normal distributions, each with diﬀerent mean
and standard deviation. We depict these distributions in
Figure 10 by showing their means and standard deviations.
To give a better intuition on the adversaries’ ability to evade
latency measurements, we show in Figure 11 CDFs of their
response latencies in experiments where audit size are 700
blocks, with block size of 160 and 320 group elements. As
can be seen from the ﬁgure, the CDFs of ADQ’s latency
measurements stochastically dominate those of the honest
prover. Hence, ADQ can evade the detection by intention-
ally introducing delays to the response times. Although the
CDFs of AOC ’s latency measurements do not stochastically
dominate P’s, they are similar and thus it requires challenges
of signiﬁcant size in order to detect AOC ’s violation of the
SLA.
C.2
Protocol. One possible mitigation for the previous attack
is to adopt a PoR scheme in which the prover performs
virtually no computation in executing the residency check-
ing, such as the authenticator-based PoR [26, 28]. In this
scheme, the data owner pre-processes the ﬁle F using an
error-erasure code to create (cid:101)F , partitions (cid:101)F into m blocks,
JK-PoR based residency checking
and appends a MAC under secret key sk to each of them
before outsourcing them to the storage server. During the
residency checking, the veriﬁer issues a single request that
asks for v (cid:28) m randomly chosen data blocks (the value of
v is determined by the security setting of the scheme) and
measures the latency incurred by the storage provider in
delivering all those requested blocks.
Although it is no longer possible to
Dishonest Prover.
speedup the response latency by over-clocking its processor
or employing parallelism, a dishonest storage provider can
still reduce the latency by distributing the fetching of the
14
P A
3.5
3
2.5
2
1.5
)
s
d
n
o
c
e
s
(
e
m
T
i
P A
)
s
d
n
o
c
e
s
(
e
m
T
i
4
3.5
3
2.5
2
1.5
80
120
160
80
120
160
Audit Size (v)
Audit Size (v)
(a) 512-byte block
(b) 1024-bytes block
Figure 12: Response latencies incurred by P and A in in
JK-PoR based residency checking. The error bars represent
one standard deviation.
)
e
m
i
t
(
F
D
C
1
0.8
0.6
0.4
0.2
0
P
A
2.5
3
3.5
4
Time (seconds)
)
e
m
i
t
(
F
D
C
0.8
0.6
0.4
0.2
0
P
A
3
3.5
4
Time (seconds)
(a) 512-bytes block
(b) 1024-bytes block
Figure 13: CDF of the response latencies incurred by P and
A in JK-PoR based residency checking.
requested blocks. With suﬃcient number of remote storage
servers, the reduction of fetching time can oﬀset the addi-
tional latency incurred by accessing the remote storage.
We empirically study the eﬀectiveness of the dishonest
prover. In our experiments, the honest prover P follows the
protocol and keeps the user’s data in its own local drives,
while the dishonest prover A distributes the data blocks to
ﬁve diﬀerent remote servers8, and pulls data blocks from
these servers in parallel to the local server upon requested.
Each data block is appended with a 160-bit MAC. The
storage servers are equipped with commodity storage hard-
ware whose read latency ranges from 12 to 15ms on average.
Empirical results. We vary the number of blocks requested
in each audit from 80 to 160, as well as the block size (512
and 1024 bytes), and observe that the response latencies of
P and A generally follow normal distributions, each with
diﬀerent mean and standard variation. We show the means
and standard deviations of these distributions in Figure 12.
We also depict in Figure 13 their CDFs for audits of size
160 blocks. When the block size is 1024 bytes, although
we do not have stochastic dominances, the two CDFs are
similar. With block size of 512 bytes, the CDF of A’s s
latency measurements stochastically dominates that of P,
implying it can always evade the detection.
8Average round-trip time of transmitting a 64-byte packet
between A and these servers is 6.5m.
15