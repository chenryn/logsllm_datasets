result
return NULL;
PyErr
arg
PyEval_Callobject(func)arg)
*kw)
Pyobjeet_call（fune,arg,kw）;
Setstr
ing(RyExc_TypeErnor,
Python源码剖析
"keyword list must be a
14.1import前奏曲
一深度探索动态语言核心技术
”符号，正对应
345
---
## Page 376
Python源码剖析
346
的类型对象是什么呢？正是PycFunction_Type:
目标，备足粮草，开始真枪实弹地进行mport动作了。
制的操作手被我们找到了，Python从接收到import的指令开始，到现在，才真正地找准
这个函数指针所指向的函数—builtin
函数指针。然后，Python虚拟机直接利用之前创建的那个PyTupleObject对象arg调用
所维护的那个函数指针一
代码清单14-2
就沿着它给我们指示的PyCFuncton_Cal函数，
于Python虚拟机而言，这个ryCFunctionobject对象确实是一个可调用的对象，好，
Pyobject*
[methodobject.o]
EyTypeobrect
[methodobject.c]
第14章Python模块的动态加载机制
我们刚才提到，这个una对象实际上是一个PyCFuncEionobject对象，那么它对应
return NULL;
PyErr_Format(PyExc_TypeError,
case
case
case
Byobject
PyCFunctionobjectf=
"builcin_funetion_or_method",
PyObject_HEAD_INIT(&PyType_TyDe)
return (·（PyCFunctionwithkeywords)meth)(self,arg,kw）；
break;
口11:
METH_OLDARGS
METH_VARARGS
METH_VARARGS:
一深度探索动态语言核心技术
PycFunetion_Cal1(Pyobject *func;Pyobjaet arg,Pyobject kw)
return （*meth)(self, arg);
数调用
*self
>mmi->mi_name);
meth，这个指针也就是指向C函数builtin
PyDict_Size（kw）==0)
MEIH_KEYWORDS
METH_KEYWORDS:
(PycFunctionobject*)func;
*tncal1*
"%.200s() takes no keyword arguments",
import。到了这里，真正实现import 机
一路追踪下去（见代码清单14-2）。
import
那
2
---
## Page 377
14.2.1.1
14.2.1
14.2
中的import机制进行黑盒探测。所谓黑盒探测，指的是我们将通过各种不同的impor动
module和package的基础之上构建软件，这样不仅使得软件的架构清晰，而且也能很好地
和稍后会挖掘的package机制来实现对系统复杂度的分解，以及保护名字空间不受污染。
码。为了更好地理解Pyhon的import机制，请在阅读时对照参考Pyhon源代码。
们对import机制的黑盒探测也从sysmodale开始。
作观察Python在动态加载module或package时会进行什么样的动作，以及将对执行环境
如果考虑的只是importsys这样的语法，则会删节处理importxml.sax这样语法的代
importsys这样的语法，也会处理importxml，sax这样的语法，那我们在展示代码时，
能简洁，在展示代码时，我们可能会对代码进行一些删节，比如一个函数中可能会处理
我们将一
而用户module中又分Python语言写的module和C语言写的以dn形式存在的module。
探测
产生什么样的影响。
实现代码复用。
irpont sys
import
from sys
Python中import机制的黑盒探测
在Pyton中，module和package通过import机制融入Python，本节中，我们将对Python
从import的目标来说，可以有系统的standardmodule，还有用户自已写的module，
在本节中，我们并不涉及Pyhon中的import机制是如何实现的，而是通过这样的黑
对于Python用户，sysmodule恐怕是一个非常熟悉也使用得非常频繁的module，我
通过module和package，我们可以将某个功能、某种抽象进行独立的实现和维护，在
我们知道，在Python中，从语法层面讲，import有很多种写法，比如：
同Java中的package机制、C++中的namespace机制一样，Pyhon通过module机制
Python内建Module
标准import
sys
useimodule
也就是源码分析
一介绍各种语法，各种目标module背景下Python的import动作。考虑到尽可
imp
OLE
path as mypath
Dath
一打下坚实的基础。
14.2Python中import机制的黑盒探测
Python源码剖析
深度探索动态语言核心技术
347
---
## Page 378
348
Python源码剖析
何将存放在sys.modules中的os引入到1ocal名字空间中。
我需要将这个符号引入到1ocal名字空间中，以便我的程序使用这个符号背后的对象。
在初始化时，就将sysmoduie加载到了内存中，实际上，Python是将一大批的module
名字空间成为可见的，而引用该module的方法正式通过module的名字，即这里的“sys”。
显然，Python中的import机制影响了当前1ocal名字空间，使得加载的module在1ocal
import动作对当前名字空间的影响，如图14-2所示。
有参数，则会将参数视为对象，输出该对象的所有属性。我们的第一个探测就是看一看
执行dir操作时，如果没有参数，则会打印出当前的1ocal名字空间的所有符号，而如果
些符号暴露在当前的1ocal名字空间中，而是需要用户显式地通过import机制通知Python：
加载到了内存中。但是为了使local名字空间能够达到最干净的效果，Pyhon并没有将这
import机制的终极法宝。如果你在Python的交互式环境下键入help（air），你会看到在
上隐藏着一个module对象，在Python内部，实际上就是一个PyModuleObject对象。很
个“sys”的符号，而且通过type操作，我们发现，在这个“sys”的符号背后，实际
这些预先被加载进内存的module存放在sys.modules中，下面的图143展示了我们如
第14章Python模块的动态加载机制
细心的读者一定还记得在之前对Python运行环境初始化的分析中，我们发现Python
在对Python运行环境的初始化的分析中，我们看到了air，这个小工具是我们探测
11474832
147
一深度探索动态语言核心技术
tandom,)
id(sys.modules[os])
show modules()
dir()
nt.os.
图14-2引入sysmodule对名字空间的影响
>>
nodulesQ：
die0)
In gys.modules.items():
图14-3探索对osmodule的加载
doc
nane
os,showmodules',sys]
aya
---
## Page 379
14.2.1.2
dl1文件，只以py文件作为例子。我们准备一个简单的module
机制的框架性黑盒探测，并不探讨import机制的实现，所以这里我们并不区分py文件和
Python的扩展module，这些都不是Python的内建modulea因为我们在这一节只是做import
Python中，用户可以通过py文件创建自己的module，也可以通过C语言创建dl，生成
已经在Python初始化阶段被加载到sys.modules集合中的osmodule。
两个不同的id操作中可以看到，毫无疑问，Python虚拟机的import动作引入的正是事先
对heliomodule的import动作将对Python产生怎样的影响。
的内建module。通过import机制，这个module被引入到了当前的1ocal名字空间中。从
地。更进一步，从两个id（）操作的结果看来，local名字空间中的符号“nello”和
local名字空间中，而且这个被动态加载的module也在sys.modules中拥有了一席容身之
Python对hellomoaule进行import操作的结果不仅将hel1omodule引入到了当前的
[hello.py]
13861136
>>containHello()
>>>defcontainHello():
13861136
alse
=2
在这个简单的module中，我们仅仅创建了两个符号，a和b图144显示了Python
接下来，我们看一看当Python对非内建的module进行import时所发生的动作，在
可以看到，osmodule是从C:Python25liblos.pyc这个文件中引入的，它是一个Python
探索“hello”这个符号背后隐藏的这个PyModuleObject对象也非常地有意义，图
操作type(）的结果显示，
id(sys.modules[hello*])
type(hello)
diE(）
containHello()
import hello
inpott sys
用户自定义Module
ceturn
_doc_，
图14-4
import机制确实创建了一个新的module。而令人惊奇的是
name
探索对hellomodule的加载
14.2Python中import机制的黑盒探测
Python源码剖析
As,OTTey,OTTHuTeuO,
一深度探索动态语言核心技术
hello.py:
349
---
## Page 380
Python源码剖析
350
的名字和值之间的关系，既然1ocal名字空间中的“
赋予它们，徒增迷惑？刚才我们提到，在module中，实际上是通过一个dict在维护属性
另一个是dict对象，从两者的i也可看出，它们两个完全没有关系。
这两个符号有什么关系呢？图14-6展示了我们对这个疑问的探测。
初始化完成之后，我们敲入dir（），显示的结果中同样有一个“
的过程中，对hello.py暗中下了手，生成了hello.py的编译结果hello.pyC。
hello.py文件经过Pyhon编译后存储编译结果的hello.pyc文件，由此可见，Python在import
的名字，module所容身的文件名。
我们也能清楚地看到这一点，在module内部，有一些关于module的元信息，比如module
对，说白了，同class一样，module又是一个名字空间。从PyModuleobject结构的定义
14-5展示了对hello内部的探测。
11286544
11279856
>
[a'
"diet'>
print hello.
builtins
dir（hello)
图14-6module中的_builtins_与local名字空间中的builtins
builtins_)
一深度探索动态语言核心技术
"b*
虽然名字完全一样，但却是完全不同的家伙，
builtins
builtins
doc
图14-5探测hellomodule的内部信息
file
diet
doc
keys()
builtins
"containHello',
builtins_"符号对应一个module
”和hellomodule中的
一个是module对象，而
builtins
，a，'b']
”符号，
---
## Page 381
14.2.2
被Python预先加载进内存中的module一样，维护在sys.modules中。
嗯，我们来探测一下，如图147所示。
对象，而hellomodule中的“
中看到的那个_builtin_module及它所维护的aict，这个_bui化tinmodule和其他
它们两个都只是表象，它们背后的真身实际上就是我们在对Pyton运行环境初始化分析
是当前名字空间中_bui1tins_符号对应的module对象所维护的那个dict对象，而其实
对usermodulel进行import动作，以推倒第一块多米诺骨牌。加载后的结果如图148所
usermodule2.py中，我们又一次激活了import机制，加载sysmodule。首先，我们需要
会发生什么有趣的事情：
import动作。所谓嵌套的import动作，即是指当Python在执行“import A”时，在A
mport sys
[usermodule2.py]
上面我们研究了对于单个独立的module的import动作，下面我们来探索一下嵌套的
嵌套import
从图14-7中我们发现，果然，hellomodule中的_builtins_符号对应的aict正
dir(usermodulel.usermodule2)
builtina
dir()
builting
dir(）
图14-7
builtins
builtins
module中的_builtins_与local名字空间中的_builtins_间的联系
11286544
11286544
>>>id(
11286544
id(ays.modules[_builtin
图14-8在module中嵌套import操作
builtins_.
doc
doc
doc
“builtins_”符号对应一个dict 对象，有没有可能…
14.2Python中import机制的黑盒探测
file
dict_)
Python源码剖析
usermodule1']
name
name