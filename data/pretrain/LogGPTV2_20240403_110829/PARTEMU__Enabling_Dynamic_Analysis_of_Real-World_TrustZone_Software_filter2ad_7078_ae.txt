shared memory by design, whereas QSEE does not. This issue
did not apply to either OP-TEE or TEEGRIS because they
mapped shared memory buffers at a random virtual address,
and because the GlobalPlatform TEE Client API they imple-
ment do not provide for shared memory pointers between the
CA and TA.
Unvalidated Types. The GlobalPlatform TEE Client
API [20], however, required a different check that was miss-
ing in some TAs. This API allows CAs to specify the type
800    29th USENIX Security Symposium
USENIX Association
and content of four arguments for a command to a TA. The
type can broadly be either a value or a buffer. We found that
some TAs using these APIs implicitly assumed the types of
arguments sent by the CAs. Thus, they interpreted a buffer
address as a value, or worse yet, dereferenced a value. This re-
sults in vulnerabilities similar to those caused by unvalidated
pointers from the normal world. We found instances of these
that resulted in both conﬁdentiality and integrity compromise.
9.2.1 Reproducibility and False Positives
We classify a TA crash as a false positive if it is not repro-
ducible on a device. The general cause for false positives is a
lack of ﬁdelity in emulation of hardware or software compo-
nents that TA interacts with. The only software component
the TA interacts with is the TZOS, but this is unlikely to be
a source of false positives since we reuse the original TZOS
binary. Therefore, the most likely cause for false positives is
insufﬁcient hardware emulation. However, we found that only
a few TAs interact with hardware and usually do not crash
even if such hardware is unavailable, and thus PARTEMU’s
results have a high chance of being reproducible.
Our results are consistent with this intuition. We had de-
vices corresponding to 24 out of the 48 unique crashes we
found, and we were able to reproduce all 24 crashes on these
devices. This included two TAs that accessed specialized hard-
ware that we did not emulate. Out of the remaining crashes,
only three other TAs accessed specialized hardware. If we
conservatively assume that these three crashes are false pos-
itives, PARTEMU would have a true positive rate of 45/48
(93%), which we believe is sufﬁciently high to be useful.
9.3 Use Case: Fuzz Testing TZOS
Our second target for fuzz testing was the SMC API exported
by the TZOS. We performed SMC API tests on one of our four
target TZOSes - QSEE v4.0. Our aim was not to compare the
security of TZOSes, but to show the utility of PARTEMU for
TZOS testing: the reason we chose QSEE was because of
its relatively simple and synchronous SMC calling conven-
tion [37]. In general, the normal world OS calls SMCs to
request services from the secure monitor, TZOS, or TAs. This
API is similar to the system call API: the caller speciﬁes an
SMC number and several arguments in registers.
The TZOS should protect itself from a compromised nor-
mal world that issues arbitrary SMCs. Consistent with this
threat model, we used normal world driver programs to fuzz
test the QSEE SMC API. The driver program gets the fuzz
testing input from AFL, transforms these into SMC argu-
ments, and sends the SMC. Crashes are detected if QEMU
raises an abort. An additional challenge with APIs is that
argument types can either be values or buffers. We use a part
of the AFL input to determine argument types.
In total, AFL identiﬁed 124 distinct SMCs, and found
crashes in 3 SMCs. These crashes only affected TZOS avail-
ability, and thus have limited security impact. However, in-
terestingly, all these crashes tested QSEE code paths that
would not normally be exercised on a real device, but those
that could be triggered by an attacker who compromises the
normal world. We discuss two cases below.
Normal-World Checks. One crash we found in QSEE that
was independently ﬁxed was an invalid pointer dereference
triggered when the normal world requested the TZOS to load
a TA that was already loaded. Interestingly, we found that
this particular QSEE path was “shielded” by normal-world
checks: QSEE’s Linux kernel TEE driver [37], before sending
a request to QSEE to load a TA, checked with QSEE if the
TA was already loaded. If it was, the TEE driver did not send
a request to load the TA at all. An attacker who compromises
the Linux kernel itself, however, would not be restricted by
this check, and could trigger this code path.
Assumptions of Normal-World Call Sequence. Another
crash we found in QSEE was an uninitialized pointer derefer-
ence. This pointer was initialized by another SMC call that
the Linux kernel on the device normally issued during boot.
However, a compromised normal world would skip this SMC
altogether, thus triggering this vulnerability. On a device, such
a condition would normally not be triggered because the ini-
tialization would already have happened during boot.
10 Related Work
Closely related to our work are approaches that attempt to
run real-world software in an emulator for dynamic analy-
sis. Avatar [59], PROSPECT [28], Charm [49], and Surro-
gates [31] all attempt to enable dynamic analysis by running
the target in a virtualized or emulated environment and for-
warding accesses to real hardware. While Avatar, PROSPECT,
and Surrogates target embedded device ﬁrmware, Charm tar-
gets Linux kernel device drivers running on mobile systems
such as Android. These approaches work when the hardware
exposes ways to interact with it, such as JTAG serial port,
or USB. However, as we have seen, neither does TrustZone
hardware exposes such interfaces, nor is it possible to run a
software proxy for such hardware access in the TrustZone
because of code signing.
Other approaches such as Costin et al. [15] and FIRMA-
DYNE [11] attempt to emulate hardware to test embedded
ﬁrmware. Hardware emulation was possible in these cases
because the hardware was well-documented or standard. We
study how to emulate the hardware required to run real-world
TrustZone OSes, which is often non-standard and without
documentation. Further, we show that it is possible to skip
emulation of extremely complicated hardware by emulating
other software components instead.
Firmware re-hosting [23] is the process of migrating
ﬁrmware from its original hardware environment into a virtual
environment. Pretender [23] attempts automated ﬁrmware
USENIX Association
29th USENIX Security Symposium    801
re-hosting by generating hardware models using machine
learning on runtime traces. P2IM [19] uses manually-deﬁned
hardware register patterns and generates hardware models
automatically on-the-ﬂy by ﬁtting different registers to these
patterns at runtime. While these systems were tested on mi-
crocontrollers that are much simpler than our environment,
they show the potential for automation of much of our work.
Concurrently with our work, Komaromy developed
TEEMU [30], an emulator to run TAs for <t-base, an older
version of the Kinibi TZOS. In contrast to our work, TEEMU
does not re-host the <t-base TZOS itself. Instead, TEEMU
emulates the TZOS by manually re-implementing speciﬁc
<t-base system calls. This limits TEEMU to testing <t-base
TAs that use only those system calls, and does not allow
testing the <t-base TZOS itself. Furthermore, reproducibil-
ity is dependent on the ﬁdelity of re-implementation of the
TZOS system calls. Similar limitations apply to the Open-
TEE [33, 35] project, which is a virtual TZOS implementing
the GlobalPlatform TEE API [21]. In contrast, PARTEMU sup-
ports full-system emulation by re-hosting unmodiﬁed TA and
TZOS binaries, allowing holistic testing of TrustZone and
making it signiﬁcantly more likely that any issues found are
reproducible on a real device.
PARTEMU enables using advances in dynamic analysis
on real-world TrustZone software. Thus far, the main tech-
nique to analyze real-world TrustZone software has been
static binary reverse-engineering of TAs and the TZOS [7, 8].
Dynamic analysis for TrustZone software has been limited to
blind fuzzing [6] and emulation of particular parts of Trust-
Zone [30]. PARTEMU enables dynamic analysis techniques
such as feedback-driven fuzz testing [9, 12, 40, 61], symbolic
and concolic execution [10, 13, 48], taint analysis [14, 17, 58],
and debugging for real-world TrustZone software.
11 Discussion and Future Work
Dealing with Stateful TAs. On a random sample of 10 TAs,
AFL had basic-block coverage varying from 0.2% to 45.6%
with a median of 17.7%. We found that a major limiting fac-
tor for coverage was TA state: we noticed that several TAs
had internal ﬁnite state machines and therefore required a
sequence of multiple inputs to drive them to interesting states
(e.g., connected, authorized, processing). Our driver currently
sends a single message to a newly forked TA instance each
time so that AFL does not have issues with stability (Sec-
tion 8.1). Therefore, we cannot get past state checks, which
require a sequence of inputs. We plan to handle TA state in
future work. Even with such limited coverage, however, as
we have seen, PARTEMU was able to ﬁnd several non-trivial
real-world vulnerabilities.
Hardware Roots of Trust. PARTEMU does not emulate
hardware roots of trust. An example is the factory-installed
per-device private key signed by the Samsung CA [42] and
used for remote attestation. Thus, code paths in TAs that
depend on remote attestation succeeding may not work. For
example, Samsung Pay uses remote attestation for credit card
enrollment; we cannot successfully enroll a credit card using
a Samsung Pay TA [44] running on PARTEMU because we do
not have access to the attestation key that would be present on
a real device. While such TAs that depend on a valid root of
trust require other techniques to test, they are few in number,
and PARTEMU is able to test the vast majority of TAs.
Performance. Since we ran PARTEMU on an x86 machine,
we could not take advantage of ARMv8 hardware virtualiza-
tion [16]. AFL ran at around 10-25 executions per second
for QSEE, OP-TEE, and TEEGRIS, while our performance
optimizations for Kinibi (Section 8.3) enabled 125 executions
per second. While even this was sufﬁcient to ﬁnd several
non-trivial vulnerabilities, we believe PARTEMU would be
even more useful if it could run faster. To this end, we plan to
explore running PARTEMU directly on ARMv8 hardware.
12 Conclusion
In this work, we addressed the problem of the lack of dy-
namic analysis for real-world TrustZone software by building
an emulator that runs four widespread, real-world, TZOSes -
QSEE, Kinibi, TEEGRIS, and OP-TEE. We studied the soft-
ware and hardware emulation effort required to run these
TZOSes. We found that emulating the required hardware and
software dependencies was feasible. We implemented our
emulation on PARTEMU, enabling dynamic analysis of real-
world TZOSes. We showed PARTEMU’s utility by ﬁnding
48 previously-unknown vulnerabilities across 194 TAs from
12 different Android smartphone vendors and an IoT ven-
dor. We identiﬁed patterns of developer mistakes unique to
TrustZone development that cause some of these vulnerabili-
ties, highlighting the need for TrustZone-speciﬁc developer
education. This work shows that dynamic analysis of real-
world TrustZone software using emulation is both feasible
and beneﬁcial.
Disclosure
We have notiﬁed each vendor of any relevant ﬁndings and are
working with their security teams to address the issues.
13 Acknowledgements
We thank Stephen McLaughlin for automating parts of our
analysis and interpreting results. We thank our anonymous re-
viewers for their suggestions that helped signiﬁcantly improve
the presentation and scope of this work. We thank Peng Ning,
Kunal Patel, Laurent Simon, Luke Deshotels, and Stephen
McLaughlin for helpful discussions and suggestions during
various stages of this work.
802    29th USENIX Security Symposium
USENIX Association
References
[1] Apple.
iOS Security.
https://www.apple.com/
business/site/docs/iOS_Security_Guide.pdf.
[2] ARM. ARM TrustZone.
http://www.arm.com/
products/processors/technologies/trustzone/
index.php.
[3] J. S. S. T. Association.
Embedded Multimedia
Card eMMC. http://www.jedec.org/standards-
documents/results/JESD84-A.
[4] A. M. Azab, P. Ning, J. Shah, Q. Chen, R. Bhutkar,
G. Ganesh, J. Ma, and W. Shen. Hypervision across
worlds: Real-time kernel protection from the arm trust-
zone secure world. In Proceedings of the 2014 ACM
SIGSAC Conference on Computer and Communications
Security, 2014.
[5] F. Bellard. QEMU, a Fast and Portable Dynamic Trans-
In Proceedings of the Annual Conference on
lator.
USENIX Annual Technical Conference, 2005.
[6] G. Beniamini.
FuzzZone.
https://github.
com/laginimaineb/fuzz_zone/tree/master/
FuzzZone.
[7] G. Beniamini. TrustZone Kernel Privilege Escalation.
http://bits-please.blogspot.com/2016/06/
trustzone-kernel-privilege-escalation.html.
[8] D. Berard. Kinibi TEE: Trusted Application ex-
https://www.synacktiv.com/posts/
ploitation.
exploit/kinibi-tee-trusted-application-
exploitation.html.
[9] M. Böhme, V.-T. Pham, and A. Roychoudhury.
Coverage-based greybox fuzzing as markov chain. In
Proceedings of the 2016 ACM SIGSAC Conference on
Computer and Communications Security, 2016.
[10] C. Cadar, D. Dunbar, and D. Engler. Klee: Unassisted
and automatic generation of high-coverage tests for
complex systems programs. In Proceedings of the 8th
USENIX Conference on Operating Systems Design and
Implementation, 2008.
[11] D. D. Chen, M. Woo, D. Brumley, and M. Egele. To-
wards automated dynamic analysis for linux-based em-
bedded ﬁrmware. In NDSS, 2016.
[12] P. Chen and H. Chen. Angora: Efﬁcient Fuzzing by
Principled Search. In 2018 IEEE Symposium on Security
and Privacy (SP), 2018.
[13] V. Chipounov, V. Kuznetsov, and G. Candea. S2e: A
platform for in-vivo multi-path analysis of software sys-
In Proceedings of the Sixteenth International
tems.
Conference on Architectural Support for Programming
Languages and Operating Systems, 2011.
[14] J. Clause, W. Li, and A. Orso. Dytan: A generic dy-
namic taint analysis framework. In Proceedings of the
2007 International Symposium on Software Testing and
Analysis, 2007.
[15] A. Costin, A. Zarras, and A. Francillon. Automated
dynamic ﬁrmware analysis at scale: A case study on em-
bedded web interfaces. In Proceedings of the 11th ACM
on Asia Conference on Computer and Communications
Security, 2016.
[16] C. Dall and J. Nieh. Kvm/arm: The design and imple-
mentation of the linux arm hypervisor. In In Proceedings
of the 19th International Conference on Architectural
Support for Programming Languages and Operating
Systems, 2014.
[17] B. Dolan-Gavitt, J. Hodosh, P. Hulin, T. Leek, and
R. Whelan. Repeatable Reverse Engineering with
PANDA. In Proceedings of the 5th Program Protection
and Reverse Engineering Workshop, PPREW, 2015.
[18] J.-E. Ekberg.
Trusted Execution Environments
https://usmile.at/sites/
(and Android).
default/files/androidsecuritysymposium/
presentations2015/Ekberg_
AndroidAndTrustedExecutionEnvironments.pdf.
[19] B. Feng, A. Mera, and L. Lu. P2IM: Scalable and
hardware-independent ﬁrmware testing via automatic
peripheral interface modeling. In Proceedings of the
29th USENIX Security Symposium, 2020.
[20] GlobalPlatform.
TEE Client API Speciﬁcation
https://globalplatform.org/specs-
v1.0.
library/tee-client-api-specification/.
[21] GlobalPlatform.
TEE Internal Core API Spec-
https://globalplatform.
v1.2.1.
iﬁcation
org/specs-library/tee-internal-core-api-
specification/.
[22] I. GlobalPlatform. GP TEE Certiﬁcate: TEEgris 2.5
on MT6737T. https://globalplatform.org/wp-
content/uploads/2018/03/GP-TEE-2017_01_
Certificate_MediaTek_GP170002_20171027_Gil.
pdf.
[23] E. Gustafson, M. Muench, C. Spensky, N. Redini,
A. Machiry, Y. Fratantonio, D. Balzarotti, A. Francil-
lon, Y. R. Choe, C. Kruegel, and G. Vigna. Toward the
analysis of embedded ﬁrmware through automated re-
hosting. In 22nd International Symposium on Research
in Attacks, Intrusions and Defenses (RAID 2019), 2019.
USENIX Association
29th USENIX Security Symposium    803
[24] J. Hertz and T. Newsham. AFL/QEMU fuzzing with full-
system emulation. https://github.com/nccgroup/
TriforceAFL.
[38] Qualcomm. Qualcomm Security for Mobile Com-
https://www.qualcomm.com/solutions/
puting.
mobile-computing/features/security.
[25] IETF.
The Open Trust Protocol
(OTrP).
[39] Qualcomm. Secure Boot and Image Authentication.
https://www.ietf.org/archive/id/draft-
pei-opentrustprotocol-06.txt.
[26] JEDEC.
e.MMC v5.1A.
https://www.jedec.
org/standards-documents/technology-focus-
areas/flash-memory-ssds-ufs-emmc/e-mmc.
[27] JEDEC.
Universal Flash Storage (UFS) 3.0.
https://www.jedec.org/standards-documents/
focus/flash/universal-flash-storage-ufs.
[28] M. Kammerstetter, C. Platzer, and W. Kastner. Prospect:
peripheral proxying supported embedded code testing.
In 9th ACM Symposium on Information, Computer and
Communications Security, ASIA CCS ’14, Kyoto, Japan
- June 03 - 06, 2014, 2014.
https://www.qualcomm.com/media/documents/