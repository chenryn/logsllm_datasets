stmia sp1, (r4, 1r)
 Store link register and callee-saved r4 on stack
bl subroutine
 Cal1 subroutine, trashing 1ink register
1dmia sp1, (r4, 1x)
 Return to calling code
 Load original 1ink register and r4 from stack
bx 1r
Thumb指令使用了一些特殊的push和pop指令，来隐式地操作SP寄存器（栈顶指针），
而不是显式地进行引用。Thumb还有一个特殊的扩展，pop指令会引用PC寄存器来处理写人，
类似于bx1r指令。这种方法使得一条指令就能触发Intcrworking，如下列代码所示。
●Thumb指令调用子函数
push (1r)
 Store link register on stack
bl subroutine
# Call subroutine, trashing link register
pop (pe)
 =
 Load original link register and return to calling code
Thumb指令pop{pc）非常类似x86的ret指令，它会从栈上取出地址继续执行。最大区别
在于pop指令可以作为函数的整个结尾（epilogue），除了PC寄存器之外，还可以在一条指令中
还原其他寄存器的值。Thumb的leafroutine也可以用bxlr指令结尾，当然，lr中必须存有正
确的值。
9.2.2将gadget组成ROP链
记住，你的目标是使用现有的代码序列来组合成攻击载荷。如果攻击者能够控制栈，任何以
bxlr或者pop（-，pc）结尾的指令都可以作为gadget，来让攻击者保持对程序计数器的控制。
---
## Page 249
9.2ARM采构下的ROP基础
233
感谢Interworking 机制，ARM和 Thumb gadget 可以任意地进行混合。唯一的例外是，少数 gadget
会以 ARM模式的 mov pc，1r 结尾，这种gadget 只能拼接ARM模式的 gadget，因为这种方式
不支持Interworking机制。
使用1dmiasp1，（，1r)从栈数据还原1r，然后bx 1r，或者仅仅使用pop（，pc)，
对这两种gadget进行组合是非常直接的方式。因为1r是从栈上取得的下一个地址，这个地址可
以通过栈来提供。除了gadget地址外，函数结尾时需要还原的寄存器值也需要在栈上提供（即使
在ROP的载荷中并没有用到它们），因为这样才能在执行下一个gadget的时候，让栈顶指针对准
这个位置。如果下一个gadget使用Thumb指令，要记得将地址最低比特设置成1，来通知处理
器切换到Thumb模式。即便处理器已经处于Thumb模式，也需要这样做；否则，如果地址最低
比特为0的话，它会假设调用的函数是ARM模式，处理器就会切换到ARM模式。
以图9-4为例，假设你可以利用栈溢出漏洞往栈上写任何想要的数据（包括nul），程序即将
执行pop（pc）指令。在开启了堆栈不可执行保护的情况下，你通过调用mprotect函数将栈设
置为可执行来利用这个漏洞，然后原地执行你的原生代码。这种情况下，写人栈的载荷会如图
9-4所示。
gadget
栈
b00038eb
pop(r0-24,pc}
r0
r1
r2
r3
r4
pc=b000. .
图9-4简单的 POP-ROP链
那些叶节点的gadget，即以bx1r结尾而前面没有恢复LR寄存器的指令，需要在执行之前
对LR寄存器值进行特殊处理。通常，1r中包含的值所指向的gadget，是从最后一个显式恢复
LR寄存器的 ARM gadget中得到的（因为 ARM gadget 从栈恢复1r，且把它作为下一个 gadget
的地址）。如果一个函数调用了一个子函数，那么1r指向了子函数调用处后面的地址，这会带
来非预期的行为。当另外一个以 bx1r结尾的 gadget被执行，程序就会跳转到上面所说的子函
数中，而不是下一个预期的gadget。如果1r能够指向一个先前所用过的gadget，并且这个gadget
没有任何破坏副作用，这可以很容易地通过在栈上放置所需的地址来实现。但是如果1r指向了
一个大程序或者一个不能被执行第二遍的gadget，1r的值就必须调整。找一个恢复1r的ARM
gadget，加上一个以pop（pc）指令结尾的Thumb gadget，就可以解决这个间题，如图9-5所示。
---
## Page 250
234第9章ROP漏洞利用技术
ARM gadget会把下一个 gadget的地址加载到1r中，并从那开始继续执行；下列的Thumb
gadget仅仅跳转到下一个 gadget。这样，1r 就指向了一个 Thumb gadget来实现gadget的无缝连
接、任何以bx1r结尾的gadget均可被安全地执行。现在我们能够使用任意函数返回指令为结
尾的指令序列 gadget。
寄存器
galget
栈
b000133c
pop [x0,
1x}
c = ox
1
bx 1r
1r = b0002ab0
b0002abo
pc - 777
pop (pe)
图9-5设置 1r 指向 pop(pc)
9.2.3识别潜在的gadget
由于ARM指令是对齐的，所以只能使用有意生成的代码作为gadget。这和x86架构的复杂
指令集（CISC）有区别。在x86中，返回指令只有一字节，所以很有可能跳转到一些长指令的
中间，其中恰巧包含一个与返回指令相似的字节。这种特性使得x86架构拥有更多gadget。
在精简指令集（RISC）平台上去寻找可用的gadget是非常容易的。对于对齐的指令来说，
只需要在二进制文件中搜索能够返回的指令，例如pop（，pc），之后在反汇编列表（dead
listing）中检查这些返回指令之前的指令即可。因此，我们可以首先创建一个ARM和Thumb
的反汇编列表，然后用正则表达式进行解析。用这种方法寻找gadget非常容易。本章编写了一
个脚本来创建ROP链。
与在x86下跳转到长指令中间开始执行类似，在ARM下也有一个技巧：ARM模式和Thumb
模式是可以自由切换的，可以把已有的ARM指令当作Thumb指令来执行，反之亦然。虽然这种
技巧不会带来多于2条指令的gadgct，但是ARM指令中的2字节往往能够提供pop（-，pc）
这种非常有用的Thumb指令。这些指令通常能够从上还原一些普通函数结尾中不会出现的寄
存器，例如需要调用者来保存的r0~r3，甚至栈顶指针。Thumb和ARM指令的分解示例如图9-6
所示。
另外，异常处理和进程初始化过程的代码中可能会存在大量有用的gadget。这些指令都是用
汇编来实现的，专门用来处理底层架构相关的组件。C库、动态链接器中会出现这样的gadget，
下一节中我们就将介绍。
---
## Page 251
9.3案例分析：Android4.0.1链接器
235
Idclt 0,cr6[pe,J-100]
h条件
“指令
标志
pc
?
害
1011
110(1)
000
1111
ARM
Thumt
A-0
0×1f
6[×0 09×0
1011
110
1
000
11111
Thumb“pop”
不选取{r5-r7
r0-c4
[d’-]dod
图9-6从ARM指令中分解出的Thumb pop指令
9.3案例分析：Android4.0.1链接器
由于Android中的大多数进程都是从Zygote进程fork面来的，所以它们共享了很多库。对
于那些不是从Zygote进程fork出来的进程，内存布局就可能有比较大的差异，一个典型的例子
是将在第11章中讨论的无线接口层进程（rild）。不过这些进程也是动态链接的，因此所有进程
的地址空间中都有一段相同的代码内存映射：动态链接器。这段代码用来递归解析二进制程序中
的所有依赖，然后解析从其他库中导入的符号并调整相应的地址。对于未被移入预期基址的二进
制文件，例如由实现地址空间布局随机化（ASLR）所导致的，动态链接器还会负责对其重定位。
在Android4.0系统以及更早的版本中，Bionic动态链接器被映射到静态地址0xb0001000中。
因此，不需要任何信息泄露就能构造ROP载荷。Android4.1系统中，动态链接器的基址像其他
二进制程序那样被随机化了，第12章会进行讨论。
动态链接器存在于所有进程之中，并且在老版本Android系统中有一个固定基址：除此之外，
它还是一个相当稳定的二进制程序，并不会像其他库那样发生很大的变化。Android进程中的大
多数库在不同手机、甚至相同Android版本的不同固件（ROM）中有很大差异，面动态链接库却
非常固定。可能是因为动态链接器非常关键和敏感，开发者总是使用Android源码中的预编译工
具来编译，不对其作任何代码修改。注意，动态链接器的低地址当中包含一个Bionicmemcpy函
数的实现。由于memcDy针对目标架构有较大的优化，所以在不同的处理器上，指令流的偏移会
出现一些细微差异。这就导致链接器当中ROPgadget的地址与特定处理器相对应。
出于以上原因，动态链接库是构造ROP链的完美目标，使其可以尽可能多地得到重用。本
章以搭载Android4.0.1系统的GalaxyNexus中的动态链接器作为案例，学习构造ROP链，并作
---
## Page 252
236
第9章ROP漏润利用技术
为第8章中WebKit漏润利用的延续。
由于Android系统并没有对可执行代码的内存映射进行签名，所以攻击者可以使用ROP链
分配一页（409%字节）可执行的内存，然后把准备的原生载荷复制过来，跳转过去执行。使用
这种方法就能够比较通用地运行任意用户空间的载荷。
9.3.1迁移栈指针
运行ROP载荷的第一步，通常是把栈顶指针指向攻击者控制的数据，例如堆。这一步也被
称作迁移（Pivoting）。当利用栈缓冲区溢出漏洞的时候，栈顶指针往往距离ROP载荷很近，所
以迁移非常简单。如果攻击者控制的数据在堆上，栈迁移就是构造可用ROP链过程中最有挑战
的任务之一。
回到第8章的例子，假设我们已经通过劫持RenderObject类中的虚表指针和伪造对应的
虚函数表控制了程序计数器。即便在其他情况下（例如主堆上一般性的释放后重用漏洞），将栈
迁移到堆上也是有必要的。我们会介绍一种通用的方法，而对于利用漏洞的不同情况，可能会有
更加合适的技术。一个例子是，如果栈上存在堆的指针，那么这个指针就能用作栈帧指针，在函
数结束的时候还原栈顶指针，实现栈到堆的迁移。
在链接器中存在一个非常有趣的gadget，它可以将所有寄存器设置成用户定义的值。我们称
之为mastergadget，它威力巨大，已经被多个漏洞利用编写者用于未公开的漏洞利用代码中。这
个gadget是未使用的异常处理代码的一部分，在Android4.0.1中如下所示：
 text :B0002868
EXPORT __d1_restore_core_regs
text :B0002868
ADD
LDMIA
R1, R0, 0x34
.text :B000286C
R1,(R3R5)
text : B0002870
CARLS
SP1, (R3-R5)
. text : B0002874
LDMIA
R0, (R0-R11)
LDMFD
SP, (SP-PC)
text:B0002878 ; Esd of function _d1_restore_core_regs
它的强大在于有多个可用人口点，每个人口点都对应一个gadget。
口使用0xb0002878作为gadget的起始地址，栈顶指针、1r和新的程序计数器会从当前栈
中载人。当栈顶的局部变量可以被用户控制时，这个gadget就会非常有用，但是针对不
同的bug，效果有较大差异。