.PP
 各种\\d 命令都接受一个 pattern  参数，声明要显示的对象名字。* 表示"任何字符序列"， 而 ? 表示"任何单个字符"。（这个表示法和 Unix 的 shell 文件名模式兼容。） 高级用户也可以使用正则表达式表示法，比如字符表，[0-9] 这样的东西来匹配"任意数字"。 要让任何这些模式匹配字符可以安字面方式解析，那就应该用双引号包围它们。
.PP
 一个包含（无引号的）句点的模式会被解析承一个模式名的模式后面跟着一个对象名的模式。 比如，\\dt foo*.bar* 显示所有以foo 开头的模式里的以 bar 开头的表名字。 如果没有出现句点，那么这个模式只匹配在当前模式搜索路径中可见的对象。
.PP
 如果完全省略 pattern 参数， 那么\\d 命令显示所有在当前模式搜索路径中可见的对象。 要查阅在数据库中的所有对象，使用模式 *.*。
.SS "ADVANCED FEATURES 高级特性"
.SS "VARIABLES 变量"
.PP
\fBpsql\fR 提供类似通常 Unix 命令 shell 那样的变量替换特性。 变量只是简单的名称/数值对， 这里的值可以是任何长度的任何值。要设置一个变量，使用 psql 元命令
\fB\\set\fR：
.sp
.nf
testdb=>\fB\\set foo bar\fR
.sp
.fi
 把变量"foo" 设置为值 "bar"。 要检索变量的内容，在变量名前面放上冒号然后把它用在任意斜杠命令里：
.sp
.nf
testdb=>\fB\\echo :foo\fR
bar
.sp
.fi
.sp
.RS
.B "Note:"
注意: \fB\\set\fR 的参数服从和其他命令一样的替换规则。 因此你可以构造有趣的引用，象\\set :foo 'something' 这样， 获得分别象Perl或 PHP那样有名的"软连接（soft links）"或"变量 变量"。 不幸的是（或者 万幸的？），用这些构造不能做任何有用的事情。另一方面，\\set bar :foo 是一个非常有效的拷贝变量的方法。
.RE
.sp
.PP
 如果你不带第二个参数调用\fB\\set\fR， 那么只是设置这个变量而没有值。 要重置（或删除）一个变量，使用命令\fB\\unset\fR。
.PP
\fBpsql\fR 的内部变量可以包括任意顺序， 任意数量的字母，数字和下划线。 有一些常用变量被 psql 另眼相待。它们是一些选项设置， 这些选项在运行时可以通过改变变量的值或者改变一些应用的表现状态而改变。 尽管你可以把这些变量用于其他用途，但是我们不鼓励这么做，因为程序的特性可能会很快变得非常奇怪。 通常，所有特殊对待的变量都是由大写字母组成（可能还有数字和下划线）。 为了保证和未来的最大限度的兼容性，请避免使用这样的变量。 下面是一个所有特殊对待的变量列表。
.TP
\fBAUTOCOMMIT\fR
 如果是 on（缺省），那么每个 SQL 命令都在成功完成后自动提交。 要推迟这种模式下的提交，你必须输入一个 BEGIN 或者 START TRANSACTION SQL 命令。 如果是 off 或者未设置，SQL 命令不会提交，知道你明确地发出 COMMIT 或者 END。 关闭自动提交的模式是通过为你明确发出一个 BEGIN 实现的， 它是放在任何尚未在一个事务块中并且自己不是 BEGIN 或者其它事务控制命令的前面。
.sp
.RS
.B "Note:"
注意:  在关闭自动提交的模式下，你必须明确放弃任何失败的事务，方法是执行 ABORT 或者 ROLLBACK。 还要注意如果你不提交就退出会话，你的工作会丢失。
.RE
.sp
.sp
.RS
.B "Note:"
注意:  自动提交打开方式是 PostgreSQL 传统的行为， 但是关闭自动提交更接近 SQL 规范。如果你喜欢关闭自动提交，你应该在你的\fI.psqlrc\fR 文件里设置它。
.RE
.sp
.TP
\fBDBNAME\fR
 你正在联接着的数据库名称。 每次你与一个数据库联结都会设置这个值（包括程序启动），但是可以删除。
.TP
\fBECHO\fR
 如果置为 all， 输入的或者来自一个脚本的所有行在分析或执行前都写到标准输出。 要在程序启动时声明这些，使用 -a如果设置为 queries， psql 只是在查询发送给服务器之前打印出来。 实现这个功能的命令行选项是 -e。
.TP
\fBECHO_HIDDEN\fR
 当设置了这个变量并且一个反斜杠命令查询数据库时，首先显示查询。 这样你可以学习 PostgreSQL  内部的东西并且在你自己的程序里提供类似功能。如果你设置该变量的值为 "noexec"，查询只是显示出来但是实际上不发送到服务器和执行。
.TP
\fBENCODING\fR
 当前的客户端字符集编码。
.TP
\fBHISTCONTROL\fR
 如果这个变量设置为 ignorespace， 以空格开始的行将不会进入历史列表。 如果设置为变量 ignoredups， 与以前历史记录里匹配的行也不会进入历史记录。值 ignoreboth是上面两个的结合。 如果删除此变量或者其值为任何与上面的值不同的东西， 所有交互模式读入的行都被保存入历史列表。
.sp
.RS
.B "Note:"
注意:  这个特性是无耻地从\fBbash\fR 里剽窃来的。
.RE
.sp
.TP
\fBHISTSIZE\fR
 存在命令历史里的命令的个数。缺省值是 500。
.sp
.RS
.B "Note:"
注意:  这个特性是无耻地从\fBbash\fR 里剽窃来的。
.RE
.sp
.TP
\fBHOST\fR
 当前你正联接的数据库服务器主机。 这是在每次你与数据库联接时（包括程序启动）设置的，但是可以删除。
.TP
\fBIGNOREEOF\fR
 如果删除此变量，向一个交互的 psql会话发送一个 EOF （通常是\fBControl\fR+\fBD\fR）将终止应用。如果设置为一个数字值，那么在应用终止前该数值的 EOF 字符将被忽略。 如果设置了此变量但是没有数字值，缺省是 10。
.sp
.RS
.B "Note:"
注意:  这个特性是无耻地从\fBbash\fR 里剽窃来的。
.RE
.sp
.TP
\fBLASTOID\fR
 最后影响的oid值，即为从一条 INSERT 或 lo_insert 命令返回的值。 此变量只保证在下一条 SQL 命令的结果显示之前有效。
.TP
\fBON_ERROR_STOP\fR
 缺省时，如果非交互的脚本碰到一个错误，象一条错误的 SQL 命令或者内部元命令，处理会继续进行。 这是 psql 的传统特性， 但是有时候我们不太希望这样。如果设置了这个变量，脚本处理将马上停止。 如果该脚本是从另外一个脚本调用的，那个脚本也会按同样的方式停止。 如果最外层的脚本不是从一次交互的 psql  会话中调用的而是用 -f 选项调用的，psql  将返回错误代码 3，以示这个情况与致命错误条件的区别（错误代码 1）。
.TP
\fBPORT\fR
 当前你正在联接的数据库服务器的端口。 这是在每次你与数据库联接时（包括程序启动）设置的，但是可以删除。
.TP
\fBPROMPT1\fR
.TP
\fBPROMPT2\fR
.TP
\fBPROMPT3\fR
 这些指明psql 显示的提示符看上去象什么。 参阅下面的 "Prompting 提示符"。
.TP
\fBQUIET\fR
 这个变量等效于命令行选项 -q。 可能在交互模式下没有什么用。
.TP
\fBSINGLELINE\fR
 这个变量等效于设置命令行选项 -S。你可以在运行时删除或设置它。
.TP
\fBSINGLESTEP\fR
 这个变量等效于命令行选项\fB-s\fR。
.TP
\fBUSER\fR
 当前你正用于联接的数据库用户。 这是在每次你与数据库联接时（包括程序启动）设置的，但是可以删除/重置。
.TP
\fBVERBOSITY\fR
 这个选项可以设置为值 default，verbose，或者 terse  以控制错误报告的冗余行。
.SS "SQL INTERPOLATION 代换"
.PP
 一个附加的 psql 变量的有用特性是你可以把它们替换（"代换"）成正规的 SQL 语句。这样做的语法同样还是变量名前面加一个冒号（:）。
.sp
.nf
testdb=>\fB\\set foo 'my_table'\fR
testdb=>\fBSELECT * FROM :foo;\fR
.sp
.fi
 将会查询表my_table。变量的值是逐字拷贝的， 所以它甚至可以包含不对称的引号或反斜杠命令。你必须保证你输入的东西是有意义的。 变量替换将不会在引号引起来的 SQL 语句里面发生。
.PP
 利用这个功能的一个时髦的应用是通过使用一个随后的语句中最后插入的 OID 建立一个外键仿真场景。 另一个可能用到这个机制的地方是把一个文件的内容拷贝到一个字段里面去。 首先把文件装载到一个变量然后象上面那样处理。
.sp
.nf
testdb=>\fB\\set content '\\'' `cat my_file.txt` '\\''\fR
testdb=>\fBINSERT INTO my_table VALUES (:content);\fR
.sp
.fi
 这样处理的一个可能问题是 my_file.txt  可能包含单引号。这些需要被逃逸以免在处理第三行时不会导致语法错误。 可以使用程序 sed 来做这个处理：
.sp
.nf
testdb=>\fB\\set content '\\'' `sed -e "s/'/\\\\\\\\\\\\'/g" \fR
 数据库服务器正在侦听的端口号。
.TP
\fB%n\fR
 数据库会话的用户名。 （这个值的扩展可能在一个数据库会话过程中因为\fBSET SESSION AUTHORIZATION\fR 命令而改变。）
.TP
\fB%/\fR
当前数据库名称。
.TP
\fB%~\fR
类似 %/， 但如果数据库是你的缺省数据库输出是"~"  （波浪线（tilde））。
.TP
\fB%#\fR
 如果会话用户是数据库超级用户，使用 "#"，否则用">"。 （这个值的扩展可能在一个数据库会话过程中因为\fBSET SESSION AUTHORIZATION\fR 命令而改变。）
.TP
\fB%R\fR
 对于 prompt 1 通常是 =，但是如果是单行模式则是 ^，而如果会话与数据库断开（如果\connect 失败可能发生）是 !。对于 prompt 2 该序列被 -，*，一个单引号或者一个双引号代替， 这取决于 psql是否等待更多的输入（因为查询没有终止，或着正在一个 /* ... */注释里面，或者因为你在引号里面）。对于 prompt 3 该序列不解释成任何东西。
.TP
\fB%x\fR
 事务状态：如果不在事务块里，是一个空字串，如果在事务块里，是 *， 如果在一个失败的事务块里是 !，或者无法判断事务状态时为 ?  （比如，因为没有连接）。
.TP
\fB%\fIdigits\fB\fR
 如果 digits 以 0x 开头， 那么其余字符被解释成一个十六进制数字并且替换为对应（十六进制码）的字符。 如果第一个数字是 0，该字符被解释成一个八进制数字并且替换为对应的（八进制码）的字符。 否则认为是一个十进制数字。
.TP
\fB%:\fIname\fB:\fR