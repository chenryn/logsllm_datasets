作者: [程进@默安科技](https://mp.weixin.qq.com/s/gR7CcICIPV8S1Jop3i_8WQ##)
#### 01\. 研究背景
在如今，做安全防御已经不仅仅是被动的等着攻击者攻击，作为防御方，有越来越多的方法去反击攻击者，甚至给攻击者一些威胁。
设备指纹技术是一种长久有效的追踪技术，即使攻击者挂再多 vpn，也能够准确识别攻击者身份。
本文借助理海大学发布的 [(Cross-)Browser Fingerprinting via OS and Hardware Level
Features](http://yinzhicao.org/TrackingFree/crossbrowsertracking_NDSS17.pdf)
文章，写一些个人理解，与原文一并服用，效果更佳。
#### 02\. 设备指纹技术介绍
###### 1\. 第一代
第一代指纹追踪是 cookie 这类的服务端在客户端设置标志的追踪技术，evercookie 是 cookie 的加强版。
###### 2\. 第二代
第二代指纹追踪是设备指纹技术，发现 IP 背后的设备。通过 js 获取操作系统、分辨率、像素比等等一系列信息，传到后台计算，然后归并设备。
唯一性可以保证，但准确率很难完全保证。主要原因就是在跨浏览器指纹识别上面。跨浏览器之后，第二代技术中很重要的 canvas
指纹、浏览器插件指纹都变了，所以很难把跨浏览器指纹归并到同一设备上。
因为设备指纹相同，很大概率上是同一台设备；但是，设备指纹不同时，不一定不是同一台设备。
###### 3\. 第三代
第三代指纹追踪技术，则是发现设备后面的人。通过人的习惯、人的行为等等来对人进行归并，此项技术比较复杂。
###### 4\. 总 结
第一代、第二代的指纹追踪技术是可以直接通过 js 收集信息的，第三代指纹追踪技术目前可看到的案例是2017年 RSA 创新沙盒的冠军 unifyid
技术。但是在 RSA 的答辩现场我们可以看到，unifyid 在移动端安装软件、收集信息，不仅仅是通过 js。至于利用于 web 上，还任重而道远。
因此，2.5代指纹识别技术，即跨浏览器指纹识别技术。
#### 03\. 跨浏览器指纹识别特征
这篇 paper 中的创新点很多，最主要的是深入研究了显卡的渲染方法，图片的哪些部分用到硬件渲染，哪些部分只用到软件渲染，或者跟浏览器有关，paper
中都有深入研究。
着重讲一些比较有意思的特征，文章中用到的所有特征如下：
其中很多特征都是在其他设备指纹的 paper 中出现过的，并且目前被广泛用于设备指纹项目。比如 canvas 指纹在单浏览器识别中是比较有区分度的特征。
对比一下已经开源的 fp2 的指纹列表
fp2 中的都是一些常规的追踪项目，并且如果用过就知道，其中很多项目是没有什么区分度的，比如
  * Has session storage or not
  * Has local storage or not
  * Has indexed DB
  * Has IE specific 'AddBehavior'
  * Has open DB
  * Is AdBlock installed or not
  * Has the user tampered with its languages 1
  * Has the user tampered with its screen resolution 1
  * Has the user tampered with its OS 1
  * Has the user tampered with its browser
这些项只能进行一些大致的区分，并没有什么实际的参考价值
但是这篇 paper 中去掉了这些区分度低的特征，用到了另一类特征，显卡渲染图片，就是特征表中的 task(a)-task(r)，可以看到这些 task
的跨浏览器稳定性都非常高，也就是说受浏览器的影响不是很大，抽一些任务介绍一下
首先，paper 中对图片渲染进行了简单的介绍
> 在此之前，首先介绍下面的基本画布设置。画布的大小为
> 256×256。画布的轴定义如下，[0，0，0]是画布的中心，其中x轴是向右延伸的水平线，y轴是延伸到底部的垂直线，z轴朝远离 屏幕方向延伸。存在功率为
> [R：0.3，G：0.3，B：0.3]（1） 的环境光，相机位于 [0，0，-7]
> 的位置。这两个组件是必需的，否则模型完全是黑色的。在本文的其余部分，除非指定，例如具有 2D
> 特征的任务（d）和其他带有附加灯的任务，其他所有任务中使用相同的基本设置。
这里列举几个典型的 task
###### 1\. task（a）：纹理
图2（a）中的任务是测试片段着色器中的常规纹理特征。
具体来说，Suzanne 模型[19]在随机生成纹理的画布上呈现。纹理，大小为 256×256
的正方形，通过随机选择每个像素的颜色来创建。也就是说，我们在一个像素的三个基色（红色，绿色和蓝色）之间产生 0 和 255
之间的三个随机值，将三个基色混合在一起，并将其用作像素的颜色。
之所以选择这个随机生成的纹理，是因为这个纹理比常规纹理具有更多的指纹特征。原因如下，当片段着色器将纹理映射到模型时，片段着色器需要在纹理中插入点，以便将纹理映射到模型上的每个点。插入值算法在不同的显卡中是不同的，当纹理变化很大时，差异就被放大。因此，我们需要生成在每对相邻像素之间颜色变化很大的这种纹理。
###### 2\. task（d）：线和曲线
图（d）中的任务是测试线和曲线。 在画布上绘制一条曲线和三条不同角度的直线。具体来说，曲线遵循以下功能：y = 256-100cos（2.0πx/