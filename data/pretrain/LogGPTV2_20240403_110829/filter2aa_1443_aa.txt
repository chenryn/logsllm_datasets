Saif  El-Sherei & Etienne Stalmans 
What is Fuzzing?? 
Fuzzing is feeding an Application with 
malformed input in hope to find errors and 
faults in the application code and with a bit 
of luck these faults can lead to exploitable 
vulnerabilities  
Basic History of Fuzzing 
•
1988-199: 
•
Boris Beizer Syntax Testing. 
•
Barton Miller Fuzz: An Emprical Study of Robustness. 
•
1999 – 2001 OUSPG PROTOS SNMP, HTTP, SIP, H.323, LDAP, etc … 
•
2002 Dave Aitel SPIKE block based fuzzing. Codnemicon first commercial 
fuzzer. 
•
2004 Browser Fuzzing start lcamtuf‟s MangleMe. 
•
2005 FileFuzz , SPIKEfile NotSPIKEfile File format fuzzing. 
•
2006 Month of Browser Bugs (MoBB) HD Moore relases a browser bug 
every day for a month release of CSSDIE, COMRaider and Axman and 
hamachi. 
•
2011 Lcamtuf decided to revolutionize Browser fuzzing in 2011 by releasing 
cross_fuzz. In his own words "a surprisingly effective but notoriously 
annoying cross-document DOM binding fuzzer that helped identify about 
one hundred bugs in all browsers on the market - many of said bugs 
exploitable - and is still finding more." it is based on ref_fuzz which he 
developed in 2008. 
•
2014 lcamtuf‟s introduces American Fuzzy lop (Afl) Evolutionary fuzzer. 
Fuzzing Types And Techniques 
Fuzzing methodology 
Monitor for Memory corruption Errors. 
Fuzz target 
Generate Data 
Identify Inputs 
Identify Target 
Fuzzing Types  
• Mutation/Non-Intelligent Fuzzing  
Randomly apply mutation algorithms to the 
supplied input to generate several test cases 
without any concern to the target format. 
• Generation/Intelligent Fuzzing 
Utilize grammar to model a certain format 
specification and randomly generate semi-valid 
test cases. to minimize fault conditions and 
generate test cases that are accepted by the 
target. 
Fuzzing Types Contd.. 
• Evolutionary Fuzzing 
Combining either types of fuzzing with code and 
binary instrumentation tools, to monitor code paths and 
generate test cases based on the results of the 
instrumentation to achieve least number of test cases 
with highest amount of code coverage and branches 
explored. 
In Fewer words lcamtuf‟s American fuzzy lop.  
Tools of the Trade - Memory Error 
Detectors 
Memory Error Detectors poisons memory areas 
after memory allocations and after the memory is 
free-ed. It monitors access to these parts in 
memory and returns detailed error information. 
Windows:  
• PageHeap which is part of Gflags part of 
windows debugging toolkit can be applied on 
some windows processes. 
Linux and OSX:  
•  Google's Address Sanitizer (Asan) is a clang 
compiler plugin that can be implemented during 
compilation time of any linux or OSX application. 
Tools of the Trade - Fuzzing Harnesses 
Fuzzing harnesses are not themselves 
fuzzers but they are tools that run the target 
process feed it the generated test case and 
monitor the process for crashes.  
Windows: 
•  Grinder by Stephen Fewer. 
Linux and Mac OSX:  
• Node Fuzz by Atte Kettunen of OUSPG. 
Introducing 
Wadi – Fuzzing Harness 
Atte Kettunen's of OUSPG NodeFuzz: 
• Nodefuzz is a fuzzing framework that works on Linux, 
And Mac OSX. 
• It is coded by Atte Kettunen of OUSPG using Nodejs.  
• It works by instrumenting the browser using ASan. and 
a test case generation module to feed the browser the 
test case through web sockets.  
• The modules are not provided as part of NodeFuzz you 
can code your own. it is a pretty simple process.  
• NodeFuzz is what we are currently using. with our own 
custom modules. 
Wadi – Memory Error Detector 
Google's AddressSanitizer (ASan): 
• AddressSanitizer (ASan) is a clang compiler plugin 
Developed By Google which allows fast memory error 
detection.  
• The run-time library replaces the malloc and free functions. 
The memory around malloc-ed regions (red zones) is 
poisoned. The free-ed memory is placed in quarantine and 
also poisoned. Every memory access is monitored and if 
address is poisoned a detailed error is returned. 
• It Helps find use-after-free and heap,stack,global}-buffer 
overflow bugs in C/C++ programs. For Linux and mac OSX 
• Google and Mozilla both releases ASan pre built binaries for 
testing.  
What is Wadi? 
• Exploring new tributaries in browser fuzzing.  
• Grammars are used to describe how browsers 
should process web content, Wadi turns that 
around and uses grammars to break browsers. 
• Wadi already responsible for a handful of high 
severity bugs in browsers.  
Why Wadi? 
• From Chrome, to IE, Wadi identifies 
exploitable bugs in new and existing web APIs. 
• The talk introduces Wadi and walks the 
audience through the steps taken to go from 
LL(1) grammar to fuzz test cases and browser 
crashes 
A simple Intro to The DOM  
Interfaces are types of objects that allow web applications 
and web browsers to programmatically access and interact 
with them to access their members. 
The Document Object Model (DOM): 
The Document Object Model provides a standard set of 
objects for representing HTML and XML documents, a 
standard model of how these objects can be combined, and 
a standard interface for accessing and manipulating them. 
Web API: 
When writing code for the Web using JavaScript, there are 
great many APIs available. that you may be able to use 
developing Web applications. ex: speech, webaudio, 
gamepad, canvas, webgl, animation, etc.. 
Wadi Architecture 
• Wadi is 3538 lines of code.  
• 2932 of these are grammar for test case 
generation. 
• Wadi works as a NodeFuzz Module and it 
is used to fuzz Chromium and Firefox 
Asan builds. 
• Already responsible for a number of bugs. 
What is Grammar ? 
Grammar in English explains how a sentence is 
constructed.  The same can be said about 
Grammars in compilers it describes how the 
language syntax is constructed the input is parsed 
based on a set rules “Productions” and tokens 
defined in the grammar definitions. In fuzzing 
grammar is used to help the fuzzer generate valid 
test cases.  
w3c have provided us with a nice interface definition 
language(IDL) that defines browser technology 
interfaces this is utilized by the fuzzer to be able to 
create and fuzz all attributes and methods used by 
them. 
Grammar – IDL Interface 
According to the IDL definitions an interface is an object 
with a set of interface members these can be constants, 
attributes, or functions. Each interface has a unique 
identifier and inherits from a parent interface if needed. 
• LL(1) Interface Definition Grammar: 
"interface" identifier Inheritance "{" InterfaceMembers "}" ";“ 
Grammar – IDL Interface Example 
• Identifier: Text 
• Inheritance: CharacterData 
interface Text : CharacterData { 
Text               splitText(in unsigned long offset) 
raises(DOMException); 
Text               replaceWholeText(in DOMString content) 
raises(DOMException); 
readonly  attribute boolean         isElementContentWhitespace; 
attribute DOMString   wholeText; 
}; 
Grammar – IDL Interface Members 
An interface member can be a constant, attribute or function as mentioned 
before. What we are interested in are the attributes and functions of an 
interface object. Taking a closer look at how interface members are defined in 
the IDL specification. 
•
InterfaceMembers: 
Attributes: isElementContentWhitespace, wholeText 
Functions: splitText(), replaceWholeText() 
LL(1) Grammar Interface Member Definition: 
InterfaceMember → 
Const 
| AttributeOrOperation 
AttributeOrOperation 
→ 
"stringifier" StringifierAttributeOrOperation 
| Attribute 
| Operation 
Grammar – IDL Attributes 
An attribute is a declared interface member with an identifier 
whose value can be retrieved and in some cases changed. 
LL(1) Grammar Attribute Definition: 
Attribute → 
Inherit ReadOnly "attribute" Type identifier ";" 
Attributes of Example Interface: 
readonly attribute boolean         isElementContentWhitespace; 
        attribute DOMString   wholeText; 
Identifier 
Input Type 
ReadOnly 
isElementContentWhitespace 
boolean          
True 
wholeText 
DOMString        
False 
Example Interface Attributes: 
Grammar – IDL Functions 
Functions in the IDL specification is referred to as operations. A function 
is an interface member that defines behavior that can be invoked on 
objects implementing the interface. 
LL(1) Grammar Attribute Definition: 
Functions of Example Interface: 
Example Interface Functions: 
Operation 
→ 
Qualifiers OperationRest 
OperationRest → 
ReturnType OptionalIdentifier "(" ArgumentList ")" ";" 
  Text               replaceWholeText(in DOMString content) 
  Text               splitText(in unsigned long offset) 
Identifier 
Number of Args 
Arg Identifier 
Arg Type 
Return Value 
replaceWholeText One 