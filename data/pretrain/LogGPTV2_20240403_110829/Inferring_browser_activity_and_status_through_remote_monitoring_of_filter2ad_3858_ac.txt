0
80.3
73.0
Linux
Windows
Figure 10: Accuracy of cross-tab activity inference attacks via Tor on
Linux and Windows. Using Tor decreased the inference accuracy due to its
geographical differences and network noise.
fetch all resources of a web page in one minute due to the long and
unstable latency of Tor. An attacker needs to prolong monitoring
time to mitigate the second problem.
3.5
Identifying Cached Web Sites
Next, we perform our cross-tab activity inference attacks against
web sites that are stored in the browser cache (i.e., warm). When
a web browser visits a cached web site again, it only fetches and
stores dynamic or updated resources of the web site. Thus, a change
log of storage footprint size would contain restrictive information.
We expect that the inference accuracy of our attack decreases when
a victim visits cached web sites.
We prepared attack databases that contain change logs of storage
footprint size when visiting cached Alexa Top 100 web sites, and
compare the attack databases with a victim’s visits for inference.
Note that we did not test it with Tor because it usually does not cache
web resources. We consecutively visited each web site 10 times for
each platform while clearing the browser cache only before visiting
a web site for the ﬁrst time. Figure 11 shows the inference accuracy
of our attack when a victim visits the front web pages of Alexa Top
100 web sites that are already cached. As expected, we observed
decreased inference accuracy: 70.5% (Linux), 65.8% (Android),
and 60% (Windows).
3.6 Summary
As shown in §3.3.3, §3.3.4, §3.4, and §3.5, background noise
in disk and network, Tor, and heavy usage of the browser cache
(e.g., increasing the browser cache size) can mitigate our cross-
tab activity inference attacks, but we still have a chance to infer a
victim’s activity. A robust and effective countermeasure against our
attack will be introduced in §5.1.
4. BROWSER STATUS INFERENCE
)
%
(
y
c
a
r
u
c
c
a
e
c
n
e
r
e
f
n
I
100
80
60
40
20
0
70.5
65.8
60.0
Linux
Android
Windows
Figure 11: Accuracy of cross-tab activity inference attacks against cached
web pages. The inference accuracy decreased because a browser did not
fetch cached resources.
(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:17)(cid:70)(cid:82)(cid:80)
(cid:55)(cid:68)(cid:85)(cid:74)(cid:72)(cid:87)(cid:17)(cid:70)(cid:82)(cid:80)
(cid:57)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)
(cid:50)(cid:83)(cid:72)(cid:81)(cid:3)(cid:55)(cid:68)(cid:69)(cid:20)(cid:3)
(cid:20)(cid:17) (cid:57)(cid:76)(cid:86)(cid:76)(cid:87)(cid:3)(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:17)(cid:70)(cid:82)(cid:80)
(cid:21)(cid:17) (cid:40)(cid:91)(cid:72)(cid:70)(cid:88)(cid:87)(cid:72)(cid:3)(cid:68)(cid:81)(cid:3)(cid:68)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)
(cid:86)(cid:70)(cid:85)(cid:76)(cid:83)(cid:87)
(cid:23)(cid:17) (cid:47)(cid:82)(cid:74)(cid:3)(cid:70)(cid:75)(cid:68)(cid:81)(cid:74)(cid:72)(cid:86)(cid:3)(cid:76)(cid:81)(cid:3)(cid:87)(cid:75)(cid:72)
(cid:86)(cid:76)(cid:93)(cid:72)(cid:3)(cid:82)(cid:73)(cid:3)(cid:86)(cid:87)(cid:82)(cid:85)(cid:68)(cid:74)(cid:72)(cid:3)(cid:73)(cid:82)(cid:82)(cid:87)(cid:83)(cid:85)(cid:76)(cid:81)(cid:87)(cid:86)
(cid:31)(cid:41)(cid:82)(cid:85)(cid:72)(cid:74)(cid:85)(cid:82)(cid:88)(cid:81)(cid:71)(cid:33)
(cid:50)(cid:83)(cid:72)(cid:81)(cid:3)
(cid:75)(cid:76)(cid:71)(cid:71)(cid:72)(cid:81)(cid:3)(cid:55)(cid:68)(cid:69)
(cid:31)(cid:43)(cid:76)(cid:71)(cid:71)(cid:72)(cid:81)(cid:33)
(cid:22)(cid:17) (cid:57)(cid:76)(cid:86)(cid:76)(cid:87)(cid:3)(cid:55)(cid:68)(cid:85)(cid:74)(cid:72)(cid:87)(cid:17)(cid:70)(cid:82)(cid:80)
(cid:24)(cid:17) (cid:41)(cid:72)(cid:87)(cid:70)(cid:75)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:85)(cid:72)(cid:86)(cid:82)(cid:88)(cid:85)(cid:70)(cid:72)(cid:86)
(cid:82)(cid:73)(cid:3)(cid:55)(cid:68)(cid:85)(cid:74)(cid:72)(cid:87)(cid:17)(cid:70)(cid:82)(cid:80)
(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:17)(cid:70)(cid:82)(cid:80)
(cid:55)(cid:68)(cid:85)(cid:74)(cid:72)(cid:87)(cid:17)(cid:70)(cid:82)(cid:80)
(cid:75)(cid:87)(cid:87)(cid:83)(cid:29)(cid:18)(cid:18)(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:17)(cid:70)(cid:82)(cid:80)
(cid:25)(cid:17) (cid:54)(cid:72)(cid:81)(cid:71)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:83)(cid:72)(cid:68)(cid:78)(cid:3)(cid:86)(cid:76)(cid:93)(cid:72)
(cid:82)(cid:73)(cid:3)(cid:86)(cid:87)(cid:82)(cid:85)(cid:68)(cid:74)(cid:72)(cid:3)(cid:73)(cid:82)(cid:82)(cid:87)(cid:83)(cid:85)(cid:76)(cid:81)(cid:87)
(cid:55)(cid:76)(cid:80)(cid:72)
Figure 12: The procedure of a browser status inference attack using storage
footprints. When a victim visits Attack.com, it creates a hidden tab to inspect
browser status toward any web sites.
In this section, we explain how we can use storage footprints to
develop two active attacks to infer browser status: browser history
stealing and login status identiﬁcation. Our browser status infer-
ence attacks resemble conventional cache timing attacks [4, 10, 19].
However, the accuracy of our attacks is better than the conventional
attacks because our attacks use the total size of newly fetched re-
sources that is not affected by network condition. In contrast, the
cache timing attacks are highly vulnerable to network condition (see
§4.5).
4.1 Threat Model
The threat model of the browser status inference attack is basi-
cally the same as §3.1, but an attacker has a slightly different goal:
inferring browser history and login status. To obtain such informa-
tion, the attacker generates additional requests to other web sites
under consideration.
4.2 Attack Procedure
Figure 12 depicts the procedure of our browser status inference
attack. This attack’s procedure is almost the same as the procedure
of our cross-tab activity inference attack except the methods to
visit a target web site Target.com and to compare storage footprints
differ. First, an attack script directly loads Target.com by using
Prerendering [15], which allows a web application to preload a web
page in a hidden browser tab. Second, an attacker uses the peak size
of storage footprints instead of the change logs of storage footprint
size to identify the status of a target web site.
4.2.1 Prefetching and prerendering
create_prerender(URL[idx]);
idx++;
1 var PrerenderTimer;
2 var URL = ["google.com", "facebook.com", ...];
3 var idx = 0;
4
5 PrerenderTimer = setInterval("prerenderURL()",10000);
6
7 function prerenderURL() {
8
9
10 }
11
12 function create_prerender(url) {
13
14
15
16
17
18
19
20
21 }
link.id = ’prerendering’;
link.rel = ’prerender’;
link.href = url;
document.body.appendChild(link);
var link = document.getElementById(’prerendering’) ||
document.createElement(’link’);
Figure 13: JavaScript pseudocode to prerender target web sites.
Modern web browser supports two functions, prefetching and pre-
rendering, to reduce loading and processing time of web pages. First,
prefetching makes a web browser preemptively download resources
of a web page, but it only reduces network delay. A web site can
prefetch a resource by using .
Second, prerendering makes a web browser preload a web page
in a hidden browser tab and display the loaded web page when a
user attempts to visit the web page. Thus, prerendering can reduce
network and rendering delay. A web site can preload a web page by
using .
Figure 13 shows JavaScript pseudocode to prerender target web
sites. At Line 2, an array URL contains a list of web pages to be
inspected. At Line 5, the script deﬁnes PrerenderTimer to period-
ically call prerenderURL() (at Line 7). At Lines 7–10, the script
prerenders a new web page every 10 s by dynamically inserting a
link tag into an attack web page (at Lines 12–21).
Instead of prerendering, an attacker can use an iframe tag to
load a web page. However, a web page can prevent an iframe
tag from including itself by using either an HTTP header ﬁeld
X-Frame-Options [35] or frame busting code [37]. Therefore, we do
not use an iframe tag when conducting our browser status inference
attacks.
4.2.2 Peak size of storage footprints
We use the peak size of storage footprints to identify whether a
victim web browser has visited a web site rather than OSB. When
a victim visits a web site that he or she has visited before, many
resources of the web site are already stored in the browser cache
such that the victim web browser only downloads changed or dy-
namic resources of the web site. Deﬁnitely, the peak size of storage
footprints in such a case is smaller than that when a victim ﬁrstly
visits the web site. Using the peak size can avoid the computation
overhead of OSB and shows enough accuracy as explained in the
following sections.
4.3 History Stealing in a Normal Network
We ﬁrst consider how our browser status inference attack success-
fully identiﬁes browser history in a normal network.
4.3.1 Data collection
We collected the peak size of storage footprints of the non-cached
front pages of Alexa Top 500 web sites on three different platforms
(Linux, Windows, and Android) and treated them as attack databases.
A data collection procedure for each front page of Alexa Top 500
415
)
%
(
y
c
a
r
u
c
c
a
e
c
n
e
r
e
f
n
I
100
80
60
40
20
0
98.5
97.7
97.3
Android
Linux
Windows
Figure 14: Inference accuracy of browser history stealing (Alexa Top 500
sites). We always observed high inference accuracy regardless of OSes.
)
%
(
y
c
a
r
u
c
c
a
e
c
n
e
r
e
f
n
I
100
80
60
40
20
0
96.3
91.2
Windows
Linux
Figure 15: Inference accuracy of browser history stealing via Tor (Alexa
Top 500 sites). The attack on Linux showed slightly worse accuracy due to
frequent geographical changes in Tor.
Inference accuracy
web sites is as follows. First, using a Chrome web browser, we
visit our attack page that uses Prerendering to visit the front page.
Second, we monitor temporal changes in the size of storage foot-
prints for 10 s. Third, we inform an attack server of the peak size of
storage footprints. Lastly, we clear the browser cache. We repeated
this procedure ﬁve times for each front page on each platform and
regarded the 2,500 peak size values of storage footprints per each
platform as attack databases.
4.3.2
To evaluate the inference accuracy of our history stealing attack,
we visited each front page of Alexa Top 500 web sites ﬁve times
on each platform and compared the peak size of storage footprints
for each front page with that for each non-cached front page stored
in the attack databases. Let µp and σp are mean and standard
deviation of the peak size values of a web page p stored in the attack
databases. Also, let sp is the peak size of storage footprints when
a victim web browser visits p. If sp < µp − σp, we treat that the
victim web browser has visited p before. Otherwise, we treat that
the victim web browser has not visited p. This treatment resembles
the distinguishability deﬁned in [20].
We identify that the inference accuracy of our history stealing
attack is considerably high. As shown in Figure 14, the inference
accuracy of our attack against the front web pages of Alexa Top 500
web sites on the three platforms is 98.5% (Android), 97.7% (Linux),
and 97.3% (Windows).
4.4 History Stealing in a Tor Network
Next, we consider browser history stealing in a Tor network.
Figure 15 shows results of browser history stealing for front pages
of Alexa Top 500 web sites on Windows and Linux. Inference
accuracy of our attack on Windows and Linux is 96.3% and 91.2%,
respectively.
We analyze why the inference accuracy of our attack in a Tor
network decreases and identify that it is due to changes of the
geographical location of a victim web browser by Tor as explained
416
webpage.onload = function () {
var end = new Date().getTime();
var load = end - this.getAttribute(’start’);
var webpage = document.createElement(’iframe’);
webpage.setAttribute(’start’, new Date().getTime());
webpage.src = URL[Url_count];
1 function create_iframe() {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16 }
Figure 16: Javascript pseudocode to measure load time of web pages to
steal the browser history.
this.parentNode.removeChild(this);
...
create_iframe();
// Send "load" to an attack server.
}
Our method
Timing attack
98.0
100
78.5
99.3
70.2
)
%
(
y
c
a
r
u
c
c
a
e
c
n
e
r
e
f
n
I
80
60
40
20
0
LAN
Wi-Fi
Figure 17: Inference accuracy of browser history stealing using storage
footprints and using timing attacks on Linux (Alexa Top 200 sites). Our
attack was better than the timing attacks.
in §3.4. When a web site provides different contents according to
the country information of a web browser, the resources of the web
site cached in the browser are no longer valid if the browser moves