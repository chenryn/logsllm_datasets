(cid:32) (cid:35) (cid:32)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
(cid:35)
rations, the DATA GUI was key to master the amount of data
we collected. We open-source our tool, including the DATA
GUI and provide examples to reproduce our results. Figure 5
in Appendix A depicts the DATA GUI, showing a discovered
control-ﬂow leak in BoringSSL.
(cid:35)
5 Vulnerability Analysis Overview
In this work, we analyze OpenSSL, LibreSSL, and BoringSSL
for (EC)DSA nonce leakage. We include the whole life cy-
cle of nonces in the analysis, i.e., nonce generation, modular
exponentiation for DSA or scalar multiplication for ECDSA,
modular inversion, and the ﬁnal modular multiplication. Our
ﬁndings are summarized in Table 1 and outlined in the fol-
lowing. As mentioned in Section 4, our analysis cannot prove
an implementation secure in a mathematical sense.
Nonce representation is based on Bignumbers. OpenSSL
and LibreSSL minimize memory usage, i.e., small numbers
use fewer memory words than larger ones. This minimal rep-
resentation of Bignumbers leaks the length of small nonces
in several subsequent computation steps. BoringSSL, on the
other hand, does not shrink sensitive Bignumbers, avoiding
all Bignumber-related vulnerabilities we found by design.
Generation of nonces is done via rejection sampling in Li-
breSSL and BoringSSL, which gives uniformly distributed
nonces. In contrast, OpenSSL truncates a large random num-
ber to the target nonce, introducing a negligible bias. Only
OpenSSL includes the private key in the nonce generation to
address potential weaknesses in random number generators.
DSA modular exponentiation itself did not reveal any leaks,
as the ﬁxed-window implementations are constant time. How-
ever, for OpenSSL and LibreSSL, we found several critical
leaks due to padding the nonce prior to exponentiation. This
enables easy-to-mount cache attacks, leading to full key re-
covery. Although the patched OpenSSL version closes the
cache-attack vulnerability, it is still vulnerable to more sophis-
ticated attacks, which we demonstrate in Appendix B.
ECDSA scalar multiplication leaks in OpenSSL and Li-
breSSL in the same way as DSA exponentiation, namely when
padding the nonce. On the other hand, the default multiplica-
tion uses blinding to make side-channel leakage independent
of the nonce. Additionally, OpenSSL and BoringSSL provide
USENIX Association
29th USENIX Security Symposium    1771
Table 2: Discovered vulnerabilities in OpenSSL, LibreSSL, and BoringSSL and whether they are patched as of October
2019, currently being patched A, or unpatched . Exploiting the side channel can be easy (cid:32) , medium (cid:71)(cid:35) , or hard (cid:35) .
The number of leaked bits (Nonce Leakage) indicates the complexity of a full key recovery.
Vulnerability
Generate: (V1) Small k (top)
OpenSSL LibreSSL BoringSSL Nonce Leakage
SC Comments
.
t
l
u
M
r
a
l
a
c
S
/
.
p
x
E
t
r
e
v
n
I
(V2) k-padding resize
(V3) consttime-swap
(V4) Downgrade
(V5) k-padding (top)
(V6) Buffer conversion
(V7) Point addition
(V8) Euclid BN_div
(V9) Euclid negation
Multiply: (V10) Small k−1 (top)
EC
EC
DSAEC DSAEC
DSAEC DSAEC
DSA
–
DSAEC DSAEC
EC
ECA
DSA
DSA
–
–
–
DSA
DSA
EC
–
–
–
–
–
–
EC
–
–
–
Leaks in BN_add and BN_is_bit_set.
SGX attack shown in Appendix B.
Topmost 0-limbs of k
Topmost 0-bits of k
same as (V2)
same as (V2) + [24]
same as (V2)
Topmost 0-bytes of k
All 0-windows of k
Topmost bit of k
Topmost 0-bit of kinv
(cid:32) Leaks in several subsequent steps
(cid:32) CVE-2018-0734 and CVE-2018-0735
(cid:71)(cid:35) Already known
(cid:32) Introduced while ﬁxing (V2)
(cid:35)
(cid:35)
(cid:35)
(cid:32) Leaks via resize, similar to (V2)
(cid:32) Leaks via conditional negation
Topmost 0-limbs of kinv (cid:71)(cid:35)
ual task. In particular, leakage models might not trigger if
they do not match the actual leakage. In this case, leakage
might still show up in the phase one differences reported by
DATA, and an extension of the leakage models is required.
Also, leakage models might show a correlation without cau-
sation, e.g., via public values. Such cases can be eliminated
by tracing the leakage back to its sources in our DATA GUI.
Following this methodology helped us uncover numerous
vulnerabilities, as summarized in Table 2. To give an intuition
about their exploitability, we rank them as easy to exploit
(cid:32) if a Flush+Reload attack sufﬁces for extracting nonce bits,
medium(cid:71)(cid:35) for more elaborate attacks requiring performance
degradation or Prime+Probe, or hard(cid:35) for tiny leakage (e.g.,
few assembler instructions on a single cache line) which might
be only exploitable in an SGX setting [17].
6.1 Nonce Representation
OpenSSL and LibreSSL represent cryptographic values
such as nonces via Bignumbers. Each Bignumber is stored
in a BIGNUM struct that contains a lazily allocated array of
limbs (e.g., 64-bit words). The number of allocated limbs is
tracked via the ﬁeld dmax. Bignumbers are represented in
their minimal form, i.e., each BIGNUM tracks the actually used
limbs in a separate top ﬁeld. As seen in Figure 1, top can be
smaller than dmax. Whenever space is exhausted, a BIGNUM
is dynamically resized via a call to bn_wexpand.
To maintain the minimal representation, OpenSSL and Li-
breSSL constantly realign top via a call to bn_fix_top by ex-
cluding leading zero limbs. This has two advantages: First, it
avoids unnecessary computations and increases performance.
Second, the programmer does not need to know the maximum
size of Bignumbers in advance. However, it is also a source
for side-channel leakage, leading to various vulnerabilities.
BoringSSL, in contrast, has hardened their implementa-
tion against such leaks by abandoning the minimal representa-
tion invariant of Bignumbers. They introduced a width ﬁeld,
optimized constant-time windowed multiplication routines
for several NIST curves. We discovered a tiny but severe side-
channel leakage in their constant-time point addition, which
leaks whenever a nonce multiplication window is all zero.
For OpenSSL, we identiﬁed additional nonce leakage due to
Bignumber handling, which was partly known before.
Modular inversion in OpenSSL and LibreSSL is done via
a variant of Euclid’s algorithm, claiming some side-channel
security. Nevertheless, we found an easy-to-exploit vulner-
ability leaking the topmost nonce bit during a division step.
Moreover, Euclid’s algorithm inherently leaks the number of
iterations, which correlates to the nonce itself. While we could
not ﬁnd a way to exploit this non-constant time behavior, our
tool reported another leak in a ﬁnal negation step that helps an
attacker again to learn the topmost nonce bit. BoringSSL em-
ploys Fermat’s little theorem to invert nonces securely. Due
to our ﬁndings, OpenSSL also switched to Fermat inversion.
Modular Multiplication. While OpenSSL uses blinding to
alleviate non-constant time code, LibreSSL removes blinding
too early, leaking the length of the inverse nonce.
6 Detailed Analysis
In the following, we present our analysis methodology and
discuss results and discovered vulnerabilities in detail.
Analysis Methodology. The process of tool-aided side-
channel analysis comprises a proper selection of algorithms
to test, the actual analysis phase and an interpretation of the
results. Since OpenSSL supports over 80 different elliptic
curves and countless compiler options, exhaustive testing of
each combination is impractical. We selected the default con-
ﬁguration as a basis for our analysis, and selectively enabled
different implementations of popular NIST curves. We tested
all three DSA parameter sets and focused on ECDSA curves
operating close to a machine word boundary. For the actual
analysis, we used our tool alongside manual code review to
speciﬁcally test relevant portions in the code. While the tool
helps uncover leakage, interpreting the results remains a man-
1772    29th USENIX Security Symposium
USENIX Association
0...0F
261EA02B
q
0...03
dmax,top
152A916C
k1
D07655A4
k2
dmax
top
Figure 1: OpenSSL/LibreSSL (V1): some nonces (k2) are
smaller than the average (k1) and the modulus q.
Table 3: OpenSSL/LibreSSL curves leaking L bits of
small (inverse) nonces (V1),(V10) on 32/64-bit systems.
L32 L64 Curve
– sect163r1
15.8
13.8
– sect163r2
9.0 9.0 sect233k1
– sect233r1
– sect239k1
– c2pnb163v1
– c2pnb163v2
– c2pnb163v3
L32 Curve
Curve
2.0 c2tnb359v1
secp112r1
2.0 c2tnb431r1
secp112r2
secp521r1
7.0 wap-wtls1
8.0 wap-wtls3
prime239v1 15.0
13.0 wap-wtls4
prime239v2 15.0
2.0 wap-wtls5
prime239v3 15.0
2.0 wap-wtls6
16.0
sect113r1
16.0
sect113r2
2.0 wap-wtls8
2.0 2.0 c2tnb239v1 13.0 wap-wtls10
sect131r1
sect131r2
2.0 2.0 c2tnb239v2 12.4 wap-wtls11
2.0
sect163k1
– c2tnb239v3 11.7
L32
0.8
1.7
16.0
2.0
16.0
2.0
15.8
16.0
7.0
8.0
which ﬁxes top to the maximum width in advance.2 Hence,
it is immune to the Bignumber-related leaks we found.
Small Nonce Vulnerability (V1). Nonces are generated in
the range [1,q− 1]. If the length of the modulus q is slightly
above a word boundary, it may happen that the generated
nonce uses fewer limbs than q. In Figure 1, the ﬁrst nonce k1
uses two limbs, whereas the second nonce k2 is represented
in one limb, as indicated by top. A side-channel attacker
learning the value of top can distinguish small nonces from
large ones and mount a key recovery attack.
In this example, q uses only four bits (0xF) of the topmost
limb. Thus, an attacker learns whether the four topmost bits
of k are zero. Consider w as the word size, i.e., the size of
one limb. For i386, w=32 and for x86_64, w=64. Thus, a
small nonce leaks L = log2(q) mod w bits, which occurs
every 2Lth signature on average. By collecting enough leaky
signatures, an attacker can recover the private key via lattice
or Bleichenbacher attacks (see Section 2.2).
In general, both DSA and ECDSA are affected by small
nonces. However, if L is too large, leaky signatures occur too
rarely to be practically exploitable. Since DSA moduli are
always (half)word-aligned, L = 32 or L = 64 and attacks are
impractical. On the other hand, for ECDSA, several curves
have a modulus (group order) that is slightly above a word
boundary. Table 3 lists all affected curves with L < 20, and
curves affected on 64-bit systems are marked bold. For exam-
ple, the sect131 curves leak 2 bits approximately every 4th
signature, while secp521r1 leaks 9 bits every 512th signature.
In order to exploit the small nonce vulnerability, an attacker
needs to learn the nonce length (i.e., the value of top). Since
the nonce is involved in many different computation steps,
there are plenty of opportunities for an attacker to observe its
2https://github.com/openssl/openssl/issues/6640
length. We found leakage in the nonce generation, scalar mul-
tiplication, and nonce inversion (Equations (3), (5) and (7)).
Details for OpenSSL and LibreSSL can be looked up in Ap-
pendix C. In the following, we focus on the most critical leak-
age present in the OpenSSL version patched against (V8). The
leaky code in Listing 1 converts the nonce stored in BIGNUM
a into its Montgomery representation. BIGNUM b holds a
Montgomery conversion factor. If both, a and b have the
full word length of q, denoted as num, the if branch will ex-
ecute an assembler-optimized multiplication (bn_mul_mont
in line 4) and terminate in line 5. If, however, the nonce a
is one limb smaller, OpenSSL falls back to the functions