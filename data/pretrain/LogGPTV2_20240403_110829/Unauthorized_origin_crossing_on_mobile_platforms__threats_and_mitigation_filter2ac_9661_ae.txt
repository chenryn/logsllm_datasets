(i.e.,  the  Dropbox  app)  as  the  only  legitimate  sender  origin  for 
these schemes. As a result, our reference monitor ensures that any 
invocation  of  the  schemes  comes  only  from  the  Dropbox  app, 
which  defeats  the  attacks  from  a  malicious  webpage  (through 
Facebook app or the Google Plus app). In the case of the attack 
using  the  Yelp  app  (second  vulnerability  described  in  Section 
3.3.2), the problem comes from that the recipient of the scheme 
message, the Facebook app, cannot tell whether the origin of the 
message is indeed Yelp or a malicious website visited by the Yelp 
app’s  WebView  instance.  In  the  presence  of  Morbs,  the  true 
origin of the message is revealed as the website’s domain, which 
enables  Facebook  to  thwart  the  attack.  Note  that  we  did  not 
actually run those fixes as the problems were found on iOS. 
Mediating issues in web-accessing utility classes. For the case 
of  the  WebView  callback  within  the  Facebook  app  (Section 
3.4.1),  this  callback  should  only  respond  to  the  event  (i.e., 
processing  the  fbrpc  URL)  when  this  URL  comes  from  the 
domains  under  Facebook’s  control.  Let’s  assume  Facebook  app 
specifies “https://*.facebook.com” as the whitelist associated with 
the callback class UIWebViewDelegate, an operation that can be 
easily  done  using  Morbs.  As  a  result,  the  event  initiated  from 
“attacker.com” is ignored by the WebView, without triggering the 
callback 
from 
facebook.com  continue  to  be  handled.  We  further  evaluated  our 
implementation  against  the  exploit  on  the  HttpClient  class 
(Section 3.4.2). This time, we set “https://*.dropbox.com” as the 
legitimate origin on the whitelist for the instance of the HttpClient 
class  used  in  the  Dropbox  app.  After  that,  we  found  that  even 
after  the  adversary  crossed  the  origins  through  the  next-intent 
channel,  he  still  cannot  steal  the  Dropbox  authentication  header 
by sending requests to a non-dropbox.com URL, because it was 
blocked by our reference monitor according to the whitelist. 
5.2  Performance 
We evaluated the performance of our implementation on a Nexus 
4 development phone. We compared the overhead of Morbs with 
the overall delay the user experiences in the absence of Morbs, to 
understand the performance impact that our approach can have on 
cross-origin communications. In the experiments, we call a Java 
API nanoTime to collect timing measurements at a precision of 1 
nanosecond (i.e., 10-9 s).  To measure the performance of a Morbs 
operation,  we  repeated  it  10  times  to  get  its  average  execution 
time.  The  operations  we  studied  include  setting  policies  and 
checking policy compliance.  Among them, the compliance check 
is the focus of our evaluations, as the policy setting is just a one-
time task. More specifically, we measured the delays for sending 
messages  through  intent,  scheme,  and  utility  classes  in  the 
absence of Morbs, and then compared them with the time spent on 
shouldStartLoadWithRequest,  while 
those 
a policy compliance check.  In all the cases, the impact of Morbs 
was found to be negligible (below 1%). 
Performance of Morbs operations. On the Android OS with our 
Morbs  implementation,  we  ran  a  test  app  to  invoke  the 
setOriginPolicy API, and measured the time for setting a policy. 
On average, this operation took 0.354 ms, which involves storing 
the content of the policy to a policy database maintained by the 
OS.  To check the compliance with the policies, Morbs needs to 
search the database to find out whether the origin of the current 
sender or recipient is whitelisted. As described in Section 4.1, we 
leverage the hash-table search to quickly locate the policies.  To 
understand  the  performance  of  this  operation,  we  utilized  a  test 
app to invoke another test app through an intent message, which 
triggered  the  checkOriginPolicy  function.  We  found  that  the 
whole compliance check process took 0.219 ms on average. Note 
that policy enforcement over other channels all utilizes the same 
ReferenceMonitor  class,  which  is  expected  to  bring  in  similar 
average delay. 
Impacts  on  mobile  communications.  As  described  above,  the 
performance impact of setting policies should be minimum, since 
it just incurs a one-time cost. Also for the policies declared within 
a manifest file, they are set when the app is installed, which does 
not  affect  its  operations.  Therefore,  our  focus  was  policy 
compliance check.  
In  the  study,  we  measured  the  overall  delays  for  sending  a 
message through intent, scheme, and web-accessing utility classes 
without the policy compliance check. Table 1 shows the average 
delays  for  such  communication,  and  their  comparison  with  the 
overhead for a compliance check (0.219 ms). This gives a pretty 
good  picture  about  the  impact  the  check  can  have  on  such 
channels.  Specifically,  for  the  intent  channel,  we  measured  the 
time  interval  between  the  invocation  of  startActivity  and  the 
execution  of  performCreate  (the  first  API  the  target  Activity 
needs  to  call).  After  repeating  the  operation  for  10  times,  we 
observed  an  average  delay  of  42.142  ms  when  the  sender  and 
recipient were the same app, and 46.267 ms when they were not 
(see Table 1).  On the other hand, the compliance check took only 
an average 0.219 ms.  Therefore, the impact of this mediation on 
the  intent  communication  was  around  0.5%.    For  the  scheme 
message  delivered  between  two  apps,  it  goes  through  the  same 
intent  mechanism.  The  mediation  impact  of  Morbs  on  this 
communication  was  found  to  be  0.3%  on  average.  We  further 
measured  the  time  a  webpage  takes  to  invoke  an  app  through 
scheme,  between  the  event  when  the  method  handleMessage  in 
WebViewCore class is triggered to process the scheme URL, and 
when the performCreate API for the target test app is called. We 
found that this whole process took 115.301 ms and the impact of 
the policy checking there was 0.2%. 
When  we  take  into  account  the  delays  incurred  by  web-related 
operations,  particularly  those  performed  by  the  methods  and 
callbacks of WebView and HttpClient class, the extra time spent 
on  the  policy  compliance  check  can  be  comfortably  ignored.  
Specifically,  we  measured  the  waiting  time  for  loading  a  URL 
(specifically,  google.com)  through  HttpClient,  and  WebView.  
For  HttpClient,  we  measured  the  time  interval  between  the 
creation  of  a  class  instance  and  the  point  when  the  instance 
receives the HTTP response, which took 225.035 ms on average. 
For WebView, we measured the interval between the start of page 
loading 
completion 
(onPageFinished 
took  692.955  ms.  By 
called) 
is  called),  which 
(onPageStarted 
and 
is 
its 
643comparison,  the  time  Morbs  spends  on  the  compliance  check 
(0.219 ms) become unnoticeable. 
Table 1 Impact of policy compliance check 
Table 2 Comparison of current fixes and the fixes with Morbs 
Problems 
Fix w/o Morbs 
Fix w. Morbs 
Channel 
Type of 
Communication 
intent 
scheme 
utility 
classes 
in-app 
cross-app 
app-app 
web-app 
HttpClient 
WebView 
Communication 
Delay w/o 
Morbs (ms) 
42.142 
46.267 
64.077 
115.301 
225.035 
692.955 
Impact of Morbs 
policy checking 
0.52% 
0.47% 
0.34% 
0.19% 
0.10% 
0.03% 
5.3  Compatibility and Developer’s Effort 
An  important  goal  of  Morbs  is  to  maintain  compatibility  when 
possible and minimize the developer’s effort to use its protection. 
Following we elaborate our study on these two issues. 
Compatibility.  To  see  whether  our  implementation  can  work 
with existing apps, we loaded Android with Morbs into a Nexus 4 
development  phone  and  evaluated  the  operations  of  top  20  free 
apps downloaded from Google Play market. Those apps were first 
analyzed: we disassembled their binary code and found that all of 
them use intent, 12 claim various schemes and all need to use the 
web through WebView and HttpClient classes. We then analyzed 
their  functionalities  in  the  presence  or  absence  of  Morbs 
mediation, by clicking on all buttons and using all of the services 
we could find.  During the test, we did not observed any deviation 
of those apps’ behaviors with and without our mechanism. 
Developer’s  effort.    As  discussed  before,  to  use  Morbs,  the 
developer  only  need  to  specify  her  whitelists  through  the 
interfaces  (e.g.,  the  setOriginPolicy  API)  we  provide,  which  is 
straightforward for them to act on.  This is compared to the case-
by-case fixes that app developers are currently doing in response 
to  our  vulnerability  reports.  In  Table  1,  we  give  a  comparison 
with  regard  to  the  vulnerabilities  described  in  Section  3.    The 
ways they are fixed (or to be fixed) (“Fix w/o Morbs”) come from 
our  conversations  with  corresponding  software  vendors.  Here, 
how to fix the problem 4 (the exploit through Yelp app) and 5 (the 
callback loophole) is still unknown. 
As  we  can  see  from  the  table,  these  vulnerabilities  are  much 
easier to fix with the support of Morbs. Specifically, for the next-
intent  problem  (Section  3.2.1),  both  Dropbox  and  Facebook 
informed us that an effective fix takes time to build. Particularly, 
Dropbox explained that they need to “change the architecture” of 
their app, which involves non-trivial effort. In the presence of our 
origin-based  protection,  however,  this  next-intent  cross-origin 
loophole is fixed without requiring any modification to the apps.  
As another example, for the fbconnect issue described in Section 
3.3.1, Facebook chose to deprecate the use of fbconnect, which is 
a  core  feature  in  all  of  its  native  SDKs  and  official  apps.  This 
effort  needs  “a  several  month  deprecation  period”,  according  to 
Facebook.  Using Morbs, however, Facebook could easily fix the 
problem  without  touching  any  of  its  SDKs  and  apps,  by  simply 
adding an extra header, including the origins of the apps supposed 
to receive its message, to the HTTP response its server sends to 
mobile devices. Overall, as shown in the table, the current fixes to 
these  problems  are  all  case  by  case,  while  our  solution  is 
consistent  in  the  way  to  set  origin-based  security  policies 
(whitelist of authorized origins) and enforce the policies.  
next-intent 
(Section 3.2.1) 
fbconnect 
(Section 3.3.1) 
Change architecture of the 
Dropbox  app  and 
the 
Facebook app  
this 
Deprecate 
feature 
(affecting  all  apps  with 
Facebook  SDKs, 
and 
taking several months) 
Dropbox 
SDK 
3.3.2) 
iOS 
(Section 
Change both the Dropbox 
apps and SDKs  
Yelp 
(Section 3.3.2) 
issue  
Unknown 
callback  exploit 
(Section 3.4.1) 
Unknown 
HTTPClient 
exploit  (Section 
3.4.2) 
Change  to  the  Dropbox 
app,  adding  code 
for 
checking  whether  a  URL 
is  from  dropbox.  com 
when 
attaching 
authorization header  
No modification 
Facebook server specifies 
recipient whitelist by setting a 
header in HTTP response 
“mobile- allowed-origins: 
app://com.facebook.katana”  
Dropbox SDK specifies sender 
whitelist by adding an entry 
“allowedOrigins: 
app://com.getdropbox.Dropbox” 
under “URL scheme” in .plist file. 
No modification 
Facebook app specifies sender 
whitelist by calling 
WebViewClient:setAllowedOrigi
ns(“https://*.facebook.com”) 
Dropbox app specifies recipient 
whitelist by calling 
HTTPClient.setAllowedOrigins(“
https://*.dropbox.com”). 
6.  RELATED WORK 
Origin-based  protection  in  web  browsers. 
  Origin-based 
protection is a cornerstone for browser security. All modern web 
browsers enforce the same-origin policy (SOP) [4] to protect the 
web content from one origin against unauthorized access from a 
different  origin.  Always  at  the  center  of  browser  security  is  the 
attacks that circumvent this protection, such as XSS, CSRF, login 
CSRF, and the defense that reinforces the browser and makes the 
protection  hard  to  bypass  [1][2][3].  Our  research  shows  that 