2Ã— improvement.
4 DIVISION AND TRUNCATION
,(cid:0)4
(cid:1)-OT1). Two calls to Î ğœ‚+1
(cid:1)-OT1)-hybrid.
0 , âŸ¨xtâŸ©ğµ
0 âŠ• ğ‘—âˆ—
MILL
1
1
We present our results on secure implementations of division in
the ring by a positive integer and truncation (division by power-
of-2) that are bitwise equivalent to the corresponding cleartext
computation. We begin with closed form expressions for each of
these followed by secure protocols that use them.
4.1 Expressing general division and truncation
using arithmetic over secret shares
Let idiv : Z Ã— Z â†’ Z denote signed integer division, where the
quotient is rounded towards âˆ’âˆ and the sign of the remainder is
the same as that of divisor. We denote division of a ring element by
a positive integer using rdiv : Zğ‘› Ã— Z â†’ Zğ‘› defined as
rdiv(ğ‘, ğ‘‘) â‰œ idiv(ğ‘ğ‘¢ âˆ’ 1{ğ‘ğ‘¢ â‰¥ âŒˆğ‘›/2âŒ‰} Â· ğ‘›, ğ‘‘) mod ğ‘›,
(2)
where the integer ğ‘ğ‘¢ âˆˆ {0, 1, . . . , ğ‘› âˆ’ 1} is the unsigned representa-
tion of ğ‘ âˆˆ Zğ‘› lifted to integers and 0 < ğ‘‘ < ğ‘›. For brevity, we use
ğ‘¥ =ğ‘› ğ‘¦ to denote ğ‘¥ mod ğ‘› = ğ‘¦ mod ğ‘›.
0 , âŸ¨ğ‘âŸ©ğ‘›
Theorem 4.1. (Division of ring element by positive integer). Let
1 âˆˆ Zğ‘›, for some ğ‘› = ğ‘›1 Â· ğ‘‘ + ğ‘›0 âˆˆ Z,
the shares of ğ‘ âˆˆ Zğ‘› be âŸ¨ğ‘âŸ©ğ‘›
where ğ‘›0, ğ‘›1, ğ‘‘ âˆˆ Z and 0 â‰¤ ğ‘›0 < ğ‘‘ < ğ‘›.
Let the unsigned representation of ğ‘, âŸ¨ğ‘âŸ©ğ‘›
0 , âŸ¨ğ‘âŸ©ğ‘›
1 in Zğ‘› lifted to inte-
gers be ğ‘ğ‘¢, ğ‘0, ğ‘1 âˆˆ {0, 1, . . . , ğ‘› âˆ’ 1}, respectively, such that ğ‘0 =
0 Â· ğ‘‘ + ğ‘0
1 âˆˆ Z and
0 and ğ‘1 = ğ‘1
ğ‘1
1, where ğ‘1
0, ğ‘1
0, ğ‘0
1 < ğ‘‘. Let ğ‘›â€² = âŒˆğ‘›/2âŒ‰ âˆˆ Z. Define corr, ğ´, ğµ, ğ¶ âˆˆ Z
0 â‰¤ ğ‘0
0, ğ‘0
1 Â· ğ‘‘ + ğ‘0
1, ğ‘0
7
as follows:
 âˆ’1
corr =
(ğ‘ğ‘¢ â‰¥ ğ‘›â€²) âˆ§ (ğ‘0 < ğ‘›â€²) âˆ§ (ğ‘1 < ğ‘›â€²)
(ğ‘ğ‘¢ < ğ‘›â€²) âˆ§ (ğ‘0 â‰¥ ğ‘›â€²) âˆ§ (ğ‘1 â‰¥ ğ‘›â€²)
1
0
1 âˆ’ (1{ğ‘0 â‰¥ ğ‘›â€²} + 1{ğ‘1 â‰¥ ğ‘›â€²} âˆ’ corr) Â· ğ‘›0.
0 + ğ‘0
ğ´ = ğ‘0
0 âˆ’ 1{ğ‘0 â‰¥ ğ‘›â€²} Â· ğ‘›0, ğ‘‘) + idiv(ğ‘0
ğµ = idiv(ğ‘0
ğ¶ = 1{ğ´ < ğ‘‘} + 1{ğ´ < 0} + 1{ğ´ < âˆ’ğ‘‘}
otherwise
,
1 âˆ’ 1{ğ‘1 â‰¥ ğ‘›â€²} Â· ğ‘›0, ğ‘‘)
Then, we have:
rdiv(âŸ¨ğ‘âŸ©ğ‘›
0 , ğ‘‘) + rdiv(âŸ¨ğ‘âŸ©ğ‘›
1 , ğ‘‘) + (corr Â· ğ‘›1 + 1 âˆ’ ğ¶ âˆ’ ğµ) =ğ‘› rdiv(ğ‘, ğ‘‘).
The proof of the above theorem is presented in Appendix C.
Special Case of truncation for â„“ bit integers. The expression
4.1.1
above can be simplified for the special case of division by 2ğ‘  of â„“-bit
integers, i.e., arithmetic right shift with ğ‘  (â‰« ğ‘ ), as follows:
0 , âŸ¨ğ‘âŸ©ğ¿
1 Â· 2ğ‘  + ğ‘0
0 and ğ‘1 = ğ‘1
Corollary 4.2. (Truncation for â„“-bit integers). Let the shares
of ğ‘ âˆˆ Zğ¿ be âŸ¨ğ‘âŸ©ğ¿
1 âˆˆ Zğ¿. Let the unsigned representation of
1 in Zğ¿ lifted to integers be ğ‘ğ‘¢, ğ‘0, ğ‘1 âˆˆ {0, 1, . . . , 2â„“ âˆ’ 1},
0 , âŸ¨ğ‘âŸ©ğ¿
ğ‘, âŸ¨ğ‘âŸ©ğ¿
0 Â· 2ğ‘  + ğ‘0
respectively, such that ğ‘0 = ğ‘1
1, where
1 âˆˆ Z and 0 â‰¤ ğ‘0
1 < 2ğ‘ . Let corr âˆˆ Z be defined as in
1, ğ‘0
0, ğ‘0
0, ğ‘1
ğ‘1
0, ğ‘0
Theorem 4.1. Then, we have:
(ğ‘0 â‰« ğ‘ ) + (ğ‘1 â‰« ğ‘ ) + corr Â· 2â„“âˆ’ğ‘  + 1{ğ‘0
1 â‰¥ 2ğ‘ } =ğ¿ (ğ‘ â‰« ğ‘ ).
Proof. The corollary follows directly from Theorem 4.1 as fol-
lows: First, (ğ‘ â‰« ğ‘ ) = rdiv(ğ‘, 2ğ‘ ). Next, ğ‘› = 2â„“, ğ‘›1 = 2â„“âˆ’ğ‘ , and
1, ğµ = 0 and ğ¶ = 1{ğ´ < 2ğ‘ } =
ğ‘›0 = 0. Using these, we get ğ´ = ğ‘0
1{ğ‘0
â–¡
4.2 Protocols for division
1 < 2ğ‘ }.
0 + ğ‘0
0 + ğ‘0
0 + ğ‘0
In this section, we describe our protocols for division in different
settings. We first describe a protocol for the simplest case of trun-
cation for â„“-bit integers followed by a protocol for general division
in Zğ‘› by a positive integer (Section 4.2.2). Finally, we discuss an-
other simpler case of truncation, which allows us to do better than
general division for rings with a special structure (Section 4.2.3).
4.2.1 Protocol for truncation of â„“-bit integer. Let F int,â„“,ğ‘ 
Trunc be
the functionality that takes arithmetic shares of ğ‘ as input and
returns arithmetic shares of ğ‘ â‰« ğ‘  as output. In this work, we
give a protocol (Algorithm 5) that realizes the functionality F int,â„“,ğ‘ 
Trunc
correctly building on Corollary 4.2.
Intuition. Parties ğ‘ƒ0 & ğ‘ƒ1 first invoke an instance of F int,â„“
DReLU (where
one party locally flips its share of DReLU(ğ‘)) to get boolean shares
âŸ¨ğ‘šâŸ©ğµ
lating âŸ¨corrâŸ©ğ¿
Next, they use an instance of F ğ‘ 
ğ‘ = 1{ğ‘0
0 + ğ‘0
using a call to F ğ¿
Correctness and Security. For any ğ‘§ âˆˆ Zğ¿, MSB(ğ‘§) = 1{ğ‘§ğ‘¢ â‰¥ 2â„“âˆ’1},
where ğ‘§ğ‘¢ is unsigned representation of ğ‘§ lifted to integers. First, note
0 , âŸ¨ğ‘šâŸ©ğµ
that Reconstğµ(âŸ¨ğ‘šâŸ©ğµ
1 ) = MSB(ğ‘)
DReLU. Next, we show that Reconstğ¿(âŸ¨corrâŸ©ğ¿
by correctness of F int,â„“
0 ,
1 ) = corr, as defined in Corollary 4.2. Let ğ‘¥ğ‘ = MSB(âŸ¨ğ‘âŸ©ğ¿
ğ‘)
âŸ¨corrâŸ©ğ¿
ğ‘ , i.e., arithmetic shares of corr term in Corollary 4.2.
MILL to compute boolean shares of
1 â‰¥ 2ğ‘ }. Finally, they compute arithmetic shares of ğ‘
ğ‘ of MSB(ğ‘). Using these shares, they use a(cid:0)4
(cid:1)-OTâ„“ for calcu-
1 ) = 1âŠ•Reconstğµ(âŸ¨ğ›¼âŸ©ğµ
B2A (Algorithm 7).
0 , âŸ¨ğ›¼âŸ©ğµ
1
ğ‘ âˆˆ Z be as defined in Corollary 4.2.
, ğ‘1
ğ‘ to learn
0 âŠ• ğ‘—0 âŠ• ğ‘—1) s.t.
ğ‘ , where ğ‘ âˆˆ Zğ¿.
ğ‘ s.t. ğ‘§ = ğ‘ â‰« ğ‘ .
Algorithm 5 Truncation, Î int,â„“,ğ‘ 
Trunc:
Input: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ holds âŸ¨ğ‘âŸ©ğ¿
Output: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ learns âŸ¨ğ‘§âŸ©ğ¿
1: For ğ‘ âˆˆ {0, 1}, let ğ‘ğ‘, ğ‘0
2: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ invokes F int,â„“
ğ‘ . Party ğ‘ƒğ‘ sets âŸ¨ğ‘šâŸ©ğµ
output âŸ¨ğ›¼âŸ©ğµ
ğ‘
DReLU with input âŸ¨ğ‘âŸ©ğ¿
ğ‘ = âŸ¨ğ›¼âŸ©ğµ
ğ‘ âŠ• ğ‘.
3: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ sets ğ‘¥ğ‘ = MSB(âŸ¨ğ‘âŸ©ğ¿
ğ‘).
4: ğ‘ƒ0 samples âŸ¨corrâŸ©ğ¿
$â† Z2â„“ .
0
5: for ğ‘— = {00, 01, 10, 11} do
ğ‘ƒ0 computes ğ‘¡ ğ‘— = (âŸ¨ğ‘šâŸ©ğµ
6:
if ğ‘¡ ğ‘— âˆ§ 1{ğ‘¥0 = 0} then
ğ‘ƒ0 sets ğ‘  ğ‘— =ğ¿ âˆ’âŸ¨corrâŸ©ğ¿
0 âˆ’ 1.
else if ğ‘¡ ğ‘— âˆ§ 1{ğ‘¥0 = 1} then
ğ‘ƒ0 sets ğ‘  ğ‘— =ğ¿ âˆ’âŸ¨corrâŸ©ğ¿
0 + 1.
else
ğ‘ƒ0 sets ğ‘  ğ‘— =ğ¿ âˆ’âŸ¨corrâŸ©ğ¿
0 .
0 âŠ• ğ‘—0 âŠ• ğ‘¥0) âˆ§ (âŸ¨ğ‘šâŸ©ğµ
ğ‘— = ( ğ‘—0|| ğ‘—1).
7:
8:
9:
10:
11:
12:
13:
14: end for
1
end if
15: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of(cid:0)4
(cid:1)-OTâ„“, where ğ‘ƒ0 is the sender
0 âŠ• âŸ¨ğ‘šâŸ©ğµ
ğ‘ = (âŸ¨ğ‘âŸ©ğ¿
ğ‘ â‰« ğ‘ ) + âŸ¨corrâŸ©ğ¿
18: ğ‘ƒğ‘ outputs âŸ¨ğ‘§âŸ©ğ¿
ğ‘ and learns âŸ¨ğ‘‘âŸ©ğ¿
ğ‘ .
and ğ‘ƒ1â€™s input as ğ‘0
input âŸ¨ğ‘âŸ©ğµ
ğ‘ Â· 2â„“âˆ’ğ‘  + âŸ¨ğ‘‘âŸ©ğ¿
1 ||ğ‘¥1). Then, ğ‘¡ ğ‘—âˆ— = (âŸ¨ğ‘šâŸ©ğµ
16: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of F ğ‘ 
17: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ invokes an instance of F ğ¿
with inputs {ğ‘  ğ‘—} ğ‘— and ğ‘ƒ1 is the receiver with input âŸ¨ğ‘šâŸ©ğµ
and learns âŸ¨corrâŸ©ğ¿
1 .
1. For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ learns âŸ¨ğ‘âŸ©ğµ
ğ‘ .
1 ||ğ‘¥1
MILL with ğ‘ƒ0â€™s input as 2ğ‘ âˆ’1âˆ’ğ‘0
0
B2A (ğ¿ = 2â„“) with
ğ‘ , ğ‘ âˆˆ {0, 1}.
for ğ‘ âˆˆ {0, 1}, and let ğ‘—âˆ— = (âŸ¨ğ‘šâŸ©ğµ
0 âŠ• âŸ¨ğ‘šâŸ©ğµ
1 âŠ•
ğ‘¥0) âˆ§ (âŸ¨ğ‘šâŸ©ğµ
1 âŠ• ğ‘¥1) = (MSB(ğ‘) âŠ• ğ‘¥0) âˆ§ (MSB(ğ‘) âŠ• ğ‘¥1). Now,
ğ‘¡ ğ‘—âˆ— = 1 implies that we are in one of the first two cases of expression
for corr â€“ which case we are in can be checked using ğ‘¥0 (steps 7
0 + corr = âŸ¨corrâŸ©ğ¿
& 9). Now it is easy to see that ğ‘  ğ‘—âˆ— = âˆ’âŸ¨corrâŸ©ğ¿
1 .
1 ) = âŸ¨ğ‘âŸ©ğµ
0 âŠ•
0 , âŸ¨ğ‘âŸ©ğµ
1 â‰¥ 2ğ‘ }. Given boolean shares of ğ‘, step 17, cre-
âŸ¨ğ‘âŸ©ğµ
ates arithmetic shares of the same using an instance of F ğ¿
B2A. Since
âŸ¨corrâŸ©ğ¿
0 is uniformly random, security of our protocol is easy to see
in (F int,â„“
B2A)-hybrid.
, F ğ¿
DReLU
Communication complexity. Î int,â„“,ğ‘ 
Trunc involves a single call each to
F int,â„“
MILL. Hence, communication required
is < ğœ†â„“ + 2ğœ† + 19â„“+ communication for F ğ‘ 
DReLU
MILL that depends on
parameter ğ‘ . For â„“ = 32 and ğ‘  = 12, our concrete communication is
MILL inside Î int,32
4310 bits (using ğ‘š = 7 for Î 12
DReLU)
as opposed to 24064 bits for garbled circuits.
(cid:1)-OTâ„“, F ğ‘ 
,(cid:0)4
(cid:1)-OTâ„“, F ğ¿
Next, by correctness of F ğ‘ 
1 = 1{ğ‘0
MILL, ğ‘ = Reconstğµ(âŸ¨ğ‘âŸ©ğµ
MILL as well as Î 31
B2A and F ğ‘ 
,(cid:0)4
0 + ğ‘0
MILL
1
1
4.2.2 Protocol for division in ring. Let F ring,ğ‘›,ğ‘‘
be the func-
tionality for division that takes arithmetic shares of ğ‘ as input and
returns arithmetic shares of rdiv(ğ‘, ğ‘‘) as output. Our protocol builds
on our closed form expression from Theorem 4.1. We note that â„“-bit
integers is a special case of Zğ‘› and we use the same protocol for
DIV
8
division of an element in Zğ¿ by a positive integer.
Intuition. This protocol is similar to the previous protocol for trun-
cation and uses the same logic to compute shares of corr term. Most