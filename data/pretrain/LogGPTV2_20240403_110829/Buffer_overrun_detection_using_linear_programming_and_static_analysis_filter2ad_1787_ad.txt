### Constraint Generation and Context Sensitivity

Using this approach to constraint generation, we obtain the following ranges:
- For `cc1!alloc` and `cc1!used`: [0..2047] and [1..2048], respectively.
- For `cc2!alloc` and `cc2!used`: [0..1023] and [1..1024], respectively.

These ranges represent an improvement over the values reported in Figure 4.

#### Constraint Inlining
When using the constraint inlining approach, we can determine the value of a variable within a specific calling context. The calling context is encoded implicitly in the renamed variable. However, this method has limitations:
- It can lead to an exponential number of calling contexts, resulting in a large number of variables and constraints.
- It does not support recursive function calls.

#### Summary Information
To overcome these drawbacks, we can use summary information, as suggested by Sharir and Pnueli [28]. In this inter-procedural dataflow analysis, a "summary" is generated for each function. This summary information is used at each callsite to simulate the effect of the call.

For example, a function's summary constraints can be generated to summarize its effect on global variables and formal parameters. This is equivalent to projecting the constraints generated by the function onto these variables. Several well-known solutions exist for this problem:
- If the function generates only difference constraints, the problem reduces to an instance of the all-pairs shortest path algorithm [12, 19].
- For more general constraints, the Fourier-Motzkin variable elimination algorithm [16] can be used.

Consider the `copy buffer` function, which does not modify or use global variables. The summary constraints are:
- `copy buffer$return!alloc!max ≥ buffer!used!max - 1`
- `copy buffer$return!used!max ≥ buffer!used!max`
- `copy buffer$return!alloc!min ≤ buffer!used!min - 1`
- `copy buffer$return!used!min ≤ buffer!used!min`

To achieve context sensitivity, these constraints are applied at each callsite with the formal parameters replaced by the corresponding actuals. For example, at line (7), the constraint variables for `buffer` and `copy buffer$return` are replaced with those for `header` and `cc1`, respectively. Similarly, at line (10), the relationship between `cc2` and `buf` is obtained by substituting them for `copy buffer$return` and `buffer` in the summary constraints.

This approach is more efficient than constraint inlining because it does not increase the number of constraint variables. However, it is less precise because the values of the variables are merged across different calling contexts, leading to a loss of precision. For instance, in the program in Figure 2, the values for `cc1!used`, `cc1!alloc`, `cc2!used`, and `cc2!alloc` are the same as those obtained using constraint inlining, but the values for `copy!alloc` and `copy!used` are [0..2047] and [1..2048], respectively, due to the merging of values from different calls.

#### Handling Recursive Function Calls
This approach can handle recursive function calls, although our prototype implementation does not attempt to summarize them for simplicity.

### Experience with the Tool

We tested our prototype implementation on several popular commercial programs. In each case, the tool produced multiple warnings, which we used, combined with CodeSurfer features like slicing, to check for real overruns. We verified if the tool discovered known overruns documented in public databases such as bugtraq [1] and CERT [2], and also checked for previously unreported overruns. Our results for wu-ftpd and sendmail are detailed below, with additional results available in [19].

#### Experimental Setup
Our experiments were conducted on a 3GHz Pentium-4 Xeon processor machine with 4GB RAM, running Debian GNU/Linux 3.0. We used CodeSurfer-1.8 and gcc-3.2.1 for building the programs. CodeSurfer implements several pointer analysis algorithms, and we used a field-sensitive version of Andersen’s analysis [6] that incorporates the common-initial-prefix technique of Yong and Horwitz [34] to handle structure casts. The tool was configured to use the hierarchical solver described in Section 4.3 for constraint resolution, producing constraints in a context-insensitive fashion. Section 6.4 discusses the effects of context-sensitive constraint generation.

#### WU-FTP Daemon
We tested two versions of the wu-ftp daemon, a popular file transfer server:
- **Version 2.5.0**: An older version with several known vulnerabilities (see CERT advisories CA-1999-13, CA-2001-07, and CA-2001-33).
- **Version 2.6.2**: The current version with security patches addressing known vulnerabilities.

##### wu-ftpd-2.6.2
- **Lines of Code**: Approximately 18K
- **Warnings Produced**: 178

Upon examining the warnings, we found 14 previously unreported overruns. One of these is detailed below:

**Potential Overrun in `read_servers_line`**
- **File**: rd-servers.c
- **Buffer**: `accesspath`
- **Issue**: Up to 8192 bytes could be copied into a buffer allocated for 4095 bytes.

```c
int read_servers_line (FILE *svrfp, char *hostaddress, char *accesspath) {
    static char buffer[BUFSIZ];
    ...
    while (fgets(buffer, BUFSIZ, svrfp)) {
        ...
        if ((hp = gethostbyname(hcp))) {
            struct in_addr in;
            memmove(&in, hp->h_addr, sizeof(in));
            strcpy(hostaddress, inet_ntoa(in));
        } else
            strcpy(hostaddress, hcp);
        strcpy(accesspath, acp);
    }
}
```

The `fgets` statement may copy up to 8192 bytes into `buffer`, which is further processed. By appropriate manipulation of `buffer`, `acp` or `hcp` could point to a string buffer as long as 8190 bytes, potentially causing an overflow in `accesspath` or `hostname`.

**Calls to `read_servers_line`**
- **Location**: Main procedure in ftprestart.c
- **Buffers**: `hostaddress` (32 bytes) and `configdir` (4095 bytes)
- **Input File**: PATH FTPSERVERS, typically with privileged access but writable by a local user in non-standard configurations.

**Solution**: Replacing `strcpy` with `strncpy` or `strlcpy` in `read_servers_line` rectifies the problem.

**Other New Overruns Detected**
- **Unchecked `sprintf` in `main` (ftprestart.c)**: Could write 16383 bytes into a 4095-byte buffer.
- **Another Unchecked `sprintf` in `main` (ftprestart.c)**: Could write 8447 bytes into a 4095-byte buffer.
- **Unchecked `strcpy` in `main` (ftprestart.c)**: Could write 8192 bytes into a 4095-byte buffer.

In each case, a carefully chosen input string in PATH FTPACCESS can cause the overrun. We contacted the wu-ftpd developers, who acknowledged the bugs and are working on fixes.

##### wu-ftpd-2.5.0
- **Lines of Code**: Approximately 16K
- **Warnings Produced**: 139

We analyzed the warnings to check for a widely exploited overrun reported in CERT advisory CA-1999-13. The buffer overflow was on a globally declared buffer `mapped_path` in the `do_elem` procedure in ftpd.c. The issue was due to `strcat(mapped_path, dir)`, where `dir` could be derived from user input. Our tool reported the range for `mapped_path!used` as [0..+∞] and `mapped_path!alloc` as [4095..4095].

**Modeling `strcat(dst, src)`**
- **Constraints**:
  - `dst!used!max ≥ dst!used!max + src!used!max`
  - `dst!used!min ≤ dst!used!min + src!used!min`
  - `dst!used!max ≥ dst`
  - `dst!used!min ≤ dst`

The first two constraints make the linear program infeasible, setting `dst!used!max` to +∞. Hence, `mapped_path!used!max` is set to +∞, and the tool would report the same range even without an overrun. Using CodeSurfer’s program slicing feature, we confirmed that `dir` could be derived from user input. The `do_elem` procedure, called from `mapping_chdir`, which in turn is called from `cmd`, whose input arguments can be controlled by the user, highlights the importance of providing end users with program analysis features.

#### Sendmail
Sendmail is a popular mail transfer agent. We analyzed:
- **sendmail-8.7.6**: An old version released after a code audit of version 8.7.5, with several known vulnerabilities.
- **sendmail-8.11.6**: Vulnerable to two new buffer overrun vulnerabilities reported in March 2003.

##### sendmail-8.7.6
- **Lines of Code**: Approximately 38K
- **Warnings Produced**: 295

Due to the large number of warnings, we focused on detecting known overruns. Wagner et al. [30] reported an off-by-one bug in `queuename` in sendmail-8.9.3, where up to 21 bytes could be written into a 20-byte array `dfname`. Our tool identified four possible program points in sendmail-8.7.6 where the return value from `queuename` is copied using `strcpy` statements into buffers allocated 20 bytes. The tool reported that the return value from `queuename` could be up to 257 bytes long, requiring further manual analysis to confirm the off-by-one bug. Another minor off-by-one bug was reported where `delimbuf` (allocated 3 bytes) stored "\n\t ", which is 4 bytes long including the null terminator.

##### sendmail-8.11.6
- **Lines of Code**: Approximately 68K
- **Warnings Produced**: 453

We examined the warnings to check if the tool discovered the new vulnerabilities reported in March 2003. One vulnerability is in the `crackaddr` function in headers.c, which parses an incoming email address string. The function stores the address string in a local static buffer `buf` (declared as MAXNAME + 1 bytes) and performs boundary checks. However, the condition handling angle brackets (<> ) in the From address string is imprecise, leading to an overflow [5].

**Tool Report**
- **Pointer `bp`**: `bp!alloc!max = +∞` and `bp!used!max = +∞`
- **Reason**: Several pointer arithmetic statements, particularly `bp--`, resulted in `bp!alloc!max` and `bp!used!max` being set to +∞. This warning would exist even if the boundary checks were correct.

This bug is challenging to track precisely in a flow-insensitive analysis. Control dependence information, associating each statement with the predicate that decides its execution, is crucial for reliable detection. We are working to enhance our infrastructure to support these features.

### Performance
Table 1 contains representative numbers from our experiments with wu-ftpd-2.6.2 and sendmail-8.7.6. All timings were obtained using the UNIX `time` command. `CODESURFER` denotes the time taken by CodeSurfer to analyze the program, and `GENERATION` denotes the time taken to generate constraints.