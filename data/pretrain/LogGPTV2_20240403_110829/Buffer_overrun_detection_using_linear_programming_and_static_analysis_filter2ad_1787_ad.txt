With this approach to constraint generation, we obtain the range
[0..2047] and [1..2048] for cc1!alloc and cc1!used respectively,
while cc2!alloc and cc2!used obtain [0..1023] and [1..1024]
respectively, which is an improvement over the values reported in
Figure 4.
Note that using the constraint inlining approach, we can obtain
the value of a variable with a particular calling context (the call-
ing context will be encoded implicitly in the renamed variable).
However, this comes at a price – since we can have an exponential
number of calling contexts, the constraint system will have a large
number of variables, and as a result, a large number of constraints.
Moreover, this approach cannot work with recursive function calls.
These drawbacks can be overcome through the use of summary
information. In this approach to inter-procedural dataﬂow analysis,
ﬁrst suggested by Sharir and Pnueli [28], a “summary” is obtained
for each function foo, and the summary information is used at each
callsite to foo to “simulate” the effect of the call.
In our case, a function can be summarized by generating sum-
mary constraints, which summarize the effect of a function in terms
of the constraint variables representing global variables and formal
parameters of the function. This is equivalent to ﬁnding a pro-
jection of the constraints generated by the function on the global
variables and the formal parameters of the function. This problem
has several well-known solutions. In particular, if the function gen-
erates only difference constraints, then the problem of ﬁnding the
summary constraints reduces to an instance of the all-pairs shortest
path algorithm [12, 19], for which several efﬁcient algorithms are
known. For more general kinds of constraints, the Fourier-Motzkin
variable elimination algorithm [16] can be used.
Consider, for instance, constraints generated by copy buffer.
This function does not modify or use global variables, and hence
we obtain the summary constraints (shown below) by projecting
the constraints on the formal parameters of this function.
copy buffer$return!alloc!max ≥ buffer!used!max - 1
copy buffer$return!used!max ≥ buffer!used!max
copy buffer$return!alloc!min ≤ buffer!used!min - 1
copy buffer$return!used!min ≤ buffer!used!min
To obtain context sensitivity, we use these constraints at each
callsite to copy buffer with the formal parameters appearing in
the summary constraints replaced with the corresponding actuals.
Constraints are generated at line (7) by replacing the constraint
variables corresponding to buffer and copy buffer$return in
the summary constraints with the constraint variables correspond-
ing to header and cc1 respectively. Similarly, the relationship
between cc2 and buf at line (10) can be obtained by substituting
them in place of copy buffer$return and buffer respectively,
in the summary constraints. Note that we must still retain the as-
signment of the actual variable to the formal-in parameter so that
we can obtain the values of the constraint variables corresponding
to the local variables of the called function.
This approach is more efﬁcient than the constraint inlining ap-
proach since it does not cause an increase in the number of con-
straint variables. However it is also less precise than constraint
inlining because of the same reason. Observe that in constraint in-
lining the variables were renamed at each callsite, thus enabling us
to examine their values due to a particular calling context. On the
other hand, in the summary constraints approach the values of the
variables are merged across different calling contexts, thus leading
to loss of precision. For instance, consider the program in Fig-
ure 2. While the values for cc1!used, cc1!alloc, cc2!used
and cc2!alloc are the same as obtained using constraint inlin-
ing, the values of copy!alloc and copy!used are [0..2047] and
[1..2048] respectively. This is because the values that these vari-
ables obtained due to calls at line (7) and line (10) are “merged”.
The constraint inlining approach returns the values [0..2047] and
[1..2048] for copy!alloc and copy!used respectively due to the
call at line (7), and returns [0..1023] and [1..1024] due to the call
at line (10).
This approach is capable of handling recursive function calls,
however for simplicity we do not attempt to summarize recursive
function calls in our prototype implementation.
6. EXPERIENCE WITH THE TOOL
We tested our prototype implementation on several popular com-
mercially used programs. In each case, the tool produced several
warnings; we used these warnings, combined with CodeSurfer fea-
tures such as slicing, to check for real overruns. We tested to
see if the tool discovered known overruns documented in public
databases such as bugtraq [1] and CERT [2], and also checked
to see if any overruns that were previously unreported were dis-
covered. We report our experience with wu-ftpd and sendmail.
Results on a few more packages are in [19].
Our experiments were performed on a 3GHz Pentium-4 Xeon
processor machine with 4GB RAM, running Debian GNU/Linux 3.0.
We used CodeSurfer-1.8 for our experiments, the gcc-3.2.1 com-
piler for building the programs. CodeSurfer implements several
pointer analysis algorithms; in each case we performed the experi-
ments with a ﬁeld-sensitive version of Andersen’s analysis [6] that
uses the common-initial-preﬁx technique of Yong and Horwitz [34]
to deal with structure casts. We conﬁgured the tool to use the hi-
erarchical solver described in Section 4.3 for constraint resolution
(so the values obtained will be precise) and produce constraints in
a context-insensitive fashion. Section 6.4 discusses the effects of
context-sensitive constraint generation.
6.1 WU-FTP Daemon
We tested two versions of the wu-ftp daemon, a popular ﬁle
transfer server. Version 2.5.0 is an older version with several
known vulnerabilities (see CERT advisories CA-1999-13, CA-2001-
07 and CA-2001-33), while version 2.6.2 is the current version
with several security patches that address the known vulnerabili-
ties.
6.1.1 wu-ftpd-2.6.2
wu-ftpd-2.6.2 has about 18K lines of code, and produced 178
warnings when examined by our tool. Upon examining the warn-
ings, we found 14 previously unreported overruns; we will describe
one of these in detail.
The tool reported a potential overrun on a buffer pointed to by
accesspath in the procedure read servers line in the ﬁle rd-
servers.c, where as many as 8192 bytes could be copied into the
buffer for which up to 4095 bytes were allocated. Figure 7 shows
the code snippet from read servers line which is responsible
for the overrun.
int read_servers_line (FILE *svrfp,
char *hostaddress,
char *accesspath){
static char buffer[BUFSIZ];
...
while (fgets(buffer, BUFSIZ, svrfp)){
...
if ((hp = gethostbyname(hcp))){
struct in_addr in;
memmove(&in, hp->h_addr, sizeof(in));
strcpy(hostaddress, inet_ntoa(in));
}
else
strcpy(hostaddress, hcp);
strcpy(accesspath, acp);
}
}
Figure 7: Code snippet from wu-ftpd-2.6.2
The fgets statement may copy as many as 8192 (BUFSIZ) bytes
into buffer, which is processed further in this function. As a result
of this processing, acp and hcp point to locations inside buffer.
By an appropriate choice of the contents of buffer, one could
make acp or hcp point to a string buffer as long as 8190 bytes,
which could result in an overﬂow on the buffer pointed to either by
accesspath or hostname respectively.
The procedure read servers line is called at several places
in the code. For instance, it is called in the main procedure in ft-
prestart.c where read servers line is called with two local
buffers, hostaddress and configdir, which have been allocated
32 bytes and 4095 bytes respectively. This call reads the contents
of the ﬁle PATH FTPSERVERS, which typically has privileged ac-
cess. However, in non-standard and unusual conﬁgurations of the
system, PATH FTPSERVERS could be written to by a local user. As
a result, the buffers hostaddress and configdir can overﬂow
based on a carefully chosen input string, possibly leading to a local
exploit. The use of a strncpy or strlcpy statement instead of the
unsafe strcpy in read servers line rectiﬁes the problem.
A few other new overruns which were detected by the tool were:
• An unchecked sprintf in main in the ﬁle ftprestart.c could
result in 16383 bytes being written into a local buffer that was al-
located 4095 bytes.
• Another unchecked sprintf in main in the ﬁle ftprestart.c
could result in 8447 bytes being written into a local buffer that was
allocated 4095 bytes.
• An unchecked strcpy in main in the ﬁle ftprestart.c could
result in 8192 bytes being written into a local buffer that was allo-
cated 4095 bytes.
In each of the above cases, a carefully chosen string in the ﬁle
PATH FTPACCESS can be used to cause the overrun. As before,
PATH FTPACCESS typically has privileged access, but could be
written to by a local user in non-standard conﬁgurations. We con-
tacted the wu-ftpd developers, and they have acknowledged the
presence of these bugs in their code, and are in the process of ﬁx-
ing the bugs (at the time of writing this paper).
6.1.2 wu-ftpd-2.5.0
wu-ftpd-2.5.0 has about 16K lines of code; when analyzed
by our tool, it produced 139 warnings. We analyzed the warnings
to check for a widely exploited overrun reported in CERT advi-
sory CA-1999-13. The buffer overﬂow was on a globally declared
buffer mapped path in the procedure do elem in the ﬁle ftpd.c.
It was noted in [22] that the overrun was due to a statement str-
cat(mapped path, dir), where the variable dir could be de-
rived (indirectly) from user input. As a result it was possible to
overﬂow mapped path for which 4095 bytes were allocated. Our
tool reported the range for mapped path!used as [0..+∞], while
mapped path!alloc was [4095..4095]. The call strcat(dst,
src) would be modeled as four linear constraints by our tool:
!used!max ≥ dst!used!max + src!used!max
!used!min ≤ dst!used!min + src!used!min
dst
dst!used!max ≥ dst
dst
dst!used!min ≤ dst
!used!max
!used!min
(cid:1)
(cid:1)
(cid:1)
(cid:1)
The ﬁrst two constraints make the linear program infeasible, as ex-
plained in Section 4, and result in dst!used!max being set to +∞.
Hence, in wu-ftpd-2.5.0, mapped path!used!max will be set
to +∞, and the tool would have reported the same range even in
the absence of an overrun. We used CodeSurfer’s program slic-
ing feature to conﬁrm that dir could be derived from user input.
We found that the procedure do elem, one of whose parameters is
dir, was called from the procedure mapping chdir. This function
was in turn called from the procedure cmd, whose input arguments
could be controlled by the user. This shows the importance of pro-
viding the end user with several program analysis features. These
features, such as program slicing and control and data dependence
predecessors, which are part of CodeSurfer, aid the user of the tool
to understand the source code better and hence locate the source of
the vulnerability.
6.2 Sendmail
Sendmail is a very popular mail transfer agent. We analyzed
sendmail-8.7.6, an old version that was released after a thor-
ough code audit of version 8.7.5. However, this version has sev-
eral known vulnerabilities. We also analyzed sendmail-8.11.6;
in March 2003, two new buffer overrun vulnerabilities were re-
ported in the then latest version of sendmail. Both sendmail-
8.7.6 and sendmail-8.11.6 are vulnerable to these overruns as
well.
6.2.1 sendmail-8.7.6
sendmail-8.7.6 has about 38K lines of code; when analyzed
by our tool, it produced 295 warnings. Due to the large number
of warnings, we focused on scanning the warnings to detect some
known overruns.
Wagner et al. use BOON to report an off-by-one bug [30] in
sendmail-8.9.3 where as many as 21 bytes, returned by a func-
tion queuename, could be written into a 20 byte array dfname. Our
tool identiﬁed four possible program points in sendmail-8.7.6
where the return value from queuename is copied using strcpy
statements into buffers which are allocated 20 bytes. As in [30],
our tool reported that the return value from queuename could be
up to 257 bytes long, and further manual analysis was required
to decipher that this was in fact an off-by-one bug. Another mi-
nor off-by-one bug was reported by the tool where the programmer
mistakenly allocated only 3 bytes for the buffer delimbuf which
stored "\n\t ", which is 4 bytes long including the end of string
character.
6.2.2 sendmail-8.11.6
sendmail-8.11.6 is signiﬁcantly larger than version 8.7.6
and has 68K lines of code; when we ran our tool, it produced 453
warnings. We examined the warnings to check if the tool discov-
ered the new vulnerabilities reported in March 2003.
One of these vulnerabilities is on a function crackaddr in the
ﬁle headers.c, which parses an incoming e-mail address string.
This function stores the address string in a local static buffer called
buf that is declared to be MAXNAME + 1 bytes long, and performs
several boundary condition checks to see that buf does not over-
ﬂow. However, the condition that handles the angle brackets (<>)
in the From address string is imprecise, thus leading to the over-
ﬂow [5].
Our tool reported that bp, a pointer to the buffer buf in the func-
tion had bp!alloc!max = +∞ and bp!used!max = +∞, thus
raising an warning. However, the reason that bp!alloc!max and
bp!used!max were set to +∞ was because of several pointer arith-
metic statements in the body of the function. In particular, the state-
ment bp-- resulted in bp!alloc!max = +∞ and bp!used!max =
+∞. Hence, this warning would have existed even if the boundary
condition checks were correct.
We note that this bug is hard to track precisely in a ﬂow-insensitive
analysis. Moreover, we have discovered that the use of control de-
pendence information, which associates each statement with the
predicate that decides whether the statement will be executed, is
crucial to detecting such overruns reliably. We are working towards
enhancing our infrastructure to support these features.
6.3 Performance
Table 1 contains representative numbers from our experiments
with wu-ftpd-2.6.2 and sendmail-8.7.6. All timings were
obtained using the UNIX time command. CODESURFER denotes
the time taken by CodeSurfer to analyze the program, GENERA-