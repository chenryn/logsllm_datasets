---
author: Marty Kalin
category: 技术
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 8960
date: '2020-08-13 15:03:00'
editorchoice: false
excerpt: 通过 OpenSSL 深入了解密码学的细节：哈希值、数字签名、数字证书等。
fromurl: https://opensource.com/article/19/6/cryptography-basics-openssl-part-2
id: 12511
islctt: true
largepic: /data/attachment/album/202008/13/150012t7zwwk6x7wr69wih.jpg
permalink: /article-12511-1.html
pic: /data/attachment/album/202008/13/150012t7zwwk6x7wr69wih.jpg.thumb.jpg
related:
- displayorder: 0
  raid: 11810
reviewer: wxy
selector: lujun9972
summary: 通过 OpenSSL 深入了解密码学的细节：哈希值、数字签名、数字证书等。
tags:
- OpenSSL
thumb: false
title: 如何使用 OpenSSL：哈希值、数字签名等
titlepic: true
translator: wxy
updated: '2020-08-13 15:03:00'
---
> 
> 通过 OpenSSL 深入了解密码学的细节：哈希值、数字签名、数字证书等。
> 
> 
> 
![](/data/attachment/album/202008/13/150012t7zwwk6x7wr69wih.jpg)
[本系列的第一篇文章](/article-11810-1.html)通过 OpenSSL 库和命令行实用程序介绍了哈希、加密/解密、数字签名和数字证书。这第二篇文章将对细节进行深入探讨。让我们从计算中无处不在的哈希开始，并考虑是什么使哈希函数*具备密码学意义*。
### 密码学哈希
OpenSSL 源代码的[下载页面](https://www.openssl.org/source/)包含了一个带有最新版本的表格。每个版本都有两个 哈希值   hash ：160 位 SHA1 和 256 位 SHA256。这些值可以用来验证下载的文件是否与存储库中的原始文件相匹配：下载者在本地重新计算下载文件的哈希值，然后将结果与原始文件进行比较。现代系统有计算这种哈希值的实用程序。例如，Linux 有 `md5sum` 和 `sha256sum`。OpenSSL 本身也提供了类似的命令行实用程序。
哈希值被用于计算的许多领域。例如，比特币区块链使用 SHA256 哈希值作为区块标识符。挖比特币就是生成一个低于指定阈值的 SHA256 哈希值，也就是至少有 N 个前导零的哈希值。（N 的值可以上升或下降，这取决于特定时间的挖矿生产力）。作为一个兴趣点，如今的矿机是为并行生成 SHA256 哈希值而设计的硬件集群。在 2018 年的一个高峰期，全球的比特币矿工每秒产生约 7500 万个 太哈希值   terahash  —— 这真是一个不可思议的数字。
网络协议也使用哈希值（在这里通常叫做“ 校验和   checksum ”）来支持消息的完整性；也就是说，保证收到的消息与发送的消息是一样的。消息发送者计算消息的校验和，并将结果与消息一起发送。当消息到达时，接收方重新计算校验和。如果发送的校验和与重新计算的校验和不一致，那么消息在传输过程中可能出现了一些问题，或者发送的校验和出现了问题，或者两者都出现了问题。在这种情况下，应该重新发送消息和它的校验和，或者至少应该触发一个错误情况。（如 UDP 这样的低级网络协议不会理会校验和。）
哈希的其他例子大家都很熟悉。比如一个网站，要求用户用密码进行验证，用户在浏览器中输入密码，然后，他们通过 HTTPS 连接到服务器，密码从浏览器加密发送到服务器。一旦密码到达服务器，就会被解密，然后进行数据库表的查询。
在这个查询表中应该存储什么？存储密码本身是有风险的。风险要小得多的方式是存储一个由密码生成的哈希值，也许在计算哈希值之前“加一些 盐   salt （额外的位）改善口味”。你的密码可能会被发送到 Web 服务器上，但网站可以向你保证，密码不会存储在那里。
哈希值还出现在安全的各个领域。例如， 基于哈希值的消息认证码   hash-based message authentication code （[HMAC](https://en.wikipedia.org/wiki/HMAC)）使用一个哈希值和一个秘密的 加密密钥   cryptographic key 来认证通过网络发送的消息。HMAC 码轻量级且易于在程序中使用，在 Web 服务中很受欢迎。一个 X509 数字证书包括一个称为 指纹   fingerprint 的哈希值，它可以方便证书验证。一个存放于内存中的 可信存储   truststore 可以实现为一个以这种指纹为键的查找表 —— 作为一个支持恒定查找时间的 哈希映射   hash map 。来自传入的证书的指纹可以与可信存储中的密钥进行比较，以确定是否匹配。
 密码学哈希函数   cryptographic hash function 应该具有什么特殊属性？它应该是 单向   one-way 的，这意味着很难被逆转。一个加密哈希函数应该是比较容易计算的，但是计算它的反函数（将哈希值映射回输入位串的函数）在计算上应该是困难的。下面是一个描述，用 `chf` 作为加密哈希函数，我的密码 `foobar` 作为样本输入。
```
        +---+
foobar—>|chf|—>hash value ## 简单直接
        +--–+
```
相比之下，逆向操作是不可行的：
```
            +-----------+
hash value—>|chf inverse|—>foobar ## 棘手困难
            +-----------+
```
例如，回忆一下 SHA256 哈希函数。对于一个任意长度为 N > 0 的输入位串，这个函数会生成一个 256 位的固定长度的哈希值；因此，这个哈希值甚至不会反映出输入位串的长度 N，更不用说字符串中每个位的值了。顺便说一下，SHA256 不容易受到   长度扩展攻击    length extension attack 。唯一有效的逆向工程方法是通过蛮力搜索将计算出的 SHA256 哈希值逆向返回到输入位串，这意味着需要尝试所有可能的输入位串，直到找到与目标哈希值匹配的位串。这样的搜索在 SHA256 这样一个完善的加密哈希函数上是不可行的。
现在，最后一个回顾的知识点是 有序   in order 。加密哈希值是统计学上的唯一，而不是无条件的唯一，这意味着两个不同的输入位串产生相同的哈希值是不太可能的，但也不是不可能的 —— 这称之为 碰撞   collision 。[生日问题](https://en.wikipedia.org/wiki/Birthday_problem)提供了一个很好的反直觉的碰撞例子。对各种哈希算法的 抗碰撞性   collision resistance 有着广泛的研究。例如，MD5（128 位哈希值）在大约 2 21 次哈希之后，抗碰撞能力就会崩溃。对于 SHA1（160 位哈希值），大约在 2 61 次哈希后开始崩溃。
对于 SHA256 的抗碰撞能力的剖析，目前还没有一个很好的估计。这个事实并不奇怪。SHA256 有 2 256 个不同的哈希值范围，这个数字的十进制表示法有 78 位之多！那么，SHA256 哈希会不会发生碰撞呢？当然可能，但可能性极小。
在下面的命令行示例中，有两个输入文件被用作位串源：`hashIn1.txt` 和 `hashIn2.txt`。第一个文件包含 `abc`，第二个文件包含 `1a2b3c`。
为了便于阅读，这些文件包含的是文本，但也可以使用二进制文件代替。
在命令行（百分号 `%` 是提示符）使用 Linux `sha256sum` 实用程序对这两个文件进行处理产生以下哈希值（十六进制）:
```
% sha256sum hashIn1.txt
9e83e05bbf9b5db17ac0deec3b7ce6cba983f6dc50531c7a919f28d5fb3696c3 hashIn1.txt
% sha256sum hashIn2.txt
3eaac518777682bf4e8840dd012c0b104c2e16009083877675f00e995906ed13 hashIn2.txt
```
OpenSSL 哈希对应的结果与预期相同：
```
% openssl dgst -sha256 hashIn1.txt
SHA256(hashIn1.txt)= 9e83e05bbf9b5db17ac0deec3b7ce6cba983f6dc50531c7a919f28d5fb3696c3
% openssl dgst -sha256 hashIn2.txt
SHA256(hashIn2.txt)= 3eaac518777682bf4e8840dd012c0b104c2e16009083877675f00e995906ed13
```
这种对密码学哈希函数的研究，为我们仔细研究数字签名及其与密钥对的关系奠定了基础。
### 数字签名
顾名思义， 数字签字   digital signature 可以附在文件或其他一些电子 工件   artifact （如程序）上，以证明其真实性。因此，这种签名类似于纸质文件上的手写签名。验证数字签名就是要确认两件事：第一，被担保的工件在签名被附上后没有改变，因为它部分是基于文件的加密学哈希值。第二，签名属于一个人（例如 Alice），只有她才能获得一对密钥中的私钥。顺便说一下，对代码（源码或编译后的代码）进行数字签名已经成为程序员的普遍做法。
让我们来了解一下数字签名是如何创建的。如前所述，没有公钥和私钥对就没有数字签名。当使用 OpenSSL 创建这些密钥时，有两个独立的命令：一个是创建私钥，另一个是从私钥中提取匹配的公钥。这些密钥对用 base64 编码，在这个过程中可以指定它们的大小。
 私钥   private key 由数值组成，其中两个数值（一个 模数   modulus 和一个 指数   exponent ）组成了公钥。虽然私钥文件包含了 公钥   public key ，但提取出来的公钥并**不会**透露相应私钥的值。
因此，生成的带有私钥的文件包含了完整的密钥对。将公钥提取到自己的文件中是很实用的，因为这两把钥匙有不同的用途，而这种提取方式也将私钥可能被意外公开的危险降到最低。
接下来，这对密钥的私钥被用来生成目标工件（如电子邮件）的哈希值，从而创建签名。在另一端，接收者的系统使用这对密钥的公钥来验证附在工件上的签名。
现在举个例子。首先，用 OpenSSL 生成一个 2048 位的 RSA 密钥对：
```