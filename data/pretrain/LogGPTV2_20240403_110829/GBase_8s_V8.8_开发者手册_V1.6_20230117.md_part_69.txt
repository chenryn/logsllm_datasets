 重做日志接口
 恢复接口
 真空接口
为了支持所有缺失的功能，SQL层和FDW接口层已扩展，从而为插入MOT事务存储
引擎提供必要的基础设施。
结果：线性扩容
以下是上述MOT设计原则和实现的结果：
MOT在符合ACID工作负载的事务吞吐量方面优于所有现有的工业级OLTP数据库。
13.3.2 MOT 并发控制机制
通过大量研究，我们找到了最佳的并发控制机制，结论为：基于SILO 的OCC算法是
MOT中最符合ACID特性的OCC算法。SILO 为满足MOT的挑战性需求提供了最好的基
础。
MOT完全符合原子性、一致性、隔离性、持久性（ACID）特性，如MOT简介所述。
下面介绍MOT的并发控制机制。
南大通用数据技术股份有限公司
492
GBase 8s V8.8开发者手册
13.3.3 MOT 本地内存和全局内存
SILO管理本地内存和全局内存，如图13-3所示。
全局内存是所有核共享的长期内存，主要用于存储所有的表数据和索引。
本地内存是短期内存，主要由会话使用，用于处理事务及将数据更改存储到事务内存中，
直到提交阶段。
当事务需要更改时，SILO将该事务的所有数据从全局内存复制到本地内存。使用OCC
方法，全局内存中放置的是最小的锁，因此争用时间极短。事务更改完成后，该数据从本地
内存回推到全局内存中。
本地内存与SILO增强并发控制的基本交互式事务流如下所示：
图 13-3 私有（本地）内存（每个事务）和全局内存（所有核的所有事务）
13.3.4 MOT SILO 增强特性
SILO凭借其基本算法流程，优于我们在研究实验中测试的许多其他符合ACID的OCC
算法。然而，为了使SILO成为产品级机制，我们必须用许多在最初设计中缺失的基本功能
来增强它，例如：
 新增对交互式事务的支持，其中事务的SQL运行在客户端实现，而不是作为服务器端
的单个步骤运行。
 新增乐观插入。
 新增对非唯一索引的支持。
南大通用数据技术股份有限公司
493
GBase 8s V8.8开发者手册
 新增对事务中写后读校验（RAW）的支持，使用户能够在提交之前查看更改。
 新增对无锁协同垃圾回收的支持。
 新增对无锁检查点的支持。
 新增对快速恢复的支持。
13.3.5 MOT 隔离级别
即使MOT完全兼容ACID，GBase8s并非支持所有的隔离级别。下表介绍了各隔离级
别，以及MOT支持和不支持的内容。
表 13-3 隔离级别
隔离级别 说明
READUNCOMMITTED MOT不支持
MOT支持
READCOMMITTED（读已提交）隔离级别保证任何正在读取
的数据在上一次读取时都已提交。它只是限制读者看到任何中
READCOMMITTED
间数据、未提交数据或脏读。数据被读取后可以自由更改，因
此，读已提交隔离级别并不保证事务再次读取时能找到相同的
数据。
MOT不支持
SNAPSHOT（快照）隔离级别提供与SERIALIZABLE（可序列
化）相同的保证，同时支持并发事务修改数据。相反，它迫使
SNAPSHOT
每个读者看到自己的世界版本（自己的快照）。不阻止并发更
新使得编程非常容易，且可扩展性很强。然而，在许多实现中，
这种隔离级别需要更高的服务器资源。
MOT支持
REPEATABLEREAD（可重复读）是一个更高的隔离级别，除
了READCOMMITTED隔离级别的保证之外，它还保证任何读
取的数据都不能更改。如果一个事务再次读取相同的数据，它
REPEATABLEREAD
将找出该数据，不做更改，并且保证它可读取。
乐观模型使得并发事务能更新该事务读取的行。在提交时，该
事务将验证REPEATABLEREAD 隔离级别是否被违反。若违
反，则回滚该事务，必须重试。
南大通用数据技术股份有限公司
494
GBase 8s V8.8开发者手册
MOT不支持
SERIALIZABLE（可序列化）隔离提供了更强的保证。除了
REPEATABLEREAD隔离级别保证的所有内容外，它还保证后
SERIALIZABLE
续读取不会看到新数据。
它之所以被命名为SERIALIZABLE，是因为隔离非常严格，几
乎有点像事务串行运行，而不是并行运行。
下表显示了不同隔离级别启用的并发副作用。
表 13-4 隔离级别启用的并发副作用
隔离级别 说明 不可重复读 幻读
READ
是 是 是
UNCOMMITTED
READCOMMITTED 否 是 是
REPEATABLE
否 否 是
READ
SNAPSHOT 否 否 否
SERIALIZABLE 否 否 否
13.3.6 MOT 乐观并发控制
并发控制模块（简称CC模块）提供了主内存引擎的所有事务性需求。CC模块的主要
目标是为主内存引擎提供各种隔离级别的支持。
13.3.6.1 乐观 OCC 与悲观 2PL
悲观2PL（2阶段锁定）和乐观并发控制（OCC）的功能差异在于对事务完整性分别采
用悲观和乐观方法。
基于磁盘的表使用悲观方法，这是最常用的数据库方法。MOT引擎使用的是乐观方法。
悲观方法和乐观方法的主要功能区别在于，如果冲突发生，
 悲观的方法会导致客户端等待；
 而乐观方法会导致其中一个事务失败，使得客户端必须重试失败的事务。
南大通用数据技术股份有限公司
495
GBase 8s V8.8开发者手册
乐观并发控制方法（MOT使用）
乐观并发控制（OCC）方法在冲突发生时检测冲突，并在提交时执行验证检查。
乐观方法开销较小，而且通常效率更高，原因之一是事务冲突在大多数应用程序中并不
常见。
当强制执行REPEATABLEREAD隔离级别时，乐观方法与悲观方法之间的函数差异更
大，而当强制执行SERIALIZABLE隔离级别时，函数差异最大。
悲观方法（MOT未使用）
悲观并发控制（2PL，或称2阶段锁定）方法使用锁阻止在潜在冲突的发生。执行语句
时应用锁，提交事务时释放锁。基于磁盘的行存储使用这种方法，并且添加了多版本并发控
制（Multi-versionConcurrencyControl，MVCC）。
在2PL算法中，当一个事务正在写入行时，其他事务不能访问该行；当一个行正在读
取时，其他事务不能覆盖该行。在访问时锁定每个行，以进行读写；在提交时释放锁。这些
算法需要一个处理和避免死锁的方案。死锁可以通过计算等待图中的周期来检测。死锁可以
通过使用TSO保持时序或使用某种回退方案来避免。
遇时锁定（ETL）
另一种方法是遇时锁定（ETL），它以乐观的方式处理读取，但写入操作锁定它们访问
的数据。因此，来自不同ETL事务的写入操作相互感知，并可以决定中止。实验证明，ETL
通过两种方式提高OCC的性能：
 首先，ETL会在早期检测冲突，并通常能增加事务吞吐量。这是因为事务不会执行无
用的操作。（通常）在提交时发现的冲突无法在不中止至少一个事务的情况下解决。
 其次，ETL写后读校验（RAW）运行高效，无需昂贵或复杂的机制。
结论：
OCC是大多数工作负载最快的选项。这一点我们在初步研究阶段已经发现。
其中一个原因是，当每个核执行多个线程时，锁很可能被交换线程持有，特别是在交互
模式下。另一个原因是悲观算法涉及死锁检测（产生开销），并通常使用读写锁（比标准自
旋锁效率低）。
我们选择Silo是因为它比其他现有选项（如TicToc）简单，同时对大多数工作负载保
持相同的性能。ETL有时比OCC 更快，但它引入了假中止，可能会使用户混淆，而OCC
则只在提交时中止。
南大通用数据技术股份有限公司
496
GBase 8s V8.8开发者手册
13.3.6.2 OCC 与 2PL 的区别举例
下面是会话同时更新同一个表时，两种用户体验的区别：悲观（针对基于磁盘的表）和
乐观（针对MOT表）。
本例中，使用如下表测试命令：
table “TEST” – createtabletest(xint,yint,zint,primarykey(x));
本示例描述同一测试的两个方面：用户体验（本示例中的操作）和重试要求。
悲观方法示例——用于基于磁盘的表
下面是一个悲观方法例子（非MOT）。任何隔离级别都可能适用。
以下两个会话执行尝试更新单个表的事务。
WAITLOCK 操作发生，客户端体验是：会话2卡住，直到会话1完成COMMIT，会
话2才能进行。
但是，使用这种方法时，两个会话都成功，并且不会发生异常中止（除非应用了
SERIALIZABLE或REPEATABLE-READ隔离级别），这会导致整个事务需要重试。
表 13-5 悲观方法代码示例
时间 会话1 会话2
t0 Begin Begin
t1 updatetestsety=200wherex=1;
Update test sety=300 where x=1; –Wait
t2 y=200
onlock
t4 Commit
Unlock
Commit
(in READ-COMMITTED this will
succeed,inSERIALIZABLEitwillfail)
y=300
乐观方法示例——用于MOT
南大通用数据技术股份有限公司
497
GBase 8s V8.8开发者手册
下面是一个乐观方法的例子。
它描述了创建一个MOT表，然后有两个并发会话同时更新同一个MOT表的情况。
createforeigntabletest(xint,yint,zint,primarykey(x));
 OCC的优点是，在COMMIT之前没有锁。
 OCC的缺点是，如果另一个会话更新了相同的记录，则更新可能会失败。如果更新失
败（在所有支持的隔离级别中），则必须重试整个会话#2事务。
 更新冲突由内核在提交时通过版本检查机制检测。
 会话2将不会等待其更新操作，并且由于在提交阶段检测到冲突而中止。
表 13-6 乐观方法代码示例——用于MOT
时间 会话1 会话2
t0 Begin Begin
update test set y=200 where
t1
x=1;
Update test set y=300 where
t2 y=200
x=1;
t4 Commit y=300
Commit
ABORT
y=200
13.3.7 扩展 FDW 与其他特性
GBase8s是基于PostgreSQL的。但PostgreSQL没有内置存储引擎适配器，如MySQL
的handlerton。为了在GBase8s数据库中集成MOT存储引擎，利用并扩展了现有的FDW
机制，可以将这些外表和数据源呈现为统一、本地可访问的关系来访问外部管理的数据库。
和PostgreSQL不同的是，MOT存储引擎是嵌入在GBase8s数据库内部的，表由GBase
8s管理。GBase8s规划器和执行器控制表的访问。MOT从GBase8s获取日志和检查点服务，
并参与恢复过程和其他过程。
南大通用数据技术股份有限公司
498
GBase 8s V8.8开发者手册
我们把正在使用或正在访问MOT存储引擎的所有组件称为封装。
下图显示了MOT存储引擎如何嵌入到数据库中，及其对数据库功能的双向访问。
图 13-4GBase8s内置MOT存储引擎——外部数据库的FDW访问
我们通过扩展和修改FdwRoutine结构来扩展FDW的能力，以便引入在MOT引入之前
不需要的特性和调用。例如，新增了对以下功能的支持：添加索引、删除索引/表、截断、
真空和表/索引内存统计。重点放在了FdwRoutine结构与日志、复制和检查点机制的集成，
以便通过故障为跨表事务提供一致性。在这种情况下，MOT本身有时会通过FDW层发起
对GBase8s功能的调用。
创建表和索引
为了支持MOT表的创建，重用了标准的FDW语法。
例如，创建FOREIGN表。
MOTDW机制将指令传递给MOT存储引擎，用于实际建表。同样，我们支持创建索
引（createindex …）。此功能以前在FDW中不可用，因为表由外部管理，不需要此功能。
为了在MOTFDW中支持两者，ValidateTableDef函数实际上创建了指定的表。它还处
理该关系的索引创建、DROP TABLE 和 DROP INDEX 以及先前在 FDW 中不支持的
VACUUM和ALTERTABLE。
索引规划与执行的使用方法
查询分为两个阶段：规划和执行。在规划阶段（可能在多次执行中才出现一次），选择
南大通用数据技术股份有限公司
499
GBase 8s V8.8开发者手册
扫描的最佳索引。该选择基于匹配查询的WHERE子句、JOIN子句和ORDERBY条件。在
执行期间，查询迭代相关的表行，并执行各种任务，如每次迭代的更新或删除。插入是一种
特殊情况——表将行添加到所有索引中，且不需要扫描。
 规划器：在标准FDW中，将查询传递给外部数据源执行。这意味着索引过滤和实际规
划（例如索引的选择）不在数据库中本地执行，而是在外部数据源中执行。在内部，FDW
向数据库规划器返回总体计划。MOT 表的处理方式与磁盘表类似。这意味着相关的
MOT索引得到过滤和匹配，最小化遍历行集的索引被选择并添加到计划中。
 执行器：查询执行器使用所选的MOT索引来迭代表的相关行。每个行都由GBase8s
封装检查，根据查询条件调用update或delete处理相应的行。
持久性、复制性和高可用性
存储引擎负责存储、读取、更新和删除底层内存和存储系统中的数据。存储引擎不处理
日志、检查点和恢复，特别是因为某些事务包含多个不同存储引擎的表。因此，为了数据持
久化和复制，GBase8s封装使用如下高可用性设施：
 持久性：MOT 引擎通过WAL记录使数据持久化，WAL记录使用GBase 8s的XLOG
接口。这为GBase8s提供了使用相同API进行复制的好处。具体请参见MOT持久性
概念。
 检查点设定：通过向GBase8sCheckpointer注册回调来启用MOT检查点每当执行通用
数据库检查点时，MOT检查点也被调用。MOT保留了检查点的日志序列号（LSN），
以便与GBase8s恢复对齐。MOTCheckpointing算法是高度优化的异步算法，不会停止
并发事务。具体请参见MOT检查点概念。
 恢复：启动时，GBase 8s首先调用MOT回调，通过加载到内存行并创建索引来恢复
MOT检查点，然后根据检查点的LSN重放记录来执行WAL恢复。MOT检查点使用多
线程并行恢复，每个线程读取不同的数据段。这使MOT检查点在多核硬件上的恢复速
度相当快，尽管可能比仅重放WAL记录的基于磁盘的表慢一些。具体请参见MOT恢
复概念。
VACUUM和DROP
为了最大化MOT功能，我们增加了对VACUUM、DROPTABLE和DROPINDEX的支
持。这三个操作都使用排他表锁执行，这意味着不允许在表上并发事务。系统VACUUM调
用一个新的FDW函数执行MOT真空，而ValidateTableDef()函数中增加了DROP。
删除内存池
南大通用数据技术股份有限公司
500
GBase 8s V8.8开发者手册
每个索引和表都跟踪它使用的所有内存池。DROPINDEX命令用于删除元数据。内存
池作为单个连续块被删除。MOTVACUUM只对已使用的内存进行压缩，因为内存回收由基
于epoch的垃圾收集器（GC）在后台持续进行。为了执行压缩，我们将索引或表切换到新
的内存池，遍历所有实时数据，删除每行并使用新池插入数据，最后删除池，就像执行DROP
那样。
查询本机编译（JIT）
MOT引擎的FDW适配器还包含一个轻量级执行路径，该路径使用LLVM编译器执行
JIT编译查询。有关MOT查询本机编译的更多信息可以在MOT查询原生编译（JIT）一节
中找到。
13.3.8 NUMA-aware 分配和亲和性
非统一内存访问（NUMA）是一种计算机内存设计，用于多重处理，其中内存访问时间
取决于内存相对于处理器的位置。处理器可以利用NUMA的优势，优先访问本地内存（速
度更快），而不是访问非本地内存（这意味着它不会访问另一个处理器的本地内存或处理器
之间共享的内存）。
MOT内存访问设计时采用了NUMA感知。即MOT意识到内存不是统一的，而是通过
访问最快和最本地的内存来获得最佳性能。
NUMA的优点仅限于某些类型的工作负载，特别是数据通常与某些任务或用户强相关