}
??'
^
??!
|
??•
~
除此之外不进行其它替换。 说明:三字符序列是 ANSI 标准新引入的特征。
A.12.2          行连接
通过将以反斜杠\结束的指令行末尾的反斜杠和其后的换行符删除掉。可以将若干指令行 合并成一行。这种处理要在分隔记号之前进行。
A.12.3          宏定义和扩展
类似于下列形式的控制指令:
#define 标识符 记号序列 将使得预处理器把该标识符后续出现的各个实例用给定的记号序列替换。记号序列前后的空
白符都将被丢弃掉。第二次用#define 指令定义同一标识符是错误的，除非第二次定义中的
标记序列与第一次相同(所有的空白分隔符被认为是相同的)。
类似于下列形式的指令行:
#define 标识符(标识符表 opt) 记号序列 是一个带有形式参数(由标识符表指定)的宏定义，其中第一个标识符与圆括号(之间没有
空格。同第一种形式一样，记号序列前后的空白符都将被丢弃掉。如果要对宏进行重定义，
则必须保证其形式参数个数、拼写及记号序列都必须与前面的定义相同。
类似于下列形式的控制指令:
#undef 标识符
用于取消标识符的预处理器定义。将#undef 应用于未知标识符(即未用#define 指令定义 的标识符)并不会导致错误。
按照第二种形式定义宏时，宏标识符(后面可以跟一个空白符，空白符是可选的)及其 后用一对圆括号括起来的、由逗号分隔的记号序列就构成了一个宏调用。宏调用的实际参数 是用逗号分隔的记号序列，用引号或嵌套的括号括起来的逗号不能用于分隔实际参数。在处 理过程中，实际参数不进行宏扩展。宏调用时，实际参数的数目必须与定义中形式参数的数 目匹配。实际参数被分离后，前导和尾部的空白符将被删除。随后，由各实际参数产生的记 号序列将替换未用引号引起来的相应形式参数的标识符(位于宏的替换记号序列中)。除非替 换序列中的形式参数的前面有一个#符号，或者其前面或后面有一个##符号，否则，在插入前 要对宏调用的实际参数记号进行检查，并在必要时进行扩展。
两个特殊的运算符会影响替换过程。首先，如果替换记号序列中的某个形式参数前面直 接是一个#符号(它们之间没有空白符)，相应形式参数的两边将被加上双引号(")，随后，# 和形式参数标识符将被用引号引起来的实际参数替换。实际参数中的字符串字面值、字符常 量两边或内部的每个双引号(")或反斜杠(\)前面都要插入一个反斜杠(\)。
其次，无论哪种宏的定义记号序列中包含一个##运算符，在形式参数替换后都要把##及 其前后的空白符都删除掉，以便将相邻记号连接起来形成一个新记号。如果这样产生的记号 无效，或者结果依赖于##运算符的处理顺序，则结果没有定义。同时，##也可以不出现在替 换记号序列的开头或结尾。
对这两种类型的宏，都要重复扫描替换记号序列以查找更多的已定义标识符。但是。当 某个标识符在某个扩展中被替换后，再次扫描并再次遇到此标识符时不再对其执行替换，而 是保持不变。
即使执行宏扩展后得到的最终结果以#打头，也不认为它是预处理指令。 说明:有关宏扩展处理的细节信息，ANSI 标准比第 1 版描述得更详细。最重要的变化是
加入了#和##运算符，这就使得引用和连接成为可能。某些新规则(特别是与连接有关的规则)
比较独特(参见下面的例子)。
例如，这种功能可用来定义"表示常量"，如下例所示:
#define TABSIZE 100 int table[TABSIZE];
定义
#define ABSDIFF(a, b)              ((a)>(b) ? (a)•(b) : (b)•(a))
定义了一个宏，它返回两个参数之差的绝对值。与执行同样功能的函数所不同的是，参数与 返回值可以是任意算术类型，甚至可以是指针。同时，参数可能有副作用，而且需要计算两 次，一次进行测试，另一次则生成值。
假定有下列定义:
#define tempfile(dir)              #dir "%s"
宏调用 tempfile(/usr/tmp)将生成
"/usr/tmp" "%s"
随后，该结果将被连接为一个单个的字符串。给定下列定义:
#define cat(x, y)              x ## y
那么，宏调用 cat(var, 123)将生成 var123。但是，宏调用 cat(cat(1,2),3)没有定 义:##阻止了外层调用的参数的扩展。因此，它将生成下列记号串:
cat              (              1              ,              2              )3
并且，)3 (不是一个合法的记号，它由第一个参数的最后一个记号与第二个参数的第一个记 号连接而成。如果再引入第二层的宏定义，如下所示:
#define xcat(x, y)              cat(x,y)
我们就可以得到正确的结果。xcat(xcat(1, 2), 3)将生成 123，因为 xcat 自身的扩展 不包含##运算符。
类似地，ABSDIFF(ABSDIFF(a,b),c)将生成所期望的经完全扩展后的结果。
A.12.4          文件包含
下列形式的控制指令:
#include 
将把该行替换为文件名指定的文件的内容。文件名不能包含>或换行符。如果文件名中包含字 符"、'、\、或/*，则其行为没有定义。预处理器将在某些特定的位置查找指定的文件，查 找的位置与具体的实现相关。
类似地，下列形式的控制指令:
#include "文件名"
首先从源文件的位置开始搜索指定文件(搜索过程与具体的实现相关)，如果没有找到指 定的文件，则按照第一种定义的方式处理。如果文件名中包含字符'、\、或/*，其结果仍然 是没有定义的，但可以使用字符>。
最后，下列形式的指令行:
#include 记号序列 同上述两种情况都不同，它将按照扩展普通文本的方式扩展记号序列进行解释。记号序列必
须被解释为或"..."两种形式之一，然后再按照上述方式进行相应的处理。
#include 文件可以嵌套。
A.12.5          条件编译
对一个程序的某些部分可以进行条件编译，条件编译的语法形式如下:
预处理器条件:
if 行文本 elif 部分 opt else 部分 opt #endif if 行:
#if 常量表达式
#ifdef 标识符
#ifndef 标识符
elif 部分:
elif 行 文本 elif 部分 opt elif 行:
#elif 常量表达式
else 部分:
else 行 文本
else 行:
#else
其中，每个条件编译指令(if 行、elif 行、else 行以及#endif)在程序中均单独占一行。 预处理器依次对#if 以及后续的#elif 行中的常量表达式进行计算，直到发现某个指令的常 量表达式为非 0 值为止，这时将放弃值为 0 的指令行后面的文本。常量表达式不为 0 的#if 和#elif 指令之后的文本将按照其它普通程序代码一样进行编译。在这里，"文本"是指任何 不属于条件编译指令结构的程序代码，它可以包含预处理指令，也可以为空。一旦预处理器 发现某个#if 或#elif 条件编译指令中的常量表达式的值不为 0，并选择其后的文本供以后 的编译阶段使用时，后续的#elif 和#else 条件编译指令及相应的文本将被放弃。如果所有 常量表达式的值都为 0，并且该条件编译指令链中包含一条#else 指令。则将选择#else 指 令之后的文本。除了对条件编译指令的嵌套进行检查之外，条件编译指令的无效分支(即条 件值为假的分支)控制的文本都将被忽略。
#if 和#elif 中的常量表达式将执行通常的宏替换。并且，任何下列形式的表达式:
defined 标识符 或
Defined(标识符)
都将在执行宏扫描之前进行替换，如果该标识符在预处理器中已经定义，则用 1 替换它，否
则，用 0 替换。预处理器进行宏扩展之后仍然存在的任何标识符都将用 0 来替换。最后，每
个整型常量都被预处理器认为其后面跟有后缀 L，以便把所有的算术运算都当作是在长整型或 无符号长整型的操作数之间进行的运算。
进行上述处理之后的常量表达式(参见    A.7.19    节)满足下列限制条件:它必须是整型， 并且其中不包含 sizeof、强制类型转换运算符或枚举常量。
下列控制指令:
#ifdef 标识蒋
#ifndef 标识符 分别等价于:
#if defined 标识符
#if !defined 标识符
说明:#elif 是 ANSI 中新引入的条件编译指令，但此前它已经在某些预处理器中实现 了。defined 预处理器运算符也是 ANSI 中新引入的特征。
A.12.6          行控制
为了便于其它预处理器生成 C 语言程序，下列形式的指令行:
#line 常量 "文件名"
#line 常量 将使编译器认为(出于错误诊断的目的):下一行源代码的行号是以十进制整型常量的形式给
出的，并且，当前的输入文件是由该标识符命名的。如果缺少带双引号的文件名部分，则将
不改变当前编译的源文件的名字。行中的宏将先进行扩展，然后再进行解释。
A.12.7          错误信息生成
下列形式的预处理器控制指令:
#error 记号序列 opt
将使预处理器打印包含该记号序列的诊断信息。
A.12.8          pragma
下列形式的控制指令:
#pragma 记号序列 opt
将使预处理器执行一个与具体实现相关的操作。无法识别的    pragma(编译指示)将被忽略掉。
A.12.9          空指令
下列形式的预处理器行不执行任何操作:
#
A.12.10预定义名字
某些标识符是预定义的，扩展后将生成特定的信息。它们同预处理器表达式运算符
defined 一样，不能取消定义或重新进行定义。
LINE              
FILE              
DATE              
TIME              
STDC              
包含当前源文件行数的十进制常量。 包含正在被编译的源文件名字的字符串字面值。 包含编译日期的字符串字面值，其形式为“ Mmm dd yyyy"。 包含编译时间的字符串字面值，其形式为“  hh:mm:ss"。 整型常量 1。只有在遵循标准的实现中该标识符才被定义为 1。
说明:#error 与#pragma 是 ANSI 标准中新引入的特征。这些预定叉的预处理器宏也 是新引入的，其中的一些宏先前已经在某些编译器中实现。
A.13             语法
这一部分的内容将简要概述本附录前面部分中讲述的语法。它们的内容完全相同，但顺 序有一些调整。
本语法没有定义下列终结符:整型常量、字符常量、浮点常量、标识符、字符串和枚举 常量。以打字字体形式表示的单词和符号是终结符。本语法可以直接转换为自动语法分析程 序生成器可以接受的输入。除了增加语法记号说明产生式中的候选页外，还需要扩展其中的 “ one of”结构，并(根据语法分析程序生成器的规则)复制每个带有 opt 符号的产生式:一 个带有 opt 符号，一个没有 opt 符号。这里还有一个变化，即删除了产生式"类型定义名: 标识符"，这样就使得其中的类型定义名成为个终结符。该语法可被 YACC 语法分析程序生成 器接受，但由于 if•else 的歧义性问题，还存在一处冲突。
翻译单元
外部声明
翻译单元 外部声明 外部声明:
函数定义 声明
函数定义:
声明说明符 opt 声明符声明表 opt 复合语句 声明:
声明说明符 初始化声明符表 opt;
声明表:
声明
声明表 声明
声明说明符:
存储类说明符 声明说明符 opt 类型说明符 声明说明符 opt 类型限定符 声明说明符 opt
存储类说明符:one of
auto register static extern tyedef
类型说明符:one of
void char short int long float double signed unsigned 结构或联合说明符 枚举说明符 类型定义名
类型限定符:one of
const volatile
结构或联合说明符:
结构或联合 标识符 opt {结构声明表}