# 01 \| 基础篇：学习此课程你需要了解哪些基础知识？你好，我是于航。 在我们正式进入到 WebAssembly的学习之前，为了帮助你更好地理解课程内容，我为你准备了一节基础课。 在这一节基础课中，我将与编程语言及计算机基础相关的一些概念，按照其各自所属的领域进行了分类，供你进行本课程的预习与巩固。 这些概念大多都相互独立，因此你可以根据自己的实际情况选择性学习。在后面的课程中，我将会直接使用这些概念或术语，不再过多介绍。当然，如果你对这些知识足够熟悉，可以直接跳过这节课。 JavaScript接下来，我将介绍有关 JavaScript 的一些概念。其中包括 ECMAScript语言规范中提及的一些特性，以及一些经常在 Web 应用开发中使用到的JavaScript Web API。window.requestAnimationFramewindow.requestAnimationFrame 这个 Web API ，主要用来替代曾经的window.setInterval 和 window.setTimeout函数，以专门用于处理需要进行"动画绘制"的场景。该方法接受一个回调函数作为参数，该回调函数将会在下一次浏览器尝试重新绘制当前帧动画时被调用。因此，我们便需要在回调函数里再次调用window.requestAnimationFrame函数，以确保浏览器能够正确地绘制下一帧动画。这个 API一个简单的用法如下所示。                                                          let start = null;        let element = document.querySelector('div');        const step = (timestamp) => {          if (!start) start = timestamp;          let progress = timestamp - start;          element.style.left = Math.min(progress / 10, 200) + 'px';          if (progress     在这段代码中为了便于展示，我们直接连同 CSS 样式、HTML 标签以及JavaScript 代码全部以"内嵌"的方式，整合到同一个 HTML文件中。 页面元素部分，我们使用标签绘制了一个背景色为红色，长宽分别为 100像素的矩形。并且该矩形元素的 position 属性被设置为了"absolute"，这样我们便可以通过为其添加 "left"属性的方式，来改变当前矩形在页面中的位置。在 JavaScript 代码部分，我们首先通过 "document.querySelector"的方式获取到了该矩形对应的 DOM 元素对象。并编写了一个用于绘制动画的函数"step"。 在这个函数定义的最后，我们调用了 window.requestAnimationFrame方法，来触发对动画下一帧的绘制过程。由此便构成了一个间接递归，动画便可以持续不断地绘制下去，直到"progress \    extern "C" {      int add(int x, int y) {        return x + y;      }    }    int main(int argc, char** argv) {      int x = add(0, 1);      std::cout  document.createElement('div'),        ...      }    })可以看到，在 Glue Code 代码中，我们将封装好的用于调用"document.createElement" 这个 Web API 去创建空 div 标签的 JavaScript函数 "createEmptyDivElement"，传递给了用于实例化 Wasm 模块的WebAssembly.instantiateStreaming方法。 在框架所对应的 C++ 代码中，我们使用了这个从 JavaScript 环境导入到Wasm 模块中的 "createEmptyDivElement" 函数。这里在代码中，所有通过"extern" 指定的外部函数，都将会在编译至 Wasm 二进制模块后，从模块对应的Import Section中获取实际的函数体。关于上述的代码示例，你大致有一个印象即可。我们会在"实战篇"中详细介绍一个Wasm 项目从 0 到 1的完整构建流程。跨上下文频繁调用的开销除了上面提到的，即使将 Web 前端框架完全重写并编译至Wasm，我们也无法在完全脱离 JavaScript Glue Code的情况下使用框架。另一个由此带来的问题在某些情况下可能会显得更加"致命"，那就是"Wasm 与 JavaScript两个上下文环境之间的函数调用开销"。在早期的 Firefox 浏览器（版本 62以前）上，由于实现问题，导致不管是使用 JavaScript 调用从 Wasm模块中导出的函数，还是在 Wasm 模块内调用从 Web 浏览器导入到模块内的JavaScript函数，这两种方式的函数调用成本都十分高昂。在某些情况下，同样的函数调用过程会比JavaScript 之间的函数调用过程慢约 20倍。 但好在 Firefox 在 62 之后的版本中修复了这个问题。并着重优化了JavaScript 与 Wasm 之间的函数调用效率。甚至在某些情况下，JavaScript 与Wasm 之间的函数调用效率要高于 JavaScript之间的函数效率。虽然这个问题在 Firefox上得到了修复，但不可否认的是，在其他浏览器厂商的 Wasm实现中，也可能会出现类似的性能问题。Web 前端框架作为一个需要与 DOM 元素，以及相关 Web API强相互依赖的技术产品，可想而知其在实际使用过程中，必然会通过 Glue Code去完成 Wasm 与 JavaScript 之间的频繁函数调用。而以性能为重的 Web前端框架，则无法忽视这些由于频繁函数调用带来的性能损耗。使用 Wasm 重写现有框架的核心逻辑在第二种方案下，我们将使用 Wasm 重写 Web前端框架的核心逻辑，但并非全部。如下图所示，在这种情况下，Web应用的主要组成结构与上一种方案类似，唯一的不同是增加了 Web 框架所对应的JavaScript 代码实现部分。![](Images/d7d1aab425d8d2841df091e05e477d06.png)savepage-src="https://static001.geekbang.org/resource/image/ab/62/aba4ec5bfc67193d46615efba1ce7462.png"}相较于将整个框架都通过 Wasm来实现，仅实现框架的核心逻辑部分，可以说更具有现实意义，而这也是现阶段大多数的框架开发者都在实践的方向。所谓"核心逻辑"，其实依框架的具体实现不同，无法通过统一、准确的描述来定义。但可以遵循的原则是，这部分逻辑不会涉及与DOM 或者 Web API的频繁交互，但其本身却又是"计算密集（compute-intensive）"的。这里的"计算密集"可以理解为：包含有大量的纯数学计算逻辑。我们知道，Wasm十分擅长处理这样的计算密集型逻辑。一个很具有代表性的，可以被 Wasm重写的组件便是 React Fiber 架构中的 Reconciler（主要用来计算 React 中VDOM 之间的差异）。使用 Wasm 配合框架增强应用的部分功能我们继续逐渐递减 Wasm与框架的"耦合"程度。在第三种方案中，从本质上来看，框架本身的代码不会有任何的变化。而 Wasm也不再着重于优化框架本身的性能。相对地，框架与 Wasm将会配合起来使用，以优化整个应用的某一部分功能。下面这张图是在这个方案下，一个Web 应用的基本组成结构。![](Images/8add1b5324ad788b403611aa33659d3b.png)savepage-src="https://static001.geekbang.org/resource/image/2a/8c/2a3a73af31e382f34e4a847fayy2b48c.png"}可以看到，这里 Wasm本身只是作为一个模块，用于优化应用的某方面功能。而 Web框架本身的源代码组成形式不会发生任何改变，应用仍然还是使用 JavaScript来构建其主体结构。事实上，这是 Wasm 在 Web 上的一种最为典型和常见的应用方式。Wasm并不尝试取代 JavaScript，而是通过利用其优势来补足或者加以提升 Web应用在某方面的短板。一个最为常见的例子便是前端的"数据编解码"。我们都知道，"编解码"实际上是十分单纯的数学计算，那么这便是 Wasm能够大显身手的地方。通过替换 Web 应用中原有的基于 JavaScript实现的编解码逻辑，使用 Wasm来实现这部分逻辑则会有着明显的性能提升。而且由于这个过程不涉及与 Web API的频繁交互，Wasm所能够带来的性能提升程度更是显而易见的。使用其他语言构建 Web 前端框架最后一种方案相较于之前的几种可能会稍显激进，但随着 Wasm发展而不断出现的，一批又一批基于此方案实现的 Web前端框架，值得让我们重新重视起来。在此方案下，我们将使用诸如 C++ 和 Rust 等静态类型语言来实现 Web前端框架。不仅如此，我们也同样需要使用这些语言来编写我们的 Web应用。类似的框架有基于 Rust 语言的 Yew、Seed，以及基于 Go 语言 Vugu等等。 以相对较为"流行"的 Yew 框架为例，我们使用它来编写 Web前端应用的大致思路，与 React 和 Vue.js 等传统 JavaScript Web前端框架的形式十分类似。以下代码展示了如何使用 Rust 语言基于 Yew框架，来构建一个基本的 Web前端应用。     use yew::prelude::*;    pub struct App {}    pub enum Msg {}    impl Component for App {      type Message = Msg;      type Properties = ();      // 应用创建时执行的生命周期函数；      fn create(_: Self::Properties, _: ComponentLink) -> Self {        App {}      }      // 应用视图更新时执行的生命周期函数；      fn update(&mut self, _msg: Self::Message) -> ShouldRender {        true      }      // 定义应用视图结构；      fn view(&self) -> Html {        html! {          { "Hello, world!" }        }      }    }相信即使你不懂 Rust，但如果你熟悉 React，仍然可以发现基于 Yew 构建的Web 前端应用，它的代码组织结构与 React十分类似，整个应用也同样被划分为不同的"生命周期"。比如在上面的代码中，"create" 方法对应应用的创建时刻；update方法对应应用的状态更新时刻，以及最后用于渲染应用 UI 的 view方法等等。不仅如此，在 Yew 中也同样拥有组件的概念，使用方式与 React类似。 相对来说，抛开语言本身带来的成本不谈，单从性能来看，在目前 Wasm 的MVP 标准下，Yew 这类框架的潜力还没有实际的显露出来。Yew 希望能够借助Wasm的能力，将视图（VDOM）差异的计算过程以更高性能的方式进行实现。但鉴于目前MVP 标准下的一些限制，实际上在最后的编译产物中，Glue Code执行时所带来的成本则会与 Wasm带来的性能提升相互抵消。不仅如此，考虑到目前 JavaScript 在构建 Web应用时的丰富生态和资源，单从性能角度进行考量而使用 Yew等框架也不是一个实际可行的方案。因此，未来这类"跨语言" Web前端框架的生态会变得如何，也只能够让我们拭目以待了。已有的讨论在介绍了上述四种，Wasm 可能与 Web前端框架相互结合的方案后。我们再回过头来，看一看目前仍然流行的几种JavaScript Web 前端框架有没有进行与 Wasm 结合的相关尝试。这里我选择了React、Vue.js 以及 Ember.js 这三种 Web框架。 React作为目前 Web 前端开发领域中最流行的框架之一。React暂时还没有计划进行任何与 Wasm相关的尝试。如下图所示，虽然社区中曾有人提议使用 Wasm 重写 React Fiber架构中的 Reconciler 组件，但由于目前 Wasm 还无法直接操作 DOM元素等标准上的限制，导致我们可预见，现阶段即使用 Wasm 重写 React 的Fiber 算法，框架在实际处理 UI更新时，可能也不会有着显著的性能提升。因此，对于 React团队来说，投入产出比是一个值得考量的因素。![](Images/b358835d206875ce1c9edc200ccf4635.png)savepage-src="https://static001.geekbang.org/resource/image/63/25/634f8202eaf1fe730bd4bd2d81b98625.png"}Vue.js同 React 类似，Vue.js的社区内也曾有过类似的讨论，如下图所示。![](Images/51cee3dc2991346a8d543c24e6dc7eab.png)savepage-src="https://static001.geekbang.org/resource/image/b9/5f/b93f7ee3d059fb9f0c3ffc461d7eb65f.png"}但与 React 所不同的是，Vue.js 与 Wasm的"结合"方式根据框架的具体实现细节，可能有着更多的可能。不过一个不可否认的事实是，Wasm仍然处在快速的发展阶段。同样的，基于 Wasm构建的各类应用也同样处在不稳定的维护状态中（比如，上述帖子中提到的 Walt实际上于 2019年便不再继续更新）。而目前，正是一个"百花齐放"的时代。Ember.js最后我们要来讲讲 Ember.js。Ember.js 的用户虽然没有 React 与 Vue.js那么多，但它却是第一个宣布尝试与 Wasm 进行"深度整合"的 Web前端框架，Ember.js 在内部使用了名为 Glimmer VM 的渲染引擎。与 React通过使用 Reconciler 组件计算 VDOM 差异来更新 UI 的策略有所不同，GlimmerVM 通过将模板的构建过程分解为独立的虚拟机 "OpCode" 操作，来对 UI中呈现的动态值进行细粒度更新。![](Images/94140cf6d8e9d6b4a2ea521639ddf392.png)savepage-src="https://static001.geekbang.org/resource/image/31/59/315de62de69f42c5cbf60dae5575e859.png"}图片来自于EmberConf 2018在 EmberConf 2018 年的技术会议上，来自 Ember.js 团队的 Yehuda Katz向我们介绍了 Glimmer VM 与 Wasm 的整合情况。你通过上图可以看到，除了OpCode 模块相关的部分逻辑仍然在使用 JavaScript 构建以外，整个 VM的大部分功能都已经完成到 Wasm 的迁移。并且该 Wasm 版本的 Glimmer VM也已经通过了所有的测试集 Case。但计划赶不上变化，回到 2020 年，我们再来看 Glimmer VM，关于它与 Wasm整合的消息貌似已经没有了太多的声音。从  [Ember.js官方论坛  slate-object="inline"中我们可以看到，Ember.js 在与 Wasm进行整合的过程中，其实遇到了很多问题，比如不支持 GC 导致 Wasm线性内存中使用的资源无法被及时清理。Glimmer VM还在继续为将来能够完全移植到 Wasm做着准备。 但无论如何，这都不失为一次非常有意义的尝试。总结好了，讲到这，今天的内容也就基本结束了。最后我来给你总结一下。在这节课里呢，我主要给你介绍了 Wasm 与 Web前端框架的一些"故事"。"Wasm 能否影响，或者说会如何影响现有的、基于 JavaScript 构建的现代Web 前端框架呢？"这是一个被很多 Web前端工程师所提及的问题。在这节课中，我尝试按照 Wasm 与 Web前端框架的"整合程度"不同，将两者能够相互结合的可能方式大致分为了四种方案。在第一种方案中，我们尝试将整个 Web 框架的全部功能，使用同样的 Wasm版本进行代替，而应用代码仍然使用 JavaScript 进行编写。但由于现阶段 WasmMVP 标准的限制，在这种方案下，我们不得不借助 JavaScript Glue Code的帮助来实现框架的部分功能。而当 Glue Code 的代码越来越多时，JavaScript 函数与 Wasm导出函数之间的相互调用会更加频繁，在某些情况下，这可能会产生严重的性能损耗。因此结合现实情况来看，整个方案的可用性并不高。在第二种方案中，我们尝试仅使用 Wasm 来重写框架的核心部分，比如 ReactFiber 架构中的 Reconciler 组件。这类组件通常并不含有过多需要与 Web API打交道的地方，相对纯粹的计算逻辑更易于 Wasm能力的发挥。同时这种方案也是现阶段大多数 Web 框架正在尝试的，与 Wasm进行交互的"常规"方式。在第三种方案中，我们仅使用 Wasm 来作为 Web 框架的辅助，以优化 Web应用的某一方面功能。在这种方案中，框架本身的代码结构不会有任何的变化。实际上，这种方案也是传统Web 应用在利用 Wasm时的最常规方式。在最后一个方案中，我们介绍了一种更为激进的方式。在这种方案下，包括Web 框架和应用代码本身，都会由除 JavaScript 以外的，如 Rust、C++ 和 Go等静态语言来编写。但同样受限于现阶段 Wasm MVP 标准的限制，框架本身仍然离不开 JavaScriptGlue Code 的帮助。同时考虑到实际的语言使用成本以及 JavaScript生态的舍弃，这种方案的实际可行性仍有待时间的验证。无论如何，相信随着 Wasm Post-MVP 标准的不断实现，上述各方案中使用的Glue Code 代码量将会逐渐减少。随之提升的，便是 Web框架以及应用的整体运行性能。**课后思考**最后，我们来做一个思考题吧。除了我们今天介绍的这四种 Web 框架与 Wasm的结合使用方式，你还有哪些奇思妙想呢？今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，同时欢迎你把这节课分享给你的朋友或者同事，一起交流一下。