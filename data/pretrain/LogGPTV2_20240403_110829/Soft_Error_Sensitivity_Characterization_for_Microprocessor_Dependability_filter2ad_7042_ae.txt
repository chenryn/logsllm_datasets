82
83
Figure 8. The SES of the D-cache.
neous transition from valid to invalid simply makes the pro-
cessor wait for valid data, whereas a transition in the op-
posite direction lets unexpected data to be delivered to the
IU or SMU. A corrupted data transfer also occurs if FIL
54 or FIL 83 fails. FIL 54 aligns data items read from the
DCRAM (FIL 83) and puts them on the bus. Since the func-
tions of FIL 54 and FIL 83 are performed in a sequence,
their SES levels and patterns are very similar. FIL 56 is the
most sensitive sub-block as it signals synchronization error,
I/O error, and/or memory error in data access. Like FIL
38 in the I-cache, FIL 59 may modify data in the DCRAM
with a false write enable signal. Other write enable signals
are produced by FIL 68 for tags and FIL 69 for status bits.
FIL 60 acts as a sleep signal to the DCRAM and DTAG.
Improperly disabling the D-cache results in a process fail-
ure. FILs 61 and 70 are the address for the D-cache access.
An address error may be resolved as an access miss or other
situations as we discussed with FIL 1. Thus, their sensitiv-
ities are close to that of FIL 1. FIL 63 controls bypassing
data path for non-cacheable loads and stores. If it selects a
wrong path, a memory transaction error occurs.
A DTAG error creates an incorrect hit or miss decision.
Miss rate on the D-cache is relatively high, and therefore,
more false hits (erroneous decision changes from miss to
hit) may occur than in the I-cache. Moreover, a false miss
for a dirty line makes a stale data delivery from the memory.
This is why the DTAG exhibits some error susceptibilities
unlike the ITAG. A bit-toggle at the outputs of FIL 81 or
82 guarantees a mis-decision. On the other hand, faulty FIL
79 still has a possibility of avoiding false hits because the
output signal is 19 bits. We need to note that how often a
fault in a FIL eventually corrupts its output signal is a differ-
ent issue from how the output error affects the computation.
The former is mainly related with the upset rate of the FIL
and the latter is the SES that we investigate here. In reality,
the upset rates for FIL 79 and FIL 81 might be similar.
When FID was increased to 500 for testing rarely sensi-
tive sub-blocks, faults were effective in FILs 64, 71, and 72,
but not in FILs 57 and 73 as shown in Figure 6. The reason
for FIL 57 is the same as FIL 44 of the ICU. FIL 73 notiﬁes
whether or not a store on an SC write miss is completed in
the D-cache. The SC miss is a rare event. A false signaling
in one direction induces more wait cycles and the signaling
in the other direction is not very prone to a failure.
The general protection scheme for the D-cache can be
the same as the I-cache in that memory arrays are checked
with an ECC and at least critical control sub-blocks are cov-
ered. For a write-back D-cache as employed in picoJava-II,
up-to-date data items may be available only in the cache.
Therefore, more integrity checking needs to considered for
the D-cache than the I-cache. Write through policy is most
commonly used when parity protection is used. In the case
of error detection in a cache line, simply invalidating the
line accomplishes error recovery.
FPU, SMU, PCSU, BIU, and MEMC:
In Figure
9, the maximum SES results for the remaining FUBs are
presented where FID are 1 and 10. Apparently, the more
ﬂoating point operations, the higher SES. However, the FPU
here shows very low sensitivities. The reason for that is as
follows. FIL 84 is another example of the case in Figure
4(b), asserting the start and end signal of ﬂoating point op-
erations. The output of FIL 85 is valid only for one or two
cycles on completion of long execution (up to 2000 cycles)
of a ﬂoating-point instruction. It is quite unlikely for short
FIDs to overlap with such a brief interval. To examine the
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:17:34 UTC from IEEE Xplore.  Restrictions apply. 
FPU
SMU
PCSU
BIU
MEMC
)
%
(
t
l
u
a
f
e
v
i
t
c
e
f
f
E
100
90
80
70
60
50
40
30
20
10
0
84
85
86
87
88
89
90
91
92
93
94
Max (Bubble, Crypt, Linpack, Queens)
95
99
Fault injection location (FIL)
96
97
98
Process hanging
System crash
Incorrect state
100
101
102
103
104
105
106
107
108
109
Figure 9. The SES of the remaining FUBs.
SES of the FPU in the worst situation, we could have in-
jected the faults when the output is active. In that case, the
SES would be much higher. Separate fault injections into
smaller logic blocks of FIL 85 are needed to understand er-
ror manifestation behavior at its output.
The SMU shows zero SES in all FILs except FIL 92.
It handles spills and ﬁlls of the SC and manages execution
pipeline in overﬂow and underﬂow conditions. An over-
ﬂow occurs if the top of the stack pointer is smaller than
the bottom of stack pointer. In comparison to other oper-
ations, the overﬂow frequency is very low. An underﬂow
can be activated only in response to changes at the top of
the stack pointer initiated by the return instructions, which
seldom occur. For these reasons, faults are hardly effective
in the SMU. FIPs that are randomly selected in our test did
not coincide with the occasional SMU active cycles.
Even if FID is 500 (Figure 6), FILs 90, 91, 94, and 96
have no changes in the SES. When FID 90 asserts a write
enable, the output of FIL 89 is latched. Since the state of
FIL 89 does not vary often, additional writes by erroneous
FID 90 have usually no special impact. FIL 91 generates
pipeline stalls. Holding the pipeline for extra cycles intro-
duces an operation delay, but not a process failure. FIL 94
requests loads solely on an SC ﬁll or an underﬂow. FIL
96 tells the DCU that a data request is a non-allocate store.
This has no effect in the case of a D-cache hit, but on a
miss, data item is directly written to the memory. Erro-
neous switching by FIL 96 between caching or non-caching
data cannot alter the correctness of computation unless it
caches data from a non-cacheable address region. Based on
the observation, the SMU can be the last FUB to consider
for integrity checking. Since the SMU mainly consists of
random logic, the lifespan of errors in the SMU caused by
temporary hardware failures is short.
FIL 97 requests the IU to take a trap when there is an in-
terrupt by an external device. The trap is however not taken
when the interrupt mask bit of the processor state register is
0, making faults ineffective. FIL 99 signals a power-down
to other FUBs. Unless the IU executes a power-down in-
struction, indicated by FIL 24, no response is made. Ac-
cordingly, its SES is zero. Erroneously triggering a standby
when the FUBs are not ready leads the process to fail,
whereas not going into the standby mode even at a right
timing does not affect normal execution. Considering this
unique characteristic, the power-down control logic needs a
protection from the former case only. The PCSU is placed
in a fault tolerant position like Figure 4(b).
As clearly seen in the ﬁgure, handshaking signals by
FIL 100, 101, and 109 are error-sensitive during memory
transactions between the BIU and the caches or the BIU
and MEMC. A false bus acknowledgment causes the pro-
cessor to hang or crash. Other FILs except FIL 107 are
less sensitive because their faulty signals neither initiate nor
terminate bus transactions. Data errors directly propagate
through memory transactions. Thus, ensuring the integrity
of handshaking activity along with data check is a critical
component, qualifying for protection redundancy.
FUB-level SES: Figure 10 visualizes our SES esti-
mate of the picoJava-II. The average SES of each FUB is
quantized into one of 10 shade levels after weighting the ar-
eas and sensitivities of FILs in the FUB. A higher SES is
represented by a darker shade.
Register control unit
l
o
r
t
n
o
c
e
p
P
i
t
i
n
u
Instruction
cache
unit
Instruction cache RAM
Execution unit
t
i
n
u
g
n
d
o
l
i
f
n
o
i
t
c
u
r
t
s
n
I
ITAG
DCU
Data cache tag
BIU
Stack
manager
unit
e
d
o
c
o
r
c
M
i
U
S
C
P
Floating point RAM0
Floating point RAM1
Floating point logic
Data cache RAM0
Data cache RAM1
Figure 10. Estimated SES visualization.
6. Summary
We have conducted fault injection simulations on a com-
mercial product, picoJava-II, to characterize the soft error
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:17:34 UTC from IEEE Xplore.  Restrictions apply. 
sensitivities of its components. We summarize our anal-
ysis as follows: (1) Many processor components are sel-
dom susceptible to soft errors, while there are a few com-
ponents with a very high SES. The SES of a component is
determined by its architectural function; logical situation,
governing processor behavior directly or in collaboration
with other components; and active cycle/frequency. A logic
block may have an inherent capability of fault masking to
some degree.
(2) Workload variation does not convert a
critical component to a non-critical component in terms of
SES, or vice versa. Although minor changes in the SES
level and the pattern of failures can be induced by different
workloads, clear distinction between the protection order,
from ﬁrst to last, among components remains unchanged.
As a result, the SES is an effective standard for prioritiz-
ing protection and the integrity checking of various proces-
sor components to enhance dependability. (3) Soft errors
in control logic generally have a shorter lifetime than those
in the memory arrays. Controlling program ﬂow and bus
transaction is more effective than other controls. There-
fore, protection can start with memory, which is already
common in many microprocessors, and then include criti-
cal random logic. (4) The sensitivities of many components
are fairly predictable from processor architecture and orga-
nization. The amount of efforts to estimate the SES data is
adjustable with varying degree of accuracy. Different levels
in processor model hierarchy can be selected for the esti-
mation. This enables the designer to meet time-to-market
requirements, while achieving a resource-efﬁcient increase
in processor dependability.
Our study demonstrates that fault injection in RTL mod-
els is a very effective method to improve the efﬁciency of
the protection techniques in an early development stage.
Acknowledgments: This work was funded in part by
Carver Trust Grants from Iowa State University. The au-
thors would like to thank Jon E. Froehlich for verifying our
simulator and benchmark programs.
References
[1] J. Sosnowski, “Transient fault tolerance in digital systems,”
IEEE Micro, 14(1):24-35, Feb. 1994.
[2] D. Siewiorek and R. Swartz, Reliable Computer Systems:
Design and evaluation, A K Peters, Natick, MA, 1998.
[3] S. Kim and A. K. somani, “Area efﬁcient architectures for
information integrity in cache memories,” Int’l Symp. Com-
puter Architecture, pp. 246-255, 1999.
[4] J. Clark and D. Pradhan, “Fault injection: a method for val-
idating computer-system dependability,” IEEE Computer,
28(6):47-56, June 1995.
[5] M. Hsueh, T. Tsai, and R. Iyer, “Fault injection techniques
and tools,” IEEE Computer, 30(4):75-82, April 1997.
[6] S. Chau, “Fault injection boundary scan design for veriﬁca-
tion of fault tolerant systems,” Proc. ITC, pp. 667-682, 1994.
[7] C. Constantinescu, “Teraﬂops supercomputer: architecture
and validation of the fault tolerance mechanisms,” IEEE
Trans. Computers, 49(9):886-894, Sept. 2000.
[8] J. Karlsson et al., “Using heavy-ion radiation to validate
fault-handling mechanisms,” IEEE Micro, 14(1):8-23, 1994.
[9] G. Miremadi and J. Torin, “Evaluating processor-behavior
and three error-detection mechanisms using physical fault-
injection,” IEEE Trans. Reliability, 44(3):441-454, 1995.
[10] U. Gunneﬂo, J. Karlsson, and J. Torin, “Evaluation of error
detection schemes using fault injection by heavy-ion radia-
tion,” Proc. FTCS-19, pp. 340-347, 1989.
[11] G. Miremadi et al., “Two software techniques for on-line
error detection,” Proc. FTCS-22, pp. 328-335, 1992.
[12] W. Moreno et al, “First test results of system level fault tol-
erant design validation through laser fault injection,” Proc.
ICCD, pp. 544-548, 1997.
[13] J. Samson et al, “A technique for automated validation of
fault tolerant designs using laser fault injection (LFI),” Proc.
FTCS-28, pp. 162-167, 1998.
[14] G. Kanawati et al., “FERRARI: a ﬂexible software-based
fault and error injection system,” IEEE Trans. Computers,
44(2):248-260, Feb., 1995.
[15] P. Cheynet et al., “Experimentally evaluating an automatic
approach for generating safety-critical software with re-
spect to transient errors,” IEEE Trans. Nuclear Science,
47(6):2231-2236, Dec., 2000.
[16] J. Aidemark et al., “GOOFI: generic object-oriented fault
injection tool,” Proc. DSN, pp. 83-88, 2001.
[17] V. Sieh et al., “VERIFY: evaluation of reliability using
VHDL-models with embedded fault descriptions,” Proc.
FTCS-97, pp. 32-36, 1997.
[18] E. W. Czeck and D. P. Siewiorek, “Observations on the ef-
fects of fault manifestation as a function of workload,” IEEE
Trans. Computers, 41(5):559-566, 1992.
[19] S. Kim and A. K. Somani, “On-line integrity monitoring of
microprocessor control logic,” ICCD, pp. 314-319, 2001.
[20] P. Duba and R.
Iyer, “Transient
fault behavior
in a
microprocessor-a case study,” ICCD, pp. 272-276, 1988.
[21] E. W. Czeck and D. P. Siewiorek, “Effects of transient gate-
level faults on program behavior,” FTCS, pp. 236-243, 1990.
[22] M. Rimen and J. Ohlsson, “A study of the error behavior of a
32-bit RISC subjected to simulated transient fault injection,”
Proc. Int’l Test Conf., pp. 696-704, 1992.
[23] G. Choi at el., “Fault behavior dictionary for simulation of
device-level transients,” Proc. Conf. CAD, pp. 6-9, 1993.
[24] N. Kanawati et al., “Dependability evaluation using hybrid
fault/error injection,” Proc. Symp. Computer Performance
and Dependability, pp. 224-233, 1995.
[25] J. Guthoff and V. Sieh, “Combining software-implemented
and simulation-based fault injection into a single fault injec-
tion method,” Proc. FTCS-25, pp. 196-206, 1995.
[26] E. Jenn et al., “Fault injection into VHDL models:
the
MEFISTO tool,” Proc. FTCS-24, pp. 66-75, 1994.
[27] A. Amendola et al., “Fault behavior observation of a micro-
processor system through a VHDL simulation-based fault
injection experiment,” Proc. Conf. EURO Design Automa-
tion, pp. 536-541, 1996.
[28] D. Gil et al., “Fault injection into VHDL models: analysis
of the error syndrome of a microcomputer system,” Proc.
FTCS-28, pp. 418-424, 1998.
[29] J. Gaisler, “Evaluation of a 32-bit microprocessor wit built-
in concurrent error-detection,” FTCS-27, pp. 42-46, 1997.
[30] C. Kouba and G. Choi, “The single event upset character-
istics of the 486-DX4 microprocessor,” Proc. Radiation Ef-
fects Data Workshop, pp. 48-52, 1997.
[31] H. McGhan and M. O’Connor, “PicoJava: a direct execution
engine for Java bytecode,” IEEE Computer, 32(10):22-30,
Oct. 1998.
[32] “Community
source
licensing,”
Sun Microsystems,
http://www.sun.com/processors/communitysource.
[33] S. Dey et al., “Using a soft core in a SoC design: experiences
with picoJava,” IEEE Design & Test of computers, 17(3):60-
71, July-Sept. 2000.
[34] “The java grande forum benchmark suite,” Java Grande Fo-
rum, http://www.javagrande.org.
[35] S. Kim and A. K. Somani, “SSD: an affordable fault tolerant
architecture for superscalar processors,” Proc. Int’l Symp.
Paciﬁc Rim Dependable Computing, pp. 27-34, 2001.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:17:34 UTC from IEEE Xplore.  Restrictions apply.