# 十四、提供平台
到目前为止，本书的每一章都集中在集群的基础设施上。我们已经探索了如何部署 Kubernetes，如何保护它，以及如何监控它。我们还没有讨论的是如何部署应用。
在这一章，也就是我们的最后一章，我们将利用我们对 Kubernetes 的了解来构建一个应用部署平台。我们将基于一些常见的企业需求来构建我们的平台。在我们不能直接实现一个需求的地方，因为在 Kubernetes 上构建一个平台可以填充它自己的书，我们将调用它并提供一些见解。
在本章中，我们将涵盖以下主题:
*   设计管道
*   准备我们的集群
*   部署 GitLab
*   部署 Tekton
*   部署 ArgoCD
*   使用 OpenUnison 自动化项目入职
# 技术要求
要执行本章中的练习，您将需要一个干净的 KinD 集群，该集群至少有 8 GB 内存、75 GB 存储空间和 4 个 CPU。我们将构建的系统是极简主义的，但仍然需要相当大的马力来运行。
您可以在以下 GitHub 存储库中访问本章的代码:[https://GitHub . com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide)。
# 设计管道
术语“管道”在 Kubernetes 和 DevOps 世界中被广泛使用。很简单，管道是一个过程，通常是自动化的，它接受代码并让它运行。这通常包括以下内容:
![Figure 14.1 – A simple pipeline ](img/Fig_14.1_B15514.jpg)
图 14.1–一个简单的管道
让我们快速浏览一下此过程中涉及的步骤:
1.  将源代码存储在中央存储库中，通常是 Git
2.  当提交代码时，构建它并生成工件，通常是一个容器
3.  告诉平台——在这个例子中是 Kubernetes——推出新容器并关闭旧容器
这是管道能得到的最基本的东西，在大多数部署中用处不大。除了构建和部署代码之外，我们还希望确保扫描容器中已知的漏洞。在投入生产之前，我们可能还想通过一些自动化测试来运行我们的容器。在企业部署中，通常会有一个法规遵从性要求，即有人也负责生产转移。考虑到这一点，管道开始变得更加复杂:
![Figure 14.2 – Pipeline with common enterprise requirements ](img/Fig_14.2_B15514.jpg)
图 14.2–具有常见企业需求的管道
管道增加了一些额外的步骤，但它仍然是线性的，只有一个起点，即提交。这也是非常简单化和不现实的。随着新的**常见漏洞和暴露** ( **CVEs** )的发现和修补，应用所基于的基本容器和库不断更新，这是一种对安全漏洞进行编目和识别的常见方法。除了让开发人员更新应用代码以满足新的需求之外，您还需要一个系统来扫描代码和基本容器以获得可用的更新。这些扫描器监视您的基本容器，并且可以在新的基本容器准备好之后触发构建。虽然扫描器可以调用一个 API 来触发管道，但是您的管道已经在等待您的 Git 存储库去做一些事情，所以最好简单地向 Git 存储库添加一个提交或拉请求来触发管道:
![Figure 14.3 – Pipeline with scanners integrated ](img/Fig_14.3_B15514.jpg)
图 14.3–集成扫描仪的管道
这意味着您的应用代码被跟踪，您的操作更新在 Git 中被跟踪。Git 现在不仅是你的应用代码的真实来源，也是操作更新的真实来源。到了审核的时候，你有一个现成的变更日志！如果您的策略要求您将变更输入到变更管理系统中，只需从 Git 中导出变更。
到目前为止，我们专注于我们的应用代码，只是把**推出**放在我们管道的末端。最后一步通常意味着用我们新构建的容器修补一个`Deployment`或`StatefulSet`，让 Kubernetes 斯做旋转新的`Pods`和缩小旧的工作。这可以通过一个简单的 API 调用来完成，但是我们如何跟踪和审计这种变化呢？真理的来源是什么？
我们在 Kubernetes 中的应用被定义为存储在`etcd`中的一系列对象，这些对象通常用 YAML 文件表示为代码。为什么不把这些文件也存储在 Git 存储库中呢？这给我们带来了与用 Git 存储应用代码相同的好处。对于应用源和应用的操作，我们都有一个单一的真实来源！现在，我们的管道还包括一些步骤:
![Figure 14.4 – GitOps pipeline ](img/Fig_14.4_B15514.jpg)
图 14.4–GitOps 管道
在这个图中，我们的展示用我们应用的 Kubernetes·YAML 更新了一个 Git 存储库。我们集群中的一个控制器监视 Git 的更新，当它看到更新时，让集群与 Git 中的内容同步。它也能探测到我们星系团中的漂移，并使其与我们的真相之源重新对齐。
这个对 Git 的关注叫做 **GitOps** 。其思想是应用的所有工作都是通过代码完成的，而不是直接通过 API。你对这个想法有多严格可以决定你的平台是什么样的。接下来，我们将探讨意见如何塑造您的平台。
## 固执己见的平台
谷歌的开发者倡导者、Kubernetes 世界的领导者 Kelsey Hightower 曾经说过:“Kubernetes 是一个构建平台的平台。这是一个更好的起点；不是终局。”当您看到构建基于 Kubernetes 的产品的供应商和项目的情况时，他们都对应该如何构建系统有自己的看法。举个例子，红帽的 **OpenShift 容器平台** ( **OCP** )想要成为多租户企业部署的一站式平台。它建立在我们讨论的大量管道中。您定义了一个由提交触发的管道，该管道构建一个容器并将其推入自己的内部注册表，然后触发新容器的部署。名称空间是租户的边界。Canonical 是一个极简主义的发行版，不包含任何管道组件。亚马逊、Azure 和谷歌等托管供应商提供集群的构建模块和管道的托管构建工具，但让您自行构建您的平台。
对于使用哪个平台，没有正确的答案。每个都是固执己见的，适合您的部署将取决于您自己的要求。根据您企业的规模，看到部署多个平台并不奇怪！
看了固执己见的平台的想法之后，让我们探讨一下构建管道的安全影响。
## 保护你的管道
根据您的起点，这可能会很快变得复杂。你的管道有多少是一个集成的系统，或者可以用一个多彩的美国口语来描述，包括管道胶带？即使在所有组件都在的平台上，将它们捆绑在一起通常也意味着构建一个复杂的系统。作为您的管道的一部分，大多数系统都有一个可视化组件。通常，视觉组件是仪表板。用户和开发人员可能需要访问该仪表板。你不想为所有这些系统维护单独的帐户，是吗？您需要为管道的所有组件提供一个登录点和入口。
在确定如何对使用这些系统的用户进行认证后，下一个问题是如何自动化部署。管道的每个组件都需要配置。它可以像通过应用编程接口调用创建的对象一样简单，也可以像用 SSH 密钥将 Git repo 和构建过程捆绑在一起以实现安全自动化一样复杂。在如此复杂的环境中，手动创建管道基础设施将导致安全漏洞。这也将导致无法管理的系统。自动化流程并提供一致性将帮助您保护基础架构并保持其可维护性。
最后，从安全角度理解 GitOps 对我们集群的影响是很重要的。我们在 [*第 7 章*](07.html#_idTextAnchor203) 、*将认证集成到您的集群中*和 [*第 8 章*](08.html#_idTextAnchor228) *、使用活动目录用户的 RBAC 策略*中讨论了对管理员和开发人员使用 Kubernetes API 进行认证以及授权访问不同的 API。如果有人可以签入一个为其分配名称空间的`admin` `ClusterRole`的`RoleBinding`，并且 GitOps 控制器自动将其推送到集群，会有什么影响？在设计平台时，请考虑开发人员和管理员希望如何与之交互。说“让每个人都与他们应用的 Git 注册表交互”是很有诱惑力的，但这意味着作为许多请求的集群所有者，您要承担负担。正如我们在 [*第 8 章*](08.html#_idTextAnchor228)*使用活动目录的 RBAC 策略*中所讨论的，这可能会使您的团队成为企业中的瓶颈。在这种情况下，了解您的客户对于了解他们希望如何与其运营互动非常重要，即使这不是您想要的。
在接触了 GitOps 和管道的一些安全方面之后，让我们探讨一下典型管道的需求以及我们将如何构建它。
## 构建我们平台的需求
Kubernetes 部署，尤其是在企业环境中，通常有以下基本要求:
*   **开发和测试环境**:至少两个集群，测试集群级别的变化对应用的影响
*   **开发人员沙箱**:开发人员可以构建容器并对其进行测试而不用担心对共享命名空间的影响的地方
*   **源代码控制和问题跟踪**:存储代码和跟踪未完成任务的地方
除了这些基本要求之外，企业通常还有其他要求，例如定期访问审查、基于策略限制访问，以及为可能影响共享环境的操作分配责任的工作流。
对于我们的平台，我们希望包含尽可能多的这些需求。为了更好地将部署自动化到我们的平台上，我们将每个应用定义为具有以下内容:
*   **一个开发命名空间**:开发人员就是管理员。
*   **一个生产命名空间**:开发者就是观众。
*   **一个源码控制项目**:开发者可以分叉。
*   **一个构建过程**:由 Git 的更新触发。
*   **一个部署流程**:由 Git 更新触发。
此外，我们希望我们的开发人员拥有自己的沙盒，这样每个用户都将获得自己的开发名称空间。
重要说明
在实际部署中，您会希望将开发和生产环境分离到单独的集群中。这使得测试集群范围内的操作(如升级)变得更加容易，而不会影响正在运行的应用。我们在一个集群中做所有事情，让您更容易独立设置。
为了提供对每个应用的访问，我们将定义三个角色:
*   **所有者**:作为应用所有者的用户可以批准其应用内其他角色的访问权限。此角色分配给应用请求者，并且可以由应用所有者分配。所有者还负责推动开发和生产的变革。
*   **开发人员**:这些用户可以访问应用的源代码控制，并且可以管理应用的开发命名空间。他们可以查看生产命名空间中的对象，但不能编辑任何内容。该角色可以由任何用户请求，并由应用所有者批准。
*   **操作**:这些用户具有作为开发人员的能力，但是也可以根据需要对生产命名空间进行更改。该角色可以由任何用户请求，并得到应用所有者的批准。
我们还将创建一些全环境角色:
*   **系统批准者**:具有该角色的用户可以批准对任何系统范围角色的访问。
*   **集群管理员**:这个角色专门负责管理我们的集群和组成我们管道的应用。它可以由任何人请求，并且必须由系统批准者角色的成员批准。
*   **开发人员**:任何登录的人都会获得自己的开发命名空间。其他用户不能请求访问这些命名空间。这些名称空间没有直接连接到任何 CI/CD 基础设施或 Git 存储库。
即使使用非常简单的平台，我们也有六个角色需要映射到组成管道的应用。每个应用都有自己的认证和授权过程，这些角色需要映射到这些过程。这只是自动化对集群安全性如此重要的一个例子。基于电子邮件请求手动配置此访问可能会变得难以管理。
开发人员在应用中需要经历的工作流程将与我们之前设计的 GitOps 流程一致:
*   应用所有者将请求创建应用。一旦获得批准，将为应用代码、管道构建清单和 Kubernetes 清单创建一个 Git 存储库。开发和生产名称空间也将使用适当的`RoleBinding`对象来创建。将创建反映每个应用角色的组，并将对这些组的访问权限授予应用所有者。
*   开发人员和操作人员可以通过请求或由应用所有者直接提供来访问应用。一旦被授予访问权限，开发人员的沙箱和开发命名空间中都需要更新。Git 存储库的更新是在用户的分叉中进行的，拉取请求用于将代码合并到驱动自动化的主存储库中。
*   所有的构建都是通过应用源代码控制中的“脚本”来控制的。
*   所有工件都发布到一个集中的容器注册中心。
*   所有生产更新都必须得到应用所有者的批准。
这个基本工作流不包括工作流的典型组件，如代码和容器扫描、定期访问重新认证或特权访问要求。这一章的主题本身很容易成为一本完整的书。目标不是构建一个完整的企业平台，而是为您提供一个构建和设计自己系统的起点。
## 选择我们的技术栈
在本节前面的部分中，我们一般性地讨论了管道。现在，让我们进入管道中需要什么技术的细节。我们之前已经确定，每个应用都有应用源代码和 Kubernetes 清单定义。它还必须构建容器。需要有一种方法来观察 Git 的变化并更新我们的集群。最后，我们需要一个自动化平台，以便所有这些组件协同工作。
基于我们对平台的要求，我们希望技术具有以下特点:
*   **开源**:我们不希望你为了这本书就去买任何东西！
*   **API 驱动的**:我们需要能够以自动化的方式供应组件和访问。
*   **有一个支持外部认证的可视化组件**:这本书聚焦企业，企业里的每个人都爱自己的 GUI。只是每个应用没有不同的凭据。
*   **支持于 Kubernetes** :这是一本关于 Kubernetes 的书。
为了满足这些要求，我们将在集群中部署以下组件:
*   **Git 注册表–Git lab**:Git lab 是一个功能强大的系统，为使用支持外部认证的 Git(即**单点登录(SSO)** )提供了很好的 UI 和体验。它集成了问题管理和广泛的应用编程接口。它也有一个赫尔姆图表，我们为这本书量身定制，运行一个最小的安装。
*   **自动化构建–Tekton**:最初是 Kubernetes 功能即服务部署的 Knative 项目的构建部分，Tekton 被剥离到自己的项目中，为通用应用提供构建服务。它在 Kubernetes 中运行，所有交互都是通过 Kubernetes API 进行的。还有一个早期仪表板！
*   **容器注册表–简单 Docker 注册表**:有很多非常有能力的开源注册表。由于这个部署会很快变得复杂，我们决定只使用 Docker 提供的注册表。上面不会有任何安全性，所以不要在生产中使用！
*   **GitOps–ArgoCD**:ArgoCD 是 Intuit 和 Weaveworks 合作打造的功能丰富的 GitOps 平台。它是 Kubernetes 原生的，有自己的 API，并将其对象存储为 Kubernetes 自定义资源，使其更容易自动化。它的用户界面和命令行界面工具都使用 OpenID Connect 与单点登录集成。
*   **访问、认证和自动化–OpenUnison**:我们将继续使用 OpenUnison 在我们的集群中进行认证。我们还将集成我们技术栈的用户界面组件，为我们的平台提供单一门户。最后，我们将使用 OpenUnison 的工作流基于我们的角色结构来管理对每个系统的访问，并提供所有东西协同工作所需的对象。访问将通过 OpenUnison 的自助服务门户网站提供。
翻阅这一技术栈，你可能会问“为什么不选择 *XYZ* ？”Kubernetes 生态系统是多样化的，不缺乏适合您集群的优秀项目和产品。这绝不是一个确定的栈，甚至也不是一个“推荐”的栈。它是满足我们需求的应用的集合，让我们专注于正在实现的过程，而不是学习特定的技术。
您可能还会发现，即使是这个栈中的工具之间也有相当多的重叠。例如，GitLab 有 GitOps 功能和自己的构建系统，但我们选择在本章中不使用它们。我们这样做是为了让您能够看到如何将不同的系统连接在一起以构建一个平台。您的平台可能使用 GitHub 的 SaaS 解决方案进行源代码控制，但在内部运行构建，并与亚马逊的容器注册相结合。我们希望您了解如何将这些系统连接起来，以构建一个平台，而不是专注于特定的工具。
本节深入探讨了管道设计背后的理论，并探讨了构建基于 Kubernetes 的平台的常见需求。我们确定了可以实现这些需求的技术组件，以及我们选择它们的原因。有了这些知识，是时候建造了！
# 准备我们的集群
在我们开始部署我们的技术栈之前，我们需要做一些事情。我建议从一个新鲜的集群开始。如果您正在使用本书中的 KinD 集群，请从一个新集群开始。我们正在部署几个需要集成的组件，重新开始会更简单、更容易，而不是潜在的与以前的配置做斗争。在我们开始部署将组成我们的栈的应用之前，我们将部署 JetStack 的证书管理器来自动化证书颁发、一个简单的容器注册表以及用于认证和自动化的 OpenUnison。
## 部署证书管理器
专注于 Kubernetes 的咨询公司 JetStack 创建了一个名为`cert-manager`的项目，以使证书的创建和更新更容易自动化。这个项目的工作原理是让您使用 Kubernetes 自定义资源定义发行者，然后在`Ingress`对象上使用注释，使用这些发行者生成证书。最终的结果是，一个集群运行在适当管理的轮换证书上，而不会生成单个**证书签名请求** ( **CSR** )或担心过期！
`cert-manager`项目最常被提及的是*让我们加密*(https://letsencrypt.org/)，以自动发布由商业认可的证书颁发机构免费签署的证书(如啤酒)。这是可能的，因为*让我们加密*自动化了这个过程。证书有效期只有 90 天，整个过程都是由应用编程接口驱动的。为了推动这种自动化，您必须有某种方式让*让我们加密*来验证您试图获取证书的域的所有权。在本书中，我们一直使用`nip.io`来模拟 DNS。如果你有一个你可以使用并且得到`cert-manager`支持的域名服务，比如亚马逊的 53 号路线，那么这是一个很好的解决方案。
由于我们使用的是`nip.io`，我们将使用自签名的证书颁发机构来部署`cert-manager`。这给了我们一个好处，拥有一个可以快速生成证书的证书颁发机构，而不必担心域验证。然后，我们将指示我们的工作站信任该证书以及我们部署的应用，以便使用正确构建的证书来保护一切。
重要说明
使用自签名证书颁发机构是大多数企业内部部署的常见做法。这避免了必须处理潜在的验证问题，因为商业签署的证书不会提供太多价值。大多数企业都能够通过其活动目录基础结构分发内部证书颁发机构的证书。您的企业有办法请求内部证书或也可以使用的通配符。
部署`cert-manager`的步骤如下: