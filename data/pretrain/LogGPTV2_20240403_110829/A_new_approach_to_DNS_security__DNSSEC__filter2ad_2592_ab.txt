techniques.
3.2 Motivation
Any public-key cryptographic algorithm requires some form
of authentication. Usually, this is achieved via trusted cer-
tiﬁcation authorities (CAs) which generate certiﬁcates on
the users’ behalf. A certiﬁcate binds the user’s identity to a
public key and contains other pertinent information such as
inception and expiration dates. It is assumed that a method
to verify the validity of certiﬁcates is known a priori.
Secure communication based on public-key cryptography
has several positive aspects and in particular: It requires
only a functional Trusted Third Party (TTP) and the TTP
has the ability to operate oﬀ-line in the sense that it does not
have to be involved during secure transactions. A functional
TTP does not have access to the secret keys corresponding
to the public keys, hence, in some scenarios, it does not have
to be unconditionally trusted. However, this does not apply
to the case of certiﬁed public keys. Indeed, the CA (i.e., the
TTP) could generate a fake certiﬁcate and pretend to be
someone else. It could then read encrypted messages or sign
1The symbol || denotes the concatenation operation.
88XY
KXY
K 1
K 2
XY
KR0
PXY
Inf o(PXY )
P ER0
N oncei
IX identity information about X
XY , K 2
XY ) shared by X and Y (Y ’s master key)
secret-key pair (K 1
secret key shared by X and Y used for encryption
secret key shared by X and Y used for MAC functions
root’s (R0) key pair (K 1
symmetric certiﬁcate shared by X and Y
contains relevant information about PXY
public-key encryption under root’s public key
r||t, where r is a random number and t a timestamp
R0 ) (root’s master key)
R0 , K 2
Table 1: Notation
arbitrary messages under the stolen identity. In this case,
the CA must be fully trusted. On the other hand, secret-key
cryptography requires unconditionally trusted TTPs which,
in addition, have to be operated on-line. However, secret-
key algorithms are extremely fast and make use of relatively
short keys.
The PK-DNSSEC system [20, 27] uses the entire DNS
tree of domains as an on-line certiﬁcation authority that,
for each request of host mapping information, returns the
public key of the authoritative server responsible for that
host. The DNS tree builds a chain of trust from the root
to the authoritative server and each node that is passed
through acts as a CA for its child nodes. In addition, the
information retrieved from the DNS database is signed by
DNS servers which must be then unconditionally trusted.
Let us emphasize these two points:
1. the DNS system is involved in any request, thus acting
as an on-line certiﬁcation authority;
2. the information retrieved from the database is signed
by name servers which implies that each DNS server
must be unconditionally trusted.
From the previous two points, it is clear that the network
conﬁguration and the trust model of PK-DNSSEC would not
change if secret-key cryptography were employed in place of
public-key cryptography.
In the next sections, we investigate a new approach to
DNS security based on secret-key cryptography. We pro-
pose a new system which addresses some open issues of the
current DNSSEC proposals.
3.3 The New Protocol
The notation used throughout the paper is shown in Ta-
ble 1. Given the DNS tree of domains, it is assumed that
each node shares a key with its parent, called master key.
For instance, the node serv.com (subdomain) shares a key
with .com (domain) that is referred to as the master key
of serv.com. The root domain has an asymmetric key pair
(public and secret keys) as well as its own master key that
is not shared with any other node. The root’s master key is
used to start the process of building the chain of trust from
the root to the authoritative servers.
The general idea behind our proposal is quite simple. As
a viable example, suppose that a local name server (acting
as a resolver) U queries the root domain server for the IP
address of host.company.com. The root is not authoritative
for this query and thus will refer the resolver to the DNS
server .com. (It is assumed that U has an authentic copy of
the root’s public key.) The root server generates a secret key
Ka which is sent (encrypted) to U along with a symmetric
certiﬁcate for .com. The key Ka will be shared by U and
the server .com. The symmetric certiﬁcate is an encryption
under the master key of .com of the key Ka and informa-
tion about U . The name server U queries .com by sending
the original DNS request along with the symmetric certiﬁ-
cate generated by the root server. The .com server will re-
trieve the key Ka from the certiﬁcate and use it to encrypt a
freshly generated key Kb. To safely communicate such a key
to .company.com, the server .com inserts the key Kb into an-
other symmetric certiﬁcate created for .company.com. The
key Kb will be shared by U and the server .company.com.
Finally, the server .company.com will send the IP address of
host.company.com to U symmetrically signed with Kb.
The entire process is done to create a trusted path from
the root to .company.com. Symmetric certiﬁcates can be
seen as a sort of tickets in the Kerberos system [10, 17] and
the trusted path from the root to the authoritative server
is similar to the trusted path created in Kerberos from the
authentication server to the destination server going through
the ticket-granting server [17].
Master keys are used to generate symmetric certiﬁcates
which allow safe transport of secret keys from the parent to
the child in the DNS tree. Each node shares a master key
with its node parent. This is usually achieved manually or
via out-of-band cryptographic techniques (as it is done for
transaction signatures (TSIGs) [25]).
Name servers acting as resolvers must have an authentic
copy of the root’s public key. (This is the same assumption
made in the PK-DNSSEC proposal.) Such a public key can
be recovered from trusted sources, bundled with the DNS
server software distribution or could just be printed in some
popular newspapers.
When a DNS resolver contacts the root server for the ﬁrst
time, it sends a request DN S RootCert Req encrypted un-
der the public key of the root. Inside the encryption, the re-
solver includes two secret keys K1, K2 and a protocol header
P H which should minimally contain the identities of both
the resolver and the root server, lifetime of the encryption,
and a nonce (i.e., a random number and a timestamp). The
root server will generate a symmetric certiﬁcate for itself,
the DNS root certiﬁcate, which is symmetrically signed and
encrypted with the key K2 and K1, respectively. The en-
cryption is then sent to the resolver. The symmetric certiﬁ-
cate will be used to create an authenticated channel between
the resolver and the root server.
Public-key cryptography is used only the ﬁrst time the re-
solver communicates with the root server, since the root does
89not store (and will never store) locally any secrets shared
with the resolvers. However, the next time the resolver con-
tacts the root server, it will communicate securely via eﬃ-
cient symmetric-key protocols (see Remark 1).
DNS Root Certificate:
R0 ←− U : P ER0 (P H, K1, K2, DNS RootCert Req);
R0 −→ U : PR0U , EK1 (KR0U , M ACK2 (KR0U , PR0U ));
PR0U = Inf o(PR0U ), EK1
R0
(KR0U ,
MACK2
R0
(Inf o(PR0U ), KR0U )).
The communication cost associated with the above re-
quest (two network messages) can be amortized.
Indeed,
the request for the root symmetric certiﬁcate can be sent
along with an ordinary DNS request.
The value Inf o(PXY ) contains relevant information about
the certiﬁcate PXY , shared by the servers X and Y , which
is similar to the information contained in standard public-
key certiﬁcates. In particular, Inf o(PXY ) has to minimally
contain the identity strings IX and IY , inception and expira-
tion dates, details about the encryption and authentication
algorithms employed, certiﬁcate and key unique identiﬁers
(in case of multiple keys), and the identity of the creator of
the certiﬁcate.
The resolver U may send a DNS query to the root do-
main server which is not authoritative for it. The root does
not need to store any information about U as all it needs is
stored into the symmetric certiﬁcate enclosed with the re-
quest. In particular, the certiﬁcate contains the necessary
secret keys used to create private and authenticated chan-
nels between the root and the host U .
DNS Request to Root with Symmetric Certificate:
R0 ←− U : PR0U , DNS Req, N once0;
R0 −→ U : PR1U , DNS Ans0, EK1
(KR1U ,
R0U
MACK2
R0 U
(DNS Ans0, N once0, KR1U ));
PR1U = Inf o(PR1U ), EK1
R0R1
(KR1U ,
MACK2
R0R1
(Inf o(PR1U ), KR1U )).
The response from the root is signed using the MAC func-
tion whose output is also encrypted under the key shared
by the root and the server U . The ﬁeld DNS Ans contains
the answer to U ’s query in accordance with the DNS pro-
In particular, DNS Ans contains information that
tocol.
undeniably identiﬁes it as the answer to the original query
DNS Req (e.g., DNS Ans may simply include DNS Req).
The symmetric signature contains also the nonce gener-
ated by U and a secret key that will be shared by U and R1.
Furthermore, in case of multiple keys being used, an addi-
tional piece of information containing key identiﬁers should
be included. The symmetric certiﬁcate of R1, PR1U , is sent
along with the signature. It contains the secret key KR1U
shared by R1 and U . Finally, the encryption is computed
under R1’s master key and contains a MAC function which
acts as symmetric signature and precludes malleability at-
tacks. Iterative requests to intermediated servers have the
same structure:
DNS Request to Intermediate Server:
Ri ←− U : PRiU , DNS Req, N oncei;
Ri −→ U : PRi+1U , DNS Ansi, EK1
MACK2
Ri U
(DNS Ansi, N oncei, KRi+1U ));
(KRi+1U ,
Ri U
PRi+1U =Inf o(PRi+1U ), EK1
RiRi+1
(KRi+1U ,
MACK2
RiRi+1
(Inf o(PRi+1U ), KRi+1U )).
Symmetric certiﬁcates can be cached and used later by U
for similar requests.
Once the authoritative server is queried by U , it will send
the answer signed using the MAC function. No other sym-
metric certiﬁcates are generated in this ﬁnal phase.
DNS Request to Authoritative Server:
Rn ←− U : PRnU , DNS Req, N oncen;
Rn −→ U : DNS Ansn, MACK2
Rn U
(DNS Ansn, N oncen);
DNS Ansn is the authoritative answer.
The above is a high-level description and it does not in-
clude implementation details needed for a robust and eﬃ-
cient execution of the protocol. We refer the reader to [2] for
technical details about the implementation of the system.
If mutual authentication and protection for DNS requests
are needed (see section 4), then, for any 0 ≤ i ≤ n, the ﬁrst
message
Ri ←− U : PRiU , DNS Req, N oncei
becomes:
Ri ←− U :
PRiU , DNS Req, N oncei, MACK2
Ri U
(DNS Req, N oncei).
The timestamp in N oncei should be veriﬁed by Ri, and
U should set a timeout period after which rejecting signed
messages which contain N oncei. Obviously, in case of mu-
tual authentication, the server U should authenticate itself
ﬁrst. This needs to be done only once, for instance it can
be done together with the request for the DNS root sym-
metric certiﬁcate. The server U would sign the public-key
encryption (the ﬁrst message) by computing:
90SIGNU (P H1, P ER0 (P H, K1, K2, DNS RootCert Req)),
where P H1 is a protocol header similar to P H which also
contains a sentence clearly stating that the signature is com-
puted over an encryption in accordance with the DNS pro-
tocol. The public-key of U may be embedded in a certiﬁcate
signed by some certiﬁcation authority recognized by the root
server. Finally, the root will set an appropriate ﬂag inside
the symmetric certiﬁcate to inform other nodes that the re-
solver was indeed authenticated. Similarly, this entire task
can be performed by any downward name server and not
necessarily by the root.
The resolving process will end once the resolver U sends
the information retrieved from the authoritative server to
the stub resolver H, which requested it. The host H could
share a key with the local name server U so they could
communicate securely via mechanisms that may be already
in place, such as TSIG [25]. The secret key may be generated
by the system administrators and stored manually in both
U and H.
Remark 1.
(Hybrid Approach). Notice that once a
name server becomes operative for the ﬁrst time, it has to
query one of the root servers for a root symmetric certiﬁcate.
This forces the root server to decrypt a message each time a
name server needs to use public-key encryption. This, how-
ever, is not an issue since the name server will retrieve the
root symmetric certiﬁcate and use it thereafter. Moreover, a
public-key encryption function is never applied on the entire
message but rather on a short symmetric key2.
Observe that the problem in DNSSEC is not that root
servers cannot compute cryptographic functions fast enough.
Indeed, root servers are very powerful (and expensive) ma-
chines 3 and, if necessary, they can be equipped with special-
ized hardware, such as high speed encryption accelerators.
The real problems in DNSSEC are the potential increase of
network traﬃc due to larger DNS messages and the high cost
of cryptographically verifying, at the resolver side, public-
key digital signatures computed over zone data.
Alternatively, however, it is possible to implement a hy-
brid system which uses both PK-DNSSEC and SK-DNSSEC.
The idea is to let some servers sign answers via public-key
signatures which will include, at a certain point, subdo-
mains’ public keys used by SK-DNSSEC. Suppose, for in-
stance, that root servers are conﬁgured to use PK-DNSSEC
whereas top-level domains use SK-DNSSEC. A resolver may
query one of the roots for the IP address of comp.ccc.com.
Since the root is not authoritative, it will send a referral
which will be signed via a public-key signature. The signa-
ture contains the SK-DNSSEC public-key of .com used for
encryption. The resolver can then start using SK-DNSSEC
by requesting a symmetric certiﬁcate from .com via the pro-
tocol, introduced earlier, used for requesting DNS root cer-
tiﬁcates.
This modus operandi may be useful to relieve certain
name servers (root servers, for instance) from computing
public-key decryptions.
2A fast Pentium III (800Mhz) server can compute about 200
RSA decryptions of a short key (128 bits) per second, when
the modulus is 768 bits long.
3The root server F.root-servers.net [8] is a virtual parallel
machine with currently 8 processors and a total of 8 Gb of
memory.
Operation
Create SK authoritative ans
Verify SK authoritative ans
Create SK referral
Verify SK referral
Create DSA signature
Verify DSA signature
Create RSA signature
Verify RSA signature
Create DSA signature
Verify DSA signature