如果分拆确实成为未来的方式，它也不会取代目前形式的资料库 —— 它们仍然会像以往一样被需要。为了维护流处理元件中的状态，资料库仍然是需要的，并且为批处理和流处理器的输出提供查询服务（请参阅 “[批处理工作流的输出](ch10.md#批处理工作流的输出)” 与 “[流处理](ch11.md#流处理)”）。专用查询引擎对于特定的工作负载仍然非常重要：例如，MPP 资料仓库中的查询引擎针对探索性分析查询进行了最佳化，并且能够很好地处理这种型别的工作负载（请参阅 “[Hadoop 与分散式资料库的对比](ch10.md#Hadoop与分散式资料库的对比)” 。
执行几种不同基础设施的复杂性可能是一个问题：每种软体都有一个学习曲线，配置问题和操作怪癖，因此部署尽可能少的移动部件是很有必要的。比起使用应用程式码拼接多个工具而成的系统，单一整合软体产品也可以在其设计应对的工作负载型别上实现更好、更可预测的效能【23】。正如在前言中所说的那样，为了不需要的规模而构建系统是白费精力，而且可能会将你锁死在一个不灵活的设计中。实际上，这是一种过早最佳化的形式。
分拆的目标不是要针对个别资料库与特定工作负载的效能进行竞争；我们的目标是允许你结合多个不同的资料库，以便在比单个软体可能实现的更广泛的工作负载范围内实现更好的效能。这是关于广度，而不是深度 —— 与我们在 “[Hadoop 与分散式资料库的对比](ch10.md#Hadoop与分散式资料库的对比)” 中讨论的储存和处理模型的多样性一样。
因此，如果有一项技术可以满足你的所有需求，那么最好使用该产品，而不是试图用更低层级的元件重新实现它。只有当没有单一软体满足你的所有需求时，才会出现拆分和联合的优势。
#### 少了什么？
用于组成资料系统的工具正在变得越来越好，但我认为还缺少一个主要的东西：我们还没有与 Unix shell 类似的分拆资料库等价物（即，一种宣告式的、简单的、用于组装储存和处理系统的高阶语言）。
例如，如果我们可以简单地宣告 `mysql | elasticsearch`，类似于 Unix 管道【22】，成为 `CREATE INDEX` 的分拆等价物：它将读取 MySQL 资料库中的所有文件并将其索引到 Elasticsearch 丛集中。然后它会不断捕获对资料库所做的所有变更，并自动将它们应用于搜寻索引，而无需编写自定义应用程式码。这种整合应当支援几乎任何型别的储存或索引系统。
同样，能够更容易地预先计算和更新快取将是一件好事。回想一下，物化检视本质上是一个预先计算的快取，所以你可以透过为复杂查询宣告指定物化检视来建立快取，包括图上的递回查询（请参阅 “[图资料模型](ch2.md#图资料模型)”）和应用逻辑。在这方面有一些有趣的早期研究，如 **差分资料流（differential dataflow）**【24,25】，我希望这些想法能够在生产系统中找到自己的方法。
### 围绕资料流设计应用
使用应用程式码组合专用储存与处理系统来分拆资料库的方法，也被称为 “**资料库由内而外（database inside-out）**” 方法【26】，该名称来源于我在 2014 年的一次会议演讲标题【27】。然而称它为 “新架构” 过于夸大，我仅将其看作是一种设计模式，一个讨论的起点，我们只是简单地给它起一个名字，以便我们能更好地讨论它。
这些想法不是我的；它们是很多人的思想的融合，这些思想非常值得我们学习。尤其是，以 Oz【28】和 Juttle【29】为代表的资料流语言，以 Elm【30,31】为代表的 **函式式响应式程式设计（functional reactive programming, FRP）**，以 Bloom【32】为代表的逻辑程式语言。在这一语境中的术语 **分拆（unbundling）** 是由 Jay Kreps 提出的【7】。
即使是 **电子表格** 也在资料流程式设计能力上甩开大多数主流程式语言几条街【33】。在电子表格中，可以将公式放入一个单元格中（例如，对另一列中的单元格求和），并且只要公式的任何输入发生变更，公式的结果都会自动重新计算。这正是我们在资料系统层次所需要的：当资料库中的记录发生变更时，我们希望自动更新该记录的任何索引，并且自动重新整理依赖于记录的任何快取检视或聚合。你不必担心这种重新整理如何发生的技术细节，但能够简单地相信它可以正常工作。
因此，我认为绝大多数资料系统仍然可以从 VisiCalc 在 1979 年已经具备的功能中学习【34】。与电子表格的不同之处在于，今天的资料系统需要具有容错性，可伸缩性以及持久储存资料。它们还需要能够整合不同人群编写的不同技术，并重用现有的库和服务：期望使用某一种特定的语言、框架或工具来开发所有软体是不切实际的。
在本节中，我将详细介绍这些想法，并探讨一些围绕分拆资料库和资料流的想法构建应用的方法。
#### 应用程式码作为衍生函式
当一个数据集衍生自另一个数据集时，它会经历某种转换函式。例如：
* 次级索引是由一种直白的转换函式生成的衍生资料集：对于基础表中的每行或每个文件，它挑选被索引的列或栏位中的值，并按这些值排序（假设使用 B 树或 SSTable 索引，按键排序，如 [第三章](ch3.md) 所述）。
* 全文搜寻索引是透过应用各种自然语言处理函式而建立的，诸如语言检测、分词、词干或词汇化、拼写纠正和同义词识别，然后构建用于高效查询的资料结构（例如倒排索引）。
* 在机器学习系统中，我们可以将模型视作从训练资料透过应用各种特征提取、统计分析函式衍生的资料，当模型应用于新的输入资料时，模型的输出是从输入和模型（因此间接地从训练资料）中衍生的。
* 快取通常包含将以使用者介面（UI）显示的形式的资料聚合。因此填充快取需要知道 UI 中引用的栏位；UI 中的变更可能需要更新快取填充方式的定义，并重建快取。
用于次级索引的衍生函式是如此常用的需求，以致于它作为核心功能被内建至许多资料库中，你可以简单地透过 `CREATE INDEX` 来呼叫它。对于全文索引，常见语言的基本语言特征可能内建到资料库中，但更复杂的特征通常需要领域特定的调整。在机器学习中，特征工程是众所周知的特定于应用的特征，通常需要包含很多关于使用者互动与应用部署的详细知识【35】。
当建立衍生资料集的函式不是像建立次级索引那样的标准搬砖函式时，需要自定义程式码来处理特定于应用的东西。而这个自定义程式码是让许多资料库挣扎的地方，虽然关系资料库通常支援触发器、储存过程和使用者定义的函式，可以用它们来在资料库中执行应用程式码，但它们有点像资料库设计里的事后反思。（请参阅 “[传递事件流](ch11.md#传递事件流)”）。
#### 应用程式码和状态的分离
理论上，资料库可以是任意应用程式码的部署环境，就如同作业系统一样。然而实践中它们对这一目标适配的很差。它们不满足现代应用开发的要求，例如依赖和软体包管理、版本控制、滚动升级、可演化性、监控、指标、对网路服务的呼叫以及与外部系统的整合。
另一方面，Mesos、YARN、Docker、Kubernetes 等部署和丛集管理工具专为执行应用程式码而设计。透过专注于做好一件事情，他们能够做得比将资料库作为其众多功能之一执行使用者定义的功能要好得多。
我认为让系统的某些部分专门用于持久资料储存并让其他部分专门执行应用程式程式码是有意义的。这两者可以在保持独立的同时互动。
现在大多数 Web 应用程式都是作为无状态服务部署的，其中任何使用者请求都可以路由到任何应用程式伺服器，并且伺服器在传送响应后会忘记所有请求。这种部署方式很方便，因为可以随意新增或删除伺服器，但状态必须到某个地方：通常是资料库。趋势是将无状态应用程式逻辑与状态管理（资料库）分开：不将应用程式逻辑放入资料库中，也不将持久状态置于应用程式中【36】。正如函数语言程式设计社群喜欢开玩笑说的那样，“我们相信 **教会（Church）** 与 **国家（state）** 的分离”【37】 [^i]
[^i]: 解释笑话很少会让人感觉更好，但我不想让任何人感到被遗漏。在这里，Church 指代的是数学家的阿隆佐・邱奇，他创立了 lambda 演算，这是计算的早期形式，是大多数函数语言程式设计语言的基础。lambda 演算不具有可变状态（即没有变数可以被覆盖），所以可以说可变状态与 Church 的工作是分离的。
在这个典型的 Web 应用模型中，资料库充当一种可以透过网路同步访问的可变共享变数。应用程式可以读取和更新变数，而资料库负责维持它的永续性，提供一些诸如并发控制和容错的功能。
但是，在大多数程式语言中，你无法订阅可变变数中的变更 —— 你只能定期读取它。与电子表格不同，如果变数的值发生变化，变数的读者不会收到通知（你可以在自己的程式码中实现这样的通知 —— 这被称为 **观察者模式** —— 但大多数语言没有将这种模式作为内建功能）。