图15 抓取到的上线包
命令加密后使用tcp协议发送，部分执行结果则使用http协议进行回传。如下是我们模拟木马命令，使用shell dir
列出感染设备当前目录所抓取到的数据包。从图16中可以看到，命令执行后的结果回传使用了http协议。
图16 控制命令执行后，返回的数据包
### 4.3 远程控制
从CS木马远控模块的控制命令和相关代码的反汇编结果来看（见图17），远控模块包含多种恶意功能。主要包括屏幕截图、键盘记录、socks代理、网络和主机枚举、端口扫描、文件上传和下载、执行powershell命令、提权、注入会话到特定进程以及DNS隧道攻击等（详细的的命令和功能介绍见附录部分）。由以上的分析可知，当对手下载并运行该伪造的“vpn客户端”，打开“vpn安装配置指南”文档研究的同时，红队方的木马已悄悄上线。红队方攻破对手内网后，能够利用该木马窃取对手的作战计划、掌握的工具和利用的漏洞等信息，红队方根据掌握的这些信息，可以有效调整自己的作战策略和应对计划。
图17 控制命令和代码执行
## 对抗技术分析
以上攻击案例中我们仅仅对CS木马从落地到远程控制的过程做了简要分析，在更多的案例中，CS木马还具备更加强大而丰富的安全对抗手段，如逃逸管道技术、DNS隧道、SMB隧道、Socks代理技术以及可定制的代码注入技术等等，这些技术手段的使用在很大程度上不但断提高自身的成活率，增强黑客攻击活动隐秘性，极好的保护黑客自身。本节将对CS使用到的此类技术的实现原理和机制进行详细的分析和讨论。
### 5.1 管道逃逸技术
CS木马使用了管道逃逸技术来躲避安全软件的查杀。该技术利用管道作为恶意代码的暂存通道，在很大程度上避免了安全软件的查杀，通过测试验证，该技术可以绕过很多主流杀毒软件（如360、ESET
Nod32）的安全检查。经我们的安全研究人员多次验证，该技术截至本文撰写时依然有效。CS木马利用管道逃逸技术执行远控模块的实现过程如下。
首先新起一个线程创建名为"\\.\pipe\MSSE-594-server"的命名管道（其中594为随机值）如图18，接着木马将长度为0x34200的加密数据写入到该命名管道中，等待后续读取和进一步的解密，写入的加密数据见图19。
图18 创建命名管道，写入加密数据
图19 加密数据
睡眠1024毫秒后，木马从前面创建的命名管道中读取加密数据，见图20。
图20 从命名管道读取数据
在解密数据之前，木马首先申请一段内存空间，用于存放解密后的payload，见图21。
图21 申请内存空间
木马将读取到的加密数据，每4个字节为一组，依次和整形数据0x1aa64991（不同的样本该数值会有不同）异或，异或运算后的值即为解密数据，最终解密出CS远控模块文件。
图22 解密数据
通过解密后的数据可以看出，该CS远控模块文件为Windows平台的PE文件，如图23。
图23 CS远控模块文件
CS木马在解密完远控模块后，将远控模块所在的内存属性修改为rx，并使用函数CreateThread执行远控模块代码，实现对感染机器的攻击和远程控制，如图24：
图24 启动线程执行CS远控模块
### 5.2 DNS隧道
DNS隧道是将其他的协议内容封装在DNS协议中，然后利用DNS查询过程来进行数据传输的技术。CS支持使用DNS隧道技术来和C&C服务器通信以应对复杂的网络环境。如图25，封装后的流量通过DNS递归查询，最终到达C&C服务器解密。同样，来自C&C服务器的指令也可以通过这种方式顺利下发到受控端。使用DNS隧道技术可以有效躲避防火墙、IDS、IPS等传统网络安全设备的检测（因为这些设备很难做到对DNS流量的友好规则控制），大大提高了渗透测试或攻击的隐蔽性。
图25 DNS隧道攻击
图26是一个使用DNS隧道模式进行通信的数据包，从图中我们可以看到，控制端发送的命令和受控端返回的流量都被隐藏在了DNS隧道中加密传输。
图26 DNS隧道模式通信的数据包
如图27，命令执行完后，受控端将回显信息封装成DNS字符串，通过DNS隧道回传给C&C服务器。
图27 回显信息加密传输
### 5.3 SMB隧道
CS支持内网主机之间使用基于SMB协议的 Beacon 来进行数据交换。这允许让一台受感染的计算机与 C&C 服务器进行正常的 beacon
连接，并使内部网络上的所有其他的服务器通过 SMB
协议与最初受感染的主机进行通信。如图28，在攻击者成功攻破内网主机目标1后再进行内网横向移动，将基于SMB的Beacon木马植入目标2主机。这样目标2上线后，就会通过SMB协议的命名管道和目标1通信，目标1再通过DNS或者HTTP协议将恶意流量转发出去。通过这样，攻击者可以操纵
Beacon
通信，实现让所有来自受感染主机的流量看起来和普通流量无异。采用这种连接方式，当安全管理人员检测到一个二级系统有问题并进行取证分析时，他们可能会无法识别与实际攻击相关的
C&C 服务器域名。
图28 SMB内网渗透
图29是内网中目标2和目标1的通信数据包，从图中可以看到，在完成SMB协议协商和会话后，目标2连接到了目标1的IPC$共享，然后利用该命名管道进行基于SMB协议的数据通信。
图29 SMB通信数据包
### 5.4 Socks代理
Cobalt Strike自带socks代理功能，在攻破组织内网后，beacon socks代理功能可以被用来对目标网络做进一步的内网渗透。如图30，web
server是一个位于内网的web服务器，其仅为组织内部服务。目标1为内网中一台可以访问外网的设备，攻击者在拿到目标1的控制权限后，可以在控制端开启beacon的socks功能，然后利用proxychains等本地代理工具访问webserver内网服务器，对目标组织进行更加深入的渗透攻击。
图30 Socks代理功能
如图31，是目标1通过beacon的socks代理转发给攻击者的内网服务器流量，从图中可以看到，攻击者成功访问了位于组织内部的Web Server服务。
图31 Beacon转发的流量
### 5.5 代码注入技术分析
在分析CS远控模块的过程中，我们发现根据不同的上下文条件，远控模块使用了不同的代码注入技术来实现远程代码的注入（图32为使用了远程线程及APC注入技术）。
图32 恶意代码的注入和执行
CS木马的注入方式是非常灵活的，其可以通过配置文件来进行灵活的配置，从官方博客中我们就可以看到beacon模块的代码注入配置样例。自从Cobalt
Strike更新至3.6版本后，官方给出了一个Malleable-C2，也就是在启动团队服务器的时候加载一些配置文件，Malleable-C2配置文件中的进程注入块（process-inject block）决定了进程注入行为的内容并且控制进程注入行为。
图33 process-inject block
进程注入块是围绕进程注入流程的生命周期组织的，分为以下4步：
图34 进程注入流程
第一步是隐式的，如果生成一个临时进程，例如后开发工作（post-exploitation
job），实际上已经有了对远程进程进行操作的句柄。如果要对现有的远程进程注入代码，恶意payload会使用OpenProcess函数。
对于第二步和第三步，恶意payload有两个选择来分配远程进程中的内存并将数据复制到其中。第一个选择是经典的VirtualAllocEx->WriteProcessMemory模式，另一个选择是CreateFileMapping->MapViewOfFile->NtMapViewOfSection模式。
第四步，这一步之前，要注入的内容已经复制到了远程进程当中，这一步需要做的就是执行这些内容，这就是process-inject->execute块的作用。执行块控制着恶意payload注入代码到进程的方法，恶意payload检查执行块中的每个选项，以确定该选项是否可用于当前上下文，在方法可用时尝试该方法，如果没有执行代码，则继续执行下一个选项。可以看到，执行块中的执行选项包括“CreateThread”、CreateRemoteThread、NtQueueApcThread、NtQueueApcThread
s、RtlCreateUserThread等函数。
CreateThread和CreateRemoteThread函数有一些变体，这些变体使用另一个函数的地址生成一个挂起的线程，更新挂起的线程以执行注入的代码，并恢复该线程。使用[function]”module!function+0x##”指定要欺骗的起始地址。对于远程进程，多使用ntdll和kernel32模块。可选的0x##部分是添加到起始地址的偏移量。这些变体只适用于x86到x86和x64到x64注入。
SetThreadContext和NtQueueApcThread-s函数特定于为恶意payload的后开发作业（Post Exploitation
Jobs）启动临时进程。这些函数会挂起进程的主线程，并使用它执行被注入的后开发恶意功能。
NtQueueApcThread、RtlCreateUserThread和CreateRemoteThread是向远程进程注入代码的常用函数。RtlCreateUserThread函数有一个用于x86到x64注入的实现变体。CreateRemoteThread和RtlCreateUserThread都处理x64到x86注入。所有其他函数包括x86到x86和x64到x64的注入。
Post Exploitation Jobs-很多Cobalt Strike的后开发（post-exploitation）特性（比如屏幕截图、键盘记录、哈希存储等）被实现为Windows的dll。为了执行这些特性，Cobalt
Strike生成一个临时进程，并将这些功能注入其中，进程控制块（process-inject block）控制这一进程注入步骤。后开发控制块（post-ex
block）（见图35）则控制Cobalt Strike后开发特性的特定内容和行为。
图35 post-ex block
下图是我们的研究人员在搭建的Cobalt
Strike攻击环境后，执行恶意命令，受害机器进程的监控情况，从图中可以看到，每当执行一个截图命令或者“spawn”等“后渗透”相关命令，在受害机器上都会新起一个rundll32进程和攻击服务器通信。
图36 后渗透相关功能
## 总结
本文揭秘了Cobalt Strike框架的在野使用情况并深入介绍了相关木马的核心技术。Cobalt
Strike使用者遍布全球，不论是APT组织还是红队人员，都被该框架出色的易用性、可扩展性以及隐匿性所吸引。我们也观察到几类现象，一是越来越多的攻击者开始选择商业软件作为攻击武器，一方面能够降低代码被溯源的可能性，另一方面也可以有效降低攻击成本；二是攻击者越发重视自身的隐蔽性，大量采用了域名仿造、CDN、域前置、DNS隧道、流量伪装等技术对抗检测，而Cobalt
Strike框架本身在通信隐匿方面具有很大的优势，其不仅提供了http、https、dns、smb等多种主流上线协议，还支持自定义通信流量特征，这也促成了其在全世界的广泛流行；三是目前主流的威胁情报平台和检测防御系统面临越来越大的压力，在面对Cobalt
Strike这类隐匿方式多样、对抗手段丰富的攻击武器时，大量未知的APT攻击难以被发现和披露，这也需要持续加强深度有效的特征指纹、流量分析和关联分析等能力，以应对越来越复杂的网络攻击活动。
无论怎样，恶意攻击的关键步骤是传播和落地，防重于治，在恶意攻击造成严重损失后再去修补漏洞显然只是无奈的选择，安全管理最重要的还是对人的管理，需要从源头把好关、“治病于未病”。因此，不管是对于企业还是个人，都应该加强安全意识，不要轻易打开未知来源的邮件和附件，不轻易点击未知链接，不打开不可靠的文档，不执行未知的程序，及时更新系统补丁和应用程序，守住我们的系统和数据安全。
## 附录
beacon命令列表
**命令** | **描述**  
---|---  
argue | Spoof arguments for matching processes  
browserpivot | Setup a browser pivot session  
bypassuac | Spawn a session in a high integrity process  
cancel | Cancel a download that's in-progress  
cd | Change directory  
checkin | Call home and post data  