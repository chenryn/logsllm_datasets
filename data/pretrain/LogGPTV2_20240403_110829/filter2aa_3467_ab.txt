ELF32
Type:
DYN (Shared object file)
Machine:
ARM
Entry point address:
0x433c
Start of program headers:
52 (bytes into file)
Start of section headers:
92204 (bytes into file)
Size of program headers:
32 (bytes)
Number of program headers:
6
Size of section headers:
0 (bytes)
Number of section headers:
0
Type
Offset
VirtAddr
PhysAddr
FileSiz
MemSiz
Flg
Align
EXIDX
0x028584
0x00028584
0x00028584
0x00568
0x00568
R
0x4
LOAD
0x000000
0x00000000
0x00000000
0x131ec
0x131ec
RE
0x8000
LOAD
0x018c1c
0x00030c1c
0x00030c1c
0x00520
0x01538
RW
0x8000
DYNAMIC
0x018c80
0x00030c80
0x00030c80
0x00108
0x00108
RW
0x4
GNU_STACK
0x000000
0x00000000
0x00000000
0x00000
0x00000
RW
0x4
GNU_RELRO
0x018c1c
0x00030c1c
0x00030c1c
0x003e4
0x003e4
R
0x1
Entry address points to compressed code (anti-debugging)
Start of section table is out of file bounders
No section table (anti-debugging)
Exception Index Table is out of file bounders (IDA crash)
Program headers:
0x0000000c (INIT)
0x125A9
0x00000019 (INIT_ARRAY)
0x30C1C
...
Dynamic section:
Real entry point
Bangcle - libsecexe.so
0xf4
0x9d0
0x1cb0
0x3b79
0x43e0
0x125a9
0x13150
HASH
SYMTAB
STRTAB
REL
Compressed code
TEXT (init code)
0x433c
0x12590
0x433c
0x4638
0x4938
0xde38
0xe050
0x28aec
a1
r1
r2
JNI_OnLoad
Copy code sections to an 
allocated buffer.
Decompress 0x247b0 bytes 
to 0x433c 
Registration 
com.secneo.guard.ACall 
native methods: a1, r1, r2, ...
Bangcle - Processes
Extract ELF /data/data//.cache/ from apk (Assets)
fork app process
execl /data/data//.cache/  -1114751212 1 /data/app//base.apk 34  43 44 0
fork pkg process (from libsecmain.so::so_main)
anti-debugging thread
fork pkg process if .cache/classes.dex (OAT) does not exist
LD_PRELOAD=/data/data//.cache/libsecpreload.so
LD_PRELOAD_ARGS= 9 13 
LD_PRELOAD_SECSO=/data/data//.cache/libsecmain.so
execl /system/bin/dex2oat 
–zip-fd=9 –zip-location=/data/data//.cache/classes.jar –oat-fd=13
–oat-location=/data/data//.cache/classes.dex –instruction-set=arm
Function a1
Function r2
Bangcle - libc.so hook
libc func
Offset
libc func
Offset
munmap
0x15BD8
close
0x14FAC
msync
0x15F88
__openat
0x14DA4
read
0x15118
pread64
0x162F8
__mmap2
0x15420
pwrite64
0x166DC
__open
0x14B9C
write
0x152FC
Protection was changed
Function r1
Bangcle - Summary
●
Creates a stub in Java activity to load native library.
●
Native library is protected with different anti research techniques.
●
Native library hooks libc for handling the opening of the OAT file.
Baidu - Classification
Classes
-
StubApplication
-
StubProvider
Files
-
libbaiduprotect
-
baiduprotect1 (original dex)
Baidu - Native Loader Implementation
public class A implements Enumeration {
    public static native byte B(int arg0, Object arg1, ...);
    public static native char C(int arg0, Object arg1, ...);
    public static native double D(int arg0, Object arg1, ...);
    public static native float F(int arg0, Object arg1, ...);
    public static native int I(int arg0, Object arg1, ...);
    public static native long J(int arg0, Object arg1, ...);
    public static native Object L(int arg0, Object arg1, ...);
    public static native short S(int arg0, Object arg1, ...);
    public static native void V(int arg0, Object arg1, ...);
    public static native boolean Z(int arg0, Object arg1, ...);
    public static native void a();
    public static native void b();
    public static native String[] c();
}
Func
Offset
a
0x23459
b
0x2345d
c
0x23461
V, Z, B, C, S, I, J, F, D, L
0x25861
Baidu - libbaiduprotect.so
0x1000
0x2e6d
0x2ea4
0x23459
0x2345d
0x23461
0x25861
0x3ca78
0x4286c
JNI_OnLoad
a
b
c
V, Z, B, C, S, I, J, F, D, L
TEXT (Entry point 1)
Change self protection 
0x2000 - 0x3d000
Decrypt code 
0x2e6d - 0x3ca78
Change self protection 
0x0 - 0x1000
Remove ELF header
Baidu - JNI_OnLoad
Anti-debugging
Registration of native methods: a, b, c, …
Extract packed DEX /Assets/baiduprotect1.jar to /data/data//.1/1.jar
Create empty DEX file /data/data//.1/classes.jar
Hook libart.so
Create DexClassLoader(/data/data//.1/classes.jar) + Merge with main class loader by 
extending BaseDexClassLoader::pathList::dexElements
Baidu - Anti-debugging
●
Obfuscation
●
Logs disabling
●
For each /proc/ check that /proc//cmdline does not contain gdb, gdbserver, android_server
●
For each /proc/self/task check that /proc/self/task//status does not contain TracerPid
●
For each /proc/self/task check that /proc/self/task//comm does not contain JDWP
●
Check android.os.Debug.isDebuggerConnected
●
select call (timer) based technique
●
inotify watch (IN_ACCESS + IN_OPEN) of 
○
/proc/self/mem 
○
/proc/self/pagemap 
○
For each /proc/self/task
■
/proc/self/task//mem 
■
/proc/self/task//pagemap 
Baidu - libart.so hook
libc func
Libart hook
Offset
read
0x309BC8
0xA75C
open
0x309BDC
0x8FAC
close
0x309BE4
0x9168
mmap
0x309BE8
0x9474
strstr
0x309C58
0x8BD8
fork
0x309F3C
0x92DC
waitpid
0x309F40
0xA5E4
execv
0x309F4C
0xA324
__android_log_print
0x309FAC
0xA750
 Function __android_log_print
No logs
 Function execv
dex2oat hook:
Add environment variable ANDROID_LOG_TAGS=*:f
Prevent code compilation: add --compiler-filter=verify-none command line parameter
 Function open
Decrypt /data/data//.1/1.jar in case of /data/data//.1/classes.jar file loading
Baidu - Summary
●
Creates a stub in Java activity to load native library.
●
Native library is protected with different anti research techniques .
●
Native library hooks libc for handling the opening of the DEX file.
libc::open == decryption
Bangle 
Baidu
Filter by file path:
/data/data//.cache/classes.dex
/data/data//.1 /classes.jar
Expect to see:
OAT 
DEX
Using the DEX Loading Process to Unpack Apps
Where is first call of DEX/OAT file opening?
DEX 
OAT
dalvik.system.DexClassLoader::DexClassLoader
dalvik.system.DexFile::DexFile
DexFile::openDexFileNative
DexFile_openDexFileNative
ClassLinker::OpenDexFilesFromOat
OatFileAssistant::MakeUpToDate
OatFileAssistant::OatFileIsUpToDate
OatFileAssistant::GetOatFile 
OatFile::Open
OatFile::OpenElfFile → DexFile::DexFile
OatFileAssistant::GivenOatFileIsUpToDate
OatFileAssistant::GetRequiredDexChecksum
DexFile::GetChecksum
OpenAndReadMagic
platform/art/runtime/dex_file.cc patch
static int OpenAndReadMagic(const char* filename, uint32_t* magic, std::string* error_msg) 
{
    CHECK(magic != nullptr);
    ScopedFd fd(open(filename, O_RDONLY, 0));  
    …
    char* fn_out = new char[PATH_MAX];
    strcpy(fn_out, filename);
    strcat(fn_out, "__unpacked");
    int fd_out = open(fn_out, O_WRONLY|O_CREAT|O_EXCL, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
    struct stat st;
    if (!fstat(fd.get(), &st)) {
      char* addr = (char*)mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd.get(), 0);
      write(fd_out, addr, st.st_size);
      munmap(addr, st.st_size);
    }   
    close(fd_out);
    delete fn_out;
    ...  
}
DexFile::DexFile(const uint8_t* base, size_t size,
        const std::string& location,
        uint32_t location_checksum,
        MemMap* mem_map,
        const OatDexFile* oat_dex_file)
    : begin_(base),
      size_(size), 
      ... 
{  
    ...
    std::ofstream dst(location + "__unpacked", std::ios::binary);
    dst.write(reinterpret_cast(base), size);
    dst.close();
    ...
}
DEX 
OAT
Demo Time!
Unpacking modification 
instructions to AOSP can 
be found @checkpoint 
github repo
Questions?