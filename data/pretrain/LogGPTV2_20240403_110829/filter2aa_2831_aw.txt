method, you're calling a local non-COM method of the smart
pointer class. The wrapper method will call the raw COM
method directly, and check the HRESULT returned.
Here's the definition of an actual wrapper class method. The
wrapper class is IBasicTypes. This code comes from a TLI file.
inline HRESULT IBasicTypes::LongTest ( long l, 
long * pl ) 
{
Summary
261
Additonal Information and Updates: http://www.iftech.com/dcom
  HRESULT _hr = raw_LongTest(l, pl);
  if (FAILED(_hr)) _com_issue_errorex(_hr, 
this, __uuidof(this));
  return _hr;
}
As you can see, the wrapper class just calls the raw COM
interface. In this example, raw_LongTest() is an actual COM
method. The preceding "raw" was automatically appended to the
method by the compiler when it created the smart pointer. The
raw method will return a normal HRESULT code. If the HRESULT
is an error, a _com_error object is created, and thrown as an
exception. If you debug into a COM method of a client using the
#import directive, you'll see a very similar piece of code.
Summary
We've examined some template basics, and looked at how ATL
implements COM. Of course the purpose of ATL is to hide all
this implementation. Unfortunately, when you start debugging,
you'll quickly find yourself trying to understand the ATL code.
The final section of this chapter examined the native com-
piler directive #import. Import uses the type library to generate
two header files that include extensive definitions. One of the
most useful parts of the import directive is the use of smart
pointers. Using smart pointers, we can simplify much of our cli-
ent application.
262    Chapter 15 •
ATL and Compiler Support 
S
I
X
T
E
E
N
16
Other Topics   
COM is full of concepts and techniques that aren't normally seen
by programmers. This section attempts to deal with several of
these. Most of these items are unrelated, but may be useful when
you are working with COM applications.
Errors
We've already briefly discussed HRESULTS. Strangely enough,
HRESULTS aren't handles, and they aren't results. An HRESULT is
the 32-bit status code returned by almost all COM functions. 
Normally in C and C++, we write functions to return values.
The atoi() function is typical; it returns an integer from a string.
int x = atoi( "100" );
As C++ programmers, we're in the habit of returning mean-
ingful values as function results. COM needs to do things a little
differently. A COM method always should return an HRESULT.
Here's how we would write the COM method for a hypothetical
interface called ITest:
264    Chapter 16 •
Other Topics 
int x;
HRESULT hr = ITest->AtoI(  &x,  "100" );
In COM we can't guarantee that the method call will suc-
ceed. Returning an HRESULT allows the client to receive out-of-
band information. Typically, a client might receive notification
that it has lost communication with the server. If this were the
case, the integer result returned by ITest->AtoI() would be mean-
ingless.
The two most common HRESULTS are S_OK and E_FAILED.
S_OK is defined as the number zero. When you test an
HRESULT, you should use the predefined macros SUCCEEDED()
and FAILED(). This is necessary because there are numerous suc-
cess codes besides S_OK. Following is the standard method of
checking COM errors.
HRESULT hr;
hr = CoCreateInstance(,,,…);
if (SUCCEEDED(hr))
{
… // continue processing
}
The HRESULT is segmented into several bit fields, each of
which defines part of the status. 
 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+---+-+-+-----------------------+-------------------------------+
|Sev|C|R|     Facility          |               Code            |
+---+-+-+-----------------------+-------------------------------+
The meaning of these bits are as follows
Bits
Description
0-15
Information Code. Describes the specific error.
16-27
Facility Code. The subsystem that created the error.
28
Customer code flag. (not commonly used)
29
Reserved bit.
30-31
Severity Code. 
Table 16.1
HRESULT bit fields
Errors
265
Additonal Information and Updates: http://www.iftech.com/dcom
Information Code
This part of the error status defines the specific message. The
code can be extracted with the macro HRESULT_CODE(), which
applies a bit-mask to the HRESULT, returning only the code field.
Facility Code
Windows divides its error messages into groups, or facilities. The
facility is the subsystem that created the error code. There are a
number of standard facilities defined for windows. Each has a
#define to identify it:
There are several other less common facilities defined in
WINERROR.H.
Facility
Description
Value
FACILITY_WIN32
General Windows error codes. Generally 
these were returned by the Windows API.
7
FACILITY_RPC
Codes returned by the RPC services. These 
generally indicate a communications prob-
lem.
1
FACILITY_DISPATCH Errors generated by Idispatch interfaces.
2
FACILITY_STORAGE
Errors from structured storage. Generally 
the IStorage and IStream intefaces.
3
FACILITY_ITF
Interface dependent error codes. Each inter-
face may define it's own codes.
4
FACILITY_SSPI
Security Support Provider Interface (SSPI). 
Generally related to authentication and 
security.
9
FACILITY_WINDOWS Error codes from Microsoft defined inter-
faces.
8
FACILITY_NULL
General codes, such as S_OK.
0
Table 16.2
HRESULT Facility Codes
266    Chapter 16 •
Other Topics 
Customer Code Flag and Reserved bits 
You probably won't see much of either of these. The customer
code is designed to allow interfaces to use their own specific set
of errors. The reserved flag is just that, reserved for use by
Microsoft.
Severity Code
The most significant two bits of the HRESULT represent the
severity of the message. The severity code can be extracted with
the HRESULT_SEVERITY() macro. In general, whenever you see
an HRESULT with a negative decimal value, it is an error.
Looking Up HRESULTS
Much of the information about HRESULTs can be found in the
system header file WINERROR.H. It's worth your time to open
and browse this header, it is often a good source of information
on error codes. Most of the errors in this file are not COM errors. 
In general, HRESULTS are best viewed in hexadecimal.
Many of the common error codes have the severity bit set, so
they appear as large negative numbers in decimal. For example,
the decimal number -2147221164 is much more readable as
0x80040154.
Because the HRESULT is a combination of several fields,
you won't always be able to find your specific error code in
WINERROR.H. 
One 
of 
the 
more 
common 
errors,
RPC_S_SERVER_UNAVAILABLE, isn't in WINERROR.H. If you
look it up, you'll find it mapped to the decimal number 1722.
Severity
Description
0
Success.
1
Information. Just an informational message,
2
Warning. An error that requires attention.
3
Error. An error occurred.
Table 16.3
HRESULT Severity Codes
Displaying Error Messages
267
Additonal Information and Updates: http://www.iftech.com/dcom
This number is only the information code. The code returned by
CoCreateInstance is 0x800706ba. This number is composed of
several bit fields, it breaks down into the following:
0x10000000 + SEVERITY_WARNING 
0x00070000 + FACILITY_RPC 
0x000006ba + SERVER_UNAVAILABLE (1722L)
-------------------------------------
0x800706ba = RPC_S_SERVER_UNAVAILABLE
SCODES
The SCODE is a holdover from 16-bit windows. On Win32, the
SCODE is defined as a 32-bit DWORD value. They are the pro-
genitor of the HRESULT, so there are many similarities. Although
interchangeable on Win32, you should use HRESULTS. If you see
the term SCODE, you're probably working with code that was
ported from Windows 3.1.
Displaying Error Messages
We've shown how to interpret and find error codes using the
 header. Obviously, there are easier ways to get
this information. Perhaps the most accessible method is to run
"Error Lookup" application included in the Developers Studio.
(Under the TOOLS menu.) This is OK for debugging, but you
can also generate the text of the error messages interactively.
Using the _com_error class is by far the easiest way to dis-
play error messages. You can construct a _com_error object with
your HRESULT and call the ErrorMessage message to get a string.
#include 
HRESULT hr = S_OK;
_com_error e(hr);
cout  to get the
_com_error definition.
Using FormatMessage
The FormatMessage function can be used to look up the
text 
of 
the 
message. 
Specifying
FORMAT_MESSAGE_FROM_SYSTEM tells the function to look
up the HRESULT in the system message tables. 
char *pMsgBuf = NULL;
// build message string
::FormatMessage( 
FORMAT_MESSAGE_ALLOCATE_BUFFER | 
FORMAT_MESSAGE_FROM_SYSTEM | 
FORMAT_MESSAGE_IGNORE_INSERTS,
    NULL,
    hr,
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
    (LPTSTR) &pMsgBuf,
    0,NULL);
CString MyCopy = pMsgBuf;
// Free the buffer.
LocalFree(pMsgBuf) ;
In this example, we are passing in an HRESULT code (hr) as
the third argument. The error string will be written to a buffer
pointed to by pMsgBuf. Note that this buffer is allocated by For-
matMessage. This happened because we passed in the
FORMAT_MESSAGE_ALLOCATE_BUFFER flag. FormatMessage
will allocate the buffer, fill it with the message text, and return
the pointer. This buffer needs to be de-allocated using LocalFree.
LocalFree is considered to be obsolete, but I use it because the
documentation for FormatMessage says it's required. You should
also note that we're making a copy of the string before calling
LocalFree.
Aggregation and Containment
269
Additonal Information and Updates: http://www.iftech.com/dcom
Aggregation and Containment
COM offers two alternatives for the re-use of components. Con-
tainment means that an interface 'contains' another interface, and
uses it to accomplish its goals. Aggregation is the act of combin-
ing COM objects: one COM object directly exposes another COM
object without the client knowing it is dealing with two compo-
nents.
Containment in COM is very straightforward. The outer, or
'containing' object, creates an instance of the inner object. It cre-
ates the 2nd object, and passes calls along to that object.
HRESULT ObjectA::BeepMe( long lDuration )
{
IBeepObj *pInner;
HRESULT hr = CoCreateInstance( CLSID_ObjectB,
NULL, 
CLSCTX_INPROC_SERVER,
IID_IBeepObj,
(void**)&pInner );
if (SUCCEEDED(hr))
{
hr = pInner->BeepMe(lDuration);
pInner->Release();
}
return hr;
}
This is a rather simple example. Normally, we would expect
the containing object to create the contained object and keep it
around for later use.  You have a lot of flexibility in how you
implement containment.
As you can see, the calling client will have no idea it is deal-
ing with a second component. The first object completely man-
ages the lifetime of its contained object. This technique is very
simple and easily implemented. Aggregation is a special case of
containment.
270    Chapter 16 •
Other Topics 
The problem with containment is that the outer object may
have to implement every single method of its contained object. If
there are a lot of methods, this can be aggravating. An aggre-
gated object does not require these 'shell' methods. Aggregation
actually exposes the complete inner object. The client will
believe that it is actually dealing with a single component. Hid-
ing the existence of the inner object introduces some very tricky
programming into the implementation of IUnknown. Aggreag-
table classes need a special version of QueryInterface, and spe-
cial reference counting. The inner object needs to be specifically
coded to handle aggregation.
Once again, ATL takes care of much of this complexity. By
default, all wizard-generated ATL classes are aggregatable. This is
controlled by the radio button on the ATL Object Wizard Proper-
ties dialog. By allowing aggregation, you give other program-
mers the flexibility to aggregate your class. 
The class factory of the ATL object has a base class of CCo-
mAggObject, which handles the special IUnknown. This comes
from the ATL template macro DECLARE_AGGREGATABLE(). By
Figure 16–1
Configuring for aggregation
Building a COM Object with MFC
271
Additonal Information and Updates: http://www.iftech.com/dcom
selecting NO to aggregation, you'll get the DECLARE_NOT_
AGGREGATABLE macro. 
Building a COM Object with MFC
You can build perfectly good COM objects using MFC. MFC uses
the base class CCmdTarget and a number of macros to imple-
ment COM. In this example we'll use MFC to create a COM ready
class. This example comes from the MfcClient example program. 
 CCmdTarget is the base class for MFC message maps. CCm-
dTarget is fully capable of supporting OLE. This means it sup-
ports COM. What you we are doing in this section, therefore, is
demonstrating how to use MFC in place of ATL. As discussed in
Chapter 15, ATL is the preferred choice for server implementa-
tion. However, there are occasions where the use of MFC can
have advantages. For example, if you have developed an MFC
client and you want to embed a callback object inside of it so
that the server can talk back to the client, then you suddenly
have a need to implement COM with MFC. This example pre-
sented here is based on the Callback client from the chapter on
Callbacks. MFC supports COM at a lower level, and we're going
to have to write some of the basic COM plumbing to get this
example to work.
We will assume you have already defined the COM interface
using MIDL. We will be implementing a COM interface named
ICallBack that was created in the Callback chapter. In order to
get the MIDL-generated definitions, we'll include two files from
the server. Note that the path to these include files is relative.
You will need to ensure that they point to the correct files where
you created the server project.
#include "../CallbackServer/CallbackServer _i.c"
#include "../CallbackServer /CallbackServer.h"
The CCmdTarget class has several interesting features. This
class has a Windows message loop. It also implements the stan-
dard methods of IUnknown. As you recall, these are QueryInter-
272    Chapter 16 •
Other Topics 
face(), AddRef(), and Release(). Simply by inheriting from
CCmdTarget, we get a fully functional COM object.
We're also going to use an obscure feature of C++ language
- nested classes. If you're unfamiliar with nested classes, they are
straightforward. A nested class is a class declared within the
scope of another class. Whenever you reference a nested class,
you need to fully qualify the name with both classes. 
You're going to see a lot of macros in the following code.
MFC/OLE uses macros quite extensively. This makes sense,
because the fundamentals of COM are very standardized. These
macros, however, can make MFC-style COM difficult to follow.
We will create our class object as follows:
class CMyCallback : public CCmdTarget
{
public:
CMyCallback(){};
DECLARE_INTERFACE_MAP()
public:
BEGIN_INTERFACE_PART( MyEvents, ICallBack )
STDMETHOD(Awake)(long lDuration);
END_INTERFACE_PART(MyEvents)
};
The BEGIN_INTERFACE_PART and END_INTERFACE_PART
create a nested class. This nested class appends an X to the
string "MyEvents", and declares a member variable named
m_xMyEvents of the same type. The macro expands out into
code that is similar to this:
// code generated by BEGIN_INTERFACE_PART macros
class XMyEvents: public ICallBack
{
public: 
ULONG AddRef(); 
ULONG Release(); 
HRESULT QueryInterface(REFIID iid, LPVOID* 
ppvObj); 
HRESULT Awake(long lDuration);
} m_xMyEvents;
Building a COM Object with MFC
273
Additonal Information and Updates: http://www.iftech.com/dcom
friend class XMyEvents;
The class XMyEvents will have to implement the three meth-
ods of IUnknown. Because it is a custom interface, it also has a
custom method Awake(). This is the only application-specific
method exposed by this COM object. In order to reference
AddRef 
in 
the 
nested 