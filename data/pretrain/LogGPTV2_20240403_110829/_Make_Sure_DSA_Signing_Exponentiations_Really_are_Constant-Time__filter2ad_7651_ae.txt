Hence, we can set:
t =
(cid:106)
(cid:106)
−(cid:96)(cid:107)
q
−1 · r · 2
s
(2n + a − s
−1 · h(m)) · 2
u =
v = |α · t − u|q
and by (1) we have |v| ≤(cid:6)q/2(cid:96)+1(cid:7).
Out of the HNP instances we generate, we select at ran-
dom 49 for the SSH attack, 130 for the TLS attack and
construct a lattice as described in Section 2.5.2. We solve
the CVP problem with a Sage script, performing lattice re-
duction using BKZ [34], and enumerate the lattice points
using Babai’s Nearest Plane (NP) algorithm [7]. We ap-
ply two diﬀerent techniques to extend NP to a larger search
space. First, we take multiple rounding values to explore
210 diﬀerent solutions in the tree paths [23, Sec. 4]. Second,
we use a randomization technique [26, Sec. 3.5] and shuﬄe
the rows of B between lattice reductions. We repeat with
a diﬀerent random selection of instances until we ﬁnd the
private key.
Table 2: Empirical lattice attack results over a thou-
sand trials. Set size and errors are mean values.
Iterations and CPU time are median values.
Victim
Key size
Handshakes
Lattice size
Set size
Errors
Iterations
CPU minutes
Success rate (%)
OpenSSH (SSH)
1024/160-bit
260
50
70.8
2.1
13
5.9
100.0
stunnel (TLS)
2048/256-bit
580
131
158.1
1.7
22
38.8
100.0
6.3 Results
We implemented the attack and evaluated it against the
two protocols, SSH with 1024/160-bit DSA and TLS with
2048/256-bit DSA. Table 2 contains the results. For both
protocols we only utilize traces with (cid:96) ≥ 3. With this value
we experimentally found that we require 49 such signatures
for SSH and 130 for TLS in order to achieve a reasonable
probability of solving the resulting CVP.
Because the nonces are chosen uniformly at random, only
about one in every four signatures has an (cid:96) that we can
utilize. To gather enough signatures and to compensate for
possible trace errors, we collect 580 SM sequences from TLS
handshakes and 260 from SSH.
On average, these collected sequences yield 70.8 (SSH)
and 158.1 (TLS) traces with (cid:96) ≥ 3. Comparing the traces to
the ground truth, we know that on average less than 3 have
trace errors. However, because an adversary cannot check
against the ground truth, we leave these erroneous traces
in the set and use them in the attack. We note that due
to the smaller key size in SSH, trace errors are much more
prevalent there.
We construct a lattice from a random selection of the col-
lected traces and attempt to solve the resulting CVP. Due
to the presence of the error traces there is a non-negligible
probability that our selected set contains an error. Further-
more, even if all the chosen traces are correct, the algorithm
may fail to ﬁnd the target solution due to the heuristic na-
ture of lattice techniques. In case of failure, we repeat the
process with a new random selection from the same set. We
need to execute a median value of 13 iterations for SSH and
22 for TLS until we ﬁnd the target solution.
As seen from Table 2, repeating our experiment over a
thousand trials on a cluster with hundreds of nodes, mixed
between Intel X5660 and AMD Opteron 2435 cores, we ﬁnd
the private key in all cases requiring a median 5.9 CPU min-
utes for the SSH key and 38.8 CPU minutes for the TLS key.
Although we executed each trial on a single core, in reality
the iterations are independent of each other—the lattice at-
tack is embarrassingly parallel.
7. CONCLUSION
In this work we disclose a programming error in Open-
SSL that results in a security weakness. We show that as
a result of the defect, the DSA implementation in Open-
SSL is vulnerable to cache-timing attacks, and exploit the
vulnerability to mount end-to-end attacks against SSH (via
OpenSSH) and TLS (via stunnel).
It is all too easy to dismiss the bug as an innocent pro-
gramming error. However, we believe that the core issue is
a design problem. When designing the “constant-time” ﬁx,
the developers elected to use an insecure default behavior.
From an engineering perspective the decision is justiﬁed—
it is much easier to identify the handful of locations where
we know that the exponent should be kept secret than to
analyze the entire library identifying exponents that can be
leaked. However, from a security perspective, this design
decision breaches the principle of fail-safe defaults, which
Saltzer and Schroeder [33] justify by saying: a design or
implementation mistake in a mechanism that explicitly ex-
cludes access tends to fail by allowing access, a failure which
may go unnoticed in normal use.
It is hard not to appreciate the extraordinary prescience of
Saltzer and Schroeder’s justiﬁcation. Had OpenSSL elected
to use a better design, that defaults to the constant-time be-
havior, a similar bug could have resulted in a small perfor-
mance loss for non-sensitive exponentiations, but the omis-
sion to preserve the ﬂag in question would have been unlikely
to jeopardize the security of the system. A more secure de-
sign would also improve the security of third-party products
in the case that developers may not be aware of the intrica-
cies of the constant-time ﬂags.
The simplest software-based solution to mitigate our at-
tack is to ﬁx the software defect. During responsible disclo-
sure, OpenSSL, LibreSSL, and BoringSSL merged patches
for CVE-2016-217813, assigned as a result of this work.
Broader, the clflush instruction does not require elevated
privileges to execute, hence we suggest access control mech-
anisms. We recommend that cache ﬂush instructions be
privileged-only execution, or at least restricted to memory
pages to which the process has write access and to memory
pages explicitly allowed by the kernel. Partially or fully dis-
abling caching during sensitive code execution can prevent
cache-timing attacks at the cost of performance [3]. Pre-
venting page sharing between processes is a partial solution
at the cost of increased memory requirements and avoiding
sharing of sensitive code is possible by changing the program
loader.
We close with some practical advice regarding this vul-
nerability. OpenSSH supports building without OpenSSL
as a dependency. We recommend that OpenSSH package
maintainers switch to this option. For OpenSSH adminis-
trators and users, we recommend migrating to ssh-ed25519
key types, the implementation of which has many desirable
side-channel properties. Furthermore, ensure that ssh-dss
is absent from the HostKeyAlgorithms conﬁguration ﬁeld,
and any such HostKey entries removed. On the TLS side,
we recommend disabling cipher suites that have DSA func-
tionality as a pre-requisite.
Acknowledgments
The ﬁrst author is supported by the Erasmus Mundus Nord-
SecMob Master’s Programme and the European Commis-
sion.
The ﬁrst and second authors are supported in part by
TEKES grant 3772/31/2014 Cyber Trust.
This article is based in part upon work from COST Ac-
tion IC1403 CRYPTACUS, supported by COST (European
Cooperation in Science and Technology).
13https://web.nvd.nist.gov/view/vuln/detail?vulnId=
CVE-2016-2178
We thank Tampere Center for Scientiﬁc Computing (TCSC)
for generously granting us access to computing cluster re-
sources.
References
[1] Onur Acıi¸cmez, ¸Cetin Kaya Ko¸c, and Jean-Pierre
Seifert. Predicting secret keys via branch prediction.
In 2007 CT-RSA, pages 225–242, 2007.
[2] Onur Acıi¸cmez, ¸Cetin Kaya Ko¸c, and Jean-Pierre
Seifert. On the power of simple branch prediction
analysis. In 2nd AsiaCCS, Singapore, 2007.
[3] Onur Acıi¸cmez, Billy Bob Brumley, and Philipp
Grabher. New results on instruction cache attacks. In
CHES, Santa Barbara, CA, US, 2010.
[4] Thomas Allan, Billy Bob Brumley, Katrina Falkner,
Joop van de Pol, and Yuval Yarom. Amplifying side
channels through performance degradation. IACR
Cryptology ePrint Archive, Report 2015/1141, Nov
2015.
[5] Diego F. Aranha, Pierre-Alain Fouque, Benoˆıt G´erard,
Jean-Gabriel Kammerer, Mehdi Tibouchi, and
Jean-Christophe Zapalowicz. GLV/GLS
decomposition, power analysis, and attacks on ECDSA
signatures with single-bit nonce bias. In ASIACRYPT,
pages 262–281, Kaohsiung, TW, Dec 2014.
[6] Andrea Arcangeli, Izik Eidus, and Chris Wright.
Increasing memory density by using KSM. In Linux
symposium, pages 19–28, 2009.
[7] L´aszl´o Babai. On Lov´asz’ lattice reduction and the
nearest lattice point problem. Combinatorica, 6(1):
1–13, March 1986.
[8] Elaine Barker and Allen Roginsky. Transitions:
Recommendation for transitioning the use of
cryptographic algorithms and key lengths. NIST
Special Publication 800-131A Revision 1, Nov 2015.
URL http://dx.doi.org/10.6028/NIST.SP.800-131Ar1.
[9] Naomi Benger, Joop van de Pol, Nigel P. Smart, and
Yuval Yarom. “Ooh aah. . . , just a little bit”: A small
amount of side channel can go a long way. In CHES,
pages 75–92, Busan, KR, Sep 2014.
[10] Daniel J Bernstein. Cache-timing attacks on AES,
2005. Preprint available at
http://cr.yp.to/papers.html#cachetiming.
[11] Daniel Bleichenbacher. On the generation of one-time
keys in DL signature schemes. Presentation at IEEE
P1363 Working Group meeting, Nov 2000.
[12] Dan Boneh and Ramarathnam Venkatesan. Hardness
of computing the most signiﬁcant bits of secret keys in
Diﬃe-Hellman and related schemes. In CRYPTO’96,
pages 129–142, Santa Barbara, CA, US, Aug 1996.
[13] Ernie Brickell, Gary Graunke, and Jean-Pierre Seifert.
Mitigating cache/timing based side-channels in AES
and RSA software implementations. RSA Conference
2006 session DEV-203, Feb 2006.
[14] Billy Bob Brumley and Risto M. Hakala.
Cache-timing template attacks. In 15th ASIACRYPT,
pages 667–684, Tokyo, JP, Dec 2009.
[15] Billy Bob Brumley and Nicola Tuveri. Remote timing
attacks are still practical. In 16th ESORICS, Leuven,
BE, 2011.
[16] Teodoro Cipresso and Mark Stamp. Software reverse
engineering. In Handbook of Information and
Communication Security, pages 659–696. 2010.
[17] Intel Corporation. Intel 64 and ia-32 architectures
optimization reference manual, Jan 2016.
[18] Elke De Mulder, Michael Hutter, Mark E. Marson,
and Peter Pearson. Using Bleichenbacher’s solution to
the hidden number problem to attack nonce leaks in
384-bit ECDSA. In CHES, pages 435–452, Santa
Barabara, CA, US, Aug 2013.
[19] Daniel Genkin, Lev Pachmanov, Itamar Pipman, Eran
Tromer, and Yuval Yarom. ECDSA key extraction
from mobile devices via nonintrusive physical side
channels. IACR Cryptology ePrint Archive, Report
2016/230, Mar 2016.
[20] D. Gullasch, E. Bangerter, and S. Krenn. Cache
games – bringing access-based cache attacks on AES
to practice. In S&P, pages 490–505, May 2011.
[21] Nick Howgrave-Graham and Nigel P. Smart. Lattice
attacks on digital signature schemes. DCC, 23(3):
283–290, Aug 2001.
[22] Gorka Irazoqui, Thomas Eisenbarth, and Berk Sunar.
S$A: A shared cache attack that works across cores
and deﬁes VM sandboxing – and its application to
AES. In S&P, San Jose, CA, US, May 2015.
[23] Richard Lindner and Chris Peikert. Better key sizes
(and attacks) for LWE-based encryption. In 2011
CT-RSA, pages 319–339, 2011.
[24] Moritz Lipp, Daniel Gruss, Raphael Spreitzer, and
Stefan Mangard. ARMageddon: Last-level cache
attacks on mobile devices. arXiv preprint
arXiv:1511.04897, 2015.
[25] Fangfei Liu, Yuval Yarom, Qian Ge, Gernot Heiser,
and Ruby B Lee. Last-level cache side-channel attacks
are practical. In S&P, pages 605–622, May 2015.
[26] Mingjie Liu and Phong Q Nguyen. Solving BDD by
enumeration: An update. In Topics in
Cryptology–CT-RSA 2013, pages 293–309. 2013.
[27] Phong Q. Nguyen and Igor E. Shparlinski. The
insecurity of the digital signature algorithm with
partially known nonces. J. Cryptology, 15(2):151–176,
Jun 2002.
[28] Phong Q. Nguyen and Igor E. Shparlinski. The
insecurity of the elliptic curve digital signature
algorithm with partially known nonces. DCC, 30(2):
201–217, Sep 2003.
[29] Dag Arne Osvik, Adi Shamir, and Eran Tromer.
Cache attacks and countermeasures: The case of AES.
In 2006 CT-RSA, 2006.
[30] Dan Page. Theoretical use of cache memory as a
cryptanalytic side-channel. IACR Cryptology ePrint
Archive, 2002:169, 2002.
[31] Colin Percival. Cache missing for fun and proﬁt. In
BSDCan 2005, Ottawa, CA, 2005.
[32] Joop van de Pol, Nigel P. Smart, and Yuval Yarom.
Just a little bit more. In 2015 CT-RSA, pages 3–21,
San Francisco, CA, USA, Apr 2015.
[33] Jerome H. Saltzer and Michael D. Schroeder. The
protection of information in computer systems. Proc.
IEEE, 63(9):1278–1308, Sep 1975.
[34] C. P. Schnorr and M. Euchner. Lattic basis reduction:
Improved practical algorithms and solving subset sum
problems. Math. Prog., 66(1–3):181–199, Aug 1994.
[35] Augustus K. Uht, Vijay Sindagi, and Kelley Hall.
Disjoint eager execution: An optimal form of
speculative execution. MICRO 28, pages 313–325,
1995.
[36] Carl A. Waldspurger. Memory resource management
in VMware ESX server. SIGOPS Oper. Syst. Rev.,
pages 181–194, Dec 2002.
[37] Colin D. Walter. Longer keys may facilitate side
channel attacks. In SAC, pages 42–57, Waterloo, ON,
Canda, Aug 2004.
[38] Pieter Wuille. Dealling with malleability.
https://github.com/bitcoin/bips/blob/master/
bip-0062.mediawiki, March 2014.
[39] Yuval Yarom and Naomi Benger. Recovering
OpenSSL ECDSA nonces using the Flush+Reload
cache side-channel attack. IACR Cryptology ePrint
Archive, Report 2014/140, Feb 2014.
[40] Yuval Yarom and Katrina Falkner. Flush+Reload:
a high resolution, low noise, L3 cache side-channel
attack. In 23rd USENIX Security, pages 719–732, San
Diego, CA, US, 2014.
[41] Yuval Yarom, Daniel Genkin, and Nadia Heninger.
CacheBleed: A timing attack on OpenSSL constant
time RSA. In CHES, 2016.