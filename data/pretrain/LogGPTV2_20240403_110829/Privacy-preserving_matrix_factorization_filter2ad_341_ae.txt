### Execution Time and Parallelization

Approximately two-thirds of the execution time is attributed to gradient computation operations, while the remaining one-third is due to sorting operations. Given that both types of operations are highly parallelizable, this suggests that the overall execution time can be significantly reduced through parallel processing.

### Communication Overhead

Figure 6 illustrates the amount of data (in bytes) communicated between the Content Service Provider (CSP) and the Recommender System (RecSys) for a single iteration of garbling and evaluation. The plot demonstrates similar properties to the execution time, indicating that the communication size scales almost linearly with the number of ratings. Additionally, the majority of the circuit is dedicated to gradient computations. In all implementations, copy and update operations contribute less than 0.4% of the gates in the circuit.

### Performance on Real Datasets

To evaluate the time and communication performance on a real dataset, we limited our MovieLens dataset to the 40 most popular movies, resulting in 14,683 ratings generated by 940 users. One iteration of gradient descent, with parameters set to achieve an error of \(10^{-4}\), took 2.9 hours. These experiments were conducted on a machine with 16 cores; however, real-world systems often use much more powerful hardware, such as hundreds of Amazon EC2 servers. Since the operations are highly parallelizable, access to industry-level equipment can bring this timing into the realm of practicality, especially considering that recommender systems typically run matrix factorization on a weekly basis.

### Related Work

#### Secure Multiparty Computation (MPC)
Secure multiparty computation (MPC) was initially proposed by Yao [62, 63]. There are numerous frameworks that implement Yao's garbled circuits [45, 23, 24, 44, 53, 25, 36]. Alternative approaches to general-purpose MPC include secret-sharing schemes and fully homomorphic encryption (FHE). Secret-sharing schemes have been proposed for various linear algebra operations, such as solving linear systems [51], linear regression [29, 30, 21], and auctions [10]. Secret-sharing requires at least three non-colluding online authorities to share the workload and communicate over multiple rounds, ensuring security as long as no two authorities collude. Garbled circuits, on the other hand, assume only two non-colluding authorities and require far less communication, making them better suited for scenarios where the RecSys is a cloud service and the CSP is implemented in a trusted hardware component. Non-linear computation through FHE [16] can reduce the workload on the CSP compared to garbled circuits, but current FHE schemes [39, 20] for simpler algebraic computations are not as efficient as garbled circuit approaches [50].

#### Centralized Garbled-Circuit Computation
Centralized garbled-circuit computation of a function over a large number of individual inputs was introduced by Naor et al. in the context of auctions [48]. Our approach is closest to the privacy-preserving regression computation in [50], though implementing matrix factorization efficiently as a circuit introduces unique challenges not present in regression. Beyond [50], hybrid approaches combining garbled circuits with other methods (such as HE or secret-sharing) have been used for tasks like face and fingerprint recognition [57, 26], and learning decision trees [41]. These discrete function evaluations differ considerably from matrix factorization.

#### Data-Oblivious Algorithms
Regardless of the cryptographic primitive used, the main challenge in building an efficient algorithm for secure multiparty computation is to implement it in a data-oblivious fashion, i.e., so that the execution path does not depend on the input. Generally, any RAM program executable in bounded time \(T\) can be converted to a \(O(T^3)\) Turing machine [8], and any bounded \(T\)-time TM can be converted to a circuit of size \(O(T \log T)\) [54], which is data-oblivious. This results in a \(O(T^3 \log T)\) complexity, which is prohibitive in most applications. A survey of algorithms for which efficient data-oblivious implementations are unknown can be found in [11]; matrix factorization broadly falls into the category of Data Mining summarization problems.

#### Sorting Networks
Sorting networks were originally developed to enable sorting parallelization and efficient hardware implementation. Recent works exploit the data-obliviousness of sorting networks for cryptographic purposes, leading to renewed interest in oblivious sorting protocols beyond sorting networks (e.g., [18, 22]). Many recent data-oblivious algorithms use sorting as a building block, including compaction and selection [60, 19], convex hull and all-nearest neighbors computation [13], and weighted set intersection [28]. The simple counting protocol in Section 3.3 is a variation of these schemes. However, these operations are much simpler than matrix factorization; to the best of our knowledge, we are the first to apply oblivious sorting to such a numerical task.

#### Privacy in Recommender Systems
Privacy in recommender systems has been studied under various contexts, including the use of trusted hardware [1] and the susceptibility of systems to shilling attacks (i.e., the injection of false ratings to manipulate recommendation outcomes) [38, 47]. An orthogonal approach to introducing privacy in recommender systems is differential privacy [12, 46]. By adding noise, differential privacy ensures that the distribution of the system’s output is insensitive to any individual’s record, preventing the inference of any single user’s data from the output. However, differential privacy does not protect data from the recommender system itself. Crucially, differential privacy can be combined with secure computation [58], in our case by incorporating noise addition within the garbled circuit factorizing the input matrix. Differential privacy can thus enhance the privacy properties of our protocol, ensuring that the data remains private during computation and that the final result does not expose individual user data.

### Conclusions and Future Work

We presented a protocol for matrix factorization on user ratings that remain encrypted at all times. This critical building block allows a recommender to learn item profiles without learning anything about users’ ratings, providing users with protection from inference threats and accidental information leakage. Our hybrid approach combines partially homomorphic encryption and Yao’s garbled circuits. To the best of our knowledge, we are the first to apply oblivious sorting to a numerical task as complex as matrix factorization. Through this key idea, we also enable high parallelization, overcoming scalability and performance needs, and bringing matrix factorization on encrypted data into the realm of practicality.

There are several future directions for this work:
1. **Deployment on Cloud Compute Services:** We plan to deploy our system over a cloud compute service (e.g., using Hadoop on Amazon EC2), which will enable us to process a wider range of datasets.
2. **Application to Other Machine Learning Tasks:** We aim to investigate the application of our approach to other intensive machine learning tasks, especially those with an underlying bipartite structure in computations. We could leverage sorting networks again to achieve performance scalability.
3. **Extension to Different Security Models:** We intend to extend our protocol to work under different security models, such as a malicious CSP. A malicious CSP can create an incorrect circuit, which can be handled with standard techniques for verifying garbled circuits [43, 40]. Additionally, it can feed the wrong inputs to the circuit, potentially corrupting the result of the computation. Therefore, additional techniques should be designed to ensure that the CSP provides the correct inputs to the circuit or that the output of the recommendation circuit closely approximates the ratings provided by users.

### Acknowledgments
The last author is supported by NSF.

### References
[References listed here as per the original text]

This optimized version maintains the clarity, coherence, and professional tone of the original text while improving readability and structure.