by the policies deﬁned in the doctrine. When a service
provider receives a request, it ﬁrst checks the membership
list in order to determine the validity of the requestor’s role
assignment. Then, it grants the requestor the permissions to
use the service if the authorisation policies allow it.
If the provider has sufﬁcient device capability it may de-
cide to re-verify the user-role assignment. This helps to
guard against a malicious or compromised coordinator hav-
ing admitted a rogue user in the community. If a violation
is detected, other participants can be notiﬁed and if needed
the community can be reconstructed (see section 4.6).
4.5. Leaving the Community
Two scenarios can occur: either the user notiﬁes the co-
ordinator that it is going to leave the community or its un-
expected absence is detected by others. If it is temporarily
absent (e.g., user moves out of range) but its absence is not
detected by other participants, no changes are necessary.
The ﬁrst scenario is straightforward as the coordinator
can remove the user from the membership list, which can
then be re-sent to all participants. In the second scenario,
we rely on the other participants detecting its absence, typ-
ically through a communication failure. When a communi-
cation failure occurs, a user will retry for up to τ times. If
the failure is conﬁrmed, the user notiﬁes the coordinator by
sending a signed (cid:1)FAILURE NOTIFICATION(cid:2).
Upon receipt of such a notiﬁcation of failure to reach a
user, uleave, the coordinator will checks that uleave is in-
deed a member of the community and attempt to reach that
user for τ times. If uleave is still unreachable, the coordi-
nator removes it from the membership list, checks that the
community establishment constraints are still satisﬁed and
broadcasts the revised membership list. If the constraints
are not satisﬁed the community can be dissolved.
4.6. The Coordinator is Unavailable
The coordinator can also become disconnected in an un-
expected manner. When the disconnection has been con-
ﬁrmed, an (cid:1)UNAVAILABILITY(cid:2) message is broadcast to
all participants. The community is considered by all par-
ticipants to be in a static state until a new coordinator is
elected. Static state (i.e., coordinator absent) implies that
no new users can be admitted to the community and all par-
ticipants disregard membership updates until a new coordi-
nator is elected. The community continues to operate based
on the last authenticated membership list.
Upon receipt of the (cid:1)UNAVAILABILITY(cid:2) message,
each participant checks whether or not it has the resources
and capability to serve as coordinator. Among all the eli-
gible participants, only one participant is selected and the
choice is arbitrary. For example, the participant with the
lowest node id can be selected as it is the oldest participant
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
in the community amongst the eligible ones. The selected
user, ulowid then broadcasts a (cid:1)RECONSTRUCTION(cid:2) mes-
sage and the other participants re-join the community by
sending (cid:1)REJOIN(cid:2) to ulowid. Subsequently, ulowid checks
all the URA policies and community constraints, and if they
are fulﬁlled, ulowid re-established the community. How-
ever, if no participant can take over the role of coordinator,
the community remains in static state until it is dissolved.
5. Architecture
Figure 1 shows the overall architecture of the proposed
It is composed of ﬁve components: proﬁle
framework.
management, membership management, protocol manage-
ment, policy enforcement and an event service. The frame-
work runs on every user’s device.
Applications
Application
Requests
Community
Community
Management
Management
Interfaces
Interfaces
Credentials,
doctrines,
Preferences
Policy
Enforcement
Authorisation
& Obligation
Policies
Membership
Info
Membership
Management
Credentials,
doctrines,
Preferences
Profile
Management
Protocol
Requests
Membership Info
Events
Events
Protocol
Management
Event
Service
Requests
Lower Layers
Messages
A Policy-based Security Framework
Figure 1. The architectural overview.
The proﬁle management component maintains the user’s
credentials, such as public-key certiﬁcates, private-key
stores, and attribute certiﬁcates. Users can manage their
credentials and device settings through the community man-
agement interface. In addition, this component also main-
tains the user’s preferences on which communities the de-
vice should automatically join.
The membership management component exposes the
community management interface to the application level,
so that applications can initiate the establishment of a new
community, search for communities, as well as joining par-
ticular communities. Through this interface, the user can
register the services that it is providing to other participants.
The membership management component is also responsi-
ble for checking the authenticity of the doctrines and enforc-
ing them by extracting and distributing the policy instances
to various enforcement components. An optional module,
known as coordination service can be dynamically loaded
according to the user’s device capability in order to enable
the device to act as the coordinator. In this case, the mem-
bership management will also manage the membership of
the community including the enforcement of URA policies
and the community constraints.
The protocol management component executes various
security protocols for the establishment, evolution and man-
agement of communities as discussed in section 4. The pol-
icy enforcement component enforces both the authorisation
and obligation policies. Access requests are intercepted and
then checked against the policies to determine if they are
permitted. Obligation policies are enforced by subscribing
to the speciﬁed event and executing the actions speciﬁed in
the policies when the events occur.
Lastly, the event service collects and aggregates events
and subsequently forwards them to the policy enforcement,
e.g.
the triggering of the execution of obligation policies.
System events are forwarded to the protocol management,
so that appropriate protocols can be performed. Events re-
garding the discovery of new communities are forwarded to
the membership management component.
5.1. Emulations and Preliminary Results
We have designed and implemented an emulation of a
mobile environment in order to investigate, the robustness
of the protocols against node mobility and to determine the
impact of various pause times on the proposed protocol.
The architecture was implemented as a Java prototype
and was tested using the MobiEmu [34] emulation tool.
MobiEmu was chosen because it can emulate the mobility
encountered in wireless networks and provides support for
ad-hoc routing. Essentially, MobiEmu provides a software
platform for testing and analysing ad-hoc network proto-
cols and applications in a LAN setting. The emulation is
scenario-driven and simulates the movement of nodes given
a history of locations. In terms of routing, it enforces a par-
tially connected topology at the data link layer and uses the
best-case ad-hoc routing algorithm.
A testbed was set-up to emulate the establishment and
evolution of an ad-hoc community. For simplicity, all ma-
chines were conﬁgured as capable to act as coordinator and
each of them was loaded with attribute certiﬁcates. A doc-
trine corresponding to the scenario described in section 3
was also created. Mobility scenarios were generated using
setdest version two, which can be found in ns-2 [7]. Table
1 summarises the parameters used in our emulations.
When running the emulation over a period of time, the
community could end up in the static or established state.
We are interested to ﬁnd out the probability that a com-
munity will end-up in the static state at the end of the
emulation, i.e., that the community can no longer be re-
constructed. This occurs when the participants are out of
range and are no longer able to receive reconstruction mes-
sages even if a coordinator has been identiﬁed. Conversely,
a community remains in established state with the possi-
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Table 1. Overall emulation parameters
Transmission Range
Emulation Time
Number of Nodes
Pause Time
Max. Node Speed
Min. Node Speed
Topology Size
200 m
1000 s
5
30, 60, 300, 600 s
3.0 m/s
0.1 m/s
500 x 500 m
bility that it has been reconstructed or it has never been
reconstructed. From Figure 2, we observe that the proba-
bility for a community to end up in static state is of 0.1 to
0.2. This probability is low and thus the protocol proposed
is relatively robust to the mobility of devices. Most of the
time, the community remains in the established state. More
speciﬁcally the probability that a community remains estab-
lished without being reconstructed for various pause times
ranges from 0.3 - 0.7.
The Probability that a community changes to static state vs
remains as established state
y
t
i
l
i
b
a
b
o
r
P
1
0.8
0.6
0.4
0.2
0
Static state (community could not
be reconstructed)
Established state (community was
reconstructed)
Established state (community was
not reconstructed)
30
60
300
600
Pause Time (s)
Figure 2. This graph shows the stability of the
community against various pause times.
The second aspect is to investigate the probability of hav-
ing to reconstruct the community as a function of the pause
time of the nodes. As shown in Figure 2, we observed that
the probability that a community goes through the recon-
struction phase remains fairly high for pause times of 30,
60 and 300 s. For longer periods of time i.e., greater than
600s the coordinator remains within communication range
of the other devices for longer periods and the probability
of a reconstruction phase happening is relatively low i.e.,
0.2. This ﬁnding reveals that the proposed framework could
be efﬁcient for scenarios such as communities in trains, li-
braries, and ad-hoc business meetings because in these sce-
narios, the users tend to move and then pause for a long
period of time before they move again.
6. Related Work
Law Governed Interaction (LGI) [23] proposes a frame-
work where interactions between a group of distributed
agents can interact subject to communication rules (the law)
speciﬁed using a simple Prolog notation. The underlying as-
sumption is that all interactions must occur through trusted
agents present at each of the sites to enforce the law. Our
framework does not rely on trusted agents, but requires par-
ticipants to monitor each other’s behaviour.
Zhou and Haas [35] have proposed the use of thresh-
old cryptography to thwart the problem of a single point
of failure in ad-hoc networks. They proposed that multiple
nodes can be used to act as CAs in an ad-hoc network. Each
network has a certiﬁcate signing key that is divided into n
shares and distributed to all nodes acting as CA. In order