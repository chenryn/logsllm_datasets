as freshness, completeness or query computation correctness.
Mylar, also implemented on top of Meteor, is easy to integrate
with Verena.
XIII. CONCLUSION
Verena is the ﬁrst web application platform that provides
end-to-end integrity guarantees for data and query results in
a webpage against attackers that have compromised the web
server. In Verena, the user’s browser can verify the integrity
of a webpage, by verifying the results of the database queries
which are used to populate the page content. Our evaluation
results show that Verena can support real applications with
modest overhead. Verena attempts to close the gap between the
research efforts of protecting the integrity of database systems,
and the application of this research in one of the most popular
use cases of databases, web applications.
REFERENCES
[1] “Biotronik home monitoring,” https://www.biotronik.
com/wps/wcm/connect/en_us_web/biotronik/sub_top/
healthcareprofessionals/products/home_monitoring/.
[2] “Boston
remote
scientiﬁc
patient monitoring,”
http://www.bostonscientiﬁc.com/en-US/products/remote-
patient-monitoring.html.
[3] “Keybase,” https://keybase.io/.
[4] “Medtronic CareLink network for cardiac device
patients,”
http://www.medtronic.com/for-healthcare-
professionals/products-therapies/cardiac-rhythm/patient-
management-carelink/medtronic-carelink-network-for-
cardiac-device-patients/index.htm.
[5] “MongoDB,” https://www.mongodb.org/.
910910
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:13 UTC from IEEE Xplore.  Restrictions apply. 
[6] “Native
client.
client,” https://developer.chrome.com/native-
[7] “Node.js,” https://nodejs.org/.
[8] “OpenSSL,” https://www.openssl.org/.
[9] “PhantomJS,” http://phantomjs.org/.
[10] “RocksDB,” http://rocksdb.org/.
[11] “Stanford JavaScript crypto library (SJCL),” https://crypto.
stanford.edu/sjcl/.
[12] A. Baumann, M. Peinado, and G. Hunt, “Shielding
applications from an untrusted cloud with haven,” in
Proceedings of the 11th Symposium on Operating Systems
Design and Implementation (OSDI), 2014.
[13] G. Becker, “Merkle signature schemes, Merkle trees and
their cryptanalysis,” 2008.
[14] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and
M. Virza, “SNARKs for C: Verifying program executions
succinctly and in zero knowledge,” in Proceedings of
the 33rd International Cryptology Conference (CRYPTO),
2013.
[15] M. Bodnarchuk, “Why should you use client-side
MVC framework?” http://jster.net/blog/why-should-you-
use-client-side-mvc-framework, 2013.
[16] J. Bonneau, C. Herley, P. C. v. Oorschot, and F. Stajano,
“The quest to replace passwords: A framework for com-
parative evaluation of web authentication schemes,” in
Proceedings of the 33rd IEEE Symposium on Security
and Privacy (S&P), 2012.
[17] H. Burri and D. Senouf, “Remote monitoring and follow-
up of pacemakers and implantable cardioverter deﬁbrilla-
tors,” Europace, vol. 11, no. 6, 2009.
[18] A. Chlipala, “Static checking of dynamically-varying
security policies in database-backed applications,” in
Proceedings of the 9th Symposium on Operating Systems
Design and Implementation (OSDI), 2010.
[19] S. Chong, K. Vikram, and A. C. Myers, “SIF: Enforcing
conﬁdentiality and integrity in web applications,” in
Proceedings of the 16th USENIX Security Symposium,
2007.
[20] S. A. Crosby and D. S. Wallach, “Authenticated dictionar-
ies: Real-world costs and trade-offs,” ACM Transactions
on Information and System Security,, vol. 14, no. 2, 2011.
[21] E.-J. Goh, H. Shacham, N. Modadugu, and D. Boneh,
“SiRiUS: Securing remote untrusted storage,” in Proceed-
ings of the Tenth Network and Distributed System Security
(NDSS) Symposium, 2003.
[22] M. T. Goodrich, C. Papamanthou, R. Tamassia, and
N. Triandopoulos, “Athos: Efﬁcient authentication of
outsourced ﬁle systems,” in Proceedings of the 11th
International Conference on Information Security, 2008.
[23] M. T. Goodrich, R. Tamassia, and A. Schwerin, “Im-
plementation of an authenticated dictionary with skip
lists and commutative hashing,” in DARPA Information
Survivability Conference and Exposition II (DISCEX II),
2001.
[24] W. He, D. Akhawe, S. Jain, E. Shi, and D. Song,
“Shadowcrypt: Encrypted web applications for everyone,”
in Proceedings of the 21st ACM Conference on Computer
and Communications Security (CCS), 2014.
[25] M. Kallahalla, E. Riedel, R. Swaminathan, Q. Wang, and
K. Fu, “Plutus: Scalable secure ﬁle sharing on untrusted
storage,” in 2nd USENIX conference on File and Storage
Technologies (FAST), 2003.
[26] B. H. Kim and D. Lie, “Caelus: Verifying the consistency
of cloud services with battery-powered devices,” in
Proceedings of the 36th IEEE Symposium on Security
and Privacy (S&P), 2015.
[27] I. Lam, S. Szebeni, and L. Buttyan, “Tresorium: Cryp-
tographic ﬁle system for dynamic groups over untrusted
cloud storage,” in Proceedings of the 41st International
Conference on Parallel Processing Workshops, 2012.
and trends
in
2015,” 2015, http://www.contextis.com/resources/blog/
vulnerability-statistics-trends-2015/.
[28] S. Lamb,
“Vulnerability statistics
[29] D. Levin, J. R. Douceur, J. R. Lorch, and T. Moscibroda,
“Trinc: Small trusted hardware for large distributed sys-
tems,” in Proceedings of the 6th Symposium on Networked
Systems Design and Implementation (NSDI), 2009.
[30] F. Li, M. Hadjieleftheriou, G. Kollios, and L. Reyzin,
“Dynamic authenticated index structures for outsourced
databases,” in Proceedings of the 2006 ACM SIGMOD
International Conference on Management of Data (SIG-
MOD), 2006.
[31] F. Li, M. Hadjieleftheriou, G. Kollios, and L. Reyzin,
“Authenticated index structures for aggregation queries,”
ACM Transactions on Information and System Security,
vol. 13, no. 4, 2010.
[32] J. Li, M. Krohn, D. Mazières, and D. Shasha, “Secure
untrusted data repository (SUNDR),” in Proceedings of
the 6th Symposium on Operating Systems Design and
Implementation (OSDI), 2004.
[33] C. Martel, G. Nuckolls, P. Devanbu, M. Gertz, A. Kwong,
and S. G. Stubblebine, “A general model for authenticated
data structures,” Algorithmica, vol. 39, 2001.
[34] D. Mazières and D. Shasha, “Building secure ﬁle systems
out of Byzantine storage,” in Proceedings of the 21st
Annual Annual Symposium on Principles of Distributed
Computing (PODC), 2002.
911911
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:13 UTC from IEEE Xplore.  Restrictions apply. 
[35] R. Merkle, “Secrecy, authentication and public key
systems / A certiﬁed digital signature,” 1979.
[36] Meteor, Inc., “Meteor: A better way to build apps,” Sep.
2013, http://www.meteor.com.
[37] H. Pang and T. Kian-Lee, Query answer authentication.
Morgan and Claypool Publishers, 2012.
[38] B. Parno, J. Howell, C. Gentry, and M. Raykova,
“Pinocchio: Nearly practical veriﬁable computation,” in
Proceedings of the 34th IEEE Symposium on Security
and Privacy (S&P), May 2013.
[39] R. A. Popa, J. R. Lorch, D. Molnar, H. J. Wang, and
L. Zhuang, “Enabling security in cloud storage SLAs
with CloudProof,” in Proceedings of the 2011 USENIX
Annual Technical Conference, 2011.
[40] R. A. Popa, C. M. S. Redﬁeld, N. Zeldovich, and
H. Balakrishnan, “CryptDB: Protecting conﬁdentiality
with encrypted query processing,” in Proceedings of the
23rd ACM Symposium on Operating Systems Principles
(SOSP), 2011.
[41] R. A. Popa, E. Stark, S. Valdez, J. Helfer, N. Zeldovich,
M. F. Kaashoek, and H. Balakrishnan, “Building web
applications on top of encrypted data using Mylar,” in
Proceedings of the 11th Symposium on Networked Systems
Design and Implementation (NSDI), 2014.
[42] W. Robertson and G. Vigna, “Static enforcement of
web application integrity through strong typing,” in
Proceedings of the 18th USENIX Security Symposium,
2009.
[43] H. Singh, T. Giardina, A. Meyer, S. Forjuoh, M. Reis,
and E. Thomas, “Types and origins of diagnostic errors
in primary care settings,” JAMA Internal Medicine, vol.
173, no. 6, 2013.
[44] H. Singh, A. Meyer, and E. Thomas, “The frequency of
diagnostic errors in outpatient care: estimations from
three large observational studies involving US adult
populations,” BMJ Quality and Safety, 2014.
[45] V. Sriram, G. Narayan, and K. Gopinath, “SAFIUS - A
secure and accountable ﬁlesystem over untrusted storage,”
in Proceedings of the 4thInternational IEEE Security in
Storage Workshop, 2007.
[46] M. Walﬁsh and A. J. Blumberg, “Verifying computations
without reexecuting them: From theoretical possibility to
near-practicality,” in Communications of the ACM, 2015.
[47] B. Winters, J. Custer, S. M. Galvagno, E. Colantuoni,
S. G. Kapoor, H. Lee, V. Goode, K. Robinson, A. Nakhasi,
P. Pronovost, and D. Newman-Toker, “Diagnostic errors
in the intensive care unit: A systematic review of autopsy
studies,” BMJ Quality and Safety, 2012.
5
10
−∞
2
−∞
0
0
5
2
2
9
8
8
9
8
+∞
0
0
key (range_field)
aggregate
value (data_field)
Fig. 7: Example tree-based ADS, supporting aggregations. Node
hashes realizing the Merkle hash tree, as well as node color, realizing
the red-black tree balancing mechanism used in our implementation,
are not shown.
[48] A. Yip, X. Wang, N. Zeldovich, and M. F. Kaashoek,
“Improving application security with data ﬂow assertions,”
in Proceedings of the 22nd ACM Symposium on Operating
Systems Principles (SOSP), 2009.
[49] Y. Zhang, J. Katz, and C. Papamanthou, “IntegriDB: Veriﬁ-
able SQL for outsourced databases,” in Proceedings of the
22nd ACM Conference on Computer and Communications
Security (CCS), 2015.
A. Background on Authenticated Data Structures
APPENDIX
Verena leverages authenticated data structures (ADS) [20,
23, 30, 31, 33, 37, 49] as its underlying integrity protection
building block. In fact, Verena does not rely on a speciﬁc
ADS. In our implementation of Verena we make use of one-
dimension red-black binary Merkle hash trees with the ability
to support projection queries, as well as aggregation queries
based on the tree-based technique of [31].
Here we summarize how such trees work and refer the reader
to the literature for a detailed analysis. We assume that the
reader is familiar with Merkle hash trees [13, 35]. Consider a
database table consisting of two ﬁelds (i.e, columns); a range
ﬁeld and an aggregation ﬁeld, i.e, a ﬁeld in which stored data
is used in aggregation queries. In SQL notation, a user runs
queries of the form “SELECT sum(aggr. ﬁeld) FROM table
WHERE x ≤ range ﬁeld ≤ y”.
Fig. 7 shows an example of such a tree, sorted (i.e., keyed)
by the range ﬁeld. Note that the red-black property is only
used for keeping the tree balanced, and hence Fig. 7 omits the
color of the nodes. Also not shown in Fig. 7 are the hashes of
each node, which constitute the Merkle hash tree. The client,
who is the owner of the data stored in the tree, keeps the root
hash of the Merkle hash tree, and the untrusted server keeps
the entire tree.
Data is stored on leaf nodes. Each node stores a key and an
aggregate value; leaf nodes further store the data values. Given
our aforementioned example, the keys are the range ﬁeld values
and data stored on leaf nodes is the data of the aggregation
ﬁeld. For leaf nodes, the aggregate value is equal to the data
912912
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:13 UTC from IEEE Xplore.  Restrictions apply. 
value itself. For each internal node, the aggregate value is the
aggregation over the aggregate values of its children. The tree
in Fig. 7 features sum as the aggregation operation.
Assume that the client issues the query “SELECT sum(aggr.
ﬁeld) FROM table WHERE 2 ≤ range ﬁeld ≤ 5”. The server
responds with the sum of interest, 2 in this case, together with
a proof that the sum is correct. We explain brieﬂy what the
proof consists of and refer the reader to [31] for more details.
The proof consists of two parts. The ﬁrst part is, for each edge
of the interval, the server provides two nodes in the tree whose
range ﬁelds include the edge of the interval, together with their
Merkle hash paths to the root. The client checks these Merkle
paths against the Merkle hash root it stores and ensures that
the edge of the interval is inside this interval. Note that this
is always possible because the keys ±∞ (containing dummy
data values) are also in the tree. The second part of the proof
is a minimal covering set for the range [2,5] together with a
Merkle hash path up to the root. In our example, this minimal
covering set consists of the internal node with key −∞ and
aggregate value 2. In general, the covering set is a logarithmic
number of nodes.
The client then checks that these nodes cover the range of
interest entirely and veriﬁes their hashes and Markle hash
paths against the root hash that the client stores. By the
properties of Merkle hash trees, if the veriﬁcation is successful,
the server provided the correct aggregate value. Overall, the
client performs O(logn) work per value returned where n
is the number of nodes in the tree. A similar computation
happens when inserting, updating and deleting data, with some
additional details.
Note that the server does not have precomputed the aggregate
value for each range. The ADS tree has one data entry (leaf
node) per range ﬁeld value and there is a quadratic number
of possible ranges. Clients can query arbitrary ranges, and
these ranges could contain a large number of nodes. The
server transforms these ranges into a set of subranges, and the
client then aggregates the aggregate values for each range. The
maximum number of subranges is logarithmic in the number of
nodes in the tree. Hence, the client does little aggregation work
because it aggregates only a logarithmic number of values.
913913
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:13 UTC from IEEE Xplore.  Restrictions apply.