ğ›¼â€² â† Zğ¾
ğ‘ğ´ = ğ‘ âŠ™ ğ‘ğµ âŠ• Enc(ğ‘ğ‘˜, ğ›¼â€²)
ğ›¼ = âˆ’ğ›¼â€² mod ğ‘
ğ‘ƒ2
ğ‘ ,ğœ‹ğ‘ƒ
â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’ ğ‘ğ‘˜ = ğ‘ , ğ‘ ğ‘˜ = ğœ™(ğ‘)
ğ‘ğµ,ğœ‹ğµ
â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’ ğ‘ğµ = Enc(ğ‘ğ‘˜, ğ‘)
ğ‘ğ´,ğœ‹ğ´
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ ğ›½â€² = Dec(ğ‘ ğ‘˜, ğ‘ğ´)
ğ›½ = ğ›½â€² mod ğ‘
ğ‘ 2(ğ‘Ÿ1 + ğ‘˜2)
Since
?
= â„ + ğ‘Ÿ(ğ‘¥2 âˆ’ ğ‘¡ğµ âˆ’ ğ‘ğ‘) mod ğ‘.
(2)
Figure 4: The Paillier-based MtA from [19]. ğ¾ is the parameter
to be determined.
(3)
ğ‘ 2 Â· (ğ‘Ÿ1 Â· ğ‘ƒ + ğ‘…2) = â„ Â· ğ‘ƒ + ğ‘Ÿ(ğ‘¥2 âˆ’ ğ‘¡ğµ âˆ’ ğ‘ğ‘) Â· ğ‘ƒ
holds if and only if Equation 2 is correct, the condition to output
(ğ‘Ÿ, ğ‘ ) in both the real and simulated case is identical.
This implies that the advantage of any PPT adversary who cor-
rupts ğ‘ƒ2 to distinguish the real execution and simulated execution
given by S is negligible.
4 INSTANTIATIONS OF MTA AND THEIR
APPLICATIONS TO 2ECDSA
There are several constructions of MtA which could be directly
applied to our 2ECDSA.
4.1 MtA from Oblivious Transfer
Following Gilboaâ€™s semi-honest oblivious transfer [21], and moti-
vated by two-party ECDSA, Doerner et al. [15] proposed a MtA
against malicious adversary. Their construction is based upon Sim-
plest OT [10] and KOS [23] OT-extension protocols. Please refer
to Appendix C for a detailed description. Their MtA is computa-
tionally very efficient, while the communication is rather large. To
compute a MtA, at least 8ğœ…2 bits must be transferred. Concretely,
when ğœ… = 256, the communication of a single execution of MtA is
â‰ˆ 90 KB.
Their OT-based MtA could be applied to 2ECDSA. The online
phase of both [15] and our protocols are extremely lightweight:
sending a single field element and computing two elliptic curve
point multiplications. In our protocol, a single MtA is required
while the two-party ECDSA of [15] needs two. Thus, our solution
requires roughly half of the communication and computation of
[15]. A concrete comparison is given in Sec. 5.
4.2 MtA from Paillier
Gennaro and Goldfeder [19] presented a Multiplicative-to-Additive
conversion protocol from Paillier encryption, which has appeared
many times before [12, 25, 27]. Lindell et al. [26] also proposed a
similar protocol and call it private multiplication. We recall it and
explain its application to our 2ECDSA.
Let ğ‘ğ‘˜ = ğ‘ and ğ‘ ğ‘˜ = ğœ™(ğ‘) be the public and secret keys of Pail-
lier encryption. Denote the encryption of message ğ‘š by Enc(ğ‘ğ‘˜, ğ‘š),
the decryption of ciphertext ğ‘ by Dec(ğ‘ ğ‘˜, ğ‘). Denote by ğ‘1âŠ•ğ‘2 = ğ‘1ğ‘2
mod ğ‘ 2 the addition of the plaintext in ciphertexts ğ‘1 and ğ‘2, and
by ğ‘ âŠ™ ğ‘ = ğ‘ğ‘ mod ğ‘ 2 the multiplication of the plaintext in ğ‘ by a
scalar ğ‘.
The Paillier-based MtA between ğ‘ƒ1 with input ğ‘ and ğ‘ƒ2 with
input ğ‘ works in Figure 4 where
â€¢ ğœ‹ğ‘ƒ is a ZKPoK for {(ğ‘ ; ğœ™(ğ‘))| gcd(ğ‘ , ğœ™(ğ‘)) = 1};
â€¢ ğœ‹ğµ is a ZKPoK for {(ğ‘ğµ; ğ‘)|ğ‘ğµ = Enc(ğ‘ğ‘˜, ğ‘) âˆ§ ğ‘ âˆˆ Zğ‘};
â€¢ ğœ‹ğ´ is a ZKPoK for {(ğ‘ğ´, ğ‘ğµ; ğ‘, ğ›¼â€²)|ğ‘ğ´ = ğ‘âŠ™ğ‘ğµ âŠ•Enc(ğ‘ğ‘˜, ğ›¼â€²)âˆ§
ğ‘ âˆˆ Zğ‘ âˆ§ ğ›¼â€² âˆˆ Zğ¾}.
Please refer to Appendix D for the full description of Paillier-based
MtA and these ZKPoK protocols (w/o slack regarding soundness).
As noted by previous works [6, 19, 25, 26], ğœ‹ğ´ and ğœ‹ğµ are very
expensive. Several works have been done to reduce or even remove
these proofs. Lindell [25], Gennaro and Goldfeder [19] suggested to
eliminate ğœ‹ğ´ by relying on a non-standard Paillier-EC assumption
(Appendix D.3). Lindell et al. [26], Gennaro and Goldfeder [19], and
Canetti et al. [6] found that it is enough to use proofs with a lot of
slack regarding soundness. The slack version of ğœ‹ğ´ and ğœ‹ğµ roughly
cost computing 6 Paillier exponentiations and sending 6 log ğ‘ bits.
Thus, the overall cost of Paillier-based MtA is computing approxi-
mately 14 Paillier exponentiations and sending 16 log ğ‘ bits. Under
the Paillier-EC assumption, it could be further reduced to 8 Paillier
exponentiations and 10 log ğ‘ bits respectively.
4.2.1 Applying Paillier-based MtA to 2ECDSA. We propose two
versions of Paillier-based 2ECDSA depending on whether or not
MtA relies on Paillier-EC assumption. When applying Paillier-EC
assumption, a proof-of-knowledge for the discrete logarithm of ğ‘„â€²1
should be added against corrupted ğ‘ƒ1. (In order to extract ğ‘¥â€²1 to
querying the oracle in Paillier-EC assumption.) Actually, Gennaro
and Goldfeder [19] also proposed another non-standard assumption
to further eliminate ğœ‹ğµ, and their technique could also be applied
to our protocol. Nevertheless, to simplify the analysis, we do not
include it in this paper and just analyze Gennaro and Goldfederâ€™s
scheme based on Paillier-EC.
Lindellâ€™s two-party protocol [25] has the best overall perfor-
mance. Nevertheless, their online phase is comparatively expensive,
i.e., sending a Paillier ciphertext and computing Paillier decryp-
tion. The online phase of the two-party case of Lindellâ€™s threshold
scheme [26] is worst, since 14 Paillier exponentiations are required.
The online phase of [19] is fast, while their offline phase requires at
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea566ğ‘ƒ1(pk, ğ‘)
ğ‘ƒ2(pk, sk; ğ‘)
ğ‘ğµ,ğœ‹ğ¶ğ¿
â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’ ğ‘ğµ = Encğ‘ğ‘™ (pk, ğ‘)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ ğ›½â€² = Decğ‘ğ‘™ (ğ‘ ğ‘˜, ğ‘ğ´)
ğ›¼â€² â† Zğ‘
ğ‘ğ´ = ğ‘ âŠ™ ğ‘ğµ âŠ• Encğ‘ğ‘™ (ğ‘ğ‘˜, ğ›¼â€²)
ğ›¼ = âˆ’ğ›¼â€² mod ğ‘
Figure 5: The CL-based MtA extracted from [7, 8].
ğ›½ = ğ›½â€² mod ğ‘
ğ‘ğ´
least computing 18 Paillier exponentiations and sending 16 â„“ğ‘ bits
depending on Paillier-EC is required or not. The online phase of the
two-party case of Canetti et al. [6] and our scheme are extremely
lightweight. However, the offline phase of [6] needs 204 Paillier ex-
ponentiations. Our scheme relies on 8 or 14 Paillier exponentiations
and sending 10 â„“ğ‘ or 16 â„“ğ‘ bits depending on whether Paillier-EC
is required. A concrete comparison is given in Sec. 5.
4.3 MtA with CL-encryption Achieving
Game-based Security
To address the problem of non-standard assumption in Paillier-
based MtA, Castagnos et al. [7, 8] replaces Paillier with CL encryp-
tion [9] which allows instantiations where the message space is
exactly Zğ‘.
Let (Ëœğ‘ , ğ‘“ , Ë†ğ‘”ğ‘, ğ‘”ğ‘, Ë†ğº, ğ¹, ğ‘) be public parameters of CL encryption
(as defined in [8]), where ğ¹ = âŸ¨ğ‘“ âŸ© is the subgroup of Ë†ğº with order
ğ‘, ğ‘”ğ‘ is a random element in âŸ¨ Ë†ğ‘”ğ‘âŸ©. Denote by sk, pk = ğ‘”skğ‘ secret-
public key pair. CL encryption Encğ‘ğ‘™ (pk, ğ‘š, ğ‘Ÿ) computes (ğ‘1, ğ‘2) =
ğ‘, pkğ‘Ÿ ğ‘“ ğ‘š) as the encryption of ğ‘š âˆˆ Zğ‘ with randomness ğ‘Ÿ â†
(ğ‘”ğ‘Ÿ
[0, ğ‘†] (for some ğ‘†), and Decğ‘ğ‘™ (sk, ğ‘1, ğ‘2) computes logğ‘“ (ğ‘2/ğ‘sk
1 ) to
decrypt. We also denote by âŠ• the addition of the plaintext in two
ciphertexts, and by âŠ™ the scalar multiplication on ciphertext.
We abstract CL-based MtA from Castagnos et al.â€™s protocol [8].
ğ‘ƒ2 generates public-secret keypair and sends pk to ğ‘ƒ1 in the setup
phase. The CL-based MtA protocol is presented in Fig. 5, where
ğœ‹ğ¶ğ¿ is a ZKPoK for relation
ğ‘Ÿ
ğ‘ âˆ§ ğ‘2 = pkğ‘Ÿ
ğ‘“
ğ‘š}.
{(pk, ğ‘1, ğ‘2; ğ‘š, ğ‘Ÿ)|pk âˆˆ Ë†ğº, ğ‘Ÿ âˆˆ [0, ğ‘†], ğ‘1 = ğ‘”
Please refer to Appendix E for the proof ğœ‹ğ¶ğ¿.
The CL-encryption requires 2 exponentiations on the class group
while the decryption requires 1. The prover of ğœ‹ğ¶ğ¿ needs 2 expo-
nentiations while the verifier computes 4 exponentiations. The size
of ğœ‹ğ¶ğ¿ is about a CL ciphertext. Thus, the overall cost of CL-based
MtA is sending 3 CL ciphertexts and computing 9 exponentiations
over the class group.
Note that the scheme of Figure 5 dose not provide full simulation-
based security when ğ‘ƒ1 is corrupted. We remark that simulation
based security could be achieved by adding an expensive ZKPoK for
the affine operation of ğ‘ğ´ on ğ‘ğµ. In our specific usage, we choose the
same strategy as Castagnos et al. [8, Sec. 2.2] to achieve a weaker
game-based threshold unforgeability given in Appendix E.2, thus
do not add this ZKPoK.
4.3.1 Applying CL-based MtA to 2ECDSA. Instantiating MtA by
CL will result in a CL-based 2ECDSA1. In both [7, 8] and our pro-
tocol, CL encryption/decryption and/or ğœ‹ğ¶ğ¿ dominate the overall
complexity.
Although the overall cost of [7] is best, a CL ciphertext should be
transferred and a decryption computation is required making the
online phase computationally expensive. In particular, it is more
than 50 times slower compared with [8, 33], and nearly 1000 times
slower than ours in the online phase. The online phase of two-party
case of [8, 33] is fast (although it is interactive), while it costs 28
exponentiations and 140ğœ… bits (when ğœ… = 256). Our online phase is
non-interactive and extremely fast, and our offline cost is just 11
exponentiations and 53ğœ… bits. A concrete comparison is given in
Sec. 5.
5 IMPLEMENTATION AND COMPARISON
In this section, we give a comprehensive implementation and com-
parison of two-party ECDSA from Paillier, OT and CL-encryption.
Although [6, 8, 16, 19, 26] support threshold larger than two, we
only consider their performance in two-party case.
We benchmark our implementation using Rust on a MacBook
Pro 13-inch 2019 with Intel Core i5 @ 1.4 GHz CPU and 16 GB 2133
MHz LPDDR3 RAM running macOS Mojave v10.14.5. For simplicity,
we evaluate the protocols in a single laptop and consider only the
computation time. We remark that the comparison will further
favor our scheme if latency is taken into account. The reason is, as
shown in Sec. 1.4, our scheme has fewer communication rounds
than other schemes. The results are the median time of running 100
times. All benchmarks were taken over curve secp256k1 which is
recommended by NIST [24] and is the curve used in Bitcoin, among
many other blockchains and cryptocurrencies. We use SHA-256 to
instantiate the hash functions, random oracles and/or the PRG.
Overall comparison is shown in Figure 6 and Table 2. The detailed
comparisons are given in the following subsections.
5.1 Paillier-based Schemes
We set security parameters ğœ… = 256 (achieving 128-bits computa-
tional security), 80 bits statistical security, and 80 bits soundness
error for our Paillier-based 2ECDSA. The underlying MtA is that in
Appendix D. Lin17 [25] uses 40-bits statistical security and sound-
ness error. LNR18 [26] and CGGMP20 [6] set the same statistical
and soundness parameters with us. GG18 [19] sets 128-bits compu-
tational security, 256-bit statistical security and 128-bits soundness
error. We note that these works recommend 2048-bit module ğ‘ . To
make a fair comparison with CL and OT-based schemes, we set a
3072-bit module in the implementation and comparison.
We implement two versions of 2ECDSA and GG18 (one with
and one without Paillier-EC), LNR18, and CGGMP20 based on the
elementary code of ZenGo [32] and run ZenGoâ€™s code on Lin17. The
results of computation and communication on signing are presented
in Table 3. The key generation of our scheme has a similar cost
with GG18, LNR18, and CGGMP20.
Without Paillier-EC assumption, our scheme improves GG18â€™s
offline complexity by a factor of 5 for computation and a factor of 2
1ğœ‹ğ¶ğ¿ requires a setup step to guarantee that ğ‘”ğ‘ is a random element of the subgroup
âŸ¨ Ë†ğ‘”ğ‘âŸ©. It is executed in the key generation phase.
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea567Figure 6: Cost comparison of all two-party schemes. For every scheme, the south-west point is the offline cost, while north-east
point is the overall cost. Thus, the distance between these two points indicates the online complexity. The dashed red rectangles
share the same area.
for communication. Our implementation outperforms CGGMP20â€™s
work by a factor of 9 for computation and a factor of 8 for com-
munication. Without Paillier-EC assumption, we improve GG18â€™s
computation by a factor of 2 and its communication by a factor of
1.6.
5.2 OT-based Schemes
We set security parameters ğœ… = 256 (achieving 128-bits computa-