// Invoke the JNI method MyJni.load()
// JNI reflection invocation. args: Method=Context.getPackageName()  
// res: "com.vnuhqwdqdqd.trarenren5"
// Internal framework API
// Set the base context for this ContextWrapper.
// Malicious behaviors 1
// Load native library libnesec.so
01 Instrumentation.newApplication()
02       ClassLoader.loadClass("com.netease.nis.wrapper.MyApplication")
03 Application.init()
04 Application.attach() 
05       ContextWrapper.attathBaseContext() 
06        ...;
07       System.loadLibrary("nesec") 
08              FindClass( "com/netease/nis/wrapper/MyJni")  // Find and define Class = "com/netease/nis/wrapper/MyJni"          
09              LoadNativeLibrary("/data/app/com.vnuhqwdqdqd.trarenren5-1/lib/arm/libnesec.so")  //  Load library libnesec.so
10       MyJni.load()
11              InvokeVirtualOrInterfaceWithVarArgs()  
12              Context.getPackageName()
13              sys_open("data/data/com.vnuhqwdqdqd.trarenren5/.cache/classes.dex")   //  res: fd = 24
14              sys_write(fd = 24);            sys_close(fd = 24)  // Write protected dex content to classes.dex
15              /* Open and initialize DexFile arg(cid:6646)location="/data/user/0/com.vnuhqwdqdqd.trarenren5/.cache/classes.dex"  */
16             OpenMemory( ) 
17 Instrumentation.callApplicationOnCreate() 
18 Application.onCreate() 
19       IntentFilter.("com.zjdroid.invoke") 
20        /* Register an Intent receiver dynamically */
21       ContextWrapper.registerReceiver() 
22 Instrumentation.newActivity() 
23       ClassLoader.loadClass("v.v.v.MainActivity")
24             DefineClass()
25       Class.newInstance()
26             Activity.init()
27 Instrumentation.callActivityOnCreate() 
28             Activity.performCreate() 
29                 ...; 
30             Activity.finish() 
// Create and display an activity
// Create activity "v.v.v.MainActivity"
// Malicious behaviors 2
// Close the activity for hiding
// Called when the application is starting, before the activity is created
// Create an IntentFilter@0x12e4d848,
// Load Class="v.v.v.MainActivity", res: Class@0x13110808
// args: DexFileObj=0x06d541c8  Class="Lv/v/v/MainActivity;"
         // arg: Application@0x12e05498
// res: DexFileObj@0x06d541c8 The DexFile object is used to represented the dex file in Android runtime
// arg:  IntentFilter@0x12e4d848   
// Initialize the new activity arg: Activity="v.v.v.MainActivity", res: Activity@0x12c79f08 
Figure 6: The major information collected by Malton on function level. The names of Android runtime functions and system calls
are in black italics. We omit the information of method arguments due to the space limitation).
malware also calls the framework method Activity.ﬁnish()
to destroy its activity (Line 30).
Summary Malton can analyze sophisticated packed mal-
ware samples, and help the analyst identify the behaviors
of both the malware and its hidden code.
Behavior of Class (cid:256)(cid:256)com.netease.nis.wrapper.MyApplication(cid:257)
Malicious behavior 1
Load native component 
libnesec.so
Call JNI method 
MyJni.load()
Get IMEI of the device
Create a new thread
Leak the IMEI by the new thread 
through network
Get package name through JNI 
reflection invocation
Create new dex file classes.dex
Load dex file classes.dex and 
initialize new DexFile object
Register receiver for Intent 
(cid:256)com.zjdroid.invoke(cid:257)
Anti dynamic analysis
Behavior of Class (cid:256)v.v.v.MainActivity(cid:257)
Malicious behavior 2
Get IMEI of the device
Write the IMEI information into disk 
through the interfaces of class 
android.app.SharedPreferences.
Figure 7: Malton can reconstruct the behaviors of the
packed malware and its hidden code.
4.3 Path Exploration
To answer Q3, we ﬁrst employ Malton to analyze the
SMS handler of the packed malware com.nai.ke. From
the logs, we ﬁnd that its SMS handler handleReceiver()
processes each incoming SMS by obtaining its address
and content through methods getOriginatingAddress() and
getMessageBody(), respectively.
If the SMS is not from
the controller (i.e., Tel: 1851130**14), it calls the method
abortBroadcast() to abort the current broadcast.
Effectiveness
To explore all the malicious payload-
s controlled by the received SMS message, we speci-
fy the code region between the return of the function
getMessageBody() and the return of handleReceiver() to
perform in-memory concolic execution. We set the re-
sult of getMessageBody() (i.e., SMS content) as the input
of the concolic execution. To circumvent the checking
of the phone number of the received SMS message, we
trigger the malware to execute the satisﬁed code path by
changing the result of getOriginatingAddress() to the num-
ber of the controller.
However, we ﬁnd that the constraint resolver cannot
always ﬁnd the satisfying input due to the comparison of
two strings’ hash values. Therefore, we use the direct
execution engine to force the malware to execute the s-
elected code path. Eventually, we identify 14 different
code paths (or behaviors) that depend on the content of
the received SMS. The generated inputs and their cor-
responding behaviors are listed in Table 5. This result
demonstrated the effectiveness of Malton to explore dif-
ferent code paths.
Efﬁciency Thanks to the in-memory optimization, when
exploring code paths in the interested code region,
Malton just needs one SMS and then iteratively executes
the speciﬁed code region for 14 times without the need
of restarting the app for 14 times. To evaluate the ef-
USENIX Association
26th USENIX Security Symposium    299
Table 5: The commands and the related behaviors explored by Malton (The 3rd column lists the number of IR blocks to be
executed for exploring the code paths with/without in-memory optimization).
Command
Detected behavior
Number of executed blocks
“cq”
“qf”
“df”
“zy”
“by”
Read information SMS contents, contacts, device model and system version,
then send to PI:EMAIL with password “aAaccvv11” through SMTP protocol.
Send SMS to all contacts with no SMS content.
Send SMS to speciﬁed number, and both the number and content are speciﬁed by the command SMS.
Set unconditional call forwarding through making call to “**21*targetNum%23”,
and the targetNum is read from the command SMS.
Set call forwarding when the phone is busy through making call to “%23%23targetNum%23”,
and the targetNum is read from the control SMS.
32k/20443k
7k/20537k
5k/22970k
8k/22848k
15k/20639k
“ld”,“fd”,“dh”,“cz”,
“fx”,“sx”,“dc”, “bc”
Modify the its conﬁguration ﬁle zzxx.xml.
Others
Tell the controller the command format is error by replying an SMS.
5k-18k/20403k-20452k
15k/20443k
ﬁciency of the in-memory optimization, we record the
number of IR blocks to be executed for exploring each
code path with/without in-memory optimization, and list
them in Table 5 (the last column). The result shows that
the in-memory optimization can avoid executing a large
number of IR blocks. For example, when exploring the
paths decided by the command “df”, Malton only need-
s to execute 5k IR blocks with in-memory optimization.
Otherwise, it has to execute 22,970k IR blocks.
106
105
104
103
e
r
o
c
S
Android without Valgrind
Android with Valgrind
Malgrind without taint propagation
Malgrind with taint propagation
Android on emulator (Qemu)
31079
17237
22773
2844
1886
2924
877
1977
1137
867
602
2324
1436
1530
911
Table 6: The number of IR blocks to be executed for path
exploration with and without in-memory optimization.
Malware
With
Optimization
Without
Optimization
0710e f 0ee60e1ac f d2817988672b f 01b
0ced776e0 f 18dd f 02785704a72 f 97aac
0e69a f 88dcbb469e30 f 16609b10c926c
336602990b176c f 381d288b79680e4 f 6
8e1c7909aed92eea89 f 6a14e0 f 41503d
203k
203k
4k
13k
7k
26237k
26010k
16826k
1908k
69968k
We also use ﬁve other malware samples, which have
the SMS handler, to further evaluate the efﬁciency of
the path exploration module. The average number of IR
blocks to be executed with and without in-memory opti-
mization are listed in Table 6. The in-memory optimiza-
tion can obviously reduce the number of IR blocks to be
executed.
Summary The path exploration module of Malton can
explore code paths of malicious payloads effectively and
efﬁciently. The concolic execution engine generates the
satisfying inputs to execute certain code paths, and the
direct execution engine forcibly executes selected code
paths when the constraint resolver fails.
4.4 Performance Overhead
To understand the overhead introduced by Malton, we
run the benchmark tool CF-Bench [8] 30 times on
a Nexus 5 smartphone running Android 6.0 under
four different environments, including Android without
Valgrind, Android with Valgrind, and Malton with and
Native Score
Java Score
Overall Score
Figure 8: Performance measured by CF-Bench.
without the taint propagation. To compare with the dy-
namic analysis tools based on the Qemu emulator, we
also execute CF-Bench in Qemu, which runs on a Ubuntu
14.04 desktop equipped with Core(TM) i7 CPU and 32G
memory.
The results are shown in Figure 8. There are three
types of scores. The Java score denotes the performance
of Java operations, and the native score indicates the per-
formance of naive code operation. The overall scores
are calculated based on the Java and the native score. A
higher score means a better performance.
Figure 8 illustrates that Malton introduces around 16x
and 36x slowdown to the Java operations without and
with taint propagation. However, when the app runs with
only Valgrind, there is also 11x slowdown.
It mean-
s that Malton brings 1.5x-3.2x additional slowdown to
Valgrind. Similarly, for the native operations, Malton in-
troduces 1.7x-2.3x additional slowdown when running
Valgrind is taken as the baseline. Overall, Malton in-
troduces around 25x slowdown (with taint propagation).
Since the Qemu [57] emulator incurs around 15x over-
all slowdown, and the Qemu-based tools (e.g., the taint
tracker of DroidScope [83]) may incur 11x-34x additional
slowdown, Malton could be more efﬁcient than the exist-
ing tools based on Qemu.
Summary As a dynamic analysis tool, Malton has a rea-
sonable performance and could be more efﬁcient than the
existing tools based on the Qemu emulator.
300    26th USENIX Security Symposium
USENIX Association
5 Discussion
In this section, we discuss the limitations of Malton and
potential solutions to be investigated in future work.
First, Malton is based on the Valgrind framework.
Similar to the anti-emulator techniques, malware sam-
ples may detect the existence of Malton and then stop
executing malicious payloads or confuse the Java method
tracker of Malton. For example, the malware could check
the app starting command or the time used to ﬁnish some
operations. To address this challenge, we could leverage
Malton’s path exploration mechanism to explore and trig-
ger conditionally executed payloads. Nevertheless, it’s
an arm race between the analysis tool and anti-analysis
techniques.
Second, though the in-memory optimization signiﬁ-
cantly reduces the code required to be executed, it is
semi-automated because the analysts have to specify the
entry point and the exit point of the interested code re-
gion. How to fully automate this process is an interest-
ing research direction that we will pursue. Moreover, the
direct execution needs analysts to specify the branches
to be executed directly. Our current prototype ignores all
possible crashes because the directly executed code path
may access invalid memory. Advanced malware may ex-
ploit this weakness to evade Malton. In future work, we
will borrow some ideas from the X-Force [55] system to
recover the execution from crashes automatically.
Third, the code coverage is a concern for all dynam-
ic analysis platforms, including ours. We leverage the
monkey tool to generate events, and use the path ex-
ploration module to explore code paths. Even using the
simple monkey tool, Malton has demonstrated better re-
sults than existing tools in Section 4.1. In future work,
we will equip Malton with UI automation frameworks
(e.g., [41]) to generate more directive events. Moreover,
as Malton only deﬁnes the default sensitive APIs, users
can add more sensitive APIs to Malton.
Last but not least, though Malton uses taint analysis to
track sensitive information propagation, it cannot track
implicit information ﬂow and propagate taint tags over
indirect ﬂows.We will enhance it by leveraging the ideas
in [45]. For example, we can track the indirect ﬂows
like Binder IPC/RPC by hooking the related framework
methods and runtime functions. Moreover, since the ma-
jor purpose of Malton is to provide a comprehensive view
of the target apps instead of ﬁnding unknown malware,
it requires users to specify the malicious patterns for em-
ploying Malton to identify potential malware.
6 Related Work
Android malware analysis techniques can be generally
divided into static analysis, dynamic analysis, and the
hybrid of static and dynamic analysis. Since Malton is a
dynamic analysis system, this section introduces the re-
lated dynamic and hybrid approaches. Interested readers
please refer to [18,51,58,63,72,80] for more information
on static analysis of Android apps.
6.1 Dynamic or Hybrid Analysis
According to the implementation techniques, the exist-
ing (dynamic or hybrid) Android malware analysis tools
can be roughly divided into ﬁve types: tailoring Android
system [34, 39, 71, 89], customizing Android emulator
(e.g., Qemu) [73, 83], modifying (repackaging) app im-
plementation [37], employing system tracking tools [84],
or leveraging an app sandbox [20, 24].
We compare Malton with popular (dynamic or hybrid)
Android malware analysis tools, and enumerate the ma-
in-
jor differences in Table 7. Please note that
dicate that the tool can capture malware behaviors in the
framework layer, the runtime layer and the native layer,
respectively. Besides, the shadow sector means partial
of TaintART suggests that it can
support. For example,
monitor partial framework behaviors.
, and
,
TaintDroid [39] conducts dynamic taint analysis to de-
tect information leakage by modifying DVM. It does not
capture the behaviors in native layer because it trust-
s the native libraries loaded from ﬁrmware and does
not consider third-party native libraries. While on-
ly a small percent of apps used native libraries when
TaintDroid was designed, recent studies showed that na-