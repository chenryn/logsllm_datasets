Springer, 148â€“164.
[49] Adi Shamir. 1979. How to share a secret. Commun. ACM 22, 11 (1979), 612â€“613.
[50] Lloyd R Welch and Elwyn R Berlekamp. 1986. Error correction for algebraic
block codes. (Dec. 30 1986). US Patent 4,633,470.
[51] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. Hotstuff: Bft consensus with linearity and responsiveness. In Proceed-
ings of the 2019 ACM Symposium on Principles of Distributed Computing. ACM,
347â€“356.
[52] Thomas Yurek, Licheng Luo, Jaiden Fairoze, Aniket Kate, and Andrew K Miller.
2021. hbACSS: How to Robustly Share Many Secrets. (2021), 159 pages.
A ANALYSIS OF ALGORITHM 4
In this section, we will analyze that Algorithm 4 implements RBC
for long messages while keeping the round complexity at 4.
Lemma A.1. Assuming a collision resistant hash function, if an
honest node sends âŸ¨READY, ğ‘šğ‘–, â„âŸ© where â„ = hash(ğ‘€), then ğ‘šğ‘– is the
ğ‘–th symbol of RSEnc(ğ‘€, ğ‘›, ğ‘¡ + 1), and furthermore, no honest node
sends a READY message for a different â„â€² Ì¸= â„.
Proof. Let ğ‘– be the first honest node that sends a âŸ¨READY,âˆ—, â„âŸ©.
Then at least 2ğ‘¡+1 nodes sent âŸ¨ECHO,âˆ—, â„âŸ© to node ğ‘–. Now, for the sake
of contradiction assume that an honest node ğ‘–â€² is the first honest
node that sends a âŸ¨READY,âˆ—, â„â€²âŸ© for â„â€² Ì¸= â„. Again at least 2ğ‘¡ + 1
nodes sent âŸ¨ECHO,âˆ—, â„â€²âŸ© to node ğ‘–â€². Then, by quorum intersection,
at least ğ‘¡ + 1 nodes sent ECHO message for both â„ and â„â€². This is
impossible as there are at most ğ‘¡ malicious nodes and an honest
node sends ECHO message at most once.
Note that an honest node ğ‘– sends âŸ¨READY, ğ‘šğ‘–, â„âŸ© for â„ = hash(ğ‘€)
only upon receiving at least ğ‘¡ + 1 matching âŸ¨ECHO, ğ‘šğ‘–, â„âŸ©. At least
one of these ECHO message is from an honest node. Then, by the
collision resistance property of the underlying hash function, ğ‘šğ‘– is
the ğ‘–th symbol of RSEnc(ğ‘€, ğ‘›, ğ‘¡ + 1).
â–¡
Lemma A.2. If an honest node ğ‘– receives ğ‘¡ +1 READY messages with
a matching hash â„, then node ğ‘– will eventually receive ğ‘¡ + 1 matching
âŸ¨ECHO, ğ‘šğ‘–, â„âŸ© messages and hence send âŸ¨READY, ğ‘šğ‘–, â„âŸ©.
Proof. Let ğ‘— be the first honest node that sends âŸ¨READY,âˆ—, â„âŸ©
message to all. Then, node ğ‘— must have received at least 2ğ‘¡ + 1 ECHO
messages with matching â„. At least ğ‘¡ +1 of these ECHO messages are
from honest nodes. All these honest node will send âŸ¨ECHO, ğ‘šğ‘–, â„âŸ©
to node ğ‘–. Hence, node ğ‘– will eventually receive ğ‘¡ + 1 âŸ¨ECHO, ğ‘šğ‘–, â„âŸ©
messages.
â–¡
Theorem A.3 (Totality and Agreement). Algorithm 4 guar-
antees Totality and Agreement.
Proof. An honest node outputs a message ğ‘€ only upon receiv-
ing at least 2ğ‘¡+1 READY messages with a matching hash â„ = hash(ğ‘€).
At least ğ‘¡ + 1 of them are sent by an honest node. Hence, all honest
nodes will receive at least ğ‘¡ + 1 READY messages with hash â„. By
lemma A.2, eventually all honest nodes will send READY messages
with hash â„. Hence, all honest nodes will receive READY messages
from all other honest nodes. Furthermore, due to Lemma A.1, all
these READY message contain correct symbols from the codeword
RSEnc(ğ‘€, ğ‘›, ğ‘¡ + 1). Thus, every honest node will eventually output
ğ‘€ such that â„ = hash(ğ‘€).
â–¡
Theorem A.4 (Validity). Algorithm 4 guarantees Validity.
Proof. When the broadcaster is honest and has input M, at
least 2ğ‘¡ + 1 honest nodes will send ECHO messages with identical
â„ = hash(ğ‘€). Hence, all honest nodes will eventually send READY
messages for â„. By lemma A.1 no honest node will send READY
message for â„â€² Ì¸= â„. As a result, all honest node will receive at
least 2ğ‘¡ + 1 READY message for â„ with valid symbols in it, which is
sufficient to recover ğ‘€.
â–¡
Next, we will analyze the communication complexity of the
protocol.
Lemma A.5. Assuming existence of collision resistant hash func-
tions, Algorithm 4 solves RBC with communication complexity of
ğ‘‚(ğ‘›|ğ‘€|+ğœ…ğ‘›2) where ğœ… is the size of the output of the hash function.
Proof. In algorithm 4 the broadcaster sends a single PROPOSE
to all other nodes. Moreover, each honest node sends a single ECHO
and READY message. The proposal message has a communication
cost of ğ‘‚(ğ‘›|ğ‘€|). Since |ğ‘šğ‘–|= |ğ‘€|/(ğ‘¡ + 1) and hash outputs are ğœ… bits
long, both ECHO and READY messages are ğ‘‚(|ğ‘€|/ğ‘› + ğœ…) bits long.
Hence, each node incur a communication cost of ğ‘‚(|ğ‘€|+ğ‘›ğœ…) for
sending ECHO and READY messages to all other nodes. Hence, the
total communication cost is ğ‘‚(ğ‘›|ğ‘€|+ğœ…ğ‘›2).
â–¡
B ADD FOR HIGH THRESHOLD
Recall from Â§3 that it is impossible to solve ADD for ğ‘› â‰¤ 2ğ‘¡. In this
section we will describe how to extend our solution to ADD from
ğ‘› > 3ğ‘¡ to ğ‘› > 2ğ‘¡. To do so, we will make use of a collision-resistant
hash function. The detailed changes in our original protocol are as
follows.
During the encoding phase, each sender encodes the message ğ‘€
with ğ‘š = ğ‘›(ğ‘¡ + 1)/(ğ‘› âˆ’ 2ğ‘¡) (due to reasons to be described later). Let
ğ‘€â€² = RSEnc(ğ‘€, ğ‘š, ğ‘¡ + 1) be the encoded message.
During the dispersal phase, each sender sends the ğ‘–th component
of ğ‘€â€² (i.e., ğ‘šğ‘–) to node ğ‘–. Note that ğ‘šğ‘– consists of ğ‘š/ğ‘› symbols of
the codeword, hence its size is
ğ‘›(ğ‘¡ + 1) =
ğ‘›(ğ‘¡ + 1)|ğ‘€|
(ğ‘› âˆ’ 2ğ‘¡)ğ‘›(ğ‘¡ + 1) = |ğ‘€|
ğ‘› âˆ’ 2ğ‘¡
|ğ‘šğ‘–|= ğ‘š|ğ‘€|
Furthermore, each sender additionally sends the cryptographic
hash digest â„ = hash(ğ‘€) to all other nodes. In particular, during the
dispersal phase, each sender sends âŸ¨DISPERSE, ğ‘šğ‘–, â„âŸ© to node ğ‘–. A
recipient node ğ‘—, upon receiving ğ‘¡ + 1 matching âŸ¨DISPERSE, ğ‘š ğ‘— , â„âŸ©
ğ‘— = ğ‘š ğ‘— and â„âˆ— = â„, which will be used during the
message, sets ğ‘šâˆ—
reconstruction phase.
During the reconstruction phase, similar to our ğ‘¡  2ğ‘¡ nodes where up to ğ‘¡ nodes could be
malicious, our high-threshold ADD has a total communication cost of
ğ‘‚(ğ‘›2|ğ‘€|/(ğ‘› âˆ’ 2ğ‘¡) + ğ‘›2ğœ…). Here ğœ… is the size of the output of the hash
function.
Proof. During the dispersal phase, each sender sends a mes-
sage of size ğ‘‚(|ğ‘€â€²|/ğ‘› + ğœ…) to every other node. Hence, the total
communication cost of every sender is ğ‘‚(|ğ‘€â€²|+ğ‘›ğœ…). Since there are
Î˜(ğ‘›) senders, the total communication cost in the dispersal phase is
ğ‘‚(ğ‘›|ğ‘€â€²|+ğ‘›2ğœ…). During the reconstruction phase, each nodes sends
a message of size ğ‘‚(|ğ‘€â€²|/ğ‘›) to every other node. Hence, the total
communication cost during the reconstruction phase is ğ‘‚(ğ‘›|ğ‘€â€²|)
Since in our high-threshold ADD |ğ‘€â€²|= ğ‘‚(ğ‘›|ğ‘€|/(ğ‘› âˆ’ 2ğ‘¡), it has a
total communication cost of ğ‘‚(ğ‘›2|ğ‘€|/(ğ‘› âˆ’ 2ğ‘¡) + ğ‘›2ğœ…).
â–¡
C THRESHOLD SECRET SHARING
A (ğ‘›, ğ‘˜) threshold secret sharing scheme allows a secret ğ‘  âˆˆ Zğ‘ to be
shared among ğ‘› nodes such that any ğ‘˜ of them can come together
to recover the original secret, but any subset of ğ‘˜ âˆ’ 1 shares cannot
be used to recover the original secret [9, 49]. We use the common
Shamir secret sharing [49] scheme, where the secret is embedded
in a random degree ğ‘˜ âˆ’ 1 polynomial in the field Zğ‘ for some prime
ğ‘. Specifically, to share a secret ğ‘  âˆˆ Zğ‘, a polynomial ğ‘(Â·) of degree
ğ‘˜ âˆ’ 1 is chosen such that ğ‘  = ğ‘(0). The remaining coefficients of
ğ‘(Â·), ğ‘1, ğ‘2, Â· Â· Â· , ğ‘ğ‘¡ are chosen uniformly randomly from Zğ‘. The
resulting polynomial ğ‘(ğ‘¥) is defined as:
ğ‘(ğ‘¥) = ğ‘  + ğ‘1ğ‘¥ + ğ‘2ğ‘¥2 + Â· Â· Â· + ğ‘ğ‘˜âˆ’1ğ‘¥ğ‘˜âˆ’1
Each node is then given a single evaluation of ğ‘(Â·). In particular, the
ğ‘–th node is given ğ‘(ğ‘–) i.e., the polynomial evaluated at ğ‘–. Observe
that given ğ‘¡ + 1 points on the polynomial ğ‘(Â·), one can efficiently
reconstruct the polynomial using Lagrange Interpolation. Also note
that when ğ‘  is uniformly random in Zğ‘, ğ‘  is information theoretically
hidden from an adversary that knows any subset of ğ‘˜ âˆ’ 1 or less
evaluation points on the polynomial other than ğ‘(0) [49].
D PEDERSENâ€™S VSS [44]
Let ğœ… be the security parameter. Let G be a cyclic abelian group of
prime order ğ‘ and Zğ‘ the group of integer modulo ğ‘. Let ğ‘”0, ğ‘”1 â†
G be two uniform and independent element from G. Before we
describe Pedersenâ€™s VSS scheme, we will first briefly describe the
commitment scheme for a arbitrary secret ğ‘  âˆˆ Zğ‘. To commit to a
secret ğ‘ , the committer samples a random ğ‘Ÿ âˆˆ Zğ‘ and computes
commit(ğ‘ , ğ‘Ÿ) = ğ‘£ = ğ‘”ğ‘ 
0ğ‘”ğ‘Ÿ
1
To reveal such a commitment later, the committer reveals (ğ‘ , ğ‘Ÿ)
1 is equal to ğ‘£ or not. We refer
and the verifier checks whether ğ‘”ğ‘ 
to the reveal procedure as:
0ğ‘”ğ‘Ÿ
reveal(ğ‘£) := ğ‘ , ğ‘Ÿ such that ğ‘£ = ğ‘”ğ‘ 
0ğ‘”ğ‘Ÿ
1
Pedersen [44] illustrates that the commitment scheme described
above information theoretically hides ğ‘  and binds ğ‘  to ğ‘£ for a com-
putationally bounded prover, assuming the prover does not know
the discrete logarithm of ğ‘”1 with respect to ğ‘”0, i.e., the prover can
not efficiently compute logğ‘”0 ğ‘”1. We summarize the VSS scheme
from [44] in Figure 4.
Observe that the commitment to the polynomial ğ‘(Â·) that embeds
the secret ğ‘  is linear in the number of nodes. Moreover, given the
linear size commitment and a tuple (ğ‘ ğ‘˜, ğ‘¡ğ‘˜), one can efficiently verify
(without any extra information) whether ğ‘ ğ‘˜ is equal to ğ‘(ğ‘˜) or not.
We will crucially use these properties to design our AVSS scheme
with a total communication cost of ğ‘‚(ğœ…ğ‘›2).
Next, we briefly summarize the properties of the VSS scheme
described in Figure 4. Informally, Lemma D.1 states that once the
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2719Let ğ‘  be the secret a node (the dealer) and let ğ‘”0, ğ‘”1 two
uniformly random and independent generators of a group G.
PedPolyCommit(ğ‘”0, ğ‘”1, ğ‘ ) â†’ {ğ’”, ğ’„, ğ’“}
(1) Sample ğ‘Ÿ â† Zğ‘ and let ğ‘£0 = commit(ğ‘ , ğ‘Ÿ).
(2) Sample ğ‘ğ‘˜, ğ‘ğ‘˜ âˆˆ ğ‘ğ‘ for ğ‘˜ = 1, 2, ..., ğ‘¡ and let:
ğ‘(ğ‘¥) = ğ‘  + ğ‘1ğ‘¥ + . . . + ğ‘ğ‘¡ ğ‘¥ğ‘¡; and
ğœ™(ğ‘¥) = ğ‘Ÿ + ğ‘1ğ‘¥ + . . . + ğ‘ğ‘¡ ğ‘¥ğ‘¡