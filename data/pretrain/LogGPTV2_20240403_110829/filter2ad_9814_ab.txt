因为更新迭代，此时的富文本编辑器中的数据提交到了select_images_post_wangEditor.php文件中，这里的正则匹配特殊字符替换成空，但是这里的文件后缀也采用pathinfo()方法获取文件后缀，之前文件名1.png.p*hp经过特殊字符替换成空，然后pathinfo()方法获取获取到的文件后缀为php，这里的白名单`$cfg_imgtype`是`jpg|gif|png`，显然php并不在其中，所以返回提示信息"您所上传的图片类型不在许可列表"。
官方已修复该漏洞，请注意升级。补丁链接： 
### 05 漏洞总结
从上面可以知道上传`p*hp`后缀的原因是在正则替换之前存在着一个黑名单验证，传入`p*hp`后缀后可以绕过这个黑名单验证然后被正则把*替换为空，而文件后缀获取时会取出最后一个数组成员php，并没有进行二次验证，所以造成了这次文件上传漏洞的产生。
## 0x04 DedeCMS V5.7 SP2后台文件上传(CVE-2019-8362)
### 01 漏洞复现
复现环境：phpstudy、DedeCMS V5.7 SP2、php5.6.9
首先准备一个压缩包1.zip，压缩包里面的文件名为1.jpg.php，文件内容为：
安装完成之后登录到系统后台，默认账号/密码是admin/admin，点击在左侧当导航栏中的核心按钮，然后选中附件管理中的文件式管理器，进入其中的soft目录中。
然后把之前准备好的压缩包上传上去。
然后访问album_add.php文件发布新图集，这里需要提前创建一个图集主栏目，上传方式选择从ZIP压缩包中解压图片，选择之前上传的1.zip。
上传完成之后，我们点击预览文档。
然后就会跳转到前台页面，点击下面的testZip。
当点击testZip，页面跳转，之前压缩包内的1.jpg.php里面的代码会执行。
我们来看一下这里正常上传图片的效果，当压缩包内是图片的话，这个会显示出图片，至于链接的话就是查看图片的链接。
### 02 漏洞分析
使用burpSuite抓包，发现提交到了album_add.php文件，在/dede/album_add.php中找到这个文件，跟进程序看到底是怎么处理的。
album_add.php文件的前半部分都是一些验证赋值操作，或者是验证关于相关栏目的信息，但是因为上传的时候选择的是从压缩包中解压图片，所以`$formzip`参数值为1，这个后面会用到。
因为`$formzip`参数值为1，所以会解压压缩包中的图片，其实可以发现在程序的173行调用ExtractAll()方法完成解压操作，传入`$zipfile`和`$tmpzipdir`两个参数，`$zipfile`是压缩包的保存路径，`$tmpzipdir`是创建出来存在解压文件的路径。
跟进到ExtractAll()方法，查看程序的下一步执行。
在程序第309行会调用get_List()方法获取压缩包中的信息。
这里要提一下ReadCentralFileHeaders()方法，在这个方法中会读取到压缩包中的文件名等信息。
然后回到ExtractAll()方法，接着调用Extract()方法解压单个文件，这个方法中也会调用ReadCentralFileHeaders()方法读取到压缩包中的文件名等信息，然后在361行调用ExtractFile()方法，并把获取压缩包中文件信息(`$header`)、压缩包路径(`$zip`)、创建的目录(`$to`)这三个参数一起传入。
ExtractFile()方法中的大致流程就是首先会创建的目录下面创建一个gz文件，文件名称是`$header[‘filename’].gz`拼接的，也就是1.jpg.php.gz，接下来在创建一个`$header[‘filename’]`文件，此时这个文件名就是1.jpg.php，再把读取到的内容写入进去，这个过程中并没有对内容进行校验。
从调试中可以看到，写入的内容就是上传压缩包中文件的内容``，最后删除gz文件。完成解压。
完成解压之后程序回到album_add.php文件中，在程序第176行，程序调用了GetMatchFiles()方法，并且传入了三个参数，分别是`$tmpzipdir`、`jpg|png|gif`、`$imgs`。
回到album_add.php文件。此时的`$imgs`就是读取到的文件名，此时会进行循环操作，循环中首先会组成一个保存路径`$savepath`，是由`$cfg_image_dir`拼接上年月组成，`$iurl`是由`$savepath`进行一系列的拼接组成，最关键的点是在程序的第184行，取出`$imgold`参数的最后四个字符，`$imgold`就是GetMatchFiles()方法读取到的文件路径，其中最后四个字符就是`.php`，然后拼接在`$iurl`上面，`$cfg_basedir`跟`$iurl`组成文件名，所以此时的文件后缀就是php，然后利用copy()方法，把`$imgold`中的内容复制到`$iurl`中，并且删除之前创建的ziptmp中的目录，最后就是进行一些图片的尺寸以及数据库的操作。
程序继续向下进行，在第209行，会把`$iurl`参数参入到数据库中，就是把发表的信息都存入到数据库中。
最后如果选择删除压缩包，会把压缩包删除，再通过RmDirFiles()方法删除对应创建的目录`$tmpzipdir`。
当前台调用的时候可以发现跳转的链接，点击超链接进入。
当要点击标题链接时，在左下角也会发现同样的URL，这个URL就是我们保存的PHP文件的路径。
并且从代码中我们也可以看见，这个链接是写死在HTML文件中的。
所以点击链接就会跳转到PHP文件，执行文件中的代码。
### 03 漏洞修复
我们把/dede/file_class.php中第161行代码修改成：
    else if (in_array(pathinfo($filename, PATHINFO_EXTENSION), explode("|", $fileexp),true) === TRUE)  
这里之前是验证文件名，现在改成验证文件后缀，后续就会验证文件后缀是否存在`$fileexp`中了。
最新版中使用pathinfo()方法获取到文件的后缀，然后判断是否后缀是否在白名单数组中。然后再重复一次之前的上传流程，此时在这个断点处可以看到，php后缀并不满足判断条件，所以此时的文件名并不就加入到`$filearr`中，`$filearr`数组就是当时作为参数传入的`$imgs`数组，因为`$imgs`为空数组，所以接下来的循环复制操作也就不会执行了。
官方已修复该漏洞，请注意升级。补丁链接： 
### 04 漏洞总结
在分析过程中可以看到，对于压缩包中文件的后缀并没有进行验证，文件后缀的获取也没有进行二次验证，而是直接获取文件名称的最后四个字符拼接上去，最终造成了文件上传漏洞的产生。
## 0x05 总结
从上面两个实例中可以看到，第一个漏洞有用到黑名单验证，但并不是验证的文件后缀，两个漏洞都用白名单对文件名进行了验证，保存文件时对于文件后缀的获取并没有进行二次验证，而是直接获取拼接，所以才会造成文件上传漏洞的产生，造成系统的Getshell。对于上传文件其实也要对内容进行验证的，并且这两个地方本来都是上传图片的功能，验证上传文件的头部信息，对上传文件进行二次渲染，在保存文件时对后缀进行二次验证，这样就可以极大程度的避免文件上传漏洞的产生。
* * *