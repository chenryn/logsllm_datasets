  * 在传统代码领域，如C代码中，对第三方代码功能的复用依赖，往往通过直接进行库的引入实现，第三方代码独立而完整，也较容易进行整体更新；这是最简单的情况，只需要所有下游使用者保证仅使用官方版本，跟进官方更新即可；但在实践中很难如此贯彻，这是下节讨论的问题。
  * 有些第三方发布的代码，模式就是需要被源码形式包含到其他项目中进行统一编译使用（例如腾讯的开源Json解析库RapidJSON，就是纯C++头文件形式）。在开源领域有如GPL等规约对此进行规范，下游开发者遵循协议，引用代码，强制或可选地显式保留其GPL声明，可以进行使用和更改。这样的源码依赖关系，结合规范化的changelog声明代码改动，侧面也是为开发过程中跟进考虑。但是一个成型的产品，比如企业自有的服务端底层产品、中间件，新版本的发版更新是复杂的过程，开发者在旧版本仍然“功能正常”的情况下往往倾向于不跟进新版本；而上游代码如果进行安全漏洞修复，通常也都只在其最新版本代码中改动，安全修复与功能迭代并存，如果没有类似Linux发行版社区的努力，旧版本代码完全没有干净的安全更新patch可用。
  * 在特定场景下，有些开发实践可能不严格遵循开源代码协议限定，引入了GPL等协议保护的代码而不做声明（以规避相关责任），丢失了引入和版本的信息跟踪；在另一些场景下，可能存在对开源代码进行大刀阔斧的修改、剪裁、定制，以符合自身业务的极端需求，但是过多的修改、人员的迭代造成与官方代码严重的失同步，丧失可维护性。
  * 更一般的情况是，在开发中，开发者个体往往心照不宣的存在对网上代码文件、代码片段的复制-粘贴操作。被参考的代码，可能有上述的开源代码，也可能有各种Github作者练手项目、技术博客分享的代码片段、正式开源项目仅用来说明用法的不完备示例代码。这些代码的引入完全无迹可寻，即便是作者自己也很难解释用了什么。这种情况下，上面两条认定的那些与官方安全更新失同步的问题同样存在，且引入了独特的风险：被借鉴的代码可能只是原作者随手写的、仅仅是功能成立的片段，甚至可能是恶意作者随意散布的有安全问题的代码。由此，问题进入了最大的发散空间。
在Synopsys下BLACKDUCK软件之前发布的《2018 Open Source Security and Risk Analysis
Report》中分析，96%的应用中包含有开源组件和代码，开源代码在应用全部代码中的占比约为57%，78%的应用中在引用的三方开源代码中存在历史漏洞。也就是说，现在互联网上所有厂商开发的软件、应用，其开发人员自己写的代码都是一少部分，多数都是借鉴来的。而这还只是可统计、可追溯的；至于上面提到的非规范的代码引用，如果也纳入进来考虑，三方代码占应用中的比例会上升到多少？曾经有分析认为至少占80%，我们只期望不会更高。
## Ⅱ. 从碎片到乱刃：OpenSSH在野后门一览
在进行基础软件梳理时，回忆到反病毒安全软件提供商ESET在2018年十月发布的一份白皮书《THE DARK SIDE OF THE FORSSHE: A
landscape of OpenSSH
backdoors》。其站在一个具有广泛用户基础的软件提供商角度，给出了一份分析报告，数据和结论超出我们对于当前基础软件使用全景的估量。以下以我的角度对其中一方面进行解读。
### 一些必要背景
SSH的作用和重要性无需赘言；虽然我们站在传统互联网公司角度，可以认为SSH是通往生产服务器的生命通道，但当前多样化的产业环境已经不止于此（如之前libssh事件中，不幸被我言中的，SSH在网络设备、IoT设备上（如f5）的广泛使用）。
OpenSSH是目前绝大多数SSH服务端的基础软件，有完备的开发团队、发布规范、维护机制，本身是靠谱的。如同绝大多数基础软件开源项目的做法，OpenSSH对漏洞有及时的响应，针对最新版本代码发出安全补丁，但是各大Linux发行版使用的有各种版本的OpenSSH，这些社区自行负责将官方开发者的安全补丁移植到自己系统搭载的低版本代码上。
### 白皮书披露的现状
如果你是一个企业的运维管理人员，需要向企业生产服务器安装OpenSSH或者其它基础软件，最简单的方式当然是使用系统的软件管理安装即可。但是有时候，出于迁移成本考虑，可能企业需要在一个旧版本系统上，使用较新版本的OpenSSL、OpenSSH等基础软件，这些系统不提供，需要自行安装；或者需要一个某有种特殊特性的定制版本。这时，可能会选择从某些rpm包集中站下载某些不具名第三方提供的现成的安装包，或者下载非官方的定制化源码本地编译后安装，总之从这里引入了不确定性。
这种不确定性有多大？我们粗估一下，似乎不应成为问题。但这份白皮书给我们看到了鲜活的数据。
ESET研究人员从OpenSSH的一次历史大规模Linux服务端恶意软件Windigo中获得启示，采用某种巧妙的方式，面向在野的服务器进行数据采集，主要是系统与版本、安装的OpenSSH版本信息以及服务端程序文件的一个特殊签名。整理一个签名白名单，包含有所有能搜索到的官方发布二进制版本、各大Linux发行版本各个版本所带的程序文件版本，将这些标定为正常样本进行去除。最终结论是：
  * 共发现了几百个非白名单版本的OpenSSH服务端程序文件ssh和sshd；
  * 分析这些样本，将代码部分完全相同，仅仅是数据和配置不同的合并为一类，且分析判定确认有恶意代码的，共归纳为 21个各异的恶意OpenSSH家族；
  * 在21个恶意家族中，有12个家族在10月份时完全没有被公开发现分析过；而剩余的有一部分使用了历史上披露的恶意代码样本，甚至有源代码；
  * 所有恶意样本的实现，从实现复杂度、代码混淆和自我保护程度到代码特征有很大跨度的不同，但整体看，目的以偷取用户凭证等敏感信息、回连外传到攻击者为主，其中有的攻击者回连地址已经存在并活跃数年之久；
  * 这些后门的操控者，既有传统恶意软件黑产人员，也有APT组织；
  * 所有恶意软件或多或少都在被害主机上有未抹除的痕迹。ESET研究者尝试使用蜜罐引诱出攻击者，但仍有许多未解之谜。这场对抗，仍未取胜。
白皮书用了大篇幅做技术分析报告，此处供细节分析，不展开分析，以下为根据恶意程序复杂度描绘的21个家族图谱：
### 问题思考
问题引入的可能渠道，我在开头进行了一点推测，主要是由人的原因切入的，除此以外，最可能的是恶意攻击者在利用各种方法入侵目标主机后，主动替换了目标OpenSSH为恶意版本，从而达成攻击持久化操作。但是这些都是止血的安全运维人员该考虑的事情；关键问题是，透过表象，这显露了什么威胁形式？
这个问题很好回答，之前也曾经反复说过：基础软件碎片化。
如上一章节简单提到，在开发过程中有各种可能的渠道引入开发者不完全了解和信任的代码；在运维过程中也是如此。二者互相作用，造成了软件碎片化的庞杂现状。在企业内部，同一份基础软件库，可能不同的业务线各自定制一份，放到企业私有软件仓库源中，有些会有人持续更新供自己产品使用，有些由系统软件基础设施维护人员单独维护，有些则可能是开发人员临时想起来上传的，他们自己都不记得；后续用到的这个基础软件的开发和团队，在这个源上搜索到已有的库，很大概率会倾向于直接使用，不管来源、是否有质量背书等。长此以往问题会持续发酵。而我们开最坏的脑洞，是否可能有黑产人员入职到内部，提交个恶意基础库之后就走人的可能？现行企业安全开发流程中审核机制的普遍缺失给这留下了空位。
将源码来源碎片化与二进制使用碎片化并起来考虑，我们不难看到一个远远超过OpenSSH事件威胁程度的图景。但这个问题不是仅仅靠开发阶段规约、运维阶段规范、企业内部管控、行业自查、政府监管就可以根除的，最大的问题归根结底两句话：
不可能用一场战役对抗持续威胁；不可能用有限分析对抗无限未知。
## Ⅲ. 从自信到自省：RHEL、CentOS backport版本BIND漏洞
2018年12月20日凌晨，在备战冬至的软件供应链安全大赛决赛时，我注意到漏洞预警平台捕获的一封邮件。但这不是一个漏洞初始披露邮件，而是对一个稍早已披露的BIND在RedHat、CentOS发行版上特定版本的1day漏洞CVE-2018-5742，由BIND的官方开发者进行额外信息澄(shuǎi)清(guō)的邮件。
### 一些必要背景
**关于BIND**
互联网的一个古老而基础的设施是DNS，这个概念在读者不应陌生。而BIND“是现今互联网上最常使用的DNS软件，使用BIND作为服务器软件的DNS服务器约占所有DNS服务器的九成。BIND现在由互联网系统协会负责开发与维护参考。”所以BIND的基础地位即是如此，因此也一向被大量白帽黑帽反复测试、挖掘漏洞，其开发者大概也一直处在紧绷着应对的处境。
**关于ISC和RedHat**
说到开发者，上面提到BIND的官方开发者是互联网系统协会（ISC）。ISC是一个老牌非营利组织，目前主要就是BIND和DHCP基础设施的维护者。而BIND本身如同大多数历史悠久的互联网基础开源软件，是4个UCB在校生在DARPA资助下于1984年的实验室产物，直到2012年由ISC接管。
那么RedHat在此中是什么角色呢？这又要提到我之前提到的Linux发行版和自带软件维护策略。Red Hat Enterprise
Linux（RHEL）及其社区版CentOS秉持着稳健的软件策略，每个大的发行版本的软件仓库，都只选用最必要且质量久经时间考验的软件版本，哪怕那些版本实在是老掉牙。这不是一种过分的保守，事实证明这种策略往往给RedHat用户在最新漏洞面前提供了保障——代码总是跑得越少，潜在漏洞越多。
但是这有两个关键问题。
一方面，如果开源基础软件被发现一例有历史沿革的代码漏洞，那么官方开发者基本都只为其最新代码负责，在当前代码上推出修复补丁。
另一方面，互联网基础设施虽然不像其上的应用那样爆发性迭代，但依然持续有一些新特性涌现，其中一些是必不可少的，但同样只在最新代码中提供。
两个刚需推动下，各Linux发行版对长期支持版本系统的软件都采用一致的策略，即保持其基础软件在一个固定的版本，但对于这些版本软件的最新漏洞、必要的最新软件特性，由发行版维护者将官方开发者最新代码改动“向后移植”到旧版本代码中，即backport。这就是基础软件的“官宣”碎片化的源头。