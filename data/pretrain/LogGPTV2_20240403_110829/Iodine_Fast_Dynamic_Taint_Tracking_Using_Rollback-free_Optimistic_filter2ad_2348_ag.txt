### Optimization and Performance Analysis of Iodine

There is no opportunity for further optimization, as Iodine fails to effectively elide taint checks. To investigate this behavior, we analyze how Iodine’s normalized runtime varies with the increasing taint sampling fraction in our some-to-all taint analysis, as detailed in §VI-C (Figure 10). We statically identify all viable taint sources (input interfaces from console, file, or network) and randomly sample the specified fraction of them to be active. Given that the selected sources may vary in their dynamic execution frequencies, we run 100 different samples for a given sampling fraction (except for 100%).

As expected, Iodine’s performance generally degrades when dealing with a larger fraction of tainted inputs. However, Iodine shows significant benefits for many realistic levels of tainted input. This behavior is inherent to hybrid analysis and is not worse in Iodine than in a conservative hybrid analysis.

Iodine is effective when the target program and the taint policy induce a low fraction of tainted data. For the IFT security policies studied in §VI-B, the static fraction of active taint sources ranges between 14-23% (as indicated in Figure 10).

### Discussion

#### Limitations
Our implementation is currently for programs written in the C language and does not support native programs written in assembly. However, the principles of Optimistic Hybrid Analysis (OHA) are generally applicable to static analyses of x86 binaries [47] and have been shown to benefit other analyses for Java programs as well [18].

Support for multi-threaded programs requires a concurrency analysis on top of Iodine’s information-flow analysis. Prior work [18] has demonstrated that OHA can benefit such analyses.

#### Rarity and Severity of Invariant Violations
For well-tested software, invariants should rarely fail, as profiles would have captured the common-case program states. However, for moderately large software with diverse features, optimistically gathered invariants may eventually fail when the program encounters unprofiled behavior. If this occurs, Iodine switches to a conservative hybrid analysis, ensuring that even in the worst case, it is as fast as the best available conservative hybrid technique.

Currently, due to the very low invariant violation rate, Iodine conservatively continues on the slow-path until the next system reboot, at which point it switches back to the fast-path. While this approach is no worse than a conservative hybrid analysis, we envision the following strategies to preserve most of Iodine’s performance benefits even after an invariant violation:

- **Background Re-analysis**: Upon an invariant failure, we can 'learn' this new behavior and re-analyze the program without the offending invariant. For many useful static analyses, this can be done incrementally rather than from scratch [48]. For a dataflow analysis like Iodine’s, this involves adding new nodes and edges to the program's definition-use graph and recomputing the transitive closure. The recompilation process can continue in the background while the monitored program runs slowly. Upon completion, the program can switch to the newly optimized analysis at a predetermined safe program point.
  
- **Graceful Degradation**: Instead of switching to the most conservative analysis, we can switch to a less aggressive optimistic analysis that excludes the failing invariant. Even better, if we can compute and succinctly encode the mapping between assumed invariants and the set of induced optimizations, we can selectively disable only those optimizations induced by the violated invariant. This essentially re-instruments the monitors that were elided by assuming that invariant. Dynamically re-instrumenting the new analysis on-demand also eliminates the memory overhead of maintaining multiple analysis versions.

Iodine can be implemented at the runtime system layer, where the invariant violation handler can invoke a dynamic instrumentation framework to re-instrument the modified analysis, thereby opening opportunities to further benefit from Just-In-Time (JIT) compilation techniques [49]. Such a setup also allows for actively learning new invariants and re-optimizing the analysis.

### Related Work

Iodine builds on prior optimistic hybrid analysis work [18] in two major ways: (1) it constructs a rollback-free OHA by limiting to only safe elision optimizations, solving the recovery problem in OHA, and (2) applies this novel technique to realize a low-overhead DIFT solution for live executions. Below, we discuss relevant prior work on DIFT, hybrid program analyses, and profile-based optimizations.

- **Dynamic Analysis**: There has been significant work on dynamic taint tracking systems [9], [12], [50]. Past work has developed many optimized dynamic techniques, such as creating highly specific information-flow policies [5], [6], [11], reducing its scope to only apply to related processes [51], optimizing low-level taint operations [34], writing minimal emulators targeted for taint tracking [14], or even providing custom hardware support [10], [52]–[54]. All these optimizations operate purely on the dynamic state of the program, attempting to make existing sets of taint operations faster. Iodine elides taint operations through static analysis, reducing the set of instructions monitored, making its optimization complementary to these prior approaches.

- **Taint Tracking Parallelization**: Taint tracking has also been parallelized either by partitioning the execution into epochs to perform local analysis and then aggregating results [15], [55], or by decoupling taint analysis from the program execution [16], [17], [56], [57], wherein the dynamic instrumentation only performs lightweight logging followed by offline analysis. These efforts reduce latency of taint tracking through parallelization but not overall work, like Iodine does. They too are complementary to Iodine’s optimizations.

- **Static Analysis**: Several systems have attempted to solve taint tracking using language features to enforce a taint policy at compile-time, sometimes with limited dynamic checks [58], [59]. These systems achieve low runtime overhead but place the burden on the programmer to specify and guarantee taint policy using an unfamiliar restrictive language. Iodine optimizes dynamic analysis and does not require source code changes, other than trivial annotations specifying taint sources, sinks, and untaint functions.

- **Hybrid Analysis**: Hybrid analysis has been explored in the past [60] for accelerating DIFT. Moore et al. provide the soundness conditions for static analysis to determine when it is safe to stop tracking certain variables dynamically [19]. In addition to removing unnecessary monitors using static analysis, Chang et al. statically transform untrusted programs into policy-enforcing programs to further reduce the amount of data to be tracked dynamically [61]. Jee et al. statically separate the taint tracking logic from the program logic and then optimize it using abstract taint flow algebra [16]. Hybrid systems have also coalesced taint checks through static analysis [4], [42]. While these traditional hybrid analyses use sound static analysis to conservatively reduce dynamic overheads, Iodine further improves runtime overheads with the use of unsound, predicated static analysis. Iodine’s use of optimistic hybrid analysis with forward recovery could likely be combined with these systems for further taint optimizations.

- **Blended Analysis**: Blended analysis [62] uses dynamic information to improve the accuracy of a best-effort static taint checking tool for JavaScript applications [63]. While they utilize dynamic information to make static analysis tractable for corner-case dynamic language features (e.g., eval), our likely invariants capture common program behaviors to improve whole-program static analysis. Moreover, their end goal is just to improve static analysis, and they do not provide soundness or completeness guarantees for any results produced. Iodine produces sound and complete dynamic analysis for live executions.

- **Profile-Guided Compiler Optimizations**: Profile-guided optimizations [64], [65] learn invariants through profiling and use them for local optimizations. In particular, work on JIT optimizing compilers, such as those that speculatively inline functions [66] or speculatively convert indirect function calls to direct function calls [67], speculatively optimize execution, as done in Iodine. Our work differs in two key ways. First, while compiler optimizations focus on optimizing program logic, Iodine aims at eliding unnecessary runtime DIFT monitors. A more fundamental difference is that Iodine uses invariants to improve precision and scalability of whole-program static analysis. In contrast, profile-guided optimizations do not typically consider whole-program static analysis, and therefore the methods for checking invariants and recovery are simpler and cheaper than optimistic hybrid analysis.

### Conclusion

We presented a novel optimistic hybrid analysis (OHA) technique to optimize DIFT. We solved a key challenge that limits applying OHA to online analyses on live executions—rollback recovery. By restricting our predicated static analysis optimizations to noop safe elisions, we eliminated the need for rollbacks. Iodine significantly improves the precision of static data-flow and pointer analysis, thereby drastically reducing DIFT overhead for important security policies to 9%.

### Acknowledgment

We thank the anonymous reviewers and our shepherd, Deian Stefan, for their thoughtful comments. This work was supported by the National Science Foundation under grants SHF-1527301 and SHF-1703931. The views and conclusions contained in this paper are solely those of the authors.