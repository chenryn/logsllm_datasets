1 
Adam Donenfeld 
STUMPING THE 
MOBILE CHIPSET 
New 0days from down under 
AGENDA 
• Android chipsets overview in ecosystem 
• Qualcomm chipset subsystem’s overview 
• New kernel vulnerabilities 
• Exploitation of a new kernel vulnerability 
• Conclusions 
~ $ man Adam 
ADAM DONENFELD 
• Years of experience in research (both PC and mobile). 
• Vulnerability assessment 
• Vulnerability exploitation 
• Senior security researcher at Check Point 
• In meiner Freizeit, lerne ich Deutsch gern  
4 
How Android gets to your device 
OEM 
Chipset code 
Android Project 
Linux Kernel 
Carrier 
5 
Qualcomm’s chipset subsystems 
[Protected] Non-confidential content 
Qualcomm 
IPC Router 
GPU 
Thermal 
QSEECOM 
Performance 
Audio 
6 
The Rooting Zoo 
7 
ASHmenian Devil (ashmem vulnerability) 
CVE-2016-5340 
●Qualcomm ‘expands’ ashmem for the GPU 
 Map ashmem to GPU 
●Passing ashmem fd to map 
8 
ASHmenian devil (ashmem vulnerability) 
9 
ASHmenian devil (ashmem vulnerability) 
●Qualcomm ‘expands’ ashmem for the GPU 
 Map ashmem to GPU 
●Passing ashmem fd to map 
●Is our fd an ashmem file descriptor? 
10 
ASHmenian devil (ashmem vulnerability) 
●Qualcomm ‘expands’ ashmem for the GPU 
●Map ashmem to GPU 
●Passing ashmem fd to map 
●Is the fd an ashmem fd? 
11 
ASHmenian devil (ashmem vulnerability) 
●Qualcomm ‘expands’ ashmem for the GPU 
●Map ashmem to GPU 
●Passing ashmem fd to map 
12 
ASHmenian devil – PoC 
●Filename on root path == “ashmem” 
●/ is read-only  
●/sdcard is a symlink 
●Obb (Opaque Binary Blob) 
13 
ASHmenian devil – PoC 
●Create an OBB 
 With “ashmem” in it’s root directory 
●Mount the OBB 
●Map “ashmem” memory to the GPU 
 Pass a fd to your fake ashmem file 
14 
Qualaroot (IPC Router vulnerability) 
CVE-2016-2059 
●Qualcomm’s IPC router 
●Special socket family 
 AF_MSM_IPC (27) 
●Unique features 
 “Whitelist” for services that are permitted to communicate 
 Everyone gets an “address” for communication 
 Creation\destruction can be monitored by anyone 
●Requires no permission  
15 
Qualaroot 
●AF_MSM_IPC socket types 
●CLIENT_PORT 
●SERVER_PORT 
●IRSC_PORT 
●CONTROL_PORT 
 Conversion via IPC_ROUTER_IOCTL_BIND_CONTROL_PORT 
●Each new socket is a CLIENT_PORT socket 
16 
Qualaroot 
17 
18 
Client list 
Control list 
Client list 
Control list 
19 
Client list 
Control list 
Client list 
Control list 
20 
Qualaroot – the vulnerability 
●control_ports list is modified without lock! 
●Deleting 2 objects from control_ports 
simultaneously! 
RACE CONDITION 
21 
Qualaroot - implementation 
control_ports 
A 
B 
C 
POISON 
22 
Qualaroot - implementation 
control_ports 
A 
B 
C 
entry = A 
next = B 
prev = control_ports 
B->prev = control_ports 
POISON 
23 
Qualaroot - implementation 
entry = A 
Next = B 
Prev = control_ports 
B->prev = control_ports 
POISON 
control_ports 
A 
B 
C 
24 
Qualaroot - implementation 
25 
Qualaroot - implementation 
entry = B 
Next = C 
Prev = control_ports 
C->prev = control_ports 
POISON 
control_ports 
A 
B 
C 
26 
Qualaroot - implementation 
entry = B 
Next = C 
Prev = control_ports 
C->prev = control_ports 
POISON 
control_ports 
A 
B 
C 
27 
Qualaroot - implementation 
entry = B 
Next = C 
Prev = control_ports 
control_ports->next = C 
POISON 
control_ports 
A 
B 
C 
28 
Qualaroot - implementation 
entry = B 
Next = C 
Prev = control_ports 
control_ports->next = C 
POISON 
control_ports 
A 
B 
C 
29 
Qualaroot - implementation 
entry = B 
Next = C 
Prev = control_ports 
entry is freed 
next = prev = LIST_POISON 
POISON 
control_ports 
A 
B 
C 
30 
Qualaroot - implementation 
entry = B 
Next = C 
Prev = control_ports 
entry is freed 
next = prev = LIST_POISON 
POISON 
control_ports 
A 
C 
B 
31 
Qualaroot - implementation 
32 
Qualaroot - implementation 
entry = A 
Next = B 
Prev = control_ports 
control_ports->next = B 
POISON 
control_ports 
A 
C 
B 
33 
Qualaroot - implementation 
entry = A 
Next = B 
Prev = control_ports 
control_ports->next = B 
POISON 
control_ports 
A 
C 
B 
34 
Qualaroot - implementation 
entry = A 
Next = B 
Prev = control_ports 
entry is freed 
next = prev = LIST_POISON 
POISON 
control_ports 
A 
C 
B 
35 
Qualaroot - implementation 
entry = A 
Next = B 
Prev = control_ports 
entry is freed 
next = prev = LIST_POISON 
POISON 
control_ports 
A 
C 
B 
36 
Qualaroot - implementation 
●Two following objects are deleted 
 Simultaneously! 
●control_ports points to a FREE data 
 LIST_POISON worked 
 No longer mappable 
 Spraying af_unix_dgram works 
●Iterations on control_ports? 
 Just close a client_port! 
 Notification to all control_ports with post_pkt_to_port 
37 
Qualaroot - implementation 
●UAF in control_ports 
●We can fake msm_ipc_port using 
LIST_POISON* 
●Iterations on control_ports? 
●Just close a client_port! 
●Notification to all control_ports with 
post_pkt_to_port 
38 
Qualaroot - implementation 
●wake_up function 
 Macros to __wake_up_common 
39 
Qualaroot - implementation 
●wake_up function 
●Macros to __wake_up_common 
40 
Qualaroot - implementation 
●wake_up function 
 Macros to __wake_up_common 
●New primitive! 
 Call to function with first controllable param! 
 We can’t control the address though  
●Not good enough for commit_creds… 
41 
Qualaroot - implementation 
●Upgrade primitives 
●Find a function that can call an arbitrary 
function with address-controlled parameters 
42 
Qualaroot - implementation 
●usb_read_done_work_fn receives a function 
pointer and a function argument! 
43 
Qualaroot - implementation 
44 
Qualaroot - implementation 
●Chain function calls 
 __wake_up_common 
 usb_read_done_work_fn 
 any function 
45 
Qualaroot – Exploitation flow 
Create UAF situation using the vulnerability 
46 
Qualaroot – Exploitation flow 
LIST_POISON 
UAF 
Spray af_unix_dgrams to catch the UAF 
47 
Qualaroot – Exploitation flow 
Spray af_unix_dgrams to catch the UAF 
LIST_POISON 
UAF 
sprayed 
Trigger list iteration 
48 
Qualaroot – Exploitation flow 
Trigger list iteration 
__wake_up_common 
UAF->port_rx_wait_q->task_list 
usb_read_work_done_fn 
qdisc_list_del 
control_ports is empty 
usb_read_work_done_fn 
enforcing_setup 
SELinux is permissive 
usb_read_work_done_fn 
commit_creds 
UID=0; 
cap = FULL_CAP_SET 
sprayed 
49 
Qualaroot 
50 
Disclosure 
51 
52 
53 
DEMO 
54 
Syncockaroot (syncsource vulnerability) 
CVE-2016-2503 
●SyncSource objects are used to 
synchronize the activity between the GPU 
and the application. 
●Can be created using IOCTLs to the GPU 
 IOCTL_KGSL_SYNCSOURCE_CREATE 
 IOCTL_KGSL_SYNCSOURCE_DESTROY 
●Referenced further with the “idr” 
mechanism 
55 
Syncockaroot (syncsource vulnerability) 
Any lock on “to-be-destroyed” object? 
56 
Syncockaroot - PoC 
●Create a syncsource object 
 A predictable idr number is allocated 
●Create 2 threads constantly destroying the 
same idr number 
●Ref-count will be reduced to -1 
 Right after getting to zero, we can spray it 
Use After Free  
57 
KanGaroot (KGsl vulnerability) 
CVE-2016-2504 
●GPU main module (kgsl-3d0) 
●Map user memory to the GPU 
 IOCTL_KGSL_MAP_USER_MEM 
 IOCTL_KGSL_GPUMEM_FREE_ID 
●Referenced by a predictable ID 
 IDR mechanism 
58 
KanGaroot (KGsl vulnerability) 
Should it already be accessible here? 
59 
KanGaroot (KGsl vulnerability) 
●GPU main module (kgsl-3d0) 
●Map user memory to the GPU 
 IOCTL_KGSL_MAP_USER_MEM 
 IOCTL_KGSL_GPUMEM_FREE_ID 
●Referenced by a predictable ID 
 IDR mechanism 
●No locks! 
 Free can be called before map ends 
60 
KanGaroot - PoC 
●Map memory 
●Save the IDR 
 We always get the first free IDR -- predictable 
●Another thread frees the object with IDR 
 *Before the first thread returns from the IOCTL 
UAF in kgsl_mem_entry_attach_process on 
‘entry’ parameter 
Suggestions/Special thanks 
commit_creds for always being there for me 
 Absense of kASLR,  
for not breaking me and commit_creds apart 
SELinux, for being liberal, 
letting anyone access mechanisms like Qualcomm’s IPC 
62 
Thank You!