出时实时进程时将
超出操作。
页相的。对的方
: 。然提能单进程
以 Linux  — 单的操作能满。的
– 198 –
 6 
进程理
处理以或实时进程。实效上
实时进程离。
操作进程 CPU 的调。的对实时进程
的实时进程处理的处理进程。
单的方 Linux 的 init 程 SysVinit∗, 以
的作:
cpu_set_t set;
int ret;
CPU_ZERO (&set); /* clear all CPUs */
ret = sched_getaffinity (0, sizeof (cpu_set_t),
&set);
if (ret == -1) {
perror (”sched_getaffinity”);
return 1;
}
CPU_CLR (1, &set); /* forbid CPU #1 */
ret = sched_setaffinity (0, sizeof (cpu_set_t),
&set);
if (ret == -1) {
perror (”sched_setaffinity”);
return 1;
}
的处理集我们处理。然出
处理 CPU #1更新处理集。
处理集子进程间 init 进程的以
的进程的处理集 CPU #1 上将何进程。
实时程 CPU #1 上:
cpu_set_t set;
int ret;
∗SysVinit     以  ftp://ftp.cistron.nl/pub/people/miquels/sysvinit/  以 GNU General
Public License v2 
– 199 –
 6 
进程理
CPU_ZERO (&set); /* clear all CPUs */
CPU_SET (1, &set); /* allow CPU #1 */
ret = sched_setaffinity (0, sizeof (cpu_set_t),
&set);
if (ret == -1) {
perror (”sched_setaffinity”);
return 1;
}
实时进程 CPU #1 上的进程处
理。
6.6 资源限制
Linux 内对进程的进程以的内的
上文件的内存页处理的。性
的内进程的超性。文件的操作
进程的文件超出 open() 调†。
Linux 提操作的调。 POSIX 的调
Linux  getlimit()  setlimit() 设:
#include 
#include 
struct rlimit {
rlim_t rlim_cur; /* soft limit */
rlim_t rlim_max; /* hard limit */
};
int getrlimit (int resource, struct rlimit *rlim);
int setrlimit (int resource, const struct rlimit
*rlim);
     RLIMIT CPU 的      示   rlimit    示 实 
 。       上 :       。内  对 进 程      
†时调设 EMFILE进程文件上。 Chapter 2  open()
调
– 200 –
 6 
进程理
进程自以以 0 间的。备
CAP SYS RESOURCE 能的进程 ( root 进程)能调。
程能提的的调
的。进程以设。
的相。 RLIMIT FSIZE示进程以
的文件单。时 rlim cur  1024进程以
 1K 的文件能扩展文件 1k 以上。
的: 0 。示
RLIMIT CORE  0内内存文件。相示存对
的。内 RLIM INFINITY 示 -1 (能
调 -1 相)。 RLIMIT CORE 内以
小的内存文件。
 getrlimit()  rlim 的 resource 的。
 0 -1设。
相对的 setrlimit()  rlim 的设 resource 的。
 0内更新对的 -1设。
6.6.1 限制列表
 Linux 提 15 :
• RLIMIT AS
进程空间上单。空间小超 — 调
mmap()  brk()  —  ENOMEM。进程的自超
内将给进程 SIGSEGV 。的 RLIM INFINITY。
• RLIMIT CORE
内存文件小的单。 0超出的内存文件
将小 0将文件。
• RLIMIT CPU
进程以的 CPU 时间单。进程时间超出
将处理内出的 SIGXCPU 。程
时 POSIX 内的步作。进程然
 Linux 进程给进程 SIGXCPU 。
进程将 SIGKILL 。
– 201 –
 6 
进程理
• RLIMIT DATA
进程段的小单。 brk() 扩段以超出
将 ENOMEM。
• RLIMIT FSIZE
文件以的文件单。进程扩展文件超出内
将 SIGXFSZ 。将进程。进程以
调 EFBIG 时自处理。
• RLIMIT LOCKS
进程以的文件的 (文件的)。
何的 ENOLCK。 Linux 2.4.25 内
能内以设何作。
• RLIMIT MEMLOCK
 CAP SYS IPC 能的进程 ( root 进程)  mlock() mlockall() 或
shmctl() 能   的   内 存 的   。 超    的 时 调     
EPERM。实上实内存页。 CAP SYS IPC 能
的进程以的内存页效。 2.6.9 内
作 CAP SYS IPC 能的进程进程能内存页。
属 POSIX  BSD 。
• RLIMIT MSGQUEUE
以 POSIX 的。新的超出
mp open()  ENOMEM。属 POSIX  2.6.8 内
 Linux 。
• RLIMIT NICE
进程以 nice  (提) 的。文进程能
提 ()。理进程以提
的。 nice 能内 20 − rlim cur 示。
设 40进程 -20()。 2.6.12 内
。
• RLIMIT NOFILE
进程以的文件。何超出的
EMFILE。 BSD  RLIMIT OFILE。
• RLIMIT NPROC
– 202 –
 6 
进程理
时的进程。何超出的 fork() 
EAGAIN。属 POSIX BSD 。
• RLIMIT RSS
进程以内存的页 (即集小 RSS)。的 2.4 内
内设。属 POSIX BSD
。
• RLIMIT RTPRIO
 CAP SYS NICE 能的进程以的实时。进
程实时调。属 POSIX 2.6.12 内 Linux 
。
• RLIMIT SIGPENDING
。更的将 sigqueue() 的调
将 EAGAIN。以将的实
. 以进程 SIGKILL  SIGTERM 。
属 POSIX Linux 。
• RLIMIT STACK
的。超出将 SIGSEGV 。
内以进程单理。子进程 fork 的时进程
 exec 进。
6.6.1.1 默认限制
: 理。内
。内 init 进程设
子进程间的给的子进程。
– 203 –
 6 
进程理
Resource limit
Soft limit
Hard limit
RLIMIT AS
RLIM INFINITY
RLIM INFINITY
RLIMIT CORE
0
RLIM INFINITY
RLIMIT CPU
RLIM INFINITY
RLIM INFINITY
RLIMIT DATA
RLIM INFINITY
RLIM INFINITY
RLIMIT FSIZE
RLIM INFINITY
RLIM INFINITY
RLIMIT LOCKS
RLIM INFINITY
RLIM INFINITY
RLIMIT MEMLOCK
8 pages
8 pages
RLIMIT MSGQUEUE
800 KB
800KB
RLIMIT NICE
0
0
RLIMIT NOFILE
1024
1024
RLIMIT NPROC
0 (implies no limit)
0 (implies no limit)
RLIMIT RSS
RLIM INFINITY
RLIM INFINITY
RLIMIT RTPRIO
0
0
RLIMIT SIGPENDING
0
0
RLIMIT STACK
8 MB
RLIM INFINITY
以:
• 何进程以 0 的内以
子进程以 fork 。
• 进程以设子进程同以 fork 
。
进程的 root 进程能何
更能的原。实上对进程的 shell
设理以进设提的。 Bourne-again
shell(bash) 理以 ulimit 设。理以
以提给提更理的。
 RLIMIT STACK(上设 RLIM INFINITY) 进处理。
6.6.2 获取和设置资源限制
我们设。
单:
– 204 –
 6 
进程理
struct rlimit rlim;
int ret;
/* get the limit on core sizes */
ret = getrlimit (RLIMIT_CORE, &rlim);
if (ret == -1) {
perror (”getrlimit”);
return 1;
}
printf (”RLIMIT_CORE limits: soft=%ld hard=%ld\n”,
rlim.rlim_cur, rlim.rlim_max);
然将:
RLIMIT_CORE limits: soft=0 hard=-1
以 0 -1(-1 )。我们以设
。的子设内存文件 32MB:
struct rlimit rlim;
int ret;
rlim.rlim_cur = 32 * 1024 * 1024; /* 32 MB */
rlim.rlim_max = RLIM_INFINITY; /* leave it alone
*/
ret = setrlimit (RLIMIT_CORE, &rlim);
if (ret == -1) {
perror (”setrlimit”);
return 1;
}
6.6.2.1 错误码
能:
EFAULT rlim 的内存或。
EINVAL resource 的或 rlim.rlim cur 的 rlim.rlim max(
setrlimit())。
– 205 –
 6 
进程理
EPERM
调 CAP SYS RESOURCE 能提。
– 206 –
 7 
文件理
第 7 章
文件与目录管理
 2 3 以及 4 我们给出文件 I/O 的方调。
我们上的文件读写操作
理文件及。
7.1 文件及其元数据
我们 1 的文件对 inode文件
（ inode 。 inode  unix 文件的理对
 Linux 内的实。 inode 存文件的
文件的时间小以及文件
的存。
能 ls 的 -i 文件 inode 
$ ls -i
1689459 Kconfig
1689461 main.c
1680144 process.c
1689464 swsusp.c
1680137 Makefile
1680141 pm.c
1680145 smp.c
1680149 user.c
1680138 console.c
1689462 power.h
1689463 snapshot.c
1689460 disk.c
1680143 poweroff.c
1680147 swap.c
出示文件 disk.c 的 inode  1689460。文件
何文件 inode  (inode number)。文件
我们能同的 inode 。
7.1.1 一组 stat 函数
Unix 提文件的
#include 
#include 
#include 
int stat (const char *path, struct stat *buf);
int fstat (int fd, struct stat *buf);
int lstat (const char *path, struct stat *buf);
– 207 –
 7 
文件理
文件的。 stat()  path 的文件
 fstat() 文件 fd 的文件。 lstat()  stat() 
对 lstat() 文件。
 stat 存的文件。 stat  
真的  的
struct stat {
dev_t st_dev; /* ID of device containing file */
ino_t st_ino; /* inode number */
mode_t st_mode; /* permissions */
nlink_t st_nlink; /* number of hard links */
uid_t st_uid; /* user ID of owner */
gid_t st_gid; /* group ID of owner */
dev_t st_rdev; /* device ID (if special file) */
off_t st_size; /* total size in bytes */
blksize_t st_blksize; /* blocksize for
filesystem I/O */
blkcnt_t st_blocks; /* number of blocks
allocated */
time_t st_atime; /* last access time */
time_t st_mtime; /* last modification time */
time_t st_ctime; /* last status change time */
};
对段的
• 段 st dev 文件设备上（我们将设
备。文件设备上文件文件 (NFS)
上 0。
• 段 st ino 文件的 inode 。
• 段 st mode 文件的段。 1  2 
的内。
• 段 st nlink 文件的。文件。
• 段 st uid 文件的 ID。
– 208 –
 7 
文件理
• 段 st gid 文件属 ID。
• 文件设备段 st rdev 设备。
• 段 st size 提文件。
• 段 st blksize 进效文件 I/O 的小。（或
 I/O 的小（ 3 。
• 段 st blocks 给文件的。文件时（文件
文件将小 st size 。
• 段 st atime 文件时间。文件的时间（
 read() 或 execle()。
• 段 st mtime 文件时间文件写的
时间。
• 段 st ctime 文件时间。段
Linux 或 Unix 的文件时间。段实上的文件的
（文件或的时间。
时调 0将文件存 stat 。
时们 -1设 errno
EACCESS
调的进程对 path 的的的
（ stat()  lstat()。
EBADF
效的 fd（ fstat()。
EFAULT
效的 path 或 buf 。
ELOOP
path （ stat()  lstat()。
ENAMETOOLONG  (path) （ stat()  lstat()。
ENOENT
path  的     或  文 件  存 （    stat() 
lstat()。
ENOMEM
内存。
ENOTDIR
path 的（ stat()  lstat()。
程 stat() 文件 (文件) 的小
#include 
#include 
#include 
#include 
– 209 –
 7 
文件理
int main (int argc, char *argv[])
{
struct stat sb;
int ret;
if (argc \n”,
argv[0]);
return 1;
}
ret = stat (argv[1], &sb);
if (ret) {
perror (”stat”);
return 1;
}
printf (”%s is %ld bytes\n”, argv[1],
sb.st_size);
return 0;
}
程自文件上的
$ ./stat stat.c
stat.c is 392 bytes
以段 fstat() 的文件理（或相对
的设备上
/*