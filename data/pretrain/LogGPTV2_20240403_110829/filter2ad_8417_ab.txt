以太坊有三种类型的空间可以用于存储操作数据，EVM 虚拟机可以直接操作这些类型。
· 堆栈：一种后进先出的容器，执行完毕后数据就会被清除。
· 内存：一种可以无限扩展的字节数组，执行完毕后数据就会被清除。
· 合约的持久化存储：一种键-值对，它区别于堆栈和内存，它存储的内容会长期保存。
来看一个具体的示例，方便理解 evm 虚拟机的执行过程。
    pragma solidity ^0.5.0;
    contract simple {
        uint num = 0;
        constructor() public {
            num = 123;
        }
        function add(uint i) public returns(uint){
            uint m = 111;
            num =num * i+m;
            return num;
        }
    }
编译后的内容过长，节选函数实现部分。
    JUMPDEST            function add(uint i) public re...
          //这下面就是函数的代码了
          PUSH 0            uint //局部变量在栈里面
          DUP1          uint m
          PUSH 6F           111
          SWAP1             uint m = 111
          POP           uint m = 111 //从push0到这里实现了定义局部变量并赋值
          DUP1          m
          DUP4          i            //获取参数
          PUSH 0            num
          SLOAD             num      //上面那句和这句实现了读取成员变量
          MUL           num * i      //乘
          ADD           num * i+m    //加
          PUSH 0            num
          DUP2          num =num * i+m
          SWAP1             num =num * i+m   //这三句赋值
          SSTORE            num =num * i+m   //成员变量存储
          POP           num =num * i+m
          //下面几句实现return
          PUSH 0            num
          SLOAD             num
          SWAP2             return num    
          POP           return num
          POP           function add(uint i) public re...
          SWAP2             function add(uint i) public re...
          SWAP1             function add(uint i) public re...
          POP           function add(uint i) public re...
          JUMP [out]            function add(uint i) public re...
栈的变化如下图所示，原图有一些错误，已用红色更正。
部分指令操作如下：
· POP指令：从栈顶弹出一个元素。
· PUSHx：PUSH系列指令把紧跟在指令后面的N（1 ～ 32）字节元素推入栈顶。
· DUPx： DUP系列指令复制从栈顶开始数的第N（1 ～ 16）个元素，并把复制后的元素推入栈顶。
· SWAPx：SWAP系列指令把栈顶元素和从栈顶开始数的第N（1 ～ 16）+ 1 个元素进行交换。
· SSTORE：从栈顶弹出 2 个元素，栈顶元素为 key，次顶元素为 value，存储到 storage 空间。
· SLOAD：先取出栈顶元素x，然后在storage中取以x为键的值（storage[x]）存入栈顶。
更多指令的解读可以参考Ethereum Virtual Machine Opcodes。
**Ethereum WebAssembly (ewasm)**
除了 EVM，以太坊社区还在积极开发 eWASM 虚拟机。eWASM 使用了 WebAssembly
的一个子集。使用WebAssembly作为智能合约的格式可获得多种好处，下面列出了其中的一些：
· 达到近乎本地的执行速度
· 可以使用许多传统编程语言（例如C，C ++和Rust）
· 能利用庞大的开发人员社区和WebAssembly周围的工具链
更多内容留给读者自己探索。
## 2.3 EOS 平台的智能合约
EOS（Enterprise Operation
System），企业操作系统，是为企业级分布式应用设计的一款区块链操作系统。相比于比特币、以太坊平台性能低、开发难度大以及手续费高等问题，EOS拥有高性能处理能力、易于开发以及用户免费等优势，极大的满足企业级的应用需求，被誉为继比特币、以太坊之后区块链
3.0 技术。
为什么EOS性能高？这要得益于他的共识算法的设计。想知道他的共识算法？欢迎关注后续文章。
要了解如何部署和运行 EOS 合约需要先了解 EOS 系统的组成部分。如下图所示：
图片来自 EOS 官网
EOS 系统主要由以下几个部分组成：
· cleos（cli+eos=Cleos）:本地的命令行工具，用户通过命令行与节点（nodeos）的 REST
接口通信。是用户或者开发者与节点进程交互的桥梁。
· keosd（key + eos = Keosd）：本地钱包工具。非节点用户存储钱包的进程，可以管理多个含有私钥的钱包并加密。
· nodeos（Node + eos=Nodes）： EOS
系统的核心进程，也就是所谓的“节点”。主要是生产节点，一般用户可以不用启动，运行时可以配置插件。本地节点启动时，配置的插件情况如下：
    nodeos -e -p eosio
    --plugin eosio::producer_plugin
    --plugin eosio::chain_api_plugin
    --plugin eosio::http_plugin
    --plugin eosio::history_plugin
    --plugin eosio::history_api_plugin
    --filter-on="*"
    --access-control-allow-origin='*'
    --contracts-console
    --http-validate-host=false
    --verbose-http-errors
上述命令所使用的插件有：
· producer_plugin（生产节点插件）：生产节点必须使用这个插件，普通节点不需要。
· chain_api_plugin（区块链接口插件）：提供区块链数据接口。
· http_plugin（http 插件）：提供 http 接口。
· history_plugin ：可以获取历史数据。
· history_api_plugin ：给 history_plugin 插件提供接口。
· wallet_plugin（钱包插件）：使用这个插件就可以省去 keosd 钱包工具。
· wallet_api_plugin（钱包接口插件）：给钱包插件提供接口。
更多命令行参数请参考EOSIO 开发者文档。
### **2.3.1 开发智能合约**
EOS 平台目前主要的合约开发语言是 C/C， 尽管可以用C开发，但是社区在主推 EOS.IO C API，它提供了更强大的类型安全性，且更易于阅读。
一个简单的 hello world 合约如下：
    #include 
    using namespace eosio;
    class [[eosio::contract]] hello : public contract {
      public:
          using contract::contract;
          [[eosio::action]]
          void hi( name user ) {
             require_auth(user);
             print( "Hello, ", user);
          }
    };
EOSIO智能合约由一组 Action 和类型定义组成。 Action 指定并实现合约的行为。
类型定义指定所需的内容和结构。开发合约时要对每一个action 实现对应的 action handler，如示例中 hi 函数就是 hi action 的
handler。action handler 的参数指定了接收的参数类型和数量。当向此合约发送 action 时，要发送满足要求的参数。
#### **2.3.1.1 Action**
EOSIO Action 主要在基于消息的通信体系结构中运行。 客户端可以使用 cleos 命令，将消息发送（推送）到 nodeos 来调用
Action。也可以使用 EOSIO send 方法（例如eosio :: action :: send）来调用 Action。 nodeos 将
Action 请求分发给合约的 WASM 代码。 该代码完整地运行完，然后继续处理下一个 Action。
**Transactions VS. Actions**
Action 代表单个操作，交易是一个或多个 Action 的集合。合约和账户以 Action 的形式通信，Action 可以单独发送，即一个交易只有一个
Action，也可以捆绑在一起发送，即一个交易包涵一组 Action。
包含一个 Action 的交易结构如下:
    {
      "expiration": "2018-04-01T15:20:44",
      "region": 0,
      "ref_block_num": 42580,
      "ref_block_prefix": 3987474256,
      "net_usage_words": 21,
      "kcpu_usage": 1000,
      "delay_sec": 0,
      "context_free_actions": [],
      "actions": [{
          "account": "eosio.token",
          "name": "issue",
          "authorization": [{
              "actor": "eosio",
              "permission": "active"
            }
          ],
          "data": "00000000007015d640420f000000000004454f5300000000046d656d6f"
        }
      ],
      "signatures": [
        ""