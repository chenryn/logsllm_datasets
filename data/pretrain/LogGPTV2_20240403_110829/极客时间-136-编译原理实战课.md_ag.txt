# 02 词法分析：用两种方式构造有限自动机

你好，我是宫文学。在上一讲中，我们整体回顾了编译过程的各个步骤、每个环节的作用及其背后的原理。这不仅帮助你理解编译过程的整体框架，还能让你熟悉一些专有名词，从而更顺畅地阅读相关资料。虽然编译过程中涉及的算法和理论可能有些枯燥，但我将尽量以通俗易懂的方式进行讲解。

本讲我们将深入探讨词法分析（Lexical Analysis）这一环节。通过本节课的学习，你将掌握如何将输入字符串识别为一个个Token，并学习如何实现一个正则表达式工具，进而能够解析任意的词法规则。

## 词法分析的原理

首先，我们需要明确词法分析的任务：将输入的字符串转换成一系列Token。因此，词法分析器在英文中通常被称为Tokenizer。例如，在处理一段代码时，空白字符（包括空格、制表符、回车和换行符）以及文件结束符EOF会被识别出来，并与实际的Token区分开来。

为了实现这一过程，我们需要引入一种计算模型——**有限自动机**（Finite-state Automaton, FSA），也称作有限状态机（Finite-state Machine, FSM）。这个概念对于大多数程序员来说并不陌生，因为它广泛应用于各种状态迁移场景中，比如电商系统中的订单状态管理就是一个典型的状态机实例。

### 有限自动机

有限自动机本质上是一种具有有限数量状态的状态机。每当它接收到一个新的字符时，会根据当前状态及该字符触发相应的状态迁移。以下是一个简单的有限自动机示例，它可以用来区分标识符和数字字面量：

- 状态 0：初始状态
- 状态 1：识别到数字字面量
- 状态 2：识别到标识符

当遇到空白字符时，如果当前处于状态 1 或状态 2，则记录下对应的Token并返回至初始状态（状态 0），准备开始新的识别过程。

由此可见，词法分析的过程实际上是对字符串进行模式匹配的过程。提到模式匹配，大家自然会想到**正则表达式**这一强大工具。许多编程语言和操作系统命令都内置了正则表达式功能，用于匹配特定格式的字符串。例如，Linux 中的一个简单命令 `ps -ef | grep 's[a-h]'` 可以用来查找所有包含 "sa" 至 "sh" 字符串的进程。

同样地，正则表达式也可以用来描述词法规则，这种描述方法称为**正则文法**。例如，数字字面量和标识符可以分别表示为：
- IntLiteral: [0-9]+; // 至少包含一个数字
- Id: [A-Za-z][A-Za-z0-9]*; // 以字母开头，后跟任意数量的字母或数字

然而，在实际应用中，当我们使用多条词法规则时可能会遇到规则冲突的情况。比如，关键字 "int" 同样符合标识符的定义。为此，我们需要设定优先级规则，通常是按照规则出现的顺序来决定优先级。这样，我们就能设计出能够区分 "int" 关键字和普通标识符的有限自动机。

## 从正则表达式生成有限自动机

了解了如何手动构建有限自动机之后，你可能会想是否可以直接根据给定的词法规则自动生成相应的有限自动机？答案是肯定的。事实上，现有的正则表达式引擎和词法分析器生成工具如lex（及其GNU版本flex）就是基于这一思路工作的。

它们的具体实现步骤如下：
1. 将正则表达式翻译成非确定性有限自动机（NFA）。
2. 再将NFA转换为确定性有限自动机（DFA）。

这里再次引入了两个新术语：NFA 和 DFA。
- **DFA** (Deterministic Finite Automaton) 是确定性的有限自动机。其特点是：在任何状态下，基于输入字符都能做出唯一确定的状态转移。
- **NFA** (Nondeterministic Finite Automaton) 则是非确定性的有限自动机。它的特点在于某些状态下可能存在多种可能的转移路径，甚至在没有输入的情况下也能发生状态变化（ε 转移）。

通过一系列标准化的操作，我们可以将任意给定的正则表达式转换为NFA，再进一步转化为DFA。这样就实现了从正则表达式到可执行程序的自动化生成流程，这也是许多现代开发工具背后的基本工作原理之一。

## 实践练习

最后，我建议你尝试自己编写一套规则，用于识别整型和浮点型数值，并手工绘制出相应的有限自动机图。欢迎在评论区分享你的经验和心得！

参考资料：
- _Compilers - Principles, Techniques & Tools_ (龙书，第 2 版)，第 3.7.1 节
- 《编译原理之美》第 16 讲