CGI application.
T1-mod: The same test as T1-cgi, except that PHP was running as an Apache2
module.
module.
T2-cgi: Requesting the webpage phpBB2/profile.php?mode=editprofile&sid=,
containing the content of one forum with a valid session ID. This test in-
volved several database reads and complex output formatting with many
string operations (creating a complex form with user-supplied data). PHP
was running as a CGI application.
T2-mod: The same test as T2-cgi, except that PHP was running as an Apache2
T3-CLI: This test was the standard PHP test (script run-tests.php) included
in PHP source code. This test runs tests designed by the PHP-platform
142
T. Pietraszek and C. Vanden Berghe
Table 2. Run-time overhead evaluation: execution time for diﬀerent tests. Errors shown
are 95% conﬁdence intervals with sample size 500 (20 for the last column).
Test Name
T1 (phpbb2 get)
T2 (phpbb2 get)
Type
Unpatched
CSSE disabled
CSSE enabled
CGI
ms
61.67 ± 0.23
62.22 ± 0.24
66.42 ± 0.29
ms
ms
ms
mod apache
61.12 ± 0.28
62.85 ± 0.29
71.54 ± 0.37
ms
ms
CGI
ms
58.59 ± 0.07
58.85 ± 0.06
61.29 ± 0.07
ms
ms
ms
mod apache
57.87 ± 0.07
59.41 ± 0.08
66.63 ± 0.09
ms
ms
T3 (PHP
tests)
CLI
s
21.19 ± 0.06
21.28 ± 0.05
21.67 ± 0.07
s
s
developers to test the correctness of PHP1. Note that these tests do not
involve a web-server and are usually not I/O intensive, therefore the expected
impact of CSSE should be lower than with T1 and T2.
The results obtained are shown in Table 2. Tests T1-cgi, T1-mod, T2-cgi, T2-mod
were executed 600 times of which the ﬁrst 100 times were discarded to prevent
caching artifacts. The timings were calculated by the Apache server. Because of
the long run time, the last test was executed only 20 times. The table also shows
95% conﬁdence intervals for each set of experiments. All measurements were done
on a single machine with a Pentium M processor running at 1.7 GHz, 1 GB of
RAM, running Linux 2.6.8. We tested PHP in the following three conﬁgurations:
Unpatched: Normal PHP source code, compiled with the standard options.
CSSE disabled: PHP was patched to include CSSE; however, CSSE was dis-
abled by the run-time conﬁguration option. The overhead is checking the
state of a PHP global conﬁguration ﬂag in each of the modiﬁed methods.
CSSE enabled: PHP was patched to include CSSE, and CSSE was enabled.
Note that the tests produced identical output in all three conﬁgurations, vary-
ing only in execution time.
6.4 Run-Time Overhead
We observed that the total run-time overhead does not exceed 8% of the total
run time if PHP runs as a CGI application and is surprisingly higher, namely,
17%, if PHP runs as an Apache2 module. This is shown in Figure 3, where
black bars represent the execution time of an unpatched PHP, grey bars show
the overhead with CSSE disabled, and light grey bars indicate the overhead of
CSSE. As expected, the performance overhead for non-I/O intensive operations
(the last test with a standalone PHP interpreter), is only around 2% of the total
execution time.
1 In our experiments, 5 out of 581 tests run by run-tests.php failed (not all the
modules were compiled and many other tests were skipped). This was not related to
CSSE, and we obtained the same result with the original PHP code.
Defending Against Injection Attacks Through CSSE
143
It is important to stress that these numbers should be interpreted in the
context of the goals set for our prototype in Section 5. As the prototype is
limited to the most commonly used string operations, our measurements will
underestimate the actual performance impact. However, this underestimation
is very small as the calls of the instrumented string functions account for a
preponderance of the total number of string function calls. Additionally, our
prototype is not optimized for performance and, for example, using an alter-
native metadata representation as zval values would have a positive impact on
performance.
Contrary to our expectations, CSSE overhead was more than 2.5 times higher
when PHP was running as a module, rather than as a CGI application, even with
a simple ﬂag check to determine whether CSSE is enabled. This is most likely due
to some threading issues, resulting in loading the entire run-time conﬁguration
data in each string operation, which can possibly be avoided with more careful
prototype design.
Another interesting observation is that PHP running as an Apache2 module
does not yield any signiﬁcant performance increase in comparison with a CGI
application. We attribute this to our experiment setup, in which the PHP inter-
preter was already cached in the memory and was running only a single task.
During normal operation, Apache2 modules are noticeably faster than CGI.
To conclude, the overall performance overhead is application-dependent. Our
tests suggest that it ranges from 2% for applications with few I/O operations to
around 10% for typical web applications with PHP running with a webserver.
]
s
m
[
i
e
m
T
n
o
i
t
u
c
e
x
E
0
7
0
6
0
5
0
4
0
3
0
2
0
1
0
]
%
[
e
s
a
e
r
c
n
I
i
e
m
T
n
o
i
t
u
c
e
x
E
5
1
0
1
5
0
T1−cgi
T1−mod
T2−cgi
T2−mod
T1−cgi
T1−mod
T2−cgi
T2−mod T3−CLI
Fig. 3. Run-time overhead evaluation: request processing time and the relative increase
for diﬀerent tests. Black bars show total run time, gray bars show the run-time overhead
with CSSE disabled and light gray bars show the overhead with CSSE enabled.
In the current implementation, strings containing at least one untrusted part
consume twice as much memory as do their normal counterparts. To investigate
the memory eﬃciency of CSSE we analyzed the heap allocation of CSSE-enabled
PHP run with tests T1 and T2 using Valgrind [19]. In both cases the impact of
CSSE was at around 2% (40kB increase for a total of ca. 2MB allocated heap).
This is intuitive as only a small amount of memory allocated by PHP is used
for storing PHP variables, only some of which contain strings with user data.
144
T. Pietraszek and C. Vanden Berghe
Obviously, these results are application-dependant, but should be similar for
typical web applications.
As we already mentioned, various optimization techniques can be applied to
reduce this additional memory storage, but this was beyond the scope of our
prototype. Our results show that even with this ineﬃcient implementation the
memory impact is negligible.
7 Conclusions and Future Work
Injection vulnerabilities form an important problem in application-level security.
In this work we identiﬁed the root cause of these vulnerabilities—the ad-hoc se-
rialization of user-provided input. In addition, we provided a unifying view of
injection vulnerabilities, which facilitates reasoning about this class of vulnera-
bilities and allows for the prediction of new types of related vulnerabilities.
Based on our improved understanding, we developed Context-Sensitive String
Evaluation (CSSE), a novel method for defending against injection attacks.
CSSE addresses the root cause of injection vulnerabilities by enforcing strict
channel separation, while still allowing the convenient use of ad-hoc serializa-
tion. CSSE is transparent to the application developer, as the necessary checks
are enforced at the platform level: neither modiﬁcation nor analysis of the ap-
plications is required. As a result, it is advantageous over the two categories of
related solutions: safe ad-hoc serialization and serialization APIs.
CSSE works by an automatic marking of all user-originated data with meta-
data about its origin and ensuring that this metadata is preserved and updated
when operations are performed on the data. The metadata enables a CSSE-
enabled platform to automatically carry out the necessary checks at a very late
stage, namely when the output expressions are ready to be sent to the handling
component. As at this point the complete context of the output expressions is
known, CSSE is able to independently determine and execute the appropriate
checks on the data it previously marked unsafe.
We developed a prototype implementation of CSSE for the PHP platform, and
evaluated it with phpBB, a large real-life application. Our prototype prevented
all known SQL injection attacks, with a performance impact of ca. 10%.
As ongoing work, we are instrumenting the remaining string operations and
output vectors to prevent more sophisticated injection attacks, including XSS
attacks, and evaluate CSSE with other applications. We will also develop an
application-level implementation of CSSE for a platform that supports the
aspect-oriented programming paradigm.
Acknowledgments
Many thanks to Andreas Wespi, Birgit Baum-Waidner, Klaus Julisch, James Ri-
ordan, Axel Tanner and Diego Zamboni of the Global Security Analysis Labora-
tory for the stimulating discussions and feedback. We also thank Frank Piessens
of the Katholieke Universiteit Leuven for his valuable comments on this paper.
Defending Against Injection Attacks Through CSSE
145
References
1. Anley, C.: Advanced SQL Injection In SQL Server Applications. Technical report,
NGSSoftware Insight Security Research (2002).
2. Anley, C.: (more) Advanced SQL Injection. Technical report, NGSSoftware Insight
Security Research (2002).
3. Boyd, S., Keromytis, A.: SQLrand: Preventing SQL injection attacks. In Jakobsson,
M., Yung, M., Zhou, J., eds.: Proceedings of the 2nd Applied Cryptography and
Network Security (ACNS) Conference. Volume 3089 of Lecture Notes in Computer
Science., Springer-Verlag (2004) 292–304.
4. Descartes, A., Bunce, T.: Perl DBI. O’Reilly (2000).
5. Kiczales, G., Lamping, J., Menhdhekar, A., Maeda, C., Lopes, C., Loingtier, J.M.,
Irwin, J.: Aspect-Oriented Programming. In Ak¸sit, M., Matsuoka, S., eds.: Pro-
ceedings European Conference on Object-Oriented Programming. Volume 1241 of
Lecture Notes in Computer Science., Springer-Verlag (1997) 220–242.
6. Larson, E., Austin, T.: High coverage detection of input-related security faults. In:
Proceedings of the 12th USENIX Security Symposium, Washington D.C., USENIX
(2003) 121–136.
7. Lim, J.: ADOdb Database Abstraction Library for PHP (and Python). Web page
at http://adodb.sourceforge.net (2000–2004).
8. Maor, O., Shulman, A.: SQL Injection Signatures Evasion. Technical report,
Imperva Application Defense Center (2004).
9. Meijer, E., Schulte, W., Bierman, G.: Unifying tables, objects and documents.
In: Workshop on Declarative Programming in the Context of OO Languages (DP-
COOL’03), Uppsala, Sweeden (2003) 145–166.
10. MITRE: Common Vulnerabilites and Exposures. Web page at http://cve.
mitre.org (1999–2004).
11. NIST: ICAT Metabase. Web page at http://icat.nist.gov/ (2000–2004).
12. Ollmann, G.: HTML Code Injection and Cross-site Scripting. Technical report,
Gunter Ollmann (2002).
Insight Security Research (2004).
(2001–2004).
13. Ollmann, G.: Second-order Code Injection Attacks. Technical report, NGSSoftware
14. PHP Group, T.: PHP Hypertext Preprocessor. Web page at http://www.php.net
15. phpBB Group, T.: phpBB.com. Web page at http://www.phpbb.com (2001–2004).
16. SecurityFocus: BugTraq. Web page at http://www.securityfocus.com/bid
(1998–2004).
17. Shankar, U., Talwar, K., Foster, J.S., Wagner, D.: Detecting format string vul-
In: Proceedings of the 10th USENIX Security
nerabilities with type qualiﬁers.
Symposium, Washington D.C., USENIX (2001) 257–272.
18. Stamey, J.W., Saunders, B.T., Cameron, M.: Aspect Oriented PHP (AOPHP).
Web page at http://www.aophp.net (2004–2005).
19. Valgrind Developers: Valgrind. Web page at http://valgrind.org (2000–2005).
20. Wall, L., Christiansen, T., Orwant, J.: Programming Perl. O’Reilly (2000).
Improving Host-Based IDS with Argument
Abstraction to Prevent Mimicry Attacks
Sufatrio1 and Roland H.C. Yap2
1 Temasek Laboratories, National University of Singapore,
5 Sports Drive 2, Singapore 117508, Singapore
PI:EMAIL
2 School of Computing, National University of Singapore,
3 Science Drive 2, Singapore 117543, Singapore
PI:EMAIL
Abstract. A popular class of host-based Intrusion Detection Systems
(IDS) are those based on comparing the system call trace of a process against
a set of k-grams. However, the detection mechanism in such IDS can be
evaded by cloaking an attack as a mimicry attack. In this paper, we give an
algorithm that transforms a detectable attack into a mimicry attack. We
demonstrate on a number of examples that using this algorithm, mimicry
attacks can be easily constructed on self-based IDS with a set of k-grams
and also a more precise graph proﬁle representation. We enhance the IDS by
making use of the system call arguments and process credentials. To avoid
increasing the false positives, a supplied speciﬁcation is used to abstract the
system call arguments and process credentials. The speciﬁcation takes into
account what objects in the system that can be sensitive to potential at-
tacks, and highlights the occurrence of “dangerous” operations. With this
simple extension, we show that the robustness of the IDS is increased. Our
preliminary experiments show that on our example programs and attacks, it
was no longer possible to construct mimicry attacks. We also demonstrate
that the enhanced IDS provides resistance to a variety of common attack