B 树索引中的每块资料都必须至少写入两次：一次写入预先写入日志（WAL），一次写入树页面本身（如果有分页还需要再写入一次）。即使在该页面中只有几个位元组发生了变化，也需要接受写入整个页面的开销。有些储存引擎甚至会覆写同一个页面两次，以免在电源故障的情况下页面未完整更新【24,25】。
由于反复压缩和合并 SSTables，日志结构索引也会多次重写资料。这种影响 —— 在资料库的生命周期中每笔资料导致对硬碟的多次写入 —— 被称为 **写入放大（write amplification）**。使用固态硬碟的机器需要额外关注这点，固态硬碟的快闪记忆体寿命在覆写有限次数后就会耗尽。
在写入繁重的应用程式中，效能瓶颈可能是资料库可以写入硬碟的速度。在这种情况下，写放大会导致直接的效能代价：储存引擎写入硬碟的次数越多，可用硬碟频宽内它能处理的每秒写入次数就越少。
进而，LSM 树通常能够比 B 树支援更高的写入吞吐量，部分原因是它们有时具有较低的写放大（尽管这取决于储存引擎的配置和工作负载），部分是因为它们顺序地写入紧凑的 SSTable 档案而不是必须覆写树中的几个页面【26】。这种差异在机械硬碟上尤其重要，其顺序写入比随机写入要快得多。
LSM 树可以被压缩得更好，因此通常能比 B 树在硬碟上产生更小的档案。B 树储存引擎会由于碎片化（fragmentation）而留下一些未使用的硬碟空间：当页面被拆分或某行不能放入现有页面时，页面中的某些空间仍未被使用。由于 LSM 树不是面向页面的，并且会透过定期重写 SSTables 以去除碎片，所以它们具有较低的储存开销，特别是当使用分层压缩（leveled compaction）时【27】。
在许多固态硬碟上，韧体内部使用了日志结构化演算法，以将随机写入转变为顺序写入底层储存晶片，因此储存引擎写入模式的影响不太明显【19】。但是，较低的写入放大率和减少的碎片仍然对固态硬碟更有利：更紧凑地表示资料允许在可用的 I/O 频宽内处理更多的读取和写入请求。
#### LSM树的缺点
日志结构储存的缺点是压缩过程有时会干扰正在进行的读写操作。尽管储存引擎尝试增量地执行压缩以尽量不影响并发访问，但是硬碟资源有限，所以很容易发生某个请求需要等待硬碟先完成昂贵的压缩操作。对吞吐量和平均响应时间的影响通常很小，但是日志结构化储存引擎在更高百分位的响应时间（请参阅 “[描述效能](ch1.md#描述效能)”）有时会相当长，而 B 树的行为则相对更具有可预测性【28】。
压缩的另一个问题出现在高写入吞吐量时：硬碟的有限写入频宽需要在初始写入（记录日志和重新整理记忆体表到硬碟）和在后台执行的压缩执行绪之间共享。写入空资料库时，可以使用全硬碟频宽进行初始写入，但资料库越大，压缩所需的硬碟频宽就越多。
如果写入吞吐量很高，并且压缩没有仔细配置好，有可能导致压缩跟不上写入速率。在这种情况下，硬碟上未合并段的数量不断增加，直到硬碟空间用完，读取速度也会减慢，因为它们需要检查更多的段档案。通常情况下，即使压缩无法跟上，基于 SSTable 的储存引擎也不会限制传入写入的速率，所以你需要进行明确的监控来检测这种情况【29,30】。
B 树的一个优点是每个键只存在于索引中的一个位置，而日志结构化的储存引擎可能在不同的段中有相同键的多个副本。这个方面使得 B 树在想要提供强大的事务语义的资料库中很有吸引力：在许多关系资料库中，事务隔离是透过在键范围上使用锁来实现的，在 B 树索引中，这些锁可以直接附加到树上【5】。在 [第七章](ch7.md) 中，我们将更详细地讨论这一点。
B 树在资料库架构中是非常根深蒂固的，为许多工作负载都提供了始终如一的良好效能，所以它们不可能在短期内消失。在新的资料库中，日志结构化索引变得越来越流行。没有简单易行的办法来判断哪种型别的储存引擎对你的使用场景更好，所以需要透过一些测试来得到相关经验。
### 其他索引结构
到目前为止，我们只讨论了键值索引，它们就像关系模型中的 **主键（primary key）** 索引。主键唯一标识关系表中的一行，或文件资料库中的一个文件或图形资料库中的一个顶点。资料库中的其他记录可以透过其主键（或 ID）引用该行 / 文件 / 顶点，索引就被用于解析这样的引用。
次级索引（secondary indexes）也很常见。在关系资料库中，你可以使用 `CREATE INDEX` 命令在同一个表上建立多个次级索引，而且这些索引通常对于有效地执行联接（join）而言至关重要。例如，在 [第二章](ch2.md) 中的 [图 2-1](../img/fig2-1.png) 中，很可能在 `user_id` 列上有一个次级索引，以便你可以在每个表中找到属于同一使用者的所有行。
次级索引可以很容易地从键值索引构建。次级索引主要的不同是键不是唯一的，即可能有许多行（文件，顶点）具有相同的键。这可以透过两种方式来解决：将匹配行识别符号的列表作为索引里的值（就像全文索引中的记录列表），或者透过向每个键新增行识别符号来使键唯一。无论哪种方式，B 树和日志结构索引都可以用作次级索引。
#### 将值储存在索引中
索引中的键是查询要搜寻的内容，而其值可以是以下两种情况之一：它可以是实际的行（文件，顶点），也可以是对储存在别处的行的引用。在后一种情况下，行被储存的地方被称为 **堆档案（heap file）**，并且储存的资料没有特定的顺序（它可以是仅追加的，或者它可以跟踪被删除的行以便后续可以用新的资料进行覆盖）。堆档案方法很常见，因为它避免了在存在多个次级索引时对资料的复制：每个索引只引用堆档案中的一个位置，实际的资料都储存在一个地方。
在不更改键的情况下更新值时，堆档案方法可以非常高效：只要新值的位元组数不大于旧值，就可以覆盖该记录。如果新值更大，情况会更复杂，因为它可能需要移到堆中有足够空间的新位置。在这种情况下，要么所有的索引都需要更新，以指向记录的新堆位置，或者在旧堆位置留下一个转发指标【5】。
在某些情况下，从索引到堆档案的额外跳跃对读取来说效能损失太大，因此可能希望将被索引的行直接储存在索引中。这被称为聚集索引（clustered index）。例如，在 MySQL 的 InnoDB 储存引擎中，表的主键总是一个聚集索引，次级索引则引用主键（而不是堆档案中的位置）【31】。在 SQL Server 中，可以为每个表指定一个聚集索引【32】。
在 **聚集索引**（在索引中储存所有的行资料）和 **非聚集索引**（仅在索引中储存对资料的引用）之间的折衷被称为 **覆盖索引（covering index）** 或 **包含列的索引（index with included columns）**，其在索引记忆体储表的一部分列【33】。这允许透过单独使用索引来处理一些查询（这种情况下，可以说索引 **覆盖（cover）** 了查询）【32】。
与任何型别的资料重复一样，聚集索引和覆盖索引可以加快读取速度，但是它们需要额外的储存空间，并且会增加写入开销。资料库还需要额外的努力来执行事务保证，因为应用程式不应看到任何因为使用副本而导致的不一致。
#### 多列索引
至今讨论的索引只是将一个键对映到一个值。如果我们需要同时查询一个表中的多个列（或文件中的多个栏位），这显然是不够的。
最常见的多列索引被称为 **连线索引（concatenated index）** ，它透过将一列的值追加到另一列后面，简单地将多个栏位组合成一个键（索引定义中指定了栏位的连线顺序）。这就像一个老式的纸质电话簿，它提供了一个从（姓氏，名字）到电话号码的索引。由于排序顺序，索引可以用来查询所有具有特定姓氏的人，或所有具有特定姓氏 - 名字组合的人。但如果你想找到所有具有特定名字的人，这个索引是没有用的。
**多维索引（multi-dimensional index）** 是一种查询多个列的更一般的方法，这对于地理空间资料尤为重要。例如，餐厅搜寻网站可能有一个数据库，其中包含每个餐厅的经度和纬度。当用户在地图上检视餐馆时，网站需要搜寻使用者正在检视的矩形地图区域内的所有餐馆。这需要一个二维范围查询，如下所示：
```sql
SELECT * FROM restaurants WHERE latitude > 51.4946 AND latitude  -0.1162 AND longitude < -0.1004;
```
一个标准的 B 树或者 LSM 树索引不能够高效地处理这种查询：它可以返回一个纬度范围内的所有餐馆（但经度可能是任意值），或者返回在同一个经度范围内的所有餐馆（但纬度可能是北极和南极之间的任意地方），但不能同时满足两个条件。
一种选择是使用 **空间填充曲线（space-filling curve）** 将二维位置转换为单个数字，然后使用常规 B 树索引【34】。更普遍的是，使用特殊化的空间索引，例如 R 树。例如，PostGIS 使用 PostgreSQL 的通用 GiST 工具【35】将地理空间索引实现为 R 树。这里我们没有足够的地方来描述 R 树，但是有大量的文献可供参考。
有趣的是，多维索引不仅可以用于地理位置。例如，在电子商务网站上可以使用建立在（红，绿，蓝）维度上的三维索引来搜寻特定颜色范围内的产品，也可以在天气观测资料库中建立（日期，温度）的二维索引，以便有效地搜寻 2013 年内的温度在 25 至 30°C 之间的所有观测资料。如果使用一维索引，你将不得不扫描 2013 年的所有记录（不管温度如何），然后透过温度进行过滤，或者反之亦然。二维索引可以同时透过时间戳和温度来收窄资料集。这个技术被 HyperDex 所使用【36】。
#### 全文搜寻和模糊索引
到目前为止所讨论的所有索引都假定你有确切的资料，并允许你查询键的确切值或具有排序顺序的键的值范围。他们不允许你做的是搜寻**类似**的键，如拼写错误的单词。这种模糊的查询需要不同的技术。
例如，全文搜寻引擎通常允许搜寻目标从一个单词扩充套件为包括该单词的同义词，忽略单词的语法变体，搜寻在相同文件中的近义词，并且支援各种其他取决于文字的语言分析功能。为了处理文件或查询中的拼写错误，Lucene 能够在一定的编辑距离内搜寻文字【37】（编辑距离 1 意味著单词内发生了 1 个字母的新增、删除或替换）。