for (symmetric-key) broadcast encryption [16, 18] and multicast
encryption [12, 24, 30]. Cremers et al. [15] note MLS/TreeKEM’s dis-
advantages w.r.t. PCS for multiple groups, and Weider [29] suggests
Causal TreeKEM, a variant that requires less ordering of protocol
messages. Finally, in concurrent work appearing recently, [9] ana-
lyzed an older version of TreeKEM (from MLS Draft 7) using formal
verification techniques.
2 PRELIMINARIES
Notation. We use associative arrays which map arbitrary key strings
to item strings. For array 𝐴 we use “.” to denote all entries. In
particular, we (implicitly) declare variable 𝐴 to be a (1-dimensional)
array and set all of its entries empty string by writing 𝐴[.] ← 𝜀.
Similarly, we declare a new 2-dimensional array 𝐵 with empty
entries by 𝐵[., .] ← 𝜀. We use the shorthand 𝐵[𝑥, .] ← 𝐴 to denote
that ∀𝑦 with 𝐴[𝑦] ̸= 𝜀 we set 𝐵[𝑥, 𝑦] ← 𝐴[𝑦]. For subset 𝑌 ′ ⊆
𝑌 the term 𝑌 ′ ⊆ 𝐴 returns true iff 𝐴 contains all elements in
𝑌 ′; that is ∀𝑦 ∈ 𝑌 ′ ∃𝑥 : 𝐴[𝑥] = 𝑦. For vector x = (𝑥1, . . . , 𝑥𝑑)
with all components 𝑥𝑖 ∈ 𝑋 we write 𝐴[x] to denote the vector
(𝐴[𝑥1], . . . , 𝐴[𝑥𝑑]). We denote the empty list with [.] and the length
of a list 𝐿 by |𝐿|. The following special keywords are used to simplify
the exposition of the security games: req is followed by a condition;
if the condition is not satisfied, the oracle/procedure containing the
keyword is exited and all actions by it are undone. let is followed
by a variable and a condition. After evaluating the expression the
variable is assigned with the value that satisfies the condition, if
such value exists, and ⊥ otherwise. chk is followed by a condition;
if the condition is not satisfied, the oracle/procedure containing the
keyword returns false, otherwise the next instruction is executed.
3 FORMAL DEFINITION OF SECURE GROUP
MESSAGING
In this section we formally define secure group messaging (SGM).
Specifically, the formal syntax of SGM schemes is introduced in
Section 3.1, and Section 3.2 introduces the security game for SGM
schemes.
3While not ideal, we felt this approach was necessary given the strong incentive to
make progress on MLS’s analysis prior to it being to widely deployed.
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea14653.1 Syntax
This section introduces the formal syntax of an SGM scheme. Parties
are identified by unique party IDs ID chosen from an arbitrary fixed
set. In the following, 𝑠 and 𝑠′ denote the internal state of the SGM
scheme before and after an operation, respectively. An SGM scheme
SGM consists of 15 algorithms grouped into the categories above:
• For initialization:
– 𝑠 ← Init(ID): takes as input a party ID ID and generates
the initial state.
and outputs the public key;
to spk from the state;
for party ID′;
• For interaction with the PKI:
– (𝑠′, spk) ← Gen-SK(𝑠): generates new signature key pair
– 𝑠′ ← Rem-SK(𝑠, spk): removes the key pair corresponding
– 𝑠′ ← Get-SK(𝑠, ID′, spk′): stores signature public key spk′
– (𝑠′, kb) ← Gen-KB(𝑠, spk): generates new key bundle (aka
– (𝑠′, ok) ← Get-KB(𝑠, ID′, kb′): stores key bundle kb′ for
initial key material), signed with spk;
party ID′ — can reject kb′ by outputting ok = false.
Key bundles have the format kb = (wpk, spk, sig), where
sig is a signature of wpk under spk, and wpk is so-called
welcome key material, which can be used to encrypt secret
information for joining group members.
• For group creation:
– 𝑠′ ← Create(𝑠, spk, wpk): creates group with self, where
the party uses key pair corresponding to spk to sign in
this group, while control messages for which the recipient
is the group creator, will be encrypted under keys in wpk.
ID′;
party ID′;
• For proposals:
– (𝑠′, 𝑃) ← Add(𝑠, ID′): generates a proposal to add party
– (𝑠′, 𝑃) ← Remove(𝑠, ID′): generates a proposal to remove
– (𝑠′, 𝑃) ← Update(𝑠, spk): generates a proposal for self to
update the personal key material; the new signing verifi-
cation key will be spk;
– (𝑠′, PI) ← Proc-PM(𝑠, 𝑃): adds proposal 𝑃 to the state and
outputs information PI about 𝑃.
• For commits:
– (𝑠′, 𝐸, W,𝑇 ) ← Commit(𝑠, P): creates a commit correspond-
ing to a vector P of proposals and outputs an epoch ID
𝐸, an array of welcome messages W (where W[ID] is the
welcome message for newly added party ID), and a commit
message 𝑇 (for existing group members);
– (𝑠′, GI) ← Proc-CM(𝑠,𝑇 ): used by existing group members
to process a commit message 𝑇 and reach a new epoch;
outputs updated group information GI (where GI = ⊥ if 𝑇
is considered invalid);
– (𝑠′, GI) ← Proc-WM(𝑠,𝑊 ): used by newly added group
members to process welcome message 𝑊 and join a group;
outputs group information GI (where GI = ⊥ if 𝑊 is con-
sidered invalid).
plaintext 𝑚 and authenticating AD 𝑎;
• For sending and receiving messages:
– (𝑠′, 𝑒) ← Send(𝑠, 𝑎, 𝑚): generates a ciphertext 𝑒 encrypting
– (𝑠′, 𝐸, S, 𝑖, 𝑚) ← Rcv(𝑠, 𝑎, 𝑒): decrypts ciphertext 𝑒 to plain-
text 𝑚 and verifies AD 𝑎; also outputs a triple (𝐸, S, 𝑖) con-
sisting of epoch ID 𝐸, sender ID S, and message index
𝑖.
3.2 Security
3.2.1 Bookkeeping. The complexity of the SGM security definition
stems from the bookkeeping required to determine which messages
are safe to challenge and when the attacker is allowed to inject. The
security game keeps track of all the relevant execution data with
the help of a so-called history graph. The recorded data informs
three safety predicates (each pertaining to privacy, authenticity,
or both) used to determine whether a given execution was legal.
These predicates are kept generic and considered parameters of the
security definition.
History graphs. A history graph is a directed tree whose nodes
correspond to the group state in the various epochs of an execution:
The root of the tree is a special node 𝑣root that corresponds to the
state of not being part of a group. The children of the root node
are 𝑣create-nodes, which correspond to the creation of groups.4 The
remaining nodes all correspond to the group state after a partic-
ular commit operation. Two nodes 𝑣 and 𝑣′ are connected by an
edge (𝑣, 𝑣′) if the commit operation leading to 𝑣′ was created in 𝑣.
Concretely, a history graph node consists of the following values:
𝑣 = (vid, orig, data, pid), where vid is the node’s (unique) ID, orig
is the party that caused the node’s creation, i.e., orig is either the
group creator or the committer, data is additional data, and pid is
the vector of (IDs of) proposals (see below) that were included in
the commit. The history graph is accessed by the security-game
oracles via the “HG object” HG, which provides information via
several methods (explained later as they are needed). The (ID vid
of the) node corresponding to a party ID’s current state is stored
by the array V-Pt[ID].
Proposals. Similarly to HG and the history graph, the object Props
keeps track of proposals. The information recorded about each pro-
posal is a vector 𝑝 = (pid, vid, op, orig, data), where pid is the pro-
posal’s (unique) ID, vid is the (ID of) the HG node corresponding to
the epoch in which the proposal was created, op ∈ {add, rem, upd}
is the type of proposal, orig is the party that issued the proposal, and
data is additional data. Similarly to the HG object, Props will also
export several useful methods (also explained later) to the oracles
of the security game.
4The security game allows multiple groups to be created (when multiple parties simul-
taneously create a group). However, in order to remain in the single-group setting,
the attacker is required to pick a single one of these groups as the “canonical group.”
Parties may only join the canonical group.
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1466PKI bookkeeping. Just as epochs and proposals are kept track of
symbolically, so are welcome keys and signature keys. Specifically,
each welcome key has a (unique) welcome-key ID wkid, and each
signature key has a (unique) signature-key ID skid. The arrays
WK-ID[·] and SK-ID[·] map wkid and skid values to the ID of the
party that owns the corresponding secret keys; the arrays WK-PK[·]
and SK-PK[·] map wkid and skid values to the corresponding public
keys. Moreover, the array WK-SK[·] remembers the binding of
welcome keys to signature keys; these bindings are created by key
bundles: when wpk with wkid is signed under spk with skid in a
key bundle, the game sets WK-SK[wkid] ← skid.
The array CL-KB[·, ·] keeps track of the contact list for each party.
Specifically, CL-KB[ID, ID′] is a queue of pairs (wkid, skid) of (IDs
of) initial key material that ID would use if it were to add ID′ to
the group.
Stored and leaked values. In order to stay on top of the information
attacker A accumulates via state compromise, the security game
maintains the following arrays/sets. Stored values: V-St[ID] contains
pairs (vid, flag) of (i) (IDs of) the epochs for which ID currently
stores information and (ii) a flag recording whether said information
can be used to infer information about subsequent states. This array
is organized as a queue with maximum capacity 𝑟, where 𝑟 is a
parameter of the definition and of SGM protocols: it stands for the
maximum number of “open” epochs a party keeps at any point in
time.5 P-St[ID] contains the (IDs of) the proposals currently stored
by ID. WK-St[·] and SK-St[·] contain the (IDs of) the welcome and
signing keys, respectively, currently stored by ID. Leaked values:
V-Lk is a set that contains triples (vid, ID). Each such tuple means
that the attacker learned the state of ID in epoch vid, that for that
state flag = true, which implies that leaked information can be used
to infer information about subsequent epochs. WK-Lk and SK-Lk
contain the (IDs of) the welcome and signing keys, respectively,
for which the attacker has learned the secret keys. AM-Lk records
application messages for which the attacker has learned the key
material.
Deletions, and lack thereof. The SGM definition also requires that
parties who fail to delete old values can not use them to their
advantage after they are removed from the group. Correspondingly,
the array Del keeps track of which parties are deleting values as they
are supposed to (those with Del[ID] = true) and which ones are not.
Formally, a party with Del[ID] = false will simply move such values
to a special “trash tape,” instead of deleting them; the contents of the
trash tape will be revealed to A upon state leakage. Consequently,
there are several “trash arrays” that keep track of what is stored
on the trash tape of each party: V-Tr (for undeleted information
about epochs), AM-Tr (for undeleted information about application
messages), WK-Tr (for undeleted information about welcome keys),
and SK-Tr (for undeleted information about signature keys).
Challenges. The array Chall[vid] stores, for each vid, pairs (S, 𝑖),
indicating that the 𝑖th message from S in epoch vid was a challenge
message.
5The intuition behind the flag is that only the information stored about newest epoch
should allow the attacker (upon state leakage) to compute key material for subsequent
epochs (which is unavoidable). Information corresponding to older epochs, which
are only kept open to receive delayed application messages, should not lend itself to
compromise the security of subsequent epochs.
Epoch IDs. The receiving algorithm Rcv must correctly output a
“sequence number” for each message received. A natural way to
identify application messages is by the triple of epoch ID, sender,
and index (as above). However, the SGM scheme cannot be expected
to output epoch identifiers vid used by the security game. Instead,
the scheme gets to label the epochs itself whenever a commit is cre-
ated by outputting an epoch ID 𝐸. Algorithm Rcv will use the same 𝐸
to refer to messages sent in the corresponding epoch. The security
game stores the 𝐸 used by the SGM scheme in array Ep-ID[vid].
Bad randomness. The game keeps track of which update proposals
and commits were created with randomness known to the attacker
with the help of the Boolean array BR[·]. This information must be
recorded because such proposals/commits will not contribute to
PCS.
In the oracles below that correspond to randomized SGM algo-
rithms, the attacker gets to possibly supply the random coins 𝑟
used by the affected party. Whenever A does not wish to specify
said coins, it sets 𝑟 = ⊥, in which case uniformly random coins
(unknown to A) are used.
// General
𝑏 ← {0, 1}
idCtr++
∀ID : 𝑠[ID] ← Init(ID)
// Communication
CM[·, ·] ← 𝜖
WM[·, ·] ← 𝜖
PM[·, ·] ← 𝜖
AM[·, ·, ·, ·] ← 𝜖
// History Graph
vidroot ← HG.init
V-Pt[·] ← vidroot
V-St[·] ← [(vidroot, false)]
V-Tr[·] ← ∅
V-Lk ← ∅
P-St[·] ← ∅
Ep-ID[·] ← 𝜖
// App. Messages
AM-Tr[·] ← ∅
AM-Lk ← ∅
// Miscellaneous
Chall[·] ← ∅
Del[·] ← true
BR[·] ← false
// PKI
CL-KB[·, ·] ← 𝜖
WK-SK[·] ← 𝜖
WK-ID[·] ← 𝜖
WK-PK[·] ← 𝜖
WK-St[·] ← ∅
WK-Tr ← ∅
WK-Lk ← ∅
SK-ID[·] ← 𝜖
SK-PK[·] ← 𝜖
SK-St[·] ← ∅
SK-Tr ← ∅
SK-Lk ← ∅
Figure 1: Initialization of the security game for secure group-
messaging schemes.
Initialization. At the onset of the execution, the SGM secu-
3.2.2
rity game initializes (cf. Figure 1) all of the bookkeeping variables
listed above. Additionally, it randomly chooses the challenge bit
𝑏, initializes a counter idCtr that serves to provide IDs for epochs
(vid), for proposals (pid), for welcome keys (wkid), as well as for
signature keys (skid), and sets up communication arrays (explained
where they are used) dedicated to control and application messages.
The initialization also initializes the state of all possible parties
by running the Init algorithm and storing the result in the state
array 𝑠[·].6
Finally, the first node of the history graph is created via a call
to the HG.init method. This causes HG to create the root node
𝑣root = (.vid ← idCtr++, .orig ← ⊥, .data ← ⊥, .pid ← ⊥) and
return vidroot = 𝑣root.vid.
6Of course, this is really done on an on-demand basis.
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea14673.2.3 Oracles. All adversary oracles described below proceed ac-
cording to the same pattern: (a) verifying the validity of the oracle
call, (b) retrieving values needed for (c), (c) running the correspond-
ing SGM algorithm, and (d) updating the bookkeeping. Validity
checks (a) are described informally in the text below; a formal de-
scription is provided in Section D of the Appendix. Note that, most
of the time, (b) and (c) are straight-forward and are not mentioned
in the descriptions. To improve readability, lines (c) are highlighted.
// ID generates new sig. key
gen-new-SigK(ID)
(𝑠[ID], spk) ← Gen-SK(𝑠[ID])
skid ← idCtr++
SK-ID[skid] ← ID
SK-PK[skid] ← spk
SK-St[ID] +← skid