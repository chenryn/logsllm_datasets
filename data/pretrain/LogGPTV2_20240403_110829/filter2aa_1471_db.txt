io
n
TRACELO
G_REGIST
ER_GUIDS
Allows the user to register the provider (creating the 
EtwRegistration object backed by the 
ETW_REG_ENTRY data structure)
Pr
ov
id
er
TRACELO
G_JOIN_G
ROUP
Allows the user to insert a manifest-based or 
tracelogging provider to a Providers group (part of 
the ETW traits, which are not described in this 
book)
Pr
ov
id
er
Most of the ETW access rights are automatically granted to the SYSTEM
account and to members of the Administrators, Local Service, and Network
Service groups. This implies that normal users are not allowed to interact
with ETW (unless an explicit session and provider security descriptor allows
it). To overcome the problem, Windows includes the Performance Log Users
group, which has been designed to allow normal users to interact with ETW
(especially for controlling trace sessions). Although all the ETW access
rights are granted by the default security descriptor to the Performance Log
Users group, Windows supports another group, called Performance Monitor
Users, which has been designed only to receive or send notifications to the
session notification provider. This is because the group has been designed to
access system performance counters, enumerated by tools like Performance
Monitor and Resource Monitor, and not to access the full ETW events. The
two tools have been already described in the “Performance monitor and
resource monitor” section of Chapter 1 in Part 1.
As previously introduced in the “ETW Sessions” section of this chapter,
all the ETW security descriptors are stored in the
HKLM\System\CurrentControlSet\Control\Wmi\Security registry key in a
binary format. In ETW, everything that is represented by a GUID can be
protected by a customized security descriptor. To manage ETW security,
applications usually do not directly interact with security descriptors stored in
the registry but use the EventAccessControl and EventAccessQuery APIs
implemented in Sechost.dll.
EXPERIMENT: Witnessing the default security
descriptor of ETW sessions
A kernel debugger can easily show the default security descriptor
associated with ETW sessions that do not have a specific one
associated with them. In this experiment, you need a Windows 10
machine with a kernel debugger already attached and connected to
a host system. Otherwise, you can use a local kernel debugger, or
LiveKd (downloadable from https://docs.microsoft.com/en-
us/sysinternals/downloads/livekd.) After the correct symbols are
configured, you should be able to dump the default SD using the
following command:
Click here to view code image
!sd poi(nt!EtwpDefaultTraceSecurityDescriptor)
The output should be similar to the following (cut for space
reasons):
Click here to view code image
->Revision: 0x1
->Sbz1    : 0x0
->Control : 0x8004
            SE_DACL_PRESENT
            SE_SELF_RELATIVE
->Owner   : S-1-5-32-544
->Group   : S-1-5-32-544
->Dacl    :
->Dacl    : ->AclRevision: 0x2
->Dacl    : ->Sbz1       : 0x0
->Dacl    : ->AclSize    : 0xf0
->Dacl    : ->AceCount   : 0x9
->Dacl    : ->Sbz2       : 0x0
->Dacl    : ->Ace[0]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[0]: ->AceFlags: 0x0
->Dacl    : ->Ace[0]: ->AceSize: 0x14
->Dacl    : ->Ace[0]: ->Mask : 0x00001800
->Dacl    : ->Ace[0]: ->SID: S-1-1-0
->Dacl    : ->Ace[1]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[1]: ->AceFlags: 0x0
->Dacl    : ->Ace[1]: ->AceSize: 0x14
->Dacl    : ->Ace[1]: ->Mask : 0x00120fff
->Dacl    : ->Ace[1]: ->SID: S-1-5-18
->Dacl    : ->Ace[2]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[2]: ->AceFlags: 0x0
->Dacl    : ->Ace[2]: ->AceSize: 0x14
->Dacl    : ->Ace[2]: ->Mask : 0x00120fff
->Dacl    : ->Ace[2]: ->SID: S-1-5-19
->Dacl    : ->Ace[3]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[3]: ->AceFlags: 0x0
->Dacl    : ->Ace[3]: ->AceSize: 0x14
->Dacl    : ->Ace[3]: ->Mask : 0x00120fff
->Dacl    : ->Ace[3]: ->SID: S-1-5-20
->Dacl    : ->Ace[4]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[4]: ->AceFlags: 0x0
->Dacl    : ->Ace[4]: ->AceSize: 0x18
->Dacl    : ->Ace[4]: ->Mask : 0x00120fff
->Dacl    : ->Ace[4]: ->SID: S-1-5-32-544
->Dacl    : ->Ace[5]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[5]: ->AceFlags: 0x0
->Dacl    : ->Ace[5]: ->AceSize: 0x18
->Dacl    : ->Ace[5]: ->Mask : 0x00000ee5
->Dacl    : ->Ace[5]: ->SID: S-1-5-32-559
->Dacl    : ->Ace[6]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[6]: ->AceFlags: 0x0
->Dacl    : ->Ace[6]: ->AceSize: 0x18
->Dacl    : ->Ace[6]: ->Mask : 0x00000004
->Dacl    : ->Ace[6]: ->SID: S-1-5-32-558
You can use the Psgetsid tool (available at
https://docs.microsoft.com/en-us/sysinternals/downloads/psgetsid)
to translate the SID to human-readable names. From the preceding
output, you can see that all ETW access is granted to the SYSTEM
(S-1-5-18), LOCAL SERVICE (S-1-5-19), NETWORK SERVICE
(S-1-5-18), and Administrators (S-1-5-32-544) groups. As
explained in the previous section, the Performance Log Users
group (S-1-5-32-559) has almost all ETW access, whereas the
Performance Monitor Users group (S-1-5-32-558) has only the
WMIGUID_NOTIFICATION access right granted by the session’s
default security descriptor.
Click here to view code image
C:\Users\andrea>psgetsid64 S-1-5-32-559
PsGetSid v1.45 - Translates SIDs to names and vice versa
Copyright (C) 1999-2016 Mark Russinovich
Sysinternals - www.sysinternals.com
Account for AALL86-LAPTOP\S-1-5-32-559:
Alias: BUILTIN\Performance Log Users
Security Audit logger
The Security Audit logger is an ETW session used by the Windows Event
logger service (wevtsvc.dll) to listen for events generated by the Security
Lsass Provider. The Security Lsass provider (which is identified by the
{54849625-5478-4994-a5ba-3e3b0328c30d} GUID) can be registered only
by the NT kernel at ETW initialization time and is never inserted in the
global provider’s hash table. Only the Security audit logger and Autologgers
configured with the EnableSecurityProvider registry value set to 1 can
receive events from the Security Lsass Provider. When the
EtwStartAutoLogger internal function encounters the value set to 1, it enables
the SECURITY_TRACE flag on the associated ETW session, adding the
session to the list of loggers that can receive Security audit events.
The flag also has the important effect that user-mode applications can’t
query, stop, flush, or control the session anymore, unless they are running as
protected process light (at the antimalware, Windows, or WinTcb level;
further details on protected processes are available in Chapter 3 of Part 1).
Secure loggers
Classic (MOF) and WPP providers have not been designed to support all the
security features implemented for manifest-based and tracelogging providers.
An Autologger or a generic ETW session can thus be created with the
EVENT_TRACE_SECURE_MODE flag, which marks the session as secure.
A secure session has the goal of ensuring that it receives events only from
trusted identities. The flag has two main effects:
■    Prevents classic (MOF) and WPP providers from writing any event to
the secure session. If a classic provider is enabled in a secure section,
the provider won’t be able to generate any events.
■    Requires the supplemental TRACELOG_LOG_EVENT access right,
which should be granted by the session’s security descriptor to the
controller application’s access token while enabling a provider to the
secure session.
The TRACE_LOG_EVENT access right allows a more-granular security to
be specified in a session’s security descriptor. If the security descriptor grants
only the TRACELOG_GUID_ENABLE to an untrusted user, and the ETW
session is created as secure by another entity (a kernel driver or a more
privileged application), the untrusted user can’t enable any provider on the
secure section. If the section is created as nonsecure, the untrusted user can
enable any providers on it.
Dynamic tracing (DTrace)
As discussed in the previous section, Event Tracing for Windows is a
powerful tracing technology integrated into the OS, but it’s static, meaning
that the end user can only trace and log events that are generated by well-
defined components belonging to the operating system or to third-party
frameworks/applications (.NET CLR, for example.) To overcome the
limitation, the May 2019 Update of Windows 10 (19H1) introduced DTrace,
the dynamic tracing facility built into Windows. DTrace can be used by
administrators on live systems to examine the behavior of both user programs
and of the operating system itself. DTrace is an open-source technology that
was developed for the Solaris operating system (and its descendant, illumos,
both of which are Unix-based) and ported to several operating systems other
than Windows.
DTrace can dynamically trace parts of the operating system and user
applications at certain locations of interest, called probes. A probe is a binary
code location or activity to which DTrace can bind a request to perform a set
of actions, like logging messages, recording a stack trace, a timestamp, and
so on. When a probe fires, DTrace gathers the data from the probe and
executes the actions associated with the probe. Both the probes and the
actions are specified in a script file (or directly in the DTrace application
through the command line), using the D programming language. Support for
probes are provided by kernel modules, called providers. The original
illumos DTrace supported around 20 providers, which were deeply tied to the
Unix-based OS. At the time of this writing, Windows supports the following
providers:
■    SYSCALL Allows the tracing of the OS system calls (both on entry
and on exit) invoked from user-mode applications and kernel-mode
drivers (through Zw* APIs).
■    FBT (Function Boundary tracing) Through FBT, a system
administrator can trace the execution of individual functions
implemented in all the modules that run in the NT kernel.
■    PID (User-mode process tracing) The provider is similar to FBT and
allows tracing of individual functions of a user-mode process and
application.
■    ETW (Event Tracing for Windows) DTrace can use this provider to
attach to manifest-based and TraceLogging events fired from the
ETW engine. DTrace is able to define new ETW providers and
provide associated ETW events via the etw_trace action (which is not
part of any provider).
■    PROFILE Provides probes associated with a time-based interrupt
firing every fixed, specified time interval.
■    DTRACE Built-in provider is implicitly enabled in the DTrace
engine.
The listed providers allow system administrators to dynamically trace
almost every component of the Windows operating system and user-mode
applications.
 Note
There are big differences between the first version of DTrace for
Windows, which appeared in the May 2019 Update of Windows 10, and
the current stable release (distributed at the time of this writing in the May
2021 edition of Windows 10). One of the most notable differences is that
the first release required a kernel debugger to be set up to enable the FBT
provider. Furthermore, the ETW provider was not completely available in
the first release of DTrace.
EXPERIMENT: Enabling DTrace and listing the
installed providers
In this experiment, you install and enable DTrace and list the
providers that are available for dynamically tracing various
Windows components. You need a system with Windows 10 May
2020 Update (20H1) or later installed. As explained in the
Microsoft documentation (https://docs.microsoft.com/en-
us/windows-hardware/drivers/devtest/dtrace), you should first
enable DTrace by opening an administrative command prompt and
typing the following command (remember to disable Bitlocker, if it
is enabled):
bcdedit /set dtrace ON
After the command succeeds, you can download the DTrace
package from https://www.microsoft.com/download/details.aspx?
id=100441 and install it. Restart your computer (or virtual
machine) and open an administrative command prompt (by typing
CMD in the Cortana search box and selecting Run As
Administrator). Type the following commands (replacing
providers.txt with another file name if desired):
Click here to view code image
cd /d “C:\Program Files\DTrace”
dtrace -l > providers.txt
Open the generated file (providers.txt in the example). If
DTrace has been successfully installed and enabled, a list of probes
and providers (DTrace, syscall, and ETW) should be listed in the
output file. Probes are composed of an ID and a human-readable
name. The human-readable name is composed of four parts. Each
part may or may not exist, depending on the provider. In general,
providers try to follow the convention as close as possible, but in
some cases the meaning of each part can be overloaded with
something different:
■    Provider The name of the DTrace provider that is
publishing the probe.
■    Module If the probe corresponds to a specific program
location, the name of the module in which the probe is
located. The module is used only for the PID (which is not
shown in the output produced by the dtrace -l command)
and ETW provider.
■    Function If the probe corresponds to a specific program
location, the name of the program function in which the
probe is located.
■    Name The final component of the probe name is a name
that gives you some idea of the probe’s semantic meaning,
such as BEGIN or END.
When writing out the full human-readable name of a probe, all
the parts of the name are separated by colons. For example,
Click here to view code image
syscall::NtQuerySystemInformation:entry
specifies a probe on the NtQueryInformation function entry
provided by the syscall provider. Note that in this case, the module
name is empty because the syscall provider does not specify any
name (all the syscalls are implicitly provided by the NT kernel).
The PID and FBT providers instead dynamically generate probes
based on the process or kernel image to which they are applied
(and based on the currently available symbols). For example, to
correctly list the PID probes of a process, you should first get the
process ID (PID) of the process that you want to analyze (by
simply opening the Task Manager and selecting the Details
property sheet; in this example, we are using Notepad, which in the
test system has PID equal to 8020). Then execute DTrace with the
following command:
Click here to view code image
dtrace -ln pid8020:::entry > pid_notepad.txt
This lists all the probes on function entries generated by the PID
provider for the Notepad process. The output will contain a lot of
entries. Note that if you do not have the symbol store path set, the
output will not contain any probes generated by private functions.
To restrict the output, you can add the name of the module:
Click here to view code image
dtrace.exe -ln pid8020:kernelbase::entry 
>pid_kernelbase_notepad.txt
This yields all the PID probes generated for function entries of
the kernelbase.dll module mapped in Notepad. If you repeat the
previous two commands after having set the symbol store path with
the following command,
Click here to view code image
set 
_NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/dow
nload/symbols
you will find that the output is much different (and also probes
on private functions).
As explained in the “The Function Boundary Tracing (FBT) and
Process (PID) providers” section later in this chapter, the PID and
FBT provider can be applied to any offset in a function’s code. The
following command returns all the offsets (always located at
instruction boundary) in which the PID provider can generate
probes on the SetComputerNameW function of Kernelbase.dll:
Click here to view code image
dtrace.exe -ln pid8020:kernelbase:SetComputerNameW:
Internal architecture
As explained in the “Enabling DTrace and listing the installed providers”
experiment earlier in this chapter, in Windows 10 May 2020 Update (20H1),
some components of DTrace should be installed through an external package.
Future versions of Windows may integrate DTrace completely in the OS
image. Even though DTrace is deeply integrated in the operating system, it
requires three external components to work properly. These include both the
NT-specific implementation and the original DTrace code released under the
free Common Development and Distribution License (CDDL), which is
downloadable from https://github.com/microsoft/DTrace-on-
Windows/tree/windows.
As shown in Figure 10-37, DTrace in Windows is composed of the
following components:
■    DTrace.sys The DTrace extension driver is the main component that
executes the actions associated with the probes and stores the results
in a circular buffer that the user-mode application obtains via
IOCTLs.
■    DTrace.dll The module encapsulates LibDTrace, which is the DTrace
user-mode engine. It implements the Compiler for the D scripts, sends
the IOCTLs to the DTrace driver, and is the main consumer of the
circular DTrace buffer (where the DTrace driver stores the output of
the actions).
■    DTrace.exe The entry point executable that dispatches all the
possible commands (specified through the command line) to the
LibDTrace.
Figure 10-37 DTrace internal architecture.
To start the dynamic trace of the Windows kernel, a driver, or a user-mode
application, the user just invokes the DTrace.exe main executable specifying
a command or an external D script. In both cases, the command or the file
contain one or more probes and additional actions expressed in the D
programming language. DTrace.exe parses the input command line and
forwards the proper request to the LibDTrace (which is implemented in
DTrace.dll). For example, when started for enabling one or more probes, the
DTrace executable calls the internal dtrace_program_fcompile function
implemented in LibDTrace, which compiles the D script and produces the
DTrace Intermediate Format (DIF) bytecode in an output buffer.
 Note
Describing the details of the DIF bytecode and how a D script (or D
commands) is compiled is outside the scope of this book. Interested
readers can find detailed documentation in the OpenDTrace Specification
book (released by the University of Cambridge), which is available at
https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-924.pdf.
While the D compiler is entirely implemented in user-mode in LibDTrace,
to execute the compiled DIF bytecode, the LibDtrace module just sends the
DTRACEIOC_ENABLE IOCTL to the DTrace driver, which implements the
DIF virtual machine. The DIF virtual machine is able to evaluate each D
clause expressed in the bytecode and to execute optional actions associated
with them. A limited set of actions are available, which are executed through
native code and not interpreted via the D virtual machine.
As shown earlier in Figure 10-37, the DTrace extension driver implements
all the providers. Before discussing how the main providers work, it is
necessary to present an introduction of the DTrace initialization in the
Windows OS.
DTrace initialization