  with	
  AWID	
  we	
  saw	
  that	
  the	
  tag	
  would	
  simply	
  create	
  the	
  same	
  waveform	
  repeatedly	
  and	
  the	
reader	
  would	
  simply	
  demodulate	
  that	
  signal,	
  NFC	
  tags	
  allow	
  for	
  a	
  variety	
  of	
  operating	
  modes	
  including	
the	
  general	
  sharing	
  of	
  data.	
  While	
  some	
  tags	
  support	
  security	
  features	
  such	
  as	
  cryptography,	
  some	
popular	
  applications	
  are	
  designed	
  to	
  only	
  verify	
  basic	
  unprotected	
  data	
  such	
  as	
  the	
  tag’s	
  unique	
identifier.	
  For	
  example,	
  Timo	
  Kasper’s	
  PhD	
  thesis	
  from	
  Ruhr-­‐University	
  Bochum	
  describes	
  how	
  the	
Siemens	
  SIPORT	
  enterprise	
  solution	
  for	
  access	
  control	
  was	
  easily	
  subverted	
  because	
  the	
  system	
  relied	
  on	
the	
  UID	
  (transmitted	
  in	
  plaintext)	
  and	
  the	
  first	
  sector	
  of	
  a	
  Mifare	
  Classic	
  card	
  using	
  default	
  keys.24	
  Certain	
other	
  access	
  control	
  systems	
  including	
  the	
  Android	
  NFC	
  ‘Smart	
  Unlock’	
  feature	
  and	
  Samsung	
  locks	
  NFC	
24	
  Section	
  5.6.3	
  https://www.emsec.rub.de/media/attachments/files/2012/11/timo_phd_thesis.pdf	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
compatible	
  locks	
  (like	
  the	
  SHS-­‐3321)	
  only	
  check	
  the	
  unprotected	
  UID.	
  As	
  discussed	
  earlier	
  in	
  this	
document,	
  the	
  UID	
  block	
  of	
  a	
  tag	
  is	
  intended	
  to	
  be	
  a	
  factory	
  programmed	
  unchangeable	
  value	
  to	
  uniquely	
identify	
  the	
  tag.	
  This	
  section	
  outlines	
  how	
  the	
  proxmark3	
  firmware	
  was	
  enhanced	
  to	
  support	
  stand-­‐
alone	
  operation	
  to	
  capture,	
  clone,	
  and	
  emulate	
  UIDs	
  from	
  ISO1443a	
  compliant	
  tags.	
  (Cloning	
  capability	
  in	
this	
  initial	
  design	
  is	
  limited	
  to	
  changeable	
  Mifare	
  Classic	
  cards.)	
Stand-­‐alone	
  mode	
  runs	
  entirely	
  on	
  the	
  ARM	
  with	
  source	
  code	
  contained	
  within	
  the	
  armsrc/appmain.c	
source	
  file.	
  Each	
  loop	
  of	
  the	
  main	
  application	
  checks	
  if	
  a	
  command	
  arrived	
  over	
  USB	
  as	
  well	
  as	
  checking	
whether	
  the	
  push-­‐button	
  was	
  held	
  down	
  for	
  a	
  second.	
  The	
  traditional	
  low-­‐frequency	
  operation	
  invokes	
SamyRun()	
  which	
  provides	
  replay	
  and	
  simulation	
  logic	
  for	
  HID	
  tags.	
  Interacting	
  with	
  the	
  high-­‐frequency	
tags	
  requires	
  a	
  different	
  FPGA	
  configuration	
  and	
  of	
  course	
  ISO14443	
  specific	
  function	
  calls.	
  FPGA	
configurations	
  are	
  stored	
  in	
  the	
  flash	
  memory	
  of	
  the	
  ARM	
  and	
  can	
  be	
  loaded	
  on	
  demand	
  with	
FpgaDownloadAndGo().	
  The	
  FPGA_BITSTREAM_HF	
  configuration	
  arranges	
  the	
  pin-­‐out	
  so	
  that	
  the	
appropriate	
  coil	
  is	
  connected	
  and	
  the	
  FPGA	
  is	
  ready	
  to	
  expect	
  HF	
  commands.	
The	
  general	
  structure	
  of	
  stand	
  alone	
  operation	
  can	
  be	
  modeled	
  around	
  the	
  existing	
  SamyRun()	
  but	
  it	
requires	
  replacing	
  HID	
  logic	
  with	
  ISO1443	
  logic.	
  For	
  HID	
  reading	
  mode,	
  SamyRun()	
  uses	
CmdHIDdemodFSK()	
  but	
  the	
  new	
  logic	
  will	
  need	
  to	
  first	
  command	
  the	
  FPGA	
  to	
  act	
  as	
  an	
  ISO14443a	
reader	
  with	
  iso14443a_setup(FPGA_HF_ISO1443A_READER_MOD).	
  Reading	
  the	
  UID	
  of	
  a	
  tag	
  is	
  covered	
with	
  the	
  iso14443a_select_card()	
  call.	
  This	
  function	
  will	
  return	
  false	
  until	
  a	
  card	
  was	
  successfully	
  selected	
and	
  its	
  UID	
  saved	
  to	
  memory.	
  The	
  UID	
  is	
  printed	
  and	
  then	
  rearranged	
  to	
  the	
  expected	
  byte	
  order	
  for	
  the	
clone	
  and	
  replay	
  functions.	
Again	
  for	
  cloning,	
  SamyRun()	
  uses	
  a	
  single	
  function	
  CopyHIDtoT55x7()	
  while	
  the	
  HF	
  equivalent	
  of	
  writing	
to	
  a	
  changeable	
  UID	
  card	
  requires	
  a	
  little	
  more	
  effort.	
  First	
  the	
  UID	
  value	
  must	
  be	
  transformed	
  to	
  create	
  a	
well-­‐formed	
  block	
  0.	
  The	
  relevant	
  functions	
  for	
  working	
  with	
  changeable	
  UID	
  Mifare	
  cards	
  are	
MifareCSetBlock()	
  and	
  MifareCGetBlock().	
  Example	
  usage	
  of	
  these	
  functions	
  to	
  write	
  a	
  new	
  UID	
  to	
  a	
  card	
is	
  presented	
  in	
  mfCSetUID()	
  which	
  first	
  reads	
  block	
  0	
  from	
  the	
  target	
  tag	
  and	
  then	
  replaces	
  the	
  UID	
  bytes	
while	
  maintaining	
  the	
  reserved	
  bytes	
  5-­‐7	
  and	
  setting	
  an	
  appropriate	
  block	
  check	
  character	
  (BCC).	
The	
  final	
  stand-­‐alone	
  feature	
  is	
  tag	
  simulation	
  performed	
  for	
  HID	
  tags	
  with	
  CmdHIDsimTAG().	
  For	
ISO14443,	
  the	
  equivalent	
  function	
  to	
  use	
  is	
  SimulateIso14443aTag()	
  which	
  takes	
  in	
  high	
  and	
  low	
  order	
bytes	
  for	
  the	
  UID	
  and	
  configures	
  the	
  device	
  to	
  act	
  as	
  a	
  tag	
  with	
  that	
  UID.	
  Simulation	
  of	
  an	
  ISO14443a	
  tag	
however	
  may	
  not	
  work	
  as	
  well	
  as	
  cloning	
  to	
  a	
  card.	
  Using	
  a	
  PCB	
  antenna	
  from	
  RyscCorp25	
  works	
  very	
well	
  for	
  simulating	
  the	
  tag	
  when	
  interrogated	
  by	
  some	
  devices	
  but	
  hardly	
  works	
  on	
  others.	
  For	
  example	
when	
  the	
  coil	
  is	
  brought	
  in	
  proximity	
  to	
  certain	
  Samsung	
  locks	
  the	
  simulation	
  function	
  reports	
unexpected	
  commands	
  while	
  a	
  cloned	
  card	
  works	
  perfectly.	
  (Specifically	
  the	
  SHS-­‐3321	
  and	
  SHS-­‐3420	
locks	
  were	
  evaluated.)	
  This	
  may	
  be	
  a	
  consequence	
  of	
  timing	
  discrepancies	
  or	
  perhaps	
  related	
  to	
  the	
antenna	
  shape	
  but	
  experiments	
  with	
  other	
  hardware	
  based	
  tag	
  simulation	
  (PN533	
  w/	
  libNFC	
  and	
ChameleonMini)	
  had	
  similar	
  results.	
  In	
  general	
  these	
  devices	
  are	
  not	
  recognized	
  as	
  tags	
  by	
  the	
  lock.	
Further	
  testing	
  is	
  needed	
  to	
  definitively	
  debug	
  this	
  behavior	
  and	
  determine	
  whether	
  this	
  may	
  even	
  be	
  an	
advanced	
  security	
  feature	
  of	
  the	
  lock.	
  Over	
  the	
  course	
  of	
  many	
  tests,	
  the	
  simulation	
  mode	
  worked	
25	
  http://store.ryscc.com/collections/proxmark-­‐3/products/high-­‐frequency-­‐pcb-­‐antenna	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
reliably	
  with	
  a	
  Nexus	
  4	
  and	
  Nexus	
  7	
  making	
  it	
  possible	
  (as	
  Google	
  clearly	
  warns)	
  for	
  a	
  tag	
  used	
  by	
  the	
Android	
  Smart	
  Lock26	
  feature	
  to	
  be	
  replicated	
  in	
  this	
  manner.	
  With	
  the	
  tested	
  Samsung	
  locks	
  however	
only	
  opened	
  (one	
  time	
  only)	
  after	
  dozens	
  of	
  attempts	
  with	
  different	
  antenna	
  placement.	
  None	
  of	
  the	
tested	
  NFC	
  devices	
  had	
  problems	
  reading	
  from	
  clone	
  cards.	
Once	
  the	
  main	
  functionality	
  was	
  working,	
  the	
  next	
  challenge	
  was	
  to	
  reconsider	
  the	
  usage	
  workflow.	
  In	
the	
  traditional	
  LF	
  stand-­‐alone	
  mode	
  it	
  is	
  necessary	
  to	
  first	
  use	
  the	
  button	
  to	
  enter	
  stand-­‐alone	
  mode	
  and	
then	
  again	
  to	
  enter	
  record	
  mode.	
  It	
  is	
  also	
  possible	
  to	
  go	
  directly	
  into	
  play	
  mode	
  but	
  since	
  the	
  ID	
  is	
  not	
initialized	
  or	
  preserved	
  across	
  sessions,	
  this	
  seemed	
  extraneous.	
  Instead	
  the	
  NFC	
  code	
  has	
  been	
  designed	
to	
  enter	
  directly	
  into	
  reader	
  mode	