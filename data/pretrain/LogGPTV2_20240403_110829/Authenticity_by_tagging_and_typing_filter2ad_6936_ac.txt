following process. Similar reasoning applies also to the latter. The
type nonce(I, J, M) prevents the nonce to be sent as cleartext on the
network: in fact, as mentioned above, only terms with type Un can
be sent on the network.
SYMMETRIC and ASYMMETRIC ENCRYPT rely on the judg-
ment A;Γ (cid:15) {M1, . . . ,Mn}M0 : enc( f ), which means that the cipher-
text {M1, . . . ,Mn}M0 can be encrypted by A under the typing en-
vironment Γ and the atomic effect f . Such an effect is either the
empty effect or run(A, I, M): as mentioned above, an encryption
may represent the start of an authentication session, so the corre-
sponding run must have been previously executed. Typing rules for
enc( f ) are reported in Table 5 and discussed in Section 3.3.
As shown in SYMMETRIC and ASYMMETRIC DECRYPT, when
decrypting a ciphertext, the highest types are assigned to the free
variables according to the encryption rule originating that cipher-
text. The encryption rules are mutually exclusive and univocally
determine these highest types. In practice, ﬁnding these types is
trivial, since it amounts to giving type Un to all variables except the
ones with tags Claim?, Verif? which require type nonce(I, J, M), as
described in Section 3.3. Γ
A simulates the typing environment of
the originator of the message, which possibly differs from Γ be-
cause of secret nonces casted to Un in SOPH/SOSH challenges
(see Section 3.3 for more detail).
3.3 Typing Authentication
ble 5. In the following, (cid:1)M represents a sequence of terms; the order
We continue our description of the typing rule by illustrating the
typing of the nonce-handshakes. The authentication rules are in Ta-
of the terms in a ciphertext is immaterial; ﬁnally, Γ(cid:15) M1, . . . ,Mn : T
is a short for Γ (cid:15) M1 : T, . . .,Γ (cid:15) Mn : T .
POSH Nonce Hand-Shake
In a POSH nonce hand-shake, J creates a fresh nonce n with type
Un (NEW NAME) and sends it on the network. I receives it and
creates a ciphertext by POSH REQUEST for authenticating a mes-
Table 4 Typing Processes
In SYMMETRIC DECRYPT , Γ (cid:15) K : keysym(I, J) ⇒ A ∈ {I, J}. In ASYMMETRIC DECRYPT , Γ (cid:15) K : keypriv(I) ⇒ A = I.
In SYMMETRIC and ASYMMETRIC DECRYPT, Γ
A
= Γ[n : Un/n : nonce(I, A, M)], ∀n, I, M.
Γ, k : keysym(I, J) (cid:15) P : e
SYMMETRIC KEY
Γ (cid:15) let k = sym-key(I, J).P : e
Γ, k : keyasym(I) (cid:15) P : e
ASYMMETRIC-KEY
Γ (cid:15) let k = asym-key(I).P : e
REPLICATION
Γ (cid:15) A (cid:2) S : e
Γ (cid:15) A(cid:2)!S : e
PARΓ (cid:15) P : eP
Γ (cid:15) Q : eQ
Γ (cid:15) P|Q : eP + eQ
IDENTITY ASSIGNMENT
A;Γ (cid:15) S : e
Γ (cid:15) A (cid:2) S : e
NILΓ (cid:15) (cid:16)
A;Γ (cid:15) 0 : e
RUN
A;Γ (cid:15) S : e + [run(A, I, M)]
A;Γ (cid:15) run(A, I, M).S : e
INPUT
A;Γ, f v(M1, . . . ,Mn) : Un (cid:15) S : e + [in(M1) + . . . + in(Mn)]
A;Γ (cid:15) in(M1, . . . ,Mn).S : e
OUTPUT
∀i ∈ [1, n]
Γ (cid:15) Mi : Un
A;Γ (cid:15) S : e
A;Γ (cid:15) out(M1, . . . ,Mn).S : e
NEW NAME
A;Γ, n : Un (cid:15) S : e + [ f resh(n)]
A;Γ (cid:15) new(n : Un).S : e
NEW SECRET NONCE
A;Γ, n : nonce(I, A, M) (cid:15) S : e + [ f resh(n, I, A, M)]
A;Γ (cid:15) new(n : nonce(I, A, M)).S : e
SYMMETRIC ENCRYPT
A;Γ (cid:15) {M1, . . . ,Mn}K : enc( f )
A;Γ, z : Un (cid:15) S : e
A;Γ (cid:15) encrypt {M1, . . . ,Mn}K as z.S : e + [ f ]
ASYMMETRIC ENCRYPT
A;Γ (cid:15) {|M1, . . . ,Mn|}K : enc( f )
A;Γ, z : Un (cid:15) S : e
A;Γ (cid:15) encrypt {|M1, . . . ,Mn|}K as z.S : e + [ f ]
SYMMETRIC DECRYPT
Γ (cid:15) M : Un
f v(M1, . . . ,Mn) = x1, . . . ,xm
T1, . . . ,Tm are the highest types such that I;Γ
A
A;Γ, x1 : T1, . . . ,xm : Tm (cid:15) S : e + [dec{M1, . . . ,Mn}K]
, x1 : T1, . . . ,xm : Tm (cid:15) {M1, . . . ,Mn}
K : enc( f )
A;Γ (cid:15) decrypt M as {M1, . . . ,Mn}K .S : e
ASYMMETRIC DECRYPT
Γ (cid:15) M : Un
f v(M1, . . . ,Mn) = x1, . . . ,xm
T1, . . . ,Tm are the highest types such that I;Γ
A
A;Γ, x1 : T1, . . . ,xm : Tm (cid:15) S : e + [dec{|M1, . . . ,Mn|}
, x1 : T1, . . . ,xm : Tm (cid:15) {|M1, . . . ,Mn|}
K : enc( f )
]
K
A;Γ (cid:15) decrypt M as {|M1, . . . ,Mn|}K.S : e
sage M with J. That ciphertext is received by J which authenticates
I and M by POSH COMMIT .
C(N), Auth(M), (cid:1)M}K. The tag of N, which is the nonce re-
POSH REQUEST The judgment allows the encryption of {Id(Id),
ceived from the network, and the identity label Id change
according to the type of K. If K is a long-term key shared
with J, then I may alternatively communicate to J that she is
the claimant (tag Claim) of the authentication session or J is
her intended veriﬁer (tag Verif). Since K is only known by
I and J, the two different tags above convey the same infor-
mation: "I is the claimant and J is the intended veriﬁer". In
fact, communicating who is the claimant implicitly commu-
nicates who is the intended veriﬁer and vice-versa. If K is the
private key of I, then the intended veriﬁer has to be speciﬁed,
since the identity of the claimant is implicit in the signature.
The message to be authenticated is tagged by Auth. Since
the encryption represents the start of an authentication ses-
sion from I to J, at least one occurrence of run(I, J, M) has
to be present in the typing effect. Notice that the judgment
Γ (cid:15) (cid:1)M : Un says that M is a tuple of untagged terms. This
SOPH/SOSH Nonce Hand-Shake
J may start a SOPH/SOSH nonce-handshake with I for authenti-
cating M, by creating a fresh nonce n with type nonce(I, J, M) by
NEW SECRET NONCE (Table 4). The nonce is then encrypted by
SOPH/SOSH INQUIRY in a ciphertext and sent to I. The cipher-
text is used for asking I whether or not she agrees on M and is
willing to authenticate with J. When I receives the ciphertext, he
may conﬁrm the request by sending back the nonce either as clear-
text or re-encrypted. In this case, the type of the nonce is cast to
Un by SOPH/SOSH CONFIRM. When J receives that nonce, he
authenticates I and M by SOPH/SOSH COMMIT .
SOPH/SOSH INQUIRY allows one entity to encrypt the secret
nonce in messages of the form {Id(Id), C(n), Auth(M), (cid:1)M}K,
where K is either the public key of I, or a long-term key
shared with J. The tags used here are similar to POSH RE-
QUEST . In this case, however, the tag of the nonce is in-
terrogative, since the ciphertext is used for asking I whether
or not she agrees on M and is willing to authenticate with J.
This tagging disambiguates whether the ciphertext is used as
challenge (as in SOPH/SOSH) or response (as in POSH).
makes the application of the rule deterministic.
POSH COMMIT After having received the above described ci-
phertext and checked the freshness of n, J accepts the au-
thentication request from I and authenticates M. The check
of n is formalized by removing the atomic effect f resh(n),
previously added by NEW NAME. This ensures that n is not
checked again.
SOPH/SOSH CONFIRM I may conﬁrm her willingness to authen-
ticate M with J by publishing the nonce a just received. As
mentioned above, only terms with type Un can be sent as
cleartext on the network: the rule casts the type of a from
nonce(I, J, M) to Un, while asserting the corresponding run2.
2Notice that the rule is nondeterministic since the nonce is not in-
dicated in the run primitive. If more than one nonce is present, one
Table 5 Authentication Rules
Encryption Rules
POSH REQUEST
Γ (cid:15) N, M, (cid:1)M : Un
Γ (cid:15) K : T
I;Γ (cid:15) {Id(Id),C(N), Auth(M), (cid:1)M}K : enc(run(I, J, M))
T,C, Id as in POSH(I, J)
SOPH/SOSH INQUIRY
Γ (cid:15) N : nonce(I, J, M)
Γ (cid:15) M, (cid:1)M : Un
Γ (cid:15) K : T
T,C, Id as in SOPH/SOSH(I, J)
J;Γ (cid:15) {Id(Id),C(N), Auth(M), (cid:1)M}K : enc((cid:14))
POSH(I, J)
T
C
Id
keysym(I, J) Claim I
keysym(I, J) Verif
J
keypriv(I)
Verif
J
SOPH/SOSH(I, J)
T
C
keysym(I, J) Claim?
keysym(I, J) Verif?
keypub(I)
Verif?
Id
I
J
J
SYMMETRIC ENCRYPTION
∀i ∈ [1, n]
Γ (cid:15) Mi : Un
I;Γ (cid:15) {M1, . . . ,Mn}K : enc((cid:14))
Γ(K) ∈ {Un, keysym(I, J)}
ASYMMETRIC ENCRYPTION
∀i ∈ [1, n]
Γ (cid:15) Mi : Un
I;Γ (cid:15) {|M1, . . . ,Mn|}K : enc((cid:14))
Γ(K) ∈ {Un, keypriv(I), keypub(J)}
Secret Nonce Typing
Authentication
SOPH/SOSH CONFIRM
I;Γ, a : nonce(I, J, M),Γ(cid:11) (cid:15) run(I, J, M).S : e
I;Γ, a : Un,Γ(cid:11) (cid:15) S : e
POSH COMMIT
dec{Id(Id),C(n), Auth(M), (cid:1)M}K ∈ e
J;Γ (cid:15) S : e
Γ (cid:15) n, M, (cid:1)M : Un
Γ (cid:15) K : T
T,C, Id as in POSH(I, J)
J;Γ (cid:15) commit(J, I, M).S : e + [ f resh(n)]
SOPH/SOSH COMMIT
J;Γ (cid:15) S : e
Γ (cid:15) n : nonce(I, J, M)
J;Γ (cid:15) commit(J, I, M).S : e + [ f resh(n, I, J, M)]
in(n) ∈ e or dec{n, (cid:1)M}K ∈ e
SOPH/SOSH COMMIT When J receives back the nonce n, either
as cleartext or as ciphertext, and checks its freshness, he au-
thenticates I and M. As before, removing f resh(n, I, J, M)
from the ﬁnal effect formalizes the linearity of nonce-check.
3.4 Typing Rules for Run-Time Behaviour
The typing rules in Table 6 are never used for the static analysis
of a protocol. Instead, they are required in the proof that types are
preserved at run-time.
TRUSTED and UNTRUSTED CIPHERTEXTS give the type Un to
ciphertexts, allowing trusted principals to freely send and receive
them. Notice that ciphertexts do not appear in the ρ-spi calcu-
lus syntax: they can be created either by the enemy or by trusted
principals by means of encryption primitives. Ciphertexts created
by a trusted principal I are regulated by the typing judgment I;Γ (cid:15)
{M1, . . . , Mn} : enc( f ), while the ones created by the enemy are
regulated by the ρ-spi calculus semantics (remember that each un-
tagged term known by the environment has type Un). To motivate
the sub-typing rule SECRET NONCE, let us consider the following
protocol, using a SOPH nonce-handshake:
needs to "guess" which is going to be used ﬁrst.
B → A :
A → B :
{Id(B), Auth(m), Verif?(n)}Pub(kA)
n
Notice that A does not know whether the ciphertext has been cre-
ated by B or by the enemy (remember: the enemy knows all the
public keys). In the former case, the type of the nonce n is nonce(A,
B, M), in the latter it is Un. Hence, at run-time, the variable with
type nonce(A, B, M) might be substituted by a term with type Un.
Moreover, the commit of B is typed by SOPH/SOSH COMMIT ,
which requires the nonce to have type nonce(B, A, M). However,
the type of n was cast by A to Un, in order to send back that nonce.
The sub-typing rule SECRET NONCE addresses both of these is-
sues.
Table 6 Run-Time Typing rules
(cid:2)
The function [M] is deﬁned as follows:
We omit the asymmetric version of UNTRUSTED CIPHERTEXT and TRUSTED CIPHERTEXT.
[M]
[C(M)] = [M] otherwise
= M if M is either a name or a ciphertext or a key pair
TRUSTED CIPHERTEXT
I;Γ (cid:15) {M1, . . . ,Mn}
Γ (cid:15) {M1, . . . ,Mn}
M0 : enc( f )
M0
: Un
UNTRUSTED CIPHERTEXT
∀i ∈ [0, n] Γ (cid:15) [Mi] : Un
Γ (cid:15) {M1, . . . ,Mn}
: Un
M0
Γ (cid:15) M : Un
SECRET NONCE
Γ (cid:15) Un <: nonce(A, I, M)
3.5 Safety Theorem
Our main result states that if a process can be typed with empty
effect and empty typing environment, then every trace generated by
that process is safe.
Theorem 1 (Safety) If (cid:14) (cid:15) P : [], then P is safe.
Interestingly, our analysis is strongly compositional, as stated by
the following theorem. Let keys(k1, . . . ,kn) denote a sequence of
key declarations.