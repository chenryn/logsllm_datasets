ğºğ‘Ÿğ‘›ğ‘‘, ğ¸(ğ‘¡ ğ‘¦ğ‘ğ‘’)
1
2
ğ‘Œ ğ‘Ÿğ‘›ğ‘‘)
Figure 5: Proof to receive a message in our tree-unlinkable
scheme. This function constructs a proof that the provided ci-
phertexts to be used for blind issuance of forwarding credentials
encrypt either 1) the same message and re-randomized source
as are committed to in ğ¶ğ¹ , or 2) commit to the same message as
committed to in ğ¶ğ´ and a re-randomization of ğ‘ ğ‘Ÿğ‘.
Users also store an authoring credential ad, which has the same
form as the forwarding data, but for an unused message âŠ¥. The au-
thoring data is given to the user by the platform when the new user
is created. The authoring data is used by the user to prove creden-
tials on a new message so that new messages are indistinguishable
from forwarded messages to the platform.
Once a user gets forwarding data after receiving a message, the
forwarding data stays constant for the rest of its sending activity for
that message. The MAC is presented blindly during future forwards,
and so the possession of a valid forwarding credential can be proved
to a platform multiple times unlinkably.
Sending a message. To send a message, the sender provides au-
thoring information ğ¶ğ´ and forwarding information (ğ¶ğ¹ , ğ¶â€²
ğ¹ , ğœ‹ğ‘, ğœ‹ğ‘Ÿ).
Only one of these is filled with useful information, depending on
the type of message that the user wants to send. If the message
is an authored message, the authoring information ğ¶ğ´ is for the
actual message plaintext, and the forwarding information is for an
unused message âŠ¥ (created from the userâ€™s authoring data ad). If
the message is a forward, the message contents are swapped, and
the relevant forwarding data fd is used to create the forwarding
information.
The authoring information is a commitment, ğ¶ğ´, to the Zğ‘ rep-
resentation of the message, while the forwarding information is
constructed in the present sub-protocol (Figure 4) and consists of
ğ¶ğ¹ , which is a commitment to the forwarded messageâ€™s Zğ‘ rep-
resentation and source ciphertext, as well as ğ¶â€²
ğ¹ , which is a new
commitment to the same message and a re-randomization of the
source ciphertexts. The forwarding information also includes ğœ‹ğ‘, a
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1493return âŠ¥
ğ‘ƒğ‘›ğ‘’ğ‘¤ (sk, U)
if ğ‘ˆğ‘– âˆˆ U :
ğ‘Ÿ â†R Zğ‘, (ğ¸1, ğ¸2) â† (ğºğ‘Ÿ , ğ‘ˆğ‘–ğ‘Œ ğ‘Ÿ)
(ğœ, ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’) â† issue(âŠ¥, ğ¸1, ğ¸2, skğ‘€ğ´ğ¶)
ğœ, ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’, (ğ¸1, ğ¸2)
ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk, md)
if !blindVf(ğœ‹ğ‘, ğ¶ğ¹ , skğ‘€ğ´ğ¶)
âˆ¨ !Vf(ğœ‹ğ‘Ÿ , ğ¶ğ¹ , ğ¶â€²
ğ¹) : return âŠ¥
ğ‘Ÿ â†R Zğ‘, ğ‘† â† (ğ‘ˆğ‘ , md)
ğ‘ ğ‘Ÿğ‘ â† (ğºğ‘Ÿ , ğ‘†ğ‘Œ ğ‘Ÿ)
return (ğ‘ğ‘‘ = (ğ¶ğ´, ğ‘ ğ‘Ÿğ‘, ğ¶â€²
ğ¹), ğ‘’)
ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk, md)
RecMsg(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘’, pk = ğ‘Œ)
ğ‘ˆğ‘Ÿğ‘’ğ‘
ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk = (ğ‘¦, skğ‘€ğ´ğ¶), ğ‘ğ‘‘)
ğ‘ğ‘‘
(ğ¶ğ´, ğ‘ ğ‘Ÿğ‘, ğ¶ğ¹) â† ğ‘ğ‘‘
(ğ‘š, ğ‘œğ´, ğ‘œğ¹) â† receive(ğ‘’, ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ)
(ğ‘§ğ´, ğ‘‘ğ´) â† ğ‘œğ´
if ğ¶ğ´ â‰  ğºğ‘§ğ´
ğ‘¦3 ğºğ‘‘ğ´
(ğ‘§ğ¹ , ğ‘‘ğ¹ , ğ¸1, ğ¸2) â† ğ‘œğ¹
(ğ¶ğ‘‘, ğ¶ğ¸1, ğ¶ğ¸2) â† ğ¶ğ¹
if ğ¶ğ‘‘ â‰  ğºğ‘ğ¹
return âŠ¥
ğ‘¦3 ğºğ‘‘ğ¹
âˆ¨ ğ¶ğ¸2 â‰  ğºğ‘§ğ¹
ğ‘‘ âˆ¨ ğ¶ğ¸1 â‰  ğºğ‘§ğ¹
ğ‘¦1 ğ¸1
return âŠ¥
ğ‘¦2 ğ¸2 :
ğ‘‘
:
if ğ‘‘ = ğ‘‘ğ´ â‰  âŠ¥ âˆ§ ğ‘‘ğ¹ = âŠ¥ :
ğ‘¡ ğ‘¦ğ‘ğ‘’ â† ğ´ //new message
elseif ğ‘‘ğ´ = âŠ¥ âˆ§ ğ‘‘ğ¹ = ğ‘‘ â‰  âŠ¥ :
//forwarded message
ğ‘¡ ğ‘¦ğ‘ğ‘’ â† ğ¹
return âŠ¥
else :
//prove rerandomizations commit to ğ‘œğ‘ or ğ‘œ ğ‘“
ğ‘œ â† redeem(ğ¶ğ´, ğ‘ ğ‘Ÿğ‘, ğ‘œğ´, ğ¶ğ¹ , ğ‘œğ¹ , ğ‘¡ ğ‘¦ğ‘ğ‘’, pk)
(ğœ‹, ğ‘–ğ‘›ğ‘“ ğ‘œ, â„, ğ¸â€²
ğœ‹, ğ‘–ğ‘›ğ‘“ ğ‘œ
2) â† ğ‘œ
1, ğ¸â€²
(ğ¶ğ´, ğ‘ ğ‘Ÿğ‘, ğ¶ğ¹) â† ğ‘ğ‘‘
//verify proof that rerandomizations are valid
if !Vf(ğœ‹, ğ‘–ğ‘›ğ‘“ ğ‘œ, ğ¶ğ´, ğ‘ ğ‘Ÿğ‘, ğ¶ğ¹) :
return âŠ¥
//blindly issue MAC on rerandomized values
(ğ‘ğ‘¡ğœ , ğœ‹) â† blindIssue(ğ‘–ğ‘›ğ‘“ ğ‘œ, skğ‘€ğ´ğ¶)
ğ‘ğ‘¡ğœ , ğœ‹
//verify proof that the new MAC is valid
ğœ â† Vfğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ (ğœ‹, ğ‘ğ‘¡ğœ , ğ‘–ğ‘›ğ‘“ ğ‘œ, â„)
if ğœ == âŠ¥ : return âŠ¥
return (ğ‘š, fd = (ğ» (ğ‘š), (ğ¸â€²
Report(ğ‘š, pk = ğ‘Œ)
ğ‘ˆğ‘Ÿğ‘’ğ‘ (fd)
//prove knowledge of valid fd
ğ‘œğ‘¢ğ‘¡ â† present(fd, pk)
1, ğ¸â€²
2), ğœ)) //(m, fd) used to forward the message
ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk = (ğ‘¦, skğ‘€ğ´ğ¶))
KGen(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ )
(ğ‘¦, ğ‘Œ â† ğº ğ‘¦) â†R KGenP (ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ )
skğ‘€ğ´ğ¶ â† KGenğ‘€ğ´ğ¶ (ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ )
return (pk = ğ‘Œ , sk = (ğ‘¦, skğ‘€ğ´ğ¶))
newUser(ğ‘ˆğ‘–, sk, pk = ğ‘Œ)
ğ‘ˆğ‘›ğ‘’ğ‘¤
U.ğ‘ğ‘‘ğ‘‘(ğ‘ˆğ‘–)
return U
ğ‘–ğ‘›ğ‘“ ğ‘œ â† (âŠ¥, ğ¸1, ğ¸2)
if Vf(ğœ, ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’, ğ‘–ğ‘›ğ‘“ ğ‘œ) :
ad â† (ğ» (âŠ¥), ğœ, (ğ¸1, ğ¸2))
return ad
return âŠ¥
AuthMsg(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , pk = ğ‘Œ)
ğ‘ˆğ‘ğ‘¢ğ‘¡â„(ğ‘šğ‘ ğ‘”)
ğ‘š, ad â† ğ‘šğ‘ ğ‘”
//create proof sender has valid authoring data
ğ‘œğ‘¢ğ‘¡ â† present(ad, pk)
(ğ¶ğ¹ , ğ¶â€²
ğ‘§ â†R Zğ‘, ğ‘‘ â† ğ» (ğ‘š)
ğ‘œğ´ â† (ğ‘§, ğ‘‘)
ğ¶ğ´ â† ğºğ‘§
ğ‘¦3ğºğ‘‘
//send via underlying msg scheme
ğ‘’ â† send((ğ‘š, ğ‘œğ´, ğ‘œğ¹), ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ)
ğ‘’, ğ¶ğ´, ğ¶ğ¹ , ğ¶â€²
ğ¹ , ğ‘œğ¹ , ğœ‹ğ‘, ğœ‹ğ‘Ÿ) â† ğ‘œğ‘¢ğ‘¡
ğ‘‘ //commit to new message
ğ¹ , ğœ‹ğ‘, ğœ‹ğ‘Ÿ
return ğ‘’
FwdMsg(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , pk = ğ‘Œ)
ğ‘ˆğ‘“ ğ‘¤ğ‘‘ (ğ‘šğ‘ ğ‘”)
(ğ‘š, fd) â† ğ‘šğ‘ ğ‘”
ğ‘œğ‘¢ğ‘¡ â† present(fd, pk)
(ğ¶ğ¹ , ğ¶â€²
ğ‘§ â†R Zğ‘, ğ¶ğ´ â† ğºğ‘§
ğ‘œğ´ â† (ğ‘§,âŠ¥)
ğ‘’ â† send((ğ‘š, ğ‘œğ´, ğ‘œğ¹), ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ)
ğ‘’, ğ¶ğ´, ğ¶ğ¹ , ğ¶â€²
ğ¹ , ğ‘œğ¹ , ğœ‹ğ‘, ğœ‹ğ‘Ÿ) â† ğ‘œğ‘¢ğ‘¡
ğ‘¦3ğºâŠ¥
ğ¹ , ğœ‹ğ‘, ğœ‹ğ‘Ÿ
ğ‘‘
return ğ‘’
ğ‘œğ‘¢ğ‘¡
if !blindVf(ğœ‹ğ‘, ğ¶ğ¹ , skğ‘€ğ´ğ¶)
âˆ¨!Vf(ğœ‹ğ‘Ÿ , ğ¶ğ¹ , ğ¶â€²
ğ¹) : return âŠ¥
ğ‘Ÿ â†R Zğ‘, ğ‘† â† (ğ‘ˆğ‘ , md)
ğ‘ ğ‘Ÿğ‘ â† (ğºğ‘Ÿ , ğ‘†ğ‘Œ ğ‘Ÿ)
return (ğ‘ğ‘‘ = (ğ¶ğ´, ğ‘ ğ‘Ÿğ‘, ğ¶â€²
ğ¹), ğ‘’)
Figure 6: Protocols for Scheme 2.
ğ¹ , ğ‘œğ¹ , ğœ‹ğ‘, ğœ‹ğ‘Ÿ) â† ğ‘œğ‘¢ğ‘¡
ğ¶ğ¹ , (ğ¶â€²
if !(blindVf(ğœ‹ğ‘, ğ¶ğ¹ , skğ‘€ğ´ğ¶) âˆ§ Vf(ğœ‹ğ‘Ÿ , ğ¶ğ¹ , ğ¶â€²
ğ¹)) :
return âŠ¥
(ğ‘§, ğ‘‘â€², ğ¸1, ğ¸2) â† ğ‘œğ¹
ğ‘‘ â† ğ» (ğ‘š)
if ğ¶â€²
ğ¹ â‰  (ğºğ‘§
ğ‘‘ , ğºğ‘§
âˆ¨ ğ‘‘ â‰  ğ‘‘â€² âˆ¨ ğ‘‘ = âŠ¥ :
ğ‘¦3ğºğ‘‘
return ğ¸2/ğ¸ğ‘¦
1
ğ‘¦1 ğ¸1, ğºğ‘§
ğ‘¦2 ğ¸2)
return âŠ¥
//decrypt to recover (ğ‘ ğ‘Ÿğ‘, md)
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1494ğ‘¦3ğºğ‘‘
ğ‘¦3ğºğ‘‘
ğ‘‘
proof that the user holds a valid MAC on the values stored in ğ¶ğ¹ ,
and ğœ‹ğ‘Ÿ , which proves that ğ¶â€²
ğ¹ commits to the same message and
(re-randomized) source as ğ¶ğ¹ . We note that these two proofs can
easily be combined into a single statement, but weâ€™ve written them
out separately to distinguish between scheme-specific statements
and the standard MAC issuance proof.
The authoring commitment to a hash of a message ğ‘‘ âˆˆ Zğ‘ has the
form of a standard Pedersen commitment [24] with bases ğºğ‘¦3 and
for a random ğ‘Ÿ â†R Zğ‘. A forwarding commitment
ğºğ‘‘: ğ¶ğ´ = ğºğ‘Ÿ
takes the form of a multi-attribute Pedersen commitment on ğ‘‘
and two group elements ğ¸1 and ğ¸2 with bases ğºğ‘¦3, ğºğ‘¦1, ğºğ‘¦2, ğºğ‘‘:
ğ‘‘). Hashing the plaintext to an element
ğ¶ğ¹ = (ğºğ‘Ÿ
in Zğ‘ ensures that these schemes are binding without the need
for an additional group element to fix the opening to a particular
value of ğ‘Ÿ. We note that this structure can easily be extended to
commit to multiple additional attributes that may be required to
store additional metadata.
ğ‘¦2ğ¸2, ğºğ‘Ÿ
ğ‘¦1ğ¸1, ğºğ‘Ÿ
ğ¹ , ğ‘ ğ‘Ÿğ‘ to the receiver.
The sending user encrypts openings to ğ¶ğ´ and ğ¶â€²
ğ¹ alongside the
message plaintext and passes that information on to the receiver.
Processing a message. To process a sent message, the platform
first checks that the proofs ğœ‹ğ‘ and ğœ‹ğ‘Ÿ are valid for the provided
commitments. If this is the case, it creates a new encryption ğ‘ ğ‘Ÿğ‘
of the sending userâ€™s identity and some associated metadata to be
used if the message is new. It then passes along the platform data
ğ‘ğ‘‘ = ğ¶ğ´, ğ¶â€²
Receiving a message. During the receipt of a message, the receiver
presents encryptions of a message plaintext and ğ‘ ğ‘Ÿğ‘ ciphertext and
proves that these are either (re-randomizations of) the forward-
ing information committed to in ğ¶â€²
ğ¹ or of the authored message
committed to in ğ¶ğ´ and the new ğ‘ ğ‘Ÿğ‘ ciphertext. The platform then
blindly issues the receiver a new MAC on those attributes. The
helper function redeem (Figure 5), is used by the receiver to con-
struct a proof to the platform that the values it would like to get a
MAC on are valid.
Reporting a message. To report a message, a user presents the
platform with the message plaintext, a re-randomization of the
source ciphertext it would like to report, and a proof that it has
a valid credential on those values. This proof is created in the
same manner as when sending a message by calling the helper
function present (Figure 4). After verifying the proof, the platform
can decrypt the ciphertext to reveal the identity of the source.
Security. We prove the following theorems in Appendix C.
Theorem 5.1. Assuming that the MAC of [5] satisfies blind issuance
and anonymity as defined in [5], the platformâ€™s El Gamal encryption
scheme is CPA-secure, the proof system employed is zero-knowledge,