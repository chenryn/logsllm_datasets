Object
Object
JTOC
启动映像
Boot Record
启动映像管理器
0x00000000
图
110-4：JikesRVM的运行时内存配置
在图10-4中可以看到许多关键项：
启动映像管理器
启动映像管理器和它的栈由负责载入启动映像的加载器组成。
本机库
类库使用的本机库所需要的内存。这将在10.5.7节进一步讲述。
MMTK空间
有不同的垃圾收集堆供MIMTK使用来支持运行的应用程序。
根映射
1147
---
## Page 1149
垃圾收集器在启动映像中可获得的域的信息。在随后的10.5.9节将
进一步讲述。
代码映像
分别从Java内容表和类型信息块中可以直接获得的静态方法和虚方
法的可执行代码。代码写入了单独的启动映像区域以提供内存保护
的支持。
数据映像
数据映像是通过先记录启动记录和Java内容表然后对Java内容表可
获得的对象进行移动所创建的。利用Java的反射API，这些对象移入
自举M中。对象移人的顺序会影响位置，由此影响性能，所以，
这个移入机制是可配置的（Rogers等2008）。
Java内容表
正如先前在10.4.1节中所述，Java内容表负责保存字和静态的域值。
移动Java内容表产生启动映像。
启动记录
位于数据映像开头部分的包含在启动映像管理器和JikesRVM之间共
享数据的表。这些值在自举期间通常不能确定。
10.4.3编译原生类并填充Java内容表
原生类是必须构建到启动映像中以让它运行的类的集合。最重要的
原生类是负责启动虚拟机的orgjikesrvmVM。如果某些类不是启动
映像的一部分，那就不是原生类，因而就是引用的。当一个引用的
对象在运行时被访问时，会导致类加载器加载并链接这个引用的
类。原生类的清单是在自举期间通过搜索目录和读取一个明确要编
译的类的清单来生成的。这个明确的清单对数组类型特别重要。通
过重复编译和增加构建到启动映像中的类，就可以能生成原生类的
清单。但是，这会显著地增加构建JikesRVM的时间。一个建议的替
代方案是使用Java的annotation来标示哪些是原生类。
在移动对象图和记录启动映像之前，启动映像记录器会编译原生
类。编译一个原生类涉及用JikesRVM的类加载器加载它的类，这个
1148
---
## Page 1150
类加载器会自动地在Java内容表和类型信息块中分配必需的空间，
然后遍历所有的方法并用JikesRVM的一个编译器编译它们。因为这
全是纯Java代码，启动映像记录器利用Java的并发API来尽可能地并
行执行这个任务。一旦核心的原生类编译完成，主机JVM堆中的对
象图就提供了充足的功能让JikesRVM启动自身、分配额外的对象、
开始载入和执行用户类。为了完成这个自举过程，核心对象图就利
用主机JVM提供的Java的反射API的能力进行移动并记录到磁盘上
JikesRVM的对象模型中。
10.4.4启动映像管理器和VM.boot
正如10.4节所述，启动映像管理器负责把编译后的映像载入内存。
这种方式的具体细节根据操作系统而改变，但是，这些映像都设置
成按请求分页载入内存。按请求分页的意思是启动映像中的页保持
在磁盘上，直到需要它们。
一旦载入内存，启动映像管理器初始化启动记录，然后载入机器寄
存器来把执行移交给JikesRVM的方法orgjikesrvm.VM.boot（或简写
的VM.boot）。JikesRVM负责所有的内存布置，使高效的垃圾收集
技术和有效处理Java异常的一个栈体制成为可能（参见后面的10.5.4
节）。一旦进入VM.boot方法，就需要专门的封装器在启动映像管
理器中的本机代码和C库之间进行传递（这些将在随后的10.5.7节进
一步讲述）。
VM.boot的工作是确保这个VM处于执行程序的就绪状态。它通过初
始化在记录启动映像时不能初始化的那些RVM组件来做到这一点。
一些组件必须显式地启动一例如，垃圾收集器。其余的组件是那些
由于在自举程序和JfikesRVM类文件之间有冲突而没有完全写人启动
映像的小部分原生类。为了初始化这些类，必须运行这些类的静态
初始化方法。初始化线程系统是VM.boot方法的一个重要部分。它
创建必须的垃圾收集线程、一个用来运行对象的finalizer方法的线程
和负责自适应优化系统的线程。还会创建一个调试器线程，但只有
当操作系统给JikesRVM发送一个信号时这个线程才会安排执行。最
后才创建并开始执行的线程是负责运行这个Java应用程序的主线
程。
10.5运行时组件
1149
---
## Page 1151
前面一节讲述了使得JikesRVM准备好执行。在本节中，我们看一些
JikesRVM主要的运行时组件，从直接负责执行Java字节码的组件开
始，然后看一些支持执行的其他虚拟机子系统。
10.5.1基础的执行模型
JikesRVM不包括解释器：所有的字节码都必须通过JikesRVM的一
个编译器转变为本机机器码。这种编译的单位是方法，而方法的编
译延迟到其第一次由程序调用时才进行。最初的编译由JikesRVM的
化编译器。随着执行的继续，JikesRVM的自适应系统监控程序的执
行以发现程序的热点并用JikesRVM的优化编译器选择性地重新编译
它们。这是一个可以生成更高质量代码的成熟得多的编译器，但
是，在编译时和编译内存使用上比基线编译器的开销大很多。
这种选择性优化的模式不是JikesRVM所特有的。所有现代的生产
JVM都依赖某种形式的选择性优化把编译资源优化成将产成最大益
处的部分程序方法。正如先前所述，选择性优化是使成熟的优化编
译器能够作为动态编译器进行部署的关键。
10.5.2自适应优化系统
从架构而言，自适应优化系统实现为一组松散的同步实体。因为它
是用Java实现的，我们能够利用内建的语言特性（例如线程和监视
器）来构建代码。
随着程序执行，基于定时器的样例由运行的Java线程累积入取样线
程。两种类型的概要数据会收集起来：当前执行的方法的样例（为
了指导识别优化编译的候选方法）和调用栈的样例（为了识别重要
的概要数据定向内联的调用图边界）。当取样缓冲充满时，低级别
的概要代理给一个高级别的Orgamizer（用单独的Java线程实现的）
发出一个信号来总结和记录原始的概要数据。一个Controller线程会
周期性地分析当前的概要数据并利用一个分析模型来确定哪些方法
（如果有）应该安排进行优化编译。这些决策利用来自“滑雪板租
赁（skirental）”[l-问题在线算法的一个标准2-竞争解决方案所制定
的。一个方法没有选定进行优化，直到优化它所预期的好处（将来
调用中的加速）超过预期的成本（编译时间）。这些成本效益计算
是通过结合在线概要数据（候选方法在当前的执行过程中取样的赖
率）和（离线的）描述预期的相对加速与优化编译器的每个优化级
1150
---
## Page 1152
别的编译成本的经验驱动的常量来进行的（众所周知的编译器的
DNA)。
[L].查看http://en.wikipedia.org/wiki/Ski_rental_problem来了解更多的
信息。
10.5.3优化编译
作为一个元循环运行时，JikesRVM自己进行编译而不是依赖另一个
编译器以确保良好的性能。元循环创建了一个有效力的循环：我们
要在虚拟机的实现中编写清楚、雅观和高效的Java代码，这个强烈
的愿望驱使我们发展创新的编译器优化和运行时实现技术。在这一
节中，我们将介绍优化编译器，它由许多状态组成，这些状态归并
为三个主要阶段：
1.高级中间表示（HIR）
2.低级中间表示（LIR）
3.机器级中间表示（MIR）
所有这些阶段都在一个由基础块组成的控制流程图上进行，这些基
础块由如图10-5所示的一些指令组成。一条指令由几个操作数和一
个运算符组成。因为运算符逐渐变得更加针对特定的机器，所以，
运算符在这个指令的生命周期内会发生改变（变异）。操作数按定
义的操作数和使用的操作数来进行组织。主要类型的操作数包括固
定操作数和由寄存器编码的操作数。基础块是分支指令只出现在末
端的一列指令。有专门的指令标识基础块的开始和结尾。控制流程
图通过边界线连接着不同的代码区域。异常会进行特殊处理，这在
后面会进行讨论。由于编译的三个主要阶段都使用相同的基础中间
显示，许多优化都应用于不止一个阶段。接下来我们介绍这三个编
译器阶段的主要任务。
1151
---
## Page 1153
指令
运算符
定义的
使用的
操作数
操作数
Add
11....
t2,t3...
基础块
控制流程图
Label
分支指令
边界线
基础块
图10-5：优化编译器的中间表示的概览
高级中间表示
高级中间表示由一个名为BC2IR的编译器阶段生成，它获取字节码
作为输入。这个初始阶段基于字节码操作数栈进行传播。这个栈是
模拟的，字节码合在了一起来生成HIR指令，而不是生成分开的操
作。除了用一个极大的符号寄存器来代替一个表达式栈之外，HIR
级的运算符等同于字节码中执行的运算。
一旦指令形成，它们就转变为更简单的操作（如果更简单的操作存
在）。在这之后，其余的调用指令都考虑内联。BC2IR阶段的主要
部分进行递归地编写，所以，内联递归地使用BC2IR阶段。
本地优化在HIR阶段进行。本地优化考虑降低基础块的复杂性。考
虑一个基础块的时候，这个基础块内的依赖也会考虑。这简化了编
译器阶段，不必考虑分支和循环的结果，这些情况会引入不同种类
的数据依赖。本地优化包括：
常量传播
传播常量值以避免把它们放入寄存器中。
副本传播
1152
---
## Page 1154