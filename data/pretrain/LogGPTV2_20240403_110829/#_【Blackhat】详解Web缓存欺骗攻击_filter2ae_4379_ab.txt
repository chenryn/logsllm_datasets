这种正则表达式不仅会匹配正常的URL（即“
”），也会匹配不存在的URL（如“ ”）。
如果正则表达式尾部使用了“$”符，那么就不会匹配这种恶意URL地址。
**6.3 ASP.NET**
ASP.NET框架中有个内置的功能，叫做FriendlyURLs，这个功能的主要目的是使URL看起来更加“整洁”同时也更加友好。当用户访问“
”时，服务器会删掉尾部的扩展名，将用户重定向至“https://www.example.com/home”。
我们可以在Route.config文件中配置这个功能，在ASP.NET应用中，这个功能默认情况下处于启用状态。
启用FriendlyURLs功能时，当用户通过“http://localhost:39790/Account/Manage.aspx”地址访问已有的Manage.aspx页面时，服务器会移除.aspx扩展名，显示页面内容。
在这种配置下，当用户访问“http://localhost:39790/Account/Manage.aspx/test.css”时，.aspx扩展名会被移除，用户会被重定向到“http://localhost:39790/Account/Manage/test.css”，此时服务器会返回404错误。这意味着当ASP.NET启用FriendlyURLs功能时，攻击条件无法满足。
虽然FriendlyURLs默认处于启用状态，但很多网站并没有使用这个功能。该功能可以在Route.config文件中关闭。
关闭该功能后，访问攻击URL地址时服务器会返回200 OK响应，并且会返回Manage.aspx页面的内容。
**七、现有的缓存机制**
攻击的第2个条件是web应用启用了Web缓存功能，并且会根据文件的扩展名来缓存，同时会忽略掉任何缓存头部。下面我们会以现有的某些缓存机制为例，介绍这些机制的缓存过程以及它们如何识别接收到的文件的类型。
**7.1 Cloudflare**
当来自web服务器的文件到达Cloudflare时，文件会经过两个阶段的处理过程。第一个阶段名为资格阶段（Eligibility
Phase），此时Cloudflare会检查目标站点是否设置了缓存功能，也会检查文件来源目录是否设置了缓存功能。如果检查通过（检查基本都会通过，这也是为什么网站一开始就使用Cloudflare服务的原因所在），那么Cloudflare服务器就会检查具体的URL地址是否以如下静态扩展名结尾：
class, css, jar, js, jpg, jpeg, gif, ico, png, bmp, pict, csv, doc, docx, xls,
xlsx, ps, pdf, pls, ppt, pptx, tif, tiff, ttf, otf, webp, woff, woff2, svg,
svgz, eot, eps, ejs, swf, torrent, midi, mid
如果URL地址的确以上述扩展名结尾，那么文件就会到达第二阶段的处理过程，即失格阶段（Disqualification
Phase），此时Cloudflare服务器会检查HTTP缓存头部是否存在。
不幸的是，当我们访问恶意URL地址时，web服务器会返回已有的动态页面的缓存头部，这意味着服务器很有可能会返回带有“no-cache”指令的文件。
幸运的是，Cloudflare存在一个名为“边缘缓存过期TTL（Edge cache expire
TTL）”的功能，这个功能可以用来覆盖任何已有的头部信息。将该功能设置为启用（on）状态时，服务器返回的带有“no-cache”指令的文件仍会被缓存下来。出于各种原因，在Cloudflare的建议下，该功能通常会处于启用状态。
**7.2 IIS ARR**
应用程序请求路由（Application Request Routing，ARR）模块可以为IIS带来负载均衡功能。
ARR模块提供的一个功能就是缓存功能。Web服务器可以通过负载均衡器设置缓存规则，以便将文件保存到缓存目录中。在创建新的缓存规则时，我们使用通配符和目标扩展名来定义待缓存的文件类型。当文件经过ARR处理时，ARR会根据文件对应的URL来匹配缓存规则。实际上，ARR会根据URL尾部的扩展名来识别文件类型。
此外，IIS ARR中还包含一个选项，可以忽略掉文件的缓存头部，导致该规则在任何情况下都适用。
如下图这个例子中，IIS ARR与两个web服务器相连接，并且根据配置会缓存所有的样式表和JavaScript文件。
如果客户端访问恶意URL（
），那么缓存目录中就会生成一个新的目录，目录名为welcome.php，在该目录中，会生成名为test.css的一个新的文件，该文件的内容为用户访问的welcome.php页面的内容。
**7.3 NGINX**
作为负载均衡服务器，NGINX服务器也可以提供缓存功能，来缓存从web服务器返回的页面。
我们可以通过NGINX配置文件来配置缓存规则。如果使用下图所示的配置文件，那么NGINX就会缓存特定类型的静态文件，并且会忽略这些文件的缓存头部。
当来自于web服务器的某个页面到达NGINX时，NGINX会搜索URL尾部的扩展名，根据扩展名识别文件的类型。
首先，缓存目录中没有缓存任何文件。
当经过认证的用户访问恶意URL时（http://www.sampleapp.com/app/welcome.php/test.css），用户的页面就会被缓存到缓存目录中。
接下来，未经认证的攻击者会访问恶意URL，此时NGINX服务器会返回已缓存的文件，文件中包含用户的隐私数据。
**八、缓解措施**
可以使用以下几种方法缓解此类攻击。
1、配置缓存策略，只有当文件的HTTP缓存头部允许缓存时，才会缓存这些文件。
2、将所有的静态文件保存到某个指定目录，并且只缓存这个目录。
3、如果缓存组件允许的话，需要将其配置为根据文件的具体内容来缓存文件。
4、配置web服务器，使其在处理诸如“http://www.example.com/home.php/nonexistent.css”的页面时，不会返回home.php的内容，而会返回404或者302响应。
**九、总结**
Web缓存欺骗攻击实施起来没有那么容易，但依然可以造成严重的后果，包括泄露用户的隐私信息、攻击者可以完全控制用户的账户等等。此前我们发现一些知名的网站会受到此类攻击影响，并且这些网站中绝大部分由最为常见的CDN服务商来提供服务。我们有理由相信，此时此刻仍有许多网站会沦为此类攻击的受害者。
虽然这份白皮书中只提到了可以满足web缓存欺骗攻击条件的几种技术，但还有其他许多web框架以及缓存机制存在脆弱性，攻击者可以使用类似技术发起攻击。
如果Web框架以及缓存机制可以创造条件来满足漏洞场景，那么我们认为这些Web框架及缓存机制本身并没有存在这类漏洞，它们的主要问题是脆弱性配置问题。
为了防御web缓存欺骗攻击，技术人员首先应当了解此类攻击发起的条件。此外，厂商应该有所作为，避免他们的产品符合攻击条件。以上要求可以通过禁用特定功能、更改默认设置及行为、提供警报信息以增强技术人员的警觉意识来实现。
**十、致谢**
感谢Sagi Cohen、Bill Ben Haim、Sophie Lewin、Or Kliger、Gil Biton、Yakir
Mordehay、Hagar Livne。
**十一、参考资料**
[1] RPO – The Spanner 博客。
[2] RPO gadgets – XSS Jigsaw 博客
[3] Django URL分发器
[4] NGINX缓存机制
[5] Web缓存欺骗攻击
[6] 针对PayPal主页的web缓存欺骗攻击
[7] Cloudflare blog的参考资料
[8] Akamai博客上的参考资料