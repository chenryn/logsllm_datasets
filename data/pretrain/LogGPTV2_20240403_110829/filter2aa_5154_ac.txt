    p a #=> [5, 4, 3, 2, 1]
    ```
- `a.sort`
- `a.sort!`
- `a.sort{|i, j| … }`
- `a.sort!{|i, j| … }`
    对数组 a 进行排序。排序方法可以由块指定。没有块时，使用 `` 运算符比较。
    ```ruby
    a = [2, 4, 3, 5, 1]
    a.sort!
    p a    #=> [1, 2, 3, 4, 5]
    ```
- `a.sort_by{|i| … }`
    对数组 a 进行排序。根据块的运行结果对数组的所有元素进行排序。
    ```ruby
    a = [2, 4, 3, 5, 1]
    p a.sort_by{|i| -i }    #=> [5, 4, 3, 2, 1]
    ```
# 数组与迭代器
迭代器是实现循环处理的方法，而数组则是多个对象的集合。在对这些对象进行某种处理，或者取出某几个对象时，都需要大量用到迭代器。
例如，对数组的各元素进行相同的操作时使用的 `each` 方法就是典型的迭代器。该方法会遍历数组的所有元素，并对其进行特定的处理。
此外，接收者不是数组的情况下，为了让迭代器的执行结果能作为某个对象返回，也会用到数组。其中 `collect` 方法就是一个具有代表性的方法。`collect` 方法会收集某种处理的结果，并将其合并为一个数组后返回。
```ruby
a = 1..5
b = a.collect{|i| i += 2}
p b    #=> [3, 4, 5, 6, 7]
```
在上面的例子中，接收者为范围对象，而结果则是数组对象。像这样，迭代器和数组就被紧密地结合在一起了。
# 处理数组中的元素
对数组中的元素进行处理时可以采取多种方法。
**使用循环与索引**
传统的方法是使用循环，也就是在遍历数组的同时，利用索引逐个访问数组元素。
例如，我们把数组的元素逐个取出来并输出。
```ruby
list = ["a", "b", "c", "d"]
for i in 0..3
  print "第", i+1,"个元素是",list[i],"。\n"
end
```
对数值数组的元素进行合计的例子
```ruby
list = [1, 3, 5, 7, 9]
sum = 0
for i in 0..4
  sum += list[i]
end
print "合计：",sum,"\n"
```
**使用 each 方法逐个获取元素**
数组中，通过 `each` 方法可以实现循环操作。下面，我们尝试使用 each 方法来改写
```ruby
list = [1, 3, 5, 7, 9]
sum = 0
list.each do |elem|
  sum += elem
end
print "合计：",sum,"\n"
```
但是，使用 `each` 方法时，我们并不知道元素的索引值。因此，当需要指定元素的索引值时，可以使用 `each_with_index` 方法。
```ruby
list = ["a", "b", "c", "d"]
list.each_with_index do |elem, i|
  print "第", i+1,"个元素是",elem,"。\n"
end
```
**使用具有破坏性的方法实现循环**
如果数组内各元素全部处理完毕后该数组就不需要了，那么我们就可以通过逐个删除数组元素使数组变空这样的手段来实现循环。
```ruby
while item = a.pop
  ## 对item 进行处理
end
```
假设在循环开始前已经有元素在数组 `a` 中。如果逐个删除数组 `a` 中的元素，就会对删除的元素进行处理。最后，当数组为空时，循环结束。
**使用其他迭代器**
Ruby 中实现了不少像 collect、map 方法这样一眼就能看出其作用的基本操作。当希望创建某种迭代器时，请翻阅 Ruby 参考手册，一般情况下在里面都能找到我们需要的迭代器。这样就不会因为花精力创建了一个 Ruby 本来就有的迭代器而感到失望了。
# 数组的元素
数组中可以存放各种各样的对象。除了数值、字符串外，我们还可以在数组对象中存放别的数组对象或散列对象等等。
**使用简单的矩阵**
下面我们来看看用数组来表示矩阵的例子。
数组的各个元素也可以是数组，也就是所谓的数组的数组，这样的形式经常被用于表示矩阵。
例如，我们试试用数组的数组这种形式来表示矩阵。
```
/1,2,3\
|4,5,6|
\7,8,9/
```
第 1 行为 `[1, 2, 3]`，第 2 行为 `[4, 5, 6]`，第 3 行为 `[7, ,8 , 9]`，把它们归纳为数组，如下所示。
```ruby
a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```
如果想取出元素 6，我们可以像下面这样做。
```ruby
a[1][2]
```
首先用 `a[1]` 表示 `[4, 5, 6]` 这个数组，然后再指定第 3 位的元素，这样就能达到我们的目的了。
**初始化时的注意事项**
把数组对象或者散列对象作为数组元素时，需要注意该对象初始化时的问题。
```ruby
a = Array.new(3, [0, 0, 0])
```
在上面的例子中，我们可能会以为 `a` 为 `[[0, 0, 0], [0, 0, 0], [0, 0, 0]]`，但实际却是另外一个结果
像下面那样，原本只是打算变更第 1 行的第 2 个元素，结果所有行的第 2 个元素都发生了改变。
```ruby
a = Array.new(3, [0, 0, 0])
a[0][1] = 2
p a    #=> [[0, 2, 0], [0, 2, 0], [0, 2, 0]]
```
为了解决这个问题，我们可以指定 `new` 方法的块和元素个数。程序调用与元素个数一样次数的块，然后再将块的返回值赋值给元素。每次调用块都会生成新的对象，这样一来，各个元素引用同一个对象的问题就不会发生了。
```ruby
a = Array.new(3) do
  [0, 0, 0]
end
p a    #=> [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
a[0][1] = 2
p a    #=> [[0, 2, 0], [0, 0, 0], [0, 0, 0]]
```
进行下述操作后，对应的元素的索引值就会被赋值给 `i`，这样就可以根据索引值初始化出不同的值了。
```ruby
a = Array.new(5){|i| i + 1 }
p a    #=> [1, 2, 3, 4, 5]
```
# 同时访问多个数组
接下来我们来看看用相同的索引值同时访问对多个数组时的情况。在代码中，合计三个数组中索引值相同的元素，并将结果保存在新数组（result）中。
```ruby
ary1 = [1, 2, 3, 4, 5]
ary2 = [10, 20, 30, 40, 50]
ary3 = [100, 200, 300, 400, 500]
i = 0
result = []
while i  [111, 222, 333, 444, 555]
```
使用 `zip` 方法可以程序变得更简单
```ruby
ary1 = [1, 2, 3, 4, 5]
ary2 = [10, 20, 30, 40, 50]
ary3 = [100, 200, 300, 400, 500]
result = []
ary1.zip(ary2, ary3) do |a, b, c|
  result  [111, 222, 333, 444, 555]
```
`zip` 方法会将接收器和参数传来的数组元素逐一取出，而且每次都会启动块。参数可以是一个也可以是多个。