ASCII诞生于此。后来施耐德电气`（SchneiderElectric）`收购了Modicon公司，并在1997年推出了ModbusTCP协议。
2004年，中国国家标准委员会正式把Modbus作为了国家标准，开启了Modbus为中国工业通信做贡献的时代。
MODBUS是一种应用层消息传递协议，位于OSI模型的第7级，提供在不同类型的总线或网络上连接的设备之间的客户端/服务器通信。自1979年以来，作为业界系列上的标准，MODBUS继续使数百万自动化设备能够进行通信。
MODBUS是一种请求/回复协议，提供功能代码指定的服务。 MODBUS功能代码是MODBUS请求/回复PDU的元素。 本文不对 modbus
协议的传输方式、错误检测方法、物理层方面等进行描述，仅对MODBUS内使用的功能代码进行简单介绍。
MODBUS功能码主要分为有效功能码、异常功能码和错误功能码。有效功能码有二十几种，但是一般使用上都以`1、2、3、4、5、6、15、16`等八种最为常用，以及另外特殊使用的20、21两种，此为General
Reference Register，绝大部份的Modbus设备并不会提供此Register。
MODBUS 本来想说很多的，但是发现官方有这方面的文档，因此就不在细说了
文档下载地址：见最下方链接  
英文版：
中文版
这个里面详细说明了 modbus 的功能码，相关工作原理等，有兴趣的可以下载下来研究一下。
# 0x03 实例分析
## 实例一：S7comm 协议分析
### 题目说明
分析 S7 流量中的异常，在异常数据包中找到 flag
### 题解
打开文件如下图：
由于题目已经说明是 S7 协议，因此可以排除掉非 S7 协议的内容：
由于包很多，不能确定使用了哪些PDU 类型，将该分组导出：
用以下脚本来判断使用的 PDU 类型和次数：
    #!/usr/bin/env python
    #encoding=utf-8
    import pyshark
    captures = pyshark.FileCapture("cotp.pcapng")
    pdu_types = {}
    for c in captures:
        for pkt in c:
            if pkt.layer_name == "cotp":
                if hasattr(pkt, "type"):
                    type = pkt.type
                    if type in pdu_types:
                        pdu_types[type] += 1
                    else:
                        pdu_types[type] = 1
    print(pdu_types)
确定使用了三种 PDU 类型功能码，分别为 0x0f（3696 次），0x0e（12 次），0x0d（8次）
上文中没有对 cotp 进行介绍，但其实也仅仅是功能和传输格式上的区别，这三种功能码说明如下：
#### PDU Type: DT Data (0x0f)：
主要用于数据传输，Parameter中含有 data 结构
#### PDU Type: CR Connect Request (0x0e)
主要用于发起连接请求
#### PDU Type: CC Connect Confirm (0x0d)
主要用于连接确认
从三种 PDU 协议功能码的出现频率来看，0x0d 和0x0e出现 flag 的概率最大，因此来分析这两种功能码：
注意到：
每一次发起请求连接对应着一次请求确认，在前三个协议包中，连续三次发起了请求，可能存在问题，查看发现：
在第三个包中，发现有意义的内容：NESSUS
又看了其他数据包的内容，并未发现有意义内容，因此该字符串即为 flag
## 实例二：modbus 协议分析
### 题目说明
没有给什么提示，就是单纯的协议分析题
### 题解
打开文件发现：
非正常的协议包，对比正常协议包发现是文件头尾被篡改，因此使用010 Editor编辑修改文件头和文件尾：
正常 pcap 包
下载文件的 pcap 包：
删除文件的头三个尾三个字节，修改后打开：
因为协议很多，其他协议内容不是本文的重点，这里只对 modbus 协议进行分析（实际上 flag 也就在 modbus里面），使用筛选器筛选出 modbus
协议，然后分组导出，使用以下脚本确定存在的功能码：
    #!/usr/bin/env python
    #encoding=utf-8
    import pyshark
    captures = pyshark.FileCapture("modbus-ics.pcapng")
    modbus_func_code = {}
    for c in captures:
        for modbus in c:
            if modbus.layer_name == "modbus":
                if hasattr(modbus, "func_code"):
                    type = modbus.func_code
                    if type in modbus_func_code:
                        modbus_func_code[type] += 1
                    else:
                        modbus_func_code[type] = 1
    print(modbus_func_code)
发现只存在功能码为 3 的协议包，共计 274 条。  
上文中也提到了，modbus 协议以`1、2、3、4、5、6、15、16`等八种最为常用，  
下表为 modbus 的功能码简单说明：
功能码为3 的主要作用是读取寄存器，因此我们只需要确定读取寄存器的内容，即可确定 flag。  
观察流量包：
[  
发现只要寄存器1的数据在不断变化，因此按照传输顺序提取寄存器1的数据并转成ASCII码，得到数据：
    0x39,0x65,0x32,0x33,0x32,0x61,0x62,0x39,0x65,0x30,0x63,0x32,0x65,0x31,0x37,0x33,0x35,0x39,0x64,0x37,0x61,0x64,0x37,0x61,0x64,0x65,0x61,0x30,0x61,0x33,0x30,0x37,0x31,0x38,0x65,0x00,0x33,0x35,0x32,0x66,0x63,0x36,0x31,0x31,0x33,0x66,0x64,0x62,0x61,0x33,0x32,0x36,0x64,0x34,0x39,0x38,0x37,0x37,0x63,0x37,0x33,0x38,0x33,0x34,0x35,0x34,0x65,0x37,0x00,0x61,0x65,0x62,0x66,0x62,0x61,0x34,0x35,0x32,0x33,0x63,0x64,0x66,0x30,0x33,0x64,0x64,0x66,0x65,0x38,0x65,0x66,0x38,0x64,0x66,0x36,0x32,0x30,0x66,0x66,0x35,0x30,0x00,0x61,0x33,0x64,0x65,0x62,0x39,0x65,0x65,0x32,0x37,0x32,0x35,0x37,0x36,0x33,0x33,0x66,0x35,0x39,0x30,0x35,0x37,0x63,0x35,0x36,0x35,0x34,0x64,0x66,0x66,0x65,0x36
使用以下脚本将其转化为字符串：
    #!/usr/bin/env python
    #encoding=utf-8
    data = 0x39,0x65,0x32,0x33,0x32,0x61,0x62,0x39,0x65,0x30,0x63,0x32,0x65,0x31,0x37,0x33,0x35,0x39,0x64,0x37,0x61,0x64,0x37,0x61,0x64,0x65,0x61,0x30,0x61,0x33,0x30,0x37,0x31,0x38,0x65,0x00,0x33,0x35,0x32,0x66,0x63,0x36,0x31,0x31,0x33,0x66,0x64,0x62,0x61,0x33,0x32,0x36,0x64,0x34,0x39,0x38,0x37,0x37,0x63,0x37,0x33,0x38,0x33,0x34,0x35,0x34,0x65,0x37,0x00,0x61,0x65,0x62,0x66,0x62,0x61,0x34,0x35,0x32,0x33,0x63,0x64,0x66,0x30,0x33,0x64,0x64,0x66,0x65,0x38,0x65,0x66,0x38,0x64,0x66,0x36,0x32,0x30,0x66,0x66,0x35,0x30,0x00,0x61,0x33,0x64,0x65,0x62,0x39,0x65,0x65,0x32,0x37,0x32,0x35,0x37,0x36,0x33,0x33,0x66,0x35,0x39,0x30,0x35,0x37,0x63,0x35,0x36,0x35,0x34,0x64,0x66,0x66,0x65,0x36
    ret=''
    for i in data:
        if i == 0:
            ret+='\n'
        else:
            ret += chr(i)
    print (ret)
可以得到四行字符串：
    9e232ab9e0c2e17359d7ad7adea0a30718e
    352fc6113fdba326d49877c7383454e7
    aebfba4523cdf03ddfe8ef8df620ff50
    a3deb9ee27257633f59057c5654dffe6
其中后面3个字符串可以直接破解md5，为`_love_this_game!`  
第一个发现多出来三个字符，观察发现在第 19 位置到第 24 位置，存在重复，删除多余的`d7a`，解密md5 可得`pcl_i`  
最终得到 flag 为`pcl_i_love_this_game!`
## 实例三：工控系统操作1
#### 要求
  * 调节某阀门开度，使其数值从35变到大于60，数值稳定、持续时间大于3秒。
  * 完成时间：30分钟  
#### 已知条件
  * 工控设备（虚拟机）的IP地址。
  * 设备支持Modbus通信协议，端口号502
  * PLC上有以下寄存器和线圈：  
**状态寄存器 0x0000~0x0009，供监视用。** 控制寄存器 0x000A~0x0014，供控制用。  
**状态线圈 0x0000~0x0009，供监视用。** 控制线圈 0x000A~0x0014，供控制用。  
** 附加寄存器 0x1000~0x1063，供提交FLAG用。
  * 阀门开度对应的状态寄存器为0x0008，对应的控制寄存器为0x0010。  
#### 完成标准  
操作成功后，附加寄存器0x1000~0x1007中会自动出现一组（8个）非0数值，这些数值对应的ASCII码即为任务完成的FLAG  
### 题解  
因为现在已经没有环境可以复现，因此只做简单说明。
这题刚开始很久没人做出来，后来官方给出了 tips：
  * 设定值的前提条件之一是系统处于维护模式
  * 控制寄存器0x00B是系统工作模式，值为3代表维护模式、值为0代表运行模式。
  * 为防止误操作，正常运行时工作模式是锁定的。如要改变工作模式，须先操作某控制线圈来进行解锁。
根据提示，我们首先要将进入系统维护模式，测试发现可改的线圈只有 15，因此需要调整 15 线圈，将其写入 Bool 型数据
true，然后调整工作模式，由11 切换到 3 ，再对控制器进行操作，在地址16写入值 为 100（其他也行，但是要大于
64），最后将系统的工作模式复原，先将线圈 11 改为 0，然后把控制器 15 改成 false 即可。  
最后可以从4096[+10]得到ascii，如下图：
转换后得到flag： 06E6B72D
## 实例三：工控系统操作2
#### 要求
  * 以正常通信方式打开PLC设备的报警使能开关；
  * 读取PLC系统生成的一条日志，分析日志中记录的报警时间。
  * 完成时间：30分钟。  
#### 已知条件
  * 工控设备（虚拟机）的IP地址。
  * 设备支持Modbus通信协议，端口号502。
  * PLC上有以下寄存器和线圈：  
**状态寄存器 0x0000~0x0009，供监视用。** 控制寄存器 0x000A~0x0014，供控制用。  
**状态线圈 0x0000~0x0009，供监视用。** 控制线圈 0x000A~0x0014，供控制用。  
** 状态寄存器 0x100~0x163，供报警日志用。
  * 报警日志使能开关的对应的控制线圈地址为0x000D
#### 完成标准
取得报警时间后，该时间值即为任务完成FLAG，格式为`yyyy-mm-dd hh:mm:ss`
### 题解
这题完成的基础是在上题的基础上。  
根据已知条件，首先打开日志使能开关，即将线圈13 改为 true  
Fuzzing了几个寄存器后，发现256[+100]能看到报错数值，因此读取该地址的数值：
    [18:25:10] [256] 25
    [18:25:12] [257] 13
    [18:25:16] [258] 84 T
    [18:25:19] [259] 224
    [18:25:23] [260] 92 /
    [18:25:26] [261] 115 s
    [18:25:29] [262] 119 w
    [18:25:32] [263] 105 i
    [18:25:34] [264] 116 t
    [18:25:37] [265] 99 c
    [18:25:39] [266] 104 h
    [18:25:41] [267] 32 space
    [18:25:44] [268] 49 1
    [18:25:46] [269] 51 3
    [18:25:50] [263] 105 i
    [18:25:56] [270] 49 1
    [18:25:59] [271] 32 space
    [18:26:02] [272] 116 t
    [18:26:06] [273] 114 r
    [18:26:08] [274] 105 i