title:High performance state-machine replication
author:Parisa Jalili Marandi and
Marco Primi and
Fernando Pedone
High Performance State-Machine Replication
Parisa Jalili Marandi
University of Lugano (USI)
Switzerland
Marco Primi
University of Lugano (USI)
Switzerland
Fernando Pedone
University of Lugano (USI)
Switzerland
Abstract—State-machine replication is a well-established ap-
proach to fault tolerance. The idea is to replicate a service on
multiple servers so that it remains available despite the failure
of one or more servers. From a performance perspective, state-
machine replication has two limitations. First, it introduces
some overhead in service response time, due to the requirement
to totally order commands. Second, service throughput cannot
be augmented by adding replicas to the system. We address
the two issues in this paper. We use speculative execution to
reduce the response time and state partitioning to increase the
throughput of state-machine replication. We illustrate these
techniques with a highly available parallel B-tree service.
I. INTRODUCTION
Computer systems are usually made fault tolerant through
replication. By replicating a service on multiple servers,
clients have the guarantee that even if some replicas fail,
the service is still available. However, once a service is
replicated, consistency among the replicas must be ensured.
State-machine replication is a well-known approach to repli-
cation. It achieves strong consistency by regulating how
client commands must be propagated to and executed by the
replicas [1], [2]. Command propagation can be decomposed
into two requirements: (i) every nonfaulty replica must
receive every command and (ii) no two replicas can disagree
on the order of received and executed commands. Command
execution must be deterministic: if two replicas execute the
same sequence of commands in the same order, they must
reach the same state and produce the same output.
State-machine replication improves service availability.
From a performance perspective it has two limitations. First,
it introduces some overhead in service response time with
respect to a client-server implementation. Second, service
throughput
is determined by the throughput of a single
replica—as discussed in the next section, replication can
provide limited throughout improvements under certain con-
ditions. Thus, if demand augments (e.g., more clients join
the system) it cannot be absorbed by adding replicas to
the compound. The increased response time stems from
the need to order client commands before they can be
executed: ordering commands is inherently more costly than
sending them directly to a server, as in a client-server setup.
The throughput limitation is a consequence of each replica
storing a full copy of the service state and handling every
command. In this paper we address each one of these issues.
To reduce the overhead in response time we rely on
speculative (or optimistic) execution, a technique that has
been used before in the context of replicated databases
(e.g., [3], [4]). The idea is to expose servers to a command
before its ﬁnal order has been established. As a result, the
execution of the command by the server and the execution
of the protocol that orders the command can overlap in time,
reducing service response time. The technique is speculative
because it only works if the order in which commands are
executed is conﬁrmed by the ordering protocol. If the order
is not comﬁrmed, the commands must be rolled back and
re-executed in the correct order (i.e., the order deﬁned by the
ordering protocol). We exploit this technique in the context
of Ring Paxos, a high throughput consensus protocol used to
implement state-machine replication. As we explain in the
paper, speculative execution in Ring Paxos does not depend
on network conditions (e.g., spontaneous message order),
and therefore is more advantageous than previous proposals
(e.g., [3], [4]).
We address the throughput limitation of state-machine
replication with a state partitioning strategy. In brief, we
allow applications to decompose their state into sub-states
and replicate each sub-state individually. Commands are
directed to and executed by the relevant partitions only.
By partitioning the state of a service, we allow to pro-
cess commands in parallel. This is particularly effective
for services whose state partitioning is perfect, that is, all
commands access one sub-state or another, but no command
accesses two or more sub-states. Commands that access
more than one sub-state must be carefully ordered to avoid
inconsistencies. We discuss how to efﬁciently integrate the
technique into Ring Paxos.
To illustrate high performance state-machine replication,
we propose, implement, and fully evaluate a highly available
parallel B-tree service. Our service implements three B-
tree operations: inserts, deletes, and range queries. We show
that speculative execution can reduce response time by up
to 16.2%. State partitioning allows service throughput to
increase by adding replicas,
in some cases resulting in
throughput near 4 times greater than classic state-machine
replication. In our largest conﬁguration, up to three quarters
of a million B-tree commands can be executed per second
with a response time below 4 milliseconds.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:31:45 UTC from IEEE Xplore.  Restrictions apply. 
978-1-4244-9233-6/11/$26.00 ©2011 IEEE454Summing up, the paper makes the following contributions:
(1) It shows how speculative execution can be integrated into
Ring Paxos to reduce the response time of state-machine
replication. (2) It presents the idea of state partitioning in
the context of state-machine replication. (3) It illustrates the
techniques with a B-tree service capable of executing com-
mands very efﬁciently. (4) It discusses the implementation
of these ideas and fully assesses them experimentally.
The remainder of the paper is structured as follows. Sec-
tion II describes our system model and state-machine repli-
cation. Section III presents speculative execution and state
partitioning in detail. Section IV illustrates the approach with
a highly available parallel B-tree service. Section V evaluates
the performance of the B-tree service. Section VI comments
on related work. Section VII concludes the paper. A proof
of correctness of our protocols can be found in [5].
II. BACKGROUND
A. System model
We assume a distributed system composed of intercon-
nected nodes within a single geographical location (e.g., a
data center). Nodes may fail by crashing and subsequently
recover, but do not experience arbitrary behavior (i.e., no
Byzantine failures). The network is mostly reliable and
subject to small latencies, although load unbalances (e.g.,
peak demand) imposed on both nodes and the network
may cause variations in processing and transmission delays.
Communication can be one-to-one, through the primitives
send(p, m) and receive(m), and one-to-many, through the
primitives ip-multicast(g, m) and ip-deliver(m), where m is
a message, p is a node, and g is a group of nodes. Messages
can be lost but not corrupted.
Our protocols ensure safety under both asynchronous
and synchronous execution periods. The FLP impossibil-
ity result [6] states that under asynchronous assumptions
consensus cannot be both safe and live. We thus assume
that the system is partially synchronous [7], that is, it is
initially asynchronous and eventually becomes synchronous.
The time when the system becomes synchronous is called
the Global Stabilization Time (GST) [7], and it is unknown
to the nodes. Before GST, there are no bounds on the time
it takes for messages to be transmitted and actions to be
executed. After GST, such bounds exist but are unknown.
After GST nodes are either correct or faulty. A correct node
is operational “forever” and can reliably exchange messages
with other correct nodes. This assumption is only needed
to prove liveness properties about the system. In practice,
“forever” means long enough for one instance of consensus
to terminate.
B. State-machine replication
State-machine replication is a fundamental approach to
implementing a fault-tolerant service by replicating servers
and coordinating client commands among server replicas [1],
[2]. The precise way in which the technique is implemented
depends on the targeted consistency criteria, which in this
paper we assume to be linearizability.
An execution is linearizable if there is a way to reorder its
commands in a sequence that (i) respects the semantics of
the commands, as deﬁned in their sequential speciﬁcations,
and (ii) respects the order of non-overlapping commands
across all clients [8]. Linearizability can be contrasted with
sequential consistency, a weaker form of consistency: An
execution is sequentially consistent if there is a way to
reorder the commands in a sequence that (i) respects their
semantics, and (ii) respects the ordering of commands issued
by the same client [8].
In the execution on top of Figure 1, client C2 modiﬁes
the state of a read-write object x and then client C1 reads
a state of x that precedes C2’s update (e.g., by accessing a
replica that has not seen C2’s changes yet). This execution
is not
is sequentially consistent. The
execution on the bottom of Figure 1 is both linearizable and
sequentially consistent: C1 is allowed to see a value of x
that precedes C2’s update since the two commands overlap
in time.
linearizable but
it
Figure 1. Linearizabiliy vs. sequential consistency.
State-machine replication can be implemented as a series
of consensus instances [9]. The i-th consensus instance
decides on the i-th command (or batch of commands) to
be executed by the servers. Consensus is deﬁned by the
primitives propose(v) and decide(v), where v is an arbitrary
value, a command to be executed by the servers. Consensus
guarantees that (i) if a server decides v then some client
proposed v; (ii) no two servers decide different values; and
(iii) if one (or more) non-faulty client proposes a value then
eventually some value is decided by all non-faulty servers.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:31:45 UTC from IEEE Xplore.  Restrictions apply. 
Sequential consistent (see Proof) but not linearizableRead(x)Reply(10)Write(x,20)Reply(ok)Client C1Client C2Read(x)Reply(20)timeReorderedSequence(Proof)Read(x)Reply(10)Write(x,20)Reply(ok)Client C1Client C2Read(x)Reply(20)Sequential consistent and linearizable (see Proof)ReorderedSequence(Proof)455Figure 2. Client-server (CS) versus state-machine replication with one replica (SMR) executing read-only commands.
With respect to performance, state-machine replication
suffers from two limitations: First, totally ordering com-
mands delays their execution and consequently the response
time experienced by the clients, when compared to a non-
replicated client-server setup. Second, since every replica
contains a full copy of the service state and must receive
every command, limited or no performance improvement
can be expected from adding replicas to the system. Notice
that some performance improvement can be obtained from
a few optimizations. Read commands need not be executed
by all replicas: upon deciding on a read command, only one
server (e.g., randomly assigned) must execute the command
and return the results to the client. Although all servers
must execute update commands, the response from only one
server is sufﬁcient for the clients. Obviously, if the server
assigned to return the results to the client fails, the client
has to retransmit its request. Since fails are (hopefully) rare
events, this is the design we follow in this paper.
Figure 2 compares the performance of a replicated system
to a non-replicated client-server system with a workload
composed of read-only commands only—more details about
these experiments can be found in Sections IV and V. The
graph on the left of Figure 2 shows the response time of the
two systems as the number of clients increases. The differ-
ence between the two curves before saturation (28 clients)
indicates the overhead introduced by replication. The graph
on the right of Figure 2 shows the throughput of the system
as replicas are added. Since the workload is composed of
read operations only, replication can improve throughput
up to four replicas; with eight replicas, the overhead of
simply delivering and discarding read commands prevents
the system from scaling further.
We claim that these are fundamental performance limita-
tions, not implementation speciﬁc. State-machine replication
requires commands to be ordered, and ordering commands
is inherently more expensive than directly sending them to
a server. Moreover, the fact that all replicas must deliver all
commands—although not all commands must be executed
by all replicas—limits the attainable performance (see [10]
for a similar argument). In the next section we describe two
mechanisms that address these problems.