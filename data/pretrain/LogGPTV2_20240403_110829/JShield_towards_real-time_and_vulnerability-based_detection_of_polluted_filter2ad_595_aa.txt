title:JShield: towards real-time and vulnerability-based detection of polluted
drive-by download attacks
author:Yinzhi Cao and
Xiang Pan and
Yan Chen and
Jianwei Zhuge
JShield: Towards Real-time and Vulnerability-based
Detection of Polluted Drive-by Download Attacks
Yinzhi Cao†, Xiang Pan, Yan Chen, and Jianwei Zhuge††
Northwestern University
†Columbia University
††Tsinghua University
ABSTRACT
Drive-by download attacks, which exploit vulnerabilities of web
browsers to control client computers, have become a major venue
for attackers. To detect such attacks, researchers have proposed
many approaches such as anomaly-based [22, 23] and vulnerability-
based [44, 50] detections. However, anomaly-based approaches are
vulnerable to data pollution, and existing vulnerability-based ap-
proaches cannot accurately describe the vulnerability condition of
all the drive-by download attacks.
In this paper, we propose a vulnerability-based approach, namely
JShield, which uses novel opcode vulnerability signature, a deter-
ministic ﬁnite automaton (DFA) with a variable pool at opcode
level, to match drive-by download vulnerabilities. We investigate
all the JavaScript engine vulnerabilities of web browsers from 2009
to 2014, as well as those of portable document ﬁles (PDF) readers
from 2007 to 2014. JShield is able to match all of those vulnera-
bilities; furthermore, the overall evaluation shows that JShield is so
lightweight that it only adds 2.39 percent of overhead to original
execution as the median among top 500 Alexa web sites.
1.
INTRODUCTION
In the past few years, drive-by download attacks exploiting
browser vulnerabilities have become a major venue for attackers
to control benign computers including those of reputable compa-
nies. For example, in February 2013, both Facebook and Apple
conﬁrm being hit in “watering hole attack” [4], a variance of drive-
by download attack. In such an attack, the attacker compromises a
web site commonly visited by victims, injects drive-by download
attacks, and then waits for victims to come, just as a predator sitting
at a water hole in a desert for prey.
To defeat such attacks, many anomaly-based approaches [21–23,
46], which tune the detection engine based on attacker-generated
exploits and benign web sites, have been proposed and signiﬁcantly
improved state of the art. However, although anomaly-based ap-
proaches can detect unknown attacks, they could succumb in adver-
sarial environments. Inspired by the data pollution on polymorphic
worm detection [41], we designed and implemented polluted drive-
by download attacks, which could signiﬁcantly reduce the detection
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for proﬁt or commercial advantage and that copies bear
this notice and the full citation on the ﬁrst page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior speciﬁc permission and/or a fee. Request
permissions from Permissions@acm.org.
ACSAC ’14, December 08 - 12 2014, New Orleans, LA, USA
Copyright 2014 ACM 978-1-4503-3005-3/14/12$15.00
http://dx.doi.org/10.1145/2664243.2664256.
h
g
h
i
y
c
a
r
u
c
c
A
Turing 
Machine 
Signature
JShield 
Signature
Ideal 
Signature
Symbolic 
Constraint 
Signature
l
o
w
Speed
Regular 
Expression 
Signature
high
Figure 1: Signature Comparison.
rates of those anomaly-based detectors.
To countermeasure such data pollution, we turn to vulnerability-
based approaches.
In this emerging direction, although the pre-
cise description of a network protocol layer vulnerability signa-
ture has already been used in the network intrusion detection sys-
tems (NIDS) [32, 54], its application on Web drive-by download
attack detection is very limited. In BrowserShield [44], Reis et al.
rewrite JavaScript codes and enforce stateless security policies (sig-
natures), such as checking the parameter length of a function call.
The other work by Song et al. [50] matches the inter-module com-
munication with vulnerability signatures. However, neither of these
techniques can precisely represent the exact vulnerability condi-
tions of drive-by download attacks. More speciﬁcally, the rules in
BrowserShield do not have stateful data structures to record con-
trol or data ﬂow, and the signatures in the work by Song et al. lack
sufﬁcient information for control ﬂow at the inter-module level.
In summary, we believe that an approach detecting drive-by
download attacks should address the following challenges:
• Signatures for Stateful Intra-module Vulnerabilities. The
signature for drive-by download attacks targeting stateful intra-
module vulnerabilities should contain both control and data
ﬂows during matching.
• Resilience to Polluted Data. The system should be resilient to
polluted training and testing samples provided by the attackers.
• High Performance. The runtime detection system should have
an acceptable overhead to the pure execution of web pages.
In this paper, we propose JShield, vulnerability-based detec-
tion of drive-by download attacks. JShield has been adopted by
Huawei, the world’s largest telecommunication company. We posi-
tion JShield opcode signatures in Figure 1 with other known vulner-
ability signatures. Neither symbolic constraint signature nor regu-
lar expression signature can represent a drive-by download vulner-
ability that takes Javascript, a Turing complete language, as input,
since they do not have loops. Meanwhile, a traditional Turing ma-
chine signature is so complex that it requires a signature as large
Malicious
Web
Server
(1) Visiting
(2) Downloading 
and Expanding
Malicious JS
Browser
JavaScript
Engine
i
g
n
y
a
r
p
S
)
3
(
Users
(4) Exploiting 
Browser 
Vulnerability
OS
(5) Downloading
Malware
Memory
(6) Executing Malware
Figure 2: Six Steps of a Drive-by Download Attack.
as a whole browser. Thus, we abstract lower level Turing machine
to a higher level opcode Turing machine and design detection for-
mat of our opcode signature. To further make it scalable, we also
use regular expression (ﬁlter format of opcode signature) to ﬁlter a
large number of benign trafﬁc.
The current signature generation process involves some manual
effort. However, we believe that the amount of manual work is
small due to the small number (approximately 10) of vulnerabili-
ties each year. Actually, even for a large amount of signatures, most
network intrusion detection/prevention system (IDS/IPS) vendors,
such as Snort, Cisco and Juniper, all generate these signatures man-
ually [5, 13].
Besides being the f irst to design polluted drive-by down-
load attacks and evaluate their effectiveness on the state-of-the-art
anomaly-based approaches, we make the following contributions
in this paper:
• Stateful Drive-by Download Vulnerability Signatures. Our
vulnerability signature is a deterministic ﬁnite automaton (DFA)
with a variable pool recording both control and data ﬂows to
detect stateful intra-module vulnerabilities of drive-by download
attacks.
• Vulnerability Signature at the Opcode Level. A vulnerabil-
ity signature at the opcode level can precisely describe a given
vulnerability.
• Fast Two-stage Matching. We design a two-stage matching
process to speed up the detection. The ﬁltering stage adopts fast
regular expression matching for a given test sample, and then
if the sample is captured at the ﬁltering stage, it is subject to a
further matching with opcode signature.
To evaluate JShield, we investigate the vulnerability coverage of
JShield and ﬁnd that JShield is able to handle all the recent Java-
Script engine vulnerabilities of web browser and portable document
ﬁles (PDF) reader. The overall evaluation shows that JShield has
introduced little performance overhead to pure execution. The av-
erage overhead of top 500 Alexa web sites is 9.42% and the median
is 2.39%.
2. THREAT MODEL
The paper focuses on drive-by download attacks consisting of
two major stages: pre-exploit stage and post-exploit stage, which
can further divide into six steps as shown in Figure 2.
At the pre-exploit stage, a benign user is lured to visit a malicious
web site (step one). Then, malicious contents are downloaded, and
malicious JavaScript codes, possibly obfuscated by eval, setTime-
out, and DOM events, get expanded by execution (step two). Dur-
ing execution, some malicious JavaScripts also ﬁll the heap with
Detection 
Engine
Tuned 
Detection 
Engine
Figure 3: Anomaly-based Approaches to Detect Drive-by Download At-
tacks.
shellcodes and nop sleds to overcome address space layout ran-
domization and facilitate attacks (step three).
After all the preparation, the malicious JavaScript exploits a cer-
tain vulnerability (step four), and thus the injected shellcode takes
control of the browser to download malware (step ﬁve), which is
subsequently executed on the victim machine (step six).
To distinguish our threat model from others, we also mention
other attacks below - these however are out of scope of the paper.
Attacks without any JavaScript Interaction. Similar to existing
works like Zozzle [23], we only focus on the JavaScript part of
a drive-by download attack. If an attack is purely related to HTML
parser, CSS parser or font processing, neither Zozzle with abstract
syntax tree (AST) features nor JShield with opcode vulnerability
signatures can detect the attack. Instead, due to lack of full featured
obfuscation techniques, this type of attacks should be prevented by
traditional NIDS.
Other Web-based Attacks. Other web-based attacks, such as cross-
site scripting (XSS) attacks, cross-site request forgery (CSRF), and
so on are out of scope of the paper. People should rely on existing
defense mechanisms [19, 52] for those attacks.
3. POLLUTED DRIVE-BY DOWNLOAD AT-
TACKS
Anomaly-based approaches [18, 22, 23, 46] ﬁrst train a detection
engine based on exploits generated by attackers as well as benign
samples collected from the Internet, and then perform detection by
the tuned engine. An overview architecture is shown in Figure 3.
Normally, a machine learning engine is deployed in the training
stage, which extracts malicious and benign features from training
data and then trains the detection engine.
In this section, we discuss the efﬁcacy of anomaly-based detec-
tion in adversarial environment. We understand that the advan-
tage of anomaly-based detections is that they can detect unknown
attacks, however in this paper we only focus on the behavior of
anomaly-based detection in adversarial environment.
Generally, an anomaly-based detection could be evaded in two
ways, namely, polluting attacker generated exploits in training
stage and altering malicious samples in detection stage. We in-
troduce data pollution in detection stage ﬁrst because of its effec-
tiveness. For data pollution, we use naive Bayes engine adopted by
Zozzle [23] as an example to show how to evade anomaly-based
approaches.
3.1 Polluting Samples at Detection Stage
An attacker can alter malicious samples by injecting benign fea-
tures (BF), thus increasing the probability of classifying those sam-
ples as benign and evading naive Bayes engine.
Intuitively, the
benign features decrease the anomaly by reducing the signiﬁcance
Table 1: Zozzle’s Detection Rate.
Original Rate
Rate after Pollution at Detection Stage
Table 2: The detection rate of ﬁve anti-virus programs before and after data
pollution.
True Positive
False Positive
93.1%
0.5%
36.7%
0.5%
of the malicious features statistically. Here is the detailed reason.
Assume there is a sample with malicious feature (MF). According
to the deﬁnition, P (M |M F ), the probability of malice given the
existence of one malicious feature, is larger than 0.5. Now let us as-
sume that one benign feature (BF) is introduced to that ﬁle. Given
that MF and BF are independently distributed in naive Bayes, we
have Equation 1.
P (M|M F, BF ) =
P (M F, BF |M) ∗ P (M)
P (M F, BF )
=
=
P (M F |M) ∗ P (BF |M) ∗ P (M)
p(M F ) ∗ P (BF )
P (BF |M)
P (BF )
∗ P (M|M F )
Since fewer BFs exist in malicious ﬁles, P (BF |M )
P (BF ) < 1. Thus,
Equation 1 shows that the existence of one benign feature reduces
the probability of the sample’s malice. If enough benign features
are introduced, P (M |M F, BF, BF 1, BF 2...), the probability of
the sample’s malice, will be eventually less than 0.5, resulting in a
mislead of the Bayes classiﬁer.
3.2 Real-world Experiments
We use Zozzle [23], the most recent and successful machine
learning detection, as a case study to show how to evade an
anomaly-based approach, however, our discussion is not restricted
to Zozzle. Since Zozzle is not open source, we strictly followed
what has been described in the paper [23], implemented our version
of Zozzle, and reproduced comparable detection rate for unpolluted
samples as the one reported by Zozzle.
The testing data set is from Huawei, which contains unclassiﬁed
malicious JavaScript codes collected from their customer reporting,
other anti-virus software reporting, etc. After ﬁltering all the land-
ing pages, we collect 880 malicious samples (Zozzle adopts 919
JavaScript malware samples [23]). Meanwhile, Top 5,000 Alexa
web sites [3] are used as benign samples during training. After
manual and automatic selection documented in Zozzle, we collect
300 benign and malicious features.
Since an attacker cannot acquire our benign features used in the
system, we collect all the common features among Top 5,000 Alexa
web sites and add them to malicious samples. The size of each
malicious sample increases 45% on average, i.e., 396KB. As shown
in Table 1, pollution at the detection stage decreases the overall
accuracy to 36.7%.
In addition to Zozzle, we also evaluated ﬁve popular anti-virus
programs1 selected from an anti-virus software review web site [1],
which are: 1) Avira Antivirus Premium 2013, 2) AVG Internet Se-
curity 2013, 3) Kaspersky Internet Security 2012, 4) Norton Inter-
net Security 2013 and 5) Trend Micro Titanium Internet Security
2013. The results are shown in Table 2. Before data pollution,
the detection rates of anti-virus software except AV4 are all above
85%. However, after data pollution, the detection rates of them
are all below 4%. Therefore, existing anti-virus software, which
are blackbox to us and some of which belong to regular expression
based approach, are not robust to data pollution either.
4. OVERVIEW
1This order does not correspond to the order of AV1 to AV5 in
Table 2.
(1)
4.1 Deployment
Anti-virus
Original Rate
Rate After Pollution
AV1
AV2
AV3
AV4
AV5
98.00%
89.33%
92.41%
20.67%
87.58%
0.58%
3.58%
2.00%
0.08%
2.00%
As discussed in previous section, attacker generated samples
adopted by anomaly-based detections could be polluted, and thus