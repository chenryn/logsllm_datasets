名古屋
2007315
钛
名古屋
2007401
钢
名古屋
2007424
名古屋
2007502
镁
名古屋
2007510
钛
福冈
2007510
锌
福冈
200752B
锡
各生产地每天都会入库一批材料，然后使用材料生产各种各样的产
品。但是，有时材料不能按原定计划在一天内消耗完，会出现重复。这时，
为了在各生产地之间调整重复的材料，我们需要调查出存在重复材料的生
产地。
先来分析一下满足条件的生产地具有哪些特征。从表中我们可以看到，
形式，而不是以元素的形式存在的。处理这种情况的基本方法就是使用
GROUPBY子句将集合划分为若干个子集，像下面这样。
图灵社区会员非洲铜(PI:EMAIL）专享尊重版权
---
## Page 186
110HAVING子句文国来了
173
S2大院
NTDISTINCT
53：名吉屋
54:福冈
COUNT
因为子集51和53都存在重置，
COUNTIDISTINCT
所以排影择重复元表后数据行数不同
目标集合是锌重复的东京，以及钛和钢重复的名古屋。那么这两个集
合满足而其他集合不满足的条件是什么呢？
这个条件是，“排除掉重复元素后和排除掉重复元素前元素个数不相
同”这是因为，如果不存在重复的元素，不管是否加上DISTINCT可选项，
COUNT 的结果都是相同的。
-选中材料存在重复的生产地
SELECT center
FROM Katerials
HAVING COUNT (natexia1) <> COUNr (DISTI
naterlall ;
■执行结果
center
东京
名古屋
虽然我们无法通过这条SQL语句知道重复的材料具体是哪一种，但
是通过在WHBRE子句中加上具体的材料作为参数，可以查出某种材料存
在重复的生产地。而且，和前面一样，我们可以把条件移到SELECT子句中，
这样就能在结果中清晰地看到各个生产地是否存在重复材料了。
SELSCT center,
ELSE不存在重复END AS status
FRON Materlals
GROUP BY center;
---
## Page 187
174—第1章神奇的SOL
center
大阪
不存在重复
东京
存在重复
福冈
不存在重复
名古屋
存在重复
从1-4节开始我们进行了许多与HAVING子句相关的练习，所以对于
使用GROUPBY将原来的表划分为子集的思考方式，大家已经非常习惯了
吧。接下来针对我们一直在使用的“子集”的说法，稍微补充一点理论方
面的知识。在数学中，通过GROUP BY生成的子集有一个对应的名字，叫
作划分（partition）.它是集合论和群论中的重要概念，指的是将某个集合
按照某种规则进行分割后得到的子集。这些子集相互之间没有重复的元素，
而且它们的并集就是原来的集合。这样的分割操作被称为划分操作。SQL
中的GROUPBY，其实就是针对集合的划分操作的具体实现（关于划分和
划分操作的更多内容，可以参考本书2-5节）。
顺便说一下，这个间题也可以通过将HAVING改写成EXISTS的方式
来解决。
-存在重复的集合：使用EXISTS
SELSCT centex, material
FBOM Katerlalα M1
HHERE EXISTS
{SELECT +
FROX Haterials M2
WHERE N1.centex = N2 .centex
AND Nl.receive_date <> N2-receive_date
AND Nl.material = N2 .material) :
centex
naterial
东京
东京
锌
名古屋
名古屋
名古屋
钢
名古屋
软
而且使用EXISTS后性能也很好。相反地，如果想要查出不存在重复材料
---
## Page 188
110HAVING子句文B来了
175 
的生产地有哪些，只需要把 EXISTS 改写为NOT EXISTS 就可以了。
寻找缺失的编号：升级版
1-4节介绍过下面这样一条查询数列的缺失编号的查询语句，大家还
记得吗？
SSLBCT存在缺失的编号NS9aP
--如果有查询结果，说明存在缺失的编号
FROM SeqTbl
这条SQL语句有一个前提条件，即数列的起始值必须是1。大部分
情况下这样是没有问题的，但是我们还是放宽这个限制条件，思考一下不
管数列的最小值是多少，都能用来判断该数列是否连续的SQL语句。对
新的SQL语句来说，下面4种情况中，(3)是连续的，而（4)存在数据缺
失。然而对前面的SQL语句来说，这里（3）的起始值不是1，所以是不
连续的。
(1)不存在缺失编号（起始值=1）
(2)存在缺失编号（起始值=1）
Seq[连续跨号】
Sa (连续编号]
(3)不存在缺失编号（起始值1）（4）存在缺失编号（起始值<>1）
Seq[连续跨号
Saq（连续编号）
10
---
## Page 189
176—第1章神奇的SOL
解决这个间题的基本思路和之前是一样的，即将表整体看作一个集合，
使用cOUNT（*）来获得其中的元素个数。上面4种情况的话，每张表都满
足COUNT(*)-5。而且，如果数列的最小值和最大值之间没有缺失的编号，
它们之间包含的元素的个数应该是“最大值一最小值十1”。因此，我们像
下面这样写比较条件就可以了。
--知果有查询结果，说明存在缺失的编号：只调查数列的连续性
SBLBCT存在缺失的编号ASgap
FROM SeqTb1
[I +(NIN -(baSXHN  MAX (seq) - NIN(eeq) + 1
THEN·存在缺失的编号
BLSE 连续·END AS gap
FEOM SeqTb1;
这条SQL语句中稍微多做了一点处理，即表为空的时候当作异常情
况处理，返回“表为空”的结果（即使是表为空的时候，前面那条使用了
HAVING的SQL语句也会认为编号是连续的）。像这样表达详细的条件分
支正是CASE表达式的魅力所在。
接下来我们也顺便改进一下查找最小的缺失编号的SQL语句，去掉
起始值必须是1的限制。对于之前的简单版的SQL语句来说，情况（4)会
把5当成最小的缺失编号来返回。因为表中并没有1和2，所以简单版的
SQL语句根本不会去检查它们的下一个数是否存在。对于像这样表中原本
就不存在1的情况，我们追加一个条件分支让它返回1，即像下面这样来
写 SQL 语句。
-查找最小的缺失输号：表中没有1时退目1
SELBCT CASE WHEx COOBTr(*)  0 O: NIX(eeq)> 1 -- 量小值不是 1时返目 1
THEN 1
图灵社区会员非洲钢(PI:EMAIL）专享尊重版权
---
## Page 190
1-10HAVING子句又国来了—177 鲁
ELSE (SELECT MIN (8eq +1)
-量小值是1时一返回最小的缺失编号
FROM SeqTbl S1
NHERE NOT EXISTS
(SELECT *
PROM SeqTbl S2
KHERE S2.seg = 81.8eg + 1)) ED
FROM SeqTb1↓
可以看到，简单版的SQL语句以标量子查询的方式整体地嵌入到了
CASE表达式的返回结果块里。考虑到表可能为空，所以这里加上了
COUNT（*）－O这个条件。而且相比简单版，NOTIN也改写成了NOT
EXISTS，这样写是为了处理值为NULL的情况，以及略微优化一下性能。
性能。这条SQL语句会返回下面这样的结果。
*情况（1）：6（没有缺失的编号，所以返回最大值5的下一个数）
*情况（2)：3（最小的缺失编号）
情况（3）：1（因为表中没有1）
情况（4)：1（因为表中没有1）
在面向过程语言中，条件分支是通过IF语句或者CASE语句等进行的。
但是在SQL语言中，所有的条件分支都是通过“表达式（函数）”进行的。
在这一点上，SQL语言跟函数式语言非常相似。
为集合设置详细的条件
最后，我们再练习一些使用CASE表达式来描述特征函数的方法。熟
练掌握这些方法之后，不管多么复杂的条件都能轻松地表达出来（不是夸
张，是真的)。
这里以下面这张记录了学生考试成绩的表为例进行讲解。
---
## Page 191
178—
第1章种奇的 SQL
TestResults
ludent id ( 学号 ID }
class（班级】
S8x(性别]
soore （分数）
001
A
男
100
002
A
女
100
003
A
女
49
004
A
男
30
005
B
女
100
006
B
男
92
007
B
男
80
008
B
男
80
009
B
女
10
010
C
男
92
011
C
男
08
012
C
21
013
D
女
100
014
D
女
0
015
D
0
请根据这张表回答后面几个间题。这次笔者不会给大家画出维恩图了，
如果需要的话请自己画一下。
好了，我们先看一个简单的。
第1题：请查询出75%以上的学生分数都在80分以上的班级。
班级里的总人数可以通过COUNT（*}查到，80分以上的学生人数可以
通过特征函数来统计，因此答案如下所示。
SELBCT class
FROM TeatResulta
GROUP BY class
HAVING COUNT (+) + O.75
THEN 1
ELSE 0 END):
■执行结果
c1as5
---
## Page 192
110HAVING子句文B来了 