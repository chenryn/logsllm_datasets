like Fts3Table;
●
sqlite3Fts3Optimize will handle the fake instance;
●
Do some code review to see if we can have 
memory RW or PC control.
Exploitation Strategy
1.
To have memory control in known address, heap spray is still available in 
modern browsers, e.g. by allocating a lot of JavaScript ArrayBuffer objects
2.
Dereference Fts3Cursor at a specified and controlled location, where we can 
fake Fts3Cursor and other structs
3.
Find a code path of optimize/offsets/matchinfo() for arbitrary RW primitive/PC 
control
41
One Exploitation Path for Arbitrary RW
42
fts3OptimizeFunc
sqlite3Fts3Optimize
sqlite3Fts3SegmentsClose
sqlite3_blob_close
sqlite3_finalize
sqlite3VdbeFinalize
sqlite3VdbeReset
sqlite3ValueSetStr
sqlite3VdbeMemSetStr
This function is basically just doing "strcpy" with controlled arguments, 
by which we can achieve the following:
Copy value from controlled location to any addr => Arbitrary write 
Copy value from any addr to controlled location => Arbitrary read
sqlite3VdbeTransferError
Let's start a long journey... 
static void fts3OptimizeFunc(
  sqlite3_context *pContext,
  int nVal,
  sqlite3_value **apVal
){
  int rc;
  Fts3Table *p;
  Fts3Cursor *pCursor;
  UNUSED_PARAMETER(nVal);
  assert( nVal==1 );
  if( fts3FunctionArg(pContext, "optimize",
                      apVal[0], &pCursor) )
    return;
  p = (Fts3Table *)pCursor->base.pVtab;
  rc = sqlite3Fts3Optimize(p);
  ...
}
43
Fake a Fts3Cursor struct and all related structs in 
controlled (heap sprayed) memory.
Added a Fts3Table to Fts3Cursor.
Fts3Table
...
Fts3Cursor
pVtab
...
...
sqlite3_vtab_c
ursor
sqlite3Fts3Optimize
int sqlite3Fts3Optimize(Fts3Table *p){
  int rc;
  rc = sqlite3_exec(p->db, "SAVEPOINT fts3", 0, 0, 0);
  if( rc==SQLITE_OK ){
    rc = fts3DoOptimize(p, 1);
    if( rc==SQLITE_OK || rc==SQLITE_DONE ){
      int rc2 = sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
      if( rc2!=SQLITE_OK ) rc = rc2;
    }else{
      sqlite3_exec(p->db, "ROLLBACK TO fts3", 0, 0, 0);
      sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
    }
  }
  sqlite3Fts3SegmentsClose(p); 
  return rc;
}
44
let sqlite3_exec() != SQLITE_OK
Fts3Cursor
sqlite3_vtab_c
ursor
pVtab
...
...
Fts3Table
...
let sqlite3_exec() != SQLITE_OK
int sqlite3_exec(
  sqlite3 *db,
  const char *zSql,
  sqlite3_callback xCallback,
  void *pArg,
  char **pzErrMsg
){
  int rc = SQLITE_OK;
  const char *zLeftover;
  sqlite3_stmt *pStmt = 0;
  char **azCols = 0;
  int callbackIsInit;
  if( !sqlite3SafetyCheckOk(db) )
    return SQLITE_MISUSE_BKPT;
  if( zSql==0 ) zSql = "";
  ...
}
int sqlite3SafetyCheckOk(sqlite3 *db){
  u32 magic;
  if( db==0 ){
    logBadConnection("NULL");
    return 0;
  }
  magic = db->magic;
  if( magic!=SQLITE_MAGIC_OPEN ){
    if( sqlite3SafetyCheckSickOrOk(db) ){
      testcase( sqlite3GlobalConfig.xLog!=0 );
      logBadConnection("unopened");
    }
    return 0;
  }else{
    return 1;
  }
}
45
let sqlite3SafetyCheckOk() = 0
let db = 0
let p->db = 0 
Fts3Cursor
sqlite3_vtab_c
ursor
pVtab
...
...
Fts3Table
...
db = 0
...
Fts3Cursor
sqlite3_vtab_c
ursor
pVtab
...
...
Fts3Table
...
sqlite3Fts3SegmentsClose
void sqlite3Fts3SegmentsClose(Fts3Table *p){
  sqlite3_blob_close(p->pSegments);
  p->pSegments = 0;
}
int sqlite3_blob_close(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  int rc;
  sqlite3 *db;
  if( p ){
    db = p->db;
    sqlite3_mutex_enter(db->mutex);
    rc = sqlite3_finalize(p->pStmt);
    sqlite3DbFree(db, p);
    sqlite3_mutex_leave(db->mutex);
  }else{
    rc = SQLITE_OK;
  }
  return rc;
}
47
Fts3Cursor
sqlite3_vtab_c
ursor
pVtab
...
...
Incrblob
...
pStmt
db
...
Vdbe
...
sqlite3
...
mutex = 0
...
Fts3Table
...
db = 0
...
pSegments
...
●
Added a Incrblob to Fts3Table.
●
Added a sqlite3(db) and a Vdbe to 
the Incrblob.
sqlite3_finalize
int sqlite3_finalize(sqlite3_stmt *pStmt){
  int rc;
  if( pStmt==0 ){
    rc = SQLITE_OK;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
    sqlite3 *db = v->db;
    if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;
    sqlite3_mutex_enter(db->mutex);
    checkProfileCallback(db, v);
    rc = sqlite3VdbeFinalize(v);
    rc = sqlite3ApiExit(db, rc);
    sqlite3LeaveMutexAndCloseZombie(db);
  }
  return rc;
}
int sqlite3VdbeFinalize(Vdbe *p){
  int rc = SQLITE_OK;
  if( p->magic==VDBE_MAGIC_RUN || 
p->magic==VDBE_MAGIC_HALT ){
    rc = sqlite3VdbeReset(p);
    assert( (rc & p->db->errMask)==rc );
  }
  sqlite3VdbeDelete(p);
  return rc;
}
48
let p->magic == VDBE_MAGIC_HALT
survive vdbeSafety()/checkProfileCallback()
Structs
49
Fts3Cursor
sqlite3_vtab_c
ursor
pVtab
...
...
Incrblob
...
pStmt
db
...
Fts3Table
...
db = 0
...
pSegments
...
sqlite3
...
mutex = 0
...
Vdbe
db
...
magic = 
VDBE_MAGIC_HALT
...
sqlite3VdbeReset
int sqlite3VdbeReset(Vdbe *p){
  sqlite3 *db;
  db = p->db;
  sqlite3VdbeHalt(p);
  if( p->pc>=0 ){
    vdbeInvokeSqllog(p);
    sqlite3VdbeTransferError(p);
    sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = 0;
    if( p->runOnlyOnce ) p->expired = 1;
  }else if( p->rc && p->expired ){
    ...
  }
  Cleanup(p);
  p->iCurrentTime = 0;
  p->magic = VDBE_MAGIC_RESET;
  return p->rc & db->errMask;
}
50
survive sqlite3VdbeHalt()
p->pc >= 0
Structs
Fts3Cursor
sqlite3_vtab_c
ursor
pVtab
...
...
Incrblob
...
pStmt
db
...
Fts3Table
...
db = 0
...
pSegments
...
sqlite3
...
mutex = 0
...
Vdbe
db
...
magic = 
VDBE_MAGIC_HALT
...
pc >= 0
...
sqlite3VdbeTransferError
int sqlite3VdbeTransferError(Vdbe *p){
  sqlite3 *db = p->db;
  int rc = p->rc;
  if( p->zErrMsg ){
    db->bBenignMalloc++;
    sqlite3BeginBenignMalloc();
    if( db->pErr==0 ) db->pErr = sqlite3ValueNew(db);
    sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);
    sqlite3EndBenignMalloc();
    db->bBenignMalloc--;
    db->errCode = rc;
  }else{
    sqlite3Error(db, rc);
  }
  return rc;
}
void sqlite3ValueSetStr(sqlite3_value *v, int n, const void *z, u8 enc, void (*xDel)(void*) 
){
  if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
}
52
fake a db->pErr struct, and p->zErrMsg != 0
sqlite3VdbeMemSetStr
int sqlite3VdbeMemSetStr(Mem *pMem, const char *z, int n, u8 enc, void (*xDel)(void*)
){ 
  int nByte = n;
  ...
  if( nByteiLimit ) nByte = iLimit+1;
    }
    ...
  }
  if( xDel==SQLITE_TRANSIENT ){
    int nAlloc = nByte;
    ...
    if( sqlite3VdbeMemClearAndResize(pMem, MAX(nAlloc,32)) ) return SQLITE_NOMEM_BKPT;
    memcpy(pMem->z, z, nAlloc);
  }
  ...
  return SQLITE_OK;
}
53
sqlite3VdbeMemClearAndResize() will do:
pMem->z = pMem->zMalloc;
For memcpy():
z is a string pointer from Vdbe's zErrMsg
pMem is a Mem struct, pMem->z also can be controlled 
by pMem->zMalloc.
nAlloc is the length of string z.
So we have a "strcpy" primitive with controlled 
arguments: source and destination.
Structs
54
Fts3Cursor
sqlite3_vtab_c
ursor
pVtab
...
...
Incrblob
...
pStmt
db
...
Fts3Table
...
db = 0
...
pSegments
...
sqlite3
...
mutex = 0
...
Vdbe
db
...
magic = 
VDBE_MAGIC_HALT
...
pc >= 0
...
zErrMsg
...
Mem/
sqlite3_value
...
zMalloc
...
pErr
...
Added a Mem struct to the sqlite3 
struct.
For strcpy primitive:
zMalloc specifies the source,
zErrMsg specifies the destination.
One Exploitation Path For PC Control
55
fts3OptimizeFunc
sqlite3Fts3Optimize
sqlite3Fts3SegmentsClose
sqlite3_blob_close
sqlite3_finalize
checkProfileCallback
invokeProfileCallback
invokeProfileCallback() will invoke many callbacks: 
xProfile/xTrace/xCurrentTime/xCurrentTimeint64.
These callbacks call be controlled in sprayed memory.
invokeProfileCallback
static SQLITE_NOINLINE void invokeProfileCallback(sqlite3 *db, Vdbe *p){
  sqlite3_int64 iNow;
  sqlite3_int64 iElapse;
  ...
  sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);
  iElapse = (iNow - p->startTime)*1000000;
  if( db->xProfile ){
    db->xProfile(db->pProfileArg, p->zSql, iElapse);
  }
  if( db->mTrace & SQLITE_TRACE_PROFILE ){
    db->xTrace(SQLITE_TRACE_PROFILE, db->pTraceArg, p, (void*)&iElapse);
  }
  p->startTime = 0;
}
56
We used callback db->xProfile because we can also 
control 2 arguments through db->pProfileArg and p->zSql
To survive sqlite3OsCurrentTimeInt64(), we 
should construct db->pVfs of struct sqlite3_vfs, 
and nullify the callback 
db->Vfs->xCurrentTimeInt64. 
Structs
57
Fts3Cursor
sqlite3_vtab_c
ursor
pVtab
...
...
Incrblob
...
pStmt
db
...
Fts3Table
...
db = 0
...
pSegments
...
sqlite3
pVfs
...
mutex = 0
pProfileArg
xProfile
...
Vdbe
db
...
magic = 
VDBE_MAGIC_HALT
...
zSql
...
We achieved arbitrary function call:
xProfile specifies gadget address;
pProfileArg specifies first argument;
zSql specifies second argument
...
xCurrentTimeInt64
...
sqlite3_vfs
ASLR Bypass
58
sqlite> create virtual table a using fts3(b);
sqlite> insert into a values(x'4141414142424242');
sqlite> select hex(a) from a;
C854D98F08560000
●
By CVE-2017-6991 above, we leaked the address of a FTS3Cursor 
object
●
The first member of struct FTS3Cursor points to a global variable 
fts3Module
●
By arbitrary read primitive, we can read the address of fts3Module, 
which will reveal the address of sqlite library (at least, sometimes 
sqlite will be statically linked together with other libraries) 
Shellcode Execution
●
With arbitrary function call primitive, invoke longjmp/mprotect gadget as 
below,  to mark the memory pages of shellcode as executable
●
Trigger the function call primitive again to jump to the shellcode
59
"Birds"
60
61
●
62
●
63
●
64
●
Thank you!
65