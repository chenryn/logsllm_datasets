points indents - 
quickly on a call.
123
o Verify no proprietary algorithms are being used
o Check that RNGCryptoServiceProvider is used for PRNG
o Verify key length is at least 128 bits
• For Java check that the Java Cryptography Extension (JCE) is being used
o Verify no proprietary algorithms are being used
o Check that SecureRandom (or similar) is used for PRNG
o Verify key length is at least 128 bits
Bad Practice: Use of Insecure Cryptographic Algorithms
The DES and SHA-0 algorithms are cryptographically insecure. The example in sample 12.1 outlines a cryptographic 
module using DES (available per using the Java Cryptographic Extensions) which should not be used.  Additionally, 
SHA-1 and MD5 should be avoided in new applications moving forward.
Good Practice: Use Strong Entropy 
The source code in sample 12.2 outlines secure key generation per use of strong entropy:
package org.badexample.crypto;
try {
/**  Step 1. Generate a DES key using KeyGenerator */
KeyGenerator keyGen = KeyGenerator.getInstance(“DES”);
SecretKey secretKey = keyGen.generateKey();
/**  Step2. Create a Cipher by specifying the following parameters
 *  
a. Algorithm name - here it is DES
 *  
b. Mode - here it is CBC
 *  
c. Padding - PKCS5Padding */
Cipher desCipher = Cipher.getInstance(“DES/CBC/PKCS5Padding”);
Sample 12.1
package org.owasp.java.crypto;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;
import sun.misc.BASE64Encoder;
/**
 * This program provides the functionality for Generating a Secure Random Number.
 * There are 2 ways to generate a Random number through SecureRandom.
 * 1. By calling nextBytes method to generate Random Bytes
Sample 12.2
A6 - Sensitive Data Exposure
bottom of page is 
in terms of bullet 
again let’s cover 
124
Good Practice: Use Strong Algorithms
Below illustrates the implementation of AES (available per Using the Java Cryptographic Extensions):
 * 2. Using setSeed(byte[]) to reseed a Random object
*/
public class SecureRandomGen {
public static void main(String[] args) {
try {
        // Initialize a secure random number generator
        SecureRandom secureRandom = SecureRandom.getInstance(“SHA512”);
        // Method 1 - Calling nextBytes method to generate Random Bytes
        byte[] bytes = new byte[512];
        secureRandom.nextBytes(bytes); 
        // Printing the SecureRandom number by calling secureRandom.nextDouble()
        System.out.println(“ Secure Random # generated by calling nextBytes() is “ + secureRandom.
nextDouble());
        // Method 2 - Using setSeed(byte[]) to reseed a Random object
        int seedByteCount = 10;
        byte[] seed = secureRandom.generateSeed(seedByteCount);   
        secureRandom.setSeed(seed); 
        System.out.println(“ Secure Random # generated using setSeed(byte[]) is  “ + secureRandom.
nextDouble());
    } catch (NoSuchAlgorithmException noSuchAlgo)
{
System.out.println(“ No Such Algorithm exists “ + noSuchAlgo);
}
}
}
package org.owasp.java.crypto;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.Cipher;
import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
import java.security.InvalidAlgorithmParameterException;
import javax.crypto.NoSuchPaddingException;
Sample 12.3
A6 - Sensitive Data Exposure
125
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import sun.misc.BASE64Encoder;
/**
 * This program provides the following cryptographic functionalities
 * 1. Encryption using AES
 * 2. Decryption using AES
 * 
 * High Level Algorithm :
 * 1. Generate a DES key (specify the Key size during this phase) 
 * 2. Create the Cipher 
 * 3. To Encrypt : Initialize the Cipher for Encryption
 * 4. To Decrypt : Initialize the Cipher for Decryption
 */
public class AES {
public static void main(String[] args) {
String strDataToEncrypt = new String();
String strCipherText = new String();
String strDecryptedText = new String();
try{
/**
 *  Step 1. Generate an AES key using KeyGenerator
 *   
Initialize the keysize to 128 
 */
KeyGenerator keyGen = KeyGenerator.getInstance(“AES”);
keyGen.init(128);
SecretKey secretKey = keyGen.generateKey();
/**
 *  Step2. Create a Cipher by specifying the following parameters
 *  
a. Algorithm name - here it is AES
 */
Cipher aesCipher = Cipher.getInstance(“AES”);
/**
 *  Step 3. Initialize the Cipher for Encryption 
 */
aesCipher.init(Cipher.ENCRYPT_MODE,secretKey);
/**
 *  Step 4. Encrypt the Data
 *   
1. Declare / Initialize the Data. Here the data is of type String
 *   
2. Convert the Input Text to Bytes
A6 - Sensitive Data Exposure
126
 *   
3. Encrypt the bytes using doFinal method 
 */
strDataToEncrypt = “Hello World of Encryption using AES “;
byte[] byteDataToEncrypt = strDataToEncrypt.getBytes();
byte[] byteCipherText = aesCipher.doFinal(byteDataToEncrypt); 
strCipherText = new BASE64Encoder().encode(byteCipherText);
System.out.println(“Cipher Text generated using AES is “ +strCipherText);
/**
*/  Step 5. Decrypt the Data
 *   
1. Initialize the Cipher for Decryption 
 *   
2. Decrypt the cipher bytes using doFinal method 
*/
aesCipher.init(Cipher.DECRYPT_MODE,secretKey,aesCipher.getParameters());
byte[] byteDecryptedText = aesCipher.doFinal(byteCipherText);
strDecryptedText = new String(byteDecryptedText);
System.out.println(“ Decrypted Text message is “ +strDecryptedText);
}
catch (NoSuchAlgorithmException noSuchAlgo)
{
System.out.println(“ No Such Algorithm exists “ + noSuchAlgo);
}
catch (NoSuchPaddingException noSuchPad)
{
System.out.println(“ No Such Padding exists “ + noSuchPad);
}
catch (InvalidKeyException invalidKey)
{
System.out.println(“ Invalid Key “ + invalidKey);
}
catch (BadPaddingException badPadding)
{
System.out.println(“ Bad Padding “ + badPadding);
}
catch (IllegalBlockSizeException illegalBlockSize)
{
System.out.println(“ Illegal Block Size “ + illegalBlockSize);
}
catch (InvalidAlgorithmParameterException invalidParam)
{
System.out.println(“ Invalid Parameter “ + invalidParam);
}
}
}
A6 - Sensitive Data Exposure
127
1.1.4 References
[1] Bruce Schneier, Applied Cryptography, John Wiley & Sons, 2nd edition, 1996.
[2] Michael Howard, Steve Lipner, The Security Development Lifecycle, 2006, pp. 251 - 258
[3] .NET Framework Developer’s Guide, Cryptographic Services, http://msdn2.microsoft.com/en-us/library/93bsk-
f9z.aspx
[4] Microsoft Developer Network, Windows Data Protection, http://msdn2.microsoft.com/en-us/library/
ms995355.aspx
[5] Sun Developer Network, Java Cryptography Extension, http://java.sun.com/products/jce/
[6] Sun Developer Network, Cryptographic Service Providers and Clean Room Implementations, http://java.sun.
com/products/jce/jce122_providers.html
[7] Federal Information Processing Standards, http://csrc.nist.gov/publications/fips/
12.5 Encryption, Hashing & Salting
A cryptographic hash algorithm, also called a hash function, is a computer algorithm designed to provide a random 
mapping from an arbitrary block of data (string of binary data) and return a fixed-size bit string known as a “message 
digest” and achieve certain security.
Cryptographic hashing functions are used to create digital signatures, message authentication codes (MACs), other 
forms of authentication and many other security applications in the information infrastructure. They are also used 
to store user passwords in databases instead of storing the password in clear text and help prevent data leakage in 
session management for web applications. The actual algorithm used to create a cryptology function varies per im-
plementation (SHA-256, SHA-512, etc.)
Never accept in a code review an algorithm created by the programmer for hashing. Always use cryptographic func-
tions that are provided by the language, framework, or common (trusted) cryptographic libraries. These functions are 
well vetted and well tested by experience cryptographers.
In the United States in 2000, the department of Commerce Bureau of Export revised encryption export regulations. 
The results of the new export regulations it that the regulations have been greatly relaxed. However if the code is to 
be exported outside of the source country current export laws for the export and import counties should be reviewed 
for compliance. 
Case in point is if the entire message is hashed instead of a digital signature of the message the National Security 
Agency (NSA) considers this a quasi-encryption and State controls would apply.
It is always a valid choice to seek legal advice within the organization if the code review is being done to ensure legal 
compliance.
With security nothing is secure forever. This is especially true with cryptographic hashing functions.  Some hashing 
algorithms such as Windows LanMan hashes are considered completely broken. Others like MD5, which in the past 
were considered safe for password hash usage, have known issues like collision attacks (note that collision attacks do 
not affect password hashes). The code reviewer needs to understand the weaknesses of obsolete hashing functions 
as well as the current best practices for the choice of cryptographic algorithms. 
A6 - Sensitive Data Exposure
128
Working with Salts
The most common programmatic issue with hashing is:
• Not using a salt value
• Using a salt the salt value is too short
• Same salt value is used in multiple hashes. 
The purpose of a salt is to make it harder for an attacker to perform pre-computed hashing attack (e.g., using rainbow 
tables).  Take for example that the SHA512 has of ‘password’ is as shown in row 1 of table 20, and any attacker with a 
rainbow table will spot the hash value corresponding to ‘password’.  Taking into consideration it takes days or weeks 
to compute a rainbow table to values up to around 8 or 10 characters, the effort to produce this table is worth it when 
an application is not using any salts.
Now take a scenario where an application adds a salt of ‘WindowCleaner’ to all passwords entered.  Now the hash of 
‘password’ becomes the hash of ‘passwordWindowCleaner’, which is shown in row 2 of table 20.  This is unlikely to be 
in the attackers rainbow table, however the attacker can now spend the next 10 days (for example) computing a new 
rainbow table with ‘WindowCleaner’ on the end of every 8 to 10 character string and they again can now decode our 
hashed database of passwords.
At a last step, an application can create a random salt for each entry, and store that salt in the DB with the hashed 
password.  Now for user1, the random salt is ‘a0w8hsdfas8ls587uas87’, meaning the password to be hashed is ‘pass-
worda0w8hsdfas8ls587uas87’, shown in row 3 of table 20, and for user2, the random salt is ‘8ash87123klnf9d8dq3w’, 
meaning the password to be hashed is ‘password8ash87123klnf9d8dq3w’, shown in row 4 of table X, and repeat for 
all users. 
Now an attacker would need a rainbow table for each users’ password they mean to decrypt – whereas before it took 
10 days to decrypt all of the DB passwords using the same salt, now it takes 10 days to create a rainbow table for 
user1’s password, and another 10 days for user2’s password, etc.  If there were 100,000 users, that’s now 100,000 x 10 
days = 1,000,000 days or 2738 years, to create rainbow tables for all the users.
As can be seen, the salt does not need to be secret, as it is the fact that unique salts are used for each user that 
slows down an attacker.
Fingerprint
Method to hash ‘password’
No salt
B109F3BBBC244EB82441917ED06D618B9008DD09B3
BEFD1B5E07394C706A8BB980B1D7785E5976EC049B
46DF5F1326AF5A2EA6D103FD07C95385FFAB0CACBC86
Salt = ‘WindowCleaner’
Salt = ‘a0w8hsdfas8ls587uas87’
Salt = ‘8ash87123klnf9d8dq3w’
E6F9DCB1D07E5412135120C0257BAA1A27659D41DC7
7FE2DE4C345E23CB973415F8DFDFFF6AA7F0AE0BDD
61560FB028EFEDF2B5422B40E5EE040A0223D16F06F
5AA762E7C83CFF223B5A00ADA939FBD186C4A2CD01
1B0A7FE7AF86B8CA5420C7A47B52AFD2FA6B9BB172
22ACF32B3E13F8C436447C36364A5E2BE998416A103A
8058D43195B1CF2794D012A86AC809BFE73254A82C8C
E6C10256D1C46B9F45700D040A6AC6290746058A63E5
0AAF8C87ABCD5C3AA00CDBDB31C10BA6D12A1A7
Table 20: Salt usages and associated fingerprints
A6 - Sensitive Data Exposure
129
One way to generate a salt value is using a pseudo-random number generator, as shown in sample 12.4 below.
Note that a salt value does not need to possess the quality of a cryptographically secure randomness.
Best practices is to use a cryptographically function to create the salt, create a salt value for each hash value, 
and a minimum value of 128 bits (16 characters). The bits are not costly so don’t save a few bits thinking you 
gain something back in performance instead use a value of 256-bit salt value. It is highly recommended. 
Best Practices
Industry leading Cryptographer’s are advising that MD5 and SHA-1 should not be used for any applications. 
The United State FEDERAL INFORMATION PROCESSING STANDARDS PUBLICATION (FIPS) specifies seven cryp-
tographic hash algorithms — SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 
are approved for federal use.
 The code reviewer should consider this standard because the FIPS is also widely adopted by the information 
technology industry. 
The code reviewer should raise a red flag if MD5 and SHA-1 are used and a risk assessment be done to under-
stand why these functions would be used instead of other better-suited hash functions. FIPS does allow that 
MD5 can be used only when used as part of an approved key transport scheme where no security is provided 
by the algorithm.
sample 12.5 below shows an example function which could implement a generic hash feature for an applica-
tion. 
   private int minSaltSize = 8;
    private int maxSaltSize = 24;
    private int saltSize; 
    private byte[] GetSalt(string input) {
            byte[] data;
            byte[] saltBytes;
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            saltBytes = new byte[saltSize];
            rng.GetNonZeroBytes(saltBytes);
            data = Encoding.UTF8.GetBytes(input);
            byte[] dataWithSaltBytes =
                new byte[data.Length + saltBytes.Length];
            for (int i = 0; i 
C# Code:
   1:  preferredHash = HashAlgorithm.Create((string)ConfigurationManager.AppSettings[“HashMethod”]);