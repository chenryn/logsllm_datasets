ğ‘ (ğ‘–)
given the authenticity of the garbled circuit scheme, this second
execution of the prover will be successful with probability at least
ğœŒâ€² = ğœŒ âˆ’ AdvauthGC (ğœ…). If the prover is not successful after the fork, B
will try again with a different value of ğ›¿2 until the prover succeeds.
By the Forking Lemma (Appendix A.3), in expected time ğ‘‚(ğœğ‘/ğœŒâ€²2),
1) and (ğ‘ 2, ğ‘¡2, ğ‘¡â€²
the adversary will obtain values (ğ‘ 1, ğ‘¡1, ğ‘¡â€²
2) such that:
ğ´) = (ğ‘ 1 âˆ’ ğ‘ âˆ—) ğ´ + ğ‘¡â€²
ğ‘–=1 2ğ‘–âˆ’1ğ‘§(ğ‘–)
com = ğ‘ 1 ğ´ + ğ‘¡1 ğ‘ƒ
1ğ‘ƒ
ğ´) = (ğ‘ 2 âˆ’ ğ‘ âˆ—) ğ´ + ğ‘¡â€²
ğ‘–=1 2ğ‘–âˆ’1ğ‘§(ğ‘–)
com = ğ‘ 2 ğ´ + ğ‘¡2 ğ‘ƒ
2ğ‘ƒ .
Now, if ğ‘ 1 â‰ ğ‘ ğ‘ 2, the discrete logarithm of ğ´ can be extracted as
ğ‘ (cid:66) (ğ‘¡2 âˆ’ ğ‘¡1)/(ğ‘ 1 âˆ’ ğ‘ 2). Otherwise, let ğ‘  (cid:66) ğ‘ 1 (=ğ‘ ğ‘ 2), and assume
that ğ‘  â‰ ğ‘ ğ‘ âˆ—. We have,
1 ( Ë†ğµ âˆ’ğ‘›
2 ( Ë†ğµ âˆ’ğ‘›
0 = ğ›¿2 + ğ»(ğ‘ (ğ‘–)
ğ›¿-1
ğ›¿-1
ğ‘ âˆ—
ğ‘ âˆ—
ğ‘–
ğ‘–
ğ›¿1(ğ‘  âˆ’ ğ‘ âˆ—) ğ´ + ğ›¿1ğ‘¡â€²
1 ğ‘ƒ = ğ›¿2(ğ‘  âˆ’ ğ‘ âˆ—) ğ´ + ğ›¿2ğ‘¡â€²
2 ğ‘ƒ ,
so we can extract the discrete logarithm of ğ´ as
ğ‘ (cid:66)
ğ›¿2ğ‘¡â€²
2 âˆ’ ğ›¿1ğ‘¡â€²
1
(ğ›¿1 âˆ’ ğ›¿2)(ğ‘  âˆ’ ğ‘ âˆ—)
.
Session 2E: Smart Contracts and Cryptocurrencies CCS '20, November 9â€“13, 2020, Virtual Event, USA649FCOT (choose, {ğ‘¥ğ‘–}ğ‘–âˆˆ[ğ‘š])
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’
{ğ‘ (ğ‘–)
0 , ğ‘ (ğ‘–)
1 }ğ‘–âˆˆ[ğ‘›]
GC, FCOT (transfer, {ğ¿(ğ‘–)
ğ‘¥ğ‘– }ğ‘–âˆˆ[ğ‘š])
â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’
Verifier(com, ğ´, ğ‘“ )
Garble(1ğœ…, ğ‘“ ) â†’
(GC, {ğ¿(ğ‘–)
1 }ğ‘–âˆˆ[ğ‘š], {ğ‘ (ğ‘–)
0 , ğ¿(ğ‘–)
0 â†$ Zğ‘ and set ğ‘§(ğ‘–)
âˆ€ğ‘– âˆˆ [ğ‘›], ğ‘§(ğ‘–)
âˆ€ğ‘ âˆˆ {0, 1}, âˆ€ğ‘– âˆˆ [ğ‘›], ğ‘ (ğ‘–)
ğ‘ (cid:66) ğ‘§(ğ‘–)
1 }ğ‘–âˆˆ[ğ‘›])
0 , ğ‘ (ğ‘–)
0 +ğ›¿
1 (cid:66) ğ‘§(ğ‘–)
ğ‘ + ğ»(ğ‘ (ğ‘–)
ğ‘ )
Ë†ğµ
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’
ğ›¿, FCOT (open-all), {ğ‘ (ğ‘–)
1 }ğ‘–âˆˆ[ğ‘›]
â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’
0 , ğ‘ (ğ‘–)
compute ğµ (cid:66) ğ›¿-1(cid:16) Ë†ğµ âˆ’ğ‘›
0 ğ´(cid:17)
ğ‘–=1 2ğ‘–âˆ’1ğ‘§(ğ‘–)
Prover(com, ğ´, ğ‘“ , ğ‘ , ğ‘¥, ğ‘¡)
(s.t. com = ğ‘  ğ´ + ğ‘¡ ğ‘ƒ âˆ§ ğ‘“ (ğ‘¥) = ğ‘ )
{ Ë†ğ‘ (ğ‘–)
ğ‘ ğ‘– }ğ‘–âˆˆ[ğ‘›] â† Eval(GC, {ğ¿(ğ‘–)
âˆ€ğ‘– âˆˆ [ğ‘›], set Ë†ğ‘§(ğ‘–)
ğ‘ ğ‘–
sample Ë†ğ‘¡ â†$ Zğ‘; compute Ë†ğµ (cid:66) Ë†ğ‘¡ ğ‘ƒ +ğ‘›
ğ‘¥ğ‘– }ğ‘–âˆˆ[ğ‘š])
ğ‘ ğ‘– âˆ’ ğ»( Ë†ğ‘ (ğ‘–)
ğ‘ ğ‘– )
ğ‘–=1 2ğ‘–âˆ’1 Ë†ğ‘§(ğ‘–)
(cid:66) ğ‘ (ğ‘–)
ğ‘ ğ‘–
ğ´
set Ë†ğ‘§(ğ‘–)Â¬ğ‘ ğ‘– = Ë†ğ‘§(ğ‘–)
abort if Verify(GC, ğ‘“ , {ğ¿(ğ‘–)
1 }, {ğ‘ (ğ‘–)
0 , ğ¿(ğ‘–)
or âˆƒğ‘– âˆˆ [ğ‘›], ğ‘ âˆˆ {0, 1} : ğ‘ (ğ‘–)
ğ‘ â‰ ğ‘ ğ‘§(ğ‘–)
ğ‘ ğ‘– +(-1)ğ‘ ğ‘– ğ›¿, âˆ€ğ‘– âˆˆ [ğ‘›] and ğ‘¡â€² (cid:66) ğ›¿-1Ë†ğ‘¡
1 }) = 0
0 , ğ‘ (ğ‘–)
ğ‘ )
ğ‘ + ğ»(ğ‘ (ğ‘–)
â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’
PoK(cid:8)(ğ‘ , ğ‘¡, ğ‘¡â€²) : com = ğ‘  ğ´ + ğ‘¡ ğ‘ƒ âˆ§ ğµ = ğ‘  ğ´ + ğ‘¡â€²ğ‘ƒ(cid:9)
accept iff PoK is accepting
Figure 4: Description of our protocol for hybrid statements for PoK {(ğ‘ , ğ‘¥, ğ‘¡) : com = ğ‘  ğ´ + ğ‘¡ ğ‘ƒ âˆ§ ğ‘“ (ğ‘¥) = ğ‘ }, where ğ´, com âˆˆ ğº for
a group (of order ğ‘), generated by ğ‘ƒ, circuit ğ‘“ : {0, 1}ğ‘š â†’ {0, 1}ğ‘›, and function ğ» : {0, 1}âˆ— â†’ Zğ‘.
When ğœ is polynomial in the security parameter and ğœŒ is non-
negligible, our adversary B runs in expected polynomial time. This
completes the proof.
â–¡
5 IMPLEMENTATION
We implement a general library for zero-knowledge proofs on arith-
metic circuits combined with algebraic statements, based on our
protocol from Figure 4. Our library is written in C/C++17 (compiled
using the g++ compiler from GCC) and uses the Relic-Toolkit [3]
for elliptic curves and the EMP-Toolkit [43] for garbled circuits and
committing oblivious transfer. Our code is publicly available and
open source for reproducibility and verifiability.6
In this section, we present the implementation details and mea-
surements of our library applied to the construction of an infor-
mation CP system for various purposes. In particular, we explore
the application of selling an ECDSA signature or RSA signature
on an agreed message. In Sections 5.1 and 5.2 we propose two
methods to argue (in zero-knowledge) knowledge of an ECDSA
or RSA signature (respectively) by showing the knowledge of a
discrete logarithm. Therefore these methods can be instantiated
very efficiently using the celebrated Schnorr sigma-protocol [40].
In all cases, we assume the seller (the prover) has encrypted
the secret ğ‘  to be sold under some key ğ‘˜, producing a ciphertext
ğ‘ â† Encğ‘˜(ğ‘ ), computed ğ‘¦ (cid:66) SHA(ğ‘˜) and shared both values (ğ‘, ğ‘¦)
with the buyer (the verifier). The seller then committed to the secret
ğ‘  as com = ğ‘  ğ´ + ğ‘¡ ğ‘ƒ, for some ğ‘¡ chosen uniformly at random, where
ğ´ is an EC group element with unknown dlog (at least, unknown
to the seller, ğ´ may be chosen by the verifier).
Our implementation consists of the computation of the previous
values and the execution of the protocol from Figure 4, so that
the verifier gets convinced about the fact that the value the seller
committed to in com is the output of circuit ğ‘“(ğ‘,ğ‘¦) on some input
6Source code at https://github.com/security-kouza/cont-pay.
(on ğ‘˜), where ğ‘“ is defined as:
ğ‘“(ğ‘,ğ‘¦)(ğ‘˜) (cid:66) Decğ‘˜(ğ‘) if ğ‘¦ = SHA(ğ‘˜) else âŠ¥ .
They will then execute an algebraic protocol where the prover
convinces the verifier about the fact that com contains a valid
(ECDSA or RSA) signature. In the next sections we describe how
these algebraic protocols can be implemented as knowledge of a
discrete logarithm.
ğ‘¥ = ğ‘Ÿ
5.1 ECDSA Signatures
First we recall the definition of ECDSA signatures. Key generation
selects an elliptic curve of order ğ‘ with generator ğ‘ƒ, samples ğ‘‘ â†$ Zğ‘
and produces (PK, SK) (cid:66) (ğ‘„, ğ‘‘), where ğ‘„ = ğ‘‘ ğ‘ƒ.
Sign(SK, ğ‘š) :
Verify(PK, ğ‘š, (ğ‘Ÿ, ğ‘ )) :
ğ¾â€² (cid:66) ğ‘ -1Â·SHA(ğ‘š) ğ‘ƒ + ğ‘ -1Â·ğ‘Ÿ ğ‘„
accept iff ğ¾â€²
ğ‘˜ â†$ Zğ‘
ğ¾ (cid:66) ğ‘˜ğ‘ƒ (cid:66) (ğ‘Ÿ, ğ¾ğ‘¦)
ğ‘  =ğ‘ ğ‘˜-1 (SHA(ğ‘š) + ğ‘ŸÂ·ğ‘‘)
output (ğ‘Ÿ, ğ‘ )
We propose a very efficient algebraic method to prove knowl-
edge of an ECDSA signature. This method is not completely zero-
knowledge in the sense that it reveals the first component of the
signature ğ‘Ÿ, whereas it is zero-knowledge for the second compo-
nent. Such a method can still be useful to perform fair-exchange
of a ECDSA signature, in scenarios where the signature is freshly
generated (in those scenarios, ğ‘Ÿ can be simulated by just taking the
ğ‘¥ coordinate of elliptic curve point chosen uniformly at random).
More concretely, after computing a signature (ğ‘Ÿ, ğ‘ ) on an agreed
message ğ‘š, the prover can share ğ¾ (sampled during the signature
generation) with the verifier and perform the zero-knowledge proof
(the prover can use ğ‘ -1 as the witness ğ‘¤):
PoK {(ğ‘¤) : ğ¾ = ğ‘¤ (SHA(ğ‘š) ğ‘ƒ + ğ¾ğ‘¥ ğ‘„)} .
(4)
Session 2E: Smart Contracts and Cryptocurrencies CCS '20, November 9â€“13, 2020, Virtual Event, USA650Observe that the knowledge of ğ¾ and such a ğ‘¤ implies the knowl-
edge of an ECDSA signature for message ğ‘š: (ğ¾ğ‘¥, ğ‘¤-1).
Prover(ğ‘ , ğ‘¡, ğ‘¡â€²) :
Verifier:
5.2 RSA Signatures
Apart from the information CP system to sell ECDSA signatures,
we also experiment with the Full Domain Hash RSA signature
scheme [10]. We first recall the scheme specifications. On input ğœ…
as a security parameter, the key generation chooses two ğœ…-bit primes
ğ‘, ğ‘, computes ğ‘ (cid:66) ğ‘ğ‘ and selects some ğ‘’ âˆˆ Zâˆ—
ğœ‘(ğ‘ ), where ğœ‘ repre-
sents Eulerâ€™s totient function. It then computes ğ‘‘ (cid:66) ğ‘’-1 (mod ğœ‘(ğ‘)),
and the public key is defined as PK = (ğ‘ , ğ‘’), whereas the secret key
is set to SK = ğ‘‘. Let ğ» : {0, 1}âˆ— â†’ Zâˆ—
ğ‘ . The signing and verification
procedures are as follows.
Sign(SK, ğ‘š) :
â„ (cid:66) ğ»(ğ‘š)
ğœ (cid:66) â„ğ‘‘ (mod ğ‘ )
output ğœ
Verify(PK, ğ‘š, ğœ) :
â„ (cid:66) ğ»(ğ‘š)
accept iff â„ =ğ‘ ğœğ‘’
In order to prove in zero-knowledge the knowledge of an RSA
signature ğœ on an agreed message ğ‘š (let â„ = ğ»(ğ‘š)), the parties
can proceed as follows. The seller will sample ğ‘Ÿ â†$ Zğ‘ , compute
ğ›¼ (cid:66) â„ğ‘Ÿ (mod ğ‘ ) and send ğ‘¡ (cid:66) ğœğ›¼ (mod ğ‘ ), to the buyer. Since the
distribution of ğ›¼ is statistically close to the uniform distribution
over the subset of Zğ‘ generated by â„, ğ›¼ acts as a blinding factor
on the signature ğœ (which lives in the same subgroup). The prover
now performs a zero-knowledge proof of:
PoK(cid:8)(ğ‘Ÿ) : (ğ‘¡ğ‘’/â„) =ğ‘ (â„ğ‘’)ğ‘Ÿ(cid:9) .
(5)
Observe that the knowledge of dlog ğ‘Ÿ of (ğ‘¡ğ‘’/â„) in base (â„ğ‘’)
implies the knowledge of a valid signature for ğ‘š. More precisely,
one could compute a signature ğœ as ğ‘¡â„âˆ’ğ‘Ÿ (mod ğ‘ ), since
ğœğ‘’ =ğ‘ (ğ‘¡â„âˆ’ğ‘Ÿ)ğ‘’ =ğ‘ ğ‘¡ğ‘’(â„ğ‘’)âˆ’ğ‘Ÿ =ğ‘ ğ‘¡ğ‘’â„/ğ‘¡ğ‘’ =ğ‘ â„ = ğ»(ğ‘š) .
Remark 6. Observe that this protocol can be applied to scenar-
ios where the signed message is known to both parties. In those
cases, the relation to be proven is between signature ğœ and element
â„. Therefore, the full domain hash or, alternatively, the encoding
scheme like PKCS#1 padding or PSS encoding (used to convert a bit-
string message into integer â„) is not important for the application
of this protocol.
5.3 Linking with the CP functionality
Observe that both in the case of ECDSA signatures and RSA sig-
natures, we have reduced the problem of proving knowledge of a