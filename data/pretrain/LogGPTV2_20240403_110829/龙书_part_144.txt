分块
for (i=0; i和使得
个分离的强连通图中的语句，它们分别在迭代i讠和i中访问相同的数据。如果我们不能分别为
比如，转置一个矩阵的开销要比两个相邻处理器之间通信的开销高得多。假设s和s 分别是两
在程序依赖图中共享大部分数据的子集之间寻找无同步的并行性。
但是，某些这样的分量仍然可能在无同步和通信的情况下被并行化。解决方法之一是尽可能地
个扩展，以解决此算法的弱点。
同步栅障进行并行化。
分划单元的编号。在这个例子中，我们发现内层循环是可并行化的，因此这个代码可以使用n 个
流水线化的并行性。在步骤3的第二部分，我们应用算法11.54 来并行化内层循环。我们像处理
有--个合法的外层循环，这个循环就是图11-53 中的原代码中的循环。因此，这个循环不具有可
为了并行化这个代码，我们需要的同步量大于一个常量。在步骤3中，应用算法11.59 确定了只
例11.65现在让我们回到例11.56。算法 11.64 的步骤1和 2 都没有找到并行性。也就是说，
成的各个空间分划单元中的计算任务上。
11.54。如果前面没有找到流水线化的并行性，就对串行循环的循环体应用算法11.54。
法11.59，以找出可流水线化的并行性。然后对分配给各个处理器的分划单元逐个应用算法
划单元中。）
用算法11.54。（如果在步骤1中没有找到无同步的并行性，那么所有的计算任务都在同一个分
如果强连通分量之间的通信是必须的，我们注意到有些通信的开销要高过其他通信的开销，
4）在逐步增加同步度数的情况下寻找最大的并行性度数。递归地把步骤3应用到上一步生
3）找出需要 0(n)次同步运算的最大并行性度数。对步骤2 中找到的每个分划单元应用算
558
如果没有发现无同步的并行性，算法11.64 的步骤2 对每个强连通分量独立地进行并行化。
算法11.64 找出了一个程序中在各个同步层面上的并行性。这个算法优先求出需要较少同
有些时候，我们宁愿多进行一些同步运算以降低通信量。例11.66 讨论了--个这样的例子。
用通信量交换同步量
考虑通信开销
2）找出需要0(1)次同步运算的并行性的最大度数：对步骤1中找出的所有空间分划单元应
1）找出不需要同步运算的并行性的最大度数，对这个程序应用算法11.43。
方法：完成下列步骤：
Ci +c1 -C2i2-c2≤8
Ci +c -C2i2-C2 =0
第11章
口
---
## Page 575
其他的等式和不等式是
术上讲，这两个向量都是转置的。
是(i,)，向量i是(i2,j2)。从技
单的时间分划约束的例子应用算法
有1000个块。
问题3中的块应该是10×10×10，且
个边长为100的三维立方体。因此，
P2个块。
参数来表示一
这个代码。因为迭代空间形成了一个三角形，总共只有1+2++10= 55个块。用P1、P2作为
出其代码，并指出必要的同步运算。
器来实现这个代码。为每个处理器p
可交换的循环嵌套结构。
体的方法总数。
P[i,将变成从i个物体中选择j个物
① 135°,②120°。
11-51中的代码流水线化的可能性。对于以下度数的斜线，写出和图11-52中的循环类似的代码：
11.9.1011.9 节的练习
需要的通信量要小很多。
这个方案将带来 0(n)次的同步，但是
们可以应用分块技术来降低通信开销。
嵌套结构，如图 11-59 所示。然后，我
11.59。在下面的内容中假设向量i讠
个程序转换成为一个完全可交换的循环
构成：
件
i<si由下列子句的析取
！练习11.9.5：让我们对一个简
3）使用边长为10个迭代的块改写
1）把这个代码改写为单一的、完全
练习11.9.1：在11.9.4 节中，我们讨论了使用倾斜的轴，而不是用水平轴或垂直轴来将图
并行性和局部性优化
②i=i2且j<j2
①i<iz，或者
练
2）在一个流水线中使用100个处理
练习11.9.3：图
练习11.9.2：如果6能够整除n，那么图11-55b 可以进一步简化。按照这种假设改写代码,
东习11.9.4：对图11-61中的代码重复练习11.9.3。但是请注意，这个问题的迭代形成了-
图 11-60中是一个计算 Pascal 三角形的前 100 行的程序。也就是说，对0≤j≤i<100,
式
写
j =j2 +40
i = i2+j2 -50
i2 +2i2-20≥0
2i +j -10 ≥0
for （i=0; i<100;1++){
图11-59例11.49的代码的--个完全可交换循环嵌套结构
for (i=0; i<99; i++)
for (j= O; j< n; j++)
A[99,j，
(j=1; j<99; 
A[i,99,0] = ]
for
for
for
二
0,j,
(i=2;i<100;i++)
（i=0；i<100;i
for (k=1; k<100; k++)
图11-61 练习11.94 的代码
j<99;
图 11-60计算 Pascal 三角形
A[i,j+1,k-1];
j++）
i++）{
/*s2
/* s1
/55*1
##
559
---
## Page 576
这个数组，把它替换为一个标量，并让各个选代使用同一个位置。
样，使用更多的内存可以得到更多的循环级并行性。如11.7.1节中的多网格例子所示，把-一个
一起也是很有好处的。我们在这里使用的算法和算法11.64 类似，它从最外层循环开始寻找所有
序遍历了各个独立的分划单元。转换得到的这个代码具有较好的局部性，因为计算得到的结果
结果数据的时间局部性。让我们回顾一下 11.7.1节中讨论的多网格的例子。应用算法11. 43 来
这样做可以使得分划单元之间的复用更加靠近。
间局部性的方法是把一个计算任务分割成为独立的分划单元，并把各个分划单元中具有依赖关
11.10局部性优化
它们同时执行。反过来，如果我们有一个每次只操作一个数组元素的顺序执行过程，就可以收缩
临时的标量变量变成--个数组就可以允许不同的选代使用这个临时变量的不同实例，也就允许
在10.2.3节中讨论指令级并行性时引人。使用更多寄存器可以得到更大的指令级并行性。同
11.10.2 数组收缩
被单独并行化的强连通分量之间存在复用，我们就尽可能地把它们组合起来。
个算法就对各个强连通分量单独进行并行化。这个并行化方法常常会增加通信量。因此，如果
的并行性粒度。如11.9.9节中讨论的，如果我们在每个层次上都不能找到无同步的并行性，这
立刻就在同-一个迭代中使用。
并行化图11-23中的代码，找到了2度的并行性。图11-24中的代码包含两个外层循环，它们顺
11.10.1计算结果数据的时间局部性
读数据的时间和空间局部性。我们可以交替执行多个分划单元，而不是一个接一个地执行它们。
目。如果在任意给定时刻该数组只有一个位置被使用，我们就可以应用数组收缩技术。
系的运算紧靠在一起执行。
理器系统和多处理器系统中提高数据局部性的技术。