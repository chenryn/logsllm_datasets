# 【技术分享】32位下的堆喷射技术
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
作者：[seviezhou](http://bobao.360.cn/member/contribute?uid=2967223576)
预估稿费：500RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**什么是堆喷射**
****为了在浏览器攻击中获得可预测的shellcode地址，堆喷射( **Heap Spray** )技术被发明出来，Heap
Spray技术在Exploit中的利用开始于2001年，针对浏览器的堆喷射一般通过JavaScript执行，通过JavaScript申请大段的堆内存，再通过漏洞控制EIP，跳到堆中可预测的地址处执行shellcode，Heap
Spray技术不仅仅可以用于浏览器，对于Adobe PDF
Reader等支持JavaScript的程序也可以使用堆喷射技术把shellcode放在可预测的地址，还有用图片进行Heap
Spray的技术，堆喷射技术使得针对浏览器等程序的攻击变得相对简单化和稳定，而且可以写出更加通用的Exploit，虽然 **ASLR** 和 **DEP**
的出现使得堆喷射的攻击更加困难，但精准的堆喷加上ROP也能够在这种情况下成功Exploit，下面会分别介绍对于不同版本IE浏览器的堆喷的不同之处。  
**  
**
**用windbg调试浏览器**
为了使用有关堆的调试命令，需要在windbg中配置符号表，只要在Symbol file path中输入:
    SRV*c:windbgsymbols*http://msdl.microsoft.com/download/symbols
然后关闭windbg并点击保存工作空间。
然后讲一下调试中使用的主要命令:
!heap -stat显示被调试进程的所有堆使用情况:
    0:007> !heap -stat
    _HEAP 00140000
         Segments            00000002
             Reserved  bytes 00200000
             Committed bytes 0009d000
         VirtAllocBlocks     000001f5
             VirtAlloc bytes 80800050
    ...
    ...
!heap -a 00140000关于00140000处堆的详细情况，输出会有些多:
    0:007> !heap -a 00140000
    Index   Address  Name      Debugging options enabled
      1:   00140000 
        Segment at 00140000 to 00240000 (0007e000 bytes committed)
        Flags:                00000002
        ForceFlags:           00000000
        Granularity:          8 bytes
        Segment Reserve:      00100000
        Segment Commit:       00002000
        DeCommit Block Thres: 00000200
        DeCommit Total Thres: 00002000
        Total Free Size:      00000c0f
        Max. Allocation Size: 7ffdefff
        Lock Variable at:     00140608
        Next TagIndex:        0000
        Maximum TagIndex:     0000
        Tag Entries:          00000000
        PsuedoTag Entries:    00000000
        Virtual Alloc List:   00140050
        UCR FreeList:        00140598
        FreeList Usage:      00040078 00000040 00000000 00000000
    ...
    ...
!heap -stat -h 00140000可以查看00140000堆的分配统计数据:
    0:007> !heap -stat -h 00140000
     heap @ 00140000
    group-by: TOTSIZE max-display: 20
        size     #blocks     total     ( %) (percent of total busy bytes)
        7ffe0 1f5 - fa7c160  (99.78)
        8000 1 - 8000  (0.01)
        7fe0 1 - 7fe0  (0.01)
        7fb0 1 - 7fb0  (0.01)
        619c 1 - 619c  (0.01)
        614 e - 5518  (0.01)
        52ac 1 - 52ac  (0.01)
        4fe4 1 - 4fe4  (0.01)
    ...
    ...
!heap -flt s 7ffe0查看大小为7ffe0的内存，在堆喷的时候可以方便的找到payload所在的地址:
    0:007> !heap -flt s 7ffe0
        _HEAP @ 140000
          HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
            02240018 fffc 0000  [0b]   02240020    7ffe0 - (busy VirtualAlloc)
            01fe0018 fffc fffc  [0b]   01fe0020    7ffe0 - (busy VirtualAlloc)
            022c0018 fffc fffc  [0b]   022c0020    7ffe0 - (busy VirtualAlloc)
            02340018 fffc fffc  [0b]   02340020    7ffe0 - (busy VirtualAlloc)
    ...
    ...
这里HEAP_ENTRY是堆的头部，UserPtr是BSTR对象头部:
    0:007> dd 02240018
    02240018  00000020 00000b00 0007ffd4 90909090
    02240028  90909090 90909090 90909090 90909090
    02240038  90909090 90909090 90909090 90909090
!heap -p -a 0x0c0c0c0c查看0x0c0c0c0c处的数据属于哪个堆:
    0:007> !heap -p -a 0x0c0c0c0c
        address 0c0c0c0c found in
        _HEAP @ 140000
          HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
            0c0c0018 fffc 0000  [0b]   0c0c0020    7ffe0 - (busy VirtualAlloc)
还有在内存空间搜索字符串可以用s命令，-a表示搜索ascii，-u表示搜索unicode:
    0:007> s -a 0x00000000 L?7fffffff "AAAA"
    0018ef03  41 41 41 41 41 41 41 64-64 64 64 64 64 18 89 89  AAAAAAAdddddd...
    0018ef04  41 41 41 41 41 41 64 64-64 64 64 64 18 89 89 89  AAAAAAdddddd....
    ...
    ...
**堆喷射内存布局**
在浏览器中分配的字符串都会被转换成unicode，所以为了准确传递字符，我们需要使用JavaScript中的 **unescape**
函数，这个函数用于解码字符串，所以用已经是unicode的字符串，在内存中就不会再次被转换成unicode了，用%u加在每两字节之前，注意两字节要反序排列。分配字符串后会变成BSTR字符串对象，含有四字节的头信息和两个NULL字节的结尾。
一般的堆喷射内存布局就是大量的nop指令(也称为滑板指令)加上shellcode，shellcode放在每个块的尾部，只要保证喷射堆块足够大，那么预测的地址处就会是nop指令，然后执行到shellcode。
在堆喷中最著名的地址要数 **0x0c0c0c0c**
了，解释一下为什么使用这个地址。如果在Exploit中通过覆盖堆栈中的虚表的话，使用这个地址就会十分合适，当虚函数被调用时，先取得栈中的对象指针，通过对象指针取得虚表指针，然后在虚表内适当偏移处取得函数指针执行，示意图:
       Stack
    +---------+          Object
    | obj_ptr | ---->  +--------+        Vtable
    +---------+        |p_Vtable| ---> +-------+
    |         |        +--------+      |p_func1| ----> func1
    +---------+        |        |      +-------+
    |         |        +--------+
    +---------+
假如将obj_ptr覆盖为0x0c0c0c0c，将0x0c0c0c0c地址内的内容填为x0cx0cx0cx0c，那么顺着这条调用链，最后还是会调用0x0c0c0c0c地址处的指令，而且:
    004010A0  0C 0C   OR AL,0C
    004010A2  0C 0C   OR AL,0C
可见0c0c指令作用和nop一样，也可以作为滑板指令。  
接下来计算一下到底需要多大的内存块才能喷射到0x0c0c0c0c:
    0x0c0c0c0c = 202116108
    202116108字节(b)=192.7529411兆字节(mb)
所以只要堆喷射大于200MB就肯定能够喷射到目标地，但由于分配的起始地址并不是从零开始，所以实际中并不需要那么大的内存，还有一个要注意的点就是unescape返回的对象在用.length计算长度时返回的是实际长度的一般，也就是说:
    > s = unescape("%u4142%u4344%u4546")
    > s.length
    3
一份堆喷射的脚本可能看起来像这样:
        tag = unescape('%u4141%u4141');
        chunk = '';
        chunksize = 0x1000;
        nr_of_chunks = 200;
        for (counter = 0; counter < chunksize; counter++) {
            chunk += unescape('%u9090%u9090');
        }
        chunk = chunk.substring(0, chunksize - tag.length);
        testarray = new Array();
        for (counter = 0; counter < nr_of_chunks; counter++) {
            testarray[counter] = tag + chunk;
        }