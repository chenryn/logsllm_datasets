# FlameGraph/flamegraph.pl out.folded > out.sv重点总结我们这一讲学习了如何使用 perf，这里我来给你总结一下重点。首先，我们在线上网络延时异常的那个实际例子中使用了perf。我们发现可以用 perf工具，通过**抓取数据、数据读取和异常聚焦这**三个步骤的操作，在 CPU Usage 增高的节点上找到具体引起 CPU增高的函数。之后我带你更深入地学习了 perf 是什么，它的工作方式是怎样的？这里我把perf 的重点再给你强调一遍：Perf 的实现基础是 event，有两大类，一类是基于硬件 PMU的，一类是内核中的软件注册。而 Perf在使用时的工作方式也是两大类，计数和采样。先看一下计数，它执行的命令是`perf stat`，用来查看每种 event发生的次数；采样执行的命令是`perf record`，它可以使用 period 方式，就是每 N 个 event发生后记录一次 event 发生时的 IP/ 进程信息，或者用 frequency方式，每秒钟以固定次数来记录信息。记录的信息会存在当前目录的 perf.data文件中。 如果我们要在容器中使用perf，要注意这两点：1. 容器中的 perf版本要和宿主机内核版本匹配，可以直接从源代码编译出静态链接的perf。 2. 我们需要解决两个权限的问题，一个是 seccomp对系统调用的限制，还有一个是内核对容器中没有 SYC_ADMIN capability的限制。 **在我们日常分析系统性能异常的时候，使用 perf最常用的方式是**`perf record`**获取采样数据，然后用 FlameGraph工具来生成火焰图。**思考题你可以在自己的一台 Linux 机器上运行一些带负载的程序，然后使用 perf并且生成火焰图，看看开销最大的函数是哪一个。欢迎在留言区分享你的疑惑和见解。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。
# 加餐03 \| 理解ftrace（1）：怎么应用ftrace查看长延时内核函数？你好，我是程远。上一讲里，我们一起学习了 perf 这个工具。在我们的案例里，使用 perf找到了热点函数之后，我们又使用了 ftrace 这个工具，最终锁定了长延时的函数estimation_timer()。那么这一讲，我们就来学习一下 ftrace这个工具，主要分为两个部分来学习。第一部分讲解 ftrace的最基本的使用方法，里面也会提到在我们的案例中是如何使用的。第二部分我们一起看看Linux ftrace 是如何实现的，这样可以帮助你更好地理解 Linux 的 ftrace工具。 ftrace 的基本使用方法ftrace 这个工具在 2008 年的时候就被合入了 Linux 内核，当时的版本还是Linux2.6.x。从 ftrace 的名字 functiontracer，其实我们就可以看出，它最初就是用来 trace内核中的函数的。当然了，现在 ftrace 的功能要更加丰富了。不过，function tracer 作为ftrace 最基本的功能，也是我们平常调试 Linux内核问题时最常用到的功能。那我们就先来看看这个最基本，同时也是最重要的function tracer 的功能。ftrace 的操作都可以在 tracefs 这个虚拟文件系统中完成，对于CentOS，这个 tracefs 的挂载点在 /sys/kernel/debug/tracing下：     
# cat /proc/mounts | grep tracefs    tracefs /sys/kernel/debug/tracing tracefs rw,relatime 0 0你可以进入到 /sys/kernel/debug/tracing目录下，看一下这个目录下的文件：    
# cd /sys/kernel/debug/tracing    
# ls    available_events            dyn_ftrace_total_info     kprobe_events    saved_cmdlines_size  set_graph_notrace   trace_clock          tracing_on    available_filter_functions  enabled_functions         kprobe_profile   saved_tgids          snapshot            trace_marker         tracing_thresh    available_tracers           error_log                 max_graph_depth  set_event            stack_max_size      trace_marker_raw     uprobe_events    buffer_percent              events                    options          set_event_pid        stack_trace         trace_options        uprobe_profile    buffer_size_kb              free_buffer               per_cpu          set_ftrace_filter    stack_trace_filter  trace_pipe    buffer_total_size_kb        function_profile_enabled  printk_formats   set_ftrace_notrace   synthetic_events    trace_stat    current_tracer              hwlat_detector            README           set_ftrace_pid       timestamp_mode      tracing_cpumask    dynamic_events              instances                 saved_cmdlines   set_graph_function   trace               tracing_max_latencytracefs 虚拟文件系统下的文件操作，其实和我们常用的 Linux proc 和 sys虚拟文件系统的操作是差不多的。通过对某个文件的 echo操作，我们可以向内核的 ftrace 系统发送命令，然后 cat 某个文件得到 ftrace的返回结果。对于 ftrace，它的输出结果都可以通过 `cat trace`这个命令得到。在缺省的状态下 ftrace 的 tracer 是 nop，也就是 ftrace什么都不做。因此，我们从`cat trace`中也看不到别的，只是显示了 trace输出格式。     
# pwd    /sys/kernel/debug/tracing    
# cat trace         
# tracer: nop    
#    
# entries-in-buffer/entries-written: 0/0   #P:12    
#    
#                              _-----=> irqs-off    