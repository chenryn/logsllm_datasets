**作者:[evilpan](https://evilpan.com)  
原文链接: **
**本文为作者投稿，Seebug Paper 期待你的分享，凡经采用即有礼品相送！**  
**投稿邮箱：PI:EMAIL**
# 前言
之前写过一篇[对称加密与攻击案例分析](https://evilpan.com/2019/06/02/crypto-attacks/
"对称加密与攻击案例分析")，而对于非对称加密，虽然接触的时间不短了，但一直没有很系统的记录过。因此趁着国庆家里蹲的五天长假，就来好好回顾总结一下。
其实从加密的定语就能看出，对称加密表示通信双方是拥有同样信息的(即信息对称)。信息可以是预共享的秘钥(PSK)，也可以是事先约定的编解码方法(如凯撒密码)。非对称加密则将信息分为两部分，例如秘钥A和秘钥B，通过秘钥A加密的信息可以用秘钥B进行解密，反之通过秘钥B加密的信息也可以通过秘钥A进行解密。通常这对秘钥可以叫做公钥和私钥，公钥对外发布，私钥自己保留，从而在信息不对称的情况下实现加密和认证。
非对称加密的实现方法有很多，大都依赖于难题假设(hardness
assumptions)。基于一个常量时间内被公认不可解的难题，将该问题的答案分为不同因子，组成对应非对称密码学算法的公钥和私钥。例如RSA基于大素数分解问题，(EC)DSA基于离散对数问题等。本文重点关注RSA非对称加密。
# RSA原理
[RSA](https://en.wikipedia.org/wiki/RSA_\(cryptosystem\)
"RSA")应该是最早的公钥加密系统之一了，其名称是三个发明者的名字首字母缩写(Rivest–Shamir–Adleman)。其算法所基于的难题假设是质数分解问题，在此之前先简单介绍一下涉及到的数学基础。
  1. 欧拉函数： _φ(n)_ ，表示小于n的正整数中与n互质的数的数目。如果n能写做两个不同质数 _p_ 和 _q_ 的乘积，那么则有 _φ(n) = (p - 1)(q - 1)_ 。证明：略。
  2. 同余：给定一个正整m，如果两个整数 _a_ 和 _b_ 满足 _(a-b)_ 被 _m_ 整除，那么就称为`a和b对模m同余`，记作 _a≡b(mod m)_ ，其中`≡`是同余符号。同余的两个数有一些有趣的特性，比如反身性、对称性、传递性等等，详见《数论》。
  3. 模逆元：也叫模倒数(modular multiplicative inverse)。整数 _a_ 的模逆元为整数 _x_ ，则满足 _ax≡1(mod m)_ ，其中 _m_ 为模(modulus)。
  4. 欧拉公式：若 _a_ 与 _n_ 互为质数，则满足 **a^φ(n)≡1(mod n)** ，证明：参考拉格朗日定理。
  5. lcm：least common multiple，最小公倍数。
  6. gcd：greatest common devisor，最大公约数。
  7. 互质：co-prime，两个正整数 _a_ 、 _b_ 互质意味着能同时被它们整除的数只有1，即 _gcd(a, b) = 1_
## 秘钥构成
有了上面的数学基础，再来看RSA公私钥的组成和生成过程。秘钥生成主要有以下几步，其实每一步在实践上都有注意事项，这个后面单独说。
  1. 找到两个不同的质数 _p_ 和 _q_
  2. 计算其乘积 _n=pq_
  3. 计算 _φ(n)_ ，由于 _p_ 和 _q_ 是质数，根据欧拉定理得 _φ(n) = lcm(p-1, q-1)_
  4. 选择一个整数 _e_ ，满足 _1  详细的证明过程见: M. Wiener. Cryptanalysis of short RSA secret exponents. IEEE
> Transactions on Information Theory, 36:553-558, 1990。
## 公钥指数
前面秘钥生成的过程中第四步我们说需要选择一个整数 _e_ ，满足 _1 < e < φ(n)_且 _gcd(e, φ(n)) = 1_ ，即 _e_ 和
_φ(n)_ 互质。这个 _e_ 是公钥的重要组成，因此称为公钥指数。
作为一个选择困难症患者，依旧是看到 **选择** 两个字就犯难。既然要求e和φ(n)互质即可，那么我随便选个满足要求的质数不就行了吗，比如 _e=3_
。估计抱有和我同样想法的人不在少数，但这样其实是有问题的，从结论上看会导致攻击者可以在特定情况下较为高效地还原私钥 _d_
，据不完全统计，涉及到的攻击场景有下面这些：
  * Hastad's Broadcast Attack
  * Franklin-Reiter Related Message Attack
  * Coppersmith's Short Pad Attack
  * Partial Key Exposure Attack
  * ...
感兴趣的朋友可以查看文末的参考资料，这里就不展开了。值得一提的是这种情况的危害相对于前面选择过小的私钥指数情形而言相对较轻一些，即便选取了较小的公钥指数，距离成功的攻击也有不少的计算量。现实中私钥指数一般选择`e
= 2^16 + 1 = 65537`就可以很好地防御攻击了，后面在拆解一些现实中的秘钥时也会看到。
## Padding
我们前面所指的加密、解密和签名运算，明文和密文标的都是一个 **整数** ，该整数小于 _n_ 。这种方式叫做plain RSA(Textbook
RSA或裸加密)，在现实中很少直接使用。plain RSA实际上存在许多安全隐患，列举一些如下：