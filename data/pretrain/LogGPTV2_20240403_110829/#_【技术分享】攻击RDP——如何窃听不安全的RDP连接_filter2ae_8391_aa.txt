# 【技术分享】攻击RDP——如何窃听不安全的RDP连接
|
##### 译文声明
本文是翻译文章，文章来源：exploit-db.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
****
翻译：[shan66](http://bobao.360.cn/member/contribute?uid=2522399780)
稿费：300RMB（不服你也来投稿啊！）
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**简介**
系统管理员每天都会使用远程桌面协议（RDP）登录到远程Windows计算机。最常见的情形是，人们使用它在关键服务器上执行某些管理任务，这些服务器包括具有高度特权帐户的域控制器等，它们的登陆凭据都是通过RDP传输的。因此，确保RDP配置的安全性是至关重要的。
但是根据我们的观察，由于配置错误，Active Directory环境中的系统管理员会定期显示（并忽略）证书警告，如下所示：
图1：SSL证书警告
如果您的环境中经常遇到这样的警告的话，您将无法识别真正的中间人（MitM）攻击。
本文旨在帮您认识到认真对待证书警告以及如何安全地配置Windows环境有多么的重要。目标受众是系统管理员、渗透测试人员和安全爱好者。虽然对下列主题的了解没有硬性要求，但我仍然鼓励您进一步深入学习一下：
公钥密码术以及对称密码术（RSA和RC4）
SSL
x509证书
TCP
Python
十六进制数和二进制代码
我们将演示MitM是如何嗅探您的凭据的，如果您不小心的话是很容易中招的。这些都不是特别新的技术，例如Cain
[2]就是用来干这个的。然而，Cain不仅“年代久远”，代码封闭，而且还只适用于Windows系统。我们想要分析RDP的所有细节和内部工作机制，并尽可能地模拟真实的攻击情形。
不用说，本文介绍的技术不得用于在未经授权的情况下访问不属于您的任何系统。它们只能在系统所有者完全同意的情况下用于教育目的。否则，你很可能违反法律，当然，具体还取决于你的管辖权。
对于心急的读者，可以通过参考资料[1]中的链接下载相应的源代码。
**协议分析**
让我们启动Wireshark，看看当我们通过RDP连接到服务器时会发生什么：
图2：Wireshark中的RDP会话的开头部分内容
正如我们所看到的，客户端首先提出了用于RDP会话的安全协议。这里有三个协议：
标准RDP安全性协议
增强型RDP安全或TLS安全性协议
CredSSP协议
在本例中，客户端能够使用前两个协议。注意，标准的RDP安全性协议总是可用的，不需要由客户端指出。TLS或增强的RDP安全性协议，只是将标准RDP安全性协议封装到加密的TLS隧道内而已。顺便说一下，在本文中术语SSL和TLS可是可以互换的。
CredSSP协议虽然也使用TLS隧道，但它不是在受保护的隧道中传输密码，而是使用NTLM或Kerberos进行身份验证。该协议也称为网络级认证（NLA）。
早期的用户身份验证有一个特点，那就是允许服务器可以在用户提交任何凭据（用户名除外）之前拒绝访问，例如，如果用户没有必要的远程访问权限。
在上面的Wireshark会话中，我们可以看到，SSL握手是在客户端和服务器已同意使用增强的RDP安全性协议之后执行的。为此，我们右键单击磋商数据包后的第一个数据包，并将TCP数据流作为SSL解码：
图3：SSL握手的开头部分内容
因此，如果我们想要对一个RDP连接进行中间人攻击的话，不能直接使用SSL代理，因为代理还需要知道RDP。它需要知道何时启动SSL握手，这类似于SMTP或FTP中的StartTLS。我们选择Python来实现这样的代理。为此，我们只需创建受害者客户端连接到的服务器套接字，以及连接到实际服务器的客户端套接字。我们在这些套接字之间转发数据，并在必要时将它们封装到SSL套接字中。当然，我们将密切关注相关数据并根据需要进行修改。
当然，首先要修改的就是客户端提出的协议。客户端可能想告诉服务器它可以执行CredSSP协议，但我们将在相应数据到达服务器的半路上将协议更改为标准RDP安全性协议。在默认配置中，服务器会很乐意使用这个协议的。
**利用Python打造用于RDP的MitM代理**
我们的Python脚本的主循环大致如下所示：
函数run()打开套接字，处理协议的协商并启用SSL（如有必要）。
之后，数据就可以在两个套接字之间转发了。如果设置了调试标志，dump_data()函数会将数据作为hexdump打印到屏幕。而parse_rdp()会从数据中提取相应的信息，tamper_data()函数可用于对其进行修改。
**密码学基础知识**
因为我们需要借助RSA来搞定标准RDP安全协议，所以我们先来了解一下RSA的基础知识。如果您熟悉这方面的知识的话，可以跳过此部分。
在RSA中，加密、解密和签名纯粹就是数学运算，并且都是针对整数的运算。
请记住，所有这些操作都是在有限群上完成的[3]。
当生成RSA密钥对时，您需要找到两个大质数p和q。你得到他们的乘积，n = pq（这称为模数），计算φ（n）=（p – 1）（q –
1）（欧拉常数函数），并选择一个与φ(n) 互质的整数e。然后，您需要找到满足
    e•d≡1  modφ（n）
的数字d。
数字d就是私钥，而e和n则组成公钥。当然，理论上d可以利用n和e求出，但φ（n）却很难计算，除非你知道p和q。这就是为什么RSA的安全性在很大程度上取决于大数分解的难度。到目前为止，没有人知道如何有效地进行大数分解——除非你有一台可以工作的量子计算机[4,5]。
为了加密消息m，我们只需求其e次幂，然后模n：
    c≡me mod n
为了对密文c进行解密，我们可以使用私钥指数d进行下列运算：
    m≡cd mod n
实际上，这是加密运算的逆运算。当然，这里涉及许多数学知识，过于深入的内容我就不介绍了。
签名与解密相同。你只需在消息的哈希值上执行相同的运算即可。
如果m或c大于256位的话，这些运算的开销将非常大，所以通常只使用RSA来加密对称密钥。然后，通过使用刚生成的密钥通过对称密码（通常为AES）算法来加密实际的消息。
**攻陷标准RDP安全协议**
其实，攻破这个协议难度并不太大，因为它的设计本身就存在很大隐患，下面我会具体加以讲解。
标准RDP安全协议的运行机制是：
客户声明打算使用标准RDP安全协议。
服务器同意并将自己的RSA公钥与“Server Random”一起发送到客户端。公钥以及其他信息（例如主机名等）的集合称为“证书”。
使用终端服务私钥对证书进行签名，以确保真实性。
客户端通过使用终端服务公钥验证证书。如果验证成功，它就使用服务器的公钥来加密“Client Random”，并将其发送给服务器。
服务器使用自己的私钥解密Client Random。
服务器和客户端从Server Random和Client Random中求出会话密钥[6]。这些密钥用于对会话的其余部分进行对称加密。
请注意，所有这些都是以纯文本形式发送的，而不是在SSL隧道内发送的。原则上讲这没有什么问题，微软只是试图实现自己的SSL加密技术。然而，加密技术是可没想象的那么容易[7]，按一般规律，你始终应该依靠已建立的解决方案，因为它们都是经过时间考验过得，而不是实现自己的解决方案。因此，微软在这里犯了一个根本性的错误——我实在想不通他们为什么要这样做。
你能发现这里的错误吗？客户端是如何获取终端服务公钥的？答案是：它是预装的。这意味着它在所有系统上使用相同的密钥。这意味着私钥也都是一样的！所以，它可以从任何Windows安装上面提取到。事实上，我们甚至不需要这样做，因为现在微软已经决定正式发布它，这样一来，我们可以直接从microsoft.com网站上找到它们[8]。
在导出会话密钥后，可以使用多个安全级别[9]进行对称加密：无、40位RC4、56位RC4、128位RC4或3DES（称为FIPS）。默认值为128位RC4（“High”）。但是如果我们能够窃听密钥的话，那么加密的强度就无所谓了。
所以我们的计划是很明显的：当发现服务器的公钥时，我们快速生成相同大小的自己的RSA密钥对，并用它覆盖原始密钥。当然，我们需要使用终端服务私钥生成我们的公钥的签名，并用它替换原始签名。然后，在客户端成功验证我们的假公钥之后，我们接收其Client
Random。我们使用我们的私钥对它进行解密，将其写下来以便使用服务器的公钥重新加密它。仅此而已！这样一来，我们就可以被动地读取客户端和服务器之间的加密流量了。
唯一的挑战是正确解析RDP数据包。这才是我们感兴趣的：
    From server:
    00000000: 03 00 02 15 02 F0 80 7F 66 82 02 09 0A 01 00 02 ........f.......
    00000010: 01 00 30 1A 02 01 22 02 01 03 02 01 00 02 01 01 ..0...".........