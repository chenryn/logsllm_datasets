# 【技术分享】攻击RDP——如何窃听不安全的RDP连接

#### 译文声明
本文为翻译文章，原文来源：exploit-db.com。具体表达及含义以原文为准。

#### 翻译信息
- **翻译者**：shan66
- **稿费**：300 RMB
- **投稿方式**：发送邮件至 linwei#360.cn 或登录网页版在线投稿

## 简介
系统管理员每天都会使用远程桌面协议（RDP）来访问远程Windows计算机，尤其是在执行关键服务器上的管理任务时，例如在域控制器上操作，这些通常涉及高权限账户。因此，确保RDP配置的安全性至关重要。然而，我们观察到，在Active Directory环境中，系统管理员常常会忽略SSL证书警告，这使得他们难以识别真正的中间人（MitM）攻击。

本文旨在帮助读者理解重视证书警告的重要性以及如何正确配置Windows环境中的RDP安全性。目标受众包括系统管理员、渗透测试人员和安全爱好者。尽管对以下主题的理解并非强制要求，但建议您深入学习：
- 公钥密码学与对称密码学（如RSA和RC4）
- SSL
- x509证书
- TCP
- Python
- 十六进制数和二进制代码

我们将展示如何通过MitM攻击嗅探凭据，并强调即使不是特别新的技术，也需要谨慎对待。例如，Cain [2] 就是用于此类攻击的工具之一。然而，Cain不仅“年代久远”且代码封闭，还仅适用于Windows系统。我们的目的是详细分析RDP的工作机制，并尽可能模拟真实的攻击情景。

请注意，本文介绍的技术不得用于未经授权访问任何不属于您的系统。它们只能在系统所有者的完全同意下用于教育目的。否则，你可能会违反法律，具体情况取决于你的管辖权。

对于心急的读者，可以通过参考资料[1]中的链接下载相应的源代码。

## 协议分析
让我们启动Wireshark，看看当我们通过RDP连接到服务器时会发生什么：

### Wireshark中的RDP会话
![图2](图2：Wireshark中的RDP会话的开头部分内容)

从上图中可以看出，客户端首先提出用于RDP会话的安全协议。这里有三种协议：
1. 标准RDP安全性协议
2. 增强型RDP安全或TLS安全性协议
3. CredSSP协议

在本例中，客户端能够使用前两个协议。注意，标准RDP安全性协议总是可用的，不需要由客户端指出。TLS或增强的RDP安全性协议，只是将标准RDP安全性协议封装到加密的TLS隧道内而已。术语SSL和TLS在本文中可以互换使用。

CredSSP协议虽然也使用TLS隧道，但它不是在受保护的隧道中传输密码，而是使用NTLM或Kerberos进行身份验证。该协议也称为网络级认证（NLA）。早期的用户身份验证允许服务器在用户提交任何凭据（用户名除外）之前拒绝访问，例如，如果用户没有必要的远程访问权限。

在上面的Wireshark会话中，我们可以看到，SSL握手是在客户端和服务器已同意使用增强的RDP安全性协议之后执行的。为此，我们右键单击协商数据包后的第一个数据包，并将TCP数据流作为SSL解码：

### SSL握手
![图3](图3：SSL握手的开头部分内容)

如果我们想要对一个RDP连接进行中间人攻击的话，不能直接使用SSL代理，因为代理还需要知道何时启动SSL握手，类似于SMTP或FTP中的StartTLS。我们选择Python来实现这样的代理。为此，我们只需创建受害者客户端连接到的服务器套接字，以及连接到实际服务器的客户端套接字。我们在这些套接字之间转发数据，并在必要时将它们封装到SSL套接字中。当然，我们将密切关注相关数据并根据需要进行修改。

### 修改客户端提出的协议
客户端可能想告诉服务器它可以执行CredSSP协议，但我们将在相应数据到达服务器的半路上将协议更改为标准RDP安全性协议。在默认配置中，服务器会很乐意使用这个协议的。

## 利用Python打造用于RDP的MitM代理
我们的Python脚本的主循环大致如下所示：

```python
def run():
    # 打开套接字，处理协议的协商并启用SSL（如有必要）
    while True:
        data = client_socket.recv(BUFFER_SIZE)
        if debug_flag:
            dump_data(data)
        parse_rdp(data)
        tamper_data(data)
        server_socket.send(data)
```

函数`run()`打开套接字，处理协议的协商并启用SSL（如有必要）。之后，数据就可以在两个套接字之间转发了。如果设置了调试标志，`dump_data()`函数会将数据作为hexdump打印到屏幕。而`parse_rdp()`会从数据中提取相应的信息，`tamper_data()`函数可用于对其进行修改。

## 密码学基础知识
因为我们需要借助RSA来搞定标准RDP安全协议，所以我们先来了解一下RSA的基础知识。如果您熟悉这方面的知识的话，可以跳过此部分。

在RSA中，加密、解密和签名纯粹就是数学运算，并且都是针对整数的运算。请记住，所有这些操作都是在有限群上完成的[3]。

当生成RSA密钥对时，您需要找到两个大质数p和q。得到他们的乘积n = pq（这称为模数），计算φ（n）=（p – 1）（q – 1）（欧拉常数函数），并选择一个与φ(n) 互质的整数e。然后，您需要找到满足
\[ e \cdot d \equiv 1 \mod \varphi(n) \]
的数字d。

数字d就是私钥，而e和n则组成公钥。理论上d可以利用n和e求出，但φ（n）却很难计算，除非你知道p和q。这就是为什么RSA的安全性在很大程度上取决于大数分解的难度。到目前为止，没有人知道如何有效地进行大数分解——除非你有一台可以工作的量子计算机[4,5]。

为了加密消息m，我们只需求其e次幂，然后模n：
\[ c \equiv m^e \mod n \]

为了对密文c进行解密，我们可以使用私钥指数d进行下列运算：
\[ m \equiv c^d \mod n \]

实际上，这是加密运算的逆运算。当然，这里涉及许多数学知识，过于深入的内容我就不介绍了。

签名与解密相同。你只需在消息的哈希值上执行相同的运算即可。

如果m或c大于256位的话，这些运算的开销将非常大，所以通常只使用RSA来加密对称密钥。然后，通过使用刚生成的密钥通过对称密码（通常为AES）算法来加密实际的消息。

## 攻陷标准RDP安全协议
攻破这个协议并不难，因为它的设计本身就存在很大隐患。标准RDP安全协议的运行机制是：

1. 客户端声明打算使用标准RDP安全协议。
2. 服务器同意并将自己的RSA公钥与“Server Random”一起发送到客户端。公钥以及其他信息（例如主机名等）的集合称为“证书”。
3. 使用终端服务私钥对证书进行签名，以确保真实性。
4. 客户端通过使用终端服务公钥验证证书。如果验证成功，它就使用服务器的公钥来加密“Client Random”，并将其发送给服务器。
5. 服务器使用自己的私钥解密Client Random。
6. 服务器和客户端从Server Random和Client Random中求出会话密钥[6]。这些密钥用于对会话的其余部分进行对称加密。

请注意，所有这些都是以纯文本形式发送的，而不是在SSL隧道内发送的。原则上讲这没有什么问题，微软只是试图实现自己的SSL加密技术。然而，加密技术并不是那么容易实现的[7]，按一般规律，你始终应该依靠已建立的解决方案，因为它们都是经过时间考验的，而不是实现自己的解决方案。因此，微软在这里犯了一个根本性的错误——我实在想不通他们为什么要这样做。

你能发现这里的错误吗？客户端是如何获取终端服务公钥的？答案是：它是预装的。这意味着它在所有系统上使用相同的密钥。这意味着私钥也都是一样的！所以，它可以从任何Windows安装上面提取到。事实上，我们甚至不需要这样做，因为现在微软已经决定正式发布它，这样一来，我们可以直接从microsoft.com网站上找到它们[8]。

在导出会话密钥后，可以使用多个安全级别[9]进行对称加密：无、40位RC4、56位RC4、128位RC4或3DES（称为FIPS）。默认值为128位RC4（“High”）。但是如果我们能够窃听密钥的话，那么加密的强度就无所谓了。

所以我们的计划是很明显的：当发现服务器的公钥时，我们快速生成相同大小的自己的RSA密钥对，并用它覆盖原始密钥。当然，我们需要使用终端服务私钥生成我们的公钥的签名，并用它替换原始签名。然后，在客户端成功验证我们的假公钥之后，我们接收其Client Random。我们使用我们的私钥对它进行解密，将其写下来以便使用服务器的公钥重新加密它。仅此而已！这样一来，我们就可以被动地读取客户端和服务器之间的加密流量了。

唯一的挑战是正确解析RDP数据包。这才是我们感兴趣的：
```
From server:
00000000: 03 00 02 15 02 F0 80 7F 66 82 02 09 0A 01 00 02 ........f.......
00000010: 01 00 30 1A 02 01 22 02 01 03 02 01 00 02 01 01 ..0...".........
```