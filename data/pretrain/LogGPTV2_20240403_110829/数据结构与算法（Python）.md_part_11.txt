们对这四种操作运行时间的比较是有意义的。它不能准确的说串联操作耗时6.54毫秒，应该说串联
操作测试函数耗时6.54毫秒。作为练习，你可以测试调用一个空函数所耗费的时间，并把这个时间
从上面测试得出的结果中减去。
既然我们已经了解了如何对操作进行具体的测量，那么你可以看图表2.2，了解所有列表基本操
作的大O效率。在你对图表2.2进行仔细思考后，可能会对pop操作的两个不同的时间感到疑惑。
当pop操作每次从列表的最后一位删除元素时复杂度为O（1），而将列表的第一个元素或中间任意
一个位置的元素删除时，复杂度则为O（n）。这样迥然不同的结果是由Python对列表的执行方式造
成的。在Python的执行过程中，当从列表的第一位删除一个元素，其后的每一位元素都将向前挪动
一位。你可能觉得这种操作很愚蠢，但当你仔细看完图表2.2后会发现这种执行方式会让index索引
操作的复杂度降为O（1）。这种运行时间的权衡是Python执行者认为正确高效的。
为进一步论证这些操作表现的差异性，让我们用timeit模块进行另一个实验。我们的目标是能
够核实以下两种pop操作的表现，第一种是在一个已知长度的列表中从列表的末端删除元素，而第
二种则是从这个列表的开头删除元素。我们还想测量出对不同长度的列表进行pop操作的时间。我
们想要看到的是，随着列表长度的增加，从列表末端删除元素的pop操作时间保持稳定，而从列表
开头删除元素的pop操作则随着长度的增加而增加。
下面的代码展示了对这两种pop操作的区别进行测量的一个尝试。正如你从第一个例子中看见
的那样，从列表末尾删除的pop操作耗时0.0003毫秒，然而从列表开头删除则耗时4.82毫秒。对于
一个有2百万个元素的列表，两种操作耗费的时间相差16000倍。
对于这个代码，我们有很多地方值得去注意。第一点就是 from __main__ import x语句。尽管我
么并没有定义一个函数，但我们仍然想在测试中可以使用列表对象x。这种方式使我们可以对单个
pop操作进行计时，并且使我们得到对单个操作最准确的测量时间。因为计时操作执行1000次，所
以必须指出的是在循环过程中每进行一次操作，列表都将缩短一位。但是由于起始列表有两百万个
元素，进行1000次操作仅减少了0.05%，这种改变是很微小的，几乎无影响。
尽管第一个测试证明了pop（0）操作确实比pop（）操作要慢，但并不能确切的说明pop（0）
复杂度为O（n）而pop（）的复杂度为O（1）。为了证实这个结果，我们需要综合不同列表长度的
测试结果。
图2.3 pop 与 pop(0) 操作性能的比较
图 2.3展示了我们实验的结果。 可以看到，随着列表的逐渐变长，pop(0)所需要的时间也同样
增加。但是pop() 的时间却始终保持基本不变。不出所料，这正是 O(n)与 O(1) 算法的行为。
我们小实验的误差可能来源于我们计算机上同时运行的其他进程。当我们测量时间时，这些进
程可能使我们的代码运行变慢。即使我们试图最小化计算机上其他事情的影响，用时上也总是存在
着一定的不确定度。这就是为什么我们要将测试循环上千次——为了获得足够的信息以使结果具有
足够的可信度。
2.3.2 字典
Python中第二个主要的数据结构是字典。回想一下，字典与列表的不同之处在于你需要通过一
个键（key）来访问条目，而不是通过一个坐标。在本书的后面我们会介绍多种字典的实现方式，不
过现在我们要说的重点是，字典条目的访问和赋值都是 O(1)的时间复杂度。字典的另一个重要的操
作是所谓的“包含”。检查一个键是否存在于字典中也只需 O(1)的时间。其他字典操作的时间效率
都已经在 表2.3中列出。需要注意的是，这里所列出的都是平均时间复杂度。在一些罕见的情况
下，包含、访问和赋值都可能退化为O(n)，不过这将是我们之后研究字典的实现时才会讨论的内
容。
操作 时间效率（大O表示法）
复制 O(n)
访问 O(1)
赋值 O(1)
删除 O(1)
包含（in） O(1)
迭代 O(n)
表格2.2字典操作效率表（大O表示法）
我们的最后一个性能实验将会对比列表和字典的包含操作的效率。在这一过程中我们将会验证
列表的包含操作是O(n)，为字典的是O(1)。这个实验很简单，我们将生成一个自然数（range）的列
表，然后随机地选取一个数字，检查其是否在列表中。如果我们之前的效率表是正确的话，列表越
大，所用的时间也就越长。
然后我们将在一个以数字为键的字典上重复这个实验。这次我们会发现检查一个数字是否在字
典中要快得多，而且即使字典变大，检查所用的时间也保持不变。
下面的代码实现了这个比较。请注意我们实际上是在做完全相同的操作。区别仅仅在于在第7
行，x是一个列表，而在第9行的x是一个字典。
1 import timeit
2 import random
3
4 for i in range(10000,1000001,20000):
5 t = timeit.Timer("random.randrange(%d) in x"%i,
6 "from __main__ import random,x")
7 x = list(range(i))
8 lst_time = t.timeit(number=1000)
9 x = {j:None for j in range(i)}
10 d_time = t.timeit(number=1000)
11 print("%d,%10.3f,%10.3f" % (i, lst_time, d_time))
代码 xxx对比列表和字典的包含操作的效率
图2.4总结了我们的结果。可以看到，字典始终比列表快，对于最小的只包含10, 000个元素的
情况，字典比列表快89.4倍，而在最大的990, 000个元素时，字典要快11603倍！另外可以注意
到，随着列表的增大，其包含操作所需要的时间是线性增长的，这证实了我们之前关于其时间复杂
度是O(n)的论断。与此同时，字典的包含操作用时保持不变，即使字典的大小不断变大也是如此。
实际上，10,000个元素的字典的包含操作用了0.004毫秒，而990,000个元素的字典同样也用了
0.004毫秒。
图2.4对比列表和字典的包含操作的效率
因为 Python是一门仍在发展中的语言，其幕后总在进行着各种改进。关于Python的数据结构
性能的最新信息可以在Python网站上找到。对于这部分，Pythonwiki上有一页关于时间复杂度的很
好的介绍，可以在Time Complexity Wiki上找到。
牛刀小试
1. 下面的列表操作中哪一个是O(1)的？
A. list.pop(0)
B. list.pop()
C. list.append()
D. list[10]
E.以上全是
2．下面的字典操作中哪一个是O(1)的？
A. ‘𝑥’ in my_dict
B. del my_dict[‘𝑥’]
C. my_dict[‘𝑥’] == 10
D. my_dict[‘𝑥’] = my_dict[‘𝑥’] + 1
E.以上全是
2.4 小结
● 算法分析是一种与具体实现无关的衡量算法（好坏）的方法。
● 大O表示法可以按照随着问题规模的变化时算法的主要变化行为把算法分类。
2.5 关键字
平均情况 大“O”表示法 暴力匹配算法
检查标记 指数（的） 线性（的）
对数线性（的） 对数（的） 数量级
二次（的） 时间复杂度 最坏的情况
2.6 问题讨论
1. 给出下面代码段的时间复杂度（大O表示法）：
for i in range(n):
k = 2 + 2
2. 给出下面代码段的时间复杂度（大O表示法）：
i = n
while i > 0:
k = 2 + 2
i = i // 2
3. 给出下面代码段的时间复杂度（大O表示法）：
for i in range(n):
for j in range(n):
k = 2 + 2
4. 给出下面代码段的时间复杂度（大O表示法）：
for i in range(n):
for j in range(n):
for k in range(n):
k = 2 + 2
5. 给出下面代码段的时间复杂度（大O表示法）：
for i in range(n):
k = 2 + 2
for j in range(n):
k = 2 + 2
for k in range(n):
k = 2 + 2
2.7 编程练习
1. 设计一个实验来验证列表索引操作是O(1)的
2. 设计一个实验来验证字典的读取和赋值操作都是O(1)的
3. 设计一个实验来比较列表列表和字典的删除（del）运算符的性能
4. 给出一个寻找一个随机数列中第k小的数的O（nlog(n)）的算法
5. 你能把前面一题中的算法改进为O（n）吗？解释原因
三．基本数据结构类型
3.1 学习目标
● 了解抽象数据类型：栈stack、队列queue、双端队列deque 和列表list；
●用Python 列表数据结构，来实现stack/queue/deque 抽象数据类型的构建；
● 了解各种基本线性数据结构的性能和使用方法；
● 了解前缀、中缀和后缀表达式；
● 采用栈stack 对后缀表达式进行求值；
● 采用栈stack 将中缀表达式转换为后缀表达式；
● 采用队列queue 进行基本的时间模拟；
● 能够明确问题类型，选用stack、queue 或者deque 中合适的数据结构；
● 能够采用节点和引用模式来将抽象数据类型list实现为链表；，
● 能够比较链表和列表的算法性能。
3.2 什么是线性结构？
在我们开始数据结构的学习之前，先来看看四个简单但非常强大的概念: 栈，队列，双端队
列，和列表。这四种数据集合的项的由添加或删除的方式整合在一起。当添加一个项目时，它就被
放在这样一个位置：在之前存在的项与后来要加入的项之间。像这样的数据集合常被称为线性数据
结构。
你可以想象线性结构有两个端，有时候，我们称这两端为“左”和“右”，或者“前”和
“后”，或者“顶”和“底”。其实名字不重要，区别线性结构和其他结构的依据是项进行添加和
删除的方式，尤其是添加和删除发生的位置。例如，有的结构可能仅允许仅在一端加项；有的结构
可能会允许从两端移除项。
这些变化引起了计算机科学中的一些最有用的数据结构的出现。他们出现在许多算法中被用
用来解决各种重要问题。
3.3 栈
3.3.1 什么是栈？
一个栈（有时称“叠加栈”）是一个项的有序集合。添加项和移除项都发生在同一“端”。
这一端通常被称为“顶”。另一端的顶部被称为“底”。
栈的“底”是有标志性的，因为存储在栈中更靠近“底”的项就是栈中储存时间最长的项。
最新添加的项在移除项时也会第一个被移除。这种排序原则有时也称为LIFO 法，也就是“后进先
出”。项的排序基于它在集合中存在的时间长度。越新的项越靠近“顶”，越老的项越靠近
“底”。
在日常生活中有许多栈的实例。几乎所有的餐厅有一堆餐盘，你可以拿走最顶上的一个，排
在你后面一个人将拿走原来你餐盘下的那个。又或者在桌上叠着一摞书（图3.1）。只有最上面的一
个本书的封面可以看见。如果要看到其他书，我们需要拿掉那些放在上面的书。图3.2是另一个栈结
构。这包含着一些原始的Python 数据对象。
图
3.1：书的栈图3.2： python原始对象的栈
栈的最有用的一个思路，来自对项添加、然后移除的简单观察。假设你的面前有一张干净的
桌面。现在把书一本一本地放在前一本顶上。这时你就在构建一个栈。当你移除书籍时，它们被拆
移除的顺序和它们被放置是的顺序完全相反。栈很重要，因为它们可以用于反转项的顺序。放入的
顺序和拿出顺序相反。图3.3 展示了Python 数据对象的栈被创造、然后移除项时的情况。注意对象
的顺序。
图3.3：栈的逆转属性
考虑到这种逆转性，你可以想一想你使用电脑时栈发生的例子。例如，每个浏览器都有后退按
钮。当你浏览网页时，那些网页就被放在栈中（实际上是将网址放在栈中）。你正在浏览的当前页
被放在“顶”，你打开的第一个网页被放在“底”。如果你点击后退按钮，你就会开始以相反的顺
序浏览网页。
栈操作 栈内容 返回值
s.is_empty() [] True
s.push(4) [4]
s.push(‘dog’) [4,’dog’]
s.peek() [4,’dog’] ‘dog’
s.push(True) [4,’dog’,True]
s.size() [4,’dog’,True] 3
s.is_empty() [4,’dog’,True] False