title:Understanding Linux Malware
author:Emanuele Cozzi and
Mariano Graziano and
Yanick Fratantonio and
Davide Balzarotti
2018 IEEE Symposium on Security and Privacy
Understanding Linux Malware
Emanuele Cozzi
Eurecom
Mariano Graziano
Cisco Systems, Inc.
Yanick Fratantonio
Davide Balzarotti
Eurecom
Eurecom
Abstract—For the past two decades, the security community
has been ﬁghting malicious programs for Windows-based operat-
ing systems. However, the recent surge in adoption of embedded
devices and the IoT revolution are rapidly changing the malware
landscape. Embedded devices are profoundly different than tradi-
tional personal computers. In fact, while personal computers run
predominantly on x86-ﬂavored architectures, embedded systems
rely on a variety of different architectures. In turn, this aspect
causes a large number of these systems to run some variants
of the Linux operating system, pushing malicious actors to give
birth to “Linux malware.”
To the best of our knowledge, there is currently no comprehen-
sive study attempting to characterize, analyze, and understand
Linux malware. The majority of resources on the topic are
available as sparse reports often published as blog posts, while
the few systematic studies focused on the analysis of speciﬁc
families of malware (e.g., the Mirai botnet) mainly by looking
at their network-level behavior, thus leaving the main challenges
of analyzing Linux malware unaddressed.
This work constitutes the ﬁrst step towards ﬁlling this gap.
After a systematic exploration of the challenges involved in
the process, we present the design and implementation details
of the ﬁrst malware analysis pipeline speciﬁcally tailored for
Linux malware. We then present the results of the ﬁrst large-
scale measurement study conducted on 10,548 malware samples
(collected over a time frame of one year) documenting detailed
statistics and insights that can help directing future work in the
area.
I. INTRODUCTION
The security community has been ﬁghting malware for
over two decades. However, despite the signiﬁcant effort
dedicated to this problem by both the academic and indus-
try communities,
the automated analysis and detection of
malicious software remains an open problem. Historically,
the vast majority of malware was designed to target almost
exclusively personal computers running Microsoft’s Windows
operating system, mainly because of its very large market
share (currently estimated at 83% [1] for desktop computers).
Therefore,
the security community has also been focusing
its effort on Windows-based malware—resulting in several
hundreds of papers and a vast knowledge base on how to
detect, analyze, and defend from different classes of malicious
programs.
However, the recent exponential growth in popularity of
embedded devices is causing the malware landscape to rapidly
change. Embedded devices have been in use in industrial
environments for many years, but it is only recently that they
started to permeate every aspect of our society, mainly (but
not only) driven by the so-called “Internet of Things” (IoT)
revolution. Companies producing these devices are in a con-
stant race to increase their market share, thus focusing mainly
© 2018, Emanuele Cozzi. Under license to IEEE.
DOI 10.1109/SP.2018.00054
161
on a short time-to-market combined with innovative features
to attract new users. Too often,
this results in postponing
(if not simply ignoring) any security and privacy concerns.
With these premises,
it does not come as a surprise that
the vast majority of these newly interconnected devices are
routinely found vulnerable to critical security issues, ranging
from Internet-facing insecure logins (e.g., easy-to-guess hard-
coded passwords, exposed telnet services, or accessible debug
interfaces),
to unsafe default conﬁgurations and unpatched
software containing well-known security vulnerabilities.
Embedded devices are profoundly different from traditional
personal computers. For example, while personal computers
run predominantly on x86 architectures, embedded devices are
built upon a variety of other CPU architectures—and often
on hardware with limited resources. To support these new
systems, developers often adopt Unix-like operating systems,
with different ﬂavors of Linux quickly gaining popularity in
this sector.
Not surprisingly, the astonishing number of poorly secured
devices that are now connected to the Internet has recently
attracted the attention of malware authors. However, with the
exception of few anecdotal proof-of-concept examples, the an-
tivirus industry had largely ignored malicious Linux programs,
and it is only by the end of 2014 that VirusTotal recognized
this as a growing concern for the security community [2].
Academia was even slower to react to this change, and to date
it has not given much attention to this emerging threat. In the
meantime, available resources are often limited to blog posts
(such as the excellent Malware Must Die [3]) that present the,
often manually performed, analysis of speciﬁc samples. One
of the few systematic works in this area is a recent study by
Antonakakis et al. [4] that focuses on the network behavior
of a speciﬁc malware family (the Mirai botnet). However,
no comprehensive study has been conducted to characterize,
analyze, and understand the characteristics of Linux-based
malware.
This work aims at ﬁlling this gap by presenting the ﬁrst
large-scale empirical study conducted to characterize and un-
derstand Linux-based malware (for both embedded devices
and traditional personal computers). We ﬁrst systematically
enumerate the challenges that arise when collecting and ana-
lyzing Linux samples. For example, we show how supporting
malware analysis for “common” architectures such as x86 and
ARM is often insufﬁcient, and we explore several challenges
including the analysis of statically linked binaries, the prepa-
ration of a suitable execution environment, and the differential
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:40 UTC from IEEE Xplore.  Restrictions apply. 
analysis of samples run with different privileges. We also detail
Linux-speciﬁc techniques that are used to implement different
aspects traditionally associated with malicious software, such
as anti-analysis tricks, packing and polymorphism, evasion,
and attempts to gain persistence on the infected machine. These
insights were uncovered thanks to an analysis pipeline we
speciﬁcally designed to analyze Linux-based malware and the
experiments we conducted with over 10K malicious samples.
Our results show that Linux malware is already a multi-faced
problem. While still not as complex as its Windows coun-
terpart, we were able to identify many interesting behaviors—
including the ability of certain samples to properly run in mul-
tiple operating systems, the use of privilege escalation exploits,
or the custom modiﬁcation of the UPX packer adopted to
protect their code. We also found that a considerable fraction of
Linux malware interacts with other shell utilities and, despite
the lack of available malware analysis sandboxes, that some
samples already implement a wide range of VM-detections
approaches. Finally, we also performed a differential analysis
to study how the malware behavior changes when the same
sample is executed with or without root privileges.
In summary, this paper brings the following contributions:
• We document the design and implementation of several
tools we designed to support the analysis of Linux mal-
ware and we discuss the challenges involved when dealing
with this particular type of malicious ﬁles.
• We present the ﬁrst large-scale empirical study conducted
on 10,548 Linux malware samples obtained over a period
of one year.
• We uncover and discuss a number of low-level Linux-
speciﬁc techniques employed by real-world malware and
we provide detailed statistics on the current usage.
We make the raw results of all our analyzed samples
available to the research community and we provide our entire
infrastructure as a free service to other researchers.
II. CHALLENGES
The analysis of generic (and potentially malicious) Linux
programs requires tackling a number of speciﬁc challenges.
This section presents a systematic exploration of the main
problems we encountered in our study.
A. Target Diversity
The ﬁrst problem relates to the broad diversity of the
possible target environments. The general belief is that the
main challenge is about supporting different architectures (e.g.,
ARM or MIPS), but
this is in fact only one aspect of a
much more complex problem. Malware analysis systems for
Windows, MacOS, or Android executables can rely on de-
tailed information about the underlying execution environment.
Linux-based malware can instead target a very diverse set of
targets, such as Internet routers, printers, surveillance cameras,
smart TVs, or medical devices. This greatly complicates their
analysis. In fact, without the proper information about the
target (unfortunately, program binaries do not specify where
162
they were supposed to run) it is very hard to properly conﬁgure
the right execution environment.
Computer Architectures. Linux is known to support tens
of different architectures. This requires analysts to prepare
different analysis sandboxes and port the different architecture-
speciﬁc analysis components to support each of them. In a re-
cent work covering the Mirai botnet [4], the authors supported
three architectures: MIPS 32-bit, ARM 32-bit, and x86 32-bit.
However, this covers a small fraction of the overall malware
landscape for Linux. For instance, these three architectures
together only cover about 32% of our dataset. Moreover, some
families (such as ARM) are particularly challenging to support
because of the large number of different CPU architectures they
contain.
Loaders and Libraries. The ELF ﬁle format allows a Linux
program to specify an arbitrary loader, which is responsible
to load and prepare the executable in memory. Unfortunately,
a copy of the requested loader may not be present in the
analysis environment, thus preventing the sample from starting
its execution. Moreover, dynamically linked binaries expect
their required libraries to be available in the target system:
once again, it is enough for a single library to be missing
to prevent the successful execution of the program. Contrary
to what one would expect, in the context of this work these
aspects affect a signiﬁcant portion of our dataset. A common
example are Linux programs that are dynamically linked with
uClibc or musl, smaller and more performant alternatives to the
traditional glibc. Not only does an analysis environment need
to have these alternatives installed, but their corresponding
loaders are also required.
Operating System. This work focuses on Linux binaries.
However, and quite unexpectedly, it can be challenging to
discern ELF programs compiled for Linux from other ELF-
compatible operating systems, such as FreeBSD or Android.
The ELF headers include an “OS/ABI” ﬁeld that, in principle,
should specify which operating system is required for the
program to run. In practice, this is rarely informative. For
example, ELF binaries for both Linux and Android specify a
generic “System V” OS/ABI. Moreover, current Linux kernels
seem to ignore this ﬁeld, and it
is possible for a binary
that speciﬁes “FreeBSD” as its OS/ABI to be a valid Linux
program, a trick that was abused by one of the malware sample
we encountered in our experiments. Finally, while a binary
compiled for FreeBSD can be properly loaded and executed
under Linux, this is only the case for dynamically linked pro-
grams. In fact, the syscalls numbers and arguments for Linux
and FreeBSD do not generally match, and therefore statically
linked programs usually crash when they encounter such a
difference. These differences may also exist between different
versions of the Linux kernel, and custom modiﬁcations are
not too rare in the world of embedded devices. This has two
important consequences for our work: On the one hand, it
makes it hard to compile a dataset of Linux-based malware.
On the other hand, this also results in the fact that even well-
formed Linux binaries may not be guaranteed to run correctly
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:40 UTC from IEEE Xplore.  Restrictions apply. 
in a generic Linux system.
B. Static Linking
When a binary is statically linked, all its library dependen-
cies are included in the resulting binary as part of the com-
pilation process. Static linking can offer several advantages,
including making the resulting binary more portable (as it is
going to execute correctly even when its dependencies are not
installed in the target environment) and making it harder to
reverse engineer (as it is difﬁcult to identify which library
functions are used by the binary).
Static linking introduces also another, much less obvious
challenge for malware analysis. In fact, since these binaries
include all their libraries, the resulting application does not
rely on any external wrapper to execute system calls. Normal
programs do not call system calls directly, but invoke instead
higher level API functions (typically part of the libc) that
in turn wrap the communication with the kernel. Statically
linked binaries are more portable from a library dependency
point of view, but less portable as they may crash at runtime if
the kernel ABI is different from what they expected (and what
was provided by the—unfortunately unknown—target system).
C. Analysis Environment
An ideal analysis sandbox should emulate as closely as
possible the system in which the sample under analysis was
supposed to run. So far we have discussed challenges related
to setting up an environment with the correct architecture,
libraries, and operating system, but
these only cover part
of the environment setup. Another important aspect is the
privileges the program should run with. Typically, malware
analysis sandboxes execute samples as a normal, unprivileged
user. Administration privileges would give the malware the
ability to tamper with the sandbox itself and would make the
instrumentation and observation of the program behavior much
more complex. Moreover, it is very uncommon for a Windows
sample to expect super-user privileges to work.
Unfortunately, Linux malware is often written with the
assumption (true for some classes of embedded targets) that
its code would run with root privileges. However, since these
details are rarely available to the analyst, it is difﬁcult to
identify these samples in advance. We will discuss how we
deal with this problem by performing a differential analysis in
Section III.
D. Lack of Previous Studies
To the best of our knowledge, this is the ﬁrst work that
attempts to perform a comprehensive analysis of the Linux
malware landscape. This mere fact introduces several addi-
tional challenges. First, it is not clear how to design and
implement an analysis pipeline speciﬁcally tailored for Linux
malware. In fact, analysis tools are tailored to the characteris-
tics of the existing malware samples. Unfortunately, the lack of
information on how Linux-based malware works complicated
the design of our pipeline. Which aspects should we focus on?
Which architectures do we need to support? A second problem
in this domain is the lack of a comprehensive dataset. One of
the few works looking at Linux-based malware focused only on
botnets, thus using honeypots to build a representative dataset.
Unfortunately, this approach would bias our study towards
those samples that propagate themselves on random targets.
III. ANALYSIS INFRASTRUCTURE
The task of designing and implementing an analysis infras-
tructure for Linux-based malware was complicated by the fact
that when we started our experiments we still knew very little
about how Linux malware worked and of which techniques
and components we would have needed to study its behavior.
For instance, we did not know a priori any of the challenges
we discussed in the previous section and we often had wrong
expectations about
the prevalence of certain characteristics
(such as static linking or malformed ﬁle headers) or their
impact on our analysis strategy.
Despite our extensive experience in analyzing malicious
ﬁles for Windows and Android, we only had an anecdo-
tal knowledge of Linux-based malware that we obtained by
reading online reports describing manual analysis of speciﬁc
families. Therefore,
the design and implementation of an
analysis pipeline became a trial-and-error process that we
tackled by following an incremental approach. Each analysis
task was implemented as an independent component, which
was integrated in an interactive framework responsible to
distribute the jobs execution among multiple parallel workers
and to provide a rich interface for human analysts to inspect
and visualize the data. As more samples were added to our
analysis environment every day,
the system identiﬁed and
reported any anomaly in the results or any problem that was
encountered in the execution of existing modules (such as
new and unsupported architectures, errors that prevented a
sample from being correctly executed in our sandboxes, or
unexpected crashes in the adopted tools). Whenever a certain
issue became widespread enough to impact
the successful
analysis of a considerable number of samples, we introduced