3.59
Table 5: Page load time (in seconds) of pSweeper on five pop-
ular websites.
5.5 Summary
In summary, faster sweeping rates can generally have lower runtime
and memory overheads. However, pSweeper with faster sweeping
rates will consume more energy and CPU resources. While this is
appropriate when there are idle cores, it may seriously affect the
performance of CPU-bound multi-threaded applications. Therefore,
if an application is not memory-allocation-intensive, pSweeper
should be usually configured to run at a lower sweeping rate.
6 DISCUSSION & LIMITATIONS
Comparison to garbage collection (GC). GC [6, 18] not only
heads off exploits but also prevents program crashes due to UaF
vulnerabilities. However, most GC algorithms consume more mem-
ory because they defer free until there is insufficient memory or
applications explicitly ask for. Even worse, some dangling pointers
can remain alive for a long time, thus preventing conservative GC
reclaiming freed memory. By contrast, pSweeper frees memory
after one round of pointer sweeping and can proactively eliminate
dangling pointers. Moreover, stop-the-world GC can cause unpre-
dictable interference to application performance. pSweeper instead
does not stall application threads. Finally, although pSweeper can
only probabilistically mask program crashes, it guarantees to pin-
point the root-causes of UaF vulnerabilities when programs crash.
pSweeper metadata protection. pSweeper does not specially
protect its metadata like the MAS and PLM table. However, this does
not degrade our security guarantee. By design, all UaF exploits are
disrupted. Thus, attackers can leak and tamper with metadata only
through non-UaF vulnerabilities. As discussed in §2, orthogonal
defenses should be used to protect against these vulnerabilities.
Accessing freed memory due to deferred free. Since pSweeper
defers object free until the end of a sweeping round, applications
are able to access the memory that should have been freed. This
design resembles garbage collection. Therefore, we believe this is
not a critical concern in practice.
Energy consumption. Since pSweeper continuously scans for
dangling pointers in a concurrent thread, it will consume more
power and energy. As a result, it may not be suitable for deployment
on battery-backed mobile devices. Instead, we envision pSweeper
to be mainly deployed on desktops.
False positives. Basically, false positives can occur in two cases.
First, a pointer may be type-casted to and used as an integer. For
instance, a program might depend on the difference of two pointers
p, q. If p or q is neutralized by pSweeper, the value (p − q) will be
changed. Second, applications may intentionally use the values in
dangling pointers. Since these false positives are rare in practice, we
believe they will not seriously affect the practicality of pSweeper.
Actually, all other three comparable approaches [36, 54, 58] suffer
the same false positives.
False negatives. pSweeper relies on the types of global/local vari-
ables and operands in store instructions to identify live pointers.
However, an integer is type-casted to a pointer at runtime. Also,
pSweeper currently conservatively ignores unions if one of their
fields are non-pointers. In these cases, pSweeper will suffer false
negatives if the missed pointers become dangling.
Another possible cause of false negatives lies in the fact that
pSweeper does not proactively neutralize dangling pointers in reg-
isters. It will induce undue overhead if pSweeper peeks into and
tampers with the registers used by application threads. While these
dangling pointers are theoretically false negatives, they can hardly
be exploited in practice. Therefore, currently we do not tackle them.
Instead, we guarantee that they never propagate to memory (§4.5).
Again, all existing approaches [36, 54, 58] do no handle dangling
pointer in registers.
7 RELATED WORK
We have compared pSweeper with DANGNULL [36], FreeSentry
[58] and DangSan [54], the works closest to ours above (§3.1). Here
we discuss the remaining related works.
Dangling pointer detection. Tools like Valgrind [45] and Ad-
dressSanitizer [51] track the (de)allocation status of each memory
location. As long as a freed memory block is not reallocated, these
tools can detect all dangling pointers. However, they can miss
those pointing to a reallocated memory, which is common in UaF
exploits. Another set of approaches extend each pointer with a
unique identifier and check the validity on every pointer derefer-
ence [15, 43, 56, 57]. Unfortunately, software-only explicit pointer
checks can slow applications by an order of magnitude. Recently,
Nagarakatte et al. [40, 41] proposed a hardware-assisted approach
that can provide full memory safety at low overheads. Undangle
[19] detects dangling pointers by using dynamic taint analysis to
track pointer propagations at runtime. It can serve as an in-house
testing tool but not a runtime defense system.
Safe memory allocators. Cling [14] is a safe memory allocator
that avoids memory reuse among objects of different types. It can
thwart many, but not all, UaF exploits. DieHard [16] and DieHarder
[47] are based on the idea of “infinite" heaps. Unfortunately, an
infinite-heap is idealized but infeasible, and thus it can only provide
probabilistic memory safety. Exterminator [48] extends DieHard
to automatically fix dangling pointers by delaying object frees.
Dhurjati and Adve [26] used a new virtual page for each memory
allocation and relied on page protection to detect dangling pointer
accesses. Inspired by Dhurjati and Adve’s work, Oscar [24] develops
a page-permission-based protection scheme to ensure pointer safety.
By contrast, pSweeper proactively neutralizes all dangling pointers.
Safe C languages. Fail-safe C [49] implements a completely
memory-safe compiler that is fully compatible with ANSI C. It uses
garbage collection to protect against dangling pointers. There are
also safe C dialects, such as Cyclone [28, 30] and CCured [21, 44]. Al-
though they attempt to keep compatible with C/C++ specifications,
non-trivial efforts are still needed to retrofit legacy programs.
Parallelizing security checks. Concurrent security checks as
in pSweeper have also been adopted in several previous works.
Speck [46] decouples security checks from applications and exe-
cutes them in parallel on multiple cores. Unlike Speck, pSweeper
does not use speculative execution. Cruiser [59] and Kruiser [52]
use concurrent threads to detect buffer overflows in user appli-
cations and kernels, respectively. ShadowReplica [29] accelerates
dynamic data flow tracking by running analysis on spare cores.
However, pSweeper tackles a different problem and faces unique
challenges. Finally, RCORE [27] detects program state invariant
violations on idle cores. Although RCORE can also detect dangling
pointers, it does not consider the race conditions (e.g., dangling
pointer propagation §4.5 and no deferred free in RCORE). RCORE
also relies on static type analysis to identify pointers, which is
quite challenging to be complete in real-world software. Therefore,
pSweeper is more robust than RCORE.
8 CONCLUSION
This paper presents pSweeper, a system that effectively protects
applications from UaF vulnerabilities at low overhead. The key
feature of pSweeper is to iteratively sweep live pointers to neutral-
ize dangling ones in concurrent threads. To accomplish this, we
devise lock-free algorithms to address the entangled races among
pSweeper and application threads, without using any heavyweight
synchronization mechanism that can stall application threads. We
also propose to encode object origin information into dangling
pointers to achieve object origin tracking, which helps to pinpoint
the root-causes of UaF vulnerabilities. We implement a prototype of
pSweeper and validate its effectiveness and efficiency in production
environments.
9 ACKNOWLEDGMENTS
We would like to thank our shepherd Byoungyoung Lee and anony-
mous reviewers for their insightful feedback, which helped us im-
prove the quality of this paper. This work was supported in part by
ONR grant N00014-17-1-248.
REFERENCES
[1] Apachebench. https://httpd.apache.org/docs/2.4/programs/ab.html/.
[2] app.telemetry page speed monitor. https://addons.mozilla.org/en-US/firefox/add
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CV
on/apptelemetry/.
[3] Cve-2014-3505.
E-2014-3505.
[4] Cve-2016-6309. https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-6309.
[5] Detecting memory access errors using hardware support. https://blogs.oracle.c
om/raj/entry/detecting_memory_access_errors_using.
[6] A garbage collector for c and c++. http://hboehm.info/gc/.
[7] Intel 64 and ia-32 architectures software developer manual.
https:
//www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-a
rchitectures-software-developer-system-programming-manual-325384.html.
[8] Jetstream. http://browserbench.org/JetStream/.
[9] Lighttpd bug-2440. https://redmine.lighttpd.net/issues/2440.
[10] The llvm compiler infrastructure. http://llvm.org/.
[11] Motionmark. http://browserbench.org/MotionMark/.
[12] Speedometer. http://browserbench.org/Speedometer/.
[13] Wireshark bug-12840. https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=
12840.
[14] Akritidis, P. Cling: A memory allocator to mitigate dangling pointers.
Proceedings of the 19th USENIX Conference on Security (Security) (2010).
[15] Austin, T. M., Breach, S. E., and Sohi, G. S. Efficient detection of all pointer
and array access errors. In Proceedings of the ACM SIGPLAN 1994 Conference on
Programming Language Design and Implementation (PLDI) (1994).
[16] Berger, E. D., and Zorn, B. G. Diehard: Probabilistic memory safety for unsafe
languages. In Proceedings of the 27th ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI) (2006).
In
[17] Bienia, C., Kumar, S., Singh, J. P., and Li, K. The parsec benchmark suite:
Characterization and architectural implications. In Proceedings of the 17th Inter-
national Conference on Parallel Architectures and Compilation Techniques (PACT)
(2008).
[18] Boehm, H.-J., and Weiser, M. Garbage collection in an uncooperative environ-
ment. Softw. Pract. Exper. 18 (1988).
[19] Caballero, J., Grieco, G., Marron, M., and Nappa, A. Undangle: Early detec-
tion of dangling pointers in use-after-free and double-free vulnerabilities. In
Proceedings of the 2012 International Symposium on Software Testing and Analysis
(ISSTA) (2012).
[20] Chen, X., Slowinska, A., Andriesse, D., Bos, H., and Giuffrida, C. Stackarmor:
Comprehensive protection from stack-based memory error vulnerabilities for
binaries. In Proc. Network and Distributed System Security Symposium (NDSS)
(2015).
[21] Condit, J., Harren, M., McPeak, S., Necula, G. C., and Weimer, W. Ccured in
the real world. In Proceedings of the ACM SIGPLAN 2003 Conference on Program-
ming Language Design and Implementation (PLDI) (2003).
[22] Cowan, C., Pu, C., Maier, D., Hintony, H., Walpole, J., Bakke, P., Beattie, S.,
Grier, A., Wagle, P., and Zhang, Q. Stackguard: Automatic adaptive detection
and prevention of buffer-overflow attacks. In Proceedings of the 7th Conference
on USENIX Security Symposium (1998).
[23] Criswell, J., Lenharth, A., Dhurjati, D., and Adve, V. Secure virtual ar-
chitecture: A safe execution environment for commodity operating systems.
In Proceedings of Twenty-first ACM SIGOPS Symposium on Operating Systems
Principles (SOSP) (2007).
[24] Dang, T. H., Maniatis, P., and Wagner, D. Oscar: A practical page-permissions-
based scheme for thwarting dangling pointers. In 26th USENIX Security Sympo-
sium (2017).
[25] Devietti, J., Blundell, C., Martin, M. M. K., and Zdancewic, S. Hardbound:
Architectural support for spatial safety of the c programming language.
In
Proceedings of the 13th International Conference on Architectural Support for Pro-
gramming Languages and Operating Systems (ASPLOS) (2008).
[26] Dhurjati, D., and Adve, V. Efficiently detecting all dangling pointer uses in
production servers. In Proceedings of the International Conference on Dependable
Systems and Networks (DSN) (2006).
[27] Giuffrida, C., Cavallaro, L., and Tanenbaum, A. S. Practical automated
vulnerability monitoring using program state invariants. In 2013 43rd Annual
IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)
(2013).
[28] Grossman, D., Morrisett, G., Jim, T., Hicks, M., Wang, Y., and Cheney, J.
Region-based memory management in cyclone. In Proceedings of the ACM SIG-
PLAN 2002 Conference on Programming Language Design and Implementation
(PLDI) (2002).
[29] Jee, K., Kemerlis, V. P., Keromytis, A. D., and Portokalidis, G. Shadowreplica:
Efficient parallelization of dynamic data flow tracking. In Proceedings of ACM
SIGSAC Conference on Computer and Communications Security (CCS) (2013).
[30] Jim, T., Morrisett, J. G., Grossman, D., Hicks, M. W., Cheney, J., and Wang, Y.
Cyclone: A safe dialect of c. In Proceedings of the General Track of the Annual
Conference on USENIX Annual Technical Conference (ATC) (2002).
[31] Jones, R., Hosking, A., and Moss, E. The Garbage Collection Handbook: The Art
of Automatic Memory Management, 1st ed. Chapman & Hall/CRC, 2011.
[32] Kasikci, B., Schubert, B., Pereira, C., Pokam, G., and Candea, G. Failure
sketching: A technique for automated root cause diagnosis of in-production
failures. In Proceedings of the 25th Symposium on Operating Systems Principles
(SOSP) (2015).
[33] Kharbutli, M., Jiang, X., Solihin, Y., Venkataramani, G., and Prvulovic, M.
Comprehensively and efficiently protecting the heap. In Proceedings of the 12th
International Conference on Architectural Support for Programming Languages and
Operating Systems (ASPLOS) (2006).
[34] Kuznetsov, V., Szekeres, L., Payer, M., Candea, G., Sekar, R., and Song, D.
Code-pointer integrity. In Proceedings of the 11th USENIX Conference on Operating
Systems Design and Implementation (OSDI) (2014).
[35] Lattner, C., and Adve, V. Llvm: A compilation framework for lifelong program
analysis & transformation. In Proceedings of the International Symposium on Code
Generation and Optimization: Feedback-directed and Runtime Optimization (CGO)
(2004).
[36] Lee, B., Song, C., Jang, Y., Wang, T., Kim, T., Lu, L., and Lee, W. Preventing use-
after-free with dangling pointers nullification. In Proc. Network and Distributed
System Security Symposium (NDSS) (2015).
[37] Liblit, B., Aiken, A., Zheng, A. X., and Jordan, M. I. Bug isolation via remote
program sampling.
In Proceedings of the ACM SIGPLAN 2003 Conference on
Programming Language Design and Implementation (PLDI) (2003).
[38] Liblit, B., Naik, M., Zheng, A. X., Aiken, A., and Jordan, M. I. Scalable
statistical bug isolation. In Proceedings of the 2005 ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI) (2005).
[39] Lvin, V. B., Novark, G., Berger, E. D., and Zorn, B. G. Archipelago: Trading
address space for reliability and security. In Proceedings of the 13th International
Conference on Architectural Support for Programming Languages and Operating
Systems (ASPLOS) (2008).
[40] Nagarakatte, S., Martin, M. M. K., and Zdancewic, S. Watchdog: Hardware
for safe and secure manual memory management and full memory safety. In
Proceedings of the 39th Annual International Symposium on Computer Architecture
(ISCA) (2012).
[41] Nagarakatte, S., Martin, M. M. K., and Zdancewic, S. Watchdoglite:
Hardware-accelerated compiler-based pointer checking. In Proceedings of Annual
IEEE/ACM International Symposium on Code Generation and Optimization (CGO)
(2014).
[42] Nagarakatte, S., Zhao, J., Martin, M. M., and Zdancewic, S. Softbound:
Highly compatible and complete spatial memory safety for c. In Proceedings
of the 30th ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI) (2009).
[43] Nagarakatte, S., Zhao, J., Martin, M. M., and Zdancewic, S. Cets: Compiler
enforced temporal safety for c. In Proceedings of the 2010 International Symposium
on Memory Management (ISMM) (2010).
[44] Necula, G. C., McPeak, S., and Weimer, W. Ccured: Type-safe retrofitting of
legacy code. In Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (POPL) (2002).
[45] Nethercote, N., and Seward, J. Valgrind: A framework for heavyweight
dynamic binary instrumentation.
In Proceedings of the 28th ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI) (2007).
[46] Nightingale, E. B., Peek, D., Chen, P. M., and Flinn, J. Parallelizing security
checks on commodity hardware. In Proceedings of the 13th International Confer-
ence on Architectural Support for Programming Languages and Operating Systems
(ASPLOS) (2008).
[47] Novark, G., and Berger, E. D. Dieharder: Securing the heap. In Proceedings of
the 17th ACM Conference on Computer and Communications Security (CCS) (2010).
[48] Novark, G., Berger, E. D., and Zorn, B. G. Exterminator: Automatically correct-
ing memory errors with high probability. In Proceedings of the 28th ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI) (2007).
[49] Oiwa, Y. Implementation of the memory-safe full ansi-c compiler. In Proceedings
of the 30th ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI) (2009).
[50] Prasad, M., and cker Chiueh, T. A binary rewriting defense against stack based
overflow attacks. In In Proceedings of the USENIX Annual Technical Conference
(ATC) (2003).
[51] Serebryany, K., Bruening, D., Potapenko, A., and Vyukov, D. Addresssanitizer:
A fast address sanity checker. In Proceedings of the 2012 USENIX Conference on
Annual Technical Conference (ATC) (2012).
[52] Tian, D., Zeng, Q., Wu, D., Liu, P., and Hu, C. Kruiser: Semi-synchronized non-
blocking concurrent kernel heap buffer overflow monitoring. In Proc. Network
and Distributed System Security Symposium (NDSS) (2015).
[53] Tucek, J., Lu, S., Huang, C., Xanthos, S., and Zhou, Y. Triage: Diagnosing
production run failures at the user’s site. In Proceedings of Twenty-first ACM
SIGOPS Symposium on Operating Systems Principles (SOSP) (2007).
[54] van der Kouwe, E., Nigade, V., and Giuffrida, C. Dangsan: Scalable use-after-
free detection. In Proceedings of the Twelfth European Conference on Computer
Systems (EuroSys) (2017).
[55] Venkataramani, G., Roemer, B., Solihin, Y., and Prvulovic, M. Memtracker:
Efficient and programmable support for memory access monitoring and debug-
ging.
In Proceedings of the 2007 IEEE 13th International Symposium on High
Performance Computer Architecture (HPCA) (2007).
[56] Xu, W., DuVarney, D. C., and Sekar, R. An efficient and backwards-compatible
transformation to ensure memory safety of c programs. In Proceedings of the
12th ACM SIGSOFT Twelfth International Symposium on Foundations of Software
Engineering (FSE) (2004).
[57] Yong, S. H., and Horwitz, S. Protecting c programs from attacks via invalid
pointer dereferences. In Proceedings of the 9th European Software Engineering
Conference Held Jointly with 11th ACM SIGSOFT International Symposium on
Foundations of Software Engineering (ESEC/FSE) (2003).
[58] Younan, Y. Freesentry: Protecting against use-after-free vulnerabilities due to
dangling pointers. In Proc. Network and Distributed System Security Symposium
(NDSS) (2015).
[59] Zeng, Q., Wu, D., and Liu, P. Cruiser: Concurrent heap buffer overflow moni-
toring using lock-free data structures. In Proceedings of the 32Nd ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI) (2011).