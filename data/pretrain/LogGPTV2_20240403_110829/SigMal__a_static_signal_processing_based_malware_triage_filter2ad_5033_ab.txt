ﬁlters are band-pass ﬁlters whose responses are Gaussian
functions modulated with a complex sinusoid. The ﬁlter
response t(x, y) and its Fourier transform T (u, v) are deﬁned
as:
t(x, y) =
1
(2πσxσy)
x2
y2
exp[− 1
(
2 +
2
σx
σy
(u − W )2
2 ) + 2πjW x]
T (u, v) = exp[− 1
2
(
(σu)2 +
v2
(σv)2 )]
(1)
(2)
where σu = 1/2πσx and σv = 1/2πσy. Here, σx and σy
are the standard deviations of the Gaussians function along
the x direction and y direction. These parameters deter-
mine the bandwidth of the ﬁlter and W is the modulation
frequency.
(x, y) and (u, v) are the spatial and frequency
domain coordinates.
We create a ﬁlter bank by rotating (orientation) and scal-
Figure 2: Texture-based feature computation. The
malware image is ﬁrst resized, then ﬁltered, followed
by sub-block averaging to form the feature vector.
ing (dilation) the basic ﬁlter response function t(x, y), re-
sulting in a set of k self-similar ﬁlters. In image processing
terminology, the functions modeling the ﬁlters are often re-
ferred to as Gabor Wavelets [6]. The image is then ﬁltered
using this ﬁlter bank to produce k ﬁltered images.
Each ﬁltered image is further divided into B × B sub-
blocks and the average value of a sub-block is computed and
stored as a vector of length L = B2. This way, k vectors of
length L are computed per image. These vectors are then
concatenated to form a kL-dimensional feature vector called
GIST. In this paper, we used 20 self-similar ﬁlters derived
from diﬀerent rotations (orientations) and scales. In partic-
ular, we used 3 scales, out of which the ﬁrst two scales have
8 orientations and the last one has 4. We used B = 4 to
obtain a 320-dimensional feature vector. These parameters
have been previously used for image search [7]. While com-
puting the GIST descriptor, it is a common pre-processing
step to resize the image to a square image of dimensions
s×s [7]. In our experiments, we used the parameters d = 256
and s = 64 and observed that choosing diﬀerent values of
d did not aﬀect the results, while choosing a value of s less
than s = 64 decreased the accuracy. Larger value of s in-
creased the computational complexity, however, because of
the sub-block averaging, this did not eﬀectively strengthen
the signature feature. In Fig. 2, we illustrate how a feature
vector is calculated by ﬁltering the image with a single ﬁlter.
This process is repeated for all other ﬁlters in the ﬁlter bank,
and the feature vectors thus obtained are concatenated to
form the full GIST descriptor.
2.2 Section-aware feature extraction
A normal executable ﬁle structure consists of many sec-
tions, such as code or data. Apart from some special types
of malware executables, such as COM ﬁles, usually all mal-
ware executable ﬁles are also structured in this way. The
true malicious behavior of malware is represented by the
section containing the code, which executes the actual ma-
licious activities. The previously-proposed algorithm [20]
ignores this critical information and generates malware ﬁn-
gerprints from the entire binary. This approach may cause
the code section similarity to be out-weighted by dissimilar-
ities of other sections, such as the resource section, and fail
to identify a variant. Generic packers and installers usually
share resources, such as icons and extraction routines. With
relatively small packed executables, these resource similari-
ties will produce false-positive similarity detection.
SigMal takes advantage of the internal structure of an ex-
ecutable. The texture properties of an executable section
depends on its content type. An executable can contain dif-
ferent types of contents such as code, packed and unpacked
data, and other resources, which produce corresponding dif-
MalwareImageSub-bandFilteringFeatureVectorSub-blockAveraging ResizeSectionExtractionData: PE Executable
Result: A list of important sections
Map sections into raw binary ﬁle;
if overlapping section exits then
resize section to make it contiguous with adjacent sections;
end
if .text executable section exists then
if is the largest section then
Result.append(.text section and the second largest
section);
else
if .text section is writable then
Result.append(two largest sections);
else
Result.append(.text section and the largest section);
end
end
else
if any non-writable executable section exists then
Result.append(this section and the largest section);
else
Result.append(two largest sections);
end
end
Algorithm 1: Finding important sections.
ferent types of GIST ﬁlter responses. The texture feature
extracted from the entire binary captures the spatial struc-
ture of these sections. To capture more localized signal infor-
mation from the important regions of the binary, we extract
separate GIST descriptors from each “important” section of
the executable. We say a section is an important section if it
is likely to contain the code (packed or unpacked) of the ex-
ecutable. These sections get more weight because the GIST
descriptors are computed on a per-section basis and con-
catenated to form the ﬁnal feature set. To extract separate
GIST descriptors from the important sections of the binary,
we ﬁrst need to identify them. One way to extract this in-
formation is to use the PE structure information. However,
especially in case of malware binaries, the mapping of sec-
tion information from the PE structure to the binary ﬁle
data is not always reliable. For example, code sections can
be compressed, relocated, or obfuscated, and their size can
be spuriously speciﬁed as an arbitrarily large value. We use
heuristics to ﬁnd boundaries of the important sections of an
executable within the raw binary data, and select two impor-
tant sections using the heuristics presented in Algorithm 1.
These heuristics are loosely based on [9]. The section type,
section ﬂags, and the size of the section are used in the
heuristics. For example, small writable executable sections
are usually common loader sections instead of actual mal-
ware code. The heuristics give less priority to such sections.
We also experimented with heuristics that prioritize the sec-
tion selection based on entropy instead of size. However, we
did not use this method because the results were slightly less
precise.
3. METHODOLOGY
3.1 Feature matching
We use the Euclidean distance metrics between feature
vectors to ﬁnd the nearest-neighbor sample in the learning
dataset. For each unknown sample q, we perform a nearest-
neighbor query on the malicious and the benign datasets,
which returns two distances, say dm and db, respectively.
If both distances are very similar, we cannot say for sure
whether the sample q is malicious or benign. This confusion
(a)
(b)
Figure 3: Illustration of a Balltree: (a) A Binary
Tree (b) Corresponding Ball Tree representation.
is even more pronounced when dm and db themselves are
large (i.e., when the similarity to the dataset is weak). In
order to model this nature of the distances, we introduce a
detection conﬁdence parameter c as described in Eq. 3. We
mark the sample q as unknown if the value of c is less than
a certain threshold (i.e., the absolute diﬀerence of distances
dm and db is not large enough).
(cid:112)d2
|dm − db|
m + d2
b
c =
(3)
Here, the value of detection conﬁdence c varies from 0 to
1, such that the value of 0 implies no conﬁdence (unknown),
and the value of 1 implies the highest conﬁdence. In case
of a faulty training set, where the same sample is present
in the both malware and benign datasets, the value of c for
that sample will be undeﬁned (dm = db = 0).
3.2 Fast nearest-neighbor
Because of the high dimensionality of the feature SigMal,
brute-force nearest-neighbor search is computationally ex-
pensive. For the eﬃcient nearest-neighbor search in a high-
dimensional space, we use Balltree data structures [22]. A
Ball, in n-dimensional Euclidean space Rn, is deﬁned as
a region bounded by a hyper sphere.
It is represented as
B = {c, r}, where c is an n-dimensional vector specifying
the coordinates of the ball’s centroid, and r is the radius of
the ball. A balltree is a binary tree where each node is asso-
ciated with a ball. Each ball is a minimal ball that contains
all balls associated with its children nodes. The data is re-
cursively partitioned into nodes deﬁned by the centroid and
the radius of the ball. Each point in the node lies within
this region. Fig. 3 shows an illustration of a binary tree,
and a balltree over four balls (1,2,3,4). Search is carried out
by ﬁnding the minimal ball that completely contains all its
children. This ball also overlaps the least with other balls
in the tree. For a dataset of M samples and dimensionality
N , the query time grows approximately as O(N log(M )) (as
opposed to O(N M ) for a brute force search).
3.3 Comparison
We compared our signal processing-based malware simi-
larity algorithm with three popular malware detection meth-
ods.
3.3.1 N-gram based detection
The N-gram signature based approach has been exten-
sively used in the previous works of malware similarity [3,
10, 29]. The N-gram signature of a string is a set of all sub-
strings of the string with a length n. In the case of a binary
executable, the N-gram signature is usually computed on
the string of its raw bytes, or disassembled instructions.
AB1234CABC1234Various similarity measures have been proposed to com-
pare the similarity between N-gram signatures [3, 10, 29]. In
our case, we used the Jaccard similarity metric, which has
been extensively used in previous work [4, 10, 25]. Jaccard
similarity is the number of common occurrence of N-grams
in both N-gram signatures with respect to the total num-
ber of unique N-grams. More precisely, given two N-gram
signatures (sets of N-grams) sa and sb:
sa ∩ sb
sa ∪ sb
J(sa, sb) =
.
3.3.2 PE structure-based detection
Several PE structure-based malware detection techniques
have been proposed [30, 31, 35]. They are mainly based on
the structural features of executables, which are directly ex-
tracted from the PE ﬁle structure with low computational
overhead. In a recent work, only seven PE-based features
were used to produce detection results comparable to meth-
ods using tens of features [26]. We used this method for our
evaluation experiment. As suggested by [26], we chose the
J48 decision-tree method to build models for the classes.
3.3.3 Control-ﬂow graph-based detection
Control-ﬂow graph (CFG) have been extensively used for
detecting similarities between executables [5, 8, 15]. Kruegel
et al. [15] extracted CFGs from network streams and de-
tected polymorphic worms by identifying structural similar-
ities. In this approach, the control ﬂow graphs are decom-
posed into a set of subgraphs of ﬁxed size k. Worm detection
and classiﬁcation occurs by identifying the prevalence of k-
subgraph features between worm-like executable content and
unknown executable content. We used the tool made avail-
able by [15] for the comparison experiment. The similarity
measure between two samples is calculated as below:
CF G similarity =
number of matching subgraphs
total number of subgraphs
.
As the focus of this paper is on packer-agnostic approach
of malware detection, in all of our experiments, malware
samples were used without unpacking. This includes the
control-ﬂow graph-based detection experiment. One can ar-
gue that this may not be a fair comparison, as the control-
ﬂow graph extracted from a packed executable is usually
representative of the unpacking routines only, rather than
the actual malware code. However, we are interested in the
comparison of the eﬀectiveness of these algorithms when ap-
plied directly on packed malware. The weak results of the
CFG-based approach in this case show that the method is
not suitable for packed executables.
4. DATASET
We prepared three datasets for the evaluation of detection
methods.
Benign dataset
For the ﬁrst dataset, we collected benign executables from
three diﬀerent sources, a fresh Windows XP SP2 install,
the ZDnet Software Directory, and the National Software
Figure 4: The toxicity ratio distribution of 1.2 million
malware samples.
Reference Library (NSRL) maintained by NIST. Our be-
nign dataset contains 377 executables from a fresh Win-
dows installation, the top 3000 most popular downloads
from ZDnet Software Directory, and 49,373 software bina-
ries from NSRL. We consider the most downloaded software
from ZDnet Software Directory as benign. We assume that
a malicious software sample does not appear in the most-
downloaded list of a well-reputed site. All of these samples
were also cross-checked with VirusTotal [2] to make sure that