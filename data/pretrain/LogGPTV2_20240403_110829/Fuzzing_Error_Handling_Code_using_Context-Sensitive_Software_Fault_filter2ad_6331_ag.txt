FIFUZZ can be still improved in some aspects. Firstly, the
static analysis of identifying possible error sites still has many
false positives. We plan to reduce these false positives us-
ing the ways mentioned in Section 6.1. Secondly, we plan
to improve FIFUZZ’s performance in some ways, such as
dropping useless error sequences, performing lightweight run-
time monitoring and exploiting multi-threading mentioned
in Section 6.4. Finally, we only use FIFUZZ to test C pro-
grams at present, and we plan to test the program in other
programming languages (such as C++ and Java).
Acknowledgment
We thank our shepherd, Deian Stefan, and anonymous review-
ers for their helpful advice on the paper. This work was mainly
supported by the China Postdoctoral Science Foundation un-
der Project 2019T120093. Kangjie Lu was supported in part
by the NSF award CNS-1931208. Any opinions, ﬁndings,
conclusions or recommendations expressed in this material
are those of the authors and do not necessarily reﬂect the
views of NSF. Jia-Ju Bai is the corresponding author.
References
[1] American Fuzzy Lop. http://lcamtuf.coredump.cx/aﬂ/.
[2] A collection of vulnerabilities discovered by the AFL
fuzzer. https://github.com/mrash/aﬂ-cve.
[3] ARM System Trace Macrocell (STM). https://commu-
nity.arm.com/tools/b/blog/posts/introduction-to-arm-s-
system-trace-macrocell.
[4] ASan: address sanitizer. https://github.com/google/san-
itizers/wiki/AddressSanitizer.
[5] ASan performance. https://github.com/google/sanitizers/
wiki/AddressSanitizerPerformanceNumbers.
[6] ASCHERMANN, C., FRASSETTO, T., HOLZ, T.,
JAUERNIG, P., SADEGHI, A.-R., AND TEUCHERT,
D. NAUTILUS: ﬁshing for deep bugs with grammars.
In Proceedings of the 26th Network and Distributed
Systems Security Symposium (NDSS) (2019).
[7] ASCHERMANN, C., SCHUMILO, S., BLAZYTKO, T.,
GAWLIK, R., AND HOLZ, T. REDQUEEN: fuzzing
with input-to-state correspondence. In Proceedings of
the 26th Network and Distributed Systems Security Sym-
posium (NDSS) (2019).
[8] ASKAROV, A., AND SABELFELD, A. Catch me if you
can: permissive yet secure error handling. In Proceed-
ings of the 4th International Workshop on Programming
Languages and Analysis for Security (PLAS) (2009),
pp. 45–57.
[9] BAI, J.-J., WANG, Y.-P., LIU, H.-Q., AND HU, S.-M.
Mining and checking paired functions in device drivers
Information and
using characteristic fault injection.
Software Technology (IST) 73 (2016), 122–133.
[10] BAI, J.-J., WANG, Y.-P., YIN, J., AND HU, S.-M. Test-
ing error handling code in device drivers using character-
istic fault injection. In Proceedings of the 2016 USENIX
Annual Technical Conference (2016), pp. 635–647.
[11] BANABIC, R., AND CANDEA, G. Fast black-box testing
In Proceedings of the 7th
of system recovery code.
European Conference on Computer Systems (EuroSys)
(2012), pp. 281–294.
[12] GNU Binutils. http://www.gnu.org/software/binutils/.
[13] BÖHME, M., PHAM, V.-T., AND ROYCHOUDHURY, A.
Coverage-based greybox fuzzing as markov chain. In
Proceedings of the 23rd International Conference on
Computer and Communications Security (CCS) (2016),
pp. 1032–1043.
[14] CABRAL, B., AND MARQUES, P. Exception handling:
A ﬁeld study in java and. net. In Proceedings of the 2007
European Conference on Object-Oriented Programming
(ECOOP) (2007), pp. 151–175.
[15] CHEN, Y., GROCE, A., ZHANG, C., WONG, W.-K.,
FERN, X., EIDE, E., AND REGEHR, J. Taming com-
piler fuzzers. In Proceedings of the 34th International
Conference on Programming Language Design and Im-
plementation (PLDI) (2013), pp. 197–208.
[16] Clang: a LLVM-based compiler for C/C++ program.
https://clang.llvm.org/.
[17] CLOC: count lines of code. https://cloc.sourceforge.net.
[18] CONG, K., LEI, L., YANG, Z., AND XIE, F. Automatic
fault injection for driver robustness testing. In Proceed-
ings of the 2015 International Symposium on Software
Testing and Analysis (ISSTA) (2015), pp. 361–372.
[19] CVE-2019-7846. https://nvd.nist.gov/vuln/detail/CVE-
2019-7846.
[20] CVE-2019-2240. https://nvd.nist.gov/vuln/detail/CVE-
2019-2240.
[21] CVE-2019-1750. https://nvd.nist.gov/vuln/detail/CVE-
2019-1750.
[22] CVE-2019-1785. https://nvd.nist.gov/vuln/detail/CVE-
2019-1785.
2608    29th USENIX Security Symposium
USENIX Association
[23] EBERT, F., AND CASTOR, F. A study on developers’
perceptions about exception handling bugs. In Proceed-
ings of the 2013 International Conference on Software
Maintenance (ICSM) (2013), pp. 448–451.
[24] FFmpeg: a complete, cross-platform solution to record,
convert and stream audio and video. https://ffmpeg.org/.
[25] FU, C., RYDER, B. G., MILANOVA, A., AND WONNA-
COTT, D. Testing of Java web services for robustness.
In Proceedings of the 2004 International Symposium on
Software Testing and Analysis (ISSTA) (2004), pp. 23–
34.
[26] GAN, S., ZHANG, C., QIN, X., TU, X., LI, K., PEI,
Z., AND CHEN, Z. CollAFL: path sensitive fuzzing. In
Proceedings of the 39th IEEE Symposium on Security
and Privacy (2018), pp. 679–696.
[27] GODEFROID, P., KIEZUN, A., AND LEVIN, M. Y.
In Proceedings
Grammar-based whitebox fuzzing.
of the 29th International Conference on Programming
Language Design and Implementation (PLDI) (2008),
pp. 206–215.
[28] GUNAWI, H. S., RUBIO-GONZÁLEZ, C., ARPACI-
DUSSEAU, A. C., ARPACI-DUSSEAU, R. H., AND LI-
BLIT, B. EIO: error handling is occasionally correct. In
Proceedings of the 6th International Conference on File
and Storage Technologies (FAST) (2008), pp. 207–222.
[29] HOLLER, C., HERZIG, K., AND ZELLER, A. Fuzzing
with code fragments. In Proceedings of the 21st USENIX
Security Symposium (2012), pp. 445–458.
[30] Honggfuzz: security oriented fuzzer with powerful anal-
ysis options. https://github.com/google/honggfuzz.
[31] Intel Processor Tracing (PT). https://software.intel.com/
en-us/blogs/2013/09/18/processor-tracing.
[32] JANA, S., KANG, Y. J., ROTH, S., AND RAY, B. Au-
tomatically detecting error handling bugs using error
speciﬁcations. In Proceedings of the 25th USENIX Se-
curity Symposium (2016), pp. 345–362.
[35] KIKUCHI, N., YOSHIMURA, T., SAKUMA, R., AND
KONO, K. Do injected faults cause real failures? a case
In Proceedings of the 25th Interna-
study of Linux.
tional Symposium on Software Reliability Engineering
Workshops (ISSRE-W) (2014), pp. 174–179.
[36] KING, J. C. Symbolic execution and program testing.
Communications of the ACM 19, 7 (1976), 385–394.
[37] LAWALL, J., LAURIE, B., HANSEN, R. R., PALIX, N.,
AND MULLER, G. Finding error handling bugs in
openssl using Coccinelle. In Proceedings of the 2010
European Dependable Computing Conference (EDCC)
(2010), pp. 191–196.
[38] LEMIEUX, C., AND SEN, K. FairFuzz: a targeted muta-
tion strategy for increasing greybox fuzz testing cover-
age. In Proceedings of the 33rd International Confer-
ence on Automated Software Engineering (ASE) (2018),
pp. 475–485.
[39] MARINESCU, P. D., AND CANDEA, G. LFI: a practical
and general library-level fault injector. In Proceedings
of the 39th International Conference on Dependable
Systems and Networks (DSN) (2009), pp. 379–388.
[40] MENDONCA, M., AND NEVES, N. Robustness test-
ing of the Windows DDK. In Proceedings of the 37th
International Conference on Dependable Systems and
Networks (DSN) (2007), pp. 554–564.
[41] MSan: memory sanitizer. https://github.com/google/san-
itizers/wiki/MemorySanitizer.
[42] MYTKOWICZ, T., COUGHLIN, D., AND DIWAN, A. In-
ferred call path proﬁling. In Proceedings of the 24th
International Conference on Object Oriented Program-
ming Systems Languages and Applications (OOPSLA)
(2009), pp. 175–190.
[43] NATELLA, R., COTRONEO, D., DURAES, J., AND
MADEIRA, H. Representativeness analysis of injected
software faults in complex software. In Proceedings
of the 40th International Conference on Dependable
Systems and Networks (DSN) (2010), pp. 437–446.
[33] KANG, Y., RAY, B., AND JANA, S. APEx: automated
inference of error speciﬁcations for C APIs. In Proceed-
ings of the 31st International Conference on Automated
Software Engineering (ASE) (2016), pp. 472–482.
[44] NATELLA, R., COTRONEO, D., DURAES, J. A., AND
MADEIRA, H. S. On fault representativeness of soft-
ware fault injection. IEEE Transactions on Software
Engineering (TSE) 39, 1 (2013), 80–96.
[34] KERY, M. B., LE GOUES, C., AND MYERS, B. A. Ex-
amining programmer practices for locally handling ex-
ceptions. In Proceedings of the 13th International Work-
ing Conference on Mining Software Repositories (MSR)
(2016), pp. 484–487.
[45] PADHYE, R., LEMIEUX, C., SEN, K., PAPADAKIS, M.,
AND LE TRAON, Y. Semantic fuzzing with Zest. In
Proceedings of the 2019 International Symposium on
Software Testing and Analysis (ISSTA) (2019), pp. 329–
340.
USENIX Association
29th USENIX Security Symposium    2609
[46] Aacsbr: check that sample_rate is not 0 before division.
http://github.com/ffmpeg/ffmpeg/commit/a50a5ff29e.
[47] Found bug: libav: divide-by-zero in sbr_make_f_master.
https://blogs.gentoo.org/ago/2016/09/21/libav-divide-
by-zero-in-sbr_make_f_master-aacsbr-c/.
[48] CVE-2016-7499. https://nvd.nist.gov/vuln/detail/CVE-
2016-7499.
[49] Frame: ﬁx the error path in av_frame_copy_props.
http://github.com/ffmpeg/ffmpeg/commit/a53551cba8.
[50] PHAM, V.-T., BÖHME, M., SANTOSA, A. E., CACI-
ULESCU, A. R., AND ROYCHOUDHURY, A. Smart
greybox fuzzing. IEEE Transactions on Software Engi-
neering (TSE) (2019).
[51] RAWAT, S., JAIN, V., KUMAR, A., COJOCAR, L.,
GIUFFRIDA, C., AND BOS, H. VUzzer: application-
aware evolutionary fuzzing. In Proceedings of the 24th
Network and Distributed Systems Security Symposium
(NDSS) (2017), pp. 1–14.
[52] ROSENBERG, H. A., AND SHIN, K. G. Software fault
injection and its application in distributed systems. In
Proceedings of the 23rd International Symposium on
Fault-Tolerant Computing (FTCS) (1993), pp. 208–217.
[53] SAHA, S., LOZI, J., THOMAS, G., LAWALL, J. L., AND
MULLER, G. Hector: detecting resource-release omis-
sion faults in error-handling code for systems software.
In Proceedings of the 43rd International Conference
on Dependable Systems and Networks (DSN) (2013),
pp. 1–12.
[59] WANG, J., CHEN, B., WEI, L., AND LIU, Y. Skyﬁre:
data-driven seed generation for fuzzing. In Proceedings
of the 38th IEEE Symposium on Security and Privacy
(2017), pp. 579–594.
[60] WANG, J., CHEN, B., WEI, L., AND LIU, Y. Superion:
grammar-aware greybox fuzzing. In Proceedings of the
41st International Conference on Software Engineering
(ICSE) (2019), pp. 724–735.
[61] WEIMER, W., AND NECULA, G. C. Finding and pre-
venting run-time error handling mistakes. In Proceed-
ings of the 19th International Conference on Object-
Oriented Programming Systems, Languages and Appli-
cations (OOPSLA) (2004), pp. 419–431.
[62] WU, W., CHEN, Y., XU, J., XING, X., GONG, X., AND
ZOU, W. FUZE: towards facilitating exploit generation
In Proceed-
for kernel use-after-free vulnerabilities.
ings of the 27th USENIX Security Symposium (2018),
pp. 781–797.
[63] XU, W., LI, J., SHU, J., YANG, W., XIE, T., ZHANG,
Y., AND GU, D. From collision to exploitation: unleash-
ing use-after-free vulnerabilities in Linux kernel.
In
Proceedings of the 22nd International Conference on
Computer and Communications Security (CCS) (2015),
pp. 414–425.
[64] YANG, X., CHEN, Y., EIDE, E., AND REGEHR, J. Find-
ing and understanding bugs in C compilers. In Proceed-
ings of the 32nd International Conference on Program-
ming Language Design and Implementation (PLDI)
(2011), pp. 283–294.
[54] SHAH, H., GÖRG, C., AND HARROLD, M. J. Why
do developers neglect exception handling? In Proceed-
ings of the 4th International Workshop on Exception
Handling (WEH) (2008), pp. 62–68.
[65] YUN, I., LEE, S., XU, M., JANG, Y., AND KIM, T.
QSYM: a practical concolic execution engine tailored
for hybrid fuzzing. In Proceedings of the 27th USENIX
Security Symposium (2018), pp. 745–761.
[55] SUSSKRAUT, M., AND FETZER, C. Automatically ﬁnd-
ing and patching bad error handling. In Proceedings of
the 2006 European Dependable Computing Conference
(EDCC) (2006), pp. 13–22.
[56] TSan: thread sanitizer. https://github.com/google/san-
itizers/wiki/ThreadSanitizerCppManual.
[57] UBSan: undeﬁned behavior sanitizer. https://clang.llvm.
org/docs/UndeﬁnedBehaviorSanitizer.html.
[58] VAN DER VEEN, V., FRATANTONIO, Y., LINDORFER,
M., GRUSS, D., MAURICE, C., VIGNA, G., BOS, H.,
RAZAVI, K., AND GIUFFRIDA, C. Drammer: deter-
ministic rowhammer attacks on mobile platforms. In
Proceedings of the 23rd International Conference on
Computer and Communications Security (CCS) (2016),
pp. 1675–1689.
[66] ZHANG, H., SHE, D., AND QIAN, Z. Android ion haz-
ard: The curse of customizable memory management
system. In Proceedings of the 23rd International Confer-
ence on Computer and Communications Security (CCS)
(2016), pp. 1663–1674.
[67] ZHANG, P., AND ELBAUM, S. Amplifying tests to
validate exception handling code. In Proceedings of the
34th International Conference on Software Engineering
(ICSE) (2012), pp. 595–605.
[68] ZUO, C., WU, J., AND GUO, S. Automatically detect-
ing SSL error-handling vulnerabilities in hybrid mobile
web apps. In Proceedings of the 10th ACM Symposium
on Information, Computer and Communications Secu-
rity (2015), pp. 591–596.
2610    29th USENIX Security Symposium
USENIX Association
USENIX Association
29th USENIX Security Symposium    2611
Appendix   We randomly select 50 of the 317 alerts reported by FIFUZZ in the 9 tested applications, and show their information in the table.   These 50 alerts are caused by 36 bugs in terms of their root causes.   The column “Error points” shows the call stacks of error points (ErrPtx) that trigger the alert. A call stack presents the information of each function call in the stack, including the name of the called function and code line number of this function call.   The columns “Source file” and “Line” respectively show the source file name and code line number where the alert occurs.   The column “State” shows the current state of our bug report. “F” means that the bug has been confirmed and fixed; “C” means that the bug has been confirmed but not fixed yet; “R” means that the bug report has not been replied.  Program Error points Source file Line Alert type State vim ErrPt1: main -> common_init(173) -> alloc(934) -> lalloc(827) -> malloc(924) message.c 4334 null-pointer dereference F vim ErrPt1: main -> mch_early_init(115) -> alloc(3212) -> lalloc(827) -> malloc(924) message.c 4334 null-pointer dereference F vim ErrPt1: main -> termcapinit(384) -> set_termname(2571) -> set_shellsize(2069) -> screenclear(3466) -> screenalloc(8744) -> lalloc(8495) -> malloc(924) screen.c 8664 null-pointer dereference F vim ErrPt1: main -> termcapinit(384) -> set_termname(2571) -> set_shellsize(2069) -> screenclear(3466) -> screenalloc(8744) -> win_alloc_lines(8507) -> alloc_clear(5085) -> lalloc(851) -> malloc(924) screen.c 8664 null-pointer dereference F vim ErrPt1: main -> vim_main2(444) -> create_windows(728) -> open_buffer(2750) -> ml_open(167) -> ml_new_data(392) -> mf_new(4015) -> mf_alloc_bhdr(379) -> alloc(898) -> lalloc(827) -> malloc(924) misc2.c 4446 null-pointer dereference F vim ErrPt1: main -> common_init(173) -> set_init_1(1010) -> set_options_default(3522) -> set_option_default(3847) -> set_string_option_direct(3769) -> vim_strsave(5976) -> alloc(1279) -> lalloc(827) -> malloc(924) charset.c 1456 null-pointer dereference F vim ErrPt1: main -> common_init(173) -> set_init_1(1010) -> set_options_default(3522) -> set_option_default(3847) -> set_string_option_direct(3769) -> set_string_option_global(5987) -> vim_strsave(6083) -> alloc(1279) -> lalloc(827) -> malloc(924) charset.c 1456 null-pointer dereference F vim ErrPt1: main -> command_line_scan(200) -> alist_add(2495) -> buflist_add(6688) -> buflist_new(3309) -> buf_copy_options(2036) -> vim_strsave(11649) -> alloc(1279) -> lalloc(827) -> malloc(924) option.c 8422 null-pointer dereference F vim ErrPt1: main -> command_line_scan(200) -> save_typebuf(2365) -> alloc_typebuf(1332) -> alloc(1286) -> lalloc(827) -> malloc(924) getchar.c 1313 double free F vim ErrPt1: main -> command_line_scan(200) -> save_typebuf(2365) -> alloc_typebuf(1332) -> alloc(1287) -> lalloc(827) -> malloc(924) getchar.c 1317 double free F vim ErrPt1: main -> init_highlight(413) -> do_highlight(415) -> syn_check_group(859) -> vim_strsave_up(3066) -> lalloc(827) -> malloc(924) highlight.c 871 null-pointer dereference F vim ErrPt1: main -> vim_main2(444) -> create_windows(728) -> open_buffer(2750) -> readfile(233) -> next_fenc(893) -> enc_canonize(2789) -> alloc(4323) -> lalloc(827) -> malloc(924) fileio.c 2320 freeing invalid pointer F vim ErrPt1: main -> vim_main2(444) -> main_loop(903) -> msg_attr(1286) -> msg_attr_keep(122) -> set_vim_var_string(142) -> vim_strsave(7119) -> alloc(1279) -> lalloc(827) -> malloc(924) message.c 1437 use after free F vim ErrPt1: main -> vim_main2(444) -> main_loop(903) -> normal_cmd(1370) -> do_pending_operator(1133) -> op_delete(1816) -> do_join(2079) -> alloc(4557) -> lalloc(827) -> malloc(924) ops.c 4559 null-pointer dereference F vim ErrPt1: main -> vim_main2(444) -> load_start_packages(492) -> do_in_path(2317) -> alloc(1864) -> lalloc(827) -> malloc(924) ErrPt2: main -> vim_main2(444) -> wait_return(680) -> hit_return_msg(1078) -> msg_puts_attr_len(1961) -> alloc(2588) -> lalloc(827) -> malloc(924) message.c 2589 null-pointer dereference F vim ErrPt1: main -> source_startup_scripts(432) -> do_source(3051) -> fix_fname(2759) -> FullName_save(4817) -> vim_FullName(3082) -> mch_FullName(4479) -> fchdir(2589) ErrPt2: main -> vim_main2(444) -> wait_return(680) -> hit_return_msg(1078) -> msg_putchar(1267) -> msg_putchar_attr(1369) -> msg_puts_attr(1386) -> msg_puts_attr_len(1961) -> msg_puts_printf(2008) -> alloc(2588) -> lalloc(827) -> malloc(924) message.c 2589 null-pointer dereference F bison ErrPt1: main -> uniqstrs_new(86) -> hash_initialize(160) -> malloc(605) hash.c 251 null-pointer dereference F bison ErrPt1: main -> reader(104) -> symbols_new(714) -> hash_initialize(776) -> malloc(605) hash.c 251 null-pointer dereference F bison ErrPt1: main -> muscle_init(87) -> hash_initialize(129) -> calloc(626) hash.c 251 null-pointer dereference F bison ErrPt1: main -> generate_states(124) -> allocate_storage(358) -> state_hash_new(168) -> hash_initialize(362) -> calloc(626) hash.c 251 null-pointer dereference F bison ErrPt1: main -> tables_generate(152) -> pack_table(802) -> bitset_create(727) -> bitset_alloc(163) -> bitset_init(138) -> vbitset_init(88) -> vbitset_resize(989) -> realloc(77) vector.c 81 null-pointer dereference F ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_alloc_context(1041) -> av_mallocz(151) -> av_malloc(238) -> posix_memalign(87) dict.c 205 null-pointer dereference R ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3331) -> open_output_file(3277) -> avformat_alloc_output_context2(2152) -> avformat_alloc_context(151) -> av_mallocz(151) -> av_malloc(238) -> posix_memalign(87) dict.c 205 null-pointer dereference R ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3331) -> open_output_file(3277) -> new_audio_stream(2236) -> new_output_stream(1859) -> avcodec_alloc_context3(1387) -> init_context_defaults(163) -> av_opt_set(141) -> set_string_number(484) -> av_expr_parse_and_eval(292) -> av_expr_parse(751) -> av_malloc(687) -> posix_memalign(87) options.c 141 assertion failure R ffmpeg ErrPt1: main -> transcode(4894) -> transcode_step(4692) -> process_input(4638) -> process_input_packet(4518) -> decode_audio(2619) -> send_frame_to_filters(2337) -> ifilter_send_frame(2270) -> configure_filtergraph(2189) -> avfilter_graph_parse2(1056) -> parse_filter(427) -> av_get_token(184) -> av_malloc(151) -> posix_memalign(87) avstrings.c 87 null-pointer dereference R ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_find_stream_info(1126) -> avcodec_open2(3674) -> av_mallocz(624) -> av_malloc(238) -> posix_memalign(87) utils.c 491 null-pointer dereference R ffmpeg ErrPt1: main -> transcode(4894) -> transcode_step(4692) -> reap_filters(4648) -> init_output_stream(1442) -> avcodec_open2(3517) -> ff_ac3_float_encode_init(935) -> ff_ac3_encode_init(138) -> allocate_buffers(2481) -> ff_ac3_float_allocate_sample_buffers(2331) -> av_mallocz(49) -> av_malloc(238) -> posix_memalign(87) mem.c 223 null-pointer dereference R   2612    29th USENIX Security Symposium
USENIX Association
Program Error points File name Line Bug type State ffmpeg ErrPt1: main -> transcode(4894) -> transcode_step(4692) -> process_input(4638) -> process_input_packet(4518) -> decode_audio(2619) -> send_frame_to_filters(2337) -> ifilter_send_frame(2270) -> configure_filtergraph(2189) -> avfilter_graph_config(1109) -> graph_config_formats(1275) -> query_formats(1164) -> ff_merge_channel_layouts(499) -> av_realloc_array(242) -> av_realloc(202) -> realloc(144) avfiltergraph.c 583 use after free R ffmpeg ErrPt1: main -> transcode(4894) -> transcode_step(4692) -> process_input(4638) -> process_input_packet(4518) -> decode_audio(2619) -> send_frame_to_filters(2337) -> ifilter_send_frame(2270) -> configure_filtergraph(2189) -> configure_output_filter(1106) -> configure_output_audio_filter(685) -> choose_channel_layouts(606) -> avio_close_dyn_buf(194) -> avio_flush(1431) -> flush_buffer(241) -> writeout(184) -> dyn_buf_write(163) -> av_reallocp(1319) -> av_realloc(173) -> realloc(144) ffmpeg_filter.c 179 null-pointer dereference R ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3331) -> open_output_file(3277) -> avio_open2(2558) -> ffio_open_whitelist(1180) -> ffio_fdopen(1169) -> av_strdup(1007) -> av_realloc(256) -> realloc(144) mem.c 233 double free R ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_open_input(1104) -> init_input(573) -> io_open_default(438) -> ffio_open_whitelist(124) -> ffio_fdopen(1169) -> av_strdup(1007) -> av_realloc(256) -> realloc(144) mem.c 233 double free R ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_find_stream_info(1126) -> avcodec_open2(3674) -> av_opt_set_dict(634) -> av_opt_set_dict2(1605) -> av_dict_set(1590) -> av_strdup(87) -> av_realloc(256) -> realloc(144) ErrPt2: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_find_stream_info(1126) -> try_decode_frame(3903) -> avcodec_open2(3050) -> ff_decode_bsfs_init(736) -> av_bsf_alloc(232) -> av_mallocz(86) -> av_malloc(238) -> posix_memalign(87) decode.c 2059 freeing dangling pointer R ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_find_stream_info(1126) -> avcodec_open2(3674) -> av_opt_set_dict(634) -> av_opt_set_dict2(1605) -> av_dict_set(1590) -> av_strdup(87) -> av_realloc(256) -> realloc(144) ErrPt2: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_find_stream_info(1126) -> try_decode_frame(3903) -> avcodec_open2(3050) -> aac_decode_init(935) -> ff_mdct_init(1226) -> ff_fft_init(61) -> av_malloc(224) -> posix_memalign(87) aacdec_template.c 2659 null-pointer dereference R ffmpeg ErrPt1: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_find_stream_info(1126) -> avcodec_open2(3674) -> av_opt_set_dict(634) -> av_opt_set_dict2(1605) -> av_dict_set(1590) -> av_strdup(87) -> av_realloc(256) -> realloc(144) ErrPt2: main -> ffmpeg_parse_options(4872) -> open_files(3317) -> open_input_file(3277) -> avformat_find_stream_info(1126) -> try_decode_frame(3903) -> avcodec_open2(3050) -> aac_decode_init(935) -> ff_mdct_init(1226) -> av_malloc_array(64) -> av_malloc(188) -> posix_memalign(87) aacdec_template.c 2659 null-pointer dereference R nasm ErrPt1: main -> saa_init(479) -> nasm_malloc(56) -> malloc(75) nasm.c 1909 null-pointer dereference F nasm ErrPt1: main -> init_labels(476) -> nasm_malloc(563) -> malloc(75) nasm.c 1909 null-pointer dereference F nasm ErrPt1: main -> saa_init(479) -> nasm_zalloc(47) -> calloc(85) nasm.c 1909 null-pointer dereference F nasm ErrPt1: main -> init_labels(476) -> hash_init(561) -> alloc_table(66) -> nasm_zalloc(60) -> calloc(85) nasm.c 1909 null-pointer dereference F catdoc ErrPt1: main -> read_charset(112) -> calloc(93) charsets.c 95 null-pointer dereference R clamav ErrPt1: main -> scanmanager(161) -> cl_engine_compile(861) -> cli_loadftm(5184) -> cli_parse_add(2156) -> cli_ac_addsig(497) -> cli_ac_addpatt(2835) -> cli_ac_addpatt_recursive(340) -> add_new_node(299) -> cli_calloc(236) -> calloc(216) matcher-ac.c 578 use after free C clamav ErrPt1: main -> scanmanager(161) -> cl_engine_compile(861) -> cli_loadftm(5184) -> cli_parse_add(2156) -> cli_ac_addsig(608) -> cli_ac_addpatt(2835) -> cli_ac_addpatt_recursive(340) -> cli_ac_addpatt_recursive(305) -> add_new_node(299) -> cli_calloc(229) -> calloc(216) matcher-ac.c 578 use after free C clamav ErrPt1: main -> scanmanager(161) -> cl_load(833) -> cli_loaddbdir(4726) -> cli_load(4581) -> cli_cvdload(4341) -> cli_tgzload(706) -> cli_load(345) -> cli_loadcbc(4392) -> load_oneldb(2020) -> cli_parse_add(1876) -> cli_ac_addsig(497) -> cli_ac_addpatt(2835) -> cli_ac_addpatt_recursive(340) -> add_new_node(299) -> cli_calloc(236) -> calloc(216) matcher-ac.c 578 use after free C clamav ErrPt1: main -> scanmanager(161) -> cl_load(833) -> cli_loaddbdir(4726) -> cli_load(4581) -> cli_cvdload(4341) -> cli_tgzload(706) -> cli_load(345) -> cli_loadcbc(4392) -> cli_initroots(1961) -> cli_bm_init(678) -> cli_calloc(147) -> calloc(216) matcher-bm.c 224 double free C clamav ErrPt1: main -> scanmanager(161) -> cl_engine_compile(861) -> cli_bytecode_prepare2(5250) -> selfcheck(2683) -> add_selfcheck(2479) -> cli_calloc(2397) -> calloc(216) bytecode.c 1931 null-pointer dereference C clamav ErrPt1: main -> scanmanager(161) -> cl_load(833) -> cli_loaddbdir(4726) -> cli_load(4581) -> cli_cvdload(4341) -> cli_cvdverify(625) -> cli_versig(566) -> cli_str2hex(131) -> cli_calloc(242) -> calloc(216) dsig.c 136 null-pointer dereference C clamav ErrPt1: main -> scanmanager(161) -> cl_engine_compile(861) -> cli_loadftm(5184) -> cli_parse_add(2156) -> cli_ac_addsig(608) -> cli_ac_addpatt(2835) -> cli_ac_addpatt_recursive(340) -> add_new_node(299) -> cli_realloc(245) -> realloc(235) matcher-ac.c 578 use after free C clamav ErrPt1: main -> scanmanager(161) -> cl_engine_compile(861) -> cli_loadftm(5184) -> cli_parse_add(2156) -> cli_ac_addsig(497) -> cli_ac_addpatt(2835) -> cli_ac_addpatt_recursive(340) -> cli_ac_addpatt_recursive(305) -> cli_ac_addpatt_recursive(305) -> insert_list(268) -> cli_realloc(106) -> realloc(235)  matcher-ac.c 578 use after free C clamav ErrPt1: main -> scanmanager(161) -> cl_engine_compile(861) -> cli_bytecode_prepare2(5250) -> selfcheck(2683) -> add_selfcheck(2479) -> cli_realloc2(2348) -> realloc(254) bytecode.c 1919 null-pointer dereference C clamav ErrPt1: main -> scanmanager(161) -> cl_load(833) -> cli_loaddbdir(4726) -> cli_load(4581) -> cli_cvdload(4341) -> cli_tgzload(706) -> cli_load(345) -> cli_loadcbc(4392) -> cli_initroots(1961) -> cli_ac_init(670) -> cli_malloc(521) -> malloc(197) matcher-ac.c 614 use after free C clamav ErrPt1: main -> scanmanager(161) -> scanfile(205) -> cl_scandesc_callback(391) -> scan_common(4324) -> malloc(4128) scanners.c 4129 null-pointer dereference R