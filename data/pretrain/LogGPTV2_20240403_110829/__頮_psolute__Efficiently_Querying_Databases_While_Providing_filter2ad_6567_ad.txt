the number of nodes in the tree, they are all positive with high
probability 1 − 𝛽, for negligible 𝛽.
Again, we can compute the exact minimum required value of 𝛼ℎ
in order to ensure drawing positive values with high probability by
using the CDF of the Laplace distribution. Specifically, 𝛼ℎ should be
equal to the minimum value that satisfies the following inequality.
log𝑘 𝑁
log𝑘 𝑁
𝜖
𝜖
(cid:18)
log𝑘 𝑁
(cid:19)nodes ≤ 1 − 𝛽
2𝑒− 𝛼ℎ·𝜖
−ln (2 − 2 nodes√︁1 − 𝛽) · log𝑘 𝑁
1 − 1
(cid:38)
(cid:39)
which is equivalent to
(1)
𝛼ℎ =
𝑘−1
𝜖
+ 𝑁 is the total number of tree
where nodes = 𝑘 ⌈log𝑘 (𝑘−1)+log𝑘 𝑁−1⌉−1
nodes.
5 AN EFFICIENT PARALLEL EPSOLUTE
While the previously described scheme is a secure and correct
CDP-ODB, a single-threaded implementation may be prohibitively
slow in practice. To bring the performance closer to real-world
requirements, we need to be able to scale the algorithm horizontally.
In this section, we describe an upgrade of Epsolute — a scalable
parallel solution.
We suggest two variants of parallel Epsolute protocol. Both of
them work by operating 𝑚 ORAMs and randomly assigning to each
of them 𝑛/𝑚 database records. For each query, we utilize the index
I to find the required records from the corresponding ORAMs. For
each ORAM, we execute a separate thread to retrieve the records.
The threads work in parallel and there is no need for locking, since
each ORAM works independently from the rest. We present two
methods that differ in the way they build and store DP structure
DS, and hence the number of ORAM requests they make.
Session 7C: Database and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2268Algorithm 2 Parallel Epsolute for Π𝛾, extends Algorithm 1. 𝑚 is the number of parallel ORAMs. H is a random hash function H : {0, 1}∗ →
{1, . . . , 𝑚}. 𝛾 and ˜𝑘0 are computed as in Section 5.2. U and S maintain 𝑚 ORAM states implicitly.
Πsetup of Π𝛾
1 : User U
Input: D
2 :
3 : I ← CreateIndex (D, 𝑚)
. . . . . . . . . . . . . . for 𝑗 ∈ {1, . . . , 𝑚} do (in parallel) . . . . . . . . . . . . . .
4 :
Server S
Input: DS
𝑘 ← B (DS, 𝑞)
˜𝑘0
4 :
𝑚
. . . . . . . . . . . . . . . . . . . . . for 𝑗 ∈ {1, . . . , 𝑚} do (in parallel) . . . . . . . . . . . . . . . . . . . . .
5 : ytrue = (r, 𝑟 ID
Πquery of Π𝛾
1 : User U
2 :
3 : 𝑇1, . . . ,𝑇𝑚 ← Lookup (𝐼, 𝑞)
(cid:68)𝑟, 𝑟 ID(cid:69) s.t. H(cid:16)𝑟 ID(cid:17)
(cid:68)(w, 𝑟 ID, 𝑟)(cid:69)
6 :
ORAM𝑗 (y)
Server S
Input: ∅
𝑐 ← (1 + 𝛾)
Input: 𝑞, I
5 : y =
= 𝑗
𝑞
𝑐
𝑖
,⊥)(cid:12)(cid:12)𝑖∈𝑇𝑗
6 : ynoise = (r, 𝑆 \ 𝑇𝑗 ,⊥)(cid:12)(cid:12)𝑐−|𝑇𝑗 |
1
. . . . . . . . . . . . . . . . . . . . . . . . . . . endfor . . . . . . . . . . . . . . . . . . . . . . . . . . .
7 : DS ← A (SK1, . . . , SK𝑁 )
8 : Output: I
Output: DS
DS
5.1 No-𝛾-method: DP structure per ORAM
In Πno−𝛾, for each ORAM / subset of the dataset, we build a DP index
the same way as described in Section 4. We note that Theorem 2.5
for disjoint datasets applies to this construction: the privacy budget
𝜖 for the construction is the largest (least private) among the 𝜖’s of
the DP indices for each ORAM / subset of the dataset.
The communication efficiency changes because (i) we essentially
add 𝑚 record subsets in order to answer a query, each having at
most 𝛼 extra random records, and (ii) each ORAM holds fewer
𝑚 .
records than before, resulting in a tree of height log 𝑛
However, we cannot expect that the records required for each
query are equally distributed among the different ORAMs in order
to reduce the multiplicative communication cost from log 𝑛 to log 𝑛
𝑚 .
Instead, we need to bound the worst case scenario which is repre-
sented by the maximum number of records from any ORAM that is
required to answer a query. This can be computed as follows.
Let 𝑋 𝑗 be 1 if a record for answering query 𝑞 is in a specific
ORAM𝑗, and 0 otherwise. Due to the random assignment of records
to ORAMs, Pr(cid:2)𝑋 𝑗 = 1(cid:3) = 1/𝑚. Assume that we need 𝑘0 records in
 𝑘0∑︁
order to answer query 𝑞 . The maximum number of records from
 ≤ exp
(cid:18)
ORAM𝑗 in order to answer 𝑞 is bounded as follows.
−𝑘0𝛾2
3𝑚
√︃−3𝑚 log 𝛽
Finally, we need to determine the value of𝛾 such that exp(cid:16)− 𝑘0𝛾2
is smaller than the value 𝛽. Thus, 𝛾 =
. The communi-
cation efficiency for each query type is described in the following
corollary.
𝑋𝑖 > (1 + 𝛾) 𝑘0
𝑚
(cid:19)
(cid:17)
𝑖=1
(2)
Pr
3𝑚
𝑘0
Corollary 5.1. Let Πno−𝛾 be an outsourced database system with
storage efficiency (O(1), 0). Depending on the query type, Πno−𝛾
offers the following communication efficiency.
log 𝑛
𝑚
𝜖 𝑚 log 𝑛(cid:17)(cid:19)
1 +√︃−3𝑚 log 𝛽
, O(cid:16) log1.5 𝑁
Range queries
(cid:18)(cid:18)
(cid:19)
(cid:19)
(cid:18)
O
𝑘0
ORAM𝑗 (ytrue∥ynoise)
7 : 𝑅 𝑗
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . endfor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8 : Output: 𝑅 𝑗
Output: ∅
(cid:12)(cid:12)𝑚
𝑗=1
(cid:18)
O
(cid:18)(cid:18)
1 +√︃−3𝑚 log 𝛽
𝑘0
(cid:19)
(cid:19)
𝜖 𝑚 log 𝑛(cid:17)(cid:19)
, O(cid:16) log 𝑁
log 𝑛
𝑚
Point queries
Then, Πno−𝛾 satisfies 𝜖-differential privacy for some 𝜖.
In our experiments, we set 𝑚 as a constant depending on the
infrastructure. However, if 𝑚 is set as O(log 𝑛), the total communica-
tion overhead of the construction will still exceed the lower-bound
presented in [46].
5.2 𝛾-method: shared DP structure
In Π𝛾, we maintain a single shared DP structure DS. When a query
is issued, we must ensure that the number of records retrieved from
every ORAM is the same. As such, depending on the required
noisy number of records ˜𝑘0, we need to retrieve at most (1 + 𝛾) ˜𝑘0
𝑚
records from each ORAM, see Eq. (2), for 𝛾 =
. Setting
˜𝑘0 = 𝑘0 + log1.5 𝑁
queries, the communication efficiency is as follows.
˜𝑘0
for range queries and ˜𝑘0 = 𝑘0 + log 𝑁
√︂−3𝑚 log 𝛽
for point
𝜖
𝜖
Corollary 5.2. Let Π𝛾 be an outsourced database system with
storage efficiency (O(1), 0). Depending on the query type, Π𝛾 offers
the following communication efficiency.
(cid:32)
(cid:33)
(cid:32)(cid:32)
1 +√︂ −3𝑚 log 𝛽
(cid:19)
(cid:18)(cid:18)
1 +√︂−3𝑚 log 𝛽
𝑘0+ log1.5 𝑁
𝜖
𝑘0+ log 𝑁
𝜖
(cid:33)
, 0
(cid:16)1 + log1.5 𝑁
(cid:17)(cid:19)
(cid:16)1 + log 𝑁
𝜖
𝜖
, 0
(cid:17)(cid:33)
(cid:19)
log 𝑛
𝑚
log 𝑛
𝑚
(cid:18)
Range queries
Point queries
O
O
Then, Π𝛾 satisfies 𝜖-differential privacy for some 𝜖.
Π𝛾 is depicted in Algorithm 2. There are a few extensions to
the subroutines and notation from Algorithm 1. CreateIndex and
Lookup now build and query the index which maps a search key to
a pair — the record ID and the ORAM ID (1 to 𝑚) which stores the
record. Lines 4 to 6 of Algorithm 2 Πsetup repeat for each ORAM
and operate on the records partitioned for the given ORAM using
hash function H on the record ID. A shared DP structure is created
Session 7C: Database and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2269with the sanitizer A (line 7). In Algorithm 2 Πquery, the total number
of ORAM requests is computed once (line 4). Lines 5 to 7 repeat for
each ORAM and operate on the subset of records stored in the given
ORAM. Note that U and S implicitly maintain 𝑚 ORAM states, and
the algorithm uses the (A, B) sanitizer defined in Section 4.
Note that we guarantee privacy and access pattern protection on
a record level. Each ORAM gets accessed at least once (much more
than once for a typical query) thus the existence of a particular
result record in a particular ORAM is hidden.
5.3 Practical improvements
Here we describe the optimizations aimed at bringing the construc-
tion’s performance to the real-world demands.
5.3.1 ORAM request batching. We have noticed that although the
entire set of ORAM requests for each query is known in advance, the
requests are still executed sequentially. To address this inefficiency,
we have designed a way to combine the requests in a batch and
reduce the number of network requests to the bare minimum. We
have implemented this method over PathORAM, which we use for
the (𝜂1, 𝜂2)-ORAM protocol, but the idea applies to most tree-based
ORAMs (similar to [20]).