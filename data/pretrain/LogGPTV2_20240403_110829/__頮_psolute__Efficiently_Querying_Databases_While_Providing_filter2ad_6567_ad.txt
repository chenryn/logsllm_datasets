the number of nodes in the tree, they are all positive with high
probability 1 âˆ’ ğ›½, for negligible ğ›½.
Again, we can compute the exact minimum required value of ğ›¼â„
in order to ensure drawing positive values with high probability by
using the CDF of the Laplace distribution. Specifically, ğ›¼â„ should be
equal to the minimum value that satisfies the following inequality.
logğ‘˜ ğ‘
logğ‘˜ ğ‘
ğœ–
ğœ–
(cid:18)
logğ‘˜ ğ‘
(cid:19)nodes â‰¤ 1 âˆ’ ğ›½
2ğ‘’âˆ’ ğ›¼â„Â·ğœ–
âˆ’ln (2 âˆ’ 2 nodesâˆšï¸1 âˆ’ ğ›½) Â· logğ‘˜ ğ‘
1 âˆ’ 1
(cid:38)
(cid:39)
which is equivalent to
(1)
ğ›¼â„ =
ğ‘˜âˆ’1
ğœ–
+ ğ‘ is the total number of tree
where nodes = ğ‘˜ âŒˆlogğ‘˜ (ğ‘˜âˆ’1)+logğ‘˜ ğ‘âˆ’1âŒ‰âˆ’1
nodes.
5 AN EFFICIENT PARALLEL EPSOLUTE
While the previously described scheme is a secure and correct
CDP-ODB, a single-threaded implementation may be prohibitively
slow in practice. To bring the performance closer to real-world
requirements, we need to be able to scale the algorithm horizontally.
In this section, we describe an upgrade of Epsolute â€” a scalable
parallel solution.
We suggest two variants of parallel Epsolute protocol. Both of
them work by operating ğ‘š ORAMs and randomly assigning to each
of them ğ‘›/ğ‘š database records. For each query, we utilize the index
I to find the required records from the corresponding ORAMs. For
each ORAM, we execute a separate thread to retrieve the records.
The threads work in parallel and there is no need for locking, since
each ORAM works independently from the rest. We present two
methods that differ in the way they build and store DP structure
DS, and hence the number of ORAM requests they make.
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2268Algorithm 2 Parallel Epsolute for Î ğ›¾, extends Algorithm 1. ğ‘š is the number of parallel ORAMs. H is a random hash function H : {0, 1}âˆ— â†’
{1, . . . , ğ‘š}. ğ›¾ and Ëœğ‘˜0 are computed as in Section 5.2. U and S maintain ğ‘š ORAM states implicitly.
Î setup of Î ğ›¾
1 : User U
Input: D
2 :
3 : I â† CreateIndex (D, ğ‘š)
. . . . . . . . . . . . . . for ğ‘— âˆˆ {1, . . . , ğ‘š} do (in parallel) . . . . . . . . . . . . . .
4 :
Server S
Input: DS
ğ‘˜ â† B (DS, ğ‘)
Ëœğ‘˜0
4 :
ğ‘š
. . . . . . . . . . . . . . . . . . . . . for ğ‘— âˆˆ {1, . . . , ğ‘š} do (in parallel) . . . . . . . . . . . . . . . . . . . . .
5 : ytrue = (r, ğ‘Ÿ ID
Î query of Î ğ›¾
1 : User U
2 :
3 : ğ‘‡1, . . . ,ğ‘‡ğ‘š â† Lookup (ğ¼, ğ‘)
(cid:68)ğ‘Ÿ, ğ‘Ÿ ID(cid:69) s.t. H(cid:16)ğ‘Ÿ ID(cid:17)
(cid:68)(w, ğ‘Ÿ ID, ğ‘Ÿ)(cid:69)
6 :
ORAMğ‘— (y)
Server S
Input: âˆ…
ğ‘ â† (1 + ğ›¾)
Input: ğ‘, I
5 : y =
= ğ‘—
ğ‘
ğ‘
ğ‘–
,âŠ¥)(cid:12)(cid:12)ğ‘–âˆˆğ‘‡ğ‘—
6 : ynoise = (r, ğ‘† \ ğ‘‡ğ‘— ,âŠ¥)(cid:12)(cid:12)ğ‘âˆ’|ğ‘‡ğ‘— |
1
. . . . . . . . . . . . . . . . . . . . . . . . . . . endfor . . . . . . . . . . . . . . . . . . . . . . . . . . .
7 : DS â† A (SK1, . . . , SKğ‘ )
8 : Output: I
Output: DS
DS
5.1 No-ğ›¾-method: DP structure per ORAM
In Î noâˆ’ğ›¾, for each ORAM / subset of the dataset, we build a DP index
the same way as described in Section 4. We note that Theorem 2.5
for disjoint datasets applies to this construction: the privacy budget
ğœ– for the construction is the largest (least private) among the ğœ–â€™s of
the DP indices for each ORAM / subset of the dataset.
The communication efficiency changes because (i) we essentially
add ğ‘š record subsets in order to answer a query, each having at
most ğ›¼ extra random records, and (ii) each ORAM holds fewer
ğ‘š .
records than before, resulting in a tree of height log ğ‘›
However, we cannot expect that the records required for each
query are equally distributed among the different ORAMs in order
to reduce the multiplicative communication cost from log ğ‘› to log ğ‘›
ğ‘š .
Instead, we need to bound the worst case scenario which is repre-
sented by the maximum number of records from any ORAM that is
required to answer a query. This can be computed as follows.
Let ğ‘‹ ğ‘— be 1 if a record for answering query ğ‘ is in a specific
ORAMğ‘—, and 0 otherwise. Due to the random assignment of records
to ORAMs, Pr(cid:2)ğ‘‹ ğ‘— = 1(cid:3) = 1/ğ‘š. Assume that we need ğ‘˜0 records in
 ğ‘˜0âˆ‘ï¸
order to answer query ğ‘ . The maximum number of records from
 â‰¤ exp
(cid:18)
ORAMğ‘— in order to answer ğ‘ is bounded as follows.
âˆ’ğ‘˜0ğ›¾2
3ğ‘š
âˆšï¸ƒâˆ’3ğ‘š log ğ›½
Finally, we need to determine the value ofğ›¾ such that exp(cid:16)âˆ’ ğ‘˜0ğ›¾2
is smaller than the value ğ›½. Thus, ğ›¾ =
. The communi-
cation efficiency for each query type is described in the following
corollary.
ğ‘‹ğ‘– > (1 + ğ›¾) ğ‘˜0
ğ‘š
(cid:19)
(cid:17)
ğ‘–=1
(2)
Pr
3ğ‘š
ğ‘˜0
Corollary 5.1. Let Î noâˆ’ğ›¾ be an outsourced database system with
storage efficiency (O(1), 0). Depending on the query type, Î noâˆ’ğ›¾
offers the following communication efficiency.
log ğ‘›
ğ‘š
ğœ– ğ‘š log ğ‘›(cid:17)(cid:19)
1 +âˆšï¸ƒâˆ’3ğ‘š log ğ›½
, O(cid:16) log1.5 ğ‘
Range queries
(cid:18)(cid:18)
(cid:19)
(cid:19)
(cid:18)
O
ğ‘˜0
ORAMğ‘— (ytrueâˆ¥ynoise)
7 : ğ‘… ğ‘—
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . endfor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8 : Output: ğ‘… ğ‘—
Output: âˆ…
(cid:12)(cid:12)ğ‘š
ğ‘—=1
(cid:18)
O
(cid:18)(cid:18)
1 +âˆšï¸ƒâˆ’3ğ‘š log ğ›½
ğ‘˜0
(cid:19)
(cid:19)
ğœ– ğ‘š log ğ‘›(cid:17)(cid:19)
, O(cid:16) log ğ‘
log ğ‘›
ğ‘š
Point queries
Then, Î noâˆ’ğ›¾ satisfies ğœ–-differential privacy for some ğœ–.
In our experiments, we set ğ‘š as a constant depending on the
infrastructure. However, if ğ‘š is set as O(log ğ‘›), the total communica-
tion overhead of the construction will still exceed the lower-bound
presented in [46].
5.2 ğ›¾-method: shared DP structure
In Î ğ›¾, we maintain a single shared DP structure DS. When a query
is issued, we must ensure that the number of records retrieved from
every ORAM is the same. As such, depending on the required
noisy number of records Ëœğ‘˜0, we need to retrieve at most (1 + ğ›¾) Ëœğ‘˜0
ğ‘š
records from each ORAM, see Eq. (2), for ğ›¾ =
. Setting
Ëœğ‘˜0 = ğ‘˜0 + log1.5 ğ‘
queries, the communication efficiency is as follows.
Ëœğ‘˜0
for range queries and Ëœğ‘˜0 = ğ‘˜0 + log ğ‘
âˆšï¸‚âˆ’3ğ‘š log ğ›½
for point
ğœ–
ğœ–
Corollary 5.2. Let Î ğ›¾ be an outsourced database system with
storage efficiency (O(1), 0). Depending on the query type, Î ğ›¾ offers
the following communication efficiency.
(cid:32)
(cid:33)
(cid:32)(cid:32)
1 +âˆšï¸‚ âˆ’3ğ‘š log ğ›½
(cid:19)
(cid:18)(cid:18)
1 +âˆšï¸‚âˆ’3ğ‘š log ğ›½
ğ‘˜0+ log1.5 ğ‘
ğœ–
ğ‘˜0+ log ğ‘
ğœ–
(cid:33)
, 0
(cid:16)1 + log1.5 ğ‘
(cid:17)(cid:19)
(cid:16)1 + log ğ‘
ğœ–
ğœ–
, 0
(cid:17)(cid:33)
(cid:19)
log ğ‘›
ğ‘š
log ğ‘›
ğ‘š
(cid:18)
Range queries
Point queries
O
O
Then, Î ğ›¾ satisfies ğœ–-differential privacy for some ğœ–.
Î ğ›¾ is depicted in Algorithm 2. There are a few extensions to
the subroutines and notation from Algorithm 1. CreateIndex and
Lookup now build and query the index which maps a search key to
a pair â€” the record ID and the ORAM ID (1 to ğ‘š) which stores the
record. Lines 4 to 6 of Algorithm 2 Î setup repeat for each ORAM
and operate on the records partitioned for the given ORAM using
hash function H on the record ID. A shared DP structure is created
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2269with the sanitizer A (line 7). In Algorithm 2 Î query, the total number
of ORAM requests is computed once (line 4). Lines 5 to 7 repeat for
each ORAM and operate on the subset of records stored in the given
ORAM. Note that U and S implicitly maintain ğ‘š ORAM states, and
the algorithm uses the (A, B) sanitizer defined in Section 4.
Note that we guarantee privacy and access pattern protection on
a record level. Each ORAM gets accessed at least once (much more
than once for a typical query) thus the existence of a particular
result record in a particular ORAM is hidden.
5.3 Practical improvements
Here we describe the optimizations aimed at bringing the construc-
tionâ€™s performance to the real-world demands.
5.3.1 ORAM request batching. We have noticed that although the
entire set of ORAM requests for each query is known in advance, the
requests are still executed sequentially. To address this inefficiency,
we have designed a way to combine the requests in a batch and
reduce the number of network requests to the bare minimum. We
have implemented this method over PathORAM, which we use for
the (ğœ‚1, ğœ‚2)-ORAM protocol, but the idea applies to most tree-based
ORAMs (similar to [20]).