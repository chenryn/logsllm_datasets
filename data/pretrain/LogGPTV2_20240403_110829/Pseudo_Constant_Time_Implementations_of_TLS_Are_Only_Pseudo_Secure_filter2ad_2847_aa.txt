title:Pseudo Constant Time Implementations of TLS Are Only Pseudo Secure
author:Eyal Ronen and
Kenneth G. Paterson and
Adi Shamir
Pseudo Constant Time Implementations of TLS
Are Only Pseudo Secure
Eyal Ronen1, Kenneth G. Paterson2, and Adi Shamir1
1 Weizmann Institute of Science.
eyal.ronen,PI:EMAIL
2 Royal Holloway, University of London,
PI:EMAIL
Abstract. Today, about 10% of TLS connections are still using CBC-mode ci-
pher suites, despite a long history of attacks and the availability of better options
(e.g. AES-GCM). In this work, we present three new types of attack against four
popular fully patched implementations of TLS (Amazon’s s2n, GnuTLS, mbed
TLS and wolfSSL) which elected to use “pseudo constant time” countermea-
sures against the Lucky 13 attack on CBC-mode. Our attacks combine several
variants of the PRIME+PROBE cache timing technique with a new extension
of the original Lucky 13 attack. They apply in a cross-VM attack setting and
are capable of recovering most of the plaintext whilst requiring only a moder-
ate number of TLS connections. Along the way, we uncovered additional serious
(but easy to patch) bugs in all four of the TLS implementations that we studied;
in three cases, these bugs lead to Lucky 13 style attacks that can be mounted re-
motely with no access to a shared cache. Our work shows that adopting pseudo
constant time countermeasures is not suﬃcient to attain real security in TLS
implementations in CBC mode.
Keywords: Lucky 13 attack, TLS, Side-channel cache attacks, Plaintext recovery
1
Introduction
“All secure implementations are alike; each insecure implementation is buggy in its own
way.” – after Leo Tolstoy, Anna Karenina.
1.1 Background
The celebrated Lucky 13 attack on TLS [3] builds on Vaudenay’s padding oracle at-
tack [33,9] and exploits small timing variations present in implementations of TLS’s
decryption processing for CBC-mode cipher suites. The attack enables remote plain-
text recovery of TLS-protected data that is sent repeatedly in predictable locations in
a connection, such as HTTP cookies. The exploited timing variations were endemic
in TLS implementations due to TLS’s reliance on a MAC-then-pad-then-encrypt con-
struction in CBC mode: reversing these steps requires removal of padding before robust
integrity checks have been performed. An attacker could exploit CBC-mode’s “cut and
paste” property to place target ciphertext blocks at the end of TLS records so that
they were interpreted as containing padding. The timing diﬀerences between good and
bad padding could then be translated into leakage about target plaintext blocks. Un-
der an assumption about the presence of malicious client-side JavaScript, an attacker
2
Eyal Ronen, Kenneth G. Paterson, and Adi Shamir
could arrange for arbitrary plaintext bytes to be recovered. Similar techniques were ex-
ploited in the POODLE attack [29] which was speciﬁc to SSL’s padding construction.
Implementation-speciﬁc variants of the Lucky 13 attack were also discovered, see for
example [2,5,4].
The TLS developer community responded in a variety of diﬀerent ways to Lucky
13.3 OpenSSL, used in Apache and NGINX, its BoringSSL fork used by Google in
Chrome and server-side, as well as NSS used in Mozilla Firefox, added roughly 500
new lines of code to implement the decryption processing required in a fully constant-
time, constant-memory-access fashion. The code is complex and diﬃcult to understand
for developers not fully conversant in constant-time programming techniques.4 Even
this was not fully successful at ﬁrst, as a code-branch in OpenSSL taking advantage
of AES hardware support was not properly patched, and an even worse attack was
enabled [32].
Other implementations (e.g. Amazon’s s2n, GnuTLS, wolfSSL) took an easier route
by adopting “pseudo constant time” solutions to address Lucky 13. For example, s2n
attempted to equalise the MAC veriﬁcation time by adding dummy HMAC compu-
tations and also included a random timing delay. This kind of approach was perhaps
justiﬁed given the small timing diﬀerences involved in Lucky 13 (on the order of 1
microsecond, making the attack diﬃcult to mount in practice, especially remotely) and
the complexity of the OpenSSL patch. However, soon after, Irazoqui et al. [5] showed
how to re-enable the Lucky 13 attack in a cross-VM setting, by presenting cache-
based “FLUSH+RELOAD” attacks that detect the dummy function calls that only
occur when bad padding is encountered. Their attacks work on deduplication-enabled
platforms (e.g. those implementing Kernel SamePage Merging, KSM, or related tech-
nologies). In this setting, their attacks apply to those implementations which take the
simplest approach to remediation, that of adding dummy computations via new func-
tion calls. Irazoqui et al. showed that the PolarSSL (now mbed TLS), GnuTLS and
CyaSSL (now wolfSSL) implementations were all vulnerable to attack in their speciﬁc
deduplication-enabled, cross-VM setting. PolarSSL patched against this attack, but
GnuTLS and wolfSSL chose not to. However, as deduplication is currently disabled
across diﬀerent VMs by Infrastructure-as-a-service (IaaS) providers [23], no practical
cross-VM attack against any implementation is currently known.5
More broadly, the Lucky 13 attack, and the vulnerabilities in the alternative RC4-
based cipher suites discovered around the same time, nudged developers into ﬁnally
implementing and deploying TLS 1.2 with its support for more modern AES-GCM-
based cipher suites. These have risen in popularity to the point today where more
than 80% of TLS connections rely on AES-GCM. Yet still today, more than 10% of
TLS traﬃc is protected with CBC-mode cipher suites in the original MAC-then-pad-
3 A partial list of vendor responses can be found at http://www.isg.rhul.ac.uk/tls/
Lucky13.html.
4 See https://www.imperialviolet.org/2013/02/04/luckythirteen.html for a detailed
discussion of this patch.
5 More recently Xiao et al. [35] used an automated diﬀerential analysis framework to ﬁnd
cache-based side channels to re-enable the Lucky 13 attack against GnuTLS and mbed TLS
code that runs directly inside an Intel Software Guard Extension (SGX) secure enclave.
However, they require root permissions for their “man in the kernel” attack.
Pseudo Constant Time Implementations of TLS Are Only Pseudo Secure
3
RSA AES 256 CBC SHA
RSA AES 128 CBC SHA
ECDHE RSA AES 256 CBC SHA384 4.4%
1.7%
1.2%
ECDHE RSA AES 256 CBC SHA 1.2%
ECDHE RSA AES 128 CBC SHA 1.1%
ECDHE RSA AES 128 CBC SHA256 1.1%
Table 1: Distribution of CBC-mode TLS cipher suites.
Source: ICSI Certiﬁcate Notary, 24/04/2018 [1]
then-encrypt construction, see Table 1.6 Notably, CBC-mode cipher suites relying on
HMAC with SHA-384 for integrity have risen in popularity over SHA-256 and SHA-1
(this might be due to the fact that on modern 64-bit CPUs, SHA-384 is faster per
byte than SHA-256). This 10% ﬁgure makes the security of CBC-mode cipher suites of
enduring interest and means that their continued study (and elimination in the event
of new vulnerabilities being found) is still of considerable value.
1.2 Our contributions
Our main contribution is to present novel cache timing attacks on a representative
set of implementations of TLS that did not adopt the fully constant-time/constant-
memory-access approach to address Lucky 13, but which instead used pseudo constant
time ﬁxes. We are thus able to mount practical attacks on TLS implementations that
have been fully patched against all previously known variants of Lucky 13, including
previous cache-based attacks such as [5].
As usual for such attacks, we assume the existence of a co-located adversary running
on the same CPU as the victim’s process or VM, and a shared cache. However, in
contrast to [5], we do not rely on memory deduplication technologies like KSM, that
are currently disabled across diﬀerent VMs by IaaS providers [23]. Instead, we only
assume a shared Last Level Cache (LLC) side-channel as in [23].
Our attacks are capable of plaintext recovery with low complexity. We use 3 diﬀerent
LLC side-channel based attack techniques to target the s2n, GnuTLS, mbed TLS and
wolfSSL implementations, giving for each technique a proof of concept (PoC) attack.
The attacks were developed through manual code inspection of the diﬀerent imple-
mentations. We show that each implementation provides some leakage to the adversary
about the amount of TLS padding present in a plaintext underlying a chosen cipher-
text. Using by-now standard “JavaScript in the browser” methods (see, for example,
[3]), such leakage can be leveraged to perform plaintext recovery for TLS cookies, for
example. Naive exploitation of some of the leakages requires a large number of TLS
connections, but we show how to ﬁne-tune them to improve their performance by three
orders of magnitude. We also introduce a novel variant of Lucky 13 that uses long TLS
padding patterns. These enhancements should be of independent interest.
Implementation Bugs in Lucky13 Countermeasures As a secondary contribu-
tion, we point out that all the reviewed pseudo constant time implementations of TLS
(s2n, GnuTLS, mbed TLS, wolfSSL) have bugs in their pseudo-constant-time code that
6 RFC 7366 [18] speciﬁes an alternative “Encrypt-then-MAC” construction, but ﬁgures ob-
tained from the ICSI Certiﬁcate Notary indicate that it is barely used.
4
Eyal Ronen, Kenneth G. Paterson, and Adi Shamir
come into play when SHA-384 is selected as the hash algorithm in HMAC. These bugs
are easy to ﬁx by changing some constants related to the SHA-384 hash size, but ren-
der the decryption operations non-constant time and therefore vulnerable to relatively
simple plaintext recovery attacks. Moreover, we show that GnuTLS is still vulnerable
to a novel variant of the original Lucky 13 attack even for SHA-256, despite having
been speciﬁcally patched against Lucky 13.
New variants of the PRIME+PROBE attack:
1. The synchronized probe PRIME+PROBE attack can sense the time between an
event controlled by the attacker (e.g. sending a message to the target) and a non-
constant-time memory access. We send the message at time tsend and assume that
the memory access will occur either at time tsend + t1 or tsend + t2 depending on
some secret value. We synchronize the cache probing to occur at time tsend + tprobe
(where t1  t2. From the result of the cache probing,
we get an oracle for the secret value. Again this attack technique is especially useful
a scenario where the side-channel probing resolution is not high enough to perform
multiple measurements in the interval of length t1− t2. The delay tprime is both code
and machine speciﬁc.
3. The “PostFetch” attack can help to overcome large cache lines that reduce the cache
attack resolution. We would like to distinguish between the cases of accessing just
the ﬁrst few bytes of an array inside a cache line, and accessing most of the array.
However, due to the cache line size, the whole array will be read into the cache in
both cases. In some scenarios, if a large part of a cache line is accessed (near the
cache line boundary), then the next cache line will also be read into the cache. This
can be caused by either hardware memory prefetching or by speculative execution.
In those scenarios, we can distinguish between the two types of access by probing
the cache line that contains the bytes after the array.
Implications of Our Results We consider our complete set of results surprising in
the light of the huge amount of eﬀort spent on correcting and verifying CBC-mode and
HMAC implementations in TLS over the last 5 years. For example, s2n was repeat-
edly patched in response to Lucky 13 style attacks [2,4]. Its principal author, Colm
MacCarthaigh wrote a detailed and thoughtful blogpost explaining AWS’s selected ap-
proach to defending against this kind of attack [24], focussing on the argument that a
balance needs to be struck between code simplicity and security. Moreover, the vulner-
able s2n HMAC code had also passed formal veriﬁcation [13,10]. At its core, our work
Pseudo Constant Time Implementations of TLS Are Only Pseudo Secure
5
shows that nothing short of the full “belt and braces” approach adopted in OpenSSL is
suﬃcient to provide a robust defence against Lucky 13 style attacks in all their forms,
and in fact the approach taken in OpenSSL is immune to our attacks. While our cache-
based timing attacks are diﬀerent from the methods used in previous attacks against
s2n [2,4] and mbed TLS [5], cache-based attack scenarios have been well-known and
broadly accepted as being realistic in the security community for some years. In retro-
spect, the developers of the TLS implementations which we target in this work might
have better invested their code development eﬀort in adopting fully robust approaches
from the beginning, rather than being forced to incrementally patch against each new
generation of attack (or to have to expend energy defending the decision not to patch
at all).
1.3 Disclosure
We have disclosed the vulnerabilities to all vendors mentioned in the paper, and sug-
gested a coordinated public disclosure on the 25th of July 2018. The status of these
disclosures at the time of writing is as follows:
– The wolfSSL team followed our recommendation and switched to the full constant
time solution in release 3.15.37 (released 20th June 2018).
– The mbed TLS team released a security advisory8 on July 25th 2018. CVEs 2018-
0497 and 2018-0497 were assigned to the SHA-384 bug and to the cache-based timing
attacks, respectively. Both CVEs were rated “high severity” and users were advised
to upgrade to new releases of the code, or to disable the CBC-mode cipher suite
if this is not possibles. Our understanding is that the new releases provide interim
ﬁxies, with a full solution to follow in due course.
– The GnuTLS team made a number of changes to their code on June 12th 2018 and
then in releases 3.6.3, 3.5.19 and 3.3.30 on July 16th 2018. These changes address
the bugs in SHA-384 constants and adopt a new variant of the pseudo constant time
approach, roughly equalising the running time of decryption processing by ensuring
a constant number of hash compression function calls is made. However, we believe
that the GnuTLS code is still vulnerable to variants of the attacks presented in our
paper due to its padding-dependent memory accesses. We notiﬁed the GnuTLS team
of our concerns about this on June 13th 2018. Our understanding is that the GnuTLS
team does not plan to address the issues, but prefers to promote the use of Encrypt-
then-MAC (as speciﬁed in RFC 7366) when legacy cipher suites are required. Red
Hat assigned CVEs 2018-10844, 2018-10845 and 2018-10846 to the issues.
– Amazon’s s2n team plans to remove CBC-mode cipher suites from their list of pre-
ferred ciphers, and will replace their implementation of CBC-mode decryption with
the fully constant time one from BoringSSL.
1.4 Paper Structure
Section 2 gives further background on the Lucky 13 attack and cache attacks, and
Section 3 describes the bugs we found in the various implementations of the lucky 13
7 https://www.wolfssl.com/docs/wolfssl-changelog/.
8 https://tls.mbed.org/tech-updates/security-advisories/
mbedtls-security-advisory-2018-02.
6
Eyal Ronen, Kenneth G. Paterson, and Adi Shamir
countermeasures. Next we describe the main contribution of our paper: Section 4 de-