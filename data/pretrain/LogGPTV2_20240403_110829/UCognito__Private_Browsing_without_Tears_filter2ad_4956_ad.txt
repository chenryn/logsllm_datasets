by adding a prefix to the path, that is, we rewrite the path to
/tmp/ucognito-pid/home/user/.config. Since the rewriting hap-
pens before entering the kernel execution, the file descriptors opened
for the redirected path. Thus, further read/write (accessed with file
descriptor) automatically happens on the file at the contained lo-
cation. Note that this rewriting operation is done outside of the
sandbox. Since we placed hooks for all file-related system-calls, the
Component
Sandbox & Policy
UI Layer
UCOGNITO
MBox [17]
MBox + UCOGNITO
UVERIFIER
Lines of code
415 lines of ANSI-C
149 lines of Java and Python
564 lines of code
24,311 lines of ANSI-C
24,827 lines of code
533 lines of Python
Figure 7: Components of UCOGNITO and an estimate of their complexities
in terms of lines of code. UCOGNITO can be implemented with minimal
code changes to MBox (564 lines of code). Note that we deleted/commented-
out unused part of MBox (48 lines) so that total number of lines are not
matched with addition of the two numbers. We also note that our verifier,
UVERIFIER has 533 lines of Python code.
web browser instance running in the sandbox environment cannot
bypass this rewriting routine.
5.2 Policy System
We implemented our policy system designed in §4.5 on our
filesystem sandbox. For each policy section (CLEAN, COPY, or WRITE),
they can have two types of path entries: a file or a directory entry.
Note that the enforcement is handled differently for files and direc-
tories (including all sub-directory entries). We describe the rules on
accessing files and directories under our policy system as follows.
File: initialize before start. For the file entry, we initialize them
during initialization of the sandbox; i.e., before running the browser
application. For files marked as COPY, we duplicate the specified
file from the host filesystem to the sandbox filesystem. For files
marked as CLEAN, we simply create an empty file on the sandbox
filesystem. After the file is initialized in this way, all further access
(both read/write) to those files are contained (by path rewriting) in
the sandbox filesystem.
Directory: initialize upon access. For directory entries, we initial-
ize them in lazy way, i.e., only when a system call is issued to access
a path under the specified directory. Upon the interception of such
system call, we get the path argument and check if the path is under
the directory listed in a COPY or CLEAN section of the policy file. Note
that if the path does not belongs to any of directory listed in the
policy, we copy the file to the sandbox filesystem. This is to support
loading of libraries (e.g., *.so files) and other files that are required
but not related to the private mode of the web browser. To prevent
this automatic COPY rule being applied to the whole filesystem, pol-
icy writer must specify the path, which is usually the user’s home
directory, in the CLEAN list to opt-out from this rule. In case a path is
matched with the entry in both CLEAN and COPY (e.g. ~/.config is
in COPY while ~/ is in CLEAN), we set COPY overrides CLEAN to follow
the policy of white-listing of the read access.
Data write-back. For WRITE policy, we enforce the policy when
the protected application (in our case, the browser) terminates. Upon
exiting the application, we get the list of modified files in the sandbox
filesystem. Modification is detected by comparing hash of contained
file with that of the file in the host filesystem. Then, we check if
a path belongs to any of policy definition. For a file entry, if the
path is matched, then it is written back to the source file at the host
filesystem. Likewise, for the directory entry, if the prefix matches,
we perform the same operation.
5.3 UI Layer
In UCOGNITO, since it wraps the normal web browser with sand-
box to make it as private mode, there is no UI indicator like Mozilla
Firefox and Google Chrome. To the user, it is very important to
Figure 8: UI highlights for UCOGNITO. Figure on the left shows normal
running of Mozilla Firefox; on the right, our UI highlight is shown as pink
border line to indicate UCOGNITO is working for the web browser.
know the mode of the current session. We employ a very simple
method: highlighting the border of the window with different colors.
Figure 8 shows an example. We keep track of the focus on the
X11 window display. Whenever focus changes, we check if the
currently focused window is in private mode. If it is, we retrieve the
size of the window, then draw a colored, thick borderline rectangle
over the window. We implemented the drawing part with JPanel and
make the rectangle always-on-the-top so that it cannot be hidden by
the browser window.
5.4 Launching a Private Mode
Launching a web browser with UCOGNITO is quite simple. The
following command launches Google Chrome web browser with
the specified policy file:
1 $ ucognito -P chrome_incognito.cfg -- google-chrome
The option argument -P indicates the location of policy file de-
scribed above. At the time of launching, before executing the actual
web browser program, UCOGNITO applies policy first to create a
new file (for CLEAN policy) or copy a file (for COPY). Afterwards,
UCOGNITO applies the sandbox by calling seccomp system call and
then executes the browser instance. The whole procedure for private
browsing under UCOGNITO can be divided into four phases:
1. Initialization phase. Load the policy file (if specified), then
applies pre-execution policies (e.g. COPY or CLEAN file entries);
2. Browser starting phase. Create a new process, place hooks on
50 file-related system calls using seccomp-bpf;
3. Browsing phase. Launch the browser to let user browse in
private mode;
4. Cleaning phase. Depending on the WRITE policy, check if any
file that belongs to the policy has been changed. If any, then
write back the file to the host filesystem to make it persist.
6. EVALUATION
The goal of our evaluation of UCOGNITO is to answer:
1. What are the use cases for UCOGNITO? (§6.1, §6.2)
2. How flexible and general is UCOGNITO’s policy in imple-
menting private browsing schemes of popular browsers? (§6.3)
3. How much is the performance overheads? (§6.4)
Experimental setup. To evaluate UCOGNITO, we ran Mozilla
Firefox 37.0.2 and Google Chrome 42.0.2311.152, on Ubuntu 14.04
LTS, running 64-bit Linux Kernel 3.19.0. We ran our experiments
on commodity hardware, equipped with Intel Xeon E5-1620 (one
CPU, quad core, and 3.6GHz) and 16GB of RAM.
6.1 Preventing Privacy Violations
We tested the effectiveness of UCOGNITO in protecting against
the privacy violations we found in §3.3. Our results showed that
UCOGNITO is able to mitigate all these privacy violation cases:
• OCSP cache. We ran a single private browsing session to visit
a HTTPS site. We observed that OCSP cache files generated
in the temporary filesystem during the private browsing ses-
sion are subsequently cleaned after the session finishes. None
of these cache files are written back to the original filesystem.
• PNaCl translation cache. We first ran a public browsing
session to generate PNaCl translation cache first and sub-
sequently ran a private browsing session to access the same
PNaCl app in §3.3. Unlike in §3.3, we observed no discernible
loading time differences between these two sessions.
• Nvidia’s OpenGL cache. We first ran a public browsing ses-
sion to generate Nvidia’s OpenGL translation cache and sub-
sequently ran a private browsing session to access the same
WebGL app in §3.3. Unlike in §3.3, we observed no differ-
ences in the Nvidia cache file in original filesystem and found
that new cache files are generated and subsequently deleted
in the temporary filesystem.
6.2 Supporting Add-ons
Add-ons can be a major source of privacy violation in private
mode, as evidenced in §2.4. We tested the effectiveness of UCOGNITO
in protecting against the privacy violations brought by add-ons. We
evaluated UCOGNITO against four popular Chrome extensions with-
out modification to the policy defined in Figure 5. We chose these
add-ons not only because of their popularity, but also because we
expected them to cause privacy violations as their core functionality,
i.e., session, history and autofill management, inevitably involve
user private data. As shown in Table 4, UCOGNITO successfully
prevented all privacy violations found in those four extensions, indi-
cating that UCOGNITO is a promising candidate in enabling private
mode support for add-ons without making any changes to those
add-ons.
6.3 Policy Flexibility
We measured the flexibility of our policy system in terms of
how fine-grain we can achieve in modelling a specific private mode.
Since UCOGNITO only provides per-file granularity for policy spec-
ification, if two types of persistent data are contained in one single
file and their use/store behavior is different in private mode, our
policy system will not be able to model that. Otherwise, we can
always define a policy to match the intended definition of private
mode. We show the mapping of persistent data to its container in Ta-
ble 5, and from the table it can be shown that for Firefox, browsing
history, downloaded entries and bookmarks are all persisted in the
the same file, places.sqlite. If we attach the WRITE policy to allow
saving bookmarks in private mode, then the browsing history will
be persisted too, which is not user intended. User or browser vendor
is forced to make a trade-off decision on this (although we believe
a better design is to have Firefox separate them). However, this
is the only case in Table 1 that cannot be expressed as a policy in
UCOGNITO. For any other item, enabling loading of it in private
mode requires only one COPY policy while enabling storing of the
item requires only one WRITE policy.
6.4 Browsing Performance
Since UCOGNITO heavily places hooks on the system calls, it af-
fects the running time of web browser. To measure the performance
overhead, we ran two types of test: 1) JavaScript benchmark, and
Benchmark
Base
Kraken (ms)
1171.1
Sunspider (ms) 158.3
Octane (pts)
27164
Firefox
Chrome
UCOGNITO
1171.2 (0.0%)
159.8 (0.9%)
27013 (-0.6%)
Base
1108.6
173.1
27266
UCOGNITO
1115.2 (0.6%)
177.4 (2.5%)
27018 (-0.9%)
Table 6: Performance overheads of standard JavaScript benchmark on Fire-
fox and Chrome running with UCOGNITO: the worst case performance
overhead is around 2.5%
Website
Google.com
193 ms
Bing.com
190 ms
Twitter.com
599 ms
Facebook.com 256 ms
Base UCOGNITO Overhead
1.55%
1.58%
2.50%
1.18%
196 ms
193 ms
614 ms
259 ms
Table 7: Page loading time in Google Chrome, with and without UCOGNITO.
The private-aware browsing with UCOGNITO incurs negligible overhead
(_0/1
Behavior in UCOGNITO
Only changes in Local Extension Settings are writ-
ten back to original filesystem as per policy, other
changes are discarded
The log file is deleted in the temporary filesystem upon
completion of the session
The log file is deleted in the temporary filesystem upon
completion of the session
Form entries saved in database file in temporary filesys-
tem and is not written back to the original filesystem
Table 4: Using UCOGNITO for automatically enabling private mode for add-ons.
Category
Transparent to user
User action involved
Add-on support
Persistent data
Browsing history
Cookies
Cache
HTML5 local storage
Flash storage
Download entries
Autofills
Bookmarks
Per-site zoom level
Per-site permission
SSL self-signed cert
SSL client cert
Add-on storage
Add-on installation
Firefox
Chrome
//places.sqlite
//cookies.sqlite
//cache2
//webappsstore.sqlite
//.macromedia/Flash_Player
//History
//Cookies
//Cache
//Local Storage
//Pepper Data/Shockwave Flash
//places.sqlite
//{key3.db, formhistory.sqlite}
//places.sqlite
//content-pref.sqlite
//permissions.sqlite