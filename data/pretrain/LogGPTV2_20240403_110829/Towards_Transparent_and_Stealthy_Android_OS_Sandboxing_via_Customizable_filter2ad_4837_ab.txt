containers and an extensive evaluation with existing anti-virtual-
machine heuristics, are still missing. Our research bridges this gap.
Challenges. Compared with the rise of container-based virtu-
alization in PC and server platforms [2, 26, 72], Android container’s
development has to overcome the challenge of hardware resource
multiplexing. Especially, many mobile devices are physically not
designed for multiplexing (e.g., WiFi and Bluetooth). For the An-
droid OS, at least the devices and pseudo-device drivers listed in
Table 1 must be fully supported. However, none of the existing
Android containers can meet this goal. Besides, to facilitate a rapid
transplantation and upgrade of the Android system, Android 8.0 re-
architected the vendor interface in the Android OS framework [46].
This new update invalidates existing virtualization methods on
multiple devices, such as Telephony, Display, Network, and Binder.
Another take-away message from Table 1 is that none of the
existing work can meet the “out-of-the-box” design; that is, all
of them have in-guest virtualization components that run at the
same privilege level as the VP’s apps. As a result, it is trivial to
detect whether an app is running in these containers by scanning
suspicious non-system files and processes. Furthermore, as shown
in Table 1’s gray color row, no existing work can customize the VP’s
device attributes. As we will present in §7, stealthy customization
is impossible without the “out-of-the-box” virtualization design.
Cells [10]. Cells is the pioneering work of mobile container-
based virtualization. Limited by the small-scale touchscreen, Cells
introduces a usage model of having one foreground VP and other
VPs running in the background. The VP running in the foreground
Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2860Table 1: The comparison of devices, pseudo-device drivers, and services among five Android container-based virtualization
solutions. Cellrox [17] is Cells’s commercial version. The labels(cid:2)/(cid:3) indicate the virtualization is missing ((cid:2)) or enabled ((cid:3)).(cid:4)(cid:2)
means the virtualization has been outdated in mainstream Android versions. The marks / indicate the device virtualization
meets the “out-of-the-box” design () or not ().
Description
Cells [10] Cellrox [17] Condroid [73] VMOS [71] VPBox
Device/Pseudo Device1
Display
Filesystem
Power
Binder
Input
Network
WiFi
Telephony
GPU
Sensors
Camera
Audio
GPS
Bluetooth
ADB
Display screen graphics
SD card partition virtualization
Power management
Inter-process communication
Touchscreen and input buttons
Core network resources
Wireless connection configuration
Incoming/outgoing calls
Graphics processing unit
Light sensor and accelerometer
Video and still-frame input
Speakers, microphone
Global positioning system
Short-range wireless communication
Command-line utility for debugging
Service
Multiple virtual phones
Reduce memory consumption
Security-Enhanced Linux in Android
Device attribute customization
The latest Android version supported
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:3), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:3), 
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:3)
(cid:4)(cid:2)
(cid:2)
(cid:2)
4.0.3
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:3), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:3), 
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:3)
(cid:4)(cid:2)
(cid:2)
(cid:2)
5.1
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:2)
(cid:2)
(cid:2)
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:2)
(cid:2)
(cid:2)
(cid:3)
(cid:4)(cid:2)
(cid:2)
(cid:2)
4.4.2
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:2)
(cid:2)
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:4)(cid:2), 
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
5.1
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3), 
(cid:3)
(cid:3)
(cid:3)
(cid:3)
10.0
1Pseudo-device drivers (e.g., Binder) are parts of the kernel that act like device drivers but do not correspond to any actual hardware.
is displayed at any time and is always given direct access to hard-
ware devices. Cells invents a new device namespace mechanism
to support efficient hardware resource multiplexing, and each VP is
associated with a unique device namespace for device interactions.
In addition to the kernel-level virtualization, Cells also integrates
user-level device virtualization methods to handle proprietary de-
vices with closed software stacks. Unfortunately, many of Cells’s
device virtualization methods are either incompatible with new
Android versions or leave in-guest components. Furthermore, it
also lacks some essential device virtualization solutions that are
indispensable to a malware sandbox. For example, as no existing
work can virtualize Bluetooth because of its complexity, malware
can easily check Bluetooth profiles (e.g., Bluetooth MAC Address)
to differentiate a sandbox from a real machine [4, 69].
Condroid [73] & VMOS [71]. Condroid and VMOS, two follow-
up Android containers, share similar limitations with Cells in trans-
parency and customization. Condroid transplants the Linux Con-
tainer tools [44] to Android and makes the most of the modifications
at the Android framework layer; it ensures the isolation of contain-
ers by leveraging namespaces and cgroups. VMOS runs another
Android OS as the guest operating system by mounting the virtual
root file system and virtualizing the JAVA runtime. VMOS’s virtual
system and the host phone share the host’s native libraries to access
hardware devices. Compared with Cells, VMOS’s implementation
is simpler, but at the cost of a weaker container isolation mecha-
nism. Except for the mount namespace, VMOS’s virtual system and
the host device have the same namespaces, which cannot isolate
operating system resources.
Summary. The existing Android containers are not qualified to
be an OS-level sandbox for security applications. Their limitations
on outdated/incomplete device virtualization, having in-guest com-
ponents, and a lack of device customization, can all be exploited
by attackers as new fingerprints to detect the presence of Android
containers. Our work delivers a novel Android container platform
with strong anti-evasion capability, even to a dedicated adversary.
2.4 Binder
Binder is the Android-specific inter-process communication (IPC)
mechanism and the remote method invocation system. Binder con-
sists of Binder driver, ServiceManager, server, and client. The Binder
driver is a pseudo device in the kernel and does not correspond to
the physical device. Userspace processes supporting the Binder com-
munication will create corresponding Binder data structures (e.g.,
binder_proc, binder_node) in the kernel to maintain the process
state. The server is the Binder service. ServiceManager is a special
Binder service. The Android kernel creates a global binder_node
object binder_context_mgr_node in the Binder driver to indicate
that it is the Binder service manager and set handler=0 for other
client processes to call. When the client (e.g., App) requests the
Binder service, it will obtain the ServiceManager service by calling
the handler with a value of 0. ServiceManager finally queries the
binder_node from the server according to the list of services it
maintains and binds it to binder_node from the client to implement
the client-to-server binder interface call.
Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2861Host Root Namespace
Virtual Phone
(Foreground)
Device Namespace
Proxy
Telephony Bluetooth
Cellc
CellD
Binder Service Sharing
Virtual
Phones
(Background)
Bluetoot
WiFi
Configuration Display
h
Telephon
GPU
y
Audio &
Camera
Kernel-Level Device Virtualization
Input
Sensors
Binder
Power
Network
GPS
Namespace(pid, uts, mnt, net, user, ipc, device)
cgroups
chroot
Linux Kernel
Figure 1: Overview of VPBox’s architecture. The names in
red represent Cells’s modules reused by VPBox.
3 VPBOX SYSTEM OVERVIEW
VPBox is a transparent and stealthy Android OS-level sandbox via
a novel, customizable container-based virtualization technique. To
enable the application to security related tasks, VPBox’s design is
capable of meeting the following two progressive requirements:
(1) Transparency. This requirement involves two aspects: a)
the virtualized device exhibits the same hardware effects as
the underlying physical device; b) complete virtualization
support for all devices and services listed in Table 1.
(2) Stealthiness. On top of the transparency, this requirement
ensures a dedicated adversary in the VP is difficult to finger-
print the presence of the container, including the presence of
virtualization components and the particular mobile device
that runs the container.
Existing Android containers partially meet the transparency re-
quirement due to their incomplete device virtualization, but no one
satisfies the stealthiness requirement. The last column of Table 1
shows VPBox’s advantages. All of the devices and services listed in
Table 1 are fully supported by VPBox, including hardware devices,
pseudo-device drivers, and necessary services to the Android sys-
tem (e.g., Bluetooth, ADB, and SELinux). Security analysts are free
to configure different device artifacts and then boot up diversified
virtual environments. To achieve the goal of stealthiness, we enable
our device virtualization and the customization of device-specific
attributes to be executed outside of VPs.
Figure 1 provides an overview of VPBox’s device virtualiza-
tion. VPBox retains the foreground-background VP usage model of
Cells [10]. Each isolated VP runs a stock Android userspace envi-
ronment. The VP running in the foreground can always have direct
access to hardware devices. VPBox utilizes Linux namespaces and
the device namespace introduced by Cells to remap OS resource
identifiers to VPs. Each VP has its private namespace so that it does
not interfere with the other VPs and the host. The names in red
in Figure 1 represent Cells’s modules reused by VPBox. We reuse
Cells’s kernel-level virtualization methods that still work in the
latest Android version, including Input (e.g., touchscreen and input
buttons) and Sensors (e.g., accelerometer and light sensors). The
virtualization of Input and Sensors is to modify a device subsystem
to be aware of the device namespace. We also keep two custom
processes, “Cellc” and “CellD,” in the host device’s root namespace;
they manage the service of booting up a VP and switching VPs be-
tween the foreground and background. CellD also coordinates our