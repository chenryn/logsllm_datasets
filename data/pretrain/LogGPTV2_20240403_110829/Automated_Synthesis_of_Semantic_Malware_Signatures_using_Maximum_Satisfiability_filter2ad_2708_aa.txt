title:Automated Synthesis of Semantic Malware Signatures using Maximum Satisfiability
author:Yu Feng and
Osbert Bastani and
Ruben Martins and
Isil Dillig and
Saswat Anand
Automated Synthesis of Semantic Malware
Signatures using Maximum Satisﬁability
Yu Feng
University of Texas at Austin
PI:EMAIL
Osbert Bastani
Stanford University
PI:EMAIL
Ruben Martins
University of Texas at Austin
PI:EMAIL
Isil Dillig
University of Texas at Austin
PI:EMAIL
Saswat Anand
Google, Inc.
PI:EMAIL
Abstract—This paper proposes a technique for automatically
learning semantic malware signatures for Android from very
few samples of a malware family. The key idea underlying our
technique is to look for a maximally suspicious common subgraph
(MSCS) that is shared between all known instances of a malware
family. An MSCS describes the shared functionality between
multiple Android applications in terms of inter-component call
relations and their semantic metadata (e.g., data-ﬂow properties).
Our approach identiﬁes such maximally suspicious common
subgraphs by reducing the problem to maximum satisﬁability.
Once a semantic signature is learned, our approach uses a
combination of static analysis and a new approximate signature
matching algorithm to determine whether an Android application
matches the semantic signature characterizing a given malware
family.
We have implemented our approach in a tool called ASTROID
and show that it has a number of advantages over state-of-the-
art malware detection techniques. First, we compare the semantic
malware signatures automatically synthesized by ASTROID with
manually-written signatures used in previous work and show that
the signatures learned by ASTROID perform better in terms of ac-
curacy as well as precision. Second, we compare ASTROID against
two state-of-the-art malware detection tools and demonstrate its
advantages in terms of interpretability and accuracy. Finally,
we demonstrate that ASTROID’s approximate signature matching
algorithm is resistant to behavioral obfuscation and that it can
be used to detect zero-day malware. In particular, we were able
to ﬁnd 22 instances of zero-day malware in Google Play that are
not reported as malware by existing tools.
I.
INTRODUCTION
Due to the enormous popularity of Android as a mobile
platform, the number of applications (“apps”) available for
Android has skyrocketed, with 1.6 million apps being currently
available for download. Unfortunately,
the soaring number
of Android users has also led to a rapid increase in the
Permission  to  freely  reproduce  all  or  part  of  this  paper  for  noncommercial 
purposes is granted provided that copies bear this notice and the full citation 
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited 
without the prior written consent of the Internet Society, the ﬁrst-named author 
(for  reproduction  of  an  entire  paper  only),  and  the  author’s  employer  if  the 
paper  was  prepared  within  the  scope  of  employment.
NDSS  ’17,  26  February  -  1  March  2017,  San  Diego,  CA,  USA
Copyright  2017  Internet  Society,  ISBN  1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23379
number of Android malware, with 4,900 malware samples
being introduced every day [1]. Correspondingly, this upsurge
in Android malware has also led to a ﬂurry of research for
automatically detecting malicious applications [2, 3, 4, 5, 6, 7].
Generally speaking, approaches for automated malware de-
tection can be classiﬁed as either signature-based or learning-
based. Signature-based techniques look for speciﬁc patterns in
the application to determine whether the app is malicious, and,
if so, which malware family the app belongs to [8, 2, 9, 10].
These patterns can either be syntactic (e.g., sequence of in-
structions) or semantic (e.g., control- or data-ﬂow properties).
Signature-based approaches allow security analysts to quickly
identify the malicious component of an application; hence,
they are widely-used by several commercial anti-virus (AV)
companies. However, one key shortcoming of these techniques
is that they require a trained security analyst to manually write
suitable signatures that can be used to detect each malware
family. Unfortunately, this manual effort is typically time-
consuming and error-prone.
Learning-based techniques [3, 6, 11, 12, 4, 13, 14, 5]
aim to address this limitation by automatically learning a
malware classiﬁer from data. These techniques extract various
features from the application and use standard machine learn-
ing algorithms to learn a classiﬁer that labels apps as either
benign or malicious. Compared to signature-based techniques,
current learning-based approaches suffer from a number of
shortcomings:
• They produce results that are difﬁcult to interpret (for
example, they typically cannot be used to determine the
malware family), which makes it difﬁcult for a security
analyst to discharge false positives.
• They typically require a large number of samples from
each malware family, which is problematic for families
that have recently emerged or that are rare (58% of
malware families in [3] have fewer than 5 samples).
This paper aims to overcome these disadvantages of ex-
isting malware detectors by proposing a new technique to
automatically infer malware signatures. By identifying mal-
ware based on inferred signatures, our approach retains all
the advantages of signature-based approaches: it can pinpoint
the location of the malicious components as well as the
corresponding malware family, and requires very few samples
(<5 in our evaluation). Furthermore, our approach can learn
semantic signatures that are resilient to low-level obfuscation
mechanisms and produces very few false alarms. Finally,
because our signature matching algorithm uses approximate
(rather than exact) matching, our algorithm is also resilient to
high-level obfuscation mechanisms that modify the program’s
control ﬂow and data-ﬂow properties.
The ﬁrst key insight underlying our approach is to au-
tomatically identify a semantic pattern that (a) occurs in all
instances of a given malware family, and (b) is maximally
suspicious (i.e., maximizes the number of “suspicious” features
that are typically not found in benign apps). Here, criterion (a)
serves to minimize the number of false negatives: If the pattern
does not occur in all instances of the malware family, then
our signatures would not match all malicious apps, thereby
resulting in false negatives. In contrast, criterion (b) serves
to minimize false positives: By requiring that the identiﬁed
semantic pattern is maximally suspicious, we ensure that our
signatures are unlikely to ﬂag benign apps as malicious.
The second key insight underlying our technique is to
automatically learn these semantic patterns by ﬁnding a maxi-
mally suspicious common subgraph (MSCS) of the malware in-
stances. An MSCS describes the shared functionality between
multiple Android applications in terms of inter-component
call relations and their semantic metadata (e.g., data-ﬂow
properties, intent ﬁlters, API calls etc.). Our approach automat-
ically ﬁnds an MSCS by reducing the problem to maximum
satisﬁability (MaxSAT). Intuitively, the MaxSAT problem aims
to maximize the amount of suspicious metadata while ensuring
that this functionality is shared between all instances of the
malware family. The solution to the MaxSAT problem can
then be directly translated into a semantic signature that
characterizes a speciﬁc malware family.
Our third and ﬁnal insight is to utilize the proposed sig-
nature inference algorithm for approximate matching. Specif-
ically, given a database of malware signatures and a new
application A, we must decide whether A matches any of these
signatures. Rather than performing exact signature matching
as done in previous work [2], we employ a novel approximate
signature matching algorithm. The key idea is to generate a
new signature S assuming that A is an instance of family
F. We then decide if A is actually an instance of F based on
the similarity score between S and F’s existing signature. The
main advantage of this approach is that it makes our technique
even more resilient to obfuscations, including those that change
program behavior.
We have implemented the proposed technique in a tool
called ASTROID1 and evaluate it
in a number of ways.
Our ﬁrst experiment shows that the signatures automatically
inferred by ASTROID are competitive with (in fact, better
than) manually-written signatures used for evaluating previous
work [2]. We also compare ASTROID with two state-of-
the-art Android malware detectors, namely DREBIN [3] and
MASSVET [15], and show that ASTROID compares favorably
with these tools in terms of accuracy, false positives, and
interpretability. Third, we demonstrate that ASTROID’s approx-
imate signature matching algorithm is both resilient to various
1ASTROID stands for Automatic SignaTure ﬁndeR for andrOID
behavioral obfuscations and is also useful for detecting zero-
day malware. Speciﬁcally, in a corpus of apps collected from
Google Play, ASTROID identiﬁed 103 apps from more than
10 malware families for which we did not previously have
signatures. Furthermore, among these 103 apps, 22 of them
were previously unknown and are not reported as malware by
existing tools.
signatures from few samples of a malware family.
This paper makes the following key contributions:
• We propose a novel
technique for inferring malware
• We formulate signature inference as the problem of ﬁnd-
ing a maximally suspicious common subgraph (MSCS) of
a set of Android applications and show how to reduce
MSCS detection to maximum satisﬁability.
• We propose a novel approximate signature matching
algorithm that leverages automated signature synthesis.
• We implement our approach in a tool called ASTROID and
evaluate it against manually written malware signatures,
other state-of-the-art malware detectors, and behavioral
obfuscation strategies.
II. BACKGROUND
In this section, we provide some background that is nec-
essary for understanding the rest of this paper.
A. Android Basics
An Android application consists of four kinds of com-
ponents, namely Activity, Service, BroadcastReceiver, and
ContentProvider. Every screen of an app corresponds to an
Activity. Services run in the background without a user in-
terface, ContentProviders store data, and BroadcastReceivers
react asynchronously to messages from other applications.
In Android, different components communicate with each
other through Intents, which are effectively messages that
describe operations to be performed. Components can receive
intents from other components or from the Android system;
thus intents form the basis of inter-component communication
(ICC) in Android. Intent objects can have several attributes,
three of which we discuss below:
ciﬁc component invoked by this Intent.
• The optional target attribute explicitly speciﬁes the spe-
• The action attribute speciﬁes the type of action that the
• The data type attribute speciﬁes the type of data that the
receiver of the Intent should perform.
receiver of the intent is supposed to operate on.
An Intent whose target attribute is speciﬁed is called an explicit
Intent. In contrast, an implicit Intent does not have its target
attribute speciﬁed, so the Android system decides the targets
of an implicit intent I at run time by comparing I’s action and
data attributes against the intent ﬁlters of other components.
The intent ﬁlter of a component C speciﬁes the action that C
is able to perform and the data it can operate on. Such intent
ﬁlters are declared in the app’s manifest, which is an XML ﬁle
containing information about the app.
2
Fig. 1: Motivating example to illustrate our approach
B. Inter-component Call Graphs
Our technique uses the inter-component call graph (ICCG)
representation introduced in previous work [2]. The ICCG for
an Android app summarizes inter-component communication
within the app as well as any relevant metadata (e.g., dataﬂow
or API calls). More formally, an ICCG for an application A
is a graph (V, X, Y ) where:
• V is a set of vertices, where each v ∈ V is a component
of A. The type of a vertex v, written T (v), is the type of
the component that v represents. Hence, we have:
T (v) ∈ T = {activity, service, receiver, provider}
• X is a set of edges representing inter-component call re-
lations. Speciﬁcally, (v, v(cid:48)) ∈ X indicates that component
v may invoke component v(cid:48) either through an explicit or
implicit intent.
• Y is a set of labeled edges representing metadata. In
particular, (v, v(cid:48), d) ∈ Y indicates that components v and
v(cid:48) are related by metadata d.
Metadata edges Y in the ICCG indicate potentially suspi-
cious behaviors of the app. We explain three kinds of metadata
that will be used in this paper:
• Data ﬂow information, denoted as src ; sink. In
particular, (v, v(cid:48), s ; s(cid:48)) ∈ Y indicates that the source
s originating from component v ﬂows to the sink s(cid:48) in
component v(cid:48). Sources represent conﬁdential information
(e.g., IMEI number), and sinks represent externally visible
channels (e.g., Internet, SMS).
• Suspicious API calls, written (cid:46)API. Speciﬁcally, an edge
(v, v, (cid:46)f) ∈ Y indicates component v calls Android API
method f (e.g., exec).
• Suspicious actions, denoted as (cid:5)Act, represent actions
that can be performed by a component. In particular,
(v, v,(cid:5)Act) ∈ Y indicates that component Y can perform
action Act.
• Intent ﬁlters, denoted as (cid:63)o, represent
the data type
that a given component can operate on. In particular,
(v, v, (cid:63)o) ∈ Y indicates that component v can operate
on data of type o (passed using intents).
For a given set of apps, the universe of labels from which
metadata can be drawn is ﬁxed. In the rest of the paper, we
use D to indicate the domain of edge labels d in Y .
Example 1: Consider the ICCG labeled as Gold Dream
Sample 1 in Figure 1. Here, solid edges represent X, and
dashed edges with metadata represent Y . Nodes drawn as
rectangles are Activities, while ellipses indicate Broadcas-
tReceivers and hexagons denote Services. Since there is a
solid edge from zjReceiver to zjService, broadcast
receiver zjReceiver may call zjService. Furthermore,
since there is a dashed edge from zjService to itself labeled
as deviceId ; Internet, source deviceId ﬂows to the Internet
within component zjService.
III. OVERVIEW
Suppose that Alice, a security auditor at an anti-virus
company, recently learned about a new malware family called
GoldDream [16]. Alice would like to update their anti-virus
tool to detect GoldDream instances. Alice wants to use a
learning-based tool to save work, but then she must man-
ually examine each app ﬂagged by the tool due to high
false positive rates (which is time-consuming because the
explanations produced by these tools typically do not pinpoint
malicious functionalities). Furthermore, the malware family is
new, so Alice only has two samples, and current learning-
based approaches require many training samples to achieve
high accuracy. Defeated, Alice manually writes signatures to
detect GoldDream instances by reverse engineering common
3
HandPicsdongmanfeizhuliufengjinganimalviewpicsAdActivityISniperProﬁleHighscoremoreGameUserActzjReceiverGameActMyReceiverBoolServicezjServiceactivity0activity2activity1activity3GoldDream Sample 1 (G1)GoldDream Sample 2 (G2)Signature candidate (S1)Signature candidate (S2)Signature candidate (S3)receiver0service0activity0malicious behaviors from the byte code of the two GoldDream
samples, and working to ensure that no benign apps are ﬂagged
by her signatures.
ASTROID can greatly beneﬁt Alice by automatically infer-
ring a signature characterizing the GoldDream family from as
few as two samples. In the top half of Figure 1, we show the
ICCGs of Alice’s two GoldDream samples. Observe that these
two samples have different component names and perform
very different functionalities—the ICCG on the left belongs
to a game, while the one on the right belongs to an app for
browsing pictures.
To detect the malice shared by these two samples, AS-
TROID searches for connected subgraphs of the two ICCGs that