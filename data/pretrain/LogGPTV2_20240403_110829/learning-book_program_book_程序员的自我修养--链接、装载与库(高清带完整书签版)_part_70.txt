(dosretval 1= 0 11 os_read == 0) (
*q+= CR;
else(
F
1.f(_o8fi1e (fh) &(PDEV1PPIPE))(
/ *
管道成设备文件*/
if(peekchr =s LF)
else {
*q++ = LF;
/如果预读的字特不是LF，
使用pipech存键字井·/
_pipech(fh) - peekchr;
*q▪+ = CR;
else{
if (q == buf && peekchr == LP)(
/*普通文件*/
*q++ = LF:
else {
/*如果预读的字符不是LF.
用geek四退文件指针*/
filepos =
_1seek_1k(fh, -1, FILE_CURRENT) ;
if (peekchr 1= LP}
q++ = CR;
bytes_read = (int) (q - (char *)buf1:
f
11.5.6fread回顾
如果读者能够一口气把fread的实现看完，我们对您表示十分的钦佩，因为它里面涉及
诸多的细节让人无法做到一览无余。我们在这里把这些细节略去，在此做个总结性的回顾。
当用户调用CRT的fread时，它到ReadFile的调用轨迹如图11-15所示。
程序员的自我修养——链接、装载与库
---
## Page 404
11.6本章小结
381
增加缓冲溢出保护，加锁
fread
V
循环读取、缓冲
不
换行符转换
_fread_nolocks
Windows文件读取API
_read
ReadFile/
图 11-15ReadFile 调用轨迹
在这个轨迹中，_fread_nolock_s的实现是最复杂的，因为它涉及缓冲区的操作，它也是
读取文件的主要部分，如果我们使用fread 读取一小块数据，有可能在_fread_nolock_s的时
候发现所有所需要的数据都在缓冲中，就不需要通过_read和ReadFile向操作系统读取文件
了，而是直接从缓冲区复制数据并返同，这样就减少了系统调用的开销。
11.6本章小结
在这一章中，我们介绍了程序运行库的各个方面，首先详细了解了Glibe和MSVCCRT
的程序入口点的实现，并在此基础上着重分析了MSVCCRT的初始化过程，尤其是MSVC
的 IO 初始化。
接下来，还介绍了C/C++运行库的其他方方面面，包括库函数的实现、运行库的构造、
运行库与并发的关系，以及最后C++运行库实现全局构造的方法。在介绍这些内容的过程中，
我们一改以往以Glibe的代码为主要示例的方法，着重以MSVC提供的运行库源代码为例子
介绍了fread在CRT 中的实现。由于Glibc为了支持多平台，它的IO部分的源代码显得十
分复杂而难以理解，不便于在本书中讲解，于是改为介绍MSVC的fread实现。
程序员的自我修养一链接、装载与库
---
## Page 406
系统调用与API
12.1系统调用介绍
12.2系统调用原理
12.3Windows API
12.4本章小结
程序员的自我修养一链接、装载与库
---
## Page 407
384
第12章系统调用与API
沿着程序与操作系统交互的轨迹，我们从程序如何髓接、如何使用运行库到运行库的实
现机制，层层挖掘和剖析，现在已经到了用户层面与内核层面的界限了，也就是常说的系统
调用（SystemCall）。系统调用是应用程序（运行库也是应用程序的一部分）与操作系统内
核之间的接口，它决定了应用程序是如何与内核打交道的。无论程序是直接进行系统调用，
还是通过运行库，最终还是会到达系统调用这个层面上。
Windows系统是完全基于DLL机制的，它通过DLL堆系统调用进行了包装，形成了所
谓的 Windows APl。应用程序所能看到的 Windows 系统的最底层的接口就是 Windows API，
比如上一节中的 fread最终还是到了ReadFile这个API。于是Windows 的程序相当于在运行
库与系统调用之间又多了一层API，不过无论如何，API最终还是通过系统调用。在这一章
里，我们会了解到系统调用和API的各方面，包括许多实现的细节。
12.1系统调用介绍
12.1.1什么是系统调用
在现代的操作系统里，程序运行的时候，本身是没有权利访问多少系统资源的。由于系
统有限的资源有可能被多个不同的应用程序同时访间，因此，如果不加以保护，那么各个应
用程序难免产生冲突。所以现代操作系统都将可能产生冲突的系统资源给保护起来，阻止应
用程序直接访问，这些系统资源包括文件、网络、IO、各种设备等。举个例子，无论在Windows
下还是Linux下，程序员都没有机会撞自去访问硬盘的某扇区上面的数据，而必须通过文件
系统：也不能擅自修改任意文件，所有的这些操作都必须经由操作系统所规定的方式来进行，
比如我们使用fopen去打开一个没有权限的文件就会发生失败。
此外，有一些行为，应用程序不借助操作系统是无法办到或不能有效地办到的。例如，
如果我们要让程序等待一段时间，不借助操作系统的唯一办法就是使用这样的代码：
for (i = 0; i 
int main(int argc, char* argv[])
char* error_nessage = *open file error\n*;
char buffer[64]:
int fd = open(*readme.txt*, 0, 0):
if(fd == -1) (
write( 0, error_message, strlen(error_me
ssagel};
程序员的自我修养——链接、装载与库
---
## Page 410
12.1系统调用介绍
387
return -1:
write( 0, success_nessage, strlen(success_message) );
read( fd, buffer, 64 );
// read tile
close (fd) ;
return 0;
当然也可以举一反三，可以使用read系统调用实现读取用户输入（标准输入的文件句
柄为1)。不过由于绕过了glibc 的文件读取机制，所以所有位于glibe 中的缓冲、按行读取
文本文件等这些机制都没有了，读取的就是文件的原始数据，当然很多时候我们希塑获得更
高的文件读写性能，直接绕过glibc使用系统调用也是一个比较好的办法。
我们也可以使用Linux的man命令察看每个系统调用的详细说明，比如察看read（man
参数2表示系统调用手册）：
$ nan 2 read