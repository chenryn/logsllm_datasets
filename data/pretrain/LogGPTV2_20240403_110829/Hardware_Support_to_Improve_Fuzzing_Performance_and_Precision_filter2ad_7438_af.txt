signed not to hinder the maximum clock frequency, we are limited
in our evaluation to a research-grade hardware setup with low
clock speed. We hope our work motivates future studies and adop-
tion on more powerful cores [58] and custom ASICs by processor
vendors [38]. Additionally, while SNAP does not support kernel
coverage filtered by the privilege level, leveraging the hardware
for tracing kernel space is not fundamentally restricted. SNAP is
also not suitable to track dynamic code generation with reused
code pages, such as JIT and library loading/unloading, as it affects
the validity of the coverage bitmap. If needed, annotations with
filters on the program space can be applied to reduce noise. Future
work could include repurposing a buffer dedicated for coverage
bitmap storage to avoid extra cache misses, leveraging other micro-
architectural states from hardware, such as memory access patterns,
to identify dynamic memory allocations (e.g., heap) across program
runs, or adopting operands of comparing instructions for feedback
as suggested [41]. Alternatively, given filters in the debug unit of
ARM’s CoreSight extension [2], the practicality of the design can
be further demonstrated without relying on custom hardware.
7 RELATED WORK
Binary-only fuzzing. Runtime coverage tracing can be costly and
becomes even more complicated when handling closed-source tar-
gets, such as COTS binaries. In particular, a typical software-based
solution falls into either static or dynamic binary instrumentation,
each limited by different constraints. For example, DynInst [57] is
not widely adopted, as the binary rewriting mechanism is error-
prone due to its complexity and thus cannot be applied to many
real-world use cases [15]. RetroWrite [15] requires relocation infor-
mation of position-independent code to soundly instrument bina-
ries. While most of the dynamic binary instrumentation schemes
[4, 11, 44, 49, 63] are more accessible to fuzzers thanks to their
ease of use, they typically suffer from significant overhead due to
runtime translation or callback routines. Although UnTracer [48]
suggests coverage-guided tracing to achieve near-native execution
speed for most of the non-interesting fuzzing testcases, its current
design and evaluation are based on basic block coverage, which
represents a less accurate program execution trace in regard to
branch transfers and loops. Despite that a revised edge coverage
tracker (without edge count) has been proposed, the performance
impact of switching to the new solution is unclear due to the po-
tential increase of interesting testcases. In contrast, SNAP avoids
such hassles by tracing at the hardware level. It removes the gap be-
tween source-based and binary-only tracing while providing richer
execution feedback with near-zero performance overhead.
Session 7B: FuzzingCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2225Hardware-assisted fuzzing. Besides the software-based solu-
tions, existing fuzzers [13, 26, 28, 53, 64] turn to available hardware
extensions [31, 32, 36] for guidance when fuzzing binaries without
source code. Intel PT [36] has been the most commonly adopted
one, exposing the full trace of an execution in a highly compressed
fashion for efficiency. Despite its generality, the use of Intel PT
for fuzzing can be ad-hoc, as the feature was originally designed
for helping debug a program execution with accurate and detailed
traces without worrying about performance impact. Therefore, it
already incurs at least 20-40% combined overhead for tracing and
decoding before a fuzzer can incorporate the feedback for further
mutation [33, 48, 64]. Although PTrix [13] utilizes Intel PT to gather
traces under a parallel scheme without recovering the exact condi-
tional branches for edge coverage to avoid major decoding over-
head, it merely achieves a comparable execution speed as source
instrumentation. Similarly, since PHMon [14] is designed to suit dif-
ferent use cases, such as providing shadow stack and watchpoints
for a debugger, its usage for tracing is not optimized for fuzzing
either. In comparison, SNAP adopts a highly optimized design for
fuzzing and shows its advantage over the other approaches in §5.4.
Despite the barrier to entry for a customized architecture, the ben-
efits of SNAP under minimal changes to an existing CPU pipeline
can be intriguing to commodity hardware. Motivated by the ex-
isting hardware-accelerated infrastructures dedicated for machine
learning [1, 23, 50], along with the increasing industrial demand
of fuzzing services [24, 47], SNAP demonstrates the feasibility of
performance boost by hardware-assisted fuzzing, complementing
Intel PT for various use cases.
8 CONCLUSION
We present SNAP, a customized hardware platform that imple-
ments hardware primitives to enhance performance and precision of
coverage-guided fuzzing. SNAP is prototyped as a full FPGA imple-
mentation together with the necessary OS support. By leveraging
micro-architectural optimizations in the processor, our prototype
enables not only transparent tracing but also richer feedback on
execution states with near-zero performance cost. Adopted fuzzers,
such as AFL, can achieve 41% and 228× faster execution speed
(and thus higher coverage) running on SNAP than with existing
tracing schemes, such as source instrumentation and DBI. The hard-
ware design only poses a 4.8% area and 6.5% power overhead and
thus is applicable to existing CPU architectures without significant
changes.
9 ACKNOWLEDGMENT
We thank the anonymous reviewers, and our shepherd, David Chis-
nall, for their helpful feedback. This research was supported, in
part, by the NSF award CNS-1563848 and CNS-1749711 ONR un-
der grant N00014-18-1-2662, N00014-15-1-2162, N00014-17-1-2895,
DARPA AIMEE HR00112090034 and SocialCyber HR00112190087,
ETRI IITP/KEIT[2014-3-00035], and gifts from Facebook, Mozilla,
Intel, VMware and Google.
REFERENCES
[1] Apple. 2020. M1: Apple Neural Engine. https://www.apple.com/newsroom/2020/
11/apple-unleashes-m1/.
[2] ARM. 2009. CoreSight Components Technical Reference Manual.
//developer.arm.com/documentation/ddi0314/h/.
https:
[3] Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, and
Thorsten Holz. 2019. REDQUEEN: Fuzzing with Input-to-State Correspondence.
In Proceedings of the 2019 Annual Network and Distributed System Security Sym-
posium (NDSS). San Diego, CA.
[4] Fabrice Bellard. 2005. QEMU, a fast and portable dynamic translator. In Proceed-
ings of the 2005 USENIX Annual Technical Conference (ATC). Anaheim, CA.
[5] UC Berkeley. 2016. Rocket Chip Generator. https://github.com/chipsalliance/
rocket-chip.
[6] UC Berkeley. 2017. The Berkeley Out-of-Order RISC-V Processor. https://github.
com/riscv-boom/riscv-boom.
[7] UC Berkeley. 2019. The Branch Predictor (BPD) in RISC-V BOOM. https://docs.
boom-core.org/en/latest/sections/branch-prediction/backing-predictor.html.
[8] David Biancolin, Sagar Karandikar, Donggyu Kim, Jack Koenig, Andrew Water-
man, Jonathan Bachrach, and Krste Asanovic. 2019. FASED: FPGA-Accelerated
Simulation and Evaluation of DRAM. In Proceedings of the 2019 ACM/SIGDA
International Symposium on Field-Programmable Gate Arrays (FPGA ’19).
[9] Marcel Bohme, Valentin Manes, and Sang Kil Cha. 2020. Boosting Fuzzer Effi-
ciency: An Information Theoretic Perspective. In Proceedings of the 28th Joint
Meeting of the European Software Engineering Conference (ESEC) and the ACM SIG-
SOFT Symposium on the Foundations of Software Engineering (FSE). Sacramento,
CA.
[10] Marcel Böhme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
based greybox fuzzing as markov chain. In Proceedings of the 23rd ACM Conference
on Computer and Communications Security (CCS). Vienna, Austria.
[11] Derek Bruening and Saman Amarasinghe. 2004. Efficient, transparent, and com-
prehensive runtime code manipulation. Ph.D. Dissertation. Massachusetts Institute
of Technology.
[12] Peng Chen and Hao Chen. 2018. Angora: Efficient Fuzzing by Principled Search.
In Proceedings of the 39th IEEE Symposium on Security and Privacy (Oakland). San
Francisco, CA.
[13] Yaohui Chen, Dongliang Mu, Jun Xu, Zhichuang Sun, Wenbo Shen, Xinyu Xing,
Long Lu, and Bing Mao. 2019. Ptrix: Efficient hardware-assisted fuzzing for cots
binary. In Proceedings of the 14th ACM Symposium on Information, Computer and
Communications Security (ASIACCS). Auckland, New Zealand.
[14] Leila Delshadtehrani, Sadullah Canakci, Boyou Zhou, Schuyler Eldridge, Ajay
Joshi, and Manuel Egele. 2020. PHMon: A Programmable Hardware Monitor and
Its Security Use Cases. In Proceedings of the 29th USENIX Security Symposium
(Security). Boston, MA.
[15] Sushant Dinesh, Nathan Burow, Dongyan Xu, and Mathias Payer. 2018.
Retrowrite: Statically instrumenting cots binaries for fuzzing and sanitization. In
Proceedings of the 41st IEEE Symposium on Security and Privacy (Oakland).
[16] Andrea Fioraldi, Daniele Cono D’Elia, and Emilio Coppa. 2020. WEIZZ: Auto-
matic Grey-box Fuzzing for Structured Binary Formats. In Proceedings of the
International Symposium on Software Testing and Analysis (ISSTA). Los Angeles,
CA.
[17] Andrea Fioraldi, Dominik Maier, Heiko Eißfeldt, and Marc Heuse. 2020. AFL++:
Combining incremental steps of fuzzing research. In Proceedings of the 14th
USENIX Workshop on Offensive Technologies (WOOT).
[18] Shuitao Gan, Chao Zhang, Peng Chen, Bodong Zhao, Xiaojun Qin, Dong Wu,
and Zuoning Chen. 2020. GREYONE: Data Flow Sensitive Fuzzing. In Proceedings
of the 29th USENIX Security Symposium (Security). Boston, MA.
[19] Shuitao Gan, Chao Zhang, Xiaojun Qin, Xuwen Tu, Kang Li, Zhongyu Pei, and
Zuoning Chen. 2018. CollAFL: Path Sensitive Fuzzing. In Proceedings of the 39th
IEEE Symposium on Security and Privacy (Oakland). San Francisco, CA.
[20] GNU Compiler Collection (GCC). 2012. Gcov is a test coverage program. https:
//gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html.
[21] GNU Project. 2020. GNU Binutils. https://www.gnu.org/software/binutils.
[22] Google. 2018. syzkaller – kernel fuzzer. https://github.com/google/syzkaller.
[23] Google. 2020. Cloud TPU: Empowering businesses with Google Cloud AI. https:
//cloud.google.com/tpu.
[24] Google. 2020. ClusterFuzz. https://google.github.io/clusterfuzz.
[25] Google. 2020. FuzzBench: Fuzzer benchmarking as a service. https://github.com/
google/fuzzbench.
Session 7B: FuzzingCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2226[26] Google. 2020. Honggfuzz. https://github.com/google/honggfuzz.
[27] Google. 2020. OSS-Fuzz - Continuous Fuzzing for Open Source Software. https:
//github.com/google/oss-fuzz.
[28] Google Project Zero. 2020. WinAFL. https://github.com/googleprojectzero/
winafl.
[29] Matthew R. Guthaus, James E. Stine, Samira Ataei, Brian Chen, Bin Wu, and
Mehedi Sarwar. 2016. OpenRAM: An Open-Source Memory Compiler. In Pro-
ceedings of the 35th International Conference on Computer-Aided Design (ICCAD).
[30] IBM. 2016. IBM z13 Technical Guide. https://www.redbooks.ibm.com/redbooks/
pdfs/sg248251.pdf.
[31] Intel. 2011. Intel® 64 and ia-32 architectures software developer’s manual. Volume
3B: System programming Guide, Part 2 (2011).
[32] Intel. 2011. Intel BTS: Real time instruction trace. https://www.intel.com/content/
dam/www/public/us/en/documents/reference-guides/real-time-instruction-
trace-atom-reference.pdf.
[33] Intel. 2013. Intel processor trace decoder library. https://github.com/intel/libipt.
https:
[34] Intel. 2020.
10th Generation Intel Core Processor Families.
//www.intel.com/content/www/us/en/products/docs/processors/core/10th-
gen-core-families-datasheet-vol-1.html.
[35] Intel. 2020. 11th Generation Intel Core Processor (UP3 and UP4). https://cdrdv2.
intel.com/v1/dl/getContent/631121.
[36] James R. 2013. Processor Tracing. https://software.intel.com/content/www/us/
en/develop/blogs/processor-tracing.html.
[37] Simon Kagstrom. 2015. Kcov is a FreeBSD/Linux/OSX code coverage tester.
https://github.com/SimonKagstrom/kcov.
[38] Michael Kan. 2021.
Intel to Build Chips for Other Companies With New
Foundry Business. https://in.pcmag.com/processors/141636/intel-to-build-chips-
for-other-companies-with-new-foundry-business.
[39] Sagar Karandikar, Howard Mao, Donggyu Kim, David Biancolin, Alon Amid,
Dayeol Lee, Nathan Pemberton, Emmanuel Amaro, Colin Schmidt, Aditya Chopra,
Qijing Huang, Kyle Kovacs, Borivoje Nikolic, Randy Katz, Jonathan Bachrach, and
Krste Asanović. 2018. FireSim: FPGA-accelerated Cycle-exact Scale-out System
Simulation in the Public Cloud. In Proceedings of the 45th Annual International
Symposium on Computer Architecture (ISCA ’18).
[40] George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei, and Michael Hicks. 2018.
Evaluating Fuzz Testing. In Proceedings of the 25th ACM Conference on Computer
and Communications Security (CCS). Toronto, ON, Canada.
[41] lafintel. 2016. LAF LLVM Passes. https://gitlab.com/laf-intel/laf-llvm-pass.
[42] Caroline Lemieux and Koushik Sen. 2018. FairFuzz: A targeted mutation strat-
egy for increasing greybox fuzz testing coverage. In Proceedings of the 33rd
IEEE/ACM International Conference on Automated Software Engineering (ASE).
Corum, France.
[43] LLVM Project. 2020. libFuzzer - a library for coverage-guided fuzz testing. https:
//llvm.org/docs/LibFuzzer.html.
[44] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:
building customized program analysis tools with dynamic instrumentation. Acm
sigplan notices 40, 6 (2005), 190–200.
[45] Chenyang Lyu, Shouling Ji, Chao Zhang, Yuwei Li, Wei-Han Lee, Yu Song, and
Raheem Beyah. 2019. {MOPT}: Optimized mutation scheduling for fuzzers. In
Proceedings of the 28th USENIX Security Symposium (Security). Santa Clara, CA.
[46] Valentin Manes, Soomin Kim, and Sang Kil Cha. 2020. Ankou: Guiding Grey-box
Fuzzing towards Combinatorial Difference. In Proceedings of the 42th International
Conference on Software Engineering (ICSE). Seoul, South Korea.
[47] Microsoft Security Response Center (MSRC). 2020. OneFuzz. https://github.com/
microsoft/onefuzz.
[48] Stefan Nagy and Matthew Hicks. 2019. Full-speed fuzzing: Reducing fuzzing over-
head through coverage-guided tracing. In Proceedings of the 40th IEEE Symposium
on Security and Privacy (Oakland). San Francisco, CA.
[49] Anh-Quynh Nguyen and Hoang-Vu Dang. 2014. Unicorn: Next Generation CPU
Emulator Framework. In Black Hat USA Briefings (Black Hat USA). Las Vegas,
NV.
[50] Nvidia. 2020. NVIDIA DRIVE AGX ORIN: Advanced, Software-Defined Platform
for Autonomous Machines. https://www.nvidia.com/en-us/self-driving-cars/
drive-platform/hardware/.
[51] Van-Thuan Pham, Marcel Bohme, Andrew Santosa, Alexandru Caciulescu, and
Abhik Roychoudhury. 2019. Smart Greybox Fuzzing. In IEEE Transactions on
Software Engineering.
[52] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,
and Herbert Bos. 2017. Vuzzer: Application-aware evolutionary fuzzing. In Pro-
ceedings of the 2017 Annual Network and Distributed System Security Symposium
(NDSS). San Diego, CA.
[53] Sergej Schumilo, Cornelius Aschermann, Robert Gawlik, Sebastian Schinzel, and
Thorsten Holz. 2017. KAFL: Hardware-assisted feedback fuzzing for OS kernels.
In Proceedings of the 26th USENIX Security Symposium (Security). Vancouver, BC,
Canada.
[54] SiFive Inc. 2017. The RISC-V Instruction Set Manual. https://riscv.org//wp-
content/uploads/2017/05/riscv-spec-v2.2.pdf.
[55] J. E. Stine, I. Castellanos, M. Wood, J. Henson, F. Love, W. R. Davis, P. D. Franzon,
M. Bucher, S. Basavarajaiah, J. Oh, and R. Jenkal. 2007. FreePDK: An Open-
Source Variation-Aware Design Kit. In 2007 IEEE International Conference on
Microelectronic Systems Education (MSE’07).
[56] Synopsys. 2020. DC Ultra. https://www.synopsys.com/implementation-and-
signoff/rtl-synthesis-test/dc-ultra.html.
[57] Cisco Talos. 2014. AFL-Dyninst: AFL fuzzing blackbox binaries. https://github.
com/Cisco-Talos/moflow/tree/master/afl-dyninst.
[58] TechPowerUp. 2020. RISC-V Processor Achieves 5 GHz Frequency at Just 1 Watt
of Power. https://www.techpowerup.com/275463/risc-v-processor-achieves-5-
ghz-frequency-at-just-1-watt-of-power.
[59] Renju Thomas, Manoj Franklin, Chris Wilkerson, and Jared Stark. 2003. Improv-
ing Branch Prediction by Dynamic Dataflow-based Identification of Correlated
Branches from a Large Global History. In Proceedings of the 30th ACM/IEEE
International Symposium on Computer Architecture (ISCA). San Diego, CA, USA.
[60] Tielei Wang, Tao Wei, Guofei Gu, and Wei Zou. 2010. TaintScope: A checksum-
aware directed fuzzing tool for automatic software vulnerability detection. In
Proceedings of the 31th IEEE Symposium on Security and Privacy (Oakland). Oak-
land, CA.
[61] Michal Zalewski. 2014. american fuzzy lop. http://lcamtuf.coredump.cx/afl/.
[62] Michal Zalewski. 2019. Fast LLVM-based instrumentation for afl-fuzz. https:
//github.com/google/AFL/blob/master/llvm_mode/README.llvm.
[63] Google Project Zero. 2020. TinyInst: A lightweight dynamic instrumentation
library. https://github.com/googleprojectzero/TinyInst.
[64] Gen Zhang, Xu Zhou, Yingqi Luo, Xugang Wu, and Erxue Min. 2018. PTfuzz:
Guided fuzzing with processor trace feedback. In IEEE Access (vol. 6).
[65] Jerry Zhao, Korpan Ben, Gonzalez Abraham, and Asanovic Krste. 2020. Sonic-
BOOM: The 3rd Generation Berkeley Out-of-Order Machine. In Fourth Workshop
on Computer Architecture Research with RISC-V.
Session 7B: FuzzingCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2227The finding generally aligns with that of the AFL whitepaper [62],
suggesting the performance gain of less than 10% for most binaries
other than CPU-bound benchmarks. The only exception occurs
when fuzzing strings (14.04%). This is because AFL’s feedback adopts
edge counters, driving the fuzzer to to search for longer inputs with
more printable strings, while the gain is magnified due to more
iterations and branch encounters consequentially. Thus, given the
relative edges over AFL-gcc (Figure 8 and Figure 10) and the posing
overhead on the SPEC benchmarks (Table 4 and Table 1), we would
expect SNAP to outperform AFL-clang on the RISC-V platform with
higher fuzzing throughput.
Figure 10: The average execution speed from fuzzing with AFL-gcc
and AFL-clang-fast for 12 hours across the Binutils binaries. The
numbers below the bars of AFL-gcc show the number of executions per
second for the mechanism.
A APPENDIX
A.1 AFL throughput on x86 platforms
Although the fuzzing throughput from AFL-clang on the RISC-V
platform is left out due to technical difficulties, a similar comparison
for the numbers on x86 platforms is gathered instead. In particular,
we compile the Binutils binaries through AFL-gcc and AFL-clang,
and conduct five consecutive fuzzing runs of 12 hours to reduce the
statistical noise. Figure 10 shows that AFL-clang takes consistent
advantage of the compiler-based optimizations over AFL-gcc, which
manually instruments at the assembly-level, and outperforms in all
evaluating cases by an average of 6.96% faster execution speed.
cxxﬁltnmobjdumpreadelfsizestringsstrip0.91.01.11.2ThroughputImprovement(X)5.06%7.10%4.04%4.32%6.97%14.04%7.19%(1718)(972)(941)(1112)(932)(171)(932)AFL-gccAFL-clang-fastSession 7B: FuzzingCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2228