--AaB03x
Content-Disposition: form-data; name="submit-name"
Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain
... contents of file1.txt ...
--AaB03x--
```
## 缓存
实现方法：
- 代理服务器缓存
- 客户端缓存
### 缓存控制
#### 禁止对响应进行缓存
```html
Cache-Control: no-store
```
#### 强制确认缓存
只有当客户端确认缓存资源有效时，才能使用这个响应
```html
Cache-Control: no-cache
```
- must-revalidate和proxy-revalidate
must-revalidate表示在资源过期后，一定需要从服务器中进行获取 proxy-revalidate用于提示代理、CDN等设备资源过期后的缓存行为
#### 禁止修改
```http
Cache-Control: no-transform
```
禁止代理服务器修改HTTP响应头或者响应体
#### 私有缓存
只能单独给用户使用，一般用在浏览器
```html
Cache-Control: private
```
#### 公共缓存
可以被多个用户使用，一般存储在代理服务器中
```html
Cache-Control: public
```
#### 客户端缓存新鲜度限制
- max-stale: 提供一个秒为单位的数字 代表这段时间内缓存不能过期
- min-fresh: 后续跟随一个以秒为单位的数字，用于建议服务器能返回一个不少于该时间的缓存资源
- only-if-cached: 表示客户端要求不发送网络请求，只使用缓存来进行响应
#### HTML的HTTP-EQUIV
可以控制服务器解析这个标签 然后将这个标签里的添加到首部响应返回给客户端
### 缓存验证
#### If-None-Match
ETag 是资源的唯一标识
```http
If-None-Match: "82e22293907ce725faf67773957acd12"
```
如果服务器接收到ETage后，判断资源没有发生改变，会返回一个304
弱验证器：
```http
If-None-Match: W/"82e22293907ce725faf67773957acd12"
```
弱验证器当文件内容发生变化后，缓存也不会失效
#### If-Modified-Since
Last-Modified 首部字段也可以用于缓存验证，如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文
![缓存验证-新鲜度检测](/assets/屏幕截图%202022-01-13%20174058.png)
### 缓存过期
出现在响应报文，超过这个时间 缓存就被认为过期
```html
Cache-Control: max-age=31536000
```
Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期
```html
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```
但Expires有如下问题：
1. 受限于客户端的时间
2. 无法缓存客户私有资源
3. 无法描述“不缓存”，如js文件引用后面要加个版本号
#### 试探性过期
对于没有提供max-age跟Expires的响应
- 许久不修改的 最近也认为不怎么修改
- 最近修改的 最近修改的可能性更大
## 通信数据转发
### 代理
目的：
- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录
![代理流量获取](/assets/屏幕截图%202022-01-06%20174916.png)
#### 正向代理
用户可以察觉正向代理的存在
```mermaid
sequenceDiagram
  客户端 ->> 代理: 请求
  代理 ->> 服务端: 请求
  服务端 ->> 代理: 响应
  代理 ->> 客户端: 响应
```
#### 反向代理
反向代理一般位于内部网络中，用户察觉不到
```mermaid
sequenceDiagram
  客户端 ->> 代理: 请求
  opt 内部网络
    代理 ->> 服务端: 请求
    服务端 ->> 代理: 响应
  end
  代理 ->> 客户端: 响应
```
#### 客户端代理配置
- 手动配置代理服务器地址及端口
- [PAC](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling/Proxy_Auto-Configuration_PAC_file) 自动代理配置 通过一段js脚本确定一个url要以怎样的方式使用什么代理访问
- WPAD 代理发现 自动发现PAC并进行下载然后为请求使用代理
#### 有关代理的一些问题
- 客户端向代理发送请求时 需要在HTTP请求消息里面包含完整的URI信息 这样代理服务器才知道要转发到哪里
```http
GET http://baidu.com HTTP/1.0
```
- 如果代理接收到的URI不完整 也可以通过Host确定
#### 报文追踪
- Via首部
```http
Via: [  "/" ]   [ ":"  ]
```
![经过多层代理 通过Via标识](/assets/屏幕截图%202022-01-07%20172607.png)
每经过一层代理，代理都可以向该字段加入自己的标识 在多层代理的情况下，通过检查这个字段有没有自己，可以检测环路，该字段与Server的区别在于Server是源服务器信息，代理不应修改
- TRACE
![TRACE流程](/assets/屏幕截图%202022-01-07%20173637.png)
通过指定Max-Forwards头部 每经过一层代理该值就会减1 当为0时，及时当前服务器不是源服务器，也必须马上将结果返回给客户端
#### 认证
- Proxy-Authenticate 首部
#### 兼容性
为了保证代理的兼容性，代理对于不认识的首部，必须原样转发，并且首部的顺序，也不能随意修改
### 网关
网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务
### 隧道
使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路
```mermaid
sequenceDiagram
  客户端->>隧道网关: CONNECT请求 CONNECT baidu.com:888 HTTP/1.0
  隧道网关->>客户端: HTTP/1.0 407 Proxy authentication required
  客户端->>隧道网关: CONNECT带上凭证
  隧道网关->>baidu.com: 打开888端口连接
  baidu.com->>隧道网关: 连接已建立
  隧道网关->>客户端: 连接就绪 HTTP/1.0 Connection established
  客户端->>隧道网关: 非HTTP流量
  隧道网关->>baidu.com: 非HTTP流量
  baidu.com->>隧道网关: 非HTTP流量
  隧道网关->>客户端: 非HTTP流量
```
### 中继
- 由于HTTP的连接管理，单纯的盲中继可能会出现连接管理上的问题
```mermaid
sequenceDiagram
    客户端->>中继: 二进制流A
    中继->>目标服务器: 二进制流A
    目标服务器->>中继: 二进制流B
    中继->>客户端: 二进制流B
```
## 重定向原理
当服务端对客户端进行重定向时，会设置一个Location响应头，并将状态码设置为302
客户端（浏览器）接收到这样的响应之后，就会跳转到Location里面的网址
## HTTPS
### HTTP的问题
- 明文通信
- 无法确认通信方
- 无法验证报文完整性
### 原理
1. 客户端向服务端发送HTTPS请求
2. 服务端收到HTTPS请求返回公钥证书
3. 客户端收到服务端的公钥证书，验证是否有效（验证颁发机构、过期时间等等）
4. 如果有效，生成一个随机数用公钥加密，然后发送给服务端
5. 服务端使用私钥将该随机数解密，然后用该随机数作为密钥加密一串字符给客户端
6. 如果客户端解密这串字符成功，这串字符将作为接下来客户端与服务端通信的密钥
这个过程的关键在于密钥传递使用了非对称加密，数据传输采用了对称加密
所以这就保证了对称加密的密钥不会通过网络直接传输，之所以数据传输采用了对称加密，主要是因为非对称加密性能很低
#### SSL记录
![屏幕截图 2022-06-13 210046](/assets/屏幕截图%202022-06-13%20210046.png)
#### 握手
在初始阶段会进行协商选择对称加密算法来进行加密会话密钥，同时为了防止中间人篡改选择的对称加密算法，客户端在服务端完成会话密钥的校验后，还需要发送所有握手报文的一个MAC，服务端再回送一个MAC
#### 挥手
基于SSL的加密不断单纯地发送一个FIN关闭底层TCP连接，这是因为可能会被中间人伪造一个FIN，从而破坏数据的完整性，而是需要通过SSL记录的类型字段来确定是否关闭
### 证书
通过使用 证书 来对通信方进行认证
数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构
服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起
#### 证书信任链
![20231018163340](/assets/20231018163340.webp)
TLS 证书都有签名部分，这个签名就是用签发者的私钥加密的, 客户端的 Trust store 里就有这个 CA 的公钥（在 CA 证书里），会使用证书指定的散列算法计算出证书的散列值，然后用这个公钥去尝试解开签名，解开的结果如果跟散列值一样，就说明这张叶子证书确实是这个 CA 签发的。
用 根证书的公钥 去 解密验证 上一层证书的合法性，再拿上一层证书的公钥去验证更上层证书的合法性；递归回溯。最后验证服务器端的证书是可信任的
### 完整性保护
SSL 提供报文摘要功能来进行完整性保护
CA将用户的个人身份跟公开密钥链接在一起 可以防抵赖
通过操作系统内置的证书 可以在不通过网络的情况下对证书进行认证
TLS1.3 只允许前向加密（PFS）的密钥交换算法，主要是为了防止黑客取得了服务端私钥，并且抓取了历史上的 TLS 密文，那么就可以用这个私钥和抓包文件，把这些 TLS 会话的对称密钥给还原出来，前向加密算法每次的私钥都不一样
### HTTPS的缺点
- 加解密有性能损失
- 证书授权需要高额费用