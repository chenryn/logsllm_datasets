of indices [ma] = {1,··· ,|y|} and [mb] = {1,··· ,|x|}.
2. Preparing circuit randomness: Bob generates random seeds {ρ(j)}j∈[σ] for generating the circuits and sends
them to Cloud.
Phase 2: Input commitments
1. Committing to Bob’s inputs: For each circuit j ∈ [σ], input bit i ∈ [mb], and b ∈ {0, 1} Bob uses ρ(j) to
i,b . These keys will later be generated by Cloud to commit to the input wire labels
generate commitment keys θ(j)
corresponding to Bob’s input. Bob then commits to his own inputs as {Γ(j)}j∈[σ] as:
using independently generated random commitment keys γ(j)
ment keys {γ(j)
i }i∈[mb],j∈[σ] to Cloud.
i
Γ(j) = {com(θ(j)
i,xi
; γ(j)
i
)}i∈[mb]
. Bob sends {Γ(j)}j∈[σ] to Alice and the commit-
2. Committing to Cloud’s inputs: To allow for a fair release of the outputs, the cloud inputs one-time pads
to blind both parties’ outputs. Cloud randomly generates pa ∈ {0, 1}|fa| and pb ∈ {0, 1}|fb|, as well as
rc ∈ {0, 1}2k+log(k) as its input to the 2-universal circuit. We denote Cloud’s input as z = pa(cid:107)pb(cid:107)rc, and the
indices of Cloud’s input wires as [mc] = {1,··· ,|z|}.
For each circuit j ∈ [σ] and input bit i ∈ [mc], Cloud uses {ρ(j)}j∈[σ] to generates the garbled input wire keys
i ∈ {0, 1}. To locate the correct key
(K (j)
i,b , b ⊕ π(j)
for bit b on input wire wi of circuit j, we designate the label W (j)
Let {wma+i}i∈[mc] be the input wires for Cloud. Cloud then commits to the label pairs for its input wires as
{Ψ(j)}j∈[σ], where
i,1 ∈ {0, 1}k and the permutation bit π(j)
i,b = (K (j)
), where K (j)
i,0 , K (j)
).
i,0 , K (j)
i,1 , π(j)
i
i
Ψ(j) = {com(W (j)
ma+i,0⊕π(j)
com(W (j)
ma+i,1⊕π(j)
; ψ(j)
i,0⊕π(j)
i
; ψ(j)
i,1⊕π(j)
i
),
)}i∈[mc]
i
i
using commitment keys ψ(j)
as:
i,b generated with the random seed ρ(j). Cloud then commits to its inputs as {Ξ(j)}j∈[σ]
using independently generated random commitment keys. Cloud sends {Ψ(j)}j∈[σ] and {Ξ(j)}j∈[σ] to Alice.
Ξ(j) = {com(ψ(j)
i,zi
; ξ(j)
i
)}i∈[mc]
6
Phase 3: Circuit construction
1. Constructing the objective circuit: Alice sends M to Cloud, then Alice and Cloud run a coin ﬂipping protocol
to randomly determine the 2-universal hash matrix H ∈ {0, 1}k×mb. These two matrices can be used to generate
the new circuit C that computes the function g : (x, y) → (⊥, (hb, hc, ca, cb)), where hb = H · x, hc =
H· z, gb = fb(x, M· y), cb = gb ⊕ e⊕ pb, ga = fa(x, M· y), and ca = ga ⊕ pa. Bob will need the values hc(cid:107)cb
to recover his output. We denote the set of indices corresponding to these values as Ob = {1,··· ,|hc| + |cb|}.
2. Committing to input and output wire label pairs: Using the same method as in Step 2, Cloud uses {ρ(j)}j∈[σ]
to generate the input wire keys for both Alice and Bob’s input as well as the output wire keys for Bob’s output
(these output keys must be committed for the witness indistinguishable proof of Bob’s output correctness). Let
{wi}i∈[mb] be the input wires for Bob, {wmb+i}i∈[ma] be the input wires for Alice, and {wi}i∈Ob. Cloud then
commits to the label pairs in Bob’s input, Alice’s input, and Bob’s Output as {Θ(j), Ω(j), Φ(j)}j∈[σ], where
Θ(j) ={com(W (j)
i,0⊕π(j)
i
; θ(j)
i,0⊕π(j)
; θ(j)
com(W (j)
Ω(j) ={com(W (j)
Φ(j) ={com(W (j)
i,1⊕π(j)
mb+i,0; ω(j)
i,0 ; φ(j)
i
i
i,1⊕π(j)
i ), com(W (j)
i
),
)}i∈[mb]
), com(W (j)
i,1 ; φ(j)
i
mb+i,1; ω(j)
i )}i∈Ob
i
)}i∈[ma]
using commitment keys generated with the random seed ρ(j). Cloud then sends these commitments to Alice.
Phase 4: Oblivious transfers
1. Oblivious transfers: The Cloud and Alice execute ma input oblivious transfers and σ circuit oblivious transfers
as follows:
(a) Input: For each i ∈ [ma], both parties run a(cid:0)2
(cid:1)-OT where Cloud inputs
1
(cid:17)
(cid:16){(W (j)
mb+i,0; ω(j)
i
)}j∈[σ],{(W (j)
mb+i,1; ω(j)
i
)}j∈[σ]
while Alice inputs yi. Once Alice receives all of her garbled input wire labels, she uses the decommitment
keys obtained in the OTs to check the committed wire values in {Ω(j)}j∈[σ]. If any of the labels received
in the OT do not match the committed wire labels, Alice terminates the protocol.
(b) Circuit: Alice selects a set of circuits to be evaluated S ⊂ [σ] such that |S| = 2σ
j ∈ S and sj = 0 otherwise. Alice and Cloud perform σ(cid:0)2
5 , as in shelat and
Shen’s protocol [36]. She represents this set with a bit string s ∈ {0, 1}σ such that the jth bit sj = 1 if
(ρ(j), ({γ(j)
i }i∈[mc])), while Alice inputs sj. This allows Alice to learn either the random-
ness used to generate the check circuits or Bob and Cloud’s inputs for the evaluation circuits without the
cloud knowing which circuits are being checked or evaluated.
(cid:1)-OTs where, for every j ∈ [σ], Cloud inputs
i }i∈[mb](cid:107){Ξ(j)
1
Phase 5: Evaluation
1. Circuit evaluation: Using ρ(j), Cloud garbles the objective circuit C as G(C)(j) for all j ∈ [σ] and pipelines
these circuits to Alice using Huang’s technique [14]. Depending on whether the circuit is a check circuit or an
evaluation circuit, Alice performs one of two actions:
(a) Check: For each j ∈ [σ]\S, Alice checks to see if ρ(j) can correctly regenerate the committed wire values
{Θ(j), Ω(j), Φ(j), Ψ(j)} and the circuit G(C)(j).
(b) Evaluate: For each j ∈ S, Alice checks that she can correctly decommit Bob’s input by recovering half of
Θ(j) from the keys committed in Γ(j). She does the same for Cloud’s input, recovering half of Ψ(j) from
the keys committed in Ξ(j)
If any of the above checks fail, Alice aborts the protocol. Otherwise, she evaluates the circuits {G(C)(j)}j∈[σ]\S.
Each circuit outputs the values (h(j)
b ) for j ∈ [σ]\S.
b , h(j)
c , c(j)
a , c(j)
7
Protocol
CMTB
Salus
Whitewash
Symmetric ops
|x|
5 (|x| + |y| + |f (x, y)|)
σ(|x| + 2
5|fb(x, y)|)
2σ
Asymmetric/group ops Oblivious transfers
k
-
-
coin toss
yes
yes
no
2σ
5 (|y| + 1)
-
-
Table 1: Operations required on the mobile device by three outsourcing protocols. Recall that k is the security
parameter, σ is the number of circuits generated, x is the mobile device’s input, and y is the application server’s input.
2. Majority output selection and consistency check: Let (hb, hc, ca, cb) be the output of the majority of the
b = hb
c = hc for all j ∈ [σ]\S. If any of Bob or Cloud’s hashed input values do not match, Alice aborts the
evaluated circuits. If no majority value exists, Alice aborts the protocol. Otherwise, she checks that h(j)
and h(j)
protocol.
Phase 6: Output proof and release
1. Proof of output authenticity: Alice and Bob perform the proof of authenticity from shelat and Shen’s pro-
tocol [37] using the commitments to Bob’s output wires {Φ(j)}j∈[σ]\S and the values hc(cid:107)cb which are to be
proven correct.
2. Output release: Cloud simultaneously releases the input one-time pads pa and pb to Alice and Bob. Alice and
Bob then hash the pads and check to see if the hash values output by the circuit hc = H · pa(cid:107)pb. If the hashes do
not match, Alice and Bob abort the protocol. Otherwise, Alice receives ca ⊕ pa as her output and Bob receives
cb ⊕ pb ⊕ e as his output.
5 Comparison with previous outsourcing protocols
In this section, we compare the asymptotic complexity and security guarantees of the Whitewash protocol to two
previous outsourcing techniques: the protocol developed by Carter et al. [6], which we call “CMTB” for the remainder
of this work, and the Salus framework developed by Kamara et al. [21].
5.1 Comparison to CMTB
The underlying two-party computation protocols of Whitewash and CMTB follow similar structures in terms of the
security checks that are performed. However, the KSS protocol, which underlies CMTB, uses a number of algebraic
operations to perform input consistency checks and output proofs of consistency. The protocol developed by shelat and
Shen [37], which underlies Whitewash, removes these expensive cryptographic primitives in favor of constructions that
use only efﬁcient, symmetric-key operations. In addition to the improvements to the underlying protocol, Whitewash
outsources the generation side of two-party computation, while CMTB outsources the evaluation side. In CMTB,
since neither the mobile device or the cloud could garble inputs before computation, a specially designed Outsourced
Oblivious Transfer (OOT) protocol is necessary to deliver the mobile device’s inputs to the evaluating cloud in a secure,
privacy-preserving manner. By swapping roles in the Whitewash protocol, we allow the mobile device to garble its
own inputs, removing the need for any oblivious transfer protocol to be performed from the mobile device. While
Whitewash still requires OTs between the cloud and the evaluating party, these operations can be parallelized, while
the OOT protocol acts as a non-parallelizable bottleneck in computation.
5.1.1 Asymptotic Complexity
When examining the complexity of each protocol, our main goal is to optimize the efﬁciency on the mobile device.
Thus, we examine the number of operations each protocol requires on the mobile device itself. Table 1 shows this
complexity for both Whitewash and CMTB. Note that for the mobile device, Whitewash requires signiﬁcantly more
symmetric key operations for garbling its own input and verifying the correctness of its output. By contrast, the OOT
protocol in CMTB requires very few symmetric key operations, but requires several instantiations of an oblivious
transfer. In addition, CMTB requires that the mobile device check the application server’s input consistency and verify
the correctness of the output using algebraic operations (e.g., modular exponentiations and homomorphic operations).
8
Considering the fact that modular exponentiation is signiﬁcantly more costly than symmetric key operations, removing
these public key operations from the phone is a signiﬁcant efﬁciency improvement for Whitewash. We also note that
CMTB requires a two-party fair coin toss at the mobile device, which is not required by Whitewash.
5.1.2 Security Guarantees
The removal of the OOT protocol in Whitewash not only increases its efﬁciency when compared to CMTB, it also
allows for stronger security guarantees. In CMTB, security was only possible if none of the parties collude, since the
mobile device possessed information that would allow the Cloud to recover both input wire labels for all of the mobile
input wires after the OOT. If the mobile device and cloud collude in the Whitewash protocol, it simply removes the
guarantee of fair release and makes the protocol equivalent to the underlying two-party computation protocol. Thus,
the only guarantee lost is that of fair release at the end of the protocol, since a colluding mobile device and cloud may
not release the one-time pad used to blind the evaluating party’s output. We believe that this represents a more realistic
security setting, since the mobile device is paying for the assistance of the Cloud and may collude.
5.2 Comparison to Salus
When considering the operations performed on the mobile device, the Salus protocol and the Whitewash protocol
both make the mobile device responsible for generating circuit randomness and garbling its own inputs. However,
the Whitewash protocol requires an added proof of output consistency that is not included in Salus. While this proof
adds some complexity to the protocol, it allows Whitewash to handle functions where both parties get different output
values, while Salus is designed to handle functions with a single, shared output value. In addition, the Whitewash
protocol outsources the generation of the garbled circuit, while the malicious secure Salus protocol outsources the
evaluation. By swapping the roles of the outsourced task and adding in consistency checks at the evaluating party, the
Whitewash protocol guarantees security in a stronger adversarial model.
5.2.1 Asymptotic Complexity
Table 1 shows the number of operations performed on the mobile device for both Salus and Whitewash. Both proto-
cols use only efﬁcient, symmetric key operations, but there is a slight tradeoff in the number of operations required.
5 evaluated circuits, but requires those operations for each bit of both party’s
Salus only requires operations for the 2σ
inputs and the shared output. By contrast, Whitewash requires that the mobile device’s input be committed for all σ
circuits generated, but then only requires correctness proof of the output wires on the 2σ
5 evaluated circuits. When the
application server’s input is signiﬁcantly longer than the mobile device’s, this will cause the Salus protocol to be less
efﬁcient than Whitewash. However, in the average case where both inputs are approximately the same length, this will
mean that Whitewash requires more operations. This small tradeoff in efﬁciency is justiﬁed by the fact that Whitewash