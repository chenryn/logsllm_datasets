Figure 2: Exponentiation routines of Go and Crypto++ and gcrypt. For the corresponding exponent encoders ğ‘“ğ‘¤(Â·), see the full
version [15]. For pointers to the original source code, see Footnotes 6 and 9 and 11.
We provide a pseudo-code version of the crucial parts of Goâ€™s
EA in Figure 2 (left), where lines 1â€“2 implement phase (1), lines 3â€“4
implement phase (2), and lines 5â€“14 implement phase (3). Note that
we outsource the derivation of the exponent encoding (ğ‘’1, . . . , ğ‘’ğ¿),
i.e., the conversion of the exponent to the RR and the encoding of
the latter, to the function ğ‘“ğ‘¤ invoked in line 4. The only properties
of this function that are relevant for our description and attack are
that the exponent ğ‘¥ can be uniquely recovered from (ğ‘’1, . . . , ğ‘’ğ¿) and
that for all ğ‘’ğ‘– we have 0 â‰¤ ğ‘’ğ‘– < 2ğ‘¤. (For reference, we reproduce
the details of function ğ‘“ğ‘¤ in the full version [15].)
Given the above description, the computation steps indicated
in Figure 2 (left) should be self-explanatory. Note that lines 8â€“10
compute ğ‘… â† ğ‘…2ğ‘¤ , with the ğ‘– â‰  1 condition in line 9 arranging
for a little speed-up in the very first iteration (in which ğ‘… = 1 by
line 6).
The attack condition in Goâ€™s EA is clearly visible in the pseudo-
code: If we assume that in each iteration of line 12 the table index ğ‘’ğ‘–
leaks to the adversary, then the latter can readily recover the ex-
ponent ğ‘¥. In Section 6.3 we show how to do this in practice. The
attack condition can be removed by implementing line 12 specif-
ically such that index ğ‘’ğ‘– is not leaked.8 Notationally, in a secure
implementation we would specify line 12 as â€˜Securely ğ‘Š â† ğ‘‡ [ğ‘’ğ‘–]â€™.
5.3 Comb-based Exponentiation
Exponentiations ğ‘… â† ğµğ‘¥ in Crypto++9 are computed, given a
parameter ğ‘¤, using a comb-based algorithm by (1) tabulating a set
8If just this countermeasure is applied, the length of the encoding, which might convey
non-trivial information about the exponent, would still leak.
9The code is available at https://github.com/weidai11/cryptopp/blob/45de5c6c/algebra.
cpp#L255-L314
of initial values that depend solely on ğ‘¤; (2) encoding an ODR Î“ =
(ğ›¾ğ‘™ , . . . , ğ›¾0) of the exponent ğ‘¥ into a sequence (ğ‘’1, . . . , ğ‘’ğ¿) (the latter
merely consists of relabelling the coefficients); and (3) combining
the results of (1) and (2) in an online phase.
We provide a pseudo-code version of the crucial parts of
Crypto++â€™s EA in Figure 2 (center), where lines 15â€“16 implement
phase (1), lines 17â€“18 implement phase (2), and lines 19â€“29 im-
plement phase (3). Note that we outsource the derivation of the
exponent encoding (ğ‘’1, . . . , ğ‘’ğ¿), i.e., the conversion of the expo-
nent to the ODR and the encoding of the latter, to the function ğ‘“ğ‘¤
invoked in line 18. The only properties of this function that are
relevant for our description and attack are that the exponent ğ‘¥ can
be uniquely recovered from (ğ‘’1, . . . , ğ‘’ğ¿) and that for all ğ‘’ğ‘– we have
ğ‘’ğ‘– âˆˆ {0}âˆª{1, 3, . . . , 2ğ‘¤ âˆ’1}. (For reference, we reproduce the details
of function ğ‘“ğ‘¤ in the full version [15].)
Given the above description, the computation steps indicated in
Figure 2 (center) should be self-explanatory. (For further details on
the mechanics of comb-based exponentiation, see [23, Sect. 14].)
The attack condition in Crypto++â€™s EA is clearly visible in the
pseudo-code: If we assume that each execution of line 22 leaks to
the adversary whether the condition is fulfilled, and further each
execution of line 23 leaks the table index ğ‘’ğ‘– to the adversary, then
the latter can readily recover the exponent ğ‘¥. In Section 6 we expose
how to do this in practice.
Note that eliminating the attack condition is less immediate
than in Section 5.2. One promising option would be to introduce
an auxiliary (dummy) register ğ‘‡ [0] (initialized in line 16 together
with the other registers), and to replace lines 22,23 by the single
instruction â€˜Securely ğ‘‡ [ğ‘’ğ‘–] â† ğ‘‡ [ğ‘’ğ‘–] Â· ğ»â€™ that implements the table
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2072accesses (read and write) and the multiplication without leaking
the index ğ‘’ğ‘–.10
5.4 Sliding Window Exponentiation
Exponentiations ğ‘… â† ğµğ‘¥ in gcrypt11 are computed, given a pa-
rameter ğ‘¤, using a sliding-window algorithm by (1) precomputing
and tabulating a set of values that depend solely on ğ‘¤ and base
element ğµ; (2) encoding an ODR Î“ = (ğ›¾ğ‘™ , . . . , ğ›¾0) of the exponent ğ‘¥
into a sequence (ğ‘’0, ğ‘1, ğ‘’1, ğ‘2, ğ‘’2, . . . , ğ‘ğ¿, ğ‘’ğ¿, ğ‘ğ¿+1); and (3) combining
the results of (1) and (2) in an online phase. The encoding in step (2)
requires that ğ›¾ğ‘™ = 1 be the leading coefficient of Î“12 and is such
that the sub-sequence (ğ‘’0, ğ‘’1, . . . , ğ‘’ğ¿) coincides with the support
(ğ›¾ ğ‘—) ğ‘—:ğ›¾ ğ‘— â‰ 0 of Î“ (i.e., the set of non-zero elements; note here we have
ğ‘’0 = ğ›¾ğ‘™ = 1, and for all ğ‘’ğ‘– we have ğ‘’ğ‘– âˆˆ {1, 3, . . . , 2ğ‘¤ âˆ’ 1}), and the
values ğ‘1, ğ‘2, . . . , ğ‘ğ¿+1 correspond with the lengths of the vanish-
ing subsequences of Î“ (i.e., the contiguous runs of zero elements).
Precisely, the encoding is such that
ğ¿âˆ‘ï¸
ğ‘–=0
ğ‘¥ =
2Â¯ğ‘ğ‘– ğ‘’ğ‘– where âˆ€ğ‘– : Â¯ğ‘ğ‘– = ğ‘ğ‘–+1 + . . . + ğ‘ğ¿+1 .
(1)
We provide a pseudo-code version of the crucial parts of gcryptâ€™s
EA in Figure 2 (right), where lines 30â€“31 implement phase (1),
lines 32â€“33 implement phase (2), and lines 34â€“44 implement phase (3).
The function ğ‘“ğ‘¤ in line 33 computes the exponent encoding
(ğ‘’0, ğ‘1, ğ‘’1, ğ‘2, ğ‘’2, . . . , ğ‘ğ¿, ğ‘’ğ¿, ğ‘ğ¿+1) as follows: it sets ğ‘’0 = 1 then loops
between: (a) advancing through the bit sequence of ğ‘¥ (from most
to least significant bit) until it encounters a bit set to 1, and (b)
greedily outputting the largest possible pair (ğ‘ğ‘–, ğ‘’ğ‘–) subject to ğ‘’ğ‘– âˆˆ
{1, 3, . . . , 2ğ‘¤ âˆ’ 1}. We reproduce the pseudocode of function ğ‘“ğ‘¤ in
the full version [15].
Given the above description, the code in Figure 2 (right) should
be mostly self-explanatory, with the exception of lines 37â€“40 which
require further explanation: The code is functionally equivalent
with â€˜For ğ‘— â† 1 to ğ‘ğ‘–: ğ‘… â† ğ‘… Â· ğ‘…â€™ (similarly to lines 41â€“43) followed
by â€˜ğ‘… â† ğ‘… Â· ğ‘‡ [ğ‘’ğ‘–]â€™, but the implementation reduces side-channel
leakage by hiding for each multiplication whether the factor ğ‘Š is ğ‘…
or ğ‘‡ [ğ‘’ğ‘–], and, in the latter case, which index ğ‘’ğ‘– is used for the table
look-up.13 That is, in contrast with the cases of Go and Crypto++,
the EA of gcrypt is specifically designed to offer side-channel
resilience.
Despite its built-in protection measures, we identify a side-channel
condition in gcryptâ€™s EA that can lead to full exponent recovery.
(In Section 6.2 we demonstrate that the attack is indeed practi-
cally exploitable.) The root of the problem is that the algorithm
implements the sliding-window exponentiation method. Intuitively,
this method covers the digits of the bit-representation of the ex-
ponent ğ‘¥ with a sequence of ğ‘¤-wide non-overlapping windows
such that every 1-bit of the exponent is covered by a window and
10If just this countermeasure is applied, the length of the encoding, which might convey
non-trivial information about the exponent, would still leak.
11The code is available at https://github.com/gpg/libgcrypt/blob/ccfa9f2c/mpi/mpi-
pow.c#L393-L772
12Every integer ğ‘¥ â‰¥ 1 has at least one, but often multiple, ODRs with leading coeffi-
cient 1. The gcrypt implementation cannot handle the ğ‘¥ = 0 case.
13Precisely, line 39 implements the instruction â€œIf ğ‘— â‰¤ ğ‘ğ‘– then ğ‘Š â† ğ‘…; else, if
ğ‘— = ğ‘ğ‘– + 1, then ğ‘Š â† ğ‘‡ [ğ‘’ğ‘– ]â€ but ensures that it neither leaks which if-branch is
taken nor what the value of ğ‘’ğ‘– is.
conditioned on this the number of windows is minimized. In Equa-
tion (1), value ğ¿ corresponds with the number of windows used
for this, any coefficient Â¯ğ‘ğ‘– corresponds with the position of the ğ‘–-th
window, and any coefficient ğ‘’ğ‘– encodes the ğ‘¤ exponent bits that
the ğ‘–-th window covers. In the EA implementation, processing a
window corresponds with a multiplication ğ‘… â† ğ‘… Â· ğ‘‡ [ğ‘’ğ‘–] while
bridging a gap between two windows corresponds with a sequence
of squaring operations ğ‘… â† ğ‘… Â· ğ‘…. These operations are jointly
implemented in lines 39,40, and each iteration of the loop of line 36
processes one gap-window pair.
The approach of our side-channel attack is to closely monitor the
execution of line 36: The number of iterations of the loop during
one exponentiation immediately reveals the encoding length ğ¿, and
the time taken for the ğ‘–-th iteration is, by line 38, linear in ğ‘ğ‘– + 1 and
thus leaks, one by one, the coefficients ğ‘1, . . . , ğ‘ğ¿.14 Finally, we can
recover coefficient ğ‘ğ¿+1 by similarly monitoring the loop of line 42.
That is, if (ğ‘’0, ğ‘1, ğ‘’1, . . . , ğ‘ğ¿, ğ‘’ğ¿, ğ‘ğ¿+1) = ğ‘“ğ‘¤(ğ‘¥) is the encoding of
exponent ğ‘¥ then our measurements reveal all the ğ‘ğ‘– components
while, for now, the ğ‘’ğ‘– components remain hidden.
Before moving on to assessing the options for amplifying the
extracted information towards recovering the full exponent, let us
make a final observation on gcryptâ€™s EA. Recall that line 39 tries to
hide not only the table index ğ‘’ğ‘– but also whether the multiplication
in line 40 is with ğ‘‡ [ğ‘’ğ‘–] or ğ‘…. However, as our method recovers the
coefficients ğ‘ğ‘– straightaway, and exclusively the last iteration of the
loop of line 38 will perform a multiplication with ğ‘Š = ğ‘‡ [ğ‘’ğ‘–] (rather
than with ğ‘Š = ğ‘…), line 39 de facto just hides the ğ‘’ğ‘– coefficients.
Thus, replacing lines 38â€“40 by the instructions â€˜For ğ‘— â† 1 to ğ‘ğ‘–:
ğ‘… â† ğ‘… Â· ğ‘…â€™ followed by â€˜Securely ğ‘… â† ğ‘… Â· ğ‘‡ [ğ‘’ğ‘–]â€™ would result in
code that is equivalent from a security perspective yet simpler and
more efficient.15 We thus conclude that the authors of gcrypt were
likely not aware of the fact that the coefficients ğ‘1, . . . , ğ‘ğ¿+1 leak so
easily.
Now that we retrieve copies of the coefficients ğ‘1, . . . , ğ‘ğ¿+1, the
next subsections are dedicated to assessing the value of this infor-
mation towards an attack that recovers the full exponent.
observing that ğ‘› = ğ‘ğ‘– and is thus fully known. The sequence
5.4.1 Modelling the leakage. As a warm up, observe that when
ğ‘¤ = 1 the coefficients ğ‘ğ‘– leak the whole exponent, indeed all ğ‘’ğ‘– are
necessarily equal to 1 in this case. For larger values of ğ‘¤, however,
a search over the possible values of ğ‘’ğ‘– is necessary. Our goal here
is to quantify this partial leakage.
Letting ğ‘› + 1 = âŒˆlog2(ğ‘¥ + 1)âŒ‰ be the bit length of ğ‘¥, we start by
of ğ‘ğ‘–â€™s indicates the position of each ğ‘’ğ‘– in the binary writing of ğ‘¥,
and from the description of ğ‘“ğ‘¤ we know that ğ‘’ğ‘– is odd and ğ‘’ğ‘– <
min(2ğ‘¤, 2ğ‘ğ‘–), leaving us with min(ğ‘¤, ğ‘ğ‘–) âˆ’ 1 unknown bits in ğ‘’ğ‘–.
Note that there is no ğ‘’ğ¿+1 associated to ğ‘ğ¿+1, which indeed leaks the
number of trailing zeros of ğ‘¥. Thus, the total number of unknown
14This argument assumes that multiplications and squarings require uniform time.
This is the case for the gcrypt routines.
15The performance gain comes from the possibility of removing some of the decoy
code required for securely implementing line 39. For further details, see the source
code.
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea20730
1
0
0
1
0
0
1
1
1
1
0
0
1
1
Figure 3: Finite state machines describing ğ‘“ğ‘¤ for ğ‘¤ = 1 (left)
and ğ‘¤ = 2 (right).
window width
2
3
4
5
states
8
24
64
160
ğœ‡
7/24
7/16
341/640
925/1536
ğœ2
0.058449
0.098632
0.126731
0.145411
Table 1: Per bit statistics of the entropy ğ»ğ‘¤(ğ‘¥) as ğ‘› â†’ âˆ for
different values of the window width ğ‘¤.
ğ¿âˆ‘ï¸
ğ‘–=1
bits of ğ‘¥, which we shall call the entropy of ğ‘¥, is exactly
ğ»ğ‘¤(ğ‘¥) =
(min(ğ‘ğ‘–, ğ‘¤) âˆ’ 1).
(2)
Given â„, â„ğ‘¥ and the leakage for ğ‘¥, it the computational effort for
finding ğ‘¥ grows exponentially with ğ»ğ‘¤(ğ‘¥). We will analyze this
cost precisely in Section 5.4.2. The value ğ»ğ‘¤(ğ‘¥) depends on ğ‘¥, on
the window size ğ‘¤, and on the algorithm ğ‘“ğ‘¤ used for the encoding.
We are thus interested in estimating statistics on ğ»ğ‘¤(ğ‘¥) for secrets
ğ‘¥ of ğ‘› bits. To this end, we model the encoding function ğ‘“ğ‘¤ as a
Markov process, and use standard theorems on Markov chains to
deduce statistics on ğ»ğ‘¤(ğ‘¥) as ğ‘› â†’ âˆ.
Model ğ‘¥ as a continuous stream of independent and uniformly
distributed bits. For any fixed ğ‘¤, the leakage of the encoding ğ‘“ğ‘¤ is
described by a finite state machine outputting the per-coefficient
entropy min(ğ‘¤, ğ‘ğ‘–) âˆ’ 1 whenever it passes through a set of dis-
tinguished states. Figure 3 shows the machines for ğ‘¤ = 1 and
ğ‘¤ = 2. Circles represent ordinary states and squares represent dis-
tinguished ones. Solid arrows represent a transition associated to
reading a bit of ğ‘¥, with the read bit indicated next to the arrow.
Dashed arrows represent transitions which happen without read-
ing any bit from ğ‘¥, so called ğœ–-transitions. The starting node is the
one on top, although that is irrelevant for the modeling. The state
machine moves from one state to another as it progresses through
the bits of ğ‘¥; when it encounters a distinguished state it outputs
the entropy value represented in the node, modeling the leakage of
a value ğ‘ğ‘–. Both state machines in Figure 3 could be simplified, but
we prefer this larger presentation as it lends itself more easily to
generalization to any window size: a generalization of these state
machines to a value ğ‘¤ has ğ‘¤2ğ‘¤ states.
Before converting the state machine to a Markov chain, we first
need to get rid of the ğœ–-transitions, by replacing them with the
corresponding 0/1-transitions. This way, the number of states tra-
versed by the machine corresponds exactly to the bit length of the