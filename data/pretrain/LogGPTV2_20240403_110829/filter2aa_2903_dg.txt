格友评点
12.1.4 发货最多的图形处理器
根据ARM院士Jem Davies在2016年8月所做演讲中的数据[4]，2012
年到2015年，Mali GPU的发货数量分别是1.5亿、4亿、5.5亿和7.5亿。
该报告和ARM官网都把Mali GPU称为世界上发布最多的GPU。
在PC的鼎盛时代，英特尔的GPU曾也这样宣传过，如今时过境迁
了。
这样的第一有意思吗？
{格友再评} 有意思，妙不可言呢。
12.1.5 精悍的团队
在发货量世界第一的GPU后面，是一支很精悍的开发团队。2014年
7月，团队的总人数不到500[1]。其中主要的力量在英国的剑桥和挪威的
特隆赫姆，前者是ARM的大本营，后者是上文提到的ARM挪威，Mali
GPU的诞生地和初生摇篮。在瑞典隆德也有一个精悍的Mali GPU团队，
2016年，大约有百人，担负着广泛的任务，包括硬件设计和验证、GPU
建模、编译器、多媒体开发和软硬件测试等。
12.1.6 封闭的技术文档
从公开的技术文档数量和深入程度来看，在本书介绍的几个GPU厂
商中，ARM算是最保守和封闭的，超过Nvidia。在Mali GPU的开发资源
网页（见Arm Developer网站）中，没有指令集和寄存器这样的深层次
文档，也没有系统介绍内部架构。目前可以看到的信息或浮于表面，或
流于粗略。
导致上述现象的原因与SoC GPU的行业背景有关。在PC GPU领
域，因为丰富的应用和高度的定制化需求，几家厂商已经认识到了开放
的必要性和长久价值，整个行业形成了较好的开放传统。而SoC GPU则
不然，早期产品大多使用在固定功能的环境中，即使后来用在智能手机
和平板电脑中，但是与PC比较，还是相对单一和封闭的。从宏观上
看，SoC GPU的发展路线与PC GPU大体相同，但进度是落后一大截
的。以GPU的四大类应用为例，显示、2D/3D加速、媒体三大功能在
SoC GPU上已经相对成熟，通用计算功能还处于发展初期。简言之，与
PC GPU相比，SoC GPU上的应用环境相对封闭，应用模式相对单一，
因此顶层软件对底层硬件的灵活性需求也较少。这导致SoC GPU的厂商
觉得没有必要公开硬件细节，只要公开API就行了。但从PC GPU的经验
来看，这样做会使上层软件与底层硬件产生隔阂，“你不懂我”“我也不
懂你”，时间长了，隔阂越来越大，造成恶性循环，最后结果可想而
知。
12.1.7 单元化设计
与AMD的多引擎设计思想类似，ARM的GPU团队把所有任务分成
三个大的单元，分别称为GPU、VPU（Vedio Processing Unit，视频编解
码）和DPU（Display Processing Unit，显示处理单元）。本书只介绍3D
图形和通用计算的GPU部分。
12.2 Midgard微架构
Midgard是使用 “统一核心”（Unified Cores）设计思想的第一代Mali
GPU微架构，于2010年公布，至今还没有退役。在三星公司的多款猎户
座（Exynos）SoC和华为的麒麟950 SoC中，都集成了Midgard架构的
GPU。
12.2.1 逻辑结构
Midgard架构支持1～16个通用着色器核心。图12-2是较高层次的
Midgard架构逻辑框图。图中主体部分是16个着色器核心。其中，第1个
着色器核心的外框为实线，表示至少包含一个着色器核心，其他着色器
核心的外框为虚线，表示它们是可选的。着色器核心上面是硬件实现的
任务管理逻辑，用来分发计算任务，也称为作业管理器（job
manager）。
图12-2 Midgard微架构逻辑框图
图12-2的下面两层是两组AMBA总线接口和二级缓存，用于访问内
存和与系统接口。它们上面是内存管理器，三者一起为着色器核心提供
高速的数据访问服务。内存管理器上面是高级图块（tile）处理单元。
图块是图形处理领域的常用术语，一般是指屏幕或者一个显示平面内的
一小块矩形区域。在Mali GPU中，一直有按图块做3D渲染的传统，称
为基于图块渲染（tile-based rendering）[5]，这样做的好处是减少访问显
存的次数，降低功耗。
12.2.2 三流水线着色器核心
接下来，我们把目光聚焦到每个着色器核心的内部。
图12-3是Midgard架构的着色器核心框图，图中画了 4 条执行流水
线（pipeline），从右到左分别是：一条纹理流水线、一条加载和存储
流水线、两条算术流水线。一共4条流水线，分为3种类型。算术流水线
简称A流水线（A-pipeline），负责所有算术处理。加载/存储流水线简
称LS流水线（LS-pipeline），负责读写内存，执行插值操作，以及读写
图像数据。纹理流水线简称T流水线（T-pipeline），只负责访问只读的
纹理数据或者对纹理数据做各种处理。
在Midgard的设计中，算术流水线的数量是可以配置的，可以为一
条或者多条。比如在Mali-T720和Mali-T820中只有一条，在Mali-T880中
有三条，其他的Midgard GPU中都有两条[6]。
图12-3 Midgard架构的三流水线着色器核心示意图
因为在一个核心中配备了三类功能的流水线，所以ARM给这个着
色器核心取了个简单的名字，叫三流水线着色器核心（Tri Pipeline
Shader Core）。其实这个名字是容易误解的，因为数字三代表三类，不
是三个，实际上是2 + n结构。这种2 + n结构其实与AMD在Terascale微
架构中使用的4 + 1结构很类似。
在图12-3中，4条流水线上方的矩形代表线程发射设施，下方代表
线程完成设施。在有些介绍中，把前者称为线程池（thread pool），把
后者称为线程老化（thread retire）（单元），图12-4便是这样。该图是
根据ARM官方的技术资料[6]重新绘制的三流水线示意图，包含了流水线
外的接口结构。
图12-4 包含接口信息的三流水线着色器核心
图12-4的中心部分是三条执行流水线，左侧画了对两种不同任务做
预处理的设施，上面一排用于处理图块任务，从左到右依次如下所示。
图块列表读取器（tile list reader），用于读取要处理的图块。
光栅器（rasterizer），负责把图元信息转化为像素信息。
早期深度和模板（stencil）测试器（early ZS tester），目的是及早
排除不需要渲染的任务。
片段线程产生器（fragment thread creator），片段着色（fragment
shade）是OpenGL定义的渲染流水线中的一个阶段，相当于像素渲
染。这个线程产生器用于产生像素级别的渲染任务（线程）。
图12-4左下角的箭头代表顶点渲染任务，把该任务送给“顶点线程
产生器”，后者把要执行的任务分解成较小粒度的操作，放入线程池
中。
图12-4右侧的4个矩形描述的是渲染结果经过“后期深度和模板测试
器”（Late ZS Tester），抛弃被遮挡的无用像素后，经过混合器写到图
块内存（Tile Memory）。
12.2.3 VLIW指令集
如前所述，ARM公司没有公开Mali GPU的指令集，包括Midgard架
构。但是在多个文档中都明确说了Midgard使用的是SIMD（单指令多数
据）风格的指令。在Midgard的每条算术流水线中，包含多个算术单
元，根据公开的性能指标，很可能是5个。
在每个算术单元中（见图12-5），SIMD寄存器的宽度为128位，可
以容纳4个单精度浮点数（FP32）或者32位整数（I32）、8个半精度浮
点（FP16）或者短整数（I16）。每个算术单元内包含一个向量乘法器
（VMUL）、一个向量加法器、一个支持复杂浮点操作和函数的
VLUT、一个标量加法器（SADD）和一个标量乘法器（SMUL）。
图12-5 Midgard架构的算术单元
Midgard的指令属于VLIW（Very Long Instruction Word）风格，属
于VLIW-5，其中，5代表内部算术单元的个数。这意味着每一条指令内
部可以包含5条并行指令，每一条又可以处理多个数据项。以32位浮点
为例，理想情况下，一个ALU可以在一个时钟内同时执行如下17次浮点
操作。
VLUT执行点乘操作，包含4次乘法操作和3次加法操作。
VMUL执行4次乘法操作。
VADD执行4次加法操作。
SADD和SMUL各执行1次标量操作。
这样加起来，便是17次浮点操作。按此计算，对于频率为600MHz
的Mali-T760，每个核心有两个算术流水线，因此就是每秒34次浮点运
算，乘以16个核心是每秒544次浮点运算，再乘以600M便是每秒326400
次浮点运算，这与宣传的326 FP32 GFLOPS基本一致。
根据FreeDesktop组织的逆向研究结果[7]，Midgard指令的长度至少
是4个字（word），而且都是4个字的整数倍。
每条指令的最低4位代表当前指令的类型，接下来的4位代表下一条
指令的类型，供指令预取（prefech）设施使用。以下是常用指令类型的
编码、简要描述和指令长度（见括号中文字）。
3——Texture（4个字）
5——Load/Store（4个字）
8——ALU（4个字）
9——ALU（8个字）
A——ALU（12个字）
B——ALU（16个字）
值得说明的是，上面指令长度的字是32位，4字节，这意味着最短
的Midgard指令是16字节，最长的有64字节，真的是名副其实的
VLIW（非常长的指令字）。
12.3 Bifrost微架构
Midgard微架构的SIMD结构和VLIW指令代表它的设计思想是在指
令级别并行操作。这样的设计适合处理图形任务，编译器能容易地找到
可以并行的指令，执行时填满硬件流水线。但是对于通用计算任务来
说，编译器很难找到足够的可以同时并行的操作。为了解决Midgard微
架构的这个基本问题，Bifrost微架构应运而生。
基于Bifrost微架构的第一款GPU是Mali-G71，发布时间是2016年5
月，8个月后华为推出了使用Mali-G71的麒麟960 SoC。2017年5月，
ARM宣布了新一代基于Bifrost微架构的GPU，名为Mali-G72 [8]。
12.3.1 逻辑结构
Bifrost微架构支持1～32个着色器核心，其逻辑结构如图12-6所示。
与Midgard的逻辑结构（见图12-2）相比，二者的关键变化在着色器核
心上。
图12-6下方的4组L2缓存中和4组AMBA 4 ACE中均有三组是虚线外
框，这表示它们是可选的，由芯片厂商根据访问内存的带宽需求来决
定。
图12-6 Bifrost微架构逻辑框图
12.3.2 执行核心
Bifrost的革新主要在着色器核心，有时也称为执行核心上。因为革
新的首要目标是支持通用计算任务，所以后一种叫法更合适一些。
图12-7是执行核心的逻辑框图，其中的三个执行引擎（execution
engine）取代了Midgard架构中的算术流水线。
图12-7 Bifrost的执行核心
值得说明的是，引擎这一术语在AMD GPU中代表的是较大范围的
功能单元，比如显示控制引擎（DCE）、视频编码引擎（VCE）等，而
在Bifrost中，其范围要小得多。计算机领域的引擎一词本来就是模糊词
汇，可大可小，大家不被误导就好。
每个执行核心中的执行引擎数量是可选的，可以为1或者多个，在
G71中是3个。这符合ARM一贯喜欢的弹性原则。
除了执行引擎之外，在执行核心中还有其他几个执行单元，比如，
在Midgard中就有的纹理单元和加载/存储单元。此外，还有用于各种插
值操作的异化单元（Varying Unit），ZS（深度和模板）测试和混合单
元，以及片段渲染结果老化单元（Fragment Retire）等。
12.3.3 标量指令集和Warp
与硬件结构变化配合，Bifrost的指令集也改变了，从VLIW风格的
SIMD指令变为标量指令。下面是一小段Bifrost架构的指令，来自ARM
院士Jem Davies在介绍Bifrost架构和Mali-G71的演讲资料[9]，用于解释
Bifrost引入的子句（clause）功能。
LOAD.32 r0, [r10]
FADD.32 r1,r0,r0
FADD.32 r2,r1,r1
FADD.32 r3,r2,r2
FADD.32 r4,r3,r3
FADD.32 r3,r3,r4
FADD.32 r0,r3,r3
STORE.32 r0, [r10]
因为目前ARM公开的工具中都没有反汇编功能，所以上面这段指
令也算是难得一见的Mali GPU指令。第一条指令加载数据从r10寄存器
所指向的内存读到寄存器r0。然后是多条加法指令，其中都有三个操作
数。最后一条指令把r0寄存器的内容写回r10寄存器指向的内存，所有指
令操作的都是32位浮点数，指令的助记符中以.32指示。从这几条指令
可以看出明显的标量特征，每条指令对单一的数据执行操作。
在把指令标量化的同时，Bifrost也引入了Warp概念，以Warp为单
位调度执行单元和算核函数。在图12-6中，执行引擎上方的Warp管理器
就是用来管理和调度线程的。以Warp方式调度标志着Mali GPU从
Midgard时代的指令级并行（Instruction Level Parallel，ILP）过渡到了线
程级并行（Thread Level Parallel，TLP）。时间上，刚好与G80相距10
年。
12.4 Mali图形调试器
Mali图形调试器（Mali Graphics Debugger，MGD）[10]是ARM公司
为Mali GPU开发的一个3D图形调试工具，有独立版本，也包含在DS-5