pieces that are equally the rarest, i.e., the pieces that have
the least number of copies in the peer set.
will be chosen only at the end of the content download when
there is no other pieces to download.
Due to space limitation, we just give our main conclusions.
For a detailed discussion on the last pieces problem, the
interested reader may refer to [19].
We never observed a last pieces problem on torrents in
steady state. However, we observed this problem on a few
torrents in transient state. We found that this problem is
inherent to the transient state of the torrent, and is not due
to the rarest ﬁrst algorithm. Moreover, the rarest ﬁrst algo-
rithm is eﬃcient at mitigating this problem by replicating
fast rare pieces once they become available.
It is important to study the piece interarrival time, be-
cause partially received pieces cannot be retransmitted by a
BitTorrent client, only complete pieces can. However, pieces
are split into blocks, which are the BitTorrent unit of data
transfer. For this reason, we have also evaluated the block
interarrival time. We identiﬁed a ﬁrst blocks problem. This
ﬁrst blocks problem results in a slow startup of the torrent,
which is an area of improvement for BitTorrent.
In conclusion, the last pieces problem is overstated, but
the ﬁrst blocks problem is underestimated and a possibility
of performance improvement.
4.1.4 Discussion on Rarest First and Network Cod-
ing
We have seen that rarest ﬁrst is an eﬃcient piece selection
strategy on the presented torrents. We have also shown that
the claimed deﬁciencies of rarest ﬁrst cannot be identiﬁed in
our experiments, or are the results of a misunderstanding of
the reason of piece scarcity for torrents in transient state.
However, this paper is not a case against solutions based
on source or network coding. Network coding enables a piece
selection strategy that is close to optimal in all cases, which
is not the case of rarest ﬁrst. Indeed, in speciﬁc contexts
like small outdegree constraint, or poor network connectivity
between cluster of peers, rarest ﬁrst will perform poorly. In
this study, we show that on real torrents in the Internet,
which have a large peer set of 80 and do not suﬀer from
connectivity problems, rarest ﬁrst performs very well.
In fact, rarest ﬁrst is close to a solution based on network
coding in the presented torrents. We consider two cases to
make the comparison: the steady and transient states. In
steady state, we have seen in section 4.1.2.2 that the entropy
of the presented torrents is close to one with rarest ﬁrst. An
entropy close to one means that each peer is interested in
each other peer in its peer set most of the time. As this is
close to the target of an ideal piece selection strategy, we see
that in steady state, the possibility of improvement for any
piece selection strategy in not signiﬁcant compared to rarest
ﬁrst. For this reason, we argue that a replacement of rarest
ﬁrst cannot be justiﬁed in the studied context. In transient
state, a solution based on network coding will enable the
initial seed to send one entire copy of the content faster
than in the case of rarest ﬁrst that may suﬀer from duplicate
pieces. The problem with rarest ﬁrst is that the number of
duplicate pieces will depends on the peer selection strategy.
Indeed, if the initial seed chooses the same set of peers to
upload the initial pieces to and that these peers are all in
the same peer set, then they will have the same view of
the rarest pieces, and they will download from the initial
seed an entire copy of the content without any duplicate
pieces. But, other peer selection policies may increase the
ratio of duplicate pieces before a ﬁrst copy of the content
is sent. There is no such a problem with network coding.
However, simple policies can be implemented to guarantee
that the ratio of duplicate pieces remains low for the initial
seed, e.g., the new choke algorithm in seed state or the super
seeding mode [3]. In this case, the beneﬁt of network coding
compared to rarest ﬁrst will not be signiﬁcant at the scale
of the content download.
Network coding appears as a solution more general than
rarest ﬁrst, as it works optimally in all cases. However, we
argue in favor of the simplicity of rarest ﬁrst. Network cod-
ing raises several implementation issues and is CPU inten-
sive. Rarest ﬁrst is simple, easy to implement, and already
widely used. We have seen that in a context of peer-to-
peer content replication with a large peer set and a good
network connectivity, rarest ﬁrst is a simple and very eﬃ-
cient solution. That is in this context that we argue that a
replacement of rarest ﬁrst cannot be justiﬁed.
4.2 Choke Algorithm
The choke algorithm is a peer selection strategy. It should
guarantee fairness and maximize the system capacity.
In
this section, we focus on the fairness issue, as the claimed
deﬁciencies of the choke algorithm are related to its fairness
properties. Whereas the evaluation and optimization of the
system capacity is an important issue, the choke algorithm is
indisputably an eﬃcient peer selection strategy that is used
by millions of persons. A detailed evaluation of the system
capacity reached with the choke algorithm is an interesting
area of future research.
4.2.1 Fairness Issue
Several recent studies [5, 10, 13, 15] challenge the fairness
properties of the choke algorithm because it does not im-
plement a bit level tit-for-tat, but a coarse approximation
based on short term download estimations. Moreover, it is
believed that a fair peer selection strategy must enforce a
byte level reciprocation. For instance, a peer A refuses to
upload data to a peer B if the amount of bytes uploaded by
A to B minus the amount of bytes downloaded from B to
A is higher than a given threshold [5, 10, 15]. The rationale
behind this notion of fairness is that free riders should be
penalized, and reciprocation should be enforced. We call
this notion of fairness, tit-for-tat fairness.
We argue in the following that tit-for-tat fairness is not
appropriate in the context of peer-to-peer ﬁle replication.
A peer-to-peer session consists of seeds, leechers, and free
riders, i.e., leechers that never upload data. We consider
the free riders as a subset of the leechers. With tit-for-
tat fairness, when there is more capacity of service in the
torrent than request for this capacity, the excess capacity
will be lost even if slow leechers or free riders could beneﬁt
from it. Excess capacity is not rare as it is a fundamental
property of peer-to-peer applications. Indeed, there are two
important characteristics of peer-to-peer applications that
tit-for-tat fairness does not take into account. First, leechers
can have an asymmetrical network connectivity, the upload
capacity being lower than the download capacity.
In the
case of tit-for-tat fairness, a leecher will never be able to use
its full download capacity even if there is excess capacity in
the peer-to-peer session. Second, a seed cannot evaluate the
reciprocation of a leecher, because a seed does not need any
piece. As a consequence, there is no way for a seed to enforce
tit-for-tat fairness. But, seeds can represent an important
part of a peer-to-peer session, see Table 1. For this reason,
it is fundamental to have a notion of fairness that takes into
account seeds.
In the following, we present two fairness criteria that take
into account the characteristics of leechers and seeds and the
notion of excess capacity:
(cid:129) Any leecher i with an upload speed Ui should get a
lower download speed than any other leecher j with
an upload speed Uj > Ui.
(cid:129) A seed should give the same service time to each
leecher.
With these two simple criteria, leechers are allowed to use
the excess capacity, but not at the expense of leechers with
a higher level of contribution. Reciprocation is fostered and
free riders are penalized. Seeds do not make a distinction
between contributing leechers and free riders. However, free
riders cannot compromise the stability of the system because
the more there are contributing leechers, the less the free
riders receive from the seeds.
Tit-for-tat fairness can be extended to evenly distribute
the capacity of seeds to peers in a torrent. With this exten-
sion, tit-for-tat fairness will verify our two fairness criteria.
However, in the context of peers with asymmetric capacity,
ﬁnding a threshold that maximizes the capacity of the sys-
tem is a hard task that is not yet solved in the context of
a distributed system. Moreover, using a default threshold
may lead to a high ineﬃciency of the system. We will see in
the following that the choke algorithm veriﬁes our two fair-
ness criteria with a simple distributed algorithm that does
not require the complex computation of a threshold.
To summarize the above discussion, tit-for-tat fairness is
not appropriate in the context of peer-to-peer ﬁle replication
protocols like BitTorrent. For this reason, we proposed two
new criteria of fairness, one for leechers and one for seeds.
It is beyond the scope of this study to perform a detailed
discussion of the fairness issues for peer-to-peer protocols.
Our intent is to give a good intuition on how a peer-to-peer
protocol should behave in order to achieve a reasonable level
of fairness.
In the following, we show on real torrents that the choke
algorithm in leecher state fosters reciprocation, and that the
new choke algorithm in seed state gives the same service time
to each leecher. We conclude that the choke algorithm is fair
according to our two new fairness criteria.
Contribution to the Amount of Uploaded Bytes, LS
1
o
i
t
a
R
0.5
5
10
15
0
0
Contribution to the Amount of Downloaded Bytes, L
1
25
20
o
i
t
a
R
0.5
0
0
5
10
15
Torrent ID
20
25
Figure 7: Fairness characterization of the choke algorithm
in leecher state for each torrent. Top graph: Amount of
bytes uploaded from the local peer to remote peers. We cre-
ated 6 sets of 5 remote peers each, the ﬁrst set (in black) con-
tains the 5 remote peers that receive the most bytes from the
local peer. Each next set contains the next 5 remote peers.
The sets representation goes from black for the set contain-
ing the 5 best remote downloaders, to white for the set con-
taining the 25 to 30 best downloaders. Bottom graph:
Amount of bytes downloaded from remote peers to the local
peer. The same set construction is kept. Thus, this graph
shows how much each set of downloaders, as deﬁned in the
top graph, uploaded to the local peer.
4.2.2 Leecher State
The choke algorithm in leecher state fosters reciprocation.
We see in Fig. 7 that peers that receive the most from the lo-
cal peer (top graph) are also peers from which the local peer
downloaded the most (bottom graph).
Indeed, the same
color in the top and bottom graphs represents the same set
of peers. All seeds are removed from the data used for the
bottom graph, as it is not possible to reciprocate data to
seeds. This way, a ratio of 1 in the bottom graph represents
the total amount of bytes downloaded from leechers.
Two torrents present a diﬀerent characteristic. The local
peer for torrent 19 does not upload any byte in leecher state
because due to the small number of leechers in this torrent,
the local peer in leecher state had no leecher in its peer
set. Torrents 5, which is in transient state, has a low level
of reciprocation. This is explained by a single leecher that
gave to the local peer half of the pieces, but who received few
pieces from the local peer. The reason is that this remote
leecher was almost never interested in the local peer. This
problem is due to the low entropy of the torrent in transient
state.
Because the choke algorithm takes its decisions based on
the current download rate of the remote peers, it does not
achieve a perfect reciprocation of the amount of bytes down-
loaded and uploaded. However, Fig. 7 shows that the peers
from which the local peer downloads the most are also the
peers that receive the most uploaded bytes. Thus there is
a strong correlation between the amount of bytes uploaded
and the amount of bytes downloaded.
The above results show that with a simple distributed
algorithm and without any stringent reciprocation require-
s
e
k
o
h
c
n
U
f
o
#
s
e
k
o
h
c
n
U
f
o
#
Correlation Unchoke and Interested Duration, LS
2000
4000
6000
8000
Correlation Unchoke and Interested Duration, SS
400
200
0
0
400
200
Contribution of Peers to the Amount of Uploaded Bytes, SS
1
0.8
0.6
0.4
0.2
n
o
i
t
u
b
i
r
t
n
o
C
d
a
o
p
U
l
0
0
1
2
4
Interested Time (s)
3
5
6
x 104
0
0
5
10
15
Torrent ID
20
25
Figure 8: Correlation between the number of unchokes and
the interested time for each remote peer for torrent 7. For
each remote peer, a dot represents the correlation between
the number of times this remote peer is unchoked by the
local peer and the time this remote peer is interested in the
local peer. Top graph: Correlation when the local peer
is in leecher state. Bottom graph: Correlation when the
local peer is in seed state.
Figure 9: Fairness characterization of the choke algorithm
in seed state for each torrent. Legend: We created 6 sets of
5 remote peers each, the ﬁrst set (in black) contains the 5
remote peers that receive the most bytes from the local peer.
Each next set contains the next 5 remote peers. The set
representation goes from black from the set containing the
5 best remote downloaders, to white for the set containing
the 25 to 30 best downloaders.
ments, unlike tit-for-tat fairness, one can achieve a good
reciprocation. More importantly, the choke algorithm in