件写数据就是希望数据通过网络设备发送出去，
我们知道UNIX的传统是Everything is a fle， IVO函数不仅用干读写常规文件,
用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，
备
比如终端或网络设备。
所以在用户空间开辟VO缓冲区还是必要的，
磁盘
printf, putchar, fputs
数。POSIX.1只定义接口而不定义实现，所以并不区分一个函数是库
函数接口，既包括C标准库函数，
容的发向发展。IEEE1003.1（也称为POSIX.1）定义了UNIX系统的
POSIX（Portable Operating System Interface）是由IEEE制定的标
关于UNIX标准 请点评
buffer
内核
终端
write
用户程序
而Unbuffered I/O函数是UNIX标准的一部分，
在读写设备时通常是不希望有缓冲的，
网络
例如Windows系统的底层是Win32APL，其中读写文件的系统
内核空间
用户空间
硬件
所L以C标准VO库函数在头文件
，也包括系统调用和其它UNIX库函
而不希望只写到缓冲区里就算完事儿了
 促进各种UNIX系统向互相兼
用C标准I/O库函数就比较方便，省去了自己
(Ub++)
例如向代表网络设备的文
在必要时需调
个用户空间的函数要慢很
函数，
，在所有支持C语言的
因为它们位于C标
也用于读写设
，标准I/Q库的
而只有
当
---
## Page 522
描述符表，其中每个表项包含一个指向已打开的文件的指针，如下图所示。
（PCB，Process Control Block）。task_struct中有一个指针指向files_struct结构体，称为文件
信息，称为进程描述符（Process Descriptor），
现在该说说文件描述符了。每个进程在Linux内核中都有一个task_struct结构体来维护进程相关的
W
2
图28.2
files_struct
使用UNIX这个商标。
容的。SUS标准由The Open Group维护，
完整实现了这些接口的系统称为XSl（X/Open System Interface）兼
要实现一部分在POSIX中规定为可选实现的接口，
可以声称自己是POSIX兼容的，然而要想声称自己是UNIX,
现的。有些非UNIX系统也实现了POSIX中必须实现的部分，
POSIX定义的接口有些规定是必须实现的，
接口的应用程序是不可移植的，但在Linux系统上运行效率很高。
所以能比较好地遵照POSIX标准实现，既有BSD的特性也有SYSV的
全从头编写的，并不继承BSD或SYSV的源代码，
TO部分可以看出来一个函数接口属于哪种情况。Linux的源代码是完
的pthread库就属于这种情况）
些接口借鉴BSD的，
编程接口是基于STREAMS的TLI。POSIX在统一接口的过程中，有
在UNIX的发展历史上主要分成BSD和SYSV两个派系，
了UNIX系统的基本特性。
令、帐号和权限以及系统管理的基础知识，
样。IEEE 1003.2定义了Shell的语法和各种基本命令的选项等。
函数还是系统调用，
tty
特性，
自BSD也不是来自SYSV，
中实现
一部分在POSIX中规定为可选实现的接口在SUS中规定为必须实现
多不同的接口，
，此外还有一些Linux特有的特性，
home/akaedu/foo.txt
由操作系统的开发者决定.
比如BSD的网络编程接口是socket，
，至于哪些函数在用户空间实现，哪些函数在内核
有些接口借鉴SYSV的，
而是凭空发明出来的（例如本书要讲
，通过Man Page的COMFORMING
，而在操作系统理论中称为进程控制块 
各种UNIX系统都不太-
—
，比如epoll(7)，
 该组织拥有UNIX的注册商
，而另外一些是可以选择实
，这些内容合在一起定义
也顺带讲解Shell、基本命
 还有些接口既不是来
这由另外一个标
没有历史的包袱,
而SYSV的网络
，各自实现了很
依赖于这些
还必须
那么也
本
2
---
## Page 523
而C标准库的IO缓冲区则不具有这一特性（想一想为什么）。
可能写到内核I/O缓冲区中,
层，但在write的底层也可以分配一个内核I/O缓冲区,
[36] 事实上Unbuffered I/O这个名词是有些误导的，
的rILE结构体中。头文件unistd.h中有如下的宏定义来表示这三个文件描述符：
分别用rILE*指针stdin、stdout和stderr表示。这三个文件的描述符分别是0、1、2，保存在相应
我们知道，程序启动时会自动打开三个文件：标准输入、标准输出和标准错误输出。在C标准库中
给read或write，内核根据文件描述符找到相应的表项，
件描述符表项中的指针指向新打开的文件。当读写文件时,
当调用open打开一
1. 汇编程序的Hello world
王日
页
#define STDERR FILENO
#define STDIN_FILENO O
于开的文件在内核中用什么结构体表示.
用户
性
一个文件或创建一
不能直接访可内核中的文件描述符表，
至于究竟写到了文件中还是内核缓冲区中对于进程来说是没有差别
一个新文件时，
全国嵌入式人才培训基地
起始页
内核分配一
我们将在下一
，虽然write系统调用位于C标准库I/O缓冲区的底
 所以write也不一定是直接写到文件的，
 再通过表项中的指针找到相应的文件。
 用户程序把文件描述符传 
一个文件描述符并返回给用户程序，该文
(File Descriptor)
而只能使用文件描述符表的索引
一章详细介绍.
目前我们
 3. open/close
523
下一页
也
---
## Page 524
以下可选项可以同时指定0个或多个，
必选项：以下三个常数中必须指定一个，且仅允许指定一个。
pathname参数是要打开或创建的文件名，
最后的可变参数可以是0个或1个，由flags参数中的标志位决定，
以这些常数的宏定义都以o_开头，表示or。
数是这样声明的：
在Man Page中open函数有两种形式，
介绍一部分，
3. open/close 请点评
pen函数可以打开或创建一个文件。
·O_APPEND 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不覆
一页
O_TRUNc 如果文件已存在，并且以只写或可读可写方式打开，则将其长度截断
O_EXCL 如果同时指定了o_CREAT，并且文件已存在，则出错返回。
问权限。
_cREAT 若此文件不存在则创建它。使用此选项时需要提供第三个参数mode，表示该文件的访
盖原来的内容。
LQ_RDWR 可读可写打开
O_WRONLY 只写打开
O_RDONLY只读打开
（Truncate）为o字节。
SRTSUT
int
int open(const char *pathname,
#include
char
*pathname
和必选项按位或起来作为flags参数。可选项有很多，这里只
，一种带两个参数，
全国嵌入式人才培训基地
第 28章文件与IVO
 3. open/close 
 可以同时选择多个常数用按位或运算符连接起来，
int
int
 flags);
一种带三个参数，
，见下面的详细说明。
，其实在C代码中open函
524
下一页
---
## Page 525
后在Shell中运行并查看结果：
现在我们自己写一个程序，
是0666和0777呢？我们可以把Shell进程的umask改成0，再重复上述实验：
我们看到的都是被umask掩码修改之后的权限，那么如何证明touch或gcc创建文件的权限本来应该
是0777&~022=0755。
同样道理，
最终的文件权限是0666&~022=0644。
用touch命令创建一个文件时，创建权限是0666，
补充说明一下Shell的umask命令。Shell进程的umask掩码可以用umask命令查看:
由open的mode参数和当前进程的umask掩码共同决定。
第三个参数mode指定文件权限，
注意open函数与C标准I/O库的fopen函数有些细微的区别:
·以可写的方式fopen］
·O_NONBLOCK 对于设备文件，
·以w或w+方式fopen一个文件时，如果文件已存在就截断为0字节，而open一个文件时必须明确
指定o_TRUNC才会截断文件，否则直接在原来的数据上改写。
定o_CREAT才会创建文件，否则文件不存在就出错返回。
塞I/O在下-
SS
-rw-rw-rw- 1 akaedu akaedu 0 2009-03-08 15:09 file123
S
s
SS
$ umask
-rwxrwxrwx 1
S
0022
./a.out
umask 022
rwxr-xr-x
，用gcc编译生成一个可执行文件时，创建权限是0777，而最终的文件权限
rw-r-
1s
touch
touch
umask 0
ls
n
-1
一节详细讲解。
a.out
fil
file123 
a.out
 akaedu akaedu 6483 2009-03-08 15:09 a.out
. akaedu akaedu 6483 2009-03-08 15:07 a.out
akaedu akaedu 0 2009-03-08 15:07 file123
一个文件时，
，可以用八进制数表示，
，以o_noNBLock方式打开可以做非阻塞I/O（Nonblock I/O），非阻
，如果文件不存在会自动创建，
，详见open(2)的Man Page。要注意的是，文件权限
而touch进程继承了Shell进程的umask掩码，所以
，比如0644表示-rw-r--r--,
建，而open一个文件时必须明确指
也可以
---
## Page 526
2. C标准I/O库函数与Unbuffered I/O函
2、请按照下述要求分别写出相应的open调用。
是什么效果？为什么必选项只能选一
1、在系统头文件中查找flags 和mode参数用到的这些宏定义的值是多少。把这些宏定义按位或起来
习题 请点评
个文件中了。后面要讲的dup2函数提供了另外一种办法在指定的文件描述符上打开文件。
由open返回的文件描述符一定是该进程尚未使用的最小描述符。
关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。
所有文件。但是对于-
文件描述符调用close关闭,
参数fa是要关闭的文件描述符。需要说明的是,
close函数关闭一个已打开的文件:
码？这些问题将在第1节“引言"解释。
被Shell启动的进程可以继承Shell进程的umask掩码？为什么umask命令可以读写Shell进程的umask掩
不出所料,
数
候标准输出就不再是终端，而是-
二一页
一点在标准输入、标准输出或标准错误输出上打开一
·打开文件/home/akae.txt用于写操作，如果该文件已存在则报错退出，如果该文件不存在则
·打开文件/home/akae.txt用于写操作，如果该文件不存在则创建它
·打开文件/home/akae.txt用于写操作，以追加方式打开
创建它
则创建它
打开文件/home/akae.txt用于写操作，如果该文件已存在则截断为0字节，如果该文件不存在
$ ls -l somefile
#include 
-rw-r--r--
文件somefile的权限是0664&~022=0644。有几个问题现在我没有解释：为什么
 1 akaedu akaedu 6483 2009-03-08 15:11 somefile
一个长年累月运行的程序（比如网络服务器）
一个常规文件了，
一个而可选项可以选多个？
全国嵌入式人才培训基地
起始页
上一级
当一个进程终止时，
再调用printf就不会打印到屏幕上，而是写到这
一个新文件，
 在终止时内核也会自动关闭它打开的
，由于程序启动时自动打开文件描述
 实现重定向的功能。例如，首
打开的文件描述符一定要记得
，内核对该进程所有尚未关闭的
4. read/write
下一页
526
，这时
洗
---
## Page 527
现在明确一下阻塞（Block）这个概念。当进程调用一个阻塞的系统函数时，
写常规文件时，write的返回值通常等于请求写的字节数count，而向终端设备或网络写则不一定。
write函数向打开的设备或文件中写数据。
据到达就一直阻塞在那里。同样，
接收到数据包，
读则不一定，
读常规文件是不会阻塞的，
读到的字节数（返回值）会小于请求读的字节数count，例如：
示出错）
示有符号的size-,
参数count是请求读取的字节数，
read函数从打开的设备或文件中读取数据。
4. read/write 请点评
（Sleep）状态，这时内核调度其它进程运行，直到该进程等待的事件发生了（比如网络上接收到
中记录的读写位置是1024，
的
·读常规文件时，
：fgetc有可能从内核中预读1024个字节到I/O缓冲区中，
而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。
面socket编程部分会详细讲解。
从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数，后
从终端设备读，通常以行为单位，读到换行符就返回了。
：成这的数，
#include 
。read函数返回时，
#include  
末
尾，
如果从终端输入的数据没有换行符,
则这次read返回o
，调用read从网络读就会阻塞，
成功返回读取的
，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而
这样既可以返回正的字节数、〇（表示到达文件末尾）也可以返回负值-1（表
不管读多少字节，
，返回值说明了buf中前多少个字节是刚读上来的。有些情况下，实际
，读上来的数据保存在缓冲区buf中，
 写常规文件是不会阻塞的，而向终端设备或网络写则不一定。
全国嵌入式人才培训基地
第28章文件与VO
下次read将返回0。
告
 4. read/write
，至于会阻塞多长时间也是不确定的，
，read一定会在有限的时间内返回。从终端设备或网络
调用read读终端设备就会阻塞，
 size_t count);
再返回第一个字节，
，如果在调read之前已到达文件
 这个读写位置是记在内核中
同时文件的当前读写位置向后
 该进程被置于睡眠
 这时该文件在内核
如果一直没有数
如果网络上没有
527
表
---
## Page 528
第一次执行a.out的结果很正常，而第二次执行的过程有点特殊，现在分析一下:
执行结果如下:
数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行。
下面这个小程序从终端读数据再写回终端。
（Running）状态，在Linux内核中，处于运行状态的进程分为两种情况：
3．a.out进程打印并退出，
1．Shell进程创建a.out进程，a.out进程开始执行，而Shell进程睡眠等待a.out进程退出。
·正在被调度执行。CPU处于该进程的上下文环境中，
现执行不了，没有d这个命令。
是读走了终端设备输入缓冲区中剩下的字符d和换行符，把它当成一条命令解释执行，结果发
符，剩下的字符仍然保存在内核的终端设备输入缓冲区中。
顾用户体验，不能让和用户交互的进程响应太慢。
就绪状态。
行情况动态调整它的优先级和时间片，
那么该调度谁执行呢？内核的调度算法是基于优先级和时间片的，而且会根据每个进程的运
写该进程的地址空间。
令地址，
例 28.2.阻塞读终端
进程，
bash:
hello
所以该进程在-
inelude 
，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，正在读
int main(void)
#include
，该进程不需要等待什么事件发生，
command not found
return 0;
write(STDOUT_FILENO, buf, n);
int
char buf[10];
<utdiib.h
一个就绪队列中等待被内核调度。
 这时Shell进程恢复运行，
 read(STDIN_FILENO, buf, 10);
，直到终端设备输入了换行符才从read返回，read只读走10个字
exit(1);
 perror("read STDIN_FILENO");
，让每个进程都能比较公平地得到机会执行，同时要兼
，随时都可以执行,
，Shell继续从终端读取用户输入的命令，
，程序计数器（eip）里保存着该进程的指
 系统中可能同时有多个就绪的进程，
。与睡眠状态相对的是运行
但CPU暂时还在执行另一
528
---
## Page 529
有o_NONBLOCK标志。所以就像例28.2“阻塞读终端”一样，
做这个实验。程序开始执行时在0、1、2文件描述符上自动打开的文件就是终端，但是没
以下是一个非阻塞I/O的例子。
塞等待的超时时间，从而圆满地解决了这个问题。
这样做的问题是，
以免做太多无用功，在延迟等待的时候可以调度其它进程执行。
会在一个while循环中一直不停地查询（这称为TightLoop）
阻塞在那里，操作系统可以调度别的进程执行，
非阻塞I/O有一个缺点，
设备2有数据到达也不能处理，使用非阻塞I/O就可以避免设备2得不到及时处理。
如果read(设备1)是阻塞的，那么只要设备1没有数据到达就会一直阻塞在设备1的read调用上，即使
塞在这里死等，这样可以同时监视多个设备：