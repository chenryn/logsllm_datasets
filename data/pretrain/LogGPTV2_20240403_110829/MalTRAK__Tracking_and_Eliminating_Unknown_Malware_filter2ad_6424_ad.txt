modiﬁed or deleted, the framework within the call-chain hooks for
these functionalities, in kernel-mode employs the logic as shown
in Figure 6a in order to determine the mapping. We assume that
the object (ﬁlesystem or conﬁguration) that is being accessed is
x. Similary, in user-mode the framework employs the logic as
Oy
shown in Figure 6b. Similar logic is employed when a ﬁlesystem
or conﬁguration object is read, in order to determine the sibling
mappings.
We treat kernel-mode and user-mode seperately. The idea is
that within kernel mode all modules are always visible to them-
selves and every process. Thus, we need to distinguish between re-
quests that came from kernel-mode versus request that came from
user-mode which included the kernel-mode point in the call-chain.
We do so using the ExGetPreviousMode windows kernel function
which returns the previous operating mode of the processor. We
make use of the fact that a caller cannot call from the kernel pre-
tending to be from user as that would break the existing implemen-
tation of Windows OS kernel.
4.3
Intercepts
Before we discuss our implementation of intercepts, a few
words regarding how the Windows kernel is structured is in order.
The Windows OS kernel is completely object based. Every ele-
ment from ﬁles to processes to buffers are all encapsulated in the
form of an object. Thus, for all ﬁles, directories, volumes etc, we
deal with the FILE OBJECT while for processes we deal with the
EPROCESS object and so on. The implementation of intercepts on
the Windows OS kernel consists of ﬁle system and registry (con-
ﬁguration) intercepts.
Filesystem Intercepts: A ﬁle system is implemented as a ﬁle
system driver within the Windows kernel. A FSD has entry points
which the Windows kernel invokes in response to a ﬁle access ei-
ther in user- or kernel mode. As an example, invoking Create-
File within user-mode ultimately translates to a IRP MJ CREATE
request at the FSD. These entry points are also called dispatch
317317
If (previousExecutionMode == KernelMode){    if (request came from allocated memory pool)        p(Oyx)= Fnm from CALLCONTEXT    else if (request came from module space)        p(Oyx) = Fnm of module image    else if (request came from core OS kernel and         no module  has been loaded after the framework)        p(Oyx) = Fnm of core OS kernel image    else if (request came from core OS kernel and        module has been loaded after the framework)        for (each loaded module)            p(Oyx) += Fnm of module image}    if (request came from allocated memory pool)        p(Oyx)= Fnm from CALLCONTEXT    else if (request came from dll that was created              and/or modified)        p(Oyx) = Fnm  of dll image    else if (request came from standard/system dlls){        if (code modified)            p(Oyx) = Fnm from CALLCONTEXT        else            p(Oyx) = Fnm  of dll image    }else if (request came from exeutable space)        p(Oyx) = Fnm  of executable image(a)(b)routines. Internally the windows kernel always uses I/O Request
Packets to describe any kind of request. Thus the FSD always
deals with I/O Request Packets for all ﬁlesystem operation. One
such information that can be found in the I/O Request Packet is the
FILE OBJECT of the corresponding ﬁle that is being operated on.
One approach to the implementation could simply change the
pointer for the driver dispatch routines to point to its own thereby
receiving control. However, due to the complexity of the FSD,
the parameters passed to these dispatch routines are not easy to
decipher. Instead, we chose to intercept at internal functions of
the FSD which accept reﬁned parameters which allow us to easily
map the ﬁle object that was being manipulated. At a ﬁrst glance it
might seem that this method is not portable, but in our experiment
we compared the two sample drivers provided in the windows ddk
with that of the ntfs driver debug symbols and found that the entry
points of the functionality we needed were common and took the
same parameters. We intercepted the Create, Open, Delete, Close,
QueryInfo and SetInfo dispatch routines in the FSD.
Registry Intercepts: Windows manages conﬁguration infor-
mation in what is called a registry. A registry is essentially a col-
lection of system speciﬁc ﬁles that store almost every piece of con-
ﬁguration information that is essential to the systems. Registry is
composed of hives and keys much like directory and ﬁles.
The windows registry is managed by the conﬁguration manager
which is a subsystem of the Windows kernel. The registry is stored
in memory and ﬂushed to disk periodically. However, these ﬂushes
to disk are made in a lazy fashion. which means that the copy on
the memory and on the disk at any given point are not guaranteed
to be exact, so we choose to intercept registry access in memory
since it ensures that the value written to and read from are the
same. We note that direct manipulation of the registry is not a pos-
sibility as the conﬁguration manager opens it at start and keeps it
open until Windows shuts down in exclusive mode. Further the or-
ganization of the registry is something that is not public and tech-
niques employing such direct access is going to break in imple-
mentation. The framework intercepts the CreateKey, DeleteKey,
Close, QueryKey and SetKey registry functions within the conﬁg-
uration manager, so that it gets control whenever the correspond-
ing registry operation is initiated.
Unlike current approaches which employ ﬁlter drivers or sys-
tem call table in order to monitor ﬁlesystem and conﬁguration
information, we employ redirection at the lowest possible level
within the OS kernel or the ﬁlesystem driver itself. By obtaining
control at the lowest possible level, we ensure that we always get
control and can never be bypassed easily.
4.4 DisInfection
The implementation of Disinfection consists of the implemen-
tation of alerts and the disinfection console.
4.4.1 Alerts
Alerts are implemented by hooking various systemOS kernel
points which can be used either directly or indirectly by a mal-
ware to infect a system. Figure 7 shows the scenarios and the OS
execution points that are redirected by the framework for Windows
XP SP2 OS in order to record alerts.
If an alert is conﬁgured to be passive, the framework simply
records it and proceeds with the ﬂow of execution. However, if the
alert is conﬁgured to be active, the framework delivers the alert to
Figure 7. Alerts: Aid the user in the selection of
a starting operation, whose effects are then auto-
matically eliminated by the framework
the disinfection console (see Section 4.4.2) via an Asynchronous
Procedure Call (APC) [24]. The user can then decide to continue
or abort the operation. Upon the delivery of the APC, the dis-
infection console then enters the framework via an IOCTL and
dequeues the spinlock that was held with the status of either con-
tinuing or abortting the operation. This scheme of using the APC
to communicate with the recovery console ensures that, if the sys-
tem entry point for an alert scenario is the FSD, no other ﬁlesystem
requests are initiated until the response from the disinfection con-
sole.
4.4.2 Disinfection Console
When the user wishes to disinfect an infected system, he/she uses
the disinfection console which then enters the framework into the
disinfection mode. In this mode, any context switching is disabled
and no operations are permitted on the system until disinfection
ﬁnishes.
The disinfection begins with the construction of active and
delete lists as explained in section . As the next step, the disin-
fection engine then sweeps through all the open ﬁle handles in the
running processes and builds a list of ﬁle handles that need to be
reopened when the system is switched to a different view. It then
deferences all the FILE OBJECTS associates with the ﬁle han-
dles thereby terminating all mappings with the FSD. The handles
themselves are not deleted. The recovery engine then scans the
recovery and delete lists to see if any process/thread that is depen-
dent on these lists is currently active in memory. The call-contexts
are used for this purpose. The disinfection engine then forcibly
tears down the process by sending it the terminate signal within
kernel-mode. The recovery engine then applies the recovery and
delete lists to the current view and moves the system into the de-
sired state. Finally the recovery engine creates a new mapping
for the FILE OBJECTS and the handles in the running processes,
enables interrupts and returns to the disinfection console. At this
point, the system has been disinfected.
5 Evaluation
This section presents a qualitative as well as a quantitative eval-
uation of our framework. The qualitative evaluation shows the
framework effectiveness in detecting and removing the effects of
malware, while the quantitative evaluation shows the framework
runtime cost to imperceptible.
Our testbed consisted of a clean system running Windows XP
SP2 on an Intel 3.2 GHz processor with 1GB of system memory
318318
and 160GB hard-disk. The framework prototype was installed
on the system and tested on a suite of malware consisting of:
Adware/Spyware (Booked Space and Bargain Buddy), Viruses
(W32/Kalb-ow, W32/Bacalid and W32/Detnat), E-mail Worms
(W32/Klez) and Rootkits (Rustock and Nailuj). We also tested
the above malware with two popular commercial anti-virus tools
McAfee VirusScan Plus [22] and Norton Anti-virus [29] for com-
parison purposes on the same system conﬁguration.
5.1 Qualitative Evaluation
We carried out the following experiment to demonstrate the ef-
fectiveness of our framework. We ﬁrst took a complete snapshot
of the base system with our framework installed. We then ran the
malware sample and let it infect the system. We then used our
framework to remove the effects of the malware. We then took a
second complete snapshot of the system. We then compared the
two snapshots (ﬁles, ﬁle contents in binary and conﬁguration in-
formation) to check for any differences. We repeated the above
experiment for all malware samples and for the framework and the
two commercial tools.
Figure 8. Comparison of MalTRAK and two popu-
lar commercial Anti-Virus tools; (a) ability to de-
tect and restore modiﬁcations to the ﬁlesystem
and conﬁguration elements, and (b) percentage of
malware effects that are removed from the system.
Figure 8a shows the number of ﬁles and conﬁguration elements
that were affected by the malware that were detected and removed
by our framework with those that were detected and removed by
the commercial tools. The ﬁgure shows that for all the malware
our tool can successfully remove all their effects completely than
the commercial tools can. These include:
that
the malware modi-
E.g W32/Kalb-ow,
ﬁed/completely destroyed in the system.
W32/Bacalid, W32/Detnat and W32/Klez. Our tool was able to
recover all the elements while the commercial tools could only
recover a fraction. Further for malware such as W32/Kalb-ow the
commerical tools could not recover any of the original elements
as they were completely overwritten.
Files/Conﬁguration
elements
Companion/Temporary elements that the malware created in
the system. Eg. Booked Space, Bargain Buddy and W32/Klez.
319319
Our tool was able to recover all the elements whereas the commer-
cial tools overlooked a portion of such elements.
Stealth malware: Eg. Rustock and Nailuj. Our tool was able to
recover all elements whereas the commercial tool could not even
detect these malware once they infected the system.
Thus, on an average, the commercial tools could only restore
36% of the effects of all the malware put together. What was more
surprising to us was the fact that the commercial tools claimed to
have the signatures for the Rustock and Nailuj, but for some rea-
son they were not able to detect them or recover their effects once
they had infected the system. Upon further investigation, we found
that these malware directly intercept at the FSD level thereby com-
pletely bypassing the ﬁlter drivers that are used by the commercial
tools. Further, these malware change the results of a ﬁle/directory
query to the FSD to remove all its ﬁles from the result buffer.
Thus, the anti-virus tools dont see the ﬁles used by these malware
which explains the observed discrepancy. However, since Mal-
TRAK intercepts at the FSD level beforehand, it receives control
at the lowest-level (since the malware intercepts chain to the orig-
inal FSD functions, which in our case is redirected by MalTRAK)
and is therefore still able to detect such malware and remove their
effects.
5.2 Quantitative Evaluation
Our framework monitors all activity to the ﬁlesystem as well
as conﬁguration subsystems systemwide. It records information
about such activity in case of modiﬁcations. It also intercepts call-
chains and certain system points in order to maintain state informa-
tion about the executing code and the modiﬁcations done. Figure 9
shows the overhead of the frameowork in the whole system (both
time and space) for several benign and malware programs. As
seen from the measurements, the overhead of our implementation
is minimal in the context of both runtime latency and disk space
for both ﬁlesystem intensive and non-intensive workloads. The
average runtime latency is very close to the actual exceution time.
For most programs which create new ﬁles, there is no disk space
overhead. For programs which modify existing ﬁles (W32/Kalb-
ow and Untar), the disk space overhead is reasonable. Note that
for W32/Kalb-ow, the runtime latency and disk space overhead is
quite large when compared to other programs. This is because the
W32/Kalb-ow is an overwriting virus which scans the system and
recursively overwrites all possible ﬁles periodically. Given the fact
that our framework is able to recover from such damaging opera-
tions, the overhead is acceptable in this case.
Figure 9. Execution time and disk space overhead
of MalTRAK while running benign and malware
programs.
Booked Space          Bargain  Buddy                    W32/Bacalid                                                                       W32/Detnat                                        W32/Kalb-ow                                                  W32/Klez                                                            Rustock                                                                      NailujMalTRAKCommercial Anti-Virus 1Commercial Anti-Virus 2Configuration ObjectsFile/Directory ObjectsConfiguration ObjectsFile/Directory ObjectsConfiguration ObjectsFile/Directory Objects100%    100%    100%    100%    100%    100%    100%    100%100%    100%    100%    100%    100%    100%    100%    100% 18%      25%      79%      100%      0%      96%       0%*       0%* 46%       47%    100%      67%      60%      0%        0%*       0%*  8%         4%     80.7%    100%      0%       96%       0%*      0%* 17%       19%     100%      17%      0%       50%       0%*       0%*Restored22           2259           59328        258152        152173         0567        5440             00             0Booked SpaceBargain BuddyW32/BacalidW32/DetnatW32/Kalb-owW32/KlezRustockNailujCommercial Anti-Virus 1ConfigurationObjects File/DirectoryObjectsDetectedMalwareConfigurationObjects File/DirectoryObjectsConfigurationObjects File/DirectoryObjectsCommercial Anti-Virus 2RestoredDetectedRestored52       5243       430          012       125          54          410        1013        13123       123236       236328       328152       152173       173567       5671            18            8DetectedRestoredDetectedRestored9             98             80             02             20             02             20             00             010         108            8328      265152      152173        0567      544 0           0 0           0DetectedRestoredDetected24        2420        200           08           83           30           00           00           0MalTRAK(a)(b)* These malware were not detected at allMalwareExecution TimeDisk Space OverheadNormalExecutionWithMalTRAKFreeWireKazaaRustockW32/Kalb.owUntarCygwin InstallProgram15.238s35.237s1.212s8.567s1.256s95.165s16.588s37.098s1.378s14.245s1.987s98.797s0 KB0 KB0 KB4276 KB875 KB0 KB5.3 Usability
There could be situations where it might be difﬁcult for the user
to pick the appropriate restore point to recover from the infected
system. When this happens the usability of our framework will
suffer. However, for all the malware that were detected and disin-
fected by our framework, we found that the framework provided
alerts which made it easy to spot the recovery point. Another situ-
ation in which the usability of the system could suffer is if a mal-
ware messes with the recovery console, making it difﬁcult for the
user to interact with our framework. While one solution would be
to move the console into kernel-mode, it is very difﬁcult to imple-
ment a user interaction due to limitations of Windows. Further, a
kernel-mode malware could mess with the console in kernel-mode.
Thus, the only option in this case would be boot the system using
a cdrom/bootdisk and run our recovery console via the command
line.
The framework alerts are by default in passive mode. This