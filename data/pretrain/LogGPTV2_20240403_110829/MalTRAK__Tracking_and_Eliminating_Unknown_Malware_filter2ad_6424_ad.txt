### Modified or Deleted Object Handling

When an object (such as a filesystem or configuration) is modified or deleted, the framework within the call-chain hooks employs a specific logic to determine the mapping. In kernel-mode, this logic is illustrated in Figure 6a. We assume that the object being accessed is denoted as \( x \). Similarly, in user-mode, the framework uses the logic shown in Figure 6b. The same logic is applied when a filesystem or configuration object is read to determine sibling mappings.

### Kernel-Mode and User-Mode Distinction

We handle kernel-mode and user-mode operations separately. In kernel mode, all modules are always visible to themselves and every process. Therefore, we need to distinguish between requests originating from kernel-mode and those from user-mode, which may include a kernel-mode point in the call-chain. This distinction is made using the `ExGetPreviousMode` Windows kernel function, which returns the previous operating mode of the processor. It is important to note that a caller cannot pretend to be from user-mode while in kernel-mode, as this would violate the existing implementation of the Windows OS kernel.

### Intercepts

#### Overview of Windows Kernel Structure

Before discussing our intercept implementation, it is essential to understand the structure of the Windows OS kernel. The kernel is entirely object-based, with every element, from files to processes to buffers, encapsulated as an object. For example, for files, directories, and volumes, we deal with the `FILE_OBJECT`, while for processes, we use the `EPROCESS` object. Our intercepts on the Windows OS kernel focus on filesystem and registry (configuration) intercepts.

#### Filesystem Intercepts

A filesystem is implemented as a filesystem driver (FSD) within the Windows kernel. The FSD has entry points that the Windows kernel invokes in response to file access, whether in user- or kernel-mode. For instance, invoking `CreateFile` in user-mode translates to an `IRP_MJ_CREATE` request at the FSD. These entry points are also known as dispatch routines. Internally, the Windows kernel uses I/O Request Packets (IRPs) to describe any kind of request. Thus, the FSD deals with IRPs for all filesystem operations. One piece of information found in the IRP is the `FILE_OBJECT` of the corresponding file being operated on.

One approach to implementing intercepts could be to change the pointer for the driver dispatch routines to point to our own, thereby gaining control. However, due to the complexity of the FSD, the parameters passed to these dispatch routines are not easy to decipher. Instead, we chose to intercept at internal functions of the FSD, which accept refined parameters, allowing us to easily map the file object being manipulated. Although this method might seem non-portable, our experiments comparing sample drivers provided in the Windows DDK with the NTFS driver debug symbols showed that the entry points and parameters were common. We intercepted the `Create`, `Open`, `Delete`, `Close`, `QueryInfo`, and `SetInfo` dispatch routines in the FSD.

#### Registry Intercepts

Windows manages configuration information in the registry, which is a collection of system-specific files storing essential configuration data. The registry is composed of hives and keys, similar to directories and files. The registry is managed by the configuration manager, a subsystem of the Windows kernel. The registry is stored in memory and periodically flushed to disk, but these flushes are done lazily, meaning the in-memory and on-disk copies may not always be identical. Therefore, we intercept registry access in memory to ensure consistency.

Direct manipulation of the registry is not possible because the configuration manager opens it at startup and keeps it open in exclusive mode until Windows shuts down. Additionally, the organization of the registry is not publicly documented, making direct access techniques unreliable. Our framework intercepts the `CreateKey`, `DeleteKey`, `Close`, `QueryKey`, and `SetKey` registry functions within the configuration manager to gain control over registry operations.

### Disinfection

The disinfection process consists of two main components: alerts and the disinfection console.

#### Alerts

Alerts are implemented by hooking various system kernel points that can be used directly or indirectly by malware to infect a system. Figure 7 illustrates the scenarios and OS execution points redirected by the framework for Windows XP SP2 to record alerts.

If an alert is configured to be passive, the framework simply records it and continues with the execution flow. If the alert is active, the framework delivers the alert to the disinfection console via an Asynchronous Procedure Call (APC). The user can then decide to continue or abort the operation. Upon receiving the APC, the disinfection console enters the framework via an IOCTL and dequeues the spinlock, indicating whether to continue or abort the operation. This ensures that no other filesystem requests are initiated if the alert scenario involves the FSD.

#### Disinfection Console

When a user wants to disinfect an infected system, they use the disinfection console, which puts the framework into disinfection mode. In this mode, context switching is disabled, and no operations are allowed on the system until disinfection is complete.

Disinfection begins with the construction of active and delete lists. The disinfection engine then sweeps through all open file handles in running processes, building a list of file handles that need to be reopened when the system is switched to a different view. It dereferences all `FILE_OBJECTS` associated with these handles, terminating their mappings with the FSD. The handles themselves are not deleted. The recovery engine scans the recovery and delete lists to check if any dependent processes/threads are active in memory, using call-contexts for this purpose. The disinfection engine forcibly terminates these processes by sending a terminate signal in kernel-mode. The recovery engine then applies the recovery and delete lists to the current view, moving the system to the desired state. Finally, the recovery engine creates new mappings for the `FILE_OBJECTS` and handles in running processes, enables interrupts, and returns to the disinfection console. At this point, the system is disinfected.

### Evaluation

#### Qualitative Evaluation

To demonstrate the effectiveness of our framework, we conducted an experiment on a clean system running Windows XP SP2 with an Intel 3.2 GHz processor, 1GB of system memory, and a 160GB hard drive. We installed the framework prototype and tested it on a suite of malware, including Adware/Spyware (Booked Space and Bargain Buddy), Viruses (W32/Kalb-ow, W32/Bacalid, and W32/Detnat), E-mail Worms (W32/Klez), and Rootkits (Rustock and Nailuj). We also compared our results with two popular commercial anti-virus tools, McAfee VirusScan Plus and Norton Anti-virus, on the same system configuration.

Figure 8 shows the number of files and configuration elements affected by the malware that were detected and removed by our framework versus the commercial tools. Our tool successfully removed all effects of the malware, while the commercial tools only partially recovered some elements. For example, our tool fully recovered all elements for W32/Kalb-ow, W32/Bacalid, W32/Detnat, and W32/Klez, whereas the commercial tools could only recover a fraction. For stealth malware like Rustock and Nailuj, our tool detected and removed all effects, while the commercial tools failed to detect them.

On average, the commercial tools could only restore 36% of the malware effects. The commercial tools claimed to have signatures for Rustock and Nailuj but failed to detect or remove their effects once the system was infected. This is because these malware intercept at the FSD level, bypassing the filter drivers used by the commercial tools. Since our framework intercepts at the FSD level, it can still detect and remove such malware.

#### Quantitative Evaluation

Our framework monitors all activity to the filesystem and configuration subsystems, recording information about modifications and intercepting call-chains to maintain state information. Figure 9 shows the overhead of the framework in terms of runtime latency and disk space for several benign and malware programs. The overhead is minimal, with the average runtime latency close to the actual execution time. For programs creating new files, there is no disk space overhead. For programs modifying existing files, the disk space overhead is reasonable. For W32/Kalb-ow, an overwriting virus, the overhead is larger but acceptable given the framework's ability to recover from such damage.

#### Usability

Usability can be challenging if the user finds it difficult to select the appropriate restore point. However, our framework provides alerts that make it easier to identify the recovery point. Another usability issue arises if malware interferes with the recovery console, making it hard for the user to interact with the framework. While moving the console to kernel-mode is one solution, it is difficult to implement due to Windows limitations. A kernel-mode malware could also interfere with the console in kernel-mode. The best option in such cases is to boot the system using a CD-ROM/boot disk and run the recovery console via the command line.

By default, the framework alerts are in passive mode, meaning they only record the events without interrupting the system.