我们先用我们的fuzzing程序简单检查一下，为了简单，我们只生成最大长度为10的字符串：
    for i in range(0,100):
        data = fuzzer(max_length=10)
        print(data)
        print(my_sqrt(data))
你可以尝试一下，结果不堪设想，基本上没有能运行完的时候，直接就是报错报错报错，但是经过测试我们也知道，程序确实是充满问题，而且我们也可以通过发生错误的输入，来反推程序是哪里出了问题。下面就让我们来完善这个程序。
###  长度陷阱
在以往参加的自动化漏洞挖掘比赛中，我们往往都会先无脑发送一波超级无敌长的字符串，因为大多数程序并没有考虑输入的长度限制，如果你输入的字符串过大，必然会导致程序直接奔溃。所以我们往往会第一步先设置输入字符串的长度，比如这里我们就可以指定长度为8，如果输入的字符串的长度大于8，我们就直接将其舍弃掉。
###  corner数据
如果你打过acm或者参加过学校的oj测试，你一定会优先考虑：有没有一些特殊的数据现在的函数无法处理？这样的数据我们管它叫做corner，也就是经常注意不到的边缘数据。显然，对于我们的函数，0和负数就是边缘数据，这样的输入从逻辑上，它们不能求平方根；从代码上，它们会导致代码失控。所以，我们需要限制这样数据的输入，或者是对这样的数据进行单独处理
    if x len(buffer):
            print("栈溢出了兄弟！")
很显然如果我们的str长度超过了10，就会触发栈溢出问题，一旦程序发生了奔溃，我们就可以考虑程序是否出现了栈溢出的问题，从而进一步构造payload进行利用。
当然在c语言程序中，由于栈的构造（在我们的局部变量之前还保存了ebp、返回地址、函数参数等信息），有时候我们虽然是触发了栈溢出，但是由于溢出的东西比较少，程序还是能“坚强”的完成运行，但考虑到fuzzing进行数不清的数据测试，这个问题不会对我们的fuzzing产生影响。
    cin>>size;
    int * p = (int *)malloc(size);
这个错误相信大家都可以看出来，攻击者只要输入一个足够大的数，程序就算是当场完蛋了。
###  信息泄漏
这其实和上面软件测试中提到的非法输入有些相似，都是因为输入的不合法导致了一些问题，我们常常可以看见舍友们半夜敲oj写程序时敢于“放飞自我”，写出这样大逆不道，让安全研究猿吐血三升的程序：
    cin>>index;
    cout<<arr[index];
这样简单的两行代码就有着“卧龙凤雏”两大错误：
  * 数组其实就是指针的语法糖，只是为了让使用者易于理解、便于使用，实际上在底层，下面两种结果是完全等价的 
        arr[index]
    *(arr+index)
所以你的写法是让使用者获得了一个自由的指针，它约等于随便访问的权利，会泄漏你的各种数据
  * 如果输入的东西引发了指针越界等问题，会导致程序直接奔溃。
###  完整性缺失
很多时候我们在进行漏洞利用时，都需要构造特殊的payload，比如说我们会输入一些地址甚至是shellcode，如果程序没有完整性检查，就会导致我们的程序对于这些非法输入视而不见，相反，良好的完整性检查能让漏洞利用的难度直线上升。这里的完整性是对数据的特殊规定，和上面提过的非法输入还不太一样，比如程序需要输入一个电话号码，输入字符串就是违背了上面的非法输入原则，但输入的数字我们还可以进一步做约束，比如电话开头必须是1，再比如号码必须是11位等等。
    def check(str):
        assert str.len() == 11
        assert str[1] == '1'
## 总结
在这篇文章中我们简单实现了自己的fuzzing，并用它测试了一些程序，算是初步了解了fuzzing是个什么东西。但就像前文中说的，现在它还只是一个lv1的史莱姆，这一篇中我们也算是打了不少小怪，下一篇中也该让它升级了，让它的fuzzer变得更加“聪明”。