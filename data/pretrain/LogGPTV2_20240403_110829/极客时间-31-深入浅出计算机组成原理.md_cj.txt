## 总结延伸好了，不知道讲完这些，你有没有体会到 Disruptor 这个框架的神奇之处呢？CPU 从内存加载数据到 CPU Cache里面的时候，不是一个变量一个变量加载的，而是加载固定长度的 CacheLine。如果是加载数组里面的数据，那么 CPU就会加载到数组里面连续的多个数据。所以，数组的遍历很容易享受到 CPU Cache那风驰电掣的速度带来的红利。对于类里面定义的单独的变量，就不容易享受到 CPU Cache红利了。因为这些字段虽然在内存层面会分配到一起，但是实际应用的时候往往没有什么关联。于是，就会出现多个CPU Core 访问的情况下，数据频繁在 CPU Cache 和内存里面来来回回的情况。而Disruptor 很取巧地在需要频繁高速访问的常量 INITIAL_CURSOR_VALUE前后，各定义了 7 个没有任何作用和读写请求的 long 类型的变量。这样，无论在内存的什么位置上，这个 INITIAL_CURSOR_VALUE 所在的 CacheLine 都不会有任何写更新的请求。我们就可以始终在 Cache Line里面读到它的值，而不需要从内存里面去读取数据，也就大大加速了 Disruptor的性能。这样的思路，其实渗透在 Disruptor这个开源框架的方方面面。作为一个生产者 - 消费者模型，Disruptor并没有选择使用链表来实现一个队列，而是使用了 RingBuffer。RingBuffer底层的数据结构则是一个固定长度的数组。这个数组不仅让我们更容易用好 CPUCache，对 CPU执行过程中的分支预测也非常有利。更准确的分支预测，可以使得我们更好地利用好CPU 的流水线，让代码跑得更快。
## 推荐阅读今天讲的是 Disruptor，推荐的阅读内容自然是 Disruptor的官方文档。作为一个开源项目，Disruptor在自己[GitHub](https://github.com/LMAX-Exchange/disruptor/wiki/Introduction)上有很详细的设计文档，推荐你好好阅读一下。这里面不仅包含了怎么用好 Disruptor，也包含了整个 Disruptor框架的设计思路，是一份很好的阅读学习材料。另外，Disruptor的官方文档里，还有很多文章、演讲，详细介绍了这个框架，很值得深入去看一看。Disruptor的源代码其实并不复杂，很适合用来学习怎么阅读开源框架代码。
## 课后思考今天我们讲解了缓存行填充，你可以试试修改 Disruptor的代码，看看在没有缓存行填充和有缓存行填充的情况下的性能差异。你也可以尝试直接修改Disruptor的源码和[性能测试代码](https://github.com/LMAX-Exchange/disruptor/blob/master/src/perftest/java/com/lmax/disruptor/immutable/CustomPerformanceTest.java)，看看运行的结果是什么样的。欢迎你把你的测试结果写在留言区，和大家一起讨论、分享。如果有收获，你也可以把这篇文章分享给你的朋友。![](Images/79d06107d349635530fbf82aa8dfb625.png){savepage-src="https://static001.geekbang.org/resource/image/28/29/281ca28b90c8aa0aecbb5adc08394f29.jpg"}
# 55 \| 理解Disruptor（下）：不需要换挡和踩刹车的CPU，有多快？上一讲，我们学习了一个精妙的想法，Disruptor 通过缓存行填充，来利用好 CPU的高速缓存。不知道你做完课后思考题之后，有没有体会到高速缓存在实践中带来的速度提升呢？不过，利用 CPU 高速缓存，只是Disruptor"快"的一个因素，那今天我们就来看一看 Disruptor快的另一个因素，也就是"无锁"，而尽可能发挥 CPU 本身的高速处理性能。
## 缓慢的锁Disruptor 作为一个高性能的生产者 -消费者队列系统，一个核心的设计就是通过 RingBuffer 实现一个无锁队列。上一讲里我们讲过，Java 里面的基础库里，就有像 LinkedBlockingQueue这样的队列库。但是，这个队列库比起 Disruptor 里用的 RingBuffer要慢上很多。慢的第一个原因我们说过，因为链表的数据在内存里面的布局对于高速缓存并不友好，而RingBuffer 所使用的数组则不然。![](Images/8403edb2146e1c8c15cf77ef2da5a1b5.png){savepage-src="https://static001.geekbang.org/resource/image/9c/69/9ce732cb22c49a8a26e870dddde66b69.jpeg"}LinkedBlockingQueue慢，有另外一个重要的因素，那就是它对于锁的依赖。在生产者 -消费者模式里，我们可能有多个消费者，同样也可能有多个生产者。多个生产者都要往队列的尾指针里面添加新的任务，就会产生多个线程的竞争。于是，在做这个事情的时候，生产者就需要拿到对于队列尾部的锁。同样地，在多个消费者去消费队列头的时候，也就产生竞争。同样消费者也要拿到锁。``{=html}那只有一个生产者，或者一个消费者，我们是不是就没有这个锁竞争的问题了呢？很遗憾，答案还是否定的。一般来说，在生产者 -消费者模式下，消费者要比生产者快。不然的话，队列会产生积压，队列里面的任务会越堆越多。一方面，你会发现越来越多的任务没有能够及时完成；另一方面，我们的内存也会放不下。虽然生产者 -消费者模型下，我们都有一个队列来作为缓冲区，但是大部分情况下，这个缓冲区里面是空的。也就是说，即使只有一个生产者和一个消费者者，这个生产者指向的队列尾和消费者指向的队列头是同一个节点。于是，这两个生产者和消费者之间一样会产生锁竞争。在 LinkedBlockingQueue 上，这个锁机制是通过 synchronized 这个 Java关键字来实现的。一般情况下，这个锁最终会对应到操作系统层面的加锁机制（OS-basedLock），这个锁机制需要由操作系统的内核来进行裁决。这个裁决，也需要通过一次上下文切换（ContextSwitch），把没有拿到锁的线程挂起等待。不知道你还记不记得，我们在[第 28讲](https://time.geekbang.org/column/article/103717)讲过的异常和中断，这里的上下文切换要做的和异常和中断里的是一样的。上下文切换的过程，需要把当前执行线程的寄存器等等的信息，保存到线程栈里面。而这个过程也必然意味着，已经加载到高速缓存里面的指令或者数据，又回到了主内存里面，会进一步拖慢我们的性能。我们可以按照 Disruptor 介绍资料里提到的Benchmark，写一段代码来看看，是不是真是这样的。这里我放了一段 Java代码，代码的逻辑很简单，就是把一个 long 类型的 counter，从 0 自增到 5亿。一种方式是没有任何锁，另外一个方式是每次自增的时候都要去取一个锁。你可以在自己的电脑上试试跑一下这个程序。在我这里，两个方式执行所需要的时间分别是207 毫秒和 9603 毫秒，性能差出了将近 50 倍。    package com.xuwenhao.perf.jmm;  import java.util.concurrent.atomic.AtomicLong;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;  public class LockBenchmark{      public static void runIncrement()    {        long counter = 0;        long max = 500000000L;        long start = System.currentTimeMillis();        while (counter ```加锁和不加锁自增 counter]{.reference}```{=html}```    Time spent is 207ms without lockTime spent is 9603ms with lock```{=html}```性能差出将近 10 倍]{.reference}```{=html}```
## 无锁的 RingBuffer加锁很慢，所以 Disruptor的解决方案就是"无锁"。这个"无锁"指的是没有操作系统层面的锁。实际上，Disruptor还是利用了一个 CPU 硬件支持的指令，称之为 CAS（Compare AndSwap，比较和交换）。在 Intel CPU 里面，这个对应的指令就是cmpxchg。那么下面，我们就一起从 Disruptor的源码，到具体的硬件指令来看看这是怎么一回事儿。Disruptor 的 RingBuffer是这么设计的，它和直接在链表的头和尾加锁不同。Disruptor 的 RingBuffer创建了一个 Sequence 对象，用来指向当前的 RingBuffer的头和尾。这个头和尾的标识呢，不是通过一个指针来实现的，而是通过一个**序号**。这也是为什么对应源码里面的类名叫Sequence。![](Images/21d2e13625bf6b9c98862610e681d5d0.png){savepage-src="https://static001.geekbang.org/resource/image/b6/ec/b64487a7b6b45393fdfa7e2d63e176ec.jpeg"}在这个 RingBuffer当中，进行生产者和消费者之间的资源协调，采用的是对比序号的方式。当生产者想要往队列里加入新数据的时候，它会把当前的生产者的Sequence的序号，加上需要加入的新数据的数量，然后和实际的消费者所在的位置进行对比，看看队列里是不是有足够的空间加入这些数据，而不会覆盖掉消费者还没有处理完的数据。在 Sequence 的代码里面，就是通过 compareAndSet这个方法，并且最终调用到了 UNSAFE.compareAndSwapLong，也就是直接使用了CAS 指令。     public boolean compareAndSet(final long expectedValue, final long newValue)    {        return UNSAFE.compareAndSwapLong(this, VALUE_OFFSET, expectedValue, newValue);    }  public long addAndGet(final long increment)    {        long currentValue;        long newValue;          do        {            currentValue = get();            newValue = currentValue + increment;        }        while (!compareAndSet(currentValue, newValue));          return newValue;```{=html}```Sequence 源码中的 addAndGet，如果 CAS的操作没有成功，它会不断忙等待地重试]{.reference}```{=html}```这个 CAS指令，也就是比较和交换的操作，并不是基础库里的一个函数。它也不是操作系统里面实现的一个系统调用，而是**一个CPU 硬件支持的机器指令**。在我们服务器所使用的 Intel CPU 上，就是cmpxchg 这个指令。    compxchg [ax] (隐式参数，EAX 累加器), [bx] (源操作数地址), [cx] (目标操作数地址)cmpxchg指令，一共有三个操作数，第一个操作数不在指令里面出现，是一个隐式的操作数，也就是EAX累加寄存器里面的值。第二个操作数就是源操作数，并且指令会对比这个操作数和上面的累加寄存器里面的值。如果值是相同的，那一方面，CPU 会把ZF（也就是条件码寄存器里面零标志位的值）设置为1，然后再把第三个操作数（也就是目标操作数），设置到源操作数的地址上。如果不相等的话，就会把源操作数里面的值，设置到累加器寄存器里面。我在这里放了这个逻辑对应的伪代码，你可以看一下。如果你对汇编指令、条件码寄存器这些知识点有点儿模糊了，可以回头去看看[第5](https://time.geekbang.org/column/article/93359)[讲](https://time.geekbang.org/column/article/93359)、[第6讲](https://time.geekbang.org/column/article/94075)关于汇编指令的部分。    IF [ax]`{=html}另一方面，写专栏和我们写程序一样，都是有 deadline的。无论是在系统发版之后的午夜里，还是去美国出差的飞机上，乃至偶尔忘带了录音笔的时候，总是要打起精神想尽方法，写出一篇让自己满意的文章来。同时，也有不少同学给我挑出了错漏或者不准确的部分，一起把这个专栏打磨地更"完美"。不知道正在读结束语的你，有没有在过去 5个月里坚持学习这个专栏呢？有没有认真阅读我每一节后的推荐阅读呢？有没有尝试去做一做每一讲后面的思考题呢？如果你能够坚持下来，那首先要恭喜你，我相信能够学完的同学并不太多。如果你还没有学完，也不要紧，先跟着整个课程走一遍，有个大致印象。与其半途而费，不如先囫囵吞枣，硬着头皮看完再说。**新的知识第一遍没有百分百看懂，而随着时间的推移，慢慢领悟成长了，这才是人生的常态。而我所见到的优秀的工程师大都会经历这样的成长过程。**我们这个行业，经常喜欢把软件开发和建筑放在一起类比，所以才会有经典的《设计模式》这样的书。甚至有不少人干脆从《建筑的永恒之道》里面去寻找灵感。然而，建筑能够在历史上留下长久的刻印，但是软件却完全不同。无论多么完美的代码都会不断迭代，就好像新陈代谢一样。几年过去之后，最初那些代码的踪影早已经没有了。软件工程师放弃了追求永恒，而是投身在创作的快乐之中。希望在日后的学习过程中，你也能抱着"日拱一卒、不期速成"的心态坚持下去，不断地学习、反思、练习、再学习，这样的迭代才是最快的成长之路。