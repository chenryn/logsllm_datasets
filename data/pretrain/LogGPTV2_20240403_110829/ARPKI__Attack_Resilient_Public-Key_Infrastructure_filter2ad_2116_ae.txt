RegReq
UpdateReq
CCReq
CA1 CA2
9.28
9.31
9.33
9.49
5.12
5.64
ILS1 Total
32.15
13.56
31.80
12.98
7.06
17.82
Table 2: Detailed processing time (in milliseconds)
by the given entity.
Request
RegReq
CA1 UpdateReq
CCReq
RegReq
CA2 UpdateReq
CCReq
RegReq
ILS1 UpdateReq
CCReq
RSA ARCert Hash Misc.
1.61
1.71
2.51
1.37
1.44
1.28
1.72
1.90
1.24
5.80
5.90
2.39
5.97
5.72
2.40
10.09
9.32
5.68
1.72
1.69
-
1.70
1.93
-
1.38
1.40
-
0.18
0.19
0.22
0.24
0.24
0.25
0.37
0.36
0.15
request to the time that CA1 sends the response (which went
through all required entities), without considering network
latency. In other words, we measure the total processing
time spent by the entities involved.
We provide a further breakdown of the processing time
in Table 2. For each entity, we distinguish four kinds of
processing time. RSA denotes the time spent on signature
veriﬁcation and creation, required for creating and process-
ing protocol messages. ARCert denotes the time spent
on the veriﬁcation and parameter validation of the X.509
certiﬁcates. Hash denotes the time required to compute
hashes. Misc. encompasses message processing (Base64 and
JSON encoding/decoding and parsing), database lookup,
and input/output operations. For the CCReq, no ARCert
validation needs to be done, which we denote by a hyphen
in the table.
For the validation by the browser, we distinguish two
phases: standard validation and ARPKI validation. During
the standard validation phase, the browser validates every
X.509 certiﬁcate within ARCert, using the standard browser
validation procedure. This includes checking whether the
certiﬁcate is issued for a correct domain, has been signed
correctly, has expired, etc. The validation phase of ARPKI
additionally checks that (a) certiﬁcates within ARCert are
signed by CAs that are trusted by the domain, (b) proofs
have been produced for the correct ARCert and that the
proof validates with the correct root, and (c) the proof and
the root are signed by the correct entities (i.e., they are
distinct and trusted by the domain). We used an ARCert
that consisted of three standard X.509 certiﬁcates. The
entire validation took 2.25ms on average (the median was
2.20ms); the standard validation took 0.70ms on average
(median 0.67ms), and the ARPKI validation took on average
1.55ms (median 1.53ms).
The most time-consuming operations in our system in-
volve signature creation and veriﬁcation. This computational
overhead can be reduced by using state-of-the-art digital
signature schemes [6,14]. However, such improvements may
not be backward-compatible with software that uses older
cryptographic libraries.
In our design, the CAs are required to perform veriﬁcation
in addition to their normal operations. Even though our
prototype is not yet optimized, our tests indicate that a CA
on a single low-end machine can serve about 100 ARCert’s
registrations/updates and 200 conﬁrmations per second. The
bandwidth required for this is 10Mbit/s.
In terms of client-server communication, the biggest trans-
mission overhead is introduced by using the ARCert, since it
is implemented by concatenating standard X.509 certiﬁcates.
Instead of sending one standard certiﬁcate, as is currently
done, a domain sends the concatenation of standard certiﬁ-
cates, each signed by a diﬀerent CA. Note that the size of this
overhead is not ﬁxed: the domain can adjust the trade-oﬀ
between processing/transmission overhead and the authenti-
cation of its own public key by combining the desired number
of standard certiﬁcates into an ARCert. It is important that
the latency introduced by the ARPKI infrastructure does not
inﬂuence the client-server connection. The conﬁrmations are
obtained periodically and stored by the server for a selected
amount of time. At each connection, the server provides
these conﬁrmations to the browser along with its ARCert.
Our solution does not introduce any extra network requests
for client-server connections. However, due to the size of
ARCert and conﬁrmations, small latency may be introduced
by the transport layer protocol [16]. Note that our solution
does not introduce any additional computational overhead
for the server during regular HTTPS connections.
Overall, our analysis of the prototype implementation
indicates that it is feasible to deploy ARPKI with reasonable
overhead.
7. CONCLUSIONS
We have presented ARPKI, a new public-key infrastruc-
ture that oﬀers very strong security guarantees. In particular,
it oﬀers resilience against impersonation attacks that involve
n− 1 compromised entities. Moreover, if all entities involved
in an ARCert are compromised, in which case domain imper-
sonation cannot be prevented, the validators may still obtain
the evidence of the compromise, and can take compensating
actions out of band. If such evidence cannot be obtained (an
adversary uses compromised keys to produce an ARCert and
its conﬁrmation, without logging this malicious ARCert),
then only an attacked client can make that attack detectable
by contacting validators out of band. Even though attack re-
silience cannot be achieved in this case, complete compromise
situations are at least visible. We have also implemented our
proposal. Our evaluation of the complete proof-of-concept
implementation provides strong evidence of the feasibility of
deploying ARPKI with reasonable overhead.
Throughout the design and implementation of ARPKI, we
used formal analysis to validate our design modiﬁcations.
This co-design of the formal model and the implementation
enabled us to detect numerous pitfalls early on.
It also
enabled us to make implementation choices that simpliﬁed
the construction of proofs later, such as including unique tags
in all messages. As a result, our formal model is much closer
to the implementation than a typical after-the-fact analysis
of a given implementation, thereby reducing the possibility
of modeling errors.
Finally, ARPKI introduces a new model of public-key in-
frastructure and certiﬁcate validation. Future work therefore
includes developing procedures for managing CA certiﬁcates,
elaborating the CAs’ policies and business models, improving
the representation of ARCert, and developing incremental
deployment strategies.
Acknowledgments
This work was supported by CyLab at Carnegie Mellon
University, NSF under award CNS-1040801, and a gift from
Google. We thank Emilia Kasper for her feedback during
the initial stage of this work. We thank Lorenzo Baesso and
Lin Chen for their programming assistance.
8. REFERENCES
[1] ARPKI: Full implementation, formal model, and
security properties.
http://www.netsec.ethz.ch/research/arpki.
[2] Convergence. http://convergence.io/.
[3] Public Key Pinning. http://www.imperialviolet.
org/2011/05/04/pinning.html, May 2011.
[4] Public Key Pinning Extension for HTTP.
http://tools.ietf.org/html/draft-ietf-websec-
key-pinning-01, December 2011.
[5] Mart´ın Abadi, Andrew Birrell, Ilya Mironov, Ted
Wobber, and Yinglian Xie. Global authentication in an
untrustworthy world. In Petros Maniatis, editor,
HotOS. USENIX Association, 2013.
[6] Daniel J Bernstein, Niels Duif, Tanja Lange, Peter
Schwabe, and Bo-Yin Yang. High-speed high-security
signatures. Journal of Cryptographic Engineering,
2(2):77–89, 2012.
[7] Robert Biddle, Paul C van Oorschot, Andrew S Patrick,
Jennifer Sobey, and Tara Whalen. Browser interfaces
and extended validation SSL certiﬁcates: an empirical
study. In Proceedings of the 2009 ACM workshop on
Cloud computing security, pages 19–30. ACM, 2009.
[8] D. Cooper, S. Santesson, S. Farrell, S. Boeyen,
R. Housley, and W. Polk. Internet X.509 Public Key
Infrastructure Certiﬁcate and Certiﬁcate Revocation
List (CRL) Proﬁle. RFC 5280 (Proposed Standard),
May 2008.
[9] Paul Ducklin. The TURKTRUST SSL certiﬁcate ﬁasco
- what really happened, and what happens next?
http://nakedsecurity.sophos.com/2013/01/08/the-
turktrust-ssl-certificate-fiasco-what-
happened-and-what-happens-next/, January 2013.
[10] Peter Eckersley. Sovereign Key Cryptography for
Internet Domains.
https://git.eff.org/?p=sovereign-keys.git;a=
blob;f=sovereign-key-design.txt;hb=HEAD.
[11] Martin Georgiev, Subodh Iyengar, Suman Jana,
Rishita Anubhai, Dan Boneh, and Vitaly Shmatikov.
The most dangerous code in the world: validating SSL
certiﬁcates in non-browser software. In Proceedings of
the 2012 ACM conference on Computer and
communications security, pages 38–49. ACM, 2012.
[12] Paul Hoﬀman and Jakob Schlyter. The DNS-based
Authentication of Named Entities (DANE) Transport
Layer Security (TLS) Protocol: TLSA.
http://tools.ietf.org/html/rfc6698, August 2012.
IETF RFC 6698.
[13] R. Housley, W. Polk, W. Ford, and D. Solo. Internet
X.509 Public Key Infrastructure: Certiﬁcate and
Certiﬁcate Revocation List (CRL) Proﬁle. Technical
Report RFC 3280, Internet Engineering Task Force,
April 2002.
[14] Emilia Kasper. Fast elliptic curve cryptography in
OpenSSL. In Financial Cryptography and Data
Security, volume 7126 of LNCS, pages 27–39. Springer,
2012.
[15] Tiﬀany Hyun-Jin Kim, Lin-Shung Huang, Adrian
Perrig, Collin Jackson, and Virgil Gligor. Accountable
Key Infrastructure (AKI): A Proposal for a Public-Key
Validation Infrastructure. In Daniel Schwabe, Virg´ılio
A. F. Almeida, Hartmut Glaser, Ricardo A.
Baeza-Yates, and Sue B. Moon, editors, Proceedings of
the International World Wide Web Conference
(WWW), May 2013.
[16] Adam Langley. Overclocking SSL.
https://www.imperialviolet.org/2010/06/25/
overclocking-ssl.html, June 2010.
[17] Ben Laurie and Emilia Kasper. Revocation
Transparency. http://sump2.links.org/files/
RevocationTransparency.pdf.
[18] Ben Laurie, Adam Langley, and Emilia Kasper.
Certiﬁcate Transparency.
http://tools.ietf.org/pdf/rfc6962.pdf, June 2013.
IETF RFC 6962.
[19] Moxie Marlinspike and Trevor Perrin. Trust Assertions
for Certiﬁcate Keys. http://tack.io/draft.html,
May 2012.
[20] Simon Meier, Benedikt Schmidt, Cas Cremers, and
David Basin. The TAMARIN Prover for the Symbolic
Analysis of Security Protocols. In Computer Aided
Veriﬁcation, 25th International Conference, CAV 2013,
Princeton, USA, Proc., volume 8044 of LNCS, pages
696–701. Springer, 2013.
[21] Joseph Menn. Key internet operator VeriSign hit by
hackers.
http://www.reuters.com/article/2012/02/02/us-
hacking-verisign-idUSTRE8110Z820120202, January
2012.
[22] M. Myers, R. Ankney, A. Malpani, S. Galperin, and
C. Adams. X.509 Internet Public Key Infrastructure
Online Certiﬁcate Status Protocol - OCSP. Internet
Request for Comments 2560, June 1999.
[23] Paul Roberts. Phony SSL certiﬁcates issued for Google,
Yahoo, Skype, others.
http://threatpost.com/phony-ssl-certificates-
issued-google-yahoo-skype-others-032311/,
March 2011.
[24] Mark D. Ryan. Enhanced certiﬁcate transparency and
end-to-end encrypted mail. In Proceedings of NDSS.
The Internet Society, 2014.
[25] Benedikt Schmidt, Simon Meier, Cas Cremers, and
David Basin. Automated analysis of Diﬃe-Hellman
protocols and advanced security properties. In
Computer Security Foundations Symposium (CSF),
pages 78–94. IEEE, 2012.
[26] Toby Sterling. Second ﬁrm warns of concern after
Dutch hack. http://news.yahoo.com/second-firm-
warns-concern-dutch-hack-215940770.html,
September 2011.
[27] Pawel Szalachowski, Stephanos Matsumoto, and Adrian
Perrig. PoliCert: Secure and Flexible TLS Certiﬁcate
Management. In Proceedings of the ACM Conference
on Computer and Communications Security (CCS).
ACM, November 2014.
[28] Emin Topalovic, Brennan Saeta, Lin-Shung Huang,
Collin Jackson, and Dan Boneh. Towards Short-Lived
Certiﬁcates. In Web 2.0 Security and Privacy, May
2012.
[29] Dan Wendlandt, David G. Andersen, and Adrian Perrig.
Perspectives: Improving SSH-style Host Authentication
with Multi-Path Probing. In Proceedings of USENIX
Annual Technical Conference, June 2008.