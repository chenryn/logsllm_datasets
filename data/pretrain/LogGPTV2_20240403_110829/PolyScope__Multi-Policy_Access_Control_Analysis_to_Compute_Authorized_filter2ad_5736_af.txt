0
24
25
14
8
48
72
16
87
107
0
64
22
12
12
92
199
41
124
46
0
(READ_LOGS) associated with the AID_LOG DAC group, ven-
dors include several signed apps on their devices, and some
signed apps have had reported vulnerabilities, such as the
adb app [33]. resetreason has access to several integrity-
critical resources, and we have conﬁrmed that we can redirect
resetreason to write ﬁles in the encrypted ﬁlesystem direc-
tory. Previous work demonstrated the importance of attacks on
the encrypted ﬁlesystem from the system’s radio service [44].
We responsbly reported this vulnerability, which has been
conﬁrmed by Samsung and assigned CVE-2020-13833.
Xiaomi and Huawei Thememanager: We discovered mul-
tiple unreported vulnerabilities in the Xiaomi and Huawei
devices. We describe one example here. These devices in-
clude a variety of value-added services, including the The-
memanager, which allows users to customize the user inter-
face of their devices. However, the Xiaomi access control
policies are conﬁgured such that untrusted apps can write to
the ﬁle /data/data/com.android.thememanager/cache,
which is used by the Thememanager for storing content that
the Thememanager may use in conﬁguring the display. We
veriﬁed on Xiaomi 8.0 that arbitrary modiﬁcations to this ﬁle
do crash the privileged Thememanager process and in some
cases impact the GUI without crashing. A ﬁnely-crafted modi-
ﬁcation could perhaps exploit the Thememanager service. We
found four other similar vulnerabilities in the Xiaomi 8.0 re-
lease for writeable cache ﬁles. We responsibly reported these
vulnerabilities to Xiaomi, who indicated that they were ﬁxed
in the Xiaomi 9.0 release.
We found that Huawei on both the 8.0 and 9.0 releases has
a similar vulnerability for the theme cache ﬁles as well, but ex-
ploitation requires adversaries to compromise an application
with media_rw permission (T2 in the Google Privilege Lev-
els) We responsibly reported these vulnerabilities to Huawei
who stated that they are not concerned about so-called privi-
Figure 4: PolyScope Analysis Performance
leged apps being exploited. We note that a similar scenario
led to the issuing of a CVE by Samsung. Furthermore, we
point out that privileged applications have been found to be
ﬂawed in several instances, see Section 2.3.
7.7 Performance
We measured the performance of PolyScope for the eight
Android releases. The overhead was measured on a PC run-
ning an AMD Ryzen 7 3700X (8 core, 16 thread) with 16GB
of RAM and an RTX 2080 Super GPU using Ubuntu 18.04.
PolyScope IVs are found in two steps as described in Sec-
tion 6: TE IV computation and TE IV validation. We ﬁnd
that the performance of TE IV computation has a linear rela-
tionship to the SEAndroid policy size. The TE IV validation
stage’s performance is proportional to the number of IVs
found in TE IV computation, but that impact can be reduced
because validation can be parallelized.
Figure 4 shows the performance overhead of these two
stages11 for the eight releases. We evaluate the performance
11The cost of computing attack operations is negligible and included in
the TE IV validation.
USENIX Association
30th USENIX Security Symposium    2591
of the TE IV validation for one to eight threads. With a multi-
core CPU, parallelization does produce signiﬁcant perfor-
mance improvement. We also point out that we found it quite
expensive to compute all the authorized data ﬂows for these
releases. On the other hand, with a proper threat model to
prune cases, PolyScope is able to identify integrity violations
in a reasonable amount of time.
8 Discussion
In this section, we review limitations in the PolyScope ap-
proach and examine the implications of a recently proposed
Android defense called scoped storage.
8.1 Limitations
We identify three limitations of PolyScope: (1) PolyScope
relies on rooted phone to collect ﬁlesystem data; (2) we cannot
always determine the mapping between MAC labels and their
corresponding DAC UIDs; (3) PolyScope cannot conﬁrm
vulnerabilities from attack operations automatically.
Without rooting the phone, we cannot gather DAC informa-
tion from privileged directories such as /system. Recently,
Hernandez et al. [22] proposed BigMAC, which includes a
technique to extract accurate DAC conﬁguration data from
these privileged directories (˜95%). We will explore integrat-
ing BigMAC into our data collection in future releases. To-
gether with the data collected from an unrooted phone, see
Appendix A.1, we should be able to recover a nearly com-
plete snapshot of the ﬁlesystem. We will explore methods to
achieve complete recovery in future work.
Another limitation of PolyScope is that ﬁnding the MAC-
to-DAC mapping of subjects requires running a process for
each MAC label to collect its DAC UIDs/groups.12 Currently,
if either the adversary or victim for a computed TE IV is
not mapped to a complete subject, we skipped the IV valida-
tion stage for that TE IV. About 25% of the TE IVs do not
go through validation. Runtime support could collect such
mappings to seed validation.
Finally, PolyScope lacks a systematic way to test the vic-
tims for vulnerabilities to the attack operations found. The
problem is that we need to know when a victim uses a ﬁle,
binding, or IPC that is associated with an attack operation.
Sting [52] provides passive runtime monitoring of processes
for use of bindings associated with attack operations (e.g.,
ﬁle squatting and link traversal). However, Sting only used
the available DAC policies to determine whether an attack
operation would be possible, and did not test for other at-
tack operations. PolyScope’s more accurate computation of
attack operations should improve the effectiveness of such
an approach. To test for luring traversals, one must develop
methods to detect at-risk IPCs rather than ﬁle accesses. The
Jigsaw system [49] provides a method for identifying system
12Recall that we leverage the ﬁnding of Chen et al. [10] that the MAC-to-
DAC mapping for Android systems is one-to-one.
calls that may receive input that could enable luring traversals,
but it does not identify the scope of targets to which luring
may occur. PolyScope identiﬁes a full scope of luring targets
using victim permission expansion, so we will explore the
use of PolyScope to generate test cases for the system calls
identiﬁed by Jigsaw.
8.2 Scoped Storage
Android scoped storage [19] was recently introduced to con-
trol application access to another’s ﬁles in the external stor-
age folders (e.g., Download) that are shared among appli-
cations. For these shared folders, scoped storage limits app
accesses only to the ﬁles they create, except for apps with
the READ_EXTERNAL_STORAGE13 Android permission.
Even in this case, apps cannot modify ﬁles they did not create.
For private folders, scoped storage prevents an app from read-
ing another app’s ﬁles. These restrictions prevent use of victim
permission expansion (see Section 5.3) to create pathname-
IVs and prevent exploitation of many attack operations on
other ﬁle-IVs.
These defenses are enforced by ﬁlesystem in userspace
(FUSE), which has been re-introduced in Android 11. When
a ﬁle operation is issued to external storage, the permission
checking is done at the FUSE-daemon, which leverages the
MediaProvider’s database to keep track of ﬁle ownership.
Scoped storage was deployed as an option in Android 10
(e.g., apps may opt-out), but now is mandatory in Android 11.
Scoped storage impacts PolyScope by preventing many of
the IVs found in external storage folders from being used in
attack operations. In Android 11, MAC and DAC permissions
have been weakened to grant apps access to ﬁles in shared
external storage folders, so PolyScope identiﬁes these as IVs.
Table 5 shows that Android 11 has many IVs between privi-
lege levels T1 and T3. These weakened policies also create
risks among apps at the same privilege level, but we do not
consider that threat in this paper. However, scoped storage pre-
vents attack operations from being exercised on many of these
IVs in external storage, excepting only read-IVs in shared di-
rectories. We estimate that the number of PolyScope IVs with
Operations in Table 2 is reduced from 1,764 by about half
for Android 11 due to scoped storage. While this indicates a
large number of false positives, actually only 30 objects are
misclassiﬁed. Since Table 2 counts the subject-object pairs,
the weakened MAC and DAC policies that grant several sub-
jects access to these objects, which exacerbates the impact.
At present, scoped storage is only applied in external storage
folders, so scoped storage would not block attack operations
on the vulnerable IVs identiﬁed in Section 7.6.
Extending PolyScope to reason about scoped storage is
future work. We have two obvious choices for including
13MANAGE_EXTERNAL_STORAGE provides read/write access to ﬁles
on external storage, but is now a signature-level permission that requires
Google’s approval. At the time of writing, Google halted the granting of this
signature permission due to the workload of app vetting.
2592    30th USENIX Security Symposium
USENIX Association
scoped storage. First, PolyScope could be extended to an-
alyze policies enforced by the FUSE-daemon for scoped
storage analogously to MAC and DAC policies. PolyScope
could be extended to analyze policies enforced by the FUSE-
daemon for scoped storage analogously to MAC and DAC
policies by extending our model of subjects and objects in
Section 5.1 for the policies managed by the MediaProvider.
Second, PolyScope could be extended to reason about the
scoped storage enforcement semantics at large, e.g., by pre-
venting any attack operation in external storage folders. This
approach would be simpler in concept, but one would need
to ensure that PolyScope always had the correct semantics
for scoped storage as the system evolves. Since some ex-
ternal storage folders used for gaming are not processed by
the FUSE-daemon (i.e., are outside scoped storage), track-
ing folders accurately could be non-trivial. We will explore
implementing the ﬁrst option.
9 Related Work
Researchers have long known about the three types of in-
tegrity violations listed in Section 4, but have found it difﬁcult
to prevent programs from falling victim to such threats. A
variety of mechanisms have been proposed to prevent attacks
during name resolution, including defenses for binding and
pathname vulnerabilities. These defenses have often been
focused on TOCTTOU attacks [31, 5]. Some defenses are im-
plemented in the program or as library extensions [12, 35, 13,
46] and some as kernel extensions [28, 36, 9, 34, 47, 48], but
the methods overlap, where some enforce invariants on ﬁle
access [12, 28, 48, 35, 36, 47], some enforce namespace invari-
ants [9, 34], and some aim for “safe” access methods [13, 46].
In general, all program defenses have been limited because
they lack insight into the changing system and all system
defenses are limited because they lack side-information about
the intent of the program [8].
The main defense for preventing ﬁlesystem vulnerabilities
is access control. If the access control policies prevent an
adversary from accessing the ﬁlesystem resources that enable
attack operations, then the system is free of associated vul-
nerabilities. However, the discretionary access control (DAC)
policies commonly used do not enable prediction of whether
a subject may obtain an unauthorized permission [21], so
techniques to restrict DAC [26, 38, 45] and apply mandatory
access control (MAC) enforcement [3, 4] were then explored,
culminating in MAC enforcement systems, such as Linux Se-
curity Modules [55] employed by SELinux [39] and AppAr-
mor [32]. Researchers than proposed MAC enforcement for
Android systems [56, 7], so a version of SELinux [39] target-
ing Android was developed, called SEAndroid [42]. However,
the attack operations we ﬁnd in this paper abuse available
MAC permissions. While a techniques have been developed
to limit processes the permissions available to individual sys-
tem calls [41, 51], such techniques need policy analysis to
determine the policies to enforce.
Researchers have proposed using access control policy anal-
ysis to identify misconﬁgurations that may lead to vulnerabil-
ities [24, 40], but traditionally, access control policy analysis
methods only reason about one policy, such as a mandatory
access control (MAC) policy [40, 25, 11, 50] or an Android
permission policy [14, 53, 54]. However, based on the research
challenges above, we must consider the combination of the
access control policies employed on the system to compute
attack operations accurately. Chen et al. [10] were the ﬁrst
work that we are aware of to combine MAC and DAC policies
in access control policy analysis. Hernandez et al. [22] fur-
ther extended their analysis to include MAC, DAC and Linux
capabilities. However, both of these techniques compute data
ﬂows, which are much more numerous than integrity viola-
tions. Chen et al. look for data ﬂows that may lead to sensitive
data leakage directly rather than attack operations that may
enable such leakage as PolyScope does.
10 Conclusions
Android uses a combination of ﬁlesystem access control mech-
anisms to assure its platform integrity. This paper has pro-
posed PolyScope, a policy analysis tool that reasons over
Android’s mandatory (SEAndroid) and discretionary (Unix
permissions) access control policies, in addition to the other
mechanisms (e.g., Android permissions) that inﬂuence ﬁle
access control. PolyScope is novel in its ability to reason
about permission expansion, which lies at the intersection of
mandatory and discretionary policy. We applied PolyScope
to three different Google Android releases and ﬁve different
OEM Android releases, characterizing the potential for ﬁle-
based attacks such as ﬁle squatting, link traversal, and luring
traversal. In doing so, we identiﬁed two new vulnerabilities
in OEM Android releases and opportunities to direct further
automated testing. Our results suggest that the access con-
trol policy changes introduced by OEMs do not sufﬁciently
address integrity violations for their feature additions.
Acknowledgments
Thanks to our shepherd, Sven Bugiel, and the anonymous re-
viewers. This research was sponsored by the U.S. Army Com-
bat Capabilities Development Command Army Research Lab-
oratory and was accomplished under Cooperative Agreement
Number W911NF-13-2-0045 (ARL Cyber Security CRA)
and National Science Foundation grants CNS-1816282. The
views and conclusions contained in this document are those
of the authors and should not be interpreted as represent-
ing the ofﬁcial policies, either expressed or implied, of the
Combat Capabilities Development Command Army Research
Laboratory of the U.S. government. The U.S. government is
authorized to reproduce and distribute reprints for government
purposes notwithstanding any copyright notation here on.
USENIX Association
30th USENIX Security Symposium    2593
References
[1] Yousra Aafer, Nan Zhang, Zhongwen Zhang, Xiao
Zhang, Kai Chen, XiaoFeng Wang, Xiaoyong Zhou,
Wenliang Du, and Michael Grace. Hare Hunting in
the Wild Android: A Study on the Threat of Hang-
ing Attribute References. In Proceedings of the 22nd
ACM Conference on Computer and Communications
Security, pages 1248–1259, 2015.
J. P. Anderson. Computer Security Technology Plan-
ning Study, Volume II. Technical report ESD-TR-73-
51, AFSC, October 1972.
[2]
[3] D. E. Bell and L. J. LaPadula. Secure Computer Sys-
tem: Uniﬁed Exposition and Multics Interpretation.
Technical report ESD-TR-75-306, Deputy for Com-
mand and Management Systems, HQ Electronic Sys-
tems Division (AFSC), March 1976.
[4] K. J. Biba. Integrity Considerations for Secure Com-
puter Systems. Technical report MTR-3153, MITRE,
April 1977.
[5] M. Bishop and M. Digler. Checking for race conditions
in ﬁle accesses. Computer Systems, 9(2), Spring 1996.