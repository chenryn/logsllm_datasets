usually guided by many #ifdef statements. For example, the
functions designed to bridge 32-bit applications with 64-bit
kernels will be compiled only when CONFIG_COMPAT is enabled.
We would like to cover these functions too.
To do this, we modify the conﬁguration process for both the
Linux and the FreeBSD kernels. For Linux, we rely on the built-
in allyesconfig setting, which effectively enables all CONFIG_*
macro (more than 10,000 items). Similarly, for FreeBSD, we
rely on the make LINT command to output all available options
and enable them all to get the build conﬁguration ﬁle.
B. Compiling source code to LLVM IR
Since the Linux kernel is not yet compatible with the LLVM
toolchain, we compile it with the following steps: 1) we ﬁrst
build the kernel with GCC and collect the build log; 2) we
then parse the log to extract compilation ﬂags (e.g., -I, -D) for
each source ﬁle and feed the ﬂags to Clang to compile the ﬁle
again to LLVM IR; 3) we again use the linking information
in the build log and use llvm-link to merge the generated
bitcode ﬁles into a single module. Files that are incompatible
with LLVM will fail in step 2, which are only eight (out of
15,912 ﬁles in Linux 4.13.2).
For the FreeBSD kernel, although it can be successfully
compiled with Clang, we cannot directly add the -emit-llvm
ﬂag to generate LLVM IR because the compilation process
checks whether the generated object ﬁles are ELF ﬁles and will
abort if not. Therefore, similar to the Linux kernel compilation,
Component
Core modules
Drivers
Filesystem
Networking
Total
# Multi-Reads
Linux
25
760
246
73
1,104
FreeBSD
4
86
9
2
101
# Double-fetch Bugs
FreeBSD
Linux
0
2
0
16
1
2
3
0
1
23
TABLE I: Distribution of multi-reads and double-fetch bugs found
by DEADLINE in the Linux and FreeBSD kernels
we compile the FreeBSD kernel in the normal way, parse the
build log, re-compile the ﬁles to IR, and merge them into a
single module.
VIII. FINDINGS
In this section, we show DEADLINE’s performance in both
detecting multi-reads and double-fetch bugs in kernel software.
Table I summarizes the number of multi-reads detected in the
Linux and FreeBSD kernels and how many of them are actually
double-fetch bugs.
A. Detecting multi-reads
This experiment is conducted on version 4.13.3 for the Linux
kernel and 11.1 (July, 2017 release) for the FreeBSD kernel.
As shown in Table I, DEADLINE reports 1,104 multi-reads in
the Linux kernel and 101 multi-reads in the FreeBSD kernel, as
FreeBSD has a much smaller codebase. Furthermore, besides
device drivers which have been studied in prior works [9], [10],
many other kernel components, including the core modules
(e.g., ipc, sched, etc), might issue multiple fetches from
userspace, and some of them can be buggy.
More importantly, the scale of 1,104 multi-reads is not
suitable for manual veriﬁcation, not to mention keeping up with
the frequent kernel updates. Therefore, this ﬁnding supports
the claims that formal deﬁnitions are needed to deﬁne when
a multi-read turns into a double-fetch bug and that automatic
vetting is needed to alleviate this manual effort. This motivates
the development of DEADLINE.
B. Detecting and reporting double-fetch bugs
Conﬁrming previously reported bugs. We ﬁrst show that
DEADLINE is at least as good as prior works in detecting
double-fetch bugs. In particular, DEADLINE runs against Linux
kernel 4.5, the same version Wang et al. [10] used in their work.
Out of ﬁve bugs reported in [10], DEADLINE found four of
them, including vop_ioctl, audit_log_single_ execve_arg,
ec_device_ioctl_xcmd, and ioctl_send_fib. DEADLINE is
unable to detect sclp_ctl_ioctl_sccb, as DEADLINE com-
piles the kernel for the x86 architecture while sclp_ctl.c is
only compilable for the IBM S/390 architecture. We leave the
detection on other architectures for future work.
Finding new bugs. A more important task for DEADLINE
is to ﬁnd new bugs. This experiment is conducted on version
669
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:58 UTC from IEEE Xplore.  Restrictions apply. 
4.12.7 to 4.13.3 for the Linux kernel and 11.1 (July, 2017
release) for the FreeBSD kernel 2.
Out of all multi-reads found in the kernels, DEADLINE
detected 23 double-fetch bugs in Linux and one bug in FreeBSD.
We manually checked all the bugs and reported them to the
kernel maintainers. The full list of detected double-fetch bugs
are shown in Table II. At the time of writing:
• Nine bugs have been ﬁxed with the patches we provided.
• Four bugs are acknowledged. We are currently working
with the kernel maintainers to ﬁnalize the patches.
• Nine bugs are pending for review but no conﬁrmation has
been received.
• Two bugs are considered as “won’t ﬁx,” as the maintainers
do not think they are exploitable right now.
In summary, the number of reported bugs is signiﬁcantly
higher than in prior works (six in Linux and zero in FreeBSD).
More importantly, while DEADLINE found signiﬁcantly more
multi-reads, it further automatically looks for real double-fetch
bugs in the haystack of multi-reads, which is otherwise beyond
the scale of manual veriﬁcation. Furthermore, we anticipate
that 14 out of the 24 bugs DEADLINE found could never be
found by prior works because of the complications in the bugs,
such as falling out of the empirical bug patterns, requiring
inter-procedural analysis, loop involvement, and that a function
is guarded by #ifdef macros.
Bugs marked as “won’t ﬁx”. We pay special attention to
the two bugs rejected for ﬁxing by the developers, as they
represent potential false alarms by DEADLINE as well as show
the limitations of DEADLINE.
In the case of uhid_event_from_user, the developers ac-
tually acknowledged that the race condition can occur in
userspace; however, they do not believe that this can cause
serious harm, as quoted by one of the maintainers: “With
current code, worst case scenario is someone shortcutting
the compat-conversion by setting UHID_CREATE after uhid_-
event_from_user() copied it. However, this does no harm. If
user-space wants to shortcut the conversion, let them do so...”
In the case of ll_copy_user_md, DEADLINE falsely reports
it due to an assumption on an enclosing function. By con-
structing execution paths within the enclosing function only,
DEADLINE implicitly assumes that if there is an overlapped-
the
fetch, careful developers should ﬁnish checking that
doubly-fetched values are either the same or subject
to
the same constraints. In this case, the checking should be
ll_lov_user_md_size(*kbuf) == lum_size right after the sec-
ond fetch. Otherwise, once the function returns, the developers
lose the opportunity re-assert this relation. However, this
implicit assumption does not hold in this case, as the derived
value of the ﬁrst fetch, lum_size, is passed out of the function
as a return value, and the result of the second fetch, kbuf,
is passed out by pointer. In other words, even outside this
enclosing function, the relation between these two fetches can
still be re-checked.
2We perform bug ﬁnding iteratively as we develop and improve DEADLINE,
which explains why several versions of Linux kernel are used.
(char *s, size_t maxlen) {
len++;
if (maxlen && len > maxlen)
char *p, bt; int error;
size_t len = 0;
// test and check user strlen
for (p = s; ;p++) {
if (copyin(p, &bt, 1))
return NULL;
return NULL;
1 char *smb_strdupin
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25 }
if (bt == 0)
break;
}
p = malloc(len, M_SMBSTR);
// copy the whole string
error = copyin(s, p, len);
if (error) {
free(p, M_SMBSTR);
return NULL;
}
// BUG: p is not NULL-termed
return p;
...
// dispatch to device ioctl
nsmb_dev_ioctl() {
...
// dispatch by command
smb_usr_t2request() {
...
// [!] double-fetch bug
buf = smb_strdupin();
1 // syscall entry point
2 entry: ioctl() {
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25 }
...
}
}
}
}
smb_t2_request() {
...
smb_t2_request_int() {
...
// [!] exploitation
nmlen = strlen(buf);
(a) Buggy function
(b) Call stack for an exploit
Fig. 6: An exploitable double-fetch bug in the FreeBSD kernel. 6a
shows the function ﬂagged as buggy by DEADLINE and 6b shows
the end-to-end call stack in the kernel if a user thread tries to exploit
this bug by issuing an ioctl syscall.
Bug distribution. Aligned with prior research [9], [10], a
majority of double-fetch bugs are found in the driver code,
indicating that drivers are still the most error-prone part in the
kernel. This also aligns with the distribution of multi-reads
where a majority of the multi-reads are located in drivers.
However, ﬁle systems, networking components, or even the
core kernel might also be subject to double-fetch bugs.
Detection time. On a machine with Intel Xeon E5-1620 CPU
(four cores) and 64GB RAM running 64-bit Ubuntu 16.04.3
LTS, DEADLINE ﬁnishes detection in four hours for the Linux
kernel and one hour for the FreeBSD kernel. Around 20% of
the execution time is spent on ﬁnding multi-reads with static
analysis and 80% of the time is spent on symbolic checking
on these multi-reads.
IX. EXPLOITATION
Exploiting double-fetch bugs can be proﬁtable but also
challenging. Prior works [9], [10] have identiﬁed several ways
to exploit a double-fetch bug in kernel.
Leaking information. This exploitation typically occurs in
a process that does data transfer both to and from userspace,
i.e., a request-response situation, as shown in the case of CVE-
2016-6130. The bug in CVE-2016-6130 is very similar to the
bug in perf_copy_attr (Figure 4), where the ﬁrst fetch sanity
checked the size value while the second fetch assumes size
does not change and omitted the sanity check. Later, when the
response is copied back to userspace based on the unchecked
size value, a large chunk of kernel memory will be copied,
hence causing a kernel information leak.
Bypassing restrictions. This exploitation typically occurs
when the kernel wants to early reject a request from userspace.
670
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:58 UTC from IEEE Xplore.  Restrictions apply. 
#
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
File
block/scsi_ioctl.c
drivers/acpi/custom_method.c
drivers/hid/uhid.c
drivers/isdn/i4l/isdn_ppp.c
drivers/message/fusion/mptctl.c
drivers/nvdimm/bus.c
drivers/nvdimm/bus.c
drivers/scsi/aacraid/commctrl.c
drivers/scsi/dpt_i2o.c
drivers/scsi/megaraid/megaraid.c
drivers/scsi/megaraid/megaraid_mm.c
drivers/scsi/mpt3sas/mpt3sas_ctl.c
drivers/staging/lustre/lustre/llite/llite_lib.c
drivers/tty/vt/vt.c
drivers/vhost/vhost.c
fs/coda/psdev.c
fs/nfsd/nfs4recover.c
kernel/events/core.c
kernel/sched/core.c
net/compat.c
net/tls/tls_main.c
net/wireless/wext-core.c
sound/pci/asihpi/hpioctl.c
netsmb/smb_subr.c
Function
sg_scsi_ioctl
cm_write
uhid_event_from_user
isdn_ppp_write
__mptctl_ioctl
__nd_ioctl (1)
__nd_ioctl (2)
aac_send_raw_srb
adpt_i2o_passthru
mega_m_to_n
mraid_mm_ioctl
_ctl_getiocinfo
ll_copy_user_md
con_font_set
vhost_vring_ioctl
coda_psdev_write
cld_pipe_downcall
perf_copy_attr
sched_copy_attr
cmsghdr_from_user_compat_to_kern
do_tls_setsockopt_tx
ioctl_standard_iw_point
asihpi_hpi_ioctl
smb_strdupin
Complication
Status
Acknowledged Macro expansion
Submitted
Won’t Fix
Patched
Submitted
Patched