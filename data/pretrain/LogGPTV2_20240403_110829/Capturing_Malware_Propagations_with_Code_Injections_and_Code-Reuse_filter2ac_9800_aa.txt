title:Capturing Malware Propagations with Code Injections and Code-Reuse
Attacks
author:David Korczynski and
Heng Yin
Capturing Malware Propagations with Code Injections and
Code-Reuse A(cid:130)acks
David Korczynski
University of Oxford
University of California, Riverside
PI:EMAIL
Heng Yin
University of California, Riverside
PI:EMAIL
ABSTRACT
Defending against malware involves analysing large amounts of
suspicious samples. To deal with such quantities we rely heavily on
automatic approaches to determine whether a sample is malicious
or not. Unfortunately, complete and precise automatic analysis
of malware is far from an easy task. (cid:140)is is because malware is
o(cid:137)en designed to contain several techniques and countermeasures
speci(cid:128)cally to hinder analysis. One of these techniques is for the
malware to propagate through the operating system so as to execute
in the context of benign processes. (cid:140)e malware does this by writing
memory to a given process and then proceeds to have this memory
execute. In some cases these propagations are trivial to capture
because they rely on well-known techniques. However, in the cases
where malware deploys novel code injection techniques, rely on
code-reuse a(cid:138)acks and potentially deploy dynamically generated
code, the problem of capturing a complete and precise view of the
malware execution is non-trivial.
In this paper we present a uni(cid:128)ed approach to tracing malware
propagations inside the host in the context of code injections and
code-reuse a(cid:138)acks. We also present, to the knowledge of the au-
thors, the (cid:128)rst approach to identifying dynamically generated code
based on information-(cid:131)ow analysis. We implement our techniques
in a system called Tartarus and match Tartarus with both synthetic
applications and real-world malware. We compare Tartarus to pre-
vious works and show that our techniques substantially improve
the precision for collecting malware execution traces, and that
our approach can capture intrinsic characteristics of novel code
injection techniques.
KEYWORDS
Malware, Taint Analysis, Security, Code Injection
1 INTRODUCTION
Today, malware remains one of the biggest IT security threats that
we have to face. Although the last decade has introduced many
improvements in our defences and has signi(cid:128)cantly raised the bar
for malware authors to be successful, there is still an increasing
number of malware incidents reported each year. Presently, the
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for pro(cid:128)t or commercial advantage and that copies bear this notice and the full citation
on the (cid:128)rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permi(cid:138)ed. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speci(cid:128)c permission and/or a
fee. Request permissions from permissions@acm.org.
CCS’17, Oct. 30–Nov. 3, 2017, Dallas, TX, USA.
© 2017 ACM. ISBN 978-1-4503-4946-8/17/10...$15.00
DOI: h(cid:138)p://dx.doi.org/0.1145/3133956.3134099
(cid:128)ght against malware is challenged by two core, albeit opposite,
problems. On the one hand, anti-malware companies receive thou-
sands of samples every day and each of these (cid:128)les must be processed
and analysed in order to determine their maliciousness. On the
other hand, malicious applications are o(cid:137)en well-designed so(cid:137)-
ware with dedicated anti-analysis features. (cid:140)is makes accurate
and automatic analysis of malware a true challenge. In addition to
this, many of the current tools available are constructed for speci(cid:128)c
reverse engineering purposes, which makes them less applicable to
fully automated procedures and more useful for manually-assisted
analysis tasks.
One problem that has particularly challenged the malware re-
search community is analysis and detection of malware propaga-
tions inside a host system. When malware executes on a host
system, it integrates itself to the system using stealthy approaches,
o(cid:137)en motivated by evasion and privilege escalation. An important
part of our defences is to identify these propagation strategies so
they can be used in host-based intrusion prevention systems (HIPS).
A key aspect of malware propagation strategies is the use of code
injections. In the context of malware, code injection is when the mal-
ware writes code to another processes on the system so as to have
this code execute. When the malware does this, it e(cid:130)ectively exe-
cutes under the context of a legitimate application like white-listed
processes that goes undetected by HIPS. In cases where malware
relies on well-known techniques to inject the code it is easy for
malware analysis systems to identify the code injection. However,
recent reports have shown that novel code injection techniques
can go unidenti(cid:128)ed by (cid:128)ne-grained malware analysis environments
[29, 36] and also bypass modern-day HIPS [27, 45]. (cid:140)is presents
a crucial challenge because false-negatives in both environments
mean that malware can operate without detection for a potentially
long time.
Traditional code injection techniques rely on (cid:128)xed API calls
such as WriteProcessMemory and CreateRemote(cid:138)read where recent
approaches have started adopting exploit-like features such as code-
reuse a(cid:138)acks [2, 27, 29, 45]. (cid:140)is means, instead of writing code to
another process using WriteProcessMemory and creating a thread
in the target process with CreateRemote(cid:138)read, malware will, for
example, write memory to a global bu(cid:130)er, force the target process
to overwrite its own stack with the memory from the global bu(cid:130)er,
eventually resulting in the target process executing a ROP chain
controlled by the malware. In this way the malware achieves execu-
tion in the target process even without explicitly writing memory
to it [27].
(cid:140)e security community has previously investigated automated
analysis of malware propagation and code injection. (cid:140)ese works
can be roughly divided in two groups. One group that has been
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1691focused on automated approaches to unpacking of malware, and
another group focused on detection and analysis of code-reuse
a(cid:138)acks.
Automated approaches to unpacking malware is a well-studied
area [5, 22, 30, 40]. (cid:140)e main focus point of these approaches is how
to uncover and extract dynamically generated code. Code injection
is a natural extension hereof, as we can consider code injections to
be dynamically generated code across processes. (cid:140)e most recent
work on unpacking has indeed investigated this particular prob-
lem [5, 40]. However, the suggested approaches do not address
several challenges posed by recent code injections. For example,
Codisasm proposed by Bonfante et al. [5] relies on hooking Cre-
ateRemote(cid:138)read and CreateRemote(cid:138)readEx in order to monitor
code execution in a di(cid:130)erent process. (cid:140)is excludes their approach
from any code injections that do not rely on these two API calls,
of which there are many [2, 27, 29, 45]. Ugarte et al. [40] make
e(cid:130)orts into monitoring dynamically generated code via (cid:128)le map-
pings and to shared memory sections. However, these techniques
only monitor for dynamically generated code explicitly wri(cid:138)en by
the malware, and do not consider when malware uses code-reuse
a(cid:138)acks. Because of this, their approach will not detect malicious
code that has been dynamically generated via benign code, of which
there has recently been several cases [2, 27, 29, 45].
Similarly to automatic unpacking, automatic detection and anal-
ysis of code-reuse a(cid:138)acks has lately received a lot of a(cid:138)ention
[10, 17, 23, 34]. However, the problem with relying on generic
methods for detecting novel a(cid:138)acks is simply that it is hard, and
analysis of special cases seems inevitable [10, 16]. In fact, a recent
demonstration of a new code injection was shown to bypass both
HIPS and the many exploit-mitigations deployed by Windows [28].
(cid:140)is particular injection technique was adapted by malware not
long a(cid:137)er the technique was published [2] . (cid:140)e problem with the
current tools for analysing code-reuse a(cid:138)acks, besides being few in
numbers, is that these tools provide a local and limited view on the
injection in respect to the entire malware propagation. (cid:140)is makes
them well-suited for aiding reverse engineering but are not well-
adapted for complete and automated analysis of entire malware
propagations [17, 23, 34].
Because of the limitations in previous work and the problems
reported by the malware community, there remains to be found
a general and accurate solution to automatic analysis of malware
propagations with code injections and code-reuse a(cid:138)acks. Before
we proceed, it is natural to consider what is required by such a
solution. Within the entire malware propagation, the malicious
code o(cid:137)en contains several waves of encrypted code even before
performing any code injection, and potentially a(cid:137)er a given code
injection as well. (cid:140)ese encrypted waves of code contain the mali-
cious payload which will be used for analysing the capabilities of
the malware. We therefore consider a complete solution to auto-
mated analysis of malware propagations to both capture malware
execution traces across the entire operating system (OS) and also
raise the execution trace into abstractions in the shape of code
waves and code injections.
In this paper we describe Tartarus, a system for automatically
capturing and analysing malware propagations with code injections
and code-reuse a(cid:138)acks. Tartarus captures the malware execution
based on a novel approach that relies on taint analysis of the entire
malware code in combination with a model of code-reuse a(cid:138)acks.
(cid:140)is combination allows Tartarus to follow malware execution in
the whole OS without relying on any API hooking, and also gives
Tartarus the ability to identify where code-reuse a(cid:138)acks occur.
Tartarus further deploys two novel abstractions upon the malware
execution trace in order to identify dynamically generated code
and code injection techniques.
To the best of our knowledge, Tartarus is the (cid:128)rst malware anal-
ysis system that monitors malware execution based on taint anal-
ysis in combination with code-reuse a(cid:138)acks. Tartarus is also the
(cid:128)rst system that captures dynamically generated code based on an
information-(cid:131)ow model and also has the abilities to automatically
identify code injections and give detailed insights about them. We
have systematically tested Tartarus against several datasets that
demonstrate the operational practicality of Tartarus, its relevance
against todays’ malware landscape as well as its improvements on
previous work.
Our main contributions can be listed as follows:
for identifying dynamically generated code.
‚ We propose a technique for complete malware tracing
based on taint analysis in combination with a model of
code-reuse a(cid:138)acks.
‚ We propose a novel technique based on information-(cid:131)ow
‚ We propose a (cid:128)ne-grained technique as a uni(cid:128)ed approach
for automatically identifying code injections and also pro-
viding detailed insights about them.
‚ We implement our techniques in a practical system called
Tartarus and evaluate it thoroughly against several datasets.
Our results show that Tartarus works well in operational
contexts and improves over previous work in several areas.
2 MOTIVATION AND BACKGROUND
In this section we illustrate the motivation and background for our
work by introducing a running example. We describe each of the
three techniques: (1) dynamically generated code; (2) code-reuse
a(cid:138)acks; and (3) code injections, and use our running example to
describe the limitations of previous work.
2.1 Motivating example
Our running example is a sample collected from the Gapz malware
family and Figure 1 shows the propagation strategy the sample
deploys. (cid:140)e entry point of the malware is given by the black circle
within the Malware.exe process. Solid arrows present control-(cid:131)ow,
dashed arrows present data-(cid:131)ow and wave0 are instructions ex-
plicitly present in the Malware.exe binary image when (cid:128)rst loaded.
When executed, the sample (cid:128)rst deploys one wave of dynamically
generated code (wave1 of Malware.exe). (cid:140)e instructions of this
wave then overwrite a pointer within the legitimate Windows pro-
cess explorer.exe using SetWindowsLong and hijacks control of
the process with a call to SendNotifyMessage. (cid:140)e execution in
explorer.exe is transferred to a sequence of code-reuse a(cid:138)acks
that are responsible for writing shellcode within explorer.exe.
(cid:140)e code-reuse a(cid:138)acks transfer execution to the newly wri(cid:138)en
shellcode and the shellcode itself writes a new wave of dynamically
generated code inside explorer.exe. Finally, this wave continues to
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1692Malware.exe
wave0
4150
instrs
wave1
2700
instrs
explorer.exe
wave2
3567
instrs
SetWindowsLong
SendNotifyMessage
Code-
reuse
attacks
23 instrs
wave1
456 instrs
shellcode
58 instrs
Figure 1: Malware propagation of Gapz.
deploy yet another wave of dynamically generated code with a
substantially larger number of instructions.
2.2 Dynamically generated code
Nowadays, the majority of malware deploy dynamically generated
code. In its simplest terms, dynamically generated code refers to
when an application writes memory at runtime and then proceeds
to execute this memory. Most o(cid:137)en, malware does this by contain-
ing encrypted code inside its binary image and then decrypts this
memory during execution, followed by transferring control to it.
Traditionally, dynamically generated code has been associated
with the concept of packers. From a simplistic point of view, pack-
ers are applications that input a binary and output a new binary
that will dynamically generate the original binary’s code. (cid:140)e main
concern of previous work in unpacking is therefore focused on
automatic ways to uncover the code dynamically generated in the
packed application. (cid:140)e techniques applied by previous solutions
are fundamentally very similar. (cid:140)ey keep a set of all the mem-
ory writes performed by the malware, and then monitor for each
instruction executed in the malware process whether the bytes
making up the instruction is an element of this set.
However, this heuristic is fundamentally limited because it only
monitors code explicitly wri(cid:138)en by the malware. As such, they
do not consider the cases where malware uses benign code to
dynamically generate malicious code on its behalf. (cid:140)is limitation
is visible in our motivating example where previous approaches
to automatically uncovering dynamically generated code would
only include wave0 and wave1 of the Malware.exe process. (cid:140)is is
because Gapz relies on the code-reuse a(cid:138)acks to write the shellcode,
and the shellcode is then in charge of propagating memory wri(cid:138)en
by the Malware.exe process into the explorer.exe process. As a
result, previous approaches will fail to recognize the code-reuse
a(cid:138)acks and all of the malware execution that propagates from this
code.
2.3 Code-reuse attacks
To hijack an application’s control-(cid:131)ow, malware can manipulate
benign code of the application even without writing any code to
the application itself. We call this type of a(cid:138)ack a code-reuse a(cid:138)ack.
One of the most popular techniques of this kind is return-oriented
programming, described by Shacham [38]. (cid:140)e basic idea is to rely
on small sequences of code that end in ret instructions. We call
such code sequences gadgets. (cid:140)e a(cid:138)ack then works by writing an
address to memory such that whenever the target ret instruction
is executed, it will transfer control to the address wri(cid:138)en by the
adversary. By combining these gadgets in meaningful ways, the
adversary can achieve complex computation and in most real-world
cases even Turing complete computation [6, 8]. In the context of
ROP, we call a chain of gadgets a ROP chain.
Code-reuse a(cid:138)acks is not limited to ROP, but are o(cid:137)en lever-
aged with a combination of hijacking other types of indirect branch
instructions. For example, jump-oriented programming (JOP) ex-
plores a similar paradigm to ROP, but focuses on indirect jmp in-
structions instead of ret instructions [4]. Equally, code-reuse at-
tacks can be obtained by hijacking indirect call instructions, and
even a mix all three instruction types. Although it is not shown in
Figure 1, our motivating sample does indeed hijack both ret and
indirect call instructions.
Although there exist several techniques for identifying code-
reuse a(cid:138)acks [10, 17, 23, 34], these are designed to highlight the
use of gadgets and not the overall malware propagation. As can be
seen in Figure 1, the code-reuse a(cid:138)acks only play a very local role
in the malware propagation and does not reveal much about the
sample’s overall structure. As such, these techniques will not be of
much use in fully automatic approaches, but rather serve well in
assisting manual forensics tasks.
2.4 Code injections
Code injection is when a malicious binary writes code to another
process and then proceeds to execute this code. (cid:140)e e(cid:130)ect of code
injections is that execution of the malicious code happens inside a
“legitimate” application. In practice, there are many reasons why
malware use code injections. Two of the most common reasons are
evasion against anti-malware solutions and escalation of process
level restrictions. By nature, dynamically generated code and code
injection techniques are closely related. In order to inject code,
the malware writes the code at runtime, making the injected code
dynamically generated.
Traditionally, malware has relied on a common set of approaches
to inject their code. (cid:140)ese approaches rely on well-known API
calls such as WriteProcessMemory, MapViewOfSection and alike, to
place malicious memory in the context of the target process, and
then execute this code using API calls such as CreateRemote(cid:138)read,
(cid:137)eueUserAPC and Resume(cid:138)read. Previous work on automatic