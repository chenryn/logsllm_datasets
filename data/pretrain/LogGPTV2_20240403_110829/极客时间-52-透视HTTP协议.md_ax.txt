## 对称加密"对称加密"很好理解，就是指加密和解密时使用的密钥都是同一个，是"对称"的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。举个例子，你想要登录某网站，只要事先和它约定好使用一个对称密码，通信过程中传输的全是用密钥加密后的密文，只有你和网站才能解密。黑客即使能够窃听，看到的也只是乱码，因为没有密钥无法解出明文，所以就实现了机密性。![](Images/2c2e74fb336d54bb4830452470356592.png){savepage-src="https://static001.geekbang.org/resource/image/8f/49/8feab67c25a534f8c72077680927ab49.png"}TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES和 ChaCha20。AES 的意思是"高级加密标准"（Advanced EncryptionStandard），密钥长度可以是 128、192 或 256。它是 DES算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法。ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8之后也加入了 AES硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错算法。
## 加密分组模式对称算法还有一个"**分组模式**"的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。最早有 ECB、CBC、CFB、OFB等几种分组模式，但都陆续被发现有安全漏洞，所以现在基本都不怎么用了。最新的分组模式被称为AEAD（Authenticated Encryption with AssociatedData），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。比如，AES128-GCM，意思是密钥长度为 128 位的 AES 算法，使用的分组模式是GCM；ChaCha20-Poly1305 的意思是 ChaCha20 算法，使用的分组模式是Poly1305。你可以用实验环境的 URI"/24-1"来测试 OpenSSL 里的 AES128-CBC，在 URI后用参数"key""plain"输入密钥和明文，服务器会在响应报文里输出加密解密的结果。    https://www.chrono.com/24-1?key=123456 algo  = aes_128_cbcplain = hello opensslenc   = 93a024a94083bc39fb2c2b9f5ce27c09dec   = hello openssl
## 非对称加密对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题：如何把密钥安全地传递给对方，术语叫"**密钥交换**"。因为在对称加密算法中只要持有密钥就可以解密。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。这个问题该怎么解决呢？你或许会说："把密钥再加密一下发过去就好了"，但传输"加密密钥的密钥"又成了新问题。这就像是"鸡生蛋、蛋生鸡"，可以无限递归下去。只用对称加密算法，是绝对无法解决密钥交换的问题的。所以，就出现了非对称加密（也叫公钥加密算法）。它有两个密钥，一个叫"**公钥**"（public key），一个叫"**私钥**"（privatekey）。两个密钥是不同的，"不对称"，公钥可以公开给任何人使用，而私钥必须严格保密。公钥和私钥有个特别的"**单向**"性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。非对称加密可以解决"密钥交换"的问题。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。![](Images/d0d1fd54e564140f945f3048ced87858.png){savepage-src="https://static001.geekbang.org/resource/image/89/17/89344c2e493600b486d5349a84318417.png"}非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如DH、DSA、RSA、ECC 等。RSA可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于"**整数分解**"的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。10 年前 RSA 密钥的推荐长度是 1024，但随着计算机运算能力的提高，现在 1024已经不安全，普遍认为至少要 2048 位。ECC（Elliptic CurveCryptography）是非对称加密里的"后起之秀"，它基于"**椭圆曲线离散对数**"的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法ECDHE 用于密钥交换，ECDSA 用于数字签名。目前比较常用的两个曲线是 P-256（secp256r1，在 OpenSSL 称为prime256v1）和 x25519。P-256 是 NIST（美国国家标准技术研究所）和NSA（美国国家安全局）推荐使用的曲线，而 x25519被认为是最安全、最快速的曲线。ECC名字里的"椭圆"经常会引起误解，其实它的曲线并不是椭圆形，只是因为方程很类似计算椭圆周长的公式，实际的形状更像抛物线，比如下面的图就展示了两个简单的椭圆曲线。![](Images/adedd4718f2fc9b95980d0de8fecfd93.png){savepage-src="https://static001.geekbang.org/resource/image/b4/ba/b452ceb3cbfc5c644a3053f2054b1aba.jpg"}[两个简单的椭圆曲线：y\^2=x\^3+7，y\^2=x\^3-x]{.reference}比起 RSA，ECC 在安全强度和性能上都有明显的优势。160 位的 ECC 相当于 1024位的 RSA，而 224 位的 ECC 则相当于 2048 位的RSA。因为密钥短，所以相应的计算量、消耗的内存和带宽也就少，加密解密的性能就上去了，对于现在的移动互联网非常有吸引力。实验环境的 URI"/24-2"演示了 RSA1024，你在课后可以动手试一下。
## 混合加密看到这里，你是不是认为可以抛弃对称加密，只用非对称加密来实现机密性呢？很遗憾，虽然非对称加密没有"密钥交换"的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，即使是ECC 也要比 AES差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。实验环境的 URI"/24-3"对比了 AES 和 RSA这两种算法的性能，下面列出了一次测试的结果：    aes_128_cbc enc/dec 1000 times : 0.97ms, 13.11MB/s rsa_1024 enc/dec 1000 times : 138.59ms, 93.80KB/srsa_1024/aes ratio = 143.17 rsa_2048 enc/dec 1000 times : 840.35ms, 15.47KB/srsa_2048/aes ratio = 868.13可以看到，RSA 的运算速度是非常慢的，2048 位的加解密大约是15KB/S（微秒或毫秒级），而 AES128 则是 13MB/S（纳秒级），差了几百倍。那么，是不是能够把对称加密和非对称加密结合起来呢，两者互相取长补短，即能高效地加密解密，又能安全地密钥交换。这就是现在 TLS 里使用的**混合加密**方式，其实说穿了也很简单：在通信刚开始的时候使用非对称算法，比如RSA、ECDHE，首先解决密钥交换的问题。然后用随机数产生对称算法使用的"**会话密钥**"（sessionkey），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32字节，所以慢一点也无所谓。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。![](Images/430614375f3d5f12c237811ce4fd3b02.png){savepage-src="https://static001.geekbang.org/resource/image/e4/85/e41f87110aeea3e548d58cc35a478e85.png"}这样混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。不过这只是"万里长征的第一步"，后面还有完整性、身份认证、不可否认等特性没有实现，所以现在的通信还不是绝对安全，我们下次再说。
## 小结1.  [加密算法的核心思想是"把一个小秘密（密钥）转化为一个大秘密（密文消息）"，守住了小秘密，也就守住了大秘密；]{.orange}2.  [对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换，常用的有    AES 和 ChaCha20；]{.orange}3.  [非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有    RSA 和 ECC；]{.orange}4.  [把对称加密和非对称加密结合起来就得到了"又好又快"的混合加密，也就是    TLS 里使用的加密方式。]{.orange}
## 课下作业1.  加密算法中"密钥"的名字很形象，你能试着用现实中的锁和钥匙来比喻一下吗？2.  在混合加密中用到了公钥加密，因为只能由私钥解密。那么反过来，私钥加密后任何人都可以用公钥解密，这有什么用呢？欢迎你把自己的学习体会写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。![unpreview](Images/363506cb904cf225e5fee6b8562eafda.png){savepage-src="https://static001.geekbang.org/resource/image/b4/d7/b437f2b898a2f3424bd8812d9a0dcbd7.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 25 \| 固若金汤的根本（下）：数字签名与证书上一讲中我们学习了对称加密和非对称加密，以及两者结合起来的混合加密，实现了机密性。但仅有机密性，离安全还差的很远。黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能"照单全收"，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。另外，黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和"某宝"通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在"安全"的通信过程中被窃取了。所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。
## 摘要算法实现完整性的手段主要是**摘要算法**（DigestAlgorithm），也就是常说的散列函数、哈希函数（Hash Function）。你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据"压缩"成固定长度、而且独一无二的"摘要"字符串，就好像是给这段数据生成了一个数字"指纹"。换一个角度，也可以把摘要算法理解成特殊的"单向"加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。``{=html}![](Images/ff068c5810344155487289d3568a8ae6.png){savepage-src="https://static001.geekbang.org/resource/image/28/d8/2865d2c77466efb7a480833bcb27f9d8.png"}摘要算法实际上是把数据从一个"大空间"映射到了"小空间"，所以就存在"冲突"（collision，也叫碰撞）的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够"抵抗冲突"，让这种可能性尽量地小。因为摘要算法对输入具有"单向性"和"雪崩效应"，输入的微小不同会导致输出的剧烈变化，所以也被TLS 用来生成伪随机数（PRF，pseudo random function）。你一定在日常工作中听过、或者用过 MD5（Message-Digest 5）、SHA-1（SecureHash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS里已经被禁止使用了。目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。你可以用实验环境的 URI"/25-1"来测试一下 TLS 里的各种摘要算法，包括MD5、SHA-1 和 SHA-2。    https://www.chrono.com/25-1?algo=md5https://www.chrono.com/25-1?algo=sha1https://www.chrono.com/25-1?algo=sha256