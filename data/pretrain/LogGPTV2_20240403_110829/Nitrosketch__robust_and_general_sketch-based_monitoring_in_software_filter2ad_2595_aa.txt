title:Nitrosketch: robust and general sketch-based monitoring in software
switches
author:Zaoxing Liu and
Ran Ben-Basat and
Gil Einziger and
Yaron Kassner and
Vladimir Braverman and
Roy Friedman and
Vyas Sekar
NitroSketch: Robust and General Sketch-based Monitoring
in Software Switches
Zaoxing Liu1, Ran Ben-Basat2, Gil Einziger3, Yaron Kassner4,
Vladimir Braverman5, Roy Friedman4, Vyas Sekar1
1Carnegie Mellon University, 2Harvard University, 3Ben-Gurion University
4Technion, 5Johns Hopkins University
ABSTRACT
Software switches are emerging as a vital measurement vantage
point in many networked systems. Sketching algorithms or sketches,
provide high-fidelity approximate measurements, and appear as a
promising alternative to traditional approaches such as packet sam-
pling. However, sketches incur significant computation overhead in
software switches. Existing efforts in implementing sketches in vir-
tual switches make sacrifices on one or more of the following dimen-
sions: performance (handling 40 Gbps line-rate packet throughput
with low CPU footprint), robustness (accuracy guarantees across
diverse workloads), and generality (supporting various measurement
tasks).
In this work, we present the design and implementation of Ni-
troSketch, a sketching framework that systematically addresses the
performance bottlenecks of sketches without sacrificing robustness
and generality. Our key contribution is the careful synthesis of rig-
orous, yet practical solutions to reduce the number of per-packet
CPU and memory operations. We implement NitroSketch on three
popular software platforms (Open vSwitch-DPDK, FD.io-VPP, and
BESS) and evaluate the performance. We show that accuracy is com-
parable to unmodified sketches while attaining up to two orders of
magnitude speedup, and up to 45% reduction in CPU usage.
CCS CONCEPTS
• Networks → Network monitoring; Network measurement;
KEYWORDS
Sketch, Software Switch, Virtual Switch, Flow Monitoring, Sketch-
ing Algorithm
ACM Reference Format:
Zaoxing Liu, Ran Ben-Basat, Gil Einziger, Yaron Kassner, Vladimir Braver-
man, Roy Friedman, Vyas Sekar. 2019. NitroSketch: Robust and General
Sketch-based Monitoring in Software Switches. In SIGCOMM ’19: 2019
Conference of the ACM Special Interest Group on Data Communication,
August 19–23, 2019, Beijing, China. ACM, New York, NY, USA, 17 pages.
https://doi.org/10.1145/3341302.3342076
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
SIGCOMM ’19, August 19–23, 2019, Beijing, China
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-5956-6/19/08. . . $15.00
https://doi.org/10.1145/3341302.3342076
INTRODUCTION
1
Traffic measurements are at the core of network functions such as
traffic engineering, fairness, load balancing, quality of service, and
intrusion detection [3, 4, 12, 28, 36, 38, 44, 49, 65, 74, 75]. While
monitoring on dedicated switching hardware continues to be impor-
tant, measurement capabilities are increasingly being deployed on
software switches with the transition to virtualized deployments and
“white-box” capabilities (e.g., Open vSwitch [67], Microsoft Hyper-
V [62], Cisco Nexus 1000V [22], FD.io VPP [34], and BESS [39]).
Naturally, we want measurement capabilities to run at high line
rates but impose a small resource footprint to avoid constraining the
main network functions and services that run atop the switch. In this
respect, sketching algorithms appear promising as they provide rigor-
ous accuracy guarantees and support a variety of measurement tasks.
Example tasks include per-flow frequency estimation [17, 27], track-
ing heavy hitters [10, 61, 63, 68, 69], detecting hierarchical heavy
hitters [8, 9, 20, 26], counting distinct flows [6, 7, 55], estimating
frequency moments [5], and change detection [51, 55].
In practice, the performance of sketching algorithms in soft-
ware switches is far from ideal [1, 2, 43]. For instance, Count-Min
Sketch [27] and Count Sketch [17] do not achieve 10M packets per
second (Mpps), and UnivMon [55, 56] runs at 83Mpps vs. 40Gbps line rates.
We begin with background and related work in the next section.
We then present the bottleneck analysis of sketches in §3, the design
that addresses the bottlenecks in §4, and the analysis of NitroSketch
algorithms in §5. After implementation (§6) and evaluation (§7), we
summarize NitroSketch and conclude in §8.
2 RELATED WORK AND MOTIVATION
We begin by providing background on sketching algorithms and mo-
tivate the need for performance improvements in software switches.
We then discuss previous attempts to improve the performance of
software sketch implementations.
Sketches. Sketches are useful for many network measurement tasks
such as: (1) Heavy Hitter Detection to identify flows that consume
more than a threshold α of the total traffic (e.g., based on the packet
or byte counts) [17, 27, 55, 61, 69]; (2) Change Detection to identify
flows that contribute more than a threshold of the total capacity
change over two consecutive time intervals [51, 55, 68]; (3) Car-
dinality Estimation to estimate the number of distinct flows in the
traffic [7, 55]; (4) Entropy Estimation to approximate the entropy of
different header distributions (e.g., [52]); and (5) Attack Detection
to identify a destination host that receives traffic from more than a
threshold number of source hosts [76]. More recent work such as
UnivMon [55] also suggests extensions to support a range of these
tasks, rather than a specialized sketch per task.
At a high-level, sketches are approximate data structures to esti-
mate various statistics of a given streaming workload. A sketch data
structure typically consists of some arrays of counters, and uses a
set of independent hash functions to update these counters. To illus-
trate the common structure of sketches, we consider the Count-Min
Sketch (CMS) [27] as an example. As depicted in Figure 1, CMS
maintains d arrays of w counters each. On its Update procedure, it
computes d independent hash values from the packet’s flow identifier
(e.g., 5-tuple). Each such hash provides an offset within one of the
d arrays, and CMS then increases the corresponding counters. This
data structure can then be used for a number of estimation tasks.
Specifically, the estimate for a given flow’s size is the minimum
value among the corresponding counters for this flow. Using these
+1+1+1+1Pkt+1d-hashesh1…hdw = 9d=5NitroSketch: Robust and General Sketch-based Monitoring
SIGCOMM ’19, August 19–23, 2019, Beijing, China
Figure 2: Packet rates of Sketches, OVS, and DPDK.
per-flow estimates, we can compute other derived statistics such as
quantiles or other traffic summaries.
Sketches are typically designed to reduce the memory usage
of measurement tasks and to achieve guaranteed fidelity for the
estimated statistics. Space efficiency is crucial in hardware as high-
speed memory (e.g., SRAM) is at a premium [41, 57, 72] and line-
rate processing is guaranteed once data structure fits in the memory.
Sketch performance in software switches. In a software switch
context, however, memory may be a less severe constraint. A more
critical goal is to support high line-rates with a low computation
footprint (e.g., using single CPU core). This low footprint is vital to
ensure that other concurrent services (e.g., virtual machine instances)
can make maximal use of the available resources.
To analyze the performance, we profiled a single-thread OVS-
DPDK and the result shows that the CPU room for running added
measurement algorithms is limited. Figure 2 shows the measured
performance of software implementation of sketches atop OVS-
DPDK. (We provide more details on our testbed setup in Section 7.)
We configure the memory allocation of the sketches as recommended
in the respective papers. For Count-Min Sketch, we set 5 rows of
1000 counters; for UnivMon, its Count Sketch components have
five rows of 10000 counters each. We observe that sketches impose
significant overhead and cannot meet 10Gbps line-rate with a single
CPU core for a worst-case workload (i.e., 14.88Mpps with 64B
packets). Even the light-weight Count-Min Sketch [27] is far away
from line rate processing.
Existing solutions. Indeed, we are not alone (nor the first) in point-
ing out these limitations, and these results mirror the measurements
from other efforts [1, 2, 43, 73].
To tackle this performance issue, prior efforts have taken one
of two approaches: (1) eschewing sketches altogether in favor of
simpler data structures or (2) heuristic fixes to sketches. Both ap-
proaches have fundamental limitations and do not meet our goals of
performance, robustness, and generality.