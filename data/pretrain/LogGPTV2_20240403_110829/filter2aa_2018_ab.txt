ssl3 resolved symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
4.5
Client/Server random values in memory
. . . . . . . . . . . . . . . . .
63
4.6
Ncryptsslp “Validate” function symbols . . . . . . . . . . . . . . . . . .
65
4.7
Disassembled ValidateMasterKey function (x64) . . . . . . . . . . . . .
65
4.8
SSL master key instance in memory (x64)
. . . . . . . . . . . . . . . .
67
4.9
SSL master key (ssl5) C data structure . . . . . . . . . . . . . . . . . .
68
4.10 Dereference of CipherSuiteList entry from ssl5 . . . . . . . . . . . . . .
69
4.11 Local Security Authority Sub-System (LSASS) SSL session key (ssl3) data
structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
4.12 Non-LSASS SSL session key (ssl3) data structure . . . . . . . . . . . .
72
vi
Figure
Page
4.13 Non-LSASS SSL session key (ssl3) V-Type data structure (x64) . . . .
73
4.14 SSL ephemeral key (ssl6) and key pair (ssl4) C data structures . . . . .
74
4.15 SSL key pair (ssl4) provider Dereference
. . . . . . . . . . . . . . . . .
75
4.16 Dereferenced KSPK private key DPAPI Blob . . . . . . . . . . . . . . .
76
4.17 NcryptSslKey instances Dereferenced (x64) . . . . . . . . . . . . . . . .
78
4.18 Master key to session ID mapping . . . . . . . . . . . . . . . . . . . . .
79
4.19 Schannel CSslCacheItem parsing (x64) . . . . . . . . . . . . . . . . . .
81
4.20 Schannel CSslCacheItem V-Types (x64)
. . . . . . . . . . . . . . . . .
83
4.21 Volatility LSASSLKey plug-in output . . . . . . . . . . . . . . . . . . .
90
4.22 Decrypted Remote Desktop Protocol (RDP) session . . . . . . . . . . .
91
vii
LIST OF ACRONYMS & ABBREVIATIONS
AES . . . . . . . . . . . . . . . . . . . . Advanced Encryption Standard
API . . . . . . . . . . . . . . . . . . . . Application Programming Interface
ASN.1
. . . . . . . . . . . . . . . . . . Abstract Syntax Notation One
CNG
. . . . . . . . . . . . . . . . . . . CryptoAPI Next Generation
DER
. . . . . . . . . . . . . . . . . . . Distinguished Encoding Rules
DLL . . . . . . . . . . . . . . . . . . . . Dynamic Link Library
DPAPI . . . . . . . . . . . . . . . . . . Data Protection API
DTB
. . . . . . . . . . . . . . . . . . . Directory Table Base
DWORD . . . . . . . . . . . . . . . . . Double Word
IP . . . . . . . . . . . . . . . . . . . . . Internet Protocol
LSASS
. . . . . . . . . . . . . . . . . . Local Security Authority Sub-System
OS . . . . . . . . . . . . . . . . . . . . . Operating System
PDB
. . . . . . . . . . . . . . . . . . . Program Database
PEB . . . . . . . . . . . . . . . . . . . . Process Execution Block
PEM
. . . . . . . . . . . . . . . . . . . Privacy-enhanced Electronic Mail
PFS . . . . . . . . . . . . . . . . . . . . Perfect Forward Secrecy
PKCS . . . . . . . . . . . . . . . . . . . Public Key Cryptography Standards
PKI . . . . . . . . . . . . . . . . . . . . Public Key Infrastructure
PMK
. . . . . . . . . . . . . . . . . . . Pre-Master Key
PMS
. . . . . . . . . . . . . . . . . . . Pre-Master Secret
PoC . . . . . . . . . . . . . . . . . . . . Proof-of-Concept
PRF . . . . . . . . . . . . . . . . . . . . Pseudo-Random Function
viii
PRNG
. . . . . . . . . . . . . . . . . . Pseudo-Random Number Generator
PSK . . . . . . . . . . . . . . . . . . . . Pre-Shared Key
QWORD . . . . . . . . . . . . . . . . . Quad Word
RDP
. . . . . . . . . . . . . . . . . . . Remote Desktop Protocol
RFC . . . . . . . . . . . . . . . . . . . . Request for Comment
SNI
. . . . . . . . . . . . . . . . . . . . Server Name Indicator
SSL . . . . . . . . . . . . . . . . . . . . Secure Socket Layer
SSP . . . . . . . . . . . . . . . . . . . . Security Support Provider
TCP
. . . . . . . . . . . . . . . . . . . Transmission Control Protocol
TLS . . . . . . . . . . . . . . . . . . . . Transport Layer Security
TLV . . . . . . . . . . . . . . . . . . . . Type-Length-Value
UDP
. . . . . . . . . . . . . . . . . . . User Datagram Protocol
VAD
. . . . . . . . . . . . . . . . . . . Virtual Address Descriptor
ix
LIST OF TERMS
Bit
“A contraction of the term ‘binary digit’; the
smallest unit of information storage, which has
two possible states or values. The values usu-
ally are represented by the symbols ‘0’ (zero)
and ‘1’ (one).” (Shirey, 2007, p. 36).
Bitstream
A contiguous linear serialization of bits.
Byte
“A fundamental unit of computer storage; the
smallest addressable unit in a computer’s ar-
chitecture.
Usually holds one character of
information and, today, usually means eight
bits.
(Compare: octet.)”
(Shirey, 2007, p.
43).
Cipher
“A cryptographic algorithm for encryption
and decryption” (Shirey, 2007, p. 61).
Ciphertext
“Data that has been transformed by encryp-
tion so that its semantic information content
(i.e., its meaning) is no longer intelligible or
directly available.” (Shirey, 2007, p. 62).
x
Common Criteria
An international “standard for evaluating in-
formation technology (IT) products and sys-
tems. It states requirements for security func-
tions and for assurance measures. ” (Shirey,
2007, p. 69).
Double Word
“A DWORD is a 32-bit unsigned integer
(range: 0 through 4294967295 decimal). Be-
cause a DWORD is unsigned, its ﬁrst bit
(Most Signiﬁcant Bit (MSB)) is not reserved
for signing.” (Microsoft, n.d.-c, s. 2.2.9).
Encode
“Use a system of symbols to represent in-
formation, which might originally have some
other representation. Example: Morse code.”
(Shirey, 2007, p. 119).
Encryption
“Cryptographic transformation of data (called
”plain text”) into a di↵erent form (called ”ci-
pher text”) that conceals the data’s original
meaning and prevents the original form from
being used. The corresponding reverse process
is ”decryption”, a transformation that restores
encrypted data to its original form.” (Shirey,
2007, p. 119).
xi
Ephemeral
“Refers to a cryptographic key or other cryp-
tographic parameter or data object that is
short-lived, temporary, or used one time.”
(Shirey, 2007, p. 122).
Hash Value
“The output of a hash function.”
(Shirey,
2007, p. 141).
Hash Function
“A (mathematical) function which maps val-
ues from a large (possibly very large) domain
into a smaller range. A ‘good’ hash function
is such that the results of applying the func-
tion to a (large) set of values in the domain
will be evenly distributed (and apparently at
random) over the range.1” (Shirey, 2007, p.
140).
Plaintext
“Data that is input to an encryption process.”
(Shirey, 2007, p. 225).
Pseudorandom
“A sequence of values that appears to be ran-
dom (i.e., unpredictable) but is actually gen-
erated by a deterministic algorithm.” (Shirey,
2007, p. 240).
1In the context of security, hash functions accept variable-length input and produce ﬁxed-length
output
xii
Pseudorandom Function
A function that “uses a deterministic com-
putational process (usually implemented by
software) that has one or more inputs called
‘seeds’, and it outputs a sequence of values
that appears to be random according to spec-
iﬁed statistical tests.” (Shirey, 2007, p. 244).
Quad Word
“A QWORD is a 64-bit unsigned integer.”
(Microsoft, n.d.-c, s. 2.2.40).
Request For Comment
“One of the documents in the archival se-
ries that is the oﬃcial channel for IDOCs and
other publications of the Internet Engineer-
ing Steering Group, the Internet Architecture
Board, and the Internet community in gen-
eral.” (Shirey, 2007, p. 250).
1
CHAPTER 1. INTRODUCTION
The forensic analysis of digital media has rapidly advanced over the course of
the last decade, vaulting from the fringes of forensic science to prominence and
acceptance within both the forensic community and the public eye. This explosion
has been in part fueled by the rapid expansion of technology into nearly every facet
of daily life. These digital systems, from traditional personal computers, to smart
phones, vehicles, and intelligent appliances, are increasingly storing, processing, and
transmitting data that is providing critical context in cases and investigations
around the world.
More recently emerging as a sub-discipline of digital forensics is volatile
memory forensics, focused on the incredible wealth of information that can be
gleaned from capturing this ephemeral storage media. As the size of persistence
storage both increases and becomes ever more economical, the smaller volatile
memory that holds the salient points of recent activity is being turned to as a great
triage mechanism. It stands on its own merits, however, providing exclusive access
to items of evidentiary value that are simply unobtainable from any other source.
Driving the expansion of interest in volatile memory forensics has been the
enumeration of artifacts belonging to the proliﬁc Windows family of operating
systems, and the development of tools that have abstracted the complexities of
understanding Windows memory management, making the volatile medium far more
accessible. It is upon this driver for development that the author builds, seeking to
explore the extraction of Windows SSL/TLS secrets from within volatile memory.
2
1.1 Statement of Problem
Currently, there exists no reliable or automated way to forensically decrypt
SSL/TLS connections that leverage ephemeral key negotiations as implemented by
the modern Windows operating system. Since Secure Socket Layer was ﬁrst put
forth by Netscape and later galvanized in an RFC, the concept of Public Key
Infrastructure (PKI) and the key exchange has been central to its security. The
private key has historically been the penultimate secret, stored persistently with the
server and used across all key exchanges to decrypt the pre-master secret. This has
proved to be its Achilles’ heel from a security standpoint, as the private key can be
leveraged to retroactively decrypt the handshake of any session between the server
and clients for which the key was used indeﬁnitely. It has also been suggested that
the key itself may often outlive a certiﬁcate renewal, being used across regenerated
certiﬁcates (Taubert, 2014).
The advent of Perfect Forward Secrecy (PFS), a property that means past
connections are secure from future decryption (accomplished in SSL and Transport
Layer Security (TLS) through use of “throw-away” ephemeral keys), has proved a
double-edged sword for network defenders, law enforcement activity, and attackers
alike. On the one hand, it helps ensure the conﬁdentiality of mission critical
information against future theft; however, it similarly imposes a barrier to access
when used nefariously to exﬁltrate information from a network or shroud illicit
activities.
Still, the implementations of PFS for TLS in practice have been mired by
conﬂicting objectives. The desire for quick reconnection through the use of “Session
Resumption” has meant caching of SSL/TLS secrets in main memory, or even to
disk. This has been well-documented in instances of Web servers, like Apache or
NGINX (Dreijer & Rijs, 2013) on Linux and Unix systems, but has not seen the
same level of scrutiny in Windows, possibly owing to the closed-source nature of the
material.
3
Beyond simply decryption of connections, the attribution or trace evidence of
connections, while perhaps less interesting to an attacker, would still provide
potentially invaluable context to an Incident Responder investigating a suspect
system, or a forensic analyst working a case. Artifacts like public certiﬁcates or
negotiated connection parameters could furnish clues about attack vectors or the
intent of a given connection, but currently are not well documented artifacts on
Windows-based systems.
1.2 Signiﬁcance
As ephemeral cipher suites become increasingly popular and are embraced by
the Windows operating system, it will become more important to identify a reliable
and forensically sound mechanism to decrypt them. Windows components like Edge
(and Internet Explorer), RDP, Outlook, Skype, Windows Update, SQL Server, IIS,
Microsoft Exchange, and LDAPS (Active Directory mechanism) all leverage the
Windows SSL/TLS implementation and will likely embrace PFS as a desired or
default property in the future (Microsoft, 2015d). Anecdotal testing on Windows
10, suggests that it already does prefer ephemeral cipher suites. Other third-party
applications (like the popular Citrix client) that leverage Windows libraries for
SSL/TLS negotiation will also likely follow the system preference. This gives rise to
several use cases for a legitimate capability to retroactively decrypt connections that