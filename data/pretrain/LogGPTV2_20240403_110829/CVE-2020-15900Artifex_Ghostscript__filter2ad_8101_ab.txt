要获得我的交互对象和对应的引用，思路如下：
  * 创建若干在内存中可被识别（即不会随机出现）的数字。
  * 搜索我们可以读取/写入的堆区域，以查找`ref_t`与该数字匹配的结构。
  * 通过设置类型位将一个更改为另一种类型（浮点数）。
  * 浏览我的许多副本，直到找到一个浮点数。
  * 获得一种稳定的方式来读取/写入Ghostscript中的值，并剪切出与其`ref_t`在内存中的表示形式相对应的 字符串部分。
更改`ref_t`变量基础上的原始对象的能力可以改变游戏规则。通过将其设置为长度合理的字符串类型，然后在内存中的任何位置设置其地址，我们可以读取/写入所指向的结构。通过将任何对象写入变量，我们可以读出实际数据在内存中的地址。
### 4.3. 尝试利用
一般情况下我们碰到内存损坏漏洞时都会考虑注入一些shellcode或ROP链到内存中，来修改一些指针地址使其执行我们的恶意代码。但是，现代操作系统保护措施，如ASLR，DEP，堆栈保护器等使得这些在实战利用中变得比较困难。我暂时决定先以一种较为简单的方式来进行漏洞利用！  
我的思路如下：  
Postscript语言功能齐全，能够执行任意系统命令、读写文件以及我们想要的所有功能，这些功能由内存中的某个标志来表示。该平台以前的错误集中在禁用较早版本的沙箱作为目标，尽管沙箱的位置已移动，但将其作为最终目标还是有意义的。我们只需要找到该字节。
确定好思路后，切入点就是`启动沙箱`的代码点。由于Ghostscript是开源的，因此可以在其项目地址中找到相关代码。文档显示它已通过
`.activatepathcontrol` 运算符打开，搜索显示该运算符已在如下第958行处注册：
    //https://github.com/ArtifexSoftware/ghostpdl/blob/ghostscript-9.52/psi/zfile.c#L958
    {"0.activatepathcontrol", zactivatepathcontrol},
可以在这里找到实现此功能的函数`zactivatepathcontrol()`：
    //https://github.com/ArtifexSoftware/ghostpdl/blob/ghostscript-9.52/psi/zfile.c#L920
    //详情如下
    static int zactivatepathcontrol(i_ctx_t *i_ctx_p)
    {
        gs_activate_path_control(imemory, 1);
        return 0;
    }
从上得知只是调用了`gs_activate_path_control()`函数：
    //https://github.com/ArtifexSoftware/ghostpdl/blob/ghostscript-9.52/base/gslibctx.c#L912
    //详情如下
    void
    gs_activate_path_control(gs_memory_t *mem, int enable)
    {
        gs_lib_ctx_core_t *core;
        if (mem == NULL || mem->gs_lib_ctx == NULL ||
            (core = mem->gs_lib_ctx->core) == NULL)
            return;
        core->path_control_active = enable;
    }
该函数从一个`gs_memory_t`对象开始，从该对象中检索`gs_lib_ctx`字段，从该字段检索`core`字段，然后将其中的`path_control_active`值设置为1。因此，如果我们得到一个`gs_memory_t`对象，我们可以按照相同的过程来进行操作，写入一个0以取消设置标志。  
在查看了许多不同的Postscript数据类型之后，我发现`字典`类型中引用了内存`memory`字段，如下：
    //https://github.com/ArtifexSoftware/ghostpdl/blob/ghostscript-9.52/psi/idict.h#L32
    //详情如下
    struct dict_s {
        ref values;         /* t_array, values */
        ref keys;           /* t_shortarray or t_array, keys */
        ref count;          /* t_integer, count of occupied entries */
        /* (length) */
        ref maxlength;      /* t_integer, maxlength as seen by client. */
        ref memory;         /* foreign t_struct, the allocator that */
        /* created this dictionary */
    #define dict_memory(pdict) r_ptr(&(pdict)->memory, gs_ref_memory_t)
    #define dict_mem(pdict) r_ptr(&(pdict)->memory, gs_memory_t)
    };
事实证明，字典类型可以引用内存分配器`gs_memory_t`，初步推测如此，这样做以便在添加更多键的情况下，字典可以使用它来分配更多内存以对自身进行扩展。整个字典结构由一系列`ref_t`结构组成，指向进一步的记录。  
通过将系统字典写入变量中，其地址将存储在基础变量`ref_t`结构中。然后，我们将此引用更改为长度合理的字符串，并通过读取该字符串可以从字典结构中来提取指针。由于`ref_t`结构在所有系系统架构、编译器和操作平台上的大小都是固定的，并且字段通常按顺序进行存储，因此第五个`ref_t`引用的后半部分的偏移量应始终是16个字节
(128 位) 加上 8 个字节 (64 位)
的四倍再减去72个字节以获得正确的偏移量。计算出偏移量之后，我们就可以创建一个指向它的字符串引用，复制出指针，然后将它们写回到我们的`ref_t`引用中，以跟随指针到达下一个结构。  
当我们编译Ghostscript项目（其用C编写）时，对应的编译器根据其某种约定决定如何在内存中布置数据结构，该约定因架构和平台的不同所实施的规则也不同。然后，这些容易被识别的标识
(如 “core”) 都被转换为数据结构中的一个偏移量，例如80，可以直接在编译的代码中使用。  
提取字段的每一步都要求我们知道特定字段在结构中的偏移量。这在不同的体系结构之间有所不同，并且我们正在测试不同的版本，没有设置编译器，因此需要从二进制文件中提取。为此，我们通过[`Ghidra`](https://www.nsa.gov/resources/everyone/ghidra/)反编译了官方库版本（在本例中为`gsdll64.dll`），找到了该`gs_activate_path_control()`函数，该函数是包装器调用的唯一函数，并导出为API的一部分，并按顺序拉出要添加到指针的偏移量，在本例中为`0xd0`，`8`
和`0x88`：  
### 4.4. 漏洞影响
上述操作的最终成果是关闭了Ghostscript引擎的沙箱功能，之后我们可以继续寻找命令执行和文件读写的利用方法。
## 5\. 结论
尽管沙箱功能正在逐步完善，但Postscript渲染过程仍然存在很大的攻击面，并且我认为在完全不受信任的输入（例如外部文件）前提下运行Ghostscript非常危险。通过简单的模糊测试，我们在几天内从一个简单的模糊运行中发现了大量未分类的崩溃，尽管报告的是我们知道唯一可以利用的崩溃。如果你工作中存在这类使用场景，不要认为开启沙箱就足够安全，建议使用进一步的隔离措施，例如在低特权用户帐户下运行程序或使用应用沙箱，甚至让其在独立的主机上运行。同时也不要认为这样的项目是公开的，就认为它们进行过全面的代码审计已修复过一些浅显的问题，这些想法比较天真。