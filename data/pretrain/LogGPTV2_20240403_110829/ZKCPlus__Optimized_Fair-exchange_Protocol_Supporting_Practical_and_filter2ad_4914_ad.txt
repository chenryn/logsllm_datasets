knowledge of (x, k) s.t.
ğœ™(x) = 1 âˆ§ z = Enck(x) âˆ§ h = H(k),
â€¢ B on receipt of (z, h, ğœ‹) runs b â† Î .Verify(cid:0)ğœ, (z, h), ğœ‹(cid:1), aborts
and sends the tuple (z, h, ğœ‹) to B;
(20)
if b = 0, otherwise builds a transaction tx = (p, h)sigB which
pays funds p to one who opens the hash-lock h by revealing
its preimage, and sends tx to J;
2. Reveal: S checks if tx posted by B contains the designated hash
image h, aborts if not, otherwise reveals k;
3. Finalize: On the revealed k, J executes tx if H(k) = h, which
will transfer Bâ€™s funds p to S, otherwise the funds are returned
to B. If k is correct, B can retrieve the digital good by running
x â† Encâ€“1
k (z).
A ZKCP protocol is said to be secure if it fulfills the following
criteria:
â€¢ (buyer fairness) for any possibly malicious seller Sâˆ—, if its balance
increases with non-negligble probability, then the buyer B learns
some xâ€² s.t. ğœ™(xâ€²) = 1;
â€¢ (seller fairness) for a seller S interacting with a possibly mali-
cious buyer Bâˆ—, if Sâ€™s balance does not increase, then except for
negligible probability, Bâˆ— learns no information of x, apart from
what can be inferred from ğœ™.
As for its performance, the most important metric is end-to-end
throughput, the amount of data transferred from S to B in unit
time.
The original ZKCP design uses Pinocchio/BCTV14 zkSNARK for
Î , and SHA256-based stream cipher for Enc [9]. In retrospect, we
observe that these choices are not optimal. As for Î , although Pinoc-
chio/BCTV14 [7, 46] (and its variate Groth16 [32]) have many strong
points, including constant proof size and very efficient verifier, they
also have some significant drawbacks. For one thing, they require a
trusted CRS, but relying on a trusted third party to produce the CRS
contradicts ZKCPâ€™s very premise of being trustless. So ZKCP in-
stead entrusts the buyer B to produce the CRS. Unfortunately, this
circumvention turns out to be problematic: the proof system has
to ensure subversion zero-knowledge to prevent B from learning
information about x [13, 25], but subversion zero-knowledge is usu-
ally too expensive to be of practical use. For another, the throughput
of a ZKCP protocol is jointly determined by both parties. While
these zkSNARKs offer extremely efficient verifier, it is the prover
efficiency that sets the upper limit on the overall throughput. An-
other prominent merit of these schemes, namely the constant proof
size, does not help too much either, since in ZKCP the proof is
transferred off chain alongside with the linear-sized ciphertext.
Also concerning Enc and H, many zero-knowledge-proof-friendly
ciphers and hash functions emerge in recent years. Operating na-
tively in large prime fields (or binary fields), they promise compara-
ble security strength as AES or SHA256 with orders of magnitude
less constraints in the circuits. Incorporating these schemes into the
existing ZKCP protocol can vastly boost the protocolâ€™s performance.
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea30084.2 Construction of ZKCPlus
We propose a variate of the ZKCP protocol, which we call ZKCPlus,
as listed in details in the following. By ZKCPlus we aim at adapt-
ing ZKCP to efficient and flexible fair exchange of data on large
scale.Henceforth we write the digital good in vector form x âˆˆ Fn
p,
and accordingly its ciphertext z âˆˆ Fn
p.
1. Commit: S runs (cx, rx) â† Com.Commit(pp, x), and publishes
2. Validate:
the commitment cx;
â€¢ B posts predicate ğœ™, which specifies a relation R, possibly with
input s, s.t. ğœ™(x) = 1 iff R(s, x) = 1;
â€¢ S runs ğœ‹ğœ™ â† Î Com.Prove(ğœ, (s, cx), (x, rx, aux)) using a CP-
NIZK argument Î Com, with aux being auxiliary witness;
â€¢ B blindly checks whether x is satisfying by running b â†
Î Com.Verify(ğœ, (s, cx), ğœ‹ğœ™), and aborts if b = 0;
â€¢ S chooses a key k, encrypts x by z â† Enck(x), and produces
a â€œproof of deliveryâ€ by
3. Deliver:
ğœ‹z â† Î Com.Prove(ğœ, (z, cx, h), (x, k, rx, aux))
â€¢ B runs b â† Î Com.Verify(cid:0)ğœ, (z, cx, h), ğœ‹z
which attests the knowledge of (x, k) s.t. z = Enck(x)âˆ§H(k) = h;
S sends out tuple (z, h, ğœ‹z);
erwise builds a transaction tx = (p, h)sigB which pays funds p
to who presents the preimage of h, and sends tx to J;
(cid:1), aborts if b = 0, oth-
4. Reveal: (same as ZKCP);
5. Finalize: (same as ZKCP).
4.2.1 Modifications as compared to ZKCP ZKCPlusâ€™s core mod-
ification is to replace Pinocchio/BCTV14 zkSNARKs by CP-NIZK
argument schemes. The digital good x in exchange is committed
in the first place, and all later proofs refer to its commitment cx. In
this respect, we can say ZKCPlus is more â€œdata-centricâ€. Moreover,
the modularity of CP-NIZK arguments allows finer-gained organi-
zation of the protocol. Concretely, we split â€œvalidateâ€ and â€œdeliverâ€
into two phases. In a â€œvalidateâ€ phase, B posts desired predicate ğœ™,
whereas S responds with a proof ğœ‹ğœ™ for
ğœ™(x) = 1.
(21)
Then in a â€œdeliverâ€ phase, S sends out ciphertext z, accompanied
by a â€œproof of deliveryâ€ ğœ‹z attesting that z is faithfully computed
from x using encryption key k, namely
z = Enck(x) âˆ§ h = H(k).
(22)
Note relations in (21) and (22) share input of x. Given the compo-
sition properties of CP-NIZK arguments, ğœ‹ğœ™ and ğœ‹z jointly attests
their conjunction of (20).
We use the CP-NIZK argument described in the previous section
in ZKCPlus whenever a computation is data-parallel. In particular,
with a block cipher running in CTR mode, the encryption procedure
in the â€œdeliver" phase is in fact data-parallel. We develop a â€œproof
of deliveryâ€ based on this observation.
4.2.2 Proof of delivery We use MiMC-p/p block cipher in CTR
mode for the encryption scheme Enc. More specifically, the i-th
element of z (denoted zi) is computed from the i-th element of x
(denote xi) by
zi = xi + Ck(nonce + i).
(23)
ai =
bi =
ci =

,
As illustrated in Figure 1, this is in essence a data-parallel computa-
tion, where i-th block cipher runs on inputs of xi, k and (nonce + i),
and produces output zi. Therefore, the CP-NIZK argument for
data-parallel circuits in Section 3 applies. In aggregation, we write
k = k Â· 1 = [k, k, . . . , k], ctr = [nonce + 1, nonce + 2, . . . , nonce + n];
ctr and z are public, whereas x and k are private and committed as
(24)
Note that cx is the very commitment of x sent in the â€œcommitâ€
phase. We employ the argument described in Section 3 to prove the
(ck, rk) â† Commit(pp, k).
(cx, rx) â† Commit(pp, x),
relation
,
p
(25)
jâˆˆ[m] Aij Â· vj,
jâˆˆ[m] Bij Â· vj,
jâˆˆ[m] Cij Â· vj,
iâˆˆ[m] ai â—¦ bi = ci
A, B, C âˆˆ FmÃ—m
p
ctr, z âˆˆ Fn
p,
cx, ck âˆˆ G;
{vj âˆˆ Fn
p}jâˆˆpriv,
rx, rk âˆˆ Fp
where A, B, C âˆˆ FmÃ—m
are the R1CS coefficient matrices for C, with
public assignments {vj}jâˆˆpub = {ctr, z}, and committed assignments
{vj}jâˆˆcms = {x, k}.
âˆ§ Check(pp, cx, x, rx) = 1
âˆ§ Check(pp, ck, k, rk) = 1
Taking advantage of the composition property of Î Com, we can
even omit the hash-lock h, and instead use the commitment ck for
k as the lock. Specifically, in the â€œdeliverâ€ phase, S sends ck in place
of the hash image h, and correspondingly, in the â€œrevealâ€ phase it
reveals a pair of (k, rk). The arbiter J, checks whether
Check(pp, ck, (k Â· 1), rk) = 1.
(26)
In ZKCPlus the arbiter J is instantiated by a smart contract on
blockchain whose computational power is limited. To prevent the
linear overhead of (26), it may store a pre-computed G0 = âŸ¨1, GâŸ©,
and check the revealed (k, rk) pair by
k Â· G0 + rk Â· H ?= ck.
(27)
While security of the hash lock is built on the collision- and preimage-
resistance of the hash function H, here we rely on the the binding
and hiding properties of the Pedersen commitment scheme to en-
sure that neither S nor B can cheat with ck. Refer to Appendix E
for more details.
Theorem 4.1. ZKCPlus is a secure ZKCP construction, given that
the embedded CP-NIZK argument Î Com satisfies completeness, com-
putational knowledge soundness and zero-knowledge.
We include a sketch of the proof for Theorem 4.1 in Appendix E.
4.3 Functionalities and extensions
By incorporating the composition property of CP-NIZK arguments,
ZKCPlus can support some functionalities that could be difficult or
inefficient for the original ZKCP design.
4.3.1 Compositions of predicates Due to composability of Î Com,
it is possible to further split the â€œvalidateâ€ phase into multiple
rounds. In each round, B challenges with a predicate ğœ™(i), possibly
dependent on previous predicates, and S responds with a proof ğœ‹(i)
attesting ğœ™(i)(x) = 1. {ğœ‹(i)} jointly validates the relation
ğœ™(i)(x) = 1.
(28)

i
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3009Of these predicates, some may be data-parallel while others not. We
can use the argument in Section 3 for those are, and other suitable
CP-NIZK arguments for those are not, as long as they refer to the
same initial commitments.
By this modular approach, ZKCPlus is capable of building up
very complicated predicates, or validating a predicate that holds up
to a probability threshold. See 5.1 for an example.
4.3.2 Selective transfer With ZKCPlus, it is easy to implement
a â€œselective transferâ€ mode, where after the â€œvalidateâ€ phase, B
decides that it is interested in purchasing only a subset of the bulk
x, so it uses a binary mask b âˆˆ {0, 1}n, marking the wanted part of
x by 1 and the rest by 0. Accordingly, S runs the â€œdeliverâ€ phase
on input of xâ€² = x â—¦ b, combined with an adaptor Î Com
link attesting
that xâ€² is consistent with the original x s.t. the linking function
f (x, xâ€²) = âŸ¨x, b â—¦ yâŸ© â€“ âŸ¨xâ€², yâŸ© = 0
(29)
holds for randomly sampled y $â† Fn
p. By Schwartz-Zippel lemma,
|Fp|, f (x, xâ€²) = 0 implies
except for a negligible soundness error n
that xâ€² = x â—¦ b. Note that (29) is about a sum of two inner vector
products, so the argument in Appendix B.2 applies. We include one
example for this mode in Section 5.2.
4.3.3 ZKCSP A zero-knowledge contingent service payment (ZKCSP)
[13] protocol allows payment for digital services rather than digital
goods. Take file storage service as an example. B will pay if S can
prove the integrity of a stored file, without actually retrieving the
file. ZKCSP utilizes a pair of claw-free hash functions (H1, H2), for
which finding a pair (x1, x2) s.t. H1(x1) = H2(x2) is computationally
infeasible. For a designated file x and predicate ğœ™ s.t. ğœ™(x) = 1 iff x
is intact, S selects k
$â† Fp, computes a hash lock h â† H1(k), and a
proof ğœ‹ for the relation
(cid:0)H1(k) = h âˆ§ ğœ™(x) = 1(cid:1) âˆ¨ (cid:0)H2(k) = h âˆ§ ğœ™(x) = 0(cid:1).
(30)
S sends out tuple (ğœ‹, h), and B on verification of ğœ‹ sends out a
conditional transaction tx = (p, h)sigB locked on h. If S reveals a k
s.t. H1(k) = h, J executes the transaction and finalizes the payment.
Then by skipping the â€œdeliverâ€ phase, ZKCPlus naturally adapts
to the ZKCSP scenario. Moreover, in ZKCPlus the initial commit-
ment cx for x is reusable for multiple runs of the protocol. This
comes in handy for a long-term file storage service, where the
integrity of x has to be checked from time to time.
5 Applications
As an extension of ZKCP, ZKCPlus supports all possible applications
of ZKCP. In particular, we describe how it adapts to trading sudoku
solutions in Appendix F. But ZKCPlus is not limited to this. With
its modular nature, it applies to a broader scope of applications, and
some of them are of practical interest. In this section, we develop
a comprehensive example of trading a trained CNN model in the
MLaaS context. We also explore ZKCPlusâ€™s potential application in
cloud database systems.
5.1 Pay to CNN model
MLaaS allows a computationally limited client to delegate the heavy
tasks of training machine learning models to an untrusted server
who has ample computational resources. With prescribed model
architecture and hyperparameters, the server does the training, and
sells the trained parameters (e.g., weights and biases) as a digital
good. The client is willing to pay for the trained model only if it
shows sufficiently high accuracy. To achieve fairness, the question
arises as how the client can test the modelâ€™s accuracy without
knowing any of the trained parameters.
This becomes easy with ZKCPlus. Take CNN for image classifica-
tion as an example. First, in the â€œcommitâ€ phase the server publishes
the commitment c to the trained parameters of the model. Then
in the â€œvalidateâ€ phase, the client challenges with some test im-
age. The server runs the trained model on the test image, acquires
a classification result, and generates a proof ğœ‹ using a CP-NIZK
argument with reference to the commitment c. The client exams
the classification result and its accompanying proof, and aborts
if either is wrong. Otherwise, the client should be confident that
the model applied to the test image yields correct classification. If
the client decides that one testing result is not convincing enough,
ZKCPlus allows multiple rounds of challenges. The more rounds of
successful challenges are performed, the more confident the client
will be, until eventually it decides to accept or to abort.
Moreover, we note that many machine learning related com-
putations are data-parallel. Typically, a CNN model is organized
as a series of consecutive layers, including convolutional layers,
activation layers, pooling layers, fully connected layers and oth-
ers, whereas each of these layers consists of an array of identical
units (i.e., neurons) running in parallel. The CP-NIZK argument for
data-parallel computations of Section 3 adapts smoothly to most of
these layers.
Convolutional layer Convolutional layer convolves an input
feature map with a series of filters, and outputs a new feature map.
For simplicity, we write the input feature map as vector x âˆˆ Fn
p,
and the filter as vector t âˆˆ Fk
p of size k  0,
if xi â‰¤ 0.
It is fully data-parallel, so the argument of Section 3 applies.
Pooling layer We consider the widely used pooling layer, max
pooling, which reduces the size of a feature map by dividing it into
small patches and extracting the local maximum of each patch. We
assume the usual case of 2Ã—2-pixel patches. For an input feature map
x âˆˆ Fn
such
that their respective i-th elements {x(0)
, x(3)
} constitute a
2 Ã— 2-pixel patch. Local maximums of these 2 Ã— 2-pixel patches
i
i
constitute a quarter-sized output feature map xâ€² âˆˆ Fn/4
p , whose i-th
element is
p, we divide it into 4 segments x(0), x(1), x(2), x(3) âˆˆ Fn/4
, x(1)
i
, x(2)