mistakenly viewed as an incompatible type
402
Such provider-conscious design is
rare in software systems but is some-
what fashionable in cryptographic
library designs. Allowing different
providers has a few advantages. For
example, the developer can plug in
a  native-code  implementation  to
make  use  of  an  already  resident
cryptographic  package  or  a  hard-
ware-based solution. Also, there are
any number of reasons that a partic-
ular user may prefer one provider
over another.
We emphasize that our design is
open  so  that  any  cryptography
provider can choose to implement to
our APIs and make the implementa-
tion available commercially.  We do
not  follow  a  controlled-provider
approach and do not seek to certify
or restrict providers on the basis of
export control or other reasons.
Secure communication. Appli-
cations built with JDK can provide
secure network-based communica-
tions at link level, as in Sun Microsys-
tems’ SKIP technology, or at session
level, as in Netscape’s SSL protocol
(see  Glossary).  JavaSoft  supports
open standards that solve our cus-
tomers’ technical needs, but we can
only  operate  within  our  business
restrictions. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply. 
App 1
App 2
App n
App 1
App 2
App n
System domain
System domains
Net I/O
File I/O
AWT
Printer
Figure 4. Java runtime domain architecture.
Net I/O
File I/O
AWT
Printer
For example, SSL and SKIP support different “ﬂavors,” in
that the user has a choice of which algorithm to use for key
exchange and which to use for encrypting trafﬁc. One ﬂavor
would be to use Difﬁe-Hellman for key exchange and triple-
DES for trafﬁc encryption.
However, some of these algorithms are proprietary, so it
is practically impossible to include them in a toolkit such as
JDK. This means that, as part of JDK, Java-based implemen-
tations of SSL and SKIP may be available in a limited num-
ber of ﬂavors, while end-user products may bundle SSL and
SKIP in fuller ﬂavors.
Flexible security policy. The sandbox as it stands now
is  fixed  and  hard  to  change  (and  it  is  not  meant  to  be
changed lightly). To allow for ﬂexible security policies, we
must have mechanisms for supporting ﬁne-grained authen-
tication and authorization.
Java will be deployed on a wide range of platforms, where
user authentication takes place in various forms—from sim-
ple password-based login to public-key technology with
hardware support. Therefore, we must allow multiple ways
to establish identity, but provide a uniform way to access
such identity information.  One beneﬁt of this approach is
that the Java runtime can support features such as single
sign-on and interface with legacy systems.  
Authorization at runtime depends on many factors, includ-
ing the code base (whether it is local or remote, and which
hosts),  whether  the  code  is  signed  and  by  whom,  and
whether we recognize and trust the signers. We envision
specifying a policy in terms of sets of permissions, where
any piece of code runs with a permissions set in effect.
The permissions format is typed in the sense that it allows
for extension and customization. For example, the follow-
ing are three permissions JavaSoft has specified to permit
reading a ﬁle, connecting to a speciﬁed host at a particular
port number, and exiting the Java runtime.
COM.JavaSoft File read path
COM.JavaSoft Net connect remoteIP:port
COM.JavaSoft Runtime allow system.exit
We expect that this format will evolve in the near future
and that we will publish a full speciﬁcation for consultation.
Protection domains. A fundamental concept and impor-
tant building block of system security is called the protec-
tion domain.8 A domain can be scoped by the set of objects
that are currently directly accessible by a principal. A prin-
Figure 5. Separating system domains.
cipal is an entity in the computer system to which the sys-
tem grants authorizations (and, as a result, accountability).
The Java sandbox is an example of a protection domain with
a ﬁxed boundary.
By default, the system must keep protection domains from
interacting with each other. Any permitted interaction must be
either through trusted system code or explicitly allowed by
the domains concerned. Often a domain supports inheritance:
a subdomain automatically inherits the parent domain’s secu-
rity attributes. In certain cases, however, the parent further
restricts the subdomain explicitly. Relaxing a subdomain is
also a possibility with the notion of trusted code.
Protection domains generally fall into two distinct cate-
gories: system and application. It is important that all pro-
tected  external  resources,  such  as  the  file  system,  the
networking facility, and the screen and keyboard, are only
accessible via system domains. Figure 4 shows the domain
composition of a Java runtime.
Each domain (system or application) may also implement
additional protection of its internal resources within its own
domain boundary. Because it is unlikely that the JDK sys-
tem can predict or enforce the semantics of such protection,
the protection system at this level is best left to the applica-
tion developers.
One example is a banking application, where the banking
software can support and protect internal concepts such as a
checking account, deposits, withdrawals, and so on. The
developer for the banking application can use the protection
domain primitive in JDK to run the application in a domain,
thus insulating the application from other applications. The
developer can also construct the system so that the handling
of each separate account runs inside a distinct subdomain,
thus ensuring that accounts cannot be accidentally mixed up.
For convenience, we can think of the system domain as a
single, big collection of all system code. For better protection,
though, system code can run in multiple system domains,
where each domain protects a particular type of resource
and has a special set of rights. For example, as shown in
Figure 5, ﬁle system code and network system code can run
in two separate domains, where neither has rights to the
other’s resources. With this arrangement, the risks and con-
sequences of an error or security ﬂaw in one system domain
are more likely to be conﬁned within its boundary. 
403
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply. 
1.
2.
3.
Application
Systemany
Method invocation
Application
Systemtrusted
1.
Some domain
Systemany
Application
2.
Some domain
Last domainany
Minimum rights
Last domaintrusted
Trusted rights
Figure 6. Execution involving two domains.
Multidomain computation. A thread of execution (not
necessarily tied to a single thread) may occur completely
within  a  single  protection  domain.  Alternatively,  it  may
involve an application domain and also the system domain,
as shown in Figure 6.
For example, an application that prints a message must
interact with the system domain, which is the only access
point to an output stream. In this case, it is crucial that the
application domain does not gain additional permissions at
any time by calling the system domain. If it does, there can
be security implications.
In  the  reverse  situation,  a  system  domain  invokes  a
method from an application domain, such as when the AWT
system domain calls an applet’s paint method to display the
applet. In these situations, it is again crucial that the effec-
tive access rights are the same as current rights enabled in
the application domain at all times. The generalization is an
execution thread that can also traverse multiple protection
domains, as shown in Figure 7.
An exceptional case is when a piece of trusted system code
can temporarily exercise more permissions than are avail-
able directly to the application. This is necessary in some
cases. For example, a user cannot have direct access to the
password  file,  but  can  call  a  trusted  system  utility  that
changes the password on the user’s behalf. In this situation,
the system utility must enter a special privileged mode.  
The following are simple and prudent rules of thumb for
calculating permissions:
(cid:129) The permission of an execution thread is the intersec-
tion of the permissions of all protection domains tra-
versed by the execution thread.
(cid:129) When  a  piece  of  code  in  the  execution  thread  has
entered its privileged mode, the intersection of permis-
sion is applied only to protection domains between the
privileged code and the end of the thread.
THIS ARTICLE HAS GIVEN A VERY BRIEF OVERVIEW
of Java’s basic security mechanisms—those existing, and some
planned for the future. We have chosen to describe in some
detail the design of the cryptographic library and the concept
of protection domain,10-12 but have not had room to elabo-
rate on other topics such as password-protected authentica-
404
Figure 7. Execution involving multiple domains.
tion protocols,13 access control and delegation,14-16 and secure
remote method invocation. We expect to report our design
and implementation experiences in future articles.
Acknowledgments
Ideas from decades of research in computer security inﬂu-
enced the ideas presented here. It is unfortunately beyond
our ability here to give a complete listing of original publi-
cations or to thank by name everyone from whom we have
beneﬁted in recent discussions.
This document is a purely technical discussion for the
wider Java community, and does not necessarily commit
JavaSoft to any particular features or implementations.
References
1.
J.  Gosling,  B.  Joy,  and  G.  Steele,  The  Java  Language
Speciﬁcation, Addison-Wesley, Menlo Park, Calif., 1996.
2. T. Lindholm and F. Yellin, The Java Virtual Machine Speciﬁcation,
3.
Addison-Wesley, 1997.
J.C. Laprie, ed., Dependability: Basic Concepts and Terminology,
Dependable Computing and Fault-Tolerant Systems, Vol. 5,
Springer-Verlag, New York, 1992.
4. R.M. Needham, “Denial of Service: An Example,” Comm. ACM,
Vol. 37, No. 11, Nov. 1994, pp. 42–46.
5. P.G. Neumann, Computer-Related Risks, Addison-Wesley, 1995.
6. “Information Security: Computer Attacks at Department of
Defense Pose Increasing Risks,” US General Accounting Ofﬁce,
Tech. Report GAO/AIMD-96-84, Washington, D.C., 1996.
7. M. Gasser, Building a Secure Computer System, Van Nostrand
8.
Reinhold Co., New York, 1988.
J.H. Saltzer and M.D. Schroeder, “The Protection of Information
in Computer Systems,” Proc. IEEE, Vol. 63, No. 9, Sept. 1975,
pp. 1278–1308.
9. D. Dean, E.W. Felton, and D.S. Wallach, “Java Security: From
HotJava to Netscape and Beyond,” Proc. IEEE Symp. Research
in  Security  and  Privacy,  IEEE,  Piscataway,  N.J.,  1996,  pp.
190–200. 
10. M.D.  Schroeder,  Cooperation  of  Mutually  Suspicious
Subsystems in a Computer Utility, doctoral dissertation, Dept.
Electrical  Eng.,  Massachusetts  Institute  of  Technology,
Cambridge, Mass., 1972.  
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply. 
.
11. A.K.  Jones,  Protection  in  Programmed  Systems, doctoral
dissertation, Dept. Computer Science, Carnegie Mellon Univ.,
Pittsburgh, Pa., 1973.  
12. W.A. Wulf, R. Levin, and S.P. Harbison, HYDRA/C.mmp–An
Experimental Computer System, McGraw-Hill, New York, 1981.
13. L. Gong et al., “Protecting Poorly Chosen Secrets from Guessing
Attacks,” IEEE J. Selected Areas in Comm., Vol. 11, No. 5, Jun.
1993, pp. 648–656.
14. B.W.  Lampson,  “Protection,”  Proc.  Fifth  Princeton  Symp.
Information  Sciences  and  Systems,  Princeton  University,
Princeton, N.J., 1971. Reprinted in ACM Operating Systems
Review, Vol. 8, No. 1, Jan. 1974, pp. 18–24.
J.H. Saltzer, “Protection and the Control of Information Sharing
in  Multics,”  Comm.  ACM,  Vol.  17,  No.  7,  Jul.  1974,  pp.
388–402.
15.
16. B. Lampson et al., “Authentication in Distributed Systems:
Theory and Practice,” ACM Trans. Computer Systems, Vol. 10,
No. 4, Nov. 1992, pp. 265–310.
Li Gong joined JavaSoft from Stanford
Research Institute as Java security archi-
tect. His research interests include dis-
tributed 
systems  and  networking,
especially  security  and  fault  tolerance
issues.  
Gong received the PhD degree from
the University of Cambridge, England, and the 1994 IEEE
Communications Society Leonard G. Abraham award. He
served as program cochair of the third and fourth ACM
Conferences on Computer and Communications Security and
as program chair of the seventh and eighth IEEE Computer
Security Foundations Workshops. He is currently program
cochair of the 1998 IEEE Symposium on Security and Privacy.
He  is  an  associate  editor  of  ACM  Transactions  on
Information and System Security and is on the editorial board
of the Journal of Computer Security. He is a member of the
IEEE and the ACM. 
Direct  questions  concerning  this  article  to  Li  Gong,
JavaSoft, MS UCUP02-102, 2550 Garcia Ave., Mountain View,
CA 94043-1100; gong@eng.sun.com.  
405
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply.