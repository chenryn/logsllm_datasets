encoding of ğ‘– âˆ’ 1).
â€¢ For the first level, P2 constructs trees
ğ‘‡ğ‘— = ğ‘‡ (ğ‘1,ğ‘— , ğ›¼ âˆ’ 1) with ğ‘— âˆˆ [ğ‘˜] \ {ğ‘1}.
â€¢ For each level ğ‘™ âˆˆ [ğ›¼], let ğ‘‡1, . . . ,ğ‘‡ğ‘˜ğ‘™ be the sub-trees
of ğ‘‡ at level ğ‘™. In previous iterations P2 has computed
all such sub-trees except for ğ‘‡ğ‘– ğ‘— , with
the direct children of each ğ‘‡ğ‘— as {ğ‘  ğ‘—,1, . . . , ğ‘  ğ‘—,ğ‘˜}ğ‘— âˆˆ[ğ‘˜]\ğ‘–ğ‘™
Then, additional seeds {ğ‘ ğ‘ğ‘™ ,ğ‘—}ğ‘—â‰ ğ‘–ğ‘™+1 can be obtained
from (ğ‘â€²
ğ‘–ğ‘™ =ğ‘¥âˆˆ[ğ‘™] ğ‘˜ğ‘¥âˆ’1 Â· ğ‘ğ‘¥ + 1. P2 then collects the seeds of
.
ğ‘™,ğ‘—)ğ‘—â‰ ğ‘ğ‘™+1 as
ğ‘ ğ‘ğ‘™ ,ğ‘— :=

ğ‘  âŠ• ğ‘ğ‘™,ğ‘—
ğ‘ âˆˆ{ğ‘  ğ‘—,ğ‘¥ : ğ‘¥ â‰¡ ğ‘— mod ğ‘˜}
By expanding those seeds using ğº, P2 computes all
sub-trees of ğ‘‡ at level ğ‘™ + 1, except for the one at
position ğ‘–ğ‘™+1 =ğ‘¥âˆˆ[ğ‘™+1] ğ‘˜ğ‘¥âˆ’1 Â· ğ‘ğ‘¥ + 1.
at position ğ‘– =ğ‘¥âˆˆ[ğ›¼] ğ‘˜ğ‘¥âˆ’1 Â· ğ‘ğ‘¥ + 1.
P2 returns the list of seeds of leaves of ğ‘‡ , except for the one
(ğ‘› âˆ’ 1)-OUT-OF-ğ‘› RANDOM OT
3
In this section we consider the question of oblivious selection of
ğ‘› âˆ’ 1 items out of ğ‘› in the case when all items are pseudoran-
dom. This corresponds to Functionality 1, namely (ğ‘› âˆ’ 1)-out-of-ğ‘›
random oblivious transfer. If we allow linear communication, a
protocol for Functionality 1 can be easily obtained using oblivious
selection techniques. We instead propose a protocol with sub-linear
communication and linear computation. Our protocol consists of
a key generation phase where P1 learns a key ğ¾1 consisting of a
single PRG seed ğ‘ 0, and P2 learns a key ğ¾2 consisting of logğ‘˜(ğ‘›)
PRG seeds, via logğ‘˜(ğ‘›) parallel executions of a (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜ OT
protocol, for parameter ğ‘˜ > 1. Expanding the respective seeds to
obtain their length-ğ‘› outputs takes ğ‘‚(ğ‘›) PRG evaluations per party.
Key generation via a GGM tree. We crucially leverage the fact that
values are generated pseudo-randomly in order to obtain a protocol
with the above communication complexity. Let us assume, without
loss of generality, that logğ‘˜(ğ‘›) is an integer. The ğ‘› values of u are
generated from a single random seed ğ‘ 0 using a GGM tree ğ‘‡ [32]
constructed using a PRG ğº of stretch ğ‘˜, i.e. ğº : {0, 1}ğœ† â†¦â†’ {0, 1}ğ‘˜ğœ†,
for security parameter ğœ†. More concretely, ğ‘‡ is an ordered complete
ğ‘˜-ary tree of depth logğ‘˜(ğ‘›) and ğ‘› leaves, with its nodes labeled
with seeds in {0, 1}ğœ† (we will refer to nodes and their seeds/labels
indistinctly). The label of the root is ğ‘ 0, and the label ğ‘  ğ‘— of the ğ‘—th
child of a node ğ‘£ is obtained from the seed of ğ‘£, by applying the
PRG ğº and parsing the output as (ğ‘ 1| Â· Â· Â· |ğ‘  ğ‘—| Â· Â· Â· |ğ‘ ğ‘˜).
The 2-party protocol. Our protocol is presented as Protocol 2.
First, P1, the sender, computes the tree ğ‘‡ locally from a seed ğ‘ 0
(note that this can be done with 2ğ‘› âˆ’ 1 calls to ğº) and sets ğ‘ 0 to
be its key ğ¾1. The rest of the protocol allows P2, the receiver, to
recover all the seeds of ğ‘‡ , except for the ones in the path to the ğ‘–th
leaf. This is done in a way that does not leak ğ‘– to P1, and requires
only log(ğ‘›) seeds, which will constitute P2â€™s key ğ¾2, to be expanded
locally. We now informally discuss the correctness and security of
our protocol, as well as associated communication and computation
costs.
Let (ğ‘–1, . . . , ğ‘–logğ‘˜ (ğ‘›)) be the path to the ğ‘–-th leaf (this is a sequence
of values in {0, . . . , ğ‘˜ âˆ’ 1}, indicating which children to follow at
each level to reach the ğ‘–th leaf from the root, and in fact corresponds
to the ğ‘˜-ary encoding of the integer ğ‘– âˆ’ 1). For example, Figure 1
shows how for ğ‘› = 8 and ğ‘– = 3, the path the receiver should not
learn is 010. As mentioned above, our goal is that the receiver can
reconstruct all the tree except for the nodes on this path.
Although it will become clear that the protocol can be paral-
lelized across levels, for explanatory purposes it is useful to think of
it as processing ğ‘‡ level by level from the root guaranteeing that, for
each level ğ‘™ âˆˆ [logğ‘˜(ğ‘›)], the receiver can reconstruct ğ‘‡ up to level ğ‘™,
except for the nodes in the path (ğ‘–1, . . . , ğ‘–ğ‘™). This property obviously
holds for ğ‘™ = 0 and, to argue the correctness of our protocol, we
now argue inductively how to extend it from level ğ‘™ to level ğ‘™ + 1.
By induction assume that the receiver can reconstruct all sub-
trees ğ‘‡1, . . . ğ‘‡ğ‘˜ğ‘™ of depth ğ›¼ âˆ’ ğ‘™ rooted at the nodes of level ğ‘™ except
for exactly one: the one rooted at path (ğ‘–1, . . . , ğ‘–ğ‘™). This is, precisely,
show how a single execution of (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜ OT is enough
to extend the above property to level ğ‘™ + 1. Intuitively, we want
ğ‘‡(ğ‘¥âˆˆ[ğ‘™] ğ‘˜ğ‘¥âˆ’1Â·ğ‘–ğ‘¥+1), which we denote ğ‘‡âˆ— for simplicity. Now, let us
5
(cid:16)ğ‘˜ğ‘™
ğ‘—=1 ğ‘  ğ‘—,0
ğ‘—=1 ğ‘  ğ‘—,ğ‘˜âˆ’1
to ensure that the receiver learns all direct children of ğ‘‡âˆ—, except
for the ğ‘–ğ‘™+1th one. As ğ‘‡âˆ— has ğ‘˜ direct children, this corresponds
to a (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜-OT. However, for privacy, it is important
that the sender never learns that ğ‘‡âˆ— is in fact the sub-tree that the
receiver cannot reconstruct at level ğ‘™, as this reveals too much about
the index ğ‘–. This difficulty can be overcome by constructing the
messages in the (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜-OT as follows.
Let ğ‘  ğ‘—,0, . . . , ğ‘  ğ‘—,ğ‘˜âˆ’1 be the seeds of the nodes that are direct chil-
dren of each tree ğ‘‡ğ‘—. As the receiver knows all the ğ‘‡ğ‘—s except for ğ‘‡âˆ—,
1), i.e., the children ofğ‘‡âˆ—. The key idea to achieve the above goal is to
have the sender compute ğ‘˜ values ğ‘š0 =
she has all such seeds except for the ones with ğ‘— = (ğ‘¥âˆˆ[ğ‘™] ğ‘˜ğ‘¥âˆ’1Â·ğ‘–ğ‘¥+
(cid:17), . . . , ğ‘šğ‘˜âˆ’1 =
(cid:16)ğ‘˜ğ‘™
(cid:17). Here, ğ‘š0 is the XOR of all direct first children of
the seed ğ‘ (ğ‘¥âˆˆ[ğ‘™] ğ‘˜ğ‘¥âˆ’1Â·ğ‘–ğ‘¥+1),ğ‘— (the ğ‘¦th child of ğ‘‡âˆ—) since she knows
nodes at level ğ‘™, ğ‘š1 is the XOR of all second children, and so on.
Now observe that, given any value ğ‘šğ‘¦ the receiver can compute
all the other values XOR-ed into the ğ‘š ğ‘— value. On the other hand,
ğ‘š ğ‘— does not reveal anything about the seeds ğ‘ ğ‘˜ğ‘™ ,ğ‘¥ with ğ‘¥ â‰  ğ‘—. Thus,
the sender and the receiver run (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜ OT where the
senderâ€™s inputs are ğ‘š0, . . . , ğ‘šğ‘˜âˆ’1 and the receiverâ€™s input is the set
{0, . . . , ğ‘˜ âˆ’ 1} \ {ğ‘–ğ‘™}. After running this sub-protocol the receiver
can reconstruct ğ‘‡ up to level ğ‘™ + 1, except for the nodes in the path
(ğ‘–1, . . . , ğ‘–ğ‘™+1). This shows how to extend the construction from level
ğ‘™ to ğ‘™ + 1, and the protocol finishes when ğ‘™ = ğ‘›.
An important observation is that the instances of (ğ‘˜âˆ’1)-out-of-ğ‘˜
OT used in the above construction can all be run in parallel. The
correctness of our construction follows from the above discussion,
and its security, stated in the next lemma, follows directly from the
security of ğº, and the underlying protocol for (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜ OT.
A detailed proof can be found in Appendix A.1. In Section 8 we
describe how ğº is instantiated in our implementation, as well as
other practical considerations and optimizations.
Lemma 3.1. For any constant ğ‘˜ > 1, Protocol 2 is a secure two party
computation protocol for the (ğ‘› âˆ’ 1)-out-of-n ROT functionality in
the (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜ OT hybrid model assuming a secure PRG ğº. The
protocol is one round, and requires ğ‘‚(ğœ† log(ğ‘›)) communication and
ğ‘‚(ğœ†ğ‘›) computation per party, including 2ğ‘› PRG evaluations, where
ğœ† is the length of the PRG seed.
Proof Sketch. Showing the security of the above protocol consists
of two steps: first, showing that the keys that the parties receive
have the desired pseudorandom properties (Definition A.1), which
follows from the pseudorandom properties of the GGM construction
and which we formally prove in Theorem A.2. And second, showing
that the key generation protocol is a secure two party computation
protocol for the generation of the keys, which follows from the
OT security and which we prove formally in Theorem A.3. The
communication overhead follows from the fact that the parties
execute logğ‘˜ ğ‘› OTs, which have linear communication in ğœ†. The
computation ğ‘‚(ğœ†ğ‘›) for each comes from the execution of the logğ‘˜ ğ‘›
OTs and the expansion of the keys which uses 2ğ‘› PRG calls.
How to set ğ‘˜, and instantiations of (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜ OT. The con-
struction of Protocol 2 works for any integer ğ‘˜ > 1. Choosing ğ‘˜
constant results in logarithmic communication, and in fact in our
6
implementation we use ğ‘˜ = 2. In practice, this allows us to lever-
age very efficient implementations of 1-out-of-2 OT based on OT
Extension. When instantiated with ğ‘˜ = 2, our protocol resembles
the Function Secret sharing construction by Boyle et al. [12].
Privately Punctured PRF. Our ğ‘›âˆ’1-out-ğ‘› random OT protocol also
provides a construction for a privately punctured pseudorandom
function, where one party has the PRF key and can evaluate the
PRF on any input (in our case this is P1 who has the GGM root)
and the other party has a punctured key which allows it to evaluate
the PRF on all but one inputs (P2 in our case). The OT protocol
enables P2 to obtain its punctured PRF key without revealing the
punctured point to P1 (the punctured key is the output that P2 has
at the end of the KeyExchange phase of the OT protocol). We note
the difference in the punctured key generation algorithm from the
one defined in other contexts for privately puncturable PRFs [8],
where the party who has the full PRF key generates the punctured
key and knows the point at which it is punctured.
4 KNOWN-INDEX SPFSS
In this section we use our ğ‘› âˆ’ 1-out-of-ğ‘› random OT protocol to
construct a 2-party computation protocol to jointly generate FSS
keys for point functions. The setup for our distributed FSS protocol
assumes that one party knows the non-zero evaluation point while
the value at that point is shared between the two parties. Thus,
it is not equivalent to a generic distributed FSS scheme for point
functions, as for example described in [23]. However, this relaxed
version suffices for our VOLE construction described in Section 6.
We call our FSS variant Known-Index SPFSS to emphasize that one
party knows the non-zero index.
Conceptually, the existing construction of point function FSS [12]
generates two PRF keys ğ¾1 and ğ¾2 such that PRFğ¾1(ğ‘¥) = âˆ’PRFğ¾2(ğ‘¥)
for all values of ğ‘¥ except the input with non-zero evaluation ğ‘–. The
values PRFğ¾1(ğ‘–) and PRFğ¾2(ğ‘–) are random shares of the function
evaluation ğ›½ at the input ğ‘–. If two parties need to generate ğ¾1 and
ğ¾2 in a distributed way, they can use secure general computation
for this task, and Doerner and shelat [23] show a more efficient
way to construct such an MPC protocol in the semi-honest setting.
When one of the parties, P2, knows ğ‘–, we can construct ğ¾1 and
ğ¾2 in a distributed fashion as follows. First, P1 and P2 run a secure
(ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT key generation protocol (the construction
and
from the previous section), for the parties to obtain keys ğ¾ROT1
. Note that, if the parties compute rğ‘ = ROT.Expand(ğ‘, ğ¾ROT
),
ğ¾ROT2
the vectors r1, r2 coincide at every position except for a position
ğ‘– known to P2. As P2 can negate its vector, we can think of r1
and âˆ’r2 as additive shares of a vector of all zeroes except for the
ğ‘–th position. Now all that remains is to modify r1 and âˆ’r2 to fix
the ğ‘–th position to be a share of a value ğ›½ shared among P1 and
P2 (see Protocol 3). Crucially, this needs to be done in a way that
does not leak ğ›½ to either party, and keeps ğ‘– private from P1. To
do this we leverage the observation that P1 and P2 can compute
ğ‘— . The difference ğ‘… âˆ’ ğ‘…â€² will
be the evaluation of PRFğ¾1( ğ‘—). Since the parties have shares ğ›½1
and ğ›½2 of the point function evaluation ğ›½ at ğ‘–, we complete the
protocol by P1 sending ğ‘…ğ›½ = ğ‘… âˆ’ ğ›½1 to P2 (note that this hides
ğ›½1 because P2 does not know ğ‘Ÿ1
ğ‘– , which is a random mask) who
ğ‘— and ğ‘…â€² = ğ‘—â‰ ğ‘– ğ‘Ÿ2
sums ğ‘… = ğ‘— ğ‘Ÿ1
ğ‘
0
1
0
1
0
1
1
0
1
OT
OT
OT
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0