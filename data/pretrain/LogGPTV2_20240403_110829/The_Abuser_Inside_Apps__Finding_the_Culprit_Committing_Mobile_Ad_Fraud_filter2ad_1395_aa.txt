title:The Abuser Inside Apps: Finding the Culprit Committing Mobile Ad Fraud
author:Joongyum Kim and
Junghwan Park and
Sooel Son
The Abuser Inside Apps: Finding the Culprit
Committing Mobile Ad Fraud
Joongyum Kim∗
Jung-hwan Park∗
Sooel Son
School of Computing, KAIST
School of Computing, KAIST
School of Computing, KAIST
PI:EMAIL
PI:EMAIL
PI:EMAIL
Abstract—Mobile ad fraud is a signiﬁcant threat that victim-
izes app publishers and their users, thereby undermining the
ecosystem of app markets. Prior works on detecting mobile ad
fraud have focused on constructing predeﬁned test scenarios that
preclude user involvement in identifying ad fraud. However, due
to their dependence on contextual testing environments, these
works have neglected to track which app modules and which
user interactions are responsible for observed ad fraud.
To address these shortcomings, this paper presents the design
and implementation of FraudDetective, a dynamic testing frame-
work that identiﬁes ad fraud activities. FraudDetective focuses on
identifying fraudulent activities that originate without any user
interactions. FraudDetective computes a full stack trace from
an observed ad fraud activity to a user event by connecting
fragmented multiple stack traces, thus generating the causal
relationships between user inputs and the observed fraudulent
activity. We revised an Android Open Source Project (AOSP)
to emit detected ad fraud activities along with their full stack
traces, which help pinpoint the app modules responsible for the
observed fraud activities. We evaluate FraudDetective on 48,172
apps from Google Play Store. FraudDetective reports that 74 apps
are responsible for 34,453 ad fraud activities and ﬁnd that 98.6%
of the fraudulent behaviors originate from embedded third-party
ad libraries. Our evaluation demonstrates that FraudDetective is
capable of accurately identifying ad fraud via reasoning based
on observed suspicious behaviors without user interactions. The
experimental results also yield the new insight that abusive ad
service providers harness their ad libraries to actively engage in
committing ad fraud.
I.
INTRODUCTION
The mobile ad has been a compelling motivator that drives
app publishers to develop innovative apps. Nowadays, mobile
ads have become pervasive. Recent research shows that the
mobile ad market has expanded to reach 187 billion USD
in 2020, which comprises 30.5% of the global ad market
budget [49].
Whereas the mobile ad ecosystem facilitates the virtuous
cycle of bringing innovation to mobile computing, ad fraud
*Both authors contributed equally to the paper
Network and Distributed Systems Security (NDSS) Symposium 2021
21-25 February 2021, Virtual
ISBN 1-891562-66-5
https://dx.doi.org/10.14722/ndss.2021.23161
www.ndss-symposium.org
Fig. 1: Ad fraud example: The invocation of a different app
via Android explicit Intent, which is triggered without user
interaction.
has become a major security threat. Previous studies [47],
[52], [73] have demonstrated that the total losses due to ad
fraud amount to approximately 9%-20% of the annual market
budget for global mobile advertising. For instance, ZeroAccess
operates the world’s largest botnet, making $100,000 daily via
ad fraud [64].
To maintain the sanity of Google Play Store, protecting
users from mobile ad fraud, Google has published a developer
policy regarding mobile ads [30] that denounces abusive ad
libraries for their excessive monetization. Also, Google Android
security has actively identiﬁed apps with abusive behaviors that
result in ad fraud [54].
Previous studies proposed novel dynamic testing frame-
works, MAdFraud [25] and MAdLife [21], designed to identify
ad fraud in Android apps. Whereas they demonstrate their
efﬁcacy in ﬁnding apps that commit ad fraud, these frameworks
lose sight of which user interactions and app modules cause the
commission of ad fraud. MAdFraud conducts dynamic testing
of apps without any interaction, emulating an environment
involving no user interaction. MAdLife focuses on identifying
full-screen ads that pop up in the foreground immediately after
an app starts. However, depending on these types of contextual
testing environments inevitably limits the testing of target app
functionalities.
Our contributions. We design and implement FraudDetective,
a dynamic testing framework for identifying mobile ad fraud
initiated via Android apps. We deﬁne an ad fraud activity as
(1) a click URL request submission for which the targeted ad
service counts user clicks or (2) an invocation of a different app
Fraudulent AppSamsung BrowserExplicit Android Intent•Package :  com.sec.android.app.sbrowser•URL         :  https://www.bithumb.com/...Invoking a browser without user interactionin the foreground without any explicit user interaction. Figure 1
is an example of the latter type of ad fraud activity, which
instantiates the Samsung Android browser with a Bithumb sign-
up page without having any user input. By deﬁnition, identifying
an ad fraud activity requires computing the causality between
that fraudulent activity and explicit user interaction, such as a
touch or a drag event. For instance, it is benign for a mobile
app to invoke the Chrome browser with a promotional page
when a user touches a banner ad for Nike sneakers. On the
other hand, when this mobile app invokes the browser with
the same page but without user touch, it becomes an ad fraud
activity.
Prior approaches [21], [25] to the runtime detection of ad
fraud activities have suffered from two types of problems: 1)
they have neglected to model the causality between observed
fraud activities and user interactions precisely, resorting to
leverage restricted testing environments having no user input;
and 2) their methods have been unable to track which app
modules conduct an observed ad fraud activity.
To address these issues, we propose to compute a full stack
trace to capture such causal relationships. A full stack trace
is a sequence of callees that lie within the calling context
from an execution entry to a statement committing an ad fraud
activity. This stack trace contributes to identifying the existence
of explicit user input and determines which source classes
invoked the ad fraud activity, revealing the culprit module
within an app committing ad fraud.
However, a stack trace for a fraud activity is often frag-
mented due to the usage of multiple threads, message queues
connecting event generators and their handlers, and external
Chromium WebView instances separated from apps. To compute
the non-fragmented full stack trace for an observed fraud
activity, we revise an Android Open Source Project (AOSP)
that corresponds to Android Oreo [5] and leverage this AOSP
to emit execution logs of ad fraud activities and their stack
traces. FraudDetective harnesses this AOSP for its dynamic
testing of apps, connects fragmented stack traces via collecting
execution logs, and identiﬁes ad fraud activities.
We evaluate FraudDetective on 48,172 apps that Fraud-
Detective crawled from Google Play Store. Of 48,172 apps,
FraudDetective identiﬁes 74 apps that commit 34,453 ad fraud
activities. We further analyze whether these observed ad fraud
cases originate in the apps themselves or in ad libraries
embedded in these apps. We ﬁnd that 98.6% of the observed
activities originate from ad libraries, which account for 73 of the
74 apps identiﬁed. This observation yields the new insight that
abusive ad library providers play a key role in the commission
of ad fraud by exploiting actual user devices. That is, an ad
service provider invites various app developers to embed their ad
libraries and commits ad fraud by victimizing mobile users with
mobile apps from these developers. Consequently, the victims
contribute to increasing ad trafﬁc by visiting certain promotional
websites, as orchestrated by these ad library providers.
In addition, we observed that one Google Play Store app has
been used to forcibly invoke YouTube and Naver [42] mobile
apps in the foreground and redirect their users to web pages or
videos promoting speciﬁc products and services. Although
YouTube and Naver do not conduct excessive promotions,
ad fraud activities from this app may lead to users blaming
YouTube and Naver because their apps with promotional content
are brought into the foreground without explicit user interaction.
Thus, users have left related negative feedback about YouTube
and Naver apps at Google Play Store. However, FraudDetective
ﬁnds, through the analysis of full stack traces of observed ad
fraud activities, that the culprits are abusive ad libraries that
have redirected users by invoking these apps via cross-app
Android Intents.
By computing full stack traces of ad fraud activities, we
improve the precision of ad fraud detection compared to prior
work. We believe that this capability is an important requisite for
dynamically identifying ad fraud behaviors, which is applicable
to vetting mobile apps in many app stores, thereby protecting
users from ad fraud campaigns.
II. BACKGROUND
A. Mobile ad ecosystem
Serving mobile ads is a prevalent method of monetizing
mobile apps. App developers integrate their mobile apps with
a mobile ad library, and the embedded library conducts the
rendering of ads at the screen estates of its hosting app.
The usage of such mobile ad libraries is quite prevalent;
approximately 56% of Android apps in Google Play Store
include AdMob, an ad library managed by Google [16].
There are three key participants in the mobile advertising
ecosystem: publisher, advertiser, and ad service provider. (1)
A publisher is an app developer who monetizes their app by
integrating an ad library managed by an ad service provider. (2)
An advertiser or their agency designs an ad campaign for their
target audiences and requests the launch of such ad campaigns
to an ad service provider. (3) An ad service provider connects
the advertisers’ need for greater exposure to their ads with
the publishers’ offer to serve ads. This ad service provider
also offers an ad library for publishers to include. When a
publisher embeds this ad library, it fetches ads from the ad
service provider and then renders the ads at user devices. Each
rendered ad is called an ad impression, which typically refers
to an image or a video rendered one time.
Ad service providers offer various ways of charging adver-
tisers for their services. In general, there are three representative
methods of billing advertisers: cost-per-mile (CPM), cost-per-
click (CPC), and cost-per-install (CPI). CPM, CPC, and CPI
involve charging an advertiser for rendered ad impressions,
user clicks, and app installs, respectively. For instance, when
an ad service provider asks $5 CPM for a given campaign,
an advertiser is required to pay 5 USD when this campaign
delivers 1,000 ad impressions to audiences.
B. Mobile ad fraud
Mobile ad fraud refers to an operation that generates
unwanted ad trafﬁc involving ad impressions, clicks, or conver-
sions, thus generating fraudulent revenues. This paper focuses
on two types of ad fraud: click fraud and impression fraud.
Click fraud. Click fraud refers to a fraudulent operation
generating illegitimate clicks that consume the marketing budget
of a victim advertiser [46], [79]. A click fraud adversary could
be an abusive publisher, an ad service provider, or a competitor
of a targeted advertiser. The motivation for publishers and ad
2
service providers to engage in click fraud is to inﬂate their
CPC prices by promoting a fraudulently high CPC [36], [82].
An advertising competitor may recruit a botnet network to click
ad impressions of a targeted advertiser, thus depleting their ad
budget.
A successful click fraud campaign is highly dependent on
generating click URL requests that a target ad service provider
accepts and counts toward the billing of a target advertiser. A
typical click URL points to an ad server and redirects users to
a landing page. Consider the click URL example below:
(cid:122)
(cid:125)(cid:124)
App ID
(cid:123)
&id=466158
http://click.cauly.co.kr/caulyClick?
code=aRU5Bq1u
&unique_app_id=kr.kbac3k.ktv
&click_action=click
&...
Ad ID
P ackage name
Label of click U RL
This click URL points to the Cauly ad network and contains
information that indicates an application identiﬁer (aRU5Bq1u),
an application package name (kr.kbac3k.ktv), and a publisher
(466158) that initiated the request.
Therefore, there exist two ways of implementing click fraud:
1) the attacker sends a vast volume of click URL requests
that a target ad service provider accepts by leveraging her
own botnet networks [26], [28], [64]; 2) alternatively, the
attacker deceives users into actually clicking ad impressions,
thus generating admissible click URL requests from users’
devices [82]. The former method requires an understanding
of how the ad service provider generates an admissible click
URL request. On the other hand, the latter requires no such
understanding but necessitates deceiving a large number of
users into clicking unwanted ad impressions [82].
Impression fraud. One key requirement of mobile ads is to
render ad impressions; advertisers are often charged by the
number of rendered impressions. An attacker is able either
to hide ads underneath other visible elements on the screen
or create invisible ads by making them small [32], [56]. In
either case, no ad impressions are exposed to users, but the
users’ devices still send ad impression requests, which results
in advertisers being charged.
III. MOTIVATION
Preserving the sanity of app markets (e.g., Google Play
Store) is an essential task for protecting the security and privacy
of market users, thus establishing long-term success. Therefore,
Google has been operating an Android app analysis framework,
known as Bouncer, to ﬁnd malware [39], apps with known
security vulnerabilities [67], and ad abusing apps [54].
Considering that the number of Android apps in Google
Play Store surpassed 2.8 million as of October 2019 [17],
analyzing mobile apps in an automatic way is paramount to
the scalable detection of malicious or abusive applications. To
this end, previous research has proposed novel dynamic testing
frameworks designed to identify Android apps committing ad
fraud [21], [25].
MAdFraud is designed to identify fraudulent click URL
requests without authentic user clicks [25]. It observes outgoing
HTTP URL requests and their responses while not interacting
with an app under testing, which simulates an execution
environment with no user intervention. MAdLife is another
dynamic analysis framework that detects abusive full-screen ad
3
impressions rendered without any user interactions. It compares
the pre-click and post-click log data and screenshots of a
target app and classiﬁes it as abusive when two data points
are equivalent, denoting that the app has already rendered the
full-screen ad impression event before the framework conducts
an actual click [21].
We argue that these previous frameworks suffer from four
limitations as follows. (1) Their approaches are unable to
manifest causal relationships between user interactions and
fraudulent activities, such as an automatic submission of a
click URL request triggered without user touch. MAdFraud
classiﬁes all observed HTTP requests with click URLs as
abusive when a target app is in the foreground or background.
It creates a speciﬁc testing environment in which the target
app cannot obtain legitimate user inputs. Thus, when this app
requires user interaction before committing ad fraud, MAdFraud
inevitably produces a false negative. MAdLife identiﬁes an
ad fraud activity when a target app shows an ad landing
page in the foreground before clicking WebView ads. It only
focuses on identifying click fraud that involves clicking a
WebView instance and misses computing causal relationships
of fraudulent activities not involving WebView.
(2) The previous strategies cannot pinpoint which app
module conducts ad fraud. Because both approaches only take
external behaviors into account, they lose sight of internal app
logic and are thus unable to determine the culprit committing
observed ad fraud. The offender might be a target app under
testing or one of the embedded libraries in the hosting app.
We observed that 73 apps conducted ad fraud by means
of their embedded third-party libraries (§VI-B). Note that
pinpointing abusive modules helps app developers patch their
apps, especially when they inadvertently conduct click fraud
by including fraudulent ad libraries. Auditors also beneﬁt from
being able to penalize the identiﬁed ad services in order to stop
their fraud campaigns, instead of needing to track the patch of
each identiﬁed app.
(3) Neither system interacts with a target app, leading them
to cover only a small portion of the functionalities. By design,
MAdFraud should not have user interactions during its testing.
This limitation brings with it the inevitable shortcoming of
limited testing coverage. When a target app requires app-speciﬁc
permission consents or the touching of user controls to initiate
abusive behaviors, MAdFraud will produce false negatives.
(4) Both systems leverage emulators to conduct dynamic
testing. Thus, the systems may not observe ad fraud activities
that only appear at real mobile devices [51], [57].
Note that the aforementioned four limitations also become
technical challenges that a next-generation dynamic testing
framework should address for the accurate detection of mobile
ad fraud. In this paper, we deﬁne an ad fraud activity as a
click URL request submission or an invocation of other apps
via cross-app Intents without genuine user interaction. For the
accurate detection of these ad fraud activities, we propose a
dynamic ad fraud detection framework, FraudDetective.
To address the ﬁrst and second technical challenges, we
revised an Android operating system so that it produces a
full stack trace from an execution entry to a sink method
that sends a click URL request or invokes a cross-app Intent.
FraudDetective is able to identify whether each full stack trace