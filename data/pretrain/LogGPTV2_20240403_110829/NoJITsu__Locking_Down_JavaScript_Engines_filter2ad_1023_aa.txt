title:NoJITsu: Locking Down JavaScript Engines
author:Taemin Park and
Karel Dhondt and
David Gens and
Yeoul Na and
Stijn Volckaert and
Michael Franz
NOJITSU: Locking Down JavaScript Engines
Taemin Park∗, Karel Dhondt†, David Gens∗, Yeoul Na∗, Stijn Volckaert†, Michael Franz∗
∗Department of Computer Science, University of California, Irvine
†Department of Computer Science, imec-DistriNet, KU Leuven
Abstract—Data-only attacks against dynamic scripting envi-
ronments have become common. Web browsers and other mod-
ern applications embed scripting engines to support interactive
content. The scripting engines optimize performance via just-in-
time compilation. Since applications are increasingly hardened
against code-reuse attacks, adversaries are looking to achieve
code execution or elevate privileges by corrupting sensitive data
like the intermediate representation of optimizing JIT compilers.
This has inspired numerous defenses for just-in-time compilers.
Our paper demonstrates that securing JIT compilation is not
sufﬁcient. First, we present a proof-of-concept data-only attack
against a recent version of Mozilla’s SpiderMonkey JIT in which
the attacker only corrupts heap objects to successfully issue a
system call from within bytecode execution at run time. Previous
work assumed that bytecode execution is safe by construction
since interpreters only allow a narrow set of benign instructions
and bytecode is always checked for validity before execution.
We show that this does not prevent malicious code execution in
practice. Second, we design a novel defense, dubbed NOJITSU
to protect complex, real-world scripting engines from data-only
attacks against interpreted code. The key idea behind our defense
is to enable ﬁne-grained memory access control for individual
memory regions based on their roles throughout the JavaScript
lifecycle. For this we combine automated analysis, instrumenta-
tion, compartmentalization, and Intel’s Memory-Protection Keys
to secure SpiderMonkey against existing and newly synthesized
attacks. We implement and thoroughly test our implementation
using a number of real-world scenarios as well as standard
benchmarks. We show that NOJITSU successfully thwarts code-
reuse as well as data-only attacks against any part of the scripting
engine while offering a modest run-time overhead of only 5%.
I.
INTRODUCTION
Browsers are among the most widely used programs and
are continuously exposed to untrusted inputs provided by
remote web servers. A substantial part of these untrusted inputs
is JavaScript code. Browsers generally use a script engine with
one or more Just-In-Time (JIT) compilers to execute scripts ef-
ﬁciently. Mainstream engines such as Mozilla’s SpiderMonkey
and Google’s V8 evolve rapidly and grow continuously to keep
up with the latest ECMAScript standard and with the users’
demand for high performance. Consequently, they are prime
targets for adversaries who exploit this increasing complexity
and ﬂexibility to gain remote code execution in the browser
process [49], [66].
Network and Distributed Systems Security (NDSS) Symposium 2020
23-26 February 2020, San Diego, CA, USA
ISBN 1-891562-61-4
https://dx.doi.org/10.14722/ndss.2020.24262
www.ndss-symposium.org
Initially, these exploits focused on the JIT compiler itself.
This compiler transforms interpreted bytecode into natively
executed machine code. When JavaScript JIT compilers ﬁrst
became popular, they wrote all run-time generated code onto
memory pages that were simultaneously writable and exe-
cutable throughout the execution of the script. This trivially
enabled code-injection attacks [18], [55]. Later JIT engines
added support for W⊕X policies by doubly-mapping JIT
pages instead. This meant that JIT code could no longer be
found on memory pages that were simultaneously writable
and executable. While this undeniably improved security, at-
tackers repeatedly demonstrated that JIT engines could still
be attacked. JIT spraying, for example, lets an attacker inject
small arbitrary instruction sequences into JIT pages with-
out writing directly to the pages [7], [13], [37]. Defenders
quickly thwarted these attacks through the use of constant
blinding [13], constant elimination and code obfuscation [19],
code randomization [32], or control-ﬂow integrity [46].
Successfully defending JIT engines against code-reuse at-
tacks proved more challenging, however, since an adversary
can leverage memory disclosure vulnerabilities to iteratively
traverse and disassemble code pages to dynamically generate
a ROP chain at run time (an attack known as JIT-ROP [56]). A
number of schemes protect against such attacks by leveraging
randomization and execute-only memory [8], [9], [23], [29].
More recently, several efforts independently demonstrated
that an adversary may still be able to inject code despite all
of the above defenses being in place by resorting to data-
only attacks. Both Theori et al. [62] and Frassetto et al. [27]
showed that an attacker can force the JIT compiler to generate
malicious code by corrupting the intermediate representation
of the compiler without overwriting any code pointers. For this
reason, recent defenses propose isolating the compilation from
the execution of JIT code, through separate processes [42], [58]
or hardware-based trusted execution environments [27].
In this paper, we show that isolating JIT code compilation
from its execution does not sufﬁce to prevent remote code
execution. To this end, we ﬁrst present a new attack that only
leverages the bytecode interpreter component of the scripting
engine. Previous work considered this component safe by
design, since the bytecode is conﬁned to a limited set of
operations whose safety is validated by the interpreter before
they are executed. We show that this assumption does not hold
in practice, as we can corrupt the internal data representation
of individual operations within the interpreter. This allows us
to execute potentially malicious operations such as arbitrary
system calls. Crucially, our new attack does not require JIT
compilation of bytecode at any point in time. We implemented
our proof-of-concept attack for a recent version of Mozilla’s
popular and widely used JavaScript engine SpiderMonkey to
verify its efﬁcacy.
previously
proposed
protections
Unfortunately,
for
JavaScript engines do not
trivially extend to the bytecode
interpreter, as their design is either tailored towards running
in a trusted execution environment, or because they would
incur substantial run-time overhead in the context of an
interpreter. This is why we present a novel and general
defense strategy, called NOJITSU, to defend the JIT engine
against a wide variety of run-time attacks, including code
injection, code reuse, and data-only attacks against any
of
its components. Our design leverages hardware-based
memory protection features, such as Intel MPK, to isolate
and protect each component of the scripting engine. In this
way, we are able to effectively reduce the memory-access
permissions of each component
its minimally
required working set. To demonstrate feasibility we then
analyze, partition, and instrument SpiderMonkey, leveraging
automated dynamic analysis techniques to scale our efforts
to this complex real-world code base, while keeping our
techniques
implementation-agnostic. To the best of our
knowledge, we are the ﬁrst to present and fully implement
hardware-backed, ﬁne-grained access control for a JavaScript
engine. We thoroughly tested and evaluated NOJITSU in a
number of attack scenarios, which include code-injection,
(dynamic) code-reuse, as well as data-only attacks, and
analyzed its security in depth. Using standard benchmarks
as well as real-world application scenarios we show that
our prototype already offers practical performance, with a
moderate run-time overhead of only 5% on average.
towards
•
•
In summary, our contributions are as follows:
•
interpreters
Bytecode Interpreter Attack. We present a new
attack against bytecode
in modern
JavaScript engines which have not been targeted in
previous work. Our attack therefore works despite all
existing defenses being enabled and enforced.
Fine-Grained Memory Access Control. We propose
NOJITSU, a novel approach that effectively secures
the bytecode interpreter component of modern script-
ing engines. Our design leverages enhanced memory
protection, such as Intel MPK, to completely lock
down the entire scripting engine. To the best of
our knowledge, we are the ﬁrst to incorporate ﬁne-
grained memory access control into a large real-world
JIT engine and also protect the JavaScript interpreter
component. We implemented our prototype in a recent
version of Mozilla’s SpiderMonkey.
Thorough Evaluation. We extensively evaluate our
prototype of NOJITSU for its security using a number
of real-world attack scenarios, for which we also re-
implemented a fully working JIT-ROP attack against
SpiderMonkey. As we are able to show NOJITSU
withstands all previously presented attacks as well
as our new data-only attack. We further evaluate
performance using standard benchmarks and practical
use cases, demonstrating that NOJITSU additionally
offers low overhead with an average performance hit
of only 5%.
Fig. 1: High-level overview of our model. If an adversary is
able to trigger a memory-corruption vulnerability in any part
of the JIT engine, we show that the internal data used by
individual bytecode operations can be exploited to make the
interpreter call external system functions, which are always
mapped as part of the application’s address space. This strategy
works despite state-of-the-art defenses for JIT engines being
deployed.
II. ATTACKING THE INTERPRETER
We constructed an attack on the interpreter component of
Mozilla’s SpiderMonkey, the JavaScript engine used in the
Firefox web browser. This section provides the necessary back-
ground information and assumptions about SpiderMonkey’s
internals and then proceeds to describe our attack.
A. Threat Model
We assume a recent version of SpiderMonkey built with
the standard Mozilla build environment and conﬁguration.
SpiderMonkey has many components that contain machine
code compiled ahead of time (statically). We assume that at
least one of these components contains an arbitrary memory
read/write vulnerability.
We assume that
the standard code-injection and code-
reuse defenses are in place. Hardware vulnerabilities such as
Rowhammer [31], [52], Meltdown [38], and Spectre [33] are
orthogonal to software vulnerabilities and outside the scope of
this paper. Our threat model is in line with those of related
work in this area [7], [13], [19], [27], [32], [37], [46].
• Memory-corruption vulnerability. Some part of the
scripting engine (or the surrounding application) con-
tains a memory-corruption bug that enables an adver-
sary to arbitrarily corrupt any part of the program’s
address space.
Code-injection defense. We assume the scripting
engine enforces a strong W⊕X policy [41], and,
thus, that no memory pages are ever simultaneously
writable and executable. Some engines enforce W⊕X
by ofﬂoading the JIT compilation to an external pro-
cess [42], [58] or trusted execution environment [27],
•
2
Javascript EngineInterpreterJITCompilerJIT codeC LibraryBugCorruptJIT compileJIT code emitRead/writeCall library functionsBytecodeObj tableobjCall library functions•
while others simply toggle the writable and executable
permissions on JIT pages at run time [44].
Code-reuse defense. We assume that the browser uses
all code-reuse defenses that have seen widespread
adoption. These defenses include, among others,
ASLR [48] and coarse-grained CFI [3]. With these de-
fenses in place, the base addresses of executable code
sections are not known a priori, and control ﬂow can
only be diverted to legitimate function entry points.
This set of defenses, however, doesn’t prevent leaking
function addresses by disassembling code pages on-
the-ﬂy to directly discover function locations encoded
in the code pages or indirectly read a location of data
structures such as PLT that contain legitimate function
entry points.
• Hardware-based Memory Protection Features. We
assume Intel Memory Protection Keys (MPK) [22] to
be available on the target platform. We assume PKRU
values, which control access privileges to memory
domains, always stay in registers so adversaries with
arbitrary memory read/write capability cannot directly
manipulate these values. As coarse-grained CFI is in
place, the attacker cannot leverage unintentional oc-
currences of instructions to modify in-register PKRU
values.
B. SpiderMonkey Implementation
Modern scripting engines have at least two components that
support the execution of JavaScript code: an interpreter and a
JIT compiler (see Figure 1)1 The interpreter takes a plain-text
script as input, parses it, and generates bytecode instructions,
object tables, and data objects. The data objects encapsulate
all of the data used throughout the execution of the bytecode
program. For example, this includes constant values, function
arguments, local and global variables, properties, and function
pointers. The object tables form an indirection layer between
the bytecode and the data objects. Thanks to this indirection,
the bytecode can refer to data objects using their index in
an object table. This allows the JavaScript engine to generate
highly compact bytecode. The engine then executes the script
by interpreting the bytecode. When the interpreter executes a
particular part of the bytecode often enough (i.e., the bytecode
becomes “hot”), it invokes the JIT compiler, which compiles
the bytecode into optimized native machine code. Among other
things, this eliminates the overhead of interpreter distpatch.
1) Speculative Optimization: Some of the optimizations
leveraged by the JIT compiler might be speculative in nature.
The compiler might, for example, speculate that the types of
certain program variables remain stable, when in principle
types can change at any point. If one of the speculative
assumptions does not hold during execution, the optimized
code is de-optimized and execution falls back to the interpreter.
To make the transition between interpreted execution and JIT
code execution seamless,
the interpreter and JIT compiler
share many data structures and memory regions. For exam-
ple, program variables, are stored in data objects, regardless
1Note that all three major JavaScript engines, SpiderMonkey, JavaScript-
Core, and V8, have bytecode interpreters in their script execution pipeline.
V8 has recently added the interpreter to reduce memory overhead in mobile
environments.
3
of where the script is executing. Other data structures and
memory regions might be used exclusively by one of the two
components.
2) Native Functions: During its execution, a script may call
C++ functions that are registered as so-called JavaScript native
(JSNative for short) functions. SpiderMonkey has hundreds
of JSNative functions. They provide the functionality of the
built-in JavaScript types and operations. In many cases, calls
to JSNative functions are not inlined, even when the caller
is a JIT-compiled function. Instead, SpiderMonkey transfers
control
to the JSNative function using a regular function
call. One important property of JSNative functions is that
SpiderMonkey calls them using an internal calling convention.
According to this calling convention, a JSNative function must
receive a pointer to the global JavaScript context object as
its ﬁrst argument, an argument count object as its second
argument, and a pointer to an argument array as its third
argument. Within the argument array, there is one slot that is
reserved to store the return value of the JSNative function.
However, upon calling a JSNative function, SpiderMonkey
stores a pointer to the callee’s JavaScript function object in
the return address slot.
3) Data Structures: Throughout our analysis of Spider-
Monkey’s implementation, we identiﬁed a number of key
memory areas that play a crucial role in ensuring the correct
and secure operation of the script engine: (1) the bytecode
region, (2) the JIT code cache, (3) the JIT compiler data, (4) the
JavaScript data objects, and (5) the object tables. The JIT code
is mapped as an executable memory region whereas all the
other areas are mapped as readable and writable regions. The
bytecode region includes instruction opcodes, and operands,
and is used by both the interpreter and the JIT compiler. The