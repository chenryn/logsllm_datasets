                        04:c7:11:16:2a:76:1d:56:8e:be:b9:62:65:d4:c3:
                        ce:b4:f0:c3:30:ec:8f:6d:d7:6e:39:bc:c8:49:ab:
                        ab:b8:e3:43:78:d5:81:06:5d:ef:c7:7d:9f:ce:d6:
                        b3:90:75:de:0c:b0:90:de:23:ba:c8:d1:3e:67:e0:
                        19:a9:1b:86:31:1e:5f:34:2d:ee:17:fd:15:fb:7e:
                        27:8a:32:a1:ea:c9:8f:c9:7e:18:cb:2f:3b:2c:48:
                        7a:7d:a6:f4:01:07:ac
                    Order: 
                        00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
                        ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:c7:63:4d:81:f4:
                        37:2d:df:58:1a:0d:b2:48:b0:a7:7a:ec:ec:19:6a:
                        cc:c5:29:73
                    Cofactor:  1 (0x1)
                    Seed:
                        a3:35:92:6a:a3:19:a2:7a:1d:00:89:6a:67:73:a4:
                        82:7a:cd:ac:73
            X509v3 extensions:
                X509v3 Subject Key Identifier: 
                    43:EF:70:87:B8:9D:BF:EC:88:19:DC:C6:C4:6B:75:0D:75:34:33:08
                X509v3 Authority Key Identifier: 
                    keyid:43:EF:70:87:B8:9D:BF:EC:88:19:DC:C6:C4:6B:75:0D:75:34:33:08
                X509v3 Basic Constraints: critical
                    CA:TRUE
        Signature Algorithm: ecdsa-with-SHA256
             30:64:02:30:4e:9f:c7:5b:ca:1e:bf:fe:d9:4b:25:db:be:58:
             d2:1e:32:e9:a5:a9:da:0c:e5:b1:00:25:82:6b:1e:9d:2c:55:
             72:f2:a6:c6:4b:94:e1:f6:2a:b6:20:4b:4c:b9:ef:29:02:30:
             32:84:a1:19:a2:ae:35:88:dd:b3:e0:77:fe:de:4f:dc:47:55:
             45:42:bf:4e:76:3a:ef:d2:57:ae:45:a2:d6:7f:b0:c0:d1:a8:
             6f:91:1d:11:c6:99:51:cd:d2:44:90:76
### 三、证书签名与验证
由于后面会涉及到证书的验证过程，所以在这里简单提一下相关算法及验证流程。
椭圆曲线数字签名算法（ECDSA）
椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（Digital Signature
Algorithm，DSA）的模拟。整个签名过程与DSA类似，只是签名中采用的算法为ECC。ECC的简要原理在前面介绍过，下面来看一下数字签名算法DSA，DSA的安全性基于离散对数求解的困难性，一般用于数字签名和认证。以下为DSA签名算法流程：
  1. 发送方使用HASH算法将发送内容加密产生摘要；
  2. 发送方使用私钥对摘要进行再次加密得到数字签名；
  3. 发送方将原文和数字签名传给接收方；
  4. 接收方使用发送方的公钥对签名进行解密得到摘要 ，同时对收到的内容使用同样的HASH算法加密生成摘要；
  5. 接收方将解密后的摘要和使用HASH算法加密生成的摘要进行比对，如果两者一致，则说明传输过程的信息没有被破坏和篡改，签名验证成功。
证书链验证
数字证书采用信任链验证。数字证书的信任锚（信任的起点）就是根证书颁发机构。根证书（root
certificate）一般为一个无签名或自签名的证书。证书链的验证一般如下图所示：
  1. 取上级证书的公钥，对下级证书的签名进行解密得出下级证书的摘要digest1；
  2. 对下级证书使用相同的哈希算法进行信息摘要得到digest2；
  3. 判断digest1和digest2是否相等，相等则说明这个下级证书没有被篡改且确实由上级证书签发，下级证书验证通过；
  4. 依次对各个相邻级别证书实施1～3步骤，直到根证书（或者可信任锚点[trusted anchor]，此时已经证明这条trust chain上的证书都是正确且可信任的；
## 补丁对比
补丁对比可以帮助我们快速定位到关键函数或关键位置，可使用 bindiff
对补丁前后的crypt32.dll进行比对，就不截图了。本次补丁主要修改了ChainGetSubjectStatus函数、CCertObjectCache::FindKnownStoreFlags函数及CertDllVerifyMicrosoftRootCertificateChainPolicy函数，并添加了一些函数，如ChainComparePublicKeyParametersAndByte函数、IsRootEntryMatch函数、ChainIsNullOrNoParameters函数、CveEventWrite函数（导入函数）等等。具体情况看下面的对比吧：
ChainGetSubjectStatus函数
ChainGetSubjectStatus函数中增加了对ChainComparePublicKeyParametersAndBytes函数的调用，该函数是补丁中新增的函数。补丁前的代码看上去只比较了两处0x10大小的数据，前提是v35中设置了标志2。
      v35 = *(_DWORD *)(v8 + 0x14);
      if ( v35 & 2 )
      {
        if ( !memcmp((const void *)(v8 + 0xF8), (const void *)(v37 + 0xE8), 0x10u) )
        {
    LABEL_11:
          v16 = (char *)a4 + 4;
          goto LABEL_12;
        }
        *(_DWORD *)a4 |= 8u;
      }
补丁后的代码在该流程中加入了ChainComparePublicKeyParametersAndBytes函数，如果该函数返回值大于0，则有可能执行
ChainLogMSRC54294Error函数，在该函数内部会调用CveEventWrite来将检测到的对CVE-2020-0601漏洞的利用情况写入Windows事件日志，所以后续可以从ChainGetSubjectStatus这个函数开始分析。
      v36 = ChainComparePublicKeyParametersAndBytes(
              *(int **)(v9 + 0x108),
              *(_DWORD *)(v9 + 0x10C),
              (int *)(*((_DWORD *)pvIssuer + 3) + 0x3C),
              *((_DWORD *)pvIssuer + 3) + 0x44);
      v26 = v36 == 0;
      if ( v36 > 0 )
      {
        if ( CryptVerifyCertificateSignatureEx(0, 1u, 2u, pvSubject, 2u, pvIssuer, 0, 0) )
          goto LABEL_40;
        ChainLogMSRC54294Error((PCCERT_CONTEXT)pvIssuer, *(unsigned int **)(v9 + 0x108));
        v26 = v36 == 0;
      }
在新增的ChainComparePublicKeyParametersAndBytes函数中有两次比对，分别是对a2、a4相应结构的比对和对a1、a3相应结构的比对。这很可能增加了对ECC算法参数的比较。
    signed int __fastcall ChainComparePublicKeyParametersAndBytes(int *a1, int a2, int *a3, int a4)
    {
      ...
      v9 = 0;
      v10 = 0;
      v4 = a1;
      if ( a2
        && a4
        && *(_DWORD *)a2 == *(_DWORD *)a4
        && *(_DWORD *)a2
        && !memcmp(*(const void **)(a2 + 4), *(const void **)(a4 + 4), *(_DWORD *)a2) )
      {
        v5 = 1;
        if ( !v4 )
          v4 = &v9;
        v6 = a3;
        if ( !a3 )
          v6 = &v9;
        if ( *v4 == *v6 )
        {
          if ( !*v4 || !memcmp((const void *)v4[1], (const void *)v6[1], *v4) )
            v5 = 0;
        }
CCertObjectCache::FindKnownStoreFlags函数
CCertObjectCache::FindKnownStoreFlags函数中也引入了ChainComparePublicKeyParametersAndByte函数。这里函数的四个参数就比较直观了，补丁前只比较了两个结构体偏移0x44处的结构，加入该函数后，增加了对结构体偏移0x3c处的结构（后面证实了这个结构体偏移0x3c处为算法参数的_CRYPTOAPI_BLOB结构）的比较。
    if ( v20 != v19 )
            {
              if ( *(_DWORD *)(v20 + 0x44) != *(_DWORD *)(v19 + 0x44)
                || (v4 = v17, memcmp(*(const void **)(v20 + 0x48), *(const void **)(v19 + 0x48), *(_DWORD *)(v20 + 0x44))) )
              {
                if ( !_InterlockedExchangeAdd((volatile signed __int32 *)i, 0xFFFFFFFF) )
                {
                  v21 = *(_DWORD *)(i + 4);
                  v22 = *(void (__thiscall **)(_DWORD, _DWORD))(v21 + 4);
    if ( v19 != v18 )
          {
            if ( ChainComparePublicKeyParametersAndBytes((int *)(v19 + 0x3C), v19 + 0x44, (int *)(v18 + 0x3C), v18 + 0x44) )
            {
              if ( !_InterlockedExchangeAdd((volatile signed __int32 *)v6, 0xFFFFFFFF) )
              {
                v20 = *(_DWORD *)(v6 + 4);
                v21 = *(void (__thiscall **)(_DWORD, _DW
CertDllVerifyMicrosoftRootCertificateChainPolicy函数
在CertDllVerifyMicrosoftRootCertificateChainPolicy函数中引入了IsRootEntryMatch函数，补丁前只比较了公钥哈希与硬编码数据。
    if ( !CryptHashCertificate2(
              L"SHA256",
              0,
              0,
              v8->SubjectPublicKeyInfo.PublicKey.pbData,
              v8->SubjectPublicKeyInfo.PublicKey.cbData,
              &pbComputedHash,
              &pcbComputedHash)
        || pcbComputedHash != 0x20 )
      {
    LABEL_19:
        v13 = 0x800B0109;
        v14 = v22 - 1;
        goto LABEL_16;
      }
      if ( v6 & 0x20000 )
      {
        if ( v6 & 0x10000 )
        {
          v13 = 0x80070057;
          goto LABEL_15;
        }
        v16 = dword_5CF09EF8;
        v17 = 0;
        while ( memcmp(v16, &pbComputedHash, 0x20u) )
新加入的IsRootEntryMatch函数的第一个参数为硬编码数据，第二个参数为通过证书公钥计算出的SHA256散列值，第三个参数为SubjectPublicKeyInfo.Algorithm.Parameters结构。
        v9 = (int)&v8->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters;
        if ( v6 & 0x20000 )
        {
          if ( v6 & 0x10000 )
          {
            v10 = 0x80070057;
    LABEL_34:
            v14 = 0;
            goto LABEL_19;
          }
          pcbComputedHash = 0;
          v11 = &off_5CF03210;
          v22 = &off_5CF03210;
          while ( !IsRootEntryMatch((int)v11, (int)&pbComputedHash, v9) )
在IsRootEntryMatch函数中首先比较a1、a2指向的0x20大小的散列值是否相同，不同的话返回0。然后比较算法参数是否相同，比较长度为*(_DWORD
*)a3，成功的话返回1。