and passed to the message receiver.
Note that in the example app there is a critical function:
getDeviceId() in the method getId() of Class2. Adversaries
cannot directly utilize this functionality, because the operand
tmpbool is false (i.e., the conditional statement C6). However,
by manipulating gadgets, adversaries may change the program
state (such as tmpbool’s value) and drive the app to call getId().
In getId() a JavaScript function is also required as part of the
event handler’s input to receive the device ID.
Although it appears simple to manually analyze this example
code, real-world apps are much more complex. Our goal is
to develop a technique that can automatically detect such
vulnerabilities and construct exploit code.
B. Threat Model
We assume that WebView is enabled in apps, but JavaScript
is not required to be enabled, since HTML code can also trigger
event handlers. We assume that adversaries can inject malicious
HTML/JavaScript code into WebView. As Figure 1 shows, we
consider the following two different attack scenarios:
• Web Attack: In this scenario, we assume adversaries
control several malicious domains and servers, but they
are not able to control or monitor the network trafﬁc
between apps and other domains.
The web content loaded from ﬁrst-parties is trustable.
However, the content may further contain subframes
•
(e.g., iframe) to load extra web content from third-
parties, which may be malicious.
Generally, all web frames loaded in WebView are well
isolated and protected by same origin policy (SOP)
[8].
Network Attack: Adversaries can hijack unsafe network
trafﬁc (such as HTTP) through man-in-the-middle
attacks. Compared with desktop programs, mobile apps
are more likely to suffer from this type of attacks,
considering that many unsafe WI-FI hotspots are used
[23].
Note that we do not assume any other abilities of the
adversaries. They may not access the users’ device, install any
certiﬁcate or malware, or change apps’ internal data. The target
app itself as well as all the apps pre-installed on the users’
devices may be benign.
C. Security Issues
Similar to other attacks on WebView [19], the security issues
caused by event handlers are rooted in the inconsistency of
security models between web and native context. In hybrid apps,
the SOP security model for the web context is circumscribed to
prevent event handlers from being triggered by malicious web
code, because the handlers do not have any way of identifying
the origin of an event (so they have no way to distinguish
between trusted and untrusted origins). SOP is also ineffective to
protect the local resources (such as camera), which are located
in the native context. The permission based sandbox model for
the native context can protect local resources. However, it is
ineffective to prevent the access to critical functionalities from
web code, since the origin information of the access is lost.
4
D. Problem Deﬁnition
We state that an exploit is successful if it successfully
triggers a critical functionality through event handlers deﬁned
in the app. A successful exploit must satisfy the constraints
in triggering target events and event handlers: it must guide
the target app to reach the target state by manipulating the
input and execution orders of gadgets, and it must bypass all
security checks which are usually located before the critical
functionality.
The event-oriented exploit generation problem can be
formally deﬁned as follows. Given an app, discover a program
state s that leads the app to execute a critical functionality. Such
a state should be reached through a sequence of executions
of gadgets ((W0, E0, I0, J0), (W1, E1, I1, J1), . . . , (Wn, En,
In, J0)), where Wi is the HTML/JavaScript code that triggers
the event Ei and passes the input Ii to Ei. Ii may also include
pre-deﬁned JavaScript code Ji.
E. Critical Functionalities
We deﬁne critical functionalities as sensitive APIs in the
Android framework. In this paper, we mainly consider the
following four types of APIs. Nevertheless, EOEDroid is
extensible and user customized APIs can be added easily.
URL Loading API (e.g., WebView.loadUrl(p)). If mali-
cious HTML/JavaScript code in subframes leverages the API
through EOE, the content of the main frame or the whole
WebView may be changed (Section II). Depending on the
value of the API parameter p, the following two consequences
may be caused.
•
•
Cross-Frame DOM Manipulation: If the web code in
subframes inﬂuences p’s value and makes p be starting
with “javascript:”, the JavaScript code contained in p
may be executed in the main frame. Hence, through
EOE, the web code in subframes obtains the capability
to bypass SOP and inject malicious code to the main
frame.
Phishing: If the web code in subframes can determines
p’s value through EOE, it may change p’s value to the
url of a fake web page. Then, WebView is redirected
to show the fake web page. Considering that WebView
usually does not have an address bar to indicate the
url it is loading, such attacks on WebView are much
more stealthy than on regular web browsers.
Compared with other attack channels (such as MITM
attacks) which may also be utilized to perform above attacks,
EOE over loadUrl() is more powerful. Considering the situation
that WebView loads a webpage from developers’ web site using
HTTPS, and one of its nested subframes uses HTTP. Due to
boundaries between frames, existing attacks may only be able
to control the content of the subframe, but not the main frame.
However, EOE does not have this limitation. By means of
loadUrl(), adversaries can directly change the content of the
main frame.
Source and Sink APIs. This type of API invocations
may result in users’ privacy leakage. We mainly consider two
scenarios: (1) there are paths from source to sink in event
handlers. (2) source is passed to the web space, and then sent
out through HTML/JavaScript code.
We consider the Android ID, device ID, phone number, and
serial number, and GPS location information as source, and
connecting network and sending text message as sink.
APIs Accessing Local Resources. This type of APIs
may be leveraged by adversaries to access local resources,
such as local ﬁles, and hardware resource (e.g., camera).
Serious consequences may be caused when these APIs are
combined with other sensitive APIs. For instance, adversaries
may remotely take a picture and also save it to the local storage
using camera APIs. Then, adversaries may obtain the picture
in the web context through ﬁle reading API and further send
the picture out through native sink APIs or HTML/JavaScript
code.
APIs Sending Intent messages. As demonstrated by Wang
et al. [36], the Intent messages that are sent out through
WebView may have serious consequences. We consider the
following type of APIs as sensitive: the API parameter is totally
controlled by adversaries, which means the destination of the
Intent message to be sent is totally determined by adversaries.
For other Intent-sending APIs, we treat them as regular inter-
component communications.
IV. SYSTEM OVERVIEW
In this section, we provide an overview of EOEDroid
and illustrate it with the motivating example described in
the previous section. The technical details of EOEDroid are
presented in Section V.
We use the following basic concepts and notations:
•
•
A Symbolic Conditional Statement: a conditional state-
ment whose operands are symbolic.
Path Constraints: all constraints that must be satisﬁed
when guiding an app to execute a path. Different from
prior work, EOEDroid involves both symbolic and non-
symbolic conditional statements in path constraints.
Input Constraints: A subset of path constraints but are
only related to event handlers’ input.
•
We assume that s is the target program state that leads to
the execution of a critical functionality; f is the target critical
functionality; p0 is the path containing f; eh0 is the event
handler containing p0.
A. Overview
EOEDroid consists of three modules: event handler analysis,
program state analysis, and exploit code generation, as shown
in Figure 2. In the ﬁrst module, selective symbolic execution
is used to explore paths in the event handlers and collect path
constraints. To apply the technique for Android hybrid apps,
technical challenges (Section V-B) are addressed by four sub-
modules: analysis sandbox, heuristic generation, Intent handler,
and array-indexing type implicit ﬂow handler. More speciﬁcally,
given an app, “selective symbolic execution” is called to
repeatedly test each event handler until all the inside interesting
paths are traversed. The interesting paths are discovered by the
sub-module “heuristic-generation”. Note that when a branch
is ﬂagged as interesting, no matter whether the conditional
statement is symbolic or not, EOEDroid forcely traverses
this path. Meanwhile, the corresponding path constraint is
constructed and saved.
5
For each round of test, the sub-module “analysis sandbox”
is applied to guard the analysis environment from pollution
and keep each round of test independent.
In the second phase, the module “program state analysis”
runs to discover state s and learn how to reach s by manip-
ulating event handlers’ input and execution order, which are
handled by the sub-modules “event handler input generation”
and “event handler execution order generation” respectively.
For event handlers’ input, it is generated by applying an SMT
solver in the associated input constraints collected in the ﬁrst
phase. For event handlers’ execution order, it is generated by
solving the event handler dependency problem (as described
in Section I).
For each path p that contains critical functionalities, EOE-
Droid repeatedly resolves all event handler dependencies for p
with four steps: (1) it analyzes p’s path constraints to identify
all non-symbolic conditional statements; (2) it conﬁrms the
expected value v for each conditional statement; (3) starting
from each conditional statement c,
it performs backward
program analysis to determine the variables O that can inﬂuence
c’s operands, and further computes the required value for each
variable in O; and (4) it analyzes all paths in all event handlers
that contain the instructions changing the variables in O to
their corresponding expected values.
In the third phase, the module exploit code generation
generates exploit code for each exploitable critical functionality.
First, the event handlers’ execution order generated in the
second phase is converted to the web event order, and the
event handlers’ input is converted to the corresponding web
events’. Second, if JavaScript code is required as the event
handler’s input (such as the callback function in our motivating
example), the syntax of the associated JavaScript code is parsed
and analyzed to generated required JavaScript code.
B. Analyzing the Example
Now we illustrate how EOEDroid works for our motivating
example. When the event handler shouldOverrideUrlLoading()
is triggered, EOEDroid is started. First of all, EOEDroid sym-
bolizes the event handler’s second parameter as ‘InputUrl’, since
its value can be controlled by adversaries. Then, EOEDroid
analyzes each instruction. As the class Uri is frequently used,
we model it by symbolizing its instance u as ‘Uri.(Input
Url)’. The input’s scheme and host are also symbolized, whose
symbolic expressions are ‘Uri.(InputUrl).getScheme()’
and ‘Uri.(InputUrl).getHost()’, respectively.
When the conditional statement C1 is analyzed, “heuristic
generation” is started to discover which branches are interesting.
In this case, both branches have interesting instructions. So
both of them are sequentially traversed. In the true branch,
when an Intent message is sent to another app or component,
the module “Intent handler” (Section V-B3) is set up to ﬁll
the symbolic information gap between the sender and receiver.
Similarly, the conditional statements C2, C3 and C4 are
processed. In C4’s true branch, EOEDroid encounters a special
conditional statement that is non-symbolic (i.e., C5). As its
true branch is interesting, EOEDroid forcely executes it and
also collects necessary information, such as the executed path
information, the instruction’s position (such as ), the condition expression (i.e., tmpbool == 0), the operand
variable (i.e., tmpbool), current value of the variable (i.e., 0) and
its selected branch (i.e., 1). Note that in this path the external
ﬁeld variable Initialized is written. To ensure each round of test
is independent, such interaction between the event handler and
the external variable is handled by the sub-module “analysis
sandbox”.
The conditional statement C6 is then reached. In the true
branch, the host name is split to an array, whose symbolic
expression is Uri.(InputUrl).getHost().split("."). Then,
an implicit ﬂow is faced, which is caused by the Hashmap
accessing operation. To handle it, the sub-module “implicit
ﬂow handler” is started to try all possibilities in the Hashmap
instance. Therefore, a critical functionality is found in getId() in
Class2, which can be leveraged by adversaries to perform cross-
frame DOM manipulation and steal the device ID information.
The main associated path constraints are shown in Listing 1.
(1) Uri.(InputUrl).getScheme().equals("market") == 0
(2) Uri.(InputUrl).getScheme().equals("tel") == 0
(3) Uri.(InputUrl).getScheme().equals("sms") == 0
(4) Uri.(InputUrl).getHost().equals("developer.com")
(5) Uri.(InputUrl).getScheme().equals("sdk") (cid:54) = 0
(6) tmpbool (cid:54) = 0
(7) Uri.(InputUrl).getHost().split(".").length == 3
(8) Uri.(InputUrl).getHost().split(".")[0].equals("c2
== 0
(9) Uri.(InputUrl).getHost().split(".")[1].equals("
") (cid:54) = 0 // generated by implicit flow handler
getId") (cid:54) = 0
Listing 1: Path Constraints In Executing getId()
In the second phase, the module “program state analysis”
analyzes the path constraints (Listing 1) to change the program
state. First, the sub-module “event handler input generation”
checks if the constraints can be satisﬁed by feeding the event
handler with appropriate input. In this case, all constraints
except (6) can be satisﬁed. Second, the sub-module “event
handler execution order generation” runs to check how to
inﬂuence the program state to satisfy the constraint (6). Starting
from the conditional statement C6, EOEDroid backward tracks
the operand tmpbool along the executed path, and conﬁrms
the variable (i.e., Initialized) can inﬂuence its value. Next,
EOEDroid goes through all paths identiﬁed in the ﬁrst phase
to check whether there is a path that contains an instruction
changing Initialized’s value. It ﬁnds that Path3 contains
the expected operation. Hence,
there is an event handler
dependency on C6:  C6−−→
.
In the third phase, the module “exploit code generation”
generates the exploit code for the critical functionality in getId().
To drive the app to execute the critical functionality, event
handlers should be executed as follows:
(1) shouldOverrideUrlLoading(webview, "sdk://init")
(2) shouldOverrideUrlLoading(webview, "sdk://c2.getId.?")
Then, the above event handler execution order is converted
to the web event order, and further transformed to the following
HTML/JavaScript code (based on our event handler study
presented in Section V-A):
The above code can change the program state and reach the
sensitive API loadUrl(). However, part of the event handler’s
input is still missing, which is a JavaScript callback function
used to receive the sensitive information (i.e., device ID).
To address this problem, the sub-module “JavaScript code
syntax analysis” runs to analyze the syntax of the parameter of
loadUrl(), and generate required JavaScript code. Finally, the
6
following exploit code is generated, which can help developers
test and verify the EOE problem.