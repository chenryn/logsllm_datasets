@import as if it were CSS. This is a backward compatibility
feature, part of the “quirks mode” applied to HTML docu-
ments that do not include a proper document type deﬁnition
(DTD). In the “standards mode” recommended for new sites,
style sheets will only be processed if they are labeled with
the HTTP header Content-Type: text/css.
The attacker, of course, controls whether or not the at-
tacking page is in quirks mode. However, the attacker has
no control over the Content-Type header labeling the target
page; that’s generated by the target site’s server. Therefore,
our proposed client-side defense is to enforce content type
checking for style sheets loaded cross-origin, even if the re-
questing page is in quirks mode. We describe two variants
on this proposal.
4.1.1
Strict enforcement refuses to load any style sheet cross-
origin, unless it is properly labeled text/css. Since the
target document is labeled text/html, application/json,
text/rss+xml, or some other non-CSS content type, the
browser will not load it as a style sheet, foiling the attack.
Strict Enforcement
Strict enforcement may cause legitimate requests for cross-
origin style sheets to fail, if the server providing the style
sheet is misconﬁgured. Unfortunately, content type miscon-
ﬁgurations are common, so strict enforcement may be too
risky for browser vendors to adopt.
4.1.2 Minimal Enforcement
To address this concern, we also propose a more tolerant
solution: minimal enforcement blocks a CSS resource if and
only if it is loaded cross-origin, has an invalid content type,
and is syntactically malformed. When the browser encounters
a cross-origin style sheet labeled with the wrong content
type, it begins parsing the sheet as CSS, but if it encounters
a syntax error before it has processed the ﬁrst complete
style rule, it stops and discards the sheet. This rule allows
legitimate but misconﬁgured sites to continue to work, as
long as the ﬁrst thing in their cross-origin, mislabeled style
624Requesting Rendering
Correct type
Incorrect type
server
Same-origin
Cross-origin
mode
Standards
Quirks
Standards
Quirks
Total
180,445
25,606
47,943
6,075
260,069
Total HTTP error Well-formed Malformed Well-formed Malformed
1
59
0
0
60
178,017
24,445
47,345
5,891
255,698
1,497
466
347
53
2,363
506
332
104
57
999
424
304
147
74
949
Table 2: Categorization of CSS references for the Alexa top 100,000 sites.
sheet is a well-formed CSS rule. This defense will still foil
most cross-origin CSS attacks, which attempt to load a non-
CSS document as CSS; for instance, HTML almost always
begins with  or a DOCTYPE declaration, either of which
will cause a CSS syntax error.
4.2 Experiment
To evaluate the compatibility of our proposed defense of
content type checking for cross-origin CSS loads, we surveyed
the public Web to determine how often servers fail to provide
the correct content type for style sheets, how often style
sheets begin with a CSS syntax error, and how often style
sheets are requested from a diﬀerent origin.
Design.
Using an instrumented browser based on WebKit [15],
we crawled the top 100,000 web sites ranked by Alexa [1]
and identiﬁed all of the style sheet resources used by their
front pages. Our instrumentation reported every style sheet
requested while the page itself was loading. This allowed us
to identify sheets used indirectly via CSS @import directives,
and sheets added by JavaScript during page load, as well as
those referenced directly in the HTML.
Results.
From these 100,000 web sites, our crawler logged a total of
260,069 CSS references, of which 206,051 were same-origin
and 54,018 cross-origin. We did not include data for sites that
were unreachable during our evaluation, due to unresponding
servers or domain name errors. Our results are shown in
Table 2.
Of these 260,069 requested style sheets, 2,363 returned
an HTTP error (e.g. 400 Bad Request, 404 Not Found, or
500 Internal Server Error) rather than a style sheet. These
resources are unreachable, so they already have no eﬀect on
the rendering of the page; our proposal does not change this.
Excluding the responses with HTTP errors, 1,009 were
labeled with an incorrect Content-Type header (that is, any-
thing but Content-Type: text/css). We summarize the
incorrect headers we observed in Table 3; text/html is the
most common value, accounting for 71% of errors. Some of
Incorrect Content-Type
Occurrences
text/html
text/plain
application/octet-stream
other
missing
715
45
29
42
178
(71%)
(4%)
(3%)
(4%)
(18%)
Table 3: Incorrect Content Types Observed for CSS
these text/html responses were HTML landing pages pro-
duced (with a 200 OK response code) because the desired
style sheet no longer existed; the content type is correct in
this case, but the server is still misconﬁgured, as it should
have produced an HTTP error. Style sheets labeled with the
generic types text/plain and application/octet-stream
make up a further 7% of the total, and a few other speciﬁc
types appeared, e.g. application/x-javascript.
The second most common error, accounting for 18% of
the total, is to provide no Content-Type header at all, or a
header with no value; these are listed together in table 3 as
“missing.” Most browsers will process a style sheet with a
missing content type, even in standards mode. See Section 4.4
for further discussion of this wrinkle.
The crawler logged whether standards or quirks mode was
in eﬀect for each HTML page that loaded a CSS resource.
Quirks mode is in eﬀect for a substantial minority of the
100,000 sites crawled, but of the 260,069 requests for CSS,
only 31,681 came from pages in quirks mode. In standards
mode, style sheets are always discarded if they are labeled
with the wrong content type; we observed 572 such futile
requests in our sample. From pages in quirks mode, there
were 437 requests for sheets that were labeled with the wrong
type; these sheets are honored.
The crawler also recorded whether a style sheet was served
from the same origin as the requesting HTML document. It
is most common to serve style sheets from the same origin as
the HTML, but we did observe 54,018 cross-origin requests,
6,075 of which were for pages in quirks mode. Only 74
of those cross-origin requests were labeled with the wrong
content type.
Finally, the crawler checked whether each sheet began
with a well-formed CSS construct. 1,059 sheets (0.41% of
the sample) were malformed. (It is interesting to note that a
common error among these malformed sheets is to start the
ﬁle with an HTML  tag.) Only 60 sheets were both
malformed and labeled with an incorrect content type, and
none of these were served cross-origin.
Discussion.
Within the Alexa top 100,000 web sites, we observed a
total of 1,009 CSS resources labeled with an incorrect content
type (excluding responses with HTTP errors). Of these, 572
are associated with sites being rendered in standards mode,
and are therefore already being ignored. Of the remaining
437 style sheets, 74 are loaded cross-origin; these are the
sheets that would be rejected by the strict defense, breaking
62 (0.06%) of the Alexa sites. This is enough to make browser
vendors reluctant to deploy strict enforcement. The minimal
defense, which accepts cross-origin, mislabeled sheets unless
they are also malformed, would not break any of the top
100,000 sites.
625Content-Type
Opera
Safari Chrome Firefox 3.5/3.6 Firefox 4
IE 8
text/html, other well-formed non-CSS
*/*, other ill-formed values
Header missing
application/x-unknown-content-type
M
M
M
M
M
M
M
M
M
S
M = minimal defense; S = strict defense; blank = no defense.
Table 4: Handling of Missing or Ill-Formed Content-Type Headers after our Proposal
Many sites provide additional content to registered users.
Due to practical limitations of our automated scanning, our
results are for unauthenticated access. It is possible that
more sites would be broken (by either form of the defense) if
viewed by an authenticated user.
4.3 Adoption
Our proposal has been adopted by several major brow-
sers. We implemented minimal enforcement for WebKit, and
both minimal and strict enforcement for Mozilla’s Gecko
engine. Minimal enforcement based on our changes has been
deployed in Google Chrome 4.0.249.78, Safari 4.0.5, and both
Firefox 3.5.11 and 3.6.7. Firefox 4 instead oﬀers strict en-
forcement, which Mozilla considers preferable in the long
term. Opera has also adopted our minimal enforcement
proposal for version 10.10 of their browser.
4.4 Missing or Ill-Formed Content Types
To be fully reliable, our proposed defenses should be ap-
plied whenever a style sheet lacks the proper text/css label,
including when the Content-Type header is missing or has
an ill-formed value. Recall from Table 3 that we saw 178
CSS resources that lacked a Content-Type header in our
survey. However, as shown in Table 4, most browsers—with
the notable exception of Opera—do accept cross-origin style
sheets if they lack a Content-Type header, even in standards
mode. Firefox ignores Content-Type headers that it cannot
parse (e.g. Content-Type: */*) and will therefore also accept
a cross-origin style sheet with an ill-formed Content-Type.
Finally, Webkit and Firefox both treat the special type
application/x-unknown-content-type the same as the ab-
sence of a header.
These gaps in the defense could open up a target server to
attack, if it fails to set a Content-Type header on its HTML
documents. We have not yet observed any web servers in
the wild that are aﬀected by this vulnerability, but browsers
may wish to follow Opera’s lead and block such style sheets
when loaded across origins. In any case, we recommend that
servers always provide a correct Content-Type header.
4.5 Other Client-Side Approaches
Other defensive approaches could be deployed in browsers
without modifying web servers, but we argue that all of them
could easily be circumvented, or else would signiﬁcantly
reduce web compatibility.
4.5.1 Block Cookies
If HTTP cookies are disabled in the browser, web at-
tackers cannot steal content from cookie-authenticated sites.
However, completely disabling cookies renders many sites
unusable. Some browsers have the option to block only
“third-party” cookies, which prevents cookies from being set
by a cross-origin load. Unfortunately, this mode typically
does not block cookies from being sent with a cross-origin
load, because some sites require session cookies for cross-
origin resources [17]. Blocking only cookie sets does not
block cross-origin CSS attacks.
4.5.2 Block JavaScript Style APIs
Many browsers already prevent JavaScript from reading
parsed style rules when those rules were loaded cross-origin;
this could be done more thoroughly, and they could also
prevent access to computed style when the chosen value
came from a cross-origin sheet. These changes would stop
some attacks, but an attacker could still use the no-JavaScript
technique of triggering an HTTP request directly from the
style sheet.
4.6 Server-Side Mitigation
In this section, we consider approaches that can be adopted
by web servers without requiring changes to current browsers.
Web applications may wish to adopt such mitigations to
protect users of browsers that have not yet adopted our
proposed defenses, such as Internet Explorer.
4.6.1 Newlines
The CSS speciﬁcation does not allow strings and URLs
to contain newlines. Most browsers enforce this rule, so
sites can defend against cross-origin CSS attacks by inserting
newlines before and after potential injection points. This
does not protect users of Internet Explorer, which does not
enforce this particular rule.
4.6.2 HTML Encoding
CSS-based attacks can be thwarted by substituting HTML