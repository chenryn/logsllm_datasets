来实现。不过，如果使用Subject：*，我们就能在之后的程序中使用捕获型括号来
访问主题的内容（例如Perl中的s1）（译注3）。
译注2：zeromatch，即不匹配任何宇符也能成功的匹配。
译注3：这个例子用捕获型括号来讲解匹配优先，所以它只适用于NFA（只有NFA支持捕获型
括号）。不过，匹配优先的特性对所有引擎都是一样的，包括不支持捕获的DFA。
---
## Page 178
152
第4章：表达式的匹配原理
在探讨".*匹配邮件主题之前，请读者记住，一旦“Subject：·能够部分匹配，整个正则
表达式就一定能够全部匹配。因为~Subject：·之后没有字符会导致表达式匹配失败：.*
永远不会失败，因为“不匹配任何字符”也是".*的可能结果之一。
那么，为什么要添加".*呢？这是因为我们知道，星号是匹配优先的，它会用点号匹配尽
可能多的字符，所以我们用它来“填充”$1。事实上，括号并没有影响正则表达式的匹配
过程，在本例中，我们只是用它们来包括.*匹配的字符。
.*到达字符串的末尾之后点号不能继续匹配，所以星号最终停下来，尝试匹配表达式中
的下一个元素（尽管.*无法继续匹配了，但下面的子表达式或许能够继续匹配）。不过，
因为本例中不存在后面的元素，到达表达式的末尾之后，我们就获得了成功的匹配结果。
过度的匹配优先
个"*，把正则表达式写作“Subject：（.*)，结果会是如何呢？答案是，没有变化。开
头的.*（括号中的）会霸占整个标题的文本，而不给第二个.*留下任何字符。而第二个
.*的匹配失败并不要紧，因为".*不匹配任何字符也能成功。如果我们给第二个.*也加
上括号，$2将会是空白。
这是否说明，在正则表达式中，.*的部分没有机会匹配任何字符呢？答案显然是否定的。
就像我们在W+S这个例子中看到的，如果进行全部匹配必须这样做，表达式中的某些部
），），
{^.*（[0-9]（0-9]）或许是个有用的正则表达式，它能够匹配一行字符的最后两位数字，
如果有的话，然后将它们存储在S1中。下面是匹配的过程：.*首先匹配整行，而[0-9]
[0-9]是必须匹配的，在尝试匹配行末的时候会失败，这样它会通知.*：“嗨，你占的太
多了，交出一些字符来吧，这样我没准能匹配。”匹配优先组件首先会匹配尽可能多的字符，
但为了整个表达式的匹配，它们通常需要“释放”一些字符（抑制自己的天性）。当然，它
们并不“愿意”这样做，只是不得已而为之。当然，“交还”绝不能破坏匹配成立必须的条
件，比如加号的第一次匹配。
---
## Page 179
表达式主导与文本主导
153
明白了这一点，我们来看^.*（[0-9][0-9]）匹配‘about·24characters·long’的过程。
.*匹配整个字符串以后，第一个[0-9]的匹配要求.*释放一个字符‘g’（最后的字符）。
但是这并不能让“[0-9]匹配，所以.*必须继续“交还”字符，接下来交还的字符是‘n”。
如此循环15次，直到".*最终释放‘4’为止。
不幸的是，即使第一个[0-9]能够匹配‘4'，第二个“[0-9]仍然不能匹配。为了匹配整
个正则表达式，.*必须再次释放一个字符，这次是‘2'，由第一个[0-9]；匹配。现在，‘4”
能够由第二个[0-9]：匹配，所以整个表达式匹配的是‘about·24;char…'，$1的值是‘24”。
先来先服务
如果用~.*[0-9]+来匹配一行的最后两个数字，期望匹配的不止是最后两位数字，而是最
后的整个数，结果会是多长呢？如果用它来匹配‘Copyright2003.”，结果是什么？答
案在下一页。
深入细节
许容易引起混淆。我使用这些说法是因为它们易于理解，而且跟实际的结果一致。不过，
事情的真相是由基本的引擎类型决定一—是DFA，还是NFA。现在我们就来看这些。
表达式主导与文本主导
Regex-DirectedVersusText-Directed
DFA和NFA反映了将正则表达式在应用算法上的根本差异。我把对应汽油机的NFA称为
“表达式主导（regex-directed）”引擎，而对应电动机的DFA称为“文本主导（text-directed）”
引擎。
NFA引擎：表达式主导
NFAEngine:Regex-Directed
我们来看用'to（nitelknightInight）匹配文本‘…tonight.…’的一种办法。正则表达式
从‘t开始，每次检查一部分（由引擎查看表达式的一部分），同时检查“当前文本（current
text）”是否匹配表达式的当前部分。如果是，则继续表达式的下一部分，如此继续，直到
表达式的所有部分都能匹配，即整个表达式能够匹配成功。
---
## Page 180
154
第4章：表达式的匹配原理
测验答案
153页测验的答案
用^.*（[0-9]+）：匹配‘copyright2003.”，括号会输获到什么？
这个表达式的本意是捕获整个数字2003，但结果并非如此。之前已经说过，为了满足
[0-9]+的匹配，.*必须交还一些字符。在这个例子中，释放的字符是最后的“3”
和点号，之后‘3’能够由[0-9]：匹配。[0-9]；由‘+量词修饰，所以现在还只做到
了最小的匹配可能，现在它遇到了‘.”，找不到其他可以匹配的字符。
与之前不同，此时没有“必频”匹配的元素，所以‘.*不会被迫交出0。否则、[0-9】+]
应当心存感激，接受匹配优先元素的馈赠，但请记住“先来先服务”原则。匹配优先
的结构只会在被迫的情况下交还字符。所以，最终S1的值是“3”。
如果读者觉得难以理解，不妨这样想，[0-9]+1和[0-9]*差不多，而本例中（0-9]*
和*是一样的。用它来替换原来的表达式"~.*（[0-9]+)1，我们得到.*（），这
与152页的“~Subject：*（.*）很相似，第二个".*不会匹配任何字符。
在'to（nitelknightInight）i的例子中，第--个元素是‘t，它将会重复尝试，直到在目标
字符串中找到‘t’为止。之后，就检查紧随其后的字符是否能由匹配，如果能，就检
查下面的元素。在本例中，“下面的元素”指（nitelknightInight）它的真正含义是“nite)
或者knighti或者nighti”。引擎会依次尝试这3种可能。我们（具有高级神经网络的人
类）能够发现，如果待匹配的字符串是tonight，第三个选择能够匹配。不论神经学起源
（85）如何，表达式主导的引擎必须完全测试，才能得出结论。
尝试nite的过程与之前一样：“尝试匹配ni，然后是i，然后是t，最后是e)。”如果这
种尝试失败一—就像本例，引擎会尝试另一种可能，如此继续下去，直到匹配成功或是报
告失败。表达式中的控制权在不同的元素之间转换，所以我称它为“表达式主导”。
---
## Page 181
表达式主导与文本主导
155
NFA引擎在操作上的优点
实质上，在表达式主导的匹配过程中，每一个子表达式都是独立的。这不同于反向引用，
子表达式之间不存在内在联系，而只是整个正则表达式的各个部分。在子表达式与正则表
达式的控制结构（多选分支、括号以及匹配量词）的层级关系（layout）控制了整个匹配过
程。
现他/她期望的结果（第5章和第6章将会告诉读者，如何正确高效地实现目标)。现在看
起来，这点还有些模糊，但过一段就会变清晰。
DFA引擎：文本主导
DFAEngine:Text-Directed
与表达式主导的NFA不同，DFA引擎在扫描字符串时，会记录“当前有效（currentlyinthe
works)”的所有匹配可能。具体到tonight的例子，引擎移动到t时，它会在当前处理的
匹配可能中添加一个潜在的可能：
字符串中的位置
正则表达式中的位置
after.….tonight.….可能的匹配位置：'to（nite|knight|night））
接下来扫描的每个字符，都会更新当前的可能匹配序列。继续扫描两个字符以后的情况是：
字符串中的位置
正则表达式中的位置
after...toni ght...
可能的匹配位置：to（nitelknightInight）
有效的可能匹配变为两个（knight被淘汰出局）。扫描到g时，就只剩下一个可能匹配了。
当h和t匹配完成后，引擎发现匹配已经完成，报告成功。
我称这种方式为“文本主导”，是因为它扫描的字符串中的每个字符都对引擎进行了控制。
在本例中，某个未完成的匹配也许是任意多个（只要可行）匹配的开始。不合适的匹配可
能在扫描后继文字时会被去除。在某些情况下，“处理中的未终结匹配（partialmatchin
progress）”可能就是一个完整的匹配。例如正则表达式'to（）？，括号内的部分并不是必
须出现的，但考虑到匹配优先的性质，引擎仍然会尝试匹配括号内的部分。匹配过程中，
在尝试括号内的部分时，完整匹配（to'）已经保留下来，以应付括号中的内容无法匹配
的情况。
---
## Page 182
156
第4章：表达式的匹配原理
如果引擎发现，文本中出现的某个字符会令所有处理中的匹配可能失效，就会返回某个之
前保留的完整匹配。如果不存在这样的完整匹配，则要报告在当前位置无法匹配。
第一想法：比较NFA与DFA
First Thoughts: NFA and DFA in Comparison
如果读者根据上面介绍的知识比较NFA和DFA，可能会得出结论：一般情况下，文本主导
表达式匹配，可能会浪费时间（就好像上面例子中的3个分支）。
这个结论是对的。在NFA的匹配过程中，目标文本中的某个字符可能会被正则表达式中的
检查表达式中剩下的部分，找到匹配，它也可能需要再一次应用（甚至可能反复多次）。单
独的子表达式可能匹配成功，也可能失败，但是，直到抵达正则表达式的末尾之前，我们
都无法确知全局匹配成功与否（也就是说“不到最后关头不能分胜负（It'snotoveruntilthefat
ladysings）”，但这句话又不符合本段的语境）。相反，DFA引I擎则是确定型的（deterministic）
一目标文本中的每个字符只会检查（最多）一遍。对于一个已经匹配的字符，你无法知
道它是否属于最终匹配（它可能属于最终会失败的匹配），但因为引擎同时记录了所有可能
的匹配，这个字符只需要检测一次，如此而已。
正则表达式引擎所使用的两种基本技术，都对应有正式的名字：非确定型有穷自动机（NFA）
和确定型有穷自动机（DFA)。这两个名字实在是太饶舌，所以我坚持只用DFA和NFA。
下文中不会出现它们的全称了(注4)。
用户需要面对的结果
因为NFA具有表达式主导的特性，引擎的匹配原理就非常重要。我已经说过，通过改变表
达式的编写方式，用户可以对表达式进行多方面的控制。拿tonight的例子来说，如果改
变表达式的编写方式，可能会节省很多工夫，比如下面这3种方式：
‘to(ni(ght|te)1knight))
·'toniteltoknight|tonight;
·'to(k?night(nite)1
注4：我例是希望能讲解这两个名字背后的理论，可惜我不知道该如何做。我已经暗示，“确定
型”这个名词是很重要的，但是，我们只需要懂得实际的效果，而这套理论的大部分内容
与本书无关。读完本章，你会发现事实就是扣此。
---
## Page 183
回潮
157
给出任意文本，这3个表达式都可以捕获相同的结果，但是它们以不同的方式控制引擎。
现在，我们还无法分辨这3者的优劣，不过接下来会看到。
DFA的情况相反一一引擎会同时记录所有的匹配选择，因为这3个表达式最终能够捕获的
文本相同，在写法上的差异并无意义。取得一个结果可能有上百种途径，但因为DFA能够
同时记录它们（有点神奇，待稍后详述），选择哪一个表达式并无区别。对纯粹的DFA来
说，即使'abci和[aa-a]（blb（l）lb)ci看来相差巨大，但其实是一样的。
如果要描述DFA，我能想到的特征有：
·DFA匹配很迅速。
·DFA匹配很一致。
·谈论DFA匹配很恼人。
最终我会展开这3点。
因为NFA是表达式主导的，谈论它是件很有意思的事情。NFA为创造性思维提供了丰富的
施展空间。调校好一个表达式能带来许多收益，调校不好则会带来严重后果。这就好比发
动机的熄火和点不着火，他们并不只是汽油发动机的专利。为了彻底弄明白这个问题，我
们来看NFA最重要的部分：回溯（backtracking)。
回溯
Backtracking
NFA引擎最重要的性质是，它会依次处理各个子表达式或组成元素，遇到需要在两个可能
成功的可能中进行选择的时候，它会选择其一，同时记住另一个，以备稍后可能的需要。
需要做出选择的情形包括量词（决定是否尝试另一次匹配）和多选结构（决定选择哪个多
选分支，留下哪个稍后尝试）。
不论选择那一种途径，如果它能匹配成功，而且正则表达式的余下部分也成功了，匹配即
告完成。如果正则表达式中余下的部分最终匹配失败，引擎会知道需要回溯到之前做出选
择的地方，选择其他的备用分支继续尝试。这样，引擎最终会尝试表达式的所有可能途径
（或者是匹配完成之前需要的所有途径）。
---
## Page 184
158
第4章：表达式的匹配原理
真实世界中的例子：面包屑
A Rcally Crummy Analogy
回溯就像是在道路的每个分岔口留下一小堆面包屑。如果走了死路，就可以照原路返回，
直到遇见面包屑标示的尚未尝试过的道路。如果那条路也走不通，你可以继续返回，找到
下一堆面包屑，如此重复，直到找到出路，或者走完所有没有尝试过的路。
在许多情况下，正则引擎必须在两个（或更多）选项中做出选择一我们之前看到的分支
的情况就是一例。另一个例子是，在遇到x？时，引擎必须决定是否尝试匹配x1。对
于x+的情况，毫无疑问，x至少尝试匹配一次一一因为加号要求必须匹配至少一次。
第一个x匹配之后，此要求已经满足，需要决定是否尝试下一个x。如果决定进行，还要
决定是否匹配第三个x，第四个x，如此继续。每次选择，其实就是洒下一堆“面包屑”，
用于提示此处还有另一个可能的选择（目前还不能确定它能否匹配），保留起来以备用。
一个简单的例子
现在来看个完整的例子，用先前的to（nitelknightInight）；匹配字符串‘hot'tonic
tonight！’（看起来有点无聊，但是个好例子)。第-个元素t从字符串的最左端开始尝
试，因为无法匹配‘h'，所以在这个位置匹配失败。传动装置于是驱动引擎向后移动，从
第二个位置开始匹配（同样也会失败），然后是第三个。这时候‘t能够匹配，接下来的‘o
无法匹配，因为字符串中对应位置是一个空格。至此，本轮尝试宣告失败。
继续下去，从tonic.…开始的尝试则很有意思。to匹配成功之后，剩下的3个多选分支
都成为可能。引整选取其中之一进行尝试，留下其他的备用（也就是洒下一些面包屑）。在
讨论中，我们假定引擎首先选择的是‘nite)。这个表达式被分解为“n+i+'t)+e”，在
toiC遭遇失败。但此时的情况与之前不同，这种失败并不意味着整个表达式匹配失败
一一因为仍然存在没有尝试过的多选分支（就好像是，我们仍然可以找到先前留下的面包
屑）。假设引擎然后选择knight)，那么马上就会遭遇失败，因为k不能匹配‘n'。现在只
剩下最后的选项night，但它不能失败。因为'night是最后尝试的选项，它的失败也就意
味着整个表达式在tonic.…的位置匹配失败，所以传动机构会驱动引l擎继续前进。
---
## Page 185
回溯
159
直到引擎开始从…tonight！处开始匹配，情况又变得有趣了。这一次，多选分支'night
终于可以匹配字符串的结尾部分了（于是整体匹配成功，现在引擎可以报告匹配成功了）。
回溯的两个要点
Truo lmportant Points on Backtracking
回溯机制的基本原理并不难理解，还是有些细节对实际应用很重要。它们是，面对众多选
择时，哪个分支应当首先选择？回溯进行时，应该选取哪个保存的状态？第一个问题的容
案是下面这条重要原则：
选择“进行尝试”，而对于忽略优先量词，会选择“跳过尝试”。
此原则影响深远。对于薪手来说，它有助于解释为什么匹配优先的量词是“匹配优先”的，
但还不完整。要想彻底弄清楚这一点，我们需要了解回溯时使用的是哪个（或者是哪些个）
之前保存的分支，答案是：
距离当前最近储存的选项就是当本地失败强制回溯时返回的。使用的原则是LIFO（last
infirstout，后进先出）。
用面包屑比喻就很好理解一一如果前面是死路，你只需要沿原路返回，直到找到一堆面包
屑为止。你会遇到的第一堆面包屑就是最近洒下的。传统的LIFO比喻也是这样：就像堆叠
盘子一样，最后叠上去的盘子肯定是最先拿下来的。