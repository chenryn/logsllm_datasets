翻译链接：[heap-tricks-never-get-old-insomnihack-teaser](https://www.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
文章分类：二进制漏洞分析
# 常见好用的堆栈技巧——比赛专用
>
> Synacktiv红队在上周末的Insomni'hack比赛，以280名队伍第九名完结。其中有一个挑战非常有趣，并且教会了我一些技巧和方法，所以我决定写一篇详细的博客。在这篇文章中，我会努力充分的解释解决这个问题的思考过程，绝不仅仅是一般的方法。希望你能享受这个阅读，最后的exp.py放在文末附录。
二进制文件和libc文件都是沿用pwn的方法进行使用。
## 1.初始化安装步骤
从保护方法来看，`ontestament.bin`文件有很好的保护措施，包括`RELPO保护，NX位保护，PIE保护`。
    $ checksec ontestament.bin
    [*] '/home/bak/onetestament/ontestament.bin'
        Arch:     amd64-64-little
        RELRO:    Full RELRO
        Stack:    No canary found
        NX:       NX enabled
        PIE:      PIE enabled
提供的libc文件是与源文件剥离的，可以方便的使用debug符号重新得到等效项。辛运的是，[pwninit](https://github.com/io12/pwninit/)工具就是这么做得，修补二进制文件，使用其提供的libc链接，而不是使用系统链接。
libc链接可以使用`ldd`工具来验证：
    $ ldd ontestament.bin_patched
        linux-vdso.so.1 (0x00007ffc057eb000)
        libc.so.6 => ./libc.so.6 (0x00007f84a2ec8000)
        ./ld-2.23.so => /lib64/ld-linux-x86-64.so.2 (0x00007f84a3499000)
同时，libc的版本号是多少呢？
    $ ./libc6.so | head -n 1
    GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.3) stable release version 2.23, by Roland McGrath et al.
如果你对常见heap堆技巧非常熟悉，那么你会知道知道libc的版本非常重要。
事实上，heap的内存管理随着时间的已经发展了很长一段时间了。保护措施的出现，内存结构的改变，他们的工作方式也在改变。这也是为什么基于堆的攻击常常影响的是libc的特定的版本。如果你想看更多这方面的资料，可以看看[A
repository for learning various heap exploitation
techniques.](https://github.com/shellphish/how2heap)。
在我的印象中，Glibc
2.23开始于2016年2月份，他已经是非常老的了。在开始挖漏洞之前，有一件非常有趣的事情需要做，那就是看看下一个版本新版本的libc中有什么安全修复措施和相关安全保护措施。
## 2.逆向工程程序漏洞
### 程序特征识别
这个程序的运行结果是非常的直接。列出所有的堆技术，你可以创建对象，编辑对象，查看对象，删除对象。至少这也是我所想的，当我第一次看到这个程序运行的时候。
    $ ./ontestament.bin
    ==========================
         ✝ OneTestament ✝      
    ==========================
    1. My new testament
    2. Show my testament
    3. Edit my testament
    4. Delete my testament
    5. Bye!
    Please enter your choice:
在程序运行之前，一个`alarm(20)`的调用产生了。这会在20秒之后触发SIGALRM信号，停止程序。为了避免这个令人烦恼的行为，可以修补二进制文件（nop对alarm的调用）或者简单的在gdb输入以下命令：
    pwndbg> handle SIGALRM ignore
    Signal        Stop      Print   Pass to program Description
    SIGALRM       No        Yes     No              Alarm clock
让我们迅速开始查看所有的重要函数。
### 创建程序
函数的伪代码如下：
首先，我发现了程序只允许10次分配，全局变量（此处变量名是`nb_testaments`）在每次新分配后都会递增。
可用的大小包含： **0x18** , **0x30** , **0x60** and **0x7c**
字节，这样可以方便我在快速bins和未排序bins中释放数据块chunks。提醒一下，每个大于0x58字节的数据块在释放后都会放入未排序的容器中。
数据块chunks由calloc()函数负责分配，关于`calloc()`函数与`malloc()`函数的主要区别是后者对分配的内存区域执行`memset(mem,0sz)`。
之后，testament将用户指定的数据填入。与一般所想不同的是，`fill_testament()`函数是安全的，这里不再详细给出缘由。
另一个有趣的地方是，testament指针和大小都存储在全局变量中，即.bss段。
细心地读者发现了我调过了`read_input()`函数，他的伪代码如下：
    __int64 read_input()
    {
      int v2; // [rsp+Ch] [rbp-4h]
      read(0, nptr, 5uLL);
      v2 = atoi(nptr);
      if ( v2  9 )
        abort("Oops! not a valid index");
      testament_addr = (char *)testaments[input];
      if ( !testament_addr )
        abort("Impossible! No testaments");
      size_testament = size_testaments[input];
      if ( nb_times_edited[input] > 2 )
        abort("Are you serious?");
      printf("Please enter your testament content: ");
      offset = read_input();
      if ( offset > size_testament )
        abort("Nope, impossible!");
      ++testament_addr[offset];
      ++nb_times_edited[input];
    }
这个函数在创建前验证选择了`testament`。然而，它并没有检查是否已经释放，这也叫做UAF（使用后免费）。
除此之外，我们可以看到遗嘱`testament`是通过全局变量`testaments`和`size_testaments`判断的，非常有意思。
更重要的是，存在一个验证，确保我只能编辑遗嘱2次。
实际上，这个函数不允许用户编辑遗嘱的全部内容，但是，如果我们设法更改变量`size_testaments`，那么可以增加1个字节，最多增加两次，可能会溢出边界，我需要牢记这一点。
### 逆向工程：删除
现在，有趣的地方来，查看删除函数的伪代码：
    void delete_testament()
    {
      unsigned int input; // [rsp+4h] [rbp-Ch]
      void *ptr; // [rsp+8h] [rbp-8h]
      printf("Please enter your testament index: ");
      input = read_input();
      if ( input > 9 )
        abort("Oops! not a valid index");
      ptr = (void *)testaments[input];
      if ( !ptr )
        abort("Impossible! No testaments");
      switch ( input )
      {
        case 0u:
          if ( !dword_5555556030C8 )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030C8 = 0;
          break;
        case 1u:
          if ( !dword_5555556030C4 )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030C4 = 0;
          break;
        case 2u:
          if ( !dword_5555556030C0 )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030C0 = 0;
          break;
        case 3u:
          if ( !dword_5555556030BC )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030BC = 0;
          break;
        case 4u:
          if ( !dword_5555556030B8 )                // remember this guy
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030B8 = 0;
          break;
        case 5u:
          if ( !dword_5555556030B0 )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030B0 = 0;
          break;
        case 6u:
          if ( !dword_5555556030AC )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030AC = 0;
          break;
        case 7u:
          if ( !dword_5555556030A8 )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030A8 = 0;
          break;
        case 8u:
          if ( !dword_5555556030A4 )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030A4 = 0;
          break;
        case 9u:
          if ( !dword_5555556030A0 )
            abort("Impossible to delete again this testament");
          free(ptr);
          dword_5555556030A0 = 0;
          break;
        default:
          return;
      }
    }
每当调用这个函数的时候，`testament`的指针都会被释放。
乍一看，一个指针释放两次似乎是似乎是不可能的。事实上，一个全局变量指明了每一个testament是否已经被`free()`。
还记得在`read_input()`函数的溢出的1个字节吗？猜一下紧挨着变量`nptr`的是什么？
溢出影响的`dword_5555556030B8`双字用来指明第五个tstaments是否已经被释放。
按照下面的方法，我们可以触发双重`free`：
  * 分配至少5个`testament`
  * 释放第五个`testament`
  * 触发溢出漏洞，以便将`dword_5555556030B8`设置为0以外的任意值。
  * 再次释放第五个testament。
## 3.泄漏-逆向工程