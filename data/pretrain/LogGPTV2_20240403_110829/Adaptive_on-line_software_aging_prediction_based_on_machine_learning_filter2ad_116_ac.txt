X_h  X 
(3)d 
SWA variation 
X-
X 
SWA variation 
ITH (2)e 
X-X  X 
ITH (2,/ 
SWA variation 
X_h  X 
l/SWA (3)d 
X-X  X 
l/SWA (3,/ 
X-X  X 
Young/Old 
X_h  X 
X 
Resource 
X 
X 
X-
(l/SWA variation)ITH 
X-X  X 
(l/SWA variation)ITH 
X 
X 
X-
(RiSWA variation)ITH 
X-X  X 
(RiSWA variation)ITH 
X 
X-X  X 
SWA Resource 
X 
X-X  X 
Time to Failure 
a Exp. 4.3 Complete-Expo 
b (X) number of variables 
C Sliding 
d For Num. Threads, 
e For Tomcat Memory Used and System Memory Used 
f For Young Zone Used and Old Zone Used 
8 For Response 
Time, Throughput, 
Tomcat Memory Used 
h Removed only Tomcat Memory Used and System Memory Used 
variables 
Tomcat Mem. Used and System Mem. Used 
(2)' 
(2,/ 
(2), 
(2,/ 
System Memory Used and 
Window Average (SWA) 
Used(R)/SWA 
(3)d 
Selection 
Used/SWA (2) 
related 
Used (4)8 
X 
X 
X 
of machine characteristics 
are 
In our experiments 
we have played with 
To simulate 
the aging-related 
errors consuming 
re­
we have modified the TPC­
until their exhaustion, 
sources 
W implementation. 
two different 
resources: 
or merged. To simulate 
Threads and Memory, individually 
a random memory consumption 
TPC-W clients, 
called Emulated 
Browsers 
(EBs), access 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
511 
DSN 2010: Alonso et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 13:59:15 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP 
International 
Conference 
on Dependable 
Systems & Networks 
(DSN) 
(TPCW -.SearchJequesLservlet) 
using two new experiments 
with different 
four experiments 
workload 
(75EBs and 150EBs). 
a random number between 0 and N. This 
use the servlet 
how many requests 
be­
is injected. 
Therefore, 
depends of the num­
of servlet 
Accord­
this frequency depends on 
visits. 
chosen. This makes that with high workload 
memory leaks, 
however with low 
is lower too. But, again, the 
rate would depend on the average 
of 
with fluctuations 
that become less rel­
over time. Therefore, 
we could thus 
N, and we have decided to 
N. On the other hand, 
quickly 
of memory consumption 
and the frequency 
injects 
the consumption 
we have modified a servlet 
which computes 
number determines 
fore the next memory consumption 
the variation 
ber of clients 
ing to the TPC-W specification, 
the workload 
our servlet 
workload, 
average 
consumption 
this random variable, 
evant when averaged 
simulate 
stick to only one relevant 
to simulate 
parameters: 
jects a random number of threads 
determines 
a random number (in seconds) 
injection 
is independent 
occurs independently 
memory injection 
when a certain 
application 
two errors help us to validate 
scenarios. 
Shopping 
all of our experiments 
this effect by varying 
using shopping 
is workload 
component 
parameter, 
4. Prediction 
Experiment Results 
a thread consumption 
in the servlet 
T and M. At every injection, 
we use two 
the system in­
between 0 and M, and 
how much time occurs until the next injection, 
between 0 and T. Thread 
of the workload 
(since injection 
of the running applications), 
dependent 
(because 
while 
it occurs 
is executed). 
These 
our hypothesis 
TPC-W has three types of workload 
and Ordering). 
In our case, we have conducted 
under different 
(Browsing, 
distribution. 
Table 2 presents 
the variables 
used to build every model 
conducted. 
In every experiment, 
the size (number of nodes and leafs) of the 
used in every experiment 
we indicate 
model and the number of instances 
Moreover, 
[21] links to the training 
our experiments. 
used to train the model. 
and test datasets 
used in 
4.1 Deterministic Software Aging 
Our first approach 
was to evaluate 
M5P to predict 
the 
software 
aging. We 
due to deterministic 
a 1MB of memory leak with N =  30 (see 
our model, generated 
with 25 EBs, 50EBs, 
4 executions 
We trained 
us­
The M5P 
2776 instances. 
was composed by a tree with 33 Leafs and 
setup). 
to inject 
time until failure 
decided 
experimental 
ing M5P, with previous 
100EBs and 200EBs, becoming 
model generated 
30 inner nodes, using 10 instances 
experiment, 
training 
cat, to let  the M5P 
a deterministic 
racy of the model, we evaluated 
experiments 
were executed 
software 
to build every leaf. In this 
we did not add the heap information. 
The four 
to learn the behavior 
aging. Finally, 
of the system under 
to evaluate 
the accu­
the model built with these 
until the crash of Tom­
Table 3. MAEs obtained in Exp. 4.1 
Lin. Reg  M5P 
75EBsMAE 
75EBs S-MAE 
150EBsMAE 
150EBs S-MAE 
75EBs PRE-MAE 
75EBs POST-MAE 
150EBs PRE-MAE 
150EBs POST-MAE 
19 min 35 sees 15 min 14 sees 
14 min 17 sees 9 min 34 sees 
20 min 24 sec 5 min 46 sees 
17 min 24 sees 2 min 52 sees 
21 min 13 sees 16 min 22 sees 
5 min 11 sees 2 min 20 sees 
19 min 40 sees 6 min 18 sees 
24 min 14 sees 2 min 57 sees 
In Table 3 we present 
the results 
results 
serve how M5P obtains 
gression 
better 
to the Heap Memory Management 
do not add the specific 
Section 
due because 
it handles 
better 
3. 
obtained. 
than simple linear 
the trend changes due 
We can ob­
re­
information, 
as in the examples 
actions, 
even when we 
in 
4.2 Dynamic and Variable Software Aging 
Our next experiment 
was to evaluate 
our model to pre­
see the experimen­
but dynamic software aging under constant 
time until 
injection. 
to determinate 
Using these only 4 executions 
We trained 
one hour execution 
we trained 
the 
was composed by 36 leafs and 
to build every leaf. The 
as an infinite 
the model with 4 executions 
(1710 
where we did not inject 
any 
where we injected 
1MB 
ratio (N =  15,N =  30 and 
execution, 
dict progressive 
workload. 
instances): 
memory leak and three executions 
memory leak with constant 
N =  75 in every respective 
tal setup). 
model. The model generated 
35 inner nodes, using 10 instances 
model was trained 
crash as 3 hours (10800 secs) using the training 
without 
ment where we changed the ratio every 20 minutes. 
the first 20 minutes we did not inject 
any memory leak. Af­
ter that, during the next 20 minutes we injected 
leak following 
the injection 
reduced the software 
left constant 
MAE and S-MAE, we fix the current 
the system until a crash occurs. 
simulate 
evaluate 
the capability 
aging trend changes and react before it, so if the consump­
tion speed goes down, the time until exhaustion 
and vice versa. 
this ratio until crash. In order to compute the 
rate and then 
This model was tested over an experi­
During 
20 minutes later, 
we 
a N =  75 and we 
to N =  15 and finally, 
of the model to overcome 
aging following 
So, we wanted to 
injection 
a memory 
data set 
software 
a ratio of N =  30. After that, we increase 
Figure 3 presents 
the predicted 
time (dark line) vs. Tom­
increases 
we have trained 
cat memory evolution 
First, 
til crash is 3 hours (standing 
when there is no aging; indeed, 
(grey line) during the execution. 
our model to declare 
that the time un­
for "very long" or "infinite") 
during the first 20 minutes 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
512 
DSN 2010: Alonso et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 13:59:15 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFlP 
International 
Conference 
on Dependable 
Systems & Networks 
(DSN) 
'".""." ! Injection 
:-------------
N = 75 
14000 ,------
v;-12000 
'C o o 10000 
:;  0000 
'j! , 
E4000 
;:: 
No injection Injection 
N = 30 
--r 90,ro 
BO,oo  
70,00 § 
60,00  
50,00  
E  3 hours to crash) to 
based on aging trend. After another 
window intro­
that (in this case, 12 marks, 
of the third 
by the Heap 
fact happens in the beginning 
A flat zone provoked 
rate increases. 
phase provokes 
as discussed 
The sliding 
before. 
20 min­
But a 
 - "'100  ;;; ;; 10000 § . E 5000 ;:: 
Because of this, the model starts 
to predict 
more time 
However, 
detecting 
Tomcat memory plot), 
rate, which translates 
it, and it keeps the prediction 
to the new circumstances, 
the model is seeing a lower-than­
after the start of the experiment). 
the 
in this region is not quite accu­
rate is so slow, the model has 
almost con­
a second resizing 
that the real time, because 
real consumption 
when the flat region ends (as visible 
prediction. 
the model reacts quickly 
in the  the 
to adapt the time until crash close to the real value (around 
2850 seconds 
In the fourth 
phase, we reduce the rate and the model quickly adapts 
the time predicted 
increasing 
time until crash. Prediction 
rate, though: as the injection 
trouble 
we can observe 
stant. 
4850 seconds to 5900 seconds). 
the model is not accurate 
cat memory usage), 
the flat zone, again the model reacts reducing 
til crash. This behavior 
of M5P. The MAE and S-MAE obtained 
scenario 
tively, 
the other hand, Linear Regression 
MAE. On the other hand the PRE-MAE and POST-MAE 
were, respectively, 
by M5P in this 
was 16 min. 26 secs. and 13 min. 3 secs. respec­
accuracy; 
unacceptable 
(from 
During this phase, again 
17 min. 15 secs. and 8 min. 14 secs. 
shows the adaptability 
(as it does see a constant 
Tomcat memory is out  of 
is a quite reasonable 
Furthermore, 
which we believe 
but when  the 
has a really 
to changes 
the time un­
Tom­
on 
978-1-4244-7501-8/10/$26,00 
©2010 IEEE 
513 
DSN 2010: Alonso et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 13:59:15 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFIP 
International 
Conference 
on Dependable 
Systems & Networks 
(DSN) 
12000 
Vi  10000 
"0 " 8 ! 8000 
'" .2 6000 
:! 
'i! 4000 
" 
'" E i= 2000 
No injection phase 
: N=30o-M=30-and-1'=90; 
:in-ection lase  I 
:N=15. M=15 and T=120 
i:.iniection phase  L: .--::::..----
1800 
1200  
::  
---i 10CX)   
800 ::  
600   
o  E 
400 a:; 
-'" 
200 5 
:z 
-Time until failure 
predcted 
-Threads consumed by Tomcat 
-Memor y used by Tomcat 
Execution 
Time (seconds) 
Figure 5. Time predicted and resource evolution during the two-resource 
experiment 
Table 4. MAEs obtained in Exp 4.3 
MAE 
S·MAE 
PRE-MAE 
POST-MAE 
Lin Reg 
15 min 57 sees 
4 min 53 sees 
16 min 10 sees 
8 min 14 sees 
M5P 
3 min 34 sees 
21 sees 
3 min 31 sees 
5 min 29 sees 
as follows: 
the memory rate injection 
and 
were Memory and Threads, 
was 
The experiment 
we have a first phase with no injec­
after that we start to inject both re­
volved in the experiment 
every phase was around 30 minutes. 
conducted 
tion (both resources), 
sources: 
thread rate injection 
to N =  15 and the 
we increased 
was reduced to M =  15 and T =  120. 
thread rate injection 
After that, in the last phase, we change again both rates, 
re­
ducing the memory rate (N =  75) and increasing 
rate injection 
was M =  30 and T =  90. After that, 
was N =  30, while the 
(M =  45 and T =  60). 
the memory rate injection 
the thread 
One important 
point in this experiment 
is that when a 
a system thread is assigned 
to the Java thread 
point is that every Java Thread 
Java Thread, 
until it dies. Other important 
has an impact over the Tomcat Memory, because the Java 
So, although 
thread consumes 
the 
two causes of aging are unrelated 
they are 
related 
and that it may easily go unnoticed 
Java memory by itself. 
after all; we believe 
even to expert eyes. 
on the surface, 
this may be a common situation, 
and 
We 
The 
In Figure 5 we can observe 
the thread consumption 
I3min. 
evolution 
18min. 16secs. 
clearly the 
and 2min. 5 secs. respectively: 
was: 16min. 52secs., 
during the experiment. 
four phases of the experiment. 
memory consumption 
can observe 
MAE and S-MAE, PRE-MEA and POST-MAE obtained 
by M5P in this experiment 
22secs, 
this 
is about 10% error (MAE and S-MAE), given that the exper­
iment took 1 hour and 55 minutes until crash. We can ob­