l e n g t h h i s t o [ code
len = code
len ;
len ;
len ] + + ;
}
(∗ symbol ) ++;
Listing 7: A false positive in Brotli detected by SpecTaint.
False positives in detection. In this section, we discuss the
cases where detected gadgets are not exploitable. First, when
the triggering instruction can be resolved shortly, e.g., loops
and constant comparison, the following gadgets cannot be
executed before the speculation is resolved. However, in this
case, SpecTaint would simulate speculative execution with the
default SEW and detect the following gadgets that satisfy the
pre-deﬁned pattern.
Second, when the triggering instruction opens a large SEW
(e.g., due to a cache miss), SpecTaint may produce false posi-
tives in some cases. For instance, SpecTaint detects a Spectre
gadget in Brotli shown in Listing 7. In this example, the
code len is tainted, which is propagated from user inputs.
If the branch at line 4 was mispredicted and the CPU specula-
tively executes the function ProcessSingleCodeLength,
it would pass an out-of-bounds code len to function
12
line 17,
ProcessSingleCodeLength. At
the out-of-
bounds code len is used as an index to access the array
next symbol; the loaded value is further used as an index
to access another array symbol list. Thus,
the attack
can retrieve the out-of-bound value by monitoring the cache
state. In practice, this gadget is hard to exploit to launch a
Spectre V1 attack because the out-of-bound access at line
17 uses code len as an index. By the time code len
is available, the conditional branch at line 5 has already been
resolved, which means the speculative execution is terminated.
According to our pattern checking policy, SpecTaint still treats
it as a Spectre gadget.
To guarantee a low false negative rate, we conservatively
assume the maximum values for CPU optimization parameters
such as ROB limit. This means our detected gadgets may not
be exploitable in some processor models.
Incomplete path coverage. Like other dynamic analysis tools,
our approach is also bounded by the quality of test cases.
In other words, our approach would fail to detect gadgets in
uncovered paths. We can leverage state-of-the-art fuzzers [2],
[8] to increase path coverage. Moreover, SpecTaint can be
combined with other static Spectre gadget detection tools [5],
[43] and test the uncovered paths to improve coverage. To
ensure security, all
the uncovered paths can be hardened
conservatively for security-sensitive projects.
Control dependent attacks. Our Spectre gadget detection
depends on dynamic taint analysis that keeps track of direct
data ﬂows. It will not detect Spectre gadgets that are control
dependent on user inputs. Compared with the gadgets that
are controlled via direct data-ﬂoe dependency, the control-
dependent gadgets often are of limited attack capabilities and
are currently beyond the scope of this work. We leave the
investigation of this kind of gadgets as future work.
VIII. RELATED WORK
We have discussed related works closely throughout the
paper. In this section, we brieﬂy survey additional related
works. We focus on gadget detection techniques. Many other
approaches aim at designing the hardware architecture to
defeat the transient execution vulnerabilities [36], [47], [49].
Since they are orthogonal to our approach, we will only brieﬂy
discuss these approaches in this section.
Transient Execution Attack Variants. Transient execution
attacks include Spectre-type attacks and Meltdown-type at-
tacks in general. Spectre-type attacks can be categorized into
Spectre-PHT [29], Spectre-BTB [29], [31], Spectre-RSB [30],
[34] and Spectre-STL [17], [37]. They focus on exploiting
different hardware caches. For example, Spectre-PHT attacks
poison the Pattern History Table (PHT) to trigger speculative
execution. Spectre-BTB exploits the Branch Target Buffer
(BTB). Meltdown-type attacks usually exploit fault-handling
exceptions such as virtual memory exception [16], [32], [45],
or an exception reading a disabled or privileged register [26],
[42]. Aligned with other tools [23], [39], we only focus on
detecting gadgets in victim programs that can be exploited by
Spectre V1 attacks and leak sensitive data through cache side
channels.
Spectre Gadget Detection. Spectre gadget detection can be
categorized as static and dynamic detection techniques. One
direction of the static analysis technique is to model the Spectre
gadget by using its syntax pattern, such as Spectre 1 Scanner
from RedHat [5] and MSCV Spectre 1 pass [41], and conduct
the pattern search on binaries for potential candidates. These
tools produce a large number of false positives. Furthermore,
their approaches are not generic and only designed for gad-
gets with special patterns. Another direction is to explore a
more precise modeling by using symbolic execution or static
taint analysis to detect Spectre gadgets. These approaches
are more reliable and generic [23], [43], but they are still
bounded by limitations of the static analysis. For example,
oo7 utilizes a static tainting analysis to capture the data-
dependency of Spectre gadget for detection. However, it inher-
its the limitation of static taint analysis, such as over-tainting
and under-tainting issues. SPECTECTOR [23] proposes to
use symbolic execution to automatically prove speculative
non-interference, or to detect violations. However, it inherits
the limitations of symbolic execution and has to sacriﬁce
soundness and completeness of analysis when analyzing large
programs. SpecFuzz [39] extends the fuzzing technique and
detect memory errors during simulated speculative execution.
However, to ensure high fuzzing throughput, the simulation
logic is over-simpliﬁed, resulting in poor precision and recall.
Compared with these approaches, SpecTaint is designed to
provide a more precise detection approach that is also scalable
for detecting Spectre gadgets from real-world programs.
Mitigation and Defense. Intel proposed hardware ﬁxes [44]
including improved process and privilege-level separation,
but they are only designed for Spectre 2.0. ConTExT [36]
provides a new architecture design using a temporary buffer
to mitigate information leakage during speculative execution.
It relies on users to identify the conﬁdential information and
perform dynamic taint analysis on hardware to keep track
of the conﬁdential information. Other approaches [28], [46]
either proposed to isolate the cache side channel or provide
a speculative buffer as a temporary buffer to mitigate the
cache leakage, but they are still at the design stage. At the
system level, the kernel page-table isolation is proposed to
mitigate Meltdown attack [22]. Many approaches [4], [18]
start to add mitigation instructions (serializing instructions or
mitigation instructions) at the compiler time to mitigate Spectre
attacks. Since SpecTaint can effectively provide more precise
Spectre gadget candidates, it can greatly reduce the number
of instructions for mitigation insertion. Therefore, SpecTaint
can improve the runtime performance after patching, which
has been substantiated in Section 3.
Dynamic Analysis. PIN [33], DynamoRIO [15], and Val-
grind [38] are powerful dynamic instrumentation tools. In fact,
our approach can also be implemented on these platforms.
Xforce [40] is the ﬁrst tool to propose the idea of force execu-
tion, but Xforce is used for code coverage based exploration,
and it is not designed for the speculative execution simulation.
Our approach is inspired by their approach and builds the
unique features for the speculative execution simulation that
enables dynamic taint analysis on speculative paths.
IX. CONCLUSION
In this paper, we enable dynamic taint analysis for Spectre
V1 gadget detection. To this end, we present a system-level
approach to simulate and explore the speculative execution
and provide ﬁne-grained gadget patterns for precise gadget
detection. We have implemented a prototype SpecTaint to
demonstrate the efﬁcacy of our proposed approach. We eval-
uated the effectiveness of SpecTaint on our Spectre Samples
Dataset and real-world programs. Our experimental results
demonstrate that SpecTaint outperforms the existing meth-
ods with reasonable runtime efﬁciency, and it discloses new
Spectre V1 gadgets from real-world applications.
AVAILABILITY
The source code of SpecTaint and the dataset used in the
evaluation can be found via https://github.com/bitsecurerlab/
SpecTaint.git.
ACKNOWLEDGEMENT
We would like to thank the anonymous reviewers for
their valuable suggestions and comments. This work was
supported by the Ofﬁce of Naval Research under Award No.
N00014-17-1-2893. Any opinions, ﬁndings, and conclusions
or recommendations expressed in this paper are those of the
authors and do not necessarily reﬂect the views of the funding
agencies.
REFERENCES
[1] Caffe. https://caffe.berkeleyvision.org/.
[2] American Fuzzy Lop (2.52b). http://lcamtuf.coredump.cx/aﬂ/, 2011.
[3] Spectre Mitigations in Microsoft’s C/C++ Compiler.
https://www.
paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html, 2018.
[4] Spectre mitigations in MSVC.
https://blogs.msdn.microsoft.com/
vcblog/2018/01/15/spectre-mitigations-in-msvc/, 2018.
[5] SPECTRE Variant 1 scanning tool.
766093/posts/3510331, 2018.
https://access.redhat.com/blogs/
[6] LibYAML. https://pyyaml.org/wiki/LibYAML, 2019.
[7] Brotli. https://brotli.org, Accessed: June 2020.
[8] Honggfuzz. http://honggfuzz.com/, Accessed: June 2020.
[9] HTTP. https://github.com/nodejs/http-parser, Accessed: June 2020.
[10]
[11] LibHTP. https://github.com/OISF/libhtp, Accessed: June 2020.
[12] OpenSSL. https://www.openssl.org/, Accessed: June 2020.
[13]
JSMN. https://github.com/zserge/jsmn, Accessed: June 2020.
Intel.
intel-x86-and-64-manual-vol3/o fe12b1e2a880e0ce-273.html,
by 2019.
https://xem.github.io/minix86/manual/
cited
[14] Fabrice Bellard. Qemu, a fast and portable dynamic translator. In In
Proceedings of the USENIX Annual Technical Conference (ATC ’05),
ATC, 2005.
[15] Derek Bruening, Timothy Garnett, and Saman Amarasinghe. An
In Proceedings of
infrastructure for adaptive dynamic optimization.
the International Symposium on Code Generation and Optimization:
Feedback-directed and Runtime Optimization, CGO ’03, 2003.
Jo Van Bulck, Marina Minkin, Oﬁr Weisse, Daniel Genkin, Baris
Kasikci, Frank Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval
Yarom, and Raoul Strackx. Foreshadow: Extracting the keys to the intel
SGX kingdom with transient out-of-order execution. In 27th USENIX
Security Symposium (USENIX Security 18), 2018.
[16]
[17] Claudio Canella, Jo Van Bulck, Michael Schwarz, Moritz Lipp, Ben-
jamin von Berg, Philipp Ortner, Frank Piessens, Dmitry Evtyushkin, and
Daniel Gruss. A systematic evaluation of transient execution attacks and
defenses. In 28th USENIX Security Symposium (USENIX Security 19),
2019.
13
Michael Schwarz, Moritz Lipp. Context: A generic approach for
mitigating spectre. Proceedings of the Annual Network and Distributed
System Security Symposium (NDSS’20), 2020.
[37] Marina Minkin, Daniel Moghimi, Moritz Lipp, Michael Schwarz,
Jo Van Bulck, Daniel Genkin, Daniel Gruss, Frank Piessens, Berk Sunar,
and Yuval Yarom. Fallout: Reading kernel writes from user space.
CoRR, 2019.
[38] Nicholas Nethercote and Julian Seward. Valgrind: A framework for
In Proceedings of the
heavyweight dynamic binary instrumentation.
28th ACM SIGPLAN Conference on Programming Language Design
and Implementation, PLDI ’07, 2007.
[39] Oleksii Oleksenko, Bohdan Trach, Mark Silberstein, and Christof
Fetzer. Specfuzz: Bringing spectre-type vulnerabilities to the surface.
CoRR, abs/1905.10311, 2019.
[40] Fei Peng, Zhui Deng, Xiangyu Zhang, Dongyan Xu, Zhiqiang Lin, and
Zhendong Su. X-force: Force-executing binary programs for security
applications. In 23rd USENIX Security Symposium (USENIX Security
14), 2014.
[41] Read Sprabery, Konstantin Evchenko, Abhilash Raj, Rakesh B. Bobba,
Sibin Mohan, and R H Campbell. Scheduling, isolation, and cache
allocation: A side-channel defense. 2018.
Julian Stecklina and Thomas Prescher. Lazyfp: Leaking FPU register
state using microarchitectural side-channels. CoRR, abs/1806.07480,
2018.
[42]
[43] Guanhua Wang, Sudipta Chattopadhyay, Ivan Gotovchits, Tulika Mitra,
and Abhik Roychoudhury. oo7: Low-overhead defense against spectre
attacks via binary analysis. CoRR, abs/1807.05843, 2018.
[44] T. Warren.
Intel processors are being redesigned to protect against
spectre. 2018.
[45] Oﬁr Weisse, Jo Van Bulck, Marina Minkin, Daniel Genkin, Baris
Kasikci, Frank Piessens, Mark Silberstein, Raoul Strackx, Thomas F
Wenisch, and Yuval Yarom.
Foreshadow-ng: Breaking the virtual
memory abstraction with transient out-of-order execution. Technical
report, 2018.
[46] Mengjia Yan, Jiho Choi, Dimitrios Skarlatos, Adam Morrison, Christo-
pher W. Fletcher, and Josep Torrellas. Invisispec: Making speculative
execution invisible in the cache hierarchy. 2018 51st Annual IEEE/ACM
International Symposium on Microarchitecture (MICRO), 2018.
[47] Mengjia Yan, Bhargava Gopireddy, Thomas Shull, and Josep Torrellas.
Secure hierarchy-aware cache replacement policy (sharp): Defending
In Proceedings of the 44th
against cache-based side channel atacks.
Annual International Symposium on Computer Architecture, ISCA ’17,
2017.
[48] Yuval Yarom and Katrina Falkner. Flush+reload: A high resolution,
In 23rd USENIX Security
low noise, l3 cache side-channel attack.
Symposium (USENIX Security 14), pages 719–732, San Diego, CA,
August 2014. USENIX Association.
[49] Si Yu, Xiaolin Gui, and Jiancai Lin. An approach with two-stage mode
to detect cache-based side channel attacks. In Proceedings of the 2013
International Conference on Information Networking (ICOIN), ICOIN
’13, 2013.
[18] C Carruth.
Speculative load hardening.
https://docs.google.com/
document/d/1wwcfv3UV9ZnZVcGiGuoITT61eKo3TmoCS3uXLcJR0/
edit#heading=h.phdehs44eom6., 2018.
[19] Ali Davanian, Zhenxiao Qi, Yu Qu, and Heng Yin. Decaf++: Elas-
In the 22nd International
tic whole-system dynamic taint analysis.
Symposium on Research in Attacks, Intrusions and Defenses (RAID),
September 2019., RAID, 2019.
[20] B. Dolan-Gavitt, P. Hulin, E. Kirda, T. Leek, A. Mambretti, W. Robert-
son, F. Ulrich, and R. Whelan. Lava: Large-scale automated vulnerabil-
ity addition. In 2016 IEEE Symposium on Security and Privacy (SP),
pages 110–121, 2016.
J. Fustos and H. Yun. Spectrerewind: A framework for leaking secrets
to past instructions. arXiv, 2003.12208.
[21]
[22] Daniel Gruss, Moritz Lipp, Michael Schwarz, Richard Fellner,
Cl´ementine Maurice, and Stefan Mangard. Kaslr is dead: Long live
In the 9th International Symposium on Engineering Secure
kaslr.
Software and Systems (ESSoS’17), 2017.
[23] Marco Guarnieri, Boris K¨opf, Jos´e F. Morales, Jan Reineke, and
Andr´es S´anchez. SPECTECTOR: principled detection of speculative
information ﬂows. CoRR, abs/1812.08639, 2018.
[24] A. Henderson, L. K. Yan, X. Hu, A. Prakash, H. Yin, and S. McCa-
mant. Decaf: A platform-neutral whole-system dynamic binary analysis
platform. IEEE Transactions on Software Engineering, 43(2):164–184,
2017.
[25] Andrew Henderson, Aravind Prakash, Lok Kwong Yan, Xunchao Hu,
Xujiewen Wang, Rundong Zhou, and Heng Yin. Make it work, make it
right, make it fast: Building a platform-neutral whole-system dynamic
In Proceedings of the 2014 International
binary analysis platform.
Symposium on Software Testing and Analysis, ISSTA, 2014.
Intel. Q2 2018 speculative execution side channel update. 2018.
[26]
[27] K. N. Khasawneh, E. M. Koruyeh, C. Song, D. Evtyushkin, D. Pono-
marev, and N. Abu-Ghazaleh. Safespec: Banishing the spectre of a
In 2019 56th ACM/IEEE
meltdown with leakage-free speculation.
Design Automation Conference (DAC), pages 1–6, 2019.
[28] V. Kiriansky, I. Lebedev, S. Amarasinghe, S. Devadas, and J. Emer.
Dawg: A defense against cache timing attacks in speculative execution
processors. 2018.
[29] Paul Kocher, Daniel Genkin, Daniel Gruss, Werner Haas, Mike
Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael
Schwarz, and Yuval Yarom. Spectre attacks: Exploiting speculative
execution. CoRR, abs/1801.01203, 2018.
[30] Esmaeil Mohammadian Koruyeh, Khaled N. Khasawneh, Chengyu
Song, and Nael Abu-Ghazaleh. Spectre returns! speculation attacks
In Proceedings of the 12th USENIX
using the return stack buffer.
Conference on Offensive Technologies, WOOT’18, 2018.
[31] Sangho Lee, Ming-Wei Shih, Prasun Gera, Taesoo Kim, Hyesoon Kim,
and Marcus Peinado.
Inferring ﬁne-grained control ﬂow inside SGX
enclaves with branch shadowing. In 26th USENIX Security Symposium
(USENIX Security 17), 2017.
[32] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner
Haas, Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel
Genkin, Yuval Yarom, and Mike Hamburg. Meltdown: Reading kernel
In 27th USENIX Security Symposium
memory from user space.
(USENIX Security 18), 2018.
[33] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser,
Geoff Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazel-
wood. Pin: Building customized program analysis tools with dynamic
instrumentation. In Proceedings of the 2005 ACM SIGPLAN Conference
on Programming Language Design and Implementation, PLDI ’05,
2005.
[34] Giorgi Maisuradze and Christian Rossow. Ret2spec: Speculative execu-
tion using return stack buffers. In Proceedings of the 2018 ACM SIGSAC
Conference on Computer and Communications Security(CCS’18), 2018.
[35] Andrea Mambretti, Matthias Neugschwandtner, Alessandro Sorniotti,
Engin Kirda, William Robertson, and Anil Kurmus. Speculator: A tool
to analyze speculative execution attacks and mitigations. In Proceedings
of the 35th Annual Computer Security Applications Conference, ACSAC
’19, page 747–761, New York, NY, USA, 2019. Association for
Computing Machinery.
[36] Claudio Canella Robert Schilling Florian Kargl Daniel Gruss
14