Controlled(r eд, −1,
,
, r eдI D, _, addr , ctx),
′u ′
′R ′
, _, addr , ctx),
, _, ctx).
This rule states that we run into IP control if we have an indirect
call, a memory load at that address, and the register operand used
at that address is controlled. Similarly, a write-where rule can be
expressed as follows:
ControlledStore(′stor e ′
Controlled(base , disp,
Memory(_,
′stor e ′
, base , disp, addr , ctx) : −
′D ′
, addr , ctx),
, _, _, disp, addr , ctx).
WrW(base , disp, bb, addr , ctx) : −
Register(id , base ,
Memory(′stor e ′
Controlled(base , −1,
′d ′
, _, addr , ctx),
, _, id , _, addr , ctx),
′R ′
, _, ctx).
Here, we define a rule for a controlled store, e.g., a memory cell
value at base +disp which we control. The WrW rule states that we
are interested in a register which is the base address of a memory
store. The last fact in the body says that the base of that store has
to be controlled.
For a WWW rule, we combine both, the WriteWhere rule and the
ControlledStore rule, since we are interested in a controlled value
305Towards Automated Generation of Exploitation Primitives for Web Browsers
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
new path string is encountered, we update the trie and send the
path to the symbolic execution engine.
Path Explosion. Since the number of paths can grow exponen-
tially, we vary the gap size until we reach a given coverage of sinks
or a specified number of generated paths. With gap size we refer
to the maximum number of basic blocks that are allowed to lie
between the nodes in the CPG. We encountered the best results in
terms of speed and reasonable quality with a gap size between 15
and 20. Each path is sorted by its length and priority. Paths where
we control the branch conditions have a higher priority and are
processed first. To further cope with the path explosion, we skip
calls to functions that do not touch any controlled data. We use
heuristic approaches to skip calls in order to keep the paths as
simple as possible and summarize them as follows:
trolled data flows into a desired sink.
• The callee does not lead us to a specific location where con-
• The call site is postdominated by the target location, in which
case we reach the target location anyway.
• The call does not touch any controlled data.
The former two rules enforce call skipping even if the callee touches
tainted data. In § 5.2 we discuss how this choice can lead to problems
and how we deal with them.
Memory Maps. Recall that we search for paths between the con-
trol point and an attacker sink. Attacker-controlled data by means of
objects placed at predictable locations have to be crafted carefully,
such that the program follows the path into the sinks to perform the
wanted primitive. These paths are computed to prefer basic blocks
which process controlled data. We symbolically execute paths be-
tween source and sinks and gather constraints that are dependent
on controlled data. Paths that run into unsatisfiable conditions are
discarded.
Based on the constraints, we build a memory map along with
possible minimum and maximum values to be stored into the cor-
responding memory cells and which preserve the satisfiability of
the path. We further incorporate metadata into each memory cell
to keep track of instructions which introduced the constraints.
This procedure is best explained by example and we refer to our
running example illustrated in Figure 2. Recall that the value in
ecx at 0x107a00d7 is the memory region that the attacker controls
through a JS object. At offset 0xac, a dereference occurs and its value
has to be equal to 1 to satisfy the jump condition to 0x107a00ed.
The memory map on the right side shows this coherence. The base
address of the map is set to 0xd0000f54 in our case, but can be set
to any value afterwards. The corresponding addresses in the cells
are rebased accordingly.
At 0x11521448, the value of ecx (offset 0 in the map) is derefer-
enced, loaded into ecx which flows into edi at 0x101c0c9a where
it serves as a base address for the next jump condition. Note that
this value is again a memory region controlled by the attacker. The
value at offset 0x10ac=0x1094+0x18, can be set to 0x5 or 0xff
as indicated in the map through the min and max values. These
min/max values usually describe a range from which we can pick
a value; however, in this case, the test instruction performs an
and operation which restricts the value to be chosen. To avoid
bad characters which can be induced by zeros, we usually choose
Figure 3: Control Propagation Graph (CPG) of our running
example: leaf nodes are attacker sinks.
which is stored in memory and, at the same time, the base operand
of that memory store is to be controlled.
3.4 Program Paths
Upon taint generation, we build a graph that represents how control
flows from one basic block to another until it reaches a sink. We
refer to this graph as Control Propagation Graph (CPG) which is
illustrated in Figure 3. Leaf nodes which are not sensitive are pruned
away. Note, how ecx_2 in 0x107a00d4 is passed through its non
subscripted counterpart ecx in 0x11521448. In between these basic
blocks are two calls. Nodes in the CPG are not necessarily connected
by an edge in the CFG leaving us with gaps between these nodes.
The CPG can basically be seen as a slice from the control point
to the aimed attacker sink. Our aim in this process is to generate
paths between each node in the CPG to close these gaps. However,
we might face hundreds of basic blocks that lie in between these
sliced nodes with conditions that contradict each other leading
to unsatisfiable paths. We start by generating paths ahead of time
before we check for their satisfiability. This is done in a breadth-first
search manner with respect to being realizable. A realizable path
accounts for the call stack, i.e., when a function returns it continues
on the right call site. We send these paths to the symbolic execution
engine.
Symbolic Execution. To lighten the burden on the symbolic
execution engine, we generate a trie datastructure for all the paths
that were sent. Paths can be represented as strings which allows
us to use string searching algorithms to process the trie [2]. In
each node of the trie, we additionally incorporate meta data that
gives us information about whether the node kills the taint or it is
satisfiable along with its state. We only save the states in the nodes
when they are satisfiable. The idea behind this is to prioritize paths
that reach the sink through basic blocks where controlled data is
processed. This gives an attacker a valuable overview on how much
she can influence along different paths to its corresponding sinks.
Whenever we generate a path ahead of time we process the trie and
see if it is satisfiable up to some prefix of the path. In this manner
we avoid recomputing paths that have an unsatisfiable prefix. If a
0x107a00d40x115214480x101c0d0e0x101c0c96ecx_2, ecxecx_0, ecxecx_0, ecx0x101c0d2becx, edi_00x107d4ac60x107d4ab50x101c0ca8edi_0, eax_1edi_0, eax_12edi_0, edx_2edi_0, esi_70x101c0cab0x101c0cb40x104c0c4fesi_7, esi_1esi_1, eax_8ecx_8, ecxesi_1, ecx_8306ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
B. Garmany et al.
the max value. For some memory cells, as for the one used in the
sink, the range between min and max is the maximum word size
(0xffffffff), depending on whether we are dealing with a 32 or
64bit process. Whenever we encounter such a range, we use it as
an indicator to place an address at that cell that points back into a
attacker controlled area. However, we also need to account for loop
conditions that we might control. Setting the value to high might
lead the execution to run forever. We use a weak topological sorting
algorithm that partitions each loop in the process of topological
sort [9]. This allows us to spot controlled data that is processed in
the head of a loop. If controlled data runs into a flag condition it
indicates that we control the loop condition. In this case we need
to find a suitable value.
Each memory map is transformed into a tree structure which
simplifies the process of following dereference chains. The base is
the root of the tree and each entry in the map is a node. Nodes are
connected with an edge if a dereference occurs on that cell that
points to another cell (see Figure 2).
Verify. Due to the lack of context (state) information, each sat-
isfiable path needs to undergo a verification process. In order to
verify the paths in a platform-agnostic manner, we use a dump
that is acquired at the time where we hit the control point. Usually
this is the moment where, for instance, the heap spray has already
occurred. We mimic the process of different heap spray routines by
setting the memory according to our memory maps. In an emula-
tion process we examine if our memory settings drive the execution
into the desired primitive. Paths that do not fulfill this property are
filtered out.
3.5 Triggering Input
To generate code that triggers a given exploitation primitive, an
attacker has to deliver a manually crafted template file. This tem-
plate file contains the VUT, and eventually, a routine to prepare
attacker memory which is usually achieved through heap spraying.
The following code snippet in Listing 1 shows an excerpt of an EPT
for our running example generated from a template file.
1 function prepare_memory () {...}
2 function VUT () {...}
3 function set ( offset , value ) {...}
4 base_addr = ...
5 /* automatically generated code */
6 function gen () {
7
8
9
10
11
12
13
14
set (0 x70 , base_addr +0 x110 );
set (0 xac , 0 x1 );
set (0 x0 , base_addr +0 x1094 );
set (0 x10ac , 0 xff ); // 0 x1094 + 0 x18 = 0 x10ac
set (0 x10a8 , base_addr +0 x20ac ); // 0 x1094 +0 x14 =0 x10a8
set (0 x20ac , base_addr +0 x2f74 ); // 0 x20ac +0 x0 =0 x20ac
set (0 x30ac , base_addr +0 x220 ); //
}
0 x2f74 +0 x138 =0 x30ac
Listing 1: JS EPT excerpt.
The VUT and the memory preparation stabilizes control over the
memory regions through JS objects. Our memory tree structures
from the previous step are used to generate a recipe on how the
objects need to be crafted to trigger the attacker’s sink. The gen
function is generated by PrimGen and delivers this recipe.
Again, recall the example illustrated in Figure 2: For offset 0xac,
PrimGen generates set(0xac, 0x1), which conforms to line 8 in
Listing 1. The set function invocations write the values to the corre-
sponding offsets in user controlled memory. When heap spraying
is involved, the gen procedure is embedded into the heap spraying
routine. Line 9 represents the connection from 0xd0000ff54 to the
node with offset 0x0 in our memory tree. The memory tree has
two outgoing edges to 0x10ac and 0x10a8 which conforms to lines
10 and 11, respectively. At offset 0x70 we have an unconstrained
value, in which case an unused address to user controlled memory
is chosen.
The number of lines generated depend on the complexity of
the path, i.e., the length, the number of constraints referring to
controlled data, interplay with heap and eventually user defined
buffers. A full presentation of the VUT, template and generated
EPT can be found in Appendix A.
4 IMPLEMENTATION DETAILS
The core of our system consists of 44,400 lines of Python code and
2,600 lines of Datalog code. We implemented the preprocessing
phase on top of Amoco [39] and IDA Pro. IDA Pro is used to retrieve
the CFG of each function in the binary. As shown by Andriesse et
al. [4], IDA Pro reconstructs the most accurate CFG with the lowest
false positive rate among its other contributors in this field. How-
ever, basically any control flow recovery tool can be applied and
interfaced with our framework. Our choice for Amoco is motivated
by its flexibility that we gain through its IL. Our demand for an
IL are features to enable eased lifting, expression and statement
manipulation, custom expression operators, as well as serialization
of specific parts of an expression, all of which we found fulfilled.
An important feature are Amoco’s maps. Each map can be seen
as an abstract environment for each instruction to be transformed
into its semantically equivalent IL. They provide us with an instru-
ment to deal with the IL and symbolically evaluate expressions in a
given context. We extended these maps to support SSA using the
algorithm proposed by Cytron et al [15]. We additionally imple-
mented the concept of collectors proposed in Van Emmeriks work
on decompilers [41], which allows us to collect useful data during
the process of the SSA algorithm. For instance, the SSA algorithm
builds a stack of live definitions for each variable. Whenever a node
is processed, we extract these stack information into Scope facts,
as defined in Table 1.
We refer to our maps as SSA-maps. Expressions derived by in-
structions that evaluate to a constant are transparently handled.
For instance, an instruction like xor eax, eax or sub eax, eax
is evaluated to an IL statement that assigns a zero-expression to
a register expression which represents eax. This is done within
the map. Whenever an IL instruction enters a map instance, it is
evaluated within the context represented by that map. An excerpt
of an SSA-map is presented in Appendix B.
We transform all SSA-maps among with properties of interest
into fact databases for Datalog. These facts build up the base for
our analysis in the postprocessing phase. Our Datalog engine of
choice is Soufflé, a Datalog variation which extends the language
with features that are similar to high-level languages [20].
307Towards Automated Generation of Exploitation Primitives for Web Browsers
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
xul.dll 46.0.1.5966 and xul.dll 44.0.2.5884 as shown in Table 2. How-
ever, PrimGen found 6 (4 + 2) alternative ways to expand control
into desired attacker sinks. As the numbers indicate there are more
ways to drive the execution into exploitable states other than those
used in the original PoC. This, in particular, is what we refer to as
an alternative way. Again recall, we only use these original PoCs to
verify if we can trigger the same sinks.
Figure 4 shows the satisfiable paths relative to the path length
(number of basic blocks). It indicates that paths reaching our sinks
are shallow. We argue that these are the more desirable options for
an attacker as it simplifies her efforts, but we also acknowledge the
fact that there is space for improvement. Note that these paths are
checked for their satisfiability which are further filtered through a
verification process.
5.2 Fine Tuning
There are cases where the address of the control point is not suffi-
cient. We encountered this issue for CVE-2016-1960. The following
assembly snippet shows the corresponding basic block in xul.dll
with the address of the control point at 0x1010760e:
0 x10107601 mov ecx ,
0 x10107604 mov eax ,
0 x10107607 lea edx ,
0 x1010760a mov [ esp +18h+ var_4 ] , edx
0 x1010760e mov edx ,
[ edi +38h ]
[ edi +30h ]
[ eax+ecx ∗ 4 ]
[ edx ]
; c o n t r o l l e d
In the code snippet above, the control point is reached through a
chain of dereferences. If we start the propagation at that location
we loose information due to aliasing issues. In fact, we did not find
any sinks starting at 0x1010760e. Our static taint analysis does
not have a memory state model as used in Mayhem [12, 30]. If a
memory cell is tainted in a dynamic approach, it is easier to track
the flow if that memory cell is dereferenced.
To overcome this problem, we backward slice the source register
until we reach a dereference. We then taint the base and start again.
In this case we taint edi in its SSA subscripted form. Obviously,
this overapproximates the flow of control. Following this approach
delivers 61 sinks, one of which is the sink used in the original
proof of concept. However, we encountered that only two scripts
generated by our engine worked which have the nature of a write-
what-where primitive. Considering the low effort and the outcome
of this process, we think that this is a valuable and lightweight
procedure to integrate in the system. If the number of sinks is too
high and the outcome not satisfying, we opt for a more precise
approach that involves a points-to analysis.
Since the problem arises through aliasing issues, we implemented
a field-, flow-, and context-sensitive points-to analysis that shares