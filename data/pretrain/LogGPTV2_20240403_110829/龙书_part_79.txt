通常的程序往往将大部分时间花费在执行程序中的最内层循环和最紧凑的递归环上。
然处理非法输人和异常情况的指令对于程序的正确性是至关重要的，但是它们在某次运
在程序的一次典型运行中，可能被调用的代码中只有一小部分会被实际执行。例如，虽
行中很少会被调用。
不再被使用的指令。
128KB--4MB
256MB~2GB
32个机器字
16 -- 64KB
> 2GB
典型的大小
图7-16典型的内存层次结构的配置
寄存器（处理器）
二级高速缓存
虚拟内存（磁盘）
--级高速缓存
物理内存
典型的访问时间
100 ~150 ns
5 ~10 ns
40 ~~ 60 ns
3~15 ms
1 1Is
293
能
司
---
## Page 310
得更好。这个概念可以递归地应用于物理内存、高速缓存以及寄存器中的数据的复用。
主存)，并且在这些数据驻留在较快层中时执行所有针对这些数据的运算，那么程序的性能就会变
会很好。我们可以每次将一部分数据从存储层次结构的较慢层次加载到较快层次（比如从磁盘移到
部性。例如，一些程序反复地访问大量数据，而每次访问只完成少量的计算，这样的程序的性能不
运行。
连续执行的多个基本块(即总是顺序执行的指令序列)连续存放，即放在同一个存储页面中，
种现象是空间局部性的一个例子。提高指令的空间局部性的一个有效技术是让编译器把很可能
预测将来的存储使用情况。当一条新的指令被执行时，其下一条指令也很有可能将被执行。这
的指令。
这些指令。因此，我们必须动态调整最快的存储中的内容，用它们来保存可能很快会被频繁使用
点则更加困难。即使我们知道哪些指令会被频繁执行，最快的高速缓存通常也不能够同时存储
的作用并不明显—循环遍历非常大的数组的程序就是这样的例子。
在
程序的平均存储访问时间。
令和数据放在快而小的存储中，而将其余部分放入慢面大的存储中，我们就可以显著地降低一个
线过于费时，因此在实践中常常会限制一条高速缓存线在高速缓存中的放置位置。这个约束
部性。然而，数据访问模式通常比指令访问模式表现出更大的多样性。将最近使用的数据放
用静态电路构造。
特。因此我们通常会看到动态 RAM 类型的大容量主存，而像高速缓存这样的较小存储则使
被改写为止。显然，一-个芯片使用动态 RAM 电路可以比使用静态 RAM 电路存储更多的比
个比特都需要一个更复杂的电路，结果是存储在其中的比特值可以保持任意长时间，直到它
要定期刷新，即读出然后重新写人它们的比特。另－-方面，在静态（stalic)RAM 的设计中，每
这些电路会在短时间内丢失电位(因此也就会“忘记”它们原本存储的比特值)。这些电路需
294
我们还可以改变数据布局或计算顺序，从而改进一个程序中的数据访问的时间局部性和空间局
仅仅通过查看代码，我们一般无法看出哪部分代码会被频繁地用到，针对特定输人指出这-
将最近使用过的指令放人高速缓存的策略通常很有效。换句话说，过去的情况能够很好地
利用存储层次结构的优化
人们已经发现，很多程序在对指令和数据的访问方式上既表现出时间局部性，又表现出空[
局部性使得我们可以充分利用如图7-16 所示的现代计算机的存储层次结构。将最常用的指
常见的存储层次结构的特性是在每次访问某层存储的时候会从该层存储中获取一个包含了多个机器字的块。
静态的和动态的RAM
高速缓存体系结构
第7章
可
起
一
---
## Page 311
chunk）。因为它的可扩展性，Lea 把这个块当作最大尺寸存储块的容器。
管理器可以向操作系统请求更多的页面来扩展这个块。这个块被称为“荒野块”（wilderness
的两倍)。在每一个容器中，存储块按照它们的大小排列。总是存在这样一个空闲空间块，存储
个容器。更大尺寸的容器按照对数值进行划分（即每个容器的最小尺寸是前一个容器的最小尺寸
于1
例
时花费的时间较少，但是人们发现它在总体性能上要比 best-fit 策略差。
略
ft算法趋向于将大的窗口保留下来满足后续的更大请求。另一种策略被称为 first-fit。在这个策
程
将来的请求，尽管总的空闲空间可能仍然充足。
碎片，即大量的细小且不连续的窗口。此时，就有可能找不到一个足够大的“窗口”来满足某
合(coalesce）成为更大的窗口，否则窗口只会越变越小。如果我们不小心，空闲存储最终会变成
切分某个窗口，结果创建出更小的窗口。
的存储块放入一个足够大的“窗口”中。除非找到-个大小恰好相等的“窗口”，否则我们必定会
储工作的进行，空间被分割成若干空闲存储块和已用存储块，而空闲块不--定位于堆区的某个连
7.4.4碎片整理
如，在 GNU 的C 编译器 gcc 中使用的存储管理器 Lea 将所有的存储块对齐到8字节的边界。对
呈序中碎片最少的一个良好策略是将请求的存储分配在满足请求的最小可用窗口中。这个best
续
器中。一个实际可行的想法是为较小的尺寸设置较多的容器，因为小对象的个数通常比较多
各中，对象被放置到第一个(即地址最低的)能够容纳请求对象的窗口中。这种策略在放置对象
对于每个回收请求，被释放的存储块被放回到空闲空间的缓冲池中。我们把连续的窗口接
区域中。我们将空闲存储块称为“窗口”（hole)。对于每个分配请求，存储管理器必须将请义
常情况下会将最近最少使用的缓存线清除出高速缓存。
条缓存线被调入高速缓存，并且所有可能存放这个高速缓存线的位置都已经被占用，那么通
个集合中的位置 n mod（s/k)上。大部分指令和数据高速缓存的相关性在1～8 之间。如果一
类似地，-个k路成组相关高速缓存被分为k个集合，而一个地址为n 的数据只能映射到各
存中,存储地址为 n 的数据只能够放在缓存地址 n mod s上，其中s 是这个高速缓存的大小。
路相关高速缓存，它也称为直接映射高速缓存（direct-mapped cache）。在--个直接映射高速缓
称为成组相关性（set associativity）。如果在--个高速缓存中，一条缓存线只能被放在k个位置
运行时刻环境
16 字节到512字节之间的、每个大小为8字节整数倍的存储块，这个存储管理器都设置了-
为了更有效地实现 best-fit 放置策略，我们可以根据空闲空间块的大小，将它们分在若干个
 我们通过控制存储管理器在堆区中放置新对象的方法来减少碎片。经验表明，使现实中的
·如果被请求的尺寸有一个专有容器，即该容器只包含该尺寸的存储块，我们可以从该容
容器机制使得寻找 best-fit 块变得容易。
best-fit 和 next-fit 对象放置
第一个足够大的存储块，也可以花更多的时间去寻找最小的满足需求的存储块。注意，
在这个容器中，我们可以使用 first-fit 或best-fit 策略。也就是说，我们既可以找到并选择
器中任意取出一个存储块。Lea 存储管理器在处理小尺寸请求时就是这样做的。
295
容
长
---
## Page 312
空闲的。于是我们可以将 A 和B接合成-一个 300 字节的存储块。
在 B 的左边的存储块的末端，在这个例子中就是 A。A 右端的 free/used 位当前为 O，因此 A 也是
100，它刚刚被回收并回到了空闲列表中。因为我们知道B的开始位置（左端），也就知道了紧靠
例7.10
数据结构可以用于支持相邻空闲块的接合：
理；或者我们想要接合相邻的块，并在必要的时候将合并得到的块移动到另一个容器中。有两种
取一个新的页，将其分割成适当大小的存储块，同时扩展用于存储管理的位向量。
相应比特为0的块，将这个位改为1，然后就可以使用该内存块了。如果没有空闲块，我们就获
当一个块被回收时，我们将它对应的1改为0。当我们需要分配一个存储块时，便找出任意一个
一个位映射，其中的每个比特对应于容器中的--个块。1代表该块已被占用，0表示它是空闲的。
样大小的块全部按照需要放在多个页中，而不必接合。那么，一个简单的分配/回收方案是维护
么我们可能倾向于不把相邻的该尺寸的块合并成为双倍大小的块。比较简单的做法是将所有
完成的工作，但是不能用很多个小存储块来保存一个大对象，而合并后的存储块就有可能做到。
块
再次分配。在某些情况下，还可以将这个块和堆中的相邻块合并(接合)起来，构成一个更大的
next-ft 策略还可以提高分配操作的速度。
刚分割过的存储块中还有足够的空间来容纳这个对象，我们就把这个对象放置在这个存储块中。
请求尺寸的存储块时，使用另一种对象放置方法。在这种情况下，我们使用 next-fit 策略，只要刚
们放置在--起可以改善程序的空间局部性。对 best-fit 算法的有用改进之一是在找不到恰巧等子
好的。程序在同一时间分配的块通常具有类似的访问模式，并具有类似的生命周期。因此将它
央。这样做是有好处的。因为我们总能够用－个大的存储块来完成总量相等的多个小存储块月
296
有可能出现这样的情况，即紧靠在B的右端的存储块C也是空闲的。在这种情况下，我们可
在有些情况下问题会变得比较复杂。比如，我们不使用容器而把堆区作为--个整体进行管
如果我们为所有具有固定尺寸的存储块保留--个容器，如Iea 中为小尺寸块所做的那样，那
边界标记。在每个（不管是空闲的还是已分配的）存储块的高低两端，我们都存放了重要
当一-个对象通过手工方式回收时，存储管理器必须将该存储块设置为空闲的，以便它可以被
管理和接合空闲空间
虽然 best-fit 放置策略可以提高空间利用率，但从空间局部性的角度考虑，它可能并不是最
·不过，这个目标容器可能为空，或者这个容器中的所有存储块都太小，不能满足空间请
大小排序，因此可以支持 best-it 放置策略。
记的位置上。因此，不需要额外的空间来存放这个空闲块列表，尽管它的存在为块的
链表进行链接。这个链表的指针就存放在这些块中，比如说存放在紧挨着某-一-端边界标
一个双重链接的、嵌入式的空闲列表。各个空闲块(而不是已分配的块)还使用一-个双重
空闲的（free）。在与每-一个 free/used 位相邻的位置上存放了该块中的字节总数。
的信息。在块的两端都设置了一个free/used 位，用来标识当前该块是已用的(used)还是
到需要的空间，但有可能需要请求操作系统为堆区增加更多的内存页。
我们要么找到可以使用的存储块，要么到达“荒野块”。从这个荒野块中我们一定可以得
求。在这种情况下，我们只需要使用对应于下一个较大尺寸的容器重新进行搜索。最后，
小尺寸的容器中。
图7-17给出堆区的-一个部分，其中包含三个相邻的存储块 A、B和C。B块的大小为
和
两个指针的空间。空闲列表中的存储块的顺序没有确定。例如，这个列表可以按块的
设置了一个下界。即使数据对象只有一个字节，存储块也必须提供存放两个边界标记
第 7章
大
同
1
---
## Page 313
的对象的引用，使得这些对象可以被自动回收。
已经知道该对象不会再被引用。在那种情况下，程序员可以主动地删除指向那些不会再被引用
程序可能仍然耗费了过多的内存。有时尽管在某处还存在着对某个对象的引用，但程序员可能
服务器代码这样不间断运行的程序，保证它们没有内存泄漏是非常关键的。
容忍内存泄漏，当泄漏比较缓慢时尤其如此。然而，对于长期运行的程序，特别是像操作系统
序运行的速度，但是只要机器没有用完全部存储，它们就不会影响程序的正确性。很多程序可，
有删
dereference）错误。
为内存泄漏（memory-leak）错误；引用已经被删除的数据，这称为悬空指针引用（dangling-pointer-
被引用的空间都不能删除。遗憾的是，这两个性质都很难保证。除了考虑人工回收的困难之及
安排数据的回收。在理想情况下，任何不会再被访问的存储都应该删除。反过来，任何可能还
7.4.5人工回收请习
除所有的碎片。在7.6.4节中将更详细地讨论垃圾回收机制和存储管理之间的相互影响。
中的指针并将 A 和 B 替换为-个接合后的存储块。
B在空闲列表中也相邻。知道了A和B在空闲列表中的前驱和后继的存储块，就可以操作列
结构使得我们可以找到 A 和B 中的前驱和后继结点。请注意，不应该假定在物理上相邻的 A 
C不可以被接合。
块的起始位置。在该点上，我们检查C的 free/used 位，发现其值为1，表明C 正在被使用，因此
道 B块的总字节数为100字节。根据这个信息，我们可以找到 B的右端和紧靠在B右边的存储
我们按照下面的步骤找到C 的开始位置。我们从已知的B的左端开始，在B 的左边界标记中知
有两个连续的空闲块。因此我们总是只需要查看与正被回收的块相邻的两个块。在当前例子中，
以把A、B和C全部合并起来。请注意，如果我们总是尽可能地把存储块接合起来，那么就不会
被-段额外空间包围;对未分配空间的访问,或对数据对象之间的间隙空间的访问都被标记
维护了一个存储的映像图，指明所有空闲的和已用的空间的分布。每个已分配空间的对象都
工具之一。Purify 对二进制代码进行插装，加人在程序运行时检查程序错误的附加指令。它
程序员不能保证---个程序是否永远不会在将来引用某块存储，因此第一个常见的错误是没
外，我们还将描述一些被程序员用于处理这些难点的技术。
我们在本节的最后讨论人工存储管理。此时，程序员必须像在C和C++语言中那样显式地
如果自动垃圾回收过程将所有已分配的存储块移动到一段连续的存储中，它同时还可以消
运行时刻环境
自动垃圾回收通过回收所有的垃圾而消除了内存泄漏问题。即使使用自动垃圾回收机制
除那些不会被再次引用的数据。请注意，尽管内存泄漏可能由于占用的存储增多而降低
人工存储管理很容易出错。常见的错误有两种形式：一直未能删除不能被引用的数据，这称
人工回收带来的问题
因为我们必须接合 A 和B，所以需要从空闲列表中删除它们中的一个。空闲列表的双重链接
Rational 的 Purify 是帮助程序员寻找程序中的内存访问错误和内存泄漏的最常用的商业
0:200
图7-17堆的片段和一个双重链接的空闲列表
存储块A
一个工具实例:Purify
存储块B
100 1209 120
存储块（