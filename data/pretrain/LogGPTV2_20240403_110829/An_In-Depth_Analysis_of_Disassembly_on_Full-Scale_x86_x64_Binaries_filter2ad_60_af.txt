NDSS
ACSAC
USENIX Sec
NDSS
NDSS
USENIX Sec
2015
2015
2014
2014
2015
2015
2013
2015
2013
2014
2015
2015
2013
2015
2014
2013
2015
2015
2014
2015
2013
2015
2015
2014
2015
2014
2013
2015
2015
2014
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
Table 6: Set of papers discussed in the literature study.
itives on Windows, at best 50% of papers discuss what
happens if the primitive is not recovered perfectly. This
number applies to the top-tier papers; overall, the num-
ber is even lower. The number for Linux-based papers is
slightly better, though even here only a small majority of
papers devote signiﬁcant attention to potential problems.
One would expect more thorough discussion, especially
given that between 80% and 90% of Windows papers,
and around 60% of Linux papers, may suffer malignant
failures given imperfect primitives. The issue is most
apparent in the Windows papers that require function start
information. Only 25% of the top-tier papers that require
function starts consider potential errors in this informa-
tion, even though Section 3.1.1 shows that function starts
are quite challenging to recover accurately.
The percentage of Windows papers that discuss com-
plex cases such as inline data varies from 31% overall
to 42% for top-tier papers. Again, this is less than we
would expect given the prevalence of inline jump tables
generated by Visual Studio. The number for papers that
target Linux is even lower, though this causes fewer issues
as complex cases in ELF binaries are rare.
There is a strong correlation within all papers between
discussion of errors and complex cases, and support for
error handling. Papers that discuss such cases also tend
to implement some mechanism for dealing with errors
if they occur. Conversely, papers that do not implement
error handling nearly always fail to discuss errors at all.
We identiﬁed three popular and recurring categories of
error handling mechanisms.
(1) Overestimation: For instance, CFG and callgraph
overestimation are popular in papers that build binary-
level security; it minimizes the risk of accidentally pro-
hibiting valid edges, though the precision of security poli-
cies may suffer slightly.
(2) Underestimation: This is used in papers where
soundness is more important than completeness.
(3) Runtime augmentation: Some papers use static
analysis to approximate a primitive, and use low-cost
runtime checks to ﬁx errors in the primitive where needed.
Overestimation is the most popular error handling strat-
egy, used in around 30% of top-tier papers. It is followed
by underestimation and runtime augmentation.
6 Discussion
Our ﬁndings show a dualism in the stance on disassem-
bly in the literature. On the one hand, the difﬁculty
of pure (instruction-level) disassembly is often exagger-
ated. The prevalence of complex constructs like overlap-
ping basic blocks, inline data, and overlapping instruc-
tions is frequently overestimated, especially for gcc and
clang [5, 23]. This leads reviewers and researchers to
underestimate the effectiveness of binary-based research.
We showed that unless binaries are deliberately ob-
fuscated, instruction recovery is extremely accurate, es-
USENIX Association  
25th USENIX Security Symposium  597
15
pecially in ELF binaries generated with gcc or clang.
We did not ﬁnd any inline data for these binaries, even
in optimized library code; even jump tables are explic-
itly placed in the .rodata section. Moreover, in Visual
Studio binaries with jump tables in the code section, mod-
ern disassemblers like IDA Pro recognize and resolve
them quite accurately. The rare overlapping instructions
in handcrafted library code take on a limited number of
forms, typically using a direct conditional jump over a
preﬁx. These are resolved without problems by IDA Pro
and Dyninst, among others. The same is true for multi-
entry functions, which are also rare. Moreover, overlap-
ping/shared basic blocks (commonly cited as particularly
challenging for binary analysis), do not appear in our
ﬁndings at all.
On the other hand, some primitives really do often suf-
fer from inaccuracies. Some recursive disassemblers used
for binary instrumentation (notably Dyninst) regularly
miss up to 10% of basic blocks in optimized binaries, call-
ing for special attention in systems which rely on basic
block-level binary instrumentation. Additionally, func-
tion signatures in 64-bit code are extremely inaccurate;
fortunately, they are also rarely used in the literature.
However, function starts are regularly needed, though
the false negative rate regularly rises to 20% or more
even for the best performing disassemblers. This is es-
pecially true in optimized binaries, or in coding styles
that make extensive use of function pointers. Worse, false
positive function starts are almost as common. This can
lead to problems in some binary-based research, espe-
cially binary instrumentation, if care is not taken to en-
sure graceful failure in the event of misdetected function
starts. Symbols offer a great deal of help, especially in
reducing the false negative rate. Unfortunately, they are
rarely available in practice.
It is surprising then, to ﬁnd that only 20% to 25%
(top-tier) of Windows papers that use function starts, and
33% to 50% (top-tier) of the Linux papers, devote any
attention to discussing these problems. A similarly small
number of papers implement error handling, even though
errors can cause malignant failures in a majority of pa-
pers. While it is not impossible to base well-functioning
binary-based systems on function start information (or
other primitives), it is crucial that such work implement
mechanisms for handling inaccuracies. Three effective
classes of error handling (depending on the situation) have
already been proposed in the literature: overestimation,
underestimation, and runtime augmentation.
We hope our study will facilitate a better match be-
tween expectations on disassembly in future research, and
the performance actually delivered by modern disassem-
blers. Moreover, we believe our ﬁndings can be used to
better judge where problems are to be expected, and to
implement effective mechanisms for dealing with them.
7 Related Work
Prior work on disassembly precision focused on complex
corner cases [5, 23, 25] or obfuscated code [18, 34], show-
ing that these can strongly reduce disassembly accuracy.
We focus instead on the performance of modern disas-
semblers given realistic full-scale binaries without active
anti-disassembly techniques.
Miller et al. center their analysis around complex cases
in glibc-2.12 [23]. Their ﬁndings largely correspond
to our own, though we found no inline jump tables in
glibc-2.22. In addition to their glibc analysis, Miller
et al. ﬁnd complex cases in SPEC CPU2006; however,
this analysis focuses exclusively on statically linked bina-
ries. We show in Section 3.3 that these cases are entirely
due to embedded library code, and are extremely rare in
non-statically linked applications.
Our ﬁnding that function starts are among the most
challenging primitives to recover is in agreement with
results by Bao et al. [4].
Paleari et al. study instruction decoders in disassem-
blers [25], which parse individual x86 instructions. Spe-
ciﬁc instructions that are sometimes wrongly parsed have
also been outlined by the authors of Capstone [31].
Complex constructs in obfuscated code are discussed
by Schwarz et al. [34], Linn et al. [21] and Kruegel et
al. [18]. We show that these worst-case complex con-
structs are exceedingly rare in non-obfuscated code.
8 Conclusion
Our study contradicts the widespread belief that complex
constructs severely limit the usefulness of binary-based
research. Instead, we show that modern disassemblers
achieve close to 100% instruction disassembly accuracy
for compiler-generated binaries, and that constructs like
inline data and overlapping code are very rare. Errors in
areas where disassembly is truly lacking, such as function
start recovery, are not discussed nearly as often in the
literature. By analyzing discrepancies between disassem-
bler capabilities and the literature, our work provides a
foundation for guiding future research.
Acknowledgements
We thank the anonymous reviewers for their valuable
input to improve the paper. We also thank Mingwei
Zhang and Rui Qiao for their proofreading and feedback.
This work was supported by the European Commission
through project H2020 ICT-32-2014 “SHARCS” under
Grant Agreement No. 644571, and by the Netherlands
Organisation for Scientiﬁc Research through grant NWO
CSI-DHS 628.001.021 and the NWO 639.023.309 VICI
“Dowsing” project.
598  25th USENIX Security Symposium 
USENIX Association
16
References
[1] ANDRIESSE, D., VAN DER VEEN, V., G ¨OKTAS¸ , E., GRAS, B.,
SAMBUC, L., SLOWINSKA, A., BOS, H., AND GIUFFRIDA,
C. Practical Context-Sensitive CFI. In Proceedings of the 22nd
Conference on Computer and Communications Security (CCS’15)
(Denver, CO, USA, October 2015), ACM.
[2] BACKES, M., AND N ¨URNBERGER, S. Oxymoron Making Fine-
Grained Memory Randomization Practical by Allowing Code
Sharing. In Proceedings of the 23rd USENIX Security Symposium
(USENIX Sec’14) (2014).
[3] BALAKRISHNAN, G., AND REPS, T. WYSINWYX: What You
See is Not What You eXecute. ACM Transactions on Program-
ming Languages and Systems 32, 6 (Aug. 2010), 23:1–23:84.
[4] BAO, T., BURKET, J., WOO, M., TURNER, R., AND BRUMLEY,
D. BYTEWEIGHT: Learning to Recognize Functions in Binary
Code. In Proceedings of the 23rd USENIX Security Symposium
(USENIX Sec’14) (2014).
[5] BERNAT, A. R., AND MILLER, B. P. Anywhere, Any-Time Bi-
nary Instrumentation. In Proceedings of the 10th ACM SIGPLAN-
SIGSOFT Workshop on Program Analysis for Software Tools
(2011).
[6] BONFANTE, G., FERNANDEZ, J., MARION, J.-Y., ROUXEL, B.,
SABATIER, F., AND THIERRY, A. CoDisasm: Medium Scale Con-
catic Disassembly of Self-Modifying Binaries with Overlapping
Instructions. In Proceedings of the 22nd Conference on Computer
and Communications Security (CCS’15) (2015).
[13] GAWLIK, R., AND HOLZ, T. Towards Automated Integrity Pro-
tection of C++ Virtual Function Tables in Binary Programs. In
Proceedings of the 30th Annual Computer Security Applications
Conference (ACSAC’14) (2014).
[14] HALLER, I., SLOWINSKA, A., NEUGSCHWANDTNER, M., AND
BOS, H. Dowsing for Overﬂows: A Guided Fuzzer to Find Buffer
Boundary Violations. In Proceedings of the 22nd USENIX Security
Symposium (USENIX Sec’13) (2013).
[15] HU, X., AND SHIN, K. G. DUET: Integration of Dynamic and
Static Analyses for Malware Clustering with Cluster Ensembles.
In Proceedings of the 29th Annual Computer Security Applications
Conference (ACSAC’13) (2013).
[16] JANG, J., WOO, M., AND BRUMLEY, D. Towards Automatic
Software Lineage Inference. In Proceedings of the 22nd USENIX
Security Symposium (USENIX Sec’13) (2013).
[17] KINDER, J. Static Analysis of x86 Executables. PhD thesis,
Technische Universit¨at Darmstadt, 2010.
[18] KRUEGEL, C., ROBERTSON, W., VALEUR, F., AND VIGNA, G.
Static Disassembly of Obfuscated Binaries. In Proceedings of the
13th USENIX Security Symposium (USENIX Sec’04) (2004).
[19] LAURENZANO, M., TIKIR, M. M., CARRINGTON, L., AND
SNAVELY, A. PEBIL: Efﬁcient Static Binary Instrumentation
for Linux. In Proceedings of the International Symposium on
Performance Analysis of Systems and Software (2010).
[20] LEE, K. H., ZHANG, X., AND XU, D. High Accuracy Attack
Provenance via Binary-based Execution Partition. In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’13) (2013).
[7] BRUMLEY, D., JAGER, I., AVGERINOS, T., AND SCHWARTZ,
E. J. BAP: A Binary Analysis Platform. In Proceedings of the
23rd International Conference on Computer Aided Veriﬁcation
(CAV’11) (2011).
[21] LINN, C., AND DEBRAY, S. Obfuscation of Executable Code to
Improve Resistance to Static Disassembly. In Proceedings of the
10th ACM Conference on Computer and Communications Security
(CCS’03) (2003).
[8] CHEN, X., SLOWINSKA, A., ANDRIESSE, D., BOS, H., AND
GIUFFRIDA, C. StackArmor: Comprehensive Protection from
Stack-Based Memory Error Vulnerabilities for Binaries. In Pro-
ceedings of the Network and Distributed System Security Sympo-
sium (NDSS’15) (San Diego, CA, USA, February 2015), Internet
Society.
[9] CHENG, Y., ZHOU, Z., YU, M., DING, X., AND DENG, R. H.
ROPecker: A Generic and Practical Approach for Defending
Against ROP Attacks. In Proceedings of the Network and Dis-
tributed System Security Symposium (NDSS’14) (2014).
[10] DAVI, L., KOEBERL, P., AND SADEGHI, A.-R. Hardware-
Assisted Fine-Grained Control-Flow Integrity: Towards Efﬁcient
Protection of Embedded Systems Against Software Exploitation.
In Proceedings of the 18th International Symposium on Research
in Attacks, Intrusions, and Defenses (RAID’15) (2015).
[11] EGELE, M., WOO, M., CHAPMAN, P., AND BRUMLEY, D. Blan-
ket Execution: Dynamic Similarity Testing for Program Binaries
and Components. In Proceedings of the 23rd USENIX Security
Symposium (USENIX Sec’14) (2014).
[12] EVANS, I., LONG, F., OTGONBAATAR, U., SHROBE, H., RI-
NARD, M., OKHRAVI, H., AND SIDIROGLOU-DOUSKOS, S.
Control Jujutsu: On the Weaknesses of Fine-Grained Control
Flow Integrity. In Proceedings of the 22nd Conference on Com-
puter and Communications Security (CCS’15) (Denver, CO, USA,
2015), ACM.
[22] MICROSOFT DEVELOPER NETWORK. Overview of x64 Calling
Conventions, 2015. https://msdn.microsoft.com/en-us/
library/ms235286.aspx.
[23] MILLER, B. P., AND MENG, X. Binary Code is Not Easy, 2015.
Technical report, University of Wisconsin-Madison.
[24] MOHAN, V., LARSEN, P., BRUNTHALER, S., HAMLEN, K. W.,
AND FRANZ, M. Opaque Control-Flow Integrity. In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’15) (2015).
[25] PALEARI, R., MARTIGNONI, L., FRESI ROGLIA, G., AND BR-
USCHI, D. N-Version Disassembly: Differential Testing of x86
Disassemblers. In Proceedings of the 19th International Sympo-
sium on Software Testing and Analysis (2010), ISSTA’10.
[26] PENG, F., DENG, Z., ZHANG, X., XU, D., LIN, Z., AND SU, Z.
X-Force: Force-Executing Binary Programs for Security Applica-
tions. In Proceedings of the 23rd USENIX Security Symposium
(USENIX Sec’14) (2014).
[27] PEWNY, J., GARMANY, B., GAWLIK, R., ROSSOW, C., AND
HOLZ, T. Cross-Architecture Bug Search in Binary Executables.
In Proceedings of the 36th IEEE Symposium on Security and
Privacy (S&P’15) (2015).
[28] PEWNY, J., SCHUSTER, F., ROSSOW, C., BERNHARD, L., AND
HOLZ, T. Leveraging Semantic Signatures for Bug Search in
Binary Programs. In Proceedings of the 30th Annual Computer
Security Applications Conference (ACSAC’14) (2014).
USENIX Association  
25th USENIX Security Symposium  599
17
[29] PRAKASH, A., HU, X., AND YIN, H. vfGuard: Strict Protection
for Virtual Function Calls in COTS C++ Binaries. In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’15) (San Diego, CA, USA, February 2015), Internet Soci-
ety.
[30] QIAO, R., ZHANG, M., AND SEKAR, R. A Principled Approach
for ROP Defense. In Proceedings of the 31st Annual Computer
Security Applications Conference (ACSAC’15) (2015).
[31] QUYNH, N. A. Capstone: Next-Gen Disassembly Framework. In
Blackhat USA (2014).
[32] ROMER, T., VOELKER, G., LEE, D., WOLMAN, A., WONG, W.,
LEVY, H., BERSHAD, B., AND CHEN, B. Instrumentation and
Optimization of Win32/Intel Executables Using Etch. In Proceed-
ings of the USENIX Windows NT Workshop (NT’97) (1997).
[33] SCHWARTZ, E. J., LEE, J., WOO, M., AND BRUMLEY, D. Na-
tive x86 Decompilation Using Semantics-Preserving Structural
Analysis and Iterative Control-Flow Structuring. In Proceedings of
the 22nd USENIX Security Symposium (USENIX Sec’13) (2013).
[34] SCHWARZ, B., DEBRAY, S., AND ANDREWS, G. Disassembly
of Executable Code Revisited. In Proceedings of the 9th Working
Conference on Reverse Engineering (WCRE’02) (2002).
[35] SHIN, E. C. R., SONG, D., AND MOAZZEZI, R. Recognizing
Functions in Binaries with Neural Networks. In Proceedings of
the 24th USENIX Security Symposium (USENIX Sec’15) (2015).
[36] SHOSHITAISHVILI, Y., WANG, R., HAUSER, C., KRUEGEL, C.,
AND VIGNA, G. Firmalice - Automatic Detection of Authentica-
tion Bypass Vulnerabilities in Binary Firmware.
[37] TANG, A., SETHUMADHAVAN, S., AND STOLFO, S. Heisenbyte:
Thwarting Memory Disclosure Attacks using Destructive Code
Reads. In Proceedings of the 22nd Conference on Computer and
Communications Security (CCS’15) (2015).
[41] WANG, M., YIN, H., BHASKAR, A. V., SU, P., AND FENG, D.
Binary Code Continent: Finer-Grained Control Flow Integrity for
Stripped Binaries. In Proceedings of the 31st Annual Computer
Security Applications Conference (ACSAC’15) (2015).
[42] WANG, S., WANG, P., AND WU, D. Reassembleable Disassem-
bling. In Proceedings of the 24th USENIX Security Symposium
(USENIX Sec’15) (2015).
[43] WARTELL, R., ZHOU, Y., HAMLEN, K. W., KANTARCIOGLU,
M., AND THURAISINGHAM, B. M. Differentiating Code from
Data in x86 Binaries. In Proceedings of the European Conference
on Machine Learning and Knowledge Discovery in Databases
(2011).
[44] YAKDAN, K., ESCHWEILER, S., GERHARDS-PADILLA, E., AND
SMITH, M. No More Gotos: Decompilation Using Pattern-
Independent Control-Flow Structuring and Semantics-Preserving
Transformations. In Proceedings of the Network and Distributed
System Security Symposium (NDSS’15) (2015).
[45] ZHANG, C., SONG, C., CHEN, K. Z., CHEN, Z., AND SONG, D.
VTint: Protecting Virtual Function Tables’ Integrity. In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’15) (2015).
[46] ZHANG, C., WEI, T., CHEN, Z., DUAN, L., SZEKERES, L.,
MCCAMANT, S., SONG, D., AND ZOU, W. Practical Control
Flow Integrity and Randomization for Binary Executables. In
Proceedings of the 34th IEEE Symposium on Security and Privacy
(S&P’13) (2013).
[47] ZHANG, M., QIAO, R., HASABNIS, N., AND SEKAR, R. A
Platform for Secure Static Binary Instrumentation. In Proceedings
of the 10th ACM SIGPLAN/SIGOPS International Conference on
Virtual Execution Environments (VEE’14) (2014).
[38] TRAIL OF BITS. A Preview of McSema, 2014. Techni-
cal report. http://blog.trailofbits.com/2014/06/23/a-
preview-of-mcsema/.
[48] ZHANG, M., AND SEKAR, R. Control Flow Integrity for COTS
Binaries. In Proceedings of the 22nd USENIX Security Symposium
(USENIX Sec’13) (2013).
[39] VAN DER VEEN, V., G ¨OKTAS¸ , E., CONTAG, M., PAWLOSKI, A.,
CHEN, X., RAWAT, S., BOS, H., HOLZ, T., ATHANASOPOULOS,
E., AND GIUFFRIDA, C. A Tough call: Mitigating Advanced
Code-Reuse Attacks At The Binary Level. In Proceedings of the
37th Symposium on Security and Privacy (S&P’16) (May 2016).
[40] VOGL, S., GAWLIK, R., GARMANY, B., KITTEL, T., PFOH, J.,
ECKERT, C., AND HOLZ, T. Dynamic Hooks: Hiding Control
Flow Changes within Non-Control Data. In Proceedings of the
23rd USENIX Security Symposium (USENIX Sec’14) (2014).
[49] ZHANG, M., AND SEKAR, R. Control Flow and Code Integrity
for COTS binaries. In Proceedings of the 31st Annual Computer
Security Applications Conference (ACSAC’15) (2015).
[50] ZHANG, Y., SUN, X., DENG, Y., CHENG, L., ZENG, S., FU, Y.,
AND FENG, D. Improving Accuracy of Static Integer Overﬂow De-
tection in Binary. In Proceedings of the 18th International Sympo-
sium on Research in Attacks, Intrusions, and Defenses (RAID’15)
(2015).
600  25th USENIX Security Symposium 
USENIX Association
18