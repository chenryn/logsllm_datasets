因此，使用事件溯源的应用需要拉取事件日志（表示 **写入** 系统的资料），并将其转换为适合向用户显示的应用状态（从系统 **读取** 资料的方式【47】）。这种转换可以使用任意逻辑，但它应当是确定性的，以便能再次执行，并从事件日志中衍生出相同的应用状态。
与变更资料捕获一样，重播事件日志允许让你重新构建系统的当前状态。不过，日志压缩需要采用不同的方式处理：
* 用于记录更新的 CDC 事件通常包含记录的 **完整新版本**，因此主键的当前值完全由该主键的最近事件确定，而日志压缩可以丢弃相同主键的先前事件。
* 另一方面，事件溯源在更高层次进行建模：事件通常表示使用者操作的意图，而不是因为操作而发生的状态更新机制。在这种情况下，后面的事件通常不会覆盖先前的事件，所以你需要完整的历史事件来重新构建最终状态。这里进行同样的日志压缩是不可能的。
使用事件溯源的应用通常有一些机制，用于储存从事件日志中汇出的当前状态快照，因此它们不需要重复处理完整的日志。然而这只是一种效能最佳化，用来加速读取，提高从崩溃中恢复的速度；真正的目的是系统能够永久储存所有原始事件，并在需要时重新处理完整的事件日志。我们将在 “[不变性的局限性](#不变性的局限性)” 中讨论这个假设。
#### 命令和事件
事件溯源的哲学是仔细区分 **事件（event）** 和 **命令（command）**【48】。当来自使用者的请求刚到达时，它一开始是一个命令：在这个时间点上它仍然可能失败，比如，因为违反了一些完整性条件。应用必须首先验证它是否可以执行该命令。如果验证成功并且命令被接受，则它变为一个持久化且不可变的事件。
例如，如果使用者试图注册特定使用者名称，或预定飞机或剧院的座位，则应用需要检查使用者名称或座位是否已被占用。（先前在 “[容错共识](ch9.md#容错共识)” 中讨论过这个例子）当检查成功时，应用可以生成一个事件，指示特定的使用者名称是由特定的使用者 ID 注册的，或者座位已经预留给特定的顾客。
在事件生成的时刻，它就成为了 **事实（fact）**。即使客户稍后决定更改或取消预订，他们之前曾预定了某个特定座位的事实仍然成立，而更改或取消是之后新增的单独的事件。
事件流的消费者不允许拒绝事件：当消费者看到事件时，它已经成为日志中不可变的一部分，并且可能已经被其他消费者看到了。因此任何对命令的验证，都需要在它成为事件之前同步完成。例如，透过使用一个可以原子性地自动验证命令并发布事件的可序列事务。
或者，预订座位的使用者请求可以拆分为两个事件：第一个是暂时预约，第二个是验证预约后的独立的确认事件（如 “[使用全序广播实现线性一致的储存](ch9.md#使用全序广播实现线性一致的储存)” 中所述） 。这种分割方式允许验证发生在一个非同步的过程中。
### 状态、流和不变性
我们在 [第十章](ch10.md) 中看到，批处理因其输入档案不变性而受益良多，你可以在现有输入档案上执行实验性处理作业，而不用担心损坏它们。这种不变性原则也是使得事件溯源与变更资料捕获如此强大的原因。
我们通常将资料库视为应用程式当前状态的储存 —— 这种表示针对读取进行了最佳化，而且通常对于服务查询而言是最为方便的表示。状态的本质是，它会变化，所以资料库才会支援资料的增删改。这又该如何匹配不变性呢？
只要你的状态发生了变化，那么这个状态就是这段时间中事件修改的结果。例如，当前可用的座位列表是你已处理的预订所产生的结果，当前帐户余额是帐户中的借与贷的结果，而 Web 伺服器的响应时间图，是所有已发生 Web 请求的独立响应时间的聚合结果。
无论状态如何变化，总是有一系列事件导致了这些变化。即使事情已经执行与回滚，这些事件出现是始终成立的。关键的想法是：可变的状态与不可变事件的仅追加日志相互之间并不矛盾：它们是一体两面，互为阴阳的。所有变化的日志 —— **变化日志（changelog）**，表示了随时间演变的状态。
如果你倾向于数学表示，那么你可能会说，应用状态是事件流对时间求积分得到的结果，而变更流是状态对时间求微分的结果，如 [图 11-6](../img/fig11-6.png) 所示【49,50,51】。这个比喻有一些局限性（例如，状态的二阶导似乎没有意义），但这是考虑资料的一个实用出发点。
$$
state(now) = \int_{t=0}^{now}{stream(t) \ dt} \\
stream(t) = \frac{d\ state(t)}{dt}
$$
![](../img/fig11-6.png)
**图 11-6 应用当前状态与事件流之间的关系**
如果你持久储存了变更日志，那么重现状态就非常简单。如果你认为事件日志是你的记录系统，而所有的衍生状态都从它派生而来，那么系统中的资料流动就容易理解的多。正如帕特・赫兰（Pat Helland）所说的【52】：
> 事务日志记录了资料库的所有变更。高速追加是更改日志的唯一方法。从这个角度来看，资料库的内容其实是日志中记录最新值的快取。日志才是真相，资料库是日志子集的快取，这一快取子集恰好来自日志中每条记录与索引值的最新值。
日志压缩（如 “[日志压缩](#日志压缩)” 中所述）是连线日志与资料库状态之间的桥梁：它只保留每条记录的最新版本，并丢弃被覆盖的版本。
#### 不可变事件的优点
资料库中的不变性是一个古老的概念。例如，会计在几个世纪以来一直在财务记账中应用不变性。一笔交易发生时，它被记录在一个仅追加写入的分类帐中，实质上是描述货币、商品或服务转手的事件日志。账目，比如利润、亏损、资产负债表，是从分类账中的交易求和衍生而来【53】。
如果发生错误，会计师不会删除或更改分类帐中的错误交易 —— 而是新增另一笔交易以补偿错误，例如退还一笔不正确的费用。不正确的交易将永远保留在分类帐中，对于审计而言可能非常重要。如果从不正确的分类账衍生出的错误数字已经公布，那么下一个会计周期的数字就会包括一个更正。这个过程在会计事务中是很常见的【54】。
尽管这种可审计性只在金融系统中尤其重要，但对于不受这种严格监管的许多其他系统，也是很有帮助的。如 “[批处理输出的哲学](ch10.md#批处理输出的哲学)” 中所讨论的，如果你意外地部署了将错误资料写入资料库的错误程式码，当代码会破坏性地覆写资料时，恢复要困难得多。使用不可变事件的仅追加日志，诊断问题与故障恢复就要容易的多。
不可变的事件也包含了比当前状态更多的资讯。例如在购物网站上，顾客可以将物品新增到他们的购物车，然后再将其移除。虽然从履行订单的角度，第二个事件取消了第一个事件，但对分析目的而言，知道客户考虑过某个特定项而之后又反悔，可能是很有用的。也许他们会选择在未来购买，或者他们已经找到了替代品。这个资讯被记录在事件日志中，但对于移出购物车就删除记录的资料库而言，这个资讯在移出购物车时可能就丢失了【42】。
#### 从同一事件日志中派生多个检视
此外，透过从不变的事件日志中分离出可变的状态，你可以针对不同的读取方式，从相同的事件日志中衍生出几种不同的表现形式。效果就像一个流的多个消费者一样（[图 11-5](../img/fig11-5.png)）：例如，分析型资料库 Druid 使用这种方式直接从 Kafka 摄取资料【55】，Pistachio 是一个分散式的键值储存，使用 Kafka 作为提交日志【56】，Kafka Connect 能将来自 Kafka 的资料汇出到各种不同的资料库与索引【41】。这对于许多其他储存和索引系统（如搜寻伺服器）来说是很有意义的，当系统要从分散式日志中获取输入时亦然（请参阅 “[保持系统同步](#保持系统同步)”）。
新增从事件日志到资料库的显式转换，能够使应用更容易地随时间演进：如果你想要引入一个新功能，以新的方式表示现有资料，则可以使用事件日志来构建一个单独的、针对新功能的读取最佳化检视，无需修改现有系统而与之共存。并行执行新旧系统通常比在现有系统中执行复杂的模式迁移更容易。一旦不再需要旧的系统，你可以简单地关闭它并回收其资源【47,57】。