User: This is more of a design question.
I was planning on writing some web-services which implement CPU intensive algorithms. The problem that I am trying to solve is - higher level languages such as python, perl or java make it easy to write web services. While lower level languages such as C, C++ make it possible to fine tune the performance of your code.
So I was looking at what I could do bridge two languages. Here's the options I came up with:
Language specific bindings
Use something like perl-xs or python's ctypes/loadlibrary or java's JNI. The up-side is that I can write extensions which can execute in the same process. There is small overhead of converting between the native language types to C and back.
Implement a separate daemon
Use something like thrift / avro and have a separate daemon that runs the C/C++ code. The upside is, it's loosely coupled from the higher level language. I can quickly replace the high level language. The downside being that the overhead of serializing and local unix domain sockets might be higher than executing the code in the same address space (offered by the previous option.)
What do you guys think?
Assistant: If your C/C++ code already exists, your best bet is to publish it as a service, with an API matching what functionality you already have.  You can then write new services in the language of your choice, matching the API you need, and they can call the C/C++ services.
If your C/C++ code does not exist yet, and you are set to create the majority of code in a higher level language such as Java or C#, consider implementing the performance critical parts initially in that language as well.  Only after profiling shows a particular performance problem, and after you exhaust the most basic optimization techniques within the language, such as avoiding allocations inside the hottest loops, you should consider rewriting the bits that have been proven to consume the most cycles into another language using glue such as JNI.
In other words, do not optimize until you have numbers in hand.  There is also no fundamental reason why you couldn't squeeze out (almost) the same performance level from Java as you can from C++, with enough trying.  You have a real chance to end up with a simpler architecture than you expect.