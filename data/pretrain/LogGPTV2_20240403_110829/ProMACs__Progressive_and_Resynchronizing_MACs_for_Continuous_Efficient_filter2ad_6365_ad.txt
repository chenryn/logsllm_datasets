ğ‘¡ğ‘–+1. To this end, the two PRFs: ğ¹
ğ‘˜â€²â€² . are used, respectively.
Below we assume that the sampled key ğ‘˜ has the form ğ‘˜ = (ğ‘˜â€², ğ‘˜â€²â€²)
3The inspiration for the name is that the sliding â€Area of Dependencyâ€ resembles the
moving â€waveâ€ when cracking a whip.
4In the following, we consider the case where ğ‘¢ is finite. At the end, we shortly discuss
the case of ğ‘¢ = âˆ.
and ğ¹
upd
ğ‘˜â€²
and that these two parts have been used to initialize the two PRFs.
upd
takes as input the counter, the initial substate, and the packet
ğ¹
ğ‘˜â€²
and outputs the next substate:
upd
ğ‘˜â€²
ğ¹
: {0, 1}ğ›¾ Ã— {0, 1}ğœ Ã— {0, 1}ğœ‡ â†’ {0, 1}ğœ
(8)
(9)
This defines the next state ğ‘ ğ‘–+1 = (ğ‘– + 1, Ëœğ‘ 0, Ëœğ‘ [ğ‘–+1,ğ‘¢]) which is used
to compute the corresponding tag with the help of ğ¹
(ğ‘–, Ëœğ‘ 0, ğ‘šğ‘–+1)
sig
ğ‘˜â€²â€² :
: {0, 1}ğ›¾ Ã— {0, 1}ğœ Ã— {0, 1}ğ‘¢Â·ğœ â†’ {0, 1}ğœ
â†¦â†’ Ëœğ‘ ğ‘–+1
(10)
(11)
The core idea of the proposed instantiation is shown in Fig.3. We
now discuss the algorithms that are part of the model, per Definition
4.1:
(ğ‘– + 1, Ëœğ‘ 0, Ëœğ‘ [ğ‘–,ğ‘¢])
â†¦â†’ ğ‘¡ğ‘–
sig
ğ‘˜â€²â€²
ğ¹
Key Generation Gen. The probabilistic key-generation algorithm
Gen samples a secret key ğ‘˜ âˆˆ K. Below we assume that sender and
receiver share a common secret key ğ‘˜ âˆˆ {0, 1}ğœ… and write ğ¹ğ‘˜(. . .)
instead of ğ¹(ğ‘˜, . . .).
Initialization Init. The probabilistic initialization algorithm Init
samples an initial substate Ëœğ‘ 0 âˆˆ {0, 1}ğœ and sets5
ğ‘ 0 = (0, Ëœğ‘ 0, Ëœğ‘ [0,ğ‘¢]).
Also, it samples a key ğ‘˜ = (ğ‘˜â€², ğ‘˜â€²â€²) âˆˆ K to initialize the PRFs ğ¹
and ğ¹
sig
ğ‘˜â€²â€² .
Update Upd and Tag Generation Sig. Both procedures: state up-
date and next tag computation, are accomplished by a call to one
PRF. 6 More precisely, let ğ‘ ğ‘–âˆ’1 denote the current internal state
(with ğ‘ 0 being the initial state) and let ğ‘šğ‘– be the current packet.
Then, Whips updates the internal state by computing:
Ëœğ‘ ğ‘– := ğ¹
upd
ğ‘˜â€²
(ğ‘– âˆ’ 1, Ëœğ‘ 0, ğ‘šğ‘–)
(13)
5The first ğ‘¢ âˆ’ 1 states contain multiple copies of Ëœğ‘ 0 to be compatible with the overall
formal of all states.
sig
6In fact, one could replace the second PRF ğ¹
ğ‘˜â€²â€² by a classical MAC. We chose to rely
on one type of cryptographic primitive, since it may be more efficient in practice to
implement it only once and use it with different keys, e.g., hash functions.
(12)
upd
ğ‘˜â€²
where ğ‘¢ = ad(Upd) is the Area of Dependency. This defines ğ‘ ğ‘– =
(ğ‘–, Ëœğ‘ 0, Ëœğ‘ [ğ‘–,ğ‘¢]). Given this, Whips computes the tag ğ‘¡ğ‘– for ğ‘šğ‘– by
sig
ğ‘˜â€²â€² (ğ‘ ğ‘–).
ğ‘¡ğ‘– := ğ¹
(14)
Verification. The verification algorithm Vrfyğ‘˜ computes on input
ğ‘ ğ‘–, ğ‘šğ‘–, Ëœğ‘¡ğ‘– first the tag ğ‘¡ğ‘– and then compares it to the given Ëœğ‘¡ğ‘–. If both
are equal, the output is true; otherwise it is false.
The Case of Infinite ğ‘¢. If ğ‘¢ = âˆ, i.e., the equivalent of duplex-
based chaining, it is no longer necessary to store the last ğ‘¢ substates
to â€cancelâ€ these out later. Instead, more compact solutions are
possible, e.g., setting ğ‘ ğ‘– = (ğ‘–, Ëœğ‘ 0, Ëœğ‘ ğ‘–) and choosing an appropriate PRF
ğ¹. Here, we can take advantage of the fact that Ëœğ‘ ğ‘– anyhow depends
on all previous states. For security reasons, it is necessary to choose
a higher value for ğœ.
5.2 Design Rationale
Before proving security of our construction, we briefly discuss why
ğ‘ ğ‘– contains the counter, the initial state, and the recent substates.
Let us assume that the state did not contain a counter. Recall that
one goal of our construction is to realize an Area of Dependency to
support resynchronization. This means that, in a scenario where
the packet stream consists of the repetition of the same packet, i.e.,
ğ‘š0 = ğ‘š1 = . . ., the tags would all be the same, which would allow
for a simple forgery attack. The counter ensures freshness of the
state, even if the packets repeat.
Next, we assume that the state would not contain the initial state
value ğ‘ 0. Then, an attacker who can figure out the internal state
ğ‘ ğ‘– for ğ‘– > 0 could produce a forgery by using ğ‘ ğ‘– as â€œinitial stateâ€.
Hence, the initial state, which is beyond attackerâ€™s control, acts as
anchor for the trust chain. In addition, it prevents replay attacks in
the sense that tags observed for one initial state are re-used for a
different initial state.
Finally, to facilitate removal of â€œoutdatedâ€ substates from the cur-
rent state calculation (to ensure an Area of Dependency of length ğ‘¢),
the current state is mainly composed from most recent ğ‘¢ substates.
5.3 Proof of Security
Below, we prove security of our construction. Recall that the mo-
tivation of ProMACs is an attacker who aims to forge a certain
tag also has to forge upcoming tags. Consequently, the number of
tags to be forged needs to be a part of the security claim. In the
context of the security definition, this is equivalent to the number
of fresh forgery sequences Î” (see the definition in Section 4.3.3).
The security claim is as follows:
Theorem 5.1. Consider an instantiation of Whips with two (ğ‘,ğ‘‡ , ğœ€/2)-
pseudorandom functions ğ¹ upd and ğ¹ sig, with substate length of ğœ, tag
length of ğœ â‰¥ 2, and counter length of at least ğ›¾ â‰¥ log2(ğ‘). Then,
for any attacker A who runs in time at most ğ‘‡ , makes at most ğ‘
Sig-queries and produces Î” fresh forgery sequences, the probability
of success is upper-bounded by:
ğ‘ƒğ‘Ÿ [A wins] â‰¤ ğœ€ + ğ‘2 + 2ğ‘
2ğœ
+
.
(15)
(cid:19) Î”
(cid:18) 1
2ğœ
In the parameter choices, we suggest keeping ğœ small (since it
impacts bandwidth overhead), while ğœ can be large (since states
is only stored internally). Thus, 1
term of the sum.
2ğœ can be seen as the dominating
We note that (15) also describes the increasing security level
of the proposed scheme. Since the attackerâ€™s advantage decreases
with every subsequent successful verification, i.e. with increasing
Î”, guaranteed security level for the respective packet is increasing
with each of these packets. For each verified packet, the security
level increases by transmitted tag bits with an upper bound of the
key length. Fig. 1 (bottom) depicts such an increasing security level,
while Fig. 4 demonstrates resynchronization properties of Whips
and the increasing security level.
Figure 4: Achieved security level for the respective incom-
ing packet, assuming a 64-bit tag size and 256-bit key size,
ad(Upd) = 4 and an error at packet #8.
Finally, we note that the proof is independent of ğ‘¢, i.e., the given
bound holds for both finite and infinite ğ‘¢.
Proof of Theorem 5.1. We show the security claim (15) by us-
ing a sequence of games ğº0-ğº3. Since ğ›¾ â‰¥ log2(ğ‘), we exclude the
case of counter overflow, i.e., that the counter repeats after up to ğ‘
queries.
Game ğº0. Let ğº0 denote the original security game as described
in Section 4.3. We are interested in showing an upper bound for
ğ‘ƒğ‘Ÿ [A wins in ğº0].
Game ğº1. ğº1 is defined as ğº0 with the only difference that, when-
upd
ever the attacker makes a Sig-query, it learns the full output of ğ¹
.
ğ‘˜â€²
Since the attacker now has more information, the probability of
success is at least as high as before:
ğ‘ƒğ‘Ÿ [A wins in ğº0] â‰¤ ğ‘ƒğ‘Ÿ [A wins in ğº1] .
(16)
Game ğº2. ğº2 is based on ğº1 with the difference that the PRFs
are replaced by a randomly chosen functions. Because each PRF
is (ğ‘, ğ‘¡, ğœ€/2)-pseudorandom and that A runs in time at most ğ‘¡ and
makes at most ğ‘ queries, it holds that:
ğ‘ƒğ‘Ÿ [A wins in ğº1] â‰¤ ğ‘ƒğ‘Ÿ [A wins in ğº2] + ğœ€.
(17)
Game ğº3. ğº3 is defined as ğº2 with the difference that the game
is aborted if during the Sig-queries, a collision in the states occurs.
An obvious upper bound is given by considering a collision on the
next substate only. Since ğ¹ğ‘˜ is replaced by a random function, it
follows that:
ğ‘ƒğ‘Ÿ [A wins in ğº2] â‰¤ ğ‘ƒğ‘Ÿ [A wins in ğº3] + ğ‘2/2ğœ .
(18)
It remains to upper bound ğ‘ƒğ‘Ÿ [A wins in ğº3].
We assume that Î” = 1. Then, an attacker wins if: (i) either it can
produce a state collision or, (ii) a tag collision. That is, we have:
2ğœ +(cid:16)1 âˆ’ ğ‘
ğ‘
2ğœ
(cid:17) Â· 1
2ğœ .
(19)
ğ‘ƒğ‘Ÿ [A wins in ğº3|Î” = 1] =
:= ğ‘+ğ‘–
Below we use ğ‘ğ‘–
rephrase the equation as:
2ğœ where ğ‘ stands for â€collisionâ€. We can
ğ‘ƒğ‘Ÿ [A wins in ğº3|Î” = 1] = ğ‘0 + 1 âˆ’ ğ‘0
2ğœ
(20)
Next, we consider the case of Î” = 2. For the first fresh sequence,
there are two possibilities: (i) a state collision, or (ii) a tag collision.
In the former, it follows that the second fresh sequence comes â€for
freeâ€. In the latter, we again have the same possibilities for the
second fresh sequence. This yields:
.
ğ‘ƒğ‘Ÿ [A wins in ğº3|Î” = 2] = ğ‘0 + 1 âˆ’ ğ‘0
2ğœ
(21)
By induction and using the fact that 1 âˆ’ ğ‘ğ‘– â‰¤ 1 for all ğ‘– â‰¥ 0, we
can show that probability of winning ğº3 with Î” fresh sequences is
upper bounded by:
Â·
.
(cid:20)
ğ‘1 + 1 âˆ’ ğ‘1
2ğœ
(cid:21)
Î”âˆ’1
ğ‘–=0
(cid:19) Î”
(cid:18) 1
2ğœ
. (22)
ğ‘0 + ğ‘1
2ğœ + ğ‘2
22ğœ + . . . + ğ‘Î”âˆ’1
2(Î”âˆ’1)Â·ğœ + 1
2Î”Â·ğœ =
ğ‘ğ‘–
2(ğ‘–)Â·ğœ +
(cid:18)
Note that, for the sum, it holds that for increasing Î”, the number of
terms in the sum increases, while their values decrease. Thus, we
aim to find an upper bound for the sum. Let ğ‘– â‰¥ 0 be arbitrary. For
the ratio of two successive, it holds that:
ğ‘ + ğ‘– + 1
Â· 1
ğ‘ + ğ‘–
2ğœ =
=
2ğœ â‰¤ 1
â‰¤ 2 Â· 1
2 .
/(cid:16) ğ‘ğ‘–
1 + 1
ğ‘ + ğ‘–
2(ğ‘–+1)Â·(ğœ+1)
Â· 1
2ğœ
ğ‘ğ‘–+1
2ğ‘–Â·ğœ
(cid:19)
(cid:18)
(cid:19)
(cid:17)
In other words, each term in the sum is at most half the size of
the previous term. This allows us to to derive the following upper
bound:
ğ‘–=0
ğ‘ğ‘–
2ğ‘–Â·ğœ
â‰¤ ğ‘0 + ğ‘0
2Î”âˆ’1 < 2 Â· ğ‘0 =
2ğ‘
2ğœ . (23)
Thus, it follows from equations (22) and (23), that attackerâ€™s proba-
bility of success in game ğº3 with Î” fresh sequences can be upper-
bounded by:
2 + ğ‘0
22 + . . . + ğ‘0
(cid:18) 1
(cid:19) Î”
(24)
2ğ‘
2ğœ +