design. First, our solution assumes that users only enter their sen-
sitive data when security indicators state that their inputs are be-
ing encrypted for the expected web application. Previous research
has proposed various alternatives, such as Bumpy [49], where a
special key stroke sequence is required to start a secure input ses-
sion. Instead of relying on users to initiate the securing of their in-
puts, in this work, we automatically encrypt all user inputs within
a CRYPTON-compliant web session. As our solution requires users
to pay attention to secure UI indicators during keyboard input, we
expect our solution to have similar usability challenges as reported
in a prior evaluation of various alternative secure input mecha-
nisms [44]. We anticipate our solution to be usable in enterprise
settings or in mission-critical applications.
Secondly, the initial key setup in establishing a CRYPTON-KERNEL-
to-server secure channel could pose a usability challenge to non-
security-experts, as it requires key upload. Other alternatives could
be considered in a full deployment, such as adopting a trust-on-
ﬁrst-use model [70] as with SSH, or the PAKE protocol [27] to es-
tablish a secure channel based on a shared secret, which have their
own pros and cons [9]. Adopting such alternatives does not af-
fect our core approach and mechanisms proposed in this work. We
choose the current setting for its strong security guarantees and its
compatibility with HTTPS. More recently, various online hosting
services, such as Github [32] and BitBucket [6], have adopted such
a mechanism to authenticate clients for more adept users. We ex-
pect a similar user experience for using a CRYPTON-enabled web-
site in enterprise settings, and a gradual broader adoption among
general web application users.
3.6 Implementation & Deployment
We implement a prototype of the CRYPTON-KERNEL integrated
with WebKit-GTK (rev 45311) with JIT disabled, for the ease of
implementation. Our prototype reuses OpenSSL code for AES-
GCM encryption/decryption. As the WebKit-GTK that we use does
not leverage hardware-accelerated rendering, we implement text
decryption and proof of impression via the software paths by inter-
cepting calls to the bridge between WebKit and the cairo graphics
library. Similarly, we intercept signal dispatch from the GTK+/Glib
to the browser to encrypt user inputs. As user input events are ﬁred
for each keystroke, we use a stream cipher to encrypt user inputs.
Thus, positions of user input characters are maintained as original,
and this naturally supports mouse text selection. When user inputs
are sent to web servers, we use a CRYPTON function to re-encrypt
them with the AES-GCM block cipher with the speciﬁed key. Ta-
ble 2 lists the sizes of components in our prototype implementation
of the CRYPTON-KERNEL. Comparing to a web browser, such
as Firefox and Chromium, which typically has around 800K to
1,100K lines of source code, the TCB in our unoptimized proto-
type is about 30× - 40× smaller.
1318App Name
RoundCube
AjaxIM
WordPress
Sensitive Data
Mails with subject marked as
“[sensitive]”
Instant messages
Blogs containing “[sensitive]”
in titles and search keywords
Server-side Change
Client-side Change
Est. Total Conversion Effort
8 LOC php
6 LOC php
10 LOC php
9 Functions, 0.5K LOC JS
9 Functions, 0.4K LOC JS
19 Functions, 1.2K LOC JS
2-3 Man-Days
2-3 Man-Days
4-5 Man-Days
Table 1: Summary of Case Studies on 3 Popular Web Apps, demonstrating modest adoption effort
CRYPTON-KERNEL Component
Manager
TEMI
Total
Secure Display
Keyboard Encryptor
LOC
2.9K
18.7K
4.8K
0.5K
26.9K
Table 2: Size of TCB in CRYPTON-KERNEL Prototype
Our prototype implements functionalities sufﬁcient to support
our studies with real-world web applications. In a full deployment,
several browser components need to be modiﬁed to propagate the
opaque objects with encrypted data, including support for untrusted
browser sandboxing, browser spell checkers, all CSS styling fea-
tures, web page printing, WebGL and GPU accelerations. Such
support has not been implemented in our current prototype.
For deployment into real web browsers, we consider an alter-
native deployment into Google Chrome’s browser kernel, lever-
aging existing privilege separation and sandboxing mechanisms in
Google Chrome. Google Chrome partitions more vulnerable com-
ponents into the renderer processes, and leave more security-sensitive
components in the browser kernel process. It has also implemented
sandboxing mechanisms to prevent renderer processes from directly
accessing UI rendering, user inputs, ﬁle systems, and network. All
such access has to go via interfaces exposed and checked by the
browser kernel. Thus, we expect it to be relatively straightforward
to implement the CRYPTON-KERNEL into the browser kernel of
Google Chrome, leveraging the existing UI and user input sand-
boxing mechanisms. If we consider such a modiﬁcation to Chrome
12, the code size that can access sensitive data will be signiﬁcantly
reduced. Essentially, it would eliminate more than 900K lines of
code constituting the renderer processes and all client-side applica-
tion code from the TCB for ensuring data protection.
4. EVALUATION
We apply our solution to real-word web applications to study the
applicability and adoption cost. We ﬁrst manually convert 3 popu-
lar web applications to use our solution to protect typical sensitive
data in those applications, and then extend our study to Alex Top 50
web pages. Both micro and macro studies show the effectiveness
of our solution in protecting typical sensitive data on the present
web with modest adoption effort required.
4.1 Applicability to Real-world Applications
Micro-study on open-source web applications. We perform case
studies on three open-source web applications to measure two as-
pects, i.e., a) how effectively our solution can protect sensitive con-
tent in real-word applications, and b) how much developer effort is
required for adopting our solution. We choose applications of dif-
ferent categories: RoundCube [65], a webmail server, AjaxIM7,
a web-based instant messenger, and WordPress [30], a web blog
7We use the AjaxIMRPG fork [23] that is better maintained than
the trunk.
service. We manually convert the source code of the three appli-
cations by: 1) modifying the server-side code to encrypt sensi-
tive content before sending it to clients; 2) identifying client-side
JavaScript functions that need to decrypt sensitive data for opera-
tions and converting them into CRYPTON functions; and 3) rewrit-
ing client-side JavaScript functions that receive and process user
inputs into CRYPTON functions; these CRYPTON functions encrypt
user inputs before sending them to web servers. We check all tests
with a server-side proxy.
We ﬁnd that with modest effort in converting these applications,
our solution can effectively protect typical sensitive data, such as
sensitive emails, instant messages, blog entries and comments. We
write a 450-line custom PHP library for common functionalities to
process CRYPTONs in PHP applications. We manually rewrite the
three web applications, leveraging the custom library to wrap sensi-
tive web content into CRYPTONs. Table 1 summarizes the results of
our case studies on the three applications. Typical client-side opera-
tions on sensitive data we observe include trimming whitespaces in
strings, serializing HTML content, emotion text replacement, URI
encoding, etc. We mark them as CRYPTON functions in our ex-
periments to support the legitimate functionalities. For brevity, we
leave out detailed steps here, and a summary of our modiﬁcation to
application source-code is available online [1].
Macro-study on real-word web applications. To further evaluate
the applicability of the CRYPTON-KERNEL to other web applica-
tions, we perform a larger-scale macro study. First, we select Alexa
Top 50 web pages, and identify all of those ﬁelds that require sen-
sitive username / password inputs for signup – 18 out of the 50 ap-
plications have signup pages (Figure 4). We choose these applica-
tions because they often have client-side checking code on sensitive
passwords (e.g. checking strength requirements). Next, we select
20 popular web applications of ﬁve categories, and identify scenar-
ios where the CRYPTON-KERNEL can strengthen security against
real attacks:
• Web search pages. We select websites that allow users to
search terms. We mark search terms as sensitive because
leaking search terms may permit third-party tracking.
• Social networking sites. These sites can be used to exchange
private messages, or post comments that may be politically-
sensitive. Hence, we mark posts and comments as sensitive.
• Banking sites. Banking sites are prime targets of browser-
based attacks and several malware disguise as browser ex-
tensions. We select a local bank that uses additional authen-
tication mechanisms such as one-time PassKeys. In its web
pages, username, passwords and the one-time PassKey are
marked as sensitive. The one-time PassKey is interesting be-
cause banks are increasingly considering this as a second-
factor authentication beyond long-lived passwords.
• E-commerce sites. We test eBay, Amazon and Babylon on-
line commerce sites. On eBay, we mark the auction listing
created by a seller as sensitive. Different auction listings can
1319Web App Detail
Sensitive Info
Gmail Login
Gmail Compose Email
Gmail Read Email
Ask Search
Google Search
Google+ Post
NetFlix
IMDb Search
Facebook Read Post
Facebook Friend Search
eBay Item List
Amazon Login
Amazon Search
MSN Search
StackOverﬂow
Twitter Login
Wikipedia Search
Babylon Purchase
Local Bank Login
BankOfAmerica Login
Username, Password
To, Subject, Content
From, Subject, Content
Search Terms
Search Terms
Post Content
Username, Password
Search Terms
Post Content
Search Terms
Item’s Description
Username, Password
Search Terms
Search Terms
Post Content
Username, Password
Search Terms
Email Address, Credit Card Info
Username, Password, PassKey
Username, Password
# & Size of Functions Requiring
Decrypted Sensitive Info
[Percentage of Total Code Size]
2 (0.29 KB) [0.43%]
9 (1.84KB) [0.98%]
2 (1.1KB) [0.64%]
3 (1.3KB) [0.31%]
6 (0.92KB) [0.26%]
5 (1.01KB) [0.13%]
1 (0.6KB) [0.2%]
1 (0.24KB) [0.02%]
1 (0.5KB) [0.18%]
9 (1.7KB) [0.50%]
8 (1.49KB) [0.62%]
2 (1.87KB) [1.28%]
9 (1.77KB) [0.24%]
5 (1.4KB) [0.08%]
5 (2.36KB) [1.18%]
3 (0.61KB) [0.27%]
6 (1.9KB) [0.23%]
3 (1.17KB) [0.70%])
3 (1.49KB) [1.01%]
2 (1.01 KB) [0.23%]
# & Size of
All JavaScript
Functions
196 (66.5KB)
745 (186.8KB)
730 (171.1KB)
569 (416.2KB)
581 (352.9KB)
1150 (750KB)
419 (289.9KB)
1131 (1.1MB)
730 (268KB)
959 (336.6KB)
725(239.2KB)
240 (146KB)
485 (732.7KB)
1185 (1.7MB)
429 (198.9KB)
472 (223.6KB)
438 (794.1KB)
485 (165KB)
250 (146.3KB)
780 (430.4KB)
# Browser and TEMI Interactions vs.
# All Calls to JS Data Types
0.7% (956/141492)
0.01% (89/541883)
0.02% (92/390206)
0.01% (40/218922)
0.2% (437/206675)
0.005% (48/947254)
0.1% (170/162853)
0.1% (422/323208)
0.02% (347/1216952)
6.4% (60305/937108)
0.1% (326/241901)
0.5% (1629/321275)
0.1% (544/433110)
0.5% (2096/435124)
0.2% (830/406328)
0.004% (27/622874)
0.45% (382/84818)