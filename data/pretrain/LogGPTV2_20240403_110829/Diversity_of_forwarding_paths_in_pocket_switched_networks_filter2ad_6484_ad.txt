50
i
)
s
(
n
o
s
o
p
x
E
o
l
t
e
m
T
i
1000
1500
2500
Optimal Path Duration (s)
2000
3000
3500
0
0
500
1000
1500
2500
Optimal Path Duration (s)
2000
3000
3500
3000
3500
(c)
(d)
Figure 7: Path Explosion Plots Info 06 9-12 (a) in-in (b) in-out (c) out-in (d) out-out.
Results for other datasets are not shown due to lack of space,
but generally showed similar behavior.
In summary, we have shown two key results in this section.
First, we have used an homogeneous analytical model to
show how path explosion occurs. We have shown that path
explosion is an exponential function of both elapsed time and
the rate λ at which nodes come into contact. This addresses
the ﬁrst question about our empirical results, namely, how
and why does path explosion occur? Second we have shed
light on the other set of questions arising from our empirical
results by considering the eﬀects of inhomogeneity in rates.
We have shown that by looking at the contact rates of the
source and destination nodes, one can gain insight into why
the optimal path duration and the time to explosion vary,
and one can relate these quantities to the relative magni-
tudes of the two contact rates.
6.
IMPLICATIONS FOR FORWARDING
In the previous sections we have developed insight into
what sorts of paths are available for use by routing algo-
rithms in settings such as ours. This has laid the ground-
work for an understanding of how various forwarding algo-
rithms perform in our setting. In this section we study the
performance of a wide range of forwarding algorithms and
relate their performance to the results developed in previous
sections.
6.1 Experiments
We study forwarding by implementing diﬀerent forward-
ing algorithms in a trace-driven simulator. We use as input
to our simulator the contact traces described in Section 3.
Each simulation therefore ran for simulated time of 3 hours.
However, to avoid end-eﬀects, only results from the ﬁrst two
hours are used.
For each trace and forwarding algorithm, we generate a
set of messages (σ, δ, t1) uniformly at random. We generate
messages according to a Poisson process with rate one mes-
sage per 4 seconds. As discussed in Section 4.1 we model
nodes as having inﬁnite buﬀers and nodes carry all the mes-
sages they receive till the end of the simulation. All our
results are averaged over 10 simulation runs. Our metrics
are success rate S and average delay D as deﬁned in Sec-
tion 4.1.
Our goal in this section is not to determine which forward-
ing algorithm is “best” but to compare the performance of
a wide range of algorithms and gain insight into what prop-
erties of a forwarding algorithm yield good performance.
Hence we choose a set of algorithms designed to span a range
of design choices. The design choices include:
• Destination aware vs. Destination unaware. Destina-
tion aware algorithms take the choice of δ into consid-
eration in forwarding, while destination unaware algo-
rithms do not.
• Single hop vs. Multi hop. Single hop algorithms use
information about the most recent contact or next ex-
pected contact; multi hop algorithms take into account
sequences of past or expected future contacts.
• Complete history vs. Recent history vs. Future knowl-
edge. Complete history algorithms take into account
Epidemic
Fresh
Greedy
Grd Onl
Dynamic Programming
Greedy Total
2000
1800
1600
1400
1200
1000
800
600
400
200
)
s
(
y
a
e
D
l
.
g
v
A
2000
1800
1600
1400
1200
1000
800
600
400
200
)
s
(
y
a
e
D
l
.
g
v
A
0
0
0.1
0.2
0.3
0.5
0.4
0.6
Success Rate
(a)
0.7
0.8
0.9
1
0
0
0.1
0.2
0.3
0.7
0.8
0.9
1
0.5
0.4
0.6
Success Rate
(b)
2000
1800
1600
1400
1200
1000
800
600
400
200
2000
1800
1600
1400
1200
1000
800
600
400
200
)
s
(
y
a
e
D
l
.
g
v
A
l
)
s
(
y
a
e
D
g
v
A
0
0
0.1
0.2
0.3
0.5
0.4
0.6
Success Rate
(c)
0.7
0.8
0.9
1
0
0
0.1
0.2
0.3
0.7
0.8
0.9
1
0.5
0.4
0.6
Success Rate
(d)
Figure 8: Average Delay (sec) vs Success Rate (a) Infocom 06 9-12 (b) Infocom 06 3-6 (c) Conext 9-12 (d)
Conext 3-6
the entire past history of other nodes when forward-
ing. Recent history algorithms taken into account only
a limited amount of history (e.g., only the most recent
encounter with the destination). Future knowledge al-
gorithms make use of oracles that provide knowledge of
future behavior of the nodes. Future knowledge algo-
rithms are not practical but provide useful comparison
cases.
To span these design choices we use the following forward-
ing algorithms. Some of these algorithms are known from
the literature and others are modiﬁcations or extensions.
Epidemic Forwarding (Flooding): A node forwards all
the packets it has to any node it meets, unless that
node already has a copy of the packet [19]. As already
noted, Epidemic Forwarding achieves the best possible
performance, so this algorithm yields upper bounds on
success rate and average delay.
FRESH : Node xi forwards a message to xj upon contact
if xj has contacted δ more recently than has xi [6].
Greedy : Node xi forwards a message to xj upon contact
if xj has contacted δ more times since the start of the
simulation than has xi. Greedy uses the entire history
of contacts in contrast to FRESH which uses only the
most recent contact history.
Greedy Total : Node xi forwards a message to xj upon
contact if xj has more total contacts (with all other
nodes) than xi. Thus Greedy Total
is destination
unaware, while FRESH and Greedy are destination
aware. Greedy Total uses both past and future knowl-
edge of internode contacts.
Greedy Online : Node xi forwards a message to xj upon
contact if xj has more contacts with δ since the start of
simulation than does xi. Greedy Online is destination
aware but uses only past knowledge, unlike Greedy.
Dynamic Programming : Node xi calculates the average
delay between all pairs of nodes then ﬁnds the optimal
path. This is based on the Minimum Expected Delay
algorithm [10]. Dynamic Programming is based on
both past and future knowledge of internode contacts.
6.2 Observations
6.2.1 Similarity of Performance
The most striking aspect of our results is the similarity in
performance of the various diﬀerent forwarding algorithms.
This is illustrated in Figure 8. For each data set and for-
warding algorithm we plot the average delay vs success rate.
The ﬁgure shows that almost all forwarding algorithms
show virtually identical performance. The exception is epi-
demic routing (shown using square symbols in the plots)
which shows somewhat better performance than the others,
since it always ﬁnds the optimal path if one exists.
While the plots in Figure 8 show the similarity of average
delay, a more detailed view is given in Figure 9. This ﬁgure
shows the entire distribution of delay. The ﬁgure shows that
i
)
s
(
e
m
T
<
d
e
r
e
v
i
l
e
D
s
e
g
a
s
s
e
M
%
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
0
1000
2000
Epidemic
Ease
Greedy
Greedy Online
Dynamic Programming
Greedy Total
Epidemic
Fresh
Greedy
Greedy Online
Dynamic Programming
Greedy Total
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
i
)
s
(
e
m
T
<
d
e
r
e
v
i
l
e
D
s
e
g
a
s
s
e
M
%
5000
6000
7000
0
0
1000
2000
3000
5000
6000
7000
8000
4000
Time (s)
(b)