l i n u x 内 核 漏 洞 检 测 与 防 御
蒋浩天/张海全 腾讯安全云鼎实验室
自我介绍
蒋浩天：
擅长二进制安全、虚拟化安全、游戏安全等，喜欢研究一些底层方向，将安全能力下沉，开启安
全对抗的上帝模式。
张海全：
主要从事GCC和Linux内核安全功能研发，Linux内核源码贡献者。 主要方向是漏洞挖掘，CFI防
御，编译器sanitizer。致力于将漏洞扼杀在编译器中。
l 漏洞攻防现状
l 漏洞利用技术
l 传统漏洞防御技巧
l 基于intel pt的漏洞检测方案
l 基于编译器的漏洞防御方案
l 后续展望
大纲
漏洞攻防现状
主机漏洞防御价值
•
系统漏洞可通杀，是云主机最主
要威胁。
•
挖矿/勒索等入侵的必争之地，有
爆发态势。
•
内核处在纵深体系中间，漏洞多
于固件/虚拟化，影响大于基础软
件/用户应用，收益大。
•
建设最后一道防线，是第一优先。
内核漏洞利用：现状
•
内核漏洞攻防现状：
•
内核版本碎片化和支持断供，关键系
统难更新。
•
利益驱动的漏洞研究暗流涌动。
•
现有防御选项。
•
开源方案关注事后阻断，即时阻断弱，
已有对抗。
响应难
即时
碎片化
严重
攻击面
庞杂
挖洞降
门槛
攻防升
级
•
VED，PaloAlto XDR
• 事中阻断，信息少
• LKRG
• 事后阻断
• PaX&GrSecurity
• 重：开销，价值，运营
• 内核隔离，随机化
• 可绕过
底层
特性
原生
加固
商业
方案
开源
机制
漏洞利用技术
常用的漏洞利用手法
•
返回地址劫持
•
堆喷
•
she链覆盖
•
栈交换
•
ROP
•
Ret2user
•
等等等
堆喷
•
内核堆喷，是当前内核漏洞利
用过程中非常重要的部分。80%
的漏洞利用，都依赖堆喷。
•
堆喷利用手法。
•
use after free/double free 
类型堆喷利用手法。
•
堆溢出类型堆喷利用手法。
传统漏洞防御技巧
堆喷干扰
•
通过hook接管linux内核slab，
slub，对申请的内存尾部追加少
量随机字节，并增加随机延迟释
放，可以有效的干扰堆喷，导致
其失败。从而做到机制性的防御，
具备更强的通用性。
堆喷干扰
•
在漏洞利用过程中，只要是
利用堆喷的，都可以对其进行干
扰，导致堆喷失败。
ROP防御
•
ROP在现代漏洞利用中，基本是必不可缺的一个环节。基本走到这一步，说明漏洞利用已经成功了
一大半了，已经进行了控制流的劫持。漏洞通过rop来调用敏感api，来完成权限提升，容器逃逸。
•
对提权，容器逃逸相关的敏感api进行HOOK。
•
检测栈指针的合法性。
•
调用来源的合法性。
•
调用指令合法性。
信息泄露缓解
•
全局变量地址泄漏。
•
干扰堆喷。
•
dmesg 异常栈指针泄漏。
•
符号地址鉴权脱敏。
•
kallsyms泄漏。
•
符号地址鉴权脱敏。
安全状态监控
•
对系统中所有的进程进行监控，监控进程的cred和namespace，及时发现进程的异常权限提升和容
器逃逸行为。
•
CR4 SMEP & SMAP状态监测，及时发现漏洞利用过程中，对SMEP & SMAP的禁用。
•
传统的内核加固方式很多，不一一列举。
基于intel PT的漏洞检测方案
基于硬件特性的漏洞检测方案
•
随着时代的发展，CPU 支持的硬件特性越来越多，安全相关的大家听的最多的就是影子栈，并且在
一些场景下已经得到应用。
•
基于软件的漏洞防御，CFI/CFG，在 Windows 中，已经得到广泛应用。
•
CET IBT（indirect branch tracker）机制，基于硬件的简化版本CFI，但是很多CPU并不支持。
•
其实Linux kernel 目前对这些安全机制都不支持。
•
我们想对老版本系统进行改造，实现这三个特性，并且无需重新编译内核。
可行性分析
•
想要实现这些特性，我们需要具备一些前置条件：
•
Shadow stack ：
•
获取指令流，从中提取出 call 和 ret 两种指令。
•
模拟一个栈，去模拟 call 和 ret 的入栈出栈操作，识别入栈和出栈不对等的情况。
•
IBT/CFI：
•
捕获所有的跳转指令，获取指令跳转信息。
•
分析跳转指令的合法性。
•
如何提取指令序列?
•
如何确定跳转指令的合法性？
技术选型
•
在x86 intel 架构上，想要获取程序的 call ，ret 和间接跳转的指令，在不修改源码的情况下有几种
方式：
•
LBR (Last branch record)，将跳转分支信息保存到MSR寄存器中，记录数量有限。可以通过技
巧做到实时拦截。
•
BTS (Branch Trace Messages)，可以将跳转分支记录到内存中，保存数量多。性能低，可以通
过技巧做到实时拦截。
•
PT (Processor Trace)，属于BTS的进化版本，性能更好。但无法通过技巧进行实时拦截。
•
通过对三种机制的分析，最终选择采用PT技术。
技术选型
•
通过查阅资料，我们发现linux perf工具已经集成了intel PT的能力，用于做性能分析。
•
分为user模块和kernel模块：
•
Kernel模块负责完成intel PT的所有trace功能。
•
User模块负责保存PT trace数据，并解析。
•
Kernel 和user 采用ringbuff进行数据交互。
•
站在巨人的肩膀上，我们对perf进行改造。
堆喷干扰
•
支持trace 的指令类型。
•
支持用户态，内核态，和进
程过滤，地址范围过滤等。非常
匹配我们的需求。
•
Intel PT trace buff 分为两种类型：
•
Single Range Out.
•
Table of Physical Addresses(ToPA).
•
ToPA可以通过配置IA32_RTIT_OUTPUT_BASE来指定
ToPA Table的第一个表，如果存在多个表，可以在表的
最后一项指定下一个ToPA的地址，并将END标志位置
为1。
•
每一个ToPA表，可以指定多个OutputRegion，并且每
一个OutputRegion的大小可以不同，最小是4k最大是
128M。
Intel PT的工作机制
•
Intel PT 类似于生产者和消费者模型。
•
每当CPU执行指令时，如果符合filter的条件，那么将会向trace buff中写入压缩的数据。
•
当buff写满之后，将会产生PMI中断。
•
在中断中，先停止trace ，然后将buff的数据保存，并重新开启Intel PT trace。
•
但是在PMI中断中，直接将缓存的数据进行转存，会比较麻烦，所以大家的做法，普遍都是用一
个用户层的程序，去读取这个trace buff数据。由用户层程序完成这个持久化操作。
Intel PT的工作机制
•
在PMI中断中，处理Intel PT事件：
•
关闭PT trace。
•
更新状态。
•
通知用户态从ringbuff中读数据。
•
重新配置trace buff，指向下一个page entry。
•
启动PT trace。
Intel PT的工作机制
•