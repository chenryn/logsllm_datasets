+++ OpenBTS.confi g 2012-03-12 11:31:27.029729225 +0100
@@ -30,3 +30,3 @@
# The initial global logging level: ERROR, WARN, NOTICE, INFO, DEBUG, DEEPDEBUG
-Log.Level NOTICE
+Log.Level INFO
cc1111..iinndddd 333322 44//1166//22001122 55::4488::1188 PPMM
Chapter 11 n Baseband Attacks 333
# Logging levels can also be defi ned for individual source fi les.
@@ -86,4 +86,4 @@
# YOU MUST HAVE A MATCHING libusrp AS WELL!!
-TRX.Path ../Transceiver/transceiver
-#TRX.Path ../Transceiver52M/transceiver
+#TRX.Path ../Transceiver/transceiver
+TRX.Path ../Transceiver52M/transceiver
$static TRX.Path
@@ -182,3 +182,3 @@
# Things to query during registration updates.
-#Control.LUR.QueryIMEI
+Control.LUR.QueryIMEI
$optional Control.LUR.QueryIMEI
@@ -197,3 +197,3 @@
# Maximum allowed ages of a TMSI, in hours.
-Control.TMSITable.MaxAge 72
+Control.TMSITable.MaxAge 24
@@ -259,3 +259,3 @@
# Location Area Code, 0-65535
-GSM.LAC 1000
+GSM.LAC 42
# Cell ID, 0-65535
@@ -286,5 +286,5 @@
# Valid ARFCN range depends on the band.
-GSM.ARFCN 51
+#GSM.ARFCN 51
# ARCN 975 is inside the US ISM-900 band and also in the GSM900 band.
-#GSM.ARFCN 975
+GSM.ARFCN 975
# ARFCN 207 was what we ran at BM2008, I think, in the GSM850 band.
@@ -295,3 +295,3 @@
# Should probably include our own ARFCN
-GSM.Neighbors 39 41 43
+GSM.Neighbors 39 41 975
#GSM.Neighbors 207
Please take care to adjust GSM.ARFCN, GSM.Band and GSM.Neighbours according
to the frequency that you have been authorized to transmit on.
Note that by default you are running OpenBTS in a so-called open confi guration
— meaning that any mobile device that tries to register with the test network
will allowed to. This may have unwanted side effects, especially if you have not
properly limited your transmission power and/or are in an area where other
networks only have weak signals. Devices may inadvertently roam into your
network. To prevent this, you can run OpenBTS in a closed confi guration that
requires each IMSI to be registered with Asterisk.
After having connected your hardware, you should perform a simple check to
see whether everything is set up correctly. For this test, you can use the testcall
functionality that you will later also use to transmit raw GSM layer 3 messages.
cc1111..iinndddd 333333 44//1166//22001122 55::4488::1188 PPMM
334 Chapter 11 n Baseband Attacks
First, install the libmich library (from https://github.com/mitshell/libmich,
not required if you use the virtual machine provided), a nifty library to create
layer 3 messages using a Python interface. Next, start OpenBTS and register your
iPhone with the test network. To select the test network, disable the automatic
selection of the network in the Carrier section of the Settings application and
choose the mobile network with the name 00101.
If you have trouble seeing or registering with your test network, it can help to
put the iPhone into airplane mode for at least 5 seconds. Disable airplane mode
after that and perform the network selection procedure again; your phone will
now perform a full scan.
After having registered with the network, you can simulate the fi rst stage of
a call establishment. Use the following commands to set up a traffi c channel
to the iPhone:
OpenBTS> tmsis
TMSI IMSI IMEI(SV) age used
0x4f5e0ccc 262XXXXXXXXXXXX 01XXXXXXXXXXXXXX 293s 293s
1 TMSIs in table
OpenBTS> testcall 262XXXXXXXXXXXX 60
OpenBTS> calls
1804289383 TI=(1,0) IMSI=262XXXXXXXXXXXX Test from=0 Q.931State=active
SIPState=Null (2 sec)
1 transactions in table
In the previous example, the command tmsis shows a mapping of the
Temporary Mobile Subscriber Identitiy (TMSI) of the registered iPhone to its
International Mobile Subscriber Identity (IMSI) together with the International
Mobile Equipment Identity and Software Version (IMEISV) as well as the time
of initial registration and the time of last use. The testcall command opens a
UDP socket — by default on port 28670 — and a traffi c channel to the mobile
device specifi ed by IMSI in the second argument. The number of seconds this
channel should be held open is specifi ed in the second argument. This allows you
to send datagrams to the UDP port that are forwarded as GSM layer 3 packets to
the mobile device and vice versa. At any time, only a single testcall instance
can be active. To see which calls are established you can use the calls command.
You then run the following simple Python script in another terminal to simu-
late call setup:
import socket
import time
from libmich.formats import *
TESTCALL_PORT = 28670
tcsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
tcsock.sendto(str(L3Mobile.SETUP()), (‘127.0.0.1’, TESTCALL_PORT))
cc1111..iinndddd 333344 44//1166//22001122 55::4488::1188 PPMM
Chapter 11 n Baseband Attacks 335
After you execute this script, your iPhone should ring. Please note that you
are not following the state transitions after sending the initial call setup mes-
sage; hence the phone will appear to be frozen while ringing. Simply shut down
OpenBTS if this test has worked.
Closed Confi guration and Asterisk Dialing Rules
You did not have to confi gure Asterisk in the previous description because
you were operating OpenBTS in open confi guration. If you want to operate
OpenBTS in closed confi guration or to make calls between multiple registered
phones on your test network, you will not be able to get around at least a basic
confi guration of Asterisk. As a bare minimum, you can simply append the fol-
lowing lines to the default extensions.conf
[sip-openbts]
exten => 6666,1,Dial(SIP/IMSI2620XXXXXXXXX)
exten => 7777,1,Dial(SIP/IMSI2620YYYYYYYYYYY)
and the following lines to the default sip.conf:
[IMSI2620XXXXXXXXXXX]
callerid=6666
canreinvite=no
type=friend
context=sip-openbts
allow=gsm
host=dynamic
[IMSI2620YYYYYYYYYY]
callerid=7777
canreinvite=no
type=friend
context=sip-openbts
allow=gsm
host=dynamic
Please make sure that both the context and the IMSI identifi ers match between
sip.conf and extensions.conf.
RTOSes Underneath the Stacks
The cellular baseband of a modern smartphone can be seen as an independent
subsystem — it is running its own operating system on its own processor with
dedicated coprocessors (for example, DSPs, crypto, and 3G coprocessors). This
can be attributed to the real-time requirements for cellular communications.
Consequently, the operating systems running underneath the cellular stack are
dedicated real-time operating systems, sometimes proprietary to the vendor
of the baseband stack — as in the case of Qualcomm’s REX. More commonly,
cc1111..iinndddd 333355 44//1166//22001122 55::4488::1188 PPMM
336 Chapter 11 n Baseband Attacks
however, the owner of the cellular stack simply has licensed a commercially
available OS on which to run his cellular stack. The primary tasks of these
operating systems is to manage resources such as processors, memory, and
attached devices — effi ciently, and with real-time constraints — which makes
them often appear much different than a desktop operating system, although
they are not.
The following sections give you a brief exposition of the three different real-
time operating systems that are in use by different versions of iOS devices.
They also explain how task/thread control, inter-task/thread communication
and locking mechanisms, memory management, and memory protection work
for each of them.
Nucleus PLUS
Nucleus PLUS is a widely used commercial RTOS distributed by Mentor Graphics.
It is shipped in source form to the paying licensees. The baseband of the S-Gold
2 as well as of the X-Gold 608 run on Nucleus PLUS. Unfortunately, no good
public documentation on Nucleus PLUS is available; however, the offi cial manu-
als have leaked.
Units of execution in Nucleus PLUS are called tasks. Tasks can be dynami-
cally created and deleted in Nucleus PLUS and run at a priority defi ned at
task creation time. For each priority level, all tasks on this level are run time
sliced in a round-robin fashion; they can also explicitly relinquish the proces-
sor. Tasks can preempt other tasks that have a lower priority. Preemption can
be disabled — not only globally but also for each task individually. Interrupt
Service Routines (ISR) are different kinds of execution units. Several different
types of ISRs are distinguished. The fi rst kind is the User ISR, which cannot
use any Nucleus PLUS services and needs to save and restore the registers it
uses itself. They are tied directly to an interrupt vector and are not registered
through Nucleus PLUS. Next are low-level ISRs (LISRs), which are fi rst-level
interrupt handlers; and high-level ISRs (HISRs), which are second-level inter-
rupt handlers. LISRs have only limited access to Nucleus PLUS services and
are tied to an interrupt vector, whereas HISRs are scheduled similarly to tasks
and may call most of the Nucleus PLUS services.
Nucleus PLUS distinguishes two different kinds of memory allocations: partition
memory and dynamic memory. Both types of memories are managed in memory
pools that need to be defi ned fi rst before allocations can be taken from them.
Tasks can be suspended when the allocation cannot be immediately performed,
causing them to wait until a suitable chunk of memory becomes free. Partition
memory is a form of memory that allows allocations only in fi xed-sized blocks.
Each call to the allocation function obtains one block of exactly that fi xed size
from the pool. This type of memory management is very common for embedded
cc1111..iinndddd 333366 44//1166//22001122 55::4488::1188 PPMM
Chapter 11 n Baseband Attacks 337
systems with real-time constraints because it allows memory allocations to
occur with constant execution time. Moreover, partition memory is more space
effi cient because there is no need to store allocation meta data for the blocks.
Dynamic memory, on the other hand, allows variable-sized allocations from
the pool, similar to a regular malloc() implementation. (Please also consult
the “Heap Implementations” section later in this chapter for the internals of
the heap implementations.)
For task synchronization and mutual exclusion semaphores can be used. The
semaphores implemented by Nucleus PLUS are counting semaphores.
Several means exist for tasks to communicate with each other: Mailboxes
can be dynamically created and deleted. They are the most primitive means
for data transfer. Each mailbox can hold only a single message consisting of
exactly four 32-bit words. More powerful primitives are pipes and queues:
Now you can send multiple messages that consist of one or more bytes (pipes),
respectively 32-bit words (queues). Both variable-and fi xed-length pipes and
queues can be created; their type is defi ned at time of creation. Messages are
sent and received by value and not by reference; broadcast messages are sup-
ported, and all tasks waiting for a message from a queue will wake up and
receive these messages.
Other concepts for signaling and synchronization between tasks supported
by Nucleus PLUS are event groups, and signals. All of these, however, have an
extremely limited bandwidth.
ThreadX
ThreadX is the direct successor of Nucleus PLUS; both operating systems were
written by the same software engineer, William Lamie. Just like Nucleus, ThreadX
is distributed to licensees in source form, but by a different company — Express
Logic. Compared to Nucleus PLUS, the complexity of the API has signifi cantly
decreased, and the interrupt architecture was overhauled. In contrast to the
other operating systems described in this chapter, Edwards C. Lamie offers
Real-Time Embedded Multithreading: Using ThreadX and ARM (ISBN 1578201349
CMP, 2005) which is a good book on ThreadX that covers its implementation in
detail. Due to this fact and its close relation to Nucleus PLUS, we do not further
describe its idiosyncrasies in this chapter.
REX/OKL4/Iguana
Real-time Executive System (REX) is an RTOS developed by Qualcomm for its
Mobile Station Modem (MSM) products. It is employed by the Advanced Mobile
Subscriber Software (AMSS) running on the MDM66x0 chips. Beginning in
late 2006, Qualcomm made a major design innovation to its cellular stack: An
L4-derived microkernel, OKL4, was propped underneath REX. Luckily, some
cc1111..iinndddd 333377 44//1166//22001122 55::4488::1188 PPMM
338 Chapter 11 n Baseband Attacks
versions of OKL4 are freely available in source form, which signifi cantly simpli-
fi es the analysis of AMSS.
OKL4 is merely the microkernel of the system. The actual meat of the operat-
ing system, such as virtual memory management and process management, is
implemented in Iguana, an L4 server, for which source code is freely available.
The unit of execution in Iguana and L4 is called a thread. In fact, Iguana threads
are L4 threads and can be manipulated through the L4 API as well as through
an Iguana API.
Iguana uses a single address space to make sharing of data effi cient and
employs per-process protection domains to enforce its security policy. A
protection domain can be seen as the equivalent of a process in a traditional
operating system and defi nes what resources a process can access.
Memory sections are contiguous ranges of virtual pages; they are the basic
units of virtual memory allocation and protection in Iguana. Memory sections
can be created both at boot time and at run time using memsection_create().
A signifi cant difference between OKL4/Iguana and the other operating
systems discussed in this chapter is that only the operating system and not the
actual application — in our case the cellular stack — runs in supervisor mode.
AMSS, including drivers, is completely run in user mode.
Heap Implementations
This section dives in head fi rst into the internals of heap memory management
of the operating systems. You should be somewhat familiar with exploiting
heap buffer overfl ows already to make use of the information presented here.
Dynamic Memory in Nucleus PLUS
Nucleus PLUS uses a simplistic fi rst-fi t allocator for managing dynamic memory.
For each pool created using NU_Create_Memory_Pool(), a pool control block of
the following layout is created:
struct dynmem_pcb
{
void *cs_prev;
void *cs_next;
uint32_t cs_prio;
void *tc_tcb_ptr;
uint32_t tc_wait_fl ag;
uint32_t id; /* magic value [‘DYNA’] */
char name[8]; /* Dynamic Pool name */
void *start_addr; /* Starting pool address */
uint32_t pool_size; /* Size of pool */
uint32_t min_alloc; /* Minimum allocate size */
uint32_t available; /* Total available bytes */
cc1111..iinndddd 333388 44//1166//22001122 55::4488::1188 PPMM
Chapter 11 n Baseband Attacks 339
struct dynmem_hdr *memory_list; /* Memory list */
struct dynmem_hdr *search_ptr /* Search pointer */
uint32_t fi fo_suspend; /* Suspension type fl ag */
uint32_t num_waiting; /* Number of waiting tasks*/
void *waiting_list; /* Suspension list */
};
Each chunk of memory allocated with NU_Allocate_Memory() has a header
of the following structure (16 bytes):
struct dynmem_hdr
{
struct dynmem_hdr *next_blk, /* Next memory block */
*prev_blk; /* Previous memory block */
bool is_free; /* Memory block free fl ag */
struct dynmem_pcb *pool_pcb; /* Dynamic pool pointer */
}
Initially, before dynamic memory can be allocated, at least one pool needs
to be created with NU_Create_Memory_Pool(pcb, name, start_addr, size,
min_alloc, suspend_t):
n pcb — Pointer to the pool control block
n name — A name for the pool, in ASCII
n start_addr — First address in memory that can be used for allocations
from this pool
n pool_size — Size of the pool, in bytes
n min_alloc — Minimal allocation size in bytes (smaller allocations will be