[6] Christian Decker, Jochen Seidel, and Roger Wattenhofer. Bitcoin meets strong
consistency. In Proceedings of the 17th International Conference on Distributed
Computing and Networking, page 13. ACM, 2016.
Ittay Eyal, Adem Efe Gencer, Emin Gün Sirer, and Robbert Van Renesse. Bitcoin-
ng: A scalable blockchain protocol. In NSDI, pages 45–59, 2016.
[8] Matthias Fitzi, Peter Gaži, Aggelos Kiayias, and Alexander Russell. Parallel
chains: Improving throughput and latency of blockchain protocols via parallel
composition. Cryptology ePrint Archive, Report 1119, 2018.
Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone proto-
col: Analysis and applications. In Annual International Conference on the Theory
and Applications of Cryptographic Techniques, pages 281–310. Springer, 2015.
[10] Dina Katabi, Mark Handley, and Charlie Rohrs. Congestion control for high
bandwidth-delay product networks. ACM SIGCOMM computer communication
review, 32(4):89–102, 2002.
[11] Aggelos Kiayias and Giorgos Panagiotakos. On trees, chains and fast transactions
in the blockchain. 2016.
[12] Lucianna Kiffer, Rajmohan Rajaraman, et al. A better method to analyze
In Proceedings of the 2018 ACM SIGSAC Conference
blockchain consistency.
on Computer and Communications Security, pages 729–744. ACM, 2018.
[13] Eleftherios Kokoris Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus
Gasser, and Bryan Ford. Enhancing bitcoin security and performance with strong
consistency via collective signing. In 25th USENIX Security Symposium, pages
279–296, 2016.
[14] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. Inclusive block chain
protocols. In International Conference on Financial Cryptography and Data Secu-
rity, pages 528–547. Springer, 2015.
[15] Chenxing Li, Peilun Li, Wei Xu, Fan Long, and Andrew Chi-chih Yao. Scaling
nakamoto consensus to thousands of transactions per second. arXiv preprint
arXiv:1805.03870, 2018.
[16] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.
[17] Christopher Natoli and Vincent Gramoli. The balance attack against proof-of-
work blockchains: The r3 testbed as an example. arXiv preprint arXiv:1612.09426,
2016.
[18] R Pass, L Seeman, and A Shelat. Analysis of the blockchain protocol in asynchro-
nous networks. In Annual International Conference on the Theory and Applications
of Cryptographic Techniques, 2017.
[19] R. Pass and E. Shi. Fruitchains: A fair blockchain. In Proceedings of the ACM
Symposium on Principles of Distributed Computing. ACM, 2017.
[20] Rafael Pass and Elaine Shi. Hybrid consensus: Efficient consensus in the permis-
sionless model. In LIPIcs-Leibniz International Proceedings in Informatics. Schloss
Dagstuhl-Leibniz-Zentrum fuer Informatik, 2017.
[21] Rafael Pass and Elaine Shi. Thunderella: Blockchains with optimistic instant
confirmation. In Annual International Conference on the Theory and Applications
of Cryptographic Techniques. Springer, 2018.
[22] Peter R Rizun. Subchains: A technique to scale bitcoin and improve the user
[23] Y Sompolinsky, Y Lewenberg, and A Zohar. Spectre: A fast and scalable cryp-
experience. Ledger, 1:38–52, 2016.
tocurrency protocol. IACR Cryptology ePrint Archive, 2016:1159.
[24] Y Sompolinsky and A Zohar. Phantom: A scalable blockdag protocol, 2018.
[25] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in
bitcoin. In International Conference on Financial Cryptography and Data Security,
pages 507–527. Springer, 2015.
[26] TierNolan. Decoupling transactions and pow. Bitcoin Forum. https://bitcointalk.
org/index.php?topic=179598.0.
[27] Haifeng Yu, Ivica Nikolic, Ruomu Hou, and Prateek Saxena. OHIE: blockchain
scaling made simple. CoRR, abs/1811.12628, 2018.
14
15
header, Ppf , Cpf = PowMining()
// Block contains header, parent, content and merkle proofs
if header is a tx block then
else if header is a prop block then
else if header is a block in voter blocktree i then
BroadcastMessage(block)
block ← ⟨header, tx Par ent, tx Pool, Ppf , Cpf ⟩
block ← ⟨header, prpPar ent, unRf T x BkPool, Ppf , Cpf ⟩
block ← ⟨header, vt Par ent[i], votesOnPrpBks[i], Ppf , Cpf ⟩
▷ Broadcast to peers
▷ All variables are global
▷ Proposer Blocktree
▷ Voter i blocktree
▷ Proposer block to mine on
▷ Voter tree i block to mine on
▷ Tx block content: Txs to add in tx bks
▷ Prop bk content1: Unreferred tx bks
▷ Prop bk content2: Unreferred prp bks
▷ Voter tree i bkbk content
▷ Voter block mined
▷ on tree i
▷ Tx block mined
▷ Prop block mined
▷ Get block from peers
16
▷ Add vote on level ℓ on all m trees
A PSEUDOCODE
Initialize()
while True do
Algorithm 1 Prism: Mining
1: procedure Main( )
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13: procedure Initialize( )
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28: procedure PowMining( )
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
while True do
48:
49:
50: procedure ReceiveBlock(B)
51:
52:
53:
54:
55:
56:
57:
58:
59:
60:
61:
62:
63:
64:
65:
66:
67:
68:
69: procedure ReceiveTx(tx)
70:
prpPar ent ← B
for i ← 1 to m do
vtT r ee[i] ← дenesisM_i
// Blockchain data structure C = (prpT r ee, vtT r ee)
prpT r ee ← дenesisP
for i ← 1 to m do
// Parent blocks to mine on
prpPar ent ← дenesisP
for i ← 1 to m do
// Block content
tx Pool ← ϕ
unRf T x BkPool ← ϕ
unRf PrpBkPool ← ϕ
for i ← 1 to m do
vt Par ent[i] ← дenesisM_i
votesOnPrpBks(i) ← ϕ
tx Par ent ← prpPar ent
// Assign content for all block types/trees
for i ← 1 to m do vtContent[i] ← votesOnPrpBks[i]
txContent ← tx Pool
prContent ← (unRf T x BkPool, unRf PrpBkPool)
// Define parents and content Merkle trees
par ent MT ←MerklTree(vt Par ent, tx Par ent, prpPar ent)
content MT ←MerklTree(vtContent, txContent, prContent)
nonce ← RandomString(1κ )
// Header is similar to Bitcoin
header ← ⟨ par ent MT .root, content MT .root, nonce ⟩
// Sortition into different block types/trees
if Hash(header) ≤ mfv then
else if mfv  vt Par ent[i].chainlen then
vt Par ent[i] ← B and votesOnPrpBks(i).update(B)
else if B is a valid prop block then
if B.level == prpPar ent.level+1 then
votesOnPrpBks(i)[B.level] ← B
else if B.level > prpPar ent.level+1 then
// Miner doesnt have block at level prpPar ent.level+1
ReqestNetwork(B.parent)
prpT r ee[B.level].append(B), unRf PrpBkPool.append(B)
unRf T x BkPool.removeTxBkRefsFrom(B)
unRf PrpBkPool.removePrpBkRefsFrom(B) ‘
if tx has valid signature then tx Pool.append(B)
Π ← ϕ
for ℓ ← 1 to prpT r ee .maxLevel do
Algorithm 2 Prism: Tx confirmation
1: procedure IsTxConfirmed(tx)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
votes N depth ← ϕ
for i in 1 to m do
votes N depth[i] ← GetVoteNDepth(i, ℓ)
if IsPropSetConfirmed(votes N depth) then
Π[ℓ] ← GetProposerSet(votes N depth)
else break
// Ledger list decoding: Check if tx is confirmed in all ledgers
prpBksSeqs ← Π[1] × Π[2] × · · · × Π[ℓ]
for prpBks in prpBksSeqs do
ledдer = BuildLedger(prpBks)
if tx is not confirmed in ledдer then return False
return True
for prpBk in voter Bk.votes do
ledдer ← []