结果不再令人激动。
图 28-52和图 28-53 说明引用只是帮助编程人员更方便书写代码，而底层
还是通过指针来实现，图 28-52 中传递的并不是n 的值，而是它的地址，这就
和使用指针那个例子是一样的。
图 28-53中 sumar 函数的内容和使用指针时是完全一样的，对指针的指向
的内容+1。
429
从零开始学IDA逆向 28 指针和引用
图28-52 通过IDA查看
图28-53 sumar函数
所以引用类型对于编程非常的方便，但是在逆向这种底层工作中还是必须要
和指针打交道。
430
从零开始学IDA逆向 29 程序漏洞实战
29 程序漏洞实战
根据读者目前所学已经可以开始分析一些实际的程序了。作者在这里留下一
份练习，也会在下一章进行解决。作者希望读者从中寻找到乐趣，如果有什么发
现也可以和作者讨论。
在练习中作者提供了2 个连续版本的程序，所以通过文件比对和分析能够找
出新版中的补丁。希望读者按照之前章节中的方式进行文件比对，判断是否存在
溢出可能，然后将结果发送给作者。当然也没有必要编写代码，找到存在漏洞的
函数就行。
附件包含了旧版和新版的安装文件。最好是在虚拟机中安装一个版本后做一
份快照，再安装另一个版本做另一份快照，然后再提取文件进行比对。
这个练习只是用来增加点乐趣。能否正确完成并没有关系。
通过查询漏洞信息库（CVE，Common Vulnerabilities and Exposures）
可以获取一些帮助。
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-465
4
漏洞存在于VLC直至 0.94 版打开扩展名为.ty 的文件时。
431
从零开始学IDA逆向 30 程序漏洞实战分析
30 程序漏洞实战分析
30.1 文件比对
本章主要解决上一章的练习。通过文件比对工具对 VLC 两个连续版本的文
件进行对比，以及查询 CVE 来获取相关的信息。这就是目前读者掌握的大部分
信息。
在虚拟机安装这两个版本之后，作者通过 CVE 网站查询漏洞线索，避免进
行一些无用的比对。
图30-1 漏洞信息
然后转到 VLC 安装目录，处理各种扩展名媒体的插件都在 plugins 文件夹
中。
432
从零开始学IDA逆向 30 程序漏洞实战分析
图30-2 plugins文件夹
检查文件名称，确认是否存在处理TIVO 或者 TY 格式媒体的插件。
图30-3 libty_plugin.dll
libty_plugin.dll 这个文件的可能性比较大。那么对它进行比对。
图30-4 libty_plugin.dll比对结果
图 30-4中可以看出 4 个函数发生了改动。一般来说都是先大致观察一下，
在最有可能的地方进行标记，之后再对这些地方进行深入得逆向分析。
433
从零开始学IDA逆向 30 程序漏洞实战分析
图30-5 第4组函数变动1
寻找的目标是一个防止栈溢出的补丁。首先来看第4 组，图 30-5中这个有
变动的函数。看上去好像阻止不了任何事情。只是将一个地址传入ESI。这里应
该不存在任何问题。
图30-6 第4组函数变动2
接下来的改动只是一个顺序上的改变，并没有什么影响。在含漏洞版本中，
程序将这个地址保存到ESI，然后再传入var_1b4，而在修复版中这个地址被传
入ECX，再保存到 var_1b4，其他也没什么了。
在第3 组中，也是一样的。虽然有一些变动，但有时只有用另一种方式实现
同样的效果，或者说同样的内容只是改变了顺序，这些并不会影响任何事情。
图30-7 第3组函数变动1
图 30-8中 var_70 的计算方式在两个版本中有改动。但是函数的其它位置
也没有对这个变量进行读取或者使用，而且作为一个局部变量，也没有作为参数
434
从零开始学IDA逆向 30 程序漏洞实战分析
传递使用，或者进行比较。可能需要略微关注一下，但并不是重点。
图30-8 var_70
这组函数就没有别的什么内容了，应该不在考虑范围内。只能接着浏览后面
的内容。
图30-9 第2组函数比对
接下俩第2 组看上去比较混乱。尝试着稍微修复一下。在不匹配的块上右键
单击选择delete matches，然后再标记可能匹配的块，选择add basic bloc
435
从零开始学IDA逆向 30 程序漏洞实战分析
k match。如果匹配度很差的话，这些块看上去会差很多，但是如果匹配度高的
话，作者现在觉得它们看上去是一样的，只是图面有点糟糕。
有时候有些函数看上去非常的不对齐，建议使用 Turbodiff，至少会稍微
对齐一点。
图30-10 Turbodiff
查看block ID 核对一下。
图30-11 局部变量
图 30-11 中虽然变量名不太一样，但是内部距离是一样的（68 对 6c，新
版本中是60 对64）。而且比较是否考虑符号也没变（例如 JB改成考虑符号的 J
L，或者其他）。而且如果JA 改成了 JB，跳转的目标也同时更改的话，其实就是
一样的。没有任何改变。
436
从零开始学IDA逆向 30 程序漏洞实战分析
接着看下面的内容。
图30-12 第2组函数比对3
图 30-12 中大概看上去都差不多，跳转指令也没有变。只是些细微的变动。
图30-13 第2组函数比对4
图 30-13中有一些旧版本中没有的比较，而 EDI 在下面就被覆盖了，这应
该是个switch…case 语句。将这部分标记起来，尽管还未发现溢出的可能性。
图 30-14右侧的 jb 指令处有一些改动，如果没有其他发现的话，这里可以
进一步研究。在旧版本中这个jb 指令在偏下一点，如图 30-15。
目前并没有深入进行逆向分析，仍然是在寻找一些值得注意的地方。图 30
-16中的位置可能性比较大，这里对一个结构体的字段进行了比较，而且旧版本
使用了JLE，新版本是 JBE，比较是否考虑符号发生了变化。这里有可能是导致
溢出的位置。
437
从零开始学IDA逆向 30 程序漏洞实战分析
图30-14 jb指令
图30-15 旧版jb指令
图30-16 jle和jbe
这是个非常复杂的函数，稍后再分析。目前已经找到一处非常有可能的结果。
先标记下来，再把最后一组函数游览完。
图 30-17 中又出现结构体的同一字段，而且更容易发现。
这里有一处循环，决定跳出的是一个计数器也就是 var_48，它在递增后会
438
从零开始学IDA逆向 30 程序漏洞实战分析
和一个最大值进行比较。
图30-17 第1组函数对比
图30-18 计数器
在进入循环前，计数器归零。作者觉得这个函数比之前那个分析起来简单，
可能两个地方都有问题，还是先从简单的地方入手。
30.2 创建结构体和字段
这个函数看上去比较复杂，刚开始的时候需要耐心一点。首先将 var_48 重
命名为contador，翻译成英文就是 counter。
439
从零开始学IDA逆向 30 程序漏洞实战分析
图30-19 重命名var_48为contador
图30-20 ebp与结构体
图 30-20中显然 EBP 就是结构体的起始地址，在这个函数的绝大部分都有
这种形式，以EBP为基址，然后加上 XXXX，也就是是字段偏移。
图30-21 赋值EBP
EBP的赋值如图 30-21。
从0x61401BBE 起 EBP 就是结构体的地址，直到 0x6140203E，如图 30-2
2，该指令中对EBP 重新赋值，也就是说，在这两者之间，EBP 都是结构体的地
址。
440
从零开始学IDA逆向 30 程序漏洞实战分析
图30-22 EBP重新赋值
这是个非常大的结构体，从这些 0xbexx 偏移的字段就能看出来。那么下面
来定义它。作者发现大部分的字段偏移都是 0xbexx，所以可以构建一个0xbf0
0 大小的结构体，至少能涵盖目前发现的字段。如果需要调整结构体的大小，后
面还有机会。
打开结构体选项卡，按INSERT 创建一个结构体。
图30-23 创建结构体
图30-24 创建结构体2
441
从零开始学IDA逆向 30 程序漏洞实战分析
在结尾ends 单词处按 D 键，添加一个单字节的字段。
图30-25 添加字段
在该字段处右键单击选择EXPAND STRUCT TYPE，然后再增加0xBF00字节，
最终如图 30-27。
图30-26 扩展结构体
图30-27 扩展结构体2
442
从零开始学IDA逆向 30 程序漏洞实战分析
图30-28 0x0BEC8字段
如图 30-28，显然如果 0x0BEC8 字段是个负数，例如 0xFFFFFFFF，如果
考虑符号，它肯定会比计数器中的正数（1、2 或者其他）要小，所以这个循环
会比设想的要多执行很多次。
按T 键选择按照结构体字段显示。
由于这个字段代表了退出循环前执行的最大次数，所以作者打算将该字段命
名为MAXIMO。
转到该结构体0x0BEC8 偏移处创建一个DWORD 字段。
图30-29 0x0BEC8偏移
按D 键直到显示类型为dd，如图 30-30。
图30-30 创建DWORD字段
然后将其重命名为MAXIMO。
443
从零开始学IDA逆向 30 程序漏洞实战分析
图30-31 定义字段类型
根据JLE跳转指令能够判断出它是个带符号整数，按 Y 键输入数据类型。
图30-32 MAXIMO字段
现在看上去好多了，虽然定义为signed int 类型，但实际并没有什么影响，
除非使用Hex Rays 反编译器。不过作者不打算现在使用，还是先把其他内容搞
清楚。
继续研究。
30.3 malloc和 calloc 函数
图30-33 malloc函数
作者发现一处调用malloc函数，这个函数常用于动态申请一个缓存区空间，
该空间不在函数栈上，而是在其他内存空间中。这个函数的参数就是申请空间的
444
从零开始学IDA逆向 30 程序漏洞实战分析
大小。当然这里程序使用了之前章节中出现过的一种形式传递参数，而不是直接
使用push 指令。通过右键单击选择显示方式就能解决这个问题。
图30-34 malloc函数
图30-35 EAX
图 30-35 中 size 参数最终通过 EAX 传递，这个值是通过之前的一些运算
获取的。
如图 30-36，通过这 4 个单字节变量计算 size，而且在传给 malloc 函数
前执行了SHL EAX, 4指令。
445
从零开始学IDA逆向 30 程序漏洞实战分析
图30-36 4个单字节变量
图30-37 shl指令
SHL EAX, 4 指令相当于 EAX * 16。而且在执行 SHL 指令之前EAX 的值存
入了MAXIMO 字段。按T 键显示结构体字段就能发现这一点。
图30-38 EAX的值存入了MAXIMO字段
如图 30-39，接下来的指令会排除 MAXIMO 字段中的负数。
所以问题就不是MAXIMO 是一个负数造成的，因为负数已经通过 TEST 指令
排除了。
而在修复版的函数中，程序没有执行 SHL 指令，也没有对 EAX 的值直接乘
446
从零开始学IDA逆向 30 程序漏洞实战分析
以16，而是调用了calloc函数。
图30-39 排除负数
图30-40 calloc函数
图30-41 修复版函数
447
从零开始学IDA逆向 30 程序漏洞实战分析
在修复版中并没有在calloc 函数外面乘以16，而是在 calloc 函数传参时
传入元素的数量和每个元素的长度0x10，那么实际上通过API 来完成元素数量
和元素大小的相乘。
MALLOC 以及 CALLOC 函数主要用于申请内存，返回的地址是会变化的。函
数不会总是返回同一地址上的空间。在之后教程会介绍研究堆（heap）以及如
何申请内存。目前读者需要了解的是函数会返回一个用户申请大小的内存空间就
行。
30.4 malloc参数漏洞分析
所以在旧版中，通过 EAX 的值（后面赋值给 MAXIMO）乘以 16 计算出申请