[*] Trying username TESTING 0.0 seconds..
[*] Trying username HAH 0.0 seconds..
[*] Trying username HO 0.0 seconds..
Figure 18: Time-based username brute-force tool
11
Since Bob is logged in, his iframe loads his LinkedIn
start page, informing him of new connections, updates
on friends, and the variety of other notiﬁcations pro-
vided on a social networking site, which causes a rela-
tively long load time of (say) 300ms.
Carol also visits Alice’s page and she too has her
LinkedIn proﬁle loaded in an invisible iframe. However,
since Carol is not logged into LinkedIn her malicious
iframe is simply redirected to a tiny page that reads
‘Please Login’. Her iframe completes loading in (say)
50ms.
Both scripts compute the time taken for the page to
load and promptly report back to Alice who is able to
deduce that while Bob is logged in, Carol is not.
The attackers challenge in such a situation (inline
with most remote timing attacks) is the uncertain line
latency that could aﬀect either Carol or Bob. If Alice
simplistically decided that any user who reported a load
time greater 200ms as logged in, then she would receive
a false positive when Dean logged in from a bandwidth-
challenged country like South Africa.
Dean’s iframe
would redirect him to the login screen too, but since he
has high latency on his line his login page takes 400ms
to load and the method would fail.
To overcome this we make use of a second request,
which Bortz referred to as a reference site [13]. The
attack is altered and is described below:
Bob visits Alice’s site, which causes two iframes to
load invisibly in his browser. One of the iframes makes
a request for a static page on the LinkedIn site that
is accessible to both members and non-members. (We
call this the base page.) The second iframe attempts
to access a page only available to members (we call this
the login page). By timing both page loads we are able
to obtain a value of load time relative to both requests.
I.e. irrespective of how slow the victim’s line is, if he
is logged in to LinkedIn his login page always loads 1.5
times longer than the time it takes for the base page to
load. Based on this ratio, Alice is now able to determine
with a high degree of certainty whether a visitor to her
site is indeed logged into LinkedIn or not.
This is demonstrated using a tiny piece of script and
a local South African Freemail service. The victim visits
a site under the attacker.s control (https://secure-
.sensepost.com/mH/time-mailbox.html).
The site-
loads four iframes: Iframe1 is used for demo feedback,
Iframe2 (tiny) is used to communicate with the at-
tacker, Iframe3 and iframe4 are the base page and lo-
gin page respectively (all four iframes are shown in Fig-
ure 19). The code on the attacker.s page does the fol-
lowing:
• Fetch the base page (default webmail login screen)
• Fetch the login page (the inbox page available to
members)
• If this is the ﬁrst load then refresh this page (this
is done to ensure that cached pages do not aﬀect
load times)
• Fetch the base page (default webmail login screen)
• Fetch the login page (the inbox page available to
members)
If the user is currently not logged in, the login page (In-
box page) will load in almost the same amount of time
as the base page (since it is tiny – and simply tells the
user he has not logged in.) This is shown in Figure 20.
If the user is, however, logged in, his Inbox takes much
longer to load (relative to the base page) allowing the
script to deduce that the user is indeed logged in to his
mailbox account, as depicted in Figure 21. If the user
is logged into webmail, his inbox takes much longer to
load (relative to the base page) allowing the script to
deduce that the user is indeed logged in to his mailbox
account.
During the loading of this attack page, the second
(tiny) iframe was used to pass timing information back
to the attacker’s webserver, revealing the following line
in the attacker’s server logs, indicating that the user is
logged in:
box.victim.com - - [30/Jun/2007:01:04:05
+0200] "GET /mH/timing/User is LoggedIn-
=1.283093960892888 HTTP/1.1"
7
Combining Cross-Site Timing
and Traditional Web Applica-
tion Timing Attacks
In Section 6 we showed an attacker is able to determine
the load time of a page from a client’s point of view
with relative ease and, since we have previously demon-
strated the ability to time the loading of a web page, an
attacker should be able to use a victim to launch brute
force attacks against a site that leaks information via
timing.
To demonstrate this we conducted the following ex-
periment.
http://bank.sensepost.com was created
with a login page that allows an attacker to enumer-
ate valid logins through timing. A failed login attempt
on a valid user account took 1ms longer than a failed
login attempt on an account that does not exist. The
malicious site hosting the JavaScript was http://ali-
ce.sensepost.com; a synopsis of the code is given in
Figure 22. In this example, the browser’s activities were
instrumented, eﬀectively allowing the victim to see all
of the activity going on in his browser. Note that for
every login attempt, two iframes are created in order
for us to obtain the time of the form submission and
the base page.
The result is that when Bob decodes to visit Al-
ice’s page (http://alice.sensepost.com), JavaScript
loads the iframes. Bob’s browser continues to try all of
the names in the user-list until it determines (through
timing) that a valid username is found. The script then
reports back to Alice that a username has been found.
12
Figure 19: Cross-site timing iframes setup
Figure 20: Cross-site timing iframes: user is logged out
Figure 21: Cross-site timing iframes: user is logged in
for eachusername:
Create iframe for base page (base time is how long it takes to load)
Create iframe for login page (login time is how long it takes to load)
if (ratio of base time to login time indicates a valid user)
{
print on screen Valid User //Clearly only for debugging
direct another hidden iframe to report valid user to attacker
(alice.sensepost.com)
}
Figure 22: Browser-based brute-force timing synopsis
13
Figure 23: Visible iframes showing browser-base brute-force timing attack
14
A screenshot of the attack is shown in Figure 23, ob-
serve the instrumented iframe in the top left, indicating
which usernames appear valid.
The implications of this attack are clear: by simply
browsing to Alice’s site, Bob’s browser has been turned
into a bot capable of brute-forcing http://bank.sense-
post.com and reporting back to Alice with the results.
Due to the reﬂected nature of the attack, the bank
cannot identify Alice without examining the malicious
script or Bob’s machine.
During this round of testing one additional compli-
cation was discovered.
The Date() function in Java-
Script returns its time in milliseconds which is some-
times not suﬃciently granular. Since any timer lacks
the ability to detect time diﬀerences that fall below
its clock resolution and requests over networks conceiv-
ably take less than a millisecond, another solution was
required to provide timing information. In 2003, Kin-
dermann [19] documented how many modern browsers
allow one to call Java classes from within JavaScript
code. Both Grossman [20] and pdp Architect [21] made
use of this technique to obtain a browser’s actual IP
Address.
Using this same technique, it was possible to make
use of the nanoTime() method within the standard
java.lang.System class to provide a timer that returns
time to the nearest nanosecond instead of millisecond.
This resolution was suﬃcient for our testing.
In compiling this paper, we tested Cross Site Re-
quest Attacks against sites vulnerable to timing attacks
using GET requests. However, we are fairly conﬁdent
that this technique can be trivially extended to attack
forms that require POST requests too, by populating
the form using JavaScript and then calling the docu-
ment.form.submit() function.
Of far more interest is
the ability to insert arbitrary headers into the user’s
request. This is an area of ongoing research and the
authors believe eﬀorts in this area will bear fruit (with-
out the use of additional technologies such as Flash).
8
Distributed Cross-Site Request
Timing
In the previous section, an attack by Alice against a
bank was reﬂected through innocent Bob.
Consider
cloning Bob hundreds or even thousands of times; Al-
ice’s site is indeed that popular. Now, Alice gets smart
and doesn’t hand out the same username lists to ev-
ery reﬂector; she divides her list and distributes a part
to each victim. In eﬀect, Alice is in control of a dis-
tributed brute-force tool focused in a single site.
6 If
the session ID of the site is passed as a request param-
eter instead of storied in a cookie, it becomes a target
for distributed brute-forcing (although we concede that
6Thoughts of a Distributed Denial-of-Service attack launched
from unknowing browsers will not be pondered further in this
paper.
the likelihood of ’striking it rich’ is vanishingly small
for a decent session ID keyspace.) However, login page
attacks such as those described in Section 5 are cer-
tainly viable. Where the session ID keyspace is small,
the following attack should be successful.
The attacker examines the site and determines the
following:
• base page: https://secure.bank.com/login/-
login.asp (load time 5ms)
• login page: https://secure.bank.com/balance/-
/all-accounts (load time 50ms if
session-id is valid)
• login page: https://secure.bank.com/balance/-
/all-accounts (load time 6ms if
session-id is invalid (returns to login-page))
(The load time delta noted above will be entirely common-
place on most sites today as demonstrated earlier.)
The attacker now places his malicious script on a
popular forum, or embeds it within a popular page
where he hopes to provoke the ‘Slashdot eﬀect’, where
a site is deluged with requests because it was to linked
to, from Slashdot. According to rough estimates, the
Slashdot eﬀect seems to result in about 200 hits per
minute when the eﬀect is at its peak. Using a slight vari-
ation on the attack described above (alice.sensepost.com,
bob.sensepost.com and bank.sensepost.com) we ﬁnd that
an attacker’s site is able to hand oﬀ requests to every
client who visits his page eﬀectively making each of the
clients / visitors to his site a drone bruteforcing session-
ids on the target (bank.com).
The attacker would then wait, until one (or several)
of his victims reported a session ID with a load time
that indicated a valid session. The attacker would then
be able to brute-force the session ID space in a relatively
short space of time at a low relative cost time him or
her.
9
Conclusion
Timing as a method of attack has been part of the hack-
ers toolkit for many years.
Recently trends indicate
that targets for timing attacks are moving away from
solely crypt-analytic, towards other breaches of security
such as privacy invasion. In this paper, we examined
a brief history of timing attacks, and provided back-
ground on the two important timing papers in the ﬁeld
of web applications.
With this as a basis, an exploration of timing attacks
and the Web commenced. Starting with Perl regular ex-
pression insertion, we showed how basic timing attacks
might be conducted in web applications. The next tar-
get was SQL Server, where we showed how to replace
DNS tunnels with timing channels when extracting ei-
ther command execution output or data.
15
Moving to recent attack vectors, a real-world sce-
nario was described where timing diﬀerences in a sys-
tem that used crypto devices were obvious enough to
enumerate users. Cross-site timing was explained and
explored, and a proof-of-concept reﬂected brute-force
client was developed that used high-resolution timers to
accurately brute-force sites. Finally, we discussed the
possibility of building distributed attacks using cross-
site timing.
The Cross-Site ﬁeld is rapidly expanding as new at-
tack vectors are discovered and ﬂeshed out.
Timing
is an emerging threat in this arena and the diﬃculties
faced by developers in addressing the issue make it likely
that an increase in timing vulnerabilities will be seen.
References
[1] Jean-Francois Dhem, Francois Koeune, Philippe-
Alexandre Leroux, Patrick Mestr´e;, Jean-Jacques
Quisquater, and Jean-Louis Willems.
A prac-
tical implementation of the timing attack.
In
CARDIS ’98: Proceedings of the The International
Conference on Smart Card Research and Applica-
tions, pages 167–182, London, UK, 2000. Springer-
Verlag.
[2] Paul C. Kocher. Timing attacks on implementa-
tions of diﬃe-hellman, rsa, dss, and other systems.
In CRYPTO ’96: Proceedings of the 16th Annual
International Cryptology Conference on Advances
in Cryptology, pages 104–113, London, UK, 1996.
Springer-Verlag.
[3] David Brumley and Dan Boneh. Remote timing
attacks are practical. In Proceedings of the 12th
USENIX Security Symposium, August 2003.
[4] Whitﬁeld Diﬃe and Martin E. Hellman. New di-
rections in cryptography. IEEE Transactions on
Information Theory, IT-22(6):644–654, November
1976.
[5] R. L. Rivest, A. Shamir, and L. Adleman.
A
method for obtaining digital signatures and public-
key cryptosystems. Commun. ACM, 26(1):96–99,
1983.
[6] Colin Percival. Cache missing for fun and proﬁt.
2005.
[7] OpenSSL: The Open Source toolkit for SSL/TLS.
[8] Daniel J. Bernstein. Cache-timing attacks on AES,
2004.
[9] Edward W. Felten and Michael A. Schneider. Tim-
ing attacks on web privacy. In CCS ’00: Proceed-
ings of the 7th ACM conference on Computer and
communications security, pages 25–32, New York,
NY, USA, 2000. ACM Press.
[10] J. Grossman and T. Niedzialkowski. Hacking in-
tranets from the outside: Javascript malware just
got a lot more dangerous. August 2006.
[11] SPI Labs. Detecting, analyzing, and exploiting in-
tranet applications using javascript. August 2006.
[12] Mozilla
Project.
The
same
origin
policy.
http://www.mozilla.org/projects/security/
components/same-origin.html.
[13] Andrew Bortz, Dan Boneh, and Palash Nandy. Ex-
posing private information by timing web applica-
tions. In WWW ’07: Proceedings of the 16th in-
ternational conference on World Wide Web, pages
621–628, New York, NY, USA, 2007. ACM Press.
[14] Chris
Anley.
Advanced
sql
in-
jection
in
sql
server
applications.
http://www.ngssoftware.com/papers/
advanced sql injection.pdf.
[15] Cesar
Cerrudo.
Datathief.
http://www.argeniss.com/research/
HackingDatabases.zip.
[16] Sec-1.
Automagic
sql
injector.
http://scoobygang.org/automagic.zip.
[17] nummish
and
Xeron.
Absinthe.
http://www.0x90.org/releases/absinthe/.
[18] icesurfer.
sqlninja.
http://sqlninja.sourceforge.net/.
[19] Lars
Kindermann.
Myaddress
java
applet.
http://reglos.de/myaddress/MyAddress.html.
[20] Jeremiah
Grossman.
Goodbye
applet,
hello
nat’ed
ip
address.
http://jeremiahgrossman.blogspot.com/2007/
01/goodbye-applet-hello-nated-ip-address
.html.
[21] pdp
Architect.
getnetinfo.
http://www.gnucitizen.org/projects/atom
#comment-2571.
16