0x00000040 60 03                      PUSH1 03 
0x00000042 60 31                      PUSH1 31 
0x00000044 56                         JUMP 
Bytecode – Dispatcher (--list)
loc_00000000:
0x00000000 60 60                      PUSH1 60 
0x00000002 60 40                      PUSH1 40 
0x00000004 52                         MSTORE 
0x00000005 60 e0                      PUSH1 e0 
0x00000007 60 02                      PUSH1 02 
0x00000009 0a                         EXP 
0x0000000a 60 00                      PUSH1 00 
0x0000000c 35                         CALLDATALOAD 
0x0000000d 04                         DIV 
0x0000000e 63 06  72  e9  ee
PUSH4 06 72 e9 ee
0x00000013 81                         DUP2 
0x00000014 14                         EQ 
0x00000015 60 24                      PUSH1 24 
0x00000017 57                         JUMPI 
loc_00000018:
0x00000018 80                         DUP1 
0x00000019 63 9d  04  0a  f4          PUSH4 9d 04 0a f4 
0x0000001e 14                         EQ 
0x0000001f 60 35                      PUSH1 35
0x00000021 57                         JUMPI 
loc_00000022:
0x00000022 5b                         JUMPDEST 
0x00000023 00                         STOP
double(uint256):
0x00000024 5b                         JUMPDEST 
0x00000025 60 45                      PUSH1 45 
0x00000027 60 04                      PUSH1 04 
0x00000029 35                         CALLDATALOAD 
0x0000002a 60 00                      PUSH1 00 
0x0000002c 60 4f                      PUSH1 4f 
0x0000002e 82                         DUP3 
0x0000002f 60 02                      PUSH1 02 
loc_00000031:
0x00000031 5b                         JUMPDEST 
0x00000032 02                         MUL 
0x00000033 90                         SWAP1 
0x00000034 56                         JUMP 
triple(uint256):
0x00000035 5b                         JUMPDEST 
0x00000036 60 45                      PUSH1 45 
0x00000038 60 04                      PUSH1 04 
0x0000003a 35                         CALLDATALOAD
0x0000003b 60 00                      PUSH1 00 
0x0000003d 60 4f                      PUSH1 4f 
0x0000003f 82                         DUP3 
0x00000040 60 03                      PUSH1 03 
0x00000042 60 31                      PUSH1 31 
0x00000044 56                         JUMP 
Bytecode – Dispatcher (--list)
loc_00000000:
0x00000000 60 60                      PUSH1 60 
0x00000002 60 40                      PUSH1 40 
0x00000004 52                         MSTORE 
0x00000005 60 e0                      PUSH1 e0 
0x00000007 60 02                      PUSH1 02 
0x00000009 0a                         EXP 
0x0000000a 60 00                      PUSH1 00 
0x0000000c 35                         CALLDATALOAD 
0x0000000d 04                         DIV 
0x0000000e 63 06  72  e9  ee
PUSH4 06 72 e9 ee
0x00000013 81                         DUP2 
0x00000014 14                         EQ 
0x00000015 60 24                      PUSH1 24 
0x00000017 57                         JUMPI 
loc_00000018:
0x00000018 80                         DUP1 
0x00000019 63 9d  04  0a  f4          PUSH4 9d 04 0a f4 
0x0000001e 14                         EQ 
0x0000001f 60 35                      PUSH1 35
0x00000021 57                         JUMPI 
loc_00000022:
0x00000022 5b                         JUMPDEST 
0x00000023 00                         STOP
double(uint256):
0x00000024 5b                         JUMPDEST 
0x00000025 60 45                      PUSH1 45 
0x00000027 60 04                      PUSH1 04 
0x00000029 35                         CALLDATALOAD 
0x0000002a 60 00                      PUSH1 00 
0x0000002c 60 4f                      PUSH1 4f 
0x0000002e 82                         DUP3 
0x0000002f 60 02                      PUSH1 02 
loc_00000031:
0x00000031 5b                         JUMPDEST 
0x00000032 02                         MUL 
0x00000033 90                         SWAP1 
0x00000034 56                         JUMP 
triple(uint256):
0x00000035 5b                         JUMPDEST 
0x00000036 60 45                      PUSH1 45 
0x00000038 60 04                      PUSH1 04 
0x0000003a 35                         CALLDATALOAD
0x0000003b 60 00                      PUSH1 00 
0x0000003d 60 4f                      PUSH1 4f 
0x0000003f 82                         DUP3 
0x00000040 60 03                      PUSH1 03 
0x00000042 60 31                      PUSH1 31 
0x00000044 56
JUMP
Bytecode – Dispatcher (--list)
loc_00000000:
0x00000000 60 60                      PUSH1 60 
0x00000002 60 40                      PUSH1 40 
0x00000004 52                         MSTORE 
0x00000005 60 e0                      PUSH1 e0 
0x00000007 60 02                      PUSH1 02 
0x00000009 0a                         EXP 
0x0000000a 60 00                      PUSH1 00 
0x0000000c 35                         CALLDATALOAD 
0x0000000d 04                         DIV 
0x0000000e 63 06  72  e9  ee
PUSH4 06 72 e9 ee
0x00000013 81                         DUP2 
0x00000014 14                         EQ 
0x00000015 60 24                      PUSH1 24 
0x00000017 57                         JUMPI 
loc_00000018:
0x00000018 80                         DUP1 
0x00000019 63 9d  04  0a  f4          PUSH4 9d 04 0a f4 
0x0000001e 14                         EQ 
0x0000001f 60 35                      PUSH1 35
0x00000021 57                         JUMPI 
loc_00000022:
0x00000022 5b                         JUMPDEST 
0x00000023 00                         STOP
double(uint256):
0x00000024 5b                         JUMPDEST 
0x00000025 60 45                      PUSH1 45 
0x00000027 60 04                      PUSH1 04 
0x00000029 35                         CALLDATALOAD 
0x0000002a 60 00                      PUSH1 00 
0x0000002c 60 4f                      PUSH1 4f 
0x0000002e 82                         DUP3 
0x0000002f 60 02                      PUSH1 02 
loc_00000031:
0x00000031 5b                         JUMPDEST 
0x00000032 02
MUL
0x00000033 90                         SWAP1 
0x00000034 56                         JUMP 
triple(uint256):
0x00000035 5b                         JUMPDEST 
0x00000036 60 45                      PUSH1 45 
0x00000038 60 04                      PUSH1 04 
0x0000003a 35                         CALLDATALOAD
0x0000003b 60 00                      PUSH1 00 
0x0000003d 60 4f                      PUSH1 4f 
0x0000003f 82                         DUP3 
0x00000040 60 03                      PUSH1 03 
0x00000042 60 31                      PUSH1 31 
0x00000044 56                         JUMP
DELEGATECALL & $30M Parity Bug
contract Wallet {
address _walletLibrary;
address owner;
// initWallet() is only invoked by the constructor. WalletLibrary is hardcoded.
function Wallet(address _owner) {
_walletLibrary = 0xa657491c1e7f16adb39b9b60e87bbb8d93988bc3;
_walletLibrary.delegatecall(bytes4(sha3("initWallet(address)")), _owner);
}
(…)
// fallback function behaves like a “generic forward” (WTF?)
// Wallet.initWallet(attacker) becomes walletLibrary.initWallet(attacker)
function () payable {
_walletLibrary.delegatecall(msg.data);
}
}
Abusing the dispatcher to reinitialize a wallet?
Generic-Forward & Fall back functions
 Typical issue introduce by the lack of upgradeability of smart-
contract
 Software engineering is hard enough, but smart-contracts need to 
be:
 Backward-Compatible
 Forward-Compatible
 Does not help to make the language verifiable.
 Fall back functions are undefined behaviors.
 Imagine if your kernel would behave like that.
 Scary, right ? Now, imagine if that’s your bank…
Fixing the initialization bug
- function initMultiowned(address[] _owners, uint _required) {
+ function initMultiowned(address[] _owners, uint _required) internal {
- function initDaylimit(uint _limit) {
+ function initDaylimit(uint _limit) internal {
+ modifier only_uninitialized { if (m_numOwners > 0) throw; _; }
- function initWallet(address[] _owners, uint _required, uint _daylimit) {
+ function initWallet(address[] _owners, uint _required, uint _daylimit) 
only_uninitialized {
Code Analysis – Vulnerable Contract
contract SendBalance {
mapping ( address => uint ) userBalances ;
bool withdrawn = false ;
function getBalance (address u) constant returns ( uint ){
return userBalances [u];
}
function addToBalance () {
userBalances[msg.sender] += msg.value ;
}
function withdrawBalance (){
if (!(msg.sender.call.value(
userBalances [msg.sender])())) { throw ; }
userBalances [msg.sender] = 0;
}
}
Code Analysis – Vulnerable Contract
contract SendBalance {
mapping ( address => uint ) userBalances ;
bool withdrawn = false ;
function getBalance (address u) constant returns ( uint ){
return userBalances [u];
}
function addToBalance () {
userBalances[msg.sender] += msg.value ;
}
function withdrawBalance (){
if (!(msg.sender.call.value(
userBalances [msg.sender])())) { throw ; }
userBalances [msg.sender] = 0;
}
}
Caller contract can recall this function 
using its fallback function
Understanding the control flow
 In the case of reentrant vulnerability, since we can 
record the EVM state at each instruction using 
porosity.
 We can track in which basic block SSTORE
instructions are called.
 userBalances [msg.sender] = 0;
 And track states for each basic block.
.\demo.ps1
$porosity = 'E:\projects\porosity\Debug\porosity.exe'
$abi = 
'[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"ty
pe\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addToBalance\",\"out
puts\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"u\",\"ty
pe\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"ui
nt256\"}],\"type\":\"function\"}]'
$code = 
'60606040526000357c01000000000000000000000000000000000000000000000000000000009004806
35fd8c7101461004f578063c0e317fb1461005e578063f8b2cb4f1461006d5761004d565b005b61005c6
004805050610099565b005b61006b600480505061013e565b005b6100836004808035906020019091905
05061017d565b6040518082815260200191505060405180910390f35b3373fffffffffffffffffffffff
fffffffffffffffff16611111600060005060003373ffffffffffffffffffffffffffffffffffffffff1
6815260200190815260200160002060005054604051809050600060405180830381858888f1935050505
0151561010657610002565b6000600060005060003373fffffffffffffffffffffffffffffffffffffff
f168152602001908152602001600020600050819055505b565b34600060005060003373fffffffffffff
fffffffffffffffffffffffffff168152602001908152602001600020600082828250540192505081905
5505b565b6000600060005060008373ffffffffffffffffffffffffffffffffffffffff1681526020019
081526020016000206000505490506101b6565b91905056’
& $porosity --abi $abi --runtime-code $code --decompile --verbose 0
Known class of bugs
 Reentrant Vulnerabilities / Race Condition
 Famously known because of the $50M USD DAO hack (2016) [8]
 Call Stack Vulnerabilities
 Got 1024 frames but a bug ain’t one – c.f. Least Authority [12]
 Time Dependency Vulnerabilities
 @mhswende blogposts are generally awesome, particularly the roulette 
one [10]
 Unconditional DELEGATECALL
Porosity + Quorum =  WASM is already a thing
 https://mbebenita.github.io/WasmExplorer/
 And a similar thing is planned for eWASM
Acknowledgements
 Mohamed Saher
 Halvar Flake
 DEFCON Review Board Team
 Max Vorobjov & Andrey Bazhan
 Martin H. Swende
 Gavin Wood
 Andreas Olofsson
References
[1] Woods, Gavin. "Ethereum: A Secure Decentralised Generalised Transaction Ledger." Web. https://github.com/ethereum/yellowpaper.pdf
[2] Olofsson, Andreas. "Solidity Workshop." Web. https://github.com/androlo/solidity-workshop
[3] Olofsson, Andreas. "Solidity Contracts." Web. https://github.com/androlo/standard-contracts
[4] Velner, Yarn, Jason Teutsch, and Loi Luu. "Smart Contracts Make Bitcoin Mining Pools Vulnerable." Web. https://eprint.iacr.org/2017/230.pdf
[5] Luu, Loi, Duc-Hiep Chu, Hrishi Olickel, Aquinas Hobor. "Making Smart Contracts Smarter." Web. 
https://www.comp.nus.edu.sg/%7Ehobor/Publications/2016/Making%20Smart%20Contracts%20Smarter.pdf
[6] Atzei, Nicola, Massimo Bartoletti, and Tiziana Cimoli. " A Survey of Attacks on Ethereum Smart Contracts." Web. 
https://eprint.iacr.org/2016/1007.pdf
[7] Sarkar, Abhiroop. "Understanding the Transactional Nature of Smart-Contracts." Web. https://abhiroop.github.io/Exceptions-and-Transactions
[8] Siegel, David. "Understanding The DAO Attack." Web. http://www.coindesk.com/understanding-dao-hack-journalists
[9] Blockchain software for asset management. "OYENTE: An Analysis Tool for Smart Contracts." Web. https://github.com/melonproject/oyente
[10] Holst Swende, Martin. “Breaking the house.“ Web. http://martin.swende.se/blog/Breaking_the_house.html
[11] Buterin, Vitalik. "Thinking About Smart Contract Security.“Web. https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security
[12] Least Authority. "Gas Economics: Call Stack Depth Limit Errors." Web. https://github.com/LeastAuthority/ethereum-
analyses/blob/master/GasEcon.md#callstack-depth-limit-errors
[13] Underhanded Solidity Coding Contest, Web. http://u.solidity.cc/
[14] Quorum. "A permissioned implementation of Ethereum supporting data privacy." https://github.com/jpmorganchase/quorum
PI:EMAIL / @msuiche 
https://github.com/comaeio/porosity