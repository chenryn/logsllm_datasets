HTTP requests and responses from HTTPS secured traﬃc
obtained during the following one day scenario. The user
logs in Google, Facebook, Twitter, Dropbox, an RSS ag-
gregator, and some other web sites; he keeps tabs opened
on multiple pages for each services, uses them during the
day and browses other websites as well. 8,185 HTTP re-
quests (122 MB) were retrieved. Among these, 4,823 re-
quests (24 MB) actually set or sent sensitives cookies.
With this HTTP trace, the script processes sequentially
each request and simulates the overheads induced by in-
stalling the MCookie module on every reached host. We
identify every sensitive cookie by looking at the httpOnly
and secure ﬂags. Table 2 describes the extra bandwidth
in diﬀerent situations: without User-Agent support (that is
using MCookies), either with na¨ıve or compressed encoding,
and with User-Agent support (the Masked-Cookies head-
ers). The results show a signiﬁcant overhead on requests
containing sensitive cookies. However, when looking at the
big picture, the overall HTTPS traﬃc, this overhead turns
out to be rather small. Finally, compared to the entire web
communications, both HTTP and HTTPS, the cost induced
by cookie masking proves to be negligible.
5.2.3 Apache module system overhead analysis
To evaluate the eﬃciency of MCookies and assess their
scalability, we performed a web server benchmark with and
without the MCookies module enabled. In order to evaluate
the module overhead, we ran the benchmarking tool on a
single HTML page. Furthermore, we also benchmarked the
module on a Wordpress website for a more realistic scenario.
Each request sent embedded three diﬀerent sentitive cookies.
The host used for this evaluation was an Intel Xeon X5650
with 6Go of RAM running a Debian system with an Apache
(v2.4.7) web server, a Mysql (v5.5) database server and host-
ing a Wordpress (v3.8.1) web site.
Vanilla
server
MCookies enabled
with UA
w/o UA
support
support
Static page
Wordpress page
384
221
318 (-17 %)
212 (-4 %)
382
220
Table 3: Performance results (transactions/second)
We used Siege12 in benchmark mode to assess the num-
ber of transactions the web server is capable to process per
second with the three scenarios. The results, as described in
Table 3, show a small decrease of 4 % of the Wordpress web
server capacity when dealing with User-Agents without the
support of this mechanism, whereas the overhead is negligi-
ble otherwise. However, for a static page served to a User-
Agent with no Masked-Cookie header support, performance
are much more degraded, but this is a worst-case scenario,
since static web sites rarely produce sensitive cookies.
6. RELATED WORK
To avoid repeating the same cookie across diﬀerent TLS
messages, a natural idea would be to change its value for
every new connection, or at least to limit the cookie life-
time. In fact, PHP proposes a way to handle session iden-
tiﬁers this way with the session_regenerate_id function,
usually called after a user logged in, to decorrelate the old
and the new sessions and avoid session ﬁxation attacks13.
Short-lived cookies (which could even be pushed to single-
use cookies) should thwart all passive attacks, but choos-
ing the right lifetime is not easy.
In fact, mitigating at-
tacks would require a very short lifetime, which could easily
lead to out-of-sync cookies when dealing with parallel HTTP
connections. Modern web sites heavily use JavaScript asyn-
chronous requests, and session regenerations are known to
provoke requests concurrency errors14. This is why MCook-
ies are designed to always have the same intended value.
One-Time Cookies [7] are another solution to protect plain-
text HTTP cookies against replay, by having the client bind
12http://www.joedog.org/siege-home/
13http://www.acros.si/papers/session_fixation.pdf
14Our 1-day HTTPS capture actually contains such concur-
rent requests, that would be problematic.
the cookie with the request sent. This mechanism uses cryp-
tographic mechanisms (symmetric encryption and HMAC)
and borrows the idea of Kerberos tickets and proposes an
elegant solution requiring no server-side state. Applied to
HTTPS and our attacker model, One-Time Cookies (OTC)
do not counter attacks, since repeating the same exact re-
quest would lead to the same OTC; however, the value re-
trieved could only be replayed for the request in question,
which would limit the scope of the attacks. Moreover, as
OTC rely on speciﬁc HTTP headers, their implementation
requires browser and server/web application modiﬁcations.
With regard to the Record protocol attacks exposed here,
Masked-Cookie headers are much simpler to implement (no
cryptographic primitives are needed).
Both solutions (single-use cookies and One-Time Cookies)
are described in Table 1. Other alternative cookie protocols
have been proposed, such as [14, 20], but they share OTC
advantage (unique cookies bound to the request data) and
drawbacks (heavy changes needed on both end points).
7. CONCLUSION
We have studied recent attacks on TLS Record protocol,
and thoroughly analyzed the proposed countermeasures. In
practice, the countermeasures implemented in most of the
software are speciﬁc to each attack: 1/n−1 split for BEAST,
constant-time CBC decryption for Lucky 13, deprecation of
RC4, disabling TLS compression for CRIME and TIME, and
deprecation of SSLv3 for POODLE.
In parallel, we showed that all the attacks relied on the
common assumption that a secret would be repeatedly sent
in diﬀerent TLS sessions. We suggested a common model to
describe these attacks. We also proposed to reuse the con-
cept of masking, borrowed from the side-channel commu-
nity, to mitigate the attacks. Such a technique can be im-
plemented as a complementary measure, a defense-in-depth
strategy. We described diﬀerent ways this countermeasure
could be implemented, and wrote two proofs of concept to
check its feasibility to protect cookies.
At the TLS level, our Scramble compression method builds
on the idea of WebSockets masking, which actually blocked
the BEAST attack. At the HTTP level, our MCookies ex-
tend the idea of single-use cookies, without requiring com-
plex changes in web protocols and applications. Masking
allows for a defense-in-depth strategy, giving developers and
integrators more time to solve the crisis. It would have been
eﬀective against the presented attacks, and might be against
yet unknown ones. The recent POODLE attack did in fact
meet all the criteria, and was published after we imple-
mented our proposals. The fact it would have been blocked
by our proofs of concept actually validates our work.
We would however make it clear that masking is designed
to be a defense-in-depth measure in addition to speciﬁc
countermeasures, not instead of them. When a cryptographic
algorithm or scheme shows signiﬁcant weaknesses, they should
be phased out and correctly patched. In the particular case
of RC4, we now know a lot of statistical biases, some of which
can lead to eﬃcient ﬁrst order attacks, but realistic second
order attacks could be the next attack against TLS Record
layer. All the masking proposals could be easily extended
to use two (or three) masks instead of one. Yet we consider
RC4 is a good example of a streamcipher that should have
been phased out a long time ago, since many RC4 practical
and theoretical ﬂaws have been known for a decade.
8. REFERENCES
[1] N. J. AlFardan, D. Bernstein, K. G. Paterson,
B. Poettering, and J. C. N. Schuldt. On the security of
RC4 in TLS and WPA. In USENIX Security, 2013.
[2] N. J. AlFardan and K. G. Paterson. Lucky Thirteen:
Breaking the TLS and DTLS Record Protocols. In
IEEE SSP, 2013.
[3] A. Barth. HTTP State Management Mechanism. RFC
6265, 2011.
[4] A. Barth. The Web Origin Concept. RFC 6454, 2011.
[5] D. Bernstein. ChaCha, a variant of Salsa20.
cr.yp.to/papers.html#chacha, 2008.
[6] S. Chari, C. S. Jutla, J. R. Rao, and P. Rohatgi.
Towards sound approaches to counteract
power-analysis attacks. In CRYPTO, 1999.
[7] I. Dacosta, S. Chakradeo, M. Ahamad, and
P. Traynor. One-time cookies: Preventing session
hijacking attacks with stateless authentication tokens.
ACM Trans. Internet Techn., 2012.
[8] T. Dierks and E. Rescorla. TLS Protocol Version 1.1.
RFC 4346, 2006.
[9] T. Dierks and E. Rescorla. TLS Protocol Version 1.2.
RFC 5246, 2008.
[10] T. Duong and J. Rizzo. BEAST: Surprising crypto
attack against HTTPS. Ekoparty, 2011.
[11] I. Fette and A. Melnikov. The WebSocket Protocol.
RFC 6455, 2011.
[12] S. Fluhrer and D. McGrew. Statistical Analysis of the
Alleged RC4 Keystream Generator. In FSE, 2000.
[13] J. Franks, P. Hallam-Baker, J. Hostetler, S. Lawrence,
P. Leach, A. Luotonen, and L. Stewart. HTTP
Authentication: Basic and Digest Access
Authentication. RFC 2617, 1999.
[14] K. Fu, E. Sit, K. Smith, and N. Feamster. The Dos
and Don’ts of Client Authentication on the Web. In
USENIX Security, 2001.
[15] L. Goubin and J. Patarin. DES and Diﬀerential Power
Analysis The ”Duplication” Method. In CHES, 1999.
[16] P. Gutmann. Encrypt-then-MAC for Transport Layer
Security (TLS) and Datagram Transport Layer
Security (DTLS). RFC 7366, 2014.
[17] J. Hodges, C. Jackson, and A. Barth. HTTP Strict
Transport Security (HSTS). RFC 6797, 2012.
[18] T. Isobe, T. Ohigashi, Y. Waatanabe, and M. Morii.
Full Plaintext Recovery Attack on Broadcast RC4. In
FSE, 2013.
[19] O. Levillain, A. Ebalard, H. Debar, and B Morin. One
Year of SSL Measurement. In ACSAC, 2012.
[20] A. X. Liu, J. M. Kovacs, C. Huang, and M. G. Gouda.
A Secure Cookie Protocol. In IEEE ICCCN, 2005.
[21] B. M¨oller. Security of CBC Ciphersuites in SSL/TLS:
Problems and Countermeasures, 2002-2004.
[22] B. M¨oller, T. Duong, and K. Kotowicz. Google
Security Advisory: This POODLE Bites: Exploiting
The SSL 3.0 Fallback, 2014.
[23] K. G. Paterson and N. J. AlFardan. Plaintext
Recovery Attacks Against DTLS. In NDSS, 2012.
[24] Y. N. Pettersen. Renego patched servers: A long-term
interoperability time bomb brewing. My Opera blog:
Implementer’s notes, 2010.
[25] A. Prado, N. Harris, and Y. Gluck. SSL, Gone in 30
seconds - A BREACH beyond CRIME. Black Hat
USA, 2013.
[26] E. Prouﬀ and M. Rivain. Masking against side-channel
attacks: a formal security proof. In Eurocrypt, 2013.
[27] E. Rescorla and N. Modadugu. DTLS Version 1.2.
RFC 6347, 2012.
[28] I. Ristic. Internet SSL Survey, Talk at BlackHat 2010.
Black Hat USA, 2010.
[29] J. Rizzo and T. Duong. The CRIME attack. Ekoparty,
2012.
[30] P. Rogaway. IETF Draft: Problems with proposed IP
Cryptography, 1995.
[31] A. Stubbleﬁeld, J. Ioannidis, and A. Rubin. Using the
Fluhrer, Mantin, and Shamir Attack to Break WEP.
In NDSS, 2002.
[32] A. Shulman T. Be’ery. A Perfect CRIME? TIME Will
Tell. Black Hat EU, 2013.
[33] S. Vaudenay. Security Flaws Induced by CBC Padding
Applications to SSL, IPsec, WTLS. In Eurocrypt,
2002.
APPENDIX
A. HTTP BASIC/DIGEST AUTH
In this paper, we discussed cookie protection. Other meth-
ods exist to authenticate the client at the HTTP layer: Basic
and Digest Authentication [13]. In practice, they are rarely
used, as the user interfaces do not allow for a clean integra-
tion with modern web applications (e.g. no logout feature).
Both headers are as vulnerable as cookies w.r.t. the de-
scribed attacks. For Basic Authentication, it is not clear
how they could be randomized: there can be no equivalent
to MCookies, unless the mechanism is deeply changed. For
Digest Authentication however, the standard already allows
for possible randomizations resembling MCookies, produc-
ing a new server nonce value for each new request. Such
policy would defeat all passive network attacks, since the
client would produce a diﬀerent header for each request.
B. SERVER-SIDE COMPRESSION
B.1 TIME and BREACH
In the TIME attack, in addition to targeting client-side
compression, the researchers proposed to target server-side
secret information repeatedly sent on the wire. For example,
Cross-Site Request Forgeries (CSRF) are usually blocked by
having the server insert a token in forms, which is later
checked on form submission. Such anti-CSRF tokens are
usually reused for a given user and a certain amount of time.
Server-side messages can be compressed using two diﬀer-
ent mechanisms.
In addition to the aforementioned TLS
compression, the server can also use HTTP compression.
This HTTP compression is also a target of the attack, as
the attacker can inject attacker-controlled data in the server
answer (preferably close to the targeted token in the pay-
load). This is the principle of the BREACH attack [25], an
attack aiming at retrieving the anti-CSRF token sent by the
server.
Hypotheses and prerequisites
• TLS or HTTP compression is activated;
• The ciphertext length is observable;
• The answer containing the target token is partially con-
trolled by the attacker, e.g. using a reﬂected ﬁeld;
• Multiple connections containing the secret can be trig-
gered by the attacker.
Proposed countermeasures
Disable TLS and HTTP compression. As for client-
side compression, this measure blocks the attack. In fact,
TLS compression can be (and has been) disabled, but HTTP
compression is essential to reduce bandwidth and disabling
it would drastically increase the size of HTTP responses.
Randomize the packet length. See Sec. 2.2.
Structurally modify web applications to separate
secrets from attacker-controlled content. If sensitive
information and attacker-controlled content come from dif-
ferent servers, compression contexts are distinct and the at-
tack does not hold. Yet, this requires signiﬁcant changes.
Change the token value for each request (single-
use token). It would block the attack but it also requires
an important change in the way anti-CSRF tokens usually
work.
B.2 MTokens: Making anti-CSRF tokens
To mitigate server-side attacks, the CSRF tokens (and
similar objects) could easily be protected using a technique
close to MCookies, i.e. by masking the token with a diﬀer-
ent value for each message. The intended value of the to-
ken would remain the same, avoiding out-of-sync problems,
while randomizing the data that is sent over the network.
Implementing this would require very very small changes to
web applications (or even no change at all if web frameworks
are modiﬁed):
it would simply amount to replacing every
call to the function producing the token (which we will call
write_csrftoken()) with mask(write_csrftoken()), and
each call to the function getting the token from the client
form (read_csrftoken()) with unmask(read_csrftoken()).
Security analysis
MTokens require small modiﬁcations in web applications (or
in frameworks), so they are easy to deploy, reliable and com-
patible with web applications, especially if the changes are
made in the framework. They are eﬀective against server-
side ﬁrst order attacks against anti-CSRF tokens in general.
C. TLS SCRAMBLING FUNCTION
The core of the Scramble compression method is the scram-
ble_record function (and unscramble_record, its counter-
part), which is implemented as follows
s t a t i c i n t s c r a m b l e r e c o r d (COMP CTX ∗ ctx ,
{
uchar ∗ out , uint o l e n , uchar ∗ i n , uint i l e n )
uchar mask [ MSIZE ] ;
( o l e n  b y t e s ( mask , MSIZE) < 0 ) return −1;
i f
i f
memcpy ( out , &mask , MSIZE ) ;
out = out + MSIZE ;
f o r ( i n t i = 0 ;
∗ ( out++) = ∗ ( i n++) ˆ mask . b y t e s [ i % MSIZE ] ;
i < i l e n ;
i ++)
return ( i l e n + MSIZE ) ;
}