Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:51:08 UTC from IEEE Xplore.  Restrictions apply. 
5.2.  Reproducing the keys
The  first  step  for  the recovery  server  and recovery
client to reproduce the keys is to force the recovery server 
to  send  the  same  SSH_MSG_KEXINIT   in  step  3  in 
Figure 2.  This is because SSH_MSG_KEXINIT contains
16-bytes of random data generated by the sender and used
as an input to future key and session identifier generating
functions.
n
K
g
f
K_S
-- preferred size in bits of the group the server
  should send
-- the shared secret
-- generator for subgroup
-- exchange value sent by the server
-- server certificate
Various  encryption  keys  are  computed  as  hash of  a  K
and H and a known single character.
Therefore,  we  need  to  make  sure  that  the  recovery
server generates the same SSH_MSG_KEXINIT as that of 
the original  server, so  that both  the recovery  client  and
server  can  derive  the  same  set  of  keys  as  those of  the
original session. This is accomplished in a straightforward
manner:   we  first  modify  the original  server so  that  it 
exports  the 16-byte random  number,  after encrypting  it
using  the  recovery  server’s public  key (and  signing with
the original server’s private key); this is exported through
secure channel to the recovery server for later use, should
recovery be called for.  During the CPR process, instead of 
generating the random numbers on the fly as is the normal
mode  of  operation  for  SSH, the  recovery  server  imports
the saved value, decrypts it using its private key (validates
the 
same
and 
SSH_MSG_KEXINIT.
finally  produces 
signature), 
the 
As  stated  earlier,  the  Diffie-Hellman  group  and  key
exchange is a secure key exchange method that produces a 
unique  set of  keys.   The  current SSH  Transport  Layer
Protocol  only designates Diffie-Hellman  key  exchange  as
the required method. However, the Diffie-Hellman group
and key exchange method offers better security because it
uses  a  different  group for  each  session,  and  is  the  default
key  exchange method deployed  in  OpenSSH.   Therefore,
without loss of generality, it is assumed herein.
In Figure 3, we expand step 5-8 of Figure 2 to illustrate
this  key  exchange  method  in  detail.    Note that  ||  denotes
string concatenation.
In step 5 of Figure 3, the client sends min, n, and max
to the server, indicating the minimal acceptable group size,
the preferred size of the group and the maximal group size
in bits the client will accept.  In step 6, the server finds a
group  that  best matches  the  client's  request,  and  sends p
and g  to  the  client.  In  step 7,  client generates  a  random
number  x.  It computes  e  =  gx  mod  p,  and sends  "e"  to
server. In step 8, server generates a random number y and
computes  f  =  gy mod  p. When  the  server  receives  “e”  it 
computes K = ey mod p, and H = hash(Vc|| Vs|| Ic|| Is|| Ks||
min || n || max || p || g || e || f || K) where
Vc & Vs
Ks
p 
Ic & Is
--client's & server's version strings, resp
-- server host key
-- safe prime
-- the payload of the client & server’s
SSH_MSG_KEXINIT, resp
min & max --minimal & maximal size in bits of an
acceptable group, resp 
(cid:38)(cid:79)(cid:76)(cid:72)(cid:81)(cid:87)(cid:3)
(cid:54)(cid:72)(cid:85)(cid:89)(cid:72)(cid:85)(cid:3)
5
7
msg_REQUEST
byte
unit32    min 
unit32    n 
uint32    max
byte msg_GROUP
mpint   p 
mpint   g
byte     msg_INIT
mpint   e = gx  mod  p 
msg_REPLY
byte
string Ks and K_S
mpint    f = gy  mod  p 
6
8
Figure 3. Diffie-Hellman
Group and Key Exchange
Following the above description, we can conclude that
the  entities  that  are unique  to  each  session  that  affect key
generation are: Vc, Vs, Ic, Is, Ks, min, n, max, p, g, e, f, K
and H. In our CPR process, the recovery client replays the 
messages previously sent by the original client, thus Vc, Ic,
min,  n,  max,  e  will  be  the same  for  the  recovery  session,
but other items that are normally generated at run time by
the  server  must  be  the  restored  as  those  originally used.
Because  the  recovery  server  is  only  a  slightly  modified
version of the original server, it will thus produce the same
Vs.    Therefore,  the  entities  that  we  need  to  force  the 
recovery server to duplicate in order to generate the same
set of keys are: Is, p, g, f, and Ks. We modify the original
SSH  server  so  that  it  encrypts  these  aforementioned
entities  using recovery  server’s public  key,  appends  with
message  digest,  signs  and  exports  them to  a  secure
network  location.
  For  the recovery  server,  instead  of 
generating these host-specific entities dynamically, it reads
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:51:08 UTC from IEEE Xplore.  Restrictions apply. 
them in  from  the  secure  location, decrypts  them  using  its 
private  host key,  verifies  message digest and  signature,
and generates the same packets to be sent to client in step
6 and 8 in Figure 3. In doing so, the recovery server and
the  corresponding  recovery  client  are  guaranteed  to
produce  the  same  set  of  initial  IVs,  as  well  as  encryption
and integrity keys, enabling our CPR to proceed.
5.3.  SSH Transport Layer Protocol 
Each  SSH  packet  includes, respectively,  4  bytes in a
packet  length field, 1  byte  in  a  padding  length field,  a 
payload  field,  and random  padding.
The  encrypted
packets  have an  additional  MAC  field  at  the  end  as 
described below. 
  Packet  format  before  and  after
encryption is depicted in Figure 4.
Packet
length
Padding
length
Random
Padding
MAC
5.3.3.  Random Padding
as expected, the first approach is just as effective without
the inefficiency of saving all the raw packets.
5.3.2.  Data Integrity
As  shown  in  Figure  4,  each  encrypted  packet  is 
appended with a Message Authentication Code (MAC) to
achieve data integrity. MAC is produced according to the
following formula:
MAC = mac_algorithm( key, sequence_number ||
unencrypted_packet )
where  unencrypted_packet is  the  entire  packet without
MAC  and  sequence_number  is  an  implicit  32  bit packet
sequence number.    The  sequence number  is  initialized  to
zero  for  the  first  packet,  and  is  incremented  after  every
packet.
Of the three parameters to MAC, we observe here that
the  only  entity  that  is  unique  to  every  packet  in  each
session is the sequence_number. The regular SSH server is 
thus  modified  to  securely export  the  latest  sequence
number  after  each packet  send/receive  operation.  At  the
end of  CPR,  we  reset  the  sequence_number  of  the
recovery server as the latest one from the original session.
The  random  padding  field  consists  of  randomly
generated bytes to ensure the total length of the raw packet
is  a  multiple  of  the  cipher block.   Although  the recovery
server  and  original  server  generate different
random
padding for  their  packets,  it  is  not  necessary  to  alter  the
recovery  server  in order  to reconcile  this inconsistency.
This  is  because  both  the recovery  client  and  recovery
server  will  derive 
the  same  encryption  and  MAC 
algorithms  after  the key  exchange  phase,  as  well  as  the
same  set  of  keys,  which  enables  the  recovery  client  to
successfully decrypt  any  packet
the 
recovery server and to proceed until CPR ends.  The only
ramification  of  different  random  padding  is  that  the
recovery server’s cipher context, or the last block of cipher
text (Ci), will be different from that of the original server. 
However,  as  explained  in section 5.1,  we  will  reset  the
cipher context of the recovery server at the end of CPR to
make  it  consistent with  the original server,  thus  making
exporting 
field
unnecessary.
received  from 
importing 
padding 
random 
and 
5.3.4 Application State
Application  state  is  recovered  in  a  manner generally
addressed in [4].  For a given application (such as a remote
shell  or  a  specific  application  invoked  using  SSH)  a  per-
application recovery  module  is  created.
These  are
generally  simple  to  create,  and  may  be  crafted from
existing  models.    The primary  issue  in an  application
Raw Packet (cid:169)
Encrypted Packet (cid:169)
Figure 4. SSH packet format
5.3.1. Encryption
According to the export/import method we described in 
section  5.2.1,  we  can  guarantee  that  the  same  encryption
algorithms  and  identical  set  of keys will  be  used during
CPR.    However,  for block  ciphers,  the previous  block of
cipher  text,  denote  as  Ci,  is used  as  the  random  data  that
will  be  XOR’d  into  the  next  plaintext.   This  in  essence,
means  that,  though we  start  with  the  same  sets  of  keys,
because we  are  only  doing  a  partial  replay,  we  may  still
arrive at an inconsistent cipher context at the end of CPR.
We  have designed  two  approaches  to  solve  this  problem:
(1)  to  modify the  original SSH  server  to export  the  most
recent Ci with every packet encryption and decryption, and
to reset the cipher context of the SSH recovery server to Ci
at  the  end  of  CPR;  vs.  (2) to  modify  the  regular SSH
server  to  securely  export  every  raw packet,  so  that  the
cipher 
applying
encryption/decryption over all the saved raw packets. We
implemented both of these two approaches and found that,
advanced 
context 
can 
by 
be 
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:51:08 UTC from IEEE Xplore.  Restrictions apply. 
it 
is  for 
to  monitor 
the original
recovery  module 
connection and extract relevant state from it. This can be
restored by replay to an unmodified application daemon or
by  directly  setting  state  into  a  daemon  modified for  that
purpose.
non-deterministic
applications  like  a  shell  session  can  display  a  list  of 
previously  executed  commands  for  the user  to  choose  to
re-execute.  More deterministic applications, such as FTP,
can have  their  state  replayed by  a  simple  proxy  client
directly.
For  example,  highly
The  only  significant  difference  between  recovery 
applications  under  Jeebs  compared  to  SecureJeebs  is  that
the recovery module  must  be  connected into  the  SSH
monitor, so  it  can  decrypt  the  session’s  application
communications  to determine which  are  relevant state-
setting  messages,  e.g.,  a  CHDIR  command  in FTP, or
gathering  the  list  of  commands  executed for  a  login
session.
  However,  since the  SSH  software  has been
slightly modified for recovery purposes anyway, this is not
a significant imposition.
6.  Performance 
We  chose OpenSSH  3.5  and modified  the  source  code 
to create  both  the  regular  and  recovery SSH server.    We
conducted our  experiments  on  several  very  modest
machines  (each  an  Intel  Pentium  333  MHz  with  128M 
memory and Intel Ethernet Pro 10/100B PCs running Red
Hat 7.2 with a mySQL database).
The  fundamental measure  of  success  in  this  case  is 
whether  SSH connections  can be  restored before  TCP’s