### Reverse Engineering Intel Last-Level Cache Complex Addressing

#### 4. Experimental Results

To compare our function against the one proposed in [8], we conducted the following experiment. Using the retrieved addressing function, we constructed a set of physical addresses that are expected to map to the same cache set (and thus the same slice). We accessed N different addresses from this set and then measured the access time to the first reference address to determine if it had been evicted from the cache.

Figure 4 shows the median number of CPU cycles required to access the reference address for different values of N, based on 100 runs. The most precise function should exhibit a memory access time spike closest to N = 20, which is the cache associativity. Both functions show a spike slightly after N = 20. This slight deviation from N = 20 is likely due to the fact that the replacement policy on Ivy Bridge is not strictly LRU but a variant called Quad-Age LRU [18]. In practice, both functions can evict a cache line with few accesses. However, our function appears more precise, requiring N = 23 accesses compared to N = 24 for [8], and exhibits a sharper transition. This confirms the correctness of our function.

#### 7. Related Work

Hardware performance counters are traditionally used for performance monitoring and have also been applied in security scenarios. For defensive purposes, they are used to detect anomalous behavior such as malware detection [5], integrity checking of programs [21], control flow integrity [34], and binary analysis [32]. Uhsadel et al. [31] used performance counters in offensive scenarios to profile the cache and derive side-channel attacks against AES. However, reading performance counters requires high privileges, i.e., kernel-mode or root in user-mode if a driver is loaded. Unlike these attacks, we use performance counters to infer hardware properties offline, and our subsequent cache attack does not require high privileges.

The Flush+Reload attack [36] relies on shared memory, specifically shared libraries, to evict lines of cache using the `clflush` instruction. This attack leverages the shared and inclusive LLC to run concurrently with the victim on separate cores, including on separate virtual machines. Flush+Reload has been used to attack implementations of RSA [36], AES [16], and ECDSA [1], and to find new side channels [13] and detect cryptographic libraries [17]. Gruss et al. [7] presented a generic technique to profile and exploit cache-based vulnerabilities using Flush+Reload. Memory sharing can be disabled in virtualized environments, effectively preventing Flush+Reload attacks. In sandboxed environments like JavaScript or Native Client [2], the absence of the `clflush` instruction [3] compromises the ability to perform Flush+Reload. Understanding complex addressing allows performing cache attacks in these environments without the need for shared memory or `clflush`.

Simultaneously with our work, Irazoqui et al. [14], Liu et al. [20], and Oren et al. [24] extended the Prime+Probe attack to the LLC, enabling side channels on the LLC without shared memory. They constructed a set of addresses that map to the same set as the line to evict. Irazoqui et al. [14] used a Nehalem processor that does not use complex addressing, making huge pages sufficient. Liu et al. [20] and Oren et al. [24] targeted more recent processors with complex addressing but did not reverse engineer the complex addressing function. Although we share the same motivation, our approaches differ significantly. Our work has broader applications, contributing to a better understanding of the undocumented complex addressing function and potentially leading to other types of attacks.

Other works have attempted to retrieve the complex addressing function. Hund et al. [8] manually reverse-engineered the function for a 4-core Sandy Bridge CPU, using colliding addresses to derive the function. They used this function to bypass kernel ASLR. Seaborn [29] continued this work with a 2-core Sandy Bridge CPU, aiming to exploit the rowhammer bug with cached accesses. Gruss et al. [6] demonstrated a rowhammer attack on JavaScript using the complex addressing function. In contrast, our method uses performance counters to perform direct measurements, retrieving the exact slice for each access. We show that the functions in [8,29] are partially incorrect, though sufficient for practical use. We also derive a function for all processors with 2^n cores, automating the reverse engineering. Our method has been tested on a wide variety of processors, unlike previous works. Irazoqui et al. [15] also worked on automating the reverse engineering, but their method is similar to [8] and suffers from the same limitations.

#### 8. Conclusions

In this paper, we introduced a novel method to reverse engineer Intel's undocumented complex addressing using hardware performance counters. The reversed functions can be exploited by an attacker to target specific sets in the last-level cache when performing cache attacks. Our method is automatic and has been evaluated on a wide range of processors, providing a more complete and accurate description of the complex addressing function than previous work. We also provided a compact function for CPUs with 2^n cores, enabling more effective attacks. We demonstrated a covert channel to prove the correctness of our function and discussed other applications, such as exploiting the rowhammer bug in JavaScript.

Our work expands the understanding of modern processors' complex and partially documented hardware. Future work could include developing a compact representation for CPUs with a different number of cores, exploring new attacks enabled by knowing the complex addressing, and developing countermeasures to cache attacks.

#### Acknowledgments

We would like to thank Mark Seaborn, Mate Soos, Gorka Irazoqui, Thomas Eisenbarth, and our anonymous reviewers for their valuable comments and suggestions. We also greatly thank Stefan Mangard and Daniel Gruss for their collaboration on the exploitation of the rowhammer bug in JavaScript, applying the findings of this article after its submission.

#### References

[References remain unchanged]