0
5
10
15
2223
Number of addresses N
20
25
30
35
Fig. 4. Median number of cycles to access a reference address, after accessing N
addresses in the same set, which is calculated using [8] and our function. Results on
100 runs, on conf ig 1 (Ivy Bridge with a 20-way associative LLC).
To compare our function against [8], we performed the following experi-
ment. Using the retrieved addressing function, we constructed a set of physical
Reverse Engineering Intel Last-Level Cache Complex Addressing
61
addresses that are supposed to map the same set (thus the same slice). We
accessed N diﬀerent addresses from this set. We then measured the access time
to the ﬁrst reference address accessed, to see if it was evicted from the cache.
Figure 4 shows the median number of CPU cycles to access the reference address
for diﬀerent values of N, for 100 runs. The function that is the most precise
should have a memory access time spike the closest N = 20 (which is the cache
associativity). We observe that both functions have a spike slightly after N = 20.
We note that the spike occurs for a value N > 20 and not exactly N = 20: it
is most likely due to the fact that the replacement policy on Ivy Bridge is not
strictly LRU, but a variant called Quad-Age LRU [18]. In practice, both func-
tions are able to evict a cache line with few accesses. However, our function
seems more precise than the one of [8], leading to fewer accesses to evict a cache
line (N = 23 accesses for our function, N = 24 for [8]), and a sharper transition.
This also conﬁrms the correctness of our function.
7 Related Work
Hardware performance counters are traditionally used for performance monitor-
ing. They have also been used in a few security scenarios. In defensive cases, they
are used to detect an anomalous behavior such as malware detection [5], integrity
checking of programs [21], control ﬂow integrity [34], and binary analysis [32].
Uhsadel et al. [31] used performance counters in oﬀensive cases to proﬁle the
cache and derive a side-channel attack against AES. However, the performance
counters can only be read with high privileges, i.e., in kernel-mode, or being
root in user-mode if a driver is already loaded. Contrary to this attack, we use
performance counters to infer hardware properties oﬄine, and our subsequent
cache attack does not need high privileges.
The Flush+Reload attack [36] relies on shared memory, and more precisely
on shared libraries, to evict lines of cache, using the clflush instruction. In
this attack, the attacker leverages the shared and inclusive LLC to run concur-
rently to the victim on separate cores, including on separate virtual machines.
Flush+Reload has been used to attack implementations of RSA [36], AES [16]
and ECDSA [1]. It has also been used to ﬁnd a new side channel that revives
a supposedly ﬁxed attack on CBC encryption mode [13], and to detect cryp-
tographic libraries [17]. Gruss et al. [7] presented a generic technique to proﬁle
and exploit cache-based vulnerabilities, using Flush+Reload. Memory sharing
can be easily disabled in virtualized environments (which is already the case
in the cloud environment), eﬀectively rendering impossible the Flush+Reload
attack. On sandboxed environments, like Javascript or Native Client [2], the
ability to perform the Flush+Reload attack is also compromised by the absence
of clflush instruction [3]. Understanding how complex addressing works allows
performing cache attacks in these environments, without the need of shared
memory or clflush.
Simultaneously to our work, Irazoqui et al. [14], Liu et al. [20], and Oren
et al. [24] have extended the Prime+Probe attack to the LLC. They are thus able
62
C. Maurice et al.
to perform side channels on the LLC without any shared memory. They construct
a set of addresses that map to the same set as the line to evict. Irazoqui et al. [14]
have used a Nehalem processor that does not use complex addressing. Therefore
huge pages are suﬃcient to construct this set of addresses. Liu et al. [20], and
Oren et al. [24] targeted more recent processors that use complex addressing.
They, however, performed their attacks without reverse engineering the complex
addressing function. Thus, even if we share the same motivation, i.e., performing
cache attacks on recent processors without any shared memory, our works are
very diﬀerent in their approaches. We also note that our work has a broader
application, as it contributes to a better understanding of the undocumented
complex addressing function, possibly leading to other types of attacks.
Other work is directly interested in retrieving the function, and several
attempts have been made to reverse engineer it. Hund et al. [8] performed a
manual reverse engineering for a 4-core Sandy Bridge CPU. Their method uses
colliding addresses, i.e., indirect measurements, to derive the function. They used
this function to bypass kernel ASLR. Very recently, and also simultaneous to our
work, Seaborn [29] continued the work of [8], with a 2-core Sandy Bridge CPU.
The intended goal is to exploit the rowhammer bug with cached accesses, without
the clflush instruction. Gruss et al. [6] subsequently demonstrated a rowham-
mer attack on Javascript, using the complex addressing function. In contrast,
we do not use the same method to retrieve the addressing function as [8,29].
Our method, using performance counters, performs direct measurements, i.e.,
retrieves the exact slice for each access. We thus show that the functions in [8,29]
are partially incorrect, even though they are suﬃcient to be used in practice. We
also derive a function for all processors with 2n cores, automating the reverse
engineering. Diﬀerent from these two works, we also have tested our method
on a large variety of processors. Concurrently to our work, Irazoqui et al. [15]
worked on automating this reverse engineering, and evaluated their work on sev-
eral processors. However, their method is similar to Hund et al. [8], and thus
suﬀers from the same limitations.
8 Conclusions
In this paper, we introduced a novel method to reverse engineer Intel’s undocu-
mented complex addressing, using hardware performance counters. The reversed
functions can be exploited by an attacker to target speciﬁc sets in the last level
cache when performing cache attacks. Contrary to previous work, our method is
automatic, and we have evaluated it on a wide range of processors, for diﬀerent
micro-architectures, numbers of cores, and product ranges. We also obtained a
more complete and more correct description of the complex addressing function
than previous work, i.e., taking into account more bits of the memory address.
In the general case with any number of cores, we automatically built a table
that maps physical addresses to cache slices. This table already enables to per-
form targeted cache attacks but may require an important amount of storage.
In the case of CPUs with 2n cores we provided a compact function that maps
Reverse Engineering Intel Last-Level Cache Complex Addressing
63
addresses to slices, rendering the attacks even more eﬀective. We demonstrated
a covert channel to prove the correctness of our function, and discussed other
applications such as exploiting the rowhammer bug in Javascript.
Our work expands the understanding of these complex and only partially
documented pieces of hardware that are modern processors. We foresee several
directions for future work. First, a compact representation for CPUs with a num-
ber of cores diﬀerent from 2n would generalize our ﬁndings. Second, we believe
that new attacks could be made possible by knowing the complex addressing of
a cache. Finally, we believe that understanding the complex addressing function
enables the development of countermeasures to cache attacks.
Acknowledgments. We would like to thank Mark Seaborn, Mate Soos, Gorka Irazo-
qui, Thomas Eisenbarth and our anonymous reviewers for their valuable comments and
suggestions. We also greatly thank Stefan Mangard and Daniel Gruss for the collabo-
ration on the exploitation of the rowhammer bug in Javascript, for which we applied
the ﬁndings of this article after its submission.
References
1. Benger, N., van de Pol, J., Smart, N.P., Yarom, Y.: “Ooh Aah.. Just a Little Bit”:
a small amount of side channel can go a long way. In: Batina, L., Robshaw, M.
(eds.) CHES 2014. LNCS, vol. 8731, pp. 75–92. Springer, Heidelberg (2014)
2. Chrome Developers. Native Client. https://developer.chrome.com/native-client.
Accessed 2 June 2015
3. Chrome Developers. Native Client Revision 13809, September 2014. http://
src.chromium.org/viewvc/native client?revision=13809&view=revision. Accessed
2 June 2015
4. Crama, Y., Hammer, P.L.: Boolean Functions: Theory, Algorithms, and Applica-
tions. Cambridge University Press, New York (2011)
5. Demme, J., Maycock, M., Schmitz, J., Tang, A., Waksman, A., Sethumadhavan,
S., Stolfo, S.: On the feasibility of online malware detection with performance
counters. ACM SIGARCH Comput. Architect. News 41(3), 559–570 (2013)
6. Gruss, D., Maurice, C., Mangard, S.: Rowhammer.js: a remote software-induced
fault attack in JavaScript. arXiv:1507.06955v1 (2015)
7. Gruss, D., Spreitzer, R., Mangard, S.: Cache template attacks: automating attacks
on inclusive last-level caches. In: Proceedings of the 24th USENIX Security Sym-
posium (2015)
8. Hund, R., Willems, C., Holz, T.: Practical timing side channel attacks against
kernel space ASLR. In: Proceedings of the 2013 IEEE Symposium on Security and
Privacy (S&P 2013), pp. 191–205. IEEE, May 2013
9. Intel. Intel R(cid:3) Xeon R(cid:3) Processor E5–2600 Product Family Uncore Performance
10. Intel. Intel R(cid:3) 64 and IA-32 Architectures Software Developer’s Manual, vol. 3 (3A,
11. Intel. Intel R(cid:3) Xeon R(cid:3) Processor E5 v2 and E7 v2 Product Families Uncore Perfor-
12. Intel. Intel R(cid:3) Xeon R(cid:3) Processor E5 v3 Family Uncore Performance Monitoring
mance Monitoring Reference Manual. 329468–002:1–200 (2014)
Monitoring Guide. 327043–001:1–136 (2012)
3B & 3C): System Programming Guide. 3(253665) (2014)
Reference Manual. 331051–001:1–232 (2014)
64
C. Maurice et al.
13. Irazoqui, G., Eisenbarth, T., Sunar, B.: Lucky 13 strikes back. In: Proceedings
of the 10th ACM Symposium on Information, Computer and Communications
Security (AsiaCCS 2015), pp. 85–96 (2015)
14. Irazoqui, G., Eisenbarth, T., Sunar, B.: S$A: a shared cache attack that works
across cores and deﬁes VM sandboxing–and its application to AES. In: Proceedings
of the 36th IEEE Symposium on Security and Privacy (S&P 2015) (2015)
15. Irazoqui, G., Eisenbarth, T., Sunar, B.: Systematic reverse engineering of cache
slice selection in Intel processors. In: Proceedings of the 18th EUROMICRO Con-
ference on Digital System Design (2015)
16. Irazoqui, G., Inci, M.S., Eisenbarth, T., Sunar, B.: Wait a minute! A fast, Cross-
VM attack on AES. In: Stavrou, A., Bos, H., Portokalidis, G. (eds.) RAID 2014.
LNCS, vol. 8688, pp. 299–319. Springer, Heidelberg (2014)
17. Irazoqui, G., IncI, M.S., Eisenbarth, T., Sunar, B.: Know thy neighbor: crypto
library detection in cloud. Proc. Priv. Enhancing Technol. 1(1), 25–40 (2015)
18. Jahagirdar, S., George, V., Sodhi, I., Wells, R.: Power management of the third
generation Intel Core micro architecture formerly codenamed Ivy Bridge. In:
Hot Chips 2012 (2012). http://hotchips.org/wp-content/uploads/hc archives/
hc24/HC24-1-Microprocessor/HC24.28.117-HotChips IvyBridge Power 04.pdf.
Accessed 16 July 2015
19. Kim, D.-H., Nair, P.J., Qureshi, M.K.: Architectural support for mitigating row
hammering in DRAM memories. IEEE Comput. Archit. Lett. 14(1), 9–12 (2014)
20. Liu, F., Yarom, Y., Ge, Q., Heiser, G., Lee, R.B.: Last-level cache side-channel
attacks are practical. In: Proceedings of the 36th IEEE Symposium on Security
and Privacy (S&P 2015) (2015)
21. Malone, C., Zahran, M., Karri, R.: Are hardware performance counters a cost
eﬀective way for integrity checking of programs. In: Proceedings of the Sixth ACM
Workshop on Scalable Trusted Computing (2011)
22. Maurice, C., Neumann, C., Heen, O., Francillon, A.: C5: cross-cores cache covert
channel. In: Almgren, M., Gulisano, V., Maggi, F. (eds.) DIMVA 2015. LNCS, vol.
9148, pp. 46–64. Springer, Heidelberg (2015)
23. Neve, M., Seifert, J.-P.: Advances on access-driven cache attacks on AES. In:
Biham, E., Youssef, A.M. (eds.) SAC 2006. LNCS, vol. 4356, pp. 147–162. Springer,
Heidelberg (2007)
24. Oren, Y., Kemerlis, V.P., Sethumadhavan, S., Keromytis, A.D.: The spy in the
sandbox: practical cache attacks in JavaScript and their implications. In: Proceed-
ings of the 22nd ACM Conference on Computer and Communications Security
(CCS 2015) (2015)
25. Osvik, Dag Arne, Shamir, Adi, Tromer, Eran: Cache attacks and countermeasures:
the case of AES. In: Pointcheval, David (ed.) CT-RSA 2006. LNCS, vol. 3860, pp.
1–20. Springer, Heidelberg (2006)
26. Percival, C.: Cache missing for fun and proﬁt. In: Proceedings of BSDCan, pp.
1–13 (2005)
27. Ristenpart, T., Tromer, E., Shacham, H., Savage, S.: Hey, you, get oﬀ of my cloud:
exploring information leakage in third-party compute clouds. In: Proceedings of the
16th ACM Conference on Computer and Communications Security (CCS 2009),
pp. 199–212 (2009)
28. Seaborn, M.: Exploiting
the DRAM rowhammer bug
gain kernel
http://googleprojectzero.blogspot.fr/2015/03/
to
privileges,
exploiting-dram-rowhammer-bug-to-gain.html. Accessed 2 June 2015
March
2015.
Reverse Engineering Intel Last-Level Cache Complex Addressing
65
29. Seaborn, M.: L3 cache mapping on Sandy Bridge CPUs, April 2015. http://
lackingrhoticity.blogspot.fr/2015/04/l3-cache-mapping-on-sandy-bridge-cpus.
html. Accessed 2 June 2015
30. Tromer, E., Osvik, D.A., Shamir, A.: Eﬃcient cache attacks on AES, and counter-
measures. J. Cryptology 23(1), 37–71 (2010)
31. Uhsadel, L., Georges, A., Verbauwhede, I.: Exploiting hardware performance coun-
ters. In: Proceedings of the 5th International Workshop on Fault Diagnosis and
Tolerance in Cryptography (FDTC 2008), pp. 59–67 (2008)
32. Willems, C., Hund, R., Fobian, A., Felsch, D., Holz, T.: Down to the bare metal:
using processor features for binary analysis. In: Proceedings of the 28th Annual
Computer Security Applications Conference (ACSAC 2012), pp. 189–198 (2012)
33. Wu, Z., Xu, Z., Wang, H.: Whispers in the hyper-space: high-speed covert channel
attacks in the cloud. In: Proceedings of the 21st USENIX Security Symposium
(2012)
34. Xia, Y., Liu, Y., Chen, H., Zang, B.: CFIMon: detecting violation of control ﬂow
integrity using performance counters. In: Proceedings of the 42th International
Conference on Dependable Systems and Networks (DSN 2012), pp. 1–12 (2012)
35. Xu, Y., Bailey, M., Jahanian, F., Joshi, K., Hiltunen, M., Schlichting, R.: An
exploration of L2 cache covert channels in virtualized environments. In: Proceed-
ings of the 3rd ACM Cloud Computing Security Workshop (CCSW 2011), pp.
29–40 (2011)
36. Yarom, Y., Falkner, K.: Flush+Reload: a high resolution, low noise, L3 cache side-
channel attack. In: Proceedings of the 23th USENIX Security Symposium (2014)
37. Zhang, Y., Juels, A., Reiter, M.K., Ristenpart, T.: Cross-VM side channels and
their use to extract private keys. In: Proceedings of the 19th ACM Conference on
Computer and Communications Security (CCS 2012) (2012)
38. Zhang, Y., Juels, A., Reiter, M.K., Ristenpart, T.: Cross-tenant side-channel
attacks in PaaS clouds. In: Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security (CCS 2014), pp. 990–1003. ACM Press,
New York (2014)