{
Breaking the x86 ISA
domas / @xoreaxeaxeax / DEF CON 2017
 Christopher Domas
 Cyber Security Researcher @
Battelle Memorial Institute
./bio
 8086: 1978
 A long, tortured history…
The x86 ISA
 Modes:
 Real (Unreal)
 Protected mode (Virtual 8086, SMM)
 Long mode (Compatibility, PAE)
x86: evolution
 Instruction sets
x86: evolution
 Modern x86 chips are a complex 
labyrinth of new and ancient technologies.
 Things get lost…
 8086: 29,000 transistors
 Pentium: 3,000,000 transistors
 Braodwell: 3,200,000,000 transistors
x86: evolution
 We don’t trust software.
 We audit it
 We reverse it
 We break it
 We sandbox it
Trust.
 But the processor itself?
 We blindly trust
Trust.
 Why?
 Hardware has
all the same problems as software
 Secret functionality?
 Appendix H.
 Bugs?
 F00F, TSX, Hyperthreading.
 Vulnerabilities?
 SYSRET, cache poisoning, sinkhole
Trust.
 We should stop
blindly trusting our hardware.
Trust.
 What do we need to worry about?
 Well known from software
 Examples
Backdoors
 Hardware
 FPGAs
 Hypervisors
 Microcode
 Supply chain
Backdoors
 Could a hidden instruction
unlock your CPU?
Hidden instructions
 Historical examples
 ICEBP
 apicall
Hidden instructions
Hidden instructions
 Traditional approaches:
 Leaked documentation
 Reverse engineering software
 NDA
 But what if it’s something stealthy?
Hidden instructions
 Find out what’s really there
Goal: Audit the Processor
 How to find hidden instructions?
Approach
 Instructions can be one byte …
 inc eax
 40
 … or 15 bytes ...
 lock add qword cs:[eax + 4 * eax + 07e06df23h], 0efcdab89h
 2e 67 f0 48 818480 23df067e 89abcdef
 Somewhere on the order of
1,329,227,995,784,915,872,903,807,060,280,344,576
possible instructions
Approach
https://code.google.com/archive/p/corkami/wikis/x86oddities.wiki
 The obvious approaches don’t work:
 Try them all?
 Only works for RISC
 Try random instructions?
 Exceptionally poor coverage
 Guided based on documentation?
 Documentation can’t be trusted
(that’s the point)
 Poor coverage of gaps in the search space
Approach
 A depth-first-search algorithm
 (Overview)
Tunneling
 Catch: requires knowing the instruction 
length
 Simple approach: trap flag
 Fails to resolve the length of faulting instructions
 Necessary to search privileged instructions:
 ring 0 only: mov cr0, eax
 ring -1 only: vmenter
 ring -2 only: rsm
 It’s hard to even auto-generate a successfully 
executing ring 3 instruction:
 mov eax, [random_number]
 Solution: page fault analysis
Instruction lengths
 (Overview)
Page Fault Analysis
 Trap flag
 Catch branching instructions
 Differentiate between fault types
Cleanup
 Reduces search space from 1.3x1036
instructions to ~100,000,000 (one day 
of scanning)
 This gives us a way to search the 
instructions space.
 How do we make sense of the instructions 
we execute?
Tunneling
 We need a “ground truth”
 Use a disassembler
 It was written based on the documentation
 Capstone
Sifting
 Compare:
 Observed length of instruction vs. 
disassembled length of instruction
 Signal generated by instruction vs.
expected signal
Sifting
sandsifter
 (Demo)
sandsifter
 Hidden instructions
 Ubiquitous software bugs
 Hypervisor flaws
 Hardware bugs
Results
 0f0dxx
 Undocumented for non-/1 reg fields
 0f18xx, 0f{1a-1f}xx
 Undocumented until December 2016
 0fae{e9-ef, f1-f7, f9-ff}
 Undocumented for non-0 r/m fields until June 2014
 dbe0, dbe1
 df{c0-c7}
 f1
 {c0-c1}{30-37, 70-77, b0-b7, f0-f7}
 {d0-d1}{30-37, 70-77, b0-b7, f0-f7}
 {d2-d3}{30-37, 70-77, b0-b7, f0-f7}
 f6 /1, f7 /1
Hidden instructions
 Catch:
 Undocumented instructions recognized by 
the disassembler are not found
Hidden instructions
 Issue:
 Our “ground truth” (the disassembler) is 
also prone to errors
Software bugs
 Every disassembler we tried as the 
“ground truth” was littered with bugs.
Software bugs
 Most bugs only appear in a few tools, 
and are not especially interesting
 Some bugs appeared in all tools
 These can be used to an attacker’s advantage.
Software bugs
 66e9xxxxxxxx (jmp)
 66e8xxxxxxxx (call)
Software bugs
 66 jmp
 Demo:
 IDA
 Visual Studio
 objdump
 QEMU
Software bugs
 66 jmp
 Why does everyone get this wrong?
 AMD designed the 64 bit architecture
 Intel adopted… most of it.
Software bugs
 Issues when we can’t agree on a standard
 sysret bugs
 Either Intel or AMD is going to be 
vulnerable when there is a difference
 Complex architecture
 Tools cannot parse a jump instruction
Software bugs
 Azure
 CPUID / Trap flag bug
Hypervisor bugs
 Intel:
 f00f bug on Pentium
 AMD:
 Incorrect signals during decode
 Transmeta:
 0f{71,72,73}xxxx
 Premature #GP0 signal during decode
Hardware bugs
 Our processors are not doing what we 
think they are
 We need formal specifications
 We need auditing tools
 This is a start.
Conclusions
 Sandsifter lets us introspect what is 
otherwise a black box
Conclusions
 Open sourced:
 The sandsifter scanning tool
 github.com/xoreaxeaxeax/sandsifter
Conclusions
 Use sandsifter to audit your processor
 Reveal the instructions it really supports
 Search for hardware errata
 Break disassemblers,
emulators, and hypervisors
 Send us the results
Conclusions
github.com/xoreaxeaxeax
sandsifter
 M/o/Vfuscator
 REpsych
 x86 0-day PoC
 Etc.
Feedback?  Ideas?
domas
@xoreaxeaxeax
PI:EMAIL