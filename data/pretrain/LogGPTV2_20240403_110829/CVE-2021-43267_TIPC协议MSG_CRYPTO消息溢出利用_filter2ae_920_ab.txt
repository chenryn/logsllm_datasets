            *_skb = skb;
        }
        if (unlikely(TIPC_SKB_CB(skb)->validated))
            return true;
        if (unlikely(!pskb_may_pull(skb, MIN_H_SIZE)))
            return false;
        hsz = msg_hdr_sz(buf_msg(skb));                    // data指针（存储数据包的内容和各层协议头, 这里是tipc_msg结构, 参考CVE-2017-6074对sk_buff的分析）; msg_hdr_sz() 取 hsz = (tipc_msg->hdr[0]>>21 & 0xf)  MAX_H_SIZE))        // 满足 hsz 在 24~60 之间
            return false;
        if (unlikely(!pskb_may_pull(skb, hsz)))
            return false;
        hdr = buf_msg(skb);
        if (unlikely(msg_version(hdr) != TIPC_VERSION))
            return false;
        msz = msg_size(hdr);                            // hdr[0] & 0x1fff
        if (unlikely(msz  TIPC_MAX_USER_MSG_SIZE))            // 满足 msz-hszlen len > msz; 注意skb->len表示数据区的总长度: (tail - data) + 分片结构体数据区的长度
            return false;
        TIPC_SKB_CB(skb)->validated = 1;
        return true;
    }
    // TIPC 消息结构
    struct tipc_msg {
        __be32 hdr[15];
    };
    static inline u32 msg_hdr_sz(struct tipc_msg *m)
    {
        return msg_bits(m, 0, 21, 0xf) data;
    }
**TIPC消息头检查总结** ：
  * `[1-2]`处 —— TIPC消息的 `hsz` – `header size` 在 24~60 字节之间；
  * `[1-2]`处 —— `msz` – `msg size` 满足 `skb->len > msz`（注意`skb->len`表示数据区的总长度：(tail – data) + 分片结构体数据区的长度）。
####  1-2. 漏洞分析
**`MSG_CRYPTO` 消息结构**：2020年9月引入了一个新的用户消息类型——
`MSG_CRYPTO`，该消息类型允许节点发送加密的秘钥。该消息结构如下所示：[tipc_aead_key](https://elixir.bootlin.com/linux/v5.14.15/source/include/uapi/linux/tipc.h#L241)
`MSG_CRYPTO`消息跟在TIPC消息头之后（偏移24处开始）。
    #define TIPC_AEAD_ALG_NAME        (32)
    struct tipc_aead_key {
        char alg_name[TIPC_AEAD_ALG_NAME];        // TIPC_AEAD_ALG_NAME 32
        unsigned int keylen;    /* in bytes */
        char key[];
    };
**`MSG_CRYPTO` 消息处理**：消息接收后，TIPC
kernel模块需要复制该信息到该节点来存储：[tipc_crypto_key_rcv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/crypto.c#L2281)
**调用路径** ：（[struct tipc_media
udp_media_inf](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/udp_media.c#L845)
->
[tipc_udp_enable()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/udp_media.c#L775)
->
[tipc_udp_recv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/udp_media.c#L390)）
|
[tipc_l2_rcv_msg()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/bearer.c#L652)
->
[tipc_rcv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/node.c#L2145)
->
[tipc_link_rcv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/link.c#L1835)
->
[tipc_link_input()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/link.c#L1330)
->
[tipc_data_input()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/link.c#L1301)
->
[tipc_crypto_msg_rcv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/crypto.c#L2173)
->
[tipc_crypto_key_rcv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/crypto.c#L2281)
    static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
    {
        struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
        struct tipc_aead_key *skey = NULL;
        u16 key_gen = msg_key_gen(hdr);
        u16 size = msg_data_sz(hdr);                // [2-1] size = msg_size(m) - msg_hdr_sz(m)    = msz - hsz
        u8 *data = msg_data(hdr);                    // data = *hdr + hsz    MSG_CRYPTO消息的拷贝起始地址，也即 tipc_aead_key 结构的起始地址
        spin_lock(&rx->lock);
        if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
            pr_err("%s: key existed , gen %d vs %d\n", rx->name,
                   rx->skey, key_gen, rx->key_gen);
            goto exit;
        }
        /* Allocate memory for the key */
        skey = kmalloc(size, GFP_ATOMIC);            // [2-2] 分配空间，分配的 size =  msg - hsz, 而 msz 和 hsz 都来自 TIPC 消息 (tipc_msg 结构)
        if (unlikely(!skey)) {
            pr_err("%s: unable to allocate memory for skey\n", rx->name);
            goto exit;
        }
        /* Copy key from msg data */
        skey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME))); // [2-3] 拷贝长度 skey->keylen 来自偏移 *(*data+32), 未对该值进行范围检查
        memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);                // [2-4] 拷贝算法名称, TIPC_AEAD_ALG_NAME = 32字节
        memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),    // [2-5] 拷贝密钥, 越界 
               skey->keylen);
        /* Sanity check */
        if (unlikely(size != tipc_aead_key_size(skey))) {                // [2-6] 必须满足 size == sizeof(*skey) + skey->keylen, 这个检查已经晚了, 溢出已经发生了！！！！！
            kfree(skey);
            skey = NULL;
            goto exit;
        }
        rx->key_gen = key_gen;
        rx->skey_mode = msg_key_mode(hdr);
        rx->skey = skey;
        rx->nokey = 0;
        mb(); /* for nokey flag */
    exit:
        spin_unlock(&rx->lock);
        /* Schedule the key attaching on this crypto */
        if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
            return true;
        return false;
    }
**`MSG_CRYPTO`消息处理漏洞总结**：TIPC消息（[tipc_msg](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/msg.h#L148)结构）的数据部分指向`MSG_CRYPTO`消息（[tipc_aead_key](https://elixir.bootlin.com/linux/v5.14.15/source/include/uapi/linux/tipc.h#L241)结构），在分配`tipc_aead_key`
空间并拷贝 `tipc_aead_key->key`
时，未校验`tipc_aead_key->keylen`的有效性，导致拷贝越界。拷贝越界之后才检查keylen的有效性，为时已晚——`[2-6]`。只对TIPC消息的
`header size` 和 `msg size` 进行检查，却没有对
`MSG_CRYPTO`消息的`tipc_aead_key->keylen`进行检查。
**利用思路** ：攻击者可以创建一个`tipc_msg->size`
较小的TIPC消息来分配堆内存，再设置`tipc_aead_key->keylen`较大的`MSG_CRYPTO` 消息来触发越界写，触发漏洞的
`MSG_CRYPTO` 消息示例如下：
* * *
## 2\. 触发漏洞
####  2-1. 交互方式
**shell交互**
：编译时开启TIPC或者加载TIPC模块后，可通过shell来与TIPC交互，采用`iproute2`中的`tipc`命令（可以采用buildroot来编译文件系统，开启iproute2选项后，文件系统中就含有tipc命令）。使能`UDP
bearer media`的具体命令是`tipc bearer enable media udp name  localip
`。
**code交互** ：用户层可以使用netlink消息（`AF_TIPC`地址族）来使能`UDP bearer
media`，非特权用户也可以。所以即使没有配置TIPC，也能完成利用。
####  2-2. 到达漏洞点
**思路** ：首先我们要使自己成为一个有效的node，并创建一个link，接着触发`MSG_CRYPTO`代码路径。参考TIPC的[protocol
specification](http://tipc.sourceforge.net/protocol.html)页面，可以了解传输、寻址、数据分片的细节。
**方法** ：exp作者通过PCAP抓包分析`tipc-over-udp
session`建立的过程，最后确定了我们发送消息前必发的几个包。总的来说，一个正常的TIPC数据包前面包含一个header，也即6个32字节（大端序），我们标记为w0~w5。w0编码了TIPC版本、header
size、payload size、message
protocol，还有个flag表示是否为顺序消息；w1表示协议消息的类型；w3包含一个`node_id`，表示node的标识符，一般用IPv4地址表示`node_id`。可通过[`net/tipc/msg.h`](https://elixir.bootlin.com/linux/latest/source/net/tipc/msg.h)
文件来了解header格式。
**创建有效node link过程** ：发送3个包。
  * `LINK_CONFIG` 包会广告自己；
  * `LINK_PROTOCOL` 包（`RESET_MSG`消息类型）会重置link；
  * `LINK_PROTOCOL` 包（`STATE_MSG`消息类型）会提出link；
  * 现在可以发送`MSG_CRYPTO` TIPC 包来触发堆溢出。
    protocol: LINK_CONFIG   -> message type: DSC_REQ_MSG
    protocol: LINK_PROTOCOL -> message type: RESET_MSG
    protocol: LINK_PROTOCOL -> message type: STATE_MSG
####  2-3. 触发漏洞