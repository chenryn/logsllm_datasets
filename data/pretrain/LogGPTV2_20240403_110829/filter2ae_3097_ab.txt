调试器和反汇编程序可以导入这些符号，这些符号会使我们的测试更轻松，因为每个函数都将通过源代码中的实际名称重命名。
#### 附加调试器
Chromium作为一个复杂的软件会将多个进程通信连接在一起，这使得调试更加困难。
调试它的最有效方法是正常启动`Chromium`，然后将调试器附加到要利用的进程中。
我们正在调试的代码会在渲染器进程中运行，下面我们分析的函数是由`chrome_child.dll`公开的。
如果要在`x64dbg`中导入符号，这里的解决方案是进入符号窗格，右键单击要导入符号的`.dll/.exe`，然后选择下载符号。
如果未正确配置符号服务器设置，它可能会失败，但它仍将在`x64dbg`的`symbols`目录中创建目录结构，我们可以在其中放置先前下载的.pdb文件。
#### 寻找可利用的代码路径
我们已经下载了未修补的Chromium版本，并且我们知道如何附加调试器。下面就需要我们编写一些JavaScript来查看是否可以访问我们的代码路径。
我们创建了一个传递给`FileReader`的Blob文件。我们注册了一个对`progress`事件的回调，并且在调用事件时进行多次访问，之前我们已经看到数据需要完全加载（这就是我们检查缓冲区大小的原因），如果我们使用相同的后台`ArrayBuffer`获得多个`DOMArrayBuffer`，它们应该将对象分离为`JavaScript`。最后，为了查证我们确实有两个不同的对象由相同的缓冲区存储，我们创建视图来修改底层数据。
我们遇到了另一个问题：进度事件不经常被调用，因此我们必须加载一个非常大的数组，以强制进程多次触发事件。加载与`Mojo`管道绑定，因此暴露`MojoJS`可能是一种新的控制方式，然而在攻击者看来这似乎不切实际。
#### 碰撞的产生
那么，既然我们已经弄清楚如何进入代码路径，我们如何利用它呢？
我们已经看到底层的`ArrayBuffer`被重新计算，所以我们不太可能通过从我们获得的一些`DOMArrayBuffer`中进行释放。溢出`refcount`似乎可行，但如果我们手动修改`refcount`值接近其最大值（通过x64dbg）会造成进程崩溃。最后，我们不能对那些`ArrayBuffers`做太多事情。我们可以改变他们的内容而不是他们的尺寸，也不能手动释放。对代码库不够熟悉，最好的方法是提交各种错误报告，并查看人们的一些谈论。这里我们必须假设`DOMArrayBuffer`拥有其底层内存。经过一番搜索后，我们发现两个链接讨论了`DOMArrayBuffer`可以被外部化，并进行转移操作。我们不熟悉这些术语，但从上下文来看，当发生这种情况时，内存的所有权会转移给其他人。由于我们希望将底层的缓冲区进行释放，所以这对我们来说可以使用。
### 利用过程注意事项和后续步骤
### 如何利用漏洞
本文档的重点不是说明如何越权免费版本后以获得完整的代码执行（事实上，Exodus发布了一个博客和一个漏洞声明，大致与本文的发布时间一致）。由于我们利用`free-after-free`的方式使得我们最终得到了一个非常大的缓冲区。利用`free-after-free`的通常方法是在释放区域之上分配新的对象以产生混淆。在这里，我们释放用于支持`ArrayBuffer`数据的原始内存。我们可以读取/写入大的区域。然而，这种方法同样存在一个问题，因为内存区域非常大，所以没有一个对象可以适应。如果我们有一个小的缓冲区，我们可以创建大量具有特定大小的对象，并将数据在此处进行分配。然而我们需要等待，直到堆为不相关的对象回收内存。在Windows
10 64位系统上，由于随机分配的方式以及随机地址可用的熵，因此此过程很难实现。在Windows 7
32位上，由于地址空间要小得多，因此堆分配更具确定性。分配10k对象可能足以让我们可以控制地址空间中的一些元数据。  
第二个原因是因为我们要取消引用一个未映射的区域，如果上面提到的10k分配无法在我们控制的那个区域中分配至少一个对象，那么我们就无法对其进行实习。我们会使得访问冲突，该进程会被终止。然而下面有另一种方法能够破坏JavaScript对象的元数据。
#### 下一步操作
一旦攻击者在渲染器进程内获得代码执行的权限，他们仍然会受到沙箱的限制。 在网络发现的攻击中，攻击者使用第二个0 day攻击Windows内核以逃离沙箱。
最近由360CoreSec发布了一篇描述该漏洞的文章。
### 总结
通过查看修复错误并查找提示进行提交，我们能够恢复出攻击所利用的途径。我们可以看到，在Windows的后期版本中引入的机制使得安全性更高。此外，Google在漏洞修补方面表现的非常积极，其大部分用户群已经无缝更新到最新版本的Chrome。
### 参考资料
[1]   
[2]   
[2b]   
[3]
[3b]
[4a]
[4b]
[5]   
[6a]
[6b]   
[7]   
[8]   
[9]   
[10a]   
[10b]   
[11]   
[12]   
[13] 
    本文来自：https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/analysis-of-a-chrome-zero-day-cve-2019-5786/