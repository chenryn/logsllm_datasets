### Verified Vulnerability Population in the Wild

We believe that the increase in SSL vulnerabilities, as shown in Figure 2, does not necessarily indicate a need for increased black-box scanning. A significant number of SSL vulnerabilities were reported in 2009, leading to an upward trend in SSL incidents. However, these vulnerabilities are primarily certificate spoofing issues, where a certificate issued for one domain name, often containing a null character, can be validated for another domain name [14], [15]. This type of vulnerability is caused by mistakes made by the certificate authority and the client application (typically a browser), and cannot be prevented or detected by the website operator. Therefore, the number of SSL/server configuration vulnerabilities that web application scanners can reasonably aim to detect does not appear to increase with the reported SSL vulnerability incidence rate.

### Previously-Reported vs. Scanner-Found Vulnerabilities for Drupal, PHPBB2, and WordPress

**Table III: Vulnerability Detection in Popular Web Applications**

| Category | XSS | SQLI | XCS | Session | CSRF | Info Leak |
|----------|-----|------|-----|---------|------|-----------|
| **Drupal 4.7.0** | Known: 6, Found: 2 | Known: 2, Found: 1 | Known: 4, Found: 0 | Known: 5, Found: 4 | Known: 2, Found: 0 | Known: 4, Found: 3 |
| **phpBB2 2.0.19** | Known: 5, Found: 2 | Known: 1, Found: 1 | Known: 1, Found: 0 | Known: 4, Found: 4 | Known: 1, Found: 0 | Known: 1, Found: 1 |
| **WordPress 1.5 Strayhorn** | Known: 13, Found: 7 | Known: 8, Found: 4 | Known: 8, Found: 3 | Known: 6, Found: 5 | Known: 1, Found: 1 | Known: 6, Found: 4 |

Figures 2 and 3 suggest that 2006 was a particularly high-incident year for web application vulnerabilities, with a subsequent decrease in incidents. This trend is also confirmed by searches in the CVE database. While it is impossible to be certain, the effectiveness of the scanners in detecting basic XSS and SQLI vulnerabilities suggests that the decrease may be attributable to progress made by the security community against these vulnerabilities. However, this improvement has been met with efforts to uncover more novel forms of vulnerabilities.

### Scanner Results on Common Web Applications

Having confirmed that the testing vector distribution of black-box web vulnerability scanners roughly correlates with the vulnerability population trends in the wild, we now examine whether the scanners are successful at finding existing vulnerabilities. We ran all scanners on three popular web applications: Drupal, phpBB2, and WordPress, all with known vulnerabilities. We chose to scan versions released around January 2006, prior to the peak in vulnerability reports in 2006. While these are field applications with some inherent uncertainty regarding their exact vulnerability content, the early release dates mean these versions are the most field-tested, with most vulnerabilities likely recorded by VUPEN via the NVD.

Table III lists the specific application versions tested, along with the number of known vulnerabilities, including those reported by the VUPEN database for each version. For all applications, we installed only the default modules and included no add-ons.

The table shows that the scanners did a generally good job of detecting previously known vulnerabilities, particularly in the Information Disclosure and Session Management categories. This suggests that effective test vectors are easier to add for these categories. The scanners also performed reasonably well in detecting XSS and SQLI vulnerabilities, with about a 50% detection rate for both. The low detection rate in the CSRF category may be due to the small number of CSRF test vectors. Anecdotally, one scanner vendor confirmed that they do not report CSRF vulnerabilities due to the difficulty of determining which forms in the application require protection from CSRF.

### Scanner Results on Custom Testbed

In addition to testing scanner detection performance on established web applications, we evaluated the scanners in a controlled environment. We developed a custom testbed application containing hand-inserted vulnerabilities, each with a proven attack pattern. We verified each vulnerability, allowing for significantly smaller uncertainty in vulnerability content than in field-deployed applications. (The scanners as a group did not uncover any unintended vulnerabilities in our web application.) We plan to release this testbed publicly.

For each vulnerability classification, we incorporated both "textbook" instances and forward-looking instances, such as XSS with non-standard tags. However, we kept the vulnerability content of our testbed fairly proportional to the vulnerability population in the wild.

Our testbed has around 50 unique URLs and around 3000 lines of code, installed on a Linux 2.6.18-128.1.6.el5 server running Apache 2.2.3, MySQL 5.0.45, and PHP 5.1.6. PhpMyAdmin was also running on our server for administrative purposes, and we ignored any scanner results related to it.

#### A. Scanner Time and Network Footprint

Figures 4a and 4b plot the time required to scan the testbed application and the number of network bytes sent/received by each scanner, as measured on the web server by tcpdump. Scanning time ranged from 66 to 473 minutes, while network traffic ranged from 80 MB to nearly 1 GB. Surprisingly, scanning time and network traffic statistics seem to be relatively independent of each other, as exemplified by the Rapid7, Qualys, N-Stalker, and McAfee results. It is interesting that the two remote services, Qualys and McAfee, generated comparatively low amounts of network traffic. Finally, it is important to note that the footprint statistics are not indicative of vulnerability detection performance.

#### B. Coverage Results

To experimentally evaluate site coverage, we wrote hyperlinks using the technology in each category shown in Figure 5 and embedded each landing page with tracker code to measure whether the link was followed. For Java, SilverLight, and Flash, the linked applet or movie is a simple, bare shell containing only the hyperlink. We then linked to the technology page from the application home page, written in regular PHP.

The link encoding category encompasses links written in hexadecimal, decimal, octal, and HTML encodings, with the landing page file named in regular ASCII. The "POST link" test involves a link that only appears when certain selections are made on a POST form. The other technologies are self-explanatory. Figure 5 shows the experimental results, where the measure is the percentage of successful links crawled over total existent links by technology category.

Figure 5 indicates that the scanners as a group have relatively low comprehension of active technologies such as Java applets, SilverLight, and, surprisingly, Flash. We speculate that some scanners only perform textual analysis of HTTP responses to collect URLs, allowing them to perform decently on script-based links but not on links embedded in compiled objects like Java applets and Flash movies. This would also explain the better coverage of SilverLight over Flash and Java, as SilverLight is delivered in a text-based markup language. The scanners could also improve their understanding of various link encodings.

#### C. Vulnerability Detection Results

1. **Overall Results**: Figure 6 presents the average vulnerability detection rate by classification, calculated as the number of vulnerabilities found over the known total number of vulnerabilities. Detailed results for each vulnerability classification, including an added malware detection classification, are explained in individual sub-sections to follow. Each sub-section describes the testbed for the category, plots the average detection rate over all scanners, and also plots anonymous individual scanner results for the category, sorted from best- to worst-performing.

The results show that the scanners as a group are fairly effective at detecting basic "reflected" cross-site scripting (XSS type 1), with a detection rate of over 60%. Additionally, although not shown, basic forms of first-order SQL Injection were detected by a majority of scanners. Unfortunately, the overall results for the first-order SQL vulnerability detection were less encouraging.