### Experiment: Examining the Default Security Descriptor of ETW Sessions

A kernel debugger can easily display the default security descriptor associated with ETW sessions that do not have a specific one. For this experiment, you will need a Windows 10 machine with a kernel debugger already attached and connected to a host system. Alternatively, you can use a local kernel debugger or LiveKd (available at [https://docs.microsoft.com/en-us/sysinternals/downloads/livekd](https://docs.microsoft.com/en-us/sysinternals/downloads/livekd)).

After configuring the correct symbols, you can dump the default security descriptor using the following command:
```plaintext
!sd poi(nt!EtwpDefaultTraceSecurityDescriptor)
```

The output should be similar to the following (truncated for brevity):

- **Revision**: 0x1
- **Sbz1**: 0x0
- **Control**: 0x8004
  - SE_DACL_PRESENT
  - SE_SELF_RELATIVE
- **Owner**: S-1-5-32-544
- **Group**: S-1-5-32-544
- **Dacl**:
  - **AclRevision**: 0x2
  - **Sbz1**: 0x0
  - **AclSize**: 0xf0
  - **AceCount**: 0x9
  - **Sbz2**: 0x0
  - **Ace[0]**:
    - **AceType**: ACCESS_ALLOWED_ACE_TYPE
    - **AceFlags**: 0x0
    - **AceSize**: 0x14
    - **Mask**: 0x00001800
    - **SID**: S-1-1-0
  - **Ace[1]**:
    - **AceType**: ACCESS_ALLOWED_ACE_TYPE
    - **AceFlags**: 0x0
    - **AceSize**: 0x14
    - **Mask**: 0x00120fff
    - **SID**: S-1-5-18
  - **Ace[2]**:
    - **AceType**: ACCESS_ALLOWED_ACE_TYPE
    - **AceFlags**: 0x0
    - **AceSize**: 0x14
    - **Mask**: 0x00120fff
    - **SID**: S-1-5-19
  - **Ace[3]**:
    - **AceType**: ACCESS_ALLOWED_ACE_TYPE
    - **AceFlags**: 0x0
    - **AceSize**: 0x14
    - **Mask**: 0x00120fff
    - **SID**: S-1-5-20
  - **Ace[4]**:
    - **AceType**: ACCESS_ALLOWED_ACE_TYPE
    - **AceFlags**: 0x0
    - **AceSize**: 0x18
    - **Mask**: 0x00120fff
    - **SID**: S-1-5-32-544
  - **Ace[5]**:
    - **AceType**: ACCESS_ALLOWED_ACE_TYPE
    - **AceFlags**: 0x0
    - **AceSize**: 0x18
    - **Mask**: 0x00000ee5
    - **SID**: S-1-5-32-559
  - **Ace[6]**:
    - **AceType**: ACCESS_ALLOWED_ACE_TYPE
    - **AceFlags**: 0x0
    - **AceSize**: 0x18
    - **Mask**: 0x00000004
    - **SID**: S-1-5-32-558

You can use the `Psgetsid` tool (available at [https://docs.microsoft.com/en-us/sysinternals/downloads/psgetsid](https://docs.microsoft.com/en-us/sysinternals/downloads/psgetsid)) to translate the SIDs into human-readable names. From the output, you can see that all ETW access is granted to the SYSTEM (S-1-5-18), LOCAL SERVICE (S-1-5-19), NETWORK SERVICE (S-1-5-20), and Administrators (S-1-5-32-544) groups. The Performance Log Users group (S-1-5-32-559) has almost all ETW access, while the Performance Monitor Users group (S-1-5-32-558) has only the WMIGUID_NOTIFICATION access right.

#### Example: Translating SIDs
```plaintext
C:\Users\andrea>psgetsid64 S-1-5-32-559
PsGetSid v1.45 - Translates SIDs to names and vice versa
Copyright (C) 1999-2016 Mark Russinovich
Sysinternals - www.sysinternals.com
Account for AALL86-LAPTOP\S-1-5-32-559:
Alias: BUILTIN\Performance Log Users
```

### Security Audit Logger

The Security Audit logger is an ETW session used by the Windows Event logger service (wevtsvc.dll) to listen for events generated by the Security Lsass Provider. The Security Lsass provider (identified by the {54849625-5478-4994-a5ba-3e3b0328c30d} GUID) can only be registered by the NT kernel during ETW initialization and is never inserted into the global provider's hash table. Only the Security audit logger and Autologgers configured with the `EnableSecurityProvider` registry value set to 1 can receive events from the Security Lsass Provider. When the `EtwStartAutoLogger` internal function encounters this value, it enables the `SECURITY_TRACE` flag on the associated ETW session, allowing the session to receive Security audit events.

This flag also ensures that user-mode applications cannot query, stop, flush, or control the session unless they are running as protected processes (at the antimalware, Windows, or WinTcb level; more details on protected processes are available in Chapter 3 of Part 1).

### Secure Loggers

Classic (MOF) and WPP providers were not designed to support all the security features implemented for manifest-based and tracelogging providers. An Autologger or a generic ETW session can be created with the `EVENT_TRACE_SECURE_MODE` flag, which marks the session as secure. A secure session ensures that it receives events only from trusted identities. This flag has two main effects:

1. **Prevents classic (MOF) and WPP providers from writing any event to the secure session.** If a classic provider is enabled in a secure section, it won't be able to generate any events.
2. **Requires the supplemental `TRACELOG_LOG_EVENT` access right.** This right must be granted by the session’s security descriptor to the controller application’s access token while enabling a provider to the secure session.

The `TRACE_LOG_EVENT` access right allows for more granular security in a session’s security descriptor. If the security descriptor grants only the `TRACELOG_GUID_ENABLE` to an untrusted user, and the ETW session is created as secure by another entity (a kernel driver or a more privileged application), the untrusted user cannot enable any provider on the secure section. If the section is created as non-secure, the untrusted user can enable any providers on it.

### Dynamic Tracing (DTrace)

Event Tracing for Windows (ETW) is a powerful tracing technology integrated into the OS, but it is static, meaning that users can only trace and log events generated by well-defined components. To overcome this limitation, the May 2019 Update of Windows 10 (19H1) introduced DTrace, a dynamic tracing facility. DTrace can be used by administrators on live systems to examine the behavior of both user programs and the operating system itself. DTrace is an open-source technology originally developed for Solaris and ported to several other operating systems, including Windows.

DTrace can dynamically trace parts of the operating system and user applications at certain locations of interest, called probes. A probe is a binary code location or activity to which DTrace can bind a request to perform actions like logging messages, recording a stack trace, or a timestamp. When a probe fires, DTrace gathers the data and executes the associated actions. Both the probes and actions are specified in a script file (or directly in the DTrace application through the command line) using the D programming language. Support for probes is provided by kernel modules called providers. At the time of writing, Windows supports the following providers:

- **SYSCALL**: Allows tracing of OS system calls (both on entry and exit) invoked from user-mode applications and kernel-mode drivers (through Zw APIs).
- **FBT (Function Boundary Tracing)**: Enables tracing of individual functions implemented in all modules running in the NT kernel.
- **PID (User-mode process tracing)**: Similar to FBT, it allows tracing of individual functions of a user-mode process and application.
- **ETW (Event Tracing for Windows)**: DTrace can use this provider to attach to manifest-based and TraceLogging events fired from the ETW engine. DTrace can define new ETW providers and provide associated ETW events via the `etw_trace` action.
- **PROFILE**: Provides probes associated with a time-based interrupt firing every fixed, specified time interval.
- **DTRACE**: Built-in provider implicitly enabled in the DTrace engine.

These providers allow system administrators to dynamically trace almost every component of the Windows operating system and user-mode applications.

#### Note
There are significant differences between the first version of DTrace for Windows (May 2019 Update) and the current stable release (May 2021 edition). One notable difference is that the initial release required a kernel debugger to enable the FBT provider, and the ETW provider was not fully available.

### Experiment: Enabling DTrace and Listing Installed Providers

In this experiment, you will install and enable DTrace and list the providers available for dynamically tracing various Windows components. You need a system with Windows 10 May 2020 Update (20H1) or later installed. As per Microsoft documentation ([https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/dtrace](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/dtrace)), you should first enable DTrace by opening an administrative command prompt and typing the following command (remember to disable BitLocker if it is enabled):
```plaintext
bcdedit /set dtrace ON
```

After the command succeeds, download the DTrace package from [https://www.microsoft.com/download/details.aspx?id=100441](https://www.microsoft.com/download/details.aspx?id=100441) and install it. Restart your computer (or virtual machine) and open an administrative command prompt (by typing `CMD` in the Cortana search box and selecting "Run As Administrator"). Type the following commands (replace `providers.txt` with another file name if desired):
```plaintext
cd /d "C:\Program Files\DTrace"
dtrace -l > providers.txt
```

Open the generated file (`providers.txt` in the example). If DTrace has been successfully installed and enabled, a list of probes and providers (DTrace, syscall, and ETW) should be listed in the output file. Probes are composed of an ID and a human-readable name. The human-readable name is composed of four parts, each part may or may not exist depending on the provider. In general, providers try to follow the convention as closely as possible, but in some cases, the meaning of each part can be overloaded with something different:

- **Provider**: The name of the DTrace provider publishing the probe.
- **Module**: If the probe corresponds to a specific program location, the name of the module in which the probe is located. The module is used only for the PID (which is not shown in the output produced by the `dtrace -l` command) and ETW provider.
- **Function**: If the probe corresponds to a specific program location, the name of the program function in which the probe is located.
- **Name**: The final component of the probe name, giving some idea of the probe’s semantic meaning, such as BEGIN or END.

When writing out the full human-readable name of a probe, all the parts of the name are separated by colons. For example:
```plaintext
syscall::NtQuerySystemInformation:entry
```
specifies a probe on the `NtQueryInformation` function entry provided by the syscall provider. Note that in this case, the module name is empty because the syscall provider does not specify any name (all syscalls are implicitly provided by the NT kernel).

The PID and FBT providers dynamically generate probes based on the process or kernel image to which they are applied (and based on the currently available symbols). For example, to list the PID probes of a process, first get the process ID (PID) of the process you want to analyze (e.g., Notepad, which in the test system has PID 8020). Then execute DTrace with the following command:
```plaintext
dtrace -ln pid8020:::entry > pid_notepad.txt
```

This lists all the probes on function entries generated by the PID provider for the Notepad process. The output will contain many entries. If you do not have the symbol store path set, the output will not contain any probes generated by private functions. To restrict the output, add the name of the module:
```plaintext
dtrace.exe -ln pid8020:kernelbase::entry > pid_kernelbase_notepad.txt
```

This yields all the PID probes generated for function entries of the `kernelbase.dll` module mapped in Notepad. If you repeat the previous two commands after setting the symbol store path with the following command:
```plaintext
set _NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols
```

you will find that the output is much different (and includes probes on private functions). As explained in the "The Function Boundary Tracing (FBT) and Process (PID) providers" section later in this chapter, the PID and FBT provider can be applied to any offset in a function’s code. The following command returns all the offsets (always located at instruction boundary) in which the PID provider can generate probes on the `SetComputerNameW` function of `Kernelbase.dll`:
```plaintext
dtrace.exe -ln pid8020:kernelbase:SetComputerNameW:
```

This command will list all the possible offsets within the `SetComputerNameW` function where probes can be placed.