->Dacl    : ->Ace[1]: ->AceFlags: 0x0 
->Dacl    : ->Ace[1]: ->AceSize: 0x14 
->Dacl    : ->Ace[1]: ->Mask : 0x00120fff 
->Dacl    : ->Ace[1]: ->SID: S-1-5-18 
->Dacl    : ->Ace[2]: ->AceType: ACCESS_ALLOWED_ACE_TYPE 
->Dacl    : ->Ace[2]: ->AceFlags: 0x0 
->Dacl    : ->Ace[2]: ->AceSize: 0x14 
->Dacl    : ->Ace[2]: ->Mask : 0x00120fff 
->Dacl    : ->Ace[2]: ->SID: S-1-5-19 
->Dacl    : ->Ace[3]: ->AceType: ACCESS_ALLOWED_ACE_TYPE 
->Dacl    : ->Ace[3]: ->AceFlags: 0x0 
->Dacl    : ->Ace[3]: ->AceSize: 0x14 
->Dacl    : ->Ace[3]: ->Mask : 0x00120fff 
->Dacl    : ->Ace[3]: ->SID: S-1-5-20 
->Dacl    : ->Ace[4]: ->AceType: ACCESS_ALLOWED_ACE_TYPE 
->Dacl    : ->Ace[4]: ->AceFlags: 0x0 
->Dacl    : ->Ace[4]: ->AceSize: 0x18 
->Dacl    : ->Ace[4]: ->Mask : 0x00120fff 
->Dacl    : ->Ace[4]: ->SID: S-1-5-32-544 
EXPERIMENT: Witnessing the default security descriptor of ETW sessions
A kernel debugger can easily show the default security descriptor associated with ETW sessions 
that do not have a specific one associated with them. In this experiment, you need a Windows 10 
machine with a kernel debugger already attached and connected to a host system. Otherwise, 
you can use a local kernel debugger, or LiveKd (downloadable from https://docs.microsoft.com/
en-us/sysinternals/downloads/livekd.) After the correct symbols are configured, you should be 
able to dump the default SD using the following command:
!sd poi(nt!EtwpDefaultTraceSecurityDescriptor)
The output should be similar to the following (cut for space reasons):
->Revision: 0x1
->Sbz1    : 0x0
->Control : 0x8004
SE_DACL_PRESENT
SE_SELF_RELATIVE
->Owner   : S-1-5-32-544
->Group   : S-1-5-32-544
->Dacl    : 
->Dacl    : ->AclRevision: 0x2
->Dacl    : ->Sbz1       : 0x0
->Dacl    : ->AclSize    : 0xf0
->Dacl    : ->AceCount   : 0x9
->Dacl    : ->Sbz2
: 0x0
->Dacl    : ->Ace[0]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[0]: ->AceFlags: 0x0
->Dacl    : ->Ace[0]: ->AceSize: 0x14
->Dacl    : ->Ace[0]: ->Mask : 0x00001800
->Dacl    : ->Ace[0]: ->SID: S-1-1-0
->Dacl    : ->Ace[1]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[1]: ->AceFlags: 0x0
->Dacl    : ->Ace[1]: ->AceSize: 0x14
->Dacl    : ->Ace[1]: ->Mask : 0x00120fff
->Dacl    : ->Ace[1]: ->SID: S-1-5-18
->Dacl    : ->Ace[2]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[2]: ->AceFlags: 0x0
->Dacl    : ->Ace[2]: ->AceSize: 0x14
->Dacl    : ->Ace[2]: ->Mask : 0x00120fff
->Dacl    : ->Ace[2]: ->SID: S-1-5-19
->Dacl    : ->Ace[3]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[3]: ->AceFlags: 0x0
->Dacl    : ->Ace[3]: ->AceSize: 0x14
->Dacl    : ->Ace[3]: ->Mask : 0x00120fff
->Dacl    : ->Ace[3]: ->SID: S-1-5-20
->Dacl    : ->Ace[4]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[4]: ->AceFlags: 0x0
->Dacl    : ->Ace[4]: ->AceSize: 0x18
->Dacl    : ->Ace[4]: ->Mask : 0x00120fff
->Dacl    : ->Ace[4]: ->SID: S-1-5-32-544
524 
CHAPTER 10 Management, diagnostics, and tracing
->Dacl    : ->Ace[5]: ->AceType: ACCESS_ALLOWED_ACE_TYPE 
->Dacl    : ->Ace[5]: ->AceFlags: 0x0 
->Dacl    : ->Ace[5]: ->AceSize: 0x18 
->Dacl    : ->Ace[5]: ->Mask : 0x00000ee5 
->Dacl    : ->Ace[5]: ->SID: S-1-5-32-559 
->Dacl    : ->Ace[6]: ->AceType: ACCESS_ALLOWED_ACE_TYPE 
->Dacl    : ->Ace[6]: ->AceFlags: 0x0 
->Dacl    : ->Ace[6]: ->AceSize: 0x18 
->Dacl    : ->Ace[6]: ->Mask : 0x00000004 
->Dacl    : ->Ace[6]: ->SID: S-1-5-32-558
You can use the Psgetsid tool (available at https://docs.microsoft.com/en-us/sysinternals/
downloads/psgetsid) to translate the SID to human-readable names. From the preceding output, 
you can see that all ETW access is granted to the SYSTEM (S-1-5-18), LOCAL SERVICE (S-1-5-19), 
NETWORK SERVICE (S-1-5-18), and Administrators (S-1-5-32-544) groups. As explained in the pre-
vious section, the Performance Log Users group (S-1-5-32-559) has almost all ETW access, where-
as the Performance Monitor Users group (S-1-5-32-558) has only the WMIGUID_NOTIFICATION 
access right granted by the session’s default security descriptor.
C:\Users\andrea>psgetsid64 S-1-5-32-559 
PsGetSid v1.45 - Translates SIDs to names and vice versa 
Copyright (C) 1999-2016 Mark Russinovich 
Sysinternals - www.sysinternals.com 
Account for AALL86-LAPTOP\S-1-5-32-559: 
Alias: BUILTIN\Performance Log Users
Security Audit logger
The Security Audit logger is an ETW session used by the Windows Event logger service (wevtsvc.dll) to 
listen for events generated by the Security Lsass Provider. The Security Lsass provider (which is identi-
fied by the {54849625-5478-4994-a5ba-3e3b0328c30d} GUID) can be registered only by the NT kernel 
at ETW initialization time and is never inserted in the global provider’s hash table. Only the Security 
audit logger and Autologgers configured with the EnableSecurityProvider registry value set to 1 can re-
ceive events from the Security Lsass Provider. When the EtwStartAutoLogger internal function encoun-
ters the value set to 1, it enables the SECURITY_TRACE flag on the associated ETW session, adding the 
session to the list of loggers that can receive Security audit events.
The flag also has the important effect that user-mode applications can’t query, stop, flush, or control 
the session anymore, unless they are running as protected process light (at the antimalware, Windows, 
or WinTcb level; further details on protected processes are available in Chapter 3 of Part 1).
Secure loggers
Classic (MOF) and WPP providers have not been designed to support all the security features imple-
mented for manifest-based and tracelogging providers. An Autologger or a generic ETW session can 
->Dacl    : ->Ace[5]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[5]: ->AceFlags: 0x0
->Dacl    : ->Ace[5]: ->AceSize: 0x18
->Dacl    : ->Ace[5]: ->Mask : 0x00000ee5
->Dacl    : ->Ace[5]: ->SID: S-1-5-32-559
->Dacl    : ->Ace[6]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[6]: ->AceFlags: 0x0
->Dacl    : ->Ace[6]: ->AceSize: 0x18
->Dacl    : ->Ace[6]: ->Mask : 0x00000004
->Dacl    : ->Ace[6]: ->SID: S-1-5-32-558
You can use the Psgetsid tool (available at https://docs.microsoft.com/en-us/sysinternals/
downloads/psgetsid) to translate the SID to human-readable names. From the preceding output, 
you can see that all ETW access is granted to the SYSTEM (S-1-5-18), LOCAL SERVICE (S-1-5-19), 
NETWORK SERVICE (S-1-5-18), and Administrators (S-1-5-32-544) groups. As explained in the pre-
vious section, the Performance Log Users group (S-1-5-32-559) has almost all ETW access, where-
as the Performance Monitor Users group (S-1-5-32-558) has only the WMIGUID_NOTIFICATION
access right granted by the session’s default security descriptor.
C:\Users\andrea>psgetsid64 S-1-5-32-559
PsGetSid v1.45 - Translates SIDs to names and vice versa
Copyright (C) 1999-2016 Mark Russinovich
Sysinternals - www.sysinternals.com
Account for AALL86-LAPTOP\S-1-5-32-559:
Alias: BUILTIN\Performance Log Users
CHAPTER 10 Management, diagnostics, and tracing
525
thus be created with the EVENT_TRACE_SECURE_MODE flag, which marks the session as secure. A 
secure session has the goal of ensuring that it receives events only from trusted identities. The flag has 
two main effects:
I 
Prevents classic (MOF) and WPP providers from writing any event to the secure session. If a clas-
sic provider is enabled in a secure section, the provider won’t be able to generate any events.
I 
Requires the supplemental TRACELOG_LOG_EVENT access right, which should be granted by
the session’s security descriptor to the controller application’s access token while enabling a
provider to the secure session.
The TRACE_LOG_EVENT access right allows a more-granular security to be specified in a session’s 
security descriptor. If the security descriptor grants only the TRACELOG_GUID_ENABLE to an untrusted 
user, and the ETW session is created as secure by another entity (a kernel driver or a more privileged 
application), the untrusted user can’t enable any provider on the secure section. If the section is created 
as nonsecure, the untrusted user can enable any providers on it.
Dynamic tracing (DTrace)
As discussed in the previous section, Event Tracing for Windows is a powerful tracing technology inte-
grated into the OS, but it’s static, meaning that the end user can only trace and log events that are gen-
erated by well-defined components belonging to the operating system or to third-party frameworks/
applications (.NET CLR, for example.) To overcome the limitation, the May 2019 Update of Windows 
10 (19H1) introduced DTrace, the dynamic tracing facility built into Windows. DTrace can be used by 
administrators on live systems to examine the behavior of both user programs and of the operating 
system itself. DTrace is an open-source technology that was developed for the Solaris operating system 
(and its descendant, illumos, both of which are Unix-based) and ported to several operating systems 
other than Windows. 
DTrace can dynamically trace parts of the operating system and user applications at certain locations 
of interest, called probes. A probe is a binary code location or activity to which DTrace can bind a request 
to perform a set of actions, like logging messages, recording a stack trace, a timestamp, and so on. When 
a probe fires, DTrace gathers the data from the probe and executes the actions associated with the probe. 
Both the probes and the actions are specified in a script file (or directly in the DTrace application through 
the command line), using the D programming language. Support for probes are provided by kernel mod-
ules, called providers. The original illumos DTrace supported around 20 providers, which were deeply tied 
to the Unix-based OS. At the time of this writing, Windows supports the following providers:
I 
SYSCALL Allows the tracing of the OS system calls (both on entry and on exit) invoked from
user-mode applications and kernel-mode drivers (through Zw APIs).
I 
FBT (Function Boundary tracing) Through FBT, a system administrator can trace the execution
of individual functions implemented in all the modules that run in the NT kernel.
I 
PID (User-mode process tracing) The provider is similar to FBT and allows tracing of individual
functions of a user-mode process and application.
526 
CHAPTER 10 Management, diagnostics, and tracing
I 
ETW (Event Tracing for Windows) DTrace can use this provider to attach to manifest-based and
TraceLogging events fired from the ETW engine. DTrace is able to define new ETW providers and
provide associated ETW events via the etw_trace action (which is not part of any provider).
I 
PROFILE Provides probes associated with a time-based interrupt firing every fixed, specified
time interval.
I 
DTRACE Built-in provider is implicitly enabled in the DTrace engine.
The listed providers allow system administrators to dynamically trace almost every component of 
the Windows operating system and user-mode applications.
Note There are big differences between the first version of DTrace for Windows, which 
appeared in the May 2019 Update of Windows 10, and the current stable release (distributed 
at the time of this writing in the May 2021 edition of Windows 10). One of the most notable 
differences is that the first release required a kernel debugger to be set up to enable the FBT 
provider. Furthermore, the ETW provider was not completely available in the first release 
of DTrace.
EXPERIMENT: Enabling DTrace and listing the installed providers
In this experiment, you install and enable DTrace and list the providers that are available for 
dynamically tracing various Windows components. You need a system with Windows 10 May 
2020 Update (20H1) or later installed. As explained in the Microsoft documentation (https://docs.
microsoft.com/en-us/windows-hardware/drivers/devtest/dtrace), you should first enable DTrace 
by opening an administrative command prompt and typing the following command (remember 
to disable Bitlocker, if it is enabled):
bcdedit /set dtrace ON
After the command succeeds, you can download the DTrace package from https://www.
microsoft.com/download/details.aspx?id=100441 and install it. Restart your computer (or virtual 
machine) and open an administrative command prompt (by typing CMD in the Cortana search 
box and selecting Run As Administrator). Type the following commands (replacing provid-
ers.txt with another file name if desired):
cd /d “C:\Program Files\DTrace” 
dtrace -l > providers.txt
Open the generated file (providers.txt in the example). If DTrace has been successfully 
installed and enabled, a list of probes and providers (DTrace, syscall, and ETW) should be listed in 
the output file. Probes are composed of an ID and a human-readable name. The human-readable 
name is composed of four parts. Each part may or may not exist, depending on the provider. In 
general, providers try to follow the convention as close as possible, but in some cases the mean-
ing of each part can be overloaded with something different:
I 
Provider The name of the DTrace provider that is publishing the probe.
EXPERIMENT: Enabling DTrace and listing the installed providers
In this experiment, you install and enable DTrace and list the providers that are available for 
dynamically tracing various Windows components. You need a system with Windows 10 May 
2020 Update (20H1) or later installed. As explained in the Microsoft documentation (https://docs.
microsoft.com/en-us/windows-hardware/drivers/devtest/dtrace), you should first enable DTrace 
by opening an administrative command prompt and typing the following command (remember 
to disable Bitlocker, if it is enabled):
bcdedit /set dtrace ON
After the command succeeds, you can download the DTrace package from https://www.
microsoft.com/download/details.aspx?id=100441 and install it. Restart your computer (or virtual 
machine) and open an administrative command prompt (by typing CMD in the Cortana search 
box and selecting Run As Administrator). Type the following commands (replacing provid-
ers.txt with another file name if desired):
cd /d “C:\Program Files\DTrace”
dtrace -l > providers.txt
Open the generated file (providers.txt in the example). If DTrace has been successfully 
installed and enabled, a list of probes and providers (DTrace, syscall, and ETW) should be listed in 
the output file. Probes are composed of an ID and a human-readable name. The human-readable 
name is composed of four parts. Each part may or may not exist, depending on the provider. In 
general, providers try to follow the convention as close as possible, but in some cases the mean-
ing of each part can be overloaded with something different:
I
Provider
The name of the DTrace provider that is publishing the probe.
CHAPTER 10 Management, diagnostics, and tracing
527
I 
Module If the probe corresponds to a specific program location, the name of the module
in which the probe is located. The module is used only for the PID (which is not shown in the
output produced by the dtrace -l command) and ETW provider.
I 
Function If the probe corresponds to a specific program location, the name of the
program function in which the probe is located.
I 
Name The final component of the probe name is a name that gives you some idea of the
probe’s semantic meaning, such as BEGIN or END.
When writing out the full human-readable name of a probe, all the parts of the name are 
separated by colons. For example,
syscall::NtQuerySystemInformation:entry 
specifies a probe on the NtQueryInformation function entry provided by the syscall provider. 
Note that in this case, the module name is empty because the syscall provider does not specify 
any name (all the syscalls are implicitly provided by the NT kernel).
The PID and FBT providers instead dynamically generate probes based on the process or 
kernel image to which they are applied (and based on the currently available symbols). For ex-
ample, to correctly list the PID probes of a process, you should first get the process ID (PID) of the 
process that you want to analyze (by simply opening the Task Manager and selecting the Details 
property sheet; in this example, we are using Notepad, which in the test system has PID equal to 
8020). Then execute DTrace with the following command:
dtrace -ln pid8020:::entry > pid_notepad.txt
This lists all the probes on function entries generated by the PID provider for the Notepad 
process. The output will contain a lot of entries. Note that if you do not have the symbol store 
path set, the output will not contain any probes generated by private functions. To restrict the 
output, you can add the name of the module:
dtrace.exe -ln pid8020:kernelbase::entry >pid_kernelbase_notepad.txt
This yields all the PID probes generated for function entries of the kernelbase.dll module 
mapped in Notepad. If you repeat the previous two commands after having set the symbol store 
path with the following command,
set _NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols
you will find that the output is much different (and also probes on private functions). 
As explained in the “The Function Boundary Tracing (FBT) and Process (PID) providers” section 
later in this chapter, the PID and FBT provider can be applied to any offset in a function’s code. 
The following command returns all the offsets (always located at instruction boundary) in which 
the PID provider can generate probes on the SetComputerNameW function of Kernelbase.dll:
dtrace.exe -ln pid8020:kernelbase:SetComputerNameW: 
I
Module
If the probe corresponds to a specific program location, the name of the module 
in which the probe is located. The module is used only for the PID (which is not shown in the 
output produced by the dtrace -l command) and ETW provider.
I
Function
If the probe corresponds to a specific program location, the name of the 
program function in which the probe is located.
I
Name
The final component of the probe name is a name that gives you some idea of the 
probe’s semantic meaning, such as BEGIN or END.
When writing out the full human-readable name of a probe, all the parts of the name are 
separated by colons. For example,
syscall::NtQuerySystemInformation:entry 
specifies a probe on the NtQueryInformation function entry provided by the syscall provider. 