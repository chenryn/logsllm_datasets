### 3. 实验结果与分析

#### A. RQ1 — 正确的内核修补
我们对运行在实际硬件上的Linux内核进行了KSHOT系统的评估。我们首先确保系统处于稳定状态，即默认的Ubuntu 14.04或16.04后台进程正在运行。然后，我们指示KSHOT应用适当的补丁，并手动验证其正确部署（例如，无内核崩溃、无进程崩溃、无系统日志错误或警告等）。我们还进行了在实时修补过程中有更重负载的工作实验（见第VI-C3节）。我们的主要结果是，在所有考虑的30个案例中，KSHOT都能正确地应用实时补丁，这表明我们的系统适用于多个操作系统版本和缺陷类型。

为了进一步说明我们成功的适用性结果，我们详细介绍了几个补丁作为案例研究。从第V-A节可以回顾，每个内核补丁可以分为三类之一。类型1补丁不涉及内联，因此具有独立的指令内存（这是一个默认的简单情况）。类型2补丁涉及内联。类型3补丁需要更改内核数据结构或全局变量。我们将讨论每一类的一个示例补丁。

**示例类型1补丁：CVE-2017-17806**
该漏洞允许本地攻击者通过执行一系列精心设计的系统调用来触发内核堆栈缓冲区溢出，从而导致SHA-3初始化缺失并最终导致堆栈越界错误。官方修复方法如清单1所示，是在相关内核函数中添加加密检查（见第7行）。
```c
static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb) {
    salg = shash_attr_alg(tb[1], 0, 0);
    if (IS_ERR(salg))
        return PTR_ERR(salg);
    alg = &salg->base;
    err = -EINVAL;
    if (crypto_shash_alg_has_setkey(salg))
        goto out_put_alg;
    +
    ds = salg->digestsize;
    ss = salg->statesize;
    - alg = &salg->base;
}
```

**示例类型2补丁：CVE-2017-17053**
此漏洞是一个使用后释放漏洞，当Linux内核在分叉新进程时未正确处理某些表分配错误时，允许本地攻击者通过特别设计的程序实现使用后释放。官方修复方法如清单2所示，修改了`init_new_context`函数的返回值（见第6行）。对于KSHOT来说，这个补丁涉及内联，因此必须更新多个函数（如表I所示）。
```c
static inline int init_new_context(struct task_struct *tsk, ...) {
#if ...
#endif
-
-
+ init_new_context_ldt(tsk, mm);
    return 0;
    return init_new_context_ldt(tsk, mm);
}
```

**示例类型3补丁：CVE-2014-3690**
该漏洞涉及对本地数据结构的更新。官方补丁如清单3所示，向局部结构`vcpu_vmx`中添加了一个新字段。此外，`vmx_set_constant_host_state`函数为新字段赋值，而`vmx_vcpu_run`函数读取该字段的值。因此，这两个函数都必须进行修补。尽管KSHOT成功应用了这个补丁，但类型3的情况通常仍然较为困难；我们将在第VIII节中再次讨论这个问题。
```c
struct vcpu_vmx {
    int gs_ldt_reload_needed;
    int fs_reload_needed;
    u64 msr_host_bndcfgs;
    unsigned long vmcs_host_cr4;
    + host_state;
};
```

#### B. RQ2 — 性能评估
为了评估KSHOT的性能，我们测量了实时修补过程中的每个阶段。我们考虑了两个来源的开销：基于SGX的二进制补丁准备和基于SMM的修补。由于SMM修补过程本质上会暂停目标操作系统，而基于SGX的飞地则不会，我们分别评估了这两部分的性能，包括与现有方法的比较。在我们的实验中，二进制补丁的总大小通常在40字节到4KB之间。

1. **基于SGX的补丁准备性能**：
   SGX飞地必须（1）从远程服务器获取补丁，（2）通过完整性检查和分支指令替换预处理补丁，（3）将补丁加密并写入共享内存区域以供SMM侧使用。我们评估了每一步的时间消耗。

   表II显示了不同补丁大小下基于SGX的补丁准备时间分解，平均测试100次。以4KB补丁为例，从远程服务器获取二进制补丁的时间为200μs，预处理时间为8,034μs，将加密后的二进制补丁存储到共享内存区域所需时间为51μs。总计，我们用了8,285μs来完成一个4KB补丁的预处理。

2. **基于SMM的修补性能**：
   SMM处理器在执行密钥生成、数据读取和解密、补丁验证以及二进制补丁操作时会暂停目标操作系统。此外，切换到SMM和保护模式也会产生开销。我们使用`rdtsc`指令来计数每个操作期间的CPU周期数，从而经验性地评估这些时间。

   在我们的实验平台上，切换到SMM和从中恢复的平均时间分别为12.9μs和21.7μs。这些值取决于具体的硬件配置，但在我们的经验中通常是同一数量级。一旦切换到SMM，我们需要花费5.2μs来生成加密密钥。切换操作和密钥生成是固定成本操作，与补丁大小无关。

   表III显示了不同补丁大小下的修补操作时间分解。例如，一个4KB补丁需要1.27μs来读取和解密，8.52μs来验证，6.92μs来应用于内核内存（即将新的补丁写入内存）。注意，大部分补丁时间来自补丁验证过程，这涉及到计算SHA-2哈希。我们可以通过使用简单的哈希算法（如SDBM [57]）来减少这一时间。

   开销随补丁大小近似线性增长。即使在40MB的大补丁情况下，所需的总时间也少于1秒。根据我们的CVE数据集，平均补丁大小小于1KB。请注意，我们没有计算补丁服务器与目标机器的不可信辅助应用程序之间的通信开销，这对SGX飞地的影响很小。从表III外推，平均补丁大约需要74μs。我们认为这是暂停系统的一个小且可接受的时间间隔，特别是考虑到实时修补事件的罕见性。

3. **整个系统的性能评估**：
   我们随机选择了6个基准进行详细的整个系统性能分析。除了修补代码本身，每个函数还需要在传输的补丁包中包含42字节的头数据（按照图3中的打包过程）。图4显示了SGX预处理阶段的时间分解，表明大部分时间花在补丁预处理上。类似地，图5显示了每个补丁在SMM中的时间分解。

   较大的补丁需要更多的修补时间，而切换和密钥生成时间在所有补丁中相对恒定。在这些整个系统的实验中，KSHOT在应用每个补丁时所需的时间非常少。例如，对于CVE-2014-4608，156字节补丁在目标机器上总共需要约7,941μs。SGX中的准备时间占主导地位，而在SMM活动期间系统仅暂停了47.6μs。这包括5.2μs的密钥生成时间和34.6μs的SMM切换时间。补丁成功完成，没有改变应用程序的状态。

   我们还使用Sysbench [58] 来测量整体系统开销。我们在用户空间执行Sysbench的同时实时修补内核，并测量最终用户可见的系统开销。在上述6个CVE补丁的1,000次实时修补中，我们从SGX和SMM补丁准备和部署时间的组合中产生的开销不到3%。

#### C. RQ3 — 修补系统比较
KSHOT借助Intel SMM和SGX提供了一种实时且可靠的内核修补机制。我们将KSHOT与现有的通用实时修补系统以及其他实时内核修补系统进行了比较。

1. **通用修补比较**：
   表IV展示了KSHOT与在更广泛的软件工程上下文中使用的代表性非内核和内核二进制修补方法的比较。据我们所知，只有少数几种方法能够在不需要重启的情况下进行实时修补。