3
2
2
1
1
1
1,3
1
1
1
2
2
1
2
1,2
1,2
1,2
1 affects Linux 3.14. 2 affects Linux 4.4. (cid:2) indicates patch type
(Section V-A).
B. RQ1 — Correct Kernel Patching
We evaluated KSHOT on Linux kernels running on live
hardware. We determined that the system was in a stable state
with the default Ubuntu 14.04 or 16.04 background processes
running. We then instructed KSHOT to apply the appropriate
patch and manually veriﬁed its correct deployment (e.g., no
kernel panics, no crashed processes, no system log errors or
warnings, etc.). We also conducted experiments with heavier
active workloads during live patching (see Section VI-C3). Our
primary result is that KSHOT correctly applied live patches
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:26:38 UTC from IEEE Xplore.  Restrictions apply. 
7
in all 30 cases considered, demonstrating that our system is
applicable across multiple OS versions and defect types.
To provide additional insight into our successful applica-
bility results, we detail a few patches as case studies. Recall
from Section V-A that we can classify each kernel patch into
one of three categories. Type 1 patches involve no inlining
and thus have their own independent instruction memory (a
default, simple case). Type 2 patches involve inlining. Type
3 patches require changes to kernel data structures or global
variables. We discuss an example patch from each category
that we considered.
Example Type 1 Patch: We consider CVE-2017-17806.
This vulnerability admits a kernel stack buffer overﬂow when
a local attacker executes a crafted sequence of system calls
that encounter a missing SHA-3 initialization and eventually
a stack-out-of-bounds bug. The ofﬁcial ﬁx, partially shown in
Listing 1, is to add the cryptographic check to the relevant
kernel function (see Line 7). This is our most direct case.
Listing 1 Type 1 example: CVE-2017-17806 patch
1
2
3
4
5
6
7
8
9
10
11
12
static int hmac_create(struct crypto_template *tmpl,
struct rtattr **tb)
salg = shash_attr_alg(tb[1], 0, 0);
if (IS_ERR(salg))
return PTR_ERR(salg);
alg = &salg->base;
err = -EINVAL;
if (crypto_shash_alg_has_setkey(salg))
goto out_put_alg;
+
+
+
+
ds = salg->digestsize;
ss = salg->statesize;
- alg = &salg->base;
Listing 2 Type 2 example: CVE-2017-17053 patch
1
2
3
4
5
6
static inline int init_new_context(struct task_struct
*tsk,
...
#endif
-
-
+
init_new_context_ldt(tsk, mm);
return 0;
return init_new_context_ldt(tsk, mm);
Example Type 2 Patch: Consider the use-after-free vul-
nerability CVE-2017-17053. In this bug, the Linux kernel does
not correctly handle errors from certain table allocations when
forking a new process, allowing a local attacker to achieve a
use-after-free via a specially-crafted program. In the ofﬁcial
ﬁx for this bug, the return value in function init new context
is changed (see Listing 2, Line 6). Critically for KSHOT,
this patch involves inlining, so more than one function is
implicated and must be updated (as listed in Table I).
Listing 3 Type 3 example: CVE-2014-3690 patch
1
2
3
4
5
6
struct vcpu_vmx {
int
int
u64
unsigned long vmcs_host_cr4
gs_ldt_reload_needed;
fs_reload_needed;
msr_host_bndcfgs;
+
} host_state;
Example Type 3 Patch: We consider CVE-2014-3690
as an example Type 3 patch involving updates to local data
structures. The ofﬁcial patch, partially shown in Listing 3, adds
a new ﬁeld to local struct vcpu vmx. In addition, function
vmx set constant host state assigns a value to the new ﬁeld,
and function vmx vcpu run reads the ﬁeld’s value. Thus, both
functions must be patched. KSHOT successfully applies this
patch, but Type 3 cases remain difﬁcult in general; we return
to this issue in Section VIII.
C. RQ2 — Performance Evaluation
To evaluate the performance of KSHOT, we measured each
stage of the live patching process. We consider overhead from
two sources: SGX-based binary patch preparation and SMM-
based patching. Since the SMM patching process essentially
pauses the target OS but the SGX-based enclave does not, we
evaluate the performance of two parts separately, including
a comparison with existing methods. In our experiments, the
total size of the binary patch generally ranged from 40 bytes
to 4KB.
1) SGX-Based Patch Preparation Performance: The SGX
enclave must (1) fetch the patch from the remote server, (2)
preprocess the patch through integrity checking and branch
instruction replacing, (3) pass the patch with encrypting and
writing to shared memory region for consumption by the SMM
side. We evaluate the time consumption in each step.
Table II shows a breakdown of the time consumed by this
SGX-based patch preparation for various patch sizes, averaged
over 100 trials. Consider the 4KB case as an example. The
time to fetch a binary patch from our remote server is 200μs,
and the time to prepare the patch is 8,034μs. In addition,
51μs is required to store the encrypted binary patch into the
shared memory region. All told, we use 8,285μs to complete
the preprocessing of a 4KB patch.
2) SMM-Based Patching Performance: The SMM handler
pauses the target OS while carrying out key generation, data
reading and decryption, patch veriﬁcation, and binary patch
activities. In addition, there are overheads associated with
switching to and from SMM and protected mode. We evaluate
these times empirically using the rdtsc instruction to count the
number of CPU cycles elapsed during each operation.
For our experimental platform, the average times for switch-
ing to, and resuming from, SMM are 12.9μs and 21.7μs,
respectively. These values depend on speciﬁc hardware con-
ﬁguration, but are typically on the same order of magnitude
in our experience. Once we switch to SMM, we spend 5.2μs
to generate encryption keys. The switching operation and key
generation are ﬁxed-cost operations, regardless of patch size.
TABLE II: Breakdown of SGX operations (μs; n = 100).
Patch Size
40B
400B
4KB
40KB
400KB
10MB
Fetching
54
68
200
2,266
16,707
415,944
Pre-processing
150
850
8,034
82,611
785,616
19,991,979
Passing
9
29
51
498
4,985
124,565
Total
213
947
8,285
85,375
807,308
20,532,488
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:26:38 UTC from IEEE Xplore.  Restrictions apply. 
8
TABLE III: Breakdown of SMM operations (μs; n = 100).
Data
Decryption
0.04
0.31
1.27
13.84
133.30
2,832.00
Patch
Patch
Application
Size
0.06
40B
0.72
400B
6.92
4KB
17.22
40KB
396.45
400KB
10MB
2,619.00
1 includes key generation and SMM switching time.
Veriﬁcation
2.93
6.32
8.52
33.85
311.15
5,973.00
Patch
Total1
42.83
47.15
56.51
104.71
880.70
11,464.00
The SMM handler reads the encrypted patch provided by
the SGX enclave, then applies it to the kernel memory. The
time taken to read, decrypt, and apply the patch depends on
the patch size. We tested patch sizes ranging from 40 bytes
to 10MB. Table III shows the time breakdown of patching
operations for various patch sizes. For example, a 4KB patch
takes 1.27μs to read and decrypt, 8.52μs to verify, and 6.92μs
to apply to kernel memory (e.g., to actually write the new patch
to memory). Note that the majority of the patch time comes
from the patch veriﬁcation process, which involves computing
a SHA-2 hash. We could reduce this time by employing a
simpler hashing algorithm such as SDBM [57].
The overhead grows approximately linearly with the patch
size. Even in the case of a large 40MB patch, the total required
time is under 1 second. On average, the patches from our
CVE dataset are less than 1KB. Note that we did not count
the overhead imposed by communication between the Patch
Server and Target Machine’s untrusted helper application,
which has minimal effect on the SGX enclave. Extrapolating
from Table III, the average patch thus requires roughly 74μs.
We view this as a small and acceptable time interval to pause
the system, especially given the rarity of live patching events.
3) Whole-System Performance Evaluation: We randomly
selected 6 of our benchmarks for a detailed analysis of
whole-system performance.1 In addition to the patched code
itself, each function requires 42 bytes of header data in the
transmitted patch package (following the packaging process
from Figure 3). Figure 4 shows that the time breakdown in
the SGX preprocessing stage, which indicates the majority
of time is spent preprocessing the patch according. Similarly,
Figure 5 shows the time breakdown in SMM for each patch.
1patches for CVE-2014-4608, CVE-2015-7872, CVE-2016-2143, CVE-
2016-5696, CVE-2017-16994, CVE-2017-18270; corresponding patch sizes:
198, 171, 257, 79, 174, 322 bytes.
Larger patches require more patching time, while the switching
and key generation times are relatively constant across all
patches. In these whole-system experiments, KSHOT required
very little time to apply each patch. For example, for CVE-
2014-4608, the total time required on the Target Machine was
about 7,941μs for a 156-byte patch. The preparation time in
SGX dominates the time cost, and the system is only paused
for a brief 47.6μs during SMM activities. This including 5.2μs
for key generation and 34.6μs for SMM switching. The patch
completed successfully, without changing application state.
We also used Sysbench [58] to measure overall system
overhead. We live patched the kernel while Sysbench executed
in userspace and measured end-user-visible system overhead.
Over 1, 000 live patches of each of the 6 aforementioned CVE
patches, we incur under 3% overhead from the combined SGX
and SMM patch preparation and deployment times.
D. RQ3 — Patching System Comparison
KSHOT provides a live and reliable mechanism for kernel
patching with the help of Intel SMM and SGX. We compare
KSHOT with existing general-purpose live patching systems
and also with live kernel patching systems.
1) General Patching Comparison: Table IV presents a
comparison of KSHOT to indicative non-kernel and kernel
binary patching approaches used in more general software
engineering contexts. To the best of our knowledge, only