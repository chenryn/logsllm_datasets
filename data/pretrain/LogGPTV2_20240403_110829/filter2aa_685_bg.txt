reference object in memory.
For the procedure name, the compiler concatenates 
the text “new” with whatever the ident parameter 
holds. This is a simple way by which templates allow 
you to construct identifiers.
Licensed to   
275
Creating a configuration DSL
echo treeRepr(typeName)
echo treeRepr(fields)
echo treeRepr(result)
echo repr(result)
You should be able to compile the code again and see that the constructor procedure
is now generated. 
9.4.4
Generating the load procedure
Last but not least is the load procedure. It will load the configuration file for you,
parse it, and populate an instance of the configuration type with its contents.
 For the config definition shown in the previous sections, which contains an
address string field and a port integer field, the load procedure should be defined as
follows:
proc load*(cfg: MyAppConfig, filename: string) =
var obj = parseFile(filename)
cfg.address = obj["address"].getStr
cfg.port = obj["port"].getNum.int
For simplicity, the underlying configuration format used in this example is JSON. The
load procedure starts by parsing the JSON file, and it then accesses the address and
port fields in the parsed JSON object and assigns them to the configuration instance.
 The address field is a string, so the load procedure uses getStr to get a string for
that field. The port field is similarly filled, although in this case the field is an integer,
so the getNum procedure is used. The type of the field will need to be determined by
the macro when the procedure is generated.
 In order to generate these statements, you’ll need information about the config
fields, including their names and types. Thankfully, the code already deals with this
information in the form of IdentDefs. You can reuse the IdentDefs that have already
been created to generate the load procedure. Let’s take a look at these IdentDefs for
the MyAppConfig definition again:
IdentDefs
Ident !"address"
Ident !"string"
Empty
IdentDefs
Ident !"port"
Ident !"int"
Empty
Loads the JSON file from filename 
and saves it into the obj variable
Gets the address field from the parsed 
JSON object, retrieves its string value, 
and assigns it to the configuration 
instance’s address field
Gets the port field from the parsed JSON 
object, retrieves its integer value, and 
assigns it to the configuration instance’s 
port field. The type conversion is needed 
because the getNum procedure returns a 
BiggestInt type.
Licensed to   
276
CHAPTER 9
Metaprogramming
The structure is pretty simple. There are two nodes, and they each contain the field
name and type. Let’s use these to generate the load procedure. I’ll show you how to
write it in steps.
 First, define a new createLoadProc procedure and add it just above the config
macro in your configurator.nim file:
proc createLoadProc(typeName: NimIdent, identDefs: seq[NimNode]): NimNode =
Just like the createRefType procedure defined previously, createLoadProc takes two
parameters: a type name and a list of IdentDefs nodes. This procedure will use a semi-
automatic approach to generating the necessary AST.
 The load procedure takes two parameters—a cfg and a filename—and you need
to create an Ident node for each of them. In addition to that, you should create an
Ident node for the obj variable used in the procedure:
var cfgIdent = newIdentNode("cfg")
var filenameIdent = newIdentNode("filename")
var objIdent = newIdentNode("obj")
Add this code to the body of the createLoadProc procedure.
 The preceding code is pretty straightforward. It creates three different identifier
nodes that store the names of the two parameters and one of the variables. Let’s use
these to generate the first line in the load procedure:
var body = newStmtList()
body.add quote do:
var `objIdent` = parseFile(`filenameIdent`)
Append this code to the end of the createLoadProc body.
 This code starts off by creating a new StmtList node to hold the statements in the
load procedure’s body. The first statement is then generated using the quote proce-
dure defined in the macros module. The quote procedure returns a NimNode in a
manner similar to the getAst procedure, but instead of needing to declare a separate
template, it allows you to pass statements to it. Code inside the body of quote can be
substituted by surrounding it with backticks.
 In the preceding code, the name that the objIdent node holds is substituted into
the var definition. A similar substitution happens for the filenameIdent node. This
results in var obj = parseFile(filename) being generated.
 The next step is to iterate through the IdentDefs and generate the correct field
assignments based on them.
The cfg parameter that will store an 
instance of the configuration object
The filename parameter that
will store the filename of the
configuration file
The obj variable that will 
store the parsed JSON object
Defines a variable that stores 
the body of the load procedure
The quote procedure returns an
expression’s AST. It allows for nodes
to be quoted inside the expression.
The expression whose AST 
is generated is the first 
line of the load procedure, 
essentially: var obj = 
parseFile(filename)
Licensed to   
277
Creating a configuration DSL
for identDef in identDefs:
let fieldNameIdent = identDef[0]
let fieldName = $fieldNameIdent.ident
case $identDef[1].ident
of "string":
body.add quote do:
`cfgIdent`.`fieldNameIdent` = `objIdent`[`fieldName`].getStr
of "int":
body.add quote do:
`cfgIdent`.`fieldNameIdent` = `objIdent`[`fieldName`].getNum().int
else:
doAssert(false, "Not Implemented")
Append this code to the end of the createLoadProc body.
 This is a rather large chunk of code, but it generates very simple statements that
depend on the fields specified in the config body. For the config definition shown in
the previous sections, it will generate the following two statements:
cfg.address = obj["address"].getStr
cfg.port = obj["port"].getNum.int
With that code, the procedure body is fully generated. All that’s left is to create the
AST for the procedure, and this can be done easily using the newProc procedure
defined in the macros module.
return newProc(newIdentNode("load"),
[newEmptyNode(),
newIdentDefs(cfgIdent, newIdentNode(typeName)),
newIdentDefs(filenameIdent, newIdentNode("string"))],
body)
The newProc procedure generates the necessary AST nodes that model a procedure.
You get to customize the procedure by specifying the name, the parameters, the
return type, and the procedure body.
 All that’s left to do is add a call to generate the load proc in the config macro. Just
add result.add createLoadProc(typeName.ident, identDefs) below the getAst call.
 That’s all there is to it! Let’s make sure that it all works now. 
Iterates through the IdentDefs nodes
Retrieves the field name 
from the IdentDefs node
Converts the Ident into a string
Generates different code 
depending on the field’s type
For a string field, generates 
the getStr call
For an int field, generates the
getNum call and a type conversion
The first procedure parameter, 
in this case cfg
The return type of the procedure; an empty 
node is used to signify a void return type
The second procedure
parameter, in this
case filename
A StmtList node containing 
statements to be included in 
the body of the procedure
The name of the procedure
Licensed to   
278
CHAPTER 9
Metaprogramming
9.4.5
Testing the configurator
Before testing the code, you should create a JSON file that can be read. Create a new
file called myappconfig.json beside your configurator.nim file,3 and add the following
code to it:
{
"address": "http://google.com",
"port": 80
}
This will be read by the configurator in your test. The following listing shows how to
test it.
import json
config MyAppConfig:
address: string
port: int
var myConf = newMyAppConfig()
myConf.load("myappconfig.json")
echo("Address: ", myConf.address)
echo("Port: ", myConf.port)
Add the code in listing 9.11 to the bottom of the configurator.nim file. Then compile
and run the file. You should see the following output:
Address: http://google.com
Port: 80
WARNING: WORKING DIRECTORY
Be sure to run the program from the src
directory; otherwise, your myappconfig.json file will not be found.
The DSL is finished! Based on this example, you should have a good idea of how DSLs
can be written in Nim and how macros work. Feel free to play around with the resulting
DSL. For an extra challenge, you might wish to add support for more field types or to
export the generated types and procedures to make them usable from other modules. 
9.5
Summary
 Metaprogramming consists of three separate constructs: generics, templates,
and macros.
 Generic procedures reduce code duplication.
 Concepts are an experimental feature related to generics that allows you to
specify requirements that a matched type must satisfy.
 You can define generic procedures to reduce code duplication.
3 This was done for simplicity; ideally, you'd create a new tests directory and place the JSON file there.
Listing 9.11
Testing the config macro
Licensed to   
279
Summary
 Templates are an advanced substitution mechanism; they’re expanded at com-
pile time.
 Templates support hygiene, which is a way to control access to variables defined
in them.
 Templates and macros are the only constructs that can take a code block as an
argument.
 Macros work by reading, generating, and modifying code in the form of an
abstract syntax tree.
 You can get an AST representation of any piece of Nim code.
 You can generate code by constructing an AST using macros.
Licensed to   
280
appendix A
Getting help
While reading this book, you may run into cases where some concepts might be
tough to understand, one of the examples doesn’t work, or you have trouble install-
ing something like the Nim compiler on your machine.
 The Nim community, which includes me, is available to help with such issues.
This appendix describes different ways that you can get in touch with people who
will be happy to help.
A.1
Real-time communication
The fastest way to get help is via one of the two real-time communication applica-
tions used by Nim programmers: IRC and Gitter. At the time of writing, there are
more than 100 users in both Nim’s IRC channel and Gitter room.
 The messages are relayed between IRC and Gitter, so speaking in one will send
an equivalent message to the other. This means you can speak with the same set of
people regardless of whether you’re using IRC or Gitter.
 Gitter is far more approachable, so I suggest using it, especially if you’re not
already familiar with IRC. You can find it here: https://gitter.im/nim-lang/Nim.
 IRC can also be accessed via the web, or you can use one of the many available
IRC clients, such as HexChat. The #nim IRC channel is hosted on freenode and can
be accessed using the web chat client available here: http://webchat.freenode.net/
?channels=nim.
 Feel free to join and ask whatever questions you might have. In some cases, you
might not hear from anyone for a while, so please be patient. If you need to leave
but want to come back later to see if your question was answered, you can look at
the messages written in the channel in Gitter and also in our IRC logs, located here:
http://irclogs.nim-lang.org/. 
Licensed to   
281
Other communication methods
A.2
Forum
There are two forums that you can use to get help. The first is the Nim forum, avail-
able at http://forum.nim-lang.org/. The second is the Manning forum for this book,
available at https://forums.manning.com/forums/nim-in-action.
 For questions relating to this book, feel free to use either forum. For more-general
Nim questions, please use the Nim forum. 
A.3
Other communication methods
For other ways to get in touch with the Nim community, take a look at the community
page on the Nim website: http://nim-lang.org/community.html. 
Licensed to   
282
appendix B
Installing Nim
Before you begin writing Nim code, you need to install and set up the Nim com-
piler. The Nim compiler is the tool that will transform your Nim source code into a
binary format that your computer can then execute. It’s only used during develop-
ment, so users of your application won’t need it.
 You have the option of installing Aporia, the Nim IDE, as well. Aporia is a useful
tool for beginning Nim programmers: it allows you to compile and run Nim code
easily, and it can also be used as a Nim-centric alternative to popular source-code
editors such as gedit, Sublime Text, or Atom.  Visual Studio Code is another editor
that offers functionality similar to Aporia (through a plugin) and can be installed
relatively easily.
 In this appendix, you’ll learn how to install both the Nim compiler and an
appropriate text editor. You’ll then test this Nim development environment by
compiling and executing a Hello World example.
 Let’s get started. Grab any computer—even a Raspberry Pi will work—and fol-
low along!1
B.1
Installing the Nim compiler
It’s difficult to write installation instructions that will remain accurate for years to
come.2 This is especially true for a compiler that’s still evolving. In this appendix, I
can’t provide a step-by-step installation guide for Nim, but I can discuss some
potential troubleshooting steps and let you know where to look for installation
instructions.
B.1.1
Getting up-to-date installation info
It’s best to consult the Nim website for up-to-date installation information. In par-
ticular, see the install page: https://nim-lang.org/install.html.
1 Seriously, though, please don’t use a Raspberry Pi for development.
2 During the development of this book, the installation instructions changed at least once.
Licensed to   
283
Installing the Nim compiler
 That page should be your first stop when installing Nim because it also contains
the downloads for Nim. There will be different downloads for each OS and each will
have different installation instructions. You may need to build the compiler yourself
or simply execute an installer.
 Depending on your OS, the installation might be easy or difficult. As Nim evolves,
installation should become easier for all OSs, but as of the time of writing that’s not yet
the case. Follow whatever instructions the Nim website offers, and if they fail, you can get
in touch with me or somebody else in the Nim community (as discussed in appendix A).
 For completeness, I’ll describe the installation process offered by Nim since its
inception—building from source. This installation method should work more or less
the same way for the foreseeable future, but remember that there are likely simpler
ways to install Nim.
POSSIBLE PROBLEMS
There’s nothing more annoying than not being able to
install something. Please remember that the Nim community is happy to help
out. Consult appendix A for ways to get in touch with us so that we can help
you solve your issue. 
B.1.2
Building from source
This installation method will work on all platforms. It relies on a compressed archive
that contains the C source code, which has been generated for a specific version of the
Nim compiler. What you’ll be doing here is compiling the Nim compiler yourself.
 To compile the C source code, you need to have a C compiler installed on your sys-
tem. If you don’t already have one, you’ll need to install one first.
Installing a C compiler
The installation of a C compiler is fairly straightforward. The recommended C compiler
and the process for installing it differs depending on your OS.
Windows
You can install GCC by installing the MinGW package available here:
www.mingw.org/.
Mac OS
The recommended C compiler on Mac OS is Clang. Clang can be installed in two
ways.
If you have Homebrew, simply execute brew install clang to install Clang.
Otherwise, follow these steps: 
 Open a terminal window.
 Execute clang or gcc.
A dialog box asking whether you’d like to install the Command Line Developer Tools
should appear. Alternatively, you can execute xcode-select --install.
Licensed to   
284
APPENDIX B 
Installing Nim
DOWNLOAD THE NIM COMPILER ARCHIVE
Once you have a working C compiler installed, it’s time to download the C sources for
the latest version of the Nim compiler.
 Navigate to the Nim download page and find the download links for the generated
C sources for Windows, Mac OS, or Linux.
 You may see two download links, one of them a zip archive and another a tar.xz
archive. If you’re unsure which one to pick, download the zip archive. 
EXTRACT THE ARCHIVE AND MOVE IT TO A SAFE LOCATION
Once the download completes, extract the archive. You should be able to simply double-
click the zip archive in your OS’s file manager to extract it.
 You should now see a folder containing files belonging to the Nim compiler (see
figure B.1). The folder’s name will likely be nim-, where  is the version of
the Nim compiler that you downloaded (for example, nim-0.12.0).
(continued)
Click the Install button. Wait for the installation to finish, and then verify that the
installation was successful by executing clang --version.
Linux
In all likelihood, you already have a C compiler installed. Before attempting to install,
you can verify this by running gcc --version or clang --version.
The recommended C compiler for Linux is GCC. The installation instructions depend
on your distribution’s package manager.
On Yum-based distributions, you should be able to execute sudo yum install gcc
to install GCC.
On Debian-based distributions, you can execute apt-get like so: sudo apt-get
Figure B.1
The nim directory after it’s been extracted from the archive
Licensed to   
285
Installing the Nim compiler
Move the Nim folder to a safe place where you’d like to install it, such as ~/programs/
nim. 
COMPILE THE NIM COMPILER
Now open a terminal. Navigate into the nim directory using the cd command; for
example, cd ~/programs/nim. Your terminal should look similar to figure B.2.
You can now build the Nim compiler by executing one of the build scripts. The
build.bat and build64.bat scripts are for Windows, and the build.sh script is for all
other OSs. To execute the build.sh script, type sh build.sh into the terminal.
 Depending on the CPU power of your computer, this may take some time. But
unless you’re compiling Nim on a 1995 IBM NetVista, it shouldn’t take more than a
minute.
 When the compilation is successful, you should see “SUCCESS” at the bottom of
your terminal, as in figure B.3.
GETTING HELP
Did the compilation fail? Are you having other issues? There
are many ways to get help, and one of the easiest is to ask on the Nim forum
or on IRC. For more information, see appendix A.
The bin directory should now contain a nim binary, but the installation is not finished
yet. 
Figure B.2
Terminal 
after navigating to 
/home/dom/programs/nim
Figure B.3
The compilation succeeded
Licensed to   
286
APPENDIX B 
Installing Nim
ADD NIM TO YOUR PATH
In order for the nim binary to be visible to other applications, such as the terminal,
you need to add the bin directory to your PATH. In the previous example, the path
you’d need to add would be /Users/dom/programs/nim/bin because the username
in that example was dom and the ~ was expanded.
EXPANDING THE TILDE
Keep in mind that the ~ expands to /home/ on Linux. The preceding examples are for Mac OS. In certain
cases, adding a file path that includes the ~ to PATH may not work, so it’s usu-
ally best to just add an absolute path.
VERIFY THAT THE INSTALLATION WAS SUCCESSFUL
Ensure that you’ve completed these steps successfully by opening a new terminal win-
dow and executing nim -v. The output should look similar to the following:
Nim Compiler Version 0.14.2 (2016-08-09) [MacOSX: amd64]
Copyright (c) 2006-2016 by Andreas Rumpf
git hash: e56da28bcf66f2ce68446b4422f887799d7b6c61
active boot switches: -d:release
Assuming you were successful in installing Nim, you’re now ready to begin developing
Nim software! Before testing your new development environment, you have the
option of installing the Aporia IDE, discussed in the next section. You can skip this if
you’d like to use another IDE or text editor for writing Nim code. Section B.3 will
show you how to compile your first Nim application. 
How to add Nim to your PATH
Windows
To add Nim to your PATH, you need to access the advanced system settings, which
you can do by opening Control Panel > System and Security > System. You should
then see Advanced System Settings in the left sidebar. Click on it and a dialog box