and Gjøsteen [12] give a procedure to distinguish 30-
byte blocks generated uniformly at random from those
generated by Dual EC. The basic idea is to count how
many points on the curve have x-coordinates that agree
with the 30-byte block in their least-signiﬁcant 30-bytes.
In both the uniformly at random case and the Dual EC
case, the number of points on the curve that match follow
a normal distribution. In order to use the this distinguisher,
one needs to see a sufﬁcient number of 30-byte blocks
(in the form of IKE nonces) to state with high conﬁdence
that the blocks came from one distribution or the other.
We empirically computed the parameters of these two
distributions to see how difﬁcult this task is. We gen-
erated 2 million 30-byte blocks using Dual EC and an
additional 2-million blocks uniformly at random and per-
formed the point counting. We estimate the distributions’
parameters by ﬁtting the data using maximum likelihood
estimation. The results are not encouraging. When gen-
erated uniformly at random, the number of points on the
curve that agree with the generated block have param-
eters µ = 65536.02 and σ = 256.05. When generated
using Dual EC, the parameters are µ = 65536.78 and
σ = 256.06. This approach is unlikely to work without
seeing tens or hundreds of thousands of connections.
Interestingly, ScreenOS’s Dual EC implementation
has a bug that makes the adversary’s job much eas-
ier.
ScreenOS contains a customized version of
OpenSSL and uses OpenSSL’s elliptic curve and arbitrary-
precision (BIGNUM) routines to implement Dual EC.
The OpenSSL function to convert a BIGNUM to an
array of bytes is BN_bn2bin(). Due to a design de-
fect in OpenSSL’s API, there is no way to correctly use
BN_bn2bin without ﬁrst determining how many bytes it
will use — using BN_num_bytes() — and zero-padding,
and only then using BN_bn2bin():14
int size = BN_num_bytes(x);
memset(buffer, 0, 30 - size);
BN_bn2bin(x, buffer + size);
ScreenOS’s Dual EC implementation omits the zero-
padding when converting from BIGNUMs to binary out-
put. The upshot is that neither the ﬁrst nor the thirty-ﬁrst
byte of a nonce will ever be a zero byte.
Thus, if the adversary ever sees a zero byte in either
position, it can conclude that the implementation is not
Juniper’s Dual EC.
If the nonces are generated uniformly at random, then
we expect each of these bytes to be zero with (indepen-
dent) probability 1/256. Thus, the probability that after
n nonces without zeros in those positions, the nonce was
generated uniformly at random is 1− (255/256)2n.
This bug does not affect the exploitability of the
Dual EC generator; however, it can lead to a few ad-
ditional potential internal states to check as described in
Section 2.
8 Discussion
A signiﬁcant amount of attention has been paid to the
2012 compromise of Juniper’s ScreenOS source code by
unknown parties. In this paper we have shown that the
vulnerabilities announced by Juniper can be traced largely
to the pre-existing design of Juniper’s ScreenOS random
number generator. Speciﬁcally, we argue that Juniper’s
14This defect was corrected quite recently, years after the version of
OpenSSL ScreenOS uses was written. https://mta.openssl.org/
pipermail/openssl-commits/2016-February/003520.html
9
Listing 2: The core ScreenOS 6.1 PRNG subroutine.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
void prng_generate(char *output) {
unsigned int index;
int time[2];
index = 0;
// FIPS checks removed for clarity
if ( blocks_generated_since_reseed++ > 9999 )
prng_reseed();
// FIPS checks removed for clarity
time[0] = 0;
time[1] = get_cycles();
do {
// FIPS checks removed for clarity
prng_generate_block(time, prng_seed, prng_key, prng_block);
// FIPS checks removed for clarity
memcpy(&output[index], prng_output_block, min(20-index, 8));
index += min(20-index, 8);
} while ( index <= 19 );
}
design is exploitable due to a series of deliberate design
decisions, accidents, and oversights on the part of the
ScreenOS developers.
Below we review each of the conditions that are re-
quired to produce an exploitable PRNG in the Juniper
system:
1. Implementation of Dual EC. The cascade design
of Juniper’s double PRNG, which employs Dual EC
to seed the RNG on each call seems a surpris-
ing choice, given the performance limitations of
Dual EC. Notably, the transition from ScreenOS 6.1
(ANSI only) to 6.2 (Dual EC and ANSI) involved
the addition of a nonce pre-generation queue to the
existing DH key queues.15 One potential motivation
for this change could be the additional security assur-
ance provided by Dual EC. However, it is surprising
to note that Juniper did not seek FIPS certiﬁcation
of the Dual EC generator, despite the fact that fol-
lowing the deprecation of the ANSI X9.31 generator
on January 1, 2016, it would have been the only
FIPS-certiﬁed PRNG in their product.16
2. Presence of a Dual EC/ANSI cascade ﬂaw. Even
with Dual EC present in the ScreenOS devices, the
use of a cascade between Dual EC and ScreenOS
should have prevented the known state recovery at-
tacks. As detailed in Section 4, this protection is not
15To give a rough estimate of the performance difference, we imple-
mented Dual EC and ANSI X9.31 using the same procedure used in
ScreenOS and measured how long it takes to generate 32-byte blocks.
Dual EC takes roughly 125 times as long as X9.31.
16A review of the CMVP certiﬁcation lists [29] shows that all
ScreenOS FIPS certiﬁcation certiﬁcates have indeed been de-listed as
of February 2016.
available due to ﬂaws in the cascade implementa-
tion, which allows for the exﬁltration of unprocessed
Dual EC output. This ﬂaw is particularly perplex-
ing. Compare the prng_generate() function in
version 6.1 (Listing 2) with the analogous function
in version 6.2 (Listing 1). Apart from minor changes
arising from moving from generating 20 bytes at a
time to generating 32 bytes at a time and always
reseeding rather than reseeding based on a counter,
the functions look quite similar. However, for some
reason, the loop index variable was changed from a
local variable to a global variable.
3. Always reseeding.
In version 6.1, ScreenOS re-
seeded the X9.31 PRNG from system entropy every
10000 calls (hardcoded; see Listing 2). However,
in version 6.2, the reseeding mechanism was repur-
posed to produce the cascade by always reseeding.
When combined with the cascade ﬂaw described
above, all PRNG output comes from Dual EC, in-
creasing the probability that a speciﬁc value ob-
served by the attacker can be used to recover PRNG
state.
4. Use of 32-byte IKE nonces. The IKE standards do
not provide a speciﬁc recommendation for nonce
length, stating only that nonces should be between
8 and 256 bytes, and that nonces should be at least
half the key size of the PRF used. The last ver-
sion of ScreenOS without Dual EC was 6.1.0r7
and speciﬁed 20 byte nonces.
In the subsequent
release, ScreenOS 6.2.0r1, Juniper developers added
Dual EC and modiﬁed the IKE nonce size from 20
to 32 bytes. Efﬁciently recovering the state of the
10
Dual EC generator requires at a minimum 26 bytes
of unprocessed PRNG output, and as discussed in
Section 5.2, having greater than 30 bytes expedites
the state recovery attack.
5. Modifying the order of nonce and key generation.
The ScreenOS IKEv1 and IKEv2 implementations
both output IKE Key Exchange prior to the IKE
Nonce packet. However, this output order does not
reﬂect the generation order of the same values in all
versions of ScreenOS. In particular, the addition of
nonce queues in ScreenOS 6.2.0r1 effectively guar-
antees that in most cases a non-loaded system will
generate a nonce immediately prior to the Difﬁe–
Hellman private key that will be used in a given
handshake. In practice, this facilitates state recov-
ery attacks that can recover secret keys (and thus
enable decryption) within a single IKE handshake,
signiﬁcantly improving the effectiveness of passive
attacks.
All told, in the course of a single version revision, Ju-
niper made a series of changes that combined to produce
a system which only required the attacker to know the
discrete log of Q to be exploitable. See Table 1 for a
summary of changes. For a randomly-selected Q, or a
point chosen using the nothing-up-my-sleeve process pro-
posed in ANS X9.82 [2], calculating d is likely to be
infeasible. We have no way to evaluate the likelihood
that some party knows d for Juniper’s non-standard Q
point, except to note that Juniper does not appear to have
used any of the recommendations presented in the NIST
standard [28]. Based on the conclusions of Juniper’s 2012
vulnerability report [17], however, it does seem reason-
able to assume that the 2012 attacker-generated Q(cid:48) was
maliciously generated.
Regardless of the causes, these ScreenOS vulnerabil-
ities provide an important lesson for the design of cryp-
tographic systems. By far the most attractive feature of
the ScreenOS PRNG attack, from the perspective of an at-
tacker, is the ability to signiﬁcantly undermine the security
of ScreenOS without producing any externally-detectable
indication that would reveal that ScreenOS devices were
vulnerable. This is in marked contrast to previous well-
known PRNG failures, such as the Debian PRNG ﬂaw,
that. Indeed, the versions of ScreenOS containing an
attacker-supplied parameter appear to have produced out-
put that was cryptographically indistinguishable from the
output of previous versions. Thus, preventing any testing
or measurement from discovering the issue.
In Section 3, we asked four questions which we repro-
duce here, along with their answers:
1. Why does a change in Q result in a passive VPN
decryption vulnerability? If an attacker is able to
11
replace Q with a value of their choice, they can
predict the (EC)DH keys which are used to establish
the VPN trafﬁc keys, thus decrypting VPN trafﬁc.
2. Why doesn’t Juniper’s use of X9.31 protect their
system against compromise of Q? In the default
conﬁguration, the X9.31 PRNG is never run, and
Dual EC output is sent directly to the network in the
form of nonces. These nonces can be used to extract
the Dual EC state and predict future outputs.
3. What is the history of the PRNG code in ScreenOS?
Version 6.1 contained a conventional X9.31-based
PRNG which was replaced with a two-stage PRNG
based on Dual EC. That same version made a num-
ber of other changes to the PRNG and IKE code
which combine to make ScreenOS vulnerable to a
Q-replacement attack.
4. How was Juniper’s Q value generated? We are un-
able to answer this question. In normal cases, the
distribution of a maliciously-generated Q is iden-
tical to the distribution of a random Q. There do,
however, exist techniques for veriﬁably generating
safe Q points such that no attacker is likely to know
the discrete log (one such procedure is described
in [2]). If Juniper employed such a technique, it
is still possible that a thorough review of historical
documentation might provide evidence that such a
technique was used.
5. Is the version of ScreenOS with Juniper’s authorized
Q vulnerable to attack? We are unable to answer
this question deﬁnitively. As demonstrated in this
paper, an attacker who knows the discrete log of Ju-
niper’s Q would be able to decrypt trafﬁc. However,
because we do not know the details of Juniper’s Q-
generation procedure, we are unable to determine if
such attackers exist.
9 Related Work
Dual EC. The history of the Dual EC random number
generator was described by Checkoway et al. [7]. By
2006, it was already clear that the generator output has
biases in its output that make it unsuitable for deployment,
through work by Gjøsteen [12] and by Schoenmakers and
Sidorenko [32]. Shumow and Ferguson’s presentation at
the Crypto 2007 rump session [33] further made clear that
someone in possession of the discrete logarithm of Q to
base P and who saw raw output from the generator would
be able to reconstruct its internal state and predict all fu-
ture outputs. Nevertheless, Dual EC was adopted as part
of NIST’s SP 800-90A standard [4], and was not with-
drawn until 2015 [5], following reporting based on the
Snowden documents [30] that suggested that the Dual EC
Table 1: ScreenOS features by version.
Version
PRNG
6.1.0
6.2.0
6.3.0
X9.31
Dual EC + X9.31
Dual EC + X9.31
Reseed period
(calls)
Reseed bug
DH queue