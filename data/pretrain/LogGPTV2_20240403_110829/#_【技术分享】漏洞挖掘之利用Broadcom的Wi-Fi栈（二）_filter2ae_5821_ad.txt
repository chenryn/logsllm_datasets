图25
在rings_info_ptr字段之后，我们还可以转储有关每个环的信息，包括其大小、当前索引及物理内存地址：
图26
我们可以看到，这些缓冲区中指定的内存地址实际上似乎是主机内存中的物理内存地址。这有点可疑…在SMMU存在的情况下，芯片应该使用完全不同的地址范围（应该由SMMU转换为物理地址）。但是，仅仅是怀疑是不够的，为了检查SMMU是否存在（或活跃），我们需要设置一个小实验！
回想一下，对于RX和TX路径，MSGBUF协议使用上述环形缓冲区来指示事件的提交和完成。实质上，在帧传输期间，主机写入TX提交环。一旦芯片传输帧，其便写入TX完成环，以指示此情况。同样，当接收到帧时，固件写入RX提交环，随后主机在接收到帧时写入RX完成环。
如果是这样，如果我们修改对应于固件的PCIe元数据结构中的TX完成环的环地址，并将其指向任意的内存地址，结果会如何？如果SMMU就位，并且所选的内存地址未映射到Wi-Fi芯片，则SMMU将生成故障，并且不会进行任何修改。但是，如果没有SMMU，我们就应该能够通过从主机转储相应的物理内存范围（例如，通过使用/dev/mem）来观察此修改。这个小型实验还让我们可以暂时不用对Wi-Fi固件的MSGBUF协议的实现进行逆向工程，该逆向工程毫无疑问是相当繁琐的。
为了使事情更有趣，让我们修改TX完成环的地址，以指向Linux内核代码段的起始（Nexus
6P上的0x80000：见/proc/iomem）。在产生一些Wi-Fi流量并检查物理内存的内容之后，我们得到以下结果：
图27
哈哈！Wi-Fi芯片成功DMA到包含主机内核的物理地址范围，没有任何干扰！这最终证实了我们的怀疑，要么不存在SMMU，要么其没有被配置为可防止芯片访问主机的RAM。
这种访问不仅不需要漏洞，还可以更可靠地利用。不需要确切的内核符号或任何其他初步信息。Wi-Fi
SoC可以使用其DMA访问来扫描物理地址范围，以定位内核。然后，其可以识别RAM中内核的符号表，分析它来定位其所需的任何内核函数，并通过覆盖其代码来劫持该函数（在类似的类DMA攻击中可以看到一个这样的示例）。总而言之，这种攻击风格完全可移植且100％可靠，相比我们看到的以前的利用方法是一个重大的升级。
我们可以到此为止，不过让我们再稍作努力，以便稍微更好地控制这个原语。虽然我们能DMA进主机的内存，但此时我们是相当“盲目地”实现的。我们不控制正在写入的数据，而是依靠Wi-Fi固件的MSGBUF协议的实现来破坏主机的内存。通过进一步研究，我们应该能够弄清Wi-Fi芯片上的DMA引擎是如何工作的，并手动利用它来访问主机的内存（而不是依赖如上所示的副作用）。
那么我们从哪里开始？搜索“MSGBUF”字符串，我们可以看到与协议相关的一些初始化例程，这是特殊“回收”区域的一部分（因此仅在芯片初始化期间使用）。然而，对这些函数进行逆向工程后表明，其引用Wi-Fi芯片RAM中的一组函数。幸运的是，这些函数的一些名称存在于ROM中！其名称似乎很相关：“dma64_txfast”、“dma64_txreset”——看起来我们在正确的轨道上。
我们再一次避免了一些逆向工程的努力。Broadcom的SoftMAC驱动程序[brcmsmac](https://github.com/torvalds/linux/tree/master/drivers/net/wireless/broadcom/brcm80211/brcmsmac)包含这些确切函数的实现。虽然我们可以预期有一些差异，但总体思路应保持不变。
梳理代码后发现，似乎对于每个具有DMA能力的源或接收器，都存在一个相应的DMA元数据结构，称为“[dma_info](http://lxr.free-electrons.com/source/drivers/staging/brcm80211/brcmsmac/hnddma.c?v=3.0#L77)”。该结构包含指向DMA
RX和TX寄存器的指针，以及插入DMA源或目标地址的DMA描述符环。另外，每个结构都被分配一个用于标识自身的8字节的名称。更重要的是，每个dma_info结构都以指向包含DMA函数的RAM函数块的指针开始——与我们之前确定的块相同。因此，我们可以通过在Wi-Fi SoC的RAM中搜索这个指针来定位这些DMA元数据结构的所有实例。
图28
现在我们知道了这些元数据结构的格式，并且有办法找到它们，所以我们可以尝试搜索对应于从Wi-Fi芯片到主机的DMA TX路径的实例。
不过，这说易行难。毕竟，我们可以预期找到这些结构的多个实例，因为Wi-Fi芯片可对多个源和接收器进行正向和反向DMA。比如，固件可能使用SoC内部DMA引擎来访问内部RX和TX FIFO。那么我们如何识别正确的DMA描述符？
回想一下，每个描述符都有一个关联的“名称”字段。我们来搜索RAM中的所有DMA描述符（通过搜索DMA函数块指针），并输出每个实例的相应名称：
图29
太好了！虽然有一些可能在内部使用的难以归类的dma_info实例（和怀疑的一样），但也有两个实例似乎对应于主机到设备（H2D）和设备到主机（D2H）DMA访问。由于我们对DMA进主机的内存感兴趣，所以我们来仔细看看D2H的结构：
图30
注意，RX和TX寄存器指向Wi-Fi固件的ROM和RAM之外的区域。实际上，其指向对应于DMA引擎寄存器的背板地址。相比之下，RX和TX描述符环指针确实指向SoC的RAM中的内存位置。
通过审查brcmsmac中的DMA代码和主机驱动程序中的MSGBUF协议实现，我们最终得以将细节拼凑起来。首先，主机使用MSGBUF协议将物理地址（对应于SKB）发送到芯片。然后由固件的MSGBUF实现将这些地址插入DMA描述符环中。一旦环被填充，Wi-Fi芯片就会写入背板寄存器，以便“启动”DMA引擎。然后，DMA引擎将审查描述符列表，并在DMA访问的当前环索引处消耗描述符。一旦DMA描述符被消耗，其值便被设置为一个特殊的“魔术”值（0xDEADBEEF）。
因此，为了操纵DMA引擎写入我们自己的任意物理地址，我们需要做的就是修改DMA描述符环。由于MSGBUF协议在帧来回发送时始终运行，所以描述符环快速变化。如果我们可以“钩住”DMA
TX流程中调用的其中一个函数，那我们就可以用我们自己设计的值快速替换当前的描述符。
幸运的是，dmx64_txfast函数位于ROM中，其序言从指向RAM的分支开始。这使我们可以使用上一篇博文中的[补丁程序](https://bugs.chromium.org/p/project-zero/issues/detail?id=1046#c9)来挂接这个函数，然后执行我们自己的shellcode存根。我们来写一个小存根，以审查D2H
DMA描述符，并将每个非消耗的描述符更改为我们自己的指针。通过这样做，对DMA引擎的后续调用应将接收到的帧的内容写入上述地址。在应用补丁并生成Wi-Fi流量后，我们收获了以下结果：
图31
我们成功将任意数据DMA到了我们选择的地址。使用该原语，我们终于可以用我们自己制作的数据来劫持任何内核函数。
最后一点，上述实验是在Nexus 6P（基于Qualcomm的Snapdragon 810
SoC）上进行的。这引起了一个问题：也许不同的SoC会展现不同的行为？为了测试这个理论，让我们在Galaxy S7 Edge（基于三星的Exynos
8890 SoC）上重复相同的实验。
使用[先前披露的权限提升](https://googleprojectzero.blogspot.com/2016/12/bitunmap-attacking-android-ashmem.html)将代码注入到system_server中，我们可以直接发出与bcmdhd驱动程序交互所需的ioctl，从而取代了上述实验中由dhdutil提供的芯片内存访问功能。同样，利用[先前披露的内核利用方法](https://googleprojectzero.blogspot.com/2017/02/lifting-hyper-visor-bypassing-samsungs.html)，我们能够在内核中执行代码，使我们能够观察内核代码段的更改。
综合起来，我们可以提取Wi-Fi芯片（BCM43596）的ROM，对其进行检查，并按照上述方法定位DMA函数。然后我们可以插入相同的挂钩，将任何未消耗的DMA
RX描述符指向内核代码的物理地址。安装挂钩并产生一些Wi-Fi流量后，我们观察到以下结果：
图32
我们又一次可以自由DMA进内核（期间绕过了RKP保护）。似乎三星的Exynos 8890 SoC和Qualcomm的Snapdragon
810要么缺乏SMMU，要么未能使用SMMU。
**结束语**
总而言之，我们已经看到，可以而且应该改进主机和Wi-Fi
SoC之间的隔离。虽然主机和芯片之间的通信协议存在缺陷，但是经过一定时间最终可以予以解决。然而，目前缺乏对流氓Wi-Fi芯片的保护令人担忧。
由于移动SoC是专有的，因此当前这一代的SoC是否能够促进这种隔离仍然是未知数。我们希望确实有能力实现内存保护（比如通过SMMU方式）的SoC尽快选择这样做。对于不能这样做的SoC，也许这项研究将成为设计下一代硬件的促进因素。
目前的缺乏隔离也可能会产生一些令人惊讶的副作用。例如，能够[与Wi-Fi固件](http://androidxref.com/7.1.1_r6/xref/system/sepolicy/ioctl_macros#15)交互的Android上下文可以利用Wi-Fi SoC的DMA能力来直接劫持内核。因此，这些上下文应该被认为是“具有内核权限”，我认为，目前安卓的安全架构还没有作出这样的假设。
固件日益复杂，Wi-Fi在不断向前迈进，这两者表明固件bug可能还要徘徊很长一段时间。该假设有事实的支持——即使对固件进行相对浅层的检查也可以发现很多bug，且都可以被远程攻击者利用。
虽然内存隔离本身有助于防御流氓Wi-Fi
SoC，但固件的防御也可以支持攻击。目前，固件缺乏利用缓解措施（如堆栈cookie），并没有充分利用现有的安全机制（如MPU）。希望未来的版本能通过实施现代利用缓解措施和采用SoC安全机制来更好地防范这种攻击。
**传送门**
* * *
**[【技术分享】漏洞挖掘之利用Broadcom的Wi-Fi栈（一）](http://bobao.360.cn/learning/detail/3742.html)**