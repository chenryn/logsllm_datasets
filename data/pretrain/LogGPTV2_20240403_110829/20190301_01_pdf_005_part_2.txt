VALUES token in order to be complete. The precise syntax rules for each command are
described in Section 2.3.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 11
Database Compatibility for Oracle® Developers
Reference Guide
2.1.2 Identifiers and Key Words
Tokens such as SELECT, UPDATE, or VALUES in the example above are examples of key
words, that is, words that have a fixed meaning in the SQL language. The tokens
MY_TABLE and A are examples of identifiers. They identify names of tables, columns, or
other database objects, depending on the command they are used in. Therefore they are
sometimes simply called, “names”. Key words and identifiers have the same lexical
structure, meaning that one cannot know whether a token is an identifier or a key word
without knowing the language.
SQL identifiers and key words must begin with a letter (a-z or A-Z). Subsequent
characters in an identifier or key word can be letters, underscores, digits (0-9), dollar
signs ($), or number signs (#).
Identifier and key word names are case insensitive. Therefore
UPDATE MY_TABLE SET A = 5;
can equivalently be written as:
uPDaTE my_TabLE SeT a = 5;
A convention often used is to write key words in upper case and names in lower case,
e.g.,
UPDATE my_table SET a = 5;
There is a second kind of identifier: the delimited identifier or quoted identifier. It is
formed by enclosing an arbitrary sequence of characters in double-quotes ("). A
delimited identifier is always an identifier, never a key word. So "select" could be
used to refer to a column or table named "select", whereas an unquoted select would
be taken as a key word and would therefore provoke a parse error when used where a
table or column name is expected. The example can be written with quoted identifiers
like this:
UPDATE "my_table" SET "a" = 5;
Quoted identifiers can contain any character, except the character with the numeric code
zero.
To include a double quote, use two double quotes. This allows you to construct table or
column names that would otherwise not be possible (such as ones containing spaces or
ampersands). The length limitation still applies.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 12
Database Compatibility for Oracle® Developers
Reference Guide
Quoting an identifier also makes it case-sensitive, whereas unquoted names are always
folded to lower case. For example, the identifiers FOO, foo, and "foo" are considered
the same by Advanced Server, but "Foo" and "FOO" are different from these three and
each other. The folding of unquoted names to lower case is not compatible with Oracle
databases. In Oracle syntax, unquoted names are folded to upper case: for example, foo
is equivalent to "FOO" not "foo". If you want to write portable applications you are
advised to always quote a particular name or never quote it.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 13
Database Compatibility for Oracle® Developers
Reference Guide
2.1.3 Constants
The kinds of implicitly-typed constants in Advanced Server are strings and numbers.
Constants can also be specified with explicit types, which can enable more accurate
representation and more efficient handling by the system. These alternatives are
discussed in the following subsections.
2.1.3.1 String Constants
A string constant in SQL is an arbitrary sequence of characters bounded by single quotes
('), for example 'This is a string'. To include a single-quote character within a
string constant, write two adjacent single quotes, e.g. 'Dianne''s horse'. Note that
this is not the same as a double-quote character (").
2.1.3.2 Numeric Constants
Numeric constants are accepted in these general forms:
digits
digits.[digits][e[+-]digits]
[digits].digits[e[+-]digits]
digitse[+-]digits
where digits is one or more decimal digits (0 through 9). At least one digit must be
before or after the decimal point, if one is used. At least one digit must follow the
exponent marker (e), if one is present. There may not be any spaces or other characters
embedded in the constant. Note that any leading plus or minus sign is not actually
considered part of the constant; it is an operator applied to the constant.
These are some examples of valid numeric constants:
42
3.5
4.
.001
5e2
1.925e-3
A numeric constant that contains neither a decimal point nor an exponent is initially
presumed to be type INTEGER if its value fits in type INTEGER (32 bits); otherwise it is
presumed to be type BIGINT if its value fits in type BIGINT (64 bits); otherwise it is
taken to be type NUMBER. Constants that contain decimal points and/or exponents are
always initially presumed to be type NUMBER.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 14
Database Compatibility for Oracle® Developers
Reference Guide
The initially assigned data type of a numeric constant is just a starting point for the type
resolution algorithms. In most cases the constant will be automatically coerced to the
most appropriate type depending on context. When necessary, you can force a numeric
value to be interpreted as a specific data type by casting it as described in the following
section.
2.1.3.3 Constants of Other Types
A constant of an arbitrary type can be entered using the following notation:
CAST('string' AS type)
The string constant‟s text is passed to the input conversion routine for the type called
type. The result is a constant of the indicated type. The explicit type cast may be omitted
if there is no ambiguity as to the type the constant must be (for example, when it is
assigned directly to a table column), in which case it is automatically coerced.
CAST can also be used to specify runtime type conversions of arbitrary expressions.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 15
Database Compatibility for Oracle® Developers
Reference Guide
2.1.4 Comments
A comment is an arbitrary sequence of characters beginning with double dashes and
extending to the end of the line, e.g.:
-- This is a standard SQL comment
Alternatively, C-style block comments can be used:
/* multiline comment
* block
*/
where the comment begins with /* and extends to the matching occurrence of */.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 16
Database Compatibility for Oracle® Developers
Reference Guide
2.2 Data Types
The following table shows the built-in general-purpose data types.
Table 2-1 Data Types
Name Alias Description
BLOB LONG RAW, RAW(n), BYTEA Binary data
BOOLEAN Logical Boolean (true/false)
Fixed-length character string of n
CHAR [ (n) ] CHARACTER [ (n) ]
characters
CLOB LONG, LONG VARCHAR Long character string
DATE TIMESTAMP Date and time to the second
FLOAT,
DOUBLE PRECISION Double precision floating-point number
FLOAT(25) – FLOAT(53)
INT, BINARY_INTEGER,
INTEGER Signed four-byte integer
PLS_INTEGER
Exact numeric with optional decimal
NUMBER DEC, DECIMAL, NUMERIC
places
DEC(p [, s ]),
Exact numeric of maximum precision,
NUMBER(p [, s ]) DECIMAL(p [, s ]),
p, and optional scale, s
NUMERIC(p [, s ])
REAL FLOAT(1) – FLOAT(24) Single precision floating-point number
Date and time with optional, fractional
TIMESTAMP [ (p) ]
second precision, p
TIMESTAMP [ (p) ] WITH Date and time with optional, fractional
TIME ZONE second precision, p, and with time zone
CHAR VARYING(n), CHARACTER Variable-length character string with a
VARCHAR2(n)
VARYING(n), VARCHAR(n) maximum length of n characters
XMLTYPE XML data
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 17
Database Compatibility for Oracle® Developers
Reference Guide
2.2.1 Numeric Types
Numeric types consist of four-byte integers, four-byte and eight-byte floating-point
numbers, and fixed-precision decimals. The following table lists the available types.
Table 2-2 Numeric Types
Storage
Name Description Range
Size
-2,147,483,648 to
BINARY_INTEGER 4 bytes Signed integer, Alias for INTEGER
+2,147,483,647
15 decimal digits
DOUBLE PRECISION 8 bytes Variable-precision, inexact
precision
-2,147,483,648 to
INTEGER 4 bytes Usual choice for integer
+2,147,483,647
Up to 1000 digits of
NUMBER Variable User-specified precision, exact
precision
Exact numeric of maximum precision, p, Up to 1000 digits of
NUMBER(p [, s ] ) Variable
and optional scale, s precision
-2,147,483,648 to
PLS_INTEGER 4 bytes Signed integer, Alias for INTEGER
+2,147,483,647
6 decimal digits
REAL 4 bytes Variable-precision, inexact
precision
-9223372036854775808
ROWID 8 bytes Signed 8 bit integer. to
9223372036854775807
The following sections describe the types in detail.
2.2.1.1 Integer Types
The type, INTEGER, stores whole numbers (without fractional components) between the
values of -2,147,483,648 and +2,147,483,647. Attempts to store values outside of the
allowed range will result in an error.
Columns of the ROWID type holds fixed-length binary data that describes the physical
address of a record. ROWID is an unsigned, four-byte INTEGER that stores whole
numbers (without fractional components) between the values of 0 and 4,294,967,295.
Attempts to store values outside of the allowed range will result in an error.
2.2.1.2 Arbitrary Precision Numbers
The type, NUMBER, can store practically an unlimited number of digits of precision and
perform calculations exactly. It is especially recommended for storing monetary amounts
and other quantities where exactness is required. However, the NUMBER type is very slow
compared to the floating-point types described in the next section.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 18
Database Compatibility for Oracle® Developers
Reference Guide
In what follows we use these terms: The scale of a NUMBER is the count of decimal digits
in the fractional part, to the right of the decimal point. The precision of a NUMBER is the
total count of significant digits in the whole number, that is, the number of digits to both
sides of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4.
Integers can be considered to have a scale of zero.
Both the precision and the scale of the NUMBER type can be configured. To declare a
column of type NUMBER use the syntax
NUMBER(precision, scale)
The precision must be positive, the scale zero or positive. Alternatively,
NUMBER(precision)
selects a scale of 0. Specifying NUMBER without any precision or scale creates a column
in which numeric values of any precision and scale can be stored, up to the
implementation limit on precision. A column of this kind will not coerce input values to
any particular scale, whereas NUMBER columns with a declared scale will coerce input
values to that scale. (The SQL standard requires a default scale of 0, i.e., coercion to
integer precision. For maximum portability, it is best to specify the precision and scale
explicitly.)
If the precision or scale of a value is greater than the declared precision or scale of a
column, the system will attempt to round the value. If the value cannot be rounded so as
to satisfy the declared limits, an error is raised.
2.2.1.3 Floating-Point Types
The data types REAL and DOUBLE PRECISION are inexact, variable-precision numeric
types. In practice, these types are usually implementations of IEEE Standard 754 for
Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent
that the underlying processor, operating system, and compiler support it.
Inexact means that some values cannot be converted exactly to the internal format and are
stored as approximations, so that storing and printing back out a value may show slight
discrepancies. Managing these errors and how they propagate through calculations is the
subject of an entire branch of mathematics and computer science and will not be
discussed further here, except for the following points:
If you require exact storage and calculations (such as for monetary amounts), use the
NUMBER type instead.
If you want to do complicated calculations with these types for anything important,
especially if you rely on certain behavior in boundary cases (infinity, underflow), you
should evaluate the implementation carefully.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 19
Database Compatibility for Oracle® Developers
Reference Guide
Comparing two floating-point values for equality may or may not work as expected.
On most platforms, the REAL type has a range of at least 1E-37 to 1E+37 with a precision
of at least 6 decimal digits. The DOUBLE PRECISION type typically has a range of
around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large
or too small will cause an error. Rounding may take place if the precision of an input
number is too high. Numbers too close to zero that are not representable as distinct from
zero will cause an underflow error.
Advanced Server also supports the SQL standard notations FLOAT and FLOAT(p) for
specifying inexact numeric types. Here, p specifies the minimum acceptable precision in
binary digits. Advanced Server accepts FLOAT(1) to FLOAT(24) as selecting the REAL
type, while FLOAT(25) to FLOAT(53) as selecting DOUBLE PRECISION. Values of p
outside the allowed range draw an error. FLOAT with no precision specified is taken to
mean DOUBLE PRECISION.
2.2.2 Character Types
The following table lists the general-purpose character types available in Advanced
Server.
Table 2-3 Character Types
Name Description
Fixed-length character string, blank-padded to the size specified
CHAR[(n)]
by n
CLOB Large variable-length up to 1 GB
LONG Variable unlimited length.
NVARCHAR(n) Variable-length national character string, with limit.
NVARCHAR2(n) Variable-length national character string, with limit.
STRING Alias for VARCHAR2.
Variable-length character string, with limit (considered
VARCHAR(n)
deprecated, but supported for compatibility)
VARCHAR2(n) Variable-length character string, with limit
Where n is a positive integer; these types can store strings up to n characters in length.
An attempt to assign a value that exceeds the length of n will result in an error, unless the
excess characters are all spaces, in which case the string will be truncated to the
maximum length.
The storage requirement for data of these types is the actual string plus 1 byte if the string
is less than 127 bytes, or 4 bytes if the string is 127 bytes or greater. In the case of
CHAR, the padding also requires storage. Long strings are compressed by the system
automatically, so the physical requirement on disk may be less. Long values are stored in
background tables so they do not interfere with rapid access to the shorter column values.
The database character set determines the character set used to store textual values.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 20
Database Compatibility for Oracle® Developers
Reference Guide
CHAR
If you do not specify a value for n, n will default to 1. If the string to be assigned is
shorter than n, values of type CHAR will be space-padded to the specified width (n), and
will be stored and displayed that way.
Padding spaces are treated as semantically insignificant. That is, trailing spaces are
disregarded when comparing two values of type CHAR, and they will be removed when
converting a CHAR value to one of the other string types.
If you explicitly cast an over-length value to a CHAR(n) type, the value will be truncated
to n characters without raising an error (as specified by the SQL standard).
VARCHAR, VARCHAR2, NVARCHAR and NVARCHAR2
If the string to be assigned is shorter than n, values of type VARCHAR, VARCHAR2,
NVARCHAR and NVARCHAR2 will store the shorter string without padding.
Note that trailing spaces are semantically significant in VARCHAR values.
If you explicitly cast a value to a VARCHAR type, an over-length value will be truncated to
n characters without raising an error (as specified by the SQL standard).
CLOB
You can store a large character string in a CLOB type. CLOB is semantically equivalent to
VARCHAR2 except no length limit is specified. Generally, you should use a CLOB type if
the maximum string length is not known.
The longest possible character string that can be stored in a CLOB type is about 1 GB.
Note: The CLOB data type is actually a DOMAIN based on the PostgreSQL TEXT data
type. For information on a DOMAIN, see the PostgreSQL core documentation at:
https://www.postgresql.org/docs/11/static/sql-createdomain.html
Thus, usage of the CLOB type is limited by what can be done for TEXT such as a
maximum size of approximately 1 GB.
For usage of larger amounts of data, instead of using the CLOB data type, use the
PostgreSQL Large Objects feature that relies on the pg_largeobject system catalog.
For information on large objects, see the PostgreSQL core documentation at:
https://www.postgresql.org/docs/11/static/largeobjects.html
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 21
Database Compatibility for Oracle® Developers
Reference Guide
2.2.3 Binary Data
The following data types allows storage of binary strings.
Table 2-4 Binary Large Object
Name Storage Size Description
Fixed-length binary string, with a length
BINARY The length of the binary string.
between 1 and 8300.
The actual binary string plus 1 byte
if the binary string is less than 127 Variable-length binary string, with a
BLOB
bytes, or 4 bytes if the binary string maximum size of 1 GB.
is 127 bytes or greater.
Variable-length binary string, with a length
VARBINARY The length of the binary string
between 1 and 8300.
A binary string is a sequence of octets (or bytes). Binary strings are distinguished from
characters strings by two characteristics: First, binary strings specifically allow storing
octets of value zero and other "non-printable" octets (defined as octets outside the range
32 to 126). Second, operations on binary strings process the actual bytes, whereas the
encoding and processing of character strings depends on locale settings.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 22
Database Compatibility for Oracle® Developers
Reference Guide
2.2.4 Date/Time Types
The following discussion of the date/time types assumes that the configuration parameter,
edb_redwood_date, has been set to TRUE whenever a table is created or altered.
Advanced Server supports the date/time types shown in the following table.
Table 2-5 Date/Time Types
Storage Low Value
Name Description High Value Resolution
Size
DATE 8 bytes Date and time 4713 BC 5874897 AD 1 second
INTERVAL DAY TO
-178000000 178000000 1 microsecond /
SECOND 12 bytes Period of time
years years 14 digits
[(p)]
INTERVAL YEAR TO -178000000 178000000 1 microsecond /
12 bytes Period of time
MONTH years years 14 digits
TIMESTAMP [(p)] 8 bytes Date and time 4713 BC 5874897 AD 1 microsecond
TIMESTAMP [(p)] Date and time
8 bytes 4713 BC 5874897 AD 1 microsecond
WITH TIME ZONE with time zone
When DATE appears as the data type of a column in the data definition language (DDL)
commands, CREATE TABLE or ALTER TABLE, it is translated to TIMESTAMP at the time
the table definition is stored in the database. Thus, a time component will also be stored
in the column along with the date.
When DATE appears as a data type of a variable in an SPL declaration section, or the data
type of a formal parameter in an SPL procedure or an SPL function, or the return type of
an SPL function, it is always translated to TIMESTAMP and thus can handle a time
component if present.
TIMESTAMP accepts an optional precision value p which specifies the number of
fractional digits retained in the seconds field. The allowed range of p is from 0 to 6 with
the default being 6.
When TIMESTAMP values are stored as double precision floating-point numbers
(currently the default), the effective limit of precision may be less than 6. TIMESTAMP
values are stored as seconds before or after midnight 2000-01-01. Microsecond precision
is achieved for dates within a few years of 2000-01-01, but the precision degrades for
dates further away. When TIMESTAMP values are stored as eight-byte integers (a
compile-time option), microsecond precision is available over the full range of values.
However eight-byte integer timestamps have a more limited range of dates than shown
above: from 4713 BC up to 294276 AD.
TIMESTAMP (p) WITH TIME ZONE is similar to TIMESTAMP (p), but includes the
time zone as well.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 23
Database Compatibility for Oracle® Developers
Reference Guide
2.2.4.1 INTERVAL Types
INTERVAL values specify a period of time. Values of INTERVAL type are composed of
fields that describe the value of the data. The following table lists the fields allowed in an
INTERVAL type:
Table 2-6 Interval Types
Field Name INTERVAL Values Allowed