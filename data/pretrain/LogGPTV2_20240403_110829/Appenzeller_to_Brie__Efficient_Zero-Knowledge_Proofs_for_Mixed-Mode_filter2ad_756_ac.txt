( ğ‘—)
ğ‘šâˆ’1), id( ğ‘—)} ğ‘— âˆˆ[ğ‘ ]):
ğ‘–=0 2ğ‘–ğ‘( ğ‘—)
(1) If ğ‘( ğ‘—) = ğ‘šâˆ’1
Functionality FConv
FConv extends the existing functionality F 2,ğ‘€
ComZK
taining two commitment instances:
(1) [Â·]2 allows to commit to values from Z2; and
(2) [Â·]ğ‘€ allows to commit to values from Zğ‘€,
plus the interface VerifyConv. It is assumed that the idâ€™s
used for VerifyConv have been used with the respective
instance of Input prior to calling this method.
VerifyConv: Upon P andV inputting (VerifyConv, ğ‘ , ğ‘š,
{(id
( ğ‘—)
0 , . . . , id
(success) to V, otherwise output abort.
Figure 1: Functionality FConv checking edaBits
Functionality FDabit
This functionality extends F 2,ğ‘€
with the extra function
1,ğ‘—)} ğ‘— âˆˆ[ğ‘ ] and
VerifyDabit that takes a set of IDs {(id
= ğ‘id1,ğ‘— where ğ‘id0,ğ‘— âˆˆ Z2 an ğ‘id1,ğ‘— âˆˆ Zğ‘€
verifies that ğ‘id0,ğ‘—
for all ğ‘— âˆˆ [ğ‘]. It is assumed that the idâ€™s have been Input
prior to calling this method.
Verify: On input (VerifyDabit, ğ‘ , {(id
1,ğ‘—)} ğ‘— âˆˆ[ğ‘ ])
by P and V where (id
(1) If ğ‘id0,ğ‘— = ğ‘id1,ğ‘— for all ğ‘— âˆˆ [ğ‘], then output (success)
0,ğ‘— , ğ‘id0,ğ‘—), (id
to V, otherwise output abort.
Figure 2: Functionality FDabit checking daBits.
0,ğ‘— , id
0,ğ‘— , id
1,ğ‘— , ğ‘id1,ğ‘—) âˆˆ st.
On a high level, Î Conv, in Figure 3, consists of three phases:
(1) Initially, P commits to auxiliary random edaBits, daBits and
multiplication triples necessary for the check. The daBits are
verified separately, and then V chooses a random permutation.
(2) After permuting the edaBits and multiplication triples, both
parties run an implicit cut-and-choose phase. Here, P opens ğ¶
of the edaBits and triples, which are checked by V.
(3) We place each conversion tuple into one of ğ‘ buckets, each of
which contains a conversion tuple ([ğ‘0]2, . . . , [ğ‘ğ‘šâˆ’1]2, [ğ‘]ğ‘€),
and a set of ğµ edaBits {([ğ‘Ÿ0]2, . . . , [ğ‘Ÿğ‘šâˆ’1]2, [ğ‘Ÿ]ğ‘€)ğ‘–}ğµâˆ’1
ğ‘–=0 . None
of these have been proven consistent, but ğ¶ edaBits coming
from the same pool have been opened in the previous step.
Now, over ğµ iterations the prover and verifier for each ğ‘— âˆˆ
[ğµ] compute [ğ‘ + ğ‘Ÿ ğ‘—]ğ‘€ = [ğ‘]ğ‘€ + [ğ‘Ÿ ğ‘—]ğ‘€ and use an addition
circuit to check that ([ğ‘’0]2, . . . , [ğ‘’ğ‘š]2) = ([ğ‘0]2, . . . , [ğ‘ğ‘šâˆ’1]2)+
([ğ‘Ÿ0]2, . . . , [ğ‘Ÿğ‘šâˆ’1]2). The addition circuit is evaluated using the
multiplication triples (which also may be inconsistent).
For the checks within each bucket, we use the two sub-protocols
convertBit2A (Figure 4) and bitADDcarry (Figure 5). The former
converts an authentication of a bit [ğ‘]2 into an arithmetic au-
thentication [ğ‘]ğ‘€ while the latter adds two authenticated values
([ğ‘¥0]2, . . . , [ğ‘¥ğ‘šâˆ’1]2) and ([ğ‘¦0]2, . . . , [ğ‘¦ğ‘šâˆ’1]2). This uses a ripple-
carry adder circuit, which satisfies the following weak tamper-
resilient property, as observed in [16].
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea196]2, . . . , [ğ‘Ÿ ( ğ‘—)
ğ‘šâˆ’1]2, [ğ‘Ÿ ( ğ‘—)]ğ‘€) ğ‘— âˆˆ[ğ‘ ğµ+ğ¶].
and
V
send
0 ]2, . . . , [ğ‘(ğ‘–)
(VerifyDabit, ğ‘ ğµ,
ğ‘šâˆ’1]2, [ğ‘(ğ‘–)]ğ‘€}ğ‘–âˆˆ[ğ‘ ].
([ğ‘¥ ( ğ‘—)]2, [ğ‘¦( ğ‘—)]2, [ğ‘§( ğ‘—)]2) ğ‘— âˆˆ[ğ‘ ğµğ‘š+ğ¶ğ‘š]
Protocol Î Conv
Assume that FDabit contains ğ‘ committed conversion tu-
ples {[ğ‘(ğ‘–)
// P commits auxiliary values for conversion check.
daBits are then verified.
(1) P commits to the following values using FDabit:
(a) Random edaBits ([ğ‘Ÿ ( ğ‘—)
0
(b) Random daBits ([ğ‘( ğ‘—)]2, [ğ‘( ğ‘—)]ğ‘€) ğ‘— âˆˆ[ğ‘ ğµ].
(c) Random multiplication triples
(2) P
{([ğ‘( ğ‘—)]2, [ğ‘( ğ‘—)]ğ‘€)} ğ‘— âˆˆ[ğ‘ ğµ]) to FDabit.
// P and V shuffle the auxiliary values and a subset gets
opened and verified.
(3) V samples uniformly random permutations ğœ‹1 âˆˆ
ğ‘†ğ‘ ğµ+ğ¶, ğœ‹2 âˆˆ ğ‘†ğ‘ ğµ, ğœ‹3 âˆˆ ğ‘†ğ‘ ğµğ‘š+ğ¶ğ‘š and sends them to P.
(4) Both
parties
edaBits
[ğ‘Ÿ ( ğ‘—)
ğ‘šâˆ’1]2, [ğ‘Ÿ ( ğ‘—)]ğ‘€ locally according to ğœ‹1.
0
They then shuffle [ğ‘( ğ‘—)
ğ‘€ ]ğ‘€ according to ğœ‹2 and
2
[ğ‘¥ ( ğ‘—)]2, [ğ‘¦( ğ‘—)]2, [ğ‘§( ğ‘—)]2 according to ğœ‹3.
(5) Run a cut-and-choose procedure as follows:
(a) P opens {[ğ‘Ÿ ( ğ‘—)
0
ğ‘—=ğ‘ ğµ+1 (the
last ğ¶ edaBits) towards V, who in turn checks that
ğ‘Ÿ ( ğ‘—) ?
(b) P opens the ğ‘¥, ğ‘¦ values for the last ğ¶ğ‘š triples
{[ğ‘¥ ( ğ‘—)]2, [ğ‘¦( ğ‘—)]2}ğ‘ ğµğ‘š+ğ¶ğ‘š
ğ‘—=ğ‘ ğµğ‘š+1 and proves to V that
CheckZero([ğ‘§( ğ‘—)]2âˆ’ğ‘¥ ( ğ‘—) Â·ğ‘¦( ğ‘—)) for all opened triples.
ğ‘šâˆ’1]2, [ğ‘Ÿ ( ğ‘—)]ğ‘€}ğ‘ ğµ+ğ¶
=ğ‘šâˆ’1
ğ‘–=0 2ğ‘– Â· ğ‘Ÿ ( ğ‘—)
]2, . . . , [ğ‘Ÿ ( ğ‘—)
]2, . . . , [ğ‘Ÿ ( ğ‘—)
]2, [ğ‘( ğ‘—)
shuffle
the
.
ğ‘–
edaBit and [ğ‘ + ğ‘Ÿ]ğ‘€ = [ğ‘]ğ‘€ + [ğ‘Ÿ]ğ‘€.
bitADDcarry([ğ‘0]2, . . . , [ğ‘ğ‘šâˆ’1]2, [ğ‘Ÿ0]2, . . . , [ğ‘Ÿğ‘šâˆ’1]2).
using the (ğ‘– âˆ’ 1) Â· ğµ + ğ‘—â€™th daBit ([ğ‘]2, [ğ‘]ğ‘€).
// P and V verify each conversion tuple in a bucket.
(6) For the ğ‘–â€™th conversion tuple [ğ‘0]2, . . . , [ğ‘ğ‘šâˆ’1]2, [ğ‘]ğ‘€,
do the following for ğ‘— âˆˆ [ğµ]:
(a) Let [ğ‘Ÿ0]2, . . . , [ğ‘Ÿğ‘šâˆ’1]2, [ğ‘Ÿ]ğ‘€ be the (ğ‘– âˆ’ 1) Â· ğµ + ğ‘—â€™th
(b) Let ([ğ‘’0]2, . . . , [ğ‘’ğ‘š]2) â†
(c) Convert [ğ‘’ğ‘š]ğ‘€ â† convertBit2A([ğ‘’ğ‘š]2)
(d) Let [ğ‘’â€²]ğ‘€ â† [ğ‘ + ğ‘Ÿ]ğ‘€ âˆ’ 2ğ‘š Â· [ğ‘’ğ‘š]ğ‘€.
(e) Let ğ‘’ğ‘– â† Open([ğ‘’ğ‘–]2) for ğ‘– = 0, . . . , ğ‘š âˆ’ 1. Then run
ğ‘–=0 2ğ‘– Â· ğ‘’ğ‘–).
(7) If any of the checks fail, V outputs abort. Otherwise it
outputs (success).
CheckZero([ğ‘’â€²]ğ‘€ âˆ’ğ‘šâˆ’1
Figure 3: Protocol Î Conv to verify Conversion Tuples
2 â†’ Zğ‘š+1
Definition 3.2. A binary circuit ğ¶ : Z2ğ‘š
is weakly
additively tamper resilient, if given any additively tampered circuit
ğ¶âˆ—, obtained by flipping the output of any fixed number of AND
gates in ğ¶, one of the following two properties hold:
(1) âˆ€(ğ‘¥, ğ‘¦) âˆˆ Z2ğ‘š
2
(2) âˆ€(ğ‘¥, ğ‘¦) âˆˆ Z2ğ‘š
2
: ğ¶(ğ‘¥, ğ‘¦) = ğ¶âˆ—(ğ‘¥, ğ‘¦); or
: ğ¶(ğ‘¥, ğ‘¦) â‰  ğ¶âˆ—(ğ‘¥, ğ‘¦)
2
Procedure convertBit2A
Input A daBit ([ğ‘Ÿ]2, [ğ‘Ÿ]ğ‘€) and a commitment [ğ‘¥]2.
Protocol
(1) ğ‘ â† Open([ğ‘Ÿ]2 âŠ• [ğ‘¥]2).
(2) Output [ğ‘¥]ğ‘€ â† ğ‘ + [ğ‘Ÿ]ğ‘€ âˆ’ 2 Â· ğ‘ Â· [ğ‘Ÿ]ğ‘€.
Figure 4: Procedure to convert bit from Z2 to Zğ‘€.
Procedure bitADDcarry
Input Commitments [ğ‘¥0]2, . . . , [ğ‘¥ğ‘šâˆ’1]2, [ğ‘¦0]2, . . . , [ğ‘¦ğ‘šâˆ’1]2.
Protocol Let ğ‘0 = 0.
(1) Compute [ğ‘ğ‘–+1]2 = [ğ‘ğ‘–]2 âŠ• (([ğ‘¥ğ‘– âŠ• ğ‘ğ‘–]2) âˆ§ ([ğ‘¦ğ‘– âŠ•
(2) Output [ğ‘§ğ‘–]2 = [ğ‘¥ğ‘– âŠ• ğ‘¦ğ‘– âŠ• ğ‘ğ‘–]2,âˆ€ğ‘– âˆˆ {0, . . . , ğ‘š âˆ’ 1} and
ğ‘ğ‘–]2)),âˆ€ğ‘– âˆˆ {0, . . . , ğ‘š âˆ’ 1}
[ğ‘ğ‘š]2.
Figure 5: A ripple-carry adder
Note that the type of additive tampering in Definition 3.2 models
the errors induced by faulty multiplication triples, when used to
evaluated a circuit in ZK or MPC. Intuitively, the definition says that
the output of the tampered circuit is either incorrect on every pos-
sible input or equivalent to the original un-tampered circuit. This
gives us the property that an adversary cannot pass the verification
protocol using a tampered circuit with both a good conversion
tuple and a bad one. Thus, if any provided multiplication triples are
incorrect, then the check at those positions would only pass with
either a good or a bad conversion tuple (or edaBit), but not both.
While bitADDcarry will ensure that (assuming correct triples)
([ğ‘’0]2, . . . , [ğ‘’ğ‘š]2) are computed as required, care must be taken
regarding [ğ‘ + ğ‘Ÿ ğ‘—]ğ‘€ as this may not be representable by ğ‘š bits any
longer (but rather ğ‘š+1). To remedy this, we use a daBit to convert
[ğ‘’ğ‘š]2 into an arithmetic authentication [ğ‘’ğ‘š]ğ‘€ to remove the carry
from [ğ‘ + ğ‘Ÿ ğ‘—]ğ‘€ by computing [ğ‘’â€²]ğ‘€ = [ğ‘ + ğ‘Ÿ ğ‘—]ğ‘€ âˆ’ 2ğ‘š Â· [ğ‘’ğ‘š]ğ‘€. Now
all that remains is to open [ğ‘’â€²]ğ‘€ (which â€œhidesâ€ ğ‘ using ğ‘Ÿ ğ‘—) as well
as ([ğ‘’0]2, . . . , [ğ‘’ğ‘šâˆ’1]2) and check that ğ‘’â€² ?
=ğ‘šâˆ’1
mod 2ğ‘š. This can then be compared withğ‘šâˆ’1
Remark 1. When ğ‘€ = 2ğ‘˜, we can optimize Î Conv by removing
the conversion step 6(d), which uses daBits. Instead, we simply ignore
the carry bit and set ğ‘’ğ‘š = 0, then in step (f), we can compute ğ‘’â€² by
first opening 2ğ‘˜âˆ’ğ‘š(ğ‘+ğ‘Ÿ), then divide this by 2ğ‘˜âˆ’ğ‘š to obtain ğ‘’â€² = ğ‘+ğ‘Ÿ
ğ‘–=0 2ğ‘– Â· ğ‘’ğ‘–.
ğ‘–=0 ğ‘’ğ‘–, as required.
Our implementation shows that our approach outperforms or
is competitive with all prior work. We discuss the implementation
and the concrete performance in Section 6.
3.3 Proof of security
Due to space constraints, the full proof of security can be found in
the full version [3]. We summarize the proof below.
In order to prove the security of Î Conv, we first observe that
instead of letting P choose multiplication triples, we might equiva-
lently model this by letting P specify circuits instead (that will be
evaluated instead of the Ripple Carry Adder). Then, we define an
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea197abstraction of the protocol as a balls-and-bins type game, similar
to [16], and analyze the success probability of an adversary in this
game.A winning in this abstraction rather than in the protocol
Î Conv. We make this abstraction, as a straightforward analysis of
the conversion protocol is rather complex. This is due to there being
multiple ways for A to pass the check with a bad conversion tuple.
The first is by corrupting ğ¾ conversion tuples, then corrupting ğ¾ Â· ğµ
edaBits and hoping that these end up in the right buckets, cancel-
ing out the errors in the conversion tuples. The second approach
is to corrupt a set of edaBits and then guess the arrangement of
these, thus yielding how many circuits A would have to corrupt in
order to cancel out the errors of the conversion tuples. Furthermore,
conversion tuples (and edaBits) may be corrupted in several ways.
To avoid these issues, we describe an abstract security game which
only provides a better chance for the adversary to win than the
original protocol. In summary, we show the following:
Theorem 3.3. The probability of Î Conv not detecting at least
one incorrect conversion tuple is upper bounded by 2âˆ’ğ‘  whenever
ğ‘ â‰¥ 2ğ‘ /(ğµâˆ’1) and ğ¶ = ğ¶â€² = ğµ for bucket size ğµ âˆˆ {3, 4, 5}.
The proof can be found in the full version [3]. The approach is
similar to that of [16], however in our case since the conversion tu-
ples are now fixed to be one per bucket, we have not taken a random
permutation across all edaBits and conversion tuples. Therefore,
we need a different analysis to show that this restriction on the
permutation still suffices.
Using this, in the full version [3] we then prove security of Î Conv:
Theorem 3.4. Let ğ‘ â‰¥ 2ğ‘ /(ğµâˆ’1), ğ¶ = ğ¶â€² = ğ¶â€²â€² = ğµ and ğµ âˆˆ
{3, 4, 5} such that
ğ‘ 
ğµâˆ’1 > ğµ, then protocol Î Conv (Figure 3) UC-
realises FConv (Figure 1) in the FDabit-hybrid model. Specifically, no
environment Z can distinguish the real-world execution from the
ideal-world execution except with probability at most 2âˆ’ğ‘ .
3.4 Faulty daBits
When working in Zğ‘ (i.e. ğ‘€ = ğ‘), our previous protocol requires a
source of daBits, namely, committed tuples ([ğ‘]2, [ğ‘]ğ‘€), where ğ‘
is a random bit. Generating consisting daBits requires verifying
that [ğ‘]ğ‘€ indeed contains a bit, which is done with a potentially
costly multiplication check by showing that ğ‘(1 âˆ’ ğ‘) = 0. In this
section, we optimize the protocol for the Zğ‘ case by showing that
Î Conv remains secure even with potentially faulty daBits. More
concretely, convertBit2A (which is part of the verification protocol)
will use daBits which are only proven consistent modulo 2. This
is much cheaper to achieve and avoids to check that ğ‘â€² is a bit.
Definition 3.5. A faulty daBit is a pair ([ğ‘]2, [ğ‘â€²]ğ‘€) such that
ğ‘ â‰¡ ğ‘â€² mod 2, but not necessarily ğ‘â€² âˆˆ {0, 1}.
ğ‘š]ğ‘€ such that ğ‘’ğ‘š = ğ‘’â€²
In Step 6 of Î Conv (Figure 3), daBits are used in convertBit2A
(Figure 4) to transform the final carry bit [ğ‘’ğ‘š]2 from bitADDcarry
(Figure 5) into [ğ‘’â€²
ğ‘š. We show that using a
faulty daBit cannot help the adversary in passing the check with
incorrect conversions. First, we observe that with a faulty daBit,
the output becomes ğ‘’â€²
ğ‘š = ğ‘’ğ‘š + (âˆ’1)ğ‘’ğ‘š Â· ğ›¿ where ğ›¿ = (âˆ’1)ğ‘ Â· (ğ‘â€²âˆ’ğ‘)
where (ğ‘â€² âˆ’ ğ‘) > 1 represents the difference (or error) between ğ‘â€²
and ğ‘ for the used daBit ([ğ‘]2, [ğ‘â€²]ğ‘€). As a result, |ğ‘’â€²
ğ‘š| > 1 where
| Â· | denotes absolute value. This carry bit [ğ‘’â€²