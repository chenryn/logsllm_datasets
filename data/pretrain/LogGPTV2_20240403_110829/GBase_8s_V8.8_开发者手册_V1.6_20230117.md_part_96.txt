AUTONOMOUS_TRANSACTION，其余语法与创建存储过程语法相同，示例如下。
--建表
createtablet2(aint,bint);
insertintot2values(1,2);
select*fromt2;
南大通用数据技术股份有限公司
738
GBase 8s V8.8开发者手册
--创建包含自治事务的存储过程
CREATEORREPLACEPROCEDUREautonomous_4(aint,bint) AS
DECLARE
num3int:=a;
num4int:=b;
PRAGMAAUTONOMOUS_TRANSACTION;
BEGIN
insertintot2values(num3,num4);
END;
/
--创建调用自治事务存储过程的普通存储过程
CREATEORREPLACEPROCEDUREautonomous_5(aint,bint) AS
DECLARE
BEGIN
insertintot2values(666,666);
autonomous_4(a,b);
rollback;
END;
/
--调用普通存储过程
selectautonomous_5(11,22);
--查看表结果
select*fromt2orderbya;
上述例子，最后在回滚的事务块中执行包含自治事务的存储过程，直接说明了自治事务
的特性，即主事务的回滚，不会影响自治事务已经提交的内容。
南大通用数据技术股份有限公司
739
GBase 8s V8.8开发者手册
18.2匿名块支持自治事务
自治事务可以在匿名块中定义，标识符为PRAGMAAUTONOMOUS_TRANSACTION，
其余语法与创建匿名块语法相同，示例如下。
createtablet1(aint,btext);
STARTTRANSACTION;
DECLARE
PRAGMAAUTONOMOUS_TRANSACTION;
BEGIN
insertintot1values(1,'youaresocute,willcommit!');
END;
/
insertintot1values(1,'youwillrollback!');
rollback;
select*fromt1;
上述例子，最后在回滚的事务块前执行包含自治事务的匿名块，也能直接说明了自治事
务的特性，即主事务的回滚，不会影响自治事务已经提交的内容。
18.3用户自定义函数支持自治事务
自治事务可以在函数中定义，标识符为PRAGMAAUTONOMOUS_TRANSACTION，
执行的函数块中使用包含 start transaction 和 commit/rollback 的 sql，其余语法与 CREATE
FUNCTION创建函数语法类似，一个简单的用例如下：
--创建表。
CREATETABLEtest1(aint,btext);
--创建包含自治事务的函数。
南大通用数据技术股份有限公司
740
GBase 8s V8.8开发者手册
CREATEORREPLACEFUNCTIONautonomous_easy_2(iint)RETURNSinteger
LANGUAGEplpgsql
AS$$
DECLARE
PRAGMAAUTONOMOUS_TRANSACTION;
BEGIN
STARTTRANSACTION;
INSERTINTOtest1VALUES(2,'a');
IFi%2=0THEN
COMMIT;
ELSE
ROLLBACK;
ENDIF;
RETURNi%2=0;
END;
$$;
--执行命令。
selectautonomous_easy_2(1);
--执行结果。
autonomous_easy_2
-------------------
0
(1row)
--执行命令，查询表数据。
select*fromtest1;
--执行结果。
a|b
---+---
(0rows)
--执行命令。
南大通用数据技术股份有限公司
741
GBase 8s V8.8开发者手册
selectautonomous_easy_2(2);
--执行结果。
autonomous_easy_2
-------------------
1
(1row)
--执行命令，查询表数据。
select*fromtest1;
--执行结果
a|b
---+---
2|a
(1row)
--清空表数据。
truncatetabletest1;
--在回滚的事务块中执行包含自治事务的函数。
begin;
insertintotest1values(1,'b');
selectautonomous_easy_2(2);
rollback;
--检查表数据。
select*fromtest1;
--执行结果如下。
a|b
---+---
2|a
(1row)
上述例子，最后在回滚的事务块中执行包含自治事务的函数，直接说明了自治事务的特
性，即主事务的回滚，不会影响自治事务已经提交的内容。
南大通用数据技术股份有限公司
742
GBase 8s V8.8开发者手册
18.4规格约束
注意：
- 自治事务执行时 ，将会在后台启动自治事务 session，我们可以通 过
max_concurrent_autonomous_transactions设置自治事务执行的最大并行数量，该参数取值范
围为0~1024，默认值为10。
- 当max_concurrent_autonomous_transactions参数设置为0时，自治事务将无法执行。
- 自治事务新启session后，将使用默认session参数，不共享主session下对象（包括
session级别变量，本地临时变量，全局临时表的数据等）。
 触发器函数不支持自治事务。
CREATETABLEtest_trigger_des_tbl(id1INT,id2INT,id3INT);
CREATEORREPLACEFUNCTIONtri_insert_func()RETURNSTRIGGERAS
$$
DECLARE
PRAGMAAUTONOMOUS_TRANSACTION;
BEGIN
INSERTINTOtest_trigger_des_tblVALUES(NEW.id1,NEW.id2,NEW.id3);
RETURNNEW;
END
$$LANGUAGEPLPGSQL;
 自治事务不支持非顶层匿名块调用（仅支持顶层自治事务,包括存储过程、函数、匿名
块）。
 自治事务不支持ref_cursor参数传递。
createtablesections(section_IDint);
南大通用数据技术股份有限公司
743
GBase 8s V8.8开发者手册
insertintosectionsvalues(1);
insertintosectionsvalues(1);
insertintosectionsvalues(1);
insertintosectionsvalues(1);
CREATEORREPLACEfunctionproc_sys_ref()
returnSYS_REFCURSOR
IS
declare
PRAGMAAUTONOMOUS_TRANSACTION;
C1SYS_REFCURSOR;
BEGIN
OPENC1FORSELECTsection_IDFROMsectionsORDERBYsection_ID;
returnC1;
END;
/
CREATEORREPLACEPROCEDUREproc_sys_call()AS
DECLARE
C1SYS_REFCURSOR;
TEMPNUMBER(4);
BEGIN
c1=proc_sys_ref();
ifc1%isopenthen
raisenotice'%','ok';
endif;
LOOP
FETCHC1INTOTEMP;
raisenotice'%',C1%ROWCOUNT;
南大通用数据技术股份有限公司
744
GBase 8s V8.8开发者手册
EXITWHENC1%NOTFOUND;
ENDLOOP;
END;
/
selectproc_sys_call();
CREATEORREPLACEfunctionproc_sys_ref(OUTC2SYS_REFCURSOR,OUTaint)
returnSYS_REFCURSOR
IS
declare
PRAGMAAUTONOMOUS_TRANSACTION;
C1SYS_REFCURSOR;
BEGIN
OPENC1FORSELECTsection_IDFROMsectionsORDERBYsection_ID;
returnC1;
END;
/
CREATEORREPLACEPROCEDUREproc_sys_call()AS
DECLARE
C1SYS_REFCURSOR;
TEMPNUMBER(4);
aint;
BEGIN
OPENC1FORSELECTsection_IDFROMsectionsORDERBYsection_ID;
c1=proc_sys_ref(C1,a);
ifc1%isopenthen
raisenotice'%','ok';
endif;
南大通用数据技术股份有限公司
745
GBase 8s V8.8开发者手册
LOOP
FETCHC1INTOTEMP;
raisenotice'%',C1%ROWCOUNT;
EXITWHENC1%NOTFOUND;
ENDLOOP;
END;
/
selectproc_sys_call();
 自治事务函数不支持返回非out形式的record类型。
 不支持修改自治事务的隔离级别。
 不支持自治事务返回集合类型（setof）。
createtabletest_in(idint,adate);
createtabletest_main(idint,adate);
insertintotest_mainvalues(1111,'2021-01-01'),(2222,'2021-02-02');
truncatetest_in,test_main;
CREATEORREPLACEFUNCTIONautonomous_f_022(num1 int)RETURNSSETOF
test_in
LANGUAGEplpgsqlAS$$
DECLARE
countint:=3;
test_rowtest_in%ROWTYPE;
PRAGMAAUTONOMOUS_TRANSACTION;
BEGIN
whiletrue
loop
ifcount=3then
null;
else
南大通用数据技术股份有限公司
746
GBase 8s V8.8开发者手册
ifcount=2then
insertintotest_mainvalues(count,'2021-03-03');
gotopos1;
endif;
endif;
count=count-1;
endloop;
insertintotest_mainvalues(1000,'2021-04-04');
>
fortest_rowinselect*fromtest_main
loop
returnnexttest_row;
endloop;
return;
END;
$$
;
19 系统表和系统视图
19.1系统表和系统视图概述
系统表是GBase8s存放结构元数据的地方，它是GBase8s数据库系统运行控制信息的
来源，是数据库系统的核心组成部分。
系统视图提供了查询系统表和访问数据库内部状态的方法。
系统表和系统视图要么只对管理员可见，要么对所有用户可见。后续的系统表和系统视
图章节有些标识了需要管理员权限，这些系统表和系统视图只有管理员可以查询。
用户可以删除后重新创建这些表、增加列、插入和更新数值，但是用户修改系统表会导
致系统信息的不一致，从而导致系统控制紊乱。正常情况下不应该由用户手工修改系统表或