6.2 Transparent Forensic Logging
To help investigate potential abuses, to support auditing,
and to help debug our platform we wanted to collect various
local information, such as the destination of traﬃc and the
rate of resource consumption. An important requirement
of this collection is that the researcher using the machine
should not be able to modify the collected data.
We implemented this functionality in a required library
by interposing on the calls that need to be logged and then
writing out the collected data into a ﬁle. To prevent modiﬁ-
cation or deletion of this ﬁle, the library traps the openfile
and removefile capabilities. Leveraging security layers en-
abled us to move this functionality outside of the sandbox
kernel, without sacriﬁcing transparency for the application
code.
6.3 Dynamic Policy Loading
An administrator may want to add or remove security
layers for a large number of machines under their control.
However, making the change on each system manually is
time prohibitive. We constructed an administrator control
required library, which retrieves a list of security layers to
load from a user-speciﬁed server. This list is signed with the
administrator’s private key (along with other security meta-
data to prevent replay attacks), and contains the names, lo-
cations, and secure hashes of the security layers to be loaded.
6.4 Location-Aware Resource Restriction
Required libraries also make it easy to construct adaptive
policies. An example of this is a policy that changes de-
pending on the machine’s location. We implemented such
a policy as a required library that periodically checks the
machine’s IP address and changes the capabilities set based
on the machine’s geolocation. This allows a user to have
diﬀerent network restrictions when their laptop is at home
or at work, for example.
7. EVALUATION
In this section we evaluate our approach. First we com-
pare the resiliency of our sandbox to the JVM. We do so by
considering previous security bug reports for the Java code
portion of the JVM [42]. We manually translate these bugs
into the context of our sandbox to understand how they
would manifest. We categorize the impact of these bugs on
our sandbox and detail how security layers help to mitigate
them. Second, we evaluate the cost of our techniques by
quantifying the performance impact and memory overhead
of constructing and using security layers in Python.
7.1 Risk Reduction
To evaluate the change in risk with using security layers,
we considered the set of critical Java security vulnerabilities
studied by Paul and Evans [42]. For each bug, we attempted
to understand how the vulnerability impacts our sandbox if
the component containing the vulnerability were translated
into our sandbox. Our translation was guided by consider-
ing how the buggy component would be implemented in our
system, relying on the underlying motivation of our project
to migrate as much functionality as possible out of the sand-
box kernel. Because this evaluation eﬀort is inherently qual-
itative we mitigated the subjective nature of the analysis
by employing three authors to independently categorize the
severity of each bug. The authors then actively discussed
the bugs where they had any category disagreement until
a complete consensus on the appropriate category for each
bug was reached.
Table 1 describes the bugs, their severity in Java, and their
categorized severity in our sandbox. The values in the secu-
rity layer severity column of this table mean the following:
Prevented – bug cannot manifest in our sandbox; Insuﬃcient
detail – bug report did not provide enough information to
make the translation possible; Cannot translate – the bug is
speciﬁc to the JVM and cannot be mapped into the context
of our sandbox; Exception – an exception is raised when the
bug is triggered; Hang – the bug hangs the sandbox; Allowed
– the bug is explicitly allowed to manifest due to security
policies of our sandbox kernel; Unknown – the bug does not
have a single deﬁnitive translation.
The most critical bugs in Table 1 allow arbitrary code
execution or read access to the entire ﬁle system. We now
discuss these critical bugs in more detail in the order they
appear in the table.
• Leveraging the bug in CVE-2001-1008 an attacker can
execute signed code with expired signatures. This is a
risk because this code may be native code containing
ﬂaws. Our sandbox prohibits users from executing na-
tive code (whether signed or not). The closest transla-
tion of this bug would manifest as a security layer that
only loads code if the code is signed. A similar ﬂaw
in this layer would allow malicious code to be loaded
and executed, however the malicious code would not
be able to escape the sandbox.
• CVE-2005-3905 and CVE-2005-3906 provide insuﬃ-
cient information to make a translation possible.
If
the reﬂection vulnerabilities exist due to bugs in type
217Short Description
Execute apps with expired signatures
Reﬂection vulnerability 1 & 2
XML/DB vulnerability allows code loading
CAB loader missing security
Bytecode veriﬁer buﬀer ﬂaw 1 & 2
Bytecode veriﬁer loads an unchecked class
Bug Number
CVE-2001-1008
CVE-2005-3905/3906
CVE-2002-0865/0866
CVE-2002-1293
CVE-1999-0766/0141
CVE-1999-0440
CVE-2000-0327/2002-0076 Bytecode veriﬁer cast bug 1 & 2
CVE-2003-0111
CVE-2004-2627
CVE-2003-0896
CVE-2000-0676
CVE-2000-0162
CVE-2000-0711
CVE-2000-0563
CVE-1999-0142/1262
CVE-2002-0058
CVE-2002-0867
CVE-2002-1289
CVE-2003-0525
CVE-2002-1287
CVE-2005-3583
CVE-2004-1503
CVE-2004-2540
CVE-2004-0651
CVE-2002-1292
CVE-2004-0723
CVE-2002-1260
CVE-2002-1290
CVE-2002-1288/1325
CVE-2002-0979
Bytecode veriﬁer unknown bug
Bytecode veriﬁer bytecode bug
A ’/’ in a classname bypasses security
Can use file:/// to read arbitrary ﬁles
Remote attacker can read ﬁles
Incorrect ServerSocket creation
Arbitrary connection via HTTP redirection
Arbitrary outgoing connections 1 & 2
Session hijack if client uses proxy
Handle validation crashes JVM
No address validation for native services
Double free from getCanonicalPath
Long classname crashes JVM
Deserialization may crash JVM
Integer overﬂow in DNS raises exception
readObject may hang the JVM
Unknown vulnerability
Can manipulate class loading security
Cross-site ﬁle system communication
DB access missing checks
Applets can manipulate clipboard
Applet can discover PWD 1 & 2
Applet may write executable to known path
Security Layer Severity
Java Severity
Prevented
Arbitrary
Insuﬃcient detail
Arbitrary
Prevented
Arbitrary
Prevented
Arbitrary
Cannot translate
Arbitrary
Prevented
Arbitrary
Cannot translate
Arbitrary
Cannot translate
Arbitrary
Cannot translate
Arbitrary
Prevented
Arbitrary
Prevented
File Read
Prevented
File Read
Allowed
Socket
Allowed
Socket
Allowed
Socket
Allowed
Socket
Exception
Unclear
Prevented
Unclear
Prevented
Unclear
Prevented
Crash
Prevented
Crash
Exception
Exception
Hang
Hang
Insuﬃcient detail
Hang
Prevented
Unclear
Prevented
Information leak
DB access
Unknown
Clipboard access Unknown
Directory Info
Unknown
Unknown
Unknown
Table 1: A listing and description of JVM security vulnerabilities from [42] that we translated into the context
of our sandbox to study the risk reduction beneﬁts of our sandbox. For those bugs where the translation was
feasible, the last column indicates the severity of the bug once it was translated. Values in this column are
deﬁned in the text. The bugs are sorted according to the order in which they are discussed in the text.
conversion or memory safety, similar bugs would allow
arbitrary code execution in our sandbox as well. How-
ever, if the ﬂaws are related to incorrect capabilities
when using reﬂection, there is no security risk as this
portion of our implementation (e.g. eval) exists in a
security layer.
• CVE-2002-0865, CVE-2002-0866, and CVE-2002-1293
are the result of diﬀerent standard libraries using cus-
tom code loading mechanisms. In our sandbox, cus-
tom code loading functionality would be implemented
inside the security layer hosting the standard library
(e.g. XML, CAB). This would prevent the vulnerabil-
ity.
• CVE-1999-0766, CVE-1999-0141 CVE-2000-0327, CVE-
2002-0076, CVE-2003-0111, and CVE-2004-2627 can-
not be easily translated because the bug descriptions
have inadequate information. These bugs are in the
bytecode veriﬁer which is signiﬁcantly diﬀerent in
Java and Python. Our implementation does not load
Python bytecode, but instead passes the interpreter
the program’s source (Appendix A). However, our im-
plementation would prevent CVE-1999-0440 (a miss-
ing check for bytecode security), since the only way
to load code is through a single call provided by the
sandbox kernel.
• The critical vulnerability CVE-2003-0896 and ﬁle ac-
cess bugs like CVE-2000-0676 and CVE-2000-0162 ex-
ist because of insuﬃcient checks on ﬁle system access.
In our implementation, there is a single set of routines
in the sandbox kernel that all routines must use. We
prevent this category of ﬂaws by placing the appropri-
ate ﬁle system access check in a single place.
One category of bugs listed in Table 1 deals with violations
of the same-origin policy (CVE-2000-0711, CVE-2000-0563,
CVE-1999-0142, CVE-1999-1262, and CVE-2002-0058). As
our sandbox is in part used for networking research, our net-
work policy is more permissive than the same-origin policy.
Namely, our users typically choose between allowing arbi-
trary network connections (no security layer interposition)
or use a security layer like the Controlled Node Communi-
cation layer (Section 6.1).
There is also a large class of bugs that crash or hang the
JVM (CVE-2002-0867, CVE-2002-1289, CVE-2003-0525,
CVE-2002-1287, CVE-2005-3583, CVE-2004-1503, CVE-
2004-2540, and CVE-2004-0651), and possibly lead to more
serious attacks.
In our framework, these bugs most likely
result in exceptions or hang the sandbox, thus having a
similar denial-of-service eﬀect.
The security policy manipulation bug (CVE-2002-1292)
exists because Java had outdated security checks that an
attacker can manipulate. Since valid security policies rarely
use this interface, the main impact of the vulnerability would
be to allow a malicious party to prevent the loading of ar-
bitrary classes. A similar vulnerability would exist in our
218No args
General
5.9 µs
Custom .15 µs
Immutable Mutable Exception
12 µs
.80 µs
8.8 µs
1.1 µs
15 µs
1.7 µs
Table 2: Call overhead for general and customized se-
curity layer veriﬁcation routines.
framework if an outdated security layer with a vulnerability
was loaded on client machines.
The ﬁnal classiﬁcation of bugs are those that leak sen-
sitive information or access, but do not allow escape of the
sandbox (CVE-2004-0723, CVE-2002-1260, CVE-2002-1290,
CVE-2002-1288, CVE-2002-0979, and CVE-2002-1325). It
is diﬃcult to directly translate these issues to our sandbox.
However, in general using a small sandbox kernel makes