it also leads to a change of the message serializer
and the message parser behavior. The transformation must be
invertible by design to allow the receiver to correctly parse the
obfuscated message. The proposed framework is designed to
be applied to a large set of message format graphs. Thus, we
have deﬁned a set of generic transformations that are presented
in table I. They include ordering transformations such as
ChildMove and TabSplit and some aggregation transformations
such as SplitCat and ConstAdd. This set can be extended with
new generic transformations.
A generic transformation T is a function that consists in
changing a graph pattern a into a graph pattern b, associated
to some applicability constraints. If the graph Gi being obfus-
cated by the framework contains the graph pattern a and if Gi
complies with the constraints of T , then the transformation τi
can be derived and the graph Gi+1 is obtained by replacing the
instantiated graph pattern a by the instantiated graph pattern
b (with a renaming of nodes if needed).
The proposed transformations do not remove any infor-
mation; they can only modify the value or the order of the
different ﬁelds of the message. These transformations are
i ◦τi = id. The main
easily inverted. In other words, we have τ -1
difﬁculty lies in the composition of the message parser and the
message serializer with the transformations. Therefore, these
transformations are constrained to ensure that the composition
of the message parser and the message serializer leads to the
SplitAdd
Serialization pseudocode ↓
Choose a random value X1
Compute X2 = X + X1
Constraints
Boundary of parent nodes must
be either Delegated or End
Challenge
Inference models and classiﬁcation: more dependencies between
ﬁelds in message and various representations of the same message
BoundaryChange
Serialization pseudocode ↑
Measure the serialization of X
Preﬁx the result with this length
Constraints
Boundary of parent nodes must
be either Delegated or End
Challenge
Fields delimitation: delimitation with a length ﬁeld
ReadFromEnd
Serialization pseudocode ↑
Mirror the serialization of X
Constraints
Boundary of parent nodes can
be anything but Delimited
Challenge
Inference models and classiﬁcation: subpart of message read
in reverse order
TabSplit
Serialization pseudocode ↓
Map fst and snd on X
Create the sequence
Constraints
Boundary of parent nodes can
be anything but Delimited and
Boundary of X must be
Delegated
Challenge
Inference models: turn a regular language (AB)∗ into
a context-free language AmBm
ChildMove
Serialization pseudocode ↓
Switch children in X
Constraints
Boundary of parent nodes can
be anything but Delimited and
no nodes inside B must depend
on a node inside A
Challenge
Classiﬁcation: meaningful ﬁelds are no more at the beginning
identity.
The framework memorizes, for each applied transformation
τi, the node in the graph that corresponds to the graph pattern
a. Accordingly, it is able to correctly derive the message
serializer and the message parser, taking into account the
transformations. Some transformations may change the values
of the ﬁelds that are needed to correctly serialize (or parse)
the remaining of the AST (or of the message), for instance
a length ﬁeld. As a result, the strategy adopted is to process
transformations on the ﬂy. The message serializer uses a depth
ﬁrst search on the AST and the transformations are executed
during this graph traversal (same for the message parser).
Each generic transformation can be formatted as presented
in Table II. This table illustrates the more interesting generic
transformations from Table I. Other transformations are small
variation (for instance SplitSub, etc.). For the generic trans-
formations of ﬁgure II, the graph at the left hand side of
the ⇒ symbol corresponds to pattern a and the one at the
right hand side corresponds to the result of the transformation
(pattern b). The serialization pseudocode is generated by the
framework to perform the transformation on the ﬂy. The
vertical arrow indicates if this transformation is performed
before serializing the children (down arrow), or on the result of
the serialization (up arrow). The constraints correspond to the
attributes to check on the node of the pattern, the sub-nodes
and parent nodes. The last information indicated in the table
is the protocol reverse challenge that is emphasized by each
transformation. These challenges are presented in section II-C.
Table II shows that most of the challenges are covered by
one of these generic transformations. The SplitTab and the
ReadFromEnd transformations change a regular language, that
is compatible with most of reverse engineering tools, into a
language that does not ﬁt models traditionally supported by
these tools (for instance, context-free language as anbn). In
particular, the ReadFromEnd encodes a message from right to
left. This practice is unusual and makes the inference of links
between ﬁelds very difﬁcult. The delimitation of ﬁelds that is
easier in presence of Delimited node, is more difﬁcult with
Length node and the BoundaryChange change from the ﬁrst
towards the second. In addition, this generic transformation is
also useful to circumvent some constraints of other generic
transformations. The classiﬁcation is also made more difﬁcult
with generic transformations like SplitAdd that can be applied
on message keywords which are often used to decide classi-
ﬁcation. The only challenge that is not addressed directly by
generic transformation is the Observation. This challenge is
addressed in the implementation of the framework, presented
in section VI.
C. Serializer and parser behavior
As soon as the message serializer starts the serialization of
a node, it inspects the list of transformations to ﬁnd out if one
transformation needs to be applied before serializing the node.
If so, this transformation is executed on the current node of
the AST. Then the message serializer processes the node and
the node with its sub-tree is replaced by a node containing
the result of the serialization. At the end of this processing,
the serializer inspects again the list of transformations to
know if a transformation must also be applied at the end of
the serialization of the node. If so, this transformation is in
turn applied. The parser works in the same way. However,
the parser has to face an additional challenge: to rebuild a
sub-node of AST from the message, it must ﬁrst delimit the
corresponding sub-part in the message.
VI. IMPLEMENTATION
The framework is implemented using the C language.
Lex and Yacc tools are used to parse the message format
speciﬁcation and generate the message format graph. The
structure that represents a message format graph is simply
a transcription in the C language of the attributes presented
in section V-A. Then, each node of the graph is analyzed to
identify compatible generic transformations. A transformation
is randomly chosen among them and applied to the node. This
routine is applied as many times as indicated by a parameter
speciﬁed in the framework. Finally, a depth-ﬁrst search al-
gorithm is executed on the resulting message format graph to
generate the source code. Generic transformations presented in
the previous section cover all reverse engineering challenges
except the Observation challenge. This last challenge is taken
into account during the generation of the code source used
to manipulate, parse and serialize an AST. In the following,
we provide more information on the structure used to store
the AST and the functions generated by the framework that
the core application can use to instantiate this AST (i.e., the
accessors of the AST).
First, let us consider a naive implementation that consists
in instantiating an non-obfuscated AST, during the execution
of the core application, and then, in applying the selected
transformations to the complete non-obfuscated AST to gen-
erate the obfuscated AST which is then serialized. With such
approach, the entire non-obfuscated AST and obfuscated AST
are available in the memory during the execution and a
unique function is used to obfuscate the ﬁrst AST. Therefore
it is easy to locate this function in the memory to recover
the non-obfuscated AST. Obfuscation techniques that process
the binary usually obfuscate the code and the internal data.
However, the AST is designed to generate a message that will
be sent through the network and these obfuscation techniques
ignore these data (in fact, they must not modify the format of
message sent in the network).
Our framework focuses on the message format speciﬁcation.
It can obfuscate an intermediate representation of the AST
that does not correspond neither to the entire non-obfuscated
AST nor to the entire obfuscated AST. In the framework,
this intermediate representation corresponds to the AST after
the application of aggregation transformations and before the
application of ordering transformations. When the core appli-
cation decides to send a message, it generates this temporary
AST through a set of setter functions. These setter functions
perform aggregation transformations on the ﬂy. When the
AST is complete, ordering transformations are applied while
serializing this message. Hence, the serialization is spread into
multiple function calls.
The code source generated by the framework provides
the prototypes of the message parser and serializer, plus the
accessors (setters and getters) and the structures for the in-
termediate AST. Getters and setters are functions that retrieve
or store a value in a ﬁeld while performing the aggregation
transformations, on-the-ﬂy. To make them harder to identify,
they can be implemented as macro, and thus inlined in the
code. This interface must be stable regardless of the chosen
transformations. Accordingly, the set of transformations can
be easily replaced by another set of transformations without
changing the core application. From a practical point of view,
this interface is directly obtained from the non-obfuscated
speciﬁcation of the message format. Accessors will hide the
complexity implied by aggregating transformations while the
code of the parser and serializer hide the complexity implied
by the ordering transformations.
VII. EXPERIMENTATIONS
To evaluate our framework, we have implemented the speci-
ﬁcation of two protocols: a binary protocol, TCP-Modbus [46],
and a text-protocol HTTP [47]. Modbus contains a Tabular
ﬁeld, a Length Boundary and a Counter Boundary, while
HTTP contains an Optional ﬁeld, a Repetitive ﬁeld, as well
as Delimited Boundary. For Modbus protocol, we have also
developed a core application that generates the messages 1,
2, 3, 4, 5, 6, 15 and 16 and their response, as required by
simply modbus2 client implementation. This set of messages
includes all the different formats of Modbus messages. For
HTTP protocol, we have also developed a simpliﬁed core
application. However, this implementation doesn’t create mes-
sages with consistent values for the keywords. We consider this
veriﬁcation to be relevant to the server code, not to the parser
code.
A. Experiments
In order to analyze the impact of the framework, several
experiments are carried out with a different number of ob-
fuscations (0 to 4) per ﬁeld, i.e., per node of the graph. For
each experiment, the transformations are selected randomly
among the set of applicable generic transformations and the
code source of the parser and serializer is generated. The
core application is compiled with this code source. Then,
it is executed to generate different messages with random
values. The source code used to initialize the message and
invoke the serialization process and the parsing process is
the same for all experiments. This validates our new concept
of protocol transformations created at the compilation time:
the code that uses the protocol is simple and independent of
applied transformations.
The results presented in the following subsections for HTTP
and Modbus correspond to 5000 experiments each (1000 for
each obfuscation scenario, from 0 to 4).
B. Measures
During the experiments, different measures were collected.
The time required for the code source generation (i.e., the
parsing of the speciﬁcation, the application of transformations
2http://www.simplymodbus.ca
i.e.
The complexity of the generated code,
the potency
of the obfuscations, is also considered in the experiments.
The number of code lines is the amount of code generated
by the framework for the complete protocol speciﬁcation. It
contains code for serializer, parser and accessors functions,
the internal structures and sanity checks, i.e. the complete
serialization library. Let us recall
the main objective
of our approach is to make the reverse engineering of the
obfuscated protocol signiﬁcantly more difﬁcult for the attacker
than without obfuscation. The increase of the complexity can
be reﬂected e.g., by a higher number of the lines of code or of
the number of internal structures used in the library to store
data during the parsing process.
that
and the code generation) is called Generation time. This
number must be low to allow the developer to easily adjust
the number of desired transformations.
The maximum number of obfuscations per node and the
total number of applied transformations on the graph are
memorized. Multiple experiments with the same number of
transformations per node may lead to different numbers of
effectively applied transformations on the graph. Indeed, ac-
cording to the transformations applied (which are randomly
chosen), the number of obfuscations may be different because
some transformations may create new nodes whereas others do
not create any. Also, some randomly selected transformations
may not be applicable if the associated constraints are not
satisﬁed. So, we compute the average, min and max for this
last metric.
The cﬂow tool is used to extract the call graph for the
parsing process. This graph reﬂects the complexity of function
invocations in the code. We retrieve the size of this graph (the
number of nodes) and its depth.
Finally, we have evaluated the cost of our solution by
measuring the time required to serialize and parse a message,
and the space overhead associated to the serialized message
size (through the evaluation of the buffer size).
C. Results
Results are summarized for each considered protocol in
Tables III, IV, respectively. Three values are indicated, with the
following syntax: average, [min, max]. The results reported for
the potency metrics are normalized by the values associated
to the non-obfuscated version. The cost metrics are provided
in absolute values.
For the simple case where at most one obfuscation is applied
per node (which nevertheless corresponds to an average of
10.1 applied transformations on the HTTP graph and 47.8
applied transformations on the Modbus graph), the complexity
of the generated code is about twice the complexity of the
code without obfuscation. In particular, the increase in the
number of structures reﬂects a signiﬁcant difference between
the initial speciﬁcation and the result of the transformation. For
the other obfuscation cases, these metrics increase as expected.
The highest increase is observed for the call graph size.
To have better insights on the impact of obfuscations, Fig-
ures 6 and 7 plot the evolution of the potency metrics relative
Fig. 4. HTTP: Parsing and serialization time
Fig. 5. Modbus: Parsing and serialization time
increase compared to the non-obfuscated case, according to
the number of obfuscations applied on the graph. Generally,
we observe a linear increasing trend of the number of lines,
the number of structures and the size of the call graph. The
increase of the call graph depth and of the buffer size is slower
and tend to stabilize. The increase of buffer size is kept very
low which is very important especially for application contexts
where network packet resources are usually more crucial than
application execution time.
lines report
The cost of the obfuscations is illustrated in ﬁgures 4 and 5
which present the evolution of the parsing and serialization
times according to the number of transformations applied
on the graph. The straight
the result of the
linear regression between these times and this number of
transformations (the correlation coefﬁcient is also indicated).
These ﬁgures show that inevitably the processing time in the
presence of transformations increases. However, this increase
is linear with the number of transformations applied and
the slope is smooth. This indicates that the overhead due to
these transformations is not important and could be reduced
with a more optimized implementation of the framework.
Note that these results are achieved with a high number of
transformations. A developer may consider it sufﬁcient
to
make only a limited number of transformations. It is also
noteworthy that in all the experiments that we have carried
out, the parsing and serialization times did not exceed 0.5 ms
for Modbus and 2.8 ms for HTTP. The average values are
signiﬁcantly lower.