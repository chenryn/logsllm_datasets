Web Application
Penetration Testing
eXtreme
XSS Filter Evasion and WAF
Bypassing
S e c t i o n 0 1 | M o d u l e 0 4
© Caendra Inc. 2020
All Rights Reserved
Table of Contents
MODULE 04 | XSS FILTER EVASION AND WAF BYPASSING
4.1 Introduction
4.2 Bypassing Blacklisting Filters
4.3 Bypassing Sanitization
4.4 Bypassing Browser Filters
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.2
Learning Objectives
In the first module we covered filtering basics, a set of
controls that can be implemented at different layers to
protect web applications.
In this module, we are going to study some evasion
techniques to fool weakest rules and obtain working XSS
bypass vectors.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.3
4.1
Introduction
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.4
4.1 Introduction
Over the years, many security researchers have developed
guides and cheat sheets to help security professionals in
testing Cross-Site Scripting flaws.
The most notorious was created by RSnake and is called
"XSS Filter Evasion Cheat Sheet“ and was later donated to
OWASP. Another interesting project is HTML5 Security
Cheatsheet by Cure53.
https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.5
http://html5sec.org/
4.1 Introduction
In this module, we are not going to analyze the vectors one by
that are reported in the cheat sheet, but rather detect which of
them are possible scenarios we may run into and see how to
overcome them.
The most common scenarios you will come across are:
1. The XSS vector is blocked by the application or something
else
2. The XSS vector is sanitized
3. The XSS vector is filtered or blocked by the browser
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.6
4.2
Bypassing
Blacklisting Filters
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.7
4.2 Bypassing Blacklisting Filters
Due to ease of installation, filters in blacklist mode are the
most common. Their goal is to detect specific patterns and
prevent malicious behaviors. It is all a matter of "patterns",
the more accurate they are the more often they will prevent
attacks.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.8
Click HEREto go back to Slide 59
4.2.1 Injecting Script Code
The  tag is the primary method which can be
used to execute client-side scripting code such as
JavaScript.
It was designed for this purpose, and of course, this is the
first vector that most filters block.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.9
4.2.1.1 Bypassing Weak  Tag Banning
It may happen that the filters are weak, and do not cover all
the possible cases, making them bypassable.
The following examples are just few bypasses for weak
rules.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.10
4.2.1.1 Bypassing Weak  Tag Banning
 Upper- & Lower-case characters
alert(1);
Upper- & Lower-case characters, without closing tag
Random string after the tag name
ipt>alert(1)ipt> Nested tags
alert(1) NULL byte (IE up to v9)
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.11
4.2.1.2 ModSecurity > Script Tag Based XSS Vectors
Rule
For example, this is how ModSecurity filters the 
tag:
SecRule ARGS
"(?i)(]*>[\s\S]*?]*>|]
*>[\s\S]*?]*>[\s\S]
*?]*>[\s\S]*?]*>[\s\S]*?)"
[continue]
Source> https://github.com/SpiderLabs/owasp-modsecurity- WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.12
crs/blob/master/base_rules/modsecurity_crs_41_xss_attacks.conf
4.2.1.2 ModSecurity > Script Tag Based XSS Vectors
Rule
Clearly, this is not the only way we have to inject script
code.
There are several alternatives in which it is possible to run
our code, such as different HTML tags and related event
handlers.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.13
4.2.1.3 Beyond  Tag…Using HTML Attributes
show
show
send
send
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.14
4.2.1.3 Beyond  Tag…Using HTML Attributes
Here is a tiny tool https://github.com/evilcos/xss.swf
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.15
https://github.com/evilcos/xss.swf
4.2.1.4 Beyond  Tag…Using HTML Events
Events are the way that
HTML DOM adds
interactivity between the
website and its visitors;
this happens simply by
executing the client-side
code (e.g., JavaScript).
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.16
Source> http://www.developphp.com/
4.2.1.4 Beyond  Tag…Using HTML Events
Almost all event handlers identifier start with on and are
followed by the name of the event. One of the most used is
onerror:
But, there are many other events.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.17
http://help.dottoro.com/lhwfcplu.php
4.2.1.4 Beyond  Tag…Using HTML Events
Below are some HTML 4 tags examples:
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.18
4.2.1.4 Beyond  Tag…Using HTML Events
Below are some HTML 5 tags examples:
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.19
4.2.1.4 Beyond  Tag…Using HTML Events
From a defensive point of view, the solution is to filter all
the events that start with on* in order to block this injection
point.
This is a very common regex you might find used widely:
(on\w+\s*=)
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.20
4.2.1.4 Beyond  Tag…Using HTML Events
Thanks to a mix of HTML and browsers "dynamisms", we
can easily bypass this first filter:
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.21
4.2.1.4 Beyond  Tag…Using HTML Events
So, we have an "upgrade":
(?i)([\s\"'`;\/0-9\=]+on\w+\s*=)
But there is still a problem. Some browsers convert the
control character to a space, thus the meta-character is
\s
not enough to cover all possible characters.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.22
http://en.wikipedia.org/wiki/Control_character
4.2.1.4 Beyond  Tag…Using HTML Events
Works in all browsers except Safari
Here are some bypasses:
IE only
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.23
4.2.1.4 Beyond  Tag…Using HTML Events
Thanks to Masato Kinugawa, we have a first list of control
characters allowed between the event name attribute
(e.g. onload) and the equal sign (=) character, or just
before the event name:
IExplorer = [0x09,0x0B,0x0C,0x20,0x3B]
Chrome = [0x09,0x20,0x28,0x2C,0x3B]
Safari = [0x2C,0x3B]
FireFox = [0x09,0x20,0x28,0x2C,0x3B]
Opera = [0x09,0x20,0x2C,0x3B]
Android = [0x09,0x20,0x28,0x2C,0x3B]
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.24
4.2.1.4 Beyond  Tag…Using HTML Events
Browsers, however, are in continuous evolution; therefore,
some of the characters allowed may not work anymore. So,
on Shazzer Fuzz DB, Gareth Heyes has created two fuzzer
tests:
• Characters allowed after attribute name
• Characters allowed before attribute name
You can run it in your browser or view the results of
browsers already scanned.
http://shazzer.co.uk/vector/Characters-allowed-after-attribute-name WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.25
http://shazzer.co.uk/vector/Characters-allowed-before-attribute-name
4.2.1.4 Beyond  Tag…Using HTML Events
To date, a valid regex rule should be the following:
(?i)([\s\"'`;\/0-9\=\x00\x09\0A\x0B\x0C\0x0D\x3B\x2C
\x28\x3B]+on\w+[\s\x00\x09\0A\x0B\x0C\0x0D\x3B\x2C\x28\x3
B]*?=)
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.26
4.2.2 Keyword Based Filters
Other obstacles that a signature-based filter may introduce
are focused on preventing the executing of scripting code
by blocking the use of certain keywords, for example:
alert, javascript, eval, etc...
Let’s now look at some "alternatives" you may use to
bypass these types of filters. Remember, some encoding
and obfuscation techniques were introduced in Module 1,
if you need just go back and check again.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.27
4.2.2.1 Character Escaping
JavaScript allows various character escape types that
provide us the ability to execute the code instead of being
interpreted as literal form.
For the following examples, let’s suppose we need to
bypass a filter that blocks the alert keyword. We are
ignoring, for a second, that there are other alternatives (see:
prompt, confirm, etc.).
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.28
4.2.2.1.1 Character Escaping > Unicode
Blocked!!
Here we see Unicode escaping without using native
functions: