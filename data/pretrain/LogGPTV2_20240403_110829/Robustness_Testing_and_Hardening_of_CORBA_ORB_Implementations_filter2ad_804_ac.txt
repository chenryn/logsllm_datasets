resolve-initial-references 
send-multiple-requests-deferred 
send-multiple-requests-oneway 
set-one-value 
set-values 
string-to-object 
15 
16 
17 
18 
19 
20 
21 
-is-a 
-is-equivalent 
8 
9 
10  add-item 
11 
12 
13 
14 
create-child 
create-list 
delete-values 
get-default-context 
large class of exceptional input values for object data types 
at a reasonable cost, using a simple method combining as- 
sertions and data structure signatures. 
4.4 Robustness failure protection for object 
reference data types 
We propose a probe technique that is flexible and can be 
easily  implemented  by  ORB vendors  to protect  against  a 
large class of robustness failures, especially those failures 
caused by  invalid and uninitialized object and pseudo-ob- 
ject references. A probe function is a function that can be 
used to determine the validity of a parameter value. There 
are  three  important  characteristics  for  a  probe  function: 
sensitivity,  non-intrusiveness  and  robustness.  The  probe 
function should be designed to be as sensitive as possible so 
that it can discem an invalid object or pseudo-object refer- 
ence value from a valid one. It must be non-intrusive so that 
the parameter value as well as the state of the program re- 
mains unchanged after the check. It must be robust so that 
no  extra  robustness  failures  are  introduced by  the  probe 
function itself. The probe function should also be as light- 
weight  as  possible  to  minimize  performance  overhead; 
however, there may be a trade-off between sensitivity and 
performance. 
We have found that omniORB 2.8 and omniORB 3.0 ac- 
tually provides the necessary basis for a simple probe tech- 
nique.  In  omniORE3  2.8  and  3.0,  each  object  and 
pseudo-object  data type is assigned  an undocumented  se- 
quence number named PR-magi c. This “magic” number 
147 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:01:43 UTC from IEEE Xplore.  Restrictions apply. 
Table 3.  Effectiveness of probe hardening for 8 sample 
operations in the omniORB 2.8 Linux build. 
Original failure percentage 
After C0RBA::is-nil() checking (alone) 
After C0RBA::is-nil() +PR-is-valid  checking 
After adding signal handling 
is unique for each object and pseudo-object data 
type and serves as an identity mark. When an in- 
stance of an object or pseudo-object data type has 
been correctly set up, the constructor initializes a 
member variable pd-magic to contain the cor- 
rect  PRmagic value specific to this data type, 
its “identity  mark”.  This  variable is  set  to  “in- 
valid”  by  the  destructor  when  the  reference  is 
freed. Therefore, a valid reference which is prop- 
erly initialized will contain a correct magic num- 
ber set up in the variable pd-magic during its lifetime. If 
pd-magic  does not contain the correct value, the refer- 
ence must be invalid. Therefore, we can detect invalid and 
uninitialized  references  to  objects and pseudo-objects by 
checking  whether  pd-magic  contains 
right 
PR-magic value  at  run  time.  An  undocumented  static 
member 
in 
omniORB for each object and pseudo-object data type to do 
this checking.  It is possible that a,valid PR-magic value 
could be stored in an uninitialized object by chance, but for 
most situations involving uninitialized memory values this 
is expected to be unlikely. 
function  PR-is-valid ( ) 
is  defined 
the 
Unfortunately,  the  above  functionality  provided  by 
omniORB is not robust enough to serve as a probe function 
for our purposes. For  many  invalid  object references that 
are in our test  set, the PR-is-valid ( )  check triggers a 
robustness  failure instead of retuming false by attempting 
to read the  PR-magic value from an illegal  memory  ad- 
dress. Also, NULL object references cannot be detected by 
PR-is-valid  ( )  checking. 
We have taken several steps to create a sensitive, robust 
and  non-intrusive  probe  functionality  by  refining  the 
PR-is-valid ( )  checking  method.  The  sensitivity  of 
PR-is-valid  ( )  is made largely acceptable by adding a 
call to  CORBA : : is n il ( ) , the specialized NULL ob- 
ject  reference  checking  method  defined  in  the  CORBA 
standard. We have made the checking procedure more ro- 
bust  by  adding necessary  signal-handling code. A  signal 
either 
triggered 
or 
CORBA: : is-nil ( ) 
is  accessing  the  parameter  value 
also indicates that aninvalid parameter value is detected. A 
multi-threaded checking scheme could also be used instead 
of  the  signal-handling method, but  would  probably have 
higher  performance  cost without  significant  optimization 
efforts. 
PR-is-valid ( ) 
while 
take  CORBA  object 
We  have  conducted some  initial  experiments to  study 
the effectiveness of this method. From our CORBA 2.1 op- 
eration test set, we selected a subgroup of eight operations 
that 
references  or  CORBA 
pseudo-object  references as parameters. A simple protec- 
tion-code  generator was  implemented to generate protec- 
tion code automatically that is suitable for some parameter 
types. First, a NULL-checking experiment was conducted. 
I  Dercentaae 
Thread-abort 
37.77% 
42.45% 
41.99% 
0% 
Second, the PR-is-valid ( )  checking code was gener- 
ated and added to the target module. Third, a signal handler 
was installed. The result was were tested on omniORB 2.8 
using the Linux platform. 
The results in Table 3 show that the protection scheme is 
effective. For the eight functions tested, all thread  aborts, 
formerly 37.77% of the test cases, were successfully elimi- 
nated. Note that without necessary signal-handling mecha- 
nisms,  CORBA: : is-nil ( )   and  PR-is-valid ( )  
checking actually introduced additional robustness failures 
because none of the checking methods had a zero robust- 
ness failure rate. 
The above results, however, do not mean that the prob- 
ing method is always effective to detect all possible kinds 
of exceptional input values. Sometimes, an invalid object 
reference  might  by  chance  have  a  correct  pd-magic 
value. This could happen when an object reference is cor- 
rectly set up through the constructor, but later part of the ob- 
ject  gets  corrupted  or  overwritten  while  the  pd-magic 
value remains intact. 
Performance overhead was measured by running the tar- 
get operation 5,000,000 times, with the probe fbnctionality 
tumed on or off, and calculating the difference of the aver- 
age execution times. Valid parameter values are used in this 
measurement because it is more important to know the per- 
formance cost under normal execution situations. Since the 
protection code is compact and the test program is also very 
short, all instructions are expected to be resident in cache, 
giving an optimistic performance assessment. 
The measurement results are shown in Figure 7. We can 
see that the probe function takes from 4.77 ps to 10.49 ps to 
execute, which is as high as 26 times the execution time for 
a simple operation CORBA : : is-nil ( )  (which contains 
only one if statement) and as low as 7% for a complex op- 
eration object-to-string  ( )  . This can be explained 
by the fact that the probe functions for all the object data 
types and pseudo-object data types use a uniform structure. 
Although probe functions incur overhead, the overhead 
is likely to be negligible in real CORBA programs.  This is 
because probes are static methods declared and run locally, 
and the bottleneck on CORBAplatforms is usually the mar- 
shalling, unmarshalling  and  communication  of  data  and 
methods over the network. 
148 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:01:43 UTC from IEEE Xplore.  Restrictions apply. 
Figure 7.  Performance overhead of the probe scheme. 
From this experiment we see that a simple probing tech- 
nique  can  protect  references  to  object  data  types  and 
pseudo-object data types against a class of exceptional val- 
ues. Similar methods might be standardized and generated 
as part of stub code by the CORBA  id1 compiler, so that 
users  can use  it  to  protect their  custom  data  types  selec- 
tively.  Future work will  include extending this method to 
protect against non-object data types with minimum or no 
compiler support. 
5. Related work 
Most previous work  comparing ORB implementations 
has  focused  on  measuring  and  optimizing  ORB  perfor- 
mance. [4] measures latency and throughput of Orbix and 
VisiBroker over high-speed ATM  networks and identifies 
major overhead sources. The study in [14] provides a per- 
formance  pattem  language  and  a  performance  measure- 
ment  object  that  can  be  used  to  extensively  test  ORB 
performance.  The  CORBA  comparison  project  [2]  com- 
pares omniORB, ORBacus,  and Orbix using  a rich set of 
benchmarks,  mainly  focusing on  latency, throughput  and 
scalability. Robustness of these ORBS is also briefly com- 
pared  in  terms  of  their  maximum  message  size  and  the 
number of objects they can handle. 
Fault  injection  on  Orbix  and  DCOM  applications  [ l ]  
studies distributed object behavior under real and simulated 
failure  scenarios.  Failures  at  thread-level,  process-level, 
and  machine-level  are  simulated  and  injected  into  the 
server, and the response of the client is monitored and cate- 
gorized, which marks the difference from our work. Our ap- 
proach tries to manifest robustness failures in the CORBA 
ORB native code using exceptional inputs. 
Various efforts  have  been made  to  build  fault-tolerant 
CORBA applications,  CORBA  services and  middleware, 
such as [ 12][ 13][20]. The Fault-Tolerant CORBA Standard 
[ 161 extends CORBA for applications  requiring high de- 
pendability, attempting to eliminate sources of single-point 
failures. This standard mainly aims at tolerating crash fail- 
ures using replication and does not address issues of excep- 
tional parameter input handling. 
Previous Ballista testing of the High Level Architecture 
Run-Time  Infrastructure  (HLA RTI)  [3] provides  another 
example  of  applying the  Ballista testing  methodology  to 
testing distributed applications. The RTI is a standard dis- 
tributed simulation system intended to provide completely 
robust exception handling. This effort extended the Ballista 
architecture  for  testing  exception-based  error  reporting 
models  and  object-oriented  software  structures,  which 
paves the path for the work presented here. 
The general idea of the probe technique falls into the cat- 
egory of executable assertions introduced as early as [19]. 
Executable  assertions  are  executable  statements  made 
about the variables in a program. If these statements do not 
hold true, an error has occurred. 
The probe technique is also a variant of the data-struc- 
ture signature technique  [21], which uses a modified com- 
piler  to  embed  a  signature  in  front  of  data  structures  to 
detect  data  access  faults.  Performance  overhead  can  be 
largely minimized by using a special signature monitor that 
can be added to a standard pipeline processor. 
149 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:01:43 UTC from IEEE Xplore.  Restrictions apply. 
6. Conclusions 
In this paper we have introduced a methodology to test 
and measure the exception-handling robustness of CORBA 
ORB implementations using Ballista. We have ported Bal- 
lista testing clients to work with the ORBS, and tested two 
major versions of three ORB implementations on two oper- 
ating systems for several CORBA 2.1 standard operations. 
This approach enables us to evaluate the robustness of spe- 
cific ORB implementations, to compare different ORB im- 
plementations provided by various vendors, and to enhance 
the robustness of a specific ORB implementation. 
We have presented results on the average percentage of 
failures for up to 23 functions per ORB. Testing for excep- 
tional  parameter value handling capabilities  has revealed 
normalized average robustness failure rates ranging from 
26%  to 42%.  These  results  suggest  that  users  must pay 
close  attention  to ORB  robustness  issues  when building 
critical applications on CORBA-based systems. 
To improve ORB robustness, we propose a probe tech- 
nique that checks for the presence of a special value that is 
stored in data structures upon initialization.  A prototype 
implementation of this technique using capabilities already 
built into omniORB demonstrated that this approach can be 
effective at eliminating robustness failures for some data 
types. 
Future work includes expanding robustness testing to in- 
clude  CORBA servers  as well  as  clients,  and creating a 
wider variety of techniques for robustness improvement of 
CORBA data types. 
7. Acknowledgments 
The  authors  would  like  to thank  Chia-Yen  Shih  and 
Christof Fetzer from  AT&T Labs for their  support.  This 
particular work was funded primarily by AT&T Labs - Re- 
search.  The Ballista project is supported in part by DARPA 
(contract DABT63-96-C-0064). 
8.  References 
[I] P. Emerald Chung, Woei-Jyh Lee, Joanne Shih, Shalini Yajnik 
and Yennun Huang, “Fault-Injection Experiments for Distributed 
Objects”,  Proceedings  of  the  Intemational  Symposium  on 
Distributed  Objects  and  Applications,  Edinburgh,  United 
Kingdom, September 5 - 7, 1999. 
[2] Distributed Systems Research Group, “CORBA Comparison 
Project”, http://nenya.ms.mff.cuni.cz/thegroup/COMP. Accessed 
June IO, 2000. 
[3] Kimberly Femsler and Philip Koopman, “Robustness Testing 
of A Distributed Simulation Backplane”,  Proceedings of ISSRE 
99, Boca Raton, Florida, November 1-4, 1999. 
[4]  Aniruddha  Gokhale  and  Douglas  Schmidt,  “Evaluating 
CORBA  Latency  and  Scalability  Over  High-speed  ATM 
150 
Networks”,  Proceedings  of  ICDCS  97,  Baltimore,  MD,  May 
27-30,  1997. 
[5]  IEEE  Computer  Society,  “IEEE  Standard  Glossary  of 
Software  Engineering  Terminology  (IEEE  Std  6 IO. 12- 1990)”, 
Dec. 10,  1990. 
[6]  IEEE  Computer  Society,  “IEEE  Standard  for  Information 
Technology  - Portable Operating  System Interface (POSIX) - 
Part  1:  System  Application  Program  Interface  (API)  - 
Amendment  1:  Real-time  Extension  [C  Language]  (IEEE  Std 
1003.1b-1993)”, 1994. 
[7] Inprise Corporation, “VisiBroker for C++ Reference, Version 
4.0”, 2000. 
[8]  IONA  technologies  PLC,  “Orbix  2000  Programmer’s 
Reference”,  March 2000. 
[9] Philip Koopman & John DeVale, “The Exception  Handling 
Effectiveness of POSIX Operating Systems”, IEEE Transactions 
on Software Engineering,  September 2000. 
[IO]  Philip  Koopman  and  John  DeVale,  “Comparing  the 
Robustness of POSIX Operating Systems”, Proceedings of FTCS 
29, Madison, Wisconsin, June  15-18, 1999. 
[ I   11 Sai-Lai Lo and David Riddoch, “The omniORB2 version 2.8 
User’s Guide”, AT&T Laboratories  Cambridge, July  1,  1999. 
[ 121 Silvan0 Maffeis, “A Fault-Tolerant CORBA Name Server”, 
Proceedings  ‘of  the  1996  IEEE  Symposium  on  Reliable 
Distributed  Systems.  Niagara-on-the-Lake,  Canada:  IEEE, 
October  1996. 
[ 131 L. Moser,  P. Melliar-Smith  and  P. Narasimhan, “A  Fault 
Tolerance  Framework  for CORBA”.  Proceedings of FTCS 29, 
Madison, Wisconsin, June  15-18, 1999. 
[14]  S.  Nimmagadda,  C.  Liyanaarachchi,  A.  Gopinath,  D. 
Niehaus  and  A.Kaushal,  “Performance  Pattems:  Automated 
Scenario Based  ORB Performance  Evaluation”,  Proceedings of 
COOTS 99, San Diego, Califomia, May 3-7,  1999. 
[ 151 Object Management Group, “The OMG’s site for CORBA 
and  UML  success  stories”,  http://www.corba.org/success.htm. 
Accessed June 22,2000. 
[ 161  Object  Management  Group,  “Fault  Tolerant  CORBA 
standard”,  http://www.omg.org/cgi-bin/doc?orbos/2000-0 1 - 1 9. 
October, 1999. Accessed June 19, 2000. 
[ 171 Object  Management Group,  “Space  Domain  Task Force”, 
http://www.omg.org/homepages/space/index.htm. Accessed  Dec 
5, 2000. 
[ 181 Object Management Group, “The Common Object Request 
Broker: Architecture  and Specification”, August,  1997. 
[I91 Saib S.H., “Executable Assertions  - An  Aid  To Reliable 
Software”,  1 1 th  Asilomar Conference  on Circuits  Systems and 
Computers, pp. 277-281,  1978. 
[20] J. Schonwalder, S. Garg, Y. Huang, A. P. A. van Moorsel and 
S .   Yajnik,  “A  Management  Interface  for  Distributed  Fault 
Tolerance  CORBA  Services”,  Proceedings  of  the  IEEE  3rd 
Intemational  Workshop on  System Management, Newport, RI, 
April 1998. 
[21] Kent  Wilken  & Timothy Kong,  ‘‘Concurrent Detection  of 
Software and Hardware Data-Access Faults”, IEEE Transactions 
on Computers, VOL. 46, No. 4, April  1997. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:01:43 UTC from IEEE Xplore.  Restrictions apply.