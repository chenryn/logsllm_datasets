# Windows内核提权漏洞CVE-2018-8120分析 - 上
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 背景：
因一次需要提权时，苦于查找安全可行的Exploit，加上一直对二进制漏洞心怀仰慕，所以花了点时间从底层研究一下漏洞原理及漏洞利用的编写，因为是从零开始，在摸索的过程中也踩了不少坑，记录下来，以供借鉴和回顾。
## 工具：
  1. IDA pro
  2. PChunter
  3. win7x86虚拟机
  4. Visual Studio 2019
  5. WinDBG
## 提要：
这次挑选了Windows系统CVE-2018-8120权限提升漏洞来着手研究和学习，该漏洞产生于win32k.sys组件，由于该组件中的SetImeInfoEx函数未能正确处理空指针对象，且因该空指针对象可被用户控制，导致任意内存地址写入的漏洞，通过与Bitmaps
GDI技术的结合，进一步扩展为任意内存地址读和写，最终可用于权限提升。
官方漏洞链接：[ _https://msrc.microsoft.com/update-guide/vulnerability/CVE-2018-8120_](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2018-8120)
## 一、漏洞定位分析
根据披露的信息，我们使用IDA Pro来对win32k.sys组件进行反编译以定位相关的漏洞位置。
### **（一）符号文件**
在此之前需要先了解一下“符号文件(Symbol
Files)”，符号文件通常以.pdb作为扩展名，是EXE、DLL等二进制文件的调试信息文件，通常来说涵盖了二进制文件的全局变量、局部变量、函数名及入口地址等信息，可以理解为源代码。
由于符号文件程序包不时地需要更新，微软在2018年4月起，弃用了以往的离线下载方式，转而采用Microsoft公共符号服务器来提供下载。通过设置系统变量“set
_NT_SYMBOL_PATH=srv*DownstreamStore*https://msdl.microsoft.com/download/symbols”，来自动加载符号文件。
符号文件详情：[ _https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/microsoft-public-symbols_](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/microsoft-public-symbols)
### **（二）函数定位及分析**
完成对win32k.sys的反编译后，我们在Function Window搜索SetImeInfoEx，随后按F5转化为C
Code进而得到SetImeInfoEx的伪源码。
阅读该方法的代码流程，留意红框圈出处，v3 = *(_DWORD **)(a1 + 20);
其中，a1为输入的参数，由于未对V3做空指针校验而直接调用赋值给V3，导致了非法访问。
得知SetImeInfoEx方法存在漏洞，自然就要找到在何处调用了该方法，点击IDA
View-A，文件查阅，通过XREF关键字可知，方法NtUserSetImeInfoEx调用了存在漏洞的SetImeInfoEx方法。
通过查看NtUserSetImeInfoEx函数的伪源代码，可知，传入SetImeInfoEx的第一个参数为 v4 =
_GetProcessWindowStation(0);
通过查阅MSDN微软开发文档（https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getprocesswindowstation），可知GetProcessWindowStation方法返回当前进程的窗口句柄。
既然有Get方法，自然也会有Set方法(https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setprocesswindowstation)
SetProcessWindowStation方法，可以将制定的窗口分配给调用的进程，使得进程可以访问窗口中的对象，比方说桌面、剪贴板等。
以及Create方法（https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-createwindowstationa）
经过这番分析，得知可以编写一个exe，该exe通过CreateWindowStation、SetProcesssWindowStation方法为当前进程设置窗口对象，而后调用NtSetUserImeInfoEx方法，进而触发SetImeInfoEx方法，而SetImeInfoEx方法的传参通过GetProcessWindowStation获得，受我们控制，因此，我们可以操纵SetImeInfoEx方法中v3的值。
链路为：CreateWindowSetProcessWindowStation->NtUserSetImeInfoEx->GetProcessWindowStation->SetImeInfoEx->v3->v4->qmemcpy
## 二、漏洞测试
### **（一）设置窗体**
打开Visual Studio 2019 or
其他版本，首先调用CreateWindowStation得到tagWINDOWSTATION对象,随后调用setProcessWindowStation为当前进程设置tagWINDOWSTATION对象
    #include 
    int main()
    {
    HWINSTA hSta = CreateWindowStation(0, 0, READ_CONTROL, 0);
    SetProcessWindowStation(hSta);
    }
以下是tagWINDOWSTATION对象的结构(通过WinDBG查看结构体):
    win32k!tagWINDOWSTATION
       +0x000 dwSessionId     : Uint4B
       +0x004 rpwinstaNext    : Ptr32 tagWINDOWSTATION
       +0x008 rpdeskList      : Ptr32 tagDESKTOP
       +0x00c pTerm           : Ptr32 tagTERMINAL
       +0x010 dwWSF_Flags     : Uint4B
       +0x014 spklList        : Ptr32 tagKL
       +0x018 ptiClipLock     : Ptr32 tagTHREADINFO
       +0x01c ptiDrawingClipboard : Ptr32 tagTHREADINFO
       +0x020 spwndClipOpen   : Ptr32 tagWND
       +0x024 spwndClipViewer : Ptr32 tagWND
       +0x028 spwndClipOwner  : Ptr32 tagWND
       +0x02c pClipBase       : Ptr32 tagCLIP
       +0x030 cNumClipFormats : Uint4B
       +0x034 iClipSerialNumber : Uint4B
       +0x038 iClipSequenceNumber : Uint4B
       +0x03c spwndClipboardListener : Ptr32 tagWND
       +0x040 pGlobalAtomTable : Ptr32 Void
       +0x044 luidEndSession  : _LUID
       +0x04c luidUser        : _LUID
       +0x054 psidUser        : Ptr32 Void
翻阅上图关于SetImeInfoEx函数的伪代码，其中第十行：v3 = *(_DWORD **)(a1 +
20);此处20转为16进制为0x014，也即获取tagWINDOWSTATION对象的spliIList成员的值。
由于通过CreateWindowStation初始化得到的tagWINDOWSTATION对象，其偏移量0x014的成员变量tagWINDOWSTATION->spklList默认为NULL。
因此通过setProcessWindowStation并调用NtUserSetImeInfoEx->GetProcessWindowStation->SetImeInfoEx->v3
= tagWINDOWSTATION->spklList，最终会导引至对空指针进行操作。
### **（二）系统服务**
Q：那么问题来了，设置好窗体对象后，要如何调用NtUserSetImeInfoEx方法呢？
A：由于NtUserSetImeInfoEx方法属于内核方法，用户程序不能直接访问内核空间，但我们可以通过调用系统服务来间接访问内核空间中的数据和方法。
Q：什么是系统服务？
A：系统服务，是由操作系统提供的一组内核函数，API可以间接或者直接的调用系统服务，而操作系统以动态链接库（DLL）的形式提供API，比方常见的ntdll.dll、kernel32,dll
Q：系统服务如何实现让用户模式下的程序调用内核函数？
A：当调用系统服务时，调用线程将会从用户模式切换为内核模式，等待调用结束后再回归用户模式，这个过程称之为上下文切换。通常通过软中断或快速系统调用实现上下文切换。
### **（三）系统服务描述表**
那么接下来，我们需要去调用系统服务，从而间接调用NtUserSetImeInfoEx方法。
在此之前，先来了解系统服务描述表（System Service Descriptor
Table），在Windows系统中，维护了两张“系统服务描述表”，分别是SSDT（System Service Descriptor
Table）以及SSDTShadow（System Service Descriptor Table）。
该表可以基于系统服务编号进行索引，来定位内核函数内存地址，以供系统或程序进行调用。
Q：SSDT跟SSDTshadow有什么区别？
A：前者涵盖的是有关ntoskrnel.exe、ntdll.dll的内核函数，后者则包含了ntoskrnel.exe以及win32k.sys、gdi.dll、user.dll中包含的内核函数。我们打开PCHunter，查看一下两张表即一目了然。以下分别是SSDT以及SSDTshadow
这次我们先来了解SSDTShadow(System Service Descriptor Table
Shadow)影子系统服务描述表，该表主要用于处理user32.dll、GDI32.dll中所调用的方法，主要在win32k.sys中实现，也就是本次存在漏洞的组件。
以下是SSDT的结构（SSDT跟SSDTShadow结构一致），
    typedef struct _SERVICE_DESCRIPTOR_TABLE