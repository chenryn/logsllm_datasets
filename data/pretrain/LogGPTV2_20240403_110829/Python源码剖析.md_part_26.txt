## Page 182
Python源码剖析
8.4
152
对Python整个的运行机理做一个全面的了解，我们还需要大致了解一下Python的运行时
但是，虚拟机和执行环境还仅仅是Pyhon运行机理（或者说运行模型）的一部分，为了
拟机在执行时需要不断使用的执行环境。了解这两点对掌握第二部分的内容已经足够了。
浩浩荡荡，横无际涯。
流程进入了PyEval_EvalRrameEx中的那个for循环，取出第一条字节码之后，第一张多
至关重要的概念：进程和线程。
文件要在操作系统中运行，只有栈帧是不够的。之前我们遗漏了两个对于可执行文件运行
析异常机制时详细讲述。
生，还是由Delphi产生，都会在一个进程（Process）中运行。进程并非是与机器指令序列
型有一个整体概念上的了解也是必须的。
部分将剖析的Python的异常机制会利用到Python内部的线程模型，因此对Python线程模
于Pyton在初始化时会创建一个主线程，所以其运行时环境中存在一个主线程，而且本
上的了解，虽然这部分内容我们会留到剖析Pyhon的多线程实现时再详细考察，但是由
环境。
Python运行时环境初探
enum why
[ceval.c]
第8章Python虚拟机框架
在本节中，我们首先要对Py山on的运行模型（主要是线程模型）进行一个整体概念
前面我们说了，PyFrameobject对应于可执行文件在执行时的栈帧，但是一个可执行
到这里，我们已经看到了Pyhon虚拟机的整体的执行框架，我们还看到了Python虚
现在，想必大家已经对Pyton的执行引擎的大体框架了然于胸了。在Pyhon的执行
变量why的取值范围在ceval.c中被定义，其实也就是Pyton结束字节码执行时的状
以Win32平台为例，我们知道，对于原生的Win32可执行文件，无论是由C/C++产
WHY_YIELD
WHY_RETURN=
WHY_NOT
NHK
NHY
一深度探索动态语言核心技术
BREAK
LEXCEPTION
0x0040
0x0010
0x0001
0X0004
0x0020,
0x0002
Noerror
yield
"return!
Exception occurred
operator
statement
statement
finaily
---
## Page 183
Python以PyInterpreterState 对象来实现。
都是全局共享的，仿佛这些module都是进程中的共享资源一样，对于进程这个抽象概念，
module集合，那么Python对内存的消耗就会显得非常惊人。所以在Python中，这些module
该存在几份？是全局共享的还是每个线程都有一个sysmodule？如果每个线程有自已独立
序中有两个线程，都会进行同样的一个动作——importsys，那么这个sysmodule究竞应
个线程可以共享进程的一些资源。在Pyhon中同样也是如此，考虑一下，如果Python
有类似的考量。
多线程机制时，我们会严格区分两者。对于下面将提到的PyInterpreterState对象，也
后我们有时会称pyThreadstate为线程对象，有时会称之为线程状态对象。只有在剖析
大部分章节中，为了叙述的方便，我们不过分严格地区分线程和线程状态本身，所以在以
仍然使用操作系统的原生线程。PyThreadState仅仅是对线程状态的抽象，不过在本书的
两者是有很大区别的，PyThreadState并非是对线程本身的模拟，因为Pyhon中的线程
种意义来说，这个PyThreaastate对象也可以看成是对线程本身的抽象。但实际上，这
Pymhreaastate对象来实现的，一个线程将拥有一个PyThreadstate对象。所以从另
需要保存关于当前线程的信息。在Py山on中，这个关于线程状态信息的抽象是通过
机制
作。真实机器上的任务切换机制对应到Pyton中，就是使不同的线程轮流使用虚拟机的
的抽象，可以看做是一个软CPU，Pyhon中的所有线程都使用这个软CPU来完成计算工
入，现在只需记住，Python在执行时，可能会有多个线程存在。
Python中的一个线程就是操作系统上的一个原生线程。这里我们对多线程机制不过多深
环境的保存工作，而在切换至新的线程之后，需要恢复该线程的线程环境。
线程。该多个线程能共享进程地址空间中的全局变量，这就自然而然地引出了线程同步的
有一个主线程：而对于多线程的可执行文件，在执行时会操作系统会创建一个进程和多个
这个概念来进行抽象的，而进程则是线程的活动环境。
相对应的活动对象，这个与可执行文件中机器指令序列对应的活动对象是由线程（Thread）
回
题。CPU对任务的切换实际上是在线程之间切换，在切换任务时，CPU需要执行线程
CPU切换任务时需要保存线程运行环境。对于Python来说，在切换线程之前，同样
在Win32下，通常都会有多个进程，而Pyhon实际上也可以有多个逻辑上的interpreter
刚才提到，在Win32下，线程是不能独立存活的，它需要存活在进程的环境中，而多
在前面我们看到了虚拟机的大致运行框架，实际上这个虚拟机就是Python中对CPU
这些关于程序运行的概念同样适用于Pyhon，Pyhon实现了对多线程的支持，而且
对于通常的单线程可执行文件，在执行时操作系统会创建一个进程，在进程中，又会
Python源码剖析
8.4Python运行时环境初探
一深度探索动态语言核心技术
153
---
## Page 184
154
Python源码剖析
对象和表示线程概念的PyThreadstate对象。
线程机制时再详细考察。
行引擎。看，是不是与真实机器上的程序执行模型非常相似？
个PyThreadState对象，与这些pyThreadState对象对应的线程轮流使用一个字节码执
存在。在通常的情况下，Python中只有一个interpreter，这个interpreter中维护了一个或多
虚拟机开始执行时，会将当前线程状态对象中的frame设置为当前的执行环境（frame）：
不过这里可以看看pyThreaastate和pyFrameObject之间的一些交互和联系。当Python
数调用堆栈。
象的线程中的函数调用机制对应。在Win32上，情形也是一样的，每个线程都会有一个函
是说，在每个pyhreadState对象中，会维护一个栈帧的列表，以与PyThreaState对
typedef struot
[pystate.h]
（GlobalInterpreterLock）来实现线程同步的，关于这部分内容，我们留到剖析Python多
Pyobiect
[ceval.c]
1PyThreadstate;
第8章Python虚拟机框架
关于pyInterpreterState和 pyThreadstate的创建留待以后在合适的地方描述，
好了，现在讨论刚才提到的那两个关键对象：表示进程概念的pyInterpreterObject
谈到多线程，就不能不谈到线程同步。在Pyhon中，是通过一个全局解释器锁GL
Pyobjectdiat
PyInterpreterState *interp;
struct
Pyobject
atruct
int recursion_depth;
struot
Pyobject
EyObject
//通过PyThireadState_GET获得当前活动线程对应的线程状态对象
*pyEval_EvalFrameEx(EyFrameObject *f, intthrowflag)
深度探索动态语言核心技术
builtina:
*modules;
*sysdlct;
Estate_head:
nexE;
180
*frame：//模拟线程中的函数调用堆栈
7/模拟进程环境中的线程集合
---
## Page 185
建立PyFrameObject链表：
基础对象的布局，如图8-6所示：
[frameobject.c]
di spatch_opcode:
现在我们发散思维，想象一下Pyton在运行时的某刻，内存中所有参与执行的关键
f->f_tstate
//链接当前执行环境
PyFrameobject
l/从PyThreadState中获得当前线程的当前执行环境
For
虚拟机主循环
constsi=
tstate->frame=f:
1/设置线程状态对象中的frame
Pyobject_GcResize(PyFrameObject,extras）;
创建新的执行环境
sfDaok
Eyobject
switoh
//指令分派
GE
opcode
(HAS_ARG(opcode)
CO-
co->co_consts1
(opcode)
NEXTARG(）:
NEXOP(）
locals)
>co_names;
tstate;
back=tstate->frame;
则从当前线程的状态对象中取出旧的frame，
Python源码剖析
8.4Python运行时环境初探
深度探索动态语言核心技术
155
---
## Page 186
Python源码剖析
156
第8章
好了，有了这些基础知识，我们就可以从容面对Pyhon虚拟机的一切内容了。
PyFrameObject（栈顿）
PyThreadState（线程）
Pyinterpreter(进程）
执行引擎（CPU）
Python虚拟机框架
深度探索动态语言核心技术
品
图8-6Python的运行时环境
---
## Page 187
9.1
表co_names入手。对于simple_obj.py，利用我们之前开发的PycParser工具解析simple
的对象。
拟机的剖析就从这里开始。在simple_obj.py中，我们仅仅是创建了一些Python中最简单
式的剖析。
留到下一章。本章将通过对3个简单的Python源文件的考察，完成对Pyhon中一般表达
wh1le等表达式，我们将之归类为控制流语句，对于Pyhon中控制流的详细剖析，我们将
都有些什么：
行的。在这里所谓的“一般表达式”包括最基本的对象创建语句，打印语句等。至于
虚拟机。在本章中，我们将剖析Python虚拟机是如何完成对Pyhon中的一般表达式的执
从这章开始，我们将深入到PyEval_Eva1FrameEx的各个细节当中，深入剖析Python的
[simple_obj.py]
简单内建对象的创建
我们从分析simple_obi.py对应的pycodeobject对象中的常量表co_consts和符号
还记得在剖析pyCodeobject的最后我们所展示simple_objpy吗，我们对Python虚
在上一章中，我们已经通过PyEval_EvalFrameEx看到了Pyhon虚拟机的整体框架，
mPython"
Python虚拟机中的一般表达式
Python源码剖析
深度探索动态语言核心技术
第
CHAPTER
6
---
## Page 188
Python源码剖析
158
间中，将存储程序执行过程中的局部变量。实际上，local名字空间也就是Python虚拟机
首先，我们通过图9-2观察一下运行时栈和1ocal名字空间的初始情况。在1ocal名字空
locals）。字节码指令对符号或常量的操作最终都将反映到运行时栈和1ocal名字空间中。
令将如何影响当前活动的PyFrameObject对象中的运行时栈和1ocal名字空间（f->f
作或产生了影响（下同）。在本章对Python虚拟机的剖析中，我们的重点将放在字节码指
节码指令进行了解析，这里首先来看一看对第一行Pyhon代码的执行：
作，在执行字节码指令时，会大量使用这些宏。我们来看一看在本章的剖析中需要的一些
后的剖析中我们可以清楚地看到，这些信息在虚拟机执行字节码指令的过程中具有非常重
宏的定义：
考虑，使用了大量的宏，其中的一些宏包括了对栈的各种操作以及对tuple元素的访问操
序列co_code时所必须的宏。其实，在PyEval_EvalFrameEx的实现中，出于对效率的
要的作用。
#define POP()
//出栈操作
#define
#aefine BASIC_PUSH(v)
/7入栈操作
#@efine STACKADJ (n)BASICLSTACKADU(n)
[PyEval_EvalFrameEx in Ceval.o]
tdefine
define BASIC_STACKADI(n)
/调整找顶指针
fdettne:
在剖析ryCodeobject时，我们已经利用Python的dis工具对simpleobi.pyc中的字
其中粗体部分那一列表示当前的字节码指令对源文件中的哪个符号或常量进行了操
图9-1中所展示的常量表和符号表是simple_objipy中关于程序运行的重要信息。在随
第9章Python虚拟机中的一般表达式
STORE_NAME
LOAD_CONST
BASIC_POP()
PUSH(V)
GEPITEM(V,
深度探索动态语言核心技术
4）PyTuple_GET_ITEM（(PyTupleObject（v）,(i））
图9-1simple_obj.pyc中的常量表和符号表
(1)
BASIC_POP()
BASIC_PUSH(V)
sinternStrindex=
-stack_pointer)
index
(stackpointer+=n）
length
value="s
/>
---
## Page 189
simple_obj.py中所创建的第一个对象。LOAD_coONST完成后的情况如图9-3所示：
也就是pycodeobject对象中的coconsts（在以后的叙述中，我们有时会把这个consts
上就是f->f_code->co_consts，其中是当前活动的PyFrameobject对象，那么，consts
然后将其压入虚拟机的运行时栈中。在PyEvalEvalFrameEx中可以发现，consts实际
ITEM（consts，O）。LOAD_CONST的意图很明显，就是从consts中读取序号为O的元素，
对照Pyhon源码中源代码，可在cevalc中搜索字符串“LOAD_cONsr”定位源码位置。
件名。读者如需对照Python源代码，比如对下面列出的LOAD_cONsT指令的实现代码，想
都位于cevalc的PyFrameEvalRrameEx中，如果有例外，我们会给出代码所在文件的文
所处的文件，而仅仅给出代码是哪个字节码指令的实现代码。默认情况下，所展示的代码
的。在剖析虚拟机时，我们展示字节码指令的实现代码的方式与前面不同，不再列出代码
的局部变量表。关于它的作用和重要性，在后面的剖析中我们会看得非常清楚。
称为常量表）。
PUSH(X）
X
[LOAD CONST]
下：
=GETITEM(consts,oparg）；
对照图9-1，我们可以发现，consts中的第0个元素是一个整数对象1，这也是
INCREF（X）;
对于第一条字节码指令LOAD_CONST
前面我们已经提到，Python的整个虚拟机实际上都是由PyPrame_EvalFrameEx实现
注意：在以后的阐述中，虚线指针代表f_locals，实线指针代表stack_pointer，
stack_pointer
图9-2初始状态时的运行时栈和local名字空间
图9-3LOAD_CONST之后的虚拟机状态