# 全局锁

全局锁是对整个数据库实例加锁。MySQL 提供了 `FLUSH TABLES WITH READ LOCK (FTWRL)` 命令，用于对整个库进行只读锁定。当需要将整个库设置为只读状态时，可以使用该命令。执行此命令后，其他线程的数据更新语句（如增删改）、数据定义语句（如建表、修改表结构）和更新类事务的提交语句都会被阻塞。

**全局锁的典型应用场景是全库逻辑备份**，即将整库每个表都导出为文本文件。以前的做法是通过 `FTWRL` 确保没有其他线程对数据库进行更新，然后对整个库进行备份。在备份过程中，整个库完全处于只读状态。

然而，让整个库处于只读状态存在风险：
- 如果在主库上备份，那么在备份期间不能执行任何更新操作，业务可能会受到影响。
- 如果在从库上备份，备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

尽管如此，不加锁进行备份也存在问题。例如，在备份过程中，如果一个用户购买了一门课程，业务逻辑会扣除其账户余额并记录到已购课程表中。如果备份顺序不当，可能导致备份结果中用户的账户余额未扣减但课程已添加，从而导致数据不一致。

为了避免这种情况，可以在可重复读隔离级别下开启一个事务来获取一致性视图。MySQL 的官方逻辑备份工具 `mysqldump` 支持 `--single-transaction` 参数，该参数会在导数据之前启动一个事务，确保获取一致性视图。但由于某些引擎（如 MyISAM）不支持事务，因此在这种情况下仍需使用 `FTWRL`。

此外，虽然可以通过 `SET GLOBAL readonly=true` 使全库进入只读状态，但建议使用 `FTWRL`，因为：
- `readonly` 变量可能被用于其他逻辑判断。
- 在异常处理机制上，`FTWRL` 更安全，客户端断开连接后会自动释放锁，而 `readonly` 则会一直保持只读状态，可能导致长时间不可写的风险。

# 表级锁

MySQL 中的表级锁有两种：表锁和元数据锁（MDL）。

### 表锁
表锁的语法是 `LOCK TABLES ... READ/WRITE`。与 `FTWRL` 类似，可以通过 `UNLOCK TABLES` 主动释放锁，也可以在客户端断开时自动释放。需要注意的是，`LOCK TABLES` 不仅限制了其他线程的读写操作，还限定了当前线程的操作对象。例如，执行 `LOCK TABLES t1 READ, t2 WRITE;` 后，其他线程无法写 t1 或读写 t2，且当前线程只能执行读 t1 和读写 t2 的操作。

对于 InnoDB 这种支持行锁的引擎，通常不使用 `LOCK TABLES` 来控制并发，因为锁住整个表的影响面较大。

### 元数据锁（MDL）
MDL 是在访问表时自动加上的锁，用于保证读写的正确性。在 MySQL 5.5 版本中引入了 MDL，当对表进行增删改查操作时，加 MDL 读锁；当进行表结构变更操作时，加 MDL 写锁。读锁之间不互斥，多个线程可以同时对同一张表进行增删改查；读写锁之间和写锁之间互斥，以确保表结构变更的安全性。

例如，给一个小表加字段时，如果某个长事务占用了 MDL 读锁，会导致后续的 DDL 操作被阻塞。为了安全地给小表加字段，可以先检查并处理长事务，或者在 `ALTER TABLE` 语句中设置等待时间，避免阻塞后续的业务操作。

# 小结

本文介绍了 MySQL 的全局锁和表级锁。全局锁主要用于逻辑备份过程，对于全部使用 InnoDB 引擎的库，建议使用 `--single-transaction` 参数进行备份。表锁一般在数据库引擎不支持行锁时使用，如果发现应用程序中有 `LOCK TABLES` 语句，需要考虑升级引擎或代码。MDL 锁在事务提交后才会释放，在进行表结构变更时需小心避免锁住线上查询和更新。

最后，留一个问题：在使用 `--single-transaction` 方法做逻辑备份的过程中，如果主库上的一个小表进行了 DDL 操作（如加一列），备库上会看到什么现象？请在留言区分享你的思考。

# 上期问题

上期的问题是关于联合主键索引和 InnoDB 索引组织表的理解。根据 @老杨同志 的回复，表记录按联合主键排序，索引组织顺序取决于创建索引时指定的字段顺序。具体示例详见原文。

感谢您的阅读，欢迎分享这篇文章给更多朋友。