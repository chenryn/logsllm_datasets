与Python 示例一样，PLUGIN_ENTRY
 函数用于创建并返回插件类的一个实例。同样，要安装插件，只需将.idc 文件复制到/plugins 目录中即可。
17.8 小结
虽然随着脚本化插件的出现，你可以暂时不必深入研究SDK ，但是如果脚本无法满足你扩展IDA 功能的需求，你自然会想到 IDA 插件。此外，实际上，除非你面临挑战，需要对 IDA 不认识的文件格式进行逆向工程，或者对 IDA 没有处理器模块的机器语言进行逆向工程，否则，插件可能是唯一需要你研究的编译扩展。
但是，在下面两章中，我们将继续探讨 IDA SDK 的功能，了解你可以构建用于 IDA 的其他类型的模块：加载器模块和处理器模块。
第18章 二进制文件与 IDA 加载器模块
有一天，你突然发现自己已经成为 IDA 专家了。这时，你可能会细细品味成功的味道，或者会“哀叹”一个事实：从今以后，你会经常受到人们的打搅，他们会向你询问某个文件的用途。最终，也许是因为他们的问题，也许只是因为你喜欢使用 IDA 打开你所能发现的几乎每一个文件，你将会遇到如图 18-1 所示的对话框。
图18-1 加载一个二进制文件
这是IDA 的标准“文件加载”对话框，不过存在一个小问题（从用户的角度看）。已识别的文件类型列表中仅包含一个条目，即二进制文件，这表示 IDA 安装的所有加载器模块都无法识别你想要加载的文件的格式。幸而你至少知道你所处理的机器语言（你至少知道这个文件是怎么有来的吧），并且能选择合适的处理器类型。遇到这种情况，你所能做的也只有这些了。
在本章中，我们将讨论 IDA 用来帮助你了解它无法识别的文件类型的功能。首先，我们将手动分析二进制文件格式，然后以此为基础，开发你自己的 IDA 加载器模块。
18.1 未知文件分析
有无数的文件格式可用于存储可执行代码。IDA 自带了一些加载器模块，可识别许多常见的文件格式，但是，文件格式日益增多，IDA 无法为它们都提供加载器模块。二进制映像可能包含为特定的操作系统而格式化的可执行文件、提取自嵌入式系统的 ROM映像、提取自闪存更新的固件映像或是提取自网络数据包的机器语言源代码块。这些映像的格式可能取决于操作系统（可执行文件）、目标处理器和系统体系结构（ROM映像），也可能与任何事物都无关（嵌入在应用层数据中的破解程序 shellcode ）。
假设处理器模块能够反汇编未知的二进制文件的代码，那么在告诉 IDA 这个二进制文件的哪些部分代表代码，哪些部分代表数据之前，你需要正确安排文件映像在 IDA 数据库中的位置。对多数处理器而言，使用二进制格式加载一个文件，你将只得到一个文件内容，这些内容构成一个以地址 0 开头的段，如代码清单 18-1 所示。
代码清单 18-1 以二进制模式加载的 PE文件的前几行
seg000:00000000                 db  4Dh ; M  
seg000:00000001                 db  5Ah ; Z  
seg000:00000002                 db  90h ; É  
seg000:00000003                 db    0  
seg000:00000004                 db    3  
seg000:00000005                 db    0  
seg000:00000006                 db    0  
seg000:00000007                 db    0
有时候，根据所选处理器模块的复杂程度，IDA 可能会进行少量反汇编。例如，如果所选的处理器是一个嵌入式微处理器，能够对ROM映像的布局做出假设，这时就会出现上述情况。Andy Whittaker为那些对这类应用程序感兴趣的读者创建了一个完美的视频教程1
 ，说明如何逆向工程Siemens C166 微处理器应用程序的二进制映像。
1. 参见http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx
 。
分析二进制文件时，你肯定需要尽可能多地收集与该文件有关的资源。这些资源包括CPU参考文献、操作系统参考文献、系统设计文档，以及通过调试或硬件辅助（如逻辑分析器）分析获得的内存布局信息。
在下一节中，为了举例方便，我们假设 IDA 无法识别Windows PE文件格式。PE是一种众所周知的文件格式，许多读者都熟悉它。更重要的是，有大量详细介绍 PE文件结构的文档可供我们使用，这使得分析任何 PE文件都会比较简单。
18.2 手动加载一个Windows PE文件
如果能够找到与某个文件所使用的格式有关的文档资源，那么，当你将这个文件与一个IDA数据库关联起来时，你面临的困难会大大降低。代码清单 18-1 显示了一个以二进制文件加载到IDA 中的PE文件的前几行代码。既然无法从 IDA 获得帮助，我们求助于PE规范1
 ，该规范指出：一个有效的 PE文件应以一个有效的 MS-DOS 头部结构开头，而一个有效的MS-DOS 头部结构则以2 字节签名 4Dh 5Ah（MZ ）
 开头，如代码清单 18-1 的前两行所示。
1. 参见http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx
 （需接受EULA ）。
这时，我们需要了解 MS-DOS 头部的布局。PE规范表明：文件中偏移量为 0x3C
 的位置的 4 字节值是我们需要找到的下一个头部（PE头部）的偏移量。你可以采用两种方法细分MS-DOS头部的字段：为 MS-DOS 头部中的每个字段定义适当大小的数据值，或者利用 IDA 的结构体创建功能，定义和应用一个符合 PE文件规范的 IMAGE_DOS_HEADER
 结构体。使用后一种方法可以得到下面的代码段（有所修改）：
seg000:00000000                 dw 5A4Dh                 ; e_magic  
seg000:00000000                 dw 90h                   ; e_cblp  
seg000:00000000                 dw 3                     ; e_cp  
seg000:00000000                 dw 0                     ; e_crlc  
seg000:00000000                 dw 4                     ; e_cparhdr  
seg000:00000000                 dw 0                     ; e_minalloc  
seg000:00000000                 dw 0FFFFh                ; e_maxalloc  
seg000:00000000                 dw 0                     ; e_ss  
seg000:00000000                 dw 0B8h                  ; e_sp  
seg000:00000000                 dw 0                     ; e_csum  
seg000:00000000                 dw 0                     ; e_ip  
seg000:00000000                 dw 0                     ; e_cs  
seg000:00000000                 dw 40h                   ; e_lfarlc  
seg000:00000000                 dw 0                     ; e_ovno  
seg000:00000000                 dw 4 dup(0)              ; e_res  
seg000:00000000                 dw 0                     ; e_oemid  
seg000:00000000                 dw 0                     ; e_oeminfo  
seg000:00000000                 dw 0Ah dup(0)            ; e_res2  
seg000:00000000                 dd 80h                ➊ ; e_lfanew
e_lfanew字段
 （➊）的值为 80h
 ，表示你应该可以在数据库的偏移量为 80h
 （128 字节）的位置找到一个 PE头部。分析偏移量为80h
 的位置的字节，可以确定这个PE头部的幻数 50h 45h（PE）
 ，并在数据库的偏移量为 80h
 的位置构建并应用一个 IMAGE_NT_HEADERS
 结构体（基于 PE规范）。得到的IDA 列表的一部分如下所示：
seg000:00000080        dd 4550h          ; Signature
seg000:00000080        dw 14Ch        ➋ ; FileHeader.Machine
seg000:00000080        dw 4           ➎ ; FileHeader.NumberOfSections
seg000:00000080        dd 47826AB4h      ; FileHeader.TimeDateStamp
seg000:00000080        dd 0E00h          ; FileHeader.PointerToSymbolTable
seg000:00000080        dd 0FBh           ; FileHeader.NumberOfSymbols
seg000:00000080        dw 0E0h           ; FileHeader.SizeOfOptionalHeader
seg000:00000080        dw 307h           ; FileHeader.Characteristics
seg000:00000080        dw 10Bh           ; OptionalHeader.Magic
seg000:00000080        db 2              ; OptionalHeader.MajorLinkerVersion
seg000:00000080        db 38h            ; OptionalHeader.MinorLinkerVersion
seg000:00000080        dd 600h           ; OptionalHeader.SizeOfCode
seg000:00000080        dd 400h           ; OptionalHeader.SizeOfInitializedData
seg000:00000080        dd 200h           ;  OptionalHeader.SizeOfUninitializedData
seg000:00000080        dd 1000h       ➍ ; OptionalHeader.AddressOfEntryPoint
seg000:00000080        dd 1000h          ; OptionalHeader.BaseOfCode
seg000:00000080        dd 0              ; OptionalHeader.BaseOfData
seg000:00000080        dd 400000h     ➌ ; OptionalHeader.ImageBase
seg000:00000080        dd 1000h       ➐ ; OptionalHeader.SectionAlignment
seg000:00000080        dd 200h        ➏ ; OptionalHeader.FileAlignment
前面的代码和讨论与第 8 章中介绍的 MS-DOS 和PE头部结构有许多相似之处。但是，在这里，我们加载文件时没有使用 PE加载器，而且，与第 8 章不同的是，这里的头部结构对于我们成功了解数据库的其他部分非常重要。
现在，我们已经揭示了大量有用的信息，它们将帮助我们进一步了解数据库布局。首先，PE头部中的 Machine
 （➋）字段指出了与构建该文件有关的目标 CPU 类型。在这个例子中，值 14Ch
 表示该文件供 x86 处理器类型使用。如果这里的机器类型是其他值，如 1C0h
 （ARM），那么，需要关闭数据库并重新开始分析，并确保在最初的加载对话框中选择正确的处理器类型。加载数据库后，你将无法更改该数据库所使用的处理器的类型。
ImageBase
 （➌）字段显示已加载文件映像的基本虚拟地址。使用这个信息，我们可以将一些虚拟地址信息合并到数据库中。使用 Edit ▶Segments ▶Rebase Program 菜单项，我们可以为程序的第一段指定一个新的基址，如图 18-2 所示。
图18-2 为程序指定一个新的基址
因为当一个文件以二进制模式加载时，IDA 仅创建一个段来保存整个文件，所以在当前的例子中，只有一个段存在。该对话框中的两个复选框决定在段被移动时，IDA 如何重新定位，以及IDA 是否应移动数据库中的每一个段。对于以二进制模式加载的文件，IDA 将无法获知任何重定位信息。同样，由于程序中只有一个段，默认情况下，IDA 将重新设置整个映像的基址。
AddressOfEntryPoint
 （➍）字段指定程序进入点的相对虚拟地址（RAV ）。RAV 是一个相对于程序基本虚拟地址的偏移量，而程序进入点表示程序中即将执行的第一条指令的地址。在这个例子中，进入点 RAV 1000h
 表示程序将在虚拟地址 401000h
 （400000h+1000h
 ）处开始运行。这是一条非常重要的信息，因为，对于该在数据库的什么地方开始寻找代码，这是我们获得的第一个提示。但是，在查找代码之前，需要将数据库的剩余部分与相应的虚拟地址对应起来。
PE格式利用“节”（section ）来描述文件内容与内存范围之间的对应关系。通过解析文件中每节的头部，我们可以确定数据库的基本虚拟内存布局。NumberOfSections
 （➎）字段指出一个PE文件所包含的节的数量，这里是 4。再次查阅 PE规范可知，在 IMAGE_NT_HEADERS
 结构体后面，紧跟着一个节头部结构体数组。这个数组中的每个元素都是 IMAGE_SECTION_HEADER
 结构体，我们可以在IDA 的“结构体”窗口中定义这些结构体，并将它应用于 IMAGE_NT_HEADERS
 结构体后面的字节（这里共应用了 4 次）。
在讨论如何创建段之前，我们还需要注意 FileAlignment
 （➏）和 SectionAlignment
 （➐）这两个字段。这两个字段说明如何对齐2
 文件中每节的数据，以及将数据映射到内存中时，如何对齐相同的数据。在我们的例子中，每节与文件中的一个200h
 字节偏移量对齐。但是，在加载到内存中时，这些节将与能够被 1000h
 整除的地址对齐。在将一个可执行映像存储到文件中时，使用更小的 FileAlignment
 有利于节省存储空间，而较大的 SectionAlignment
 值通常对应于操作系统的虚拟内存页面大小。在数据库中手动创建节时，了解节如何对齐可帮助我们避免错误。
2. 对齐体现了一个数据块的起始地址或偏移量。这个地址或偏移量必须是对齐值的偶数倍。例如，如果数据与 200h
 （512
 ）字节边界对齐，它必须以一个能够被200h
 偶数倍整除的地址（或偏移量）为起点。
创建每节头部后，我们有了足够的信息，可以开始创建数据库中的其他段。对紧跟在IMAGE_NT_HEADERS
 结构体后面的字节应用一个 IMAGE_SECTION_HEADER
 模板，将生成第一个节头部，并使以下数据在示例数据库中显示出来：
seg000:00400178                 db '.text',0,0,0       ➊; Name  
seg000:00400178                 dd 440h                  ; VirtualSize  
seg000:00400178                 dd 1000h               ➌; VirtualAddress  
seg000:00400178                 dd 600h                ➍; SizeOfRawData  
seg000:00400178                 dd 400h                ➋; PointerToRawData  
seg000:00400178                 dd 0                     ; PointerToRelocations  
seg000:00400178                 dd 0                     ; PointerToLinenumbers  
seg000:00400178                 dw 0                     ; NumberOfRelocations  
seg000:00400178                 dw 0                     ; NumberOfLinenumbers  
seg000:00400178                 dd 60000020h             ; Characteristics
Name
 （➊）字段表明这个头部描述的是.text
 节。所有其他字段都可用于格式化数据库，但这里我们重点讨论 3 个描述节布局的字段。PointerToRawData
 （➋）字段（400h
 ）指出可以找到节内容的位置的文件偏移量。需要注意的是，这个值是文件对齐值 200h
 的整数倍。PE文件中的节按文件偏移量（和虚拟地址）升序排列。由于这个节以文件偏移量 400h
 为起点，我们可以得出结论：文件的第一个 400h
 字节包含文件头部数据。因此，虽然严格来说，它们并不构成节，但是，我们可以把它们划分到数据库的一节中，以强调它们之间的逻辑关系。
Edit ▶Segments ▶Create Segment 命令用于在数据库中手动创建一个段。段创建对话框如 图18-3 所示。
图18-3 段创建对话框
在创建段时，你可以为段指定任何名称。这里我们选择.headers