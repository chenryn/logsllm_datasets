of signal types and their powers computed above to design an efﬁ-
cient SVM decision tree for classiﬁcation. The basic idea is to train
a small number of classiﬁers equal to the number of signal types we
wish to detect (currently ﬁve signal types in our implementation): one
classiﬁer for the case where the received signal has zero or one signal
type, another classiﬁer when the received signal has two signal types
and so on. These classiﬁers are trained with labeled datasets that
are generated by taking labeled data from experiments where there
is a single signal type in the collected data, and adding them up af-
ter normalizing their powers. For example, if we have labeled data
containing WiFi signals at power P1 and another labeled dataset con-
taining Zigbee signals at power P2, to create one labeled data point
for the classiﬁer meant for two signals, we would add the two datasets
above after normalizing their powers to be equal. By taking different
numbers and combinations of signal types and repeating the above
procedure, we create ﬁve training sets for the ﬁve SVM classiﬁers.
The above technique has two advantages. First, we only need to
train ﬁve classiﬁers, signiﬁcantly smaller than the naive approach
which needs at least 31 different SVM classiﬁers (one for each com-
bination of signal types and possibly more for different powers). Sec-
ond, collecting training data is relatively easy, since we only have to
collect data from controlled experiments where there is a single radio
operating, and we can artiﬁcially add them up later to generate data
for classiﬁers attempting to detect multiple interfering signal types.
To use these classiﬁers in practice however, we need to normalize
the amplitudes of the computed feature vectors since the classiﬁers
were trained on data where the component signals had equal power.
To accomplish this, we exploit that we can compute the powers of the
individual signals using asynchrony as we explained in the previous
section. For example, lets say we are classifying a signal which we
have estimated to have two different component signals with powers
P1 and P2, and the signal X1 starts before X2. Due to asynchrony,
we have an interference free part of X1 and consequently an inter-
ference free estimate of the corresponding feature vector F1. When
we get to the part of the signal where these two signals interfere,
we multiply the components of the new feature vector that were also
non-zero in the original feature vector by P2, and the remaining com-
ponents by P1.
In effect, we have normalized the feature vectors
corresponding to both components to have the same amplitude P1P2.
Now, the classiﬁers that were trained on normalized data can proceed
to classify the component signal types.
The above technique recursively generalizes to any number of in-
terfering signals, since we can use the above procedure whenever we
detect that a new signal has started interfering. Similarly, we can
reverse the technique when we detect that one of the signals has
stopped. Speciﬁcally, if we detect via the l0 norm technique that
the number of signal types has reduced by 1, and the total observed
power drops by P
, then we just normalize the remaining feature vec-
tor components by 1=P
4.3 Estimating Spectrum Occupancy
.
0
0
After identifying signal type, DOF computes the carrier frequency
and bandwidth of each signal type. The key idea is that the feature
vectors that were extracted for detecting type also encode information
about the carrier frequency and the bandwidth of the signal. The
reason is that almost every wireless communication signal modulates
constellation symbols (e.g. QAM) on top of standard bandwidth-
limited pulses such as raised cosine ﬁlters. The pulse rate is directly
proportional to the bandwidth for that signal (e.g. 5MHz for Zigbee).
This repeating pulse gives rise to speciﬁc pattern frequencies whose
value is a function of the bandwidth and the carrier frequency of that
signal. For OFDM signals like WiFi, instead of a pulse we have the
CP that repeats at a frequency proportional to the bandwidth of the
signal. DOF leverages these relationships in building its spectrum
occupancy estimation algorithm.
To see why feature vectors encode information about the carrier
frequency and bandwidth, consider the following BPSK signal that is
representative of transmitted wireless signals
s(t) = b cos(2(cid:25)fbt)ej2(cid:25)fct
(6)
where b = (cid:6)1 represents the bits and the cos(2(cid:25)fbt) represents the
pulse on which the bits are modulated, and fb is the bandwidth used
for transmission, and fc is the carrier frequency. Note that typically
for spectrum masking purposes more specialized pulses than simple
cosines are used, but for our explanation, this representation sufﬁces.
Lets assume the center frequency of our detector is fc0 and the gap
with the transmitted signal’s carrier frequency is (cid:14)f = jfc (cid:0) fc0j.
This gap just shifts the FFT of the signal by the same amount (cid:14)f. To
see how the SCF for the received signal looks, lets ﬁrst compute the
CAF for this with (cid:28) = 0
CAF (s(t)) = b2e
(cid:0)2(cid:25)(cid:14)f t + b2cos(4(cid:25)fbt)
(7)
As discussed before, the SCF is just the FFT of the CAF. From the
above equation it becomes clear that when we take its FFT, we will
see two spikes, one at (cid:14)f, and one at 2fb, giving us two prominent
pattern frequencies at these locations. The location of the two pat-
tern frequencies along with the knowledge of the detector’s center
frequency fc0 is sufﬁcient to compute the bandwidth and carrier fre-
quency of the transmitted signal.
The above technique generalizes to every communication radio (in-
cluding analog radios such as cordless phones), i.e. the Spectral Cor-
relation Function of a signal will exhibit a prominent value at a pat-
tern frequency corresponding to some function of fc; fb. Table 1 lists
the pattern frequencies that are observed in the SCF which are direct
functions of the carrier frequency and occupied bandwidth for differ-
ent signal types. This table serves as the basis of DOF’s algorithm for
spectrum occupancy and carrier frequency estimation.
However, the above technique has two caveats. First, for Bluetooth
signals which employ frequency hopping over 1 MHz intervals at a
rate of 1600 hops/second, the per hop period is 1=1600 = 625(cid:22)s. In
our current implementation, our spectrum occupancy algorithm runs
over a window of roughly 1ms intervals. Hence, DOF may estimate
multiple spectrum occupancies for Bluetooth signals, since a Blue-
tooth signal could hop multiple times in 1ms. Second, the above
234Table 1: Relationship between Pattern Frequencies and Bandwidth/Car-
rier Frequency
Signal Type
Pattern Frequency Locations
WiFi
Bluetooth
Analog Phone
ZigBee
all (cid:11)’s between [fc (cid:0) BW
2 ]
2 ; fc + BW
2 , fc (cid:0) BW
fc, fc + BW
fc, fc + BW , fc (cid:0) BW
2fc + BW , 2fc (cid:0) BW
2
intuition does not work for non communication signals such as mi-
crowave ovens because we are unable to exploit packet asynchrony
to determine the number of signals present in the time window. How-
ever, as prior work has shown [25], microwave signals can be mod-
eled as FM signals with a sweeping bandwidth that is equal to the AC
power switching frequency. We can leverage this model to initialize
our asynchrony detector counter based on the number of feature vec-
tors when the counter is set to zero, and also compute the occupied
spectrum for microwave signals due to these feature vectors.
Finally, note that one cannot determine bandwidth occupancy di-
rectly from signal type. While the detected signal type (e.g. WiFi)
can tell us what is the expected signal bandwidth (e.g. 20MHz for
Wiﬁ), it cannot tell us what carrier frequency is used since WiFi has
11 different channels. The above technique determines both band-
width and carrier frequency directly from the feature vectors.
4.4 Estimating Angles of Arrival
The ﬁnal component of DOF is angle of arrival (AoA) estimation
for each signal type detected. DOF designs a novel and efﬁcient al-
gorithm that extends cyclostationary analysis to also compute AoAs.
The key insight is that we can leverage already known information
about the unique pattern frequencies corresponding to a signal type
to extract their AoAs. We demonstrate the basic idea using a simple
uniform linear MIMO antenna array (ULA) [23] as our antenna ge-
ometry. Our algorithm generalizes to any antenna geometry, but ULA
sufﬁces for exposition.
Lets assume that we have M antennas and our radio receives N <
M signals that exhibit pattern features at unique (cid:11)n 8n = 1; : : : ; N
and arrive at AoAs (cid:18)i 8i = 1; : : : ; N respectively. A uniform linear
array by deﬁnition has all its antennas on a line with equal spacing
between them as shown in Fig. 4. Because the antennas are equally
spaced, a signal at a particular angle of arrival (cid:18) has a difference in
propagation distance that results in a time delay at the mth antenna
with respect to the ﬁrst antenna of
(cid:28)m((cid:18)) = (m (cid:0) 1)
d sin (cid:18)
c
(8)
where c is the rate of propagation (speed of light for free space)
through the medium and d is the inter-antenna spacing. A delay in the
time domain manifests itself as a phase shift as long as the narrow-
band assumption holds (the bandwidth of the signal does not exceed
the channel’s coherence bandwidth) and so the received signal at the
M antennas modeled as a summation of all the interfering compo-
nents is equal to
P
y(t) =
=
N
n=1 (cid:30)((cid:18)n)xn(t) + n(t)
(cid:8)x(t) + n(t)
(9)
where x = [x1 ::: xN ]T with each xn corresponding to the signal ar-
riving at angle (cid:18)n, y = [y1 ::: yN ]T is the vector consisting of signals
received at the M antennas, (cid:30)((cid:18)n) = [1 ej2(cid:25)fc(cid:28)2((cid:18)n) ::: ej2(cid:25)fc(cid:28)M ((cid:18)n)]T ,
and (cid:8) = [(cid:30)((cid:18)1) : : : (cid:30)((cid:18)n)] where fc is the carrier frequency.
The objective of any AoA estimation algorithm is to compute the
N column vectors in the AoA matrix (cid:30), since they directly provide
Figure 4: Uniform Linear Array - Sensing a plane wave impinging at an
angle (cid:18)
the corresponding AoAs for each of the N signal types. The typical
approach is to do a search over the space of possible matrices, and al-
gorithms differ in how the search is conducted. The key contribution
in our algorithm is a way to leverage the computed pattern frequen-
cies to signiﬁcantly reduce the search space and thus enable fast AoA
computation, as well as automatically associate the computed AoAs
with the corresponding signal type.
Lets assume we have detected a particular signal type and that it
has a unique pattern frequency (cid:11)u and is arriving at a single AoA
(cid:18)u. DOF’s algorithm ﬁrst computes the Spectral Correlation Matrix
y of the received signal at the M antennas 1 at the unique pattern
S(cid:11)u
frequency (cid:11)u. We omit the proof for brevity, but we can show that
this matrix is related to the AoA vector (cid:30)((cid:18)u) as follows:
x (f )(cid:8)((cid:18)u)H
~S(cid:11)u
y (f ) = (cid:8)((cid:18)u)~S(cid:11)u
(10)
where ((cid:1))H denotes the conjugate transpose operation. Since (cid:11)u is
unique to this signal type, ~S(cid:11)u
x (f ) will be a diagonal matrix, which
implies that (cid:8)((cid:18)u) is the eigenvector of the computed matrix ~S(cid:11)u
y .
Hence, in order to compute the AoA for this signal type, we just have
to compute the eigenvector of the matrix computed in Eq. 10. Be-
cause this computation is only performed at the pattern frequencies
corresponding to the received signal and not all possible pattern fre-
quencies, we are able to reduce the overall computation and associate
signal type with each angle.
In practice due to multipath effects, each signal type will arrive at
multiple AoAs. Due to this instead of a single eigenvector as above,
we will have multiple eigenvectors, each corresponding to a different
angle at which this signal arrives.
There are two important takeaways from this section:
(cid:15) By detecting signal types we obtain a list of corresponding
unique pattern frequencies. These are directly used in the AoA
algorithm described above to efﬁciently calculate AoAs.
(cid:15) By the very nature of the algorithm, i.e. our use of the unique
pattern frequencies for the detected signal types, the computed
AoAs are naturally and accurately associated with the corre-
sponding signal types.
5.
IMPLEMENTATION