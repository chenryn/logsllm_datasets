### 优化后的文本

随着会话数 \( S \) 的增加，恢复率稳步提高，除了最后几个字节外，几乎所有字节在 231 次试验中都能可靠地恢复。

其次，我们在一个使用 4 位每字节编码方案的环境中执行了恢复攻击。该编码方案使用字符 ‘0’ 到 ‘9’ 和 ‘a’ 到 ‘f’。这种受限的明文字符集在许多应用中经常使用 [4]；例如，在流行的 PHP 服务器端脚本语言中，HTTP cookie 的编码可以限制为每个字符 4 位 [20]。我们重用了上述模拟生成的 RC4 密钥流字节的概率估计 {pr,k}1≤r≤256,0x00≤k≤0xFF，并运行了修改后的算法 4，以考虑受限的明文空间。对于每个 \( S = 2^{24}, 2^{25}, \ldots, 2^{32} \) 会话，修改后的算法运行了 256 次。结果如图 8–10 所示。为了比较，这些图表还包括了未受限制的明文空间中的原始攻击的成功率。我们注意到：
- 当 \( S = 2^{26} \) 会话时，前 112 个明文字节的恢复率至少为每字节 50%。这比未受限制的明文空间（仅前 46 个字节的恢复率至少为每字节 50%）有显著改进。
- 对于 \( S = 2^{24}, \ldots, 2^{28} \) 会话，受限明文空间的恢复攻击成功率几乎在所有位置都优于未受限制明文空间的恢复攻击（即 \( S = 2^{25}, \ldots, 2^{29} \) 会话）。

### 5.2 双字节偏差攻击的模拟

我们基于算法 5 模拟了第二种明文恢复攻击。

在模拟中，我们加密了 \( S = 1 \cdot 2^{30}, \ldots, 13 \cdot 2^{30} \) 份相同的 256 字节明文，并尝试恢复固定位置的 16 个字节。具体来说，我们假设明文的第一个字节已知，接下来的 16 个字节是攻击的目标，而紧随其后的字节也是已知的。其余字节在攻击中不感兴趣。这种攻击场景类似于对手试图从 HTTP 请求中恢复 cookie 值的情况。根据明文副本的数量，我们使用了一个到五个 128 位的 RC4 密钥进行加密。正如第 4.2 节所述，我们使用 Fluhrer-McGrew [12] 描述的偏差来计算算法 5 所需的概率估计 {pr,k1,k2}1≤r≤255,0x00≤k1,k2≤0xFF。

对于每个 \( S = 1 \cdot 2^{30}, \ldots, 13 \cdot 2^{30} \) 加密的明文副本，攻击运行了 128 次以估计攻击的成功率。结果如图 11 所示：虚线表示成功恢复的明文字节数与加密明文数量的平均分数，实线表示完全恢复 16 字节明文的成功率与加密明文数量的关系。我们注意到：
- 当 \( S = 6 \cdot 2^{30} \) 加密的明文副本时，平均超过 50% 的明文被正确恢复。此外，在 128 次试验中，完整的 16 字节明文在 19% 的情况下被恢复。
- 当 \( S = 8 \cdot 2^{30} \) 加密的明文副本时，完整的明文在超过 50% 的 128 次试验中被正确恢复（具体来说，在 72% 的试验中完全恢复）。
- 当 \( S = 13 \cdot 2^{30} \) 时，所有试验中都完全恢复了明文。
- 完整明文正确恢复的速率在 \( S = 5 \cdot 2^{30} \) 加密的明文副本后迅速增加，当 \( S = 11 \cdot 2^{30} \) 时，几乎所有的试验（99%）都正确恢复了完整明文。

此外，类似于第 5.1 节，我们对使用 6 位每字节（base64）和 4 位每字节编码方案的明文进行了攻击模拟。首先，我们运行了修改后的算法 5，该算法考虑了受限的明文空间，只考虑对应于 base64 编码的字节值的候选明文字节。此外，我们使用了一个明文，其中攻击目标的 16 个字节由字节值对应于字符 'b' 的字节组成，这是一个有效的 base64 编码消息。与非受限明文空间的攻击一样，概率估计 {pr,k1,k2}1≤r≤255,0x00≤k1,k2≤0xFF 基于 [12] 中的偏差。对于每个 \( S = 1 \cdot 2^{30}, \ldots, 12 \cdot 2^{30} \) 加密的明文副本，攻击运行了 128 次，结果如图 12 所示。我们注意到：
- 当 \( S = 4 \cdot 2^{30} \) 加密的明文副本时，平均超过 50% 的明文被正确恢复。此外，在 128 次试验中，完整的 16 字节明文在 4% 的情况下被恢复。
- 当 \( S = 6 \cdot 2^{30} \) 加密的明文副本时，完整的明文在 50% 的 128 次试验中被正确恢复。
- 当 \( S = 10 \cdot 2^{30} \) 加密的明文副本时，完整的明文在几乎所有的试验（98%）中被正确恢复。

关于 4 位每字节编码方案，我们假设明文字符集包括 '0' 到 '9' 和 'a' 到 'f'。设置类似于上述 base64 编码消息的实验：我们运行了修改后的算法 5，该算法考虑了受限的明文空间，概率估计 {pr,k1,k2}1≤r≤255,0x00≤k1,k2≤0xFF 基于 [12] 中的偏差，我们使用了一个由字节值对应于字符 'b' 的字节组成的明文。对于每个 \( S = 1 \cdot 2^{30}, \ldots, 10 \cdot 2^{30} \) 加密的明文副本，攻击运行了 128 次，结果如图 13 所示。我们注意到：
- 当 \( S = 3 \cdot 2^{30} \) 加密的明文副本时，平均超过 50% 的明文被正确恢复（更精确地说，平均 72% 被正确恢复）。
- 当 \( S = 5 \cdot 2^{30} \) 加密的明文副本时，完整的明文在超过 50% 的 128 次试验中被恢复。
- 当 \( S = 8 \cdot 2^{30} \) 加密的明文副本时，完整的明文在几乎所有的试验（98%）中被恢复。

### 5.3 实际验证

我们在涉及通过 TLS 保护的网络连接的 Web 服务器和浏览器的真实攻击环境中测试了我们的明文恢复算法的成功率。以下是结果报告。

#### 5.3.1 验证 TLS 中的 RC4 操作

我们首先通过实验验证 OpenSSL 实现的 TLS 确实在第 2.2 节所述的方式下使用 RC4，特别是没有丢弃任何初始密钥流字节。我们通过在虚拟化环境中设置 OpenSSL 版本 1.0.1c 的客户端和服务器来实现这一点，使用了 OpenSSL 分发包中提供的通用工具 s_client 和 s_server。两个虚拟机运行 Ubuntu 12.10 和内核版本 3.5.0-17。

#### 5.3.2 验证单字节偏差攻击

...（继续原文内容）

希望这些修改能帮助您更好地传达您的研究结果。如果有其他部分需要进一步优化，请告诉我！