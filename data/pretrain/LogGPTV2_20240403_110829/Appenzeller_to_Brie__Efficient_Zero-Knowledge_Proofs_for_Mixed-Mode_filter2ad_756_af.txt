puted in the larger ring Z2ğ‘˜+2ğ‘  . Init, Random, Affine
Combination, Input and Open work exactly as in
Z2ğ‘˜
Î 
ComZK-a
CheckZero Let ğ» : {0, 1}âˆ— â†’ {0, 1}ğ‘  denote a random or-
acle. For (CheckZero, [ğ‘¥1], . . . , [ğ‘¥ğ‘›]), the parties proceed
as follows:
(1) If one of the ğ‘¥ğ‘– is not equal to 0, then P aborts.
(2) They run [ğ‘Ÿ1], . . . , [ğ‘Ÿğ‘›] â† Random() and compute
vole2k
.
[ğ‘¦ğ‘–] â† [ğ‘¥ğ‘–] + 2ğ‘˜ Â· [ğ‘Ÿğ‘–] for ğ‘– = 1, . . . , ğ‘›.
(3) P sends ğ‘1, . . . , ğ‘ğ‘› to V where ğ‘ğ‘– := ( Ëœğ‘¦ğ‘– âˆ’ ğ‘¦ğ‘–)/2ğ‘˜ de-
notes the upper 2ğ‘  bits of Ëœğ‘¦ğ‘–.
(4) P computes â„ â† ğ»(ğ‘€[ğ‘¦1], . . . , ğ‘€[ğ‘¦ğ‘›]) and sends â„ âˆˆ
{0, 1}2ğœ† to the verifier.
âˆˆ Z2ğ‘˜+2ğ‘ 
for ğ‘– = 1, . . . , ğ‘›, checks â„
(5) Finally, V computes ğ‘€[ğ‘¦ğ‘–]â€² â† Î” Â· 2ğ‘˜ Â· ğ‘ğ‘– +
?
ğ¾[ğ‘¦ğ‘–]
=
ğ»(ğ‘€[ğ‘¦1]â€², . . . , ğ‘€[ğ‘¦ğ‘›]â€²) and outputs (success) if the
equality holds and aborts otherwise
CheckZeroâ€™ CheckZeroâ€² denotes a variant of the above
which checks that Ëœğ‘¥ğ‘– = 0 (mod 2ğ‘˜+ğ‘ ), and is only used in
the multiplication check below. The difference is that only
the upper ğ‘  bits of the Ëœğ‘¥ğ‘– are hidden by the ğ‘ğ‘– (now from
Z2ğ‘  ) instead of the upper 2ğ‘  bits. The macro Openâ€²([ğ‘¥], lst)
is similarly an adaption revealing the lower ğ‘˜ + ğ‘  bits and
using CheckZeroâ€².
MultiplicationCheck The parties proceed on input
(CheckMult, ([ğ‘ğ‘–], [ğ‘ğ‘–], [ğ‘ğ‘–])ğ‘›
(1) P aborts if ğ‘ğ‘– Â· ğ‘ğ‘– â‰  ğ‘ğ‘– (mod 2ğ‘˜) for some ğ‘– = 1, . . . , ğ‘›.
(2) Let lst := âˆ….
(3) Generate ([ğ‘¥ğ‘–])ğ‘›
ğ‘–=1 â† Random() followed by [ğ‘§ğ‘–] â†
ğ‘–=1) as follows:
Input(ğ‘¥ğ‘– Â· ğ‘ğ‘–) for ğ‘– = 1, . . . , ğ‘›.
(4) V sends a random value ğœ‚ âˆˆğ‘… Z2ğ‘  to P.
(5) Compute ğœ€ğ‘– â† Openâ€²(ğœ‚Â·[ğ‘ğ‘–]âˆ’[ğ‘¥ğ‘–], lst) for ğ‘– = 1, . . . , ğ‘›.
(6) Run CheckZeroâ€²((ğœ‚ Â· [ğ‘ğ‘–] âˆ’ [ğ‘§ğ‘–] âˆ’ ğœ€ğ‘– Â· [ğ‘ğ‘–])ğ‘›
ğ‘–=1, lst). If
successful, V returns (success), otherwise abort.
Figure 14: Protocol Î 
Macâ€™nâ€™Cheese-style [4] multiplication check.
ComZK-b instantiating F Z2ğ‘˜
Z2ğ‘˜
ComZK using a
Lemma 5.3. If Pâˆ— and V run the CheckMult protocol of Î 
Z2ğ‘˜
comâˆ’a
with parameters ğµ, ğ¶ âˆˆ N such that ğ¶ â‰¥ ğµ and inputs ([ğ‘ğ‘–], [ğ‘ğ‘–], [ğ‘ğ‘–])ğ‘›
ğ‘–=1
and there exists an index 1 â‰¤ ğ‘– â‰¤ ğ‘› such that ğ‘ğ‘– Â· ğ‘ğ‘– (cid:46)ğ‘˜ ğ‘ğ‘– then
V outputs (success) with probability at most ğœ€cm + ğœ€cz with ğœ€cm :=
, and ğœ€cz the soundness error of CheckZero given in Lemma 5.2.
(cid:0)ğ‘›ğµ+ğ¶
(cid:1)âˆ’1
ğµ
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea202The CheckMult protocol is based on the corresponding check
from Wolverine [31], and the same analysis also applies to the Z2ğ‘˜
case. The proof of Lemma 5.3 can be found in Appendix E.3.
5.3.2 Proof of Î 
in the following theorem:
Z2ğ‘˜
ComZK-b. The formal statement of security is given
Theorem 5.4. The protocol Î 
Z2ğ‘˜
ComZK-b (Figure 14) securely realizes
the functionality F Z2ğ‘˜
ComZK: No environment can distinguish the real
execution from a simulated one except with probability (ğ‘cz + ğ‘cm) Â·
2âˆ’ğ‘ +1 + ğ‘cm Â· 2âˆ’ğ‘ , where ğ‘cz is the sum of calls to CheckZero and
Open, and ğ‘cm the number of calls to CheckMult.
The proof of Theorem 5.4 is given in Appendix E.4. Except for the
simulation of CheckMult, it is largely similar to the proof of Theo-
rem 5.1. Again, we first prove a lemma about the soundness error of
the CheckMult operation, that we use to show indistinguishability
of our simulation.
Lemma 5.5. If Pâˆ— andV run the CheckMult protocol of Î 
Z2ğ‘˜
with inputs ([ğ‘ğ‘–], [ğ‘ğ‘–], [ğ‘ğ‘–])ğ‘›
ğ‘–=1 such that there exists an index 1 â‰¤ ğ‘– â‰¤
ComZK-b
ğ‘› such that ğ‘ğ‘– Â· ğ‘ğ‘– (cid:46)ğ‘˜ ğ‘ğ‘–, then V outputs (success) with probability
at most ğœ€â€²
cm := 2âˆ’ğ‘ , and ğœ€cz the soundness error of
CheckZero given in Lemma 5.2.
cm + ğœ€cz with ğœ€â€²
The proof of Lemma 5.5 is given in Appendix E.5.
5.4 Instantiating VOLE mod 2ğ‘˜
Our ZK protocol over Z2ğ‘˜ requires an actively secure protocol for
VOLE in Z2ğ‘˜+ğ‘  . Unfortunately, this means we cannot take advantage
of the most efficient LPN-based protocols [8, 31], which currently
only have an actively secure setup protocol over fields. We consider
two possible alternatives. First, as done in [12], we can use the pro-
tocol for correlated oblivious transfer over general rings from [29],
which gives an amortized communication cost of ğ‘ (ğ‘˜ + ğ‘ ) bits per
VOLE. This is quadratic in the bit length, which will be a bottleneck
for our ZK protocols in terms of communication.
Alternatively, we can obtain sublinear communication using LPN-
based VOLE, but using generic actively secure 2-PC for the setup.
Here, we can use either the primal variant of LPN over rings, as
done in [30], or dual-LPN based on quasi-cyclic codes, as used over
Z2 in [8] (these can also be defined over Z2ğ‘˜ under an analogous
hardness assumption). Since dual-LPN has lower communication,
in the following we assume this variant. Now, for the setup pro-
cedure, if we produce a VOLE of length ğ‘ = 107 with parameters
(ğ‘, ğ‘¡) = (4, 54) from [8], the bottleneck is around 2ğ‘¡ log(ğ‘ğ‘/ğ‘¡) AES
evaluations in 2-PC, which gives a total of â‰ˆ 1 AND gate per VOLE
output. Using a TinyOT-like protocol [20] combined with LPN-
based OT [8, 34], each AND gate needs around 32 bits of communi-
cation, more than an order of magnitude less than the first approach
(note that TinyOT incurs a much larger round complexity).
For future work, an important problem is to adapt the current
techniques for actively secure VOLE over fields to the ring setting,
which would greatly reduce the preprocessing cost.
Table 1: Amortized communication cost in bits per instruc-
tion. ğ‘˜ is the size of the modulus, ğ‘  depends on the statistical
security parameter, ğµ is the bucket size of Î 
Z2ğ‘˜
ComZK-a.
Protocol
Î 
Î 
Z2ğ‘˜
ComZK-a
Z2ğ‘˜
ComZK-b
CheckZero
ğ‘  & 1 VOLE
2ğ‘  & 1 VOLE
Open
CheckMult
ğ‘˜ + ğ‘  & 1 VOLE
ğ‘˜ + 2ğ‘  & 1 VOLE
3ğµ(ğ‘˜ + ğ‘ ) & 4ğµ VOLE
2ğ‘˜ + 4ğ‘  & 3 VOLE
Step 8a and Î 
Z2ğ‘˜
ComZK-b
Z2ğ‘˜
ComZK-a
The amortized communication costs per checked commitment
6 EVALUATION
6.1 Communication Complexity
, V samples a
Z2ğ‘˜
6.1.1 Proofs over Z2ğ‘˜ . In the protocol Î 
permutation ğœ‹ in CheckMult and sends it to P. To reduce the
ComZK-a
communication costs, V can send a random seed instead, which
both parties expand with a PRG to derive the desired random values.
In this way, V needs to transfer only ğœ† bits (for a computational
security parameter ğœ†) instead log2(ğ‘› Â· ğµ + ğ‘)! bits for CheckMult.
As described in Section 5.1 and Section 5.2, we need to randomize
the upper ğ‘  or 2ğ‘  bits when doing a CheckZero or Open operation.
We note that in Î 
Step 5 the values
get already masked with uniformly random values directly before
the Open operation. Hence, the extra masking step during Open
can be omitted. A similar optimization can be applied in Î Conv.
and multiplication triple of both protocols are given in Table 1.
6.1.2 Verifying Conversions. The amortized costs for verifying the
correctness of a single conversion tuple ([ğ‘¥0]2, . . . , [ğ‘¥ğ‘šâˆ’1]2, [ğ‘¥]ğ‘€)
are given in Table 2, in terms of the amount of communication
required, and preprocessed correlated OTs or VOLEs. Note that to
simplify the table, we assume that ğ‘š â‰ˆ log ğ‘€, and so count the
cost of sending one Zğ‘€ element in the protocol as ğ‘š bits. Also,
in this analysis we ignore costs that are independent of the num-
ber of conversions being checked, such as the small number of
checks in the faulty daBit protocol. In Appendix D, we give a more
detailed breakdown of these costs, including complexities of the
sub-protocols bitADDcarry and convertBit2A.
The â€œnaÃ¯veâ€ way of verifying the a conversion would be to have
the prover provide both a set of bits ğœ’ = {[ğ‘¥0]ğ‘, . . . , [ğ‘¥ğ‘šâˆ’1]ğ‘} as
well as the value [ğ‘¥]ğ‘ and then verify that each element in ğœ’ is in
fact a bit, as well as that they sum to the value [ğ‘¥]ğ‘. This requires
sampling ğ‘š random VOLEs as well as fixing each of these to a value
chosen by the prover. Afterwards the prover proves that each is a
bit by computing CheckZero([ğ‘¥ğ‘–]ğ‘ Â· ([ğ‘¥ğ‘–]ğ‘ âˆ’ 1)), [ğ‘¥ğ‘–]ğ‘ âˆˆ ğœ’ which
requires multiplication triples over Fğ‘ as well as communication.
We list the cost of this â€œnaÃ¯veâ€ way of verifying the conversion
Table 2. To verify the multiplications we use the basic version
of Macâ€™nâ€™Cheese [4]. The â€œbasicâ€ baseline comparison in Table 2
comes from a straightforward application of using edaBits for
ZK, similarly to [16]. Namely, this protocol would first generate
consistent edaBits using [16], and then verify the conversion using
a single binary addition circuit (similar to the bucket-check in
Figure 3, step 6). However, this requires doing the check with ğ‘š
verified multiplication triples (over Z2) and a single daBit, which
in turn requires an additional verified multiplication (over Zğ‘€). To
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea203Table 2: Costs of verifying conversions between Z2 and Zğ‘€
in terms of COTs, VOLEs, and additional communication.
The â€œbasicâ€ protocol uses edaBits directly, while â€œSection 3â€
uses our optimizations. â€œQS-Circuitâ€ and â€œQS-Polyâ€ refer to
variants that use [33] for circuits and sets of polynomials re-
spectively. ğ‘š â‰ˆ log(ğ‘€), ğ‘˜ denotes the bitsize of the converted
value, and ğµ is the bucket size. For Z2ğ‘˜ , the costs for Î 
are given. The Î 
of communication (see Section 5.2).
Z2ğ‘˜
ComZK-a
Z2ğ‘˜
ComZK-b variant requires ğµğ‘  additional bits
Protocol
naive, Zğ‘
basic, Zğ‘, log(ğ‘) â‰¤ ğ‘ 
basic, Zğ‘, log(ğ‘) > ğ‘ 
Section 3, Zğ‘
Section 3, Z2ğ‘˜
QS-Circuit, Zğ‘
QS-Circuit, Z2ğ‘˜
QS-Poly, Zğ‘
QS-Poly, Z2ğ‘˜
Comm. in bits
2ğ‘š2
13ğµğ‘š + 6ğ‘š + ğµ âˆ’ 1
10ğµğ‘š + 6ğ‘š + ğµ âˆ’ 1
6ğµğ‘š + ğµ
5ğµğ‘š + ğµğ‘  âˆ’ 3ğµ
4ğµğ‘š + ğµ
3ğµğ‘š + ğµğ‘  âˆ’ ğµ
3ğµğ‘š + 2ğµ
2ğµğ‘š + ğµğ‘ 
#COTs
0
4ğµğ‘š + 3ğ‘š + ğµ âˆ’ 1
4ğµğ‘š + 3ğ‘š + ğµ âˆ’ 1
4ğµğ‘š + ğµ
4ğµğ‘š âˆ’ 3ğµ
2ğµğ‘š + ğµ
2ğµğ‘š âˆ’ ğµ
ğµğ‘š + 2ğµ
ğµğ‘š
#VOLEs
2ğ‘š
11ğµ âˆ’ 4
8ğµ âˆ’ 4
2ğµ
ğµ
2ğµ
ğµ
2ğµ
ğµ
estimate these costs, we used [31] for verifying AND gates at a cost
of 7 bits per gate, and [4] for verifying triples in a larger field.
Since COTs and VOLEs can be obtained from pseudorandom
correlation generators with very little communication [31, 34], the
remaining online communication dominates. Hence, our optimized
protocol from Section 3 saves at least 50% communication. To give
a concrete number, e.g. for the Zğ‘ variant with ğ‘š = 32, when
verifying a batch of around a million triples and 40-bit statistical
security, we can use bucket size ğµ = 3, and the communication cost