Symbolic Assembly Program）中的一个伪指令，用于为符号预留一块内存空间。该
汇编器由美国联合航空公司于20世纪50年代中期为IBM704大型机所开发。
后来BSS这个词被作为关键字引I入到了IBM709和7090/94机型上的标准汇编器FAP
（FortranAssemblyProgram），用于定义符号并且为该符号预留给定数量的未初始化
空间]。
Unix FAQ section 1.3 ( http:/www.faqs.org/faqs/unixfaq/faq/part1/section3.html )
里面有 Unix和C语言之父Dennis Rithcie对BSS这个词由来的解释。
总体来说，程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段属于
程序指令，而数据段和.bss段属于程序数据。
很多人可能会有疑问：为什么要那么麻烦，把程序的指令和数据的存放分开？混杂地放
在一个段里面不是更加简单？其实数据和指令分段的好处有很多，主要有如下几个方面，
一方面是当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域
对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区
域的权限可以被分别设置成可读写和只读。这样可以防止程序的指令被有意或无意
地改写。
程序贝的自我修养一键接、装载与牌
---
## Page 83
60
第3章目标文件里有什么
另外一方面是对于现代的CPU来说，它们有着极为强大的缓存（Cache）体系。由
于缓存在现代的计算机中地位非常重要，所以程序必须尽量提高缓存的命中率。指
令区和数据区的分离有利于提高程序的局部性。现代CPU的缓存一般都被设计成数
据缓存和指令缓存分离，所以程序的指令和数据被分开存放对CPU的缓存命中率提
高有好处。
·第三个原因，其实也是最重要的原因，就是当系统中运行着多个该程序的副本时，它
们的指令都是一样的，所以内存中只须要保存一份改程序的指令部分。对于指令这种
只读的区城来说是这样，对于其他的只读数据也一样，比如很多程序里面带有的图标、
图片、文本等资源也是属于可以共享的。当然每个副本进程的数据区域是不一样的，
它们是进程私有的。不要小看这个共享指令的概念，它在现代的操作系统里面占据了
极为重要的地位，特别是在有动态链接的系统中，可以节省大量的内存。比如我们常
用的Windows Intemet Explorer 7.0运行起来以后，它的总虚存空间为112 844KB，它
的私有部分数据为15944KB，即有96900KB的空间是共享部分（数据来激见图3-2）。
如果系统中运行了数百个进程，可以想象共享的方法来节省大量空间，关于内存共享
的更为深入的内容我们将在装载这一章探讨。
wxplore.exe:20776Properties
TCP/P
inage
PedomaneePetomanceGngh
T
Prionty
Reads
0:00:00.50
KeneTre
Read Delta
UserTme
000:00.218
Reed bytesDela
0:00:00.578
Conteot
WerteDeta
Prhete Bytes
15944K
vonte Byos Deta
Ote
Peak Prvate Bytes
15.240K
OtlerDeta
L.40
Wrtua Spe
112,844K
erBteDela
PageFauts
7,642
PogefatDea
Hendes
Hondes
GOtHardes-
23,520K
USER Handes
330
Worerg Set
wsP
255
7.672K
WSSareable
15,040K
Pekwolrg Set
wSshered
9,436K
2K
图3-2ProcessExplorer 下查看进程IExplorer.exe的进程信息
程序员的自我修养一—链接、装载与库
---
## Page 84
3.3挖掘SimpleSection.o
61
3.3挖掘SimpleSection.o
前面对于目标文件只是作了概念上的阐述，如果不翻底深入目标文件的具体细节，相信
这样的分析也只是泛泛而谈，没有真正深入理解的效果。就像知道TCP/IP协议是基于包的
结构，但是从来却没有看到过包的结构是怎样的，包的头部有哪些内容？日标地址和源地址
是怎么存放的？如果不了解这些，那么对于TCP/IP的了解是粗略的，不够细致的。很多问
题其实在表面上看似很简单，其实深入内部会发现很多鲜为人知的秘密，或者发现以前自己
认为理所当然的东西居然是错误的，或者是有偏差的。对于系统软件也是如此，不了解ELF
文件的结构细节就像学习了TCP/IP网络没有了解IP包头的结构一样，本节后面的内容就是
以ELF目标文件格式作为例子，翻底深入剖析目标文件，争取不放过任何一个字节。
真正了不起的程序员对自己的程序的每一个字节都了如指掌。
佚名
我们就以前面提到过的 SimpleSection.c编译出来的目标文件作为分析对象，这个程序是
经过精心挑选的，具有一定的代表性面又不至于过于繁项和复杂，在接下来所进行的一系列
编译、链接和相关的实验过程中，我们将会用到第1章所提到过的工具套件，比如GCC编
译器、binutils 等工具，如果你忘了这些工具怎么使用，那么在阅读过程中可以再回去参考
本书第1部分的内容。图3-1中的程序代码如清单3-1所示。
清单3-1
• sinpleSection.c
▪ Linux:
gce -c Simp1eSection.c
• Windows :
c1 SimpleSection.c /c /2a
*/
int printf( const char* format, .. );
int giobal_uninit_var;
int globa1_init_var = 84;
void funcl( int i )
printf(*d\n*, i );
)
int nain (void)
static int static_var = 85;
static int static_var2;
程序员的自我修养一链接、装载与库
---
## Page 85
62
第3章目标文件里有什么
int a = 1
int b:
funcl ( static_var +
+ static_var2<
+b11
return a:
注
如不加说明，则以下所分析的都是32位IntelxB6平台下的ELF文件格式。
我们使用GCC来编译这个文件（参数表示只编译不链接）：
$ gcc -c SimpleSection.c
我们得到了一个1104字节（该文件大小可能会因为编译器版本以及机器平台不同而变
化）的 SimpleSection.o 目标文件。我们可以使用 binutils 的工具objdump 来查看object 内部
的结构，这个工具在第1部分已经介绍过了，它可以用来查看各种目标文件的结构和内容。
运行以下命令：
$ objdunp -h SimpleSection.0
SimpleSection.01
file format elf32-i386
Sect ion8:
Idx Nane
Size
0000000000000000
VNA
LKA
File off
0000005b
00000034
ALgn
0.text
1,data
CONTENTS,
000000000000000
ALLOC, LOAD, RBLOC,
READONLY,
CODE
00000008
00000090
CONTENTS,
ALLOC, LOAD, DATA 
2.bsg
00000004
0000000000000000
00000098
2**2
ALLOC
3.rodata
00000004
CONTENTS,
000000000000000000000098
ALLOC, LOAD, READONLY, DATA
2**0
4. comment
0000002a
00000000
000000000000009c
CONTENTS,
READONLY
0.
5.note,GNU-stack
00000000
00000000
00000000000000c62**0
CONTENTS, READONLY
GCC和binutils可被移植到各种平台上，所以它们支持多种目标文件格式。比如Windows
下的 GCC 和 binutils支持PE文件格式、Linux 版本支持 ELF格式。Linux 还有一个很不错
的工其叫readelf，它是专门针对ELF文件格式的解析器，很多时候它对ELF文件的分析可
以跟objdump相互对照，所以我们下面会经常用到这个工具。
参数“-h”就是把ELF文件的各个段的基本信息打印出来。我们也可以使用“objdump
-x”把更多的信息打印出来，但是“-x”输出的这些信息又多又复杂，对于不熟悉ELF和
objdump的读者来说可能会很陌生。我们还是先把 ELF段的结构分析清楚。从上面的结果
来看，SimpleSection.o的段的数量比我们想象中的要多，除了最基本的代码段、数据段和
程序员的自我修养一链接、装载与库
---
## Page 86
3.3挖SimpleSection.o
63
BSS段以外，还有3个段分别是只读数据段（.rodata）、注释信息段（.comment）和堆栈提
示段（.note.GNU-stack），这3个额外的段的意义我们暂且不去细究。先来看看几个重要的
段的属性，其中最容易理解的是段的长度（Size）和段所在的位置（File Offset），每个段的
第2行中的“CONTENTS”、“ALLOC”等表示段的各种属性，“CONTENTS”表示该段在
文件中存在。我们可以看到BSS段没有“CONTENTS”，表示它实际上在ELF文件中不存
在内容。“note.GNU-stack”段虽然有“CONTENTS”，但它的长度为O，这是个很古怪的段，
我们暂且忽略它，认为它在ELF文件中也不存在。那么ELF文件中实际存在的也就是”text”、
“.data"、“rodata”和“.comment”这4个段了，它们的长度和在文件中的偏移位置我们已
经用粗体表示出来了，它们在ELF中的结构如图3-3所示。
0x00000450
Other data
0x000000c6
0x2a
comment
0x04.
.rodata
0x0000009c
0x08
.data
0x00000098
0x00000090
0x5b
.text
0x00000034
x0
ELF Header
0x00000000
图3-3SimpleSection.0
了解了这几个段在SimpleSection.o的基本分布，接着将逐个来看这几个段，看看它们
包含了什么内容。
有一个专门的命令叫做“size”，它可以用来查看ELF文件的代码段、数据段和BSS
段的长度（dec表示3个段长度的和的十进制，hex表示长度和的十六进制）
$ size SinpleSection.o
text
databss
dec
6bSimpleSection.o
hex
filenane
S6
4107
程序员的自我修养一链接、装载与库
---
## Page 87