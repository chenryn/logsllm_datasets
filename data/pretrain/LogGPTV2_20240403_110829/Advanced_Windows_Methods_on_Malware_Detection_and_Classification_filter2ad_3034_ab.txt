relation between them. Nevertheless, the hybrid sequence feature
extraction in both works ignore the API arguments and rely only
on the sequence of the API calls. Thus, malware authors can easily
modify such feature extraction models by interrupting the sequence.
2.2 Malware Classification
Many researchers have also used API call features to classify mal-
ware into its type. For example, in [10], Cheng et al. use information
retrieval theory and TF-IDF weighting to generate dynamic features
using system calls and their arguments. Similarly, in [42], Rieck et
al. implement a malware classification framework, MIST, to clas-
sify malware samples based on their similar behavior. The MIST
framework has two levels; the first level uses prioritized system
calls alone, where the second level uses both the prioritized systems
calls and their arguments. In [5], Boukhouta et al. propose malicious
network traffic detection and classification methods. They execute
each benign and malicious sample for about three minutes in an
isolated sandbox. Then, deep packet inspection and flow header
features are extracted from these samples. Such features include
network traffic information like the number of forwarding and
backward packets with their respective sizes. Then, the features are
fed into different machine learning algorithms (e.g., Boosted J48,
J48, Naive Bayes, and Support Vector Machine (SVM) learning) and
used to train multiple detection models to distinguish the malicious
from benign network traffic. Subsequently, a total of 45 features that
include the total number of packets and the mean and median of
packets inter-arrival time are extracted and used to train a Hidden
Markov algorithm to classify the detected malware samples into
their respective types.
In [34], Nair et al. propose an API-based malware classification
method, MEDUSA, that uses the frequency counters of calling
specific API calls to implement a metamorphic engine classification.
They first create a signature vector out of each metamorphic type
using a statistical measurement (i.e., average frequencies of selected
API calls on a given malware type). However, as stated before,
frequency-based classification tools can be easily evaded by adding
more redundant API calls and thus modifying the value of the
frequency counter.
Other researchers suggest using API call features together with
features of other resources, such as the Domain Name Server (DNS),
resource consumption pattern, and network traffic data, to detect
and classify malware samples into their types. For instance, authors
of [20, 43, 52] use feature extracted from the frequency counter of
calling the API calls, together with the features of the DNS requests
and the accessed files to train their respective malware classification
models. Such works combine features from different resources to
perform the same malware detection or classification techniques.
However, authors of [20, 52] use the API without arguments, where
authors of [43] take the API argument frequency-based features
into consideration. However, the frequency-based tool can be easily
evaded by adding more redundant API calls and modifying the
frequency counter value. Authors of [39] propose an LCS-based
method that uses features of both the API calls and the binary files
to classify malware samples into their types. The proposed LCS
method is used to measure the similarity between the malware
samples. In [6], Canali et al. propose different API-based feature
extraction models such as n-gram sequences and bags-of-words to
classify the malware into its respective type. However, the proposed
models have performed poorly due to some configuration issues; for
example, the distance concept between the API calls is not clearly
defined in the paper. In [37], Pektas et al. apply similar approaches
like those mentioned in [39] to classify a specific malware type (i.e.,
ransomware). To improve the accuracy of their multi-class malware
type classification model, they use additional behavioral features
(i.e., registry keys, files, and mutex artifacts) besides using the same
features from [39].
In contrast, we propose a malware detection and type classifi-
cation approach based on extracted dynamic features from both
the API calls and their arguments. Our proposed extraction meth-
ods can efficiently and effectively extract the dynamic features
that are used to train malware detection and type classification
approach using different machine learning algorithms. Detecting
malicious behavior based on both the API calls and arguments has
been slightly studied before [10, 29, 44]. Lanzi et al. in [29] focus
on characterizing the general interactions between the benign pro-
grams and the operating system (OS) by studying the accessed OS
resources (e.g., registry keys and files) while executing the benign
programs. Furthermore, [10, 44] highly depend on either the order
(sequence) or the frequency of API calls. However, our approach no
longer depends on the frequency or order of API calls. As a result,
it can be resilient against malware mutation and obfuscation tech-
niques (e.g., reordering and/or repeating specific API calls many
times). A comparison between our approach and the aforemen-
tioned API-based malicious detection approaches will be discussed
in Section 5.
3 METHODOLOGY
3.1 Overview
This section presents the working principles of the proposed mal-
ware detection and type classification approach. The basic opera-
tions of our approach are illustrated in Figure 1. As shown in the
figure, it has four main components:
(1) Behavior monitoring: the behavior of the malicious and be-
nign samples is monitored while executing them in an iso-
lated virtual machine using Cuckoo Sandbox3. In this paper,
Cuckoo’s host, where the samples are stored, is installed
with Ubuntu 16.04 LTS. Cuckoo’s guest, where the samples
are executed, is installed with Windows 7 64-bit and several
daily-use software. After executing each sample in Cuckoo’s
guest, the generated logs that hold the sequence of API calls
and their arguments of each sample will be saved in a behav-
ioral analysis report (e.g., report.json) and stored on Cuckoo’s
host.
(2) Feature extraction and generation: this component aims to
extract API-based features and prepare them for the next step
(e.g., machine learning). The list of API calls, together with
3https://cuckoosandbox.org/
57Advanced Windows Methods on Malware Detection and Classification
ACSAC 2020, December 7–11, 2020, Austin, USA
Figure 1: Overview of the proposed malware detection and type classification approach.
their arguments, are extracted from each sample’s behav-
ioral analysis report. Extracting the API calls and argument
values from the report is pretty straightforward. However,
analyzing the heterogeneous API arguments (e.g., different
types such as hex format, integer, string, pointers, etc.) is a
non-trivial task that requires some expert knowledge of the
API arguments. And that is the reason behind ignoring the
API arguments in most of the available machine learning
malware detection tools.
The API-based features are extracted using two methods. The
first method (Method 1) extracts each API call and its argu-
ments as one token (feature), whereas the second (Method 2)
deals with each argument element of each API call separately
as one token. The API arguments are very heterogeneous and
highly dependent on the operating system resources. There-
fore, we propose dynamic feature generation techniques to
process and generalize the arguments and to make them eas-
ier to be read and processed later by the machine learning
algorithms in the third component. Hashing Vectorizer func-
tion [53] is then used to encode the generalized API-based
dynamic features into a bit-vector (i.e., Method 1 bit-vector
and Method 2 bit-vector) where the length of each bit-vector
is equal to 220. This component will be demonstrated via
examples in Section 3.3.
(3) Malware detection using machine learning algorithms: in
this component, five different machine learning algorithms
(e.g., Support Vector Machine (SVM), Gradient Boosting
(XGBoost), Random Forest (RF), Decision Tree (DT), and
Passive-Aggressive (PA)) are trained using the API-based
dynamic features (i.e., bit-vectors from the previous step),
resulting in classifying samples as benign or malicious.
(4) Malware type classification using machine learning algo-
rithms: after detecting the malware samples in the previous
step, the bit-vectors of Method 1 and Method 2 are used to
train the same five machine learning algorithms (e.g., SVM,
XGBoost, RF, DT, and PA), resulting in classifying the mali-
cious samples into their respective types.
3.2 Feature Extraction and Generation
(Tokenization)
This component starts by extracting the API calls and their argu-
ments from the behavioral analysis report of each sample. Each
API call has two parts; the API name (function name) and the list
of its arguments. The API name is represented by a string of words,
where each word starts with a capitalized letter, such as "GetFileVer-
sionInfoSize", and could be any of the 312 API calls that are hooked
by Cuckoo [46]. In addition, some of the API names end with var-
ious suffixes such as Ex, A, W, ExA, and ExW. We remove such
suffixes to ensure that the extracted features are resilient against
the conflict of using multiple versions of the same API call. For
example, the two API calls FindFirstFileExW and FindFirstFileExA
will be merged under the same API call, FindFirstFile. Mainly these
58ACSAC 2020, December 7–11, 2020, Austin, USA
Dima Rabadi and Sin G. Teo
two API calls perform the same functionality where the difference
is in the format of their arguments. For instance, the former receives
its arguments in Unicode format (ExW), while the latter receives
its arguments in ANSI coded format (ExA).
On the other hand, API arguments are very heterogeneous, so
most researchers [14, 25, 36] neglect the API arguments and only
consider the API names. However, many essential information is
lost when API arguments are ignored. For example, operations
such as writing/reading to/from a specific file are considered naive
operations if their arguments are ignored (e.g., filenames). Never-
theless, such operations can be critical if the filename argument
is a system file. Thus, always the arguments should be considered
while studying the behavior of any program operations.
Now, the goal is to study and generalize the heterogeneous API
arguments without the need for any manual effort or explicit ex-
pertly in the domain. To do that, we propose the following automatic
processes. The Algorithms in Appendix A give the pseudocode of
each of the proposed processes.
(a) API arguments with integer type are converted into their
logarithmic bins. If the argument value represents an integer
larger than 0, a prefix numB plus the logarithmic bin of the
value is added to the feature. Furthermore, if the argument
value is a negative number, a prefix neд_ is added before
the logarithmic bin in the feature. To distinguish 0 from the
number in the range of (0−10), 0 is tagged as num0 instead of
numB0. This process is implemented in Algorithm 2. More-
over, arguments with concrete values will not be changed in
the feature. For example, allocation_type argument in NtAl-
locateVirtualMemory API call has a concrete number equals
8192 that represents a MEM_RESERVE. Such constant value
will not be changed in this process. This is implemented by
Lines 20 to 23 in Algorithm 1.
(b) If the argument defines a directory path (URL), then it is
checked whether it contains a System32 in its path to be
categorized as sys_dir; otherwise, it will be added to the
other_dir category. This process is implemented in Algo-
rithm 5.
(c) The extension of the file is checked, whether it is one of the
most popular Windows file types that are usually used by
malware authors [49]. This is implemented in Algorithm 4.
Similarly, if the argument is a registry key (e.g., reдkey such
as BootExecute, Winlogon, Run, and RunOnce keys, etc.), then
its value is checked, whether it is one of the most common
registry keys that is exploited by malware. This is imple-
mented in Algorithm 3.
After applying the previous processes, the API-based features
will be presented as a set of unique strings in the form of an API
function name and the values of its argument. Algorithm 1 in Ap-
pendix A gives the pseudocode of the whole proposed API-based
feature extraction and generation. The two methods will prepare the
features in two different formats. In the first method, each API call
and the list of its arguments are presented as one feature. Thus, we
have i features, where i is the number of API calls. Whereas in the
second method, each API call and each element of its arguments are
z=1 jz features, where
considered as one feature. Thus, we havei
jz defines the number of arguments of APIz, where z ∈ (0, i). Con-
sequently, Method 1 and Method 2 features are constructed using
the following formulas:
• Method 1: ‘API0: ARG0; ARG1...; ARGj0’, ‘API1: ARG0; ARG1...;
ARGj1’, ..., ‘APIi: ARG0; ARG1; ...; ARGji
• Method 2: ‘API0: ARG0’, ‘API0: ARG1’, ..., ‘API0: ARGj0’,
‘API1: ARG0’, ‘API1: ARG1’, ..., ‘API1: ARGj1’, ..., ‘APIi: ARG0’,
‘APIi: ARG1’, ..., ‘APIi: ARGji
’
’
After feature extraction and generation, Hashing Vectorizer func-
tion [53] is then used to encode the generalized API-based dynamic
features into fixed-length bit-vector. Each method’s dynamic fea-
tures will be encoded into its bit-vector, Method 1 bit-vector and
Method 2 bit-vector, where the length of each bit-vector equals 220.
3.3 Practical Examples
This section shows numerical examples of our proposed feature
extraction and generation methods and the Hashing Vectorizer
function.
3.3.1 Example - Feature Extraction and Generation: Listing 1 shows
a sequence of two API calls (NtQueryValueKey and NtAllocateVir-
tualMemory) and their arguments in a JSON format, which are
extracted from one of the samples’ analysis report. As shown,
reд_type and in f ormation_class arguments have values of 0 and
1, respectively. The feature generation processes presented before
convert these values to num0 and numB0 (e.g., numB+ log10 1), re-
spectively. Table 1 shows the generated features of Method 1 and
Method 2 of the two API calls and their arguments presented in
Listing 1.
" ( ∗ \ b f s e r i e s NtQueryValueKey ∗ ) " ,
Listing 1: Two API calls and their arguments snippet from
Cuckoo’s analysis report (JSON format).
\ \ r e p o r t . js on
" ap i " :
" r e t u r n _ v a l u e " :
" ( ∗ \ b f s e r i e s arguments ∗ ) " :
" value " :
"
" reg_type " :
" i n f o r m a t i o n _ c l a s s " :
" regkey " :
C o n t r o l S e t 0 0 1 / Control / en−US " } ,
"HKEY_LOCAL_MACHINE/ SYSTEM /
3221225524 ,
" ,
0 ,
1 ,
{
{
4 ,
0 ,
0 ,
3336 ,
" ( ∗ \ b f s e r i e s NtAllocateVirtualMemory ∗ ) " ,
" ap i " :
" r e t u r n _ v a l u e " :
" ( ∗ \ b f s e r i e s arguments ∗ ) " :
" p r o c e s s _ i d e n t i f i e r " :
524288 ,
" r e g i o n _ s i z e " :
" stack_dep_bypass " :
0 ,
" s t a c k _ p i v o t e d " :
0 ,
" heap_dep_bypass " :
" p r o t e c t i o n " :
" a l l o c a t i o n _ t y p e " :
3.3.2 Example - Hashing Vectorizer: After the dynamic features
of Method 1 and Method 2 are extracted, the Hashing Vectorizer
function will be applied to encode the features into a bit-vector for
each method. In this example, we show the bit-vector generation
of Method 2, where Method 1 is the same, but all arguments of
each API call are considered as one feature. Let us assume that our
dataset contains three samples (i.g., Sample 1, Sample 2, and Sample
3). Figure 2 shows the corpus, the extracted dynamic features of
8 1 9 2 } ,
59Advanced Windows Methods on Malware Detection and Classification
ACSAC 2020, December 7–11, 2020, Austin, USA
Table 1: The generated features of the two API calls and their arguments presented in Listing 1.
Method
Method 1
Method 2
‘NtQueryValueKey:0=numB0; NtQueryValueKey:1=0; NtQueryValueKey:2=other_reg; NtQueryValueKey:3=num0’, ‘NtAl-
locateVirtualMemory:0=8192; NtAllocateVirtualMemory:1=num0; NtAllocateVirtualMemory:2=numB3; NtAllocateVir-
tualMemory:3=numB0; NtAllocateVirtualMemory:4=numB5; NtAllocateVirtualMemory:5=num0; NtAllocateVirtualMem-
ory:6=num0’
Features
‘NtQueryValueKey:0=numB0’, ‘NtQueryValueKey:1=0’, ‘NtQueryValueKey:2=other_reg’, ‘NtQueryValueKey:3=num0’, ‘NtAl-
locateVirtualMemory:0=8192’, ‘NtAllocateVirtualMemory:1=num0’, ‘NtAllocateVirtualMemory:2=numB3’, "NtAllocateVir-
tualMemory:3=numB0’, ‘NtAllocateVirtualMemory:4=numB5’, ‘NtAllocateVirtualMemory:5=num0’, ‘NtAllocateVirtualMem-
ory:6=num0’
( ∗ \ b f s e r i e s
corpus ∗ ) = {
" ( ∗ \ b f s e r i e s Sample 1 ∗ ) : "
[ " LdrUnloadDll :0= IMM32 " , " LdrGetDllHandle : 0 = 0 " ,
" GetNativeSystemInfo : 0 = 1 " , " NtOpenKey :0=0 x00000001 " ,
" NtOpenKey :1= o t h e r _ r e g " , " G e t F i l e A t t r i b u t e s :0= −1"] ,
" ( ∗ \ b f s e r i e s Sample 2 ∗ ) : "
[ " LdrUnloadDll :0= IMM32 " , " LdrGetDllHandle : 0 = 0 " ,
" NtFreeVirtualMemory : 0 = 3 2 7 6 8 " ,
" NtFreeVirtualMemory : 1 = 2 8 5 6 " ] ,
" ( ∗ \ b f s e r i e s Sample 3 ∗ ) : "
[ " NtTerminateProcess : 0 = 3 0 4 " , " LdrUnloadDll :0= IMM32 " ,
" LdrGetDllHandle : 0 = 0 " , " GetNativeSystemInfo : 0 = 1 " ,
" NtOpenKey :0=0 x00000001 " , " NtOpenKey :1= o t h e r _ r e g " ,
" G e t F i l e A t t r i b u t e s : 0 = 1 " ]
}
1○−−→Fit
Feature
GetFileAttributes:0=-1
GetNativeSystemInfo:0=1
LdrGetDllHandle:0=0
LdrUnloadDll:0=IMM32
NtFreeVirtualMemory:0=32768
NtFreeVirtualMemory:1=2856
NtOpenKey:0=0x00000001
NtOpenKey:1=other_reg
NtTerminateProcess:0=304
Hash
(v)
v1