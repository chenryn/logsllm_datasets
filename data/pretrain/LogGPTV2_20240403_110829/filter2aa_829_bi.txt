CLSID mapping
SOFTWARE\Classes\CLSID\ 
{1CE29631- 7A1E-4A36- 8C04- 
AFCCD716A718}\ ProgID
ExcelWorkBook.16
Provides the CLSID-to-
ProgID mapping
SOFT-WARE\Classes\CLSID\ 
{1CE29631-7A1E-4A36-8C04- 
AFCCD716A718}\Inproc Server32
C:\path\to\our\handler.dll
Specifies the path to 
our malicious handler
Before deploying our changes to the live target, we can validate them in 
a lab environment using the PowerShell commands shown in Listing 13-2.
PS > $type = [Type]::GetTypeFromProgId(Excel.Workbook.16)
PS > $obj = [Activator]::CreateInstance($type)
PS > $obj.GetMembers()
Listing 13-2: Validating COM object registration
We get the type associated with our ProgID and then pass it to a func-
tion that creates an instance of a COM object. The last command shows 
the methods supported by our server as a final sanity check. If everything 
worked correctly, we should see the methods we implemented in our COM 
server returned to us via this newly instantiated object.
Deploying the Handler
Now we can upload the handler to the target’s filesystem. This executable 
can be written to any location the user has access to. Your inclination may 
be to hide it deep in some folder unrelated to Excel’s operation, but this 
could end up looking odd when it’s executed.
Instead, hiding it in plain sight might be our best option. Since we’re 
an admin on this system, we can write to the directory in which the real ver-
sion of Excel is installed. If we place our file alongside excel.exe and name it 
something innocuous, it may look less suspicious.
As soon as we drop our file to disk, the EDR will subject it to scanning. 
Hopefully, the protections we put in place mean it isn’t deemed malicious 
(though we might not know this until it is executed). If the file isn’t immedi-
ately quarantined, we can proceed by making the registry changes.
Making changes in the registry can be fairly safe depending on what is 
being modified. As discussed in Chapter 5, registry callback notifications 
might have to process thousands upon thousands of registry events per 
second. Thus, they must limit what they monitor. Most EDRs monitor only 
keys associated with specific services, as well as subkeys and values, like the 
RunAsPPL value, which controls whether LSASS is launched as a protected 
process. This works out well for us, because while we know that our actions 
will generate telemetry, we won’t touch any of the keys that are likely to be 
monitored.
Evading EDR (Early Access) © 2023 by Matt Hand
256   Chapter 13
That said, we should change as little as possible. Our PowerShell 
script will modify the values shown in Table 13-4 under the target user’s 
registry hive.
Table 13-4: Registry Keys Modified During Handler Registration
Registry key
Operation
SOFTWARE\Microsoft\Windows\CurrentVersion\ 
Explorer\FileExts\.xlsx\UserChoice
Delete
SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\ 
Explorer\FileExts\.xlsx\UserChoice
Create
SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\ 
Explorer\FileExts\.xlsx\UserChoice\Hash
Set value
SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\ 
Explorer\FileExts\.xlsx\UserChoice\ProgId
Set value
As soon as these registry changes are made, our handler should be 
functional on the system. Whenever the user next opens a .xlsx file, our 
handler will be invoked via the common language runtime, execute our 
shellcode, and then open the real Excel to allow the user to interact with 
the spreadsheet. When our agent checks in with our command-and-
control infrastructure, we should see it come through as TTAYLOR.ADM@
BINFORD.COM, elevating our privileges to what appears to be an adminis-
trator account on Binford’s Active Directory domain, all without opening a 
handle to LSASS!
Lateral Movement
Now that our agent is running on what we suspect to be a privileged 
account, we need to discover what kind of access we have in the domain. 
Rather than throwing SharpHound around to collect information 
(an activity that has become more difficult to do successfully), we can 
perform more surgical examination to figure out how we can move to 
another host.
You might think that lateral movement, or expanding our access to the 
environment, must involve deploying more agents on more hosts. However, 
this can add a ton of new indicators that we may not need. Take PsExec-
based lateral movement, for example, in which a service binary containing 
agent shellcode is copied to the target system and a service targeting that 
newly copied binary is created and started, initiating a new callback. This 
would involve generating a network logon event, as well as creating a new 
file, registry keys for the associated service, a new process, and a network 
connection to either our command-and-control infrastructure or our com-
promised hosts.
The question then becomes: do we absolutely need to deploy a new 
agent, or are there other ways to get what we need?
Evading EDR (Early Access) © 2023 by Matt Hand
Case Study: A Detection-Aware Attack   257
Finding a Target
One of the first places to start looking for lateral movement targets is the 
list of established network connections on the current host. This approach 
has a few benefits. First, it doesn’t require network scanning. Second, it can 
help you understand the environment’s firewall configuration, because if 
there is an established connection from the host to another system, it’s safe 
to assume that a firewall rule allowed it. Lastly, it can let us blend in. Since 
our compromised system has connected to the hosts in the list at least once, 
a new connection might seem less anomalous than one to a system with 
which the host has never communicated.
Since we accepted the risk of using Seatbelt previously, we can use it 
again. The TcpConnections module lists the existing connections between our 
host and others in the network, as shown in Listing 13-3.
====== TcpConnections ======
Local Address  
Foreign Address 
State 
PID 
Service 
ProcessName
0.0.0.0:135  
0.0.0.0:0  
LISTEN 768 
RpcSs 
svchost.exe
0.0.0.0:445  
0.0.0.0:0  
LISTEN 4 
System
0.0.0.0:3389  
0.0.0.0:0  
LISTEN 992 
TermService svchost.exe
0.0.0.0:49664  
0.0.0.0:0  
LISTEN 448 
wininit.exe
0.0.0.0:49665  
0.0.0.0:0  
LISTEN 1012 EventLog 
svchost.exe
0.0.0.0:49666  
0.0.0.0:0  
LISTEN 944 
Schedule 
svchost.exe
0.0.0.0:49669  
0.0.0.0:0  
LISTEN 1952 Spooler 
spoolsv.exe
0.0.0.0:49670  
0.0.0.0:0  
LISTEN 548  Netlogon 
lsass.exe
0.0.0.0:49696  
0.0.0.0:0  
LISTEN 548 
lsass.exe
0.0.0.0:49698  
0.0.0.0:0  
LISTEN 1672 PolicyAgent svchost.exe
0.0.0.0:49722  
0.0.0.0:0  
LISTEN 540 
services.exe
10.1.10.101:139  
0.0.0.0:0  
LISTEN 4 
System
10.1.10.101:51308 
52.225.18.44:443 ESTAB 
984 
edge.exe
10.1.10.101:59024 
34.206.39.153:80 ESTAB 
984 
edge.exe
10.1.10.101:51308 
50.62.194.59:443 ESTAB 
984 
edge.exe
10.1.10.101:54892 
10.1.10.5:49458 
ESTAB 
2544  
agent.exe
10.1.10.101:65532 
10.1.10.48:445  
ESTAB 
4 
System 1
Listing 13-3: Enumerating network connections with Seatbelt
This output can sometimes be overwhelming due to the sheer volume of 
connections some systems make. We can prune this list a bit by removing con-
nections we’re not interested in. For example, we can remove any HTTP and 
HTTPS connections, as we’d most likely need to provide a username and pass-
word to access these servers; we have access to a token belonging to TTAYLOR.
PI:EMAIL but not the user’s password. We can also remove any 
loopback connections, as this won’t help us expand our access to new systems 
in the environment. That leaves us with a substantially smaller list.
From here, we notice multiple connections to internal hosts over arbi-
trarily high ports, indicative of RPC traffic. There are likely no firewalls 
between us and the hosts, as explicit rules for these ports are very rare, but 
figuring out the nature of the protocol is tricky if we don’t have GUI access 
to the host.
Evading EDR (Early Access) © 2023 by Matt Hand
258   Chapter 13
There is also a connection to an internal host over TCP port 445 1, 
which is virtually always an indication of remote file-share browsing using 
SMB. SMB can use our token for authentication and won’t always require 
us to enter credentials. Furthermore, we can leverage the file-sharing func-
tionality to browse the remote system without deploying a new agent. That 
sounds like exactly what we’re after!
Enumerating Shares
Assuming this is a traditional SMB connection, we now need to find the 
name of the share being accessed. The easy answer, especially if we assume 
that we’re an administrator, is to mount the C$ share. This will allow us to 
browse the operating system volume as if we were in the root of the C: drive.
However, in enterprise environments, shared drives are rarely accessed 
in this way. Shared folders are much more common. Unfortunately for us, 
enumerating these shares isn’t as simple as just listing out the contents of 
\\10.1.10.48\. There are plenty of ways to get this information, though. Let’s 
explore some of them:
Using the net view command  Requires us to launch net.exe on the 
host, which an EDR’s process-creation sensors highly scrutinize
Running Get-SmbShare in PowerShell  Built-in PowerShell cmdlet that 
works both locally and remotely but requires us to invoke powershell.exe
Running Get-WmiObject Win32_Share in PowerShell  Similar to the previ-
ous cmdlet but queries for shares over WMI
Running SharpWMI.exe action= query query= " "select * from win32 
_share" "  Functionally the same as the previous PowerShell example 
but uses a .NET assembly, which allows us to operate using execute-
assembly and its equivalents
Using Seatbelt.exe network shares  Nearly identical to SharpWMI; uses the 
Win32_Share WMI class to query the shares on a remote system
These are just a few examples, and there are pros and cons to each. 
Since we’ve already put in the work to obfuscate Seatbelt and know that it 
works well in this environment, we can use it again here. Most EDRs work 
on a process-centric model, meaning that they track activity based on pro-
cesses. Like our initial access, we’ll be running in excel.exe and, if needed, 
set our spawnto process to the same image as it was previously. When we 
enumerate remote shares on 10.1.10.48, Seatbelt generates the output 
shown in Listing 13-4.
====== NetworkShares ======
Name  
: FIN
Path  
: C:\Shares\FIN
Description  
:
Type  
: Disk Drive
Name  
: ENG
Path  
: C:\Shares\ENG
Evading EDR (Early Access) © 2023 by Matt Hand
Case Study: A Detection-Aware Attack   259
Description  
:
Type  
: Disk Drive
Name  
: IT
Path  
: C:\Shares\IT
Description  
:
Type  
: Disk Drive
--snip--
[*] Completed collection in 0.121 seconds
Listing 13-4: Enumerating network shares with Seatbelt
The information tells us a few things about the target system. First, we 
have the ability to browse C$, which indicates that either we were granted 
read access to their filesystem volume, or, more likely, we have administra-
tive access to the host. Read access to C$ allows us to enumerate things such 
as installed software and users’ files. These both can provide valuable con-
text about how the system is used and who uses it.
The other network shares are more interesting than C$, though. They 
look like they belong to various business units inside Binford: FIN could 
stand for Finance, ENG for Engineering, IT for Information Technology, 
MKT for Marketing, and so on. ENG could be a good target based on our 
stated objectives.
However, there are detection risks to finding out for sure. When we 
list the contents of a remote share, a few things happen. First, a network 
connection is established with the remote server. The EDR’s network filter 
driver will monitor this, and because it is an SMB client connection, the 
Microsoft-Windows-SMBClient ETW provider comes into play as well. Our 
client will authenticate to the remote system, creating an event through the 
ETW provider Microsoft-Windows-Security-Auditing (as well as an event 
ID 5140, indicating that a network share was accessed, in the security event 
log) on the remote system. If a system access control list (SACL), a type of access 
control list used to audit access requests made for an object, is set on the 
shared folder or files within, an event will be generated via the Microsoft-
Windows-Security-Auditing ETW provider (as well as an event ID 4663) 
when the contents of the shared folder are accessed.
Remember, though, that the fact that telemetry was generated on the 
host doesn’t necessarily mean that it was captured. In my experience, EDRs 
monitor almost none of what I mentioned in the preceding paragraph. They 
might monitor the authentication event and network, but we’re using an 
already-established network connection to the SMB server, meaning brows-
ing the ENG share could allow us to blend in with the normal traffic coming 
from this system, lessening the likelihood of detection due to an anomalous 
access event.
This is not to say that we’ll blend in so much that there is no risk at all. 
Our user may not typically browse the ENG share, making any access event 
anomalous at the file level. There may be non-EDR controls, such as data-
loss prevention software or a canary facilitated through the SACL. We have 
Evading EDR (Early Access) © 2023 by Matt Hand
260   Chapter 13
to measure the reward of this share potentially holding Binford’s crown 
jewels against the risk of detection posed by our browsing.
All signs are pointing to this drive holding what we’re after, so we start 
recursively listing the subdirectories of the ENG share and find \\10.1.10.48\
ENG\Products\6100\3d\screwdriver_v42.stl, a stereolithography file commonly 
used by design applications in the mechanical engineering world. In order 
to verify that this file is the 3D model for the Binford 6100 left-handed 
screwdriver, we’ll need to exfiltrate it and open it in an application capable 
of processing .stl files.
File Exfiltration
The last step of our attack is pulling Binford’s crown jewels out of its envi-
ronment. Oddly, of everything we’ve done in this operation, this has the 
lowest likelihood of detection by the EDR despite having the highest impact 
to the environment. To be fair, it isn’t really the EDR’s domain. Still, sensors 
could detect our data exfiltration, so we should remain thoughtful in our 
approach.
There many ways to exfiltrate data from a system. Choosing a technique 
depends on a number of factors, such as the data’s location, contents, and size. 
Another factor to consider is how fault tolerant the data format is; if we don’t 
receive the full contents of the file, is it still workable? A text file is a good 
example of a very fault-tolerant file type, as missing half of the file means we’re 
simply missing half of the text in the document. On the other hand, images 
are generally not fault tolerant, because if we’re missing some portion of the 
picture, we generally won’t be able to reconstruct it in any meaningful way.
Lastly, we should consider how quickly we need the data. If we need it 
soon and all at once, we typically inherit a higher risk of detection than if 
we exfiltrate the file slowly because the volume of data transmitted across 
the network boundary, where security monitoring is likely to be imple-
mented, will be higher in a given timeframe.
In our operation, we can afford to take more risk because we’re not 
interested in staying embedded in the environment for much longer. 
Through our reconnaissance against the ENG share, we see that the .stl file 
is 4MB, which isn’t excessive compared to other types of files. Since we have 
a high risk tolerance and are working with a small file, let’s take the easy 
route and exfiltrate the data over our command-and-control channel.
Even though we’re using HTTPS, we should still protect the contents of 
the data. Assume the contents of any message that we send will be subjected 
to inspection by a security product. When it comes to exfiltrating files spe-
cifically, one of our biggest concerns is the file signature, or magic bytes, at 
the beginning of the file used to uniquely identify the file type. For .stl files, 
this signature is 73 6F 6C 69 64.