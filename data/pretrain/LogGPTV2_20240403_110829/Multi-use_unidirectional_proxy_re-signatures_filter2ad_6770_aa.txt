title:Multi-use unidirectional proxy re-signatures
author:Benoît Libert and
Damien Vergnaud
Multi-Use Unidirectional Proxy Re-Signatures
Benoˆıt Libert
Damien Vergnaud
Universit´e Catholique
de Louvain, Crypto Group
Belgium
ABSTRACT
In 1998, Blaze, Bleumer, and Strauss suggested a cryp-
tographic primitive termed proxy re-signature in which a
proxy transforms a signature computed under Alice’s secret
key into one from Bob on the same message. The proxy is
only semi-trusted in that it cannot learn any signing key or
sign arbitrary messages on behalf of Alice or Bob. At CCS
2005, Ateniese and Hohenberger revisited this primitive by
providing appropriate security deﬁnitions and eﬃcient con-
structions in the random oracle model. Nonetheless, they
left open the problem of constructing a multi-use unidirec-
tional scheme where the proxy is only able to translate in one
direction and signatures can be re-translated several times.
This paper provides the ﬁrst steps towards eﬃciently solv-
ing this problem, suggested for the ﬁrst time 10 years ago,
and presents the ﬁrst multi-hop unidirectional proxy re-
signature schemes. Although our proposals feature a linear
signature size in the number of translations, they are the
ﬁrst multi-use realizations of the primitive that satisfy the
requirements of the Ateniese-Hohenberger security model.
The ﬁrst scheme is secure in the random oracle model. Us-
ing the same underlying idea, it readily extends into a se-
cure construction in the standard model (i.e. the security
proof of which avoids resorting to the random oracle ide-
alization). Both schemes are computationally eﬃcient but
require newly deﬁned Diﬃe-Hellman-like assumptions in bi-
linear groups.
Categories and Subject Descriptors: E.3 [Data]: Data
Encryption – Public Key Cryptosystems
General Terms: Algorithms, Design, Security.
Keywords: Digital signatures, multi-use proxy re-crypto-
graphy, unidirectionality.
1.
INTRODUCTION
In 1998, Blaze, Bleumer and Strauss [10] introduced a
cryptographic primitive where a semi-trusted proxy is pro-
vided with some information that allows turning Alice’s sig-
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’08, October 27–31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
Ecole Normale Sup´erieure
C.N.R.S. – I.N.R.I.A.
France
nature on a message into Bob’s signature on the same mes-
sage. These proxy re-signatures (PRS) – not to be confused
with proxy signatures [26] – require that proxies be unable
to sign on behalf of Alice or Bob on their own. The recent
years saw a renewed interest of the research community in
proxy re-cryptography [3, 4, 5, 20, 21, 22, 14].
This paper presents the ﬁrst constructions of multi-use
unidirectional proxy re-signature wherein the proxy can only
translate signatures in one direction and messages can be re-
signed a polynomial number of times. Our constructions are
eﬃcient and demand new (but falsiﬁable) Diﬃe-Hellman-
related intractability assumptions in bilinear map groups.
One of our contributions is a secure scheme in the standard
model (i.e. without resorting to the random oracle model).
Related work. Alice – the delegator – can easily designate
a proxy translating signatures computed using the secret key
of Bob – the delegatee – into one that are valid w.r.t. her
public key by storing her secret key at the proxy. Upon
receiving Bob’s signatures, the proxy can check them and
re-sign the message using Alice’s private key. The problem
with this approach is that the proxy can sign arbitrary mes-
sages on behalf of Alice. Proxy re-signatures aim at securely
enabling the delegation of signatures without fully trusting
the proxy. They are related to proxy signatures [26, 18] in
that any PRS can be used to implement a proxy signature
mechanism but the converse is not necessarily true.
In 1998, Blaze et al.
[10] gave the ﬁrst example of PRS
where signing keys remain hidden from the proxy. The prim-
itive was formalized in 2005 by Ateniese and Hohenberger
[5] who pinned down useful properties that can be expected
from proxy re-signature schemes:
mial number of times;
exists;
secret by honest proxies;
delegation in one direction;
• Unidirectionality: re-signature keys can only be used for
• Multi-usability: a message can be re-signed a polyno-
• Privacy of proxy keys: re-signature keys can be kept
• Transparency: users may not even know that a proxy
• Unlinkability: a re-signature cannot be linked to the
• Key optimality: a user is only required to store a con-
• Non-interactivity: the delegatee does not act in the del-
• Non-transitivity: proxies cannot re-delegate their re-
signature from which it was generated;
stant amount of secret data;
egation process;
signing rights.
Blaze et al.’s construction is bidirectional (i.e. the proxy
information allows “translating” signatures in either direc-
tion) and multi-use (i.e. the translation of signatures can be
performed in sequence and multiple times by distinct proxies
without requiring the intervention of signing entities). Un-
fortunately, Ateniese and Hohenberger [5] pinpointed a ﬂaw
in the latter scheme: given a signature/re-signature pair,
anyone can deduce the re-signature key that has been used
in the delegation (i.e. proxy keys are not private). Another
issue in [10] is that the proxy and the delegatee can collude
to expose the delegator’s secret.
To overcome these limitations, Ateniese and Hohenberger
[5] proposed two constructions based on bilinear maps. The
ﬁrst one is a multi-use, bidirectional extension of Boneh-
Lynn-Shacham (BLS) signatures [13]. Their second scheme
is unidirectional (the design of such a scheme was an open
problem raised in [10]) but single-use. It involves two diﬀer-
ent signature algorithms: ﬁrst-level signatures can be trans-
lated by the proxy whilst second-level signatures (that are
obtained by translating ﬁrst level ones or by signing at level
2) cannot. A slightly less eﬃcient variant was also suggested
to ensure the privacy of re-signature keys kept at the proxy.
The security of all schemes was analyzed in the random or-
acle model [9].
Motivations. A number of applications were suggested in
[5] to motivate the search for unidirectional systems. One of
them was to provide a proof that a certain path was taken in
a directed graph: to make sure that a foreign visitor legally
entered the country and went through the required check-
points, U.S. customs only need one public key (the one of
the immigration service once the original signature on the
e-passport has been translated by an immigration agent).
Optionally, the ﬁnal signature can hide which speciﬁc path
was chosen and only vouch for the fact that an authorized
one was taken.
In such a setting, proxy re-signatures are
especially interesting when they are multi-use.
Another application was the sharing and the conversion
of digital certiﬁcates: valid signatures for untrusted public
keys can be turned into signatures that verify under already
certiﬁed keys so as to save the cost of obtaining a new cer-
tiﬁcate. As exempliﬁed in [5], unidirectional schemes are
quite appealing for converting certiﬁcates between ad-hoc
networks: using the public key of network B’s certiﬁcation
authority (CA), the CA of network A can non-interactively
compute a translation key and set up a proxy converting
certiﬁcates from network B within its own domain without
having to rely on untrusted nodes of B.
As a third application, PRS can be used to implement
anonymizable signatures that hide the internal organization
of a company. Outgoing documents are ﬁrst signed by spe-
ciﬁc employees. Before releasing them to the outside world,
a proxy translates signatures into ones that verify under a
corporate public key so as to conceal the original issuer’s
identity and the internal structure of the company.
Our contributions. Ateniese and Hohenberger left as
open challenges the design of multi-use unidirectional sys-
tems and that of secure schemes in the standard security
model. This paper provides solutions to both problems:
• we present a simple and eﬃcient system (built on the
short signature put forth by Boneh et al. [13]) which
is secure in the random oracle model under an appro-
priate extension of the Diﬃe-Hellman assumption;
• using an elegant technique due to Waters [31], the
scheme is easily modiﬁed so as to achieve security in
the standard model. To the best of our knowledge,
this actually provides the ﬁrst unidirectional PRS that
dispenses with random oracles and thereby improves a
recent bidirectional construction [29].
Both proposals additionally preserve the privacy of proxy
keys (with an improved eﬃciency w.r.t.
[5] in the case
of the ﬁrst one). They combine almost all of the above
properties. As in prior unidirectional schemes, proxies are
not completely transparent since signatures have diﬀerent
shapes and lengths across successive levels. The size of our
signatures actually grows linearly with the number of past
translations: signatures at level (cid:2) (i.e. that have been trans-
lated (cid:2) − i times if the original version was signed at level i)
consist of about 2(cid:2) group elements. In spite of this blow-up,
we retain important beneﬁts:
• signers may tolerate a limited number (say t) of sig-
nature translations for speciﬁc messages. Then, if L
distinct signature levels are permitted in the global
system, users can directly sign messages at level L− t.
• the conversion of a (cid:2)th level signature is indistinguish-
able from one generated at level (cid:2) + 1 by the sec-
ond signer. The original signer’s identity is moreover
perfectly hidden and the veriﬁer only needs the new
signer’s public key.
As a last contribution, we also show how the single-hop re-
strictions of both schemes can be modiﬁed in such a way
that one can prove their security in the stronger plain pub-
lic key model (also considered in [6] for diﬀerent primitives).
Prior works on proxy re-cryptography consider security def-
initions where dishonest parties’ public keys are honestly
generated and the corresponding secret key is known to the
attacker. Relying on the latter assumption requires CAs to
ask for a proof of knowledge of the associated private key
before certifying a public key. As exempliﬁed in [6], not all
security infrastructures do rigorously apply such an advis-
able practice. To address this issue in our setting, we extend
the security deﬁnitions of [5] to the plain public key model
(a.k.a. chosen-key model) where the adversary is allowed to
choose public keys on behalf of corrupt users (possibly non-
uniformly or as a function of honest parties’ public keys)
without being required to reveal or prove knowledge of the
underlying private key. In our model, we are able to con-
struct single-hop unidirectional schemes that are secure in
the plain public key model. The practical impact of this
result is that users do not have to demonstrate knowledge
of their secret upon certiﬁcation. They must only obtain a
standard certiﬁcate such as those provided by current PKIs.
Organization. In the forthcoming sections, we recall the
syntax of unidirectional PRS schemes and the security model
in section 2. Section 3 explains which algorithmic assump-
tions we need. Section 4 describes our random-oracle-using
scheme. In section 5, we detail how to get rid of the ran-
dom oracle idealization. Section 6 then suggests single-hop
constructions in the chosen-key model.
2. MODEL AND SECURITY NOTIONS
We ﬁrst recall the syntactic deﬁnition of unidirectional
PRS schemes from [5].
Definition 1
(Proxy Re-Signatures). A (unidirec-
tional) proxy re-signature (PRS) scheme for N signers and
L levels (where N and L are both polynomial in the security
parameter λ) is a tuple of (possibly randomized) algorithms
(Global-Setup, Keygen, ReKeygen, Sign, Re-Sign, Verify) where:
Global-Setup(λ): is a randomized algorithm (possibly run by
a trusted party) that takes as input a security parame-
ter λ and produces system-wide public parameters cp.
Keygen(cp): is a probabilistic algorithm that, on input of
public parameters cp, outputs a signer’s private/public
key pair (sk, pk).
ReKeygen(cp, pki, skj): on input of public parameters cp, the
public key pki of signer i and signer j’s private key skj,
this (possibly randomized but ideally non-interactive)
algorithm outputs a re-signature key Rij that allows
turning i’s signatures into signatures in the name of j.
Sign(cp, (cid:2), ski, m): on input of public parameters cp, a mes-
sage m, a private key ski and an integer (cid:2) ∈ {1, . . . , L},
this (possibly probabilistic) algorithm outputs a signa-
ture σ on behalf of signer i at level (cid:2).
Re-Sign(cp, (cid:2), m, σ, Rij, pki, pkj): given common parameters
cp, a level (cid:2) < L signature σ from signer i ∈ {1, . . . , N}
and a re-signature key Rij, this (possibly randomized)
algorithm ﬁrst checks that σ is valid w.r.t pki. If yes, it
that veriﬁes at level (cid:2) + 1 under
outputs a signature σ
the public key pkj.
Verify(cp, (cid:2), m, σ, pki): given public parameters cp, an inte-
ger (cid:2) ∈ {1, . . . , L}, a message m, an alleged signature
σ and a public key pki, this deterministic algorithm
outputs 0 or 1.
For all security parameters λ ∈ N and public parameters cp
output by Global-Setup(λ), for all couples of private/public
key pairs (ski, pki), (skj , pkj) produced by Keygen(cp), for
any (cid:2) ∈ {1, . . . , L} and message m, we should have
Verify(cp, (cid:2), m, Sign(cp, (cid:2), ski, m), pki) = 1;
(cid:2)
Verify(cp, (cid:2) + 1, m, σ, pkj) = 1.
whenever σ = ReSign(cp, (cid:2), m, Sign(cp, (cid:2), ski, m), Rij ) and
Rij = ReKeygen(cp, pki, skj ).
To lighten notations, we sometimes omit to explicitly include
public parameters cp that are part of the input of some of
the above algorithms.
The security model of [5] considers the following two or-
thogonal notions termed external and insider security.
External security: is the security against adversaries out-
side the system (that diﬀer from the proxy and dele-
gation partners). This notion demands that the next
probability be a negligible function of the security pa-
rameter λ:
Pr[ {(pki, ski) ← Keygen(λ)}i∈[1,N],
(i(cid:2), L, m(cid:2), σ(cid:2))
← AOSign (.),OResign(.)
({pki}i∈[1,N]) :
Verify(L, m(cid:2), σ(cid:2), pki(cid:2)) ∧ (i(cid:2), m(cid:2)) (cid:5)∈ Q]
where OSign(.) is an oracle taking as input a message
and an index i ∈ {1, . . . , N} to return a 1st-level sig-
nature σ ← Sign(1, ski, m); OResign(.) takes indices
i, j ∈ {1, . . . , N} and a (cid:2)th-level signature σ to out-
(cid:2) ← Re-Sign((cid:2), m, σ, ReKeygen(pki, skj ), pki, pkj);
put σ
and Q denotes the set of (signer,message) pairs (i, m)
queried to OSign(.) or such that a tuple (?, j, i, m),
with j ∈ {1, . . . , N}, was queried to OResign(.). This
notion only makes sense if re-signing keys are kept pri-
vate by the proxy.
In our setting, the translation of a (cid:2)th-level signature is per-
fectly indistinguishable from a signature produced by the
delegator at level (cid:2) + 1. Therefore, we can always simu-
late the OResign(.) oracle by publicly “sending” outputs of
OSign(.) to the next levels. For the sake of generality, we
nevertheless leave OResign(.) in the deﬁnition.
Internal security: The second security notion considered
in [5] strives to protect users against dishonest prox-
ies and colluding delegation partners. Three security
guarantees should be ensured.
1. Limited Proxy security: this notion captures
the proxy’s inability to sign messages on behalf
of the delegatee or to create signatures for the
delegator unless messages were ﬁrst signed by one
of the latter’s delegatees. Formally, we consider
a game where adversaries have all re-signing keys
but are denied access to signers’ private keys. The
following probability should be negligible:
Pr
(cid:2) {(pki, ski) ← Keygen(λ)}i∈[1,N],
{Rij ← ReKeygen(pki, skj)}i,j∈[1,N],
(i(cid:2), L, m(cid:2), σ(cid:2))
← AOSign (.,.)
(cid:3){pki}i∈[1,N],{Rij}i,j∈[1,N]
Verify(L, m(cid:2), σ(cid:2), pki(cid:2) ) ∧ m(cid:2) (cid:5)∈ Q
(cid:5)
(cid:4)