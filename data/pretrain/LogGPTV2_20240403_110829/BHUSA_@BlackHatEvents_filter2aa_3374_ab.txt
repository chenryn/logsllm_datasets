•
GetBitmapBits / SetBitmapBits
•
GetPaletteEntries / SetPaletteEntries
•
CreatePipe / NtFsControlFile
•
Previous Mode + NtReadVirtualMemory / WriteVirtualMemory
⚫ Note: Not all techniques are suitable for YARA rules
#BHUSA @BlackHatEvents
Information Classification: General
Build the right rule
1.
Write rules according to the signatures of each stage of exploitation
2.
Write rules for latest exploit techniques
3.
Write rules for the most likey vulnerability
#BHUSA @BlackHatEvents
Information Classification: General
Write rules for latest exploit techniques
⚫ Arbitrary address read with the help of Pipe Attribute
•
July 2020, “ Scoop the Windows 10 pool! ” by Paul Fariello and Corentin Bayet of Synacktiv
⚫ Arbitrary address read and write via Windows Notification Facility (WNF)
•
June 2021, “ PuzzleMaker attacks with Chrome zero-day exploit chain ” by Kaspersky
•
July 2021 “ CVE-2021-31956 Exploiting the Windows Kernel (NTFS with WNF) ” by Alex Plaskett
•
July 2021 “ Windows Pool OverFlow Exploit ” by YanZiShuang(@YanZiShuang)
⚫ These two exploit techniques are universal, we wrote rules for them and caught 
some high-value samples
#BHUSA @BlackHatEvents
Information Classification: General
Build the right rule
1.
Write rules according to the signatures of each stage of exploitation
2.
Write rules for latest exploit techniques
3.
Write rules for the most likey vulnerability
#BHUSA @BlackHatEvents
Information Classification: General
Write rules for the most likey vulnerability
⚫ The case of Desktop Windows Manager (DWM) vulnerability
•
April 13, 2021, Kaspersky wrote a blog and disclosed CVE-2021-28310, which is an itw 0day in the
Windows DWM component
•
“ Zero-day vulnerability in Desktop Window Manager (CVE-2021-28310) used in the wild ”
•
May 03, 2021, ZDI published another blog, disclosing another vulnerability CVE-2021-26900, which is
also a vulnerability in Windows DWM component
•
“ CVE-2021-26900: Privilege escalation via a use after free vulnerability in win32k ”
•
May 22, 2021, we caught a new itw DWM 0day CVE-2021-33739
#BHUSA @BlackHatEvents
Information Classification: General
Build a workable system
⚫ When an exploit is matched by a rule, how to notify us in time? 
•
VirusTotal: PI:EMAIL
•
Own Products: Email
⚫ When we get an exploit, how to quickly reproduce and classify it?
•
Prepare three types of reproduce environments: Nday, 1day, 0day
•
VMs of Windows 7, Windows 10, Windows 11, covered both x86 and x64
⚫ What skills should we master to debug different Windows LPE exploits?
•
Driver Verifier
•
Windows Remote Debugging (when debugging dwm.exe)
#BHUSA @BlackHatEvents
Information Classification: General
Build a workable system
⚫ When an exploit is matched by a rule, how to notify us in time? 
•
VirusTotal: PI:EMAIL
•
Own Products: Email (Slack is also a good choice)
⚫ When we get an exploit, how to quickly reproduce and classify it?
•
Prepare three types of reproduce environments: Nday, 1day, 0day
•
VMs of Windows 7, Windows 10, Windows 11, covered both x86 and x64
⚫ What skills should we master to debug different Windows LPE exploits?
•
Driver Verifier
•
Windows Remote Debugging (when debugging dwm.exe)
#BHUSA @BlackHatEvents
Information Classification: General
Build a workable system
⚫ When an exploit is matched by a rule, how to notify us in time? 
•
VirusTotal: PI:EMAIL
•
Own Products: Email (Slack is also a good choice)
⚫ When we get an exploit, how to quickly reproduce and classify it?
•
Prepare three types of reproduce environments: Nday, 1day, 0day
•
VMs of Windows 7, Windows 10, Windows 11, covered both x86 and x64
⚫ What skills should we master to debug different Windows LPE exploits?
•
Driver Verifier
•
Windows Remote Debugging (when debugging dwm.exe)
#BHUSA @BlackHatEvents
Information Classification: General
Test and improve the system
⚫ Eliminate false positives and false negatives
1.
Use historical itw samples to test the rules
2.
Use public pocs/exploits to test the rules
3.
Write pocs/exploits and test the rules (when public pocs/exploits are unavailable)
4.
Apply the rules to a large number of samples for stress testing
5.
(Continuously) Convert the latest exploit techniques into rules and test them
#BHUSA @BlackHatEvents
Information Classification: General
Agenda
⚫ Motivation
⚫ Learn from history (and now)
⚫ One road leads to Rome
⚫ Results
• The Story of CVE-2021-1732
• The Story of CVE-2021-33739
• The Story of a “Patched” 1day
⚫ Takeaways
#BHUSA @BlackHatEvents
Information Classification: General
The Story of CVE-2021-1732
⚫ Data source
•
The itw sample was from our private dataset
⚫ Why it caught our attention
•
It used HMValidateHandle to leak kernel address
⚫ Usage scenario
•
The sample was used as a standalone component
•
Need a parameter (process id)
#BHUSA @BlackHatEvents
Information Classification: General
The Story of CVE-2021-1732
⚫ Some highlights of the itw sample
•
It targeted the latest version of Windows operating system (Windows 10 1909 x64)
•
The sample was compiled in May 2020
•
It used GetMenuBarInfo to built arbitrary address read primitive
•
Which is a previously undisclosed exploit technique
•
Before exploit, it detected specific antivirus and performed system version check
•
Targeted Windows 10 1709 x64 ~ Windows 10 1909 x64
⚫ More details can refer to our blog
#BHUSA @BlackHatEvents
Information Classification: General
The Story of CVE-2021-33739
⚫ Data source
•
The itw sample was from VirusTotal (compiled from GitHub)
⚫ Why it caught our attention
•
It hit a rule we wrote for the most likely vulnerability (Desktop Window Manager)
⚫ Side note
•
The “author” accidentally introduced this new bug when writing an exploit for CVE-2021-26868
•
It seems that the “author” knew this
#BHUSA @BlackHatEvents
Information Classification: General
The Story of CVE-2021-33739
⚫ This is what we sent to MSRC before the bug was fixed
The first vulnerability has been fixed by Microsoft in the May 2021 patch, but the second vulnerability
is still a zero day.
I think the exploit author accidentally included a second vulnerability when attempting to
publish the exploit code of a known vulnerability, and the second vulnerability happened to be
discovered by me when I hunting for in-the-wild zero day.
So I think the second vulnerability is not strictly a zero-day vulnerability in the wild. This is just
my opinion, the final release definition depends on you.
#BHUSA @BlackHatEvents
Information Classification: General
The Story of CVE-2021-33739
⚫ This is the exploit status finally published by MSRC 
#BHUSA @BlackHatEvents
Information Classification: General
Root cause of CVE-2021-33739
⚫ Unbalanced reference count on CinteractionTrackerBindingManager Object in dwmcore.dll
⚫ Steps to trigger the vulnerability
1.
Create a CInteractionTrackerBindingManagerMarshaler resource
2.
Create a CinteractionTrackerMarshaler resource
3.
Bind the resource created by step 1 twice to the resource created by step 2 (as follows), and do not 
release these resources manully
DWORD dwDataSize = 12;
DWORD* szBuff = (DWORD*)malloc(4 * 3);
szBuff[0] = 0x02;
// resource1_id is DirectComposition::CInteractionTrackerMarshaler
szBuff[1] = 0x02;
// resource2_id is DirectComposition::CInteractionTrackerMarshaler
szBuff[2] = 0xffff; // new_entry_id
#BHUSA @BlackHatEvents
Information Classification: General
Root cause of CVE-2021-33739
⚫ Normally, the CinteractionTrackerBindingManager object will call ProcessSetTrackerBindingMode twice
to add reference count by 2
⚫ Then the code will call RemoveTrackerBindings twice to sub reference count, and release the
CinteractionTrackerBindingManager object normally when reference count is reduced to 0
// reference count starts from 0
CResourceFactory::Create +1 .............................................. ref_count = 1
CResourceTable::CreateEmptyResource +1 ................................... ref_count = 2
CComposition::Channel_CreateResource -1 .................................. ref_count = 1
CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode +1 ....... ref_count = 2
CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode +1 ....... ref_count = 3
CResourceTable::DeleteHandle -1 .......................................... ref_count = 2
CInteractionTrackerBindingManager::RemoveTrackerBindings -1 .............. ref_count = 1
CInteractionTrackerBindingManager::RemoveTrackerBindings -1 .............. ref_count = 0
// release object when reference count is reduced to 0 
#BHUSA @BlackHatEvents
Information Classification: General
Root cause of CVE-2021-33739
⚫ Normally, the CinteractionTrackerBindingManager object will call ProcessSetTrackerBindingMode twice to
add reference count by 2.
⚫ Then the code will call RemoveTrackerBindings twice to sub reference count by 2, and release the
CinteractionTrackerBindingManager object normally when reference count is reduced to 0
// reference count starts from 0
CResourceFactory::Create +1 .............................................. ref_count = 1
CResourceTable::CreateEmptyResource +1 ................................... ref_count = 2
CComposition::Channel_CreateResource -1 .................................. ref_count = 1
CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode +1 ....... ref_count = 2
CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode +1 ....... ref_count = 3
CResourceTable::DeleteHandle -1 .......................................... ref_count = 2
CInteractionTrackerBindingManager::RemoveTrackerBindings -1 .............. ref_count = 1
CInteractionTrackerBindingManager::RemoveTrackerBindings -1 .............. ref_count = 0
// release object when reference count is reduced to 0 
#BHUSA @BlackHatEvents
Information Classification: General
Root cause of CVE-2021-33739
⚫ In the vulnerability scenario, it will call ProcessSetTrackerBindingMode only once to add reference
count by 1
⚫ But the code will still call RemoveTrackerBindings twice to sub reference count by 2
⚫ UAF in the second RemoveTrackerBindings call
// reference count starts from 0
CResourceFactory::Create +1 .............................................. ref_count = 1
CResourceTable::CreateEmptyResource +1 ................................... ref_count = 2
CComposition::Channel_CreateResource -1 .................................. ref_count = 1
CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode +1 ....... ref_count = 2
CResourceTable::DeleteHandle -1 .......................................... ref_count = 1
CInteractionTrackerBindingManager::RemoveTrackerBindings -1 .............. ref_count = 0
// release object when reference count is reduced to 0 
CInteractionTrackerBindingManager::RemoveTrackerBindings -1 .............. UAF
#BHUSA @BlackHatEvents
Information Classification: General
The Story of a “Patched” 1day
⚫ Data source
•
The itw sample was from VirusTotal
⚫ Why it caught our attention
•
It hit a rule we wrote for the latest exploit techniques (Pipe Attribute)
⚫ Usage scenario
•
The sample was used as a standalone component
•
The exploit code was adapted to a variety of Windows OS versions
#BHUSA @BlackHatEvents
Information Classification: General
The Story of a “Patched” 1day
⚫ Basic information
•
A type confusion vulnerability in clfs.sys
•
Caught in October 2021, “Patched” in September 2021
•
May be one of CVE-2021-36963, CVE-2021-36955, CVE-2021-38633 or none of them
⚫ Root cause
•
The clfs.sys lacks some checks on Client Context Offset, an attacker can take advantage of this to
provide an invalid Client Context Offset
#BHUSA @BlackHatEvents
Information Classification: General
The Story of a “Patched” 1day
⚫ How the itw sample use this vulnerability
•
The itw sample leveraged this to make the first Client Context Offset(0x2B5) point to the second
Container Context Offset, then it used an 1-bit flip to change the second Container Context Offset
from 0x13A0 to 0x1BA0
“DeathNote of Microsoft Windows Kernel”, KeenLab, 2016
“CLFS Internals”, Alex Ionescu, 2021 
#BHUSA @BlackHatEvents
Information Classification: General
The Story of a “Patched” 1day
⚫ The 1-bit filp in CClfsLogFcbPhysical::FlushMetadata
1: kd> .formats 13A0
Evaluate expression:
Hex:
00000000`000013a0
Binary:
00000000 00000000 00000000 00000000 00000000 00000000 00010011 10100000
1: kd> ? 13 | 8
Evaluate expression: 27 = 00000000`0000001b
1: kd> .formats 1BA0
Evaluate expression:
Hex:
00000000`00001ba0
Binary:
00000000 00000000 00000000 00000000 00000000 00000000 00011011 10100000
#BHUSA @BlackHatEvents
Information Classification: General
The Story of a “Patched” 1day
⚫ The arbitrary address write primitive in CClfsBaseFilePersisted::RemoveContainer
•
The normal virtual table of a ClfsContainer object
•
The fake virtual table of the fake ClfsContainer object
1: kd> dps fffff804`2e9354b8
fffff804`2e9354b8
fffff804`2e960c10 CLFS!CClfsContainer::AddRef
fffff804`2e9354c0
fffff804`2e94c060 CLFS!CClfsContainer::Release
fffff804`2e9354c8
fffff804`2e92b570 CLFS!CClfsContainer::GetSListEntry
fffff804`2e9354d0
fffff804`2e9489e0 CLFS!CClfsContainer::Remove
0: kd> dps 0000003a`b777f1e8
0000003a`b777f1e8  00000000`00000000
0000003a`b777f1f0  fffff804`2f0cc390 nt!HalpDmaPowerCriticalTransitionCallback
0000003a`b777f1f8  00000000`00000000
0000003a`b777f200  fffff804`2ef95f70 nt!XmXchgOp
#BHUSA @BlackHatEvents
Information Classification: General
The Story of a “Patched” 1day
⚫ The arbitrary address read primitive
•
“Pipe Attribute” technique described in the “Scoop the Windows 10 pool!” (SSTIC2020)
struct PipeAttribute {
LIST_ENTRY list;
char * AttributeName;
uint64_t AttributeValueSize;
char * AttributeValue;
char data [0];
};
hRes = NtQuerySystemInformation(SystemBigPoolInformation, pBuffer, dwBufSize, &dwOutSize);
•
SystemBigPoolInformation technique described in “windows_kernel_address_leaks” (Github)
#BHUSA @BlackHatEvents
Information Classification: General
The Story of a “Patched” 1day
⚫ The September 2021 patch
•
The patch only checked the value of Client Context Offset to make sure it couldn't be less than
0x1368
#BHUSA @BlackHatEvents
Information Classification: General
The Story of a “Patched” 1day
⚫ Has it been fixed thoroughly?
•
What if we construct a Client Context Offset that is greater than 0x1368, and make the Client Context
Offset point directly to the CClfsContainer object?
•
BSOD
•
A variant of this “patched” 1day
•
Reported to MSRC at December 2021
•
Microsoft fixed this case in April 2022
as CVE-2022-24481
#BHUSA @BlackHatEvents
Information Classification: General
Agenda
⚫ Motivation
⚫ Learn from history (and now)
⚫ One road leads to Rome
⚫ Results
• The Story of CVE-2021-1732
• The Story of CVE-2021-33739
• The Story of a “Patched” 1day
⚫ Takeaways
#BHUSA @BlackHatEvents
Information Classification: General
Suggestions
1. Choose the most suitable method within your capability
2. Carefully study historical cases is always a good thing
3. Keep an eye out for new variants of a new itw vulnerabillity
#BHUSA @BlackHatEvents
Information Classification: General
Insights
1. More vulnerabilities in clfs may appear in the future
2. “Pipe Attribute” method will be using again in the future
3. The following techniques may be popular in the future
•
Arbitrary address read/write with the help of WNF, POC2021
•
Arbitrary address read/write with the help of ALPC, Blackhat Asia 2022
•
Arbitrary address read/write with the help of I/O Ring, TyphoonCon 2022
#BHUSA @BlackHatEvents
Information Classification: General
Acknowledgements
⚫ Thanks to guys of DBAPPSecurity WeBin Lab
⚫ Thanks to @megabeets_ and @EyalItkin for their inspiring blogs
⚫ Thanks to Xiaoyi Tu and Dong Wu of DBAPPSecurity Lieying Lab
⚫ Thanks to @YanZiShuang and @oct0xor for sharing debugging tips
#BHUSA @BlackHatEvents
Information Classification: General
Thank you!
Questions?