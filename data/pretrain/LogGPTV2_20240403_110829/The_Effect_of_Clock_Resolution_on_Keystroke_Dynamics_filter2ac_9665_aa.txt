title:The Effect of Clock Resolution on Keystroke Dynamics
author:Kevin S. Killourhy and
Roy A. Maxion
The Eﬀect of Clock Resolution
on Keystroke Dynamics
Kevin Killourhy and Roy Maxion
Dependable Systems Laboratory
Carnegie Mellon University
5000 Forbes Ave,
Pittsburgh PA, 15213
{ksk,maxion}@cs.cmu.edu
Abstract. Keystroke dynamics—the analysis of individuals’ distinctive
typing rhythms—has been proposed as a biometric to discriminate le-
gitimate users from impostors (whether insiders or external attackers).
Anomaly detectors have reportedly performed well at this discrimination
task, but there is room for improvement. Detector performance might be
constrained by the widespread use of comparatively low-resolution clocks
(typically 10–15 milliseconds).
This paper investigates the eﬀect of clock resolution on detector perfor-
mance. Using a high-resolution clock, we collected keystroke timestamps
from 51 subjects typing 400 passwords each. We derived the timestamps
that would have been generated by lower-resolution clocks. Using these
data, we evaluated three types of detectors from the keystroke-dynamics
literature, ﬁnding that detector performance is slightly worse at typical
clock resolutions than at higher ones (e.g., a 4.2% increase in equal-error
rate). None of the detectors achieved a practically useful level of perfor-
mance, but we suggest opportunities for progress through additional, con-
trolled experimentation.
Keywords: Anomaly detection; Insider-attack detection; Keystroke dy-
namics; Digital biometrics.
1 Introduction
Compromised passwords, shared accounts, and backdoors are exploited both by
external attackers and insiders. Lists of default passwords and password-cracking
programs are a staple in the toolbox of external attackers. In a study of insider
attacks (i.e., those conducted by people with legitimate access to an organiza-
tion), Keeney et al. [11] found that the majority of insiders exploited shared
or compromised passwords, as well as backdoor accounts. However, if we had
some sort of “digital ﬁngerprint” with which to identify exactly who is logging
into an account, and to discriminate between the legitimate user of an account
and an impostor, we could signiﬁcantly curb the threats represented by both
insiders and external attackers. Of the various potential solutions to this prob-
lem, one technique that has been popular within the research community is
R. Lippmann, E. Kirda, and A. Trachtenberg (Eds.): RAID 2008, LNCS 5230, pp. 331–350, 2008.
c(cid:2) Springer-Verlag Berlin Heidelberg 2008
332
K. Killourhy and R. Maxion
keystroke dynamics—the analysis of individual typing rhythms for use as a bio-
metric identiﬁer. Compared to other biometric data, typing times are relatively
easy to collect. When a user logs into a computer by typing his or her password,
the program authenticating the user could save not just the characters of the
password, but the time at which each key was pressed and released. One could
imagine a keystroke-dynamics detection algorithm that analyzes these typing
times, compares them to a known proﬁle of the legitimate user of the account,
and makes a decision about whether or not the new typist is an impostor. In
fact, detectors have been designed to use typing rhythms as a biometric, not just
during password entry (which is our focus in this work), but also for free-text
typing [17].
In terms of accuracy, the European standard for access-control systems (EN-
50133-1) speciﬁes a false-alarm rate of less than 1%, with a miss rate of no more
than 0.001% [3]. In other words, in order for a keystroke-dynamics detector to
be practical, it must correctly identify a legitimate user 99% of the time, and
it must correctly identify an impostor 99.999% of the time. At this point, no
proposed detector has obtained such numbers in repeated evaluations. When a
detector comes up short in evaluation, the common strategy is to go back to the
drawing board and try a new detector. However, it may be possible to boost the
performance of an existing detector by giving it better data.
Imagine the eﬀect that timing noise might have on a detector. With enough
noise, subtle diﬀerences between typists will be masked, and even a good detector
will be ineﬀective. One obvious source of noise comes from the resolution of
the clock supplying timestamps for each keystroke. For instance, our testing
shows that the clock used by Microsoft Windows XP to timestamp keystroke-
event messages [15] (which we call the Windows-event clock) has a resolution
of 15.625 milliseconds (ms), corresponding to 64 updates per second. Figure
1 shows how the clock resolution aﬀects the calculation of keydown–keydown
digram latencies. Speciﬁcally, if every time reported by the clock is a multiple of
15.625 ms (truncated to the nearest millisecond), then all latencies will appear
to fall in bands separated by 15 ms. The calculated latencies could diﬀer from
the true latencies by as much as the resolution of the clock (approximately
±15 ms). If two typists diﬀer in their typing times by less than 15 ms, then
the diﬀerence could be lost. This investigation empirically measures the eﬀect of
clock resolution on the performance of a detector. Speciﬁcally, we look at whether
the performance of a detector can be boosted by increasing the resolution of the
clock, and whether or not detectors are robust to low-resolution clocks.
2 Background and Related Work
Detectors for discriminating between users’ and impostors’ keystroke dynamics
have been investigated for over 30 years. They were ﬁrst considered in 1977 by
Forsen et al. [6], who distinguished a legitimate user from an impostor on the
basis of how each one typed the user’s name. In 1980, Gaines et al. [7] compared
The Eﬀect of Clock Resolution on Keystroke Dynamics
333
)
s
m
(
s
e
c
n
e
i
t
a
L
n
w
o
d
y
e
K
−
n
w
o
d
y
e
K
0
0
2
0
8
1
0
6
1
0
4
1
0
2
1
0
0
1
5
10
15
20
25
30
35
40
45
50
Subject
Fig. 1. The spacing between each horizontal band of keystroke latencies reveals that
the Windows-event clock has a resolution of 15.625 milliseconds. Any ﬁne-grained dif-
ferences between the subjects are masked when all latencies are coarsened to a nearby
multiple of the clock resolution. Data are keydown–keydown digram latencies (between
100 and 200 ms) recorded by the 15.625 ms resolution clock when each of 51 subjects
typed a password 400 times. Double bands occur because Windows reports the time-
stamps as a whole number of milliseconds, sometimes rounding up and sometimes
rounding down.
several users’ keystrokes on a transcription task. Both studies presented positive
ﬁndings, but cautioned that their results were only preliminary.
Joyce and Gupta [10] were some of the earliest researchers to study the key-
stroke dynamics of passwords. They developed a detector that compared typing
characteristics of a new presentation of a password against the average (mean)
typing characteristics of the legitimate user. Cho et al. [4] developed and com-
pared two new detectors, inspired by techniques from machine learning. One
was based on the nearest-neighbor algorithm, and the other used a multilayer
perceptron. A full survey of keystroke-dynamics detectors has been conducted
by Peacock et al. [17], but we focus here on the work of Joyce and Gupta, and
Cho et al. Their work shows a diversity among available detection techniques,
and our investigation uses detectors similar to theirs.
In terms of timing considerations, Forsen et al. and Gaines et al. collected
data on a PDP-11. Forsen et al. reported times in 5-millisecond intervals, while
Gaines et al. reported millisecond accuracy. Both Joyce and Gupta, and Cho et
al. collected data on a Sun workstation. Cho et al. speciﬁed that they used X11,
which provides keystroke timestamps with a 10 ms resolution. The X11 clock
is typically used by researchers on UNIX-based platforms, while Windows users
typically use the Windows-event clock (e.g., Sheng et al. [19]). Our testing shows
that the timestamps reported through this clock have a 15.625 ms resolution (see
Figure 1).
334
K. Killourhy and R. Maxion
3 Problem and Approach
Keystroke-dynamics detectors—programs designed to distinguish between a le-
gitimate user and an impostor on the basis of typing rhythms—will almost cer-
tainly be aﬀected by the resolution of the clock that is used for timing the
keystrokes. However, the extent of this eﬀect has never been quantiﬁed or mea-
sured. In this work, we investigate the eﬀect that clock resolution has on the
performance of keystroke-dynamics detectors. We hope to boost detector per-
formance by using better clocks, and to quantify the error introduced by typical
clocks.
3.1 Investigative Approach
Our approach is outlined in the following four steps:
1. Password-data collection: We choose a password, and we implement a
data-collection apparatus that records high-resolution timestamps. We recruit
subjects to type the password. We collect keystroke timestamps simultane-
ously with a high-resolution clock and with a typical low-resolution clock.
2. Derived clock resolutions: We coarsen the high-resolution timestamps, in
order to calculate the timestamps that would be generated by a range of lower-
resolution clocks; we derive password-timing data at a range of resolutions.
3. Detector implementation: We develop three types of keystroke-dynamics
detectors similar to those reported in the literature: a mean-based detector,
a nearest-neighbor detector, and a multilayer perceptron.
4. Performance-assessment method: We construct evaluation data sets
from our password-timing data, and we use them to measure the performance
of the three detectors. We verify the correctness of our derivations (in step 2)
by comparing a detector’s performance on derived low-resolution data to its
performance on data from a real clock operating at that resolution. Finally,
we examine how the performance changes as a function of clock resolution.
In the end, we are able to quantify the eﬀect that clock resolution has on several
diverse detectors. We show a small but signiﬁcant improvement from using high-
resolution clocks. We describe the four steps of our investigation in Sections 4–7.
3.2 Controlling for Potential Confounding Factors
Our approach departs from typical keystroke-dynamics evaluations, where real-
ism is considered to have higher importance than control. A reason for designing
a controlled experiment is to remove confounding factors—variables that may
distort the eﬀect of the variable of interest on the experimental outcome [5].
In our investigation, the variable of interest is the clock resolution, and the
experimental outcome is the performance of a detector. The clock might aﬀect
detector performance because it subtly changes the keystroke times analyzed
by the detectors. All other factors that change these keystroke times are poten-
tial confounding factors that might obscure or distort this eﬀect. They might
The Eﬀect of Clock Resolution on Keystroke Dynamics
335
change a detector’s performance, or even change how clock resolution aﬀects the
detector’s performance. The presence of such a factor would compromise our
investigation by oﬀering an alternative explanation for our results.
Ideally, we would test all potential confounding factors, to see whether they
actually do confound the experiment. However, to do so would require an ex-
ponential amount of data (in the number of factors). Practically, we control for
potential confounding factors by keeping them constant.
4 Password-Data Collection
The ﬁrst step in our investigation was to collect a sample of keystroke-timing
data using a high-resolution clock. We chose a single password to use as a typing
sample. Then we designed a data-collection apparatus for collecting subjects’
keystrokes and timestamps. Finally, we recruited 51 subjects, and collected the
timing information for 400 passwords from each one (over 8 sessions).
4.1 Choosing a Password
Password selection is the ﬁrst potential confounding factor we identiﬁed. Some
passwords can be typed more quickly than others. The choice of password may
aﬀect a subject’s keystroke times, distorting the eﬀect of clock resolution. To
control for the potential confounding factor, we chose a single ﬁxed but repre-
sentative password to use throughout the experiment.
To make the password representative of a typical, strong password, we em-
ployed a publicly available password generator [21] and password-strength checker
[13]. We generated a 10-character password containing letters, numbers, and punc-
tuation and then modiﬁed it slightly, interchanging some punctuation and casing
to better conform with the general perception of a strong password. The result of
this procedure was the following password:
.tie5Roanl
The password-strength checker rates this password as strong because it con-
tains at least 8 characters, a capital letter, a number, and punctuation. The best
rating is reserved for passwords with at least 14 characters, but we decided to
maintain a 10-character limit on our password so as not to exhaust our subjects’
patience. (Other researchers used passwords as short as 7 characters [4].)
4.2 Data-Collection Apparatus
We wrote a Windows application that prompts a subject to type the password
50 times. Of course, in the real world, users do not type their password 50 times
in a row; they might only type it a few times each day. However, the amount
of practice a subject has at typing a particular password represents another po-
tential confounding factor (see Section 3.2). Practiced typists are usually faster,
and the amount of practice a subject has may aﬀect his or her keystroke times.
336
K. Killourhy and R. Maxion
By having our subjects type the password in ﬁxed-length sessions, we controlled
how much (and under what circumstances) our subjects became practiced at
typing the password.
The application displays the password in a screen along with a text-entry
ﬁeld. In order to advance to the next screen, the subject must type the 10
characters of the password correctly in sequence and then type Return. If the
subject makes a mistake, the application immediately detects the error, clears
the text-entry ﬁeld, and after a short pause, it prompts the subject to type
the password again. For instance, if a subject typed the ﬁrst three characters
of the password correctly (.ti) but mistyped the fourth (w instead of e), the
application would make the subject type the whole password over again. In this
way, we ensure that the subject correctly types the entire password as a sequence
of exactly 11 keystrokes (corresponding to the 10 characters of the password and
the Return key). Forcing subjects to type the password without error is a typical
constraint when analyzing keystroke dynamics [4, 19].
When a subject presses or releases a key, the application records the event
(i.e., whether a key was pressed or released, and what key was involved), and
also the time at which the event occurred. Two timestamps are recorded: one is
the timestamp reported by the 15.625 ms resolution Windows-event clock; the
other is the timestamp reported by a high-resolution external reference clock.
The resolution of the reference clock was measured to be 200 microseconds by
using a function generator to simulate key presses at ﬁxed intervals. This clock
reported the timestamps accurately to within ±200 microseconds. We used an
external reference instead of the high-precision performance counter available
through Windows [16] because of concerns that factors such as system load