Play safeguards successfully.
android-sync-http 1.4.9. Finally, we looked at the android-
async-http [1] library providing interfaces for HTTP connec-
tions. This library included a vulnerable TrustManager in
version 1.4.9 [12] (LB-U-asynchttp) and like previous experi-
ments passed successfully without warnings.
Insecure Apps in Google Play
5.5
Motivated by the experiments above and previous work [70,
75, 80, 86], we replicated a study performed by Fahl et al. in
2012 [54]. However, we replaced the outdated MalloDroid
tool [54] with the most currently published tool for vulnerable
certiﬁcate validation logic in Android apps CryptoGuard [80]
that was released in 2019. CryptoGuard can detect crypto-
graphic vulnerabilities in general and vulnerable certiﬁcate
validation code of both Java programs and Android apps. We
picked a random set of 15,000 Android apps for the Crypto-
Guard analysis. Since CryptoGuard does not perform reach-
ability analyses, we cannot tell whether vulnerable code is
USENIX Association
30th USENIX Security Symposium    4357
actually executed. Using CryptoGuard reports we also can-
not distinguish developer code from third party library code.
Following Rahaman et. al [80] we terminated app processing
after 10 minutes, therefore possibly skipping the analysis of
more complex apps.
Overall, we found 2,232 (14.8%) apps with vulnerable
HostnameVeriﬁer and 5,202 (34.7%) apps with vulnerable
TrustManager implementations. Most of the affected apps
implemented both vulnerabilities, resulting in 5,511 (36.7%)
vulnerable apps total.
Surprisingly, these results are in line with reports from Fahl
et al. [54] and Georgiev et al. [58] and show that the Google
Play security checks for TLS are inefﬁcient.
6 Limitations
Our work has the following limitations:
Body of Android Apps. The Google Play crawler we used
to download apps works on a best-effort basis. We seeded
the crawler with a small list of popular free Google Play ap-
plications and recursively downloaded all available similar
apps. Although we were able to ﬁnd 1,335,322 free apps that
have received an update after Android 7, we cannot guarantee
that we were able to ﬁnd all free Google Play applications.
However, the behavior of our crawler is in line with previous
work [37]. We also limited our analysis to free apps and ig-
nored paid apps. Although we cannot generalize our ﬁndings
to paid Android apps, this is also in line with previous Android
security research [46, 48, 50–52, 54–57, 74, 75, 85]. We de-
ployed the crawler at a university in Germany which resulted
in 77,676 apps that we could not download due to geographic
restrictions. Similarly, we could not download 264,249 apps
that were e.g. removed from Google Play between crawling
meta-data and download of APK ﬁles.
NSC Analysis. We identiﬁed 99,212 apps with custom NSC
ﬁles. However, we could not analyze 2,812 of them due to
obfuscation. As for the analysis of NSC ﬁles, we might be
limited in our analysis of data related to HTTP(S) origins
and certiﬁcation data since we downloaded HTTPS certiﬁ-
cates from Germany. Hence, the availability of HTTPS for
certain websites, certiﬁcate chains and corresponding pins
from certiﬁcates might differ from the respective results in
other regions. In addition, since we analyze older versions of
applications, servers could have changed their conﬁgurations
over time which might not reﬂect the contents of NSC ﬁles
anymore. Both limitations might apply in situations where
certiﬁcate data is fetched in order to calculate pins we want
to match against either trusted roots or pins speciﬁed in NSC
ﬁles. Likewise, especially pins for backup that are not yet in
use might not be matched by us as they might not (yet) be vis-
ible. As there is only one NSC ﬁle per application, there is no
distinction between conﬁguration related to the main applica-
tion and libraries. This limitation may also apply for the static
code analysis we conducted, which means that our analysis
might not accommodate or might be limited to account for
e.g. runtime behavior or reﬂection.
7 Discussion
In this section, we discuss key takeaways and the lessons
we learned from our analysis of TLS certiﬁcate validation
security in 1,335,322 free Android applications from Google
Play. We discuss our analysis results and compare the state of
certiﬁcate validation security in Android in 2020 with results
reported in 2012 [54, 58].
We report positive as well as disappointing trends. Android
deployed multiple measures in response to security vulnerabil-
ities related to certiﬁcate validation. The measures include the
introduction of NSC to support developers in implementing
custom certiﬁcate validation logic, the default enforcement
of HTTPS in apps targeting Android 9 or higher, and Google
Play safeguards in 2016 and 2017 to prevent the publication of
apps included insecure certiﬁcate validation code. While new
Android apps beneﬁt from new secure defaults (e.g., HTTPS
by default), our results show the need for further security im-
provements. In the following, we will address the problems
we found and discuss possible improvements.
Customization is Harmful. We ﬁnd that usually, whenever
developers conﬁgure NSC ﬁles manually to handle TLS cer-
tiﬁcate validation, security takes a hit. Our results mirror the
2012 results by Fahl et al. [54] and Georgiev et al. [58] that
showed that custom certiﬁcate validation implementations in
Android apps lead to vulnerabilities. In 2012, the underlying
problem was insecure code that turns off certiﬁcate validation
in 95% of apps with custom certiﬁcate validation code. Our
results show that the problem persists in customized NSC ﬁles.
Out of the 99,212 apps with custom NSC ﬁles that we were
able to identify in our body of Android applications, 88,174
(88.87%) apps included conﬁgurations that downgrade secu-
rity compared to default settings, mostly due to developers
re-enabling HTTP trafﬁc. Dramatically, we were able to show
that this is usually unnecessary since the remote servers often
supported HTTPS. Similar to the 2012 results, we were also
able to see that developers still tend to roll out debug conﬁgu-
rations in their production apps, unnecessarily leaving users
at risk. We also show that 8.67% of the apps that include cus-
tom NSC settings allow user-installed CAs, which attackers
can exploit in MitMAs [77]. This is in line with ﬁndings of
Possemato and Fratantonio [79]. While they investigated a
smaller app set, our ﬁndings supports theirs in several ways:
First, we can conﬁrm NSC’s dominating use to re-enable
cleartext trafﬁc (cf. 4.1.1). We report similar ﬁndings regard-
ing conﬁgurations for 127.0.0.1 (cf. Section 4.1.1) and copy
paste behavior (cf. Section 4.1.6). Furthermore, their insights
extend the investigations regarding the impact of vulnerable
library use reported in our work, but clearly corroborate our
4358    30th USENIX Security Symposium
USENIX Association
ﬁndings in a bigger picture. Likewise, we can support their
proposals for extending NSC.
Pinning is Still an Issue. As early as 2012, 2013 and 2015,
Fahl et al. [54, 56] and Oltrogge et al. [74] showed that only a
small portion of developers implement certiﬁcate pinning. In
developer interviews and surveys, they found that pinning is
too complicated for most developers to implement and that
the implementations are often faulty. Android has since sim-
pliﬁed the use of certiﬁcate pinning, which has become much
more straightforward via the conﬁguration of NSC ﬁles as
compared to the more complicated implementation via cus-
tom code, which was previously necessary. Our results show
that, even though pinning should, in theory, have become
more accessible, the rollout of NSC has not led to increased
pinning use. Only 0.67% of the apps we investigated use
NSC’s pinning feature. The (non-)use of pinning seems to,
therefore, not only be caused by the complexity of its imple-
mentation. Additionally, pinning seems to be a feature that is
only interesting for a small minority of developers. Our ﬁnd-
ings conﬁrm the results of Possemato and Fratantonio [79] on
the low occurrence of pinning in NSC ﬁles and unintentional
misconﬁgurations of pins that occurs across their sample (cf.
Section 4.1.2 and 4.1.6).
NSC Implementation is Error-Prone. We were able to de-
tect several faulty and insecure NSC conﬁgurations. Even
though these are not responsible for a large number of vul-
nerabilities, they show systematic weaknesses in the current
deployment of NSC. We were able to ﬁnd apps that used
URLs instead of domain names for domain-speciﬁc conﬁgu-
rations. While this type of erroneous conﬁguration does not
prevent the app from working, it ignores the setting for the do-
main. Similar to our ﬁndings, Possemato and Fratantonio [79]
report problematic domain usage, e.g. by developers using
both the dummy domain example.com or invalid parameters
for pins or domains (cf. Section 4.1.6). However, in addition,
we discover cases in which URLs, regular expressions or other
invalid strings are added instead of domains, all of which can
lead to apps becoming less secure despite the use of pinning
due to non-functional conﬁgurations.
We trace these misconﬁgurations back to insufﬁcient docu-
mentation and lack of support for the Android Studio IDE. An-
droid Studio only provides basic XML support for NSC ﬁles.
There is limited support for tags and attributes (only limited
support for misspelled or wrong tags or attributes (e.g., URLs
instead of domains) or duplicates (e.g., for pins)). Android
Studio does not support auto-completion for NSC. Available
Android Studio support is based on LINTING checks [22]
for NSC and dates back to 2016. Since then, there were no
signiﬁcant enhancements.
We corroborate ﬁndings that resemble vulnerabilities found
in 2012, 2013, and 2015 by Fahl et al., Georgiev et al., and
Oltrogge et al. Nguyen et al. [73] showed that better developer
support in the IDE has the potential to lead to signiﬁcant
improvements to app security. Similar approaches for NSC
seem promising.
Google Play Safeguards are Insufﬁcient. Even though
Google Play announced safeguards for vulnerable imple-
mentations of certiﬁcate validation logic in 2016 and 2017,
and the ability of state of the art tools [41, 80] to iden-
tify the vulnerabilities we tested, our ﬁndings and previous
work [70,75,80,86] suggest that Google Play’s present deploy-
ment of these checks is insufﬁcient. We were able to publish
simple but vulnerable implementations of TrustManager,
HostnameVerifier, and WebViewClient code to Google
Play that, according to Google’s announcements, should have
been detected and prevented. In addition to our experiments
with publishing insecure certiﬁcate validation, we were able
to use static code analysis to show that a multitude of newly re-
leased apps still contains vulnerable implementations. While
we could not pinpoint the exact technical realization of Google
Play’s certiﬁcate validation vulnerability detection safeguards,
tools such as CryptoGuard [80] or LibScout [41] would have
detected the vulnerable apps we tested. Hence, we recom-
mend Google Play to consider the integration of state of the
art vulnerability detection mechanisms to detect and block
vulnerable apps in the future.
8 Conclusion
In this paper, we continued the long history of research efforts
covering the state of (custom) TLS certiﬁcate validation in
Android apps. While earlier studies focused on dangerous
custom TLS code and proposals to prevent this, we focus
on the on-going evolution of Android. New secure defaults
lead to better security regarding HTTPS adoption as well as
making MitMA harder to mount. At the same time, NSC,
rather than accelerating wide-spread secure use of pinning, is
mostly used for degradation of security in apps by undermin-
ing safe defaults. Also, we ﬁnd that Google Play’s safeguards
intended to prevent vulnerable TLS implementations in apps
being published do not work as expected. Overall, our results
conﬁrm that customization is often harmful to an application’s
security.
Acknowledgements
We thank the anonymous reviewers of this and an earlier revi-
sion of this paper, who have all contributed signiﬁcantly; and
particularly USENIX shepherd Professor Adwait Nadkarni
of the College of William and Mary.
This research was partially funded by the Deutsche
Forschungsgemeinschaft (DFG, German Research Founda-
tion) under Germany’s Excellence Strategy - EXC 2092
CASA – 390781972).
USENIX Association
30th USENIX Security Symposium    4359
References
[1] An
Asynchronous
HTTP
Library
for Android.
https://github.com/android-async-http/android-
async-http (visited on 09/22/2020).
[2] Android 7.0 unable to capture https packets. https://www.
cnblogs.com/0616--ataozhijia/p/9766682.html (vis-
ited on 09/22/2020).
[3] Android 8: Cleartext HTTP
trafﬁc
not permitted.
https://stackoverflow.com/questions/45940861/
android-8-cleartext-http-traffic-not-permitted
(visited on 09/22/2020).
[4] Android Root CAs. https://android.googlesource.com/
platform/system/ca-certificates/+/master/files/
(visited on 09/22/2020).
[5] Android WebView setCertiﬁcate issues SSL problems.
https://stackoverflow.com/questions/6511434/
android-webview-setcertificate-issues-ssl-
problems/57951506#57951506 (visited on 09/22/2020).
[6] 
| Android Developers.
https:
//developer.android.com/guide/topics/manifest/
application-element#usesCleartextTraffic
on 09/22/2020).
(visited
[7] Application Crash Reports for Android. https://github.
com/ACRA/acra (visited on 09/22/2020).
[8] CertiﬁcatePinner. https://square.github.io/okhttp/3.
x/okhttp/okhttp3/CertificatePinner.html (visited on
09/22/2020).
[9] Charles Web Debugging Proxy • HTTP Monitor / HTTP Proxy.
https://www.charlesproxy.com/ (visited on 09/22/2020).
[10] Debug your app | Android Developers. https://developer.
android.com/studio/debug (visited on 09/22/2020).
[11] Get Started with
the MoPub SDK for Android.
https://developers.mopub.com/publishers/android/
get-started/#step-4-add-a-network-security-
configuration-file (visited on 09/22/2020).
[12] Google Play Blocker: Unsafe SSL TrustManager De-
https://github.com/android-async-
on
ﬁned #1260.
http/android-async-http/issues/1260
09/22/2020).
(visited
[13] Google play python API.
https://github.com/
NoMore201/googleplay-api (visited on 09/22/2020).
[14] HostnameVeriﬁer.
https://developer.android.com/
reference/kotlin/javax/net/ssl/HostnameVerifier
(visited on 09/22/2020).
[15] Java android - uplaud apk and google play security
https://stackoverflow.com/questions/
alert.
43847629/java-android-uplaud-apk-and-google-
play-security-alert (visited on 09/22/2020).
[16] Java android . Google play security alert
inse-
https://stackoverflow.com/
for
cure TrustManager.
questions/43777599/java-android-google-play-