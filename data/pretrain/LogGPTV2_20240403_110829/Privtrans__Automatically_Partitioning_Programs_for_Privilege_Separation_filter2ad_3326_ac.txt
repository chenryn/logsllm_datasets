a
supplies
common
Privtrans
privwrap/privunwrap functions
such as opening a
ﬁle or creating a socket. The wrappers are reused for
each program on which we perform privilege separation.
The wrappers are implementations of functions created
using the “rpcgen” protocol compiler.
We provide wrappers for common privileged calls in-
stead of automatically generating them from the source
because we may not know statically how to wrap a
pointer argument to a call. Wrapping pointers requires
knowing the pointer’s size. Generally functions that take
a pointer argument also take an argument indicating the
pointer’s size. Finding this out is easily done by a hu-
man, say by consulting the appropriate man page, but is
difﬁcult to do with static analysis alone. The wrapper
functions are created only once, and then can be reused.
Using a shared memory region between the monitor and
slave for passing pointers may seem like an attractive so-
lution, but this approach violates the abstraction bound-
ary between monitor and slave 3 The monitor must main-
tain a separate copy of any pointers it uses similar to the
user/kernel space distinction.
Although we supply wrappers for many common func-
tions, a programmer may occasionally need to deﬁne
their own. Creating additional privwrap/privunwrap
3A shared memory region that is read-only for the slave could be
used to pass messages from the monitor to slave.
function is not difﬁcult since Privtrans provide a base
RPC library. The typical privwrap/privunwrap function
is less than 20 lines of code. The wrapper functions are
simple implementations of the declarations generated by
rpcgen.
3.4 Execution in the monitor and the monitor
state store
The slave uses a privwrap function to request the monitor
to execute a function. Upon receiving a request, the mon-
itor demarshals all arguments. If an argument is marked
privileged in the monitor’s corresponding privunwrap
function, then the argument supplied by the slave is an
index to a previously deﬁned privileged value. This fact
follows from the observation that the slave alone could
not have derived a valid index to data on the monitor.
We use a hash table to lookup each privileged argument,
and return the appropriate reference. If the index is not
valid, the monitor aborts the operation. Assuming a valid
index, the monitor executes the correct call. If the return
values (recall pointer arguments are also considered re-
turn values) are cast (statically through user annotations)
to unprivileged, then the monitor returns the values di-
rectly. If the return values are privileged, then the moni-
tor stores the results and returns the index to the slave.
The state store itself is implemented as a collection of
hash tables, one for each base C type 4. The opaque in-
dex returned to the slave is an index into the hash table.
The opaque indexes are secure since the client cannot
generate a valid index on its own. While there are many
methods to create opaque indexes, we simply associate a
random number to each indexed value.
4 Experimental results
To demonstrate Privtrans, we use it to automatically
integrate privilege separation into several open-source
programs and one open-source library: thttpd [26], the
Linux “ping” program, OpenSSL[34], OpenSSH [33],
chfn and chsh [20]. Table 1 summarizes our results.
4Using multiple hash tables reduces the number of type casts done
to eventually get the correct type.
name
src lines
# user anno-
tations
745
chfn
640
chsh
2299
ping
thttpd
21925
OpenSSH 98590
OpenSSL
211675
1
1
1
4
2
2
au-
# calls
tomatically
changed
12
13
31
13
42
7
Table 1: Results for each program with privilege sepa-
ration. The second column is the number of annotations
the programmer supplied. The third column is the num-
ber of call sites automatically changed by Privtrans
4.1 OpenSSH
Provos et al. has previously manually added privilege
separation to OpenSSH version 3.1p1 [28]. The privilege
separated code is available as OpenSSH version 3.2.2p1.
Automatically adding privilege separation to OpenSSH
3.1p1 serves as a benchmark for our automatic approach.
Our results produce a slave and monitor that are similar
to the manual OpenSSH separation by Provos et al.. The
OpenSSH server runs as root and monitors for incom-
ing connections. Upon receiving a connection, OpenSSH
forks off a slave and monitor process. The slave asks the
monitor to perform authentication and perform private
key operations 5.
After authentication, the monitor changes the uid and gid
of the slave to be that of the authenticated user. This
is accomplished through a new system call that allows
a monitor to change the uid of the corresponding slave.
Provos et al. [28] have a complex, though portable solu-
tion where the slave exports any accumulated state to the
monitor, which is exported back to the user’s login shell.
Our method is less portable but more simple.
To use Privtrans on OpenSSH, 2 annotations are needed:
one for the private keys and one for the authentication
mechanism. The interface exported by the monitor is
thus limited to pam calls and the RSA private key op-
erations. The result is a version comparable to Provos et
al..
5We did not add privilege separation for all authentication mecha-
nisms, as with Provos et al.. Instead, we focused on PAM authentica-
tion for demonstration purposes.
4.2
chfn and chsh
chfn changes the “ﬁnger” information for a user. chsh
changes the login shell for a user. Both are normally
setuid in order to write to the password ﬁle and authen-
ticate users, and both retain their privileges during pro-
gram execution. chfn and chsh have historically had se-
curity vulnerabilities [31, 6]. Only 1 annotation needs to
be speciﬁed for the PAM authentication handle. 12 and
13 call sites were automatically changed in chfn and chsh
respectively.
4.3
thttpd
thttpd is a HTTP server written with performance in
mind.
thttpd requires privileges to bind and accept
on port 80. Integrating privilege separation required the
user to provide 4 annotations. It took approximately 2
hours from downloading the source to place the correct
annotations. 13 call sites are automatically changed to
use calls to the monitor: 1 socket, 1 bind, 3 fcntl,
1 setsockopt, 4 close, 1 listen, 1 accept, and
1 poll. Privtrans comes with wrappers for all functions.
Integrating privilege separation is valuable for thttpd. Al-
though thttpd eventually drops privileges, privileges are
retained for signiﬁcant initialization.
thttpd parses user
input, sets up signal handlers, then creates and binds sev-
eral sockets before dropping privileges. Thus, if an at-
tacker can raise a signal before the program calls setuid,
the signal handlers will be executed with elevated privi-
leges. One such signal handler, SIG ALRM, could cause
the program to core dump in /tmp. With knowledge of
the PID, an attacker may be able to overwrite any ﬁle in
/tmp.
4.4 ping
The ping source is available as part of the iputils pack-
age in many Linux distributions. ping is normally setuid
to root in order to create a raw socket. Although ping
drops privileges after socket creation, an exploit could
still break policies we may wish to enforce. For exam-
ple, one may wish to allow ping to only send a certain
number or limit the size of packets sent to a destination.
Note access control is insufﬁcient for such policies. Even
after privileges are dropped such a policy may not be en-
forced if there is a buffer overﬂow or other type-safety
violation.
Privilege separated ping is also useful for securing a site
that wishes to limit internal ICMP messages. ICMP mes-
sages are commonly used for covert communication in
hacker tools [10]. The normal solution is to use a ﬁrewall
that disallows ping requests. However, this approach
does not let legitimate internal ping clients ping outside
hosts.
Using privilege separation we divide ping into the mon-
itor and slave. The slave is ran on each internal host,
while a single monitor can run from a trusted “ping host”.
While there are other ways to accomplish the same ob-
jective, privilege separation gives a new alternative. Cir-
cumstances may make such alternatives attractive.
The privilege separated version of ping is created by
the user adding 1 annotation to the original source.
It
took approximately 1.5 hours from downloading
the ping source to place the proper annotation.
31
call site are automatically changed to use the moni-
tor: 1 socket, 21 setsockopt, 1 getsockopt, 2
ioctl, 1 sendmsg, 2 recvmsg, 1 poll, 1 getuid,
and 1 bind. Privtrans comes with all 14 wrapper func-
tions.
4.5 OpenSSL
Integrating privilege separation into OpenSSL adds new
avenues for securing a site. Many sites may wish to reuse
certiﬁcates for multiple services since certiﬁcates are of-
ten expensive and are unique to a host, not a service. For
example, a small business may want to use the same SSL
certiﬁcate for both a web-server and an IMAP server.
The main drawback for using one certiﬁcate for multiple
services is that a compromise in any service will reveal
the private keys for all services.
In this experiment we add privilege separation into
OpenSSL, so that many SSL services (i.e. slave’s) will
all use the same monitor to perform privileged RSA pri-
vate key operations. Thus, trust is only given to one
server, the monitor, while multiple services can use the
certiﬁcate.
that
key:
one
added
2
annotations
the
required
for
private
and
RSA private encrypt
It
the RSA op-
We
one
erations
for
for
RSA private decrypt.
took approximately
20 minutes to ﬁnd the correct place to add annotations.
Privtrans then rewrites the library so these two functions
will be executed in a monitor, while everything else will
be in the slave. 7 call sites were automatically changed
within the library. We then compiled and linked stun-
nel [17] against our OpenSSL library. stunnel encrypts
arbitrary TCP connections inside an SSL session. We
gave the monitor the private RSA key, and provided
stunnel with only the RSA public key. As a result, all
RSA decryptions needed during an SSL session were
done by the monitor instead of in stunnel.
Such overhead is unfortunately unavoidable unless the
ping source is rewritten. Alternatively, we could special-
ize the wrapper functions for ping to eliminate about half
of the overhead.
The overhead from privilege separation is often not a lim-
iting factor since cycles are cheap but secure software is
not.
4.6 Performance overhead
We ran experiments on an Intel P4 2.4 GhZ processor
with 1 GB of RAM running Linux 2.4.24. The base
overhead for a cross domain call (i.e. between a client
and server) vs. a local call is about 84% on our test ma-
chines. We could use techniques such as software-based
isolation [38], which can reduce the cost of a cross do-
main call by up to three orders of magnitude.
We performed several micro-benchmarks. In each micro-
benchmark we timed a system call done locally vs. the
same call via the appropriate privwrap wrapper. Our re-
sults show a performance penalty factor of 8.83 for a
socket call, 7.67 for an open call, 9.76 for a bind
call, and 2.17 for a listen call. The average time
difference between a local call and wrapper call is 19
µs vs. 88 µs. Our results compare favorably to Priv-
man [18], the only other implementation with compara-
ble wrapper functions. For instance, in Privman the cost
of an open call done via their library is about 19.6 times
slower, while our implementation only has a 7.67 perfor-
mance penalty. Other measurements are similarly about
the same or better than Privman.
We also performed macro-benchmarks for several appli-
cation tested.
thttpd was tested by measuring the av-
erage web-server response time over 1000 iterations to
download index.html. For ping, we tested the time dif-
ference between the unmodiﬁed program and the privi-
lege separation version when pinging localhost 15 times.
For OpenSSL, we asked the OpenSSL library to de-
crypt 1000 randomly generated (but constant through-
out the experiment) messages. The privileged separated
OpenSSL library has an additional 15% overhead, ping
has an additional 46%, and thttpd only suffered an addi-
tional 6% overhead.
The main cause of additional overhead in ping and
OpenSSL is transferring data between the slave and mon-
itor. With ping, for example, a 4K block of data is trans-
ferred twice each time a ping reply is received: once
when calling privwrap recvmsg from the slave to mon-
itor, and once on the return from the monitor to slave.
5 Discussion
In this section we discuss how our techniques work in
practice.
Automatic vs. Manual. Our approach leverages sound
dataﬂow analysis to rewrite generic applications. Al-
though possible, it is unlikely the automatic approach
will result in code with optimal performance. The rea-
son is in the manual approach the programmer is free to
use application-speciﬁc knowledge to ﬁne-tune (or even
rewrite!) the program for better performance.
However, our approach is much easier. Finding the an-
notation locations is very simple: the set of privileged
operations on a system is generally well known and easy
to spot. In addition, the result of missing an annotation
is the slave attempting to perform a privileged operation
without appropriate privileges. Thus, the programmer is
free to incrementally add annotations until the slave and
monitor perform correctly.
Our approach outputs human-readable C code, which al-
lows the programmer to inspect and debug the monitor
and slave easily. In our experience, it takes at most a few
hours to ﬁnd the proper places to add annotations.
Portability. Any platform that supports inter-process
communication will
likely be amenable to running
privilege-separated programs. Since we rewrite C source
code, the crux of our approach does not suffer portabil-
ity problems. Also, since we separate out privileged re-
sources and data derived from those resources, our ap-
proach typically does not require OS-dependent mecha-
nisms such as ﬁle-descriptor passing. For example, our
techniques and results should apply equally well to Mi-
crosoft Windows. In the future, we plan on applying our
approach to other operating systems, including Microsoft