5252
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:33 UTC from IEEE Xplore.  Restrictions apply. 
without accessing variables that are external to the ISA spec-
iﬁcation. This is not the case for timing attacks and power
consumption attacks. For this reason it is important to provide
methodologies to ﬁx the existing veriﬁcation efforts. We show
that for some of the existing countermeasures this task can
be reduced to checking relational observation equivalence. To
make this analysis practical, we adapted an existing tool [6]
to check the conditions that are sufﬁcient to prevent informa-
tion leakage due to the new cache-channels. In general, the
additional checks in the code veriﬁcation need to be comple-
mented by a correctness proof of a given countermeasure on
a suitable cache model. In particular it has to be shown that
memory coherency for the veriﬁed code is preserved by the
countermeasure and that an attacker cannot observe sensitive
information even if it can create non-cacheable aliases.
The attack presented in Section III-B raises particular con-
cerns, since it poses integrity threats that cannot be carried out
using timing channels. The possible victims of such an attack
are systems where the ownership of memory is transferred
from the untrusted agent to the trusted one and where the
trusted agent checks the content of this memory before using
it as parameter of a critical function. After that the ownership
is transferred, if the cache is not clean, the trusted agent may
validate stale input while the critical function uses different
data. The practice of transferring ownership between security
domains is usually employed to reduce memory copies and
is used for example by hypervisors that use direct paging,
run-time monitors that
inspect executable code to prevent
execution of malware, as well as reference monitors that
inspect the content of IP packets or validate requests for device
drivers.
There are several issues we leave out as future work. We
did not provide a mechanism to check the security of some
of the countermeasures like Cache Normalisation and we did
not apply the methodology that we described to a complete
software. Moreover, the channels that we identiﬁed probably
do not cover all the existing storage side channels. Branch
prediction, TLBs, sharebility attributes are all architectural
details that, if misconﬁgured, can lead to behaviours that are
inconsistent with the ISA speciﬁcation. If the adversary is
capable of conﬁguring these resources, like in virtualized en-
vironments, it is important to identify under which conditions
the trusted software preserves its security properties.
When changing the storage control bits in page table entries
the programmer is required to ﬂush the caches. This also hints
to the point that no hardware mechanisms are mandated to
handle unexpected cache hits.
Recently, several works successfully veriﬁed low level
execution platforms that provide trustworthy mechanisms to
isolate commodity software. In this context caches are mostly
excluded from the analysis. An exception is the work by
Barthe et al. [8] that provide an abstract model of cache
behaviour sufﬁcient to replicate various timing-based exploits
and countermeasures from the literature such as STEALTH-
MEM.
The veriﬁcation of seL4 assumes that caches are correctly
handled [29] and ignores timing channels. The bandwidth of
timing channels in seL4 and possible countermeasures were
examined by Cock et al [13]. While storage based channels
have not been addressed, integrity of the kernel seems in
practice to be preserved by the fact that system call arguments
are passed through registers only.
The VerisoftXT project targeted the veriﬁcation of Microsoft
Hyper V and a semantic stack was devised to underpin
the code veriﬁcation with the VCC tool [14]. Guests are
modelled as full x64 machines where caches cannot be made
transparent if the same address is accessed in cacheable and
uncacheable mode, however no implications on security have
been discussed. Since the hypervisor uses a shadow page
algorithm, where guest translations are concatenated with a
secure host translation, the integrity properties do not seem to
be jeopardised by any actions of the guest.
Similarly the Nova [45], [46] and CertiKOS [21] micro-
visors do not consider caches in their formal analysis, but
they use hardware which supports a second level address
translation which is controlled by the host and cannot be
affected by the guest. Nevertheless the CertiKOS system keeps
a partition management software in a separate partition that
can be contacted by other guests via IPC to request access to
resources. This IPC interface is clearly a possible target for
attacks using uncacheable aliases.
In any case all of the aforementioned systems seem to
be vulnerable to cache storage channel information leakage,
assuming they allow the guest systems to set up uncacheable
memory mappings. In order to be sound, any proof of informa-
tion ﬂow properties then needs to take the caches into account.
In this paper we show for the ﬁrst time how to conduct such
a non-interference proof that treats also possible data cache
storage channels.
VIII. CONCLUDING REMARKS
We presented novel cache based attack vectors that use
storage channels and we demonstrated their usage to threaten
integrity and conﬁdentiality of real software. To the best of
our knowledge, it is the ﬁrst time that cache-based storage
channels are demonstrated on commodity hardware.
The new attack vectors partially invalidate the results of
formal veriﬁcation performed at the ISA level. In fact, us-
ing storage-channels, the adversary can extract information
From a practical point of view, we focused our experiments
on exploiting the L1 cache. For example, to extract the secret
key of the AES service on Raspberry Pi 2 we have been
forced to ﬂush and clean the L2 cache. The reason is that
on this platform the L2 cache is shared with the GPU and
we have little to no knowledge about the memory accesses it
performs. On the other hand, shared L2 caches open to the
experimentation with concurrent attacks, where the attacker
can use a shader executed on the GPU. Similarly, here we only
treated cache channels on a single processor core. Nevertheless
the same channels can be built in a multi-core settings using
the shared caches (e.g. L2 on Raspberry Pi 2). The new vectors
can then be used to replicate known timing attacks on shared
5353
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:33 UTC from IEEE Xplore.  Restrictions apply. 
caches (e.g. [25]).
ACKNOWLEDGMENT
The authors would like to thank Didrik Lundberg for
supporting the development of the Raspberry Pi 2 prototypes.
Work partially supported by the PROSPER framework grant
from the Swedish Foundation for Strategic Research, by by the
Swedish Governmental Agency for Innovation Systems under
grant 2014-00702, and by the CERCES project funded by the
Swedish Civil Contingencies Agency.
REFERENCES
[1] ARM TrustZone.
technologies/trustzone.php.
http://www.arm.com/products/processors/
[2] O. Acıic¸mez and c. K. Koc¸. Trace-driven cache attacks on AES
(short paper).
In Proceedings of the 8th International Conference on
Information and Communications Security, ICICS’06, pages 112–121.
Springer-Verlag, 2006.
[3] J. Agat. Transforming out timing leaks.
In Proceedings of the 27th
Symposium on Principles of Programming Languages, POPL ’00, pages
40–53. ACM, 2000.
[4] E. Alkassar, M. A. Hillebrand, D. Leinenbach, N. Schirmer, A. Starostin,
and A. Tsyban. Balancing the load. J. Autom. Reasoning, 42(2-4):389–
454, 2009.
[5] A. M. Azab, P. Ning, J. Shah, Q. Chen, R. Bhutkar, G. Ganesh,
J. Ma, and W. Shen. Hypervision Across Worlds: Real-time Kernel
Protection from the ARM TrustZone Secure World. In Proceedings of
the Conference on Computer and Communications Security, CCS’14,
pages 90–102. ACM, 2014.
[6] M. Balliu, M. Dam, and R. Guanciale. Automating information ﬂow
analysis of low level code.
the Conference on
Computer and Communications Security, CCS’14, pages 1080–1091.
ACM, 2014.
In Proceedings of
[7] P. Barham, B. Dragovic, K. Fraser, S. Hand, T. Harris, A. Ho, R. Neuge-
bauer, I. Pratt, and A. Warﬁeld. Xen and the art of virtualization. ACM
Operating Systems Review, 37(5):164–177, 2003.
[8] G. Barthe, G. Betarte, J. D. Campo, J. M. Chimento, and C. Luna.
Formally veriﬁed implementation of an idealized model of virtualization.
In Proceedings of the 19th International Conference on Types for Proofs
and Programs, TYPES’13, pages 45–63, 2014.
[9] G. Bertoni, V. Zaccaria, L. Breveglieri, M. Monchiero, and G. Palermo.
AES power attack based on induced cache miss and countermeasure. In
Proceedings of the International Conference on Information Technology:
Coding and Computing, ITCC’05, pages 586–591. IEEE Computer
Society, 2005.
[10] S. Bratus, N. D’Cunha, E. Sparks, and S. W. Smith. TOCTOU, traps, and
trusted computing. In Proceedings of the 1st International Conference
on Trusted Computing and Trust in Information Technologies: Trusted
Computing - Challenges and Applications, Trust’08, pages 14–32.
Springer-Verlag, 2008.
[11] B. Brumley. Cache storage attacks. In Topics in Cryptology CT-RSA,
pages 22–34. 2015.
[12] H. Chfouka, H. Nemati, R. Guanciale, M. Dam, and P. Ekdahl. Trust-
worthy prevention of code injection in linux on embedded devices. In
Proceedings of the 20th European Symposium on Research in Computer
Security, ESORICS’15, pages 90–107. Springer, 2015.
[13] D. Cock, Q. Ge, T. Murray, and G. Heiser. The Last Mile: An Empirical
Study of Timing Channels on seL4. In Proceedings of the Conference
on Computer and Communications Security, CCS’14, pages 570–581.
ACM, 2014.
[14] E. Cohen, W. Paul, and S. Schmaltz. Theory of multi core hypervisor
veriﬁcation.
In 39th International Conference on Current Trends in
Theory and Practice of Computer Science, SOFSEM’2013, pages 1–27.
Springer, 2013.
[15] Cortex-A7 mpcore processors. http://infocenter.arm.com/help/index.jsp?
topic=/com.arm.doc.subset.cortexa.cortexa7.
http://infocenter.arm.com/help/topic/com.arm.
[16] Cortex-A8 processors.
doc.subset.cortexa.a8.
[17] J. Daemen and V. Rijmen. The design of Rijndael: AES-the advanced
encryption standard. Springer Science & Business Media, 2013.
[18] M. Dam, R. Guanciale, N. Khakpour, H. Nemati, and O. Schwarz.
Formal veriﬁcation of information ﬂow security for a simple ARM-
based separation kernel. In Proceedings of the Conference on Computer
and Communications Security, CCS’13, pages 223–234. ACM, 2013.
[19] L. Duﬂot, O. Levillain, B. Morin, and O. Grumelard. Getting into the
SMRAM: SMM reloaded. CanSecWest, 2009.
[20] M. M. Godfrey and M. Zulkernine. Preventing cache-based side-channel
attacks in a cloud environment. IEEE T. Cloud Computing, 2(4):395–
408, 2014.
[21] L. Gu, A. Vaynberg, B. Ford, Z. Shao, and D. Costanzo. CertiKOS:
a certiﬁed kernel for secure cloud computing.
In Proceedings of the
Second Asia-Paciﬁc Workshop on Systems, APSys’11, page 3. ACM,
2011.
[22] D. Gullasch, E. Bangerter, and S. Krenn. Cache games – bringing
access-based cache attacks on AES to practice.
In Proceedings of
the Symposium on Security and Privacy, SP’11, pages 490–505. IEEE
Computer Society, 2011.
[23] C. Heitmeyer, M. Archer, E. Leonard, and J. McLean. Applying formal
IEEE Trans. Softw.
methods to a certiﬁably secure software system.
Eng., 34(1):82–98, Jan. 2008.
[24] M. A. Hillebrand, T. I. der Rieden, and W. J. Paul. Dealing with i/o
devices in the context of pervasive system veriﬁcation. In Proceedings of
the International Conference on Computer Design: VLSI in Computers
and Processors, ICCD’05, pages 309–316. IEEE, 2005.
[25] M. S. Inci, B. G¨ulmezoglu, G. I. Apecechea, T. Eisenbarth, and B. Sunar.
Seriously, get off my cloud! cross-vm RSA key recovery in a public
cloud. IACR Cryptology ePrint Archive, 2015:898, 2015.
[26] Intel 64 and IA-32 Architectures Software Developer’s Manual. http:
//www.intel.com/content/dam/www/public/us/en/documents/manuals/
64-ia-32-architectures-software-developer-manual-325462.pdf.
[27] J. Kelsey, B. Schneier, D. Wagner, and C. Hall. Side channel crypt-
analysis of product ciphers. J. Comput. Secur., 8(2,3):141–158, Aug.
2000.
[28] T. Kim, M. Peinado, and G. Mainar-Ruiz. STEALTHMEM: System-
level protection against cache-based side channel attacks in the cloud.
In USENIX, pages 189–204, 2012.
[29] G. Klein, J. Andronick, K. Elphinstone, T. C. Murray, T. Sewell,
R. Kolanski, and G. Heiser. Comprehensive formal veriﬁcation of an
OS microkernel. ACM Trans. Comput. Syst., 32(1):2, 2014.
[30] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell,
H. Tuch, and S. Winwood. seL4: Formal Veriﬁcation of an OS Kernel.
In Proceedings of the 22nd Symposium on Operating Systems Principles,
SOSP’09, pages 207–220. ACM, 2009.
[31] P. C. Kocher. Timing attacks on implementations of Difﬁe-Hellman,
RSA, DSS, and other systems. In Proceedings of the 16th Annual Inter-
national Cryptology Conference on Advances in Cryptology, CRYPTO
’96, pages 104–113. Springer-Verlag, 1996.
[32] D. Leinenbach and T. Santen. Verifying the microsoft hyper-v hypervisor
In Proceedings of the 2Nd World Congress on Formal
with VCC.
Methods, FM ’09, pages 806–809. Springer-Verlag, 2009.
[33] H. Nemati, R. Guanciale, and M. Dam. Trustworthy virtualization of
the armv7 memory subsystem. In Proceedings of the 41st International
Conference on Current Trends in Theory and Practice of Computer
Science, SOFSEM’15, pages 578–589. Springer, 2015.
[34] M. Neve and J.-P. Seifert. Advances on access-driven cache attacks on
AES. In Proceedings of the 13th International Conference on Selected
Areas in Cryptography, SAC’06, pages 147–162. Springer-Verlag, 2007.
[35] OpenSSL. https://www.openssl.org.
[36] D. Page. Theoretical use of cache memory as a cryptanalytic side-
channel. IACR Cryptology ePrint Archive, 2002:169, 2002.
[37] C. Percival. Cache missing for fun and proﬁt. BSDCan, 2005.
[38] Power ISA version 2.07. https://www.power.org/wp-content/uploads/
2013/05/PowerISA V2.07 PUBLIC.pdf.
[39] N. Qu, X. Gou, and X. Cheng. Using uncacheable memory to improve
unity linux performance. In Proceedings of the 6th Annual Workshop on
the Interaction between Operating Systems and Computer Architecture,
pages 27–32, 2005.
[40] H. Raj, R. Nathuji, A. Singh, and P. England. Resource management
for isolation enhanced cloud services. In Proceedings of the Workshop
on Cloud Computing Security, CCSW ’09, pages 77–84. ACM, 2009.
[41] R. Richards. Modeling and security analysis of a commercial real-time
operating system kernel. In D. S. Hardin, editor, Design and Veriﬁcation
5454
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:33 UTC from IEEE Xplore.  Restrictions apply. 
of Microprocessor Systems for High-Assurance Applications, pages 301–
322. Springer US, 2010.
[42] Raspberry Pi 2 Model B.
https://www.raspberrypi.org/products/
raspberry-pi-2-model-b/.
[43] S. M. Silver.
Implementation and analysis of software based fault
isolation. Technical Report PCS-TR96-287, Dartmouth College, 1996.
[44] D. Stefan, P. Buiras, E. Yang, A. Levy, D. Terei, A. Russo, and
D. Mazires. Eliminating cache-based timing attacks with instruction-
based scheduling. In Proceedings of the 18th European Symposium on
Research in Computer Security, ESORICS’13, pages 718–735. Springer,
2013.
[45] U. Steinberg and B. Kauer. NOVA: A microhypervisor-based secure vir-
tualization architecture. In Proceedings of the 5th European Conference
on Computer Systems, EuroSys ’10, pages 209–222. ACM, 2010.
[46] H. Tews, M. V¨olp, and T. Weber. Formal memory models for the
veriﬁcation of low-level operating-system code. J. Autom. Reasoning,
42(2-4):189–227, 2009.
[47] E. Tromer, D. A. Osvik, and A. Shamir. Efﬁcient cache attacks on AES,
and countermeasures. J. Cryptol., 23(2):37–71, Jan. 2010.
[48] Y. Tsunoo, T. Saito, T. Suzaki, and M. Shigeri. Cryptanalysis of DES
implemented on computers with cache. In Proceedings of the Workshop
on Cryptographic Hardware and Embedded Systems, CHES’03, LNCS,
pages 62–76. Springer, 2003.
[49] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. Efﬁcient
software-based fault isolation. SIGOPS Oper. Syst. Rev., 27(5):203–216,
Dec. 1993.
[50] R. N. M. Watson. Exploiting concurrency vulnerabilities in system call
wrappers. In Proceedings of the First USENIX Workshop on Offensive
Technologies, WOOT’07, pages 2:1–2:8. USENIX Association, 2007.
[51] M. Weiß, B. Heinz, and F. Stumpf. Proceedings of the 16th international
conference on ﬁnancial cryptography and data security. FC’2012, pages
314–328. Springer, 2012.
[52] R. Wojtczuk and J. Rutkowska. Attacking SMM memory via intel cpu
cache poisoning. Invisible Things Lab, 2009.
[53] wolfSSL: Embedded SSL Library. https://www.wolfssl.com/wolfSSL/
Home.html.
[54] D. Zhang, A. Askarov, and A. C. Myers. Language-based control and
mitigation of timing channels. In Proceedings of the 33rd Conference on
Programming Language Design and Implementation, PLDI ’12, pages
99–110. ACM, 2012.
[55] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. Cross-vm side
channels and their use to extract private keys.
In Proceedings of the
Conference on Computer and Communications Security, CCS ’12, pages
305–316. ACM, 2012.
[56] X.-J. Zhao and T. Wang.
CLEFIA by considering cache miss and S-box misalignment.
Cryptology ePrint Archive, 2010:56, 2010.
Improved cache trace attack on AES and
IACR
5555
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:33 UTC from IEEE Xplore.  Restrictions apply.