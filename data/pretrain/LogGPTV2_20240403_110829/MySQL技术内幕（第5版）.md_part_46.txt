一
?
运算符可以把它两边的操作数当
NULL
若a不匹配b，则结果为真
NULL
则结果为真
因此模式'Frank%能够匹配
含义
---
## Page 195
能匹配成功：
时，模式匹配成功。而对于形如^pattern$的模式，
配1个或多个其前面的字符，！
字符：
符范围的含义变反
示例演示了几种比较常用的正则表达式模式字符。
以取消其特殊含义：
'burnt'相匹配。
和'Albert'相匹配。模式‘%bert%除了可以与刚才这些字符串相匹配之外，还能匹配
（因为“_”可以自我匹配）相匹配。
与任何恰好包含有3个字符的字符串相匹配。例如，"c_t‘将与'cat'、'cot'、
如果想匹配字符“%”或“”本身，则需要在其前面加上反斜线字符（即“\%”或“\_")，
通配符可以指定在模式里的任何位置。
'abc' REGEXP b
形如^pattern'和'patternS"的模式表示的是：
这里的“任意个”包括0个，而这也正是上面第二个表达式会匹配成功的原因。如果要匹
星号
'abc'REGEXP
连接号“-”可用于指定字符范围，其两端分别为范围的起始和结束字符。如果要把这个字
方括号““...]”，可以匹配列在方括号内部的任何字符：
点号字符“.”是一个可以匹配任何单个字符的通配符：
MySQL的另一种模式匹配形式是使用正则表达式。运算符为REGEXP，而非LIKE。下面的
LIKE运算符的另一个通配符是下划线“_”，它可以匹配任何单个字符。因此，模式"
'abc'REGEXP
abc'REGEXP[0-9][0-9]*
'abc'
'abc'REGEXP'a.c'
'abc'
这种行为与标准 SQL的LIKE运算符有所差异，即在标准 SQL 里是区分大小写的。
'frankly"
BINARYfrankly'LIKE'Frank%
abcd'REGEXP
abc'
abc'
e'REGEXP
a_c'
abc'
abc
abc
Frankly'
BINARY
'frankly'LIKE'Frank%
REGEXP
“*”表示“匹配任意个其前面的字符”。例如，模式‘x*将匹配任意个数的“x”
REGEXP
LIKE
LIKE
REGEXP
LIKE
LIKE
'Frankly'LIKE
'a\_c'
'a%c'
[aeiou]
"a_c'
[
（负号）
第3章数据类型
&&
/DIV
>>
运算符优先级
REGEXP'~abc$'
COLLATE
5
(按位求反)
MOD
>
1=
>=
IN
IIS LIKE REGEXP RLIKE
→NULL
→NULL
→NULL
→-0.6000
→6.2000
+
9
0
0
否则其结果皆为 NULL：
---
## Page 197
先把它们转换成字符串，然后再返回连接后的结果：
然后表达式的计算结果为3。
的某一个进行类型转换，以使它们的类型一致。但是，应该转换哪一个呢？在本例里，+是一个
由于这两个操作数的类型不一致（一个是数字，另一个是字符串），因此MySQL会对它们当中
构成：
换为字符串，总是会得到一个二进制串。）
时，转换结果才会是一个二进制串；否则，结果为非二进制串。（在MySQL5.5.3之前，数字转
符集和排序规则,将数字转换成字符串或时态值。只有character_set_connection为 binary
型转换。发生类型转换的场合有以下几种。
3.5.2
序时，会出现在最后面。
将为 NULL，而不是真值或假值。
另外，STRCMP（）期望的是非 NULL 参数；如果把 NULL 作为参数传递给它，那么它返回的结果
的函数例外。例如，IFNULL（）便可以处理NULL参数，并且会根据具体情况返回真值或假值。
运算符、IS NULL 和 IS NOT NULL 例外，因为它们都是专门用于处理 NULL 值的：
下面来看另一个示例。CONCAT（）函数能够把多个字符串连接成一个更长的字符串。不管参
1+*2
下面这个表达式涉及一个隐式类型转换。它由一个加法运算符（+）和两个操作数（1和+2")
只要某个值的类型与上下文所要求的类型不相符，MySQL就会根据操作的类型自动进行类
在排序运算中，NULL值会一起排序。当按升序排序时，它们会出现在最前面；当以降序排
REPEAT（'X',CONCAT（1,2,3)/10）
请看下面这个表达式及其结果：
如果对CONCAT（）函数的调用又属于某个更大的表达式，那么可能会发生进一步的类型转
CONCAT(1,23,456)
可以根据系统变量character_set_connection和collation_connection所指定的字
口把操作数转换成适合运算符计算的相应类型。
当把NULL用作函数参数时，函数通常会返回NULL。不过，那些专门用于处理NULL参数
NULL LIKE%
1=NULL
当把NULL用作比较运算符或模式匹配运算符的操作数时，其计算结果皆为NULL，不过，
另
口把函数参数转换成函数所期望的类型。
NULL IS NULL
NULL
NULL REGEXP
一
品外，还可以利用类型转换运算符或函数来完成显式类型转换。
把某个值转换成适合于存储在列里的另一种类型。
IS
NULL
ORNULL
类型转换
NULL
NULL
!.*!
XXXXXXXXXXXX：
→123456
→3
↑
→NULL
3.5表达式计算和类型转换
↑
←
1
NULL
TION
NULL
NULL
---
## Page 198
是把它当成数字。
示例所示：
符串上下文里，每两个十六进制数字会被转换成一个字符，最终结果将为一个字符串，如下列
会被转换（通过四舍五入）。反之亦可，整数可以毫无问题地当作浮点数来使用。
把此类问题当作错误报告出来。更多相关细节请参考3.3节。
何值都可以处理成字符串，因此把一个值转换成字符串，在通常情况下都不会有问题。
个值（如字符串‘abc+）转换为数字类型，那么最终得到的结果将为0。如果某个看起来并不像
看起来并不像目标类型的合法值，那么这个转换就是失败的。例如，把看起来并不像数字的某
根据具体上下文的不同，MySQL会让值在三种通用类别（即数字、字符串、日期/时间）之
字符串，多
数为二进制串，那么其结果将是一个二进制串。其中，数字参数会像前面所讨论的那样转换为
相除是一个算术运算符。此表达式的结果为12.3。由于REPEAT（）函数需要的重复次数是一个
整
178
MySQL还会执行某些微小的类型转换。如果在整数上下文中使用浮点数值，那么浮点数值
日期或时间的值转换为日期或时间类型，那么最终得到的结果将为该类型的“零”值。例如，
生行转换。不过，值并不是总能从一种类型转换成另外一种类型。如果某个值在类型转换后，
请记任
如果CONCAT（）的所有参数都是非二进制串，那么其结果也将是一个非二进制串。如果有参
数，所以这个结果会四舍五人为整数12。最后，REPEAT（'X"，12)会把字符'X'重复12次。
对于比较操作中的十六进制常量，上下文会根据具体情况来确定是把它当成二进制串，还
除非上下文明确地表明需要一个数字，否则十六进制常量会被当作二进制串来对待。在字
在数据输入操作期间，为防止把非法值转换成最相近的合法值，可以启用严格模式，以便
口下面的表达式执行的是二进制串的比较。
口下面的表达式比较的是一个十六进制常量和一个数字，因此为了进行比较，该常量会
口下面的表达式会把操作数当作二进制串，并按字节进行比较。
CONCAT(X'61
CONCAT(X'61')
CONCAT(0x61
CONCAT(0x61)
X'61'
0x61+0
0x61