title:Runtime verification of authorization hook placement for the linux
security modules framework
author:Antony Edwards and
Trent Jaeger and
Xiaolan Zhang
Runtime Veriﬁcation of Authorization Hook Placement for
the Linux Security Modules Framework
Antony Edwards
Trent Jaeger
Xiaolan Zhang
PI:EMAIL
PI:EMAIL
PI:EMAIL
IBM T.J. Watson Research Center
Hawthorne, NY 10532
ABSTRACT
We present runtime tools to assist the Linux community in verify-
ing the correctness of the Linux Security Modules (LSM) frame-
work. The LSM framework consists of a set of authorization hooks
inserted into the Linux kernel to enable additional authorizations
to be performed (e.g., for mandatory access control). When com-
pared to system call interposition, authorization within the kernel
has both security and performance advantages, but it is more dif-
ﬁcult to verify that placement of the LSM hooks ensures that all
the kernel’s security-sensitive operations are authorized. We have
examined both static and runtime analysis techniques for this veri-
ﬁcation, and have found them to be complementary. Static analysis
is more complex to implement and tends to generate more false
positives, but coverage of all type-safe execution paths is possible.
Runtime analysis lacks the code and input coverage of static anal-
ysis, but tends to be simpler to gather useful information. The ma-
jor simplifying factor in our runtime veriﬁcation approach is that
we can leverage the fact that most of the LSM hooks are prop-
erly placed to identify misplaced hooks. Our runtime veriﬁcation
tools collect the current LSM authorizations and ﬁnd inconsisten-
cies in these authorizations. We describe our approach for perform-
ing runtime veriﬁcation, the design of the tools that implement this
approach, and the anomalous situations found in an LSM-patched
Linux 2.4.16 kernel.
Categories and Subject Descriptors
D.2.9 [Software Engineering]: Management—conﬁguration man-
agement; D.4.6 [Operating Systems]: Security and Protection—
access controls; K.6.5 [Management of Computing and Infor-
mation Systems]: Security and Protection—unauthorized access
General Terms
Security, Management, Languages
1.
INTRODUCTION
The Linux Security Modules (LSM) project aims to provide a
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’02, November 18-22, 2002, Washington, D.C., USA.
Copyright 2002 ACM 1-58113-612-9/02/0011 ...$5.00.
generic framework from which a wide variety of authorization mech-
anisms and policies can be enforced. Such a framework would en-
able developers to implement authorization modules of their choos-
ing for the Linux kernel. System administrators can then select the
module that best enforces their system’s security policy. For ex-
ample, modules that implement mandatory access control (MAC)
policies to enable containment of compromised system services are
under development.
The LSM framework is a set of authorization hooks inserted into
the Linux kernel. These hooks deﬁne the types of authorizations
that a module can enforce and their locations. Placing the hooks
in the kernel itself rather than at the system call boundary has se-
curity and performance advantages. First, placing hooks where the
operations are implemented ensures that the authorized objects are
the only ones used. For example, system call interposition is sus-
ceptible to time-of-check-to-time-of-use (TOCTTOU) attacks [2],
where another object is swapped for the authorized object after au-
thorization, because the kernel does not necessarily use the object
authorized by interposition. Second, since the authorizations are at
the point of the operation, there is no need to redundantly transform
system call arguments to authorize kernel objects.
While placing the authorization hooks in the kernel can improve
security, it is more difﬁcult to determine whether the hooks mediate
and authorize all controlled operations. The system call interface is
a nice mediation point because all the kernel’s controlled operations
(i.e., operations that access security-sensitive data) must eventually
go through this interface. Inside the kernel, there is no obvious ana-
logue for the system call interface. Any kernel function can contain
accesses to one or more security-sensitive data structures. Thus,
any mediation interface is at a lower-level of abstraction (e.g., in-
ode member access). In addition to mediation, it is also necessary
to ensure that the proper access control policy (e.g., write data) is
enforced for each security-sensitive operation.
If there is a mis-
match between the policy enforced and the controlled operations
that are executed under that policy, unauthorized operations can be
executed. We believe that manual veriﬁcation of the correct autho-
rization of a low-level mediation interface is impractical.
Much recent effort has focused on how static analysis tools may
aid in the veriﬁcation of various security properties [5, 12, 15]. As
is the trend now, we expect that static analysis will be used where
possible, and runtime analysis will be used to complete the analy-
sis 1. Thus, we are proceeding with the development of both static
and runtime veriﬁcation tools, and have found that static and run-
time analysis have complementary features. Our static analysis ap-
proach enables comprehensive veriﬁcation that the variables used
1Consider the static checking of type-safe C code where possible
and the runtime checking of other code used by Ccured [14].
225in security-sensitive operations have been authorized [18]. How-
ever, it is difﬁcult to statically determine the authorization require-
ments that should be checked. This is because different data and
control ﬂows within functions may require different authorizations.
One insight that we found useful is that many LSM authorization
hooks are correctly placed, so inconsistencies in authorization re-
quirements is often indicative of a problem. We built tools to enable
users to ﬁnd such inconsistencies and examine a wide variety of re-
lationships in the runtime data to ﬁnd problems.
In this paper, we present a runtime veriﬁcation approach and
tools to assist the LSM community and Linux kernel developers
in verifying that the LSM authorization hooks completely autho-
rize accesses. The runtime analysis approach involves: (1) instru-
menting the Linux kernel to collect security relevant runtime events
(e.g., major kernel events, such as system calls, LSM authoriza-
tions, and controlled operations) and (2) analyzing the collected
data to identify potential errors. First, we extend GCC to perform
analyses of its abstract syntax tree to add the necessary instrumen-
tation to the Linux kernel. We have built kernel modules to collect
the runtime events generated by the instrumentation. Second, we
have designed a ﬁltering language that enables the extraction of
runtime events of interest for analysis. We have used this language
to locate inconsistencies in authorizations for similar cases. Our
analysis tools generate two different representations that we used to
ﬁnd inconsistencies: (1) authorization graphs that display the con-
sistency between the execution of a controlled operations and its
authorizations, and (2) sensitivity class lists that show the attributes
of controlled operations to which the authorization consistency is
sensitive. Using this approach, we have found three bugs in LSM
hook placement in the ﬁle system that have since been ﬁxed, and
another anomaly that resulted in signiﬁcant discussion. While the
approach we use at present is not complete (i.e., some bugs may be
missed), we are encouraged by our ability to ﬁnd bugs using these
tools. We demonstrate the use of these tools on a LSM-patched
Linux kernel version 2.4.16.
The remainder of the paper is structured as follows. In Section 2,
we deﬁne the general hook placement problem. In Section 3, we
develop an approach to solving the general hook placement prob-
lem. In Section 4, we outline the implementation of the tools and
discuss the analyses performed and their results. In Section 5, we
conclude and describe future work.
2. GENERAL HOOK PLACEMENT PROB-
LEMS
2.1 Concepts
We identify the following key concepts in the construction of an
authorization framework:
(cid:15) Security-sensitive Operations: These are the operations that
impact the security of the system.
(cid:15) Controlled Operations: A subset of security-sensitive oper-
ations that mediate access to all other security-sensitive op-
erations. These operations deﬁne a mediation interface.
(cid:15) Authorization Hooks: These are the authorization checks in
the system (e.g., the LSM-patched Linux kernel).
(cid:15) Policy Operations: These are the conceptual operations au-
thorized by the authorization hooks.
Correct authorization hook placement must ensure that the au-
thorization hooks authorize all security-sensitive operations. Such
authorization tests whether the system’s authorization policy per-
mits the requesting principal to execute the particular security-
sensitive operations. It is more convenient to express authorization
policy at a higher level (e.g., ﬁle read or write), so rather than au-
thorizing the individual security-sensitive operations we authorize
conceptual operations, which we call policy operations. Further,
since the number of security-sensitive operations can be large, it is
preferable to authorize them once at an interface that mediates all
the security-sensitive operations. The set of controlled operations
deﬁnes such a mediation interface. Thus, we deﬁne our problem to
verify that all controlled operations are authorized for the expected
policy operations using the LSM authorization hooks.
Identifying the controlled operations is more difﬁcult for the in-
kernel mediation of LSM than for the system call mediation mech-
anisms of the past. As shown in Figure 1, the system call interface
is well-known for providing mediation of all the security-sensitive
operations in the system call. Therefore, the system call interface
can be used both as the controlled operations and the policy opera-
tions.
When authorization hooks are inserted in the kernel, a media-
tion interface is no longer obvious, so the controlled operations and
their mapping to policy operations is no longer so easy to identify.
For example, rather than verifying ﬁle open for write access at the
system call interface, the LSM authorizations for directory (exec),
link (follow link), and ultimately, the ﬁle (write) are performed at
the time these operations are to be done. This approach has the
beneﬁts of eliminating susceptibility to TOCTTOU attacks [2] and
redundant authorization processing, but in order to verify the hook
placement more work is necessary to identify the controlled opera-
tions, the policy operations they correspond to, and verify that the
authorization hooks authorize them properly.
2.2 Relationships to Verify
Figure 2 shows the relationships between the concepts.
1. Identify Controlled Operations: Find the set of operations
that deﬁne a mediation interface through which all security-
sensitive operations are accessed.
2. Determine Authorization Requirements: For each con-
trolled operation, identify the authorization requirements (i.e.,
policy) that must be authorized by the LSM hooks.
3. Verify Complete Authorization: For each controlled oper-
ation, verify that the correct authorization requirements are
authorized by LSM hooks.
4. Verify Hook Placement Clarity: Controlled operations im-
plementing a policy operation should be easily identiﬁable
from their authorization hooks. Otherwise, even trivial
changes to the source may render a hook inoperable.
The basic idea is that we identify the controlled operations and
their authorization requirements, then we verify that the authoriza-
tion hooks mediate those controlled operations properly. First, we
need an approach to ﬁnd the controlled operations in the kernel.
Second, because the controlled operations are at a lower level than
the policy operations (i.e., authorization requirements), we need
an approach by which the authorization requirements of each con-
trolled operation can be determined. Third, we need to compare
the LSM hook authorizations made to the expected authorization
requirements. These tasks are complex for in-kernel authorization,
so it is obvious that automated support is required.
Lastly, to ensure maintainability of the authorization hooks we
must verify that the controlled operations representative of each
226System Call Approach
LSM Approach
User
Syscall Trap
H
P/C
Kernel
H: Authorization Hook
P: Policy Operation
C: Controlled
    Operation
S: Security-sensitive
    Operation
...
...
H
P
C
C
S
S
S
...
S
S
S
...
Figure 1: Comparison of concepts between system call interposition framework and LSM.
Authorization Hook
Predicts
4
Policy Operation
Mediates
3
Comprises
2
Controlled Operation
Mediates
1
Security-sensitive Operation
Figure 2: Relationships between the authorization concepts.
The veriﬁcation problems are to: (1) identify controlled op-
erations; (2) determine authorization requirements; (3) verify
complete authorization; and (4) verify hook placement clarity.
policy operation can be easily determined from the authorization
hook locations. This work has been done, but in interest of focus
it is outside the scope of this paper. This is work is presented else-
where [4].
2.3 Related Work
Recently, static analysis to verify security properties has shown
promise. First, existing program analysis tools have been used to
ﬁnd common security errors, such as buffer overﬂows and printf
vulnerabilities [12, 15, 17]. Second, specialized tools have been
developed for ﬁnding security vulnerabilities, such as xgcc [5],
ITS4/RATS [16], and MOPS [3].
Program analysis tools are based on formal properties of pro-
gramming languages, so they are can be used for complete analysis
(i.e., no false negatives). However, program veriﬁcation is compu-
tationally expensive, so simpliﬁcations in these models can result
in conservative analyses (i.e., many false positives). Also, program