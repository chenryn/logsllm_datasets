INVD
使高速缓存无效，不回写（不必把数据写回到主内存）
WBINVD
使高速缓存无效，回写（需要把数据写回到主内存）
INVLPG
使TLB表项无效
LGDT
加载GDTR寄存器
LIDT
加载IDTR寄存器
LLDT
加载LDTR寄存器
LMSW
加载机器状态字（Machine Status Word），也就是CR0寄存器的0～15位
LTR
加载任务寄存器（TR）
MOV
to/from
CRn
读取或为控制寄存器赋值
MOV
to/from
DRn
读取或为调试寄存器赋值
MOV
to/from
TRn
读取或为测试寄存器赋值，386手册介绍了测试寄存器TR6和TR7，用来
测试TLB。最新的IA-32手册不再包含该内容
RDMSR
读MSR（Model-Specific Register）寄存器
WRMSR
写MSR（Model-Specific Register）寄存器
RDPMC
读性能监控计数器，CR4寄存器的PCE标志为1可以允许所有特权级的代
码都可以使用RDPMC指令
RDTSC
读时间戳计数器，CR4寄存器的TSD标志为0可以允许所有特权级的代码
都可以使用RDTSC指令
本节围绕任务保护这一主题，介绍了保护模式的基本概念和实现保
护的基本机制，包括特权级别和特权指令，这些机制对系统的安全运行
起着重要作用。下面我们将介绍保护模式下的内存管理。
2.6 段机制
内存是计算机系统的关键资源，程序必须被加载到内存中才可以被
CPU所执行。程序运行过程中，也要使用内存来记录数据和动态的信
息。在一个多任务系统中，每个任务都需要使用内存资源，因此系统需
要有一套机制来隔离不同任务所使用的内存。要使这种隔离既安全又高
效，那么硬件一级的支持是必需的。IA-32 CPU提供了多种内存管理机
制，这些机制为操作系统实现内存管理功能提供了硬件基础。
很多软件问题都是与内存有关的，深刻理解内存的使用规则对于软
件调试是很重要的。本节和2.7节将分别介绍IA-32 CPU的两种内存管理
机制：段机制和页机制。
CPU的段机制（segmentation）提供了一种手段可以将系统的内存
空间划分为一个个较小的受保护区域，其中每个区域称为一个段
（segment）。每个段都有自己的起始地址（基地址）、边界（limit）
和访问权限等属性。实现段机制的一个重要数据结构便是段描述符
（segment descriptor）。
2.6.1 段描述符
在保护模式下每个内存段都有一个段描述符，这是其他代码访问该
段的基本条件。每个段描述符是一个8字节长的数据结构，用来描述一
个段的位置、大小、访问控制和状态等信息。段描述符的通用格式如图
2-6所示。
图2-6 段描述符的通用格式
段描述符最基本的内容是这个段的基地址和边界。基地址是以4个
字节表示的（字节2、3、4和7），它可以是4GB线性地址空间中的任意
地址（00000000～0xFFFFFFFF）。边界是用20个比特位表示的（字节
0、1和字节6的低4位），其单位由粒度（Granularity）位（字节6的最高
位）决定，当G=0时，段边界的单位是1字节，当G＝1时是4KB。因此
一个段的最大边界值是（220−1），最大长度是220×4KB=4GB。表2-4介
绍了段描述符的其他各个域的含义。
表2-4 段描述符的各个域及其含义
域简
称
全  程
含  义
S
系统
（System）
S=0代表该描述符描述的是一个系统段，S=1代表该描述符描述
的是代码段、数据段或堆栈段
P
存在
（Present）
该位代表被描述的段是否在内存中，P=1表示该段已经在内存
中，P=0表示该段不在内存中。内存管理软件可以使用该位来控
制将哪些段实际加载到物理内存中。这为虚拟内存管理提供了页
机制之外的另一种方法。事实上，最早支持保护模式的286 CPU
就没有分页机制
DPL
描述符特权
级
（Descriptor
Privilege
Level）
这两位定义了该段的特权级别（0～3），简单来说，仅当要访问
该段的程序的特权级别（称为CPL）等于或高于这个段的级别时
CPU才允许其访问，否则便会产生保护性异常（GPF）
D/B
Default/Big
对于代码段，该位表示的是这个代码段的默认位数（Default
Bit）。D=0表示16位代码段，D=1表示32位代码段* 对于栈数据
段，该位被称为B（Big）标志，B=1表示使用32位的堆栈指针
（保存在ESP中），B=0表示使用16位堆栈指针（保存在SP中）
Type 段类型
位0简称A位，表示该段是否被访问过（accessed），A=1表示被
访问过 ● 对于数据/堆栈段，位2是扩展方向位，简称
E（Expand）位，E=0表示向高端扩展，反之为1；位1是读写控
制位简称W（Write）位，W=0表示该段只可以读，W=1表示可
以读写 ● 对于代码段，位2表示该段是否是一致
（Conforming）代码段，简称C位。位1表示该段是否可读
（Read），简称R位，R=1表示该段既可以执行，又可以读；
R=0表示该段只可以执行，不可以读 位3是D/C位，决定了该段
是数据/堆栈段（Data/stack）（C/D=0）还是代码段（Code）
（C/D=1）
L
64-bit代码
段
用于描述IA-32e模式下的代码段，L=1表示代码段包含的是64位
代码，L=0表示该段包含的兼容模式的代码
AVL
Available
and reserved
bits
供系统软件（操作系统）使用
*默认代码长度属性定义的是默认的地址和操作数长度，可以用地
址大小前缀和操作数大小前缀改变默认长度。
值得说明的是，对于向下扩展（Expand-Down）的栈数据段，段边
界指定的是该段的最小偏移，B标志用来指定偏移的最大有效值（即上
边界），当B=1时，最大偏移是0xFFFFFFFF，这样，如果Limit=0，那
么段的总长度便是4GB（G=0），如果B=0，那么上边界便是0xFFFF。
2.6.2 描述符表
在一个多任务系统中通常会同时存在着很多个任务，每个任务会涉
及多个段，每个段都需要一个段描述符，因此系统中会有很多段描述
符，为了便于管理，系统用线性表来存放段描述符。根据用途不同，
IA-32处理器有3种描述符表：全局描述符表（Global Descriptor Table，
GDT）、局部描述符表（Local Descriptor Table，LDT）和中断描述符
表（Interrupt Descriptor Table，IDT）。
GDT 是全局的，一个系统中通常只有一个GDT，供系统中的所有
程序和任务使用。LDT与任务相关，每个任务可以有一个LDT，也可以
让多个任务共享一个LDT。IDT的数量是和处理器的数量相关的，系统
通常会为每个CPU建立一个IDT。
GDTR和IDTR寄存器分别用来标识GDT和IDT的基地址和边界。这
两个寄存器的格式是相同的，在32位模式下，长度是48位，高32位是基
地址，低16位是边界；在IA-32e模式下，长度是80位，高64位是基地
址，低16位是边界。
LGDT和SGDT指令分别用来读取和设置GDTR寄存器。LIDT和
SIDT指令分别用来读取和设置IDTR寄存器。操作系统在启动初期会建
立GDT和IDT并初始化GDTR和IDTR寄存器。
位于GDT中第一个表项（0号）的描述符保留不用，称为空描述符
（null descriptor）。当把指向空描述符的段选择子加载到段寄存器时不
会产生异常。
当创建LDT时，GDT已经准备好，因此，LDT被创建为一种特殊的
系统段，其段描述符被放在GDT表中。GDT表本身只是一个数据结构，
没有对应的段描述符。
使用WinDBG的r命令可以观察GDTR和IDTR寄存器的值，因为它
们是48位的，所以应该分两次，分别读取它们的基地址和边界：
kd> r gdtr
gdtr=8003f000
kd> r idtr
idtr=8003f400
kd> r gdtl
gdtl=000003ff 
kd> r idtl
idtl=000007ff
从上面的gdtl值可以看出这个GDT的边界是1023，总长度是1024字
节（1KB），共有128个表项。IDT的长度是2KB，共有256个表项。
2.6.3 段选择子
局部描述符表寄存器LDTR表示当前任务的LDT在GDT中的索引，
其格式是典型的段选择子格式（见图2-7）。
图2-7 段选择子
段选择子的TI位代表要索引的段描述符表（table indicator），TI=0
表示全局描述符表，TI=1表示局部描述符表。
段选择子的高13位是描述符索引，即要选择的段描述符在TI所表示
的段描述符表中的索引号。因为这里使用的是13位，意味着最多可索引
213 = 8192个描述符，所以GDT和LDT的最大表项数都是8192。因为x86
CPU最多支持256个中断向量，所以IDT表的最多表项数是256。
段选择子的低两位表示的是请求特权级（Requestor Privilege
Level，RPL），用于特权检查，详细介绍见下文。
任务状态段寄存器TR中存放的也是一个段选择子，指向的是全局
段描述表（GDT）中描述当前任务状态段（Task State Segmentation，
TSS）的段描述符。任务状态段是保存任务上下文信息的特殊段，其基
本长度是104字节，操作系统可以附加更多内容。TSS是实现任务切换
的重要数据结构。当进行任务切换时，处理器先把当前任务的执行现场
—— 包括CS:EIP在内的寄存器保存到TR所指定的TSS中，然后把指向
下一任务的TSS的选择子装入TR（使用LTR指令），接下来再从TSS中
把下一任务的寄存器信息加载到各个寄存器中，然后开始执行下一任
务。
除了LDTR和TR，在保护模式下所有段寄存器（CS、DS、ES、FS
和GS）中存放的也是段选择子，不再是实模式时的高16位基地址。
2.6.4 观察段寄存器
可以使用调试工具（WinDBG或Visual Studio）来观察段寄存器的
值，图2-8所示的是将记事本进程中断到调试器后所看到的情况。
图2-8 保护模式下的段寄存器内容示例
首先，很容易看出这些段寄存器指向的都是全局段描述表（GDT）
中的段描述符（TI=0），GS和FS的RPL是0，其他都是3。
可以使用WinDBG的dg命令来显示一个段选择子所指向的段描述符
的详细信息。例如，以下是将CS寄存器内的段选择子传递给dg命令而
显示出的结果：
0:002> dg 1b