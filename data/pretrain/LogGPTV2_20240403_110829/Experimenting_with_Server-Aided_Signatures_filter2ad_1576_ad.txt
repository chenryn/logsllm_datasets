any SEM with malformed requests which can cer-
tainly render a SEM unavailable to legitimate users.
• Unlike other mediated or multi-party signature
methods (such as mRSA or 2-party DSA), SAS
signatures are not compatible with any other basic
signature type. In other words, SAS signatures are
not transparent to veriﬁers. Therefore, all potential
veriﬁers must avail themselves of at least the SAS
veriﬁcation method.
• It is possible, but neither easy nor elegant, for
a user to switch among diﬀerent SEMs in SAS.
One way is to have multiple SAS certiﬁcates; one
for a distinct SEM. Another way is to use on-line
hand-over of a SAS certiﬁcate among two SEMs.
Neither solution is particularly attractive due to
the diﬃculty of replication of a statfule server. (In
mRSA [4], for example, a user can swich among
SEMs transparently, where SEM is stateless. )
• SAS involves on-going state retention for regular
users and SEMs. This burden is particularly heavy
for SEMs (users can oﬀ-load their state periodically)
since they must keep complete signature histories
for all users served.
Acknowledgements
We thank Dan Boneh for some useful discus-
sions, Ignacio Solis for early prototyping of the
SAS library and Yongdae Kim for comments on the
draft of this paper. We also gratefully acknowledge
the anonymous referees whose comments served to
greatly improve the ﬁnal version of this paper.
References
[1] M. Myers, R. Ankney, A. Malpani, S. Galperin,
and C. Adams, “RFC2560: Internet public key
infrastructure online certicate status protocol -
OCSP,” June 1999.
[2] N. Asokan, G. Tsudik,
and M. Waid-
ner, “Server-supported signatures,” Journal of
Computer Security, vol. 5, no. 1, 1997.
[3] R. C. Merkle, “A digital signature based on a
conventional encryption function,” in Advances
in Cryptology – CRYPTO ’87 (C. Pomerance,
ed.), no. 293 in Lecture Notes in Computer Sci-
ence, (Santa Barbara, CA, USA), pp. 369–378,
Springer-Verlag, Berlin Germany, Aug. 1988.
[4] D. Boneh, X. Ding, G. Tsudik, and B. Wong,
“Instanteneous revocation of security capabili-
ties,” in Proceeding of USENIX Security Sym-
posium 2001, Aug. 2001.
[5] P. MacKenzie and M. K. Reiter, “Networked
cryptographic devices resilient to capture,” in
Proceedings of the 2001 IEEE Symposium on
Security and Privacy, pp. 12–25, May 2001.
[6] P. MacKenzie and M. K. Reiter, “Two-party
generation of dsa signatures,” in Advances in
Cryptology – CRYPTO ’01 (J. Kilian, ed.),
no. 2139 in Lecture Notes in Computer Science,
pp. 137–154, Springer-Verlag, Berlin Germany,
Aug. 2001.
[7] R. Ganesan, “Argumenting kerberose with
pubic-key crytography,” in Symposium on
Network and Distributed Systems Security
(T. Mayﬁeld, ed.), (San Diego, California), In-
ternet Society, Feb. 1995.
[8] C. Boyd, “Digital mulitsignatures,” Cryptogra-
phy and Coding, pp. 241–246, 1989.
[9] Y. Desmedt and Y. Frankel, “Threshold
cryptosystems,” in Advances in Cryptology –
CRYPTO ’89 (G. Brassard, ed.), no. 435 in
Lecture Notes in Computer Science, (Santa
Barbara, CA, USA), pp. 307–315, Springer-
Verlag, Berlin Germany, Aug. 1990.
[10] O. Goldreich, “Secure multi-party computation
(working draft),” 1998.
[11] B. Schneier, Applied Cryptography: Protocols,
Algorithms, and Source Code in C. John Wiley
& Sons, Inc, 1996.
[12] L. Lamport, “Password authentication with
insecure communication,” Communications of
the ACM, vol. 24, pp. 770–772, Nov. 1981.
[13] R. L. Rivest, A. Shamir, and L. M. Adle-
man, “A method for obtaining digital signa-
tures and public-key cryptosystems,” Journal
of the ACM, vol. 21, pp. 120–126, Feb. 1978.
[14] M. Bellare, R. Canetti, and H. Krawczyk,
“Keying hash functions for message authenti-
cation,” in Advances in Cryptology – CRYPTO
’96 (N.Koblitz, ed.), no. 1109 in Lecture
Notes in Computer Science, pp. 1–15, Springer-
Verlag, Berlin Germany, 1996.
[15] S. Boeyen, T. Howes, and P. Richard, “RFC
2559: Internet x.509 public key infrastructure
operational protocols - LDAPv2,” 1999.
[16] C. Adams, P. Cain, D. Pinkas, and R. Zuccher-
ato, “Internet x.509 public key infrastructure
time stamp protocol (tsp), draft-ietf-pkix-time-
stamp-15.txt,” May 2001.
[17] S. Micali, “Enhanced certiﬁcate revocation sys-
tem,” Tech. Rep. TM-542b, MIT/LCS, May
1996.
[18] “SAS plug-in web page,”
available
at:
http://sconce.ics.uci.edu/sucses/.
[19] “Qualcomm eudora mailer,”
http://www.eudora.com.
available at:
[20] R. Laboratories, “Cryptographic message syn-
tax standard,” Public Key Cryptography
Standards 7, RSA Laboratories, Redwood
City, CA, USA, 1993. Available at URL:
ftp://ftp.rsa.com/pub/pkcs/. 1993.
[21] R. Housley, W. Ford, W. Polk, and D. Solo,
“RFC 2459: Internet x.509 public key infras-
tructure certiﬁcate and crl proﬁle,” Jan. 1999.
Appendix A: SAS Implementation De-
tails
A.1 SAS Signature Format
The well-known PKCS#7 [20] standard deﬁnes
a general cryptographic message syntax for digital
signatures. In it, SignerInfo includes an optional
set of signed attributes as well as an optional set
of unsigned attributes. This ﬂexibility allows us to
easily extend the PKCS#7 signature syntax to ac-
commodate SAS signatures. This is because a SAS
signature can be viewed as a regular public key sig-
nature with an appended extra value, i.e., the hash
pre-image.
The format changes are only a few new re-
for authenticatedAttributes and
quirements
unauthenticatedAttributes of the SignerInfo
ﬁeld. In a SAS signature, SignerInfo is the same
as in plain PKCS#7, except:
• authenticatedAttributes:
this ﬁeld is not OPTIONAL, but MANDA-
TORY.
It must contain, at a minimum,
two more attributes aside from those set in
PKCS#7:
– SAS issuer sn: IssuerAndSerialNumber –
speciﬁes the SAS client’s certiﬁcate by is-
suer name and issuer-speciﬁc serial num-
ber
[22] “The
openssl
project
web
page,”
http://www.openssl.org.
[23] P. Kocher, “On certiﬁcate revocation and val-
idation,” in Financial Cryptography – FC ’98,
Lecture Notes in Computer Science, Springer-
Verlag, Vol. 1465, pp. 172–177, 1998.
[24] M. Naor and K. Nissim, “Certiﬁcate revoca-
tion and certiﬁcate update,” in Proceedings 7th
USENIX Security Symposium (San Antonio,
Texas), Jan 1998.
[25] M. Goodrich, R. Tamassia, and A. Schwerin,
“Implementation of an authenticated dictio-
nary with skip lists and commutative hashing,”
in Proceedings of DARPA DISCEX II, 2001.
[26] W. Aiello, S. Lodha, and R. Ostrovsky, “Fast
digital
identity revocation,” in Advances in
Cryptology – CRYPTO ’98 (H. Krawczyk, ed.),
no. 1462 in Lecture Notes in Computer Science,
Springer-Verlag, Berlin Germany, Aug. 1998.
– SAS signed token index:
INTEGER –
speciﬁes the SAS client signed one-time
signature index (counter)
– SAS signed token value:
OCTET
the SAS client
STRING – speciﬁes
signed one-time public key
that
PKCS#7
in
requires
Note
SignerInfo
issuerAndSerialNumber
to identify signer’s key.
In SAS, this corre-
sponds to SEM’s key. Therefore, we require
another ﬁeld SAS issuer sn to identify the
user’s SAS certiﬁcate containing the SAS root
key.
• unauthenticatedAttributes:
this ﬁeld is not OPTIONAL, but MANDA-
TORY. It must contain:
– SAS preimage token value:
OCTET
STRING – speciﬁes the SAS user’s one-
time hash pre-image of the signed token
speciﬁed
SAS signedtoken value.
in
This attribute is unsigned. It is inserted
by the user when the SEM’s half-signature
is received and veriﬁed.
the SEM and the user share the same CA).
Uniquely identiﬁes SEM’s certiﬁcate and the
corresponding public key.
Because of format compatibility, a SAS signature
can be shipped as a normal PKCS#7 signature.
However, the veriﬁcation method is obviously dif-
ferent. The normal PKCS#7 veriﬁcation routines
can only verify the SEM half-signature (i.e., RSA
public key signature).
is
the
The
extra
comparison of
SAS preimage token value
step in (light) veriﬁcation of
the
a SAS signature
hash of
and the
SAS signed token value assuming light veriﬁca-
tion is used. Otherwise, as described above, the ver-
iﬁer checks the validity of SAS signed token value
and SAS signed token index by computing the
iterative hash and comparing the result with the
SAS root key in the signer’s SAS certiﬁcate.
The fact that two parties participate in sign-
ing result in a semantic issue when SAS signa-
tures are used in conjunction with S/MIME. Most
S/MIME applications enforce a policy requiring the
sender of the message (as shown in the RFC822
From: ﬁeld) to match the e-mail address in the
signer certiﬁcate.
in SAS, the
sender is the holder of the SAS certiﬁcate, e.g., al-
ice@wonderland.com. Whereas, the “signer” is the
SEM, e.g., sem@wonderland.com. Therefore, a SAS
veriﬁer should be aware of the presence of the un-
signed attribute and use the proper email address
in comparison.
Unfortunately,
A.2 SAS Certiﬁcate
To support SAS attributes, we extended X509v3
handling [21] in the popular Openssl library [22]. In
addition to the usual X509v3 ﬁelds, a SAS certiﬁ-
cate also certiﬁes the following:
• SASHashType: DigestAlgorithmIdentifier –
identiﬁes the hash algorithm used in generating
the hash chain;
• SASPublicKeyIdentifier:
SAS root key in the hash-chain.
OCTET STRING –
• SASPublicKeyPara: INTEGER – length of the
hash-chain.
• SASServerName: STRING – SEM’s host name.
This ﬁeld indicates the location of SEM and
has no security meaning.
• SASSerialNumber: INTEGER – SEM’s certiﬁ-
cate serial number. (Here it is assumed that
A.3 Eudora Plug-in Details
We implemented the SAS plug-in as two email
translators deﬁned in Eudora’s plug-in API [19].
Speciﬁcally, SAS signing is a Q4-Transmission
translator and SAS veriﬁcation is an On-Display
translator.
SAS signing translator is invoked when Eudora
is ready to send email and is fed with the entire
email message, including its MIME header. When
SAS signature protocol terminates, the whole SAS
signature in PKCS#7 format is appended to the
email body as an attachment with the MIME sub-
type ‘‘x.SAS-signature’’.
SAS veriﬁcation translator is called when Eudora
is about to display a SAS-signed email. As in tradi-
tional signature veriﬁcation, a certiﬁcate chain must
be at hand. Our plug-in allows users to specify the
root CA certiﬁcate, assuming, of course, that the
SEM and the SAS client share the same certiﬁcate
issuer.
It is easy to build a chain by extracting
SEM and client’s certiﬁcate from the PKCS#7 sig-
In this implementation, we chose not to
nature.
adopt opaque signing.
If the signature is invalid,
an error message window is popped up while the
original email body is still displayed.
Since SAS signature veriﬁcation is diﬀerent from
normal S/MIME, non-Eudora applications,
like
Netscape or Outlook, cannot verify it without a spe-
cial veriﬁcation program. We provide such a stand-
alone
Appendix B: Related Work on Certiﬁ-
cate Revocation
• CRLs and ∆-CRLs: Certiﬁcate Revocation
Lists are the most common way to handle certiﬁcate
revocation. The Validation Authority (VA) period-
ically posts a signed list of all revoked certiﬁcates.
These lists are placed on designated servers called
CRL distribution points. Since these lists can get
quite long, a VA may alternatively post a signed
∆-CRL which only contains the list of revoked cer-
tiﬁcates since the last CRL was issued. When ver-
ifying a signature on a message, the veriﬁer checks
that, at the time that the signature was issued, the
signer’s certiﬁcate was not on the CRL.
• OCSP: The Online Certiﬁcate Status Proto-
col (OCSP) [1] improves on CRLs by avoiding the
transmission of long CRLs to every user and by pro-
viding more timely revocation information. The VA
sends back a signed response indicating whether the
speciﬁed certiﬁcate is currently revoked. When ver-
ifying a signature, the veriﬁer sends an OCSP (cer-
tiﬁcate status request) query to the VA to check if
the enclosed certiﬁcate is currently valid. The VA
answers with a signed response indicating the cer-
tiﬁcate’s revocation status. Note that OCSP pre-
vents one from implementing stronger semantics: it
is impossible to ask an OCSP VA whether a certiﬁ-
cate was valid at some time in the past.
• Certiﬁcate Revocation Trees: Kocher [23]
suggested an improvement over OCSP. Since the
VA is a global service,
it must be suﬃciently
replicated to handle the load of all validation
queries. This means the VA’s signing key must
be replicated across many servers which is either
insecure or expensive (VA servers typically use
tamper-resistance to protect the VA’s signing key).
Kocher’s idea is to have a single highly secure VA
periodically post a signed CRL-like data structure
to many insecure VA servers. Users then query
these insecure VA servers. The data structure
(CRT) proposed by Kocher is a hash tree where
the leaves are the currently revoked certiﬁcates
sorted by serial number The root of the hash tree
is signed by the VA.
A user wishing to validate a certiﬁcate issues a
query to the closest VA server. Any insecure VA
can produce a convincing proof that the certiﬁcate
is (or is not) on the CRT. If n certiﬁcates are cur-
rently revoked, the length of the proof is O(log n).
In contrast, the length of the validity proof in OCSP
is O(1).
• Skip-lists and 2-3 trees: One problem with
CRTs is that, every time a certiﬁcate is revoked, the
entire CRT must be recomputed and distributed in
its entirety to the various VA servers. A data struc-
ture allowing for dynamic updates would solve this
problem since the secure VA would only need to
send small updates to the data structure along with
a signature on the new root of the structure. Both
2-3 trees proposed by Naor and Nissim [24] and skip-
lists proposed by Goodrich [25] are natural data
structures for this purpose. Additional data struc-
tures were proposed in [26]. When a total of n cer-
tiﬁcates are already revoked and k new certiﬁcates
must be revoked during the current time period,
the size of the update message to the VA servers is
O(k log n) (as opposed to O(n) with CRT’s). The
proof of certiﬁcate’s validity is O(log n), same as
with CRTs.