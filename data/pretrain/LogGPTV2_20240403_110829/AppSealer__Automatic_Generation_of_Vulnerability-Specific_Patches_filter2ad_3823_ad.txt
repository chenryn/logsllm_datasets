the BoolWrapper parameter is only used in the “Identity”
statement (the Jimple IR statement binding formal parameter
to corresponding local variable), and is never used later. If
this is true, we can remove this parameter from the function
prototype. In addition, we need to adjust the remaining Identity
statements in the function body, because the indexes of the
subsequent parameters have changed. Further, because of the
change in the function prototype, all the invocations to this
function also need to be adapted accordingly. The optimized
crypt is then shown below, in which the second parameter
is removed and the function size is reduced from 15 to 10
statements.
public byte crypt(byte, BoolWrapper, BoolWrapper)
{
r0 := @this: VulActivity;
b0 := @parameter0: byte;
w_p0 := @parameter1: BoolWrapper;
w_r := @parameter2: BoolWrapper;
b0_t = w_p0.;
b1 = r0.;
$b2 = b0 ˆ $b1;
b2_t = b0_t | 0;
w_r. = $b2_t;
return $b2;
}
Inlining Instrumentation Code (O3). Code inlining is a
standard compiler optimization technique. By inlining the body
of a small function into its callers, the function call overhead
(including parameter passing, function prologue and epilogue,
etc.) can be avoided, and the inlined code can be further
specialized under the caller’s context. We adopt this idea to
further optimize the added instrumentation code. That is, we
want to inline the added instrumentation code (i.e., taint logic)
from the callee’s function body into the caller’s context. This
is feasible only if the added instrumentation statements are
not inﬂuenced by the other statements in the callee’s function
body. More precisely, within the function scope, we compute
a backward slice [19] for these instrumentation statements. In
order to inline these statements into the caller’s context without
side effects, the backward slice should not have statements that
may cause side effects, such as function calls, static/instance
ﬁelds, etc. If this is true, it is safe to inline the computed slice
into the caller’s context, and the callee’s function prototype
and function body can then be recovered to their original
form, meaning that the callee’s function body is no longer
instrumented.
In our running example, crypt is such a case. Its taint
logic is simple enough and has no side effect. So the instru-
mentation statements are removed and inlined into the caller’s
context. The crypt implementation is then recovered in its
original form. The code below illustrates that the instrumenta-
tion statements from crypt have been inlined into its caller
OnDestroy, so the taint propagation logic in crypt is now
enforced in the caller’s context.
$b3 = virtualinvoke r0.
($b2);
tmp21 = $b2_t;
tmp23 = tmp21 | 0;
$b3_t = tmp23
Soot’s Built-in Optimizations (O4). After these custom op-
timizations, we can ﬁnally apply Soot’s built-in optimizations
to further reduce the instrumentation overhead. Soot provides
a variety of intra-procedural optimizations. In particular, con-
stant propagation, copy propagation, dead assignment elimi-
nation, unreachable code elimination, and unused local elimi-
nation play important roles in this optimization process. In the
running example, the instrumentation statements, which have
been extracted from crypt to its caller, are now optimized
into only one statement, as shown below.
$b3 = virtualinvoke r0.
($b2);
$b3_t = $b2_t | 0;
Note that in this example, the inserted statement can be
further optimized to $b3_t = $b2_t. However, Soot does
not optimize arithmetic expressions. To achieve the optimal
instrumentation performance, we have implemented this opti-
mization in Soot. In the end, only one deﬁnition statement is
needed to propagate taint for the crypt function.
B. Optimized Patch for Running Example
Figure 5 presents the optimized patch for the running ex-
ample. For the sake of readability, we present the patch code in
Java as a “diff” to the original program, even though this patch
is actually generated on the Jimple IR level. Statements with
numeric line numbers are from the original program, whereas
those with special line number “P” are patch statements. The
underlines mark either newly introduced code or modiﬁed parts
from old statements.
We can see that a boolean variable “addr s0 t” is created to
shadow the instance ﬁeld “addr”, and another boolean variable
“location s1 t” is created to shadow the static ﬁeld “location”.
Then in onCreate(), the shadow variable “addr s0 t” is set
to 1 (tainted) when the Activity is created upon an external
Intent. Otherwise it will be set to 0 (untainted). The shadow
to 1 inside onStart(),
variable “location s1 t” is set
after getLocation() is called. Note that
this initial-
ization is originally placed inside getLocation() after
Ln.40, and a BoolWrapper is created for the return value
of getLocation(). After applying the inlining optimiza-
tion(O3),
is lifted into the caller function
onStart() and the BoolWrapper variable is also removed.
Due to the optimizations, many patch statements placed
for tracking tainted status have been removed. For example,
the taint logic in crypt() has been lifted up to the body
of onDestroy() and further optimized there. The tainted
values should also be properly cleaned up. For instance,
“addr s0 t” is set to 0 after Ln.15, where “addr” is assigned
a constant value, which means that if no “url” is provided in
the Intent, the “addr” should not be tainted.
this assignment
In the method onDestroy(), when the information ﬂows
through the post() method, we wrap the local shadow
9
1 public class VulActivity extends Activity{
...
private String addr;
public boolean addr_s0_t;
private static Location location;
public static boolean location_s1_t;
...
public void onCreate(Bundle savedInstanceState){
...
this.addr=getIntent().getExtras().getString("url");
if(isExternalIntent()){
this.addr_s0_t = true;
}else{
this.addr_s0_t = false;
}
if(this.addr == null){
this.addr = DEFAULT_ADDR;
this.addr_s0_t = false;
}
}
public void onStart(){
VulActivity.location = getLocation();
VulActivity.location_s1_t = true;
}
public void onDestroy(){
...
String url = this.addr;
BoolWrapper bytes_s1_w = new BoolWrapper();
bytes_s1_w.b = VulActivity.location_s1_t;
BoolWrapper url_s0_w = new BoolWrapper();
url_s0_w.b = this.addr_s0_t;
post(url, bytes, url_s0_w, bytes_s1_w);
}
...
public void post(String addr, byte[] bytes,
5
P
6
P
10
13
P
P
P
P
P
14
15
P
16
17
18
19
20
P
21
22
23
29
P
P
P
P
P
31
44
P
P
BoolWrapper addr_s0_w, BoolWrapper bytes_s1_w){
boolean output_s0_t = addr_s0_w.b;
boolean bytes_s1_t = bytes_s1_w.b;
...
OutputStream output = conn.getOutputStream();
if(output_s0_t == true && bytes_s1_t == true)
promptForUserDecision();
output.write(bytes, 0, bytes.length);
...
48
P
P
49
50
51
52 }
}
Fig. 5.
Java Code for the Patched Running Example
variables for corresponding parameters and pass these Bool-
Wrapper objects to new post() as additional parameters. In
the end, we retrieve the taints in post() and check the taint
statuses before the critical networking operation is conducted
at Ln.49. Consequently, we stop this component hijacking
attack right before the dangerous operation takes place.
VI. EXPERIMENTAL EVALUATION
To evaluate the efﬁcacy, correctness and efﬁciency of
AppSealer, we conducted experiments on real-world Android
applications with component hijacking vulnerabilities and gen-
erated patches for them. We ﬁrst present our experiment setup
and in Section VI-A. We then discuss summarized results in
Section VI-B, and study several cases in detail in Section VI-C.
Next, we verify the effectiveness of these patches in Sec-
tion VI-D. Finally we measure the runtime performance in
Section VI-E.
A. Experiment Setup
We collect 16 vulnerable Android apps, which expose
internal capabilities to public interfaces and are subject to
exploitation. Table I describes their exposed interfaces, leaked
capabilities and possible security threats.
10
Fig. 6. Relative Size of Slices in Percentage.
Most of these vulnerable apps accidentally leave their in-
ternal Activities open and unguarded. Thus, any Intent
whose target matches the vulnerable one can launch it. Others
carelessly accept any Intent data from a public Service
without input validations. Unauthorized external Intent can
therefore penetrate the app, through these public interfaces,
and exploit its internal capabilities. Such leaked capabilities,
including SQLite database query and Internet access, are
subject to various security threats. For instance, Intent data
received at the exposed interface may cause SQL Injection;
external Intent data sending to Internet may cause delegation
attack.
To detect and mitigate component hijacking vulnerabilities,
AppSealer automatically performs analysis and rewriting, and
generates patched apps. We conduct the experiment on our
test machine, which is equipped with Intel(R) Core(TM) i7
CPU (8M Cache, 2.80GHz) and 8GB of physical memory.
The operating system is Ubuntu 11.10 (64bit).
To verify the effectiveness and evaluate runtime perfor-
mance of our generated patches, we further run them on a real
device. Experiments are carried out on Google Nexus S, with
Android OS version 4.0.4.
B. Summarized Results
We conﬁgure AppSealer to take incoming Intents from
exposed interfaces as sources, and treat outgoing Internet
trafﬁc and internal database access as sinks. A taint slice is then
a potential path from the Intent receiver to these privileged
APIs. We compute the slice for each single vulnerable instance,
and conduct a quantitative study on it.
Figure 6 shows the proportional size of the slices, compared
to the total size of the application. We can see that most of the
taint slices represent a small portion of entire applications, with
the average proportion being 11.7%. However, we do observe
that for a few applications, the slices take up to 45% of the
total size. Some samples (e.g., com.kmshack.BusanBus) are
fairly small. Although the total slice size is only up to several
thousands Jimple statements, the relative percentage becomes
high. Apps like com.cnbc.client operate on incoming Intent
data in an excessive way, and due to the conservative nature
of static analysis, many static and instance ﬁelds are involved
in the slices.
We also measure the program size on different stages
of patch generation and optimizations. We observe that the
0%5%10%15%20%25%30%35%40%45%50%12345678910111213141516Propotional Size of SlicesApp IDTABLE I.
OVERVIEW OF VULNERABLE APPS
ID
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
Package-Version
CN.MyPrivateMessages-52
com.akbur.mathsworkout-92
com.androidfu.torrents-26
com.appspot.swisscodemonkeys.paintfx-4
com.cnbc.client-1208
com.cnbc.client-1209
com.espn.score center-141
com.espn.score center-142
com.gmail.traveldevel.android.vlc.app-131
com.kmshack.BusanBus-30
com.utagoe.momentdiary-45
com.yoondesign.colorSticker-8
fr.pb.tvﬂash-9
gov.nasa-5