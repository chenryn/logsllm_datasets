61.2  手写汇编代码 
当前的编译器都不会分配循环指令 LOOP 和位移循环指令 RCL。从另外一方面来讲，喜欢直接手写汇
编语言的编程人员非常熟悉这些指令。因此，如果你看到了这些指令的话，那么这部分代码十有八九由编
程人员手工编写而来。本书附录 A.6 都将这些指令添加了“（M）”标记。 
手写的汇编程序很少会具备完整的函数开头和函数结尾。 
通常来说，人工手写的程序没有固定的参数传递方法。 
举一个例子：Windows 2003 操作系统的内核文件 ntoskrnl.exe。 
MultiplyTest proc near  
; CODE XREF: Get386Stepping 
             xor      cx, cx 
loc_620555:  
; CODE XREF: MultiplyTest+E 
             push  
cx 
             call  
Multiply 
             pop  
cx 
             jb   
short locret_620563 
             loop  
loc_620555 
             clc 
locret_620563:   
; CODE XREF: MultiplyTest+C 
             retn 
MultiplyTest endp 
Multiply     proc near  
; CODE XREF: MultiplyTest+5 
             mov  
ecx, 81h 
             mov  
eax, 417A000h 
             mul  
ecx 
             cmp  
edx, 2 
             stc 
             jnz short locret_62057F 
             cmp eax, 0FE7A000h 
             stc 
             jnz short locret_62057F 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
636 
逆向工程权威指南（下册） 
             clc 
locret_62057F:   
; CODE XREF: Multiply+10 
; Multiply+18 
             retn 
Multiply     endp 
实际上，只要查看WRK
①
① WRK 是 Windows Research Kernel（Windows 研究内核）的缩写。 
 v1.2 的源代码就会发现：这部分指令确实来自于手写的汇编语言源文件
WRK-v1.2\base\ntos\ke\i386\cpu.asm。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 6622 章
章    魔
魔数
数与
与程
程序
序调
调试
试  
通常来说，逆向工程的主要目标理解程序处理数据的具体方法。这些数据可能来自于某个文件或者来
自于网络通信，不过数据的出处无关紧要。手工跟踪一个值往往是一项非常劳神费力的事情。为了完成这
个任务，一个最简单的方法是使用自己的特有魔数，虽然这个办法不是百分之百可靠。 
在某种意义上讲，魔数的作用和 X 光的造影剂十分相似：在病人的血液里注入造影剂之后，医生就可
以增强 X 射线的观察效果、清晰地观察病人身体的内部情况。借助造影剂的作用，医生可以在 X 光机下清
晰地观察肾脏里血液的循环过程，从而更为准确地判断脏器是否存在结石或者肿瘤等问题。 
魔数要尽量“打眼”。在观测 32 位数据时，我们可以将魔数设置为 0x0BADF00D （BADFOOD）、
或者 0x11101979（某人的生日，例如“1979 年 11 月 10 日”）。我们可以将这样的 4 字节数值写入到我们要
调查的程序之中。 
接着，我们可以利用 tracer 的代码覆盖率模式（code coverage/cc 模式）跟踪程序，再利用 grep 或者直
接搜索文本文件（跟踪结果的文本文件），我们就能够很容易地发现这些值的调用点及处理方法。 
在代码覆盖率模式（cc 模式）下，使用 tracer 跟踪程序并生成与 grep 兼容的输出（grepable）文件。
其结果大致如下所示： 
0x150bf66 (_kziaia+0x14), e=  
1 [MOV EBX, [EBP+8]] [EBP+8]=0xf59c934 
0x150bf69 (_kziaia+0x17), e=  
1 [MOV EDX, [69AEB08h]] [69AEB08h]=0 
0x150bf6f (_kziaia+0x1d), e=  
1 [FS: MOV EAX, [2Ch]] 
0x150bf75 (_kziaia+0x23), e=  
1 [MOV ECX, [EAX+EDX*4]] [EAX+EDX*4]=0xf1ac360 
0x150bf78 (_kziaia+0x26), e=  
1 [MOV [EBP-4], ECX] ECX=0xf1ac360 
我们同样可以在网络数据包中构造魔数。使用魔数的关键在于：要使用不会重复的且不会在程序里出
现的标志性数据。  
除了跟踪器tracer之外，MS-DOS模拟器（DosBox）也可以用来观测魔数。在heavydebug（重度调试）
模式下，DosBox可以把执行每条指令时的寄存器状态输出到纯文本文件
①
① 关于 MS-DOS 模拟器（DosBox）的特性可以查询以下博客：https://yurichev.com/blog/55/。 
。因此，我们同样可以利用魔数
来调试DOS程序。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 6633 章
章    其
其他
他的
的事
事情
情  
63.1  总则 
逆向工程人员应当尽可能地以编程人员的角度来分析问题。要理解他们的观点、并且时常扪心自问：
如果自己是编程人员的话，自己会如何设计程序。 
63.2  C++ 
在分析 C++的 class 时，本书 51.1.5 节中讲到的 RTTI 数据可能就是分析的重点。 
63.3  部分二进制文件的特征 
在十六进制的编辑器里，16 位/32 位/64 位数据数组的特征十分明显。本节以一个很简单的 MIPS 程序
为例。前文介绍过：每个 MIPS 指令都是整齐的 32 位（即 4 字节）指令。当然 ARM 模式或者 ARM64 模
式的程序也有这个特点。因此，在形式上这些程序的指令都构成了某种 32 位数组。 
图 63.1 所示的屏幕截图，就表现出这种数组特征。笔者添加了 3 条红色的垂直线，以突出这种现象： 
图 63.1  Hiew：一个非常典型的 MIPS 代码 
此外，本书第 86 章介绍了另外一个典型的例子。 
63.4  内存“快照”对比 
这种内存“快照”的对比技术可以凸显出内存中变化的数据，过去就常见于 8 位游戏的作弊领域。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第 63 章  其他的事情 
639 
如果您在老式的 8 位游戏机（这些机器通常内存不大，而游戏本身占用的内存更少）上启动一个游戏，
您就可能看到部分游戏数据—例如，现在装有 100 颗子弹。这时你就可以将所有的内存空间做一个镜像。
把镜像存为文件后，您可以先开一枪，这时子弹的剩余数量会显示为 99 发。这个时候，你再对整个内存空
间做另外一个影像。我们对这两个内存影像进行比对，肯定某个字节的数值从 100 降为 99。 
考虑到这些 8 位的游戏程序一般都是汇编语言程序，而且各变量都是全局变量。因此基于以上的对比
结果，我们就能分析出是哪个内存地址存放着子弹的数量。有了这个关键的突破点，我们接着就可以在游
戏程序的汇编代码（需要进行反汇编处理）中搜索那些指令引用了这个地址，就不难发现对子弹总数进行
递减运算的那条指令。然后，我们把相关指令换成 NOP，就能保证子弹总数保持 100 不变。 
在 8 位游戏机上运行的游戏程序，总是会被加载在固定的内存地址。此外，同款游戏的发行版本也比
较固定（一旦热销也就不会再进行什么升级了）。因此铁杆玩家们都知道改写哪些地址就能“黑掉”这些游
戏了。他们通常会用 BASIC 语言的单字节赋值指令 POKE 直接向已知地址写入特定字节。甚至在一些杂
志中，常常会出现一些关于 8 位机的 POKE 指令列表。 
与此类似，修改游戏分数排行榜也比较容易，而且它不仅仅适用于 8 位游戏。首先，记录一下自己的
游戏得分并将存盘文件备份出来。当排行榜的总分出现变化时，再备份一次存盘文件。接下来，我们可以
用 DOS 系统自带的二进制文件比较工具 FC 直接比对两个文件（存盘文件是二进制文件）。两个文件肯定
有几个字节发生了变化，直接修改这些数值就可以调整游戏得分。然而，现在的游戏开发团队通常都非常
清楚这些伎俩，因此可能会开发一些程序来应对这些措施。 
其他类似的例子可以在本书的第 85 章中找到。 
63.4.1  Windows 注册表 
在安装一个程序以后，我们就能比对安装前后 Windows 的注册表。这是一个非常流行的方法，可以用
来确认特定程序使用了哪些注册表键值。这也许就是“Windows 注册表清理”程序颇为流行的原因。 
63.4.2  瞬变比较器 Blink-comparator  
在介绍了文件比对和内存快照比对的方法之后，笔者不禁想起了瞬变比较器/Blink-comparator（https://en. 
wikipedia.org/wiki/Blink_comparator）：过去，它曾是天文学家观测天体移动的一种相片比对设备。它能够
快速地切换不同时期拍摄的照片，以便天文学家通过肉眼快速地发现两图之间的区别。 
实际上，正是借助于瞬变比较器，人们才在 1930 年发现了冥王星。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第六
六部
部分
分  
操
操作
作系
系统
统相
相关
关  
异步社区会员 dearfuture(15918834820) 专享 尊重版权
710 
逆向工程权威指南 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 6644 章
章    参
参数
数的
的传
传递
递方
方法
法（
（调
调用
用规
规范
范）
）  
64.1  cdecl [C Declaration 的缩写] 
这是 C/C++语言最常使用的参数传递方法。 
调用方函数逆序向被调用方函数传递参数：以“最后（右侧）的参数、倒数第二……至第一个参数”
的顺序传递参数。被调用方函数退出后，应由调用方函数调整栈指针 ESP、将栈恢复成调用其他函数之前
的原始状态。 
指令清单 64.1  cdecl  
push arg3 
push arg2 
push arg1 
call function 
add esp, 12 ; returns ESP 
64.2  stdcall [Standard Call 的缩写] 
这种调用方式与上面提到的 cdecl 规范类似，只是有一点不同：被调用方函数在返回之前会执行“RET 
x”指令还原参数栈，而不会使用单纯的“RET”指令直接返回。这里的 x 的数值的计算方式是：x=参数个
数*指针的大小（注意：指针的大小在 x86 结构中的值是 4，而在 x64 中是 8）。这样调用方函数本身就不会
调整栈指针，因此调用方函数不会因此使用类似于“add esp,x”这样的指令。 
指令清单 64.2  stdcall  
push arg3 
push arg2 
push arg1 
call function 
function: 
... do something ... 
ret 12 
此类约定在 Win32 的标准库文件中十分常见。然而因为 Win64 系统遵循调用约定的是 Win64 规范，
所以 Win64 的库文件里不会出现 stdcall 的标志性操作指令。 
以本书 8.1 节中的函数为例。我们给其中的函数增加__stdcall 限定符即可强制它使用 stdcall 调用
约定： 
int __stdcall f2 (int a, int b, int c) 
{ 
        return a*b+c; 
}; 
它的编译结果与本书 8.2 节类似，但是最后的指令从 RET 变成了 RET 12。在遵循 stdcall 约定之后，
栈指针 SP 不再由调用方函数更新了。 
这样一来，我们就可以通过函数尾部的 RETN N 指令直观地推算出外来参数的个数。计算方法就是：
N 除以 4。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
644 
逆向工程权威指南（下册） 
指令清单 64.3  MSVC 2010 
_a$ = 8  
; size = 4 
_b$ = 12  
; size = 4 
_c$ = 16  
; size = 4 
_f2@12   PROC 
        push  
ebp 
        mov  
ebp, esp 
        mov  
eax, DWORD PTR _a$[ebp] 
        imul  
eax, DWORD PTR _b$[ebp] 
        add  
eax, DWORD PTR _c$[ebp] 
        pop  
ebp 
        ret  
12   
; 0000000cH 
_f2@12   ENDP 
; ... 
        push  
3 
        push  
2 
        push  
1 
        call  
_f2@12 
        push  
eax 
        push  
OFFSET $SG81369 
        call  
_printf 
        add  
esp, 8 
64.2.1  带有可变参数的函数 
在 C/C++语言的标准函数中，printf()一类的函数可能是仅存的几个带有可变参数的函数。借助这类函
数的帮助，我们能比较容易地观察出 cdecl 和 stdcall 调用规范之间的区别。我们首先假定编译器知道 printf()函
数的参数总数。然而，在 Windows 环境下，printf()属于预先编译好的库函数，直接由文件 MSVCRT.DLL
提供。所以，我们无法通过从它的函数代码入手获悉可变参数的处理方式；但是另一方面，我们知道它肯
定会处理格式化字符串。如果 printf()函数当真采取了 stdcall 规范、根据格式化字符串统计变参的数量并且
在函数尾声恢复栈指针，那么这种局面就十分危险了：万一程序员打错了几个字母，程序就会崩溃。由此
可知，对于那些带有可变参数的函数而言，cdecl 规范要比 stdcall 规范更好一些。 
64.3  fastcall 
这个调用约定优先使用寄存器传递参数，无法通过寄存器传递的参数则通过栈传递给被调用方函数。
因为 fastcall 约定在内存栈方面的访问压力比较小，所以在早期的 CPU 平台上遵循 fastcall 规范的程序会比
遵循 stdcall 和 cdecl 规范的程序性能更高。但是在现在的、更为复杂的 CPU 平台上，fastcall 规范的性能优
势就不那么明显了。 
这种调用约定没有统一的技术规范，不同的编译器有着各自不同的实现方法。因此在使用这种约定时，
我们需要特别小心：如果用两个不同的编译器编译出来了 2 个相互调用的、遵循 fastcall 规范的 DLL 库，
那么这种互相调用的访问操作基本都会出现故障。 
不管是 MSVC 还是 GCC 都使用 ECX 和 EDX 传递第一个和第二个参数，用栈传递其余的参数。此外，
应由被调用方函数调整栈指针、把参数栈恢复到调用之前的初始状态（这一点与 stdcall 类似）。 
指令清单 64.4  fastcall  
push arg3 
mov edx, arg2 
mov ecx, arg1 
call function 
function: 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第 64 章  参数的传递方法（调用规范） 
645 
.. do something .. 
ret 4 
我们还是以本书 8.1 节中的例子来说明，把它稍微变化一下，增加一个修饰符号： 
int __fastcall f3 (int a, int b, int c) 
{ 
        return a*b+c; 
}; 
编译完成后，我们看到的结果如下所示。 
指令清单 64.5  MSVC 2010/OB0 
_c$ = 8  
; size = 4 
@f3@12 PROC 
; _a$ = ecx 
; _b$ = edx 
        mov  
eax, ecx 
        imul  
eax, edx 
        add  
eax, DWORD PTR _c$[esp-4] 
        ret  
4 
@f3@12   ENDP 
; ... 
        mov  
edx, 2 
        push  
3 
        lea  