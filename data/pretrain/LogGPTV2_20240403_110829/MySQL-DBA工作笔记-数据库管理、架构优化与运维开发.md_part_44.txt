是统一字段“APNS_PUSH_ID”的字符集为表级的UTF8。
支持非常灵活，数据库级、表级和字段级别都可以定制，而对于这个问题的直接修复，就
存在差别的，而问题的关键就在于字段 APNS_PUSH_ID 的字符集，MySQL 对于字符集的
统一字符集之后，再次执行，就会发现效率就会大大提高。
问题的验证步骤
对于这个问题，经过这样的分析测试，会发现在存储过程中和单独执行的场景中还是
Query OK,0 rows affected (0.00 sec)
关闭trace.
52d8<=APNS_PUSH_ID<=9e9abc28fefdce2dad4186d49990033ca1ac10580839d33e7f6f681bbd1152d8
select *from information_schema.optimizer_trace\G
Trace的信息如下：
Handler_read_rnd_next
Handler_delete
Handler_commit
Variable_name
"range_analysis": 
sssnd
analyzing_range_alternatives":
table_scan":
range_scan_alternatives":[
"cost":326472
”，
"ranges": [
“index”:"APNS_PUSH_ID",
"9e9abc28fefdce2dad4186d49990033ca1ac10580839d33e7f6f681bbd11
|Value
QUERY: UPDATE push_list_s SET
第6章MySQL查询优化丨261
---
## Page 284
262丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
路。对于字符集的设定，虽然灵活方便，但是也要使用统一得当。
于字符集的支持是统一管理方式的，所以也是无果而终，不过这种对比方式给了我一些思
更加坦然。我自己也尝试从和Oracle 的对比中得到一些解决问题的思路，但是Oracle 对
of the parameter that is passed to the stored routine. It must match the column's
 Problem is that the stored routine does not explicitly declare the charset
其实对于问题还是需要刨根问底，找到了问题的症结，就会让我们在处理问题的时候
问题小结
MySQL的回复如下：
f1649<= APNS_PUSH_ID<= 6f8540d3a35a1bf47adbbdc8eae8ed4c91f5b882637ad4acc3daedd51e6f1649"
yzing_range_alternatives":
_scan_alternatives":[
"index":“APNS_PUSH_ID",
"6f8540d3a35a1bf47adbbdc8eae8ed4c91f5b882637ad4acc3daedd51e6
TRACE:
d4c91f5b882637ad4acc3daedd51e6f1649
---
## Page 285
7.1.1为什么需要事务
多个，而要实现并发的方案有多种，它们两者之间没有明显的映射关系，如下图7-1所示。
一些挫败感和似懂非懂的感觉，主要的原因细究起来理解为：使用并发时需要解决的问题有
解，最后会提出事务降维的概念，并给出一些可行的策略。
分析RR隔离级别下的一些常见数据问题和锁机制，通过几个典型的死锁案例来加深理
及整个并发控制体系和MVCC技术，然后以这些为基础，逐步深入事务隔离级别，重点
务和锁就是保证高并发下业务稳定可靠的保障，本章我们会从并发控制开始聊起，会涉
为什么需要事务，听起来是个多余的问题，究其原因，事务处理机制，要保证用户
接下来我们来聊一下对于并发控制的理解，首先需要明确一个问题，那就是为什么需要事务。
并发控制解决的问题
毫无疑问，并发控制是我们学习的重点和难点，因为在一段时间的学习之后，通常会有
随着业务的快速发展，对于业务吞吐量和负载会有越来越高的要求，而 MySQL 的事
也许幸福是一种只能让我们不断追寻的东西，而却无法真正拥有。——《当幸福来敲门》
MySQL并发控制
第7章MySQL事务和锁
图7-1
并发控制的方法
---
## Page 286
264丨MySQL DBA 工作笔记：数据库管理、架构优化与运维开发
化妆品套装，但是还没有下单，如下图7-2所示。
脑，男生关电脑时发现桌面首页显示女生的账号登录了一个购物网站，购物车里有一个
购物车为例吧，故事的背景是一对情侣，某天早上女生上班前对男生说，帮我关一下电
可以用下面的三句话来概括：
样很多读写操作的并发就相对容易理解了。
们可以打一张回执单，上面会有我们的余额（持久化)，之后查多少次都不会变。
性)，我取款的时候有人给我转账，我不应该拒绝这样的操作（隔离性)，取款完毕，
（原子性），我取了1000元，那么从ATM里面取出的也应该是1000元，不多不少（一致
明如下表7-1所示。
是稳定准确，而且绝对是安全的。
顺着这个思路来看，我们把查询余额看做是读操作，存钱、取款看做是写操作，这
那么什么样的操作才是安全的呢，这就引出了事务的ACID 特性，ACID 的解释和说
我们可以假设生活中的几个场景，来吃透这三种不是很容易理解的概念，我们就以
·读在前，写在后，然后又读：幻读。
·写在前，读在后：
其中我们经常听到的脏读、不可重复读、幻读都是在读-写操作中出现的概念，我们
对于这样的操作我们分为读和写，它有如下两种组合：
这个理解起来就相对简单了，比如我去ATM机取款，要么成功，要么提示余额不足
（2）读-写操作
（1）读-读操作
读在前，
持久性（durability）
隔离性（isolation）
一致性（consistency）
原子性（atomicity）
ACID特性
写在后：
不可重复读；
：脏读；
在事务操作时，其他事务的操作不能影响到当前的事务操作
事务在开始和结束时，应该始终满足一致性约束
一个事务要么全部执行，要么完全不执行
图7-2
表 7-1
购物车
事务操作的结果是具有持久性的
化妆品套装
解
男生
释
---
## Page 287
样，吸气，呼气，一张一弛，但是不会彼此交叉。把这个过程细化到一个数据并发中的场景：
过程我们举个例子就很容易理解了。加锁阶段只加锁，解锁阶段只放锁，就好像我们呼吸一
的细节我们在后面会说。
需要通过锁的方式来控制，为了方便理解，整个过程可以理解为是串行的，有一些改进
机制，它只是一种标准，并不是规定了明细的实现细节，所以在数据库方向上大体会有
免写操作堵塞读操作的并发问题，通过使用数据的多个版本保证并发读写不冲突的一种
类并发，看起来容易，但是融合到业务场景中是千差万别，相对是比较复杂的。
制技术来确保整个过程中对于数据的操作是“安全”的。
7.1.2
致，而幻读是针对数据的插入和删除造成的读不一致，如同发生幻觉一样。
读取的数据不完全相同，两者的不同点在于不可重复读是针对数据的修改造成的读不一
以购物车里的所有商品作为参考。
装，明明只中意其中一款啊，这种情况就是幻读，幻读面对的是一类数据，在这里就是
班后，查看购物车，发现除了之前的那款化妆品，
查询数据，类似 product_code='化妆品套装'。
在于修改，一个事务前后两次读取的结果值并不一致，导致了不可重复读，面对的是相同的
带着期待的心情打开购物车，发现化妆品没变，但是数量是2套，这就是不可重复读，重点
这种情况就是脏读，即事务B读到了事务A未提交的数据状态。
信息通过这种方式被男生知晓，如果在一些信息敏感的事务处理是会产生数据问题的，
这里要先引出一个概念，就是2PL（Two-Phase Locking，二阶段锁），这个二阶段锁的
一些MVCC的不同实现。
（2）男生想，多大点事，一套不够，再买一套，于是点击添加了一套，结果女生下班后
写-写的场景其实相对容易理解，为了保证在同一时间完成数据的一致性操作，我们
我们简单总结下，不可重复读和幻读有些类似：
（3）男生查看了女生浏览的其他几款化妆品，
（1）操作数据前，加锁，互相排斥，不允许其他并发任务操作。
MVCC（MultiversionConcurrencyControl）是侧重于读写并发的改善机制，它可以避
（2）多版本并发控制（MVCC）
总体来说，有以下的两类并发控制技术方案：锁机制（Locking）和多版本并发控制（MVCC）
数据库的一个核心方向就是并发控制了，
通过锁机制可以保证数据一致性，整体的场景感觉无非是读-读、读-写、写-写这几
（1）锁机制（Locking）
（1）男生看了下购物车，于是就默默下单提交了，在这种情况下，女生相关的购物
MySQL并发控制技术方案
，并发是对临界资源进行操作，通过并发控
一下子又多了好几款其他的化妆品套
，把它们都加入了购物车，结果女生下
一个事务多次读取某条数据，发现
---
## Page 288
266丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
7.1.3MySQL 中的 MVCC
镜像，这个过程是不加锁的，而当前读-读取的是最新的版本，会加上锁，保证其他事务
在详细展开之前，我们需要了解下 MVCC 并发控制中的两类读操作，快照读（Snapshot
对于并发的性能影响是很大的，所以 InnoDB 实现了以下两种类型的行锁。
属于当前读，操作过程中会读取当前最新的版本，保证其他事务不能修改当前记录。
应的操作就是快照读，而我们上面刚刚列举的共享锁和排他锁的 SQL，还有常见的 DML 都
不会再修改这条记录。
Read）和当前读（Current Read)，其中快照读-读取的是数据的可见版本，是数据的历史
读任务还是会被阻塞，对于读写的操作还是存在瓶颈，所以在这个层面上引入了MVCC，
比如我们触发了一条 select 操作：select*from test where id=100;id 为主键，这条语句对
对于MVCC，想必大家也看到了不少源码层的解读，最大特点就是分析得比较深入了，
我们通过思维导图的形式简单对并发控制技术做个总结，如下图7-3所示。
通过这一层的改进，可以对于读-读并发的场景有了较好地支撑，但是写入的过程中
select * from table_name where .....for update
排他锁：
select * from table_name where .....lock in share mode
共享锁：
·排它锁（X）是互斥关系，读写，
·共享锁（S）之间不互斥，
·排他锁（X)：允许获得排他锁的事务更新数据，但是阻止其他事务获得相同数据
·共享锁（S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
一些常见的共享锁的使用方式有：
简单小结为：
这种锁定的方式相对比较单一而且粒度太粗，这样会导致在并发时读任务都会阻塞，
·集的共享锁和排他锁。
（2）操作数据后，解锁，其他任务可以继续执行。
并发控制技术
视角2
视角1
读读操作可以并行；
读-写多版本并发控制MVCC引出快照读，当前读的基础概念
写-写锁机制
多版本并发控制
锁机制
写写操作不可以并行。
图7-3
引出2PL（二阶段锁）的概念
共享锁S读读可以并行
---
## Page 289
标识是90，然后在这个基础上进行数据修改，数据标识为100，但是事务未提交。
分别是一次写请求和两次读请求。那么在 MySQL 中会先在 T1 时间生成一个快照，比如数据
镜像，而数据的修改指向当前的变化数据，这样两者是一个互补的关系。
理解为是之前的数据镜像，而第2行则是数据处理后的结果。
我们就以这种方式作为例子来解释，在这种情况下，第1行 update 语句对应的数据可以
条 insert 语句。下图 7-4 所示的操作是我们预期的结果。
整的数据变化历史，那么把余额从100变化为200的过程，会转化为1条 update语句，1
变化的历史，比如在数据发生变化时我们不会直接删除数据，而是把它转换为两类操作。
但是却不大好理解，最后有种不明觉厉的感觉，以至于在面试中经常翻船。
这种情况类似下图7-6所示的方式，比如T1，T2，T3三个顺序时间里发生了三次请求，
如果存在大量的并发读写，我们可以把读的压力分担出来，即数据的查询可以指向
比如修改一个账户的余额，这是敏感信息，属于状态型数据，在更新时需要保留完
我们换个角度来解读一下，在表设计中，我们有一种策略，那就是尽可能保留数据
有的同学说，这个和MVCC 有什么关系呢，其实MVCC的实现原理也是类似的方式，
可以把这个过程改造为下图7-5 这样。
100
100
Account_id
100
T3-读请求
T1-写请求
balance
T2-读请求
200
100
balance
100
20171004010100
effective date
20171004010200
20171004010100
图7-6
图7-5
图7-4
20181104010200
20171104010200
expire_date
20181104010200
expire_date
status
0
第7章MySQL事务和锁|267
update语句
insert语句
status
---
## Page 290
268丨MySQLDBA工作笔记：数据库管理、架构优化与运维开发
的日志，这个回滚相关日志的地方就是undo日志里面，一旦出现了事务回滚，我们可以
上也是一笔不小的开销，需要有后台进程去做清理的，而事务发生回滚时需要具备完善
也是对数据周期管理流程的一个补充，这里我们就要引出 InnoDB 层的实现 undo。
new_test,
版本号，在这里就是 2，和上一条的 delete_version 是一致的，比如把字段 name 修改为
阐述。
是行的删除时间。这里存储的是系统版本号，会自动递增，我们按照 DML 的几个维度进行
设在每行记录后面存在两个隐藏的列，这两个列分别保存了这个行的创建时间，一个保存的
据可用状态的。
据标识依旧是 90，T3 时间的读请求也是类似。
我们来设想一个问题，原有的多版本数据在表中存放显然比较复杂的，而且在存储
（3）delete 操作，就是把当前记录标识为已删除，如图 7-9所示。
（2）Update 操作，会先把当前记录标识为已删除，然后新增一列数据，写入相应的
（1）Insert 操作，事务 id假设是1，如下图7-7所示。
上面的实现方式中，如果事务发生回滚该如何处理，这个是我们需要重点考虑的，
明白了这些，理解 InnoDB 的MVCC 就很简单了，我们使用类似的思路来做下解读，假
（2）数据生命周期管理有两个重要的标识，
（1）表设计中数据生命周期的管理是一种体系化的管理方式，原理和思路是通用的
我们小结一下：
所以 MVCC本身还是比较接地气的，只是我们理解的方式有些高大上，消化不了了
在T1写数据的事务内，T2时间的读请求会读取T1时间生成的快照数据，读取的数
如图7-8所示。
new_value
new_test
test
name
test
name
createversion
createversion
createversion
图7-9
2
图7-8
图7-7
一个是标识数据变化的，一个是标识数
deleteversion
deleteversion
deleteversion
C
---
## Page 291
如果要查看，可以使用如下三种方式。
重复读这两种隔离级别中作选择，其中MySQL的默认隔离级别是Repeatable-Read（RR)，
而读未提交这种方式违背了基础的事务安全处理要求，所以行业里普遍是在不可重复读和可
表 7-2是不同事务隔离级别和并发问题的矩阵关系。
绍过了，隔离级别定义了事务之间按照什么规则进行隔离，将事务隔离到什么程度，下
间不是互相隔离的，可能将会出现以下问题：脏读、不可重复读、幻读；在开篇已经介
则会对所有读取的行加锁。
MVCC。Read-Uncommited由于是读到未提交的，所以不存在版本的问题；而 Serializable
位，而不是真正的删除记录，后续这些记录的清理，是通过 Purge 后台进程实现的。
时候进行回滚。
把已有的数据状态通过逆向应用保证事务的 ACID 特性。
7.2
为什么需要事务隔离级别，这是我们学习的一个切入点；简单来说，如果事务之
其中，串行化隔离级别解决了上面的所有数据问题，但是同时带来了并发的性能问题。
此外，需要说明的是，只有在隔离级别 Read-Committed 和 Repeatable-Read 才能使用
对于 InnoDB 来说，无论是更新还是删除，都只是设置行记录上的 deleted BIT 标记
·update 的数据在redo中顺序记录update操作,同时生成undo记录,为逆操作update,
·delete 的数据在 redo 中顺序记录 delete 操作,同时生成 undo 记录，为逆操作 insert;
·insert 的数据在 redo 中顺序记录 insert 操作，同时生成 undo 记录，为逆操作 delete;
比如一张表test（id，name）主键为id列。
把这三个列组合起来，就可以标记数据的周期性，并定位到相应的事务，在需要的
（2）DB_ROLL_PTR：7字节，记录指向回滚段 undo日志的指针。
（1）DB_TRX_ID：6字节，记录每一行最近一次修改它的事务ID。
要实现该细粒度的操作，在 InnoDB 设计中，实际上所有行数据会增加以下三个内部属性列：
（3）DB_ROW_ID：当写入数据时，自动维护的自增列。
比如原来是从 id=1 变成 id=3，则逆操作为 id=3，变成 id=1。
事务隔离级别
不可重复读（Read-Committed）