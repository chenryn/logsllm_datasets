A. Details of Implementation 1
The ﬁrst implementation works across platforms and uses
mostly JavaScript and HTML on the client end. All sharing
and retrieving actions are performed in a JavaScript and
cookie enabled web browser. Neither the sharer, nor the
receiver, needs to install any additional supporting software.
Our application enables users to use the access control
functionality without leaving Facebook and offers a smooth
and easy-to-follow interface. GibberishAES [21] is used for
JavaScript-based symmetric encryption. All hash values are
computed using SHA3 implementation of CryptoJS [22].
306306306
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:24:09 UTC from IEEE Xplore.  Restrictions apply. 
Sharing content: For sharing a new object, the appli-
cation presents an HTML form (Fig. 5) to the sharer for
inputting the object to be shared, context questions and
corresponding answers. It requires the sharer to input the
value of the threshold k and automatically detects the total
number of contexts N by counting the number of question-
answer pairs entered by the sharer. When the sharer submits
this information, a JavaScript function is invoked to perform
a number of client-side operations. This function computes
a random secret MO, corresponding hash KO, and a puzzle
speciﬁc key KZO. Then, the object is encrypted using AES
encryption with key KO. Shamir’s secret sharing algorithm
is executed on MO, and the obtained shares are XOR
encoded with the context answers entered in the HTML
form. The hash values of the answers concatenated with the
puzzle-speciﬁc key KZO are also computed. This completes
the client-side computations for the sharer. The puzzle ZO
is then uploaded to the application server on Amazon EC2.
Figure 6.
Impl. 1: A sample post made on Facebook
the answer ﬁelds in the HTML form with the corresponding
hash values. These hashes are then sent to the server.
Figure 5.
contexts, corresponding questions and threshold k
Impl. 1: HTML form with input boxes for message, associated
The server component of the application maintains a
MySQL database for storing information about all the puz-
zles. On receiving a new puzzle from a sharer, the server
component adds a new entry in the MySQL puzzle table
with a unique puzzle identiﬁer. This identiﬁer is then used to
generate a hyperlink or URI which is posted on the sharer’s
Facebook proﬁle (to the sharer’s social network). The sharer
can also choose to impose an additional layer of privacy
control by means of Facebook’s privacy settings (Fig. 6).
Receiving content: Sharer’s friends (or receivers) who
see the above post are expected to click on the hyperlink,
if they wish to access the shared data object. This leads the
receivers to an interface, where the server fetches the puzzle
from the database and presents them with a randomized
set of questions from the puzzle (Fig. 7). An HTML form
to accept input from the receivers is also displayed. On
receiving the answers to the questions from the receiver, a
JavaScript subroutine (at the receiver) writes all the answers
to a local cookie ﬁle. Another JavaScript function overwrites
Figure 7.
and message is revealed
Impl. 1: Encryption key is reconstructed from puzzle answers
The server component of the application matches the
hashed answers from the receiver to the hashed contexts
stored in the database. If the threshold is not satisﬁed, the
server displays an error message. If the threshold is satisﬁed,
the server redirects the receiver to the encrypted object. The
receiver also receives values of the shares encoded (XOR’ed)
with the correct context answers. On receiving these encoded
shares and the encrypted object, the receiver ﬁrst retrieves
the actual answers from the cookie ﬁle. Then, the answers
are XORed back with the encoded shares to retrieve the
original shares. The original random secret MO is then com-
puted from the shares using Lagrange polynomials. After
calculating KO from MO, AES decryption is performed to
reveal the encrypted object.
B. Details of Implementation 2
Our second implementation uses the publicly-available
CP-ABE implementation. As the CP-ABE toolkit is cur-
rently available only for the Linux platform, this imple-
mentation is restricted only to those users (both sharers
307307307
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:24:09 UTC from IEEE Xplore.  Restrictions apply. 
and receivers) who operate a Linux system pre-installed
with the CP-ABE toolkit. Moreover, as it is currently difﬁ-
cult to invoke CP-ABE library functions directly from the
browser, users may have to switch between the browser and
stand-alone components of the implementation in order to
complete the access control functionality. This may create
discontinuity in user-interaction ﬂow while using the appli-
cation. This could be addressed by developing a browser
plugin that interacts with CP-ABE libraries from within the
browser. Another issue that we encounter in this imple-
mentation is that the encoding of the access tree τ within
the ciphertext CT is not known, thus preventing us from
perturbing and reconstructing the access tree. To overcome
this problem, we currently do not remove the original access
tree τ from the ciphertext CT before storing it on the server.
This action affects the surveillance resistance property (only
in the implementation), but not
the core access control
functionality. These implementation shortcomings in our
current version will be addressed in the future. Lastly, we
compute all hash values in this implementation using SHA1
(available with OpenSSL [23]). For GUI, we use the Qt
widget toolkit application framework [24].
Sharing content: In order to share a new object, the
sharer executes a client-side Qt application. This application
takes as input the object to be shared, associated context
questions and corresponding answers, value for the number
of contexts N, and value for the threshold k (Fig. 8). The
object is stored in a ﬁle named message.txt. The values of N
and k, the questions and the hashes of answers are written
to another ﬁle details.txt. The cpabe-setup function is called
in the background to generate master key ﬁle master key
and public key ﬁle pub key. Then, the cpabe-enc process
encrypts message.txt and replace it with message.txt.cpabe.
The cURL [25] library is invoked to upload details.txt,
master key, pub key, and message.txt.cpabe to the server
component of the application running on the Amazon EC2
server. If all ﬁles are uploaded successfully, the server appli-
cation assigns the puzzle a unique post (or puzzle) identiﬁer.
The server stores the hashes of all the context answers (along
with the post identiﬁer) in a database and deletes these
hashes from details.txt. A reply is sent back to the client-
side application containing the post identiﬁer. The client-side
application prompts the sharer to copy the post identiﬁer
and pass it to a Facebook canvas application (similar to the
ﬁrst construction). The Facebook application reads the post
identiﬁer using JavaScript, generates a hyperlink similar to
the ﬁrst implementation, and shares it on Facebook to the
sharer’s social network.
Receiving content: Sharer’s friends (or receivers) who
see the above hyperlink are expected to click on it, if they
wish to access the shared data object. This leads them to
the Facebook application, where the server displays the post
identiﬁer and prompts the receiver to copy the post identiﬁer
and pass it to a client-side Qt application for receivers. Once
Figure 8.
Impl. 2: Sequential interaction with sharer
the Qt application reads the post identiﬁer, it downloads the
corresponding details.txt ﬁle (with omitted hashed answers)
from the server using the cURL library. The application then
reads details.txt and presents prospective receivers with the
questions from it. After the receiver answers the questions,
the application computes the hash values of answers and
sends them back to the server for veriﬁcation. If less
than k hashed answers matches, an error message will be
returned. If veriﬁcation succeeds, the server gives access to
message.txt.cpabe, master key, and pub key ﬁles. The Qt
application downloads these three ﬁles using cURL. The
application inputs the earlier user entered answers to the
cpabe-keygen function in order to generate the decryption
key ﬁle my priv key. The my priv key, master key, and
pub key ﬁles are used to decrypt message.txt.cpabe by using
the cpabe-dec function. Finally, the Qt application displays
the contents of message.txt to the receiver (Fig. 9).
Figure 9.
Impl. 2: Receiver solving a puzzle and reading the message
VIII. EVALUATION
In this section, we present an evaluation of preliminary
performance-related measurements that we obtained by ex-
ecuting our applications in a controlled setting as well as
a discussion of usability issues related to our proposed
solution.
308308308
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:24:09 UTC from IEEE Xplore.  Restrictions apply. 
Experimental setup: For both implementations, we use
a common PC hardware comprising of a quad core 2.5 GHz
CPU, 1GB RAM and a 802.11n WLAN interface operating
at 60 Mbps. The system is running a Ubuntu version 13.04
OS. Additionally, performance of the ﬁrst implementation
was assessed on a Nexus 7 tablet, and compared with the
performance on the PC. Latest versions of Firefox browser
were used on both devices. The second implementation
could not be benchmarked on the tablet because of its
Linux dependency. Experiments were performed for mes-
sage lengths of 100 characters, answers of 20 characters and
questions of 50 characters long. Measurements were taken
for varying number (N) of contexts, while the threshold k
is set to 1. As CP-ABE does not support (1,1) threshold,
observations start from N = 2. We do not include user
interaction time in our observations.
Implementation 1 vs. Implementation 2 on PC: Figure
10(a) and 10(b) shows the breakdown of the local processing
delay and network delay (including server-side processing)
for the sharer and the receiver, respectively. The network
delay of Implementation 2 (I2) is worst as compared to
Implementation 1 (I1). For each upload by the sharer in
I2, the cURL library is used to upload four different CP-
ABE related ﬁles (total ∼600KB in size) to the server. The
network delay observed for I2 (Figure 10(a)) is both, due
to this considerably large amount of data being transferred
between the client and the server, as well as, due to
the additional overhead caused by the cURL library. The
instability in the measurements, which mostly shows an
increased delay with increasing context size, seems to be due
to the unpredictability of the communication network speed.
Also, I2 has slightly higher local processing delay because
of the greater computational complexity of CP-ABE. The
combined delay in I1 is extremely low for both sharer and
receiver, while for I2 it is noticeably high at the sharer and
comparatively lower at the receivers.
PC vs. Tablet for Implementation 1: Figure 10(c) and
10(d) shows the breakdown of local processing delay and
network delay for sharer and receiver, respectively. We ob-
serve that I1 performs better on PC than on tablet. However,
the overheads are insigniﬁcantly low on both devices.
Usability Aspects: By means of
the implemented
Facebook-compliant prototypes, our goal was to validate
the effectiveness and efﬁciency of the proposed access
control mechanisms. We observed from our experimental
evaluations that users can successfully and efﬁciently share
data on the Facebook OSN using our prototype applications.
However, currently we have no evidence on of how intuitive
the idea of context-based sharing is to OSN users and
what features OSN users expect in such an application.
As with any online service, it is vital to understand the
related usability aspects of the proposed paradigm in order
to improve its practical feasibility, i.e., who, where and
how such applications will be used. To evaluate application
usability, feedback gathering activities such as focus groups,
surveys, user-experience studies and ergonomic assessments
can be conducted. The ISO standard 9241 Part 11 [26]
provides speciﬁc guidelines for evaluating applications in-
volving human-computer interactions with respect to the
goals of effectiveness, efﬁciency and satisfaction. In order
to improve the usability of our applications, we intend to
conduct an on-campus survey and user-study by following
the guidelines set forth in the ISO standard 9241. We
also plan to add additional features to our applications,
e.g., support for non-textual data, picture-based puzzles and
automated client-side context recommendations, to improve
its ease-of-usage and to enhance user-experience.
IX. CONCLUSIONS
In this paper, we proposed and implemented two novel
context-aware access control mechanisms which empowers
users to regulate access to their shared data in OSN ser-
vices. Instead of controlling access to shared data based
on users or user-attributes, the proposed mechanisms focus
on controlling access to data based on the knowledge of
the context associated with the data. By means of the
proposed mechanisms, OSN users can not only enable ﬁne-
grained access control and improve relevance of the shared
data, but also protect it against surveillance from curious
service providers. We analyzed the security of the proposed
mechanisms under various passive and active adversarial
scenarios. We also veriﬁed the correctness and performance
of our implementations by means of empirical evaluations.
ACKNOWLEDGMENT
The authors would like to thank all
the anonymous
reviewers for their insightful comments and suggestions.
REFERENCES
[1] G. A. Fowler, “Facebook: One Billion and Counting,” The
Wall Street Journal, October 2012.
[2] R. Gross and A. Acquisti, “Information revelation and privacy
in online social networks,” in Proceedings of WPES ’05, 2005.
[3] “Facebook privacy settings.” [Online]. Available: https:
//www.facebook.com/settings?tab=privacy
[4] M. Johnson, S. Egelman, and S. M. Bellovin, “Facebook
and privacy: It’s complicated,” in Proceedings of SOUPS ’12,
2012.
[5] A. Tootoonchian, S. Saroiu, Y. Ganjali, and A. Wolman,
“Lockr: better privacy for social networks,” in Proceedings
of the 5th international conference on Emerging networking
experiments and technologies, 2009.
[6] W. Luo, Q. Xie, and U. Hengartner, “Facecloak: An ar-
chitecture for user privacy on social networking sites,” in
Proceedings of IEEE CSE ’09, 2009.
309309309
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:24:09 UTC from IEEE Xplore.  Restrictions apply. 
(a) Sharer’s Overhead: I1 vs. I2 on PC
(b) Receiver’s Overhead: I1 vs. I2 on PC
(c) Sharer’s Overhead: PC vs. Tablet for I1
(d) Receiver’s Overhead: PC vs. Tablet for I1
Figure 10. Performance Measurements
[7] M. M. Lucas and N. Borisov, “Flybynight: mitigating the pri-
vacy risks of social networking,” in Proceedings of WPES’08,
2008.
[8] V. Pouli, J. S. Baras, and A. Arvanitis, “Increasing message
relevance in social networks via context-based routing,” in
Proceedings of MSM workshop, 2012.
[9] P. Jagtap, A. Joshi, T. Finin, and L. Zavala, “Preserving
privacy in context-aware systems,” in Proceedings of ICSC
’11, 2011.
[10] M. D¨urr, F. Gschwandtner, C. K. Schindhelm,
and
M. Duchon, “Secure and privacy-preserving cross-layer ad-
vertising of location-based social network services,” in Mobile
Computing, Applications, and Services, 2012.
[11] J. Li, Y. Tang, C. Mao, H. Lai, and J. Zhu, “Role based
access control for social network sites,” in Proceedings of
IEEE JCPC’09, 2009.
[12] S. Jahid, P. Mittal, and N. Borisov, “Easier: Encryption-based
access control in social networks with efﬁcient revocation,”
in Proceedings of ACM ASIACCS’11, 2011.
[13] C.-m. A. Yeung, I. Liccardi, K. Lu, O. Seneviratne, and
T. Berners-Lee, “Decentralization: The future of online social
networking,” in W3C Workshop on the Future of Social
Networking Position Papers, 2009.
[14] F. Beato, M. Kohlweiss, and K. Wouters, “Enforcing access
control in social network sites,” Katholieke Universiteit Leu-
ven, Belgium, 2009.
[15] ——, “Scramble! your social network data,” in Proceedings
of PETS’11, 2011.
[16] F. Beato, I. Ion, S. ˇCapkun, B. Preneel, and M. Langheinrich,
“For some eyes only: protecting online information sharing,”
in Proceedings of ACM CODASPY’13, 2013.
[17] B. Carminati, E. Ferrari, and A. Perego, “Enforcing access
control in web-based social networks,” ACM TISSEC, 2009.
[18] A. Shamir, “How to share a secret,” Comm. of ACM, 1979.
[19] J. Bethencourt, A. Sahai, and B. Waters, “Ciphertext-Policy
Attribute-Based Encryption,” in IEEE S & P ’07, 2007.
[20] “Amazon EC2.” [Online]. Available: http://aws.amazon.com/
ec2
[21] M. Percival, “GibberishAES.” [Online]. Available: https:
//github.com/mdp/gibberish-aes
[22] “CryptoJS.” [Online]. Available: https://code.google.com/p/
crypto-js
[23] “OpenSSL.” [Online]. Available: http://www.openssl.org
[24] “Qt project.” [Online]. Available: http://qt-project.org
[25] “cURL.” [Online]. Available: http://curl.haxx.se
[26] ISO 9241-11:1998 - Ergonomic requirements for ofﬁce work
with visual display terminals (VDTs) - Part 11: Guidance on
usability.
310310310
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:24:09 UTC from IEEE Xplore.  Restrictions apply.