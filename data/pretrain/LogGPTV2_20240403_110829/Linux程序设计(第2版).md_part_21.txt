---
## Page 103
84
Linux程序设计
fputc库函数把一个字符写到一个输出文件流里去。它的返间值是它刚写的那个值，如果失
败，则返回EOF
类似于fgetc和getc之间的关系，putc函数的作用也相当于fputc，但我们可以把它实现为一
个宏。
putchar函数相当于putc（c，stdour），它把一个字符写到标准输出去。需要注意的是putchar
和getchar是把字符做为int值而不是char返问的。这就允许文件尾（EOF）指示器取“-1”的值，
这是一个超出字符数字编码范围的值
3.5.9 fgets、gets函数
#include 
char *fgeta（char *s,int n,rIL *gtraan）;
fgets库函数从一个输人文件流stream里读取一个字符串。它连续不断地把读到的字符写到
s指向的字符串去，直到出现下面这三种情况之一：到达换行符、已经传输了n-1个字符，或者
到达文件尾。它会把换行符也传递到接收字符串里去，再加上一个表示结尾的空字节“0”。
一次调用最多传输n-1个字符，因为它必须把空字节加上以结束那个字符串，这样总数还是n
个字节。
当fgets成功结束时，它返回一个指向字符串s的指针。如果文件流已经在一个文件的文件尾
处，fgets会置位这个文件流的EOF指示器并返回一个空指针。如果出现读操作错误，fgets返回
一个空指针并设置errmo给出错误的类型
gets函数类似于fgets，只不过前者读的是标准输人并会丢弃它所遇见的任何换行符。它在接
收字符串的尾部也加上一个空字节。注意：gcts对可能被传输的字符的个数并没有限制，因此它
可能会溢出自已的传输缓冲区。所以应该避免使用它，尽量用fgets代替。因特网上的许多安全
问题都可以追溯到出现各种缓冲区溢出现象的程序。眼前就是一个，于万要小心！
3.5.10格式化输入和输出
如果大家用C语言编写过程序，对那些按设计格式输出数据的库函数就应该比较熟悉。这些
函数包括向一个文件流输出数据的printf系列和从一个文件流读取数据的scanf系列。
1.printf、fprintf和sprintf函数
#include 
int fprintf(rrtg *strenm,const char *format,...）;
Int sprintf(char
printf函数家族能够对各种不同类型的参数进行格式编排和输出。参数在输出流中的表示
形式是由格式参数formart控制的。格式参数是一个字符串，其中包含着普通的可打印字符和我
们称之为“转换控制符”的代码，转换控制符规定了其余的参数应该以何种方式被输出到何种
地方。
加入jaVa编程群：524621833
---
## Page 104
第3章如何使用和处理文件
85
printf函数把白己的输出送到标准输出设备中去。fprintf函数把自已的输出送到某个特定
的文件流去。sprintf函数把自己的输出和一个结尾用的空字符写到做为一个参数传递过来的
字符串s里去。这个字符串必须足够大，以便能够容纳所有的输出数据。printf家族还有一些
其他的成员，它们以各自的方式对各自的参数进行处理。详细资料请参考priatf命令的使用手
册页。
普通字符被传递输出时不发生变化。转换控制符让printf取出传递过来的参数数据并对它们
的格式进行编排。转换控制符永远以“%”字符打头。下面是一个简单的例子：
printf (*Sone nunbers:d,&d, and d\n*. 1. 2, 3);
它在标准输出上产生如下所示的输出：
Some numbers: 1, 2, and 3
下面是一些常用的格式控制符：
·%d和%i输出一个十进制整数。
·%0或%x输出一个八进制或十六进制整数。
·%c
输出一个字符。
%s
输出一个字符串。
J%·
输出一个（单精度）浮点数。
·%e
以科学计数法格式输出一个双精度浮点数。
·%g
以一般格式输出一个双精度浮点数。
让传递到printf函数的参数在数量和类型方面与format字符串里的转换控制符配上套是很重
要的。整数参数的类型可以用一个可选的长度限定符来指定。它可以是“h”，“%hd”表示这是
对printf语句进行检查，但这并非万无一失。如果读者使用的是GNU编译器，“gcc-Wformar”可
以完成这一工作。
下面是另外一个例子：
char initial s'A';
char *surname“Matthew*;
double age = 10.5;
printf(*Nello Kiss kc es, aged sgn′, initial, surname, age):
它产生如下所示的输出：
Hello Miss A Matthew, aged 10.5
利用数据域控制符可以对数据的输出格式做进一步的控制。数据域控制符是对转换控制符
的补充，能够对输出数据之间的间隔进行控制。它们的常见用法是设置浮点数的小数点位置，
或者是设置字符串两端的空格个数。
数据城控制符是转换控制符里紧跟在“%”字符后面的数字。下面是一些转换控制符示例及
其输出情况。为了让大家看得更清楚，我们用垂直线字符来表示输出边界（见表3-5）。
加入jaVa编程群：524621833
---
## Page 105
86
Linux程序设计
表3-5
恪
式
参数
输出
10s
*He11o*
He11o
-10
*He11o*
He1lo
10d
1234
1234
10d
1234
1234
$010d
1234
0000001234
$10.4f
12.34
12.3400
8*s
10, *He1lo*
He11o
上表中的示例都输出在一个10个字符宽的区城里。注意：一个负数值的数据域宽度表示数
据项将在该数据城里以左对齐的格式输出。可变数据域宽度用一个星号（*）来表示。在这种
情况下，下一个参数用来表示数据域的宽度。“%”字符后面的第一个“0”表示数据前面要用
“0”填充。根据POSIX技术规范的要求，printf不对数据域进行截断：相反，它会扩充数据域以
适应数据的宽度。因此，如果我们想打印一个长于数据域宽度的字符串，数据域会加凳。如表
3-6所示：
表3-6
参数
10s
“HelloTherePeeps"
Hello TherePeeps
prinf函数返回一个整数，即它输出的字符个数。但sprint的返回值没有算上最后结尾用的
那个nulI空字符。如果发生错误，这些函数会返回一个负数值并设置ermo。
2.scanf、fscanf和sscanf函数
Binclude
int scanf（const char *format,...);
int sacanf（conat char *s，const char *format,...);
scanf函数家族的工作情况与printf函数家族很相似，只是前者的作用是从一个文件流里读
取数据并把数据值放到传递过来的指针参数指向的地址处的变量中去。它们也使用一个格式字
符串来控制输人数据的转换操作，其工作原理和许多转换控制符都与printf系列函数方面的情
况一致。
scanf函数读人的值将保存到对应的变量里去，这些变量的类型正确与否很重要，必须让它
们与格式字符串精确配对。如果不是这样，内存就会发生冲突，从而使程序崩溃。编译器是不
会对此做出错误提示的，但如果运气够好，用户可能会看到一个警告信息！
scanf的格式字符串里包含着普通字符和转换控制符，就像printf函数中一样。但那些普通字
符用来指定在输入数据里必须出现的字符。
下面是一个简单的例子：
int num;
scaut(*Hello d*, &num);
加入jaVa编程群：524621833
---
## Page 106
第3章如何使用和处理文件87
这个scanf函数的调用只有在这种情况下才能成功：标准输人上接下来的五个字符要匹配上
“Hello”；随后的一些字符还必须构成一个可识别的十进制数字。数字将被读人并赋值给变量
num。格式字符串中的那个空格表示忽略输人数据中转换控制符之间的各种空白字符（空格、制
表符、换页符、换行符等）。这就是说，在下面两种输人情况下，这个scanf调用都会执行成功并
把1234放到变量num里去：
Hello1234
Hel1o1234
输人里的空白字符在进行数据转换时一般也会被忽略。也就是说，格式字符串“%d”将持
续读取输人，跳过空格和换行符，直到找到一组数字为止。如果预期的字符没有在输人里出现，
转换工作失败，scanf也将返回。如果不注意，就会因此导致大问题。如果用户在输人中应该出
现一个整数的地方放的是一个非数字字符，就可能在自己的程序里弄出一个无限循环来。
下面是另外一些转换控制符：
·%d
读取一个十进制整数。
·%0或%x
读取一个八进制或十六进制整数。
·%f、%e、%g读取一个浮点数。
·%c
读取一个字符。
·%s
读取一个字符串。
[]%·
：读取一个字符集合（见下面的说明）。
%%·
读取一个“%”字符。
类似于printf，在scanf的转换控制符里也可以加上对输人数据域宽度的限制。长度限定符
（“h”对应于短整数，“1”对应于长整数）指明接收参数能否比缺省情况更短或更长。也就是说，
度浮点数。
以星号（*）打头的控制符表示对应位置上的输人数据可以被忽略，不会被写到接收参数
里去。
我们用“%c”控制符从输人中读取一个字符。这个控制符不跳过起始的空白字符。
我们用“%s”控制符扫描字符串，但我们必须小心从事。它会跳过起始的空白字符，但会
在字符串里出现的第一个空白字符处停下来，所以我们最好还是用它来读取单词而不是一般意
义上的字符串。此外，如果没有数据域宽度限定符，它能够读取的字符串的长度是没有限制的，
所以接收字符串必须有足够的空间来容纳输人流里最长的字符串。最好是使用-个数据域宽度
限定符，或者混合使用fgets和sscanf先读人一行输人数据再对它进行扫描。
我们使用“%[1”控制符读取一个由一个字符集合中的字符构成的字符串。格式字符串
“%[A-Z]”将读取一个由大写字母构成的字符串。如果控制符中字符集合里的第一个字符是上箭
头字符“”，就表示将读取一个由不属于该字符集合的字符构成的字符串。因此，如果想读取
一个其中带空格的字符串，但想让它停在第一个逗号处，我们就可以使用控制符“%1^”。
给定下面的输人行：
He1lo, 1234, 5.768, X, string to the end of this line
加入jaVa编程群：524621833
---
## Page 107
88
Linux程序设计
下面的scanf函数调用能够正确地读人四个数据项：
char s1256] ;
float t;
Lnt n:
char C:
Scanf (*Hello,sd, &g, kc, [^n] *, kn,&t,&c,s) ;
scanf的返回值是它成功读取的数据项个数，如果在读第一个数据项的时候就失败了，返间
值将是零，如果在读第一个数据项的时候就已经到达了输人的结尾，就会返问EOF。如果文件
流上发生了读操作错误，就会置位文件流的出错标志，而错误变量errno将被设置为指明错误类
型的代码、详细情况请参考后面介绍文件流错误处理的内容。
一般说来，对scanf及其伙伴的评价并不高，这主要有三方面原因：
·从它们的历史来看，它们的具体实现都比较笨重。
·它们的用法不够灵活
·从用它们写的代码上不容易看出它们要分析读取的东西是什么。
尽过使用其他函数，比方说，可以用fread或fgets读取输人行，再用字符申函数把输入分断
成我们需要的数据项。
3.5.11对数据流进行处理的其他函数
stdio函数库里还有一些其他的函数，它们或者使用文件流参数，或者使用标准的stdin、
stdout和stderr流进行操作：
· fgetpos
获得文件流的当前读写位置。
• fsetpos
设置文件流的当前读写位置。
• ftell
返回文件流当前读写位置的偏移值。
•rewind
重置文件流里的文件读写位置。
• freopen
重新使用一个文件流。
* setvbuf
为文件流设置缓冲策略。
remove
相当于unlink函数；但如果它的path参数是一个子目录的话，其作用就相当于
rmdir函数。
这些都是在UNIX操作系统man使用手册第三节文档中介绍的库函数。
我们用文件流函数重写一遍前面那个文件拷贝程序，这次我们使用库函数。请看下面的
copy_stdio.c程序。
动手试试：又一个文件拷员程序
这个程序与前面的版本很相似，但逐字符的拷贝工作改为通过调用stdio.h文件里定义的函数
来完成
#include 
#include 
int main()
加入jaVa编程群：524621833
---
## Page 108
第3章如何使用和处理文件
89
FILE*in,*out:
int_c1
in = fopen(*file.in*,*r*);
（,',no.udo= no