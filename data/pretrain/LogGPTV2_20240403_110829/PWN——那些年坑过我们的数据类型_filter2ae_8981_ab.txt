    printk(&unk_2A1);
    result = 0xFFFFFFFFLL;
    }
    else
    {
    result = 0LL;
    qmemcpy(&v2, &name, (unsigned __int16)a1); // a1设置为负数即可绕过overflow检查
    }
    return result;
    }
注意到qmemcpy那里：a1被作为unsigned
__int16类型，查文档易知16代表位数，即占两字节无符号，范围自然是0~ffff即0~65535，现在我们去看汇编：
    .text:0000000000000120 movzx ecx, bx
    .text:0000000000000123 mov rsi, offset name
    .text:000000000000012A mov rdi, rsp
    .text:000000000000012D xor eax, eax
    .text:000000000000012F rep movsb
长度值是通过rdi传过来的，这段汇编前面还有一个mov rbx, rdi
> rax eax ax al ah:
>
> 分别是：64位、低32位、低16位、ax的低8位、ax的高8位
>
> 其他寄存器同理
movzx是小寄存器拷贝到大寄存器，自动用0补齐目标寄存器未用到的高位字节，0x120处的bx是16位的，ecx就是rep
movsb的长度参数、rsi和rdi是rep movsb的源、目标地址
> rep movsb
>
> rep是repeat，重复后面动作的意思，重复次数可知就是ecx
>
> movsb应该是move string byte的缩写，一次拷贝一个字节
>
> 连在一起的意思都懂
>
> 注意这不是个函数调用而是个指令，所以没有call
> qmemcpy，不知道是不是编译器优化的缘故还是ida的缘故，因此长度参数用的是寄存器ecx，而没有按照函数调用规则中的寄存器传参顺序使用edx，这就可以理解了
可见，最终，传入的长度参数由rdi“堕落”成了bx，整整由64位八字节的庞然大物堕落成了16位俩字节的小东西，而之前判断长度是否过大（>63）时用的是64位的值（读者自行审汇编）
这样一来漏洞的情况就清晰了：虽然判断大小合法性时用的是完整的64位的数据，然而最终拷贝多少字节是由其低16位（低二字节）决定的
那么我们首先可以先确定我们想拷贝多少个字节来溢出，比如0x100个吧，由此我们确定低16位就是(01
00)h，接下来我们只需要弄好剩下48位（6字节）让整个64位的值是个负数就ok了！
> 32位下int范围：
>
>   * 正数：00 00 00 00 ~ 7f ff ff ff
>   * 负数：80 00 00 00 ~ ff ff ff ff (ff ff ff ff是-1)
>
>
> 64位下int范围：
>
>   * 正数：00 00 00 00 00 00 00 00 ~ 7f ff ff ff ff ff ff ff
>   * 负数：80 00 00 00 00 00 00 00 ~ ff ff ff ff ff ff ff ff (ff ff ff ff ff ff
> ff ff是-1)
>
由此可知，我们可以将ff ff ff ff ff ff 01 00作为最终的取值，当然这里的选择性很多啦~
## 二、无符号整型使用不当漏洞
这种漏洞的原理我们上面已经说过了，在此就只提一下64位下的构造的思路：
  1. 确定缓冲区写入操作的长度参数所使用的数据类型的位数：n byte
  2. 确定需要绕过的长度检查的逻辑处所用的数据类型的位数：N byte
  3. 构造总长度为N byte，低n byte置为0其余各字节全置为ff，记作r
  4. R = r|，R即为最初输入的长度值
## 三、整数溢出漏洞
整数溢出定义不好给，直接上例子吧，来道pwn题：
    char *__cdecl check_passwd(char *s)
    {
    char *result; // eax
    char dest; // [esp+4h] [ebp-14h]
    unsigned __int8 v3; // [esp+Fh] [ebp-9h]
    v3 = strlen(s);
    if ( v3  8u ) // 4~8
    {
    puts("Invalid Password");
    result = (char *)fflush(stdout);
    }
    else
    {
    puts("Success");
    fflush(stdout);
    result = strcpy(&dest, s);
    }
    return result;
    }
传入一个字符串s，这个s已知在外层调用函数中是可设为任意长度的，但是这里进行了长度检查必须在4~8之间，然而编码者天真的以为既然是4~8那么一个字节大小的数据类型就足够使用了，因此我们看到v3的类型声明为了unsigned
__int8，只有8位一字节，范围0~255
然而strlen函数的返回值类型是64位8字节的，因此在强制转换成更短的一字节的v3时，会直接丢失掉高的7个字节！我们下面上汇编代码来具体看一下：
    .text:080486A4 push ebp
    .text:080486A5 mov ebp, esp
    .text:080486A7 sub esp, 18h
    .text:080486AA sub esp, 0Ch
    .text:080486AD push [ebp+s]
    .text:080486B0 call _strlen
    .text:080486B5 add esp, 10h
    .text:080486B8 mov [ebp+var_9], al
    .text:080486BB cmp [ebp+var_9], 3
可以看到，strlen的返回值rax寄存器在倒数第二行mov的时候，只将低八位的al部分mov给了用于和3比较的变量！
我们来看一下溢出的发生：最终比较的是八位1字节，我们用更大的值来溢出，比如260吧，其对应的hex为0x104，rax=0x104，对应的al就是0x04，在4~8之间，成功绕过长度检查，实现了后续的溢出字符串拷贝！
那么如何构造呢？我们给出两种思路：
  1. 首先确定长度合法性检查处所采用数据类型的位数n，得到M=2^n，集合B为长度检查处所有合法值的集合比如4~8，然后集合{A|(A mod M) ∈ B}中的所有元素都可以绕过检查，从中随意取个你想要的大小即可！
  2. 首先确定长度合法性检查处所采用数据类型的位数n，并在合法长度值中随便挑个值，用位数为n的hex写出来，然后往高位任意扩展位数、以及高位的具体值即可，随你构造！
## 四、总结与心得
可以看到：整数溢出构造思路的第二种方法，其实和前面所说的无符号整型漏洞的长度值构造思想是有着异曲同工之妙的，因为它们都是深入到计算机处理数据的本质，
**从“位”的处理上出发来寻找规律** 。
深化“ **位** ”的数据表示和处理思想，对于分析这一系列相关问题会是极大的帮助！！
此外，一定要看汇编！作为一名合格的pwn手要记住不看汇编的pwn，都是耍流氓！往后的文章不久将会讲到一道babydriver的内核pwn，到时候从那个例子中各位就可以深刻体会到，IDA的F5有时候是非常坑的，不看汇编真的不行！