#BHUSA @BlackHatEvents
eBPF ELFs JMPing Through the 
Windows
Richard Johnson
Trellix
#BHUSA @BlackHatEvents
Information Classification: General
Whoami
Richard Johnson
Senior Principal Security Researcher, Trellix
Vulnerability Research & Reverse Engineering
Owner, Fuzzing IO
Advanced Fuzzing and Crash Analysis Training 
Contact
PI:EMAIL
@richinseattle
Shout out to the Trellix Interns!
Kasimir Schulz
Andrea Fioraldi 
@abraxus7331
@andreafioraldi
#BHUSA @BlackHatEvents
Information Classification: General
Outline
➢ Origins and Applications of eBPF
➢ Architecture and Design of eBPF for Windows
➢ Attack Surface of APIs and Interfaces
➢ Fuzzing Methodology and Results 
➢ Concluding Thoughts
#BHUSA @BlackHatEvents
Information Classification: General
What is eBPF
eBPF is a virtual CPU architecture and VM aka “Berkley Packet Filter” extended to a more 
general purpose execution engine as an alternative to native kernel modules
eBPF programs are compiled from C into the virtual CPU instructions via LLVM and can 
run in emulated or JIT execution modes and includes a static verifier as part of the loader
Execution is sandboxed and highly restricted in what memory it can access and how many 
instructions each eBPF program may contain
eBPF is designed for high speed inspection and 
modification of network packets and program execution
#BHUSA @BlackHatEvents
Information Classification: General
Origins of eBPF
Berkeley Packet Filter technology was developed in 1992 as a way to filter network packets
BPF was reimplemented for most Unix style operating systems and also ported to userland
Most users have interacted with BPF via tcpdump, wireshark, winpcap, or npcap
Using tcpdump and supplying a filter string like “dst host 10.10.10.10 and (tcp port 80 or tcp
port 443)” automatically compiles into a BPF filter for high performance.
We now call this older BPF interface cBPF or Classic BPF
#BHUSA @BlackHatEvents
Information Classification: General
Origins of eBPF
In December 2014, Linux kernel 3.18 
was released with the addition of the 
bpf() system call which implements the 
eBPF API
eBPF extends BPF instructions to 64bit 
and adds the concept of BPF Maps 
which are arrays of persistent data 
structures that can be shared between 
eBPF programs and userspace
daemons
#BHUSA @BlackHatEvents
Information Classification: General
Origins of eBPF
eBPF extended the original BPF 
concept to allow users to write general 
purpose programs and call out to kernel 
provided APIs 
Each eBPF program is a single 
function, but they may tail call into 
others
All eBPF programs must pass a static 
verifier that ensures safe execution 
within the VM
#BHUSA @BlackHatEvents
Information Classification: General
Applications of eBPF
#BHUSA @BlackHatEvents
Information Classification: General
Linux eBPF Applications
More projects on https://ebpf.io/projects
#BHUSA @BlackHatEvents
Information Classification: General
Prior eBPF Research
Evil eBPF – Jeff Dileo, DEF CON 27 (2019)
Use of BPF_MAPS as IPC
Discussed the unprivileged interface BPF_PROG_TYPE_SOCKET_FILTER
Outlined a technique for ROP chain injection 
With Friends like eBPF, who needs enemies – Guillaume Fournier, et al, BH USA 2021
eBPF Rootkit demonstrations hooking syscall returns and userspace APIs
Exfiltration over replaced HTTPS request packets
Extra Better Program Finagling (eBPF) – Richard Johnson, Toorcon 2021
Showed hooks on Linux for tracing intercepting process creation
Preempt loading libc with attacker controlled library (undebuggable from userland)
Hook all running processes 
Provide a method for pivoting hooks into systemd-init
Fuzzed and previewed crashes in ubpf and PREVAIL verifier
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows Timeline
eBPF for Windows was announced in May 2021 https://cloudblogs.microsoft.com/opensource/2021/05/10/making-ebpf-work-on-windows/
“So far, two hooks (XDP and socket bind) have been added, and though these are networking-specific hooks, 
we expect many more hooks and helpers, not just networking-related, will be added over time.”
August 2021 Microsoft, Netflix, Google, Facebook,
and Isovalent announce the eBPF Foundation as 
part of the Linux Foundation
November 2021 added libbpf compatibility
and additional BPF_MAPS support                                    https://cloudblogs.microsoft.com/opensource/2021/11/29/progress-on-making-ebpf-work-on-windows/
February 2022 Microsoft released a blog discussing efforts to port Cillium L4LB load balancer from Linux to 
Windows https://cloudblogs.microsoft.com/opensource/2022/02/22/getting-linux-based-ebpf-programs-to-run-with-ebpf-for-windows/
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows Architecture
Unlike the Linux eBPF system which 
is entirely contained in the kernel and 
used via system calls, the Windows 
version splits the system into several 
components and imports several 
opensource projects including the IO 
Visor uBPF VM and the PREVAIL 
static verifier*
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows
eBPF for Windows is currently capable of performing introspection and modification of 
network packets and exposes a libbpf api compatibility layer for portability 
eBPF for Windows is shipped as a standalone component with claims that is for easier 
serviceability
eBPF for Windows is MIT Licensed and may be shipped as a component of third party
applications which may extend any of the layers
#BHUSA @BlackHatEvents
Information Classification: General
Creating eBPF Programs on Windows
On Windows, eBPF programs can be compiled from C source using LLVM
#BHUSA @BlackHatEvents
Information Classification: General
Creating eBPF Programs on Windows
The resulting output is an ELF object with eBPF bytecode stored in ELF sections
#BHUSA @BlackHatEvents
Information Classification: General
Creating eBPF Programs on Windows
The resulting output is an ELF object with eBPF bytecode stored in ELF sections
#BHUSA @BlackHatEvents
Information Classification: General
Creating eBPF Programs on Windows
The resulting output is an ELF object with eBPF bytecode stored in ELF sections
#BHUSA @BlackHatEvents
Information Classification: General
Creating eBPF Programs on Windows
Here’s an example of a more practical eBPF program for dropping certain packets
#BHUSA @BlackHatEvents
Information Classification: General
Creating eBPF Programs on Windows
Here’s an example of a more practical eBPF program for dropping certain packets
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows Program Types
BPF_PROG_TYPE_XDP
"Program type for handling incoming packets as early as possible.
Attach type(s): BPF_XDP"
BPF_PROG_TYPE_BIND
"Program type for handling socket bind() requests.
Attach type(s): BPF_ATTACH_TYPE_BIND"
BPF_PROG_TYPE_CGROUP_SOCK_ADDR
"Program type for handling various socket operations
Attach type(s): BPF_CGROUP_INET4_CONNECT BPF_CGROUP_INET6_CONNECT
BPF_CGROUP_INET4_RECV_ACCEPT BPF_CGROUP_INET6_RECV_ACCEPT"
BPF_PROG_TYPE_SOCK_OPS
"Program type for handling socket event notifications such as connection established
Attach type(s): BPF_CGROUP_SOCK_OPS"
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows libbpf API
Partial representation of current helper APIs
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows libbpf API
Partial representation of current helper APIs
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows libbpf API
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows Security Model
eBPF for Windows allows unsigned code to run in the kernel 
Current DACLs require Administrative access to interact with the trusted service in 
userland or the driver directly via IOCTLs to load eBPF programs
When eBPF bytecode is loaded by the service, a static verifier checks to ensure the 
program will terminate within a certain number of instructions and not access out of bounds 
memory. 
The VM engine then can JIT code to x64 and pass native instructions to the kernel or run in 
an interpreted mode executing the eBPF bytecode in the kernel* (Debug mode only)
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows Static Verifier
On Linux, the kernel has it’s own static verifier that runs when eBPF code is loaded via 
system calls 
On Windows, an opensource component called PREVAIL has been used
PREVAIL has stronger security guarantees and uses abstract interpretation for a sound 
analysis 
Modern advancements in eBPF such as loops and tail calls are allowed
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows Execution Engine
On Linux, the original kernel implementation of the eBPF bytecode execution engine is 
GPL licensed
On Windows, an opensource third party component from the IO Visor Project called uBPF
is used (https://github.com/iovisor/ubpf)
uBPF (Userspace eBPF VM) is BSD licensed and can run in user or kernel contexts 
uBPF can be leveraged by other projects as a replacement for Lua or Javascript
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows Security Guarantees
The combination of the static verifier and sandboxed execution attempt to provide the 
following security guarantees: 
• eBPF Programs will terminate within a reasonable amount of time (limited by instruction 
counts, loops are unrolled, etc)
• eBPF Programs will not read memory outside the bounds specified at compile time
• Registers are checked for value ranges, uninitialized use
• Stack references are contained to memory written by the program
• Arguments to function calls are type checked
• Pointers must be checked for NULL before dereferencing
• eBPF for Windows can also be run in a secure HVCI mode*
#BHUSA @BlackHatEvents
Information Classification: General
eBPF for Windows Attack Scenarios
Valid attack scenarios include:
• Code execution as Administrator due to parsing errors on loading 3rd party modules
• Code execution in the trusted service via RPC API implementation errors
• Code execution in the trusted service via static verifier or JIT compiler bugs
• Code execution in the kernel via static verifier, JIT compiler, or interpreter bugs
• Code execution in the kernel via IOCTL implementation errors
• Code execution in the kernel via shim hook implementation errors 
#BHUSA @BlackHatEvents
Information Classification: General
eBPF4Win API (ebpfapi.dll)
The initial set of components in the eBPF for 
Windows stack involve the user facing API 
contained in ebpfapi.dll that allows loading and 
unloading programs, creating and deleting 
maps, and so on. 
ebpfapi.dll is exposed through the bpftool.exe 
and netsh interfaces and contains the API set 
shown previously for loading programs, 
manipulating maps, and the ability to verify ELF 
sections from file path or memory
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing ebpfapi.dll
To fuzz the ELF loading API, we used a 
combination of fuzzing the PREVAIL verifier 
code on Linux and cross fuzzing as well as 
directly harnessing ebpfapi.dll APIs with 
libfuzzer
We will show some of the cross fuzzing results 
later but here is the first vulnerability we 
submitted to Microsoft..
#BHUSA @BlackHatEvents
Information Classification: General
EbpfApi Arbitrary Code Execution
Our first vulnerability is a heap corruption which calls free() on user controlled data during 
the parsing of the ELF object containing an eBPF program. Initial corruption occurs during 
the parsing of ELF relocation sections. 
CommandLine: bpftool.exe prog load crash.o xdp
===========================================================
VERIFIER STOP 000000000000000F: pid 0x2D24: corrupted suffix pattern
00000267F2D91000 : Heap handle
00000267F3AA2FC0 : Heap block
0000000000000038 : Block size
00000267F3AA2FF8 : corruption address
===========================================================
...
0:000> db 00000267F3AA2FF8 l20
00000267`f3aa2ff8 41 41 41 41 00 d0 d0 d0-?? ?? ?? ?? ?? ?? ?? ?? AAAA....????????
00000267`f3aa3008 ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ?? ????????????????
#BHUSA @BlackHatEvents
Information Classification: General
EbpfApi Arbitrary Code Execution
This attack would involve an Administrator loading a malicious prebuilt eBPF program or 
compiling a malicious project file which contained header data for an undersized relocation 
section which, when free()’d by the destructor for the relocation object would allow an 
attacker arbitrary code execution
0:000> k
# Child-SP 
RetAddr
Call Site
...
07 0000003c`c56ff060 00007ffc`151185ca 
verifier!AVrfp_ucrt_free+0x4d
08 (Inline Function) --------`--------
EbpfApi!std::_Deallocate+0x2a
09 (Inline Function) --------`--------
EbpfApi!std::allocator::deallocate+0x2e
0a (Inline Function) --------`--------
EbpfApi!std::vector >::_Tidy+0x40
0b (Inline Function) --------`--------
EbpfApi!std::vector >::{dtor}+0x40
0c 0000003c`c56ff090 00007ffc`15144778 
EbpfApi!raw_program::~raw_program+0x7a
0d 0000003c`c56ff0c0 00007ffc`15144fac 
EbpfApi!read_elf+0x9a8
0e 0000003c`c56ff550 00007ffc`15114fa0 
EbpfApi!read_elf+0xbc
0f 0000003c`c56ff790 00007ffc`1510151b 
EbpfApi!load_byte_code+0x140
10 0000003c`c56ffa50 00007ffc`1510374d 
EbpfApi!_initialize_ebpf_object_from_elf+0x16b
11 0000003c`c56ffb30 00007ffc`1513c81e 
EbpfApi!ebpf_object_open+0x1ed
#BHUSA @BlackHatEvents
Information Classification: General
EbpfApi Arbitrary Code Execution
Due to the looping nature of ELF parsing and arbitrary control of sizes and contents, we 
have high confidence this vulnerability can be exploited in practice
0:000> !heap -p -a 000001e45c188c98
address 000001e45c188c98 found in
_HEAP @ 1e45c100000
HEAP_ENTRY Size Prev Flags 
UserPtr UserSize – state
000001e45c188c10 000b 0000
[00] 
000001e45c188c60 
00038 - (busy)
7ffc18c044c1 verifier!AVrfDebugPageHeapAllocate+0x0000000000000431
...
7ffc1513caef EbpfApi!operator new+0x000000000000001f
7ffc151425f4 EbpfApi!std::vector >::_Range_construct_or_tidy+0x0000000000000064
7ffc15142c67 EbpfApi!ELFIO::relocation_section_accessor_template::generic_get_entry_rela+0x0000000000000177
7ffc15144258 EbpfApi!read_elf+0x0000000000000488