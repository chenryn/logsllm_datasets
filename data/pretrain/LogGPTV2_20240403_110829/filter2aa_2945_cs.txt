the text and controls are displayed as they appeared in the Design View
window in Visual Studio. This is the optimal size of the form as it was
designed.
13. Resize the window displaying the Customer app to its minimum width.
This time, much of the form disappears. Some of the TextBlock content
wraps, but the form is clearly not usable in this view.
14. Return to Visual Studio, and on the Debug menu, click Stop Debugging.
That was a salutary lesson in being careful about how you lay out an app.
Although the app looked fine when it ran in a window that was the same size
as the Design View, as soon as you resized the window to a narrower view, it
became less useful (or even completely useless). Additionally, the app
assumes that the user will be viewing the screen on a device in the landscape
orientation. If you temporarily switch the Design View window to the 12”
Tablet form factor and click the Portrait orientation button, you can see what
the form would look like if the user ran the app on a tablet that supports
different orientations and rotated the device to switch to portrait mode. (Don’t
forget to switch back to the 13.3” Desktop form factor afterward.)
Download from finelybook PI:EMAIL
908
The issue is that the layout technique shown so far does not scale and
adapt to different form factors and orientations. Fortunately, you can use the
properties of the Grid control and another feature called the Visual State
Manager to solve these problems.
Using the Simulator to test a Universal Windows
Platform app
Even if you don’t have a tablet computer, you can still test your UWP
apps and see how they behave on a mobile device by using the
Simulator provided with Visual Studio 2017. The Simulator mimics a
tablet device, providing you with the ability to emulate user gestures
such as pinching and swiping objects, as well as rotating and changing
the resolution of the device.
To run an app in the Simulator, open the Debug Target drop-down
list box on the Visual Studio toolbar. By default, the debug target is set
to Local Machine, which causes the app to run full-screen on your
computer, but you can select Simulator from this list, which starts the
Simulator when you debug the app. Note that you can also set the debug
target to a different computer if you need to perform remote debugging
(you will be prompted for the network address of the remote computer
when you select this option). The following image shows the Debug
Target list:
After you have selected the Simulator, when you run the app from
the Debug menu in Visual Studio, the Simulator starts and displays your
Download from finelybook PI:EMAIL
909
app. The toolbar down the right side of the Simulator window contains
a selection of tools with which you can emulate user gestures by using
the mouse. You can even simulate the location of the user if the app
requires information about the geographic position of the device.
However, for testing the layout of an app, the most important tools are
Rotate Clockwise, Rotate Counterclockwise, and Change Resolution.
The following image shows the Customers app running in the
Simulator. The app has been maximized to occupy the full screen. The
labels describe the function of each of the buttons for the Simulator.
Note The screenshots in this section were captured on a computer
with the Simulator running at a resolution of 1366 x 768
(representing a 10.6-inch display). If you are using a different
display resolution, you might need to click the Change Resolution
button and switch to 1366 × 768 to get the same results as shown
here.
The following image shows the same app after the user has clicked
the Rotate Clockwise button, which causes the app to run in the portrait
orientation:
Download from finelybook PI:EMAIL
910
You can also try to see how the app behaves if you change the
resolution of the Simulator. The following image shows the Customers
app running when the Simulator is set to a high-resolution device (2560
× 1440, the typical resolution of a 27-inch monitor). You can see that
the display for the app is squeezed into the upper-left corner of the
screen:
Download from finelybook PI:EMAIL
911
The Simulator behaves exactly like a Windows 10 computer (it is, in
fact, a remote-desktop connection to your own computer). To stop the
Simulator, click the Windows button (in the Simulator, not on your
desktop), click Power, and then click Disconnect.
You should notice that Visual Studio also supports emulators for
specific mobile devices. Some may be listed in the Simulator drop-
down list box, but you can install new emulators as they become
available by selecting Download New Emulators.
Implementing a tabular layout by using a Grid control
You can use the Grid control to implement a tabular layout. A Grid contains
rows and columns, and you can specify in which rows and columns other
controls should be placed. The beauty of the Grid control is that you can
specify the sizes of the rows and columns that it contains as relative values;
as the grid shrinks or grows to adapt itself to the different form factors and
orientations to which users might switch, the rows and columns can shrink
and grow in proportion to the grid. The intersection of a row and a column in
Download from finelybook PI:EMAIL
912
a grid defines a cell, and if you position controls in cells, they will move as
the rows and columns shrink and grow. Therefore, the key to implementing a
scalable UI is to break it down into a collection of cells and place related
elements in the same cell. A cell can contain another grid, giving you the
ability to fine-tune the exact positioning of each element.
If you consider the Customers app, you can see that the UI breaks down
into two main areas: a heading containing the title and the body containing
the customers’ details. Allowing for some spacing between these areas and a
margin at the bottom of the form, you can assign relative sizes to each of
these areas, as shown in the following diagram:
The diagram shows only rough approximations, but the row for the
heading is twice as high as the row for the spacer below it. The row for the
body is ten times as high as the spacer, and the bottom margin is twice the
height of the spacer.
To hold the elements in each area, you can define a grid with four rows
and place the appropriate items in each row. However, the body of the form
can be described by another, more complex grid, as shown in the following
diagram:
Download from finelybook PI:EMAIL
913
Again, the height of each row is specified in relative terms, as is the width
of each column. Also, you can clearly see that the TextBox elements for
Email and Phone do not quite fit this grid pattern. If you were being pedantic,
you might choose to define further grids inside the body of the form to make
these items fit. However, you should keep in mind the purpose of this grid,
which is to define the relative positioning and spacing of elements. Therefore,
it is acceptable for an element to extend beyond the boundaries of a cell in the
grid arrangement.
In the next exercise, you will modify the layout of the Customers app to
use this grid format to position the controls.
Modify the layout to scale to different form factors and orientations
1. In the XAML pane for the Customers app, add another Grid inside the
existing Grid element, before the first TextBlock control. Give this new
Grid a margin of 10 pixels from the left and right edges of the parent
Grid and 20 pixels from the top and bottom, as shown in bold in the
following code:
Click here to view code image
Download from finelybook PI:EMAIL
914
   ...
You could define the rows and columns as part of the existing Grid, but
to maintain a consistent look and feel with other UWP apps, you should
leave some blank space to the left and at the top of a page.
2. Add the following  section shown in bold to the
new Grid element.
Click here to view code image
The  section defines the rows for the grid. In this
example, you have defined four rows. You can specify the size of a row
as an absolute value specified in pixels, or you can use the * operator to
indicate that the sizes are relative and that Windows should calculate the
row sizes itself when the app runs, depending on the form factor and
resolution of the screen. The values used in this example correspond to
the relative row sizes for the header, body, spacer, and bottom margin of
the Customers form shown in the earlier diagram.
3. Move the TextBlock control that contains the text “Adventure Works
Customers” into the Grid, directly after the closing
 tag but before the closing  tag.
4. Add a Grid.Row attribute to the TextBlock control and set the value to 0.
Click here to view code image
      ...
    ...
Download from finelybook PI:EMAIL
915
This indicates that the TextBlock should be positioned within the first
row of the Grid.  (Grid controls number rows and columns starting at
zero.)
Note The Grid.Row attribute is an example of an attached
property. An attached property is a property that a control receives
from the container control in which it is placed. Outside a grid, a
TextBlock does not have a Row property (it would be meaningless),
but when positioned within a grid, the Row property is attached to
the TextBlock, and the TextBlock control can assign it a value. The
Grid control then uses this value to determine where to display the
TextBlock control. Attached properties are easy to spot because
they have the form ContainerType.PropertyName.
5. Remove the Margin property, and set the HorizontalAlignment and
VerticalAlignment properties to Center.
This will cause the TextBlock to appear centered in the row.
The XAML markup for the Grid and TextBlock controls should look like
this (the changes to the TextBlock are highlighted in bold):
Click here to view code image
    ...
    ...
6. After the TextBlock control, add another nested Grid control. This Grid
will be used to lay out the controls in the body of the form and should
appear in the third row of the outer Grid (the row of size 10*), so set the
Download from finelybook PI:EMAIL
916
Grid.Row property to 2, as shown in bold in the following code:
Click here to view code image
   ...
7. Add the following  and
 sections to the new Grid control:
Click here to view code image
These row and column definitions specify the height and width of each
of the rows and columns shown earlier in the diagram that depicted the
structure of the body of the form. There is a small space of 20 pixels
between each of the columns that will hold controls.
Download from finelybook PI:EMAIL
917
8. Move the TextBlock controls that display the ID, Title, First Name, and
Last Name labels inside the nested Grid control, immediately after the
closing  tag.
9. Set the Grid.Row property for each TextBlock control to 0 (these labels
will appear in the first row of the grid). Set the Grid.Column property
for the ID label to 1, the Grid.Column property for the Title label to 3,
the Grid.Column property for the First Name label to 5, and the
Grid.Column property for the Last Name label to 7.
10. Remove the Margin property from each of the TextBlock controls, and
set the HorizontalAlignment and VerticalAlignment properties to Center.
The XAML markup for these controls should look like this (the changes
are highlighted in bold):
Click here to view code image
      ...
      ...
11. Move the id, firstName, and lastName TextBox controls and the title
ComboBox control inside the nested Grid control, immediately after the
Last Name TextBlock control.
Place these controls in row 1 of the Grid control. Put the id control in
Download from finelybook PI:EMAIL
918
column 1, the title control in column 3, the firstName control in column
5, and the lastName control in column 7.
Remove the Margin of each of these controls, and set the
VerticalAlignment property to Center. Remove the Width property, and
set the HorizontalAlignment property to Stretch. This causes the control
to occupy the entire cell when it is displayed, and the control shrinks or
grows as the size of the cell changes.
The completed XAML markup for these controls should look like this,
with changes highlighted in bold:
Click here to view code image
...
...
...
12. Move the TextBlock control for the Email label and the email TextBox
control to the nested Grid control, immediately after the closing tag of
Download from finelybook PI:EMAIL
919
the title ComboBox control.
Place these controls in row 3 of the Grid control. Put the Email label in
column 1 and the email TextBox control in column 3. Additionally, set
the Grid.ColumnSpan property for the email TextBox control to 5; this
way, the column can spread to the value specified by its Width property
across five columns, as shown in the earlier diagram.
Set the HorizontalAlignment property of the Email label control to
Center, but leave the HorizontalAlignment property of the email
TextBox set to Left; this control should remain left-justified against the
first column that it spans rather than being centered across them all.
Set the VerticalAlignment property of the Email label and the email
TextBox control to Center.
Remove the Margin property for both of these controls.
The following XAML markup shows the completed definitions of these
controls:
Click here to view code image
        ...
        ...
    ...
        ...
13. Move the TextBlock control for the Phone label and phone TextBox
Download from finelybook PI:EMAIL
920
control to the nested Grid control, immediately after the email TextBox
control.
Place these controls in row 5 of the Grid control. Put the Phone label in
column 1 and the phone TextBox control in column 3. Set the
Grid.ColumnSpan property for the phone TextBox control to 3.
Set the HorizontalAlignment property of the Phone label control to
Center, and leave the HorizontalAlignment property of the phone
TextBox set to Left.
Set the VerticalAlignment property of both controls to Center, and
remove the Margin property.
The following XAML markup shows the completed definitions of these
controls:
Click here to view code image
        ...
        ...
        ....
14. On the Visual Studio toolbar, in the Debug Target list, select Simulator.
You will run the app in the Simulator so that you can see how the layout
adapts to different resolutions and form factors.
15. On the Debug menu, click Start Debugging.
The Simulator starts and the Customers app runs. Maximize the app so
Download from finelybook PI:EMAIL
921
that it occupies the entire screen in the Simulator. Click Change
Resolution, and then configure the Simulator to display the app using a
screen resolution of 1366 × 768. Also, ensure that the Simulator is
displayed in landscape orientation (click Rotate Clockwise if it is
running in portrait orientation). Verify that the controls are evenly
spaced in this orientation.
16. Click the Rotate Clockwise button to rotate the Simulator to portrait
orientation.
The Customers app should adjust the layout of the user interface, and the