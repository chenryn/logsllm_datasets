a capability not only enables to support automatic exploit syn-
thesis but also makes several, unprecedented applications
possible: 1) systematically discovering unknown types of
heap exploitation schemes; 2) comprehensively evaluating
the security of popular heap allocators; and 3) providing in-
sight into what and how to improve their security. However,
achieving this autonomous capability is far from trivial, for
the following reasons.
Autonomous reasoning of the heap space. To find heap
exploitation techniques, we should satisfy complicated con-
straints to bypass security checks (see §2.3) in a large search
space consisting of enormous possible orders, arguments for
heap APIs, and data in the heap and global buffer. This
space could be greatly reduced using exploit-specific knowl-
edge [17]; however, this is not applicable for finding new
exploit techniques. To resolve this issue, we use a random
search algorithm that is effective in exploring a large search
space [33]. We also abstract common designs of modern heap
allocators to further reduce the search space (§5.2).
Devising exploitation techniques. While enumerating
possible candidates for exploit techniques, a system needs
to verify whether the candidates are valuable. One way
to assess the candidates is to synthesize end-to-end ex-
ploits automatically (e.g., spawning a shell), but this is ex-
tremely difficult and inefficient, especially for heap vulnera-
bilities [4, 11, 16, 33, 58, 60]. To resolve this issue, we use
the concept of impact of exploitation. In particular, we esti-
mate the impacts of exploitation (i.e., AC, OC, AW, and RW)
during exploration instead of synthesizing a full exploit. We
show that these impacts can be quickly detectable at runtime
by utilizing shadow memory (§5.3).
Normalization. Even though a random search is effective
in exploring a large search space, an exploitation technique
found by this algorithm tends to be redundant and inessen-
tial, requiring non-trivial time to analyze the result. To fix
this issue, we leverage the delta-debugging technique [76]
to minimize the redundant actions and transform the found
result into an essential class. This is so effective that we could
reduce actions by 84.3%, drastically helping us to share the
Figure 3: Overview of ARCHEAP. It first generates heap actions
according to an optional model specification. While executing the
generated actions, it estimates the impact of exploitation. Whenever
a new exploit is found, it minimizes the actions and produces Proof-
of-Concept (PoC) code.
new exploitation techniques with the community (§5.4).
5 Autonomous Exploration for Finding Heap
Exploitation Techniques
5.1 Overview
ARCHEAP follows a common paradigm in classical fuzzing—
test generation, crash detection, and test reduction—but is
tailored to heap exploitation (see Figure 3). It first generates
a sequence of heap actions based on a user-provided model
specification. This specification is optional; if it is not given,
ARCHEAP will generate every possible action. Heap actions
that ARCHEAP can formulate include heap allocation, free,
buffer writes, heap writes, and bug invocation (§5.2). Dur-
ing execution, ARCHEAP evaluates whether the executed test
case results in impacts of exploitation, similar in concept to de-
tecting a crash in fuzzing (§5.3). Whenever ARCHEAP finds
a new exploit, it minimizes the heap actions and produces
PoC code (see Figure 5), which contains only an essential set
of actions (§5.4). It is worth noting that this minimization is
to help post-analysis of a found technique but is irrelevant to
false positives; ARCHEAP yields no false positive during our
evaluation thanks to its straightforward analysis at runtime.
5.2 Generating Actions for Abstract Heap
ARCHEAP randomly generates five types of heap-related ac-
tions: allocation, deallocation, buffer writes, heap writes, and
bug invocation. To reduce the search space, ARCHEAP for-
mulates each action on top of an abstract heap model using
the common design idioms of modern allocators. The follow-
ing explains how each action takes advantage of the designs
in reducing the search space.
Allocation. The first action that ARCHEAP can perform is
allocating memory through the standardized API, malloc().
After allocating memory, ARCHEAP stores the returned ob-
ject’s address to its internal data structure, called the con-
tainer. It also stores a chunk size of the object using another
API, malloc_usable_size(), and its status (i.e., allocated)
for further use in other actions (Line 15 – 23 in Figure 4), e.g.,
deallocation or bug invocation.
ARCHEAP allocates memory in random size but con-
sidering multiple aspects to test an allocator. First of all,
ARCHEAP carefully chooses a size of an object (I1 in Ta-
1116    29th USENIX Security Symposium
USENIX Association
Generate randomheap actions(§5.2)Heap action generatorExecute actions and detect impacts (§5.3) Generate PoC exploit(§5.4)Minimize actionsusing delta-debugging(§5.4)PoC generatorModelspecificationPoCexploitName
I1
I2
I3
I4
P1
P2
P3
P4
Description
Random size (binning)
Chunk size of a chunk
Pre-defined constants
Offsets between pointers
NULL
The buffer address
A heap address
The container address
Align
Trans
Model
ax + b
x + b
HA, BA, CA
x + b
x + b
x + b
BA
HA
CA
✓
✓
✓
✓
I: Integer strategy, P: Pointer strategy, HA: Heap address,
BA: Buffer address, CA: Container address
Table 5: Strategies for generating random values by ARCHEAP.
ARCHEAP has two types of strategies: the integer type and the
pointer type. It generates the values according to alignment, trans-
formation, and the given model (see §5.1) of each type.
ble 5) to examine different logic in different bins. In partic-
ular, ARCHEAP first randomly selects a group of sizes and
then allocates an object whose size is in this group. This
group is separated by approximate boundary values instead of
implementation-specific ones to make ARCHEAP compatible
with any allocator. Currently, ARCHEAP uses four bound-
aries with exponential distance from 20 to 220, e.g., the first
group is [20,25), the second one is [25,210), etc. It makes a
small size likely to be chosen. For instance, the chance of
making a fast-bin object in ptmalloc2 becomes more than 1/4
(i.e., chance to select the first group), which was 2−57 in the
uniform sampling. This division is arbitrary but sufficient for
increasing the probability of exploring various bins.
ARCHEAP also attempts to allocate multiple objects in the
same bin (I2) since an object interacts with others in the same
bin. For example, in ptmalloc2, a non-fast-bin object merges
with a non-fast-bin object, not with a fast bin object. To cover
this interaction, ARCHEAP allocates an object whose size is
related to the other object’s size.
To find techniques induced by common mistakes in an al-
locator, ARCHEAP also uses specialized sizes (I3, I4). In
particular, ARCHEAP uses the differences between pointers
to find integer overflow vulnerabilities in an allocator. For ex-
ample, a vulnerable allocator can return a buffer address when
claiming a very large chunk whose size is the same as the dif-
ference between the buffer and a heap object. ARCHEAP also
utilizes several pre-defined constants, e.g., zero or negative
numbers, to evaluate its edge case handling. This is analogous
to classical fuzzing, which uses a fixed set of integers to check
corner conditions (e.g., interesting values in AFL [75]).
Deallocation. ARCHEAP deallocates a randomly selected
heap pointer from the heap container using free(). To avoid
launching a double free bug, which will be emulated in the
bug invocation action, ARCHEAP checks an object’s status. If
ARCHEAP chooses an already freed pointer, it simply ignores
the deallocation action to avoid the bug (Line 24 – 30).
Heap & Buffer write.
The next action that ARCHEAP
can formulate is writing random data to a heap object or the
global buffer. As aforementioned, to find heap exploitation
techniques, written data should be accurate in terms of their
positions and values, rendering classical fuzzing (i.e., purely
// check shadow memory and report ARBITRARY_WRITE
// if arbitrary is true, othewise RESTRICTED_WRITE
// check overlaps of ptr with other chunks, buffer, or container
// generate random size using the integer strategies in Table 5
// note that it only uses container and buffer, not their shadow
// similar to random_size(), but use all strategies in Table 5
void** ptr = malloc(random_size());
check_shadow(false);
check_overlap(ptr);
allocated[ptr_id] = true;
chunk_sizes[ptr_id] = malloc_usable_size(ptr);
container[ptr_id] = container_shadow[ptr_id] = ptr;
ptr_id++;
1 void check_shadow(bool arbitrary) {
2
3
4 }
5 void check_overlap(void** ptr) {
6
7 }
8 void* random_size() {
9
10
11 }
12 void* random_value() {
13
14 }
15 void allocate() {
16
17
18
19
20
21
22
23 }
24 void deallocate() {
25
26
27
28
29
30 }
31 void heap_write() {
32
33
34
35
36
37
38
39
40
41
42
43
44 }
45 void buffer_write() {
46
47
48
49
50
51 }
int index = rand() % ptr_id;
if (!allocated[index]) return;
allocated[index] = false;
free(container[index]);
check_shadow(false);
check_shadow(true);
ptr[i] = random_value();
check_shadow(true);
int index = rand() % ptr_id;
if (!allocated[index]) return;
void** ptr = container[index];
size_t num = rand() % MAX_WRITE + 1;
size_t start = 0, end = num; // a head of the chunk
if (rand() % 2) { // a tail of the chunk
end = chunk_sizes[index] / (sizeof(void*));
start = end - num;
}
for (size_t i = start; i fd->bk = *(&p[1] - 24 + 24) = p[1] == fake *(uintptr_t*)(p[1] + 24) = (uintptr_t)&p[1] + -16; p[2] = malloc(760); // shrink p[2]'s prev_size, making 'fake' as its prev chunk *(uintptr_t*)(p[1] + 768) = 768; *(uintptr_t*)(p[1] + 776) = 768; ❷ // triggering unsafe(fake) via backward consolidation free(p[2]); ❸ // assert(p[1] == (void*)&p[1] - offsetof(bk)); // writing with p[1]: overwriting p[3] to buf ((uintptr_t*)p[1])[5] = (uintptr_t)buf; ❹ // writing with p[3]: overwrite buf[0] with 800 ((uintptr_t*)p[3])[0] = 800; ❺ // assert(buf[0] == 800); // bypassing (1): P->size == next(P)->prev_size // since fake->size = next(fake->prev_size = 0 by default // bypassing (2): P->fd->bk == P && P->bk->fd == P // [BUG] overflowing p[1] to make p[2]'s prev chunk freed, P=01 2 3 4 5 6 7 8 9 10 12 13 14 15 16 17 18 19 20 21 22 23  // fake->bk->fd = *(&p[1] - 16 + 16) = p[1] == fake11 24 p[0]p[0]Heap containerShadow memoryGlobal buﬀerShadow memory❶...p[0]Heap containerShadowmemoryGlobal buﬀerShadow memory❷p[1]p[2]p[0]p[1]p[2]p[0]p[1]p[2]p[0]Heap containerShadow memoryGlobal buﬀerShadow memory❸★p[2]p[0]p[1]p[2]p[0]p[2]Discrepency after free() - Restricted write in the heap container ★ = (void*)&p[1] - offsetof(bk)p[0]Heap containerShadowmemoryGlobal buﬀerShadow memory❹p[2]p[0]p[2]p[0]p[2]bufDivergence after heap write - Arbitrary write in the heap containerp[0]Heap containerShadow memoryGlobal buﬀerShadow memory❺p[2]p[0]p[2]p[0]p[2]bufDivergence after heap write - Arbitrary write in the global bufferbuf800★★★★an application instead of the data structure for exploitation.
ARCHEAP’s fuzzing strategies (Table 5) make this detec-
tion efficient by limiting its analysis scope to its data struc-
tures. In general, a heap exploit technique can corrupt any
data, leading to scanning of the entire memory space. How-
ever, the technique found by ARCHEAP can only modify
heap or the data structures because these are the only visible
addresses from its fuzzing strategies. ARCHEAP checks only