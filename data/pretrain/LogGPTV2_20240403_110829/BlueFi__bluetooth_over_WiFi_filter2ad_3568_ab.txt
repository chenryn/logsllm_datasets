portant is the short guard interval (SGI), the only reason why
BlueFi requires 802.11n hardware instead of 802.11g. With SGI,
the length of CP is reduced from 16 samples (800ns) to 8 samples
(400ns), and hence less impairment is introduced by the insertion
of CP. SGI directly increases throughput by more than 10%, and
therefore is implemented on all devices from all major vendors even
though it is an optional feature. Any 802.11n NIC or router with an
advertised speed of 150, 300, 450 or 600Mbps has the SGI feature.
Frame aggregation is a mandatory feature in 802.11n. Although
the maximum length of a single MAC layer payload (MPDU) is 2,304
bytes, the PHY payload (PSDU) can be as long as 65,535 bytes. The
802.11n-compliant NIC’s ability to transmit huge packets enables
BlueFi to generate a very long waveform if needed. Supporting
multiple antennas is a major focus of 802.11n, but it is an optional
feature. Therefore, all devices should support using a single spatial
stream.
2.2 Overview and Methodology of BlueFi
BlueFi starts with a simple principle: As long as the IQ waveforms
generated by a WiFi chip are close enough to those generated by a Blue-
tooth transmitter, Bluetooth devices will be able to correctly receive
the signals. Therefore, given a synthesized Bluetooth IQ waveform,
we aim to find a corresponding WiFi bit-stream so that when it is
fed into an 802.11n transmitter, the generated IQ waveform will be
as close to the Bluetooth IQ waveform as possible. Finding the cor-
responding bit-stream is somewhat similar to simply decoding an
802.11n packet received from the radio. However, the former differs
from the latter in that how “close” the reconstructed IQ waveform
is to the target Bluetooth IQ waveform should be determined by
the decoding process of a Bluetooth receiver, and a small signal
deviation, from the WiFi hardware’s perspective, can completely
disrupt the decoding process of a Bluetooth receiver.
Therefore, we use the following methodology: just like decoding
802.11n packets, BlueFi tries to reverse the operation of each block
in the transmitter one-by-one. However, the results of the reverse
operation of each block are selected based on how close they can
reconstruct the IQ waveform from a Bluetooth receiver’s perspective.
2.3 Construction of IQ Waveform
For simplicity, we assume Bluetooth’s GFSK bits, including the
entire packet from the preamble to the CRC, are fed into BlueFi.
We also assume the payload is properly scrambled with a correct
seed. We have built a tool for converting Bluetooth payload to GFSK
bits, which can also be done by other software tools. We construct
the frequency signal by converting 1’s and 0’s with respective
frequency deviations. Since typical WiFi hardware generates the
IQ signal at the sampling rate of 20MHz, each 1 or 0 corresponds
to 20 samples of the frequency signal. We also insert 0’s to the
front and to the back of the frequency signal since we observed
such a pattern on commercial Bluetooth chips. We then convert the
frequency signal to its phase signal by accumulating the frequency
signal. Since the center frequency at which we wish to transmit
477
ScramblerFEC CoderBit InterleavingQAMCP InsertionIFFTBitstreamCarrierAntenna(cid:127)(cid:129)(cid:141)[(cid:143)](cid:144)[(cid:157)] [!]"(cid:157)=∠(cid:144)[(cid:157)]IQ WaveformSIGCOMM ’21, August 23–28, 2021, Virtual Event, USA
Hsun-Wei Cho and Kang G. Shin
the Bluetooth packet may not be exactly the same as one of the
WiFi channels, we modulate the phase signal (sample-wise adding
linearly increasing phases) so that the output is the phase signal
with respect to the center of a WiFi channel. This modulating
operation must be applied before CP insertion since these two
operations are not commutative for phase signals. We denote this
phase signal as θ[n].
2.4 CP Insertion
This process is illustrated with phase signals as we can always
convert a phase signal θ[n] to its corresponding IQ waveform of
ei·θ[n]. The input of the CP insertion block can be mapped 1-to-1
to the output, and vice versa. Therefore, instead of seeking an input
that will be mapped to the best-fitting IQ waveform, we first find
an output IQ waveform ˆθ[n] that can be: (1) received by Bluetooth
devices, and (2) generated by the CP insertion block.
The output of the CP insertion block always shows the first 8
samples being identical to the last 8 samples in every 72 samples.
Therefore, the most basic waveform that satisfies (2) can be gener-
ated by copying the first 8 samples to the last 8 samples in every
72 samples. The CP insertion process technically copies the last
8 samples from the last 64 samples and inserts them to the front.
However, since we have complete freedom in designing the last 64
samples, they can be generated in a way the last 8 samples appear
to have been overwritten by the CP waveform inserted at the front.
Figure 2: CP insertion and OFDM symbol windowing
Although the waveform of this simple method has shown ac-
ceptable performance in our simulations and when transmitted
by USRP, it shows a very poor performance when transmitted by
real WiFi chips and some Bluetooth receivers cannot pick up any
signal at all. By transmitting various IQ waveforms with USRP
and analyzing the responses of Bluetooth receivers, we found that
this has something to do with windowing applied to each OFDM
symbol, which is recommended by the standard to be implemented,
dated all the way back to 802.11a, to reduce spectral leakage. The
operation of OFDM windowing is illustrated in Fig. 2. According
to the standard, the windowing works by extending each OFDM
symbol by 1 sample (which is copied from the sample immediately
following the CP) and then averaging the overlapped samples in
the time domain. Since adding two phase samples in the time do-
main creates an erratic phase, the carefully-designed phase signal
is corrupted in 1 of every 72 samples (on top of the CP corruption).
We found this corruption alone enough to make the difference of
reception/no reception on some devices. Therefore, we must con-
sider one additional constraint, which can be summarized as the
continuity constraint: for each OFDM symbol, the last few samples
478
along with the extended sample must appear continuous with the
first few samples in the next OFDM symbol.
Figure 3: Constructing ˆθ[n] from θ[n] for every symbol
ˆθ[N + n] =
We found a way to construct an IQ waveform (whose phase is
ˆθ[n]) that satisfies all these constraints. The process is illustrated
in Fig. 3. Mathematically,
θ[N + n],
θ[N + n + 64],
θ[N + n],
θ[N + n − 64] = ˆθ[N + n − 64],
θ[N + n] = ˆθ[N + n − 64],
0 ≤ n ≤ 4
5 ≤ n ≤ 8
9 ≤ n ≤ 63
64 ≤ n ≤ 68
69 ≤ n ≤ 71
where N = 0, 72, 144, · · · .
Note that the CP (0 ≤ n ≤ 7) is exactly the same as the tail (64 ≤
n ≤ 71). Also, during the windowing operation, each OFDM symbol
is extended by one sample ˆθ[N +72] = ˆθ[N +8]. Since ˆθ[N +8] is set
to the first sample in the next symbol, θ[N +72], the windowing has
no effect on the waveform. (0.5·θ[N +72]+0.5· ˆθ[N +72] = θ[N +72].)
Since the CP insertion cannot be turned off in commercial chips,
signal degradation is unavoidable. However, by designing the wave-
form this way, the signal degradation is spread out between the first
and the last Bluetooth bits in every WiFi OFDM symbol. For these
two bits, the degradation is less than 250ns, which is shorter than
the bit duration of 1000ns. Furthermore, this short-term degrada-
tion will mostly appear as a high-frequency (1/250ns=4MHz) noise
and is likely to be attenuated/removed by the band-pass filter on a
Bluetooth receiver. The input, ϕ[n], that should be sent to the CP
insertion block can be calculated by removing CPs in ˆθ[n].
2.5 QAM
The CP insertion block is immediately preceded by IFFT and QAM
generator. Therefore, BlueFi first applies FFT to the reconstructed
input to the CP block to obtain the frequency-domain samples that
the QAM generator should generate.
Symbol 1CP(1) Insert CP(2) Extend 1 sampleSymbol 2CP(3) Average overlapped samples(cid:127)[ ]:!(cid:127) :CPFour possible modulation schemes (BPSK, QPSK, 16-QAM and
64-QAM) can be used in 802.11n to generate frequency-domain
samples and a higher-order modulation scheme corresponds to a
higher data rate. A higher-order modulation has more constellations
and hence comparatively higher resolution in the frequency domain.
However, even with 64-QAM, the resolution (8 levels or 3 bits in
either the real or imaginary part) is very limited, so we must select
each constellation carefully to minimize the error of quantizing the
real or imaginary part to one of the 8 levels.
Owing to this limitation, it is hard to design an end-to-end algo-
rithm that optimizes the reception performance. Specifically, the
restriction of input assuming discrete values can be treated as an
integer constraint. The reception performance can be measured by
how close the phase of the reconstructed time-domain signal is to
the original phase signal. The problem can thus be formulated as
an integer-programming (IP) problem. Note that there is no simple
formula relating the frequency-domain samples to the phases in
the time domain. Obviously, an exact solution can be obtained by
exhaustive search or branch-and-bound. However, the complexity
of exhaustive search is 6452 = 2312 since we can control the samples
on 52 frequencies (52 subcarriers for data in 802.11n). Even if we
try to only optimize with samples at 8 subcarriers (corresponding
to a bandwidth of 0.3125 · 8=2.5MHz), the complexity is 648 = 248.
Both are intractable on almost all computing platforms.
n(y[n])2 =
f (Y[f ])2 =
is the least-square fit,

n |x[n]− ˆx[n]|2 =
Therefore, BlueFi uses relaxation, a common practice for ap-
proximating the solution of an IP problem. In addition, we try
to find the best fit for the time-domain waveform instead of the
phase of this waveform since some analytical results can be de-
rived. Suppose for a time-domain waveform x[n], we want to find a
least-square fit ˆx[n] with the restriction that its frequency-domain
counterpart, ˆX[f ], only assumes discrete values. (That is, ˆX[f ] ∈
{a + bi | a ∈ {±1,±3,±5,±7}, b ∈ {±1,±3,±5,±7}}.) Since ˆx[n]
n |x[n] − ˆx[n]|2 is minimized. Let X[f ] =
F FT(x[n]) and let y[n] = x[n] − ˆx[n], then by Parseval’s Theorem,
f |X[f ]− ˆX[f ]|2.
Therefore, minimizing the time-domain residue is equivalent to
minimizing the frequency-domain residue.
For any given X[f ], if we set ˆX[f ] to the constellation with the
shortest Euclidean distance, then the objective function is mini-
mized. Since only the phase of the time-domain waveform matters
to a Bluetooth receiver, a scale factor A can be applied between the
time-domain reference and the phase: x[n] = A · ei·ϕ[n]. We set the
scale factor to 1
5. This value is chosen such that if the energy of a
Bluetooth waveform within one OFDM symbol is mainly concen-
trated on two subcarriers, each will have a magnitude of around 32
(=64/2) units, which is close to 35 (=7 · 5). We tested using dynamic
scale factors that further optimize the residue. The performance
difference is negligible but the complexity is significantly higher as
finding an optimal scale factor is still an IP problem. The process
of selecting ˆX[f ] is illustrated in Fig. 4.
2.6 Pilots and Nulls
Not all subcarriers are modulated by the incoming data. Pilot subcar-
riers are modulated by known sequences whereas null subcarriers
are always 0’s. Since we cannot control these pilots and nulls, we
solve the problem by frequency planning, leveraging the fact that
479
SIGCOMM ’21, August 23–28, 2021, Virtual Event, USA
Figure 4: Selecting ˆX[f ] from X[f ]. X[f ] = F FT(x[n]). A scale
factor A is applied (x[n] = A · ei·ϕ[n]) so that X[f ] is appropri-
ately scaled w.r.t. origin.
we can switch WiFi channels and there are large overlaps between
WiFi channels. For example, suppose we want to transmit on Blue-
tooth channel 38 (2426MHz), then this frequency is covered by WiFi
channels 2, 3, 4 and 5, and corresponds to subcarriers 28.8, 12.8, -3.2
and -19.2, respectively. We can calculate its distance to any pilots or
nulls and select the channel to keep the Bluetooth channel farthest
away from pilots or nulls. In this example, we should use WiFi
channel 3. Using channel 3, the closest pilot is 1.8125 (=5.8*0.3125)
MHz away, which is significantly larger than half the bandwidth of
Bluetooth signals.
2.7 FEC Coder
The FEC encoder adds redundancy to the bit-stream. Because of the
redundancy in its output, an FEC encoder cannot generate arbitrary
sequences. To reverse the operation of the encoder, we must build
a decoder. We focus on convolutional codes since they are manda-
tory in 802.11n (as opposed to the optional LDPC codes). An FEC
encoder can also be viewed as a decompressor whereas a decoder
can be viewed as a lossy compressor. Consequently, when we try
to reconstruct an output sequence from decoded bits, some of the
bits will be different from the original sequence since information
is lost when decoding the original sequence.
Convolutional codes can be optimally decoded by the Viterbi
algorithm [8, 9]. Since we are not dealing with over-the-air signals
that contain noise, we used hard decoding. The Viterbi algorithm
uses dynamic programming to find the input bits corresponding to
a sequence that has the least hamming distance (Euclidean distance
for soft decoding) to the received sequence. For this decoder, we
-7       -5        -3       -1         1        3         5         7 7531-1-3-5-7IQ(cid:127)0 (cid:127)0(cid:127)1 (cid:127)1(cid:127)!:FFT of GFSK Symbols (cid:127)!: Closest WiFiQAM SymbolWiFiSymbols (64-QAM)SIGCOMM ’21, August 23–28, 2021, Virtual Event, USA
Hsun-Wei Cho and Kang G. Shin
use the code rate of 5/6 as it has the minimal information loss in
the decoding process.
In the conventional Viterbi algorithm, every bit-flip (except for
the flip at punctured bits) has an equal weight and the algorithm
finds an optimal survival path that minimizes the total weight.
However, since Bluetooth signals only occupy part of the WiFi
spectrum, bits on subcarriers corresponding to the main Bluetooth
spectrum should have as few bit-flips as possible whereas the bit-
flips on other subcarriers do not really matter. In addition, since
bits are interleaved before being mapped to subcarriers, there will
be no long runs of bits mapped to the same or nearby subcarriers
since adjacent bits are mapped to subcarriers that are far apart.
Consequently, it is possible to modify the Viterbi algorithm to
further minimize the flips of bits that matter to Bluetooth reception.
Specifically, we can assign higher weights to those important bits
and the Viterbi algorithm will then find an optimal solution to
reduce bit-flips. For example, in Table 1, we calculated the location
the first few bits in an OFDM symbol will be mapped to. Assuming
subcarriers 9 to 16 correspond to the main Bluetooth spectrum,
we then assign the highest weight to bits on those subcarriers; a
medium weight to those on 4 subcarriers immediately adjacent to
subcarriers 9 to 16 on each side. The absolute value of these weights
is not critical since the goal is to assign the priority of each bit. For
example, the highest weight means that those bits will only flip if
there is no alternative.
For apps that require real-time packet generation, we further sim-
plify the decoding algorithm to significantly lower the complexity
while guaranteeing no important bits to flip. For a real-time decoder,