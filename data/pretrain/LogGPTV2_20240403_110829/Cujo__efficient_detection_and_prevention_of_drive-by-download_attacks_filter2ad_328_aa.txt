title:Cujo: efficient detection and prevention of drive-by-download attacks
author:Konrad Rieck and
Tammo Krueger and
Andreas Dewald
Cujo: Efﬁcient Detection and Prevention of
Drive-by-Download Attacks
Konrad Rieck
Machine Learning Group
Technische Universität Berlin,
Germany
konrad.rieck@tu-
berlin.de
Tammo Krueger
Intelligent Data Analysis
Fraunhofer Institute FIRST,
tammo.krueger@tu-
Germany
berlin.de
Andreas Dewald
Laboratory for Dependable
Distributed Systems
University of Mannheim,
Germany
andreas.dewald@uni-
mannheim.de
ABSTRACT
The JavaScript language is a core component of active and
dynamic web content in the Internet today. Besides its great
success in enhancing web applications, however, JavaScript
provides the basis for so-called drive-by downloads—attacks
exploiting vulnerabilities in web browsers and their exten-
sions for unnoticeably downloading malicious software. Due
to the diversity and frequent use of obfuscation in these at-
tacks, static code analysis is largely ineﬀective in practice.
While dynamic analysis and honeypots provide means to
identify drive-by-download attacks, current approaches in-
duce a signiﬁcant overhead which renders immediate pre-
vention of attacks intractable.
In this paper, we present Cujo, a system for automatic
detection and prevention of drive-by-download attacks. Em-
bedded in a web proxy, Cujo transparently inspects web
pages and blocks delivery of malicious JavaScript code. Static
and dynamic code features are extracted on-the-ﬂy and anal-
ysed for malicious patterns using eﬃcient techniques of ma-
chine learning. We demonstrate the eﬃcacy of Cujo in
diﬀerent experiments, where it detects 94% of the drive-
by downloads with few false alarms and a median run-time
of 500 ms per web page—a quality that, to the best of our
knowledge, has not been attained in previous work on de-
tection of drive-by-download attacks.
Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—
Security and protection; I.5.1 [Pattern Recognition]: Mod-
els—Statistical
Keywords
Drive-by downloads, web security, static code analysis, dy-
namic code analysis, machine learning
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ACSAC ’10 Dec. 6-10, 2010, Austin, Texas USA
Copyright 2010 ACM 978-1-4503-0133-6/10/12 ...$10.00.
1.
INTRODUCTION
The JavaScript language is a ubiquitous tool for provid-
ing active and dynamic content in the Internet. The vast
majority of web sites, including large social networks, such
as Facebook and Twitter, makes heavy use of JavaScript for
enhancing the appearance and functionality of their services.
In contrast to server-based scripting languages, JavaScript
code is executed in the web browser of the client and thus
provides means for directly interacting with the user and the
browser environment. Although the execution of JavaScript
code at the client is restricted by several security policies,
the interaction with the browser and its extensions alone
gives rise to a severe security threat.
JavaScript is increasingly used as basis for drive-by down-
loads, attacks exploiting vulnerabilities in web browsers and
their extensions for unnoticeably downloading malicious soft-
ware [see 15, 16]. These attacks take advantage of the tight
integration of JavaScript with the browser environment to
exploit diﬀerent types of vulnerabilities and eventually as-
sume control of the web client. Due to the complexity of
browsers and their extensions, there exist numerous of these
vulnerabilities, ranging from insecure interfaces of third-
party extensions to buﬀer overﬂows and memory corruptions
[5, 7, 11]. Four of the top ﬁve most attacked vulnerabilities
observed by Symantec in 2009 have been such client-side
vulnerabilities involved in drive-by-download attacks [2].
As a consequence, detection of drive-by downloads has
gained a focus in security research. Two classes of defense
measures have been proposed to counteract this threat: First,
several security vendors have equipped their products with
rules and heuristics for identifying malicious code directly
at the client. This static code analysis, however, is largely
obstructed by the frequent use of obfuscation in drive-by
downloads. A second strain of research has thus studied de-
tection of drive-by downloads using dynamic analysis, for
example using code emulation [8, 17], sandboxing [4, 6, 16]
and client honeypots [14, 16, 21]. Although eﬀective in de-
tecting attacks, these approaches suﬀer from either of two
shortcomings: Some approaches are limited to speciﬁc at-
tack types, such as heap spraying [e.g., 8, 17], whereas the
more general approaches [e.g., 4, 14] induce an overhead pro-
hibitive for preventing attacks at the client.
As a remedy, we present Cujo1, a system for detection
and prevention of drive-by-download attacks, which com-
bines advantages of static and dynamic analysis concepts.
1Cujo = “Classiﬁcation of Unknown Javascript cOde”
Embedded in a web proxy, Cujo transparently inspects web
pages and blocks delivery of malicious JavaScript code to
the client. The analysis and detection methodology imple-
mented in this system rests on the following contributions
of this paper:
• Lightweight JavaScript analysis. We devise eﬃcient
methods for static and dynamic analysis of JavaScript
code, which provide expressive analysis reports with
very small run-time overhead.
• Generic feature extraction. For the generic detection
of drive-by downloads, we introduce a mapping from
analysis reports to a vector space that is spanned by
short analysis patterns and independent of speciﬁc at-
tack characteristics.
• Learning-based detection. We apply techniques of ma-
chine learning for generating detection models for static
and dynamic analysis, which spares us from manually
crafting and updating detection rules as in current se-
curity products.
An empirical evaluation with 200,000 web pages and 600
real drive-by-download attacks demonstrates the eﬃcacy of
this approach: Cujo detects 94% of the attacks with a false-
positive rate of 0.002%, corresponding to 2 false alarms in
100,000 visited web sites, and thus is almost on par with
oﬄine analysis systems, such as Jsand [4]. In terms of run-
time, however, Cujo signiﬁcantly surpasses these systems.
With caching enabled, Cujo provides a median run-time of
500 ms per web page, including downloading of web page
content and full analysis of JavaScript code. To the best of
our knowledge, Cujo is the ﬁrst system capable of eﬀectively
and eﬃciently blocking drive-by downloads in practice.
The rest of this paper is organized as follows: Cujo and its
detection methodology are introduced in Section 2 including
JavaScript analysis, feature extraction and learning-based
detection. Experiments and comparisons to related tech-
niques are presented in Section 3. Related work is discussed
in Section 4 and Section 5 concludes.
2. METHODOLOGY
Drive-by-download attacks can take almost arbitrary struc-
ture and form, depending on the exploited vulnerabilities as
well as the use of obfuscation. Eﬃcient analysis and detec-
tion of these attacks is a challenging problem, which requires
careful balancing of detection and run-time performance.
We address this problem by applying lightweight static and
dynamic code analysis, thereby providing two complemen-
tary views on JavaScript code. To avoid manually crafting
detection rules for each of these views, we employ techniques
of machine learning, which enable generalizing from known
attacks and allow to automatically construct detection mod-
els. A schematic view of the resulting system is presented
in Figure 1.
Cujo is embedded in a web proxy and transparently in-
spects the communication between a web client and a web
service. Prior to delivery of web page data from the service
to the client, Cujo performs a series of analysis steps and
depending on their results blocks pages likely containing ma-
licious JavaScript code. To improve processing performance,
two analysis caches are employed: First, all incoming web
data is cached to reduce loading times and, second, analysis
Figure 1: Schematic depiction of Cujo.
results are cached, if all embedded and external code asso-
ciated with a web page has not changed within a limited
period of time.
2.1
JavaScript Analysis
As ﬁrst analysis step, we aim at eﬃciently getting a com-
prehensive view on JavaScript code. To this end, we in-
spect all HTML and XML documents passing our system
for occurrences of JavaScript. For each requested document,
we extract all code blocks embedded using the HTML tag
script and contained in HTML event handlers, such as on-
load and onmouseover. Moreover, we recursively pre-load all
external code referenced in the document, including scripts,
frames and iframes, to obtain the complete code base of the
web page. All code blocks of a requested document are then
merged for further static and dynamic analysis.
As an example used throughout the following sections, we
consider the JavaScript code shown in Figure 2. The code is
obfuscated using a simple substitution cipher and contains
a routine for constructing a NOP sled, an array of NOP
instructions common in most memory corruption attacks.
Analysis reports for the static and dynamic analysis of this
code snippet are shown in Figure 3 and 4, respectively.
1 a = "";
2 b = "{@xqhvfdsh+%(xzkloh+{1ohqjwk?4333,{.@{>";
3 for (i = 0; i "
1 SET global.a TO ""
2 SET global.b TO "{@xqhvfdsh+%(xzkloh
3
4 SET global.i TO "0"
5 CALL charCodeAt
6 SET global.c TO "120"
7 CALL fromCharCode
8 SET global.a TO "x"
9 ...
10 SET global.a TO "x=unescape("%u9090");
11
12 SET global.i TO "46"
13 CALL eval
14 CALL unescape
15 SET global.x TO ""
16 SET global.x TO ""
17 ...
18 SET global.x TO " ... 1024 bytes ... "
while(x.length<1000)x+=x;"
Figure 4: Example of dynamic analysis.
Although this lightweight analysis provides only a coarse
view on the behavior of JavaScript code in comparison to
oﬄine analysis [e.g., 4, 14, 21], it enables accurate detection
of drive-by downloads with a median run-time of less than
400 ms per web page, as demonstrated in Section 3.4. As an
example, Figure 4 shows a behavior report for the code snip-
pet given in Figure 2. The ﬁrst lines of the report cover the
decryption of the obfuscated string, which is ﬁnally revealed
in lines 10–11. Starting with the call to eval, this string is
evaluated by the interpreter and results in the construction
of a NOP sled with 1024 bytes in line 18.
2.2 Feature Extraction
In the second analysis step, we extract features from the
analysis reports of static and dynamic analysis, suitable for
application of detection methods.
In contrast to previous
work, we propose a generic feature extraction, which is in-
dependent of particular attack characteristics and allows to
jointly process reports of static and dynamic analysis.
2.2.1 Q-gram Features
Our feature extraction builds on the concept of q-grams,
which has been widely studied in the ﬁeld of intrusion detec-
tion [e.g., 10, 18, 22]. To unify the representation of static
and dynamic analysis, we ﬁrst partition each report into a
sequence of words using white-space characters. We then
move a ﬁxed-length window over each report and extract
subsequences of q words at each position, so-called q-grams.
The following example shows the extraction of q-grams with
q = 3 for two code snippets of static and dynamic analysis,
respectively,
ID = ID + NUM −→ ˘ (ID = ID), (= ID +), (ID + NUM)¯,
SET a.b to "x" −→ ˘ (SET a.b to), (a.b to "x")¯.
As a result of this extraction, each report is represented
by a set of q-grams, which reﬂect short patterns and provide
the basis for mapping analysis reports to a vector space.
Intuitively, we are interested in constructing a vector space,
where analysis reports sharing several q-grams lie close to
each other, while reports with dissimilar content are sepa-
rated by large distances. To establish such a mapping, we
associate each q-gram with one particular dimension in the
vector space. Formally, this vector space is deﬁned using the
set S of all possible q-grams, where a corresponding mapping
function for a report x is given by
φ : x →`φs(x)´
(
s∈S
with φs(x) =
1 if x contains the q-gram s,
0 otherwise.
The function φ maps a report x to the vector space R|S|