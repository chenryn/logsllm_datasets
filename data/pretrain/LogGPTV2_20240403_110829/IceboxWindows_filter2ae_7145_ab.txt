       +0x000 PageFrameNumber  : Pos 12, 36 Bits
       +0x000 Unused           : Pos 48, 16 Bits
在过渡状态下，PTE的目标物理地址的计算方法如下：
    PhysicalAddress = _MMPTE.u.Trans.PageFrameNumber * 0x1000 + PageOffset
###  2.4 分页文件PTE
随后，处在过渡状态的页面将被调出到磁盘上的页面文件中。这个步骤会将页面从物理内存中释放出来，并将其备份到磁盘，如下图所示：
对应的结构是之前已经查看过的`_MMPTE_SOFTWARE`，其中`Valid`、`Prototype`和`Transition`标志设置为0，但`PageFileHigh`并不是0。
    nt!_MMPTE_SOFTWARE
       +0x000 Valid                : Pos 0, 1 Bit     // 0
       +0x000 PageFileReserved     : Pos 1, 1 Bit
       +0x000 PageFileAllocated    : Pos 2, 1 Bit
       +0x000 ColdPage             : Pos 3, 1 Bit
       +0x000 SwizzleBit           : Pos 4, 1 Bit
       +0x000 Protection           : Pos 5, 5 Bits
       +0x000 Prototype            : Pos 10, 1 Bit    // 0
       +0x000 Transition           : Pos 11, 1 Bit    // 0
       +0x000 PageFileLow          : Pos 12, 4 Bits
       +0x000 UsedPageTableEntries : Pos 16, 10 Bits
       +0x000 ShadowStack          : Pos 26, 1 Bit
       +0x000 Unused               : Pos 27, 5 Bits
       +0x000 PageFileHigh         : Pos 32, 32 Bits  // !=0
在这种情况下，检索页面内容的唯一方法是从相应的页面文件中将其读取回来。默认情况下，操作系统按驱动器定义一个页面文件。每个分页文件由索引进行标识。在备份页面时，目标页面文件索引对应于`PageFileLow`字段，文件中的页面偏移量（`PageFileOffset`）解析如下：
    PageFileOffset = _MMPTE.u.Soft.PageFileHigh * 0x1000 + PageOffset
###  2.5 Demand-zero PTE
操作系统没有保存零填充的页面，而是仅仅将这个信息保留在相应的PTE结构中。当必须要还原此类页面时，平衡集管理器将从零页表中获取一个并更新相应的PTE。零页表将由零页面线程（`MiZeroPageThread`）维护，以满足需要使用零的页面错误。
全零页面中包含一个非空的PTE值（`_MMPTE.u.Long`），但在`_MMPTE_SOFTWARE`结构中，以下标志被设置为零，分别是：`Valid`、`Prototype`、`Transition`和`PageFileHigh`。
    nt!_MMPTE_SOFTWARE
       +0x000 Valid                : Pos 0, 1 Bit     // 0
       +0x000 PageFileReserved     : Pos 1, 1 Bit
       +0x000 PageFileAllocated    : Pos 2, 1 Bit
       +0x000 ColdPage             : Pos 3, 1 Bit
       +0x000 SwizzleBit           : Pos 4, 1 Bit
       +0x000 Protection           : Pos 5, 5 Bits
       +0x000 Prototype            : Pos 10, 1 Bit    // 0
       +0x000 Transition           : Pos 11, 1 Bit    // 0
       +0x000 PageFileLow          : Pos 12, 4 Bits
       +0x000 UsedPageTableEntries : Pos 16, 10 Bits
       +0x000 ShadowStack          : Pos 26, 1 Bit
       +0x000 Unused               : Pos 27, 5 Bits
       +0x000 PageFileHigh         : Pos 32, 32 Bits  // 0
###  2.6 Prototype PTE
原型PTE（Prototype PTE）用于描述由内存段（Section
Objects）表示的内存。可以通过`CreateFileMapping`函数来创建段对象，然后使用`OpenFileMapping`打开该段对象，并使用`MapViewOfFile`进行映射。基本上，段对象应该对应于共享内存，如下图所示：
我们有两个进程，每个进程拥有一个相同的段对象（sectionX），它们指向相同的物理页面。在这里，所有PTE都是有效的。
在这里有一个与操作系统相关的难点，就是同步共享页面的裁剪。实际上，由于多个PTE可以引用同一个物理页面，因此如果操作系统决定从物理内存中删除共享页面，则它必须查找引用该页面的所有PTE，并更新其当前状态。由于这种方法看起来效率很低，因此Windows使用了原型PTE来解决这一问题。
有关原型PTE及其与段对象关系的完整说明，各位读者可以参考：
简而言之，当平衡集管理器裁剪共享页面时，会在相应的PTE中设置`_MMPTE.u.Soft.Prototype`标志。在这种情况下，涉及到的结构是`_MMPTE_PROTOTYPE`，其定义如下：
    nt!_MMPTE_PROTOTYPE
       +0x000 Valid                : Pos 0, 1 Bit   // 0
       +0x000 DemandFillProto      : Pos 1, 1 Bit
       +0x000 HiberVerifyConverted : Pos 2, 1 Bit
       +0x000 ReadOnly             : Pos 3, 1 Bit
       +0x000 SwizzleBit           : Pos 4, 1 Bit
       +0x000 Protection           : Pos 5, 5 Bits
       +0x000 Prototype            : Pos 10, 1 Bit  // 1
       +0x000 Combined             : Pos 11, 1 Bit
       +0x000 Unused1              : Pos 12, 4 Bits
       +0x000 ProtoAddress         : Pos 16, 48 Bits
在这个结构中，`ProtoAddress`指向另一个名为prototype PTE的PTE。而这个在内核`PagedPool`中分配的prototype
PTE实际上描述了当前页面的状态。从那时开始，在删除页面时，操作系统只需要更新相应的prototype PTE即可。
现在，原型PTE本身可以表示所有此前描述过的状态，包括`valid`、`transition`、`paged`、`demand
zero`。理论上，也可以是其他状态，但这里并不涉及虚拟地址转换。
例如，下图说明了处于过渡状态的原型PTE，这表明其`PageFrameNumber`仍然以具有有效内容的物理页面为目标：
###  2.7 Subsection PTE
考虑到映像文件映射，系统依靠原型PTE实现了特殊的优化。在这些文件中，包括几个不可写的常量页面。这样一来，系统就无须备份页面文件中已驻留在原始文件中的此类页面。
为了处理这种情况，系统会在目标原型PTE中设置`PTE.u.Soft.Prototype`标志。然后，这个PTE的对应结构是`_MMPTE_SUBSECTION`，其定义如下：
    nt!_MMPTE_SUBSECTION
       +0x000 Valid             : Pos 0, 1 Bit    // 0
       +0x000 Unused0           : Pos 1, 3 Bits
       +0x000 SwizzleBit        : Pos 4, 1 Bit
       +0x000 Protection        : Pos 5, 5 Bits
       +0x000 Prototype         : Pos 10, 1 Bit   // 1
       +0x000 ColdPage          : Pos 11, 1 Bit
       +0x000 Unused1           : Pos 12, 3 Bits
       +0x000 ExecutePrivilege  : Pos 15, 1 Bit
       +0x000 SubsectionAddress : Pos 16, 48 Bits
下图说明了从两个工作集中删除`ntdll.dll`页面的情况：
这里无需过于详细地说明，`_MMPTE.u.Subsect.SubsectionAddress`指向的是`_CONTROL_AREA`结构，该结构本身指向`_FILE_OBJECT`。
但遗憾的是，如果不读取文件系统上的原始映像文件，则无法访问Subsection PTE的内容。
###  2.8 基于VAD的PTE
最后的优化是由Windows实现的。当PTE值为空（`_MMPTE.u.Long=0`）时，必须检查虚拟地址描述符（VAD）进程，以找到相应的原型PTE（在Windows内部和rekall项目中的VAD
Hardware
PTE中，将该状态命名为unknown）。当设置`_MMPTE.u.Soft.Prototype`标志并且`PTE.u.Proto.ProtoAddress`等于`0xFFFFFFFF0000`时（在Windows中，该状态称为虚拟地址描述符；在rekall项目中，该状态称为VAD
Prototype PTE），情况相同。
    nt!_MMPTE_PROTOTYPE
       +0x000 Valid                : Pos 0, 1 Bit     // 0
       +0x000 DemandFillProto      : Pos 1, 1 Bit
       +0x000 HiberVerifyConverted : Pos 2, 1 Bit
       +0x000 ReadOnly             : Pos 3, 1 Bit
       +0x000 SwizzleBit           : Pos 4, 1 Bit
       +0x000 Protection           : Pos 5, 5 Bits
       +0x000 Prototype            : Pos 10, 1 Bit    // 1
       +0x000 Combined             : Pos 11, 1 Bit
       +0x000 Unused1              : Pos 12, 4 Bits
       +0x000 ProtoAddress         : Pos 16, 48 Bits  // 0xFFFFFFFF0000
下图说明了在这种情况下，如何访问所需的原型PTE。
首先，这种基于VAD的情况仅在用户进程的上下文中发生。从相应的`_EPROCESS`结构（蓝色）开始，我们必须找到相应的存储区。这个区域被称为“虚拟地址描述符”（VAD），由`_MMVAD`内核结构定义。每个进程都拥有一组VAD，这些VAD从`VadRoot`字段开始组成一个自平衡的AVL树。简而言之，每个VAD都有一个起始地址（`StartingVpn`代表虚拟起始页编号）和一个终止地址（`EndingVpn`）字段。有以下三种可能的情况：
1、所需地址在`StartingVpn`以下，将考虑左子树（红色）；
2、所需地址在`EndingVpn`以上，将考虑右子树（蓝色）；
3、否则，所需的地址位于`StartingVpn`和`EndingVpn`定义的范围内，即找到所需的VAD（深灰色）。
现在，每个VAD都将一组原型PTE作为`FirstPrototype`字段公开。由于原型PTE都是4KB的页面，因此可以轻松计算出目标原型PTE（深绿色）。最后，就可以对获得的原型PTE进行处理。
###  2.9 缓解L1终端故障（Foreshadow）
自2018年8月开始，对上述虚拟地址转换方法进行了改进。目前，如果只在虚拟地址上使用`!pte kd`命令可能会输出以下结果：