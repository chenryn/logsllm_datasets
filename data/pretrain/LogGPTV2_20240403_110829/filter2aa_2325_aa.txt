© Copyright 2013 NCC Group  
An NCC Group Publication 
Revealing Embedded Fingerprints: Deriving 
Intelligence from USB Stack Interactions 
Prepared by: 
Andy Davis 
Research Director 
andy.davis ‘at’ nccgroup.com 
NCC Group | Page 2 
© Copyright 2013 NCC Group 
Contents 
1 
List of Figures and Tables .......................................................................................................... 3 
2 
Introduction .................................................................................................................................. 4 
2.1 
Previous Research ................................................................................................................ 4 
3 
USB Background: The Enumeration Phase in Detail ............................................................... 4 
4 
USB Testing Platform .................................................................................................................. 8 
5 
USB Stack Implementations ....................................................................................................... 9 
6 
Identifying Supported Devices ................................................................................................. 10 
6.1 
USB Device Classes ........................................................................................................... 10 
6.2 
Enumerating Installed Class Drivers ................................................................................... 12 
6.3 
Other Devices Already Connected...................................................................................... 13 
7 
Fingerprinting Techniques ....................................................................................................... 14 
7.1 
Operating System Identification .......................................................................................... 14 
7.2 
Application Identification ..................................................................................................... 14 
7.3 
Timing Information .............................................................................................................. 15 
7.4 
Descriptor Types Requested .............................................................................................. 16 
7.5 
Responses to Invalid Data .................................................................................................. 17 
8 
Umap ........................................................................................................................................... 17 
9 
Conclusions ............................................................................................................................... 23 
10 
References and Further Reading ........................................................................................ 24 
11 
Glossary ................................................................................................................................. 24 
NCC Group | Page 3 
© Copyright 2013 NCC Group 
1 List of Figures and Tables 
Figure 1: The use of a Facedancer board in conjunction with a Packet-master USB analyser  
Figure 2: Enumeration stops at “Set Configuration” when a device class is not supported 
Figure 3: Enumeration continues past the “Set Configuration” when a device class is supported 
Figure 4: A Packet-master capture showing multiple USB devices connected to the same bus 
Figure 5: Linux-based TV Set-Top-Box                                    
Figure 6: Windows 8 
Figure 7: gphoto2 (Linux)                                                             
Figure 8: “Photos” Metro app (Windows 8) 
Figure 9: USB timing information during enumeration 
Figure 10: Umap basic help 
Figure 11: The USB device classes that umap currently understands 
Figure 12: Umap identifying supported classes, sub-classes and protocols 
Figure 13: The umap VID/PID lookup facility 
Figure 14: The umap operating system identification capability 
Figure 15: Umap emulating a USB camera 
Figure 16: Generic USB fuzz test cases 
Figure 17: Class-specific USB fuzz test cases 
Figure 18: Umap fuzzing a USB host 
Table 1: Get Device descriptor request 
Table 2: Device descriptor  
Table 3: Configuration descriptor 
Table 4: Interface descriptor 
Table 5: Endpoint descriptor 
Table 6: HID descriptor 
Table 7: String descriptor 
Table 8: Set Configuration request 
Table 9: USB Device classes 
Table 10: Hub class information in a Device descriptor 
Table 11: Image class information in an Interface descriptor 
Table 12: VID and PID information in a Device descriptor 
Table 13: Microsoft OS descriptor request 
NCC Group | Page 4 
© Copyright 2013 NCC Group 
2 Introduction 
Embedded systems are everywhere, from TVs to aircraft, printers to weapons control systems. As a 
security researcher when you are faced with one of these black boxes to test, sometimes in situ, it is 
difficult to know where to start. However, if there is a USB port on the device. there is useful 
information that can be gained. In this paper we will show how USB stack interaction analysis can be 
used to provide information such as the OS running on the embedded device, the USB drivers 
installed, and the devices supported. When testing the security of a USB host stack, knowledge of 
the installed drivers will increase the efficiency of the testing process dramatically. 
2.1 Previous Research 
There has been plenty of previous research into the security of USB in recent years, which has 
mainly focussed on different approaches to enable USB hosts to be tested for vulnerabilities 
[Davis][Dominguez Vega][Larimer]. However, the author is only aware of one reference to research 
involving the use of USB interactions to identify information about the host stack [Goodspeed]. 
3 USB Background: The Enumeration Phase in Detail 
USB is a master-slave protocol, with the host as the master and devices as slaves. Only the master 
can make requests to slaves and not the other way round, which poses a problem as we are trying to 
identify information about the configuration of the host from the perspective of a slave (device). 
Therefore we need to observe the way the host requests information in great detail, and also to 
provide potentially unexpected answers to the host’s requests, generating unique behaviour in the 
host, which can then also be observed.  
The initial communication any USB device has with a host is during enumeration. Enumeration is the 
mechanism by which a USB host determines the status, configuration, and capabilities of an inserted 
USB device. The process begins when a device is mechanically inserted into the host and follows a 
number of steps: 
There are four lines on a USB connector: Vcc (+5V), GND (0V), positive data (D+) and negative data 
(D-). Prior to a device being connected, D+ and D- are connected to GND via a 15K resistor. At the 
point of insertion, different resistors and differential signals are used to determine the speed of the 
connected device: 
A low speed device (1.5Mbps) connects D- to Vcc via a 1K5 pull-up resistor  
A full speed device (12Mbps) connects D+ to Vcc via a 1K5 pull-up resistor 
A high speed device (480Mbps) connects D+ to Vcc via a 1K5 pull-up resistor (and hence 
initially appears to be a full speed device). The host then attempts to communicate at 
480Mbps with the device using J and K chirps (a J chirp is a differential signal on D+ and D- 
>= +300mV, whereas a K chirp is >= -300mV). If the communication fails the host assumes 
the device is a full speed device rather than a high speed device. 
Now that the host knows what speed it can use to communicate with the device, it can start 
interrogating it for information. An 8-byte SETUP packet called the setup transaction (Table 1) is sent 
by the host in the first phase of a control transfer. It contains the request “GET_DESCRIPTOR” (for 
the device descriptor) and is sent using address 0.  
The device then responds with an 18-byte device descriptor, also on address 0 (Table 2). 
NCC Group | Page 5 
© Copyright 2013 NCC Group 
Table 1: Get Device descriptor request 
Table 2: Device descriptor  
Table 3: Configuration descriptor 
Field 
Value 
Meaning 
bmRequestType (direction) 
1 
Device-to-host 
bmRequestType (type) 
0 
Standard 
bmRequestType (recipient) 
0 
Device 
bRequest 
0x06 
Get Descriptor 
wValue 
0x0100 
DEVICE Index = 0 
wIndex 
0x0000 
Zero 
wLength 
0x0040 
Length requested = 64 
Field 
Value 
Meaning 
bLength 
18 
Descriptor length (including the bLength field) 
bDescriptorType 
1 
Device descriptor 
bcdUSB 
0x0110 
Spec version 
bDeviceClass 
0x00 
Class information stored in Interface descriptor 
bDeviceSubClass 
0x00 
Class information stored in Interface descriptor 
bDeviceProtocol 
0x00 
Class information stored in Interface descriptor 
bMaxPacketSize0 
8 
Max EP0 packet size 
idVendor 
0x413c 
Dell Inc 
idProduct 
0x2107 
Unknown 
bcdDevice 
0x0178 
Device release number 
iManufacturer 
1 
Index to Manufacturer string 
iProduct 
2 
Index to Product string 
iSerialNumber 
0 
Index to serial number 
bNumConfigurations 
1 
Number of possible configurations 
Field 
Value 
Meaning 
bLength 
9 
Descriptor length (including the bLength field) 
bDescriptorType 
2 
Configuration descriptor 
wTotalLength 
34 
Total combined size of this set of descriptors 
bNumInterfaces 
1 
Number of interfaces supported by this configuration 
bConfigurationValue 
1 
Value to use as an argument to the SetConfiguration() 
request to select this configuration 
iConfiguration 
0 
Index of String descriptor describing this configuration 
bmAttributes (Self-powered) 
0 
Bus-powered 
bmAttributes (Remote 
wakeup) 
1 
Yes 
bmAttributes (Other bits) 
0x80 
Valid 
bMaxPower 
100mA 
Maximum current drawn by device in this configuration 
NCC Group | Page 6 
© Copyright 2013 NCC Group 
The most important data in the device descriptor is: 
Device class information (if present) 
Maximum packet size in bytes of Endpoint 0  
Vendor and Product IDs (VID and PID) 
Number of configurations 
The host resets the device, allocates an address to it (in the range of 1 to 127) and then re-requests 
the device descriptor using the new address. 
For each possible configuration, the host will request a configuration descriptor, an example of which 
is shown in Table 3. The configuration descriptor includes a number of further descriptors (interface 
and endpoint, examples of which are shown in tables 4 and 5 respectively); however, the primary 
fields of interest are: 
Number of interfaces supported by this configuration 
The power attributes that indicate if the device is self- or bus-powered and the maximum 
current the device will draw. 
Table 4: Interface descriptor 
Table 5: Endpoint descriptor 
Field 
Value 
Meaning 
bLength 
9 
Descriptor length (including the bLength field) 
bDescriptorType 
4 
Interface descriptor 
bInterfaceNumber 
0 
Number of this interface 
bAlternateSetting 
0 
Value used to select this alternative setting for the 
interface identified in the prior field 
bNumberEndpoints 
1 
Number of endpoints used by this interface 
bDeviceClass 
0x03 
HID 
bDeviceSubClass 
0x01 
Boot interface 
bDeviceProtocol 
0x01 
Keyboard 
iInterface 
0 
Index of string descriptor describing this interface 
Field 
Value 
Meaning 
bLength 
7 
Descriptor length (including the bLength field) 
bDescriptorType 
5 
Endpoint descriptor 
bEndpointAddress 
0x81 
Endpoint 1 – OUT 
bmAttributes 
0x03 
Interrupt data endpoint 
wMaxPacketSize  
0x0008 
Maximum packet size is 8 
bInterval 
0x0a 
10 frames (10ms) 
NCC Group | Page 7 
© Copyright 2013 NCC Group 
Within the interface descriptor, the important information is: 
Number of endpoints 
Class information (interface-specific information not provided in the device descriptor) 
An endpoint descriptor contains: 
The endpoint address and type 
The maximum packet size in bytes of the endpoint 
Sometimes class-specific descriptors are included within the configuration, for example the HID 
descriptor in Table 6: 
Table 6: HID descriptor 
If there are multiple configurations for a device then further configuration (as well as interface, 
endpoint, etc.) descriptors will be requested. 
The next descriptors requested are string descriptors, which provide human-readable information 
about the device type and vendor. An example is shown in Table 7. 
Table 7: String descriptor 
The final step is for the host to select one of the device configurations and inform the device that it 
will be using that configuration. This is performed by issuing a “Set Configuration” request, as shown 
in Table 8. 
Field 
Value 
Meaning 
bLength 
9 
Descriptor length (including the bLength field) 
bDescriptorType 
0x21 
HID 
bcdHID 
0x0110 
HID Class Spec Version 
bCountryCode 
0 
Not Supported 
bNumDescriptors 
1 
Number of Descriptors 
bDescriptorType 
34 
Report descriptor 
wDescriptorLength 
65 
Descriptor length 
Field 
Value 
Meaning 
bLength 
48 
Descriptor length (including the bLength field) 
bDescriptorType 
3 
String descriptor 
bString 
“Dell USB 
Entry 
Keyboard” 
NCC Group | Page 8 
© Copyright 2013 NCC Group 
Table 8: Set Configuration request 
The enumeration phase is now complete, with the USB device configured and ready to use. From 
now until the device is removed, class-specific communication is used between the device and the 
host. However, as we will discuss later, there are variations to this enumeration phase which can be 
used to fingerprint different host implementations. 
4 USB Testing Platform 
Additional hardware is needed to interact with USB, so that different USB devices can be emulated. 
There are a number of requirements for this testing platform: 
The ability to both capture and replay USB traffic: There are many USB analyser tools available, 
but only a few that allow captured traffic to be replayed; an ability that is crucial in this instance. 
Full control of generated traffic: Many test-equipment-based solutions restrict the user to 
generating traffic that conforms to the USB specification. We need full control of all aspects of any 
generated traffic, as the host many behave in an unexpected way if it receives unconventional data, 
which is what we are hoping to observe. 
Class decoders are extremely useful: For each USB device class (e.g. mass storage, printer), 
there are separate specification documents that detail the class-specific communications protocols. 
Having an application that understands and decodes these protocols makes understanding the class 
communication significantly easier.  
Support for multiple speeds: USB devices, depending on their function, operate at a number of 
different speeds; therefore the ability to capture and generate data at these different speeds is 
crucial if the whole range of devices is to be emulated.   
The solution chosen for this project comprised two primary components: A commercial USB analyser 
and generator – Packet-Master [MQP], and a bespoke device emulation board called Facedancer 
[GoodFET]. Figure 1 shows how they are used together. 
Figure 1: The use of a Facedancer board in conjunction with a Packet-master USB analyser  
Field 
Value 
Meaning 
bmRequestType (direction) 
0 
Host-to-device 
bmRequestType (type) 
0 
Standard 
bmRequestType (recipient) 
0 
Device 
bRequest 
0x09 
Set Configuration 
wValue 
0x0001 
Configuration No. 
wIndex 
0x0000 
Zero 
wLength 
0x0000 
Zero 
NCC Group | Page 9 
© Copyright 2013 NCC Group 
The benefit of using both devices is that fully arbitrary USB traffic can be generated by Facedancer, 
acting as a USB device, and the responses from the host under test can be captured by the Packet-
Master appliance. However, for the majority of the techniques described in this paper, just a 
Facedancer board would suffice. 
5 USB Stack Implementations 
USB is quite a complex protocol, especially as it provides backward compatibility to support older, 
slower devices. Therefore, implementations of the host stack on different operating systems can 
behave in different ways, as we hoped to observe during this research. Typical components within a 
USB host stack are as follows:  
Host controller hardware: This performs the low-level timing and electrical aspects of the protocol 
and is communicated with via a host controller interface. 
Host controller interface (HCI): There are a number of different HCIs that have been developed 
over the years, all of which have different capabilities, but the primary difference is their ability to 
support devices running at different speeds; they are: 
oHCI (Open Host Controller Interface) 