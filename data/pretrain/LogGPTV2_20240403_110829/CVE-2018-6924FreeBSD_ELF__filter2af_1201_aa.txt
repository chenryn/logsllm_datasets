# CVE-2018-6924：解析FreeBSD ELF 头导致内核内存泄露
|
##### 译文声明
本文是翻译文章，文章原作者 quarkslab，文章来源：blog.quarkslab.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
2018年9月，FreeBSD发布了安全公告 **FreeBSD-SA-18：12** ，修复了影响该操作系统所有版本的内核内存泄露漏洞。
此漏洞（标识为`CVE-2018-6924`）是由FreeBSD内核在执行二进制文件之前解析二进制文件的ELF头时验证不充分引起的，本地非特权用户可以用它泄露内核的内存内容。
## 0x01 介绍
2018年9月12日，FreeBSD发布了安全公告[FreeBSD-SA-18：12](https://www.freebsd.org/security/advisories/FreeBSD-SA-18:12.elf.asc)，修复了CVE-2018-6924，这是由Thomas Barabosch和Mark
Johnston发现的内核内存泄漏漏洞，由内核中错误的ELF头解析引起。如公告中所述，“执行恶意ELF二进制文件可能会导致内核崩溃或泄露内核内存”。有趣的是，所有受支持的FreeBSD版本都受到这个bug的影响，包括版本10,10.4,11,11.1和11.2。
这里提供的分析基于`FreeBSD 11.2-RELEASE x64`，运行`GENERIC`内核。
## 0x02 修复情况
安全公告中包含指向修复的源代码补丁[链接](https://security.FreeBSD.org/patches/SA-18:12/elf.patch)。让我们先来看看它：
    --- sys/kern/imgact_elf.c.orig
    +++ sys/kern/imgact_elf.c
    @@ -839,7 +839,8 @@
                break;
            case PT_INTERP:
                /* Path to interpreter */
    -                   if (phdr[i].p_filesz > MAXPATHLEN) {
    +                   if (phdr[i].p_filesz  MAXPATHLEN) {
                    uprintf("Invalid PT_INTERPn");
                    error = ENOEXEC;
                    goto ret;
    @@ -870,6 +871,11 @@
                } else {
                    interp = __DECONST(char *, imgp->image_header) +
                        phdr[i].p_offset;
    +                           if (interp[interp_name_len - 1] != '') {
    +                                   uprintf("Invalid PT_INTERPn");
    +                                   error = ENOEXEC;
    +                                   goto ret;
    +                           }
                }
                break;
            case PT_GNU_STACK:
    --- sys/kern/vfs_vnops.c.orig
    +++ sys/kern/vfs_vnops.c
    @@ -528,6 +528,8 @@
        struct vn_io_fault_args args;
        int error, lock_flags;
    +   if (offset v_type != VCHR)
    +           return (EINVAL);
        auio.uio_iov = &aiov;
        auio.uio_iovcnt = 1;
        aiov.iov_base = base;
此处有两个修改过的文件：`sys/kern/imgact_elf.c`和`sys/kern/vfs_vnops.c`。sys/kern/imgact_elf.c文件中包含内核用于在执行二进制文件之前解析二进制文件的ELF头的代码，修复后的函数是这样的：
    776 static int
    777 __CONCAT(exec_, __elfN(imgact))(struct image_params *imgp)
    778 {
        [...]
因此，影响函数的名称是由`__CONCAT`和`__elfN`宏生成的。[__CONCAT](https://svnweb.freebsd.org/base/release/11.2.0/sys/sys/cdefs.h?revision=335563&view=markup#l143)连接两个参数，而__elfN在[sys/sys/elf_generic.h](https://svnweb.freebsd.org/base/release/11.2.0/sys/sys/elf_generic.h?revision=335563&view=markup#l53)中定义如下：
    #define __elfN(x)       __CONCAT(__CONCAT(__CONCAT(elf,__ELF_WORD_SIZE),_),x)
因此，函数名`___CONCAT(exec_,
__elfN(imgact))`扩展为`exec_elf32_imgact`或`exec_elf64_imgact`，具体取决于`__ELF_WORD_SIZE`定义为32还是64。但是如果我们检查`sys/kern/`目录，会发现存在名为`imgact_elf32.c`和`imgact_elf64.c`的两个非常小的文件，它们是将`__ELF_WORD_SIZE`定义为正确的大小，包含（include）了`kern/imgact_elf.c`文件，该文件包含易受攻击的函数。因此，内核包含了`sys/kern/imgact_elf.c`中任何函数的两个版本，其名称用_`_elfN`宏构建：一个版本处理32位ELF二进制文件，另一个版本处理64位ELF文件。
`imgact_elf32.c`：
    #define __ELF_WORD_SIZE 32
    #include 
`imgact_elf64.c`：
    #define __ELF_WORD_SIZE 64
    #include 
继续观察补丁，很明显问题位于处理ELF文件`PT_INTERP`程序头的代码中：
    static int
    __CONCAT(exec_, __elfN(imgact))(struct image_params *imgp)
    {
        [...]
        for (i = 0; i e_phnum; i++) {
            switch (phdr[i].p_type) {
            [...]
            case PT_INTERP:
                /* Path to interpreter */
                if (phdr[i].p_filesz > MAXPATHLEN) {
                    uprintf("Invalid PT_INTERPn");
                    error = ENOEXEC;
                    goto ret;
                }
                [...]
`PT_INTERP`程序头保存了程序解释器的路径名，该类型仅对可执行文件有意义。
`PT_INTERP`程序头引用的可执行文件用作动态链接器，负责为动态链接的可执行文件加载所需的共享库。通常，`FreeBSD`上的程序解释器设置为[/libexec/ld-elf.so.1](https://www.freebsd.org/cgi/man.cgi?query=ld-elf.so)。
作为参考，[这是](https://svnweb.freebsd.org/base/release/11.2.0/sys/sys/elf32.h?revision=335563&view=markup#l102)32位ELF文件`Elf_Phdr`结构的指定版本：
    typedef struct {
        Elf32_Word      p_type;         /*输入类型*/
        Elf32_Off       p_offset;       /*文件偏移量 */
        Elf32_Addr      p_vaddr;        /* 内存映像中的虚拟地址. */
        Elf32_Addr      p_paddr;        /* 物理地址（未使用） */
        Elf32_Word      p_filesz;       /* 文件中的内容大小*/
        Elf32_Word      p_memsz;        /* 内存中的内容大小 */
        Elf32_Word      p_flags;        /* 访问权限标志 */
        Elf32_Word      p_align;        /* 内存和文件中的对齐方式 */
    } Elf32_Phdr;
易受攻击的老版本仅检查`phdr [i] .p_filesz>
MAXPATHLEN`，即它检查`PT_INTERP`程序头文件中的内容的大小（即解释器路径的长度）是否比`MAXPATHLEN`（1024）大;如果大，该功能很快就会出现`ENOEXEC`错误。
另一方面，修复版本中添加了一个检查：当`phdr [i] .p_filesz
 Fix several reads beyond the mapped first page of the binary in the  
>  ELF parser. Specifically, do not allow note reader and interpreter  
>  path comparision in the brandelf code to read past end of the page.  
>  This may happen if specially crafter ELF image is activated.
这说明`sys/kern/imgact_elf.c`文件已经受到与解释器路径处理相关的漏洞的影响。具体来说，这个老版本的bug讲述了“特制的ELF镜像(specially
crafted ELF image)”触发“读取二进制文件超出映射第一页的内容(reads beyond the mapped first page of
the binary)”的内容。对我来说，这听起来像是在第一页末尾的那些内存读取可能导致内核内存的泄露，这激发了我的灵感！
## 0x04 建立概念验证