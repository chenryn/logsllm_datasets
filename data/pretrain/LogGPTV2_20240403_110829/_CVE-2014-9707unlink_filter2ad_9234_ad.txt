    ```
    Breakpoint 2, 0xb7fb65ac in websNormalizeUriPath (
        pathArg=0x805bcc0 "/y05b/y05b230362377277?y05b", 'A' ...) at src/http.c:3227
    3227             if ((path = walloc(len + nseg + 1)) != 0) {
    gdb-peda$ x/10x $esp
    0xbffff230:        0x0000040a     0x0805bcc0      0x00000000     0x0805c1e9
    0xbffff240:        0x0805d8ac     0xb7faa388      0xb7fb5fd9       0x00000402
    0xbffff250:        0x0805ddd6     0x0805c728
    ```
这里注意一下esp的值，返回中esp中存放的值是40a，也就是1034，就是缓冲区的长度，接下来到达一处非常关键的for循环。
    ```
        if ((path = walloc(len + nseg + 1)) != 0) {
            for (i = 0, dp = path; i ...) at src/http.c:3232
    3232                     if (++i ...) at src/http.c:3232
    3232                     if (++i ...) at src/http.c:3232
    3232                     if (++i ...) at src/http.c:3232
    3232                     if (++i ...) at src/http.c:3232
    3232                     if (++i ...) at src/http.c:3232
    3232                     if (++i ...) at src/http.c:3232
    3232                     if (++i ...) at src/http.c:3238
    3238             wfree(dupPath);
    3+132+3+2+2c2+2c2 = 6be = 1726
    ```
可以看到，一共拷贝了8次，总共拷贝了1726，在整个拷贝过程中，eax监视的是拷贝的长度，算一下总和，已经超过了1034，那么由此就会造成堆溢出。
接下来执行，发生堆溢出，到达漏洞位置。
    ```
    gdb-peda$ c
    Continuing.
    Program received signal SIGABRT, Aborted.
    [----------------------------------registers-----------------------------------]
    EAX: 0x0 
    EBX: 0xef3 
    ECX: 0xef3 
    EDX: 0x6 
    ESI: 0x45 ('E')
    EDI: 0xb7eec000 --> 0x1a5da8 
    EBP: 0xbffff178 --> 0x805cb30 --> 0x73 ('s')
    ESP: 0xbfffeeb4 --> 0xbffff178 --> 0x805cb30 --> 0x73 ('s')
    EIP: 0xb7fdebe0 (:     pop    ebp)
    EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0xb7fdebdc :        nop
       0xb7fdebdd :        nop
       0xb7fdebde :        int    0x80
    => 0xb7fdebe0 :         pop    ebp
       0xb7fdebe1 :        pop    edx
       0xb7fdebe2 :        pop    ecx
       0xb7fdebe3 :        ret    
       0xb7fdebe4:       int3
    ```
总结一下整个漏洞的形成过程，在goahead中，程序会开启监听socket进程，之后会有一个函数用于处理接收到的数据包。在收到url后，会对url进行进一步处理，在处理的过程中，由于对.的控制逻辑混乱，导致处理结束后的判断长度和之前的长度不等，从而可以导致超长串考入先前申请长度的缓冲区，引发堆溢出漏洞。
**  
**
**从漏洞分析到漏洞模型**
实际上要利用这个漏洞，其实对于Linux二进制攻防熟悉的大牛肯定已经知道就是利用unlink来对堆进行攻击，其实这个漏洞非常有意思，是因为它有一个非常基础的漏洞模型，下面我们一起来把这个漏洞模型还原出来。
首先我们再来回顾一下发生漏洞的源码部分。  
    ```
    PUBLIC char *websNormalizeUriPath(char *pathArg)
    {
        …… 省略一部分
        len = (int) slen(pathArg);
        if ((dupPath = walloc(len + 2)) == 0) {
            return NULL;
        }
        strcpy(dupPath, pathArg);
        if ((segments = walloc(sizeof(char*) * (len + 1))) == 0) {
            return NULL;
        }
        nseg = len = 0;
        firstc = *dupPath;
        for (mark = sp = dupPath; *sp; sp++) {
            if (*sp == '/') {
                *sp = '';
                while (sp[1] == '/') {
                    sp++;
                }
                segments[nseg++] = mark;
                len += (int) (sp - mark);
                mark = sp + 1;
            }
        }
        ……省略一部分
            }
        }
        nseg = j;
        assert(nseg >= 0);
        if ((path = walloc(len + nseg + 1)) != 0) {
            for (i = 0, dp = path; i < nseg; ) {
                strcpy(dp, segments[i]);
                ……省略一部分
            }
            *dp = '';
        }
        wfree(dupPath);
        wfree(segments);
    ```
有几个地方值得关注，首先是刚刚进入函数的时候，有一处申请堆操作
if ((dupPath = walloc(len + 2)) == 0) {
紧接着第二处申请堆操作
if ((segments = walloc(sizeof(char*) * (len + 1))) == 0) {
然后是第三处申请堆操作
if ((path = walloc(len + nseg + 1)) != 0) {