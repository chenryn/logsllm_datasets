Track at the RSA Conference on Topics in Cryptology (San Jose, CA) (CT-RSA’06).
Springer-Verlag, Berlin, Heidelberg, 1–20. https://doi.org/10.1007/11605805_1
[53] Ashay Rane, Calvin Lin, and Mohit Tiwari. 2015. Raccoon: Closing Digital
Side-Channels through Obfuscated Execution. In Proceedings of the 24th USENIX
Conference on Security Symposium (Washington, D.C.) (SEC’15). USENIX Associa-
tion, USA, 431–446.
[54] Frédéric Recoules, Sébastien Bardin, Richard Bonichon, Laurent Mounier, and
Marie-Laure Potet. 2019. Get Rid of Inline Assembly through Verification-
Oriented Lifting. In Proceedings of the 34th IEEE/ACM International Conference on
Automated Software Engineering (San Diego, California) (ASE ’19). IEEE Press,
577–589. https://doi.org/10.1109/ASE.2019.00060
[55] Bruno Rodrigues, Fernando Magno Quintão Pereira, and Diego F. Aranha. 2016.
Sparse Representation of Implicit Flows with Applications to Side-Channel Detec-
tion. In Proceedings of the 25th International Conference on Compiler Construction
(Barcelona, Spain) (CC 2016). Association for Computing Machinery, New York,
NY, USA, 110–120. https://doi.org/10.1145/2892208.2892230
[56] B. K. Rosen, M. N. Wegman, and F. K. Zadeck. 1988. Global Value Numbers
and Redundant Computations. In Proceedings of the 15th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages (San Diego, California, USA)
(POPL ’88). Association for Computing Machinery, New York, NY, USA, 12–27.
https://doi.org/10.1145/73560.73562
[57] Michael Schwarz, Moritz Lipp, Daniel Moghimi, Jo Van Bulck, Julian Steck-
lina, Thomas Prescher, and Daniel Gruss. 2019. ZombieLoad: Cross-Privilege-
Boundary Data Sampling. In Proceedings of the 2019 ACM SIGSAC Conference
on Computer and Communications Security (London, United Kingdom) (CCS
’19). Association for Computing Machinery, New York, NY, USA, 753–768.
https://doi.org/10.1145/3319535.3354252
[58] Martin Schwarzl, Claudio Canella, Daniel Gruss, and Michael Schwarz. 2021.
Specfuscator: Evaluating Branch Removal as a Spectre Mitigation. In Financial
Cryptography and Data Security 2021.
[59] Elaine Shi, T. H. Hubert Chan, Emil Stefanov, and Mingfei Li. 2011. Oblivious
RAM with O((logN)3) Worst-Case Cost. In In: Lee D.H., Wang X. (eds) Advances
in Cryptology – ASIACRYPT 2011. Lecture Notes in Computer Science, vol 7073.
Springer Berlin Heidelberg, 197–214. https://doi.org/10.1007/978-3-642-25385-
0_11
[60] Yannis Smaragdakis and George Balatsouras. 2015. Pointer Analysis. Found. and
Trends in Prog. Lang. 2, 1 (2015), 1–69. https://doi.org/10.1561/2500000014
[61] Yannis Smaragdakis, Martin Bravenboer, and Ondrej Lhoták. 2011. Pick Your
Contexts Well: Understanding Object-Sensitivity. In Proceedings of the 38th Annual
ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
(Austin, Texas, USA) (POPL ’11). Association for Computing Machinery, New
York, NY, USA, 17–30. https://doi.org/10.1145/1926385.1926390
[62] Luigi Soares and Fernando Magno Quintao Pereira. 2021. Memory-Safe Elim-
ination of Side Channels. In (to appear) In Proceedings of the 2021 IEEE/ACM
International Symposium on Code Generation and Optimization (CGO 2021).
[63] Juraj Somorovsky. 2016. Systematic Fuzzing and Testing of TLS Libraries. In
Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications
Security (Vienna, Austria) (CCS ’16). Association for Computing Machinery, New
York, NY, USA, 1492–1504. https://doi.org/10.1145/2976749.2978411
[64] Bjarne Steensgaard. 1996. Points-to Analysis in Almost Linear Time. In Proceed-
ings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages (St. Petersburg Beach, Florida, USA) (POPL ’96). Association for Com-
puting Machinery, New York, NY, USA, 32–41. https://doi.org/10.1145/237721.
237727
[65] Emil Stefanov, Marten van Dijk, Elaine Shi, Christopher Fletcher, Ling Ren, Xi-
angyao Yu, and Srinivas Devadas. 2013. Path ORAM: An Extremely Simple
Oblivious RAM Protocol. In Proceedings of the 2013 ACM SIGSAC Conference on
Computer & Communications Security (CCS ’13). Association for Computing Ma-
chinery, New York, NY, USA, 299–310. https://doi.org/10.1145/2508859.2516660
[66] N. Stephens, S. Biles, M. Boettcher, J. Eapen, M. Eyole, G. Gabrielli, M. Horsnell,
G. Magklis, A. Martinez, N. Premillieu, A. Reid, A. Rico, and P. Walker. 2017.
The ARM Scalable Vector Extension.
IEEE Micro 37, 2 (2017), 26–39. https:
//doi.org/10.1109/MM.2017.35
[67] G Edward Suh, Dwaine Clarke, Blaise Gassend, Marten Van Dijk, and Srinivas
Devadas. 2003. AEGIS: architecture for tamper-evident and tamper-resistant
processing. In ACM International Conference on Supercomputing 25th Anniversary
Volume. 357–368.
[68] Yulei Sui and Jingling Xue. 2016. SVF: Interprocedural Static Value-Flow Anal-
ysis in LLVM. In Proceedings of the 25th International Conference on Compiler
Construction (Barcelona, Spain) (CC 2016). Association for Computing Machinery,
New York, NY, USA, 265–266. https://doi.org/10.1145/2892208.2892235
[69] U.S. National Security Agency. 2016. Commercial National Security Algorithm
Suite and Quantum Computing FAQ. (Jan. 2016).
[70] Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank
Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx.
2018. Foreshadow: Extracting the Keys to the Intel SGX Kingdom with Transient
out-of-Order Execution. In Proceedings of the 27th USENIX Conference on Security
Symposium (Baltimore, MD, USA) (SEC’18). USENIX Association, USA, 991–1008.
[71] Victor van der Veen, Yanick Fratantonio, Martina Lindorfer, Daniel Gruss, Clemen-
tine Maurice, Giovanni Vigna, Herbert Bos, Kaveh Razavi, and Cristiano Giuffrida.
2016. Drammer: Deterministic Rowhammer Attacks on Mobile Platforms. In Pro-
ceedings of the 2016 ACM SIGSAC Conference on Computer and Communications
Security (Vienna, Austria) (CCS ’16). Association for Computing Machinery, New
York, NY, USA, 1675–1689. https://doi.org/10.1145/2976749.2978406
[72] S. van Schaik, A. Milburn, S. Österlund, P. Frigo, G. Maisuradze, K. Razavi, H. Bos,
and C. Giuffrida. 2019. RIDL: Rogue In-Flight Data Load. In 2019 IEEE Symposium
on Security and Privacy (SP). 88–105. https://doi.org/10.1109/SP.2019.00087
[73] Bhanu C Vattikonda, Sambit Das, and Hovav Shacham. 2011. Eliminating fine
grained timers in Xen. In Proceedings of the 3rd ACM workshop on Cloud computing
security workshop. 41–46.
[74] Xi Wang, Nickolai Zeldovich, M. Frans Kaashoek, and Armando Solar-Lezama.
2013. Towards Optimization-Safe Systems: Analyzing the Impact of Undefined
Behavior. In Proceedings of the Twenty-Fourth ACM Symposium on Operating
Systems Principles (SOSP ’13). Association for Computing Machinery, New York,
NY, USA, 260–275. https://doi.org/10.1145/2517349.2522728
[75] Zhenghong Wang and Ruby B Lee. 2007. New cache designs for thwarting
software cache-based side channel attacks. In Proceedings of the 34th annual
international symposium on Computer architecture (ISCA). 494–505.
[76] Zhenghong Wang and Ruby B. Lee. 2007. New Cache Designs for Thwarting
Software Cache-Based Side Channel Attacks. In Proceedings of the 34th Annual
International Symposium on Computer Architecture (San Diego, California, USA)
(ISCA ’07). Association for Computing Machinery, New York, NY, USA, 494–505.
https://doi.org/10.1145/1250662.1250723
[77] Zhenghong Wang and Ruby B Lee. 2008. A novel cache architecture with en-
hanced performance and security. In 2008 41st IEEE/ACM International Symposium
on Microarchitecture. IEEE, 83–93.
[78] Samuel Weiser, Andreas Zankl, Raphael Spreitzer, Katja Miller, Stefan Mangard,
and Georg Sigl. 2018. DATA – Differential Address Trace Analysis: Finding
Address-based Side-Channels in Binaries. In 27th USENIX Security Symposium
(USENIX Security 18). USENIX Association, Baltimore, MD, 603–620. https:
//www.usenix.org/conference/usenixsecurity18/presentation/weiser
Session 3A: Side Channel CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea728[79] John Whaley and Monica S. Lam. 2004. Cloning-Based Context-Sensitive Pointer
Alias Analysis Using Binary Decision Diagrams. In Proceedings of the ACM SIG-
PLAN 2004 Conference on Programming Language Design and Implementation
(Washington DC, USA) (PLDI ’04). Association for Computing Machinery, New
York, NY, USA, 131–144. https://doi.org/10.1145/996841.996859
[80] Meng Wu, Shengjian Guo, Patrick Schaumont, and Chao Wang. 2018. Eliminating
Timing Side-Channel Leaks Using Program Repair. In Proc. of the 27th ACM SIG-
SOFT Int. Symposium on Software Testing and Analysis (ISSTA 2018). Association
for Computing Machinery, 15–26. https://doi.org/10.1145/3213846.3213851
[81] Yuval Yarom and Katrina Falkner. 2014. FLUSH+RELOAD: A High Resolution,
Low Noise, L3 Cache Side-Channel Attack. In Proc. of the 23rd USENIX Security
Symposium (San Diego, CA) (SEC’14). USENIX Association, USA, 719–732.
[82] Yuval Yarom, Daniel Genkin, and Nadia Heninger. 2016. CacheBleed: A Timing
Attack on OpenSSL Constant Time RSA. In Cryptographic Hardware and Em-
bedded Systems – CHES 2016, Benedikt Gierlichs and Axel Y. Poschmann (Eds.).
Springer Berlin Heidelberg, Berlin, Heidelberg, 346–367.
[83] Ting Yu and Owen Kaser. 1997. A Note on ”On the Conversion of Indirect to
Direct Recursion”. ACM Trans. Program. Lang. Syst. 19, 6 (Nov. 1997), 1085–1087.
https://doi.org/10.1145/267959.269973
[84] Danfeng Zhang, Aslan Askarov, and Andrew C. Myers. 2011. Predictive Mitigation
of Timing Channels in Interactive Systems. In Proceedings of the 18th ACM
Conference on Computer and Communications Security (CCS ’11). Association for
Computing Machinery, 563–574. https://doi.org/10.1145/2046707.2046772
[85] Danfeng Zhang, Aslan Askarov, and Andrew C. Myers. 2012. Language-Based
Control and Mitigation of Timing Channels. In Proceedings of the 33rd ACM SIG-
PLAN Conference on Programming Language Design and Implementation (Beijing,
China) (PLDI ’12). Association for Computing Machinery, New York, NY, USA,
99–110. https://doi.org/10.1145/2254064.2254078
[86] Yinqian Zhang, Ari Juels, Alina Oprea, and Michael K Reiter. 2011. Homealone: Co-
residency detection in the cloud via side-channel analysis. In 2011 IEEE symposium
on security and privacy. IEEE, 313–328.
[87] Yinqian Zhang and Michael K. Reiter. 2013. DüPpel: Retrofitting Commodity
Operating Systems to Mitigate Cache Side Channels in the Cloud. In Proceedings
of the 2013 ACM SIGSAC Conference on Computer & Communications Security
(CCS ’13). Association for Computing Machinery, 827–838. https://doi.org/10.
1145/2508859.2516741
A DECOY-PATH SIDE CHANNELS
We use the following snippet to show how existing constant-time
protection solutions struggle to maintain both memory safety and
real execution invariants along decoy paths, ultimately introducing
new side channels for attackers to detect decoy paths.
1
2
3
4
5
6
7
8
9
10
11
12
char last_result;
char tableA[8192];
char tableB[4096];
char secret_hash(unsigned int secret) {
if (secret < 4096) {
register char tmp = tableB[secret];
tmp ^= tableA[secret];
last_result = tmp;
}
return last_result;
}
The if condition at line 6 guards the statement at lines 7-9 (two
read operations followed by one write operation). Let us consider
the case 4096 <= secret < 8192. All the state-of-the-art solu-
tions [20, 53, 62, 80] would also run the corresponding decoy path
(statements inside the condition, normally executed only when
secret < 4096), but with different code transformations. The ap-
proach of Coppens et al. [20] rewires the memory accesses at lines
7-9 to touch a shadow address, therefore allowing an attacker to
detect decoy path execution by observing (three) accesses to the
shadow address. SC-Eliminator [80] preloads both tables before exe-
cuting the branch, but executes the read/write operations at lines 7-9
with unmodified addresses, introducing a decoy out-of-bounds read
at line 7. Such memory safety violation might cause an exception if
the memory after tableB is unmapped, which, since the exception
is left unmasked, would terminate the program and introduce a
termination-based decoy-path side channel. Raccoon [53] closes
such termination side channels by masking the exception, but this
strategy also introduces an exception handling-based decoy-path
side channel. The approach of Soares et al. [62], on the other hand,
replaces such an unsafe read access with an access to a shadow ad-
dress, which however introduces the same decoy-path side channel
discussed for Coppens et al. [20].
Finally, even assuming no exception is caused by the out-of-
bounds read at line 7 and that we can even eliminate the out-of-
bounds behavior altogether without introducing other side chan-
nels, an attacker can still trivially detect decoy-path execution by
side channeling the read at line 8. The shadow access of Coppens et
al. [20] would leak decoy-path execution as discussed, but so will
all the other solutions [53, 62, 80], which would allow an in-bound
access at offset 4096 <= secret < 8192 to tableA. Such access
would never happen during real execution, breaking a program
invariant on a decoy path and introducing a decoy data-flow side
channel an attacker can use to again detect decoy-path execution.
In contrast, Constantine’s combined CFL/DFL strategy would
instead ensure the very same data accesses during real or decoy
execution, preserving program invariants and eliminating decoy-
path side channels by construction. Table 3 provides a detailed
comparison between Constantine and prior solutions.
B CONDITIONAL SELECTION
The ct_select primitive of §4.2 can be instantiated in different
ways. We studied how the LLVM compiler optimizes different
schemes for constant-time conditional selection to pick the best
possible alternative(s) in Constantine.
For the discussion we consider the pointer selection primitive
that we use to differentiate decoy and real store operations (i.e., to
conditionally select whether we should actually modify memory
contents), evaluating the alternatives listed below:
taken values
asm cmov
ptr = taken ? ptr : (void*)NULL
ptr = (void*)((size_t)ptr & (-taken))
ptr = (void*)((size_t)ptr & taken)
ptr = (void*)((size_t)ptr * taken)
Scheme C equivalent
1
2
3
4
5
We assume to operate on a void* ptr pointer given as input to
the ct_store primitive, and taken values being 1 on real paths and
0 on decoy ones unless otherwise stated. Instead of reporting end-
to-end overheads, we mask the slowdown from DFL by configuring
CFL to use a single shadow variable as in the solution of Coppens et
al. [20], then we compute the relative slowdowns of our protected
mulmod wolfSSL version (§7) for the different ct_select schemes,
using the default non-CT implementation (W=1) as baseline.
9.6x
7.5x
7.3x
7.7x
7.2x
Scheme 1 forces the backend to emit cmov instructions at the
assembly level, similarly to predicated execution mechanism we
discussed in §2. As this choice constrains the optimizer’s decisions,
it turns out to be the worst performing alternative just as expected.
Scheme 2 is essentially an LLVM IR select statement around the
taken indirection predicate, on which the compiler can reason about
and optimize, then after IR-level optimizations the backend for most
of its occurrences emits a cmov instruction as in scheme 1, testing
the value of the taken variable for conditional assignment.
CFL overhead
{0;1}
{0;1}
(size_t) {0;1}
{0;0xff..ff}
{0;1}
Session 3A: Side Channel CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea729Table 3: Technical, security, and compatibility features from state-of-the-art solutions vs. Constantine.
Feature
control flows
data flows
loop handling strategy
integration with compiler
sensitive region identification
decoy-path side channels
fix variable-latency instructions (e.g., div)
threat model
variable-length loops
indirect calls
recursion
spatial safety preserved
supported data pointers
Coppens et al.
predicated
-
unroll
backend
no
code
no
no
yes
-
Raccoon
transactional
Path ORAM
unroll
IR level
sw emulation
code+data
no
-
no
arrays
SC-Eliminator
hybrid
preloading
unroll
IR level
code+data*
decoy paths till bound
no
-
-
no
arrays
Soares et al.
hybrid
-
unroll
IR level
no
code
no
-
-
yes
arrays
Constantine
linearization
linearization
just-in-time
IR level