如果流处理器在步骤 2 中崩溃，则它会从上一个存档点恢复处理。这样做时，它不会跳过任何请求讯息，但可能会多次处理请求并产生重复的贷记与借记指令。但由于它是确定性的，因此它只是再次生成相同的指令，而步骤 3 中的处理器可以使用端到端请求 ID 轻松地对其除重。
如果你想确保付款人的帐户不会因此次转账而透支，则可以使用一个额外的流处理器来维护账户余额并校验事务（按付款人账户分割槽），只有有效的事务会被记录在步骤 1 中的请求日志中。
透过将多分割槽事务分解为两个不同分割槽方式的阶段，并使用端到端的请求 ID，我们实现了同样的正确性属性（每个请求对付款人与收款人都恰好生效一次），即使在出现故障，且没有使用原子提交协议的情况下依然如此。使用多个不同分割槽阶段的想法与我们在 “[多分割槽资料处理](#多分割槽资料处理)” 中讨论的想法类似（也请参阅 “[并发控制](ch11.md#并发控制)”）。
### 及时性与完整性
事务的一个便利属性是，它们通常是线性一致的（请参阅 “[线性一致性](ch9.md#线性一致性)”），也就是说，写入者会等到事务提交，而之后其写入立刻对所有读取者可见。
当我们把一个操作拆分为跨越多个阶段的流处理器时，却并非如此：日志的消费者在设计上就是非同步的，因此传送者不会等其讯息被消费者处理完。但是，客户端等待输出流中的特定讯息是可能的。这正是我们在 “[基于日志讯息传递中的唯一性](#基于日志讯息传递中的唯一性)” 一节中检查唯一性约束时所做的事情。
在这个例子中，唯一性检查的正确性不取决于讯息传送者是否等待结果。等待的目的仅仅是同步通知传送者唯一性检查是否成功。但该通知可以与讯息处理的结果相解耦。
更一般地来讲，我认为术语 **一致性（consistency）** 这个术语混淆了两个值得分别考虑的需求：
* 及时性（Timeliness）
  及时性意味著确保使用者观察到系统的最新状态。我们之前看到，如果使用者从陈旧的资料副本中读取资料，它们可能会观察到系统处于不一致的状态（请参阅 “[复制延迟问题](ch5.md#复制延迟问题)”）。但这种不一致是暂时的，而最终会透过等待与重试简单地得到解决。
  CAP 定理（请参阅 “[线性一致性的代价](ch9.md#线性一致性的代价)”）使用 **线性一致性（linearizability）** 意义上的一致性，这是实现及时性的强有力方法。像 **写后读** 这样及时性更弱的一致性也很有用（请参阅 “[读己之写](ch5.md#读己之写)”）。
* 完整性（Integrity）
  完整性意味著没有损坏；即没有资料丢失，并且没有矛盾或错误的资料。尤其是如果某些衍生资料集是作为底层资料之上的检视而维护的（请参阅 “[从事件日志中派生出当前状态](ch11.md#从事件日志中派生出当前状态)”），这种衍生必须是正确的。例如，资料库索引必须正确地反映资料库的内容 —— 缺失某些记录的索引并不是很有用。
  如果完整性被违背，这种不一致是永久的：在大多数情况下，等待与重试并不能修复资料库损坏。相反的是，需要显式地检查与修复。在 ACID 事务的上下文中（请参阅 “[ACID 的含义](ch7.md#ACID的含义)”），一致性通常被理解为某种特定于应用的完整性概念。原子性和永续性是保持完整性的重要工具。
口号形式：违反及时性，“最终一致性”；违反完整性，“永无一致性”。
我断言在大多数应用中，完整性比及时性重要得多。违反及时性可能令人困惑与讨厌，但违反完整性的结果可能是灾难性的。
例如在你的信用卡对账单上，如果某一笔过去 24 小时内完成的交易尚未出现并不令人奇怪 —— 这些系统有一定的滞后是正常的。我们知道银行是非同步核算与敲定交易的，这里的及时性并不是非常重要【3】。但如果当期对账单余额与上期对账单余额加交易总额对不上（求和错误），或者出现一笔向你收费但未向商家付款的交易（消失的钱），那就实在是太糟糕了，这样的问题就违背了系统的完整性。
#### 资料流系统的正确性
ACID 事务通常既提供及时性（例如线性一致性）也提供完整性保证（例如原子提交）。因此如果你从 ACID 事务的角度来看待应用的正确性，那么及时性与完整性的区别是无关紧要的。
另一方面，对于在本章中讨论的基于事件的资料流系统而言，它们的一个有趣特性就是将及时性与完整性分开。在非同步处理事件流时不能保证及时性，除非你显式构建一个在返回之前明确等待特定讯息到达的消费者。但完整性实际上才是流处理系统的核心。
**恰好一次** 或 **等效一次** 语义（请参阅 “[容错](ch11.md#容错)”）是一种保持完整性的机制。如果事件丢失或者生效两次，就有可能违背资料系统的完整性。因此在出现故障时，容错讯息传递与重复抑制（例如，幂等操作）对于维护资料系统的完整性是很重要的。
正如我们在上一节看到的那样，可靠的流处理系统可以在无需分散式事务与原子提交协议的情况下保持完整性，这意味著它们有潜力达到与后者相当的正确性，同时还具备好得多的效能与运维稳健性。为了达成这种正确性，我们组合使用了多种机制：
* 将写入操作的内容表示为单条讯息，从而可以轻松地被原子写入 —— 与事件溯源搭配效果拔群（请参阅 “[事件溯源](ch11.md#事件溯源)”）。
* 使用与储存过程类似的确定性衍生函式，从这一讯息中衍生出所有其他的状态变更（请参阅 “[真的序列执行](ch7.md#真的序列执行)” 和 “[应用程式码作为衍生函式](ch12.md#应用程式码作为衍生函式)”）
* 将客户端生成的请求 ID 传递透过所有的处理层次，从而允许端到端的除重，带来幂等性。
* 使讯息不可变，并允许衍生资料能随时被重新处理，这使从错误中恢复更加容易（请参阅 “[不可变事件的优点](ch11.md#不可变事件的优点)”）
这种机制组合在我看来，是未来构建容错应用的一个非常有前景的方向。
#### 宽松地解释约束
如前所述，执行唯一性约束需要共识，通常透过在单个节点中汇集特定分割槽中的所有事件来实现。如果我们想要传统的唯一性约束形式，这种限制是不可避免的，流处理也不例外。