(cid:32)(cid:20)(cid:21)(cid:3)(cid:5)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:32)(cid:20)(cid:21)(cid:3)(cid:5)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:38)(cid:2)(cid:37)(cid:1)(cid:35)(cid:9)(cid:39)(cid:20)(cid:9)(cid:3)
(cid:1)(cid:1)(cid:1)
(cid:33)(cid:12)(cid:8)(cid:28)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:33)(cid:12)(cid:8)(cid:28)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:38)(cid:2)(cid:37)(cid:1)(cid:35)(cid:9)(cid:39)(cid:20)(cid:9)(cid:3)
(cid:1)(cid:1)(cid:35)(cid:10)(cid:36)(cid:3)(cid:6)(cid:9)(cid:3)(cid:10)(cid:1)(cid:1)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:1)(cid:1)(cid:35)(cid:10)(cid:36)(cid:3)(cid:6)(cid:9)(cid:3)(cid:10)(cid:1)(cid:1)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:38)(cid:2)(cid:37)(cid:1)(cid:35)(cid:9)(cid:39)(cid:20)(cid:9)(cid:3)
(cid:25)(cid:8)(cid:28)(cid:3)
(cid:1)(cid:1)(cid:1)
(cid:1)(cid:1)(cid:1)
(cid:3)
(cid:26)
(cid:30)
(cid:20)
(cid:23)
(cid:26)
(cid:36)
(cid:41)
(cid:30)
(cid:6)
(cid:40)
(cid:37)(cid:6)(cid:14)(cid:20)(cid:10)(cid:3)(cid:6)
(cid:29)
(cid:6)
(cid:3)
(cid:10)
(cid:9)
(cid:28)
(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:1)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:1)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:1)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:12)(cid:13)(cid:14)(cid:1)(cid:1)(cid:15)(cid:2)(cid:8)(cid:12)(cid:16)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:12)(cid:13)(cid:14)(cid:1)(cid:1)(cid:15)(cid:2)(cid:8)(cid:12)(cid:16)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:1)
(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:1)(cid:22)(cid:13)(cid:23)
(cid:7)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:4)
(cid:3)
(cid:10)
(cid:23)
(cid:7)
(cid:19)
(cid:3)
(cid:26)
(cid:30)
(cid:29)
(cid:6)
(cid:3)
(cid:10)
(cid:9)
(cid:28)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:25)(cid:8)(cid:28)(cid:3)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:38)(cid:20)(cid:6)(cid:3)(cid:26)(cid:10)(cid:1)(cid:2)(cid:3)(cid:21)(cid:20)(cid:30)(cid:1)(cid:28)(cid:9)(cid:10)(cid:3)(cid:6)(cid:29)(cid:30)(cid:26)(cid:3)(cid:1)(cid:15)(cid:38)(cid:2)(cid:28)(cid:16)
(cid:1)(cid:28)(cid:9)(cid:10)(cid:3)(cid:6)(cid:9)(cid:30)(cid:11)(cid:1)(cid:1)(cid:1)(cid:22)(cid:13)(cid:23)
(cid:28)(cid:27)(cid:34)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)(cid:1)(cid:12)(cid:13)(cid:14)(cid:1)(cid:15)(cid:28)(cid:8)(cid:12)(cid:16)
(cid:28)(cid:27)(cid:34)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)(cid:1)(cid:12)(cid:13)(cid:14)(cid:1)(cid:15)(cid:28)(cid:8)(cid:12)(cid:16)
(cid:25)(cid:8)(cid:28)(cid:3)(cid:1)(cid:1)(cid:1)
(cid:12)(cid:30)(cid:6)(cid:21)(cid:21)(cid:20)(cid:23)(cid:31)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:12)(cid:30)(cid:6)(cid:21)(cid:21)(cid:20)(cid:23)(cid:31)(cid:1)(cid:8)(cid:5)(cid:9)(cid:10)(cid:6)(cid:5)(cid:11)(cid:11)(cid:3)(cid:6)
(cid:38)(cid:2)(cid:37)(cid:1)(cid:35)(cid:9)(cid:39)(cid:20)(cid:9)(cid:3)
(cid:18)(cid:1)(cid:1)(cid:25)(cid:8)(cid:28)(cid:3)(cid:1)(cid:22)(cid:13)(cid:23)(cid:1)(cid:19)(cid:7)(cid:23)(cid:10)(cid:3)(cid:4)(cid:1)(cid:22)(cid:13)(cid:23)(cid:1)(cid:2)(cid:30)(cid:23)(cid:10)(cid:3)(cid:6)
(cid:18)(cid:1)(cid:1)(cid:25)(cid:6)(cid:5)(cid:26)(cid:3)(cid:23)(cid:23)(cid:5)(cid:6)(cid:1)(cid:22)(cid:13)(cid:23)(cid:1)(cid:19)(cid:7)(cid:23)(cid:10)(cid:3)(cid:4)(cid:1)(cid:22)(cid:13)(cid:23)(cid:1)(cid:2)(cid:30)(cid:23)(cid:10)(cid:3)(cid:6)
(cid:2)(cid:30)(cid:20)(cid:9)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)
(cid:2)(cid:30)(cid:20)(cid:9)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)
(cid:1)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)
(cid:2)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:1)(cid:2)
(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:2)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)
(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)
(cid:1)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)
(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)
(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)(cid:2)(cid:1)(cid:2)(cid:2)(cid:1)
Fig. 2. Bus Master Topology: Bus masters access the main memory via diﬀerent
bus systems (e. g., PCIe, FSB). The MCH arbitrates main memory access requests of
diﬀerent bus masters. (based on [18, p.504][19][20, Section 7.3][21, Section 1.3][22])
from the main memory. I/O controller (e. g., UHCI, ethernet, harddisk controller,
etc.) provide separate DMA engines for I/O devices (e. g., USB keyboard/mouse,
harddisk, NIC, etc.). That means, when the main memory access request of a
peripheral is handled by the MCH, PCIe is not involved at all.
Determining Processor Bus System Bus Master Memory Transac-
tions: According to the experiment described in [4], malware, which is exe-
cuted in peripherals with a separate DMA engine, can access the main memory
stealthily. The host CPU does not necessarily have to be involved when a DMA-
based memory transaction is set up. Nonetheless, the memory bus is inevitable
a shared resource that is arbitrated by the MCH. This is the reason why we
expect side eﬀects when bus masters access the main memory.
We analyzed the capabilities of Performance Monitoring Units (PMU, [25,
Section 18.1]) to ﬁnd and exploit such DMA side eﬀects. PMUs are implemented
as Model-Speciﬁc Registers (MSR, processor registers to control hardware-related
features [25, Section 9.4]). These registers can be conﬁgured to count perfor-
mance related events. The PMUs are not intended to detect malicious behavior
on a computer system. Their purpose is to detect performance bottlenecks to
enable a software developer to improve the performance of the aﬀected software
accordingly [26]. In this work we exploit PMUs to reveal stealthy peripheral-
based attacks on the platform’s main memory. Malware executed in peripherals
has no access to processor registers and therefore cannot hide its activity from
the host CPU by modifying the PMU processor registers.
Our analysis revealed memory transaction events that can be counted by
PMUs. In particular, a counter event called BUS TRANS MEM summarizes all burst
(full cache line), partial read/write (non-burst) as well as invalidate memory
transactions, see [27]. This is the basis for BARM.
Depending on the precise processor architecture, Intel processors provide ﬁve
to seven performance counter registers per processor core [25, Section 18]. In this
case, at most ﬁve to seven events can be counted in parallel with one processor
Revealing Stealthy Peripheral-Based Attacks on Main Memory
7
core. Three of those counters are ﬁxed function counters, i. e., the counted event
cannot be changed. The other counters are general purpose counters that we use
for BARM to count certain BUS TRANS MEM events.
We are able to successfully measure Am when we apply the BUS TRANS MEM
counters correctly. At this point, that knowledge is insuﬃcient to decide if the
transactions exclusively relate to an OS task or if malicious transactions are
also among them. In the following, we lay the groundwork to reveal malicious
transactions originating from a compromised DMA-capable peripheral.
4.2 Bus Master Analysis
In the following we analyze the host CPU (related to the processor bus system)
and the UHCI controller (related to the PCIe bus system) bus masters regarding
the number of bus transactions that they cause. By doing so, we consider the
most important bus systems that share the memory bus. Other bus masters,
such as harddisk and ethernet controllers, can be analyzed in a similar way.
Host CPU: The host CPU is maybe the most challenging bus master. The CPU
causes a huge amount of memory transactions. Several processor cores fetch in-
structions and data for many processes. Monitoring all those processes eﬃciently
regarding the bus activity that they cause is nearly impossible. Hence, we decided
to analyze the host CPU bus agent behavior using the BUS TRANS MEM events in
conjunction with certain control options and so called event name extensions.
We implemented a Linux kernel module for this analysis. Our key results are: (i)
Bus events caused by user space and kernel space processes can be counted with
one counter. (ii) The event name extensions THIS AGENT and ALL AGENTS can be
used in conjunction with BUS TRANS MEM events [27] to distinguish between bus
transactions caused by the host CPU and all other processor bus system bus
masters. THIS AGENT counts all events related to all processor cores belonging to
a CPU bus agent. ALL AGENTS counts events of all bus agents connected to the
bus where the host CPU is connected to.
The ALL AGENTS extension is very important for our implementation. It en-
ables us to measure the bus activity value Am (see Section 3) in terms of number
of bus transactions: Am = BU S T RAN S M EM.ALL AGEN T S.
Furthermore, our analysis revealed that a host CPU is not necessarily exactly
one bus agent. A multi-core processor can consist of several bus agents. For ex-
ample, we used a quad-core processor (Intel Core 2 Quad CPU PI:EMAIL)
that consists of two bus agents. Two processor cores embody one bus agent as
depicted in Figure 3. Hence, the number of processor cores is important when
determining (il)legitimate bus transactions. Note, if the host CPU consists of
several bus agents, it is necessary to start one counter per bus agent with the
THIS AGENT event name extension.
masters Am. We can distinguish between bus activity caused by the host CPU
(ACP U
n=0 BU S T RAN S M EM.T HIS AGEN Tcpu bus agent#n, n ∈ N,
With this knowledge we can determine bus master transactions of all bus
=
(cid:2)
N
m
8
P. Stewin
(cid:1)(cid:2)(cid:3)(cid:1)(cid:2)(cid:3)
(cid:20)(cid:21)(cid:22)(cid:7)(cid:23)(cid:24)(cid:6)(cid:14)(cid:15)(cid:7)(cid:8)(cid:9)
(cid:20)(cid:21)(cid:22)(cid:7)(cid:23)(cid:24)(cid:6)(cid:14)(cid:15)(cid:7)(cid:8)(cid:10)
(cid:1)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)
(cid:1)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:10)
(cid:1)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:11)
(cid:1)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:12)
(cid:13)(cid:5)(cid:4)(cid:14)(cid:15)(cid:16)(cid:17)(cid:18)(cid:19)(cid:6)(cid:7)(cid:20)(cid:21)(cid:22)
(cid:25)(cid:28)(cid:27)(cid:25)(cid:28)(cid:27)
(cid:25)(cid:26)(cid:27)(cid:25)(cid:26)(cid:27)
Fig. 3. Intel Quad-Core Processor: The quad-core processor consists of two bus
agents and each bus agent consists of two cores, see (a). When counting BUS TRANS MEM
events with both bus agents, i. e., in (b) BA#0 and BA#1, the THIS AGENT name extension
delivers signiﬁcant diﬀerence. The kernel log in (b) also depicts that the values for the
ALL AGENTS name extension are pretty much the same within a counter query iteration.
N = number of host CP U bus agents − 1) and bus activity caused by all other
bus masters (ACP U
m ) that access the main memory via the MCH
(e. g., harddisk, ethernet, UHCI controller, etc.).
m = Am − ACP U
That means, we can subtract all legitimate bus transactions caused by user
space and kernel space processes of all processor cores. Note, according to our
trust and adversary model (see Section 2) the measured host CPU bus activity
value and the expected host CPU bus activity value are the same (ACP U
=
ACP U
m ), since all processes running on the host CPU are trusted.
Our host CPU bus master analysis reveals that Am can be split as follows:
Am = ACP U
m . It also makes sense to introduce this distinction for the
expected bus activity value: Ae = ACP U
m + ACP U
.
e
+ ACP U
e
e
Universal Host Controller Interface Controller: The Universal Host Con-
troller Interface (UHCI) controller is an I/O controller for Universal Serial Bus
(USB) devices such as a USB keyboard or a USB mouse. USB devices are polled
by the I/O controller to check if new data is available. System software needs
to prepare a schedule for the UHCI controller. This schedule determines how a
connected USB device is polled by the I/O controller.
The UHCI controller permanently checks its schedule in the main memory.
Obviously, this procedure causes a lot of bus activity. Further bus activity is
generated by USB devices if a poll reports that new data is available. In the
following we analyze how much activity is generated, i. e., how many bytes are
transfered by the UHCI controller when servicing a USB device.
In our case, the I/O controller analyzes its schedule every millisecond. That
means, the controller looks for data structures that are called transfer descrip-
tors. These descriptors determine how to poll the USB device. To get the descrip-
tors the controller reads a frame pointer from a list every millisecond. A frame
pointer (physical address) references to the transfer descriptors of the current
timeframe. Transfer descriptors are organized in queues.
A queue starts with a queue head that can contain a pointer to the ﬁrst
transfer descriptor as well as a pointer to the next queue head, see [28, p.6].
According to [28] the frame (pointer) list consists of 1024 entries and has a size
of 4096 bytes. The UHCI controller needs 1024 ms (1 entry/ms) for one frame
Revealing Stealthy Peripheral-Based Attacks on Main Memory
9
(pointer) list iteration. We analyzed the number of bus transactions for one
iteration with the help of the highest debug mode of the UHCI host controller
device driver for Linux. In that mode schedule information are mapped into the
debug ﬁle system. We ﬁgured out that the frame pointers reference to interrupt
transfer queues (see Figure 4 (d.i) and (d.ii): int2, int4, . . . , int128) and to a
queue called async. int2 means, that this queue is referenced by every second
frame pointer, int4 by every fourth, int8 by every eighth, etc. The async queue
is referenced by every 128th frame pointer.
Unassigned interrupt transfer queues, i. e., queues not used to poll a USB
device, are redirected to the queue head of the async queue, see Figure 4 (b).
Parsing the async queue requires three memory read accesses as illustrated in
Figure 4 (a).
Parsing interrupt transfer queues that are assigned to poll a USB device needs
more than four memory reads. The exact number of memory reads depends on
how many elements the queue has. Usually, it has one element if the queue is
assigned to a USB keyboard. The queue can also have two elements if the queue
is assigned to a keyboard and mouse, for example. If the queue has one element,
parsing the whole assigned interrupt transfer queue needs six memory reads, see
Figure 4 (c). We summarize our examination as follows: 8 · #async reads + 8 ·
#int128 reads + 16· #int64 reads + 32· #int32 reads + 64· #int16 reads + 128·
#int8 reads + 256· #int4 reads + 512· #int2 reads = #bus read transactions.
If int16 is assigned to a USB keyboard, as depicted in Figure 4 (d) for
example, we get the following number of bus read transactions: 8 · 3 + 8· 4 + 16 ·
4 + 32 · 4 + 64 · 6 + 128 · 4 + 256 · 4 + 512 · 4 = 4216.
According to [28], the UHCI controller updates queue elements. We expect
this for the queue element of the int16 queue. This queue is referenced by 64
frame pointers. Hence, we calculate with 64 memory write transactions. That
means, the overall number of bus transactions is 4216 + 64 = 4280. We success-
fully veriﬁed this behavior with a Dell USB keyboard as well as a Logitech USB