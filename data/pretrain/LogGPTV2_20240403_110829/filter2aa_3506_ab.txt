to confirm that requests are authorized. All 
requests to non-public APIs also need to 
be authenticated, with single sign-on now 
being the norm for enterprise applications. 
If either authorization or authentication 
is weak or missing, threat actors may be 
able to send API calls to the underlying 
application or service to extract or modify 
data. Worse still, if undocumented API 
endpoints make it into production, they 
are likely to be less secure than official 
endpoints, either because they were 
never intended to be publicly accessible 
or because they slipped under the         
testing radar.
In by the service door: APIs for extending access
Cover Your APIs: Securing Your Hidden Web Attack Surface
9
Modern web apps routinely use API 
calls to exchange information between 
components, especially with the move to 
microservices and serverless architecture. 
Rather than storing and executing all 
application code on a central server, 
developers implement operations as 
separate web services that communicate 
via APIs. Depending on the design choices, 
a single web application can be made 
up of dozens of services or hundreds of 
microservices. This API-driven approach 
enables agile development and rapid 
innovation, as teams can work in parallel 
to build independent components without 
waiting on a bigger release.
With so much functionality now deployed as 
granular services, web APIs can also serve 
as a standalone multi-purpose back-end. 
The same API can then deliver data and 
perform operations for multiple websites, 
business systems, mobile apps, IoT devices, 
and more. With back-end services doing the 
heavy lifting, it becomes simpler and faster 
to create new applications. Again, this 
helps to drive innovation by focusing    
time-sensitive efforts on building the 
right front-end and business logic to 
get maximum benefits from existing           
back-end services. 
For all its benefits, spreading access to 
data and functionality across dozens of 
standalone services has major security 
implications. Instead of having just a single 
central application to test and secure, 
organizations now also have a nebula of 
web services, each a target in its own 
right. The convenience of automated 
access by design is a double-edged 
sword, giving malicious actors much more 
freedom to craft and conduct attacks 
on a massive scale with less chance of 
arousing suspicion. Combined with the 
risk of undocumented and inadequately 
secured endpoints, this makes APIs a 
fast-growing vector for cyberattacks with 
their many possible consequences, from 
data breaches and denial of service to             
ransomware deployments.
APIs in service-based applications: Every app is a hundred apps
Figure 3. Even monolithic legacy applications often have an eternal API for integration 
and data exchange that comprises part of their attack surface.
Figure 4. Modern web applications not only have external-facing APIs but are 
themselves made up of dozens of microservices, each with its own API – all 
contributing to the overall attack surface that you need to test.
Cover Your APIs: Securing Your Hidden Web Attack Surface
10
Building API scanning into your AppSec program
Automated vulnerability scanning is a 
crucial part of any mature AppSec program, 
especially with sprawling web application 
environments that change frequently, often 
on a daily basis. To know your true security 
posture, you need to cover your entire 
web attack surface, which means scanning 
your web assets both through UIs and via 
APIs – and scanning both in development 
and in production. To complicate matters 
further, APIs can change and expand much 
faster than user-facing interfaces, making 
purely manual testing impractical and 
strengthening the case for efficient and 
accurate scanning.
Research shows that security often takes 
a back seat when release deadlines loom, 
and this goes doubly for APIs. Whether 
they are perceived as less exposed or are 
simply harder and more time-consuming to 
find and test, API security can slip out of 
mind when time is short. This is especially 
true when a separate toolchain is needed 
for the API part of security testing, further 
increasing the risk that time pressures will 
cause vulnerabilities to slip into production.
Incorporating APIs into the overall 
AppSec testing strategy presents a major 
technical and organizational challenge. To 
maximize test coverage without stopping 
development pipelines to wait for results, 
you need sufficiently advanced tooling 
and a systematic approach to application 
security to make it all work without 
having to chain together multiple tools 
and processes. Here is how Invicti makes      
this possible.
When scanning websites and applications, 
vulnerability scanners crawl pages and 
follow links to build up a list of URLs for 
testing. But you can’t crawl an API – you 
simply have to know the URLs of the API 
endpoints you want to test. For this, you 
need API definition files that are created 
during development and maintained 
across the entire lifetime of a production 
application. You also need to support all 
the popular definition formats, know the 
type of API, and have accurate security 
checks ready to probe the application via          
that interface.
Invicti provides vulnerability scanning 
support for the most popular API types, 
namely REST, SOAP, and GraphQL.      
Users can import API definition files in 
industry-standard formats, including 
Postman, OpenAPI/Swagger, WADL, and 
WSDL. In practice, this means that as long 
as you have the definition files and keep 
them updated, your automated security 
testing process can routinely cover both 
the UI and APIs during vulnerability 
scanning. And if you don’t yet have an 
application security testing process that is 
integrated into your software development 
life cycle (SDLC), building one is crucial to 
ensure that security can keep up with the 
pace of development.
Get the API definitions so you know what to test
Cover Your APIs: Securing Your Hidden Web Attack Surface
11
API definitions are prepared and maintained 
by development teams, so integrating 
vulnerability testing into the development 
pipeline makes it far easier to include APIs 
in security testing workflows. Invicti designs 
its AppSec solutions with SDLC integration 
in mind, which makes them a natural fit for 
API testing. By adding API definitions as 
they are created and updated, developers 
can ensure that every vulnerability scan 
covers the entire existing attack surface 
at every stage where security testing is 
integrated, including once an application     
is in production.
Invicti’s out-of-the-box integrations with 
popular issue trackers, CI/CD systems, 
and collaboration tools allow companies 
to plug automated security testing – APIs 
included – into their existing workflows 
for maximum efficiency. Combined with 
extremely accurate security checks and 
actionable vulnerability reports complete 
with remediation guidance, this is a tried 
and true way of bringing measurable 
security improvements without burdening 
development teams with external workflows 
or separate toolchains.
Integrate API testing into your development lifecycle
To make sure that you have the same level 
of protection all across your application, 
you need to use the same security checks 
for API-based testing and conventional 
testing. While this would be extremely hard 
to do with separate tools, Invicti makes 
it possible by consistently probing the 
entire attack surface using one integrated 
solution. By running the same high-quality 
tests both on interactive pages and on API 
endpoints, you can eliminate weak spots in 
your overall security posture.
As ever with automated testing, you 
need to strike the right balance between 
finding vulnerabilities and minimizing false 
positives. This is where Invicti’s track 
record is second to none in the industry, 
with automatic vulnerability confirmation 
taking the guesswork out of dealing with 
application security reports for the majority 
of exploitable vulnerabilities. With well over 
a thousand security checks accumulated, 
expanded, and continuously improved 
since the earliest days of vulnerability 
scanning, combined with cutting-edge 
technologies such as IAST, Invicti can help 
to bring effective and practical application 
security testing into any modern web    
development workflow.
Ensure consistent accuracy across the entire application
Authentication is another common 
stumbling block for automated security 
testing. In a world where very few sensitive 
resources are deliberately exposed to 
unauthenticated users, authenticated 
vulnerability scanning is already an 
important requirement when testing 
websites and applications. Since all APIs 
require some kind of authentication, 
support for authenticated scanning is an 
absolute necessity to allow the scanner to 
access API endpoints for testing. From 
basic authentication to single sign-on 
with OAuth2, Invicti ensures support for 
all popular authentication methods used 
by modern web applications and APIs. 
Authenticated vulnerability scanning 
provides maximum test coverage and 
the most realistic picture of your real-life 
security posture across all web-facing 
assets, including websites, applications, 
web services, and APIs.
Enforce authenticated scanning
Cover Your APIs: Securing Your Hidden Web Attack Surface
12
Modern applications require modern AppSec
If you have web applications, you also have web APIs – and you need to secure both to     
avoid weak links in your security posture. Not that long ago, manual testing was the only way 
to check the API part of your web attack surface, but manual tools and processes cannot hope 
to keep up with the pace of modern web development. With enterprise applications being 
rapidly built from dozens of services or hundreds of microservices all communicating through 
APIs, extending automated vulnerability scanning to cover APIs was the logical next step 
for web application security – but that required advanced technical solutions and efficient        
workflow integration.
Invicti provides a single platform for comprehensive web application security testing,    
covering both the visible and the hidden parts of your web attack surface. As you are using 
our industry-leading scanning technology in development and production, you can also 
ensure that your web APIs are subjected to the same level of vulnerability testing. All this 
is integrated into your existing workflows without clunky add-on toolchains or waiting for                         
external security testing.
You now have all you need to scan and continuously secure your entire web attack           
surface – so get to it before the next attack comes.
Cover Your APIs: Securing Your Hidden Web Attack Surface13
FIND US
twitter.com/invictisecurity
facebook.com/invicti-security
linkedin.com/company/invicti-security
Invicti Security is changing the way web applications are secured. An AppSec 
leader for 15 years, Invicti delivers DAST, IAST, and SCA technologies that empower 
organizations in every industry to continuously scan and secure all of their web 
applications and APIs with a highly integrated, automated approach spanning the 
entire software development lifecycle. Invicti is headquartered in Austin, Texas, and 
serves more than 3,000 organizations of all sizes all over the world.