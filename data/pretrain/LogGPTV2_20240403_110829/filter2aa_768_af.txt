第四，将异常登记结构中的处理函数作为参数调用 RtlpExecutehandlerFor- 
Unwind 函数，即： 
nDisposition = RtlpExecutehandlerForUnwind( 
        pExceptionRecord, pExceptionRegitrationRecord,  
        &context,  &DispatcherContext, pExceptionRegitrationRecord ->handler ); 
RtlpExecuteHandlerForUnwind 函数与 RtlpExecuteHandlerForException 非常
类似，它只是先将处理内嵌异常的函数地址赋给 EDX 寄存器，然后便自然进入（Fall 
Through ） 到 紧 随 其 后 的 ExecuteHandler 函 数 中 。 ExecuteHandler 内 部 会 调 用
ExecuteHandler2 函数， ExecuteHandler2 内部调用真正的异常处理函数，比如
_uraw_seh_handler。在异常处理函数返回后，标志着这个函数的展开工作结束。 
第五，调用 RtlpUnlinkHandler(pExceptionRegitrationRecord)将刚才展开结束
的异常处理器从 FS:[0]链条上移除。 
第六，取出下一个异常登记结构并回到第 4 步，直到遇到参数 pTargetFrame 所指定
的记录，标志着展开操作结束。 
第七，调用 ZwContinue(Context, FALSE)恢复到 Context 结构中指定的状态，并继
续执行，如果执行成功，程序就“飞”回到 ulTargetIpAddress 参数所指定的地址，即
标号__ret_label 所代表的地址，也就是返回到_global_unwind2 函数中。 
全局展开结束后，FS:[0]指向的便是声明愿意处理异常的登记结构了。接下来，
_except_handler3 函 数 会 将 这 个 结 构 中 记 录 的
EBP
值 （ 即 _EXCEPTION_ 
REGISTRATION 结构的_ebp 字段）设置到 EBP 寄存器中。这样栈便恢复到了这个异常处
理器所对应的栈帧。对于我们的例子，就是把栈恢复到 main 函数的栈帧，FS:[0]链条也是
main 函数调用 FuncFoo 之前的样子，此时的状态与 main 函数中发生异常需要执行异常处
理块是一样的。而后， _except_handler3 函数会调用异常处理块，也就是执行
pRegistrationFrame->scopetable[trylevel].lpfnHandler()。异常处理块结束后便
会自然进入（Fall Through）到所属的函数中，不会再返回到_except_ handler3 函数。
对于我们的例子，在 main 函数的异常处理块（第 43 行）执行后，便自然地执行后面的第
46 行和第 47 行了。 
24.6.3  局部展开（Local Unwind） 
那么，在每个异常处理器函数收到展开调用后应该做些什么呢？总的来说，就是完成
该处理函数范围内的清理和善后工作。因为 VC 为每个使用 SEH 的函数注册了一个异常
处理器，这意味着一个处理器的管理范围是它所负责的那个函数。相对于全局展开需要遍
历 FS:[0]链条依次调用多个异常处理器来讲，我们把每个异常处理器收到全局展开调用后
《软件调试》补编 
- 26 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
所作的本函数范围内的清理工作叫局部展开。因为 RtlUnwind 会从 FS:[0]链条注销被展开
的登记结构，即上面描述的第 5 步，所以局部展开时不需要注销自己的登记结构。 
概括来讲，局部展开主要是完成如下两项任务。 
第一，遍历范围表（scopetable）中属于被展开范围的各个表项，察看是否有终结处
理块（__try{}__finally 结构的 finally 块）需要执行。 
第二，对于 C++程序，调用被展开范围内还存活对象调用函数内还存活对象（alive 
objects）的析构函数。C++标准规定当栈被展开时，异常发生时仍然存活着的对象的析构
函数应该被调用。这一操作很多时候被简称为对象展开（Object Unwind）。 
我们将在下一节讨论__try{}__finally 结构。现在来看对象展开，如清单 24-17 所
示的 SehUwObj 程序。如果不带任何命令行参数执行 SehUwObj，那么 argc = 1，这会让
main 函数使用参数 n = 0 调用 FuncObjUnwind 函数，在第 23 行会发生一个除零异常。这
时，第 20 行实例化的 bug0 对象依然有效（存活），而 bug1 对象还没创建。按照 C++标准，
当栈展开时应该调用 CBug 的析构函数来析构 bug0 对象。 
清单 24-17  演示对象展开的 SehUwObj 程序 
1 
#include "stdafx.h" 
2 
#include  
3 
4 
class CBug 
5 
{ 
6 
public: 
7 
    CBug(int n) : m_nIndex(n){ printf("Bug %d constructed\n", m_nIndex);} 
8 
    ~CBug(){ printf("Bug %d deconstructed\n", m_nIndex);}; 
9 
protected: 
10 
    int m_nIndex; 
11 
}; 
12 
int FuncObjUnwind(int n) 
13 
{ 
14 
    CBug bug0(0); 
15 
    __try 
16 
    { 
17 
        n=1/n; 
// n=0 时会触发除零异常 
18 
    } 
19 
    __except(EXCEPTION_CONTINUE_SEARCH) 
20 
    { 
21 
        CBug bug1(1); 
22 
        n=0x122; 
23 
    } 
24 
    return n; 
25 
} 
26 
27 
int main(int argc, char* argv[]) 
28 
{ 
29 
    __try 
30 
    { 
31 
        printf("FuncObjUnwind got %x!\n", FuncObjUnwind(argc-1)); 
32 
    } 
33 
    __except(printf("Filter in main\n"), EXCEPTION_EXECUTE_HANDLER) 
34 
    { 
35 
        printf("Handling block in main\n"); 
36 
    } 
37 
    return 0; 
38 
} 
在 VC6 中编译以上代码，会得到多个 C4509 号警告信息： 
C:\...\ SehUwObj.cpp(32) : warning C4509: nonstandard extension used: ' 
FuncObjUnwind' uses SEH and 'bug1' has destructor 
上面的警告告诉我们，FuncObjUnwind 函数使用了不属于 C++标准的 SEH 扩展（即
__try 和__except），而且 bug1 对象有析构函数。 
接下来还有一个 C2712 号错误： 
《软件调试》补编 
- 27 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
C:\...\ SehUwObj.cpp(34) : error C2712: Cannot use __try in functions that require 
object unwinding 
这个错误明确地告诉我们，不可以在需要对象展开的函数中使用__try{}__ except()
扩展结构。察看 MSDN，对以上警告的一种解决建议是使用 C++的 try{}catch()结构。 
如果在项目属性中不启用 C++异常处理（Project > Settings > C++ > 选取 C++ 
Language > 不选中 Enable Exception Handling），那么没有上面的编译错误，但警告信息还
在。执行编译好的程序，得到的结果如下： 
Bug 0 constructed. 
Filter in main. 
Handling block in main. 
这个结果说明，由于执行第 17 行时发生了异常，程序仿佛从第 17 行（FuncObjUnwind
函数）直接飞到了第 33 行（main 函数）。FuncObjUnwind 函数中第 17 行后的代码和 main
函数中尚未执行完的 printf 函数都因为发生异常而被跳过，Bug0 对象也没能被析构，这是
不符合 C++标准的，这正是编译器发出警告信息和错误信息的原因。 
总结以上分析可以得出结论，VC 的__try{}__except()结构不支持 C++标准所规定
的对象展开。这主要是因为对象展开需要记录对象的生存范围和析构函数地址等与 C++
语言有关的信息，而__try{}__except()结构是一种既可以用于 C 语言，也可以用于 C++
语言的结构，如果加入大量对 C++的支持，那么必然会影响使用 C 语言编写的大量系统
代码和驱动程序代码的性能。因此，VC 编译器的做法是如果要支持对象展开，那么就使
用 C++的 try{}catch()结构。 
事实上，__try{}__except()结构的异常处理函数_except_handler3 会调用一个名
为_local_unwind2 的函数执行局部展开动作。该函数的原型如下： 
void _local_unwind2(_EXCEPTION_RECORD * frame, DWORD trylevel) 
因为不支持对象展开，_local_unwind2 的实现比较简单，它只是遍历 scopetable，
寻找其中的__try{}__finally 块（特征为 lpfnFilter 字段为空），找到后执行对应的
lpfnHandler 函数（即 finally 块），循环的结束条件是遍历了整个 scopetable 或到达参数
trylevel 所指定的块。我们将在下一节详细介绍以上过程。 
24.7  __try{}__finally 结构 
在对__try{}__except()结构有了比较深入的理解后，我们来看一下 Windows 结构
化异常处理中的终结处理，也就是__try{}__finally()结构。我们依然以一个简单的控
制台程序 SehFinally 为例（见清单 24-18）。 
清单 24-18  SehFinally 程序的源代码 
1 
#include "stdafx.h" 
2 
#include  
3 
4 
int SehFinally(int n) 
5 
{ 
6 
    __try 
7 
    { 
8 
        n=1/n; 
9 
    }__finally 
10 
    { 
11 
        printf("Finally block is executed.\n"); 
12 
    } 
13 
    return n; 
14 
} 
15 
int main(int argc, char* argv[]) 
16 
{ 
17 
    __try // TryMain 
18 
    { 
《软件调试》补编 
- 28 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
19 
        printf("SehFinally got %d\n", SehFinally(argc-1)); 
20 
    }__except(printf("Filter expression in main is evaluated.\n"), 
21 
        EXCEPTION_EXECUTE_HANDLER) 
22 
    { 
23 
        printf("Exception handling block is executed.\n"); 
24 
    } 
25 
    return 0; 
26 
} 
观察 SehFinally 函数的汇编指令（见清单 24-19），很容易看出编译器使用的编译方
法 与 编 译 __try{}__except 结 构 非 常 类 似 。 事 实 上 ， VC 使 用 统 一 的 数 据 结 构
（scope_entry）和处理函数（_except_handler3）来处理__try{}__except 结构和
__try{}__finally 结构。区分这两种结构的方法也非常直观，那就是__try{}__finally
结构所对应的 scope_entry 的 lpfnFilter 字段（过滤表达式）为空，也就是说，编译
器是把__try{}__finally 结构看作过滤表达式为 NULL 的特殊__try{}__except 结构
来编译的。具体来说，像把异常处理块编译成函数形式一样，终结块也被编译为一种函数
形式，我们不妨将其称为终结块函数。在清单 24-20 中，第 29～32 行便是 SehFinally
函数的终结块函数。 
清单 24-19  SehFinally 函数（发布版本）的反汇编结果 
1 
00401000 55              push    ebp     
;保护父函数的栈帧基地址 