putchar 函数在实际中常常被定义为宏，这样可以避免处理字符时调用函数所需的运行时开
销。头文件中定义的函数也常常是通过宏实现的。
可以通过#undef 指令取消名字的宏定义，这样做可以保证后续的调用是函数调用，而不 是宏调用:
#undef getchar
int getchar(void) { ... }
形式参数不能用带引号的字符串替换。但是，如果在替换文本中，参数名以#作为前缀则 结果将被扩展为由实际参数替换该参数的带引号的字符串。例如，可以将它与字符串连接运 算结合起来编写一个调试打印宏:
#define              dprint(expr)              printf(#expr " = %g\n", expr)
使用语句
dprint(x/y)
调用该宏时，该宏将被扩展为:
printf("x/y" " = &g\n", x/y);
其中的字符串被连接起来了，这样，该宏调用的效果等价于
printf("x/y = &g\n", x/y);
在实际参数中，每个双引号"将被替换为\"，反斜杠\将被替换为\\，因此替换后的字符串是 合法的字符串常量。
预处理器运算符##为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与
##相邻，则该参数将被实际参数替换，##与前后的空白符将被删除，并对替换后的结果重新
扫描。例如，下面定义的宏 paste 用于连接两个参数
#define              paste(front, back)              front ## back
因此，宏调用 paste(name, 1)的结果将建立记号 name1。
##的嵌套使用规则比较难以掌握，详细细节请参阅附录 A。
练习 4•14             定义宏 swap(t, x, y)以交换 t 类型的两个参数。(使用程序块结构会对 你有所帮助。)
4.11.3.               条件包含
还可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理执行的过程 中进行计算。这种方式为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了 一种手段。
#if 语句对其中的常量整型表达式(其中不能包含 sizeof、类型转换运算符或 enum 常 量)进行求值，若该表达式的值不等于 0，则包含其后的各行，直到遇到#endif、#elif 或
#else 语句为止(预处理器语句#elif 类似于 else if)。在#if 语句中可以使用表达式 defined(名字)，该表达式的值遵循下列规则:当名字已经定义时，其值为    1;否则，其值 为 0。
例如，为了保证 hdr.h 文件的内容只被包含一次，可以将该文件的内容包含在下列形式 的条件语句中:
#if !defined(HDR)
#define HDR
/* hdr.h 文件的内容放在这里 */
#endif
第一次包含头文件 hdr.h 时，将定义名字 HDR;此后再次包含该头文件时，会发现该名字已 经定义，这样将直接跳转到#endif 处。类似的方式也可以用来避免多次重复包含同一文件。 如果多个头文件能够一致地使用这种方式，那么，每个头文件都可以将它所依赖的任何头文 件包含进来，用户不必考虑和处理头文件之间的各种依赖关系。
下面的这段预处理代码首先测试系统变量 SYSTEM，然后根据该变量的值确定包含哪个版 本的头文件:
#if SYSTEM == SYSV
#define HDR "sysv.h"
#elif SYSTEM == BSD
#define HDR "bsd.h"
#elif SYSTEM == MSDOS
#define HDR "msdos.h"
#else
#define HDR "default.h"
#endif
#include HDR
C 语言专门定义了两个预处理语句#ifdef 与#ifndef，它们用来测试某个名字是否已经 定义。上面有关#if 的第一个例子可以改写为下列形式:
#ifndef HDR
#define EDR
/* hdr.h 文件的内容放在这里 */
#endif
第5章 指针与数组
指针是一种保存变量地址的变量。在 C 语言中，指针的使用非常广泛，原因之一是，指 针常常是表达某个计算的惟一途径，另一个原因是，同其它方法比较起来，使用指针通常可 以生成更高效、更紧凑的代码。指针与数组之间的关系十分密切，我们将在本章中讨论它们 之间的关系，并探讨如何利用这种关系。
指针和 goto 语句一样，会导致程序难以理解。如果使用者粗心，指针很容易就指向了错 误的地方。但是，如果谨慎地使用指针，便可以利用它写出简单、清晰的程序。在本章中我 们将尽力说明这一点。
ANSI C 的一个最重要的变化是，它明确地制定了操纵指针的规则。事实上，这些规则已 经被很多优秀的程序设计人员和编译器所采纳。此外，ANSI C 使用类型 void *(指向 void 的指针)代替 char *作为通用指针的类型。
5.1 指针与地址
首先，我们通过一个简单的示意图来说明内存是如何组织的。通常的机器都有一系列连 续编号或编址的存储单元，过些存储单元可以单个进行操纵，也可以以连续成组的方式操纵。 通常情况下，机器的一个字节可以存放一个 char 类型的数据，两个相邻的字节存储单元可存 储一个  short(短整型)类型的数据，而  4  个相邻的字节存储单元可存储一个  long(长整型) 类型的数据。指针是能够存放一个地址的一组存储单元(通常是两个或 4 个字节)。因此，如 果 c 的类型是 char，并且 p 是指向 c 的指针，则可用图 5•1 表示它们之间的关系:
图 5•1
一元运算符&可用于取一个对象的地址，因此，下列语句:
p = &c;
将把 c 的地址赋值给变量 p，我们称 p 为"指向”  c 的指针。地址运算符&只能应用于内存中 的对象，即变量与数组元素。它不能作用于表达式、常量或 register 类型的变量。
一元运算符*是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对 象。我们在这里假定 x 与 y 是整数，而 ip 是指向 int 类型的指针，下面的代码段说明了如 何在程序中声明指针以及如何使用运算符&和*:
int x = 1, y = 2, z[10];
int *ip;              /* ip is a pointer to int */
ip = &x;              /* ip now points to x */
y = *ip;              /* y is now 1 */
*ip = 0;              /* x is now 0 */
ip = &z[0];              /* ip now points to z[0] */
变量 x、y 与 z 的声明方式我们已经在前面的章节中见到过。我们来看指针 ip 的声明， 如下所示:
int *ip;
这样声明是为了便于记忆。该声明语句表明表达式*ip 的结果是 int 类型。这种声明变量的 语法与声明该变量所在表达式的语法类似。同样的原因，对函数的声明也可以采用这种方式。 例如，声明
double *dp，atof(char *);
表明，在表达式中，*dp 和 atof(s)的值都是 double 类型，且 atof 的参数是一个指向 char
类型的指针。
我们应该注意，指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某 种特定的数据类型。(一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针， 但它不能间接引用其自身。我们将在 5.11 节中详细讨论该问题)。
如果指针 ip 指向整型变量，那么在 x 可以出现的任何上下文中都可以使用*ip，因此， 语句
*ip = *ip + 10;
将把*ip 的值增加 10。 一元运算符*和&的优先级比算术运算符的优先级高，因此，赋值语句
y = *ip + 1
将把*ip 指向的对象的值取出并加 1，然后再将结果赋值给 y，而下列赋值语句:
*ip += 1
则将 ip 指向的对象的值加 1，它等同于
++*ip
或
(*ip)++
语句的执行结果。语句(*ip)++中的圆括号是必需的，否则，该表达式将对 ip 进行加 1 运算， 而不是对 ip 指向的对象进行加 1 运算，这是因为，类似于*和++这样的一元运算符遵循从右 至左的结合顺序。
最后说明一点，由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用 的方法使用。例如，如果 iq 是另一个指向整型的指针，那么语句
iq = ip
将把 ip 中的值拷贝到 iq 中，这样，指针 iq 也将指向 ip 指向的对象。
5.2 指针与函数参数
由于 C 语言是以传值的方式将参数值传递给被调用函数。因此，被调用函数不能直接修 改主调函数中变最的值。例如，排序函数可能会使用一个名为 swap 的函数来交换两个次序颠 倒的元素。但是，如果将 swap 函数定义为下列形式:
void swap(int x, int y)              /* WRONG */
{
int temp;
temp = x; x = y;
y = temp;
}
则下列语句无法达到该目的。
swap(a, b);
这是因为，由于参数传递采用传值方式，因此上述的 swap 函数不会影响到调用它的例程中的 参数 a 和 b 的值。该函数仅仅交换了 a 和 b 的副本的值。
那么，如何实现我们的目标昵，可以使主调程序将指向所要交换的变量的指针传递给被 调用函数，即:
swap(&a, &b);
由于一元运算符&用来取变量的地址，这样&a 就是一个指向变量 a 的指针。swap 函数的所有 参数都声明为指针，并且通过这些指针来间接访问它们指向的操作数。
void swap(int *px, int *py)              /* interchange *px and *py */
{
int temp;
temp = *px;
*px = *py;
*py = temp;
}
我们通过图 5•2 进行说明。
图 5•2
指针参数使得被调用函数能够访问和修改主调函数中对象的值。我们来看这样一个例子: 函数 getint 接受自由格式的输入，并执行转换，将输入的字符流分解成整数，且每次调用 得到一个整数。getint 需要返回转换后得到的整数，并且，在到达输入结尾时要返回文件结 束标记。这些值必须通过不同的方式返回。EOF(文件结束标记)可以用任何值表示，当然也 可用一个输入的整数表示。
可以这样设计该函数:将标识是否到达文件结尾的状态作为 getint 函数的返回值，同 时，使用一个指针参数存储转换后得到的整数并传回给主调函数。函数 scanf 的实现就采用 了这种方法，具体细节请参见 7.4 节。
下面的循环语句调用 getint 函数给一个整型数组赋值:
int n, array[SIZE], getint(int *);
for (n = 0; n 
int getch(void); void ungetch(int);
/* getint:              get next integer from input into *pn */ int getint(int *pn)
{
int c, sign;
while (isspace(c = getch()))              /* skip white space */
;
if (!isdigit(c) && c != EOF && c != '+' && c != '•') { ungetch(c);              /* it is not a number */
return 0;
}
sign = (c == '•') ? •1 : 1;
if (c == '+' || c == '•') c = getch();
for (*pn = 0; isdigit(c), c = getch())
*pn = 10 * *pn + (c • '0');
*pn *= sign; if (c != EOF)
ungetch(c); return c;
}
在 getint 函数中，*pn 始终作为一个普通的整型变量使用。其中还使用了 getch 和 ungetch 两个函数(参见 4.3 节)，借助这两个函数，函数 getint 必须读入的一个多余字符就可以重 新写回到输入中。
练习 5•1             在上面的例子中，如果符号+或•的后面紧跟的不是数字，getint 函数将把 符号视为数字 0 的有效表达方式。修改该函数，将这种形式的+或•符号重新写回到输入流中。
练习 5•2             模仿函数 getint 的实现方法，编写一个读取浮点数的函数 getfloat。 getfloat 函数的返回值应该是什么类型?