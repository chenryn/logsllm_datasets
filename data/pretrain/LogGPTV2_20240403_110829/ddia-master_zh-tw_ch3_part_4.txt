### B树
前面讨论的日志结构索引看起来已经相当可用了，但它们却不是最常见的索引型别。使用最广泛的索引结构和日志结构索引相当不同，它就是我们接下来要讨论的 B 树。
从 1970 年被引入【17】，仅不到 10 年后就变得 “无处不在”【18】，B 树很好地经受了时间的考验。在几乎所有的关系资料库中，它们仍然是标准的索引实现，许多非关系资料库也会使用到 B 树。
像 SSTables 一样，B 树保持按键排序的键值对，这允许高效的键值查询和范围查询。但这也就是仅有的相似之处了：B 树有著非常不同的设计理念。
我们前面看到的日志结构索引将资料库分解为可变大小的段，通常是几兆位元组或更大的大小，并且总是按顺序写入段。相比之下，B 树将资料库分解成固定大小的 **块（block）** 或 **分页（page）**，传统上大小为 4KB（有时会更大），并且一次只能读取或写入一个页面。这种设计更接近于底层硬体，因为硬碟空间也是按固定大小的块来组织的。
每个页面都可以使用地址或位置来标识，这允许一个页面引用另一个页面 —— 类似于指标，但在硬碟而不是在记忆体中。我们可以使用这些页面引用来构建一个页面树，如 [图 3-6](../img/fig3-6.png) 所示。
![](../img/fig3-6.png)
**图 3-6 使用 B 树索引查询一个键**
一个页面会被指定为 B 树的根；在索引中查询一个键时，就从这里开始。该页面包含几个键和对子页面的引用。每个子页面负责一段连续范围的键，根页面上每两个引用之间的键，表示相邻子页面管理的键的范围（边界）。
在 [图 3-6](../img/fig3-6.png) 的例子中，我们正在寻找键 251 ，所以我们知道我们需要跟踪边界 200 和 300 之间的页面引用。这将我们带到一个类似的页面，进一步将 200 到 300 的范围拆分到子范围。
最终，我们将到达某个包含单个键的页面（叶子页面，leaf page），该页面或者直接包含每个键的值，或者包含了对可以找到值的页面的引用。
在 B 树的一个页面中对子页面的引用的数量称为 **分支因子（branching factor）**。例如，在 [图 3-6](../img/fig3-6.png) 中，分支因子是 6。在实践中，分支因子的大小取决于储存页面引用和范围边界所需的空间，但这个值通常是几百。
如果要更新 B 树中现有键的值，需要搜寻包含该键的叶子页面，更改该页面中的值，并将该页面写回到硬碟（对该页面的任何引用都将保持有效）。如果你想新增一个新的键，你需要找到其范围能包含新键的页面，并将其新增到该页面。如果页面中没有足够的可用空间容纳新键，则将其分成两个半满页面，并更新父页面以反映新的键范围分割槽，如 [图 3-7](../img/fig3-7.png) 所示 [^ii]。
![](../img/fig3-7.png)
**图 3-7 透过分割页面来生长 B 树**
[^ii]: 向 B 树中插入一个新的键是相当符合直觉的，但删除一个键（同时保持树平衡）就会牵扯很多其他东西了【2】。
这个演算法可以确保树保持平衡：具有 n 个键的 B 树总是具有 $O (log n)$ 的深度。大多数资料库可以放入一个三到四层的 B 树，所以你不需要追踪多个页面引用来找到你正在查询的页面（分支因子为 500 的 4KB 页面的四层树可以储存多达 256TB 的资料）。
#### 让B树更可靠
B 树的基本底层写操作是用新资料覆写硬碟上的页面，并假定覆写不改变页面的位置：即，当页面被覆写时，对该页面的所有引用保持完整。这与日志结构索引（如 LSM 树）形成鲜明对比，后者只追加到档案（并最终删除过时的档案），但从不修改档案中已有的内容。
你可以把覆写硬碟上的页面对应为实际的硬体操作。在磁性硬碟驱动器上，这意味著将磁头移动到正确的位置，等待旋转盘上的正确位置出现，然后用新的资料覆写适当的扇区。在固态硬碟上，由于 SSD 必须一次擦除和重写相当大的储存晶片块，所以会发生更复杂的事情【19】。
而且，一些操作需要覆写几个不同的页面。例如，如果因为插入导致页面过满而拆分页面，则需要写入新拆分的两个页面，并覆写其父页面以更新对两个子页面的引用。这是一个危险的操作，因为如果资料库在系列操作进行到一半时崩溃，那么最终将导致一个损坏的索引（例如，可能有一个孤儿页面没有被任何页面引用） 。
为了使资料库能处理异常崩溃的场景，B 树实现通常会带有一个额外的硬碟资料结构：**预写式日志**（WAL，即 write-ahead log，也称为 **重做日志**，即 redo log）。这是一个仅追加的档案，每个 B 树的修改在其能被应用到树本身的页面之前都必须先写入到该档案。当资料库在崩溃后恢复时，这个日志将被用来使 B 树恢复到一致的状态【5,20】。
另外还有一个更新页面的复杂情况是，如果多个执行绪要同时访问 B 树，则需要仔细的并发控制 —— 否则执行绪可能会看到树处于不一致的状态。这通常是透过使用 **锁存器**（latches，轻量级锁）保护树的资料结构来完成。日志结构化的方法在这方面更简单，因为它们在后台进行所有的合并，而不会干扰新接收到的查询，并且能够时不时地将段档案切换为新的（该切换是原子操作）。
#### B树的最佳化
由于 B 树已经存在了很久，所以并不奇怪这么多年下来有很多最佳化的设计被开发出来，仅举几例：
* 不同于覆写页面并维护 WAL 以支援崩溃恢复，一些资料库（如 LMDB）使用写时复制方案【21】。经过修改的页面被写入到不同的位置，并且还在树中建立了父页面的新版本，以指向新的位置。这种方法对于并发控制也很有用，我们将在 “[快照隔离和可重复读](ch7.md#快照隔离和可重复读)” 中看到。
* 我们可以透过不储存整个键，而是缩短其大小，来节省页面空间。特别是在树内部的页面上，键只需要提供足够的资讯来充当键范围之间的边界。在页面中包含更多的键允许树具有更高的分支因子，因此也就允许更少的层级 [^iii]。
* 通常，页面可以放置在硬碟上的任何位置；没有什么要求相邻键范围的页面也放在硬碟上相邻的区域。如果某个查询需要按照排序顺序扫描大部分的键范围，那么这种按页面储存的布局可能会效率低下，因为每个页面的读取都需要执行一次硬碟查询。因此，许多 B 树的实现在布局树时会尽量使叶子页面按顺序出现在硬碟上。但是，随著树的增长，要维持这个顺序是很困难的。相比之下，由于 LSM 树在合并过程中一次性重写一大段储存，所以它们更容易使顺序键在硬碟上连续储存。
* 额外的指标被新增到树中。例如，每个叶子页面可以引用其左边和右边的兄弟页面，使得不用跳回父页面就能按顺序对键进行扫描。
* B 树的变体如 **分形树（fractal trees）**【22】借用了一些日志结构的思想来减少硬碟查询（而且它们与分形无关）。
[^iii]: 这个变种有时被称为 B+ 树，但因为这个最佳化已被广泛使用，所以经常无法区分于其它的 B 树变种。
### 比较B树和LSM树
尽管 B 树实现通常比 LSM 树实现更成熟，但 LSM 树由于效能特征也非常有趣。根据经验，通常 LSM 树的写入速度更快，而 B 树的读取速度更快【23】。LSM 树上的读取通常比较慢，因为它们必须检查几种不同的资料结构和不同压缩（Compaction）层级的 SSTables。
然而，基准测试的结果通常和工作负载的细节相关。你需要用你特有的工作负载来测试系统，以便进行有效的比较。在本节中，我们将简要讨论一些在衡量储存引擎效能时值得考虑的事情。
#### LSM树的优点