The main challenge is that blocking network connections or redirecting them
to internal servers would interfere with the inner workings of the botnet and
cause interesting behaviors to go missed. This contradicts with our goal to mon-
itor botnets and identify their lifecycle. On the other hand, running unknown
malware completely unsupervised may result in our analysis system participat-
ing in malicious actions. We opt for a trade-oﬀ between tracking quality and
execution containment. Our containment policy blocks SMTP to avoid prevent
sending spam. Reverse shells and SOCKS connections are also blocked. Future
work includes improving our containment strategy and employ more sophisti-
cated approaches like [22].
3 Evaluation
This section describes the experiments we have performed to demonstrate that
our approach is eﬀective for botnet tracking. We ﬁrst describe our experiment
setup, and then present the results of using BotWatcher to monitor four
current botnets. Finally, we also apply BotWatcher to another OS in order
to show its genericity. The detailed results of our experiments including the
concrete output generated by BotWatcher can be found in a supplementary
document [12].
3.1 Setup of the Analysis Environment
We conducted our experiments using a PC with a 3.4 GHz Intel Core i7-2600
CPU and 16 GB of main memory. This PC ran Ubuntu 14.04 x86-64. We used
576
T. Barabosch et al.
VirtualBox [5] to create three virtual analysis environments running Windows
XP SP3 (32-bits, used in Case Study 1 and 4), Windows 8.1 (32-bits, used in
Case Study 2 and 3), and Mac OS X 10.9.5 Mavericks (64-bits, used in Case
Study 5). The virtual machine was connected to its own private virtual network,
which was connected via network address translation to the Internet.
3.2 Case Study 1: Upatre
Upatre is a Trojan downloader that operates at least since August 2013 [10].
It is spread either via drive-by-downloads or spam. We executed Upatre1 on
2015-01-15 at 12:06 PM and tracked the botnet until 2015-01-22 at 12:15 PM.
Fig. 3. Upatre case study
Results. Figure 3 shows the inferred behavior of the botnet. Initially, Upatre
contacted its C&C server and downloaded an additional binary that was later
executed. This binary injected itself into the already running process svchost.
exe. Our manual analysis reveals that the new binary is a banking Trojan called
Dyzap (also known as Dyre) [3]. BotWatcher detected several malware down-
loads within the ﬁrst 24 h. Later manual analysis revealed the following: ﬁve of
these downloads are updates of Dyzap. Some of these updates that occurred
in the ﬁrst six hours were especially interesting; ﬁrst, the rootkit Pushdo (also
known as Cutwail) was downloaded and executed. BotWatcher observed then
how Pushdo created a registry entry under a key that is often used for surviv-
ing system reboots. The second interesting malware update was Pushdo down-
loading the credential stealer Kegotip. We determined this in a later analysis.
BotWatcher detected that Kegotip was injected into a newly created process
named svchost.exe. Kegotip enumerates all ﬁles on the hard disk and checks
for online credentials like FTP credentials [1]. After having started, Kegotip
began opening and closing a large amount of ﬁles, which BotWatcher inferred
as MassiveFileAccess behavior. Pushdo began 24 h later resolving many dif-
ferent domain names which failed to resolve. BotWatcher inferred that the
malware is executing a domain generation algorithm.
1 MD5 sum Upatre: D4A999B1314CFE152774F709BB4EC94B.
BotWatcher: Transparent and Generic Botnet Tracking
577
Fig. 4. Example for BotWatcher’s inference rules. BotWatcher infers a malware
update (download of Kegotip by Pushdo) in the third dump. Also, a massive ﬁle access
(enumerating local ﬁles to look for credentials) is inferred in the seventh dump.
Figure 4 illustrates how BotWatcher inferred the MalwareDownload
event corresponding to the download of Kegotip as well as the enumeration of
local ﬁles that it performed subsequently. The ﬁgure shows selected events for
eleven consecutive memory dumps. The area of plotted dots is proportional to
the number of corresponding events observed in a given dump. At the third
dump, BotWatcher inferred the sequence of opening a connection, closing the
same connection, and starting a new process as a MalwareDownload event.
Also, the fact that many ﬁles were opened and closed in the seventh dump is
inferred as a massive ﬁle access event and that corresponds to the enumeration
of local ﬁles performed by Kegotip.
In total, BotWatcher observed four diﬀerent malware families (Upatre,
Dyzap, Pushdo, Kegotip) that form part of this botnet. In the course of the case
study BotWatcher collected eighteen malware downloads.
Discussion. In this case study, BotWatcher illuminated the diﬀerent com-
ponents of an Upatre-based botnet. BotWatcher was able to extract several
artifacts like executable ﬁles. Further investigations can be based on these arti-
facts. We would like to stress that a quick dynamic analysis would have only
given a shallow overview of this complex, multi-component botnet. In contrary,
BotWatcher monitors such botnets for a long time and is capable of detecting
various behaviors and dynamically loaded components that would otherwise be
missed.
578
T. Barabosch et al.
Fig. 5. Emotet case study.
3.3 Case Study 2: Emotet
Emotet is a modular botnet with a high degree of automation [2]. It is also
known as Feodo, Geodo, Cridex, or Dridex. In addition to a small loader module,
it has several modules for diﬀerent purposes. This includes a banking module,
an address book grabber, and a spamming module. The address book grabber
collects new email addresses for the spamming module, which in turn sends
emails with the loader module attached. The banking module ensures a steady
cash ﬂow [2]. We executed Emotet2 on 2015-05-19 at 3:56 PM and tracked the
botnet until 2015-05-22 at 4:19 PM.
Results. Immediately after execution, Emotet persisted in the system and after
thirty minutes it downloaded another binary (cr mss3.exe). As it can be seen
in Fig. 5, BotWatcher observed that the bot continuously tried to contact sev-
eral mail servers. By manually reverse engineering the binary, we could conﬁrm
that it is in fact a spamming module of Emotet. While the spamming contin-
ued, further binaries were downloaded; after three hours BotWatcher detected
the download and execution of another binary that performed a code injection.
Directly after that, BotWatcher observed massive access of ﬁles performed
by the process targeted by code injection. Our manual analysis shows that the
downloaded binary is an information stealer malware. The spamming stopped
after eight hours. After some period of inactivity, BotWatcher observed several
downloads of binaries combined with spamming activity that lasted for roughly
two thirds of a day. BotWatcher collected 48 binaries in total during this case
study. All these binaries injected code in other processes, which was correctly
detected by BotWatcher. 37 of these 48 binaries have unique MD5 hashes and
correspond only to a couple of modules that were rehashed periodically.
Discussion. Emotet showed a very high degree of automation during the case
study. BotWatcher observed periods of spamming, information exﬁltration
2 MD5 sum Emotet: 06B92478CB19FDE2665038CBDD0B1420.
BotWatcher: Transparent and Generic Botnet Tracking
579
and execution of further binaries. The insights provided by BotWatcher into
the botnet life-cycle and the collected binaries during the previous stages of
the botnet tracking facilitated our manual investigation of the various modules
involved. This allowed us to deduce key aspects of the botnet operation. First,
spamming occurs in periods that last several hours. Second, the botnet’s modules
are frequenly rehashed in order to evade AV products. Third, this rehashing
occurs more often during spamming periods.
3.4 Case Study 3: Gamarue
Gamarue is a malware downloader that is also known as Andromeda, which is
often distributed via spam. For this case study, we took a Gamarue sample from
a spam email related to a hotel booking conﬁrmation. We executed this sample3
on 2015-04-27 at 2:55 PM and tracked the botnet until 2015-05-06 at 7:08 AM.
Results. Initially, BotWatcher detected that Gamarue created a new process
– the system process msiexec.exe – and injected code into it. Then, Gamarue
terminated its dropper process. For the next three days BotWatcher detected
continuous HTTP-based C&C-server communication carried out by msiexec.
exe. On 2015-04-30 at 7:00 PM, BotWatcher observed a download performed
by msiexec.exe that is followed by the creation of a new process. Subsequently,
BotWatcher detected that this process created an autostart registry key in
order to persist in the system. Furthermore, BotWatcher noticed that another
system process – svchost.exe – was started and that code was injected into it.
This system process then contacted a C&C-server for further instructions. A
manual inspection of the downloaded executable revealed that Gamarue down-
loaded the bootkit Rovnix. For the rest of this case study, both samples stayed
active and continuously contacted their C&C-server.
Discussion. The C&C-server of Gamarue delayed the delivery of Rovnix for
around three days. There might be two possible explanations for this behav-
ior. First, the operators of this botnet were very cautious. In this scenario, it
took three days until the C&C-server trusted our bot and decided to send fur-
ther modules to the infected system. Second, the C&C-server had no commands
during this period of time and therefore let the bot wait.
The downloaded malware – Rovnix – is also used as infrastructure building
malware. Unfortunately, we could not observe further downloads within the last
four days of this case study. This case study shows that static analysis and
short-time dynamic analysis cannot cope with these kinds of operators. It shows
also the importance of tracking botnets for longer than the average sandbox
execution time in order to get a full overview about a botnet’s activities.
3 MD5 sum Gamarue: 28E01A0E29155E5B993DFF915ACEA976.
580
T. Barabosch et al.
Case Study 4: Necurs. Necurs is a complex botnet that performs several
malicious actions like sending spam and distributing additional malware [4]. In
order to remain stealthy and avoid detection from security tools, it is equipped
with a rootkit component to hide its userland components. We executed Necurs4
on 2015-01-23 at 8:59 AM and tracked the botnet until 2015-01-26 at 7:32 AM.
Fig. 6. Necurs case study.
Results. Figure 6 shows the behavior of the botnet as inferred by BotWatcher.
Necurs started by installing a kernel module and searching through all ﬁles on
the hard disk. Subsequently, it did not show any interesting activity for 24 h.
After that, the bot contacted the C&C server and initiated a download of an
additional module. BotWatcher detected this as malware update behavior.
After 30 h, the analysis environment’s hostname was resolved and a connec-
tivity test conducted. Further manual analysis revealed that Necurs checked if
its host IP has been already blacklisted on blocking lists. Afterwards, Bot-
Watcher detected continuous C&C communication with two IP addresses. A
manual analysis showed that the ﬁrst IP address was contacted to report back to
its C&C server. The second IP was contacted in order to request new spam tem-
plates. While continuously contacting its C&C serverand spam template server,
it also contacted various mail servers for sending spam. The latter behavior was
identiﬁed by BotWatcher as spamming behavior. This behavior lasted for two
days.
Discussion. BotWatcher detected all signiﬁcant behaviors such as malware
installation and update, rootkit installation and spamming. The detection of
these events pointed us directly to interesting spots so that we could further
analyze the detected behavior manually. This case study shows that execution
stalling on the client-side in combination with delaying on the server-side are an
eﬀective combination for evading short-term dynamic analyses.
4 MD5 sum Necurs: C39FBB4B968C882705F3DACAEF3F51C5.
BotWatcher: Transparent and Generic Botnet Tracking
581
3.5 Observing Mac OS X: OSX/VidInstaller
Malware also targets new platforms like Mac OS X due to an ongoing diversiﬁca-
tion of operating systems. However, there are only a few Mac OS X-based botnets
at the moment. Unfortunately, we could not ﬁnd a live botnet for this platform
during our experiments. C&C infrastructures of botnets like WireLurker were
already sinkholed or taken down. We decided to run BotWatcher with an
adware in order to show BotWatcher’s capacity to monitor other platforms
besides of Microsoft Windows. We chose the adware OSX/VidInstaller. This
adware might download and install further software. It comes disguised as a
codec, font or key generator. We executed OSX/VidInstaller5 on 2015-06-03 at
8:57 AM and observed it until 2015-06-03 at 1:13 PM. The guest system was
Mac OS X Mavericks (64 bits).
Observation and Discussion. After the execution of OSX/VidInstaller, Bot-
Watcher detected a new process. This process asked the user to agree to its
installation. We simulated a user and accepted this request. Subsequently, Bot-
Watcher observed several HTTP-requests to shady-looking domains. Also the
browser Safari was started presenting the user a webpage advertising a program
called MacKeeper. Once again we simulated a user and installed this program.
BotWatcher detected the creation of two MacKeeper-related processes. For
the remaining time no further activities occurred.
Foremost, we showed that our approach is also capable of analysing other
platforms that are increasingly targeted by cyber criminals. This platform agnos-
ticism is valuable to malware researchers. With the former primary malware
target Microsoft Windows in continuous decline, malware authors target other
popular platforms such as Mac OS X and Android.
4 Time-Based Evasion Techniques
Malware employs several techniques in order to evade dynamic analysis. A promi-
nent example is execution stalling to delay the execution of the actual malicious
payload. This technique exploits the fact that sandboxes analyze the malware
for a very limited period of time. Modern analysis approaches can circumvent
client-side execution stalling to elicit the malicious behavior (e.g. Hasten [21]).
However, command and control servers can also delay delivering modules or
commands to their bots. Given the fact that analysis tools cannot manipulate
the code on the server side, this is a powerful technique to stall the execution in
order to hinder dynamic analysis. Moreover, this serves as mechanism to estab-
lish a trust relationship with the recently joined bots. For a botmaster, it is
utterly important that a bot can be trusted so as to prevent being inﬁltrated
by malware analysts. Our experiments show that modern botnets move some
of these stalling techniques to the server side. This way they can achieve more
5 MD5 sum OSX/VidInstaller: 4ddf5d89249c58c5f0f9b38300b49b91.
582
T. Barabosch et al.
resilience against current anti-evasion approaches. We strongly believe that this
kind of evasion can only be circumvented by tracking over an extended period