User: for root, dirs, files in os.walk(rootDir, topdown='true'): is something regularly used in python scripts.  Just wondering is there any well known way to provide progress here?  When you have a large folder structure this API can take a while?
Thanks.
Assistant: The walk itself can't give you progress, because there's no way of knowing in advance how many entries are under some directory tree.*
However, in most programs that use walk, you're actually doing something with the files, which usually takes a whole lot longer than the implicit stat call. For example, grabbing my first program with os.walk in it, list(os.walk(path)) takes 2.301 seconds, while my actual function (despite only operating on a small percentage of those files) takes 139.104 seconds. And I think this kind of thing is pretty typical.
So, you can first read in the entire walk (e.g., by using list(os.walk(path))), and then use that information to generate the progress for your real work.
In a realistic program, you'd probably want to show an "indeterminate progress bar" with a label like "Determining size..." while doing the list(os.walk(path)), and then replace it with a percentage progress bar with "0/12345 files" once that's done. (In fact, I'm going to go add exactly that indeterminate progress bar to my program, now that I've thought of the idea…)
(For a single-threaded interactive program, you obviously wouldn't want to just block on list(os.walk(path)); you might do it in a background thread with a callback to your main thread, or do one iteration of the walk object and runLater the rest each time through the event loop, etc.)
* This isn't because no filesystem or OS ever could do such a thing, just because they don't. There would obviously be some tradeoffs—for example, creating and deleting lots of tiny files would be a lot slower if you had to walk up the whole tree updating counts. Classic Mac used to solve this problem by keeping a cached count in the Finder Info… which was great, except that it meant a call that could take either 1us or 1min to return, with no way of predicting which in advance (or interrupting it) programmatically.