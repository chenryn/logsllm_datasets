# babyaeg——自动化之路初探
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
babyaeg是强网杯的一道pwn。本题的场景不太常见，普通的pwn一般提供binary，然后在远端启动服务，由做题人将binary分析清楚后，形成exp攻击远端；本题则随机生成二进制文件，base64编码后发送给做题人，在五秒之内，做题人必须提供Payload，直接进行攻击，如果五秒时间内做题人没有成功任意代码执行，则连接关闭，一切重来。这就意味着，我们必须自动化地对binary进行分析。
## IO处理
作为本题的第一个步骤，我们首先要看看如何与远端进行交互：
> * * *
>
> Welcome to QWB BABYAEG->
> * * *
>
> I will send you a newly compiled binary (probably exploitable) in base64
> format  
>  after you get the binary, I will be waiting for your input as a plain text  
>  when your input is given, I will execute the binary with your input as
> argv[1]  
>  you have 5 seconds to build exploit payload  
>  hint: base64 -d 1.bin | gunzip > 1.elf  
>  wait…  
>
> H52Qf4owMSIgQAAACBMmFADAB4CDCSGFMKAQiMKEsIJBvIjQIg4ACgBY3ABAAwCKCAkktMjRIsuVIi/CYCiTpkIEHAEMSKgSIRybCX++9ClgKAAOOZFy3Khw…
>
> here, get this binary and give me some crafted argv[1] for explotation  
>  remember you only have 5 seconds… hurry up!  
>  time expired! bye!
我们获取的是一个base64编码后的字符串。为了避免大段大段的编码数据，我将它省略了。既然是自动化分析，我们必须获取足够多的样本，再从中找到共同点。一个一个地复制粘贴解码太dirty，我们要将自动化的思想运用到底，选择一个优雅的方式~~
    from pwn import *
    from ipdb import set_trace
    import os
    from exp import *
    def getbinary():
        p = remote('***.**.**.***', 40005)
        tmp = p.recvuntil('wait...n')
        res = p.recvuntil('n')[:-1]
        print res
        i = 0
        while True:
            if os.path.exists('binaries/binary' + str(i)):
                i += 1
                continue
            open('tmpbinary' + str(i), 'w').write(res)
            break
        os.system('base64 -d tmpbinary' + str(i) + ' | gunzip > binaries/binary' + str(i))
        os.system('rm tmpbinary' + str(i))
    getbinary()
反复运行这个脚本，或者自行添加循环，我们就能在binaries文件夹下得到一堆binary。以供接下来进一步分析。
## 静态分析
先看程序基本信息：
本题没有Stack
Canary，没有开PIE，这对于自动化分析是非常友好的。美中不足的地方在于打开了NX，这意味着我们有可能需要自动生成ROP，但是后面我们将有简单的方法解决这个问题。
我们随便挑一个binary用ida打开，先观察一下到底是个什么样的流程。按照惯例，先看主函数：
    __int64 __fastcall main(int a1, char **a2, char **a3)
    {
      __int64 result; // rax
      unsigned int v4; // eax
      int v5; // eax
      int v6; // eax
      int v7; // eax
      char v8; // [rsp+15h] [rbp-1Bh]
      char v9; // [rsp+16h] [rbp-1Ah]
      char v10; // [rsp+17h] [rbp-19h]
      int i; // [rsp+18h] [rbp-18h]
      int v12; // [rsp+1Ch] [rbp-14h]
      int v13; // [rsp+20h] [rbp-10h]
      int v14; // [rsp+24h] [rbp-Ch]
      int v15; // [rsp+28h] [rbp-8h]
      int v16; // [rsp+2Ch] [rbp-4h]
      if ( a1 == 2 )
      {
        v4 = sub_26095B9(1LL, 2LL, 3LL, 4LL, 5LL, 6LL);
        srand(v4);
        dword_280BC5C = strlen(a2[1]) >> 1;
        if ( dword_280BC5C 
    #include 
    #include 