### Reference Extractor and Its Role in Identifying PDF Parser Weaknesses

A reference extractor can facilitate the identification of weaknesses in other PDF parsers. However, there can never be a guarantee that an improved parser will faithfully follow the parsing logic of Adobe Reader. Even if a perfect parser could be developed, this work would need to be repeated for each version of Adobe Reader, given their unique parsing behaviors.

### Deployment of the Reference Extractor

Given that improving existing parsers depends on the existence of a reference extractor, it seems more straightforward to use the reference extractor directly. Figure 5 demonstrates the third possibility for attack mitigation, which involves deploying the reference JavaScript extractor along with a JavaScript-based classifier in a real-world scenario. Since the reference extractor can only precisely mimic the behavior of the specific version of Adobe Reader upon which it is based, it is best suited for controlled, relatively homogeneous environments (e.g., enterprises) where the versions of Adobe Reader in use are known.

To demonstrate the effectiveness of the reference extractor in improving the accuracy of existing JavaScript-based classifiers, we compared the performance of the original PJScan detector, which uses libpdfjs as its extractor, against a modified version using the reference JavaScript extractor.

Since PJScan can only classify samples containing JavaScript, we evaluated it against samples for which any extractor was able to produce JavaScript. While we cannot be certain that each of these samples actually contains JavaScript, the detection improvement can still be demonstrated. Since the reference extractor can also identify malformed samples, we excluded those from the evaluation, arguing that malformed files can be blocked without adversely affecting the end-user.

PJScan utilizes a One-Class Support Vector Machine (SVM) that needs to be trained on a malicious set before classifying any samples. A two-fold cross-validation was performed. Table VII shows the results of this evaluation, with the number of samples in each set shown in parentheses (for the reference extractors, these are the number of samples they considered well-formed). As can be seen, the use of the reference extractors greatly improves PJScan’s ability to detect malicious PDFs.

The primary reason for this improvement is that the reference JavaScript extractors can extract JavaScript from more of the malicious samples than libpdfjs. Of the 1453 malicious samples reported by any tool as containing JavaScript, libpdfjs is only able to produce 1021 extractions, whereas the version 9.5.0 and 11.0.08 reference extractors produce extractions for 1429 and 1013 out of the 1441 and 1021 malicious files they identify as well-formed, respectively.

Additionally, since only the samples that can actually be processed by each version of Adobe Reader are used to train PJScan, there is less noise in the training data, leading to a better model. For example, the versions of Adobe Reader we used do not open samples containing many older exploits that have been patched. By discarding these older malformed samples using the reference extractors, the classifier can be trained and evaluated against only newer exploits, increasing its accuracy. This also explains why the version 9.5.0 extractor has slightly better performance—since newer PDFs that cannot be opened by this version are filtered out, there is more similarity among the remaining malicious samples.

We then tested the effectiveness of PJScan combined with the reference JavaScript extractors using our obfuscated samples. Results show that when paired with the version 11.0.08 reference extractor, PJScan can now detect all the samples used in the parser confusion attacks, provided a PDF containing the same malicious payload is used in the training set. When paired with the version 9.5.0 reference extractor, PJScan can detect all of these samples except those using the R6 security handler, which is not supported by that version.

Table VIII shows the average runtime for each of the evaluated JavaScript extractors for all the samples obtained from VirusTotal. As expected, the Adobe Reader tool incurs a significant penalty for having to restore the virtual machine to a clean state after every iteration. Note that the performance of the reference extractor is comparable to MPScan, even though they do not appear to reset the system between samples [26]. The use of a reference monitor instead of dynamic hooking would also require this system reset and is significantly slower than running a VM.

In a real-world implementation, certain optimizations can be performed. For instance, by placing the virtual machine on a RAM disk instead of a hard drive, we can save approximately 2 seconds on VM snapshot restoration. Since the snapshot restoration can be performed after the extraction, the latency for receiving a sample's analysis can be greatly reduced, and a pipeline of analyzers could be produced to mitigate the remaining overhead.

Adobe Reader. Additionally, since we cannot afford to process any single sample indefinitely, we can fail to extract JavaScript that delays its execution or does not finish within the allotted time. In practice, however, these issues do not appear to be significant in terms of malicious PDF detection. Of the 10 malicious files that the reference extractor did not extract JavaScript from (out of 1453), one was malformed, and the remaining nine depended on user interaction. Fundamentally, these limitations are caused by the use of dynamic analysis, but as our evaluation has shown, static analysis also has its own limitations.

Malware often uses "anti-VM" or "anti-sandbox" techniques to avoid detection by electing not to exhibit malicious behavior in virtual environments. Although we are unaware of any such techniques used by malicious PDFs and think that the limited amount of information about the system available through the Adobe Reader JavaScript API would make them difficult to implement, we cannot claim that such checks are impossible. For example, it might be possible for an advanced attacker to test if the sandbox is disabled, which is required for the reference extractor to function. However, any such check would have to depend on the execution of some JavaScript, which would be extracted and could be used to classify the document as malicious or at least suspicious.

### Conclusion

In this paper, we conducted a systematic study on a new evasion technique called a PDF parser confusion attack, which aims to confuse the PDF parsers in malware detectors to evade detection. To enable a systematic study, we developed a reference JavaScript extractor by directly tapping into Adobe Reader and presented a mostly-automatic technique for developing it. By delving into the discrepancies between the reference extractor and existing extractors, we identified several new obfuscations and quantified their impact when used in parser confusion attacks on JavaScript extractors and malware detectors. By combining several of these obfuscations, we produced a malicious PDF that can successfully evade all the malware detectors evaluated, including signature-based, structure/metadata-based, and JavaScript-based detectors. To address parser confusion attacks, we discussed several mitigation techniques. In particular, we demonstrated that with our reference JavaScript extractor, the detection rate of an existing classifier increased significantly from 68% to 96% on our sample set and presented a possible deployment scenario for the reference extractor.

### Acknowledgements

We would like to thank anonymous reviewers and our shepherd Dr. Guofei Gu for their insightful feedback. This research was supported in part by the National Science Foundation Grant #1054605, Air Force Research Lab Grants #FA8750-13-2-0115 and #FA8750-15-2-0106, and DARPA Grant #FA8750-14-C-0118. Any opinions, findings, and conclusions in this paper are those of the authors and do not necessarily reflect the views of the funding agencies.

### Limitations

The primary limitation of the reference extractor is its ability to only extract code that is automatically executed by Adobe Reader.