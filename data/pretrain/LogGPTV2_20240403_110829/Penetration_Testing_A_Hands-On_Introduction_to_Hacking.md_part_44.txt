georgia@ubuntu:~$ gcc -g -fno-stack-protector -z execstack -o overflowtest overflowtest.c
To compile our C code as shown above, we use GCC, the GNU Compiler
Collection, which is built into Ubuntu by default. The -g option tells GCC
to add extra debugging information for GDB, the GNU debugger. We use
the -fno-stack-protector flag to turn off GCC’s stack-protection mechanism,
which would attempt to prevent buffer overflows if we left it turned on. The
-z execstack compiler option makes the stack executable, disabling another
buffer overflow prevention method. We tell GCC to compile overflowtest.c
into an executable called overflowtest with the -o option.
Recall that main takes the first command line argument to the program
and feeds it to function1, which copies the value into a five-character local
variable. Let’s run the program with the command line argument AAAA, as
shown here. Make overflowtest executable with chmod if necessary. We use
four As instead of five because a string ends with a null byte. Technically, if
we used five As, we would already be overflowing the buffer, albeit by just
one character.
georgia@ubuntu:~$ ./overflowtest AAAA
Executed normally
As shown, the program does what we expected: main calls function1,
function1 copies AAAA into buffer, function1 returns execution to main, and main
prints “Executed normally” to the console before the program exits. Maybe
if we give overflowtest some unexpected input, we can force it to behave in a
way that will help us cause a buffer overflow.
Causing a Crash
Now let’s try giving the program a long string of As as an argument, as
shown here.
georgia@ubuntu:~$ ./overflowtest AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
This time, the program crashes with a segmentation fault. Our pro-
gram’s problem lies with the implementation of strcpy, which we use in
function1. The strcpy function takes one string and copies it into another,
but it does not do any bounds checking to make sure the supplied argu-
ment will fit into the destination string variable. The strcpy function
will attempt to copy three, five, or even hundreds of characters into our
366 Chapter 16
five-character destination string. If our string is five characters long and
we copy in 100 characters, the other 95 will end up overwriting data at
adja cent memory addresses in the stack.
We could potentially overwrite the rest of function1’s stack frame and
even higher memory. Remember what’s at the memory address immedi-
ately after the base of that stack frame? Before the frame was pushed on
the stack, main pushed its return address onto the stack to designate where
execution should continue once function1 returns. If the string we copy into
buffer is long enough, we’ll overwrite memory from buffer straight through
to EBP, over the return address, and even into main’s stack frame.
Once strcpy places the first argument from overflowtest into buffer,
function1 returns back to main. Its stack frame is popped off the stack, and
the CPU tries to execute the instruction at the memory location in the return
address. Because we’ve overwritten the return address with a long string of
As, as shown in Figure 16-4, the CPU will try to execute the instructions at
the memory address 41414141 (the hexadecimal representation of four As).
low memory
ESP
function1’s stack frame
buffer = [AAAAA]
EBP AAAA
return address AAAA
AAAA
main’s stack frame
high memory
Figure 16-4: Memory after strcpy is executed
However, our program can’t read, write, or execute from anywhere it
likes in memory because that would cause utter chaos. The memory address
41414141 is out of bounds for our program, and it crashes with the segmenta-
tion fault we saw at the beginning of this section.
In the next section, we’ll take a closer look behind the scenes when the
program crashes. In GDB, discussed next, you can use the command mainte-
nance info sections to see which memory regions are mapped to the process.
Running GDB
We can see exactly what’s happening in memory by running our program
in a debugger. Our Ubuntu machine comes with GDB, so let’s open the pro-
gram in the debugger, as shown here, and watch what happens in memory
if we overflow our five-character buffer.
A Stack-Based Buffer Overflow in Linux 367
georgia@ubuntu:~$ gdb overflowtest
(gdb)
Before we run the program, we’ll set some breakpoints to pause execu-
tion at certain points in the program and allow us to view the state of
memory at those times. Because we compiled the program with the -g
flag, we can view the source code directly, as shown in Listing 16-2, and set
breakpoints at the lines where we would like to pause.
(gdb) list 1,16
1 #include 
2 #include 
3
4 void overflowed() {
5 printf("%s\n", "Execution Hijacked");
6 }
7
8 void function(char *str){
9 char buffer[5];
10 strcpy(buffer, str); u
11 } v
12 void main(int argc, char *argv[])
13 {
14 function(argv[1]); w
15 printf("%s\n", "Executed normally");
16 }
(gdb)
Listing 16-2: Viewing source code in GDB
First, let’s pause the program right before main calls function1 at w, just
before the instruction is executed. We’ll also set two more breakpoints, inside
function1, right before strcpy is executed at u, and directly afterward, at v.
Setting breakpoints in GDB is shown in Listing 16-3. Set breakpoints at
lines 14, 10, and 11 by using the GDB command break.
(gdb) break 14
Breakpoint 1 at 0x8048433: file overflowtest.c, line 14.
(gdb) break 10
Breakpoint 2 at 0x804840e: file overflowtest.c, line 10.
(gdb) break 11
Breakpoint 3 at 0x8048420: file overflowtest.c, line 11.
(gdb)
Listing 16-3: Setting breakpoints in GDB
Before we overflow buffer and cause the program to crash, let’s run it
with just four As, as shown here, and watch memory as the program exe-
cutes normally.
(gdb) run AAAA
Starting program: /home/georgia/overflowtest AAAA
368 Chapter 16
Breakpoint 1, main (argc=2, argv=0xbffff5e4) at overflowtest.c:14
14 function(argv[1]);
We use the GDB command run followed by arguments to start the pro-
gram in the debugger. Here we run the program with four As as an argu-
ment. We hit our first breakpoint just before function1 is called, at which
time we can examine the program’s memory using the GDB command x.
GDB needs to know which part of memory we want to see and how
it should be displayed. Memory contents can be displayed in octal, hexa-
decimal, decimal, or binary format. We’ll see a lot of hexadecimal in our
journey through exploit development, so let’s use the x flag to tell GDB to
display our memory in hexadecimal format.
We can also output memory in increments of one byte, a two-byte half-
word, a four-byte word, and an eight-byte giant. Let’s look at 16 hexadecimal
format words starting at the ESP register with the command x/16xw $esp, as
shown in Listing 16-4.
(gdb) x/16xw $esp
0xbffff540: 0xb7ff0f50 0xbffff560 0xbffff5b8 0xb7e8c685
0xbffff550: 0x08048470 0x08048340 0xbffff5b8 0xb7e8c685
0xbffff560: 0x00000002 0xbffff5e4 0xbffff5f0 0xb7fe2b38
0xbffff570: 0x00000001 0x00000001 0x00000000 0x08048249
Listing 16-4: Examining the contents of memory
The x/16xw $esp command prints out 16 four-byte words in hexadecimal
format, starting with ESP. Recall from earlier in the chapter that ESP marks the
lowest memory address in our stack. Because our first breakpoint paused exe-
cution right before the call to function1, ESP is at the top of main’s stack frame.
The output of memory in GDB in Listing 16-4 might be a bit confusing at
first, so let’s break it down. On the far left, we have our memory addresses in
16-byte increments, followed by the contents of memory at those addresses.
In this case, the first four bytes will be the contents of ESP followed by addi-
tional memory, starting at ESP and continuing down the stack.
We can find EBP, which points at the bottom (or highest address) of main’s
stack frame, by examining EBP as shown here with the command x/1xw $ebp.
(gdb) x/1xw $ebp
0xbffff548: 0xbffff5b8
(gdb)
This command allows us to examine one hexadecimal word from EBP
to find the memory location and contents of the EBP register. Based on the
output, main’s stack frame looks like this:
0xbffff540: 0xb7ff0f50 0xbffff560 0xbffff5b8
As you can see, there’s not much to it, but then again, all main does is
call another function and then print a line of text to the screen; there’s no
heavy-duty processing required.
A Stack-Based Buffer Overflow in Linux 369
Based on what we know about the stack, we can expect that when we let
the program continue and function1 is called, the return address for main
and a stack frame for function1 will be pushed onto the stack. Remember
that the stack grows to lower memory addresses, so the top of the stack will
be at a lower memory address when we hit our next breakpoint inside of
function1. Recall that our next breakpoint is inside function1 right before the
strcpy command is executed. Use the command continue to let the program
run until the next breakpoint, as shown in Listing 16-5.
(gdb) continue
Continuing.
Breakpoint 2, function (str=0xbffff74c "AAAA") at overflowtest.c:10
10 strcpy(buffer, str);
(gdb) x/16xw $espu
0xbffff520: 0xb7f93849 0x08049ff4 0xbffff538 0x080482e8
0xbffff530: 0xb7fcfff4 0x08049ff4 0xbffff548 0x08048443
0xbffff540: 0xbffff74f 0xbffff560 0xbffff5b8 0xb7e8c685
0xbffff550: 0x08048470 0x08048340 0xbffff5b8 0xb7e8c685
(gdb) x/1xw $ebpv
0xbffff538: 0xbffff548
Listing 16-5: Breakpoint before the strcpy command
After using the continue command to run the program until the next
breakpoint, examine ESP at u and EBP at v to see the contents of function1’s
stack frame. function1’s stack frame is shown here.
0xbffff520: 0xb7f93849 0x08049ff4 0xbffff538 0x080482e8
0xbffff530: 0xb7fcfff4 0x08049ff4 0xbffff548
The stack frame for function1 is a bit larger than main’s. There’s some
memory allocated for the local variable buffer, along with a little extra space
for strcpy to work with, but there’s certainly not enough room for 30 or 40 As.
Recall from the last breakpoint that main’s stack frame began at memory
address 0xbffff540. Based on our knowledge of the stack, 0x08048443, the
four-byte memory address between function1’s stack frame and main’s stack
frame, should be our return address for main. Let’s disassemble main with the
disass command, as shown in Listing 16-6, to see where 0x08048443 comes in.
(gdb) disass main
Dump of assembler code for function main:
0x08048422 : lea 0x4(%esp),%ecx
0x08048426 : and $0xfffffff0,%esp
0x08048429 : pushl -0x4(%ecx)
0x0804842c : push %ebp
0x0804842d : mov %esp,%ebp
0x0804842f : push %ecx
0x08048430 : sub $0x4,%esp
0x08048433 : mov 0x4(%ecx),%eax
0x08048436 : add $0x4,%eax
0x08048439 : mov (%eax),%eax
370 Chapter 16
0x0804843b : mov %eax,(%esp)
0x0804843e : call 0x8048408  u
0x08048443 : movl $0x8048533,(%esp) v
0x0804844a : call 0x804832c 
0x0804844f : add $0x4,%esp
0x08048452 : pop %ecx
0x08048453 : pop %ebp
0x08048454 : lea -0x4(%ecx),%esp
0x08048457 : ret
End of assembler dump.
Listing 16-6: Disassembled main function
If you aren’t fluent in assembly code, don’t worry. The instruction we’re
looking for jumps out at us in plain English: At 0x0804843e u, main calls the
memory address of function1. It stands to reason that the next instruction to
be executed when function1 exits (and thus our return address) will be the
next instruction in the list. And sure enough, the next line at v shows the
return address we found on the stack. Everything looks just like the theory
says it should.
Let’s allow the program to continue and see what happens in memory
when our four As are copied into buffer. After the program pauses at the
third breakpoint, examine memory in the usual way, as shown in Listing 16-7.
(gdb) continue
Continuing.
Breakpoint 3, function (str=0xbffff74c "AAAA") at overflowtest.c:11
11 }
(gdb) x/16xw $esp
0xbffff520: 0xbffff533 0xbffff74c 0xbffff538 0x080482e8
0xbffff530: 0x41fcfff4 0x00414141u 0xbffff500 0x08048443
0xbffff540: 0xbffff74c 0xbffff560 0xbffff5b8 0xb7e8c685
0xbffff550: 0x08048470 0x08048340 0xbffff5b8 0xb7e8c685
(gdb) x/1xw $ebp
0xbffff538: 0xbffff500
Listing 16-7: Examining memory at breakpoint 3
As shown, we’re still inside function1, so our stack frame location is the
same. Inside function1’s stack frame, we can see our four As u represented in
hexadecimal as 41 followed by 00 for the ending null byte. They fit nicely
in our five-character buffer, so our return address is still intact, and every-
thing works as expected when we let the program continue, as shown in
Listing 16-8.
(gdb) continue
Continuing.
Executed normally
Program exited with code 022.
(gdb)
Listing 16-8: The program finishes normally.
A Stack-Based Buffer Overflow in Linux 371
Sure enough, “Executed normally” prints to the screen.
Now, let’s run the program again, this time overflowing our buffer with
too many characters, and watch what happens in memory.
Crashing the Program in GDB
We could enter a long string of As, or we could let the Perl scripting language
generate that string for us, as shown in Listing 16-9. (Perl will come in handy
later when we try to hijack execution with an actual memory address rather
than crash the program.)
(gdb) run $(perl -e 'print "A" x 30') u
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 30')
Breakpoint 1, main (argc=2, argv=0xbffff5c4) at overflowtest.c:14
14 function(argv[1]);
(gdb) x/16xw $esp
0xbffff520: 0xb7ff0f50 0xbffff540 0xbffff598 0xb7e8c685
0xbffff530: 0x08048470 0x08048340 0xbffff598 0xb7e8c685
0xbffff540: 0x00000002 0xbffff5c4 0xbffff5d0 0xb7fe2b38
0xbffff550: 0x00000001 0x00000001 0x00000000 0x08048249
(gdb) x/1xw $ebp
0xbffff528: 0xbffff598
(gdb) continue
Listing 16-9: Running the program with 30 As as an argument
Here we tell Perl to execute the command print to make a string of 30 As
and feed the results in as the argument to overflowtest u. When strcpy tries
to place such a long string into our five-character buffer, we can expect to see
parts of our stack get overwritten with As. When we hit our first breakpoint,
we’re still in main, and everything looks normal so far. The trouble shouldn’t
start until our third breakpoint, after strcpy is executed with too many As.
note main’s stack frame is still 12 bytes long, though it has moved 32 bytes up the stack.
This is due to changes in the length of the command line argument, and so on. The
size of the stack frame will be consistent throughout.