7.1.2 Other possible channels. There are other possibilities to de-
sign low-capacity upstream covert channels for Waterfall. One direc-
tion is the use of known network steganography mechanisms [1, 40],
such as timing channels, IPID, and TCP ISN. Such features will
be reflected in the downstream traffic, and therefore intercepted
by downstream decoy routers. These mechanisms, however, offer
much lower capacities than the channels we introduced above. An-
other possibility is the use of heartbeat messages in the TLS protocol.
The purpose of heartbeat messages is to make sure a connection is
alive. A heartbeat message consists of a payload field that can be
filled with arbitrary content [51]. A webserver receiving a heartbeat
Figure 7: The architecture of Waterfall client software
message will return the exact message on the downstream traffic,
therefore it can be used as a Waterfall upstream covert channel.
Note that, however, the use of TLS heartbeat messages is not very
common in regular TLS connections, and therefore excessive use
of it by Waterfall can raise suspicion.
7.2 Downstream Covert Channel
Designing Waterfall’s downstream covert channel is more straight-
forward than its upstream channel, since Waterfall decoy routers
intercept downstream traffic of the censored clients. We implement
Waterfall’s downstream covert channel by replacing the down-
stream TLS records of a client’s overt traffic, as shown in Figure 6b.
The decoy router is able to manipulate the downstream overt TLS
records by using the information provided by the client in her reg-
istration package (Section 6). The decoys encrypt the downstream
covert content using the Read Keys provided by the user during
registration.
Note that simply replacing overt TLS records with covert content
will make Waterfall’s traffic prone to various traffic analysis attacks,
i.e., based on the timing, sizes, and order of packets. In Section 9, we
describe how we carefully embed the upstream and downstream
covert messages to resist traffic analysis attacks.
8 WATERFALL’S IMPLEMENTATION
We have implemented Waterfall as a fully operational system, which
is available online [55].
8.1 Main components
Figure 7 shows the high-level architecture of the Waterfall client
software, which is composed of the following components.
Application. This is any application software with SOCKS support
that intends to use Waterfall to bypass censorship. We particularly
use a web browser as the application component in order to make
Waterfall for censorship-resistant web browsing.
SOCKS Proxy Server. A client application (e.g., a web browser)
tunnels its traffic through Waterfall by connecting to a SOCKS
proxy server run by Waterfall client software.
Covert Connection Handler. Each SOCKS connection made by
a client application (e.g., an HTTP request by a web browser) is
Session I5:  Communication PrivacyCCS’17, October 30-November 3, 2017, Dallas, TX, USA2047handled by a separate Covert Connection Handler (CCH). A CCH
exchanges messages with the OvertConnection component, de-
scribed below.
Overt User Simulator. The Overt User Simulator (OUS) is essen-
tially a headless browser that creates overt traffic for Waterfall
communications. The OUS does so by repeatedly sending requests
for specific overt websites set by the client. As we describe in
Section 9, the traffic generated by the OUS is used to resist traffic
analysis attacks.
Overt Connection. The OvertConnection component embeds
the covert data received from CCHs into the overt traffic generated
by the OUS. More specifically, OvertConnection buffers the covert
traffic received from CCHs until there is sufficient overt traffic that
can carry the buffered covert traffic in a way resistant to traffic
analysis. The OvertConnection decides an upstream covert mech-
anism (from the set of mechanisms introduced in Section 7.1) for
various overt destinations.
8.2 Step-By-Step Operation
We have described the step-by-step operation of our implemented
Waterfall software in Appendix A.
8.3 Implementation Details
Our Waterfall client software implementation is written in about
900 lines of Python. It uses the Twisted Framework [52] for net-
work communications and the Scapy [47] library for creating and
manipulating TLS connections and messages. The OUS uses the
Python Selenium library [49] to run and control a PhantomJS [44]
browser. In order to intercept the overt requests, the PhantomJS
browser is configured to use an HTTPS proxy running in the client
which man-in-the-middles the overt requests using a self-signed
certificate that the PhantomJS browser is configured to ignore.
Our Waterfall client supports the HTTP Redirect and HTTP 404
upstream covert channels (Section 7.1). It is possible to easily extend
our client to support any other HTTP-based channels, including
website specific channels, by simply providing a Python class that
implements a given interface. A sample class for using Google as
an overt destination with HTTP Redirects is shown in Appendix B.
We have also implemented a proof-of-concept decoy router using
an experimental setup by simulating a network router intercepting
downstream flows. We use iptables with NFQUEUE to intercept
packets coming from overt destinations and process them with our
decoy router code (~500 lines of Python). The decoy router code
uses the negotiated client credentials (Section 6) to man-in-the-
middle a client’s TLS connection with an overt destination, and to
extract covert upstream messages.
9 RESISTING TRAFFIC ANALYSIS ATTACKS
We describe how our implementation of Waterfall, described in
Section 8, enforces mechanisms to resist traffic analysis attacks.
To resist traffic analysis attacks, a decoy routing system must pre-
serve the traffic patterns, i.e., packet timing and sizes, of the overt
webpages in both upstream and downstream communications. Slith-
een [4] is the state-of-the-art decoy routing system whose main
objective is strong resistance to traffic analysis. To achieve unob-
servability, Slitheen embeds the upstream covert data within custom
Figure 8: Waterfall’s Overt User Simulator (OUS)
headers in the overt HTTP requests made by an OUS. To make room
for covert data while preserving the original request size, Slitheen
removes or compresses redundant HTTP header fields. Slitheen also
preserves downstream traffic patterns by replacing data in HTTP
responses of the overt website with covert data of the same size.
However, in order to allow the OUS to complete a normal page load
of the overt website, Slitheen only replaces responses containing
leaf content (e.g., images and videos). Consequently, Slitheen is
only able to use 40% of the available downstream throughput [4].
Similar to Slitheen our OUS aims at preserving traffic patterns
in both upstream and downstream overt traffic while increasing
downstream throughput compared to Slitheen. Note that we can
not borrow the mechanism used in Slitheen (i.e., embedding covert
data in overt request headers made by the OUS) since Waterfall
decoys do not intercept upstream overt traffic. In order to send
upstream covert data, Waterfall must make separate requests, e.g.,
requests that will result in HTTP 404 or 3XX Redirect responses.
This complicates the task of imitating a normal user browsing the
overt website.
The main intuition behind our OUS is to cache previously browsed
overt websites, and only use already cached requests for upstream
and downstream covert communications. This allows Waterfall to
modify and replace requests to perfectly mimic2 the traffic patterns
of the overt website. On the other hands, this approach significantly
increases the downstream covert capacity compared to the state-
of-the-art Slitheen as Waterfall decoys are not limited to replacing
only the leaf content. Figure 8 shows the block diagram of our OUS,
composed of three main components. HeadlessBrowser is a back-
ground browser that repeatedly loads pages from overt websites.
The OUS Cache stores unmodified responses to all overt requests
previously received by the browser. Finally, RequestInterceptor
intercepts the requests made by the HeadlessBrowser, responds
to the browser with content from the Cache, and forwards overt re-
quests to be processed by the overt connection in a traffic analysis re-
silient manner. Specifically, Waterfall client modifies HeadlessBrowser’s
traffic based on the following criteria to preserve traffic patterns:
A. Non-Overt Requests: These are requests that are not directly
targeted at the overt destination server, such as images hosted on
CDNs or advertisements. Such requests are proxied normally with
no modifications.
B. Cache-Miss Requests: These are requests whose responses do
not exist in the Cache, e.g., they have not been previously requested
or their TTLs have expired. Such requests are proxied without any
2Note that since Waterfall runs the actual HTTP protocol, it is not subject to ac-
tive/proactive attacks on imitation systems [20].
Session I5:  Communication PrivacyCCS’17, October 30-November 3, 2017, Dallas, TX, USA2048changes to the traffic. The responses received in response to these
requests are used to populate the Cache.
C. Small-Response Cached Requests: These are request that
are cached in the OUS, where the size of the cached response is
small, i.e., comparable in size to that of typical HTTP Redirect re-
sponses (we use a threshold of 1 KB based on our measurement of
HTTP redirects in top 10,000 Alexa webpages). Waterfall replaces
such requests with requests used for upstream covert communi-
cation with the decoy routers (e.g., through HTTP Redirect) as
described earlier. To do so, Waterfall will create an overt HTTP
request containing covert data, while preserving the original re-
quest size. Note that requests made by a browser typically have
many HTTP headers, some with large values such as the Cookies
header. We make room for covert data by omitting some of the
non-essential header content. The request will be sent to the overt
destination in place of the original request. In order to maintain a
normal overt page load in the browser, upon receiving the response
to this request, the OUS will respond to the browser’s request from
the Cache.
D. Large-Response Cached Requests: These are requests that
are cached in OUS, where the size of their cached responses are
larger than typical HTTP redirects or errors (i.e., 1 KB). Waterfall
uses such requests for downstream covert communication as they
offer ample downstream covert capacity. That is, the Waterfall client
does not modify their upstream HTTP requests, however, the inter-
cepting Waterfall decoy router replaces their (large) downstream
responses with downstream covert messages, as described earlier.
The decoy router preserves the size and timing of downstream
responses in order to ensure resistance to traffic analysis.
9.1 Evaluating Traffic Analysis Resistance
Our described implementation of Waterfall provides strong resis-
tance to traffic analysis. This is because Waterfall’s OUS and decoy
routers preserve the exact timings and sizes of upstream and down-
stream overt traffic based on the traffic patterns cached from previ-
ous connections. We confirm resistance to traffic analysis through
experiments on our implemented Waterfall. Using Google as the
overt destination, we simulated a browser page load by making
requests for different resources (e.g., HTML, JS, and images) from
Google servers with a sequence of predefined delays across four
seconds. The requests were made by a Python script configured to
use OUS’s RequestInterceptor as an HTTPS proxy. Figures 9a
and 9b compare the CDF of the regular overt traffic with Waterfall
traffic for downstream and upstream traffic, respectively (averaged
over 30 runs). The figures demonstrate that Waterfall strongly pre-
servers the traffic patterns of both upstream and downstream traffic,
as described before. We confirm this statistically using a two-sided
K-S test [36] on total download times. Our test results in a D-value
of 0.11 and a p value of 0.5, showing that the K-S test fails in dis-
tinguishing between regular and Waterfall connections to an overt
website with significant confidence.
9.2 Evaluating Throughput
Unlike the state-of-the-art Slitheen, which only replaces leaf con-
tent in downstream traffic, in Waterfall decoy routers can use the
(a) Downstream traffic latencies
(b) Upstream traffic latencies
Figure 9: Traffic analysis resistance evaluation
whole content of downstream TLS packets for covert communica-
tions. This is thanks to Waterfall’s OUS preserving traffic patterns
based on cached observations, enabling the client browser to con-
tinue loading the page regardless of the response received from
the overt destination. As a result, Waterfall achieves a significantly
higher downstream throughput compared to the recent Slitheen.
Particularly, while a Waterfall decoy router uses 100% of the down-
stream traffic throughput for covert communications, Slitheen can
only use 40% of downstream throughput (based on Slitheen [4]’s
evaluations for top 1,000 Alexa websites).
As described earlier, a Waterfall client only uses “small-response”
overt requests for its upstream communications. Therefore, the
upstream throughput of Waterfall depends on the ratio of small-
response requests contained in a full page load of the selected overt
websites. We evaluated 1,976 websites that support HTTP redirects,
and find that, on average, 40% of their upstream traffic consists of
small-response requests, which can be used for upstream covert
communications in Waterfall.
10 CONCLUSIONS
We proposed a new architecture for decoy routing, called downstream-
only, that is significantly stronger to rerouting attacks than all pre-
vious designs, as we demonstrated through extensive Internet-scale
BGP simulations. We designed and built the first downstream-only
decoy routing system, called Waterfall, leveraging novel covert
channels. In addition to its strong resistance to routing attacks,
Waterfall is designed to defeat traffic analysis. We believe that
02000400060008000Overtpagesdownloadtime(ms)050010001500200025003000350040004500DownstreamKiloBytesReceivedDecoyRegular02000400060008000Overtrequesttime(ms)0200040006000UpstreambytessentWithCovertDataWithoutCovertDataSession I5:  Communication PrivacyCCS’17, October 30-November 3, 2017, Dallas, TX, USA2049downstream-only decoy routing is a major step towards making de-
coy routing systems practical by significantly reducing the number
of volunteer ASes needed to deploy decoy routers.
ACKNOWLEDGMENTS
We would like to thank anonymous reviewers for their feedback.
This work was supported by the NSF CAREER grant CNS-1553301.
4185.
REFERENCES
[1] Kamran Ahsan and Deepa Kundur. 2002. Practical data hiding in TCP/IP. In Proc.
Workshop on Multimedia Security at ACM Multimedia, Vol. 2.
[2] Alexa Top 1 Million Websites, February 2017.
http://s3.amazonaws.com/
alexa-static/top-1m.csv.zip.
[3] Hitesh Ballani, Paul Francis, and Xinyang Zhang. 2007. A study of prefix hijacking
and interception in the Internet. In ACM SIGCOMM CCR, Vol. 37. ACM, 265–276.
[4] Cecylia Bocovich and Ian Goldberg. 2016. Slitheen: Perfectly Imitated Decoy
Routing through Traffic Replacement. In ACM CCS. ACM, 1702–1714.
[5] Justin Boyan. 1997. The Anonymizer: Protecting User Privacy on the Web.
Computer-Mediated Communication Magazine 4, 9 (Sept. 1997).
[6] Bridge Easily Detected by GFW. https://trac.torproject.org/projects/tor/ticket/
[7] Kevin Butler, Toni R Farley, Patrick McDaniel, and Jennifer Rexford. 2010. A
survey of BGP security issues and solutions. Proc. IEEE 98, 1 (2010), 100–122.
[8] The CAIDA UCSD [AS Relationships] - [Jan 2016]. http://www.caida.org/data/
as-relationships/.
[9] CAIDA AS Ranks. http://as-rank.caida.org.
[10] Jacopo Cesareo, Josh Karlin, Jennifer Rexford, and Michael Schapira. 2012. Opti-
mizing the placement of implicit proxies. Technical Report.
[11] China
blocks VPN services
around
censorship.
http://www.scmp.com/news/china/article/1689961/