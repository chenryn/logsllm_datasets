---
tags: ['架构']
standardName: 'Domain Driven Design'
alias: ['ddd', '领域驱动设计']
level: 1
books: [
  {name: '领域驱动设计:软件核心复杂性应对之道'}
]
---
# 领域驱动设计
- 架构设计的本质是解决问题，我们可以随意地剪裁方法论，用其中20%-30%的套路来简化我们的沟通和设计成本即可
三种类型导向的设计：
- UI导向
- 业务导向(DDD)
- 数据导向
DDD能解决的：
- 代码冗余降低
- 需求响应提升
- 故障缺陷降低
- 部分性能提升
不能解决的：
- 大部分性能优化的问题
- 需求理解偏差的问题
- 人员开发技术差的问题
## 核心概念
![三者关系](/assets/屏幕截图%202021-11-14%20211012.png)
### 领域
领域就是这个边界内要解决的业务问题域
### 子域
每个子域对应一个更小的问题域或更小的业务范围
- 核心域：重点关注的子域
- 支撑子域服务于核心子域
- 通用子域被多个子域共同使用 具有通用性
## 模型
模型：对知识进行了选择性的简化和有意的结构化
- 模型与设计相互影响
- 模型是团队的通用语言
  - 通用语言是连接技术人员与业务人员的桥梁
- 模型是浓缩的知识
### 有效建模的要素
- 模型与实现绑定
  - 如果模型不能帮助开发可运行的软件 那就毫无意义
  - 寻找一种可以绑定模型与程序设计的设计
- 建立了基于模型的语言
- 模型蕴含丰富的知识
- 提炼模型
  - 不断对模型精简或者增加元素
- 讨论
```mermaid
stateDiagram-v2
  知识 --> 模型: 消化
  模型 --> 实现
  模型 --> 深层模型: 持续精进
  深层模型 --> 模型
  实现 --> 模型: 理解深入
  实现 --> 深层模型
```
### 通用语言
领域模型可以作为一种语言，语言就是模型的一种表现，模型与语言是一致的
修改代码就是修改模型，修改模型就是修改通用语言
![通用语言的内容](/assets/屏幕截图%202022-05-22%20211010.png)
使用文档与图作为面的面沟通的辅助手段，文档不应重复表示代码已经明确表达的内容，并且要与模型保持同步
### 模型驱动设计
在设计模型时需要考虑如何让代码更加自然地表达模型
### 亲自编码的建模师
如果参与建模的人最终没有参与到实现的工作中，那么模型与实现二者之间便会割裂开来
### 建模范式
模型驱动的设计并非一定只能使用OO设计，混用其他的一些设计范式能使设计更加自然
像现在我正在尝试系统整体使用OO，局部使用函数式
## 领域
### 分层架构
![DDD中的四层](/assets/批注%202020-07-21%20125205.png)
![DD分层与六边形架构与整洁架构](/assets/2022524203432.webp)
层名          | 含义
----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------
用户界面层（或表示层） | 负责向用户显示信息和解释用户指令。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人
应用层         | 定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行交互的必要渠道。应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作。它没有反映业务情况的状态，但是却可以具有另外一种状态，为用户或程序显示某个任务的进度
领域层（或模型层）   | 负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。领域层是业务软件的核心，这层理论上不应该直接依赖基础设施层，而是通过依赖倒置实现领域层对基础资源的解耦
基础设施层       | 为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持4个层次间的交互模式
- DO (Data Object): 此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
- DTO (Data Transfer Object): 数据传输对象，Service 或 Manager 向外传输的对象，不提倡在 DTO 中写逻辑，强制不要在 RPC 返回对象的 DTO 中封装逻辑
- BO (Business Object): 业务对象，由 Service 层输出的封装业务逻辑的对象。
- AO (Application Object): 应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴 近展示层，复用度不高。
- VO (View Object): 显示层对象，通常是 Web 向模板渲染引擎层传输的对象。Query: 数据查询对象，各层接收上层的查询请求。
查询视图：
```mermaid
stateDiagram-v2
  state "Service(BIZ)(BO)" as Service(BIZ)
  Manager/Client --> 三方、中间件等
  Service(BIZ) --> Manager/Client: DTO/Param
  Service(RPC) --> Service(BIZ): DTO/Param
  Manager/Client --> DAO: Query/DO
  Service(BIZ) --> DAO: Query/DO/Param
  Controller --> Service(BIZ): Param/AO
  WEB/APP/其他服务 --> Controller: Param/AO
  WEB/APP/其他服务 --> Service(RPC): Param
  DAO --> DB
```
返回视图：
```mermaid
stateDiagram-v2
  state "Service(BIZ)(BO)" as Service(BIZ)
  三方、中间件等 --> Manager/Client
  Manager/Client --> Service(BIZ): DTO
  Service(BIZ) --> Controller: DTO/AO
  Controller --> WEB/APP/其他服务: VO/DTO/AO
  Service(BIZ) --> Service(RPC): DTO
  Service(RPC) --> WEB/APP/其他服务: DTO
  DB --> DAO
  DAO --> Service(BIZ): DO
```
常用的一些领域模型之间的转换工具类库：
- org.apache.commons.beanutils.BeanUtils#copyProperties
- org.springframework.beans.BeanUtils#copyProperties(java.lang.Object, java.lang.Object)
- `org.dozer.Mapper#map(java.lang.Object, java.lang.Class)`
- net.sf.cglib.beans.BeanCopier#copy
- ma.glasnost.orika.MapperFacade#map(S, D)
- mapstruct
### 领域模型
建模范式：
- 对象范式
- 非对象范式
- 混合范式
贫血模型：指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层
充血模型：拥有业务逻辑行为、数据封装
#### 关联
代表领域中两个实体的关联 以及技术里的关联
为了使关联更易于控制：
1. 使用单向关联
2. 对关联进行限定，缩小范围
3. 消除不必要的关联
#### 实体
由标志所定义的对象，数据可变，拥有着自己的生命周期
这个标识是什么？是一个ID
实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现
#### 值对象
没有概念标识的对象
作为一个临时对象，应该是不可变的，通常用来传递消息
#### Service
有些操作是无法归类到某个值对象或者实体上面
需要使用Service来封装这些行为，由于上层的用户都可以使用Service, Service应用保持无状态
粒度更粗的Service更容易被服用，较粗粒度的Service也不容易把领域层的知识泄露到应用层上面去
#### 模块
对一些职责类似的对象进行封装
### 领域对象的生命周期
```mermaid
stateDiagram-v2
  [*] --> 活动状态: 创建
  活动状态 --> 活动状态: 修改
  活动状态 --> 数据库表示: 存储
  数据库表示 --> 活动状态: 重建
  活动状态 --> 数据库或文件表示:存档
  活动状态 --> [*]: 删除
  数据库或文件表示 --> [*]:删除
```
#### 聚合
> 聚合就是一组相关对象的集合，我们把它作为数据修改的单元。每个聚合都有一个根（root）和一个边界（boundary）。边界定义了聚合的内部都有什么。根则是聚合所包含的一个特定实体。对聚合而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用，聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题
![聚合实例 Car是一个聚合根](/assets/批注%202020-07-22%20161748.png)
聚合以及聚合根的构建：
```mermaid
stateDiagram-v2
  事件风暴 --> 找出实体和值对象
  找出实体和值对象 --> 找出聚合根
  找出聚合根 --> 将其他实体或者值对象归到某个聚合根
  将其他实体或者值对象归到某个聚合根 --> 定义聚合根之间的关系
```
设计原则：
1. 聚合内的对象、实体具备自洽、不变性
2. 聚合保持小而美
3. 使用聚合根ID引用别的聚合根，而非直接的对象引用
4. 聚合内数据强一致性，而聚合之间数据最终一致性
5. 跨聚合的服务调用应有应用层来完成