由钟的方程可得到一些不言而喻的结果，这些结果是通过筒
CLOCK=(tick-→tick→tick-→CLOCK)
CLOCK=(tick-CLOCK)
且其字母表亦为A。为方便起见，我们把这个解表示
=(tick→(tick→CLOCK)
μX:A.F(X) =μY :A.F(Y)
因为片程的解是任意的。我们把以前缀开始
tick-→tick-→tiok--...
μX:A.F(X)
=x²+x-2
X=F(X)
1.414.….
X=X 
类似得出
经过代换
原方程
---
## Page 30
受罢，这条公理的价值和意义会越来越明显。在没有给出进程的
不好理解或不能合人信服，就请他们把这个结论暂作公理加以接
也就是说，这两个客体是同一进程。有些人会觉得这种推理方法
定。而截止到任一时刻动作都相同的两个客体具有同样的行为，
始部分也就越来越长。这样任何有限行为都可以用这种方法确
代换，定义进程行为的表达式就随之增长，它所刻画的行为的初
的方法非形式地证明。用方程的右侧对进程名的全部山现做一次
定义为
越为
的另·种写法。
如上所述，这个方程式是更形式的定义
X4
X3
X1一只永远不停的钟，它的递归定义是
路去不写。
定义时，如果宇母表A从逃程的内容或上下文不言自明，我们就
给出进程的递归定义，哪种方法方便就用哪种。在用#X：A.F（X）
是方程Y=F(Y)中变量Y的解。以后，我们或用方程式，或用μ
女
CH5B=(in5p-out1p-out1p->out1p-→out2p→CH5B) 
卫式的方程有解，且解是唯一的，这一断言我们可运用代换
aCH3A={inp,out2p,outip}
一台换钱方法不同的机器，其进程的字母表与上例相同，
共递归定义是
一台简单自动售货机，投人多少枚硬币就送出多少块巧克
举例
CH5A={in5p-→out2p->out1p→out2p→CH5A)
一台换钱机，我们投人五便土的硬币，它会换成养钱，表
VMS = μX:[coin,choc}.(coin-→(choc→X))
((SWA-0oyo)u00)=SWA
CLOCK=μX:{tick}.(tick-→X)
口
口
---
## Page 31
筹码的移动可由下述进程所定义
X1这块板.上
一个事件求确定。如前，我们继续延用字母表的守恒性，即有
作。既然x和y不同，则P和Q之间的选择就要由实际发生的第
体的后续行为按P进行动作；如果是事件y，则客体按Q进行动
执行事件y。当第一个事件发生后，如果发生的是事件x，则客
表逝了这样一种客体，一开始时，它既可以执行事件×，也可以
事件了。假设和！是两个不同事件，则表达式
另一-个只能投入一便士的硬币；这时就要由颐客来决定选择哪
台自动售货机可能有两个硬币槽，一个只能投入二便士的硬币，
境中与环境相互作用，致使客体的行为受到环境影响。例如，
这类客体的行为不受外界影响。然而，有很多客体在其所处的环
1.1.3选择
式特性为基础。我们将在3.8节中讨论非卫式的递归的含义。
在第2.8.3节中给出。在这里对递归的叙逃主要以递归方程的卫
精确的数学定义前，
“!”读做“选择”：“选择x则按P执行，选择y则按Q执行”
α(x→P|y-→Q) =αP
使用前缓和递归的方法，我们只能刻画单一行为流的客体，
举例
(up-STOP|right-→right-→up-→STOP)
，更形式的证明是无法得到的。形式证明将
(x→P↓y-→Q)
当{x,y}≤αP且αP=αQ时
口
---
## Page 32
X7
不多给。
克力，但是先付了多少钱，售货机就送出值多少钱的巧克力，决
这台售货机最多可允许连续两次投入硬币，然后连续途出两块巧
程
也允许先付后尝。此进程写为
器容易得多，所以，我们在机器上加上一条注意事项
不能接连投入三个便士的硬币。但是改一下用卢手册要比改进机
象许多复杂的机器··样，这台售货机有一个设计上的缺陷，顾客
的方式上，郡有选择余地，可定义为
X4
X3
由换钱的顾客进行选择。
1.1.2中X3和X4，在这两例中没有选择余地)，此机器可写为
X5
out.0由进程的输出通道输出
in.1由进程的输入涵道输入
i.0山进程的输入通道输入0
一个拷贝进程执行下列事件：
为了避免损失，使用VMCRED 时必须先付使用费。
·一台售货机允许顾客先品尝一块巧克力，然后再付钱。它
VMC=(in2p-→(large-→VMC|small-outi1n-→VMC)
“注意：不要接连投入三个便土。
一台更为复杂的售货机，在使用的硬币，出售的货品和找钱
CH:C= in5p->(out1p->out1p→out1n-→out2p-→CH5C
一台机器同时可提供两种方法破开五便士的硬币（比较
一台售货机，其每笔交易或卖巧克力或灵太妃糖，
VMCT =μX.coin→(choc→X|toffee→X)
|ini p->(small-→V MC|in1p→(large→VMC
VMS2 = (coin-VMCRED)
(OHO+dzina+d[no+dzina|
定义为
，如进
口
口
口
---
## Page 33
此有
中选择x然后按进程P(x)动作”。
，然斤按P(y)继续动作。这个进程定义表达式应读作“从B
定义了这样一个进程，开始时，它允许选择集合B中任意事件
混为一谈，后者犯有语法错误。
把它和
应被看作是单个算子，这个算子有三个变元P,Q,R。千万不能
是引人非确定性，这将在3.3节中实现。现在，假设x，y，是不
事件的权利，但实际上叉没有做到这一点。解决这个问题的代价
赋予任何含义，这个表达式看上去好象向环境提供了选择第一个
的写法是有语法错误的。不能这样写的原因是，我们想回避给表
注意选择符号丨不是进程之间的算子；因此对进程P和Q，PIQ
了一个进程，则
同事件，则
达式
的主要区别。
择了。在第四聋中我们处理通信问题时，这一点将是输入和输出
注意这--进程允许由环境选择输入的，但输出时环境就不能选
一位数，又将这一位数输出，记为
这一进程的行为是成对事件的重复发生。在每个周期望，它输入
总之，设B为事件集合，对B中每个x，表达式P(x)定义
选择的定义可推广到两个以上的情形，即
0ut.1由进程的输出通道输出1
(x-→P|y→Q|--|2-→R)
(x→Pi(y-→Q|z→R))
(x-→P1y-→Q|z-→R)
（x→P)↓(x→→Q)
(x:B-→P(x))
。表达式中是局部变量，因
口
---
## Page 34
方程的左侧恰好出现一次。
的条件是，联立方程的右侧都必须为卫式，且每个未知进程都在
这里日={a,b}，
在一种更为特殊的情形里，初始荣单是空的。这时，不会发坐任
始事件，就有
地把它广：多个未知的进程是联立方程组的解。这个推论成立
1.1.4联立递归
<1.4节）中将大有用处。
在我们制定进程必须遵从的一般法则(1.3节)，以及进程实施
我们把选择、前级和STOP定义为一般选择记法的特殊情形。这
在三个或三个以上对象之间的选择可以类似地表越出来。这样，
二元选择算子丨也可以用这个更为一般的记法来定义
何事件，因此有
选择的动作的集合。
集合B定义了选程的初始茶单，因为它给出了进程启动时，可以
件，
X8
递归技术把单个进程定义为某个单一方程的解。我们可容易
在初始荣单内只含一个事件e时，则由于é是唯一可能的初
则它为
一个进程，它在任何时候都能执行其宇母表A中的任何事
举例
(x:{ }→P(x))=(y:{ }-Q(y))=STOP
R(x) =if x=α then P else Q
(a-→P|b-=Q)=(x:B-→R(x))
(x:{e}-=P(x))=(e-=P(e))
(x:B→P(x)）=(y:B-→P(y）)
RUN= (x:A→RUN,)
αRUNA= A
---
## Page 35
其中n为自然数0,1,2，"。
剩下的无穷方程组为
离地n次运动的行为。客体的初始行为定义为
且规定当它在地上时，还可向四周运动，我们设n∈{0；1,2,"}。
都可以向上或向下运动，除非它落到地上，不能再向下落了。而
X2一个客体以地面为起点，可以向上运动。以后任意时刻它
另一状态去。
W状态。在两种状态不，它或者给出相应的饮料，或者被转换到
非形式地说，当第一个事件发生后，饮料分配器就处于G状态或
程的宁母表和行为的方程
且－旦搬动后它不能再回到这个初始位置上。以下是定义三个进
设搬键开始在中间位置，不指向ORANGE，也不指向LEMON，
setorange和setlemon。给出饮料的动作定义为orange和lemon，
有桔子汁(ORANGE)和柠檬汁(LEMON)。搬键的动作定义为
X1饮料分配器上有一个搬键，搬键的两个可能位置上分别标：
aDD = aG =aW = {setorange ,setlemon,coin,orange,lemon}
ZG
DD= (setorange→G|setlemon-→W)
归纳定义的方程式是否有效，
举例
梁用带下标的变量，我们就可以写出无穷方程组了，
W = (coin-→lemon-→W|setorange-→G)
G= (coin-→orange-G|setlemon→→W)
举例
CT,= (up-→CT,|around-→CT)
一般情形不看每个方程右侧所
门
---
## Page 36
不知鬼不觉地回到该箭头所指向的节点。
当一个进程走到了在这种箭头的尾部所在的节点时，它就立即神
头，它可沿树上叶点绕回到前面的某个圆圈去。这个约定是说，
的进程，我们得引入另一-个约定，即有一种没有任何标记的箭
表示为一个不引出箭头的圆圈。如果用图示法表示具有无限行为
由同一节点引出的箭头必须标有不同事件。
向向下进行。每个箭头旁边标有实现状态转换时发生的事件。在
的圆圈（一般画在树形图上方)是初始状态；整个进程沿着箭头方
那些圆圈代表进程的各个状态，箭头表示状态间的转换。树根上
图由箭头连起来的一些小圆圈组成，在状态机器的传统术语里，
程组：它是否有效就要看每个方程右侧是否是卫式。
豹。因此，这个定义式只能被看做是一个无穷的联立递归定义方
x1O
在这三个例子中，每个树的各个分支都以STOP结束，STOP
举例(1.1.1节中X1,X2；1.1.3节中X3)
用树形结构图作为进程的示意图，有时是很有帮助的，树形
04
coin
x O
1.2示意
O
 coin
coin
choc
choc,
图
xO
choc
. coin
foffee
coin
Q
toffee .
一
---
## Page 37
显然，这两个不同的示意图所描绘的是同-个进程（1.1.3节的
次序，显然不应该有多大关系，即
行为，已可有许多不同的方法了。譬如说，被选择的事件的表远
X
14
尽管到目前为止我们引入的只是一部分记法，但要刻画同一
down
!
3
(x-=P|y-→Q)=(y-=Qlx-=P)
1.3
X3)。然而，要用图示的方法来证明
画好一阵了。
状态的筹码进程的示意图，就够我们
没有那么多地方。只有65536种不同
程（见左图），如CT。。
具有很多很多个或有无穷个状态的进
这是图示法的“个弱点。