题，例如在一个代码块中定义了两次同样的标识名，编译器会拒绝
对代码进行编译。在另外一些地方，则仅会给出警告信息，指出某
个变量是以不正确的类型进行初始化的。在语义检查之后，GCC还
会进行其他检查，如数据流分析，这通常用来优化代码。在这些阶
段同样会生成一些有用的警告信息。GCC编译器非常灵活并能够提
供多种用于程序调优和错误检测的选项。在所有情况下都应该认真
地分析警告信息，并且最好将这些问题都解决掉。没有警告信息的
代码更易于维护，也包含更少的错误倾向。拥有保持代码清洁的良
好习惯，能够使你远离那些警告信息掩盖之下的严重问题。
Clang静态分析器
Clang静态分析器也称为Clang检查器，它是底层虚拟机（LowLevel
VirtualMachine,LLVM）项目中相对年轻的组成部分。尽管还需要做
大量的开发，这个检查器已经能够提供良好的结果，并可以成功地
对空值、解引用未定义的指针、除零、无效的函数调用、未初始化
参数等一些恶性问题进行有效的检查。该工具的一个优点是它的输
出格式，相比其他分析器，Clang分析器能够为在代码中检测到的缺
陷建立HTML格式报告，包括行号、有颜色的语句和完整的问题描
述。根据这些描述，开发者能够容易地查看到原始缺陷（见例20
1)。
例20-1：下面的代码片段仅是无效删除的前四步（完整的报告在
http://wwws.clamav.net/bugzilla/show_bug.cgi?id=1292)
[.]
[8]进入错误的程序分支。
757if(!i)
758 cli_errmsg("lsigattribs:Empty TDB`n");
2107
---
## Page 2109
759 return-1;
760}
761
[9]循环条件为真。进入循环体。
762 for(i=0;tokens[i];i++){
[10]循环条件为假。继续执行第769行。
763 for(j=0;attrtab[j].name:j++){
764 if(!strcmp(attrtab[j].name,tokens[i]))
765 apt=& attrtab[j];
766 break;
767}
768}
[11]空指针解引用。
769 switch(apt- >type){
[]
Splint
在编译器装有高级代码分析器之前，以往的程序员不得不依赖外部
工具。最通用的工具是Lint，它与1979年发布的第7版UNIX系统捆绑
在一起。从那时起，并发了很多相同功能的工具，它们都具有类似
理念，甚至是相似的名称。当今一款可以作为推荐的工具是Splint。
这个名字的含义是“安全的程序绷带”，因为除了传统的语义检查，
它还能检测安全相关的问题，如空指针清除、内存管理错误、缓冲
区溢出、危险的别名、可能的无穷循环，以及其他可疑的语句。
Splin是一个很灵敏的工具。它不仅可以对一段看起来不错的代码报
2108
---
## Page 2110
告许多错误，而且有时还可对更加复杂的文件进行分析，因此它可
以对你希望检查的部分代码进行独立的分离式的分析。
保持耐心
同其他静态分析器一样，GCC、Clang静态分析器和（特别是）Splint
并不完美，可能会生成错误报告或者漏报一些问题。误报和漏报的
比例通常依赖于调优工具的运行时选项。当静态分析器对一段完美
可用的代码报告问题时，不要过于恼火！在多数情况下，可以通过
一些特殊选项或者注释源代码行禁止误报的产生。
内存检查器
内存管理错误是最常见的软件缺陷之一，并且在大型项目中几乎是
不可避免的。最普遍的问题有内存泄露，使用了未声明的或已经释
放的内存，写出边界，或者二次释放。内存相关的问题会有非常不
同的症状。在一些基本情况下，它们会导致程序崩溃（由程序段错
误引起），并且这种症状是重复的。然而在少数情况下，这些问题
是难以重现的，有时甚至是不能确定的。在这样的情形下，查找问
题原因是非常耗时的，如同大海捞针一般，你知道问题的存在，但
是没有那么好的运气找到它。非常幸运的是，有一些高级的内存调
试工具可以节省大量时间，这使得程序员的生活大为改观。使用这
些工具进行动态分析比静态方法常常更为理想、简便，特别是对于
问题可以复现的情况更是如此。ClamAV项目常常使用Valgrind、电子
围墙和DUMA，以及Mudflap。
Valgrind
Valgrind功能强大而且简单易用。它的优点在于，你不必对要测试的
程序做任何修改，Valgrind直接在二进制环境下工作。这意味着你的
程序可以是有任何语言编写的（解释运行也是如此！）。它不仅仅
是一个内存调试器，实际上，它是提供缓冲和堆配置，或者同步问
题检测的一整套工具。虽然Valgrind的最初版本仅支持特定硬件平台
（x86、amd64、Ppc32/64）上的Linux环境，但是它有对其他系统的
非官方端口。Valgrid可以对软件模拟运行的环境进行模拟仿真。由
于它还对CPU进行模拟仿真，执行过程要慢得多（在最坏情况下，
要慢50倍），因此使用运算速度较快的机器会有所帮助。（参见例
20-2)
2109
---
## Page 2111
例20-2：在ClamAV0.92中的压缩的可执行文件的解压器中，Valgrid
报告内存崩溃
==18030== Invalid write of size 1
==18030== at 0x4E6D92A:unmew(packlibs.c:300)
==18030== by 0x4E6F5DA:unmew11(mew.c:799)
=18030== by 0x4E61FE0:cli_scanpe(pe.c:1155)
=18030==by 0x4E47F6A:cli_magic_scandesc(scanners.c:2234)
=18030== by 0x4E498F0:cl_scandesc(scanners.c:2264)
==18030== by 0x405737:checkfle(manager.c:651)
18030== by 0x40675A:scanfle(manager.c:1093)
=18030== by 0x40733D:scanmanager(manager.c:371)
==18030==by 0x404EA5:main(clamscan.c:213)
=18030== Address 0x67594f0 is 0 bytes after a block of size 12,288
allocd
=18030== at 0x4C216F4:calloc(vg_replace_malloc.c:397)
=18030== by 0x4E42CD9:cli_calloc(others.c:330)
==18030== by 0x4E61DF5:cli_scanpe(pe.c:1123)
==18030== by 0x4E47F6A:cli_magic_scandesc(scanners.c:2234)
==18030== by 0x4E498F0:cl_scandesc(scanners.c:2264)
==18030== by 0x405737:checkfle(manager.c:651)
=18030==by 0x40675A:scanfle(manager.c:1093)
==18030==by 0x40733D:scanmanager(manager.c:371)
2110
---
## Page 2112
=18030==by 0x404EA5:main(clamscan.c:213)
电子围墙和DUMA
除了Valgrind之外，我们还使用电子围墙和DUMA。这二者都是
malloc（函数的调试器，它们利用系统的虚拟内存硬件来检查堆分配
缓冲区的边界溢出和无效的内存读取。这些检查是通过对每一个在
不可读取的内容页上进行malloc操作的跟踪来实现的，一旦被测试的
程序试图读取这样的内存页，它就会被终止，并报告这一无效存
取。类似地，所有通过free（函数释放的内存会被标记为不可读取，
并以同样的方式处理。DUMA还能对内存泄漏进行检测，并且它还
具有对C++内存管理函数的支持。这些工具的一个很大的优点是它
们的可移植性，它们能够在大多数操作系统和体系结构上运行。为
了使用它们对程序检测，需要将程序在libefence和libduma上进行链
接，它们会将C库函数中的默认内存管理函数进行替换。在很多系统
中，可以通过预先加载这些库来避免对程序的重新编译。虽然这些
工具通常不会导致Valgrind那样严重的使运行减慢（尽管当代码中有
大量小的内存分配操作时，会使得速度严重减慢），但是它们会使
程序消耗更多的内存，因此它们应该有限制地作为测试手段使用。
Mudflap
Mudflap是一种指针调试工具，从GCC4.0版开始成为它的组成部分
之一。它通过修改GCC结构，检测所有可能存在问题的指针清除操
作，以及具有类似风险的函数，对内存引用错误进行探测，是一款
高级的检测工具。由于Mudflap要对内部结构进行修改，这就要求目
标应用程序使用GCC编译器的-fimudfap开关选项进行重新编译，并
链接到libmudflap。完成之后，可以通过环境变量
MUDFLAP_OPTIONS对Mudflap进行控制。这一工具提供了许多运行
时选项来对检测进行调优。Mudflap工具的一大优点即：它是GCC编
译器的组成部分，因此不依赖其他第三方组件。但是，相对于其他
解决方案，它的易用性较差，且非常敏感。在默认配置下，它可能
会抛出大量警告，这需要测试人员小心地对其甄别。Mudflap的最大
优点在于它能对对象之外的读取进行检测，尽管从内存角度看这样
的操作可能是完全合法的。当一个对象的读写操作越界，没有内存
溢出但是破坏了内部结构体或其他对象时，就会产生这种状况。这
样的问题常会导致“缺一错误”（off-by-one），非常讨厌并且难于调
2111
---
## Page 2113
试，前面提到的工具都不能检测到这类错误。对于这些错误的调
试，Mudflap能够为我们节省很多时间。
局限
虽然有了这些非常好的内存调试器，但是一个共性问题是内存泄漏
可能发生在非常少的执行路径上，这使得它们的检测大大地复杂
化。在查找内存泄漏的问题时，我们通常在Valgrind之下运行扫描
器，对大量的文件进行测试。我们还开发了自已的工具以包装内存
调用和文件函数，并检查内存和描述符的泄漏。由于它的开销非常
低，所以当我们只是要查找泄漏或者对大量文件扫描时，这个工具
要比Valgrind更实用。
由于内存管理错误可能出现在任何的代码单元里，因此测试尽可能
多的模块是非常重要的。对于我们来说，这意味着我们尽可能地对
各种格式的文件进行扫描。当然，这样仍然不能保证我们能发现所
有的问题！因此当进行一般性的代码测试时，我们建议动态分析和
静态分析都要做，以发现经常被忽视的错误路径等一些比较隐蔽的
代码缺陷。
单元测试
作为白盒测试的一部分，ClamAV使用单元测试的方法。这种解决方
案允许我们检查代码单元个体（如单个函数或模块）是否工作正
常：是否正确接收和处理输入数据，并返回预期的值。单元测试让
我们能够在对SVN存档提交更改前快速的检查代码并找出哪一个单
元行为异常。在不同的平台和架构上进行测试也是极其可贵的。在
开发阶段的全过程和所有的关键代码部分都应该实施单元测试。单
元测试方法也是KISS理念在实践中的一个漂亮的实现。开发中整合
单元测试能促使形成好的代码编写实践，形成更合理的代码设计和
模块化开发。
我们使用的是一种称为Check的面向C语言的开源单元测试框架，它
可以在http://check.sf.net上获得。它的产生受著名的面向Java语言的
JUnit和其他一些类似框架的启发，具有界面清晰简单的特点。由于C
语言的特性，所有测试过程需要与框架相分离以避免产生一个测试
影响整个框架的情况。Check在分离的进程运行测试，并通过消息队
列与整个框架通信，这就使这一解决方案稳定而可靠。该框架能够
2112
---
## Page 2114