s
(
e
m
T
n
o
i
t
a
u
a
v
E
l
0
5000000
10000000
15000000
20000000
25000000
0
5000000
10000000
15000000
20000000
25000000
Evaluation Circuit Gate Count
Evaluation Circuit Gate count
(a) Comparing our GPU Eval Per Sec Per Core
(b) Comparing our GPU Eval Overall
Figure 3: GPU Evaluation Times with comparison to Kreuter et al.
[14], Frederiksen and Nielsen [5] and our GPU implementation.
the evaluation is guaranteed that it is executing multiple copies of
an identical circuit, it is easier to setup kernels that i) avoid warp
divergence, as warps will never process different gate types, and
ii)coalesce circuit data in the GPU’s global memory, by simply
storing each circuits data adjacent in memory. Note that both of
these solutions depend on the GPU taking advantage of multiple
identical copies of the same circuit executing.
We see that our GPU marginally outperforms Kreuter et al., sug-
gesting that they are paying a heavy price for using MPI on a single
machine (but of course, they are designed to run on large com-
pute clusters, and huge circuits where such performance penalties
should be amortized).
8.4 CPU Evaluation
Due in part to the seemingly structural problems of evaluation
on a SIMD GPU, we implemented a multi-threaded CPU evalua-
tion scheme in OpenMP. Results can be seen in Fig. 4. It is clear
that a MIMD architecture, such as a multi-core CPU will not suffer
from warp divergence or memory coalescing problems given their
advanced memory controllers and internal logic. A lack of warp
divergence removes the fear that large numbers of cores sit idle
while a level is completed is less of a problem. Also, we do not
need to create multiple distinct ‘kernels’ for different gate types,
nor worry that different cores are evaluating different gates. Simi-
larly, the fraction of cores that go unused while waiting for a level
to complete, as a total fraction of compute power will be smaller.
While we continue to under perform Frederiksen and Nielsen,
we improve over Kreuter et al, and show that their system is likely
to beneﬁt from the inclusion of threading within their nodes on the
compute-cluster, as opposed to having all of the parallelism at the
node level.
9. CONCLUSION, LESSONS LEARNED, AND
FUTURE WORK
Given the ability of the GPU to generate large circuits (or large
numbers of circuits) efﬁciently, and the CPUs better performance
in evaluation, it seems that an implementation that aims to imple-
ment a cut-and-choose protocol, should do veriﬁcation and gener-
ation on the GPU, and evaluation on the CPU in parallel. Sim-
ilarly, 1BM implementations should implement generation on the
GPU, and evaluation on the CPU. With appropriate pipelining these
would be done in parallel. The technique introduced which allows
177
i
)
s
(
e
m
T
n
o
i
t
a
u
a
v
E
l
0
0
.
0
0
1
0
0
.
0
1
0
0
.
1
0
1
.
0
1
0
.
0
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
0
Evaluation Times Over Gate Count
Normalized Gate Evaluation Per Second
●
● ●
●
●
●
● ●
●
●
●
● ●
●
Tie (CPU)
EC2 (CPU)
Kreuter et al. (CPU)
Frederiksen et al. (GPU)
e
r
o
C
r
e
P
d
n
o
c
e
S
r
e
P
s
e
t
a
G
0
0
0
0
0
4
0
0
0
0
0
3
0
0
0
0
0
2
0
0
0
0
0
1
0
●
●●
●
●
● ●
●
●
●
●
●
●
Tie (CPU)
EC2 (CPU)
Kreuter et al. (CPU)
Frederiksen et al. (GPU)
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
2000000
4000000
6000000
8000000
10000000
0
2000000
4000000
6000000
8000000
10000000
Circuit Gate Count
Circuit Gate Count
(a) CPU System Gate Count Eval vs. Time
(b) CPU System Gate Eval per sec per core vs. Gate Count
Figure 4: Our Evaluation Times as implemented on the CPU with
comparison to Kreuter et al. [14] and Frederiksen and Nielsen [5] .
XOR gates to be generated in parallel greatly helps in the circuit
gate generation rate.
While we do not report the results here, we have initial work
showing there is potential for multiple GPUs to be used in a sin-
gle system to further speed generation and evaluation results, but
a more careful implementation must be done that carefully splits
work amongst the GPUs, and takes into consideration the single-
bus bottleneck, or card-to-card memory transfer. We plan to pursue
these directions as future work.
It is clear that in order for better performance comparisons to
be made in the future, there needs to be a test-bank of standard
circuits designed. They must be delineated in a standard ﬁle for-
mat that all future implementations can parse (although, they may
further process in this format). Currently, each implementation in
the ﬁeld is rolling its own ﬁle format. The recent development of
MPCLounge aims to keep track of such circuits. Similarly, the
SCAPI project by Ejgenberg et al. will help in providing a long
term supported test environment [4].
10. ACKNOWLEDGEMENTS
The authors would like to thank the NSF and DARPA for fund-
ing, Jonathan Katz for discussion and aid on preliminary work, and
Tore Frederiksen and Ben Kreuter for aid with their systems. This
work was supported by an AWS in Education grant.
11. REFERENCES
[1] BELLARE, M., HOANG, V. T., KEELVEEDHI, S., AND
ROGAWAY, P. Efﬁcient garbling from a ﬁxed-key
blockcipher. In IEEE Symposium on Security and Privacy
(2013), IEEE Computer Society, pp. 478–492.
[2] CAMPBELL, I. Baremetal vs. xen vs. kvm — redux.
http://blog.xen.org/index.php/2011/11/
29/baremetal-vs-xen-vs-kvm-redux/ (Nov
2011).
[3] DAMGÅRD, I., PASTRO, V., SMART, N. P., AND
ZAKARIAS, S. Multiparty computation from somewhat
homomorphic encryption. In CRYPTO (2012),
R. Safavi-Naini and R. Canetti, Eds., vol. 7417 of Lecture
Notes in Computer Science, Springer, pp. 643–662.
[4] EJGENBERG, Y., FARBSTEIN, M., LEVY, M., AND
LINDELL, Y. Scapi: The secure computation application
programming interface. IACR Cryptology ePrint Archive
2012 (2012), 629.
[5] FREDERIKSEN, T. K., AND NIELSEN, J. B. Fast and
maliciously secure two-party computation using the gpu.
Tech. rep., Cryptology ePrint Archive, Report 2013/046,
2013. http://eprint. iacr. org, 2012.
[6] GOLDREICH, O. Foundations of Cryptography, vol. 2: Basic
Applications. Cambridge University Press, Cambridge, UK,
2004.
[7] GOYAL, V., MOHASSEL, P., AND SMITH, A. Efﬁcient two
party and multi party computation against covert adversaries.
In EUROCRYPT (2008), N. P. Smart, Ed., vol. 4965 of
Lecture Notes in Computer Science, Springer, pp. 289–306.
[8] HUANG, Y., EVANS, D., KATZ, J., AND MALKA, L. Faster
secure two-party computation using garbled circuits. In
USENIX Security Symposium (2011).
[9] HUANG, Y., KATZ, J., AND EVANS, D.
Quid-pro-quo-tocols: Strengthening semi-honest protocols
with dual execution. In Security and Privacy (SP), 2012
IEEE Symposium on (2012), IEEE, pp. 272–284.
[10] HUANG, Y., SHEN, C.-H., EVANS, D., KATZ, J., AND
SHELAT, A. Efﬁcient secure computation with garbled
circuits. In Information Systems Security. Springer, 2011,
pp. 28–48.
[11] ISHAI, Y., KILIAN, J., NISSIM, K., AND PETRANK, E.
Extending oblivious transfers efﬁciently. Advances in
Cryptology-CRYPTO 2003 (2003), 145–161.
[12] JANG, K., HAN, S., HAN, S., MOON, S., AND PARK, K.
Sslshader: cheap ssl acceleration with commodity
processors. In Proceedings of the 8th USENIX conference on
Networked systems design and implementation (2011),
USENIX Association, pp. 1–1.
[13] KOLESNIKOV, V., AND SCHNEIDER, T. Improved garbled
circuit: Free XOR gates and applications. pp. 486–498.
[14] KREUTER, B., MOOD, B., SHELAT, A., AND BUTLER, K.
Pcf: A portable circuit format for scalable two-party secure
computation. In To Appear in USENIX Security 2013 (2013).
[15] KREUTER, B., SHELAT, A., AND SHEN, C.-H. Billion-gate
secure computation with malicious adversaries. In
Proceedings of the 21st USENIX conference on Security
symposium, Security (2012), vol. 12, pp. 14–14.
[16] LINDELL, Y. Fast cut-and-choose based protocols for
malicious and covert adversaries. In CRYPTO (2) (2013),
R. Canetti and J. A. Garay, Eds., vol. 8043 of Lecture Notes
in Computer Science, Springer, pp. 1–17.
[17] LINDELL, Y., AND PINKAS, B. A proof of security of Yao’s
protocol for two-party computation. 161–188.
[18] MALKHI, D., NISAN, N., PINKAS, B., AND SELLA, Y.
Fairplay—a secure two-party computation system. In
Proceedings of the 13th conference on USENIX Security
Symposium-Volume 13 (2004), USENIX Association,
pp. 20–20.
[19] MOHASSEL, P., AND FRANKLIN, M. K. Efﬁciency
tradeoffs for malicious two-party computation. In Public Key
Cryptography (2006), M. Yung, Y. Dodis, A. Kiayias, and
T. Malkin, Eds., vol. 3958 of Lecture Notes in Computer
Science, Springer, pp. 458–473.
[20] NAOR, M., AND PINKAS, B. Computationally secure
oblivious transfer. Journal of Cryptology 18, 1 (2005), 1–35.
[21] PINKAS, B., SCHNEIDER, T., SMART, N., AND
WILLIAMS, S. Secure two-party computation is practical.
pp. 250–267.
[22] PINKAS, B., SCHNEIDER, T., SMART, N. P., AND
WILLIAMS, S. C. Secure two-party computation is practical.
In Proceedings of the 15th International Conference on the
Theory and Application of Cryptology and Information
Security: Advances in Cryptology (Berlin, Heidelberg,
2009), ASIACRYPT ’09, Springer-Verlag, pp. 250–267.
[23] PU, S., DUAN, P., AND LIU, J.-C. Fastplay–a
parallelization model and implementation of smc on cuda
based gpu cluster architecture. Tech. rep., Cryptology ePrint
Archive, Report 2011/097, 2011. http://eprint. iacr. org,
2011.
[24] SHELAT, A., AND SHEN, C.-H. Two-output secure
computation with malicious adversaries. In EUROCRYPT
(2011), K. G. Paterson, Ed., vol. 6632 of Lecture Notes in
Computer Science, Springer, pp. 386–405.
[25] YAO, A. How to generate and exchange secrets. In
Foundations of Computer Science, 1986., 27th Annual
Symposium on (1986), IEEE, pp. 162–167.
178