**作者：菜丝@蚂蚁安全实验室  
公众号：[蚂蚁安全实验室](https://mp.weixin.qq.com/s/oUp99tATgNNVu0uyZSD9FA)**
## 1.前 言
相信读者对 XSS 早已不陌生。通常谈论 XSS 的时候大多是针对 Web 安全领域的攻防和利用，而在客户端中也可能出现对输入处理不当而造成的
XSS。蚂蚁安全光年实验室近日在 BlackHat EU 2020 上发表的议题 Cross-Site Escape: Pwning macOS
Safari Sandbox the Unusual Way 就展示了一种针对 Safari 浏览器沙箱的绕过思路，将 Web
安全老生常谈的攻击方式移植到一个看上去毫不相干的领域，将进程间通信（IPC）的安全问题转化成跨组件的 js
脚本注入，最后完全绕过浏览器沙箱获得完整的代码执行权限。
由于浏览器功能复杂、迭代迅速，很容易出现内存安全相关的漏洞，因此沙箱（sandbox）成为了现代浏览器的标准配置。简单来说就是把渲染引擎等逻辑装进一个被“笼子”关起来的进程，即使攻击者利用漏洞获得了任意代码执行，接下来仍然要做额外的工作从沙箱里逃逸出来，才能真正访问到有价值的信息。常规的沙箱逃逸多是利用进程间通信机制，或可访问到的内核、驱动等组件，在权限更高的进程或者直接内核当中触发其他内存安全问题，从而关闭沙箱或者启动一个不受限制的进程，形成完整的攻击链条（fullchain
exploit）。
而我们的议题富有创意地在 XSS
的老树上开出了新花，嫁接到沙箱逃逸的场景中实现了稳定的利用，而且完全避开当下系统针对内存安全漏洞所引入的各种缓解措施（mitigation）。因为这些缓解措施并不是针对此类问题而设计的，两者不在同一个战场上。
## 2.跨进程 XSS？
通常 XSS 指的是通过 HTTP 协议等输入向量，将恶意代码（如 Javascript 或者 HTML
片段）注入到本不应该受攻击者控制的站点内容当中，从而绕过同源策略（Same-Origin
Policy）窃取用户凭据的攻击手法。这种攻击可以追溯到二十世纪九十年代，常年雄踞 OWASP 的十大 Web 安全威胁榜单。
结合浏览器漏洞的场景，又有 UXSS（Universal XSS）的攻击方式。XSS 通常出现在服务器后端或者网页前端脚本，而 UXSS
主要基于客户端浏览器（或扩展）的漏洞，从而篡改浏览器预定的行为和绕过安全限制。通常在没有启用站点隔离（Site-Isolation，Chrome
的安全特性）的浏览器中，同一个渲染器进程可以同时处理多个域名，因此同源策略是在进程内通过特定的访问控制策略保证的。
有时浏览器在处理特定的 DOM
或者网络接口存在逻辑缺陷，可能导致不同站点的数据可以相互访问，或注入脚本到不同的域名上下文中；有时特定的浏览器上下文配置会默认允许关闭同源策略检测，例如
Android系统WebView可以使用 setAllowUniversalAccessFromFileURLs 等配置对 file
域开启同源策略例外，对应的 iOS 下 UIWebView 则直接默认启用了类似的策略，只要是 file://
域下的页面，一律不限制同源策略；而在出现了内存破坏漏洞，导致恶意网页具有内存读写权限的前提下，攻击者的脚本可以修改进程内的特定标志位实现 UXSS。
在这篇议题当中借鉴了 XSS 注入 javascript 的思路，但输入向量不是 Web 协议，而是本地进程之间的跨进程通信（IPC）。例如反射型 XSS
通常会将恶意的脚本或者 HTML 直接附在 GET 请求的 query string 当中，让脚本在目标站点域执行；而类似的，本文的一些案例通过
XPC（macOS 和 iOS 下的进程通信）接口，从浏览器的沙箱进程内发起调用，诱导其他高权限系统服务渲染攻击 HTML，从而在没有沙箱限制的
WebView 里运行恶意脚本，最终获得完整权限的本地代码执行（即沙箱逃逸）。和 UXSS 相比，虽然都是本地的攻击，但 UXSS
仍然在进程内，而本文的思路则实现了跨进程、跨安全边界的代码注入。
以下表格简单比较了这种攻击的特点：
| XSS | 跨进程 js 注入  
---|---|---  
输入向量 | HTTP 协议 | 跨进程通信  
对象 | 其他域名 | 高权限本地进程  
载荷 | 提取登录凭据或直接发起请求伪造 | 在高权限 WebView 执行本地代码  
最终目的 | 绕过同源策略 | 浏览器渲染器沙箱逃逸  
**因此这种攻击的思路大体如下：**
1.拥有一个完整的 WebKit 远程代码执行漏洞，用以触发后续逃逸操作。
2.找到浏览器沙箱可以交互的系统服务，使用系统服务当中的逻辑缺陷向其他本地进程注入 js 代码。
3.被注入 js 的进程和存在逻辑缺陷的系统服务不一定是同一个。
4.在高权限进程当中通过再次利用 WebKit 漏洞，甚至进程自身的特殊功能，获得无沙箱限制的命令执行。
## 3.WebView
既然要在不同上下文当中运行 js 脚本，就得在高权限进程当中找到可以渲染 HTML 和执行 js 的地方。
macOS 上支持 HTML 渲染的组件非常多。像 Finder、Spotlight、Dictionary、HelpViewer、iBooks 甚至
iMessage 当中都用到了 WebView 组件。WebView 分为两种，历史遗留（legacy）的 WebView 和 macOS 10.10
后引入的 WKWebView。前者不支持进程隔离（没有 sandbox），不支持 JIT（即时编译），在 SDK 中标记为已废弃。而 WKWebView
是目前推荐的嵌入 Web 内容的方式。因为使用了多进程，从攻击角度来说和 Safari 完全一致。
两种 WebView 都提供了一些机制来实现 Objective-C 和 javascript 互相调用，但实现上不同。WKWebView 因为用了
IPC，就只支持异步的 messageHandler 委托；历史遗留的 WebView 则提供更强大的接口，可以直接把 Objective-C
的对象、方法暴露给 js，也支持同步调用。其实 WKWebView 提供了一种叫做 InjectedBundle
的机制，可以在渲染器进程里直接加载二进制插件，从而暴露更多的 JSContext 功能。但由于系统签名机制，沙箱进程 WebContent
不允许载入第三方签名的模块，因此只有 Apple 自己用到了这项功能，也没有在开发者文档中提到。
这些不是 Safari，本身又用到了 HTML 渲染的进程，便是本议题的攻击目标。一些 WebView 使用的老式的接口，没有进程隔离。假设我们有一个非
JIT 的浏览器漏洞，直接通过客户端 xss 在这些 WebView 里运行利用，即可获得没有限制的任意代码执行；更有甚者，一些 WebView 本身向
js 暴露了接口，使得我们不需要重复使用 WebKit 的漏洞，而是简单调用便可以执行任意本地代码。
**如果上面的描述让人昏昏欲睡，话不多说，我们直接来看漏洞案例。**
**cfprefsd TOCTOU 沙箱逃逸**
这个问题没有分配 CVE。笔者在 10.13 上发现，但在当时的 10.14 开发者测试版上已经被修复了。复现很简单：
  1. 在 macOS _sandboxed != NULL ) {
        *(*(block->lvar1 + 8) + 24) = ctx->_sandboxed == kCFBooleanTrue;
      } else {
        *(*(block->lvar1 + 8) + 24) = sandbox_check(block->pid, 0, SANDBOX_CHECK_NO_REPORT) != 0;
        ctx->_sandboxed = *(*(block->lvar1 + 8) + 24LL) ? &kCFBooleanTrue : &kCFBooleanFalse;
      }
    }
这就造成了一个 Time-of-check-time-of-use（TOCTOU）的问题。
在 mac 系统下，一个进程可以动态地给自身加上沙箱锁定状态。这个 API
是单向的，即进入沙箱之后就无法解除这个状态（除非有内核漏洞）。假设一个进程先访问了 Preferences，然后进入沙箱，此时在 cfprefsd
服务的眼里，进程仍然是之前缓存的那个“没有沙箱”的状态，从而畅通无阻。
而 WebKit 的渲染器进程不巧在默认情况下就满足这个条件。
在初始化阶段，WebKit 不会加载任何第三方的内容，因此这时候不需要沙箱也是合理的。WebKit 当中引用到了一个 AppKit