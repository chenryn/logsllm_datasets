by Ambrona et al. [14].
Other works in computer-aided cryptographic design include:
AutoBatch [8, 9] (for batching the verification of PPEs), AutoStrong [7]
(for compiling a signature scheme secure under the standard def-
inition into one that is strongly secure), AutoGroup+ [6, 7] (for
translating a Type-I pairing scheme into a Type-III pairing scheme;
IPConv [2, 4] is an alternative method, although not open source
at this time). Ambrona et al. [13] showed how to apply computer-
aided reasoning to the design of attribute-based encryption systems.
In the private key setting, there are interesting automation results
for blockciphers [48] and authenticated encryption [44].
There are many great tools for automating proof generation
or verification, such as Cryptoverif [25], CertiCrypt [21], Easy-
Crypt [17] and AutoG&P [22]. In 2019, researchers impressively
showed how to use EasyCrypt to machine-check a security proof
for the domain management protocol of Amazon Web Services’
KMS (Key Management Service) [10] and to verify cryptographic
standards such as SHA-3 [12]. These tools were also used to verify
proofs for key exchange protocols [16, 33], MPC protocols [43],
commitment schemes [49], software stacks [11] and protocols in
the UC framework [33]. Barthe et al. [22] provided a tool that trans-
lates the proofs output by AutoG&P into a format verifiable by
EasyCrypt and similarly Akinyele et al. [5] showed that the proofs
output by AutoBatch can be automatically verified by EasyCrypt.
The AutoLWE tool [20] semi-automatically proves the security of
cryptographic constructions based on Learning with Errors.
2 PRELIMINARIES
We define the algebraic setting and notation used in throughout
this work. We let [1, n] be shorthand for the set {1, . . . , n}. We use
v to denote a vector and vi to denote the i-th element. For a vector
v of length n and a subset U ⊆ [1, n], we denote vU as the set of
elements vi for i = 1, . . . , n where i ∈ U . Similarly vU denotes
the subset of elements vi for i = 1, . . . , n where i (cid:60) U . Let us
denote the set of pairing group identifiers {1, 2,T} by I. Let x, y be
polynomials over variables in (u1, . . . , un), then by x ≡ y, we mean
that x and y are equivalent polynomials.
2.1 Pairings
Let G1, G2 and GT be groups of prime order p. A map e : G1×G2 →
GT is an admissible pairing (also called a bilinear map) if it satisfies
the following three properties:
(1) Bilinearity: for all д1 ∈ G1, д2 ∈ G2, and a, b ∈ Zp, it holds
(2) Non-degeneracy: if д1 and д2 are generators of G1 and G2,
that e(дa, hb) = e(дb , ha) = e(д, h)ab.
resp., then e(д1, д2) is a generator of GT .
д1 ∈ G1 and д2 ∈ G2, computes e(д1, д2).
(3) Efficiency: there exists an efficient method that given any
A pairing generator PGen is an algorithm that on input a se-
curity parameter 1λ, outputs the parameters for a pairing group
(p, д1, д2, дT , G1, G2, GT , e) such that G1, G2 and GT are groups of
prime order p ∈ Θ(2λ) where д1 generates G1, д2 generates G2 and
e : G1 × G2 → GT is an admissible pairing. The above pairing is
called an asymmetric or Type-III pairing. In Type-II pairings, there
exists an efficient isomorphism ψ from G1 to G2 or such an iso-
morphism ϕ from G2 to G1 but not both. In symmetric or Type-I
pairings, efficient isomorphisms ψ and ϕ both exist, and thus we
can consider it as though G1 = G2. In this work, we support any of
these types of pairings. We will typically refer to Type III pairings
in our text, since they are general and typically the most efficient
choice for implementation, but our software tool in Section 5 can
handle any type. We represent identity elements of the groups
G1, G2, GT by I1, I2 and IT respectively.
Given pairing parameters (p, д1,д2, дT ,G1, G2,GT , e), we extend
prior definitions [42, 45] to define a pairing product equation over
variables Z , {Xi}m
j=1 e(Xi , Yj)γi j
= 1, where Ai , Xi ∈ G1, Bi , Yi ∈ G2, Z ∈ GT , γij ∈ Zp. (This
is the traditional definition.)
i =1n
i =1 e(Xi , Bi) ·m
i =1 e(Ai , Yi) ·m
i =1 as an equation of the form
i =1, {Yi}n
• Z ·n
• A ·m
• A ·n
γi
i =1 X
i
γi
i =1 Y
i
= 1, where A, Xi ∈ G1, γi ∈ Zp.
= 1, where A, Yi ∈ G2, γi ∈ Zp.
The second two PPE formats do not enable any additional func-
tionality over the traditional definition, but they will later be useful
for obtaining more efficient identity tests. We sometimes rearrange
the terms of a PPE to improve readability. As we will use it later, we
observe that under the above definition, a PPE can be employed as
an identity test in groups G1, G2 or GT , either for a single element
or according to any of the above combinations of products and
exponents.
Session 2B: Applied Cryptography CCS '20, November 9–13, 2020, Virtual Event, USA3933 DEFINING PPE CIRCUITS
We introduce and formally define PPE circuits. We begin with the
notion of a PPE problem instance [45].
tion (PPE) problem instance Π consists of 5
Definition 3.1 (PPE Problem Instance [45]). A pairing product equa-
• pairing parameters G =(p,д1,д2,дT ,G1, G2,GT ,e),
• positive integers n, m,
• multivariate polynomials f = (f1, . . . , fm) over n variables
in Zp denoted u = (u1, . . . , un),
• a sequence of pairing group identifiers in I = {1, 2,T} de-
noted α = (α1, . . . , αm),
• a set Trusted ⊆ [1, m].
The pairing parameters above can optionally indicate the type
of pairing group (e.g., Type I, II or III); unless otherwise speci-
fied we assume Type III pairings. Throughout the paper, we use
the notation InTrusted(Π) to denote the set of variables that ap-
pear in the Trusted set of polynomials of Π i.e., InTrusted(Π) =
∪i∈Trusted{variables used in fi} ⊆ u. We simplify the notation and
use InTrusted whenever the problem instance Π is implicit.
Following [45], we map cryptographic schemes into PPE problem
instances by rewriting the scheme using a single group generator,
when possible. For example, let д1, д2, дT be group generators of
groups G1, G2, GT respectively. Let a group element in the scheme
be hx · дx2 · д
, by represent-
ing h = дz2 for a fresh variable z. Consequently, each group ele-
ment in the scheme could be represented by their group indicator
(G1/G2/GT ) along with the polynomial present in the exponent.
Definition 3.2 (PPE Challenge [45]). Let Π = (G, n, m, f, u, α,
Trusted) be a PPE problem instance as in Definition 3.1. Let F =
(F1, . . . , Fm) be comprised of pairing group elements, where each Fi
. F is called a challenge to PPE instance Π. Challenges
is in group Gαi
are classified as:
• F = (F1, . . . , Fm) is a YES challenge if there exists an assign-
ment to variables u = (u1, . . . , un) ∈ Zn
p such that for all i,
Fi = д
• F = (F1, . . . , Fm) is a NO challenge if it is not a YES challenge
and there exists an assignment to u = (u1, . . . , un) ∈ Zn
p such
fi(u)
that for all i ∈ Trusted, Fi = д
αi
• F = (F1, . . . , Fm) is an INVALID challenge if it is neither a
YES nor NO challenge.
2 . We rewrite this element as д
xz+x +y
y
2
.
fi(u)
αi
.
Following [45], we can view a YES challenge as meaning that
both the trusted and untrusted elements are distributed as they
should be, whereas in a NO challenge the trusted elements are
correctly formed, but the untrusted ones are not. In an INVALID
challenge, the “trusted” elements are not drawn from the proper
distribution (e.g., the public parameters are not correct), and there-
fore, we ignore this case since verification requires correctness of
the elements we trust.
The goal of our work will be to (automatically) devise circuits
that take as input a PPE challenge (recall Definition 3.2) and output
5Unlike the definition of [45], we do not include the set Fixed in the PPE Problem
Instance definition as we implicitly define this set of variables (called InTrusted) as
those that appear in elements corresponding to the Trusted set.
1 for all YES challenges and 0 for all NO challenges. That is, where
prior work [45] allowed only the conjunction of PPEs to test the
well-formedness of the untrusted elements; we will now combine
the power of PPEs with arbitrary logic. Informally, the PPE circuit
takes m group elements as input and outputs a single bit. Like
regular circuits, each gate of the circuit could be an AND/OR/NOT
gate. In addition, we also allow the circuit to have PPE gates. Each
PPE gate has some PPE P (over formal variables F1, F2,· · · , Fm
denoting the m input wires of the PPE circuit) hardcoded in it and
outputs a boolean value representing whether the m input group
elements satisfy P. Informally, in order to evaluate a PPE circuit
on given m group elements (x1, x2,· · · xm), we first evaluate each
PPE gate on the given input (check whether the PPE is satisfied by
substituting Fi = xi∀i ∈ [m]), and then evaluate the boolean circuit
logic to obtain the final output. As observed in Section 2.1, PPEs
can also capture identity tests as well as be a hardwire for 0 (the
equation that is never satisfied) or 1 (the equation that is always
satisfied).
N , Gates, out, GateType, A, B), where
We now establish some formal notation for our specialized PPE
circuits adapting the more general circuit notation of Bellare, Hoang,
and Rogaway [23] and Garg, Gentry, Halevi, Sahai and Waters [36].
Definition 3.3 (PPE Circuit). A PPE circuit C is a tuple (G, m, α,
• G = (p, д1, д2, дT , G1, G2, GT , e) establishes the algebraic
setting,
• integer m specifies the number of group elements in the
circuit input. We will refer to these as Inputs = {1, . . . , m}.
• the vector α = (α1, . . . , αm) is a sequence of pairing group
identifiers in I = {1, 2,T} for the input elements,
• integer N is the number of gates in the PPE circuit,
• Gates = {m + 1, . . . , m + N}. We will refer to Wires =
• out is the integer in Gates denoting the output gate. Unless
• GateType : Gates → {(PPE, β), AND, OR, NOT} is a func-
tion that identifies the gate functionality. In case of PPE
gates, the description includes a circuit β with m Inputs wires
whose logic forms that of a PPE over variables F1, . . . , Fm
where each Fi ∈ Gαi
as specified by α and the single output
wire of the PPE carries a bit representing whether or not the
input satisfies the PPE.
• A : Gates → Wires and B : Gates → Wires are functions.
For any gate AND/OR/NOT д, A(д) identifies д’s first incom-
ing wire. For any AND/OR gate д, B(д) identifies д’s second
incoming wire. We require that д > B(д) > A(д), ignoring
B(д) when undefined. Recall that the input wires for all PPE
gates are the Inputs.
Inputs ∪ Gates.
otherwise stated, out = m + N .
This describes a circuit taking as input m group elements and
outputting a single output on wire out. We now describe how to
evaluate the above circuit.
Definition 3.4 (PPE Circuit Evaluation). A PPE circuit evaluation
: C × (x1, . . . , xm) takes as input a PPE circuit
algorithm Eval
C = (G, m, α , N , Gates, out, GateType, A, B) together with an m-
element PPE challenge (x1, . . . , xm) which must be consistent with
(G, α) (i.e., xi ∈ Gαi
). The algorithm outputs a bit in {0, 1}.
Session 2B: Applied Cryptography CCS '20, November 9–13, 2020, Virtual Event, USA394Here we describe a “canonical” evaluation algorithm. The input
group elements (x1,· · · , xm) are assigned to the m input wires. For
each gate д ∈ Gates (in the increasing order of д), compute sд as
follows according to the description of GateType(д):
• if (PPE, β), then evaluate the PPE β using the assignment
to variables in (F1, . . . , Fk). If the PPE is satisfied, then set
sд = 1. Otherwise, set sд = 0.
• if AND, then sд = sA(д) ∧ sB(д).
• if OR, then sд = sA(д) ∨ sB(д).
• if NOT, then sд = ¬sA(д).
This algorithm outputs sout. For the AND, OR and NOT gates, by
the rules of the circuit description, sA(д) and sB(д) will be defined
before they are used.
The above conditions guarantee that the circuit does not have
any loops. While we chose to have AND, OR and NOT gates, this is
somewhat arbitrary. We could have chosen only NAND or allowed
gates with larger fan-in, etc. We abuse notation and let C(x) denote
Eval(C, x) i.e., evaluation of the circuit C on input x.
We next extend the notion of PPE testability and testing sets [45]
to apply to PPE circuits.
Definition 3.5 (PPE Circuit Testable and Testing Circuits). A PPE
problem instance Π = (G, n, m, f, u, α , Trusted) is said to be PPE
circuit testable if and only if there exists a PPE circuit C = (G, m, α ,·,
·,·,·,·,·). such that both of the following hold:
• C(x) = 1 for every YES challenge x,
• C(y) = 0 for every NO challenge y.
There are no conditions on the behavior of C for INVALID chal-
lenges. For any PPE problem instance Π, we call such a PPE circuit
C a testing circuit. A testing circuit for a PPE problem instance need
not be unique.
3.1 A Few Shorthand Notations for Circuits
Useful shorthand is informally defined here with formalisms in Ap-
pendix A. We use MakeCircuit(G, m, α , P) to define a PPE circuit
that computes the output of a PPE P and use Cacc to denote the
circuit which always outputs 1.
Consider any two PPE circuits C1 and C2 with the same group
structure G, number of inputs m and group identifiers α. When
building our circuits, we will use shorthand notation like(C1 AND C2),
(C1 OR C2) or (NOT C1). Informally, we use C1 AND C2 to denote
the circuit obtained by ANDing the output wires of C1 and C2 (i.e.,
connecting output wires of C1 and C2 as inputs to a fresh AND gate,
and considering the output wire of the fresh AND gate as output
wire of the entire circuit). Similarly, we use the notation C1 OR C2
to denote the circuit obtained by ORing the output wires of C1 and
C2. We use NOT C1 to denote the circuit obtained by connecting
the output wire of C1 to a fresh NOT gate and then considering
the output wire of the NOT gate to be the output wire of the entire
circuit. Furthermore, when the circuits share common inputs (e.g.,
same PPE challenge elements), we will make sure the final circuit
has only the appropriate number of input wires.
4 SEARCHING FOR A PPE TESTING CIRCUIT
We now describe an algorithm to search for a testing circuit Q for
a PPE problem. The input is a PPE problem Π and there are two
possible types of outputs. Either it will output that Π is PPE circuit
testable and, to confirm this, it will produce one testing circuit Q or
it will output the special response unknown. In the latter case, NO