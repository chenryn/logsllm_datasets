consists of several Python scripts that run on top of IDA. As
input they take the results of DT and as output they integrate
information on tainted data ﬂow into the disassembly view
provided by IDA, as well as extending it with new tables of
relevant information. The analysis component SA and user
interface components UI are quite closely linked so we will
explain their features in tandem.
3.2.1 Attack Surface Identiﬁcation
The ﬁrst stage of reverse engineering driven vulnerability
detection requires one to ﬁnd the attack surface of a pro-
gram. We will loosely deﬁne the attack surface as code with
data-ﬂow or control-ﬂow that can be directly or indirectly
inﬂuenced by an attacker. This stage is critical as typically
one wants to ﬁnd the most security ﬂaws in the least amount
of time and the ability to prioritize diﬀerent parts of the code
for review is crucial to this process.
Often applications come with their functionality spread
through a number of shared libraries, each with potentially
hundreds or even thousands of individual functions. For ex-
ample, one of the applications discussed in section 4 contains
43 DLLs, several of which have more than a thousand func-
tions. PINNACLE makes it easy to quickly discover which of
these process attacker controlled input and which do not.
203
Previously, a popular approach to this problem has cen-
tered around a technique called diﬀerential debugging or dif-
ferential reverse engineering [16, 23, 2]. Under this approach
one attempts to discover the code responsible for particular
features of a piece of software by recording the basic blocks
executed when that functionality is not used and then again
when it is used. By taking the diﬀerence between these two
sets of basic blocks one usually ends up with a set of basic
blocks that are related to the feature of interest. Diﬀeren-
tial debugging is a simple but relatively eﬀective solution
to the problem. However, using data tainting information
we can get much more ﬁne grained information. Instead of
concluding that a collection of basic blocks may be some-
how related to the feature in question we can conclude the
precise instructions responsible for processing every byte of
user input.
We break the process of attack surface identiﬁcation down
into two stages, ﬁrstly at the library level and then at the
function level.
Library Processing.
Using the program trace we group the recorded instruc-
tions by DLL and count them. Following this we also group
and count each function and instruction alert. The results
are then displayed in a table to the user who can easily see
those DLLs that perform the most work on attacker con-
trolled inputs and also those that generate the most alerts
for events of note.
Often applications will encapsulate functionality related
to IO within a particular library and then tainted data will
ﬂow from this library through a number of other libraries
before reaching a taint sink. If the tracing mode is enabled
then on an alert we can create a graph visualizing this in-
formation ﬂow for the user.
Attack Surface by Function.
Using the information provided by the program trace and
the analysis API of IDA we update the disassembly view of
IDA to highlight every instruction that has processed tainted
data. A count per function of each alert generated by that
function, its cyclomatic complexity, the number of instruc-
tions in the function and the number of tainted instructions
is then placed in a sortable table and displayed. Any func-
tions that introduce tainted data via a taint source are also
highlighted.
The information displayed allows a user to get a feel for
which functions perform the most processing and are po-
tentially the most interesting locations to begin auditing.
Currently we do not attempt to perform any automated
ranking of functions but allow the user to select from the
above metrics and sort the results.
3.2.2 Alert Prioritisation and Display
For each alert generated by a kalert function the output
will depend on the propagation mode in use. Under the
tracking mode the output will be the information from a set
of DirectTI and/or IndirectTI instances that allow us to
identify a set of byte inputs from a ﬁle or network stream.
Under the tracing mode the output is much more verbose
and allows us to link the bytes of interest at the point of the
kalert execution to a set of input bytes through each instruc-
tion that may have transformed them along the way. The
resulting information is a set of input bytes and a sequence
of instruction addresses A =. Processing the
produced log into this set of address is not discussed here
due to space considerations. The process is relatively triv-
ial and simply a matter of iterating over the produced log
and building the set of instruction addresses, ordered by the
tainted instruction counter.
For both the tracing and tracking mode we may also have
access to the path condition. This can also be processed
into a set of addresses  that identify tainted
conditional branches. Assuming we are operating under the
tracking mode the addresses of the conditional branches can
be integrated into A using the associated tainted instruction
counter values.
Due to the volume of alerts that may be generated it is
necessary to have some form of prioritisation mechanism.
We do this by performing a simple analysis of every instruc-
tion in A. If we detect an arithmetic operator like add the
has arith ﬂag is set, if we detect a bitwise operator like and
the has bitwise ﬂag is set and ﬁnally, if there are any condi-
tional jumps in A the has jcc ﬂag is set. The attributes are
ranked as follows:
has_arith > has_bitwise > has_jcc
The ranking of a trace is given by the least of the attributes
assigned to it. When two traces have the same ranking, the
one with the shorter sequence of addresses is ranked higher.
Naturally, the has arith and has bitwise attributes only
apply if we are operating under the tracing mode. In the
tracking mode we have no choice but to simply rank traces
without conditional jumps higher than those with them.
The list of alerts are then displayed to the user via a table
in IDA, where the columns contain the name of the alert
followed by the above calculated attributes. Once an alert
is selected another table is generated listing every instruction
in A. The disassembly view is also updated to color each of
the instructions listed in A.
4. USAGE AND EVALUATION
For the purposes of this paper we have evaluated PINNACLE
on the targets listed in table 1. The targets are all complex,
commercial software and available only in binary form 1.
The purpose of the applications are diverse, including one
of the most frequently encountered image editing suites (Im-
ageSuite); a multi-threaded game server that typically has
50,000 online players at any one time(GameServer ); the
desktop control center for a common brand of network printer
(PrinterControl ) and a popular industrial design suite (In-
dDesign). Between them their functionality is scattered
across several hundred DLLs and several hundred thousand
functions.
Reverse engineering any of these targets for the purposes
of vulnerability detection can be a time consuming process
but in this section we will demonstrate how PINNACLE enables
a user to quickly discover the program’s attack surface and
then audit that attack surface in a prioritized manner. Us-
ing PINNACLE we were able to discover security vulnerabilities
in all targets in a short amount of time.
1The targets have been anonymised as the security ﬂaws
found are unpatched
204
4.1 Performance
The primary output of PINNACLE is intended for human
consumption, and thus an evaluation of the quality of this
information is subjective. An idea of the usefulness of this
data is provided in section 4.2 where we go through a num-
ber of serious ﬂaws found with PINNACLE. However, we can
provide metrics on the run-time impact of PINNACLE during
the instrumentation phase as well as the size of the identi-
ﬁed attack surface relative to the overall quantity of code
executed. It is important to measure the run-time impact
of the tool as this is the most time consuming part of the
analysis. As mentioned in the introduction, excessively long
run-times may not integrate well into a user’s work ﬂow. By
measuring the diﬀerence between unique executed instruc-
tions and the subset of these that process tainted data we
can get an idea of whether the wait for this information is
worthwhile, versus an alternative approach such as diﬀeren-
tial debugging.
Table 1 shows the run-time impact of PINNACLE in com-
parison to a basic block coverage tool, used for diﬀerential
debugging. The experiments were performed on a 32-bit
dual-core Intel 2.20Ghz processor with 3GB of RAM run-
ning Windows 7 2. The basic block coverage tool is taken as
a base and and the results of other methods are a factor of
that. The actual program run time in seconds is also pro-
vided. The tasks performed were to scan a document (Print-
erControl ), load an image from disk (ImageSuite), connect
a client to the game (GameServer ) and open a design spec-
iﬁcation (IndDesign).
We can see that, as expected, PINNACLE has a higher run-
time impact than simple basic block coverage tracking. How-
ever, the run-time impact is not suﬃciently large as to pre-
vent the integration of the tool into a reverse engineer’s work
ﬂow.
Interestingly, in some cases the impact of running
PINNACLE in tracing mode is not signiﬁcantly higher than
running in tracking mode. In these cases we can get the ben-
eﬁts associated with the extra information provided, without
run-times that might be inconvenient to the user. The two
exceptions were with GameServer and IndDesign.
While running the GameServer under the tracing mode
the client displayed a connection timeout error after approx-
imately 80 seconds. By this point the client and server had
already exchanged a number of requests and responses so
we were still able to gather information on a useful por-
tion of the connection protocol. With IndDesign under trac-
ing mode the system eventually ran into an out-of-memory
(OOM) condition while loading the input. The IndDesign
application performs extensive decompression on the input.
As a result of this, the application performs signiﬁcantly
more processing of tainted data, in comparison to the oth-
ers. This leads to an OOM condition in PINNACLE due to
the large chains of objects necessary to maintain informa-
tion on each instruction operating on tainted data. Despite
this, we were able to ﬁnd a number of security vulnerabil-
ities using the information from the tracking mode alone.
However, both this OOM and the timeout on GameServer
show that there is still work to be done on optimizing the
instrumentation phase of our approach.
2
PINNACLE also works on Linux and x86-64
One of the most useful applications of PINNACLE is in at-
tack surface identiﬁcation. In table 2 we can see a compari-
son of the number of loaded DLLs, including system DLLS,
versus the number of DLLS that actually process tainted
data. We can clearly see that taint tracking allows us to
signiﬁcantly cut the number of DLLs we may consider in-
teresting from an attackers perspective. A large number of
DLLs may still remain if we only consider those that process
tainted data, however, using the data ﬂow graph mentioned
in section 3.2.1, along with basic metrics on the number of
tainted instructions per DLL, a user is provided with useful
guidelines on where signiﬁcant processing is performed.
Table 2 also provides metrics on the number of unique in-
struction addresses executed versus the number of those that
process tainted data. PINNACLE cuts the attack surface down
to a fraction of those instructions actually executed e.g. by
a factor of 120 in the case of the PrinterControl application.
This saves signiﬁcant amounts of time for a reverse engineer
and is a more accurate solution in comparison to diﬀerential
debugging.
The ability to focus quickly on code that is inﬂuenced by
an attacker, in combination with direct targeting towards
potential vulnerabilities, means that a user can be more ef-
ﬁcient than otherwise. We have tested this hypothesis by
real world use of PINNACLE.
4.2 Vulnerability Discovery
4.2.1 Remote Overﬂow in PrinterControl
In the application PrinterControl we found several vulner-
abilities that can lead to remote compromise of the device
attempting to interact with the network printer. One such
vulnerability is found in the initialization stages of the appli-
cation. When PrinterControl starts it sends a broadcast re-
quest over the network to identify an available printer/scanner.
Any device on the local network can see and respond to
these requests. By starting PrinterControl under PINNACLE
we were able to detect a serious vulnerability resulting from
insecure parsing of responses to this initial broadcast.
Several function alerts related to memory allocation us-
ing a tainted size are generated during this initial phase.
The majority are in a single DLL, which we will refer to as
Parse.dll. Using the data ﬂow graph available, we can see
Parse.dll uses a second DLL Net.dll to read data from a
network socket through an exported function Net.dll!Read.
In Parse.dll there are 67 call sites to the allocation function
used, which PINNACLE narrows down to 10 as being depen-
dent on attacker provided input. In all cases the allocation
size is ﬁrst read from data received over the network, then
that same size is provided to Net.dll!Read to ﬁll the allo-
cated buﬀer. Using the taint information from PINNACLE we
can quickly inspect these call sites and conclude that all uses
of allocated buﬀer and attacker inﬂuenced size are safe.
However, if we instead inspect Parse.dll by looking at call
sites to Net.dll!Read where the size is tainted the results are
more interesting. Under this view we can see a single call to
Net.dll!Read where the size to be read is taken from a pre-
vious network packet and the destination buﬀer is the stack.
PINNACLE can provide us with each check and modiﬁcation
performed on the size value, allowing us to conﬁrm that any
non-zero size can be provided.
Pseudo-code for the vulnerability can be seen in Figure 3.
The ﬂaw itself is trivial to spot once the code has been iden-
205
Application
PrinterControl
ImageSuite
GameServer
IndDesign
BBCov
x1 (58s)
x1 (71s)
x1 (12s)
x1 (615s)
PINNACLE Track
x4 (210s)
x3 (240s)
x6 (68s)
x5 (3000s)
PINNACLE Trace
x5 (290s)
x13 (945s)
Timeout
OOM