/处理函数参款的默认值
PY_DECREF(V)=
V=POP(
NJILO
PyCodeObject
deff()
codle
func0.py的
1/获得与两数王对应的PyCodeObject对象
name
code;
图11-5
Pyobject
函数声明与函数定义的分离
_Gc_Aew(PyFunct lonobjeet,&EyEumction_Type);
Python源码剖析
Pyobjectglobals)
PyCodeObject
print"..
11.2无参函数调用
函数f的
深度探索动态语言核心技术
219
---
## Page 250
Python源码剖析
11.2.2
220
动作：
行时栈和1ocal名字空间的情形。
家应该对这两条指令及其动作相当熟悉了。图11-6展示了deff（）语句执行完成之后运
到了运行时栈中，随后的STORENAME和LOAD_NAME的作用这里不再详述。到了这里，大
不过这个总体框架的建立对以后的深入考察是大有牌益的。
立起对Pyhon函数调用过程的总体框架，尽管可能非常简陋，而且有许多细节的遗失，
在对带参函数的剖析中，我们会深入地考察参数的传递机制。在这一节，我们的目的是建
[CALL_FUNCTION]
的动作，由于我们的正是一个最简单的无参函数，没有任何参数，所以在这里略过不谈。
从“12CALL_FUNCTIONo”指令开始，Python虚拟机就进入了激动人心的函数调用
在MAKE_FUNCTION结束之后，新建的PyFunctionObject对象通过PUSH操作被压入
第11章Python虚拟机中的函数机制
在创建了PyFunctionObject对象之后，MAKE_FUNCTIoN还会进行一些处理函数参数
函数调用
else
return NULL:
1/函数的文档
consts
7/画数中的常量对象表
深度探索动态语言核心技术
stack_pointer=sp:
PyObject **sp;
doc =Py_None;
X
doc
(1PyString_Check(doc）&&IPyUnicode_Check（doe）)
cali
doc=Py_None;
图11-6创建PyFuctionObject对象之后的虚拟机状态
((Pycodeobject）code)->co_consts;
_function（&sp.oparg);
9
0）
>
---
## Page 251
代码清单11-2
时栈栈顶指针之后，就杀入了cal1_function（见代码清单11-2）。
static Pyobject*call_functlon(Pyobjeet **pp_stack,int oparg)
[ceval.c]
现在我们不深入阐述，只需要记住，其中计算得到的口指明了在运行时栈中，栈顶的多少
进入fast_function。这里需要重点关注一下fast_function的参数Fune，同时这个
会进入这个cal1_function
func也是被pyFunction_check进行检查的对象，我们猜想，
进入cALL_FUNCTION的指令代码中，Python虚拟机虚晃一枪，在获得了当前的运行
Python虚拟机在代码清单11-2的[31处通过了PyFunction_Check的检查之后，就会
可以看到，不光是我们的Function，另外两个家伙，CFunction和Method的调用也
if（PyCbunction_Check（func）&&mk==o）
7/1了：处理画数参数信息
在cal1_function开始的代码清单11-2的[1]处，
Jelse
Pyobject
Pyobject
Pyobject
intn=
nt
else
//[31：对PyFunctionobject对象进行调用
break:
PSH（X）
(ByFuretionCneck(fune))
(PyMethod_Check(fune)
X
ria
xDedo
=do_cal1（fune,pp_stack,na,nk）;
*func
continue;
*pfunc
NULL)
ptunc:
nk:
&0xff
当然，这里我们把关注的焦点集中在Function上，不管
&PyMethod_GET_SEDF（func）=NULL）
Python源码剖析
有一些处理函数参数信息的动作，
11.2
它一定就是通过deEf（）
无参函数调用
一深度探索动态语言核心技术
221
---
## Page 252
Python源码剖析
222
EvalFrameEx中发生的事，我们应该是很熟悉的了。
并进入一般函数的通道，所谓一般函数，我们会在后面介绍。在一般函数的通道中，Pyhon
function中实际上是包含了两条执行路径，无参函数会在代码清单11-3的[1]处作出判断，
pyCodeobject对象及函数运行时的global名字空间等信息。然后，我们看到，fast
fast_function(Pyobject *func,Pyobject ***pp_stack,int n)int maint nk)
代码清单11-3
的那个在MAKEFUNCTION中创建的PyFunctonObject对象。
向了Python虚拟机在CALL_FUNCTION之前通过“LOADNAME
的指令代码中传入的当前运行时栈的栈顶指针，所以很显然，
个元素是与参数相关的。当然对于我们的，这里的na、nk、n都会是0，所以在代码清
[ceval.c]
进入了fast_function之后，首先会抽取出Pyrunctionobject 对象中保存的
第11章Python虚拟机中的函数机制
好了，闲话少说，我们进入East_function（见代码清单1-3）。
if
Pyobjeet
Pyobjeut
/1]:
d=&PyTuple_GEr_ITEM(argdefs,
(argdefs I= NULL)
return retval;
retval=DyEval_EvalFrameEx（f,0）:
Lnt
pyObject
PyFrameObject
(argdefs
PyObiect
=PyFrame_New(tstate,co,(globals,NULii）;
一深度探索动态语言核心技术
一般函数的快速通道
EOP
*argdefs
PyFunction_GET_CLosURE(funG));
(*pp_staek))-2*nk,
*retval
Itstaee
NULL;
&&
PyFunction_GET_DEFAULTs(Eune);
ByEumetion
*)argdefs)->ob_size;
**gtack:
PyThreadstate_GET();
001
nd,
*pFunc，也就是unc，指
0”指令压入到运行时栈中
---
## Page 253
11.3
Python虚拟机在执行函数的字节码指令序列时，PyFrameobject对象之间的关系及它们
节码指令序列对应的PyCodeobject对象一起被传入到新的栈帧中的。图11-7展示了当
实际上是同一个名字空间。实际上这个名字空间是通过pyFunctionobject的携带，和字
码指令序列时的global名字空间和执行函数的字节码指令序列时的global名字空间
上就是当前PyFrameObject对象中的f_globala。这就意味着，在执行func_O.py的字节
的global名字空间。而在MAKE_FUNCTION的指令代码中，我们看到这个globals实际
f_builtins。在PyFunction_New时传入的globals将成为在新的栈帧中执行函数时
会依次从三个PyDictObject对象中进行搜索，搜索的顺序是：f_locals、_globals
将成为与函数对应的PyFrameObject中的global名字空间—f_globals
这样的函数则不行，Pyhon正是靠函数参数的形式来决定是否可以进入快速通道的。
就可以，比如 Draw（x，y）这样的函数，而像Python独有的函数，如Draw（x，key，*aict）
就是说，什么样的函数能进入快速通道呢？举个例子吧，像C、C++、Java中那样的函数
名字空间的一种打包和运输方式。
到头来，实际上是为他人做了嫁衣裳。PyFunctionobject主要是对字节码指令和global
储的 pycodeQbject对象和global名字空间。也就是说，PyFunctionobject辛苦一场，
Object 对象的影响已经消失了，真正对新栈顿产生影响的是在PyFunctionobject中存
帧中执行代码。有一点需要注意，在最终通过PyEval_EvalprameEx时，PyFunction
状态。这个过程实际上就是对x86平台上函数调用过程的模拟：创建新的栈帧，在新的栈
在我们的func_O.py中，也正是函数主中那条print语句对应的字节码。
的字节码指令序列的循环，这个新的字节码指令序列正是函数所对应的字节码指令序列。
EvalFrameEx，Python虚拟机在一个新的PyFrameObject（栈顿）环境中开始一次执行新
EvalFrameEx。也就是说，无参函数进入fast_function 之后，最终会进入PyEval
包含着一系列复杂而繁多的动作，但是如果追踪下去，在最后我们还是会看到一个yEval
还记得当初对LOAD_NAME指令的分析吗？在执行LOAD_NAME指令时，Python虚拟机
函数执行时的名字空间
现在，我们对Pyton中函数调用机制的大体框架比较熟悉了，在此基础上，来看一
前面我们提到了一般函数这个概念，在Pyton中，什么样的函数是一般函数呢？也
从PyEval_EvalFrameEx开始，Python虚拟机也就真正进入了所谓的“函数调用”的
而在另一条路径上，横亘着PyEval_EvalCodeEx。在函数PyEval_EvalCodeEx中，
Python源码剖析
11.3
函数执行时的名字空间223
一深度探索动态语言核心技术
---
## Page 254
Python源码剖析
224
中可使用a、b，
New之前，将globals的内容输出，如图11-8所示：
与global名字空间的关系。
底包含什么东西：
E
def E():
可以看到，在Pybon源代码中定义的符号都包含在了这个globals中，这使得在函数
考虑下面一段Python代码，我们看看在调用pyFunction_New时，这个globals到
第11章
修改Python源代码，在defE（）对应的MAKE_FUNCTION指令代码调用PyFunction_
print
func_O.py对应的PyFrameObject
深度探索动态语言核心技术
'Punction g"
图11-7
Python虚拟机中的函数机制
正是依靠这个globals的传递，才使得函数可以使用函数f以外的符号。
图11-8调用PyFuction_New之前的global名字空间
图11-9
函数调用时PyFrameObject 对象与global名字空间的关系
6
a'
CALL_FUNCTION中的global名字空间
file_
builtins_
name_
doc
file
builtins_
doc.
name
函数f对应的PyFrameObject
function
function
fglobals
NoneType
module
NoneType
"func_0-py”
module
func_O.py'
main_
fglobals
(PyDictObject)
global名字空间
---
## Page 255
11.4
实现。那么王这个狡猎的符号是在什么时候偷偷地溜进当前PyFrameobject对象的
对象中的func_globals输出来看看，结果如图11-9所示。
然没有自身，这就会导致一个严重的后果，即在主中不能再调用函数，也就是说，递
的整体框架，这一节的重点会放在参数的传递机制上。同时，在本节中，我们也将剖析函
水，会显得太死板。在这一节，我们将深入研究函数参数。上面我们已经分析了函数调用
的分析，而Pyhon则依靠的是运行时的名字空间。
不同的。C语言中函数是否可调用（可编译通过）完全是基于源代码中函数出现的位置做
并且被加入到王_1ocals（fglobais）中了，于是就可以使用了，这一点是跟C语言完全
数g了，虽然g是在之后被定义的。因为在执行至（）时，函数对象g已经被创建产生，
同时将E放进global名字空间f_globals中了。
作用域了。所以，当sTORE_NAME指令将符号f放入1ocal名字空间f_1ocals时，也就
这样的安排其实也是理所当然的，因为在func_0.py外层，什么都没有了，也不会有别的
个PyDictobject对象的，这一点可以在PyFrame_New中清晰地看到。不过仔细想一想，
时的那个作为参数的PyFrameobject对象，它的_locals和fglobals竟然是指向同
空间_locals中。妙就妙在，当开始执行func_0.py时，第一次进入PyEval_EvalFrameEx
STORE_NAME是将一个符号和符号对应的值存放到当前PyFrameObject对象的1ocal名字
而LOAD_NAME显然没有那么大的法力，玄机正是在这个STORE_NAME中。前面我们分析过
么在MAKE_FUNCTION和CALL_FUNCTION之间只有两条字节码，STORE_NAME和LOAD_NAME，
f_globals的呢？
在函数对应的那个PyFrameobject对象中的f_globals中，使得函数的递归调用得以
关键在哪里呢？同样，在cALL_FUNcTION指令的开始处将已经创建的PyFunctionObject
归函数没办法实现了。
从参数的类别开始。
数中局部变量的实现方式。
函数参数的实现
仔细地看一看，这里实际上还隐藏着另一个有趣的结论：在王中我们甚至可以使用函
事实真的是这样的吗？当然不是，Pyhon显然是支持函数的递归调用的。那么问题的
我们回过头来看看，如果略去那个函数g，基本上就是我们之前考察的func_0.py，那
可以看到，这时符号E已经进入了当前funcglobals，因此，符号就一定会出现
到了这里，如果你仔细观察，会发现一个致命的问题。那就是在这个globals中，居
在Pyton的函数机制中，参数一共分为四种类别的参数，我们对函数参数的剖析就
函数，必须要配上参数才会变得有趣，并呈现出万千变化。否则，函数就会像一滩死
Python源码剖析
11.4
函数参数的实现
深度探索动态语言核心技术
225
---
## Page 256
Python源码剖析
11.4.1
226
少个参数，一共需要多大的内存空间来维护参数。
数形式，但是实际上我们只需要记录位置参数的个数和键参数的个数，就能知道一共有多
本质上扩展位置参数是由多个位置参数构成的。这就意味着，虽然Pyhon中存在四种参
键参数的个数。虽然扩展位置参数和扩展键参数是位置参数和键参数的更高级形式，但是