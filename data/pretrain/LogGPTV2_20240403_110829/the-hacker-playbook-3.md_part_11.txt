赏金项目，或者仅仅想要快速发现输入验证存在哪些问题等情况。
因此，我们可以像（ http://bit.ly/2GXxqxH ）这样构建一个 Polyglot，而不是普通的
：
/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//\x3csVg/\x3e
67
第3章 抛传——Web 应用程序漏洞利用
如果你看一下上面的 payload,此攻击试图不使用尖括号，点和斜线的传统攻击代码；执行
onclick XSS；关闭多个标签；最后尝试一个 onload XSS。这些类型的攻击使 Polyglots 在识
别 XSS 方面非常有效和高效。你可以在此处阅读有关这些 Polyglot XSS 的更多信
息：https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot 。
如果你想测试和使用不同的 polyglots，可以从易受攻击的 XSS 页面（ http://chat:3000/xss
）或整个聊天应用程序开始。
BeEF
浏览器漏洞利用框架（ http://beefproject.com/ ）或简称 BeEF 将 XSS 攻击提升到另一个层
次。此工具将 JavaScript payload 注入受害者的浏览器，该浏览器会感染用户的系统。这会
在受害者的浏览器上创建一个 C2通道，用于 JavaScript 后期利用。
对红队来说，BeEF 是一个很好的工具，可用于入侵活动，跟踪用户，捕获凭据，执行点击劫
持，使用 Tabna 进行攻击等等。如果不在攻击期间使用，BeEF 也是一个很好的工具，可以
展示 XSS 漏洞的强大功能。这也有助于更复杂的攻击，我们将在后面的 Blind XSS 小节下讨
论。
BeEF 分为两部分：一部分是服务器，另一部分是攻击 payload。要启动服务器：
在你的攻击者 Kali 主机上启动 BeEF
打开终端
beef-xss
使用 beef：beef
查看 http://127.0.0.1:3000/hook.js
完整 payload 文件：
查看位于 http://127.0.0.1:3000/hook.js 上的 hook.js 文件，你应该会看到类似于长混淆的
JavaScript 文件的内容。这是连接受害者返回命令和控制服务器的客户端 payload 。
一旦在目标应用程序上识别出 XSS，而不是原始的 alert(1) 样式的 payload，就可以修改
 payload 来利用此漏洞。一旦你的受
害者陷入此 XSS 陷阱，将导致他们的浏览器连接回你这边并成为你的僵尸网络的一部分。
BeEF 支持哪些类型的后渗透攻击？一旦你的受害者受到你的控制，你就可以做任何
JavaScript 可以做的事情。你可以通过 HTLM5打开相机并拍摄受害者的照片，你可以在屏幕
上显示覆盖图以捕获凭据，也可以将其重定向到恶意网站以执行恶意软件。
以下是 BeEF 从 XSS 攻击中引发大量问题的快速演示：
首先，确保你的 BeEF 服务器在攻击者计算机上运行。在我们的易受攻击的聊天支持系统的
应用程序中，你可以访问 http://chat:3000/xss 并在练习2的字段中输入你的 payload：
68
第3章 抛传——Web 应用程序漏洞利用
一旦你的受害者连接到你的僵尸网络，你就可以完全控制他们的浏览器。你可以根据设备，
浏览器和目标机器启用的功能进行各种攻击。通过社会工程学演示 XSS 影响力的一个好方法
是通过 Flash 更新提示将恶意软件推送到他们的计算机。
一旦执行，将在受害者的计算机上显示弹出窗口，强制他们安装更新，其中包含我们准备的
恶意软件。
我建议花一些时间熟悉所有 BeEf 的后渗透模块，并了解 JavaScript 的强大功能。由于我们
会控制浏览器，因此我们必须弄清楚如何在红队活动中使用它。一旦你通过 XSS 感染了受害
者，你还想做些什么？我们将在后面的“从 XSS 到 shell”部分讨论这个问题。
Blind XSS 漏洞
Blind XSS 漏洞很少被讨论，因为它是需要耐心的游戏。什么是 Blind XSS 漏洞？正如攻击的
名称所表示的那样，攻击者/用户看不到存储的 XSS payload 的执行（无回显），只有管理员
或后台员工才能看到。由于其攻击后端用户的能力，所以这种攻击可能危害很大，但尽管如
此，它还是经常被遗忘。
69
第3章 抛传——Web 应用程序漏洞利用
例如，我们假设某个应用程序有一个“联系我们”页面，允许用户向管理员提供联系信息，以便
以后联系。由于该数据的结果只能由管理员手动查看而不是用户请求查看，所以如果应用程
序易受 XSS 攻击，攻击者不会立即看到他们的 “alert(1)” 攻击的回显。在这些情况下，我们
可以使用 XSSHunter 来帮助我们验证 Blind XSS 漏洞。
XSSHunter 的工作原理是，当我们的 JavaScript payload 执行时，它将截取受害者屏幕（他
们正在查看的当前页面）的屏幕截图，并将该数据发送回 XSSHunter 的站点。发生这种情况
时，XSSHunter 将发送一个警报，告知我们的 payload 已执行并向我们提供所有详细信息。
我们现在可以回去创建一个恶意 payload 并重新进行我们的攻击。
XSS Hunter：
禁用任何代理（即 Burp Suite）
在 https://xsshunter.com 创建帐户
登录 https://xsshunter.com/app
转到 Payload 模块以获得你的 Payload
修改 payload 以适应你的攻击或使用它构建 Polyglot
检查 XSS hunter 以查看 payload 执行情况
70
第3章 抛传——Web 应用程序漏洞利用
基于 DOM 的 XSS
对反射 XSS 和存储 XSS 的理解相对简单。我们已经知道，如果服务器没有为用户/数据库提
供足够的输入/输出验证，我们的恶意脚本代码就会通过源代码呈现给用户。然而，在基于
DOM 的 XSS 中，它略有不同，这导致了一些常见的误解。因此，让我们花些时间专注于基
于 DOM 的 XSS。
当攻击者可以操纵 Web 应用程序的客户端脚本时，就可以使用基于文档对象模型（DOM）的
XSS。如果攻击者可以将恶意代码注入 DOM 并由客户端的浏览器读取，则可以在从 DOM 读
回数据时执行 payload。
DOM 究竟是什么？文档对象模型（DOM）是 HTML 属性的一个特性。由于你的浏览器不理
解 HTML，因此它会使用将 HTML 转换为 DOM 模型的解释器。
让我们在聊天支持网站上试一下吧。查看易受攻击的 Web 应用程序，你应该能够看到聊天支
持网站受到 XSS 攻击的流程：
创建一个帐户
登录
去聊天
尝试  ，然后尝试一些更疯狂的 XSS 攻击！
在我们的示例中，我们在服务器端有 Node.js，socket.io（Node.js 的库）在用户和服务器之
间设置 Web 套接字，客户端 JavaScript 和我们的恶意 msg.msgText JavaScript。正如你在下
面和页面的源代码中看到的那样，你不会像在标准的反射/存储的 XSS 中那样直接引用你
的“弹窗” payload。在这个例子里，我们将得知唯一指示可以调用 payload 的位置来自
msg.name 引用。这有时会使我们很难确定执行 XSS payload 的位置，或者是否需要打破任
何 HTML 标记。
NodeJS 中的高级 XSS
XSS 可以不断用于攻击的一个重要原因是，仅靠过滤标签或某些字符防御它的话要困难得
多。当 payload 特定于某种语言或框架时，XSS 很难防御。由于每种语言在此漏洞方面都有
其独到之处，因此 NodeJS 也不会有什么不同。
71
第3章 抛传——Web 应用程序漏洞利用
在高级 XSS 部分中，你将学习一些特定语言的 XSS 漏洞发挥作用的示例。我们的 NodeJS
Web 应用程序将使用一种更常见的 Web 堆栈和配置。此实现包括 Express Framework 和
Pug 模板引擎。重要的是要注意一点，默认情况下，Express 确实没有内置的 XSS 防护，除
非通过模板引擎进行渲染。当使用像 Pub 这样的模板引擎时，有两种常见的方法可以找到
XSS 漏洞：(1)通过字符串插值，以及(2)缓冲代码。
模板引擎有一个字符串插值的概念，这是一种定义“字符串变量的占位符”的奇特方式。例如，
让我们将字符串分配给 Pug 模板格式的变量：
- var title = "This is the HTML Title"
- var THP = "Hack the Planet"
h1 #{title}
p The Hacker Playbook will teach you how to #{THP}
请注意， #{THP} 是 THP 之前分配的变量的占位符。我们通常会在电子邮件分发消息中看到
这些模板。你是否收到过来自 ...的自动化系统发送的电子邮件而不是你的真实
${first_name}
名字？这正是模板引擎的用途。
当上面的模板代码呈现为 HTML 时，它将如下所示：
This is the HTML Title
The Hacker Playbook will teach you how to Hack the Planet
幸运的是，在这种情况下，我们使用 #{} 字符串插值，这是 Pug 插值的转义版本。如你所
见，通过使用模板，我们可以创建可重用性非常高的代码并使模板非常轻量级。
Pug 支持转义和非转义字符串插值。隐藏和未转义之间的区别是什么？好吧，使用转义字符
串插值将对  ， ' 和 " 之类的字符进行 HTML 编码。这将有助于向用户提供输入
验证。如果开发人员使用非转义字符串插值，这通常会导致 XSS 漏洞。
此外，字符串插值（或变量插值，变量替换或变量扩展）是评估包含一个或多个占位符的字
符串文字的过程，从而产生一个结果，其中占位符替换为其对应的值。
[https://en.wikipedia.org/wiki/String_interpolation]
在 Pug 隐藏和非转义字符串插值（ https://pugjs.org/language/interpolation.html ）：
!{} - 非转义字符串插值
#{} - 转义字符串插值 * 虽然这是转义的，但如果直接通过 JavaScript 传递它仍然
可能容易受到 XSS 的攻击
在 JavaScript 中，未转义的缓冲区代码以“!=”开头。“!=”之后的任何内容都将自动作为
JavaScript 执行。 [https://pugjs.org/language/code.html#unescaped-buffered-code]
最后，只要允许插入原始 HTML，就有可能存在 XSS。
72
第3章 抛传——Web 应用程序漏洞利用
在现实世界中，我们已经看到许多易受 XSS 攻击的案例，基于上述说明的方法，开发人员忘
记了他们所处的上下文以及输入的参数的传递位置。让我们看看我们易受攻击的聊天支持系
统应用程序中的一些示例。转到虚拟机上的以下 URL： 。我们将逐步
http://chat:3000/xss
完成这些练习中的每一个，以了解 NodeJS/Pug XSS。
练习1：（ http://chat:3000/xss ）
在这个例子中，我们将字符串插值转义为段落标记。这是不可利用的，因为我们在 HTML 段
落上下文中使用了正确的转义字符串插值符号。
转到 http://chat:3000/xss ，然后单击练习＃1
Pug 模板源代码
p No results found for #{name1}
尝试输入并提交以下 payload ：
单击练习＃1并查看无结果输出
查看 HTML 响应（查看页面的源代码）：
点击提交后，查看页面源代码（ctrl+u）并搜索“alert”一词。你将看到我们的 payload 中的特
殊字符被转换为 HTML 实体。脚本标签仍可通过我们的浏览器在我们的网站上看到，但不会
呈现为 JavaScript。这种字符串插值的使用是正确的，并且实际上没有办法通过这种情况来
找到 XSS。这个工作评分会是 A+！让我们看一些糟糕的例子。
练习2
在这个例子中，我们在段落标记中用 表示非转义字符串插值。这很容易受到被精心设计
!{}
的 XSS 攻击。任何基本的 XSS payload 都会触发此操作，例如： 
打开练习2
Pug 模板源代码
p No results found for !{name2}
尝试输入 payload：
返回：
73