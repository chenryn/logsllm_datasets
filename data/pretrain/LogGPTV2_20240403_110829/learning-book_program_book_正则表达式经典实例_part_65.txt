参见
实例2.3和实例2.6。
7.3在全文中查找加引号的URL
问题描述
你要在一大段文本中查找URL。URL可能被标点符号包括起来，也可能没有，外包的
标点符号是属于外围文本的一部分，而不是URL的一部分。你要使用户可以选择是否
把URL放到引号中，这样就能显式地指出标点符号或者甚至是空格，是否应当是URL
的一部分。
解决方案
\b(?:(?:https?1ftp|fi1e)://1(www|ftp)\.) [-A-z0-9+&@#/%?=~_1$!:,.] *
[-A-Z0-9+&@#/=~_1S]
I"(?:(?:https?|ftplfile) :/ /1(www|ftp)\.) [^"\r\n]+"
1'(?:(?:https?|ftp|file):/ /|(www|ftp)\.) ['\r\n]+*
正则选项：宽松排列、不区分大小写、点号匹配换行符、定位符匹配换行处
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
前一实例解释了URL和英语文本混合在一起的问题，以及如何将英语标点符号和URL
字符区分开来。尽管前一实例的解决方案非常实用，并且它在大多数时候都能正确工
作，但是没有一个正则表达式能够在所有时候都是对的。
如果把你的正则表达式用在尚未写出的文本中，那么可以为用户提供一个为URL周围
加引号的方法。本节我们所给的解决方案都充许把一对单引号或者双引号加在URL周
URL、路径和Internet地址337
www.TopSage.com
---
## Page 354
两个子域名（wwwftp>之-一作为开头。在一个通信协议方案或者子域名之后，正则表达
式允许URL包括除了换行符和作为分界符的引号以外的任意字符。
整个正则表达式可以被拆分为3个选择分支。第一个选择分支是来自前一实例的正则
表达式，它匹配未加引号的URL，试图区分英文中的标点符号和URL字符。第二个选
择分支会匹配一个加了双引号的URL。第3个选择分支匹配一个加了单引号的URL。
这里我们用了2个选择分支，而不是用一个带捕获分组的选择分支来获取起始引号，
然后使用向后引用来匹配结束引号，因为我们不能在一个否定字符类中使用向后引用
排除URL中的引号符。
之所以选择单引号和双引I号，是因为这是在HTML和XHTML文件中URL通常会出现
的方式。这种为URL加引号的方法对于在Web上工作的人们来说很自然，当然你也可
以很容易地编辑这个正则表达式，使之支持使用不同的字符对来分隔URL。
参见
实例2.8和实例2.9。
7.4在全文中寻找加括号的URL
问题描述
你要在一大段文本中找到URL。URL可能被标点符号包括起来，也可能没有，外包的
标点符号是属于外围文本的一部分，而不是URL的一部分。你要正确地匹配在内部包
含了括号对的URL，而不能匹配位于整个URL两边的一对括号。
解决方案
\b (?: (?:https?Iftp| file) : / / Iwww\. 1ftp\.)
（?:\([-A-20-9+&@#/=~_1$?1:,.]*\) 1[-A-20-9+&@#/=~_1$?！:,.]) *
（[s1~=/#+6-02-]1(\[:1~=/#+6-02--])\:）
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
\b(?:(?:https?1ftp1file)://1www\.1ftp\.)(?:\([-A-20-9+&@#/&=~_1$?!:,.]*\)
1[-A-20-9+&@#/8=~_1$？!:,.]) *(?:\([-A-20-9+6@#/%=~_1S?!:,.1*\)1
（[s1~=/#9+6-02-]
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
几乎任意字符都是URL中的合法字符，这其中也包含了括号。然而，括号在URL中
极为罕见，这就是为什么我们不在上一个实例的任何一个正则表达式中包含括号的原
338第7章
www.TopSage.com
---
## Page 355
因。但是一些重要的网站已经开始使用括号了：
http://en.wikipedia.org/wiki/PC_Tools_(Central_Point_Software)
http://msdn.microsoft.com/en-us/1ibrary/aa752574(vs.85).aspx
一种解决方案是要求你的用户为这样的URL加引号。另外一种解决方案是强化你自己
的正则式来接受这类URL。这里的困难之处在于确定一个结束括号是否是URL的一部
分，还是它被用作包围URL的标点符号，如下例所示：
RegexBuddy's web site (at http://www.regexbuddy.com) is really cool.
因为有可能两个括号中的一个与URL较为紧邻，而另一个括号则距离URL较远，所
以我们不能使用前一实例中加引号的正则式技巧。最直观的解决方案是只允许URL中
的括号以不嵌套的左括号和右括号对出现。前面所给的例子中，维基百科和微软的URL
符合这一需求。
前面解决方案中所给的两个正则表达式是一样的。第一个使用了宽松排列模式，使得
它更容易阅读。
这些正则表达式本质上和实例7.2的解决方案是一样的。所有正则表达式都由3个部分
组成：通信协议方案的列表，紧接着是一个URL主体，其中使用了星号量词允许URL
为任意长度，以及URL的结尾，它没有使用量词（也就是说，它只能出现一次）。在
实例7.2最初的正则表达式中，URL主体和URL结尾都只包含了一个字符类。
本实例的解决方案用更精细的内容替换了2个字符类。
中间的字符类：
[-A-Z0-9+&@#/%=~_1S?!:,.]
被替换为：
（[-A-20-9+&@#/%=~_1$?！:,.]*\)1[-A-20-9+&@#/=~_1$？!:,.]
最后一个字符类：
[S1~=/#9+6-02-]
被替换为：
\（[-A-20-9+&@#/=~_1$？!:,.]*\)1[A-20-9+&@#/=~_1$]
这两个字符类都被替换成了和多选结构有关的内容（实例2.8）。因为多选结构在所有
的正则式操作符中的优先级最低，因此我们使用了非捕获分组（实例2.9）来保证这两
个多选结构是并列的。
对于两个字符类来说，我们添加了选择分支和c>是字面的括号，
而和。如果在d>上直接加上一个内部的星号，该正则表达式的复杂度就会出现指数级
的增长。（(d*)*可以按照许多不同方式来匹配dddd。例如，外围的星号可以重复4次，
而内部的星号每次重复1次。外围星号也可以重复3次，而内部星号则可以采取重复
2-1-1、1-2-1或者1-1-2。如果外围星号重复2次，那么内部星号可以是2-2、1-3或者
3-1。你可以想像，当字符串长度增加时，可能的组合数量是快速爆炸式增长的。我们
把这叫作灾难性的回溯，它是在实例2.15中引人的概念。当正则表达式不能找到一个
合法的匹配时就会出现这个问题，例如，这可能是因为你已经在正则表达式尾部附加
了一些内容，来查找包含特定要求字符或者以特定要求的字符作为结尾的URL。
参见
实例2.8和实例2.9。
7.5把URL转变为链接
问题描述
你有一段可能包含一个或多个URL的文本。你需要把其中所包含的URL转变为链接，
把HTML定位符标签添加到URL之上。URL字符串本身则可以作为链接的目标和被
加链接的文本。
解决方案
要找到文本中的URL，可以使用实例7.2或者实例7.4中的正则表达式。至于替代文本，
习使用：
$&
替代文本流派：.NET、JavaScript、Per1
$0
替代文本流派：.NET、Java、PHP
340第7章
www.TopSage.com
---
## Page 357
\0
替代文本流派：PHP、Ruby
\&
替代文本流派：Ruby
">\g
替代文本流派：Python
在编程时，你可以参考在实例3.15中讲解过的查找和替换操作来实现。
讨论
本问题的解决方案非常直观。我们使用了一个正则表达式来匹配URL，然后用
《URL》来替代它，这里的URL代表我们所匹配到的URL。不
同的编程语言会使用不同的语法来作为替代文本，因而这个问题的解决方案中包含
了一长串的列表。但是它们所做的的确都是一样的事情。实例2.20中讲解了替代文
本语法。
参见
实例2.21、实例3.15、实例7.2和实例7.4。
7.6URN合法性验证
问题描述
你要检查是否-一个字符串代表了一个合法的统一资源名称（URN），并且符合RFC2141
中的规定，或者是要在一大段文本中查找URN。
解决方案
检查一个字符串是否整体上由一个合法URN组成：
\Aurn:
#命名空间标识
[a-z0-9][a-z0-9-]{0, 31}:
#特定于命名空间的字符串
[a-z0-9（）+,\-.:=;$_!*/?#]+
\z
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
^urn:[a-z0-9][a-z0-9-1(0,31}:[a-z0-9()+,\-.:=@;$_!*+e/?]+$
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
在一大段文本中查找URN：
URL、路径和Internet地址
341
www.TopSage.com
---
## Page 358
\burn:
#命名空间标识
[a-20-9][a-z0-9-]{0,31}:
#特定于命名空间的字符串
[a-z0-9（)+,\-.:=@;$_!*'g/?#]+
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
\burn:[a-z0-9][a-z0-9-]{0, 31}:[a-z0-9()+,\-.:=@;$_!*'&/?#]+
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在一大段文本中找到一个URN，并假设URN结尾处的标点符号是引I用该URN的（英
文）文本的一部分，而不属于URN本身的一部分：
\burn:
#命名空间标识
[a-z0-9][a-z0-9-]{0,31}:
#特定于命名空间的字符串
[a-z0-9()+,\-.:=@;$_!*'g/?#] *[a-z0-9+=@$/]
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
\burn:[a-z0-9][a-z0-9-]{0,31}:[a-z0-9()+,\-.:=@;$_!*'%/?#] *[a-z0-9+=@$/]
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
一个URN由3个部分组成。第一部分是4个字符um:，我们可以在正则表达式中以字
面方式添加这4个字符。
第二部分是命名空间标识（NID)。它的长度介于1～32个字符之间。第一个字符必须
是字母或者数字。余下部分的字符可以是字母、数字或者连字符。我们用了2个字符
类（参见实例2.3）来进行匹配：第一个字符类匹配一个字母或数字，第二个字符类匹
配0～31个字母、数字和连字符。NID必须以冒号分隔，正则式中可以在字面上添加
冒号。
URN的第三个部分是特定于命名空间的字符串（NSS）。它可以是任意长度的，可以包
括字母、数字以及各种各样的标点符号字符。我们用另一字符类可以很容易地匹配到
它。在字符类后的加号使之重复一次或者多次（实例2.12）。
假如你要检查一个字符串是否代表了一个合法的URN，剩下还需要做的事情就是在正
则式的开头和结尾加上定位符以匹配字符串的开头和结尾。除了Ruby之外的所有正则
流派都可以用匹配字符串开头和结尾，而除了JavaScript之外的所有正则流
派都可以用A和Z>。关于这些定位符的详细信息，可以参考实例2.5。
如果你要在一大段文本中来查找URN，这就有一点麻烦了。实例7.2中讨论过的URL
342第7章
www.TopSage.com
---
## Page 359