that veriﬁes against the bit-ﬂipped public key stored in
the original trusted.gpg.
We can now sign our malicious package with the new
private key and the victim will download and install the
new package without a warning.
5 Evaluation
We evaluated dFFS to answer the following three key
questions:
• What is the success probability of the dFFS attack?
• How long does the dFFS attack take?
• How much computation power is necessary for a
successful dFFS attack?
We used the following methodology for our evalua-
tion. We ﬁrst used a Rowhammer testbed to measure
how many templates are available in a given segment of
memory and how long it takes us to ﬁnd a certain tem-
plate. We then executed the end-to-end attacks discussed
in Section 4.5 and report on their success rate and their
start-to-ﬁnish execution time. We then performed an an-
alytical large-scale study of the factorization time, suc-
cess probability, and computation requirements of 200
USENIX Association  
25th USENIX Security Symposium  9
9
Figure 4: Required time and memory for templating.
Figure 5: Number of usable 1-to-0 bit ﬂips usable in the
SSH authorized_keys ﬁle for various modulus sizes.
RSA public keys for each of the 1024, 2048 and 4096-bit
moduli with 50 bit ﬂips at random locations (i.e., 30,000
bit ﬂipped public keys in total).
We used the following hardware for our Rowhammer
testbed and for the cluster that we used to conduct our
factorization study:
Rowhammer testbed.
Intel Haswell i7-4790 4-core
processor on an Asus H97-Pro mainboard with 8 GB of
DDR3 memory.
Factorization cluster. Up to 60 nodes, each with two
Intel Xeon E5-2630 8-core processors with 64 GB of
memory.
5.1 dFFS on the Rowhammer Testbed
Memory templating. Our current implementation of
Rowhammer takes an average of 10.58 seconds to com-
plete double-sided Rowhammer for each target row. Fig-
ure 4 shows the amount of time and physical memory
that is necessary for discovering a certain number of tem-
plates. Note that, in our testbed, we could discover tem-
plates for almost any bit offset (i.e., 29,524 out of 32,768
possible templates). Later, we will show that we only
need a very small fraction of these templates to success-
fully exploit our two target programs.
Memory massaging.
dFFS needs to wait for a certain
amount of time for KSM to merge memory pages. KSM
scans a certain number of pages in each waking period.
On the default version of Ubuntu, for example, KSM
scans 100 pages every 20 milliseconds (i.e., 20 MB). Re-
cent work [12] shows that it is possible to easily detect
when a deduplication pass happens, hence dFFS needs
to wait at most the sum of memory allocated to each co-
hosted VM. For example, in our experiments with one
Figure 6: CDF of successful automatic SSH attacks.
attacker VM and one victim VM each with 2 GB of mem-
ory, KSM takes at most around 200 seconds for a com-
plete pass.
5.2 The SSH Public Key Attack
Figure 5 shows the number of possible templates to per-
form the dFFS attack on the SSH authorized_keys
ﬁle with a single randomly selected RSA public key, for
1024, 2048 and 4096-bit public keys. For this experi-
ment, we assumed 1-to-0 bit ﬂips since they are more
common in our testbed. For DRAM chips that are sus-
ceptible to frequent 0-to-1 bit ﬂips, these numbers dou-
ble. For our experiment we focused on 2048-bit public
keys as they are the default length as generated by the
ssh-keygen command.
To demonstrate the working end-to-end attack, mea-
sure its reliability, and measure the elapsed time distri-
bution, we automatically performed the SSH attack 300
times from an attacker VM on a victim VM, creating the
keys and VM’s from scratch each time. Figure 6 shows
the CDF of successful attacks with respect to the time
they took. In 29 cases (9.6%), the Rowhammer opera-
tion did not change the modulus at all (the attacker needs
10  25th USENIX Security Symposium 
USENIX Association
10
 0 500 1000 1500 2000 2500 3000 3500 4000 4500 0 5000 10000 15000 20000 25000 30000 0 10 20 30 40 50 60Physical memory used (MB)Time spent (h)Unique templates discoveredPhysical memoryTime spent 0 5 10 15 20 25 30 200 400 600 800 1000 1200 1400 1600 1800 2000FrequencyNumber of usable 1->0 bit ﬂips1024-bit Moduli2048-bit Moduli4096-bit Moduli 0 0.2 0.4 0.6 0.8 1 0 2 4 6 8 10 12CDFAttack time (mins)successful attacksTable 1: Examples of domains that are one bit ﬂip away
from ubuntu.com that we purchased.
ubuftu.com ubunt5.com ubunte.com
ubunuu.com ubunvu.com ubunpu.com
ubun4u.com ubuntw.com ubuntt.com
to retry). In 19 cases (6.3%), the Rowhammer operation
changed the modulus other than planned. The remaining
252 (84.1%) were successful the ﬁrst time. All the at-
tacks ﬁnished within 12.6 minutes with a median of 5.3
minutes.
5.3 The Ubuntu/Debian Update Attack
We tried factorizing the two bit-ﬂipped 4096 bit Ubuntu
Archive Automatic Signing RSA keys found in the
trusted.gpg ﬁle. Out of the 8,192 trials (we tried
both 1-to-0 and 0-to-1 ﬂips), we could factorize 344 tem-
plates. We also need to ﬁnd a bit ﬂip in the URL of the
Ubuntu or Debian update servers (depending on the tar-
get VM’s distribution) in the page cache entry for apt’s
sources.list ﬁle. For ubuntu.com, 29 templates re-
sult in a valid domain name, and for debian.org, 26
templates result in a valid domain name. Table 5.2 shows
examples of domains that are one bit ﬂip away from
ubuntu.com.
Performing the update attack on our Rowhammer
testbed, we could trigger a bit ﬂip in the page cache
entry of sources sources.list in 212 seconds, con-
verting ubuntu.com to ubunvu.com, a domain which
we control. Further, we could trigger a bit ﬂip in the
page cache entry of trusted.gpg that changed one of
the RSA public keys to one that we had pre-computed
a factorization in 352 seconds. At this point, we man-
ually sign the malicious package with our GPG private
key that corresponds to the mutated public key. When
the victim then updates the package database and up-
grades the packages, the malicious package is down-
loaded and installed without warning. Since the cur-
rent version of dFFS runs these steps sequentially, the
entire end-to-end attack took 566 seconds. We have
prepared a video of this attack which is available at:
https://vusec.net/projects/flip-feng-shui
Growingly concerned about the impact of such practi-
cal attacks, we conservatively registered all the possible
domains from our Ubuntu/Debian list.
5.4 RSA Modulus Factorization
Figure 7 shows the average probability of successful fac-
torizations based on the amount of available compute
Figure 7: Compute power and factorization timeout
tradeoff for 2048-bit RSA keys.
Figure 8: CDF of success rate with increasing templates.
hours. We generated this graph using 200 randomly gen-
erated 2048-bit RSA keys, each with a bit ﬂip in 50 dis-
tinct trials (i.e., 10,000 keys, each with a bit ﬂip). For this
experiment, we relied on the ECM factorization tool, dis-
cussed in Section 3, and varied its user-controlled time-
out parameter between one second and one hour. For
example, with a timeout of one second for a key with a
bit ﬂip, we either timeout or the factorization succeeds
immediately. In both cases, we move on to the next trial
of the same key with a different bit ﬂip.
This graph shows that, with 50 bit ﬂips, the average
factorization success probability is between 0.76 for a
timeout of one second and 0.93 for a timeout of one hour.
Note that, for example, with a timeout of one second,
we can try 50 templates in less than 50 seconds, while
achieving a successful factorization in as many as 76%
of the public keys. A timeout of one minute provides
a reasonable tradeoff and can achieve a success rate of
91% for 2048-bit RSA keys.
Figure 8 shows the cumulative success probability of
factorization as more templates become available for
1024-bit, 2048-bit and 4096-bit keys. For 4096-bit keys,
we need around 50 templates to be able to factorize a
key with high probability (0.85) with a 1-hour timeout.
USENIX Association  
25th USENIX Security Symposium  11
11
 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 5 10 15 20 25 30 35 40 45 50Success ProbabilityCompute hours availabletimeout 1 sectimeout 10 sectimeout 1 mintimeout 5 mintimeout 60 min 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 10 20 30 40 50Factorization Success ProbabilityAvailable Templates1024-bit Moduli2048-bit Moduli4096-bit ModuliTable 2: Memory savings with different dedup strategies.
Strategy
Required memory
Savings
No dedup
Zero-page dedup
Full dedup
506 GB
271 GB
108 GB
0%
46%
79%
6.1 Defending against dFFS
We discuss both hardware and software solutions for de-
fending against dFFS.
Figure 9: Probability mass function of successful factor-
izations with one ﬂip.
6.1.1
In Hardware
With bit-ﬂipped 2048-bit RSA public keys, with only
48 templates, we achieved a success probability of 0.99
with a 1 hour timeout. This proves that for 2048-bit keys
(ssh-keygen’s default), only a very small fraction of the
templates from our testbed is necessary for a successful
factorization. For 1024-bit keys, we found a successful
factorization for all keys after just 32 templates.
Some DRAM modules may only have a small number
of bit ﬂips [34], so an interesting question is: what is the
chance of achieving a factorization using only a single
template? Figure 9 answers this question for 1024-bit,
2048-bit and 4096-bit moduli separately. To interpret the
ﬁgure, ﬁx a point on the horizontal axis: this is the prob-
ability of a successful factorization using a single bit ﬂip
within 1 hour. Now read the corresponding value on the
vertical axis, which shows the probability that a public
key follows this success rate. For example, on average,
15% of 2048-bit RSA public keys can be factored using
only a single bit ﬂip with probability 0.1. As is expected,
the probability to factor 4096-bit keys with the same 1-
hour timeout is lower, and for 1024-bit keys higher. The
fact that the distributions are centered around roughly
0.22, 0.11, and 0.055 are consistent with our analytical
results in 3, which predict the factorization cost is linear
in the bitlength of the modulus.
6 Mitigations
Mitigating Flip Feng Shui is not straightforward as hard-
ware reliability bugs become prevalent. While there
is obviously need for new testing methods and certi-
ﬁcation on the hardware manufacturer’s side [4], soft-
ware needs to adapt to ﬁt Flip Feng Shui in its threat
model.
In this section, we ﬁrst discuss concrete miti-
gations against dFFS before suggesting how to improve
software to counter FFS attacks.
We recommend DRAM consumers perform extensive
Rowhammer testing [2] to identify vulnerable DRAM
modules. These DRAM modules should be replaced,
but if this is not possible, reducing DRAM refresh in-
tervals (e.g., by half) may be sufﬁcient to protect against
Rowhammer [51]. However, this also reduces DRAM
performance and consumes additional power.
Another option is to rely on memory with error-
correcting codes (ECC) to protect against single bit ﬂips.
Unfortunately, we have observed that Rowhammer can
occasionally induce multiple ﬂips in a single 64-bit word
conﬁrming the ﬁndings of the original Rowhammer pa-
per [34]. These multi-ﬂips can cause corruption even in
presence of ECC. More expensive multi-ECC DIMMs
can protect against multiple bit ﬂips, but it is still unclear
whether they can completely mitigate Rowhammer.
A more promising technology is directed row re-
fresh, which is implemented in low-power DDR4 [7]
(LPDDR4) and some DDR4 implementations. LPDDR4
counts the number of activations of each row and,
when this number grows beyond a particular threshold,
it refreshes the adjunct rows, preventing cell charges
from falling below the error margin. Newer Intel pro-
cessors support a similar feature for DDR3, but re-
quire compliant DIMMs. While these ﬁxes mitigate
Rowhammer, replacing most of current DDR3 deploy-
ments with LPDDR4 or secure DDR4 DIMMs (some
DDR4 DIMMs are reported to be vulnerable to Rowham-
mer [1]), is not economically feasible as it requires com-
patible mainboards and processors. As a result, a soft-
ware solution is necessary for mitigating Rowhammer in
current deployments.
6.1.2
In Software
The most obvious mitigation against dFFS is disabling
memory deduplication.
In fact, this is what we rec-
ommend in security-sensitive environments. Disabling
memory deduplication completely, however, wastes a
12  25th USENIX Security Symposium 
USENIX Association
12
 0 0.05 0.1 0.15 0.2 0.25 0.3 0 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4Frequency of Successful FactorizationSingle-ﬂip Success Probability1024-bit Moduli2048-bit Moduli4096-bit Modulisubstantial amount of physical memory that can be saved
otherwise [6, 46, 54].
Previous work [12] showed that deduplicating zero
pages alone can retain between 84% and 93% of the
beneﬁts of full deduplication in a browser setting. Lim-
iting deduplication to zero pages and isolating their
Rowhammer-prone surrounding rows was our ﬁrst mit-
igation attempt. To understand whether zero-page dedu-
plication retains sufﬁcient memory saving beneﬁts in a
cloud setting, we performed a large-scale memory dedu-
plication study using 1,011 memory snapshots of dif-
ferent VMs from community VM images of Windows
Azure [48]. Table 2 presents our results. Unfortunately,
zero-page deduplication only saves 46% of the poten-
tial 79%. This suggests that deduplicating zero pages
alone is insufﬁcient to eradicate the wasteful redundancy
in current cloud deployments. Hence, we need a bet-
ter strategy that can retain the beneﬁts of full memory
deduplication without resulting in a memory massaging
primitive for the attackers.
A strawman design A possible solution is to rely on
a deduplication design that, for every merge operation,
randomly allocates a new physical page to back the ex-
isting duplicate pages. When merge operations with ex-
isting shared pages occur, such design would need to
randomly select a new physical page and update all the
page-table mappings for all the sharing parties.
This strawman design eliminates the memory massag-
ing primitive that is necessary for dFFS under normal cir-
cumstances. However, this may be insufﬁcient if an at-
tacker can ﬁnd different primitives to control the physical
memory layout. For example, the attacker’s VM can cor-
ner the kernel’s page allocator into allocating pages with
predictable patterns if it can force the host kernel into an
out-of-memory (OOM) situation. This is not difﬁcult if
the host relies on over-committed memory to pack more
VMs than available RAM, a practice which is common
in cloud settings and naturally enabled by memory dedu-
plication. For example, the attacker can trigger a massive
number of unmerge operations and cause the host kernel
to approach an OOM situation. At this point, the attacker