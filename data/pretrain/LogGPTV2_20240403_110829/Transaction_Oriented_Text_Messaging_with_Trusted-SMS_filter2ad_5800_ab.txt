key.
2. Service Supplier: the Service Supplier does not own
any secret key; the SS signature services depends on
the secrets owned by the CA.
3. CA: the CA owns a key-pair; the CA uses this key-
pair in order to satisfy the Service Supplier requests for
signing the SMS-content. Moreover the CA owns the
list of the EU public key in order to verify the signa-
tures that the Service Supplier receives with the SMS.
The Indirect Schema transaction requires the “on-line” par-
ticipation of the CA, so it can be deﬁned as an arbitrated
protocol. The EU takes part into the scenario with two dif-
ferent channels: the SMS and the Web. At the beginning
the EU browsing on the SS web site sends the request for
a speciﬁc service. The SS receives this request and records
it on its own database, print on the web page a SR: service
response, then SS involves the CA for the signature gener-
ation process. Our implementation preserves the SMS con-
tent from the CA access by producing a digest of SMS real
content with SHA1. The CA veriﬁes if the EU is able to
send the service request then it generates the signature for
the digest of the SMS received from the SS with its own
private key. The SS encapsulates the text and the signature
(ΣCA) into an SMS and sends it to the EU. The SS involves
the CA again in order to verify the EU signature appended
to the SA. If the signature is correct, the CA produces a
SC or a service conﬁrmation; the SS delivers the requested
service according to the user reply, sending a twofold con-
ﬁrmation: the ﬁrst one on its web-site and the second one
over the SMS channel.
Scenario 2: Direct transaction schema (SS-Centric)
The direct transaction schema requires that:
488488
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:56:46 UTC from IEEE Xplore.  Restrictions apply. 
1. EU: each EU has to be provided with a key-pair; the
distribution of the key pair to the end users is realized
following a speciﬁc provisioning scenario among that
described in previous sections. Moreover each EU has
the list of public keys of the Service Suppliers with
which it is interested to interact.
– All the transactions move together toward a sin-
gle point of failure, that can represent also the
framework bottleneck or the target of a DoS at-
tack.
Direct Schema
2. Service Supplier: each Service Supplier has to be pro-
vided with key-pair; the Service Supplier uses its pri-
vate key in order to sign the SMS sent to its customer
(the EUs).
Pros:
– The common PKI infrastructure and roles are
preserved.
– CA is not aware about EU and SS interaction,
CA never accesses the SMS content, the privacy
of the transactions is preserved.
3. CA: the CA in this schema plays its conventional role;
it is responsible for registering the Service Suppliers
and the EUs; with the registration the CA also pro-
duces a certiﬁcate that contains the public component
of the key-pair.
This protocol does not request any “on-line” participation
of the CA, so it can be deﬁned as an adjudicated protocol;
evidently the CA is responsible for granting the involved
entities releasing them the necessary credentials.
The EU takes part into the scenario with two different chan-
nels: the SMS and the Web. At the beginning the EU brows-
ing on the SS web site sends the request for a speciﬁc ser-
vice. The SS receives this request, verify user qualiﬁcation
and begins to process the request. SS composes, signs and
sends an SMS message for requesting the service deliver
(SR). The signature generation process involves the SS pri-
vate key. As soon as the EU receives the signed SMS he
goes ahead with the signature veriﬁcation process using the
SS public key. EU accepts/denies the service delivery and
produces a SA (service response). The SS veriﬁes the EU
qualiﬁcation then veriﬁes the signature over the SA with the
EU public key. The SS decides if he has to deliver the re-
quested service according to the EU answer, SS prepares
a signed conﬁrmation message and ﬁnally sends a twofold
conﬁrmation. The ﬁrst conﬁrmation is published on its web-
site, the second one is sent over the SMS channel. Waiting
for the effective service delivery the EU veriﬁes the Service
Supplier signature appended to the service conﬁrmation us-
ing the Service Supplier public key.
Indirect Schema
Pros:
Cons:
– EU has only to manage one single public key
QCA.
– There is a single common accepted trusted entity:
the CA.
– CA is involved in transaction processing directly.
– Direct involvement implies that the common PKI
infrastructure and roles are invalidated.
Cons:
– The EU subsystem must be able to obtain and
manage the public keys set of all the Service Sup-
pliers.
5 Implementation
The CA performs its tasks via Web Services. The
W3C Web service deﬁnition refers to clients and servers
that communicate using XML messages that follow the
SOAP-standard [20]. The CA publishes two different list
of web services, each one for its communication partners:
the CA Administrator and the SS. The permanent storage
of information is achieved using a mysql database and
it is protected by symmetric key encryption. The SS
subsystem utilizes the signature veriﬁcation/generation
services according to the transaction schema selected, so in
the direct transaction schema these services are offered by
the SS itself, in the indirect transaction schema signature
services are exported by CA as web services.
EU subsystem details: The EU subsystem is mainly rep-
resented by a Java 2 Micro Edition application compliant
to MIDP 2.0 and CLDC 1.1 and installed on different mod-
els of Nokia mobile phones: series 40 equipped with Sym-
bian OS 8.0 (i.e.6630, 6680), series 60 2nd edition equipped
with Symbian OS 8.1 (i.e. N70), and series 60 3rd edition
equipped with Symbian OS 9.1 (i.e. N73, E70). Bouncy-
castle Crypto APIs offer support for realizing cryptographic
operations. This APIs are an open source solution, which
works with everything between J2ME and JDK 1.6 [9].
In the EU Key Generation scenario (cfr.4.1.1) the keys
QEU , dEU are generated by the resident MIDlet and the
public key is sent to generate the correspondent X.509 cer-
tiﬁcate. In particular,
1. The message built by CA to EU embeds the URL of a
X.509 MIDlet certiﬁcate;
2. The MIDlet can download the X.509 CA and the EU
certiﬁcate.
489489
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:56:46 UTC from IEEE Xplore.  Restrictions apply. 
3. The channel CA/SS has to be considered secured by
an appropriate tunnel (e.g. IPSEC,SSL-ECC) or by the
security standard provided for web services interaction
(e.g. XML ﬁrewall).
The generation process needs two different seeds: the for-
mer is represented by the activation code, the latter is cho-
sen by the user at ﬁrst application startup. The user receives
the activation code during the registration phase. Causing
the lack of the Provider support for the J2ME [23] envi-
ronment, the key generation capability is not native into the
Bouncycastle Lightweight API [9]. In order to allow to each
application in generating its own key pair the same algo-
rithm available for the J2SE environment was implemented
into the mobile component. The MIDlet according to a con-
ﬁguration parameter is able to compute either 160-bit keys,
or 192-bit keys, or 224-bit keys.
In the CA Key Generation scenario (cfr.4.1.1) we suppose
that the CA is in charge of generating the keys and distribut-
ing them to the various components. The MIDlet can be
downloaded via Over The Air (OTA) download contains:
• an AES 256-bit the ephemeral key KAES(1), whose
only purpose is to secure the transfer of the private key
dEU during the provisioning phase (we are supposing
that the EU cannot access to GPRS service, so cannot
perform a Difﬁe-Hellmann key exchange);
• the CA public key QCA.
At the time of the MIDlet activation (initiated by the user),
the CA encrypts the private key with KAES(1), obtaining
the message routed to the mobile device, e.g., via SMS.
The key advantage of symmetric encryption is that it is
computationally fast and efﬁcient. This makes symmet-
ric encryption the ideal choice for mobile devices. Other-
wise, the key disadvantages of symmetric encryption are
the need to pre-share the keys among the senders and re-
cipients and the keys must be exchanged securely via some
trusted communications channel or through some key ex-
change mechanisms. At SMS message delivery, the res-
ident MIDlet decodes KAES(1) [dEU ] and auto-activates
to the CA the client, requesting a PIN code, so that
PIN: KAES(2)=HMAC[rnd,PIN]. The new generated key
KAES(2) will be used to encrypt the private key dEU once
stored in the ﬁle system. Moreover, the private key will be
in the cleartext exclusively when used to sign a SMS mes-
sage, otherwise it will stay permanently encrypted, stored
in the ﬁlesystem as KAES(2)[dEU ]. The key KAES(2) de-
pends on a PIN factor, which is not stored anywhere in the
ﬁlesystem: the only possible attack for this is to build an ad-
hoc Rainbow table, easily overcome by salting mechanisms.
This system performs strong encryption on the private key:
dEU , whose length is 195 byte (p = 192, in Fp), will be en-
crypted with a 256-bit AES key. Alternative storage strate-
gies include the private key storage on an external memory
(e.g. SD) so that the key can be used only when needed.
Finally, in this scenario, the Trusted-SMS framework mo-
bile component was delivered to the EU in a package that
contained also the EU key-pair. As previously examined,
the symmetric encryption scheme protects the private com-
ponent of the key pairs; the symmetric key of that scheme
was then injected into the code. Since the key KAES(1)
is one-time and no one secret relies on it after the genera-
tion of KAES(2), the only security countermeasure of this
solution relies on the code obfuscation provided by a free
Java class ﬁle shrinker, optimizer, obfuscator, and preveri-
ﬁer (Proguard).
6 Security considerations
Developing secure J2ME applications is difﬁcult due to
limitations in the J2ME security model as well as bugs in
real devices. A proper security analysis and testing of real
devices must be carried out to determine the level of secu-
rity that can be achieved.
Midlet. Our MIDlet is designed to be a multithreading ap-
plication. A program’s execution ﬂow is event-driven, so
the main thread is idle and ready to handle events. Time-
consuming operations such as lengthy calculations or net-
work communication occur in separate threads to retain a
responsive user interface. Encryption is a computation in-
tensive task, and when implemented in Java it can be time
consuming because low-level optimizations such as those
for CPU architecture are impossible. The speed and efﬁ-
ciency of the encryption operation has a direct impact on the
usability of the system. Saltzer and Schroeder [18] wrote
about psychological acceptability as one of the security de-
sign principles. Security solutions that are implemented
must be usable and as transparent as possible to the user.
In the case of SMS signature, the users are used to a nom-
inal time required to send an SMS message, typically less
than 10 seconds to receive a Message sent reply from the
SMSC. If the encryption slows down the sending process
signiﬁcantly, the users will be frustrated and may choose to
disable the encryption.
Stolen Midlets. On some devices it is possible to install a
ﬁle system explorer (e.g. the FExplorer software [13] ), in
order to transfer MIDlet JAD and JAR ﬁles to a second de-
vice, navigating through the ﬁles and MIDlets installed on
the device and sending those ﬁles to another device via the
Bluetooth technology. It is important to note that transfer-
ring is not possible for DRM (Digital Right Management)
protected MIDlets (protection should be at least by the for-
ward lock mode [28]). In addition MIDP 1.0 and 2.0 does
not natively support encrypted storage, making it vulnera-
ble to the same hardware attacks. Indeed, rms.db ﬁle that
490490
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:56:46 UTC from IEEE Xplore.  Restrictions apply. 
holds all MIDlet persistent data is located in the same loca-
tion as JAD and JAR ﬁles and can be transferred following
the same steps. Moreover, the DRM issue is no more valid
for rms.db. That is, even if the MIDlet is DRM protected
the rms.db can be transferred because the DRM protection
holds only for JAR ﬁles [28]. This may have a serious im-
pact on the privacy of the MIDlet since it is possible to tam-
per with its persistent data.
Key storage and randomness Thus, J2ME’s storage sys-
tem cannot be trusted with sensitive data unless the appli-
cation itself secures the data. Using cryptographic libraries
is a partial solution. However, the availability of crypto-
graphic APIs does not automatically solve the plaintext stor-
age problem. Trusted-SMS protects data stored on the RMS
using Advanced Encryption Standard (AES) as symmetric
key algorithm. Data consistency is achieved storing in a
permanent way data as soon as possible; adopting a write-
through like mechanism for addressing the need of a strong
consistency impacts on the system performance. However
this solution prevents either the accidental power down re-
lated to battery empty and the system crash related to po-
tential Denial of Service attacks. Another important issue
is the lack of sources of randomness in J2ME implementa-
tions. A strong cipher can be used, but the encryption key
must be impossible to guess. MIDP 2.0 does not provide a
cryptographically strong pseudorandom number generator
similar to SecureRandom in J2SE. In order to avoid secu-
rity weakness related to this, J2ME relies on a strong mech-
anism for determining the seeds of the user keys. That seed
is derived using the conjunction of two factors: a timestamp
information, that enforce the randomness of the keypair
and the user Mobile Subscriber Integrated Services Digital
Network Number (MSISDN) information, which enforces
the uniqueness of the keypair. The development of a MI-
Dlet using a speciﬁc version of the Bouncycastle crypto-
graphic library implies the deﬁnition of some classes inside
the system package as java.math.BigInteger. Java prevents
the deﬁnition of classes into the system package throwing
a run time exception java.lang.NoClassDefFoundError that
blocks the execution of the application.
On obfuscators. An obfuscator can rename the classes so
they will not be in the restricted namespace. Moreover in
recent years, code obfuscation has attracted some attention
as a low cost approach to worsen the code readability, em-
ploying the security through obscurity paradigm ([36], [10],
[11], [33], [12]). The goal of code obfuscation is to make
difﬁcult for an attacker to reverse engineer a program. Ob-
fuscation attempts to transform a program into an equiva-
lent one that is harder to reverse engineer but that program
is not tamper-proof. Tamper-prooﬁng causes a program to
malfunction when it detects that it has been modiﬁed, but
these technologies are not mature and widespread yet for
mobile environments.
7 Performance
The system belongs to the distributed (holistic) system
class; in this class of systems the performance of each por-
tion contribute to the performance of the overall system.
Trusted-SMS belongs to the class of the non homogeneous
distributed systems; in this class the system components
strongly differ in terms of computing and memory. The
system performance problem was widely explored for the
full featured environments (e.g. servers); indeed the same
problem has a little literature for the mobile environments.
The main performance issues that have to be evaluated for
mobile environments are: battery consumption, execution
speed, jar ﬁle size (download costs, memory occupation...),
and (usability through) perceived performance (user inter-
face responsiveness).
Battery Consumption The results in [29] can be applied
to Trusted-SMS framework;
table 1, which summarized
that results, compares the energy consumed by the three
federal information processing standard (FIPS)-approved
asymmetric algorithm for generating and verifying signa-
ture in security protocols: RSA, DSA, and ECDSA. The
energy value are reported for the three main steps associated
with digital signature algorithms: key generation, signature
generation, and signature veriﬁcation. The basic mathemat-
ical operation in RSA, DSA, and DH is modular exponen-
tiation, while point multiplication on elliptic curves forms
the core arithmetic operation in ECDSA and ECDH. We
can see that 163-bit ECDSA is energy-efﬁcient compared
to 1024-bit DSA. However, 163-bit ECDSA and 1024-bit
RSA digital signature algorithms have complementary en-
ergy costs. RSA performs signature veriﬁcation efﬁciently,
while ECDSA imposes a smaller cost for signature gener-
ation. We can see that the energy costs of sign and verify
are much more symmetric in ECDSA than in RSA. ECDSA
uses point multiplication for both sign and verify operation.
The huge discrepancy in the energy costs of sign and verify
operations in RSA results from the signiﬁcant difference in
the size of the keys employed (which are used as exponents
in modular exponentiation operation).
Execution speed The execution speed depends on many
factors; careful design and algorithm choice yield greater
beneﬁts than line-by-line code optimizations. This is as true
of MIDlets as it is of other programs, and it is easy to slow
your MIDlet by making careless design choices. Java pro-
grams usually spend a small part of their time executing pro-
491491
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:56:46 UTC from IEEE Xplore.  Restrictions apply. 
Table 1. DSA’s energy costs comparison
Algorithm KeySize Key Generation
RSA
DSA
ECDSA
ECDSA
ECDSA
ECDSA
ECDSA
(bits)
1024
1024
163
192
233
283
409
(mJ)
270.13
293.20
226.65
281.65