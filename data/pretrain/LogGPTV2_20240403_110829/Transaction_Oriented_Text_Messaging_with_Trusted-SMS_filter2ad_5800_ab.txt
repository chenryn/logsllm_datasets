### Key Concepts

1. **Service Supplier (SS):** The Service Supplier does not possess any secret key. The SS's signature services rely on the secrets owned by the Certificate Authority (CA).

2. **Certificate Authority (CA):** The CA owns a key-pair, which is used to fulfill the Service Supplier's requests for signing SMS content. Additionally, the CA maintains a list of EU public keys to verify signatures received by the Service Supplier via SMS.

3. **Indirect Schema:** This transaction requires the "online" participation of the CA, making it an arbitrated protocol. The End User (EU) interacts with the SS through two channels: SMS and the Web. Initially, the EU sends a service request via the SS's website. The SS records this request in its database and generates a Service Response (SR). The SS then involves the CA for the signature generation process. To ensure the privacy of the SMS content, a digest (SHA1) of the actual content is generated. The CA verifies if the EU is authorized to send the service request and generates a signature for the digest using its private key. The SS encapsulates the text and the CA's signature (ΣCA) into an SMS and sends it to the EU. The SS again involves the CA to verify the EU's signature appended to the Service Acknowledgment (SA). If the signature is valid, the CA produces a Service Confirmation (SC), and the SS delivers the requested service, providing confirmation both on its website and via SMS.

4. **Direct Transaction Schema (SS-Centric):** In this schema, each EU and Service Supplier must have a key-pair. The distribution of key pairs to end users follows a specific provisioning scenario. Each EU also has a list of public keys of the Service Suppliers they interact with. The Service Supplier uses its private key to sign SMS messages sent to EUs. This protocol does not require the CA's "online" participation, making it an adjudicated protocol. The CA's role is limited to registering Service Suppliers and EUs and issuing certificates containing the public component of their key-pairs.

   - **Pros:**
     - Preserves the common PKI infrastructure and roles.
     - The CA is not involved in the EU and SS interactions, ensuring the privacy of transactions.
   - **Cons:**
     - The EU subsystem must manage the public keys of all Service Suppliers.
     - All transactions converge to a single point of failure, which can be a bottleneck or a target for DoS attacks.

### Implementation

The CA performs its tasks using Web Services, adhering to the W3C Web service definition, which involves communication using XML messages following the SOAP standard. The CA publishes two lists of web services for its communication partners: the CA Administrator and the SS. Information is stored permanently in a MySQL database, protected by symmetric key encryption. The SS subsystem uses signature verification/generation services based on the selected transaction schema. In the direct transaction schema, these services are provided by the SS, while in the indirect transaction schema, they are exported by the CA as web services.

#### EU Subsystem Details

The EU subsystem is primarily represented by a Java 2 Micro Edition (J2ME) application compliant with MIDP 2.0 and CLDC 1.1, installed on various Nokia mobile phones. BouncyCastle Crypto APIs support cryptographic operations, offering an open-source solution compatible with J2ME and JDK 1.6.

- **Key Generation Scenario:**
  - The EU's key pair (QEU, dEU) is generated by the resident MIDlet, and the public key is sent to generate the corresponding X.509 certificate.
  - The CA sends a message to the EU containing the URL of the X.509 MIDlet certificate.
  - The MIDlet can download the X.509 CA and EU certificates.
  - The CA/SS channel is secured using appropriate tunnels (e.g., IPSEC, SSL-ECC) or security standards for web services interaction (e.g., XML firewall).

- **Key Generation Process:**
  - Two seeds are required: the activation code and a user-chosen seed at the first application startup.
  - The activation code is received during the registration phase.
  - Due to the lack of provider support for J2ME, the key generation capability is implemented within the mobile component.
  - The MIDlet can compute 160-bit, 192-bit, or 224-bit keys based on a configuration parameter.

- **CA Key Generation Scenario:**
  - The CA generates the keys and distributes them to the components.
  - The MIDlet, downloaded via Over The Air (OTA), contains:
    - An AES 256-bit ephemeral key (KAES(1)) to secure the transfer of the private key (dEU) during the provisioning phase.
    - The CA's public key (QCA).
  - At MIDlet activation, the CA encrypts the private key with KAES(1) and sends it to the mobile device via SMS.
  - Symmetric encryption is used for its computational efficiency, but it requires pre-sharing keys securely.
  - The resident MIDlet decodes KAES(1)[dEU] and requests a PIN from the user to generate a new key (KAES(2)).
  - KAES(2) is used to encrypt the private key (dEU) stored in the file system, ensuring it remains encrypted except when used for signing.

### Security Considerations

Developing secure J2ME applications is challenging due to limitations in the J2ME security model and potential bugs in real devices. Proper security analysis and testing are essential to determine the achievable level of security.

- **Midlet Design:**
  - The MIDlet is designed as a multithreading application with an event-driven execution flow.
  - Time-consuming operations, such as encryption, are performed in separate threads to maintain a responsive user interface.
  - Encryption speed and efficiency are critical for usability, as delays can frustrate users and lead to disabling encryption.

- **Stolen Midlets:**
  - On some devices, it is possible to install a file system explorer to transfer MIDlet JAD and JAR files, potentially exposing persistent data.
  - DRM protection does not cover the rms.db file, which holds all MIDlet persistent data, making it vulnerable to tampering.

- **Key Storage and Randomness:**
  - J2ME’s storage system cannot be trusted with sensitive data unless the application secures it.
  - Trusted-SMS protects data stored on the RMS using AES.
  - Data consistency is achieved through a write-through mechanism, preventing accidental power down and DoS attacks.
  - A strong mechanism for determining the seeds of user keys is used, combining timestamp information and MSISDN to ensure randomness and uniqueness.

- **Obfuscators:**
  - Code obfuscation is used to worsen code readability and make reverse engineering more difficult.
  - Obfuscation does not make the program tamper-proof, but it can deter casual attackers.

### Performance

Trusted-SMS belongs to the class of non-homogeneous distributed systems, where components differ in computing and memory capabilities.

- **Battery Consumption:**
  - ECDSA is energy-efficient compared to DSA, especially for 163-bit keys.
  - RSA is efficient for signature verification, while ECDSA is more balanced in terms of energy costs for both signing and verifying.

- **Execution Speed:**
  - Careful design and algorithm choice are crucial for performance.
  - Java programs typically spend a small part of their time executing procedural code, so optimizing design choices is more beneficial than line-by-line optimizations.

This comprehensive overview provides a clear and professional description of the key concepts, implementation details, security considerations, and performance aspects of the Trusted-SMS framework.