Object(8(
Object(list(head(1(
Object(list(head(2(
NULL(
•  Core(1(just(exhausted(the(linked(list(
node(slab(heap(
•  Core(0(sees(a(change(on(the(NULL(page(
•  Core(0(calls(svcSignalEvent(to(free(a(
bunch(of(linked(list(nodes(
•  Next(allocations(use(the(free(nodes(as(
intended(
(
Just-in-time node freeing 
nextptr$$prevptr$$objptr$$$00000000$
just(became(
00000000$00000000$00000000$00000000$
Free(object(
Free(object(
Free(object(
Free(object(
Object(1(
Free(list(head(
Linked list unlinking 
•  When(the(NULL(node(is(unlinked,(
we(control(node->next(and(node-
>prev(
=>(We(can(write(an(arbitrary(value(to(
an(arbitrary(location(
•  Has(to(be(a(writable"pointer(value…(
•  But(what(to(overwrite?(
•  vtable(is(used(immediately(after(
unlinking(for(an(indirect(call…(
•  Difficulties(
•  free_kobj(kernel(panics(on(NULL(
•  Unlinking(writes(to(our(target(and(our(
value(–(so(writing(a(code(address(is(
annoying(
How do we get code execution? 
KLinkedList::remove:$
...$
$
KLinkedListNode$*next$=$node->next;$
KLinkedListNode$*prev$=$node->prev;$
next->prev$=$prev;$
prev->next$=$next;$
node->next$=$0;$
node->prev$=$0;$
$
...$
...$
$
KLinkedList::remove(...);$
free_kobj(&freelist_listnodes,$node);$
((int(*)(_DWORD,$_DWORD))(vtable[9]))(...);$
$
...$
RWX NULL page linked list nodes 
•  Node"0"
•  Next:(node(1(
•  Prev:(irrelevant((unused)(
•  Element:(fake(object(that(won’t(
trigger(unlinking(
•  Node"1"
•  Next:(node(2(
•  Prev:(address(of(target(vtable(slot(
•  Element:(fake(object(that(will(trigger(
unlinking(
•  Node"2"
•  Next:(“ldr$pc,$[pc]”(
•  Prev:(irrelevant((unlink(overwrites(it)(
•  Element:(address(loaded(by(“ldr$pc,$
[pc]”(
Manufacturing the linked list 
00000040$C0C0C0C0$00000800$00000000$
00000000$00000000$00000000$00000000$
00000000$00000000$00000000$00000000$
00000000$00000000$00000000$00000000$
00000080$DFFEC6B0$00000C00$00000000$
00000000$00000000$00000000$00000000$
00000000$00000000$00000000$00000000$
00000000$00000000$00000000$00000000$
E59FF000$DEADBABE$00101678$00000000$
00000000$00000000$00000000$00000000$
00000000$00000000$00000000$00000000$
00000000$00000000$00000000$00000000$
00000000"
00000010"
00000020"
00000030"
00000040"
00000050"
00000060"
00000070"
00000080"
00000090"
000000A0"
000000B0"
Node"1"
Node"2"
Node"0"
ARM11 Kernel 
Home Menu 
loader 
fs 
GSP 
ldr:ro 
System calls 
APPLICATION memory region 
SYSTEM memory region 
BASE memory region 
mcopy 
ARM11 kernel compromised, and therefore all ARM11 processes as well 
Taking over the ARM9 
Because nothing’s ever enough with you people 
Memory 
CPUs 
Devices 
ARM9(
ARM11(
FCRAM(
WRAM(
VRAM(
ARM9(
internal(
GPU(
CRYPTO(
NAND(
What’s compromised so far 
ARM9 responsibilities 
•  Brokers(access(to(storage((SD,(NAND…)(
•  Includes(title(management((installing,(updating…)(
•  Decrypts(and(verifies/authenticates(content(
•  Owning(ARM11(is(enough(to(run(pirated(content,(but(not(to(decrypt(new(
content(if(an(update(is(released(
•  Handles(backwards(compatibility(
•  How(does(that(work?(
AGB_FIRM(
-  AGB(=(GBA(codename(
-  Used(to(run(GBA(
software(
-  “Safe(mode”(FIRM(
-  Used(to(do(firmware(
updates(
SAFE_FIRM(
-  Main(FIRM(
-  Runs(apps(and(games(
-  3DS(boots(it(by(default(
TWL_FIRM(
-  TWL(=(DSi(codename(
-  Used(to(run(DS(and(
DSi(software(
The 3DS’s “FIRM” firmware system 
NATIVE_FIRM(
Memory 
CPUs 
Devices 
GPU(
CRYPTO(
FIRM launch: ARM9 loads FIRM from NAND 
ARM9(
ARM9(
internal(
NAND(
ARM11(
FCRAM(
WRAM(
VRAM(
Memory 
CPUs 
Devices 
GPU(
FIRM launch: ARM9 uses CRYPTO hardware to decrypt and authenticate FIRM 
ARM9(
ARM9(
internal(
NAND(
CRYPTO(
ARM11(
FCRAM(
WRAM(
VRAM(
Memory 
CPUs 
Devices 
GPU(
FIRM launch: ARM9 copies sections to relevant locations 
ARM9(
internal(
NAND(
CRYPTO(
ARM9(
ARM11(
FCRAM(
WRAM(
VRAM(
Memory 
CPUs 
Devices 
ARM11(
FCRAM(
WRAM(
VRAM(
GPU(
FIRM launch: ARM9 signals ARM11 to run its FIRM section and then runs its own 
ARM9(
internal(
NAND(
CRYPTO(
ARM9(
Memory 
CPUs 
Devices 
ARM11(
FCRAM(
WRAM(
VRAM(
GPU(
FIRM launch: a compromised ARM11 can just keep running its own code 
ARM9(
internal(
NAND(
CRYPTO(
ARM9(
Memory 
CPUs 
Devices 
ARM11(
FCRAM(
WRAM(
VRAM(
GPU(
TWL_FIRM 
ARM9(
internal(
NAND(
CRYPTO(
ARM9(
Runs(menu,(performs(some(rendering(tasks(((
Loads(and(verifies(ROM,(sets(up(backwards(compatibility(hardware(then(serves(as(DS(CPU(
Serves(as(DS’s(main(
RAM(
Contains(ARM11(code(
Where do ROMs come from? 
•  TWL_FIRM(can(load(ROMs(from(multiple(sources(
•  Gamecarts((physical(games)(
•  NAND((DSiWare)(
•  ARM11((…?)(
•  ROMs(are(authenticated(before(being(parsed(
•  DSi(games(are(RSA(signed(
•  DS(games(weren’t(signed(so(a(their(content(is(hashed(and(a(whitelist(is(used(
•  This(should(be(fine…(
•  But(for(some(reason,(those(checks(are(bypassed(when(the(ROM(comes(from(
the(ARM11(
DS mode memory layout 
3DS_PA$=$(NDS_PA$-$0x02000000)$*$4$+$0x20000000$$
8(bytes(of(3DS(address(space(==(2(bytes(of(DS(space(
If(NDS_PA(isn’t(properly(bounded,(then(any(3DS_PA(value(is(
possible…(
Header"Overview$
$$Address$Bytes$Expl.$
$$000h$$$$12$$$$Game$Title$$(Uppercase$ASCII,$padded$with$00h)$
$$00Ch$$$$4$$$$$Gamecode$$$$(Uppercase$ASCII,$NTR-)$$$$$$$$(0=homebrew)$
$$010h$$$$2$$$$$Makercode$$$(Uppercase$ASCII,$eg.$"01"=Nintendo)$(0=homebrew)$
$$012h$$$$1$$$$$Unitcode$$$$(00h=Nintendo$DS)$
$$013h$$$$1$$$$$Encryption$Seed$Select$(00..07h,$usually$00h)$
$$014h$$$$1$$$$$Devicecapacity$$$$$$$$$(Chipsize$=$128KB$SHL$nn)$(eg.$7$=$16MB)$
$$015h$$$$9$$$$$Reserved$$$$$$$$$$$(zero$filled)$
$$01Eh$$$$1$$$$$ROM$Version$$$$$$$$(usually$00h)$
$$01Fh$$$$1$$$$$Autostart$(Bit2:$Skip$"Press$Button"$after$Health$and$Safety)$
$$$$$$$$$$$$$$$$(Also$skips$bootmenu,$even$in$Manual$mode$&$even$Start$pressed)$
$$020h$$$$4$$$$$ARM9$rom_offset$$$$(4000h$and$up,$align$1000h)$
$$024h$$$$4$$$$$ARM9$entry_address$(2000000h..23BFE00h)$
$$028h$$$$4$$$$$ARM9$ram_address$$$(2000000h..23BFE00h)$
$$02Ch$$$$4$$$$$ARM9$size$$$$$$$$$$(max$3BFE00h)$(3839.5KB)$
$$030h$$$$4$$$$$ARM7$rom_offset$$$$(8000h$and$up)$
$$034h$$$$4$$$$$ARM7$entry_address$(2000000h..23BFE00h,$or$37F8000h..3807E00h)$
$$038h$$$$4$$$$$ARM7$ram_address$$$(2000000h..23BFE00h,$or$37F8000h..3807E00h)$
$$03Ch$$$$4$$$$$ARM7$size$$$$$$$$$$(max$3BFE00h,$or$FE00h)$(3839.5KB,$63.5KB)$
$$...$
DS ROM header format (credit: gbatek https://problemkaputt.de/gbatek.htm) 
TWL_FIRM ROM loader code section checks 
•  section_ram_address$>=$0x02000000$
•  section_ram_address$+$section_size$=$0x02000000$
•  0xBC01B98D$+$0x43FE4673$=$0$$0x023FF000$
•  section$doesn't$intersect$with$[0x03FFF600;$0x03FFF800]$
•  Because$0xBC01B98D$>$0x03FFF800$
What if we want to write to 0x0806E634? 
Example(values:(
•  section_ram_address$=$0xBC01B98D$
•  section_size$=$0x43FE4673$
•  (0xBC01B98D$-$0x02000000)$*$4$+$0x20000000$=$0x0806E634$
What about the huge section size ? 
ROM section loading code 
•  We(have(section_size(=(0x43FE4673(
•  (0x43FE4673(bytes(is(about(1GB(of(data(
•  =>(we(will(crash(if(we(can’t(interrupt(the(
copy(while(it’s(happening…(
•  Fortunately,(load_nds_section(copies(in(
blocks(of(0x10000(bytes(at(most(
void$load_nds_section(u32$ram_address,$u32$rom_offset,$u32$size,$...)$
{$
$$...$
$
$$u32$rom_endoffset$=$rom_offset$+$size;$
$$u32$rom_offset_cursor$=$rom_offset;$
$$u32$ndsram_cursor$=$ram_address;$
$
$$while$($rom_offset_cursor$<$rom_endoffset$)$
$${$
$$$$curblock_size$=$0x10000;$
$$$$if$($rom_endoffset$-$rom_offset_cursor$<$curblock_size$)$
$$$${$
$$$$$$curblock_size$=$align32(rom_endoffset$-$rom_offset_cursor);$
$$$$}$
$
$$$$memcpy(buf,$rom_offset_cursor$+$0x27C00000,$curblock_size);$
$
$$$$...$
$
$$$$write_ndsram_section(ndsram_cursor,$buf,$curblock_size);$
$
$$$$rom_offset_cursor$+=$curblock_size;$
$$$$ndsram_cursor$+=$curblock_size;$
$$}$
$
$$...$
}$
$
$
Performs(the(actual(copy(–(
can(hijack(its(return(address(
TWL_FIRM’s “weird” memcpy 
void$write_ndsram_section(u32$ndsram_dst,$u16*$src,$int$len)$
{$
$$u16*$ctr_pa_dst$=$convert_ndsram_to_ctrpa(ndsram_dst);$
$
$$for(int$i$=$len;$i$!=$0;$i$-=$2)$
$${$
$$$$*ctr_pa_dst$=$*src;$
$
$$$$ctr_pa_dst$+=$4;$
$$$$src$+=$4;$
$$}$
}$
Copies(2(bytes(at(a(time…(
…every(8(bytes(
Corrupting the stack 
08032F41$
00000000$
080C0000$
C0180000$
08033851$
00000000$
00010000$
0806E66C$
00000001$
00010000$
0808922C$
00010000$
08089E64$
0808923C
0803DCDC$
0806E634"
0806E638"
0806E63C"
0806E640"
0806E644"
0806E648"
0806E64C"
0806E650"
0806E654"
0806E658"
0806E65C"
0806E660"
0806E664"
0806E668"
0806E66C"
write_ndsram_section(return(address(
load_nds_section stack 
Value 
Address 
Bytes(we(can(overwrite(
⇒ We(can(only(redirect(to(a(gadget(within(
a(0x10000(byte(region(
⇒ We(can(only(generate(addresses(within(
0x10000(byte(regions(determined(by(
pointers(already(on(the(stack(
Corrupting the stack 
08035512$
00000000$
080C0000$
C0180000$
08033851$
00000000$
00010000$
0806E66C$
00000001$
00010000$
08089064$
00010000$
08089E64$
0808923c
0803DCDC$
0806E634"
0806E638"
0806E63C"
0806E640"
0806E644"
0806E648"
0806E64C"
0806E650"
0806E654"
0806E658"
0806E65C"
0806E660"
0806E664"
0806E668"
0806E66C"
Value 
Address 
ADD$SP,$SP,$#0x14$
POP${R4-R7,PC}$
ADD$SP,$SP,$#0x14(
POP${R4-R7}(
Points(to(code(in(the(NDS(ROM(header(
(Process9(doesn’t(have(DEP)(
load_nds_section stack 
Memory 
CPUs 
Devices 
ARM9(
ARM11(
FCRAM(
WRAM(
VRAM(
ARM9(
internal(
GPU(
CRYPTO(
NAND(
ARM9 down J 
Thanks to: 
derrek, nedwill, yellows8, plutoo, naehrwert 
@smealum(
Code available at github.com/smealum 
Icon credits 
•  https://www.webdesignerdepot.com/2017/07/free-download-flat-
nintendo-icons/(
•  https://www.flaticon.com/free-icon/gaming_771247(
•  https://www.flaticon.com/free-icon/checked_291201(
•  https://www.flaticon.com/free-icon/close_579006(
•  https://www.flaticon.com/free-icon/twitter_174876(