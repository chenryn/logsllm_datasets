Table 2: Partitioning results for SPECCPU 2006 benchmarks (use a random global as sensitive variable).
Sensitive
data and type
LBM_Grid* srcGrid
struct quantum_reg* lambda
char* progName
char* realholdings
double[] path_coeff
char** liveargs
int ser_randseed
int[] FirstMBInSlice
# of functions/
sensitive functions
19/5
115/3
100/6
144/5
235/2
369/3
538/7
590/5
lbm
1,156
libquantum 4,358
bzip2
8,393
13,547
sjeng
15,042
milc
25,090
sphinx3
hmmer
35,992
h264ref
51,578
Average
PBT
overhead
141.4%
282.3%
59.4%
41.7%
111%
90.5%
128.5%
234.4%
136.2%
Total/BR
pointers
695/131
1690/128
4356/8
3415/81
5001/0
9491/37
17692/175
32212/461
SPBT
overhead
19.7%
11.2%
3.1%
3.4%
0%
5.1%
5.8%
9.6%
7.2%
Table 3: The random partitioning results for SPECCPU 2006 benchmarks.
Benchmark Average BR-pointer ratio Average SPBT overhead Average total overhead
lbm
14.3%
libquantum 16.2%
12.4%
bzip2
15.2%
sjeng
milc
10.7%
8.7%
sphinx
8.8%
hmmer
9.1%
h264ref
Average
11.8%
55.1%
163.3%
71.3%
63.9%
83.2%
37.5%
89.7%
101.9%
79.3%
15.4%
51.5%
16.4%
14.1%
23.4%
17.9%
29.8%
38.4%
29.4%
A second straightforward improvement of the partitioning algo-
rithm is to produce partitions that balance between security and
performance. A program profiling tool can be used to profile the
frequency of function calls and size of data sent over function calls;
such performance numbers can be used to annotate PDG edges.
Then an algorithm such as the one used by ProgramCutter [32]
can be used to produce a partitioning that takes into account of
both security and performance. Another interesting direction is to
target specific application domains. For instance, OS developers
have long been interested in privilege separating kernel code and
there had been manual privilege separation effort [13]; similarly,
there is a need to partition legacy applications to be compatible
with a trusted execution environment such as Intel’s SGX. Finally,
extending the support to C++ applications requires extending our
type-based marshalling and unmarshalling to cover more types
including C++ classes.
PtrSplit automatically partitions single threaded code and it will
be a technical challenge to extend it to cover multi-threaded code.
One issue with multi-threading is that the computation of data de-
pendence is more complex, because of shared data between threads.
Furthermore, the mechanism of deep copying pointer data naturally
leads to a sequential execution model: pointer data is copied in at
the beginning of an RPC call and copied out at the end. For a multi-
threaded application, one thread can perform an RPC call, which
leads to a copy of the passed pointer data; without synchronization,
a second thread can modify the original pointer data, while the
callee can separately modify its own copy. Proper synchronization
12
code needs to be generated for pointer data, while not sacrificing
too much performance.
PtrSplit also makes assumptions about how types are used in
order for partitioned applications to function correctly. We men-
tioned before that PtrSplit’s computation of call edges in PDGs
assumes the lack of certain type casts on function-pointer types.
Another assumption is that pointers can be identified through the
types of cross-partition data. This assumption may be violated by
type casts. As an example, suppose an application casts the type
of a struct pointer to a void pointer. For bounds tracking, LLVM
treats a void pointer as an i8* pointer (pointer to bytes) and Soft-
Bound can track its bounds. As a result, a void pointer across the
boundary is marshalled as a byte array. This is problematic when
the original struct contains other pointers as they are hidden from
the type-based marshalling process. Therefore, PtrSplit currently
assumes void pointers do not appear at the boundary and raises
an alarm when such a situation occurs. We did not encounter this
case in our experiments. An alternative design would be to add run-
time type information (RTTI) for data pointers and use the runtime
types for marshaling and unmarshalling. As a side note, PtrSplit’s
PDG-construction builds on DSA alias analysis, which can handle
type casts when calculating aliases; so dependence edges are not
missed in PDGs because of type casts.
PtrSplit can be further optimized by using more efficient pointer
bounds tracking tools to reduce the overhead. Recent work such
as Low-Fat Pointers [14, 15] and CUP [6] seem to provide general
pointer tracking with lower overhead than SoftBound, while still
maintaining the Application Binary Interface (ABI). Unfortunately,
Session K3:  Program AnalysisCCS’17, October 30-November 3, 2017, Dallas, TX, USA2370these systems are not yet open sourced. When they are available,
we wish to combine our SPBT approach and these state-of-the-art
bounds tracking techniques to make PtrSplit more efficient.
9 CONCLUSIONS
Automatic partitioning security-critical applications is an effective
way of improving software security. It is important to support the
automatic partitioning of C/C++ applications given their lack of
memory safety and that trusted execution environments including
SGX and TrustZone can run only native code; managed code such as
Java bytecode cannot run directly inside SGX without first porting
the whole language virtual machine into an SGX enclave. In this
paper, we describe several techniques that support general pointers
in C/C++ applications, including parameter trees, selective pointer
bounds tracking, and type-based marshalling/unmarshalling. These
techniques push forward the state-of-the-art of privilege separating
C/C++ applications and experiments suggest they have the potential
of making automatic program partitioning practical.
10 ACKNOWLEDGMENTS
We thank anonymous reviewers for their insightful comments,
which helped us substantially improve the paper. This research is
based upon work supported by US NSF grants CNS-1624126 and
CNS-1408880. The research was also supported in part by NSF grant
CCF-1624124 and the Defense Advanced Research Projects Agency
(DARPA) under agreement number N66001-13-2-4040. The views
and conclusions contained herein are those of the authors and
should not be interpreted as necessarily representing the official
policies or endorsements, either expressed or implied, of any of the
above organizations or any person connected with them.
REFERENCES
[1] Adam Barth, Collin Jackson, Charles Reis, and Google Chrome. 2008. The security
architecture of the Chromium browser. Technical Report.
[2] David M. Beazley. 1997. SWIG Users Manual: Version 1.1.
[3] Andrea Bittau, Petr Marchenko, Mark Handley, and Brad Karp. 2008. Wedge:
splitting applications into reduced-privilege compartments. In Proceedings of
the 5th USENIX Symposium on Networked Systems Design and Implementation.
309–322.
[4] Don Box. 1997. Essential COM. Addison-Wesley Professional.
[5] David Brumley and Dawn Song. 2004. Privtrans: Automatically Partitioning
Programs for Privilege Separation. In 13th Usenix Security Symposium. 57–72.
[6] Nathan Burow, Derrick McKee, Scott A. Carr, and Mathias Payer. 2017. CUP:
Comprehensive User-Space Protection for C/C++. (2017). https://arxiv.org/abs/
1704.05004v1.
[7] Stephen Chong, Jed Liu, Andrew Myers, Xin Qi, K. Vikram, Lantian Zheng, and
Xin Zheng. 2007. Secure Web Applications via Automatic Partitioning. In ACM
SIGOPS Symposium on Operating Systems Principles (SOSP). 31–44.
[8] John Criswell, Andrew Lenharth, Dinakar Dhurjati, and Vikram Adve. 2007. Se-
cure virtual architecture: a safe execution environment for commodity operating
systems. SIGOPS Oper. Syst. Rev. 41 (Oct. 2007), 351–366. Issue 6.
[9] Dinakar Dhurjati and Vikram S. Adve. 2006. Backwards-compatible array bounds
checking for C with very low overhead. In ICSE. 162–171.
[10] Petros Efstathopoulos, Maxwell Krohn, Steve Vandebogart, Cliff Frey, David
Ziegler, Eddie Kohler, David Mazières, M. Frans Kaashoek, and Robert Morris.
2005. Labels and event processes in the Asbestos operating system. In ACM
SIGOPS Symposium on Operating Systems Principles (SOSP). 17–30.
[11] Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. 1987. The Program De-
pendence Graph and its Use in Optimization. ACM Transactions on Programming
13
Languages and Systems 9, 3 (July 1987), 319–349.
[12] Google Inc. GRPC: A high performance, open-source universal RPC framework.
Google Inc. http://www.grpc.io.
[13] Charles Jacobsen, Muktesh Khole, Sarah Spall, Scotty Bauer, and Anton Burtsev.
2016. Lightweight Capability Domains: Towards Decomposing the Linux Kernel.
SIGOPS Oper. Syst. Rev. 49, 2 (Jan. 2016), 44–50.
[14] Gregory J.Duck and Roland H.C. Yap. 2016. Heap Bounds Protection with Low
Fat Pointers. In CC.
[15] Gregory J.Duck, Roland H. C. Yap, and Lorenzo Cavallaro. 2017. Stack Bounds
Protection with Low Fat Pointers. In NDSS.
[16] Douglas Kilpatrick. 2003. Privman: A library for partitioning applications. In
USENIX Annual Technical Conference, FREENIX track. 273–284.
[17] Maxwell Krohn, Alexander Yip, Micah Brodsky, Natan Cliffer, M. Frans Kaashoek,
Eddie Kohler, and Robert Morris. 2007. Information flow control for standard OS
abstractions. In ACM SIGOPS Symposium on Operating Systems Principles (SOSP).
321–334.
[18] C. Lattner, A. Lanharth, and V. Adve. 2007. Making context-sensitive points-to
analysis with heap cloning practical for the real world. In ACM Conference on
Programming Language Design and Implementation (PLDI). 278–289.
[19] D. Liang and M. J. Harrold. 1998. Slicing objects using system dependence graphs.
In ICSM. 358–367.
[20] Joshua Lind, Christian Priebe, Divya Muthukumaran, Dan O’Keeffe, Pierre-Louis
Aublin, Florian Kelbert, Tobias Reiher, David Goltzsche, David M. Eyers, Rüdiger
Kapitza, Christof Fetzer, and Peter R. Pietzuch. 2017. Glamdring: Automatic
Application Partitioning for Intel SGX. In USENIX Annual Technical Conference
(ATC). 285–298.
[21] Yutao Liu, Tianyu Zhou, Kexin Chen, Haibo Chen, and Yubin Xia. 2015. Thwarting
Memory Disclosure with Efficient Hypervisor-enforced Intra-domain Isolation.
In 22nd ACM Conference on Computer and Communications Security (CCS). 1607–
1619.
[22] Andrea Mambretti, Kaan Onarlioglu, Collin Mulliner, William Robertson, Engin
Kirda, Federico Maggi, and Stefano Zanero. 2016. Trellis: Privilege Separation
for Multi-user Applications Made Easy. In International Symposium on Research
in Attacks, Intrusions and Defenses. 437–456.
[23] Andrew Myers and Barbara Liskov. 2000. Protecting privacy using the decentral-
ized label model. ACM Transactions on Software Engineering Methodology 9 (Oct.
2000), 410–442. Issue 4.
[24] Santosh Nagarakatte, Jianzhou Zhao, Milo M. K. Martin, and Steve Zdancewic.
2009. SoftBound: highly compatible and complete spatial memory safety for C.
In PLDI. 245–258.
[25] George Necula, Scott McPeak, and Westley Weimer. 2002. CCured: type-safe
retrofitting of legacy code. In 29th ACM Symposium on Principles of Programming
Languages (POPL). 128–139.
[26] Ben Niu and Gang Tan. 2014. Modular Control Flow Integrity. In ACM Conference
on Programming Language Design and Implementation (PLDI). 577–587.
[27] Oracle. Introduction to TI-RPC. Oracle. https://docs.oracle.com/cd/E18752_01/
html/816-1435/rpcintro-46812.html.
[28] Niels Provos, Markus Friedl, and Peter Honeyman. 2003. Preventing privilege
escalation. In 12th Usenix Security Symposium. 231–242.
[29] Charles Reis and Steven D. Gribble. 2009. Isolating web programs in modern
browser architectures. In EuroSys. 219–232.
[30] Konstantin Rubinov, Lucia Rosculete, Tulika Mitra, and Abhik Roychoudhury.
2016. Automated partitioning of Android applications for trusted execution
environments. In International Conference on Software engineering (ICSE). 923–
934.
[31] Robert Watson, Jonathan Anderson, Ben Laurie, and Kris Kennaway. 2010. Cap-
sicum: Practical Capabilities for UNIX. In 19th Usenix Security Symposium. 29–46.
[32] Yang Liu Yongzheng Wu, Jun Sun and Jin Song Dong. 2013. Automatically parti-
tion software into least privilege components using dynamic data dependency
analysis. In ASE. 323–333.
[33] Steve Zdancewic, Lantian Zheng, Nathaniel Nystrom, and Andrew Myers. 2002.
Secure program partitioning. ACM Transactions on Compututer Systems (TOCS)
20, 3 (2002), 283–328.
[34] Nickolai Zeldovich, Silas Boyd-Wickizer, Eddie Kohler, and David Mazières. 2006.
Making Information Flow Explicit in HiStar. In USENIX Symposium on Operating
Systems Design and Implementation (OSDI). 263–278.
[35] Lantian Zheng, Stephen Chong, Andrew Myers, and Steve Zdancewic. 2003.
Using Replication and Partitioning to Build Secure Distributed Systems. In IEEE
Symposium on Security and Privacy (S&P). 236–250.
Session K3:  Program AnalysisCCS’17, October 30-November 3, 2017, Dallas, TX, USA2371