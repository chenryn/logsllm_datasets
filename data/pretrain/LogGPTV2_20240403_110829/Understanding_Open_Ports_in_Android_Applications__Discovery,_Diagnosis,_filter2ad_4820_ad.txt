IP address. Moreover, if addr is set to null, the ANY IP
address is also used by default. This legacy design in the
original Java SDK might be appropriate for open ports on
PCs but not for mobile — as we saw earlier in Table I, many
Android open ports are designed for local usages. We consider
this kind of “convenient” usage potentially insecure in the
sense that they could inadvertently increase the attack surface.
In view of such potentially insecure use of the APIs,
we come up our second objective of identifying the precise
parameter values of all open-port constructions, so that we
can evaluate the extent to which Android developers adopt
such convenient but potentially insecure Java APIs. Note that
these parameters might evolve across different objects, ﬁelds,
arrays, and involve arithmetic operators and Android APIs. We
need to understand all these semantics and calculate a complete
representation of the parameters (instead of just capturing
// API #1-#3
ServerSocket(int port);
ServerSocket(int port, int backlog);
ServerSocket(int port, int backlog, InetAddress addr);
// API #4-#6
SSLServerSocket(int port);
SSLServerSocket(int port, int backlog);
SSLServerSocket(int port, int backlog, InetAddress addr);
// API #7-#9
//class ServerSocketFactory:
createServerSocket(int port);
createServerSocket(int port, int backlog);
createServerSocket(int port, int backlog,InetAddress addr);
// API #10-#11
//ServerSocket socket = new ServerSocket();
socket.bind(SocketAddress addr);
socket.bind(SocketAddress addr, int backlog);
Listing 1: All ServerSocket constructor APIs.
isolated constants in SAAF [51]). Last but not the least, it
is important for our analysis to be efﬁcient and scalable with
a large number of Android apps.
B. OPTool’s Design and Implementation
We design and implement a new static analysis tool called
OPTool
to speciﬁcally handle these challenges. Instead of
generating traditional slicing paths, OPTool uses a structure
called backward slicing graph (BSG) to simultaneously track
multiple parameters (e.g., port and addr) and capture a com-
plete representation of the parameters. On the generated BSGs,
OPTool performs graph traversal and conducts semantic-aware
constant propagation. We also include a preprocessing step
in OPTool to quickly search for open-port constructions to
improve its scalability.
Locating open-port constructions. This can be done
by searching for the accept() API of ServerSocket
and ServerSocketChannel classes, which are the only
Android APIs to open TCP ports in Java. To enable fast
searching and to handle the multidex issue (where Android
apps split their bytecodes into multiple DEX ﬁles to overcome
the limit of having a maximum of 65,536 methods [12]), we
use dexdump [15] to dump (multiple) app bytecodes into
a (combined) plaintext ﬁle and then perform the searching.
Additionally, for the native code, OPTool searches each .so
ﬁle for the four socket system calls.
Backward parameter slicing via BSG. After locating the
open-port constructions, we apply backward slicing on their
parameters to generate BSGs. Each BSG corresponds to one
target open-port call site and records the slicing information
of all its parameters and paths. The BSG not only enables
OPTool to track multiple parameters in just one backward run,
but also makes our analysis ﬂow- and context-sensitive, e.g.,
the process of constructing BSG naturally records the calling
context when analyzing the target of a function call so that
it can always jump back to the original call site. OPTool is
also sensitive to arrays and ﬁelds. With the help of forward
constant propagation shown below, our backtracking just needs
to taint both the instance ﬁeld (or the array index) and its class
object. Handling static ﬁelds does not need the extra help,
but requires us to add their statically uninvoked 
methods (where static ﬁelds get initialized) into the BSG.
7
A notable challenge for Android backward slicing is to deal
with implicit ﬂows and callbacks. OPTool builds in support
of class hierarchy, interface methods, asynchronous execution
(e.g., in Thread, AsyncTask, and Handler), and major
callbacks in the EdgeMiner list [44]. Furthermore, we support
backtracking across (explicit) inter-component communication
(ICC) [62], and model Android component lifecycle [40].
Semantic-aware constant propagation. After performing
the inter-procedural backward slicing, we calculate the com-
plete parameter representation in a forward manner. Besides
the instruction semantics as in the typical forward propaga-
tion [48], we handle the following semantics:
Maintaining object semantics. To determine the correct
object for each instance ﬁeld, we perform points-to analy-
sis [54] for all new statements in the BSG. Speciﬁcally, we
deﬁne an InstanceObj structure and initialize a unique
InstanceObj object for each new statement. We then
propagate the InstanceObj objects along the path and
update their member ﬁelds if necessary. As a result, whenever
a target instance ﬁeld is to be resolved, we can retrieve its
corresponding InstanceObj and extract its value. Array and
ICC objects can be treated similarly with our modeling of the
Intent APIs for updating/retrieving the ICC object ﬁelds.
Modeling arithmetic and API semantics. We model not
only the ﬁve major arithmetic operators, +, -, *, /, and
% (by extracting the two operands and generating a cor-
responding statement
in Java code), but also mathemati-
cal APIs, e.g., Math.abs(int) and Math.random()
(via a special constant “RANDOM”). We also model all
other encountered Android framework APIs, which in-
clude IP address APIs, Integer and String APIs, and
SharedPreferences APIs. There are also a few APIs that
are statically unresolvable, e.g., retrieving values from user
interface via EditText.getText() and from database via
Cursor.getInt(int). We save these cases to the ﬁnal
results without resolving their parameters.
Removing dead ports and resolving SDK names. An
important feature in OPTool is the removal of “dead ports” that
are never executed. We analyze the port liveness in three steps
of OPTool. First, during the backward slicing, we perform
reachability analysis to exclude slices that cannot trace back to
the app entry functions. Second, in the forward propagation,
we consider ports with unresolvable parameters as dead ports.
Third, the post-processing step excludes dead ports with illegal
parameters, e.g., we have detected tens of cases with port
parameter -1.
Resolving
non-trivial
due
have
had
successes with (i) extracting the name of each “sink”
class
calls ServerSocket constructor
directly
e.g.,
APIs — typically
non-obfuscated
the
the
com.facebook.ads.internal.e.b.f
Facebook Advertisement SDK; (ii) extracting Android Logcat
tags [6] of the sink classes which may embed plaintext class
names, as demonstrated in Google’s ofﬁcial document [6];
and (iii) correlating different apps’ open-port parameters
and tags, e.g., most Alibaba AMap SDK [4] classes are
obfuscated, but we can still ﬁnd non-obfuscated instances, e.g.,
com.amap.api.location.core.SocketService.
SDKs
is
said, we
portions,
names
obfuscation. That
the
of
for
to
code
that
Fig. 5: Percentage of open-port apps in each Google Play category.
C. Static Analysis Experiments
As explained in Sec. III-C3, we have two sets of apps
for analysis: (i) the top 9,900 apps across 33 Google Play
categories and (ii) the 1,027 apps from AndroZoo that are
conﬁrmed with TCP open ports.
We use the ﬁrst set to measure the distribution of open-
port apps across different categories. Out of the 9,900 apps
statically analyzed by OPTool, we identify 1,061 apps and their
corresponding 1,453 TCP open ports. Fig. 5 plots a bar chart of
the percentage of open-port apps in each Google Play category.
It clearly shows that open port functionality has been planted
into apps in all 33 Google Play categories, ranging from the
lowest 2.67% in “Libraries & Demo” to the highest 26.67% in
“Tools”. After excluding Facebook SDKs, the percentage drops
to between 0.33% in “Art & Design” and 12.0% in “Video
Players & Editors”. This suggests that open ports may have a
wider adoption in mobile systems than that in the traditional
PC environment.
We then use the second set of apps to quantify the
effectiveness of crowdsourcing in a comparison with static
analysis, as mentioned in Sec. III-C3. Out of the 1,027 open-
port apps as ground truth, OPTool ﬂags 671 apps with potential
Java open-port constructions and 98 apps with native open-port
constructions. Among the remaining 258 (25.1%) apps, 110 of
them implement open ports via dynamic code loading4, and
the rest of 148 apps are likely equipped with advanced code
obfuscation (e.g., multiple anti-virus apps, such as Avast shown
in Table I, appear in this set). For the 671 apps analyzed by
OPTool for open-port parameters, it successfully recovers the
parameters of 459 apps and identiﬁes 48 statically unresolvable
cases (e.g., values from EditText). Other cases are mainly
due to the complex implicit ﬂows (e.g., [43], [55]) that OPTool
currently cannot address, even we have adopted the state-of-
the-art methods [40], [42], [44]. We argue that in an “ideal”
situation (where all 98 apps with native constructions are
successfully analyzed and 48 statically unresolvable cases are
included), a typical static analysis tool can detect only 58.9%
of open-port apps that are discovered by our crowdsourcing
approach.
4We measure it via DexClassLoader and PathClassLoader APIs.
8
Art_DesignAuto_VehicleBeautyBooksBusinessComicsCommuni.DatingEducationEntertainEventsFinanceFood_DrinkGamesHealthHouseLibs_DemoLifestyleMapsMedicalMusic_AudioNewsParentingPersonalPhotographyProductivityShoppingSocialSportsToolsTravel_LocalVideoPlayersWeatherApp Categories on Google Play0%5%10%15%20%25%30%% of Open-Port Apps in Each CategoryWithout FB SDKBy Facebook SDKTABLE III: Open-port SDKs detected in our dataset, and the number of apps affected by them.
SDK
Facebook Audience Network SDK [17]
Yandex Metrica SDK [38]
CyberGarage UPnP SDK [14]
MIT App Inventor SDK [25]
Tencent XG Push SDK [36]
Corona Game Engine SDK [13]
Alibaba AMap SDK [4]
Millennial Ad SDK [24]
PhoneGap SDK [28]
Titanium SDK [37]
Aol AdTech SDK [8]
Apache Cordova SDK [9]
Getui Push SDK [18]
Pattern
Class=‘com.facebook.ads.%’, Tag=ProxyCache, Ip=127.0.0.1, Port=0, Backlog=8
Class=‘com.yandex.metrica.%’, Port=29009|30102
Class=org.cybergarage.http.HTTPServer, Ip=getHostAddress(), Port=8058|8059
Class=com.google.appinventor.components.runtime.util.NanoHTTPD, Port=8001
Class=com.tencent.android.tpush.service.XGWatchdog, Port=RANDOM+55000
Class=com.ansca.corona.CoronaVideoView, Port=0, Backlog=8
Class=‘com.amap.%’, Port=43689
Class=‘com.millennialmedia.android.%’, Tag=MillennialMediaAdSDK, Ip=null, Port=0
Class=com.phonegap.CallbackServer, Port=0
Class=org.appcelerator.kroll.common.TiFastDev, Tag=TiFastDev, Port=7999
Class=com.adtech.mobilesdk.publisher.cache.NanoHTTPD, Port=RANDOM+9000
Class=org.apache.cordova.CallbackServer, Port=0
Class=‘com.igexin.push.%’, Port=48432|51688, Ip=0.0.0.0
#
897
28
19
19
13
11
9
8
6
6
6
4
3
Considering both sets of apps and focusing on those with
their parameters successfully recovered by OPTool, we further
analyze the 1,520 (1,061 + 459) apps with open ports in the
next two subsections.
D. Detection of Open-Port SDKs
Out of these 1,520 apps, we are able to detect 13 open-
port SDKs that affect at least three apps each in our dataset.
Table III lists their details, including the class pattern (we use
“%” to represent obfuscated ﬁelds), the Android Logcat tag
(if any), raw open-port parameters, and the number of affected
apps. Note that the app number here is the number of apps that
actually invoke the SDK code, because some apps may embed
an open-port SDK but never invoke it. For example, we found
a total of 1,110 apps embedding Facebook Audience Network
SDK [17] but only 897 of them triggering the SDK code.
These SDKs are invoked in 1,018 apps (a few apps embed
multiple SDKs), and only 581 open-port apps are not affected
at all. In other words, 61.8% of the 1,520 open-port apps are
solely due to SDKs, among which Facebook SDK is the major
contributor. Even after excluding the impact of Facebook SDK,
we could still count 117 (16.8%) open-port apps that are solely
due to SDKs. These results indicate that SDK-introduced open
ports are signiﬁcant and should be considered seriously in
terms of their necessity as we will discuss in Sec. VI.
We take a closer look at Table III to see what kinds
of SDKs introduce open ports and whether it could raise
an alarm to developers. We ﬁnd that only three SDKs, the
UPnP SDK from CyberGarage [14] and two mobile push
SDKs [18], [36], are networking related. The others are
about advertisements [8], [17], [24], [38] (e.g., Facebook
and Yandex), Javascript generation [9], [25], [28], [37] (e.g.,
App Inventor and PhoneGap), gaming engines [25] and map
navigation [4]. Hence, we argue that developers could hardly
realize the existence of these open ports by simply examining
their functionality.
E. Identiﬁcation of Insecure API Usages
We further analyze the 581 apps whose open ports are
not introduced by SDKs, and their corresponding 869 open
ports. We ﬁnd that 515 port constructions did not set the
IP addr parameter and 96 ports set
it as “null”. Hence,
the default setting of addr, i.e., the ANY IP address, is
automatically used for these ports. In total, these convenient
API usages account to 611 open ports from 390 apps (67.1%).
Furthermore, 164 of these ports (coming from 120 apps)
have their port parameter set as random, which has nearly
no chance of being able to accept external connections and
thus binding to the ANY IP address clearly increases their
attack surfaces. This translates to a (lower bound) estimation
of 26.8% of the 611 convenient API usages being insecure,
and correspondingly 20.7% (120/581) open-port apps adopting
convenient but insecure API usages.
Such an insecure coding practice is not limited to app
developers but also SDK producers. In Table III, six SDKs
make a random port yet using the default addr parameter
binding the port to ANY IP addresses. Hence, Google may
reconsider the design of ServerSocket APIs to enhance
its security at the API level.
V. SECURITY ASSESSMENT
In the last phase of our pipeline (Fig. 1), we perform
comprehensive security assessment of open ports in three
directions: vulnerability analysis in Sec. V-A, denial-of-service
attack evaluation in Sec. V-B, and inter-device connectivity
measurement in Sec. V-C.
A. Vulnerability Analysis of Open Ports
According to our experience of analyzing open-port vul-
nerabilities over more than two years, it is easy for open-
port apps to become vulnerable, especially for TCP open
ports that do not provide system networking services as UDP
open ports (as explained in Sec. III-C1). Therefore, instead
of developing tools to detect individual vulnerable open ports,
we attempt to uncover vulnerability patterns in popular apps
that are usually more representative and more difﬁcult
to
detect. Hence, our vulnerability analysis is quite different
from the previous work [52] that uses pre-deﬁned pattern for
vulnerability detection. Instead, we explore all possible ways in
which an open port could become vulnerable, as long as they
ﬁt our threat model discussed in Sec. II, by performing in-
depth reverse engineering via the state-of-the-art JEB Android
decompiler [21] and extensive dynamic testing.
Table IV summarizes the ﬁve vulnerability patterns we have
identiﬁed. The ﬁrst two have been reported in [52], while the
third is a new variant of the crash vulnerability mentioned in
the traditional Android app security research [49]. The last two
have not been reported and they are speciﬁc to open ports.
9
TABLE IV: Vulnerability patterns identiﬁed in open ports.