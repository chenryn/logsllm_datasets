# 【木马分析】深入分析Android/Ztorg的最新变种
|
##### 译文声明
本文是翻译文章，文章来源：fortinet.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
****
作者：[shan66](http://bobao.360.cn/member/contribute?uid=2676915949)
稿费：300RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**前言**
Ztorg，又称为Qysly，是Android恶意软件的最大家族之一。它于2015年4月首次现身，目前变种数量已经超过25个，截止2017年，其中一些变种仍然处于活跃状态。然而，关于Ztorg的技术说明却非常匮乏——好像只有最初的Ztorg.A样本的相关分析，所以我决定根据2017年1月20日检测到的较新版本的Android
/ Ztorg.AM！tr做一番深入的分析。
该样本以“Cool Video Player”身份示人，并且它的恶意活动是如此隐蔽，以至于最初我认为这是一个误报。但是，它绝非善类，不久您就会明白了。
**寻找恶意代码**
这个样本的manifest表明main activity位于com.mx.cool.videoplayer.activity.mainactivity中。
这个activity用于初始化多个SDK，但是从中没有检测到恶意行为：
com.adjust：调校SDK，用于应用程序的分析
com.batmobi：Batmobi，用于移动广告
com.catchgift：这显然是广告
com.marswin89：这是一个marsdaemon，该库用于保证应用程序的处于运行状态，但没有恶意行为。
com.squareup：移动支付
com.umeng：移动广告分析
那么，恶意代码到底在哪里呢？难道只是某个开发工具包中的一些“不太干净的”代码触发了警报（假阳性）吗？
我继续在这个应用程序的其他命名空间中进行寻找：
u.aly包含MobClick广告代码，
android.support.v4是应用开发标准。
命名空间e.i.o.q除了命名空间a调用函数之外，没有做任何事情。
所以，当我开始探索命名空间a…
**字符串混淆**
我立即注意到有许多经过混淆处理的字符串，并且忍不住要进行反混淆处理（要不咋叫Crypto Girl呢，对吧？）
例如，请看下列代码：
其中c.a()函数的实现代码如下所示：
简单来说，这就是将第一个和最后一个字节作为XOR密钥对字节数组的其余部分进行混淆处理。于是，我写了一个单独的Python解码器，来模拟反编译代码。它的确很方便，不过要是使用JEB2脚本的话，可能会更好一些，这样就可以让它直接在反编译的输出中替换这些字符串了。
JEB脚本写起来很是需要一些技巧。Mine用于对反编译的类进行解析，并在每个类中使用c.a（new byte []
{…}）来定位语句。许多情况下都会出现对这个解码函数的调用，例如v0 [6] = ca（new byte [] {…，以及 a = new
String(c.a(new
byte[]{….。因此，我们需要对其右侧的代码进行非常细致的分析。当检测到一个调用时，脚本就会对相应的值进行解码，并使用解码的结果将其替换掉。
例如，第一个图（左边）展示了a.a.a.的初始的反编译代码。第二个图展示了使用脚本处理后的结果。
这里使用的脚本可以从Github上下载。
**模拟器检测**
在解码的字符串中，我们注意到许多VirtualBox，QEMU之类的引用。这是模拟器检测，下面您会发现，这是一种非常高级的技术。
让我们回到执行的流程。主活动（MainActivity）的onCreate()方法会调用f()，f()会调用e.i.o.q.d()。通过逆向e.i.o.q.d()，我们发现该函数会检测是否在模拟器上运行。如果不是在模拟器上的话，它就只运行代码中的恶意部分，这正是沙盒没有记录下任何恶意活动的原因。
这个模拟器检测例程是一种非常复杂的技术，并且用途广泛。它能检测标准的Android模拟器、Genymotion模拟器、Bluestacks模拟器、BuilDroid虚拟机，以及使用TaintDroid的环境。
那么它是如何检测模拟器呢？它可以根据：
1.系统属性中的特定值。
2.与模拟器有关的IMEI、IMSI和电话号码的典型值。在Genymotion中，IMEI是可以定制的，但IMSI则不可以。在标准Android
SDK模拟器上，这些都难以定制，除非给模拟器打补丁并重新编译模拟器。
3.存在特定文件。例如，/ dev / qemu_pipe。从AV分析师的角度来看，这是很难对付的，因为没有这些文件的话，许多模拟环境将无法正常工作。
4.检查特定系统文件中的某些值。需要特别指出的是，这是我第一次见到恶意软件检查/ proc / net /
tcp中的值。这一点非常有趣：该文件是记录活动的TCP连接的。第一列对应于条目数，第二列是本地地址，第三列是本地端口，第四列是远程地址。在真实的设备上，我们会看到下列内容：
        0: 4604D20A:B512 A3D13AD8...
但是在模拟器上，地址会被清零，这很容易注意到：
        0: 00000000:0016 00000000:0000
5.特定的TaintDroid类（dalvik.system.Taint）和注入的字段（FileDescriptor类中的名称和Cipher中的密钥）。这些代码可能是来自Tim
Strazzere的反模拟器代码。
**下载远程内容**
我们已经看到，该样本实现了高级的仿真器检测功能。然而，许多正常的应用程序也会出于各种原因而做这些事情的。那么，恶意的代码究竟在哪里呢？当目前为止，我们仍然无法确认这不是一个误报。
其实，我们离真相已经越来越近了。当样本检测到并非在模拟器上运行之后，它就会发送一个HTTP请求到hXXp：//bbs.tihalf.com/only/ [$
1] /2.html ?。这正是我们在上一步中反混淆处理后得到的那个网址。[$
1]被替换为gp1187（另一个反混淆后得到的字符串），并且将一个blob附加到url中，这里的blob是一个包含代码版本、SDK版本等信息的经DES加密的JSON对象。
它已经越来越可疑了。
响应是base64编码形式的，并用DES-CBC进行了加密（见类a.c.a）：
密钥是硬编码的（就是反混淆处理后的字符串sokhlwej），IV是DES_e.IV = new byte []
{1,2,3,4,5,6,7,8}。好了，现在我们对服务器的响应进行解密：
我们注意到o和p含有一个关于Android包的链接。那么，它们被用到了吗？ 是的!
检索JSON对象后，该样本就会读取o中的URL，并尝试下载该文件。如果o无法正常使用，它就会尝试p。