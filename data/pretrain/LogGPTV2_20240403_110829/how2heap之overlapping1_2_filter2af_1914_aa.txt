# how2heapä¹‹overlapping1/2
|
##### è¯‘æ–‡å£°æ˜
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŸæ–‡ä¸ºå‡†ã€‚
> æ¬¢è¿å„ä½å–œæ¬¢å®‰å…¨çš„å°ä¼™ä¼´ä»¬åŠ å…¥æ˜Ÿç›Ÿå®‰å…¨ UVEgZ3JvdXA6IDU3MDI5NTQ2MQ==
>
> æ¥ä¸Šä¸€ç¯‡çš„unink
PS:ç”±äºæœ¬äººæ‰ç–å­¦æµ…,æ–‡ä¸­å¯èƒ½ä¼šæœ‰ä¸€äº›ç†è§£çš„ä¸å¯¹çš„åœ°æ–¹,æ¬¢è¿å„ä½æ–§æ­£ ğŸ™‚
## å‚è€ƒç½‘ç«™
    https://ctf-wiki.github.io/ctf-wiki/
## 0x0 overlapping_chunk
###  åº
overlappingåœ¨å¹³å¸¸ç®—æ˜¯æœ€å¸¸ç”¨çš„æŠ€å·§äº†,å‡ ä¹æ¯ä¸€é“é¢˜éƒ½éœ€è¦æ„é€ overlap
è€Œæåˆ°overlappingå°±ä¸å¾—ä¸è¯´chunk shrinkå’Œchunk
extendäº†,å…¶å®è¿™ä¸¤ä¸ªéƒ½æ˜¯ä¾é æ›´æ”¹chunkçš„pre_sizeåŸŸå’ŒsizeåŸŸæ¥æ¬ºéª—ptmallocçš„
è¯¦æƒ…å¯è§,[æ–‡ç« ä¸€](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/chunk_extend_overlapping-zh/#4extendoverlapping),[æ–‡ç« äºŒ](https://nightrainy.github.io/2019/07/25/chunk-extend-and-overlapping/)
å¥½äº†,å›è¿‡æ¥,æˆ‘ä»¬ç»§ç»­çœ‹æœ¬ä¾‹
###  æºä»£ç 
æˆ‘ä»¬è¿˜æ˜¯å…ˆçœ‹æºä»£ç å§,åŒæ ·çš„,æˆ‘åˆ äº†å†™ä¸œè¥¿å¹¶åŠ äº†ä¸€å°ç‚¹ç¿»è¯‘(é›¾
    #include 
    #include 
    #include 
    #include 
    int main(int argc , char* argv[]){
            intptr_t *p1,*p2,*p3,*p4;
            p1 = malloc(0x100 - 8);
            p2 = malloc(0x100 - 8);
            p3 = malloc(0x80 - 8);
            fprintf(stderr, "The 3 chunks have been allocated here:np1=%pnp2=%pnp3=%pn", p1, p2, p3);
            memset(p1, '1', 0x100 - 8);
            memset(p2, '2', 0x100 - 8);
            memset(p3, '3', 0x80 - 8);
            free(p2);
            // p2ç°åœ¨åœ¨unsorted binä¸­,æ—¶åˆ»å‡†å¤‡ä¸ºæ–°çš„mallocæœåŠ¡
            fprintf(stderr, "The chunk p2 is now in the unsorted bin ready to serve possiblennew malloc() of its sizen");                   
            // ç°åœ¨æ¨¡æ‹Ÿä¸€ä¸‹æº¢å‡ºæ¥è¦†å†™p2çš„size                                                                               
            fprintf(stderr, "Now let's simulate an overflow that can overwrite the size of thenchunk freed p2.n");     
            //å¯¹å®ä¾‹ç¨‹åºè€Œè¨€,æœ€åä¸‰ä¸ªå­—èŠ‚æ˜¯ä»€ä¹ˆå¹¶ä¸é‡è¦,ç„¶è€Œ,æˆ‘ä»¬æœ€å¥½è¿˜æ˜¯ç»´æŒä¸€ä¸‹å †çš„ç¨³å®šæ€§
            fprintf(stderr, "For a toy program, the value of the last 3 bits is unimportant;"
                    " however, it is best to maintain the stability of the heap.n");
            //ä¸ºäº†ç»´æŒå †çš„ç¨³å®šæ€§,æˆ‘ä»¬è¿˜æ˜¯è¦æŠŠprev_inuseæ ‡å¿—ä½è®¾ä½1æ¥ç¡®ä¿æˆ‘ä»¬çš„p1ä¸ä¼šè¢«é”™è¯¯çš„è®¤ä¸ºæ˜¯ä¸€ä¸ªfree chunk
            fprintf(stderr, "To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),"
                    " to assure that p1 is not mistaken for a free chunk.n");
            int evil_chunk_size = 0x181;
            int evil_region_size = 0x180 - 8;
            fprintf(stderr, "We are going to set the size of chunk p2 to to %d, which gives usna region size of %dn",                                                                                                                       evil_chunk_size, evil_region_size);
            *(p2-1) = evil_chunk_size; // we are overwriting the "size" field of chunk p2
            //ç°åœ¨æˆ‘ä»¬åˆ†é…ä¸€ä¸ªå’Œp2è¢«æ³¨å…¥çš„sizeä¸€æ ·çš„å¤§å°çš„chunk
            fprintf(stderr, "nNow let's allocate another chunk with a size equal to the datan"
                   "size of the chunk p2 injected sizen");
            è¿™æ¬¡çš„mallocå°†ä¼šä»æˆ‘ä»¬åˆšåˆšä¿®æ”¹è¿‡sizeçš„unsoted binä¸­å–å‡ºfree chunk
            fprintf(stderr, "This malloc will be served from the previously freed chunk thatn"
                   "is parked in the unsorted bin which size has been modified by usn");
            p4 = malloc(evil_region_size);
            fprintf(stderr, "np4 has been allocated at %p and ends at %pn", (char *)p4, (char *)p4+evil_region_size);
            fprintf(stderr, "p3 starts at %p and ends at %pn", (char *)p3, (char *)p3+0x80-8);
            fprintf(stderr, "p4 should overlap with p3, in this case p4 includes all p3.n");
            //ç°åœ¨æˆ‘ä»¬å†™è¿›p4çš„å†…å®¹å°±å¯ä»¥è¦†ç›–p3å•¦,åŒæ—¶,æˆ‘ä»¬å†™åˆ°p3é‡Œçš„å†…å®¹ä¹Ÿå¯ä»¥ä¿®æ”¹p4çš„å†…å®¹
            fprintf(stderr, "nNow everything copied inside chunk p4 can overwrites data onnchunk p3,"
                    " and data written to chunk p3 can overwrite datanstored in the p4 chunk.nn");
            fprintf(stderr, "Let's run through an example. Right now, we have:n");
            fprintf(stderr, "p4 = %sn", (char *)p4);
            fprintf(stderr, "p3 = %sn", (char *)p3);
            fprintf(stderr, "nIf we memset(p4, '4', %d), we have:n", evil_region_size);
            memset(p4, '4', evil_region_size);
            fprintf(stderr, "p4 = %sn", (char *)p4);
            fprintf(stderr, "p3 = %sn", (char *)p3);
            fprintf(stderr, "nAnd if we then memset(p3, '3', 80), we have:n");
            memset(p3, '3', 80);
            fprintf(stderr, "p4 = %sn", (char *)p4);
            fprintf(stderr, "p3 = %sn", (char *)p3);
    }
###  è¿è¡Œç»“æœ
    This is a simple chunks overlapping problem
    Let's start to allocate 3 chunks on the heap
    The 3 chunks have been allocated here:
    p1=0x7aa010
    p2=0x7aa110
    p3=0x7aa210
    Now let's free the chunk p2
    The chunk p2 is now in the unsorted bin ready to serve possible
    new malloc() of its size
    Now let's simulate an overflow that can overwrite the size of the
    chunk freed p2.
    For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.
    To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.
    We are going to set the size of chunk p2 to to 385, which gives us
    a region size of 376
    Now let's allocate another chunk with a size equal to the data
    size of the chunk p2 injected size
    This malloc will be served from the previously freed chunk that
    is parked in the unsorted bin which size has been modified by us
    p4 has been allocated at 0x7aa110 and ends at 0x7aa288
    p3 starts at 0x7aa210 and ends at 0x7aa288
    p4 should overlap with p3, in this case p4 includes all p3.
    Now everything copied inside chunk p4 can overwrites data on
    chunk p3, and data written to chunk p3 can overwrite data
    stored in the p4 chunk.
    Let's run through an example. Right now, we have:
    p4 = xK heap
    0x603000 PREV_INUSE {
      prev_size = 0,
      size = 257,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603100 PREV_INUSE {
      prev_size = 0,
      size = 257,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603200 FASTBIN {
      prev_size = 0,
      size = 129,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603280 PREV_INUSE {
      prev_size = 0,