第4章解决Rabbit相关问题：编码与模式
序时，客户端和服务器端会发生什么呢？
Client） Sent 'ping' RPC call. Waiting for reply...
Server) Received API call...replying...
Client) RPC Reply --- Pong! (Client Name: RPC Client 1.0)
(RPC Ca1l Issued Time: 1288111236.43)
你会发现这里服务器的应答就是针对该客户端的调用。因为服务器应答包含的
时间戳就是客户端调用消息内的那个时间戳。在此，你可以轻易地通过创建队列和
绑定的方式来扩展API以支持新的API方法。这样做最大的好处是任何一台服务器
都无须对所有API调用做应答。举个例子，你可以简单地编写一个新的RPC服务
器来进行图像处理，并运行在与pingAPI服务器不同的物理主机上。客户端不会知
道有什么差异，你也可以根据需要随意扩展你的API服务。Rabbit像施了魔法一样
将所有这一切组织成一个API结构。没有特殊的协议和服务目录。
4.4总结
在本章中，我们讨论了利用RabbitMQ编写应用程序的基础方法及其背后的消
息通信模式。我们讨论了从发后即忘模式，譬如告警和图片处理，到使用真正的双
向通信来实现RPCAPI。在理解这些基础的消息通信架构后，你可以自由设计自己
的复杂模式，将这些基础知识组合而成独一无二的解决方案来完成明确的目标。既
然你开始用RabbitMQ来构建应用程序的核心的话，那么是时候让我们看看如何以
弹性配置来运行RabbitMQ了，以确保当我们需要它的时候，它总是可用的。
---
## Page 121
集群并处理失败
本章要点
RabbitMQ集群架构
■在你的笔记本电脑上搭建集群
■使用物理服务器创建集群
■升级集群节点
■与镜像队列一起工作
你刚刚依靠RabbitMQ消息队列的魔力，完成了了不起的新Web应用。用户接
口展现了从后端API发送来的实时通知，并且Rabbit只发送每位API客户端感兴
趣的通知。所有这一切看起来棒极了。同时Rabbit让你在老板面前看起来像一位编
程大师。是时候该部署到产品环境了。你只需将RabbitMQ实例往生产环境服务器
上一扔，一切就大功告成了，对吧？先别急。虽然对于客户端来说你的实时魔法看
起来不错，但是当你的RabbitMQ服务器遇到内存崩溃了或者断电的情况，该怎么
办呢？这款高性能的产品将成为公司的耻辱一—也成为你的问题。现在正是时候讨
论一下如何使得RabbitMQ能够弹性应对故障了，因而当墨菲定律肆虐你的应用程
序时，你能确信作为应用程序“心脏”的RabbitMQ可以正常运行。
---
## Page 122
100
第5章集群并处理失败
要让RabbitMQ变成高可用性有两种方法。其中一种是设置Rabbit集群，这样
你可以从任何一台Rabbit故障中得以幸免，并且应用程序能够持续运作而不会停
顿。另一种方法是扩大程序的规模以提升性能。单个RabbitMQ实例可能足够处理
吉娃娃遛狗应用服务每天产生的消息吞吐量，但是当你需要处理每秒1000000条
遛狗请求时，会发生什么呢？你需要Rabbit集群来保证应用程序正常运作。幸运的
是，RabbitMQ自带的内建集群可以解决以上两个问题。不管是因为服务器故障还
是碰上了巨大的成功，你的应用程序总是能够连上Rabbit。在本章中，我们会讲述
RabbitMQ中令人看迷的集群。在本章结束的时候，你会理解集群背后的工作原理，
并且明白如何在用于开发的笔记本电脑上搭建小规模的集群，也能在生产环境中搭
建多台服务器集群。你会知道在新版本Rabbit发布后，如何升级集群。话不多说，
让我们逐步深入，看看如何将儿个Rabbit搭建成一个犀利的消息传递集群吧！
5.1开足马力：RabbitMQ集群
RabbitMQ最优秀的功能之一就是其内建集群。这使得它与几乎其他所有开源
消息通信服务器有所区别；同时能够将集群在5分钟内搭建并运行起来这一事实，
后在运行时添加更多的Rabbit以增加高可用性或者提升性能，而完全不用停机。不过，
RabbitMQ集群并非“包治百病”。那么，RabbitMQ集群可以带给你什么呢?
RabbitMQ内建集群的设计用于完成两个目标：允许消费者和生产者在Rabbit
节点崩溃的情况下继续运行，以及通过添加更多的节点来线性扩展消息通信吞吐量。
RabbitMQ通过利用Erlang提供的开放电信平台（OpenTelecomPlatform，OTP）分
布式通信框架来巧妙地满足以上两个需求。你可以失去一个RabbitMQ节点，同时
客户端能够重新连接到集群中的任何其他节点并继续生产或者消费消息，就像什么
事都没发生过一样。同样地，如果Rabbit集群正疲于应对庞大消息通信量的话，那
么添加更多的节点会线性地增加更多性能。RabbitMQ集群不能保证消息的万无一失。
即便你将所有事情处理得很好（将消息、队列、交换器设置成可持久化，等
等），当一个Rabbit集群节点崩溃时，该节点上队列的消息也会消失。这是因为
RabbitMQ默认不会将队列的内容复制到整个集群上。如果不进行特别的配置，这
些消息仅存在于队列所属的那个节点上。等一下，队列只存在于集群中的一个节点
上？答案既是又非。为了能更好地理解，让我们看一下RabbitMQ集群架构。
---
## Page 123
5.2集群架构
101
5.2集群架构
到自前为止，我们对于RabbitMQ的内部情况还不甚了解。确实，你知道队列
和交换器的含义，以及如何将它们绑定到一起，也知道该使用哪些类型的交换器。
但是这背后到底发生了什么呢？RabbitMQ是如何记录所有你使用的各种基础构件，
同时它们又如何装配成一个消息通信服务器的呢？
RabbitMQ会始终记录以下四种类型的内部元数据：
·队列元数据一队列名称和它们的属性（是否可持久化，是否自动删除？）
·交换器元数据一交换器名称、类型和属性（可持久化等）
■绑定元数据一—一张简单的表格展示了如何将消息路由到队列
■vhost元数据一为vhost内的队列、交换器和绑定提供命名空间和安全属性
在单一节点内，RabbitMQ会将所有这些信息存储在内存中，同时将那些标记
为可持久化的队列和交换器（以及它们的绑定）存储到硬盘上。存储到硬盘上可以
确保队列和交换器在重启RabbitMQ节点后重新创建。当你引人集群时，RabbitMQ
需要追踪新的元数据类型：集群节点位置，以及节点与已记录的其他类型元数据的
关系。集群也提供了选择：将元数据存储到磁盘上（独立节点的默认设置），或者
仅存储在RAM中。但是在我们深入到集群节点和它们如何存储元数据前，你应该
首先理解在集群环境中队列和交换器的行为。
5.2.1集群中的队列
在将两个节点组成集群的那一刻，事情发生了巨大的变化：不是每一个节点都
有所有队列的完全拷贝。在单一节点设置中，所有关于队列的信息（元数据、状态
和内容）都完全存储在该节点上（见图5.1）。但是如果在集群中创建队列的话，集
群只会在单个节点而不是在所有节点上创建完整的队列信息（元数据、状态、内容）。
结果是只有队列的所有者节点知道有关队列的所有信息。所有其他非所有者节点只
该节点的队列和关联的绑定就都消失了。附加在那些队列上的消费者丢失了其订阅
1在RabbitMQ2.6.0及之后的版本中提供了镜像队列以允许队列内容免于集群节点故障。我们会在5.6
节进行讲解。
---
## Page 124
102
第5章集群并处理失败
信息，并且任何匹配该队列绑定信息的新消息也都丢失了。
以列1元数据
队列名称
是否持久化
是否自动删除
所有者节点
队列1内容
列
数据
RabbitMQ
RabbitMQ
以列
认列1
节点
节点
RabbitMQ
RabbitMQ
独立节点
节点
集群
图5.1在独立节点和集群配置下的队列行为
别担心，你可以让消费者重连到集群并重新创建队列，对吧？这种做法仅当队
列最开始没有被设置成可持久化时才是可行的。如果重新创建的队列被标记成持久
化了，那么在其他节点上重新声明它们的话会得到一个难看的404NOT_FOUND错
误。这样确保了当失败节点恢复后加人集群，该节点上的队列消息不会丢失。想要
该指定队列重回集群的唯一方法是恢复故障节点。但是如果消费者尝试重建的队列
不是可持久化的，那么重新声明就会成功，你可以准备重新绑定它们并传输数据。
挥之不去的问题是，为什么默认情况下RabbitMQ不将队列内容和状态复制到所有
的节点上呢？
有两个原因：
（1）存储空间一如果每个集群节点都拥有所有队列的完整拷贝，那么添加新
的节点不会给你带来更多存储空间。举个例子，如果一个节点可以存储1GB的消息，
那么添加两个节点只会给你带来两个一模一样的1GB消息的拷贝。
---
## Page 125
5.2集群架构
103
（2）性能一消息的发布需要将消息复制到每一个集群节点。对于持久化消息
来说，每一条消息都会触发磁盘活动。每次新增节点，网络和磁盘负载都会增加，
最终只能保持集群性能的平稳（甚至更糟）。
通过设置集群中的唯一节点来负责任何特定队列，只有该负责节点才会因队列
消息而遭受磁盘活动的影响。所有其他节点需要将接收到的该队列的消息传递给该
队列的所有者节点。因此，往Rabbit集群添加更多的节点意味着你将拥有更多的节
点来传播队列，这些新增节点为你带来了性能的提升。当负载增加时，RabbitMQ
集群是性能扩展的最佳方案。你可能好奇交换器是否也遵循同样的规则。并非如此，
因为交换器本身是你凭空想象出来的。
5.2.2分布交换器
到自前为止，我们一直把交换器描述得如同队列那样是一个活生生的实体。事
实上，不同于队列那样拥有自己的进程，交换器说到底只是一个名称和一个队列绑
定列表。当你将消息发布到交换器时，实际上是由你所连接到的信道将消息上的路
由键同交换器的绑定列表进行比较，然后路由消息。正是信道（channel）按照绑定
匹配的结果，将消息路由到队列。这是为什么呢？理解信道是真正的路由器这一点
很重要，因为这解释了为什么交换器不会像集群中的队列那样受到相同的限制。
注意：理解RabbitMQ背后的消息路由工作机制的方法是把每个队列想象
成节点上运行的进程，每个进程拥有自己的进程ID（PID）。交换器只不过
是路由模式列表和匹配消息应发往的队列进程ID列表。当发布的消息匹
配了交换器中的绑定规则时，实际上是由信道完成了匹配工作，并在匹配
之后建立到队列PID的连接，然后将消息传送过去。队列的进程ID本质
上是其在集群中的Erlang地址。
由于交换器只不过是一张查询表，而非实际上的消息路由器，因此将交换器在
RabbitMQ所要做的是将查询表添加到集群中的所有节点上。这时，每个节点上的
每条信道都可以访问到新的交换器了。因此，相对于默认情况下队列的完整信息存
在于集群中的单一节点来说，集群中的每个节点拥有每个交换器的所有信息。就可
用性来讲，这非常棒，因为这意味着你不用担心在节点故障时重新声明交换器。只
需让故障节点上的生产者重新连接到集群上，它们立即就能开始往交换器上发布消
---
## Page 126
104
第5章集群并处理失败
消息会怎样呢？
交换器A
交换器A
routing_keyl
routing_keyl
routing_key2
routing_key2
routing_key3
元数据
routing_key3
队列1元数据
队列1元数据
队列1内容
交换器A
routing_key1
RabbitMQ
routing_key2
RabbitMQ
routing_key3
集群
集群
队列1元数据
RabbitMQ
集群
图5.2集群中的交换器和队列分布
AMQP的basic·publish命令不会返回消息的状态。这意味着当信道节点崩
溃时信道可能仍然在路由消息，而生产者已经继续创建下一条消息了。在这种情况
下，你将承受丢失消息的风险。解决方法是使用AMQP事务，在消息路由到队列之
前它会一直阻塞；或者使用发送方确认（publisherconfirm）模式来记录连接中断时
尚未被确认的消息。这两种解决方案也能帮助你在节点故障并且目的队列不复存在
时检测到消息无法路由的情况。当与交换器在集群中完全复制的这一事实相结合时，
事务模式和发送方确认模式都能确保应用程序一直发布而不丢失一条消息。
现在你明白了队列和交换器在集群中的表现，是时候看一下RabbitMQ是如何
记录它们，以及节点如何为它们提供动力的了。
5.2.3是内存节点还是磁盘节点
每个RabbitMQ节点，不管是单一节点系统或者是庞大集群的一部分，要么是
内存节点（RAMnode），要么是磁盘节点（disknode）。内存节点将所有的队列、交
---
## Page 127
5.2集群架构
105
换器、绑定、用户、权限和vhost的元数据定义都仅存储在内存中。而磁盘节点则
将元数据存储在磁盘中（见图5.3）。单节点系统只允许磁盘类型的节点；否则，每
次你重启RabbitMQ之后，所有关于系统的配置信息都会丢失。不过在集群中，你
可以选择配置部分节点为内存节点。为什么会想要选择将元数据仅存储在内存中？
因为它使得像队列和交换器声明之类的操作更加快速。
queue.declare
my_queue
存储
my.
RAM
RabbitMQ
磁盘节点
存储
queue.declare
my_queue
my_queue
定义
磁盘
存储
my_queue
定义
BabhitMQ
内存节点
RAM
图5.3元数据写入内存和磁盘节点
当在集群中声明队列、交换器或者绑定的时候，这些操作会直到所有集群节点
都成功提交元数据变更后才返回。对于内存节点来说，这意味着将变更写人内存；
而对于磁盘节点来说，这意味着昂贵的磁盘写人操作，直到完成之后，节点才能说：
“完事儿了！”假设你有五个节点的集群，并且所有节点都是磁盘节点，则你必须
得等待所有这五个节点将元数据写人磁盘后，队列声明操作才能返回。对于队列长