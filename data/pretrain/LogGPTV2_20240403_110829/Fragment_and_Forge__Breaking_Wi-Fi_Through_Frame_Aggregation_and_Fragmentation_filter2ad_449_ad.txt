S
Client
Attacker
AP (vulnerable)
Auth
Spoof client MAC address
Connect under client MAC
Encn
k{Frag0(s)}
Decrypt & store fragment
Deauth
Fragment cache is not cleared
Let client connect & forward normal trafﬁc
Send sensitive data
(cid:96){Frag0(s(cid:48))}
{Frag1(s(cid:48))}
Encn
Encn+1
(cid:96)
Encn
Encn+1
(cid:96){Frag0(s(cid:48))}
{Frag1(s)}
(cid:96)
Reassemble frame and
thereby exﬁltrate data
Figure 6: Fragment cache attack against a vulnerable AP
with as goal to exﬁltrate (decrypt) client data. The adversary
injects a fragment with an attacker-destined IP packet, which
is appended with a fragment containing sensitive data.
that the fragment that we inject in the second stage of the
attack stays in the AP’s fragment cache.
In stage 3(cid:13) of the attack, the adversary waits until a second
fragment with packet number n + 1 is sent. The adversary for-
wards this fragment to the AP with sequence number s. This
causes the AP to combine it with the injected fragment since
they have the same sequence number and MAC addresses.
Because the AP does not store under which credentials these
fragments were received, it does not realize both fragments
were in fact sent by different users. The reassembled frame
will contain an IP packet with as destination the adversary,
and with as payload the user data (similar to Figure 5). This
exﬁltrates the user data to the adversary. If the frame with
packet number n + 1 is not a second fragment, the attack can
be restarted by forcibly disconnecting the client from the AP.
5.3 Packet injection
An attacker can also inject packets by poisoning the fragment
cache. Against an AP this attack is similar to the data exﬁltra-
tion attack of Section 5.2, except that the injected fragment
Frag0 in stage 2(cid:13) contains the packet to be injected. When
reassembling the frame upon reception of the second frag-
ment, unknown content will be appended to the injected frame.
However, the network layer above 802.11 will discard this
unknown content as padding data. The receiver knows where
this padding data starts because network packets, such as IP
or ARP packets, contain length ﬁelds that deﬁne the size of
the packet. As a result, the adversary can inject packets under
USENIX Association
30th USENIX Security Symposium    169
Client (vulnerable)
Attacker
AP
Spoof AP MAC address
Connect to untrusted network
Encn
k{Frag0(s)}
Decrypt & store fragment
Deauth
Fragment cache is not cleared
Let client connect & forward normal trafﬁc
Encn
Encn+1
(cid:96){Frag0(s(cid:48))}
{Frag1(s)}
Encn
Encn+1
(cid:96)
(cid:96){Frag0(s(cid:48))}
{Frag1(s(cid:48))}
(cid:96)
Reassemble frame
and process packet
1(cid:13)
e
g
a
t
S
2(cid:13)
e
g
a
t
S
Figure 7: Fragment cache attack against a client with as goal
to inject a packet. We abuse this to force the client into using
our DNS server while being connected to a trusted network.
another client’s identity, which is otherwise not possible in
our hotspot-type networks.
To abuse fragment cache poisoning against a client, we
rely on a novel threat model where the client will connect to
an untrusted protected network, but will only send sensitive
data when connected to a trusted network. For instance, a
company laptop can be conﬁgured to only send sensitive data
when connected to the company network, but the laptop is also
used for casual internet surﬁng by, for example, connecting
to a coffee shop network with a publicly shared password.
To attack a client, the adversary ﬁrst spoofs the MAC ad-
dress of the trusted (company) network but advertises the
SSID of the untrusted (coffee shop) network (see stage 1(cid:13) in
Figure 7). Once the client connected to this rogue network, the
adversary injects fragment Frag0(s) into the victim’s memory.
This fragment contains the packet to be injected.
Between stages 1(cid:13) and 2(cid:13) of the attack, the client is discon-
nected from the untrusted network, after which it connects to
the trusted (company) network. While the client is connecting,
the adversary establishes a multi-channel MitM position be-
tween the client and AP. In this MitM position, the adversary
forwards all frames between the client and AP, while avoiding
to use sequence number s in frames towards the client. Note
that the 802.11 standard does not require that the client clears
its fragment cache when (re)connecting to an AP.
Stage 2(cid:13) of the attack starts when the AP of the trusted net-
work sends a second fragment with packet number n + 1. The
adversary forwards this frame with sequence number s, such
that the client will reassemble it with the injected fragment
Frag0(s). Similar to the attack against the AP, the network
layer of the client will discard the content in the second frag-
ment as padding bytes, and will subsequently process the
packet contained in Frag0. In practice, an adversary can use
this packet injection capability to trick the client into using
a malicious DNS server (recall Section 3.3). This in turn
enables the adversary to intercept data that the client only
transmits while connected to the trusted (company) network.
5.4 Experiments
Similar to the mixed key attack, patched drivers are needed
to perform the attack in practice. Windows and Linux are
vulnerable with more than half of all tested network cards. The
Android and iOS devices we tested were not vulnerable. Out
of the tested BSD systems, only FreeBSD is vulnerable in AP
mode and when using the injection technique of Appendix E.
Our three professional APs were not affected, but all our
four home routers unfortunately were. See Section 6.1 for an
overview of all tested devices.
To keep experiments easier to reproduce, we again tested
end-to-end attacks against Linux user virtual Wi-Fi interfaces.
The target network used EAP-PWD, meaning users authenti-
cate themselves using a username and password. In this setup
we successfully attacked a vulnerable AP, poisoned its frag-
ment cache with the start of an IP packet towards our server,
and exﬁltrated (decrypted) fragments sent by the victim.
We also successfully conﬁrmed the attack against WEP on
Linux, meaning this design ﬂaw has been part of the 802.11
standard since its release in 1997.
Finally, we note that attacking Linux is non-trivial because
it clears fragments from memory after two seconds. Neverthe-
less, attacks against Linux APs are practical, because there
we can inject the malicious fragment right before a client is
already attempting to connect to the AP, which assures delay
between the injected and forwarded fragment is low.
5.5 Discussion
A backwards-compatible defense is to clear the fragment
cache when (re)connecting or (re)associating with a station.
We elaborate on this in Section 7.2.
Our cache poisoning attack is only possible if a device in
the network uses fragmentation. Similar to our mixed key
attack, we conjecture that our MitM position can pretend that
the client and AP support dynamic fragmentation, and thereby
induce the use of fragmentation against 802.11ax devices.
In practice, if a device is vulnerable to cache attacks, it is
likely also vulnerable to mixed key attacks. This is not guar-
anteed though, because mixed key attacks can be prevented
while cache attacks remain possible (and vice versa).
6 Experiments and Implementation Flaws
In this section, we elaborate on the experimental setup used to
conﬁrm the design ﬂaws, and we present common implemen-
tation ﬂaws related to frame aggregation and fragmentation.
170    30th USENIX Security Symposium
USENIX Association
6.1 Experimental setup
To conﬁrm the design ﬂaws in practice we tested smartphones,
laptops, internet-of-things devices, home routers, and profes-
sional APs (see Table 1). We also tested Windows 10 and
Linux 5.5 as clients using 16 wireless network cards on a Lati-
tude 7490 and MSI GE60 (Table 2). Then we tested FreeBSD
12.1 and NetBSD 7.0 using several network cards (Table 3),
and OpenBSD 6.4 using a small number of supported network
cards (Section 6.8). In total this means we tested 75 devices,
i. e., network card and OS combinations. In these experiments
all devices were affected by one or more attacks. In general,
whether a device is affected depends on the OS, network card,
and whether it is acting as a client or AP. While performing
experiments, we also analyzed the code of leaked and open
source network stacks and found several implementation ﬂaws
related to aggregation and fragmentation.
We created a tool that can test if clients or APs are affected
by the discovered design and implementations ﬂaws [1]. It can
test home networks and enterprise networks where authentica-
tion is done using, e. g., PEAP-MSCHAPv2 or EAP-TLS. Our
tool supports over 45 test cases, and over all devices combined
we performed more than a thousand tests.
6.2 Non-consecutive packet numbers
A common implementation ﬂaw is that devices do not check
whether all fragments of a frame have consecutive packet num-
bers, i. e., whether the received fragments indeed belong to the
same frame. This ﬂaw has been assigned CVE-2020-26146.2
In our tests, all devices were affected except Windows 10
when using an Intel 3160 or 8265 card, and Linux when the
kernel itself reassembles fragments (this is generally the case
with SoftMAC 802.11 drivers). This means out of 68 tested
devices that support fragmentation, 52 were vulnerable. See
the “Non-con” column in Table 1, 2, and 3 for an overview of
affected devices. Similar to the mixed key attack of Section 4,
an adversary can abuse this vulnerability by mixing fragments
of different packets in order to exﬁltrate user data. The details
of this attack are illustrated in Figure 9 in the Appendix.
The vulnerability affects CCMP and GCMP. TKIP is only
affected if the authenticity of reassembled frames is not ver-
iﬁed (see Section 6.7). The WEP protocol is vulnerable by
design, meaning this can be considered a fourth novel design
ﬂaw. Interestingly, when GCMP was introduced in 2013, its
speciﬁcation did not require that GCMP-encrypted fragments
must have a consecutive PNs [32, §11.4.3]. The 802.11 group
noticed this mistake in 2015 and updated the standard to
require this check for GCMP as well [41]. Due to this tempo-
rary design ﬂaw, Linux 4.0 to 4.4 was vulnerable when using
GCMP even when the kernel reassembled fragments [11].
2For each implementation ﬂaw we list a reference CVE identiﬁer, however,
vendors may use different CVEs because an implementation ﬂaw normally
receives a unique CVE for each affected codebase. For further details see [1].
Table 1: Devices tested using their default built-in wireless
network card and operating system. The ﬁrst three attacks
are the design ﬂaws discussed in Section 3, 4, and 5, respec-
tively. The last four attacks correspond to implementation
ﬂaws discussed in Section 6.2, 6.3, 6.4, and 6.5, respectively.
Attacks
U
D
S
M
A
-
y
e
k
d
e
x
i
M
.
t
t
a
e
h
c
a
C
.
n
o
c
-
n
o
N
.
g
a
r
f
.
n
i
a
l
P
.
g
a
r
f
.
t
s
a
c
B
l
o
p
a
e
e
k
a
F
Device
Huawei Y6 prime
Nexus 5X
Samsung i9305
iPhone XR
iPad Pro 2