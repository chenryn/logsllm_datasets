具体来说，判断请求是否为正规用户自愿发送的实现方法，有如下 3 类。
嵌入机密信息（令牌）
再次输入密码
检验 Referer
下面就让我们来依次说明。
嵌入机密信息（令牌）
如果访问需防范 CSRF 的页面（登录页面、订单确认页面等）时需要提供第三方无法得知的机密信息的话，那么即使出现非正规用户自愿发送的请求，应用端也能够通过判断得知请求是否合法。用于此目的的机密信息被称为令牌（Token）。会话 ID 就是一种既简单又安全的令牌的实现方法。
下面我们就来看一下嵌入令牌并进行检验的例子。
代码清单 嵌入令牌的例子（执行页面的前一个页面）
新密码 
">
                             └嵌入令牌
代码清单 确认令牌的例子（执行页面）
session_start();                    ┌─确认令牌
if (session_id() !== $_POST['token']) {
  die(' 请从正规的页面进行操作 '); // 显示合适的错误消息
}
// 下面将执行关键处理
通过要求提供第三方无法得知的令牌，从而成功防御了 CSRF 攻击。
在页面跳转有三次以上的情况下，如“输入－确认－执行”模式，嵌入令牌的页面也同样应当为执行页面的前一个页面。
另外，接收令牌的请求（接收关键处理的请求）必须为 POST 方法。因为假如使用 GET 方法发送机密信息的话，令牌信息就有可能通过 Referer 泄漏出去 30
 。
专栏：令牌与一次性令牌
有一种令牌叫作一次性令牌。一次性令牌使用一次后即作废。因此每当需要一次性令牌时都会生成不同的值。生成一次性令牌时通常使用密码学级别的伪随机数生成器（参考 4.6.2 节）。
一次性令牌经常被用于需要防范重放攻击（Replay Attack）的情况下。重放攻击是指，在监听得到加密的请求后，将该请求原封不动地再次发送而达到伪装的效果。一次性令牌能有效防御重放攻击。
关于一次性令牌是否应该用于 CSRF 的防范策略，目前为止还没有形成统一的认识。虽然有人主张使用一次性令牌会提升安全性，但基于以下理由，本书并不推荐使用一次性令牌。
CSRF 攻击与重放攻击毫不相干，因此并非一定要使用一次性令牌
没有证据能说明一次性令牌比使用会话 ID 作为令牌的方法更安全
使用一次性令牌有时会导致正常的操作也出错
另外，在一些介绍一次性令牌的书籍中，很多生成令牌的方法并不安全。例如，使用不安全的随机数，或者使用当前时间的方法等。这些方法都不如使用会话 ID 作为令牌值安全。
因此，应当避免自己生成一次性令牌的方法。
再次输入密码
让用户再次输入密码，也是用来确认请求是否由用户自愿发起的一种方法。
除了用来防范 CSRF 攻击，再次输入密码也可以被用于其他目的。
在用户下订单之前，再次向用户确认购买意向
能够确认此时在电脑前操作的确实是用户本人
因此，当页面有上述需求时，最好采用再次输入密码的方法来防范 CSRF。而对其他的页面（如注销处理）来说，让用户再次输入密码，反而会降低应用的易用性 31
 。
前面在讲解 CSRF 攻击时所列举的密码变更功能是安全性方面的重要功能，因此，为了再次确认操作者确实为用户本人，要求用户再次输入密码是目前非常普遍的一种方式 {32[不仅需要输入当前的密码，由于密码的输入框通常看不到输入值，为了防止输入错误，新密码的情况下一般会要求输入两遍。]}。
不论是有 3 个以上页面的“输入－确认－执行”模式，还是向导模式，要求确认密码的页面都应该是最后的执行页面。如果仅在中途的某个页面进行密码确认，根据代码实现方法还是可能会存在 CSRF 漏洞，所以要求输入密码的时机非常重要。
检验 Referer
在执行关键处理的页面确认 Referer，也是 CSRF 的一种防范策略。正如“安全隐患的产生原因”这一小节所讲述的那样，正规请求与 CSRF 攻击请求的 Referer 字段的内容不同。正规请求中 Referer 的值应该为执行页面的上一个页面（输入页面或确认页面等）的 URL，这一点一定要得到确认。下面就是检验 Referer 的示例。
if (preg_match('#\Ahttp://example\.jp/45/45-002\.php#',
               @$_SERVER['HTTP_REFERER']) !== 1) {
 die(' 请从正规的页面进行操作 ');  // 显示合适的错误消息
}
检验 Referer 的方法也存在缺陷。因为如果用户设置为不发送 Referer，页面就会无法正常显示。通过个人防火墙或浏览器的插件等禁止 Referer 的用户不在少数。另外，手机的浏览器中也有不发送 Referer 的浏览器和能够关闭发送 Referer 功能的浏览器。
另外，检验 Referer 时还容易产生疏漏，这一点一定要引起注意。例如，下面的检验就存在安全隐患。
// Referer 检验存在漏洞的示例
if (preg_match('#^http://example\.jp#', @$_SERVER['HTTP_REFERER'])
   !== 1) { // 以下为错误处理
// 能够绕过上述校验的示例 URL（域名为 example.com，而非 example.jp）
// http://example.jp.trap.example.com/trap.html
问题出在 example.jp 后面的 / 没有得到检验。检验 Referer 时，必须要使用前方一致检索检验绝对 URL，包括域名后的 /。
另一方面，检验 Referer 方法所需的代码量是最少的。因为其他两种方法都需要在 2 个页面中追加处理，而检验 Referer 方法只需要在执行关键处理的页面上追加处理即可。
综上所述，通过检验 Referer 来防范 CSRF 漏洞的方法，其适用范围应该被限定在对公司的内部系统等能够限定用户环境的既有应用实施安全隐患对策的情况。
CSRF 防范策略的比较
这里，我们对以上讲述的三种 CSRF 防范策略加以比较归纳，如表 4-12 所示。
表 4-12 CSRF 防范策略的比较
嵌入令牌
再次输入密码
确认 Referer
开发耗时
中
中 *1
小
对用户的影响
无
增加了输入密码的麻烦
关闭了 Referer 的用户无法 正常使用
能否用于手机网站
可
可
不可
建议使用的地方
最基本的防御策略，所有情况下均可使用
需要防范他人伪装或者确认需求很强的页面
用于能够限定用户环境的既有应用的 CSRF 防范策略
*1 如果作为既有系统的 CSRF 防范策略而从后期添加的话，因为需要修改页面，所以可能会非常耗时。
CSRF 的辅助性对策
执行完关键处理后，建议向用户注册的邮箱发送有关处理内容的通知邮件。
发送通知邮件虽然不能防范 CSRF 攻击，但是在万一遭受了 CSRF 攻击的情况下能在第一时间让用户知情，从而将损害降到最低。
另外，除了 CSRF 攻击之外，在攻击者通过 XSS 攻击伪装成用户操作关键处理时，发送通知邮件也能够使用户尽早发现，可谓大有裨益。
但是，由于邮件是未经加密的明文传输，因此，最好不要在邮件中添加重要信息，而只是通知用户有人恶意执行了关键处理。而如果用户想要了解详情的话，可以登录 Web 应用查看购买历史或发送历史等内容。
对策总结
CSRF 漏洞的根本性防范策略如下。
筛选出需要防范 CSRF 的页面
确认是正规用户自愿发起的请求
其中，确认请求确实由用户自愿发起的方法有以下三种。三种方法的比较请参考表 4-12。
嵌入机密信息（令牌）
再次输入密码
检验 Referer
另外，作为 CSRF 漏洞的辅助性对策，可以执行以下操作。
执行完关键处理后，向用户注册的邮箱发送通知邮件
29
 “添加到购物车”页面也需要防范 CSRF。不过，即使被第三方随意添加了购入商品，用户在付款前也应该能够察觉到。因此，如果作为一种营销模式而允许外界添加商品的话，就可以选择不对该页面执行 CSRF 防范策略。
30
 HTTP/1.1 的规格文档 RFC2616 中记载了含有更新处理的页面不应使用 GET 方法（9.1.1 节），由此可见，需要防范 CSRF 的页面本来就不应该使用 GET，而应当使用 POST 方法。
31
 注销处理对安全性的影响度较低，所以很多情况下会容许存在隐患。而且，就算针对注销处理采取 CSRF 防范策略，注销前让用户再次输入密码也会让人感觉极不自然。
4.6 不完善的会话管理
Web 应用中经常使用会话管理机制来记忆认证结果等当前状态。当今主流的会话管理机制为，使用 Cookie 等记忆会话 ID 这个标识符，而此会话 ID 的作用就相当于获取服务器端信息的钥匙。
接下来，本节就将讲述会话管理机制以及使用方法不妥善而产生的安全隐患。
4.6.1 会话劫持的原因及影响
如果由于某些原因，某用户的会话 ID 被第三方得知的话，就会出现他人伪装成该用户访问应用的危险。第三方恶意利用会话 ID 来伪装成他人的攻击手段就被称为会话劫持。
第三方获取会话 ID 的手段有如下 3 类。
预测会话 ID
窃取会话 ID
挟持会话 ID
下面我们就来分别看一下以上 3 种手段的概况。
预测会话 ID
如果生成会话 ID 的方法不妥善，用户的会话 ID 就可能会被第三方预测成功，进而造成会话劫持。第 3 章中所介绍的连续数值就是一种不妥善的会话 ID，除此之外，基于日期时间或用户名生成的会话 ID 也不安全。开源软件等生成会话 ID 的逻辑对外公开的情况下，外界就能根据代码中的逻辑推测出会话 ID，而源代码或逻辑不公开的情况下外界也有可能稍费时日从而破解出会话 ID 的生成方法。
窃取会话 ID
如果会话 ID 被外界窃取，就有可能造成会话劫持。窃取会话 ID 的方法有如下几种。
生成 Cookie 时的属性设置不妥善而遭泄漏（参考第 3 章）
会话 ID 在网络上被监听（参考 7.3 节）
由于跨站脚本等应用中的安全隐患而遭泄漏（后述）
由于 PHP 或浏览器等平台的安全隐患而遭泄漏
会话 ID 保存在 URL 中时经由 Referer 消息头泄漏（参考 4.6.3 节）
应用中能被用于窃取会话 ID 的代表性安全隐患有以下几种。
跨站脚本（XSS）（参考 4.3.1 节）
HTTP 消息头注入（参考 4.7.2 节）
嵌入在 URL 中的会话 ID（参考 4.6.3 节）
关于各隐患的详情请参考各个章节。
挟持会话 ID
除了窃取会话 ID 这种方式外，如果能将会话 ID 强制设置到用户的浏览器中，攻击者也就相当于“得知”了用户的会话 ID，因此也就能够形成会话劫持。这种攻击被称为“会话固定攻击”（Session Fixation Attack）。会话固定攻击在第 3 章已经做过概述，其防范策略等详情将于 4.6.4 节讲述。
会话劫持的方法总结
接下来，我们将以上介绍的会话劫持的方法加以归纳，如下表所示。
表 4-13 会话劫持总结
分类
攻击对象
攻击方法
安全隐患
解说
预测会话 ID
应用程序
预测会话 ID
自制会话管理机制中的安全隐患
4.6.2 节
中间件
推测会话 ID
中间件的安全隐患
7.1 节
窃取会话 ID
应用程序
XSS