# Your Cache Has Fallen: Cache-Poisoned Denial-of-Service Attack

## Authors
- Hoai Viet Nguyen
- Luigi Lo Iacono
- Hannes Federrath

### Affiliations
- **Hoai Viet Nguyen, Luigi Lo Iacono**
  - Data & Application Security Group
  - Cologne University of Applied Sciences, Germany
  - Email: {viet.nguyen, luigi.lo_iacono}@th-koeln.de
- **Hannes Federrath**
  - Security in Distributed Systems Group
  - University of Hamburg, Germany
  - Email: hannes.federrath@uni-hamburg.de

## Abstract
Web caching is a crucial component in modern distributed systems, aimed at reducing the number of requests to origin servers, minimizing network traffic, and decreasing user-perceived latency. Additionally, caches provide a layer of protection against Denial of Service (DoS) attacks. In this paper, we introduce and analyze a new class of web cache poisoning attacks, where an error on the origin server, undetected by the caching system, leads to the cache being poisoned with the server-generated error page. This results in the cache serving useless content instead of the intended resource, rendering the victim service unavailable. Our extensive study of fifteen web caching solutions reveals that one proxy cache product and five Content Delivery Network (CDN) services are vulnerable to this Cache-Poisoned DoS (CPDoS) attack. The consequences are severe, as a single request can paralyze a victim website across a large geographical region. Understanding CPDoS is essential for researchers and practitioners to develop robust and secure distributed systems.

## CCS Concepts
- **Security and privacy** → Network security; Denial-of-service attacks; Web application security.

## Keywords
- HTTP
- Web Caching
- Cache Poisoning
- Denial of Service

## ACM Reference Format
Nguyen, H. V., Lo Iacono, L., & Federrath, H. (2019). Your Cache Has Fallen: Cache-Poisoned Denial-of-Service Attack. In 2019 ACM SIGSAC Conference on Computer and Communications Security (CCS '19), November 11–15, 2019, London, United Kingdom. ACM, New York, NY, USA, 16 pages. https://doi.org/10.1145/3319535.3354215

## 1. Introduction
Contemporary distributed software systems need to scale efficiently to handle the vast number of requests from users and devices worldwide. A common architectural approach involves layering the system with intermediaries such as caches, firewalls, load balancers, and filters. Caches store frequently used resources to reduce network traffic and improve performance. They also provide additional protection against DoS attacks by serving cached content even when the origin server is offline.

A general problem in layered systems is the inconsistent interpretation of messages by different entities. This inconsistency is the root cause of "semantic gap" attacks, where an attacker exploits the difference in how two or more entities interpret a message. In the context of web caching, an attacker can generate an HTTP request with inaccurate fields that the caching system ignores but which cause an error on the origin server. The cache then stores and serves the error page, leading to a Cache-Poisoned DoS (CPDoS) attack.

We conducted an in-depth study of fifteen web caching solutions to understand the impact of CPDoS. We identified one proxy cache product and five CDN services vulnerable to CPDoS. The consequences are severe, as a single request can paralyze a victim website across a large geographical region. Awareness of CPDoS is crucial for both researchers and practitioners to develop robust and secure distributed systems.

### Contributions
1. **Introduction of CPDoS**: We present a new class of attacks, "Cache-Poisoned Denial-of-Service (CPDoS)," and systematically study the cases where error pages are generated by origin servers and stored by caching systems. We introduce three specific attack variations.
2. **Empirical Study**: We empirically study the behavior of fifteen web caching solutions in handling HTTP requests with inaccurate fields and caching resulting error pages. We disclosed our findings to affected vendors and reported them to CERT/CC.
3. **Countermeasures**: We discuss possible CPDoS countermeasures, ranging from immediate protections to long-term safeguards.

## 2. Foundations
The web is the world's largest distributed system, and caching is essential for its scalability. Web caching systems can be private (e.g., browser caches) or shared (e.g., CDNs and proxy caches). Content providers control caching policies using directives in the `Cache-Control` header, such as `max-age`, `s-maxage`, and `no-store`. Responses to GET requests with certain status codes (e.g., 200 OK, 404 Not Found) can be cached implicitly.

## 3. Security Threats in Web Caching Systems
While web caching provides many benefits, it can also be exploited to affect the privacy and reliability of applications. Common attacks include:
- **Request Smuggling**: Exploits inconsistencies in parsing duplicate headers.
- **Host of Troubles**: Exploits multiple `Host` headers.
- **Response Splitting**: Exploits parsing issues in the origin server.
- **Browser Cache Poisoning (BCP)**: Targets private caches.
- **Web Cache Deception**: Poisons shared caches with sensitive content.
- **DDoS via CDN**: Utilizes the infrastructure of a CDN to overload the origin server.

These attacks exploit the semantic gap between different layers of the system, leading to cache poisoning.

## 4. Poisoning Web Caches with Error Pages
The CPDoS attack exploits the semantic gap between a shared cache and an origin server. An attacker crafts a request with a malicious header that the cache forwards without issue, but the origin server processes and returns an error. The cache then stores and serves this error page, rendering the victim service unavailable.

### 4.1 HTTP Method Override (HMO) Attack
Some REST-based APIs use method override headers (e.g., `X-HTTP-Method-Override`) to pass through unrecognized HTTP methods. If a web application supports these headers and uses a shared cache, an attacker can exploit this to perform a CPDoS attack. For example, a GET request with an `X-HTTP-Method-Override` header set to POST will be interpreted as a POST request by the origin server, causing an error if the endpoint does not support POST.

### 4.2 Header Size Limits
Another CPDoS variation exploits header size limits. If a cache allows large headers but the origin server does not, an attacker can craft a request with oversized headers, causing an error on the origin server while the cache stores and serves the error page.

### 4.3 Parsing of Meta Characters
This variant exploits the parsing of meta characters. If a cache and origin server parse meta characters differently, an attacker can craft a request that causes an error on the origin server, leading to cache poisoning.

### Consequences
CPDoS can render parts or all of a web application unavailable. It can also block critical updates and security alerts, making it a high-risk attack. Our study of popular caching solutions and CDNs revealed that some violate RFC specifications by storing and reusing non-cacheable error messages, further highlighting the need for robust countermeasures.

## Conclusion
Understanding and mitigating CPDoS is crucial for the security and reliability of web applications. By identifying and addressing the semantic gaps in web caching systems, we can enhance the overall security of the web.

---

This version of the text is more structured, clear, and professional, with improved coherence and readability.