not take into account the information leaked when decrypting incomplete ciphertexts, that is,
ciphertexts for some, but not all, slots i ∈ [n]. Moreover, this scheme is only secure when
there is only one challenge ciphertext per pair (i, ℓ), where i ∈ [n] is an input slot, and ℓ is
a label. The construction we give in Chapter 6 is a generalization of [CDG+18a] to encrypt
vectors (instead of scalars in [CDG+18a]). Then, we deal with the limitation in the security
model that requires for complete ciphertexts only. Our solution is quite generic, as this is an
additional layer that is applied to the ciphertexts so that, unless the ciphertext is complete
(with all the encrypted components), no information leaks about the individual ciphertexts,
and thus on each component. This technique relies on a linear secret sharing scheme, hence
the name Secret Sharing Encapsulation (SSE). It can also be seen as a decentralized version
of All-Or-Nothing Transforms [Riv97, Boy99, CDH+00]. We propose a concrete instantiation
in pairing-friendly groups, under the Decisional Bilinear Diﬃe-Hellman problem, in the ran-
dom oracle model. This transformation works on any MCFE, and not only MCFE for inner
products. Secondly, we show how another independent layer of single-input functional encryp-
tion for inner products authorizes repetitions: more precisely, we remove the restriction of a
unique input per client and per label. Finally, we propose an eﬃcient decentralized algorithm
to generate a sum of private inputs, which can convert an MCFE for inner products into a
decentralized MCFE for inner products: this technique is inspired from [KDK11], and only
applies to the functional decryption key generation algorithm, and so this is compatible with
the two above conversions. The resulting scheme is completely decentralized, in the sense that
users do not need a trusted third party, even for setting up parameters (they just need to agree
on a speciﬁc pairing group and a hash function that will be used later). These techniques
used to strengthen the security of MCFE, as well as decentralize the key generation and setup,
appeared in [CDG+18b].
1.2 Functional Encryption
13
A use case. Consider a ﬁnancial ﬁrm that wants to compute aggregates of several companies’
private data (proﬁts, number of sales) so that it can better understand the dynamics of a sector.
The companies may be willing to help the ﬁnancial ﬁrm understand the sector as whole, or may
be oﬀered compensation for their help, but they don’t trust the ﬁnancial ﬁrm or each other
with their individual data. After setting up a DMCFE, each company encrypts its private
data with a time-stamp label under its private key. Together, they can give the ﬁnancial ﬁrm
a decryption aggregation key that only reveals a sum on the companies’ private data weighted
by public information (employee count, market value) for a given time-stamp. New keys can
retroactively decrypt aggregates on old data.
Private stream aggregation (PSA). This notion, also referred to as Privacy-Preserving
Aggregation of Time-Series Data, is an older primitive introduced by Shi et al. [SCR+11]. Even
though it is quite similar to our target DMCFE scheme, PSA does not consider the possibility
of adaptively generating diﬀerent keys for diﬀerent inner-product evaluations, but only enables
the aggregator to compute the sum of the clients’ data for each time period. PSA also typically
involves a Diﬀerential Privacy component, which has yet to be studied in the larger setting of
DMCFE. Further research on PSA has focused on achieving new properties or better eﬃciency
[CSS12, Emu17, JL13, LC13, LC12, BJL16] but not on enabling new functionalities.
Contribution 2.3: Functional encryption for quadratic functions.
In [BCFG17], we build the ﬁrst functional encryption scheme based on standard assump-
tions that supports a functionality beyond inner products, or predicates. Our scheme al-
lows to compute bilinear maps over the integers: messages are expressed as pairs of vectors
(x, y) ∈ Zn × Zm, secret keys are associated with n · m coeﬃcients αi,j, and decryption allows
to compute Pi,j αi,jxiyj. Bilinear maps represent a very general class of quadratic functions
that includes, for instance, multivariate quadratic polynomials. These functions have several
practical applications. For instance, a quadratic polynomial can express many statistical func-
tions (e.g. (weighted) mean, variance, covariance, root-mean-square), the Euclidean distance
between two vectors, and the application of a linear or quadratic classiﬁer (e.g., linear or
quadratic regression).
In [DGP18], we implement a functional encryption scheme for bilinear maps to perform
machine learning on encrypted data. Namely, a quadratic classiﬁer is learned on plain data,
then, a functional decryption key is generated for a function that corresponds to the quadratic
classiﬁer. Using functional encryption, users can encrypt data, and the owner of the functional
decryption key can perform classiﬁcation of the encrypted data, without ever decrypting the
data. In particular, no information apart from the result of the classiﬁcation4 is revealed about
the encrypted data. In [DGP18], the quadratic classiﬁer has an accuracy of 97.54% on MNIST
data set of hand-written digits, where encryption and decryption only take a few seconds.
In [BCFG17], we present a fully-secure construction whose security is proven in an idealized
model, called the Generic Group Model (GGM), where the adversary cannot use the structure
of the underlying pairing group. This is justiﬁed in practice, since for well-chosen elliptic
curves, the only known attacks are generic, they do not use the structure of the underlying
group. The security of the construction from [DGP18] also relies on the generic group model.
In Chapter 7, we present the construction from [BCFG17] that is proven selectively-secure
under standard assumptions, as opposed to relying on the generic group model. Note that
[AS17, Lin17] concurrently exhibited functional encryption schemes supporting the evaluation
of degree-2 polynomials, but on the arguably simpler private-key setting, where encryption
4in fact, to be technically accurate, the functional decryption keys in [DGP18] leak slightly more information
than just the result of the classiﬁcation: they leak the probability that a given instance belongs to each possible
class.
14
Chapter 1. Introduction
References
security
public or private key
[AS17]
[Lin17]
sel. GGM
private-key
sel. standard
private-key
[BCFG17, DGP18]
ad. GGM
public-key
[BCFG17]
sel. standard
public-key
Figure 1.4: Existing functional encryption for quadratic functions. Here, ad. and sel. denote
adaptive and selective security respectively and GGM stands for Generic Group Model.
requires a secret key. A comparison of existing functional encryption schemes for quadratic
functions is given in Figure 7.1.
Other contributions
In this manuscript, we focus on presenting tightly-secure encryption, and functional encryption
schemes. During this thesis, we have been also working on other topics, which led to papers
accepted in peer-reviewed conferences. We give a brief description of these contributions here.
A list of personal publications appears at the end of this manuscript.
• In [GMW15], we construct a lattice-based predicate encryption scheme for multi-dimensional
range and multi-dimensional subset queries. Our scheme is selectively-secure and weakly
attribute-hiding, and its security is based on the standard Learning With Errors (LWE)
assumption. Multi-dimensional range and subset queries capture many interesting appli-
cations pertaining to searching on encrypted data. To the best of our knowledge, these
were the ﬁrst lattice-based predicate encryption schemes for functionalities beyond IBE
and inner products.
• In [CGW15], we present a modular framework for the design of eﬃcient adaptively se-
cure attribute-based encryption (ABE) schemes for a large class of predicates under the
standard k-Lin assumption in prime-order groups; this is the ﬁrst uniform treatment of
dual system ABE across diﬀerent predicates and across both composite and prime-order
groups. Via this framework, we obtain concrete eﬃciency improvements for several ABE
schemes. Our framework has three novel components over prior works: (i) new techniques
for simulating composite-order groups in prime-order ones (ii) a reﬁnement of prior en-
codings framework for dual system ABE in composite-order groups (iii) an extension to
weakly attribute-hiding predicate encryption (which includes anonymous identity-based
encryption as a special case).
• In [GKW15], we initiate a systematic treatment of the communication complexity of
conditional disclosure of secrets (CDS), where two parties want to disclose a secret to a
third party if and only if their respective inputs satisfy some predicate. We present a
general upper bound and the ﬁrst non-trivial lower bounds for conditional disclosure of
secrets. Moreover, we achieve tight lower bounds for many interesting setting of parame-
ters for CDS with linear reconstruction, the latter being a requirement in the application
to attribute-based encryption.
In particular, our lower bounds explain the trade-oﬀ
between ciphertext and secret key sizes of several existing attribute-based encryption
schemes based on the dual system methodology.
• In [FGKO17], we build new Access Control Encryption (ACE), which is a novel paradigm
for encryption which allows to control not only what users in the system are allowed
to read but also what they are allowed to write. The original work of Damgård et
al. [DHO16] introducing this notion left several open questions, in particular whether it
1.2 Functional Encryption
15
is possible to construct ACE schemes with polylogarithmic complexity (in the number of
possible identities in the system) from standard cryptographic assumptions. In this work
we answer the question in the aﬃrmative by giving (eﬃcient) constructions of ACE for an
interesting class of predicates which includes equality, comparison, interval membership,
and more. We instantiate our constructions based both on standard pairing assumptions
(SXDH) or more eﬃciently in the generic group model.
• In [AGRW17], we present a multi-input functional encryption scheme (MIFE) for inner
products based on the k-Lin assumption in prime-order bilinear groups. Our construc-
tion works for any polynomial number of encryption slots and achieves adaptive security
against unbounded collusion, while relying on standard polynomial hardness assump-
tions. Prior to this work, we did not even have a candidate for 3-slot MIFE for inner
products in the generic bilinear group model. Our work is also the ﬁrst MIFE scheme
for a non-trivial functionality based on standard cryptographic assumptions, as well as
the ﬁrst to achieve polynomial security loss for a super-constant number of slots under
falsiﬁable assumptions. Prior works required stronger non-standard assumptions such as
indistinguishability obfuscation or multilinear maps.
• In [BCFG17], we present two practically eﬃcient functional encryption schemes for a large
class of quadratic functionalities. Speciﬁcally, our constructions enable the computation
of so-called bilinear maps on encrypted vectors. This represents a practically relevant
class of functions that includes, for instance, multivariate quadratic polynomials (over
the integers). Our realizations work over asymmetric bilinear groups and are surprisingly
eﬃcient and easy to implement. For instance, in our most eﬃcient scheme the public key
and each ciphertext consists of 2n+1 and 4n+2 group elements respectively, where n is the
dimension of the encrypted vectors, while secret keys are only two group elements. Our
two schemes build on similar ideas, but develop them in a diﬀerent way in order to achieve
distinct goals. Our ﬁrst scheme is proved (selectively) secure under standard assumptions,
while our second construction is concretely more eﬃcient and is proved (adaptively)
secure in the generic group model. As a byproduct of our functional encryption schemes,
we show new predicate encryption schemes for degree-two polynomial evaluations, where
ciphertexts consist of only O(n) group elements. This signiﬁcantly improves the O(n2)
bound one would get from predicate encryption for inner products.
• In [ABGW17], we propose, implement, and evaluate fully automated methods for proving
security of ABE in the Generic Bilinear Group Model ([BBG05, Boy08]), an idealized
model which admits simpler and more eﬃcient constructions, and can also be used to
ﬁnd attacks. Our method is applicable to Rational-Fraction Induced ABE, a large class
of ABE that contains most of the schemes from the literature, and relies on a Master
Theorem, which reduces security in the GGM to a (new) notion of symbolic security,
which is amenable to automated veriﬁcation using constraint- based techniques. We
relate our notion of symbolic security for Rational-Fraction Induced ABE to prior notions
for Pair Encodings. Finally, we present several applications, including automated proofs
for new schemes.
• In [FG18], we focus on structure-preserving signatures on equivalence classes, or equivalence-
class signatures for short (EQS), are signature schemes deﬁned over bilinear groups whose
messages are vectors of group elements. Signatures are perfectly randomizable and given
a signature on a vector, anyone can derive a signature on any multiple of the vector;
EQS thus sign projective equivalence classes. Applications of EQS include the ﬁrst
constant-size anonymous attribute-based credentials, eﬃcient round-optimal blind sig-
natures without random oracles and eﬃcient access-control encryption. To date, the
only existing instantiation of EQS is proven secure in the generic-group model. In this
work we show that by relaxing the deﬁnition of unforgeability, which makes it eﬃciently
16
Chapter 1. Introduction
veriﬁable, we can construct EQS from standard assumptions, namely the Matrix-Diﬃe-
Hellman assumptions. We then show that our unforgeability notion is suﬃcient for most
applications.
• In [GHKP18], We provide a structure-preserving signature (SPS) scheme with an (al-
most) tight security reduction to a standard assumption. Compared to the state-of-the-
art tightly secure SPS scheme of Abe et al. [AHN+17], our scheme has smaller signatures
and public keys (of about 56%, resp. 40% of the size of signatures and public keys in Abe
et al.’s scheme), and a lower security loss (of O(log Q) instead of O(λ), where λ is the se-
curity parameter, and Q = poly(λ) is the number of adversarial signature queries). While
our scheme is still less compact than structure-preserving signature schemes without tight
security reduction, it signiﬁcantly lowers the price to pay for a tight security reduction.
In fact, when accounting for a non-tight security reduction with larger key (i.e., group)
sizes, the computational eﬃciency of our scheme becomes at least comparable to that of
non-tightly secure SPS schemes. Technically, we combine and reﬁne recent existing works
on tightly secure encryption and SPS schemes. Our technical novelties include a modular
treatment (that develops an SPS scheme out of a basic message authentication code),
and a reﬁned hybrid argument that enables a lower security loss of O(log Q) (instead of
O(λ)).
• In [ACF+18], we present new constructions of multi-input functional encryption (MIFE)
schemes for the inner-product functionality that improve the state of the art solution
of Abdalla et al.
[AGRW17] in two main directions. First, we put forward a novel
methodology to convert single-input functional encryption for inner products into multi-
input schemes for the same functionality. Our transformation is surprisingly simple,
general, and eﬃcient. In particular, it does not require pairings and it can be instantiated
with all known single-input schemes. This leads to two main advances. First, we enlarge
the set of assumptions this primitive can be based on, notably obtaining new MIFEs for
inner products from plain DDH, LWE and Composite Residuosity. Second, we obtain
the ﬁrst MIFE schemes from standard assumptions where decryption works eﬃciently
even for messages of super-polynomial size. Our second main contribution is the ﬁrst
function-hiding MIFE scheme for inner products based on standard assumptions. To
this end, we show how to extend the original, pairing-based, MIFE by Abdalla et al.
[AGRW17] in order to make it function hiding, thus obtaining a function-hiding MIFE
from the MDDH assumption.
• In [GKW18], we present a new public-key broadcast encryption scheme where both the
ciphertext and secret keys consist of a constant number of group elements. Our result
improves upon the work of Boneh, Gentry, and Waters [BGW05] in two ways: (i) we
achieve adaptive security instead of selective security, and (ii) our construction relies on
the decisional k-Linear Assumption in prime-order groups (as opposed to q-type assump-
tions or subgroup decisional assumptions in composite-order groups); our improvements
come at the cost of a larger public key. Finally, we show that our scheme achieves adap-
tive security in the multi-ciphertext setting with a security loss that is independent of
the number of challenge ciphertexts.
• In [CDG+18a], we consider a situation where multiple parties, owning data that have to
be frequently updated, agree to share weighted sums of these data with some aggrega-
tor, but where they do not wish to reveal their individual data, and do not trust each
other. We combine techniques from Private Stream Aggregation (PSA) and Functional
Encryption (FE), to introduce a primitive we call Decentralized Multi-Client Functional
Encryption (DMCFE), for which we give a practical instantiation for inner products. This
primitive allows various senders to non-interactively generate ciphertexts which support
inner-product evaluation, with functional decryption keys that can also be generated
1.2 Functional Encryption
17
Interactions are required
non-interactively, in a distributed way, among the senders.
during the setup phase only. We prove adaptive security of our constructions, while
allowing corruptions of the clients, in the random oracle model.
Road-map. The rest of this thesis is organized as follows. In Chapter 2, we give the relevant
background on public-key encryption and functional encryption, including security deﬁnitions
and concrete assumptions that will be used throughout this thesis. In Chapter 3, we give our
tightly CCA-secure encryption without pairings. Then, in Chapter 4, we present our multi-
input functional encryption for inner products from pairings. In Chapter 5, we present our
multi-input functional encryption for inner products without pairings. In Chapter 6, we exhibit
our multi-client functional encryption for inner products. Finally, in Chapter 7, we present
our functional encryption for quadratic functions, before concluding in Chapter 8.
18
Chapter 1. Introduction
Chapter 2
Preliminaries
Notations and Basics
For any set S, we denote by x ←R S an element x that is picked uniformly at random over S.
Adversaries or algorithms refer to Turing machines. PPT stands for Probabilistic Polynomial
Time. For any PPT algorithm A, we denote by x ← A an output of A which is sampled at
random in the output space of A, over the random coins of A. For any Turing machine A, we
denote by T(A) its running time. Let p be a prime, and n, m ∈ N. For any matrix A ∈ Zn×m
,
we denote by Span(A) the (column) span of A. For any dimension d ∈ N, we denote by GLd(p)
the set of invertible matrices in Zd×d
. For
i . Throughout
this paper, we denote by λ the security parameter, and we use the notation 1λ to indicate
that the security parameter is written in unary basis. For any function in parameter λ, we
denote by f(λ) = poly(λ) the fact that f is a polynomial. We denote by f(λ) = negl(λ),
if for all polynomials P , f is asymptotically dominated by 1/P , that is, for λ large enough,
f(λ) < 1/P (λ).
any vector x ∈ Rd, we denote by kxk2 the Euclidian norm of x, that isqPd
i=1 x2
p
. We denote by IDd×d the identity matrix in Zd×d
p
p
Collision resistant hashing
A hash function generator is a PPT algorithm H that, on input 1λ , outputs an eﬃciently
computable function H : {0, 1}∗ → {0, 1}λ.
Deﬁnition 1: Collision Resistance
We say that a hash function generator H outputs collision-resistant hash functions H if
for all PPT adversaries A,
AdvCR
H,A(λ) := Pr[x 6= x′ ∧ H(x) = H(x′)|H ←R H(1λ), (x, x′) ← A(1λ, H)] = negl(λ).
19
20
Chapter 2. Preliminaries
Symmetric-Key Encryption