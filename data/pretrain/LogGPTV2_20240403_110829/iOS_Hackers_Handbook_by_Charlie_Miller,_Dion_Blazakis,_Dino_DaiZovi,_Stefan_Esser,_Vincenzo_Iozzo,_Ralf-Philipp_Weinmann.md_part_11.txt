The provisioning profi le is validated in the MISProvisioningProfileCheckValidity
function in the libmis dynamic library, which can be found in the dyld_shared_
cache. You’ll see this important library again later. This function verifi es the
following information about the profi le before accepting it:
n The signing certifi cate must be issued by the Apple iPhone Certifi cate
Authority.
n The signing certifi cate must be named Apple iPhone OS Provisioning
Profi le Signing.
n The certifi cate signing chain must be no longer than three links.
n The root certifi cate must have a particular SHA1 hash value.
n The version number of the profi le must be 1.
n The UDID of the device must be present or the profi le must contain the
ProvisionsAllDevices key.
n The profi le must not be expired.
cc0044..iinndddd 7777 44//1166//22001122 55::4433::4499 PPMM
78 Chapter 4 n Code Signing and Memory Protections
Understanding Application Signing
Xcode can be used to sign apps that are going to be used by developers. These
apps run only on devices with the associated provisioning profi le. If you look
at such an app with the codesign tool, you will see why:
$ codesign -dvvv test-dyld.app
Executable=/Users/cmiller/Library/Developer/Xcode/DerivedData/ip
hone-payload/Products/Debug-iphoneos/test-dyld.app/test-dyld
Identifier=Accuvant.test-dyld
Format=bundle with Mach-O thin (armv7)
CodeDirectory v=20100 size=287 flags=0x0(none) hashes=6+5
location=embedded
Hash type=sha1 size=20
CDHash=977d68fb31cfbb255da01b401455292a5f89843c
Signature size=4287
Authority=iPhone Developer: Charles Miller (7URR5G4CD1)
Authority=Apple Worldwide Developer Relations Certification
Authority
Authority=Apple Root CA
Signed Time=Sep 9, 2011 3:30:50 PM
Info.plist entries=26
Sealed Resources rules=3 files=5
Internal requirements count=1 size=208
This code reveals that the application is signed by an individual developer,
in this case Charles Miller. This app will be rejected on phones without the cor-
rect provisioning profi le. If this app is submitted to the Apple App Store, and
it is approved, Apple would sign it and make it available for download. In this
case, it could be run on any device, which you can see:
$ codesign -dvvv AngryBirds.app
Executable=/Users/cmiller/book/iphone-
book2/AngryBirds.app/AngryBirds
Identifier=com.clickgamer.AngryBirds
Format=bundle with Mach-O thin (armv6)
CodeDirectory v=20100 size=19454 flags=0x0(none) hashes=964+5
location=embedded
Hash type=sha1 size=20
CDHash=8d41c1d2f2f1edc5cd66b2ee8ba582f1d41163ac
Signature size=3582
Authority=Apple iPhone OS Application Signing
Authority=Apple iPhone Certification Authority
Authority=Apple Root CA
Signed Time=Jul 25, 2011 6:43:55 AM
Info.plist entries=29
Sealed Resources rules=5 files=694
Internal requirements count=2 size=320
Now, the app is signed by the Apple iPhone OS Application Signing authority,
which is accepted by default on all devices.
cc0044..iinndddd 7788 44//1166//22001122 55::4433::4499 PPMM
Chapter 4 n Code Signing and Memory Protections 79
The executables that ship on an iPhone may be signed like the App Store apps,
but typically, they are signed with an ad hoc method as shown here:
$ codesign -dvvv CommCenter
Executable=/Users/cmiller/book/iphone-book2/CommCenter
Identifier=com.apple.CommCenter
Format=Mach-O thin (armv7)
CodeDirectory v=20100 size=6429 flags=0x2(adhoc) hashes=313+5
location=embedded
Hash type=sha1 size=20
CDHash=5ce2b6ddef23ac9fcd0dc5b873c7d97dc31ca3ba
Signature=adhoc
Info.plist=not bound
Sealed Resources=none
Internal requirements count=1 size=332
Alone, this important executable would not execute, because it is not signed.
However, as you see shortly, there are other ways besides having a particular
signature, that code is still trusted. In this case, the binary’s hash is baked right
into the kernel in the static trust cache. Executables whose hashes are contained
in the static trust cache are automatically allowed to execute as if they had a
valid and accepted signature.
Inside Entitlements
Signed applications may also contain a plist fi le specifying a set of entitlements
to grant the application. Using the ldid tool, produced by Saurik, you can list
the set of entitlements for a given application:
# ldid -e AngryBirds
application-identifier
G8PVV3624J.com.clickgamer.AngryBirds
aps-environment
production
keychain-access-groups
G8PVV3624J.com.clickgamer.AngryBirds
The application identifi er provides a unique prefi x for each application. The
keychain-access group provides a way for apps to secure their data. Entitlements
provide a mechanism for some apps to have more or fewer privileges than other
apps, even if they are running as the same user and have the same sandbox
cc0044..iinndddd 7799 44//1166//22001122 55::4433::5500 PPMM
80 Chapter 4 n Code Signing and Memory Protections
rules. Also, as discussed earlier, the entitlements that can be given out are a
function of the provisioning profi le, and so Apple can not only limit the func-
tionality of certain apps, but can also limit the functionality of all apps written
by a particular developer.
For another example, consider gdb, the GNU debugger, which you can get
from the iOS SDK:
# ldid -e /usr/bin/gdb
com.apple.springboard.debugapplications
get-task-allow
task_for_pid-allow
You’ll notice that gdb has a few additional entitlements that are necessary to
allow it to debug other applications. You learn about another entitlement, dynamic-
codesigning, in the upcoming section “Understanding Dynamic Code Signing”.
How Code Signing Enforcement Works
The actual code signing enforcement takes place in the kernel’s virtual memory
system. Individual memory pages, as well as the process as a whole, are examined
to see if they originate from signed code.
Collecting and Verifying Signing Information
When executable code is loaded, it is examined by the kernel to see if it contains
a code signature, stored with the LC_CODE_SIGNATURE load command:
$ otool -l CommCenter | grep -A 5 SIGN
cmd LC_CODE_SIGNATURE
cmdsize 16
dataoff 1280832
datasize 7424
The kernel code, which looks for this and parses it, is found in XNU’s bsd/
kern/mach_loader.c in the parse_machfile function:
parse_machfile(
struct vnode *vp,
cc0044..iinndddd 8800 44//1166//22001122 55::4433::5500 PPMM
Chapter 4 n Code Signing and Memory Protections 81
vm_map_t map,
thread_t thread,
struct mach_header *header,
off_t file_offset,
off_t macho_size,
int depth,
int64_t aslr_offset,
load_result_t *result
)
{
...
case LC_CODE_SIGNATURE:
/* CODE SIGNING */
...
ret = load_code_signature(
(struct linkedit_data_command *) lcp,
vp,
file_offset,
macho_size,
header->cputype,
(depth == 1) ? result : NULL);
The actual loading of the signature is performed in the load_code_
signature function:
static load_return_t
load_code_signature(
struct linkedit_data_command *lcp,
struct vnode *vp,
off_t macho_offset,
off_t macho_size,
cpu_type_t cputype,
load_result_t *result)
{
...
kr = ubc_cs_blob_allocate(&addr, &blob_size);
...
ubc_cs_blob_add(vp,
cputype,
macho_offset,
addr,
lcp->datasize))
...
And the ubc_cs_blob_add function checks whether the signature is acceptable:
int
ubc_cs_blob_add(
struct vnode *vp,
cpu_type_t cputype,
cc0044..iinndddd 8811 44//1166//22001122 55::4433::5500 PPMM
82 Chapter 4 n Code Signing and Memory Protections
off_t base_offset,
vm_address_t addr,
vm_size_t size)
{
...
/*
* Let policy module check whether the blob’s signature
* is accepted.
*/
#if CONFIG_MACF
error = mac_vnode_check_signature(vp, blob->csb_sha1,
(void*)addr, size);
if (error)
goto out;
#endif
Finally, AMFI performs the actual code signing checks inside the hooking
function vnode_check_signature. Figure 4.6 is a decompilation of that function.
Figure 4.6: Decompilation of amfi_vnode_check_signature
cc0044..iinndddd 8822 44//1166//22001122 55::4433::5500 PPMM
Chapter 4 n Code Signing and Memory Protections 83
The code shown in Figure 4.6 checks in the trust caches, and if it cannot
fi nd that it is trusted in these, it calls out to a userspace daemon to determine
whether it is properly signed. Figure 4.7 shows how the static trust cache looks.
Figure 4.7: Decompilation of code that checks the static trust cache
The static trust cache is actually contained right in the kernel. You can see it
in IDA Pro. (See Figure 4.8.)
Figure 4.8: The static trust cache in the kernel
cc0044..iinndddd 8833 44//1166//22001122 55::4433::5500 PPMM
84 Chapter 4 n Code Signing and Memory Protections
The check for dynamic trust is similar, except that trust data is not static
but is loaded dynamically. For items that are not in either of these two caches,
AMFI asks the userspace daemon amfi d, using Mach RPC, if the code signature
is valid. amfi d has two subroutines accessible over Mach RPC. The one that is
called in vnode_check_signature is verify_code_directory. This function
calls MISValidateSignature in libmis.dylib, which calls SecCMSVerify in the
Security Framework for the actual verifi cation.
How Signatures Are Enforced on Processes
The code signing validity of a process is tracked in the kernel’s csflags member
of the proc structure for each process. For example, whenever there is a page
fault, the function vm_fault is called. vm_fault_enter calls functions that are
responsible for checking the code signing of executable pages. Note that a page
fault is generated any time a page is loaded into the virtual memory system,
including when it is initially loaded.
To see the code responsible for doing this checking and enforcement, examine
vm_fault, which is in ./osfmk/vm/vm_fault.c:
kern_return_t
vm_fault(
vm_map_t map,
vm_map_offset_t vaddr,
vm_prot_t fault_type,
boolean_t change_wiring,
int interruptible,
pmap_t caller_pmap,
vm_map_offset_t caller_pmap_addr)
{
...
kr = vm_fault_enter(m,
pmap,
vaddr,
prot,
fault_type,
wired,
change_wiring,
fault_info.no_cache,
fault_info.cs_bypass,
&type_of_fault);
...
And within vm_fault_enter, this is what you see:
vm_fault_enter(vm_page_t m,
pmap_t pmap,
vm_map_offset_t vaddr,
vm_prot_t prot,
vm_prot_t fault_type,
cc0044..iinndddd 8844 44//1166//22001122 55::4433::5500 PPMM
Chapter 4 n Code Signing and Memory Protections 85
boolean_t wired,
boolean_t change_wiring,
boolean_t no_cache,
boolean_t cs_bypass,
int *type_of_fault)
{
...
/* Validate code signature if necessary. */
if (VM_FAULT_NEED_CS_VALIDATION(pmap, m)) {
vm_object_lock_assert_exclusive(m->object);
if (m->cs_validated) {
vm_cs_revalidates++;
}
vm_page_validate_cs(m);
}