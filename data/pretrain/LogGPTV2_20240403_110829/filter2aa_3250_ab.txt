qemu-kvm process.
So we allocate an object in the guest, and compute
hva = physmem_base
+ (gva_to_gfn(gva) cb at the desired %rip.
Set ->expire to something small (e.g. 0).
2 Calculate its address in the host.
3 Write 2 to IO port 0xae08 to eject the ISA bridge.
4 ping the emulated gateway with ICMP packets containing pointers to
your allocated timer in the host.
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
25 / 42
virtunoid.c: The exploit
Getting to shellcode
We’ve got %rip, now what?
Options:
Get EIP = 0x41414141 and declare victory.
Disable NX in my BIOS and call it good enough for a demo.
Do a ROP pivot, ROP to victory.
????
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
26 / 42
virtunoid.c: The exploit
Getting to shellcode
Another look at QEMUTimer
s t r u c t QEMUTimer {
. . .
s t r u c t QEMUTimer * next ;
. . .
};
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
27 / 42
virtunoid.c: The exploit
Getting to shellcode
qemu_run_timers
s t a t i c
void
qemu run timers (QEMUClock * clock )
{
QEMUTimer ** ptimer head ,
* t s ;
i n t 6 4 t
c u r r e n t t i m e ;
c u r r e n t t i m e = qemu get clock ns ( clock ) ;
ptimer head = &a c t i v e t i m e r s [ clock −>type ] ;
f o r ( ; ; )
{
t s = * ptimer head ;
i f
( ! qemu timer expired ns ( ts ,
c u r r e n t t i m e ))
break ;
* ptimer head = ts−>next ;
ts−>next = NULL;
ts−>cb ( ts−>opaque ) ;
}
}
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
28 / 42
virtunoid.c: The exploit
Getting to shellcode
Timer chains
We don’t just control %rip – we control a QEMUTimer object that is
going to get dispatched by qemu_run_timers.
In particular, we can control ->next.
So we can chain fake timers, and make multiple one-argument calls in
a row.
We can fake other structs to get the ﬁrst argument.
qemu_run_timers doesn’t touch %rsi in any version of qemu-kvm
I’ve examined.
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
29 / 42
virtunoid.c: The exploit
Getting to shellcode
Getting to mprotect
Find a function (“F”) that makes a three-arg function call based on
struct(s) passed as arguments one and two.
Construct appropriate fake structures.
Construct a timer chain that
Does a call to set up %rsi based on a ﬁrst argument in %rdi.
Does a call to F that mprotect()s one or more pages in the guest
physmem map.
Calls shellcode stored in those pages.
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
30 / 42
virtunoid.c: The exploit
Getting to shellcode
Why this trickery?
Continued execution is dead simple.
Reduced dependence on details of compiled code.
I’m not that good at ROP :)
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
31 / 42
virtunoid.c: The exploit
Bypassing ASLR
Addresses
We need at least two addresses
The base address of the qemu-kvm binary, to ﬁnd code addresses.
physmem_base, the address of the physical memory mapping inside
qemu-kvm.
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
32 / 42
virtunoid.c: The exploit
Bypassing ASLR
Option A
Find an information leak.
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
33 / 42
virtunoid.c: The exploit
Bypassing ASLR
Option B
Assume non-PIE, and be clever.
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
34 / 42
virtunoid.c: The exploit
Bypassing ASLR
fw_cfg
Emulated IO ports 0x510 (address) and 0x511 (data)
Used to communicate various tables to the qemu BIOS (e820 map,
ACPI tables, etc)
Also provides support for exporting writable tables to the BIOS.
However, fw_cfg_write doesn’t check if the target table is supposed
to be writable!
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
35 / 42
virtunoid.c: The exploit
Bypassing ASLR
hw/pc.c
s t a t i c
s t r u c t
e 8 2 0 t a b l e
e 8 2 0 t a b l e ;
s t r u c t
h p e t f w c o n f i g
h p e t c f g = {. count = UINT8 MAX};
. . .
fw cfg = f w c f g i n i t (BIOS CFG IOPORT , BIOS CFG IOPO
f w c f g a d d b y t e s ( fw cfg , FW CFG E820 TABLE ,
( u i n t 8
s i z e o f ( s t r u c t
e 8 2 0 ta b l e ) ) ;
f w c f g a d d b y t e s ( fw cfg , FW CFG HPET,
( u i n t 8 t
*)&
s i z e o f ( s t r u c t
h p e t f w c o n f i g ) ) ;
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
36 / 42
virtunoid.c: The exploit
Bypassing ASLR
read4 your way to victory
Net result: nearly 500 writable bytes inside a static variable.
mprotect needs a page-aligned address, so these aren’t suitable for
our shellcode.
But, we can construct fake timer chains in this space to build a
read4() primitive.
Use that to ﬁnd physmem_base
Proceed as before.
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
37 / 42
virtunoid.c: The exploit
Bypassing ASLR
Repeated timer chaining
Previously, we ended timer chains with ->next = NULL.
Instead, end them with a timer that calls rtc_update_second to
reschedule the timer every second.
Now we can execute a read4, update structures based on the result,
and then hijack the list again.
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
38 / 42
Conclusions and further research
Possible hardening directions
Sandbox qemu-kvm (work underway well before this talk).
Build qemu-kvm as PIE.
Keep memory in a ﬁle in tmpfs and lazily mmap as-needed for DMA?
XOR-encode key function pointers?
More auditing and fuzzing of qemu-kvm!
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
39 / 42
Conclusions and further research
Future research directions
Fuzzing/auditing kvm.ko (That x86 emulator sketches me)
Fingerprinting qemu-kvm versions
Searching for infoleaks (Rosenbugs?)
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
40 / 42
Demo
It’s demo time
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
41 / 42
Demo
Questions?
Nelson Elhage ()
Virtunoid: Breaking out of KVM
July 25, 2011
42 / 42