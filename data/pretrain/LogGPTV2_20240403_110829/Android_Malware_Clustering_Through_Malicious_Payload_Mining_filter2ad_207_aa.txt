title:Android Malware Clustering Through Malicious Payload Mining
author:Yuping Li and
Jiyong Jang and
Xin Hu and
Xinming Ou
Android Malware Clustering Through
Malicious Payload Mining
Yuping Li1(B), Jiyong Jang2, Xin Hu3, and Xinming Ou1
1 University of South Florida, Tampa, USA
PI:EMAIL, PI:EMAIL
2 IBM Research, Yorktown Heights, USA
PI:EMAIL
3 Pinterest, San Francisco, USA
PI:EMAIL
Abstract. Clustering has been well studied for desktop malware analy-
sis as an eﬀective triage method. Conventional similarity-based clus-
tering techniques, however, cannot be immediately applied to Android
malware analysis due to the excessive use of third-party libraries in
Android application development and the widespread use of repackaging
in malware development. We design and implement an Android mal-
ware clustering system through iterative mining of malicious payload
and checking whether malware samples share the same version of mali-
cious payload. Our system utilizes a hierarchical clustering technique and
an eﬃcient bit-vector format to represent Android apps. Experimental
results demonstrate that our clustering approach achieves precision of
0.90 and recall of 0.75 for Android Genome malware dataset, and aver-
age precision of 0.98 and recall of 0.96 with respect to manually veriﬁed
ground-truth.
1 Introduction
Triaging is an important step in malware analysis given the large number of
samples received daily by security companies. Clustering, or grouping malware
based on behavioral proﬁles is a widely-studied technique that allows analysts
to focus their eﬀorts on new types of malware. Multiple static [14,30], dynamic
[2,22], and hybrid [12] analysis based clustering techniques have been proposed
in the desktop malware domain.
With the rapid growth of Android smart devices, malicious Android apps
have become a persistent problem. Security companies receive a list of (poten-
tial zero-day) malware on a daily basis [28]. Those apps that present certain
suspicious behaviors but are not detected by any existing anti-virus scanners
need to be further analyzed manually. Conducting clustering on those incoming
Electronic supplementary material The online version of this chapter (doi:10.
1007/978-3-319-66332-6 9) contains supplementary material, which is available to
authorized users.
c(cid:2) Springer International Publishing AG 2017
M. Dacier et al. (Eds.): RAID 2017, LNCS 10453, pp. 192–214, 2017.
DOI: 10.1007/978-3-319-66332-6 9
Android Malware Clustering Through Malicious Payload Mining
193
malware apps can allow the analysts to triage their tasks by (a) quickly identify-
ing malware that shares similar behaviors with known existing malware so they
may not allocate much resources on it; and (b) selecting a few representative
apps from each new malware cluster to prioritize their analysis.
We often observe that existing approaches to group Android malware based
on their behaviors have provided limited capabilities. For example, existing
Android malware detection products may report a family name for a detected
sample; however, samples from one family can have multiple diﬀerent versions of
malicious code segments presenting signiﬁcantly diﬀerent behaviors. Therefore,
the malware family information provided by AV products can be incomplete to
describe crucial malicious code segments of Android malware.
Existing overall similarity analysis based clustering system cannot be imme-
diately applied for Android malware clustering because the malicious code seg-
ments often constitute only a small fraction of an Android malware sample. In
desktop malware clustering, the static or dynamic features are ﬁrst extracted
from target samples. Then a clustering algorithm (e.g., hierarchical agglomer-
ative clustering) is applied to group the samples such that samples within the
same resulting group share high level of overall similarity. However, we note
that overall similarity analysis performs poorly in Android malware clustering
because of two common practices in Android malware development.
The ﬁrst practice is repackaging. Malware writers may embed the malicious
code inside an otherwise legitimate app, in which case the real malicious code
segment is likely to be small compared to the original benign app. Our analysis
shows that the ratio of the core malicious code segments to the entire app for a
collection of 19,725 malware samples is between 0.1% and 58.2%. Given the small
percentage of malicious code segments, the conventional clustering approach that
is based on overall code similarity will not work well. For example, two malicious
samples from diﬀerent families can be repackaged based on the same original
benign app, thus presenting high level of overall similarity. Likewise, Android
malware variants with the same malicious code of one family can be repackaged
into diﬀerent original benign apps, thus presenting low level of overall similarity.
Another practice is utilizing shared library code. Android apps often include
a variety of third-party libraries to implement extra functionalities in a cost-
eﬀective way. If the library code size is too large compared to the rest of the
app, samples from diﬀerent malware families may be clustered together simply
because they share the same libraries. We measured the library code proportion
of the 19,725 malware samples. For 13,233 of the samples that used at least
one legitimate library, we found that the average library code ratio is 53.1% in
terms of number of byte code instructions. This means a large portion of an
Android app belongs to libraries. One approach to prevent those libraries from
“diluting” the malicious code segments is to use a whitelist [4–6,8,10] to exclude
all library code. However, previous work leverages only the names of libraries
while building a whitelist as opposed to the content of libraries. We observed that
malware authors injected their malicious code under popular library names, such
as com.google.ssearch, com.android.appupdate, android.ad.appoffer, and
194
Y. Li et al.
com.umeng.adutils. Consequently, na¨ıve whitelisting approaches inadvertently
remove certain malicious payloads together with the legitimate library code from
analysis. We found that about 30% of our analyzed Android malware families
disguise their malicious payload under popular library names.
Due to the above two reasons, directly applying overall similarity analysis on
Android apps will not be eﬀective for Android malware analysis. A major chal-
lenge is to precisely identify the malicious code segments of Android malware.
For simplicity, we refer to the core malicious code segments of Android malware
as malicious payload. A payload can be an added/modiﬁed part of a repack-
aged malware app, or the entire code of “standalone” malware app excluding
legitimate library code.
In this paper we propose an Android malware clustering approach through
iterative mining of malicious payloads. Our main contributions include:
1. We design and implement an Android malware clustering solution through
checking if apps share the same version of the malicious payloads. By recon-
structing the original malicious payloads, our approach oﬀers an eﬀective
Android malware app clustering solution along with fundamental insights
into malware grouping.
2. We design a novel method to precisely remove legitimate library code from
Android apps, and still preserve the malicious payloads even if they are
injected under popular library names.
3. We conduct extensive experiments to evaluate the consistency and robustness
of our clustering solution. Our experimental results demonstrate that our
clustering approach achieves precision of 0.90 and recall of 0.75 for Android
Genome malware dataset, and average precision of 0.984 and recall of 0.959
regarding manually veriﬁed ground-truth.
2 Overview of Android Malware Clustering System
Rather than directly conducting overall similarity analysis between Android mal-
ware samples, we ﬁrst design a solution to precisely remove legitimate library
code from Android apps. We consider the shared code segments (excluding legit-
imate library code) between the analyzed Android apps as candidate payload,
and ﬁnd all of the input Android apps through pairwise intersection analysis. For
a group of n apps, each input app will contribute to n − 1 versions of candidate
payloads.
After extracting all candidate payloads, we conduct traditional clustering
analysis on all candidate payloads to group similar ones together. Base on sev-
eral key insights that are learned from analyzing candidate payload clustering
results, we design an eﬀective approach to iteratively mine the payload clusters
that are most likely to be malicious, and make sure that each input app will
only contribute one version of malicious payload. Finally, we use the identiﬁed
malicious payload clusters and payload-to-app association information to group
the input Android malware apps. We describe this process in more details below.
Android Malware Clustering Through Malicious Payload Mining
195
(1)
fp1
fp2
fp3
fp4
fp5
App FPs
Pairwise
Intersec(cid:415)on
(2)
fp1-2
fp1-3
fp1-4
fp1-5
fp2-3
fp2-4
fp2-5
fp3-4
fp3-5
fp4-5
Clustering 
Analysis
(3)
fp1-2
fp1-3
fp2-3
fp3-5
fp3-4
fp1-4
fp4-5
fp2-5
fp2-4
fp1-5
Candidate 
Payload FPs
All Payload Clusters
Itera(cid:415)ve 
Selec(cid:415)ng
“Mined” Clusters
(4)
(size > 1)
fp1-2
fp1-3
fp2-3
Skipped 
Clusters
(size = 1)
fp4-5
(5)
App Clusters
1,2,3
Associate
Fig. 1. Overview of the clustering system with ﬁve Android malware samples.
Figure 1 illustrates the overview of the clustering analysis system with ﬁve
malware samples.
1. Library code removal: We convert malware samples into ﬁngerprint rep-
resentation, and design an eﬀective approach to precisely remove legitimate
library code from each app ﬁngerprint. We denote the library-removed app
ﬁngerprints as fp1, fp2, fp3, fp4, and fp5 accordingly.
2. Candidate payloads extraction: We conduct a pairwise intersection analy-
sis to extract all shared code segments (e.g., candidate payloads) between
input apps. Relying on the app ﬁngerprint representation, we create candidate
payload ﬁngerprints, and record the payload-to-app association information.
For example, fp1-2 indicates that this candidate payload is extracted from
malware sample 1 and 2.
3. Candidate payloads clustering: We then perform hierarchical clustering
on all candidate payloads with a predeﬁned clustering similarity threshold θ,
e.g., the candidate payload ﬁngerprints fp1-2, fp1-3, and fp2-3 are grouped
together as the largest payload cluster based on the overall payload similarity.
4. Malicious payload mining: After removing legitimate libraries, similar
malicious payloads extracted from samples in the same malware family will
become more popular1 due to the “legitimate” reason of code reuse. Therefore,
we design an iterative approach to mine the popular payload clusters from the
clustering results, which are more likely malicious payload. For instance, can-
didate payload cluster containing fp1-2, fp1-3, and fp2-3 is selected as the most
popular cluster. To ensure that each input app only contributes one version
of ﬁnal malicious payload, we simultaneously update the remaining payload
clusters. e.g., ﬁngerprints fp1-4, fp1-5, fp2-4, fp2-5, fp3-4, and fp3-5 are then
skipped because malware sample 1, 2 and 3 have already been “used”.
5. Malicious samples grouping: We group the original Android samples
based on payload mining results and payload-to-app association information
such that the samples within each app cluster contains the same version of
the malicious payload. For example, malware samples 1, 2, and 3 are grouped
together based on the selected candidate payload cluster containing fp1-2,
fp1-3, and fp2-3.
1 Further intuition explanation and popularity criteria are included in Sect. 4.
196
Y. Li et al.
3 App Fingerprint Representation and Utilization
As we can see from Sect. 2, the clustering system requires an eﬀective ﬁngerprint
representation to denote input Android apps and candidate payloads. Ideally,
the ﬁngerprint needs to be constructed from the code segments of the input app
and support two fundamental operations: precisely removing legitimate code,
correctly extracting shared app code.
Based on these requirements, we decide to represent Android apps as bit-
vector ﬁngerprints, by encoding the features that are extracted from app code
through feature hashing [13,14,26]. The value of each bit in the generated ﬁn-
gerprint is either 0 or 1, indicating whether the corresponding app has a speciﬁc
feature or not.
This bit-vector format enables us to precisely remove legitimate library code
(Sect. 3.2), extract shared code segments (Sect. 3.3), and reconstruct the original
malicious payload (Sect. 3.4) by utilizing the bit manipulation capability.
3.1 Fingerprint Generation and Fingerprint Comparison
In this work, we use n-gram sequence of Dalvik bytecode to denote an Android
app feature, and use a bit-vector ﬁngerprint to represent the extracted features.
The overall ﬁngerprint generation process is shown in Fig. 2.
Android  
Applica(cid:415)on
Preprocessed Dalvik 
Bytecode Sequences
2-gram Features 
1
1. if-eqz 
2, if-nez
3, iget-object
4, invoke-direct 
5, invoke-virtual
6, iput-object
7. imove-result
…..
2
1. if-eqz, if-nez
2, if-nez,iget-object 
3, iget-object,invoke-direct 
4, invoke-direct,invoke-virtual
5. invoke-virtual, iput-object
6. iput-object, move-result
…..
3
Fig. 2. Overall ﬁngerprint generation procedure
Applica(cid:415)on 
Fingerprint
1
0
1
1
0
1
0
1
0
1
For each Android app, we ﬁrst use Dexdump [7] to disassemble classes.dex
into Dalvik bytecode, then preprocess the Dalvik bytecode sequences to only
include the major distinctive information and extract the n-gram features from
the preprecessed bytecode sequences. We follow similar approach to extract the
distinctive information (e.g., bytecode opcode) for feature construction as Jux-
tapp [11]. Since feature space is vital to support the key operations designed in
this work, we decide to increase the feature space by including more generic but
meaningful information from each bytecode instruction. The major distinctive
information is separated into 4 categories and summarized in Table 1. Besides the
feature diﬀerences shown in Table 1, we extract the n-gram features at the func-
tion level, while Juxtapp extracts n-gram features at the basic block level. For
simplicity, we only show the Dalvik bytecode opcode sequences as the distinctive
instruction information in Fig. 2.
Android Malware Clustering Through Malicious Payload Mining
197
Table 1. Major feature categories and main diﬀerences comparing with Juxtapp
Feature category
Dalvik bytecode opcode sequences
Java VM type signatures
String value of const-string
instructions
Type signatures for “invoked”
functions
Examples
Our approach Juxtapp
(cid:2)
sget, goto, return
Z(Boolean), B(byte) (cid:2)
(cid:2)
–
(cid:2)
f(I,[B)Z
(cid:2)
After extracting all the n-gram features, we then encode all the features in