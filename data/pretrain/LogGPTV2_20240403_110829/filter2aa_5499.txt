### 背包问题概述
首先，我们先来介绍一下背包问题，假定一个背包可以称重 W，现在有 n 个物品，其重量分别为 $a_1, a_2,...,a_n$ 我们想问一下装哪些物品可以恰好使得背包装满，并且每个物品只能被装一次。这其实就是在解这样的一个问题
$$
x_1a_1+x_2a_2+,...,+x_na_n=W
$$
其中所有的 $x_i$ 只能为 0 和 1。显然我们必须枚举所有的 n 个物品的组合才能解决这个问题，而复杂度也就是 $2^n$，这也就是背包加密的妙处所在。
在加密时，如果我们想要加密的明文为 x，那么我们可以将其表示为 n 位二进制数，然后分别乘上 $a_i$ 即可得到加密结果。
但是解密的时候，该怎么办呢？我们确实让其他人难以解密密文，但是我们自己也确实没有办法解密密文。
但是当 $a_i$ 是超递增的话，我们就有办法解了，所谓超递增是指序列满足如下条件
$$
a_i>\sum_{k=1}^{i-1}a_k
$$
即第 i 个数大于前面所有数的和。
为什么满足这样的条件就可以解密了呢？这是因为如果加密后的结果大于 $a_n$ 的话，其前面的系数为必须 1 的。反之，无论如何也无法使得等式成立。因此，我们可以立马得到对应的明文。
但是，这样又出现了一个问题，由于 $a_i$ 是公开的，如果攻击者截获了密文，那么它也就很容易去破解这样的密码。为了弥补这样的问题，就出现了 Merkle–Hellman 这样的加密算法，我们可以使用初始的背包集作为私钥，变换后的背包集作为公钥，再稍微改动加密过程，即可。
这里虽然说了超递增序列，但是却没有说是如何生成的。
### Merkle–Hellman的公私钥生成
#### 生成私钥
私钥就是我们的初始的背包集，这里我们使用超递增序列，怎么生成呢？我们可以假设 $a_1=1$，那么 $a_2$ 大于 1 即可，类似的可以依次生成后面的值。
#### 生成公钥
在生成公钥的过程中主要使用了模乘的运算。
首先，我们生成模乘的模数 m，这里要确保
$$
m>\sum_{i=1}^{i=n}a_i
$$
其次，我们选择模乘的乘数 w，作为私钥并且确保
$$
gcd(w,m)=1
$$
之后，我们便可以通过如下公式生成公钥
$$
b_i \equiv w a_i \bmod m
$$
并将这个新的背包集 $b_i$ 和 m 作为公钥。
### Merkle–Hellman的加解密过程
#### 加密
假设我们要加密的明文为 v，其每一个比特位为 $v_i$，那么我们加密的结果为
$$
\sum_{i=1}^{i=n}b_iv_i \bmod m
$$
#### 解密
对于解密方，首先可以求的 w 关于 m 的逆元 $w^{-1}$。
然后我们可以将得到的密文乘以 $w^{-1}$ 即可得到明文，这是因为
$$
\sum_{i=1}^{i=n}w^{-1}b_iv_i \bmod m=\sum_{i=1}^{i=n}a_iv_i \bmod m
$$
这里有
$$
b_i \equiv w a_i \bmod m
$$
对于每一块的加密的消息都是小于 m 的，所以求得结果自然也就是明文了。
### Merkle–Hellman的破解
该加密体制在提出后两年后该体制即被破译，破译的基本思想是我们不一定要找出正确的乘数 w（即陷门信息），只需找出任意模数 `m′` 和乘数 `w′`，只要使用 `w′` 去乘公开的背包向量 B 时，能够产生超递增的背包向量即可。