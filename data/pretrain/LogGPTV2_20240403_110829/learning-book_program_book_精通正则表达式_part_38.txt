测试与回潮
我们将看到的例子代表了使用正则表达式时经常遇到的情况。在分析某个的正则表达式的
效率时，我有时会列出正则引擎在匹配过程中进行的独立测试（individualtest）的次数。如
果用正则表达式martyi匹配smarty，一共会进行6次独立测试，首先是m对s（匹配失
败），然后是m对m，ai对a，依次继续。我通常会给出回溯的次数（本例中回溯次数为0，
不过，正则引擎的传动装置必然会在第二个字符处重试正则表达式，这或许可以算作一次
回溯）
之所以要列出这些数字，并不是为表明精确性，而是因为它们比“许多”、“少量”、“多次”、
“更好”、“不太多”之类更为准确。我的意思不是说，在NFA上使用正则表达式需要精确
地考察测试和回溯的次数，我只是希望让读者知道这些例子的相对优劣。
另一个重要的问题是，你必须意识到这些“精确”的数字可能根据工具的不同而有所不同。
我期望读者能够知道，它只是针对具体例子的、相对的粗略表现。不同工具之间的一个重
要区别就是，它们可能使用的优化措施不同。如果能够预先判断目标字符串基本无法匹配
（例如目标字符事缺少一个引擎能够预知的，匹配成功必须的字符），足够聪明的实现方式
可以完全不应用正则表达式。我在本章讨论了这些重要的优化措施，不过普遍原理比具体
问题更为重要。
传统型NFA还是POSIXNFA
在分析效率时，一定不要忘记所使用工具的引擎类型：传统型NFA还是POSIXNFA。下~
节中我们会看到，有些问题只对某种引擎存在。有的改变可能对其中之一没有影响，对另
一个却有极大的影响。还是那句话，理解基本原理，就能应付各种情况。
典型示例
ASoberingExample
首先来看一个真正体现回溯和效率的重要性的例子。在198页，我们用“（\\.|{^\\"})*"
来匹配引号字符串，其中容许出现转义的双引号。这个表达式没有错，但如果我们使用NFA
引擎，对每个字符都应用多选结构的效率就会很低。对字符串中每个“正常”（非转义、非
引用）的字符来说，这个引擎需要测试\.，遇到失败后回溯，最终由[^\\"1匹配。如
果效率不容忽视，就应该做些改动来加快匹配速度。
---
## Page 249
典型示例
223
稍加修改一先迈最好使的腿
A Simple Change—PlacingYourBestFoot Foruard
对于一般的双引号字符串来说，普通字符的数量比转义字符要多，一个简单的改动就是调
换两个多选分支的顺序，把（^\\"]放到\.之前。这样，只有在遇到字符事中的转义字
符时才会按照多选结构进行回溯（还有一次回溯是星号无法匹配引起的，此时所有的多选
分支都匹配失败，所以整个多选结构无法匹配）。图6-1说明了其中的差异。箭头数量的减
少，说明第一个多选分支的成功匹配次数增加了，也就是说回溯的次数减少了。
正则表达式
文字字符串
"2\"x3\"1ikeness"
“（.）*”
"2\"x3\"1ikeness"
多选结构回溯发生的位置
图6-1：多选分支排列顺序的影响（传统型NFA）
请从下面几个方面评价这个修改：
·哪种引擎从中获益？传统型NFA，或者POSIXNFA，或是两者？
什么情况下，这种修改带来的收益最大？在文本能够匹配时，无法匹配时，还是所有
时候。
请思考这些问题，翻到下一页查看答案。在阅读下一节以前，务必理解答案（及原因）。
效率vs准确性
Efficiency Versus Correctness
为提高效率修改正则表达式时最需要考虑的问题是，改动是否会影响匹配的准确性。像上
面那样重新安排多选分支的顺序，只有在排序与匹配成功无关时才不会影响准确性。前一
章出现的-（\\.1[^"]）*"（197）的例子是有缺陷的。如果正则表达式只需要（should）
应用于格式正确的字符串，此问题永远也不会暴露出来。如果认为这个表达式很不错，改
---
## Page 250
224
第6章：打造高效正则表达式
稍加改动的效果
223页问题的答案
哪种引擎从中获益？这种改动对POSIXNFA没有影响。因为它最终必须尝试正则表达
式的每一种可能，多选分支的顺序其实不重要。不过，对传统型NFA来说，这样提高
速度的多选分支重排序是有利的，因为引擎一旦找到匹配结果就会停下来。
什么样的情况下会有效果？只有匹配成功时才会加快速度。只有在尝试所有的可能（再
说一次，POSIXNFA任何情况下都会尝试所有可能）之后，NFA才可能失败。所以如
果确实不能匹配，每种可能都会被尝试，所以排列顺序没有影响。
下表列出了若干种情况下所进行的测试和回溯的次数（数字越小越好）：
传统型NFA
POSIXNFA
目标字符串
（[~\\.]1\.）*两个表达式情况相同
测试
回溯
测试
回溯
测试
回溯
"2\"x3\" 1ikeness"
32
14
22
48
30
'makudonarudo*
28
14
16
2
40
26
"very.99 more chars
..-1ong*
218
109
111
2
325
216
No\“match\*here|124
86
124
86
124
86
我们发现，两个表达式在POSIXNFA中的情况是一样的，而修改之后，传统型NFA
的表现提升了（减少了回潮）。而在不能匹配的情况下（最后一行），因为两种引擎必
须尝试所有的可能，结果就是一样的。
动的确提高了效率，我们就会遇到真正的问题。交换多选分支，把（^"]放在前面，避免
表达式进行不正确的匹配，如果目标字符串包含一个转义的双引号：
"You needa2\*3\"photo.*
所以，在关注效率的时候，万不可忘记准确性。
---
## Page 251
典型示例
225
继续前进—限制匹配优先的作用范围
AdoancingFurther-Localizing the Greediness
从图6-1可以看出，在任意正则表达式中，星号会对每个普通字符进行选代（或者说“重复”），
重复进入-退出多选结构（和括号）。这需要成本，也就是额外的处理一—如果可能，我们必
须避免这些额外处理。
有一次，在处理这类正则表达式时，我想到一个优化的办法，考虑到[\\"]匹配“普通”
（非引号，非反斜线）的情况，使用[^\\"]+会在（）*的一次选代中读入尽可能多的字
符。对没有转义字符的字符串来说，这样会一次读人整个字符串。于是就几乎不会进行回
溯，也就把星号选代的次数减少到最小。我很为自己的发现而高兴。
我们会在本章更深入地考察这个例子，不过看一眼统计数据会清楚地发现好处。图6-2展示
了传统型NFA上应用这个例子的情况。比较原来的（\\.I[^\\"]）"（上面的两个表达
式），与多选结构相关的回溯和星号迭代都减少了。下面的两个例子说明，结合之前的重排
序技巧，这种修改会带来更多的收益。
正则表达式
文字字符串
"2Ax3\"likeness"
[（丨[A\]+）*"
2x3
likeness
*（】）
"2\"x3\"11k
[（]）*"
多选结构回溯发生的位置
图6-2：添加加号的结果（传统型NFA）
新增的加号大大减少了多选结构回溯的次数，以及星号的选代次数。星号量词作用于括号
内的子表达式，每次迭代都需要进入然后再退出括号，这都需要成本，因为引擎需要记录
---
## Page 252
226
第6章：打造高效正则表达式
括号内的子表达式匹配的文本（本章会深入探讨此问题）。
表6-1与第224页答案中的表格类似，不过表达式不同，另外还给出了星号的选代次数。在
每种情况下，独立测试次数和回溯次数的增加都很有限，但是选代次数有了显著降低，这
是很大的进步。
表6-1：传统型NFA的匹配效率
（.*"
（）
字符串
测试
回溯
迭代
测试
回湖
*选代
"makudonarudo "
16
2
13
17
3
2
*2\"x3\* 1ikeness"
22
4
25
6
*very...99more chars...1ong"
111
2
108
112
3
2
实测
Reality Check
是的，我对自己的发现颇为得意。但这个看起来很奇妙的“改动”不过是场还未爆发的灾
难。你可能注意到了，在考察它的各项指标时，我没有给出POSIXNFA的统计数据。如果
这样做，你可能会很惊奇地发现"very·..·long"的匹配需要超过3亿亿亿次（实际上是
324518553658426726783156020576256）回溯。说简单点就是，回溯是个天文数字。
这需要超过50百亿亿（quintillion）年，或者是若干千万亿个千年（注1）。
确实很出乎意料！那么，为什么会发生这种情况呢？简单地说，原因在于一一这个正则表
达式中某个元素受加号限定的同时，还受括号外的星号限定，无法区分哪个量词控制哪个
特殊的字符。这种不确定性就是症结。下一节给出了详细解释。
“指数级”匹配
没有添加星号时，[\\"]是星号的约束对象，真正的（[^\\"]）*能够匹配的字符是有限
的。它先匹配一个字符，然后匹配下一个字符，如此继续，最多就是匹配目标文本中的每
个字符。它也可能无法匹配目标字符串中的所有字符，不过，充其量，匹配字符的个数与
目标字符串的长度成线性关系。目标字符串越长，可能的工作量相对也越大。
注1：这个数字是根据其他测试估算出来的，我可没有那么长的时间来测试，
---
## Page 253
典型示例
227
但是，对正则表达式的（[^\\"]+）*来说，加号和星号二者分割（divvyup）字符申的可能
性是成指数形式增长的。如果目标字符串是makudonarudo，是星号会选代12次，每一次
选代中“{~\\"}+匹配一个字符（就像这样‘mu"）？还是星号选代3次，内部
的[~\\"]+1分别匹配5、3、4个字符（makugonarudg'）？或者2、2、5、3个字符
(makudonarudg'）？还是其他....
你现在知道，存在许多种可能（对长度为12的字符串存在4096种可能）。字符串中的每个
字符，都存在两种可能，POSIXNFA在给出结果之前必须尝试所有可能。这就是“指数级
匹配”的来历。我还听说过一个不错的名字：“超线性（super-linear）”。
无论叫什么名字，终归都是回溯，大量的回溯（注2)！12个字符需要4096种可能，这可
能不需要多久时间，不过20个字符需要超过一百万种可能，时间长达若干秒。30个字符，
就需要超过十亿种可能，长达若干小时，如果是40个字符，就需要一年多的时间。这显然
不是什么好事情。
你可能会想，“没关系，POSIXNFA并不常见。我知道我的工具用的是传统型NFA，所以
这问题对我不存在。”的确，POSIXNFA和传统型NFA的主要差别在于，传统型NFA在遇
到第一个完整匹配可能时会停止。如果没有完整匹配，即使是传统型NFA也需要尝试所有
的可能，在找到之前。即使是前面提到的"No"\"match\"here这样短短的字符串，在报告
失败之前，也需要尝试8192种可能。
在正则引擎忙于尝试这些数量庞大的可能时，整个程序看起来好像“锁死（lockup）”了。
我第一次遇到这种情况时，以为自己发现了程序的bug，不过现在我理解了，现在我把这个
正则表达式加人自己的正则表达式工具包里，用来测试引擎的类型。
·如果其中的某个表达式，即使不能匹配，也能很快给出结果，那可能就是DFA。
·如果只有在能够匹配时才很快出结果，那就是传统型NFA。
·
如果总是很慢，那就是POSIXNFA。
第一个判断中我使用了“可能”这个单词，因为经过高级优化的NFA没准能检测并且避免
这些指数级的无休止（neverending）匹配（详见本章后文250）。同样，我们会见到各种方
法来改进或重写这些表达式，加快它们匹配或报错的速度。
注2：给感兴趣的读者两个数字，长度为目的字符串，回溯的次数是2+1，独立测试的次数为
20+1+2”。
---
## Page 254
228
第6章：打造高效正则表达式
前面列出的几点表明，如果排除某些高级优化的影响，就能根据正则表达式的相对性能判
断引擎的类型。这就是第4章中（146）我们能用某些正则表达式来“测试引擎的类型
的原因。