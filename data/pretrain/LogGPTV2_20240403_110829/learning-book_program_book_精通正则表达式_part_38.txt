### 测试与回溯

在使用正则表达式时，经常会遇到一些典型情况。为了分析某个正则表达式的效率，我们通常会记录正则引擎在匹配过程中进行的独立测试次数。例如，用正则表达式 `marty` 匹配字符串 `smarty` 时，共需进行6次独立测试：首先是 `m` 对 `s`（失败），然后是 `m` 对 `m`，`a` 对 `a`，依次类推。本例中，回溯次数为0，但正则引擎会在第二个字符处重新尝试正则表达式，这可以视为一次回溯。

列出这些数字并不是为了精确度，而是因为它们比“许多”、“少量”、“多次”、“更好”、“不太多”等词汇更为具体。我的目的不是要求读者精确计算NFA上的测试和回溯次数，而是希望让读者了解这些例子的相对优劣。需要注意的是，不同工具的具体表现可能有所不同，因为它们可能采用不同的优化措施。如果目标字符串显然无法匹配（例如缺少某些必需的字符），足够智能的实现方式可以完全跳过正则表达式的应用。本章将讨论这些重要的优化措施，但普遍原理比具体问题更为重要。

### 传统型NFA还是POSIX NFA

在分析效率时，必须考虑所使用的工具引擎类型：是传统型NFA还是POSIX NFA。有些问题仅对特定类型的引擎存在，某些改动可能对一种引擎没有影响，但对另一种却有显著影响。理解基本原理可以帮助应对各种情况。

### 典型示例

#### ASobering Example

首先来看一个真正体现回溯和效率的重要性的例子。在198页，我们用 `(\.|[^\\"])*` 来匹配引号字符串，其中允许出现转义的双引号。这个表达式没有错，但如果使用NFA引擎，对每个字符都应用多选结构的效率会很低。对于字符串中的每个“正常”（非转义、非引用）字符，引擎需要先测试 `\.`，失败后回溯，最终由 `[^\\"` 匹配。如果效率是一个关键因素，我们应该做一些改动来提高匹配速度。

#### 稍加修改—先迈最好使的腿

对于一般的双引号字符串来说，普通字符的数量远多于转义字符。一个简单的改进是调换两个多选分支的顺序，将 `[^\\"]` 放在 `\.` 之前。这样，只有在遇到字符串中的转义字符时才会按照多选结构进行回溯。图6-1展示了这种差异。箭头数量的减少表明第一个多选分支的成功匹配次数增加，从而减少了回溯次数。

请从以下几个方面评价这个修改：
- 哪种引擎从中获益？传统型NFA，或者POSIX NFA，或是两者？
- 在什么情况下，这种修改带来的收益最大？是在文本能够匹配时，无法匹配时，还是所有时候？

请思考这些问题，并翻到下一页查看答案。在阅读下一节之前，请务必理解答案及其原因。

### 效率 vs 准确性

在提高效率时，最重要的问题是确保修改不会影响匹配的准确性。像上面那样重新安排多选分支的顺序，只有在排序不影响匹配结果时才不会影响准确性。前一章中出现的 `-(\\.|\[^"])*"` 的例子是有缺陷的。如果正则表达式仅应用于格式正确的字符串，这个问题可能永远不会暴露出来。如果认为这个表达式很不错，那么在关注效率的同时，不能忽略准确性。

#### 223页问题的答案

哪种引擎从中获益？这种改动对POSIX NFA没有影响，因为它最终必须尝试正则表达式的每一种可能，多选分支的顺序并不重要。然而，对于传统型NFA来说，这样的重排序是有利的，因为一旦找到匹配结果，引擎就会停止。

在什么情况下会有效果？只有在匹配成功时才会加快速度。只有在尝试所有可能之后，NFA才可能失败。因此，如果确实不能匹配，每种可能都会被尝试，排列顺序没有影响。

下表列出了几种情况下进行的测试和回溯次数（数字越小越好）：

| 目标字符串 | 传统型NFA (原) | 传统型NFA (改) | POSIX NFA (原) | POSIX NFA (改) |
|-------------|-----------------|-----------------|-----------------|-----------------|
| "2\"x3\"1ikeness" | 32, 14 | 22, 48 | 30, 26 | 30, 26 |
| "makudonarudo" | 28, 14 | 16, 2 | 40, 26 | 40, 26 |
| "very...99more chars...long" | 218, 109 | 111, 2 | 325, 216 | 325, 216 |
| "No\“match\*here" | 86, 124 | 86, 124 | 86, 124 | 86, 124 |

我们发现，在POSIX NFA中，两个表达式的情况相同，而修改后的传统型NFA表现有所提升（减少了回溯）。而在不能匹配的情况下（最后一行），两种引擎必须尝试所有可能，结果是一样的。

### 继续前进—限制匹配优先的作用范围

从图6-1可以看出，在任意正则表达式中，星号会对每个普通字符进行迭代（或“重复”），这需要进入和退出多选结构（和括号），增加了额外的处理成本。有一次，在处理这类正则表达式时，我想到一个优化方法：使用 `[^\\"]+` 代替 `(\.|[^\\"])`，以在每次星号迭代中读入尽可能多的字符。对于没有转义字符的字符串，这样几乎不会进行回溯，从而减少了星号迭代的次数。

图6-2展示了在传统型NFA上应用这个例子的情况。比较原来的 `(\.|[^\\"])*` 和新的 `([^\\"]+)*`，与多选结构相关的回溯和星号迭代都减少了。结合之前的重排序技巧，这种修改带来了更多的收益。

#### 实测

我对自己的发现颇为得意，但这个看似巧妙的“改动”实际上是一场未爆发的灾难。你可能注意到，在考察其各项指标时，我没有给出POSIX NFA的统计数据。如果这样做，你会发现 `"very...long"` 的匹配需要超过3亿亿亿次回溯。这需要超过50百亿亿年，或者是若干千万亿个千年。

为什么会发生这种情况？简单地说，原因是正则表达式中的某个元素同时受加号和星号限定，导致无法区分哪个量词控制哪个特定字符。这种不确定性就是症结所在。下一节将详细解释。

#### 指数级匹配

没有添加星号时，`[^\\"]` 是星号的约束对象，真正的 `[^\\"]*` 能够匹配的字符是有限的。它最多匹配目标文本中的每个字符，且匹配字符的个数与目标字符串的长度成线性关系。但是，对于正则表达式的 `([^\\"]+)*`，加号和星号二者分割字符的可能性呈指数形式增长。如果目标字符串是 `makudonarudo`，是星号迭代12次，每次迭代中 `[^\\"]+` 匹配一个字符（如 `m`），还是星号迭代3次，内部的 `[^\\"]+` 分别匹配5、3、4个字符（如 `makugonarudo`）？或者2、2、5、3个字符（如 `makudonarudo`）？等等。

你现在知道，存在许多种可能（对于长度为12的字符串存在4096种可能）。每个字符都有两种可能，POSIX NFA在给出结果之前必须尝试所有可能。这就是“指数级匹配”的来历。无论叫什么名字，终归都是大量的回溯。12个字符需要4096种可能，这可能不需要多久时间，但20个字符需要超过一百万种可能，时间长达若干秒。30个字符需要超过十亿种可能，长达若干小时，如果是40个字符，就需要一年多的时间。这显然不是一个好事情。

你可能会想，“没关系，POSIX NFA并不常见。我知道我的工具用的是传统型NFA，所以这问题对我不存在。”的确，POSIX NFA和传统型NFA的主要区别在于，传统型NFA在遇到第一个完整匹配可能时会停止。如果没有完整匹配，即使是传统型NFA也需要尝试所有的可能。即使是前面提到的 `"No\"match\"here"` 这样短短的字符串，在报告失败之前，也需要尝试8192种可能。

当正则引擎忙于尝试这些大量可能性时，整个程序看起来好像“锁死”了。我第一次遇到这种情况时，以为自己发现了程序的bug，但现在我理解了。现在我把这个正则表达式加入自己的正则表达式工具包里，用来测试引擎的类型。
- 如果某个表达式即使不能匹配也能很快给出结果，那可能是DFA。
- 如果只有在能够匹配时才很快出结果，那就是传统型NFA。
- 如果总是很慢，那就是POSIX NFA。

第一个判断中我使用了“可能”这个词，因为经过高级优化的NFA可能能检测并避免这些指数级的无休止匹配。同样，我们会见到各种方法来改进或重写这些表达式，加快它们匹配或报错的速度。

### 总结

通过上述几点，我们可以根据正则表达式的相对性能来判断引擎的类型，排除某些高级优化的影响。这就是第4章中我们能用某些正则表达式来“测试引擎的类型”的原因。