# 30 \| 分布式高可用之故障隔离：当断不断，反受其乱你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。 在前面两篇文章中，我带你一起学习了分布式系统高可靠的关键技术，包括分布式负载均衡和流量控制。除了高可靠，在实际生产中，分布式系统的高可用问题也极其重要。 比如，在双十一的抢购高峰期，如果分布式系统不能满足高可用的特性，那么当大量用户同时抢购时就可能导致系统崩溃，无法提供服务，导致大量用户流失。 因此，在接下来的两篇文章，我将从故障隔离和恢复机制这两项关键技术入手，和你一起学习如何保证分布式系统的高可用。 今天，我们就先一起打卡分布式高可用中的故障隔离吧。 什么是故障隔离？从字面意思来看，故障隔离就是，把故障通过某种方式与其他正常模块进行隔离，以保证某一模块出现故障后，不会影响其他模块。 其实，我们生活有很多故障隔离的例子，比如交通。一辆车就类似于分布式系统中的一个模块，当一辆车在高速公路上出现故障后，我们通常会将其停靠在紧急车道，或者在其前后设置故障指示牌，以防止其他车辆与其相撞，引起更大的交通事故。这种将故障车辆停靠在路边紧急车道或设置故障指标牌的方法，就是一种故障隔离。 现在我们回到分布式系统，故障隔离，就是采用一定的策略，以实现当某个模块故障时，不会影响其他模块继续提供服务，以保证整个系统的可用性。所以说，故障隔离，可以避免分布式系统出现大规模的故障，甚至是瘫痪，降低损失。 在分布式系统中，要实现故障隔离，通常需要在进行系统设计时，提前对可能出现的故障进行预防，以使得在出现故障后能实现故障隔离。此外，由于是提前设计预防的，因此故障隔离还可以帮助我们快速定位故障点。 也就是说，分布式系统中的故障隔离策略是在系统设计时就进行考虑，从预防的角度来实现故障发生时，该模块故障不会影响其他模块。因此，**我今天与你介绍的故障隔离策略，是整个系统设计时，从高可用这个维度进行设计的策略。** 好了，理解了故障隔离为什么可以提高分布式系统的可用性以后，我们再来看看实现故障隔离有哪些常见策略吧。 分布式故障隔离策略分布式系统中的故障隔离策略有很多，大体上可以从两个维度来划分： 1.  一类是以系统功能模块为粒度进行隔离。比如，通过系统功能 /    服务划分，将系统分为多个功能 / 服务模块，各个功能 /    服务模块之间实现松耦合，即一个功能 /    服务模块出现故障，不会影响其他功能 /    服务模块，根据功能模块或服务由线程执行还是进程执行，通常分为线程级隔离、进程级隔离。        2.  另一类是，通过资源隔离来实现。比如，系统中各个模块拥有自己独立的资源，不会发生资源争抢，从而大大提升系统性能。根据资源所属粒度，通常包括进程级隔离（比如采用容器隔离）、虚拟机隔离、服务器隔离和机房隔离等。        基于这个分类，接下来，我将为你讲述三种比较常见的故障隔离策略，包括以功能模块为粒度进行隔离的线程级隔离和进程级隔离，以及以资源为隔离维度的资源隔离。 线程级隔离线程级故障隔离，是指使用不同的线程池处理不同的请求任务。当某种请求任务出现故障时，负责其他请求任务的线程池不会受到影响，即会继续提供服务，从而实现故障的隔离。 如图所示，以电商购物平台为例，假设初期运行在单台机器的一个进程中，在这个进程中有三个线程池，分别负责订单任务、支付任务和配送任务。这样，当订单请求出现故障时，不会影响已下单用户的支付和仓库配送服务。 ![](Images/c1fb9eb13e613b6881109367edb54314.png)savepage-src="https://static001.geekbang.org/resource/image/43/85/43500cb5d70138a423e6d1fc2187a885.png"}**线程级的故障隔离策略，在生产环境中较为常用，尤其对于单体应用**（单进程多线程的应用）。在单体应用场景下，应用被单个进程执行，但单进程中包括多个线程，因此该场景下，只需要实现线程级隔离即可，实现简单、效果好，因此是一种很常用的方式。 系统实现线程级隔离后，线程间的通信通常使用**共享变量**来实现。简单地说，共享变量就是一个进程中的全局变量，在进程的各个线程间可以同时使用。这种通信方式，实现简单且效果明显。 进程级隔离随着业务逐渐扩大，业务系统也会越来越复杂，单体应用可能无法满足公司与用户的需求，这时候就需要对系统进行拆分。 一种常用的方式就是，将系统按照功能分为不同的进程，分布到相同或不同的机器中。如果系统的进程分布到不同机器上的话，从资源的角度来看，也可以说成是主机级的故障隔离。因为从另一个层面看，系统确实分布到了不同机器上，当某个机器出现故障时，不会对其他机器造成影响。 如图所示，电商购物平台可以分为订单系统、支付系统和配送系统三部分。这三个子系统可以采用三个不同的进程来服务用户。 这就是一个进程级的故障隔离方案，即不同的子系统对应不同的进程，某一个子系统出现故障，都不会导致其他系统不可用。 ![](Images/b89e3bfcb74a177666ade900f7dc52bf.png)savepage-src="https://static001.geekbang.org/resource/image/2b/c0/2b8b5ee8a2215c82552a13fcb92709c0.png"}系统实现进程级隔离后，进程间的协同必须通过**进程间通信**（IPC）来实现。进程间通信有很多方式，大体可以分为以下两类： 1.  如果进程都在同一台机器上，则可以通过管道、消息队列、信号量、共享内存等方式，来实现；        2.  如果进程分布在不同机器上，则可以通过远程调用来实现，你可以再回顾下        [第 19 篇文章            slate-object="inline"    中的相关内容。        进程级故障隔离，目前在分布式应用中应用广泛，比如常见的电商、火车票购买等业务都可以采用。资源隔离前面介绍的是以服务或功能模块为粒度进行隔离的，下面我们一起看下从资源角度进行隔离是怎么做的？简单来说，资源隔离就是将分布式系统的所有资源分成几个部分，每部分资源负责一个模块，这样系统各个模块就不会争抢资源，即资源之间互不干扰。这种方式不仅可以提高硬件资源利用率，也便于系统的维护与管理，可以大幅提升系统性能。微服务就是一个典型的例子。当前，很多公司都在将自己的业务系统微服务化，比如亚马逊、阿里、华为、微软等。在微服务的理念中，是尽可能将服务最小化，服务与服务之间进行解耦合，包括运行环境的相互隔离等。比如，现在通常采用容器进行隔离，我在第 9 篇文章中分享的 Mesos、Kubernetes等可实现容器管理与调度，而 Mesos 和 Kuberntes的上层应用很多都是微服务。实际上，在微服务框架中，一个服务通常对应一个容器，而一个容器其实就是操作系统中一个进程，不同容器负责不同的服务，就类似于刚才所讲的：不同进程负责系统不同的功能模块。如图所示，如果将电商购物平台微服务化，则可以启动三个容器，分别负责订单服务、支付服务和配送服务。一个容器对应一个进程，因此微服务框架本质上还是一种进程级故障隔离策略。![](Images/7c5b7e3decfc1973e7ae4cb2620456b7.png)savepage-src="https://static001.geekbang.org/resource/image/55/b8/55e56fcffbdf4a8d67092e5172a134b8.png"}但与进程级隔离不同的是，微服务框架采用容器进行故障隔离。容器虽然本质上是操作系统的一个进程，但具备普通进程不具备的特性，比如资源隔离。1.  一个普通进程有很大的计算或内存需求时，可能会占满物理机上所有的    CPU、内存资源，导致其他进程没有资源可用，引发进程间的资源争夺；        2.  但容器可以实现资源限制，让每个容器占用的资源都有一个上限，比如    CPU、内存，均会设置一个上限值，这个上限值限定了该容器的处理能力，就好比一台服务器具有资源上限值一样。因此，一个容器使用的资源不会影响其他容器的资源，从而避免资源争抢，提高性能。        那到底什么是容器呢？容器是一种虚拟化技术，可以为应用提供一整套运行环境。容器通过限制自身使用的资源来实现资源隔离，从而让容器就像一个个的"集装箱"：容量固定，存放着任意的物品。目前，比较常用的容器是 Docker。Docker 主要使用 Linux 内核中的 LinuxCgroups 模块来设置容器的资源上限，包括 CPU、内存、磁盘、网络带宽等。通过Cgroups模块，容器间就形成了资源隔离，从而避免了容器间的资源争夺，提升了系统性能。通过容器进行资源隔离后，需要容器进行网络配置来进行容器间的通信。比如，Docker默认是通过建立虚拟网桥来实现容器间通信的。如果你想深入了解容器网络配置相关的内容，可以自行查阅Docker官方文档中网络部分slate-object="inline"的内容。除了容器级别的资源隔离，虚拟机级别的隔离也是资源隔离的一种常用手段，一台物理机可以安装多个虚拟机，每个虚拟机都会分配一定的资源，即进行资源隔离。除此之外，主机级别的隔离也可以说是一种资源隔离，每台机器的资源是独享的，不会与其他机器发生资源争夺，从而做到资源隔离。除了以上所讲到的故障隔离策略，其实还有一些更粗力度的隔离策略，比如集群隔离、机房隔离等，这些策略主要是跨集群或跨地域的隔离策略。这些粗粒度的隔离策略，不仅可以根据系统功能/ 服务等维度对系统进行划分，比如每个功能 /服务由一个集群或一个机房单独负责，而且也是一种资源隔离策略，即集群间或机房间资源互相隔离，不会发生资源争夺，互不影响。故障隔离策略综合对比以上，就是分布式应用中常用的几种故障隔离策略了。接下来，我再通过一个表格进行对比分析，以便于你理解和记忆。![](Images/d52c43685df206b6ccfc9dbd0fc351f2.png)savepage-src="https://static001.geekbang.org/resource/image/72/fc/7233f358e26052b4e9f58f67bb514afc.jpg"}知识扩展：从用户角度看，有哪些常用的故障隔离方案？无论是按照功能 /服务划分模块，实现进程级、虚拟机级等故障隔离，还是按照系统资源进行故障隔离，它们都是一种针对服务方的故障隔离手段。除此之外，还有一种故障隔离策略是，针对用户的，即用户级别的故障隔离。用户级别的故障隔离是指，将不同用户分开，当系统出现故障时，只影响部分用户，而不是全体用户。比如，发布产品前大多会有一个"灰度发布"过程，就是先发布给一小部分用户进行测试，如果没问题再大规模发布；如果有问题也只是影响一小部分用户。这就是一种典型的用户级别的故障隔离。常用的用户级别故障隔离策略，有数据分片、负载均衡等。你可以再回顾下第 25 篇文章slate-object="inline"中关于数据分片，以及第 28 篇文章slate-object="inline"中关于负载均衡技术的相关内容。以数据分片为例，系统可以将不同用户的数据存储到不同的数据库，即一个数据库只存储部分用户的信息。这样当某个数据库出现故障时，仅影响该故障数据库存储的用户，而不会影响全部用户。负载均衡也是这个道理。当处理请求的某个服务器出现故障时，只影响该故障服务器负责的用户请求，而不会影响其他服务器负责的用户请求。总结今天，我主要带你学习了分布式高可用技术中的故障隔离技术。首先，我以汽车故障为例，带你了解了故障隔离的概念，并引出分布式系统中的故障隔离。分布式系统中的故障隔离技术是，在进行分布式系统可用性设计时，考虑故障隔离的设计，也就是提前预防或避免出现故障后对整个系统造成影响。然后，我与你介绍了常见的故障隔离策略，包括线程级隔离、进程级隔离和资源隔离策略。其中，线程级隔离和进程级隔离是从对功能/服务模块进行隔离的维度进行划分的，借助了系统本身对线程或进程的隔离机制实现故障隔离；资源隔离是从资源的维度进行隔离，主要通过容器、服务器、集群、机房等物理资源维度进行隔离。最后，我再通过一张思维导图来归纳一下今天的核心知识点吧。![](Images/c4b5ca630075feca481191efbf41baa0.png)savepage-src="https://static001.geekbang.org/resource/image/b5/6b/b5e25369e1645514e9cf8c2d2a52866b.png"}加油，相信通过今天的学习，你对分布式系统中的故障隔离技术有了一定的理解，也可以进一步对容器、虚拟机等的隔离技术进行深入分析了。加油，行动起来吧！思考题分布式系统难免会发生故障，那么评判一个系统故障的指标有哪些呢？或者说通过哪些指标可以判断故障的健康度呢？我是聂鹏程，感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再会！![](Images/c191f391e2aab7575517a886bbd7a681.png)savepage-src="https://static001.geekbang.org/resource/image/a4/8c/a42a16601611a1a72599ecfca434508c.jpg"}
# 31 \| 分布式高可用之故障恢复：知错能改，善莫大焉你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。在上一篇文章，我带你学习了故障隔离。故障隔离的目的是，对故障组件进行隔离，以避免其影响系统中的其他组件，尽可能保证分布式系统的可用性。在分布式系统中，故障在所难免，发生故障后仅仅进行隔离还远远不够，还需要进行故障恢复。比如，现在集群中有3 个节点，节点 1 故障后，对节点 1 进行隔离，如果节点 2、节点 3紧接着故障了，又隔离了这两个节点。那么，整个集群就无法继续提供服务了，何谈分布式系统的高可用呢？为了解决这种问题，分布式领域还有一个关键技术来保证系统的高可用，即故障恢复。接下来，我们就一起打卡分布式系统的故障恢复技术吧。分布式故障基础知识在介绍故障恢复之前，我先与你说说分布式系统中会有哪些故障类型。故障类型在任何一个分布式系统中，故障都是不可避免的。这里的故障，通常包括两类：1.  一类是物理故障，比如硬盘损坏、断电断网、硬件升级等；        2.  另一类是软件层故障，比如系统存在 Bug    导致系统崩溃、系统负载过高导致系统崩溃等。        在讨论分布式系统故障时，我们通常还会从是否是网络导致的故障的角度来进行故障划分，包括节点故障和网络故障，而这两类故障可能同时包括物理故障和软件层故障。由于软件层故障和具体的程序实现等相关，因此主要由开发者根据自己的实现去解决；而物理故障通常具有很多共同特征，因此**今天我主要针对物理故障导致软件不可用的情况进行讲解**。首先，我们看一下**节点故障。**简单地说，节点故障就是单个机器自身出现故障。比如，由机器A、B，......，Z 构成的分布式集群中，机器 A自身出现故障，而不是非机器之间的网络连接出现故障，就是节点故障。![](Images/c8f90bfe0eeca1e83eb4e1942b52fb28.png)savepage-src="https://static001.geekbang.org/resource/image/43/28/434bfe18caacd4be581722b589bac828.png"}节点故障有很多种，大体可以分为两类：1.  一类是硬件故障，比如机器硬盘损坏、内存接触不良等；        2.  另一类是软件故障，比如由于请求过多，超过服务器处理能力上限，导致无法处理，又或者是机器被攻击，导致机器瘫痪等。        节点故障在软件层的表现结果是，该机器无法为用户提供服务。其次，我们看一下**网络故障**。简单地说，网络故障就是分布式集群中，节点之间无法完成通信。比如，由机器A，B，......，Z 构成的分布式集群中，机器间比如机器 A 和 B之间无法完成通信，就属于网络故障。![](Images/f866fcc6213b1ff563106b5ecee75f95.png)savepage-src="https://static001.geekbang.org/resource/image/fa/0d/fa5659ae83d610bd99be333f9353d40d.png"}网络故障也有很多种，比如路由器故障、DNS故障、网络线路断裂等。这些物理故障在软件层的表现结果是，机器间无法通信，影响分布式应用正常提供服务。了解了故障的类型，我们还要搞明白如何检查到故障，也就是如何进行故障检测，因为这是故障恢复的前提。故障检测故障检测，就是指通过一定的方式识别或发现故障。就好比，我们把火灾、地震等危险事件看作是故障，采用火灾报警器、地震仪等来检测发现火灾或地震。如果可以提前检测到事件的发生，就能将损失降到最小。**在分布式系统中，检测硬件故障通常比较麻烦，因此会通过查看软件层的表现结果来进行故障检测**。比如，网络故障导致服务器之间无法通信，因此就可以通过检测服务器之间是否可以通信（比如，服务器之间心跳包是否可以正常地发送和接收），来检测是否存在网络故障。关于故障检测的具体策略，我会在后文与你展开。当检测到故障后，就需要进行故障恢复了。故障恢复故障恢复，就是指修复分布式系统中出现的故障，使系统恢复正常。简单来说，故障恢复就是故障发生之后的弥补方案，可以理解为对故障进行修正或修复，以保证服务正常运行，有点类似"知错能改，善莫大焉"。接下来，我们就具体看看故障检测和故障恢复的原理或者说策略吧。分布式故障检测原理在分布式系统中，常见的故障检测方法是心跳机制。基于心跳进行故障检测的策略主要分为两类，固定心跳检测策略和根据历史心跳信息预测故障策略。还记得我在第 22 篇文章slate-object="inline"中，与你介绍的通过心跳方式判断集中式架构和非集中式架构中节点是否存活的方法吗？其实，这里用到的就是固定心跳检测策略。具体的检测原理，你可以再回顾下这篇文章。所以接下来，**我主要与你分享基于历史心跳消息预测故障的策略，也就是我们常说的φ值故障检测**。φ值故障检测是基于心跳间隔符合正态分布的假设进行计算的。其中，φ值是用来评估心跳是否超时的概率，是对心跳间隔的概率求对数，将非整数转换为整数以便于理解。φ值故障检测方法中，通常会设置一个阈值Ф，若当前心跳计算得到的φ≥Ф，则判断心跳超时，否则心跳未超时。那么，**φ值是如何计算的呢？**从流程上来讲，φ值的计算可以分为三步，即：1.       采样窗口存储心跳到达的时间；        2.       通过样本计算出心跳到达时间间隔的分布；        3.       使用得到的正态分布计算当前的φ值。        接下来，我们就具体看看这三个阶段吧。**第一步：采样窗口存储心跳到达的时间。**采样窗口就是一个具有固定容量的容器，一般存储近 k次的心跳信息，每次心跳到达时，会将到达时间存储到采样窗口，如果采样窗口已满，则会删除窗口中最旧的数据。比如，采样窗口最多存储最近 10 次心跳到达的时间，t1，t2，......，t10，当第 11 次心跳到来时，采样窗口会将 t1 删除，存入t11。到达时间的间隔很容易得到，比如第 11 次心跳到来后，到达时间的间隔是t3 - t2，t4 -- t3，......，t11 --t10。通过这些采样数据，可以计算出样本的平均值μ和方差σ2] slate-object="inline"，以便后面计算φ值。当然，随着新的心跳到来，这些数据会进行相应的更新。**第二步：通过样本计算出心跳到达时间间隔的分布。**φ值故障检测是假设心跳到达时间间隔的分布遵循正态分布，假设Plater] slate-object="inline"(t) 表示接收到上一次心跳之后 t个时间片能收到下一次心跳的概率，则通过第一步中得到的样本平均值µ和方差σ2] slate-object="inline"，得到 Plater] slate-object="inline"(t)的计算结果如下：  .ps} {slate-type="block-katex" ```{=html}``````{=html}``````{=html}```]{.strut style="height:1em;vertical-align:-0.25em;"}[[P]{.mord.mathdefault style="margin-right:0.13889em;"}[[[]{.pstrutstyle="height:2.7em;"}l]{.mord .mathdefault .mtightstyle="margin-right:0.01968em;"}[a]{.mord .mathdefault .mtight}[t]{.mord.mathdefault .mtight}[e]{.mord .mathdefault .mtight}[r]{.mord.mathdefault .mtight style="margin-right:0.02778em;"}]{.mord.mtight}]{.sizing .reset-size6 .size3.mtight}]{style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"}]{.vliststyle="height:0.33610799999999996em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.15em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mord}[(]{.mopen}[t]{.mord.mathdefault}[)]{.mclose}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}]{.base}```{=html}```]{.strut style="height:2.4512310000000004em;vertical-align:-0.93em;"}```{=html}```]{.mopen .nulldelimiter}```{=html}``````{=html}``````{=html}``````{=html}``````{=html}```]{.pstrut style="height:3em;"}```{=html}```σ]{.mord .mathdefault style="margin-right:0.03588em;"}```{=html}``````{=html}``````{=html}``````{=html}```]{.pstrut style="height:3em;"}[[2]{.mord}[π]{.mord .mathdefaultstyle="margin-right:0.03588em;"}]{.mordstyle="padding-left:0.833em;"}]{.svg-align style="top:-3em;"}```{=html}```]{.pstrut style="height:3em;"}```{=html}``````{=html}`````{=html}``{=html}```{=html}`````{=html}``{=html}``{=html}[​]{.vlist-s}``{=html}[[]{.vliststyle="height:0.13278em;"}]{.vlist-r}``{=html}``{=html}``{=html}``{=html}[[]{.pstrutstyle="height:3em;"}[]{.frac-linestyle="border-bottom-width:0.04em;"}]{style="top:-3.23em;"}[[]{.pstrutstyle="height:3em;"}[[1]{.mord}]{.mord}]{style="top:-3.677em;"}``{=html}[​]{.vlist-s}``{=html}[[]{.vliststyle="height:0.93em;"}]{.vlist-r}``{=html}``{=html}[]{.mclose.nulldelimiter}``{=html}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[[∫]{.mop .op-symbol.large-opstyle="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;"}[[[]{.pstrutstyle="height:2.7em;"}t]{.mord .mathdefault .mtight}]{.mord.mtight}]{.sizing .reset-size6 .size3.mtight}]{style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"}[[]{.pstrutstyle="height:2.7em;"}+]{.mord .mtight}[∞]{.mord .mtight}]{.mord.mtight}]{.sizing .reset-size6 .size3.mtight}]{style="top:-3.8129000000000004em;margin-right:0.05em;"}]{.vliststyle="height:1.5212310000000002em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.9119499999999999em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mop}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[[e]{.mord.mathdefault}[[[]{.pstrut style="height:3em;"}[[[−]{.mord.mtight}[[]{.mopen .nulldelimiter .sizing .reset-size3.size6}[[[]{.pstrut style="height:3em;"}[[[2]{.mord.mtight}[[σ]{.mord .mathdefault .mtightstyle="margin-right:0.03588em;"}[[[]{.pstrutstyle="height:2.64444em;"}[[2]{.mord .mtight}]{.mord.mtight}]{style="top:-2.93844em;margin-right:0.1em;"}]{.vliststyle="height:0.9384399999999999em;"}]{.vlist-r}]{.vlist-t}]{.msupsub}]{.mord.mtight}]{.mord .mtight}]{.sizing .reset-size3 .size1.mtight}]{style="top:-2.5061857142857145em;"}[[]{.pstrutstyle="height:3em;"}[]{.frac-line .mtightstyle="border-bottom-width:0.049em;"}]{style="top:-3.2255000000000003em;"}[[]{.pstrutstyle="height:3em;"}(]{.mopen .mtight}[x]{.mord .mathdefault.mtight}[−]{.mbin .mtight}[u]{.mord .mathdefault .mtight}[[)]{.mclose.mtight}[[[]{.pstrut style="height:2.64444em;"}[[2]{.mord.mtight}]{.mord.mtight}]{style="top:-3.04844em;margin-right:0.1em;"}]{.vliststyle="height:1.04844em;"}]{.vlist-r}]{.vlist-t}]{.msupsub}]{.mclose.mtight}]{.mord .mtight}]{.sizing .reset-size3 .size1.mtight}]{style="top:-3.5020714285714285em;"}]{.vliststyle="height:1.250957142857143em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.49381428571428565em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.mfrac}[]{.mclose .nulldelimiter .sizing .reset-size3.size6}]{.mord .mtight}]{.mord .mtight}]{.sizing .reset-size6 .size3.mtight}]{style="top:-3.4534200000000004em;margin-right:0.05em;"}]{.vliststyle="height:1.32909em;"}]{.vlist-r}]{.vlist-t}]{.msupsub}]{.mord}[d]{.mord.mathdefault}[x]{.mord .mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}``{=html}[[]{.strutstyle="height:0.72777em;vertical-align:-0.08333em;"}[1]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[F]{.mord .mathdefaultstyle="margin-right:0.13889em;"}[(]{.mopen}[t]{.mord.mathdefault}[)]{.mclose}]{.base}``{=html}``{=html}``{=html} {.ps__rail-x style="left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 0px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}其中，F(t) 是具有均值µ和方差σ2] slate-object="inline"的正态分布的累积分布函数。**第三步：使用得到的正态分布计算当前的φ值。**假设，Tlast] slate-object="inline"表示最近一次接收到心跳的时间，tnow] slate-object="inline"表示当前时间。将Tlast] slate-object="inline"、tnow] slate-object="inline"，和第二步求得的Plater] slate-object="inline"(t)，带入以下公式即可求得φ值：  .ps} {slate-type="block-katex" ```{=html}``````{=html}``````{=html}``````{=html}```]{.strutstyle="height:1.2641079999999998em;vertical-align:-0.25em;"}[φ]{.mord.mathdefault}[(]{.mopen}[[t]{.mord .mathdefault}[[[]{.pstrutstyle="height:2.7em;"}n]{.mord .mathdefault .mtight}[o]{.mord.mathdefault .mtight}[w]{.mord .mathdefault .mtightstyle="margin-right:0.02691em;"}]{.mord .mtight}]{.sizing .reset-size6.size3.mtight}]{style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}]{.vliststyle="height:0.151392em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.15em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mord}[)]{.mclose}[]{.mspacestyle="margin-right:0.2777777777777778em;"}```{=html}``````{=html}``````{=html}``````{=html}```]{.pstrut style="height:2.7em;"}d]{.mord .mathdefault.mtight}[e]{.mord .mathdefault .mtight}[f]{.mord .mathdefault .mtightstyle="margin-right:0.10764em;"}]{.mord .mtight}]{.sizing .reset-size6.size3 .mtight .x-arrow-pad}]{style="top:-3.228em;"}```{=html}```]{.pstrut style="height:2.7em;"}```{=html}``````{=html}`````{=html}``{=html}```{=html}`````{=html}``{=html}``{=html}``{=html}``{=html}``{=html}[]{.mspacestyle="margin-right:0.2777777777777778em;"}``{=html}[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[−]{.mord}[l]{.mord.mathdefault style="margin-right:0.01968em;"}[o]{.mord.mathdefault}[[g]{.mord .mathdefaultstyle="margin-right:0.03588em;"}[[[]{.pstrutstyle="height:2.7em;"}1]{.mord .mtight}[0]{.mord .mtight}]{.mord.mtight}]{.sizing .reset-size6 .size3.mtight}]{style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}]{.vliststyle="height:0.30110799999999993em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.15em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mord}[(]{.mopen}[[P]{.mord .mathdefaultstyle="margin-right:0.13889em;"}[[[]{.pstrutstyle="height:2.7em;"}l]{.mord .mathdefault .mtightstyle="margin-right:0.01968em;"}[a]{.mord .mathdefault .mtight}[t]{.mord.mathdefault .mtight}[e]{.mord .mathdefault .mtight}[r]{.mord.mathdefault .mtight style="margin-right:0.02778em;"}]{.mord.mtight}]{.sizing .reset-size6 .size3.mtight}]{style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"}]{.vliststyle="height:0.33610799999999996em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.15em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mord}[(]{.mopen}[[t]{.mord.mathdefault}[[[]{.pstrut style="height:2.7em;"}[[[n]{.mord.mathdefault .mtight}[o]{.mord .mathdefault .mtight}[w]{.mord.mathdefault .mtight style="margin-right:0.02691em;"}]{.mord.mtight}]{.sizing .reset-size6 .size3.mtight}]{style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}]{.vliststyle="height:0.151392em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.15em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[[T]{.mord .mathdefaultstyle="margin-right:0.13889em;"}[[[]{.pstrutstyle="height:2.7em;"}l]{.mord .mathdefault .mtightstyle="margin-right:0.01968em;"}[a]{.mord .mathdefault .mtight}[s]{.mord.mathdefault .mtight}[t]{.mord .mathdefault .mtight}]{.mord.mtight}]{.sizing .reset-size6 .size3.mtight}]{style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"}]{.vliststyle="height:0.33610799999999996em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.15em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mord}[)]{.mclose}[)]{.mclose}]{.base}``{=html}``{=html}``{=html} {.ps__rail-x style="left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 0px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}求得φ值后，与阈值Ф进行比较，即可判断节点是否发生故障。以上就是φ值故障检测策略的介绍，它的基本思想是利用了历史心跳信息，来降低误判的可能性。如果你想了解这个策略更详细的内容，可以参考"Theφ Accrual FailureDetector"这篇论文。这篇论文中提到，当阈值Ф=1 时，误判的可能性大约为 10%；Ф=2时，误判的可能性大约为 1%；Ф=3 时，误判的可能性大约为 0.1%······ 通过以上讲解，可以看出，**φ值故障检测策略可以根据历史心跳信息动态预测下一次心跳是否超时，并可以通过设置阈值来自由调控误判的可能性**。目前，该策略已被应用到一些框架中，比如我们熟悉的 Akka集群的故障检测，便是采用了φ值故障检测策略。当采用故障检测策略检测到故障后，故障如何恢复呢？接下来，我们就一起看看故障恢复策略吧。故障恢复策略关于故障恢复策略，我从单节点故障和网络故障两个维度展开。**对于单节点故障问题，往往采取主备策略**，即当主节点故障后，从备节点中选出一个作为新的主节点，以继续提供服务。这种备升主的方式比较好理解。如下图所示，用户 A 访问分布式集群时一直是与 Master 交互的，但当Master 故障后，其他 Slave会通过分布式选举算法选出一个新的主节点。假设，从 Slave 1、Slave 2 和 Slave 3 中选举出 Slave 2 作为新的Master，则 Slave 2 需要承担原来 Master的职责，继续为用户提供服务，因此当用户 A再次访问集群时，提供服务的是新选出的 Master，也就是 Slave2。这就是备升主的过程。关于分布式选举算法的相关内容，你可以再回顾下第 4 篇文章slate-object="inline"。![](Images/de2258cc33a3e4a5319a882887386b54.png)savepage-src="https://static001.geekbang.org/resource/image/b4/f3/b44d27914ff2826c7fe1fe3bd780d3f3.png"}从用户 A的角度来看，并不会感受到服务有什么异常，因为依旧可以正常访问集群。因此，**主备策略可以大大提高分布式系统的可用性，在分布式系统中随处可见**。比如，第 10 篇文章涉及的 Redis集群、 [第 23篇文章  slate-object="inline"中讲到的 ZooKeeper集群等，都是采用了这种主备策略来做故障恢复。**而对于网络故障问题的解决方案，简单来说就是 C、A、P选择的问题**，即在分布式系统的可用性和数据一致性之间做权衡。根据不同的应用场景，选择不同的解决方案。当分布式系统中出现网络故障时，对于高可用性要求严格的系统，比如要求必须及时响应用户的场景，就需要采用保AP 弃 C的策略；对于数据一致性有严格要求的系统，比如银行、金融系统等场景，就需要采用保CP 弃 A的策略。具体内容，你可以再回顾下第 23 篇文章slate-object="inline"。其实，网络故障恢复问题也可以看作数据复制的问题，即网络故障恢复后节点间数据同步的问题。还记得第 26 篇文章slate-object="inline"中的同步复制、异步复制和半同步复制技术吗？其中，半同步复制技术因为既能有效保证数据安全，又能满足系统高性能的要求，所以最受欢迎，被大多数分布式系统采用。关于如何通过半同步复制技术，来进行网络故障恢复，你可以再回顾下第 26篇文章的相关内容。其实，**节点故障和网络故障也有交叉的地方**，比如网络故障产生的原因可能是节点故障，即因为节点故障导致节点间无法通信，而不是纯粹的网络链路问题。这种情况有两种可能性，一种是节点临时性故障，即一段时间后就会恢复；一种是节点永久性故障，即节点不会恢复。针对第一种情况，只需等到故障恢复后，数据进行同步即可；第二种情况则需要备升主策略来解决。知识扩展：固定心跳检测和基于历史心跳信息预测故障的策略，各有什么特点呢？首先，我们看一下固定心跳检测。固定心跳检测的核心是，固定周期 T 秒发送心跳，若连续 k次未收到心跳回复（时间 T 内），则判断心跳超时的时间为 k\*T秒。可以看出，k 和 T的设置非常重要。比如，对于要求秒级故障检测的场景（时延敏感性场景），则k\*T≤1s，因此需要将 T 设置为 ms 级，比如 200ms，k 设置为 1000/200=5次。但，这样一来容易导致误判。因为判断超时的时间设置得太短，很可能是系统做内存回收或系统本身有高任务在运行导致心跳回复延后。而对于时延不太敏感的场景，k 或 T可以设置得大一些，降低误判率，但却会增加发现故障的时间。接下来，我们看一下φ值故障检测。φ值故障检测是基于心跳间隔符合正态分布的假设，通过对历史心跳数据采样来预测当前心跳是否超时的。也就是说，心跳间隔符合比较平稳或符合规律的情况下，比较适合，但对于具有突发情况或心跳间隔无规律的场景误判率比较高。**在网络状况确定且比较稳定的场景下，大多数系统会采用固定心跳检测策略，因为其可以根据网络状况与业务场景自主设定合适的k 和 T值，简单有效；而当网络状况有所变化，且变化有规律的场景，则可以使用φ值故障检测策略。**总结今天，我主要带你学习了分布式高可用技术中的故障恢复技术。首先，我为你介绍了分布式系统中的故障类型，主要包括物理故障和软件故障，软件故障主要是由于程序或软件Bug等导致，通常由开发者在开发或测试过程中解决，而物理故障导致软件不可用的故障类型主要分为两类，节点故障和网络故障。其次，我为你介绍了故障检测方法。故障检测方法主要是心跳检测方法，包括固定心跳策略和基于历史信息的心跳策略。其中，固定心跳策略的具体原理见第 22 篇文章slate-object="inline"中的相关内容；基于历史心跳策略的核心是通过统计历史数据规律，以预测当前心跳是否超时以进行故障检测；紧接着，我为你介绍了故障恢复策略，主要涉及备升主、数据复制等关键技术，相关关键技术原理，你可以再回顾第 4 篇文章slate-object="inline"中的分布式选举算法，以及第 26 篇文章slate-object="inline"中的数据复制技术。最后，我再通过一张思维导图来归纳一下今天的核心知识点吧。![](Images/088e1e8ccea812c2ebf68062b9384f7c.png)savepage-src="https://static001.geekbang.org/resource/image/70/57/70ecf4c65c8d9d16212b92f306b2e657.png"}加油，相信通过今天的学习，分布式系统中的故障恢复技术对你来说不再陌生了，你可以根据业务场景设计出对应的故障检测和故障恢复策略了。行动起来吧，加油！思考题在分布式系统中，网络分区是一个非常重要的故障问题。那么如何判断网络分区呢？以及出现网络分区后，如何处理呢？我是聂鹏程，感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再会！![](Images/c191f391e2aab7575517a886bbd7a681.png)savepage-src="https://static001.geekbang.org/resource/image/a4/8c/a42a16601611a1a72599ecfca434508c.jpg"}