binaries,” in FMCAD 2010. Springer, 2010.
[17] A. Sepp, B. Mihaila, and A. Simon, “Precise static analysis of binaries
by extracting relational information,” in 18th Working Conference on
Reverse Engineering, WCRE 2011.
IEEE, 2011. [Online]. Available:
http://dx.doi.org/10.1109/WCRE.2011.50
[18] K. R. M. Leino, “Efﬁcient weakest preconditions,” Inf. Process. Lett.,
vol. 93, no. 6, 2005.
[19] A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu, “Symbolic model
checking without bdds,” in TACAS 1999. Springer, 1999.
[20] A. Djoudi and S. Bardin, “Binsec: Binary code analysis with low-level
regions,” in Tools and Algorithms for the Construction and Analysis of
Systems. Springer, 2015.
[21] R. David, S. Bardin, T. Thanh Dinh, J. Feist, L. Mounier, M.-L. Potet,
and J.-Y. Marion, “BINSEC/SE: A dynamic symbolic execution toolkit
for binary-level analysis,” in SANER 2016.
IEEE, 2016.
Software protection for the masses,” in SPRO 2015.
[22] J. Calvet, J. Campos, and T. Dupuy, “Visiting The Bear Den, A Journey
in the Land of (Cyber-)Espionage,” RECON 2016, Montreal, 17/06/16.
[23] P. Junod, J. Rinaldini, J. Wehrli, and J. Michielin, “Obfuscator-llvm:
IEEE Press, 2015.
[24] J. Vanegue and S. Heelan, “SMT solvers in software security,” in
WOOT 2012. Usenix Association, 2012, pp. 85–96. [Online]. Available:
http://www.usenix.org/conference/woot12/smt-solvers-software-security
[25] P. Godefroid, N. Klarlund, and K. Sen, “Dart: Directed automated random
testing,” SIGPLAN Not., vol. 40, no. 6, 2005.
[26] K. Sen, D. Marinov, and G. Agha, “Cute: A concolic unit testing engine
for C,” SIGSOFT Softw. Eng. Notes, vol. 30, no. 5, 2005.
[27] R. David, S. Bardin, J. Feist, J.-Y. Marion, L. Mounier, M.-L. Potet, and
T. D. Ta, “Speciﬁcation of concretization and symbolization policies in
symbolic execution,” in ISSTA 2016. ACM, July 2016.
[28] S. Bardin and P. Herrmann, “OSMOSE: automatic structural testing of
executables,” Softw. Test., Verif. Reliab., vol. 21, no. 1, 2011.
[29] V. Chipounov, V. Kuznetsov, and G. Candea, “The S2E platform: Design,
implementation, and applications,” ACM Trans. Comput. Syst., vol. 30,
no. 1, Feb. 2012.
[30] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing mayhem
on binary code,” in SP 2012.
IEEE, 2012.
[31] M. D. Preda, R. Giacobazzi, S. K. Debray, K. Coogan, and G. M.
Townsend, “Modelling metamorphism by abstract interpretation,” in SAS
2010. Springer, 2010.
[32] S. Bardin, P. Herrmann, J. Leroux, O. Ly, R. Tabary, and A. Vincent,
“The Bincoa Framework for Binary Code Analysis,” in CAV 2011, 2011.
[Online]. Available: http://dx.doi.org/10.1007/978-3-642-22110-1_13
[33] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz, “Sok: Automated
software diversity,” in SP 2014, May 2014.
[34] X. Ugarte-Pedrero, D. Balzarotti, I. Santos, and P. G. Bringas, “Sok:
Deep packer inspection: A longitudinal study of the complexity
of
[Online]. Available:
http://dx.doi.org/10.1109/SP.2015.46
run-time packers,” in SP 2015, 2015.
[35] C. Collberg, S. Martin, J. Myers, and J. Nagra, “Distributed application
tamper detection via continuous software updates,” in ACSAC 2012.
ACM, 2012.
[36] Trend Micro, “Operation Pawn Storm, Using Decoys to Evade Detection,”
Tech. Rep., 2014.
[37] ESET Research, “Sednit APT Group Meets Hacking Team,” http://www.
welivesecurity.com/2015/07/10/sednit-apt-group-meets-hacking-team/,
Oct. 2015.
[38] Trend Micro, “Operation Pawn Storm Ramps Up its Activities; Targets
NATO, White House,” Apr. 2015.
[11] B. Yadegari, B. Johannesmeyer, B. Whitely, and S. Debray, “A generic
approach to automatic deobfuscation of executable code,” in SP 2015,
May 2015.
[39] von Gastbeitrag, “Digital Attack on German Parliament: Investigative
Report on the Hack of the Left Party Infrastructure in Bundestag,” Jun.
2015.
648
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
[40] D. Alperovitch,
the
Democratic National Committee,”
https://www.crowdstrike.com/
blog/bears-midst-intrusion-democratic-national-committee/, Jun. 2016.
[41] N. Mehta and B. Leonard, “CVE-2016-7855: Chromium Win32k system
the Midst:
Intrusion
“Bears
into
in
call lockdown,” Tech. Rep., 2016.
[42] D. Creus, T. Halfpop, and R. Falcone, “Sofacy’s
‘Komplex’
OS X Trojan,” http://researchcenter.paloaltonetworks.com/2016/09/
unit42-sofacys-komplex-os-x-trojan/, Sep. 2016.
[43] Y. Zhou, A. Main, Y. X. Gu, and H. Johnson, “Information Hiding in
Software with Mixed Boolean-Arithmetic Transforms,” in Information
Security Applications. Berlin, Heidelberg: Springer Berlin Heidelberg,
2007, vol. 4867, pp. 61–75.
[44] N. Eyrolles, L. Goubin, and M. Videau, “Defeating mba-based obfusca-
tion,” in SPRO 2016 (CCS workshop), ACM, Ed., 2016.
[45] S. Banescu, C. S. Collberg, V. Ganesh, Z. Newsham, and A. Pretschner,
“Code obfuscation against symbolic execution attacks,” in ACSAC 2016.
ACM, 2016.
[46] N. M. Hai, M. Ogawa,
and Q. T. Tho, Foundations and
Practice of Security: 8th International Symposium, FPS 2015,
Revised Selected Papers.
Springer, 2016, ch. Obfuscation Code
Localization Based on CFG Generation of Malware. [Online]. Available:
http://dx.doi.org/10.1007/978-3-319-30303-1_14
[47] A. Finkel and P. Schnoebelen, “Well-structured transition systems
everywhere!” Theor. Comput. Sci., vol. 256, no. 1-2, 2001.
[48] F. Charreteur and A. Gotlieb, “Constraint-based test input generation for
java bytecode,” in ISSRE 2010.
IEEE, 2010.
[49] S. Bardin, M. Delahaye, R. David, N. Kosmatov, M. Papadakis, Y. L.
Traon, and J. Marion, “Sound and quasi-complete detection of infeasible
test requirements,” in ICST 2015.
IEEE, 2015.
[50] T. Reinbacher and J. Brauer, “Precise control ﬂow reconstruction using
boolean logic,” in EMSOFT 2011. ACM, 2011. [Online]. Available:
http://doi.acm.org/10.1145/2038642.2038662
[51] S. Blazy, V. Laporte, and D. Pichardie, “Veriﬁed abstract interpretation
techniques for disassembling low-level self-modifying code,” in ITP
2014. Springer, 2014.
[52] M. Dalla Preda, M. Madou, K. De Bosschere, and R. Giacobazzi,
“Opaque predicates detection by abstract interpretation,” in AMAST 2006.
Springer-Verlag, 2006. [Online]. Available: http://dx.doi.org/10.1007/
11784180_9
[53] M. H. Nguyen, T. B. Nguyen, T. T. Quan, and M. Ogawa, “A hybrid
approach for control ﬂow graph construction from binary code,” in
APSEC 2013, vol. 2, Dec 2013.
[54] G. Myles and C. Collberg, “Software watermarking via opaque
predicates: Implementation, analysis, and attacks,” Electronic Commerce
Research, vol. 6, no. 2, 2006. [Online]. Available: http://dx.doi.org/10.
1007/s10660-006-6955-z
[55] J. Palsberg, S. Krishnaswamy, M. Kwon, D. Ma, Q. Shao, and Y. Zhang,
“Experience with software watermarking,” in ACSAC 2000, 2000.
[Online]. Available: http://dx.doi.org/10.1109/ACSAC.2000.898885
[56] S. K. Udupa, S. K. Debray, and M. Madou, “Deobfuscation: Reverse
engineering obfuscated code,” in WCRE 2005, 2005.
APPENDIX
(Section VI-B, extended). Figure 14 shows a graphical
representation of results from Table V. The x-axis represents
the value of the bound k, and the y-axis represents the numbers
of predicates identiﬁed as opaque, genuine, plus the number
of timeouts (TO), false positive (FP) and false negative (FN).
When k increases, #FN strongly decreases while #FP slowly
increases. Here, #TO is kept very low.
(Section VII-B, extended) Findings on call/stack tampering.
From the call/stack tampering perspective and according to
the taxonomy deﬁned in Section V, many different kinds
of violations were detected. The ﬁrst two patterns found
in ACProtect shown in Figures 15 and 16 are respectively
649
Fig. 14: OP detection: tradeoff between k, FN and FP
detected as [violated], [single], [aligned] and
[violated], [single], [disaligned]. Figures 18,
17 and 19 show three different kinds of violation found in
ASPack. In the ﬁrst example (cf. Figure 18) the tampering is
detected with labels [violated], [disaligned] since
the stack pointer read the ret address at the wrong offset.
In the second example (cf. Figure 17),
the return value
is modiﬁed in place. The tampering is detected with the
[violated], [aligned], [single] tags. The last ex-
ample (cf. Figure 19), takes place between the transition of two
self-modiﬁcation layers and the ret is used for tail-transitioning
to the packer payload (i.e., the original unpacked program). This
violation is detected with [violated], [disaligned],
[single] since the analysis matches a call far upper in
the trace which is disaligned. Note that instruction push
0x10011d7 at address 10043ba is originally a push 0, but
it is patched by instruction at address 10043a9, triggering the
entrance in a new auto-modiﬁcation layer when executing it.
This pattern reﬂects a broader phenomenon found in many
packers like nPack, TELock or Upack having a single ret
tampered: these packers perform their tail transition to the
entrypoint of the original (packed) program with push; ret.
Thus, such analysis allows to ﬁnd precisely that moment in the
execution trace, where the payload is very likely decompressed
in memory.
address
1004328
1004318
100431c
mnemonic
call 0x1004318
add [esp], 9
ret
comment
//push 0x100432d as return
//tamper the value in place
//return to 0x1004n336
Fig. 15: ACProtect violation 1/2
address
1001000
1001005
100100a
100100b
mnemonic
push 0x1004000
push 0x100100b
ret
ret
comment
jump on the ret below
jump on 0x1004000
Fig. 16: ACProtect violation 2/2
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
address
1004a3a
1004c96
1004c9c
1004c9d
1004ca3
len
5
5
1
5
1
mnemonic
call 0x1004c96
call 0x1004c9c
pop esi
sub esi, 4474311
ret
comment
//push 0x1004a3f as return site
//push 0x1004c9b as return site
//pop return address in esi
//return to 0x1004a3f
Fig. 17: ASPack violation 1/3
address
1004002
1004007
1004008
100400a
100400b
100400c
100400d
address
10043a9
10043af
10043b0
10043ba
10043bf
10011d7
mnemonic
call 0x100400a
.byteinvalid
[...]
pop ebp
inc ebp
push ebp
ret
Fig. 18: ASPack violation 2/3
comment
//push 0x1004007 as return
//invalid byte (cannot disassemble)
//not disassembled
//pop return address in ebp
//increment ebp
//push back the value
//jump on 0x1004008
comment
//Patch push value at 10043ba*
//restore initial program context
//enter last SM layer (payload)
mnemonic
mov [ebp+0x3a8], eax
popa
jnz 0x10043ba
Enter SMC Layer 1
push 0x10011d7
ret
[...]
*(at runtime eax=10011d7 and ebp+0x3a8=10043bb)
//push the address of the entrypoint
//use ret to jump on it
//start executing payload
layer
0
0
0
1
0
1
Fig. 19: ASPack violation 3/3
(Section VII-A, extended) Detailed packer experiments.
Table XVI presents a complete view of the experiments
presented in Table VII.
650
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
TABLE XVI: Packer experiment: Opaque Predicates & Call stack tampering
Packers
Dynamic
#proc
self-mod.
#layers
Obfuscation detection
Opaque Predicates (k16)
1
2
1
1
1
-
1
1
1
1
-
1
1
1
1
-
1
1
1
1
1
1
1
-
1
1
1
1
1
1
1
1
#th
1
11
1
15
1
-
1
1
1
1
-
1
1
1
1
-
1
1
1
1
1
1
5
-
1
28
1
1
1
1
1
1
(tr.ok/host)
((cid:2),×)
(×,×)
((cid:2),(cid:2))
(×,×)∗
((cid:2),×)
(×,×)†
((cid:2),(cid:2))
((cid:2),(cid:2))