title:Type Casting Verification: Stopping an Emerging Attack Vector
author:Byoungyoung Lee and
Chengyu Song and
Taesoo Kim and
Wenke Lee
Type Casting Verification:  
Stopping an Emerging Attack Vector
Byoungyoung Lee, Chengyu Song, Taesoo Kim, and Wenke Lee,  
Georgia Institute of Technology
https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/lee
This paper is included in the Proceedings of the 
24th USENIX Security Symposium
August 12–14, 2015 • Washington, D.C.
ISBN  978-1-939133-11-3
Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXType Casting Verification:
Stopping an Emerging Attack Vector
Byoungyoung Lee, Chengyu Song, Taesoo Kim, and Wenke Lee
School of Computer Science
Georgia Institute of Technology
Abstract
Many applications such as the Chrome and Firefox
browsers are largely implemented in C++ for its perfor-
mance and modularity. Type casting, which converts one
type of an object to another, plays an essential role in en-
abling polymorphism in C++ because it allows a program
to utilize certain general or specific implementations in
the class hierarchies. However, if not correctly used, it
may return unsafe and incorrectly casted values, leading
to so-called bad-casting or type-confusion vulnerabili-
ties. Since a bad-casted pointer violates a programmer’s
intended pointer semantics and enables an attacker to
corrupt memory, bad-casting has critical security implica-
tions similar to those of other memory corruption vulner-
abilities. Despite the increasing number of bad-casting
vulnerabilities, the bad-casting detection problem has not
been addressed by the security community.
In this paper, we present CAVER, a runtime bad-casting
detection tool.
It performs program instrumentation
at compile time and uses a new runtime type tracing
mechanism—the type hierarchy table—to overcome the
limitation of existing approaches and efficiently verify
type casting dynamically. In particular, CAVER can be
easily and automatically adopted to target applications,
achieves broader detection coverage, and incurs reason-
able runtime overhead. We have applied CAVER to large-
scale software including Chrome and Firefox browsers,
and discovered 11 previously unknown security vulnera-
bilities: nine in GNU libstdc++ and two in Firefox, all
of which have been confirmed and subsequently fixed by
vendors. Our evaluation showed that CAVER imposes up
to 7.6% and 64.6% overhead for performance-intensive
benchmarks on the Chromium and Firefox browsers, re-
spectively.
1
The programming paradigm popularly known as object-
oriented programming (OOP) is widely used for devel-
oping large and complex applications because it encap-
sulates the implementation details of data structures and
algorithms into objects; this in turn facilitates cleaner
software design, better code reuse, and easier software
Introduction
maintenance. Although there are many programming lan-
guages that support OOP, C++ has been the most popular,
in particular when runtime performance is a key objective.
For example, all major web browsers—Internet Explorer,
Chrome, Firefox, and Safari are implemented in C++.
An important OOP feature is type casting that converts
one object type to another. Type conversions play an im-
portant role in polymorphism. It allows a program to treat
objects of one type as another so that the code can utilize
certain general or specific features within the class hier-
archy. Unlike other OOP languages—such as Java—that
always verify the safety of a type conversion using run-
time type information (RTTI), C++ offers two kinds of type
conversions: static_cast, which verifies the correctness
of conversion at compile time, and dynamic_cast, which
verifies type safety at runtime using RTTI. static_cast
is much more efficient because runtime type checking by
dynamic_cast is an expensive operation (e.g., 90 times
slower than static_cast on average). For this reason,
many performance critical applications like web browsers,
Chrome and Firefox in particular, prohibit dynamic_cast
in their code and libraries, and strictly use static_cast.
However, the performance benefit of static_cast
comes with a security risk because information at com-
pile time is by no means sufficient to fully verify the
safety of type conversions. In particular, upcasting (cast-
ing a derived class to its parent class) is always safe, but
downcasting (casting a parent class to one of its derived
classes) may not be safe because the derived class may
not be a subobject of a truly allocated object in downcast-
ing. Unsafe downcasting is better known as bad-casting
or type-confusion.
Bad-casting has critical security implications. First,
bad-casting is undefined behavior as specified in the C++
standard (5.2.9/11 [26]). Thus, compilers cannot guar-
antee the correctness of a program execution after bad-
casting occurs (more detailed security implication analy-
sis on undefined behavior is provided in §2). In addition
to undefined behavior, bad-casting is similar to memory
corruption vulnerabilities like stack/heap overflows and
use-after-free. A bad-casted pointer violates a program-
mer’s intended pointer semantics, and allows an attacker
USENIX Association  
24th USENIX Security Symposium  81
1
to corrupt memory beyond the true boundary of an ob-
ject. For example, a bad-casting vulnerability in Chrome
(CVE-2013-0912) was used to win the Pwn2Own 2013
competition by leaking and corrupting a security sensitive
memory region [31]. More alarmingly, bad-casting is not
only security-critical but is also common in applications.
For example, 91 bad-casting vulnerabilities have been
reported over the last four years in Chrome. Moreover,
over 90% of these bad-casting bugs were rated as security-
high, meaning that the bug can be directly exploited or
indirectly used to mount arbitrary code execution attacks.
To avoid bad-casting issues, several C++ projects em-
ploy custom RTTI, which embeds code to manually keep
type information at runtime and verify the type conver-
sion safety of static_cast. However, only a few C++
programs are designed with custom RTTI, and supporting
custom RTTI in existing programs requires heavy manual
code modifications.
Another approach, as recently implemented by Google
in the Undefined Behavior Sanitizer (UBSAN) [42],
optimizes the performance of dynamic_cast and re-
places all static_cast with dynamic_cast. However,
this approach is limited because dynamic_cast only
supports polymorphic classes, whereas static_cast is
used for both polymorphic and non-polymorphic classes.
Thus, this simple replacement approach changes the pro-
gram semantics and results in runtime crashes when
dynamic_cast is applied to non-polymorphic classes. It
is difficult to identify whether a static_cast operation
will be used for polymorphic or non-polymorphic classes
without runtime information. For this reason, tools follow-
ing this direction have to rely on manual blacklists (i.e.,
opt-out and do not check all non-polymorphic classes) to
avoid runtime crashes. For example, UBSAN has to black-
list 250 classes, ten functions, and eight whole source files
used for the Chromium browser [9], which is manually
created by repeated trial-and-error processes. Considering
the amount of code in popular C++ projects, creating such
a blacklist would require massive manual engineering
efforts.
In this paper, we present CAVER, a runtime bad-casting
detection tool that can be seamlessly integrated with large-
scale applications such as commodity browsers. It takes
a program’s source code as input and automatically in-
struments the program to verify type castings at runtime.
We designed a new metadata, the Type Hierarchy Ta-
ble (THTable) to efficiently keep track of rich type infor-
mation. Unlike RTTI, THTable uses a disjoint metadata
scheme (i.e., the reference to an object’s THTable is stored
outside the object). This allows CAVER to overcome all
limitations of previous bad-casting detection techniques:
it not only supports both polymorphic classes and non-
polymorphic classes, but also preserves the C++ ABI and
works seamlessly with legacy code. More specifically,
CAVER achieves three goals:
• Easy-to-deploy. CAVER can be easily adopted to
existing C++ programs without any manual effort.
Unlike current state-of-the-art tools like UBSAN, it
does not rely on manual blacklists, which are re-
quired to avoid program corruption. To demonstrate,
we have integrated CAVER into two popular web
browsers, Chromium and Firefox, by only modify-
ing its build configurations.
• Coverage. CAVER can protect all type castings
of both polymorphic and non-polymorphic classes.
Compared to UBSAN, CAVER covers 241% and
199% more classes and their castings, respectively.
• Performance. CAVER also employs optimization
techniques to further reduce runtime overheads (e.g.,
type-based casting analysis). Our evaluation shows
that CAVER imposes up to 7.6% and 64.6% over-
heads for performance-intensive benchmarks on the
Chromium and Firefox browsers, respectively. On
the contrary, UBSAN is 13.8% slower than CAVER
on the Chromium browser, and it cannot run the
Firefox browser due to a runtime crash.
To summarize, we make three major contribution as fol-
lows:
• Security analysis of bad-casting. We analyzed the
bad-casting problem and its security implications
in detail, thus providing security researchers and
practitioners a better understanding of this emerging
attack vector.
• Bad-casting detection tool. We designed and im-
plemented CAVER, a general, automated, and easy-
to-deploy tool that can be applied to any C++ applica-
tion to detect (and mitigate) bad-casting vulnerabili-
ties. We have shared CAVER with the Firefox team 1
and made our source code publicly available.
• New vulnerabilities. While evaluating CAVER, we
discovered eleven previously unknown bad-casting
vulnerabilities in two mature and widely-used open
source projects, GNU libstdc++ and Firefox. All
vulnerabilities have been reported and fixed in these
projects’ latest releases. We expect that integration
with unit tests and fuzzing infrastructure will allow
CAVER to discover more bad-casting vulnerabilities
in the future.
This paper is organized as follows. §2 explains bad-
casting issues and their security implications. §3 illus-
trates high-level ideas and usages of CAVER, §4 describes
the design of CAVER. §5 describes the implementa-
tion details of CAVER, §6 evaluates various aspects of
1The Firefox team at Mozilla asked us to share CAVER for regression
testing on bad-casting vulnerabilities.
82  24th USENIX Security Symposium 
USENIX Association
2
C++ Bad-casting Demystified
CAVER. §7 further discusses applications and limitations
of CAVER, §8 describes related work. Finally, §9 con-
cludes the paper.
2
Type castings in C++. Type casting in C++ allows an
object of one type to be converted to another so that
the program can use different features of the class hi-
erarchy. C++ provides four explicit casting operations:
static, dynamic, const, and reinterpret. In this pa-
per, we focus on the first two types — static_cast and
dynamic_cast (5.2.9 and 5.2.7 in ISO/IEC N3690 [26]) —
because they can perform downcasting and result in bad-
casting. static_cast and dynamic_cast have a variety
of different usages and subtle issues, but for the purpose
of this paper, the following two distinctive properties
are the most important: (1) time of verification: as the
name of each casting operation implies, the correctness
of a type conversion is checked (statically) at compile
time for static_cast, and (dynamically) at runtime for
dynamic_cast; (2) runtime support (RTTI): to verify type
checking at runtime, dynamic_cast requires runtime sup-
port, called RTTI, that provides type information of the
polymorphic objects.
Example 1 illustrates typical usage of both casting
operations and their correctness and safety: (1) casting
from a derived class (pCanvas of SVGElement) to a parent
class (pEle of Element) is valid upcasting; (2) casting
from the parent class (pEle of Element) to the original
allocated class (pCanvasAgain of SVGElement) is valid
downcasting; (3) on the other hand, the casting from an
object allocated as a base class (pDom of Element) to a
derived class (p of SVGElement) is invalid downcasting
(i.e., a bad-casting); (4) memory access via the invalid
pointer (p->m_className) can cause memory corruption,
and more critically, compilers cannot guarantee any cor-
rectness of program execution after this incorrect conver-
sion, resulting in undefined behavior; and (5) by using
dynamic_cast, programmers can check the correctness of
type casting at runtime, that is, since an object allocated
as a base class (pDom of Element) cannot be converted to
its derived class (SVGElement), dynamic_cast will return
a NULL pointer and the error-checking code (line 18) can
catch this bug, thus avoiding memory corruption.
Type castings in practice.
Although dynamic_cast
can guarantee the correctness of type casting, it is an
expensive operation because parsing RTTI involves recur-
sive data structure traversal and linear string comparison.
From our preliminary evaluation, dynamic_cast is, on
average, 90 times slower than static_cast on average.
For large applications such as the Chrome browser, such
performance overhead is not acceptable: simply launch-
ing Chrome incurs over 150,000 casts. Therefore, despite
its security benefit, the use of dynamic_cast is strictly
1 class SVGElement: public Element { ... };
2
3 Element *pDom = new Element();
4 SVGElement *pCanvas = new SVGElement();
5
6 // (1) valid upcast from pCanvas to pEle
7 Element *pEle = static_cast(pCanvas);
8 // (2) valid downcast from pEle to pCanvasAgain (== pCanvas)
9 SVGElement *pCanvasAgain = static_cast(pEle);
10
11 // (3) invalid downcast (-> undefined behavior)
12 SVGElement *p = static_cast(pDom);
13 // (4) leads to memory corruption
14 p->m_className = "my-canvas";
15
16 // (5) invalid downcast with dynamic_cast, but no corruption
17 SVGElement *p = dynamic_cast(pDom);
18 if (p) {
19
20
p->m_className = "my-canvas";
}
Example 1: Code example using static_cast to convert types
of object pointers (e.g., Element ↔ SVGElement classes). (1) is
valid upcast and (2) is valid downcast. (3) is an invalid down-
cast. (4) Memory access via the invalid pointer result in memory
corruption; more critically, compilers cannot guarantee the cor-
rectness of program execution after this incorrect conversion,
resulting in undefined behavior. (5) Using dynamic_cast, on the
other hand, the program can check the correctness of downcast
by checking the returned pointer.
forbidden in Chrome development.
A typical workaround is to implement custom RTTI
For example, most classes in WebKit-
support.
based browsers have an isType() method (e.g.,
isSVGElement()), which indicates the true allocated type
of an object. Having this support, programmers can decou-
ple a dynamic_cast into an explicit type check, followed
by static_cast. For example, to prevent the bad-casting
(line 12) in Example 1, the program could invoke the
isSVGElement() method to check the validity of casting.
However, this sort of type tracking and verification has
to be manually implemented, and thus supporting custom
RTTI in existing complex programs is a challenging prob-
lem. Moreover, due to the error-prone nature of manual
modifications (e.g., incorrectly marking the object iden-
tity flag, forgetting to check the identity using isType()
function, etc.), bad-casting bugs still occur despite custom
RTTI [41].
Security implications of bad-casting. The C++ stan-
dard (5.2.9/11 [26]) clearly specifies that the behavior
of an application becomes undefined after an incorrect
static_cast. Because undefined behavior is an enig-
matic issue, understanding the security implications and
exploitability of bad-casting requires deep knowledge of
common compiler implementations.
Generally, bad-casting vulnerabilities can be exploited
via several means. An incorrectly casted pointer will ei-
ther have wider code-wise visibility (e.g., allowing out-of-
bound memory accesses), or become incorrectly adjusted