39 imul bx, bx 
40 jo MandelBreak 
41 imul   bp, bp 
42 jo MandelBreak 
43 add bx, bp 
44 jo MandelBreak 
45 sub bx, bp 
46 sub bx, bp 
47 
48 sar bx, 6 
49 add bx, dx 
50 sar si, 6 
51 add si, ax 
52 
53 loop MandelLoop 
54 
55 MandelBreak: 
56 xchg ax, cx 
57 stosb 
58 cmp di, 0FA00h 
59 jb FillLoop 
60 
61 ; wait for keypress 
62 xor ax, ax 
63 int 16h 
64 ; set text video mode 
65 mov ax, 3 
66 int 10h 
67 ; exit 
68 int 20h 
笔者修正了上一个程序的缺陷：使用了平滑过渡的灰度调色板；把整个图形全部输出到了图形缓冲区里（第
19、20 行））；使图像中心与屏幕中心重合（第 30 行）；绘图结束后等待键盘敲击再退出程序（第 58～68 行）。不
过，整个程序大了近一倍：它由 54 条指令构成，文件大小也增长到了 105 字节。该程序的绘图如图 83.5 所示。 
图 83.5  笔者的改进版程序的绘图 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第九
九部
部分
分  
文
文件
件分
分析
析  
异步社区会员 dearfuture(15918834820) 专享 尊重版权
826 
逆向工程权威指南 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 8844 章
章    基
基于
于 XXO
ORR 的
的文
文件
件加
加密
密  
84.1  Norton Guide：单字节 XOR 加密实例 
在 MS-DOS 时代，Norton Guide（http://en.wikipedia.org/wiki/Norton_Guides）风靡一时。它是一款驻留
内存的 TSR 程序，可与编程语言的编辑程序整合，提供超文本形式的参考信息。 
Norton Guide 的数据库文件是.ng 文件。一看便知，这种文件经过加密处理。如图 84.1 所示。 
图 84.1  Very typical look 
为什么说它是加密文件而非压缩文件呢？我们可以看到数值为 0x1A 的字节（右箭头字符）多次出现，
而压缩文件则不会发生这种情况。我们还看到了大量有拉丁字符的片段，只是这些字符串不可自然解释。 
因为文件多次出现了 0x1A，所以我们按照加密文件进行处理，并且假设该文件是经异或/XOR 加密的密文。
我们可在 Hiew 里清楚地看到，当使用 0x1A 对每个字节进行异或运算时，文件里出现了亲切的英语文字。
如图 84.2 所示。 
图 84.2  Hiew XORing with 0x1A 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
828 
逆向工程权威指南（下册） 
对每个字节进行 XOR 运算是一种最初级的加密方法。不要因为其简单就瞧不起这种分析方法，实际
的分析工作中就是会频繁遇到这种技术。 
现在，我们大体理解了 0x1A 出现次数很多的原因了。在进行异或运算之后，数值为 0 的明文字节会演变
为数值为 0x1A 的密文。 
应当注意：加密的常量会因文件而异。在解密单字节 XOR 加密的密文时，我们应当尝试 0～255 之间的每个
数，再分析一下密文文件被解密成什么样子。有关 Norton Guide 的文件格式，请参见：http://www.davep.org/ 
norton-guides/file-format/。 
信息熵 
在加密领域，信息熵（entropy）属于重要的信息指标。它有一个重要特性：加密前后的明文和密文，
其信息熵不变。本节将介绍使用 Wolfram Mathematica 10 来计算信息熵的具体方法。 
指令清单 84.1  Wolfram Mathematica 10 
In[1]:= input = BinaryReadList["X86.NG"]; 
In[2]:= Entropy[2, input] // N 
Out[2]= 5.62724 
In[3]:= decrypted = Map[BitXor[#, 16^^1A] &, input]; 
In[4]:= Export["X86_decrypted.NG", decrypted, "Binary"]; 
In[5]:= Entropy[2, decrypted] // N 
Out[5]= 5.62724 
In[6]:= Entropy[2, ExampleData[{"Text", "ShakespearesSonnets"}]] // N 
Out[6]= 4.42366 
上述各指令分别用于加载文件、计算信息熵、解密、保存和计算明文的信息熵（熵不变）。Mathematica
还提供了知名的英文片段以供人们进行分析。我选取了莎士比亚的十四行韵律诗进行分析，其信息熵与前
一个例子基本相同。我们分析的英文语句，其信息熵与莎士比亚的语言相似。对英文原文进行单字节的 XOR
加密之后，其信息熵与原文相同。 
但是，如果加密单元大于一个字节，那么信息熵就是另外一种情况了。 
本节分析的英文原文，可在下述地址下载：http://beginners.re/examples/norton_guide/X86.NG。 
其他 
Wolfram Mathematica计算的熵以自然指数e为基数，而UNIX的ent工具
①
84.2  4 字节 XOR 加密实例 
则以 2 为基数。所以上例明确
指定“以 2 为基数”，以使得Mathematica的计算结果与ent工具的计算结果相同。 
即使 XOR 算法采用多字节密钥，例如说 4 字节密钥，分析方法也没有什么两样。本节以 32 位 Windows 
Server 2008 的 Kernel32.dll 为例进行说明。源文件如图 84.3 所示。 
以 4 字节密钥进行加密，可得到图 84.4 所示的结果。 
通过观察文件，就可以看到一组循环出现的 4 字节字符串。实际上这并不困难，因为 PE 文件的文件
头中含有大量的零字节，所以我们可以直接看到密钥。 
在 16 进制编辑器里，PE 文件头大体如图 84.5 所示。 
① 官方网站为 http://www.fourmilab.ch/random/。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第 84 章  基于 XOR 的文件加密 
829 
图 84.3  源文件 
图 84.4  文件密文 
图 84.5  PE 文件头 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
830 
逆向工程权威指南（下册） 
加密之后，如图 84.6 所示。 
图 84.6  加密后的 PE 文件头 
观察可得 4 字节密钥：8C 61 D2 63。使用这个消息块即可对文件解密。 
此处不得不提 PE 文件的几个特点： 
① PE 文件头里含有大量的零字节。 
② 所有的 PE 字段都向分页边界—4096 字节对齐，用零字节填补空缺；所以每个字段之后肯定存在
大量的零字节。 
用零来实现边界对齐的文件格式并不罕见。很多科学计算软件及工程类软件都采用了这种文件格式。 
有兴趣的读者可研究一下本例的文件。它们的下载地址是：http://beginners.re/examples/XOR_4byte/。 
84.3  练习题 
请尝试解密下列链接中的密文。 
http://go.yurichev.com/17353 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 8855 章
章    M
Miilllleenniiuum
m 游
游戏
戏的
的存
存档
档文
文件
件  
“Millenium Return to Earth”是一款古老的 DOS 游戏（1991 年问世）。玩家可在游戏中挖矿、修建战舰、
在其他星球上作战，等等。有兴趣的读者可以体验一下它：http://thehouseofgames.org/index.php?t=10&id=110。 
和其他的游戏程序一样，这个游戏也有游戏存档的功能。现在我们来分析一下它的存档文件。 
游戏中有“矿”的概念。挖矿的速度因星球而异，在某些星球上快些，而在另一些星球上慢些。另外，
在游戏的设定中，矿产的种类也有差异化的设定。在图 85.1 中，您可看到游戏存盘时的挖矿进度。 
图 85.1  Mine：状态 1 
我保存了这一时刻的游戏状态。存盘文件总计 9538 字节。 
然后，我又在游戏里挖了几“天”的矿。挖矿进度如图 85.2 所示。 
图 85.2  Mine：状态 2 
此时我再次保存了游戏状态。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
832 
逆向工程权威指南（下册） 
现在，我们使用 DOS/Windows 的 FC 程序来比较两个存档文件的差别： 
...> FC /b 2200save.i.v1 2200SAVE.I.V2 
Comparing files 2200save.i.v1 and 2200SAVE.I.V2 
00000016: 0D 04 
00000017: 03 04 
0000001C: 1F 1E 
00000146: 27 3B 
00000BDA: 0E 16 
00000BDC: 66 9B 
00000BDE: 0E 16 
00000BE0: 0E 16 
00000BE6: DB 4C 
00000BE7: 00 01 
00000BE8: 99 E8 
00000BEC: A1 F3 
00000BEE: 83 C7 
00000BFB: A8 28 
00000BFD: 98 18 
00000BFF: A8 28 
00000C01: A8 28 
00000C07: D8 58 
00000C09: E4 A4 
00000C0D: 38 B8 
00000C0F: E8 68 
... 
上述内容是比对结果的部分内容。两个文件的不同之处还有很多，但是其余内容不如这些信息那样富
有代表性。 
在第一次存盘时，我持有 14 个单位的 hydrogen 和 102 个单位的 oxygen。在第二次存盘时，相应的持
有量变为 22 和 155 个单位。如果程序把这两个值存储在存档文件中，那么我们应当可以在存档里找到它。
实际情况正是如此。在存档文件的 0xBDA 处，第一个存档文件的值为 0x0E（14），在第二个存档文件的值
为 0x16（22）。地址 0xBDA 存储的应当是 hygrogen 的量。然后，在文件的 0xBDC 处，两个值分别为 0x66
（102）和 0x9B（155）。地址 0xBDC 存储的应当是 oxygen 的值。 
您可以自己把玩一下这个游戏，分析存档文件的具体格式。您还可以下载我用的游戏存档：
http://beginners.re/examples/millenium_DOS_game/。 
使用 Hiew 打开第二次存档的存档文件，可以看到有关矿石的持有量。如图 85.3 所示。 
图 85.3  Hiew：状态 1 
这个值无疑是 16 位数值：在 DOS 时代的 16 位软件程序里，int 型数据就是 16 位数据，这并不意外。 
验证一下我们的推测是否正确。把这个地址的值（hydrogen）改为 1234（0x4D2），如图 85.4 所示。 
图 85.4  Hiew：把数值修改为 1234（0x04D2） 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第 85 章  Millenium 游戏的存档文件 
833 
然后打开游戏、加载存档中的进度，看看矿产持有量。如图 85.5 所示。 
图 85.5  Let’s check for hydrogen value 
以上信息表明，我们的推测是正确的。 
为了快速通关，我们把所有矿产的持有量都改成最大值，如图 85.6 所示。 
图 85.6  Hiew：把各项都修改为最大值 
0xFFFF 是 65535。改动之后，我们就是资源大亨了。如图 85.7 所示。 
图 85.7  所有资源都变为 65535 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
834 
逆向工程权威指南（下册） 
在进行了几个游戏日的奋斗之后—哎？部分资源变少了。如图 85.8 所示。 
图 85.8  Resource variables overflow 
这就发生了数值溢出。游戏开发人员可能没有想到玩家会持有这么多的矿产，所以未做溢出检测。但
是挖矿就会增加矿产，超过数据最大值之后、数据溢出了。这样看来，要是我当初没那么贪心就好了，或
许吧。 
这款游戏的存档文件里还有很多数值，本文不再一一分析。 
这属于一种简单的游戏作弊方法。只要玩家略微改动一下存档文件，他们就可以获得很高的游戏分值。 
本书 63.4 节详细介绍了各种文件及内存快照的比较方法。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 8866 章
章    O
Orraaccllee 的
的..SSYYM
M 文
文件
件  
在程序崩溃的时候，Oracle RDBMS 会把大量信息写到日志文件（log）里。日志文件会记录数据栈的
使用情况，如下所示。 
----- Call Stack Trace ----- 
calling         
      call     entry                   argument values in hex 
location              type     point                   (? means dubious value) 
-------------------- -------- -------------------- ------------------- 
_kqvrow()                   
    00000000 
_opifch2()+2729       CALLptr  00000000     
     23D4B914 E47F264 1F19AE2 
                                                              EB1C8A8 1 
_kpoal8()+2832       CALLrel  _opifch2()              89 5 EB1CC74 
_opiodr()+1248       CALLreg  00000000                 5E 1C EB1F0A0 
_ttcpip()+1051       CALLreg  00000000                 5E 1C EB1F0A0 0 
_opitsk()+1404       CALL???  00000000                 C96C040 5E EB1F0A0 0 EB1ED30 
                                                              EB1F1CC 53E52E 0 EB1F1F8 
_opiino()+980 
      CALLrel  _opitsk()                00 
_opiodr()+1248       CALLreg  00000000                 3C 4 EB1FBF4 
_opidrv()+1201       CALLrel  _opiodr()                3C 4 EB1FBF4 0 
_sou2o()+55           CALLrel  _opidrv()                3C 4 EB1FBF4 
_opimai_real()+124    CALLrel  _sou2o()                 EB1FC04 3C 4 EB1FBF4 
_opimai()+125 
      CALLrel  _opimai_real()          2 EB1FC2C 
_OracleThreadStart@   CALLrel  _opimai()                2 EB1FF6C 7C88A7F4 EB1FC34 0 
4()+830                                                      EB1FD04 
77E6481C       
      CALLreg  00000000                 E41FF9C 0 0 E41FF9C 0 EB1FFC4 
00000000       
      CALL???  00000000 
既然是编译器生成的程序，那么 Oracle 的可执行程序里必定会有调试信息、带有符号（symbol）信息
的映射文件、或者是相似的信息。 
在 Windows NT 版的 Oracle RDBMS 中，其可执行文件里存在着与.SYM 文件有关的符号信息。可惜，
官方不会公开.SYM 文件的文件格式。固然 Oracle 可以使用纯文本文件，但是如此一来还要对其进行多次
转换，性能必然大打折扣。 
我们从最短的文件 orawtc8.sym 入手，试着分析这种格式的文件。Oracle 8.1.7 的动态库文件 orawtc8.dll 之中，
存在着这个.SYM 文件的符号信息。对于 oracle 数据库的程序来说，版本越旧、功能模块的文件就越小。 
使用 Hiew 打开上述文件，可以看到如图 86.1 所示的界面。 
图 86.1  使用 Hiew 打开整个文件 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
836 
逆向工程权威指南（下册） 
参照其他.SYM 文件，可知这种格式的文件头（及文件尾部）都有 OSYM 字样。据此判断，这个字符
串可能是某种文件签名。 
大体来说，这种文件的格式是“OSYM + 某些二进制数据 + 以 0 做结束符的字符串 + OSYM”。很明显，
这些文件中的字符串应当是函数名和全局变量名。 
如图 86.2 所示，字符串 OSYM 的位置较为固定。 
图 86.2  OSYM signature and text strings 
接下来，我把这个文件中的整个字符串部分（不包含尾部的 OSYM 签名字符串）复制了出来，并单独
存储为一个文件 strings_block。然后使用 UNIX 的 strings 和 wc 工具统计它字符串的数量： 
strings strings_block | wc -l 
66 
可见它包含 66 个文本字符串。我们先把这个数字记下来。 
通常来说，无论它是字符串、还是其他什么类型的数据，数据的总数往往会出现在二进制文件的其他
部分。这次的分析过程再次印证了这个规律，我们可以在文件的开始部分、OSYM 之后看到 66（0x42）： 
$ hexdump -C orawtc8.sym 
00000000  4f 53 59 4d 42 00 00 00  00 10 00 10 80 10 00 10  |OSYMB...........| 
00000010  f0 10 00 10 50 11 00 10  60 11 00 10 c0 11 00 10  |....P...`.......| 
00000020  d0 11 00 10 70 13 00 10  40 15 00 10 50 15 00 10  |....p...@...P...| 
00000030  60 15 00 10 80 15 00 10  a0 15 00 10 a6 15 00 10  |`...............| 
.... 
当然，0x42 不是一个 byte 型数据，很可能是个以小端字节序存储的 32 位数据。正因如此，0x42 之后
排列着 3 个以上的零字节。 
判断它是 32 位数据的依据是什么？Oracle RDBMS 的符号文件可能非常大。以版本号为 10.2.0.4 的
Oracle 主程序为例，它的 oracle.sym 包含有 0x3A38E（即 238478）个符号。16 位的数据类型不足以表达这
个数字。 
分析过其他.SYM 文件之后，我更加确定了上述猜测：在 32 位的 OSYM 签名之后的数据，就是反映
文本字符串数量的数据。 
这也是多数二进制文件的常规格式：文件头通常包含程序签名和文件中的某种信息。 
接下来，我们分析一下文件中的二进制部分。我把文件中第 8 字节（字符串计数器之后）到字符串之
间的内容存储为另外一个文件（binary_block）。然后再使用 Hiew 打开这个新文件，如图 86.3 所示。 
这个文件的模式逐渐清晰了起来。为了便于理解，我在图中添加了几条分割线，如图 86.4 所示。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第 86 章  Oracle 的.SYM 文件 
837 
图 86.3  Binary block 
图 86.4  Binary block 
多数的 hex 编辑器每行都显示 16 个字节，Hiew 也不例外。所以，在 Hiew 的窗口里，每行信息对应
着 4 个 32 位数据。 
文件中的数据凸显了它的这种特征：在地址 0x104 之前的数据都是 0x1000xxx 形式的数据（请注意小
端字节序），数据都以 0x10、0x00 字节开头；以 0x108 开始的数据，都是 0x0000xxxx 型的数据，都以两个
零字节开头。 
我们把这些数据整理为 32 位的数组，代码如下所示。 
指令清单 86.1  第一列是地址 
$ od -v -t x4 binary_block 
0000000 10001000 10001080 100010f0 10001150 
0000020 10001160 100011c0 100011d0 10001370 
0000040 10001540 10001550 10001560 10001580 
0000060 100015a0 100015a6 100015ac 100015b2 