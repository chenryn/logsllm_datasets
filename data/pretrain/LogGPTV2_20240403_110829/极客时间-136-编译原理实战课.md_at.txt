# 20 \| JavaScript编译器（一）：V8的解析和编译过程你好，我是宫文学。从这一讲开始，我们就进入另一个非常重要的编译器：V8编译器。 V8 是谷歌公司在 2008 年推出的一款 JavaScript编译器，它也可能是世界上使用最广泛的编译器。即使你不是编程人员，你每天也会运行很多次V8，因为 JavaScript 是 Web的语言，我们在电脑和手机上浏览的每个页面，几乎都会运行一点 JavaScript脚本。 扩展：V8 这个词，原意是 8 缸的发动机，换算成排量，大约是 4.0排量，属于相当强劲的发动机了。它的编译器，叫做Ignition，是点火装置的意思。而它最新的 JIT 编译器，叫做TurboFan，是涡轮风扇发动机的意思。slate-object="mark"}在浏览器诞生的早期，就开始支持 JavaScript 了。但在 V8推出以后，它重新定义了 Web应用可以胜任的工作。到今天，在浏览器里，我们可以运行很多高度复杂的应用，比如办公套件等，这些都得益于以V8 为代表的 JavaScript 引擎的进步。2008 年 V8发布时，就已经比当时的竞争对手快 10 倍了；到目前，它的速度又已经提升了10倍以上。从中你可以看到，编译技术有多大的潜力可挖掘！对 JavaScript编译器来说，它最大的挑战就在于，当我们打开一个页面的时候，源代码的下载、解析（Parse）、编译（Compile）和执行，都要在很短的时间内完成，否则就会影响到用户的体验。**那么，V8是如何做到既编译得快，又要运行得快的呢？**所以接下来，我将会花两讲的时间，来带你一起剖析一下 V8里面的编译技术。在这个过程中，你能了解到 V8是如何完成前端解析、后端优化等功能的，它都有哪些突出的特点；另外，了解了V8的编译原理，对你以后编写更容易优化的程序，也会非常有好处。今天这一讲，我们先来透彻了解一下 V8的编译过程，以及每个编译阶段的工作原理，看看它跟我们已经了解的其他编译器相比，有什么不同。初步了解 V8首先，按照惯例，我们肯定要下载 V8的源代码。按照官方文档slate-object="inline"中的步骤，你可以下载源代码，并在本地编译。注意，你最好把它编译成Debug模式，这样便于用调试工具去跟踪它的执行，所以你要使用下面的命令来进行编译。    tools/dev/gm.py x64.debug编译完毕以后，进入 v8/out/x64.debug目录，你可以运行./d8，这就是编译好的 V8 的命令行工具。如果你用过Node.js，那么 d8 的使用方法，其实跟它几乎是完全一样的，因为 Node.js就封装了一个 V8 引擎。你还可以用 GDB 或 LLDB 工具来调试d8，这样你就可以知道，它是怎么编译和运行 JavaScript程序了。 而 v8/src 目录下的，就是 V8 的源代码了。V8 是用 C++编写的。你可以重点关注这几个目录中的代码，它们是与编译有关的功能，而别的代码主要是运行时功能：![](Images/9f768493aad9781471ed8b1165a9bef9.png)savepage-src="https://static001.geekbang.org/resource/image/ce/ee/ce80ee2ace64988a8d332e0e545ef0ee.jpg"}V8 的编译器的构成跟 Java的编译器很像，它们都有从源代码编译到字节码的编译器，也都有解释器（叫Ignition），也都有 JIT 编译器（叫 TurboFan）。你可以看下 V8的编译过程的图例。在这个图中，你能注意到两个陌生的节点：**流处理节点（Stream）和预解析器（PreParser）**，这是 V8编译过程中比较有特色的两个处理阶段。![](Images/6af690e972a9aed06dc3f76fb52b5903.png)savepage-src="https://static001.geekbang.org/resource/image/09/fb/095613e2515fc6d6cc36705e6d952afb.jpg"}图 1：V8 的编译过程slate-object="mark"}注意：这是比较新的 V8 版本的架构。在更早的版本里，有时会用到两个 JIT编译器，类似于 HotSpot 的 C1 和C2，分别强调编译速度和优化效果。在更早的版本里，还没有字节码解释器。现在的架构，引入了字节码解释器，其速度够快，所以就取消了其中一级的JIT 编译器。 下面我们就进入到 V8编译过程中的各个阶段，去了解一些编译器的细节。超级快的解析过程（词法分析和语法分析）首先，我们来了解一下 V8 解析源代码的过程。我在开头就已经说过，V8解析源代码的速度必须要非常快才行。源代码边下载边解析完毕，在这个过程中，用户几乎感觉不到停顿。**那它是如何实现的呢？**有两篇文章就非常好地解释了 V8解析速度快的原因。一个是" [optimizing thescanner  slate-object="inline""这篇文章，它解释了 V8 在词法分析上做的优化。V8的作者们真是锱铢必较地在每一个可能优化的步骤上去做优化，他们所采用的技术很具备参考价值。那我就按照我对这篇文章的理解，来给你解释一下 V8解析速度快的原因吧：第一个原因，是 **V8的整个解析过程是流（Stream）化的**，也就是一边从网络下载源代码，一边解析。在下载后，各种不同的编码还被统一转化为UTF-16编码单位，这样词法解析器就不需要处理多种编码了。第二个原因，是**识别标识符时所做的优化**，这也让 V8的解析速度更快了一点。你应该知道，标识符的第一个字符（ID_START）只允许用字母、下划线和\$来表示，而之后的字符（ID_CONTINUE）还可以包括数字。所以，当词法解析器遇到一个字符的时候，我们首先要判断它是否是合法的ID_START。 **那么，这样一个逻辑，通常你会怎么写？**我一般想也不想，肯定是这样的写法：    if(ch >= 'A' && ch ='a' && ch function countdown(n)               if n  countdown(10)    10 9 8 7 6 5 4 3 2 1 end所以从这段示例代码中，可以看出，Julia主要有这样几个特点： 1.  用 function    关键字来声明一个函数；        2.  用 end 关键字作为块（函数声明、if 语句、for    语句等）的结尾；        3.  函数的参数可以不用指定类型（变量声明也不需要），因为它是动态类型的；        4.  Julia 支持递归函数。        **那么 Julia的编译器是用什么语言实现的呢？又是如何支持它的这些独特的特性的呢？**带着这些好奇，让我们来看一看 Julia编译器的源代码。 ![](Images/1f6fc602f3b9ad2154b1bbcbb3ff7f72.png)savepage-src="https://static001.geekbang.org/resource/image/7c/9f/7cdbbdbe9a95d0077331ayy8b8608f9f.jpg"}图 2：Julia 的源代码目录slate-object="mark"} 其实 Julia 的实现会让人有点困扰，因为它使用了 4 种语言：C、C++、Lisp和 Julia 自身。相比而言，CPython 的实现只用了两种语言：C 语言和Python。这种情况，就对社区的其他技术人员理解这个编译器和参与开发，带来了不小的困难。 Julia 的作者用 C语言实现了一些运行时的核心功能，包括垃圾收集器。他们是比较偏爱 C语言的。C++ 主要是用来实现跟 LLVM 衔接的功能，因为 LLVM 是用 C++实现的。 但是，为什么又冒出了一个 Lisp 语言呢？而且前端部分的主要功能都是用Lisp 实现的。 原来，Julia 中用到 Lisp 叫做femtolisp（简称 flisp），这是杰夫·贝赞松（JeffBezanson）做的一个开源 Lisp实现，当时的目标是做一个最小的、编译速度又最快的 Lisp 版本。后来 JeffBezanson 作为 Julia 的核心开发人员，又把 flisp 带进了Julia。 实际上，Julia 语言本身也宣称是继承了 Lisp语言的精髓。在其核心的设计思想里，在函数式编程风格和元编程功能方面，也确实是如此。Lisp在研究界一直有很多的追随者，Julia 这个项目诞生于MIT，同时又主要服务于各种科研工作者，所以它也就带上了这种科学家的味道。它还有其他特性，也能看出这种科研工作者的倾向，比如说： 1.  对于类型系统，Julia    的开发者们进行了很好的形式化，是我在所有语言中看到的最像数学家做的类型系统。        2.  在它的语法和语义设计上，带有 Metalab 和 Mathematics    这些数学软件的痕迹，科研工作者们应该很熟悉这种感觉。        3.  在很多特性的实现上，都带有很强的前沿探索的特征，锋芒突出，不像我们平常使用的那些商业公司设计的计算机语言一样，追求四平八稳。        以上就是我对 Julia的感觉，一种**结合了数据家风格的自由不羁的极客风**。实际上，Lisp 最早的设计者约翰·麦卡锡（JohnMcCarthy）就是一位数学博士，所以数学上的美感是 Lisp给人的感受之一。而且，Lisp 语言本身也是在 MIT 发源的，所以 Julia可以说是继承了这个传统、这种风格。 Julia 的编译过程刚刚说了，Julia 的前端主要是用 Lisp 来实现的。你在启动 Julia的时候，通过"--lisp"参数就可以进入 flisp 的REPL：     ./julia --lisp在这个 REPL 界面中调用一个 julia-parse 函数，就可以把一个 Julia语句编译成 AST。     > (julia-parse "a = 2+3*5")    (= a (call + 2           (call * 3 5)))    > (julia-parse "function countdown(n)                        if n  function foo(x,y)   #一个简单的函数，把两个参数相加               x+y        #最后一句的结果就是返回值，这里可以省略return           end通过 \@code_llvm 宏生成的 LLVMIR，如下图所示： ![](Images/a02506083f6d588e6f4e5686c804d300.png)savepage-src="https://static001.geekbang.org/resource/image/c1/35/c1bb01e06ed7262107b24ab99b7b1f35.jpg"}通过 \@code_native宏输出的汇编代码是这样的： ![](Images/62011e43e25f9ea965c0e1e64a33f3f1.png)savepage-src="https://static001.geekbang.org/resource/image/df/3c/dfc49ac304b06700a484886e4bf1cf3c.jpg"}最后生成的汇编代码，可以通过汇编器迅速生成机器码并运行。 通过上面的梳理，你应该已经了解了 Julia的编译过程脉络：**通过 Lisp 的程序，把程序变成 AST，然后再变成更低级一点的IR，在这个过程中编译器要进行类型推断等语义层面的处理；最后，翻译成 LLVM的IR，并生成可执行的本地代码。** 对于静态类型的语言来说，我们根据准确的类型信息，就可以生成高效的本地代码，这也是C 语言性能高的原因。比如，我们用 C 语言来写一下 foo函数：     long foo(long x, long y){        return x+y;    }Clang 的 LLVM IR 跟 Julia生成的基本一样： ![](Images/4632bccd10111ee6ee8838de871f0f27.png)savepage-src="https://static001.geekbang.org/resource/image/39/e3/3962f55b94074a305f5a33226a67c6e3.jpg"}生成的汇编代码也差不多： ![](Images/a1ad98e46246f1606f631894e1ee675f.png)savepage-src="https://static001.geekbang.org/resource/image/65/64/65c786870b31ac1bd831407daa8fa064.jpg"}所以，对于这样的程序，Julia 的编译后的本地代码，跟 C语言的比起来可以说是完全一样。那性能高也就不足为奇了。 你可能由此就会下结论：因为 Julia 能够借助 LLVM生成本地代码，这就是它性能高的原因。 **且慢！事情没有这么简单。**为什么这么说？因为在基于前面生成的机器码的这个例子中，当参数是整型的时候，运行效率自然是会比较快。但是，你别忘了Julia 是动态类型的语言。我们在 Julia 中声明 foo函数的时候，并没有指定参数的数据类型。如果参数类型变了，会怎样呢？ Julia 的最大突破：生成多个版本的目标代码实际上，我们可以给它传递不同的参数，比如可以传递两个浮点数给它，甚至传递两个向量或者矩阵给它，都能得到正确的结果：     julia> foo(2.1, 3.2)    5.300000000000001    julia> foo([1,2,3], [3,4,5])    3-element Array{Int64,1}:     4     6     8显然，如果上面两次对 foo()函数的调用，我们也是用之前生成的汇编代码，那是行不通的。因为之前的汇编代码只能用于处理64 位的整数。 实际上，如果我们观察调用 foo(2.1, 3.2) 时，Julia 生成的 LLVM IR和汇编代码，就会发现，它智能地适应了新的数据类型，生成了用于处理浮点数的代码，使用了不同的指令和寄存器。 ![](Images/7067931ea0aa0e65e15ae5224ef2e2cb.png)savepage-src="https://static001.geekbang.org/resource/image/6e/51/6ea3a61f54ffb74c66d6c5386f0e7c51.jpg"}你可以用同样的方法，来试一下`foo([1,2,3], [3,4,5])` 对应的 LLVM IR和汇编代码。这个就要复杂一点了，因为它要处理数组的存储。但不管怎样，Julia生成的代码确实是适应了它的参数类型的。 数学中的很多算法，其实是概念层面的，它不关心涉及的数字是 32位整数、64位整数，还是一个浮点数。但同样是实现一个加法操作，对于计算机内部实现来说，不同的数据类型对应的指令则是完全不同的，那么编译器就要弥合抽象的算法和计算机的具体实现之间的差别。 对于 C 语言这样的静态语言来说，它需要针对 x、y的各种不同的数据类型，分别编写不同的函数。这些函数的逻辑是一样的，但就是因为数据类型不同，我们就要写很多遍。这是不太合理的，太啰嗦了。 对于 Python这样的动态类型语言来说呢，倒是简洁地写一遍就可以了。但在运行时，对于每一次运算，我们都要根据数据类型来选择合适的操作。这样就大大拉低了整体的运行效率。 所以，这才是 Julia真正的突破：**它能针对同一个算法，根据运行时获得的数据，进行类型推断，并编译生成最优化的本地代码。**在每种参数类型组合的情况下，只要编译一次，就可以被缓存下来，可以使用很多次，从而使得程序运行的总体性能很高。 你对比一下 JavaScript编译器基于类型推断的编译优化，就会发现它们之间的明显的不同。JavaScript编译器一般只会针对类型推断生成一个版本的目标代码，而 Julia则会针对每种参数类型组合，都生成一个版本。 不过，既然 Julia编译器存在多个版本的目标代码，那么在运行期，就要有一个程序来确定到底采用哪个版本的目标代码，这就是Julia 的一个非常重要的功能：**函数分派算法**。 函数分派，就是指让编译器在编译时或运行时来确定采用函数的哪个实现版本。针对函数分派，我再给你讲一下Julia的一个特色功能，多重分派。这个知识点有助于你加深对于函数分派的理解，也有助于你理解函数式编程的特点。 Julia 的多重分派功能我们在编程的时候，经常会涉及同一个函数名称的多个实现。比如在做面向对象编程的时候，同一个类里可以有多个相同名称的方法，但参数不同，这种现象有时被叫做**重载（Overload）**；同时，在这个类的子类里，也可以定义跟父类完全相同的方法，这种现象叫做**覆盖（Override）**。 而程序在调用一个方法的时候，到底调用的是哪个实现，有时候我们在编译期就能确定下来，有时候却必须到运行期才能确定（就像多态的情形），这两种情形就分别叫做**静态分派（Static Dispatch）和动态分派（DynamicDispatch）**。 方法的分派还有另一个分类：**单一分派（Single Dispatch）和多重分派（MultipleDispatch）**。传统的面向对象的语言使用的都是单一分派。比如，在面向对象语言里面，实现加法的运算：     a.add(b)这里我们假设 a 和 b 都有多个 add方法的版本，但实际上，无论怎样分派，程序的调用都是分派到 a对象的方法上。这是因为，对于 add 方法，实质上它的第一个参数是对象a（编译成目标代码时，a 会成为第一个参数，以便访问封装在 a里面的数据），也就是相当于这样一个函数：     add(a, b)所以，**面向对象的方法分派相当于是由第一个参数决定的。这种就是单一分派**。 实际上，采用面向对象的编程方式，在方法分派时经常会让人觉得很别扭。你回顾一下，我在讲Python 编译器slate-object="inline"的时候，讲到加法操作采用的实现是第一个操作数对象的类型里，定义的与加法有关的函数。**但为什么它是用第一个对象的方法，而不是第二个对象的呢？如果第一个对象和第二个对象的类型不同怎么办呢？**（这就是我在那讲中留给你的问题） 还有一个很不方便的地方。如果你增加了一种新的数据类型，比如矩阵（Matrix），它要能够跟整数、浮点数等进行加减乘除运算，但你没有办法给Integer 和 Float这些已有的类增加方法。 所以，针对这些很别扭的情况，Julia 和 Lisp等函数式语言，就支持**多重分派**的方式。 你只需要定义几个相同名称的函数（在 Julia里，这被叫做同一个函数的多个方法），编译器在运行时会根据参数，决定分派给哪个方法。 我们来看下面这个例子，foo函数有两个方法，根据调用参数的不同，分别分派给不同的方法。     julia> foo(x::Int64, y::Int64) = x + y  #第一个方法    foo (generic function with 1 method)        julia> foo(x, y) = x - y                #第二个方法    foo (generic function with 2 methods)    julia> methods(foo)                     #显示foo函数的所有方法    
# 2 methods for generic function "foo":    [1] foo(x::Int64, y::Int64) in Main at REPL[38]:1    [2] foo(x, y) in Main at REPL[39]:1    julia> foo(2, 3)                        #分派到第一个方法    5    julia> foo(2.0, 3)                      #分派到第二个方法    -1.0你可以发现，这种分派方法会**公平对待函数的所有参数，而不是由一个特殊的参数来决定。这种分派方法就叫做多重分派。** 在 Julia中，其实"+"操作符（以及其他操作符）也是函数，它有上百个不同的方法，分别处理不同数据类型的加法操作。     julia> methods(+)    