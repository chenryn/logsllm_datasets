2、这段代码确保我们不会覆盖我们的值，或链接寄存器，然后调用 `GetMailboxBase`。
```
channel .req r1
value .req r2
mov value,r0
push {lr}
bl GetMailboxBase
mailbox .req r0
```
3、这段代码加载当前状态。
```
wait1$:
status .req r3
ldr status,[mailbox,#0x18]
```
4、这段代码检查状态字段的头一位是否为 0，如果不为 0，循环回到第 3 步。
```
tst status,#0x80000000
.unreq status
bne wait1$
```
5、这段代码将通道和值组合到一起。
```
add value,channel
.unreq channel
```
6、这段代码保存结果到写入字段。
```
str value,[mailbox,#0x20]
.unreq value
.unreq mailbox
pop {pc}
```
`MailboxRead` 的代码和它非常类似。
1. 我们的输入将从哪个邮箱读取（`r0`）。我们必须要验证邮箱的真实性。不要忘了验证输入。
2. 使用 `GetMailboxBase` 去检索地址。
3. 读取 `Status` 字段。
4. 检查第 30 位是否为 0。如果不为 0，返回到第 3 步。
5. 读取 `Read` 字段。
6. 检查邮箱是否是我们所要的，如果不是返回到第 3 步。
7. 返回结果。
我们来按顺序写出它们中的每一步。
1、这一段代码来验证 `r0` 中的值。
```
.globl MailboxRead
MailboxRead:
cmp r0,#15
movhi pc,lr
```
2、这段代码确保我们不会覆盖掉我们的值，或链接寄存器，然后调用 `GetMailboxBase`。
```
channel .req r1
mov channel,r0
push {lr}
bl GetMailboxBase
mailbox .req r0
```
3、这段代码加载当前状态。
```
rightmail$:
wait2$:
status .req r2
ldr status,[mailbox,#0x18]
```
4、这段代码检查状态字段第 30 位是否为 0，如果不为 0，返回到第 3 步。
```
tst status,#0x40000000
.unreq status
bne wait2$
```
5、这段代码从邮箱中读取下一条消息。
```
mail .req r2
ldr mail,[mailbox,#0]
```
6、这段代码检查我们正在读取的邮箱通道是否为提供给我们的通道。如果不是，返回到第 3 步。
```
inchan .req r3
and inchan,mail,#0b1111
teq inchan,channel
.unreq inchan
bne rightmail$
.unreq mailbox
.unreq channel
```
7、这段代码将答案（邮件的前 28 位）移动到寄存器 `r0` 中。
```
and r0,mail,#0xfffffff0
.unreq mail
pop {pc}
```
### 4、我心爱的图形处理器
通过我们新的邮差程序，我们现在已经能够向图形卡上发送消息了。我们应该发送些什么呢？这对我来说可能是个很难找到答案的问题，因为它不是任何线上手册能够找到答案的问题。尽管如此，通过查找有关树莓派的 GNU/Linux，我们能够找出我们需要发送的内容。
消息很简单。我们描述我们想要的帧缓冲区，而图形卡要么接受我们的请求，给我们返回一个 0，然后用我们写的一个小的调查问卷来填充屏幕；要么发送一个非 0 值，我们知道那表示很遗憾（出错了）。不幸的是，我并不知道它返回的其它数字是什么，也不知道它意味着什么，但我们知道仅当它返回一个 0，才表示一切顺利。幸运的是，对于合理的输入，它总是返回一个 0，因此我们不用过于担心。
> 
> 由于在树莓派的内存是在图形处理器和主处理器之间共享的，我们能够只发送可以找到我们信息的位置即可。这就是 DMA，许多复杂的设备使用这种技术去加速访问时间。
> 
> 
> 
为简单起见，我们将提前设计好我们的请求，并将它保存到 `framebuffer.s` 文件的 `.data` 节中，它的代码如下：
```
.section .data
.align 4
.globl FrameBufferInfo
FrameBufferInfo:
.int 1024 /* #0 物理宽度 */
.int 768 /* #4 物理高度 */
.int 1024 /* #8 虚拟宽度 */
.int 768 /* #12 虚拟高度 */
.int 0 /* #16 GPU - 间距 */
.int 16 /* #20 位深 */
.int 0 /* #24 X */
.int 0 /* #28 Y */
.int 0 /* #32 GPU - 指针 */
.int 0 /* #36 GPU - 大小 */
```
这就是我们发送到图形处理器的消息格式。第一对两个关键字描述了物理宽度和高度。第二对关键字描述了虚拟宽度和高度。帧缓冲的宽度和高度就是虚拟的宽度和高度，而 GPU 按需要伸缩帧缓冲去填充物理屏幕。如果 GPU 接受我们的请求，接下来的关键字将是 GPU 去填充的参数。它们是帧缓冲每行的字节数，在本案例中它是 `2 × 1024 = 2048`。下一个关键字是每个像素分配的位数。使用了一个 16 作为值意味着图形处理器使用了我们上面所描述的高色值模式。值为 24 是真彩色，而值为 32 则是 RGBA32。接下来的两个关键字是 x 和 y 偏移量，它表示当将帧缓冲复制到屏幕时，从屏幕左上角跳过的像素数目。最后两个关键字是由图形处理器填写的，第一个表示指向帧缓冲的实际指针，第二个是用字节数表示的帧缓冲大小。
在这里我非常谨慎地使用了一个 `.align 4` 指令。正如前面所讨论的，这样确保了下一行地址的低 4 位是 0。所以，我们可以确保将被放到那个地址上的帧缓冲（`FrameBufferInfo`）是可以发送到图形处理器上的，因为我们的邮箱仅发送低 4 位全为 0 的值。
> 
> 当设备使用 DMA 时，对齐约束变得非常重要。GPU 预期该消息都是 16 字节对齐的。
> 
> 
> 
到目前为止，我们已经有了待发送的消息，我们可以写代码去发送它了。通讯将按如下的步骤进行：
1. 写入 `FrameBufferInfo + 0x40000000` 的地址到邮箱 1。
2. 从邮箱 1 上读取结果。如果它是非 0 值，意味着我们没有请求一个正确的帧缓冲。
3. 复制我们的图像到指针，这时图像将出现在屏幕上！
我在步骤 1 中说了一些以前没有提到的事情。我们在发送之前，在帧缓冲地址上加了 `0x40000000`。这其实是一个给 GPU 的特殊信号，它告诉 GPU 应该如何写到结构上。如果我们只是发送地址，GPU 将写到它的回复上，这样不能保证我们可以通过刷新缓存看到它。缓存是处理器使用的值在它们被发送到存储之前保存在内存中的片段。通过加上 `0x40000000`，我们告诉 GPU 不要将写入到它的缓存中，这样将确保我们能够看到变化。