www.TopSage.com
---
## Page 223
产生脚本
112A
提供了不同的选项集：
在初始文件中使用Shel1风格的注释固然方便，不过我们还是可以使用STRIPCOMENTS
将它们副除，这是假设此注释字符并未出现在文件中：
STRIPCOMMENTS=′Sed -e s/#.*$//'
我们也需要一个过滤器，将数据流过滤为内缩状（比较好看的输出），并将换行字符置
换为空格：
JOINLINES=*tr *\n′*\040**
INDENT=*awk*( print \*\t\t1t\*\S0 )**
接下来是两个可选用的初始文件的定义：
defaultdirectories=$BUILDHOME/directories
defaultuserhosts=SBUILDHONE/userhosts
最后的初始化会设置来源目录的列表：
SRCDIRS=**SSTRIPCOMENTS $defaultdirectories 2> /dev/nu11**
由于命令替换会将换行字符转换成空格且以空白字符回人的方式排列，在初始化文件里
的目录，可以写成一行一个或多个目录的方式。
如果用户定制文件不存在，STRIPCOMMENTS会在SRCDIRS中产生一个空字符串，所以
我们要测试这样的情况，并把SRCDIRS重新设置为合理的默认值列表，这个列表根据
我们多年的使用经验得来：
test -z*$SRCDIRS* 5&\
SRCDIRS=*
fusr/local/src
/usx/1ocal/gnu/sre
SHOME/gnu/src
SHOMB/SrC
/tmp
fu8x/tmp
/var/tmp
在行结尾处，11和&&运算符后面接着一个反斜杠是C-Shell家族的要求，而这么作对
Bourne-Shell家族也无碍。当前目录（.）为此列表的成员，因为我们可能就只是将要构
建的包文件下载到一个任意位置。
www.TopSage.com
---
## Page 224
212
第8章
现在初始化该做的事都照顾到了，所以我们已经准备好处理命令行选项。这个任务在所
有Shell脚本下的处理方式都相同：while（当）参数仍在时，选择case语句的一个
合适的分支来处理该参数，然后再shift（移到）参数列表里的下一个参数，并继续循
环。任何需要先消耗另一个参数的分支，会进行移位。正如我们之前做过的，我们允许
单个与双个连字号的选项形式，而且我们也允许它们缩短为任何唯一性的字首：
vhile test s# -ot 0
do
case $1 1n
--al1、--cd、--check，--configure情况会存储接下来的参数，丢弃任何前一个存
下来的值：
--a11 1 --al 1 --a I -a11 1 =al 1 -a 1
shift
ALLTARG&TS='$1*
II
{ po- 1 po-
shift
1
-check 1
--chec 1 ==che 1 -=ch 1 -check 1 -chec I =che 1 =ch }
Bhift
--configure 1 --configur 1 --configu 1 --config 1 --confi 1 \
\1 0o- 1 uo2-- 1 guo3
-configure 1 -configur I-configu 1-config 1-confi 1 \
(02-1 u00-1 Ju00-
CONFIGUREFLAGS=*$1*
shift
--environment选项可让用户在构建主机上，提供配置期环境变量的一次性设置，而
无须要修改构建配置文件：
--enviroruent 1 --environnen 1 --environme 1 =-environm 1 =-environ 1 \
--enviro 1 --envir I --envi I --env 1 --en I --e 1 \
-environment 1 -environnen 1 -environne 1 -environn 1  -environ 1 \
-enviro 1-envir 1  -envi 1 -env 1-en I -e )
shift
EXTRAIDVIROIMENT=*S1*
--help情况会调用我们尚未被显示的函数之一，并终止程序：
[-, I y- 1 au- 1 reu- 1 dra 1 , /dev/nu11**
否则，如果userhosts变量为空，期仍有两种可能作法。如果ALTUSERHOSTS已设置，
我们会保持原封不动，如来未设置，则将其设置为默认文件。接着，我们指定
ALTUSERHOSTS里的文件的内容给userhosts变量，成为最终列表：
fi
userhoets=*^$STRIPCONMENrTS $AL/TUSERHOSTS 2> /dev/nu11**
在开始真正的操作之前，为确保我们至少有一个主机，有必要进行健康检查。虽然在此
种情况下最里面的循环不会被执行，但我们还是要避免产生不必要的目录与日志文件。
如果userhosts为空，则有可能是用户大意了，所以这时可以适时地提醒他这个程序的
用法：
test -z *Suserhosts* &s usage_and_exit 1
最后是程序最外部的循环，用来处理包。如果参数列表为空，则Shell不会执行循环体，
这正是我们要的。这个循环很大，所以我们一次只介绍几行即可：
for p in *$8*
op
在来源目录列表里，寻找包存档文件的工作委托find_package函数来做，它会将结果
留在全局性变量：PARFILE（包存档文件：package archive file）里：
find_package *$p*
如PARPILE为空，则我们就把使用方式错误的信息发出到标准错误输出，再继续处理下
一个包：
if test -z *$PARFILE*
then
continue
www.TopSage.com
---
## Page 228
216
第8章
另一方面，如果未提供日志目录，或有提供但不是目录或是不能写人、则我们会试图在
包存档文件被找到的目录下，建立名为1ogs的子目录。如果找不到该目录，或无法写
入，则我们会试着将日志文件放在用户的sHoME/.build/logs目录或临时目录内。我
们倾向于尽量不要使用临时目录/tmp，因为在开机后通常它的内容会消失，所以只将
它作为没办法时的最后手段。
L0GDIR=*$altlogdir*
then
for LOGDIR in *^dirnane $PARFILE²/1ogs/Sp* S8UILoHOME/1ogs/Sp \
do
/usz/tnp /var/tmp /tmp
fi
done
注意：dirname 命令是与8.1节介绍过的basename命令一起的，dirnane会截新其参数里最后
斜杠之后的所有字符，以从完整路径名称中恢复一个目录路径，并将结果显示到标准输出：
S dlrname /usr/local/bdn/nawik
报告目录路径
/usr/locel/bin
如果参数里没有斜杠，dirname会产生一个点号（.）以表示目前目录：
S dirname whinsical-nane
报告目录路径
dlrnamne就像basename一样，视其参数为单纯的文字字符串，而不会去检查目录是否真
的存在于文件系统中。
如省略参数，则Girname的行为模式由运行时定义。
我们会告知用户日志文件建立于何处，并将该位置记录于电子邮件中，因为用户有可能
在大型包构建完成之前就忘了日志文件的位置：
msg=*Check build logs for Sp in *hostname*:$LoGDIR*
echo *$nag*
主循环里的最后一步便是通过嵌套循环，以井行处理的方式，令每台远程主机开始构建
现行包。我们再一次将大部分的工作交给函数来做。这也会结束最外部循环：
tor u in Suserhosts
OD
bui1d_one $u
Gone
done
www.TopSage.com
---
## Page 229
产生脚本
build_one的调用为连续性的，所以我们可以更容易地识别出通信的间题，然而：它们OIm1
在远程构建主机上起始的工作都以后台执行，所以build_one其实很快就完成。
现在，程序已完成它的工作。最后的语句是将累加状态码最高限定在125，并将状态码
返回给调用者：
=gt 125 &&EXITC0DE=125
我们已将许多构建过程留在后台执行，将它们的输出信息不断累积在相关的日志文件里，
并选择无论结果为何都会退出，所以build-all才得以执行得这么快。
有人可能会倾向于另一种设计方式，就是先不返回，一直等到所有后台进程都完成时再
返回。要改成这种方式也很简单：只要在最后的exit语句之前插人以下这条语句：
wait
我们不觉得这种方式好，因为它会挂在终端窗口上直到所有构建完成为止，或是如果
buila-al1在后台执行，它的完成通知可能会混合许多其他的输出。如果它出现得太后
面的话，可能还会找不到。