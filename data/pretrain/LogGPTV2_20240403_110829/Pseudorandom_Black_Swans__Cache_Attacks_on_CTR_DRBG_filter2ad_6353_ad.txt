nonce 1 < k < n. The signature is the pair r = (kG)x mod n
and s = k −1(H(m) + rdA) mod n, where Px represents the x-
coordinate of an elliptic curve point P, and H(m) is the hash
of the message m using a collision-resistant hash function
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1247
00 02
Padding
00
48-byte PMS
Fig. 3: PKCS#1v1.5 RSA encryption padding appends a
pseudorandom padding string to the message, together
with some ﬁxed bytes. The padding block is ﬁlled with
k − 3 − (cid:4) non-zero bytes that are generated by a PRG,
where k is the byte-length of the modulus and (cid:4) is the
byte-length of the message to be encrypted.
H. Next, if an attacker learns the value of the nonce k, she
can compute the private key dA from the signature as dA =
(sk − H(m))r −1 mod n. We omit the details of the signature
veriﬁcation procedure, as they are orthogonal to our attacks.
C. TLS Handshake Protocol
We describe the details of the TLS 1.0–1.2 handshake
protocol required for our attack. A TLS handshake begins
with a ClientHello message containing a 32-byte nonce along
with a list of supported cipher suites. The standard speciﬁes
that the nonce should consist of a four-byte timestamp and 28
bytes of raw output from a pseudorandom number generator.
The ServerHello message contains a similar nonce and the
server’s choice of cipher suite. We specialize to the case
of RSA key exchange with mutual authentication, an option
that is enabled for higher-security deployments, for VPN-over-
TLS, and other instances where the server needs assurance
of the client’s identity. For these cipher suites, the server
then sends a Certiﬁcate message with its certiﬁcate chain, a
CertiﬁcateRequest message, and a ServerHelloDone message.
The client checks the server certiﬁcate, generates a 48-byte
premaster secret (PMS) and encrypts it to the server’s public
key from the certiﬁcate. The PMS and padding formatting are
shown above in Fig. 3.
The client then sends the RSA-encrypted PMS in a Clien-
tKeyExchange message, sends its own certiﬁcate in a Certiﬁ-
cate message, and a CertiﬁcateVerify message containing a
signature computed over a transcript of the handshake thus far,
that proves it possesses the relevant private key.
On receiving the encrypted ClientKeyExchange, the server
decrypts the message, veriﬁes the structure of the padding has
the correct structure, and extracts the PMS. The server then
veriﬁes the client certiﬁcate. Both client and server then derive
symmetric encryption and authentication keys by applying a
key derivation function to the PMS and the client and server
nonces. Both sides exchange messages to authenticate the
handshake, then begin transmitting encrypted trafﬁc.
D. Finding Enough Randomness in TLS
The state recovery attack described in Section V required
1996 bytes of output from the PRG. Thus, for our cache side-
channel attack to work at the protocol level, we needed to
ﬁnd places in the handshake where a single PRG call would
request enough output for an attacker to feasibly carry out state
recovery. We evaluated the TLS protocol for potential sources
of large or variable length randomness and settled on three
possibilities: the ExtendedRandom TLS extension, RSASSA-
PSS padding, and RSA PKCS#1 v1.5 padding.
ExtendedRandom TLS Extension.
ExtendedRandom is
a non-standard extension to TLS that was proposed to the
IETF [25] to permit clients to request up to 216 − 1 bytes
of randomness from the server. While our attacks (as well
as those of [19, 20]) may have been able to make use of
the increased output from the server’s generator to recover
secret information, there are no known implementations with
a functional implementation of this extension [25].
RSA-PSS. We evaluated whether the generation of the random
salt for RSA-PSS signatures provided a viable attack vector.
Under the PSS speciﬁcation, for a message of 214 bytes, the
maximum salt length allowed is 2016 bytes, or 126 blocks of
PRG output, sufﬁcient for our state recovery attack. However,
since RFC8446 [72] restricts the salt length when PSS is used
in TLS1.2, an attacker in this context cannot observe enough
encryptions from calls to the underlying PRG.
PKCS#1 v1.5 Padding in TLS. When a TLS handshake is
performed with an RSA cipher suite, the client generates the
32-byte PMS and encrypts it under the server’s RSA public
key, transmitting it in the ClientKeyExchangeMessage. If the
malicious sever uses a 16384-bit RSA modulus, the client
must generate 2,013 padding bytes, equivalent to 126 blocks
of PRG output. This is enough blocks for us to mount the state
recovery attack. We thus target this mode of TLS.
E. Targeting TLS Clients
Unlike the attacks in [18–20], which compromise the
server’s PRG, we compromise the state of the PRG used by
the TLS client, since the client is the party that generates the
encrypted key exchange message. However, similar to those
works, we use the recovered state to predict future outputs of
the PRG. In our case, this allows us to recover the client’s
long-term authentication key.
Threat Model. We assume an attacker who can induce the
client to connect to a malicious TLS server, and that the client
uses ECDSA for digital signatures. We also assume that the
attacker is capable of running unprivileged code on the client.
Attack Overview.
The attacker conﬁgures her server to
support only TLS versions 1.0 through 1.2 (and not 1.3),
and to require RSA key exchange. The client connects and
begins the TLS handshake procedure. Since the RSA PKCS
padding generation procedure requires the client to generate
pseudorandom bytes, the attacker can use the cache leakage
traces collected during the generation of the PKCS padding
to recover the client’s PRG state via the method described in
Section V. With the client’s PRG state successfully recovered,
the attacker predicts the subsequent PRG output and thus is
able to compute the ECDSA nonce that the client generates
in the course of producing the digital signature for the
CertiﬁcateVerify message. As outlined in Section VI-B, an
attacker who knows the nonce used to generate an ECDSA
signature can trivially recover the long-term private key used
for client authentication, even if that key was generated in a
secure manner. Recovering the signing key allows the attacker
to impersonate the client. This may allow the attacker to
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1248
access TLS-protected resources that are served only to an
authenticated client. Our attack proceeds as follows:
1) Victim Client Connects
to an Attacker-Controlled
Server. A client with an ECDSA certiﬁcate is manipulated
into visiting a web page with an attacker controlled script.
The script initiates TLS handshakes with RSA cipher suites,
to an attacker-controlled server. The server transmits an
RSA certiﬁcate and requests mutual authentication.
2) Recovering PRG State. The client’s software encrypts
the TLS premaster secret using the server’s RSA public
key, generating PKCS#1v1.5 padding proportional to the
size of the certiﬁcate. The attacker simultaneously conducts
the state recovery attack explored in Section V.
3) ECDSA Signature Generation.
The client transmits
its certiﬁcate and generates a random nonce to sign the
CertiﬁcateVerify message using ECDSA. The client then
transmits the signed CertiﬁcateVerify message to the server.
4) Recovering the Client’s Nonce. The attacker conducts an
ofﬂine search for entropy and addin parameters used by the
PRG to generate the client’s ECDSA nonce. The attacker
checks candidates by recomputing the ECDSA signature
and validating it against the client-transmitted signature.
5) Key Recovery. The attacker computes the client’s ECDSA
private key and can now impersonate the client.
Performing Nonce Recovery. To perform Item 4, the state
of the client’s PRG must be advanced to the point at which
ECDSA nonce generation occurs. The attacker can only wind
the generator forward, and at each call to the generate and
reseed functions the attacker must guess the entropy and
additional input parameters. Thus, the attacker must pay close
attention to implementation-speciﬁc details surrounding the
ordering of calls to the PRG. We illustrate this challenge using
OpenSSL 1.0.2, which we used as our baseline implementation
for our nonce-recovery attacks.
F. Using PKCS#1 v1.5 in OpenSSL 1.0.2 for Nonce Recovery
We begin by describing the steps performed by OpenSSL
during the establishment of a TLS connection to generate the
random PKCS#1 v1.5 padding and ECDSA nonce. For ease
of reference, we label each step of these processes. We then
describe our end-to-end attack on OpenSSL 1.0.2.
1. Initial Padding Generation. The output of the PRG is fed
into an n-byte buffer to be used for PKCS#1 v1.5 padding,
where n is the length of padding required (in our case
n = 1996). The state is updated twice, once before the bytes
are generated and once after. State compromise occurs after
the ﬁrst call to update, but prior to the second.
2. Padding Zero-Fill. PKCS#1 v1.5 does not allow 0x00
bytes to be present in the random padding, so if there are z
0x00 bytes present in the PKCS output buffer, OpenSSL
makes at least z more requests for output from the PRG,
one for each byte. If any of these additional requests also
result in a 0x00 byte, OpenSSL makes repeated requests to
the PRG until the output is non-zero. The output from these
requests is used to replace the null bytes in the padding
to produce a valid non-null padding string under PKCS#1
v1.5. Within each request for random bytes, the PRG state
is advanced twice. Both updates use the same underlying
additional input.
3. RAND_seed. The ECDSA signing routine tries to reseed
OpenSSL’s RNG via RAND_seed. The SHA256 hash of
the TLS handshake transcript is used as external entropy.
4. RAND_add. A call to RAND_add is made as part of
bnrand, which is used to generate a random integer in a
given range. Time in seconds is used as external entropy.
5. GenNonce. OpenSSL then generates the ECDSA nonce.
Within the call to the CTR_DRBG generate function, the
state is updated before the nonce value is ﬁnally produced.
Notably, Steps 3 and 4 call functions from the OpenSSL PRG
API, which as discussed in Section VI-G does not always
reseed or update CTR_DRBG.
Causing a Large Number of Random Byte Generations.
To perform the attack, the attacker must observe side-channel
leakage during the generation of a large amount of randomness.
Moreover, to recover the PRG’s state, the attacker must learn
the values of the victim-generated randomness. In our attack
scenario, the attacker could cause a victim client to connect
to the attack server using a malicious script served by an ad
network on a website the user would otherwise normally visit.
The attacker’s server is conﬁgured to support only RSA key
exchange, and deliberately serves a 16534-bit RSA certiﬁcate,
which is the maximum size that an OpenSSL client will accept
without throwing an error. This is due to deliberate, hard-
coded limits on message sizes that OpenSSL will accept, in
the interest of preventing denial of service attacks [61, 63].
Next, while encrypting the PMS to the server’s 16534-bit
RSA public key to generate the ClientKeyExchange message
for the TLS handshake, the client generates 1,996 bytes of
PKCS#1v1.5 padding output, which, if using CTR_DRBG,
gives the server an opportunity to conduct a side-channel attack
against 125 AES encryptions. The attack server learns the
value of the padding generated by the client by decrypting
the padded RSA-encrypted message using its private key. The
attacker then recovers the PRG state via the method described
in Section V, using the decrypted padding as the ciphertexts.
The Problem of Padding Zero-Fill. As noted above, to
comply with the PKCS standard, there must be no 0x00
bytes in this padding. OpenSSL complies by ﬁrst generating
padding of the total length required, and then replacing each
null byte with output from further calls to the PRG, each used
to replace one zero byte. To encrypt to the malicious server’s
large certiﬁcate, OpenSSL generates 1,996 bytes of output for
padding used as per Fig. 3. In expectation, a ciphertext will
have eight such 0x00 bytes that need to be replaced.
Next, for each 0x00 byte in the padding, the generator
will have advanced an additional time. Since the attacker must
brute force over the additional entropy added at each step, this
increases the search space exponentially in the number of bytes
generated in Step 2 to recover the ﬁnal PRG state.
Bypassing RAND_add.
However, as the initial 1996
padding bytes (generated during the initial Padding Generation
step) have a uniform distribution over the 256 possible byte
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1249
values, the probability of the padding not containing 0x00
is (255/256)1996. We therefore expect that once every 2470
handshakes, the padding generated after the Padding 1 step will
not require additional calls to CTR_DRBG to produce a valid
PKCS#1 v1.5 padding string. Combining this with our success
rate for state recovery in Section V-C, an attacker recovers the
state, on expectation, once in every 218 handshakes.
Nonce Recovery. With the PRG state recovered, the attacker
proceeds to recover the client’s ECDSA nonce. Since the
nonce is generated in a new call
the PRG
is reseeded between our state recovery attack and nonce
generation. An attacker must therefore obtain the values used
during RAND_seed and RAND_add (Steps 3 and 4). The exact
strategy of recovering these values is implementation-speciﬁc.
to the PRG,
G. Implementation Choices and Nonce Recovery
In this section we describe how implementations use the
addin parameter, and how they explicitly reseed the random
number generator. We describe how this impacts our ability
to recover the value of addin and entropy used during
RAND_seed and RAND_add (Steps 3 and 4) in Section VI-F.
FortiOS.
FortiOS does not implement RAND_seed and
RAND_add, and instead relies on the nist_drbg library’s inter-
nal reseed counter. As a result, RAND_seed and RAND_add
do not cause a state update, reducing the attack complexity.
Furthermore, as FortiOS does not use the optional additional
input for calls to generate, the PRG can be wound forward
without the ofﬂine search for additional input.
Custom Parameters for FortiOS. We modify the For-
tiOS implementation to illustrate that even if it were to
improve its reseeding and updating strategies, the implemen-
tation can be attacked in the absence of sufﬁciently high-
quality entropy input. To evaluate this, we modiﬁed the
FortiOS RAND_METHOD behavior to cause it to reseed during
RAND_seed and RAND_add. Moreover, we added support
for the additional data parameter, ﬁlling it with a microsecond
timestamp to emulate OpenSSL FIPS.
OpenSSL FIPS.
The OpenSSL 1.0.2 FIPS module also