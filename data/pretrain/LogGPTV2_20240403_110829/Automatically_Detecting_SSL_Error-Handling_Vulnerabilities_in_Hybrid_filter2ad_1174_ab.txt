found, then we consider the app is free from this vulnera-
bility. We collect all the classes inherit from WebViewClient
and check them one by one to determine whether they have
overridden the method onReceivedSslError which would
be called by system callback when HTTPS certi(cid:12)cate veri-
(cid:12)cation failure occurs. The app could trust illegal pages by
overriding this method with a rather weak one. According
to our research, most app chooses to trust all certi(cid:12)cate, and
some of them use a simple way to handle this error and the
others choose to abort the page.
We have identi(cid:12)ed three common operations that app
choose to perform in onReceivedSslError.First, They trust
all certi(cid:12)cate and returns proceed signal. Obviously this is
vulnerable if it’s reachable. Second, They reject and return
cancel signal. It’s free from this vulnerability. Third, They
verify certi(cid:12)cate by itself. Some of them check hostnames,
and some of them use complex algorithm, and some of them
even show a dialog for the user to make a choice. We can’t
determine if the app is vulnerable or not by static analysis,
so we need further detect by dynamic analysis.
Build MCG We have seen some apps with unreachable
code and most of them are for testing. So we have to make
sure the overridden method onReceivedSslError is reach-
able. We would build a Method Call Graph to ful(cid:12)ll this.
It is a directed graph representing the calling relationship
among methods. Each node in MCG represents one method
and an edge from Method A to Method B means that Method
A could call Method B directly. We employed a conserva-
tive approach like[6] to handle virtual method and interfaces
while building MCG. A class hierarchy was maintained dur-
ing the analysis process and all possible assignable classes
would be considered when an ambiguous reference occurred.
Algorithm 1 Build Activity Call Graph
Input:
MCG : Method Call Graph
ms : Temporary storage of methods
Output: ACG : Activity Call Graph
function BuildACG(MCG,AndroidManifest.xml )
InitACGNodes(ACG,AndroidM anif est.xml)
ms
getParents(M CG,"startActivity()")
=
[
getParents(M CG,"startActivityF orResult()");
for each method method in ms do
Eactivity = getTargetActivity(method)
IDs = FindMethodCallerViewId(M CG,method,ϕ)
for each view ID viewid in IDs do
Sactivity = (cid:12)ndActivityByViewID(viewid)
ACG = ACG [ (Sactivity-Eactivityjviewid)
end for
end for
end function
function FindMethodCallerViewId(MCG,method,IDs)
if method is View Event Method then
IDs = IDs [ FindViewId(method,M CG)
else
ms = getParents(method,M CG);
for each method tmethod in ms do
FindMethodCallerViewId(M CG,tmethod,IDs)
end for
end if
return IDs
end function
In particular, our system builds MCG based on some prior
knowledge. Because there are some method calls in system
space where we can’t reach such as method Thread.start
and method Thread.run, they do not have any relationship
in user space, but from our knowledge Thread.Start will
invoke Thread.Run. So with this knowledge we added some
edges in MCG in advance.
Locate Target Activities Native Android app UI con-
sists of several Activities in some of which WebView em-
bedded. The system callbacks would call the methods in
the classes which inherit from WebViewClient which we de-
(cid:12)ne as self-de(cid:12)ned-WebViewClient. To make sure onRe-
3
Dynamic AnalysisStatic AnalysisAPKSDisassemblyVulnerabilityDetectionBuilding ACGAndroid TesterResults(log,pic...)Fake HTTPS ServerInternetHTTPHTTPSEmulatorModifiedAndroid FrameworkEmulatorModifiedAndroid Framework593ceivedSslError is reachable code we would (cid:12)nd the activity
whose WebView uses vulnerable self-de(cid:12)ned-WebViewClient.
Once the vulnerable self-de(cid:12)ned-WebViewClient is found,
the system backtraces through MCG until the Activity which
sets the WebViewClient is found. The backtracing would
stop when it enters the system callback methods (current-
ly our system could only handle Activity.onCreate and
View.onClick) because there is no apparent method invok-
ing these methods. We call these entry methods. Once
the entry methods are found, it’s easy to determine target
Activity. If the entry methods are system callbacks of one
Activity, this Activity is the target Activity. The Activity
which owns the view is target Activity if the entry methods
are system callbacks of a view. For Android app only these
Activities that are declared in AndroidManifest.xml could
be presented. That’s why we check the target Activities set
and delete Activities which are undeclared in AndroidMan-
ifest.xml.
Build ACG Now, we have got target Activities. Our
purpose is to jump to target Activities from the launcher
Activity and trigger the vulnerability. We need to (cid:12)nd a way
from launcher Activity to each target Activity with the help
of ACG which is introduced before. We use algorithm 1 to
build ACG. Each node in ACG represents one Activity that
is declared in AndroidManifest.xml. Native Android UI
jumps from one to another Activity because of View Event
(such as Button.onClick). So each edge in ACG represents
one View ID whose event method triggers native Android
UI jumps from edge start Activity to edge end Activity. To
our knowledge, there are two system calls to make activity
jump, they are startActivity and startActivityForRe-
sult. They both need an intent which sets the jump to
Activity as parameter. To build the edges, we backtrace the
parameters of these two system calls (startActivity and
startActivityForResult) to (cid:12)nd the Activity (as A1) it s-
tarts. At the same time, we would (cid:12)nd which View Event
calls the system calls directly or indirectly during the back-
tracing process. Then we could (cid:12)nd out the View ID (as
ID1) and which Activity (as A2) owns this View. Then we
add this edge f A2 - A1 j ID1.event g to ACG. The jump-
to Activity sets in intent is not easy to (cid:12)nd. There are
six constructors of intent[4] and two kinds of intent: ex-
plicit intent and implicit intent. Explicit intent needs target
Activity name which is recorded in AndroidManifest.xml as
parameter however implicit intent just needs an action name
which is also de(cid:12)ned in AndroidManifest.xml. The Activ-
ity name of an explicit Intent could be tracked by method
backtracing and register backtracing. For implicit Intents,
we (cid:12)rst scan the AndroidManifest.xml (cid:12)le and build the
correspondence of the Activities and Actions. Once we have
got the Action, jump-to Activity could be determined via
correspondence built before.
3.2 Dynamic Analysis Module
This module is the most important part of our system. In
this module our system automatically runs each app on an
emulator and triggering native Android UI to target activity
to check whether the app shows an illegal page. We use
algorithm 2 to drive UI to target activity.
Dynamic Test Environment. In order to improve the
e(cid:14)ciency of our system we apply multi-emulator to run the
test. During this phase we need to install and run the app,
and to make it automatically we need to simulate human op-
Algorithm 2 UI Drive
Input:
ACG : Activity Call Graph
tas, target activities
for each target activity act in tas do
start target APP
tACG = copy(ACG)
ca = getCurrentActivity()
while ca is from target APP and ca is NOT act do
V iewID = FindNextEdge(tACG,ca,act)
if V iewID is NOT NULL then
perform(ViewID)
else
perform(return)
end if
WaitForJumpOrTimeOut()
ca = getCurrentActivity()
end while
if ca is act then
TryToOpenHTTPSWebPage()
end if
stop target APP
end for
function FindNextEdge(ACG,ca,ta)
path = (cid:12)ndPath(ACG,ca,ta)
if path is ϕ then
return NULL
else
edg = (cid:12)rst edge of path
ACG = ACG - edg
return edg
end if
end function
erations on testing app. To meet our needs, the dynamic test
environment should have the following features: Being able
to understand the UI states, such as which activity is shown
on screen, the position and ID of each View, the screen is
showing a dialog or not; Being able to get UI objects, such
as get the object of the button that is displayed on screen;
Being able to perform actions, such as performing click ac-
tion on a button by speci(cid:12)ed button id; Being able to get
return value, such as whether a click action is successful or
not.
In order to achieve these features, we have modi(cid:12)ed An-
droid system tool instrumentation[7] by bypassing the sig-
nature veri(cid:12)cation phase, which allow us to test other apps
with our own test script app (APK) though they have di(cid:11)er-
ent signatures. With modi(cid:12)ed instrumentation, we don’t
need to re-sign the target app which may cause app crash.
We developed a general test script app of which the con(cid:12)g-
uration (cid:12)le was obtained from static analysis. With these
features, we could run the test automatically. The con(cid:12)gura-
tion (cid:12)le would be generated automatically from information
(e.g. ACG, target activities) obtained during static analysis
phase. Then the app would be installed and tested according
to the script app automatically.
After the app was installed, our system would drive the
app to jump to the target Activities and further to trigger
the vulnerability once the test script started by simulating a
series of human operations. This driving procedure is divid-
4
594Table 1: Results of Static Analysis
Table 3: Top 3 Categories of Vulnerable Activities
1360
Potential Vulnerable Apps #
Free from such Vulnerability # 12203
Decompilation Failure #
Total Apps #
257
13820
9.8%
88.3%
1.9%
Categories
Payment
Authenticate
Login&Register
Count Percentage
209
280
73
25.0%
33.5%
8.7%
Table 2: Results of Dynamic Analysis
47.4%
Vulnerability Con(cid:12)rmed #
52.6%
645
715
Potential Vulnerable Apps # 1360
Vulnerability Free #
ed into two parts: native Android UI driving and WebView
UI driving. Native Android UI driving drives the UI to tar-
get Activity and WebView driving drives WebView to load
an HTTPS web page.
We take a target Activity and calculate the path from
current Activity to it based on ACG. If the path exists,
we get the (cid:12)rst edge in path which represents a View ID
and a View event, trigger the View event for this View and