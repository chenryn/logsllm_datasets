title:Expressive policy analysis with enhanced system dynamicity
author:Robert Craven and
Jorge Lobo and
Jiefei Ma and
Alessandra Russo and
Emil C. Lupu and
Arosha K. Bandara
Expressive Policy Analysis with
Enhanced System Dynamicity∗
Robert Craven
Department of Computing
Imperial College, London
PI:EMAIL
Jorge Lobo
IBM T.J. Watson Research
Center
PI:EMAIL
Jiefei Ma
Department of Computing
Imperial College, London
PI:EMAIL
Alessandra Russo
Department of Computing
Imperial College, London
PI:EMAIL
Emil Lupu
Department of Computing
Imperial College, London
PI:EMAIL
Arosha Bandara
Department of Computing
Open University
PI:EMAIL
ABSTRACT
Despite several research studies, the eﬀective analysis of pol-
icy based systems remains a signiﬁcant challenge. Policy
analysis should at least (i) be expressive (ii) take account
of obligations and authorizations, (iii) include a dynamic
system model, and (iv) give useful diagnostic information.
We present a logic-based policy analysis framework which
satisﬁes these requirements, showing how many signiﬁcant
policy-related properties can be analysed, and we give de-
tails of a prototype implementation.
Categories and Subject Descriptors
K.6.4 [Computing Milieux]: Management of Comput-
ing and Information Systems—System Management; K.6.1
[Computing Milieux]: Management of Computing and
Information Systems—Project and People Management
General Terms
Design, Management
Keywords
Policies, Formal analysis, Security, Authorization
∗Research was sponsored by the U.S. Army Research Lab-
oratory and the U.K. Ministry of Defence and was accom-
plished under Agreement Number W911NF-06-3-0001. The
views and conclusions contained in this document are those
of the authors and should not be interpreted as represent-
ing the oﬃcial policies, either expressed or implied, of the
U.S. Army Research Laboratory, the U.S. Government, the
U.K. Ministry of Defence or the U.K. Government. The
U.S. and U.K. Governments are authorized to reproduce and
distribute reprints for Government purposes notwithstand-
ing any copyright notation hereon.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS ’09, March 10–12, 2009, Sydney, NSW, Australia
Copyright 2009 ACM 978-1-60558-394-5/09/03 ...$5.00.
1.
INTRODUCTION
There is an obvious relationship between the expressive-
ness of a policy language and the ability to analyse its prop-
erties and impact on system behaviour. Without being ex-
pressive a policy language may not be able to regulate com-
plex system behaviour, apply across heterogeneous compo-
nents, or apply to systems involving frequent changes such
as mobile systems. Yet without analysis much of the ben-
eﬁt of using policy-based techniques and declarative policy
languages may be lost. Arguably, the lack of eﬀective anal-
ysis tools accounts in part for the lack of wider adoption of
policy-based techniques.
A policy framework needs several key properties. First,
it should be expressive. We need to specify both authoriza-
tion [23, 32] and obligation policies [21, 30, 31] formally, and
to allow complex dependencies of one on the other—for in-
stance, authorization to withdraw a library book may be de-
nied if the obligation to return requested items has been re-
peatedly violated. To be expressive, a framework should also
allow policy decisions to depend on aspects of the evolving
system history, so that authorization can depend not only on
a static assignment of roles, or the ﬁxed location of a sensor,
but will vary as the system state changes. Policies must also
provide ﬁne-grained defaults. Many policy languages rely on
a simple, universal default of either permitting or denying
requests not covered by any speciﬁc policy rule. SELinux
[26], for example, has blanket denials for actions not cov-
ered explicitly by policy rules. Whilst we support such de-
faults, there is a need for a much more nuanced control over
the default behaviour, so that requests to delete a ﬁle may
be denied by default, but requests to read a ﬁle would be
authorized [22]. Defaults are also useful in the presence of
conﬂicts: the policy combination rules of XACML [30], for
example, specify the response to a request which the explicit
policy rules both authorize and deny. Our framework can
represent both sorts of default easily and concisely.
Second, a powerful policy analysis component is essential.
This lets the policies be checked for necessary or desirable
properties. Existing analysis frameworks—[21, 7, 6]—rarely
take into account the changing system state, or only allow
the statement and analysis of temporal constraints and re-
lationships amongst policy decisions. There is a strong re-
lationship between the expressiveness of a policy language
and its analysis, since a less expressive language simpliﬁes
the analysis but also limits the scope of properties that can
be checked. For example, if the language does not allow the
representation of an authorization’s dependence on the ful-
ﬁlment of two key obligations, then an analysis of whether
it was even possible to jointly satisfy those two obligations
and then obtain permission, would not be possible.
Yet, expressiveness in the representation of policies, in
the way they rely on each other, and the way in which they
interact with the system, is insuﬃcient. Policy authors also
need to check for a wide variety of properties on the policies
and systems they deﬁne. This requires an expressiveness in
the query language of the analysis component, and strength
in the analysis algorithm itself. Analysis should be able to
cope with the following tasks:
• Modality conﬂicts such as the joint authorization
and denial of a request to perform some action, or the
presence of an obligation to act without the permis-
sions necessary for its fulﬁlment.
• Separation of duty conﬂicts, including static sepa-
ration of duty, dynamic, and many other classes (see
[33] for terminology and instances).
• Coverage gaps, where no policy exists to dictate the
correct response to a request.
• Policy comparison, including whether two policies
are equivalent, or one is subsumed by the other.
• Behavioural simulation provides speciﬁc sequences
of requests and events to the policy-regulated system
to determine which policy decisions arise.
Third, the output of the analysis component should be
rich enough to provide useful diagnostic information to a
policy writer or system engineer. The system traces, policy
decisions, and actions related to a queried property should
all be indicated by the analysis—in addition to properties
of the actors or principals involved, and the policy rules
used in making the decisions that led to the state reached.
Alternative traces and decisions should also be suggested,
and the user ought to be able to insert constraints which
guide the search for diagnostic information.
Fourth, it is desirable that a policy framework is sep-
arated into a part which is used to describe the policies,
and a part which speciﬁes system behaviour—by which we
mean, the system on which the policies are deployed, and
whose requests and actions the policies govern and shape
[14]. This permits analyzing the behaviour of policies on
diﬀerent systems—something which is crucial, given the in-
creasing deployment of the same policy on heterogeneous
platforms—and spares the user the eﬀort of formalizing the
policy again for each new system.
This paper presents an expressive logical framework for
policy speciﬁcation, in which it is possible to analyse for
the types of properties mentioned above. The framework
caters for both authorization and obligation policies, and
incorporates a model of the changing system state. Our al-
gorithm gives policy authors rich diagnostic information on
analyses. We use abductive, constraint logic programming
(ACLP) systems as the basis of our analysis algorithms and
implementation, and the Event Calculus (EC) [25] to de-
scribe how events and actions occurring in the system aﬀect
the system states, leading to circumstances in which a given
policy rule is applicable. This information is an output of
the analysis.
In contrast to other logic-based formalisms ([20, 24, 22]),
our approach caters for more dynamic policy models and
includes an explicit representation of time, with temporal
variables governed by constraints, allowing policies to be
sensitive to changing system state. In addition, we include
a class of obligation policies which monitors when and how
users or the system initiate actions. This is needed for man-
aging security, but is also useful in other applications such
as context-aware adaptation in ubiquitous computing and
privacy. Our policy language is also expressive enough that
existing policy notations such as Ponder2 [31], XACML
[30] and Cassandra [7] can automatically be translated into
it; to provide analysis for speciﬁcation notations which cur-
rently do not support this. Translation algorithms have been
developed for a large class of Ponder2 policies, and we are
currently working on such schemes for XACML. We have de-
veloped a prototype implementation,1 of our analysis frame-
work.
The paper is organized as follows. Section 2 considers re-
lated work. Section 3 gives the syntax and semantics of the
language, including a number of illustrative examples. Sec-
tion 4 discusses the kinds of analysis our language permits,
together with a discussion of the implementation and com-
plexity properties. Conclusions and future research are in
Section 5.
2. RELATED WORK
The Lithium language [20] is a logical formalism for policy
representation and analysis; however, the authors work in
pure ﬁrst-order logic which imposes on the policy author the
burden of specifying complete deﬁnitions (every request has
a decision) since default decision policies are not expressible.
For example, representing that all and only faculty members
are permitted to chair committees; students are not [20] re-
quires a complete speciﬁcation of faculty and student body
members, which may change dynamically, thus raising the
well-known problem of elaboration tolerance [27]. The use of
default rules—of the kind that our formalism supports—can
simplify speciﬁcations and changes to the speciﬁcation. An-
other important diﬀerence in our work is that we perform
hypothetical analysis through abduction, letting the engi-
neer specify initial conditions and sequences of requests or
events in a system only partially; our analysis algorithm then
supplies the additional information which makes a property
true or false.
Our treatment of obligations is based on our experience
with Ponder [13] and deontic logic; the result is similar to
[21]. However, we have adapted obligation policies to pro-
duce a more general language that allows more complex poli-
cies to be represented, and our framework can support anal-
yses such as the strong accountability checking presented in
[21]. Dougherty et al. [15] present a model in which obliga-
tions are tied to authorizations, as conditions on acquiring
permission to access a given resource. The model we use
is more general, allowing obligations that are not tied to
authorizations, as well as mutual dependence.
[15] also in-
cludes a system model, though this is conceived abstractly
as a set of state traces, which would need to be deﬁned in
1http://www.doc.ic.ac.uk/~rac101/ffpa/
full—our use of EC domain descriptions allows us to gener-
ate traces of actions which lead to the holding or violation of
policy-related properties, from concise system descriptions.
Barker presents in [4] a language that represents access
control policies using stratiﬁed clausal-form logic, with em-
phasis on RBAC policies. However, this work does not dis-
cuss analysis. The Authorization Speciﬁcation Language
(ASL) [24], the Flexible Authorization Framework (FAF)
[23] and the extension to handle dynamic authorizations dis-
cussed in [11] are also based on stratiﬁed clausal-form logic.
They oﬀer techniques for detecting modality conﬂicts and
some application-speciﬁc conﬂicts in authorization policies.
However, they work with a ﬁxed domain model; in contrast,
our framework does not presume a predeﬁned domain model
and can cater for varying system descriptions.
An access control policy language is presented in [5]; it has
an associated analysis framework based on a subset of trans-
action logic programs and in these respects the approach is
similar to our own. However, although the authors do take
into account the fact that some policy-governed actions can
change role activations, and thus there is some dynamicity
in their framework, they limit the speciﬁcation to sequences
of operations. Further, they cannot represent explicit pro-
hibitions, and are thus forced into an unchangeable default
assumption that anything not explicitly allowed is to be de-
nied. Our formalism is more expressive: it has explicit prohi-
bitions, and a great degree of control can be exercised in the
way defaults cover policy gaps, or legislate between conﬂicts.
In [6], the authors use abduction to analyse authorization
policies, focussing on ﬁnding explanations for the denial of
access requests. They provide soundness, completeness and
termination results. However, as with [5], there is no fully
dynamic system model. So although credentials can be ab-
duced which would have led to the granting of access, it is
not possible to see which policy-regulated actions, or system
events, would have led to those credentials being present.
Fisler et al. [17] present an approach for the analysis of
role-based access control policies written in XACML. The
underlying formalism is MTBDDs (multi-terminal binary
decision diagrams), and the method supports the analysis
of the impact of changes on policies. There are, however,