ğ»1, ğ»2 are random oracles, and Î Â± is an ideal permutation.
Before giving the proof, we first sketch the main idea of the simu-
lator. The simulatorâ€™s job, when the adversary gives the polynomial
ğ‘ƒ, is to extract a set Ëœğ‘Œ that it can send to the ideal functionality.
Then, after learning ğ‘‹ âˆ© Ëœğ‘Œ, it simulates the message ğ¾ appropriately.
Intuitively, we want to make a distinction between KA instances
where the receiver participates versus KA instances where the re-
ceiver acts as an eavesdropper. The former instances will correspond
to the items of Ëœğ‘Œ and the latter instances will contribute to KA
outputs (and elements of ğ¾) that look random.
The honest sender will interpret Î (ğ‘ƒ(ğ»1(ğ‘¥))) as a KA message,
for every ğ‘¥ âˆˆ ğ‘‹. The receiver only â€œcontrolsâ€ this value if: (1) it made
a query to ğ»1(ğ‘¥); (2) it made a backwards query to Î âˆ’1 that resulted
in the value ğ‘ƒ(ğ»1(ğ‘¥)). If on the other hand the adversary chose
ğ‘ƒ(ğ»1(ğ‘¥)) first and only then made a forward query at Î (ğ‘ƒ(ğ»1(ğ‘¥))),
then intuitively it will have no control over the resulting value.
The simulator observes all queries to Î Â± and to ğ»1, and can
therefore use these criteria to identify which KA instances will give
outputs that the receiver can recognize. All other KA outputs can
safely be replaced with random.
We draw the readerâ€™s attention to two subtleties in the proof:
Suppose the adversary queries Î  to obtain some KA message ğ‘šâˆ—.
Since (intuitively) the adversary has no control over ğ‘šâˆ—, we would
like to argue that the corresponding KA.key(ğ‘šâˆ—) (slightly abusing
notation here) looks random. But suppose the adversary programs
ğ‘ƒ so that Î (ğ‘ƒ(ğ»1(ğ‘¦))) = ğ‘šâˆ— and Î (ğ‘ƒ(ğ»1(ğ‘¦â€²))) = ğ‘šâˆ— + 1. If the
sender has both inputs ğ‘¦ and ğ‘¦â€², then she will compute and send
KA.key(ğ‘šâˆ—) and KA.key(ğ‘šâˆ— + 1). Does the former KA output look
random even in the presence of the latter? It does if the KA protocol
is non-malleable in the sense of Definition 3.3.
Another subtlety is that the receiver may choose its polynomial ğ‘ƒ
to have â€œcollisionsâ€ in the sense that ğ‘ƒ(ğ»1(ğ‘¦)) = ğ‘ƒ(ğ»1(ğ‘¦â€²)). This is
not a problem or an attack per se, but it means that the hybrids in the
proof must be structured carefully. The goal of the proof is to justify
that the senderâ€™s messages of the form ğ»2(ğ‘¥ğ‘–, KA.key(Î (ğ‘ƒ(ğ»1(ğ‘¥ğ‘–))))
can be replaced with random values, for all ğ‘¥ğ‘– not in the intersection.
But the sequence of hybrids does not replace these real values with
random one at a time. Instead, we replace Î (ğ‘ƒ(ğ»1(Â·))) outputs, one
at a time, with KA messages chosen by the simulator. Then we can
argue that KA.key(Î (ğ‘ƒ(ğ»1(ğ‘¥ğ‘–)))) is indistinguishable from random
for possibly many values of ğ‘¥ğ‘– that give the same ğ‘ƒ(ğ»1(ğ‘¥ğ‘–)).
Proof. We first formally describe the behavior of the simulator:
â€¢ The simulator honestly plays the role of random oracle ğ»1 and
ideal permutation Î Â±. For every query ğ»1(ğ‘¦) made by the adver-
sary, record ğ‘¦ in a set O1. For every query Î âˆ’1(ğ‘š) = ğ‘“ , where
there was no previous query of the form Î (ğ‘“ ) = ğ‘š, record ğ‘“
in a set OÎ .
â€¢ The simulator runs steps 1â€“2 honestly.
â€¢ Upon receiving ğ‘ƒ in step 4, the simulator defines the set
Ëœğ‘Œ = {ğ‘¦ | ğ‘¦ âˆˆ O1 and ğ‘ƒ(ğ»1(ğ‘¦)) âˆˆ OÎ }
and sends Ëœğ‘Œ to the ideal PSI functionality.
â€¢ Upon receiving output ğ‘ = ğ‘‹ âˆ© Ëœğ‘Œ from the functionality, the
simulator computes ğ‘˜ğ‘§ = KA.key1(ğ‘, Î (ğ‘ƒ(ğ»1(ğ‘§))) for each ğ‘§ âˆˆ ğ‘.
Define ğ¾ = {ğ»2(ğ‘§, ğ‘˜ğ‘§) | ğ‘§ âˆˆ ğ‘} and then keep adding uniformly
random values to ğ¾ until |ğ¾| = |ğ‘‹|. The simulator finally sends
this ğ¾ to the adversary.
We prove that this simulation is indistinguishable from the real
interation via the following sequence of hybrids.
Hybrid 0: The real interaction, with the sender running honestly
on input ğ‘‹. In particular, the protocol message ğ¾ is generated as
follows:
(cid:16)ğ‘¥, KA.key1(cid:0)ğ‘, Î (ğ‘ƒ(ğ»1(ğ‘¥))(cid:1)(cid:17) | ğ‘¥ âˆˆ ğ‘‹(cid:111)
(cid:110)ğ»2
ğ¾ =
The lists O1 and OÎ  are also maintained, as defined above.
Hybrid 1: Same as the previous hybrid, except the interaction
aborts in step 5 if there is an ğ‘¥ âˆˆ ğ‘‹ where ğ‘¥ âˆ‰ O1 and yet
ğ‘ƒ(ğ»1(ğ‘¥)) âˆˆ OÎ . In other words, the adversary nevery queried
ğ»1(ğ‘¥) and yet ğ‘ƒ(ğ»1(ğ‘¥)) is a value that it previously received as
output from Î âˆ’1.
It suffices to show that the probability of such an abort is negligi-
ble. For any ğ‘“ âˆˆ OÎ , the polynomial equation ğ‘ƒ(Â·) = ğ‘“ has at most
ğ‘› solutions, since ğ‘ƒ is a polynomial of degree ğ‘›, and not the zero
polynomial (that would mean ğ‘ƒ is a constant polynomial and the
sender would have already aborted in step 4). Since ğ»1(ğ‘¥) is a fresh
query never made before (until the simulated sender makes it), it is
uniformly distributed in F and therefore has at most ğ‘›/|F| proba-
bility of satisfying ğ‘ƒ(ğ»1(ğ‘¥)) = ğ‘“ . Suppose the adversary makes a
total of ğ‘ queries to its oracles. By a union bound over all ğ‘› choices
of ğ‘¥ âˆˆ ğ‘‹ and ğ‘ choices of ğ‘“ âˆˆ OÎ , the total probability of this event
is ğ‘›2ğ‘/|F|, which is negligible.
Hybrid (2, ğ‘–), for ğ‘– âˆˆ [ğ‘]: Same as the previous hybrid, except for
the following changes. For the first ğ‘– queries of the form Î (ğ‘“ ) = ğ‘š,
where there was no previous query to Î âˆ’1(ğ‘š), add ğ‘“ to the set Sğ‘–.
Note that Sğ‘– and OÎ  are necessarily disjoint (based on whether Î 
or Î âˆ’1 was queried first). Intuitively, Sğ‘– are the first ğ‘– Î -outputs
(interpreted in the protocol as KA protocol messages) that the
adversary has no control over. Then compute ğ¾ instead as:
(cid:16)ğ‘¥, KA.key1(cid:0)ğ‘, Î (ğ‘ƒ(ğ»1(ğ‘¥))(cid:1)(cid:17) | ğ‘¥ âˆˆ ğ‘‹ and ğ‘ƒ(ğ»1(ğ‘¥)) âˆ‰ Sğ‘–
ğ¾ =
and thereafter add uniformly random elements to ğ¾ until |ğ¾| = ğ‘›.
Note that there may be many values of ğ‘¥ giving the same ğ‘ƒ(ğ»1(ğ‘¥))
(cid:110)ğ»2
(cid:111)
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1173Compact and Malicious Private Set Intersection for Small Sets
CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
output, so there may be many values of ğ‘¥ treated differently between
Hybrids (2, ğ‘–) and (2, ğ‘– + 1).
It should be clear that Hybrid (2, 0) is identical to Hybrid 2, since
S0 = âˆ… and the new condition is always true. In Lemma 4.3 we
prove that Hybrids (2, ğ‘–) and (2, ğ‘– + 1) are indistinguishable.
Hybrid 3: We rewrite Hybrid (2, ğ‘) for clarity. In this hybrid,
every Î (ğ‘“ ) = ğ‘š that is known in the interaction is represented in
either Sğ‘ (for those known by an initial Î -query) or OÎ  (for those
known by an initial Î âˆ’1 query). In other words, these two sets form
a partition of all known Î (ğ‘“ ) = ğ‘š points.
Let us consider how the set ğ¾ is computed in this hybrid. The
condition ğ‘ƒ(ğ»1(ğ‘¥)) âˆ‰ Sğ‘ is equivalent to ğ‘ƒ(ğ»1(ğ‘¥)) âˆˆ OÎ , meaning
that we can write:
(cid:16)ğ‘¥, KA.key1(cid:0)ğ‘, Î (ğ‘ƒ(ğ»1(ğ‘¥))(cid:1)(cid:17) | ğ‘¥ âˆˆ ğ‘‹ and ğ‘ƒ(ğ»1(ğ‘¥)) âˆˆ OÎ 
ğ¾ =
(padded with random values).
Recall that the interaction aborts if there is any ğ‘¥ âˆ‰ O1 but
ğ‘ƒ(ğ»1(ğ‘¥)) âˆˆ OÎ . In other words, conditioned on even reaching this
point in the interaction, ğ‘ƒ(ğ»1(ğ‘¥)) âˆˆ OÎ  implies ğ‘¥ âˆˆ O1. Hence we
can further rewrite the definition of ğ¾ as:
(cid:110)ğ»2
(cid:16)ğ‘¥, KA.key1(cid:0)ğ‘, Î (ğ‘ƒ(ğ»1(ğ‘¥))(cid:1)(cid:17) |
(cid:16)ğ‘¥, KA.key1(cid:0)ğ‘, Î (ğ‘ƒ(ğ»1(ğ‘¥))(cid:1)(cid:17) | ğ‘¥ âˆˆ ğ‘‹ âˆ© Ëœğ‘Œ (cid:111)
(cid:110)ğ»2
ğ‘¥ âˆˆ ğ‘‹ âˆ© O1
and ğ‘ƒ(ğ»1(ğ‘¥)) âˆˆ OÎ 
Now, suppose we define Ëœğ‘Œ = {ğ‘¦ | ğ‘¦ âˆˆ O1 and ğ‘ƒ(ğ»1(ğ‘¦)) âˆˆ OÎ }.
Then ğ¾ can be rewritten in the equivalent form:
(cid:111)
(cid:110)ğ»2
ğ¾ =
ğ¾ =
In this form, it is now clear that the hybrid corresponds to the
behavior of the ideal interaction. That is, the simulator computes
Ëœğ‘Œ, and then computes ğ¾ based only on the contents of ğ‘ = ğ‘‹ âˆ© Ëœğ‘Œ,
its output from the functionality.
â–¡
Lemma 4.3. Hybrids (2, ğ‘– âˆ’ 1) and (2, ğ‘–) are indistinguishable, if
the KA protocol is non-malleable (Definition 3.3) and |KA.K| â‰¥ 2ğœ….
Proof. The hybrids differ only in the following way: Hybrid
(2, ğ‘–) replaces KA.key1(ğ‘, Î (ğ‘“ âˆ—)) with random, in the event that ğ‘“ âˆ—
was the ğ‘–th query to Î  (with no corresponding prior Î âˆ’1 query).
Recall that in the game that defines non-malleability of a KA,
the distinguisher receives (ğ‘š1 = KA.msg1(ğ‘), ğ‘š2, ğ‘˜) and also gets
access to an oracle for K(Â·) = KA.key1(ğ‘, Â·), which it cannot query
on ğ‘š2. Below is a reduction algorithm that is a distinguisher for
the non-malleability game:
RK(ğ‘š1, ğ‘š2, ğ‘˜):
â€¢ Run Hybrid (2, ğ‘– âˆ’ 1) against the adversary, using ğ‘š1 as the PSI
protocol message ğ‘š.
â€¢ Maintain set Sğ‘–âˆ’1 as described. On the ğ‘–th query to Î  (i.e., the
value that would have been added to Sğ‘–), let ğ‘“ âˆ— denote the input
and simulate ğ‘š2 = Î (ğ‘“ âˆ—) as the response.
â€¢ For every expression of the form KA.key1(ğ‘, Î (ğ‘ƒ(ğ»1(ğ‘¥)))) used
in the definition of ğ¾:
â€“ If ğ‘ƒ(ğ»1(ğ‘¥)) = ğ‘“ âˆ— then replace the entire expression with ğ‘˜
(input to this reduction algorithm).
â€“ Otherwise, replace the entire expression with the result of
K(Î (ğ‘ƒ(ğ»1(ğ‘¥)))), where K is the reduction algorithmâ€™s oracle.
Since Î  is a permutation, we have Î (ğ‘ƒ(ğ»1(ğ‘¥))) â‰  Î (ğ‘“ âˆ—) =
ğ‘š2; in other words, the oracle K is never invoked on ğ‘š2.
Intuitively, this reduction algorithm runs the hybrid interaction
without knowing the KA randomness ğ‘. Instead, ğ‘ is used implicitly
via ğ‘š1, ğ‘˜, and the oracle K.
When the input ğ‘˜ is the correct key ğ‘˜ = KA.key1(ğ‘, ğ‘š2), then the
simulation exactly matches Hybrid (2, ğ‘– âˆ’ 1), since the reduction
correctly uses ğ‘˜ in place of the expression KA.key1(ğ‘, Î (ğ‘“ âˆ—)) =
KA.key1(ğ‘, ğ‘š2).
Now consider the case that ğ‘˜ is a random key. Then when-
ever ğ‘ƒ(ğ»1(ğ‘¥)) = ğ‘“ âˆ—, the value ğ»2(ğ‘¥, ğ‘˜) is added to ğ¾. Since ğ»2
is a random oracle, and since ğ‘˜ is uniform (and |ğ‘˜| â‰¥ ğœ…), outputs
ğ»2(ğ‘¥, ğ‘˜) are indistinguishable from random, even for multiple val-
ues of ğ‘¥ (e.g., in the case where the adversary constructs ğ‘ƒ so that
ğ‘ƒ(ğ»1(ğ‘¥)) = ğ‘“ âˆ— for several values of ğ‘¥). In summary, when ğ‘˜ is
uniform, the simulation is indistinguishable from Hybrid (2, ğ‘–) in
which a random value is added to the set ğ¾ in these cases. The
non-malleabiity of KA means that these two cases are indistin-
guishable.
â–¡
(cid:111)
Optimizations. When KA is a one-round key agreement proto-
col (i.e., message 2 doesnâ€™t depend on message 1, as in the Diffie-
Hellman instantiation), then the two messages ğ‘š and ğ¾ from the
sender can be combined. This leads to a 2-round PSI protocol
where the first flow is ğ‘ƒ from the receiver and the second flow is
ğ‘š, ğ¾ from the sender.
Note that the direction of the last message (ğ»2 outputs from
sender to receiver) is important. It is not possible to save a round
of communication by letting the receiver send ğ»2 outputs to the
sender. These ğ»2 outputs are computed using the result of a KA
between a common ğ‘ (chosen by the sender) and various ğ‘ğ‘– (chosen
by the receiver). Knowing ğ‘, the sender can compute the â€œcorrectâ€
ğ»2 for any ğ‘¥, so the receiver would expose a dictionary attack by
sending their set of ğ»2 outputs.
If security is required against only semi-honest adversaries,
then the protocol can be streamlined slightly, as follows (full details
are given in Appendix A):
â€¢ The polynomial can be interpolated on values ğ‘ƒ(ğ‘¦ğ‘–) instead of
â€¢ Instead of sending values of the form ğ»2(ğ‘¥ğ‘–, ğ‘˜ğ‘–), the sender can
simply send the ğ‘˜ğ‘– values. Again, ğ»2 was used only to extract.
Furthermore, the ğ‘˜ğ‘– values can have length of only ğœ† + 2 log(ğ‘›)
in order to ensure correctness with probability 1 âˆ’ 2âˆ’ğœ†.
ğ‘ƒ(ğ»1(ğ‘¦ğ‘–)); ğ»1 was used only to help extract.
Two other possible optimizations are presented in Appendix B.
Costs. The sender must compute one KA message and ğ‘› KA
keys/outputs. The receiver computes ğ‘› KA responses and ğ‘› KA
keys/outputs. Both parties make ğ‘› queries to each of ğ»1, ğ»2, and
Î Â±. Finally, the receiver must interpolate a polynomial of degree ğ‘›,
and the sender must evaluate such a polynomial on ğ‘› points. These
are both possible with ğ‘‚(ğ‘› log2 ğ‘›) field operations, as described in
Section 2.3.
The total communication cost of the protocol consists of: (1) 1
KA message from the sender, (2) ğ‘› field elements (each equivalent in
size to a KA response) from the receiver to describe ğ‘ƒ, (3) ğ‘› outputs
of ğ»2, each 2ğœ… bits.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1174CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Mike Rosulek and Ni Trieu
4.1 Size of Adversaryâ€™s Set
Recall that we consider an ideal functionality in which a corrupt
party can provide an input set that is â€œlarger than advertised.â€ If
a corrupt party (specifically, the receiver) provides an input that
is as large as the universe of possible items, then PSI provides no
security whatsoever. Hence, it is important to bound the size of the
set that the simulator extracts.
Corrupt Sender. The sender gives a set ğ¾ during the protocol,
which is supposed to contain ğ»2-outputs. The simulator extracts
by finding ğ‘¥ such that ğ»2(ğ‘¥, ğ‘˜) âˆˆ ğ¾, for an appropriate value ğ‘˜.
Since the output of ğ»2 is 2ğœ… bits, the probability of the adversary
encountering a collision in ğ»2 is negligible. Hence for each item in
ğ¾, there is at most one preimage known to the adversary/simulator
and hence at most one item that will be included in the extracted
set Ëœğ‘‹.
In other words, the simulator extracts an input set for a corrupt
sender of size at most |ğ¾| = ğ‘›. The protocol strictly enforces the
size of a corrupt senderâ€™s input set.
Corrupt Receiver. The simulator for a corrupt receiver extracts
their input set as
Ëœğ‘Œ = {ğ‘¦ | ğ‘¦ âˆˆ O1 and ğ‘ƒ(ğ»1(ğ‘¦)) âˆˆ OÎ }
Abstractly speaking, the adversary sees ğ‘ outputs of ğ»1, and it
sees ğ‘ outputs of Î . In the simulation, outputs of both ğ»1 and
Î  are uniform. The adversary then generates a polynomial ğ‘ƒ of
degree less than ğ‘› (and greater than 0) and the simulator checks
whether ğ‘ƒ(ğ›¼) = ğ›½ for all outputs ğ›¼ from ğ»1 and all outputs ğ›½ from
Î . The number of such pairs is the size of the set that is extracted.
The question is therefore how many random points can the
adversary fit on a degree < ğ‘› polynomial?
CDJ shows that if the size of the field is 2ğ‘›ğœ”(log ğœ…) then with over-
whelming probability no polynomial can fit more points than its
degree suggests. However, such a large field leads to quadratic total
communication (ğ‘› coefficients in a field of more than 2ğ‘› elements).
We instead prefer to stick to a field of minimum size (large enough
only to encode a KA message) and obtain bounds on the number of
items.
Definition 4.4. Let F be a field and define the PolyOverfitğ‘›,ğ‘›â€²
game against an adversary A to be as follows:
F
(ğ‘)
sample ğ›¼1, . . . , ğ›¼ğ‘, ğ›½1, . . . , ğ›½ğ‘ â† F
ğ‘ƒ â† A(ğ›¼1, . . . , ğ›¼ğ‘, ğ›½1, . . . , ğ›½ğ‘)
if 0 < deg(ğ‘ƒ) < ğ‘› and(cid:12)(cid:12)(cid:12){ğ›¼ğ‘– | ğ‘ƒ(ğ›¼ğ‘–) âˆˆ {ğ›½1, . . . , ğ›½ğ‘}}(cid:12)(cid:12)(cid:12) â‰¥ ğ‘›â€²:
declare A the winner
In other words, the adversary tries to generate a polynomial that
hits some ğ›½ ğ‘— on at least ğ‘›â€² distinct ğ›¼ğ‘–â€™s.
all PPT A, the adversary wins with negligible probability.
We say that PolyOverfitğ‘›,ğ‘›â€²
is hard if for all polynomial ğ‘ and
F
Proposition 4.5. If PolyOverfitğ‘›,ğ‘›â€²
is hard, then the simulator
for a corrupt receiver in our PSI protocol outputs a set of size bounded
by ğ‘›â€², except with negligible probability.
F
In Appendix C we show the following using a standard compres-
sion argument. If such an â€œoverfittingâ€ polynomial existed, it could
be used to generate a compressed representation of the ğ›¼ğ‘–â€™s and
ğ›½ğ‘–â€™s, which is impossible if they are uniform.
Lemma 4.6. The probability of winning PolyOverfitğ‘›,ğ‘›â€²
(ğ‘) is at
F
most (ğ‘2ğ‘›)ğ‘›â€²/|F|ğ‘›â€²âˆ’ğ‘›.
Some concrete examples of this bound for |F| = 2256 are given
below:
ğ‘
2107
2115
2102
2110
ğ‘›
210
210
220
220
ğ‘›â€²
8ğ‘› + 4
16ğ‘› + 8
8ğ‘› + 4
16ğ‘› + 8
bound
2âˆ’128
2âˆ’128
2âˆ’128
2âˆ’128
For example, when running the protocol for ğ‘› = 210 items, the
adversary will not be able to have an effective input of size 8ğ‘› + 4,
with high probability.
We emphasize that the above bound is unconditional, meaning
that for the parameters above, such an â€œoverfittingâ€ polynomial
simply does not exist except with negligible probability. It seems
reasonable to conjecture that even when such polynomials exist,
finding them is hard for PPT adversaries. If such a claim were
proven, it would imply a tighter enforcement of set sizes in our
protocol.
We also emphasize that all malicious PSI protocols based on OT
extension have similar â€œslackâ€ in the size of corrupt partiesâ€™ sets.