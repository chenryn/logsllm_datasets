263m35.46s
1569m11.06s
2409m16.89s
corresponding qhasm code fe25519r64 */fe25519 *. We are
able to reproduce a known bug in an old version of F
2255−19
multiplication (fe25519r64 mul-1). A counterexample can
be found in seconds with a pair of precondition and postcon-
dition for the reduction phase. Veriﬁcation time of squaring
is less than that of multiplication because (1) squaring is
simpler than multiplication which requires more low-level
multiplication operations, and (2) multiplication is veriﬁed
without the fourth heuristic to be introduced later in this
section, but squaring is veriﬁed with the heuristic.
The rows mul25519-p2-1 and mul25519-p2-2 are the re-
sults of verifying the delayed carry phase of mul25519, a
3-phase implementation of multiplication. The result shows
that if we add an additional midcondition to the delayed
carry phase of mul25519, the veriﬁcation time of the de-
layed carry phase can be reduced from 2723 minutes to
263 minutes. In general, inserting more midconditions al-
lows lower veriﬁcation time, with a cost of more manual
eﬀorts. Besides mul25519 and qhasm code in the ladder
step, we also successfully veriﬁed (1) a 3-phase implementa-
tion of multiplication with addition (muladd25519), and (2)
implementations of multiplication over diﬀerent ﬁnite ﬁelds
(fe19119 mul, mul1271, and re15319).
Note that all postconditions for the radix-264 are equali-
ties. Since Boolector can not verify modular congruence
relations in the radix-264 representation, we have to estab-
lish them in Coq. On the other hand, Boolector success-
fully veriﬁes the modular congruence relation Q51delay carry
for the radix-251 representation. Our Coq proof for the
radix-251 representation is thus simpliﬁed. The reason why
some congruence relations is veriﬁed in the radix-251 rep-
resentation is because we are able to divide P 51D further
into smaller fragments. A few extra carry bits can not only
reduce the time for execution but also veriﬁcation.
We found the following heuristics are quite useful to ac-
celerate veriﬁcation. We cannot verify many of the cases
without them. First, we split conjunctions of postcondi-
tions, i.e., translate (|Q0|) P (|Q1 ∧ Q2|) to (|Q0|) P (|Q1|) and
(|Q0|) P (|Q2|). This reduces the veriﬁcation time of the mul-
tiply phase of mul25519 from one day to one minute. Sec-
ond, we delay bit-width extension. For example, consider
a formula a 256= b ∗ c where a has 256 bits and b, c have 64
bits.
Instead of extending b and c to 256 bits before the
multiplication, we ﬁrst extend b and c to 128 bits, compute
the multiplication, and then extend the result to 256 bits.
Third, the sequence of mathematical operations in anno-
tations should match as much as possible the sequence of
operations executed in a program. For example, if a pro-
gram calculates the value of a variable r by adding 19x0y2
ﬁrst, then 19x1y1, and ﬁnally 19x2y0, the annotation is bet-
ter written as r = (19x0y2 + 19x1y1) + 19x2y0 instead of
r = 19(x0y2+x1y1+x2y0) or r = 19x0y2+(19x1y1+19x2y0).
If we really need to prove r = 19(x0y2 + x1y1 + x2y0), it
can be done in Coq very easily with rewrite tactics given
the fact that r = (19x0y2 + 19x1y1) + 19x2y0. Fourth, we
over-approximate Boolector speciﬁcations by automati-
cally reducing logical variables and weakening preconditions
such that the speciﬁcations become easier to be proven.
The validity of an over-approximated speciﬁcation guaran-
tees the validity of the original one, but not vice versa.
This heuristic can be viewed as program slicing with over-
approximation. To be more speciﬁc, given a speciﬁcation
(cid:12)(cid:12)(cid:1) P (|Q1|), our translator automatically
(cid:0)(cid:12)(cid:12)Q1
(cid:0)(cid:12)(cid:12)r = r1 ∧ r1 = r0 + x ∧ x ≤ 251(cid:12)(cid:12)(cid:1) r+=y (|r = r1 + y|), this heu-
removes logical variables that do not appear in Q1; it re-
moves Qi
0 neither appears in Q1
nor gets updated in P . For example, given a Hoare triple
ristic produces (|r = r1|) r+=y (|r = r1 + y|) where (1) r1 =
r0 + x is removed because the logical variable r0 does not
appear in the postcondition, and (2) x ≤ 251 is removed
0 if some variable in Qi
0 ∧ Q2
0 ∧ ··· ∧ Qn
0
307because x neither gets updated nor appears in the postcon-
dition. Traditional program slicing may not remove r0 and
x because both variables are related to r1, which appears
in the postcondition. We cannot verify fe25519r64 sq and
fe25519 sq without this heuristic.
7. FUTURE WORK
There are several avenues for future work. One interesting
topic could be to develop veriﬁcation approaches for ensur-
ing that the an assembly implementation is resistant against
side-channel attacks. Formal techniques in measuring worst-
case execution time (WCET) might be a starting point for
this line of research.
Currently, we need to manually provide midconditions
for veriﬁcations. Although the veriﬁcation steps between
preconditions and postconditions are done automatically, it
would be even better if we can increase the degree of au-
tomation further by investigating techniques for automatic
insertion of midconditions. We think the tools for automatic
assertion insertion could be relevant [25]. The tool obtains
assertions based on given templates of assertions and by syn-
thesizing them dynamically from observed executions traces.
Our translator currently can produce Boolector speci-
ﬁcations from annotated qhasm ﬁles. Recall that some prop-
erties that cannot be proved in Boolector are proved in
Coq. It would be good if the translator can produce both
Boolector speciﬁcations and Coq proof obligations from
an annotated qhasm ﬁle, which makes the qhasm ﬁle more
self-contained. Moreover, tactics of Coq may be developed
to solve some speciﬁc problems, for example, modular con-
gruence, to reduce human work.
8. REFERENCES
[1] R. Aﬀeldt. On construction of a library of formally
veriﬁed low-level arithmetic functions. Innovations in
Systems and Software Engineering, 9(2):59–77, 2013.
https://staff.aist.go.jp/reynald.affeldt/
documents/arilib-affeldt.pdf.
[2] R. Aﬀeldt and N. Marti. An approach to formal
veriﬁcation of arithmetic functions in assembly. In
M. Okada and I. Satoh, editors, Advances in
Computer Science – ASIAN 2006, volume 4435 of
Lecture Notes in Computer Science, pages 346–360.
Springer-Verlag Berlin Heidelberg, 2007.
https://staff.aist.go.jp/reynald.affeldt/
documents/affeldt-asian2006.pdf.
[3] R. Aﬀeldt, D. Nowak, and K. Yamada. Certifying
assembly with formal security proofs: The case of
BBS. Science of Computer Programming,
77(10–11):1058–1074, 2012.
http://www.sciencedirect.com/science/article/
pii/S0167642311001493.
[4] J. B. Almeida, M. Barbosa, G. Barthe, and
F. Dupressoir. Certiﬁed computer-aided cryptography:
eﬃcient provably secure machine code from high-level
implementations. In V. Gligor and M. Yung, editors,
Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security, pages
1217–1230. ACM New York, 2013.
http://eprint.iacr.org/2013/316/.
[5] B. Alpern, M. N. Wegman, and F. K. Zadeck.
Detecting equality of variables in programs. In ACM
Symposium on Principles of Programming Languages
– (POPL 1988), pages 1–11. ACM Press, 1988.
http://courses.cs.washington.edu/courses/
cse501/04wi/papers/alpern-popl88.pdf.
[6] R. Avanzi, H. Cohen, C. Doche, G. Frey, T. Lange,
K. Nguyen, and F. Vercauteren. Handbook of Elliptic
and Hyperelliptic Curve Cryptography. Chapman &
Hall/CRC, 2006.
[7] E.-I. Bartzia. Formalisation des courbes elliptiques en
coq. Master’s thesis, Universit´e de Vincennes-Saint
Denis – Paris VIII, 2011.
http://pierre-yves.strub.nu/research/ec/.
[8] A. G. Bayrak, F. Regazzoni, D. Novo, and P. Ienne.
Sleuth: Automated veriﬁcation of software power
analysis countermeasures. In G. Bertoni and J.-S.
Coron, editors, Cryptographic Hardware and Embedded
Systems – CHES 2013, volume 8086 of Lecture Notes
in Computer Science, pages 293–310. Springer-Verlag
Berlin Heidelberg, 2013.
[9] D. J. Bernstein. qhasm: tools to help write high-speed
software. http://cr.yp.to/qhasm.html.
[10] D. J. Bernstein. Supercop: System for uniﬁed
performance evaluation related to cryptographic
operations and primitives.
http://bench.cr.yp.to/supercop.html. Published
as part of ECRYPT II VAMPIRE Lab.
[11] D. J. Bernstein. Curve25519: new Diﬃe-Hellman
speed records. In M. Yung, Y. Dodis, A. Kiayias, and
T. Malkin, editors, Public Key Cryptography – PKC
2006, volume 3958 of Lecture Notes in Computer
Science, pages 207–228. Springer-Verlag Berlin
Heidelberg, 2006.
http://cr.yp.to/papers.html#curve25519.
[12] D. J. Bernstein. Batch binary Edwards. In S. Halevi,
editor, Advances in Cryptology – CRYPTO 2009,
volume 5677 of Lecture Notes in Computer Science,
pages 317–336. Springer-Verlag Berlin Heidelberg,
2009. http://cr.yp.to/papers.html#bbe.
[13] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and
B.-Y. Yang. High-speed high-security signatures. In
B. Preneel and T. Takagi, editors, Cryptographic
Hardware and Embedded Systems – CHES 2011,
volume 6917 of Lecture Notes in Computer Science,
pages 124–142. Springer-Verlag Berlin Heidelberg,
2011. see also full version [14].
[14] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and
B.-Y. Yang. High-speed high-security signatures.
Journal of Cryptographic Engineering, 2(2):77–89,
2012. http://cryptojedi.org/papers/#ed25519, see
also short version [13].
[15] D. J. Bernstein and T. L. (editors). eBACS: ECRYPT
Benchmarking of Cryptographic Systems.
http://bench.cr.yp.to (accessed May 17, 2014).
[16] D. J. Bernstein and T. L. (editors). Explicit-formulas
database. http://www.hyperelliptic.org/EFD/
(accessed May 17, 2014).
[17] D. J. Bernstein, W. Janssen, T. Lange, and
P. Schwabe. TweetNaCl: A crypto library in 100
tweets, 2013.
http://cryptojedi.org/papers/#tweetnacl.
[18] D. J. Bernstein, T. Lange, and P. Schwabe. The
security impact of a new cryptographic library. In
308A. Hevia and G. Neven, editors, Progress in
Cryptology – LATINCRYPT 2012, volume 7533 of
Lecture Notes in Computer Science, pages 159–176.
Springer-Verlag Berlin Heidelberg, 2012.
http://cryptojedi.org/papers/#coolnacl.
[19] Y. Bertot and P. Cast´eran. Interactive Theorem
Proving and Program Development Coq’Art: The
Calculus of Inductive Constructions. EATCS.
Springer, 2004.
[20] K. Bhargavan, A. Delignat-Lavaud, C. Fournet,
M. Kohlweiss, A. Pironti, P.-Y. Strub, and
S. Zanella-B´eguelin. miTLS: A veriﬁed reference TLS
implementation, 2014.
http://www.mitls.org/wsgi/home.
[21] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti,
and P.-Y. Strub. Implementing TLS with veriﬁed
cryptographic security. In IEEE Symposium on
Security and Privacy 2013, pages 445–459, 2013. full
version: http:
//www.mitls.org/downloads/miTLS-report.pdf.
[22] B. B. Brumley, M. Barbosa, D. Page, and
F. Vercauteren. Practical realisation and elimination
of an ECC-related software bug attack. In
O. Dunkelman, editor, Topics in Cryptology –
CT-RSA 2012, volume 7178 of Lecture Notes in
Computer Science, pages 171–186. Springer-Verlag
Berlin Heidelberg, 2012.
http://eprint.iacr.org/2011/633.
[23] R. Brummayer and A. Biere. Boolector: An eﬃcient
SMT solver for bit-vectors and arrays. In
S. Kowalewski and A. Philippou, editors, Tools and
Algorithms for the Construction and Analysis of
Systems – (TACAS 2009), volume 5505 of Lecture
Notes in Computer Science, pages 174–177.
Springer-Verlag Berlin Heidelberg, 2009. http:
//fmv.jku.at/papers/BrummayerBiere-TACAS09.pdf.
[24] C. Costello, H. Hisil, and B. Smith. Faster compact
diﬃe–hellman: Endomorphisms on the x-line. In P. Q.
Nguyen and E. Oswald, editors, Advances in
Cryptology – EUROCRYPT 2014, volume 8441 of
Lecture Notes in Computer Science, pages 183–200.
Springer-Verlag Berlin Heidelberg, 2014.
http://eprint.iacr.org/2013/692/.
[25] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant,
C. Pacheco, M. S. Tschantz, and C. Xiao. The daikon
system for dynamic detection of likely invariants. Sci.
Comput. Program., 69(1–3):35–45, 2007.
http://pgbovine.net/publications/
daikon-invariant-detector_SCP-2007.pdf.
[29] P. Longa and F. Sica. Four-dimensional
Gallant-Lambert-Vanstone scalar multiplication. In
X. Wang and K. Sako, editors, Advances in Cryptology
– ASIACRYPT 2012, volume 7658 of Lecture Notes in
Computer Science, pages 718–739. Springer-Verlag
Berlin Heidelberg, 2012.
https://eprint.iacr.org/2011/608.
[30] D. Molnar, M. Piotrowski, D. Schultz, and D. Wagner.
The program counter security model: Automatic
detection and removal of control-ﬂow side channel
attacks. In D. H. Won and S. Kim, editors,
Information Security and Cryptology – ICISC 2005,
volume 3935 of Lecture Notes in Computer Science,
pages 156–168. Springer-Verlag Berlin Heidelberg,
2005. Full version at
http://eprint.iacr.org/2005/368/.
[31] P. L. Montgomery. Speeding the Pollard and elliptic
curve methods of factorization. Mathematics of
Computation, 48(177):243–264, 1987.
http://www.ams.org/journals/mcom/1987-48-177/
S0025-5718-1987-0866113-7/
S0025-5718-1987-0866113-7.pdf.
[32] M. O. Myreen and M. J. C. Gordon. Hoare logic for
realistically modelled machine code. In O. Grumberg
and M. Huth, editors, Tools and Algorithms for the
Construction and Analysis of Systems, volume 4424 of
Lecture Notes in Computer Science, pages 568–582.
Springer-Verlag Berlin Heidelberg, 2007. http:
//www.cl.cam.ac.uk/~mom22/mc-hoare-logic.pdf.
[33] T. Oliveira, J. L´opez, D. F. Aranha, and
F. Rodr´ıguez-Henr´ıquez. Lambda coordinates for
binary elliptic curves. In G. Bertoni and J.-S. Coron,
editors, Cryptographic Hardware and Embedded
Systems – CHES 2013, volume 8086 of Lecture Notes
in Computer Science, pages 311–330. Springer-Verlag
Berlin Heidelberg, 2013. http:
//eprint.iacr.org/2013/131/20130611:205154.
[34] S. Ragan. Bugcrowd launches funding drive to audit
popenssl. News article on CSO, 2014.
http://www.csoonline.com/article/2145020/
security-industry/
bugcrowd-launches-funding-drive-to-audit-openssl.
html (accessed May 17, 2014).
[35] B. K. Rosen, M. N. Wegman, and F. K. Zadeck.
Global value numbers and redundant computations. In
ACM Symposium on Principles of Programming
Languages – (POPL 1988), pages 12–27. ACM Press,
1988. http://www.cs.wustl.edu/~cytron/cs531/
Resources/Papers/valnum.pdf.
[26] M. Gordon. CryptVer project. http:
[36] L. Th´ery and G. Hanrot. Primality proving with
//www.cl.cam.ac.uk/~mjcg/proposals/CryptVer/.
[27] D. Hankerson, A. Menezes, and S. A. Vanstone. Guide
to Elliptic Curve Cryptography. Springer-Verlag New
York, 2004.
[28] C. A. R. Hoare. An axiomatic basis for computer
programming. Communications of the ACM,
12(10):576–580, 1969. http://www.spatial.maine.
edu/~worboys/processes/hoare/20axiomatic.pdf.
elliptic curves. In K. Schneider and J. Brandt, editors,
Theorem Proving in Higher Order Logics, volume 4732
of Lecture Notes in Computer Science, pages 319–333.
Springer-Verlag Berlin Heidelberg, 2007. http:
//hal.inria.fr/docs/00/14/06/58/PDF/paper.pdf.
[37] K. White and M. Green. IsTrueCryptAuditedYet?
http://istruecryptauditedyet.com/
(accessed May 17, 2014).
309