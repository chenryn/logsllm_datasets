---
## Page 421
#!/bin/bash
# trouble: script to demonstrate connon errors
nunber=1
u[I =xoqunus ] T
echo "Munber is equal to 1."
else
echo "Munber is not equal to 1.*
fi
结果是这样的：
[neglinuxbox -]$ trouble
/home/me/bin/trouble: 1ine 9: syntax error near unexpected toker
else'
/home/me/bin/trouble: 1ine 9: *else
再次，错误信息指向一个错误，其出现的位置在实际问题所在的文本行的后面。所发生的事
情真是相当有意思。我们记得，if能够接受一系列命令，并且会计算列表中最后一个命令的退
出代码。在我们的程序中，我们打算这个列表由单个命令组成，即[，测试的同义词。这个[命
令把它后面的东西看作是一个参数列表。在我们这种情况下，有三个参数：Snumber，=，和。
由于删除了分号，单词then被添加到参数列表中，从语法上讲，这是合法的。随后的echo命
令也是合法的。它被解释为命令列表中的另一个命令，f将会计算命令的退出代码。接下来遇
到单词else，但是它出局了，因为shell把它认定为一个保留字（对于shell有特殊含义的单词），
而不是一个命令名，因此报告错误信息。
31.1.3预料不到的展开
可能有这样的错误，它们仅会间歇性地出现在一个脚本中。有时候这个脚本执行正常，其它时
间会失败，这是因为展开结果造成的。如果我们归还我们丢掉的分号，并把number的数值更
改为一个空变量，我们可以示范一下：
#!/bin/bash
# trouble: script to demonstrate connon errors
420
---
## Page 422
nunber=
if [ $nunber = 1 ]; then
echo "Munber is equal to 1."
else
echo "Munber is not equal to 1.*
fi
运行这个做了修改的脚本，得到以下输出：
[nedlinuxbox -]$ trouble
/home/me/bin/trouble: line 7: [: =: unary operator expected
Munber is not equal to 1.
我们得到一个相当神秘的错误信息，其后是第二个echo命令的输出结果。这问题是由于
test命令中number变量的展开结果造成的。当此命令：
[$nunber = 1 ]
经过展开之后，mumber变为空值，结果就是这样：
[= 1 ]
这是无效的，所以就产生了错误。这个=操作符是一个二元操作符（它要求每边都有一个
数值）.但是第一个数值是缺失的，这样test命令就期望用一个一元操作符（比如-z）来代替。
进一步说，因为test命令运行失败了（由于错误），这个if命令接收到一个非零退出代码，因
此执行第二个echo命令。
通过为test命令中的第一个参数添加双引号，可以更正这个问题：
[“$number" = 1 ]
然后当展开操作发生地时候，执行结果将会是这样：
421
---
## Page 423
[ * = 1 ]
其得到了正确的参数个数。除了代表空字符串之外，引号应该被用于这样的场合，一个要展
开成多单词字符串的数值，及其包含嵌入式空格的文件名。
31.2逻辑错误
不同于语法错误，逻辑错误不会阻正脚本执行。虽然脚本会正常运行，但是它不会产生期望的
结果，归答于脚本的逻辑问题。虽然有不计其数的可能的逻辑错误，但下面是一些在脚本中找
到的最常见的逻辑错误类型：
1.不正确的条件表达式。很容易编写一个错误的if/then/else语句，并且执行错误的逻辑。
有时候逻辑会被颠倒，或者是逻辑结构不完整。
2.“超出一个值”错误。当编写带有计数器的循环语句的时候，为了计数在恰当的点结束
循坏语句可能要求从0开始计数，而不是从1开始，这有可能会薇忽视。这些类型的错
误要不导致循环计数太多，而“超出范围”，要不就是过早的结束了一次送代，从而错过
了最后一次送代循环。
3.意外情况。大多数逻辑错误来自于程序碰到了程序员没有预见到的数据或者情况。这也
可以包括出乎意料的展开，比如说一个包含嵌人式空格的文件名展开成多个命令参数而
不是单个的文件名。
31.2.1防错编程
当编程的时候，验证假设非常重要。这意味着要仔细地计算脚本所使用的程序和命令的退出状
态。这里有个基于一个真实的故事的实例。为了在一台重要的服务器中执行维护任务，一位不
幸的系统管理员写了一个脚本。这个脚本包含下面两行代码：
ueuxtps p
rB *
从本质上来说，这两行代码没有任何问题，只要是变量dir_name中存储的目录名字存在就
可以。但是如果不是这样会发生什么事情呢？在那种情况下，cd命令会运行失败，脚本会继续
422
---
## Page 424
执行下一行代码，将会删除当前工作目录中的所有文件。完成不是期望的结果！由于这种设计
策略，这个倒霉的管理员销毁了服务器中的一个重要部分。
让我们看一些能够提高这个设计的方法。首先，在cd命令执行成功之后，再运行rm命令，
可能是明智的选择。
cd $dir_nane kk rn *
这样，如果cd命令运行失败后，rm命令将不会执行。这样比较好，但是仍然有可能未设
置变量dir_name或其变量值为空，从而导致删除了用户家目录下面的所有文件。这个问题也
能够避免，通过检验变量dir_name中包含的目录名是否真正地存在：
[[ -d $dir_nase ]] &k cd $dir_nane &t rn *
通常，当某种情况（比如上述问题）发生的时候，最好是终止脚本执行，并对这种情况提示
错误信息：
if [[ -d $dir_name 1]; then
if cd $dir_nane; then
ra *
else
b2
#exit 1
fi
通过给脚本中的一个逻辑区块内的每条语句的开头添加一个注释符号，我们就阻止了这部
分代码的执行。然后可以再次执行测试，来看看清除的代码是否影响了错误的行为。
426
---
## Page 428
31.4.2追踪
在一个脚本中，错误往往是由意想不到的逻辑流导致的。也就是说，脚本中的一部分代码或者
从未执行，或是以错误的顺序，或在错误的时间给执行了。为了查看真实的程序流，我们使用
一项叫做追踪（tracing）的技术。
一种追踪方法涉及到在脚本中添加可以显示程序执行位置的提示性信息。我们可以添加提
示信息到我们的代码片段中：
if [[ -d $dir_name ]]:; then
if cd $dir_nane; then
echo *deleting files" >k2
rm *
else
b2
我们把提示信息输出到标准错误输出，让其从标准输出中分离出来。我们也没有缩进包含
提示信息的语句，这样想要删除它们的时候，能比较容易找到它们。
当这个脚本执行的时候，就可能看到文件删除操作已经完成了：
[ne@linuxbox -]$ deletion-script
preparing to delete files
deleting files
file deletion complete
[nedlinuxbox -]$
bash还提供了一种名为追踪的方法，这种方法可通过-x选项和set命令加上-x选项两种
途径实现。拿我们之前的trouble脚本为例，给该脚本的第一行语句添加-x选项，我们就能追
踪整个脚本。
427
---
## Page 429
#!/bin/bash =x
# trouble: script to demonstrate connon errors
nunber=1
if [ $nunber = 1 ]; then
echo "Munber is equal to 1."
α1se
echo "Munber is not equal to 1. *
fi
当脚本执行后，输出结果看起来像这样：
[ne@linuxbox -]$ trouble
+ nunber=1
+'[ 1 = 1 ]
+ echo 'Bunber is equal to 1.*
Munber is equal to 1.
追踪生效后，我们看到脚本命令展开后才执行。行首的加号表明追踪的迹象，使其与常规输
出结果区分开来。加号是追踪输出的默认字符。它包含在PS4（提示符4）shell变量中。可以
调整这个变量值让提示信息更有意义。这里，我们修改该变量的内容，让其包含脚本中追踪执
行到的当前行的行号。注意这里必须使用单引号是为了防止变量展开，直到提示符真正使用的
时候，就不需要了。
. +ONaNITs , =Sd4xodxos[-xoqxnut5ou]
[ne@linuxbox -]$ trouble
5 + number=1
[，I =.].+ 
8 + echo 'Munber is equal to 1.'
Hunber is equal to 1.
我们可以使用set命令加上-x选项，为脚本中的一块选择区域，而不是整个脚本启用追踪。
428
---
## Page 430