6) For every adversarial node j ∈ T , D extracts the secrets
sj as described in Figure 2. Let Q ⊂ T be the set of
k∈Q sk. Also, let
w = |T|−|Q|, i.e., the number of honest node included
in T . Then, the s can be written as:
phase. Let s =(cid:80)
malicious nodes in T . Then, let u =(cid:80)
(cid:88)
k∈T sk.
s = u + w · a +
(9)
rk
k∈T\Q
(cid:80)
7) D extracts u as in Figure 2 and uses owhuh
k∈T \Q rk
as the ﬁnal public key. For each honest node, D uses the
NIZK simulator of dleq protocol for generating required
proofs during the key derivation phase.
Claim 1. If o = gab, the distribution of transcript generated
due to A’s interaction with D is identical to the distribution
generated during a real execution of the protocol.
k∈T \Q rk
(10)
Proof: When o = gab then
owhuh
(cid:80)
Since s = aw + u +(cid:80)
(cid:80)
= haw+u+(cid:80)
k∈T \Q rk = gabwhuh
k∈T \Q rk
k∈T\Q rk and the NIZK simulator of
dleq is perfect, the distribution generated by D is identical
to the real-world execution of our ADKG protocol.
Claim 2. If o = gr for a random r ∈ Zq the distribution
of transcript generated due to A’s interaction with D is
identical to the distribution generated by S.
k∈T \Q rk
owhuh
Proof: When o = gr then
(cid:80)
(cid:80)
(cid:80)
k∈T \Q rk = grwhuh
= hr(cid:48)whuh
= hr(cid:48)w+u+(cid:80)
k∈T\Q rk ;
k∈T \Q rk
rk’s, s = r(cid:48)w+u+(cid:80)
(r(cid:48) = rb−1)
(11)
Since r(cid:48) is uniformly random and independent of w, u and
k∈T\Q rk is uniformly random. Hence,
the distribution generated by D is identical to the distribution
generate by S.
Proof of Lemma 5: From Claim 1 and 2, if A distin-
guishes these two distributions with probability 1/2+p, then
D will distinguish the DDH tuple with the same probability.
Thus, assuming the hardness of DDH, the view generated
by the S is indistinguishable from the view of the actual
protocol.
It follows from the description
of the distinguisher D and the proof of Lemma 5 that
assuming hardness of DDH, the ADKG public key hz is
indistinguishable from a uniformly random element in G.
Since h is ﬁxed and independent of z, this implies that z is
indistinguishable from a random element in Zq.
Proof of Lemma 3:
Figure 3: Description of DDH distinguisher D
a distinguisher D, given in Figure 3, to break the DDH
assumption.
The distinguisher D gets an DDH tuple (g, ga, gb, o) as
input where either o = gab or o = gr for a random r ∈
Zq. D then runs our ADKG protocol with the adversary A
where D emulates the honest nodes. At the end of the ADKG
protocol, A outputs a bit β which is A’s guess of whether
the ADKG transcript is identical to the simulated transcript
or the transcript of a real execution of the protocol. D then
outputs β as its guess of whether o = gab or o = gr.
of the interaction of A with D.
Next we prove the following claims about the transcript
C. Performance
Lemma 6. The expected total communication cost of our
ADKG protocol is O(n3).
Proof: Let CACSS be the communication cost of one
ACSS instance. Let CABA be the expected communication
cost of one ABA instance. Let CRBC(L) be the communica-
tion cost of an RBC protocol on a message of size L. Then,
CACSS = O(κn2) ([58], §VII), CABA = O(κn2) [17],
[12], and CRBC(L) = O(nL + κn2) [19]. The expected
communication cost of our ADKG protocol is n· (CACSS +
CRBC(n) + CABA + O(κn2) = O(κn3).
Remark. Note that although the expected latency for n par-
allel instances of ABA to terminate is O(log n) rounds [7],
the expected communication cost is n · CABA = O(κn3).
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
9
2526
Lemma 7. The expected computation cost per node in our
ADKG protocol is O(κn3), measured in number of elliptic
curve exponentiations.
We prove Lemma 7 in Appendix A.
Lemma 8. Our ADKG protocol
rounds in expectation.
terminates in O(log n)
Proof: The sharing, key set proposal, and key derivation
phase of our ADKG protocol require O(1) rounds [19].
Although a single ABA instance terminates in O(1) rounds
in expectation, it takes O(log n) rounds in expectation for
all n parallel instances to terminate [7]. Thus, our ADKG
protocol runs in O(log n) rounds in expectation.
Remark. Although, in theory, our ADKG protocol may
take O(log n) rounds in expectation, in the common case in
practice, our protocol terminate within much fewer rounds.
This is due to the property of Crain’s ABA [17] that when
all honest nodes input the same value to an ABA instance,
that ABA instance will
terminate within two iterations,
without using any common coin. For the same reason, in
the common case in practice, each node only incurs O(n2)
computation cost (as opposed to O(n3) in the worst-case)
because nodes need not compute the intermediate threshold
keys for generating common coins.
Combining all of the above, we get the following theorem.
Theorem 1 (ADKG). In a network of n ≥ 3t + 1 nodes
where up to t nodes could be malicious, assuming hard-
ness of Decisional Difﬁe-Hellman, Algorithm 1 implements
an ADKG protocol with expected communication cost of
O(κn3), expected computation cost of O(n3) per node and
expected O(log n) rounds (κ is the security parameter).
VI. HIGH-THRESHOLD ADKG
So far, we have discussed our ADKG protocol for a
threshold of (cid:96) = t + 1, i.e., the ﬁnal secret key is secret
shared among nodes using a (n, t + 1) threshold secret
sharing. However, many applications [12], [57], [36] require
the secrer key to be shared by a (n, n − t) threshold secret
sharing. Here on, we will refer to an ADKG protocol that
shares the secret using a threshold of (cid:96) > t + 1 as a high-
threshold ADKG. In this section, we describe how to extend
our ADKG protocol to support high-threshold.
Design. The only change we need to get a high-threshold
ADKG is to use a high-threshold ACSS scheme with the
properties speciﬁed in §III-B in the sharing phase. The rest
of the protocol can proceed exactly as in §IV.
But designing an efﬁcient high-threshold ACSS scheme
with our desired properties turns out to be challenging. The
prior best known high-threshold ACSS with these properties
is due to [43]. However, their ACSS has a communication
cost of O(κn3), which is too costly. The high-threshold
ACSS protocols of [6] and [19] have communication costs
of O(κn2 log n) and O(κn2), respectively, but do not pro-
vide the required Homomorphic-Partial-Commitment prop-
erty. We design a new high-threshold ACSS that adds the
Homomorphic-Partial-Commitment property to [19] while
retaining its O(κn2) communication complexity. We provide
more details on our high-threshold ACSS in §VII.
Analysis. Since the only change we introduce is to use a
high-threshold ACSS, the correctness of our high-threshold
ADKG follows directly from the correctness analysis in §V.
For secrecy, we need to ensure that given gs for a secret s,
the high-threshold ACSS scheme is simulatable.
VII. HIGH-THRESHOLD ACSS
This section describes a new high-threshold ACSS scheme
that adds the Homomorphic-Partial-Commitment property
to [19] while retaining its O(κn2) communication cost.
Brieﬂy, we need veriﬁable encryption of discrete loga-
rithms, i.e., a CPA-secure encryption scheme that allows
an encrypter to prove in zero-knowledge about the correct
encryption of discrete logarithms of a known value. We use
the scheme due to Fouque [26] which assumes the hardness
of Decisional Composite Residuosity (DCR) [49].
A. Veriﬁable Encryption of Discrete Logs
The problem of veriﬁable encryption of discrete loga-
rithms involves three parties: a prover P, a veriﬁer V, and
a receiver R. The receiver R has a public-private key pair
(pk, sk). Let G be an appropriate group and let g ∈ G
be a random generator of G. Given (g, x, c, pk), the prover
P wants to convince the veriﬁer V that c is an public key
encryption of α under the public key pk such that gα = x
and P knows α.
public-private key pair for the encryption scheme.
Fouque and Stern’s protocol [26] for veriﬁable encryp-
tion of discrete logarithm is a “Σ-protocol” and is zero-
knowledge and knowledge sound. The protocol has the
following interfaces.
• KeyGen(1κ) → (pk, sk). KeyGen algorithm outputs a
• Decrypt(sk, c) → α: Given a ciphertext c and a secret key
sk, Decrypt decrypts c using sk and outputs the message.
• EncAndProve(pk, g, α) → (c, x, π): EncAndProve func-
tion encrypts a uniformly random message α using the
public-key pk to get c, computes x = gα, and creates a
NIZK proof of knowledge π that the encryptor knows α
such that α = Decrypt(pk, c) and x = gα.
• VerifyDLog(pk, g, x, c, π) → 0/1. Given (pk, g, x, c, π),
the VerifyDLog(·) outputs 1 if π is a valid proof that there
exists α such that α = Decrypt(pk, c) and x = gα. Note
that the proof π needs to be veriﬁable without access to
the secret key or the underlying message α.
B. Design and Analysis
Our high-threshold ACSS is given in Algorithm 2. The
main difference between our Algorithm 2 and the high-
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
10
2527
Algorithm 2 Homomorphic high-threshold ACSS
PUBLIC PARAMETER: n, t, (cid:96), g,{pki} for i = 1, 2, . . . , n
p(0) = s
{π1, π2, .., πn}.
// As dealer L with a uniform random input s:
SHARING PHASE:
1: Sample a ((cid:96) − 1)-degree random polynomial p(·) such that
2: Let vj, cj, πj ← EncAndProve(pkj, g, p(j)) for each j ∈ [n].
3: Let v = {v1, v2, .., vn}, c = {c1, c2, .., cn}, and π =
4: RBC(v, c, π) with predicate P (·).
5: procedure P (v, c, π)
6:
7:
8:
9:
(cid:46) predicate for node i during RBC
if v is commitment of a polynomial of degree ≤ (cid:96)−1 then
if VerifyDLog(pkj, g, v[j], c[j], π[j]) is valid ∀j then
return True
return False
RECONSTRUCTION PHASE:
// every node i with key pki, ski
10: ˜si := Decrypt(ski, c[i])
11: send (cid:104)RECONSTRUCT, ˜si(cid:105) to all
12: upon receiving (cid:104)RECONSTRUCT, ˜sj(cid:105) from node j do
13:
14:
15:
16:
if v[j] = g ˜sj then
T = T ∪ {˜sj}
if |T|≥ (cid:96) then
output s using Lagrange interpolation and return
threshold ACSS of [19] is the way the dealer encrypts the
shares and computes the corresponding NIZK proofs.
During the sharing phase, to share a uniformly random
secret s ∈ Zq, the dealer L samples a random ((cid:96)− 1) degree
polynomial p(·) such that p(0) = s. Then for each j ∈ [n],
L computes (vj, cj, πj) ← EncAndProve(pkj, g, p(j)). Let
v = {v1, . . . , vn}, c = {c1, . . . , cn}, and π = {π1, . . . , πn}.
We will refer to v, c, π as the commitment, encryption
and proof vector, respectively. Then, the dealer sends the
tuple (v, c, π) using a validated RBC protocol (e.g., [19]).
In a validated RBC protocol, nodes participate only if the
predicate P (·) returns true. In our case, this requires (i) v is a
commitment to a polynomial of degree at most (cid:96)−1; and (ii)
for each tuple (vj, cj, πj), VerifyDLog(pkj, g, vj, cj, πj) =
1, i.e., cj is an encryption of logg vj under pkj, the public
key of node j. For checking the degree of the polynomial
commitment v, we use the approach from [15].
During the reconstruction phase, each node i decrypts c[i]
to recover its share ˜si := Decrypt(ski, c[i]). Node i then
multi-casts ˜si to all other nodes. A node j, upon receiving ˜si
from node i, checks whether v[i] equals g˜si. After receiving
(cid:96) or more valid shares, a node reconstructs the secret using
Lagrange interpolation.
We now analyze our ACSS scheme in Algorithm 2. Termi-
nation of our ACSS follows from the Termination property
of RBC and Completeness property of the EncAndProve.
Similarly, the Completeness of our ACSS follows from the
11
2528
Soundness of EncAndProve and Totality of RBC. Correct-
ness of our ACSS follows directly from the Soundness of
the underlying zero-knowledge protocols. Furthermore, our
ACSS has the Homomorphic-Partial-Commitment property
because the dealer reliably broadcasts the Feldman commit-
ment of the polynomial. We next provide a proof sketch for
Secrecy.
Lemma 9. For a uniformly random s, given gs, assuming
hardness of Decisional Composite Residuosity and the ex-
istence of a Random Oracle, there exists a PPT simulator
that can simulate the view of any static PPT adversary.
Proof Sketch: Let A be a static PPT adversary that
corrupts up to (cid:96) nodes. Without loss of generality, let A
corrupts the ﬁrst (cid:96) nodes. Let pki for i ∈ [n] be the public
key of node i. Given gs for a random secret s, the simulator
S chooses (cid:96) − 1 random points si ∈ Zq for each i ∈ [(cid:96) − 1]
and sets vi = gsi. For each i ∈ [(cid:96), n], S constructs vi using
Lagrange interpolation in the exponent. S then encrypts the
share of the each node j ∈ [(cid:96)− 1]. For each node j ∈ [(cid:96), n],
S uses encryptions of 0 as the encryption of shares of node
j. Note that due to CPA security of the encryption scheme,
the encryptions of 0 are indistinguishable from encryption
of actual shares of nodes in [(cid:96), n]. Next, S uses the zero-
knowledge simulator of the EncAndProve to construct the
proofs πj for each j ∈ [(cid:96), n]. It is easy to see that the
view of A in its interaction with the S is computationally
indistinguishable from its view in the actual protocol.
Now, let us analyze the communication cost of our high-
threshold ACSS. Observe that each v, c and π are κn
bits long. Hence, using the RBC protocol due to [19], the
communication cost of the sharing phase in O(κn2). During
the reconstruction phase, each node multi-casts O(κ) bits,
so the reconstruction phase has a communication cost of
O(κn2). Hence, the total communication cost is O(κn2).
VIII. IMPLEMENTATION AND EVALUATION
A. Implementation Details
We have implemented a prototype of our ADKG protocol
for any reconstruction threshold (cid:96) ∈ [t + 1, n − t] using
python 3.7.6 on top of the open-source hbACSS library [3].
We use Rust libraries for elliptic curve operations and
asyncio for concurrency, though our prototype only runs
on a single processor core. For (cid:96) = t + 1, we use the
ACSS protocol from [19]. For (cid:96) ≥ t + 1, we implement
the ACSS protocol from §VII. Here on, we refer to the
former as the low threshold ACSS and the latter as the high
threshold ACSS. We use the python phe library with default
parameters for DCR operations [20]. We also implement
Crain’s ABA protocol [17] and Das et al.’s RBC [19].
In our implementation, we use both the curve25519 and
bls12-381 elliptic curves. We use the Ristretto group over
curve25519 implementation from [2] and the bls12-381
implementation from Zcash [34] (with a python wrapper
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
)
B
M
n
i
(
e
g
a
s
u
h
t
d