retention.  We  settled  on  this  fast  approximation  to
FIFO:
1. The cache is a circular buffer.
2. Scan the cache for empty slots, and take the first emp-
ty slot found. Note: empty slots occur naturally for
RaceGuard because of the heavy use of cache invali-
dation  upon  successful  creation  of  temporary  files
(see Section 3.1).
3. The above scan is started from the most recently cre-
ated entry. If no empty slots are found, then eject the
entry just before the most recently created entry slot
in the circular buffer.
This cache eviction policy is fast, and avoids the pathol-
ogy of evicting the most recently created entry.
Races  sometimes  occur  between  processes,  especially
for shell scripts. RaceGuard partially deals with this by
inheriting the cache from parent to child (which is why
fork() is mediated). If the parent tested a file’s exist-
ence with a common shell built-in function such as [ -
f  tempfile  ],  this  information  is  shared  with  its
subsequent  child  processes.  Employing  our  aggressive
cache  clearing  policy,  child  processes  clearing  entries
from their cache notify their parent to also clear entries.
Likewise, children do not try to populate their parents’
cache as this would violate our conservative cache pop-
ulation  policy  and  could  pollute  the  parent’s  cache  or
cause false positives.
Some system calls which create file system entries are
not subject to race conditions because they fail when the
entry already exists, i.e. mkdir(), link(), etc. How-
ever, we clear matching cache entries on any successful
file system entry creation, even those which we do not
need to monitor for races. Similarly, many system calls
return  ENOENT  informing  the  user  that  no  file  system
entry  exists.  However,  we  have  carefully  selected  a
small  subset  of  these  calls  to  mediate  based  on  real
world  code.  It  is  common  for  applications  to  use
stat() or access() to check for a file’s existence,
while it is uncommon for applications to use chmod()
for  such  a check.  This  conservative approach  to cache
population also helps ensure the cache is not polluted.
This approach of cautiously only caching entries from a
few file probing system calls is largely effective. How-
ever  one  pathological  case  exists:  when  a  shell  script
executes a program, the shell typically stat’s for that
program  file  in  every  directory  in  the  $PATH.  If  the
script probes many directories before finding the file it
is  looking  for,  it  has  the  effect  of  flooding  the  Race-
Guard  cache  with  useless  entries.  Thus,  a  shell  script
that probes for a file, executes an external program, and
then  creates  the  file,  may  not  be  protected  by  Race-
Guard.  In  our  experience,  most  shell  scripts  find  the
executables they are looking for in /bin or /usr/bin
so this problem does not occur in practice.
Note  that  this  problem  does  not  occur  for  native  pro-
grams  and  dynamic  linking.  The  GNU/Linux  ld.so
loader uses open() rather than stat() when search-
ing  the  $LD_LIBRARY_PATH  for  a  .so  file.  The
(cid:127)
(cid:127)
(cid:127)
 >>
[steve@reddwarf .elm]$ echo "please dont hurt me" > ~/dont_hurt_me
        >>
[steve@reddwarf .elm]$ LD_PRELOAD=~/libmktemp.so rcsdiff -u elmrc > /dev/null
===================================================================
RCS file: RCS/elmrc,v
retrieving revision 1.3
unsafe_mktemp[20038]: ImmunixOS unsafe mktemp - about to pass back /tmp/T0LZ388D
        >>
diff -u -r1.3 elmrc
        >>
[steve@reddwarf .elm]$ cat ~/dont_hurt_me | head -5
#
# .elm/elmrc - options file for the ELM mail system
#
# Saved automatically by ELM 2.5 PL1 for Steve Beattie
#
Figure 1  Successful Attack Against RCS Without RaceGuard
execlp/execvp system calls search the path, but they
do not stat files; instead, they call execve (the sys-
tem call), and if it fails they move on to the next direc-
tory in the path.
4  Security Testing
Rigorous testing of temporary file race vulnerabilities is
problematic, because the vulnerability is fundamentally
non-deterministic: the outcome of the attack depends on
whether  the  victim  program  or  the  attacking  program
wins the race to the file in question. Therefore, the secu-
rity testing in this paper will not be as cleanly definitive
as  we would  like.  To do  deterministic,  repeatable test-
ing,  we  had  to  create  a  situation  in  which  the  attacker
would  reliably win the race. We did this by creating a
doctored  version  of  the  mktemp  library  call  that  does
two key things:
Pause  the  Program:  our  doctored  mktemp  function
pauses the caller for 30 seconds, giving the attacker
ample time to deploy the race attack.
Print the Created File Name: The file names produced
by  mktemp are easy enough to guess that  a deter-
mined  attacker  can  get  a  hit  and  violate  security,
eventually. Our doctored mktemp function shortens
this task by printing the name of the temporary file
that it will create to syslog. This allows the attacker
to precisely deploy a race attack, rather than repeat-
edly guessing the file name.
While we recognize the limited value of security testing
against  such  a  straw-man,  we  felt  it  necessary  to  get
repeatable experiments. We view the above concessions
as  largely  immaterial  to  the  validity  of  RaceGuard
defense,  because  they  only  make  the  programs  more
vulnerable. However, it is interesting to note that while
exploits  for  buffer  overflow  [9],  format  bug  [7],  and
CGI [8] vulnerabilities are readily available, exploits for
race  vulnerabilities  are  extremely  rare.  We  conjecture
that the relative scarcity of race exploits is related to the
relative difficulty in successfully deploying race attacks:
“script kiddies” aren’t interested in attacks that are hard
to do, and so race attacks remain the purview of the rela-
tively serious attacker.
Using this doctored mktemp function, we attacked four
programs:  RCS  version  5.7  [15],  rdist  Version  6.1.5
[14], sdiff - GNU diffutils version 2.7 [2], and shadow-
utils-19990827  [12].  In  each  case,  without  RaceGuard
protection, we succeeded in duping the victim program
into  over-writing  an  unintended  file.  Figure  1  shows
such a successful attack against RCS. With RaceGuard
protection,  the  identical  attack  produces  a  RaceGuard
intrusion alert and aborts the victim program, while the
file that would have been over-written is unharmed, as
shown in Figure 2.
5  Compatibility Testing
RaceGuard is intended to be a highly transparent secu-
rity solution, which means that it may not break much
(if  any)  legitimate  software  that  is  not  being  actively
 >>
[steve@kryten .elm]$ echo "please dont hurt me" > ~/dont_hurt_me
        >>
[steve@kryten .elm]$  LD_PRELOAD=~/libmktemp.so rcsdiff -u elmrc > /dev/null
===================================================================
RCS file: RCS/elmrc,v
retrieving revision 1.3
unsafe_mktemp[1456]: ImmunixOS unsafe mktemp - about to pass back /tmp/T0POjIdZ
        >>
/usr/bin/co: Killed
rcsdiff aborted
        >>
[steve@kryten .elm]$ cat ~/dont_hurt_me 
please dont hurt me
        >>
[steve@kryten .elm]$ dmesg | tail -1
Immunix: RaceGuard: rcsdiff (pid 1458) killing before opening /tmp/T0POjIdZ!
Figure 2  Failed Attack Against RCS With RaceGuard
subjected to actual race attacks. To test this compatibil-
ity requirement, we exercised RaceGuard under a wide
variety  of  software.  To  that  end,  RaceGuard  has  been
running on various developers workstations day-to-day
since January 1, 2001. This section describes the various
compatibility faults induced by the original RaceGuard
design, and how we addressed them. The current imple-
mentation exhibits no known compatibility faults.
The  first  problem  we  encountered  was  manifested  by
the Mozilla  web/mail client.  Mozilla  makes  heavy  use
of  temporary  files  for  caching  web  content.  Re-use  of
some of these names induced false positive reports from
RaceGuard. This problem is what spurred us to add the
cache clearing feature, where RaceGuard cache entries
are  flushed  when  the  corresponding  file  creation  suc-
ceeds.
A  related  problem  was  induced  by  the  script  Red  Hat
Linux uses to preserve  /dev/random’s entropy pool
across re-boots. This is a shell script in which the parent
process does the probe, and a child process creates the
temporary  file.  Adding  the  feature  where  clearing  the
cache entry from a process also clears the entry from its
parent’s cache (see Section 3.2) fixed this problem.
The third problem encountered was induced by CVS [4]
checkout. Here, CVS frequently probes for the same file
name  in  various  directories.  The  rough  sequence  of
“probe(“foo”); 
chdir(“bar”);
creat(“foo”)” induced a false positive RaceGuard
event  for  the  file  “foo”.  Changing  RaceGuard  cache
entries from simply the name presented to each system
call  to  a  fully  resolved  absolute  path  addressed  this
problem.
Finally, the VMWare virtual machine emulation system
[11]  manifested  a  minor  compatibility  problem  with
RaceGuard.  Portions  of  the  VMWare  system  periodi-
cally make calls to the stat() system call with a null
argument  for  the  pathname,  i.e  calling  “stat(““)”
which  is  meaningless.  Initially,  RaceGuard  reported  a
debugging error when this occurred (thinking that it was
some kind of error copying syscall arguments to kernel
space.  However,  once  we  satisfied  ourselves  that  this
behavior  is  harmless,  we  disabled  that  debugging  fea-
ture.
The RaceGuard kernel has been in use on various devel-
oper workstations (now up to half a dozen) for the last
six weeks. Workloads include editing files, compiling &
testing  code,  reading  e-mail,  surfing  the  web,  playing
MP3s1, and compiling large systems such as the kernel
itself (see Section 6). The above are the only compatibil-
ity issues found to date, and all of them are addressed by
the current implementation.
1. Essential for software development :-)
Table 1: RaceGuard Microbenchmark Results
System Call
Stat non-existent file
Open non-existent file
Fork
Without RaceGuard With RaceGuard % Overhead
104%
-4%
13%
4.3 microseconds
1.5 milliseconds
161 microseconds
8.8 microseconds
1.44 milliseconds
183 microseconds
6  Performance Testing
Any run-time security defense will impose performance
costs,  due  to  additional  run-time  checks  that  it  is  per-
forming. However, a security enhancement must be effi-
cient enough that these overhead costs are minimal with
respect  to  the  defense  they  provide.  Ideally,  the  cost
should be below noticability for the intended user base.
RaceGuard  achieves  this  level  of  performance.  Over-
head is only imposed on the run-time cost of a handful
of mediated system calls. The cost on each system call is
cache insertion or lookup to see if the proposed name is
in 
the  RaceGuard  cache.  Section  6.1  presents
microbenchmarks  that  show 
the  precise  overhead
imposed on these system calls. Section 6.2 shows mac-
robenchmarks  that  measure  the  imposed  overhead  on
programs  that  make  intensive  use  of  many  temporary
files.
6.1 Microbenchmarks
Here we measure the marginal overhead of RaceGuard
protection  on  each  of  the  mediated  system  calls.  We
measure  the  overhead  with  programs  that  call  the
affected system call 10,000 times in a tight loop, the test
is run 10 times, the lowest and highest are thrown away,
and the remainder are averaged. We ran these tests with
and  without  RaceGuard  protection,  and  computed  the
percent overhead. The performance results are shown in
Table 1. Some commentary on the results:.
Stat a non-existent file: measure the overhead to create
a RaceGuard cache entry. The marginal overhead is
substantial, because the work of the non-RaceGuard
case is minimal, while the RaceGuard case is doing
some work.
Open  non-existent  file:  measure  the  overhead  to  find
and clear a RaceGuard cache entry. We do not actu-
ally believe there is a speedup due to RaceGuard, and