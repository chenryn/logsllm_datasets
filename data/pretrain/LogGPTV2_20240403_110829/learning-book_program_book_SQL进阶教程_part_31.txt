例如，下面两条SQL语句返回的结果是一样的。
-聚合后使用BAVING子句过露
SELBCT sale_date, SUM(quantity)
FROM SalesHiatoxy
HAVING aale_4ate = *2007-10-01′;
-聚合前使用HHERE子句过滤
SELECT sale_date, SUM(quantity)
FOM SalesHiatoxy
HHERE aale_4ate - * 2007-10-011
sale_date
sun (quant1ty)
* 2007-10-01*
17
但是从性能上来看，第二条语句写法效率更高。原因通常有两个。第
一个是在使用GROUP BY子句聚合时会进行排序，如果事先通过WHERE子
句筛选出一部分行，就能够减轻排序的负担。第二个是在WHERE子句的条
件里可以使用索引。HAVING子句是针对聚合后生成的视图进行筛选的，
但是很多时候聚合后的视图都没有继承原表的索引结构。
在GROUPBY子句和ORDERBY子句中使用索引
一般来说，GROUPBY子句和ORDER BY子句都会进行排序，来对行
进行排列和替换。不过，通过指定带索引的列作为GROUPBY和ORDER
BY的列，可以实现高速查询。特别是，在一些数据库中，如果操作对象
的列上建立的是唯一索引，那么排序过程本身都会被省略掉。如果各位有
兴趣，可以确认一下自己使用的数据库是否支持这个功能。
真的用到索引了吗
一般情况下，我们都会对数据量相对较大的表建立索引。简单理解起
来，索引的工作原理与C语言中指针数组是一样的。即相比查找复杂对象
的数组，查找轻量的指针会更高效。而且最流行的B树索引还进行了一些
优化，以使用二分查找来提升查询的速度。
---
## Page 207
●194—
—第1章 神奇的SOL
假设我们在一个叫作col_1的列上建立了索引，然后来看一看下面这
条SQL语句。这条SQL语句本来是想使用索引，但实际上执行时却进行
了全表扫描。很多时候，大家是否也在无意识间就这么写了呢？
在索引字段上进行运算
SSL8CT *
FROM SomeTable
100T 100 / 1.1
同样，在查询条件的左侧使用函数时，也不能用到索引。
S8L8CT *
FEOM SomeTable
MHERE SUBSTE |col_1, 1, 1] - +a ′;
如果无法避免在左侧进行运算，那么使用函数索引也是一种办法，但
是不太推荐随意这么做。
使用索引时，条件表达式的左侧应该是原始字段
请牢记，这一点是在优化索引时首要关注的地方。
使用ISNULL谓词
通常，索引字段是不存在NULL的，所以指定ISNULL和IS NOT
NULL的话会使得索引无法使用，进而导致查询性能低下。
SELSCT *
注
HHERE col_1 IS NULL;
FEOM SoneTable
在 DB2 和Oracle中， I5 UL条
件色能使用素引。这也许是因为
它们在实我时为N续了某个
关于索引字段不存在NULL的原因，简单来说是NULL并不是值。非
具有特殊含义的值。但量，这个
特性不显所有数报库都有的。
值不会被包含在值的集合中（详情请参考1-3节）
图灵社区会员非洲钢(PI:EMAIL）专享尊重版权
---
## Page 208
1-11让SOL飞起来—195
然而，如果需要使用类似IS NOT NULL的功能，又想用到索引，那
么可以使用下面的方法，假设“col_1”列的最小值是1。
--IS NOT NULL的代替方案
SELECT *
MHERE col_1 > 0
原理很简单，只要使用不等号并指定一个比最小值还小的数，就可以
选出 col_1中所有的值。因为 col_1>NULL 的执行结果是 unknown，所
以当“col_1”列的值为NULL的行不会被选择。不过，如果要选择“非
NULL的行”，正确的做法还是使用IS NOT NULL。上面这种写法意思有些
容易混淆，所以笔者也不太推荐，请只在应急的情况下使用。
使用否定形式
下面这几种否定形式不能用到索引。
<>
#!=
 NOT IN
因此，下面的SQL语句也会进行全表扫描。
SELECT *
FROM SoneTable
使用OR
在col_1和co1_2上分别建立了不同的索引，或者建立了（col_1,
col_2）这样的联合索引时，如果使用oR连接条件，那么要么用不到索引，
要么用到了但是效率比AND要差很多。
SELECT *
SoneTable
MHERB
col_1 > 100
OR
col_2 = *abe ′;
---
## Page 209
196—第1章神奇的SQL
如果无论如何都要使用OR，那么有一种办法是位图索引。但是这种
索引的话更新数据时的性能开销会增大，所以使用之前需要权衡一下利弊。
使用联合索引时，列的顺序错误
假设存在这样顺序的一个联合索引“col_1，col_2，col_3"
这时，指定条件的顺序就很重要。
SELECT * FROM SomeTable MHERE ool_1 = 10 ND col_2 = 100 AND col_3 = 500;
SELECT · FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 
X
SELECT · FROM SomeTable WHERE col_1 = 10 AND col_3 = 500 
SELECT ▪ FROM SomeTable WHERE col_2 - 100 AND col_3 = 500 
SELECT · FROM SomeTable WHERE col_2 = 100 AND col_1 - 10 
联合索引中的第一列（col_1）必须写在查询条件的开头，而且索引
中列的顺序不能顺倒，有些数据库里顺序颠倒后也能使用索引，但是性能
还是比顺序正确时差一些。
如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引
拆分为多个索引。
使用LIKE谓词进行后方一致或中间一致的匹配
使用LIKE谓词时，只有前方一致的匹配才能用到索引。
XSELECT +FROM SomeTable MHERE col_1 LIKE a;
SELECT
FROM
SomeTable
LIKE a’;
SELECT
FROM
SomeTable
进行默认的类型转换
■对char类型的“col_1”列指定条件的示例
SELECT * FROM SomeTable MHERE col_1 = 101
SELECT * FROM SomeTable MHERE col_1 = +10′;
SELECT * FROM SoneTable MHERE col_1 - CAST(10, AS CHAR(2>);
默认的类型转换不仅会增加额外的性能开销，还会导致索引不可用，
可以说是有百害而无一利。虽然这样写还不至于出错，但还是不要嫌麻烦，
在需要类型转换时显式地进行类型转换吧（别忘了转换要写在条件表达式
的右边）。
---
## Page 210
1-11让SOL飞起来—197
减少中间表
在SQL中，子查询的结果会被看成一张新表，这张新表与原始表一样，
可以通过代码进行操作。这种高度的相似性使得SQL编程具有非常强的
灵活性，但是如果不加限制地大量使用中间表，会导致查询性能下降。
频繁使用中间表会带来两个间题，一是展开数据需要耗费内存资源，
二是原始表中的索引不容易使用到（特别是聚合时）因此，尽量减少中
间表的使用也是提升性能的一个重要方法。
灵活使用HAVING子句
对聚合结果指定筛选条件时，使用HAVING子句是基本原则。不习惯
使用HAVING子句的数据库工程师可能会倾向于像下面这样先生成一张中
间表，然后在WHERE子句中指定筛选条件。
SELECT *
FROM (sELECT sale_date, MAX (quantity) AS max_qty
FROM SalesHistory
GROUP BY sale_date) TMF
证用的中间表
/0T =
和IN谓词的参数就不能是标量值，而应是值列表了。
我们来看一下下面这道例题。这里对多个字段使用了In谓词，“id"
列是主键。
SELBCT id, state, city
FROM Addressesl A1
MHERE 8tate IN (SEL&CT atate
KHERE A1.id = A2.idl
FROM Addresses2 A2
KHERE A1.id = A2. idl J
这段代码中用到了两个子查询。但是，如果像下面这样把字段连接在
一起，那么就能把逻辑写在一处了。
SSLSCT *
FROM Addressesl A1
MHERE id ll state ll city
IN (sELECT id Il Btatell city
FROM Addresses2 A2) :
这样一来，子查询不用考虑关联性，而且只执行一次就可以。此外，
如果所用的数据库实现了行与行的比较，那么我们也可以像下面这样，在
IN中写多个字段的组合。
SELSCT *
FEOM Addressesal Al
MHERE (id, state, clty)
IN (SELEcr id, atate, city
FROM Addresses2 A2) :
这种方法与前面的连接字段的方法相比有两个优点。一是不用担心连
接字段时出现的类型转换间题，二是这种方法不会对字段进行加工，因此
可以使用索引，
图灵社区会员 非洲铜(PI:EMAIL) 专享 尊重版权
---
## Page 212
111让SOL飞起来—199
先进行连接再进行聚合
1-5节提到过，连接和聚合同时使用时，先进行连接操作可以避免产
生中间表。原因是，从集合运算的角度来看，连接做的是“乘法运算”
连接表双方是一对一、一对多的关系时，连接运算后数据的行数不会增加。
而且，因为在很多设计中多对多的关系都可以分解成两个一对多的关系，
因此这个技巧在大部分情况下都可以使用。
合理地使用视图
视图是非常方便的工具，相信日常工作中很多人都在频繁地使用。但
是，如果没有经过深入思考就定义复杂的视图，可能会带来巨大的性能问
题。特别是视图的定义语句中包含以下运算的时候，SQL会非常低效，执
行速度也会变得非常慢。
·聚合函数（AVG、COUNT、SUM、MIN、MZX）
集合运算符（UNION、INTERSECT、EXCEPT等）
一般来说，要格外注意避免在视图中进行聚合操作后需要特别注意。
最近越来越多的数据库为了解决视图的这个缺点，实现了物化视图
（materializedview）等技术。当视图的定义变得复杂时，可以考虑使用一下。
本节小结
本节重点介绍了SQL性能优化方面的一些注意事项。虽然这里列举
了几个要点，但其实优化的核心思想只有一个，那就是找出性能瓶颈所在，
重点解决它。
其实不只是数据库和SQL，计算机世界里容易成为性能瓶颈的也是
对硬盘，也就是文件系统的访间（因此个人计算机还可以通过增加内存，
或者使用访间速度更快的硬盘等方法来提升性能），不管是减少排序还是
使用索引，抑或是避免中间表的使用，都是为了减少对硬盘的访问。请务
必理解这一本质。
---
## Page 213
20O—第1章奇的SOL
下面是本节要点。
1.参数是子查询时，使用EXISTS或者连接代替IN。
2.使用索引时，条件表达式的左侧应该是原始字段。
3.在SQL中排序无法显式地指定，但是请注意很多运算都会暗中进
行排序。
4.尽量减少没用的中间表。
如果想了解关于性能优化的更高级的内容，请参考下面的资料。
1.JoeCelko，《SQL权威指南（第4版》（人民邮电出版社，2013年）
化方法，从基本思想到高级技巧进行了全面的介绍。
2.后藤孝宪、名和满、五岛和彦、井原秀树，《系统工程师的Oracle性能
注0
优化指南》（SoftBank Publishing，2003年）
原书名% [ SE    ) 0racle
/;
这是一本全面总结性能优化要点的好书。虽然书名中有Oracle，但也包
无中文版。——编者注
含了许多不依赖具体数据库实现的通用的观点和技巧，强烈推荐。
---
## Page 214
112SQL编程方法
201@
SQL编程方法
确立SOL的编程风格
在SQL中，标准的端程风格还不成熟，也没有确立统一的编程方针。本节将面向未来，思考真正合
理的SQL编程风格，并提出笔者个人的想法，望有抛砖引玉之效。
代码要清晰，不要为了“效率”牺牲可读性。
注0
Kernighan&Plauger，《编程格调》
高博、除张宁译，人民部电出版
社, 2015 年。
写在前面
在编程的世界里，有很多追求各种高超技巧的研究领域。但是除此之
外，还有重视代码的可读性，从提高开发效率的角度研究编程风格的领域。
随着编程语言从注重“更容易让机器理解”的低级语言（如机器语言
程语言应该是一种人类可以读得懂、写得出的语言”这样的观点越来越认
同，于是从认知心理学的角度研究编程风格的领域应运而生。认知心理学
这样的偏执态度，去认真地思考如何写出任何人看了都觉得简单明了，而
且错误很少的代码一—这其实也是一种非常普遍的常识。应该有不少人听
注图