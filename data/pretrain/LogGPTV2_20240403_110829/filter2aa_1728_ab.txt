• Data
Binary Obfuscation
Obfuscation
• Layout obfuscation essentially means 
scrambling the program around at the 
source-level.
• The International Obfuscated C Contest 
(ioccc.org) is a perfect example of this.
Binary Obfuscation
Obfuscation
X=1024; Y=768; A=3;
J=0;K=-10;L=-7;M=1296;N=36;O=255;P=9;_=1>>BBBGGIIKK"[b]-64;C="C@=::C@@==@=:C@=:C@=:C5""31/513/5131/"
"31/531/53"[b ]-64;S=bx?(X^=Y):0,  I (x,Y/2,X
)):(E=X);      }H(x){I(x,    _,0);}p;q(        c,x,y,z,k,l,m,a,          b){F(c
);x-=E*M     ;y-=S*M           ;z-=C*M         ;b=x*       x/M+         y*y/M+z
*z/M-D*D    *M;a=-x              *k/M     -y*l/M-z        *m/M;    p=((b=a*a/M-
b)>=0?(I    (b*M,_      ,0),b    =E,      a+(a>b      ?-b:b)):     -1.0);}Z;W;o
(c,x,y,     z,k,l,    m,a){Z=!    c?      -1:Z;c           0&&c!=     a&&        (p0
&&Z>=0? (e+=h*W/M,f+=i*W/M,g+=j*W/M,F(Z),u=e-E*M,v=f-S*M,w=g-C*M,b=(-2*u-2*v+w)
/3,H(u*u+v*v+w*w),b/=D,b*=b,b*=200,b/=(M*M),V=Z,E!=0?(u=-u*M/E,v=-v*M/E,w=-w*M/
E):0,E=(h*u+i*v+j*w)/M,h-=u*E/(M/2),i-=v*E/(M/2),j-=w*E/(M/2),n(e,f,g,h,i,j,d-1
,Z,0,0),Q/=2,T/=2,       U/=2,V=V0?g/8:g/     20):0,j    >0?(U=     j    *j/M,Q      =255-    250*U/M,T=255
-150*U/M,U=255    -100    *U/M):(U    =j*j     /M,UO?     O:          Q;T=TO?O:T;U=UO?O:U;}R;G;B    ;t(x,y     ,a,    b){n(M*J+M    *40*(A*x   +a)/X/A-M*20,M*K,M
*L-M*30*(A*y+b)/Y/A+M*15,0,M,0,P,  -1,0,0);R+=Q    ;G+=T;B   +=U;++a 0)
{
   puts(“yes”);
   exit(0);
}
puts(“no”);
Binary Obfuscation
Control-Flow Obfuscation
PUSH “yes”
CALL $PUTS
PUSH 0
CALL $EXIT
int a=7,b=2,c=8,d=9;
if (a+b+c*d > 0)
{
   puts(“yes”);
   exit(0);
}
puts(“no”);
Binary Obfuscation
Control-Flow Obfuscation
int a,b,c,d;
srand(time(0));
a=rand()+1;b=rand()+1;
c=rand()+1;d=rand()+1;
if (a+b+c*d > 0)
{
   puts(“yes”);
   exit(0);
}
puts(“no”);
Binary Obfuscation
Control-Flow Obfuscation
...
TEST EAX,EAX
JLE SHORT :NO
PUSH “yes”
CALL $PUTS
PUSH 0
CALL $EXIT
NO: PUSH “no”
CALL $PUTS
int a,b,c,d;
srand(time(0));
a=rand()+1;b=rand()+1;
c=rand()+1;d=rand()+1;
if (a+b+c*d > 0)
{
   puts(“yes”);
   exit(0);
}
puts(“no”);
Binary Obfuscation
Control-Flow Obfuscation
• Control-ﬂow ﬂattening involves, quite 
literally, ﬂattening the graphical 
representation of your program.
• Typically you have a top-down ﬂow with 
program graphs. With ﬂattening, you cause 
a central piece of code to control the ﬂow 
of the program.
• Control-ﬂow obfuscation is employed by 
bin/crackmes/leetkey.exe
Binary Obfuscation
Control-Flow Obfuscation
Flattened:
Normal:
Binary Obfuscation
Control-Flow Obfuscation
Binary Obfuscation
Control-Flow Obfuscation
doThis();
doThat();
doMore();
int x=2;
sw: switch(x) {
   case 0: doThat();
   x = 1;
   goto sw;
   case 1: doMore();
   break; 
   case 2: doThis();
   x = 0;
   goto sw;
}
Binary Obfuscation
Control-Flow Obfuscation
• This technique of obfuscation can be 
applied very creatively.
• See src/cﬂow-ﬂatlist.c and                      
src/cﬂow-ﬂattree.c
Binary Obfuscation
Control-Flow Obfuscation
• Most programs are reducible-- meaning 
they can easily be optimized.
• If a program is irreducible, then it cannot be 
optimized, thus translating spaghetti code 
into spaghetti assembly.
• A good example by Madou et. al. is making 
a loop irreducible.
• See src/cﬂow-irreducible.c
Binary Obfuscation
Control-Flow Obfuscation
• Raising bogus exceptions is a common way 
for malware to obfuscate and frustrate 
reverse engineering.
• This is easily accomplished by setting up a 
try block, intentionally triggering the 
exception, then resuming at the caught 
section.
• For Linux, you can do the same with signals.
• See src/cﬂow-exceptions.cpp
Binary Obfuscation
Control-Flow Obfuscation
try {
   volatile int trigger=20;
   doThis();
   doThat();
   /* trigger divide-by-zero exception */
   trigger=trigger/(trigger-trigger);
   neverExecutes();
} catch (...) {
   doMore();
   doTonsMore();
}
Data Obfuscation
Binary Obfuscation
Data Obfuscation
• Data obfuscation takes a little more care 
than control-ﬂow obfuscation.
• The data must be obfuscated before the 
compilation process, then de-obfuscated at 
run-time.
• If the data is not obfuscated before run-
time, dead-code analysis is made trivial and 
your obfuscation is useless.
Binary Obfuscation
Data Obfuscation
• One of the more obvious techniques is to 
encrypt your strings.
• Even though strings don’t technically lead 
to knowledge of the program, it can help 
aide in reverse-engineering more often than 
you think.
Binary Obfuscation
Data Obfuscation
• Recall the explanation of volatile:
• With enough annoyances, this can be used 
to frustrate analysis.
volatile int x;
x = 7;
x <<= 2;
x *= 2;
x -= 12;
x += (x*x)<<2;
printf("%d\n", x);
Binary Obfuscation
Data Obfuscation
• Data aggregation can be used to make 
dead-code analysis confusing.
char aggr[7] = “fboaor”;
char foo[3], bar[3];
int i;
for (i=0;i<3;++i) {
   foo[i]=aggr[i*2];
   bar[i]=aggr[i*2+1];
}
/* foo = “foo” / bar = “bar” */
Binary Obfuscation
Data Obfuscation
• Functions in the PLT/IAT are certainly 
considered data.
• To prevent dead-code analysis from 
discovering our library calls, we can easily 
“create” functions at run-time by using 
system calls such as LoadLibrary and 
GetProcAddress (Windows) and 
dlopen and dlsym (Linux).
• See src/data-loadlib.c, src/data-dlopen.c and 
src/mdl.cpp
Poor Man’s Packer
How to simulate a packer in a humorous manner.
Binary Obfuscation
Poor Man’s Packer
• Combines control-ﬂow and data 
obfuscation to cause all sorts of headaches.
• Revolves around compiling, copying data 
and applying function pointers to 
obfuscated or encrypted data.
• See bin/crackmes/manifest.exe
• If you have problems with this binary, ask 
a DC949 member what the group motto 
is.
Binary Obfuscation
Poor Man’s Packer
• Compile
• Disassemble
• Copy bytes of function, make an array
• Apply encryption, aggregation, etc.
• Recompile
• Decipher at run-time
• Cast as function-pointer
• Execute
• See src/pmp-concept.c
Binary Obfuscation
Poor Man’s Packer
• Problems
• Functions are broken because they are 
no longer in the PLT/IAT.
• Data offsets are completely messed up.
• Functions in C++ objects cause 
segmentation faults (due to broken 
thiscall).
• Compiler might change calling 
conventions.
• void pointers are scary.
Binary Obfuscation
Poor Man’s Packer
• If you pass a data structure containing data 
required by the function (function offsets, 
strings, etc.), you can circumvent the issue 
caused by relative jumps and offsets.
• This also applies to method pointers and      
C++ objects.
• This gives you the opportunity to 
dynamically add and remove necessary 
program data as you see ﬁt.
Binary Obfuscation
Poor Man’s Packer
• Be sure your calling conventions match 
after each step of compilation and byte-
copying!
• cdecl is the calling convention used by 
vararg functions such as printf.
• fastcall and stdcall should be ﬁne for all 
other functions.
• Mismatched calling conventions will cause 
headaches and segmentation faults.
Binary Obfuscation
Poor Man’s Packer
• Why is this beneﬁcial?
• Ultimate control of all data
• Code is still portable and executable
• Adds a bizarre layer of obfuscation
• When done enough, severely obfuscates 
source
Binary Obfuscation
Poor Man’s Packer
• Why does this suck?
• Makes binaries huge if you don’t 
compress your functions due to enlarged 
data-sections
• Takes a lot of work to accomplish
• It can be extremely frustrating to craft 
the write code with the right keywords 
with full optimization
Additional Info
Some stuff to help you out with obfuscation
Binary Obfuscation
Tools
• Code transformers
• TXL (txl.ca)
• SUIF (suif.standford.edu)
• TXL and SUIF are used to transform 
source-code by a certain set of given rules 
(such as regular expressions).
Binary Obfuscation
Sources
• M. Madou, B. Anckaert, B. De Bus, K. De 
Bosschere, J. Cappaert, and B. Preneel, "On 
the Effectiveness of Source Code 
Transformations for Binary Obfuscation"
• B. M. Prasad, T. Chiueh, "A Binary Rewriting 
Defense against Stack based Buffer 
Overﬂows"
• C. I. Popov, S. Debray, G. Andrews, "Binary 
Obfuscation Using Signals"
The End