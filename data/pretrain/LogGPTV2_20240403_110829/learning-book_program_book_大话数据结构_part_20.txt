Q->front-（Q->front+1）&MAxSIzE;
/front指针向后移一位置，*/
/·若到最后则转到数组头部·/
returnoK;
从这一段讲解，大家应该发现，单是顺序存储，若不是循环队列，算法的时间性
能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下
不需要担心队列长度的链式存储结构。
4.13队列的链式存储结构及实现
队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，
我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，
117
---
## Page 142
太请
数据结构
面队尾指针指向终端结点，如图4-13-1所示。
头结点
队头
队尾
front
rear
图 4-13-1
空队列时，front和rear都指向头结点，如图4-13-2所示。
头结点
front
rear
图4-13-2
链队列的结构为：
typedefintQElemType;/QElemType类型根据实情况而定，这里做设为int*/
typedefstruct ONode
结点结构
QElemType data;
)QNode,*QueuePtr;
typedef struct
/队列的键表结构/
QueuePtrfront，rear：/·队头、队尾相针
)LinkQueue;
4.13.1队列的链式存储结构一
一入队操作
入队操作时，其实就是在链表尾部插入结点，如图4-13-3所示。
118
---
## Page 143
第4章栈与队列
图4-13-3
其代码如下：
/插入元素e为Q的新的队尾元意/
Status EnQueue（LinkQueue *Q,QElemType e）
QueuePtr s=（QueuePtr）malloc（sizeof（qNode））;
if(!s)
/存储分配失败*/
exit（OVERFLOW）;
s->data=e;
s->next-NULL;
Q->rear->next=s;
/·把拥有元素e新结点8赋值给原队尾结点的后继，/
见上图中①/
Q->rear=s;
/·把当前的s设置为队尾结点，rear指向s.见上图中②*/
return-OK;
4.13.2队列的链式存储结构
出队操作
出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，
若链表除头结点外只剩一个元素时，则需将rear指向头结点，如图4-13-4所示。
结点p即front
结点ip即f
a
a
3
图 4-13-4
代码如下：
/若队列不空，删除Q的队头元素，用e退四其值，并返四OK，否则返园ERROR*/
119
---
## Page 144
大据数据结构
.a.x)
QueuePtr p:
if(o->front--Q->rear)
return ERROR;
p=Q->front->next：/·将缺删除的队头结点暂存给p，见上图中①*/
*e"p->data;
/将欲副除的队头结点的值赋值给e*/
Q->front->next=p->next;/*将原队头结点后继p->next赋值给头结点后继，*/
·元上图中②/
if（Q->rear--p）/*若队头是队尾，则副除后将rear指向头结点，见上图中③*/
-0），其中，s是串的名称，用双引号（有些书中
也用单引号）括起来的字符序列是串的值，注意单引号不属于串的内容。a（1≤i<
n）可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称
空串（nullstring），它的长度为零，可以直接用两双引号“”表示，也可以用希腊
字母“”来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。
还有一些概念需要解释。
空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，
面且可以不止一个空格。
子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，
包含子串的串称为主串。
子串在主串中的位置就是子串的第一个字符在主串中的序号。
“believe”这些单词字符串的子串。
125
---
## Page 150
大适数据结构
5.3串的比较
两个数字，很容易比较大小。2比1大，这完全正确，可是两个字符串如何比
机中的大小其实取决于它们挨个字母的前后顺序。它们的第一个字母都是“s”，我们
认为不存在大小差异，而第二个字母，由于“”字母比“t”字母要靠前，所以“1”<
“t”，于是我们说“silly”<“stupid”。
事实上，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的
是字符在对应字符集中的序号。
计算机中的常用字符是使用标准的ASCII编码，更准确一点，由7位二进制数表
示一个字符，总共可以表示128个字符。后来发现一些特殊符号的出现，128个不够
用，于是扩展ASCII码由8位二进制数表示一个字符，总共可以表示256个字符，这
已经足够满足以英语为主的语言和特殊符号进行输入、存储、输出等操作的字符需要
了。可是，单我们国家就有除汉族外的满、回、藏、蒙古、维吾尔等多个少数民族文
字，换作全世界估计要有成百上千种语言与文字，显然这256个字符是不够的，因此
后来就有了Unicode编码，比较常用的是由16位的二进制数表示一个字符，这样总
共就可以表示216个字符，约是65万多个字符，足够表示世界上所有语言的所有字
符了。当然，为了和ASCI1码兼容，Unicode的前256个字符与ASCII码完全相同。
所以如果我们要在C语言中比较两个串是否相等，必须是它们申的长度以及它们
各个对应位置的字符都相等时，才算是相等。即给定两个串：s“ajazan，t
“bb…..bm，当且仅当n=m，且a=b，az=bz，.…，an=bm时，我们认为s=t。
那么对于两个串不相等时，如何判定它们的大小呢。我们这样定义：
给定两个申：s=“aaz…an”，t=“bb...bm”，当满足以下条件之一时，
s<t.
1.n<m，且a=b（i=1，2,…,n）。
例如当s=“hap，t=“happy”，就有s<t。因为t比s多出了两个字母。
2.存在某个k<min（m，n），使得aj=b（i=1，2，……，k-1），ak<bk
例如当s=“happen”，t=“happy”，因为两串的前4个字母均相同，而两串第5