.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "CREATE TABLE" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
CREATE TABLE \- 定义一个新表
.SH SYNOPSIS
.sp
.nf
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE \fItable_name\fR (
    { \fIcolumn_name\fR \fIdata_type\fR [ DEFAULT \fIdefault_expr\fR ] [ \fIcolumn_constraint\fR [, ... ] ]
    | \fItable_constraint\fR
    | LIKE \fIparent_table\fR [ { INCLUDING | EXCLUDING } DEFAULTS ] }  [, ... ]
)
[ INHERITS ( \fIparent_table\fR [, ... ] ) ]
[ WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
where \fIcolumn_constraint\fR is:
[ CONSTRAINT \fIconstraint_name\fR ]
{ NOT NULL | NULL | UNIQUE | PRIMARY KEY |
  CHECK (\fIexpression\fR) |
  REFERENCES \fIreftable\fR [ ( \fIrefcolumn\fR ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE \fIaction\fR ] [ ON UPDATE \fIaction\fR ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
and \fItable_constraint\fR is:
[ CONSTRAINT \fIconstraint_name\fR ]
{ UNIQUE ( \fIcolumn_name\fR [, ... ] ) |
  PRIMARY KEY ( \fIcolumn_name\fR [, ... ] ) |
  CHECK ( \fIexpression\fR ) |
  FOREIGN KEY ( \fIcolumn_name\fR [, ... ] ) REFERENCES \fIreftable\fR [ ( \fIrefcolumn\fR [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE \fIaction\fR ] [ ON UPDATE \fIaction\fR ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBCREATE TABLE\fR 将在当前数据库创建一个新的， 初始为空的表。该表将由发出此命令的用户所有。
.PP
 如果给出了模式名（比如，CREATE TABLE myschema.mytable ...）， 那么表是在指定模式中创建的。否则它在当前模式中创建。临时表存在于一个特殊的模式里， 因此创建临时表的时候不能给出模式名。表名字必需和同一模式中其他表，序列，索引或者视图相区别。
.PP
\fBCREATE TABLE\fR 还自动创建一个数据类型， 该数据类型代表对应该表一行的复合类型。 因此，表不能和同模式中的现有数据类型同名。
.PP
 一个表的字段数不能超过 1600。（实际上，真正的限制比这低，因为还有元组长度的约束）。
.PP
 可选的约束子句声明约束（或者测试），新行或者更新的行必须满足这些约束才能成功插入或更新。 约束是一个它是一个 SQL 对象，它以多种方式协助我们协助我们在表上定义有效的数值集合。
.PP
 定义约束又两种方法：表约束和列约束。一个列约束是作为一个列定义的一部分定义的。 而表约束并不和某个列绑在一起， 它可以作用于多于一个列上。每个列约束也可以写成表约束； 如果某个约束只影响一个列，那么列约束只是符号上的简洁方式而已。
.SH "PARAMETERS 参数"
.TP
\fBTEMPORARY 或 TEMP\fR
 如果声明了此参数，则该表创建为临时表。临时表在会话结束时自动删除， 或者是（可选）在当前事务的结尾（参阅下面的 ON COMMIT）。 现有同名永久表在临时表存在期间在本会话过程中是不可见的， 除非它们是用模式修饰的名字引用的。 任何在临时表上创建的索引也都会自动删除。
 我们可以选择在 TEMPORARY 或 TEMP 前面放上 GLOBAL 或者 LOCAL。 这样对 PostgreSQL 没有任何区别，可以参阅 Compatibility [\fBcreate_table\fR(7)]。
.TP
\fB\fItable_name\fB\fR
 要创建的表的名字（可以用模式修饰）。
.TP
\fB\fIcolumn_name\fB\fR
 在新表中要创建的字段名字。
.TP
\fB\fIdata_type\fB\fR
 该字段的数据类型。它可以包括数组说明符。
.TP
\fBDEFAULT\fR
DEFAULT 子句给它所出现的字段一个缺省数值。 该数值可以是任何不含变量的表达式（不允许使用子查询和对本表中的其它字段的交叉引用）。 缺省表达式的数据类型必须和字段类型匹配。
 缺省表达式将被用于任何未声明该字段数值的插入操作。 如果字段上没有缺省值，那么缺省是 NULL。
.TP
LIKE 子句声明一个表，新表自动从这个表里面继承所有字段名， 他们的数据类型，以及非空约束。
 和 INHERITS 不同，新表与继承过来的表之间在创建动作完毕之后是完全无关的。 插入新表的数据不会在父表中表现出来。
 字段缺省表达式只有在声明了 INCLUDING DEFAULTS 之后才会继承过来。 缺省是排除缺省表达式。
.TP
\fBINHERITS ( \fIparent_table\fB [, ... ] )\fR
 可选的 INHERITS 子句声明一列表，这个新表自动从这列表中继承所有字段。 如果在多于一个父表中存在同名的字段，那么就会报告一个错误，除非这些字段的数据类型在每个父表里都是匹配的。 如果没有冲突，那么重复的字段在新表中融合成一个字段。 如果新表的字段名列表中包括和继承的字段同名的，那么它的数据类型也必须和上面一样与继承字段匹配，并且这些字段定义会融合成一个。 不过，同名的继承和新字段声明可以声明不同的约束：所有的继承过来的约束以及声明的约束都融合到一起，并且全部应用于新表。 如果新表为该字段明确的声明了一个缺省数值，那么此缺省数值覆盖任何来自继承字段声明的缺省值。 否则，任何为该字段声明了缺省数值的父表都必须声明相同的缺省，否则就会报告一个错误。
.TP
\fBWITH OIDS\fR
.TP
\fBWITHOUT OIDS\fR
 这个可选的子句声明新表中的行是否应该拥有赋予它们的 OID （对象标识）。 缺省是有 OID。（如果新表从任何有 OID 的表继承而来，那么就算这条命令说了 WITHOUT OIDS， 也会强制 WITH OIDS。）
 声明 WITHOUT OIDS 允许用户禁止为行或者表生成 OID。 这么做对大表是值得的，因为这样可以减少 OID 消耗并且推迟 32 位 OID 计数器的消耗。 一旦该计数器重叠，那么就不能再假设 OID 的唯一，这样它的实用性就大打折扣。 声明 WITHOUT OIDS 还会减少在磁盘上存储每行的空间，每行减少 4 字节，因此也可以改进性能。
.TP
\fBCONSTRAINT \fIconstraint_name\fB\fR
 列或表约束的可选名字。如果没有声明，则由系统生成一个名字。
.TP
\fBNOT NULL\fR
 字段不允许包含 NULL 数值。
.TP
\fBNULL\fR
 该字段允许包含 NULL 数值。这是缺省。
 这个子句的存在只是为和那些非标准 SQL 数据库兼容。 我们不建议在新应用中使用它。
.TP
\fBUNIQUE (column constraint)\fR
.TP
\fBUNIQUE ( \fIcolumn_name\fB [, ... ] ) (table constraint)\fR
UNIQUE 声明一个规则，表示一个表里的一个或者多个独立的字段组合的分组只能包含唯一的数值。 表的唯一约束的行为和列约束的一样，只不过多了跨多行的能力。
 对于唯一约束的用途而言，系统认为 NULL 数值是不相等的。
 每个唯一表约束都必须命名一个字段的集合，该集合必须和其它唯一约束命名字段集合或者该表定义的主键约束不同。 （否则就只是同样的约束写了两次。）
.TP
\fBPRIMARY KEY (column constraint)\fR
.TP
\fBPRIMARY KEY ( \fIcolumn_name\fB [, ... ] ) (table constraint)\fR
 主键约束表明表中的一个或者一些字段只能包含唯一（不重复）非 NULL 的数值。 从技术上讲，PRIMARY KEY 只是 UNIQUE 和 NOT NULL 的组合，不过把一套字段标识为主键同时也体现了模式设计的元数据， 因为主键意味着其它表可以拿这套字段用做行的唯一标识。
 一个表只能声明一个主键，不管是作为字段约束还是表约束。
 主键约束应该定义在同个表上的一个与其它唯一约束所定义的不同的字段集合上。
.TP
\fBCHECK (\fIexpression\fB)\fR
CHECK 约束声明一个生成布尔结果的子句， 一次插入或者更新操作若想成功则里面的新行或者被更新的行必须满足这个条件。 声明为字段约束的检查约束应该只引用该字段的数值，而在表约束里出现的表达式可以引用多个字段。
 目前，CHECK 表达式不能包含子查询也不能引用除当前行字段之外的变量。
.TP
\fBREFERENCES \fIreftable\fB [ ( \fIrefcolumn\fB ) ] [ MATCH \fImatchtype\fB ] [ ON DELETE \fIaction\fB ] [ ON UPDATE \fIaction\fB ] (column constraint)\fR
.TP
\fBFOREIGN KEY ( \fIcolumn\fB [, ... ] )\fR
 这些子句声明一个外键约束，外键约束声明一个由新表中一列或者多列组成的组应该只包含匹配引用的表 reftable 中对应引用的字段 refcolumn 中的数值。 如果省略 refcolumn， 则使用 reftable 的主键。 被引用字段必须是被引用表中的唯一字段或者主键。
 向这些字段插入的数值将使用给出的匹配类型与参考表中的参考列中的数值进行匹配。 有三种匹配类型：MATCH FULL， MATCH PARTIAL，和 MATCH SIMPLE，它也是缺省匹配类型。 MATCH FULL 将不允许一个多字段外键的字段为 NULL，除非所有外键字段都为 NULL。 MATCH SIMPLE 允许某些外键字段为 NULL 而外键的其它部分不是 NULL。MATCH PARTIAL  还没实现。
 另外，当被参考字段中的数据改变的时候，那么将对本表的字段中的数据执行某种操作。 ON DELETE 子句声明当被参考表中的被参考行将被删除的时候要执行的操作。 类似，ON UPDATE 子句声明被参考表中被参考字段更新为新值的时候要执行的动作。 如果该行被更新，但被参考的字段实际上没有变化，那么就不会有任何动作。 下面是每个子句的可能的动作：
.RS
.TP
\fBNO ACTION\fR
 生成一个错误，表明删除或者更新将产生一个违反外键约束的动作。 它是缺省动作。
.TP
\fBRESTRICT\fR
 和 NO ACTION 一样，只是动作不可推迟， 即使约束剩下的部分是可以推迟的也马上发生。
.TP
\fBCASCADE\fR
 删除任何引用了被删除行的行，或者分别把引用行的字段值更新为被参考字段的新数值。
.TP
\fBSET NULL\fR
 把引用行数值设置为 NULL。
.TP
\fBSET DEFAULT\fR
 把引用列的数值设置为它们的缺省值。
.RE
.PP
 如果主键字段经常更新，那么我们给 REFERENCES  字段增加一个索引可能是合适的，这样与 REFERENCES 字段相关联的 NO ACTION  和 CASCADE 动作可以更有效地执行。
.TP
\fBDEFERRABLE\fR
.TP
\fBNOT DEFERRABLE\fR
 这两个关键字设置该约束是否可推迟。一个不可推迟的约束将在每条命令之后马上检查。 可以推迟的约束检查可以推迟到事务结尾（使用 SET CONSTRAINTS [\fBset_constraints\fR(7)]  命令）。 缺省是 NOT DEFERRABLE。目前只有外键约束接受这个子句。所有其它约束类型都是不可推迟的。
.TP
\fBINITIALLY IMMEDIATE\fR
.TP
\fBINITIALLY DEFERRED\fR
 如果约束是可推迟的，那么这个子句声明检查约束的缺省时间。 如果约束是 INITIALLY IMMEDIATE， 那么每条语句之后就检查它。这个是缺省。如果约束是 INITIALLY DEFERRED，那么只有在事务结尾才检查它。 约束检查的时间可以用 SET CONSTRAINTS [\fBset_constraints\fR(7)] 命令修改。
.TP
\fBON COMMIT\fR
 我们可以用 ON COMMIT 控制临时表在事务块结尾的行为。这三个选项是：
.RS
.TP
\fBPRESERVE ROWS\fR
 在事务结尾不发生任何特定的动作。这是缺省行为。
.TP
\fBDELETE ROWS\fR
 临时表的所有行在每次事务结尾都被删除。实际上，在每次提交的时候都自动 \fBtruncate\fR(7)  。
.TP
\fBDROP\fR
 在当前事务块的结尾，临时表将被删除。
.RE
.PP
.SH "NOTES 注意"
.TP 0.2i
\(bu
 如果一个应用使用了 OID 标识表中的特定行，那么我们建议在该表的 oid 字段上创建一个唯一约束，以确保该表的 OID 即使在计数器重叠之后也是唯一的。如果你需要一个整个数据库范围的唯一标识， 那么就要避免假设 OID 是跨表唯一的，你可以用 tableoid 和行 OID 的组合来实现这个目的。 （将来的 PostgreSQL 很可能为每个表使用独立的 OID 计数器， 因此包括 tableoid 组成数据库范围内的唯一标识将是必须的，而不是可选的。）
.sp
.RS
.B "提示:" 
对那些没有主键的表，我们不建议使用 WITHOUT OIDS， 因为如果既没有 OID 又没有唯一数据键字，那么就很难标识特定的行。
.RE
.sp
.TP 0.2i
\(bu
PostgreSQL 自动为每个唯一约束和主键约束创建一个索引以确保唯一性。 因此，我们不必为主键字段创建明确的索引。（参阅 CREATE INDEX [\fBcreate_index\fR(7)]获取更多信息。）
.TP 0.2i
\(bu
 唯一约束和主键在目前的实现里是不能继承的。 这样，如果把继承和唯一约束组合在一起会导致无法运转。
.SH "EXAMPLES 例子"
.PP