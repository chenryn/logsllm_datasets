We designed two scanning modes: a full mode that scans
for all patterns in Oyster’s virus database and a regu-
lar mode that scans for regular patterns only. We also
designed two user-oriented forensic modes for differ-
ent classes of users and sites of deployment. These two
forensic modes are called Immediate and Deferred. Avfs
can be mounted with any combination of scanning and
forensic modes using mount-time options. We describe
the two scan modes in Section 4.2.1 and the forensic
modes in Section 4.2.2
4.2.1 Scan Modes
Regular and multi-part (polymorphic) patterns are ex-
plained in detail in Section 3.1.
In full mode, Oyster
scans input for all the patterns (regular and multi-part)
in the database, making use of its full trie structure.
Scanning multi-part patterns can be expensive in terms
of speed because they can span several pages of a ﬁle.
Writes to random locations in a ﬁle can cause repetitive
scanning of the whole ﬁle. In regular mode, Oyster scans
input only for regular patterns. The full mode is accurate
in the sense that it scans the input for all patterns (in-
cluding multi-part patterns using their virus deﬁnitions)
in the database. The regular mode trades-off accuracy
for speed by scanning only for regular patterns.
The semantics of the full mode are different for un-
known and clean ﬁles. For unknown ﬁles during se-
quential reads, we always have state at the end of the
previous page and as we progress toward the end of the
ﬁle it gets gradually scanned and ﬁnally is marked clean.
If we have random reads from different parts of the ﬁle,
we adopt a different strategy. Random reads ahead of
the current scanned page trigger a scan of the intermedi-
ate pages. For random reads before the current scanned
page, we simply ignore scanning because that part of the
ﬁle has already been scanned.
Sequential writes are dealt with in the same way
as sequential reads, but the case of random writes is
slightly different. Multi-part patterns of the form P =
fp1; p2; p3; ::: ; png are hard to detect because we could
have the following scenario. Consider a multi-part pat-
tern P = fp1; p2; p3g and an empty ﬁle. The ﬁrst write
could produce p2 on page 2. Our scanner would scan the
ﬁle until the end of page 2 and ﬁnd that the ﬁle is clean.
The next write could be p3 on page 3. The ﬁnal write
of p1 to page 1 would complete the whole virus in the
ﬁle. To avoid this, the state maintained after the write to
page 3 should be invalidated during the write to page 1
and the whole ﬁle should be scanned to detect the virus.
We implemented this technique which scans the
whole ﬁle for multi-part patterns using the multi-part
trie structure of Oyster on every random write, but it
proved to be inefﬁcient because some programs like ld
write randomly around the two ends of the ﬁle and hence
cause a number of rescans over the entire length of the
ﬁle. Our current implementation, therefore, has a full-
scan-on-close ﬂag on the ﬁle’s inode which, when set,
causes the ﬁle to be scanned completely for multi-part
viruses when the ﬁle is closed. This ﬂag is set if there are
random writes before the current scanned page, and the
page is scanned only for regular patterns using a cush-
ioned scan implementation. A cushioned scan works
by extending the concerned page with sufﬁciently large
buffers of data on either side to guarantee that patterns
are detected across page boundaries. The size of a cush-
ion buffer is equal to the length of the longest pattern
available in Oyster’s database (currently 2,467 charac-
ters). A cushioned scan is shown in Figure 9.
Maximum pattern length − 1
cushion
current page
cushion
Page 1
Page 2
Page 3
Page n
Total scan for page 2
Figure 9: A cushioned scan implementation for viruses
spread across page boundaries
We have a conﬁgurable parameter max-jump that de-
cides when the full-scan-on-close ﬂag should be set.
Forward random writes to pages within max-jump from
the current scanned page cause intermediate pages to
be scanned for all viruses, but forward writes to pages
greater than max-jump cause only the regular patterns to
be scanned for, and the full-scan-on-close ﬂag is set. If
this ﬂag is set, access to the ﬁle is denied for all other
processes except the current process performing the ran-
dom writes. When the ﬁle is closed, the state is stored
persistently in the ﬁle’s state ﬁle. If the state indicates
that the last page was scanned, the ﬁle is safely marked
clean; otherwise, the state represents the last scanned
page of the ﬁle.
After a ﬁle is marked clean, new reads do not result in
additional scans. Appends to a clean ﬁle are dealt with
in the same way as sequential writes for unknown ﬁles
(ﬁles that are not marked clean). Writes to the middle
of the ﬁle are handled in a similar fashion as writes to
unknown ﬁles.
The regular mode is almost identical to the full mode
except that it scans the input only for regular patterns.
Reads to unknown or clean ﬁles, as well as sequential
writes, are treated in the same way as in full mode. Ran-
dom writes past the current scanned page force scan-
ning of intermediate pages, and backward writes use
cushioned scanning. The value of the maximum pat-
tern length is currently less than a page size, so cush-
ioned scanning adds a maximum overhead of scanning
one page on either side. This overhead is less than in full
mode because in full mode we have to scan the entire ﬁle
to detect multi-part viruses. For large ﬁles, full mode is
slower than the regular mode. Regular mode is useful
in cases where random read and write performance is
important. Full mode should be used when detection of
multi-part patterns is required.
4.2.2 Forensic Modes
If a process writes a virus into the ﬁle system, the pro-
cess should be notiﬁed of this behavior as early as pos-
sible. Also, if a process is reading from an infected
ﬁle, then the read must not succeed. These requirements
motivated the development of an immediate mode that
would not let viruses to be written to disk and return an
error to the process so that it can take remedial action.
Immediate mode is especially suited to a single-user en-
vironment where protection from viruses is the prime
requirement.
In addition to the immediate mode, we developed an-
other mode called the deferred mode which defers the
error notiﬁcation and records malicious activity. Such a
mode is suitable for large enterprise servers where sev-
eral users access data concurrently. In addition to on-
access virus protection, this mode provides (1) data con-
sistency by backing up ﬁles, and (2) a mechanism to
trace processes that attempt to write viruses into the ﬁle
system. We keep evidence such as process information,
time of attack, and infected ﬁles, so that the incident can
be investigated later.
When Avfs is mounted over an existing ﬁle system,
it is possible for the underlying ﬁle system to already
contain some virus-infected ﬁles. Such existing virus-
infected ﬁles are detected during reads from the ﬁle.
In this case, the ﬁle is quarantined, so that no process
could access it. Another possibility of a virus infection
is through a process that tries to write a virus into the ﬁle
system. In the immediate mode, these writes are trapped
in the Avfs layer itself and are not allowed to propagate
to the lower ﬁle system. Permission for such a write is
denied and the offending process is immediately noti-
ﬁed of the corresponding error. The ﬁle remains con-
sistent up to the last successful write to the ﬁle. The
ﬁle, however, may have multi-part viruses or viruses that
span over page-boundaries. A multi-part virus is not
detected until all of its parts are discovered in the cor-
rect sequence in a ﬁle. At the same time, a ﬁle cannot
be called clean if it contains even one part of a multi-
part virus. Hence, if most parts of a multi-part virus are
written and the virus is detected on writing the last part,
the ﬁle could still be corrupted due to the previous virus
parts. If a regular virus spans across page boundaries,
only the last write to the page that completes the virus is
denied.
Deferred mode operates in the same way as immedi-
ate mode for existing virus-infected ﬁles. These ﬁles are
simply quarantined and access to them is denied. At-
tempts to write viruses, however, are treated differently.
Files can have multiple instances open simultaneously.
An open on a ﬁle causes an instance to be created and
a close on that instance causes the instance to termi-
nate. We deﬁne a session to be the duration between the
ﬁrst open of the ﬁle and the last close of the ﬁle. We
back up a ﬁle during the ﬁrst write of a session. We keep
this backup in case a virus is created in the course of this
session. In such a situation, we revert to the backup and
restore the ﬁle to a consistent state. Here, we have only
one version of the ﬁle which prevents us from reverting
to versions more than one session old. If some parts of
a multi-part virus are written over several sessions, we
cannot revert to totally clean versions (without any part
of the virus) because we cannot detect such a virus un-
til all its parts are written. With multiple ﬁle versions,
however, this problem is easily solved.
When an attempt to write a virus is detected, we
record the time of the event and the process identiﬁer
(PID) of the offending process. We do not return an er-
ror immediately to the process. Instead, we lead it to
believe that the write was successful and allow it to pro-
ceed writing. However, we prevent read access to the ﬁle
for the offending process, so that it cannot read the virus
it had written. In addition to that, we also deny all ac-
cess (read, write, open) to the ﬁle for all other processes.
On close of the session, we rename the infected ﬁle to
a new name with the recorded PID and time stamp as
an evidence of the offense. Then, we rename the saved
backup to the original name so that data-consistency is
ensured. The saved evidence ﬁle can be used to launch
an investigation into the incident.
5 Related Work
There are several anti-virus systems available today.
Most of these systems are commercial products: Syman-
tec’s Norton Antivirus [18], McAfee Virusscan [13],
Sophos [17], Anti-Virus by Kaspersky Lab [9], Com-
puter Associates’s eTrust [4], and others. To protect
trade secrets, little information is released about their
internals. Their development is closed, and there is no
opportunity for peer review. Although the internals of
these products are trade secrets, advertised information
and white papers suggest their general structure. Most
of the commercial scanners detect viruses using virus
signature databases. These scanners boast large virus
databases ranging anywhere from 65,000 to 120,000 pat-
terns, which have been built over long periods. They also
use heuristic engines for scanning. The heuristic engines
eliminate ﬁles that cannot contain viruses, and scan only
the suspicious ones. Such heuristics typically include
identifying executable ﬁle types, appropriate ﬁle sizes,
and scanning only certain regions of ﬁles for viruses.
Some commercial scanners offer real-time virus pro-
tection. Real-time protection involves scanning ﬁles for
viruses when they are used. This is done by intercepting
the open, close, or exec system calls and scanning
entire ﬁles when these system calls are invoked. Scan-
ning during an open system call detects a virus only if
the ﬁle is already infected. If a virus is not present dur-
ing the open, but is written into the ﬁle after the open
operation, on-open scanning does not detect it. This
is the reason most real-time scanners scan for viruses
on close of the ﬁle as well. This scheme has three
drawbacks. First, viruses can be detected only after they
have been written to the ﬁle.
If the ﬁle cannot be re-
paired, critical data cannot be restored. Second, multi-
ple processes can access a virus in a ﬁle before the ﬁle
is scanned during close. Third, scanning ﬁles on both
open and close results in scanning them twice.
ClamAV [11] is a open-source system which forms
the basis of our scanning engine. ClamAV maintains an
up-to-date virus-deﬁnition database; it has been adopted
as the primary virus-scanner in many organizations and
is the basis for several open-source projects.
Dazuko is a kernel module that provides third-party
applications an interface for ﬁle access control [6].
Dazuko was originally developed by H+BEDV Daten-
technik GmbH, but has been released as free software
to encourage development and to enable users to com-
pile the module into their custom kernels. Dazuko in-
tercepts the open, close, and exec system calls.
It passes control to virus-scanners during these system
calls to perform on-access (on-open, on-close, on-
exec) virus scanning. Clamuko [11] (the on-access
scanner from ClamAV) and H+BEDV [7] are two virus
scanners that use Dazuko. One disadvantage of us-
ing systems like Dazuko is that its kernel module has
to communicate with user-level virus scanners, slowing
performance. Sockets or devices are used for communi-
cation, so data also has to traverse protocol layers. Fi-
nally, data-copies have to be performed between the ker-
nel and the user-level.
The Internet Content Adaptation Protocol (ICAP)
[8] is a protocol designed to off-load speciﬁc Internet-
based content to dedicated servers, thereby freeing up
resources and standardizing the way features are imple-
mented. ICAP servers focus on providing speciﬁc func-
tionality such as spam ﬁltering or virus scanning. The
downside of this scheme is performance: data is trans-
fered over the network to the virus-scanning server.
6 Evaluation
We evaluated the performance of Avfs under a variety of
system conditions by comparing it to other commercial
and open-source anti-virus systems.
All benchmarks were performed on Red Hat Linux
9 with a vanilla 2.4.22 kernel running on a 1.7GHz Pen-
tium 4 processor with 1GB of RAM. A 20GB 7200 RPM
Western Digital Caviar IDE disk was used for all the ex-
periments. To ensure cold-cache results, we unmounted
the ﬁle systems on which the experiments were con-
ducted between successive runs. To reduce I/O effects
due to ZCAV, we located the tests on a partition toward
the outside of the disk that was just large enough for the
test data [5]. We recorded the elapsed, system, and user
times for all tests. We computed the wait time, which
is the elapsed time minus the CPU and user times used.
Wait time is primarily due to I/O, but other factors such
as scheduling can affect it. Each test was run at least
10 times. We used the Student-t distribution to compute
95% conﬁdence intervals for the mean elapsed, system,
and user times. In each case the half-widths of the conﬁ-
dence intervals were less than 5% of the mean. The user
time is not affected by Avfs because only the kernel is
changed; therefore we do not discuss user time results.
In Section 6.1 we describe the conﬁgurations used for
Avfs. Section 6.2 describes the workloads we used to
exercise Avfs. We describe the properties of our virus
database in Section 6.3. In Section 6.4 we present the
results from an Am-Utils compile. Section 6.5 presents
the results of Postmark. Finally, in Section 6.6 we com-
pare our scanning engine to others.
6.1 Conﬁgurations
We used all the combinations of our scanning modes and
forensic modes for evaluating Avfs.
We used two scanning modes:
FULL: Scan for all patterns including multi-part ones.
REGULAR: Scan only for regular patterns.
Each scanning mode was tested with both of our
forensic modes:
IMMEDIATE: This mode returns an error to the process
immediately and does not allow malicious writes to
reach the disk.
DEFERRED: This mode backs up a ﬁle so it can be
restored to a consistent state after an infection and
provide information to trace malicious activity.
We used the default trie minimum height of three and
maximum of three for all tests, unless otherwise men-
tioned. A minimum height of three gave us the best
performance for all databases and a maximum height of
three gave us the best performance for databases of small
sizes like 1K, 2K, 4K and 8K patterns. We show later, in
Section 6.4, how the maximum height parameter can be
tuned to improve performance for large databases.
For commercial anti-virus products that support on-
access scanning, we ran the Am-Utils compile and the
Postmark benchmarks. Clamuko and H+BEDV are in
this category. Sophos and some other commercial virus
scanners do not support on-access scanning trivially, so
we compared the performance of our scanning engine to
these on large ﬁles using command line utilities.
6.2 Workloads
We ran three types of benchmarks on our system: a
CPU-intensive benchmark, an I/O intensive one, and one
that compares our scanning engine with anti-virus prod-
ucts that do not support on-access scanning.
The ﬁrst workload was a build of Am-Utils [14]. We
used Am-Utils 6.1b3: it contains over 60,000 lines of C
code in 430 ﬁles. The build process begins by running
several hundred small conﬁguration tests to detect sys-
tem features. It then builds a shared library, ten binaries,
four scripts, and documentation: a total of 152 new ﬁles
and 19 new directories. Though the Am-Utils compile
is CPU intensive, it contains a fair mix of ﬁle system
operations, which result in the creation of several ﬁles
and random read and write operations on them. For each
ﬁle, a state ﬁle is created and backups of ﬁles are cre-
ated in the deferred forensic mode. These operations of
the Am-Utils benchmark sufﬁciently exercise Avfs. We
ran this benchmark with all four combinations of scan-
ning and forensic modes that we support. This work-
load demonstrates the performance impact a user might
see when using Avfs under a normal workload. For this
benchmark, 25% of the operations are writes, 22% are
lseek operations, 20.5% are reads, 10% are open op-
erations, 10% are close operations, and the remaining
operations are a mix of readdir, lookup, etc.
The second workload we chose was Postmark [10].
Postmark simulates the operation of electronic mail
servers.
It performs a series of ﬁle system operations