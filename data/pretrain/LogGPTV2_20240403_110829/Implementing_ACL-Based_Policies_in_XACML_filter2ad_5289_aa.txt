title:Implementing ACL-Based Policies in XACML
author:G&quot;unter Karjoth and
Andreas Schade and
Els Van Herreweghen
2008 Annual Computer Security Applications Conference
2008 Annual Computer Security Applications Conference
Implementing ACL-based Policies in XACML
G¨unter Karjoth, Andreas Schade and Els Van Herreweghen
IBM Research
Zurich Research Laboratory
Abstract
XACML is commonly used as a policy exchange mecha-
nism, decision engines are available, and veriﬁcation tools
are under development. However, no support for legacy ac-
cess control systems exists yet. To explore the feasibility
to support legacy systems, we designed and implemented a
mapping of the IBM R(cid:13) Tivoli R(cid:13) Access Manager policy lan-
guage into XACML. Although the Tivoli Access Manager
policy language, being ACL-based, is simpler in general, it
turned out to be a non-trivial task to encode the interplay
of the Tivoli Access Manager policy elements and decision
logic within XACML. To achieve this task, we had to come
up with a novel use of XACML features.
1 Introduction
The
extensible access
control markup language
(XACML), an OASIS standard formally ratiﬁed in 2005,
deﬁnes both a policy language and an access control
decision request/response language, both given in XML
[6]. It also includes a high-level architecture deﬁning the
roles of and the data ﬂow between the entities involved
to make an authorization decision. Authorizations are
expressed in form of positive or negative rules, possibly
subject to a condition. Rules are combined into policies
and policies may be combined into policy sets. Several
combining algorithms exist
to aggregate the individual
results yielded by rules, policies, or policy sets. These
composition operators express logical operations on the
results, supporting federated administration of policies on
shared resources.
Recently XACML has received considerable attention
from academia as well as from industry. At Burton Group’s
2007 Catalyst Conference North America1, eight XACML
vendors showed fundamental interoperability in two usage
scenarios: policy exchange and authorization decision pro-
cessing.
1http://www.oasis-open.org/news/
xacml-interop-2007-press-release.pdf
1063-9527/08 $25.00 © 2008 IEEE
1063-9527/08 $25.00 © 2008 IEEE
DOI 10.1109/ACSAC.2008.31
DOI 10.1109/ACSAC.2008.31
173
183
Whereas interest in and adoption of XACML continues
to increase across the industry, not all application areas of
XACML are yet clearly identiﬁed. XACML as a policy ex-
change mechanism is already commonly used. Decision
engines are currently developed [10] but XACML policy
editing tools are missing. A number of tools, Margrave
[4] for example, have been developed for the veriﬁcation
of XACML policies. In [14], XACML policies are derived
from business process models. However, to gain wide mar-
ket penetration, XACML has also to support existing legacy
access control systems; i.e., to show its platform indepen-
dence. To manage access control policies of heterogeneous
computing environment centrally, there is the need to im-
port (translate) these policies into XACML. Whereas sev-
eral translations of XACML into other formats exist, mainly
for veriﬁcation purposes, to the best of our knowledge there
is no work in the other direction with the exception of trans-
lating Java R(cid:13) PolicyFile policies into XACML [1].
IBM Tivoli Access Manager (AM) is a system for (1)
centrally managing policy to govern access to resources
over geographically dispersed intranets and extranets and
(2) providing authorization services to applications [8]. Ap-
plications that are part of the Tivoli Access Manager family
include WebSEAL (for Internet resources), Access Man-
ager for Business Integration (for MQSeries queues and
applications), and Access Manager for Operating Systems
(for system resources). Third-party applications can use
Tivoli Access Manager’s authorization service by calling its
standard-based Authorization API [13].
AM performs authorization checks (i.e., access control
decisions) on protected URL-addressable objects, including
“dynamic URLs” generated by applications, based on the
user’s credentials. Policies are deﬁned over an object space.
ACL inheritance allows to manage these policies efﬁciently.
Access control lists (ACLs) attached to resources assign
permissions to users and groups and control their reach-
ability. Predeﬁned or customer-deﬁned conditions, called
protected object policies (POPs) respectively authorization
rules (ARules), may further restrict access or give additional
instructions to the resource manager.
To study the feasibility to support such legacy systems,
we designed and implemented a mapping of the AM pol-
icy language into XACML. Although AM’s language, being
ACL-based, is simpler in general, it turned out to be a non-
trivial task to encode the interplay of AM’s data structure
and decision logic within XACML. To achieve this task, we
had to come up with a novel use of XACML features. An
AM policy and an XACML policy are equivalent if for a
given query both decision engines return the same result.
As opposed to AM’s ability to support multiple actions per
query, queries have to be restricted to only contain a sin-
gle action as prescribed by the XACML model for deci-
sion evaluation. The described XACML mapping covers
the full range of Tivoli Access Manager policies provided
that XACML condition expressions exist as counterparts for
all authorization rules.
In the remainder of this paper, we brieﬂy describe the
Tivoli Access Manager authorization model in Section 2
and that of XACML in Section 3.
In Section 4, we out-
line the encoding of the AM policy elements ACL, POP
and ARule. The complete translation algorithm is given in
Section 5, where we show how we have captured the spe-
cial effects of permission inheritance and accessibility. Sec-
tion 6 describes the implementation of the AM to XACML
translator and discusses software requirements to support
general XACML policies. We conclude in Section 7.
2 Tivoli Access Manager Policy Semantics
In this section, we describe the part of AM, which is rele-
vant for the translation into XACML. A detailed and formal
description of Tivoli Access Manager’s underlying access
control model is given in [8].
Figure 1. Object space populated with ACLs,
POPs, and ARule.
To control access, AM deploys access control
lists
(ACL), protected object policies (POP), and authorization
rules (ARule). An ACL grants authorizations to subjects,
174184
which are single users or groups. Groups are sets of indi-
vidual users and cannot be nested but a user may belong
to several groups. Besides users and groups, there are two
additional ACL entries: any-other matches any authen-
ticated user and unauthenticated matches any unau-
thenticated user. A POP is a set of predeﬁned conditions
evaluated on attribute-value pairs. POPs impose restrictions
on the request or denote information to be passed back to the
calling resource manager. For example, a POP may limit
access to a speciﬁc time period or may instruct the resource
manager to enforce a certain audit level.
Objects are denoted by strings whose syntax and struc-
ture are similar to absolute ﬁlenames in a hierarchical ﬁle
system. The slash character (‘/’) is used to delimit, from
left to right, hierarchical components of the object’s name.
Thus, the strings /Mgmt and /Mgmt/Manuals are exam-
ples of object names given in Figure 1. AM’s object space
is open; i.e., any object without a speciﬁc policy is subject
to the policy attached to its nearest ancestor in the object
hierarchy.
Tivoli Access Manager gathers resources that require
protection along with the associated policy into a domain.
Resources within a domain are represented by objects that
span a hierarchical portrayal of its members called protected
object space. In Fig. 1, the object space is given as a tree.
To control access, ACLs, POPs, and authorization rules are
attached to objects. If an object does not have an ACL, POP,
or ARule explicity attached then it inherits that policy from
an object higher up in the hierarchy. A policy attached to an
object deﬁnes a region; that object is called container object.
A region is a subtree whose root is the the container object
together with all descendents that do not have a policy at-
tached to themselves. For example, the region deﬁned by
ACL1 consists of the objects /, /Mgmt, /Departments
and /Departments/Docs (see the dashed polygon in
Fig. 1).
An object within a region is accessible if either it is the
container object of that region or the user (explicitly or im-
plicitly) has the Traverse right on the container object. An
object is accessible if all regions on the path from the root
to this object are accessible. Thus, in checking for a pri-
mary authorization corresponding to an access query for an
object, Traverse authorizations on parent objects must be
checked as auxiliary (or secondary) authorizations.
In summary, to determine whether an access request
is permitted, Tivoli Access Manager checks whether (1)
the ACL of the container node grants the required permis-
sion(s), (2) all regions on the path to the root are accessible
(the Traverse permission is granted), and (3) evaluates the
POP, and (4) the ARule. If any of the ACL, POP, or ARule
evaluation fails, the request is denied access. For example,
the object /Departments/Code/Tiger is controlled
by two ACLs and one POP. Access is granted if the region
/Mgmt//Departments/Mgmt/Manuals/Departments/Code/Departments/Code/TigerACL3ACL2POP2AuthRule1ACL1POP1/Departments/Docsspawned by ACL ACL1 is accessible, ACL ACL2 grants
the necessary permission, and the evaluation of POP POP2
does not fail.
3 XACML Policies
Each XACML policy contains exactly one Policy or Pol-
icySet root XML element. A PolicySet is a container that
can hold other Policies or PolicySets, as well as references
to policies found in remote locations. A Policy represents
a single access control policy, expressed through a set of
Rules with Permit or Deny effect. A Policy or PolicySet
may hence contain multiple policies or rules, each of which
may evaluate to different access control decisions. There-
fore, XACML has a collection of Combining Algorithms to
reconcile the decisions made by these rules. Each algorithm
represents a different way of combining multiple decisions
into a single result. There are Policy Combining Algorithms
(used by PolicySet) and Rule Combining Algorithms (used
by Policy). An example of these is the Deny Overrides al-
gorithm, which says that no matter what, if any evaluation
returns Deny, or no evaluation permits, then the ﬁnal re-
sult is also Deny. Thus, this combiner can be regarded as a
logical conjunction of permits. There are seven Combining
Algorithms to build up increasingly complex policies.
A Target
is basically a set of simpliﬁed conditions
for Subject, Resource and Action. These conditions use
boolean functions to compare values found in a request with
those included in the Target. If all the conditions of a Target
are satisﬁed, then its associated PolicySet, Policy, or Rule
applies to the request.
Once a Policy has been found and veriﬁed to apply to a
given request, its Rules are evaluated. Rules have an Effect
– a value of Permit or Deny that is associated with success-
ful evaluation of the Rule. Rules may also have a condition.
If this condition evaluates to true then the Rule’s Effect is
returned. Evaluation of a Condition can also result in an er-
ror (Indeterminate) or discovery that the Condition doesn’t
apply to the request (NotApplicable). Conditions can be
quite complex, built from an arbitrary nesting of functions
and attributes.
Attributes are named values of known types that may in-
clude an issuer identiﬁer or an issue date and time. Speciﬁ-
cally, attributes are characteristics of the Subject, Resource,
Action, or Environment in which the access request is made.
A user’s name, its security clearance, the ﬁle the user want
to access, and the time of day are all attribute values. When
a request is sent from a Policy Enforcement Point (PEP) to
a Policy Decision Point (PDP), that request is formed al-
most exclusively of attributes, and their actual values will
be compared to attribute values in a policy to make the ac-
cess decisions.
In summary, authorizations are expressed in XACML by
access rules which specify the subject, resource and action
elements of an authorization. These elements may deﬁne
the applicable subjects, resources, and actions speciﬁcally,
or may be wildcard elements, which match all speciﬁc el-
ements in the corresponding category. For example, a rule
expressing authorization of a user Alice to read a data object
“Manuals” can be deﬁned by (using some simpliﬁcations in
the XML syntax):
Groups of Rules can be combined via logical algorithms
into Policies, and groups of policies can be similarly com-
bined into Policy sets. Thus, the overall access control pol-
icy data structure in XACML typically comprises multiple
Policy sets, each specifying the logical algorithms to be ap-
plied by the decision logic to Policies, and, within those
Policies, Rules, which apply to particular combinations of
subject/resource/action elements. In operation, the decision
logic compares the subject/resource/action triple in an ac-
cess query to the targets in the data structure to identify the
applicable policy sets, policies and rules, and then evaluates
these accordingly. This evaluation yields a permit or deny
decision in response to the access request.
4 Translating Tivoli Access Manager Policy
Elements
In Tivoli Access Manager (AM), accessibility of a re-
source depends on the permissions assigned by the ACL
controlling the region of the resource, the reachability of
that region, a protected object policy, and an authorization
rule. In particular, the AM access decision function grants
the request of a user to perform a given action on a given
resource if all of the following conditions are fulﬁlled:
1. the user has the required permissions on the resource
as determined by the user’s permissions according to
the ACL applying to the resource itself;
2. the user can access the resource’s region, as deter-
mined by Traverse permissions in the ACLs applying
to the nodes between the resource and the root;
3. all the conditions as expressed in the POP applying to
the resource are fulﬁlled;
4. all the authorization rules applying to the resource
evaluate to true.
175185
In the remainder of this section, we explain in detail the
structure of the above AM policy elements, how they are
interpreted by the AM access decision function, and how
they can be expressed in XACML.
Figure 2. Structure of a Resource policy.
Having an XACML policy for each of the above items,
the overall policy for a particular resource can be modeled
by an XACML PolicySet that combines the four subpolicies
in a deny-overrides mode (see Figure 2). This policy
set contains a target that matches the particular resource be-
ing modeled.
4.1 Access Control Lists
AM grants authorizations to subjects, which are either
single users or ﬂat groups of users. The ACL applying
to a resource determines the permissions of a user (au-
thenticated or unauthenticated, with possible group mem-
berships) to perform certain actions on that resource. An
ACL has four entry types: user entries, group entries, and
the special entries any-other and unauthenticated.
The any-other entry contains default permissions of all
authenticated users while the unauthenticated entry
contains the permissions of unauthenticated users. The
ACL shown in Figure 3 gives, for example, user Alice the
read (r) and write (w) permission, whereas user Bob has
just the read permission. The absence of a permission is
indicated by the symbol ’-’. Note that the Traverse (T)
permission is only assigned to entries any-other and
unauthenticated; its particular importance to control
accessibility of nodes in the object space is described in
Section 4.2.
user Alice
user Bob
group Admin
group Physician
any-other
unauthenticated
-rw
-r-
--w
-r-
Tr-
T--
Figure 3. Content of ACL ACL3.
For a given client, determined by its user identiﬁer and
a possibly empty set of group identiﬁers, the set of permis-
176186
sions granted by a speciﬁc ACL is determined by perform-
ing a sequence of attempted matches against ACL entry
types. First, it checks whether the user identiﬁer matches
one of the ACL’s user entries.
If so, it returns the asso-
ciated set of permissions. Otherwise, if any of the user’s
group credentials match any of the ACL’s group entries,
the algorithm returns the union of all permissions the user