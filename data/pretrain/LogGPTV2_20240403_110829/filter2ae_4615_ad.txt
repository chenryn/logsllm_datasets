### 结构与内存布局

以下展示了特定结构的内存布局：

- **+0x100 Header**: [2] _M128A
- **+0x120 Legacy**: [8] _M128A
- **+0x1a0 Xmm0** to **+0x290 Xmm15**: _M128A (每个XMM寄存器)
- **+0x300 VectorRegister**: [26] _M128A
- **+0x4a0 VectorControl**: 0x410041`00410041
- **+0x4a8 DebugControl**: 0x410041`00410041
- **+0x4b0 LastBranchToRip**: 0x410041`00410041
- **+0x4b8 LastBranchFromRip**: 0x410041`00410041
- **+0x4c0 LastExceptionToRip**: 0x410041`00410041
- **+0x4c8 LastExceptionFromRip**: 0x410041`00410041

### 汇编代码分析

在 `kernel32!WinExec` 函数中，以下是相关汇编指令及其功能：

```assembly
00000000`76c38d50 488bc4          mov     rax, rsp
00000000`76c38d53 48895808        mov     qword ptr [rax + 8], rbx
00000000`76c38d57 55              push    rbp
00000000`76c38d58 56              push    rsi
00000000`76c38d59 57              push    rdi
00000000`76c38d5a 4881ec10010000  sub     rsp, 110h
00000000`76c38d61 0fbae21f        bt      edx, 1Fh
00000000`76c38d65 8bf2            mov     esi, edx
```

### 命令行参数

`rcx` 寄存器包含 `WinExec` 的命令行参数：

```plaintext
00000000`0039e9c4  575c3a43 6f646e69 535c7377 65747379  C:\Windows\Syste
00000000`0039e9d4  5c32336d 636c6163 6578652e 00000000  m32\calc.exe....
00000000`0039e9e4  00000069 00000002 00000069 000942a2  i.......i....B..
00000000`0039e9f4  00000008 00790074 00650070 00000000  ....t.y.p.e.....
00000000`0039ea04  a9cc59f8 0000001a 0062006f 005f006a  .Y......o.b.j._.
00000000`0039ea14  00740070 005f0072 006f006c 00650077  p.t.r._.l.o.w.e.
00000000`0039ea24  00000072 a9d7dd8b 0000001a 0062006f  r...........o.b.
00000000`0039ea34  005f006a 00740070 005f0072 00700075  j._.p.t.r._.u.p.
```

### 栈内存泄漏

泄露的 native stack 地址如下：

```plaintext
0:013> dps 0x53884e0 l50
00000000`053884e0  00000000`00001f80
00000000`053884e8  000007fe`fd1a24c8 msvcrt!control87+0x28
00000000`053884f0  00000000`05388580
00000000`053884f8  000007fe`f00d9315 jscript!TLS_NoDestructor::Close+0x59
...
00000000`053886f8  00000000`0039f638
00000000`05388700  00000000`00001f80
00000000`05388708  00000000`003080b0
00000000`05388710  00000000`00000080
00000000`05388718  00000000`0037a480
00000000`05388720  00000000`00000000
00000000`05388728  00000000`053886f0
00000000`05388730  00000000`003797a0
00000000`05388738  00000000`05388e40
00000000`05388740  00000000`1039c228
00000000`05388748  000007fe`f00aabe8 jscript!NameList::FCreateVval+0xd8
00000000`05388750  00008687`1cf8f2fd
00000000`05388758  00000000`05389660
```

### 漏洞利用总结

通过上述分析，我们可以得出以下结论：

- 该漏洞利用代码展示了如何将 JScript 中的 UAF（Use After Free）漏洞转化为 RCE（远程代码执行）。这表明 JScript 模块中的类似 UAF 漏洞都可以通过这种方法实现 RCE。
- 该利用代码由国外安全研究员编写，虽然与最初的在野 0day 利用代码不同，但更具可读性。其利用过程与前几年广泛讨论的 VBScript 漏洞相似，都是通过类型混淆来实现。
- 随着 JScript 中 UAF 漏洞的逐渐发现，在 JScript 被加入 Office Moniker 黑名单之前，攻击者可能会青睐这种通过 Office 加载 JScript 漏洞的方式，因为这种方式无需配合提权漏洞。

### 参考资料

- Garbage Collection Internals of JScript
- CVE-2018-8353 漏洞分析笔记
- CVE-2017-11906 && CVE-2017-11907 组合漏洞分析笔记
- 利用 WPAD/PAC 与 JScript 实现 Windows 10 远程代码执行
- aPAColypse now: Exploiting Windows 10 in a Local Network with WPAD/PAC and JScript