'\" t
.\" Don't change the first line, it tells man that we need tbl.
.\" This man page is Copyright (C) 1999 Andi Kleen .
.\" and copyright (c) 1999 Matthew Wilcox. 
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.TH SOCKET  7 "7 May 1999" "Linux Man Page" "Linux Programmer's Manual" 
.SH NAME
socket \- Linux 套接字
.SH 总览
.B #include  
.br
.IB mysocket " = socket(int " socket_family ", int " socket_type ", int " protocol );
.SH 描述
本手册页介绍了 Linux 套接字的用户接口. 这个 BSD 兼容套接字是介于用
户进程与内核网络协议栈之间的统一接口, 各协议模块属于不同的
.I 协议族
,如
.BR PF_INET ", " PF_IPX ", " PF_PACKET
和
.I 套接字类型
,如
.B 字节流（SOCK_STREAM）
或
.BR 数据报（SOCK_DGRAM）.
关于协议族和套接字类型请参考
.BR socket (2) "."
.SH 套接层函数
用户通过这些套接字函数发送和接收包, 以及其他套接字操作.
详细说明参看他们各自的手册页.
.BR socket (2)
创建套接字，
.PP
.BR connect (2)
与远程套接字地址建立连接
.PP
.BR bind (2)
把套接字和一个本地套接字地址绑定在一起（为套接字分配一个本地协议地址）
.PP
.BR listen (2)
通知套接字接受新的连接
.PP
.BR accept (2)
为新的已完成连接获得新的描述字
.PP
.BR socketpair (2)
返回两个连接的匿名套接字（仅在某些本地族中才有实现,如
.BR PF_UNIX "）"
.PP
.BR send (2),
.PP
.BR sendto (2),
和
.BR sendmsg (2)
通过套接字发送数据，而
.BR recv (2),
.BR recvfrom (2),
.BR recvmsg (2)
从套接字接收数据.
.BR poll (2)
和
.PP
.BR select (2)
等待数据到来或准备好接收数据. 除此之外, 标准 I/O 操作如
.BR write (2),
.BR writev (2),
.BR sendfile (2),
.BR read (2),
和
.BR readv (2) 
也可用来读入（接收）和写出（发送）数据.
.PP
.BR getsockname (2)
用于获得本地套接字地址
.PP
.BR getpeername (2)
用于获得远端套接字地址.
.BR getsockopt (2)
和
.BR setsockopt (2)
用于设置或取得套接字或协议选项. 
.BR ioctl (2)
也可以用来设置或读取一些其他选项.
.PP
.BR close (2)
关闭套接字.
.BR shutdown (2)
关闭全双工套接字连接的一部分.
.PP
套接字不支持搜索，也不支持调用
.BR pread (2) 
或
.BR pwrite (2)
进行非 0 位置的操作.
可以用
.BR fcntl (2).
设置
.B O_NONBLOCK
标志来实现对套接字的非阻塞 I/O 操作
.B O_NONBLOCK
是从 accept 继承来的，然后原来所有会阻塞的操作会返回
.BR EAGAIN .
.BR connect (2) 
在此情况下返回
.B EINPROGRESS
错误.
用户可以通过
.BR poll (2)
或者
.BR select (2)
等待各种事件.
.PP
.TS
tab(:) allbox;
c s s
l l l.
I/O 事件
事件:轮询标志:发生事件
读:POLLIN:T{
新数据到达.
T}
读:POLLIN:T{
(对面向连接的套接字)建立连接成功
T}
读:POLLHUP:T{
另一端套接字发出断开连接请求.
T}
读:POLLHUP:T{
(仅对面向连接协议)套接字写的时候连接断开. 同时发送
.B SIGPIPE.
T}
写:POLLOUT:T{
套接字有充足的发送缓冲区用于写入新数据.
T}
读/写:T{
POLLIN|
.br
POLLOUT
T}:T{
发出的
.BR connect (2)
结束.
T}
读/写:POLLERR:产生一个异步错误.
读/写:POLLHUP:对方已经单向关闭连接.
例外:POLLPRI:T{
紧急数据到达.然后发送
.B SIGURG.
T}
.\" XXX not true currently
.\" It is no I/O event when the connection
.\" is broken from the local end using 
.\" .BR shutdown (2)
.\" or 
.\" .BR close (2)
.\" .
.TE
.PP
另外一个的 poll/select 方法是让内核用
.B SIGIO
信号来通知应用程序. 要这么用的话你必须用
.BR fcntl (2)
设置套接字文件描述符的
.B FASYNC
标志，并用
.BR sigaction (2).
给
.B SIGIO
信号设置一个的有效信号处理句柄.参看下面的
.I SIGNALS
的讨论.
.SH 套接字选项
套接字选项可以用
.BR setsockopt (2)
来设置，用
.BR getsockopt (2)
读取所有套接字级别设为
.B SOL_SOCKET 
的套接字的套接字选项:
.TP
.B SO_KEEPALIVE
允许在面向连接的套接字上发送 keep\-alive 消息的功能.是一个布尔整数.
.TP
.B SO_OOBINLINE
如果打开这个选项，带外（Out\-of\-Band）数据可以直接放入接收数据流。
否则，只有接收时打开
.B MSG_OOB 
标志, 才接收带外数据.
.\" don't document it because it can do too much harm.
.\".B SO_NO_CHECK
.TP
.BR SO_RCVLOWAT " 和 " SO_SNDLOWAT
声明在开始向协议
.RB ( SO_SNDLOWAT ) 
或正在接收数据的用户
.RB ( SO_RCVLOWAT ).
传递数据之前缓冲区内的最小字节数. 在 Linux 中这两个值是不可改变的,
固定为 1 字节.
可以用
.B getsockopt 
用来读取它们的值; 
.B setsockopt 
总是返回
.BR ENOPROTOOPT .  
.TP
.BR SO_RCVTIMEO " 和 " SO_SNDTIMEO
发送和接收时的超时设定, 并在超时时报错. 在 Linux 中由
协议指定, 不能被读写. 它们的功能可用
.BR alarm (2)
或者
.BR setitimer (2).
来模拟.
.TP
.B SO_BSDCOMPAT
允许 BSD 的 bug\-to\-bug 兼容. 这一项只能在 UDP 协议模块中使用而
且今后将要取消. 如果允许的话, UDP 套接字接收到的 ICMP 错误将不
会被传送至用户程序. Linux 2.0 中对于原始套接字也允许 BSD 
bug\-to\-bug 兼容（报头随机改变,省略广播标识）,但在 Linux 2.2
中取消了这一项. 修改用户程序的方式比较好.
.TP
.B SO_PASSCRED
允许或关闭
.B SCM_CREDENTIALS
控制消息的接收.
更多信息参见
.BR unix (7). 
.TP
.B SO_PEERCRED
返回连接至此套接字的外部进程的身份验证. 只在 
.B PF_UNIX 
套接字中有用.参见 
.BR unix (7). 
参数为
.B ucred 
结构.只在
.BR getsockopt .
中有效.
.TP
.B SO_BINDTODEVICE
将此套接字绑定到一个特定的设备上, 如\(lqeth0\(rq,
做为指定的接口名字传递. 如果名称是空字符串或此项长度为 0,
则套接字设备绑定被取消. 过去的选项是一个变长的空零结尾的
接口名称的字符串, 其最大长度为
.BR IFNAMSIZ . 
如果一个套接字被绑定至一接口,
只有由这个特定接口接收的信息包可以由此套接字处理.
.TP
.B SO_DEBUG 
允许套接字调试.只对有
.B CAP_NET_ADMIN