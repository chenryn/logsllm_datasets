看一下 `scalar_mul(G1Point point, uint s)` 函数签名，以 point 为生成元，计算
point+point+.....+point，一共 n 个 point 相加。这属于使用上面第二种方法表示循环群中的一个点。
在 Solidity 智能合约实现中需要使用 uint256 类型来编码Fq，但 uint256 类型的最大值是大于q 值，那么 会出现这样一种情况：在
uint256 中有多个数 经过 mod 运算之后都会对应到同一个Fq中的值。比如s和s +
q表示的其实是同一个点，即第s个点。这是因为在循环群中点q其实等价于 点0（每个点分别对应 0,1,2,3,....q-1）。同理，s +
2q等均对应到点s。我们把可以输入多个大整数会对应到同一个Fq中的值 这一现象称作“输入假名”，即这些数互为假名。
以太坊 7 号合约实现的椭圆曲线是y^2 = ax^3+bx+c。p 和 q 分别如下。
![
](https://images.seebug.org/content/images/2019/07/2e82f53e-d62e-4de9-991a-44d9c114d6cb.jpg-w331s)
这里的q值即上文中提到的群的阶数。那么在 uint256 类型范围内，共有 uint256_max / q个，算下来也就是最多会有 5 个整数代表同一个点（
5 个“输入假名”）。
这意味着什么呢？让我们回顾上面调用`scalar_mul(G1Point point, uint s)`的`verifyProof(a, b, c,
input)` 函数，`input[]` 数组里的每个元素实际就是 s。对于每个s，在 uint256 数据类型范围内，会最多存在其他 4
个值，传入后计算结果与原值一致。
因此，当用户向合约出示零知识证明进行提现后，合约会把input[1]（也就是某个s）放入作废列表。用户（或其他攻击者）还可以使用另外 4
个值再次进行证明提交。 **而这 4 个值之前并没有被列入“废弃列表”，因此“伪造”的证明可以顺利通过校验，利用 5 个“输入假名”一笔钱可以被重复花 5
次，而且攻击成本非常低！**
### 还有更多受影响的项目
存在问题的远远不止 semaphore 一个。其他很多以太坊混币项目以及 zkSNARKs 项目都存在同样的允许“输入假名”的问题。
这当中，影响最大的要数几个大名鼎鼎的 zkSNARKs 库或框架项目，包括 snarkjs、ethsnarks、ZoKrates
等。许多应用项目会直接引用或参考他们的代码进行开发，从而埋下安全隐患。因此，上述三个项目迅速进行了安全修复更新。另外，多个利用了 zkSNARKs
技术的知名混币项目，如 hopper、Heiswap、Miximus 也立刻进行了同步修复。 **这些项目在社区热度都十分高，其中 Heiswap
更是被人们称为 “Vitalik 最喜爱的项目”。**
### “输入假名”漏洞的解决方案
事实上，所有使用了该 zkSNARKs 密码学合约库的项目都应该立即开展自查，评估是否受影响。那么应该如何修复这个问题？
所幸的是，修复很简单。仅需在验证函数中添加对输入参数大小的校验，强制要求 input 值小于上面提到的 q
值。即严禁“输入假名”，杜绝使用多个数表示同一个点。
![
](https://images.seebug.org/content/images/2019/07/83e9f6f2-6669-47f2-b8e2-1a677790cad5.jpg-w331s)
### 暴露的深层问题值得反思
该“输入假名”导致的安全漏洞值得社区认真反思。我们再回顾一下整个故事。2017 年 Christian 在 Gist 网站贴出了自己的 zkSNARKs
合约计算实现。作为计算库，我们可以认为他的实现并没有安全问题，没有违反任何密码学常识，完美地完成了在合约中进行证明验证的工作。事实上，作为 Solidity
语言的发明者，Christian
在这里当然不会犯任何低级错误。而两年后的今天，这段代码却引发了如此的安全风波。两年多的时间内，可能有无数同行和专家看过或使用过这段只有两百多行的代码，却没有发现任何问题。
核心问题出在哪里？可能出在底层库的实现者和库的使用者双方间对于程序接口的理解出现了偏差。换句话说：底层库的实现者对于应用开发者的不当使用方式欠缺考虑；而上层应用开发者没有在使用中没有深入理解底层实现原理和注意事项，进行了错误的安全假设。
所幸的是，目前常见的 zkSNARKs 合约库都火速进行了更新，从底层库层面杜绝“输入假名”。
**安比（SECBIT）实验室认为，底层库的更新诚然能够很大程度上消除掉后续使用者的安全隐患，但若该问题的严重性没有得到广泛地宣传和传播，依旧会有开发者不幸使用到错误版本的代码，或者是根据错误的教程进行开发（就像因为整数溢出而归零的那些
Token 一样），从而埋下安全隐患。**
“输入假名”漏洞不禁让我们回想起此前频繁曝出的“整数溢出”漏洞。二者相似之处颇多：都是源于大量开发者的错误假设；都与 Solidity 里的 uint256
类型有关；波及面都十分广；网络上也都流传着很多存在隐患的教程代码或者库合约。但显然“输入假名”漏洞显然更难检测，潜伏时间更长，需要的背景知识更多（涉及到复杂的椭圆曲线和密码学理论）。安比（SECBIT）实验室认为，随着
zkSNARKs、零知识证明应用、隐私技术的兴起，社区会涌现出更多的新应用，而背后暗藏的更多安全威胁可能会进一步暴露出来。希望这波新技术浪潮中，社区能充分吸收以往的惨痛教训，重视安全问题。
### 参考文献
[1] 
[2]
[3] 
[4]
[5] 
* * *