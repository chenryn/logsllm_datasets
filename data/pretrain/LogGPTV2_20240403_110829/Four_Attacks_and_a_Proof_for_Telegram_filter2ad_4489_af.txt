kk â†$ {0, 1}672 ; mk â†$ {0, 1}320
auth_key_id â† HASH.Ev(hk, kk (cid:107) mk)
(kkI , kkR) â† ğœ™KDF(kk)
(mkI , mkR) â† ğœ™MAC(mk)
keyI â† (kkI , mkI)
keyR â† (kkR , mkR)
(stME,I , stME,R) â†$ ME.Init()
stI â† (auth_key_id, keyI , keyR , stME,I)
stR â† (auth_key_id, keyR , keyI , stME,R)
Return (stI , stR)
Figure 12: Construction of MTProto-based channel CH = MTP-CH[ME, HASH, MAC, KDF, ğœ™MAC, ğœ™KDF, SE] from message encoding
scheme ME, function families HASH, MAC and KDF, related-key-deriving functions ğœ™MAC and ğœ™KDF, and from deterministic
symmetric encryption scheme SE.
CH.Recv(stu, ğ‘, aux)
(auth_key_id, keyu
(kku, mku) â† keyu
(auth_key_id(cid:48), msg_key, ğ‘se) â† ğ‘
If auth_key_id â‰  auth_key_id(cid:48) then
Return (stu,âŠ¥)
ğ‘˜ â† KDF.Ev(kku, msg_key)
ğ‘ â† SE.Dec(ğ‘˜, ğ‘se)
msg_key(cid:48) â† MAC.Ev(mku, ğ‘)
If msg_key(cid:48) â‰  msg_key then return (stu,âŠ¥)
(stME, ğ‘š) â† ME.Decode(stME, ğ‘, aux)
stu â† (auth_key_id, keyu
, stME)
Return (stu, ğ‘š)
, stME) â† stu
, stME)
, keyu
, keyu
in Section IV-A does not appear in the code in Fig. 12, since
each part of auth_key that is used for keying the primitives
can be generated independently. These parts are denoted by
hk, kk and mk. The function ğœ™KDF (resp. ğœ™MAC) is then used
to derive the (related) keys for each user from kk (resp. mk).
CH.Send proceeds by ï¬rst using ME to encode a message
ğ‘š into a payload ğ‘. The MAC is computed on this payload to
produce a msg_key, and the KDF is called on the msg_key to
compute the key and IV for symmetric encryption SE, here
abstracted as ğ‘˜. The payload is encrypted with SE using this
key material, and the resulting ciphertext is called ğ‘se. The
CH ciphertext ğ‘ consists of auth_key_id, msg_key and the
symmetric ciphertext ğ‘se.
CH.Recv reverses the steps by ï¬rst computing ğ‘˜ from the
msg_key parsed from ğ‘, then decrypting ğ‘se to the payload
ğ‘, and recomputing the MAC of ğ‘ to check whether it equals
msg_key. If not, it returns âŠ¥ (without changing the state) to
signify failure. If the check passes, it uses ME to decode the
payload into a message ğ‘š. It is important the MAC check is
performed before ME.Decode is called, otherwise this opens
the channel to attacks â€“ as we show later in Section VI.
Deï¬nition 5. Let ME be a message encoding scheme. Let
HASH be a function family such that {0, 1}992 âŠ† HASH.In.
Let MAC be a function family such that ME.Out âŠ† MAC.In.
Let KDF be a function family such that {0, 1}MAC.ol âŠ†
KDF.In. Let ğœ™MAC : {0, 1}320 â†’ MAC.Keys Ã— MAC.Keys and
ğœ™KDF : {0, 1}672 â†’ KDF.Keys Ã— KDF.Keys. Let SE be a de-
terministic symmetric encryption scheme with SE.kl = KDF.ol
and SE.MS = ME.Out. Then CH = MTP-CH[ME, HASH, MAC,
KDF, ğœ™MAC, ğœ™KDF, SE] is the channel as deï¬ned in Fig. 12, with
CH.MS = ME.MS and CH.SendRS = ME.EncRS.
The message encoding scheme MTP-ME is speciï¬ed in
Deï¬nition 6 and Fig. 13. It is a simpliï¬ed scheme for strict
in-order delivery without replays (see the full version of this
work for the actual MTProto scheme that permits reordering).
As justiï¬ed in Section IV-C, MTP-ME follows the header format
of Table I, but it does not use the server_salt ï¬eld (we deï¬ne
salt as ï¬lled with zeros to preserve the ï¬eld order) and we
merge the 64-bit msg_id and 32-bit msg_seq_no ï¬elds into
a single 96-bit seq_no ï¬eld. Note that the internal counters
of MTP-ME wrap around when seq_no â€œoverï¬‚owsâ€ modulo
296, so MTP-ME can only provide encoding integrity against
adversaries that make at most 296 oracle Send queries.
Deï¬nition 6. Let session_id âˆˆ {0, 1}64 and pb, bl âˆˆ N.
Then ME = MTP-ME[session_id, pb, bl]
is the message-
ğ‘–=1{0, 1}8Â·ğ‘–,
encoding scheme given in Fig. 13, with ME.MS =224
ME.Out = ğ‘–âˆˆN{0, 1}blÂ·ğ‘– and ME.pl(â„“, ğœˆ) = 256 + â„“ +
|GenPadding(â„“; ğœˆ)|.19
=
=
the
The following SHA-1 and SHA-256-based function famil-
ies capture the MTProto primitives that are used to derive
auth_key_id, the message key msg_key and the symmetric
encryption key ğ‘˜.
Deï¬nition 7. MTP-HASH is
the function family with
MTP-HASH.Keys = {0, 1}1056, MTP-HASH.In = {0, 1}992,
MTP-HASH.ol = 128 and MTP-HASH.Ev(hk, ğ‘¥) = SHA-1(ğ‘¥[0 :
672] (cid:107) hk[0 : 32] (cid:107) ğ‘¥[672 : 992] (cid:107) hk[32 : 1056])[96 : 160].
Deï¬nition 8. MTP-MAC is
function family with
{0, 1}âˆ—,
MTP-MAC.Keys
MTP-MAC.ol
=
SHA-256(mku (cid:107) ğ‘)[64 : 192]. We refer to its output as
msg_key.
Deï¬nition 9. MTP-KDF is
function family with
MTP-KDF.Keys = {0, 1}288Ã—{0, 1}288, MTP-KDF.In = {0, 1}128,
MTP-KDF.ol = 2Â·SHA-256.ol and MTP-KDF.Ev given in Fig. 14.
Since the keys for KDF and MAC in MTProto are not
independent for the two users, we have to work in a related-key
setting. We are inspired by the RKA framework of [36], but
deï¬ne our related-key-deriving function ğœ™KDF (resp. ğœ™MAC) to
output both keys at once, as a function of kk (resp. mk). See
Fig. 15 for precise details of ğœ™KDF and ğœ™MAC.
{0, 1}256, MTP-MAC.In
128
and MTP-MAC.Ev(mku, ğ‘)
the
=
We now deï¬ne the symmetric encryption scheme.
19The deï¬nition of ME.pl assumes that GenPadding is invoked with the
random coins of the corresponding ME.Encode call. For simplicity, we chose
to not surface these coins in Fig. 13 and instead handle this implicitly.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
97
// â„“ âˆˆ224
ME.Init()
ğ‘sent â† 0 ; ğ‘recv â† 0
stME,I â† (session_id, ğ‘sent, ğ‘recv)
stME,R â† (session_id, ğ‘sent, ğ‘recv)
Return (stME,I , stME,R)
ğ‘–=1{0, 1}8Â·ğ‘–
GenPadding(â„“)
â„“(cid:48) â† bl âˆ’ â„“ mod bl
bn â†$ {1, Â· Â· Â· , pb}
ğ‘š â† ğ‘[256 : 256 + length Â· 8]
padding â†$ {0, 1}â„“(cid:48)+bnâˆ—bl
ğ‘recv â† (ğ‘recv + 1) mod 296
stME,u â† (session_id, ğ‘sent, ğ‘recv) ; Return (stME,u, ğ‘š)
Return padding
Figure 13: Construction of a simpliï¬ed message encoding scheme for strict in-order delivery ME = MTP-ME[session_id, pb, bl]
for session identiï¬er session_id, maximum padding length (in full blocks) pb, and output block length bl.
ME.Encode(stME,u, ğ‘š, aux)
(session_id, ğ‘sent, ğ‘recv) â† stME,u
salt â† (cid:104)0(cid:105)64 ; seq_no â† (cid:104)ğ‘sent(cid:105)96
length â† (cid:104)|ğ‘š|/8(cid:105)32
padding â†$ GenPadding(|ğ‘š|)
ğ‘0 â† salt (cid:107) session_id
ğ‘1 â† seq_no (cid:107) length
ğ‘2 â† ğ‘š (cid:107) padding ; ğ‘ â† ğ‘0 (cid:107) ğ‘1 (cid:107) ğ‘2
ğ‘sent â† (ğ‘sent + 1) mod 296
stME,u â† (session_id, ğ‘sent, ğ‘recv)
Return (stME,u, ğ‘)
ME.Decode(stME,u, ğ‘, aux)
If | ğ‘| < 256 then return (stME,u,âŠ¥)
(session_id, ğ‘sent, ğ‘recv) â† stME,u ; â„“ â† | ğ‘| âˆ’ 256
salt â† ğ‘[0 : 64] ; session_id(cid:48) â† ğ‘[64 : 128]
seq_no â† ğ‘[128 : 224] ;
If (session_id(cid:48) â‰  session_id)âˆ¨
(seq_no â‰  ğ‘recv)âˆ¨
Â¬(0 < length â‰¤ |â„“| /8) then return (stME,u,âŠ¥)
length â† ğ‘[224 : 256]
// |msg_key| = 128
MTP-KDF.Ev(kku, msg_key)
(kk0, kk1) â† kku ; ğ‘˜0 â† SHA-256(msg_key (cid:107) kk0)
ğ‘˜1 â† SHA-256(kk1 (cid:107) msg_key) ; ğ‘˜ â† ğ‘˜0 (cid:107) ğ‘˜1 ; Return ğ‘˜
Figure 14: Construction of function family MTP-KDF.
// |mk| = 320
ğœ™MAC(mk)
mkI â† mk[0 : 256]
mkR â† mk[64 : 320]
Return (mkI , mkR)
// |kk| = 672
ğœ™KDF(kk)
kkI,0 â† kk[0 : 288]
kkR,0 â† kk[64 : 352]
kkI,1 â† kk[320 : 608]
kkR,1 â† kk[384 : 672]
kkI â† (kkI,0, kkI,1)
kkR â† (kkR,0, kkR,1)
Return (kkI , kkR)
Figure 15: Related-key-deriving functions ğœ™KDF : {0, 1}672 â†’
MTP-KDF.Keys Ã— MTP-KDF.Keys and ğœ™MAC : {0, 1}320 â†’
MTP-MAC.Keys Ã— MTP-MAC.Keys.
Deï¬nition 10. Let AES-256 be the standard AES block cipher
with AES-256.kl = 256 and AES-256.ol = 128, and let IGE be
the block cipher mode in Fig. 4. Let MTP-SE = IGE[AES-256].
V. Formal security analysis
We ï¬rst deï¬ne the central security notions required from
each of the primitives used in MTP-CH. Then, we state that
MTP-CH satisï¬es correctness, indistinguishability and integrity.
A. Security requirements on standard primitives
1) MTP-HASH is a one-time indistinguishable function
family: We require that MTP-HASH meets the one-time weak
indistinguishability notion (OTWIND) deï¬ned in Fig. 16. The
security game Gotwind
HASH,D in Fig. 16 evaluates the function family
HASH on a challenge input ğ‘¥ğ‘ using a secret uniformly random
function key hk. Adversary D is given ğ‘¥0, ğ‘¥1 and the output of
HASH; it is required to guess the challenge bit ğ‘ âˆˆ {0, 1}. The
game samples inputs ğ‘¥0, ğ‘¥1 uniformly at random rather than
allowing D to choose them, so this security notion requires
HASH to provide only a weak form of one-time indistinguishab-
ility. The advantage of D in breaking the OTWIND-security
HASH,D]âˆ’1. The
of HASH is deï¬ned as Advotwind
full version of this work provides a formal reduction from the
HASH (D) = 2Â·Pr[Gotwind
98
OTWIND-security of MTP-HASH to the one-time PRF-security
of SHACAL-1 (as deï¬ned in Section II-B).
Game Gotwind
HASH,D
ğ‘ â†$ {0, 1} ; hk â†$ {0, 1}HASH.kl ; ğ‘¥0 â†$ HASH.In
ğ‘¥1 â†$ HASH.In ; auth_key_id â† HASH.Ev(hk, ğ‘¥ğ‘)
ğ‘(cid:48) â†$ D(ğ‘¥0, ğ‘¥1, auth_key_id) ; Return ğ‘(cid:48) = ğ‘
Figure 16: One-time weak indistinguishability of function
family HASH.
2) MTP-KDF is a PRF under related-key attacks: We require
that MTP-KDF behaves like a pseudorandom function in the
RKA setting (RKPRF) as deï¬ned in Fig. 17. The security game
Grkprf
KDF, ğœ™KDF,D in Fig. 17 deï¬nes a variant of the standard PRF
notion allowing the adversary D to use its RoR oracle to
evaluate the function family KDF on either of the two secret,
related function keys kkI, kkR (both computed using related-
key-deriving function ğœ™KDF). The advantage of D in breaking
the RKPRF-security of KDF with respect to ğœ™KDF is deï¬ned as
Advrkprf
(D) = 2 Â· Pr[Grkprf
KDF, ğœ™KDF,D] âˆ’ 1.
KDF, ğœ™KDF
KDF, ğœ™KDF,D
Game Grkprf
ğ‘ â†$ {0, 1} ; kk â†$ {0, 1}672
(kkI , kkR) â† ğœ™KDF(kk)
ğ‘(cid:48) â†$ DRoR ; Return ğ‘(cid:48) = ğ‘
Figure 17: Related-key PRF-security of function family KDF
with respect to related-key-deriving function ğœ™KDF.
RoR(u, msg_key)
ğ‘˜1 â† KDF.Ev(kku, msg_key)
If T[u, msg_key] =âŠ¥ then
T[u, msg_key] â†$ {0, 1}KDF.ol
ğ‘˜0 â† T[u, msg_key] ; Return ğ‘˜ğ‘
In Section V-B1 we deï¬ne a novel security notion for
SHACAL-2 that roughly requires it to be a leakage-resilient
PRF under related-key attacks; in the full version of this
work we provide a formal reduction from the RKPRF-security
of MTP-KDF to the new security notion. In this context,
â€œleakage resilienceâ€ means that the adversary can adaptively
choose a part of the SHACAL-2 key. However, we limit the
adversary to being able to evaluate SHACAL-2 only on a
single known, constant input (which is IV256, the initial state
of SHA-256). The new security notion is formalised as the
LRKPRF-security of SHACAL-2 with respect to a pair of related-
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
key-deriving functions ğœ™KDF and ğœ™SHACAL-2 (the latter is deï¬ned
in Section V-B1).
3) MTP-MAC is collision-resistant under RKA: We require
that collisions in the outputs of MTP-MAC under related
keys are hard to ï¬nd (RKCR), as deï¬ned in Fig. 18. The
security game Grkcr
MAC, ğœ™MAC,F in Fig. 18 gives the adversary
F two related function keys mkI, mkR (created by the