1081-6011/06 $20.00 © 2006 IEEE 
In our signature-creation algorithm, we initially begin
with the MEP path consisting of those instructions execut-
ing in the exploit trace T . We then compute a program chop
of the vulnerability, where vinit is the initial read of the sam-
ple exploit, and vﬁnal is the vulnerability point. The chop
contains all possible execution paths from where an exploit
was read (in the trace) to the vulnerability point. We then
initially create a signature S for the MEP path given by the
execution trace, and then iteratively improve S by consider-
ing other paths.
For our running example, the MEP coverage consists of
the instructions executed in the trace. The complete PEP
coverage consists of lines 1-12, excluding line 6.
3 Automatic Vulnerability Signature Cre-
ation
At a high level, our algorithm for computing a vulnera-
bility signature for program P, vulnerability condition c, a
sample exploit x, and the corresponding instruction trace T
is depicted in Figure 4. In this section we detail how we
perform each of the steps:
1. Pre-process the program before any exploit is received
by:
(a) Disassembling the program P (Section 3.1).
(b) Converting the assembly into an intermediate
representation (IR) (Section 3.1).
2. Compute a chop with respect to the trace T . The chop
includes all paths to the vulnerability point including
that taken by the sample exploit (Section 3.2).
3. Compute the signature:
(a) Compute the Turing machine signature (Sec-
tion 3.3.1). Stop if this is the ﬁnal representation.
(b) Compute the symbolic constraint signature from
the TM signature (Section 3.3.2). Stop if this is
the ﬁnal representation.
(c) Compute the regular expression signature from
the symbolic constraint signature (Section 3.4).
3.1 Disassembling the Binary Program and Con-
verting to the IR
We ﬁrst disassemble the binary and identify function
boundaries. We do not require the symbol table as functions
can be identiﬁed via their prologue and epilogue. Next, we
convert the disassembled instructions into an intermediate
representation (IR). The IR disambiguates instructions by
making implicit hardware side-effects explicit. Although
this step is seemingly straight-forward, it is actually fairly
involved. The main complication we address is modern ar-
chitectures such as x86 implicitly set and test hardware reg-
isters, which can affect program execution, i.e., these tests
and sets do not appear explicitly in the assembly. For ex-
ample, the overﬂow ﬂag may be automatically set when ex-
ecuting arithmetic operation, then later tested by a condi-
tional jump. Another complication is the same register may
be indexed in different modes, e.g., al is the lower 8 bits
of the eax register, so any instruction affecting al must
simultaneously affect eax in the IR.
More concretely, the x86 instruction set contains over
60 instructions that perform via hardware test or set oper-
ations on the EFLAGS register. Extra IR statements must
be added to almost all operations to reﬂect the updates done
in hardware. Worse, which statements to add is speciﬁc to
the particular mode of the operands. The x86 architecture
has 8-bit mode, 16-bit mode, etc., which is set depending
upon the format of the instruction operands. For exam-
ple, add %ax, %bx is an addition in 16-bit mode since
the registers speciﬁed are 16-bits long. Overﬂow, the carry
ﬂag, and other implicit hardware-assisted effects must then
be set with respect to 16-bits. A very similar instruction
add %eax, %ebx is 32-bit mode, and implicit hardware
effects must be done with respect to 32-bits.
We perform the remaining steps — program chopping
and vulnerability signature creation — on the IR statements.
3.2 Computing the Chop on the IR
We ﬁrst compute the chop [27, 48] of the vulnerability
with respect to the exploit x and trace T (as discussed in
Section 2.5). Note our chopping algorithm results in an im-
precise chop because we lack pointer analysis. The result of
the chop is a smaller program P (cid:2) in which every path begins
at the read statement in the trace and ends at the vulnera-
bility point. We can then select in the signature generation
step any set of paths in P (cid:2) and compute a signature.
We perform a chop on the program’s callgraph. The chop
contains all functions that may be executed between reading
in the exploit and the vulnerability point. The chop is per-
formed by essentially doing a reachability analysis so that
any function in a call sequence that may reach the vulnera-
bility point is included.
A callgraph is a directed graph where each function is
a vertex, and edges represent the caller-callee relationship
of functions. We perform the following algorithm on the
callgraph to create the chop given start IR statement vinit ,
which is the read statement for the exploit in the trace,
and the vulnerability point vﬁnal in the trace T . Let Finit
and Fﬁnal be the functions enclosing the vinit and vﬁnal
nodes respectively. Note that there is at least one path from
Finit to Fﬁnal : the one that appears in the trace. We then
add an extra edge from Fﬁnal to Finit , resulting in a loop
in the callgraph. We then calculate the strongly connected
component (SCC) containing Finit and Fﬁnal . This SCC is
the chop, since it contains all reachable functions from Finit
to Fﬁnal .
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Binary
Program
Exploit &
Trace
Vulnerability
Condition
Disassemble
Convert to IR
Compute Chop
Select paths from
Chop
Create TM Sig
Symbolic Execution
& Constraint Generation
Constraint
Solving
Pre processing Phase
Automatic Vulnerability Signature Generation
Signature Generation Phase
Turing Machine Signature
Symbolic Constraint
Signature
Regular Expression
Signature
Figure 4. A high level view of the steps to compute a vulnerability signature.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
One problem we must deal with at the binary level is
the widespread use of indirect jumps, e.g., jmp %eax is
indirect while jmp 0x80bebefa is direct. Note some
indirect jumps correspond to source code constructs such
as function pointers, while some are compiler-generated as
optimizations. The central issue is a target of an indirect
jump could potentially be any other instruction. As a re-
sult, any control ﬂow graph (including dependency graphs)
would have an edge from each indirect jump to all other
instructions.
In order to deal with the widespread indirect jumps in bi-
naries without pointer analysis, when creating the callgraph
we make the target of each indirect jump a special node
IJMP. Our algorithm for computing the chop then will es-
sentially ignore indirect jumps until a chop is computed.
After computing the chop, we constrain each indirect jump
so that the target is within the chop. One limitation of this
approach is that technically we could be incorrectly exclud-
ing a function that only appears as the target of an indirect
jump. The indirect jump problem may or may not disappear
once we have implemented function pointer analysis. It re-
mains unclear (and a point of future work) how precisely
such analysis will be able to pin down the targets of indirect
jumps.
3.3 Computing the Signature
We compute the signature with respect to the chop. We
compute a PEP signature by iteratively considering single
MEP paths (except in our data-ﬂow analysis optimization).
Our iterative method works because we can pick any path
or set of paths within the chop, perform our analysis, and
output the corresponding vulnerability signature. The com-
plete PEP coverage signature (Section 2.5) is then the anal-
ysis of all paths in the chop. We begin by describing how we
compute the complete PEP TM signature, which in turn be-
comes input to symbolic constraint and regular expression
signature generation.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
c h a r ∗ u r l = m a l l o c ( 4 ) ;
i n t c = 0 ;
i f ( i n p [ c ]
! = ’ g ’ && i n p [ c ]
r e t u r n BENIGN
! = ’G ’ )
r e t u r n BENIGN ;
r e t u r n BENIGN ;
’ )
’ )
! = ’
c + + ;
i f ( i n p [ c ]
c + + ;
i f ( i n p [ c ] == ’
∗ u r l = i n p [ c ] ; c + + ; u r l + + ;
i f ( i n p [ c ] == ’
∗ u r l = i n p [ c ] ; c + + ; u r l + + ;
i f ( i n p [ c ] == ’
∗ u r l = i n p [ c ] ; c + + ; u r l + + ;
i f ( i n p [ c ] == ’
r e t u r n EXPLOIT ;
’ )
r e t u r n BENIGN ;
’ )
r e t u r n BENIGN ;
’ )
r e t u r n BENIGN ;
Figure 5. The MEP TM signature for our run-
ning example.
3.3.1 Turing Machine Signature Generation
MEP Turing machine signature generation. Our initial
MEP Turing machine signature is created with respect to the
path followed in the instruction trace. Therefore, the initial
signature will match the sample exploit, and certain exploit
variants such as changing the exploit payload. We create
the initial MEP TM signature by reading in the instruction
trace and including the corresponding IR statements.
Sequential instructions in the trace correspond to sequen-
tial statements in the MEP Turing machine signature. Con-
ditional branch statements have exactly two targets in the
IR, which during signature creation are either BENIGN or
EXPLOIT. Any branch that does not lead towards the vul-
nerability point returns BENIGN. EXPLOIT is only re-
turned if the vulnerability point is reached and the vulnera-
bility condition is satisﬁed.
We encode the vulnerability condition as a function. At
the vulnerability point we insert a jump to this function,
which does a ﬁnal check to see if the program is in the vul-
nerable state, and returns EXPLOIT if satisﬁed else BE-
NIGN. Figure 5 shows the MEP vulnerability signature we
would return for our running example with the vulnerability
check inlined.
PEP Turing machine signature generation. A PEP Tur-
ing machine signature is created similar to an MEP Turing
machine signature. The PEP signature ﬁrst computes the
chop, and then computes which jump targets cannot lead to
the vulnerability point via standard graph reachability anal-
ysis. Paths that terminate or cannot lead to the vulnera-
bility point return BENIGN. We also again insert a call
to the vulnerability condition function at the vulnerability
point, which returns either BENIGN or EXPLOIT. Fig-
ure 2 shows the complete PEP vulnerability signature with
the vulnerability condition inlined.
3.3.2 Symbolic Constraint Signature Generation
A symbolic constraint signature is a set of constraints an
exploit of the vulnerability must satisfy. We use the TM
signature as the input to symbolic constraint signature gen-
eration, and at a high level generate constraints that rep-
resent meeting the correct conditionals in the TM to reach
the vulnerability point and satisfy the vulnerability condi-
tion. The symbolic constraint signature is an approximation
of the TM signature because we may have to statically esti-
mate the effects of loops and memory updates as constraints
on the input. The symbolic constraint system is built up by
symbolically evaluating the TM signature program on sym-
bolic inputs instead of actual inputs (values).
More formally, we build up the constraints based upon
symbolically executing paths in the TM. Each function in
the TM signature is represented by a control ﬂow graph
(CFG), which is a direct graph (V, E, ventry , vexit ) where
each IR instruction is a node in V , each transfer of control
between instructions is an edge in E, and ventry , vexit are
distinguished entry and exit nodes. Conditionals in the con-
trol ﬂow graph become constraints to take the appropriate
branch to reach the vulnerability point and satisfy the vul-
nerability condition.
Single Static Assignment (SSA) form. We must convert
the IR into a single static assignment (SSA) [41] form prior
to symbolic constraints (this step can be performed during
the pre-processing phase). Normally, memory locations and
registers are destructively updated many times in the lifes-
pan of a program, e.g., x = x + 1 destructively updates
the x on the right-hand side (RHS) when assigning to x
on the left-hand side (LHS). However, symbolic execution
requires each variable be treated as a single logical entity
that is assigned to only once. SSA form is a semantically
equivalent form of the program which satisﬁes this criteria.
The SSA form of sequential statements is just a unique re-
naming of each LHS. For example, x = x + 1 becomes
x2 = x1 + 1. For control statements, SSA introduces a
special assignment called φ-functions which merges several
possible deﬁnitions of a variable into one. For example, the
if-then-else statement
i f ( x< 2 ) z = 1 0 ;
e l s e z = 2 0 ; }
becomes
i f ( x0 < 2 ) z1 = 10 e l s e z2 = 2 0 ;
z3 = φ ( z1 , z2 ) ;
where z3 is assigned z1 on the true branch and z2 on the
false branch.
MEP symbolic execution. We perform MEP symbolic
execution by evaluating the MEP TM signature. Recall that
the MEP TM signature is a straight-line program. Then
there is a single path π = ventry , v1, ..., vexit
that goes
through the vulnerability point and the vulnerability con-
dition. All other paths will end up returning BENIGN and
need not be considered. The result of symbolic execution on
π is a set of constraints on input variables that when met re-
sults in an execution from ventry , through the vulnerability
point and the inlined vulnerability condition to vexit .
We begin by creating symbolic input variables i0, ..., in
where n is the length of the symbolic input to consider,
e.g, n is initially the length of the sample exploit x. Each
statement is then executed on these inputs, resulting in a
symbolic formula at each step. There are three fundamen-
tal operation types to evaluate symbolically: memory up-
dates, arithmetic operations, and branch predicate evalua-
tion. Symbolic execution of arithmetic operations is simply
a substitution procedure. For example, x = a+i0; y = x∗z
becomes y = (a + i0) ∗ z.
A memory store operation is an assignment of a value to
a symbolic memory location (stack and heap assignments
are handled in a uniform fashion). We adopt a model similar
to UCLID [9] for handling memory updates. The initial
state of M is given by m0. Reads and writes are modeled
as λ expressions, where a write to memory location A with
value D yields a new M (cid:2):
M (cid:2) = λaddr.ITE(addr = A, D, M [addr])
The result of a write is an if-then-else (ITE) λ expression.
A subsequent read behaves as follows: the address to read
is applied as the argument to the write λ expression. If the
supplied address matches A, then D is returned, else we
recurse to the next memory address given by M [addr].
Without loss of generality, we assume each branch predi-
cate (such as je (jump if equal) or jz (jump if zero)) vi ∈ π
evaluates to true in order to create the desired total path π. A
branch predicate forms an arithmetic constraint (with some
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
expressions perhaps involving memory reads and writes) re-
lating the symbolic execution to some constant, e.g., jz y