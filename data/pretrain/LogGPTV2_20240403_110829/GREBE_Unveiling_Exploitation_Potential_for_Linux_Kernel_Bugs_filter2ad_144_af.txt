Although the kernel fuzzers above demonstrate effectiveness in
ﬁnding kernel bugs, like Syzkaller, their design inevitably fails
multiple error behavior exploration simply because they rely
on code coverage to guide kernel fuzzing tasks, making our
task inefﬁcient. In this work, GREBE introduces a new design
that utilizes critical kernel objects to improve effectiveness and
efﬁciency for multiple error behavior exploration.
Apart from kernel fuzzers aiming to ﬁnd various types of
bugs in the entire system, there are works focusing on speciﬁc
kernel modules or bug types. DIFUZE [20] uses static analysis
to effectively fuzz device drivers in the Android kernel.
Periscope [58] fuzzes a device driver not via system call
interfaces but mutating input space over I/O bus. Razzer [22]
combines static and dynamic testing to reach program sites
where race condition bugs may exist. KRACE [21] further
customizes to ﬁnd race condition bugs in the ﬁle system. While
they demonstrate their utility in hunting bugs in speciﬁc kernel
modules, it is difﬁcult to generalize these techniques to explore
kernel bugs’ error behaviors.
SemFuzz [19] is the only work that aims to trigger a
known kernel bug through kernel fuzzing to the best of
our knowledge. However, this technique is not designed to
diversify the paths and contexts for triggering the bug but
simply to enable bug reproduction. Therefore, it is not suitable
for the problem we address.
Exploitability assessment. Automating exploit development
can also facilitate exploitability assessment.
For user space programs, Brumley et al. [59], [60] used
preconditioned symbolic execution to generate exploits for
stack overﬂow and format string vulnerabilities. Bao et al. [61]
recently proposed shellcode layout
remediation and path
kneading approaches to transplant existing shellcode. The
Shellphish team developed PovFuzzer and Rex to turn a crash
to an exploit [62], [63], [64]. Heelan et al. focus on heap
buffer overﬂow vulnerabilities in user space programs. In [65],
they use regression test to learn how to automate heap layout
manipulation so that one could corrupt the sensitive pointers.
In [66], they further improve their proposed approach by using
a genetic algorithm to replace the random search algorithm
for exploiting heap overﬂow vulnerabilities in language inter-
preters. Sharing the similar goals with the works [65], [66],
Revery [67] also explores exploitable memory layouts for vul-
nerabilities in userspace programs. It utilizes fuzz testing along
with a program synthesis method to guide the construction of
a working exploit. Insu et al. [68] discovers new exploitation
primitives in the heap allocator. They provide heap operations
and attack capabilities as actions, driving the heap allocator to
execute until primitives such as arbitrary write or overlapped
chunks are identiﬁed. Unlike the works summarized above,
GREBE focuses on a bug’s exploitability assessment in the ker-
nel space which is naturally more sophisticated than userland
programs. Besides, our work is not designed for constructing
exploitable memory layout or synthesizing working exploits.
Rather, it focuses on exploring all the possible error behaviors
for a single kernel bug.
Regarding the kernel space, existing exploitability assess-
ment works are mainly in three directions. The ﬁrst direction is
to obtain exploitable primitives. Xu et al. [69] exploit use-after-
free vulnerabilities using two memory collision mechanisms
to perform heap spray in the kernel. SLAKE [70] facilitates
the exploitation of slab-based vulnerabilities by ﬁrst building a
database of kernel objects and then systematically manipulat-
ing slab layout using the kernel objects in the database. Lu et
al. [71] exploits use-before-initialization vulnerabilities using
deterministic stack spraying and reliable exhaustive memory
spraying. As a follow-up work, Cho et al. [72] further propose
to use BPF functionality in the kernel for stack spraying. The
second direction is to bypass mitigations in the kernel. For
example, ret2dir [73] takes advantage of physical memory
which is mapped to kernel space for payload injection. KE-
PLER [74] leverages communication channels between kernel
space and user space (e.g., copy_from/to_user) to leak stack
canary and inject ROP payload to kernel stack. ELOISE [15]
bypasses KASLR and heap cookie protector using a special
but pervasive type of structure. The third direction is to explore
the capability of vulnerabilties, which is most related to our
work. In this direction, FUZE [75] explores new use sites for
use-after-free vulnerabilities using under-context fuzzing and
identiﬁes exploitable primitives implied by the new use sites
using symbolic execution. KOOBE [76] extracts capabilities
of a slab-out-of-bound access vulnerability manifested in the
PoC program and uncover hidden capabilities using capability-
guided fuzzing. The techniques developed in both works are
customized to the characteristics of a speciﬁc vulnerability
type and are difﬁcult to generalized to others. Besides, they
require to manually diagnose root cause of the bug while
GREBE does not. Moreover, they cannot explore possible error
behaviors for a single bug, which is the main contribution of
GREBE.
VIII. CONCLUSION AND FUTURE WORK
We design and develop an object-driven kernel fuzzing
method. Using our proposed technique, security analysts could
explore various contexts and paths toward a target kernel bug
and exhibit the bug’s many error behaviors. The newly iden-
tiﬁed error behaviors might have higher exploitation potential
than the one shown in the original report. It indicates the bug’s
exploitability escalation. As such, we safely conclude, given a
kernel bug, the object-driven kernel fuzzing method could help
security analysts better understand and infer exploitability for
a given kernel bug.
In this work, we focus on developing technical methods
to expose multiple error behaviors only for Linux kernel
bugs. Thus, one of our future directions is to explore the
proposed method against
the bugs on other kernels (e.g.,
XNU, FreeBSD). While our design is general and not speciﬁc
for Linux, we argue intensive engineering efforts are still
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2090
necessary. First, the debugging features such as KASAN are
not always available on other OSes (e.g., no KASAN support
for FreeBSD). Even if GREBE could trigger the bug through
different paths or contexts, the lack of debugging features
would lead to the failure of reporting the severe error behavior
exposed through these new paths or contexts. Second, existing
fuzzing tools and templates are mainly designed for Linux
kernel and, to enable GREBE on other OSes, we will have
to port fuzzing tools to other OSes and enrich the fuzzing
templates accordingly (e.g., no open-sourced Syzkaller support
for XNU). As part of our future work, we will devote our
energy to these engineering efforts.
ACKNOWLEDGEMENTS
We thank the anonymous reviewers for their valuable sug-
gestions and feedback. This work was partially supported by
the 2020 IBM PhD Fellowship Program, NSF 1954466, NSF
1718459, and ONR N00014-20-1-2008. This paper gives the
views of the author, and not necessarily the position of the
funding agency.
REFERENCES
[1] S. Team, “!exploitable crash analyzer version 1.6,” 2013.
[2] B. J. Wever, “Bugid - automated bug analysis,” 2017, https://prezi.com/
caic9eqayy-o/bugid-automated-bug-analysis/.
[3] J. Vanegue, “In memory safety, the soundness of attacks is what matters,”
2020.
[4] D. Vyukov, “Syzkaller,” 2020, https://github.com/google/syzkaller.
[5] S. Schumilo, C. Aschermann, R. Gawlik, S. Schinzel, and T. Holz,
“kAFL: Hardware-assisted feedback fuzzing for os kernels,” in Pro-
ceedings of the 28th USENIX Security Symposium (USENIX Security),
2019.
[6] D. Jones, “Trinity,” 2020, https://github.com/kernelslacker/trinity.
[7] T. Blazytko, M. Schl¨ogel, C. Aschermann, A. Abbasi, J. Frank,
S. W¨orner, and T. Holz, “AURORA: Statistical crash analysis for
automated root cause explanation,” in Proceeding of the 28th USENIX
Security Symposium (USENIX Security), 2020.
[8] syzbot,
“general
protection
2017,
5d3cce34cc09f722e859ae2037801f5b0d67c5c9.
fault
hrtimer active,”
https://syzkaller.appspot.com/bug?id=
in
[9] “Linux kernel design patterns - part 2,” https://lwn.net/Articles/336255/,
2009.
[10] S. Brin and L. Page, “The anatomy of a large-scale hypertextual web
search engine,” 1998.
“KASAN:
[11] syzbot,
fault write copy kernel,”
id=7022420cc54310220ebad2da89e499bdb1f0f5e8.
slab-out-of-bounds
2019,
de-
https://syzkaller.appspot.com/bug?
Read
in
[12] syzbot,
“BUG:
unable
check memory region,”
id=692a8c2104416b219c0036b0a566eb88f73b1dd5.
to
2018,
handle
kernel
in
https://syzkaller.appspot.com/bug?
request
paging
[13] Z. Lin, “Grebe’s source code,” 2021, https://github.com/Markakd/
GREBE.
[14] K. Lu and H. Hu, “Where Does It Go? Reﬁning indirect-call targets
with multi-layer type analysis,” in Proceedings of the 26th ACM SIGSAC
Conference on Computer and Communications Security (CCS), 2019.
[15] Y. Chen, Z. Lin, and X. Xing, “A systematic study of elastic objects
the 27th ACM SIGSAC
in kernel exploitation,” in Proceedings of
Conference on Computer and Communications Security (CCS), 2020.
[16] I. Ben-Gal, “Outlier detection,” in Data mining and knowledge discovery
handbook. Springer, 2005, pp. 131–146.
[17] S. Pailoor, A. Aday, and S. Jana, “MoonShine: Optimizing os fuzzer seed
selection with trace distillation,” in Proceedings of the 27th USENIX
Security Symposium (USENIX Security), 2018.
[18] K. Kim, D. R. Jeong, C. H. Kim, Y. Jang, I. Shin, and B. Lee, “HFL:
Hybrid fuzzing on the linux kernel,” in Proceedings of the 2020 Network
and Distributed System Security Symposium (NDSS), 2020.
[19] W. You, P. Zong, K. Chen, X. Wang, X. Liao, P. Bian, and B. Liang,
“SemFuzz: Semantics-based automatic generation of proof-of-concept
exploits,” in Proceedings of the 24th ACM SIGSAC Conference on
Computer and Communications Security (CCS), 2017.
[20] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao, C. Kruegel,
and G. Vigna, “DIFUZE: Interface aware fuzzing for kernel drivers,”
in Proceedings of the 24th ACM SIGSAC Conference on Computer and
Communications Security (CCS), 2017.
[21] M. Xu, S. Kashyap, H. Zhao, and T. Kim, “KRace: Data race fuzzing
for kernel ﬁle systems,” in Proceedings of the 41st IEEE Symposium on
Security and Privacy (S&P), 2020.
[22] D. R. Jeong, K. Kim, B. Shivakumar, B. Lee, and I. Shin, “Razzer:
Finding kernel race bugs through fuzzing,” in Proceedings of the 40th
IEEE Symposium on Security and Privacy (S&P), 2019.
[23] syzbot,
“WARNING:
2020,
bdeea91ae259b3a42aa8ed8d8c91afd871eb5d80.
refcount
bug
crypto mod get,”
https://syzkaller.appspot.com/bug?id=
in
[24] syzbot,
“WARNING:
2019,
521a764b3fc8145496efa50600dfe2a67e49b90b.
refcount
bug
nr insert socket,”
https://syzkaller.appspot.com/bug?id=
in
[25] syzbot,
“general
layed uprobe remove,”
id=229e0b718232b004dfddaeac61d8d66990ed247a.
protection
de-
https://syzkaller.appspot.com/bug?
2019,
fault
in
[26] “Full performance results of syzkaller, syzkaller variant, grebe without
mutation optimization and grebe,” 2021, https://tinyurl.com/x9ky26ms.
handle
in
https://syzkaller.appspot.com/bug?id=
skb release data,”
d1baeb189d38d5ba53517876c89b20d4e6857bc6.
to
2017,
[27] syzbot,
request
“BUG:
paging
unable
kernel
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2091
[28] syzbot, “BUG: corrupted list in
neigh create,” 2019, https://syzkaller.
[55] syzbot,
“KASAN:
appspot.com/bug?id=de28cb0e686acfa1c9dbad1e11cbb0ac9b05caf2.
[29] syzbot, “Warning: refcount bug,” 2020, https://syzkaller.appspot.com/
bug?id=8eceaff64a35a9f02c1315bbf12b7f262a0b4f08.
[30] syzbot,
“general
protection
2020,
f56bbe6668873ee245986bbd23312b895fa5a50a.
fault
qrtr endpoint post,”
https://syzkaller.appspot.com/bug?id=
in
[31] syzbot, “WARNING in get pi state,” 2017, https://syzkaller.appspot.
com/bug?id=bb7fa48ebde0db8e3fc683a47bb69ab1dca895bc.
[32] syzbot,
“BUG:
corrupted
2020,
f0ec9a394925aafbdf13d0a7e6af4cff860f0ed6.
list
kobject add internal,”
https://syzkaller.appspot.com/bug?id=
in
[33] syzbot,
“KASAN:
crypto chacha20 crypt,”
id=d767177245c54af614d5241159cce56995eef0db.
general
2018,
protection
in
https://syzkaller.appspot.com/bug?
fault
“WARNING: ODEBUG bug in io sqe ﬁles unregister,”
https://syzkaller.appspot.com/bug?id=
2020,
460cc948740aa1e715156c0edf5d5d397401d557.
[34] syzbot,
[35] syzbot, “WARNING in vhost dev cleanup,” 2018, https://syzkaller.
appspot.com/bug?id=0df4c1a9c14776f5fd163180e3580ad88b32649a.
[36] syzbot, “general protection fault in vb2 mmap,” 2019, https://syzkaller.
appspot.com/bug?id=4cf5ee79b52a4797c5bd40a58bd6ab243d40de48.
[37] syzbot, “general protection fault
in strlen,” 2018, https://syzkaller.
appspot.com/bug?id=502c872feb9bbb5ad6494c349c7faa87a9f1777b.
[38] syzbot, “WARNING in dma buf vunmap,” 2019, https://syzkaller.
appspot.com/bug?id=163388d1fb80146cd3ba22a11a5a1995c3eaaafe.
request
“BUG:
unable
handle
[39] syzbot,
kernel
in
https://syzkaller.appspot.com/bug?
paging
ethnl update bitset32,”
id=b36d7e444fe532685b683ae7980f4e3a184f0ad8.
fault