### Optimized Text

Although the aforementioned kernel fuzzers, including Syzkaller, have proven effective in identifying kernel bugs, their design inherently limits their ability to explore multiple error behaviors. This limitation arises because these fuzzers rely on code coverage as a guiding metric for kernel fuzzing tasks, which can lead to inefficiencies. In this work, GREBE introduces a novel design that leverages critical kernel objects to enhance both the effectiveness and efficiency of exploring multiple error behaviors.

While some kernel fuzzers aim to detect various types of bugs across the entire system, others focus on specific kernel modules or bug types. For instance, DIFUZE [20] employs static analysis to effectively fuzz device drivers in the Android kernel. Periscope [58] targets device drivers by mutating input space over the I/O bus rather than through system call interfaces. Razzer [22] combines static and dynamic testing to identify potential race condition bugs, and KRACE [21] is specifically tailored to find race condition bugs in file systems. Although these techniques are useful for identifying bugs in specific kernel modules, they are not easily generalizable for exploring the full range of error behaviors associated with kernel bugs.

SemFuzz [19] is the only known work that aims to trigger a known kernel bug through fuzzing. However, it is designed primarily for reproducing the bug rather than diversifying the paths and contexts for triggering it. Therefore, SemFuzz is not suitable for the problem addressed by GREBE.

### Exploitability Assessment

Automating exploit development can also facilitate exploitability assessment. For user-space programs, Brumley et al. [59], [60] used preconditioned symbolic execution to generate exploits for stack overflow and format string vulnerabilities. Bao et al. [61] recently proposed shellcode layout remediation and path kneading approaches to transplant existing shellcode. The Shellphish team developed PovFuzzer and Rex to convert crashes into exploits [62], [63], [64]. Heelan et al. focused on heap buffer overflow vulnerabilities in user-space programs, using regression testing to automate heap layout manipulation [65] and later improving their approach with a genetic algorithm [66]. Revery [67] explores exploitable memory layouts for vulnerabilities in user-space programs, combining fuzz testing with program synthesis to guide the construction of working exploits. Insu et al. [68] discovered new exploitation primitives in the heap allocator, providing heap operations and attack capabilities as actions to drive the heap allocator until primitives such as arbitrary write or overlapped chunks are identified.

Unlike the works mentioned above, GREBE focuses on assessing the exploitability of bugs in the kernel space, which is more complex than in userland programs. Additionally, GREBE is not designed for constructing exploitable memory layouts or synthesizing working exploits. Instead, it aims to explore all possible error behaviors for a single kernel bug.

### Kernel Space Exploitability Assessment

Existing works on exploitability assessment in the kernel space can be categorized into three main directions. The first direction involves obtaining exploitable primitives. Xu et al. [69] exploited use-after-free vulnerabilities using two memory collision mechanisms for heap spraying in the kernel. SLAKE [70] facilitates the exploitation of slab-based vulnerabilities by building a database of kernel objects and systematically manipulating slab layout. Lu et al. [71] exploited use-before-initialization vulnerabilities using deterministic stack spraying and exhaustive memory spraying. Cho et al. [72] further proposed using BPF functionality in the kernel for stack spraying.

The second direction focuses on bypassing mitigations in the kernel. For example, ret2dir [73] uses physical memory mapped to kernel space for payload injection. KEPLER [74] leverages communication channels between kernel and user space (e.g., copy_from/to_user) to leak stack canary and inject ROP payloads into the kernel stack. ELOISE [15] bypasses KASLR and heap cookie protectors using a special but pervasive type of structure.

The third direction, most relevant to our work, is to explore the capabilities of vulnerabilities. FUZE [75] identifies new use sites for use-after-free vulnerabilities using under-context fuzzing and symbolic execution. KOOBE [76] extracts the capabilities of a slab-out-of-bound access vulnerability from the PoC program and uncovers hidden capabilities using capability-guided fuzzing. These techniques are customized for specific vulnerability types and are difficult to generalize. Moreover, they require manual diagnosis of the root cause of the bug, which GREBE does not. Additionally, they cannot explore the full range of possible error behaviors for a single bug, which is the primary contribution of GREBE.

### Conclusion and Future Work

We have designed and developed an object-driven kernel fuzzing method. Using this technique, security analysts can explore various contexts and paths toward a target kernel bug, revealing multiple error behaviors. The newly identified error behaviors may have higher exploitation potential than those shown in the original report, indicating an escalation in the bug's exploitability. Thus, we conclude that the object-driven kernel fuzzing method can help security analysts better understand and infer the exploitability of a given kernel bug.

In this work, we focused on developing technical methods to expose multiple error behaviors for Linux kernel bugs. One future direction is to extend the proposed method to other kernels, such as XNU and FreeBSD. While our design is general, intensive engineering efforts are necessary. First, debugging features like KASAN are not always available on other operating systems (e.g., no KASAN support for FreeBSD). Even if GREBE can trigger the bug through different paths or contexts, the lack of debugging features would hinder the reporting of severe error behaviors. Second, existing fuzzing tools and templates are mainly designed for the Linux kernel. To enable GREBE on other operating systems, we will need to port fuzzing tools and enrich the fuzzing templates accordingly (e.g., no open-sourced Syzkaller support for XNU). As part of our future work, we will dedicate our efforts to these engineering challenges.

### Acknowledgements

We thank the anonymous reviewers for their valuable suggestions and feedback. This work was partially supported by the 2020 IBM PhD Fellowship Program, NSF 1954466, NSF 1718459, and ONR N00014-20-1-2008. The views expressed in this paper are those of the author and do not necessarily reflect the position of the funding agency.

### References

[1] S. Team, “!exploitable crash analyzer version 1.6,” 2013.
[2] B. J. Wever, “Bugid - automated bug analysis,” 2017, https://prezi.com/caic9eqayy-o/bugid-automated-bug-analysis/.
[3] J. Vanegue, “In memory safety, the soundness of attacks is what matters,” 2020.
[4] D. Vyukov, “Syzkaller,” 2020, https://github.com/google/syzkaller.
[5] S. Schumilo, C. Aschermann, R. Gawlik, S. Schinzel, and T. Holz, “kAFL: Hardware-assisted feedback fuzzing for OS kernels,” in Proceedings of the 28th USENIX Security Symposium (USENIX Security), 2019.
[6] D. Jones, “Trinity,” 2020, https://github.com/kernelslacker/trinity.
[7] T. Blazytko, M. Schlögel, C. Aschermann, A. Abbasi, J. Frank, S. Wörner, and T. Holz, “AURORA: Statistical crash analysis for automated root cause explanation,” in Proceedings of the 28th USENIX Security Symposium (USENIX Security), 2020.
[8] syzbot, “General protection fault hrtimer active,” 2017, https://syzkaller.appspot.com/bug?id=5d3cce34cc09f722e859ae2037801f5b0d67c5c9.
[9] “Linux kernel design patterns - part 2,” https://lwn.net/Articles/336255/, 2009.
[10] S. Brin and L. Page, “The anatomy of a large-scale hypertextual web search engine,” 1998.
[11] syzbot, “KASAN: slab-out-of-bounds fault write copy kernel,” 2019, https://syzkaller.appspot.com/bug?id=7022420cc54310220ebad2da89e499bdb1f0f5e8.
[12] syzbot, “BUG: unable to handle kernel request paging read,” 2018, https://syzkaller.appspot.com/bug?id=692a8c2104416b219c0036b0a566eb88f73b1dd5.
[13] Z. Lin, “Grebe’s source code,” 2021, https://github.com/Markakd/GREBE.
[14] K. Lu and H. Hu, “Where Does It Go? Refining indirect-call targets with multi-layer type analysis,” in Proceedings of the 26th ACM SIGSAC Conference on Computer and Communications Security (CCS), 2019.
[15] Y. Chen, Z. Lin, and X. Xing, “A systematic study of elastic objects in kernel exploitation,” in Proceedings of the 27th ACM SIGSAC Conference on Computer and Communications Security (CCS), 2020.
[16] I. Ben-Gal, “Outlier detection,” in Data mining and knowledge discovery handbook. Springer, 2005, pp. 131–146.
[17] S. Pailoor, A. Aday, and S. Jana, “MoonShine: Optimizing OS fuzzer seed selection with trace distillation,” in Proceedings of the 27th USENIX Security Symposium (USENIX Security), 2018.
[18] K. Kim, D. R. Jeong, C. H. Kim, Y. Jang, I. Shin, and B. Lee, “HFL: Hybrid fuzzing on the Linux kernel,” in Proceedings of the 2020 Network and Distributed System Security Symposium (NDSS), 2020.
[19] W. You, P. Zong, K. Chen, X. Wang, X. Liao, P. Bian, and B. Liang, “SemFuzz: Semantics-based automatic generation of proof-of-concept exploits,” in Proceedings of the 24th ACM SIGSAC Conference on Computer and Communications Security (CCS), 2017.
[20] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao, C. Kruegel, and G. Vigna, “DIFUZE: Interface-aware fuzzing for kernel drivers,” in Proceedings of the 24th ACM SIGSAC Conference on Computer and Communications Security (CCS), 2017.
[21] M. Xu, S. Kashyap, H. Zhao, and T. Kim, “KRace: Data race fuzzing for kernel file systems,” in Proceedings of the 41st IEEE Symposium on Security and Privacy (S&P), 2020.
[22] D. R. Jeong, K. Kim, B. Shivakumar, B. Lee, and I. Shin, “Razzer: Finding kernel race bugs through fuzzing,” in Proceedings of the 40th IEEE Symposium on Security and Privacy (S&P), 2019.
[23] syzbot, “WARNING: refcount bug crypto mod get,” 2020, https://syzkaller.appspot.com/bug?id=bdeea91ae259b3a42aa8ed8d8c91afd871eb5d80.
[24] syzbot, “WARNING: refcount bug nr insert socket,” 2019, https://syzkaller.appspot.com/bug?id=521a764b3fc8145496efa50600dfe2a67e49b90b.
[25] syzbot, “General protection fault delayed uprobe remove,” 2019, https://syzkaller.appspot.com/bug?id=229e0b718232b004dfddaeac61d8d66990ed247a.
[26] “Full performance results of syzkaller, syzkaller variant, grebe without mutation optimization and grebe,” 2021, https://tinyurl.com/x9ky26ms.
[27] syzbot, “BUG: corrupted list in neigh create,” 2019, https://syzkaller.appspot.com/bug?id=de28cb0e686acfa1c9dbad1e11cbb0ac9b05caf2.
[28] syzbot, “Warning: refcount bug,” 2020, https://syzkaller.appspot.com/bug?id=8eceaff64a35a9f02c1315bbf12b7f262a0b4f08.
[29] syzbot, “General protection fault qrtr endpoint post,” 2020, https://syzkaller.appspot.com/bug?id=f56bbe6668873ee245986bbd23312b895fa5a50a.
[30] syzbot, “WARNING in get pi state,” 2017, https://syzkaller.appspot.com/bug?id=bb7fa48ebde0db8e3fc683a47bb69ab1dca895bc.
[31] syzbot, “BUG: corrupted list kobject add internal,” 2020, https://syzkaller.appspot.com/bug?id=f0ec9a394925aafbdf13d0a7e6af4cff860f0ed6.
[32] syzbot, “KASAN: general protection fault crypto chacha20 crypt,” 2018, https://syzkaller.appspot.com/bug?id=d767177245c54af614d5241159cce56995eef0db.
[33] syzbot, “WARNING: ODEBUG bug in io sqe files unregister,” 2020, https://syzkaller.appspot.com/bug?id=460cc948740aa1e715156c0edf5d5d397401d557.
[34] syzbot, “WARNING in vhost dev cleanup,” 2018, https://syzkaller.appspot.com/bug?id=0df4c1a9c14776f5fd163180e3580ad88b32649a.
[35] syzbot, “General protection fault in vb2 mmap,” 2019, https://syzkaller.appspot.com/bug?id=4cf5ee79b52a4797c5bd40a58bd6ab243d40de48.
[36] syzbot, “General protection fault in strlen,” 2018, https://syzkaller.appspot.com/bug?id=502c872feb9bbb5ad6494c349c7faa87a9f1777b.
[37] syzbot, “WARNING in dma buf vunmap,” 2019, https://syzkaller.appspot.com/bug?id=163388d1fb80146cd3ba22a11a5a1995c3eaaafe.
[38] syzbot, “BUG: unable to handle kernel request paging ethnl update bitset32,” 2019, https://syzkaller.appspot.com/bug?id=b36d7e444fe532685b683ae7980f4e3a184f0ad8.
[39] syzbot, “BUG: corrupted list skb release data,” 2017, https://syzkaller.appspot.com/bug?id=d1baeb189d38d5ba53517876c89b20d4e6857bc6.