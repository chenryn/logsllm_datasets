filesystem. By changing the filename manually in the request using Burp
Proxy, we were able to see other sensitive files. No doubt the developer did
not consider the possibility that the user could just ask for any file and,
thus, did not think to limit the files that could be accessed through the
user’s newsletters.
Worse still, we aren’t limited to files from the web application. We can
load any file from the filesystem that the IIS_USER has read access to. For
example, if you create a file called secret.txt on the C: drive, you can load it
through the newsletters functionality. Just substitute the file you want in the
request in Burp Suite. If we can find a way to upload files to a web applica-
tion, we can even use LFI vulnerability to execute malicious code on the
webserver.
remote File inclusion
Remote file inclusion (RFI) vulnerabilities allow attackers to load and
execute malicious scripts, hosted elsewhere, on a vulnerable server. In
Chapter 8, we used the open phpMyAdmin interface in XAMPP to write a
simple PHP shell and finally a PHP version of Meterpreter to the web server.
Though we are not uploading a file to the server here, the attack is similar.
If we can trick the vulnerable server into executing a remote script, we can
run commands on the underlying system.
Our site does not have a remote file inclusion vulnerability, but simple
vulnerable PHP code is shown here as an illustration.
An attacker can host a malicious PHP script (such as the meterpreter.php
script we used in Chapter 8) on their webserver and request the page with the
file parameter set to http:///meterpreter.php. The RFI vulnerability
would cause meterpreter.php to be executed by the webserver even though it is
hosted elsewhere. Of course, our example application is ASP.net not PHP, but
Msfvenom can create payloads in ASPX format for these sorts of apps.
Command execution
As noted earlier, the Newsletters folder contains a folder called Mike@Mike
.com. Logically, this suggests that the site may contain similar folders with
the email addresses of all users signed up to receive newsletters. Some part
of the application must be creating these folders as users register or sign
up for the newsletter. The application’s code is probably running a com-
mand to create the folders on the filesystem. Perhaps, again through lack of
input validation, we can run additional commands that the developer never
intended us to run.
Web Application Testing 327
As shown in Figure 14-18, the bottom
right of the web app contains a form to sign
up for newsletters. We suspect that when we
enter an email address, a folder is created for
that email address in the newsletters folder.
We guess that the email address input is
fed to a system command to create a direc-
tory in the newsletters folder. If the developer
does not properly sanitize user input, we may
be able to run additional commands using
the ampersand (&) symbol.
Figure 14-18: Newsletter
We’ll execute a command and send Signup
its output to a file in our application’s
C:\inetpub\wwwroot\Book\ directory, then
access the files directly to see the command’s
output. Run the ipconfig command on the Windows 7 target as shown here
to pipe the output from a system command such as ipconfig to the file test.txt
in the Book directory.
PI:EMAIL & ipconfig > C:\inetpub\wwwroot\Book\test.txt
When we browse to http://192.168.20.12/bookservice/test.txt, we see the
output of our ipconfig command, as shown in Figure 14-19.
Figure 14-19: Command execution output
328 Chapter 14
We will be limited to the privileges of the Internet Information Services
(IIS) user. Unfortunately for us, the Microsoft IIS application on Windows 7
systems runs as a separate account without the full privileges of a system
user: a better security scenario for the developer but a more challenging
one for us.
Though we don’t have full access, we will be able to gather a lot of
information about the system with the access we do have. For example, we
can use the dir command to find interesting files, or the command netsh
advfirewall firewall show rule name=all to see the rules in the Windows
firewall.
Since we are on a Windows system we cannot use wget from the com-
mand line to pull down an interactive shell, but we can use various other
methods to do so. In Chapter 8 we used TFTP to transfer a shell from our
Kali system to the Windows XP target. Windows 7 does not have a TFTP
client installed by default, but in Windows 7 we do have a powerful scripting
language called Powershell, which we can use for tasks such as downloading
and executing a file.
note A study of Powershell is outside of the scope of this book, but it is very helpful for post
exploitation on the latest Windows operating systems. A good reference can be found
here: http://www.darkoperator.com/powershellbasics/.
Cross-site scripting
Perhaps the most common and most debated web application security vul-
nerability is cross-site scripting (XSS). When such vulnerabilities are pres-
ent, attackers can inject malicious scripts into an otherwise innocuous site
to be executed in the user’s browser.
XSS attacks are typically broken into two categories: stored and reflected.
Stored XSS attacks are stored on the server and executed whenever a user visits
the page where the script is stored. User forums, reviews, and other places
where users can save input displayed to other users are ideal places for these
sorts of attacks. Reflective XSS attacks are not stored on the server but are cre-
ated by sending requests with the XSS attack itself. The attacks occur when
user input is included in the server’s response, for example, in error messages
or search results.
Reflected XSS attacks rely on a user sending a request with the XSS
attack included, so there will likely be some sort of social-engineering com-
ponent to the attack as well. In fact, having XSS might actually increase the
success of a social-engineering attack, because you can craft a URL that is
part of a real website—a website the user knows and trusts—and use the
XSS to, for instance, redirect the user to a malicious page. Like the other
attacks discussed in this chapter, XSS attacks rely on a lack of user input
sanitation, which allows us to create and run a malicious script.
Web Application Testing 329
Checking for a Reflected XSS Vulnerability
We should check any user input for XSS vulnerabilities. We’ll find that our
application has a reflected XSS vulnerability in the search functionality. Try
searching for the title xss in the Books Search box, as shown in Figure 14-20.
As shown in Figure 14-21, the search results page prints the original
user input as part of the results. If the user input is not properly sanitized,
this may be where we can use XSS.
Figure 14-20: Search Figure 14-21: Search results page
function
The typical first XSS test to try to run is a JavaScript alert box. The
following code will attempt to put up a JavaScript alert with the text xss. If
user input is not properly filtered, the script will be executed as part of the
search results page.
In some cases, the user’s browser will auto-
matically block obvious XSS attacks such as this
one, and Iceweasel is one such browser. Switch over
to your Windows 7 target with Internet Explorer.
As shown in Figure 14-22, the pop-up alert script
executes.
Having determined that reflective XSS is
present, we could try to leverage it to attack users.
Common attacks include stealing session cookies Figure 14-22: XSS
to send to an attacker-controlled site or embed- pop-up
ding a frame (a way of splitting an HTML page
into different segments) to prompt the user for
login credentials. A user may think that the frame
is part of the original page and enter his or her cre-
dentials, which are then sent offsite to the attacker.
330 Chapter 14
Leveraging XSS with the Browser Exploitation Framework
XSS issues tend to be overlooked. How much damage can an alert box that
says “XSS” do anyway? A good tool for leveraging XSS issues and uncovering
their true attack potential is the Browser Exploitation Framework (BeEF).
Using BeEF, we can “hook” a browser by tricking the user into browsing to
our BeEF server, or better yet using the BeEF JavaScript hook as a payload
in the presence of an XSS vulnerability like the one discussed previously.
Now change directories to /usr/share/beef-xss, and run ./beef, as shown
in Listing 14-3. This will start the BeEF server, including the web interface
and the attack hook.
root@kali:~# cd /usr/share/beef-xss/
root@kali:/usr/share/beef-xss# ./beef
[11:53:26][*] Bind socket [imapeudora1] listening on [0.0.0.0:2000].
[11:53:26][*] Browser Exploitation Framework (BeEF) 0.4.4.5-alpha
--snip--
[11:53:27][+] running on network interface: 192.168.20.9
[11:53:27] | Hook URL: http://192.168.20.9:3000/hook.js
[11:53:27] |_ UI URL: http://192.168.20.9:3000/ui/panel
[11:53:27][*] RESTful API key: 1c3e8f2c8edd075d09156ee0080fa540a707facf
[11:53:27][*] HTTP Proxy: http://127.0.0.1:6789
[11:53:27][*] BeEF server started (press control+c to stop)
Listing 14-3: Starting BeEF
Now in Kali, browse to http://192.168.20.9:3000/ui/panel to access the
BeEF web interface. You should be presented with a login page, like the one
shown in Figure 14-23.
Figure 14-23: BeEF login page
Web Application Testing 331
The default credentials for BeEF are beef:beef. After you enter them in
the login dialog, you are shown the web interface (Figure 14-24).
Figure 14-24: BeEF web interface
Currently no browsers are hooked in BeEF, so we need to trick some-
one into loading and running BeEF’s malicious hook.js script. Let’s return to
our XSS vulnerability in the Book Search box. This time, instead of using
an alert dialog, let’s leverage the issue to load BeEF’s hook.js in the target
browser. From the Windows 7 Internet Explorer browser, enter "" into the Book Search box,
and click Go. This time there will be no alert box or other indication to
the user suggesting that anything is amiss, but if you turn back to BeEF, you
should see the IP address of the Windows 7 box in the Online Browsers list
at the left of the screen, as shown in Figure 14-25.
In the details pane, with the IP address of Windows 7 selected in BeEF,
you can see details about the hooked browser as well as the underlying
system, such as versions and installed software. At the top of the pane are
additional tabs, such as Logs and Commands. Click Commands to see addi-
tional BeEF modules you can run against the hooked browser.
332 Chapter 14
Figure 14-25: A hooked browser
For example, as shown in Figure 14-26, navigate to Browser4Hooked
Domain4Create Alert Dialog. At the right of the screen, you have the option
to change the alert text. When you finish, click Execute at the bottom right.
Figure 14-26: Running a BeEF module
Web Application Testing 333
Turn back to your Windows 7 browser. You should see the pop-up
dialog, shown in Figure 14-27.
Figure 14-27: Causing an alert in the hooked browser
Another interesting BeEF command allows you to steal data from the
Windows clipboard. On the Windows 7 system, copy some text to the clip-
board. Now in BeEF, navigate in the Commands Module Tree to Host4Get
Clipboard. The text on the clipboard is displayed in the Command Results
Pane on the right, as shown in Figure 14-28.
Figure 14-28: Stealing clipboard information
In this section we have looked at only two simple examples of lever-
aging a hooked browser with BeEF. There is plenty more we can do. For
example, we can use the target browser as a pivot to start gathering infor-
mation about the local network with ping sweeps or even port scans. You
334 Chapter 14
can even integrate BeEF with Metasploit. On your pentests, you can use
BeEF as part of social-engineering attacks. If you can find an XSS in your
client’s web server, you can improve the results of your campaign by direct-
ing users not to a attacker-owned site but rather to the company website
they trust.
Cross-site request Forgery
Cross-site scripting exploits the trust a user has in a website, whereas a simi-
lar vulnerability class called cross-site request forgery (CSRF) exploits a website’s
trust in the user’s browser. Consider this scenario: A user is logged in to
a banking website and has an active session cookie. Naturally, the user is
also browsing to other websites in other tabs. The user opens a malicious
website that contains a frame or image tag that triggers a HTTP request
to the banking website with the correct parameters to transfer funds to
another account (presumably the attacker’s account). The banking website,
of course, checks to see that the user is logged in. Finding that the user’s
browser has a currently active session, the banking website executes the
command in the request, and the attacker steals the user’s money. The user,
of course, never initiated the transaction—he just had the misfortune of
browsing to a malicious website.
web application scanning with w3af
It is difficult to automate testing with a tool, particularly for custom appli-
cations. Nothing compares to a skilled web application tester with a proxy.
That said, several commercial web application scanners and some free and
open source scanners can automate tasks such as crawling the website and
searching for known security issues.
One open source web application scanner is the Web Application Attack
and Audit Framework (w3af). w3af is made up of plugins that perform differ-
ent web application–testing tasks, such as looking for URLs and parameters
to test and testing interesting parameters for SQL injection vulnerabilities.
Now start w3af, as shown here.
root@kali:~# w3af
The w3af GUI will be launched and should look similar to Figure 14-29.
On the left of the screen are the scan configuration profiles. By default
you are in an empty profile, which allows you to fully customize which w3af
plugins are run against your target. You can also use several preconfig-
ured profiles. For example, the OWASP_Top10 profile will crawl the app
with plugins from the discovery section as well as run plugins from the
audit section that look for vulnerabilities from the Open Web Application
Security Project (OWASP)’s top ten vulnerability categories. Enter the URL
to be scanned, as shown in Figure 14-29, and click Start at the right of the
window.
Web Application Testing 335
Figure 14-29: Using w3af
As the scan runs, details will be shown in the Logs tab, and issues dis-
covered will be added to the Results tab (Figure 14-30).
Figure 14-30: w3af results
336 Chapter 14
w3af finds the SQL injection vulnerability that we exploited at the start
of this chapter as well as some minor issues that are worth adding to your
pentest report. You can try other w3af profiles or create your own, custom-
izing which plugins are run against the app. w3af can even do a creden-
tialed scan, in which it has an active logged-in session with the app, giving
it access to additional functionality to search for issues.
summary
In this chapter we took a brief look at examples of common web application
vulnerabilities in a sample application built without the input sanitation
needed to mitigate many attacks. Our bookservice app has a SQL injection
vulnerability in its books details page. We were able to extract data from the
database and even get a system command shell.
We found a similar injection vulnerability in the XML-based login
functionality. We were able to use a crafted query to bypass authentica-
tion and log in as the first user stored in the AuthInfo.xml file. We were also
able to use the newsletter page to see the source of arbitrary pages in the
web application including the authentication information—the result of a
lack of access control on the pages as well as a local file inclusion issue. We
were able to run commands on the system by chaining them with the email
address to sign up for newsletters, and we were able to write the output of
commands to a file and then access them through the browser. We found
an example of reflective XSS in the search functionality. We used BeEF
to leverage this XSS issue and gain control of a target browser, giving us a
foothold in the system. Finally, we looked briefly at an open source web vul-
nerability scanner, w3af.
Web application testing deserves much more discussion than we can
devote to it in this book. All the issues covered in this chapter are discussed
in detail on OWASP’s website https://www.owasp.org/index.php/Main_Page/,
which is a good starting point for continuing your study of web application
security. OWASP also publishes a vulnerable app, Webgoat, which uses exer-