214
第7章动态链接
思上面的程序中，为什么使用argv作为基准来定位各个结构的地址，面不是采用
考
argc？提示：传值和传址。
7.6动态链接的步骤和实现
有了前面诸多的铺垫，我们终于要开始分析动志链接的实际链接步骤了。动态链接的步
骤基本上分为3步：先是启动动态链接器本身，然后装载所有需要的共享对象，最后是重定
位和初始化。
7.6.1动态链接器自举
我们知道动态链接器本身也是一个共享对象，但是事实上它有一些特殊性。对于普通共
享对象文件来说，它的重定位工作由动态链接器来完成：它也可以依赖于其他共享对象，其
中的被依赖的共享对象由动态链接器负责链接和装载。可是对于动态链接器本身来说，它的
重定位工作由谁来完成？它是否可以依赖于其他的共享对象？
必须有些特殊性。首先是，动态链接器本身不可以依赖于其他任何共享对家：其次是动态链
接器本身所需要的全局和静态变量的重定位工作由它本身完成，对于第一个条件我们可以人
为地控制，在编写动态链接器时保证不使用任何系统库、运行库：对于第二个条件，动态链
接器必须在启动时有段非常精巧的代码可以完成这项艰巨的工作而向时又不能用到全局
和静态变量。这种具有一定限制条件的启动代码往往被称为自举（Bootstrap）。
动态链接器入口地址即是白举代码的入口，当操作系统将进程控制权交给动态链接器
时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的GOT。而GOT的第
段。通过“dynamic”中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表
等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。从这一步开始，动态链
接器代码中才可以开始使用白已的全局变量和静态变量。
实际上在动态链接器的自举代码中，除了不可以使用全局变量和静志变量之外，甚至不
能调用函数，即动态链接器本身的函数也不能调用。这是为什么呢？其实我们在前面分析地
址无关代码时已经提到过，实际上使用PIC模式编译的共享对象，对于模块内部的函数调用
也是采用跟模块外部函数调用一样的方式，即使用GOT/PLT的方式，所以在GOT/PLT没有
被重定位之前，白举代码不可以使用任何全局变量，也不可以调用函数。下面这段注释来自
于Glibc 2.6.1源代码中的 elf/rtld.c:
程序员的自我修养一链接、装载与库
---
## Page 238
7.6动态链接的步骤和实现
215
/* Now life ic sane; we can call functions and accees global dat8.
Set up to uee the operating system faci1ities, and find out from
che operating system's program loader where to find the progran
header table in core. Put the rest of _dl_start into a separate
function, chat way the compiler cannot put accesses to the GOT
before ELF_DYNAMIC_RELOCATE.
这段注释写在自举代码的末尾，表示白举代码已经执行结束、“Nowlifeis sane”，可以
想象动态链接器的作者在此时大舒一口气，终于完成白举了，可以自由地调用各种函数并且
随意访间全局变量了。
7.6.2装载共享对象
完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个符号
表当中，我们u以称它为全局符号表（Global Symbol Table）。然后链接器开始寻找可执行
文件所依赖的共享对象，我们前面提到过“dynamic”段中，有一种类型的入口是
DT_NEEDED，它所指出的是该可执行文件（或共享对象）所依赖的共享对象。由此，链接
器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入到一个装载集
合中。然后链接器开始从集合里取一个所需要的共享对象的名字，找到相应的文件后打开该
文件，读取相应的ELF文件头和“dynamic”段，然后将它相应的代码段和数据段映射到进
程空间中。如果这个ELF共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名
字放到装载集合中，如此环直到所有依赖的共享对象都被装载进来为止，当然链接器可以
有不同的装载顺序，如果我们把依赖关系看作一个图的话，那么这个装裁过程就是一个图的
遍历过程，链接器可能会使用深度优先或者广度优先或者其他的顺序来遍历整个图，这取决
于链接器，比较常见的算法一般都是广度优先的。
当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当
所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要
的符号。
符号的优先级
在动态链接器按照各个模块之间的依赖关系，对它们进行装载并且将它们的符号并入到
全局符号表时，会不会有这么-种情况发生，那就是有可能两个不同的模块定义了同一个符
号？让我们来看看这样一个例子：共有4个共享对象al.s0、a2.so、bl.so和 b2.so，它们的
源代码文件分别为 al.c、a2.c、bl.c和b2.ci
#include 
/* a1.c * /
void a ()
程序员的自我修养——链接、装载与库
---
## Page 239
216
第7章动态链接
printf(*al.c\n*);
1
/* a2,c */
incIude 
void a()
printf(*a2,c\n*);
}
/* b1.c */
void aI);
void b1 ()
a (1 ;
/* b2.c */
void a (1 ;
void b2 ()
a () ;
可以看到al.c和a2.e中都定义了名字为“a”的函数。那么由于b1.c和 b2.c 都用到了
外部函数“a”，但由于源代码中没有指定依赖于哪个共享对象中的函数“a”，所以我们在编
译时指定依赖关系。我们假设bl.so 依赖于al.so，b2.so依赖丁a2.so，将b1.so与al.so进行
链接，b2.so与a2.so进行链接：
$ gcc -fPIc -shared a1.c -o a1.s0
$ gcc -fPIC
$ goc -fPIC
-8hared a2.c -O a2.80
-ghared b1.c a1.8o -o b1.80
$ gcc -fPIC
-shared b2.c a2.8o -o b2.80
$ 1dd b1.80
linux-gate.so.1 =>
a1,so > not found
(oxffffe000)
1ibc,8o,6 => /1ib/t1a/1686/cnov/1ibc,so.6 (0xb7e86000)
$1dd b2.s0
/1ib/1d1inux.8o.2 (0×80000000)
1inux-gate,8o.1 =>
a2.,so s> not found
1ibc,so.6 => /1ib/t1s/i686/cnov/1ibc.so.6 (0xb7e17000)
/1ib/1d-1inux.8o.2 (0x80000000)
那么当有程序同时使用b1.c中的函数b1和b2.c中的函数b2会怎么样呢？比如有程序
main.c:
#include 
/* nain.c */
void bl();
程序员的自我修养一链接、装载与库
---
## Page 240
7.6动态链接的步骤和实现
217
void b2 () ;
int main()
b1 () :
b2 () :
return 0;
然后我们将main.c编译成可执行文件并且运行：
a1. c
./main
al,c
"-XLinker-rpath/表示链接器在当前路径寻找共享对象，否则链接器会报无法找
到a1.so 和 a2.so 错误
很明显，main 依赖于 b1.so 和b2.so:b1.so 依赖于al.so;b2.so 依赖于a2.so，所以当动
态链接器对main程序进行动态链接时，bl.so、b2.so、al.so和a2.so都会被装载到进程的地
址空间，并且它们中的符号都会被并入到全局符号表，通过查看进程的地址空间信息可看到：
$cat/proc/14831/aaps
08048000-08049000 r-xp 00000000 08:01 1344643
08049000-0804a000
00000000 dxx
08:01 1344643
. /main
. /main
b7e83000-b7e84000 rwxp b7e83000
000:00
b7e84000-b7e85000
r-xp 00000000
08:01 1343481
./a2.60
b7e85000-b7e86000rwxp 00000000
08:01 1343481
./a2.50
b7e86000-b7e87000
b7e87000-b7e88000
r-xp 00000000
rwxp
00000000
08:01 1343328
08:01 1343328
. /a1.80
b7e88000-b7fcc000 r-xp 00000000 08:01 1488993
. /a1.80
b7fcc000-b7fcd000 r-xp 00143000 08:01 1488993
/1ib/t18/i686/cmov/1ibc-2 .6 .1 .80
/1ib/t1s/i686/cmov/1ibc-2.6.1.so
/1ib/t1s/i686/cmov/1ibc-2.6.1.80
b7fcd000-b7fcf000 rwxp 00144000 08:01 1488993
b7fde000-b7fdf000
00000000dx
00000000 dx-1
08:01 1344641
08:01 1344641
. /b2.s0
b7fdf000-b7fe0000
08:01 1344637
./b1.80
./b2.80
b7fe0000-b7fe1000
b7fe1000-b7fe2000
I -xp
rwxp
90000000
00000000
08:01 1344637
0002q x
000:00
./b1.80
b7fe2000-b7fe4000
b7fe4000-b7ffe000
r-xp 00000000
08:01 1455332
/1ib/1d-2.6.1.s0
b7ffe000-b8000000
rwxp
 00019000
08:01 1455332
/1ib/1d-2.6.1.so
bfdd2000-bfde7000
ffffe00o-ffftto00 r-xp 0ooo0o00 00:00 0
000:00
[vdso]
[stack]
这4个共享对象的确都被装载进来了，那al.so中的函数a和a2.so中的函数a是不是冲
突了呢？为什么main的输出结果是两个“al.e”呢？也就是说a2.so中的函数a似乎被忽略
了。这种一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象又被称
程序员的自我修养一键接、装载与库
---
## Page 241
218
第7章动芯链摄
为共享对象全局符号介入（Global Symbol Interpose）。
关于全局符号介入这个问题，实际上Linux下的动态链接器是这样处理的：它定义了一
个规则，那就是当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加
入的符号被忽略。从动态链接器的装载顺序可以看到，它是按照广度优先的顺序进行装载的，
首先是main，然后是b1.s0、b2.s0、al.so，最后是a2.s0。当a2.so 中的函数a要被加入全局
符号表时，先前装载al.so时，al.so中的函数a已经存在于全局符号表，那么a2.so中的函
数a只能被忽略。所以整个进程中，所有对于符合“a”的引用都会被解析到al.so中的函数
由于存在这种重名符号被直接忽略的问题，当程序使用大量共享对象时应该非常小心符
号的重名问题，如果两个符号重名文执行不同的功能，那么程序运行时可能会将所有该符号
错误。
全局符号介入与地址无关代码
前面介绍地址无关代码时，对于第一类模块内部调用或跳转的处理时，我们简单地将其
当作是相对地址调用/跳转。但实际上这个问题比想象中要复杂，结合全局符号介入，关于
调用方式的分类的解释会更加清楚。还是拿前面“pic.c”的例子来看，由于可能存在全局符
号介入的问题，foo函数对于bar的调用不能够采用第一类模块内部调用的方法，因为一且
bar函数由于全局符号介入被其他模块中的间名函数覆盖，那么foo如果采用相对地址调用
的话，那个相对地址部分就需要重定位，这又与共享对象的地址无关性矛盾。所以对于bar()
函数的调用，编译器只能采用第三种，即当作模块外部符号处理，barO函数被覆盖，动态链
接器只需要重定位“gotplt”，不影响共享对象的代码段。
为了提高模块内部函数调用的效率，有一个办法是把bar0函数变成编译单元私有函数，
即使用“static”关键字定义barO函数，这种情况下，编译器要确定bar(O函数不被其他模块
覆盖，就可以使用第一类的方法，即模块内部调用指令，可以加快函数的调用速度。
7.6.3重定位和初始化
当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，
将它们的GOT/PLT中的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了
进程的全局符号表，所以这个修正过程也显得比较容易，跟我们前面提到的地址重定位的原
理基本相同。在前面介绍动态链接下的重定位表时，我们已经碰到过几种重定位类型，每种
重定位入口地址的计算方式我们在这里就不再重复介绍了。
程序员的自我修养一链接、装载与库
---
## Page 242
7.6动态链接的步骤和实现
219
中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的C++的全局