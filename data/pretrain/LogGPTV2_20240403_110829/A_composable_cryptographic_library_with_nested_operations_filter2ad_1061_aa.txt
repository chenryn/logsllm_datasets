title:A composable cryptographic library with nested operations
author:Michael Backes and
Birgit Pfitzmann and
Michael Waidner
A Composable Cryptographic Library with Nested
Operations
(Extended Abstract)
Michael Backes
IBM Research Division
R¨uschlikon, Switzerland
PI:EMAIL
Birgit Pﬁtzmann
IBM Research Division
R¨uschlikon, Switzerland
PI:EMAIL
Michael Waidner
IBM Research Division
R¨uschlikon, Switzerland
PI:EMAIL
ABSTRACT
We present the ﬁrst idealized cryptographic library that can be used
like the Dolev-Yao model for automated proofs of cryptographic
protocols that use nested cryptographic operations, while coming
with a cryptographic implementation that is provably secure under
active attacks.
Categories and Subject Descriptors
E.3 [Data]: Data Encryption; F.1.2 [Theory of Computation]:
Computation by Abstract Devices, Modes of Computation
General Terms
Security, Theory, Veriﬁcation
Keywords
Cryptography, Simulatability, Security Analysis of Protocols,
Cryptographically Composable Operators
1.
INTRODUCTION
Many practically relevant cryptographic protocols like SSL/TLS,
S/MIME, IPSec, or SET use cryptographic primitives like signa-
ture schemes or encryption in a black-box way, while adding many
non-cryptographic features. Vulnerabilities have accompanied the
design of such protocols ever since early authentication protocols
like Needham-Schroeder [43, 25], over carefully designed de-facto
standards like SSL and PKCS [52, 16], up to current widely de-
ployed products like Microsoft Passport [29]. However, proving
the security of such protocols has been a very unsatisfactory task
for a long time.
One possibility was to take the cryptographic approach. This
means reduction proofs between the security of the overall system
and the security of the cryptographic primitives, i.e., one shows that
if one could break the overall system, one could also break one of
the underlying cryptographic primitives with respect to their cryp-
tographic deﬁnitions, e.g., adaptive chosen-message security for
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’03, October 27–31, 2003, Washington, DC, USA.
Copyright 2003 ACM 1-58113-738-9/03/0010 ...$5.00.
signature schemes. For authentication protocols, this approach was
ﬁrst used in [15]. In principle, proofs in this approach are as rigor-
ous as typical proofs in mathematics. In practice, however, human
beings are extremely fallible with this type of proofs. This is not
due to the cryptography, but to the distributed-systems aspects of
the protocols. It is well-known from non-cryptographic distributed
systems that many wrong protocols have been published even for
very small problems. Hand-made proofs are highly error-prone be-
cause following all the different cases how actions of different ma-
chines interleave is extremely tedious. Humans tend to take wrong
shortcuts and do not want to proof-read such details in proofs by
others. If the protocol contains cryptography, this obstacle is even
much worse: Already a rigorous deﬁnition of the goals gets more
complicated, and often not only trace properties (integrity) have to
be proven but also secrecy. Further, in principle the complexity-
theoretic reduction has to be carried out across all these cases, and
it is not at all trivial to do this rigorously. In consequence, there
is almost no real cryptographic proof of a larger protocol, and sev-
eral times supposedly proven, relatively small systems were later
broken, e.g., [47, 26].
The other possibility was to use formal methods. There one
leaves the tedious parts of proofs to machines, i.e., model check-
ers or automatic theorem provers. This means to code the cryp-
tographic protocols into the language of such tools, which may
need more or less start-up work depending on whether the tool al-
ready supports distributed systems or whether interaction models
have to be encoded ﬁrst. None of these tools, however, is currently
able to deal with reduction proofs. Nobody even thought about
this for a long time, because one felt that protocol proofs could be
based on simpler, idealized abstractions from cryptographic prim-
itives. Almost all these abstractions are variants of the Dolev-Yao
model [27], which represents all cryptographic primitives as opera-
tors of a term algebra with cancellation rules. For instance, public-
key encryption is represented by operators E for encryption and D
for decryption with one cancellation rule, D(E(m)) = m for all
m. Encrypting a message m twice in this model does not yield an-
other message from the basic message space but the term E(E(m)).
Further, the model assumes that two terms whose equality cannot
be derived with the cancellation rules are not equal, and every term
that cannot be derived is completely secret. However, originally
there was no foundation at all for such assumptions about real cryp-
tographic primitives, and thus no guarantee that protocols proved
with these tools were still secure when implemented with real cryp-
tography. Although no previously proved protocol has been broken
when implemented with standard provably secure cryptosystems,
this was clearly an unsatisfactory situation, and artiﬁcial counterex-
amples can be constructed.
220Three years ago, efforts started to get the best of both worlds.
Essentially, [46, 48] started to deﬁne general cryptographic mod-
els that support idealization that is secure in arbitrary environments
and under arbitrary active attacks, while [2] started to justify the
Dolev-Yao model as far as one could without such a model. Both
directions were signiﬁcantly extended in subsequent papers, in par-
ticular [1, 49, 19, 5].
Nevertheless, this paper is the ﬁrst that offers a provably secure
variant of the Dolev-Yao model for proofs that people typically
make with the Dolev-Yao model, because for the ﬁrst time we cover
both active attacks and nested cryptographic operations. This new
property combination is essential: First, most cryptographic proto-
cols are broken by active attacks, e.g., man-in-the-middle attacks or
attacks where an adversary reuses a message from one protocol step
in a different protocol step where it suddenly gets a different se-
mantics. Such attacks are not covered by [2, 1]. Secondly, the main
use of the Dolev-Yao model is to represent nested protocol mes-
sages like Epkev (signsksu
(m, N1), N2), where m denotes an arbi-
trary message and N1, N2 two nonces. No previous idealization
proved in the reactive cryptographic models contains abstractions
from cryptographic primitives (here mainly encryption and signa-
tures, but also the nonces and the list operation) that can be used in
such nested terms. Existing abstractions are either too high-level,
e.g., the secure channels in [49, 5] combine encryption and signa-
tures in a ﬁxed way. Or they need immediate interaction with the
adversary [19, 18], i.e., the adversary learns the structure of every
term any honest party ever builds, and even every signed message.
This abstraction is not usable for a term as above because one may
want to show that m is secret because of the outer encryption, but
the abstraction gives m to the adversary. (A similar immediate ap-
plication of the model of [49] to such primitives would avoid this
problem, but instead keep all signatures and ciphertexts in the sys-
tem, so that nesting is also not possible.) Finally, there exist some
semi-abstractions which still depend on cryptographic details [39,
49]. Thus they are not suitable for abstract protocol representations
and proof tools, but we use such a semi-abstraction of public-key
encryption as a submodule below.
The ﬁrst decision in the design of an ideal library that supports
both nesting and general active attacks was how we can represent
an idealized cryptographic term and the corresponding real mes-
sage in the same way to a higher protocol. This is necessary for
using the reactive cryptographic models and their composition the-
orems. We do this by handles. In the ideal system, these handles
essentially point to Dolev-Yao-like terms, while in the real system
they point to real cryptographic messages. Our model for storing
the terms belonging to the handles is stateful and in the ideal sys-
tem comprises the knowledge of who knows which terms. Thus
our overall ideal cryptographic library corresponds more to “the
CSP Dolev-Yao model” or “the Strand-space Dolev-Yao model”
than the pure algebraic Dolev-Yao model. Once one has the idea of
handles, one has to consider whether one can put the exact Dolev-
Yao terms under them or how one has to or wants to deviate from
them in order to allow a provably secure cryptographic realization,
based on a more or less general class of underlying primitives. An
overview of these deviations is given in Section 1.2, and Section 1.3
surveys how the cryptographic primitives are augmented to give a
secure implementation of the ideal library.
The vast majority of the work was to make a credible proof
that the real cryptographic library securely implements the ideal
one. This is a hand-made proof based on cryptographic primi-
tives and with many distributed-systems aspects, and thus with all
the problems mentioned above for cryptographic proofs of large
protocols.
Indeed we needed a novel proof technique consisting
of a probabilistic, imperfect bisimulation with an embedded static
information-ﬂow analysis, followed by cryptographic reductions
proofs for so-called error sets of traces where the bisimulation did
not work. As this proof needs to be made only once, and is in-
tended to be the justiﬁcation for later basing many protocol proofs
on the ideal cryptographic library and proving them with higher
assurance using automatic tools, we carefully worked out all the
tedious details, and we encourage some readers to double-check
the 68-page full version of this paper [10]. Based on our experi-
ence with making this proof and the errors we found by making it,
we strongly discourage the reader against accepting idealizations
of cryptographic primitives where a similar security property, sim-
ulatability, is claimed but only the ﬁrst step of the proof, the deﬁni-
tion of a simulator, is made.
1.1 Further Related Literature
Both the cryptographic and the idealizing approach at proving
cryptographic systems started in the early 80s. Early examples of
cryptographic deﬁnitions and reduction proofs are [33, 34]. Ap-
plied to protocols, these techniques are at their best for relatively
small protocols where there is still a certain interaction between
cryptographic primitives, e.g., [14, 51]. The early methods of au-
tomating proofs based on the Dolev-Yao model are summarized
in [37]. More recently, such work concentrated on using existing
general-purpose model checkers [40, 42, 24] and theorem provers
[28, 45], and on treating larger protocols, e.g., [12].
Work intended to bridge the gap between the cryptographic ap-
proach and the use of automated tools started independently with
[46, 48] and [2]. In [2], Dolev-Yao terms, i.e., with nested opera-
tions, are considered speciﬁcally for symmetric encryption. How-
ever, the adversary is restricted to passive eavesdropping. Conse-
quently, it was not necessary to deﬁne a reactive model of a sys-
tem, its honest users, and an adversary, and the security goals were
all formulated as indistinguishability of terms. This was extended
in [1] from terms to more general programs, but the restriction to
passive adversaries remains, which is not realistic in most practi-
cal applications. Further, there are no theorems about composi-
tion or property preservation from the abstract to the real system.
Several papers extended this work for speciﬁc models or speciﬁc
properties. For instance, [35] speciﬁcally considers strand spaces
and information-theoretically secure authentication only. In [38] a
deduction system for information ﬂow is based on the same opera-
tions as in [2], still under passive attacks only.
The approach in [46, 48] was from the other end: It starts with a
general reactive system model, a general deﬁnition of cryptograph-
ically secure implementation by simulatability, and a composition
theorem for this notion of secure implementation. This work is
based on deﬁnitions of secure function evaluation, i.e., the com-
putation of one set of outputs from one set of inputs [32, 41, 11,
17]; earlier extensions towards reactive systems were either without
real abstraction [39] or for quite special cases [36]. The approach
was extended from synchronous to asynchronous systems in [49,
19]. All the reactive works come with more or less worked-out
examples of abstractions of cryptographic systems, and ﬁrst tool-
supported proofs were made based on such an abstraction [5, 4]
using the theorem prover PVS [44]. However, even with a com-
position theorem this does not automatically give a cryptographic
library in the Dolev-Yao sense, i.e., with the possibility to nest ab-
stract operations, as explained above. Our cryptographic library
overcomes these problems. It supports nested operations in the in-
tuitive sense; operations that are performed locally are not visible
to the adversary. It is secure against arbitrary active attacks, and
works in the context of arbitrary surrounding interactive protocols.
This holds independently of the goals that one wants to prove about
the surrounding protocols; in particular, property preservation the-
orems for the simulatability deﬁnition we use have been proved for
integrity, liveness, and non-interference [4, 9, 6, 8].
We have already exempliﬁed the usefulness of the cryptographic
library by conducting the ﬁrst cryptographically sound security
proof of the well-known Needham-Schroeder-Lowe protocol [7].
Since the proof relies on idealizations of cryptography it has all the
advantages explained in the text; in particular, the proof is suited for
formal proof tools. Simultaneously and independently to this work,
another cryptographically sound security proof of this protocol was
invented in [53]. This proof is done from scratch in the crypto-
graphic setting and is hence vulnerable to the problems mentioned
before. However, it is fair to mention that this proof establishes
the security property of matching conversations whereas our proof
currently only strives for a weaker authentication requirement.
1.2 Overview of the Ideal Cryptographic Li-
brary
The ideal cryptographic library offers its users abstract crypto-
graphic operations, such as commands to encrypt or decrypt a mes-
sage, to make or test a signature, and to generate a nonce. All
these commands have a simple, deterministic semantics. In a reac-
tive scenario, this semantics is based on state, e.g., of who already
knows which terms. We store state in a “database”. Each entry
has a type, e.g., “signature”, and pointers to its arguments, e.g., a
key and a message. This corresponds to the top level of a Dolev-
Yao term; an entire term can be found by following the pointers.
Further, each entry contains handles for those participants who al-
ready know it. Thus the database index and these handles serve as
an inﬁnite, but efﬁciently constructible supply of global and local
names for cryptographic objects. However, most libraries have ex-
port operations and leave message transport to their users (“token-
based”). An actual implementation of the simulatable library might
internally also be structured like this, but higher protocols are only
automatically secure if they do not use this export function except
via the special send operations.
The ideal cryptographic library does not allow cheating. For in-
stance, if it receives a command to encrypt a message m with a cer-