# 31 \| 编程范式游记（2）- 泛型编程上一篇文章中，我从 C语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的C 语言已经无法满足更高层次的编程的需要。于是，C++ 出现了。
# C++ 语言1980 年，AT&T 贝尔实验室的**Bjarne Stroustrup**创建的 C++语言横空出世，它既可以全面兼容 C语言，又巧妙揉和了一些面向对象的编程理念。现在来看，不得不佩服Stroustrup 的魄力。在这里，我也向你推荐一本书，书名是《C++语言的设计和演化》。这本书系统介绍了 C++诞生的背景以及初衷，书的作者就是[Stroustrup](https://book.douban.com/author/362072/)本人，所以你可以非常详细地从语言创建者的角度了解他的设计思路和创新之旅。当然，就是在今天，C++这门语言也还有很多争议，这里我不细说。如果你感兴趣的话，可以看看我几年前在酷壳上发表的文章《[C++的坑真的多吗？](https://coolshell.cn/articles/7992.html)》。从语言角度来说，实际上早期 C++ 的许多工作是对 C的强化和净化，并把完全兼容 C 作为强制性要求（这也是 C++复杂晦涩的原因，这点 Java 就干得比 C++ 彻底得多）。在 C89、C99 这两个 C语言的标准中，有许多改进都是从 C++ 中引进的。可见，C++ 对 C 语言的贡献非常之大。是的，因为 C++ 很大程度就是用来解决 C语言中的各种问题和各种不方便的。比如：-   用引用来解决指针的问题。-   用 namespace 来解决名字空间冲突的问题。-   通过 try-catch 来解决检查返回值编程的问题。-   用 class    来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。-   通过重载操作符来达到操作上的泛型。（比如，消除[上一篇文章](https://time.geekbang.org/column/article/301)中提到的比较函数`cmpFn`，再比如用`>>`操作符消除`printf()`的数据类型不够泛型的问题。）-   通过模板 template    和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。-   用 RAII、智能指针的方式，解决了 C    语言中因为需要释放资源而出现的那些非常 ugly    也很容易出错的代码的问题。-   用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。
# C++ 泛型编程C++ 是支持编程范式最多的一门语言，它虽然解决了很多 C语言的问题，但我个人觉得它最大的意义是解决了 C语言泛型编程的问题。因为，我们可以看到一些 C++的标准规格说明书里，有一半以上都在说明 STL的标准规格应该是什么样的，这说明泛型编程是 C++ 重点中的重点。理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。**而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？**``{=html}我们来看看 C++ 是如何有效解决程序泛型问题的，我认为有三点。**第一，它通过类的方式来解决**。-   类里面会有构造函数、析构函数表示这个类的分配和释放。-   还有它的拷贝构造函数，表示了对内存的复制。-   还有重载操作符，像我们要去比较大于、等于、不等于。这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。**第二，通过模板达到类型和算法的妥协**。-   模板有点像    DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。-   模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。模板很好地取代了 C 时代宏定义带来的问题。**第三，通过虚函数和运行时类型识别**。-   虚函数带来的多态在语义上可以支持"同一类"的类型泛型。-   运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。这样一来，就可以写出基于抽象接口的泛型。拥有了这些 C++ 引入的技术，我们就可以做到 C 语言很难做到的泛型编程了。正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：1.  算法的泛型；2.  类型的泛型；3.  数据结构（数据容器）的泛型。
## C++ 泛型编程的示例 - Search 函数就像前面的`search()`函数，里面的 `for(int i=0; iIter search(Iter pStart, Iter pEnd, T target) {for(Iter p = pStart; p != pEnd; p++) {if ( *p == target ) return p;}return NULL;}在 C++ 的泛型版本中，我们可以看到：-   使用`typename T`抽象了数据结构中存储数据的类型。-   使用`typename Iter`，这是不同的数据结构需要自己实现的"迭代器"，这样也就抽象掉了不同类型的数据结构。-   然后，我们对数据容器的遍历使用了`Iter`中的`++`方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。-   在函数的入参上使用了`pStart`和`pEnd`来表示遍历的起止。-   使用`*Iter`来取得这个"指针"的内容。这也是通过重载 `*`    取值操作符来达到的泛型。当然，你可能会问，为什么我们不用标准接口`Iter.Next()`取代`++`，用`Iter.GetValue()`来取代`*`，而是通过重载操作符？其实这样做是为了兼容原有C 语言的编程习惯。说明一下，所谓的`Iter`，在实际代码中，就是像`vector::iterator`或`map::iterator`这样的东西。这是由相应的数据容器来实现和提供的。注：下面是 C++ STL 中的`find()`函数的代码。    template  InputIterator find (InputIterator first, InputIterator last, const T& val){  while (first!=last) {    if (*first==val) return first;    ++first;  }  return last;}
## C++ 泛型编程示例 - Sum 函数也许你觉得到这一步，我们的泛型设计就完成了。其实，还远远不够。`search`函数只是一个开始，我们还有很多别的算法会让问题变得更为复杂。我们再来看一个`sum()`函数。先看 C 语言版：    long sum(int *a, size_t size) {long result = 0;for(int i=0; iT sum(Iter pStart, Iter pEnd) {T result = 0;for(Iter p=pStart; p!=pEnd; p++) {result += *p;}return result;}你看到了什么样的问题？这个代码中最大的问题就是 `T result = 0;`这条语句：-   那个`0`假设了类型是`int`；-   那个`T`假设了 Iter 中出来的类型是`T`。这样的假设是有问题的，如果类型不一样，就会导致转型的问题，这会带来非常buggy 的代码。那么，我们怎么解决呢？
## C++ 泛型编程的重要技术 - 迭代器我们知道`Iter`在实际调用者那会是一个具体的像`vector::iterator`这样的东西。在这个声明中，`int`已经被传入`Iter`中了。所以，定义`result`的`T`应该可以从`Iter`中来。这样就可以保证类型是一样的，而且不会有被转型的问题。所以，我们需要精心地实现一个"迭代器"。下面是一个"精简版"的迭代器（我没有把C++ STL代码里的迭代器列出来，是因为代码太多太复杂，我这里只是为了说明问题）。    template class container {public:class iterator {public:typedef iterator self_type;typedef T   value_type;typedef T*  pointer;typedef T& reference; reference operator*();pointer operator->();bool operator==(const self_type& rhs)；bool operator!=(const self_type& rhs)；self_type operator++() { self_type i = *this; ptr_++; return i; }self_type operator++(int junk) { ptr_++; return *this; }......private:pointer _ptr;}; iterator begin();iterator end();......};上面的代码是我写的一个迭代器（这个迭代器在语义上是没有问题的），我没有把所有的代码列出来，而把它的一些基本思路列了出来。这里我说明一下几个关键点。-   首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。-   它需要重载一些操作符，比如：取值操作`*`、成员操作`->`、比较操作`==`和`!=`，还有遍历操作`++`，等等。-   然后，还要`typedef`一些类型，比如`value_type`，告诉我们容器内的数据的实际类型是什么样子。-   还有一些，如`begin()`和`end()`的基本操作。-   我们还可以看到其中有一个`pointer _ptr`的内部指针来指向当前的数据（注意，`pointer`就是    `T*`）。好了，有了这个迭代器后，我们还要解决`T result = 0`后面的这个`0`的问题。这个事，算法没有办法搞定，最好由用户传入。于是出现了下面最终泛型的`sum()`版函数。    template typename Iter::value_typesum(Iter start, Iter end, T init) {typename Iter::value_type result = init;while (start != end) {result = result + *start;start++;}return result;}我们可以看到`typename Iter::value_type result = init`这条语句是关键。我们解决了所有的问题。我们如下使用：    container c;container::iterator it = c.begin();sum(c.begin(), c.end(), 0);这就是整个 STL 的泛型方法，其中包括：-   泛型的数据容器；-   泛型数据容器的迭代器；-   然后泛型的算法就很容易写了。