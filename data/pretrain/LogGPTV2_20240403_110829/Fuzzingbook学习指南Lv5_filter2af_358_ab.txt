  * 那么新标签现在是+
  * 重复….
如此，我们就可以生成我们语法要求格式的字符串，同时我们也可以直观看到，如果不限制循环的次数，他完全可以-1111···这样一直生成下去。解包的思想在这里发挥了重要作用。在Fuzzingbook还给了很多例子和如何将这种语法封装为工具箱，因为篇幅限制就不再是详述了，大家可以自行参考。
看了上面的代码我们又会发现一些问题：
  * 我们的迭代有点”傻“，我们要遍历字符串，随机抽取，随机生成，这个过程过于繁琐，直接影响效率。而且实际上我们是无法从已有的生成记录中再去进行“学习”的，它的遍历过程没有留下有效的结构信息。
  * 我们控制不住它，即使是我们限制了迭代次数，在迭代范围内它也是过于随机了，导致生成的结果我们能插手的地方很少，我们没有办法以合适的粒度对其进行限制。而一不小心，它还经常生成长字符串。
对于第二个问题，我们还可以想办法进行改善，比如，我们限制标签的最大深度和最小深度，超过或者小于这个深度时，标签就不再出现，比如：
    "":
            [(" + ", opts(min_depth=10)),
             (" - ", opts(max_depth=2)),
             ""]
但这样的解决方案能力有限，因为这样操作相当于我们人为限制了语法的“值域”，也就是说输出的结果范围被限制了，我们可能无法生成所需的fuzzing字符串。而且，我们永远没有探索最短、最长等特殊表达式的能力，比如1+1，这样的表达式你就只能等着它自己慢慢生成。
而对于第一个问题，因为我们使用简单的字符产组织，结构如此，永远没办法改善，只能另谋他路。
## 语法树
在算法问题中，我们常常一言不合就用树，因为树状结构简单清晰，还弥补了很多数据结构的缺点（虽然很多优点它也没继承），那么我们在这个问题上能不能使用树结构呢？我们简单思考：
  * 有限状态机的结构与树非常契合，我们可以认为树的当前的节点就是一个状态，而这个状态的下一个状态，我们可以用该节点的子节点表示，有几个就挂几个子节点，可以一直继续下去。也就是说，节点的种类有限，节点的数量无限。同样用在我们的语法规则上也适用，我们生成的标签就可以作为节点，我们可以按照规则选择接下来的标签挂到节点上。
  * 我们语法规则是马尔科夫链（当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态。但要注意，有限状态机本身不能算是马尔可夫链，因为实际上有限状态机的状态变换时一定的，没有概率一说，但我们生成字符串的规则却是带有随机性的）的一种特殊情况，它的每次状态变化都只依赖于当前状态，和之前的都没关系，所以对于树结构，我们只需要看当前的叶子节点即可，不需要关心前面节点的情况。
理论上的东西太抽象了，我们来看个例子，我们给出如下的语法规则（实际上就是四则运算规则）：
我们按照上面的思路试试能不能建树：
  * start节点作为根节点
  * start节点可以转移到expr节点，挂上expr节点
  * expr节点有三个包，随机选一个挂上，比如expr + term包
  * 现在我们有三个节点，其中，+不是非终端节点，它的使命已经完成，我们对其他两个节点重复操作
  * 重复直到所有的叶子节点都是终端节点即可。
如此，我们得到了2+2这个数学表达式。这个东西我们管它叫派生树，也可以叫语法树。我们看看它解决上面的问题了吗？
  * 时间上，我们遍历时不需要考虑整棵树，只需要检查叶子节点即可，效率大大提高
  * 在控制方面，我们对于每一个叶子节点在遍历过程中都是可控的，我们可以人为在任何一步设置限定，不但不影响性能，编写程序也方便。
并且，我们可以看到，树结构还为我们提供了清晰的结构，让我们有了对于语法的“具体格式”，上面一章虽然也有结构信息保留下来，但结构信息杂乱，难以提取有效格式，而树结构天然就可供我们使用。我们可以进行大量的测试，我们手里有了大量树结构及其对应的代码覆盖等指标，我们完全可以选择其中优质的树结构进行相似度比较，从而提取更加优秀的树结构供我们使用。
比如bc人为限制不能输入+，如果我们按照普通的四则运算语法显然会导致大量的失效，但我们可以从有效的树中进行相似度比较，提取相似部分，这样我们就能慢慢去接近这套规则。因为树结构的存在，我们完全可以自由使用前面的知识，“养蛊”式的优化我们的树。
说完了理论，来简单看看代码实现，对于树结构，我们在python中有一套经典的保存方案：
    derivation_tree = ("",
                       [None])
即用二元组表示一棵树，其中，第一个表示节点，第二个是一个list，表示孩子。这套方案最大的问题是没法解决边的问题，但是我们现在对边也没什么讲究。
    class GrammarFuzzer(GrammarFuzzer):
        def choose_node_expansion(self, node, possible_children):
            return random.randrange(0, len(possible_children))
        def expand_node_randomly(self, node):
            (symbol, children) = node
            assert children is None
            expansions = self.grammar[symbol]
            possible_children = [self.expansion_to_children(
                expansion) for expansion in expansions]
            index = self.choose_node_expansion(node, possible_children)
            chosen_children = possible_children[index]
            chosen_children = self.process_chosen_children(chosen_children,
                                                           expansions[index])
            return (symbol, chosen_children)
对于节点的扩充，其实和之前类似，都是先查语法，找到当前标签的包，随机选择一个，然后把包里所有的标签挂到节点上即可。到此，我们已经完全可以利用语法树来为我们生成fuzzing字符串了。
但是我们还不满意，我们说了树结构能帮助我们控制生成的过程，那应该怎么做呢？我们一般会定义如下的概念：
  * 节点最小代价，即节点到终端节点需要消耗的最小“步数”，比如`` → `` → `` → `` → `` → 1，expr走到终端节点最短路径如此，故其最小代价是5
  * 节点最大代价，即节点到终端节点最大需要的步数，对于有递归的节点来说，就是无限大，对于digit来说，就是1
这两个概念可以帮助我们限制节点的走向，比如，我们可以规定，每一个节点都必须以最小的代价来进行生成（代码非常简单，我们检查节点所有可能的孩子的代价，对于包的情况，就是包内所有节点的代价的和，选择最小的挂上去即可），那么我们就会得到
我们就得到了一棵相对简单的树，它的表达式长度也让人比较满意。我们同样也可以按照最大代价进行生成，我们限制递归次数即可，如此我们就可以得到较长的表达式。但是这些会导致“僵化”问题，即路径固定，比如如果我们的最短路径只有上面一条，导致我们一直走，那我们生成的格式就永远是x+y/z了
我们目前实际上有了三种节点策略：
  * 最小代价生成，即找最小代价的，会造成“僵化”
  * 最大代价生成，即找最大代价的，在递归较多的语法中，“僵化”可能性较小
  * 随机找一个，不会“僵化”
实际使用中，我们可以对每个节点采取不同的策略，比如有的采取最小，有的采取随机，有的采取最大，然后再人为限制递归次数，我们就即可以保证生成字符串多种多样，得到较为理想的结果了。
## 总结
我们从没头没脑的随机生成fuzzing字符串到现在终于可以利用语法“随心所欲”的生成符合我们要求格式的字符串，但在语法方面，仍有大量的知识等着我们学习，下一篇内容仍将聚焦于语法部分，期待我们的史莱姆再次升级。