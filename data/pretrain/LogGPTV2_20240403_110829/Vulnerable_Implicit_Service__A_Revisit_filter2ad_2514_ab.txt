bound service will be destroyed if all callers have been destroyed.
A messaging object named Intent is passed into startService()
and bindService(). (cid:140)ere are two types of intents, explicit intent
and implicit intent. Explicit intents specify the component name or
package name in the intent explicitly. In contrast, implicit intents
only specify some general information, such as the action to be
performed, the data to operate on, or the category of the action etc.,
and delegate the task of evaluating the matching components to the
Android system. For a service to be started by an implicit intent, the
service should de(cid:128)ne one or more Intent Filters, which specify the
types of intents that the service can respond to. A service matches
an implicit intent only when the action, data, and category de(cid:128)ned
in the intent object match one of the Intent Filters de(cid:128)ned by the
service. When starting service components through an implicit
intent, the Android system calculates the matching values of all
the Intent Filters to this intent. If one intent matches multiple
services, the system selects the proper service automatically in the
background.
2.2 SDK Version
Each application has a corresponding  declaration [22]
in its Manifest.xml (cid:128)le, which de(cid:128)nes the application’s compatibility
with one or more versions of the Android platform, by means of an
API Level integer. In total, three a(cid:138)ributes could be de(cid:128)ned in the
 declaration, i.e., minSdkV ersion, maxSdkV ersion, and
tar❕etSdkV ersion. (cid:140)e (cid:128)rst two a(cid:138)ributes designate the minimum
and maximum API Levels designed for the application to run. In
other words, installing the application on a system with the API
Level lower than minSdkV ersion or higher than maxSdkV ersion
is not allowed. minSdkV ersion should be declared in each app,
while maxSdkV ersion is no longer checked or enforced beyond
Android 2.0.1. tar❕etSdkV ersion designates the API Level that the
application targets at, and its default value is set to the value of
minSdkV ersion. (cid:140)is a(cid:138)ribute informs the system that the applica-
tion has been tested against the target SDK version and the system
should not enable any compatibility behaviors to maintain the ap-
plication’s forward-compatibility with the target version. (cid:140)e appli-
cation is still able to run on older versions down to minSdkV ersion.
2.3 Service Hijacking Attacks
Originally implicit intents are provided by Android to help ease
the developer’s working load with more (cid:131)exibility. For instance,
when an application needs some complex services such as image
enhancement or object detection, instead of coding our own version
of services, we can pass on the operation request and image data to
the Android system, which will pick an available application, e.g.
OpenCV Manager, that has implemented those services and opens
to third-party apps.
Later, researchers found that implicit service invocations are not
secure and may su(cid:130)er from service hijacking a(cid:138)acks [10]. Suppose
one application de(cid:128)nes a service A that includes at least one Intent
Filter and can be called through implicit intent by other apps. An
a(cid:138)acker can launch service hijacking a(cid:138)acks by cra(cid:137)ing a malicious
application that provides a service A* to match the same implicit
intent but with higher priority. When a victim application sends the
requests for calling service A to the Android system, the system is
responsible for automatically selecting the service with the highest
priority (i.e., the malicious service A*) from multiple matching
services and uses it to serve the victim app.
Android sorts service priority using (cid:128)ve Intent Filters’ (cid:128)elds,
namely, priority, per f erredOrder, isDe f ault, match, and system,
in the decreasing priority order.
• priority is the declared priority of this Intent Filter. (cid:140)e
value of priority must be greater than -1000 and less than
1000, higher value means higher priority. (cid:140)e default value
is 0.
• pre f erredOrder represents the user’s preference. A higher
value means higher priority; however, currently this value
is set to the default value 0 for all services and cannot be
changed.
• isDe f ault denotes if an Intent Filter has speci(cid:128)ed the In-
tent.CATEGORY DEFAULT a(cid:138)ribute, which means a default
action can be performed.
• match is the system’s evaluation on how well the Intent
Filter matches the intent, calculated according to (cid:128)ve Intent
Filter a(cid:138)ributes including action, cate❕ories, type, data,
and scheme.
• system de(cid:128)nes if it is a service de(cid:128)ned in a system appli-
cation. A system application has a high priority than user
applications.
(cid:140)e three (cid:128)elds priority, isDe f ault, and match are related to the
a(cid:138)ributes set in the Intent Filter and thus can be misused by mali-
cious developers to cra(cid:137) a malicious service with higher priority
to hijack a victim service. When there are multiple services with
the same matching value to an implicit intent, the services will be
ranked according to alphabetical order of the package names. (cid:140)us,
the a(cid:138)acker may misuse the package name to give its service a
higher priority. Since Android 5.0, Android suggests to use explicit
intents only, and it claims that when a service is invoked through
implicit intent, the system simply throws an exception and the
application invoking the service implicitly will crash [19].
3 METHODOLOGY
We develop an analysis framework called ISA to systematically
analyze the vulnerabilities in service invocations before and a(cid:137)er
the implicit service invocations are forbidden. As shown in Figure 1,
the ISA framework consists of four major components: Preprocessor,
Static Intent Analyzer, Reachability Veri(cid:128)er, and Vulnerable Service
Invocation Analyzer. (cid:140)e preprocessor is responsible for converting
APK (cid:128)les into smali (cid:128)les to facilitate further analysis. (cid:140)e static
intent analyzer then processes smali (cid:128)les to (cid:128)nd out all explicit and
implicit intents being consumed for invoking service components.
Session E2:  Securing Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1053Figure 1: (cid:135)e ISA Analysis Framework
Next, the reachability veri(cid:128)er (cid:128)lters out service invocations in the
dead codes and provides a database that only contains reachable ser-
vice invocations. Finally, the vulnerable service invocation analyzer
(cid:128)nds out all the vulnerable service invocations.
3.1 Preprocessor
Android applications are packaged as APK (cid:128)les, which are ZIP com-
pressed (cid:128)le containing compiled bytecode and additional metadata
such as manifest.xml (cid:128)le and resource (cid:128)les. To reduce the failures
on disassembling the Java code [13, 24], we use android-apktool
tool [2] to unpack the APK (cid:128)les and obtain the corresponding smali
(cid:128)les and manifest.xml (cid:128)le. More importantly, the smali code con-
tains almost all necessary information to facilitate the data (cid:131)ow
analysis. For instance, for the override functions with the same
function name and di(cid:130)erent parameters, since the function proto-
type can be provided when the function is invoked, we can precisely
trace the data (cid:131)ow across the function boundary.
3.2 Static Intent Analyzer
We conduct a static data (cid:131)ow analysis on the smali (cid:128)les to discover
all explicit and implicit intents that are consumed for invoking the
service components. It contains two modules, Intent Constructor
Finder and Data Flow Analyzer. (cid:140)e intent constructor (cid:128)nder is
responsible for obtaining a list of methods in which an Intent is
constructed and then recording those methods in an Intent Con-
structor Database. (cid:140)e data (cid:131)ow analyzer conducts a static data (cid:131)ow
analysis to (cid:128)nd all intents that are used to invoke services through
startService() and bindService(), and then records the intent
values in an Intent Value Database.
3.2.1
Intent Constructor Finder. As the starting point of our
analysis, this module (cid:128)nds the list of all methods in which new
intents are constructed. It can be done by simply grepping the intent
construction code (i.e., “new-instance v*, Landroid/content/Intent;”)
in the smali codes.
3.2.2 Data Flow Analyzer. (cid:140)e data (cid:131)ow analyzer parses the
methods in the intent constructor database and records the intents
for invoking services in an intent value database. Figure 2 shows the
algorithm of data (cid:131)ow analysis on Intents for each method in the
intent constructor database. (cid:140)e process of intents can be divided
into two categories: intra-method intent processing and inter-method
intent processing.
Figure 2: (cid:135)e Algorithm of Data Flow Analysis.
Static Intent AnalyzerApk fileSmali Filesmanifest.xmlPreprocessorIntentConstructor  DatabaseIntent ValueDatabaseIntent Constructor FinderData Flow AnalyzerVulnerableService InvocationAnalyzerImplicitInvocationFinderResolvedInvocationFinderInvocationRelationshipAnalyzerReachableIntentDatabaseReachabilityVerifierApk fileDataFlowAnalyzer ( SmaliFilePath,  Method,  IntentList )BeginIf ( IntentList Not Null ) TemporaryIntentList.Add(IntentList);//Read From the Begin Of the Method Line By LineWhile (( line = ReadNext ( SmaliFilePath:Method )  !=  End of Method ){   Switch line:Case: Invoke Intent Create Functions          TemporaryIntentList.Add;Case: Invoke Intent Process Functions         TemporaryIntentList.Update;Case: Invoke Intent Consume Functions        Intent Value Database.Add;Case: Invoke Auxiliary Functions    Save / Update Related VariablesCase: Invoke Method1 ( Intent1 in TemporaryIntentList ):SmaliFilePath1=GetSmaliFilePath(Method1);DataFlowAnalyzer(SmaliFilePath1, Method1,Intent1);Case: Return Intent1 in TemporaryIntentList: MethodReturnIntentList.Add(Method,Intent1); Store Method’s caller methods into the Intent Constructor DatabaseCase: Put Intent1 in TemporaryIntentList Into A Global Variable GVarGlobalValueList.Add(GVar,Intent1);     Store methods in which GVar is Get into the Intent Constructor DatabaseCase: Get GlobalVariable GVar Not In GlobalValueListFind MethodList in Which GVar is PutForeach(Method1 in MethodList){SmaliFilePath1=GetSmaliFilePath(Method1);DataFlowAnalyzer(SmaliFilePath1, Method1,NULL);}Case: Invoke Method1 in MethodReturnIntentListIntent1=MethodReturnIntentList.get(Method1);TemporaryIntentList.Add;Case: Get GlobalVariable GVar in GlobalValueListVar=GlobalValueList.get(GVar);if(Var is Intent) TemporaryIntentList.Add;}EndSession E2:  Securing Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1054Intra-Method Intent Processing. Since we need to obtain
the intent a(cid:138)ributes such as action, component name, package
name, and class name, rather than the data passed through
the intent such as the URI data, we construct a framework
model focusing on Android classes and APIs that handle re-
lated intent a(cid:138)ributes. For other APIs encountered during the
data (cid:131)ow analyzing, we only record the APIs invoked.
In to-
tal, we identify (cid:128)ve Android classes that are critical for the
analysis of intent a(cid:138)ributes, namely, android.content.Intent,
android.content.ComponentName, android.content.Context,
java.lang.Class, and java.lang.String, as shown in Table 1.
Table 1: Intent-related Classes and APIs
Class
android.content.Intent
android.content.ComponentName
java.lang.Class
java.lang.String
android.content.Context
API Prototype
Intent(Context, Class)
Intent(Intent)
Intent(String)
Intent(String, Uri, Context, Class)
Intent(String, Uri)
Intent()
setClass(Context, Class)
setClassName(String, String)
setClassName(Context, String)
setComponent(ComponentName)
setPackage(String)
setAction(String)
queryIntentServices(Intent,Flag)
resolveService()(Intent,Flag)
ComponentName(String, String)
ComponentName(Context, String)
ComponentName(Context, Class)
createRelative(String, String)
createRelative(Context, String)
un(cid:131)a(cid:138)enFromString(String)
getClassName()
getPackageName()
getShortClassName()
getCanonicalName()
getName()
getClass()
forName(String)
Several String Processing Functions
getPackageName()
bindService(Intent,ServiceConnection,int)
startService(Intent)
Category
Intent Creating
Functions
Intent Processing
Functions
Auxiliary
Functions
Intent Consuming
Functions
(cid:140)e life time of an intent variable can be divided into three
phases, intent created, intent processed and intent consumed. Ac-
cordingly, the list of APIs in Table 1 can be divided into intent
creating functions, intent processing functions, and intent con-
suming functions. First, the intent creating functions include all
constructor functions of the intent class. When encountering these
functions, a new intent will be stored into a temporary list named
TemporaryIntentList. We ignore all URI variables passed in as pa-
rameters. Second, the intent processing functions include con-
(cid:128)guration functions used to set the a(cid:138)ributes of the intent. We
focus on the a(cid:138)ributes related to our analysis, such as action,
class, package, and component, etc. When these functions are
invoked, the a(cid:138)ributes of the corresponding intent in the Tempo-
raryIntentList may be updated. If the intent is processed through
queryIntentServices() or resolveService(), it will be marked
in the TemporaryIntentList. (cid:140)ird, the intent consuming functions
include the functions that consume an intent to start a service com-
ponent. When encountering these functions, the corresponding
intent in the TemporaryIntentList will be stored into the intent
value database along with the invocation position of the intent
consuming functions.