### 优化后的文本

#### 图6：不同参数下的Reff
- (a) peff
- (b) ppre
- (c) pnode

第二组实例使我们能够评估在采用分布式优化协议时，修订后的优化程序（第5节）的有效性。请注意，由于使用了保守的方法接口，第二组实例的表现不会低于第一组。

我们为图4中的每个程序生成了十个EC[0.5, 0.5, 0.5]实例，并测量了每种优化程序实例的优化效果比Rpre和Reff。对这十个实例的测量结果进行了平均，并如图7所示。标记为pre (empty) 和eff (empty) 的条形图显示了使用空方法接口的优化程序的平均Rpre和Reff，而pre (inferred) 和eff (inferred) 则对应于使用推断方法接口的优化程序的平均Rpre和Reff。

从图7中可以得出以下三个观察结果：
1. 即使没有方法接口，前提条件消除和效果消除都能显著减少性能开销。
2. 前提条件消除的效果明显优于效果消除。
3. 方法接口的附加有效性是明显的，但并不显著。

### 实验2：改变策略特征

为了表征在不同策略结构下的优化效果，我们将修订后的优化程序（带推断方法接口）应用于不同的实验配置。具体来说，我们将pnode、peff和ppre分别从0到1以0.1的增量变化，同时保持其他两个参数固定在0.5。同样地，对于每种实验配置生成十个实例，并描绘出每种配置的平均效果比Rpre和Reff，分别如图5和图6所示。

从图6 (a) 和 (b) 中可以看出，随着效果密度（peff）的增加，Reff也随之增加；然而，随着前提条件密度（ppre）的增加，Reff则会减少。这种现象可以通过数据流方程（7）来解释：较高的peff增加了kill LIV[·]的大小，从而创建更大的死集，促进了效果消除。相反，较高的ppre增加了gen LIV[·]的大小，导致较小的死集，从而抑制了效果消除。类似地，从图5 (a) 和 (b) 中可以看出，无论是增加效果密度（peff）还是前提条件密度（ppre），Rpre都会增加。这也可以通过数据流方程（3）来解释，在该方程中，较大的效果和前提条件集会产生更大的保证集，从而促进前提条件消除。此外，隐式断言会被显式断言覆盖，因此图5 (b) 显示的增长幅度不如图5 (a) 显著。上述观察结果表明：

如果两种不同的安全策略编码产生类似的开销，那么我们应该选择具有更多效果和更少前提条件的编码，因为这样的策略更容易进行优化。

图5 (c) 和图6 (c) 表明更高的操作符密度（pnode）会产生更高的优化效果。

IRM在更多的程序点被解释为访问事件时，能从前提条件和效果消除中获益更多。

### 结论

我们提出了一种约束策略表示法，以促进IRM优化。我们的策略表示法足够表达简单的完整性策略、广义中国墙策略和层次化的一次选k策略。我们的核心优化程序是安全的、不显眼且有效的。该优化程序已扩展以适应分布式优化协议，在该协议中，不受信任的代码生产者可以制定方法接口，以提高不信任代码消费者的优化效果。该程序的一个原型已经实现，并展示了积极的性能特性。

我们正在探索替代优化指令，这些指令可能会比当前设计的方法接口带来更有效的优化。虽然我们目前的策略表示法和分布式优化协议旨在支持基于控制流的策略，但我们也在探索如何将其扩展以实施数据流约束 [7]。

### 致谢

本研究部分得到了NSERC发现基金和NSERC战略网络基金的支持。

### 参考文献

[略]

### 附录A：定理2的证明

**证明：** 考虑一个分层的一次选k策略{Ci}1≤i≤k。不失一般性，假设每个a ∈ Σ至少属于一个Ci。定义访问a ∈ Σ的主类H(a)为包含a的最小类。（这样的类的存在由条件(1)保证。）一对访问，比如a和b，被称为一致的当且仅当它们属于同一个应用类：即∃i . {a, b} ⊆ Ci。否则，它们是冲突的。注意到a和b是一致的当且仅当H(a) ⊆ H(b) ∨ H(b) ⊆ H(a)。（“如果”方向是直接的。“仅当”方向通过对{a, b} ⊆ Ci应用条件(2)得到。）

为了获得所需的CPCE表示{Ci}1≤i≤k，构造Π = {pC | C ∈ {Ci}1≤i≤k}，q0 = {¬pC | C ∈ {Ci}1≤i≤k}，以及δa = hpre a, eff ai，其中：

- pre a = {¬pC | H(a) 6⊆ C ∧ C 6⊆ H(a)}
- eff a = {pH(a)}

很容易看出，使用上述CPCE运算符，在运行时，迄今为止发生的访问集H是成对一致的。我们想要的是存在一个Ci使得H ⊆ Ci。我们通过归纳法证明这一点。

|H| ≤ 2的基础情况可以简单处理。假设对于某个k > 2，所有|H| = k的事件集H在包含成对一致事件时都有H ⊆ Ci。考虑一个集合H' = H ∪ {a}，其中|H| = k，a ∉ H，且H'中的事件成对一致。反设以下成立：

不存在Ci使得H' ⊆ Ci。

由于H包含成对一致事件，根据归纳假设，存在一个类C⋆使得H ⊆ C⋆。同时，a与H中的每个成员都一致。因此，对于每个b ∈ H，设Cb是一个包含a和b的类。根据(1)，C◦ = Tb∈H Cb是一个类。根据假设，存在一个事件b⋆ ∈ H使得b⋆ ∉ C◦。根据(1)，C• = C⋆ ∩ Cb⋆ 是一个类。现在，a ∈ C◦，但a ∉ C•；b⋆ ∈ C•，但b⋆ ∉ C◦。因此，C◦和C•是Cb⋆ 中的两个不同且不可比较的子集，这与(2)矛盾。