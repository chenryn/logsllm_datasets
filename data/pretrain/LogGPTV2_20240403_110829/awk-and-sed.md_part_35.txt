“getlineO）
 awk -v CMDFILE="uucp_commands" script 
 awk script CMDFILE="uucp_commands"
(getline〈 CMDFILE)>0
while（(getline〈CMDFILE)>O）{
else
if ((getline0)
# 与莱单项相关的命令的数组
#输入数组
exit
 title = $1
command [size0fArray] = $2 
menu[size0fArray] = $1
#菜单项的数组
++size0fArray
QQ群：
50192241
因此变量 CMDFILE 在 BEGIN 模式中将得不到定义
它被作为一个命令行参数来传递。这里
第十章
“底部抽屉”
---
## Page 246
序。如果是有效的响应，那么我们从command 数组中检索这个命令，显示它，
们在这个程序中读取菜单命令文件，
这个程序将接收标准输入,
如果找不到这样的命令则将这一行注释掉)
我们做的第一件事就是使用 system()函数来调用一个命令以清除屏幕（在我的
display_menu()函数：
供初始提示，在处理了用户的响应后再调用它以便进行另一个选择。下面是
个程序的主过程就是对用户的选择做出响应并执行命令。下面是这部分程序
实现的，因为我们需要在两个地方调用它：从BEGIN模式中调用它以向用户提
首
先，我们检查用户的响应范围。如果响应超出了范围，我们只简单地退出程
# 处理用户对提示的响应
function display_menu ()
display_menu()
#重新显示菜单
if ($1 > 0 && $1  0 && $1  O) {
else
if ((getline〈 CMDFILE)>O)
处理 CMDFILE，将项目读入菜单数组
后面的行包含：$1－描述；
#
调用函数显示菜单项和提示符
getline
#在再次显示菜单前等待输入
printf("")
system(command [$1])
#然后执行它
#打印执行的命令
command[size0fArray] = $2 
# 与莱单项相关的命令的数组
#菜单项的数组
#输入数组
exit
QQ群：
exit 1
title =
11
50192241
 $1
265
%s\n",
#命令生成器
command [$1]]
－－基于菜单的
第十章
“底部抽屉”
---
## Page 248
结果写入一个文件中。例如，下面的语句将当前记录写到文件 data.out 中：
直接向文件和管道输出
使得菜单列表可以被非专业的用户很容易地改变和扩展。
其他 awk程序）可以通过修改菜单命令文件来被执行。换句话说，程序中最可
这个程序实际上就是一个 shell,
这个程序。
当用户按RETURN键时，莱单将重新显示在屏幕上。用户可以选择“4”来退出
在屏幕上将显示下面的结果：
用户被提示输入菜单选项的编号。输入1～3之间以外的任何数字都能退出菜
当用户运行这个程序时，显示如下的输出：
单
/var/spool /uucppubl ic/dale
Executing ...find /var/spool/uucppublic -print 
Choose one:
UUCP Status Menu 
/var/spool /uucppubl ic 
function display_menu ()
display_menu()
#重新显示菜单
如果用户输入“1”用于了解在uucp公共目录下的文件列表，那么
4
7
#清屏－-如果不能清除，
QQ群：
printf("Choose one: ")
printf "\t%d. Exit\n",
#打印标题、项目列表、退出项目和提示符
Exit
for (i = 1; i ”出现在表达式的参数列表中时被看做是
命令的参数时可能会产生混淆。规定当“>”出现在任何打印语句的参数列表中
因为重定向操作符“>”和关系操作符是一样的，
据。
件是截断它，
打开文件，随后使用重定向操作符将数据追加到文件中。
文件名可以是任何能产生合法的文件名的表达式。
sub (/^\.
 print | command
print | 
print "a =", a, "b =", b, "max =", (a > b ? a : b) > "data. out
print > "data. out"
"wc -w"
可以用圆括号将表达式或参数列表括起来。例如，下面的例子用
QQ群：
去掉宏，然后得到单词数
50192241
- 267 -
，所以当你用表达式作为print
第一次使用重定向操作符将
第十章 
“>”
“底部抽屉”
和“>>”之间的
---
## Page 250
一个注册编号开始并以一个空行结束：
下面的脚本用于将一个包含大量帮助页的大文件分割为小文件。每个帮助页以
不会超出打开文件数的限制。
我们将要看到这个例子可以正常工作，因为它使用了close（）函数，它的运行
如果不关闭文件，
也许需要测试文件名以确定它的长度或查找不能用在文件名中的字符。
的文件中：
一个可以作为文件名的字符串，你可以编写一个脚本将每个记录输出到它对应
类似地，
注4:
作，
直接向文件写入输出的一个常见的方法，是将一个大的文件分割成几个小的文
程序打开更多的文件。
件，awk 提供了close ()函数用于关闭打开的文件。关闭已经处理完的文件可使
有内部限制，
当读文件或写文件时文件被打开。每个操作系统对一个正在运行程序能够同时
处理多个文件
注意，每次只能打开一定数量的管道。使用close ()函数关闭用过的管道。
打开的文件的数量都有一定的限制，
作而且不用创建
你
中
这种方法更简单
可以用变量来指定文件名并从文件的模式中挑选一个值。例如，如果$1提供
print $0 > $1
尽管UNIX提供了有用的 split和csplit命令，它们可以完成相同的工
WC
#
print 
得到单词数
也可以用 sed 来写入文件，
-W
￥$
gawk 企图通过先关闭再重新打开文件，
这个数字可能比系统限制要小（注4）。
建 shell脚本。
单且更容易理解。然而，
QQ群：
那么，
-－去掉宏
50192241
这个程序最终将用完可打开的文件数而不得不中止。
- 268 -
，但必须指定一个固定的文件名。在 awk
，而且，
，但关闭你使用过的文件更有效。
另一种方法的优势是可以完成相同的工
每个 awk 实现对打开文件的数量都
来打开比系统限制更多的文
。为了避免打开过多的文
第十章
“底部抽屉”
---
## Page 251
输入行写入一个新的文件中。
到文件名。一旦找到文件名，
难是第一行不是给出文件名的行。因此，我们将这些行写入一个数组中直到找
这个行的第五个字段，
码，使得事情有点困难。）提供文件名的行如下所示：
（尽管帮助页在大多数部分使用了-man宏，帮助页的开始部分具有奇怪的编
/^\.nr x 0/, /~$/ {
#最后一行为空
#新帮助页的第一项是".nrX 0"
BEGIN  file = O; i = O; filename =
# man. split 
.nr X0 
QQ群：
#匹配提供文件名的行
#这个条件收集行直到得到一个文件名
if ($4 == "x}"） {
else
+
if (file == 0)
#
($O~
关闭并清屏
-－分隔包含x的帮助页的文件
“XDrawLine”包含文件名，
50192241
file = 0
close (fi lename)
/^$/）{
i=0
#现在有一个文件名
print $0 > filename
i=0
for (x = 1; x  filename
-269
，也许编写这个脚本的惟一困
并从这一位置开始将每个
第十章
“底部抽屉”
---
## Page 252
的前面两行。我们仅在指定为项目的地方读取相应的行，如下例所示：
我们来编写一个简单的程序，用价格乘以订货数量。这个脚本将忽略每个记录
数
的
每个订单包含多行，
下面是客户订单文件中的两个客户记录的样本：
假设已有一个处理数据条目的脚本。该数据条目脚本有两项工作：第一项是输
介绍任何新的功能，
本节描述了一个小型商务应用程序，产生美元数量的报告。这个应用程序没有
生成柱状报告
出到被命名的文件中。
新文件中。不读取下一个输入行时，file 将被设置为1且print 语句将把它输
行时，将file设置为1。新文件的名字打印在屏幕上，以便用户能从程序中得
一个数组中。变量í是一个用于数组下标的计数器。当我们遇到设置文件名白
以及能否对这个文件进行写入。最初，file 为O，并且当前的输入行被存储
货
有
入
可以看出，
量和项目的单价。
名字，
的数据被写入不同的文件。
关7个项目的订单，
客户的名字和通信地址，
awk’/^#/{
#
#
P.0 NONE Date: 03/14/97
Martin S.
#
#
#
#13 7.50
P.0 N61331 97 Y 045 Date: 03/14/97
Charlotte Webb
2 5 6.75
27.50
71 7.50
17.5
2 3 7.50
，购买订单编号和订货日期。后面的每个行用编号表示一个项目、订货
我们使用变量file作为标记来表示我们是否有一个合法的文件名，
.Rossi
QQ群：