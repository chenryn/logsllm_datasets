title:EON: modeling and analyzing dynamic access control systems with
logic programs
author:Avik Chaudhuri and
Prasad Naldurg and
Sriram K. Rajamani and
G. Ramalingam and
Lakshmisubrahmanyam Velaga
EON: Modeling and Analyzing
Dynamic Access Control Systems with Logic Programs
Avik Chaudhuri
University of California
Santa Cruz, USA
PI:EMAIL
Prasad Naldurg
Microsoft Research
Bangalore, India
Sriram K. Rajamani
Microsoft Research
Bangalore, India
PI:EMAIL
PI:EMAIL
G. Ramalingam
Microsoft Research
Bangalore, India
Lakshmisubrahmanyam Velaga
Indian Institute of Management
Bangalore, India
PI:EMAIL
PI:EMAIL
ABSTRACT
We present EON, a logic-programming language and tool that can
be used to model and analyze dynamic access control systems. Our
language extends Datalog with some carefully designed constructs
that allow the introduction and transformation of new relations. For
example, these constructs can model the creation of processes and
objects, and the modiﬁcation of their security labels at runtime.
The information-ﬂow properties of such systems can be analyzed
by asking queries in this language. We show that query evaluation
in EON can be reduced to decidable query satisﬁability in a frag-
ment of Datalog, and further, under some restrictions, to efﬁcient
query evaluation in Datalog. We implement these reductions in our
tool, and demonstrate its scope through several case studies. In par-
ticular, we study in detail the dynamic access control models of the
Windows Vista and Asbestos operating systems. We also automat-
ically prove the security of a webserver running on Asbestos.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—Access con-
trols, Information ﬂow controls, Veriﬁcation; F.3.1 [Logics and
Meanings of Programs]: Specifying and Verifying and Reason-
ing about Programs—Speciﬁcation techniques, Mechanical veri-
ﬁcation; F.4.1 [Mathematical Logic and Formal Languages]:
Mathematic Logic—Logic and constraint programming
General Terms
Security, Veriﬁcation, Languages, Algorithms
Keywords
dynamic access control, logic programming, automatic veriﬁcation
1.
INTRODUCTION
Most modern operating systems implement access control mod-
els that try to strike a reasonable balance between security and prac-
tice. Unfortunately, ﬁnding such a balance can be quite delicate:
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’08, October 27–31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
security concerns often lead to inﬂexible restrictions, which do not
always seem practical. To tackle this conﬂict, these systems typi-
cally admit various ways of controlling access at runtime.
This paper is about verifying such access control systems auto-
matically. We focus on systems in which processes and objects are
labeled with security levels, and processes are prevented from ac-
cessing objects based on their labels. Such access control systems
represent the state of the art in both the commercial world and the
academic world, exempliﬁed by Windows Vista and Asbestos [11].
They are typically weaker than the pioneering models of this ap-
proach, due to Bell-LaPadula [3] and Biba [4], which have strong
secrecy and integrity properties, but turn out to be too restrictive in
practice [15]. In particular, some facility to control labels at run-
time often seems to be necessary in these systems.
We illustrate this point with an example. Consider a model in
which objects downloaded from the Internet are labeled Low, and
High processes are prevented from executing Low objects. In this
model, suppose that a High process needs to run an executable f
downloaded from the Internet (say, to install a new application),
and the integrity of f can be established (say, by verifying a dig-
ital certiﬁcate). Then, the High process should be able to run f
by upgrading it to High. On the other hand, if the integrity of f
cannot be established, the High process should still be able to run
f by downgrading itself to Low (following the principle of least
privilege [14]).
Windows Vista implements an access control model along these
lines. In particular, Windows Vista’s access control model aims to
prevent privilege escalation, data tampering, and code tampering by
viruses by enforcing a system-wide integrity policy based on labels.
However, to admit the above scenarios, the model allows labels to
be lowered or raised at runtime. This requires explicit authorization
by the user. While an informed user may be able to decide whether
such authorization is safe, there is a real danger that an uninformed
user may inadvertently authorize unsafe information ﬂows. For in-
stance, a High process can run a Low executable f , as above, by
downgrading itself to Low. As such, running f cannot do much
damage—in particular, f cannot write High objects, since Low
processes are prevented from writing High objects in the model.
However, another High process may upgrade f to High and run
it, without verifying its integrity. Unfortunately, f may be a virus
that can then write High objects.
The Asbestos operating system implements a related access con-
trol model. In this model, process labels are dynamically tainted
on communication with other processes, and such taints are prop-
agated to isolate processes based on the secrets they carry. The
model aims to prevent leaking of those secrets. At the same time,
the model allows a customized form of declassiﬁcation, and thereby
admits some information-ﬂow vulnerabilities.
Although Windows Vista and Asbestos differ in their details,
both systems implement dynamic access control models, based on
labels, that try to balance concerns of security and practice. The
information-ﬂow properties of these systems have not been fully
studied. In this paper, we develop a technique to model and analyze
such systems, and to automatically ﬁnd information-ﬂow attacks in
those systems, or conversely prove their security.
At the heart of our technique is a new logic-programming lan-
guage called EON, that extends Datalog with dynamic operators
for creating and modifying simple objects. We show how we can
code information-ﬂow violations as queries in this language, and
use query evaluation to ﬁnd possible vulnerabilities. EON has some
carefully designed restrictions—new names can be introduced only
through unary relations, only unary relations can be transformed,
and some monotonicity conditions must be satisﬁed. These restric-
tions are obeyed naturally by our speciﬁcations of Windows Vista
and Asbestos. We show that with these restrictions, query evalu-
ation for EON is decidable. Our crucial insight is that with these
restrictions, it is possible to reduce query evaluation in EON to
query satisﬁability in a fragment of Datalog. Then, we adapt an
algorithm due to Halevy et al. [12] (with minor corrections), to de-
cide this satisﬁability problem. Further, if the EON program does
not have negations over derived relations, we show a simpler re-
duction to query evaluation in Datalog, which allows us to solve
the program and generate attacks or proofs very efﬁciently.
We implement these reductions in our tool, and evaluate in de-
tail the security of Windows Vista and Asbestos with EON. Our
experiments highlight EON’s programmability. For instance, we
study the impact of various design choices, by making small, lo-
cal changes in speciﬁc models and observing their inﬂuence on the
attacks or proofs generated. We also model speciﬁc usage disci-
plines, and prove that some attacks are not possible if those disci-
plines are enforced (either statically or at runtime). In sum, EON
seems to be an effective tool to specify, understand, and verify ac-
cess control models. We expect that this approach can be used to
study other dynamic systems just as well.
The rest of the paper is organized as follows. The ﬁrst half (Sec-
tions 2–4) is devoted to theory. The next half is devoted to appli-
cations. In Section 2, we describe the syntax and semantics of the
EON language.
In Section 3, we show how query evaluation in
EON can be reduced to query satisﬁability in a fragment of Data-
log. (A satisﬁability algorithm for this fragment is reviewed in [7].)
In Section 4, we show how query evaluation in a fragment of EON
can be reduced to efﬁcient query evaluation in Datalog.
In Sec-
tion 5, we show applications of our technique through several ex-
periments with the EON tool. In Section 6, we discuss related work.
Finally, in Section 7, we discuss our contributions and conclude.
2. THE EON LANGUAGE
In this section, we introduce the EON language, and describe
its syntax and semantics. We begin by providing a brief review of
Datalog. We then extend Datalog with some carefully designed dy-
namic operators1 (Section 2.1), and present the semantics of these
operators (Section 2.2). Finally, we deﬁne the syntax and semantics
of queries in the language (Section 2.3).
Datalog is a convenient logic-programming language to express
relational access control models [18, 16, 10, 2]. In Datalog, a pos-
1In [7], we show that even a slight generalization of these operators leads
to undecidability of query evaluation in the language.
itive literal S is of the form R(t1, . . . , tm), where R is a relation,
m ≥ 0, and each ti is a variable or a constant. A negative literal is
of the form !S. A clause is of the form
S :− L1, . . . , Ln.
where each Li is a positive or negative literal. We refer to the left
hand side of :− as the head, and the right hand side of :− as the
body. A Datalog program is a collection of clauses.
A clause without a body is a fact. A clause is safe if every vari-
able in the clause appears in some positive literal in the body. A
program is safe if all clauses in the program are safe.
A relation depends on another if there is a clause in the program
that has the former relation in the head and the latter in the body; the
dependency is negative if the literal that contains the latter relation
is negative. A base relation does not depend on any other relation.
A base fact is a fact on a base relation. A program is stratiﬁed if
there is no negative dependency in any dependency cycle between
relations in the program.
In a safe stratiﬁed program, a clause “S :− L1, . . . , Ln." with
variables ex is interpreted as the ﬁrst-order logic formula ∀ex. L1 ∧
· · · ∧ Ln =⇒ S. A program is interpreted as the conjunction of the
interpretations of its clauses.
A database is a set of base facts. Given a program F and a
database DB, let I(F, DB) be the set of facts that are implied by the
interpretation of F ∪ DB. This set can be computed efﬁciently [20].
2.1 Syntax
In EON, we extend Datalog with two dynamic operators: new
and next. Before we formally describe their syntax and semantics,
we present a simple example to illustrate the language. This exam-
ple describes a dynamic system where new administrators and users
can be added to the system over time, any user x can be promoted
to an administrator by another administrator y, and any administra-
tor can control the system. The new operator models the creation
of fresh constants, and the next operator models the transformation
of relations over those constants:
new Admin.
new User.
next Admin(x)
Control(x)
:− User(x), Admin(y).
:− Admin(x).
Can a user that is not an administrator control the system?
? User(x),
!Admin(x), Control(x).
This query evaluates to false according to the operational seman-
tics, described in Sections 2.2 and 2.3.
Intuitively, the program
does not reach a state where User(x) and Control(x) are both
true but Admin(x) is not. In contrast, the following query asks if a
user that is not an administrator can eventually control the system:
? User(x),
!Admin(x) # Control(x).
Here # denotes sequencing of queries. This query evaluates to true;
intuitively, the program can reach a state where User(x) is true but
Admin(x) is not, then reach a state where Control(x) is true. (In
the latter state, we expect that Admin(x) is also true.)
Formally, an EON program is a set of EON clauses. Let E be a
set of unary base relations, called dynamic relations, and B range
over subsets of E .
Intuitively, these relations can be introduced
or transformed by the dynamic operators. The grammar of EON
clauses is shown below.
C ::=
S :− L1, . . . , Ln.
new B :− R.
next B(x), !B′(x) :− R(x).
EON clause
clause