浅析绕过js加密
原创六号刃部 酒仙桥六号部队
2020-11-10原文
这是 酒仙桥六号部队 的第 104 篇文章。
全文共计3191个字，预计阅读时长9分钟。
前 言 ： 在 渗 透 测 试 过 程 中 ， 我 们 经 常 会 碰 到 登 录 处 用 js
加密字段的情况。在大多数情况下，看到这种加密方式，我们
都 会 放 弃 对 该 登 录 处 进 行 暴 力 破 解 。 本 文 主 要 讲 解 对 js
加密进行绕过，以达到爆破或绕反爬的目的！
案例一：对登录处使用sm2国密加密算法的某网站进行爆破
抓包分析
该网站图形验证码失效，只要能对密码字段进行相应的加密，就可
以爆破！
访 问 网 站 ， 输 入 用 户 名 ： admin 、 密 码 ： 123456
以及正确的图形验证码进行登录。
抓包，可以看到密码字段被加密为很长的一段字符。
实战绕过
F12打开开发者调试模式，切换到Network选项卡。
重新登录一遍，可以看到password字段进行了加密。
切 换 到 Source 选 项 卡 ， ctrl+shift+F
调出全局搜索框，全局搜索 password 字段。
跳 到 checkuser.js
文件，我们看看password字段经过哪些加密。
password经过两次加密：
var password = hex_md5($("#password").val());
password = sm2Encrypt(password, publicKey_).toLocaleUpperCase();
第一步的加密很简单，就是调用hex_md5加密函数对password进行
加密。通过全局搜索hex_md5，在md5.js文件中找到了该函数。如
下：
function hex_md5(s){ return binl2hex(core_md5(str2binl(s),
s.length * chrsz));}
然 后 我 们 看 第 二 步 加 密 ， 第 二 步 加 密 调 用 了 sm2Encrypt()
函数对第一步加密后的字符串再进行加密。
我们在全局搜索sm2Encrypt，最终在sm2.js文件中找到了该加密
函数。通过百度搜索sm2加密算法，发现该算法是国密加密算法。
SM2国密加密算法
SM2是国家密码管理局于2010年12月17日发布的椭圆曲线公钥密码
算法。SM2算法和RSA算法都是公钥密码算法，SM2算法是一种更先
进安全的算法，在我们国家商用密码体系中被用来替换RSA算法。
随着密码技术和计算机技术的发展，目前常用的1024位RSA算法面
临严重的安全威胁，我们国家密码管理部门经过研究，决定采用SM2
椭圆曲线算法替换RSA算法。
更多的关于椭圆曲线的加密方法就不细讲。
所以，现在我们需要对sm2Encrypt加密函数进行模拟。我使用nod
ejs来进行模拟。本地创建sm2.js文件，把网站上sm2.js文件中的
sm2Encrypt()加密函数复制进来。末尾加一个console.log()打
印，便于我们查看结果。再把网站的md5.js文件拷贝到sm2.js同
目录下。而publickey则在sm2.js全局定义了。
运 行 该 js 文 件 ， 提 示 CryptoJS is not
defined 。 于 是 在 开 头 加 入 var CryptoJS =
require("crypto-js");
并且安装crypto-js模块：
cnpm install crypto-js
安 装 完 之 后 ， 再 次 运 行 。 提 示 SM2Cipher is not defined
。提示这个报错是因为该函数里面用到的一些其他函数我们没有复
制出来。所以得一个个把相关的依赖函数复制出来。
在加密的地方打断点，F11进行跟进。
一 步 一 步 跳 ， 找 到 了 SM2Cipher 函 数 ， 将 其 复 制 到 我 们 的 js
文件中。
再次运行，这次提示 KJUR is not defined
百度了下发现需要安装 jsrsasign
于 是 安 装 该 模 块 ， 并 且 在 脚 本 的 开 头 加 入 引 入 语 句 var
KJUR=require("jsrsasign");
再 次 运 行 ， 提 示 unregistered EC curve name:
sm2，这是引入的 jsrsasign.js 文件报的异常。
于是猜测需要去注册sm2曲线名称。我们继续翻阅网站的sm2.js文
件，终于找到了注册该sm2曲线名称的代码。将其复制到我们的代码
中。
再 次 运 行 ， 则 提 示 如 下 的 错 ： TypeError:
ECPointFp.decodeFromHex is not a function
我 们 在 导 入 的 模 块 里 面 全 局 搜 索 该 函 数
ECPointFp.decodeFromHex，发现导入的模块中其实是有该函数
的。
于 是 我 们 将 之 前 的 这 条 语 句 var
KJUR=require("jsrsasign"); 改 为 var
jsrsasign=require("jsrsasign");
。然后再次运行，对运行报错的函数，全局搜索。如果在导入的模
块中含有该函数，则在其前面加上jsrsasign.
如果到导入的模块中不含有该函数，则说明该函数是该网站自己定
义的，我们到网站的sm2.js中把该函数复制下来就行。比如funct
ion
SM3Digest函数，我们导入的模块中不含有该函数，但是在网站中
是定义了该函数的，我们将其复制下来到我们自己的代码中即可。
经过一个函数一个函数的跟踪其依赖，最终将其加密算法模拟了出
来，运行截图如下：
sm2.js代码如下：
最 终 我 们 可 以 使 用 burpsuite 的 插 件 对 这 个 js
加密函数进行调用爆破，如下：
至此，js解密完成，我们可以对该登录接口进行爆破了！
案例二：对某漏洞平台反爬进行绕过
以下是针对某漏洞平台反爬进行绕过，最终可以通过脚本爬取该漏
洞平台的漏洞列表。
直接使用爬虫脚本爬去漏洞，返回的是一段加密后的js代码，且返
回状态码为521。
于是百度了下响应状态码521，果然，是反爬措施。
抓包分析
接着，就需要开始绕过反爬了。
首先F12调试模式查看访问网站时的各种资源。我这里使用的是火狐
浏览器。
查看网络—>html，访问网站分两步。
先看第一步521请求
返回的是 521 状态码，然后返回的数据是加密的js代码。
再看请求头和响应头，发现响应头有一个set-cookie参数值 。
再看第二个200请求
返回的是 200 状态码，然后返回的数据是网页的数据。
再看请求头和响应头，发现请求头的参数值有两个。其中一个参数
__jsluid_s 是 第 一 步 521 请 求 响 应 包 设 置 的 ， 而 另 一 个 参 数
__jsl_clearance 则 是 第 一 步 521 请 求 响 应 的 js
数据解密后的值。
我们来梳理一下流程：
所以，现在要想绕过反爬措施，最主要的是解密第一步 521 返回的
js 代码。以下是美化后返回的js代码。
实战绕过
我们来分析一下js代码。
首 先 设 置 了 x 变 量 和 y 变 量 。 还 设 置 了 函 数 f 和 函 数
z 。 我 们 现 在 姑 且 不 看 x 、 y 、 f 和
z 的 内 容 到 底 是 什 么 。 我 们 看 最 后 的 一 个 while
循环，循环里面执行了 eval函数。
我们暂且不看eval函数里的内容是啥意思。我们将eval函数里的内
容 赋 值 给
test，然后控制台输入这个内容最后调用eval函数执行这个test。
这样，我们就可以在控制台看到最后执行的是啥东西了。
while (z++) try {
var test=y.replace(/\b\w+\b/g,
function(y) {
return x[f(y, z) - 1] || ("_" + y)
});
console.log(test);
eval(test);
break
} catch(_) {}
将以下js代码保存为后缀为 .html 的文件。
然后用浏览器打开该html文件，打开控制台输出以下js代码，并且
一直在刷新。
将控制台输出的js代码美化，如下：
我们发现cookie是通过如下函数生成的。
我们直接在控制台执行该函数，如下，得到了生成的cookie。但是
因为该cookie是有一定的时效性的。所以，我们得写一个脚本，快
速的获取生成的cookie，然后访问网站。
最终的反爬脚本运行截图如下 :
总结
无论是案例一还是案例二，都是网站为了加强安全性使用js加密做
的防护。所以需要我们对网站的js代码进行深入分析，才能进行绕
过。在工作中，碰到了js加密的网站不用慌，慢慢细心的分析，总
会有意想不到的收获！
精选留言
用户设置不下载评论