Out-of-Order Execution. In USENIX Security Symposium. USENIX Association,
991–1008.
[19] Jo Van Bulck, Daniel Moghimi, Michael Schwarz, Moritz Lipp, Marina Minkin,
Daniel Genkin, Yuval Yarom, Berk Sunar, Daniel Gruss, and Frank Piessens.
2020. LVI: Hijacking Transient Execution through Microarchitectural Load Value
Injection. In IEEE Symposium on Security and Privacy. IEEE, 54–72.
[20] Jo Van Bulck, Frank Piessens, and Raoul Strackx. 2017. SGX-Step: A Practical
Attack Framework for Precise Enclave Execution Control. In SysTEX@SOSP.
ACM, 4:1–4:6.
[21] Jo Van Bulck, Frank Piessens, and Raoul Strackx. 2018. Nemesis: Studying
Microarchitectural Timing Leaks in Rudimentary CPU Interrupt Logic. In CCS.
ACM, 178–195.
[22] Guoxing Chen, Sanchuan Chen, Yuan Xiao, Yinqian Zhang, Zhiqiang Lin, and
Ten-Hwang Lai. 2020. SgxPectre: Stealing Intel Secrets From SGX Enclaves via
Speculative Execution. IEEE Secur. Priv. 18, 3 (2020), 28–37.
[23] Don Coppersmith. 1997. Small Solutions to Polynomial Equations, and Low
Exponent RSA Vulnerabilities. J. Cryptol. 10, 4 (1997), 233–260.
[24] Victor Costan and Srinivas Devadas. 2016. Intel® SGX Explained. https://eprint.
iacr.org/2016/086.pdf.
[25] Fergus Dall, Gabrielle De Micheli, Thomas Eisenbarth, Daniel Genkin, Nadia
Heninger, Ahmad Moghimi, and Yuval Yarom. 2018. CacheQuote: Efficiently
Recovering Long-term Secrets of SGX EPID via Cache Attacks.
IACR Trans.
Cryptogr. Hardw. Embed. Syst. 2018, 2 (2018), 171–191.
[26] Goran Doychev, Boris Köpf, Laurent Mauborgne, and Jan Reineke. 2015. CacheAu-
dit: A Tool for the Static Analysis of Cache Side Channels. ACM Trans. Inf. Syst.
Secur. 18, 1 (2015), 4:1–4:32.
[27] Enigma. Accessed: 2021. Secret Network. https://scrt.network/.
[28] Enigma. Accessed: 2021.
https:
//github.com/enigmampc/SecretNetwork/blob/master/deployment/dockerfiles/
base.Dockerfile.
Secret Network - Deployment.
[29] Cesar Pereida García, Sohaib ul Hassan, Nicola Tuveri, Iaroslav Gridin, Alejan-
dro Cabrera Aldaya, and Billy Bob Brumley. 2020. Certified Side Channels. In
USENIX Security Symposium. USENIX Association, 2021–2038.
[30] GNU Nettle: a low-level cryptographic library. Accessed: 2020. https://git.lysator.
liu.se/nettle/nettle.
[31] Ben Gras, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2018. Translation
Leak-aside Buffer: Defeating Cache Side-channel Protections with TLB Attacks.
In USENIX Security Symposium. USENIX Association, 955–972.
[32] Daniel Gruss, Clémentine Maurice, Klaus Wagner, and Stefan Mangard. 2016.
In Detection of Intrusions and
Flush+Flush: a fast and stealthy cache attack.
Malware, and Vulnerability Assessment. Springer.
[33] Shay Gueron. 2016. Memory Encryption for General-Purpose Processors. IEEE
Secur. Priv. 14, 6 (2016), 54–62.
[34] Wilko Henecka, Alexander May, and Alexander Meurer. 2010. Correcting Errors
in RSA Private Keys. In CRYPTO (Lecture Notes in Computer Science), Vol. 6223.
Springer, 351–369.
[35] Nadia Heninger and Hovav Shacham. 2009. Reconstructing RSA Private Keys
from Random Key Bits. In CRYPTO (Lecture Notes in Computer Science), Vol. 5677.
Springer, 1–17.
[36] Matthew Hoekstra, Reshma Lal, Pradeep Pappachan, Vinay Phegade, and Juan
del Cuvillo. 2013. Using innovative instructions to create trustworthy software
solutions. In HASP@ISCA. ACM, 11.
[37] Nick Howgrave-Graham. 1997. Finding Small Roots of Univariate Modular
Equations Revisited. In IMACC (Lecture Notes in Computer Science), Vol. 1355.
Springer, 131–142.
[38] Mehmet Sinan Inci, Berk Gülmezoglu, Gorka Irazoqui, Thomas Eisenbarth, and
Berk Sunar. 2016. Cache Attacks Enable Bulk Key Recovery on the Cloud. In
CHES (Lecture Notes in Computer Science), Vol. 9813. Springer, 368–388.
[39] Intel. 2018. L1 Terminal Fault. https://software.intel.com/security-software-
guidance/deep-dives/deep-dive-intel-analysis-l1-terminal-fault.
[40] Intel. 2020.
Intel®Processors Load Value Injection Advisory - INTEL-SA-
00334. https://www.intel.com/content/www/us/en/security-center/advisory/
intel-sa-00334.html.
[41] Intel. 2020, Accessed: 2021. Load Value Injection. https://software.intel.com/
content/www/us/en/develop/articles/software-security-guidance/technical-
documentation/load-value-injection.html.
[42] Intel. Accessed: 2021. https://github.com/intel/intel-sgx-ssl.
[43] Intel®. 2020. Intel®Software Guard Extensions (Intel®SGX) SDK for Linux OS -
Developer Reference. Revision 2.9.
[44] ITU. Accessed: 2020. X.680: ASN.1 specification. https://www.itu.int/rec/T-REC-
X.680/en.
[45] B. Kaliski and EMC. 2008. RFC 5208 - Public-Key Cryptography Standards
(PKCS) #8: Private-Key Information Syntax Specification Version 1.2. https:
//tools.ietf.org/html/rfc5208.
[46] Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss, Werner
Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael
Schwarz, and Yuval Yarom. 2020. Spectre attacks: exploiting speculative execution.
Commun. ACM 63, 7 (2020), 93–101.
[47] Sandeep S. Kumar, Christof Paar, Jan Pelzl, Gerd Pfeiffer, and Manfred Schimmler.
2006. Breaking Ciphers with COPACOBANA - A Cost-Optimized Parallel Code
Breaker. In CHES (Lecture Notes in Computer Science), Vol. 4249. Springer, 101–
118.
[48] Sangho Lee, Ming-Wei Shih, Prasun Gera, Taesoo Kim, Hyesoon Kim, and Marcus
Peinado. 2017. Inferring Fine-grained Control Flow Inside SGX Enclaves with
Branch Shadowing. In USENIX Security Symposium. USENIX Association, 557–
574.
[49] libsodium. Accessed: 2021. https://github.com/jedisct1/libsodium/.
[50] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval Yarom, Mike
Hamburg, and Raoul Strackx. 2020. Meltdown: reading kernel memory from user
space. Commun. ACM 63, 6 (2020), 46–56.
[51] Fangfei Liu, Yuval Yarom, Qian Ge, Gernot Heiser, and Ruby B. Lee. 2015. Last-
Level Cache Side-Channel Attacks are Practical. In IEEE Symposium on Security
and Privacy. IEEE Computer Society, 605–622.
[52] Alexander May. 2003. New RSA vulnerabilities using lattice reduction methods.
Ph.D. Dissertation. University of Paderborn.
[53] Alexander May. 2010. Using LLL-Reduction for Solving RSA and Factorization
Problems. In The LLL Algorithm. Springer, 315–348.
[54] mbed TLS. Accessed: 2021. https://github.com/ARMmbed/mbedtls.
[55] Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos V. Rozas, Hisham Shafi,
Vedvyas Shanbhogue, and Uday R. Savagaonkar. 2013. Innovative instructions
and software model for isolated execution. In HASP@ISCA. ACM, 10.
[56] Microsoft. Accessed: 2021.
Cryptography, CryptoAPI, and CAPICOM.
https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptography--
cryptoapi--and-capicom.
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2469[57] Microsoft. Accessed: 2021. FIPS 140-2 Validation. https://docs.microsoft.com/en-
us/windows/security/threat-protection/fips-140-validation.
[58] Ahmad Moghimi, Gorka Irazoqui, and Thomas Eisenbarth. 2017. CacheZoom:
How SGX Amplifies the Power of Cache Attacks. In CHES (Lecture Notes in
Computer Science), Vol. 10529. Springer, 69–90.
[59] Daniel Moghimi, Jo Van Bulck, Nadia Heninger, Frank Piessens, and Berk Sunar.
2020. CopyCat: Controlled Instruction-Level Attacks on Enclaves for Maximal
Key Extraction. CoRR abs/2002.08437 (2020).
[60] Daniel Moghimi, Moritz Lipp, Berk Sunar, and Michael Schwarz. 2020. Medusa:
Microarchitectural Data Leakage via Automated Attack Synthesis. In USENIX
Security Symposium. USENIX Association, 1427–1444.
[61] Nimbus-JOSE-JWT. Accessed: 2021. https://bitbucket.org/connect2id/nimbus-
[62] NSS. Accessed: 2020. https://hg.mozilla.org/projects/nss.
[63] OpenSSL: Cryptography and SSL/TLS Toolkit. Accessed: 2021. https://github.
jose-jwt.
com/openssl/openssl.
sgx-sdk.
[64] Dag Arne Osvik, Adi Shamir, and Eran Tromer. 2006. Cache Attacks and Coun-
termeasures: The Case of AES. In CT-RSA. Springer, Berlin, Heidelberg, 1–20.
[65] Kenneth G. Paterson, Antigoni Polychroniadou, and Dale L. Sibborn. 2012. A
Coding-Theoretic Approach to Recovering Noisy RSA Keys. In ASIACRYPT (Lec-
ture Notes in Computer Science), Vol. 7658. Springer, 386–403.
[66] Colin Percival. 2005. Cache missing for fun and profit.
[67] Hany Ragab, Alyssa Milburn, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida.
2021. Crosstalk: Speculative data leaks across cores are real. In IEEE Symposium
on Security and Privacy. IEEE, accepted.
[68] Rohde & Schwarz Cybersecurity and Hackmanit GmbH. Accessed: 2020. BSI
project: Development of a secure crypto library. https://www.bsi.bund.de/EN/
Topics/Crypto/Cryptography/CryptoLibrary/crypto_library_node.html.
[69] Rust SGX SDK. Accessed: 2021. https://github.com/apache/incubator-teaclave-
[70] Vinnie Scarlata, Simon Johnson, James Beaney, and Piotr Zmijewski. 2018. Sup-
porting third party attestation for Intel® SGX with Intel® data center attestation
primitives.
[71] Michael Schwarz, Moritz Lipp, Daniel Moghimi, Jo Van Bulck, Julian Steck-
lina, Thomas Prescher, and Daniel Gruss. 2019. ZombieLoad: Cross-Privilege-
Boundary Data Sampling. In CCS. ACM, 753–768.
[72] Atsushi Takayasu and Noboru Kunihiro. 2017. A Tool Kit for Partial Key Expo-
sure Attacks on RSA. In CT-RSA (Lecture Notes in Computer Science), Vol. 10159.
Springer, 58–73.
[73] TaLoS: Efficient TLS Termination Inside SGX Enclaves for Existing Applications.
Accessed: 2020. https://github.com/lsds/TaLoS.
[74] Sohaib ul Hassan, Iaroslav Gridin, Ignacio M. Delgado-Lozano, Cesar Pereida
García, Jesús-Javier Chi-Domínguez, Alejandro Cabrera Aldaya, and Billy Bob
Brumley. 2020. Déjà Vu: Side-Channel Analysis of Mozilla’s NSS. In CCS. ACM,
1887–1902.
[75] Pepe Vila, Boris Köpf, and José F. Morales. 2019. Theory and Practice of Finding
Eviction Sets. In IEEE Symposium on Security and Privacy. IEEE, 39–54.
[76] Samuel Weiser, David Schrammel, Lukas Bodner, and Raphael Spreitzer. 2020. Big
Numbers - Big Troubles: Systematically Analyzing Nonce Leakage in (EC)DSA
Implementations. In USENIX Security Symposium. USENIX Association, 1767–
1784.
[77] Samuel Weiser, Andreas Zankl, Raphael Spreitzer, Katja Miller, Stefan Man-
gard, and Georg Sigl. 2018. DATA - Differential Address Trace Analysis: Find-
ing Address-based Side-Channels in Binaries. In USENIX Security Symposium.
USENIX Association, 603–620.
[78] Jan Wichelmann, Ahmad Moghimi, Thomas Eisenbarth, and Berk Sunar. 2018.
MicroWalk: A Framework for Finding Side Channels in Binaries. In ACSAC. ACM,
161–173.
[79] wolfSSL: Embedded TLS Library. Accessed: 2021. https://github.com/wolfSSL/
wolfssl.
[80] Yuanzhong Xu, Weidong Cui, and Marcus Peinado. 2015. Controlled-Channel
Attacks: Deterministic Side Channels for Untrusted Operating Systems. In IEEE
Symposium on Security and Privacy. IEEE Computer Society, 640–656.
[81] Yuval Yarom and Katrina Falkner. 2014. FLUSH+RELOAD: A High Resolu-
tion, Low Noise, L3 Cache Side-Channel Attack. In USENIX Security Symposium.
USENIX Association, 719–732.
[82] Yuval Yarom, Daniel Genkin, and Nadia Heninger. 2017. CacheBleed: a timing
attack on OpenSSL constant-time RSA. J. Cryptogr. Eng. 7, 2 (2017), 99–112.
[83] Yinqian Zhang, Ari Juels, Michael K. Reiter, and Thomas Ristenpart. 2012. Cross-
VM side channels and their use to extract private keys. In CCS. ACM, 305–316.
[84] Intel® Developer Zone. 2019, Accessed: 2020. Microarchitectural Data Sam-
pling. https://software.intel.com/security-software-guidance/deep-dives/deep-
dive-intel-analysis-microarchitectural-data-sampling.
𝑞 , 𝑞★
𝑝
𝑝 , 𝑑★
A MISSING PARTS FROM SECTION 5
Blockwise Knowledge. We consider the situation that some block-
−1)
wise knowledge about the secret key sk★ = (𝑝★, 𝑞★, 𝑑★, 𝑑★
was obtained. In the following, we focus on the first five variables
and treat sk★ as a quintuple on the variables Vars = {𝑝, 𝑞, 𝑑, 𝑑𝑝, 𝑑𝑞}.
To simplify notation, for 𝑣 ∈ Vars, we denote the corresponding en-
try in some key sk by sk[𝑣]. We show in Sec. A.1 that integrating the
last variable 𝑞−1
𝑝 into the key-recovery approach does not directly
give a usable linear equation in contrast to the other variables.
In the situation given by our attack, we do not have observa-
tions on single bits, but on blocks consisting of 6 bits, the length
of a base64 symbol. In our model, we let 𝑏 ∈ Z>0 be the block-
size. Without loss of generality, we assume that for each 𝑣 ∈ Vars,
we have 𝑏|⟨sk★[𝑣]⟩ by zero-padding all variables, i. e. the length
⟨sk★[𝑣]⟩ of each variable 𝑣 in our secret key sk★ is a multiple of 𝑏.
We denote the 𝑖-th bit of a bit-string 𝑥 by 𝑥[𝑖], i. e. the numeri-
𝑖=0 2𝑖𝑥[𝑖]. The 𝑗-th block block𝑗 (𝑥) ∈
{0, . . . , 2𝑏 − 1} of 𝑥 is defined as the value of the bitstring in the
𝑥[𝑖]2𝑖−𝑗·𝑏. In our attack,
we make use of the fact that the possible values for block𝑗 (𝑥)
are partitioned into different sets to model the different cache
lines used in our attack. We consider a partition part of the set
{0, . . . , 2𝑏 − 1}, i. e. part is a set of sets part1, . . . , part| part | such
all 𝑖 ≠ 𝑖′. An observation obs(part) with regard to this partition
part is a quintuple that contains for each variable 𝑣 ∈ Vars a
vector in {1, . . . , | part |}⟨sk★[𝑣]⟩/𝑏. We denote the 𝑗-th entry of
this vector by obs(part)[sk★[𝑣]]𝑗. We say that an observation
obs(part) is correct for a secret key sk★ if for all 𝑣 ∈ Vars and all 𝑗 ∈
{0, . . . , (⟨sk★[𝑣]⟩/𝑏) − 1}, we have block𝑗 (sk★[𝑣]) ∈ part𝑗′ with
𝑗′ = obs(part)[sk★[𝑣]]𝑗 if and only if block𝑗 (sk★[𝑣]) ∈ part𝑗.
cal value of 𝑥 is given by⟨𝑥⟩
𝑗-th block of 𝑥, i. e. block𝑗 (𝑥) =𝑗·𝑏+𝑏−1
that (i)𝑖 part𝑖 = {0, . . . , 2𝑏 − 1} and part𝑖 ∩ part𝑖′ = ∅ for
𝑖=𝑗·𝑏
A.1 Adapting the Algorithm
The main idea of the algorithm is to reconstruct the different bits
of the secret key sk★ iteratively. We build up a set of candidates.
Each candidate is a guess for the least significant bits of the true
secret key sk★ compatible with our observation and the RSA equa-
tions. We start our algorithm by producing a single candidate(cid:101)sk
apply the expand operation on(cid:101)sk to obtain two candidates(cid:101)sk1 and
(cid:101)sk2 of depth 2 by using the RSA equations described by Heninger
of depth 1, i. e. each variable only consists of a single bit. We then
and Shacham [35]. Whenever a candidate has reached depth of a
multiple of 𝑏, i. e., 𝑗 · 𝑏 for some 𝑗, we apply the check operation on
this candidate to verify that the last produced block block𝑗 (𝑣) of
each variable 𝑣 is feasible under our observation. If this candidate
does not fit to our observation, we prune it. We repeat these oper-
ations until a target depth 𝐷 is reached. All produced candidates
of depth 𝐷 are output. This target depth will be sufficient to recon-
struct the remaining bits via the Coppersmith method [23, 37, 52].
Informally, the depth of a candidate is the number of bits each
variable has (see below for details). Our algorithm performs these
operations in a depth-first fashion (see Figure 7 in Sec. 5). We now
give a more formal description of our algorithm. The expand opera-
tion uses a set of 4 modular equations on 5 variables and the check
operation compares the generated candidates to our observations.
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2470(1) As a first step to set up our modular equations, we need to
determine values 𝑘, 𝑘𝑝, and 𝑘𝑞 such that 𝑒·sk★[𝑑] = 𝑘(𝑁 −sk★[𝑝]−
sk★[𝑞] + 1) + 1, 𝑒 · sk★[𝑑𝑝] = 𝑘𝑝(sk★[𝑝] − 1) + 1, and 𝑒 · sk★[𝑑𝑞] =
𝑘𝑞(sk★[𝑞] − 1) + 1. We use the same technique as Heninger and
Shacham [35] to obtain these values.
Find 𝑘, 𝑘𝑝 , and 𝑘𝑞. An argument by Boneh, Durfee, and Frankel [13]