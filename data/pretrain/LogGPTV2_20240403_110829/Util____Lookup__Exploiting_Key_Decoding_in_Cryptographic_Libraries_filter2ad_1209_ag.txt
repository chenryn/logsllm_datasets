Out-of-Order Execution. In USENIX Security Symposium. USENIX Association,
991â€“1008.
[19] Jo Van Bulck, Daniel Moghimi, Michael Schwarz, Moritz Lipp, Marina Minkin,
Daniel Genkin, Yuval Yarom, Berk Sunar, Daniel Gruss, and Frank Piessens.
2020. LVI: Hijacking Transient Execution through Microarchitectural Load Value
Injection. In IEEE Symposium on Security and Privacy. IEEE, 54â€“72.
[20] Jo Van Bulck, Frank Piessens, and Raoul Strackx. 2017. SGX-Step: A Practical
Attack Framework for Precise Enclave Execution Control. In SysTEX@SOSP.
ACM, 4:1â€“4:6.
[21] Jo Van Bulck, Frank Piessens, and Raoul Strackx. 2018. Nemesis: Studying
Microarchitectural Timing Leaks in Rudimentary CPU Interrupt Logic. In CCS.
ACM, 178â€“195.
[22] Guoxing Chen, Sanchuan Chen, Yuan Xiao, Yinqian Zhang, Zhiqiang Lin, and
Ten-Hwang Lai. 2020. SgxPectre: Stealing Intel Secrets From SGX Enclaves via
Speculative Execution. IEEE Secur. Priv. 18, 3 (2020), 28â€“37.
[23] Don Coppersmith. 1997. Small Solutions to Polynomial Equations, and Low
Exponent RSA Vulnerabilities. J. Cryptol. 10, 4 (1997), 233â€“260.
[24] Victor Costan and Srinivas Devadas. 2016. IntelÂ® SGX Explained. https://eprint.
iacr.org/2016/086.pdf.
[25] Fergus Dall, Gabrielle De Micheli, Thomas Eisenbarth, Daniel Genkin, Nadia
Heninger, Ahmad Moghimi, and Yuval Yarom. 2018. CacheQuote: Efficiently
Recovering Long-term Secrets of SGX EPID via Cache Attacks.
IACR Trans.
Cryptogr. Hardw. Embed. Syst. 2018, 2 (2018), 171â€“191.
[26] Goran Doychev, Boris KÃ¶pf, Laurent Mauborgne, and Jan Reineke. 2015. CacheAu-
dit: A Tool for the Static Analysis of Cache Side Channels. ACM Trans. Inf. Syst.
Secur. 18, 1 (2015), 4:1â€“4:32.
[27] Enigma. Accessed: 2021. Secret Network. https://scrt.network/.
[28] Enigma. Accessed: 2021.
https:
//github.com/enigmampc/SecretNetwork/blob/master/deployment/dockerfiles/
base.Dockerfile.
Secret Network - Deployment.
[29] Cesar Pereida GarcÃ­a, Sohaib ul Hassan, Nicola Tuveri, Iaroslav Gridin, Alejan-
dro Cabrera Aldaya, and Billy Bob Brumley. 2020. Certified Side Channels. In
USENIX Security Symposium. USENIX Association, 2021â€“2038.
[30] GNU Nettle: a low-level cryptographic library. Accessed: 2020. https://git.lysator.
liu.se/nettle/nettle.
[31] Ben Gras, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2018. Translation
Leak-aside Buffer: Defeating Cache Side-channel Protections with TLB Attacks.
In USENIX Security Symposium. USENIX Association, 955â€“972.
[32] Daniel Gruss, ClÃ©mentine Maurice, Klaus Wagner, and Stefan Mangard. 2016.
In Detection of Intrusions and
Flush+Flush: a fast and stealthy cache attack.
Malware, and Vulnerability Assessment. Springer.
[33] Shay Gueron. 2016. Memory Encryption for General-Purpose Processors. IEEE
Secur. Priv. 14, 6 (2016), 54â€“62.
[34] Wilko Henecka, Alexander May, and Alexander Meurer. 2010. Correcting Errors
in RSA Private Keys. In CRYPTO (Lecture Notes in Computer Science), Vol. 6223.
Springer, 351â€“369.
[35] Nadia Heninger and Hovav Shacham. 2009. Reconstructing RSA Private Keys
from Random Key Bits. In CRYPTO (Lecture Notes in Computer Science), Vol. 5677.
Springer, 1â€“17.
[36] Matthew Hoekstra, Reshma Lal, Pradeep Pappachan, Vinay Phegade, and Juan
del Cuvillo. 2013. Using innovative instructions to create trustworthy software
solutions. In HASP@ISCA. ACM, 11.
[37] Nick Howgrave-Graham. 1997. Finding Small Roots of Univariate Modular
Equations Revisited. In IMACC (Lecture Notes in Computer Science), Vol. 1355.
Springer, 131â€“142.
[38] Mehmet Sinan Inci, Berk GÃ¼lmezoglu, Gorka Irazoqui, Thomas Eisenbarth, and
Berk Sunar. 2016. Cache Attacks Enable Bulk Key Recovery on the Cloud. In
CHES (Lecture Notes in Computer Science), Vol. 9813. Springer, 368â€“388.
[39] Intel. 2018. L1 Terminal Fault. https://software.intel.com/security-software-
guidance/deep-dives/deep-dive-intel-analysis-l1-terminal-fault.
[40] Intel. 2020.
IntelÂ®Processors Load Value Injection Advisory - INTEL-SA-
00334. https://www.intel.com/content/www/us/en/security-center/advisory/
intel-sa-00334.html.
[41] Intel. 2020, Accessed: 2021. Load Value Injection. https://software.intel.com/
content/www/us/en/develop/articles/software-security-guidance/technical-
documentation/load-value-injection.html.
[42] Intel. Accessed: 2021. https://github.com/intel/intel-sgx-ssl.
[43] IntelÂ®. 2020. IntelÂ®Software Guard Extensions (IntelÂ®SGX) SDK for Linux OS -
Developer Reference. Revision 2.9.
[44] ITU. Accessed: 2020. X.680: ASN.1 specification. https://www.itu.int/rec/T-REC-
X.680/en.
[45] B. Kaliski and EMC. 2008. RFC 5208 - Public-Key Cryptography Standards
(PKCS) #8: Private-Key Information Syntax Specification Version 1.2. https:
//tools.ietf.org/html/rfc5208.
[46] Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss, Werner
Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael
Schwarz, and Yuval Yarom. 2020. Spectre attacks: exploiting speculative execution.
Commun. ACM 63, 7 (2020), 93â€“101.
[47] Sandeep S. Kumar, Christof Paar, Jan Pelzl, Gerd Pfeiffer, and Manfred Schimmler.
2006. Breaking Ciphers with COPACOBANA - A Cost-Optimized Parallel Code
Breaker. In CHES (Lecture Notes in Computer Science), Vol. 4249. Springer, 101â€“
118.
[48] Sangho Lee, Ming-Wei Shih, Prasun Gera, Taesoo Kim, Hyesoon Kim, and Marcus
Peinado. 2017. Inferring Fine-grained Control Flow Inside SGX Enclaves with
Branch Shadowing. In USENIX Security Symposium. USENIX Association, 557â€“
574.
[49] libsodium. Accessed: 2021. https://github.com/jedisct1/libsodium/.
[50] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval Yarom, Mike
Hamburg, and Raoul Strackx. 2020. Meltdown: reading kernel memory from user
space. Commun. ACM 63, 6 (2020), 46â€“56.
[51] Fangfei Liu, Yuval Yarom, Qian Ge, Gernot Heiser, and Ruby B. Lee. 2015. Last-
Level Cache Side-Channel Attacks are Practical. In IEEE Symposium on Security
and Privacy. IEEE Computer Society, 605â€“622.
[52] Alexander May. 2003. New RSA vulnerabilities using lattice reduction methods.
Ph.D. Dissertation. University of Paderborn.
[53] Alexander May. 2010. Using LLL-Reduction for Solving RSA and Factorization
Problems. In The LLL Algorithm. Springer, 315â€“348.
[54] mbed TLS. Accessed: 2021. https://github.com/ARMmbed/mbedtls.
[55] Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos V. Rozas, Hisham Shafi,
Vedvyas Shanbhogue, and Uday R. Savagaonkar. 2013. Innovative instructions
and software model for isolated execution. In HASP@ISCA. ACM, 10.
[56] Microsoft. Accessed: 2021.
Cryptography, CryptoAPI, and CAPICOM.
https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptography--
cryptoapi--and-capicom.
Session 10A: Crypto, Symbols and Obfuscation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2469[57] Microsoft. Accessed: 2021. FIPS 140-2 Validation. https://docs.microsoft.com/en-
us/windows/security/threat-protection/fips-140-validation.
[58] Ahmad Moghimi, Gorka Irazoqui, and Thomas Eisenbarth. 2017. CacheZoom:
How SGX Amplifies the Power of Cache Attacks. In CHES (Lecture Notes in
Computer Science), Vol. 10529. Springer, 69â€“90.
[59] Daniel Moghimi, Jo Van Bulck, Nadia Heninger, Frank Piessens, and Berk Sunar.
2020. CopyCat: Controlled Instruction-Level Attacks on Enclaves for Maximal
Key Extraction. CoRR abs/2002.08437 (2020).
[60] Daniel Moghimi, Moritz Lipp, Berk Sunar, and Michael Schwarz. 2020. Medusa:
Microarchitectural Data Leakage via Automated Attack Synthesis. In USENIX
Security Symposium. USENIX Association, 1427â€“1444.
[61] Nimbus-JOSE-JWT. Accessed: 2021. https://bitbucket.org/connect2id/nimbus-
[62] NSS. Accessed: 2020. https://hg.mozilla.org/projects/nss.
[63] OpenSSL: Cryptography and SSL/TLS Toolkit. Accessed: 2021. https://github.
jose-jwt.
com/openssl/openssl.
sgx-sdk.
[64] Dag Arne Osvik, Adi Shamir, and Eran Tromer. 2006. Cache Attacks and Coun-
termeasures: The Case of AES. In CT-RSA. Springer, Berlin, Heidelberg, 1â€“20.
[65] Kenneth G. Paterson, Antigoni Polychroniadou, and Dale L. Sibborn. 2012. A
Coding-Theoretic Approach to Recovering Noisy RSA Keys. In ASIACRYPT (Lec-
ture Notes in Computer Science), Vol. 7658. Springer, 386â€“403.
[66] Colin Percival. 2005. Cache missing for fun and profit.
[67] Hany Ragab, Alyssa Milburn, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida.
2021. Crosstalk: Speculative data leaks across cores are real. In IEEE Symposium
on Security and Privacy. IEEE, accepted.
[68] Rohde & Schwarz Cybersecurity and Hackmanit GmbH. Accessed: 2020. BSI
project: Development of a secure crypto library. https://www.bsi.bund.de/EN/
Topics/Crypto/Cryptography/CryptoLibrary/crypto_library_node.html.
[69] Rust SGX SDK. Accessed: 2021. https://github.com/apache/incubator-teaclave-
[70] Vinnie Scarlata, Simon Johnson, James Beaney, and Piotr Zmijewski. 2018. Sup-
porting third party attestation for IntelÂ® SGX with IntelÂ® data center attestation
primitives.
[71] Michael Schwarz, Moritz Lipp, Daniel Moghimi, Jo Van Bulck, Julian Steck-
lina, Thomas Prescher, and Daniel Gruss. 2019. ZombieLoad: Cross-Privilege-
Boundary Data Sampling. In CCS. ACM, 753â€“768.
[72] Atsushi Takayasu and Noboru Kunihiro. 2017. A Tool Kit for Partial Key Expo-
sure Attacks on RSA. In CT-RSA (Lecture Notes in Computer Science), Vol. 10159.
Springer, 58â€“73.
[73] TaLoS: Efficient TLS Termination Inside SGX Enclaves for Existing Applications.
Accessed: 2020. https://github.com/lsds/TaLoS.
[74] Sohaib ul Hassan, Iaroslav Gridin, Ignacio M. Delgado-Lozano, Cesar Pereida
GarcÃ­a, JesÃºs-Javier Chi-DomÃ­nguez, Alejandro Cabrera Aldaya, and Billy Bob
Brumley. 2020. DÃ©jÃ  Vu: Side-Channel Analysis of Mozillaâ€™s NSS. In CCS. ACM,
1887â€“1902.
[75] Pepe Vila, Boris KÃ¶pf, and JosÃ© F. Morales. 2019. Theory and Practice of Finding
Eviction Sets. In IEEE Symposium on Security and Privacy. IEEE, 39â€“54.
[76] Samuel Weiser, David Schrammel, Lukas Bodner, and Raphael Spreitzer. 2020. Big
Numbers - Big Troubles: Systematically Analyzing Nonce Leakage in (EC)DSA
Implementations. In USENIX Security Symposium. USENIX Association, 1767â€“
1784.
[77] Samuel Weiser, Andreas Zankl, Raphael Spreitzer, Katja Miller, Stefan Man-
gard, and Georg Sigl. 2018. DATA - Differential Address Trace Analysis: Find-
ing Address-based Side-Channels in Binaries. In USENIX Security Symposium.
USENIX Association, 603â€“620.
[78] Jan Wichelmann, Ahmad Moghimi, Thomas Eisenbarth, and Berk Sunar. 2018.
MicroWalk: A Framework for Finding Side Channels in Binaries. In ACSAC. ACM,
161â€“173.
[79] wolfSSL: Embedded TLS Library. Accessed: 2021. https://github.com/wolfSSL/
wolfssl.
[80] Yuanzhong Xu, Weidong Cui, and Marcus Peinado. 2015. Controlled-Channel
Attacks: Deterministic Side Channels for Untrusted Operating Systems. In IEEE
Symposium on Security and Privacy. IEEE Computer Society, 640â€“656.
[81] Yuval Yarom and Katrina Falkner. 2014. FLUSH+RELOAD: A High Resolu-
tion, Low Noise, L3 Cache Side-Channel Attack. In USENIX Security Symposium.
USENIX Association, 719â€“732.
[82] Yuval Yarom, Daniel Genkin, and Nadia Heninger. 2017. CacheBleed: a timing
attack on OpenSSL constant-time RSA. J. Cryptogr. Eng. 7, 2 (2017), 99â€“112.
[83] Yinqian Zhang, Ari Juels, Michael K. Reiter, and Thomas Ristenpart. 2012. Cross-
VM side channels and their use to extract private keys. In CCS. ACM, 305â€“316.
[84] IntelÂ® Developer Zone. 2019, Accessed: 2020. Microarchitectural Data Sam-
pling. https://software.intel.com/security-software-guidance/deep-dives/deep-
dive-intel-analysis-microarchitectural-data-sampling.
ğ‘ , ğ‘â˜…
ğ‘
ğ‘ , ğ‘‘â˜…
A MISSING PARTS FROM SECTION 5
Blockwise Knowledge. We consider the situation that some block-
âˆ’1)
wise knowledge about the secret key skâ˜… = (ğ‘â˜…, ğ‘â˜…, ğ‘‘â˜…, ğ‘‘â˜…
was obtained. In the following, we focus on the first five variables
and treat skâ˜… as a quintuple on the variables Vars = {ğ‘, ğ‘, ğ‘‘, ğ‘‘ğ‘, ğ‘‘ğ‘}.
To simplify notation, for ğ‘£ âˆˆ Vars, we denote the corresponding en-
try in some key sk by sk[ğ‘£]. We show in Sec. A.1 that integrating the
last variable ğ‘âˆ’1
ğ‘ into the key-recovery approach does not directly
give a usable linear equation in contrast to the other variables.
In the situation given by our attack, we do not have observa-
tions on single bits, but on blocks consisting of 6 bits, the length
of a base64 symbol. In our model, we let ğ‘ âˆˆ Z>0 be the block-
size. Without loss of generality, we assume that for each ğ‘£ âˆˆ Vars,
we have ğ‘|âŸ¨skâ˜…[ğ‘£]âŸ© by zero-padding all variables, i. e. the length
âŸ¨skâ˜…[ğ‘£]âŸ© of each variable ğ‘£ in our secret key skâ˜… is a multiple of ğ‘.
We denote the ğ‘–-th bit of a bit-string ğ‘¥ by ğ‘¥[ğ‘–], i. e. the numeri-
ğ‘–=0 2ğ‘–ğ‘¥[ğ‘–]. The ğ‘—-th block blockğ‘— (ğ‘¥) âˆˆ
{0, . . . , 2ğ‘ âˆ’ 1} of ğ‘¥ is defined as the value of the bitstring in the
ğ‘¥[ğ‘–]2ğ‘–âˆ’ğ‘—Â·ğ‘. In our attack,
we make use of the fact that the possible values for blockğ‘— (ğ‘¥)
are partitioned into different sets to model the different cache
lines used in our attack. We consider a partition part of the set
{0, . . . , 2ğ‘ âˆ’ 1}, i. e. part is a set of sets part1, . . . , part| part | such
all ğ‘– â‰  ğ‘–â€². An observation obs(part) with regard to this partition
part is a quintuple that contains for each variable ğ‘£ âˆˆ Vars a
vector in {1, . . . , | part |}âŸ¨skâ˜…[ğ‘£]âŸ©/ğ‘. We denote the ğ‘—-th entry of
this vector by obs(part)[skâ˜…[ğ‘£]]ğ‘—. We say that an observation
obs(part) is correct for a secret key skâ˜… if for all ğ‘£ âˆˆ Vars and all ğ‘— âˆˆ
{0, . . . , (âŸ¨skâ˜…[ğ‘£]âŸ©/ğ‘) âˆ’ 1}, we have blockğ‘— (skâ˜…[ğ‘£]) âˆˆ partğ‘—â€² with
ğ‘—â€² = obs(part)[skâ˜…[ğ‘£]]ğ‘— if and only if blockğ‘— (skâ˜…[ğ‘£]) âˆˆ partğ‘—.
cal value of ğ‘¥ is given byâŸ¨ğ‘¥âŸ©
ğ‘—-th block of ğ‘¥, i. e. blockğ‘— (ğ‘¥) =ğ‘—Â·ğ‘+ğ‘âˆ’1
that (i)ğ‘– partğ‘– = {0, . . . , 2ğ‘ âˆ’ 1} and partğ‘– âˆ© partğ‘–â€² = âˆ… for
ğ‘–=ğ‘—Â·ğ‘
A.1 Adapting the Algorithm
The main idea of the algorithm is to reconstruct the different bits
of the secret key skâ˜… iteratively. We build up a set of candidates.
Each candidate is a guess for the least significant bits of the true
secret key skâ˜… compatible with our observation and the RSA equa-
tions. We start our algorithm by producing a single candidate(cid:101)sk
apply the expand operation on(cid:101)sk to obtain two candidates(cid:101)sk1 and
(cid:101)sk2 of depth 2 by using the RSA equations described by Heninger
of depth 1, i. e. each variable only consists of a single bit. We then
and Shacham [35]. Whenever a candidate has reached depth of a
multiple of ğ‘, i. e., ğ‘— Â· ğ‘ for some ğ‘—, we apply the check operation on
this candidate to verify that the last produced block blockğ‘— (ğ‘£) of
each variable ğ‘£ is feasible under our observation. If this candidate
does not fit to our observation, we prune it. We repeat these oper-
ations until a target depth ğ· is reached. All produced candidates
of depth ğ· are output. This target depth will be sufficient to recon-
struct the remaining bits via the Coppersmith method [23, 37, 52].
Informally, the depth of a candidate is the number of bits each
variable has (see below for details). Our algorithm performs these
operations in a depth-first fashion (see Figure 7 in Sec. 5). We now
give a more formal description of our algorithm. The expand opera-
tion uses a set of 4 modular equations on 5 variables and the check
operation compares the generated candidates to our observations.
Session 10A: Crypto, Symbols and Obfuscation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2470(1) As a first step to set up our modular equations, we need to
determine values ğ‘˜, ğ‘˜ğ‘, and ğ‘˜ğ‘ such that ğ‘’Â·skâ˜…[ğ‘‘] = ğ‘˜(ğ‘ âˆ’skâ˜…[ğ‘]âˆ’
skâ˜…[ğ‘] + 1) + 1, ğ‘’ Â· skâ˜…[ğ‘‘ğ‘] = ğ‘˜ğ‘(skâ˜…[ğ‘] âˆ’ 1) + 1, and ğ‘’ Â· skâ˜…[ğ‘‘ğ‘] =
ğ‘˜ğ‘(skâ˜…[ğ‘] âˆ’ 1) + 1. We use the same technique as Heninger and
Shacham [35] to obtain these values.
Find ğ‘˜, ğ‘˜ğ‘ , and ğ‘˜ğ‘. An argument by Boneh, Durfee, and Frankel [13]