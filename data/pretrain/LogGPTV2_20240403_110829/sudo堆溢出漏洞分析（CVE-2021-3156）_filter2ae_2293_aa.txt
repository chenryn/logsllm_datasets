# sudo堆溢出漏洞分析（CVE-2021-3156）
##### 译文声明
本文是翻译文章，文章原作者 酒仙桥6号部队，文章来源：酒仙桥6号部队
原文地址：[https://mp.weixin.qq.com/s?src=11&timestamp=1613813934&ver=2902&signature=Oicxnz5C-goIdtDJiaPnMM9WLGYJtDJ*6wjxa3eihGuT0PLt4i0WD9IbDrtVhw1pUWy9s-LA5EXjbekaeY39hqMzQYkaWcbdDg1fmYMhq6LnOmenSLnZctDuOiHjKni9&new=1](https://mp.weixin.qq.com/s?src=11&timestamp=1613813934&ver=2902&signature=Oicxnz5C-goIdtDJiaPnMM9WLGYJtDJ*6wjxa3eihGuT0PLt4i0WD9IbDrtVhw1pUWy9s-LA5EXjbekaeY39hqMzQYkaWcbdDg1fmYMhq6LnOmenSLnZctDuOiHjKni9&new=1)
译文仅供参考，具体内容表达以及含义原文为准。
> 本文译自：https://www.kalmarunionen.dk/writeups/sudo/
## 介绍
2021年1月26日，sudo被曝存在一个“新”漏洞，但是实际上这个漏洞可能已经存在10年了。该漏洞可以使攻击者通过堆缓冲区溢出来进行权限提升。但是漏洞发布并没有exploit/POC，笔者所以决定自己构建一个。
## 脆弱性
简要介绍该漏洞，本质上攻击者可以通过在给sudo的任何argv或env参数的末尾插入一个反斜杠来让堆溢出，从而导致参数超出范围，来看一下简化版本的代码片段。
第一个for循环中，正在遍历每个参数，并使用strlen判断其大小(加上空终止符)，现在我们假设有空字符串“AAAA\”（\是一个字符），大小为5，并且加上这是唯一的参数，仅分配5个字节。
在下一部分中，我们将有一个用于参数的外部for循环和一个将所有参数的内容复制到单个缓冲区user_args中的内部循环，本质上是将所有参数串联在一起。
考虑与前面相同的字符串“AAAA\”，当[0]==’\’成立时，进入if并从from++递增，因为它指向空终止符，所以导致递增。之后，我们使用下一条语句*to++=*from++;继续循环。复制空终止符，复制字节，最终产出界限。
之所以会发生这种情况，是因为它希望每个\后面都有一个元字符，作者提出了一种巧妙的绕过方法，使它容易溢出。如果您想知道为什么以及进入该块时我们最终在参数中只有\的原因，请阅读本文。
通过使用符号链接sudoedit到sudo，我们可以做到这一点：
## 溢出的属性
作者陈述了有关此溢出的3个重要属性，这些属性使其非常强大。
首先，最简单的就是控制user_args的分配大小，因此选择sudo参数的数量和时间属性。
其次，控制溢出区域的内容。可以通过使用提供的环境变量来实现。环境变量实际上存储在最后一个参数传递给sudoedit之后，这意味着如果我们执行env -i’A
=BBBB’sudoedit -s’CCCCCCCCCCCCCCCC’，我们会将C插入到user_args缓冲区中，而A =
BBBB将紧随其后插入到边界区域。请注意，块大小应与0x10大小保持一致，例如env -i’A =
BB’sudoedit-s’CCCCBBBBBBBB’仅填充缓冲区。
如果密切关注串联块中的内部循环，您可能会注意到可以多次利用它。通过用\结束环境变量，可以再次跳到下一个环境变量。那为什么要那样？因为随着from++的增加，在以下to++=*from++上指向空终止符的指针，它将插入该空终止符。这能够在不结束溢出的情况下插入0x0，从而使该溢出功能极为强大。
作者的例子：
env -i’AA = a ”B = b ”C = c ”D = d ”E = e ”F =
f’sudoedit-s’1234567890123456789012 ‘
这样最终会在缓冲区中结束：
因此，我们将不讨论堆块的正向（fd）或反向（bk）指针的含义，因为我们仅在使用内存中进行利用。
  * 第一个大小是后续块的大小。它等于给malloc的0x10+参数，因为还需要本身和对齐/以前大小的空间。
  * 下一个大小是连续的块大小。
  * fd和bk分别指向此释放块链接列表中的下一个和上一个块的指针。这仅适用于释放的块。否则，malloc的调用者可以使用这个空间。
关于空终止符插入，这里需要注意的一点是，我认为原稿中缺少的是，我们也可以插入多个连续的空字节。
首先要了解的是，环境变量不必以SOMETHING=SOMETHING_more的形式出现。与其他所有内容一样，这些只是字符数组，我们可以在C语言中使用它们。例如：
在这里，我们使用execve在完全控制环境变量的情况下执行过程。在内部for循环中，我们在””\””处插入if语句，并通过from++反斜杠跳过一个字符，然后仅将null插入到下一个“\”，然后在a中插入两个null字节。
## 开发
尽管作者在本文中提到了3个可能的目标，但我们仅涵盖第二个目标。
原因：
  * 与第一种选择相反，它们没有暴力破解，在第一种选择中，它们部分溢出了以暴力破解击败ASLR的函数指针。
  * 他们说，他们成功地在3个操作系统上成功做到了这一点，而其他两个操作系统都只有一个。
在第二个选项中，我们尝试溢出到存储在堆中的service_user结构中。
nss_load_library在溢出加载新的动态链接库后，libc中经常使用此结构，我们可以使文件名溢出，然后控制要加载的库。然后，我们可以针对我们可以制作的将以root特权运行的非特权库为目标。
该函数如下所示：
此功能的目标是点击ni->library->lib_handle =__libc_dlopen（shlib_name）加载一个我们控制的新库。
这里有两件事要注意，第一件事是本文提到的。如果ni->library不为NULL，我们将在ni->library->lib_handle中使用该指针，并且由于ASLR是一个X子，因此我们无法预测没有泄漏的有效指针。幸运的是，此结构存在一个初始情况，如果该结构为null，则可以通过ni->library=nss_new_service来设置它，现在，多个空字节写入就派上用场了！
然后，我们只需要将此结构完全溢出到其名称字段，即可将其更改为我们控制的非特权库。
第二个挑战是我们拥有下一个指针struct service_user *
next;。在结构内部形成一个链表，当加载发生时将遍历该链表。因此，如果我们在过程中意外溢出另一个service_user结构，则当我们因fx
A溢出而导致错误时，就将编写垃圾指针。可以通过在该位置插入空字节来避免这种情况，但这会带来另一个问题，现在断开链表，并且可以从列表中完全删除目标结构，而在整个内存空间中都没有指向它的指针。
这意味着我们必须定位到分配区域之后的链表中的第一个结构。事实证明，这是要克服的最大挑战，因为您可以想象这需要对堆分配进行很好的控制。