4.1 S3 System Architecture
Figure 2: S3 System Architecture and operating layers
We consider the cloud infrastructure shown in Figure 2 as
the architecture for framework S3, where the networking in-
frastructure is based on Software Deﬁned Networking (SDN)
solutions. SDN is an emerging technology aiming to enhance
the current networking protocols by separating control-plane
from data-plane. The Application Plane comprises of vulner-
ability scanner (Nessus) which collects vulnerability infor-
mation from each network host. The vulnerability scanner,
on the other hand, interacts with the individual hosts at data
plane using API network.
The Security Policy Database (SPD), as shown in Figure 2,
creates security policies to deﬁne micro-segmentation poli-
cies. These policies dictate how segments are created. The
trafﬁc between segments is regulated using security policies
deﬁned by SPD. The SPD interacts with SDN controller using
northbound REST APIs to update security policy information.
The Attack Graph Generator module, which is a wrapper
program we developed for the generation of sub-AGs at the
level of each segment. This module interacts with a vulnera-
bility scanner and SPD to create segments using an algorithm,
and ﬁnally, utilize merge algorithm to merge segments into
fully connected AG.
S3 framework utilizes OpenFlow southbound APIs to pro-
vide ﬂexible and programmable micro-segmentation archi-
476          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Associationtecture. The SDN framework utilizes OpenFlow protocol to
communicate with switches at the Control Plane level. As
shown in the Figure 2, the SDN controller (control plane) col-
lects connection information from software switches situated
at the data plane using getConnInfo() API. The security poli-
cies are implemented on each switch using addFlow() API as
shown in the communication channel between controller and
switch - Figure 2.
Each OpenFlow switch has ﬂow tables, which are used to
store incoming/outgoing ﬂow rules based on packet header
match. The rules are stored in the Ternary Content Address-
able Memory (TCAM) format.
5 DFW and Micro-Segmentation
Micro-segmentation based on SDN-framework is a method
of creating secure zones in data centers and cloud deploy-
ments to isolate workloads from one another and secure them
individually to make network security more granular.
We utilize distributed ﬁrewall (DFW) functionality based
on micro-segmentation architecture to control the reachability
across different network segments, and in effect, reducing the
AG scalability. By leveraging the |DFW| rules, as shown in
Figure 1 (a), we can control the access between Web Server
(VM1) and FTP Server (VM2) in Segment 1. Similarly, a gran-
ular security policy can enforced to control the connection
requests from LDAP Server (VM3) to SQL Server (VM4).
Table 1: Example of Network topology vulnerabilities and
connectivity information.
Segment
Segment 1
Segment 2
VM
Service
VM1 WebServer
FTPServer
VM2
LDAP Server
VM3
VM4
SQL Server
Vulnerability
Cross-Site Scripting
Remote Code Execution
Local Buffer Overﬂow
SQL Injection
Attack Path
Internet- VM1 port 80
VM1 - VM2 port 25
Segment 1 via DFW
VM3 - VM4 port 3306
Figure 3: S3 data structures utilzed by control plane software
(a), (b) and application plane REST API used by network
admin (c), (d).
Flow Table consists of other important ﬁelds besides match
and action ﬁelds. Each ﬂow entry also has priority, counter,
and timeout ﬁelds, as shown in the Figure 3 (a). The header
structure - Figure 3 (b) of each ﬂow is used for matching traf-
ﬁc against incoming trafﬁc. The REST API at the application
plane help in management of the distributed control plane. For
instance, if a new controller needs to be added to the control
plane, the POST API - Figure 3 (c) is used by controller in
order to announce intent to join DFW. The application plane
checks the vulnerability, network topology, and reachability
information periodically in order to update the network seg-
ments. Information about each segment can be obtained using
GET API as shown in Figure 3 (d). The network segment
generated by S3 framework in this case int-net segment, with
segment ID 10 consists of services present on ports 80-40000
on all machines in range 192.168.1.25-89.
When the DFW is absent, the attacker can reach to any
virtual machine from the internet and exploit it since it has a
vulnerability as shown in Table 1. The resulted AG for this
topology is shown in Figure 1 (b). The provided Figure is just
a simple example to illustrate multi-stage attacks that can be
launched in a cloud network. In reality, the graph will have
more nodes and edges to illustrate connectivity information.
Figure 4: Flow Diagram of S3 Segmentation and AG Genera-
tion.
5.1 Implementation
Segmentation can also be achieved by considering security
requirements. The requirements, however, are not analyzed
and do not take into account the existing vulnerabilities and
the connectivity between those vulnerabilities (vulnerability
dependencies). Therefore, the goal of S3 is to provide a seg-
mentation solution to enhance system security and ensure ﬁne-
grained security rules between vulnerable and mission-critical
services. S3 utilizes the system administrator’s knowledge
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 477Algorithm 1 Segmentation and Scalable AG Generation Al-
gorithm
1: procedure SEGMENT ESTABLISHMENT
2: V ← {1,n}
3: R ← {1,m}
4: S ← {1, l}
5:
6:
7:
sort(service, type)
if connected (servicei, service j, rulek) & vuln
(cid:46) list of vulnerabilities
(cid:46) distributed ﬁrewall rules
(cid:46) network services
for all service ∈ S, vuln ∈ V, rule ∈ R do
∈ (servicei, service j) then
update (segment, servicei, service j)
else if type (servicei) == type (service j) then
update (segment, servicei, service j)
end if
for all Segments do
8:
9:
10:
11:
12: end for
13: procedure ATTACK GRAPH GENERATION
14:
15:
16:
17:
18:
19:
20:
21:
end for
for all subAGs do
Compute sub-AG for segmenti
merge (subAGi, subAG j)
end if
end for
if connected (subAGi, subAG j, rulek) then
about the existing vulnerabilities residing in the system and
provides a methodology to build logical segments containing
services based on their vulnerability and reachability infor-
mation. The ﬂow diagram of S3 is presented in Figure 4. The
network services are ﬁrst analyzed and sorted according to
the service type and connectivity between the services based
on the |DFW| rules. If the services are of the same type, then
we append them to segments. If the services are connected
by |DFW| rule, and there is a vulnerability in the connected
services, then we also append the services into different sepa-
rate segments. We separated the segments because we want
to keep services of same type in one segment and separated
from other ones having different type. After that, we compute
the sub-AG of all the segments and check for connectivity
between the sub-AG based on the |DFW| as well. Finally, the
sub-AG from individual segments are merged and Compos-
ite Attack Graph (CAG) is created. The graph is frequently
updated, based on changes in network and vulnerability con-
ﬁgurations, which are monitored by SDN controller. Next,
we present an Algorithm 1, which explains more on how the
segmentation is achieved for the of building scalable CAG.
5.1.1 Algorithm Analysis
S3 segmentation and AG generation approach is shown in
Algorithm 1. The algorithm ﬁrst starts by obtaining all vul-
nerabilities, running services, and |DFW| rules in the system
lines 2-4. Next, the algorithm span over all of these gathered
information and sorts the services by their type as shown in
line 5. After that, the algorithm checks for services that are
of the same type and put them in the same logical segment.
Also, if there are two services connected to each other by a
|DFW| rule such that there is a vulnerability in servicei al-
lowing the attacker to exploit a vulnerability in service j, then
these two services are aggregated in the same segment. To
avoid redundancy, if the services have been already added to
an existing segment, the algorithm continues. After sorting
and aggregating services, vulnerabilities, and |DFW| rules,
we now have a number of segments that contain services of
similar type, or vulnerable services connected by |DFW| rule.
The next step is to compute an AG for each of these segments
to check and the critical paths inside each of these segments -
lines 13-15. Next, the sub-AG needs to be merged together to
allow the system administrator to see the relationship between
these segments and how an adversary can move from one seg-
ment to another one to achieve their ﬁnal goal. The merge
procedure, as shown in line 16-19 is based on the connectivity
of the separated segments.
5.1.2 Complexity Analysis
The sort operation over services in algorithm 1 can be per-
formed using quick sort algorithm [9] which has average
complexity of O(Slog(S)), where S is the number of ser-
vices. Computing the sub-AG is a linear time operation as the
computation is being performed in parallel with the help of
S3 SDN controller. The merge operation requires searching
among the segments and their connectivity, thus the search
can be done using divide and conquer approach which has
the complexity of O(Klog(K)) [9], where K is the number of
segments. As a result, the complexity of computing the global-
view of AG is based on the total number of vulnerabilities
in the system N, divided by the number of segments K, plus
the complexity for the merge operations, a total of O(( N
K )2)
+ O(Klog(K)) + O(Slog(S)) ∼ O(( N
K )2) when N >> K and
N >> S.
To make the full picture more clear about the resulting AG,
we present the following abstraction representation deﬁnitions
of AG:
Deﬁnition 2. Composite Attack Graph (CAG) is a tuple
CAG={S, E, N}.
• S denotes the set of all segments. Each segment has a sub
attack graph (sub-AG), i.e., sub-AG1, sub-AG2 ∈ S. If
there is a connectivity (|DFW| rule) from one service in
segment s to service present in segment s(cid:48), s (cid:54)= s(cid:48), where
this connection is the one required to exploit a vulnera-
bility present on service in s(cid:48), then this information (post
and pre-condition, vulnerability and connectivity) are
appended and concatenated in a segment.
• N denotes the nodes the set of all nodes present in the
CAG. A node in an individual segment s can be denoted
478          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationD or root node Ns
by Ns. The nodes can be conjunct nodes Ns
C, disjunct
node Ns
R. A link from segment s to seg-
ment s(cid:48) indicates reachability to a vulnerability in the
target segment s(cid:48), or a |DFW| rule that exists based on
the Service Level Agreement (SLA). In other words, this
link is the result from exploiting segment s which we call
post-condition that is needed for the attacker to reach
and exploit s(cid:48). Hence the post-condition from s becomes
a pre-condition s(cid:48).
• E ⊆ES
pre ∪ES
post is the edges present across all seg-
ments. If an edge from segment (sub-AG) s creates a
(cid:48)
post-condition in segment (sub-AG) s
, we denote the
post-condition using edge Es(cid:48)
post = Ns
C × Ns(cid:48)
D.
5.2 Optimal Micro-Segmentation and Valida-
tion
In a large cloud network, when creating segmentation, the
natural question is to identify the quality of segmentation. The
network administrator needs to identify the optimal number
(K) of segments and the basis of segmentation. We use a
heuristic approach based on service similarity, vulnerability
weight, and DFW rules, in order to validate segment quality
and optimal number (K). We deﬁne segmentation properties
used in S3 framework as follows.
1. Segment Compactness: Evaluates how closely the ser-
vices in the same segment are related to each other. For
instance, all Web Server (http/https) services can be put
in the same segment. We represent this using variable
scom.
2. Separation: The separation can be decided based on
the number of |DFW| rules currently present between
two segments. The higher the number, the higher the
distance will be between the segments. Variable sd is
used for representing separation measure.
3. Connectivity: The connectivity depends on dependen-
cies between vulnerabilities in the same segment as de-
scribed in Deﬁnition 2. The connectivity is denoted using
variable scon.
The segmentation procedure aims at ﬁnding segmentation
with high separation across segments, and high connectivity
between nodes in the same segment. We utilize Segmentation
Index (SI), an indexing measure based on Dunn Index [11],
often used in K-Means clustering [15] approach in order to
validate the quality of our micro-segmentation. Using the
variables enumerated above, we deﬁne segmentation index
as,
SI =
α×{scom + scon}
β× sd
,α,β ∈ (0,1],
(1)
where α and β are indexing parameters, their values are cho-
sen based on the administrator’s need. This indexing equa-
tion can help the system administrator to decide the optimal
number of segments based on the desired requirements. If
α > β, it means the SI places higher weight on connectivity
between services in the same segment. On the other hand
if α < β, the SI places higher weight on |DFW| rules be-
tween the segments. High segmentation index value indicates
optimal number of segments, since this equation is derived
from Dunn Index, which also aims at ﬁnding the maximum