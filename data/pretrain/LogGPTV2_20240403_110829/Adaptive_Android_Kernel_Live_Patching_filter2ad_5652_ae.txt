### 优化后的文本

#### 分析时间
随着函数复杂度的增加，分析时间也会相应延长，但所有情况下的分析时间均不超过36秒，平均时间为12.5秒。如果没有使用启发式方法，分析时间会显著增加，在某些情况下甚至可能无法完成。

#### 性能评估
为了评估KARMA的性能开销，我们使用了标准的Android基准测试（CF-Bench [9]）和基于系统调用的微基准测试。这两项基准测试均在运行Android 4.4的Google Nexus 5上进行。每个报告的结果是20次测量的平均值，结果的标准偏差可以忽略不计。总体而言，我们发现KARMA并未对测试设备的常规操作引入明显的延迟。考虑到大多数关键内核漏洞存在于较少执行的代码路径中（例如，设备驱动程序的ioctl接口，如表6所示），我们认为KARMA的性能足以满足实际部署需求。

![Figure 11: CF-Bench性能得分](https://example.com/figure11.png)
![Figure 12: 不同补丁下chmod的执行时间](https://example.com/figure12.png)

#### 讨论与未来工作
首先，KARMA旨在使Android框架独立于供应商实现更新（即Project Treble [20]）。这至少部分解决了用户空间更新问题，但未解决内核更新问题。Android内核仍然碎片化且过时，因此像KARMA这样的系统仍然是必要的。

其次，KARMA的补丁是用Lua编程语言编写的，依赖Lua引擎来严格限制补丁的运行时行为。尽管Lua引擎相对成熟且安全，但这种方法增加了内核的信任计算基础，并且在系统负载较重时会对性能产生负面影响。然而，实际上这不是一个大问题，因为大多数Android内核漏洞位于冷路径上，如设备驱动程序的ioctl函数（见表6）。我们正在研究能够提供类似安全保证的替代设计，如BPF [8]和沙盒二进制补丁。

第三，KARMA利用内核现有的错误处理代码来处理过滤后的恶意输入，以保持内核尽可能稳定。然而，错误处理代码已被证明包含漏洞 [36]，这种设计可能会导致资源泄漏甚至死锁（KARMA不允许补丁本身释放资源，因为这需要写入内核）。在我们的实验中，针对所有关键Android内核漏洞，我们未发现这是个约束条件。KARMA的参考补丁通常是官方源代码补丁的直接翻译，应已正确释放资源。如果官方补丁无法转换为一级或二级补丁，我们可以回退到三级（二进制）补丁。三级补丁更灵活，但需要仔细审查。

第四，KARMA使用符号执行来语义匹配两个易受攻击的函数。这种方法在实践中足够有效，因为许多内核函数在不同设备和Android版本之间相当稳定。这是一种在健全性和可扩展性之间的权衡。许多系统也做出了类似的权衡，因为符号执行本身既不太可扩展也不太精确（例如，如何处理循环）。我们正在改进方法，以更好地识别易受攻击的函数并适应补丁。如果KARMA的自动适应无法找到适当的函数进行修补，我们可以回退到特定漏洞的二进制补丁。

最后，KARMA是一个第三方内核实时修补系统。补丁可以迅速交付给用户设备，无需等待供应商和运营商的漫长过程。然而，未经供应商和运营商测试，这些补丁可能导致用户设备的稳定性问题。我们的实现允许用户选择性地禁用有问题的补丁。通过KARMA的云服务，我们可以自动将此类补丁从特定设备型号中黑名单。我们还可以与设备供应商合作，在发布前快速测试补丁。

#### 相关工作
**内核实时修补：**
相关的第一类工作包括多个内核实时修补系统，如kpatch [23]、kGraft [22]、Ksplice [27] 和 KUP [37]。它们假设内核源代码可用（这是一个合理的假设），并从源代码补丁创建实时补丁。然而，它们的补丁是二进制形式的，这不符合KARMA的威胁模型。首先，尽管Android内核是GPL许可的，但许多Android供应商并不及时发布其内核源代码。其次，这些系统缺乏自动适应不同Android设备的机制。KARMA的一个重要设计目标是适应性，以便扩展到Android生态系统。第三，二进制补丁容易被滥用，因为它们难以理解和审查，而这些系统没有强大的补丁运行时行为约束。KARMA专门设计来解决这些挑战。

**语义匹配：**
相关工作的第二类包括比较函数语义或相似性的系统 [31, 32, 39, 40]。BinHunt [32] 首先使用符号执行计算基本块的语义相似性，然后使用图同构算法进一步比较控制流图 (CFG) 的相似性。他们的后续工作 iBinHunt [40] 扩展了BinHunt，加入了过程间控制流图的比较。然而，整个程序的比较非常耗时。为了解决这个问题，iBinHunt 使用污点跟踪仅比较相同数据流中的基本块。这种方法不适合KARMA，因为商业Android设备不支持内核动态污点跟踪或全内核插桩。CoP [39] 也使用符号执行计算基本块的语义相似性，并使用线性独立路径的最长公共子序列来衡量程序的相似性。KARMA使用符号执行来解决语义等价函数中的语法差异，并利用大多数内核函数在不同内核版本之间保持语义相似的事实来显著加快比较速度。DiscovRE [31] 采用不同的方法，使用语法信息（即结构和数值特征）来比较函数相似性，从而显著提高分析效率。KARMA需要比基于语法的方法更精确的比较。

**自动补丁/过滤器生成：**
相关工作的第三类包括旨在自动生成补丁或输入过滤器的系统。例如，Talos [34] 是一个漏洞快速响应系统，它将安全应急措施 (SWRRs) 插入内核源代码中，以暂时保护内核免受漏洞利用。Talos 与KARMA有类似的目标，并且都依赖内核的错误处理代码来优雅地中和攻击。Talos 的基于源代码的方法不能应用于碎片化的Android生态系统。为了解决碎片化问题，KARMA可以自动将补丁适应到其他设备，并严格限制补丁的运行时行为。ClearView [41] 在动态训练阶段学习程序的不变量。当程序失败时，它识别出与失败相关的不变量，并使用它们生成程序补丁。PAR [38] 提出了一个基于模式的自动程序修复框架，其生成的补丁类似于从人工编写补丁中学到的模式。ASSURE 引入了救援点，可以在维持系统完整性和可用性的同时从未知攻击中恢复软件 [45]。ShieldGen [29] 是一个自动生成漏洞签名（即数据补丁）的系统。基于签名的过滤只能阻止已知攻击。为了解决这个问题，ShieldGen 利用协议规范从初始样本中生成更多攻击。Bouncer [28] 使用静态分析和动态符号执行创建全面的输入过滤器，以保护软件免受不良输入的影响。与这些系统相比，KARMA旨在保护许多Android系统的内核漏洞，并具有不同的设计。

#### 总结
我们介绍了KARMA的设计、实现和评估，这是一个适用于Android内核漏洞的自适应实时修补系统。通过过滤恶意用户输入，KARMA可以保护大多数Android内核漏洞免受攻击。与现有的内核实时修补系统相比，KARMA的独特之处在于它可以自动适应许多Android设备的参考补丁，并严格限制补丁的运行时行为。这两个特点使KARMA能够扩展到大型且碎片化的Android生态系统。我们的评估结果表明，KARMA可以在许多设备上保护大多数关键的Android内核漏洞，且性能开销可忽略不计。

#### 致谢
感谢我们的指导者David Lie和匿名评审员提供的宝贵意见，极大地帮助改进了本文的呈现。Yue Chen和Zhi Wang的部分研究得到了美国国家科学基金会（NSF）的资助（项目编号1453020）以及百度X-Lab的支持。本材料中的任何观点、发现和结论或建议均为作者的观点，并不一定反映NSF的意见。

#### 参考文献
[略]

---

希望这个优化后的文本更加清晰、连贯和专业。如果有任何进一步的修改需求，请告诉我！