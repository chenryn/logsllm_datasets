ysis time increases with the complexity of the function,
but they are all less than 36 seconds with an average of
12.5 seconds. Without this heuristics, it will take much
longer and may never ﬁnish in some cases.
3.3 Evaluation of Performance
To evaluate the performance overhead of KARMA, we
experimented with both a standard Android benchmark
(CF-Bench [9]) and a syscall-based micro-benchmark.
Both benchmarks were run on Google Nexus 5 with An-
droid 4.4. Each reported result is the average over 20
measurements. The standard deviation of the results is
negligible. Overall, we ﬁnd that KARMA does not in-
troduce noticeable time lag to regular operations of the
test device. Considering the fact that most critical kernel
vulnerabilities exist in less-hot code paths (e.g., device
drivers’ ioctl interfaces as shown in Table 6), we con-
sider KARMA’s performance is sufﬁcient for real-world
deployment.
1264    26th USENIX Security Symposium
USENIX Association
ALDRR1, [R4,#0x15C]MOVR0, #1MOVR0, R0, LSL R5ADDR1, R1, #8BLmsm_camera_io_wbBMOVR0, #0x64BLmsecs_to_jiffiesCMULR7, R7, R6ADDR5, R7, #0x210ADDR5, R4, R5MOVR1, R0MOVR0, R5BLwait_for_completion_timeoutA'LDRR1,[R4,#0x15C]MULR7, R7, R6MOVR0, #1MOVR0, R0, LSL R5ADDR5, R4, R7ADDR1, R1, #8ADDR5, R5, #0x1E4BLmsm_camera_io_wB'MOVR0, #0x64BLmsecs_to_jiffiesC'MOVR1, R0MOVR0, R5BLwait_for_completion_interruptible_timeoutFigure 11: Performance scores by CF-Bench.
Figure 12: Execution time of chmod with different patches.
and the vendor implementation so that, eventually, the
Android framework can be updated independent of the
vendor implementation (aka. project Treble [20]). This
will at least partially address the user-space update prob-
lem. However, project Treble does not address the kernel
update problem. Android kernels are still fragmented and
out-of-date. A system like KARMA is still necessary.
Second, KARMA’s patches are written in the Lua pro-
gramming language. It relies on the Lua engine to strictly
conﬁne patches’ run-time behaviors. However, this ap-
proach increases the kernel’s trusted computing base de-
spite the fact that the Lua engine is relatively mature and
secure. Executing patches on the Lua engine also nega-
tively impacts the performance, especially if the system
is under heavy load (in reality, this is not a concern be-
cause most Android kernel vulnerabilities are on the ker-
nel’s cold paths, such as device drivers’ ioctl functions,
as shown in Table 6). We are investigating alternative de-
signs that can achieve similar security guarantees, such
as BPF [8] and sandboxed binary patches.
Third, KARMA leverages the existing error handling
code in the kernel to handle ﬁltered malicious inputs, in
order to keep the kernel as stable as possible. However,
error handling code has been shown to contain vulnera-
bilities [36], and this design may leak resources and even
cause deadlocks (KARMA does not allow patches them-
selves to release resource because that requires writing
to the kernel). We did not ﬁnd this to be a constraint
during our experiment with all the critical Android ker-
nel vulnerabilities. KARMA’s reference patch is often a
direct translation of the ofﬁcial source-code patch, which
should have properly released the resources. If an ofﬁcial
patch cannot be translated to a level-1 or level-2 patch,
we can fall back to the level-3 (binary) patch. Level-3
patches are more ﬂexible but require careful vetting.
Fourth, KARMA uses symbolic execution to semanti-
cally match two vulnerable functions. The approach is
sufﬁcient for our purpose in practice because many ker-
nel functions are rather stable across devices and Android
releases.
It is a
trade-off between soundness and scalability. Many sys-
tems make a similar trade-off because symbolic execu-
In theory, the approach is not sound.
tion itself is neither very scalable nor very precise (e.g.,
how to handle loops). We are improving our method to
better identify vulnerable functions and adapt patches. If
KARMA’s automated adaption cannot ﬁnd a proper func-
tion to patch, we can fall back to the binary patch for this
particular vulnerability.
Lastly, KARMA is a third-party kernel live patching
system. Patches can be promptly delivered to user de-
vices without the long wait caused by vendors and carri-
ers. However, without testing performed by vendors and
carries, its patches could cause stability issues in the user
devices. Our implementation allows users to selectively
disable a problematic patch. With KARMA’s cloud ser-
vice, we can automatically blacklist such patches from
speciﬁc device models. We can also work with device
vendors so patches can be quickly tested before release.
5 Related Work
Kernel live patching: the ﬁrst category of the related
work consists of a number of kernel live patching sys-
tems, such as kpatch [23], kGraft [22], Ksplice [27], and
KUP [37]. They assume that the kernel source code
is available (a reasonable assumption for their purpose)
and create live patches from source code patches. Their
patches are however in the binary form. This design does
not ﬁt the threat model of KARMA. First, although An-
droid kernel is licensed in GPL, many Android vendors,
small and large alike [19], do not (promptly) release their
kernel source code. Second, these systems lack a mech-
anism to automatically adapt a kernel patch to different
Android devices. An important design goal of KARMA
is adaptiveness so that it can scale to the Android ecosys-
tem. Third, binary patches are prone to misuse because
they are hard to understand and vet, and these systems
have no strong conﬁnement of patches’ run-time behav-
iors. KARMA has been designed speciﬁcally to address
all these challenges in a live kernel patching system for
Android.
Among these systems, kpatch [23] and kGraft [22] re-
place a whole vulnerable function with the patched ver-
sion. They differ in how patches are applied: kpatch
USENIX Association
26th USENIX Security Symposium    1265
  0  5,000  10,000  15,000  20,000No patchTowelrootPing Pong RootBothPerformance Score  0  20  40  60  80  100  120No patchDirect returnConditional comparisonMemory readMixed operationsExecution Time (microseconds)stops all the running processes and ensures that none
of these processes are running inside the function to be
patched (similar to KARMA). kGraft instead maintains
two copies of each patched function at the same time and
dynamically decides which copy to execute. Speciﬁcally,
the kernel code active at the time of patching (e.g., sys-
tem calls, kernel threads, and interrupt handlers) is dis-
patched to the original version until it reaches a comple-
tion point; all other code is dispatched to the patched ver-
sion. Like kpatch, Ksplice [27] also stops the machine
to apply patches. However, Ksplice can patch individual
instructions instead of replacing whole functions. These
systems share the same limitation that they cannot sup-
port patches that “change the semantics of persistent data
structures [27]”. To address that, KUP [37] employs the
process checkpoint-and-restart to implement kernel hot
patching. Speciﬁcally, it checkpoints all the user pro-
cesses, replaces the running kernel with the patched ver-
sion, and then restores these user processes. Because it
replaces the whole kernel, KUP can support all kinds
of patches. However, restoring external resources (e.g.,
sockets) is often problematic for checkpoint-and-restore
systems, including KUP.
Semantic matching: the second category of the re-
lated work includes systems that compare semantics or
similarity of two functions [31, 32, 39, 40]. BinHunt [32]
ﬁrst uses symbolic execution to compute semantic simi-
larity of basic blocks and uses a graph isomorphism algo-
rithm to further compare the similarity of CFGs (control-
ﬂow graphs). Their follow-up work,
iBinHunt [40],
extends BinHunt with the inter-procedural control-ﬂow
graph comparison. However, whole-program compari-
son could be very time-consuming. To solve that, iB-
inHunt runs the program with taint tracking and only
compares basic blocks within the same data ﬂows. This
approach is not suitable for KARMA because none of
the commercial Android devices support kernel dynamic
taint tracking or whole-kernel instrumentation. CoP [39]
also uses symbolic execution to compute the seman-
tic similarity of basic blocks and uses the longest com-
mon sub-sequence of linearly independent paths to mea-
sure the similarity of programs. KARMA uses symbolic
execution to solve syntax differences in semantically-
equivalent functions.
In addition, it leverages the fact
that most kernel functions remain semantically similar
across different kernel versions to signiﬁcantly speed-
up the comparison. DiscovRE [31] takes a different ap-
proach by using the syntactic information (i.e., structural
and numeric features) to compare function similarities.
This can signiﬁcantly improve the analysis efﬁciency.
KARMA requires a more precise comparison than that
can be provided by syntax-based approaches.
Automatic patch/ﬁlter generation: the third category
of the related work includes systems that aim at auto-
matically generating patches or input ﬁlters. For exam-
ple, Talos [34] is a vulnerability rapid response system.
It inserts SWRRs (Security Workarounds for Rapid Re-
sponse) into the kernel source code in order to temporar-
ily protect kernel vulnerabilities from being exploited.
Talos shares a similar goal as KARMA, and both rely
on the kernel’s error handling code to gracefully neutral-
ize attacks. Talos’ source code based approach cannot
be applied to the fragmented Android ecosystem. To ad-
dress the fragmentation problem, KARMA can automat-
ically adapt a patch to other devices and strictly conﬁne
the run-time behaviors of its patches. ClearView [41]
learns invariants of a program during a dynamic train-
ing phase. When program failure happens, it identiﬁes
the failure-related invariants and uses them to generate
patches for the program. PAR [38] proposes a pattern-
based automatic program repair framework.
Its gener-
ated patches resemble the patterns learned from human-
written patches. ASSURE introduces rescue points that
can recover software from unknown exploits while main-
taining system integrity and availability [45]. Shield-
Gen [29] is a system for automatically generating vul-
nerability signatures (i.e., data patches). Signature-based
ﬁltering can only block known attacks. To address that,
ShieldGen leverages protocol speciﬁcations to generate
more exploits from an initial sample. Bouncer [28] uses
static analysis and dynamic symbolic execution to cre-
ate comprehensive input ﬁlters to protect software from
bad inputs. Compared to these systems, KARMA aims at
protecting kernel vulnerabilities for many Android sys-
tems and have a different design.
6 Summary
We have presented the design, implementation, and eval-
uation of KARMA, an adaptive live patching system
for Android kernel vulnerabilities. By ﬁltering mali-
cious user inputs, KARMA can protect most Android
kernel vulnerabilities from exploits. Compared to ex-
isting kernel live patching systems, the unique features
of KARMA are that it can automatically adapt a refer-
ence patch for many Android devices, and it strictly con-
ﬁnes the run-time behaviors of its patches. These two
features allow KARMA to scale to a large, fragmented
Android ecosystem. Our evaluation results demonstrated
that KARMA can protect most critical Android kernel
vulnerabilities in many devices with negligible perfor-
mance overhead.
7 Acknowledgments
We would like to thank our shepherd David Lie and
the anonymous reviewers for their insightful comments
1266    26th USENIX Security Symposium
USENIX Association
that greatly helped improve the presentation of this pa-
per. Yue Chen and Zhi Wang were supported in part by
the US National Science Foundation (NSF) under Grant
1453020 and a grant from Baidu X-Lab. Any opinions,
ﬁndings, and conclusions or recommendations expressed
in this material are those of the authors and do not neces-
sarily reﬂect the views of the NSF.
References
[1] Android Fragmentation: There Are Now 24,000 De-
http://www.zdnet.com/
vices from 1,300 Brands.
article/android-fragmentation-there-are-
now-24-devices-from-13-brands/.
[2] Android Platform Versions.
https://developer.
android.com/about/dashboards/index.html.
[3] Android Security Bulletins.
https://source.
android.com/security/bulletin/.
[4] Android System and Kernel Security.
https:
//source.android.com/security/overview/
kernel-security.html.
[5] Android Towelroot Exploit Used to Deliver Dogspec-
https://www.bluecoat.com/
tus Ransomware.
security-blog/216-4-25/android-exploit-
delivers-dogspectus-ransomware.
[6] angr. http://angr.io.
[7] Anonymous Citation. This citation is anonymized to
avoid leaking the authors’ identities.
[8] Berkeley Packet Filter (BPF). https://www.kernel.
org/doc/Documentation/networking/filter.txt.
[9] CF-Bench. https://play.google.com/store/apps/details?
id=eu.chainﬁre.cfbench.
[10] CVE-2013-2595 Kernel Patch.
https://www.
codeaurora.org/patches/quic/la/.PATCH_
2443_iwoLuwW321heHwW.tar.gz.
Patch.
Kernel
[11] CVE-2013-2596
http:
//git.kernel.org/cgit/linux/kernel/
git/torvalds/linux.git/commit/?id=
fc9bbca8f65e5f738af886317ca41a48ae4a.
[12] CVE-2013-6282
Kernel
Patch.
http:
//git.kernel.org/cgit/linux/kernel/
git/torvalds/linux.git/commit/?id=
844663f81d212918ff85f493649a799129fa4.
[13] CVE-2014-3153
Kernel
Patch.
http:
//git.kernel.org/cgit/linux/kernel/
git/torvalds/linux.git/commit/?id=
e9c243a5a6debe8e584c64d353412584b592f8.
[14] CVE-2014-3153 (Towelroot).
https://cve.mitre.
org/cgi-bin/cvename.cgi?name=cve-214-3153.
[15] CVE-2015-1805
Kernel
Patch.
http:
//git.kernel.org/cgit/linux/kernel/
git/torvalds/linux.git/commit/?id=
637b58c2887e5e5785865839cc75f59184b23d1.
[16] CVE-2015-3636
Kernel
Patch.
http:
//git.kernel.org/cgit/linux/kernel/
git/torvalds/linux.git/commit/?id=
a134f83e79fb4c3da925691e732c56911b4326.
[17] From HummingBad to Worse.
https://blog.
checkpoint.com/wp-content/uploads/216/7/
HummingBad-Research-report_FINAL-62916.pdf.
[18] Ghost Push: An Un-Installable Android Virus Infect-
ing 600,000+ Users Per Day. http://www.cmcm.com/
blog/en/security/215-9-18/799.html.
[19] GPLv2 and Its Infringement by Xiaomi.
http:
//www.xda-developers.com/gplv2-and-its-
infringement-by-xiaomi/.
[20] Here comes Treble: A modular base for Android. https:
//android-developers.googleblog.com/217/
5/here-comes-treble-modular-base-for.html.
[21] Kemoge: Another Mobile Malicious Adware Infect-
https://www.fireeye.
ing Over 20 Countries.
com/blog/threat-research/215/1/kemoge_
another_mobi.html.
[22] kGraft:
Live
patching
of
the Linux
kernel.
http://events.linuxfoundation.org/sites/
events/files/slides/kGraft.pdf.
[23] kpatch: Dynamic Kernel Patching. https://github.
com/dynup/kpatch.
[24] Linux Kernel Coding Style.
https://www.kernel.
org/doc/Documentation/CodingStyle.
[25] Linux Kernel Livepatch. https://www.kernel.org/
doc/Documentation/livepatch/livepatch.txt.
[26] lunatik.
ng/lunatik-ng.
https://github.com/lunatik-
[27] ARNOLD, J., AND KAASHOEK, M. F. Ksplice: Au-
tomatic Rebootless Kernel Updates.
In Proceedings of
the 4th ACM European Conference on Computer Systems
(New York, NY, USA, 2009), ACM, pp. 187–198.
[28] COSTA, M., CASTRO, M., ZHOU, L., ZHANG, L., AND
PEINADO, M. Bouncer: Securing Software by Blocking
Bad Input. In Proceedings of the 21st ACM SIGOPS Sym-
posium on Operating Systems Principles (2007), vol. 41,
ACM, pp. 117–130.
[29] CUI, W., PEINADO, M., WANG, H. J., AND LOCASTO,
M. E. Shieldgen: Automatic Data Patch Generation for
Unknown Vulnerabilities with Informed Probing. In Pro-
ceedings of the 28th IEEE Symposium on Security and
Privacy (2007), IEEE, pp. 252–266.
[30] CVE-2015-3636. https://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-215-3636.
[31] ESCHWEILER, S., YAKDAN, K., AND GERHARDS-
PADILLA, E.
discovRE: Efﬁcient Cross-Architecture
Identiﬁcation of Bugs in Binary Code. In Proceedings of
the 23rd Network and Distributed System Security Sym-
posium (2016).
USENIX Association
26th USENIX Security Symposium    1267
[32] GAO, D., REITER, M. K., AND SONG, D. Binhunt: Au-
tomatically Finding Semantic Differences in Binary Pro-
grams. In International Conference on Information and
Communications Security (2008), Springer, pp. 238–255.
Why Do Carriers Delay Up-
dates
http:
//www.howtogeek.com/163958/why-do-carriers-
delay-updates-for-android-but-not-iphone.
for Android But Not
[33] HOW-TO GEEK.
iPhone?
[34] HUANG, Z., D’ANGELO, M., MIYANI, D., AND LIE,
D. Talos: Neutralizing Vulnerabilities with Security
Workarounds for Rapid Response. In Proceedings of the
37th IEEE Symposium on Security and Privacy (2016).
[35] IERUSALIMSCHY, R., DE FIGUEIREDO, L. H., AND CE-
In Proceedings of the
LES, W. The Evolution of Lua.
Third ACM SIGPLAN Conference on History of Program-