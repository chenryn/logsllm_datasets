 123"]]
 a = [==[
 alo
 123"]==]
```
数字常量 （或称为 数字量） 可以由可选的小数部分和可选的十为底的指数部分构成， 指数部分用字符 'e' 或 'E' 来标记。 Lua 也接受以 0x 或 0X 开头的 16 进制常量。 16 进制常量也接受小数加指数部分的形式，指数部分是以二为底， 用字符 'p' 或 'P' 来标记。 数字常量中包含小数点或指数部分时，被认为是一个浮点数； 否则被认为是一个整数。 下面有一些合法的整数常量的例子：
```lua
3   345   0xff   0xBEBADA
```
以下为合法的浮点常量：
```lua
3.0     3.1416     314.16e-2     0.31416E1     34e1
0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
```
在字符串外的任何地方出现以双横线 `--` 开头的部分是 注释 。 如果 `--` 后没有紧跟着一个开大括号， 该注释为 短注释， 注释到当前行末截至。 否则，这是一段 长注释 ， 注释区一直维持到对应的闭长括号。 长注释通常用于临时屏蔽掉一大段代码。
## 变量
变量是储存值的地方。 Lua 中有三种变量： 全局变量、局部变量和表的域。
单个名字可以指代一个全局变量也可以指代一个局部变量 （或者是一个函数的形参，这是一种特殊形式的局部变量）。
```lua
var ::= Name
```
名字指 §3.1 中定义的标识符。
所有没有显式声明为局部变量（参见 §3.3.7） 的变量名都被当做全局变量。 局部变量有其 作用范围 ： 局部变量可以被定义在它作用范围中的函数自由使用（参见 §3.5）。
在变量的首次赋值之前，变量的值均为 `nil`。
方括号被用来对表作索引：
```lua
var ::= prefixexp '[' exp ']'
```
对全局变量以及表的域之访问的含义可以通过元表来改变。 以索引方式访问一个变量 `t[i]` 等价于 调用 `gettable_event(t,i)`。 （参见 §2.4 ，有一份完整的关于 `gettable_event` 函数的说明。 这个函数并没有在 `lua` 中定义出来，也不能在 `lua` 中调用。这里我们把提到它只是方便说明问题。）
`var.Name` 这种语法只是一个语法糖，用来表示 `var["Name"]`：
```lua
var ::= prefixexp '.' Name
```
对全局变量 x 的操作等价于操作 `_ENV.x`。 由于代码块编译的方式， _ENV 永远也不可能是一个全局名字 （参见 §2.2）。
## 语句
Lua 支持所有与 Pascal 或是 C 类似的常见形式的语句， 这个集合包括赋值，控制结构，函数调用，还有变量声明。
### 语句块
语句块是一个语句序列，它们会按次序执行：
```lua
block ::= {stat}
```
Lua 支持 空语句， 你可以用分号分割语句，也可以以分号开始一个语句块， 或是连着写两个分号：
```lua
stat ::= ';'
```
函数调用和赋值语句都可能以一个小括号打头， 这可能让 Lua 的语法产生歧义。 我们来看看下面的代码片断：
```lua
a = b + c
(print or io.write)('done')
```
从语法上说，可能有两种解释方式：
```lua
a = b + c(print or io.write)('done')
a = b + c; (print or io.write)('done')
```
当前的解析器总是用第一种结构来解析， 它会将开括号看成函数调用的参数传递开始处。 为了避免这种二义性， 在一条语句以小括号开头时，前面放一个分号是个好习惯：
```lua
;(print or io.write)('done')
```
一个语句块可以被显式的定界为单条语句：
```js
stat ::= do block end
```
显式的对一个块定界通常用来控制内部变量声明的作用域。 有时，显式定界也用于在一个语句块中间插入 `return` （参见 §3.3.4）。
### 代码块
`Lua` 的一个编译单元被称为一个 代码块。 从句法构成上讲，一个代码块就是一个语句块。
```lua
chunk ::= block
```
`Lua` 把一个代码块当作一个拥有不定参数的匿名函数 （参见§3.4.11）来处理。 正是这样，代码块内可以定义局部变量，它可以接收参数，返回若干值。 此外，这个匿名函数在编译时还为它的作用域绑定了一个外部局部变量 `_ENV` （参见 §2.2）。 该函数总是把 `_ENV` 作为它唯一的一个上值， 即使这个函数不使用这个变量，它也存在。
代码块可以被保存在文件中，也可以作为宿主程序内部的一个字符串。 要执行一个代码块， 首先要让 `Lua` 加载 它， 将代码块中的代码预编译成虚拟机中的指令， 而后，`Lua` 用虚拟机解释器来运行编译后的代码。
代码块可以被预编译为二进制形式； 参见程序 luac 以及函数 string.dump 可获得更多细节。 用源码表示的程序和编译后的形式可自由替换； `Lua` 会自动检测文件格式做相应的处理 （参见 load）。
### 赋值
`Lua` 允许多重赋值。 因此，赋值的语法定义是等号左边放一个变量列表， 而等号右边放一个表达式列表。 两边的列表中的元素都用逗号间开：
```lua
    stat ::= varlist ‘=’ explist
    varlist ::= var {‘,’ var}
    explist ::= exp {‘,’ exp}
```
表达式放在 §3.4 中讨论。
在作赋值操作之前， 那值列表会被 调整 为左边变量列表的个数。 如果值比需要的更多的话，多余的值就被扔掉。 如果值的数量不够需求， 将会按所需扩展若干个 nil。 如果表达式列表以一个函数调用结束， 这个函数所返回的所有值都会在调整操作之前被置入值列表中 （除非这个函数调用被用括号括了起来；参见 §3.4）。
赋值语句首先让所有的表达式完成运算， 之后再做赋值操作。 因此，下面这段代码
```lua
i = 3
i, a[i] = i+1, 20
```
会把 `a[3]` 设置为 `20`，而不会影响到 `a[4]` 。 这是因为 `a[i]` 中的 `i` 在被赋值为 4 之前就被计算出来了（当时是 3 ）。 简单说 ，这样一行
```lua
x, y = y, x
```
会交换 x 和 y 的值， 及
```lua
x, y, z = y, z, x
```
会轮换 x，y，z 的值。
对全局变量以及表的域的赋值操作的含义可以通过元表来改变。 对 `t[i] = val` 这样的变量索引赋值， 等价于 `settable_event(t,i,val)`。 （关于函数 `settable_event` 的详细说明，参见 §2.4。 这个函数并没有在 `Lua` 中定义出来，也不可以被调用。 这里我们列出来，仅仅出于方便解释的目的。）
对于全局变量 x = val 的赋值等价于 _ENV.x = val （参见 §2.2）。
### 控制结构
`if`, `while`, `and` `repeat` 这些控制结构符合通常的意义，而且也有类似的语法：
```lua
stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
```
`Lua` 也有一个 `for` 语句，它有两种形式 （参见 §3.3.5）。
控制结构中的条件表达式可以返回任何值。 `false` 与 `nil` 两者都被认为是假。 所有不同于 `nil` 与 `false` 的其它值都被认为是真 （特别需要注意的是，数字 0 和空字符串也被认为是真）。
在 `repeat–until` 循环中， 内部语句块的结束点不是在 `until` 这个关键字处， 它还包括了其后的条件表达式。 因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。
goto 语句将程序的控制点转移到一个标签处。 由于句法上的原因， Lua 里的标签也被认为是语句：
```lua
stat ::= goto Name
stat ::= label
label ::= '::' Name '::'
```
除了在内嵌函数中，以及在内嵌语句块中定义了同名标签，的情况外， 标签对于它定义所在的整个语句块可见。 只要 `goto` 没有进入一个新的局部变量的作用域，它可以跳转到任意可见标签处。
标签和没有内容的语句被称为空语句，它们不做任何操作。
`break` 被用来结束 `while`、 `repeat`、或 `for` 循环，它将跳到循环外接着之后的语句运行：
```lua
stat ::= break
```
`break` 跳出最内层的循环。
`return` 被用于从函数或是代码块（其实它就是一个函数） 中返回值。 函数可以返回不止一个值，所以 `return` 的语法为
```lua
stat ::= return [explist] [';']
```
`return` 只能被写在一个语句块的最后一句。 如果你真的需要从语句块的中间 `return`， 你可以使用显式的定义一个内部语句块， 一般写作 `do return end`。 可以这样写是因为现在 `return` 成了（内部）语句块的最后一句了。
### For 语句
`for` 有两种形式：一种是数字形式，另一种是通用形式。
数字形式的 `for` 循环，通过一个数学运算不断地运行内部的代码块。 下面是它的语法：
```lua
stat ::= for Name ‘=’ exp ‘,’ exp [‘,’ exp] do block end
```
`block` 将把 `name` 作循环变量。 从第一个 `exp` 开始起，直到第二个 `exp` 的值为止， 其步长为第三个 `exp` 。 更确切的说，一个 `for` 循环看起来是这个样子
```lua
for v = e1, e2, e3 do block end
```
这等价于代码：
```lua
do
    local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
    if not (var and limit and step) then error() end
    var = var - step
    while true do
        var = var + step
        if (step >= 0 and var > limit) or (step < 0 and var < limit) then
            break
        end
        local v = var
        block
    end
end
```
注意下面这几点：