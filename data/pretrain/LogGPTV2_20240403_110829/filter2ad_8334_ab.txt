如果你使用过 Linux 系统，或多或少的经历过忘记系统密码导致无法进入系统的尴尬境地。我们的解决方案也堪称简单粗暴，直接进入 grub
引导修改密码。所以，如果设备触手可及，几乎不存在进不入系统的问题。
在摄像头这种运行着嵌入式 Linux 操作系统的设备上，也有一个类似 `grub` 的存在，它就是 `u-boot`。
重启设备，根据提示键入组合键进入到 `u-boot` 命令行界面。
`u-boot` 命令行内置了很多常用命令供我们使用，键入 `h` 查看帮助。
通过 `printenv` 打印出 `u-boot` 传递给内核的参数信息。
从部分参数的内容可以看到 `u-boot` 引导程序是如何移交控制权给内核的。
  * 首先为内核设置启动参数
`console=${consoledev},${baudrate} noinitrd mem=${mem} rw ${rootfstype}
init=linuxrc`
  * 将内核从 Flash 加载到内存中
  * 跳转到内存中内核的起始地址并执行
我们来重点看下启动参数的 `init` 字段。
`init` 字段设置内核执行的初始化进程名，比如上面的 `linuxrc`，它是位于文件系统根目录下的一段程序代码，负责后续的系统初始化工作。
是否可以直接修改 `init=/bin/sh` 从而实现在系统未初始化完成的时候访问根文件系统呢？我们不妨试一下，在 `u-boot` 命令行中修改参数
`sfboot` 中 `init` 字段的值为 `/bin/sh`并保存，修改后效果如下。（修改前做好参数的备份）
    console=${consoledev},${baudrate} noinitrd mem=${mem} rw ${rootfstype} init=/bin/sh
重启设备，正如我们所猜想的，修改内核执行的初始进程，我们成功获得了一个 `Shell`。
由于没有经过 `linuxrc` 的初始化过程，这样获得的 Shell 功能是很受限的。在该 shell 下编辑 `/etc/shadow`
文件，擦除或者破解 `root` 用户的密码，重启到 `u-boot` 命令行界面中修改回原来的启动参数并保存，再次重启到 Shell
登陆界面，即可获得一个具有完整功能的 Shell。
#### 3.5 打包上传固件
经过上面的步骤，我们已经可以登录到一个功能完整的 `Shell`，使用 `tar` 和 `tftp` 命令打包上传根文件系统到 tftp 服务器即可。
#### 3.6 其他技巧
在 `u-boot` 中提供了相关命令操作 Flash 芯片，所以也可以按照如下方式提取固件。（这种 cat 内存的方式只是一种思路，速度是内伤）
### 0x04 暴力读写固件存储芯片解锁新功能
本小节我们以另一款基于 gSOAP 协议的摄像头为例（固件存储芯片型号 `MX25LP128`），介绍如何用编程器读写 Flash 芯片，从而打开该摄像头的
telnet 服务。
#### 4.0 需要准备的工具
  * 25 系列芯片编程器
  * 电洛铁
  * ...
#### 4.1 读取固件
`MX25L128` 这款 25 系列 Flash 芯片可以直接在线读取，用 `夹子` 夹住 `Flash 芯片`，连接编程器即可读取其中的固件。
点击 `智能识别SmartID`，芯片型号识别成功后点击 `读取 Read` ，最后保存成文件即可。如下图，读取过程非常顺利。
#### 4.2 固件解压
`binwalk` 是 devttys0 大神开发的一款固件分析工具，强烈推荐使用 `Github`
上的[教程安装](https://github.com/devttys0/binwalk/blob/master/INSTALL.md)，直接 `apt-get` 安装会缺少很多依赖。
使用 `binwalk` 查看固件结构
内核编译（make）之后会生成两个文件，一个 Image，一个 zImage，其中 Image 为内核映像文件，而 zImage为内核的一种映像压缩文件。
那么 uImage 又是什么的？它是 uboot 专用的映像文件，它是在 zImage 之前加上一个长度为 64
字节的头部，说明这个内核的版本、加载位置、生成时间、大小等信息；其 `0x40` 之后与 zImage 没有区别。
固件使用的是 `squashfs` 文件系统，它是一套供 Linux 核心使用的 GPL
开源只读压缩文件系统。所以设备正常运行的时候是不能对固件进行修改的，在前面那部分，我们从串口进去通过修改内核的初始进程的方式进入系统，是由于系统尚未初始化完成，从而获得了对文件系统的读写权限。
在固件的后一部分，包含一个可以写入的区域。一个 `JFFS2`
文件系统，它是在闪存上使用非常广泛的读/写文件系统，设备运行过程中修改过的配置信息和其他数据将被写入这个文件系统中。
`squashfs` 文件系统开始于 `0x3800000`, 大小为 `6963644` 字节, 用 `dd` 命令提取该文件系统，用
`unsquashfs` 命令解压。
#### 4.3 解锁功能
熟悉文件系统结构和已有的命令
很明显，该固件的 `Shell` 是基于 `busybox` 提供的。从 `file` 指令的结果可以判断该摄像头是 32位 ARM 指令架构。
这个 `busybox` 是静态链接的，不依赖其他的库文件。可以直接利用 `qemu-arm` 模拟运行。
当然，我们也可以搭建一个 `qemu` 虚拟机。
在这个网站下载[ qemu
虚拟机镜像文件](https://people.debian.org/~aurel32/qemu/armel/)，然后按照如下方式启动虚拟机。
现在我们已经可以确定目标文件系统是存在 `telnetd` 命令的。在根目录下的 `boot.sh` 文件末尾添加以下内容，使设备在开启时自动启动
telnet 服务。
#### 4.4 重新封印
现在，对文件系统的简单修改已经完成了，我们该如何重新打包固件，以便重新刷回到设备呢？
还是从固件结构入手，如下
我们自定义的只是中间的文件系统部分。即 `0x3100000 - 0xB00000` 这一段。同时，这一段的长度并不等于 `squashfs`
文件系统的大小 `6963644` 字节，`squashfs` 文件系统末至下一段开始之前有一段 `0xff`的填充部分。
从 uImage 头信息可以看到，`image size` 为 `2217456`, 而 `squashfs` 文件系统的起始位置为
`3670016`，没有对 `squashfs` 文件系统做 `CRC` 检验。
根据以上结论判断，我们只需要在不改变原始固件结构的前提下，将修改后的文件系统重新打包成固件。
利用 `cat` 将各段连接起来
#### 4.5 刷回
Cheers，重新打包完成。利用编程器将修改后的固件离线刷入固件存储芯片即可。（在线刷各种坑，建议离线写入）
#### 4.6 成果
可以看到，我们成功开启了该摄像头的 `telnet` 服务。
### 0x05 总结
对智能设备的软硬件有足够的了解是深入挖掘设备漏洞的基础。本文是在对摄像头等物联网设备研究过程中的一些经验总结，希望对大家有所帮助。
* * *