ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
TOU by
Linux Kernel
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
TOC by Tracing
Programs
sys_enter tracepoint
ptrace
kprobe
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
TOU by
Linux Kernel
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
TOC by Tracing
Programs
sys_exit tracepoint
ptrace
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
TOU by
Linux Kernel
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU - Connect
User Space
Kernel 5.7.0
syscall enter
syscall exit
Execution Flow
Falco pdig
Falco (orig_ax)
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU Windows across Kernels
• TOCTOU windows exist since the initial release of tracepoint/ptrace
• Expected behaviors
• Monitor kernel memory
TOCTOU – Falco
• User space pointers are dereferenced by
• sys_exit tracepoint (kernel module, eBPF)
• sys_exit ptrace (pdig)
• Falco older than v0.31.1
• Check with vendors which commercial versions are affected
• 12/06/2021 Issue reported (CVE-2022-26316)
• 03/11/2022 Mitigation implemented (Advisory)
• For selected syscalls, compare sys_enter and sys_exit tracepoint data (Falco LKM, 
eBPF)
• Compare sys_enter and sys_exit ptrace data (Falco pdig)
TOCTOU – Falco 
• We evaluated the important syscalls in Falco rules.
Syscall
Category
TOCTOU?
Exploitable by blocking condition
Exploitable by DC29 attack
connect
Network
Y
Y
Y
sendto/sendmsg
Network
Y
N
Y
open(at)
File
Y
Y
Y
execve
File
N
N*
N*
rename
File
Y
Y
Y
renameat(2)
File
Y
Y
Y
mkdir(at)
File
Y
Y
Y
rmdir
File
Y
Y
Y
unlink(at)
File
Y
Y
Y
symlink(at)
File
Y
Y
Y
chmod/fchmod(at)
File
Y
Y
Y
creat
File
Y
Y
Y
Exploit Requirements
• Exploitation requirements
• No additional privilege and capabilities
• Control the time to inject the delay
• Enough delay for pointer overwrite
• Reliable
Exploit Strategy 1 (DEFCON 29)
Phantom Attack: Evading System Call Monitoring, DEFCON 29. https://github.com/rexguowork/phantom-attack
• Injected delay is small 
• Requires Userfaultfd syscall for precise injection while pausing the kernel 
execution
• seccomp can block userfaultfd syscall (e.g., docker default seccomp profile)
• Falco’s mitigation was to detect userfaultfd
Exploit Strategy 2
• Injected delay >> the syscall execution time
• No Precise control is required
Syscall Built-in Delay
• Attackers can trigger significant syscall delays by introducing:
• Blocking conditions (attack sys_exit)
• Seccomp rules (attack sys_enter)
• Syscall can get “blocked”
Categories
Syscalls
Process
fork/exec/exit/wait/…
File system
open(at)/symlink(at)/read/write/…
Networking
connect/accept/socket/…
Security
seccomp/keyctl/…
Many others…
…
Connect Syscall
Execution Flow
Bypassing Connect Syscall Tracing (Demo)
Execution Flow
Blocking Syscalls (File Systems)
• File system syscalls are all affected
• open/openat
• creat
• rename/renameat/renameat2
• mkdir/mkdirat
• rmdir
• Other file system syscalls with pointer arguments
• Other syscalls are also affected due to fetching files from file systems. 
• execve/execveat
Filesystem in USErspace - FUSE
1, https://github.com/GoogleCloudPlatform/gcsfuse
2, https://github.com/s3fs-fuse/s3fs-fuse
3, https://github.com/Azure/azure-storage-fuse
4, https://netflixtechblog.com/mezzfs-mounting-object-storage-in-netflixs-media-processing-platform-cda01c446ba
• User space filesystem framework
• Used as remote storage FUSE
• Access the remote files as local ones
• Faster evolvement and don’t panic the kernel etc.
• Remote storage FUSE examples:
• gcsfuse1 : developed by Google for GCS
• s3fs-fuse2: Amazon S3
• BlobFuse3: developed by Azure for Blob storage
• MezzFS4: developed and deployed @ Netflix
• Many others (sshfs etc.)
Remote Storage FUSE - Architecture
Bypassing Openat Tracing (Demo) 
Execution Flow
TOCTOU – sys_enter (Connect)
User Space
Kernel 5.7.0
syscall enter
syscall exit
Execution Flow
ptrace
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
TOU by
Linux Kernel
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
seccomp
Seccomp Introduction
• Kernel level mechanism to restrict syscalls
• Modern sandboxes heavily relies on seccomp
• Developers can write rules to:
• allow/block certain syscalls
• allow/block syscalls based on argument values
• These rules can be quite complex (read more)
• More rules takes more time to compute
• First inserted rules are evaluated last
Attacking Syscall Enter
Execution Flow
ptrace + seccomp redirect
• Tracer starts App
Exploitation and Mitigations
Tracing location
TOCTOU Exploitation
Mitigations
ptrace @ sys_enter
Seccomp filter insertion
-
ptrace + seccomp redirect to start the app.
-
Inspect seccomp filters already inserted 
when attaching to a running app 
tracepoint @ sys_enter
Unreliable
N/A
tracepoint @ sys_exit
-
Blocking syscall (This talk)
-
Phantom attack v1 
(DEFCON 29)
-
Compare tracepoint sys_enter and sys_exit 
args
ptrace @ sys_exit
Same as above
-
Deploy all mitigations for ptrace @ sys_enter
-
Compared the sys_enter and sys_exit syscall 
args
kprobe @ kernel internal
It depends
Read the kernel copy of the syscall args
-
LSM (BPF-LSM)
-
Other interfaces
Key Takeaways
1. Linux kernel tracing can be bypassed reliably
• Check your security tools
2. Mitigation is complex (workload type and kernel compatibility)
• Check your security tools’ mitigation claims
3. Correlate different data sources
4. Know your normal
• Discussing further?
• @Xiaofei_REX  / rex.guo *NOSPAM* lacework DOT com
• jzeng04 *NOSPAM* gmail DOT com
• POC: https://github.com/rexguowork/phantom-attack
Acknowledgement
• Joel Schopp (Linux kernel / Security)
• Lacework Labs
• James Condon
• Greg Foss
• Chris Hall
• Jared Stroud
• Falco open source team
• Leonardo Di Donato
• Michael Clark
• Michele Zuccala
• Luca Guerra
• John Dickson