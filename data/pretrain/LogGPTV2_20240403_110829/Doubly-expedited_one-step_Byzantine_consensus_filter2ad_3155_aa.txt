title:Doubly-expedited one-step Byzantine consensus
author:Nazreen Banu and
Taisuke Izumi and
Koichi Wada
名古屋工业大学学术机関リポジトリ Nagoya Institute of Technology Repository
Doubly-Expedited One-Step Byzantine Consensus
著者（英）
journal or
publication title
page range
year
URL
Nazreen Banu, Taisuke Izumi, Koichi Wada
Proceedings of the 2010 IEEE/IFIP
International Conference on Dependable Systems
and Networks (DSN)
373-382
2010-04-09
http://id.nii.ac.jp/1476/00005903/
doi: 10.1109/DSN.2010.5544293(http://dx.doi.org/10.1109/DSN.2010.5544293)
(c)2010 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all
other uses, in any current or future media, including reprinting/republishing this material for
advertising or promotional purposes, creating new collective works, for resale or redistribution to
servers or lists, or reuse of any copyrighted component of this work in other works.
Doubly-Expedited One-Step Byzantine Consensus
Nazreen Banu, Taisuke Izumi, Koichi Wada
Graduate school of Engineering,
Nagoya Institute of Technology, Gokisho-cho,
Showa-ku, Nagoya, Aichi, 466-8555, Japan.
Phone: +81-52-735-5408, Fax: +81-52-735-5408
PI:EMAIL,{t-izumi,wada}@nitech.ac.jp
April 9, 2010
Abstract
It is known that Byzantine consensus algorithms guarantee one-step decision only in favorable
situations (e.g. when all processes propose the same value) and no one-step algorithm can support two-
step decision. This paper presents DEX, a novel one-step Byzantine algorithm that circumvents these
impossibilities using the condition-based approach. Algorithm DEX has two distinguished features:
Adaptiveness and Double-expedition property. Adaptiveness makes it sensitive to only actual number
of failures so that it provides fast termination for more number of inputs when there are fewer failures (a
common case in practice). The double-expedition property facilitates two-step decision in addition to
one-step decision by running two condition-based mechanisms in parallel. To the best of our knowledge,
double-expedition property is the new concept introduced by this paper, and DEX is the ﬁrst algorithm
having such a feature. Although DEX takes four steps at worst in well-behaved runs while existing
one-step algorithms take only three, it is expected to work eﬃciently because the worst-case does not
occur so often in practice.
1 Introduction
1.1 Background
The consensus problem is central for the construction of fault-tolerant distributed systems. In the consen-
sus problem, each process proposes a value, and all non-faulty processes have to agree on a common value
which is one of the proposed values. Several practical agreement problems (such as atomic broadcast,
view synchrony, state-machine replication, etc.) can be implemented using a solution to the consensus
problem, and hence solving consensus is crucial in designing distributed systems.
The consensus problem has been studied with various failure models and diﬀerent synchrony as-
sumptions. This paper studies the consensus in asynchronous systems subject to Byzantine failures, i.e.,
faulty processes can behave in an arbitrary way, and there are assumptions neither about relative speed
of processes nor about timely delivery of messages.
To converge on a single decision value, consensus protocols need to exchange messages. Each message
exchange constitutes a communication step. The number of communication steps taken for reaching
agreement is an important measure to evaluate the eﬃciency of the consensus algorithms. A previous
work has proved that any consensus algorithm requires at least two communication steps for decision
even in failure-free executions [9]. This lower bound often becomes a dominant part of the performance
overhead imposed to consensus-based applications. However, this fact does not imply that the two-
step lower bound is incurred for every input (an input to consensus algorithms is deﬁned as a n-tuple
consisting of all proposed values). For example, it does not hold for the case where all processes propose
the same value. Furthermore, in typical runs of consensus-based applications, the consensus algorithm
often receives such “good” inputs. For instance, consider a replicated state machine: The replicated
servers need to agree on the processing order of the update requests. If a client broadcasts its request to
all servers and there is no contention, then all servers propose the same request as the candidate they
will handle next. Practically, it is not so often that two or more concurrent update-requests arise for the
same data object.
This observation induces an interest in one-step decision for good inputs. The attempts to circumvent
two-step lower bound are initiated by Brasileiro et al.[2]. They propose a general framework to convert any
crash-tolerant algorithm into the one that solves the consensus for any input, and especially terminates in
one step when all processes propose the same value. In the following results [3, 4], the notion of one-step
decision is considered in combination with other schemes such as randomization and failure detectors.
An interesting aspect of one-step decision schemes is to characterize the situations where one-step
decision is possible. The ﬁrst investigation in that aspect is considered by Mostefaoui et.al.[11], which
applies the condition-based approach for obtaining a good one-step decision scheme.
In general, the
condition-based approach deﬁnes a set of inputs, called condition, for which the condition-based algorithm
guarantees a certain kind of good property. The ﬁrst result with this approach[11] gives a suﬃcient class
of conditions such that we can construct the condition-based algorithm guaranteeing one-step decision
for any input belongs to the condition. This result is extended by Izumi and Masuzawa[8]. It gives the
complete characterization of conditions that makes one-step decision possible.
While all of the above results are considered on crash-failure model, a recent work (BOSCO)[12]
has devised one-step consensus algorithms on Byzantine failure model.
It has shown two variants of
one-step Byzantine consensus problem, weak and strong ones. The weakly one-step guarantees one-step
decision only when all processes propose the same value and no process is faulty, but the strongly one-
step must guarantee it in any situation only with a common proposed value, regardless of the number
of faulty processes. In addition, this result also proposed an algorithm for each variant and proved that
the assumptions n > 5t and n > 7t are necessary for weakly and strongly one-step Byzantine consensus
respectively, where n is the number of processes and t is the maximum number of faulty processes.
1.2 Our Contribution
As seen above, the research challenge centered in one-step consensus is to enhance and clarify the sit-
uations favoring one-step decision. In the same research direction, this paper also explores Byzantine
consensus problems with better one-step decision schemes. In particular, we focus on two features for
one-step decision schemes shown as follows:
Adaptive Condition-Based Approach Most of the one-step algorithms are designed with the aim
that they never violate agreement even if the number of failures is at the maximum. However, such
a design works as a pessimistic approach when actual number of faulty processes is small, which is
the usual case in real systems. An interesting way to circumvent this drawback is the use of adaptive
condition-based approach. Informally, the adaptive condition-based approach handles the condition that
dynamically changes according to the actual number of faulty processes (typically, fewer faults allow the
condition with more number of inputs). In the context of one-step consensus, it means that the algorithm
can terminate in one-step for more number of inputs when fewer processes are faulty. The notion of the
adaptive condition-based approach is ﬁrst introduced by Izumi and Masuzawa[7] and applied to one-step
consensus problem in crash-failure model[8]. However, there is no result to apply it in Byzantine-failure
model.
Double Expedition of One-Step Consensus One of the serious drawbacks in one-step decision
schemes is the impossibility of zero-degradation[6, 3]. Informally, the zero-degradation is an important
feature of consensus algorithms based on failure detectors, which always guarantees the best complexity
(i.e., two steps) in stable runs where the failure detector does not make any mistakes and its output is
stable. This impossibility result says that, to achieve one-step decision, any algorithm must sacriﬁce the
2
Table 1: Performance comparison of DEX with the existing works.
System Failure Number of Feasibility for
Model
Processes One-step Decision
Type
Feasibility for
Two-step Decision
Asyn.
Brasileiro et.al.[2]
Izumi et.al.[8]
Asyn.
Mostefaoui et.al.[11] Syn.
Asyn.
Friedman et.al.[5]
Crash
Crash
Crash
Byzan.
Yee et.al. [12]
(Bosco)
Asyn.
Byzan.
DEX
Asyn.
Byzan.
3t+1
3t+1
t+1
7t+ 1
5t+1
(Weak)
7t+ 1
(Strong)
6t+1
Agreed proposals
Condition-Based
Condition-Based
Agreed proposals
Agreed proposals
Agreed proposals of correct
processes
Condition-Based
–
–
–
–
–
–
Condition-Based
decision at the end of the second step. It is also shown that achieving both one-step decision and zero-
degradation needs more stronger assumption about failure detections such as the existence of eventually
perfect failure detector (cid:166)P . However, similar to the impossibility result of one-step decision [9], this
result does not necessarily imply the impossibility of two-step decision for any inputs. Thus, it yields an
interest to realize a doubly-expedited consensus algorithm, which equips a “conditional” two-step decision
scheme combined with one-step decision.
This paper contributes a doubly-expedited Byzantine consensus algorithm based on the adaptive condition-
based approach. The distinguished features of the proposed algorithm can be summarized as follows:
• In our construction, we ﬁrst show a generic framework of the algorithm based on the notion of
adaptive condition-based approach. Generally, in condition-based approach, adaptiveness property
can be characterized by a condition sequence, which is deﬁned as a sequence of t + 1 conditions
such that the k-th (0 ≤ k ≤ t) condition is valid when the actual number of faulty processes is k.
To attain the double-expedition property in adaptive manner, the framework is instantiated with
a pair of condition sequences, each of which corresponds to the situations of one-step and two-step
decisions respectively. We also show suﬃcient criteria, say legality, for the condition-sequence pair
such that the doubly-expedited algorithms can be instantiated using any condition-sequence pair
satisfying them.
• Two examples of legal condition-sequence pair, called frequency-based pair and privileged-value-
based pair, are proposed. They have distinct advantages in the sense that the expedited situations
corresponding to each pair is complementary.
Interestingly, the algorithm instantiated by the
frequency-based pair has more chances to decide in one or two steps compared to the existing
one-step Byzantine consensus algorithms.Table 1 compares this result with the previous results.
• One drawback of the proposed framework is that it trades the decision scheme at third step for
double-expedition property. This drawback causes a performance degradation in consensus-based
applications when we consider pessimistic runs (that is, the given input is out of the conditions).
However, standing on its optimistic counterpart, we make more inputs belong to the conditions so
that our algorithm decides in one or two steps for many cases and achieves better performance in
average.
To the best of our knowledge, double expedition property is the concept newly introduced in this
paper. Hence, this paper is the ﬁrst result showing the feasibility for taking both one- and two-step
decision schemes simultaneously with no help of additional stronger assumptions.