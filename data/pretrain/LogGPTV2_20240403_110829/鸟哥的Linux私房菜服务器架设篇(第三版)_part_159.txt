"/var/spool/mail/dmtsai": 10 messages 10 new N 1 PI:EMAIL Mon Aug 8 18:53 18/579 "from vbird"
....(中间省略)....
N 9 root Tue Aug 9 15:04 19/618 "Just test"
N 10 root Tue Aug 9 15:04 29/745 "My bashrc"
&  ’那个符号吧！那表示目前 mail 所在的邮件位置，你可以直接输
入 Enter 即可看到该封信件的内容！ 另外，你也可以在‘&’之后的光标位置
输入号码，就可以看该封信件的内容了！(注：如果持续按 Enter，则会自‘ > ’
符号所在的邮件逐次向后读取每封信件内容！)
 显示标题： (直接数入 h 或输入 h 数字)
例如有 100 封信，要看 90 封左右的信件标题，就输入‘ h90 ’即可。
 回复邮件： (直接输入 R )
如果要回复目前‘ > ’符号所在的邮件，直接按下‘ R ’即可进入刚刚前面介
绍过的 mail 文字编辑画面啰！你可以编辑信件后传回去啰！
PI:EMAIL
 删除邮件： (输入 d 数字)
按下‘ d## ’即可删除邮件！例如我要删除掉第 2 封邮件，可以输入‘ d2 ’
如果是要删除第 10-50 封邮件，可以输入‘ d10-50 ’来删除喔！请记得，如
果有删除邮件的话，离开 mail box 时，要使用‘ q ’才行！
 储存邮件到档案： (输入 s 数字 文件名)
如果要将邮件资料存下来，可以输入‘ s ## filename ’，例如我要将上面第 10
封邮件存下来，可以输入‘ s 10 text.txt ’即可将第一封邮件内容存成
text.txt 这个档案！
 离开 mail： (输入 q 或 x )
要离开 mail 可以输入 q 或者是 x，请注意‘输入 x 可以在不更动 mail box
的情况下离开 mail 程序，不管你刚刚有没有使用 d 删除数据；使用 q 才会将
删除的数据移除。’也就是说，如果你不想更动 mail box 那就使用 x 或 exit
离开，如果想要使刚刚移除的动作生效，就要使用 q 啦！
 请求协助：
关于 mail 更详细的用法可以输入 help 就可以显现目前的 mail 所有功能！
上面是简易的 mail 收信功能！不过，我们曾经将信件转存下来的话，那该如何读
取该信件呢？例如读取刚刚记录的 text.txt 邮件信箱。其实可以简单的使用这个方式
来读取：
[dmtsai@www ~]$ mail -f ~/text.txt
以‘附件夹带’的方式寄信
前面提到的都是信件的内容，那么有没有可能以‘附件’的方式来传递档案？是可
以的，不过你需要 uuencode 这个指令的帮忙，在 CentOS 当中这个指令属于
sharutils ，请先利用 yum 来安装他吧！接下来你可以这样使用：
[root@www ~]# [利用 uuencode 编码 ] | [利用 mail 寄出去]
[root@www ~]# uuencode [实际档案] [信件中的档名] | mail -s '标题' email
# 1. 将 /etc/hosts 以附件夹带的方式寄给 dmtsai
[root@www ~]# uuencode /etc/hosts myhosts | mail -s 'test encode' dmtsai
这样就能寄出去了，不过，如果收下这封信件呢？同样的我们得要透过译码器来解码啊！
你得先将该档案存下来，然后这样做：
# 底下的身份可是 dmtsai 这个用户喔！
PI:EMAIL
[dmtsai@www ~]$ mail
Heirloom Mail version 12.4 7/29/08. Type ? for help.
"/var/spool/mail/dmtsai": 11 messages 1 new 8 unread
1 PI:EMAIL Mon Aug 8 18:53 19/590 "from vbird"
....(中间省略)....
U 10 root Tue Aug 9 15:04 30/755 "My bashrc"
>N 11 root Tue Aug 9 15:12 29/1121 "test encode"
& s 11 test_encode
"test_encode" [New file] 31/1141
& exit
[dmtsai@www ~]$ uudecode test_encode -o decode
加密档 输出档
[dmtsai@www ~]$ ll *code*
-rw-r--r--. 1 dmtsai dmtsai 380 Aug 9 15:15 decode  [-s 信件标题] email地址
选项与参数：
-a 附加档：后面就是你想要传送给朋友的档案，是附加档案，不是信件内容
PI:EMAIL
喔！
-i 内文档：就是信件的内文部分，先编写成为档案而已；
-b 秘密副本：原收件者不知道这封信还会寄给后面的那个秘密副本收件者；
-c 一般副本：原收件者会看到这封信还有传给哪位收件者；
-s 信件标题：这还需要解释吗？这封信的标头！
email地址：就是原收件者的 email 啰！
# 1. 直接在线编写信件，然后寄给 PI:EMAIL 这个用户
[root@www ~]# mutt -s '一封测试信' PI:EMAIL
/root/Mail 不存在。建立吗？ ([yes]/no): y 
To: PI:EMAIL
Cc:
Bcc:
Subject: 一封测试信
Reply-To:
Fcc: ~/sent
Security: 清除
-- 附件
- I 1 /tmp/mutt-www-2784-0 [text/plain, 8bit, utf-8, 0.1K]
# 2. 将 /etc/hosts 当成信件内容寄给 PI:EMAIL 这个用
户
[root@www ~]# mutt -s 'hosts' -i /etc/hosts PI:EMAIL
# 记得最终在 vim 底下要按下 :wq 来储存寄出喔！
与 mail 在线编写文字不一样，mutt 竟然会呼叫 vi 让你去编辑你的信件！如此一来，
当然不需要预先编写信件内文了！ 这真是让人感到非常的开心啊！而且整个画面非常
的直觉化！相当容易处理呢！那么如果需要附件夹带呢？尤其是夹带 binary program
时，可以这样做：
# 1. 将 /usr/bin/passwd 当成附件夹带，寄给 PI:EMAIL 用户
[root@www ~]# mutt -s '附件' -a /usr/bin/passwd --
PI:EMAIL
To: PI:EMAIL
PI:EMAIL
Subject: 附件
不过是个附件测试！
y:寄出 q:中断 t:To c:CC s:Subj a:附加档案 d:叙述 ?:求助 
To: PI:EMAIL
Cc:
Bcc:
Subject: 附件
Reply-To:
Fcc: ~/sent
Security: 清除
-- 附件
- I 1 /tmp/mutt-www-2839-0 [text/plain, 8bit, utf-8, 0.1K] :下一页 v:显示附件。 d:删除 r:回复 j:下
一个 ?:求助
Date: Tue, 9 Aug 2011 15:24:34 +0800
From: root 
To: PI:EMAIL
Subject: 附件
User-Agent: Mutt/1.5.20 (2009-12-10)
[-- 附件 #1 --]
[-- 种类：textplain，编码：8bit，大小：0.1K --]
不过是个附件测试！ <==信件的内文部分