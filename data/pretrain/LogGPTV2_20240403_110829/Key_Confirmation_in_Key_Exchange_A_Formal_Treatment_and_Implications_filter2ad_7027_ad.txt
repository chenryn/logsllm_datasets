to condition on the existence of a partnered (honest) session
to the session (cid:2), e.g., adding the requirement ∃(cid:2)(cid:3)(cid:3) ∈ L(cid:3)
::
Partners((cid:2), (cid:2)(cid:3)(cid:3)) to the full key conﬁrmation predicate. But then
any (correct) key exchange protocol provides this kind of
“unauthenticated” full key-conﬁrmation anyway: Correctness
demands that partnered sessions (i.e., with the adversary only
passively relaying messages) derive the same key. This means
that such a session (cid:2)(cid:3)(cid:3) already serves as a partnered session
holding the same key according to our original deﬁnition.
In the case of almost-full key conﬁrmation, guarantees for
unauthenticated peers would again need to be conditioned on
an existing session sharing the same key conﬁrmation identiﬁer
(e.g., swapping in the requirement ∃(cid:2)(cid:3)(cid:3) ∈ L(cid:3)
(cid:2).kcid =
(cid:2)(cid:3)(cid:3).kcid for (cid:2).pid /∈ Corr ∪ {∗}). But then again, the natural
requirement of key-conﬁrmation identiﬁer binding (being part
of the almost-full key conﬁrmation property) already satisﬁes
almost-full key-conﬁrmation for such cases trivially: It ensures
that two sessions sharing the same key-conﬁrmation identiﬁer,
upon acceptance, will derive the same key. Thus, session (cid:2)(cid:3)(cid:3)
again serves as the desired partnered session according to out
current notion.
::
In conclusion, obtaining no advantage from deﬁnitions
encompassing unauthenticated peers, we focus on the key
conﬁrmation guarantees attainable when communicating with
an authenticated partner.
IV. KEY CONFIRMATION IN TLS 1.3 DRAFT-10
In this
section, we investigate the key conﬁrmation
properties provided by the currently developed next ver-
sion of the Transport Layer Security protocol (TLS 1.3).
the recent TLS 1.3 draft
More precisely, we consider
draft-ietf-tls-tls13-10 [29] (short: draft-10) and
its full (EC)DHE handshake. We remark that we do not
analyze key secrecy or Match security for draft-10, which is
beyond the scope of this work, but focus on key conﬁrmation.
Key secrecy for TLS 1.3 draft-10 and earlier draft versions
has been recently studied by Dowling et al. [18], [19]. We
furthermore do not treat the other handshake modes speci-
ﬁed in draft-10 for resumption (PSK/PSK-(EC)DHE) and
zero round-trip time (0-RTT) [29, Section 6.2] or extensions
added in later drafts like post-handshake client authentication
(draft-11 [30]).
Figure 3 depicts the TLS 1.3 draft-10 full (EC)DHE
handshake including the essential steps of the Difﬁe–Hellman-
based key derivation.8 We sometimes use abbreviated message
names (ClientHello = CH, ClientKeyShare = CKS, and so
on).
As in previous versions, TLS 1.3 in draft-10 employs
Finished messages (sent both by the client and the server),
which are essentially MAC values computed over the (hashed)
transcript (excluding the Finished messages), the so-called
“session hash”, in order to “provide[] key conﬁrmation” [29,
p. 31]. Importantly, in contrast to previous TLS versions, the
MAC key employed is not the derived session key, but a
separate ﬁnished_secret derived through a key derivation func-
tion from one of the secret Difﬁe–Hellman values established
within the key exchange. In that sense, draft-10 essentially
follows the popular paradigm we discuss in Section V to
exchange MACs over the transcript (or the session identiﬁers)
in order to achieve key conﬁrmation.
A. Key Conﬁrmation without Finished Messages
Interestingly, we can however actually show that already
a shortened variant of the draft-10 handshake without the
ClientFinished and ServerFinished messages (which we
denote as draft-10-nf) provides the same strongest form of
key conﬁrmation one can expect. That is, in the mutually
authenticating handshake the server is assured that the client
already accepted with the same key at the time the server
accepts while the client is assured that, if the server later
accepts, it will do so with the same key. In contrast, in the
unilaterally authenticating handshake—as expected—only the
client is guaranteed (full) key conﬁrmation.9 We will ﬁrst
elaborate in detail how to prove key conﬁrmation for the
shortened draft-10-nf handshake and then demonstrate in
Section IV-B how this result can easily be adapted to the actual
draft-10 handshake.
More formally, we show that the mutually authenticating
draft-10-nf handshake (short: draft-10-nf-m) achieves full
8In TLS 1.3 draft-10, handshake messages from EncryptedExtensions
on are sent encrypted under a separately derived handshake trafﬁc key
(independent of the ﬁnal session key). We disregard this handshake encryption
in our analysis as it does not affect the key conﬁrmation guarantees for the
ﬁnal session key we are interested in here.
9Observe that, for unilateral authentication, in contrast to draft-10 the
server sends the last protocol message in the shortened draft-10-nf variant
due to the omitted ﬁnished messages.
460460
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:58 UTC from IEEE Xplore.  Restrictions apply. 
Client
rc ← {0, 1}256
X ← g
x
ClientHello : rc
ClientKeyShare : X
Server
y
y
†
, SS = ES
rs ← {0, 1}256
Y ← g
ES ← X
xES ← HKDF.Extract(0, ES)
xSS ← HKDF.Extract(0, SS)
SCV ← Sign(skS, H(CH|| . . .||CR))
ﬁnished_secret ← HKDF.Expand(xSS,
SF ← HMAC(ﬁnished_secret,
kcid ← CH|| . . .||SCV
“finished secret”||H(CH|| . . .||SCV))
“server finished”||H(CH|| . . .||SCV))
x
†
, SS = ES
kcid ← CH|| . . .||SCV
ES ← Y
compute xES, xSS
compute ﬁnished_secret
verify SCV
check SF
CCV ← Sign(skC , H(CH|| . . .||CCRT))
CF ← HMAC(ﬁnished_secret,
“client finished”||H(CH|| . . .||CCV))
ServerHello : rs
ServerKeyShare : Y
∗
EncryptedExtensions
∗
ServerConfiguration
ServerCertificate : pkS
CertificateRequest
ServerCertificateVerify
ServerFinished
ClientCertificate : pkC
ClientCertificateVerify
ClientFinished
verify CCV
check CF
mES ← HKDF.Expand(xES, “expanded ephemeral secret”||H(CH|| . . .||SCV))
mSS ← HKDF.Expand(xSS, “expanded static secret”||H(CH|| . . .||SCV))
key ← HKDF.Expand(M S, “application data key expansion”||H(CH|| . . .||CCV))
M S ← HKDF.Extract(mSS, mES)
sid ← CH|| . . .||CCV
Figure 3: The TLS 1.3 draft-10 full (EC)DHE handshake protocol with Difﬁe–Hellman-based key derivation. Messages
ServerCertificate and ServerCertificateVerify are sent both for unilateral and mutual authentication, messages
CertificateRequest, ClientCertificate, and ClientCertificateVerify are only sent for mutual authentication.
Starred messages are situation-dependent and not always sent. In the computations, we abbreviate message names as
ClientHello = CH, ClientKeyShare = CKS, etc. Enumerations for session-hash values of messages exchanged (like
H(CH|| . . .||CCV)) always exclude the Finished messages. Without client authentication, the server may derive the session key
already after sending ServerFinished.
In the shortened draft-10-nf we deﬁne and analyze, the ServerFinished and ClientFinished messages are omitted.
† TLS 1.3 draft-10 allows handshake variants where the client announces knowledge of a cached server conﬁguration in
which case xSS is derived differently. We do not capture this variant in our analysis and hence omit it here for the ease of
presentation.
461461
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:58 UTC from IEEE Xplore.  Restrictions apply. 
(S,C)-key conﬁrmation and almost-full (C,S)-key conﬁr-
mation and that the unilaterally authenticating draft-10-nf
handshake (draft-10-nf-u) provides full (C,S)-key conﬁr-
mation. While we analyze both authentication variants of the
handshake separately, we remark that both results also hold
when handshakes are allowed to run with mutual and with
unilateral concurrently in our model, as the message ﬂow is
unique for each authentication variant which allows to tell the
according sessions apart.
a
is
on
the
our
For
over
both
variants
signature
handshake
ClientCertificateVerify
proofs
resp.
rely
exchanged, which
ServerCertificateVerify message
resp.
essentially
intuitively be
almost-complete transcript and can, hence,
seen as a signature-based analogue of
the MAC-based
transform discussed in Section V. We deﬁne the key-
conﬁrmation identiﬁers
to
kcid = ClientHello|| . . .||ServerCertificateVerify
by the server on sending its ServerCertificateVerify
message and by the client on receiving that message.
in draft-10-nf to be
complete
the
set
Theorem 4.1: The TLS 1.3 draft-10-nf-m handshake for
mutual authentication without ﬁnished messages satisﬁes full
(S,C)-key conﬁrmation and almost-full (C,S)-key conﬁrma-
tion. Formally, for any efﬁcient adversary A against full
(S,C)-key conﬁrmation resp. almost-full (C,S)-key conﬁrma-
tion there exist efﬁcient algorithms B1, B2 such that
(cid:2)
(cid:3)
ExpPred
draft-10-nf-m,A(n) = 1
s · 2−|nonce| + AdvCOLL
H,B1
Pr
≤ n2
+ nu · AdvEUF-CMA
Sig,B2
,
for Pred = FullConf(S,C) resp. Pred = AlmostConf(C,S),
where nu is the maximum number of participating parties, ns
is the maximum number of sessions, and |nonce| = 256 is the
bit-length of the nonces.
session,
for a server
Proof: We show that,
the
ClientCertificateVerify message of an honest client
sufﬁces as assurance that this client has accepted with the same
key when the server session accepts. In turn, for a client ses-
sion, the ServerCertificateVerify message of an honest
server ensures that this server agrees on the key-conﬁrmation
identiﬁer kcid and will, if it accepts, derive the same key. To
this extend we modify the original ExpPred
draft-10-nf-m,A(n) ex-
periment in three steps, showing that the advantage difference
of adversary A can each time be bounded by the advantage of
breaking the security of TLS 1.3 components, ﬁnally reaching
an experiment where the advantage of A is 0.
modiﬁed
experiment
First,
ExpPred
draft-10-nf-m,A(n) which is as before, except it aborts (and
outputs 0) if, during the execution, any two honest sessions
choose the same nonce (rc or rs). The probability that the
s · 2−|nonce|
experiment aborts can be bounded from above by n2
where ns is the maximum number of sessions and |nonce| is
consider
the
we
(cid:2)
the nonces’ bit-length. Therefore,
(cid:2)
(cid:3)
draft-10-nf-m,A(n) = 1
ExpPred
(cid:3)
draft-10-nf-m,A(n) = 1
(cid:2)
ExpPred
(cid:2)
Pr
≤ Pr
+ n2
s · 2−|nonce|.
(cid:2)(cid:2)
Second, we switch to ExpPred
draft-10-nf-m,A(n) in which we
also abort if, during the execution, any two honest sessions
compute the same hash value for two different
inputs to
the hash function H. We can bound the probability that this
experiment aborts for this reason by the advantage AdvCOLL
H,B1
of an adversary B1 against
the collision resistance of H.
For this purpose, B1 simply simulates ExpPred
draft-10-nf-m,A(n)
for A on its own and outputs the two colliding inputs when
they occur during the simulation, perfectly simulating the
experiment up to this point and always winning when the
modiﬁed experiment aborts. Hence we have that
(cid:2)(cid:2)
(cid:2)
(cid:2)
(cid:3)
draft-10-nf-m,A(n) = 1
ExpPred
(cid:3)
draft-10-nf-m,A(n) = 1
(cid:2)(cid:2)
ExpPred
(cid:2)
Pr
≤ Pr
+ AdvCOLL
H,B1
.
(cid:2)(cid:2)(cid:2)
Sig,B2
Third, we consider ExpPred
draft-10-nf-m,A(n), which, in addi-
tion, aborts whenever a simulated server resp. client ses-
sion obtains, within the ClientCertificateVerify resp.
ServerCertificateVerify message, a valid signature (un-
der the public key of some non-corrupted client resp. server i ∈
I) which was not output by any honest client resp. server
session. Again, we can bound the probability of this abort by
of an adversary B2 against the ex-
the advantage AdvEUF-CMA
istential unforgeability of the deployed signature scheme Sig,
simulating the experiment for A as follows. Initially, B2
randomly chooses a party i among the at most nu parties,
∗
with it, and generates
associating the challenge public key pk
the long-term key for all other parties i ∈ I \ {i}. During
the simulation, B2 then uses it signing oracle whenever a
signature needs to be computed under the secret key of i.
When a simulated session obtains a valid signature that no
other honest session has output, B2 aborts the experiment and
outputs that signature as its forgery. If B2 correctly guessed
the (non-corrupted) identity i under whose public key pk
the
obtained signature veriﬁes, this is a valid forgery and B2 wins,
thus