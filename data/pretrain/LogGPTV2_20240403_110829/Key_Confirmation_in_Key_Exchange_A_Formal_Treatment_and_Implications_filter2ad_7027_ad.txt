To condition on the existence of a partnered (honest) session, such as session (cid:2), we can add the requirement ∃(cid:3)(cid:3) ∈ L(cid:3) :: Partners((cid:2), (cid:3)(cid:3)) to the full key confirmation predicate. However, any correct key exchange protocol inherently provides this kind of "unauthenticated" full key confirmation. Correctness demands that partnered sessions (i.e., with the adversary only passively relaying messages) derive the same key. Therefore, such a session (cid:3)(cid:3) already serves as a partnered session holding the same key according to our original definition.

For almost-full key confirmation, guarantees for unauthenticated peers would need to be conditioned on an existing session sharing the same key confirmation identifier (e.g., by adding the requirement ∃(cid:3)(cid:3) ∈ L(cid:3) :: (cid:2).kcid = (cid:3)(cid:3).kcid for (cid:2).pid /∈ Corr ∪ {∗}). However, the natural requirement of key confirmation identifier binding, which is part of the almost-full key confirmation property, already ensures that two sessions sharing the same key confirmation identifier will derive the same key upon acceptance. Thus, session (cid:3)(cid:3) again serves as the desired partnered session according to our current notion.

In conclusion, since definitions encompassing unauthenticated peers do not provide additional advantages, we focus on the key confirmation guarantees attainable when communicating with an authenticated partner.

### IV. Key Confirmation in TLS 1.3 Draft-10

In this section, we investigate the key confirmation properties provided by the currently developed next version of the Transport Layer Security protocol (TLS 1.3), specifically draft-ietf-tls-tls13-10 [29] (short: draft-10) and its full (EC)DHE handshake. We do not analyze key secrecy or Match security for draft-10, which is beyond the scope of this work, but focus on key confirmation. Key secrecy for TLS 1.3 draft-10 and earlier draft versions has been recently studied by Dowling et al. [18], [19]. We also do not treat other handshake modes specified in draft-10 for resumption (PSK/PSK-(EC)DHE) and zero round-trip time (0-RTT) [29, Section 6.2] or extensions added in later drafts like post-handshake client authentication (draft-11 [30]).

Figure 3 depicts the TLS 1.3 draft-10 full (EC)DHE handshake, including the essential steps of the Diffie–Hellman-based key derivation. We sometimes use abbreviated message names (ClientHello = CH, ClientKeyShare = CKS, etc.).

As in previous versions, TLS 1.3 in draft-10 employs Finished messages (sent both by the client and the server), which are essentially MAC values computed over the (hashed) transcript (excluding the Finished messages), the so-called "session hash," to provide key confirmation [29, p. 31]. Importantly, in contrast to previous TLS versions, the MAC key employed is not the derived session key, but a separate finished_secret derived through a key derivation function from one of the secret Diffie–Hellman values established within the key exchange. In this sense, draft-10 follows the popular paradigm discussed in Section V to exchange MACs over the transcript (or the session identifiers) to achieve key confirmation.

#### A. Key Confirmation without Finished Messages

Interestingly, we can show that a shortened variant of the draft-10 handshake without the ClientFinished and ServerFinished messages (denoted as draft-10-nf) provides the same strongest form of key confirmation. In the mutually authenticating handshake, the server is assured that the client has accepted with the same key at the time the server accepts, while the client is assured that, if the server later accepts, it will do so with the same key. In the unilaterally authenticating handshake, only the client is guaranteed (full) key confirmation. We will first elaborate on how to prove key confirmation for the shortened draft-10-nf handshake and then demonstrate in Section IV-B how this result can be adapted to the actual draft-10 handshake.

More formally, we show that the mutually authenticating draft-10-nf handshake (short: draft-10-nf-m) achieves full (S,C)-key confirmation and almost-full (C,S)-key confirmation, and that the unilaterally authenticating draft-10-nf handshake (draft-10-nf-u) provides full (C,S)-key confirmation. While we analyze both authentication variants separately, we note that both results hold even when handshakes are allowed to run with mutual and unilateral authentication concurrently in our model, as the message flow is unique for each authentication variant, allowing us to distinguish the sessions.

For both variants, the proofs rely on the signature-based handshake, specifically the ClientCertificateVerify and ServerCertificateVerify messages, which can be seen as a signature-based analogue of the MAC-based transform discussed in Section V. We define the key confirmation identifiers (kcid) to be the complete set of messages up to and including the ServerCertificateVerify message.

**Theorem 4.1:** The TLS 1.3 draft-10-nf-m handshake for mutual authentication without finished messages satisfies full (S,C)-key confirmation and almost-full (C,S)-key confirmation. Formally, for any efficient adversary A against full (S,C)-key confirmation or almost-full (C,S)-key confirmation, there exist efficient algorithms B1, B2 such that:

\[
\Pr \left[ \text{Exp}_{\text{Pred}}^{\text{draft-10-nf-m},A}(n) = 1 \right] \leq n_s \cdot 2^{-|\text{nonce}|} + \text{Adv}_{\text{COLL}}^H(B_1) + n_u \cdot \text{Adv}_{\text{EUF-CMA}}^{\text{Sig}}(B_2),
\]

for Pred = FullConf(S,C) or Pred = AlmostConf(C,S), where \( n_u \) is the maximum number of participating parties, \( n_s \) is the maximum number of sessions, and \( |\text{nonce}| = 256 \) is the bit-length of the nonces.

**Proof:** We show that the ClientCertificateVerify message of an honest client suffices as assurance that the client has accepted with the same key when the server session accepts. For a client session, the ServerCertificateVerify message of an honest server ensures that the server agrees on the key confirmation identifier (kcid) and will, if it accepts, derive the same key. We modify the original experiment in three steps, showing that the advantage difference of adversary A can each time be bounded by the advantage of breaking the security of TLS 1.3 components, finally reaching an experiment where the advantage of A is 0.

1. **First Modification:** We consider the modified experiment \(\text{Exp}_{\text{Pred}}^{\text{draft-10-nf-m},A}(n)\), which aborts (and outputs 0) if any two honest sessions choose the same nonce (rc or rs). The probability that the experiment aborts can be bounded by \( n_s \cdot 2^{-|\text{nonce}|} \).

2. **Second Modification:** We switch to \(\text{Exp}_{\text{Pred}}^{\text{draft-10-nf-m},A}(n)\) in which we also abort if any two honest sessions compute the same hash value for two different inputs to the hash function H. The probability that this experiment aborts can be bounded by the advantage \(\text{Adv}_{\text{COLL}}^H(B_1)\) of an adversary B1 against the collision resistance of H.

3. **Third Modification:** We consider \(\text{Exp}_{\text{Pred}}^{\text{draft-10-nf-m},A}(n)\), which, in addition, aborts whenever a simulated server or client session obtains, within the ClientCertificateVerify or ServerCertificateVerify message, a valid signature (under the public key of some non-corrupted client or server i ∈ I) that was not output by any honest session. The probability of this abort can be bounded by the advantage \(\text{Adv}_{\text{EUF-CMA}}^{\text{Sig}}(B_2)\) of an adversary B2 against the existential unforgeability of the deployed signature scheme Sig.

Thus, the theorem holds, and the draft-10-nf-m handshake provides the desired key confirmation guarantees.