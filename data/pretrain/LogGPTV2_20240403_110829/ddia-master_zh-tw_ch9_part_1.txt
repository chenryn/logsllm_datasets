# 第九章：一致性与共识
![](../img/ch9.png)
> 好死还是赖活著？
> —— Jay Kreps, 关于 Kafka 与 Jepsen 的若干笔记 (2013)
---------------
[TOC]
正如 [第八章](ch8.md) 所讨论的，分散式系统中的许多事情可能会出错。处理这种故障的最简单方法是简单地让整个服务失效，并向用户显示错误讯息。如果无法接受这个解决方案，我们就需要找到容错的方法 —— 即使某些内部元件出现故障，服务也能正常执行。
在本章中，我们将讨论构建容错分散式系统的演算法和协议的一些例子。我们将假设 [第八章](ch8.md) 的所有问题都可能发生：网路中的资料包可能会丢失、重新排序、重复推送或任意延迟；时钟只是尽其所能地近似；且节点可以暂停（例如，由于垃圾收集）或随时崩溃。
构建容错系统的最好方法，是找到一些带有实用保证的通用抽象，实现一次，然后让应用依赖这些保证。这与 [第七章](ch7.md) 中的事务处理方法相同：透过使用事务，应用可以假装没有崩溃（原子性），没有其他人同时访问资料库（隔离），储存装置是完全可靠的（永续性）。即使发生崩溃，竞态条件和磁碟故障，事务抽象隐藏了这些问题，因此应用不必担心它们。
现在我们将继续沿著同样的路线前进，寻求可以让应用忽略分散式系统部分问题的抽象概念。例如，分散式系统最重要的抽象之一就是 **共识（consensus）**：**就是让所有的节点对某件事达成一致**。正如我们在本章中将会看到的那样，要可靠地达成共识，且不被网路故障和程序故障所影响，是一个令人惊讶的棘手问题。
一旦达成共识，应用可以将其用于各种目的。例如，假设你有一个单主复制的资料库。如果主库挂掉，并且需要故障切换到另一个节点，剩余的资料库节点可以使用共识来选举新的领导者。正如在 “[处理节点宕机](ch5.md#处理节点宕机)” 中所讨论的那样，重要的是只有一个领导者，且所有的节点都认同其领导。如果两个节点都认为自己是领导者，这种情况被称为 **脑裂（split brain）**，它经常会导致资料丢失。正确实现共识有助于避免这种问题。
在本章后面的 “[分散式事务与共识](#分散式事务与共识)” 中，我们将研究解决共识和相关问题的演算法。但首先，我们首先需要探索可以在分散式系统中提供的保证和抽象的范围。
我们需要了解可以做什么和不可以做什么的范围：在某些情况下，系统可以容忍故障并继续工作；在其他情况下，这是不可能的。我们将深入研究什么可能而什么不可能的限制，既透过理论证明，也透过实际实现。我们将在本章中概述这些基本限制。
分散式系统领域的研究人员几十年来一直在研究这些主题，所以有很多资料 —— 我们只能介绍一些皮毛。在本书中，我们没有空间去详细介绍形式模型和证明的细节，所以我们会按照直觉来介绍。如果你有兴趣，参考文献可以提供更多的深度。
## 一致性保证
在 “[复制延迟问题](ch5.md#复制延迟问题)” 中，我们看到了资料库复制中发生的一些时序问题。如果你在同一时刻检视两个资料库节点，则可能在两个节点上看到不同的资料，因为写请求在不同的时间到达不同的节点。无论资料库使用何种复制方法（单主复制、多主复制或无主复制），都会出现这些不一致情况。
大多数复制的资料库至少提供了 **最终一致性**，这意味著如果你停止向资料库写入资料并等待一段不确定的时间，那么最终所有的读取请求都会返回相同的值【1】。换句话说，不一致性是暂时的，最终会自行解决（假设网路中的任何故障最终都会被修复）。最终一致性的一个更好的名字可能是 **收敛（convergence）**，因为我们预计所有的副本最终会收敛到相同的值【2】。
然而，这是一个非常弱的保证 —— 它并没有说什么时候副本会收敛。在收敛之前，读操作可能会返回任何东西或什么都没有【1】。例如，如果你写入了一个值，然后立即再次读取，这并不能保证你能看到刚才写入的值，因为读请求可能会被路由到另外的副本上。（请参阅 “[读己之写](ch5.md#读己之写)” ）。
对于应用开发人员而言，最终一致性是很困难的，因为它与普通单执行绪程式中变数的行为有很大区别。对于后者，如果将一个值赋给一个变数，然后很快地再次读取，不可能读到旧的值，或者读取失败。资料库表面上看起来像一个你可以读写的变数，但实际上它有更复杂的语义【3】。
在与只提供弱保证的资料库打交道时，你需要始终意识到它的局限性，而不是意外地作出太多假设。错误往往是微妙的，很难找到，也很难测试，因为应用可能在大多数情况下执行良好。当系统出现故障（例如网路中断）或高并发时，最终一致性的边缘情况才会显现出来。
本章将探索资料系统可能选择提供的更强一致性模型。它不是免费的：具有较强保证的系统可能会比保证较差的系统具有更差的效能或更少的容错性。尽管如此，更强的保证能够吸引人，因为它们更容易用对。只有见过不同的一致性模型后，才能更好地决定哪一个最适合自己的需求。
**分散式一致性模型** 和我们之前讨论的事务隔离级别的层次结构有一些相似之处【4,5】（请参阅 “[弱隔离级别](ch7.md#弱隔离级别)”）。尽管两者有一部分内容重叠，但它们大多是无关的问题：事务隔离主要是为了 **避免由于同时执行事务而导致的竞争状态**，而分散式一致性主要关于 **在面对延迟和故障时如何协调副本间的状态**。
本章涵盖了广泛的话题，但我们将会看到这些领域实际上是紧密联络在一起的：
* 首先看一下常用的 **最强一致性模型** 之一，**线性一致性（linearizability）**，并考察其优缺点。
* 然后我们将检查分散式系统中 [**事件顺序**](#顺序保证) 的问题，特别是因果关系和全域性顺序的问题。
* 在第三节的（“[分散式事务与共识](#分散式事务与共识)”）中将探讨如何原子地提交分散式事务，这将最终引领我们走向共识问题的解决方案。
## 线性一致性
在 **最终一致** 的资料库，如果你在同一时刻问两个不同副本相同的问题，可能会得到两个不同的答案。这很让人困惑。如果资料库可以提供只有一个副本的假象（即，只有一个数据副本），那么事情就简单太多了。那么每个客户端都会有相同的资料检视，且不必担心复制滞后了。
这就是 **线性一致性（linearizability）** 背后的想法【6】（也称为 **原子一致性（atomic consistency）**【7】，**强一致性（strong consistency）**，**立即一致性（immediate consistency）** 或 **外部一致性（external consistency ）**【8】）。线性一致性的精确定义相当微妙，我们将在本节的剩余部分探讨它。但是基本的想法是让一个系统看起来好像只有一个数据副本，而且所有的操作都是原子性的。有了这个保证，即使实际中可能有多个副本，应用也不需要担心它们。
在一个线性一致的系统中，只要一个客户端成功完成写操作，所有客户端从资料库中读取资料必须能够看到刚刚写入的值。要维护资料的单个副本的假象，系统应保障读到的值是最近的、最新的，而不是来自陈旧的快取或副本。换句话说，线性一致性是一个 **新鲜度保证（recency guarantee）**。为了阐明这个想法，我们来看看一个非线性一致系统的例子。
![](../img/fig9-1.png)
**图 9-1 这个系统是非线性一致的，导致了球迷的困惑**