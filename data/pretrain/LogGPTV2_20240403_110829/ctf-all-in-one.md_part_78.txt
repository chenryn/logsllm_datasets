将一段代码划分为一个个基本块，然后根据控制转移语句指明的跳转到的代码的位
置，将基本块连接起来。
对于调用图的构建，如果是直接过程调用的程序，每个调用的目标都可以静态确
定，则调用图中的每个调用点恰好有一条边指向一个调用过程。但如果程序使用了
过程参数或者函数指针，则通过静态分析只能得到近似的估计。对于面向对象程序
设计语言来说，间接调用才是常用的方式。此时需要分析调用点调用所接收对象的
类型来确定调用的是哪个方法。
漏洞分析规则
程序漏洞通常和程序中变量的状态或者变量的取值相关。状态自动机可以描述和程
序变量状态相关的漏洞分析规则，自动机的状态和变量相应的状态对应。和变量取
值相关的检测规则通常包含和程序语句或者指令相关的对变量取值的记录规则以及
在特定情况下变量取值需要满足的约束。
一个描述指针变量使用的有限状态自动机的例子：
811
5.4 数据流分析
一个用于检测缓冲区溢出漏洞的分析变量取值的规则如下：
char a[10]; // len(a) = 10;
[...]
strcpy(dest, src); // len(dest) > len(src);
静态漏洞分析
数据流分析检测漏洞是利用分析规则按照一定的顺序分析代码中间表示的过程。
过程内分析。对于抽象语法树的分析，可以按照程序执行语句的过程从右向左、自
底向上地进行分析。对于三地址码的分析，则可以直接识别其操作以及操作相关的
变量。
通常，赋值语句、控制转移语句和过程调用语句是数据流分析最关心的三类语句。
通过赋值语句，程序变量的状态或者取值常常会改变，在分析过程中，可以根据分
析规则将所关心的变量的状态或取值记录下来。在分析的同时还需要考虑到控制转
移语句中的路径条件。对过程调用语句的分析需要根据函数或方法的名字识别其语
义或者根据调用图进行过程间的分析。通过将代码语义和漏洞分析规则联系起来，
就能确定在分析中需要记录怎样的信息。
过程内分析的另一个关键是确定分析语句的顺序，即利用程序语句的存储位置或者
根据控制流图依次确定待分析的每一条程序语句。在流不敏感分析中，常常使用线
性扫描的方式依次分析每一条中间表示形式的语句；流敏感的分析或路径敏感的分
析，则根据控制流图进行分析。对控制流图的遍历主要是深度优先和广度优先两种
方式。在遍历并分析程序的过程中，需要在基本块上保存一定的部分分析结果，以
为之后的分析所用。基本块的摘要通常包括前置条件和后置条件两部分，前置条件
记录对基本块分析前已有的相关分析结果；后置条件是分析基本块后得到的结果。
812
5.4 数据流分析
在分析基本块之前，首先使用该节点的前向节点的后置条件，计算该基本块的前置
条件，如果该基本块已经被分析过，则将已有的前置条件和计算得到的前置条件相
比较，如果相同，则不需要再对该块进行分析。
过程间分析。一个简单的思路是：如果在分析某段程序中遇到过程调用语句，就分
析其调用过程的内部的代码，完成分析之后再回到原来的程序段继续分析。另一种
思路是借鉴基本块的分析，给过程设置上摘要，也包含前置条件和后置条件。
指向分析
指向分析（points-to analysis）用于回答变量指向哪些被分配空间的对象这样的问
题。通过对待分析的程序使用指向分析，可以大致确定变量指向哪些对象，进而构
建相对准确的调用图。指向分析常常需要虚拟一个存储空间，用于记录被分配空间
的对象。
例如下面这段 Java 代码：
obj = new Type(); // 在虚拟存储空间记录一个对象 o，同时记录变量 obj
指向对象 o
obj1 = obj2; // 如果 obj2 指向对象 o2，则记录 obj1 指向对象 o2
obj1.field = obj2; // 记录 obj1 的实例域 field 指向 obj2 指向的对象
obj2 = obj1.field; // 记录 obj2 指向对象 obj1 的实例域 field
对于 C 语言的指向分析就相对复杂一些，因为 C 语言可以使用指针变量。指针变
量存储的是某个对象在存储空间中的地址，所以在指向分析中，通常还要加入地址
这样的信息，主要有下面四种形式的赋值语句：
p = q;
p = &q;
p = *q;
*p = q;
通过指向分析，可以得到变量指向的被分配空间的对象集合。根据集合中对象的类
型以及程序中类的层次结构，可以大致确定某个调用点调用的方法是哪些类中声明
的方法。指向分析的结果中如果两个变量指向的对象的集合是相同的，则可以确定
它们互为别名。
813
5.4 数据流分析
实例分析
检测指针变量的错误使用
在检测指针变量的错误使用时，我们关心的是变量的状态。
下面看一个例子：
int contrived(int *p, int *w, int x) {
int *q;
if (x) {
kfree(w); // w free
q = p;
}
[...]
if (!x)
return *w;
return *q; // p use after free
}
int contrived_caller(int *w, int x, int *p) {
kfree(p); // p free
[...]
int r = contrived(p, w, x);
[...]
return *w; // w use after free
}
可以看到上面的代码可能出现 use-after-free 漏洞。
这里我们采用路径敏感的数据流分析，控制流图如下：
814
5.4 数据流分析
815
5.4 数据流分析
调用图如下：
下面是用于检测指针变量错误使用的检测规则：
v 被分配空间 ==> v.start
v.start: {kfree(v)} ==> v.free
v.free: {*v} ==> v.useAfterFree
v.free: {kfree(v)} ==> v.doubleFree
分析过程从函数 contrived_call 的入口点开始，对于过程内代码的分析，使用深度
优先遍历控制流图的方法，并使用基本块摘要进行辅助，而对于过程间的分析，选
择在遇到函数调用时直接分析被调用函数内代码的方式，并使用函数摘要。
函数 contrived 中的路径有两条：
BB0->BB1->BB2->BB3->BB5->BB6：在进行到 BB5 时，BB5 的前置条件为
p.free, q.free 和 w.free，此时语句 q1 = *q 将触发 use-after-free 规则并设
置 q.useAfterFree 状态。然后返回到函数 contrived_call 的 BB2，其前置条件
为 p.useAfterFree, w.free，此时语句 w1 = *w 设置 w.useAfterFree。
BB0->BB1->BB3->BB4->BB6：该路径是安全的。
检测缓冲区溢出
在检测缓冲区溢出时，我们关心的是变量的取值，并在一些预定义的敏感操作所在
的程序点上，对变量的取值进行检查。
816
5.4 数据流分析
下面是一些记录变量的取值的规则：
char s[n]; // len(s) = n
strcpy(des, src); // len(des) > len(src)
strncpy(des, src, n); // len(des) > min(len(src), n)
s = "foo"; // len(s) = 4
strcat(s, suffix); // len(s) = len(s) + len(suffix) - 1
fgets(s, n, ...); // len(s) > n
817
5.4.1 Soot
5.4.1 Soot
参考资料
参考资料
https://github.com/Sable/soot/
A Survivor's Guide to Java Program Analysis with Soot
Analyzing Java Programs with Soot
The Soot framework for Java program analysis: a retrospective
818
5.5 污点分析
5.5 污点分析
污点分析
基本原理
方法实现
实例分析
动态污点分析
基本原理
方法实现
实例分析
污点分析
基本原理
污点分析是一种跟踪并分析污点信息在程序中流动的技术。在漏洞分析中，使用污
点分析技术将所感兴趣的数据（通常来自程序的外部输入）标记为污点数据，然后
通过跟踪和污点数据相关的信息的流向，可以知道它们是否会影响某些关键的程序
操作，进而挖掘程序漏洞。即将程序是否存在某种漏洞的问题转化为污点信息是否
会被 Sink 点上的操作所使用的问题。
污点分析常常包括以下几个部分：
识别污点信息在程序中的产生点（Source点）并对污点信息进行标记
利用特定的规则跟踪分析污点信息在程序中的传播过程
在一些关键的程序点（Sink点）检测关键的操作是否会受到污点信息的影响
举个例子：
819
5.5 污点分析
[...]
scanf("%d", &x); // Source 点，输入数据被标记为污点信息，并且认为变
量 x 是污染的
[...]
y = x + k; // 如果二元操作的操作数是污染的，那么操作结果也是污
染的，所以变量 y 也是污染的
[...]
x = 0; // 如果一个被污染的变量被赋值为一个常数，那么认为它
是未污染的，所以 x 转变成未污染的
[...]
while (i  0)
y = 1;
else
y = 0;
变量 y 的取值依赖于变量 x 的取值，如果变量 x 是污染的，那么变量 y 也应该是污
染的。
通常我们将使用污点分析可以检测的程序漏洞称为污点类型的漏洞，例如 SQL 注
入漏洞：
820
5.5 污点分析
String user = getUser();
String pass = getPass();
String sqlQuery = "select * from login where user='" + user + "'
and pass='" + pass + "'";
Statement stam = con.createStatement();
ResultSetrs = stam.executeQuery(sqlQuery);
if (rs.next())
success = true;
在进行污点分析时，将变量 user 和 pass 标记为污染的，由于变量 sqlQuery 的值
受到 user 和 pass 的影响，所以将 sqlQuery 也标记为污染的。程序将变量
sqlQuery 作为参数构造 SQL 操作语句，于是可以判定程序存在 SQL 注入漏洞。
使用污点分析检测程序漏洞的工作原理如下图所示：
基于数据流的污点分析。在不考虑隐式信息流的情况下，可以将污点分析看做
针对污点数据的数据流分析。根据污点传播规则跟踪污点信息或者标记路径上
的变量污染情况，进而检查污点信息是否影响敏感操作。
基于依赖关系的污点分析。考虑隐式信息流，在分析过程中，根据程序中的语
句或者指令之间的依赖关系，检查 Sink 点处敏感操作是否依赖于 Source 点处
接收污点信息的操作。
方法实现
821
5.5 污点分析
静态污点分析系统首先对程序代码进行解析，获得程序代码的中间表示，然后在中
间表示的基础上对程序代码进行控制流分析等辅助分析，以获得需要的控制流图、
调用图等。在辅助分析的过程中，系统可以利用污点分析规则在中间表示上识别程
序中的 Source 点和 Sink 点。最后检测系统根据污点分析规则，利用静态污点分析
检查程序是否存在污点类型的漏洞。
基于数据流的污点分析
在基于数据流的污点分析中，常常需要一些辅助分析技术，例如别名分析、取值分
析等，来提高分析精度。辅助分析和污点分析交替进行，通常沿着程序路径的方向
分析污点信息的流向，检查 Source 点处程序接收的污点信息是否会影响到 Sink 点
处的敏感操作。
过程内的分析中，按照一定的顺序分析过程内的每一条语句或者指令，进而分析污
点信息的流向。
记录污点信息。在静态分析层面，程序变量的污染情况为主要关注对象。为记
录污染信息，通常为变量添加一个污染标签。最简单的就是一个布尔型变量，
表示变量是否被污染。更复杂的标签还可以记录变量的污染信息来自哪些
Source 点，甚至精确到 Source 点接收数据的哪一部分。当然也可以不使用污
染标签，这时我们通过对变量进行跟踪的方式达到分析污点信息流向的目的。
例如使用栈或者队列来记录被污染的变量。
程序语句的分析。在确定如何记录污染信息后，将对程序语句进行静态分析。
通常我们主要关注赋值语句、控制转移语句以及过程调用语句三类。
赋值语句。
对于简单的赋值语句，形如 a = b 这样的，记录语句左端的变量和
右端的变量具有相同的污染状态。程序中的常量通常认为是未污染
的，如果一个变量被赋值为常量，在不考虑隐式信息流的情况下，认
为变量的状态在赋值后是未污染的。
对于形如 a = b + c 这样带有二元操作的赋值语句，通常规定如
果右端的操作数只要有一个是被污染的，则左端的变量是污染的（除
非右端计算结果为常量）。
对于和数组元素相关的赋值，如果可以通过静态分析确定数组下标的
取值或者取值范围，那么就可以精确地判断数组中哪个或哪些元素是
污染的。但通常静态分析不能确定一个变量是污染的，那么就简单地
认为整个数组都是污染的。
对于包含字段或者包含指针操作的赋值语句，常常需要用到指向分析
822
5.5 污点分析
的分析结果。
控制转移语句。
在分析条件控制转移语句时，首先考虑语句中的路径条件可能是包含
对污点数据的限制，在实际分析中常常需要识别这种限制污点数据的
条件，以判断这些限制条件是否足够包含程序不会受到攻击。如果得
出路径条件的限制是足够的，那么可以将相应的变量标记为未污染
的。
对于循环语句，通常规定循环变量的取值范围不能受到输入的影响。
例如在语句 for (i = 1; i < k; i++){} 中，可以规定循环的上
界 k 不能是污染的。
过程调用语句。
可以使用过程间的分析或者直接应用过程摘要进行分析。污点分析所
使用的过程摘要主要描述怎样改变与该过程相关的变量的污染状态，
以及对哪些变量的污染状态进行检测。这些变量可以是过程使用的参
数、参数的字段或者过程的返回值等。例如在语句 flag =
obj.method(str); 中，str 是污染的，那么通过过程间的分析，将
变量 obj 的字段 str 标记为污染的，而记录方法的返回值的变量 flag
标记为未污染的。
在实际的过程间分析中，可以对已经分析过的过程构建过程摘要。例
如前面的语句，其过程摘要描述为：方法 method 的参数污染状态决
定其接收对象的实例域 str 的污染状态，并且它的返回值是未受污染
的。那么下一次分析需要时，就可以直接应用摘要进行分析。
代码的遍历。一般情况下，常常使用流敏感的方式或者路径敏感的方式进行遍
历，并分析过程中的代码。如果使用流敏感的方式，可以通过对不同路径上的
分析结果进行汇集，以发现程序中的数据净化规则。如果使用路径敏感的分析
方式，则需要关注路径条件，如果路径条件中涉及对污染变量取值的限制，可
认为路径条件对污染数据进行了净化，还可以将分析路径条件对污染数据的限
制进行记录，如果在一条程序路径上，这些限制足够保证数据不会被攻击者利
用，就可以将相应的变量标记为未污染的。
过程间的分析与数据流过程间分析类似，使用自底向上的分析方法，分析调用图中
的每一个过程，进而对程序进行整体的分析。
基于依赖关系的污点分析
823
5.5 污点分析
在基于依赖关系的污点分析中，首先利用程序的中间表示、控制流图和过程调用图
构造程序完整的或者局部的程序的依赖关系。在分析程序依赖关系后，根据污点分
析规则，检测 Sink 点处敏感操作是否依赖于 Source 点。
分析程序依赖关系的过程可以看做是构建程序依赖图的过程。程序依赖图是一个有
向图。它的节点是程序语句，它的有向边表示程序语句之间的依赖关系。程序依赖
图的有向边常常包括数据依赖边和控制依赖边。在构建有一定规模的程序的依赖图
时，需要按需地构建程序依赖关系，并且优先考虑和污点信息相关的程序代码。
实例分析
在使用污点分析方法检测程序漏洞时，污点数据相关的程序漏洞是主要关注对象，
如 SQL 注入漏洞、命令注入漏洞和跨站脚本漏洞等。
下面是一个存在 SQL 注入漏洞 ASP 程序的例子：
<%
Set pwd = "bar"
Set sql1 = "SELECT companyname FROM " & Request.Cookies("hel