Move无法直接对其进行操作，但是ShadowMove可以直接使用重复的句柄（例如，句柄1），因为它是在ShadowMove的上下文中创建的。接下来，Shad
owMove调用WSADuplicateSocket与自己共享Handle1。结果，创建了句柄2，并将其放入WSAPROTOCOL_INFO结构的dwProviderReserved字段中。最后，ShadowMove以WSAPROTOCOL_INFO结构作为一个参数调用WSASocket，以使Handle
2成为功能性的套接字句柄。由于WSADuplicateSocket和WSASocket是在同一进程（即ShadowMove）中调用的，因此无需在进程之间传递WSAPROTOCOL_INFO结构。
**(c)Linux上的套接字复制**
在Linux（或*
NIX）上的套接字复制设计与Windows上的套接字复制不同。由于更严格的进程隔离，即使另一个进程由同一用户拥有，也无法直接从另一个进程复制套接字。但是，Linux上支持套接字共享，但是这需要两个进程之间的合作。由于ShadowMove假定受害者应用程序不合作，因此解决方案是通过将代码注入到其地址空间中来强制受害者应用程序进行合作，以建立与ShadowMove
process的套接字共享。要将代码注入受害者应用程序，创建了一个启动器，它将启动受害者应用程序作为子进程，然后利用ptrace以共享库的形式注入代码。最后，在命令搜索路径中将启动器版本放在原始受害者应用程序的前面，以便用户在运行受害者应用程序时会调用启动器。
应该注意，与Windows上的ShadowMove相比，使用进程注入可以减少Linux上ShadowMove攻击的隐蔽性。但是，Linux设计仍然有很大的机会规避最先进的防御措施。将对评估进行详细讨论。
**Linux上的套接字共享：**
为了共享一个套接字，两个进程首先通过Unix域套接字连接，然后发送方进程调用sendmsg并在输入参数中传递套接字描述符，而接收方调用recvmsg并从中检索一个（可能不同的）套接字描述符。输出参数。当以这种方式传递套接字描述符时，底层的Linux内核会在接收进程的地址空间中创建一个新的描述符，该地址指向内核中与结束进程发送的描述符相同的文件表条目。
更具体地说，在Linux上有四个ShadowMove攻击组件，分别是目标进程，共享库，启动器和ShadowMove（下图）。
启动程序通过使用ptrace将共享库注入目标进程，该进程必须首先附加到目标进程。当前的Linux系统对ptrace施加了严格的控制。具体来说，默认情况下，Yama
Linux安全模块（LSM）仅允许具有sudo特权的进程或从父进程到子进程的ptrace。使用第二个选项，因此不需要特权升级。启动器将目标应用程序作为子进程运行，然后使用ptrace附加到目标进程。之后，它调用__libc_dlopen_mode将共享库加载到目标进程中。
本研究开发了共享库的原型，该共享库的构造函数（在加载库时自动执行）枚举目标进程中的打开套接字。对于每个打开的套接字，它使用dup方法创建该套接字的副本，通过Unix域套接字连接到ShadowMove进程，并使用该通道共享重复的套接字。如果没有打开的套接字，它将休眠一段时间并尝试再次查找打开的套接字。为了避免阻塞目标进程的主线程，创建了一个专用于套接字复制的新线程。
为了使受害用户在打算运行目标应用程序时无意中运行启动器，给启动器起一个与目标应用程序相同的名称，并确保启动器在命令搜索路径中位于目标应用程序的前面，可以通过更改PATH环境变量来完成。为了使攻击更加隐秘，如果当前命令搜索路径上的任何位置是（1）受害用户可写的并且（2）在目标应用程序的位置之前，则可以避免更改PATH环境变量。情况下，只需要在该可写位置复制启动器即可。否则，将创建一个看起来是良性的文件夹（例如，可被名为npm的良性应用程序使用的/home/alice/.npm-packages/bin），将启动器复制到此处，然后添加通过将export PATH = / path / of / the / launcher：$
PATH添加到受害者用户的.bashrc中，将新文件夹位置添加到PATH环境变量中。
例如，如果ftp是目标应用程序，则启动器将命名为ftp。当用户尝试运行FTP时，启动器将被执行，它将作为子进程运行原始FTP应用程序
**(d)良性应用程序与攻击之间的竞争**
应该注意，在提出的攻击中，套接字在原始客户端和攻击者之间共享，这可能导致从远程端点接收和发送数据时出现竞争状况。首先调用recv函数的人将从输入缓冲区中获取数据，而首先调用send函数的人会将数据发送至服务器。这可能导致从服务器读取部分响应或向服务器发送乱码请求。为了避免这种可能性，攻击者可以在客户端正在从服务器发送/接收数据时，暂时将客户端进程暂停，然后再恢复客户端进程。要暂停客户端进程，攻击者可以通过调用SuspendThread暂停其所有线程，而要恢复客户端进程，攻击者可以使用ResumeThread恢复所有线程。
###  5）横向移动计划器（LMP）
横向移动计划器（LMP）可以使敌方协调多个受害者系统上的攻击行动，从而优化攻击效率和隐蔽性。例如，假设上图中的攻击者已承诺将主机A和B都连接到主机C，但是它们各自的连接不足以进行横向移动（例如，A的连接只能复制恶意软件，而B的连接只能执行恶意软件）。在这种情况下，同时涉及A和B的协调计划（例如，将恶意软件复制到C，然后B远程在C上启动恶意软件）将允许横向迁移到C，从而使攻击更加有效。对于另一个示例，如果存在到目标系统的多条路径，则协调计划将允许攻击者使用最短路径将有效载荷发送到目标/从目标接收到数据，从而使攻击更加隐秘。假设攻击者寻找一组特定的目标，这些目标可以在达到目标时被识别。
**在Prolog中制定了攻击计划问题：**
使用上表中的谓词指定受感染网络的当前状态：system和connected指定可访问系统及其互连，并且commit定义了ShadowMove实例已在系统上执行的操作。对于每个协议，还使用能力谓词来指定攻击者劫持相应TCP连接时可以执行的操作。
前图展示了系统B（IP地址为10.10.10.50）ShadowMove知识库的快照，该知识库由一组事实组成，这些事实代表具有三个受感染系统和一个目标的网络。此知识库是从所有Shadow
Move实例之间共享的全局视图构造的。 LMP使用以下规则来确定是否可以在给定系统X的远程系统Y上执行特定操作。
通过使用remoteOperation，ShadowMove实例可以检查两个系统之间是否存在路径，以允许它们执行特定的操作，例如执行或上载文件。例如，攻击者可以执行以下查询：
它返回[010.10.10.100，0 10.10.10.300，0
10.10.10.1000]。此结果意味着，到达10.10.10.10并已移至10.10.10.30的攻击者可以通过ShadowMove执行器之一将恶意软件从10.10.10.30复制到10.10.10.100。可以使用remoteOperation谓词来构造更复杂的谓词，例如commitExecuteOperation：
为了从受威胁的系统上在目标系统上运行ShadowMove，不仅这两个系统之间必须存在允许ShadowMove立场执行执行操作的连接，而且文件还必须通过以下方式上载到该目标系统：执行操作之前的阴影移动实例之一。例如，在前图中，当且仅当（1）存在允许系统B在系统C上执行文件的连接时，系统B才能在系统C（目标）上启动ShadowMove：
（2）ShadowMove二进制文件已上传到系统C：
如果基于其当前的知识库，没有任何ShadowMove实例将文件上传到目标上，则系统B必须等待直到ShadowMove实例之一（例如系统A上的一个）提交了上载操作。系统B可以在其上启动ShadowMove的目标系统，系统B上的ShadowMove实例可以执行以下查询：
如果返回的ExecuteList不为空（例如[‘10
.10.10.100’]），则可以在新的目标系统（例如10.10.10.100）上启动ShadowMove的实例。这是横向移动的说明，它要求在不同路径之间进行协调，只有在可以全面了解受感染网络的情况下才有可能。
###  6）横向移动执行器
横向移动执行器（LMA）是一个模块管理器，其中包含多个执行模块。这些模块中的每一个都负责处理一种协议，例如TDS。
LMA可以采取被动和主动行动。在被动模式下，模块仅绕过MSG_PEEK标志从套接字读取，以进行Recv
API调用。这样，不会清空输入缓冲区，因此原始进程可以读取内容。在活动模式下，模块不通过MSG_PEEK标志就从套接字读取数据；因此recvcall会消耗输入缓冲区中的数据。在这种状态下，模块还写入套接字输出缓冲区以发送经过精心设计的消息。
在某些协议中需要学习一些秘密，然后才能制作有效的消息（例如，WinRM的shellID）。在这些情况下，执行器模块以被动模式启动，嗅探接收消息以了解此类秘密值。在学习了所有这些必需的数据元素之后，执行器模块可以将其自身切换到活动模式并开始与远程端点进行通信。值得注意的是，LMA模块只能读取传入的消息。它无法读取传出的消息，没有这样的API允许人们从套接字输出缓冲区中读取消息。在当前的原型中，LMA具有用于FTP，MS
SQL和WinRM协议的三个驱动模块。但是，可以通过实现称为IPModule的接口向LMA添加新协议。
## 0x04 Prototypes for ShadowMove Actuators
用2,501行C / C ++代码在Windows上实现了ShadowMove设计的原型。横向移动计划器基于SWI-Prolog，它是Prolog编程语言的免费实现。原型展示了一些常见功能，例如连接检测，套接字复制，网络视图同步和横向移动计划；它还克服了操作上的挑战，即如何使注入的数据包与各自的协议保持一致，并且对横向移动（例如上传恶意软件和启动恶意软件）有用，这特定于各个应用程序协议。
在本节中介绍三个利用FTP，MS
SQL和WinRM的ShadowMove执行器。正如在之前中讨论的那样，选择这些协议的标准是它们缺乏对消息来源完整性的支持。具体来说，FTP和Microsoft
SQL没有原始完整性强制，而WinRM没有足够的原始完整性强制。
###  1）ShadowMove实例化
对于每个实验，首先准备一个包含受害者应用程序的目标环境，例如，一台运行FTP客户端的计算机和另一台运行FTP服务器的计算机。对应用程序进行配置，以使它们不会按预期目的运行，在受害客户端计算机上启动ShadowMove
PoC。观察到，一旦建立候选PoC，PoC就会定期检测候选TCP连接（受害客户端应用程序不必在PoC之前启动），复制相应的套接字，并确定在TCP连接上运行的协议（例如FTP）
。
PoC定期查询横向移动计划器模块（通过显示其当前网络视图），并在计划程序返回下一个移动目标时执行执行器逻辑（例如，使用FTP连接将PoC复制到FTP服务器）
。在服务器计算机上启动PoC时，看到它检测到活动的TCP连接（包括与客户端计算机的TCP连接）并复制了相应的套接字，进一步观察到，服务器上的PoC与客户端上的PoC成功交换了“信号”消息，然后它们交换了当前的网络视图。这样，两台计算机上的网络视图都会更新。一段时间后，再次查询横向移动计划器模块，以基于新的网络视图做出下一个决定。
上述情况对于所有三个执行器都是通用的。因此，在单个执行器的描述中省略了这些细节。利用FTP的ShadowMove
PoC演示视频可在（
）中找到上述情况的案例。在本演示中，将ShadowMove PoC移至FTP服务器后手动启动它，但是可以通过WinRM自动启动PoC。