木村
荒木
山本
内田
*
显然，这样会有间题，必须马上重新分配房间。我们面对的问题是如
何查出住宿日期重叠的客人并列表显示。
下面，我们给重叠的住宿日期分类，可知一共有下面三种类型。
■日期的重叠美型
(1)自己的入住日期在他人的住宿期间内
自己
他人
(2)自己的真店日期在人的住宿期间内
自己
形人
(3}自己的入住日期和离店日期都在他人的住宿期间内
自己
他人
例如，在看来，荒木是属于类型(1)的：相反，在荒木看来，是
属于类型(2)的。而山本的住宿期间完全在内田的住宿期间内，所以在山
本看来，内田是属于类型（3)的。因此，我们只要找出满足这三种类型中
任意一种的客人就可以了。但是，稍微考虑一下我们就会发现，其实类型
(3)的情况忽略掉也没有问题。原因是，满足(3)和同时满足(1)、(2)是等
价的。
因此，充要条件是满足类型(1)和类型（2)中至少一个条件，解答如
下所示。
SELECT reserver, start_date, end_date
--求重叠的住宿期问
FROM Reservations R1
MHERE EXISTS
(SELECT *
---
## Page 121
108—第1章神奇的SQL
FROM Reservations R2
MHERE R1.reserver R2.reserver--与自已以外的客人进行比较
AND I R1.atart_date BSIwEEN R2.start_date AND R2.end_date
--条件[1）：自己的入住日期在他人的住宿期间内
OR R1.end_date
BSIXEsN R2.atart_date AND R2.end_date)1 ,
--条件[2）：自己的商店日期在勉人的住有期问内
■执行结果
reserver start_date end_date
荒木
2006-10-282006-10-31
 .........
—........:
2006-10-312006-11-01
山本
内田
2006-11-03
2006-11-04
2006-11-032006-11-05
请注意，因为自己和自己在住宿期间上肯定是重叠的，所以如果没有
R1.reserver<>R2.reserver这个条件，所有人都会出现在结果列表里。
相反，如果想求“与任何住宿期间都不重叠的日期”，我们只需要把
EXISTS谓词改写成NOT EXISTS谓词就可以了。
下面继续分析上面的SQL语句。如果山本的入住日期不是11月3号，
而是推迟了一天，即11月4号，那么查询结果里将不会出现内田。这是
因为，内田的入住日期和离店日期都不再与任何人重叠，于是条件（1)和
条件（2）就都不满足了。换句话说，像内田这种自己的住宿期间完全包含
了他人的住宿期间的情况，会被这条SQL语句排除掉。
如果想把这样的住宿期间也输出，我们需要追加条件。
--升级版：把完全包含别人的住有期间的情况也输出
SEL&cT reserver, start_date, end_date
FROM Reservatioms R1
MHERE EXISTS
(SELECT *
FROM Reservaticns R2
XHERE R1.reserver <> R2-reserver
AND I (
Rl.start_date BEIwEEM R2.start_date
AND R2.end_date
OR R1.end_date
BSIWEEN R2.start_date
R2.start_date BSrwEEN R1.start_date
AND R2.end_date)
OR（
AND R1.end_date
AND R2.end_date
BSIWEEN R1.start_date
AND R1.end_date)) ↓
---
## Page 122
1-6用关联子查询比较行与行—109
这里追加的条件是把前面的条件中的OR改写成了AND，R1改写成了
R2，刚好相反。
本节小结
通过本节的例题，相信你已经明白了关联子查询是一种非常强大的运
算。在这里，我们也公正地介绍一些它的缺点。第一个缺点是代码的可读
性不好。可能也是因为还不太习惯使用关联子查询，所以使用了关联子查
询的SQL语句一般都不能让人一眼就看明白。特别是在计算累计值和移
动平均值的例题里，与聚合一起使用后，其内部处理过程非常难理解。第
二个缺点是性能不好。特别是在SELECT子句里使用标量子查询时，性能
可能会变差，需要注意一下。借用JoeCelko的话来说就是，程序员和查
询优化者都很难读懂关联子查询。
注0
无论使用什么语言和什么技术，都没有万能的银弹·。我们掌握的任
双锐色子弹，在传说中，银色子
弹往往被描经成具有驱魔功效的
何一样东西，都像一把双刃剑，有看好和坏两面。关联子查询这样的具有
有效性的解决方法，相当于杀手
然图，级在多被比喻为具有相端
强大威力的武器也有着与其能力相当的缺点。希望大家明白这一点，然后
帆、量强杀相、王牌等。
—编者注
运用智慧合理地利用它。
下面是本节要点。
1.作为面向集合语言，SQL在比较多行数据时，不进行排序和循环。
2.SQL的做法是添加比较对象数据的集合，通过关联子查询（或者自
连接）一行一行地偏移处理。如果选用的数据库支持窗口函数，也可以考
虑使用窗口函数。
3.求累计值和移动平均值的基本思路是使用冯·诺依曼型递归集合。
4.关联子查询的缺点是性能及代码可读性不好。
5.人生中不可能所有的事情都一帆风顺。
如果大家想了解史多关十关联子查询的内容，请参考下面的资料。
1.JceCelko，《SQL权威指南（第4版》（人民邮电出版社，2013年）
关于累计值的求法，请参考该书31.6节“累积统计”。
---
## Page 123
110—第1章神奇的SOL
注0
2.JoeCelko，《SQL编程风格》（人民邮电出版社，2008年）
豪宗蒸译。机械工业出版社，
2000年。—编者注
该书可以说是Brian W.Kemighan和Rob Pike的著作《程序设计实践》的
SQL版，是一本值得细细品味的书。6.9节“避免使用关联子查询”从
代码可读性和性能的角度讲解了为什么要避免滥用关联子查询。
3.JoeCelko，《SQL解惑（第2版）》（人民邮电出版杜，2008年）
关于累计值的计算，请参考“谜题35库存调整”：关于移动平均值的求
题6预约旅馆房间”和“谜题47连号的座位”
4.明智重藏——求移动平均值
(http://oraclesqlpuzzle.hp.infoseek.co.jp/8-5.html)
文中分别介绍了使用窗口函数和关联子查询求移动平均值的方法。其中，
使用关联子查询的实现方法用到了BETWEEN谓词，非常简洁。
练习题
练习题1-6-1：简化多行数据的比较
在“用列表展示与上一年的比较结果”部分，我们比较了企业每年的
营业额与上一年相比是否增加。其实，第一条SQL的性能还有改善的余地。
在三个WHEN子句里，同样的子查询执行了三次，有点多余，所以请把它
们整合在一个WHEN子句里。
●练习题1-6-2：使用OVERLAPS查询重叠的时间区间
很多人都不知道，SQL-92 提供了 oVERLAPs 谓词（Oracke 和 PostgreSQL
已支持），目的正是用来查询重叠的时间区间。这个谓词的用法如下所示。
（开始日期1，结束日期1）OVERLAPS（开始日期2，结束日期2）
请使用这个函数改写“查询重叠的时间区间”部分里的SQL（P.108），
并对比一下执行结果。正文中使用的是BETWEEN，而这里是OVERLAPS，
这两种方法的执行结果稍微有点不同。理解其区别在哪儿就是这道练习题
的目的。
图灵社区会员非洲铜(PI:EMAIL)专享尊重版权
---
## Page 124
1-6用关联子查询比较行与行一
-111
练习题1-6-3：SUM函数可以计算出累计值，那么MAX、MIN
AVG可以计算出什么？
“移动累计值和移动平均值”部分介绍了求累计值的SQL语句。如果
又是什么呢？
sELBcr pre_date, pre_ant,
窗口函数版
MAX (pzc_ant) OVER (ORDER BY pzc_date) AS onhand_max
FE:OM Aceoumt.8;
SELECT pre_date, A1.prc_ant,
-关联子查询版版
(SELBCT MUX (pxc_ant)
FROM Accounta A2
HHERE Al.prc_date >= A2.prc_date ) AS cnhand_nax
osep"oxd x8 H2T0
FROM Accounts A1
■执行结果
prc_date
prc_ant
onhand_max
2006-10-26
*******
12000
2006 -10-28
2500
2006 -10-31
-15000
2006 -11-03
34000
这里的值
2006 -11-04
-5000
是？
2006 -11-06
7200
2006-11-11
11000
用MAX函数计算之后，也请再用MIN函数和AVG函数计算一下。实
际执行之前，请先思考一下，然后再确认执行结果与设想是否一样。
---
## Page 125
●112-
一第1章种奇的SQL
用SQL进行集合运算
SQL和集合论
SQL语言的基础之一是集合论。但是，很长一段时间内，由于SQL没能很好地支持集合运算，所以
相关功能并没有被人们充分地利用。过去这些年，SQL凑齐了大部分基础的集合运算，人们终于可以真
正地使用它了。本节，我们将学习一些使用了集合运算的技术，并深入思考一下它们背后的思想。
写在前面
集合论是SQL语言的根基
一一这是贯穿全书的主题之一。因为它的
这个特性，SQL也被称为面向集合语言。笔者认为，只有从集合的角度来
思考，才能明白SQL的强大威力。但是，实际上这一点长期以来都被很
多人忽略了。
造成这种状况，SQL本身也是要负一定责任的。其实，在很长一段时
间内，SQL连我们在高中学习过的基础的集合运算符都没有。UNION是
SQL-86标准开始加入的，还算比较早，而INTERSECT和EXCEPr 都是
SQL-92标准才加入的。至于关系除法运算（DIVIDEBY），更是至今还没
有被标准化，这个前面也提到过。有人以此来批评SQL作为一种语言来
说并不完整，这种看法也不是没有道理的，
但是，今天的标准SQL已经包含了大部分基础的集合运算符，各大
数据库提供商也紧随其后给出了相关功能的实现，人们终于可以真正地使
用它了，本节将介绍一些使用了集合运算的好用的SQL，解释一下它们的
思路，并从不同角度来深入了解SQL的本质。
导入篇：集合运算的几个注意事项
顾名思义，集合运算符的参数是集合，从数据库实现层面上来说就是
表或者视图。因为和高中学过的集合代数很像，所以理解起来相对比较容
易。但是，SQL还是有几个特别的地方需要注意一下。
图灵社区会员非洲铜(PI:EMAIL）专享尊重版权
---
## Page 126
1-7用SCL进行集合运算113
注意事项1：SQL能操作具有重复行的集合，可以通过可选项ALL
来支持
一般的集合论是不允许集合里存在重复元素的，因此集合{1，1,2,3,3，
3}和集合{1,2,3}被视为相同的集合。但是关系数据库里的表允许存在重
复的行，称为多重集合（multiset,bag）。
因此，SQL的集合运算符也提供了允许重复和不允许重复的两种用法。
如果直接使用UNION或INTERS&CT，结果里就不会出现重复的行。如果
想在结果里留下重复行，可以加上可选项ALL，写作UNION ALL。ALL的
作用和 SBLECT子句里的DISTINCT可选项刚好相反。但是，不知道为什么，
SQL并不支持UNIONDISTINCT这样的写法。
除了运算结果以外，这两种用法还有一个不同。集合运算符为了排除
掉重复行，默认地会发生排序，而加上可选项ALL之后，就不会再排序，
所以性能会有提升。这是非常有效的用于优化查询性能的方法，所以如果
不关心结果是否存在重复行，或者确定结果里不会产生重复行，加上可选
项ALL会更好些。
注意事项2：集合运算符有优先级
标准 SQL规定，INTERSECT 比UNION和 EXCEPT优先级更高。因此，
当同时使用UNION和INTERSECT，又想让UNION优先执行时，必须用括
号明确地指定运算顺序（本节最后有一道练习题是关于这个知识点的，可
以练习一下）
注意事项3：各个DBMS提供商在集合运算的实现程度上参差不齐
前面说过，早期的SQL对集合运算的支持程度不是很高。受到这一
点影响，各个数据库提供商的实现程度也参差不齐。SQLServer从2005
版开始支持INTERSECT和EXCBPT，而MySQL还都不支持（包含在“中
长期计划”里）。还有像Oracle这样，实现了ExCEPT功能但却命名为
MINUs的数据库。这一点比较麻烦，因为Oracle用户需要在使用时将
EXCEPT全部改写成 MINUS。
注意事项4：除法运算没有标准定义
四则运算里的和（UNION）、差（EXCEPT）、积（CROSSJOIN）都被引
---
## Page 127
114—第1章神奇的SOL
入了标准SQL。但是很遗撼，商（DIVIDEBY）因为各种原因迟迟没能标
准化（具体原因请参考1-4节里的解释）。因此，现阶段我们需要自己写
SQL语句来实现除法运算。
比较表和表：检查集合相等性之基础篇
接下来，我们来看看集合运算的实际应用。
在迁移数据库的时候，或者需要比较备份数据和最新数据的时候，我
们需要调查两张表是否是相等的。这里说的“相等”指的是行数和列数以
及内容都相同，即“是同一个集合”的意思。例如，下面的表tbl_A和
tbl_B，虽然名称不同，但是是同一个集合。
■名字不同但内容相同的两张表
tbl_A
tbl_B
C
5
6
L
5
1
6
有没有什么办法能让我们像比较文件一样来比较两张表是相等还是
不相等呢？如果像上面这两张表一样，只有几行数据，那么用眼睛就能看
清楚。但是，如果是几百列或者几千万行，就不可能用眼睛看清楚了。