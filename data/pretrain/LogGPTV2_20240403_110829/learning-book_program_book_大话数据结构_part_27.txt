访问其实是要根据实际的需要来确定具体做什么，比如对每个结点进行相关计
算，输出打印等，它算作是一个抽象操作。在这里我们可以简单地假定就是输出结点
的数据信息。
二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的
遍历方式。树的结点之间不存在唯一的前驱和后继关系，在访间问一个结点后，下一个
被访问的结点面临着不同的选择。就像你人生的道路上，高考填志愿要面临哪个城
市、哪所大学、具体专业等选择，由于选择方式的不同，遍历的次序就完全不同了。
BB
Q
GAMES
DILETS
REFRESH
图6-8-1
6.8.2二叉树遍历方法
二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就
分为四种：
1.前序遍历
规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子
树，再前序遍历右子树。如图6-8-2所示，遍历的顺序为：ABDGHCEIF。
175
---
## Page 200
大话数据结构
图6-8-2
2.中序遍历
规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结
点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。如图6-8-3
所示，遍历的顺序为：GDHBAEICF。
B
图6-8-3
3.后序遍历
规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左
右子树，最后是访问根结点。如图6-8-4所示；遍历的顺序为：GHDBIEFCA。
176
---
## Page 201
第6章树
6-8-4
4.层序遍历
规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，
从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如图6-8-5所
示，遍历的顺序为：ABCDEFGHI。
R
8-9
有同学会说，研究这么多遍历的方法干什么呢？
我们用图形的方式来表现树的结构，应该说是非常直观和容易理解，但是对于计
算机来说，它只有循环、判断等方式来处理，也就是说，它只会处理线性序列，面我
们刚才提到的四种遍历方法，其实都是在把树中的结点变成某种意义的线性序列，这
就给程序的实现带来了好处。
另外不同的遍历提供了对结点依次处理的不同方式，可以在遍历过程中对结点进
行各种处理。
177
---
## Page 202
大调数报结构
6.8.3前序遍历算法
二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其
简洁明了。先来看看二叉树的前序遍历算法。代码如下：
/·二叉树的前序遍历递归算法*/
if（T==NULL)
return;
printE（“c"，T->data）:/显示结点数据，可以更改为其他对结点操作*/
PreOrderTraverse（T->lchild）：/再先序遍历左子树*/
PreOrderTraverse（T->rchild）;/*最后先序遍历右子树*/
假设我们现在有如图6-8-6这样一棵二叉树T。这树已经用二叉链表结构存储在内
存当中。
A
D
(E
?
H
K
图6-8-6
那么当调用PreOrderTraverse（T）函数时，我们来看看程序是如何运行的。
1.调用PreOrderTraverse（T），T根结点不为null，所以执行printf，打印字母
A，如图6-8-7所示。
A)
B
C
D
(E
(F
H
图6-8-7
178
---
## Page 203
第6章树
2.调用PreOrderTraverse（T->khild）：访问了A结点的左孩子，不为null，执行
printf显示字母B，如图6-8-8所示。
A
B
D
E
F
G
H
1
K
图6-8-8
3.此时再次递归调用PreOrderTraverse（T->khid）：访问了B结点的左孩子，执
行printf显示字母D，如图6-8-9所示。
A
B
C
D
E
F
H
?
图6-8-9
4.再次递归调用PreOrderTraverse（T->khil）：访问了D结点的左孩子，执行
printf显示字母H，如图6-8-10所示。
A
B
D
E
F
G
H
K
图6-8-10
5.再次递归调用PreOrderTraverse（T->khid）：访问了H结点的左孩子，此时因
为H结点无左孩子，所以T==null，返回此函数，此时递归调用
179
---
## Page 204
大话
数据结构
PreOrderTraverse（T>rchil）：访问了H结点的右孩子，printf显示字母K，
如图6-8-11所示。
A
B
C
D
E
F
G
H
K
图 6-8-11
6.再次递归调用PreOrderTraverse（T->khid）;访问了K结点的左孩子，K结点
无左孩子，返回，调用PreOrderTraverse（T->rchid）：访问了K结点的右孩
子，也是null，返回。于是此函数执行完毕，返回到上一级递归的函数（即
打印H结点时的函数），也执行完毕，返回到打印结点D时的函数，调用
PreOrderTraverse（T->rchild）：访问了D结点的右孩子，不存在，返回到B
结点，调用PreOrderTraverse（T->rchild）：找到了结点E，打印字母E，如图
6-8-12所示。
A
B
C
D
（E）
F
G
H
1
图6-8-12
7.由于结点E没有左右孩子，返回打印结点B时的递归函数，递归执行完毕，
返回到最初的PreOrderTraverse，调用PreOrderTraverse（T->rchid）；访问结
点A的右孩子，打印字母C，如图6-8-13所示。
180
---
## Page 205
海毫9
B
C
D
E
H
K
图 6-8-13
8.之后类似前面的递归调用，依次继续打印F、I、G、J，步骤略。
综上，前序遍历这棵二叉树的节点顺序是：ABDHKECFIGJ。
6.8.4中序遍历算法
那么二叉树的中序遍历算法是如何呢？哈哈，别以为很复杂，它和前序遍历算法
仅仅只是代码的顺序上的差异。
/二叉树的中序遍历递归算法·/
voidInOrderTraverse(BiTree T)
if（T--NULL)
return;
printf（"&c"，T->data）/·显示结点数据，可以更改为其他对结点操作·/
InOrderTraverse（T->rchild）：/*最后中序遍历右子树*/
换句话说，它等于是把调用左孩子的递归函数提前了，就这么简单。我们来看看
当调用InOrderTraverse（T）函数时，程序是如何运行的。
1.调用InOrderTraverse（T），T的根结点不为null，于是调用InOrderTraverse
（T->khild）；访问结点B，当前指针不为null，继续调用InOrderTraverse（T->
khild）：访问结点D。不为null，继续调用InOrderTraverse（T->khid）：访问
结点H。继续调用InOrderTraverse（T->khid）；访问结点H的左孩子，发现
当前指针为null，于是返回。打印当前结点H，如图6-8-14所示。
181
---
## Page 206
大话
E
G
H
图6-8-14
2.然后调用InOrderTraverse（T->rchil）：访问结点H的右孩子K，因结点K无
左孩子，所以打印K，如图6-8-15所示。
D
E
F
G
H
K
图 6-8-15
3.因为结点K没有右孩子，所以返回。打印结点H函数执行完毕，返回。打印
字母D，如图6-8-16所示。
?
F
G
H
O
K
图6-8-16
4.结点D无右孩子，此函数执行完毕，返回。打印字母B，如图6-8-17所示。
182
---
## Page 207
第6章树
B
D
E
H
K
图 6-8-17
5.调用InOrderTraverse（T->rchid）；访问结点B的右孩子E，因结点E无左孩
子，所以打印E，如图6-8-18所示。
入
B
E
G
H
K
图6-8-18
6.结点E无右孩子，返回。结点B的递归函数执行完毕，返回到了最初我们调
用InOrderTraverse的地方，打印字母A，如图6-8-19所示。
A
B
H
K
图6-8-19
7.再调用InOrderTraverse（T->rchil）：访问结点A的右孩子C，再递归访问结
点C的左孩子F，结点F的左孩子I。因为I无左孩子，打印I，之后分别打印
F、C、G、J。步骤省略。
综上，中序遍历这棵二叉树的节点顺序是：HKDBEAIFCG]。
183
---