# 对利用CVE-2017-8750漏洞的恶意RTF文档分析
##### 译文声明
本文是翻译文章
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 写在前面的话
在2018年4月下旬，NCC集团的研究人员发现了少量利用CVE-2017-8750传播的恶意文档。这些文件的目的在受害者的机器上安装远程木马（RAT）。本文对文档及其payload进行了深入分析。
下面的图1显示了恶意文档和恶意软件安装的工作流程。
## CVE-2017-8750 RTF
如前所述，RAT的感染载体是采用CVE-2017-8750的RTF文件的形式（图2）。
SCT文件包含一组模糊的Javascript。有一个非常大的加密数据，后面还跟着一个模糊的解密例程。可以在图4中看到去掉大字符数组的Javascript代码。
## 什么是WLL文件
Javascript代码的目的是解密并将文件`“wordHelpAss.wll”`写入Word
STARTUP目录。WLL文件实际上只是一个普通的DLL文件。这项技术并不新奇，前面已经描述过，但它不是我们通常看到的技术。另一个有趣的地方是，payload不会马上被执行。实际上，当下一个Word打开时，WLL文件才会被执行。这会阻碍自动分析系统，因为Word在分析过程中一般不会重新启动。当最终执行WLL文件时，它将安装RAT有效载荷。
## Sisfader RAT
由于WLL文件安装的payload不是一个普通的RAT。其他行业合作伙伴已将此RAT
Sisfader命名，我们采用这个名称来保持一致性。它维护自身作为系统服务的持久性，并具有多个组件，如下表所述。
## Dropper
该dropper是一个x86PE文件。它负责在受害者的计算机上安装恶意软件。恶意软件组件位于droppers的资源部分，如图所示。
## 执行流程
该dropper以`anti-emulation`开始，采用线程的形式，该线程反复调用`PostMessageA()`，参数为`0x5ACE8D0A`（参见图）。主线程调用`GetMessageA()`
并等待接收响应。如果消息参数不是`0x5ACE8D0A`，那么程序将退出并且恶意软件不会被安装。
下一步是解密Config，它是位于`.data`部分的354字节字符数组。所使用的解密算法是使用16字节滚动键的简单XOR循环。在此之后，恶意软件会检查它具有的权限。如果不是很高，它将尝试执行提升（稍后将在本文中介绍此方法）。安装之前的最后一步是生成用于C2服务器识别主机的唯一ID（UUID）。
在确定了系统的体系结构后，恶意软件会将两个组件写入注册表。它写入的密钥取决于它是否成功地提升了它的权限。如果以管理员身份运行，它将写入`HKCR`。如果不是，它会写入`HKCUSystemCurrentControlSetControl`。
现在是编写加载程序DLL的时候了，它可以使恶意软件保持持久性。AUTO资源被加载，并被复制到分配的内存`GlobalAlloc`中。然后调用一个查找标记`（0xFE19C04F）`的函数。当找到标记时，写入先前生成的主机UUID。
下一步是将自动DLL写入磁盘。这可以在三个位置之一，依赖于检查。
1.`C:WindowsSystem32iscsiexe.dll`  
该文件实际上被覆盖。有效负载中有代码来控制文件，以便系统不会尝试将原始文件写回。  
2.`C:WindowsSystem32appmgmts.dll`  
仅限XP。有效负载将尝试从dllcache中删除原始内容，以便恶意软件不会被它取代。  
3.`％LOCALAPPDATA％ AppUIHelper.dll`
然后，恶意软件被安装为一个服务，使用下列名称之一:
  * AppMgmt
  * MSiSCSI
## 注入和UAC Bypass
如前所述，如果进程尚未以Admin身份运行，那么它将尝试提升其权限。这是它是如何做到的：
1.用`DEBUG_PROCESS`创建标志创建一个新的进程（explorer.exe / select）。  
2.调用`WaitForDebugEvent`代码CREATE_PROCESS_DEBUG_EVENT 查找事件。  
3.将`WriteProcessMemory`一些代码和一段数据注入到资源管理器进程中。此代码执行CMSTPLUA UAC bypass;
用提升的权限重新启动恶意软件payload。在资源管理器进程的入口点注入代码。该地址是从函数`_DEBUG_EVENT`返回的结构中获得的`WaitForDebugEvent`。
4.调用ContinueDebugEvent恢复执行注入的资源管理器进程。  
这项技术虽然很少，但并不新鲜。至少在2013年，它被一个名为Win32 / Napolar上使用过。
## 自动加载程序
恶意软件的主要代码实际上是在DllMain中，而不是ServiceMain函数。服务本身并没有实际做任何事情。
自动DLL的目的是从注册表中提取Agent DLL和Config，反射加载Agent
DLL并调用并导出Agent（在这种情况下为Initialize函数）。Initialize函数将主要的恶意软件函数返回到缓冲区。然后代理调用它，传递配置。
## 代理
代理与服务器执行一次握手，然后监听命令。它通过TCP进行通信。通讯端口位于Config中（在本例中为9000）。所有通信都以DWORD作为前缀：`0xFFDDEEAA`它初始化一个包含其操作数据的结构。这种结构将被传递给网络通信功能。
## 网络通信
它有自己的通信协议。报头长度为0x24字节，其后有任何附加数据。头结构如下：
命令数据使用从配置中的数据计算的0x10字节滚动密钥进行XOR加密。在大多数情况下，要确认C2已收到该命令，它将发回没有数据相同的命令代码。
## 命令代码
> IOCs  
>  File paths  
>  %LOCALAPPDATA%AppUIHelper.dll  
>  C:WindowsSystem32appmgmts.dll (XP only)  
>  C:WindowsSystem32iscsiexe.dll (overwritten)
>
> Registry keys  
>  HKCRb  
>  HKCRc  
>  HKCUSystemCurrentControlSetControlb  
>  HKCUSystemCurrentControlSetControlc
>
> Services  
>  AppMgmt  
>  MSiSCSI
>
> URL  
>  cv3sa.gicp[dot]net  
>  kmbk8.hicp[dot]net
>
> IP Addresses  
>  103.255.45.200:9000
>
> Files Analysed  
>  cdcafe42a688ee042dc023128b7da9e591a01f1a163f9644db774acfe1d6d044  
>  f1d99e124bf644cc20c7ac93701563ed19978bcf32337e3700b2fbc8a9023b82
参考:  
.  
.  
.  
.
审核人：yiwang 编辑：边边