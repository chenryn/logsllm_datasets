= g
1
i∈[N ] miαi
• UpdateCommit(C, S, m[S], m(cid:48)[S]). Outputs
C(cid:48) := C · g(m(cid:48)[S]−m[S])(cid:62)a[S]
1
• Prove(i, m). Outputs
i∈S (m(cid:48)
i−mi)αi
(cid:80)
1
= C · g
(cid:80)
πi := gαN +1−im[−i](cid:62)a[−i]
1
= g
1
j∈[N ]−{i} mj αN +1−i+j
Note that anyone can compute gαN +1−ia[−i]
(m(cid:48)
, a proof can be updated in a way similar to a commitment: π(cid:48) := π · g
changes m(cid:48)
1
If mi changes, then the proof π need not be updated (but the commitment C does).
• Aggregate(C, S, m[S],{πi : i ∈ S}). Outputs
for all i ∈ [N ] given pp. If a value mj at index j (cid:54)= i
j−mj )αN +1−i+j
.
1
j
(cid:89)
i∈S
πti
i
where
ˆπ :=
• Verify(C, S, m[S], ˆπ). Checks that
(cid:80)
(cid:18)
i∈S αN +1−iti
e
C, g
2
ti = H(i, C, S, m[S])
(cid:19)
αN +1(cid:80)
i∈S miti
?= e(ˆπ, g2) · g
T
where ti is the same as in Aggregate.
11
Implementation and E(cid:129)ciency. We now discuss a few implementation details. We summarize the
performance of our scheme (including algorithms from Section 4.2) in Table 2.
rerandomization, so that the (cid:128)nal α = αs ·(cid:81)
• Setup can be performed securely and e(cid:129)ciently via a large-scale distributed computation, similar to
[BGM17], but simpler because of the structure of the parameters [Suh19]. (cid:145)e (cid:128)rst party chooses α1
and generates its own public parameters according to Setup; each subsequent party i, in sequence,
chooses a secret αi and raises each element of the public parameters generated so far to the
appropriate power of αi; at the end, we will use αs generated by a public random beacon for one (cid:128)nal
i αi. Furthermore, each party will prove knowledge
of αi, and each party will use the output of the previous party only if this proof of knowledge is
consistent with (cid:128)rst elements of the ga
vectors, and if the appropriate pairing relationships
between the various group elements hold (to ensure the remaining elements of the parameters are
computed correctly).
and ga
1
2
• Commit takes nz(m) G1-exponentiations and Prove takes one fewer, where nz(m) is the number of
non-zero entries in the vector m. We note that products of exponentiations are considerably more
e(cid:129)cient than separate exponentiations—via, for example, Pippenger’s algorithm [Pip80].
• When producing a proof ˆπ for m[S] where S is known in advance, it is faster to compute the proof
directly using the formula
N(cid:89)
ˆπ =
gckαk
1
gcN +1+kαN +1+k
1
where
k=2
ck =
cN +1+k =
k=1
· N−1(cid:89)
(cid:88)
(cid:88)
mk+i−N−1ti
i∈S,i≥N−k+2
mk+iti
i∈S,i≤N−k
instead of running Prove multiple times followed by Aggregate. (cid:145)e cost of this computation
is a product of min(2N − 2,|S| · nz(m)) G1-exponentiations (to be more precise, the 2N − 2
term can be replaced with N + max(S) − min(S) − 1, because c2, . . . , cN +1−max(S), cN +1, and
c2N−min(S)+2, . . . , c2N are 0).
is more e(cid:129)cient to compute r = ((cid:80)
• For Verify, because operations in G1 are typically faster than in G2, which are faster than in GT , it
i∈S miti)−1 mod p (the special case when the inverse does not
r(cid:80)
exist needs to be handled separately) and check
(cid:19)
(cid:18)
i∈S αN +1−iti
· e(cid:0)ˆπ−r, g2
(cid:1) ?= gαN +1
T
e
C, g
2
Note that a product of two pairings can be computed considerably faster than two separate pairings
(because the time-consuming (cid:128)nal exponentiation needs to be performed only once). Note also that
if |S| = 1 and we set ti = 1 for the sole i ∈ S, as discussed above, then it is more e(cid:129)cient to move
exponentiation to G1 and compute the (cid:128)rst term as (Cr, gαN +1−i
).
2
12
• For |S| = 1, we could set ti = 1 for the single i ∈ S (this le(cid:139)ing ˆπ = πi and eliminating the need
for Aggregate) to save work. All the proofs go through unchanged, because all ti values (except 0,
which occurs with probability 1/p) are functionally equivalent to ti = 1, via raising the veri(cid:128)cation
equation to 1/ti. It may be worthwhile to create a special case for |S| = 1 in an implementation to
save on Aggregate, depending on how frequent this case is.
Operation
Commit
Prove
Aggregate
Same-Aggr. Prove min(2N − 2,|S| · nz(m))-exp1
Verify
AggregateAcross
VerifyAcross
Time
nz(m)-exp1
nz(m)-exp1
|S|-exp1
1-exp1+|S|-exp2 + 2-pp
(cid:96)-exp1
1-exp1 +(cid:80)
j(|Sj|-exp2) + ((cid:96)+1)-pp
Table 2: Concrete e(cid:129)ciency of our scheme, ignoring costs of hashing and Zp operations. Here, nz(m)
denotes the number of non-zero entries in the vector m, k-expi denotes a product of k exponentiations in
Gi, and k-pp denotes a product of k parings.
Proof of correctness. First, we show that for all i ∈ [N ], πi = Prove(i, m) = gαN +1−im[−i](cid:62)a[−i]
satis(cid:128)es:
1
e(C, gαN +1−i
2
) = e(πi, g2) · gαN +1mi
T
(1)
Observe that
Multiplying both sides by αN +1−i yields
m(cid:62)a = m[−i](cid:62)a[−i] + αimi
(m(cid:62)a)αN +1−i = αN +1−im[−i](cid:62)a[−i] + αN +1mi
and thus
e(gm(cid:62)a
1
, gαN +1−i
2
) = e(gαN +1−im[−i](cid:62)a[−i]
1
, g2) · gαN +1mi
T
and (1) holds. To show correctness of aggregated proofs, we (cid:128)rst raise both sides of (1) to the power ti, to
get
e(C, gαN +1−iti
2
) = e(πti
i , g2) · gαN +1miti
T
Multiplying these equations for all i ∈ S yields
(cid:18)
(cid:80)
i∈S αN +1−iti
e
C, g
2
= e
πti
i , g2
(cid:19)
(cid:32)(cid:89)
i∈S
(cid:33)
αN +1(cid:80)
i∈S miti
· g
T
Correctness for updates follows readily from the equality:
m(cid:48)(cid:62)
a = (m(cid:48)[S] − m[S])(cid:62)a[S] + m(cid:62)a
13
4.2 Cross-Commitment Aggregation
We describe the following additional algorithms:
AggregateAcross({ Cj, Sj, mj[Sj], ˆπj }j∈[(cid:96)]). Outputs
π :=
(cid:96)(cid:89)
j=1
t(cid:48)
j
j
ˆπ
where
j = H(cid:48)(j,{Cj, Sj, mj[Sj]}j∈[(cid:96)])
t(cid:48)
VerifyAcross({ Cj, Sj, mj[Sj]}j∈[(cid:96)], π). Checks that
(cid:19)t(cid:48)
(cid:18)
(cid:80)
αN +1−itj,i
(cid:96)(cid:89)
i∈Sj
e
Cj, g
2
j ?= e(π, g2) · g
αN +1(cid:80)
T
j∈[(cid:96)],i∈Sj
mj,itj,it(cid:48)
j
j=1
where
tj,i = H(i, Cj, Sj, mj[Sj]),
j = H(cid:48)(j,{Cj, Sj, mj[Sj]}j∈[(cid:96)]),
t(cid:48)
mj = (mj,1, . . . , mj,N )
Implementation and E(cid:129)ciency. Recall that a summary of computational costs is given in Table 2.
mj,itj,it(cid:48)
• Similarly to Verify, it is faster to implement VerifyAcross by computing r = ((cid:80)
mod p (with a special case for the inverse does not exist) and checking that
j∈[(cid:96)],i∈Sj
j)−1
(cid:18)
(cid:96)(cid:89)
(cid:80)
(cid:19)
e(π−r, g2) ·
rt(cid:48)
Cj, g
2
j
e
αN +1−itj,i
i∈Sj
?= gαN +1
T
j=1
• We note that when (cid:96) = 1, we could set t1 = 1, thus eliminating the need for AggregateAcross
and se(cid:139)ing VerifyAcross = Verify. (cid:145)is modi(cid:128)cation is similar to the case of |S| = 1 for same-
commitment aggregation and works for the same reason.
Proof of correctness. By correctness of ˆπj, each ˆπj satis(cid:128)es its veri(cid:128)cation equation. Raising jth
veri(cid:128)cation equation to t(cid:48)
and multiplying over all j ∈ [(cid:96)] yields the desired equality.
j
4.3 Proof of binding for same-commitment aggregation
Our scheme satis(cid:128)es binding for same-commitment aggregation in the AGM+ROM model under the
(cid:96)-wBDHE∗ assumption (as described in Section 2).
Proof intuition. Suppose the adversary computes C = gz(cid:62)a
(S, m[S]) where m[S] (cid:54)= z[S]. Note that the adversary does not get gαN +1
and provides an accepting proof ˆπ for
, and so the coe(cid:129)cient of αN +1
1
1
14
in logg1 ˆπ should be 0. Comparing coe(cid:129)cients of gαN +1
therefore have
T
on both sides of the veri(cid:128)cation equation, we
z[S](cid:62)t ≡p m[S](cid:62)t ,
where t = (H(i, C, S, m[S]), i ∈ S). Now, suppose t ← Z|S|
(S, z[S], m[S]) are (cid:128)xed, in which case
p
(cid:2)z[S] (cid:54)≡p m[S] and z[S](cid:62)t ≡p m[S](cid:62)t(cid:3) = 1/p .
Pr
t
is chosen uniformly at random a(cid:137)er
To ensure the uniform choice of t for any (cid:128)xed (S, z[S], m[S]), we note that C determines z in AGM and
that C, S, and m[S] are input to the random oracle H(i,·,·,·), which produces ti.
On the necessity of inputting S and m[S] to H. (cid:145)e a(cid:139)acker wins if
(cid:88)
i∈S
(cid:88)
i∈S
ziti ≡p
miti
(2)
√
√
log p algorithm that given {ziti, miti}i∈[N ], computes a set S of size 2
(as long as zi (cid:54)= mi for some i ∈ S). (cid:145)us, if ti can be determined without mi, the a(cid:139)acker could simply (cid:128)x
all values but a single mi and solve for the remaining mi. Moreover, even if we hash the actual messages
(cid:128)rst (and thus mi values are random, rather than under the a(cid:139)acker’s control), Wagner’s a(cid:139)ack [Wag02]
√
yields a 2
log p such that (2) holds.
log p a(cid:139)ack if we set ti = H(i, C) instead of H(i, C, S, m[S]). At 128-bit security level
(cid:145)is yields a 2
√
for the curve (i.e., log p ≈ 256), we have 2
log p ≈ 216, which makes for a very practical a(cid:139)ack! It seems
plausible that the a(cid:139)ack also extends to the se(cid:139)ing of ti = H(i, C, S): it would su(cid:129)ce to extend Wagner’s
algorithm to (cid:128)nding values that sum to a given constant, because the values of the elements of S are not
i∈S ziti is (cid:128)xed, the a(cid:139)acker can choose from a list of random mi for
each i ∈ S.
Analysis. (cid:145)e formal analysis proceeds in two steps.
Step 1: bounding “lucky” queries. Consider any query ((cid:63), C, S, m[S]) that an algebraic adversary (on input
pp) makes to H. Since the adversary is algebraic, it must output z ∈ ZN
commi(cid:139)ed, and thus, although(cid:80)
such that
p , y ∈ ZN−1
p
(cid:80)
i∈[N ] ziαi+(cid:80)
j∈[N−1] yj αN +1+j
C = gz(cid:62)a+αN y(cid:62)a[−1]
1
We say that the query is “H-lucky” if
= g
1
m[S] (cid:54)≡p z[S] and (m[S] − z[S])(cid:62)t) ≡p 0 ,
where t = (H(i, C, S, m[S]) : i ∈ S). Note that a query is H-lucky with probability at most 1/p. Here
we use the fact that the query to H (cid:128)xes (S, m[S], z[S]).
By the union bound, the probability that an adversary makes an H-lucky query is at most qH /p, where
qH is the number of queries to H. Below, we assume this never happens.
Step 2: extracting gαN +1
gαN +1
1
, contradicting (cid:96)-wBDHE∗.