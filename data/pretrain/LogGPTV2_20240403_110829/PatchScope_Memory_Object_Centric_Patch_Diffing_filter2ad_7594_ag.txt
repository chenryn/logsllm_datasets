[17] Franck de Goër, Sanjay Rawat, Dennis Andriesse, Herbert Bos, and Roland Groz.
2018. Now You See Me: Real-time Dynamic Function Call Detection. In Proceed-
ings of the 34th Annual Computer Security Applications Conference (ACSAC’18).
[18] Steven H. H. Ding, Benjamin C. M. Fung, and Philippe Charland. 2019. Asm2Vec:
Boosting Static Representation Robustness for Binary Clone Search against Code
Obfuscation and Compiler Optimization. In Proceedings of the 40th IEEE Sympo-
sium on Security and Privacy (S&P’19).
[19] Yue Duan, Xuezixiang Li, Jinghan Wang, and Heng Yin. 2020. DEEPBINDIFF:
Learning Program-Wide Code Representations for Binary Diffing. In Proceedings
of the 27th Annual Network and Distributed System Security Symposium (NDSS’20).
[20] Manuel Egele, Maverick Woo, Peter Chapman, and David Brumley. 2014. Blanket
Execution: Dynamic Similarity Testing for Program Binaries and Components.
In Proceedings of the 23rd USENIX Security Symposium (USENIX Security’14).
[21] Sebastian Eschweiler, Khaled Yakdan, and Elmar Gerhards-Padilla. 2016. discovRE:
Efficient Cross-Architecture Identification of Bugs in Binary Code. In Proceedings
of the 23nd Annual Network and Distributed System Security Symposium (NDSS’16).
[22] Qian Feng, Rundong Zhou, Chengcheng Xu, Yao Cheng, Brian Testa, and Heng
Yin. 2016. Scalable Graph-based Bug Search for Firmware Images. In Proceedings
of the 2016 ACM SIGSAC Conference on Computer and Communications Security
(CCS’16).
[23] Matt Fredrikson, Somesh Jha, Mihai Christodorescu, Reiner Sailer, and Xifeng
Yan. 2010. Synthesizing Near-Optimal Malware Specifications from Suspicious
html.
Behaviors. In Proceedings of the 31st IEEE Symposium on Security and Privacy
(S&P’10).
[24] Ulf Frisk. 2018. Total Meltdown? http://blog.frizk.net/2018/03/total-meltdown.
[25] Debin Gao, Michael K. Reiter, and Dawn Song. 2008. BinHunt: Automatically
Finding Semantic Differences in Binary Programs. In Poceedings of the 10th
International Conference on Information and Communications Security (ICICS’08).
[26] Jian Gao, Xin Yang, Ying Fu, Yu Jiang, Heyuan Shi, and Jiaguang Sun. 2018.
VulSeeker-pro: Enhanced Semantic Learning Based Binary Vulnerability Seeker
with Emulation. In Proceedings of the 26th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of Software Engineering
(ESEC/FSE’18).
[27] Google LLC. 2011. BinDiff: Graph Comparison for Binary Files. https://www.
zynamics.com/bindiff.html.
[28] Andrew Henderson, Aravind Prakash, Lok Kwong Yan, Xunchao Hu, Xujiewen
Wang, Rundong Zhou, and Heng Yin. 2014. Make It Work, Make It Right, Make
It Fast: Building a Platform-Neutral Whole-System Dynamic Binary Analysis
Platform. In Proceedings of the 2014 International Symposium on Software Testing
and Analysis (ISSTA’14).
[29] Xin Hu, Tzi-cker Chiueh, and Kang G. Shin. 2009. Large-scale Malware Index-
ing Using Function-call Graphs. In Proceedings of the 16th ACM Conference on
Computer and Communications Security (CCS’09).
[30] Noah M. Johnson, Juan Caballero, Kevin Zhijie Chen, Stephen McCamant,
Pongsin Poosankam, Daniel Reynaud, and Dawn Song. 2011. Differential Slicing:
Identifying Causal Execution Differences for Security Applications. In Proceedings
of the 2011 IEEE Symposium on Security and Privacy (S&P’11).
[31] Mateusz Jurczyk. 2017. Using Binary Diffing to Discover Windows Kernel Mem-
ory Disclosure Bugs. Google Project Zero Team Blog.
[32] Min Gyung Kang, Stephen McCamant, Pongsin Poosankam, and Dawn Song. 2011.
DTA++: Dynamic Taint Analysis with Targeted Control-Flow Propagation. In
Proceedings of the 18th Annual Network and Distributed System Security Symposium
(NDSS’11).
[33] Clemens Kolbitsch, Paolo Milani Comparetti, Christopher Kruegel, Engin Kirda,
Xiaoyong Zhou, and XiaoFeng Wang. 2009. Effective and Efficient Malware
Detection at the End Host. In Proceedings of the 18th Conference on USENIX
Security Symposium (USENIX Security’09).
[34] Joxean Koret. 2015. Diaphora: A Free and Open Source Program Diffing Tool.
http://diaphora.re/.
[35] Shuvendu K Lahiri, Chris Hawblitzel, Ming Kawaguchi, and Henrique Rebêlo.
2012. Symdiff: A language-agnostic semantic diff tool for imperative programs.
In International Conference on Computer Aided Verification. Springer, 712–717.
[36] Frank Li and Vern Paxson. 2017. A Large-Scale Empirical Study of Security
Patches. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security (CCS’17).
[37] Zhen Li, Deqing Zou, Shouhuai Xu, Xinyu Ou, Hai Jin, Sujuan Wang, Zhijun
Deng, and Yuyi Zhong. 2018. VulDeePecker: A Deep Learning-Based System for
Vulnerability Detection. In Proceedings of the 25th Annual Network and Distributed
System Security Symposium (NDSS’18).
[38] Bingchang Liu, Wei Huo, Chao Zhang, Wenchao Li, Feng Li, Aihua Piao, and Wei
Zou. 2018. αDiff: Cross-version Binary Code Similarity Detection with DNN. In
Proceedings of the 33rd ACM/IEEE International Conference on Automated Software
Engineering (ASE’18).
[39] Fan Long, Stelios Sidiroglou-Douskos, Deokhwan Kim, and Martin Rinard. 2014.
Sound Input Filter Generation for Integer Overflow Errors. In Proceedings of the
41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
(POPL’14).
[40] Lannan Luo, Jiang Ming, Dinghao Wu, Peng Liu, and Sencun Zhu. 2014.
Semantics-based Obfuscation-resilient Binary Code Similarity Comparison with
Applications to Software Plagiarism Detection. In Proceedings of the 22nd
ACM SIGSOFT International Symposium on Foundations of Software Engineer-
ing (FSE’14).
[41] Aravind Machiry, Nilo Redini, Eric Camellini, Christopher Kruegel, and Gio-
vanni Vigna. 2020. Spider: Enabling fast patch propagation in related software
repositories. In 2020 IEEE Symposium on Security and Privacy (SP). IEEE.
[42] Niccolò Marastoni, Roberto Giacobazzi, and Mila Dalla Preda. 2018. A Deep
Learning Approach to Program Similarity. In Proceedings of the 1st International
Workshop on Machine Learning and Software Engineering in Symbiosis (MASES’18).
[43] Luca Massarelli, Giuseppe Antonio Di Luna, Fabio Petroni, Roberto Baldoni, and
Leonardo Querzoni. 2019. SAFE: Self-Attentive Function Embeddings for Binary
Similarity. In Proceedings of the 16th Conference on Detection of Intrusions and
Malware & Vulnerability Assessment (DIMVA’19).
[44] Jiang Ming, Dongpeng Xu, Yufei Jiang, and Dinghao Wu. 2017. BinSim: Trace-
based Semantic Binary Diffing via System Call Sliced Segment Equivalence
Checking. In Proceedings of the 26th USENIX Conference on Security Symposium
(USENIX Security’17).
[45] Manish Motwani, Sandhya Sankaranarayanan, René Just, and Yuriy Brun. 2018.
Do automated program repair techniques repair hard and important bugs? Em-
pirical Software Engineering 23, 5 (2018), 2901–2947.
[46] Dongliang Mu, Alejandro Cuevas, Limin Yang, Hang Hu, Xinyu Xing, Bing Mao,
and Gang Wang. 2018. Understanding the Reproducibility of Crowd-reported
Security Vulnerabilities. In Proceedings of the 27th USENIX Conference on Security
Symposium (USENIX Security’18).
[47] Jeong Wook Oh. 2009. Fight against 1-day exploits: Diffing Binaries vs Anti-diffing
Binaries. Black Hat USA.
[48] Jeong Wook Oh. 2010. Exploit Spotting: Locating Vulnerabilities Out of Vendor
Patches Automatically. Black Hat USA.
[49] Jeong Wook Oh. 2011. DarunGrim: A Patch Analysis and Binary Diffing Tool.
http://www.darungrim.org/.
[50] Jiaqi Peng, Feng Li, Bingchang Liu, Lili Xu, Binghong Liu, Kai Chen, and Wei
Huo. 2019. 1dVul: Discovering 1-day Vulnerabilities through Binary Patches. In
Proceedings of the 49th IEEE/IFIP International Conference on Dependable Systems
and Networks (DSN’19).
[51] Suzette Person, Matthew B Dwyer, Sebastian Elbaum, and Corina S Pˇasˇareanu.
2008. Differential symbolic execution. In Proceedings of the 16th ACM SIGSOFT
International Symposium on Foundations of software engineering. 226–237.
[52] Suzette Person, Guowei Yang, Neha Rungta, and Sarfraz Khurshid. 2011. Di-
rected incremental symbolic execution. In Proceedings of the 32nd ACM SIGPLAN
Conference on Programming Language Design and Implementation. 504–515.
[53] Dawei Qi, Abhik Roychoudhury, Zhenkai Liang, and Kapil Vaswani. 2009. DAR-
WIN: An Approach for Debugging Evolving Programs. In Proceedings of the the
7th Joint Meeting of the European Software Engineering Conference and the ACM
SIGSOFT Symposium on The Foundations of Software Engineering. ACM.
[54] Ashwin Ramaswamy, Sergey Bratus, Sean W. Smith, and Michael E. Locasto. 2010.
Katana: A Hot Patching Framework for ELF Executables. In Proceedings of the
2010 International Conference on Availability, Reliability and Security.
[55] Stephen Sims. 2016. Bruh! Do you even diff?—Diffing Microsoft Patches to Find
Vulnerabilities. RSA Conference.
[56] Asia Slowinska and Herbert Bos. 2009. Pointless tainting? Evaluating the practi-
cality of pointer tainting. In EuroSys. 61–74.
[57] Asia Slowinska, Traian Stancescu, and Herbert Bos. 2011. Howard: A Dynamic
Excavator for Reverse Engineering Data Structures. In Proceedings of the 18th
Annual Network and Distributed System Security Symposium (NDSS’11).
[58] Temple F. Smith and M.S. Waterman. 1981. Identification of Common Molecular
Subsequences. Journal of Molecular Biology 147, 1 (1981).
[59] Alexander Sotirov. 2006. Hotpatching and the Rise of Third-Party Patches. Black-
Hat USA.
[60] Zhenzhou Tian, Qinghua Zheng, Ting Liu, Ming Fan, Eryue Zhuang, and Zijiang
Yang. 2015. Software Plagiarism Detection with Birthmarks Based on Dynamic
Key Instruction Sequences. IEEE Transactions on Software Engineering 41, 12
(2015).
[61] Windows Unicorn vulnerability exploited in the wild. [online]. Windows Unicorn
vulnerability exploited in the wild. https://securityaffairs.co/wordpress/30402/
security/unicorn-exploited-in-the-wild.html.
[62] Harsimran Walia. 2011. Reversing Microsoft patches to reveal vulnerable code.
Nullcon.
[63] Shuai Wang and Dinghao Wu. 2017. In-memory Fuzzing for Binary Code Simi-
larity Analysis. In Proceedings of the 32nd IEEE/ACM International Conference on
Automated Software Engineering (ASE’17).
[64] Xinran Wang, Yoon-Chan Jhi, Sencun Zhu, and Peng Liu. 2009. Behavior Based
Software Theft Detection. In Proceedings of the 16th ACM Conference on Computer
and Communications Security (CCS’09).
[65] Xinda Wang, Kun Sun, Archer Batcheller, and Sushil Jajodia. 2019. Detecting"
0-Day" Vulnerability: An Empirical Study of Secret Security Patch in OSS. In
2019 49th Annual IEEE/IFIP International Conference on Dependable Systems and
Networks (DSN). IEEE, 485–492.
[66] Ye Wang, Na Meng, and Hao Zhong. 2018. An Empirical Study of Multi-Entity
Changes in Real Bug Fixes. In Proceedings of the 34th IEEE International Conference
on Software Maintenance and Evolution (ICSME’18).
[67] Dasarath Weeratunge, Xiangyu Zhang, William N Sumner, and Suresh Jagan-
nathan. 2010. Analyzing concurrency bugs using dual slicing. In Proceedings of
the 19th international symposium on Software testing and analysis. ACM, 253–264.
[68] Qiushi Wu, Yang He, Stephen McCamant, and Kangjie Lu. 2020. Precisely Char-
acterizing Security Impact in a Flood of Patches via Symbolic Rule Comparison.
In Proceedings of the 27th Annual Network and Distributed System Security Sym-
posium (NDSS’20).
[69] Yang Xiao, Bihuan Chen, Chendong Yu, Zhengzi Xu, Zimu Yuan, Feng Li,
Binghong Liu, Yang Liu, Wei Huo, Wei Zou, and Wenchang Shi. 2020. MVP:
Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures. In 29th
USENIX Security Symposium (USENIX Security 20). USENIX Association.
[70] Dongpeng Xu, Jiang Ming, and Dinghao Wu. 2017. Cryptographic Function
Detection in Obfuscated Binaries via Bit-precise Symbolic Loop Mapping. In
Proceedings of the 38th IEEE Symposium on Security and Privacy (S&P’17).
[71] Xiaojun Xu, Chang Liu, Qian Feng, Heng Yin, Le Song, and Dawn Song. 2017.
Neural Network-based Graph Embedding for Cross-Platform Binary Code Simi-
larity Detection. In Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security (CCS’17).
[72] Zhengzi Xu, Bihuan Chen, Mahinthan Chandramohan, Yang Liu, and Fu Song.
2017. SPAIN: Security Patch Analysis for Binaries Towards Understanding the
Pain and Pills. In Proceedings of the 39th International Conference on Software
Engineering (ICSE’17).
[73] Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang, Xiaojing Liao, Pan Bian, and
Bin Liang. 2017. SemFuzz: Semantics-based Automatic Generation of Proof-of-
Concept Exploit. In Proceedings of the 23rd ACM Conference on Computer and
Communications Security (CCS’17).
[74] Hang Zhang and Zhiyun Qian. 2018. Precise and accurate patch presence test for
binaries. In 27th {USENIX} Security Symposium ({USENIX} Security 18). 887–902.
[75] Shitong Zhu, Xunchao Hu, Zhiyun Qian, Zubair Shafiq, and Heng Yin. 2018.
Measuring and Disrupting Anti-Adblockers Using Differential Execution Anal-
ysis. In Proceedings of the 25th Annual Network and Distributed System Security
Symposium (NDSS’18).
[76] Fei Zuo, Xiaopeng Li, Zhexin Zhang, Patrick Young, Lannan Luo, and Qiang Zeng.
2019. Neural Machine Translation Inspired Binary Code Similarity Comparison
beyond Function Pairs. In Proceedings of the 26th Network and Distributed System
Security Symposium (NDSS’19).
APPENDIX
A OUTPUT RESULTS FROM BINDIFF
For the example in Figure 1, we leverage BinDiff to compare the
dynamic execution traces of the two ghttpd versions on a given
PoC. It reports up to 30 differences in terms of the instructions
removed or added. We list a snippet of the instruction alignment
sequence in Figure 5.
Our further analysis on the reported 32 different memory ac-
cesses shows that these differences include memory accesses via
function pointers, instruction addresses, parameters, and so on. This
result indicates that the patch in Figure 1 results in types of differ-
ent elements regarding memory accesses. By contrast, PatchScope
outperforms BLEX [20] as the memory object access is constructed
on top of reverse-engineered memory objects and it only captures
memory objects used for manipulating program inputs.
Through this example, we highlight code representations defined
in binary diffing techniques are specific for problem scopes. As
demonstrated in the literature [20], BLEX explicitly considers the
case where different compilers and optimization settings produce
different binary programs from identical source code. For patch
analysis, however, BLEX may not be suitable because it reports a
number of differences.
Figure 5: A partial sequence of Figure 1’s instruction align-
ment returned by BinDiff.
With the output like Figure 5, it is far from meeting the goal of
patch analysis. First, we can observe that BinDiff did an inaccurate
trace alignment. The instruction at Line 19 in the left should be
aligned to Line 4 in the right. Second, an expert may infer that it is
an out-of-boundary vulnerability, because the patch redefines two
dynamically allocated heap spaces with flexible length. Even so,
low-level differences cannot avail security experts much regarding
how to trigger this vulnerability.
B OUTPUT RESULTS FROM BLEX
For the example in Figure 1, BLEX [20] can successfully identify the
two different functions because the similarity score is pretty low.
However, if we employ BLEX [20] to identify differences for patch
biffing, BLEX [20] reports 32 different memory accesses, which are
shown in Figure 6.
Please note these differences only include memory accesses gen-
erated by the instructions belonging to the vulnerable function Log
in Figure 1. That is, we exclude different memory accesses during
the execution of library function calls. Otherwise, BLEX [20] would
report thousands of different memory accesses, because this patch
changes two local variables in the stack to dynamically allocated
variables in the heap. As a consequence, all memory accesses dur-
ing the library function calls (such as vsprintf and strlen) would be
identified as differences, because of the memory cell types (stack
vs. heap).
Figure 6: A partial sequence of differences returned by
BLEX. Each item includes the instruction, its operands,
and the corresponding memory access during the in-
struction execution. Take the item in the first
line,
W@0xbfffb360[0x0804b34c], for illustration. W refers to
writing to memory. 0xbfffb360 refers to the memory address,
and 0x0804b34c is the value written to the memory cell at
0xbfffb360.
C TAIL CALL OPTIMIZATION EXAMPLE
Tail call optimization uses the stack memory more efficiently but
hides inter-procedural call relationship. We simplify the example
in Figure 7 with pseudo-assembly languages.
  ghttpd-1.4.3 ghttpd-1.4.4 1 xor %eax,%eax xor %eax,%eax 2 lea 0x374(%esp),%eax  3 mov %eax,0x10(%esp) mov %bx,0x3b(%esp) 4 mov 0x370(%esp),%eax mov $0x2e64,0x27(%esp) 5 lea 0xbd(%esp),%esi  6 mov %bx,0x3b(%esp) mov %edi,(%esp) 7  mov $0x252e,0x2b(%esp) 8  mov $0x5b20,0x2f(%esp) 9  mov $0x253a,0x33(%esp) 10  mov $0x5e25,0x37(%esp) 11  call strlen 12 lea 0x20(%esp),%ebx lea 0x400(%eax),%ebx 13 mov $0xc8,0x8(%esp) mov %ebx,(%esp) 14  call malloc 15 mov $0x1,0x4(%esp) mov %ebp,0x14(%esp) 16  lea 0x3d(%esp),%ebp 17 mov %eax,0xc(%esp) mov %edi,0x10(%esp) 18 mov %esi,(%esp) mov %ebp,%edi 19 mov $0x2e64,0x27(%esp) mov %ebx,0x4(%esp)      804abbb mov %ebx,(%esp)  W@0xbfffb360[0x0804b34c] 804abd9 call strlen   W@0xbfffb35c[0x0804abde] 804abe3 mov %eax,(%esp)  W@0xbfffb360[0x00000426] 804abe6 call malloc   W @0xbfffb35c[0x0804abeb] 804abeb mov %ebx,(%esp)  W@0xbfffb360[0x0804b34c] 804abee mov %eax,-0x1b0(%ebp) W@0xbfffb388[0x08051da8] 804abf4 call strlen    W@0xbfffb35c[0x0804abf9] 804abf9 mov -0x1b0(%ebp),%edi R@0xbfffb388[0x08051da8] 804ac15 mov %edi,(%esp)  W@0xbfffb360[0x08051da8] 804ac25 mov %eax,0x4(%esp) W@0xbfffb364[0x00000426] 804ac29 call vsnprintf   W@0xbfffb35c[0x0804ac2e] 804ac75 call strftime   W@0xbfffb35c[0x0804ac7a] 804ac7a mov -0x1b0(%ebp),%edi R@0xbfffb388[0x08051da8]  804ac80 mov %edi,(%esp)  W@0xbfffb360[0x08051da8] 804ac83 call strlen   W@0xbfffb35c[0x0804ac88] 804ac90 mov %eax,(%esp)  W@0xbfffb360[0xbfffb492] 804ac93 call strlen   W@0xbfffb35c[0x0804ac98] 804ac9c mov %eax,(%esp)  W@0xbfffb360[0x0000011c] 804aca5 call malloc   W@0xbfffb35c[0x0804acaa] 804acaa mov %edi,0x14(%esp) W@0xbfffb374[0x08051da8] 804acd2 mov %eax,(%esp)  W@0xbfffb360[0x08052230] 804acd5 call sprintf   W@0xbfffb35c[0x0804acda] 804ad24 mov -0x1b0(%ebp),%eax R@0xbfffb388[0x08051da8] 804ad2a mov %eax,(%esp)  W@0xbfffb360[0x08051da8] 804ad2d call free    W@0xbfffb35c[0x0804ad32] 804ad32 mov %esi,(%esp)  W@0xbfffb360[0x08052230] 804ad35 call free    W@0xbfffb35c[0x0804ad3a] 804ad54 pop %ebx   R@0xbfffb52c[0xbfffb577] 804ad55 pop %esi    R@0xbfffb530[0x00001000] 804ad56 pop %edi    R@0xbfffb534[0x00000003] 804ad57 pop %ebp   R@0xbfffb538[0xbffff6c8] 804ad58 ret     R@0xbfffb53c[0x0804a0f7]  we identified a memory object access that was caused by a buffer
overflow.
An interesting observation from this case is that the operations
and corresponding variables in the code changes of patches may
not be the vulnerable variables. For this example, it first receives
an integer, and then uses this integer to allocate a second memory
object and calculates the length for further received inputs. The
mistake calculation leads to a fault parameter for invoking recv.
This observation also suggests that previous techniques [68, 74]
that extract patch signatures, vulnerable operations, and vulnerable
variables from patches should consider more patch patterns.
2fax-3.04. The patch for this application overwrites a function,
which is the most complicated one. As shown in Table 1, the LOC
is 27, and the industry binary diffing tools report a large number of
differences. By examining these results, we observe that these in-
dustry binary diffing tools identified a pair of unmatched functions
and a large number of unmatched items in the pair of functions.
Security experts could be plagued by such a large number of
low-level code differences. By contrast, PatchScope only identified
4 differences. Examining the different details in MOA, we found
that the new function in the patch only adds a security check. With
the impact of the security check, the patched program blocks the
PoC. This case further demonstrates that the core of PatchScope,
memory object access sequences, is particularly fit for patch analysis
by identifying differences in input manipulations.
Besides, we can also observe that DeepBinDiff [19] performs
well in this case, as it identifies only three different basic blocks.
To confirm this result, we discussed this case with the author of
DeepBinDiff. The reason is DeepBinDiff adopts a program-wide
code representation learning, whereas traditional binary diffing
works on function similarity.
libsndfile. This vulnerability is difficult to understand due to com-
plicated program logical faults. The patch for fixing this vulnera-
bility changes multiple statements in different locations. Although
complicated, PatchScope still provides valuable clues to reason
about the vulnerability. First, PatchScope successfully narrows
down the patch differences to only three different memory object
access items, which are marked with colors in Figure 8.
We can observe one extra sub manipulation on memory object
R1 and R3 in the patched program, and this manipulation calculates
the value of R3. Then, R3 is passed to memcpy as a parameter. By con-
trast, the vulnerable program takes L2 as the parameter of memcpy.
We can learn that this patch fixes a vulnerability by changing the
parameter value of memcpy. As both L2 and R3’s types are registers,
we infer that both L2 and R3 are memcpy’s size parameter—number
of bytes to copy. This finding motivates us to backtrack L2 and R3’s
data flow in MOAS. We show their dependencies at the bottom of
Figure 8.
The missing line of L2’s data flow dependencies reveals the root
cause of the vulnerability: L2 can be manipulated by syscall read
before it is passed to memcpy. The patch adds one line to initialize
R3 again before memcpy accepts it. Note that L2 has two correlated
input fields, and one of them ([0x176, 0x303]) does not exist in R3.
This clue implies that overflowing this particular input field can
trigger the vulnerability, and we confirm this in our PoC exploit.
Figure 7: Tail call optimization example.
D SMITH-WATERMAN ALGORITHM
The input to Smith-Waterman algorithm is two sequences A =
a1, a2, ...an and B = b1, b2, ...bm of length n and m respectively. A
maximum similarity matrix H is filled using the equation below.
H(i ,0) = 0, 0 ≤ i ≤ m,
H(0,j) = 0, 0 ≤ j ≤ n,
and
0
H(i−1,j−1) + Sim(ai , bj)
Maxk ≥1H(i ,j−k) + Wk
Maxl ≥1H(i−l ,j) + Wl
H(i ,j) = Max
(1)
1 ≤ i ≤ m, 1 ≤ j ≤ n
Here A and B are two memory object access sequences. Sim(ai , bj)
is the similarity score of two memory object access items. We treat
a memory object access’s definition as a vector and measure two
vectors’s similarity using Jaccard index: |A ∩ B|/|A ∪ B|. Both Wk
and Wl are the gap penalty scheme. In our comparison, the simple
gap penalty scheme that uses a fixed score for each gap already
delivers good precision. We tune the value of Wk and Wl as -2.
E CASE STUDIES
Nginx-1.4.0. The vulnerability CVE-2013-2028 is a classic integer-
to-buffer-overflow. A signed and negative integer is mistakenly
used as a parameter for calling recv. By comparing MOAS between
two executions, we find that the MOAS from the patched program
is much shorter than that from the unpatched one. With this obser-
vation, an intuitive inference is that the patched program blocks
the bad inputs. Further, we identified an MOA item that only exists
in the patched program, of which the operation code is cmp. This
item confirms our inference that the patch fixes the vulnerabil-
ity via a security check. This patch seems very simple. However,
the long MOAS from the unpatched program indicates that the
patch point is far away from the crash point, which motivated us to
look for a deeper understanding of the fixed vulnerability. Finally,
 function Foo (Argument1, Argument2) {     A (Argument1);     return B (Argument2); }no optimizationFoo:  mov  reg, [esp+offset1];  push reg;  call A              pop                  mov  reg, [esp+offset2];   push reg;              call B              pop                ret1  2  3  4             5 6   7              8             9               10 Foo:  mov  reg, [esp+offset1];  push reg;  call A              pop                  mov  reg, [esp+offset2];   mov  [esp+offset1], reg;              jmp B               1  2  3  4             5 6   7              8                             tail callFigure 8: PatchScope’s comparison result for libsndfile.
L1    R1  0xb7fa70fb:sub R [0x36,0x36]   0xb7fa7107:sub R [0x36,0x36]     L2    R2  0xb7fa70fb:sub W [0x36,0x36]   0xb7fa7107:sub W [0x36,0x36]     L2    R2  0xb7fa8bd8: add R [0x36,0x36]   0xb7fa8bd8: add R [0x36,0x36]     L2    R2  0xb7fa8bd8: add W [0x36,0x36]; [0x176,0x303]   0xb7fa8bd8: add W [0x36,0x36]; [0x176,0x303]                R1       0xb7fa7133:sub R [0x36,0x36]               R3       0xb7fa7133:sub W [0x36,0x36]     L2    R3  0xb7fa7148:call memcpy R [0x36,0x36]; [0x176,0x303]   0xb7fa714a:call memcpy R [0x36,0x36]  (a) Memory object access sequence for libsndfile-1.0.25.   Data flow dependencies: L2 = 0x3004 –L1; L2 = L2 + read();  memcpy(dst, src, L2);    (b) Memory object access sequence for the patched libsndfile.  Data flow dependencies: R2 = 0x3004 –R1; R2 = R2 + read(); R3 = 0x3004 –R1; memcpy(dst, src, R3);