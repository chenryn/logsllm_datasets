以下是经过优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

[17] Franck de Goër, Sanjay Rawat, Dennis Andriesse, Herbert Bos, and Roland Groz. 2018. 实时动态函数调用检测。第34届年度计算机安全应用会议（ACSAC’18）论文集。

[18] Steven H. H. Ding, Benjamin C. M. Fung, and Philippe Charland. 2019. Asm2Vec：增强静态表示鲁棒性以对抗代码混淆和编译器优化。第40届IEEE安全与隐私研讨会（S&P’19）论文集。

[19] Yue Duan, Xuezixiang Li, Jinghan Wang, and Heng Yin. 2020. DEEPBINDIFF：学习程序范围的代码表示以进行二进制差异分析。第27届年度网络和分布式系统安全研讨会（NDSS’20）论文集。

[20] Manuel Egele, Maverick Woo, Peter Chapman, and David Brumley. 2014. 全面执行：针对程序二进制文件和组件的动态相似性测试。第23届USENIX安全研讨会（USENIX Security’14）论文集。

[21] Sebastian Eschweiler, Khaled Yakdan, and Elmar Gerhards-Padilla. 2016. discovRE：高效的跨架构二进制代码漏洞识别。第23届年度网络和分布式系统安全研讨会（NDSS’16）论文集。

[22] Qian Feng, Rundong Zhou, Chengcheng Xu, Yao Cheng, Brian Testa, and Heng Yin. 2016. 可扩展的基于图的固件镜像漏洞搜索。2016年ACM SIGSAC计算机与通信安全会议（CCS’16）论文集。

[23] Matt Fredrikson, Somesh Jha, Mihai Christodorescu, Reiner Sailer, and Xifeng Yan. 2010. 从可疑行为合成接近最优的恶意软件规范。第31届IEEE安全与隐私研讨会（S&P’10）论文集。

[24] Ulf Frisk. 2018. 总崩溃？http://blog.frizk.net/2018/03/total-meltdown.

[25] Debin Gao, Michael K. Reiter, and Dawn Song. 2008. BinHunt：自动查找二进制程序中的语义差异。第10届国际信息与通信安全会议（ICICS’08）论文集。

[26] Jian Gao, Xin Yang, Ying Fu, Yu Jiang, Heyuan Shi, and Jiaguang Sun. 2018. VulSeeker-pro：基于增强语义学习的二进制漏洞搜索器。第26届欧洲软件工程联合会议和软件工程基础研讨会（ESEC/FSE’18）论文集。

[27] Google LLC. 2011. BinDiff：二进制文件的图形比较。https://www.zynamics.com/bindiff.html.

[28] Andrew Henderson, Aravind Prakash, Lok Kwong Yan, Xunchao Hu, Xujiewen Wang, Rundong Zhou, and Heng Yin. 2014. 让它工作，让它正确，让它快速：构建平台中立的全系统动态二进制分析平台。2014年国际软件测试与分析研讨会（ISSTA’14）论文集。

[29] Xin Hu, Tzi-cker Chiueh, and Kang G. Shin. 2009. 使用函数调用图进行大规模恶意软件索引。第16届ACM计算机与通信安全会议（CCS’09）论文集。

[30] Noah M. Johnson, Juan Caballero, Kevin Zhijie Chen, Stephen McCamant, Pongsin Poosankam, Daniel Reynaud, and Dawn Song. 2011. 差异切片：识别安全应用中的因果执行差异。2011年IEEE安全与隐私研讨会（S&P’11）论文集。

[31] Mateusz Jurczyk. 2017. 使用二进制差异发现Windows内核内存泄露漏洞。Google Project Zero团队博客。

[32] Min Gyung Kang, Stephen McCamant, Pongsin Poosankam, and Dawn Song. 2011. DTA++：具有目标控制流传播的动态污点分析。第18届年度网络和分布式系统安全研讨会（NDSS’11）论文集。

[33] Clemens Kolbitsch, Paolo Milani Comparetti, Christopher Kruegel, Engin Kirda, Xiaoyong Zhou, and XiaoFeng Wang. 2009. 终端主机上的有效且高效的恶意软件检测。第18届USENIX安全研讨会（USENIX Security’09）论文集。

[34] Joxean Koret. 2015. Diaphora：免费且开源的程序差异工具。http://diaphora.re/.

[35] Shuvendu K Lahiri, Chris Hawblitzel, Ming Kawaguchi, and Henrique Rebêlo. 2012. Symdiff：一种语言无关的命令式程序语义差异工具。国际计算机辅助验证会议。Springer, 712–717.

[36] Frank Li and Vern Paxson. 2017. 安全补丁的大规模实证研究。2017年ACM SIGSAC计算机与通信安全会议（CCS’17）论文集。

[37] Zhen Li, Deqing Zou, Shouhuai Xu, Xinyu Ou, Hai Jin, Sujuan Wang, Zhijun Deng, and Yuyi Zhong. 2018. VulDeePecker：基于深度学习的漏洞检测系统。第25届年度网络和分布式系统安全研讨会（NDSS’18）论文集。

[38] Bingchang Liu, Wei Huo, Chao Zhang, Wenchao Li, Feng Li, Aihua Piao, and Wei Zou. 2018. αDiff：基于DNN的跨版本二进制代码相似性检测。第33届ACM/IEEE自动化软件工程国际会议（ASE’18）论文集。

[39] Fan Long, Stelios Sidiroglou-Douskos, Deokhwan Kim, and Martin Rinard. 2014. 整数溢出错误的声音输入过滤生成。第41届ACM SIGPLAN-SIGACT编程语言原理研讨会（POPL’14）论文集。

[40] Lannan Luo, Jiang Ming, Dinghao Wu, Peng Liu, and Sencun Zhu. 2014. 基于语义的抗混淆二进制代码相似性比较及其在软件剽窃检测中的应用。第22届ACM SIGSOFT国际软件工程基础研讨会（FSE’14）论文集。

[41] Aravind Machiry, Nilo Redini, Eric Camellini, Christopher Kruegel, and Giovanni Vigna. 2020. Spider：在相关软件仓库中实现快速补丁传播。2020 IEEE安全与隐私研讨会（SP）。IEEE。

[42] Niccolò Marastoni, Roberto Giacobazzi, and Mila Dalla Preda. 2018. 深度学习方法用于程序相似性。第一届机器学习与软件工程共生国际研讨会（MASES’18）论文集。

[43] Luca Massarelli, Giuseppe Antonio Di Luna, Fabio Petroni, Roberto Baldoni, and Leonardo Querzoni. 2019. SAFE：自注意力函数嵌入用于二进制相似性。第16届入侵检测与恶意软件及漏洞评估会议（DIMVA’19）论文集。

[44] Jiang Ming, Dongpeng Xu, Yufei Jiang, and Dinghao Wu. 2017. BinSim：基于跟踪的语义二进制差异通过系统调用切片段等效检查。第26届USENIX安全研讨会（USENIX Security’17）论文集。

[45] Manish Motwani, Sandhya Sankaranarayanan, René Just, and Yuriy Brun. 2018. 自动化程序修复技术是否修复了重要且难以修复的漏洞？经验软件工程 23, 5 (2018), 2901–2947.

[46] Dongliang Mu, Alejandro Cuevas, Limin Yang, Hang Hu, Xinyu Xing, Bing Mao, and Gang Wang. 2018. 理解众包报告的安全漏洞的可重现性。第27届USENIX安全研讨会（USENIX Security’18）论文集。

[47] Jeong Wook Oh. 2009. 抵抗一日漏洞：二进制文件对比 vs 反二进制文件对比。Black Hat USA。

[48] Jeong Wook Oh. 2010. 漏洞定位：自动从供应商补丁中定位漏洞。Black Hat USA。

[49] Jeong Wook Oh. 2011. DarunGrim：一个补丁分析和二进制文件对比工具。http://www.darungrim.org/.

[50] Jiaqi Peng, Feng Li, Bingchang Liu, Lili Xu, Binghong Liu, Kai Chen, and Wei Huo. 2019. 1dVul：通过二进制补丁发现一日漏洞。第49届IEEE/IFIP国际依赖系统和网络会议（DSN’19）论文集。

[51] Suzette Person, Matthew B Dwyer, Sebastian Elbaum, and Corina S Pˇasˇareanu. 2008. 差异符号执行。第16届ACM SIGSOFT国际软件工程基础研讨会论文集。226–237.

[52] Suzette Person, Guowei Yang, Neha Rungta, and Sarfraz Khurshid. 2011. 有向增量符号执行。第32届ACM SIGPLAN编程语言设计与实现会议论文集。504–515.

[53] Dawei Qi, Abhik Roychoudhury, Zhenkai Liang, and Kapil Vaswani. 2009. DARWIN：调试演化程序的一种方法。第7届欧洲软件工程会议和ACM SIGSOFT软件工程基础研讨会联合会议论文集。ACM。

[54] Ashwin Ramaswamy, Sergey Bratus, Sean W. Smith, and Michael E. Locasto. 2010. Katana：一个针对ELF可执行文件的热修补框架。2010年国际可用性、可靠性和安全性会议论文集。

[55] Stephen Sims. 2016. Bruh！你真的会对比吗？——通过对比微软补丁来发现漏洞。RSA Conference。

[56] Asia Slowinska and Herbert Bos. 2009. 无意义的污点？评估指针污点的实用性。EuroSys。61–74.

[57] Asia Slowinska, Traian Stancescu, and Herbert Bos. 2011. Howard：动态挖掘数据结构的反向工程工具。第18届年度网络和分布式系统安全研讨会（NDSS’11）论文集。

[58] Temple F. Smith and M.S. Waterman. 1981. 识别常见的分子子序列。分子生物学杂志 147, 1 (1981).

[59] Alexander Sotirov. 2006. 热修补与第三方补丁的兴起。Black-Hat USA。

[60] Zhenzhou Tian, Qinghua Zheng, Ting Liu, Ming Fan, Eryue Zhuang, and Zijiang Yang. 2015. 基于动态关键指令序列的软件剽窃检测。IEEE软件工程学报 41, 12 (2015).

[61] Windows Unicorn漏洞在野外被利用。[在线]。Windows Unicorn漏洞在野外被利用。https://securityaffairs.co/wordpress/30402/security/unicorn-exploited-in-the-wild.html.

[62] Harsimran Walia. 2011. 通过反向分析微软补丁揭示易受攻击的代码。Nullcon。

[63] Shuai Wang and Dinghao Wu. 2017. 内存模糊测试用于二进制代码相似性分析。第32届IEEE/ACM自动化软件工程国际会议（ASE’17）论文集。

[64] Xinran Wang, Yoon-Chan Jhi, Sencun Zhu, and Peng Liu. 2009. 基于行为的软件盗版检测。第16届ACM计算机与通信安全会议（CCS’09）论文集。

[65] Xinda Wang, Kun Sun, Archer Batcheller, and Sushil Jajodia. 2019. 检测“零日”漏洞：OSS中秘密安全补丁的经验研究。2019年第49届IEEE/IFIP国际依赖系统和网络会议（DSN）。IEEE, 485–492.

[66] Ye Wang, Na Meng, and Hao Zhong. 2018. 多实体变更在实际Bug修复中的实证研究。第34届IEEE国际软件维护与演化会议（ICSME’18）论文集。

[67] Dasarath Weeratunge, Xiangyu Zhang, William N Sumner, and Suresh Jagannathan. 2010. 使用双切片分析并发Bug。第19届国际软件测试与分析研讨会论文集。ACM, 253–264.

[68] Qiushi Wu, Yang He, Stephen McCamant, and Kangjie Lu. 2020. 通过符号规则比较精确表征大量补丁中的安全影响。第27届年度网络和分布式系统安全研讨会（NDSS’20）论文集。

[69] Yang Xiao, Bihuan Chen, Chendong Yu, Zhengzi Xu, Zimu Yuan, Feng Li, Binghong Liu, Yang Liu, Wei Huo, Wei Zou, and Wenchang Shi. 2020. MVP：使用补丁增强的漏洞签名检测漏洞。第29届USENIX安全研讨会（USENIX Security 20）。USENIX协会。

[70] Dongpeng Xu, Jiang Ming, and Dinghao Wu. 2017. 在混淆二进制文件中通过位精度符号循环映射检测加密函数。第38届IEEE安全与隐私研讨会（S&P’17）论文集。

[71] Xiaojun Xu, Chang Liu, Qian Feng, Heng Yin, Le Song, and Dawn Song. 2017. 基于神经网络的图嵌入用于跨平台二进制代码相似性检测。2017年ACM SIGSAC计算机与通信安全会议（CCS’17）论文集。

[72] Zhengzi Xu, Bihuan Chen, Mahinthan Chandramohan, Yang Liu, and Fu Song. 2017. SPAIN：面向理解痛苦和解决方法的二进制代码安全补丁分析。第39届国际软件工程会议（ICSE’17）论文集。

[73] Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang, Xiaojing Liao, Pan Bian, and Bin Liang. 2017. SemFuzz：基于语义的PoC漏洞利用自动生成。第23届ACM计算机与通信安全会议（CCS’17）论文集。

[74] Hang Zhang and Zhiyun Qian. 2018. 针对二进制文件的精确且准确的补丁存在性测试。第27届USENIX安全研讨会（USENIX Security 18）。887–902.

[75] Shitong Zhu, Xunchao Hu, Zhiyun Qian, Zubair Shafiq, and Heng Yin. 2018. 使用差异执行分析测量和破坏反广告拦截器。第25届年度网络和分布式系统安全研讨会（NDSS’18）论文集。

[76] Fei Zuo, Xiaopeng Li, Zhexin Zhang, Patrick Young, Lannan Luo, and Qiang Zeng. 2019. 超越函数对的神经机器翻译启发的二进制代码相似性比较。第26届网络和分布式系统安全研讨会（NDSS’19）论文集。

---

### 附录

#### A. BinDiff 输出结果
对于图1中的示例，我们利用BinDiff比较两个ghttpd版本在给定PoC上的动态执行跟踪。它报告了多达30个关于删除或添加指令的差异。我们在图5中列出了部分指令对齐序列。

进一步分析报告的32个不同的内存访问显示，这些差异包括通过函数指针、指令地址、参数等进行的内存访问。这表明图1中的补丁导致了不同类型的内存访问元素。相比之下，PatchScope优于BLEX [20]，因为内存对象访问是基于逆向工程的内存对象构建的，并且只捕获用于操作程序输入的内存对象。

通过这个示例，我们强调了二进制差异技术中定义的代码表示是特定于问题范围的。正如文献[20]所示，BLEX明确考虑了不同编译器和优化设置从相同的源代码产生不同的二进制程序的情况。然而，对于补丁分析，BLEX可能并不适用，因为它报告了大量的差异。

**图5**：图1的部分指令对齐序列，由BinDiff返回。

有了如图5所示的输出，远未达到补丁分析的目标。首先，我们可以观察到BinDiff进行了不准确的跟踪对齐。左边第19行的指令应与右边第4行对齐。其次，专家可能会推断这是一个越界漏洞，因为补丁重新定义了两个动态分配的堆空间，其长度灵活。即使如此，低级别的差异也无法为安全专家提供太多关于如何触发此漏洞的信息。

#### B. BLEX 输出结果
对于图1中的示例，BLEX [20]可以成功识别这两个不同的函数，因为相似度得分非常低。然而，如果我们使用BLEX [20]来识别补丁差异，BLEX [20]会报告32个不同的内存访问，如图6所示。

请注意，这些差异仅包括由图1中易受攻击的Log函数的指令生成的内存访问。也就是说，我们排除了库函数调用期间的不同内存访问。否则，BLEX [20]将报告数千个不同的内存访问，因为此补丁将两个局部变量从栈更改为堆中动态分配的变量。因此，在库函数调用期间（例如vsprintf和strlen）的所有内存访问都会被识别为差异，因为内存单元类型（栈与堆）发生了变化。

**图6**：BLEX返回的部分差异序列。每个项目包括指令、其操作数以及指令执行期间相应的内存访问。以第一行的项目W@0xbfffb360[0x0804b34c]为例。W表示写入内存。0xbfffb360是指内存地址，0x0804b34c是写入内存单元0xbfffb360的值。

#### C. 尾调用优化示例
尾调用优化更有效地使用了栈内存，但隐藏了过程间调用关系。我们用伪汇编语言简化了图7中的示例。

```
ghttpd-1.4.3 ghttpd-1.4.4
1   xor %eax,%eax     xor %eax,%eax
2   lea 0x374(%esp),%eax  mov %bx,0x3b(%esp)
3   mov %eax,0x10(%esp)  mov $0x2e64,0x27(%esp)
4   mov 0x370(%esp),%eax  mov %edi,(%esp)
5   lea 0xbd(%esp),%esi
6   mov %bx,0x3b(%esp)  mov $0x252e,0x2b(%esp)
7                       mov $0x5b20,0x2f(%esp)
8                       mov $0x253a,0x33(%esp)
9                       mov $0x5e25,0x37(%esp)
10                      call strlen
11  lea 0x20(%esp),%ebx  lea 0x400(%eax),%ebx
12  mov $0xc8,0x8(%esp)  mov %ebx,(%esp)
13                      call malloc
14  mov $0x1,0x4(%esp)  mov %ebp,0x14(%esp)
15  lea 0x3d(%esp),%ebp
16  mov %eax,0xc(%esp)  mov %edi,0x10(%esp)
17  mov %esi,(%esp)     mov %ebp,%edi
18  mov $0x2e64,0x27(%esp)  mov %ebx,0x4(%esp)
804abbb  mov %ebx,(%esp)  W@0xbfffb360[0x0804b34c]
804abd9  call strlen      W@0xbfffb35c[0x0804abde]
804abe3  mov %eax,(%esp)  W@0xbfffb360[0x00000426]
804abe6  call malloc      W @0xbfffb35c[0x0804abeb]
804abeb  mov %ebx,(%esp)  W@0xbfffb360[0x0804b34c]
804abee  mov %eax,-0x1b0(%ebp)  W@0xbfffb388[0x08051da8]
804abf4  call strlen      W@0xbfffb35c[0x0804abf9]
804abf9  mov -0x1b0(%ebp),%edi  R@0xbfffb388[0x08051da8]
804ac15  mov %edi,(%esp)  W@0xbfffb360[0x08051da8]
804ac25  mov %eax,0x4(%esp)  W@0xbfffb364[0x00000426]
804ac29  call vsnprintf    W@0xbfffb35c[0x0804ac2e]
804ac75  call strftime     W@0xbfffb35c[0x0804ac7a]
804ac7a  mov -0x1b0(%ebp),%edi  R@0xbfffb388[0x08051da8]
804ac80  mov %edi,(%esp)  W@0xbfffb360[0x08051da8]
804ac83  call strlen      W@0xbfffb35c[0x0804ac88]
804ac90  mov %eax,(%esp)  W@0xbfffb360[0xbfffb492]
804ac93  call strlen      W@0xbfffb35c[0x0804ac98]
804ac9c  mov %eax,(%esp)  W@0xbfffb360[0x0000011c]
804aca5  call malloc      W@0xbfffb35c[0x0804acaa]
804acaa  mov %edi,0x14(%esp)  W@0xbfffb374[0x08051da8]
804acd2  mov %eax,(%esp)  W@0xbfffb360[0x08052230]
804acd5  call sprintf     W@0xbfffb35c[0x0804acda]
804ad24  mov -0x1b0(%ebp),%eax  R@0xbfffb388[0x08051da8]
804ad2a  mov %eax,(%esp)  W@0xbfffb360[0x08051da8]
804ad2d  call free        W@0xbfffb35c[0x0804ad32]
804ad32  mov %esi,(%esp)  W@0xbfffb360[0x08052230]
804ad35  call free        W@0xbfffb35c[0x0804ad3a]
804ad54  pop %ebx        R@0xbfffb52c[0xbfffb577]
804ad55  pop %esi        R@0xbfffb530[0x00001000]
804ad56  pop %edi        R@0xbfffb534[0x00000003]
804ad57  pop %ebp        R@0xbfffb538[0xbffff6c8]
804ad58  ret             R@0xbfffb53c[0x0804a0f7]
```

我们识别了一个由缓冲区溢出引起的内存对象访问。

从这个案例中可以观察到，补丁代码更改中的操作和相应变量可能并不是易受攻击的变量。在这个例子中，它首先接收一个整数，然后使用该整数分配第二个内存对象并计算进一步接收输入的长度。错误的计算导致调用recv时出现错误参数。这一观察还表明，以前的技术[68, 74]提取补丁签名、易受攻击的操作和易受攻击的变量时，应该考虑更多的补丁模式。

**fax-3.04**：该应用程序的补丁覆盖了一个函数，这是最复杂的一个。如表1所示，LOC为27，行业二进制差异工具报告了大量的差异。通过检查这些结果，我们发现这些行业二进制差异工具识别了一对不匹配的函数和这对函数中的大量不匹配项。安全专家可能会因大量低级代码差异而困扰。相比之下，PatchScope仅识别了4个差异。通过检查MOA中的不同细节，我们发现新函数在补丁中只添加了一个安全检查。由于安全检查的影响，修补程序阻止了PoC。这一案例进一步证明了PatchScope的核心——内存对象访问序列特别适合通过识别输入操作的差异来进行补丁分析。

此外，我们还可以观察到DeepBinDiff [19]在这种情况下表现良好，因为它仅识别了三个不同的基本块。为了确认这一结果，我们与DeepBinDiff的作者讨论了这个案例。原因是DeepBinDiff采用了程序范围的代码表示学习，而传统的二进制差异处理函数相似性。

**libsndfile**：此漏洞由于复杂的程序逻辑故障而难以理解。修复此漏洞的补丁在不同位置更改了多个语句。尽管复杂，PatchScope仍然提供了有价值的线索来推理漏洞。首先，PatchScope成功地将补丁差异缩小到只有三个不同的内存对象访问项，这些项在图8中标记了颜色。

我们可以观察到，修补程序在内存对象R1和R3上有一个额外的子操作，该操作计算R3的值。然后，R3作为memcpy的参数传递。相比之下，易受攻击的程序将L2作为memcpy的参数。我们了解到，这个补丁通过更改memcpy的参数值来修复漏洞。由于L2和R3的类型都是寄存器，我们推测L2和R3都是memcpy的大小参数——要复制的字节数。这一发现促使我们回溯L2和R3在MOAS中的数据流。我们在图8底部展示了它们的依赖关系。

L2的数据流依赖关系中缺失的一行揭示了漏洞的根本原因：L2在传递给memcpy之前可以通过系统调用read进行操纵。补丁在memcpy接受R3之前添加了一行初始化R3。注意，L2有两个相关的输入字段，其中一个([0x176, 0x303])在R3中不存在。这一线索暗示，溢出这个特定的输入字段可以触发漏洞，我们在PoC中确认了这一点。

**图7**：尾调用优化示例。

#### D. Smith-Waterman算法
Smith-Waterman算法的输入是两个长度分别为n和m的序列A = a1, a2, ...an 和 B = b1, b2, ...bm。最大相似性矩阵H使用以下方程填充：

\[ H(i ,0) = 0, \quad 0 \leq i \leq m, \]
\[ H(0,j) = 0, \quad 0 \leq j \leq n, \]
\[ H(i ,j) = \max \left\{ 
\begin{array}{l}
0 \\
H(i-1,j-1) + \text{Sim}(a_i, b_j) \\
\max_{k \geq 1} \left\{ H(i, j-k) + W_k \right\} \\
\max_{l \geq 1} \left\{ H(i-l, j) + W_l \right\}
\end{array}
\right\}, \quad 1 \leq i \leq m, \quad 1 \leq j \leq n
\]

这里，A和B是两个内存对象访问序列。Sim(ai, bj)是两个内存对象访问项的相似度分数。我们将内存对象访问的定义视为向量，并使用Jaccard指数 |A ∩ B| / |A ∪ B| 来衡量两个向量的相似度。Wk和Wl都是间隙惩罚方案。在我们的比较中，使用固定分数的简单间隙惩罚方案已经能够提供良好的精度。我们将Wk和Wl的值调整为-2。

#### E. 案例研究

**Nginx-1.4.0**：CVE-2013-2028漏洞是一个经典的整数到缓冲区溢出漏洞。一个带符号且为负的整数被错误地用作调用recv的参数。通过比较两个执行之间的MOAS，我们发现修补程序的MOAS比未修补程序的MOAS短得多。根据这一观察，直观的推论是修补程序阻止了不良输入。进一步，我们识别了一个仅存在于修补程序中的MOA项，其操作码为cmp。这一项证实了我们的推论，即补丁通过安全检查修复了漏洞。这个补丁看起来很简单。然而，未修补程序的长MOAS表明补丁点距离崩溃点很远，这促使我们寻找对已修复漏洞的更深入理解。最终，

**图8**：PatchScope对libsndfile的比较结果。

L1    R1  
0xb7fa70fb: sub R [0x36,0x36]  
0xb7fa7107: sub R [0x36,0x36]  

L2    R2  
0xb7fa70fb: sub W [0x36,0x36]  
0xb7fa7107: sub W [0x36,0x36]  

L2    R2  
0xb7fa8bd8: add R [0x36,0x36]  
0xb7fa8bd8: add R [0x36,0x36]  

L2    R2  
0xb7fa8bd8: add W [0x36,0x36]; [0x176,0x303]  
0xb7fa8bd8: add W [0x36,0x36]; [0x176,0x303]  

R1  
0xb7fa7133: sub R [0x36,0x36]  

R3  
0xb7fa7133: sub W [0x36,0x36]  

L2    R3  
0xb7fa7148: call memcpy R [0x36,0x36]; [0x176,0x303]  
0xb7fa714a: call memcpy R [0x36,0x36]  

(a) libsndfile-1.0.25的内存对象访问序列。  
数据流依赖关系：L2 = 0x3004 – L1; L2 = L2 + read(); memcpy(dst, src, L2);  

(b) 补丁后的libsndfile的内存对象访问序列。  
数据流依赖关系：R2 = 0x3004 – R1; R2 = R2 + read(); R3 = 0x3004 – R1; memcpy(dst, src, R3);

---

希望这些修改能帮助您更好地理解和传达您的研究内容。如果有任何进一步的需求或具体要求，请随时告诉我。