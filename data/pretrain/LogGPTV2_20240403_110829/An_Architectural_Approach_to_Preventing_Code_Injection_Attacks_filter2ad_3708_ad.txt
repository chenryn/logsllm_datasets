apache2.2
32KB pages
gzip
256 meg file
nbench
worst case
unixbench
overall
Figure 4. Normalized performance for appli-
cations and benchmarks
 100
Plain
Protected
d
e
e
p
s
l
l
u
f
f
o
%
 80
 60
 40
 20
 0
unixbench
pipe ctxsw
apache2.2
1KB pages
Figure 5. Stress-testing the performance
penalties due to context switching
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:52:10 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007Table 2. Conﬁguration information used for
performance evaluation
Item
Slackware
Apache
Version
10.2.0
2.2.3
ApacheBench
Unixbench
Nbench
Gzip
2.0.41-dev
4.1.0
2.2.2
1.3.3
Conﬁguration
Using Linux 2.6.13
Worker mpm mode, set to spawn
one process with threads
-c3 -t 60 
N/A
N/A
Compress a 256 MB ﬁle.
 100
d
e
e
p
s
l
l
u
f
f
o
%
 80
 60
 40
 20
 0
1
2
4
8
Plain
Protected
64
128
256
512
16
32
Page size (kilobytes)
Figure 6. Closer look into Apache perfor-
mance
the nbench [26] suite was used to show the performance un-
der a set of primarily computation based tests. The slowest
test in the nbench system came in at just under 97%. Finally,
the Unixbench [27] unix benchmarking suite was used as a
micro-benchmark to test various aspects of the system’s per-
formance at tasks such as process creation, pipe throughput,
ﬁlesystem throughput, etc. Here, the split memory system
ran at 82% of normal speed. This result is slightly disap-
pointing, however it can be easily explained by looking at
the speciﬁc test which performed poorly, which we do be-
low. As can be seen from these four benchmarks, the system
has very reasonable performance under a variety of tasks.
If we simply left our description of the system’s per-
formance to these four tests, some readers may object that
given the description of the system so far and the mention
in section 4.3 of the various sources of overhead, something
must be missing from our benchmarks. As such, two bench-
marks contrived to highlight the system’s weakness can be
found in Figure 5. First, one of the Unixbench testcases
called “pipe based context switching” is shown. This pri-
marily tests how quickly a system can context switch be-
tween two processes that are passing data between each
other. The next test is Apache used to serve a 1KB page. In
this conﬁguration, Apache will context switch heavily while
serving requests. In both of these tests, context switching
is taken to an extreme and therefore our system’s perfor-
mance degrades substantially due to the constant ﬂushing
of the TLB. As can be seen in the graph, both are at or
below 50%. In addition, in Figure 6, we have a more thor-
ough set of Apache benchmarks demonstrating this same
phenomena, namely that for low page sizes the system con-
text switches heavily and performance suffers, where as for
larger page sizes that cause Apache to spend more time on
I/O as well as begin to saturate the system’s network link,
the results become signiﬁcantly better. These tests show
very poor performance, however we would like to note that
they are shown here to be indicative of the system’s worst
case performance under highly stressful (rather than nor-
mal) conditions.
Overall, the system’s performance is reasonable, in most
cases being between 80 and 90% of an unprotected system.
Moreover, if split memory was supported at the hardware
level as described in section 3.3, the overheard would be al-
most non-existent. Based on previous work [28], we also
have reason to believe that building the split memory sys-
tem on top of an architecture with a software loaded TLB,
such as SPARC, would also provide further performance
improvements.
6. Limitations
There are a few limitations to our approach. First, when
an attack is stopped by our system the process involved will
crash. We offer no attempt at any sort of recovery. This
means an attacker can still exploit ﬂaws to mount denial-of-
service attacks. Second, as shown in other work [29], a split
memory architecture does not lend itself well to handling
self-modifying code. As such, self-modifying programs
cannot be protected using our technique. Next, this pro-
tection scheme offers no protection against attacks which
do not rely on executing code injected by the attacker. For
example, modifying a function’s return address to point to a
different part of the original code pages will not be stopped
by this scheme. Fortunately, address space layout random-
ization [14] could be combined with our technique to help
prevent this kind of attack. Along those same lines, non-
control-data attacks [23], wherein an attacker modiﬁes a
program’s data in order to alter program ﬂow, are also not
protected by this system. We have also not analyzed the sys-
tem’s functionality on programs that include dynamically
loadable modules (such as DLL ﬁles on windows) but do
not anticipate that such programs would be difﬁcult to sup-
port.
7. Conclusions
In this paper, we present an architectural approach to pre-
vent code injection attacks. Instead of maintaining the tradi-
tional single memory space containing both code and data,
which is often exploited by code injection attacks, our ap-
proach creates a split memory that separates code and data
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:52:10 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007into different memory spaces. Consequently, in a system
protected by our approach, code injection attacks may re-
sult in the injection of attack code into the data space. How-
ever, the attack code in the data space can not be fetched for
execution as instructions are only retrieved from the code
space. We have implemented a Linux prototype on the x86
architecture, and experimental results show the system is ef-
fective in preventing a wide range of code injection attacks
while incurring acceptable overhead.
8. Acknowledgments
We would like to thank Glenn Wurster as well as the
anonymous reviewers for their helpful comments and sug-
gestions. This work was supported in part by NSF Grants
OCI-0438246, OCI-0504261, and CNS-0546173.
References
[1] A detailed description of the data execution prevention
(dep) feature in windows xp service pack 2, windows xp
tablet pc edition 2005, and windows server 2003. http:
//support.microsoft.com/kb/875352. Last ac-
cessed Dec 2006.
[2] Pax
pageexec
documentation.
grsecurity.net/docs/pageexec.txt.
accessed Dec 2006.
http://pax.
Last
[3] I. Corporation.
IA-32 Intel Architecture Software Devel-
oper’s Manual Volume 3A: System Programming Guide,
Part 1. Intel Corp., 2006. Publication number 253668.
[4] Buffer overﬂow attacks bypassing dep (nx/xd bits) - part 2
: Code injection. http://www.mastropaolo.com/
?p=13. Last accessed Dec 2006.
[5] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beat-
tie, A. Grier, P. Wagle, Q. Zhang, and H. Hinton. Stack-
Guard: Automatic adaptive detection and prevention of
buffer-overﬂow attacks. In Proc. 7th USENIX Security Con-
ference, pages 63–78, San Antonio, Texas, jan 1998.
[6] H. Etoh. Gcc extension for protecting applications from
stack-smashing attacks. http://www.trl.ibm.com/
projects/security/ssp/. Last accessed Dec 2006.
[7] Vendicator. Stack shield: A “stack smashing” technique
protection tool for linux. http://www.angelfire.
com/sk/stackshield/info.html. Last accessed
Dec 2006.
[8] J. Wilander and M. Kamkar. A comparison of publicly avail-
able tools for dynamic buffer overﬂow prevention. In Pro-
ceedings of the 10th Network and Distributed System Se-
curity Symposium, pages 149–162, San Diego, California,
February 2003.
[9] J. von Neumann. First draft of a report on the edvac. 1945.
Reprinted in The Origins of Digital Computers Selected Pa-
pers, Second Edition, pages 355–364, 1975.
[10] P. C. van Oorschot, A. Somayaji, and G. Wurster. Hardware-
assisted circumvention of self-hashing software tamper re-
sistance. IEEE Trans. Dependable Secur. Comput., 2(2):82–
92, 2005.
[11] H. H. Aiken.
Proposed automatic calculating machine.
1937. Reprinted in The Origins of Digital Computers Se-
lected Papers, Second Edition, pages 191–198, 1975.
[12] H. H. Aiken and G. M. Hopper. The automatic sequence
controlled calculator. 1946. Reprinted in The Origins of
Digital Computers Selected Papers, Second Edition, pages
199–218, 1975.
[13] kernelthread.com:
Securing memory.
http:
//www.kernelthread.com/publications/
security/smemory.html. Last accessed Dec 2006.
[14] Pax aslr documentation. http://pax.grsecurity.
net/docs/aslr.txt. Last accessed Dec 2006.
[15] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address Obfus-
cation: An Efﬁcient Approach to Combat a Broad Range of
Memory Error Exploits. 12th USENIX Security, 2003.
[16] S. Bhatkar, R. Sekar, and D. C. DuVarney. Efﬁcient Tech-
niques for Comprehensive Protection from Memory Error
Exploits. 14th USENIX Security, 2005.
[17] J. Xu, Z. Kalbarczyk, and R. K. Iyer. Transparent Runtime
Randomization for Security. In Proc. of 22nd Symposium on
Reliable and Distributed Systems (SRDS) , Florence, Italy,
Oct. 2003.
[18] E. G. Barrantes, D. H. Ackley, S. Forrest, T. S. Palmer,
D. Stefanovic, and D. D. Zovi. Randomized Instruction Set
Emulation to Disrupt Binary Code Injection Attacks. 10th
ACM CCS, 2003.
[19] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Counter-
ing Code-Injection Attacks With Instruction-Set Random-
ization. 10th ACM CCS, 2003.
[20] S. Sidiroglou, M. E. Locasto, S. W. Boyd, and A. D.
Keromytis. Building a Reactive Immune System for Soft-
ware Services. USENIX Annual Technical Conference,
2005.
[21] L. Lam and T. Chiueh. Checking Array Bound Violation Us-
ing Segmentation Hardware. Dependable Systems and Net-
works, 2005. DSN 2005. Proceedings. International Confer-
ence on, pages 388–397, 2005.
[22] Wind river: Vxworks. http://www.windriver.com/
vxworks/. Last accessed Mar 2007.
[23] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. Iyer. Non-
control-data attacks are realistic threats. In Proc. USENIX
Security Symposium, aug 2005.
[24] bochs: The open source ia-32 emulation project. http://
bochs.sourceforge.net/. Last accessed Dec 2006.
http://httpd.
[25] The apache http server project.
[26] Linux/unix nbench. http://www.tux.org/∼mayer/
apache.org/. Last accessed Dec 2006.
linux/bmark.html. Last accessed Dec 2006.
[27] Unixbench.
http://www.tux.org/pub/tux/
benchmarks/System/unixbench/. Last accessed
Dec 2006.
[28] G. Wurster. A generic attack on hashing-based software tam-
per resistance. Master’s thesis, Carleton University, Canada,
Apr 2005.
[29] J. Gifﬁn, M. Christodorescu, and L. Kruger. Strengthen-
ing software self-checksumming via self-modifying code. In
Proceedings of the 21st Annual Computer Security Applica-
tions Conference (ACSAC 2005), pages 18–27, Tucson, AZ,
USA, Dec. 2005. Applied Computer Associates, IEEE.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:52:10 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007