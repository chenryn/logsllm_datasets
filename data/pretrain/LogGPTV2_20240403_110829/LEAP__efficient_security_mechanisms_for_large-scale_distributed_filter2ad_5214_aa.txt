title:LEAP: efficient security mechanisms for large-scale distributed
sensor networks
author:Sencun Zhu and
Sanjeev Setia and
Sushil Jajodia
LEAP: Efﬁcient Security Mechanisms for Large-Scale
Distributed Sensor Networks
Center for Secure Information
Center for Secure Information
Center for Secure Information
Sanjeev Setia
Sushil Jajodia
George Mason University
George Mason University
Sencun Zhu
Systems
Fairfax, VA 22030
PI:EMAIL
Systems
Fairfax, VA 22030
PI:EMAIL
Systems
George Mason University
Fairfax, VA 22030
PI:EMAIL
ABSTRACT
In this paper, we describe LEAP (Localized Encryption and
Authentication Protocol), a key management protocol for
sensor networks that is designed to support in-network pro-
cessing, while at the same time restricting the security im-
pact of a node compromise to the immediate network neigh-
borhood of the compromised node. The design of the pro-
tocol is motivated by the observation that diﬀerent types
of messages exchanged between sensor nodes have diﬀerent
security requirements, and that a single keying mechanism
is not suitable for meeting these diﬀerent security require-
ments. LEAP supports the establishment of four types of
keys for each sensor node – an individual key shared with
the base station, a pairwise key shared with another sensor
node, a cluster key shared with multiple neighboring nodes,
and a group key that is shared by all the nodes in the net-
work. The protocol used for establishing and updating these
keys is communication- and energy-eﬃcient, and minimizes
the involvement of the base station. LEAP also includes an
eﬃcient protocol for inter-node traﬃc authentication based
on the use of one-way key chains. A salient feature of the
authentication protocol is that it supports source authenti-
cation without precluding in-network processing and passive
participation. We analyze the performance and the secu-
rity of our scheme under various attack models and show
our schemes are very eﬃcient in defending against many at-
tacks.
Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—
Security and protection
General Terms
Design, Security
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’03, October 27–31, 2003, Washington, DC, USA.
Copyright 2003 ACM 1-58113-738-9/03/0010 ...$5.00.
Keywords
Security Mechanism, Sensor Networks, Key Management,
In-network Processing
1.
INTRODUCTION
Many sensor systems are deployed in unattended and of-
ten adversarial environments. Hence, security mechanisms
that provide conﬁdentiality and authentication are critical
for the operation of many sensor applications. Providing se-
curity is particularly challenging in sensor networks due to
the resource limitations of sensor nodes. As a speciﬁc exam-
ple, it is not practical to use asymmetric cryptosystems in a
sensor network where each node consists of a slow (4 MHz)
under-powered processor with only 8 KB of memory [22].
Thus, key management protocols for sensor networks are
based upon symmetric key algorithms.
A fundamental issue that must be addressed for using key
management protocols based on symmetric shared keys is
the mechanism used for establishing the shared keys in the
ﬁrst place. The constrained energy budgets and the lim-
ited computational and communication capacities of sensor
nodes make protocols such as TLS [7] and Kerberos [15] de-
veloped for wired networks impractical for use in large-scale
sensor networks. At present, the most practical approach
for bootstrapping secret keys in sensor networks is to use
pre-deployed keying in which keys are loaded into sensor
nodes before they are deployed. Several solutions based on
pre-deployed keying have been proposed in the literature in-
cluding approaches based on the use of a global key shared
by all nodes [5, 2], approaches in which every node shares a
unique key with the base station [22], and approaches based
on random key sharing [9, 6].
An important design consideration for security protocols
based on symmetric keys is the degree of key sharing be-
tween the nodes in the system. At one extreme, we can have
network-wide keys that are used for encrypting data and for
authentication. This key sharing approach has the lowest
storage costs and is very energy-eﬃcient since no communi-
cation is required between nodes for establishing additional
keys. However, it has the obvious security disadvantage that
the compromise of a single node will reveal the global key(s).
At the other extreme, we can have a key sharing approach
in which all secure communication is based on keys that
are shared pairwise between two nodes. From the security
point of view, this approach is ideal since the compromise
of a node does not reveal any keys that are used by the
62other nodes in the network. However, under this approach,
each node will need a unique key for every other node that it
communicates with. Moreover, in many sensor networks, the
immediate neighbors of a sensor node cannot be predicted in
advance; consequently, these pairwise shared keys will need
to be established after the network is deployed.
A unique issue that arises in sensor networks that needs
to be considered while selecting a key sharing approach is
its impact on the eﬀectiveness of in-network processing [16].
In many applications, sensors in the network are organized
into a data fusion or aggregation hierarchy for eﬃciency.
Readings or messages from several sensors are processed at
a data fusion node and aggregated into a more compact
report before being relayed to the parent node in the data
fusion hierarchy [13]. Passive participation is another form
of in-network processing in which a sensor node can take
certain actions based on overheard messages [14, 20], e.g.,
a sensor can decide to not report an event if it overhears a
neighboring node reporting the same event.
Particular keying mechanisms may preclude or reduce the
eﬀectiveness of in-network processing. To support passive
participation, it is essential that intermediate nodes be able
to decrypt or authenticate a secure message exchanged be-
tween two other sensor nodes. Thus, passive participation
of secure messages is only possible if multiple nodes share
the keys used for encryption and authentication. On the
other hand, if a pairwise shared key is used for encrypting
or authenticating a message, it eﬀectively precludes passive
participation in the sensor network.
In this paper, we describe LEAP (Localized Encryption
and Authentication Protocol), a key management protocol
for sensor networks that is designed to support in-network
processing, while at the same time providing security prop-
erties similar to those provided by pairwise key sharing sche-
mes.
In other words, the keying mechanisms provided by
LEAP enable in-network processing, while restricting the
security impact of a node compromise to the immediate net-
work neighborhood of the compromised node.
LEAP includes support for multiple keying mechanisms.
The design of these mechanisms is motivated by the obser-
vation that diﬀerent types of messages exchanged between
sensor nodes have diﬀerent security requirements, and that
a single keying mechanism is not suitable for meeting these
diﬀerent security requirements. Speciﬁcally, our protocol
supports the establishment of four types of keys for each sen-
sor node – an individual key shared with the base station,
a pairwise key shared with another sensor node, a cluster
key shared with multiple neighboring nodes, and a group
key shared by all the nodes in the network. Moreover, the
protocol used for establishing these keys for each node is
communication- and energy-eﬃcient, and minimizes the in-
volvement of the base station.
LEAP also includes an eﬃcient protocol for inter-node
traﬃc authentication based on the use of one-way key chains.
A salient feature of the authentication protocol is that it sup-
ports source authentication (unlike a protocol where a glob-
ally shared key is used for authentication) without prevent-
ing passive participation (unlike a protocol where a pairwise
shared key is used for authentication).
The rest of this paper is organized as follows. We dis-
cuss our design goals and assumptions in Section 2, before
describing the LEAP protocol in detail in Section 3. The
inter-node traﬃc authentication protocol is described in Sec-
tion 3.3. In Section 4 and 5, we analyze the performance
and security of our protocol. We discuss related work in
Section 6 before concluding the paper in Section 7.
2. ASSUMPTIONS AND DESIGN GOALS
We describe below our assumptions regarding the sensor
network scenarios in which our keying protocols will be used,
before discussing the design goals of our protocol.
2.1 Network and Security Assumptions
We assume that the sensor network is static, i.e., sensor
nodes are not mobile. The base station, acting as a con-
troller (or key server), is assumed to be a laptop class device
and supplied with long-lasting power. The sensor nodes are
similar in their computational and communication capabili-
ties and power resources to current generation sensor nodes,
e.g. the Berkeley MICA motes [12]. We assume that every
node has space for storing up to hundreds of bytes of key-
ing materials. The sensor nodes can be deployed via aerial
scattering or by physical installation. However, we assume
that the immediate neighboring nodes of any sensor node
will not be known in advance.
Because wireless communication is not secure, we assume
an adversary can eavesdrop on all traﬃc, inject packets or
replay older messages. We assume that if a node is com-
promised, all the information it holds will also be compro-
mised. However, we assume the base station will not be
compromised.
2.2 Design Goals
The main goal of LEAP is to design eﬃcient security
mechanisms for supporting various communication models
in sensor networks. The security requirements not only in-
clude authentication and conﬁdentiality but also robustness
and survivability. In other words, the sensor network should
be robust against various security attacks, and if an attack
succeeds, its impact should be minimized. For example, the
compromise of a single node should not break the security
of the entire network.
The protocol should also support sensor network opti-
mization mechanisms such as in-network processing. Since
the resources of a sensor node are very constrained, the key
establishment protocols should be lightweight and minimize
communication and energy consumption. It should be pos-
sible to add new sensor nodes incrementally to the sensor
network. The keying protocols should be scalable, i.e., the
size of the sensor network should not be limited by the per-
node storage and energy resources.
3. LEAP: LOCALIZED ENCRYPTION AND
AUTHENTICATION PROTOCOL
As discussed in the introduction, LEAP provides multiple
keying mechanisms that can be used for providing conﬁ-
dentiality and authentication in sensor networks. We ﬁrst
motivate and present an overview of the diﬀerent keying
mechanisms in Section 3.1 before describing the protocols
used by LEAP for establishing these keys. The inter-node
traﬃc authentication mechanism that is part of LEAP is
discussed separately in Section 3.3.
3.1 Overview
The packets exchanged by nodes in a sensor network can
be classiﬁed into several categories based on diﬀerent crite-
ria, e.g. control packets vs data packets, broadcast packets
vs unicast packets, queries or commands vs sensor readings,
etc. The security requirements for a packet will typically de-
pend on the category it falls in. Authentication is required
for all type of packets, whereas conﬁdentiality may only be
required for some types of packets. For example, routing
control information usually does not require conﬁdentiality,
whereas (aggregated) readings transmitted by a sensor node
and the queries sent by the base station may need conﬁden-
tiality.
We argue that no single keying mechanism is appropriate
for all the secure communication that is needed in sensor
networks. As such, LEAP supports the establishment of four
types of keys for each sensor node – an individual key shared
with the base station, a pairwise key shared with another
sensor node, a cluster key shared with multiple neighboring
nodes, and a group key that is shared by all the nodes in
the network. We now discuss each of these keys in turn and
describe our reasons for including it in our protocol.
Individual Key Every node has a unique key that it shares
pairwise with the base station. This key is used for
secure communication between a node and the base
station. For example, a node may send an alert to the
base station if it observes any abnormal or unexpected
behavior by a neighboring node. Similarly, the base
station can use this key to encrypt any sensitive in-
formation, e.g. keying material or special instruction,
that it sends to an individual node.
Group Key This is a globally shared key that is used by
the base station for encrypting messages that are broad-
cast to the whole group. For example, the base station
issues missions, sends queries and interests. Note that
from the conﬁdentiality point of view there is no ad-
vantage to separately encrypting a broadcast message
using the individual key of each node. However, since
the group key is shared among all the nodes in the net-
work, an eﬃcient rekeying mechanism is necessary for
updating this key after a compromised node is revoked.
Cluster Key A cluster key is a key shared by a node and
all its neighbors, and it is mainly used for securing
locally broadcast messages, e.g., routing control infor-
mation, or securing sensor messages which can beneﬁt
from passive participation. Researchers have shown
that in-network processing techniques, including data
aggregation and passive participation are very impor-
tant for saving energy consumption in sensor networks
[13, 14, 20]. For example, a node that overhears a
neighboring sensor node transmitting the same read-
ing as its own current reading can elect to not trans-
mit the same.
In responding to aggregation opera-
tions such as MAX, a node can also suppress its own
reading if its reading is not larger than an overheard
one. For passive participation to be feasible, neigh-
boring nodes should be able to decrypt and authen-
ticate some classes of messages, e.g., sensor readings,
transmitted by their neighbors. This means that such
messages should be encrypted or authenticated by a
locally shared key. Therefore, in LEAP each node pos-
sesses a unique cluster key that it uses for securing its
messages, while its immediate neighbors use the same
key for decryption or authentication of its messages.
Pairwise Shared Key Every node shares a pairwise key
with each of its immediate neighbors. In LEAP, pair-
wise keys are used for securing communications that
require privacy or source authentication. For example,
a node can use its pairwise keys to secure the distribu-
tion of its cluster key to its neighbors, or to secure the
transmissions of its sensor readings to an aggregation
node. Note that the use of pairwise keys precludes
passive participation.
3.2 Key Establishment
In this section, we describe the schemes provided by LEAP
for sensor nodes to establish and update individual keys,
pairwise shared keys, cluster keys, and group keys for each
node. We note that the key establishment (and re-keying)
protocol for the group key uses cluster keys, whereas cluster
keys are established (and re-keyed) using pairwise shared
keys.
Notation We list below notations which appear in the rest
of this discussion.
• N is the number of nodes in the network
• u, v (in lower case) are principals such as communi-
• {fk} is a family of pseudo-random functions [10].
• {s}
• M AC(k, s) is the message authentication code (MAC)
k means encrypting message s with key k.
cating nodes.
of message s using a symmetric key k.
From a key K a node can derive other keys for various
security purposes. For example, a node can use K0 = fK (0)
for encryption and use K1 = fK (1) for authentication. For
ease of presentation, in the following discussion, we simply
say that a message is encrypted or authenticated with key
K, although the message is really encrypted with K0 and
authenticated with K1 respectively.
3.2.1 Establishing Individual Node Keys
Every node has an individual key that is only shared with
the base station. This key is generated and pre-loaded into
each node prior to its deployment.
The individual key Km