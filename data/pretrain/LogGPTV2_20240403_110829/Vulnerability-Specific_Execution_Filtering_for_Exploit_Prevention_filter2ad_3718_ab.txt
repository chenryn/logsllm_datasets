that the data is not tainted. Dynamic taint analysis has been
shown to accurately detect a wide range of exploit attacks
including buffer overrun, format string, and double free at-
tacks [14, 27, 36, 11], making it one of the most compre-
hensive protection mechanisms that does not require access
to source code.
However, dynamic taint analysis requires instrumenting
many instructions. Every data movement, arithmetic, and
control transfer instructions that could potentially touch a
tainted memory location must be instrumented in order to
accurately propagate the taint attribute and detect when
tainted data is misused. Such extensive instrumentation can
add signiﬁcant performance overhead — up to a factor of
30 or more in some cases [27].
We observe that when exploiting a particular vulnerabil-
ity, only a handful of instructions are involved in propagat-
ing the tainted input to the sensitive location that is over-
written. When we know what those instructions are, we
Sample 
Exploit
Exploit
Detector
Exploit
Execution
Trace
VSEF filter
VSEF Binary
Instrumentation
Engine
Hardened
Binary
Program
VSEF Filter
Generator
Vulnerable
Binary 
Program
Figure 1. VSEF architecture. Once an exploit is detected, an execution log is produced. The VSEF
Filter Generator produces a ﬁlter that recognizes execution patterns that exploit the vulnerability.
These ﬁlters can then be disseminated. The VSEF Filter Generator takes the ﬁlter and instruments
the binary to recognize execution sequences that exploit the vulnerability, the result being a hardened
binary.
can instrument only those instructions to propagate the taint
attribute, and the instruction that unsafely uses the tainted
data, and still successfully detect attacks against that vul-
nerability.
Thus, in taint-based VSEF, we automatically identify
and instrument the instruction positions that need to be in-
strumented to propagate the taint attribute and to detect the
misuse of tainted data to detect exploits of a particular vul-
nerability. As a result, taint-based VSEF can detect exploits
of the same vulnerability much more efﬁciently than full
execution monitoring.
3.1.2. Taint-based VSEF Filter Generation
A taint-based VSEF ﬁlter includes two parts: (1) the list
of instruction positions that we need to add instrumentation
to for taint propagation, and (2) the instruction position to
which we need to add instrumentation to detect the misuse
of tainted data.
Instruction positions can be expressed as
absolute addresses, or as the name of a shared library and
offset into that library for increased portability.
The instruction position that we need to add instrumen-
tation to to detect the misuse of tainted data is simply the
instruction position where tainted data was detected being
misused. The list of instruction positions that we need to
add instrumentation to for taint propagation is the list of in-
structions that propagated the taint attribute from the origi-
nal malicious input to the point where it was detected being
misused in the exploit execution trace.
The VSEF Filter Generator can identify this list using
1) any exploit detector that can identify the tainted data
that was misused and what instruction misused it, and 2)
a log of instructions that have been executed, and the val-
ues of dynamically calculated addresses. The latter can be
logged in software, or generated efﬁciently using hardware
support [7, 32]. The VSEF Filter Generator examines the
trace in a backward manner to determine which instructions
propagated tainted data that reached the vulnerability detec-
tion point. It begins at the end of the trace, called the exploit
point, where the exploit was detected. The source operand
to this instruction must have been tainted by some previous
instruction in the trace (since this is an overwrite attack us-
ing tainted data); and the source operand of that instruction
must have been tainted by some other previous instruction,
etc.. The VSEF Filter Generator continues performing the
analysis recursively until it reaches the initial instructions
for reading the original untrusted input in the sample ex-
ploit.
By following the chain of tainted operations backwards,
the VSEF Filter Generator can identify the list of instruc-
tions in the execution trace which were involved in propa-
gating the taint attribute from the original untrusted input to
the exploit point. This list of instructions is used in the ﬁlter
as the list of instructions to be instrumented to propagate the
taint attribute. This calculation is an instance of ﬂowback
analysis [5], a well studied and efﬁcient procedure [38].
An obvious choice for the exploit detector is a taint-
In particular,
based exploit detector [14, 27, 36, 11].
TaintCheck [27] already keeps a directed acyclic graph
(DAG) of where tainted data was propagated from, and at
at what instruction points. That is, each time tainted data
is propagated, a node is generated that contains the posi-
tion of the currently executing instruction, and pointers to
nodes corresponding to each tainted operand.
In this ap-
proach all the information needed to calculate the ﬁlter is
already on hand. The VSEF Filter Generator simply follows
the DAG from the point(s) where tainted data was misused
to the point(s) where it was originally input, and records all
the instruction positions on that path.
C source
struct dummy t f
char buf[16];
void (*fnptr)(void);
g;
void vuln(struct dummy t *dummy)
f
char bigbuf[100];
int i = 0;
int count = 0;
void (*fnptr)(void) = NULL;
fgets(bigbuf, 100, stdin);
strcpy(dummy(cid:0) >buf, bigbuf);
fnptr = dummy(cid:0) >fnptr;
fnptr();
g
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
IA-32 assembly
Taint propagation
A int $0x80
B repz movsb %ds:(%esi),%es:(%edi)
C movzbl (%edx),%eax
D mov %al,(%ecx,%edx,1)
E mov 0x10(%eax),%eax
F mov %eax,0xffffffcc(%ebp)
G mov 0xffffffcc(%ebp),%eax
H call *%eax
0x3a966010   stdin
0xafefea80   0x3a966010
al   0xafefea80
0x80ad1b0   al
eax   0x80ad1b0
0xafefea64   eax
eax   0xafefea64
illegal use of tainted eax
Table 1. Overwrite example: A piece of vulnerable code, and the instructions that propagated and
misused the tainted data when the vulnerability was exploited. Instruction position D is the overwrite
point, where tainted data overwrites a function pointer.
Instruction position H is the exploit point,
where the tainted data is misused.
Table 1 shows an example of code that is vulnerable to
an overwrite attack, in this case a buffer overﬂow that over-
writes a function pointer. The second column shows the as-
sembly instructions that are involved in propagating tainted
data to the point where it is misused. The third column
shows the actual propagation, with the data addresses as re-
solved at run time. In this example, the exploit is detected
at instruction H, where tainted data in eax is misused. The
VSEF Filter Generator traces backwards in the execution
log (or the DAG if using TaintCheck) and ﬁnds that instruc-
tion G was the last instruction to write to eax, and so on,
back to instruction A which performed a read system call.
Hence, the taint-based VSEF ﬁlter consists of position H,
where tainted data was misused, and positions A through
G, which propagated the tainted data to that point.
3.1.3. Taint-based VSEF Binary Instrumentation
The Taint-based VSEF Filter Generator instruments each
instruction in the taint-based VSEF ﬁlter to propagate taint
information, and inserts the appropriate safety check at the
exploit point. The instrumentation conceptually keeps a list
of tainted memory locations. When an instruction listed in
the VSEF executes, the added instrumentation checks to see
if any source operand is a tainted location. If so, it marks
the destination as also tainted. The Taint-based VSEF Filter
Generator inserts instrumentation at the exploit point to de-
tect if the sensitive value being used is tainted, signifying an
attack, and if so to take appropriate action. Here, we assume
the appropriate action is exiting the program. Others have
investigated other actions, such as returning an error code
and continuing execution [30, 33]. The resulting program
with the added instrumentation is the hardened binary.
When the hardened binary is run, the instrumentation
propagates the taint attribute throughout the program as
would have been done by a full taint-based exploit detector.
If the exploit point is reached, and the data being used in a
sensitive way has been marked tainted, execution is aborted.
Since the VSEF Filter Generator does not instrument
all data movement and arithmetic instructions, tainted lo-
cations are not marked untainted when overwritten with un-
tainted data by uninstrumented instructions. This could po-
tentially lead to false positives in some cases. For example,
suppose a stack-based buffer marked as tainted is popped off
the stack, and is later overwritten with a (legitimate) return
address, without being marked untainted.
We address this problem by having the hardened binary
record the value that a location takes on when it is marked as
tainted. When another instrumented instruction later checks
to see if that location is tainted, it also checks to see if it still
has the same value. If not, then it has been overwritten by
an uninstrumented instruction, and is marked as no longer
tainted. This approach adds little overhead, but there is still
some potential for false positives. If an uninstrumented in-
struction overwrites tainted data with the same value that
was already there, this heuristic will not correctly untaint
that location.
An alternative approach is to use existing memory
watch-point techniques to monitor tainted locations, and un-
taint them when other instructions write to them. On the IA-
32 architecture the debug registers can be used to monitor
up to 4 memory locations (up to 4 bytes each). We can also
use page-protection techniques (e.g., setting tainted mem-
ory pages to be read-only) to be notiﬁed of writes to tainted
memory. Moreover, when available, we can also use ECC
memory to be notiﬁed of writes to tainted memory similar
to techniques used in [28]. All of these techniques generate
a trap when the watched memory is accessed (or memory
near the watched memory), allowing our code to untaint the
watched location if it has been rewritten by untainted data.
The cost of generating traps when data is untainted can be
reduced by reducing the amount of data that gets tainted.
One way to achieve this is to modify the instrumentation of
each of the data propagation instruction in the VSEF ﬁlter,
so that it will only taint the destination when executing in
the same call-stack context as during the original exploit.
This technique comes with a trade-off of false negatives
when data is tainted by the same instructions, but in a differ-
ent context, until the alternate contexts are discovered and
added to the VSEF ﬁlter. While we are unaware of existing
mechanisms to watch for writes to processor registers, we
expect that a processor register will not remain tainted for
long before being overwritten with untainted data. Hence,
when a register becomes tainted, we can switch to moni-
toring all instructions until it becomes untainted again. We
show how to efﬁciently turn full taint analysis on and off at
run time in [25].
3.1.4. Analysis and Combining Filters
Performance. By design the taint-based VSEF ﬁlter can be
created with information already on hand to a Taint-based
detector. As a result, ﬁlter generation is almost instanta-
neous. The length of the ﬁlter is proportional to the number
of instructions that propagate tainted data from the input to
the exploit point. Similarly, the execution overhead of the
hardened program is proportional to this number of instruc-
tions. By design, most programs attempt to minimize un-
necessary data copying, so this will intuitively be a small
set of instructions. We verify this in our experimental re-
sults.
Note that it is likely that one or more of the instructions
that propagate tainted data in the attack belong to a com-
monly used data movement function such as strcpy or
memcpy, and hence the instrumentation will be executed
any time that function is called. In our evaluation this was
true, though we did not ﬁnd it to be a performance problem.
If it were, we could use the techniques described in Sec-
tion 3.2 so that the instrumentation is only executed when
the function is called in the vulnerable context.
Accuracy. The VSEF-hardened binary has no false posi-
tives when memory watchpoint techniques are used to en-
sure locations are correctly marked untainted when written
to by uninstrumented instructions. There is nothing marked
as tainted by the instrumentation that was not actually de-
rived from untrusted input, and during detection we already
determined that the attacker should not be able to write to
the sensitive value being guarded. Note that without using
memory watchpoint support, the untaint heuristic will not
correctly untaint data if it has been overwritten by untainted