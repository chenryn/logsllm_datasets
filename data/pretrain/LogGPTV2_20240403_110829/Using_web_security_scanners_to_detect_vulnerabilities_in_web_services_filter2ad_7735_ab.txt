Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:58:23 UTC from IEEE Xplore.  Restrictions apply. 
    different versions of a specific brand), namely: HP WebInspect [10], IBM Rational AppScan [9], and Acunetix Web Vulnerability Scanner [8]. These are very well-know scanners that are representative of the state-of-the-art in the detection of security vulnerabili-ties in web applications. For the results presentation we have decided not to mention the brand and the versions of these scanners to assure neutrality and because commercial licenses do not allow in general the publication of tool evaluation results. This way, the scanners presented above are referred in the rest of this paper as VS1.1, VS1.2, VS 2, and VS3 (without any order in particular). Vulnera-bility scanners VS1.1 and VS1.2 refer to the two ver-sions of the same product.  3. Results and discussion  The following subsections present and discuss the results obtained and the lessons learned during this study. Due to space constraints we do not present the detailed results (i.e., results for the individual services). Interested readers can obtain them at [14].  3.1. Overall results analysis  Table 1 presents the overall results of the study. For each scanner it is presented the total number of vulne-rabilities and the number of services in which those vulnerabilities were found. The scanners pointed six different types of vulnerabilities, namely: (cid:129) SQL Injection: it is possible “to alter the con-struction of backend SQL statements” [15]. An at-tacker can read or modify database data and, in some cases, execute database administration opera-tions or commands in the system [4]. (cid:129) XPath Injection: it is possible to modify an XPath query to “be parsed in a way differing from the programmer's intention” [15]. Attackers may gain access to information in XML documents [4]. (cid:129) Code Execution: it is possible to manipulate the application inputs to trigger server-side code execu-tion [4]. An attacker can exploit this vulnerability to execute malicious code in the server machine.  (cid:129) Buffer Overflow: it is possible to manipulate in-puts in such a way that causes buffer allocation problems, including over-writing parts of the mem-ory [4]. Attackers can cause Denial of Service or, in worst cases, “alter application flow and force unintended actions” [15]. (cid:129) Username/Password Disclosure: the web service response contains information related to usernames and/or passwords. An attacker can use this informa-tion to get access to private data [4]. (cid:129) Server Path Disclosure: the response contains a fully qualified path name to the root of the server storage system. An attacker can use this info to dis-cover the server file system structure and devise other security attacks [4].  As we can see in Table 1, different scanners report different types of vulnerabilities. The only exception is SQL Injection that is reported by all scanners. This is a first indicator that scanners implement different forms of penetration tests and that the results from different scanners may be difficult to compare. Nevertheless, results suggest that in order to have a good coverage the user will have to use several scanners instead of relying in only one. Scanners VS1.1 and VS1.2 (two different versions of the same brand) are the only ones that detected XPath Injection vulnerabilities. An important aspect is that, when compared to SQL Injection, the number of XPath-related vulnerabilities is quite small. In fact, XPath vulnerabilities were detected in a single service, indicating that most web services make use of a data-base instead of XML documents to store information. Scanners VS1.1 and VS1.2 detected a code execu-tion vulnerability. This is a particularly critical vulne-rability that allows attackers to execute code in the server. After discovering this vulnerability we per-formed some manual tests and we were amazed by the possibility of executing commands (e.g., ‘cat /etc/passwd’, ‘ls -la’) and get the corresponding answer in a readable format. VS3 was the only one pointing vulnerabilities re-lated to buffer overflow, username and password dis-closure, and server path disclosure. As mentioned before, SQL Injection is the only type of vulnerability that was detected by the four scanners used. However, different scanners reported different vulnerabilities in different web services. In fact, the number of SQL Injection vulnerabilities detected by VS1.1 and VS1.2 is much higher than the number of vulnerabilities detected by VS2 and VS3. Thus, we decided to look at this vulnerability type in more detail. Vulnerability Types VS1.1 VS1.2 VS2 VS3 # Vuln.# WS# Vuln.# WS # Vuln. # WS # Vuln.# WSSQL Injection 217 38 225 38 25 5 35 11 XPath Injection 10 1 10 1 0 0 0 0 Code Execution 1 1 1 1 0 0 0 0 Possible Parameter Based Buffer Overflow0 0 0 0 0 0 4 3 Possible Username or Password Disclosure0 0 0 0 0 0 47 3 Possible Server Path Disclosure 0 0 0 0 0 0 17 5 Total 228 40 236 40 25 5 103 22 Table 1. Overall results. 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
569
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:58:23 UTC from IEEE Xplore.  Restrictions apply. 
    The intersection areas of the circles in Figure 1 represent the number of vulnerabilities detected by more than one scanner (the number of vulnerabilities detected is shown; zero is the value when no number is presented). Note that the area of each circle is roughly proportional to the number of vulnerabilities detected, but there is no correspondence between the size of the intersection areas and the number of vulnerabilities (it is too complex to represent graphically).  Figure 1 clearly shows that the four scanners de-tected different sets of SQL Injection vulnerabilities and the differences are considerable, pointing again to relatively low coverage of each vulnerability scanner individually. In fact, even for VS1.1 and VS1.2, two consecutive versions of the same scanner, there are considerable differences. VS1.1, the older version, detected 19 SQL Injection vulnerabilities that were not detected by VS1.2. On the other hand, VS1.2 detected 27 vulnerabilities that were not detected by VS1.1.  3.2. False positives analysis  The results presented so far do not consider false positives (i.e., situations where scanners detected a vulnerability that in the reality does not exist). Howev-er, it is well known that false positives are very diffi-cult to avoid. This way, we decided manually confirm the existence (or not) of each vulnerability detected. Confirming the existence of a vulnerability without having access to the source code is a difficult task. Thus, we defined a set of rules and corresponding checks to classify the vulnerabilities detected by the scanners in three groups: a) False positives, b) Con-firmed vulnerabilities, and c) Doubtful. Detected vulnerabilities are classified as false posi-tives if meet one of the following cases:    (cid:129) For SQL Injection vulnerabilities, if the er-ror/answer obtained is related to an application ro-bustness problem and not to a SQL command (e.g., a NumberFormatException). (cid:129) The error/value in the web service response is not caused by the elements "injected" by the scanner. In other words, the same problem occurs when the service is executed with valid inputs. (cid:129) For path and username/password disclosure, the information returned by the service is equal to the information submitted by the client (e.g., the vulne-rability scanner) when invoking the web service. In other words, there is no information disclosure. Detected vulnerabilities are classified as confirmed vulnerabilities if satisfy one of the next conditions:    1. For SQL Injection vulnerabilities, if it is possible to observe that the SQL command executed was inva-lidated by the values "injected" by the scanner (or manually). This is possible if the SQL command or part of it is included in the web service response (e.g., stack trace). 2. For SQL Injection vulnerabilities, if the “injected” values lead to exceptions raised by the database server. 3. If it is possible to access unauthorized services or web pages (e.g., by breaking the authentication process using SQL Injection).  4. For Path disclosure, if it is possible to observe the location of folders and files in the server. 5. For XPath Injection, if the “injected” values lead to exceptions raised by the XPath parser. 6. For Buffer Overflow, if the server does not answer to the request or raises an exception specifically re-lated to buffer overflow.  If none of these rules can be applied then there is no way to confirm whether a vulnerability really exists or not. These cases were classified as doubtful. Figure 2 shows the results for SQL Injection vulnerabilities.  As we can see, the number of vulnerabilities that we were not able to confirm (doubtful cases) is low for VS1.1, VS1.2, and VS3 (always less than 15%), but considerably high for VS2 (32%). This means that the false positive results are relatively accurate for the first three scanners, but it is an optimistic figure (zero false positives) for scanner VS2. Obviously, we can also read the false positives shown in Figure 2 as a range, Figure 1. SQL Injection vulnerabilities. Figure 2. False positives observed for SQL Injection.978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
570
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:58:23 UTC from IEEE Xplore.  Restrictions apply. 
    going from an optimistic value (false positives) to a pessimistic value (false positives + doubtful cases). The number of (confirmed) false-positives is high for scanners VS1.1 and VS1.2, and is also high for VS3, in relative terms. Scanner VS2 shows zero false positives, but it detected a fair percentage (8 out of 25) of vulnerabilities that were classified as doubtful, thus a pessimistic interpretation of results is that 8 out of 25 vulnerabilities may be false positives. Obviously, the low number of vulnerabilities detected by VS2 and VS3 (25 and 35 respectively) also limits the absolute number of false positives. Table 2 presents the false positive results for the other vulnerabilities. In this case, we were able to con-firm the existence (or inexistence) of all vulnerabilities and no doubts remained. An interesting aspect is that all XPath injection and Code Execution vulnerabilities were confirmed. On the other hand, all vulnerabilities related to username and password disclosure were in fact false positives (in all cases the username/password returned is equal to the one sent by the scanner).  Vulnerability Scanners ConfirmedF. P.XPath Injection VS1.1 & VS1.2 10 0 Code Execution VS1.1 & VS1.2 1 0 Buffer Overflow VS3 1 3 Username/Password Discl. VS3 0 47 Server Path Disclosure VS3 16 1 Table 2. False positives.  Figure 3 presents the SQL Injection vulnerabilities intersections after removing the false positives. The doubtful situations were in this case considered as ex-isting vulnerabilities (i.e., optimistic assumption from the point of view of scanners detection effectiveness). Results clearly show that, even if we manually remove the false positives, the four scanners still report differ-ent vulnerabilities. An interesting result is that three vulnerabilities were detected by VS1.1 and were not detected VS1.2 (the newer version of the scanner). The reverse also happens for 15 vulnerabilities, which is expectable as a newer version is expected to detected more vulnerabilities than an older one (but that should happen without missing any of the vulnerabilities iden-tified by the older version, which was not the case). This results called our attention and we tried to identify the reasons. After analyzing the detailed results we concluded that all of these 18 vulnerabilities are in the group of the doubtful ones (maybe they are really false positives, but we were not able to demonstrate that), preventing us from drawing a definitive conclusion.  3.3. Coverage analysis  A key aspect is to understand the coverage of the vulnerabilities detected. Coverage compares the num-ber of vulnerabilities detected against the total number of vulnerabilities. Obviously, in our case it is impossi-ble to know how many vulnerabilities were not dis-closed by any of the scanners (we do not have access to the source code). Thus, it is not possible to calculate the coverage. However, it is still possible to make a relative comparison based on the data available. In practice, we know the total number of vulnerabil-ities detected (which correspond to the union of the vulnerabilities detected by the four scanners after re-moving the false positives) and the number of vulnera-bilities detected by each individual scanner. Based on this information it is possible to get an optimistic cov-erage indicator for each scanner (i.e., the real coverage will be lower than the value presented). Obviously, this is relevant only for SQL Injection vulnerabilities as it is the only type that is detected by all the scanners. Table 3 presents the coverage results. As shown, 149 different SQL Injection vulnerabilities were de-tected (as before, we decided to include the doubtful situations as existing vulnerabilities). Each scanner detected a subgroup of these vulnerabilities, resulting in partial detection coverage. VS1.1 and VS1.2 present quite good results. On the other hand, the coverage of VS2 and VS3 is very low.  Scanner # SQL Injection Vuln. Coverage % VS1.1 130 87.2% VS1.2 142 95.3% VS2 25 16.8% VS3 26 17.4% Total 149 100.0% Table 3. Coverage for SQL Injection.  3.4. Lessons learned  The results presented before allowed us to observe some interesting aspects. The first observation is that different scanners detected different types of faults. SQL Injection was the only type that was detected by all scanners. The two scanners of the same brand (VS1.1 and VS1.2) were the only ones that detected Figure 3. SQL Injection vulnerabilities without FP. 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
571
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:58:23 UTC from IEEE Xplore.  Restrictions apply. 
    XPath and code execution vulnerabilities. Only one scanner (VS3) detected vulnerabilities related to buffer overflow, username and password disclosure, and server path disclosure. VS2 only detected SQL Injec-tion vulnerabilities. SQL Injection vulnerabilities are the dominant type in the web services tested (see Figure 4). However, different scanners detected different vulnerabilities of this type. In fact, VS1.1 and VS1.2 detected a huge number of vulnerabilities (215 and 225 respectively) while VS2 and VS3 detected a very low number (25 and 35 respectively). A key observation was a very large number of false positives. In fact, for three of the scanners the percen-tage of false positives was more than 25%. VS2 pre-sented zero false positives, but 32% (8 out of 25) of the SQL Injection vulnerabilities detected by this scanner remained as doubtful (i.e., could not be manually con-firmed as real vulnerabilities nor as false positives). A very low coverage, lower than 18%, was ob-served for two of the scanners (VS2 and VS3), while the other two scanners (VS1.1 and VS1.2) present a coverage superior to 87%. Note that this is an optimis-tic coverage, as the real coverage of the tested scanners (at least for the 300 web services used in the experi-ments) is definitely lower than the value observed. Figure 4 presents the final distribution of vulnera-bilities per type, after removing the false positives but including the doubtful cases (i.e., optimistic evaluation of the scanners). As the doubtful cases only affect the SQL Injection, it means that the number of SQL injec-tion vulnerabilities could be overestimated. Scanners have found 177 different vulnerabilities in 25 different services, which represent approximately 8.33% of the tested services (results for the individual services, in-cluding the distribution of the vulnerabilities found by web service can be obtained at [14]). As mentioned before, the predominant vulnerability is SQL Injection, representing 84.18% of the vulnerabilities found. This is a very important observation due to the high number of cases found and the high severity of this vulnerability.   Figure 4. Vulnerabilities distributed per type. 4. Conclusions  In this paper we presented an experimental study on using four commercial vulnerability scanners to detect security vulnerabilities in 300 publicly available web services, covering a diversity of technologies used to implement the web services and including services used in real business. A large number of vulnerabilities was observed, confirming that many services are dep-loyed without proper security testing.  Results showed that selecting a vulnerability scan-ner for web services is a very difficult task. First, dif-ferent scanners detect different types of vulnerabilities. Second, the number of false positives is quite high, which reduces the confidence on the precision of the vulnerabilities detected. Finally, the coverage is in some cases very low, suggesting that many vulnerabili-ties probably remain undetected. A final observation is that SQL Injection vulnerabilities are prevalent in the web services tested as they represent more than 84% of all vulnerabilities detected. Future research will focus on the development of an effective scanner for web services environments.  References  [1] D. A. Chappel, T. Jewell, “Java Web Services: Using Java in Service-Oriented Architectures”, O'Reilly. 2002 [2] E. Christensen et al., “Web Services Description Lan-guage (WSDL) 1.1”. 2001, W3C [3] Stock, A., Williams, J., Wichers, D., “OWASP top 10”, OWASP Foundation, July, 2007 [4] Stuttard, D., Pinto, M., “The Web Application Hacker's Handbook: Discovering and Exploiting Security Flaws”, Wiley, ISBN-10: 0470170778, October 2007 [5] FORTIFY - http://www.fortifysoftware.com/ [6] Ounce, http://www.ouncelabs.com/ [7] Pixy, http://pixybox.seclab.tuwien.ac.at/pixy/ [8] Acunetix Web Vulnerability Scanner, 2008, http://www.acunetix.com/vulnerability-scanner/ [9] IBM Rational AppScan, 2008, http://www-01.ibm.com/software/awdtools/appscan/ [10] HP WebInspect, 2008, http://www.hp.com [11] Foundstone WSDigger, 2008, http://www. foundstone.com/us/resources/proddesc/wsdigger.htm [12] wsfuzzer, 2008, http://www.neurofuzz.com/ modules/software/wsfuzzer.php  [13] Fonseca, J., Vieira, M., Madeira, H.,  "Testing and com-paring web vulnerability scanning tools for SQL injec-tion and XSS attacks", 13th IEEE Pacific Rim Depend-able Computing Conference (PRDC 2007), Melbourne, Victoria, Australia, December 2007 [14] Antunes, N., Vieira, M., Madeira, H., “Web Services Vulnerabilities”, 2008, http://eden.dei.uc.pt/~mvieira [15] Web Application Security Consortium, 2008, http://www.webappsec.org/projects/threat/classes_of_attack.shtml