 "github.ardanstudios.com/myproject/Godeps/_workspace/src/ 
    bitbucket.org/ww/goautoneg" 
05 
 "github.ardanstudios.com/myproject/Godeps/_workspace/src/ 
 github.com/beorn7/perks" 
06 ) 
在路径重写之前，import 语句使用的是包的正常路径。包对应的代码存放在 GOPATH 所指
定的磁盘目录里。在依赖管理之后，导入路径需要重写成工程内部依赖包的路径。可以看到这些
导入路径非常长，不易于使用。 
引入依赖管理将所有构建时依赖的源代码都导入到一个单独的工程代码库里，可以更容易地重
新构建工程。使用导入路径重写管理依赖包的另外一个好处是这个工程依旧支持通过 go get 获取
代码库。当获取这个工程的代码库时，go get 可以找到每个包，并将其保存到工程里正确的目录中。 
3.7.2  对 gb 的介绍 
gb 是一个由 Go 社区成员开发的全新的构建工具。gb 意识到，不一定要包装 Go 本身的工具，
也可以使用其他方法来解决可重复构建的问题。 
gb 背后的原理源自理解到 Go 语言的 import 语句并没有提供可重复构建的能力。import
语句可以驱动 go get，但是 import 本身并没有包含足够的信息来决定到底要获取包的哪个修
改的版本。go get 无法定位待获取代码的问题，导致 Go 工具在解决重复构建时，不得不使用
复杂且难看的方法。我们已经看到过使用 godep 时超长的导入路径是多么难看。
gb 的创建源于上述理解。gb 既不包装 Go 工具链，也不使用 GOPATH。gb 基于工程将 Go 工
具链工作空间的元信息做替换。这种依赖管理的方法不需要重写工程内代码的导入路径。而且导
入路径依旧通过 go get 和 GOPATH 工作空间来管理。
让我们看看上一节的工程如何转换为 gb 工程，如代码清单 3-12 所示。 
代码清单 3-12 gb 工程的例子
/home/bill/devel/myproject ($PROJECT) 
|-- src 
|   |-- cmd 
|   |   |-- myproject 
|   |   |   |-- main.go 
|   |-- examples 
|   |-- model 
|   |-- README.md 
|-- vendor 
 |-- src 
 |-- bitbucket.org 
 |   |-- ww 
 | 
 |-- goautoneg 
 | 
 |-- Makefile 
 | 
 |-- README.txt 
 | 
 |-- autoneg.go 
 | 
 |-- autoneg_test.go 
 |-- github.com 
 |-- beorn7 
 |-- perks 
 |-- README.md 
 |-- quantile 
 |-- bench_test.go 
 |-- example_test.go 
 |-- exampledata.txt 
 |-- stream.go 
一个 gb 工程就是磁盘上一个包含 src/子目录的目录。符号$PROJECT 导入了工程的根目
录中，其下有一个 src/的子目录中。这个符号只是一个简写，用来描述工程在磁盘上的位置。
$PROJECT 不是必须设置的环境变量。事实上，gb 根本不需要设置任何环境变量。
gb 工程会区分开发人员写的代码和开发人员需要依赖的代码。开发人员的代码所依赖的代
码被称作第三方代码（vendored code）。gb 工程会明确区分开发人员的代码和第三方代码，如代
码清单 3-13 和代码清单 3-14 所示。 
代码清单 3-13 工程中存放开发人员写的代码的位置 
$PROJECT/src/ 
代码清单 3-14 存放第三方代码的位置 
$PROJECT/vendor/src/ 
gb 一个最好的特点是，不需要重写导入路径。可以看看这个工程里的 main.go 文件的 import
语句——没有任何需要为导入第三方库而做的修改，如代码清单 3-15 所示。 
代码清单 3-15 gb 工程的导入路径 
01 package main 
02 
03 import ( 
04 
 "bitbucket.org/ww/goautoneg" 
05 
 "github.com/beorn7/perks" 
06 ) 
gb 工具首先会在$PROJECT/src/目录中查找代码，如果找不到，会在$PROJECT/vender/src/
目录里查找。与工程相关的整个源代码都会在同一个代码库里。自己写的代码在工程目录的 src/
目录中，第三方依赖代码在工程目录的 vender/src 子目录中。这样，不需要配合重写导入路
径也可以完成整个构建过程，同时可以把整个工程放到磁盘的任意位置。这些特点，让 gb 成为
社区里解决可重复构建的流行工具。 
还需要提一点：gb 工程与 Go 官方工具链（包括 go get）并不兼容。因为 gb 不需要设置
GOPATH，而 Go 工具链无法理解 gb 工程的目录结构，所以无法用 Go 工具链构建、测试或者获
取代码。构建（如代码清单 3-16 所示）和测试 gb 工程需要先进入$PROJECT 目录，并使用 gb
工具。 
代码清单 3-16 构建 gb 工程 
gb build all 
很多 Go 工具支持的特性，gb 都提供对应的特性。gb 还提供了插件系统，可以让社区扩展
支持的功能。其中一个插件叫作 vender。这个插件可以方便地管理$PROJECT/vender/src/
目录里的依赖关系，而这个功能 Go 工具链至今没有提供。想了解更多 gb 的特性，可以访问这
个网站：getgb.io。 
3.8  小结 
在 Go 语言中包是组织代码的基本单位。
环境变量 GOPATH 决定了 Go 源代码在磁盘上被保存、编译和安装的位置。
可以为每个工程设置不同的 GOPATH，以保持源代码和依赖的隔离。
go 工具是在命令行上工作的最好工具。
开发人员可以使用 go get 来获取别人的包并将其安装到自己的 GOPATH 指定的目录。
想要为别人创建包很简单，只要把源代码放到公用代码库，并遵守一些简单规则就可以了。 
Go 语言在设计时将分享代码作为语言的核心特性和驱动力。
推荐使用依赖管理工具来管理依赖。
有很多社区开发的依赖管理工具，如 godep、vender 和 gb。
第 4 章 数组、切片和映射 
本章主要内容 
数组的内部实现和基础功能
使用切片管理数据集合
使用映射管理键值对
很难遇到要编写一个不需要存储和读取集合数据的程序的情况。如果使用数据库或者文件，
或者访问网络，总需要一种方法来处理接收和发送的数据。Go 语言有 3 种数据结构可以让用户
管理集合数据：数组、切片和映射。这 3 种数据结构是语言核心的一部分，在标准库里被广泛使
用。一旦学会如何使用这些数据结构，用 Go 语言编写程序会变得快速、有趣且十分灵活。 
4.1  数组的内部实现和基础功能 
了解这些数据结构，一般会从数组开始，因为数组是切片和映射的基础数据结构。理解了数
组的工作原理，有助于理解切片和映射提供的优雅和强大的功能。 
4.1.1  内部实现 
在 Go 语言里，数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连
续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。 
在图 4-1 中可以看到数组的表示。灰色格子代表数组里的元素，每个元素都紧邻另一个元素。
每个元素包含相同的类型，这个例子里是整数，并且每个元素可以用一个唯一的索引（也称下标
或标号）来访问。 
数组是一种非常有用的数据结构，因为其占用的内存是连续分配的。由于内存连续，CPU
能把正在使用的数据缓存更久的时间。而且内存连续很容易计算索引，可以快速迭代数组里的所
有元素。数组的类型信息可以提供每次访问一个元素时需要在内存中移动的距离。既然数组的每
个元素类型相同，又是连续分配，就可以以固定速度索引数组中的任意数据，速度非常快。 
4
第 4 章 数组、切片和映射 
图 4-1  数组的内部实现 
4.1.2  声明和初始化 
声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为
数组的长度，如代码清单 4-1 所示。 
代码清单 4-1 声明一个数组，并设置为零值 
// 声明一个包含 5 个元素的整型数组 
var array [5]int 
一旦声明，数组里存储的数据类型和数组长度就都不能改变了。如果需要存储更多的元素，
就需要先创建一个更长的数组，再把原来数组里的值复制到新数组里。 
在 Go 语言中声明变量时，总会使用对应类型的零值来对变量进行初始化。数组也不例外。
当数组初始化时，数组内每个元素都初始化为对应类型的零值。在图 4-2 里，可以看到整型数组
里的每个元素都初始化为 0，也就是整型的零值。 
图 4-2  声明数组变量后数组的值 
一种快速创建数组并初始化的方式是使用数组字面量。数组字面量允许声明数组里元素的数
量同时指定每个元素的值，如代码清单 4-2 所示。 
代码清单 4-2 使用数组字面量声明数组 
// 声明一个包含 5 个元素的整型数组 
// 用具体值初始化每个元素 
array := [5]int{10, 20, 30, 40, 50} 
如果使用...替代数组的长度，Go 语言会根据初始化时数组元素的数量来确定该数组的长
度，如代码清单 4-3 所示。 
代码清单 4-3 让 Go 自动计算声明数组的长度 
// 声明一个整型数组 
// 用具体值初始化每个元素 
// 容量由初始化值的数量决定 
array := [...]int{10, 20, 30, 40, 50} 
如果知道数组的长度而是准备给每个值都指定具体值，就可以使用代码清单 4-4 所示的这种
语法。 
代码清单 4-4 声明数组并指定特定元素的值 
// 声明一个有 5 个元素的数组 
// 用具体值初始化索引为 1 和 2 的元素 
// 其余元素保持零值 
array := [5]int{1: 10, 2: 20} 
代码清单 4-4 中声明的数组在声明和初始化后，会和图 4-3 所展现的一样。 
图 4-3  声明之后数组的值 
4.1.3  使用数组 
正像之前提到的，因为内存布局是连续的，所以数组是效率很高的数据结构。在访问数组里
任意元素的时候，这种高效都是数组的优势。要访问数组里某个单独元素，使用[]运算符，如
代码清单 4-5 所示。 
代码清单 4-5 访问数组元素 
// 声明一个包含 5 个元素的整型数组 
// 用具体值初始为每个元素 
array := [5]int{10, 20, 30, 40, 50} 
// 修改索引为 2 的元素的值 
array[2] = 35 
代码清单 4-5 中声明的数组的值在操作完成后，会和图 4-4 所展现的一样。 
图 4-4  修改索引为 2 的值之后数组的值 
可以像第 2 章一样，声明一个所有元素都是指针的数组。使用*运算符就可以访问元素指针
所指向的值，如代码清单 4-6 所示。 
代码清单 4-6 访问指针数组的元素 
// 声明包含 5 个元素的指向整数的数组 
// 用整型指针初始化索引为 0 和 1 的数组元素 
array := [5]*int{0: new(int), 1: new(int)} 
// 为索引为 0 和 1 的元素赋值 
*array[0] = 10
*array[1] = 20
代码清单 4-6 中声明的数组的值在操作完毕后，会和图 4-5 所展现的一样。 
图 4-5  指向整数的指针数组 
在 Go 语言里，数组是一个值。这意味着数组可以用在赋值操作中。变量名代表整个数组，
因此，同样类型的数组可以赋值给另一个数组，如代码清单 4-7 所示。 
代码清单 4-7 把同样类型的一个数组赋值给另外一个数组 
// 声明第一个包含 5 个元素的字符串数组 
var array1 [5]string 
// 声明第二个包含 5 个元素的字符串数组 
// 用颜色初始化数组 
array2 := [5]string{"Red", "Blue", "Green", "Yellow", "Pink"} 
// 把 array2 的值复制到 array1 
array1 = array2 
复制之后，两个数组的值完全一样，如图 4-6 所示。 
图 4-6  复制之后的两个数组 
数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相
同的数组，才能互相赋值，如代码清单 4-8 所示。 
代码清单 4-8 编译器会阻止类型不同的数组互相赋值 
// 声明第一个包含 4 个元素的字符串数组 
var array1 [4]string 
// 声明第二个包含 5 个元素的字符串数组 
// 使用颜色初始化数组 
array2 := [5]string{"Red", "Blue", "Green", "Yellow", "Pink"} 
// 将 array2 复制给 array1 
array1 = array2 
Compiler Error: 
cannot use array2 (type [5]string) as type [4]string in assignment 
复制数组指针，只会复制指针的值，而不会复制指针所指向的值，如代码清单 4-9 所示。 
代码清单 4-9 把一个指针数组赋值给另一个 
// 声明第一个包含 3 个元素的指向字符串的指针数组 
var array1 [3]*string 
// 声明第二个包含 3 个元素的指向字符串的指针数组 
// 使用字符串指针初始化这个数组 
array2 := [3]*string{new(string), new(string), new(string)} 
// 使用颜色为每个元素赋值 
*array2[0] = "Red"
*array2[1] = "Blue"
*array2[2] = "Green"
// 将 array2 复制给 array1 
array1 = array2 
复制之后，两个数组指向同一组字符串，如图 4-7 所示。 
图 4-7  两组指向同样字符串的数组 
4.1.4  多维数组 
数组本身只有一个维度，不过可以组合多个数组创建多维数组。多维数组很容易管理具有父
子关系的数据或者与坐标系相关联的数据。声明二维数组的示例如代码清单 4-10 所示。 
代码清单 4-10 声明二维数组 
// 声明一个二维整型数组，两个维度分别存储 4 个元素和 2 个元素 
var array [4][2]int 
// 使用数组字面量来声明并初始化一个二维整型数组 
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}} 
// 声明并初始化外层数组中索引为 1 个和 3 的元素 
array := [4][2]int{1: {20, 21}, 3: {40, 41}} 
// 声明并初始化外层数组和内层数组的单个元素 
array := [4][2]int{1: {0: 20}, 3: {1: 41}} 
图 4-8 展示了代码清单 4-10 中声明的二维数组在每次声明并初始化后包含的值。 
图 4-8  二维数组及其外层数组和内层数组的值 
为了访问单个元素，需要反复组合使用[]运算符，如代码清单 4-11 所示。 
代码清单 4-11 访问二维数组的元素 
// 声明一个 2×2 的二维整型数组 
var array [2][2]int 
// 设置每个元素的整型值 
array[0][0] = 10 
array[0][1] = 20 
array[1][0] = 30 
array[1][1] = 40 
只要类型一致，就可以将多维数组互相赋值，如代码清单 4-12 所示。多维数组的类型包括每
一维度的长度以及最终存储在元素中的数据的类型。 
代码清单 4-12 同样类型的多维数组赋值 
// 声明两个不同的二维整型数组 
var array1 [2][2]int 
var array2 [2][2]int 
// 为每个元素赋值 
array2[0][0] = 10 
array2[0][1] = 20 
array2[1][0] = 30 
array2[1][1] = 40 
// 将 array2 的值复制给 array1 
array1 = array2 
因为每个数组都是一个值，所以可以独立复制某个维度，如代码清单 4-13 所示。 
代码清单 4-13 使用索引为多维数组赋值 
// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里 
var array3 [2]int = array1[1] 
// 将外层数组的索引为 1、内层数组的索引为 0 的整型值复制到新的整型变量里 
var value int = array1[1][0] 
4.1.5  在函数间传递数组 
根据内存和性能来看，在函数间传递数组是一个开销很大的操作。在函数之间传递变量时，
总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复
制，并传递给函数。 
为了考察这个操作，我们来创建一个包含 100 万个 int 类型元素的数组。在 64 位架构上，
这将需要 800 万字节，即 8 MB 的内存。如果声明了这种大小的数组，并将其传递给函数，会发
生什么呢？如代码清单 4-14 所示。 
代码清单 4-14 使用值传递，在函数间传递大数组 
// 声明一个需要 8 MB 的数组 
var array [1e6]int 
// 将数组传递给函数 foo 
foo(array) 
// 函数 foo 接受一个 100 万个整型值的数组 
func foo(array [1e6]int) { 
 ... 
} 
每次函数 foo 被调用时，必须在栈上分配 8 MB 的内存。之后，整个数组的值（8 MB 的内