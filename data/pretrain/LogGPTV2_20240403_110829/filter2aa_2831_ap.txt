If you look at the resources for an ATL wizard generated server,
you’ll see a section that contains registry entries. 
These resources are used to identify a new type of registry
script. If you look in the file list of the project you’ll see a file
with the extension “RGS” for each of these entries. Double click
on these “REGISTRY” resources and you’ll see that they are text
file containing the server’s registration commands. 
This file will be used to automatically update the registry
entries for the server. You may be familiar with “REG” scripts
used with the REGEDIT application -- the RGS scripts are used
by a completely different application. The server’s ATL classes
implement a special COM interface called IRegister. This inter-
face executes the scripts. IRegister has a limited ability to add,
delete, and make simple text substitutions. Here’s an example of
one of the RGS files.
Figure 11–6
Registry resources produced by ATL
176    Chapter 11 •
The COM Registry 
HKCR
{
    BasicTypes.BasicTypes.1 = s ‘BasicTypes Class’
{
        CLSID = s ‘{543FB20E-6281-11D1-BD74-
204C4F4F5020}’
    }
    BasicTypes.BasicTypes = s ‘BasicTypes Class’
    {
        CurVer = s ‘BasicTypes.BasicTypes.1’
    }
    NoRemove CLSID
    {
        ForceRemove 
{543FB20E-6281-11D1-BD74-204C4F4F5020} = 
                     s ‘BasicTypes Class’
        {
            ProgID = s ‘BasicTypes.BasicTypes.1’
            VersionIndependentProgID = 
s ‘BasicTypes.BasicTypes’
            LocalServer32 = s ‘%MODULE%’
            val AppID = 
s ‘{543FB201-6281-11D1-BD74-204C4F4F5020}’
        }
    }
}
The syntax here is straightforward. HKCR stands for
HKEY_CLASSES_ROOT. It immediately creates two entries for
BasicTypes.BasicTypes, and BasicTypes.BasicTypes.1. If you
look under HKEY_CLASSES_ROOT, you’ll see these entries.
The script also writes information into the CLSID key of the
registry. Under CLSID, the script will write a key for the GUID,
and several significant sub-keys such as LocalServer32.  Remem-
ber that this script works for both registration and unregistration.
The “NoRemove” keyword tells it not to delete the CLSID branch
when the server unregisters.
Automatic Registration of Remote Servers
177
Additonal Information and Updates: http://www.iftech.com/dcom
Automatic Registration of Remote Servers
If the server runs as an EXE or service, the registration is accom-
plished with a special startup command:
 MyServer - RegServer
Let’s look at the code ATL generates. The following was
taken from the WinMain function of the IDLTEST server from
chapter 6, IdlTest.CPP.
if (lstrcmpi(lpszToken, _T(“RegServer”))==0)
{
_Module.UpdateRegistryFromResource(IDR_IdlTest, 
TRUE);
nRet = _Module.RegisterServer(TRUE);
bRun = FALSE;
break;
}
 When the server is run from the command line, it checks
for the “RegServer” command. This command tells the server to
write its settings into the registry and exit immediately. In this
example object _Module is an ATL class of type CComModule. 
The first function called is UpdateRegistryFromResource(). If
you step into this module you’ll see some familiar COM behav-
ior. This CComModule class calls CoCreateInstance on the IReg-
ister interface, then calls a method named ResourceRegister,
passing in the ID of the RGS file’s resource. 
The unregistration is simply a mirror image of registration.
The server is invoked with a command line of “UnRegserver”.
Note the boolean FALSE passed into UpdateRegistryFromRe-
source(). Here’s the source from the server main routine:
if (lstrcmpi(lpszToken, _T(“UnregServer”))==0)
{
_Module.UpdateRegistryFromResource(IDR_IdlTest, 
FALSE);
nRet = _Module.UnregisterServer();
178    Chapter 11 •
The COM Registry 
bRun = FALSE;
break;
}
In-Process Servers
Servers implemented as DLL’s have a different registration
scheme. Each COM DLL must contain two exported functions for
server registration. These are DllRegisterServer and DllUnreg-
isterServer. These functions implement the same registration
functions as a remote COM server.
Because you can’t directly run a DLL, registration is handled
somewhat differently. Windows provides a utility called
REGSVR32, which can register a DLL. The way REGSVR32 works
is that it finds and loads the DLL containing the In-Process server,
then calls the DllRegisterServer function. This is the same utility
that we have used to register Proxy/Stub DLL’s.  It is executed
automatically as part of the build process, or you can run it man-
ually.
Using the Registry API
How you accomplish the registration of components is your own
business. If you like doing things the old-fashioned way, you can
skip the RGS files and directly call the registry API functions.
These consist of functions like RegCreateKey() and
RegDeleteValue(). In the old days of COM this is how all server
registration was accomplished. If you’re not familiar with these
functions they can be somewhat counterintuitive. The help files
describe how to use these functions. 
Summary
COM uses the registry as an storage area for all information
releated to COM servers and interfaces. When a COM client
Summary
179
Additonal Information and Updates: http://www.iftech.com/dcom
wants to access a COM server, the operating system uses the
information in the registry to find, start and control the server. By
becoming familiar with the information in the registry, you
improve your ability to understand and debug COM applications. 
The registry is also one of the areas responsible for many
COM errors. For example, if a server does not properly self-regis-
ter, then the client will not be able to activate it. See the error-
handling appendix, which discusses many of the problems that
can occur in the registry.
180    Chapter 11 •
The COM Registry 
T
W
E
L
V
E
12
Callback 
Interfaces   
So far, all the interfaces we’ve seen are strictly one directional - a
client program connects to a COM server and calls its methods.
Most COM interfaces are driven entirely by the client. The client
makes the connection, uses the connection, and shuts it down
when finished. This works great for simple methods that com-
plete relatively quickly.
For more complex server applications, this client driven
design can break down. Often the server needs to send
responses to the client. For example, a server may need to notify
the client whenever some asynchronous event takes place. 
An example of this would be a server that generates reports.
These reports are created from a database, require extensive
searches, and make lengthy calculations. The client GUI program
would call a method on the server called DoReport. The
DoReport method might take several minutes to complete.
Meanwhile, the client GUI would be stalled, waiting for the
report to complete. Obviously, this is a poor design. 
A better solution would be for the client GUI to call a
method named StartReport which causes the server to spawn a
worker thread that handles the lengthy report generation. Star-
tReport would start the worker thread and return as soon as it
was started. The client could then do other work, such as dis-
182    Chapter 12 •
Callback Interfaces 
playing progress. After several minutes, the server would tell the
client GUI that it was finished. The client GUI would call a
method named GetReportData, and display the complete report.
The simplest way to do this is for the client program to con-
stantly poll the server. 
BOOL IsReady;
// Start a worker thread on the server
pI->StartReport();
// Check if report is done
pI->CheckReport( &IsReady );
while(IsReady == FALSE)
{
Sleep( 60000 );// wait 1 minute
pI-> CheckReport ( &IsReady ) )// poll the server
}
// get the report
pI->GetReport( &data )
There are three problems with this code. First, there is
potentially a minute delay before the event is processed
(because of the duration of the Sleep statement). The second
problem is efficiency. You can shorten the Sleep delay at the
expense of efficiency. For remote network connections this
could mean expensive and unnecessary network traffic. The fun-
damental trade off is between responsiveness and efficiency. If
you can afford the waiting, this is a simple way to design an
interface.
A more efficient way to design this program is for the server
to make a COM connection back to the client. When the server
finishes processing, it immediately notifies the client. There are
two ways to do this - custom callback interfaces and connection
points. In essence, we will use COM to create an asynchronous
link from the server to the client.
Client and Server Confusion
183
Additonal Information and Updates: http://www.iftech.com/dcom
While conceptually simple, the implementation of this bi-
directional design can be complex. After debugging a bi-direc-
tional client and server, you may reconsider the polling interface
shown above. 
This chapter covers the simpler of the two - custom call-
backs. Connection Points are more flexible, but considerably
more complex and are discussed in the following chapter. Both
of these techniques have advantages and disadvantages in spe-
cific situations.
Client and Server Confusion
Before we embark on further explanation, here are a few words
of caution. This subject can be quite confusing. It is difficult to
keep track of clients and servers. The concepts aren’t all that
complicated, but they are hard to track mentally. 
While the diagrams are relatively simple, the description can
be difficult. The basic problem is this: each object is both a COM
client and a COM server. The labels “client” and “server” have lit-
tle meaning in this context. 
Another point of distraction is the implementation of call-
backs. To demonstrate this concept, we will need both a server
and client application. Because the two are closely tied together,
we can’t explain one without explaining both. The actual call-
back interface is extremely simple, but the interaction is com-
plex.
Custom Callback Interfaces
A callback is simply a function on the client that is called by the
server. In COM, it’s perfectly OK for a client application to also
expose COM objects. The server can connect back to a client
object. This does blur the distinction between client and server.
184    Chapter 12 •
Callback Interfaces 
 The COM/OLE world uses the terms ‘source’ and ‘sink’ to
describe bi-directional interfaces. In the above diagram, the cli-
ent application has a sink interface. This interface is used by the
server application to notify its caller. The source is a source of
events. In other words, it’s an object that makes the connection
back to the client application. The source connects to the sink.
We are going to build a dialog-based client program called
‘CallbackClient’ that implements a COM interface. We’ll also
design a server which implements an interface allowing the cli-
ent to ‘register’ itself. Once the client is registered, the server has
a way to connect back to it.  
In the COM vocabulary, registering a callback interface with
the server is often called an “Advise”. Basically, the Advise()
method makes a copy of the client’s callback interface, and
stores it for later use. When the client disconnects, it “un-advises”
its callback.
In Figure 2, Notice that the CCallBack object, and its inter-
face, are inside the callback Client Application box. They also
have dashed lines. It was drawn this way to show that ICallBack
interface is not exposed to the outside world. Unlike most COM
objects, this Object cannot be connected through a normal call to
CoCreateInstance(). The only way for the Callback Server to get
this object pointer is when the client explicitly passes it to the
server. We’ll see how this is done in the example.
Figure 12–1
With a callback, the server can talk back to the client
Client
Application
Callback Interface
Server
Applicaiton
Primary Interface
A Callback Example
185
Additonal Information and Updates: http://www.iftech.com/dcom
A Callback Example
Here is an outline of the steps we’ll follow to implement the
server object. We’ll describe each step in more detail below.
1. Create a COM Server using the ATL Wizard. Name the server
CallbackServer. 
2. Add a COM object to the server. Name the object Simple-
Callback. Use the ATL object wizard. 
3. Add the definition of a COM interface named ICallBack to
the IDL code for the server. Note that we won’t be imple-
menting the ICallBack interface in the server, we’re just add-
ing a definition. 
4. Add four methods to the ISimpleCallback interface on the
server: Advise(), UnAdvise(), Now() and Later()
Create the Server
First we’ll define the CCallbackServer server program. There’s
nothing special about this server. Use the wizard to create an
ATL COM AppWizard project. You could implement the server
either as an in-process server, or an EXE based server. Note that
an EXE server is slightly more complex to build, and also harder
to debug. 
Figure 12–2
The relationship between server and client when a callback is 
used. Note that a COM server to handle the callback is embed-
ded within the client. 
ICallback
ISimpleCallback
CSimpleCallback
Object
Server
CallbackClient
CCallback
Object
186    Chapter 12 •
Callback Interfaces 
The sample code was built as an EXE server. These tech-
niques work with any type of server - it will work just as well as
a service or a DLL.
Add a COM Object to the Server
Add a COM object to the server using the ATL Object Wizard.
Select a simple COM object. Give it the name SimpleCallback.
On the attributes page select the following:
• Apartment threading model.
• Custom Interface. (Dual would also work)
• Either yes or no for aggregation.
 Note that the “Support Connection Points” option is com-
pletely unnecessary for a custom callback method. We’ll use this
option in a later section when we add a Connection Point in the
next chapter.
Next we’ll add four methods: Advise(), UnAdvise(), Now(),
and Later(). Look in the file CallbackServer.IDL. The wizard gen-
erated MIDL definitions have an interface that looks like the fol-
lowing code. I’ve stripped out some extraneous material, and of
course, the GUID’s will be different.
 [
    object,
    uuid(B426A80D-50E9-11D2-85DA-004095424D9A),
    helpstring(“ISimpleCallback Interface”),
    pointer_default(unique)
]
interface ISimpleCallback : Iunknown
{
    HRESULT Advise([in] ICallBack *pICallback, 
[out] long *lCookie);
    HRESULT UnAdvise([in] long lCookie);
    HRESULT Now([in] long lCode);
    HRESULT Later([in] long lSeconds);
};
 Don’t laugh about the cookies. We’ll explain how they are
used later.
Adding the ICallBack Interface to IDL
187
Additonal Information and Updates: http://www.iftech.com/dcom
Adding the ICallBack Interface to IDL 
Next, we’ll add the callback interface definition to the IDL code
of the server. The callback interface will not be implemented by
this server. We will write the callback interface when we write
the Client application. We are just going to add the IDL code.
Although we’re not implementing this interface, the server needs
its definition. 
We can’t use the ATL Object Wizard, because it will also add
the CPP and H files. We’re using MIDL as a convenient way to
generate header definitions. We’ll include the headers in the cli-
ent program. 
Type in the following definition to the CallbackServer.IDL
file. Put it near the top of the file where it’s easy to find, just
above the definition of the ISimpleCallback interface.
// implemented on the client only
[
object,
uuid(B426A80D-50EA-11D2-85DA-004095424D9A),
helpstring(“ICallBack Interface”),
]
interface ICallBack : Iunknown
{
HRESULT Awake( long lVal );
};
 Modify the Header
Now we’ll modify the CSimpleCallback object and add two
member variables. We’ll add a cookie and an ICallBack interface
pointer to the class definition. Find CSimpleCallback in the
header file SIMPLECALLBACK.H. Add these two variables to the
public part of the class definition.
long m_lCookie;
ICallBack *m_ICallBack;
188    Chapter 12 •
Callback Interfaces 
Adding the Advise Method to the Server
Now we’ll add code to SimpleCallback.CPP. The first method
we’ll add is Advise(). The purpose of this method is to save a
pointer to the client’s callback interface. The client program will
call this method, passing in a pointer to its callback interface.
Note that the client is responsible for creating the ICallBack
interface pointer - we’re NOT going to call CoCreateInstance.
// Register the callback
STDMETHODIMP CSimpleCallback::Advise(ICallBack 
*pICallback, long *lCookie)
{
// Save the pointer
m_ICallBack = pICallback;
// keep the interface alive by calling AddRef
m_ICallBack->AddRef();
 // Make up a cookie with a semi-unique number
*lCookie = (long)this ;
m_lCookie = *lCookie;
 return S_OK;
}
The client passes in a pointer to its own COM interface. This
method will do an AddRef() on the callback interface, and save
the ICallBack COM pointer. All AddRef is going to do is incre-
ment the ICallBack interface reference count. 
Notice that the client passed us an ICallBack interface.
There is no ambiguity here - this method only accepts ICallBack
interfaces. When we use connection points later, we’ll see that
they are more flexible. 
Finally, we get to the cookie. You may already be familiar
with Internet cookies - COM cookies are somewhat different.
The cookie is a unique ID that the server retains to keep track of
connected clients. The server will use this value later, when it
needs to close down the connection. We’ve used the this pointer
for a semi-unique number. The cookie only has to be unique
within the context of our server.
Adding the UnAdvise Method
189
Additonal Information and Updates: http://www.iftech.com/dcom
The only purpose of the cookie is to ensure that the client
un-advises the same interface it advised. This is an unnecessary
check in this example program, but more complex servers may