double alignment: 8
&dx: 0x7fff5fbff660
&ca: 0x7fff5fbff65f
&cx: 0x7fff5fbff65e
&dz: 0x7fff5fbff650
&cb: 0x7fff5fbff64f
&cz: 0x7fff5fbff648
在我们的系统中，double的对齐值是8，这意味着地址的类型对齐可以
被8整除。以0或8结尾的十六进制地址可被8整除。这就是地址常用两个
double类型的变量和char类型的变量cz（该变量是double对齐值）。因为char
的对齐值是1，对于普通的char类型变量，编译器可以使用任何地址。
在程序中包含 stdalign.h 头文件后，就可以把 alignas 和 alignof 分别作为
_Alignas 和_Alignof的别名。这样做可以与C++关键字匹配。
1184
C11在stdlib.h库还添加了一个新的内存分配函数，用于对齐动态分配的
内存。该函数的原型如下：
void *aligned_alloc(size_t alignment, size_t size);
第1个参数代表指定的对齐，第2个参数是所需的字节数，其值应是第1
个参数的倍数。与其他内存分配函数一样，要使用free()函数释放之前分配
的内存。
1185
15.6 关键概念
C 区别于许多高级语言的特性之一是访问整数中单独位的能力。该特性
通常是与硬件设备和操作系统交互的关键。
C有两种访问位的方法。一种方法是通过按位运算符，另一种方法是在
结构中创建位字段。
C11新增了检查内存对齐要求的功能，而且可以指定比基本对齐值更大
的对齐值。
通常（但不总是），使用这些特性的程序仅限于特定的硬件平台或操作
系统，而且设计为不可移植的。
1186
15.7 本章小结
计算硬件与二进制记数系统密不可分，因为二进制数的1和0可用于表示
计算机内存和寄存器中位的开闭状态。虽然C不允许以二进制形式书写数
字，但是它识别与二进制相关的八进制和十六进制记数法。正如每个二进制
数字表示1位一样，每个八进制位代表3位，每个十六进制位代表4位。这种
关系使得二进制转为八进制或十六进制较为简单。
C 提供多种按位运算符，之所以称为按位是因为它们单独操作一个值中
的每个位。～运算符将其运算对象的每一位取反，将1转为0，0转为1。按位
与运算符（&）通过两个运算对象形成一个值。如果两运算对象中相同号位
都为1，那么该值中对应的位为1；否则，该位为0。按位或运算符（|）同样
通过两个运算对象形成一个值。如果两运算对象中相同号位有一个为1或都
为1，那么该值中对应的位为1；否则，该位为0。按位异或运算符（^）也有
类似的操作，只有两运算对象中相同号位有一个为1时，结果值中对应的位
才为1。
C还有左移（>）运算符。这两个运算符使位组合中的所
有位都向左或向右移动指定数量的位，以形成一个新值。对于左移运算符，
空出的位置设为 0。对于右移运算符，如果是无符号类型的值，空出的位设
为0；如果是有符号类型的值，右移运算符的行为取决于实现。
可以在结构中使用位字段操控一个值中的单独位或多组位。具体细节因
实现而异。
可以使用_Alignas强制执行数据存储区上的对齐要求。
这些位工具帮助C程序处理硬件问题，因此它们通常用于依赖实现的场
合中。
1187
15.8 复习题
复习题的参考答案在附录A中。
1.把下面的十进制转换为二进制：
a.3
b.13
c.59
d.119
2.将下面的二进制值转换为十进制、八进制和十六进制的形式：
a.00010101
b.01010101
c.01001100
d.10011101
3.对下面的表达式求值，假设每个值都为8位：
a.～3
b.3 & 6
c.3 | 6
d.1 | 6
e.3 ^ 6
f.7 >> 1
1188
g.7  0)
{
mask |= bitval;
bitval  0)
1189
{
mask += bitval;
bitval *= 2;
}
程序照常工作。这是否意味着*=2等同于
#define TWO 2   /* 可以使用注释 */
#define OW "Consistency is the last refuge of the unimagina\
tive.- Oscar Wilde" /* 反斜杠把该定义延续到下一行 */
#define FOUR TWO*TWO
#define PX printf("X is %d.\n", x)
#define FMT "X is %d.\n"
int main(void)
{
1198
int x = TWO;
PX;
x = FOUR;
printf(FMT, x);
printf("%s\n", OW);
printf("TWO: OW\n");
return 0;
}
每行#define（逻辑行）都由3部分组成。第1部分是#define指令本身。第
2部分是选定的缩写，也称为宏。有些宏代表值（如本例），这些宏被称为
类对象宏（object-like 
macro）。C 
语言还有类函数宏（function-like
macro），稍后讨论。宏的名称中不允许有空格，而且必须遵循C变量的命
名规则：只能使用字符、数字和下划线（_）字符，而且首字符不能是数
字。第3部分（指令行的其余部分）称为替换列表或替换体（见图16.1）。
一旦预处理器在程序中找到宏的示实例后，就会用替换体代替该宏（也有例
外，稍后解释）。从宏变成最终替换文本的过程称为宏展开（macro
expansion）。注意，可以在#define行使用标准C注释。如前所述，每条注释
都会被一个空格代替。
1199
图16.1 类对象宏定义的组成
运行该程序示例后，输出如下:
X is 2.
X is 4.
Consistency is the last refuge of the unimaginative.- Oscar Wilde
TWO: OW
下面分析具体的过程。下面的语句：
int x = TWO;
变成了：
int x = 2;
2代替了TWO。而语句：
PX;
变成了：
printf("X is %d.\n", x);
这里同样进行了替换。这是一个新用法，到目前为止我们只是用宏来表
示明示常量。从该例中可以看出，宏可以表示任何字符串，甚至可以表示整
个 C 表达式。但是要注意，虽然 PX 是一个字符串常量，它只打印一个名为
x的变量。
下一行也是一个新用法。读者可能认为FOUR被替换成4，但是实际的