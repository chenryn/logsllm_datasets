be exchanged for the ability to register a new public key. To
implement this system, we add two additional protocols to
those presented above: Get signed mailbox key and Open a
mailbox.
In Get signed mailbox key, a user Ps authenticates to the
service provider with their long-term identity pks and uses a
blind signature scheme to obliviously get a signature σes over
fresh public key pkes. We denote the service provider’s keypair
(pksign, sksign). In Open a mailbox, a user Ps anonymously
connects to the service provider and presents (pkes, σes). If
σes is valid and the service provider has never seen the public
key pkes before, the service provider opens a mailbox for the
public key pkes. These protocols are described below:
Get signed mailbox key
1) User authenticates using their longterm public key. Server
checks that the client has not exceeded their quota of
generated ephemeral identities.
2) Client generates (pke, ske) ← Πssenc.SSKeyGen(1λ)
3) Client
public
key
b ← Πbs.BSBlind(pke, pksign; r) with r ← {0, 1}λ.
4) Server signs the client’s blinded public key with sblind ←
Πbs.BSSign(b, sksign) and returns the blinded signature to
the client.
5) Client extracts the real signature locally with σe ←
ephemeral
blinds
the
Πbs.BSExtract(sblind, pksign; r)
Open a mailbox
1) Client connects anonymously to the server and sends
pke, σe
2) Server veriﬁes Πbs.BSVerify(pksign, σe) = 1 and checks
pke has not been used yet.
3) Server registers an anonymous mailbox with key pke with
an expiration date.
Integrating these protocols into one-way sealed sender
conversations and two-way sealed sender conversations is
straightforward. At the beginning of each time period (e.g. a
day), users run Get signed mailbox key up to k times, where
k is an arbitrary constant ﬁxed by the system. Then, whenever
a user needs to open a mailbox, they run the Open a mailbox
protocol. Sending and receiving messages proceeds as before.
that (1) the signing key for the blind
signature scheme public key pksign be updated regularly, and
(2) anonymous mailboxes will eventually expire. Without these
protections, malicious users eventually accumulate enough
anonymous credentials or open mailboxes that they can ef-
fectively launch the denial of service attack described above.
is important
It
Network
Conditions
ECDSA
Open a
KeyGen Mailbox Key Mailbox
Get Signed
End-to-End
User Local
Server Local
0.049
0.049
N/A
0.061
0.032
0.013
0.039
0.024
0.001
TABLE I: Timing results (in seconds) for protocols of Section VI-D,
using RSA-2048 ciphertexts and ECDSA.
Additionally, each time period’s pksign must be known to all
users; otherwise the server could use a unique key to sign each
user’s credentials, re-identifying the users.
E. Blind Signature Performance
To test the feasibility of using blind signatures, we im-
plemented the protocols in Section VI-D for a single client
and server. This represents the cryptographic overhead of
applying our solution, as the remainder (sending and receiving
messages, registering keys) are services already provided by
Signal.
The networking for both the client and server are written
in Python, with the Django web framework [1] on the server.
Starting with the code provided in [4], we implement an RSA-
2048 blind signature [8] library in Java that can be called via
RPC. Although RSA ciphertexts are large, they are very fast
to compute on modern hardware.
We evaluated our implementation by running the server on
an AWS instance with 2 Intel Xeon processors and 4 GB of
RAM. The client was running on a consumer-grade laptop,
with a 2.5 GHz Intel i7 with 16 GB of RAM, located in the
same region as the AWS server. We report the timing results in
Table I for each protocol. To better isolate the overhead from
network delay, we also report the execution time when server
and client are running locally on the same machine.
Importantly, ECDSA KeyGen can be run in the background
of the client, long before the interactive phase of the proto-
col starts. For maximum security, a user may close an old
mailbox and get a new signed key (with the same anonymous
connection), and then open a new mailbox with each message
that they send. This incurs an overhead of less that 100ms,
even including network delay. The communication overhead
of running this full protocol is less that 1KB, constituting 3
RSA-2048 ciphertexts and 1 ECDSA public key.
F. Deployment Considerations
Key Rolling. It is critical that the server maintain a database
of ephemeral identities previously registered on the system in
order to check for re-use of old ephemeral identities. Note
that to prevent reuse, this database must be maintained for as
long as the identities are valid and grows with the number of
mailboxes, not the number of users.
We suggest that Signal update their mailbox signing key at
regular intervals, perhaps each day, and leave two or three keys
valid for overlapping periods of time to avoid interruptions in
service. Because the validity of a signed mailbox key is tied to
the signing key, each update allows the server to “forget” all
the keys that it saw under the old signing keys as they cannot
be reused.
Mailbox Opening. It is important that users perform Get
signed mailbox key (where Signal learns a user’s identify)
and Open a mailbox in an uncorrelated way. Otherwise, Signal
could link the two and identify the anonymous mailbox. We
recommend performing Get signed mailbox key at regular
intervals (e.g. the same time each day), but careful consid-
eration must be taken for users that are ofﬂine during their
usual time. Users should not come online and perform both
operations immediately if sending to a new conversation. To
avoid this, clients should maintain a small batch of extra signed
mailbox keys for new conversations.
Cost Overhead. We analyze the worst case cost of scaling our
protocol. We generously assume that 10 million anonymous
mailboxes will be opened every day. The server’s part of
opening these mailboxes constitutes calls to BSVerify and
BSSign and a database query (to check for repeated identi-
ties). In our experiments, the two blind signature operations,
including the Django networking interface, took a cumulative
.014 seconds. Using AWS Lambda, supporting 10 million
messages each day would cost approximately $10 per month.
We estimate that doing 10 million reads and writes a day
to a DynamoDB database would cost approximately $20 per
month, using AWS’s reserved capacity pricing.
Using the key rolling scheme described above, the database
the number of messages delivered in a
contains at most
day times the number of simultaneously valid keys. At 10
million messages each time with a two overlapping valid
keys,
this means the database would contain at most 20
million ephemeral identities. Assuming 256-bit identity values,
the entire database would never exceed a few GB of data.
Therefore, we conservatively estimate that the marginal cost
of supporting our protocol for 10 million ephemeral identities
per day would be under $40 per month. We note our analysis
does not consider the personnel cost associated with develop-
ing or maintaining this infrastructure. Ideally, this would be
amortized along with Signal’s existing reliability and support
infrastructure.
VII. DISCUSSION
A. Other solutions
In this section, we consider alternative, minor changes to
the existing sealed sender protocol and evaluate their effective-
ness.
Random delays. Users could send delivery or read receipts
after a random delay, making it harder for attackers to corre-
late messages. This forces an attacker to increase the epoch
duration to perform the same attack. We analyze the effect
of varying epoch duration in Figure 5, and ﬁnd that even with
hour-long epochs—likely rendering delivery receipts useless—
users could still be identiﬁed within 60 messages. We conclude
that injecting random delays is an ineffective way to achieve
anonymity.
Cover trafﬁc. Users could send random sealed-sender mes-
sages that are transparently ignored by the recipient in order
13
to cover for the true pattern of ongoing conversations. Based
on our experiments, we again see that cover trafﬁc slows down
our attack, but at a linear rate with the amount of extra trafﬁc:
even with 10x extra messages, the anonymity set of potential
senders to Bob after 100 messages is under 1000 users. This
mitigation strategy has obvious costs for the service provider,
without signiﬁcant beneﬁt to user anonymity.
Disable automatic receipts. While Signal users can disable
read receipts and typing notiﬁcations, they currently cannot
turn off delivery receipts. Adding an option for this would
give users the choice to greatly mitigate this attack. We note
disabling would have to be mutual: Alice turning off delivery
receipts should also prevent Bob from sending them, different
from how Signal currently disables read receipts. We also note
users could potentially still be linked purely by their messages
eventually, making this only a partial mitigation.
B. Drawbacks and Likelihood of Adoption
We believe that the solution we have proposed in Sec-
tion VI is both practical and cost-effective. However, there
are a few drawbacks. Most importantly, it adds complexity to
the system, and complexity always increases the likelihood of
error and vulnerability. In particular, the key rolling scheme
we suggest in Section VI-F requires increased complexity in
the back-end key management system. While the compromise
of these keys would not leak message content, it could allow
for a cheap resource denial attack on Signal.
A second important drawback of our solution is the as-
sumption that a malicious service provider cannot use network
information to identify users. As mentioned, using Tor [19], [2]
would address this, but only if enough users did so to increase
the anonymity set.
Finally, our ephemeral identities may increase complexity
for users that use Signal on multiple devices. Signal would
need to securely share or deterministically generate these keys
with other devices in a privacy-preserving way.
Given the limited scope and impact of these drawbacks,
we believe that is reasonable to believe that Signal or other
secure messengers could potentially adopt our solution.
C. Group messaging
The OTR and Signal protocols were ﬁrst designed for
pairwise communication, and we have focused on such conver-
sations in this work. However, group messaging is an important
use case for private messaging services, and has recently shown
to be vulnerable to different kinds of attacks [46], [10], [47].
An interesting direction for future work would be to extend
our attacks to this setting. It is clear that received receipts
and read receipts do not work the same way in groups as
they do for two-way conversations. On the other hand, group
messages have additional group management messages which
are automatically triggered, for example, when a new member
attempts to join the group. It would be interesting to understand
if, for example, our attack could exploit these message to de-
anonymize all members of a given group chat.
Fortunately, it does seem that our main solution proposed
in Section VI would be applicable to the group chat setting:
all members of the group chat would create new, anonymous
mailboxes used only for that particular group. However, this
would still leave the difﬁculty of the initial conﬁguration and
key management, which would be more complicated than that
two-party setting. We consider this to be important and useful
potential future work.
VIII. RELATED WORK
Attacks on mobile messaging. Mobile messaging services
have been hugely popular for decades, but the SMS protocol
was designed primarily for efﬁciency and not with privacy
in mind [26]. Usability studies have shown that many users
want or even assume that
their text messages are private
[24], which has made SMS a “Goldmine to exploit” for state
surveillance [5], [21]. Even encrypted alternatives to SMS
are still targeted by hackers and state-level surveillance tools,
as seen for example by the NSO group’s Pegasus spyware,
which was used to target the text messages of journalists and
politicians in multiple countries [38].
Statistical disclosure attacks. SDAs were ﬁrst proposed as
an attack on mix networks by [14], and later strengthened
to cover more realistic scenarios with fewer or different
assumptions [40], [37], [16]. More recent variants consider
the entire network, and attempt to learn as much as possible
about all sender-receiver correlations over a large number of
observations [17], [44], [30]. See [43] for a nice overview and
comparison of many existing results.
Private messaging. Perhaps in response to these highly-
publicized attacks, third-party applications which provide end-
to-end encrypted messaging, such as WhatsApp (since 2016),
Telegram, and Signal, are rapidly gaining in popularity [32].
A good overview for the interested reader would be the SoK
paper of Unger et. al. from 2015 [49].
The ﬁrst cryptographically sound, scalable system for
end-to-end encrypted messaging is the OTR protocol from
2004 [6], which had signiﬁcant
inﬂuence on the popular
systems used today [39], [22], [9].
Since OTR, signiﬁcant research has investigated how to
remove or hide metadata to provide anonymous chat appli-
cations. Indeed, similar problems have been noted in mix-
nets [34]. Many such as Ricochet [7] rely on Tor [19]. Other
techniques for obscuring metadata are injecting noise, like
Pond [33] and Stadium [48], or decentralization [31]. Many
of these solutions require sharing cryptographic identities out-
of-band, rather than build off human-friendly or already known
identities.
DC-net based messengers like Dissent [12] or Verdict [13]
have also been proposed, but suffer problems in scaling to the
number of users seen on popular messaging applications [49],
[50]. Others such as Riposte [11] have made use of private
information retrieval to achieve anonymity, but this is also
expensive in practice. We focus on sealed sender in this paper,
as it is the most widely-deployed in practice attempt to provide
sender anonymity in secure messaging.
14
IX. CONCLUSION
In this work we analyze and improve upon Signal’s sealed
sender messaging protocol. We ﬁrst identify a type of sta-
tistical disclosure attack (SDA) that would allow Signal to
identify who is messaging a user despite sealed sender hiding
message sources. We perform a theoretical and simulation-
based analysis on this attack, and ﬁnd that it can work after
only a handful of messages have been sent to a user. Our
attack is possible because of two features of the sealed sender
protocol: (1) metadata (speciﬁcally, recipient and timing) is
still revealed, and (2) Signal sends automatic delivery receipts
back to the sender immediately after a message is received.
this attack,
We suggest a protection against
in which
users anonymously register ephemeral mailbox identities with
Signal, and use those to communicate rather than long-term