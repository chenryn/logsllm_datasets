    Acess-Control-Allow-Origin: null
    Access-Control-Allow-Credentials: true
此外，还包括第三个比特币交易所。这对攻击者来说再好不过了，因为任何网站都可以通过沙箱化的iframe轻松获得值为null的域:
使用一系列CORS请求，攻击者就可以窃取用户钱包的加密备份，然后立即展开离线蛮力破解，就能得到该钱包的密码了。如果用户的密码强度不高的话，他们的比特币就会轻而易举地被攻击者收入囊中。
更加要命的是，这种特殊的错误配置非常常见——只要你肯找，就肯定能[找到](https://www.shodan.io/search?query=%22Access-Control-Allow-Origin%3A+null%22
"找到")。实际上，选用"null"关键字本身就注定要出问题，因为在某些应用程序中，如果没有配置源白名单，可能会导致……
    Access-Control-Allow-Origin: null
哎……
**干掉HTTPS**
* * *
在这项研究中，我还发现了另外两个流行的白名单实现漏洞，并且这些漏洞通常都是伴生的。其中，第一个漏洞是轻率地将所有子域都列入白名单——甚至包括根本就不存在的子域。许多公司的子域名都会指向由第三方托管的应用程序，而这些应用程序的安全性一般都很糟糕。如果天真地相信这些程序中没有XSS漏洞，并且将来也不会有的话，那么，只能说有这种想法的人真是活该倒霉。
第二个常见漏洞是无法限制源协议。如果一个网站是通过HTTPS访问的，同时还乐于接受来自“
Strict Transport
Security功能和cookie的secure属性在防止这种攻击方面，几乎没有任何作用。对于这种攻击的具体演示，请参阅我的演讲文稿。
**滥用未启用凭证的CORS**
* * *
我们已经看到，启用凭证后，CORS可能非常危险。如果没有凭证，许多攻击将变得无关痛痒；这意味着，您不能使用用户的cookie，这样的话，让用户的浏览器发送请求，与自己发送请求一样，根本无法获得更多的优势。即使是令牌固定攻击也是行不通的，因为浏览器会忽略对cookie进行的任何重设。
一个值得注意的例外情况是，当受害者的网络位置作为一种身份验证的时候。这种情况下，您可以使用受害者的浏览器作为代理，来绕过基于IP的身份验证来访问Intranet应用程序。就危害程度而言，这种漏洞与DNS重新绑定类似，但要利用过程要更加繁琐。
**Vary: origin**
* * *
如果您考察CORS规范中的“实现注意事项”部分，就会发现，它让开发人员在动态生成Access-Control-Allow-Origin头部时，同时指定“Vary：Origin”HTTP头部。
这听起来可能很简单，但是包括W3C本身在内的很多人都忘了下面这句精彩的[名言](https://lists.w3.org/Archives/Public/public-webappsec/2016Jun/0057.html "名言")：
    我必须说，即使W3C都没能正确配置其服务器，所以，我很难相信很快会有更多网站支持CORS。
    - RetoGmür
如果我们忽视这个建议，会怎样呢？大多数情况下，人们就是这样做的。然而，在适当的情况下，它可能导致一些相当严重的攻击。
**客户端缓存中毒**
* * *
有时候，我们会遇到含有反射型XSS漏洞的页面，并且该漏洞位于自定义HTTP头部中。假设该网页并没有对响应该自定义头部的内容进行编码：
    GET / HTTP/1.1
    Host: example.com
    X-User-id: 
    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: X-User-id
    Content-Type: text/html
    ...
    Invalid user: 
如果不借助CORS的话，该漏洞是无法利用的，因为没有办法让某人的浏览器跨域发送X-User-id头部。使用CORS后，我们就可以让他们发送这种请求。当然，就其本身来说，这是无用的，因为包含我们注入的JavaScript的响应是不会被呈现的。但是，如果未指定Vary：Origin的话，那么，该响应可以存储到浏览器的缓存中，并在浏览器导航到相关的URL时立即显示。我已经创建了一个fiddle，用来演示[对您选择的URL进行攻击](https://jsfiddle.net/3gk8u8wu/3/
"对您选择的URL进行攻击")。由于这种攻击使用了客户端缓存，因此，它非常可靠。
**服务器端缓存中毒**
* * *
当天上的星星排成一条直线的时候，我们就能通过HTTP头部注入，利用服务器端缓存中毒来创建存储型XSS漏洞了。
如果应用程序会响应Origin头部，并且不检查它是否为\r之类的非法字符的话，那么，我们实际上就获得了一个针对IE/Edge浏览器用户的HTTP头部注入漏洞，因为Internet
Explorer和Edge浏览器会将\r\n（0x0d）视为有效的HTTP头部终止符：
    GET / HTTP/1.1
    Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
Internet Explorer将该响应视为：
    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: z
    Content-Type: text/html; charset=UTF-7
不过，这个漏洞无法直接利用，因为攻击者无法让某人的网络浏览器发送这种畸形的的头部；然而，我们可以利用Burp
Suite手动构造这种请求，然后，服务器端缓存可能会保存相应的响应，并将其提供给其他人。我使用的有效载荷会将页面的字符集改为UTF-7，这一招对构造XSS漏洞来说非常有用。
**好心办坏事**
* * *
刚开始的时候，我没想到动态生成Access-Control-Allow-Origin头部的网站的数量是如此之多。之所以出现这种情况，究其根本原因，可能是CORS的两个主要限制所致——既不允许在单个头部中指定多个域，也不允许在子域使用通配符。这使得许多开发人员别无选择，只能动态生成相应的头部，这样一来，就不得不面对以上讨论的各种实现漏洞。我认为，如果规范作者和浏览器允许使用源列表和部分通配符的话，动态头部生成和相关漏洞的数量将会直线下降。
浏览器的另一个可改进的地方在于，将通配符+凭证异常应用于使用null的域。目前，使用null的域的危险性要远甚于使用通配符的域，我想很多人会对此感到非常惊讶。
其他浏览器也可以尝试阻止我发明的“反向混合内容”攻击——HTTP站点使用CORS从HTTPS站点窃取数据。不过，我不知道这会造成什么样的破损。
简单性和安全性本可以相辅相成的，但是，由于浏览器不支持声明多个域，从而将复杂性直接推给了开发人员，从而带来了严重的恶果。我认为，这主要归咎于规范的设计以及实现的难度方面。
**小结**
* * *
CORS是一种功能强大技术，使用时需要格外谨慎，因为，危险的漏洞利用并不总是需要精湛的技能和错综复杂的攻击链——通常情况下，只需要对规范有基本的了解和一点点的关注就足够了。如果您想图省劲的话，这里告诉您一个好消息，目前Burp
Suite的扫描器已经能够识别并报告文中讨论的所有缺陷了。