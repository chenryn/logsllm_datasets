July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Max Bazaliy 
Jailbreaking 
Apple Watch 
July 27-30, 2017  
whoami 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
o  Security researcher at Lookout 
o  Lead researcher on Pegasus exploit chain 
o  Focused on advanced exploitation techniques 
o  Fried Apple team co-founder 
o  iOS/tvOS/WatchOS jailbreak author 
July 27-30, 2017  
o  Released in 2015%
o  Apple S1/S2%processor 
o  ARMv7k 32 bit architecture 
o  Taptic engine 
o  512 MB RAM 
o  WatchOS 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
What is Apple Watch ? 
July 27-30, 2017  
o  Access to file system 
o  Run tools like radare or frida on a watch 
o  iPhone attack vector 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Why to jailbreak a watch ? 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Apple Watch security 
o  Secure boot chain 
o  Mandatory Code Signing  
o  Sandbox 
o  Exploit Mitigations 
o  Secure Enclave Processor (2-nd gen only)  
o  Data Protection 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Possible attack vectors 
o  Malformed USB descriptor over debug port 
Debug port 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Possible attack vectors 
o  Malformed email, message, photo, etc 
 Still limited by sandbox 
o  Application extension based 
 More freedom on bug choice 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Jailbreak step by step 
o  Leak kernel base 
o  Dump whole kernel 
o  Find gadgets and setup primitives 
o  Disable security restrictions 
o  Run ssh client on a watch 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Bugs of interest 
o  WatchOS 2.x%
         - CVE-2016-4656%- osunserialize bug 
          - CVE-2016-4669%- mach_port register bug 
o  WatchOS 3.1.3%
          - CVE-2016-7644%- set_dp_control_port bug 
           - CVE-2017-2370%- voucher extract recipe bug 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Leaking kernel base 
o  CVE-2016-4655%and CVE-2016-4680%
o  Object constructor missing bounds checking 
o  OSNumber object with high number of bits 
o  Object length used to copy value from stack 
o  Kernel stack memory leaked 
o  Can be triggered from an app’s sandbox 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
OSObject * OSUnserializeBinary(const char *buffer, size_t bufferSize,  
 OSString **errorString) { 
uint32_t key, len, wordLen; 
len = (key & kOSSerializeDataMask); 
...  
case kOSSerializeNumber: 
                bufferPos += sizeof(long long); 
                if (bufferPos > bufferSize) break; 
                value = next[1]; 
                value unsigned64BitValue(); 
 len = off->numberOfBytes();
 bytes = &offsetBytes;  
... 
if (bytes) { 
 if( *dataCnt  code exec 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
OSObject * OSUnserializeBinary(const char *buffer, size_t bufferSize, …) { 
newCollect = isRef = false; 
... 
case kOSSerializeDictionary: 
       o = newDict = OSDictionary::withCapacity(len); 
       newCollect = (len != 0); 
       break; 
... 
        if (!isRef) 
        { 
          setAtIndex(objs, objsIdx, o); 
            if (!ok) break; 
            objsIdx++; 
        } 
  Save object to objs array 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
 if (dict) { 
            if (sym) 
             … 
            else { 
                sym = OSDynamicCast(OSSymbol, o); 
                if (!sym && (str = OSDynamicCast(OSString, o))) { 
                    sym = (OSSymbol *) OSSymbol::withString(str); 
                    o->release(); 
                    o = 0; 
                } 
                ok = (sym != 0); 
            } 
        } 
case kOSSerializeObject: 
                if (len >= objsIdx) break; 
                o = objsArray[len]; 
                o->retain(); 
                isRef = true; 
                break; 
 Object saved to objs array destroyed 
Deallocated object retained 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
o  Problem: No WatchOS kernel dumps  
o  No keys for WatchOS kernels 
o  Idea: read kernel as OSString chunks 
o  vtable offset required to fake OSString 
o  vtable stored in __DATA.__const in kernel 
Dumping kernel 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
Getting vtable - __DATA.__const leak 
o  __DATA.__const address is in Mach-O header 
o  Kernel base + 0x224 == __DATA.__const  
o  Deref and branch to address via fake vtable 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
Getting vtable - known offset 
o  Get vtable offset from similar XNU build 
o  Known  delta from __DATA.__const start 
o  Tune address with +/- delta 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
Getting vtable - known offset 
o  Get vtable offset from similar XNU build 
o  Known  delta from __DATA.__const start 
o  Tune address with +/- delta 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
Getting vtable – OSString layout 
…$
OSObject::retain()$
…$
vtable$ptr$+$0x8$
retain$count$
ﬂags$
length$
string$ptr$
vtable$ptr$+$0x8$
retain$count$
ﬂags$
length$
string$ptr$
OSObject::retain()$
0x0$
0x4$
0x8$
0xC$
0x10$
0x0$
0x8$
0x10$
0x18$
0x0$
0x4$
0x8$
0xC$
0x10$
0x0$
0x8$
0x10$
0x18$
0x20$
OSString 32 bit 
OSString 64 bit 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
size == 0x14%
size == 0x20%
…$
…$
0x20$
0x14$
…$
…$
…$
…$
0x28$
0x14$
July 27-30, 2017  
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
OSString layout 
OSString vtable pointer 
OSObject::retain() offset 
0x20%
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
OSString object 
OSString object vtable 
Kernel code section 
…$
…$
July 27-30, 2017  
o  vtable ptr is first 4/8%bytes of a on object 
o  What if object is not reallocated ?  
o  Memory marked as free 
o  New node pointing to next node in freelist 
Getting vtable – next free node trick 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
July 27-30, 2017  
Heap zone freelist 
Next node pointer 
Freelist head 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
July 27-30, 2017  
o  OSString memory marked as free 
o  Now it’s a node pointing to next node 
o  Next node ptr will be interpreted as vtable 
o  Call to retain() will branch out of node bounds 
o  What if OSString size == retain() offset ? 
o  We can branch out to the start of next node 
Getting vtable – next free node trick 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
July 27-30, 2017  
Next node ptr as a vtable ptr 
Interpreted as OSString 
Interpreted as OSString vtable pointer 
Interpreted as retain() 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
July 27-30, 2017  
o  Heap spray OSString objects  
o  Free few OSString’s 
o  Next free chunk pointer dereferenced as vtable 
o  Free chunk is surrounded by OSStrings 
o  retain() ->%OOB branch to next OSString 
Getting vtable – next free node trick 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
July 27-30, 2017  
Heap spray and OOB branch to vtable 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
Used memory chunks 
July 27-30, 2017  
Heap spray and OOB branch to vtable 
25 
26 
27 
28 