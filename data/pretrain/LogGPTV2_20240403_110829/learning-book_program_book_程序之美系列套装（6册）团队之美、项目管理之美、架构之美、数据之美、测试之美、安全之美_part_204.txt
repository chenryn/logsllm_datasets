利用最初的寄存器替换寄存器的副本。
简化
基于运算的操作数把运算改为更简单的运算。
表达式合并
把运算目录合并起来。例如，“x=y+1；z-x+1"可以把表达式"y+1"合
并到"z=x+1”，生成“x=y+1；Z-y+2”。
共用子表达式消除
查找对相同的操作数进行相同运算的指令，用前者结果的副本消除
后面的运算。
闲置代码消除
如果一个寄存器在两次定义之间没有使用，那么，执行最初定义的
指令是闲置代码，可以消除。
分支优化考虑改进控制流程图以便最有可能的路径按对编译器的目
标来说最优的方式进行布置。其他的分支优化希望去除多余的测试
和解并循环。
逃逸分析考虑对象是否可以只在编译的代码的上下文中存取，还考
虑一个不只在局部上下文中存取的对象是否可以在线程之间共享。
如果一个对象只是局部存取，那么，就可以排除为它分配内存的需
求并把这个对象的域移人寄存器。如果一个对象只在一个线程中访
问，那么，对这个对象的同步操作可以消除。
后面将介绍使用增加到这个中间形式的额外信息的许多优化。
低级中间表示
低级中间表示把先前类似于字节码的运算转换为更类似于机器码的
运算。对域的运算转换为载入和存储运算；像new和checkcast这样
适用于高级中间表示的大部分优化也适用于低级中间表示，但是，
像逃逸分析这样的优化不行。由于支持的运算类型不同，因此对于
1153
---
## Page 1155
不同的架构，在低级中间表示之间有一些微小的差异。对于低级中
间表示指令而言，非常多的符号寄存器可以用于低级中间表示指
令。
机器级中间表示
创建最终的机器级中间表示包括编译器后端的三个相互依存也相互
竞争的转换。说这些转换相互竞争是因为它们的顺序可以决定生成
的机器码的性能。在JikesRVM中，第一个转换是指令选择。指令选
择是类似于RISC（精简指令集计算机）的低级中间表示指令转换成
已经存在于实际机器上的指令的过程。有时候，执行一个低级中间
表示指令需要不止一个指令；例如，在32位的架构体系上，一个低
级中间表示的长整型加法需要两个指令。在其他时候，树型模式匹
配指令选择器（一个著名的自底向上重写的系统（BottomUp
Rewritesystem,BURS）把几个指令合并到一个指令。图10-6演示了
模式匹配的一个例子。两个模式都可以在IA32架构中找到：一个模
式创建三条指令用了41条机器指令，另一个模式把加载和存储编成
单个指令的内存操作，开销只有17条机器指令。最终选择了开销最
小的模式。
1154
---
## Page 1156
Java
Classfoo{
staticintx;
static void bar(int y){
HIR
x+=y;
LO寄存器保
t3=getstaticfoo.x
存着这个
t3=int_add+3,L0
参数y
putstatic+3,text.x
LIR
t1=int_loadtext.x
t2=int_add+1,L0
int_store(int_add(Int-load,)
BURS
int-store
int_loadia32_mov
ppeee!ppeu
int_storeia32_mov
cost:41
int-add
int_store(int_add(lnt-load,)ia32_add
int-loa
cost:17
LO
图10-6：自底向上重写系统指令选择
在指令选择后，无限的寄存器必须映射到一个真实机器所提供的有
限寄存器。这个过程称为寄存器分配。当没有足够的寄存器时，可
以依靠栈把值保存在内存中：依靠栈交换实际寄存器的值，这种技
术称为溢流（spilling）和填充（filling）。寄存器分配器必须将溢
流和填充减到最少，也要考虑任何架构的需要一例如，要求乘法和
除法必须用固定的寄存器进行。
JikesRVM有一个进行寄存器快速分配的线性扫描寄存器分配器，但
是可能会产生额外的复制和内存操作。当机器上可用寄存器的数量
很少时这是一个大问题。随着寄存器数量的增加和线性扫描算法的
改进，对于某些代码来说，进行一次比较昂贵的寄存器分配的好处
越来越不明显。
1155
---
## Page 1157
创建机器级中间表示指令的最后部分是指令调度。调度把指令分开
以容许处理器充分使用指令级的平行性。
在机器级中间表示级别，只进行了很少的优化。由于与机器指令相
关的很多副作用，说服并据此优化指令的行为很困难。机器级中间
表示级的其他编译器阶段关注于确保遵守调用、异常和其他规定。
分解的控制流程图
如果一个空指针用于访问内存或数组的索引越界，Java程序会创建
运行时异常。这些运行时异常控制了代码的流向并会因此结束基本
程序块。这导致小的基础程序块具有较少的局部优化范围。为了增
大基础程序块，运行时异常依赖的控制流在高级中间表示和低级中
间表示级变为人工的数据依赖。这种依赖确保操作按异常的语义学
恰当地排序，因此，可能在执行的中间过程中离开基础程序块来处
理一个运行时异常。当这种中间形态在程序块的中间存在异常出口
时，就可以说控制流程图被分解了（Choi等1999）。
明确测试运行时异常的指令被创建并生成合适的保护结果。那些接
下来需要排序的指令使用这些保护结果。可以生成一个异常的指令
就是众所周知的潜在异常指令（PotentiallyExceptioning
Instruction,PEI）。所有的潜在异常指令会生成一个合适的保护结
果，那些用来移出潜在异常指令（如果潜在异常指令是多余的）的
指令也同样如此。例如，测试nmull的分支对多余的同样的值进行空
指针测试。来自这个分支的保护结果会代替来自空指针测试的保护
结果以确保指令不能重新排在这个分支之前。
图10-7演示了单个数组赋值：把它组成的运行时异常转变为确保代
码按正确顺序执行的潜在异常指令和保护依赖。
Java:A[]=10
HIB:(4{Guard]=null-check11
15 (Guard)= bounds-check 11,10,4
int · a store 10, 11, 10, f
图10-7：分解控制流程图中指令的一个例子
分等级和扩展的数组SSA形式
1156
---
## Page 1158
静态单一赋值（StaticSingleAssignment,SSA）形式减少了编译器优
化必须关心的依赖。这种形式确保任何寄存器（更普通的叫法是变
量；在JikesRVM的高级中间表示阶段和低级中间表示阶段，所有的
变量都保存在寄存器中）儿乎立即写入。一次编译器转换必须处理
三种依赖：
真依赖
在这种情况下，一个寄存器写入然后读出。
输出依赖
在这种情况下，一个寄存器写入，然后再次写入（第二次写入必须
发生在第一次有了任何转换之后）。
反向依赖
在这种情况下，一个寄存器读出，然后写入（写入必须发生在读出
有了任何转换之后）。
知道一个寄存器写入一次就意味着不会发生输出依赖和反向依赖。
这个特性意味着我们先前的局部优化可以应用于全局。为了处理循
环和其他分支，专门的Φ指令用于对控制流程图中不同地方的特殊
值的合并进行编码。
数组静态单一赋值形式是静态单一赋值形式的一个扩展，在其中，
加载和存储认为是定义一个特殊的名为堆的变量。按这种方式对内
存存取建模使编译器推论如果两次读取都发生在相同的数组位置以
本。多余的存储也以类似的方式处理。它还允许存取无关的堆来重
新组织一例如，用浮点和整数运算。数组静态单一赋值形式最初设
计用于FORTRAN：扩展的数组静态单一赋值形式增加了形式因
素，例如Java的域不能相互同名（Fink等2000）。
还是在静态单一赋值形式中，JikesRVM构建了π指令，放在一个分
支后面，使用一个操作数。这个指令使用和分支一样的操作数并
给它一个新名字以代替后续指令中使用的操作数。利用指令，编
译器可以推断：一个分支进行一个测试（例如一个null测试），那
么，利用这个指令的寄存器结果的任何null测试都是多余的。类似
地，数组边界检查也可以取消（Bodik等2000）。
1157
---
## Page 1159
高级中间表示的静态单一赋值形式中的循环倒置优化也消除了可能
的异常。循环倒置把异常检查代码移出了循环并明确地测试异常是
否会在进入循环之前发生。如果会出现异常，那就会执行一个产生
异常代码的循环版本。如果不会出现异常，那就会执行一个没有异
常的循环版本。
局部求值
高级中间表示优化（包括静态单一赋值优化）能够减少局部代码的
复杂度，但是，这受限于可用的常量值。当一个值来自数组时通常
不能确定它是否是常量，在Java中，数组总是容许它的值发生改
变。最常发生这种情况的是对于字符事。JikesRVM引入了纯粹的
annotation作为Java的扩展。利用反射，annotation能在编译期使一个
有常量参数的方法求值。出于这个目的而利用注释和反射在元循环
运行时是不复杂的。
局部求值有能力完全消除一些开销，例如运行时安全检查。安全检
查通常遍历栈来确定哪个方法调用了一个受限方法，然后检查以了
解那个方法是否有权限调用这个受限方法。因为方法在调用时进入
栈的时间可以在编译器内确定，如果把进入栈作为内联的结果，精
确的方法就简单地产生了。通过对安全检查代码求值，或如果这检
查是纯粹的进行一次反射调用，那么安全检查的结果就可以是确定
的或如果总是通过就可以取消。
当前栈替换
当前栈替换（On-StackReplacement,OSR）是当代码在栈上执行时交
换执行代码的过程。例如，如果一个运行时间长的循环正由JIT基线
编译器创建的代码执行，当优化编译器创建优化代码后用优化代码
交换这段代码是有好处的。它的用处的另一个例子是如果一个运行
的方法有不安全的虚构的类层级属性（例如一个类没有子类，这容
许在内联上进行改进），那就可以使这个方法无效。
当前栈替换通过引入保存一个方法的执行状态的新的字节码（在JIT
基线编译器的情况）或新的指令（在优化编译器的情况）来工作。
一旦执行状态保存下来，代码可以交换为新编译的代码，通过载入
保存的状态来继续执行。