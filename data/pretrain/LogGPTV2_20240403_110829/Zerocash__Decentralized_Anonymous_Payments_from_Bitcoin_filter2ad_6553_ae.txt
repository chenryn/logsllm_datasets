i
, snew
as in (cid:126)x,
i
i
i
i
i
for the same cmnew
pk,i, pkold
pk,i, pknew
sk,i, skold
enc,i) ,
enc,i) ,
enc,i) .
addrold
addrnew
addrold
pk,i = (aold
pk,i = (anew
sk,i = (aold
Thus, a witness (cid:126)a speciﬁes authentication paths for the two
new coin commitments, the entirety of coin information
about both the old and new coins, and address secret keys
for the old coins.
Given a POUR instance (cid:126)x, a witness (cid:126)a is valid for (cid:126)x if the
following holds:
1) For each i ∈ {1, 2}:
a) The coin commitment cmold
appears on the
ledger, i.e., pathi is a valid authentication path for
leaf cmold
i with respect to root rt, in a CRH-based
Merkle tree.
of cold
i
i
b) The address secret key aold
sk,i matches the address public
i
, i.e., aold
key of cold
i
pk,i = PRFaddr
aold
sk,i
of cold
(0).
is computed correctly,
d) The
i.e., snold
i = PRFsn
aold
sk,i
coin cold
c) The serial number snold
i
i ).
(ρold
pk,i(cid:107)ρold
(aold
is well-formed,
pk,i(cid:107)ρnew
(anew
f) The address secret key aold
sk,i ties hSig to hi, i.e., hi =
i )(cid:107)vold
i ).
)(cid:107)vnew
e) The coin cnew
is well-formed,
i.e., cmnew
(COMMrold
(COMMrnew
COMMsold
COMMsnew
cmold
i.e.,
=
=
).
i
i
i
i
i
i
i
i
i
i
PRFpk
aold
sk,i
(hSig).
(with
2) Balance is preserved: vnew
1 + vnew
2 + vpub = vold
1 + vold
2
1 + vold
2 ≤ vmax).
2 ≥ 0 and vold
1 , vold
vold
Recall
in this paper zk-SNARKs are relative to the
that
language of arithmetic circuit satisﬁability (see Section II);
thus, we express the checks in POUR via an arithmetic circuit,
denoted CPOUR. In particular, the depth dtree of the Merkle
tree needs to be hardcoded in CPOUR, and we thus make it
a parameter of our construction (see below); the maximum
number of supported coins is then 2dtree.
C. Algorithm constructions
We proceed to describe the construction of the DAP scheme
Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction,
Receive) whose intuition was given in Section I-B. Figure 2
gives the pseudocode for each one of the six algorithms in Π,
in terms of the building blocks introduced in Section IV-A and
Section IV-B. In the construction, we hardcode two quantities:
468
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:49 UTC from IEEE Xplore.  Restrictions apply. 
Setup
• INPUTS: security parameter λ
• OUTPUTS: public parameters pp
1) Construct CPOUR for POUR at security λ.
2) Compute (pkPOUR, vkPOUR) := KeyGen(1λ, CPOUR).
3) Compute ppenc := Genc(1λ).
4) Compute ppsig := Gsig(1λ).
5) Set pp := (pkPOUR, vkPOUR, ppenc, ppsig).
6) Output pp.
CreateAddress
• INPUTS: public parameters pp
• OUTPUTS: address key pair (addrpk, addrsk)
1) Compute (pkenc, skenc) := Kenc(ppenc).
2) Randomly sample a PRFaddr seed ask.
3) Compute apk = PRFaddr
4) Set addrpk := (apk, pkenc).
5) Set addrsk := (ask, skenc).
6) Output (addrpk, addrsk).
(0).
ask
Mint
• INPUTS:
– public parameters pp
– coin value v ∈ {0, 1, . . . , vmax}
– destination address public key addrpk
• OUTPUTS: coin c and mint transaction txMint
1) Parse addrpk as (apk, pkenc).
2) Randomly sample a PRFsn seed ρ.
3) Randomly sample two COMM trapdoors r, s.
4) Compute k := COMMr(apk(cid:107)ρ).
5) Compute cm := COMMs(v(cid:107)k).
6) Set c := (addrpk, v, ρ, r, s, cm).
7) Set txMint := (cm, v, ∗), where ∗ := (k, s).
8) Output c and txMint.
VerifyTransaction
• INPUTS:
– public parameters pp
– a (mint or pour) transaction tx
– the current ledger L
• OUTPUTS: bit b, equals 1 iff the transaction is valid
1) If given a mint transaction tx = txMint:
a) Parse txMint as (cm, v, ∗), and ∗ as (k, s).
b) Set cm(cid:48) := COMMs(v(cid:107)k).
c) Output b := 1 if cm = cm(cid:48), else output b := 0.
2) If given a pour transaction tx = txPour:
1
a) Parse txPour as (rt, snold
1 , snold
2 , cmnew
(pksig, h1, h2, πPOUR, C1, C2, σ).
, cmnew
2
, vpub, info, ∗), and ∗ as
2 ), output b := 0.
1 = snold
1 or snold
2
appears on L (or snold
b) If snold
c) If the Merkle root rt does not appear on L, output b := 0.
d) Compute hSig := CRH(pksig).
e) Set (cid:126)x := (rt, snold
2 , cmnew
1
f) Set m := ((cid:126)x, πPOUR, info, C1, C2)
g) Compute b := Vsig(pksig, m, σ).
h) Compute b(cid:48) := Verify(vkPOUR, (cid:126)x, πPOUR), and output b ∧ b(cid:48).
, vpub, hSig, h1, h2).
1 , snold
, cmnew
2
Pour
• INPUTS:
– public parameters pp
– the Merkle root rt
– old coins cold
1 , cold
2
– old addresses secret keys addrold
– path path1 from commitment cm(cold
path path2 from commitment cm(cold
sk,1, addrold
sk,2
1 ) to root rt,
2 ) to root rt
2
1
, vnew
– new values vnew
– new addresses public keys addrnew
– public value vpub
– transaction string info
1
• OUTPUTS: new coins cnew
1) For each i ∈ {1, 2}:
, cnew
2
pk,1, addrnew
pk,2
and pour transaction txPour
i
i
i
, sold
, rold
i ).
, cmold
:= PRFsn
aold
sk,i
pk,i, vold
i
sk,i, skold
, ρold
i
enc,i).
i ).
(ρold
pk,i, pknew
enc,i).
as (addrold
a) Parse cold
b) Parse addrold
sk,i as (aold
c) Compute snold
i
d) Parse addrnew
pk,i as (anew
e) Randomly sample a PRFsn seed ρnew
f) Randomly sample two COMM trapdoors rnew
g) Compute knew
h) Compute cmnew
:= (addrnew
i) Set cnew
j) Set Ci := Eenc(pknew
:= COMMsnew
pk,i, vnew
enc,i, (vnew
i
:= COMMrnew
pk,i(cid:107)ρnew
i
).
(anew
(cid:107)knew
).
(vnew
i
i
, snew
, rnew
, cmnew
i
, rnew
i
, snew
, snew
i
)).
.
i
i
i
i
i
i
i
i
i
.
).
i
i
i
, ρnew
i
, ρnew
2) Generate (pksig, sksig) := Ksig(ppsig).
3) Compute hSig := CRH(pksig).
4) Compute h1 := PRFpk
aold
5) Set (cid:126)x := (rt, snold
, cmnew
1 , snold
2 , cmnew
2 , addrold
6) Set (cid:126)a := (path1, path2, cold
7) Compute πPOUR := Prove(pkPOUR, (cid:126)x, (cid:126)a).
8) Set m := ((cid:126)x, πPOUR, info, C1, C2).
9) Compute σ := Ssig(sksig, m).
10) Set txPour := (rt, snold
1 , snold
∗ := (pksig, h1, h2, πPOUR, C1, C2, σ).
2 , cmnew
1 , cold
sk,1
1
2
1
2
11) Output cnew
, cnew
1
2
and txPour.
(hSig) and h2 := PRFpk
aold
(hSig).