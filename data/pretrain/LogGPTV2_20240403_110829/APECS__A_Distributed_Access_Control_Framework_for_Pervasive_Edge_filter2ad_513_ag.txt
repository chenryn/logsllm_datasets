ized public key management for named data networking. In The international
conference on computer communications and networks (ICCCN 2018). IEEE.
[30] S. Yi, Z. Hao, Q. Zhang, Q. Zhang, W. Shi, and Q. Li. 2017. Lavea: Latency-
aware video analytics on edge computing platform. In Proceedings of the Second
ACM/IEEE Symposium on Edge Computing. IEEE/ACM, 1–13.
[31] Qingyang Zhang, Quan Zhang, Weisong Shi, and Hong Zhong. 2018. Distributed
collaborative execution on the edges and its application to amber alerts. IEEE
Internet of Things Journal 5, 5 (2018), 3580–3593.
[32] M. Zhao, C. Hu, X. Song, and C. Zhao. 2019. Towards dependable and trustworthy
outsourced computing: A comprehensive survey and tutorial. Journal of Network
and Computer Applications 131 (2019), 55–65.
[33] Qian Zhou, Mohammed Elbadry, Fan Ye, and Yuanyuan Yang. 2018. Heracles:
Scalable, Fine-Grained Access Control for Internet-of-Things in Enterprise Envi-
ronments. In IEEE INFOCOM 2018-IEEE Conference on Computer Communications.
IEEE, 1772–1780.
10 COMPUTATIONAL ASSUMPTIONS
Let G1 and G2 be two cyclic multiplicative groups of prime order q
generated by д1 and д2 respectively, ˆe : G1 × G2 → GT be a bilinear
map such that∀x ∈ G1, y ∈ G2, and a, b ∈ Zq, ˆe(xa, yb) = ˆe(x, y)ab,
and ˆe(д1, д2) (cid:44) 1.
Definition 10.1. The Decisional Diffie-Hellman (DDH) problem
in prime order group G = is defined as follows: on input д, дa,
дb , дc ∈ G, decide if c = ab or c is a random element of Zq.
Definition 10.2. Let algorithm BDH_Gen(1λ) output the pa-
rameters (ˆe(·,·), q, д1, д2, G1, G2, GT ) where there is an efficiently
computable isomorphism ψ from G2 to G1. The Decisional Bilinear
Diffie-Hellman (DBDH) problem is defined as follows: given д1 ∈ G1,
2 ∈ G2 and Z ∈ GT as input, decide if Z = ˆe(д1, д2)abc
д2, дa
or ˆe(д1, д2)R for R ∈ Zq.
2 , дb
2 , дc
Definition 10.3. The k-Decisional Diffie-Hellman Inversion (k-
DDHI) problem in prime order group G = is defined as follows: on
, дu ∈ Gk +2, decide if u = 1/s
input a (k+2)-tuple д, дs , дs2
or u is a random element of Zq.
, . . . , дs k
Definition 10.4. Let BDH_Gen(1λ) output the parameters for a
bilinear mapping (ˆe) : G1 × G2 → GT . The eXternal Diffie-Hellman
(XDH) assumption states that, for all probabilistic polynomial time
adversaries A, the DDH problem is hard in G1. This implies that there
does not exist an efficiently computable isomorphism ψ ′ : G1 → G2.
11 UC SECURITY ANALYSIS
11.1 Discussion
The security properties APECS aims to provide are preventing unau-
thorized users from availing services, and preventing malicious edge
servers from offering services they are not authorized to provide,
Session 5B: PKI and Access Control CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1418and accessing users’ input and personal data. The design of our
ideal functionalities must reflect these properties.
Fregister enforces that users can register for availing an SP’s
services only if the SP allows them to. When a user wants to up-
grade/downgrade their service category, Fregister forwards the re-
quest to SP, and allows the change only if SP permits it. An SP could,
of course refuse a user’s registration or service category update re-
quest, but we do not consider this as malicious behavior on the part
of the SP, since an SP can decide whom it wants to provide services
to. All details are stored in an internal table, uTable of FAPECS, and
cannot be modified by users and/or service providers. When a user
is revoked by an SP, Frevoke promptly deletes the corresponding
entry from uTable. When a user tries to request services of SP in a
category it has not registered for, e.g., a bronze member requesting
gold member services, Fresponse will check the uTable and return ⊥
to the user. This is also true when the user tries to access services
from non-existent edge servers. Hence a user will never be able to
improperly request services it has not signed up for.
When an edge server, EC, wants to provide services on behalf of
an SP, it needs to register with SP and a base station, BS. We assume
that when an EC registers with an SP and BS, it can provide all
services offered by SP on SP’s behalf in all categories. This can be
easily modified to account for various combinations of sname/scat
offered by different ECs, but we do not depict them here for presen-
tational clarity. An EC, based on stype, can distinguish whether an
incoming user’s service request is static or dynamic. In the static
case, it returns the data (e.g., movie), and in the dynamic case, it
runs the algorithms stored in the sdata field of the corresponding
sname on the user’s input, udata, and returns the result to Fresponse,
which forwards it to the user. Thus, there is no way a malicious
EC can provide unauthorized services to a user on behalf of an SP,
either in collusion with the user or otherwise. Also, Fresponse will
not forward any request containing udata to EC, unless it verifies
that EC is indeed authorized to service that user’s request, so EC
cannot get unauthorized access to user data/inputs.
11.2 Proof
We now prove Theorem 6.1.
Proof : We give a series of games, each of which is indistinguishable
from its predecessor by a PPT Z.
Game 0: This is the same as the real-world APECS. Z interacts
directly with APECS and A.
Game 1: S internally runs A and simulates the secure and au-
thenticated channels functionality Fsmt.
Lemma 11.1. For all PPT adversaries A and PPT environments Z,
there exists a simulator S such that
ExecGame0,Z ≈ ExecGame1,Z
The two games are trivially indistinguishable since S just exe-
cutes the simulator for Fsmt.
Game 2: S communicates with the honest parties and A, and
simulates the protocols of APECS with the help of FAPECS. A can
corrupt any user or EC at any point in time by sending a message
“corrupt” to them. Once an entity is corrupted, all their informa-
tion is sent to A and all further communication to and from the
corrupted party is routed through A. We now state and prove the
following lemma:
Lemma 11.2. For all PPT adversaries A and PPT environments Z,
there exists a simulator S such that
ExecGame1,Z ≈ ExecGame2,Z
SP, EC, BS create their respective key-pairs, SP sets up the ser-
vices it offers and service categories. All public keys are published
as part of Mpk. S gets SP’s public key, certificate, Certp, creates
spid, IDp, constructs the tuple td = (register, spid, sname, scat,·,·)
and passes it on to Fregister in the ideal-world who adds td to its
dTable. In the real-world, S returns IDp to SP. S receives a registra-
tion request from EC, ([IDs], Certe), upon which it creates an ecid
associated with EC, constructs tuple ts = (register, spid, ecid, bsid)
and forwards ts to Fregister in the ideal-world who adds ts to its
sTable. S then forwards ([IDs], Certe) to SP, BS who will complete
the registration in the real-world and return (e,[Ae]) to S who for-
wards it to EC. S also queries the key generation function of Fsig,
and simulates the key generation procedure for Ssig where Ssig is
the simulation of the specific digital signature scheme being used.
When an EC needs to get revoked, SP will forward to S the ecid (ˆe
in the real world). S will pass long ˆe to the appropriate BS in the real
world, and in the ideal-world, S will create and forward to Frevoke
a tuple (revoke, spid, ecid). Frevoke will delete the corresponding
tuple from dTable, and forward the successfully-processed revoca-
tion request to bsid via S. In the real-world, SP and BS will update
their respective parts of Mpk to M′
pk public. SP, BS
will also re-key the non-revoked ECs, and pass on their new keys
to them via S.
User u sends a registration request, (user_data, Certu) to S.
user_data contains information about the services [IDs] u is re-
questing, service provider IDp, the service categories [Lu], and ex-
piry time of the user’s subscription,Texp.S forwards(user_data, Certu)
to SP. SP creates a token Tpu = (IDp ,[IDs], Certu ,[Lu],Texp), and
simulates a signature on Tpu viaSsig.S then returns(Tpu , σTpu , Mpk)
to u. In the ideal world, S constructs tuple tu = (register, uid =
H(Tpu), scat, spid) and sends to Fregister, where H is a collision-
resistant hash function. Fregister will add(uid, scat, spid) to its uTable.
If Fregister returns a ⊥, S returns ⊥ to u. When a user u needs to
get revoked, SP will notify all ECs through S and S will forward
Tpu to the ECs in the real-world. In the ideal-world, S will create
and forward (revoke, uid = H(Tpu), scat, spid) to Frevoke. Frevoke
will delete the corresponding entry from its uTable.
Any user u can send a service request to S. There are three
cases to consider: a revoked user sending a service request, an un-
revoked user sending a service request and a revoked EC trying to
process the request (and thus gain access to that user’s private input
data supplied with the request), and an un-revoked user sending
a service request which is processed by an un-revoked EC. We
discuss them below:
pk and make M′
(1) Case 1: Revoked u sending a service request: u creates and
sends a service request ((Req = (Tpu ,[ID]s , C1, C2)), σTpu).
S needs to forward C1, C2 to the appropriate EC(s), since it
cannot decrypt them itself. S first does uid ← H(Tpu) and
sends (Req, σTpu) to the bsid and ecids associated with spid.
S finds the appropriate spid by calling the Verify interface
Session 5B: PKI and Access Control CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1419(cid:16)
(cid:17) ← ABE.Setup(1λ, n) and simulates SP by
Mpk = (sysparam, apk1, . . . ,
S sets up the public parameters,
apkn), ask1, . . . , askn
creating an IDp in the real-world. Although this is done for every
SP, for simplicity, we have represented only one SP. In the ideal-
world, S creates spid, which is passed on to Fregister to register SP
as (register, spid,·,·,·,·).
For every ecid in the real-world that A wants to control, A
sends to S a tuple ([IDs], Certe). In response S simulates and sends
(e,[Ae]) to A, where each [Ae] ← ABE.KeyGen(Mpk , aske , ide ,
[IDs]). S also creates (e,[Ae]) for simulating honest ECs with ser-
vice attributes not signed up for by the A in the previous step. S
stores (e,[Ae]) for honest ECs locally. In the ideal-world, S sends
(spid, ecid,·) to Fregister. If A signals an EC be revoked, S generates
the new M′
pk. For the un-revoked ECs, S sends their new [Ae]′ to
A. In the ideal-world, S sends (revoke, spid, ecid) to Frevoke who
will delete all tuples of the form (spid, ecid,·) from its sTable. If A
tries to revoke a non-existent EC, S will forward (revoke, spid,·),
who will return ⊥, which S returns to A.
A sends registration requests on behalf of corrupted users to
S. For each user u’s registration, S creates a token Tpu = (spid,
sname,·, scat,·), and creates σTpu by simulating Ssig. It returns
(Tpu , σTpu , Mpk) to A. If A sends a message for a user to get re-
voked (along with the corresponding bsid),S sends(revoke, uid, spid)
to Frevoke. If Frevoke returns ⊥, i.e., A has tried to revoke a non-
existent or an already-revoked user, S returns ⊥ to A. Else, S
notifies A of the successful revocation.
S receives a service request from A of the form(Req =(Tpu ,[ID]s
, C1, C2), σTpu). S checks if the service request can be satisfied by
one of the adversary controlled ECs; the request is handled locally
by A and need not be simulated. However, if the request cannot
be satisfied by an adversary controlled EC, S will utilize Fresponse
functionality to respond to the user request.
In static requests, C1 is plaintext, so that tells S what the sname
is. S then calls Ssig to verify the signature on σTpu with the appro-
priate V Kspid. This tells S what the spid is. Also, H(Tpu) → uid
which tells S what the uid is. When A sent Tpu, it will tell S
which bsid the request is intended for. So, S has all the information
it needs to construct a tuple Fresponse (spid, sname, uid, bsid, C2)
and sends to Fresponse. If the EC is not corrupted, i.e., S simulates
the output of a honest EC by forwarding the output, {msд,⊥}, of
Fresponse to A. Note that if Fresponse returned a ⊥ then that means
A queried on behalf of a revoked user and/or a revoked EC. When
C2 (cid:44) ⊥ (dynamic requests), S looks at the set of attributes IDs
for the key-policy ABE that were used in the generation of C1.
This will tell it the snames that A is requesting. S uses the locally
stored keys ([Ae]) to decrypt C1 to get symmetric key K, and uses
K to decrypt C2 to retrieve udata. S can then construct a tuple
(spid, sname, uid, bsid, udata) to send to Fresponse. The rest of the
simulation proceeds as in the static case.
□
of Ssig to verify the signature on σTpu with the appropriate
V Kspid. Honest ECs will return “error”, if the user is revoked,
or if the timestamp, Texp is past its expiry date, while mali-
cious ECs may still process the revoked user’s request. In the
ideal-world, S creates a tuple (spid, sname, uid, bsid, udata)
and forwards to Fresponse. Since u was revoked before send-
ing the request, Fresponse will return ⊥ (the check in Step 2
of Fresponse will fail). S then returns “error” to u. S will dis-
regard any responses it receives from malicious ECs possibly
colluding with the revoked user.
(2) Case 2: Revoked EC trying to process u’s request: User u
creates and sends a service request to S similar to Case 1, and
S forwards the request to bsid and ecids. In the real-world,
each BS will revoke ECs on the request of the appropriate SP
with whom EC is registered. When an EC gets revoked, BS
will run Protocol 7, Steps 3-12, to re-issue new keys to the
un-revoked ECs who possessed the same attributes as the
EC getting revoked. This ensures that BS will not forward
(Req, σTpu) to revoked ECs, nor will S accept any responses
from them. In the ideal-world, when an ecid needs to get re-
voked, the corresponding spid with whom ecid is registered
will send a (revoke, spid, ecid) message to Frevoke. Upon re-
ceipt of this, Frevoke will promptly delete that ecid’s tuple
from sTable, and send the tuple to S who will not forward
(Req, σTpu) to the revoked ECs. Nevertheless, if it still re-
ceives responses from revoked EC, S will ignore them. The
rest of the simulation proceeds similar to Case 1.
(3) Case 3: Un-revoked user sending a service request processed
by an un-revoked EC: User u creates and sends a service re-
quest ((Req = (Tpu ,[ID]s , C1, C2)), σTpu) as in the previous
two cases. S sends (Req, σTpu) to the bsid and ecids associ-
ated with spid. The ecids response is forwarded back to S.
If the request is for a service (dynamic request), i.e., C2 (cid:44) ⊥,
S will forward the request to bsid, and all ecids. S will ac-
cept the first response it receives from an ecid. Since S for-
wards the request to all ECs, some might respond saying
they cannot provide the requested service; S ignores such
responses. Eventually, at least one EC will send a response
of the form fulfillService(·) → msд, which S forwards to
u. If the request is for data (static request), i.e., C2 = ⊥, S
will forward the request to bsid and all ecids and accept the
first response it receives. It will receive a response of the
form contentCacheLookup → msд, which S forwards to u.
In either case, if all ecids respond with a ⊥, S returns ⊥ to u.
Game 3: In this game, S needs to simulate the honest parties’
outputs to A; S does not have access to honest parties’ outputs
as it did in Game 2. S needs to reflect the outputs and protocol
outcomes of the ideal-world in the simulation of the real-world
protocol and any attempt by A to cheat in the real-world has to
result in the protocol aborting in the ideal-world. We now state and
prove the following lemma:
Lemma 11.3. For all PPT adversaries A and PPT environments Z,
there exists a simulator S such that
ExecGame2,Z ≈ ExecGame3,Z
Session 5B: PKI and Access Control CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1420