        if (log_level)
            vfree(log_buf);
    free_env:
        if (!env->prog->aux->used_maps)
            /* if we didn't copy map pointers into bpf_prog_info, release
             * them now. Otherwise free_bpf_prog_info() will release them.
             */
            release_maps(env);
        *prog = env->prog;
        kfree(env);
        mutex_unlock(&bpf_verifier_lock);
        return ret;
    }
其中主要是使用 `do_check`来根据不同的指令类型来做具体的合法性判断。使用的核心数据结构是
`reg_state`，`bpf_reg_type`枚举变量用来表示寄存器的类型，初始化为 `NOT_INIT`：
    struct reg_state {
        enum bpf_reg_type type;
        union {
            /* valid when type == CONST_IMM | PTR_TO_STACK */
            int imm;
            /* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |
             *   PTR_TO_MAP_VALUE_OR_NULL
             */
            struct bpf_map *map_ptr;
        };
    };
    static void init_reg_state(struct reg_state *regs)
    {
        int i;
        for (i = 0; i cur_state;
        struct bpf_insn *insns = env->prog->insnsi;
        struct reg_state *regs = state->regs;
        int insn_cnt = env->prog->len;
        int insn_idx, prev_insn_idx = 0;
        int insn_processed = 0;
        bool do_print_state = false;
        init_reg_state(regs);
        insn_idx = 0;
        for (;;) {
            struct bpf_insn *insn;
            u8 class;
            int err;
            //指令条数检查
            if (insn_idx >= insn_cnt) {
                verbose("invalid insn idx %d insn_cnt %d\n",
                    insn_idx, insn_cnt);
                return -EFAULT;
            }
            insn = &insns[insn_idx];
            class = BPF_CLASS(insn->code);
            //运行过的次数上限检查
            if (++insn_processed > 32768) {
                verbose("BPF program is too large. Proccessed %d insn\n",
                    insn_processed);
                return -E2BIG;
            }
            //检测该指令有无visit，主要通过env->explored_states的状态数组保存访问过的指令的状态
            err = is_state_visited(env, insn_idx);
            if (err src_reg, SRC_OP);
                if (err)
                    return err;
                //检查目的寄存器
                err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
                if (err)
                    return err;
                //
                src_reg_type = regs[insn->src_reg].type;
                /* check that memory (src_reg + off) is readable,
                 * the state of dst_reg will be updated by this func
                 */
                //检查源寄存器+off所指的地址是可读的
                err = check_mem_access(env, insn->src_reg, insn->off,
                               BPF_SIZE(insn->code), BPF_READ,
                               insn->dst_reg);
                if (err)
                    return err;
                if (BPF_SIZE(insn->code) != BPF_W) {
                    insn_idx++;
                    continue;
                }
                if (insn->imm == 0) {
                    /* saw a valid insn
                     * dst_reg = *(u32 *)(src_reg + off)
                     * use reserved 'imm' field to mark this insn
                     */
                    insn->imm = src_reg_type;//判断出了一种指令类型，即地址取值指令
                }
                //源类型非立即数
                else if (src_reg_type != insn->imm &&
                       (src_reg_type == PTR_TO_CTX ||
                        insn->imm == PTR_TO_CTX)) {
                    /* ABuser program is trying to use the same insn
                     * dst_reg = *(u32*) (src_reg + off)
                     * with different pointer types:
                     * src_reg == ctx in one branch and
                     * src_reg == stack|map in some other branch.
                     * Reject it.
                     */
                    verbose("same insn cannot be used with different pointers\n");
                    return -EINVAL;
                }
            //BPF_STX指令
            } else if (class == BPF_STX) {
                enum bpf_reg_type dst_reg_type;
                if (BPF_MODE(insn->code) == BPF_XADD) {
                    err = check_xadd(env, insn);
                    if (err)
                        return err;
                    insn_idx++;
                    continue;
                }
                /* check src1 operand */
                err = check_reg_arg(regs, insn->src_reg, SRC_OP);
                if (err)
                    return err;
                /* check src2 operand */
                err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
                if (err)
                    return err;
                dst_reg_type = regs[insn->dst_reg].type;
                /* check that memory (dst_reg + off) is writeable */
                err = check_mem_access(env, insn->dst_reg, insn->off,
                               BPF_SIZE(insn->code), BPF_WRITE,
                               insn->src_reg);
                if (err)
                    return err;
                if (insn->imm == 0) {
                    insn->imm = dst_reg_type;
                } else if (dst_reg_type != insn->imm &&
                       (dst_reg_type == PTR_TO_CTX ||
                        insn->imm == PTR_TO_CTX)) {
                    verbose("same insn cannot be used with different pointers\n");
                    return -EINVAL;
                }
            //BPF_ST指令
            } else if (class == BPF_ST) {
                if (BPF_MODE(insn->code) != BPF_MEM ||
                    insn->src_reg != BPF_REG_0) {
                    verbose("BPF_ST uses reserved fields\n");
                    return -EINVAL;
                }
                /* check src operand */
                err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
                if (err)
                    return err;
                /* check that memory (dst_reg + off) is writeable */
                err = check_mem_access(env, insn->dst_reg, insn->off,
                               BPF_SIZE(insn->code), BPF_WRITE,
                               -1);
                if (err)
                    return err;
            //BPF_JMP指令
            } else if (class == BPF_JMP) {
                u8 opcode = BPF_OP(insn->code);
                //直接跳转CALL
                if (opcode == BPF_CALL) {
                    if (BPF_SRC(insn->code) != BPF_K ||
                        insn->off != 0 ||
                        insn->src_reg != BPF_REG_0 ||
                        insn->dst_reg != BPF_REG_0) {
                        verbose("BPF_CALL uses reserved fields\n");
                        return -EINVAL;
                    }
                    //在这个函数中会检查跳转的地址有无超过范围，函数的五个参数的参数类型(是否是key/value/map地址/stack_size等)，更新返回值寄存器，更新reg_state等。
                    err = check_call(env, insn->imm);
                    if (err)
                        return err;
                } else if (opcode == BPF_JA) {
                    if (BPF_SRC(insn->code) != BPF_K ||
                        insn->imm != 0 ||
                        insn->src_reg != BPF_REG_0 ||
                        insn->dst_reg != BPF_REG_0) {
                        verbose("BPF_JA uses reserved fields\n");
                        return -EINVAL;
                    }
                    insn_idx += insn->off + 1;
                    continue;
                } else if (opcode == BPF_EXIT) {
                    if (BPF_SRC(insn->code) != BPF_K ||
                        insn->imm != 0 ||
                        insn->src_reg != BPF_REG_0 ||
                        insn->dst_reg != BPF_REG_0) {
                        verbose("BPF_EXIT uses reserved fields\n");
                        return -EINVAL;
                    }
                    //r0保存返回值，bpf_exit为指令集合结束标志，在此之前检查有无写入值
                    /* eBPF calling convetion is such that R0 is used
                     * to return the value from eBPF program.
                     * Make sure that it's readable at this time
                     * of bpf_exit, which means that program wrote
                     * something into it earlier
                     */
                    err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
                    if (err)
                        return err;
                    if (is_pointer_value(env, BPF_REG_0)) {
                        verbose("R0 leaks addr as return value\n");
                        return -EACCES;
                    }
                    //遇到一个exit就结束一个分支，回退到分叉处执行另一个branch，类似于走迷宫遍历路径
    process_bpf_exit:
                    insn_idx = pop_stack(env, &prev_insn_idx);
                    if (insn_idx code);
                if (mode == BPF_ABS || mode == BPF_IND) {
                    err = check_ld_abs(env, insn);
                    if (err)
                        return err;
                } else if (mode == BPF_IMM) {
                    err = check_ld_imm(env, insn);
                    if (err)
                        return err;
                    insn_idx++;
                } else {
                    verbose("invalid BPF_LD mode\n");
                    return -EINVAL;
                }
            } else {
                verbose("unknown insn class %d\n", class);
                return -EINVAL;
            }
            insn_idx++;
        }
        return 0;
    }
`BPF`指令的校验是在函数 `do_check`中，代码路径为
`kernel/bpf/verifier.c`，`do_check`通过一个无限循环来遍历提供的 `bpf`指令。
## 漏洞分析
###  漏洞概述
漏洞存在于内核版本小于 `4.13.9`的系统中，漏洞成因为 `kernel/bpf/verifier.c`文件中的
`check_alu_op`函数的检查问题，这个漏洞可以允许一个普通用户向系统发起拒绝服务攻击（内存破坏）或者提升到特权用户。