software trap handler is responsible for identifying the sys-
tem call number and arguments, invoking the appropriate
system call handler, and returning the result to the calling
application. We modiﬁed the handler to call a routine that
uses the MAC to verify that the system call satisﬁes the re-
quired policy. We have not yet implemented syscall check-
ing in OpenBSD.
To evaluate the security provided by authenticated sys-
tem calls against different forms of code injection attacks,
we devised a set of synthetic attack experiments. Exploits
based on techniques such as code injection and parameter
hijacking were used against a synthetic program that con-
tain a number of exploitable vulnerabilities, such as over-
ﬂowable buffers. The attack code was able to cause the
program to spawn a root shell on the unprotected system,
while the attacks failed against the version using authenti-
cated calls.
3. Experimental Evaluation
This section gives the results of an experimental evalua-
tion of authenticated system calls as realized in our proto-
type implementation. We start by describing the ASC poli-
cies generated by the installer, and comparing them with
some of those available for Systrace. We then present ex-
perimental results that quantify the performance impact of
authenticated system calls compared with unprotected calls.
Policies. An ideal policy would permit the system call be-
haviors needed for normal operation and no others. If the
policy permits system calls not used by the uncompromised
application (unneeded calls), it leaves open the possibility
that such calls could be exploited by an attacker. If the pol-
icy omits some system calls actually used by the application
(needed calls), it raises the possibility of a false alarm that
causes the application to be terminated unnecessarily. False
alarms are a signiﬁcant administrative headache and barrier
to use.
We generate our ASC policies through a conservative
static analysis, so our polices include all needed calls, and
thus avoid false alarms. In contrast, policies generated by
hand or by training may miss needed system calls, for ex-
ample, because they occur only in parts of the program that
are rarely executed.
ASC policies might include unneeded system calls, be-
cause no static analysis is able to identify the exact set of
needed calls for every program. Note, however, that un-
needed calls might also appear in policies produced by hand
or by training. Hand produced policies can include mis-
takes, for example. System calls identiﬁed through training
are never unneeded, by deﬁnition, but there are still oppor-
tunities for errors; for example, policies might be obtained
by training on one version of an application and operating
system, and used on another. In general, policies generated
by training are not portable between operating systems, or
even between different versions of the same operating sys-
tem, and they may need to be adjusted even when only li-
braries are updated.
In order to gather some empirical evidence regarding
false alarms, unneeded system calls, and operating sys-
tem effects, we ported our policy generator from Linux
to OpenBSD. OpenBSD is a useful test case because it
supports a system call monitor, Systrace,
in its default
build, and researchers have published Systrace policies for
OpenBSD applications. The Systrace policies are generated
through training along with hand edits.
Program
bison
calc
screen
ASC policy
for Linux
ASC policy
for OpenBSD
Systrace policy
for OpenBSD
31
54
67
31
51
63
24
24
55
Table 1. Number of system calls in policies
Table 1 compares the number of distinct system calls per-
mitted in both ASC and Systrace policies for several com-
mon Unix programs: bison, the GNU Project parser gen-
erator; calc, an arbitrary-precision calculator program; and
screen, a screen manager with terminal emulation. The ﬁrst
column gives the numbers for the ASC policy generated
on Linux, the second column the ASC policy generated on
OpenBSD, and the third column gives the numbers for Sys-
trace policies published by the Project Hairy Eyeball web
site [6]. This rough comparison illustrates two things:
• There are signiﬁcant differences in the system calls
needed for the same application running on different
operating systems; this implies that policies for one
operating system cannot simply be used on another.
• ASC policies identify system calls that are not present
in Systrace policies.
Table 2 examines the policies for bison in more detail.
The table shows system calls that are permitted by the ASC
policy generated on OpenBSD but not by the Systrace pol-
icy, and vice versa. Note that the ASC policy includes many
system calls that are not present in the Systrace policy. We
believe that most of these calls are in fact needed, and we
have veriﬁed some of them by hand using a system call
tracer on actual runs of applications. This means that the
Systrace policy can cause false alarms.
Conversely, there are a few system calls permitted by the
Systrace policies that are not allowed in the ASC policy.
They break down as follows.
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:19 UTC from IEEE Xplore.  Restrictions apply. 
System call
syscall
close
fcntl
fstatfs
getdirentries
getpid
gettimeofday
kill
madvise
mkdir
mmap
nanosleep
readlink
rmdir
sendto
sigaction
socket
sysconf
uname
unlink
writev
ASC
yes
NO
yes
yes
yes
yes
yes
yes
yes
NO
NO
yes
NO
NO
yes
yes
yes
yes
yes
NO
yes
Systrace
NO
yes
NO
NO
NO
NO
NO
NO
NO
yes (fswrite)
yes
NO
yes (fsread)
yes (fswrite)
NO
NO
NO
NO
NO
yes (fswrite)
NO
Table 2. Comparison of policies for bison
mmap. The mmap system call
is
implemented on
OpenBSD by invoking syscall, a generic indirect sys-
tem call function. The ASC policy correctly constrains
syscall so that only mmap can be
the arguments of
invoked, however. With Systrace, this indirection is
hidden from users since its policy does not explicitly
allow syscall.
close. The call of close is not identiﬁed by PLTO due to
an unusual implementation on OpenBSD that PLTO
currently cannot disassemble. However, PLTO always
reports when it cannot completely disassemble a bi-
nary, so that the administrator would always be aware
of such a problem. To date, we have not encountered
similar difﬁculties on Linux, PLTO’s native platform.
mkdir, readlink, rmdir, unlink. The Systrace system uses
two generic names, fsread and fswrite, to specify sets
of system calls; fsread denotes read-related system
calls and fswrite denotes write-related calls. The fact
that mkdir, etc., are not in the ASC policy indicates
that they are unneeded system calls, but their execu-
tion would be allowed with Systrace since its policy
includes fsread and fswrite.
Next, we examine the degree to which each authenti-
cated system call is protected from alteration by its MAC.
In our current prototype, the system call site and call num-
ber are always protected by the MAC, as are those argu-
ments whose values can be determined by static analysis. It
prog
bison
calc
screen
tar
sites
158
275
639
381
calls
31
54
67
58
args
321
544
1164
750
o/p
31
78
133
105
auth mv
2
90
2
183
7
363
238
3
fds
69
109
297
152
Table 3. Argument coverage
is, of course, impossible to determine all argument values
using such techniques; for example, the value may be read
as a user input, generated as a result of a system call, or
may be unknown because of pointer aliasing. In practice,
however, static analysis can determine enough values to be
useful [22], and it can provide a partial policy template that
can then be extended by the security administrator using dy-
namic proﬁling and application knowledge.
Table 3 provides the results of generating ASC policies
for four programs: the three from above and tar, the Unix
archiving program. The sites column indicates the number
of separate system call locations in the program, calls in-
dicates the number of different system calls, and args gives
the total number of arguments (not including the system call
number) from all the call sites. The o/p column gives the
number of system call arguments that are output-only ar-
guments, that is, the argument is an address of a structure
where the kernel stores the result of the call. The auth col-
umn lists the number of arguments that could be determined
by the static analysis done by the installer and that could
be authenticated by the basic approach. These results indi-
cated that 30–40% of the arguments can be protected based
on static analysis and the basic approach.
In addition to these arguments, there are many others
that might be protected by using extensions such as those
described in section 4. Table 3 includes statistics for two
of these as well: arguments where the value can be deter-
mined using static analysis but each argument may have two
or more values (mv), and arguments that are ﬁle descrip-
tors that were returned previously from system calls such as
open or socket (fds).
Performance. This section measures the performance
overhead introduced by the syscall checking mechanism.
We begin with a description of
results from micro-
benchmarks that measure the impact on individual system
calls, and then measure the effect on the overall execution
time for a number of programs.
Table 4 presents the overheads introduced by these tech-
niques on a per-system-call basis. These results were ob-
tained by executing each system call 10,000 times using a
loop, and measuring the total number of CPU cycles us-
ing the Pentium processor’s rdtsc instruction, which reads
a 64-bit hardware cycle counter. The last two rows indi-
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:19 UTC from IEEE Xplore.  Restrictions apply. 
Program Name Type
CPU
bzip2
CPU
gzip-spec
CPU
crafty