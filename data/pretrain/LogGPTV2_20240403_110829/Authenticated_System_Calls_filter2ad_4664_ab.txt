### Software Trap Handler and System Call Verification

The software trap handler is responsible for identifying the system call number and its arguments, invoking the appropriate system call handler, and returning the result to the calling application. We modified the handler to include a routine that uses the MAC (Mandatory Access Control) to verify whether the system call complies with the required security policy. Currently, we have not implemented syscall checking in OpenBSD.

### Security Evaluation Against Code Injection Attacks

To evaluate the security provided by authenticated system calls against various forms of code injection attacks, we designed a series of synthetic attack experiments. These experiments involved exploits based on techniques such as code injection and parameter hijacking, targeting a synthetic program with several exploitable vulnerabilities, including overflowable buffers. The attack code was able to spawn a root shell on the unprotected system, while the attacks failed against the version using authenticated calls.

### 3. Experimental Evaluation

This section presents the results of an experimental evaluation of authenticated system calls as implemented in our prototype. We start by describing the ASC (Authenticated System Call) policies generated by the installer and comparing them with those available for Systrace. We then present experimental results that quantify the performance impact of authenticated system calls compared to unprotected calls.

#### Policies

An ideal policy would permit only the system call behaviors necessary for normal operation. If the policy allows unnecessary system calls, it leaves the system vulnerable to exploitation. Conversely, if the policy omits needed system calls, it can cause false alarms, leading to unnecessary termination of the application. False alarms are a significant administrative challenge and a barrier to adoption.

Our ASC policies are generated through a conservative static analysis, ensuring that all necessary calls are included, thus avoiding false alarms. In contrast, policies generated manually or through training may miss needed system calls, especially if they occur in rarely executed parts of the program.

ASC policies might include unneeded system calls due to the limitations of static analysis. However, unneeded calls can also appear in manually created or trained policies. For example, hand-produced policies can contain errors, and trained policies might be specific to a particular version of the application or operating system, making them non-portable.

To gather empirical evidence regarding false alarms, unneeded system calls, and operating system effects, we ported our policy generator from Linux to OpenBSD. OpenBSD is a useful test case because it supports Systrace, a system call monitor, and researchers have published Systrace policies for OpenBSD applications. These policies are generated through training and manual editing.

| Program | ASC Policy for Linux | ASC Policy for OpenBSD | Systrace Policy for OpenBSD |
|---------|---------------------|------------------------|----------------------------|
| bison   | 31                  | 54                     | 67                         |
| calc    | 31                  | 51                     | 63                         |
| screen  | 24                  | 24                     | 55                         |

**Table 1. Number of system calls in policies**

Table 1 compares the number of distinct system calls permitted in both ASC and Systrace policies for several common Unix programs: bison, calc, and screen. This comparison highlights two key points:
- There are significant differences in the system calls needed for the same application running on different operating systems, implying that policies for one OS cannot be directly applied to another.
- ASC policies identify system calls that are not present in Systrace policies.

#### Detailed Comparison for Bison

Table 2 provides a more detailed comparison of the policies for bison, showing system calls permitted by the ASC policy generated on OpenBSD but not by the Systrace policy, and vice versa.

| System Call | ASC | Systrace |
|-------------|-----|----------|
| syscall     | yes | no       |
| close       | no  | yes      |
| fcntl       | yes | no       |
| fstatfs     | yes | no       |
| getdirentries | yes | no       |
| getpid      | yes | no       |
| gettimeofday | yes | no       |
| kill        | yes | no       |
| madvise     | yes | no       |
| mkdir       | yes | no (fsread) |
| mmap        | no  | yes (fswrite) |
| nanosleep   | no  | no       |
| readlink    | yes | no       |
| rmdir       | no  | yes (fsread) |
| sendto      | no  | no       |
| sigaction   | yes | no       |
| socket      | yes | no       |
| sysconf     | yes | no       |
| uname       | yes | no       |
| unlink      | yes | no       |
| writev      | no  | yes (fswrite) |

**Table 2. Comparison of policies for bison**

- **mmap**: On OpenBSD, `mmap` is implemented by invoking `syscall`. The ASC policy correctly constrains `syscall` to only allow `mmap`, while Systrace does not explicitly allow `syscall`.
- **close**: The `close` call is not identified by PLTO due to an unusual implementation on OpenBSD. PLTO reports when it cannot completely disassemble a binary, alerting the administrator.
- **mkdir, readlink, rmdir, unlink**: Systrace uses generic names `fsread` and `fswrite` to specify sets of system calls. The absence of these calls in the ASC policy indicates they are unneeded, but their execution would be allowed by Systrace.

#### Argument Coverage

In our current prototype, the system call site and call number are always protected by the MAC, as are those arguments whose values can be determined by static analysis. Table 3 provides the results of generating ASC policies for four programs: bison, calc, screen, and tar.

| Program | Sites | Calls | Args | o/p | Auth | mv | fds |
|---------|-------|-------|------|-----|------|----|-----|
| bison   | 158   | 31    | 321  | 31  | 2    | 7  | 69  |
| calc    | 275   | 54    | 544  | 78  | 90   | 363 | 109 |
| screen  | 639   | 67    | 1164 | 133 | 2    | 238 | 297 |
| tar     | 381   | 58    | 750  | 105 | 183  | 3  | 152 |

**Table 3. Argument coverage**

These results indicate that 30-40% of the arguments can be protected based on static analysis and the basic approach. Additional arguments can be protected using extensions described in Section 4.

#### Performance Overhead

This section measures the performance overhead introduced by the syscall checking mechanism. We begin with microbenchmarks that measure the impact on individual system calls and then measure the effect on the overall execution time for several programs.

| Program Name | Type | CPU Cycles |
|--------------|------|------------|
| bzip2        | CPU  |            |
| gzip-spec    | CPU  |            |
| crafty       | CPU  |            |

**Table 4. Overheads introduced by syscall checking**

These results were obtained by executing each system call 10,000 times in a loop and measuring the total number of CPU cycles using the Pentium processorâ€™s `rdtsc` instruction.

---

This optimized text provides a clear, coherent, and professional overview of the system call verification process, the security evaluation, and the experimental results.