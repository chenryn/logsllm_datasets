是
FIQ
Fiq
10001
供高优先级中断的处理函数使
用
PL1
是
IRQ
Irq
10010
供普通中断的处理函数使用
PL1
是
Abort
Abt
10111
用来处理内存访问失败
PL1
是
Undef
Und
11011
用来处理未定义指令异常
PL1
是
System
Sys
11111
供操作系统使用的高特权用户
模式
PL1
否
User
Usr
10000
供普通应用程序使用的低特权
模式
PL0
否
Monitor
Mon 10110
供系统信任的安全代码使用
PL1
是
Hyp
Hyp
11010
供虚拟机监视器代码使用
PL2
是
举例来说，在图2-16所示的执行现场，PSR寄存器的低5位为
10011，代表处理器的操作模式是管理员模式。
图2-16 32位ARM处理器执行现场
与x86类似，ARM架构也定义了4种特权级别，PL0～PL3，不过
PL0级别最低，PL3级别最高，刚好与x86相反。在ARM架构中，CPU的
当前特权级别是由CPU的工作模式决定的，表2-6的第5列给出了CPU运
行在不同工作模式时的对应特权级别。此外，ARM手册中还经常出现
EL0、EL1、EL2和EL3这样的写法，代表的是4种异常级别（exception
level），也是EL0最低，EL3最高。根据ARMv8手册，异常级别决定了
特权级别，在ELn执行时的特权级别就是PLn。因此，大多数时候二者
是一一对应的。
除了工作模式和特权级别，ARM架构还有一个关键概念称为状态
（state），包括如下4种。
指令集状态：记录和指示当前使用的指令集，以ARMv7为例，共
支持4种指令集（ARM、Thumb、Jazelle和 ThumbEE），名为
ISETSTATE的内部寄存器维护着当前的指令集状态。
执行状态：记录和指示指令的执行状态，控制着指令流的解码方式
等，下文介绍的程序状态寄存器包含了大多数执行状态信息。
安全状态：当处理器支持安全扩展或者虚拟化扩展时，安全状态记
录着当前代码的安全状态。
调试状态：当CPU因为调试目的而被暂停（halted）时进入所谓的
调试状态，否则处于非调试状态。
我们将在第7章中详细介绍专门为调试目的设计的调试状态。
2.9.4 32位架构核心寄存器
前面提到，RISC指令集的处理器通常有数量较多的寄存器。ARM
架构也不例外。在32位的ARM架构中，核心寄存器（core register）一
般有37个或者更多，这视处理器实现的功能多少而定。所谓核心寄存器
就是指ARM处理器内核执行常规指令时使用的寄存器，不包括用于浮
点计算和SIMD技术的特殊寄存器，也可以理解为ARM的核心处理器单
元（PE）中的寄存器，不包括外围的协处理器中的寄存器。下面分几组
分别介绍这些寄存器。
（1）R0～R7：这8个寄存器是最普通的，所有模式都可以访问和
使用。在函数返回时，常常使用R0寄存器传递函数返回值，其作用相当
于x86的EAX。
（2）R8～R12：这5个寄存器有两份，一份是专门给FIQ模式用
的，另一份是所有其他模式都可以使用的。在ARM手册中，这种特征
的寄存器有个专门的称呼，叫banked register。bank的本意是银行和存
款，在这里的意思是“有备份的”。举例来说，当CPU执行用户代码时，
来了个高优先级的中断，于是CPU要进入FIQ模式运行，对于没有备份
的寄存器，比如R0～R7，如果中断处理函数要使用，那么必须在中断
返回前恢复这些寄存器，但对于R8～R12则不同，因为FIQ模式有自己
的R8～R12，所以使用这几个寄存器时实际使用的是自己那一份，不必
担心会影响用户模式的R8～R12。这样的寄存器技术在安腾等CPU中也
有使用，有时称为影子寄存器（shadow register），好处是可以降低处
理中断的开销、提高性能。
（3）R13：用作栈指针（Stack Pointer，SP），它也是banked
register，而且所有模式都有一份，共有6个（有虚拟化支持时再多一
个），分别用于用户、IRQ、FIQ、未定义、中止和管理员模式。在
ARM手册中，有时用SP_usr、SP_svc这样的写法来表示不同模式下的SP
寄存器。
（4）R14：又称为Link Register，简称LR，在调用子函数时，ARM
处理器会自动将子函数的返回地址放到这个寄存器中。如果子函数是所
谓的叶子函数（不再调用子函数），那么就可以不必额外保存返回地址
了，比如下面的KeGetCurrentStackPointer函数只有两条指令，把栈指针
寄存器赋给r0，然后直接使用bx lr跳转回父函数。
nt!KeGetCurrentStackPointer:
81034e68 4668     mov         r0,sp
81034e6a 4770     bx          lr
如果是非叶子函数，那么通常在函数开头将LR的值保存到栈上。
以下面的KeEnterKernel Debugger函数为例，函数入口处的push指令
（支持一次压入多个寄存器）便是把R11和LR寄存器的值都保存到栈
上。其后的mov指令把栈指针的值放到R11中，用作栈帧基地址（相当
于x86的EBP）。
nt!KeEnterKernelDebugger:
81152f40 e92d4800 push        {r11,lr}
81152f44 46eb     mov         r11,sp
LR也具有bank特征，每个模式都有一个。
（5）R15：程序指针寄存器（Program Counter，PC）。当执行
ARM指令（每条指令4字节）时，它的值为当前指令的地址加8；当执
行Thumb指令时，它的值为当前指令的地址加4，其设计原则是让PC指
向当前指令后面的第二条指令。
（6）CPSR：当前程序状态寄存器（Current Program Status
Register），记录着处理器的状态和控制信息，其作用与x86的标志寄存
器（EFLAGS）类似。图2-17是来自ARMv7架构手册的CPSR寄存器格
式定义。其中的M[4:0]代表当前的操作模式，其编码见表2-6。J位和T位
一起来指示当前的指令集状态，00代表ARM指令集，01代表Thumb指令
集，10代表支持Java字节码的Jazelle指令集，11代表更好支持动态语言
的ThumbEE指令集。例如，在图2-16所示的执行现场中，T位为1，代表
当时的指令集是Thumb指令集。A、I、F这3个位都是所谓的屏蔽位，分
别控制异步中止、普通中断和高优先级中断，为1时屏蔽相应中断，为0
时不屏蔽。E位用来控制加载和存储数据时的字节顺序，称为
Endianness，为0时代表小端（little-endian），为1时代表大端（big-
endian）。GE[3:0]位的全称是Greater than or Equal标志，供SIMD指令做
并行加减法时使用。IT[7:0]是供Thumb指令集中的If-Then指令使用的执
行状态位。Q位是累加饱和（cumulative saturation）状态位。最高的N、
Z、C、V这4个位是所谓的条件状态位，某些指令用它们指示结果，它
们代表的状态依次为负数（Negative）、0（Zero）、进位（Carry）和
溢出（Overflow）。
图2-17 当前程序状态寄存器（CPSR）的位定义
（7）SPSR：保存的程序状态寄存器（Saved Program Status
Registers），具有bank特征，每个异常模式都有一个，用来保存异常发
生前的CPSR。在ARM手册中，常用SPSR_abt、SPSR_fiq这样的写法来
代表不同模式下的SPSR寄存器。
来自ARM手册的图2-18以表格形式呈现了32位ARM架构的所有核
心寄存器，PC寄存器那一行上面的寄存器一般统称为通用（general-
purpose）寄存器，下面的统称为特殊（special-purpose）寄存器。ARM
手册特别指出了空单元格的含义，当CPU在所在列对应的模式执行时，
可以使用所在行对应的用户模式寄存器。举例来说，当CPU在所有非用
户模式下执行时，都可以使用PC寄存器（名义上属于用户模式）。类
似的系统模式没有专属自己的寄存器，在该模式下执行时，使用的都是
用户模式的寄存器。
对于图2-18中的APSR，从软件接口的角度来看，它不是单独的寄
存器，只是CPSR寄存器中的NZCVQ和GE位。这些位是应用程序可写
的，名字中的A是Application的缩写。
图2-18 32位ARM架构核心寄存器一览
2.9.5 协处理器
ARM的授权模式要求ARM架构高度模块化，以便客户根据需要裁
剪定制，选择需要的模块。协处理器可谓是实现模块化的一种方式。所
谓协处理器通常是指用来协助主CPU完成某一方面辅助功能的处理器。
比如x86架构中用于做浮点计算的x87就是协处理器的典型例子。ARM
架构支持多达16个协处理器。每个协处理器都有唯一的编号，前面冠以
CP来表示。其中CP8～CP15供ARM架构使用，CP0～CP7供ARM的客户
使用。目前，CP15一般用作包含内存管理单元的系统控制器，CP14用
作调试控制器，CP10和CP11分别用作SIMD和浮点计算。
主CPU和协处理器之间一般通过接口寄存器来通信，这些接口寄存
器通常用C0～C15表示。可以使用MCR和MRC指令来读写协处理器的
接口寄存器，前者为读（Move to ARM Core），后者为写（Move to
Coprocessor）。
MRC指令的一般格式为：
MRC ,,,,{,}
其中coproc用来指定要访问的协处理器，Rt用来指定接收数据的
ARM寄存器，CRn和CRm用来指定要访问的协处理器寄存器，opc1和可
选的opc2用来指定协处理器定义的操作码，也可以把CRn、CRm、opc1
和opc2看作一个整体来理解，它们共同指定要访问的协处理器寄存器。
MCR指令的格式与MRC类似。
举例来说，以下两条指令分别用来读写CP15的性能控制寄存器
（PMCR）：
MRC p15, 0, , c9, c12, 0 ; Read PMCR into Rt
MCR p15, 0, , c9, c12, 0 ; Write Rt to PMCR
再如，在下面所列MiFlushAllPages函数的开头的几条指令中，第4
条便是访问CP15的MRC指令，查找ARM手册中关于CP15协处理器寄存
器的定义（ARMv7，B3-1486）可以知道，该指令访问的是线程ID寄存
器（User Read-Only Thread ID Register）。根据第3个操作数，读到的结
果会被写入R3寄存器。
nt!MiFlushAllPages:
81164984 e92d4878 push        {r3-r6,r11,lr}
81164988 f10d0b10 add         r11,sp,#0x10
8116498c 25ff     movs        r5,#0xFF
8116498e ee1d3f70 mrc         p15,#0,r3,c13,c0,#3
为了便于从高层语言编写的程序中访问协处理器，开发工具通常会
提供便捷的方法，比如微软的编译器提供了如下内建函数（intrinsic）
来向协处理器写数据：
Void _MoveToCoprocessor( unsigned int value,  unsigned int coproc,     uns
igned int opcode1, unsigned int crn, unsigned int crm, unsigned int opcode
2);
为了简化代码，Windows 10 DDK中定义了很多像下面这样的宏：
#define CP15_TPIDRURO 15, 0, 13, 0, 3
有了这样的宏后，只要这样写代码就可以了：