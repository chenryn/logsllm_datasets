title:Cobra: Fine-grained Malware Analysis using Stealth Localized-executions
author:Amit Vasudevan and
Ramesh Yerraballi
Cobra: Fine-grained Malware Analysis using Stealth Localized-executions
Amit Vasudevan and Ramesh Yerraballi
Department of Computer Science and Engineering
Box 19015, 416 Yates St., 300 Nedderman Hall, Arlington, TX - 76019, USA.
University of Texas at Arlington
{vasudeva, ramesh}@cse.uta.edu
Abstract
Fine-grained code analysis in the context of malware is
a complex and challenging task that provides insight into
malware code-layers (polymorphic/metamorphic), its data en-
cryption/decryption engine, its memory layout etc., important
pieces of information that can be used to detect and counter
the malware and its variants. Current research in ﬁne-grained
code analysis can be categorized into static and dynamic ap-
proaches. Static approaches have been tailored towards mal-
ware and allow exhaustive ﬁne-grained malicious code analy-
sis, but lack support for self-modifying code, have limitations
related to code-obfuscations and face the undecidability prob-
lem. Given that most if not all malware employ self-modifying
code and code-obfuscations, poses the need to analyze them
at runtime using dynamic approaches. However, current dy-
namic approaches for ﬁne-grained code analysis are not tai-
lored speciﬁcally towards malware and lack support for multi-
threading, self-modifying/self-checking code and are easily de-
tected and countered by ever-evolving anti-analysis tricks em-
ployed by malware.
To address this problem we propose a powerful dynamic
ﬁne-grained malicious code analysis framework, codenamed
Cobra, to combat malware that are becoming increasingly
hard to analyze. Our goal is to provide a stealth, efﬁcient,
portable and easy-to-use framework supporting multithread-
ing, self-modifying/self-checking code and any form of code
obfuscation in both user- and kernel-mode on commodity op-
erating systems. Cobra cannot be detected or countered and
can be dynamically and selectively deployed on malware spe-
ciﬁc code-streams while allowing other code-streams to exe-
cute as is. We also illustrate the framework utility by describ-
ing our experience with a tool employing Cobra to analyze a
real-world malware.
1. Introduction
Malware — a term used for viruses, trojans, spywares or
any malicious code — is widespread today. Malware analy-
sis — a complex process employing various coarse- and ﬁne-
grained analysis methods — provides insight into malware
structure and functionality and facilitates the development of
an antidote. For example, the W32/MyDoom [38] trojan and
its variants propagate via e-mail and download and launch ex-
ternal programs using the network and registry. Such behav-
ior, which includes the nature of information exchanged over
the network, the registry keys used, the processes and ﬁles cre-
ated etc., is inferred by employing coarse-grained analysis per-
taining to process, network, registry, ﬁle and other related ser-
vices of the host operating system (OS). Once such behavior is
known, ﬁne-grained analysis is employed on the identiﬁed ar-
eas to reveal details such as the polymorphic and/or metamor-
phic code layers of the trojan, its data encryption and decryp-
tion engine, its memory layout etc.
Fine-grained malware analysis is a challenging task that
provides important pieces of information that are key to build-
ing a blueprint of the malware core structure and functioning,
that aids in the detecting and countering the malware and its
variants. As an example, the W32/MyDoom trojan with vari-
ants commonly known as W32/MyDoom.X-MM (where X
can be A, B, R, S, G etc.) share the same metamorphic code
layers, encryption/decryption engine and similar anti-analysis
schemes. The Netsky [15], Beagle [24] and Sobig [35] worms
are some other examples of how malware are coded in an it-
erative fashion to add more features while retaining their core
structure. Thus, once the core structure of a malware is doc-
umented, it becomes easy to tackle the rest of its variants as
well as other malware which share a similar structure. Also,
with malware writers employing more complex and hard to an-
alyze techniques, there is need to perform ﬁne-grained analy-
sis of malicious code to counter them effectively.
Current research in malware analysis can be broadly cate-
gorized into static and dynamic approaches. Static approaches
allow exhaustive ﬁne-grained analysis because they are not
bound to a speciﬁc execution instance. They allow detection
of malicious code without actually running the program, en-
suring that the malices discovered will never be executed and
incur no runtime overhead. In spite of such powerful proper-
ties, static analysis has some limitations. With static analysis
there is the problem that the analyzed code need not be the
one that is actually run; some changes could be made between
analysis and execution. This is particularly true with polymor-
phism [56, 47] and metamorphism [48] that are techniques
employed by most if not all current generation malware. Also it
is impossible to statically analyze certain situations due to un-
decidability (eg. indirect branches). Further, static code analy-
sis also has limitations related to code obfuscation, a technique
used by malware to prevent their analysis and detection.
Dynamic approaches overcome these limitations by analyz-
ing the code during runtime, ensuring that the the analyzed
code is the one that is actually run without any further alter-
ations. Though there have been several research on dynamic
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
coarse-grained malware analysis [23, 42, 46, 21, 51], not much
has been published about dynamic ﬁne-grained malware anal-
ysis. Currently dynamic ﬁne-grained malware analysis can be
achieved by employing debuggers and/or ﬁne-grained instru-
mentation frameworks. When using a debugger such as Soft-
ice [20], WinDBG [43] etc., the basic approach is to set break-
points on identiﬁed areas and then trace the desired code-
stream one instruction at a time to glean further information.
Alternatively one could also employ a ﬁne-grained instrumen-
tation framework such as Pin [34], DynamoRIO [8] etc., for
automated tracing of code-streams. However, these tools are
not equipped to handle malicious code and have severe short-
comings in the context of malware.
Current debugging and ﬁne-grained instrumentation tech-
niques can be easily detected and countered by the execut-
ing malware code-streams. As an example, W32/HIV [37],
W32/MyDoom [38], W32/Ratos [49], and their variants em-
ploy techniques such as code execution timing, where the mal-
ware time their executing code thereby easily detecting that
they are being analyzed (since debugging and/or automated
code tracing incur latency that is absent during normal exe-
cution). Further they contain ad-hoc detection schemes against
popular debuggers such as Softice, WinDBG, etc. Current de-
bugging and ﬁne-grained instrumentation techniques do not
carry support for self-modifying and/or self-checking (SM-
SC) code. Most if not all malware are sensitive to code mod-
iﬁcation, employing subtle anti-analysis techniques and code
obfuscations that defeat breakpoints in debugging and the pro-
cess of automated code tracing using ﬁne-grained instrumenta-
tion frameworks. For example, W32/MyDoom and W32/Ratos
employ integrity checking of their code-streams with pro-
gram counter relative code modiﬁcation schemes which ren-
der software breakpoints and current ﬁne-grained instrumenta-
tion frameworks unusable.
Malware that execute in kernel-mode are even tougher
to analyze using current dynamic ﬁne-grained techniques,
since they have no barriers in terms of what they can ac-
cess. For example, W32/Ratos employs a multithreaded poly-
morphic/metamorphic code engine running in kernel-mode,
and overwrites the interrupt descriptor table (IDT) with val-
ues pointing to its own handlers. Current ﬁne-grained in-
strumentation frameworks do not handle kernel-mode code
and do not carry adequate support for multithreading. Cur-
rent debugging techniques provide kernel-mode code sup-
port but do not support multithreading in kernel-mode.
Furthermore,
trend in malware has been to em-
ploy debugging mechanisms supported by the underlying
processor within their own code,
thereby effectively pre-
venting analysis of their code using current debugging tech-
niques. Examples include W32/Ratos, which employs the
single-step handler (used for code tracing) to handle its de-
cryption in kernel-mode and W32/HIV which uses debug
registers (used for hardware breakpoints) for its internal com-
putation. This situation calls for a dynamic ﬁne-grained
code analysis framework speciﬁcally tailored towards mal-
ware.
recent
This paper presents the concept of stealth localized-
executions and presents Cobra, a realization of this concept,
that enables dynamic ﬁne-grained malware analysis in com-
modity OSs in a completely stealth fashion. Our goals are to
provide a stealth, efﬁcient, portable and easy-to-use frame-
work that supports multithreading, SM-SC code and code
obfuscations in both user- and kernel-mode while allowing se-
lective isolation of malware code-streams. By stealth we mean
that Cobra does not make any visible changes to the executing
code and hence cannot be detected or countered. The frame-
work employs subtle techniques such as block-coalescing
and skipping to provide an efﬁcient supervised execution en-
vironment. Cobra currently runs under the Windows (9x,
NT, 2K and XP) and Linux OSs with minimal depen-
dency on the host OS and employs an architecture speciﬁc
disassembler for its inner functioning. This makes the frame-
work portable to other platforms (OS and architecture) with
ease. The API provided by Cobra is simple, yet powerful, mak-
ing the framework easy-to-use. Analysis tools are usually
coded in C/C++ using the framework API. The API is ar-
chitecture independent while allowing the tools to access
architecture speciﬁc details when necessary. The frame-
work supports what we call selective-isolation,
that al-
lows ﬁne-grained analysis to be deployed on malware speciﬁc
code-streams while allowing normal code-streams to exe-
cute as is. The framework also allows a user to tie speciﬁc
actions to events that are generated during the analysis pro-
cess in real-time. To the best of our knowledge, Cobra is
the ﬁrst ﬁne-grained malware analysis framework that pro-
vides a highly conducive environment to combat malware
which are ever-evolving and increasingly becoming hard-
ened to analysis.
This paper is organized as follows: We begin by discussing
related work on malware analysis and compare them with Co-
bra in Section 2. We then present an overview of Cobra in Sec-
tion 3. We follow this with a detailed discussion on design and
implementation issues in Section 4. In Section 5, we discuss
our experience with one of our tools employing Cobra to ana-
lyze a real-world malware and present some performance num-
bers for the framework in Section 6. Finally, we conclude the
paper in Section 7 summarizing our contributions with sugges-
tions for future work.
2. Background and Related Work
A malware is a program that can affect, or let other pro-
grams affect, the conﬁdentiality, integrity, the data and control
ﬂow, and the functionality of a system without explicit knowl-
edge and consent of the user [4]. A classiﬁcation of malware
according to its propagation method and goal can be found
in [39, 7]. Given the fact that malware is widespread today
and knowing the devastating effects that malware can have in
the computing world, detecting and countering malware is an
important goal. To successfully detect and counter malware,
one must be able to analyze them in both a coarse- and ﬁne-
grained fashion — a complex process that is termed malware
analysis. In this section we discuss some of the existing re-
search in the area of malware analysis and compare them with
Cobra. A complete annotated bibliography of papers on mal-
ware analysis and detection can be found in Singh and Lakho-
tia [45]. Current research in malware code analysis and detec-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
tion can be broadly categorized into static and dynamic ap-
proaches
[4]. Both methods have their advantages and dis-
advantages and are complimentary. Static approaches to mal-
ware analysis can be used ﬁrst, and information that cannot be
gleaned statically can then be dynamically acscertained.
Static approaches to malware analysis extend techniques re-
lated to verifying security properties of software at a source
level [1, 6, 9, 10, 26, 32] to binary (since for a malware, in most
if not all cases, there is no source-code availability). Bergerson
et al. [5, 3] present techniques that disassemble the binary and
pass it through a series of transformations that aid in getting
a high-level imperative representation of the code. The binary
is then sliced to extract the code fragments critical from the
standpoint of security and malicious code. Gifﬁn et al. [22] dis-
assemble a binary to remotely detect manipulated system calls
in a malware. Many malware detection techniques are based
on static analysis of executables. Kruegel et al. [28] employ
static binary analysis to detect kernel-level rootkits. SAFE [12]
and Semantic-Aware Algorithm [14] are other examples of
malware detection algorithms employing similar static analy-
sis techniques. Static approaches allow exhaustive ﬁne-grained
analysis because they are not bound to a speciﬁc execution in-
stance. They enable detection of malicious code without ac-
tually running the program. Therefore, the malices discovered
will never be executed. On the performance side, there is no
runtime overhead associated with a static analysis. After just
one analysis, the program can run freely. In spite of these ben-
eﬁcial properties, there are some limitations. The main prob-
lem with static code analysis is that the analyzed code need
not be the one that is actually run; some changes could be
made between analysis and execution. This is particularly true
in techniques such as polymorphism [56, 47] and metamor-
phism [48] that are ubiquitous in most malware code-streams.
Static approaches also have limitations related to code obfus-
cations [18, 19, 55]. They employ a dissassembler as an es-
sential step in the analysis process. Linn and Debray [31] and
Christodorescu and Jha [13] demonstrate that simple obfusca-
tions can thwart the dissassembly process. While Kruegel et
al. [27] present techniques for disassembling obfuscated exe-
cutables, they are unable to handle situations such as indirect
obfuscation [41, 53], instruction overlap [17] etc.
Dynamic approaches analyze malware code during runtime.
Dynamic approaches incur a runtime overhead and are non-
exhaustive. However, they overcome the main limitation of
static approaches in ensuring that the the analyzed code is the
one that is actually run, without any further alterations, thereby
supporting SM-SC code and code obfuscations. Dynamic ap-
proaches can further be categorized into coarse-grained and
ﬁne-grained approaches. Coarse-grained dynamic approaches
are very useful in capturing the behavior of a malware at a high
level. Janus [23] provides a secure environment to execute un-
trusted applications. It intercepts and ﬁlters dangerous system
calls under Solaris to reduce the risk of a security breach by
restricting the program’s access to the operating system. Da-
Mon [21] is a dynamic monitoring system uses a similar tech-
nique to dynamically enforces a security policy to stop cer-
tain malicious actions on resources such as ports, registry, pro-
cesses etc. SPiKE [51] is a stealth software framework devel-
oped by us, that works on the principle of dynamic monitoring,
to log activity of malware code-streams. Most network intru-
sion detection systems [42] and honeypots [46] also hinge on
dynamic coarse-grained analysis for their functioning.
In contrast, ﬁne-grained dynamic approaches help to under-
stand the inner structure of the malware in terms of its runtime
code envelopes, its data encryption/decryption engine, mem-
ory layout, anti-analysis techniques etc. Though there have
been several research on dynamic coarse-grained malware
analysis, not much has been published about dynamic ﬁne-
grained malware analysis. Cohen [16] and Chess-White [11]
propose a virus detection model that executes in a sandbox.
However, their model is not generic and does not allow ﬁne-
grained analysis at a level that can be used to document the in-
ternal workings of a malware. Debuggers such as Softice [20],
WinDBG [43], GDB [33] etc. enable dynamic ﬁne-grained
analysis in both user- and kernel-mode. Though current de-
buggers to some extent, support self-modifying code and code
obfuscations, they are not tailored speciﬁcally towards mal-
ware analysis and fall prey to several anti-debugging tricks em-
ployed by them [50]. While code analysis using a debugger
is manual (one has to trace instructions manually), tools such
as Pin [34], Valgrind [8], DynamoRIO [40], Strata [44], Diota
[36] etc. enable automated code tracing by employing a virtual
machine approach. However, these tools are designed for nor-
mal program instrumentation and hence do not carry support