debug information that comes with the kernel binary.
As a result, by intercepting this system-call, XenFIT knows which
ﬁle is removed.
Likewise, each breakpoint has a separate breakpoint-handler, which
is called when the corresponding breakpoint is hit. Each breakpoint-
handler does different thing, but with the common object: to col-
lect the useful information about the activities at the breakpoints,
so XenFIT can rely on these information to detect the intrusion.
3.2.4 Correlate for further information
In the above example of the unlink system-call, we can see that
XenFIT can only get the ﬁle-name as well as the result of the
system-call, but nothing else. Even worse, in case of other system-
calls such as write, if we rely on the function’s code as in the above
case, we can only get the ﬁle-descriptor of the affected ﬁle, but
not its ﬁle-name9. To gather more useful information, we must
correlate with information from other system-calls, as well as get
information from other kernel objects. That is why we must pay
attention to open and close system-calls.
• Open system-call: By intercepting this this system-call, we
knows which ﬁle-name corresponds to which ﬁle-descriptor.
XenFIT saves these kind of information, so it can correlate
9Many ﬁle-system related system-calls such as write work on ﬁle-
descriptor instead of ﬁle-name.
198
binaries (/boot/*) and system ﬁles (/sbin) can have this pol-
icy.
• Attributes: Only modiﬁcations of ownership and access per-
missions will be checked. The typical ﬁles are /etc/mtab,
/etc/resolv.conf, which can be changed dynamically at runt-
time by system.
With each policy ﬁle, XenFIT assigns a separate ﬁle, and this ﬁle
lists all related the ﬁles and directories that are applied that policy
to monitor. To be ﬂexible, XenFIT supports wild-card paths, so the
path such as /etc/httpd/* can be speciﬁed.
At run-time, xenﬁtd veriﬁes an event sent from a domain against
the corresponding policies, and if it ﬁnds the violation, a report is
generated. The content of the report provides detailed information
to help the administrator carry out the investigation. For exam-
ple Fig.3 demonstrates our experimental: our test program named
test xenﬁt tried to overwrite remove the ﬁle /bin/ps, which is listed
in the ReadOnly policy. Such an action violates the deﬁned pol-
icy, so despite the action successed, we still get the violation report
from XenFIT.
[2006-9-31 05:34:25][small] WRITE /bin/ps,
process 4013, user-id 0
Figure 3: An example report on the security violation
The above report tells us that the domain had the integrity vi-
olation is small, and the user caused the alarm is root, which has
user-id of 0. This user tried to overwrite to the system ﬁle ps, which
is widely used to show all the active processes in the system. The
event is quite suspicious, and might indicate that he is an intruder
trying to trojan the ps to hide his malicious backdoor process. This
is a popular trick of user-level rootkit. The administrator should
take a closer look at other log records to conﬁrm this incident.
3.2.6 Report the Intrusion
By default XenFIT writes down the report on security violations
to separate logging ﬁles for each domain, but it can also log to the
system log (which is usually syslogd). Besides, to give the admin-
istrator more details, xenﬁtd can optionally save all the event data
it gets from DomUs (including “benign” event) to separate logging
ﬁles. Once the incident happens, the administrator can inspect the
full logging to have better view on what the attacker has done after
he broken in. However, the administrator might wish to get notiﬁed
immediately on the intrusion. To achieve this goal, we suggest to
use another log-ﬁle monitoring utilities, such as swatch ([3]). These
tools can monitor the logging reports generated by xenﬁtd and sig-
nals the administrator in real-time by various ways: sends an email,
plays an alarm sound, or even send a SMS to his hand-phone. The
overall scheme to chain xenﬁtd and a log-ﬁle monitoring tool is
described in Fig.4
3.3 XenFIT Implementation
At the moment XenFIT is only implemented in Linux. The rea-
son is that other Os-es (like FreeBSD and NetBSD) are not ready
for Xen 3.0.2, the most advanced Xen version we are working
on, yet. So in this part we will present XenFIT’s implementation
speciﬁcally for Linux environment. The same techniques can be
applied for others, however.
3.3.1 Handling Breakpoints
199
Figure 4: Tool chain scheme to report the security violation in
real-time
xenﬁtd is a daemon process running in user-space of Dom0. It
watches for the new DomU to boot, then patches the kernel memory
of DomU by writing the breakpoint instructions into pre-determined
addresses. To extract the address of related line of kernel source
code, which is used as the address of the breakpoint, we developed
a small tool that deals with DWARF information in kernel binary
ﬁle. Before patching breakpoints, xenﬁtd saves the original bytes
at breakpoint addresses, so it can recover them later. Because each
breakpoint must be processed in a different way, each is attached
with a breakpoint-handler speciﬁcally deﬁned for it. After patching
step, xenﬁtd enables the debugging mode of the DomU, then waits
for the debugging events.
When a breakpoint is hit inside the kernel of DomU, the hyper-
visor pauses the DomU for xenﬁtd to examine and it sends a debug-
ging event to notiﬁed xenﬁtd. Receiving the signal, xenﬁtd comes
up to handle the breakpoint in the following sequences:
(1) First, xenﬁtd executes the corresponding breakpoint-handler.
Overwrite the breakpoint with the original byte we saved when
DomU ﬁrst booted up. Then xenﬁtd forces DomU to execute
the original instruction at the breakpoint by decreasing the in-
struction pointer 10 by 1. The reason is that the breakpoint in-
struction is exactly 1 byte length. Besides, xenﬁtd puts DomU
into the single-step mode by turning on the TF ﬂag. Finally,
xenﬁtd resumes the DomU
(2) When the DomU resumes, it execute the original code at the
place of the breakpoint. However, because it is in single-step
mode, the control is again transferred to xenﬁtd and DomU is
paused again. This time xenﬁtd recovers the breakpoint by
overwriting the breakpoint instruction on the breakpoint ad-
dress. After that, xenﬁtd disables the single-step mode by turn-
ing off the TF ﬂag, then resumes DomU. DomU continues to
execute normally until it hits another breakpoint, and the same
procedure repeats.
3.3.2 Access DomU’s Kernel Memory
In XenFIT architecture, we need to read and write to DomU’s
kernel memory. In order to access to a speciﬁc virtual address of
DomU, we must ﬁrst translate it into physical address. Currently
Xen support several kinds of architecture: x86 32, x86 32p and
x86 64, and each of these platforms has different schemes of paging
memory. Hence XenFIT must detect the underlying hardware, and
then translates the virtual memory accordingly by traversing the
page table tree.
To traverse the page table tree, it is imperative to know the phys-
ical address of the page directory. In Xen, we can have the vir-
tual control register cr3 of each virtual CPU of the VM by getting
corresponding CPU context via Xen function xc vcpu getcontext()
10The EIP register in Intel platform.
4. DISCUSSION
To make XenFIT work, the VM’s kernel (DomU’s kernel) must
be compiled with kernel debugging information. That is simply the
only requirement for VM’s kernel, and can be easily done by enable
an option at compile time.
We suppose that in our scheme, Dom0 is securely protected 14
such that the attacker has no chance to exploit our immune data,
even if he totally takes over his virtual box.
As we propose XenFIT to be able to function stealthily, we should
remove all the evidence of its existence. In DomU, there might be
one more place the intruder can investigate to discover XenFIT’s
presence: the kernel binary and kernel symbol ﬁles. Fortunately, in
Xen architecture DomU is run by loading the kernel from Dom0,
so we will not need to have kernel binary ﬁle, together with kernel
symbol ﬁles in DomU’s ﬁle system.
Last but not least, all the path to the kernel memory should be
prohibited, as the intruder might somehow get the root access in
DomU and use that privilege to access the kernel internal and modi-
ﬁes the breakpoints to disable XenFIT. In order to prevent this prob-
lem, DomU’s kernel should be compiled with /dev/{kmem,mem,port}
removed ([16]), and the ability of loading kernel module at run-
time should be eliminated, too.
In the current solution, xenﬁtd has a difﬁculty in understanding
the domain-level semantic got from DomU. For example, the event
information provides who (represented by user-id), generated the
event. Obviously it is better if we have the information about user-
name, not user-id (which is only a number). Unfortunately the ker-
nel is only aware of user-id, while user-name is something only
available in user-land. In addition, the user-id is only meaningful
in the domain that produces the event, but not in Dom0. Conse-
quently, from Dom0 the administrator can only identify the possi-
ble attacker by his user-id, but not by his user-name. This trouble
might be solved by letting Dom0 keeps the user database of DomU
(the /etc/passwd ﬁle of DomU is suitable for this purpose). How-
ever this solution is far from perfect, because it is hard to keep the
database in Dom0 updated. So at the moment, we are temporarily
content with the current situation, and look forward to improving it
in the future.
5. EVALUATION
This section ﬁrst presents the security evaluation results of Xen-
FIT, then measures the performance impact of XenFIT.
5.1 Security Evaluation
This section presents the security evaluation results of XenFIT:
the evaluation aims to test 6 popular rootkits and back-doors to see
if they are detected by XenFIT. These rootkits and backdoors are
installed on a protected DomU. Rootkits are categorized as user-
level type if they do not modify the system kernel, and kernel-level
type if they require to alter the kernel.
The user-level rootkits we choose are: t0rn ([12]), lrk5 ([18]),
dica ([8]) and SAdoor ([5]) These rootkits infect quite a few critical
ﬁles the system, among of them are /usr/bin/{ls,netstat,ps}.
To detect these rootkits, we put the above system ﬁles in the
ReadOnly policy. With this setting, XenFIT is able to detect imme-
diately the illegal modiﬁcations to the above binaries and alerts the
administrator in real-time.
Regarding the kernel-level rootkit, we choose knark ([11]) and
adore-ng ([11]). These rootkits infect the kernel and open hidden
14Thus Dom0 might be considered to belong to the Trusted Comput-
ing Base (TCB), the core component required to enforce the system
security.
([24]). Besides, as Xen supports several architectures such as x86,
PAE and x86 64 (thus different page-table formats), XenFIT must
handle the page-table accordingly to convert the virtual address to
physical address.
After that, XenFIT accesses the memory of DomU by mapping
the physical address with the function named xc map foreign range()
([24]). Then it goes on reading or writing to the mapped memory
11
3.3.3 Parsing Kernel Objects
A key challenge in inspecting the memory of VM is how to
bridge the semantic gap between the raw memory and kernel ob-
jects. To do that XenFIT must be able to have a good knowl-
edge about OS structure. And to understand in detail the layout
of DomU’s kernel and kernel objects, XenFIT must know exactly
their address and structure.
* Object’s address: Each object in the kernel is located at a
certain memory address, and kept unchanged during its life-
time12. To watch the integrity of the object, it is mandatory to
know its address. XenFIT ﬁnds the address of Linux kernel
objects via the kernel symbol ﬁle System.map coming with
the kernel binary.
* Object structure: To know only the object address is far
from enough. For example, if we want to get the list of ker-
nel modules, we can ﬁrst reach the address of the ﬁrst kernel
module, the Linux variable modules. But then to get the next
kernel module pointed by a ﬁeld named list.next in the mod-
ule structure, we must know the relative address of this ﬁeld
in module structure. This job is not trivial, as the module
structure depends on kernel compiled option, and it might
also change between kernel versions13.
To extract data about kernel-types, we leverage part of code
of LKCD project ([17]). LKCD is an open source tool to
save and analyze the Linux kernel dump. LKCD can parse
the dump thanks to an internal library libklib, which extract
all the information it needs from the DWARF data in the ker-
nel binary as well as from the kernel symbol ﬁle. This library
parses the kernel symbols and extracts kernel-types from de-
bugged kernel binary, then caches the data in the memory for
its tool, lcrash to use. Besides, libklib also interprets lcrash
user command, and serves as a disassemble engine for vari-
ous hardware platforms. Because of these reasons, libklib is
a very big and complicated code, thus cannot be employed as
it is for XenFIT. Another problem is that libklib is designed
to analyze kernel dump, but not to cope with hostile data.
So if somehow the attacker modiﬁes the kernel structure in
malicious way, libklib might crash.
In our implementation, we only reused part of libklib, in
which we only keeps the code that extracts and parses kernel-
type information from kernel binary. The library is also hard-
ened to resist potential attacks. Finally, our kernel parse code
is around only 14000 lines of C source code, which is about
30% size of the original libklib.
11This depends on the mapped right is PROT READ (read) or
PROT WRITE (write).
12Note that Linux kernel memory is never swapped out.
13Linux kernel never tries to keep compatible between different ver-
sions. The Linux kernel developers argue that backward compati-
bility might block its continuous innovation.
200
process on policy in a user-space process in Dom0, and that makes
it very easy to modify policy or even xenﬁtd itself without having
to reboot the whole system.
Reliable access to data is a prerequisite for all the computer sys-
tems. Data might be corrupted due to hardware or software mal-
function, malicious activities or inadvertent. The most popular in-
tegrity assurance mechanism occur at ﬁle-system level: all the on-
disk ﬁle-systems perform off-line consistency checking with user-
space programs like fsck, which is usually run at start-up to ﬁx un-
clean shutdown. Recent advanced ﬁle-systems support journaling
feature to avoid the unnecessary checkup. However this class of in-
tegrity checking purely aims to ﬁx the inconsistency errors, but not
to cope with security incidents, so they are not the research topic of
this paper.
Regarding the Intrusion Detection System (IDS), there are few
ways to classify them. One is to consider the source of data used
for the detection: if the tool uses the information derived from the
local host, it is called host-based IDS, or HIDS in short. In contrast
if it captures data from the local network, it is of network-based
IDS type, or NIDS.
The HIDS resides on a system and provides protection for a that
particular computer. The HIDS relies on tracking the operating
system activities. Meanwhile the NIDS gathers and analyzes the
network packets of the local network to detect the malicious trafﬁc,
in order to protect all the machines in the same network segment.
The most popular NIDS in the academia community is the open-
source Snort IDS ([23]).
Our XenFIT solution is made to detect the tampering on the ﬁle-
system level, so it is of the HIDS type. Hence in this paper we only
focus on the ﬁle-system level HIDS solutions together with their
problems and discuss the solutions to improve them.
Because ﬁle-system integrity is important to the overall security,
it is not surprised that there are many paper-works and resulted
tools on the topic. In general we can categorize them into 2 kinds: