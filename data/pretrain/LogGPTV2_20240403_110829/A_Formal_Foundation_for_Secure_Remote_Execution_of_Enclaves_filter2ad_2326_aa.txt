title:A Formal Foundation for Secure Remote Execution of Enclaves
author:Pramod Subramanyan and
Rohit Sinha and
Ilia A. Lebedev and
Srinivas Devadas and
Sanjit A. Seshia
A Formal Foundation for Secure Remote Execution of Enclaves
Pramod Subramanyan
University of California, Berkeley
PI:EMAIL
Rohit Sinha
University of California, Berkeley
PI:EMAIL
Ilia Lebedev
Massachusetts Institute of Technology
PI:EMAIL
Srinivas Devadas
Massachusetts Institute of Technology
PI:EMAIL
Sanjit A. Seshia
University of California, Berkeley
PI:EMAIL
ABSTRACT
Recent proposals for trusted hardware platforms, such as Intel SGX
and the MIT Sanctum processor, offer compelling security features
but lack formal guarantees. We introduce a verification method-
ology based on a trusted abstract platform (TAP), a formalization
of idealized enclave platforms along with a parameterized adver-
sary. We also formalize the notion of secure remote execution and
present machine-checked proofs showing that the TAP satisfies the
three key security properties that entail secure remote execution:
integrity, confidentiality and secure measurement. We then present
machine-checked proofs showing that SGX and Sanctum are refine-
ments of the TAP under certain parameterizations of the adversary,
demonstrating that these systems implement secure enclaves for
the stated adversary models.
CCS CONCEPTS
• Security and privacy → Formal methods and theory of se-
curity; Security in hardware; Trusted computing; Informa-
tion flow control;
KEYWORDS
Enclave Programs; Secure Computation; Formal Verification; Con-
fidentiality; Integrity; Remote Attestation
1 INTRODUCTION
An application executing on a typical computing platform con-
tains large privileged software layers in its trusted computing base
(TCB), which includes the operating system (OS), hypervisor and
firmware. Vulnerabilities in these privileged software layers have
been exploited to enable the execution of privileged malware with
disastrous consequences [1, 26, 35, 52, 64]. To address this problem,
processor designers and vendors are now developing CPUs with
hardware primitives, such as Intel SGX and MIT Sanctum, which
isolate sensitive code and data within protected memory regions,
called enclaves, that are inaccessible to other software running
on the machine. With these primitives, enclaves become the only
trusted components of an application, and a carefully programmed
enclave can execute safely even when the privileged software layers
are compromised.
CCS ’17, October 30-November 3, 2017, Dallas, TX, USA
© 2017 Association for Computing Machinery.
This is the author’s version of the work. It is posted here for your personal use. Not
for redistribution. The definitive Version of Record was published in Proceedings of
CCS ’17, https://doi.org/10.1145/3133956.3134098.
1
Despite growing interest, there has only been informal security
analysis of these new platforms, which we refer to as enclave plat-
forms. This lack of formalization has a number of consequences.
Developers of enclave programs cannot formally reason about se-
curity of their programs; incorrect use of hardware primitives can
render enclave programs vulnerable to security breaches. Hardware
designers cannot formally state security properties of their archi-
tectures and are unable to reason about potential vulnerabilities of
enclaves running on their hardware.
Going beyond the difficulty of reasoning about specific programs
and platforms, this lack of formalization also makes it difficult
to compare and contrast potential improvements to these plat-
forms. For example, a number of proposals have developed soft-
ware defenses to strengthen the security guarantees of Intel SGX
enclaves [55, 68, 69]. However, comparing the security guarantees
and adversary models (of say T-SGX [68] and Shinde et al. [69]) is
difficult without a unified framework for such reasoning. Further-
more, as we move towards a world in which enclave platforms are
widespread, it is conceivable that future data centers will support a
number of different enclave platforms. Developers will likely tackle
this diversity by relying on tools and libraries that provide a com-
mon application programming interface (API) for enclave programs
while supporting different target platforms. Reasoning about the
security guarantees of such toolchains is also challenging without
a unified framework. This paper bridges each of the above gaps by
presenting a unified formal framework to specify and verify the
security properties of enclave platforms.
We address the formal modeling and verification of enclave
platforms in three parts. First, we define the properties required
for secure remote execution of enclaves. Next we introduce the
trusted abstract platform (TAP), an idealization of enclave platforms
along with a parameterized adversary model. We present machine-
checked proofs showing that the TAP provides secure remote execu-
tion against these adversaries. Finally, we present machine-checked
proofs demonstrating that formal models of Intel SGX and MIT Sanc-
tum are refinements [13] of the TAP for different parameterizations
of the adversary, and thus also provide secure remote execution.
Secure Remote Execution of Enclaves: This paper first for-
malizes a model of computation of an enclave program, and the
attacker’s operations and observations — we assume a privileged
software adversary that has compromised the host OS, hypervi-
sor, network, and persistent storage. The execution model allows
the developer (or user) to precisely define the expected runtime
behavior of an enclave in the presence of a privileged software ad-
versary. When the user outsources an enclave to a remote platform,
she seeks a guarantee that the enclave be executed according to
the expected behavior, i.e., the platform must respect the enclave’s
semantics. We term this property secure remote execution (SRE):
any execution of that enclave on the trusted enclave platform must
be one of enclave’s expected executions (formalized in § 3). Any
enclave platform, such as SGX or Sanctum, must guarantee SRE to
the user, and this paper describes a formal framework and method-
ology to prove secure remote execution. SRE is decomposed into
lower-level properties — specifically, integrity, confidentiality, and
secure measurement — for which we develop machine-checked
proofs on models of SGX and Sanctum.
Trusted Abstract Platform: We develop an idealized abstrac-
tion of the aforementioned enclave platforms, named Trusted Ab-
stract Platform (TAP), consisting of a small set of formally-specified
primitives sufficient to implement enclave execution. As a precursor
to proving that TAP satisfies SRE, we define a parameterized model
of a privileged software attacker with varying capabilities. We then
present machine-checked proofs showing that TAP satisfies the
integrity, confidentiality, and secure measurement properties for
these attackers. The TAP is a general framework for reasoning
about and comparing different enclave platforms, adversary models
and security guarantees. For enclave platform implementers, the
TAP is a golden model or specification of platform behavior. From
the perspective of enclave program developers, the TAP provides a
means of reasoning about program security without being bogged
down by implementation details of individual enclave platforms.
Refinement: Next, we use the TAP to reason about the security
of Intel SGX and MIT Sanctum. We develop formal models of SGX
and Sanctum and present machine-checked proofs showing that
SGX and Sanctum are refinements of our idealized TAP: every oper-
ation on SGX and Sanctum can be mapped to a corresponding TAP
operation. Since all executions of an enclave on SGX and Sanctum
can be simulated by a TAP enclave, and because TAP guarantees
SRE, it follows that the SGX and Sanctum models also guarantee
SRE. There is a caveat that SGX only refines a version of TAP which
leaks some side channel observations to the attacker (see § 5.3),
therefore providing a weaker confidentiality guarantee. This form
of parameterization demonstrates that the TAP allows us to develop
a taxonomy of enclave platforms, each of which provides varying
guarantees against different threat models.
1.1 Contributions
This paper makes the following key contributions:
(1) A formalization of enclave execution in the presence of a
privileged software adversary, and the notion of secure re-
mote execution (SRE) of an enclave program.
(2) The Trusted Abstract Platform, which formally specifies
the semantics of a small set of trusted primitives for safely
creating and destroying enclaves, entering and exiting from
enclaves, and generating attested statements from within
enclaves. We also define a parameterized attacker model, for
which the TAP gives varying degrees of confidentiality.
(3) Decomposition of the SRE property into a triad of integrity,
confidentiality, and secure measurement properties, which
are more easily formally verified using a theorem prover.
(4) A refinement-based methodology for proving the SRE guar-
antee of enclave platforms and machine-checked proofs of
refinement for models of SGX and Sanctum.
All our models and proof scripts are being made open-source [75].
These models are designed to be modular and amenable to extension
by the community.
2 FORMAL MODEL OF ENCLAVE EXECUTION
An enclave platform implements primitives to create protected mem-
ory regions, called enclaves, that contain both code and data and
are isolated from all other software in the system. The processor
monitors all accesses to the enclave: only code running in the en-
clave can access the enclave’s memory. As an example, Intel’s SGX
instructions enable the creation of user-mode enclaves in the host-
ing application’s address space. Since the privileged software lay-
ers (OS/Hypervisor) cannot be trusted to modify enclave memory
(which is why system calls are disabled in enclave mode), the en-
clave platform allows the enclave to access the entire address space
of the hosting application. This enables efficient I/O interaction
with the external world. The external world can only transfer con-
trol to the enclave at statically-defined locations called entrypoints.
In addition to enabling isolated execution, the enclave platform
implements primitives for generating attested statements: code
inside an enclave can get messages signed using a per-processor
private key along with a hash-based measurement of the enclave.
This allows other trusted entities to verify that messages originated
from the desired enclave running on a genuine platform. Finally,
we assume the enclave platform implements a cryptographically
secure random number generator which the enclave can use for
cryptographic operations such as key generation.
Enc e
User
Other
Encs
Other
Apps
Host
App
Enc e
I/O
Privileged SW (OS/Hypervisor)
µ (e )
rand
Enclave Platform
Remote Server
Figure 1: Execution of Enclave Program
To outsource the enclave’s execution, the user sends the enclave
program to a remote machine over an untrusted channel (Figure 1).
The untrusted OS invokes the enclave platform’s primitives to
launch an enclave containing the program. While running, an en-
clave may invoke the enclave platform’s primitives to get attested
statements (with hash-based measurement µ (e)) and random bits.
The enclave may also send outputs to the user by proxying them via
the host application’s unprotected memory. We present a sample
application in § 3.3 to discuss details of secure remote execution of
an enclave program.
2
2.1 Formal Model of Enclave Programs
An enclave is launched with a set of code pages, containing user-
mode instructions, and a set of data pages, which can be used for
private heap and stack space. This forms the initial state of the
enclave — the enclave platform includes a hash-based measurement
of this initial state in all attested statements, which allows the user
to verify that the enclave was launched in an expected initial state.
The enclave’s configuration also includes (1) the entrypoint, (2) the
virtual address range evrange which maps the enclave’s protected
memory (i.e., each address in evrange either maps to a physical
address that is owned by the enclave or is inaccessible due to page
permissions) and (3) permissions for each address within evrange.
Enclave Programs: The user ships an enclave e = (inite, confige).
confige defines the enclave’s entrypoint: confige.entrypoint, its vir-
tual address range: confige.evrange, and its access permissions:
confige.acl. inite specifies the enclave’s initial state at launch, in-
cluding values of code and data pages within confige.evrange.
We assume that the enclave’s virtual address range and corre-
sponding access permissions (confige.evrange, confige.acl) are the
same for local and remote executions. The assumption is required
in order to ensure that enclave measurement (see § 3.1.1) returns a
predictable value.1
Enclave State: At any point of time, the machine is in some
state σ, which we leave abstract for now and defer its definition
to § 4.1. The enclave’s state Ee (σ ) is a projection of the machine
state, and specifies a valuation of the following state variables: (1)
memory vmem : VA → W which is a partial map from virtual
addresses (within confige.evrange) to machine words, (2) general-
purpose registers regs : N → W which are indexed by a natural
number, (3) program counter pc : VA, and (4) configuration confige,
which is copied verbatim from e and remains constant throughout
the enclave’s execution. inite specifies the state of enclave’s mem-
ory (vmem) at the time of launch. We abuse notation to also write
inite (Ee (σ )) to mean that Ee (σ ) is in its launch-time state (prior to
first entry into the enclave).
Enclave Inputs and Outputs: In addition to the private state
Ee (σ ), an enclave accesses non-enclave memory for reading in-
puts and writing outputs, both of which are under adversary con-
trol — since addresses outside evrange can be read and modified
by both the adversary and the enclave, we assume reads from
these addresses return unconstrained values. The enclave may also
invoke the enclave platform’s primitive to get random numbers
(which we also treat as inputs). Therefore, we define enclave’s input
Ie (σ ) (cid:17) ⟨I R
e (σ )⟩, where I R
e (σ ) is any random number that
e (σ ), IU
is provided by the platform in that step (ϵ if randomness was not
e (σ ) is the projection of the machine state that e
requested), and IU
may read and the attacker may write; specifically, IU
e (σ ) specifies
an evaluation of non-enclave memory: a partial map from virtual
addresses (outside confige.evrange) to machine words. Similarly, we
define enclave’s output Oe (σ ) to be a projection of the machine
state that e can write and the attacker may read; specifically, Oe (σ )
specifies an evaluation of non-enclave memory: a partial map from
virtual addresses (outside confige.evrange) to words. Furthermore,
1This is not a restrictive assumption because techniques such as Address Space Layout
Randomization (ASLR) of the enclave’s virtual memory layout can be implemented
after the enclave is initialized à la SGX Shield [67].
an attacker runs concurrently with e and maintains state that can-
not be accessed by the enclave (e.g., hypervisor private memory,
other malicious enclaves), which we denote as Ae (σ ).
Enclave Execution: Our semantics of enclave execution as-
sumes that an enclave program is deterministic modulo the input
Ie (σ ), i.e., the next state of the enclave is a function of the current
e (σ )). This
state Ee (σ ) and input Ie (σ ) (which includes IU
is not a restriction in practice as both Sanctum and SGX enclaves
interact with the external world via memory-based I/O (IU