## PostgreSQL Oracle checksum 配置与性能  
### 作者                                                           
digoal                                                           
### 日期                                                           
2018-05-28                                                         
### 标签                                                           
PostgreSQL , Oracle , checksum , IO错误   
----                                                           
## 背景   
开启数据库block checksum可以发现磁盘、存储、IO系统的问题引入一些的物理错误。  
### PostgreSQL checksum  
在PostgreSQL中，默认强制对XLOG（WAL）开启了checksum，因此可以保证从redo buffer写入redo file里面的数据是一致的，读取的时候也会根据每个REDO PAGE的checksum检查REDO PAGE的内容是否正确。（换言之没有参数来关闭WAL的checksum）  
而对于DATAFILE，是否开启CHECKSUM则取决于initdb时配置的checksum参数。  
```  
initdb  
  -k, --data-checksums      use data page checksums  
```  
通过pg_controldata检查当前数据库集群是否开启了checksum。  
```  
pg_controldata  
Data page checksum version:           0  
```  
PostgreSQL 11 允许用户动态的修改checksum的开关，而不是初始化实例时固定：  
[《PostgreSQL 11 preview - Allow on-line enabling and disabling of data checksums (含pg_verify_checksums工具，离线检查数据文件有误块错误)》](../201804/20180407_03.md)    
### Oracle checksum  
Checksums allow Oracle to detect corruption caused by underlying disks, storage systems, or I/O systems.   
If this parameter is set to OFF, DBWn calculates checksums only for the SYSTEM tablespace, but not for user tablespaces. In addition, no log checksum is performed when this parameter is set to OFF.  
https://docs.oracle.com/cd/B28359_01/server.111/b28320/initparams046.htm#REFRN10030  
DB_BLOCK_CHECKSUM determines whether DBWn and the direct loader will calculate a checksum (a number calculated from all the bytes stored in the block) and store it in the cache header of every data block when writing it to disk. Checksums are verified when a block is read - only if this parameter is TYPICAL or FULL and the last write of the block stored a checksum. In FULL mode, Oracle also verifies the checksum before a change application from update/delete statements and recomputes it after the change is applied. In addition, Oracle gives every log block a checksum before writing it to the current log.  
Starting with Oracle Database 11g, most of the log block checksum is done by the generating foreground processes, while the LGWR performs the rest of the work, for better CPU and cache efficiency. Prior to Oracle Database 11g, the LGWR solely performed the log block checksum. When this parameter is set to FULL, the LGWR verifies the checksum of each log block generated by the foreground processes before writing it to disk.  
If this parameter is set to OFF, DBWn calculates checksums only for the SYSTEM tablespace, but not for user tablespaces. In addition, no log checksum is performed when this parameter is set to OFF.  
Checksums allow Oracle to detect corruption caused by underlying disks, storage systems, or I/O systems. If set to FULL, DB_BLOCK_CHECKSUM also catches in-memory corruptions and stops them from making it to the disk. Turning on this feature in TYPICAL mode causes only an additional 1% to 2% overhead. In the FULL mode it causes 4% to 5% overhead. Oracle recommends that you set DB_BLOCK_CHECKSUM to TYPICAL.  
For backward compatibility the use of TRUE (implying TYPICAL) and FALSE (implying OFF) values is preserved.  
## PostgreSQL checksum 行为  
1、开启checksum后，PostgreSQL 从shared buffer把数据write出去，需要计算checksum。  
2、开启checksum后，从shared buffer外面（disk, os page cache）读取BLOCK到shared buffer里面，需要计算block的checksum，对比存储在page head里头的checksum是否一致。  
3、已经在shared buffer里面的block，变更、读取时并不需要计算checksum。  
### checksum计算逻辑  
1、pg_checksum_page  
src/include/storage/checksum_impl.h  
```  
/*  
 * Compute the checksum for a Postgres page.  The page must be aligned on a  
 * 4-byte boundary.  
 *  
 * The checksum includes the block number (to detect the case where a page is  
 * somehow moved to a different location), the page header (excluding the  
 * checksum itself), and the page data.  
 */  
uint16  
pg_checksum_page(char *page, BlockNumber blkno)  
{  
        PageHeader      phdr = (PageHeader) page;  
        uint16          save_checksum;  
        uint32          checksum;  
        /* We only calculate the checksum for properly-initialized pages */  
        Assert(!PageIsNew(page));  
        /*  
         * Save pd_checksum and temporarily set it to zero, so that the checksum  
         * calculation isn't affected by the old checksum stored on the page.  
         * Restore it after, because actually updating the checksum is NOT part of  
         * the API of this function.  
         */  
        save_checksum = phdr->pd_checksum;  
        phdr->pd_checksum = 0;  
        checksum = pg_checksum_block(page, BLCKSZ);  
        phdr->pd_checksum = save_checksum;  
        /* Mix in the block number to detect transposed pages */  
        checksum ^= blkno;  
        /*  
         * Reduce to a uint16 (to fit in the pd_checksum field) with an offset of  
         * one. That avoids checksums of zero, which seems like a good idea.  
         */  
        return (checksum % 65535) + 1;  
}  
```  
2、异步写（bg writer, backend process evict dirty page）时，计算checksum  
src/backend/storage/buffer/bufmgr.c  
```  
/*  
 * FlushBuffer  
 *              Physically write out a shared buffer.  
 *  
 * NOTE: this actually just passes the buffer contents to the kernel; the  
 * real write to disk won't happen until the kernel feels like it.  This  
 * is okay from our point of view since we can redo the changes from WAL.  
 * However, we will need to force the changes to disk via fsync before  
 * we can checkpoint WAL.  
 *  
 * The caller must hold a pin on the buffer and have share-locked the  
 * buffer contents.  (Note: a share-lock does not prevent updates of  
 * hint bits in the buffer, so the page could change while the write  
 * is in progress, but we assume that that will not invalidate the data  
 * written.)  
 *  
 * If the caller has an smgr reference for the buffer's relation, pass it  
 * as the second parameter.  If not, pass NULL.  
 */  
static void  
FlushBuffer(BufferDesc *buf, SMgrRelation reln)  
        /*  
         * Update page checksum if desired.  Since we have only shared lock on the  
         * buffer, other processes might be updating hint bits in it, so we must  
         * copy the page to private storage if we do checksumming.  
         */  
        bufToWrite = PageSetChecksumCopy((Page) bufBlock, buf->tag.blockNum);  
```  
3、将数据从shared buffer外围读入shared buffer时，校验checksum  
src/backend/storage/page/bufpage.c  
```  
/*  
 * PageIsVerified  
 *              Check that the page header and checksum (if any) appear valid.  
 *  
 * This is called when a page has just been read in from disk.  The idea is  
 * to cheaply detect trashed pages before we go nuts following bogus item  
 * pointers, testing invalid transaction identifiers, etc.  
 *  
 * It turns out to be necessary to allow zeroed pages here too.  Even though  
 * this routine is *not* called when deliberately adding a page to a relation,  
 * there are scenarios in which a zeroed page might be found in a table.  
 * (Example: a backend extends a relation, then crashes before it can write  
 * any WAL entry about the new page.  The kernel will already have the  
 * zeroed page in the file, and it will stay that way after restart.)  So we  
 * allow zeroed pages here, and are careful that the page access macros  
 * treat such a page as empty and without free space.  Eventually, VACUUM  
 * will clean up such a page and make it usable.  
 */  
bool  
PageIsVerified(Page page, BlockNumber blkno)  
{  
        PageHeader      p = (PageHeader) page;  
        size_t     *pagebytes;  
        int                     i;  
        bool            checksum_failure = false;  
        bool            header_sane = false;  
        bool            all_zeroes = false;  
        uint16          checksum = 0;  
        /*  
         * Don't verify page data unless the page passes basic non-zero test  
         */  
        if (!PageIsNew(page))  
        {  
                if (DataChecksumsEnabled())  
                {  
                        checksum = pg_checksum_page((char *) page, blkno);  
                        if (checksum != p->pd_checksum)  
                                checksum_failure = true;  
                }  
...................  
/*  
 * Set checksum for a page in shared buffers.  
 *  
 * If checksums are disabled, or if the page is not initialized, just return  
 * the input.  Otherwise, we must make a copy of the page before calculating  
 * the checksum, to prevent concurrent modifications (e.g. setting hint bits)  
 * from making the final checksum invalid.  It doesn't matter if we include or  
 * exclude hints during the copy, as long as we write a valid page and  
 * associated checksum.  
 *  
 * Returns a pointer to the block-sized data that needs to be written. Uses  
 * statically-allocated memory, so the caller must immediately write the  
 * returned page and not refer to it again.  
 */  
char *  
PageSetChecksumCopy(Page page, BlockNumber blkno)  
{  
        static char *pageCopy = NULL;  
        /* If we don't need a checksum, just return the passed-in data */  
        if (PageIsNew(page) || !DataChecksumsEnabled())  
                return (char *) page;  
        /*  
         * We allocate the copy space once and use it over on each subsequent  
         * call.  The point of palloc'ing here, rather than having a static char  
         * array, is first to ensure adequate alignment for the checksumming code  
         * and second to avoid wasting space in processes that never call this.  
         */  
        if (pageCopy == NULL)  
                pageCopy = MemoryContextAlloc(TopMemoryContext, BLCKSZ);  
        memcpy(pageCopy, (char *) page, BLCKSZ);  
        ((PageHeader) pageCopy)->pd_checksum = pg_checksum_page(pageCopy, blkno);  
        return pageCopy;  
}  
/*  
 * Set checksum for a page in private memory.  
 *  
 * This must only be used when we know that no other process can be modifying  
 * the page buffer.  
 */  
void  
PageSetChecksumInplace(Page page, BlockNumber blkno)  
{  
        /* If we don't need a checksum, just return */  
        if (PageIsNew(page) || !DataChecksumsEnabled())  
                return;  
        ((PageHeader) page)->pd_checksum = pg_checksum_page((char *) page, blkno);  
}  
```  