# 基于Unicorn和LibFuzzer的模拟执行fuzzing
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
之前，银河实验室对基于unicorn的模拟执行fuzzing技术进行了研究。在上次研究的基础上，我们进一步整合解决了部分问题，初步实现了基于Unicorn和LibFuzzer的模拟执行fuzzing工具：uniFuzzer。
关于这项研究的相关背景，可回顾实验室之前的这篇文章[基于 unicorn 的单个函数模拟执行和 fuzzer
实现](\(http:/galaxylab.com.cn/%E5%9F%BA%E4%BA%8E-unicorn-%E7%9A%84%E5%8D%95%E4%B8%AA%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%92%8C-fuzzer-%E5%AE%9E%E7%8E%B0/\))，这里就不再缀述了。总体而言，我们想要实现的是：
  1. 在x86服务器上模拟运行MIPS/ARM架构的ELF（主要来自IoT设备）
  2. 可以对任意函数或者代码片段进行fuzzing
  3. 高效的输入变异
其中前2点，在之前的研究中已经确定用Unicorn解决；输入的变异，我们调研后决定采用LibFuzzer，并利用其代码覆盖率反馈机制，提升fuzzing效率。
在这篇文章中，我们先简要介绍下Unicorn和LibFuzzer，随后对模拟执行fuzzing工具的原理进行详细的分析，最后通过一个demo来介绍工具的大致使用方式。
## 背景介绍
### 1.1 Unicorn
提到[Unicorn](https://github.com/unicorn-engine/unicorn)，就不得不说起[QEMU](https://www.qemu.org/)。QEMU是一款开源的虚拟机，可以模拟运行多种CPU架构的程序或系统。而Unicorn正是基于QEMU，它提取了QEMU中与CPU模拟相关的核心代码，并在外层进行了包装，提供了多种语言的API接口。
因此，Unicorn的优点很明显。相比QEMU来说，用户可以通过丰富的接口，灵活地调用CPU模拟功能，对任意代码片段进行模拟执行。不过，我们在使用过程中，也发现Unicorn存在了一些不足，最主要的就是Unicorn其实还不是很稳定、完善，存在了大量的坑（可以看Github上的issue），而且似乎作者也没有短期内要填完这些坑的打算。另一方面，由于还有较多的坑，导致Unicorn底层QEMU代码的更新似乎也没有纳入计划：Unicorn最新的release是2017年的1.0.1版本，这是基于QEMU
2的，然而今年QEMU已经发布到QEMU 4了。
不过，虽然存在着坑比较多、QEMU版本比较旧的问题，对我们的模拟执行fuzzing来说其实还好。前者可以在使用过程中用一些临时方法先填上（后面会举一个例子）。后者的影响主要是不支持一些新的架构和指令，这对于许多IoT设备来说问题并不大；而旧版本QEMU存在的安全漏洞，主要也是和驱动相关，而Unicorn并没有包含QEMU的驱动，所以基本不受这些漏洞的影响。
### 1.2 QEMU
关于QEMU的CPU模拟原理，读者可以在网上搜到一些专门的介绍，例如[这篇](https://www.slideshare.net/ChiaweiWang3/qemu-introduction)。大致来说，QEMU是通过引入一层中间语言，TCG，来实现在主机上模拟执行不同架构的代码。例如，如果在x86服务器上模拟MIPS的代码，QEMU会先以基本块（Basic
Block）为单位，将MIPS指令经由TCG这一层翻译成x86代码，得到TB(Translation Block)，最终在主机上执行。
而为了提高模拟运行的效率，QEMU还加入了TB缓存和链接机制。通过缓存翻译完成的TB，减少了下次执行时的翻译开销，这即就是Unicorn所说的JIT。而TB链接机制，则是把原始代码基本块之间的跳转关系，映射到TB之间，从而尽可能地减少了查找缓存的次数和相关的上下文切换。
值得一提的是，Unicorn所提供的hook功能，就是在目标代码翻译成TCG时，插入相关的TCG指令，从而在最终翻译得到的TB中，于指定位置处回调hook函数。而由于TCG指令和架构无关，因此添加的TCG指令可以直接适用于不同架构。
### 1.3 LibFuzzer
LibFuzzer应该许多人都不陌生，这是LLVM项目中内置的一款fuzzing工具，相比我们之前介绍过的AFL，LibFuzzer具有以下优点：
  1. 灵活：通过实现接口的方式使用，可以对任意函数进行fuzzing
  2. 高效：在同一进程中进行fuzzing，无需大量fork()进程
  3. 便捷：提供了API接口，便于定制化和集成
而且，和AFL一样，LibFuzzer也是基于代码覆盖率来引导变异输入的，因此fuzzing的效率很高。不过，这两者都需要通过编译时插桩的方式，来实现代码覆盖率的跟踪，所以必须要有目标的源代码。接下来，在uniFuzzer的原理中，我们会介绍如何结合Unicorn和LibFuzzer的功能，对闭源程序进行代码覆盖率的跟踪反馈。
## uniFuzzer原理
uniFuzzer的整体工作流程大致如下：
  1. 目标加载：在Unicorn中加载目标ELF和依赖库，并解析符号
  2. 设置hook：通过Unicorn的基本块hook，反馈给LibFuzzer代码覆盖率
  3. 准备环境：设置栈、寄存器等信息
  4. fuzzing：将Unicorn的模拟执行作为目标函数，开始LibFuzzer的fuzzing
下面对各环节进行具体的介绍。
### 2.1 目标加载
遇到的许多IoT设备，运行的是32位MIPS/ARM架构的Linux，所以我们初步设定的目标就是这类架构上的ELF文件。
如实验室之前对模拟执行研究的那篇文章中所讲，我们需要做的就是解析ELF格式，并将LOAD段映射到Unicorn的内存中。而在随后的研究中，我们发现目标代码往往会调用其他依赖库中的函数，最常见的就是libc中的各类C标准库函数。通过Unicorn的hook机制，倒是可以将部分标准库函数通过非模拟执行的方式运行。但是这种方式局限太大：假如调用的外部函数不是标准库中的，那么重写实现起来就会非常麻烦。所以，我们还是选择将目标ELF的全部依赖库也一并加载到Unicorn中，并且也通过模拟执行的方式，运行这些依赖库中的代码。
那么，以上所做的，其实也就是Linux中的动态链接器ld.so的工作。Unicorn本身并不包含这些功能，所以一种方式是由Unicorn去模拟执行合适的ld.so，另一种方式是实现相关的解析代码，再调用Unicorn的接口完成映射。由于后一种更可控，所以我们选择了这种方式。不过好在ld.so是开源的，我们只需要把相关的代码修改适配一下即可。最终我们选择了[uClibc](https://www.uclibc.org/)这个常用于嵌入式设备的轻量库，将其ld.so的代码进行了简单的修改，集成到了uniFuzzer中。
由于我们集成的是ld.so的部分功能，导入函数的地址解析无法在运行时进行。因此，我们采取类似LD_BIND_NOW的方式，在目标ELF和依赖库全部被加载到Unicorn之后，遍历符号地址，并更新GOT表条目。这样，在随后的模拟执行时，就无需再进行导入函数的地址解析工作了。
集成ld.so还带来了一个好处，就是可以利用LD_PRELOAD的机制，实现对库函数的覆盖，这有助于对fuzzing目标进行部分定制化的修改。
### 2.2 设置hook
接下来需要解决的一个重要问题，就是如何获取模拟执行的代码覆盖率，并反馈给LibFuzzer。LibFuzzer和AFL都是在编译目标源码时，通过插桩实现代码覆盖的跟踪。虽然LibFuzzer的具体插桩内容我们还没有分析，但是之前对[AFL的分析](https://rk700.github.io/2017/12/28/afl-internals/)应该可以作为参考。简单来说，AFL是为每个执行分支生成一个随机数，用于标记当前分支的”位置”；随后在跳转到某个分支时，提取该分支的”位置”，与跳转之前的上一个”位置”作异或，并将异或的结果作为此次跳转的标号，更新一个数组。AFL官网上的文档提供了这一部分的伪代码：
而这个数组，记录的就是每个跳转，如A->B，所发生的次数。AFL以此数组作为代码覆盖率的信息，进行处理，并指导后续的变异。
回到我们的fuzzing工具。如之前所说，LibFuzzer和AFL之所以需要目标的源码，是为了在编译时，在跳转处插入相关的代码，而跳转正好对应的就是基本块这一概念。恰巧，Unicorn提供的hook接口中，也包含了基本块级别的hook，可以在每个基本块被执行之前，回调我们设置的hook函数: