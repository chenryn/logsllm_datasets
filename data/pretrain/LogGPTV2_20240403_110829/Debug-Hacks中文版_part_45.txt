---
## Page 362
353
注5：
同一缓存中，发生冲突（conflict）。
第3 种情况是，每块内存都会对应到某块缓存上，某些情况下两块内存会保存到
中反复执行保存、释放处理，导致额外的开销。
存，假设缓存大小为2KB，那么要复制的内容就无法放入缓存，因此需要在缓存
第 2种情况发生在程序运行范围大于缓存范围的情况下。例如，要复制 8MB 内
技术。
在正式访问之前预先访问一遍，使之加载到缓存中，也称为预读取（pre-fetch)
关于第1次访问，由于以前没有访问过，当然会发生缓存未命中。解决方法就是
种原因都有解决方法。
缓存未命中的发生原因有①第1次访问、②缓存容量不足、③缓存线冲突等，每
中会降低性能，因此减少缓存未命中是非常重要的。
所谓缓存未命中，就是某次访问无法在缓存中满足，必须访问主内存。缓存未命
由于主内存要比CPU的速度慢，因此有效利用缓存对于提高性能是不可或缺的。
减少缓存未命中的方法
这样就能看出何处发生了较多的缓存未命中。
344|第6章高手们的调试技术
8064f05:
8064f02:
8064f00:
8064efe:
性能。
内存。大多数程序的访问模式都有局部性，用快速的小型缓存可以提高系统
存的访问速度和CPU寄存器的访问速度之差，可以说是访问速度更快的小型
关于缓存和缓存未命中。缓存位于主内存和CPU寄存器之间，用于解决主内
if (!(p->as.basic.flags & FL_MARK)) {
else{
 add_freelist(objspace, p);
74 dl
7625
free_num++;
f6 c2 20
8b 13
www.TopSage.com
jbe  8064f25 
je
mov(%ebx),&edx
test
8064ed8 
$0x20,8dl
---
## Page 363
此写了个预读补丁，补丁内容如下。
至于本 hack 中的缓存未命中，查看源代码后发现，发生原因就是第1次访问。因
少缓存未命中。
生缓存未命中。可以像下面这样按照缓存线的大小错开，使之余数不同，就能减
a]的地址和 b[的地址相隔 8KB，用 8KB 除的余数相等，因此上例中就会频繁发
一缓存线上。
例如，假设缓存有 8KB，那么内存空间除以 8KB 的余数相等时，就会保存到同
@d -1657,6 +1662,11 @@
@a -1095,6 +1095,11 @@
+++ gc.c (working copy)
--- gc.c (revision 21331)
Index: gc.c
$ svn diff
char paddingICACHE_LINE_SIZE]；/*按照缓存线的大小错开*/
int a[2048]; 
#defineCACHE_LINE_SIZE128；/*缓存线的大小*/
for(i=0;ias.basic.flags != FL_MARK)) {
((p->as.basic.flags & FL_MARK) &&
: : "r" ((p+l)->as.basic.flags) );
prefetch (%0)\n"
_volatile_.
www.TopSage.com
HACK#60 解决性能问题|  345 
354
---
## Page 364
统页面错误、中断情况等各种信息。
硬件之间的交互信息。它能获取虚拟 CPU 寄存器、硬件虚拟状态、虚拟操作系
VProbe 是个分析、调试引擎，它运行于 Hypervisor 层，能获取有关虚拟机和物理
#6.1
能调查和调优的方法。
本 hack 以减少 ruby 实现中的缓存未命中为例,具体地介绍了利用 oprofile 进行性
总结
可见，garbage_collect()的缓存未命中数由 15421 次减少到了 11678 次。
应用补丁后执行同样的测试。
346 | 第 6章高手们的调试技术
10014
11678
22716
61186
samples%
mask of @x100 (read 2nd level cache miss) count 3000
Counted BSQ_CACHE_REFERENCE events (cache references seen by the bus unit) with a unit
CPU: P4 / Xeon, speed 2400 MHz (estimated)
while (p as.basic.flags & FL_MARK)) {
利用VMwareVprobe获取信息
5.4450
6.3497
12.3515 ruby
33.2690
拟机操作系统的状态。
可以利用VMwareWorkstation6.5以后的版本的VProbe 功能查看虚
if (p->as.basic.flags &
if ((p+l)as.basic.flags) );
" prefetch (%0)\n"
ruby
ruby
no-vmlinux
image name
www.TopSage.com
ruby
ruby
no-vmlinux
app name
 gc_mark_ children
garbage_collect
gc_mark
(no symbols)
 symbol name
一-吉冈弘隆
---
## Page 365
行期间，vprobe.out中就会输出字符串。
这样在.vmx的同一目录下会生成vprobe.out，并且每秒钟输出一次hello！。
如上所示，显示enabled表示可以使用。
通过安装VMwareWorkstation时附带的vmrun命令，可以查看Vprobe功能是否
确认Vprobe功能的状态
使用Vprobe功能的注意事项
2.在虚拟机的设置文件（.vmx文件）中添加下面这行。
“hello!”字符串和换行。VMM1Hz是个每秒发生一次的静态侦测器。虚拟机运
上面的含义是用VMM1Hz这个Vprobe预定义的静态侦测器（Staticprobe）输出
执行下面的命令即可进行测试。
测试Vprobe功能
启用。
使用Vprobe需要启动虚拟机操作系统。
1.在VMware的设置文件（config）中添加下面这一行。
启用Vprobe的步骤
$/vmrun vprobeLoad‘Linux.vmx’‘(vprobe VMIHz（printf“hello!\n")）
VProbesversion:0.2(enabled)
$./vmrunvprobeVersion‘vmx文件路径（下面假设为Linux.vmx）
vprobe.enable= TRUE
config.ini
Linux下:/etc/vmware.config
vprobe.allow= TRUE
www.TopSage.com
356
---
## Page 366
设备的信息，如：
结束虚拟机操作系统的 BIOS 设置界面，重新启动，vprobe.out上就会显示启动
4.测试
脚本从命令行读入，因此必须用双引号和反引号进行转义。
在宿主上执行下述命令。
3.读取 Vprobe
键使之停在 BIOS 设置画面上。
Vprobe 的代码必须在虚拟机执行时才能读取，因此要先启动虚拟机，并用F2 等
2．启动虚拟机
1．创建下面的文件。；（分号）之后为注释，实际没有必要输入。
下面的例子演示了在特定地址的指令执行时执行动态侦测器（Dynamic probe)。
Vprobe功能的使用例：显示boot设备
要停止Vprobe 功能并结束输出，可以使用以下命令。
停止输出，停止Vprobe功能
348| 第6章高手们的调试技术
$ ./vmrun vprobeload 'Linux.vmx' "' cat printboot.emt'"
 ,xuA'xnutl, 4asayaqoudn unw/ $
(printf "Booting from %s (0x&x)\n" device dl))
(setstr device “floppy drive")
(setstr device "hard drive"))
(setint dl (&RDX @xff))
(definteger dl)
; Print the boot device.
$ cat printboot.emt 
(setstr device "unknown device CD etc."))}
(== dl 0)
cond ((==dl 0x80)
vprobeGUEST:0x7c00
defstring device)
www.TopSage.com
；条件判断
；获取 RDX 寄存器低8比特，即DL 寄存器内容
；在bootloader开始地址处执行侦测器
定义数值变量
定义字符串变量
---
## Page 367
编号和系统调用的对应关系可以参见内核源代码中的下述文件。
RAX（EAX）寄存器中会包含系统调用号码，可以判断调用了哪个系统调用。
3.在内核的 system_call 函数被调用的那一刻，vprobe.out 中就会输出信息。此时
2.读入 Vprobe
使用符号文件的例子
符号文件的扩展名要设置为.txt，或没有扩展名。
将上面获得的符号文件设置到 vmx文件中，就可以用内核函数名称来指定地址。
例
# cat /proc/kallsyms > kallsyms.txt
虚拟机的地址信息可以用下述方法导出成符号文件。
用函数名指定地址
$ ./vmrun vprobeload 'Linux.vmx' " cat system_call.emt'""
vprobe.guestSyms = "kallsyms.txt" 
v2.6.24
include/asm-x86_64/unistd.h
include/asm-i386/unistd .h
v2.6.23之前
Current RAX : 0x00000000000000af RSP : 0x000000cb2f1fe4
Current RAX : 0x00000000001 RSP : 0x0000000ce65fe4
(printf "Current RAX : 0x%016x RSP : 0x%016x \n" RAX RSP))
$ cat system_call.enmt
(vprobe GUEST:system_call
Booting from unknown device CD etc. (ox9f)
Booting from floppy drive (0x0)
Booting from hard drive (0x80)
www.TopSage.com
HACK#61利用 VMware Vprobe 获取信息| 349
358
---
## Page 368
65
首先登录到 Xen 的管理操作系统的 Domain-0。
不论是准虚拟化（Paravirtualization）的Domain-U虚拟机，还是完全虚拟化
拟机的内存转储，而且还能 livedump，无须停止虚拟机运行，就能获取内存转储。
如果在Xen 虚拟机上运行Linux，就可以利用 Xen 的控制台（Domain-0）获取虚
#62
参考资料
Vprobe 能获取的信息及静态侦测器的种类的参考手册，可以作为参考。
使用 VMware 的功能可以动态地了解内部状态。此外，
总结
篇)。
的参数传递方法（x86_64篇）和“HACK#11函数调用时的参数传递方法（i386
这样在调用函数时即可获取寄存器信息，十分方便。寄存器的详细情况参见
350 |第6章高手们的调试技术
步骤
（FullVirtualization）的 HVM Domain 虚拟机，都能进行内存转储。
“HACK#8Intel 架构的基本知识”。函数调用请参见“HACK#10函数调用时
include/asm-x86/unistd_64.h
 include/asm-x86/unistd_32.h
Vprobes Programming Reference
http://www.vmware.com/pdf/ws65_vprobes_reference.pdf
本文件，即可执行。
就比较困难。此时可以使用 Cygwin 的控制台，并用与 Linux 相同的方法指定脚
如果宿主操作系统是Windows，从标准的命令行提示符下执行多条Vprobe 脚本
的 Linux 的内存转储的方法。
本 hack 介绍获取在 Xen 虚拟机（Domain-U、HVM Domain）上运行
用 Xen 获取内存转储
www.TopSage.com
下面的参考资料中给出了
一吉田俊辅
---
## Page 369
用crash命令即可分析输出的 dump文件。
能获取它的内存转储。
用 xm dump-core 命令输出 dump 文件。指定--live选项，无须停止目标 domain，就
用 xm list命令查看运行中的 domain（虚拟机）。
[例]
# crash System.map-2.6.18-xxx vmlinux axhvmstall.live
 Dumping core of domain: Asianux3GA_HV ...
 # xm dump-core --live Asianux3GA_HV /home/user/axhvmstall.live
LOAD AVERAGE:
[中略】
Domain-0
Asianux3GA_HV
Name
# xm list
DEBUG KERNEL:
SYSTEM MAP:
DUMPFILE:
RELEASE:
VODENAME:
COMMAND:
MEMORY:
MACHINE:
VERSION:
TASKS:
UPTIME:
PID:
PANIC:
DATE:
CPUS:
文件分区的空闲容量。
输出的 dump 文件大小等于运行中的虚拟机的内存大小，因此要注意保存 dump
TASK:
i686 (2660 Mhz)
#1 SMP Sun Mar 16 20:22:54 EDT 2008
2.6.18-xxx
axs3fullovm.miraclelinux.com
0.00, 0.00, 0.00
00:53:02
Sun Sep 28 11:14:22 2008
dump/axhvmstall.live
vmlinux (2.6.18-xxx)
 System.map-2.6.18-xxx
c0664bcO [THREAD_INFO0: cC06d900]
'swapper"
2 GB
50
1
668
2048
Mem  VCPUS
www.TopSage.com
8 r----- 173.0
r-----
State Time(s)
580.1
HACK#62 用 Xen 获取内存转储1 351
360