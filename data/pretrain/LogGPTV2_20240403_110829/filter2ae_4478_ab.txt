不幸的是，这种方法依然无法成功，因为开发者也考虑到了这种情况。在分析函数体时，所有参数的值会被设置为`null`，覆盖变量的初始值。部分代码如下所示：
    node.params.forEach(function(key) {
        if(key.type == 'Identifier'){
          vars[key.name] = null;
        }
    });
这段代码会处理定义该函数的AST节点，遍历类型为`Identifier`的每个参数，提取其名称并将对应的`vars`属性为`null`。即便上述代码看起来非常正确，但也犯下了一个非常常见的错误：并没有覆盖所有可能的情况。如果某个参数比较奇怪，其类型不等于`Identifier`会出现什么情况？修复代码并没有采用白名单机制，会忽略该参数，继续执行剩余代码（类似黑名单机制）。这意味着如果我构造的节点类型与`Identifier`不同，那么该变量的值就不会被覆盖，因此就可以使用初始值。此时我非常确定自己找到了非常关键的一点。我只需要想办法将`key.type`的值设置为与`Identifier`不同的其他值即可。
前面我们提到过，`static-eval`使用[`esprima`库](https://github.com/jquery/esprima/)来解析我们输入的代码。根据相关文档，`esprima`这个解析器完全支持[ECMAScript标准](https://www.ecma-international.org/ecma-262/7.0/)。ECMAScript类似于JavaScript的另一种表示法，但具备更多的功能，语法上对用户而言更加友好。
ECMAScript添加的一个功能就是[函数参数解构](https://simonsmith.io/destructuring-objects-as-function-parameters-in-es6/)功能。在该功能的帮助下，如下JS代码现在可以正常执行：
    function fullName({firstName, lastName}){
        return firstName + " " + lastName;
    }
    console.log(fullName({firstName: "John", lastName: "McCarthy"}))
函数参数定义中包含花括号，不代表该函数接受`firstName`和`lastName`两个参数，而是只接受一个参数，该参数是包含`firstName`和`lastName`属性的一个对象。上面代码等同于如下代码：
    function fullName(person){
        return person.firstName + " " + person.lastName;
    }
    console.log(fullName({firstName: "John", lastName: "McCarthy"}))
如果我们检查esprima生成的AST（我使用的是[这款工具](http://esprima.org/demo/parse.html)），就能看到一个非常令人满意的结果：
实际上，这种新的语法可以让函数参数的`key.type`值不等于`Identifier`，因此`static-eval`在覆盖变量时不会处理该参数。通过这种方法，当执行如下表达式时:
    (function({book}){return book.constructor})({book:"".sub})
`static-eval`会使用`book`的初始值（这是一个对象），然后我们也能创建函数。但当函数被调用时，`book`就会变成一个函数，因此就能返回函数的`constructor`。现在我的确找到了绕过方法！
之前的表达式会返回函数的`constructor`，因此我只需要调用`constructor`来创建恶意函数，然后再调用新创建的函数即可。
    (function({book}){return book.constructor})({book:"".sub})("console.log(global.process.mainModule.constructor._load("child_process").execSync("id").toString())")()
我在本地环境安装了最新版的`static-eval`，并测试了这个表达式，结果与我的预期相符：
任务完成！我找到了绕过`static-eval`库的一种方法，能够在使用该库的目标主机上执行代码。唯一的条件是需要知道变量值不是函数的某个变量名，并且该变量包含`constructor`属性。字符串（strings）、数字（numbers）、数组（arrays）以及对象（objects）都满足这些条件，因此这对我们来说应该不难。我只需要在我测试的网站上使用这种技术，证实目标存在RCE利用点即可。但事情真的那么简单吗？
## 六、无法在目标环境中生效
不幸的是，即使我找到了优雅并且可用的绕过方法后，我发现我测试的目标站点上并不能使用这种技术。唯一的条件是我们要掌握变量值不为函数的某个变量名，因此大家可能觉得我找不到这个切入点，导致我无法利用漏洞。然而事实上我的确满足这个条件，之所以无法成功利用，原因有点复杂。
这里介绍一下相关背景，该网站并没有直接使用`static-eval`库，而是通过[jsonpath](https://github.com/dchester/jsonpath)
npm库来使用目标库。JSONPath是与XPATH类似的一个查询语言，但处理的是JSON文档而非XML文档，该库最早于2007年问世（参考[此处文章](https://goessner.net/articles/JsonPath/)）。
阅读JSONPath文档后，我发现这个项目非常糟糕，没有明确的规范，所实现的大多数功能有点随性而为之的感觉，并不去考虑添加这些功能是否必要。可惜的是NodeJS生态系统中充斥着类似的库。
JSONPath具有一个过滤器表达式功能，可以过滤匹配给定表达式的文档。比如，我们可以使用`$.store.book[?(@.price <
10)].title`来筛选价格低于`$10`的书籍，然后获取书籍的标题。jsonpath npm库使用`static-eval`来计算括号之间的表达式。我测试的站点可以让我指定JSONPath表达式，然后使用该库来解析这个表达式，因此RCE也就顺手拈来。
如果我们仔细观察上面那个JSONPath表达式，可以看到传递给`static-eval`的表达式为`@.price <
10`。根据文档描述，`@`是包含待过滤文档的一个变量（通常是一个对象）。不幸的是，JSONPath开发者采用的是`@`这个符号。根据ECMAScript规范，该符号并不是一个有效的变量名。因此为了让`static-eval`能够正常工作，开发者需要[修改esprima代码](https://github.com/dchester/jsonpath/blob/87f97be392870c469308dd4dc90d2067863ea02a/lib/aesprim.js#L8)。使其能够将`@`当成一个合法的变量名。
当我们在`static-eval`中创建匿名函数时，匿名函数会嵌入另一个函数中，后者将其当成已定义的变量参数来使用。因此如果我在JSONPath过滤器表达式中创建一个匿名函数，那么它将创建包含该函数的一个函数，并且接受名为`@`的一个参数。程序会直接调用`constructor`来完成该操作，因此并没有使用之前的esprima补丁。然后，当定义函数时，它会抛出我无法规避的一个错误。这是这个库的一个bug，导致我们无法在过滤器表达式中定义函数（不管是不是恶意函数）。因此，本文介绍的这种绕过技术无法适用于这个库。
由于开发者在目标库中使用了`@`来命名变量，而该符号又不是JS中的有效变量名，因此我无法在目标站点中利用RCE漏洞，也没法获得4位数的漏洞赏金。为什么开发者不使用`_`（这是一个有效的变量名）、`document`或者`joseph`！经过这次学习，我找到了某个库中很大的一个漏洞，也学到了关于JavaScript的不少知识。
## 七、总结
即使我没有拿到预期的赏金，在与这个库搏斗的过程中我也乐此不疲。我也利用学到的知识绕过了另一个受限JS环境，这一次我并没有空手而归，回头我希望能够尽快公布相关研究报告。
这里还得再次感谢Matt Austin之前关于[static-eval](https://maustin.net/articles/2017-10/static_eval)的研究成果，没有这些成果支撑，也许我不会发现这个新的漏洞。
在测试目标系统方面，我们可以考虑在本地环境中复现并控制系统的每个功能，这样我们测试起来可以更加自由。在本文中，我使用了部署`static-eval`库的一个Docker实例，在此基础上尝试绕过沙箱。我的问题在于，我在整个研究过程中只使用过这个实例，没有去验证这种技术在实际网站中是否可用。如果我先验证了这一点，很可能早就发现这一点，可以早点腾出手来。这里我们可以吸取教训，不要过于抽象整个环境，我们需要不断测试在实际系统中的发现，而不是埋头钻到实验环境中。
最后提一下，如果我们正在审计部署类似系统的站点，该站点会将用户可控的表达式在沙箱中执行，我建议大家可以好好用心分析这个环境。沙箱系统很难尽善尽美，如果沙箱能够执行动态、全功能的编程语言（如JavaScript、Python或者Ruby）的话更难面面俱到。当我们发现沙箱绕过漏洞时，这种漏洞往往能够对包含该系统的应用造成重大影响。
## 八、时间线
  * 01/02/19 – 将漏洞信息提交给NodeJS安全团队以及static-eval维护人员，大家可以参考[原始报告](https://licenciaparahackear.github.io/posts/static-eval-sandbox-escape-original-writeup/)
  * 01/03/19 – NodeJS安全团队复现漏洞，告诉我他们将联系程序库维护人员，如果维护人员不响应报告，则会公布安全公告
  * 02/14/19 – [nmpjs网站上公布安全公告](https://www.npmjs.com/advisories/758)
  * 02/15/19 – [漏洞已被修复](https://github.com/browserify/static-eval/pull/21) ，发布新版程序库
  * 02/18/19 – 程序库的README文件已更新，提到该库[不应该](https://github.com/browserify/static-eval/pull/22/files)作为沙箱来使用
  * 02/26/19 – 发布新的[补丁](https://github.com/browserify/static-eval/pull/23)，因为我最早的补丁有个bug，导致`static-eval`仍然存在漏洞