时，系统会增加它的优先级：这样，当它准备继续执行的时候，就会因为有了比较高的优先级
而优先运行。进程的优先级基数可以用nice命令设置，用renice命令进行调整。nice命令的作用
活跃进程的优先级基数。我们感兴趣的数值列在“NI”（nice）那一栏。如下所示：
Sp8-1
0501
PIDPPID PRI NI SIZE RSS WCHAN
11085756130b85
ALL YIS
TIKE COMMANT
我们看到oclock程序以默认的优先级基数运行着。如果我们用下面的命令来启动它：
5nice oclock&
它将分配到一个等于+10的优先级基数值。如果我们用下面的命令调整这个基数值：
$renice 10 146
146: old priority 0,new priority 10
这个时钟程序就将运行得不那么频繁了我们再用ps命令查看修改后的优先级基数值：
501
146
S8G0195580101
ALINS
Nv01
e:00 oc1o.°k
TIME COMPANE
加入jaVa编程群：524621833
---
## Page 321
第10章进程和信号
303
状态栏“STAT”里现在多出--个“N”，这表示此进程的优先级基数已经不是它原来的默认
值了。ps命令输出中的“PPID”域给出的是父进程的进程ID，它是启动此进程运行的那个进程
的PID：如果原来的父进程已经不存在了，就以init为父进程（PID值为1）
UNIX进程调度器以优先级为根据决定允许哪个进程能够运行。各种版本的具体做法当然会
有差异，但高优先级进程总会运行得更频繁一些。在某些情况下，只要还有高优先级进程可以
运行，低优先级进程就根本不能运行。
10.3启动新的进程
我们可以让一个程序在另一个程序的内部运行，也就是说，我们创建了一个新的进程。这
个工作可以通过库函数system来实现。下面是它的定义：
#include 
int systen (const char *string1;
system函数的作用是执行以字符串参数的形式传递给它的命令，并等待命令的完成。这个命
令的执行情况就好像shell中的下面这条命令：
$sb -c string
如果无法启动shell运行命令，system将返回“127”；出现不能执行system调用的其他错误
时返回“-1”，如果system能够顺利执行，它将返回那个命令的退出码。
动手试试：system函数
我们利用system函数编写一个程序，让它替我们运行ps命令。虽然这个程序本身的用处不是
很大，但我们将在后面的例子里对这一技术做进一步开发。其实从示例程序就可以看出来，
system调用能够大大简化程序的编写工作
#include 
include 
int main()
printf(*Running ps vith systen\n*):
printf(*Done.\n*):
system(*ps -ax*);
exit(0) :
当我们编译并运行这个system.c程序的时候，将看到如下所示的执行情况：
$./eyatem
Running ps with systen
PIDTTY STATTIHE COMAND
0:00 update (bdflush)
0:00 init
146v01 SN0:00 oc1ock
257 pp0 R
256 pp0 S
0:00 ./system
Done,
0:00 ps -ax
因为system函数要使用一个shell来启动预定的程序，所以我们可以把它放到后台去运行，目
加入jaVa编程群：524621833
---
## Page 322
304
Linux程序设计
t/G
体做法是把system.c中的函数调用语句修改为如下所示的样子：
(, x-d)uss
当我们编译并运行这个新版程序的时候，我们将看到：
./system2
Running ps with system
Dona
PID TTY STAT TIME COMMAND
0:00 init
0:00 update (bdflush)
146 v01 S N
766 pp0 R
xe-sd00:0
0:00 oclock
操作注释：
在第--个例子里，程序以字符串“ps-ax”为参数调用system函数，相当于执行ps程序。我
们的程序在ps命令完成后从system调用中返回。system函数可以很有用，但也有局限性。因为我
们的程序必须等待由system调用启动的进程结束之后才能继续，我们就不能同时执行其他工作。
在第二个例子里，对system的调用将在shell命令结束时立刻返回。因为那个shell命令只是把
一个程序放到后台去运行的一个请求，所以ps程序一开始运行shell就返回了，这和我们在shell提
示符处敲人下面这条命令的效果的一样的：
S D8 -ax &
shell返回后，我们的程序在打印出“Done.”之后也返回了，但此时ps命令还没来得及产生
任何输出呢。我们的程序结束之后，ps命令的输出出现在shell提示符处。进程的这类行为往往
会给用户带来极大的困感。想用好进程就必须对它们的动作做细致的调控。我们下面向大家介
绍一个创建进程用的底层接口：exeC。
一般说来，system函数远非是启动其他进程的理想手段，因为它必须用一个shell来
启动预定的程序。围为必须先启动一个shell，然后才能启动程序，所以这种办法的效率
很低：对shell的安装情况和它所处的环境的依赖也很大。我们将在下一节看到一种先进
得多的程序启动办法，与system调用相比，我们应该坚持在程序设计中把它做为首选。
替换一个进程映像
exec名下是由多个关联函数组成的一个完整系列。在新进程的启动方式和程序参数的传递办
法方面，它们各有各的做法。一个exec函数可以把当前进程替换为一个新进程，新进程由path或
file参数指定。
#inelude 
char **environ:
int execl(vonst char *path, const char *argo,
(char*)01;
int execle(const char *path. const char *argo,
inr
+ + - 1
(char *)0.const char *envp[11:
(char *)0};
int execv(const char *path, const char *argv(]);
加入jaVa编程群：524621833
---
## Page 323
第10章进程和信号
305
int execvp(const char ·file. const ehar *argv[]);
int execveiconst char *path, const char *argv[]. const char *envp]);
这些函数可以分为两大类：execl、execlp和execle的参数个数是可变的，参数以一个空指针
结束；execv和execvp的第二个参数是一个字符串数组，新程序在启动时会把在argv数组中给定
的参数传递到main。这些函数通常都是用execve实现的，这是一种约定俗成的做法，并不是非
这样不可。
名字最后一个字母是“p”的函数会搜索PATH环境变量去查找新程序的可执行文件。如果
可执行文件不在PATH定义的路径上，就必须把包括子目录在内的绝对文件名做为一个参数传递
给这些函数。
全局变量environ可以用来把一个值传递到新的程序环境中去。execle和exccve能够通过比其
他函数多出来的那个参数传递一个字符申数组，这个数组将被用做新的程序环境。
如果我们想通过exec函数来启动ps程序，可以有下面几种选择：
#jnclude 
/ Exanple of an argument 1ist */
const char *ps_argv(]
/* Note that we need a program name for argv[0] */
{"ps*，*-ax*,0};
/*Example environment,not terribiy useful*/
const char
{*PATH=/bin:/usr/bin*,*TERX=console*,0}：
[]daua"sd.
/*Possible calls to exec functions*/
execl(*/bin/ps*，*ps*-ax*，01;
axeclp{"ps*，'ps*.
/* assumes ps is in /bin */
/、uouuzue wno sassed、/:（dauasd0,xe-.sd,sd/uyq/.)eroaxa
'-ax',0};
/*assumes/bin is in PATH */
execv(*/bin/ps*, ps_argv):
execve(*/bin/ps*, ps_argv. ps_envp);
execvp(*ps*. ps_argv1:
动手试试：execlp函数
修改程序，让它使用一个execlp调用。
#inciude 
#include 
int nain()
printf(*Running ps with execlp\n*);
execlpi*ps*,*ps*,
-ax*,0)；
printf(*Done,\n*);
exit (0) :
我们给这个程序起名为pexec.c，当运行这个程序的时候，会看到正常的ps输出，但“Done.”
消息却根本没有出现。另外值得注意的地方是：ps输出里根本就没有名为pexec的进程的任何资料。
Running ps with execlp
S./pexec
PID TTY STAT
1?S
TIME COMNAND
0:00 init
加入jaVa编程群：524621833
---
## Page 324
306Linux程序设计
7S0:00 update(bdfluzh)
146v01 SND:0G oc1ock
操作注释：
程序先打印出自己的第·条消息，接着调用了excclp，这个函数会在PATH环境变量给出的
子目录里搜索一个名为ps的程序。找到后执行这个程序，并用它替换掉我们的pexec程序，就好
像我们给出的是如下所示的shell命令一样：
P8 -8x
当ps结束的时候，我们看到的是--个新的sheli提示符。我们没有返回到pexec去，所以第二
条消息是不会被打印出来的。新进程的PID与原先的完全一样，父进程PID和优先级基数也相同。
从效果上看，这里发生的一切其实就是运行中的程序转去执行来自exec调用中指定的可执行文
件中的新代码了。
对一个由exec函数启动进程来说，它的参数表和环境加在一起的总长度是有限制的。这个上
限由ARG_MAX给出，在Linux系统上它是128K字节。其他系统可能会设置一个大大缩藏了的限
度，有可能导致出现问题。POSIX技术规范规定ARG_MAX至少要有4096个字节。
如果没有出现错误，exec函数一般是不返回的。在出现错误时，exec函数将返回“-1”，并
且会设置错误变量erno。
由exec启动的新进程继承了原进程的许多东西。值得注意的有：已经打开了的文件描述符在
新进程里仍将是打开的一除非它们的“exce调用时关闭此文件”标志被置了位（详细说明请参
考第3章中对fcntl系统调用的介绍）。但原进程中任何已经打开的子目录流将被关闭。
复制一个进程映像
如果想用进程同时执行多个函数有两种办法：一是使用我们将在下一章介绍的线程；二是
从原程序里创建一个全新的进程，就像init的做法一样。不能像exec调用那样用新进程替换掉当
前的执行线程了。
调用fork可以创建一个全新的进程。这个系统调用对当前进程进行复制，在进程表里创建出
一个新的项目，新项目的许多属性与当前进程是相同的。新进程几乎与原进程一模一样，执行
是也是相同的代码，但新进程有自己的数据空间、自己的环境和自己的文件描述符。把fork与
cxcc函数结合起来就可以创建出薪的进程了。
#include 
include 
pid_t fork(void):
在父进程中调用fork返回的是新子进程的PID：新进程将继续执行，就像原进程一样，只
不过在子进程里调用fork将返回“0”。我们可以利用这一特点把父、子进程区分开如图10-2
所示。
加入jaVa编程群：524621833
---
## Page 325
第10章进程和信号
307
原来的进程
Fork0
返回一个新的PID
返间“0”
原来的进积
维续执行
新进
图10-2
如果fork失败了，它将返回“-1”。失败的原因通常是父进程拥有的子进程个数超过了规定
的限制（CHILD_MAX），此时errmo将被设置为EAGAIN。如果失败的原因是进程表里没有足够
的空间来创建一个新的项目，或者是因为虚拟内存不足，crrmo变量将被设置为ENOMEM。
fork的典型用法如下所示：
pid_t new_pid;
new_pid = fork(1;
switch(new_pid){
case -1 :
break;
/* Error */
case 0 :
/* We are child */
default :
break;
/* We are paxent */
break;
动手试试：fork函数
请看下面这个简单的例子，fork.c程序。
#include 
#include 
include 
int nain()
pid_t pid;
加入jaVa编程群：524621833
---