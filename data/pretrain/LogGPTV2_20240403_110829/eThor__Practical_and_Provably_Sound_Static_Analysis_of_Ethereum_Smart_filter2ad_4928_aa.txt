title:eThor: Practical and Provably Sound Static Analysis of Ethereum Smart
Contracts
author:Clara Schneidewind and
Ilya Grishchenko and
Markus Scherer and
Matteo Maffei
eThor: Practical and Provably Sound Static Analysis
of Ethereum Smart Contracts
Clara Schneidewind
Ilya Grishchenko
Markus Scherer
Matteo Maffei
TU Wien
{clara.schneidewind,markus.scherer,ilya.grishchenko,matteo.maffei}@tuwien.ac.at
0
2
0
2
y
a
M
3
1
]
L
P
.
s
c
[
1
v
7
2
2
6
0
.
5
0
0
2
:
v
i
X
r
a
ABSTRACT
Ethereum has emerged as the most popular smart contract develop-
ment platform, with hundreds of thousands of contracts stored on
the blockchain and covering a variety of application scenarios, such
as auctions, trading platforms, and so on. Given their financial na-
ture, security vulnerabilities may lead to catastrophic consequences
and, even worse, they can be hardly fixed as data stored on the
blockchain, including the smart contract code itself, are immutable.
An automated security analysis of these contracts is thus of utmost
interest, but at the same time technically challenging for a variety
of reasons, such as the specific transaction-oriented programming
mechanisms, which feature a subtle semantics, and the fact that the
blockchain data which the contract under analysis interacts with,
including the code of callers and callees, are not statically known.
In this work, we present eThor, the first sound and automated
static analyzer for EVM bytecode, which is based on an abstraction
of the EVM bytecode semantics based on Horn clauses. In particular,
our static analysis supports reachability properties, which we show
to be sufficient for capturing interesting security properties for
smart contracts (e.g., single-entrancy) as well as contract-specific
functional properties. Our analysis is proven sound against a com-
plete semantics of EVM bytecode and an experimental large-scale
evaluation on real-world contracts demonstrates that eThor is practi-
cal and outperforms the state-of-the-art static analyzers: specifically,
eThor is the only one to provide soundness guarantees, terminates
on 95% of a representative set of real-world contracts, and achieves
an F-measure (which combines sensitivity and specificity) of 89%.
1 INTRODUCTION
Smart contracts introduced a radical paradigm shift in distributed
computation, promising security in an adversarial setting thanks
to the underlying consensus algorithm. Software developers can
implement sophisticated distributed, transaction-based computa-
tions by leveraging the scripting language offered by the underlying
blockchain technology. While many cryptocurrencies have an in-
tentionally limited scripting language (e.g., Bitcoin [41]), Ethereum
was designed from the ground up with a quasi Turing-complete
language1. Ethereum smart contracts have thus found a variety
of appealing use cases, such as auctions [27], data management
1While the language itself is Turing complete, computations are associated with a
bounded computational budget (called gas), which gets consumed by each instruction
thereby enforcing termination.
Accepted for ACM CCS, 2020
.
1
systems [9], financial contracts [15], elections [40], trading plat-
forms [39, 43], permission management [13] and verifiable cloud
computing [20], just to mention a few. Given their financial nature,
bugs and vulnerabilities in smart contracts may lead to catastrophic
consequences. For instance, the infamous DAO vulnerability [1]
recently led to a 60M$ financial loss and similar vulnerabilities oc-
cur on a regular basis [2, 3]. Furthermore, many smart contracts in
the wild are intentionally fraudulent, as highlighted in a recent sur-
vey [12]. Even worse, due to the unmodifiable nature of blockchains,
bugs or vulnerabilities in deployed smart contracts cannot be fixed.
A rigorous security analysis of smart contracts is thus crucial for
the trust of the society in blockchain technologies and their wide-
spread deployment. Unfortunately, this task is quite challenging
for various reasons. First, Ethereum smart contracts are developed
in an ad-hoc language, called Solidity, which resembles JavaScript
but features non-standard semantic behaviours and transaction-
oriented mechanisms, which complicate smart contract develop-
ment and verification. Second, smart contracts are uploaded on
the blockchain in the form of Ethereum Virtual Machine (EVM)
bytecode, a stack-based low-level code featuring very little static
information, which makes it extremely difficult to analyze. Finally,
most of the data available at runtime on the blockchain, including
the contracts which the contract under analysis may interact with,
may not be known statically, which requires ad-hoc abstraction
techniques. As a result, while effective bug finding tools for smart
contracts have been recently presented, there exists at present no
automated security analysis for EVM bytecode that provides formal se-
curity guarantees (i.e., absence of false negatives, as proven against
a formal semantics of EVM bytecode), as further detailed below.
1.1 State-of-the-art in Security Analysis of
Smart Contracts
Existing approaches to smart contract analysis can be mainly classi-
fied as interactive frameworks for semantic-based machine-checked
proofs [11, 14, 25, 29, 30, 49] and automated, heuristic-driven bug
finding tools [23, 35, 38, 42, 50].
Some recent works try to fill the middle ground between these
two approaches, aiming at the best of the two worlds, i.e., an au-
tomated, yet sound static analysis of Ethereum smart contracts
that can prove generic security properties [24, 34, 37, 48]. We con-
ducted a thorough investigation, finding out that all of them fail
to provide the intended soundness guarantees, which showcases
the difficulty of this task. In the following, we further expand on
this point, highlighting the particular challenges that occur in the
Accepted for ACM CCS, 2020
Clara Schneidewind, Ilya Grishchenko, Markus Scherer, and Matteo Maffei
process of designing a sound static analysis tool for Ethereum smart
contracts.
we found an example showing that this algorithm yields unsound
results(see § D.1), undermining the soundness of the analysis.
Semantic foundations. A first fundamental limitation of most
existing static analysis tools is that they do not establish a formal
connection with a semantic model of smart contract execution.
ZEUS [34] leverages existing symbolic model checking tools for
LLVM bitcode in order to analyze contracts written in Solidity. To
this end, ZEUS first translates Solidity code into an abstract inter-
mediate language and in a next step into LLVM bitcode. However,
upto now, there is no complete formal semantics of the Solidity
language, hence making it impossible to prove the performed trans-
lation to be semantics-preserving and consequently to derive formal
guarantees from the results of the LLVM model checking. This can
easily lead to flaws, as confirmed by the theoretical investigation
conducted in [24] as well as by empirical evidence provided in [47],
which contradict the original soundness claim [34]. [24] reviews a
theoretical approach to a static analysis technique based on Horn
clauses which is claimed to be provably sound, still we could find
sources of unsoundness in the presented abstraction as detailed in
§ D.4. Securify [48] is an abstract interpreter working at the level
of EVM bytecode that also aims to offer soundness guarantees: un-
fortunately, it does not come with any formal semantics or proof of
soundness, which leads to both false positives and false negatives,
as discussed below.
Formal security properties. As hinted in the previous paragraph,
for providing reliable guarantees, not only the analysis but also the
security properties have to be formalized in the underlying seman-
tic model. All reportedly sound tools do not accomplish that. While
for ZEUS the intended properties are just informally described, Se-
curify comes with an ad-hoc formalism for characterizing security
properties of smart contracts. This, however, is not related to a
formal EVM bytecode semantics, nor are the security patterns that
are used in the analysis to determine the fulfillment and violation of
these properties2 provably related to such formal characterization.
This omission results in the lack of soundness and completeness
guarantees, as we illustrate in § D.2 by providing counterexam-
ples for the majority of the proposed patterns. Similarly, the tool
NeuCheck [37] performs a purely syntactic analysis on Solidity
source code and defines security properties by syntactic patterns
on the smart contract’s syntax tree. These patterns cannot be related
to any semantic property due to a lacking formalism, and can be
shown to be neither necessary nor sufficient for the corresponding
security properties, see § D.3.
Correct control flow reconstruction. Analyzing EVM bytecode
is particularly challenging as the underlying execution model al-
lows for dynamic jump destinations. Most works [10, 38, 44, 48]
reconstruct the control flow of a given smart contract before the
analysis. However, recovering jump destinations is interconnected
with the contract’s execution, and hence, performing such a sound
reconstruction is not trivial. For instance, [48] uses a custom algo-
rithm – whose correctness is never discussed – for doing so. Indeed
2[48] introduces compliance and violation patterns for security properties where a
contract matching a compliance pattern is meant to satisfy the property and a contract
matching a violation pattern to violate it.
2
Practicality. A useful, automated analysis tool needs to be per-
formant, not only in terms of overall execution time, but also in
terms of precision. This is particularly challenging as the soundness
goal prevents the use of (potentially cheap and fast) heuristics to
guide the analysis, but instead requires the chosen abstractions to
provably over-approximate the set of all possible executions. Ap-
propriate abstractions hence need to be sound, but still efficiently
encodable and precise enough to account for a contract’s safety.
Benchmarking, testing, and community validation. The previous
problems which affect the design of reliable analysis tools are ag-
gravated by the fact that there is no reliable and comparable bench-
marking or testing infrastructure for Ethereum smart contract anal-
ysis tools. One reason for that is the lack of clear definitions for the
generic security properties targeted by the analysis tools in the first
place. Another explanation is the difficulty of manually investigat-
ing the bytecode of real-world contracts for assessing their ground
truth. Even though the existing works evaluate their performance
on real world smart contracts (fetched from the blockchain), the
used ground truth is spurious: While [48] reports quality metrics
only on a dataset of 100 contracts which are not made available, [34]
presents results on a dataset encompassing over 1500 contracts from
the blockchain. When manually investigating this dataset, however,
we found several issues ranging from non-existing contracts to
deviating ground truths. These problems are detailed in § 5.
Inspired by the issues that we see in the state of the art, we
introduce a principled approach to the design and implementation
of a sound, yet performant, static analysis tool for EVM bytecode.
1.2 Our Contributions
The contributions of this work can be summarized as follows:
• We design the first provably sound static analyzer for EVM
bytecode, which builds on top of a reachability analysis real-
ized by Horn clause resolution. We show that a reachability
analysis suffices to verify various interesting security proper-
ties for smart contracts as well as contract-specific functional
properties via an encoding into Hoare-style reasoning. The
design of such static analysis is technically challenging, since
it requires careful abstractions of various EVM components
(e.g., the stack-based execution model, the gas used to bound
the smart contract execution, and the memory model) as
well as a dedicated over-approximation of the data stored
on the blockchain, which is not statically known and yet the
contract under analysis can interact with (e.g., the code of
other contracts which may act both as callers and callees);
• We prove the soundness of our static analysis technique
against the semantics of EVM bytecode formalized by Gr-
ishchenko et al. [25];
• In order to facilitate future refinements of our analysis, as
well as the design of similar static analyses for other lan-
guages, we design and implement HoRSt, a framework for the
specification and implementation of static analyses based on
Horn clause resolution. Specifically, HoRSt takes as input a
eThor: Practical and Provably Sound Static Analysis
of Ethereum Smart Contracts
(pen-and-paper like) specification of the Horn clauses defin-
ing the static analysis and produces a smt-lib [8] encoding
suitable for z3 [31], which includes various optimizations
such as Horn clause and constant folding;
• We use HoRSt to implement the static analyzer eThor. To gain
confidence in the resulting implementation, we encode the
relevant semantic tests (604 in total) of the official EVM suite
as reachability properties, against which we successfully test
the soundness and precision of eThor;
• We conduct a large-scale experimental evaluation on real-
world contract data comparing eThor to the state-of-the-art
analyzer ZEUS [34] which claims to provide soundness guar-
antees. While ZEUS shows a remarkable specificity (i.e., com-
pleteness) of 99.8%, eThor clearly outperforms ZEUS in terms
of recall (i.e., soundness) – 100% vs. 11.4% – which empiri-
cally refutes ZEUS’ soundness claim. With a specificity of
80%, eThor results in an overall performance of 88.9% (ac-
cording to the F-measure) as compared to ZEUS’ F-measure
of 20.4%.
The remainder of this paper is organized as follows. § 2 reviews
Ethereum and the semantics of EVM bytecode. § 3 introduces our
static reachability analysis, specifies its soundness guarantee and
discusses relevant smart contract properties in scope of the analy-
sis. § 4 introduces the specification language HoRSt. § 5 describes
eThor and presents our experimental evaluation. § 7 concludes by
discussing interesting future research directions. The appendix pro-
vides proofs and additional material. The source code of eThor and
HoRSt with the dataset used in the experimental evaluation are
available online [6].
2 ETHEREUM
We first introduce the required background on Ethereum (§ 2.1)
and then overview an existing semantics of EVM bytecode (§ 2.2),
which this work builds on.
2.1 Background
The Ethereum platform can be seen as a transaction-based state
machine where transactions alter the global state of the system,
which consists of accounts. There are two types of accounts: Ex-
ternal accounts, which are owned by a user of the system, and
contract accounts, which can be seen as a distributed program. All
accounts hold a balance in the virtual currency Ether. Additionally,
contract accounts include persistent storage and the contract’s code.
Transactions can either create new contract accounts or call exist-
ing accounts. Calls to external accounts can only transfer Ether to
this account, but calls to contract accounts additionally execute the
account’s contract code. The contract execution might influence the
storage of the account and might as well perform new transactions
– in this case, we speak of internal transactions. The effects of con-
tract executions are determined by the Ethereum Virtual Machine
(EVM). This virtual machine characterizes the quasi Turing complete
execution model of Ethereum smart contracts where the otherwise
Turing complete execution is restricted by an upfront defined re-
source gas that effectively limits the number of execution steps. A
transaction’s originator can specify an upper bound on the gas that
she is willing to pay for the contract execution and also sets the gas
3
Accepted for ACM CCS, 2020
Callstacks
S
Plain callstacks U
Machine states
µ
Account states
a
:= EXC :: U | HALT(σ, gas, d, η) :: U | U
:= (µ, ι, σ, η) :: U | ϵ