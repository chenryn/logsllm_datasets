two encrypted values. Let Even (resp. Odd) denote the XOR sum
of all seeds 𝑆𝑖+1,𝑗 for even 𝑗 (resp. for odd 𝑗). 𝐺 sends to 𝐸 Even
encrypted by 𝐴𝑖 ⊕ Δ and Odd encrypted by 𝐴𝑖. Thus, 𝐸 can decrypt
Even if the seed just off the path to 𝐿𝑎 is even (resp. for odd). 𝐸 can
then XOR in the even seeds (resp. odd seeds) she already holds and
recover the missing seed.
𝐺 now holds each seed 𝐿𝑖 and 𝐸 holds each 𝐿𝑖≠𝑎. By Definition 3.4,
the parties hold garbled sharings of zero at all points 𝑖 ≠ 𝑎. To
complete the shared one-hot vector, we must convey to 𝐸 a valid
share of one at position 𝑎. 𝐺 thus sends the following value to 𝐸:
(cid:16)
(cid:17) ⊕ Δ
𝐿𝑖
𝑖
4.2 Garbled One-Hot Outer Product
𝐸 XORs this value with the leaves she already holds and hence
extracts 𝐿𝑎 ⊕ Δ: a valid share of one.
Thus, the two parties compute(cid:74)H(𝑎)(cid:75) via 2(𝑛−1)+1 ciphertexts.
We now generalize the above approach to compute(cid:74)H(𝑎) ⊗ 𝑏(cid:75).
garbled sharing(cid:74)𝑏 𝑗(cid:75). Let 𝐵 𝑗 (resp. 𝐵 𝑗 ⊕ 𝑏 𝑗 Δ) be 𝐺’s (resp. 𝐸’s) share.
Let us back up to the point where the two parties each hold each
𝐿𝑖 except that 𝐸 does not hold 𝐿𝑎. For each 𝑗, the parties hold a
For each 𝑗 ∈ [𝑚] the parties act as follows. Both parties apply
a PRG to each of their leaf seeds 𝐿𝑖 and hence obtain strings 𝑋𝑖,𝑗.
Now, 𝐺 sends to 𝐸 the following value:
(cid:17) ⊕ 𝐵 𝑗
(cid:16)
(cid:17) ⊕ 𝐵 𝑗
(cid:17) ⊕(cid:16)(cid:16)
(cid:17) ⊕(cid:0)𝐵 𝑗 ⊕ 𝑏 𝑗 Δ(cid:1) = 𝑋𝑎,𝑗 ⊕ 𝑏 𝑗 Δ
𝐸 XORs this with her 2𝑛 − 1 values 𝑋𝑖≠𝑎,𝑗 and with her share of 𝑏 𝑗:
(cid:16)
𝑋𝑖,𝑗
𝑋𝑖,𝑗
𝑖
𝑋𝑖,𝑗
𝑖
𝑖≠𝑎
In other words, at index 𝑎, 𝐸 receives a share of 𝑏 𝑗.
Thus, the parties now hold a sharing of a 2𝑛 × 𝑚 matrix 𝑥 where
each row is all zeros except row 𝑎: row 𝑎 holds the vector 𝑏. We
The full construction, formalized in Figure 3, requires 𝐺 send to
have constructed(cid:74)H(𝑎) ⊗ 𝑏(cid:75).
𝐸 2(𝑛 − 1) + 𝑚 ciphertexts.
Recall that garbled shares support linear maps (Lemma 3.5) and
that for any function 𝑓 the following equality holds:
T (𝑓 )⊺ · H(𝑎) = 𝑓 (𝑎)
Lemma 3.3
Zero Knowledge. We briefly mention that our one-hot outer prod-
uct implies improvement for GC-based Zero Knowledge [JKO13,
HK20b]; we emphasize that our focus is 2PC, not ZK.
In ZK, 𝐸 knows each circuit wire value, so our requirement that
𝐸 knows the argument to H(·) is met automatically. Thus, in GC-
ZK we can compute any function using only 2𝑛 − 1 ciphertexts by
of 𝑓 small, since the parties construct a tree with 2𝑛 leaves.
computing T (𝑓 )⊺ ·(cid:74)H(𝑎)(cid:75). However, we must keep the domain
If 𝑓 requires a large circuit, then this truth-table based approach
can improve over the circuit. For example, if the ZK proof invokes
SHA256 on a small domain 𝑛-bit input, we need only 2𝑛 − 1 ci-
phertexts. The hand tuned SHA256 circuit, on the other hand, has
a staggering 22573 AND gates [AAL+]. Other ZK protocols, e.g.
[WYKW21], can similarly use truth tables by brute force construct-
ing a one-hot encoding (at the cost of 𝑂(2𝑛) AND gates). However,
as the size of the input grows, our technique becomes more effi-
cient. For tables with more than 9 input bits, our GC-based one-hot
encoding will improve over other protocols.
2PC. We now consider 2PC applications where both parties have
input and neither party knows any intermediate wire value.
Since our one-hot outer product primitive requires 𝐸 to know
the argument 𝑎, we must reveal 𝑎 to 𝐸 in cleartext. Of course, we
cannot arbitrarily reveal cleartext values to 𝐸: this would not be
secure. Instead, we are careful to only reveal values that have a
mask applied such that the cleartext value remains protected.
We illustrate this idea by example. Let 𝑎 ∈ {0, 1}𝑛 and 𝑏 ∈ {0, 1}𝑚
be two bitstrings. Moreover, let 𝑛, 𝑚 be small. (Formally, let 𝑛, 𝑚 be
at most logarithmic in the overall circuit input size. This restriction
avoids exponential-time computation due to the one-hot technique.)
Suppose the parties hold two sharings(cid:74)𝑎(cid:75) and(cid:74)𝑏(cid:75) and wish to
compute the (non-one-hot) outer product(cid:74)𝑎 ⊗ 𝑏(cid:75). Note that outer
The parties compute(cid:74)𝑎 ⊕ 𝛼(cid:75) and(cid:74)𝑏 ⊕ 𝛽(cid:75) inside GC. Now, it is safe
products are useful since they can be leveraged to compute matrix
products, integer products, and more (see Section 7).
First, 𝐺 chooses two uniform masks 𝛼 ∈ {0, 1}𝑛 and 𝛽 ∈ {0, 1}𝑚.
to reveal the values 𝑎 ⊕ 𝛼 and 𝑏 ⊕ 𝛽 to 𝐸 in cleartext. These values
are revealed by 𝐺 sending his color bits to 𝐸3.
From here, the parties use the following straightforward lemma:
Lemma 4.1. Let 𝑥 ∈ {0, 1}𝑛, 𝑦 ∈ {0, 1}𝑚 be two bitstrings and let
id : {0, 1}𝑛 → {0, 1}𝑛 denote the identity function:
T (id)⊺ · (H(𝑥) ⊗ 𝑦) = 𝑥 ⊗ 𝑦
4.3 Applying the One-Hot Encoding
We now give some examples of how the one-hot outer product can
be used. We greatly expand on this topic in Section 7.
3Alternatively and more directly, 𝐺 can define 𝛼 (resp. 𝛽) to be his color bits of 𝑎 (resp.
𝑏). This avoids sending small cleartext values to 𝐸 and is similar to the method used
in [ZRE15]. Here, we introduce the idea that 𝐺 can send color bits of a masked value
to 𝐸 because this sending generalizes to non-XOR masks.
Session 2D: Secure Multiparty ComputationCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea578Proof.
T (id)⊺ · (H(𝑥) ⊗ 𝑦)
= T (id)⊺ · (H(𝑥) · 𝑦⊺)
= (T (id)⊺ · H(𝑥)) · 𝑦⊺
= id(𝑥) · 𝑦⊺
= 𝑥 · 𝑦⊺
= 𝑥 ⊗ 𝑦
Definition ⊗
Associativity
Lemma 3.3
Definition id
Definition ⊗
□
In particular, the parties compute the following two values:
Finally, the parties compute the following:
T (id)⊺ ·(cid:74)H(𝑎 ⊕ 𝛼) ⊗ 𝑏(cid:75) =(cid:74)(𝑎 ⊕ 𝛼) ⊗ 𝑏(cid:75)
T (id)⊺ ·(cid:74)H(𝑏 ⊕ 𝛽) ⊗ 𝛼(cid:75) =(cid:74)(𝑏 ⊕ 𝛽) ⊗ 𝛼(cid:75)
(cid:74)(𝑎 ⊕ 𝛼) ⊗ 𝑏(cid:75) ⊕(cid:74)(𝑏 ⊕ 𝛽) ⊗ 𝛼(cid:75)⊺ ⊕(cid:74)𝛼 ⊗ 𝛽(cid:75)
=(cid:74)𝑎 ⊗ 𝑏(cid:75) ⊕(cid:74)𝛼 ⊗ 𝑏(cid:75) ⊕(cid:74)𝑏 ⊗ 𝛼(cid:75)⊺ ⊕(cid:74)𝛽 ⊗ 𝛼(cid:75)⊺ ⊕(cid:74)𝛼 ⊗ 𝛽(cid:75)
=(cid:74)𝑎 ⊗ 𝑏(cid:75) ⊕(cid:74)𝛼 ⊗ 𝑏(cid:75) ⊕(cid:74)𝛼 ⊗ 𝑏(cid:75) ⊕(cid:74)𝛼 ⊗ 𝛽(cid:75) ⊕(cid:74)𝛼 ⊗ 𝛽(cid:75)
=(cid:74)𝑎 ⊗ 𝑏(cid:75)
Thus, 𝐸 and 𝐺 can compute the outer product(cid:74)𝑎 ⊗ 𝑏(cid:75) using only
(𝐺 knows 𝛼 ⊗ 𝛽, so he can inject this value as a GC constant.)
two one-hot outer products. In total, 𝐺 sends to 𝐸 3(𝑛 + 𝑚) − 4
ciphertexts. This is a significant improvement compared to com-
puting the outer product via AND gates: the AND-gate method
consumes 2𝑛𝑚 ciphertexts.
As an interesting aside, the above technique is a strict general-
ization of the [ZRE15] half-gates technique. Namely, if we consider
length one inputs 𝑎 and 𝑏, the above technique computes Boolean
AND using only two ciphertexts. Moreover, the numbers of per-
party calls to 𝐻 match the half-gates technique.
While we have shown here only how to compute an outer prod-
uct, our technique improves other functions as well (see Section 7).
We highlight the key ideas common to such constructions:
(1) Apply a mask to an internal circuit value such that it is safe
to reveal the masked value to 𝐸.
(2) Use the revealed value as input to a one-hot outer product.
(3) Apply a function, via truth table, to this outer product matrix.
(4) Use simple algebra to remove the introduced masks and
obtain the desired output sharing. The parties can use the
output in further GC evaluation.
4.4 A Framework for One-Hot Techniques
We found a number of interesting functions that can be efficiently
implemented using the one-hot outer product (see Section 7). We
certainly did not find all such functions. Thus, part of our contribu-
tion is a simple framework for designing new such constructions,
which can then be directly used without building a new garbling
scheme from the ground up.
Section 5 motivates and explains this framework in detail. In
brief, notice our above high-level strategy involves revealing clear-
text values to 𝐸. Our framework provides a simple infrastructure
that prevents insecure leakage by packaging sensitive values into
modules and ensuring these values cannot leave the module.
Our framework is a tool for designing modules that implement
useful functions inside GC. Modules are built from a small set
Figure 2: Left: Reveal gates safely reveal values to 𝐸. At run-
time, 𝐺 samples a mask 𝛼 from the designer-specified dis-
tribution Dmask. This mask, and the input, are fed into the
designer-specified function C. For security, the output of C
must be indistinguishable from a value sampled from some
output distribution Dout, even in the context of the input
𝑎 (Requirement 2, Section 5.3). The masked value C(𝑎, 𝛼) is
revealed in cleartext to 𝐸 and 𝛼 is given to 𝐺. The masked
value C(𝑎, 𝛼) and the mask 𝛼 are output as GC shares.
Right: A module M implements a specific function and en-
capsulates any internal randomness that can emerge from
Reveal gates. M must satisfy Requirement 1 (Section 5.3).
of primitives provided by the framework. These primitives allow
the designer to specify what to compute, how to sample auxiliary
randomness, and what to reveal to 𝐸. Crucially, the module de-
signer will not directly manipulate garbled labels, material, and
other garbling scheme artifacts – all such handling is done through
the framework’s primitives. In particular, this means that the mod-
ule designer need not prove her GC instantiation secure: module
security follows from our framework’s security theorems.
5 OUR GARBLING FRAMEWORK
In this section we formalize our approach. Typically, GC approaches
consider simple gates, e.g. XOR/AND or ADD/MUL; the resulting
GC framework is simple to prove and use. Ours is more complex.
At the heart of this complexity lies our highly nonstandard one-
hot outer product gate. In particular, the gate is nonstandard because
it requires that 𝐸 know one of its inputs. Thus, to use the gate
effectively, the GC must reveal certain values to 𝐸.
One direction we could take, but which we do not take, would
be to expose one-hot gates to the circuit designer and to allow her
to manage (e.g., via masking) the information release associated
with its efficient use in GC. This would not be ideal, since each new
top level circuit would require a new proof of security.
Instead, we do not allow our one-hot primitive to be used by
top level circuits. Rather, these gates must be packaged into self-
contained modules. Each module can use our primitive to efficiently
implement a specific function. As a module might internally reveal
values to 𝐸, it must satisfy certain simple security properties. Once
these properties are proved, the module may be used by a top level
circuit as if it were a standard gate.
Cα←DmaskaC(a,α)ERevealx←Dout{a,C(a,α)}c={a,x}GMM(a)=f(a)aSession 2D: Secure Multiparty ComputationCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea579Input: 𝐸 inputs 𝑎. Parties together input shared bitstrings(cid:74)𝑎(cid:75) and(cid:74)𝑏(cid:75) where 𝑎 ∈ {0, 1}𝑛, 𝑏 ∈ {0, 1}𝑚.
Output: Parties output a shared matrix(cid:74)H(𝑎) ⊗ 𝑏(cid:75).
Procedure:
• Let 𝐴𝑖 represent 𝐺’s share of each bit 𝑎𝑖; hence 𝐸 holds 𝐴𝑖 ⊕ 𝑎𝑖 Δ.
• Our first goal is to deliver to 𝐸 2𝑛 − 1 out of 2𝑛 pseudorandom seeds where the 𝑎th seed is missing:
• 𝐸 and 𝐺 consider a full binary tree with 2𝑛 leaves. Let 𝑁𝑖,𝑗 be the 𝑗th node on level 𝑖 and let the root reside on level −1.
• 𝐸 and 𝐺 label nodes from level 1 down with jointly agreed nonces nonce𝑖,𝑗.
• 𝐺 labels each node (except the root) with a 𝜅-bit string 𝑆𝑖,𝑗:
– 𝐺 labels 𝑁0,0 by letting 𝑆0,0 ≜ 𝐴0 ⊕ Δ and 𝑁0,1 by letting 𝑆0,1 ≜ 𝐴0.
– Consider 𝑁𝑖,𝑗 with parent 𝑁𝑖−1,⌊ 𝑗/2⌋. 𝐺 sets 𝑆𝑖,𝑗 = 𝐻(𝑆𝑖−1,⌊ 𝑗/2⌋, nonce𝑖,𝑗).
• For each level 𝑖 > 0, 𝐺 XORs all odd and all even labels:
𝑗=0 𝑆𝑖,2𝑗
Even ≜ 2𝑖−1
Odd ≜ 2𝑖−1
𝑗=0 𝑆𝑖,2𝑗+1
For each level 𝑖 > 0, the parties agree on two nonces nonce𝑖,even and nonce𝑖,odd. 𝐺 sends to 𝐸 the following two values:
𝐻(𝐴𝑖 ⊕ Δ, nonce𝑖,even) ⊕ Even
𝐻(𝐴𝑖, nonce𝑖,odd) ⊕ Odd
• 𝐸 reconstructs each label 𝑆𝑖,𝑗 except the labels along the path to leaf 𝑎:
– 𝐸 labels 𝑁0,1 with 𝐴0 if 𝑎0 = 0; otherwise she labels 𝑁0,0 with 𝐴0 ⊕ Δ (recall, her share is 𝐴0 ⊕ 𝑎0Δ).
– Consider each level 𝑖 > 0. There are two sibling nodes on level 𝑖 that do not have a labeled parent. Consider each of the other
2𝑖+1 − 2 nodes 𝑁𝑖,𝑗 with parent 𝑁𝑖−1,⌊ 𝑗/2⌋. 𝐸 computes 𝐻(𝑆𝑖−1,⌊ 𝑗/2⌋, nonce𝑖,𝑗) = 𝑆𝑖,𝑗.
– For the other nodes on level 𝑖, 𝐸 decrypts the XOR sum Even if 𝑎𝑖 is odd or Odd if 𝑎𝑖 is even; 𝐸 XORs this value with her 2𝑖 − 1
even (resp. odd) labels and hence extracts the remaining even (resp. odd) label.
• 𝐺 now holds 2𝑛 strings 𝑆𝑛−1,𝑗; 𝐸 also holds each string except 𝑆𝑛−1,𝑎. Rename these leaf strings 𝐿𝑖 ≜ 𝑆𝑛−1,𝑖.
• For each bit 𝑏 𝑗 of 𝑏:
– Let 𝐵 𝑗 be 𝐺’s share of(cid:74)𝑏 𝑗(cid:75). Hence, 𝐸 holds 𝐵 𝑗 ⊕ 𝑏 𝑗 Δ.
(cid:16)
(cid:17) ⊕ 𝐵 𝑗
(cid:17) ⊕(cid:16)(cid:16)
(cid:17) ⊕ 𝐵 𝑗
(cid:17) ⊕(cid:0)𝐵 𝑗 ⊕ 𝑏 𝑗 Δ(cid:1) = 𝑋𝑎,𝑗 ⊕ 𝑏 𝑗 Δ
– 𝐸 and 𝐺 agree on 2𝑛 fresh nonces nonce𝑖.
– For each leaf 𝑖, 𝐺 sets 𝑋𝑖,𝑗 ≜ 𝐻(𝐿𝑖, nonce𝑖). 𝐺 sends to 𝐸:
– For each leaf 𝑖 ≠ 𝑎, 𝐸 computes 𝑋𝑖,𝑗 = 𝐻(𝐿𝑖, nonce𝑖). 𝐸 then computes:
(cid:16)
𝑋𝑖,𝑗
𝑋𝑖,𝑗
𝑖
• Thus, for each column 𝑗 of 𝑋, 𝐸 and 𝐺 hold 2𝑛 values equal everywhere (i.e., each is a garbled share of zero) except at index 𝑎,
• 𝐺 outputs his matrix share 𝑋; 𝐸 outputs her matrix share 𝑋 ⊕ (H(𝑎) ⊗ 𝑏)Δ
where the parties hold an XOR share of 𝑏 𝑗 Δ: the computation outputs a shared one-hot outer product.
𝑖≠𝑎
𝑋𝑖,𝑗