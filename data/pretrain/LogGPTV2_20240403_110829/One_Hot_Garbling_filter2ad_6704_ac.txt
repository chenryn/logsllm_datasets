two encrypted values. Let Even (resp. Odd) denote the XOR sum
of all seeds ğ‘†ğ‘–+1,ğ‘— for even ğ‘— (resp. for odd ğ‘—). ğº sends to ğ¸ Even
encrypted by ğ´ğ‘– âŠ• Î” and Odd encrypted by ğ´ğ‘–. Thus, ğ¸ can decrypt
Even if the seed just off the path to ğ¿ğ‘ is even (resp. for odd). ğ¸ can
then XOR in the even seeds (resp. odd seeds) she already holds and
recover the missing seed.
ğº now holds each seed ğ¿ğ‘– and ğ¸ holds each ğ¿ğ‘–â‰ ğ‘. By Definition 3.4,
the parties hold garbled sharings of zero at all points ğ‘– â‰  ğ‘. To
complete the shared one-hot vector, we must convey to ğ¸ a valid
share of one at position ğ‘. ğº thus sends the following value to ğ¸:
(cid:16)
(cid:17) âŠ• Î”
ğ¿ğ‘–
ğ‘–
4.2 Garbled One-Hot Outer Product
ğ¸ XORs this value with the leaves she already holds and hence
extracts ğ¿ğ‘ âŠ• Î”: a valid share of one.
Thus, the two parties compute(cid:74)H(ğ‘)(cid:75) via 2(ğ‘›âˆ’1)+1 ciphertexts.
We now generalize the above approach to compute(cid:74)H(ğ‘) âŠ— ğ‘(cid:75).
garbled sharing(cid:74)ğ‘ ğ‘—(cid:75). Let ğµ ğ‘— (resp. ğµ ğ‘— âŠ• ğ‘ ğ‘— Î”) be ğºâ€™s (resp. ğ¸â€™s) share.
Let us back up to the point where the two parties each hold each
ğ¿ğ‘– except that ğ¸ does not hold ğ¿ğ‘. For each ğ‘—, the parties hold a
For each ğ‘— âˆˆ [ğ‘š] the parties act as follows. Both parties apply
a PRG to each of their leaf seeds ğ¿ğ‘– and hence obtain strings ğ‘‹ğ‘–,ğ‘—.
Now, ğº sends to ğ¸ the following value:
(cid:17) âŠ• ğµ ğ‘—
(cid:16)
(cid:17) âŠ• ğµ ğ‘—
(cid:17) âŠ•(cid:16)(cid:16)
(cid:17) âŠ•(cid:0)ğµ ğ‘— âŠ• ğ‘ ğ‘— Î”(cid:1) = ğ‘‹ğ‘,ğ‘— âŠ• ğ‘ ğ‘— Î”
ğ¸ XORs this with her 2ğ‘› âˆ’ 1 values ğ‘‹ğ‘–â‰ ğ‘,ğ‘— and with her share of ğ‘ ğ‘—:
(cid:16)
ğ‘‹ğ‘–,ğ‘—
ğ‘‹ğ‘–,ğ‘—
ğ‘–
ğ‘‹ğ‘–,ğ‘—
ğ‘–
ğ‘–â‰ ğ‘
In other words, at index ğ‘, ğ¸ receives a share of ğ‘ ğ‘—.
Thus, the parties now hold a sharing of a 2ğ‘› Ã— ğ‘š matrix ğ‘¥ where
each row is all zeros except row ğ‘: row ğ‘ holds the vector ğ‘. We
The full construction, formalized in Figure 3, requires ğº send to
have constructed(cid:74)H(ğ‘) âŠ— ğ‘(cid:75).
ğ¸ 2(ğ‘› âˆ’ 1) + ğ‘š ciphertexts.
Recall that garbled shares support linear maps (Lemma 3.5) and
that for any function ğ‘“ the following equality holds:
T (ğ‘“ )âŠº Â· H(ğ‘) = ğ‘“ (ğ‘)
Lemma 3.3
Zero Knowledge. We briefly mention that our one-hot outer prod-
uct implies improvement for GC-based Zero Knowledge [JKO13,
HK20b]; we emphasize that our focus is 2PC, not ZK.
In ZK, ğ¸ knows each circuit wire value, so our requirement that
ğ¸ knows the argument to H(Â·) is met automatically. Thus, in GC-
ZK we can compute any function using only 2ğ‘› âˆ’ 1 ciphertexts by
of ğ‘“ small, since the parties construct a tree with 2ğ‘› leaves.
computing T (ğ‘“ )âŠº Â·(cid:74)H(ğ‘)(cid:75). However, we must keep the domain
If ğ‘“ requires a large circuit, then this truth-table based approach
can improve over the circuit. For example, if the ZK proof invokes
SHA256 on a small domain ğ‘›-bit input, we need only 2ğ‘› âˆ’ 1 ci-
phertexts. The hand tuned SHA256 circuit, on the other hand, has
a staggering 22573 AND gates [AAL+]. Other ZK protocols, e.g.
[WYKW21], can similarly use truth tables by brute force construct-
ing a one-hot encoding (at the cost of ğ‘‚(2ğ‘›) AND gates). However,
as the size of the input grows, our technique becomes more effi-
cient. For tables with more than 9 input bits, our GC-based one-hot
encoding will improve over other protocols.
2PC. We now consider 2PC applications where both parties have
input and neither party knows any intermediate wire value.
Since our one-hot outer product primitive requires ğ¸ to know
the argument ğ‘, we must reveal ğ‘ to ğ¸ in cleartext. Of course, we
cannot arbitrarily reveal cleartext values to ğ¸: this would not be
secure. Instead, we are careful to only reveal values that have a
mask applied such that the cleartext value remains protected.
We illustrate this idea by example. Let ğ‘ âˆˆ {0, 1}ğ‘› and ğ‘ âˆˆ {0, 1}ğ‘š
be two bitstrings. Moreover, let ğ‘›, ğ‘š be small. (Formally, let ğ‘›, ğ‘š be
at most logarithmic in the overall circuit input size. This restriction
avoids exponential-time computation due to the one-hot technique.)
Suppose the parties hold two sharings(cid:74)ğ‘(cid:75) and(cid:74)ğ‘(cid:75) and wish to
compute the (non-one-hot) outer product(cid:74)ğ‘ âŠ— ğ‘(cid:75). Note that outer
The parties compute(cid:74)ğ‘ âŠ• ğ›¼(cid:75) and(cid:74)ğ‘ âŠ• ğ›½(cid:75) inside GC. Now, it is safe
products are useful since they can be leveraged to compute matrix
products, integer products, and more (see Section 7).
First, ğº chooses two uniform masks ğ›¼ âˆˆ {0, 1}ğ‘› and ğ›½ âˆˆ {0, 1}ğ‘š.
to reveal the values ğ‘ âŠ• ğ›¼ and ğ‘ âŠ• ğ›½ to ğ¸ in cleartext. These values
are revealed by ğº sending his color bits to ğ¸3.
From here, the parties use the following straightforward lemma:
Lemma 4.1. Let ğ‘¥ âˆˆ {0, 1}ğ‘›, ğ‘¦ âˆˆ {0, 1}ğ‘š be two bitstrings and let
id : {0, 1}ğ‘› â†’ {0, 1}ğ‘› denote the identity function:
T (id)âŠº Â· (H(ğ‘¥) âŠ— ğ‘¦) = ğ‘¥ âŠ— ğ‘¦
4.3 Applying the One-Hot Encoding
We now give some examples of how the one-hot outer product can
be used. We greatly expand on this topic in Section 7.
3Alternatively and more directly, ğº can define ğ›¼ (resp. ğ›½) to be his color bits of ğ‘ (resp.
ğ‘). This avoids sending small cleartext values to ğ¸ and is similar to the method used
in [ZRE15]. Here, we introduce the idea that ğº can send color bits of a masked value
to ğ¸ because this sending generalizes to non-XOR masks.
Session 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea578Proof.
T (id)âŠº Â· (H(ğ‘¥) âŠ— ğ‘¦)
= T (id)âŠº Â· (H(ğ‘¥) Â· ğ‘¦âŠº)
= (T (id)âŠº Â· H(ğ‘¥)) Â· ğ‘¦âŠº
= id(ğ‘¥) Â· ğ‘¦âŠº
= ğ‘¥ Â· ğ‘¦âŠº
= ğ‘¥ âŠ— ğ‘¦
Definition âŠ—
Associativity
Lemma 3.3
Definition id
Definition âŠ—
â–¡
In particular, the parties compute the following two values:
Finally, the parties compute the following:
T (id)âŠº Â·(cid:74)H(ğ‘ âŠ• ğ›¼) âŠ— ğ‘(cid:75) =(cid:74)(ğ‘ âŠ• ğ›¼) âŠ— ğ‘(cid:75)
T (id)âŠº Â·(cid:74)H(ğ‘ âŠ• ğ›½) âŠ— ğ›¼(cid:75) =(cid:74)(ğ‘ âŠ• ğ›½) âŠ— ğ›¼(cid:75)
(cid:74)(ğ‘ âŠ• ğ›¼) âŠ— ğ‘(cid:75) âŠ•(cid:74)(ğ‘ âŠ• ğ›½) âŠ— ğ›¼(cid:75)âŠº âŠ•(cid:74)ğ›¼ âŠ— ğ›½(cid:75)
=(cid:74)ğ‘ âŠ— ğ‘(cid:75) âŠ•(cid:74)ğ›¼ âŠ— ğ‘(cid:75) âŠ•(cid:74)ğ‘ âŠ— ğ›¼(cid:75)âŠº âŠ•(cid:74)ğ›½ âŠ— ğ›¼(cid:75)âŠº âŠ•(cid:74)ğ›¼ âŠ— ğ›½(cid:75)
=(cid:74)ğ‘ âŠ— ğ‘(cid:75) âŠ•(cid:74)ğ›¼ âŠ— ğ‘(cid:75) âŠ•(cid:74)ğ›¼ âŠ— ğ‘(cid:75) âŠ•(cid:74)ğ›¼ âŠ— ğ›½(cid:75) âŠ•(cid:74)ğ›¼ âŠ— ğ›½(cid:75)
=(cid:74)ğ‘ âŠ— ğ‘(cid:75)
Thus, ğ¸ and ğº can compute the outer product(cid:74)ğ‘ âŠ— ğ‘(cid:75) using only
(ğº knows ğ›¼ âŠ— ğ›½, so he can inject this value as a GC constant.)
two one-hot outer products. In total, ğº sends to ğ¸ 3(ğ‘› + ğ‘š) âˆ’ 4
ciphertexts. This is a significant improvement compared to com-
puting the outer product via AND gates: the AND-gate method
consumes 2ğ‘›ğ‘š ciphertexts.
As an interesting aside, the above technique is a strict general-
ization of the [ZRE15] half-gates technique. Namely, if we consider
length one inputs ğ‘ and ğ‘, the above technique computes Boolean
AND using only two ciphertexts. Moreover, the numbers of per-
party calls to ğ» match the half-gates technique.
While we have shown here only how to compute an outer prod-
uct, our technique improves other functions as well (see Section 7).
We highlight the key ideas common to such constructions:
(1) Apply a mask to an internal circuit value such that it is safe
to reveal the masked value to ğ¸.
(2) Use the revealed value as input to a one-hot outer product.
(3) Apply a function, via truth table, to this outer product matrix.
(4) Use simple algebra to remove the introduced masks and
obtain the desired output sharing. The parties can use the
output in further GC evaluation.
4.4 A Framework for One-Hot Techniques
We found a number of interesting functions that can be efficiently
implemented using the one-hot outer product (see Section 7). We
certainly did not find all such functions. Thus, part of our contribu-
tion is a simple framework for designing new such constructions,
which can then be directly used without building a new garbling
scheme from the ground up.
Section 5 motivates and explains this framework in detail. In
brief, notice our above high-level strategy involves revealing clear-
text values to ğ¸. Our framework provides a simple infrastructure
that prevents insecure leakage by packaging sensitive values into
modules and ensuring these values cannot leave the module.
Our framework is a tool for designing modules that implement
useful functions inside GC. Modules are built from a small set
Figure 2: Left: Reveal gates safely reveal values to ğ¸. At run-
time, ğº samples a mask ğ›¼ from the designer-specified dis-
tribution Dmask. This mask, and the input, are fed into the
designer-specified function C. For security, the output of C
must be indistinguishable from a value sampled from some
output distribution Dout, even in the context of the input
ğ‘ (Requirement 2, Section 5.3). The masked value C(ğ‘, ğ›¼) is
revealed in cleartext to ğ¸ and ğ›¼ is given to ğº. The masked
value C(ğ‘, ğ›¼) and the mask ğ›¼ are output as GC shares.
Right: A module M implements a specific function and en-
capsulates any internal randomness that can emerge from
Reveal gates. M must satisfy Requirement 1 (Section 5.3).
of primitives provided by the framework. These primitives allow
the designer to specify what to compute, how to sample auxiliary
randomness, and what to reveal to ğ¸. Crucially, the module de-
signer will not directly manipulate garbled labels, material, and
other garbling scheme artifacts â€“ all such handling is done through
the frameworkâ€™s primitives. In particular, this means that the mod-
ule designer need not prove her GC instantiation secure: module
security follows from our frameworkâ€™s security theorems.
5 OUR GARBLING FRAMEWORK
In this section we formalize our approach. Typically, GC approaches
consider simple gates, e.g. XOR/AND or ADD/MUL; the resulting
GC framework is simple to prove and use. Ours is more complex.
At the heart of this complexity lies our highly nonstandard one-
hot outer product gate. In particular, the gate is nonstandard because
it requires that ğ¸ know one of its inputs. Thus, to use the gate
effectively, the GC must reveal certain values to ğ¸.
One direction we could take, but which we do not take, would
be to expose one-hot gates to the circuit designer and to allow her
to manage (e.g., via masking) the information release associated
with its efficient use in GC. This would not be ideal, since each new
top level circuit would require a new proof of security.
Instead, we do not allow our one-hot primitive to be used by
top level circuits. Rather, these gates must be packaged into self-
contained modules. Each module can use our primitive to efficiently
implement a specific function. As a module might internally reveal
values to ğ¸, it must satisfy certain simple security properties. Once
these properties are proved, the module may be used by a top level
circuit as if it were a standard gate.
CÎ±â†DmaskaC(a,Î±)ERevealxâ†Dout{a,C(a,Î±)}c={a,x}GMM(a)=f(a)aSession 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea579Input: ğ¸ inputs ğ‘. Parties together input shared bitstrings(cid:74)ğ‘(cid:75) and(cid:74)ğ‘(cid:75) where ğ‘ âˆˆ {0, 1}ğ‘›, ğ‘ âˆˆ {0, 1}ğ‘š.
Output: Parties output a shared matrix(cid:74)H(ğ‘) âŠ— ğ‘(cid:75).
Procedure:
â€¢ Let ğ´ğ‘– represent ğºâ€™s share of each bit ğ‘ğ‘–; hence ğ¸ holds ğ´ğ‘– âŠ• ğ‘ğ‘– Î”.
â€¢ Our first goal is to deliver to ğ¸ 2ğ‘› âˆ’ 1 out of 2ğ‘› pseudorandom seeds where the ğ‘th seed is missing:
â€¢ ğ¸ and ğº consider a full binary tree with 2ğ‘› leaves. Let ğ‘ğ‘–,ğ‘— be the ğ‘—th node on level ğ‘– and let the root reside on level âˆ’1.
â€¢ ğ¸ and ğº label nodes from level 1 down with jointly agreed nonces nonceğ‘–,ğ‘—.
â€¢ ğº labels each node (except the root) with a ğœ…-bit string ğ‘†ğ‘–,ğ‘—:
â€“ ğº labels ğ‘0,0 by letting ğ‘†0,0 â‰œ ğ´0 âŠ• Î” and ğ‘0,1 by letting ğ‘†0,1 â‰œ ğ´0.
â€“ Consider ğ‘ğ‘–,ğ‘— with parent ğ‘ğ‘–âˆ’1,âŒŠ ğ‘—/2âŒ‹. ğº sets ğ‘†ğ‘–,ğ‘— = ğ»(ğ‘†ğ‘–âˆ’1,âŒŠ ğ‘—/2âŒ‹, nonceğ‘–,ğ‘—).
â€¢ For each level ğ‘– > 0, ğº XORs all odd and all even labels:
ğ‘—=0 ğ‘†ğ‘–,2ğ‘—
Even â‰œ 2ğ‘–âˆ’1
Odd â‰œ 2ğ‘–âˆ’1
ğ‘—=0 ğ‘†ğ‘–,2ğ‘—+1
For each level ğ‘– > 0, the parties agree on two nonces nonceğ‘–,even and nonceğ‘–,odd. ğº sends to ğ¸ the following two values:
ğ»(ğ´ğ‘– âŠ• Î”, nonceğ‘–,even) âŠ• Even
ğ»(ğ´ğ‘–, nonceğ‘–,odd) âŠ• Odd
â€¢ ğ¸ reconstructs each label ğ‘†ğ‘–,ğ‘— except the labels along the path to leaf ğ‘:
â€“ ğ¸ labels ğ‘0,1 with ğ´0 if ğ‘0 = 0; otherwise she labels ğ‘0,0 with ğ´0 âŠ• Î” (recall, her share is ğ´0 âŠ• ğ‘0Î”).
â€“ Consider each level ğ‘– > 0. There are two sibling nodes on level ğ‘– that do not have a labeled parent. Consider each of the other
2ğ‘–+1 âˆ’ 2 nodes ğ‘ğ‘–,ğ‘— with parent ğ‘ğ‘–âˆ’1,âŒŠ ğ‘—/2âŒ‹. ğ¸ computes ğ»(ğ‘†ğ‘–âˆ’1,âŒŠ ğ‘—/2âŒ‹, nonceğ‘–,ğ‘—) = ğ‘†ğ‘–,ğ‘—.
â€“ For the other nodes on level ğ‘–, ğ¸ decrypts the XOR sum Even if ğ‘ğ‘– is odd or Odd if ğ‘ğ‘– is even; ğ¸ XORs this value with her 2ğ‘– âˆ’ 1
even (resp. odd) labels and hence extracts the remaining even (resp. odd) label.
â€¢ ğº now holds 2ğ‘› strings ğ‘†ğ‘›âˆ’1,ğ‘—; ğ¸ also holds each string except ğ‘†ğ‘›âˆ’1,ğ‘. Rename these leaf strings ğ¿ğ‘– â‰œ ğ‘†ğ‘›âˆ’1,ğ‘–.
â€¢ For each bit ğ‘ ğ‘— of ğ‘:
â€“ Let ğµ ğ‘— be ğºâ€™s share of(cid:74)ğ‘ ğ‘—(cid:75). Hence, ğ¸ holds ğµ ğ‘— âŠ• ğ‘ ğ‘— Î”.
(cid:16)
(cid:17) âŠ• ğµ ğ‘—
(cid:17) âŠ•(cid:16)(cid:16)
(cid:17) âŠ• ğµ ğ‘—
(cid:17) âŠ•(cid:0)ğµ ğ‘— âŠ• ğ‘ ğ‘— Î”(cid:1) = ğ‘‹ğ‘,ğ‘— âŠ• ğ‘ ğ‘— Î”
â€“ ğ¸ and ğº agree on 2ğ‘› fresh nonces nonceğ‘–.
â€“ For each leaf ğ‘–, ğº sets ğ‘‹ğ‘–,ğ‘— â‰œ ğ»(ğ¿ğ‘–, nonceğ‘–). ğº sends to ğ¸:
â€“ For each leaf ğ‘– â‰  ğ‘, ğ¸ computes ğ‘‹ğ‘–,ğ‘— = ğ»(ğ¿ğ‘–, nonceğ‘–). ğ¸ then computes:
(cid:16)
ğ‘‹ğ‘–,ğ‘—
ğ‘‹ğ‘–,ğ‘—
ğ‘–
â€¢ Thus, for each column ğ‘— of ğ‘‹, ğ¸ and ğº hold 2ğ‘› values equal everywhere (i.e., each is a garbled share of zero) except at index ğ‘,
â€¢ ğº outputs his matrix share ğ‘‹; ğ¸ outputs her matrix share ğ‘‹ âŠ• (H(ğ‘) âŠ— ğ‘)Î”
where the parties hold an XOR share of ğ‘ ğ‘— Î”: the computation outputs a shared one-hot outer product.
ğ‘–â‰ ğ‘
ğ‘‹ğ‘–,ğ‘—