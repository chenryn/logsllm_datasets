title:On the security of TLS renegotiation
author:Florian Giesen and
Florian Kohlar and
Douglas Stebila
On the Security of TLS Renegotiation
Florian Giesen
Horst Görtz Institut
Germany
Florian Kohlar
Horst Görtz Institut
Germany
Ruhr-Universität Bochum,
Ruhr-Universität Bochum,
ﬂPI:EMAIL
ﬂPI:EMAIL
Douglas Stebila
Queensland University of
Technology
Brisbane, Australia
PI:EMAIL
ABSTRACT
The Transport Layer Security (TLS) protocol is the most
widely used security protocol on the Internet. It supports
negotiation of a wide variety of cryptographic primitives
through diﬀerent cipher suites, various modes of client au-
thentication, and additional features such as renegotiation.
Despite its widespread use, only recently has the full TLS
protocol been proven secure, and only the core cryptographic
protocol with no additional features. These additional fea-
tures have been the cause of several practical attacks on TLS.
In 2009, Ray and Dispensa demonstrated how TLS renego-
tiation allows an attacker to splice together its own session
with that of a victim, resulting in a man-in-the-middle attack
on TLS-reliant applications such as HTTP. TLS was subse-
quently patched with two defence mechanisms for protection
against this attack.
We present the ﬁrst formal treatment of renegotiation in
secure channel establishment protocols. We add optional
renegotiation to the authenticated and conﬁdential channel
establishment model of Jager et al., an adaptation of the
Bellare–Rogaway authenticated key exchange model. We
describe the attack of Ray and Dispensa on TLS within our
model. We show generically that the proposed ﬁxes for TLS
oﬀer good protection against renegotiation attacks, and give
a simple new countermeasure that provides renegotiation
security for TLS even in the face of stronger adversaries.
Categories and Subject Descriptors
C.2.0 [Computer–Communication Networks]: General
—security and protection
Keywords
Transport Layer Security (TLS); renegotiation; security
models; key exchange
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ... $15.00.
http://dx.doi.org/10.1145/2508859.2516694.
1.
INTRODUCTION
The Transport Layer Security (TLS) protocol, the suc-
cessor of the Secure Sockets Layer (SSL) protocol, provides
secure channel establishment on the Internet. It is commonly
used to protect information sent via the Hypertext Transfer
Protocol (HTTP) on the web, and many other application
layer protocols such as email and ﬁle transfer. TLS consists
of a handshake protocol, used to agree on security parame-
ters, establish a secret key, and authenticate the parties; and
a record layer protocol, used to send encrypted data.
Despite the importance of TLS, progress on formally mod-
elling the security of TLS has been slow. A technicality of
TLS prevents it from being proven secure in standard authen-
ticated key exchange (AKE) models: in AKE, the session key
must be indistinguishable from a random key of the same
length. However, the ﬁnal handshake message of the TLS
protocol is encrypted under the session key, so an adversary
can distinguish the session key from a random key by trying
to verify the ﬁnal handshake message. Some analyses [17,
22] have shown that a truncated form of the TLS handshake
is AKE-secure. Others [12] deal with a substantially weaker
security requirement, namely unauthenticated key agreement.
Krawczyk [19] analyzed a variant of the TLS record layer.
Only very recently have analyses of unmodiﬁed TLS func-
tionality appeared. Paterson et al. [23] showed that TLS’s
MAC-then-encode-then-encrypt record layer when used with
CBC encryption (with certain length restrictions) satisﬁes
length-hiding authenticated encryption (LHAE). Jager et al.
[16] gave the ﬁrst full proof of the security of (one ciphersuite
of) unmodiﬁed TLS in a strong security model. Jager et al.
introduced a variant of the Bellare–Rogaway authenticated
key exchange model, called authenticated and conﬁdential
channel establishment (ACCE). They proved that the TLS
1.2 protocol using the TLS_DHE_DSS_WITH_3DES_EDE_CBC_
SHA ciphersuite (which we shorten to TLS_DHE_DSS_) is a
secure ACCE protocol, under standard assumptions on the
cryptographic components. Ciphersuites based on RSA key
transport and static Diﬃe–Hellman have since been shown
ACCE-secure by both Kohlar et al. [18] and Krawczyk et al.
[20]. (An alternative modular approach to proving the full
security of TLS was given by Brzuska et al. [5].)
But TLS is not just a basic secure channel:
it consists
of hundreds of variants with many optional complex func-
tionalities. Alert messages report various error conditions.
Previous sessions can be resumed with a shortened handshake.
As of August 2013, over 300 ciphersuites—combinations of
cryptographic primitives—have been standardized. Client
authentication is optional, and can be certiﬁcate-based or
387password-based. Various additional options can be speciﬁed
via extensions and optional ﬁelds. Record layer communica-
tion can be compressed. And most importantly for this paper,
after a TLS handshake has been completed and transmission
on the record layer has started, parties can renegotiate the
handshake. There have been many attacks on TLS over the
years, such Bleichenbacher’s attack [4] and others involving
padding, and Ray and Dispensa’s renegotiation attack [24],
all of which exploit ﬂaws outside the core cryptographic
primitives of TLS.
In this paper, we focus on renegotiation, which allows two
parties to either (a) obtain a fresh session key, (b) change
cryptographic parameters, or (c) change authentication cre-
dentials. For example, if a client needs to authenticate using
a client certiﬁcate but wishes to not reveal her identity over a
public channel, she could ﬁrst authenticate anonymously (or
with pseudonymous credentials), then renegotiate using her
real certiﬁcate; since the renegotiation messages are trans-
mitted within the existing record layer, the transmission of
her certiﬁcate is encrypted, and thus she obtains privacy for
her identity. We will examine TLS renegotiation in detail,
especially in light of previously identiﬁed practical attacks
related to TLS renegotiation.
Despite the utility of renegotiation in real-world protocols—
beyond TLS, renegotiation, rekeying, or reauthentication
is also used in the Secure Shell (SSH) protocol, Internet
Key Exchange version 2, the Tor anonymity protocol, and
others—there has been almost no research in the literature
on the security of protocols involving renegotiation, with the
exception of a brief note on the TLS renegotiation attack
by Farrell [10] and the recent thesis of Gelashvili [13], which
uses the Scyther tool to automatically identify the TLS
renegotiation attack. Bhargavan et al. [2] implement TLS
supporting a variety of ciphersuites and deﬁne an application
programming interface for TLS which diﬀerentiates between
renegotiated phases; using typechecking, the implementation
is shown secure according to a formal speciﬁcation, albeit
with a restricted adversary who cannot corrupt session keys.
1.1 The TLS Renegotiation Issue
All versions of TLS [7, 8, 9], and SSL v3 [11] before it,
support optional renegotiation. After the initial handshake
is completed and secure communication begins in the record
layer, either party can request renegotiation. The client can
request renegotiation by sending a new ClientHello message
in the current record layer (i.e., encrypted under the current
session key); the server can request renegotiation by sending
a HelloRequest message in the record layer, which triggers
the client to send a new ClientHello message.
In November 2009, Ray and Dispensa [24] described a man-
in-the-middle attack that exploits how certain TLS-reliant
applications—such as HTTP over TLS [25]—process data
across renegotiations. The attack is shown in Figure 1. The
attacker Eve observes Alice attempting to establish a TLS
session with Bob. Eve delays Alice’s initial ClientHello
and instead establishes her own TLS session with Bob and
transmits a message m0 over that record layer. Then Eve
passes Alice’s initial ClientHello to Bob over the Eve–Bob
record layer. Bob views this as a valid renegotiation and
responds accordingly; Eve relays the handshake messages
between Alice and Bob, who eventually establish a new record
layer to which Eve has no access. Alice then transmits a
message m1 over the Alice–Bob record layer.
Alice
Eve
handshakeAB
Bob
Bob
(TLS server)
(application)
d
e
l
a
y
e
d
b
y
E
v
e
handshakeEB
record layerEB
m0
m0
record layerAB
m1
m1
m0(cid:107)m1
Figure 1: Ray and Dispensa’s man-in-the-middle
renegotiation attack on TLS-reliant applications
This is not strictly speaking an attack on TLS but on
how some applications process TLS-protected data. It re-
sults from some applications, including HTTPS [24] and
SMTPS [28], concatenating m0 and m1 and treating them
as coming from the same party in the same context. For
example, if Eve sends the HTTP request m0 and Alice sends
the HTTP request m1, where
m0 = “GET /orderPizza?deliverTo=123-Fake-St ←(cid:45)
X-Ignore-This: ”
m1 = “GET /orderPizza?deliverTo=456-Real-St ←(cid:45)
Cookie: Account=111A2B”
(where ←(cid:45) denotes new-line character), then the concatenated
request (across multiple lines for readability) is
m0(cid:107)m1 = “GET /orderPizza?deliverTo=123-Fake-St ←(cid:45)
X-Ignore-This: GET /orderPizza
?deliverTo=456-Real-St ←(cid:45)
Cookie: Account=111A2B”
The “X-Ignore-This:” preﬁx is an invalid HTTP header,
and since this header, without a new line character, is con-
catenated with the ﬁrst line of Alice’s request, so this line is
ignored. However, the following line, Alice’s account cookie,
is still processed. Eve is able to have the pizza delivered to
herself but paid for by Alice.
It should be noted that Ray and Dispensa’s attack works for
both server-only authentication and mutual authentication
modes of TLS: the use of client certiﬁcates in general does
not prevent the attack [24, 28].
1.2 Countermeasures Added to TLS
The immediate recommendation due to this attack was to
disable renegotiation except in cases where it was essential.
Subsequently, the Internet Engineering Task Force (IETF)
TLS working group developed RFC 5746 [26] to provide
countermeasures to this attack, with the goal of applicability
to SSLv3.0 and TLS versions 1.0–1.2. Two countermeasures
were standardized: the Signalling Ciphersuite Value (SCSV)
and the Renegotiation Information Extension (RIE). In RIE,
the parties include the key conﬁrmation value from the previ-
ous handshake in a ClientHello/ServerHello extension [3],
demonstrating they have the same view of the previous
handshake, or a distinguished null value if not renegotiation.
SCSV is a slight modiﬁcation that is more compatible with
buggy implementations. A diagram showing the message
ﬂow for a generic TLS ciphersuite with SCSV/RIE counter-
measures appears in Figure 2 in Appendix B. According to
388one survey [27], as of July 2013, 82% of TLS-enabled web-
sites support SCSV/RIE, with 9% still supporting insecure
renegotiation and 9% not supporting renegotiation.
1.3 Contributions
Security model for renegotiable channel establishment pro-
tocols. In Section 2, we present a new security model for
renegotiable protocols. Since our goal is to analyze the se-
curity of TLS, we start from the ACCE model, rather than
AKE security models. The primary diﬀerence in our model
for renegotiable protocols is that each party’s oracle (session)
can have multiple phases; each new phase corresponds to
a renegotiation in that session, and can involve the same
or diﬀerent long-term keys.1 This is qualitatively diﬀerent
than simply having multiple sessions, since short-term values
from one phase of a session may be used in the renegotia-
tion for the next phase, whereas multiple sessions only share
long-term values. Each oracle maintains state and encryp-
tion/MAC keys for each phase. Like in TLS, our formalism
allows control messages to be sent on the encrypted channel.
Our extension to the ACCE model also models server-only
authentication in addition to mutual authentication.
The basic goals of a secure renegotiable ACCE protocol are
that (a) the adversary should not be able to read or inject
messages on the encrypted channel, and (b) whenever parties
successfully renegotiate, they should have exactly the same
view of all previous negotiations and all encrypted messages
sent in all previous phases of that session, even when values
from previous phases have been compromised.
Analysis of TLS without and with SCSV/RIE countermea-
sures. Based on the TLS renegotiation attack of Ray and
Dispensa, we see in Section 3 that TLS without counter-
measures is not secure in our model for renegotiation. We
subsequently show in Section 4 that, generically, TLS with
the SCSV/RIE countermeasures of RFC 5746 [26] is a weakly
secure renegotiable ACCE protocol. In this slightly weaker—
but still quite reasonable—model, the adversary is slightly
restricted in the previous secrets she is allowed to reveal.
Our approach for proving the renegotiable security of TLS
with SCSV/RIE countermeasures is modular. We cannot