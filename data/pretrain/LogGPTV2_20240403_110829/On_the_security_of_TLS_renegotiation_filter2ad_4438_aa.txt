# On the Security of TLS Renegotiation

**Authors:**
- Florian Giesen, Horst Görtz Institut, Ruhr-Universität Bochum, Germany
- Florian Kohlar, Horst Görtz Institut, Ruhr-Universität Bochum, Germany
- Douglas Stebila, Queensland University of Technology, Brisbane, Australia

## Abstract
The Transport Layer Security (TLS) protocol is the most widely used security protocol on the Internet. It supports a wide variety of cryptographic primitives through different cipher suites, various modes of client authentication, and additional features such as renegotiation. Despite its widespread use, only recently has the full TLS protocol been proven secure, and only the core cryptographic protocol with no additional features. These additional features have been the cause of several practical attacks on TLS.

In 2009, Ray and Dispensa demonstrated how TLS renegotiation allows an attacker to splice together their own session with that of a victim, resulting in a man-in-the-middle attack on TLS-reliant applications such as HTTP. Subsequently, TLS was patched with two defense mechanisms to protect against this attack.

We present the first formal treatment of renegotiation in secure channel establishment protocols. We add optional renegotiation to the authenticated and confidential channel establishment model of Jager et al., an adaptation of the Bellare–Rogaway authenticated key exchange model. We describe the attack of Ray and Dispensa on TLS within our model. We show generically that the proposed fixes for TLS offer good protection against renegotiation attacks, and we provide a simple new countermeasure that ensures renegotiation security for TLS even in the face of stronger adversaries.

**Categories and Subject Descriptors:**
C.2.0 [Computer–Communication Networks]: General — Security and Protection

**Keywords:**
Transport Layer Security (TLS), renegotiation, security models, key exchange

**Permission to Use:**
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.

**CCS'13, November 4–8, 2013, Berlin, Germany.**
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ... $15.00.
http://dx.doi.org/10.1145/2508859.2516694.

## 1. Introduction
The Transport Layer Security (TLS) protocol, the successor of the Secure Sockets Layer (SSL) protocol, provides secure channel establishment on the Internet. It is commonly used to protect information sent via the Hypertext Transfer Protocol (HTTP) on the web, and many other application layer protocols such as email and file transfer. TLS consists of a handshake protocol, used to agree on security parameters, establish a secret key, and authenticate the parties; and a record layer protocol, used to send encrypted data.

Despite the importance of TLS, progress on formally modeling the security of TLS has been slow. A technicality of TLS prevents it from being proven secure in standard authenticated key exchange (AKE) models: in AKE, the session key must be indistinguishable from a random key of the same length. However, the final handshake message of the TLS protocol is encrypted under the session key, so an adversary can distinguish the session key from a random key by trying to verify the final handshake message. Some analyses [17, 22] have shown that a truncated form of the TLS handshake is AKE-secure. Others [12] deal with a substantially weaker security requirement, namely unauthenticated key agreement. Krawczyk [19] analyzed a variant of the TLS record layer.

Only very recently have analyses of unmodified TLS functionality appeared. Paterson et al. [23] showed that TLS's MAC-then-encode-then-encrypt record layer when used with CBC encryption (with certain length restrictions) satisfies length-hiding authenticated encryption (LHAE). Jager et al. [16] gave the first full proof of the security of (one cipher suite of) unmodified TLS in a strong security model. Jager et al. introduced a variant of the Bellare–Rogaway authenticated key exchange model, called authenticated and confidential channel establishment (ACCE). They proved that the TLS 1.2 protocol using the TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA cipher suite (which we shorten to TLS_DHE_DSS_) is a secure ACCE protocol, under standard assumptions on the cryptographic components. Ciphersuites based on RSA key transport and static Diffie–Hellman have since been shown ACCE-secure by both Kohlar et al. [18] and Krawczyk et al. [20]. (An alternative modular approach to proving the full security of TLS was given by Brzuska et al. [5].)

However, TLS is not just a basic secure channel; it consists of hundreds of variants with many optional complex functionalities. Alert messages report various error conditions. Previous sessions can be resumed with a shortened handshake. As of August 2013, over 300 cipher suites—combinations of cryptographic primitives—have been standardized. Client authentication is optional and can be certificate-based or password-based. Various additional options can be specified via extensions and optional fields. Record layer communication can be compressed. And most importantly for this paper, after a TLS handshake has been completed and transmission on the record layer has started, parties can renegotiate the handshake. There have been many attacks on TLS over the years, such as Bleichenbacher’s attack [4] and others involving padding, and Ray and Dispensa’s renegotiation attack [24], all of which exploit flaws outside the core cryptographic primitives of TLS.

### 1.1 The TLS Renegotiation Issue
All versions of TLS [7, 8, 9], and SSL v3 [11] before it, support optional renegotiation. After the initial handshake is completed and secure communication begins in the record layer, either party can request renegotiation. The client can request renegotiation by sending a new ClientHello message in the current record layer (i.e., encrypted under the current session key); the server can request renegotiation by sending a HelloRequest message in the record layer, which triggers the client to send a new ClientHello message.

In November 2009, Ray and Dispensa [24] described a man-in-the-middle attack that exploits how certain TLS-reliant applications—such as HTTP over TLS [25]—process data across renegotiations. The attack is illustrated in Figure 1. The attacker Eve observes Alice attempting to establish a TLS session with Bob. Eve delays Alice’s initial ClientHello and instead establishes her own TLS session with Bob and transmits a message \( m_0 \) over that record layer. Then Eve passes Alice’s initial ClientHello to Bob over the Eve–Bob record layer. Bob views this as a valid renegotiation and responds accordingly; Eve relays the handshake messages between Alice and Bob, who eventually establish a new record layer to which Eve has no access. Alice then transmits a message \( m_1 \) over the Alice–Bob record layer.

**Figure 1: Ray and Dispensa’s man-in-the-middle renegotiation attack on TLS-reliant applications**

This is not strictly speaking an attack on TLS but on how some applications process TLS-protected data. It results from some applications, including HTTPS [24] and SMTPS [28], concatenating \( m_0 \) and \( m_1 \) and treating them as coming from the same party in the same context. For example, if Eve sends the HTTP request \( m_0 \) and Alice sends the HTTP request \( m_1 \), where:
\[ m_0 = \text{“GET /orderPizza?deliverTo=123-Fake-St} \newline \text{X-Ignore-This: ”} \]
\[ m_1 = \text{“GET /orderPizza?deliverTo=456-Real-St} \newline \text{Cookie: Account=111A2B”} \]
(where \(\newline\) denotes a new-line character), then the concatenated request (across multiple lines for readability) is:
\[ m_0 \parallel m_1 = \text{“GET /orderPizza?deliverTo=123-Fake-St} \newline \text{X-Ignore-This: GET /orderPizza} \newline \text{?deliverTo=456-Real-St} \newline \text{Cookie: Account=111A2B”} \]

The “X-Ignore-This:” prefix is an invalid HTTP header, and since this header, without a new line character, is concatenated with the first line of Alice’s request, this line is ignored. However, the following line, Alice’s account cookie, is still processed. Eve is able to have the pizza delivered to herself but paid for by Alice.

It should be noted that Ray and Dispensa’s attack works for both server-only authentication and mutual authentication modes of TLS: the use of client certificates in general does not prevent the attack [24, 28].

### 1.2 Countermeasures Added to TLS
The immediate recommendation due to this attack was to disable renegotiation except in cases where it was essential. Subsequently, the Internet Engineering Task Force (IETF) TLS working group developed RFC 5746 [26] to provide countermeasures to this attack, with the goal of applicability to SSLv3.0 and TLS versions 1.0–1.2. Two countermeasures were standardized: the Signalling Ciphersuite Value (SCSV) and the Renegotiation Information Extension (RIE). In RIE, the parties include the key confirmation value from the previous handshake in a ClientHello/ServerHello extension [3], demonstrating they have the same view of the previous handshake, or a distinguished null value if not renegotiating. SCSV is a slight modification that is more compatible with buggy implementations. A diagram showing the message flow for a generic TLS cipher suite with SCSV/RIE countermeasures appears in Figure 2 in Appendix B. According to one survey [27], as of July 2013, 82% of TLS-enabled websites support SCSV/RIE, with 9% still supporting insecure renegotiation and 9% not supporting renegotiation.

### 1.3 Contributions
- **Security Model for Renegotiable Channel Establishment Protocols:** In Section 2, we present a new security model for renegotiable protocols. Since our goal is to analyze the security of TLS, we start from the ACCE model, rather than AKE security models. The primary difference in our model for renegotiable protocols is that each party’s oracle (session) can have multiple phases; each new phase corresponds to a renegotiation in that session, and can involve the same or different long-term keys. This is qualitatively different than simply having multiple sessions, since short-term values from one phase of a session may be used in the renegotiation for the next phase, whereas multiple sessions only share long-term values. Each oracle maintains state and encryption/MAC keys for each phase. Like in TLS, our formalism allows control messages to be sent on the encrypted channel. Our extension to the ACCE model also models server-only authentication in addition to mutual authentication.
- **Basic Goals of a Secure Renegotiable ACCE Protocol:** The basic goals of a secure renegotiable ACCE protocol are that (a) the adversary should not be able to read or inject messages on the encrypted channel, and (b) whenever parties successfully renegotiate, they should have exactly the same view of all previous negotiations and all encrypted messages sent in all previous phases of that session, even when values from previous phases have been compromised.
- **Analysis of TLS Without and With SCSV/RIE Countermeasures:** Based on the TLS renegotiation attack of Ray and Dispensa, we see in Section 3 that TLS without countermeasures is not secure in our model for renegotiation. We subsequently show in Section 4 that, generically, TLS with the SCSV/RIE countermeasures of RFC 5746 [26] is a weakly secure renegotiable ACCE protocol. In this slightly weaker—but still quite reasonable—model, the adversary is slightly restricted in the previous secrets she is allowed to reveal. Our approach for proving the renegotiable security of TLS with SCSV/RIE countermeasures is modular. We cannot directly apply the existing proofs for unrenegotiated TLS, so we introduce a new proof technique that leverages the security of the underlying cipher suites and the new countermeasures.