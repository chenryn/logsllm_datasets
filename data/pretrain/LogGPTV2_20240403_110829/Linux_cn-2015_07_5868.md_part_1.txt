---
author: SamarRizvi
category: 软件开发
comments_data: []
count:
  commentnum: 0
  favtimes: 5
  likes: 0
  sharetimes: 0
  viewnum: 13151
date: '2015-07-23 08:00:00'
editorchoice: false
excerpt: 简介 要提供互联网服务，当你在开发代码的时候必须时刻保持安全意识。可能大部分 PHP 脚本都对安全问题都不在意，这很大程度上是因为有大量的无经验程序员在使用这门语言。但是，没有理由让你因为对你的代码的不确定性而导致不一致的安全策略。当你在服务器上放任何涉及到钱的东西时，就有可能会有人尝试破解它。创建一个论坛程序或者任何形式的购物车，被攻击的可能性就上升到了无穷大。
  背景 为了确保你的 web 内容安全，这里有一些常规的安全准则： 别相信表单 攻击表单很简单。通过使用一个简单的 JavaScript 技巧，你可以限制你的表
fromurl: http://www.codeproject.com/Articles/363897/PHP-Security
id: 5868
islctt: true
largepic: /data/attachment/album/201507/23/005118mdn88qq876c6687a.jpg
permalink: /article-5868-1.html
pic: /data/attachment/album/201507/23/005118mdn88qq876c6687a.jpg.thumb.jpg
related: []
reviewer: ''
selector: ''
summary: 简介 要提供互联网服务，当你在开发代码的时候必须时刻保持安全意识。可能大部分 PHP 脚本都对安全问题都不在意，这很大程度上是因为有大量的无经验程序员在使用这门语言。但是，没有理由让你因为对你的代码的不确定性而导致不一致的安全策略。当你在服务器上放任何涉及到钱的东西时，就有可能会有人尝试破解它。创建一个论坛程序或者任何形式的购物车，被攻击的可能性就上升到了无穷大。
  背景 为了确保你的 web 内容安全，这里有一些常规的安全准则： 别相信表单 攻击表单很简单。通过使用一个简单的 JavaScript 技巧，你可以限制你的表
tags:
- PHP
- 安全
thumb: false
title: PHP 安全编程建议
titlepic: false
translator: ictlyh
updated: '2015-07-23 08:00:00'
---
![](/data/attachment/album/201507/23/005118mdn88qq876c6687a.jpg)
### 简介
要提供互联网服务，当你在开发代码的时候必须时刻保持安全意识。可能大部分 PHP 脚本都对安全问题都不在意，这很大程度上是因为有大量的*无经验程序员*在使用这门语言。但是，没有理由让你因为对你的代码的不确定性而导致不一致的安全策略。当你在服务器上放任何涉及到钱的东西时，就有可能会有人尝试破解它。创建一个论坛程序或者任何形式的购物车，被攻击的可能性就上升到了无穷大。
### 背景
为了确保你的 web 内容安全，这里有一些常规的安全准则：
#### 别相信表单
攻击表单很简单。通过使用一个简单的 JavaScript 技巧，你可以限制你的表单只允许在评分域中填写 1 到 5 的数字。如果有人关闭了他们浏览器的 JavaScript 功能或者提交自定义的表单数据，你客户端的验证就失败了。
用户主要通过表单参数和你的脚本交互，因此他们是最大的安全风险。你应该学到什么呢？在 PHP 脚本中，总是要验证 传递给任何 PHP 脚本的数据。在本文中，我们向你演示了如何分析和防范跨站脚本（XSS）攻击，它可能会劫持用户凭据（甚至更严重）。你也会看到如何防止会玷污或毁坏你数据的 MySQL 注入攻击。
#### 别相信用户
假定你网站获取的每一份数据都充满了有害的代码。清理每一部分，即便你相信没有人会尝试攻击你的站点。
#### 关闭全局变量
你可能会有的最大安全漏洞是启用了 register\_globals 配置参数。幸运的是，PHP 4.2 及以后版本默认关闭了这个配置。如果打开了 **register\_globals**，你可以在你的 php.ini 文件中通过改变 register\_globals 变量为 Off 关闭该功能：
```
register_globals = Off 
```
新手程序员觉得注册全局变量很方便，但他们不会意识到这个设置有多么危险。一个启用了全局变量的服务器会自动为全局变量赋任何形式的参数。为了了解它如何工作以及为什么有危险，让我们来看一个例子。
假设你有一个称为 process.php 的脚本，它会向你的数据库插入表单数据。初始的表单像下面这样：
```
```
运行 process.php 的时候，启用了注册全局变量的 PHP 会将该参数赋值到 $username 变量。这会比通过 **$\_POST['username']** 或 **$\_GET['username']** 访问它节省击键次数。不幸的是，这也会给你留下安全问题，因为 PHP 会设置该变量的值为通过 GET 或 POST 的参数发送到脚本的任何值，如果你没有显示地初始化该变量并且你不希望任何人去操作它，这就会有一个大问题。
看下面的脚本，假如 $authorized 变量的值为 true，它会给用户显示通过验证的数据。正常情况下，只有当用户正确通过了这个假想的 authenticated\_user() 函数验证，$authorized 变量的值才会被设置为真。但是如果你启用了 **register\_globals**，任何人都可以发送一个 GET 参数，例如 authorized=1 去覆盖它：
```
```
这个故事的寓意是，你应该从预定义的服务器变量中获取表单数据。所有通过 post 表单传递到你 web 页面的数据都会自动保存到一个称为 **$\_POST** 的大数组中，所有的 GET 数据都保存在 **$\_GET** 大数组中。文件上传信息保存在一个称为 **$\_FILES** 的特殊数据中。另外，还有一个称为 **$\_REQUEST** 的复合变量。
要从一个 POST 方法表单中访问 username 字段，可以使用 **$\_POST['username']**。如果 username 在 URL 中就使用 **$\_GET['username']**。如果你不确定值来自哪里，用 **$\_REQUEST['username']**。
```
```
$\_REQUEST 是 $\_GET、$\_POST、和 $\_COOKIE 数组的结合。如果你有两个或多个值有相同的参数名称，注意 PHP 会使用哪个。默认的顺序是 cookie、POST、然后是 GET。
#### 推荐安全配置选项
这里有几个会影响安全功能的 PHP 配置设置。下面是一些显然应该用于生产服务器的：
* **register\_globals** 设置为 off
* **safe\_mode** 设置为 off
* **error\_reporting** 设置为 off。如果出现错误了，这会向用户浏览器发送可见的错误报告信息。对于生产服务器，使用错误日志代替。开发服务器如果在防火墙后面就可以启用错误日志。（LCTT 译注：此处据原文逻辑和常识，应该是“开发服务器如果在防火墙后面就可以启用错误报告，即 on。”）
* 停用这些函数：system()、exec()、passthru()、shell\_exec()、proc\_open()、和 popen()。
* **open\_basedir** 为 /tmp（以便保存会话信息）目录和 web 根目录，以便脚本不能访问这些选定区域外的文件。
* **expose\_php** 设置为 off。该功能会向 Apache 头添加包含版本号的 PHP 签名。
* **allow\_url\_fopen** 设置为 off。如果你能够注意你代码中访问文件的方式-也就是你验证所有输入参数，这并不严格需要。
* **allow\_url\_include** 设置为 off。对于任何人来说，实在没有明智的理由会想要访问通过 HTTP 包含的文件。
一般来说，如果你发现想要使用这些功能的代码，你就不应该相信它。尤其要小心会使用类似 system() 函数的代码-它几乎肯定有缺陷。
启用了这些设置后，让我们来看看一些特定的攻击以及能帮助你保护你服务器的方法。
### SQL 注入攻击
由于 PHP 传递到 MySQL 数据库的查询语句是用强大的 SQL 编程语言编写的，就有了某些人通过在 web 查询参数中使用 MySQL 语句尝试 SQL 注入攻击的风险。通过在参数中插入有害的 SQL 代码片段，攻击者会尝试进入（或破坏）你的服务器。
假如说你有一个最终会放入变量 $product 的表单参数，你使用了类似下面的 SQL 语句：
```
$sql = "select * from pinfo where product = '$product'";
```
如果参数是直接从表单中获得的，应该使用 PHP 自带的数据库特定转义函数，类似：
```
$sql = 'Select * from pinfo where product = '"' 
       mysql_real_escape_string($product) . '"';
```
如果不这样做的话，有人也许会把下面的代码段放到表单参数中：
```
39'; DROP pinfo; SELECT 'FOO 
```
那么 $sql 的结果就是：