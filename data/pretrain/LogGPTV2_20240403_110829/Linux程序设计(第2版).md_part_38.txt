int init_color(short color_number， short red.short green, short blue):
加入iaVa编程群：524621833
---
## Page 199
第6章curses函数库
COLORS
and 64 DOLOR_PAIRS available
Boldcolreir
图6-7
这个函数把-个可用色彩（0到COLORS范围之间）的深度细调为一个新的值，新值的范围
是从0到1000。这有点象为PC个人电脑的屏幕定义其VGA色板的颜色值。
6.14逻辑屏幕和显示平面
在编写比较高级的curses程序时，我们可以先创建一个逻辑屏幕，然后再把它的全部或部分
内容输出到物理屏幕上，这个办法简便易行，效果也不错。如果还能有一个尺寸大于物理屏幕
的逻辑屏幕，再根据需要一次只显示逻辑屏幕的某个部分，其效果往往会更好。
但就我们目前已经学过的curses函数而言，要想实现这种构思难度极大，因为任何窗口的尺
寸都不能超越物理屏幕。但curses允许逻辑屏幕大于正常窗口，并且专门为尺寸大于正常窗口的
逻辑屏幕上的信息处理准备了一种特殊的数据结构-—显示平面（pad）。
创建显示平面和创建正常窗口在原理上是相同的：
#include 
WINDOw *newpad(int number_of_lines, int number_of_colunns);
请注意，这个函数的返回值是一个指向WINDOW结构的指针，这一点也类似于newwin函数。
显示平面也要用delwin来剔除，就象正常窗口一样。
显示平面有自己专用的剧新例程。显示平面不受屏幕坐标位置的限制，所以在剧新时必须
指定希望把显示平而的个区间输出到屏幕上，还必须设定它在屏幕上占据的坐标位置。请看
对显示平面进行刷新的prefresh函数的定义：
#include ccurses.h>
int prefresh(wINDow *pad_ptr, int pad_row, int pad_column
加入jaVa编程群：524621833
---
## Page 200
182
Linux程序设计
int screen_row_nin, int screen_co_min,
int screen_row_nax. int screen_col_max);
这个函数的作用是把显示平面从（pad_row.pad_column）开始的区间写到屏幕上，屏幕显示区
被定义为坐标（screen_row_min，screen_col_min）和（screen_row_max，screen_col_max)之间的那-
块区域。
curses还提供了·-个pnoutrefresh函数，它的作用类似于wnoutrefresh，都是为了更有效率地
刷新屏幕。
我们通过下面这个pad.c程序具体解释一下这些函数的使用方法。
动手试试：显示平面的使用方法
1）我们在程序的开始先对显示平面的pad结构进行初始化，然后创建一个显示平面，创建函
数返回一个指向该显示平面的指针。我们用字符填满这个pad结构（它比终端的显示区长宽各多
出50个字符）。
4include 
ainclude 
int main(1
1a1dped, MOGNIR
int x,Y:
int pad_lines:
char disp_char:
int pad_cols:
pad_lines = LINES + 50;
initscr (}:
pad_ptr * newpad(pad_lines, pad_cols);
pad_co1s =COLS + 50:
disp_char ='a';
for （x=0:x
include 
#include 
#include 
include 
#define MAX_STRING 8C
/*Longest allowed database entry */
/* Longest allowed response
define MAX_ENTRY 1024
#define MESSAGE_LINE 6
define ERROR_LINE
/·Line to uce for errors
/* Misc. messages on this line
#define Q_LINE
/Line for questicns
efine PROMPT_LINE 18
/·Line for prorpting on
2)接下来，定义全局变量。变量current_cd用来保存我们]正在处理的当前CD唱盘的标题名
称。我们把它的第一个字符初始化为一个空字符null，表示用户还没有挑选好CD唱盘。严格地
说，“0”并不是必需的，但它能够保证这个变量确实被初始化了，而这总是一件好事情。变量
current_cat用来记录当前CD唱盘的分类编号。
static char current_cd[MAx_STRING]=*\o*;
static char current_cat [NAX_STRING] :
3）下面是各种文件名的声明。为了集中大家的注意力，我们在这个版本里使用的文件都是
固定的，比如临时文件的文件名。如果有两个用户同时在同一个子目录里运行这个程序，就会
出问题。
要想指定数据库文件的名字，当然还有更好的办法。我们可以把它用做程序的参数，
还可以通过环境变量传递到程序中来。临时文件名的生成办法还可以再做改进，比方说，
我们可以用POSIX技术规范提供的tmpnam函数来生成一个独一无二的临时文件名。我
们将在今后的版本里逐步解决这些问题：
const char *title_file =*title,cdb';
const char *cracks_file'tracks.cdb':
4）接下来，我们给出所有函数的预定义。
void clear_all_screen(veid) ;
int get_confirm(void);
void get_return(void);
int getchoice(char *greet.char *choices(l);
void draw_menu(char *options[].int highlight.
void insert_title(char *cdtitle}:
int atart_row, int statt_col);
void count_eds(void]:
void add_record(void);
void find_cd(void):
void list_tracks(void);
void update_cd(void) :
void remove_cd(void) ;
5)在看到它们的实现之前，我们需要一些菜单结构（实际上是一个菜单选项的数组），后面
的工作就是分析这些菜单选项是如何实现的。第一个字符是该选项被选中时将要返回的字符，
文字将被显示在屏幕上。用户挑选好一张CD唱盘后，程序将显示第二个菜单。
加入jaVa编程群：524621833
---
## Page 203
第6章curses函数库
185
char *nain_menu[]=
"find cD',
add new CD*.
count CDs and tracks in the catalog*,
"quit",
} :
V,
char *extended_menu[}α
find co',
add new CD*,
*count CDs and tracks in tbe catalog*.
list tracks on current CD*.
"update track inforaation*.
'remove current cD*,
quit*,
} :
0,
以上全都是初始化方面的工作。下面是程序中的函数，我们先把这些函数的内在联系总结
一下，它们一共有15个见图6-9。这些函数分成三大部分：
·绘制菜单。
·把CD唱盘资料添加到数据库里。
·检索和显示CD数据。
GET_RETL
ET_CONAR
CEA
图6-9
动手试试：CD唱盘管理软件的main函数
main函数允许用户从菜单里对操作进行选择，直到选中“quit”退出为止。下面是它的程序
清单：
int sain()
int choice:
initscr ();
1op
choice *getchoice(*options:*
current_cd[o] ?
加入jaVa编程群：524621833
---
## Page 204
186
Linux程序设计
switch (choice)(
case 'q':
break;
case 'a' :
add_recordi) ;
break;
case 'c':
break:
count_cds () ;
case'f':
find_cd() :
case *1':
break:
list_tracks() ;
break;
case 'r':
remove_cd() ;
break;
case
u'：
break;
update_cd() ;
）while (choice != *q*1;
cxit (EXIT_SUCCESS):
endwin():
下面开始对三个部分的函数进行分析。我们先来看看这个程序里与用户操作界面有关的三
个函数。
动手试试：莱单