USENIX Association
020040060080010001200Time (s)Ppriv[0] Ppriv[1] Ppriv[2] Ppriv[3] Ppriv[4] Ppriv[5] Ppriv[6] Ppriv[7] 0100200300400500600Time (s)Ppriv[0] Ppriv[1] Ppriv[2] Ppriv[3] 050100150200250300Time (s)Ppriv[0] Ppriv[1] Ppriv[2] Ppriv[3] 020406080100120140Time (s)Ppriv[0] Ppriv[1] Ppriv[2] 01020304050607080Time (s)Ppriv[0] Ppriv[1] 0102030405060Time (s)Ppriv[0] Ppriv[1] M =10056.5%Table 2: End-to-end attack performance.
Round
1
2
3
4
1 Block
Packets used
292
329
326
299
Time(s)
43.56
40.78
39.21
33.58
2 Blocks
Packets used
148
177
154
154
Time(s)
21.29
20.04
18.99
16.95
Figure 10: I/O performance degradation evaluated using SSH
response time (network latency excluded).
5 A Path Towards I/O Security in SEV
The root cause of the problem is the incompatibility between
AMD-V’s I/O virtualization with SEV’s memory encryption
scheme. Speciﬁcally, the primary reason of the attacks de-
scribed in Section 3 is that existing IOMMU hardware only
supports memory encryption with ASID = 0 and the operated
memory is encrypted with the hypervisor’s memory encryp-
tion key. Therefore, every I/O operation from the guest VM
must go through a shared memory page with the hypervisor.
To address this limitation, IOMMU must allow DMA oper-
ations to be performed under the ASIDs of other contexts.
Meanwhile, it must prevent the privileged software from abus-
ing such IOMMU operations. This design, however, will be
very challenging to implement in practice. According to our
discussion with AMD researchers, future releases of SEV
CPUs are unlikely to address this issue. Therefore, alternative
solutions must be identiﬁed.
In addition to this fundamental issue, the decryption oracle
is also enabled by two other vulnerabilities of SEV: (1) no
integrity protection of the encrypted memory, and (2) knowl-
edge of the tweak function T (). AMD researchers suggested
that future SEV CPUs will disable the encryption oracle by
providing memory integrity and altering the implementation
of the tweak function T (). While authenticated memory en-
cryption disables all known attacks against SEV, details of its
implementation are yet to be disclosed. We discuss some of
Figure 11: Merkle Tree (a) and Bonsai Merkle Tree used in
conjunction with split counter mode encryption (b).
the potential considerations in Section 5.1. Future versions of
the tweak function will be implemented as T (k,a), where a
is the physical address and k is a random input that changes
after every system reboot. We leave the investigation of these
vulnerabilities to future work when the technical details are
published. In Section 5.2, we present a temporary software
ﬁx that works on existing AMD processors (Section 5.2).
It is worth noting that AMD researchers suggested that
SEV-ES masks the page offset during page fault. However,
we could not ﬁnd relevant documentation or validate the claim
on our testbed. Nevertheless, our analysis (see Section 3.3.2)
suggests that the attack is still effective when the page offset
information is unavailable. Speciﬁcally, we empirically evalu-
ated the attack method that does not rely on page offsets by
repeating the experiments in Section 4.1: the mean precision
is 0.900, the mean recall is 0.730 and the mean F1 score is
0.800, which is only slightly lower.
5.1 Authenticated Encryption
Authenticated encryption must be adopted to prevent replay
attacks and replacement attacks of the encrypted ciphertext.
Merkle Tree (MT) [14] has been proposed for detecting re-
play and replacement attacks for protecting memory integrity.
MT can be built and maintained over any region of memory,
and hence it can be used to protect the entire memory or only
memory allocated to a VM, or any portion of it. There are two
types of MT that can be used, depending on the encryption
mode. For direct encryption mode, the MT covers data. For
counter-mode encryption, it was shown that replay was only
possible if the attacker replays data, its hash, and its counter
simultaneously. Hence, protecting counter freshness is suf-
ﬁcient to protect against replay [26]. MT over counters is
referred to as Bonsai Merkle Tree (BMT), a variant of which
was chosen for implementation in Intel SGX MEE [18].
A fundamental trade off exits between the choice of en-
cryption mode and the overheads of MT. When 128-bit hash
is used for MT, MT (and hashes) over data incur memory
capacity overhead of 33% (i.e. data-to-MT nodes ratio of
2:1), as illustrated in Figure 11. On the other hand, BMT
incurs an overhead of 20% for hashes, plus 0.4% for BMT
nodes. Hashes are needed for both encryption modes to pro-
USENIX Association
28th USENIX Security Symposium    1267
OriginalBp  PersistentGuess Every time0.02.55.07.510.012.515.017.5MillisecondSSH Response TimeDataMTRoot on chipMT allocated in Mem67%33%DataHash78.6%20%CtrBMT1%0.4%Root on chip(a)(b)replay attempts will be detected. Selective integrity protec-
tion may obviate the need for full MT/BMT for attacks that
occur within the vulnerable window, but leaves the memory
integrity unprotected at other time.
5.2 A Temporary Software Solution
In this section, we present a software solution that can tem-
porarily solve the I/O insecurity issues discussed in this paper.
The key idea is to make sure the hypervisor never observe any
unencrypted I/O data to/from the SEV-enabled VM. This can
be achieved using SEV’s platform management APIs [3] and
the transport encryption key of the VM Ktek.
Ktek is a shared Difﬁe-Hellman (DH) key between the VM
owner and the SEV ﬁrmware. Particularly, to launch an SEV-
enabled VM on an SEV platform, the owner of the VM ﬁrst re-
quests the Difﬁe-Hellman (DH) certiﬁcate from the platform,
which contains the platform’s DH public key. The correspond-
ing private key is kept inside the SEV ﬁrmware, which cannot
be extracted by the system administrator or the hypervisor.
The VM owner then sends her DH public key to SEV platform,
so that she establishes a shared transport encryption key Ktek
with the SEV ﬁrmware. Ktek is only known by the VM owner
and the SEV ﬁrmware, but not known to the VM itself or hy-
pervisor. SEND_UPDATE_DATA and RECEIVE_UPDATE_DATA
are two commands (among many others) implemented by
SEV to assist the hypervisor to launch and manage SEV-
enabled VMs [3]. After the VM is launched, the hypervisor
may use SEV’s SEND_UPDATE_DATA command to atomically
decrypt a piece of memory with Kvek and re-encrypt with
Ktek or use RECEIVE_UPDATE_DATA command to decrypt the
memory with Ktek and re-encrypt with Kvek.
Our proposed solution retroﬁts these APIs and Ktek to pro-
tect I/O operations. Particularly, the guest VM kernel and the
QEMU can be modiﬁed so that the guest VM never copies
data between the encrypted memory and the unencrypted
memory. Instead, to perform any I/O operation to the SEV-
enabled VM, the hypervisor issues the SEND_UPDATE_DATA
and RECEIVE_UPDATE_DATA commands to atomically de-
crypt and re-encrypt data using the two keys Kvek and Ktek. As
both keys are protected inside the SEV ﬁrmware, the hypervi-
sor is not able to learn the plaintext during the I/O operations.
The SEV ﬁrmware serves as a trusted relay of the I/O paths.
However, this solution is only a temporary ﬁx of the issue.
This is because the I/O trafﬁc is encrypted with Ktek, which
is only known to the owner of the VM. Therefore, all I/O
operations, including network I/O, disk I/O, and display I/O
must be forwarded to a trusted server that is controlled by the
VM owner (as shown in Figure 13). Acting as an I/O proxy,
the trusted server may limit the application scenarios of SEV
and greatly reduce the I/O performance.
Figure 12: Counter mode encryption with split counters using
Galois Counter Mode authentication.
tect against non-replay tampering of memory data. In addition,
counter-mode encryption requires additional storage for coun-
ters, which depends on the type of counters. 64-bit monolithic
counters take up 9% overheads, but split-counters [37] take up
only 1%. Taken together, protection against replay incurs 13%
memory capacity with direct encryption but only 1.4% with
counter mode encryption (Figure 11). For a 1 TB memory,
the difference amounts to a substantial 116 GB.
Counter mode encryption is illustrated in Figure 12. Coun-
ters are cached on chip, either in regular caches, or in a special
“counter cach”. With split counters, each page (4KB) of data
has its own major counter, and each block (64B) in a page has
its own minor counter. When there is a last level cache (LLC)
miss, the counter values (major and minor) are concatenated
with the page ID and block address of the page (i.e. page off-
set of the block) to produce a spatially and temporally unique
initial vector (IV) [37]. The IV is then encrypted to produce
a pad, which will be XOR-ed with ciphertext of data fetched
from memory to yield data plaintext. With Galois Counter
Mode, the hash of data is obtained a few clock cycles later.
Counter mode encryption is more secure than direct mode en-
cryption due to spatial and temporal uniqueness of ciphertexts
even for a single plaintext value. Furthermore, as illustrated
in the ﬁgure, decryption latency is largely overlapped with
LLC miss latency; the only exposed latency is 1-cycle XOR
of pad and data ciphertext. In contrast, direct memory mode
fully exposes decryption latency in the critical path of mem-
ory fetch. Therefore, in terms of security protection against
replay, memory capacity costs, and performance, AMD SEV
can beneﬁt from counter mode encryption and BMT.
A MT/BMT protects the memory from replay or tampering
at all time. It is also possible to selectively protect memory
region integrity only at times in which they are “expected”
to be vulnerable. For example, the time window in which
IOMMU buffer is vulnerable is between the time it is writ-
ten by the DMA until it is read/consumed by the VM. One
could take a hash of the memory region at DMA write and
verify it when the VM reads the region. Any tampering or
1268    28th USENIX Security Symposium
USENIX Association
AES-CTRPageIDPageOffsetMajorCounterMinorCounterPaddingIVKeyFetched Block(from off-chip Mem)Ciphertext(to off-chip Mem)PadCounter CacheLast Level Cache (LLC)GF MultHashXORXORthe encrypted memory is not protected. As such, malicious
hypervisors may alter the ciphertext of the encrypted memory
without triggering errors in the decryption process of the guest
VMs. Prior studies have demonstrated a variety of approaches
to exploit such unauthenticated memory encryption:
• Chosen plaintext attacks. Du et al. discovered that SME
uses Electronic Codebook (ECB) mode of operation in
its memory encryption [12], which implies that the same
plaintext always leads to the same ciphertext after encryp-
tion. As the only security measure is a physical address
based tweak function XORed with the plaintext before en-
cryption, knowledge of the tweak function will enable the
adversary to deduce the relationship between the plaintext
of two memory blocks (i.e., of 16 bytes) if their ciphertext
are the same. Du et al. exploit this weakness by construct-
ing a chosen plaintext attack (via an HTTP server installed
on the guest VM) and then replace the ciphertext of an
sshd program with the ciphertext of instructions speciﬁed
by the adversary (after applying the tweak functions).
• Fault injection attacks. Buhren et al. studied fault injec-
tion attacks on a simulated SME implementation [9]. Their
work considers a different threat model, which assumes
that the adversary is able to conduct physical DMA at-
tacks [6] and also run an unprivileged process on the target
OS. The unprivileged process performs Prime+Probe side-
channel attacks to trace the execution of the SME protected
application and, at the proper moment of a cryptographic
operation, utilizes DMA attacks to inject memory faults to
infer secret keys (or key components). We believe Buhren
et al.’s attack against SME can be migrated to SEV as
well, which is even easier to conduct as the hypervisor can
be assumed to be malicious.
• Page table manipulation. Remapping guest pages in
the nested paging structures to replay previously cap-
tured memory pages was ﬁrst studied by Hetzelt and
Buhren [17]. A similar idea was later demonstrated by
Morbitzer et al. in SEVered, an attack that by manipulat-
ing the nested page table alters the virtual memory of the
guest VMs to breach the conﬁdentiality of the memory en-
cryption [25]. More speciﬁcally, SEVered is carried out in
the following steps: First, the malicious hypervisor sends
network requests to the guest’s network-facing application,
e.g., an HTTP server, which allows the attacker to down-
load ﬁles larger than one memory page. Second, using a
coarse-grained page-level side channel, the attacker deter-
mines which of the encrypted guest VM’s memory pages
are used to store the response data. Third, after locating
these pages, the malicious hypervisor changes the page
mappings in the nested page table so that these virtual
pages used by the guest are mapped to different physical
pages. As a result, memory content of these pages can be
leaked through the responses of the network applications.
The same authors further extend SEVered to perform more
Figure 13: An illustration of the temporary software solution.
6 Related Work
6.1 Existing Security Studies on SEV
The security issues of AMD’s SEV have been placed under
the spotlight since its debut. Demonstrated security attacks
mainly targets SEV’s unencrypted VMCB [17] and SME’s
unauthenticated memory encryption [9, 12, 17, 25]. The for-
mer issue has been ﬁxed using SEV-ES [19] and the latter
could be addressed with integrity protection of the encrypted
memory. An implementation bug in the ﬁrmware of AMD
secure processors have also been reported [11]. But since the
issue was not related to a design failure, we leave it as out of
scope of the paper. We detail these related work as follows:
Unencrypted VMCB. Hetzelt and Buhren analyzed the se-
curity of SEV from the perspective of unencrypted virtual
machine control block (VMCB) [17]. VMCB is a data struc-
ture in memory shared by the hypervisor and the guest VM,
which stores the values of guest’s general purpose registers
and control bits for handling virtual interrupts. At the time
of VMExit, a malicious hypervisor may learn the machine
state of the guest VM by reading register values stored in the
VMCB and subsequently alter their values before VMRun to
control the registers of the guest VM. Hetzelt and Buhren [17]
exploit unencrypted VMCB using code gadgets in the guest
memory (similar to return-oriented programming (ROP) [29])
to arbitrarily read and write encrypted memory in the guest
VM. The security issue caused by unencrypted VMCB, how-
ever, has been mitigated by SEV-ES [19], which adds another
indirection layer during VMExit that allows the guest VM to
be notiﬁed before Non-Automatic Exits (NAE)—exits requir-
ing hypervisor emulation—and prepares a new data structure
called Guest Hypervisor Communication Block—a subset of
VMCB—to communicate with the hypervisor. The machine
states stored in the VMCB are instead encrypted with authen-
tication, such that they are inaccessible from the hypervisor.
Unauthenticated memory encryption. Because SME does
not use authenticated encryption schemes, the integrity of
USENIX Association
28th USENIX Security Symposium    1269
realistic attacks [24], by extracting secret keys in real-
world protocols and applications such as TLS, SSH, full
disk encryption (FDE). Their attack makes use of the same
side channels to identify the set of memory pages that
are likely to contain those secrets and scans those pages
(roughly 100 pages) until the secrets are found. Both these
works only present decryption oracles but not encryption
oracles.
While the security issues of SEV’s I/O operations are or-
thogonal to the problems of unauthenticated memory encryp-
tion, the decryption oracle presented in this paper does rely
on the lack of integrity protection for the ciphertext blocks.