分可能像这个样子： 
www.AdvancedLinuxProgramming.com 
22
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
代码列表 2.4 （client.c）一个网络客户程序的片断 
#include  
#include  
int main () 
{ 
  char* server_name = getenv (“SERVER_NAME”); 
  if (server_name == NULL) 
    /* 环境变量 SERVER_NAME 不存在。使用默认值。*/ 
    server_name = “server.my-company.com”; 
  printf (“accessing server %s\n”, server_name); 
  /* 在这里访问服务器。*/ 
return 0 
} 
假设这个程序叫 client。假设你还没有设置 SERVER_NAME 变量，则程序会使用默认
值进行连接： 
% client 
accessing server server.my-company.com 
但修改要连接到的服务器也很容易： 
% export SERVER_NAME=backup-server.elsewhere.net 
% client 
accessing server backup-server.elsewhere.net 
2.1.7 使用临时文件 
有时候程序需要使用临时文件，用来缓存或者向别的程序传递大量的数据。在
GNU/Linux 系统中，临时文件被存储在 /tmp 文件夹下。当使用临时文件的时候，你需要注
意以下的问题： 
· 同一个程序的多个副本可能正在（由同一个用户或不同的用户）并行运行。每个
副本都应该使用不同的临时文件以避免冲突。 
· 文件权限的设置应当保证临时文件不会被未被授权的用户修改或替换，从而导致
程序行为被改变。 
· 生成的临时文件名应该不可被外界预料；否则，攻击者可能会在程序检测一个文
件名是否被占用与实际打开临时文件进行读写之间的间隔进行攻击。 
GNU/Linux 提供了 mkstemp 和 tmpfile 两个函数以帮助你解决这些问题（以辅助使用
其它一些仍需要面临这些问题的函数）。两者之间的选择取决于你对文件操作的要求：是否
准备将临时文件转交给其它程序？使用 UNIX I/O（open、write 之类）还是标准 C 库的 I/O
（fopen、fprintf 之类）？ 
www.AdvancedLinuxProgramming.com 
23
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
使用 mkstemp 
函数 mkstemp 从一个文件名模板生成临时文件名，创建这个临时文件，将模式设置为
仅当前用户可以访问，并且以读写权限打开这个文件。文件名模板是一个字符串，其结尾应
为“XXXXXX”（六个大写字母 X）；mkstemp 函数用其它字符替换这些 X 以得到一个不重
复的文件名。函数返回已打开的文件描述符；可以通过 write 族的函数对它执行写入操作。 
由 mkstemp 创建的临时文件是不会被自动删除的。是否删除、以及在何时删除这些临
时文件完全取决于你。（程序员应该时刻记住及时清理临时文件，否则一旦 /tmp 文件夹被
填满，系统将不可用。）如果这个临时文件只是程序内部使用而不会移交给其它程序，在创
建之后立刻调用 unlink 是个不错的主意。这个函数会从目录中移除对应的文件项，但是文
件系统中的文件是有引用计数的，因此只有当所有指向该文件的描述符都被关闭的时候，它
才会被文件系统真正删除。通过这个方法，你的程序可以继续使用这个临时文件，而这个临
时文件会在你关闭文件描述符的时候被清除出系统。因为 Linux 系统会在程序结束的时候关
闭所有文件描述符，即使你的程序被异常终止，临时文件仍然会被删除。 
列表 2.5 中的两个函数展示了 mkstemp 的使用。这两个函数一起使用可以简化将一块
内存缓冲区写入临时文件（以便释放内存或将内存挪作它用）以及从临时文件读回内容的过
程。 
代码列表 2.5 （temp_file.c）使用 mkstemp 
#include  
#include  
/* 用于保存 write_temp_file 创建的临时文件的句柄类型。 
在这个实现中它是一个文件文件描述符。*/ 
typedef int temp_file_handle; 
/* 将 BUFFER 中的 LENGTH 字节内容写入临时文件。 
临时文件会立刻被执行 unlink 操作。 
返回指向临时文件的句柄。*/ 
temp_file_handle write_temp_file (char* buffer, size_t length) 
{ 
  /* 创建文件名和文件。XXXXXX 会被替换以生成不重复的文件名。*/ 
  char temp_filename[] = “/tmp/temp_file.XXXXXX”; 
  int fd = mkstemp (tmep_filename); 
  /* 立刻进行 unlink，从而使这个文件在我们关闭描述符的时候被删除。*/ 
  unlink (temp_filename); 
  /* 将数据的长度写入文件。*/ 
  write (fd, &length, sizeof (length)); 
  /* 现在再写入数据本身。*/ 
  write (fd, buffer, length); 
  /* 将文件描述符作为指向文件的句柄。*/ 
  return fd; 
} 
www.AdvancedLinuxProgramming.com 
24
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
/* 将 write_temp_file 建立的临时文件 TEMP_FILE 中的内容读回。 
   函数返回一块新分配的缓冲区，其中包含了这些内容。调用者必须用 free 释放这个缓冲区。 
   *LENGTH 被设置为数据的长度，以字节计。临时文件最后被删除。 
*/ 
char* read_temp_file (temp_file_handle temp_file, size_t* length) 
{ 
  char* buffer; 
  /* 句柄 TEMP_FILE 是一个指向临时文件的描述符。*/ 
  int fd = temp_file; 
  /* 回滚到文件的开始。*/ 
  lseek (fd, 0, SEEK_SET); 
  /* 读取数据的长度。*/ 
  read (fd, length, sizeof(*length)); 
  /* 分配缓冲区，然后读取数据。*/ 
  buffer = (char*) malloc (*length); 
  read (fd, buffer, *length); 
  /* 关闭文件描述符。这会导致临时文件被从系统中删除。*/ 
  close (fd); 
  return buffer; 
} 
使用 tmpfile 
如果你使用的是 C 库 I/O 函数，且你不需要向其它程序传递这个临时文件，你可以使用
tmpfile 函数。这个函数创建并打开一个临时文件并返回一个对应的文件指针。如前例中所
示，这个临时文件已经被 unlink，因此当文件指针被关闭（通过 fclose）或程序结束的时候
临时文件将被自动删除。 
GNU/Linux 提供了其它一些用于生成临时文件或文件名的函数，包括 mktemp、tmpnam
和 tempnam 等。不要使用这些函数，因为这些函数在可靠性和安全性方面存在不足。 
2.2 防御性编码 
写一个程序在“普通”状态下正常运行不是一件容易的事情；要让程序在运行出错的情
况下表现得优雅就更难了。本节中介绍了一些技巧和方法能够帮助程序员在编码阶段尽早发
现错误，以及使程序在运行中检测和恢复错误状况的出现。 
本书后面章节中的代码都有意省略了全面的错误检测与恢复代码，因为这些代码可能掩
盖所介绍的特性。不过在十一章“一个 GNU/Linux 样板应用程序”的最后的示例中，我们
回过头展示了如何利用这些技巧建立强壮的程序。 
2.2.1 使用 assert 
当构造一个应用程序的时候，应该始终记住：应该让程序在出现 bug 或非预期的错误的
时候，应该让程序尽可能早地突然死亡。这样做可以帮助你在开发——测试循环中尽早地发
现错误。不导致突然死亡的错误将很难被发现；它们通常会被忽略，直到程序在客户系统中
www.AdvancedLinuxProgramming.com 
25
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
运行以后才被注意到。 
检查非预期状态的最简单的方式是通过标准 C 库的 assert 宏。这个宏的参数是一个布
尔表达式（Boolean expression）。当表达式的值为假的时候，assert 会输出源文件名、出错行
数和表达式的字面内容，然后导致程序退出。Assert 宏可用于大量程序内部需要一致性检查
的场合。例如，可以用 assert 检查程序参数的合法性、检查函数（或 C++中的类方法）的前
提条件和最终状态（postcondition）、检查非预期的函数返回值，等等。 
每次使用 assert 宏，不仅可以作为一项运行期的检查，还可以被当作是嵌入代码中的文
档，用于指明程序的行为。如果你的程序中包含了 assert( condition )，它就是在告诉阅读代
码的人：condition 在这里应该始终成立；否则很可能是程序中的 bug。 
对于效率至上的代码，assert 这样的运行时检查可能引入严重的效率损失。在这种情况
下，你可以定义 NDEBUG 宏并重新编译源码（可以通过在编译器参数中添加 –DNDEBUG
参数做到）。在这种情况下，assert 宏的内容将被预处理器清除掉。应该只在当效率必须优
先考虑的情况下，对包含效率至上的代码的文件设置 NDEBUG 宏进行编译。 
因为 assert 可能被预处理过程清除，当使用这个宏的时候必须确信条件表达式不存在副
作用。特别的，不应该在 assert 的条件表达式中使用这些语句：函数调用、对变量赋值、使
用修改变量的操作符（如 ++ 等）。 
例如，假设你在一个循环中重复调用函数 do_something。这个函数在成功的情况下返
回 0，失败则返回非 0 值。但是你完全不期望它在程序中出现失败的情况。你可能会想这样
写： 
for (i = 0; i  0); 
这会帮助你发现错误的调用；同时它很清楚地告诉了读代码的人：这个函数对参数
的值有特殊的要求。 
不要就此退缩；在你的程序中适当地时候使用 assert 宏吧。 
2.2.2 系统调用失败 
通常我们都学会了写一个程序并期望它沿着一条预知的路线顺利执行完毕。我们将一个
程序分解成不同的任务和子任务；每个函数通过调用其它函数，逐级完成各种任务。通过提
供合适的输入，我们期望程序产生合理的输出及副作用。 
可惜，现实中的电脑硬件和软件将这种期待彻底地粉碎。系统资源的有限、硬件故障、
许多程序的并发执行、用户和程序员制造的错误……这些残酷的现实往往在应用程序与操作
系统交界的地方暴露出来。因此，当通过系统调用访问系统资源、执行 I/O 或其它命令的时
候，除了理解执行成功的意义，更应该明白出现错误可能出现的时机和原因。 
系统调用可能由于各种原因而失败。例如： 
· 系统可能出现资源短缺（或程序用尽了系统为单个程序设置的资源使用限制）。例
如，程序正在尝试分配过多的内存，向磁盘写入过多信息或同时打开过多的文件，
等等。 
· 当程序尝试执行某些自身权限不允许的操作的时候，系统可能会致使执行失败。例
如，程序尝试向一个设置为只读权限的文件写入信息、访问属于另外一个进程的内
存或杀死其它用户运行的程序等。 
· 系统调用可能由于程序之外的原因而失败。这种情况常见于通过系统调用访问硬件
设备的时候。这个设备可能不能正常工作、可能不支持特定的操作，也可能是处于