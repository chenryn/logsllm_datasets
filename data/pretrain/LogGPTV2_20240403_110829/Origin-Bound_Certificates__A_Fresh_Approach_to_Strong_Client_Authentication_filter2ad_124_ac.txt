certiﬁcates to TLS connections is minimal, we evalu-
ated the performance of TLS-OBCs in the open-source
Chromium browser using industry standard benchmarks.
All experiments were performed with Chromium version
19.0.1040.0 running on an Ubuntu (version 10.04) Linux
system with a 2.0GHz Core 2 Duo CPU and 4GB of
RAM.
All tests were performed against the TLS secured
version of a Google’s home page. During the tests
JavaScript was disabled in the browser to minimize the
impact of the JavaScript engine on any observed results.
Additionally, SPDY connection pooling was disabled,
the browser cache was cleared, and all HTTP connec-
tions were reset between each measured test run in order
to eliminate any saved state that would skew the exper-
imental results. The Chromium benchmark results dis-
cussed in section 6.1.1 were gathered with the Chromium
benchmarking extension [12] and the HTML5 Naviga-
tion Timing [19] JavaScript interface.
6.1.1 Eﬀects on Chromium TLS Connection Setup
We ﬁrst analyzed the slowdown resulting the TLS-OBC
extension for all connections bound for our website’s
HTTPS endpoints. The two use-cases considered by
these tests were the ﬁrst visit, which requires the client-
side generation of a fresh origin-bound certiﬁcate, and
subsequent visits where a cached origin-bound certiﬁcate
is used instead.
measured the total network latency from the Navigation
Timing fetchStart event to the responseEnd event, encap-
sulating TLS handshake time as well as network commu-
nication latency.
Figure 7: Observed Chromium network latency (ms),
TLS-OBC certiﬁcate pre-generated.
The results shown in Figure 7 represent subsequent re-
quests to our web site where there is a cache hit for a
pre-generated origin-bound certiﬁcate. We observed no
meaningful impact of the additional CertiﬁcateRequest
and Certiﬁcate messages required in the TLS handshake
on the overall network latency.
Figure 6: Observed Chromium network latency (ms)
with TLS-OBC certiﬁcate generation.
The ﬁrst test shown in Figure 6 shows the total net-
work latency in establishing a connection to our web site
and retrieving the homepage on the user’s ﬁrst visit. We
Figure 8: NSS certiﬁcate generate times (ms).
The diﬀerences between the latencies observed in Fig-
ures 6 and 7 imply that origin-bound certiﬁcate genera-
tion is the contributing factor in the slowdown observed
when ﬁrst visiting an origin that requires a new origin
bound certiﬁcate. We measured the performance of the
origin-bound certiﬁcate generation routine, as shown in
Figure 8, and found that the certiﬁcate generation does
seem to be the contributing factor in the higher latencies
No TLS-OBCECDSA1024 RSA2048 RSATLS-OBC type010020030040050060070080090010001100120013001400time (ms)1052514401011No TLS-OBCECDSA1024 RSA2048 RSATLS-OBC type010020030040050060070080090010001100120013001400time (ms)105104108117ECDSA1024 RSA2048 RSATLS-OBC type0200400600800100012001400160018002000time (ms)121291016seen when ﬁrst connecting to an origin with an origin-
bound certiﬁcate.
Client Performance Analysis
These observations
demonstrate that certiﬁcate generation is the main source
of slowdown that a client using origin-bound certiﬁcates
will experience. The selection of public key algorithm
has a signiﬁcant impact on the fresh connection case,
and an insigniﬁcant impact on subsequent connections.
This suggests that production TLS-OBC browsers should
speculatively use spare CPU cycles to precompute pub-
lic/private key pairs, although fresh connections will still
need to sign origin-bound certiﬁcates, which cannot be
done speculatively.
6.2 TLS Terminator Performance
We also measured the impact of TLS-OBC on Google’s
high-performance TLS terminator used inside the data-
center of our large-scale web service. To test our sys-
tem, we use a corpus of HTTP requests that model real-
world traﬃc and send that traﬃc through a TLS termina-
tor to a backend that simulates real-world responses, i.e.,
it varies both response delays (forcing the TLS termina-
tor to keep state about the HTTP connection in memory
for the duration of the backend’s “processing” of the re-
quest) as well as response sizes according to a real-world
distribution. Mirroring real-world traﬃc patterns, about
80% of the HTTP requests are sent over resumed TLS
sessions, while 20% of requests are sent through freshly-
negotiated TLS sessions.
We subjected the TLS terminator to 5 minutes of
3000 requests-per-second TLS-only traﬃc and periodi-
cally measured memory and CPU utilization of the TLS
terminator during that period.
We ran four diﬀerent tests: One without origin-bound
certiﬁcates, one with a 1024-bit RSA client key pair, one
with a 2048-bit RSA client key pair, and one with a 163-
bit client key pair on the sect163k1 elliptic curve (used
for ECDSA). We also measure the latency introduced by
the TLS terminator for each request (total server-side la-
tency minus backend “processing” time).
Figure 9 shows the impact on memory. Compared to
the baseline (without client certiﬁcates) of about 1.85GB,
the 2048-bit RSA client certs require about 12% more
memory, whereas the 1024-bit RSA and ECDSA keys
increase the memory consumption by less than 1%.
Figure 10 shows the impact on CPU utilization. Com-
pared to the baseline (without client certiﬁcates) of sat-
urating about 4.3 CPU cores, we observed the biggest
increase in CPU utilization (of about 7%) in the case of
the ECDSA client certiﬁcates.
Finally, Figure 11 through Figure 14 show latency his-
tograms. While we see an increase in higher-latency re-
sponses when using client-side certiﬁcates, the majority
Figure 9: Server-side memory footprint of various client-
side key sizes.
Figure 10: Server-side CPU utilization for various client-
side key sizes.
of requests are serviced in under one millisecond in all
four cases.
Server Performance Analysis
If we cared purely
about minimizing the memory and CPU load on our TLS
terminator systems, our measurements clearly indicate
that we should use 1024-bit RSA. As 1024-bit RSA and
163-bit ECDSA are oﬀer equivalent security [4], how-
ever the ECDSA server costs might be worth the client-
side beneﬁts.
7 Discussion – Practical Realities
We now discuss a variety of interesting details, chal-
lenges, and tensions that we encountered while dealing
with the actual nature of how applications are developed
and maintained on the web.
No TLS-OBCECDSA1024 RSA2048 RSATLS-OBC type0.000.250.500.751.001.251.501.752.002.252.50Memory (GB)1.8551.8731.8652.082No TLS-OBCECDSA1024 RSA2048 RSATLS-OBC type0123456CPU (cores)4.314.614.434.40Figure 11: Latency without client certiﬁcates.
Figure 13: Latency with 2048-bit RSA certiﬁcate.
Figure 12: Latency with 1024-bit RSA certiﬁcate.
Figure 14: Latency with 163-bit ECDSA certiﬁcate.
7.1 Domain Cookies and TLS-OBC
In Section 4 we explained how cookies can be channel-
bound using TLS-OBC, hardening them against theft.
However,
this works only as long as the cookie is
not set across multiple origins. For example: when a
cookie is set by origin foo.example.com for domain ex-
ample.com, then clients will send the cookie with re-
quests to (among others) bar.example.com. Presumably,
however, the client will use a diﬀerent client certiﬁcate
when talking to bar.example.com than it used when talk-
ing to foo.example.com. Thus, the channel-binding will
break.
Bortz et al. [6] make a convincing argument that do-
main cookies are a poor choice from a security point-of-
view, and we agree that in the long run, domain cookies
should be replaced with a mix of origin cookies and high-
performance federation protocols.
In the meantime, however, we would like to address
the issue of domain cookies. In particular, we would like
to be able to channel-bind domain cookies just as we’re
able to channel-bind origin cookies.
To that end, we are currently considering a “legacy
mode” of TLS-OBC, in which the client uses whole do-
mains (based on eTLDs), rather than web origins, as the
granularity for which it uses client-side certiﬁcates. Note
that this coarser granularity of client certiﬁcate scopes
does not increase the client’s exposure to credential theft.
All the protocols presented in this paper maintain their
security properties against men-in-the-middle, etc. The
only diﬀerence between origin-scoped client certiﬁcates
and (more broadly-scoped) domain-scoped client certiﬁ-
cates is that in the latter case, related domains (e.g.,
foo.example.com and bar.example.com) will be able to
see the same OBC for a given browser.
It
is also worth noting that even coarse-grained
domain-bound client certiﬁcates alleviate many of the
problems of domain cookies,
if those cookies are
channel-bound – including additional attacks from the
Bortz et al. paper.
In balance, we feel that the added protection aﬀorded
to widely-used domain cookies outweighs the slight risk
of “leaking” client identity across related domains, and
are therefore planning to support the above-mentioned
“legacy mode” of TLS-OBC.
7.2 Privacy
The TLS speciﬁcation [9] indicates that both client and
server certiﬁcates should be sent in the clear during the
handshake process. While OBCs do not bear any infor-
mation that could be used to identify the user, a single
OBC is meant to be reused when setting up subsequent
connections to an origin. This certiﬁcate reuse enables
an eavesdropper to track users by correlating the OBCs
used to setup TLS sessions to a particular user and track
a users browsing habits across multiple sessions.
Figure 15: TLS encrypted client certiﬁcates
Towards rectifying this issue, we propose to combine
TLS-OBC with an encrypted client certiﬁcate TLS ex-
tension. This extension modiﬁes the ordering of TLS
handshake messages so that the client certiﬁcate is sent
over an encrypted channel rather than in the clear. Fig-
ure 15 shows the eﬀect this extension has on TLS mes-
sage ordering.
7.3 SPDY and TLS-OBC
The SPDY [26] protocol multiplexes several HTTP re-
quests over the same TLS connection, thus achieving
higher throughput and lower latency. SPDY has been im-
plemented in Google Chrome for some time, and will be
supported in Firefox 11. SPDY always runs over TLS.
One feature of SPDY is IP pooling, which allows
HTTP sessions from the same client to diﬀerent web ori-
gins to be carried over the same TLS connection if: the
web origins in question resolve to the same IP address,
and the server in the original TLS handshake presented
a certiﬁcate for all the web origins in question.
For example,
if a.com and b.com resolved to the
same IP address, and the server at that IP address pre-
sented a valid certiﬁcate for a.com and b.com (presum-
ably through wildcard subject alternative names), then
a SPDY client would send requests to a.com and b.com
through the same SPDY (and, hence, TLS) connection.
Remember that with TLS-OBC, the client uses a dif-
ferent client TLS certiﬁcate with a.com than with b.com.
This presents a problem. The client needs to be able to
present diﬀerent client certiﬁcates for diﬀerent origins.
In fact, this is not a problem unique to TLS-OBC, but
applies to TLS client authentication in general: theoreti-
cally speaking, a client might want to use diﬀerent non-
OBC TLS certiﬁcates for diﬀerent origins, even if those
origins qualify for SPDY IP pooling.
One solution to would be to disallow SPDY IP pooling
whenever the client uses a TLS client certiﬁcate. Instead,
the client would have to open a new SPDY connection
to the host to which it wishes to present a client certiﬁ-
cate. This solution works well when client certiﬁcates
are rare: most of the time (when no client certiﬁcates
are involved), users will beneﬁt from the performance
improvements of SPDY IP pooling. When TLS client
certiﬁcates become ubiquitous, however (as we expect it
to be the case through TLS-OBC), most of the time the
client would not be able to take advantage of SPDY IP
pooling if this remained the solution to the problem.
Therefore, SPDY needs to address the problem of
client certiﬁcates and IP pooling. From version 3 on-
ward, it does this by adding a new CREDENTIAL con-
trol frame type. The client sends a CREDENTIAL frame
whenever it needs to present a new client certiﬁcate to
the server (for example, when talking to a new web ori-
gin over an IP-pooled SPDY connection). A CREDEN-
TIAL frame allows the client to prove ownership of a
public-key certiﬁcate without a new TLS handshake by
signing a TLS extractor value [21] with the private key
corresponding to the public-key certiﬁcate.
7.4 Other Designs We Considered
Before settling on TLS-OBC, we considered, and re-
jected, a number of alternative designs. We share these
rejected ideas below to further motivate the choice for
TLS-OBC.
Application-Level Crypto API
In this design, web
client applications would be able to use a crypto API
(similar to a PKCS#11 API, but accessible by JavaScript
in the browser). JavaScript would be able to generate key
pairs, have them certiﬁed (or leave the certiﬁcates self-
signed), use the private key to sign arbitrary data, etc.,
all without ever touching the private key material itself
(again, similar to PKCS#11 or similar crypto APIs).
Every web origin would have separate crypto key con-
tainers, meaning that keys generated in one web origin
would not be accessible by Javascript running in other
web origins. It would be up to individual applications
to sign relevant (and application-speciﬁc) authentication
tokens used in HTTP requests (e.g., special URL query
parameters) with keys from that web origin. The applica-
tion could further design its authentication tokens in such
a way that they don’t grant ambient authority to a user’s
account, but rather authorize speciﬁc actions on a user’s
ClientClientHelloServerHelloCertificate: CsCertificateRequestServerHello DoneCertificate: CcClientKeyExchangeCertificateVerifyChangeCipherSpecChangeCipherSpecServerClientClientHelloServerHelloCertificate: CsCertificateRequestServerHello DoneChangeCipherSpecChangeCipherSpecServerCertificate: CcClientKeyExchangeCertificateVerifyaccount (e.g., to send an email whose contents hashes to
a certain value, etc.).
Such a system would give some protection against a
TLS MITM: being unable to mint authentication tokens
itself, the attacker could only eavesdrop on a connection.
Also, this approach doesn’t require changes in the TLS or
HTTP layers, and is therefore “standards committee neu-
tral”, except for the need for a standardized JavaScript
crypto API, which presumably would be useful in other
contexts (than authentication) as well.
Note, however, that TLS-OBC with channel-bound
cookies provides strictly more protection, preventing
men-in-the-middle from eavesdropping. This approach
is also vulnerable to XSS attacks and requires applica-
tions to be re-written to use these application-level au-
thentication tokens (instead of existing cookies).
We didn’t consider the advantages mentioned above
strong enough to outweigh the disadvantages of this ap-
proach.
Signed HTTP Requests We also explored designs
where the client would sign HTTP requests at the HTTP
layer. For example, imagine an HTTP request header
“X-Request-Signature” that contained a signature of the
HTTP request. The key used to sign requests would be
client-generated, per-origin, etc., just like for TLS-OBC.
Unlike TLS-OBC, this would not require a change in
TLS, or HTTP for that matter. This design, however,
quickly morphed into a re-implementation of TLS at the
HTTP layer. For example, protection against replay at-
tacks leads to timestamps, counters, synchronization is-
sues, and extra round trips. Another example is session
renegotiation, questions of renegotiation protocols, and
the resulting induced latency.
TLS solves all these issues for us: it protects against
replay attacks, allow session renegotiation to be multi-
plexed with data packages, and many other issues that
would have to be addressed at the HTTP layer. We felt
that the TLS extension we’re proposing was far less com-
plex than the additions to the HTTP layer that would have
been necessary to get to comparable security, hence our
focus on TLS.
8 Related Work
Origin-bound certiﬁcates are closely related to traditional
client certiﬁcates; we take this opportunity to explain
why traditional client certiﬁcates don’t work in today’s
web. We also brieﬂy mention various similar eﬀorts to
remedy the security issues with authentication on the
web, and explain why they stop short of a complete so-
lution.
8.1 Traditional TLS Client Certiﬁcates
While TLS server authentication is widely used across
the web, the client authentication aspect of TLS is used
much less frequently. Just like TLS server authentication
identiﬁes a web server to a client (i.e., browser), TLS
client authentication uses public key cryptography to au-
thenticate a client to a web server; this process is an op-
tional part of the TLS handshake.