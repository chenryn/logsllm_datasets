even selectively modify the transmitted data. Figure 2 depicts
an SSL man-in-the-middle attack with a forged certiﬁcate
mounted between a browser and a HTTPS server. We describe
the basic steps of a generic SSL man-in-the-middle attack as
follows:
1) The attacker ﬁrst inserts itself into the transport path
between the client and the server, for example, by
setting up a malicious WiFi hotspot. Even on otherwise
trusted networks, a local network attacker may often
successfully re-route all of the client’s trafﬁc to itself
using exploits like ARP poisoning, DNS spooﬁng, BGP
hijacking, etc. The attacker could also possibly conﬁgure
itself as the client’s proxy server by exploiting auto-
conﬁguration protocols (PAC/WPAD) [19]. At this point,
the attacker has gained control over the client’s trafﬁc,
and acts as a relay server between the client and the
server.
2) When the attacker detects an SSL ClientHello message
being sent from the client, the attacker accurately deter-
mines that the client is initiating an SSL connection. The
attacker begins the impersonation of the victim server
and establishes an SSL connection with the client. Note
that the attacker uses a forged SSL certiﬁcate during its
SSL handshake with the client.
3) In parallel
to the previous step,
the attacker creates
a separate SSL connection to the legitimate server,
impersonating the client. Once both SSL connections are
established, the attacker relays all encrypted messages
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 07:14:31 UTC from IEEE Xplore.  Restrictions apply. 
ClientHello ServerHello Certificateattacker ServerHelloDone ClientKeyExchange ChangeCipherSpec Finished ChangeCipherSpec Finished Man-in-the-middle ClientHello ServerHello Certificateserver ServerHelloDone ClientKeyExchange ChangeCipherSpec Finished ChangeCipherSpec Finished Encryptattacker(data) Encryptattacker(data) Browser HTTPS server the installation of additional software or browser extensions.
Notably, Web Tripwires [24] uses client-side JavaScript code
to detect in-ﬂight modiﬁcations to a web page. Several other
studies [25], [26], [27], [28] have utilized Java applets to probe
the client’s network conﬁgurations and detect proxies that are
altering the client’s trafﬁc.
• Web Tripwires. Web Tripwires [24] was a technique
proposed to ensure data integrity of web pages, as an
alternative to HTTPS. Websites can deploy JavaScript
to the client’s browser that detects modiﬁcations on
web pages during transmission. In their study of real-
world clients, over 1% of 50, 000 unique IP addresses
observed altered web pages. Roughly 70% of the page
modiﬁcations were caused by user-installed software that
injected unwanted JavaScript into web pages. They found
that some ISPs and enterprise ﬁrewalls were also injecting
ads into web pages, or benignly adding compression to
the trafﬁc. Interestingly, they spotted three instances of
client-side malware that modiﬁed their web pages. Web
Tripwires was mainly designed to detect modiﬁcations to
unencrypted web trafﬁc. By design, Web Tripwires does
not detect passive eavesdropping (that does not modify
any page content), nor does it detect SSL man-in-the-
middle attacks. In comparison, our goal is to be able to
detect eavesdropping on encrypted SSL connections.
• Content Security Policy. Content Security Policy
(CSP) [29] enables websites to restrict browsers to load
page content, like scripts and stylesheets, only from a
server-speciﬁed list of trusted sources. In addition, web-
sites can instruct browsers to report CSP violations back
to the server with the report-uri directive. Interest-
ingly, CSP may detect untrusted scripts that are injected
into the protected page, and report them to websites. Like
Web Tripwires, CSP does not detect eavesdropping on
SSL connections.
• Browser Plugins. Another technique for websites to
diagnose the client’s network is by using browser plugins,
such as Java and Flash Player. Browser plugins may
provide more network capabilities than JavaScript, in-
cluding the ability to open raw network sockets and even
perform DNS requests. For instance, the Illuminati [25]
project used Java applets to identify whether clients were
connecting through proxies or NAT devices. Jackson et
al. conducted studies using both Java and Flash Player
on real-world clients to ﬁnd web proxy vulnerabilities,
including multi-pin DNS rebinding [26] and cache poi-
soning [27]. The ICSI Netalyzer [28] used a signed Java
applet to perform extensive tests on the client’s network
connectivity, such as detecting DNS manipulations.
In our work, we focused on detecting SSL man-in-the-
middle attacks in real-world, from a website’s perspective,
without modiﬁcations to current browsers. Other proposals to
prevent or mitigate SSL interception will be later discussed in
Section V.
86
III. SSL TAMPER DETECTION METHOD
In Section II-D, we discussed a number of existing tech-
niques for websites to detect network tampering. However,
none of the current methods (without browser modiﬁcations)
are effective in detecting SSL man-in-the-middle attacks. In
this section, we present a new method for detecting SSL
man-in-the-middle attacks from the website’s end. First, we
describe our threat model. We then detail the design and our
implementation of the detection method on the Facebook web-
site. Lastly, we present our ﬁndings from analyzing millions
of real-world SSL connections.
A. Threat Model
We primarily consider an active network attacker who has
control over the victim’s network connection. However, the
attacker does not have control over the website (such as
accessing internal machines and stealing the server’s private
key). The goal of the adversary is to read encrypted messages
between the victim client and the HTTPS website. The attacker
may impersonate the legitimate website with either (1) a
trusted certiﬁcate issued by a trusted CA, or (2) an untrusted
certiﬁcate (e.g. a self-signed certiﬁcate). In the case of an
untrusted certiﬁcate, we assume that users may still be vulner-
able, since previous studies [11], [12] have shown that many
users ignore browser security warnings. Users are assumed to
use up-to-date browsers (with no SSL implementation bugs).
In addition, we will discuss separately another type of
local attacker, where the attacker may be a piece of software
running on the client with the ability to modify the client’s
trusted CA store, as well as manipulate network connections.
Such local attackers are much stronger than active network
attackers, and are naturally not in scope of the SSL protocol’s
protection.
B. Design
There are several obstacles for websites to detect whether
any SSL man-in-the-middle attacks are mounted against their
connections. First of all, since SSL client certiﬁcates are rarely
sent by normal users, it is not possible to distinguish a legit-
imate client from an attacker directly via the SSL handshake
from the server’s perspective. In order to determine whether
an SSL connection is being intercepted, our fundamental
approach is to observe the server’s certiﬁcate from the client’s
perspective. Intuitively, if the client actually received a server
certiﬁcate that does not exactly match the website’s legitimate
certiﬁcate, we would have direct evidence that the client’s
connection must have been tampered with.
Although one could easily develop a binary executable ﬁle
or a custom browser extension that probes SSL certiﬁcates as
an SSL client, it would not be scalable to distribute additional
software to a large number of normal users, especially for
non-tech-savvy users. Ideally, we would like to develop a
JavaScript code snippet to observe SSL certiﬁcates, which
runs in existing browsers and can reach a large population of
clients. However, there are currently no existing browser APIs
that allows web applications to directly check the observed
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 07:14:31 UTC from IEEE Xplore.  Restrictions apply. 
order for a SWF applet from example.com to open a socket
connection to a HTTPS server example.com on port 443, a
valid socket policy ﬁle must be served at example.com on
port 843, which permits socket access from example.com
applications to port 443, as follows (in XML format):
Note that the socket policy ﬁle should not be confused with
the crossdomain.xml ﬁle served by web servers, which
restricts access to HTTP, HTTPS, and FTP access, but not
socket access. If the Flash Player cannot successfully retrieve
a valid socket policy (e.g. blocked by a ﬁrewall), the socket
connection will be aborted and an exception will be thrown.
Once the socket connection is permitted, our applet will
initiate an SSL handshake by sending a ClientHello message
over the socket, and wait for the server to respond with
the ServerHello and Certiﬁcate messages, which will be
recorded. To support clients behind explicit HTTP proxies,
the applet may send a CONNECT request over the socket to
create an SSL tunnel prior to sending the ClientHello message,
as follows:
CONNECT example.com:443 HTTP/1.1
Our SSL handshake implementation was based on the SSL
3.0 protocol version. Since our goal to observe the server’s
certiﬁcate chain, our applet closes the socket connection
after successfully receiving the certiﬁcate chain. Lastly, our
applet converts the raw bytes of the recorded SSL handshake
responses into an encoded string, and sends it back to our log
server with a POST request.
We note that the Flash Player plugin is currently supported
on 95% of web browsers [31], therefore, our applet should
be able to run on most clients. In fact, one of the major
browsers, Google Chrome, has the Flash Player plugin built
in by default. Also, SWF applets are usually allowed to
execute without any additional user conﬁrmation, and do not
trigger any visual indicators (e.g. system tray icons) while
running, thus, deploying this method should not affect the
visual appearance of the original web page.
Alternatively, the client-side applet may be implemented
using other browser plugins, for example, the Java plugin.
Java applets are allowed to create socket connections from
the client to any port on the same host that the applet was
served from. As an example, an applet served from port
80 on example.com can open a raw socket to port 443
on example.com without requesting any additional access.
However, due to security concerns, the Java plugin is currently
blocked by default on several client platforms, and may require
additional user interaction to activate the Java plugin. Such
user interaction would be too obtrusive for our experiment
and client diversity suffers greatly once all potential interactive
platforms are removed from the experiment. Another side
effect of running a Java applet on some platforms is that a
Fig. 3.
The website loads a client-side applet, that performs the SSL
handshake over a Flash-based socket connection to observe SSL certiﬁcates.
server certiﬁcate or validation status of their SSL connections.
To workaround this, we utilized browser plugins to implement
a client-side applet that is capable of imitating the browser’s
SSL handshake, accompanied with the ability to report the
observed certiﬁcate chain. The applet can open a socket con-
nection to the HTTPS server (skipping the browser’s network
stack), perform an SSL handshake over the socket, record
the SSL handshake, and report the certiﬁcate chain back to
our logging servers, shown in Figure 3. We describe our
implementation details below.
1) Client-Side Applet: Our approach is to use a client-
side applet that observes the server’s SSL certiﬁcate from
the client’s perspective, directly during the SSL handshake.
Since native browser networking APIs like XMLHttpRequest
and WebSockets do not provide web applications access to
raw bytes of socket connections, we must utilize browser
plugins. We implemented a Shockwave Flash (SWF) applet
that can open a raw socket connection to its own HTTPS server
(typically on port 443), and perform an SSL handshake over
the connection in the Flash Player.
By default, the Flash Player plugin does not allow any
applets to access socket connections, unless the remote host
runs a Flash socket policy server [30]. The Flash socket policy
server, normally running on port 843, serves a socket policy
ﬁle that declares whether SWF applications may open socket
connections to the server. Note that even if a SWF ﬁle is
requesting a socket connection to the same host it was served
from, a socket policy server is still required. As a result, in
87
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 07:14:31 UTC from IEEE Xplore.  Restrictions apply. 
Request HTML …  … Request applet.swf applet.swf  ... Port 843 ClientHello ServerHello, Certificateattacker… Port 443 Flash Player Log Certificateattacker Browser HTTPS server visible icon would be displayed in the system tray, which
might annoy or confuse some of the website’s users.
2) Lenient Certiﬁcate Extraction: Since we implemented
the SSL handshake process on our own, we must extract
the SSL certiﬁcates from a raw byte dump of the SSL
handshake observed on the client, by parsing the Server-
Hello and ServerCertiﬁcate messages. Surprisingly, in our
initial attempts, we found that this seemingly straightforward
extraction process failed occasionally. By manual inspection,
we noticed that some of the recorded SSL messages were
slightly different from the SSL/TLS standards. As a result,
we intentionally parsed the SSL handshake in as lenient a
manner as possible in order to extract certiﬁcates even if the
SSL message format did not conform exactly to the standards.
We did not discard these malformed handshakes as we theorize
that they are caused by either transmission errors or software
errors in the intercepting proxy.
Websites may choose to perform certiﬁcate extraction on-
the-ﬂy in the client-side applet, or simply send the handshake
raw bytes to their log servers for post-processing. We took
the latter approach, since it enabled us to preserve the SSL
handshake bytes for further investigation, even if early versions
of our extraction code failed (or even crashed unexpectedly)
while parsing certiﬁcates.
C. Implementation
We have implemented our client-side applets for both the
Flash Player and Java plugins. With similar functionality,
the SWF ﬁle (2.1 KB) was slightly smaller than the Java
applet (2.5 KB). Since Flash Player was supported on a larger
client population and is considered less obtrusive to users, we
deployed the SWF ﬁle for our experiments.
To observe SSL connections on a large set of real-world
clients, we deployed our client-side applet on Facebook’s
servers to run our experiments. We sampled a small portion
(much less than 1%) of the total connections on Facebook’s
desktop website, particularly on the www.facebook.com
domain. To avoid affecting the loading time of the website’s
original web pages, our applets are programmed to load several