### Stack or Event Traces

While our work also utilizes stack traces for crash analysis, our approach is fundamentally different. As mentioned earlier, memory information can be corrupted when attackers exploit a program. Consequently, the path analysis based on stack traces, as described in [26], fails because its effectiveness relies heavily on the integrity of the stack. In contrast, our approach leverages the source code of the crashing program to enhance core dump analysis and pinpoint the code statements where a software defect is likely to reside.

### Core Dump Forensics

Considering the low cost of capturing core dumps, prior studies [19, 21, 33, 37, 43] have proposed using them to analyze the root cause of software failures. For example, Polishchuk et al. [33] introduced a mechanism to reconstruct variable types from heap memory, and Salkeld and Kiczales [37] developed a method to resurrect Java objects from a shadow heap dump. Our work also restores memory information but extends beyond the state of objects at the time of the crash.

Microsoft's Windows Error Reporting (WER) service [21] uses a tool called `!analyze` to examine a core dump and determine which thread context and stack frame most likely caused the error. Although it shares the same goal as our work, `!analyze` cannot handle program crashes caused by security defects because attacks may introduce memory corruption and processor register failures, and its effectiveness depends on the integrity of this information.

In recent research, Wu et al. [43] proposed CrashLocator, a method to locate software defects by analyzing stack information in a core dump. Cui et al. [19] introduced RETracer, a system that reconstructs program semantics from core dumps and examines how program faults contribute to crashes. Both techniques rely heavily on the integrity of the core dump, and thus, they fail when vulnerabilities like buffer overflows and dangling pointers corrupt memory information.

Our approach, however, can handle both corrupted and uncorrupted core dumps, facilitating more robust program failure diagnosis. To the best of our knowledge, our work is the first to analyze core dumps without assuming memory integrity.

### Discussion

#### Limitations and Future Directions

**Other Crashes:** CREDAL is designed to provide useful information for software developers or security analysts to diagnose crashes caused by memory corruption vulnerabilities. However, it is not limited to such cases. For crashes without data corruption, CREDAL pinpoints the crash point and full stack trace. While this may not narrow down debugging efforts to a few lines of code, it still improves the utility of a core dump, especially when the program counter points to an invalid address and existing techniques fail to recover it.

**Multiple Threads:** CREDAL focuses on analyzing the data of the crash thread and providing information for debugging. A program crash, however, may involve multiple threads, and the information from the crash thread alone may not help developers reduce the code space they need to manually analyze. This limitation does not significantly downgrade CREDAL's utility, as a prior study [38] has shown that a large fraction of software defects involves only the crash thread. Our observation from the Offensive Security Exploit Database archive supports this finding; we did not discover any vulnerability requiring multi-thread coordination over the past twelve years.

**Potential Attacks:** When demonstrating CREDAL's utility, we conducted an exhaustive search for all possible Proof-of-Concepts (PoCs). These PoCs, however, are unaware of CREDAL. Real-world attackers who know about CREDAL might actively prevent our analysis by erasing the stack or carefully setting up memories to avoid data dependency mismatches. We will consider studying the possibility of countering offline debugging as future work.

### Conclusion

In this paper, we developed CREDAL, a debugging tool that enhances core dump analysis with the support of source code. CREDAL makes core dumps more informative for diagnosing software defects, particularly for locating memory corruption vulnerabilities. The design of CREDAL follows a conservative principle, preserving the utility of a core dump while minimizing uncertainty in the analysis.

We demonstrated CREDAL's utility using 73 memory corruption vulnerabilities, showing that it can accurately pinpoint crash points and stack traces. Additionally, we found that memory corruption vulnerabilities typically lie in code fragments related to data corruption. Therefore, CREDAL significantly reduces the code space that a software developer or security analyst needs to manually examine, especially in cases of memory corruption.

### Acknowledgments

We thank the anonymous reviewers for their helpful feedback and our shepherd, Mathias Payer, for his valuable comments on the revision of this paper. We also thank Professor Bing Mao for his technical advice. This work was supported by ARO W911NF-13-1-0421 (MURI), NSF CNS-1422594, NSF CNS-1505664, ARO W911NF-15-1-0576, and NIETP CAE Cybersecurity Grant.

### References

[References listed here as provided in the original text.]

---

This optimized version aims to improve clarity, coherence, and professionalism while maintaining the essential content and structure of the original text.