stack or event traces. While our work also uses stack traces for crash
analysis, our approach is fundamentally different. As is mentioned
earlier, memory information might be corrupted when attackers
exploit a program. Thus, the path analysis based on stack traces
described in [26] fails because its effectiveness highly relies upon
the stack integrity. In contrast with [26], our approach leverages the
source code of a crashing program to enhance core dump analysis
and pinpoints the code statements where a software defect is likely
to reside.
Core dump forensics Considering the low cost of capturing core
dumps, prior studies [19, 21, 33, 37, 43] proposed to use core dumps
to analyze the root cause of software failures. To facilitate software
failure debugging, Polishchuk et al. [33] for example proposed a
mechanism to reconstruct variable types from heap memory, and
Salkeld and Kiczales [37] introduced a method to resurrect Java
objects from a shadow heap dump. As part of our work, we also
restore memory information, but go beyond objects in memory at
the time of the program crash.
Stepping over memory semantic reconstruction, Microsoft devel-
oped Windows Error Reporting (WER) service [21], which uses a
tool – !analyze – to examine a core dump and determine which
thread context and stack frame most likely caused the error. Al-
though sharing the same goal as our work, !analyze cannot han-
dle program crashes caused by security defects for the reason that
the attacks may introduce memory corruption and processor register
failures and the effectiveness of !analyze highly relies on these
information.
In recent research, Wu et al. [43] proposed CrashLocator, a
method to locate software defects by analyzing stack information
in a core dump. In addition, Cui et al. [19] introduced RETracer,
a system that reconstructs program semantics from core dumps
and examines how program faults contribute to program crashes.
More speciﬁcally, RETracer leverages a core dump along with a
backward analysis mechanism to recover program execution status
and thus spot a software defect. Since the effectiveness of both
techniques highly relies upon the integrity of a core dump, and
exploiting vulnerabilities like buffer overﬂow and dangling pointers
corrupts memory information, CrashLocator and RETracer
fail to perform crash analysis.
Different from aforementioned core dump forensics, our approach
can deal with both corrupted and uncorrupted core dumps and facili-
tate program failure diagnosis. To the best of our knowledge, our
work is the ﬁrst research that analyzes the core dump of a crashed
program without the assumption of memory integrity.
8. DISCUSSION
In this section, we discuss the limitations of our current design,
insights we learned and possible future directions.
Other crashes. CREDAL is designed for providing useful informa-
tion for software developers (or security analysts) to diagnose the
crashes caused by memory corruption vulnerabilities. However, it
is not limited to analyzing the crashes that contain data corruption.
For the crashes without data corruption, CREDAL only pinpoints the
crash point and full stack trace of the crashing program. While such
information may not help developers narrow down their debugging
efforts within a couple of lines of code, CREDAL still improves the
utility of a core dump, especially considering the situation where the
program counter points to an invalid address and existing techniques
fail to recover it.
Multiple threads. CREDAL only focuses on analyzing the data of
the crash thread and providing information for debugging. However,
a program crash may be contributed by multiple threads. Thus, the
information from the crash thread may not help software developers
downsize the code space that they have to manually analyze. While
this multi-thread issue indeed limits the capability of a security
analyst utilizing CREDAL to track down a security vulnerability,
this does not signiﬁcantly downgrade the utility of CREDAL. In
fact, a prior study [38] has already indicated that a large fraction
of software defects involves only the crash thread. This ﬁnding is
consistent with our observation from the Offensive Security Exploit
Database archive. Looking into the aforementioned vulnerabilities
over the past twelve years, we do not discover any vulnerability, the
crash of which needs multi-thread coordination.
Potential attacks. When demonstrating the utility of CREDAL, we
conducted an exhaustive search to ﬁnd all the PoCs we can ex-
periment with. These PoCs are, however, unaware of CREDAL.
Real-world attackers who know about CREDAL might actively pre-
vent our analysis. For instance, they may thwart crash point recovery
and stack trace recovery via erasing the whole stack, and they may
also carefully set up memories to avoid data dependency mismatch.
We will take it as our future work to study the possibility of counter-
acting ofﬂine debugging.
9. CONCLUSION
In this paper, we develop a debugging tool CREDAL to facilitate
core dump analysis. With the support from source code, we show
that CREDAL can enhance core dump analysis and make a core
dump more informative for diagnosing software defects, particularly
locating memory corruption vulnerabilities. The design of CREDAL
follows a conservative principle. Thus, it preserves the utility of a
core dump, and at the same time, minimizes the uncertainty in core
dump analysis.
We demonstrated the utility of CREDAL using the crashes cor-
responding to 73 memory corruption vulnerabilities. We showed
that CREDAL can accurately pinpoint a crash point as well as a
stack trace. In addition, we demonstrated a memory corruption
vulnerability typically lies in the code fragment relevant to data
corruption. Following this ﬁnding, we safely conclude CREDAL
539can signiﬁcantly downsize the code space that a software developer
(or security analyst) needs to manually examine, especially when
memory corruption occurs.
10. ACKNOWLEDGMENTS
We thank the anonymous reviewers for their helpful feedback and
our shepherd, Mathias Payer, for his valuable comments on revision
of this paper. We also would like to thank Professor Bing Mao for
his technical advise. This work was supported by ARO W911NF-
13-1-0421 (MURI), NSF CNS-1422594, NSF CNS-1505664, ARO
W911NF-15-1-0576, and NIETP CAE Cybersecurity Grant.
References
[1] Abc2midi 2004-12-04 - multiple stack buffer overﬂow vulnerabilities.
https://www.exploit-db.com/exploits/25019/.
[2] Analysis of nginx 1.3.9/1.4.0 stack buffer overﬂow and x64 exploita-
tion (cve-2013-2028). http://www.vnsecurity.net/research/2013/05/21/
analysis-of-nginx-cve-2013-2028.html.
[3] Apple quicktime (rtsp url handler) stack buffer overﬂow exploit. https:
//www.exploit-db.com/exploits/3064/.
[4] Asterisk <= 1.0.12 / 1.2.12.1 (chan_skinny) remote heap overﬂow
(poc). https://www.exploit-db.com/exploits/2597/.
[5] Blender blenloader 2.x ﬁle processing integer overﬂow vulnerability.
https://www.exploit-db.com/exploits/26915/.
[6] Da’s dwarf page. https://www.prevanders.net/dwarf.html.
[7] Gaim <= 1.2.1 url handling remote stack overﬂow exploit. https:
//www.exploit-db.com/exploits/999/.
[8] libdisasm: x86 disassembler library. http://bastard.sourceforge.net/
libdisasm.html.
signal.7.html.
[9] Libelf - free software directory. https://directory.fsf.org/wiki/Libelf.
[10] The libunwind project. http://www.nongnu.org/libunwind/.
[11] Linux programmer’s manual. http://man7.org/linux/man-pages/man7/
[12] The llvm compiler infrastructure. http://llvm.org/.
[13] Nginx 1.3.9-1.4.0 - dos poc. http://seclists.org/fulldisclosure/2013/Jul/
[14] Offensive security exploit database archive. https://www.exploit-db.
[15] Safari 5.02 - stack overﬂow denial of service. https://www.exploit-db.
att-90/ngxunlock_pl.bin.
com/.
com/exploits/15558/.
[16] Sun java runtime environment 1.6 - web start jnlp ﬁle stack buffer
overﬂow vulnerability. https://www.exploit-db.com/exploits/30284/.
[17] H. Cleve and A. Zeller. Locating causes of program failures. In Pro-
ceedings of the 27th International Conference on Software Engineering,
2005.
[18] D. D. I. F. Committee. Dwarf debugging information format (version
4). http://www.dwarfstd.org/doc/DWARF4.pdf, 2010.
[19] W. Cui, M. Peinado, S. K. Cha, Y. Fratantonio, and V. P. Kemerlis.
Retracer: Triaging crashes by reverse execution from partial mem-
ory dumps. In Proceedings of the 38th International Conference on
Software Engineering, 2016.
[20] Y. Dang, R. Wu, H. Zhang, D. Zhang, and P. Nobel. Rebucket: A
method for clustering duplicate crash reports based on call stack simi-
larity. In Proceedings of the 34th International Conference on Software
Engineering, 2012.
[21] K. Glerum, K. Kinshumann, S. Greenberg, G. Aul, V. Orgovan,
G. Nichols, D. Grant, G. Loihle, and G. Hunt. Debugging in the
(very) large: Ten years of implementation and experience. In Pro-
ceedings of the ACM SIGOPS 22Nd Symposium on Operating Systems
Principles, 2009.
[22] S. Hangal and M. S. Lam. Tracking down software bugs using au-
tomatic anomaly detection. In Proceedings of the 24th International
Conference on Software Engineering, 2002.
[23] S. Horwitz, B. Liblit, and M. Polishchuk. Better debugging via output
tracing and callstack-sensitive slicing. IEEE Transaction Software
Engineering, 2010.
[24] S. Kim, T. Zimmermann, and N. Nagappan. Crash graphs: An aggre-
gated view of multiple crashes to improve crash triage. In Proceedings
of the 2011 IEEE/IFIP 41st International Conference on Dependable
Systems&Networks, 2011.
[25] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song.
Code-pointer integrity. In 11th USENIX Symposium on Operating Sys-
tems Design and Implementation (OSDI 14), pages 147–163, Broom-
ﬁeld, CO, Oct. 2014. USENIX Association.
[26] B. Liblit and A. Aiken. Building a better backtrace: Techniques for
postmortem program analysis. Technical report, 2002.
[27] R. Manevich, M. Sridharan, S. Adams, M. Das, and Z. Yang. Pse:
Explaining program failures via postmortem static analysis. In Pro-
ceedings of the 12th ACM SIGSOFT Twelfth International Symposium
on Foundations of Software Engineering, 2004.
[28] D. Molnar, X. C. Li, and D. A. Wagner. Dynamic test generation to
ﬁnd integer bugs in x86 binary linux programs. In Proceedings of the
18th Conference on USENIX Security Symposium, 2009.
[29] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. Softbound:
Highly compatible and complete spatial memory safety for c. ACM
Sigplan Notices, 44(6):245–258, 2009.
[30] P. Ohmann. Making your crashes work for you (doctoral symposium).
In Proceedings of the 2015 International Symposium on Software
Testing and Analysis, 2015.
[31] P. Ohmann and B. Liblit. Cores, debugging, and coverage. Technical
report, 2015.
[32] P. Ohmann and B. Liblit. Csiclipse: Presenting crash analysis data to
developers. In Proceedings of the on Eclipse Technology eXchange,
2015.
[33] M. Polishchuk, B. Liblit, and C. W. Schulze. Dynamic heap type
inference for program understanding and debugging. In Proceedings
of the 34th Annual ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages, 2007.
[34] M. Renieris and S. P. Reiss. Fault localization with nearest neighbor
queries. In Proceedings of IEEE/ACM International Conference on
Automated Software Engineering, 2003.
[35] T. Reps, T. Ball, M. Das, and J. Larus. The use of program proﬁling
for software maintenance with applications to the year 2000 problem.
In Proceedings of the 6th European SOFTWARE ENGINEERING
Conference, 1997.
[36] S. K. Sahoo, J. Criswell, C. Geigle, and V. Adve. Using likely in-
variants for automated software fault localization. In Proceedings of
the Eighteenth International Conference on Architectural Support for
Programming Languages and Operating Systems, 2013.
[37] R. Salkeld and G. Kiczales. Interacting with dead objects. In Proceed-
ings of the 2013 ACM SIGPLAN International Conference on Object
Oriented Programming Systems Languages & Applications, 2013.
[38] A. Schröter, N. Bettenburg, and R. Premraj. Do stack traces help devel-
opers ﬁx bugs? In Proceedings of the 7th IEEE Working Conference
on Mining Software Repositories, 2010.
[39] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov. Address-
sanitizer: a fast address sanity checker. In Presented as part of the
2012 USENIX Annual Technical Conference (USENIX ATC 12), pages
309–318, 2012.
[40] M. Sharir and A. Pnueli. Two approaches to interprocedural data
ﬂow analysis. New York University. Courant Institute of Mathematical
Sciences. ComputerScience Department, 1978.
[41] R. E. Strom and D. M. Yellin. Extending typestate checking using
conditional liveness analysis. IEEE Transaction Software Engineering,
1993.
[42] R. E. Strom and S. Yemini. Typestate: A programming language
concept for enhancing software reliability. IEEE Transaction Software
Engineering, 1986.
[43] R. Wu, H. Zhang, S.-C. Cheung, and S. Kim. Crashlocator: Locating
In Proceedings of the 2014
crashing faults based on crash stacks.
International Symposium on Software Testing and Analysis, 2014.
[44] D. Yuan, H. Mai, W. Xiong, L. Tan, Y. Zhou, and S. Pasupathy. Sherlog:
Error diagnosis by connecting clues from run-time logs. In Proceed-
ings of the Fifteenth Edition of ASPLOS on Architectural Support for
Programming Languages and Operating Systems, 2010.
[45] D. Yuan, J. Zheng, S. Park, Y. Zhou, and S. Savage. Improving software
diagnosability via log enhancement. In Proceedings of the Sixteenth
International Conference on Architectural Support for Programming
Languages and Operating Systems, 2011.
[46] A. Zeller. Isolating cause-effect chains from computer programs. In
Proceedings of the 10th ACM SIGSOFT Symposium on Foundations of
Software Engineering, 2002.
540