b
a
ﬁ
i
r
e
V
n
o
i
t
a
c
i
n
u
m
m
o
C
)
e
d
o
n
r
e
p
(
t
s
o
C
n
o
i
t
a
t
u
p
m
o
C
)
e
d
o
n
r
e
p
(
t
s
o
C
d
n
u
o
R
l
a
t
o
T
y
t
i
x
e
l
p
m
o
C
c
i
h
p
a
r
g
o
t
p
y
r
C
n
o
i
t
p
m
u
s
s
A
p
u
t
e
S
n
o
i
t
p
m
u
s
s
A

 

 
  
 


  
DDH
DDH
DCR RO & PKI
DDH
  O(log n · B(κn) + n · B(κ)) O(n log2 n) O(R + log n) SXDH RO & PKI
DDH RO & PKI
O(n2)
O(n2)
O(n2)
O(n2)
CRS
CRS
O(n2)
CRS
async.
async.
partial sync. 1/3
1/3
1/3
Kate et al. [40]
Kokoris et al. [43]
Abraham et al. [4], [28], [19]
This work
† These works do not explicitly discuss whether their protocols support high-
threshold or not. But we believe their protocols can be made to support
high-threshold with minor modiﬁcation.


 
†

async.
 






1/3


O(n3)
O(n3)
O(n2)
O(n3)‡
DDH RO & PKI
DDH
SXDH RO & PKI
RO
O(κn2)
DDH RO & PKI
‡ In our protocol, for reconstruction threshold of t + 1, in the common case
in practice, each node only incurs a quadratic computation (see §V)
O(log n)
O(n · B(κ))
O(n · B(κ))
O(B(κn))
O(n · B(κ))
O(B(κn))
O(κn3)
O(κn3)
O(κn2)
O(R)
O(R)
O(R)
O(R)
O(R)
O(n)
O(n)
O(1)
implementation available
ACSS scheme with an expected communication cost of
O(κn2). Our high-threshold ACSS assumes the hardness
of Decisional Composite Residuosity (DCR) in the Random
Oracle model and does not require a trusted setup. Our high-
threshold ACSS scheme improves the communication cost
by a factor of log n over the prior best scheme of [6]. This
result may be of independent interest.
Evaluation. We implement our ADKG protocol and
made our
at https://github.
com/sourav1547/adkg. Our implementation supports both
curve25519 and bls12-381 elliptic curves and any recon-
struction threshold in the range [t + 1, n − t]. We evaluate
with up to 128 nodes in geographically distributed Amazon
EC2 instances. For a reconstruction threshold of t + 1 with
32 nodes and either curve, our single-thread implementation
takes about 3 seconds and each node sends 0.7 Megabytes
of data. When the reconstruction threshold is n − t, for 32
nodes, our ADKG takes 38 and 41 seconds for curve25519
and bls12-381 elliptic curves, respectively, while each node
sends approximately 4.2 Megabytes of data.
Paper Organization. The rest of the paper is organized as
follows. In §II we describe our system model, deﬁne the
ADKG problem, and present an overview of our ADKG
protocol. We then describe preliminaries used in our protocol
in §III. We present
the detailed design of our ADKG
protocol in §IV and analyze it in §V. In §VI we brieﬂy
describe how to extend our ADKG protocol to support a
reconstruction threshold of up to n−t. We then describe our
new additively homomorphic high-threshold ACSS scheme
with quadratic communication cost in §VII. In §VIII we
provide implementation details and our evaluation results.
We discuss related work in §IX and conclude in §X.
II. SYSTEM MODEL AND OVERVIEW
A. Notations and System Model
We use κ to denote the security parameter. For example,
when we use a collision-resistant hash function, κ denotes
the size of the output of the hash function. We use |S| to
denote the size of a set S. Let Zq be a ﬁnite ﬁeld of order
q. For any integer a, we use [a] to denote the ordered set
{1, 2, . . . , a}. Also, for two integers a and b where a < b,
we use [a, b] to denote the ordered set {a, a + 1, . . . , b}.
Threat model and network assumption. We consider a
network of n nodes where every pair of nodes is connected
via a pairwise authenticated channel. We consider the pres-
ence of a malicious adversary A that can corrupt up to t
of the at least 3t + 1 nodes in the network. We assume
the network is asynchronous, i.e., A can arbitrarily delay
any message but must eventually deliver all messages sent
between honest nodes.
B. Deﬁnition of ADKG
As mentioned in §I, in this paper, we focus on ADKG
for discrete logarithm-based cryptosystems such as ElGamal
encryption [23] and BLS signatures [10], [9]. Our deﬁnition
is inspired from the DKG deﬁnition from Gennaro et al. [31].
A distributed key generation protocol for a discrete log-
arithm cryptosystem amounts to secret sharing a uniformly
random value z ∈ Zq and making public the value y = hz,
where h is a random generator of a group G of order q.
With n nodes, at the end of the protocol, each node outputs
a (n, (cid:96))-threshold Shamir share [54] of the secret z, where (cid:96)
shares are needed to use z. More precisely, let p(·) ∈ Zq[x]
be a random polynomial of degree (cid:96)− 1 such that p(0) = z.
At the end of the DKG protocol, the ith node outputs its
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
2
2519
deﬁne the same unique secret key z.
(C2) All honest nodes output the same public key y = hz
where z is the unique secret guaranteed by (C1).
share of the secret key zi = p(i), and every node outputs
the public key y = hz. A DKG protocol is called t-secure
if the following Correctness and Secrecy properties hold in
the presence of an adversary A that corrupts up to t nodes.
• Correctness:
(C1) All subsets of (cid:96) shares provided by honest parties
(C3) The secret key z is computationally indistinguishable
from a uniformly random element in Zq.
Additionally, applications of DKG such as threshold sig-
natures and threshold encryption require that in addition to
y, threshold public keys of all nodes are also publicly known.
So we add a fourth correctness requirement.
(C4) All honest nodes agree on and output the threshold
public keys of all nodes. The threshold public key of
node j is yj = hzj .
• Secrecy: No information about the secret z can be learned
by a computationally bounded adversary beyond the pub-
lic key y = hz.
We deﬁne the secrecy property in terms of simulatability:
for every probabilistic polynomial-time (PPT) adversary A
that corrupts up to t nodes, there exists a PPT simulator S,
such that on input of a uniformly random element y ∈ G,
produces a view which is indistinguishable from A’s view
of a run of the ADKG protocol that ends with y as its public
key output.
Remark. Our property C3 is slightly weaker than the
property C3 deﬁned in Gennaro et al. [31]. In particular,
Gennaro et al. require that
the secret key is uniformly
random, whereas we only require the secret key to be
computationally indistinguishable from uniform random.
C. Overview of our Protocol
Existing DKG protocols have the following typical struc-
ture: Each node runs a concurrent instance of veriﬁable
secret sharing (VSS) to share a randomly chosen secret
with every other node. Once secret-sharing ﬁnishes for t + 1
nodes, nodes locally aggregate their shares to compute the
share of the ﬁnal secret key z. Brieﬂy, the intuition is that
the aggregated secret key contains the contribution of at least
one honest node and thus remains hidden from the adversary.
Although the idea is simple, there are many challenges
for this idea to work in an asynchronous network. The
biggest challenge is to agree on which shares to aggregate
for the ﬁnal secret key z. It is well-known that reaching
agreement under asynchrony requires randomness [25], of-
ten shared randomness [12], [46], [17]. However, existing
efﬁcient mechanisms to generate shared randomness assume
threshold secret-shared keys, hence creating a circularity.
The inefﬁciency or lack of generality of prior works often
results from difﬁculties in tackling this circularity.
We address this circularity with a new approach illustrated
in Figure 1. After nodes ﬁnish their secret-sharing step, we
let each node i propose, using a reliable broadcast (RBC),
a set of nodes that i believes performed the secret-sharing
correctly. We refer to the set proposed by node i as the
ith intermediate key set and denote it using Ti. Then we
run n concurrent asynchronous Byzantine binary agree-
ment (ABA) instances. The ith ABA instance uses the ith
intermediate key set Ti to generate shared randomness. The
output of the ith ABA instance decides whether or not the
ith intermediate key set should be included in the ﬁnal
key. Finally, once all ABA instances terminate, we use the
approach from Neji et al. [47] to compute the ﬁnal public
key hz.
However, two challenges remain for the above approach.
Challenge 1. Ensure all honest nodes receive all the shares
required to generate shared randomness and to compute their