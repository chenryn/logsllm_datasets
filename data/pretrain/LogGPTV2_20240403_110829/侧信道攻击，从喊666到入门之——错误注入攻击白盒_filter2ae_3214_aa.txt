# 侧信道攻击，从喊666到入门之——错误注入攻击白盒
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：backahasten
[上文中](https://mp.weixin.qq.com/s?__biz=MzI2NzI2OTExNA==&mid=2247485952&idx=1&sn=af86f9c3ad810db1ee11a119e8de1d5f&chksm=ea802c95ddf7a583e8acd1be3c08cbac24bd7dcbb7f472ee69ceeae0d6105347c376cf02fcb1&token=1560489779&lang=zh_CN#rd)，我们介绍了有关`Unicorn`的使用，为了避免只造轮子不开车的现象出现，我们就用`Unicorn`来亲手攻击一个`AES`白盒。
我选取了`CHES 2016`
竞赛中的`AES`白盒，这个白盒非常白，甚至给了源码，代码和程序可以在[这里](https://github.com/SideChannelMarvels/Deadpool/tree/master/wbs_aes_ches2016)找到。这个链接还包含里`Writeup`，但是其中使用的工具很老了，还是`python2`的代码，并且使用的执行引擎是`PIN`，如果是`ARM`的安卓`APP`里的白盒就没办法了。
我选取了`CHES 2016`
竞赛中的`AES`白盒，这个白盒非常白，甚至给了源码，代码和程序可以在[这里](https://github.com/SideChannelMarvels/Deadpool/tree/master/wbs_aes_ches2016)找到。这个链接还包含里`Writeup`，但是其中使用的工具很老了，还是`python2`的代码，并且使用的执行引擎是`PIN`，如果是`ARM`的安卓`APP`里的白盒就没办法了。
## 啊呜，数学
#### **!!!!!!!!!所有计算均在——有限 _域_ GF( _2^8_ )!!!!!!!!**
在进行白盒破解之前，我们看一下错误注入的原理是什么。
对于AES128来说，错误注入的目标在第九轮的 _MixColumns_ 计算之前，第九轮的 _MixColumns_ 计算之前的数据假设是这个样子的：  
假设我们的错误正好命中了第一个字节，则数据流变成了：  
之后，数据流会依次进入
  * _MixColumns_
  * _AddRoundKey_ _K_ 9
  * _SubBytes_
  * _ShiftRows_
  * _AddRoundKey_ _K_ 10
中间的过程就不写了，有兴趣的通过可以自己推一下，如果熟悉`AES`的计算过程，不难推算。[这篇文章](https://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html)有详细的推导过程。
最后，`AddRoundKey *K*10` 结束之后输出，应该是这个样子的：  
如果成功错误注入的话，会变成这个样子：(其中的+号表示异或)  
以第一个字节为例，我们设：  
之后把`O`和`O’`进行`Xor`计算：  
 __
得到：  
 __
设：  
原式变为：  
 __
把剩下3个字节补齐，得到：  
四个Y的取值都是`0-255`,遍历四个Y，就可以得到Z的一个取值范围
。得到Z的取值范围了之后，可以对应一组Y。(再说一次，乘法和加法都在GF(2^8)上)
之后通过关系公式：  
推导出一组`K10（0,7,10,13）`密钥的值。
这只是错误出现在第一个Byte的情况，通过多组错误输出，可以唯一的推导所有的`K10`,之后通过密钥扩展算法，推导出`AES`的密钥。
这个地方有点绕，我们举个例子：
假设O13 ^O’13 = 0x55，我们尝试求一下：
    sbox=(
        0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
        0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
        0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
        0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
        0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
        0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
        0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
        0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
        0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
        0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
        0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
        0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
        0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
        0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
        0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
        0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16)
    a=[]
    for y3 in range(256):
        #假设O13 ^ O'13 = 0x55
        a.append(sbox.index(0x55 ^ sbox[i]) ^ y3)
    print(a)