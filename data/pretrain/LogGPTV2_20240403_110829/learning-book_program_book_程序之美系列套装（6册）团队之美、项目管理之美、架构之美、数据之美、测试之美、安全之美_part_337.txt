---
## Page 1928
能力处理上千项测试和分布在上百台机器中的系统来说，系统必须
须被完全自动化。对自动化测试的手动支持可能占去测试团队相当
多的时间。在我们讨论这样一个系统的实现和架构之前，先讨论一
下自动化系统的工作流程和测试的生命周期是很有帮助的。
测试自动化系统基础
一个最基本的漂亮的自动化系统就可以提高端对端的效率了，更何
况自动化系统有着各种不同的形式、规模和闪光点。对所有使用自
动化测试的测试团队来说，有一些基本的步骤是共通的。图8-1显示
了一个基本的自动化测试工作流。
编写
选择测试
收集用于
报告新的
自动化
和
运行测试
报告的
bug/解决已经
测试
测试平台
测试结果
修复的bug
图8-1自动化测试生命周期的流程
在测试并始或接近开始的一些地方，一个测试人员会写一项或多项
自动化测试。测试人员也可能会创建测试集（一组针对一个特定方
面或小的特性的测试）。他们可能写脚本，如JavaScript，或者创建
一个编译出来的用某一语言写的二进制文件，如C#或C++。在流程
的某个地方，这些测试必将运行并且由一个进程（或人）来跟踪测
试结果（例如，“通过"或“失败”）。一旦有了测试结果，测试人员
把新发现的错误输入bug跟踪系统，并且也许会把已经修复的bug相
互引用以保证相关的测试现在能正确地通过。
这个基本流程的问题是，在相当多的场景下，人为的干预可能是必
需的。一旦测试人员写好测试程序，职责可能是把脚本或可执行文
件（和其他需要的支持文件一起）复制到一个网络共享目录中，以
便其他测试人员可以访问到这些文件。在其他情况下，他可能要负
责自已去运行测试程序，分析结果和报告。通常，这个测试人员也
要负责录入与失败的测试相关的bug，并验证那些被解决的bug是否
真正被修复了。
漂亮的系统
1927
---
## Page 1929
端对端的自动化过程当然可以更加吸引眼球。让我们来看一下一个
更加精致的自动化系统和过程是什么样子的。
一旦测试人员完成了编写测试代码或脚本，他们就会把它们提交到
一个源代码控制管理系统（SCM）中去，让它的自动构建流程来构
建测试程序。一旦构建流程完成，系统会把测试程序和支持文件复
制到一个测试人员（包括组成自动化系统的工具）都可以访问的公
共位置。用于运行测试的系统的配置是自动发生的。这些机器的部
署和后续的执行是自动进行的。一个公共的数据库存放所有的测试
结果以方便报告和分析。最后，系统自动地在bug数据库中记录失败
的测试。
即使在这样一个系统中，还是存在不少阶段，未自动化的任务会开
始占据一个测试人员的时间。我就见过许多测试团队创建成千的自
动化测试，以为他们可以省下大量的测试时间，却最后不得不花上
无数小时在处理那些同样的测试的工作上。在许多团队，测试人员
花了如此多的时间在照看测试程序和分析测试结果上，以致他们只
剩下很少的时间用于实际的测试。
第一步
成功的第一步是简单的：测试代码要写得棒。许多测试团队把自己
推上了失败的道路，是因为他们给测试代码设的标准要远远低于他
们的产品代码。那些为了节约时间而写质量不高的测试的团队几乎
总是最后需要花上很大的力气去维护他们的测试并研究失败的测
试。
测试代码必须要能够易于维护。无论测试将要运行10大还是10年，
在一个大的团队中，很有可能除了作者以外还同时有其他人需要阅
读、调试或修改代码。在我观察到的许多团队里，一旦一个自动化
测试完成编写并集成到系统，这个测试将永远地留在系统里（当
然，除非团队把被测试的组件从产品中给去掉了）。到底“一旦被测
试，总要被测试"的概念（和这一问题的补救技巧）是不是合适，是
另一篇不同文章的题目了。
对测试代码的审阅和静态分析也是重要的。对测试服务器路径或者
用户名密码硬编码，通常是造成脆弱的测试的原因；而硬编码的资
源字符事在非英语版本上第一次运行也是如此。在编译时间或极其
1928
---
## Page 1930
接近编译时间分析源代码的工具或脚本对于发现许多诸如此类的常
见编程错误是很要紧的。
最后，很关键的一点是，要对测试代码进行源代码控制，并且集中
编译和创建。源代码控制通过使测试人员能够研究到测试代码、上
层基础结构和附属文件（测试用到的非代码文件，如媒体文件和输
入数据）完整的改变历史记录而让维护变得简单。测试代码和产品
代码一样会受到频繁的构建和持续的集成。集中版本可以允许最新
版本的测试运行在产品代码的任何一个版本上，并且保证测试可以
在一个中央的位置上得到。如果测试人员构建他们自已的测试并负
责把测试复制到服务器，那么最后一定会出错。集中版本还可以使
每个测试都嵌入一致的版本信息。版本信息在测试突然并始失败或
表现得和预期不一样时大大地简化了调试工作。
测试的基础结构很关键
上一部分的所有陈述都直接适用于测试的基础结构和工具。如果你
的团队有一个类似于本文中所描述的系统，很有可能至少某些部分
的开发工作是在团队内部进行的。再者，我们也需要这些测试工具
长期可靠和可信任。我曾看到测试团队费了很大力气对付那些不好
用的工具，也花了很多时间为那些不好的实现寻找变通方法，最终
却因为工具的更新而白费心血。
为了这个目的，代码评审、单元测试和验收测试对于一个测试基础
结构的所有主要部分来说都很关键。没有人想要去用一个会浪费测
试人员时间的工具，但是几乎所有人都想要用直观的、可靠的和能
工作的工具。
测试辅助
另一个很多测试团队犯的错误是：他们没能很好地管理测试辅助文
件。这里的“辅助”，我指的是数据文件、文档、插件或测试用到的
其他数据。保证这些文件有源代码控制是重要的，但是更重要的是
要确保这些文件被放在一个满足以下两个关键条件的地方。第一，
文件必须是能够被自动化测试系统得到的。例如，如果网络上设有
不同的访问权限，在一个测试团队成员都能访问到的共享目录下的
文件并不一定能被自动化系统获取。第二，辅助文件需要放在一个
非临时的地方。支持工程和维护团队痛恨接手那些需要从已经不存
在的服务器或共享文件夹复制辅助文件的测试。
1929
---
## Page 1931
应对这一问题的补救措施可以包括为测试辅助文件建立一个永久的
服务器或使用一个数据库来存储所有的辅助项目。即使不使用这个
方案，有一份移交测试辅助的计划书对于保证整个自动化系统的“坚
固耐用”也是很重要的。
自动化测试和测试用例的管理
随着测试用例的数目由上百到上千，测试用例的管理变成了整个系
统的一个关键元素。为了跟踪每项测试在做什么和哪项测试通过了
而哪项没有，所有的测试都需要被关联到一个唯一的标识号码。从
最低程序上说，指派测试ID可以帮助在多种测试配置和场景中跟踪
测试结果，并且它也可以将需求或用户故事与相应的测试联系起
来。
对每个测试用例指派唯一的ID是最低要求，但是如果能够实现一个
更大的和测试相关的属性集合，那么就可以支持更大的功能集合。
表8-1显示了一个测试用例管理系统中部分测试用例编号和相关属性
的摘要举例。
表8-1：测试用例管理系统标识属性举例
测试用例编号测试二进制文件
命令行
配置
标签
或脚本
10001
perfTest.dl1
/entry:perfTestOne
AIl
Performance; Core
10002
perfTest.dll
/entry:perfTestTwo
Main
Performance
11001
scenarioTest.exe
/Persona:Peggy
Main
Scenarios
11002
scenarioTest.exe
/Persona:Car]
Mobile
Scenarios
12001
Applications.js
AII
Applications
13002
filesysBVT.dII
/entry:createFileTests/ful1
Main
FileSystem: BVT
13023
filesysBVT.dll
/entry:usbStorageTests
USBStorage
FileSystem; BVT;
USB
以下是表8-1中各列的简要解释：
测试用例编号
这是一个分配给各项测试的全局唯一的号码。编号并不一定需要按
顺序的，但它们必须是唯一的。在大的系统中，一个能自动分配唯
1930
---
## Page 1932
一编号的方法是必需的。下文中的插文部分“详细分解”解释了一些
常用的生成编号的方法。
测试二进制文件和脚本
自动化测试通常内嵌在二进制文件（EXE或DLL）或脚本（如Java
Script、QuickTestPro、PowerShell或者Phython）里。负责运行测试
的系统（插件）会在执行测试的时候使用到二进制文件或脚本的名
字。
命令行
测试系统用命令行和二进制文件或脚本名称来运行测试。这样可以
使自定义成为可能，如为那些数据驱动的测试增加数据引用，或可
以隔离较大的测试文件中的单个测试，使之可以独立运行。