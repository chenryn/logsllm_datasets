When the catch handler finishes, the program continues with the first
statement that follows the handler. Note that if no handler corresponds to the
exception, the exception is said to be unhandled (this situation will be
described shortly).
Click here to view code image
try
{
    int leftHandSide = int.Parse(lhsOperand.Text);
    int rightHandSide = int.Parse(rhsOperand.Text);
    int answer = doCalculation(leftHandSide, rightHandSide);
    result.Text = answer.ToString();
}
catch (FormatException fEx)
{
    // Handle the exception
    ...
Download from finelybook PI:EMAIL
230
}
A catch handler employs syntax similar to that used by a method
parameter to specify the exception to be caught. In the preceding example,
when a FormatException is thrown, the fEx variable is populated with an
object containing the details of the exception.
The FormatException type has a number of properties that you can
examine to determine the exact cause of the exception. Many of these
properties are common to all exceptions. For example, the Message property
contains a text description of the error that caused the exception. You can use
this information when handling the exception, perhaps recording the details
in a log file or displaying a meaningful message to the user and then asking
the user to try again.
Unhandled exceptions
What happens if a try block throws an exception and there is no
corresponding catch handler? In the previous example, it is possible that the
lhsOperand text box could contain the string representation of a valid integer
but the integer it represents is outside the range of valid integers supported by
C# (for example, “2147483648”). In this case, the int.Parse statement would
throw an OverflowException, which will not be caught by the
FormatException catch handler. If this occurs and the try block is part of a
method, the method immediately exits and execution returns to the calling
method. If the calling method uses a try block, the runtime attempts to locate
and execute a matching catch handler for this try block. If the calling method
does not use a try block or if there is no matching catch handler, the calling
method immediately exits, and execution returns to its caller, where the
process is repeated. If a matching catch handler is eventually found, the
handler runs and execution continues with the first statement that follows the
catch handler in the catching method.
Important Notice that after catching an exception, execution continues
in the method containing the catch block that caught the exception. If
the exception occurred in a method other than the one containing the
Download from finelybook PI:EMAIL
231
catch handler, control does not return to the method that caused the
exception.
If, after cascading back through the list of calling methods, the runtime is
unable to find a matching catch handler, the program will terminate with an
unhandled exception.
You can easily examine exceptions generated by your application. If you
are running the application in Microsoft Visual Studio 2017 in debug mode
(that is, on the Debug menu you selected Start Debugging to run the
application) and an exception occurs, a dialog box similar to the one shown
in the following image appears and the application pauses, helping you to
determine the cause of the exception:
The application stops at the statement that caused the exception and drops
you into the debugger. There you can examine the values of variables, you
can change the values of variables, and you can step through your code from
the point at which the exception occurred by using the Debug toolbar and the
Download from finelybook PI:EMAIL
232
various debug windows.
Using multiple catch handlers
The previous discussion highlighted how different errors throw different
kinds of exceptions to represent different kinds of failures. To cope with
these situations, you can supply multiple catch handlers, one after the other,
such as in the following:
Click here to view code image
try
{
    int leftHandSide = int.Parse(lhsOperand.Text);
    int rightHandSide = int.Parse(rhsOperand.Text);
    int answer = doCalculation(leftHandSide, rightHandSide);
    result.Text = answer.ToString();
}
catch (FormatException fEx)
{
    //...
}
catch (OverflowException oEx)
{
    //...
}
If the code in the try block throws a FormatException exception, the
statements in the catch block for the FormatException exception run. If the
code throws an OverflowException exception, the catch block for the
OverflowException exception runs.
Note If the code in the FormatException catch block generates an
OverflowException exception, it does not cause the adjacent
OverflowException catch block to run. Instead, the exception
propagates to the method that invoked this code, as described earlier in
this section.
Download from finelybook PI:EMAIL
233
Catching multiple exceptions
The exception-catching mechanism provided by C# and the Microsoft .NET
Framework is quite comprehensive. The .NET Framework defines many
types of exceptions, and any programs you write can throw most of them. It
is highly unlikely that you will want to write catch handlers for every
possible exception that your code can throw—remember that your application
must be able to handle exceptions that you never even considered when you
wrote it! So, how do you ensure that your programs catch and handle all
possible exceptions?
The answer to this question lies in the way the different exceptions are
related to one another. Exceptions are organized into families called
inheritance hierarchies. (You will learn about inheritance in Chapter 12,
“Working with inheritance.”) FormatException and OverflowException both
belong to a family called SystemException, as do a number of other
exceptions. SystemException is itself a member of a wider family simply
called Exception, and this is the great-granddaddy of all exceptions. If you
catch Exception, the handler traps every possible exception that can occur.
Note The Exception family includes a wide variety of exceptions, many
of which are intended for use by various parts of the .NET Framework.
Some of these exceptions are somewhat esoteric, but it is still useful to
understand how to catch them.
The next example shows how to catch all possible exceptions:
Click here to view code image
try
{
    int leftHandSide = int.Parse(lhsOperand.Text);
    int rightHandSide = int.Parse(rhsOperand.Text);
    int answer = doCalculation(leftHandSide, rightHandSide);
    result.Text = answer.ToString();
}
catch (Exception ex) // this is a general catch handler
Download from finelybook PI:EMAIL
234
{
    //...
}
Note If you want to catch Exception, you can actually omit its name
from the catch handler because it is the default exception:
Click here to view code image
catch
{
    // ...
}
However, this is not recommended. The exception object passed to
the catch handler can contain useful information concerning the
exception, which is not easily accessible when using this version of the
catch construct.
There is one final question you should be asking at this point: What
happens if the same exception matches multiple catch handlers at the end of a
try block? If you catch FormatException and Exception in two different
handlers, which one will run? (Or will both execute?)
When an exception occurs, the runtime uses the first handler it finds that
matches the exception and the others are ignored. This means that if you
place a handler for Exception before a handler for FormatException, the
FormatException handler will never run. Therefore, you should place more
specific catch handlers above a general catch handler after a try block. If
none of the specific catch handlers matches the exception, the general catch
handler will.
Filtering exceptions
You can filter the exceptions that are matched against catch handlers, to
ensure that the exception handler is triggered only when additional conditions
are met. These conditions take the form of a Boolean expression prefixed by
Download from finelybook PI:EMAIL
235
the when keyword. The following example illustrates the syntax:
Click here to view code image
bool catchErrors = ...;
try
{
    ...
}
catch (Exception ex) when (catchErrors == true)
{
    // Only handle exceptions if the catchErrors variable is true
}
This example catches all exceptions (the Exception type) depending on the
value of the catchErrors boolean variable; if this variable is false, then no
exception handling occurs, and the default exception handling mechanism for
the application is used. If catchErrors is true, then the code in the catch block
runs to handle the exception.
In the following exercises, you will see what happens when an application
throws an unhandled exception, and then you will write a try block to catch
and handle an exception.
Observe how the application reports unhandled exceptions
1. Start Visual Studio 2017, if it is not already running.
2. Open the MathsOperators solution, which is located in the \Microsoft
Press\VCSBS\Chapter 6\MathsOperators folder in your Documents
folder.
This is a version of the program from Chapter 2, “Working with
variables, operators, and expressions,” that demonstrates the different
arithmetic operators.
3. On the Debug menu, click Start Without Debugging.
Note For this exercise, ensure that you actually run the application
without debugging.
Download from finelybook PI:EMAIL
236
The form appears. You are now going to enter some text in the Left
Operand box that will cause an exception. This operation will
demonstrate the lack of robustness in the current version of the program.
4. In the Left Operand box, type John, and in the Right Operand box, type
2. Click the + Addition button, and then click Calculate.
This input triggers Windows default exception handling: the application
simply terminates, and you are returned to the desktop!
Now that you have seen how the application behaves when an unhandled
exception occurs, the next step is to make the application more robust by
handling invalid input and preventing unhandled exceptions from arising.
Write a try/catch statement block
1. Return to Visual Studio 2017.
2. On the Debug menu, click Start Debugging.
3. When the form appears, in the Left Operand box, type John, and in the
Right Operand box, type 2. Click the + Addition button, and then click
Calculate.
This input should cause the same exception that occurred in the previous
exercise, except that now you are running in debug mode, so Visual
Studio traps the exception and reports it.
Visual Studio displays your code and highlights the statement that
caused the exception. It also displays a dialog box that describes the
exception, which in this case is “Input string was not in a correct
format.”
You can see that a FormatException was thrown by the call to int.Parse
inside the addValues method. The problem is that this method is unable
to parse the text “John” into a valid number.
Download from finelybook PI:EMAIL
237
4. In the exception dialog box, click View Details.
The QuickWatch dialog box opens in which you can view more details
about the exception. If you expand the exception, you can see this
information:
Download from finelybook PI:EMAIL
238
Tip Some exceptions are the result of other exceptions raised
earlier. The exception reported by Visual Studio is just the final
exception in this chain, but it is usually the earlier exceptions that
highlight the real cause of the problem. You can drill into these
earlier exceptions by expanding the InnerException property in the
View Detail dialog box. Inner exceptions might have further inner
exceptions, and you can keep digging down until you find an
exception with the InnerException property set to null (as shown in
the previous image). At this point, you have reached the initial
exception, and this exception typically highlights the problem that
you need to address.
Download from finelybook PI:EMAIL
239
5. Click Close in the QuickWatch dialog box, and then, in Visual Studio,
on the Debug menu, click Stop Debugging.
6. Display the code for the file MainPage.xaml.cs in the Code and Text
Editor window, and locate the addValues method.
7. Add a try block (including braces) around the statements inside this
method, together with a catch handler for the FormatException
exception, as shown in bold here:
Click here to view code image
try
{
    int lhs = int.Parse(lhsOperand.Text);
    int rhs = int.Parse(rhsOperand.Text);
    int outcome = 0;
    outcome = lhs + rhs;
    expression.Text = $" + ";
    result.Text = outcome.ToString();
}
catch (FormatException fEx)
{
    result.Text = fEx.Message;
}
Now, if a FormatException exception occurs, the catch handler displays
the text held in the exception’s Message property in the result text box at
the bottom of the form.
8. On the Debug menu, click Start Debugging.
9. When the form appears, in the Left Operand box, type John, and in the
Right Operand box type 2. Click the + Addition button, and then click
Calculate.
The catch handler successfully catches the FormatException, and the
message “Input string was not in a correct format” is written to the
Result text box. The application is now a bit more robust.
Download from finelybook PI:EMAIL
240
10. Replace John with the number 10. In the Right Operand box, type
Sharp, and then click Calculate.
The try block surrounds the statements that parse both text boxes, so the
same exception handler handles user input errors in both text boxes.
11. In the Right Operand box, replace Sharp with 20, click the + Addition
button, and then click Calculate.
The application now works as expected and displays the value 30 in the
Result box.
12. In the Left Operand box, replace 10 with John, click the – Subtraction
button, and then click Calculate.
Visual Studio drops into the debugger and reports a FormatException
exception again. This time, the error has occurred in the subtractValues
method, which does not include the necessary try/catch processing. You
will fix this problem shortly.
13. On the Debug menu, click Stop Debugging.
Download from finelybook PI:EMAIL
241
Propagating exceptions
Adding a try/catch block to the addValues method has made that method
more robust, but you need to apply the same exception handling to the other
methods: subtractValues, multiplyValues, divideValues, and
remainderValues. The code for each of these exception handlers will likely
be very similar, resulting in you writing the same code in each method. Each
of these methods is called by the calculateClick method when the user clicks
the Calculate button. Therefore, to avoid duplication of the exception-
handling code, it makes sense to relocate it to the calculateClick method. If a
FormatException occurs in the subtractValues, multiplyValues, divideValues,
or remainderValues method, it will be propagated back to the calculateClick
method for handling as described in the section “Unhandled exceptions”
earlier in this chapter.
Propagate an exception back to the calling method
1. Display the code for the file MainPage.xaml.cs in the Code and Text
Editor window, and locate the addValues method.
2. Remove the try block and catch handler from the addValues method and
return it to its original state, as shown in the following code:
Click here to view code image
private void addValues()
{
    int leftHandSide = int.Parse(lhsOperand.Text);
    int rightHandSide = int.Parse(rhsOperand.Text);
    int outcome = 0;
    outcome = lhs + rhs;
    expression.Text = lhsOperand.Text + " + " + rhsOperand.Text
    result.Text = outcome.ToString();
}
3. Find the calculateClick method. Add to this method the try block and
catch handler shown in bold in the following example:
Click here to view code image
private void calculateClick(object sender, RoutedEventArgs e)
{
    try
    {
Download from finelybook PI:EMAIL
242
        if ((bool)addition.IsChecked)
        {
            addValues();
        }
        else if ((bool)subtraction.IsChecked)
        {
            subtractValues();
        }
        else if ((bool)multiplication.IsChecked)
        {
            multiplyValues();
        }
        else if ((bool)division.IsChecked)
        {
            divideValues();
        }
        else if ((bool)remainder.IsChecked)
        {
            remainderValues();
        }
    }
    catch (FormatException fEx)
    {
        result.Text = fEx.Message;
    }
}
4. On the Debug menu, click Start Debugging.
5. When the form appears, in the Left Operand box, type John, and in the
Right Operand box, type 2. Click the + Addition button, and then click
Calculate.
As before, the catch handler successfully catches the FormatException,
and the message “Input string was not in a correct format” is written to
the Result text box. However, bear in mind that the exception was
actually thrown in the addValues method, but the handler caught it in the
calculateClick method.
6. Click the – Subtraction button, and then click Calculate.
This time, the subtractValues method causes the exception, but it is
propagated back to the calculateClick method and handled in the same
manner as before.
7. Test the * Multiplication, / Division, and % Remainder buttons, and
verify that the FormatException exception is caught and handled
Download from finelybook PI:EMAIL
243
correctly.
8. Return to Visual Studio and stop debugging.
Note The decision whether to catch unhandled exceptions explicitly in a
method depends on the nature of the application you are building. In
some cases, it makes sense to catch exceptions as close as possible to
the point at which they occur. In other situations, it is more useful to let
an exception propagate back to the method that invoked the routine that
threw the exception and handle the error there.
Using checked and unchecked integer arithmetic
Chapter 2 discusses how to use binary arithmetic operators such as + and *
on primitive data types such as int and double. You should also recall that the
primitive data types have a fixed size. For example, a C# int is 32 bits.
Because int has a fixed size, you know exactly the range of values that it can
hold: it is –2147483648 to 2147483647.
Tip If you want to refer to the minimum or maximum value of int in
code, you can use the int.MinValue or int.MaxValue properties.
The fixed size of the int type creates a problem. For example, what
happens if you add 1 to an int whose value is currently 2147483647? The
answer is that it depends on how the application is compiled. By default, the
C# compiler generates code that allows the calculation to overflow silently
and you get the wrong answer. (In fact, the calculation wraps around to the
largest negative integer value, and the result generated is –2147483648.) The
Download from finelybook PI:EMAIL
244
reason for this behavior is performance: integer arithmetic is a common
operation in almost every program, and adding the overhead of overflow
checking to each integer expression could lead to very poor performance. In
many cases, the risk is acceptable because you know (or hope!) that your int
values won’t reach their limits. If you don’t like this approach, you can turn
on overflow checking.
Tip You can turn overflow checking on and off in Visual Studio 2017
by setting the project properties. In Solution Explorer, click YourProject
(where YourProject is the actual name of the project). On the Project
menu, click YourProject Properties. In the project properties dialog box,
click the Build tab. Click the Advanced button in the lower-right corner
of the page. In the Advanced Build Settings dialog box, select or clear
the Check For Arithmetic Overflow/Underflow check box.
Regardless of how you compile an application, you can use the checked
and unchecked keywords to turn on and off integer arithmetic overflow
checking in parts of an application that you think need it. These keywords
override the compiler option specified for the project.
Writing checked statements
A checked statement is a block preceded by the checked keyword. All integer
arithmetic in a checked statement always throws an OverflowException if an
integer calculation in the block overflows, as shown in this example:
Click here to view code image
int number = int.MaxValue;
checked
{
    int willThrow = number++;
    Console.WriteLine("this
}
Download from finelybook PI:EMAIL