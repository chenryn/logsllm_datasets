root@0ddf83b837fe:/# apt-get install sqlite3
.....(apt-get install sqlite3命令的输出)
root@0ddf83b837fe:/# echo “test docker commit” >> hellodocker
root@0ddf83b837fe:/# exit
这里创建的容器的ID是0ddf83b837fe，这个ID在使用commit命令时会用到。在容器中完成修
改之后，使用exit命令安全退出容器。
接下来，我们使用commit命令将容器里的所有修改提交到本地库中，形成一个全新的镜像：
# docker commit -m="Message" --author="XIXIHE" 0ddf83b837fe xixihe/sqlite3:v1
a0345b9244e19f03c3456b29e488b653a9cd7b9b1686e4d60a04ecb802247c95
# docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
xixihe/sqlite3 V1 a0345b9244e1 About a minute ago 220.9 MB
...(略)
成功执行commit命令后，会返回一个长字符串，这个字符串就是刚创建的镜像的完整ID。
commit命令后跟随的0ddf83b837fe参数是我们刚才作出修改的容器ID，这个ID也可以通过docker
ps -l -q（用于获取最近创建的容器ID）命令得到。-m参数是描述我们此次创建image的信息，
--author参数用来指定作者信息，xixihe和sqlite3分别是仓库名和镜像名，v1是TAG名。
接下来，我们使用刚才创建的镜像来构建一个容器并运行，以检视所做的修改：
# docker run -t -i xixihe/sqlite3:v1
root@ce066126f750:/# sqlite3 -version
3.8.2 2013-12-06 14:53:30 27392118af4c38c5203a04b8013e1afdb1cebd0d
root@ce066126f750:/# cat hellodocker
test docker commit
从以上命令的反馈来看，SQLite3已经成功安装了，同时根目录下的hellodocker文件也存在。
3.3.2 使用Dockerfile创建镜像
与第一种方法相比，我们更推荐使用Dockerfile来构建镜像。将需要对镜像进行的操作全部
写到一个文件中，然后使用docker build 命令从这个文件中创建镜像。这种方法可以使镜像的创
建变得透明和独立化，并且创建过程可以被重复执行。Dockerfile文件以行为单位，行首为
Dockerfile命令，命令都是大写形式，其后紧跟着的是命令的参数。
下面是一个Dockerfile文件实例，本例子并没有实际意义，只是为了将知识点都覆盖到：
# Version: 1.0.1
3.3 创建本地镜像 35
FROM ubuntu:latest
1
MAINTAINER xxh "PI:EMAIL"
2
#设置root用户为后续命令的执行者
USER root
3
#执行操作
RUN apt-get update
RUN apt-get install -y nginx
4
#使用&&拼接命令
RUN touch test.txt && echo "abc" >> abc.txt
5
#对外暴露端口
EXPOSE 80 8080 1038
6
#添加文件
ADD abc.txt /opt/
7
#添加文件夹
ADD /webapp /opt/webapp
9
#添加网络文件
ADD https://www.baidu.com/img/bd_logo1.png /opt/
8
#设置环境变量
ENV WEBAPP_PORT=9090
10
#设置工作目录
WORKDIR /opt/
10
#设置启动命令
ENTRYPOINT ["ls"]
11
#设置启动参数
CMD ["-a", "-l" ]
13
#设置卷
VOLUME ["/data", "/var/www"]
14
#设置子镜像的触发操作
ONBUILD ADD . /app/src
ONBUILD RUN echo "on build excuted" >> onbuild.txt 15
下面介绍一下上述代码中各个命令的含义。
16
 FROM：指定待扩展的父级镜像。除了注释外，在文件开头必须是一个FROM指令，接下来的
指令便在这个父级镜像的环境中运行，直到遇到下一个FROM指令。通过添加多个FROM命令，
17
可以在同一个Dockerfile文件中创建多个镜像。
 MAINTAINER：用来声明创建的镜像的作者信息。在上述代码中，xxh是用户名，PI:EMAIL
18
是邮箱。这个命令并不是必需的。
36 第3章 镜像
 RUN：用来修改镜像的命令，常用来安装库、程序以及配置程序。一条RUN指令执行完毕后，
会在当前镜像上创建一个新的镜像层，接下来的指令会在新的镜像上继续执行。RUN语句
又有两种形式：
RUN apt-get update
RUN [ "apt-get", "update" ]
第一种形式是在/bin/sh环境中执行指定的命令，第二种形式是直接使用系统调用exec来执
行。我们还可以使用&&符号将多条命令连接在同一条RUN语句中执行：
RUN apt-get update && apt-get install nginx。
 EXPOSE：用来指明容器内进程对外开放的端口，多个端口之间使用空格隔开。运行容器时，
通过参数-P（大写）即可将EXPOSE里所指定的端口映射到主机上另外的随机端口，其他容
器或主机就可以通过映射后的端口与此容器通信。同时，我们也可以通过-p（小写）参
数将Dockerfile中EXPOSE中没有列出的端口设置成公开的。
 ADD：向新镜像中添加文件，这个文件可以是一个主机文件，也可以是一个网络文件，也
可以是一个文件夹。
ADD命令的第一个参数用来指定源文件（夹），它可以是文件路径、文件夹的路径或网络
文件的URL地址。需要特别注意的是，如果是文件路径或文件夹路径，它必须是相对
Dockerfile所在目录的相对路径。如果是一个文件URL，在创建镜像时，会先下载下来，
然后再添加到镜像里去。第二个参数是文件需要放置在目标镜像的位置。如果源文件是
主机上zip或者tar形式的压缩文件，Docker会先解压缩，然后将文件添加到镜像的指定位
置。如果源文件是一个通过URL指定的网络压缩文件，则不会解压。
 VOLUME：该命令会在镜像里创建一个指定路径（文件或文件夹）的挂载点，这个路径可以
来自主机或者其他容器。多个容器可以通过同一个挂载点共享数据，即便其中一个容器
已经停止，挂载点也仍然可以访问，只有当挂载点的容器引用全部消失时，挂载点才会
自动删除。关于卷的概念，我们会在第4章中详细介绍。
 WORKDIR：为接下来执行的指令指定一个新的工作目录，这个目录可以是绝对目录，也可
是相对目录。根据需要，WORKDIR可以被多次指定。当启动一个容器时，最后一条WORKDIR
指令所指的目录将作为容器运行的当前工作目录。
 ENV：设置容器运行的环境变量。在运行容器的时候，通过-e参数可以修改这个环境变量
值，也可以添加新的环境变量：
# docker run -e WEBAPP_PORT=8000 -e WEBAPP_HOST=www.example.com ...
 CMD：用来设置启动容器时默认运行的命令。假如Dockerfile中CMD命令是这样的：
CMD [ "ls", "-a", "-l" ]
那么运行容器的效果如下：
3.3 创建本地镜像 37
# docker run xixihe/test
1
total 72
drwxr-xr-x 44 root root 4096 Dec 11 06:07 .
drwxr-xr-x 44 root root 4096 Dec 11 06:07 ..
2
-rwxr-xr-x 1 root root 0 Dec 11 06:07 .dockerenv
-rwxr-xr-x 1 root root 0 Dec 11 06:07 .dockerinit
drwxr-xr-x 2 root root 4096 Dec 4 00:16 bin
3
drwxr-xr-x 2 root root 4096 Apr 10 2014 boot
...
4
这样启动一个容器时，就不再需要指定运行的程序或命令了。当然，我们仍然可以重新
指定启动命令以覆盖在Dockerfile文件中指定的命令：
5
# docker run xixihe/test echo "hello docker"
hello docker
6
CMD参数的格式和RUN类似，也有两种形式，并且两者达到的结果是一样的：
CMD ls -l -a 7
CMD [ "ls", "-l", "-a" ]
 ENTRYPOINT：与CMD类似，它也是用来指定容器启动时默认运行的命令。 9
假如，我们指定的ENTRYPOINT是这样的：
8
ENTRYPOINT [ "ls", "-l"]
并构建出名为xixihe/newImage的镜像，那么# docker run xixihe/newImage的运行结果与
10
# docker run ubuntu ls -l一样，而# docker run xixihe/newImage -a的运行结果与# docker
run ubuntu ls -l -a一样。
10
不难发现，ENTRYPINT和CMD的区别在于运行容器时添加在镜像名之后的参数，对ENTRYPOINT
是拼接，而对于CMD命令则是覆盖。幸运的是，我们在运行容器的时候可以通过 11
--entrypoint来覆盖Dockerfile中的指定：
13
# docker run --entrypoint echo xixihe/newImage "hello docker"
hello docker
14
通常情况下，我们会将CMD和ENTRYPOINT搭配起来使用。ENTRYPOINT用于指定需要运行的
命令，CMD用于指定运行命令所需要的参数，示例如下：
15
ENTRYPOINT [ "ls" ]
CMD [ "-a", "-l" ]
16
 USER：为容器的运行及接下来RUN、CMD、ENTRYPOINT等指令的运行指定用户或UID。
 ONBUILD：触发器指令。构建镜像的时候，Docker的镜像构建器会将所有的ONBUILD指令指
17
定的命令保存到镜像的元数据中，这些命令在当前镜像的构建过程中并不会执行。只有
新的镜像使用FROM指令指定父镜像为这个镜像时，便会触发执行。
18
38 第3章 镜像
下面的两条ONBUILD命令表明，使用FROM以这个Dockerfile构建出的镜像为父镜像，构建子镜
像时将自动执行ADD . /app/src和RUN echo "on build excuted" >> onbuild.txt这两个操作：
ONBUILD ADD . /app/src
ONBUILD RUN echo "on build excuted" >> onbuild.txt
接下来，我们使用build命令来构建镜像：
# docker build -t xixihe/test:v1 .
Sending build context to Docker daemon 6.656 kB
Sending build context to Docker daemon
Step 0 : FROM ubuntu:latest
---> 8eaa4ff06b53
Step 1 : MAINTAINER xxh "PI:EMAIL"
---> Using cache
---> f9caa95a4e54
Step 2 : USER root
---> Using cache
---> 05ee079f4925
Step 3 : RUN apt-get update
---> Using cache
---> 73ede9cd2370
Step 4 : RUN apt-get install -y nginx
---> Running in 08e9129ef019
Reading package lists...
Building dependency tree...
Reading state information...
...(略)
---> eed9121c42e0
Removing intermediate container 08e9129ef019
Step 5 : RUN touch test.txt && echo "abc" >> abc.txt
---> Running in 141802f35d94
---> d3625958dc52
Removing intermediate container 141802f35d94
Step 6 : EXPOSE 80 8080 1038
---> Running in f6416dc4a06a
---> 0b49809bb5bd
Removing intermediate container f6416dc4a06a
Step 7 : ADD abc.txt /opt/
---> d59504f2e153
Removing intermediate container f894b8dbe851
Step 8 : ADD /webapp /opt/webapp
---> 29c74c759648
Removing intermediate container f1743fe68cd2
Step 9 : ADD https://www.baidu.com/img/bd_logo1.png /opt/
Downloading [==================================================>] 7.877 kB/7.877 kB
---> fadd6b26b530
Removing intermediate container dd7d02402e56
Step 10 : ENV WEBAPP_PORT 9090
---> Running in 790a3a67287f
---> cec6fc5d3142
Removing intermediate container 790a3a67287f
Step 11 : WORKDIR /opt/
3.3 创建本地镜像 39
---> Running in d212a6e972d9
1
---> 124b42584b26
Removing intermediate container d212a6e972d9
Step 12 : ENTRYPOINT ls
2
---> Running in 90f8af6462f8
---> cc2d6e77e0a5
Removing intermediate container 90f8af6462f8
3
Step 13 : CMD -a -l
---> Running in f7599cc842c6
---> 8daa393de892
4
Removing intermediate container f7599cc842c6
Step 14 : VOLUME /data /var/www
---> Running in 94c93a0b4dd4
5
---> d8f925114884
Removing intermediate container 94c93a0b4dd4
Step 15 : ONBUILD add . /app/src
6
---> Running in 3a3275168c41
---> 642e0f8ad100
Removing intermediate container 3a3275168c41
7
Step 16 : ONBUILD run echo "on build excuted" >> onbuild.txt
---> Running in 4c54d1262b21
---> dd2d6ebe0215
9
Removing intermediate container 4c54d1262b21
Successfully built dd2d6ebe0215