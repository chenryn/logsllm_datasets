2For security reasons, Qualys does not test application endpoints on
This test provides a comprehensive, non-invasive view of
the conﬁguration and capabilities of a server’s SSL/TLS
implementation.
Phase 2: Reverse Engineering
In order to complete our holistic view of both the ap-
plication protocols and the client/server SSL/TLS nego-
tiation, we reverse engineered each app in the second
phase. For this step, we used the commercial interac-
tive JEB Decompiler [4] to provide Java syntax for most
classes. While we primarily used the decompiled out-
put for analysis, we also reviewed the Dalvik assem-
bly to ﬁnd vulnerabilities. Where we were able to ob-
tain accounts for mobile money accounts, we also con-
ﬁrmed each vulnerability with our accounts when doing
so would not negatively impact the service or other users.
Rather than start by identifying interesting methods
and classes, we began analysis by following the appli-
cation lifecycle as the Android framework does, starting
with the Application.onCreate() method and mov-
ing on to the ﬁrst Activity to execute. From there, we
constructed the possible control paths a user can take
from the beginning through account registration, login,
and money transfer. This approach ensures that our ﬁnd-
ings are actually present in live code, and accordingly
leads to conservative claims about vulnerabilities.3 After
tracing control paths through the Activity user inter-
face code, we also analyze other components that appear
to have sensitive functionality.
As stated previously, our main interest is in verifying
the integrity of these ﬁnancial applications. In the course
of analysis, we look for security errors in the following
actions:
These errors can be classiﬁed as:
• Registration and login
• User authentication after login
• Money transfers
• Improper authentication procedures
• Message conﬁdentiality and integrity failures (in-
• Highly sensitive information leakage (including ﬁ-
nancial information or authentication credentials)
• Practices that discourage good security hygiene,
cluding misuse of cryptography)
such as permitting insecure passwords
We discuss our speciﬁc ﬁndings in Section 4.
3.3.1 Vulnerability Disclosure
As of the publication deadline of this paper we have no-
tiﬁed all services of the vulnerabilities. We also included
basic details of accepted mitigating practices for each
non-standard ports or without registered domain names.
3In the course of analysis, we found several vulnerabilities in what
is apparently dead code. While we disclosed those ﬁndings to develop-
ers for completeness, we omit them from this paper.
USENIX Association  
24th USENIX Security Symposium  21
5
Common Weakness Enumeration
Improper Certiﬁcate Validation
Use of Insufﬁciently Random Values
Key Exchange without Entity Authentication
ID
SSL/TLS & Certiﬁcate Veriﬁcation
CWE-295
Non-standard Cryptography
CWE-330
CWE-322
Access Control
CWE-88
CWE-302
CWE-521 Weak Password Requirements
CWE-522
CWE-603
CWE-640 Weak Password Recovery Mechanism for Forgotten Password
Information Leakage
CWE-200
CWE-532
CWE-312
CWE-319
Information Exposure
Information Exposure Through Log Files
Cleartext Storage of Sensitive Information
Cleartext Transmission of Sensitive Information
Argument Injection or Modiﬁcation
Authentication Bypass by Assumed-Immutable Data
Insufﬁciently Protected Credentials
Use of Client-Side Authentication
Airtel Money
mPAY
Oxigen Wallet
GCash
Zuum MOM mCoin




























Table 1: Weaknesses in Mobile Money Applications, indexed to corresponding Common Weakness Enumera-
tion (CWE) records. The CWE database is a comprehensive taxonomy of software vulnerabilities developed by
MITRE [55] and provide a common language for software errors.
ﬁnding. Most have not sent any response to our disclo-
sures. We have chosen to publicly disclose these vulner-
abilities in this paper out of an obligation to inform users
of the risks they face in using these insecure services.
4 Results
This section details the results of analyzing the mobile
money applications. Overall, we ﬁnd 28 signiﬁcant vul-
nerabilities across seven applications. Table 1 shows
these vulnerabilities indexed by CWE and broad cate-
gories (apps are ordered by download count). All but
one application (Zuum) presents at least one major vul-
nerability that harmed the conﬁdentiality of user ﬁnan-
cial information or the integrity of transactions, and most
applications have difﬁculty with the proper use of cryp-
tography in some form.
4.1 Automated Analysis
Our results for SSL/TLS vulnerabilities should mirror
the output of an SSL/TLS vulnerability scanner such as
Mallodroid. Though two applications were unable to be
analyzed by Mallodroid, it detects at least one critical
vulnerability in over 50% of the applications it success-
fully completed.
Mallodroid produces a false positive when it detects
an SSL/TLS vulnerability in Zuum, an application that,
through manual analysis, we veriﬁed was correctly per-
forming certiﬁcate validation. The Zuum application
does contain disabled certiﬁcate validation routines, but
these are correctly enclosed in logic that checks for de-
velopment modes.
Conversely, in the case of MoneyOnMobile, Mallo-
droid produces a false negative. MoneyOnMobile con-
tains no SSL/TLS vulnerability because it does not em-
ploy SSL/TLS. While this can be considered correct op-
eration of Mallodroid, it also does not capture the severe
information exposure vulnerability in the app.
Overall, we ﬁnd that Mallodroid, an extremely pop-
ular analysis tool for Android apps, does not detect the
correct use of SSL/TLS in an application. It produces
an alert for the most secure app we analyzed and did not
for the least. In both cases, manual analysis reveals stark
differences between the Mallodroid results and the real
security of an app. A comprehensive, correct analysis
must include a review of the application’s validation and
actual use of SSL/TLS sessions as well as where these are
used in the application (e.g., used for all sensitive com-
munications). Additionally, it is critical to understand
whether the remote server enforces secure protocol ver-
sions, ciphers, and hashing algorithms. Only a manual
analysis provides this holistic view of the communica-
tion between application and server so that a complete
security evaluation can be made.
4.2 SSL/TLS
As we discussed above, problems with SSL/TLS certiﬁ-
cate validation represented the most common vulnera-
bility we found among apps we analyzed. Certiﬁcate
validation methods inspect a received certiﬁcate to en-
sure that it matches the host in the URL, that it has a
trust chain that terminates in a trusted certiﬁcate author-
ity, and that it has not been revoked or expired. However,
developers are able to disable this validation by creating
a new class that implements the X509TrustManager in-
terface using arbitrary validation methods, replacing the
validation implemented in the parent library. In the appli-
cations that override the default code, the routines were
empty; that is, they do nothing and do not throw excep-
22  24th USENIX Security Symposium 
USENIX Association
6
Product
Airtel Money
mPAY 1
mPAY 2
Oxigen Wallet
Zuum
GCash
mCoin
MoneyOnMobile
Qualys Most Noteworthy
Score
A-
F-
F-
F-
A-
C-
N/A
N/A
Vulnerabilities
Weak signature algorithm (SHA1withRSA)
SSL2 support, Insecure Client-Initiated Renegot.
Vulnerable to POODLE attack
SSL2 support, MD5 cipher suite
Weak signature algorithm (SHA1withRSA)
Vulnerable to POODLE attack
Uses expired, localhost self-signed certiﬁcate
App does not use SSL/TLS
Table 2: Qualys reports for domains associated with
branchless banking apps. “Most Noteworthy Vulnerabil-
ities” lists what Qualys considers to be the most danger-
ous elements of the server’s conﬁguration. mPAY con-
tacts two domains over SSL, both of which are separately
tabulated below. Qualys would not scan mCoin because
it connects to a speciﬁc IP address, not a domain.
tions on invalid certiﬁcates. This insecure practice was
previously identiﬁed by Georgiev et al. [31] and is specif-
ically targeted by Mallodroid.
Analyzing only the app does not provide complete vis-
ibility to the overall security state of an SSL/TLS ses-
sion. Server misconﬁguration can introduce additional
vulnerabilities, even when the client application uses cor-
rectly implemented SSL/TLS. To account for this, we
also ran the Qualys SSL Server Test [50] on each of
the HTTPS endpoints we discovered while analyzing the
apps. This service tests a number of properties of each
server to identify conﬁguration and implementation er-
rors and provide a “grade” for the conﬁguration. These
results are presented in Table 2. Three of the endpoints
we tested received failing scores due to insecure im-
plementations of SSL/TLS. To underscore the severity
of these misconﬁgurations, we have included the “Most
Noteworthy Vulnerabilities” identiﬁed by Qualys.
mCoin. Coupling the manual analysis with the Qualys
results, we found that in one case, the disabled validation
routines were required for the application to function cor-
rectly. The mCoin API server provides a certiﬁcate that
is issued to “localhost” (an invalid hostname for an ex-
ternal service), is expired, and is self-signed (has no trust
chain). No correct certiﬁcate validation routine would
accept this certiﬁcate. Therefore, without this routine,
the mCoin application would be unable to establish a
connection to its server. Although Mallodroid detected
the disabled validation routines, only our full analysis
can detect the relationship between the app’s behavior
and the server’s conﬁguration.
The implications of poor validation practices are se-
vere, especially in these critical ﬁnancial applications.
Adversaries can intercept this trafﬁc and sniff cleartext
personal or ﬁnancial information. Furthermore, without
additional message integrity checking inside these weak
SSL/TLS sessions, a man-in-the-middle adversary is free
to manipulate the inside messages.
2
1
Encryption Server
3
Registration Server
Figure 5: The user registration ﬂow of MoneyOnMobile.
All communication is over HTTP.
4.3 Non-Standard Cryptography
Despite the pervasive insecure implementations of
SSL/TLS, the client/server protocols that these apps im-
plement are similarly critical to their overall security. We
found that four applications used their own custom cryp-
tographic systems or had poor implementations of well-
known systems in their protocols. Unfortunately, these
practices are easily compromised and severely limit the
integrity and privacy guarantees of the software, giving
rise to the threat of forged transactions and loss of trans-
action privacy.
MoneyOnMobile. MoneyOnMobile does not use SS-
L/TLS. All API calls from the app use HTTP. In fact,
we found only one use of cryptography in the applica-
tion’s network calls. During the user registration process,
the app ﬁrst calls an encryption proxy web service, then
sends the service’s response to a registration web service.
The call to the encryption server includes both the user
data and a ﬁxed static key. A visualization of this proto-
col is shown in Figure 5.
The encryption server is accessed over the Internet via
HTTP, exposing both the user and key data. Because
this data is exposed during the initial call, its subsequent
encryption and delivery to the registration service pro-
vides no security. We found no other uses of this or any
other encryption in the MoneyOnMobile app; all other
API calls are provided unobfuscated user data as input.
Oxigen Wallet. Like MoneyOnMobile, Oxigen Wal-
let does not use SSL/TLS. Oxigen Wallet’s registration
messages are instead encrypted using the Blowﬁsh al-
gorithm, a strong block cipher. However, a long, ran-
dom key is not generated for input into Blowﬁsh.
In-
USENIX Association  
24th USENIX Security Symposium  23
7
stead, only 17 bits of the key are random. The remain-
ing bits are ﬁlled by the mobile phone number, the date,
and padding with 0s. The random bits are generated by
the Random [34] random number generator. The stan-
dard Java documentation [44] explicitly warns in its doc-
umentation that Random is not sufﬁciently random for
cryptographic key generation.4 As a result, any attacker
can read, modify, or spoof messages. These messages
contain demographic information including ﬁrst and last
name, email address, date of birth, and mobile phone
number, which constitutes a privacy concern for Oxigen
Wallet’s users.
After key generation, Oxigen Wallet transmits the key
in plaintext along with the message to the server. In other
words, every encrypted registration message includes the
key in plaintext. Naturally, this voids every guarantee of
the block cipher. In fact, any attacker who can listen to
messages can decrypt and modify them with only a few
lines of code.
The remainder of client-server interactions use an
RSA public key to send messages to the server. To es-
tablish an RSA key for the server, Oxigen Wallet sends
a simple HTTP request to receive an RSA key from the
Oxigen Wallet server. This message is unauthenticated,
which prevents the application from knowing that the re-
ceived key is from Oxigen Wallet and not from an at-
tacker. Thus, an attacker can pretend to be Oxigen Wal-
let and send an alternate key to the app. This would al-
low the attacker to read all messages sent by the client
(including those containing passwords) and forward the
messages to Oxigen Wallet (with or without modiﬁca-
tions) if desired. This RSA man-in-the-middle attack is
severe and puts all transactions by a user at risk. At the
very least, this will allow an attacker to steal the pass-