title:AppSealer: Automatic Generation of Vulnerability-Specific Patches
for Preventing Component Hijacking Attacks in Android Applications
author:Mu Zhang and
Heng Yin
AppSealer: Automatic Generation of Vulnerability-Speciﬁc Patches for
Preventing Component Hijacking Attacks in Android Applications
Mu Zhang
Department of EECS
Syracuse University
PI:EMAIL
Heng Yin
Department of EECS
Syracuse University
PI:EMAIL
Abstract—Component hijacking is a class of vulnerabilities
commonly appearing in Android applications. When these vul-
nerabilities are triggered by attackers, the vulnerable apps can
exﬁltrate sensitive information and compromise the data integrity
on Android devices, on behalf of the attackers. It is often unrealis-
tic to purely rely on developers to ﬁx these vulnerabilities for two
reasons: 1) it is a time-consuming process for the developers to
conﬁrm each vulnerability and release a patch for it; and 2) the
developers may not be experienced enough to properly ﬁx the
problem. In this paper, we propose a technique for automatic
patch generation. Given a vulnerable Android app (without
source code) and a discovered component hijacking vulnerability,
we automatically generate a patch to disable this vulnerability. We
have implemented a prototype called AppSealer and evaluated its
efﬁcacy on apps with component hijacking vulnerabilities. Our
evaluation on 16 real-world vulnerable Android apps demon-
strates that the generated patches can effectively track and
mitigate component hijacking vulnerabilities. Moreover, after
going through a series of optimizations, the patch code only
represents a small portion (15.9% on average) of the entire
program. The runtime overhead introduced by AppSealer is also
minimal, merely 2% on average.
I.
INTRODUCTION
With the boom of Android devices, the security threats in
Android are also increasing. Although the permission-based
sandboxing mechanism enforced in Android can effectively
conﬁne each app’s behaviors by only allowing the ones granted
with corresponding permissions, a vulnerable app with certain
critical permissions can perform security-sensitive behaviors
on behalf of a malicious app. It is so called confused deputy
attack. This kind of security vulnerabilities can present in
numerous forms, such as privilege escalation [1], capability
leaks [2], permission re-delegation [3], content
leaks and
pollution [4], component hijacking [5], etc.
Prior work primarily focused on automatic discovery of
these vulnerabilities. Once a vulnerability is discovered, it can
be reported to the developer and a patch is expected. Some
patches can be as simple as placing a permission validation at
the entry point of an exposed interface (to defeat privilege
Permission(cid:1) to(cid:1) freely(cid:1) reproduce(cid:1) all(cid:1) or(cid:1) part(cid:1) of(cid:1) this(cid:1) paper(cid:1) for(cid:1) noncommercial(cid:1)
purposes(cid:1)is(cid:1)granted(cid:1)provided(cid:1)that(cid:1)copies(cid:1)bear(cid:1)this(cid:1)notice(cid:1)and(cid:1)the(cid:1)full(cid:1)citation(cid:1)
on(cid:1)the(cid:1)ﬁrst(cid:1)page.(cid:1) Reproduction(cid:1)for(cid:1)commercial(cid:1)purposes(cid:1)is(cid:1)strictly(cid:1)prohibited(cid:1)
without(cid:1)the(cid:1)prior(cid:1)written(cid:1)consent(cid:1)of(cid:1)the(cid:1)Internet(cid:1)Society,(cid:1)the(cid:1)ﬁrst-named(cid:1)author(cid:1)
(for(cid:1) reproduction(cid:1) of(cid:1) an(cid:1) entire(cid:1) paper(cid:1) only),(cid:1) and(cid:1) the(cid:1) author’s(cid:1) employer(cid:1) if(cid:1) the(cid:1)
paper(cid:1)was(cid:1)prepared(cid:1)within(cid:1)the(cid:1)scope(cid:1)of(cid:1)employment.
NDSS(cid:1)’14,(cid:1)23-26(cid:1)February(cid:1)2014,(cid:1)San(cid:1)Diego,(cid:1)CA,(cid:1)USA
Copyright(cid:1)2014(cid:1)Internet(cid:1)Society,(cid:1)ISBN(cid:1)1-891562-35-5
http://dx.doi.org/(cid:18)(cid:17)(cid:15)(cid:18)(cid:21)(cid:24)(cid:19)(cid:19)(cid:16)(cid:79)(cid:69)(cid:84)(cid:84)(cid:15)(cid:19)(cid:17)(cid:18)(cid:21)(cid:15)(cid:19)(cid:20)(cid:19)(cid:22)(cid:22)
escalation [1] and permission re-delegation [3] attacks), or
withholding the public access to the internal data repositories
(to defend against content leaks and pollution [4]), the ﬁxes
to the other problems may not be so straightforward.
In particular, component hijacking may fall into the latter
category. When receiving a manipulated input from a malicious
Android app, an app with a component hijacking vulnerability
may exﬁltrate sensitive information or tamper with the sensi-
tive data in a critical data repository on behalf of the malicious
app. In other words, a dangerous information ﬂow may happen
in either an outbound or inbound direction depending on
certain external conditions and/or the internal program state.
A prior effort has been made to perform static analysis
to discover potential component hijacking vulnerabilities [5].
Static analysis is known to be conservative in nature and may
raise false positives. To name a few, static analysis may ﬁnd a
viable execution path for information ﬂow, which may never
be reached in actual program execution; static analysis may
ﬁnd that interesting information is stored in some elements
in a database, and thus has to conservatively treat the entire
database as sensitive. Upon receiving a discovered vulnera-
bility, the developer has to manually conﬁrm if the reported
vulnerability is real. It may also be nontrivial for the (often
inexperienced) developer to properly ﬁx the vulnerability and
release a patch for it. As a result, these discovered vulnerabil-
ities may not be addressed for long time or not addressed at
all, leaving a big time window for attackers to exploit these
vulnerabilities. Out of the 16 apps with component hijacking
vulnerabilities we tested, only 3 of them were ﬁxed in one
year.
To close this window, we aim to automatically generate a
patch that is speciﬁc to the discovered component hijacking
vulnerability. In other words, we would like to automatically
generate a vulnerability-speciﬁc patch on the original program
to block the vulnerability as a whole, not just a set of malicious
requests that exploit the vulnerability.
While automatic patch generation is fairly new in the
context of Android applications, a great deal of research has
been done for traditional client and server programs (with and
without source code). Many efforts have been made to auto-
matically generate signatures to block bad inputs, by perform-
ing symbolic execution and path exploration [6]–[10]. This ap-
proach is effective if the vulnerability is triggered purely by the
external input and the library functions can be easily modeled
in symbolic execution. However, for android applications, due
to the asynchronous nature of the program execution, a suc-
cessful exploitation may depend on not only the external input,
but also the system events and API-call return values. Other
efforts have been made to automatically generate code patches
within the vulnerable programs to mitigate certain kinds of
vulnerabilities. To name a few, AutoPaG [11] focused on buffer
overﬂow and general boundary errors; IntPatch [12] addressed
integer-overﬂow-to-buffer-overﬂow problem; To defeat zero-
day worms, Sidiroglou and Keromytis [13] proposed an end-
point ﬁrst-reaction mechanism that tries to automatically patch
vulnerable software by identifying and transforming the code
surrounding the exploited software ﬂaw; and VSEF [14] mon-
itors and instruments the part of program execution relevant to
speciﬁc vulnerability, and creates execution-based ﬁlters which
ﬁlter out exploits based on vulnerable program’s execution
trace, rather than solely upon input string.
In principle, our automatic patch generation technique falls
into the second category. However, our technique is very
different from these existing techniques, because it requires
a new machinery to address this new class of vulnerabilities.
The key of our patch generation technique is to place minimally
required code into the vulnerable program to accurately keep
track of dangerous information originated from the exposed
interfaces and effectively block the attack at
the security-
sensitive APIs.
To achieve this goal, we ﬁrst perform static bytecode
analysis to identify small but complete program slices that
lead to the discovered vulnerability. Then we devise several
shadowing mechanisms to insert new variables and instructions
along the program slices, for the purpose of keeping track of
dangerous information at runtime. In the end, we apply a series
of optimizations to remove redundant instructions to minimize
the footprint of the generated patch. Consequently, the auto-
matically generated patch can be guaranteed to completely
disable the vulnerability with minimal
impact on runtime
performance and usability.
We implement a prototype, AppSealer,
in 16 thousand
lines of Java code, based on the Java bytecode optimization
framework Soot [15]. We leverage Soot’s capability to perform
static dataﬂow analysis and bytecode instrumentation. We
evaluate our tool on 16 real-world Android apps with com-
ponent hijacking vulnerabilities. Our experiments show that
the patched programs run correctly, while the vulnerabilities
are effectively mitigated.
Contributions. In summary, this paper has made the following
contributions:
• We propose an automatic patch generation technique
to defeat component hijacking attacks in Android
applications. Its core is to place minimally required
code into the vulnerable program to accurately keep
track of dangerous information and block the attack
right at the sink.
• We implement a prototype system called AppSealer
in 16 thousand lines of Java code. AppSealer ﬁrstly
performs static dataﬂow analysis to generate program
slices of dangerous information ﬂows. Then, it au-
tomatically patches the slices by devising shadowing
mechanisms and inserting new statements. Finally, it
applies a series of optimizations to remove redundant
patch statements and minimize the patch size.
• We evaluate AppSealer on 16 vulnerable Android
apps. The experiments show that our approach is both
effective and efﬁcient. We demonstrate that patched
apps run correctly, while the vulnerability is effec-
tively mitigated. The size of patched program in-
creases only 15.9% on average and the added runtime
overhead is minimal, merely 2% on average.
Paper Organization. The rest of the paper is organized
as follows. Section II describes the problem of automatic
patch generation for preventing component hijacking attacks,
and gives an overview of our patch generation technique.
Section III, IV, and V present the three steps of our proposed
technique, which are taint slice computation, patch statement
placement, and patch optimization. Section VI presents our
experimental results over real Android apps. Discussion and
related work are presented in Section VII and Section VIII,
respectively. Finally, the paper concludes with Section IX.
II. PROBLEM STATEMENT & APPROACH OVERVIEW
In this section, we start with a motivating example to
explain the problem that this paper aims to address and provide
an overview of our proposed technique.
A. Running Example
Figure 1 presents a synthetic running example in Java
source code, which has a component hijacking vulnerability.
More concretely, the example class is one of the Activity com-
ponents in an Android application. It extends an Android Ac-
tivity and overrides several callbacks including onCreate(),
onStart() and onDestroy().
Upon receiving a triggering Intent, the Android framework
creates the Activity and further invokes these callbacks. Once
the Activity is created, onCreate() retrieves the piggy-
backed URL string from the triggering Intent. Next, it saves
this URL to an instance ﬁeld addr if the resulting string is not
null, or uses the DEFAULT_ADDR otherwise. When the Ac-
tivity starts, onStart() method acquires the latest location
information by calling getLastKnownLocation(), and
stores it to a static ﬁeld location. Further, onDestroy()
reads the location object from this static ﬁeld, encodes the data
into a string, encrypts the byte array of the string and sends it
to the URL speciﬁed by addr through a raw socket.
This program is subject to component hijacking attack,
because a malicious app may send an Intent
to this Ac-
tivity with a URL speciﬁed by the attacker. As a re-
sult,
this vulnerable app will send the location informa-
tion to the attacker’s URL. In other words, this vulnerabil-
ity allows the malicious app to retrieve sensitive informa-
tion without having to declare the related permissions (i.e.,
android.permission.ACCESS_FINE_LOCATION and
android.permission.INTERNET).
Besides information leakage, a component hijacking attack
may happen in the reverse direction. That is, a vulnerable
program may allow a malicious app to modify the content of
certain sensitive data storage, such as the Contacts database,
2
private String DEFAULT_ADDR = "http://default.url";
private byte DEFAULT_KEY = 127;
/* Entry point of this Activity */
public void onCreate(Bundle savedInstanceState){
this.key = DEFAULT_KEY;
private String addr;
private static Location location;
private byte key;
1 public class VulActivity extends Activity{
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
VulActivity.location = getLocation();
this.addr = DEFAULT_ADDR;
public void onDestroy(){
String location =
public void onStart(){
}
}
}
this.addr = getIntent().getExtras().getString("url");
if(this.addr == null){
Double.toString(VulActivity.location.getLongitude()) +
"," + Double.toString(VulActivity.location.getLatitude
());
byte[] bytes = location.getBytes();
for(int i=0; i<bytes.length; i++)
bytes[i] = crypt(bytes[i]);
String url = this.addr;
post(url, bytes);
}
public byte crypt(byte plain){
return (byte)(plain ˆ key);
}
public Location getLocation(){
Location location = null;
LocationManager locationManager = (LocationManager)
getSystemService(Context.LOCATION_SERVICE);
location = locationManager.getLastKnownLocation(
LocationManager.GPS_PROVIDER);
return location;
}
public void post(String addr, byte[] bytes){
URL url = new URL(addr);
HttpURLConnection conn = (HttpURLConnection)url.
openConnection();
...
OutputStream output = conn.getOutputStream();
output.write(bytes, 0, bytes.length);
...
26
27
28