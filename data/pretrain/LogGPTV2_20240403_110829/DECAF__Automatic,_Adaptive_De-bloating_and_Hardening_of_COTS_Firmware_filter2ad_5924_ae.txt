dead code and security vulnerabilities in the code.
Both program slicing and debloating software mechanisms
can be used to improve our pruning mechanism, however there
are two important aspects to be considered before one can
adopt and adapt them. First, existing research focuses on trim-
ming a self-contained program that can be run independently
of other system components, while UEFI ﬁrmware initializes
system hardware. An error may prevent the operating system
from using some hardware features, but the UEFI ﬁrmware
itself will still continue to run without problem. Second, the
problem of hand-written assembly code in UEFI ﬁrmware
is not tackled by most of the existing literature. The EDK II
project contains about 1.4M lines of C/C++/Header code and
19K lines of assembly, a small but not insigniﬁcant amount.
Rastogi et al. use dynamic analysis techniques to auto-
matically debloat and harden docker containers, removing
unused resources and partitioning the executeables within the
container based on the resources they access [33]. They use
system call logs to determine resource access which is similar
to our approach of hooking into the UEFI protocol look-up
method discussed in Section 2.3.
Bazhaniuk et al. use symbolic execution to ﬁnd vulner-
abilities within UEFI ﬁrmware by analyzing a snapshot of
SMRAM [7] . Their setup can generate 4000 test cases in 4
hours, which can be later repeated on an actual real board.
Their testing environment makes use of a generic and open
source UEFI implementation, and replicating it on a closed
source UEFI might not be possible, given the difﬁculty in
emulating non-generic hardware.
The article from [22] presents an extremely similar ap-
proach, but focused on debloating the Linux Kernel instead.
In this case, the argument made shows that the kernel will
contain a very large set of features, out of which only a small
number will be used by a speciﬁc end user. The developers
include all available functionalities in the kernel, even if sup-
port for certain exotic features is used by only a few users.
In a similar manner to our work, a set of usage scenarios
are deﬁned in order to determine what parts of the code are
reached within the targeted kernel. This is achieved by ana-
lyzing the function call graph at runtime during a use case.
The functions are traced back to the source code, allowing the
creation of a custom conﬁguration. According to this work
the Linux Kernel has roughly 11,000 conﬁguration options,
which will be automatically tailored to minimize the code
base while maintaining the functionality determined in the
usage scenarios, removing up to 70% of it.
RedDroid [18] is a project that targets software bloat in the
Android world. Here redundancy is deﬁned as either compile-
time or install-time, depending on when it can be determined.
The ﬁrst category comes from included libraries (because
each application runs inside a Java Virtual Machine, there
is no static or dynamic linking). The second one refers to
various platform dependent ﬁles (which can only be deter-
mined as redundant when installing on a speciﬁc platform).
The software debloating is realized by static code analysis
(for compile-time redundancy; reachable code is determined,
removing the rest) and a set of shell scripts (for install-time
redundancy; the scripts will remove any unnecessary platform
speciﬁc ﬁles). On average the APK size can decrease by 42%.
It is important to note that RedDroid does not necessarily
focus on security, but rather on saving hardware resources.
The work at [13] presents a large scale experiment on em-
bedded ﬁrmware images (note: in this context ﬁrmware does
not necessarily mean UEFI environments but, rather any form
of software that may be found on various embedded/IoT de-
vices). A large number of binaries was collected (roughly
32000 through web crawling). These images were processed
using simple static analysis and correlation techniques. By
comparing various binaries, known vulnerabilities were be
detected on various devices that were previously not known to
be affected. 38 new CVEs were also submitted, as the frame-
work also attempts to extract and crack password hashes,
private keys and certiﬁcates, ﬁnd back doors and target vari-
ous other common hot spots. An interesting result is that two
different classes of products had the same vulnerability (44
surveillance camera models and 3 ﬁrmware images for home
routers). It turns out that they all used a System on a Chip
(SoC) for networking devices from the same vendor. This
particular scenario shows how vulnerable software is reused
in different applications, and a pruning framework (such as
DECAF) can potentially remove such threats.
Of particular interest to many security-conscious users is
the Intel Management Engine (ME), which is co-processor in-
tegrated into almost all Intel-based motherboards since 2006.
It enables many Intel Features which may be attractive to
some enterprise users, but requires full access to the host sys-
tem’s memory to do so. For users not needing the advanced
management features, the ME is simply another poorly un-
derstood attack vector. Multiple vulnerabilities have been
1726    29th USENIX Security Symposium
USENIX Association
identiﬁed in the Intel ME in the past, including CVE-2017-
5689 [26], which can give an attacker full access to the host
system, including installing persistent malware and modi-
fying ﬁrmware. The open source project me_cleaner [12]
contains scripts for patching the ME ﬁrmware to disable it
on a wide variety of motherboards. me_cleaner, in conjunc-
tion with patching and removing parts of the UEFI BIOS that
depend on the ME, was used to disable Intel ME in certain
SuperMicro boards used in cloud data centers.
9 Conclusions
DECAF is the ﬁrst extensible modular platform capable of
automatically pruning a wide class of commercial, off-the-
shelf UEFI motherboard ﬁrmware, in some cases by over
70%, signiﬁcantly limiting attack surface areas and hardening
the resulting stack. DECAF is available freely for the research
community to use.
References
[1] GUID FAQ.
https://github.com/tianocore/
tianocore.github.io/wiki/GUID-FAQ.
[2] RFC 4122.
rfc4122.
https://tools.ietf.org/html/
[3] EDK II Project, https://github.com/tianocore/edk2, 2019.
https://github.com/tianocore/edk2.
[4] Gality - open-source implementation to compute metrics
on sets of gadgets, Nov 2019. https://github.com/
michaelbrownuc/gality.
[5] Cve results for "smm", Apr 2020. https://cve.mitre.
org/cgi-bin/cvekey.cgi?keyword=smm.
[6] Cve results for "ueﬁ", Feb 2020. https://cve.mitre.
org/cgi-bin/cvekey.cgi?keyword=uefi.
[7] Oleksandr Bazhaniuk,
John
Symbolic execution for bios
Loucaides, Lee
Rosenbaum, Mark R. Tuttle, and Vincent Zim-
mer.
security.
In 9th USENIX Workshop on Offensive Tech-
nologies
(WOOT 15), Washington, D.C., 2015.
https://www.usenix.org/conference/woot15/
workshop-program/presentation/bazhaniuk.
[8] Jethro Beekman. Reverse engineering UEFI by execu-
tion. 32nd Chaos Communication Congress, page 20,
December 2015.
[9] Anthony Bonkoski, Russ Bielawski, and J. Alex
Halderman.
Illuminating the security issues sur-
rounding lights-out server management. In Presented
as part of the 7th USENIX Workshop on Offensive
Technologies, Washington, D.C., 2013. USENIX.
https://www.usenix.org/conference/woot13/
workshop-program/presentation/Bonkoski.
[10] Michael D Brown and Santosh Pande. Pdf, Feb 2019.
[11] Yuriy Bulygin, Andrew Furtak, and Oleksandr Bazha-
niuk. A tale of one software bypass of windows 8 secure
boot. 2013.
[12] Nicola Corna. Me cleaner, Oct 2018. https://github.
com/corna/me_cleaner.
[13] Andrei Costin, Jonas Zaddach, Aurélien Francillon, and
Davide Balzarotti. A large-scale analysis of the security
In 23rd USENIX Security
of embedded ﬁrmwares.
Symposium (USENIX Security 14), pages 95–110, San
Diego, CA, 2014. USENIX Association. https://
www.usenix.org/conference/usenixsecurity14/
technical-sessions/presentation/costin.
[14] Laszlo Ersek. Open virtual machine ﬁrmware (ovmf)
status report. Technical report, Red Hat Software, July
2014.
http://www.linux-kvm.org/downloads/
lersek/ovmf-whitepaper-c770f8c.txt.
[15] Andreas Follner, Alexandre Bartel, and Eric Bodden.
Analyzing the gadgets - towards a metric to measure
gadget quality. In Proceedings of the International Sym-
posium on Engineering Secure Software and Systems,
2016.
[16] Les Hatton. Estimating source lines of code from object
code: Windows and embedded control systems, Aug
2005.
http://www.leshatton.org/Documents/
LOC2005.pdf.
[17] Kihong Heo, Woosuk Lee, Pardis Pashakhanloo, and
Mayur Naik. Effective program debloating via reinforce-
ment learning. Proceedings of the 2018 ACM SIGSAC
Conference on Computer and Communications Security
- CCS 18, 2018.
[18] Y. Jiang, Q. Bao, S. Wang, X. Liu, and D. Wu. Reddroid:
Android application redundancy customization based
on static analysis. In 2018 IEEE 29th International Sym-
posium on Software Reliability Engineering (ISSRE),
pages 189–199, Oct 2018.
[19] Corey Kallenberg, John Butterworth, Xeno Kovah, and
Sam Cornwell. Cve-2013-3582. https://cve.mitre.
org/cgi-bin/cvename.cgi?name=CVE-2013-3582.
[20] Corey Kallenberg, John Butterworth, Xeno Kovah, and
Sam Cornwell. Defeating signed bios enforcement, Jan
2014.
[21] Colin Ian King. Firmware test suite, Feb 2020. https:
//wiki.ubuntu.com/FirmwareTestSuite.
USENIX Association
29th USENIX Security Symposium    1727
[22] Anil Kurmus, Reinhard Tartler, Daniela Dorneanu, Bern-
hard Heinloth, Valentin Rothberg, Andreas Ruprecht,
Wolfgang Schröder-Preikschat, Daniel Lohmann, and
Rüdiger Kapitza. Attack surface metrics and auto-
mated compile-time OS kernel tailoring. In 20th Annual
Network and Distributed System Security Symposium,
NDSS 2013, San Diego, California, USA, February 24-
27, 2013. The Internet Society, 2013.
Intel plans
by
to
end legacy
2017.
[23] Brad Linder.
support
BIOS
https://liliputing.com/2017/11/
intel-plans-end-legacy-bios-support-2020.
html.
2020, November
[24] John Loucaides and Yuriy Bulygin. Platform Security
Assessment with CHIPSEC. CanSecWest 2014, March
2014.
[25] Steven C. MacConnell. Code complete: a practical
handbook of software construction. Microsoft Press,
2004.
[26] Maksim Malyutin.
Cve-2017-5689.
https:
//cve.mitre.org/cgi-bin/cvename.cgi?name=
CVE-2017-5689.
[27] Steve McConnell. Code Complete, Second Edition. Mi-
crosoft Press, USA, 2004.
[28] Ghassan Misherghi and Zhendong Su. HDD: hierarchi-
cal delta debugging. In Proceeding of the 28th interna-
tional conference on Software engineering - ICSE ’06,
Shanghai, China, 2006. ACM Press.
[29] Bruce Monroe, Rodrigo Rubia Branco, and Vincent Zim-
mer. Firmware is the new black – analyzing past 3 years
of bios/ueﬁ security vulnerabilities, Jul 2017.
[30] Karsten Nohl and Jakob Lell.
that
accessories
//srlabs.de/wp-content/uploads/2014/07/
SRLabs-BadUSB-BlackHat-v1.pdf.
turn evil, Jul 2014.
Badusb - on
https:
[31] Bazhaniuk Oleksandr, Bulygin Yuriy, Andrew Furtak,
Mikhail Gorobets, John Loucaides, Alex Matrosov, and
Mickey Shkatov. Attacking and Defending BIOS in
2015. RECON 2015, June 2015.
[32] Anh Quach, Aravind Prakash, and Lok Yan. Debloating
software through piece-wise compilation and loading.
In 27th USENIX Security Symposium (USENIX Secu-
rity 18), pages 869–886, Baltimore, MD, August 2018.
USENIX Association.
[33] Vaibhav Rastogi, Drew Davidson, Lorenzo De Carli,
Somesh Jha, and Patrick Mcdaniel. Cimpliﬁer: auto-
matically debloating containers. Proceedings of the
2017 11th Joint Meeting on Foundations of Software
Engineering - ESEC/FSE 2017, 2017.
[34] Ryan Roemer, Erik Buchanan, Hovav Shacham, and Ste-
fan Savage. Return-oriented programming. ACM Trans-
actions on Information and System Security, 15(1):1–34,
Mar 2012.
[35] Palsamy Sakthikumar and Vincent
J. Zimmer.
White paper: A tour beyond bios implementing
the acpi platform error interface with the uni-
Technical
ﬁed extensible ﬁrmware interface.
report, Intel Corporation, January 2013.
https:
//firmware.intel.com/sites/default/files/
resources/A_Tour_beyond_BIOS_Implementing_
APEI_with_UEFI_White_Paper.pdf.
[36] Nikolaj Schlej. Ueﬁ tool. https://github.com/
LongSoft/UEFITool.
[37] Nikolaj Schlej. Analyzing the source code of ueﬁ for
intel galileo by pvs-studio, May 2015.
[38] Nikolaj Schlej. Zero nights, Nov 2015.
[39] Spotify.
spotify/luigi, Jun 2019. https://github.
com/spotify/luigi.
[40] Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu,
and Zhendong Su. Perses: Syntax-guided program
In Proceedings of the 40th International
reduction.
Conference on Software Engineering, ICSE ’18, pages
361–371, New York, NY, USA, 2018. ACM. http:
//doi.acm.org/10.1145/3180155.3180236.
[41] Tianocore.
Pi boot phase, 2019.
https://raw.
githubusercontent.com/tianocore/tianocore.
github.io/master/images/PI_Boot_Phases.JPG.
[42] Matthew Weeks. Network Nightmare. Aug 2011.
[43] Stefan Weil. Qemu user manual.
weilnetz.de/doc/qemu-doc.html.
https://qemu.
[44] Mark Weiser. Program slicing.
In Proceedings of
the 5th International Conference on Software Engineer-
ing, ICSE ’81, pages 439–449, Piscataway, NJ, USA,
1981. IEEE Press. http://dl.acm.org/citation.
cfm?id=800078.802557.
[45] Corey Kallenberg Xeno Kovah. How Many Mil-
lion BIOSes Would you Like to Infect?, 2015.
http://legbacore.com/Research_files/
HowManyMillionBIOSesWouldYouLikeToInfect_
Whitepaper_v1.pdf.
[46] Andreas Zeller. Simplifying and Isolating Failure-
IEEE TRANSACTIONS ON SOFT-
Inducing Input.
WARE ENGINEERING, 28(2):17, 2002.
1728    29th USENIX Security Symposium
USENIX Association
Appendix: Pruning Results
Motherboard
SuperMicro A1SAi-2550F (V519)