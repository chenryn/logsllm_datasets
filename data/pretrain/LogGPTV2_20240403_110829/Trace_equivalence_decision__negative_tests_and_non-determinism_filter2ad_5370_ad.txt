constraint system (we only write the components of the constraint
systems that are modiÔ¨Åed during an application of an instance of a
rule). Since we intend to decide symbolic equivalence between two
sets of constraint systems, we will then explain how to apply these
transformation rules in such a setting (see Section 5.2).
The CONS rule simply guesses whether the top symbol of the
recipe is a constructor B. Either it is, and then we can split the
Transformation rules for satisÔ¨Åability:
CONS B   
   
:
XXXXz
 
    
   ‡¢≥   B       ‡¢≥   B     
     ‡¢≥ 6F ‡¢ß B
 
where            are fresh variables.
AXIOM    
   
If     ‡¢†  and  ‡£ô .
:
XXXXz
 ‡¢≥     ‡¢≥   
    ‡¢≥ 
‡¢ß 
 
DEST  ‡¢ê     , :
XXXXz
C             
        
   ‡¢≥    ,
If     ‡¢†  with  ‡£ò .        are fresh variables, and  are the variables that occur in C      ‡¢ê  a fresh renaming of
the rewriting rule  ‡¢ê .
 , ‡¢≥ ‡¢ò   ‡¢ß  ‡¢¥  ‡¢ß    ‡¢¥    ‡¢¥  ‡¢ß  
Additional transformation rules for static equivalence:
EQ-LEFT-LEFT     :
XXXXz
‡¢ß  
If          ‡¢†  for some      .
 ‡¢≥ 
 ‡¢≥ 
  
EQ-LEFT-RIGHT     :
XXXXz
 ‡¢≥ 
  
 ‡¢≥ 
‡¢ß  
If     ‡¢†  and    
that    .
   ‡¢†  for some       such
EQ-RIGHT-RIGHT    
   
:
XXXXz
 ‡¢≥     ‡¢≥   
   ‡¢≥ 
‡¢ß  
 
where  ‡¢†  ‡°ì @ and    with    7‡¢ê  ‡¢Ø  
  ‡¢†  ‡¢≥  ‡£ò .
DED-ST B   , :
XXXXz
 
     
   ‡¢≥   B      ,
 , ‡¢≥ ‡¢ò   ‡¢ß B      ‡¢¥  ‡¢ß   ‡¢¥    ‡¢¥  ‡¢ß  
If     ‡¢† . The sequences  @AB      , and       are sequences of fresh variables and  denotes the size of .
All rules assume that the equations have a mgu that is eagerly applied to the resulting constraint, that the disequations have been simpliÔ¨Åed.
  with  ‡¢ß‡¢†   and on which the rule CONS and AXIOM cannot be applied on it, and the rule
Moreover, if there exists a constraint  
DEST can not be applied anymore, then we replace  with .
Figure 3: Transformation rules
deducibility constraint, or it is not and we add a disequation on
recipes forbidding this. The rule AXIOM also guesses whether a
trivial recipe (a left member of the frame, typically an axiom =N )
can be applied. If so, the constraint can simply be removed. Oth-
erwise, we also add a disequation on recipes forbidding it. The
DEST rule is more tricky. If  is a term of the frame, that can be
uniÔ¨Åed with a non variable subterm of a left side of a rewrite rule
(for instance  is a ciphertext), we guess whether the rule can be
 , that yields
applied to . This corresponds to the equation 
an instance of , the right member of the rewrite rule, provided that
the rest of the left member is also deducible: in case of symmetric
  . The various equality
encryption, we get a constraint   
rules guess equalities between right-hand sides of deducibility con-
straints and/or members of the frame. Finally, the last transforma-
tion rule is the only rule that is needed to get in addition a static
equivalence decision algorithm, as in [1]. Thanks to this rule, if a
subterm of the frame is deducible, then there will be a branch in
which it is deduced.
The idea behind these rules is to transform a system into simpler
ones. Typically, as it is done in [11], we want to consider systems
in which right-hand sides of deducibility constraints are distinct
variables (assuming that the mgu corresponding to the equations
has been applied on the constraints). However, in presence of dis-
equations, putting the systems in such a form does not guarantee
anymore that the two resulting systems will be in symbolic equiva-
lence. Let us illustrate this using a simple example.
EXAMPLE 8. Consider the constraint systems
‡¢´   =N      
  ‡¢ù ‡¢ù ‡¢ù, and
‡¢´ ﬂ∞  =N      
  
‡¢ß   ‡¢ù ‡¢ù.
Although these two systems have the expected form, they are not in
symbolic equivalence (consider for instance the recipe =N  =N ).
Once the system is put in this kind of ‚Äúpre-solved form‚Äù, the
basic idea will be to continue to apply our transformation rules to
‚Äúmatch‚Äù the disequations of each constraint system. For this, we
want to transform the disequations in which some names or uni-
versally quantiÔ¨Åed variable occur until obtaining disequations that
only contain free variables and public function symbols. This will
guarantee that there exists a recipe associated to this term and this
gives us the way to match it in another constraint system. Once
the system is transformed into such a new kind of ‚Äúsolved form‚Äù,
we can now easily conclude. Indeed, since we also take care of
static equivalence on the resulting frames, disequations that corre-
spond to public disequality tests are easily transferable from one
constraint system to another without any additional checks.
EXAMPLE 9. Continuing Example 8 and assuming that the pair-
ing operator is the only constructor symbol, we will go on, applying
CONS. Let   =N    ,    
  ,
and       . One of the resulting pair will be the
pair ﬂ∞
    
 where:
‡¢´          ‡¢ù;
‡¢´ ﬂ∞
         ‡¢≥ 
‡¢ß  ‡¢¥  
‡¢ß  ‡¢ù;
Now, by applying the AXIOM rule twice, one of the resulting pair
will be the pair  ﬂ∞
  where:
‡¢´    ‡¢ù       =N  =N ‡¢ù; and
‡¢´ ﬂ∞
    since the disequations will be trivially not satisÔ¨Åed.
These two constraint systems are not in symbolic equivalence.
Now, to ensure that we will reach such a solved form in which
all the disequations are matched, the rule EQ-RIGHT-RIGHT plays
an important role.
EXAMPLE 10. Consider the two constraint systems:
‡¢´     
‡¢´ ﬂ∞   ‡¢ù‡¢ù‡¢ù
‡¢ß D ‡¢≥ 
‡¢ß ‡¢ù‡¢ù;
   
 .
where   =N     and    
equation 
‡¢ß D into ﬂ∞
We could apply CONS replacing  with Dﬂ∞ to simplify the dis-
‡¢ß . However, this operation will
‡¢ß .
transform the other disequation, namely 
Consequently, one of the resulting pair would be made up of two
systems on which the CONS rule is again applicable. Instead of
‡¢ß D does not contain any name, it
this, since the disequation 
can be matched to the other system, so we apply EQ-RIGHT-RIGHT.
This leads us to the pairs ﬂ∞
 and ﬂ∞
‡¢ß , into Dﬂ∞
  where:
‡¢´ ﬂ∞
   
    D   D ‡¢ù; and
‡¢´ ﬂ∞
     
‡¢ß D‡¢ù‡¢ù.
From the pair ﬂ∞
 we will conclude that symbolic equivalence
does not hold. Regarding the pair ﬂ∞
 , we can go on and reach
a solved form by applying EQ-RIGHT-RIGHT obtaining again two
pairs of constraint systems. The Ô¨Årst one will be of the form ﬂ∞
!
and the second one will contain two systems in which all the dise-
quations are matched.
5.2 How to apply the rules
We explain here how the transformation rules can be used on a
pair of sets of constraint systems, assuming that all the constraint
systems have the same structure. Actually, the basic idea is to ap-
ply the same transformation rule (with the same parameters) on
each constraint system. Note that, the parameters of a transforma-
tion rule only depend on the structure of the underlying constraint
system. Thanks to this, the simultaneous application of a transfor-
mation rule can be deÔ¨Åned in a natural way. It consists of applying
the same instance of the transformation rule on each constraint sys-
tem that occurs in the two sets. So an application of a rule on a
pair  ﬂ∞ of sets of constraint systems will result in two pairs
 ﬂ∞
Let  ﬂ∞ be a pair of sets of constraint systems having the
same structure. Let       , ﬂ∞  ﬂ∞
‡°Å, and R
be an instance of a transformation rule. An application of R on the
pair  ﬂ∞ yields two pairs  ﬂ∞
 and   ﬂ∞
 and   ﬂ∞
    ﬂ∞
  such that:
‡¢´        for     ; and
‡¢´ ﬂ∞
‡°Å for     .
    ﬂ∞
  ﬂ∞
where   (resp. ﬂ∞
systems obtained by applying R on  (resp. ﬂ∞
ﬂ∞ ﬂ∞
ﬂ∞).
 ﬂ∞ ) is the pair of constraint
Actually, deciding symbolic equivalence between two sets raises
two main issues:
‡¢´ matching an existing solution from one set to the other;
‡¢´ and deciding whether the two resulting frames are statically
equivalence or not.
which there is a disequation  ‡¢ß  and either  is not a name and
contains a name, or else  is not a variable and contains a univer-
sally quantiÔ¨Åed variable. There is still one difÔ¨Åculty, because, as
before, we may get a non terminating behavior.
When checking static equivalence, we have to check that the same
equalities hold in both resulting frames. So, in order to develop a
simple test on leaves, it is important to gather the two resulting sets
of constraint systems when the rule is used to check static equiv-
alence on the resulting frames. This leads us to consider matrices
of constraint systems and two kinds of applications for our rules:
internal and external. An external application will apply a rule on
the whole matrix while an internal application will apply a rule on
one particular line (the same in both matrices) replacing this line
with two new lines.
EXAMPLE 11. Consider the following example where there is
no deducibility constraint. The idea is to simply check whether
static equivalence holds between sets of frames. Let   =N  
 =N       and    =N     =N    IA? . We con-
sider the systems   ‡¢ù‡¢ù‡¢ù‡¢ù for     . Now, we want
to check whether   ‡£à  . Actually, symbolic equiva-
lence does not hold since  ‡¢ß√ü  . However, applying DEST, the