# 前言
最近在学习fastjson的相关漏洞，一直跟到了1.2.47的RCE，鉴于网上关于该版本的分析文章较为简略，这里提供相关分析过程供入门java代码审计的小伙伴学习~
# 漏洞分析
## FastJson1.2.24 RCE
在分析1.2.47的RCE之前先对FastJson1.2.24版本中的RCE进行一个简单的漏洞链分析，为在本篇文章后面1.2.47中漏洞的调用过程做个铺垫。在本文中的1.2.24的payload只研究针对类jdbcRowSetImpl的，因为针对templatesImpl的payload而言在高版本java中要开启Feature.SupportNonPublicField才能进行对非共有属性的反序列化处理，因此是存在一定的限制的。因此针对类jdbcRowSetImpl的payload更具有通用型一些。本中所示代码及jar包请见附件。
exp.java  
Exploit.class  
首先在本地用marshalsec起一个ldap服务，用rmi也可以，只需将datasourcename中的服务更改为rmi即可  
本文中环境为jdk1.8.0,首先在parse处下一个断点然后运行exp.java，本来打算正向找到setvalue函数，可是fastjson扫描json字符串的过程及反序列化时处理jdbcrowsetimpl类处处理流程过于繁琐，中间不知道得跟进多少个F7，很容易让人没有耐心继续调试分析，遂这里直接关注漏洞的核心点，即我们在setDataSourceName处下断点  
即此时将从我们payload中指定的DataSourceName中去加载工厂类  
在setautoconnect函数中调用了connect()函数，跟进后此时就能看到熟悉的lookup函数啦，我们知道jndi注入攻击中从远程加载恶意工厂类即是我们控制了lookup的入口参数，即控制了远程工厂类的加载地址，即此处即为关键点，F7步入  
此时getDataSourceName()的返回值也可以看到即为我们所指定的恶意工厂类地址  
然后跟进lookup看看如何调用实例化，这里调用了getURLOrDefaultInitCtx(name).lookup()函数  
此时就到了java的命名服务管理的类，此时调用getURLContext函数请求ldap，进一步在其中调用getURLObject来通过从远程的ldap服务获取Context对象  
最终完成exploit.class类的实例化，也就是工厂类的实例化，熟悉的getObjectInstance()，此时就完成了反序列化，从而触发exploit里的构造函数  
整个漏洞的函数调用栈如下图所示  
以下是一些针对fastjson不同版本的payload,可以看到bypass其实在@type类的前面加上L或者[,这都是因为fastjson在处理域时会将扫描到的这些字符进行去除  
## FastJson1.2.47 RCE
漏洞影响版本：`fastjson  