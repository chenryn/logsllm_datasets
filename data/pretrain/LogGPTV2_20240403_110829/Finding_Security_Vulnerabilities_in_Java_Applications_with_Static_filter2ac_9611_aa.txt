title:Finding Security Vulnerabilities in Java Applications with Static
Analysis
author:V. Benjamin Livshits and
Monica S. Lam
Finding Security Vulnerabilities in Java Applications
with Static Analysis
V. Benjamin Livshits and Monica S. Lam
Computer Science Department
Stanford University
{livshits, lam}@cs.stanford.edu
Abstract
This paper proposes a static analysis technique for
detecting many recently discovered application vulner-
abilities such as SQL injections, cross-site scripting, and
HTTP splitting attacks. These vulnerabilities stem from
unchecked input, which is widely recognized as the most
common source of security vulnerabilities in Web appli-
cations. We propose a static analysis approach based on
a scalable and precise points-to analysis. In our system,
user-provided speciﬁcations of vulnerabilities are auto-
matically translated into static analyzers. Our approach
ﬁnds all vulnerabilities matching a speciﬁcation in the
statically analyzed code. Results of our static analysis
are presented to the user for assessment in an auditing
interface integrated within Eclipse, a popular Java devel-
opment environment.
Our static analysis found 29 security vulnerabilities in
nine large, popular open-source applications, with two of
the vulnerabilities residing in widely-used Java libraries.
In fact, all but one application in our benchmark suite
had at least one vulnerability.Context sensitivity, com-
bined with improved object naming, proved instrumen-
tal in keeping the number of false positives low. Our
approach yielded very few false positives in our experi-
ments: in fact, only one of our benchmarks suffered from
false alarms.
1
Introduction
The security of Web applications has become increas-
ingly important in the last decade. More and more Web-
based enterprise applications deal with sensitive ﬁnancial
and medical data, which, if compromised, in addition to
downtime can mean millions of dollars in damages. It is
crucial to protect these applications from hacker attacks.
the current state of application security
leaves much to be desired. The 2002 Computer Crime
and Security Survey conducted by the Computer Secu-
rity Institute and the FBI revealed that, on a yearly ba-
sis, over half of all databases experience at least one se-
However,
curity breach and an average episode results in close to
$4 million in losses [10].
A recent penetration test-
ing study performed by the Imperva Application De-
fense Center included more than 250 Web applications
from e-commerce, online banking, enterprise collabo-
ration, and supply chain management sites [54]. Their
vulnerability assessment concluded that at least 92% of
Web applications are vulnerable to some form of hacker
attacks. Security compliance of application vendors is
especially important in light of recent U.S. industry reg-
ulations such as the Sarbanes-Oxley act pertaining to in-
formation security [4, 19].
A great deal of attention has been given to network-
level attacks such as port scanning, even though, about
75% of all attacks against Web servers target Web-based
applications, according to a recent survey [24].
Tra-
ditional defense strategies such as ﬁrewalls do not pro-
tect against Web application attacks, as these attacks rely
solely on HTTP trafﬁc, which is usually allowed to pass
through ﬁrewalls unhindered. Thus, attackers typically
have a direct line to Web applications.
Many projects in the past focused on guarding against
problems caused by the unsafe nature of C, such as buffer
overruns and format string vulnerabilities [12, 45, 51].
However, in recent years, Java has emerged as the lan-
guage of choice for building large complex Web-based
systems, in part because of language safety features that
disallow direct memory access and eliminate problems
such as buffer overruns. Platforms such as J2EE (Java 2
Enterprise Edition) also promoted the adoption of Java
as a language for implementing e-commerce applications
such as Web stores, banking sites, etc.
A typical Web application accepts input from the user
browser and interacts with a back-end database to serve
user requests; J2EE libraries make these common tasks
easy to code. However, despite Java language’s safety, it
is possible to make logical programming errors that lead
to vulnerabilities such as SQL injections [1, 2, 14] and
cross-site scripting attacks [7, 22, 46]. A simple pro-
USENIX Association
14th USENIX Security Symposium
271
gramming mistake can leave a Web application vulner-
able to unauthorized data access, unauthorized updates
or deletion of data, and application crashes leading to
denial-of-service attacks.
1.1 Causes of Vulnerabilities
Of all vulnerabilities identiﬁed in Web applications,
problems caused by unchecked input are recognized as
being the most common [41]. To exploit unchecked in-
put, an attacker needs to achieve two goals:
Inject malicious data into Web applications. Common
methods used include:
licious values in ﬁelds of HTML forms.
• Parameter tampering: pass specially crafted ma-
• URL manipulation: use specially crafted parame-
ters to be submitted to the Web application as part
of the URL.
• Hidden ﬁeld manipulation: set hidden ﬁelds of
• HTTP header tampering: manipulate parts of
• Cookie poisoning: place malicious data in cookies,
HTML forms in Web pages to malicious values.
HTTP requests sent to the application.
small ﬁles sent to Web-based applications.
Manipulate applications using malicious data. Com-
mon methods used include:
mands to a database server for execution.
• SQL injection: pass input containing SQL com-
• Cross-site scripting: exploit applications that out-
put unchecked input verbatim to trick the user into
executing malicious scripts.
• HTTP response splitting: exploit applications that
output input verbatim to perform Web page deface-
ments or Web cache poisoning attacks.
• Path traversal: exploit unchecked user input to
• Command injection: exploit user input to execute
control which ﬁles are accessed on the server.
shell commands.
These kinds of vulnerabilities are widespread in today’s
Web applications. A recent empirical study of vulnera-
bilities found that parameter tampering, SQL injection,
and cross-site scripting attacks account for more than a
third of all reported Web application vulnerabilities [49].
While different on the surface, all types of attacks listed
above are made possible by user input that has not been
(properly) validated. This set of problems is similar to
those handled dynamically by the taint mode in Perl [52],
even though our approach is considerably more extensi-
ble. We refer to this class of vulnerabilities as the tainted
object propagation problem.
1.2 Code Auditing for Security
Many attacks described in the previous section can
be detected with code auditing. Code reviews pinpoint
potential vulnerabilities before an application is run. In
fact, most Web application development methodologies
recommend a security assessment or review step as a sep-
arate development phase after testing and before applica-
tion deployment [40, 41].
Code reviews, while recognized as one of the most
effective defense strategies [21], are time-consuming,
costly, and are therefore performed infrequently. Secu-
rity auditing requires security expertise that most devel-
opers do not possess, so security reviews are often car-
ried out by external security consultants, thus adding to
the cost. In addition to this, because new security errors
are often introduced as old ones are corrected, double-
audits (auditing the code twice) is highly recommended.
The current situation calls for better tools that help de-
velopers avoid introducing vulnerabilities during the de-
velopment cycle.
1.3 Static Analysis
This paper proposes a tool based on a static analy-
sis for ﬁnding vulnerabilities caused by unchecked in-
put. Users of the tool can describe vulnerability pat-
terns of interest succinctly in PQL [35], which is an easy-
to-use program query language with a Java-like syntax.
Our tool, as shown in Figure 1, applies user-speciﬁed
queries to Java bytecode and ﬁnds all potential matches
statically. The results of the analysis are integrated into
Eclipse, a popular open-source Java development envi-
ronment [13], making the potential vulnerabilities easy
to examine and ﬁx as part of the development process.
The advantage of static analysis is that it can ﬁnd all
potential security violations without executing the appli-
cation. The use of bytecode-level analysis obviates the
need for the source code to be accessible. This is espe-
cially important since libraries whose source is unavail-
able are used extensively in Java applications. Our ap-
proach can be applied to other forms of bytecode such as
MSIL, thereby enabling the analysis of C# code [37].
Our tool is distinctive in that it is based on a precise
context-sensitive pointer analysis that has been shown
to scale to large applications [55]. This combination of
scalability and precision enables our analysis to ﬁnd all
vulnerabilities matching a speciﬁcation within the por-
tion of the code that is analyzed statically. In contrast,
previous practical tools are typically unsound [6, 20].
Without a precise analysis, these tools would ﬁnd too
many potential errors, so they only report a subset of er-
rors that are likely to be real problems. As a result, they
can miss important vulnerabilities in programs.
272
14th USENIX Security Symposium
USENIX Association
Figure 1: Architecture of our static analysis framework.
1.4 Contributions
A uniﬁed analysis framework. We unify multiple,
seemingly diverse, recently discovered categories of se-
curity vulnerabilities in Web applications and propose an
extensible tool for detecting these vulnerabilities using a
sound yet practical static analysis for Java.
A powerful static analysis. Our tool is the ﬁrst prac-
tical static security analysis that utilizes fully context-
sensitive pointer analysis results. We improve the state
of the art in pointer analysis by improving the object-
naming scheme. The precision of the analysis is effec-
tive in reducing the number of false positives issued by
our tool.
A simple user interface. Users of our tool can ﬁnd
a variety of vulnerabilities involving tainted objects by
specifying them using PQL [35]. Our system provides a
GUI auditing interface implemented on top of Eclipse,
thus allowing users to perform security audits quickly
during program development.
Experimental validation. We present a detailed ex-
perimental evaluation of our system and the static analy-
sis approach on a set of large, widely-used open-source
Java applications. We found a total of 29 security errors,
including two important vulnerabilities in widely-used li-
braries. Eight out of nine of our benchmark applications
had at least one vulnerability, and our analysis produced
only 12 false positives.
1.5 Paper Organization
The rest of the paper is organized as follows. Section 2
presents a detailed overview of application-level security
vulnerabilities we address. Section 3 describes our static
analysis approach. Section 4 describes improvements
that increase analysis precision and coverage. Section 5
describes the auditing environment our system provides.
Section 6 summarizes our experimental ﬁndings. Sec-
tion 7 describes related work, and Section 8 concludes.
2 Overview of Vulnerabilities
In this section we focus on a variety of security
vulnerabilities in Web applications that are caused by
unchecked input. According to an inﬂuential sur-
vey performed by the Open Web Application Security
Project [41], unvalidated input is the number one secu-
rity problem in Web applications. Many such security
vulnerabilities have recently been appearing on special-
ized vulnerability tracking sites such as SecurityFocus
and were widely publicized in the technical press [39,
41]. Recent reports include SQL injections in Oracle
products [31] and cross-site scripting vulnerabilities in
Mozilla Firefox [30].
2.1 SQL Injection Example
Let us start with a discussion of SQL injections, one
of the most well-known kinds of security vulnerabilities
found in Web applications. SQL injections are caused
by unchecked user input being passed to a back-end
database for execution [1, 2, 14, 29, 32, 47]. The hacker
may embed SQL commands into the data he sends to the
application, leading to unintended actions performed on
the back-end database. When exploited, a SQL injection
may cause unauthorized access to sensitive data, updates
or deletions from the database, and even shell command
execution.
Example 1. A simple example of a SQL injection is
shown below:
HttpServletRequest request = ...;
String userName = request.getParameter("name");
Connection con
String query
= ...
= "SELECT * FROM Users " +
" WHERE name = ’" + userName + "’";
con.execute(query);
This code snippet obtains a user name (userName) by in-
voking request.getParameter("name") and uses it to
construct a query to be passed to a database for execution
(con.execute(query)). This seemingly innocent piece
of code may allow an attacker to gain access to unautho-
rized information: if an attacker has full control of string
userName obtained from an HTTP request, he can for
example set it to ’OR 1 = 1;−−. Two dashes are used
to indicate comments in the Oracle dialect of SQL, so the
WHERE clause of the query effectively becomes the tau-
tology name = ’’ OR 1 = 1. This allows the attacker
to circumvent the name check and get access to all user
records in the database. 2
SQL injection is but one of the vulnerabilities that
can be formulated as tainted object propagation prob-
lems. In this case, the input variable userName is con-
sidered tainted.
If a tainted object (the source or any
other object derived from it) is passed as a parameter to
USENIX Association
14th USENIX Security Symposium
273
con.execute (the sink), then there is a vulnerability. As
discussed above, such an attack typically consists of two
parts: (1) injecting malicious data into the application
and (2) using the data to manipulating the application.
The former corresponds to the sources of a tainted object
propagation problem and the latter to the sinks. The rest
of this section presents attack techniques and examples
of how exploits may be created in practice.
2.2
Injecting Malicious Data
Protecting Web applications against unchecked input
vulnerabilities is difﬁcult because applications can obtain
information from the user in a variety of different ways.
One must check all sources of user-controlled data such
as form parameters, HTTP headers, and cookie values
systematically. While commonly used, client-side ﬁlter-
ing of malicious values is not an effective defense strat-
egy. For example, a banking application may present the
user with a form containing a choice of only two account
numbers; however, this restriction can be easily circum-
vented by saving the HTML page, editing the values in
the list, and resubmitting the form. Therefore, inputs
must be ﬁltered by the Web application on the server.
Note that many attacks are relatively easy to mount: an
attacker needs little more than a standard Web browser
to attack Web applications in most cases.
2.2.1 Parameter Tampering
The most common way for a Web application to accept
parameters is through HTML forms. When a form is sub-
mitted, parameters are sent as part of an HTTP request.
An attacker can easily tamper with parameters passed to
a Web application by entering maliciously crafted values
into text ﬁelds of HTML forms.
2.2.2 URL Tampering
For HTML forms that are submitted using the HTTP
GET method, form parameters as well as their values ap-
pear as part of the URL that is accessed after the form is
submitted. An attacker may directly edit the URL string,
embed malicious data in it, and then access this new URL
to submit malicious data to the application.
Example 2. Consider a Web page at a bank site that al-
lows an authenticated user to select one of her accounts
from a list and debit $100 from the account. When the
submit button is pressed in the Web browser, the follow-
ing URL is requested:
http://www.mybank.com/myaccount?
accountnumber=341948&debit_amount=100
However, if no additional precautions are taken by the
Web application receiving this request, accessing
http://www.mybank.com/myaccount?
accountnumber=341948&debit_amount=-5000
may in fact increase the account balance. 2
2.2.3 Hidden Field Manipulation
Because HTTP is stateless, many Web applications
use hidden ﬁelds to emulate persistence. Hidden ﬁelds
are just form ﬁelds made invisible to the end-user. For
example, consider an order form that includes a hidden
ﬁeld to store the price of items in the shopping cart:
A typical Web site using multiple forms, such as an on-
line store will likely rely on hidden ﬁelds to transfer state
information between pages. Unlike regular ﬁelds, hid-
den ﬁelds cannot be modiﬁed directly by typing values
into an HTML form. However, since the hidden ﬁeld is
part of the page source, saving the HTML page, editing
the hidden ﬁeld value, and reloading the page will cause
the Web application to receive the newly updated value
of the hidden ﬁeld.
2.2.4 HTTP Header Manipulation
HTTP headers typically remain invisible to the user
and are used only by the browser and the Web server.
However, some Web applications do process these head-
ers, and attackers can inject malicious data into applica-
tions through them. While a normal Web browser will
not allow forging the outgoing headers, multiple freely
available tools allow a hacker to craft an HTTP request
leading to an exploit [9]. Consider, for example, the
Referer ﬁeld, which contains the URL indicating where
the request comes from. This ﬁeld is commonly trusted
by the Web application, but can be easily forged by an
attacker. It is possible to manipulate the Referer ﬁeld’s
value used in an error page or for redirection to mount
cross-site scripting or HTTP response splitting attacks.
2.2.5 Cookie Poisoning
Cookie poisoning attacks consist of modifying a
cookie, which is a small ﬁle accessible to Web applica-
tions stored on the user’s computer [27]. Many Web ap-
plications use cookies to store information such as user
login/password pairs and user identiﬁers. This informa-
tion is often created and stored on the user’s computer af-
ter the initial interaction with the Web application, such
as visiting the application login page. Cookie poison-
ing is a variation of header manipulation: malicious in-
put can be passed into applications through values stored
within cookies. Because cookies are supposedly invisi-
ble to the user, cookie poisoning is often more dangerous
in practice than other forms of parameter or header ma-
nipulation attacks.
2.2.6 Non-Web Input Sources
Malicious data can also be passed in as command-
line parameters. This problem is not as important be-
cause typically only administrators are allowed to ex-
ecute components of Web-based applications directly
274
14th USENIX Security Symposium
USENIX Association
from the command line. However, by examining our
benchmarks, we discovered that command-line utilities
are often used to perform critical tasks such as initializ-
ing, cleaning, or validating a back-end database or mi-
grating the data. Therefore, attacks against these impor-
tant utilities can still be dangerous.
2.3 Exploiting Unchecked Input
Once malicious data is injected into an application, an
attacker may use one of many techniques to take advan-
tage of this data, as described below.
2.3.1 SQL Injections
SQL injections ﬁrst described in Section 2.1 are
caused by unchecked user input being passed to a back-
end database for execution. When exploited, a SQL in-
jection may cause a variety of consequences from leak-
ing the structure of the back-end database to adding new
users, mailing passwords to the hacker, or even executing
arbitrary shell commands.
Many SQL injections can be avoided relatively eas-
J2EE provides the
ily with the use of better APIs.
PreparedStatement class,
that allows specifying a
SQL statement template with ?’s indicating statement pa-
rameters. Prepared SQL statements are precompiled, and
expanded parameters never become part of executable
SQL. However, not using or improperly using prepared