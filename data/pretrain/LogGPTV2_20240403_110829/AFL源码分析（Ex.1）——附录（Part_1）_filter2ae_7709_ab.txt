`native LLVM`检测工具可以使用接受`2.1`中讨论的环境变量，但以下变量除外：
  * `AFL_AS`：因为`afl-clang-fast`不直接调用`GNU as`。
  * `TMPDIR`、`AFL_KEEP_ASSEMBLY`：因为`afl-clang-fast`没有创建临时程序集文件。
请注意， `AFL_INST_RATIO`这个环境变量的效果与`afl-gcc`的行为略有不同，因为函数本来就不是无条件地被检测，因此此环境变量被设置为低值将产生更显着的效果。对于此工具，`0`不是有效选择。
### 2.3. `afl-fuzz`相关的设置
这个工具接受多个环境变量，这些变量将禁用一些完整性检查或更改该工具的一些奇特的语义：
  * `AFL_SKIP_CPUFREQ`：此环境变量被设置会跳过`CPU`扩展策略的检查。如果您无法更改其策略的默认值(例如，没有对系统的`root`访问权限)并且可以承受一些性能损失，这将非常有用。
  * `AFL_NO_FORKSRV`：此环境变量被设置会禁用`forkserver`优化，此优化将在为每个输入样本进行`fork + execve()`调用。这在使用不守规矩的库时非常有用，这些库在初始化时创建线程或做其他疯狂的事情(在`fuzzer`运行之前）。请注意，此设置会禁止在启动`forkserver`时通常会进行的一些用户友好的诊断，并导致相当显着的性能下降。
  * `AFL_EXIT_WHEN_DONE`：此环境变量被设置会导致`afl-fuzz`在所有现有路径都被模糊化并且一段时间内没有新发现时终止。这通常由`UI`中的循环计数器是否变为绿色来指示。此变量对于某些类型的自动化作业可能很方便。
  * `AFL_NO_AFFINITY`：此环境变量被设置会禁止实例尝试绑定到`Linux`系统上的特定`CPU 内核`。这会减慢速度，但可以让您运行更多的`afl-fuzz`实例(如果您真的想要这么做的话)。
  * `AFL_SKIP_CRASHES`：此环境变量被设置会导致`AFL`忽略输入队列中导致程序崩溃的文件。这可以帮助解决程序仅间歇性崩溃的罕见情况，但在正常操作条件下并不真正推荐这样做。
  * `AFL_HANG_TMOUT`：此环境变量允许您指定超时时间用以确定特定测试用例是否“挂起”。默认值为`1`秒或`-t`参数的值，以较大者为准。如果您非常担心缓慢的输入，或者如果您不希望`AFL`花费太多时间对这些输入进行分类，而只是快速地将所有超时输入该测试目标中，则将值调低可能会很有用。
  * `AFL_NO_ARITH`：此环境变量被设置会导致`AFL`跳过大多数确定性算术过程。这对于加速基于文件格式为文本的模糊测试很有用。
  * `AFL_SHUFFLE_QUEUE`：此环境变量被设置会导致`AFL`在启动时随机重新排序输入队列。一些用户要求进行非正统的并行模糊测试设置，但不建议这样做。
  * `AFL_SKIP_BIN_CHECK`：在基于`afl-fuzz`开发自定义检测工具时，您可以使用此环境变量来禁止对非检测二进制文件和 shell 脚本的检查.此选项和`AFL_DUMB_FORKSRV`与`-n`一起设置时，`afl-fuzz` 仍然遵循`forkserver`协议，而不期望任何检测数据返回。
  * `AFL_IMPORT_FIRST`：在`-M`或`-S`模式下运行时，设置此环境变量会导致`fuzzer`在执行任何其他操作之前从其他实例导入测试用例。这使得实时反馈中的`own finds`计数器更加准确。除了反美学之外，没有什么改变。
  * `AFL_POST_LIBRARY`：设置此环境变量允许您为变异文件配置后处理器。例如，修复校验和。有关更多信息，请参阅`experimental/post_library/`。
  * `AFL_FAST_CAL`：设置此环境变量将导致校准阶段加速并保持大约`2.5`倍的速度(尽管此时精度较低)，这在针对慢速目标开始检测时会有所帮助。
  * `AFL_NO_CPU_RED`：屏幕底部显示的`CPU`小部件相当简单，可能会过早地警告您的设备处于高负载模式，尤其是在内核数量较少的系统上。设置此环境变量将使其不再显示为令人紧张的红色。
  * `AFL_PATH`：在`QEMU`模式(`-Q`)中，将在此环境变量中搜索`afl-qemu-trace`。
  * `AFL_PRELOAD`：此环境变量被设置会导致`AFL`为目标二进制文件设置`LD_PRELOAD`而不会中断`afl-fuzz`进程本身。这对于引导 `libdislocator.so`非常有用。
  * `AFL_PRELOAD`：此环境变量被设置会导致`AFL`的`GUI`被禁用，终端中只是定期打印一些基本统计信息。当`afl-fuzz`的输出被重定向到文件或管道时，也会自动触发此行为。
  * `AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES`：如果您是`Jakub`，您可能需要设置此环境变量，其他用户无需设置。
  * `AFL_BENCH_JUST_ONE`：仅基准测试，此环境变量被设置会导致`AFL`在处理第一个队列条目后退出。
  * `AFL_BENCH_UNTIL_CRASH`：仅基准测试，此环境变量被设置会导致`AFL`在发现第一次崩溃后很快退出。
### 2.4. `afl-qemu-trace`相关的设置
用于检测纯二进制文件的`QEMU`包装器支持多种环境变量：
  * `AFL_INST_RATIO`：此环境变量被设置将跳过一些基本块上的检测，这在处理非常复杂的二进制文件时很有用。
  * `AFL_INST_LIBS`：此环境变量被设置将会导致转译器也检测任何动态链接库(特别是包括`glibc`)中的代码。
  * 底层`QEMU`二进制文件将识别任何标准的用户空间模拟变量(例如，`QEMU_STACK_SIZE`)。
### 2.5. `afl-cmin`相关的设置
语料库最小化攻击提供很少的可定制性：
  * `AFL_PATH`：此环境变量用于指定`afl-showmap`和`afl-qemu-trace`位置(后者仅在`-Q`模式下)。
  * `AFL_KEEP_TRACES`：此环境变量被设置将会导致该工具保留用于最小化并通常在退出时删除的跟踪数据和其他元数据。这些文件可以在`/.traces/*`中找到。
  * `AFL_ALLOW_TMP`：此环境变量被设置将会导致该工具允许此脚本和其他一些脚本在`/tmp`中运行。这对于具有流氓用户的多用户系统来说是一个适度的安全风险，但在专用的模糊测试机器上应该是安全的。
### 2.6. `afl-tmin`相关的设置
此工具几乎没有什么可设置的。
  * `AFL_PATH`：在`QEMU`模式(`-Q`)中，将在此环境变量中搜索`afl-qemu-trace`。
  * `TMPDIR`：如果无法在当前工作目录中创建临时文件，则可以使用此环境变量。
  * `AFL_TMIN_EXACT`：如果您希望`afl-tmin`在最小化崩溃文件时要求执行路径匹配，您可以指定此环境变量。这将使最小化的效率大幅减低，但可能会阻止工具在非常有缺陷的软件中从一个崩溃条件“跳”到另一个崩溃条件。您可能希望将它与`-e`标志结合使用。
### 2.7. `afl-analyze`相关的设置
  * `AFL_ANALYZE_HEX`：您可以设置此环境变量以将获取的文件偏移量以十六进制而不是十进制的方式打印。
### 2.8. `libdislocator.so`相关的设置
此库文件有四个环境变量可被设置：
  * `AFL_LD_LIMIT_MB`：此环境变量指定定了库允许的最大堆空间使用的大小，以兆字节为单位。默认值为`1 GB`。一旦超过，分配将返回`NULL`。
  * `AFL_LD_HARD_FAIL`：此环境变量通过在过度分配时调用`abort()`来改变内存分配行为，从而导致`AFL`认为是崩溃。这对于应该保持特定内存占用的程序很有用。
  * `AFL_LD_VERBOSE`：此环境变量使库输出一些诊断消息，这些消息可能有助于查明任何观察到的问题的原因。
  * `AFL_LD_NO_CALLOC_OVER`：此环境变量在`calloc()`溢出时禁止`abort()`调用。大多数常见的分配器会在内部进行检查并返回 `NULL`，因此只有在更奇特的设置中才会存在安全风险。
### 2.9. `afl-fuzz`等工具主动设置的变量
afl-fuzz 不直接解析以下几个变量，但如果环境中尚不存在，则将其设置为最佳值：
  * 默认情况下，`LD_BIND_NOW`将被设置，这是为了通过强制链接器在`fork`服务器启动之前完成所有工作来加速模糊测试。您可以通过预先设置`LD_BIND_LAZY`来覆盖它，但这几乎可以肯定是毫无意义的。
  * 默认情况下，`ASAN_OPTIONS`设置为： 
        abort_on_error=1
    detect_leaks=0
    symbolize=0
    allocator_may_return_null=1
如果您想设置自己的选项，请确保包含`abort_on_error=1`。否则，模糊器将无法检测到测试目标中的崩溃动作。类似地，请确保包含`symbolize=0`，因为没有它，`AFL`可能难以分辨崩溃和挂起。
  * 默认情况下，`MSAN_OPTIONS`设置为： 
        exit_code=86 (出于遗留原因必须设置)    
    abort_on_error=1
    symbolize=0
    msan_track_origins=0
    allocator_may_return_null=1
在自定义任何内容时务必包括第一个，因为某些`MSAN`版本不会在出错时调用`abort()`，我们需要一种检测故障的方法。