手册里解释说 10 和 20 是行号。它们为计算机排序了语句。它们也允许程序员在某些命令中引用程序的其它行，正像你在这里使用的 `GOTO` 命令一样，它将程序指回到行 10。“这是一个很好的编程习惯”，手册认为，“以 10 的增量来编号行，可以防止你以后需要插入一些语句”。
你输入 `RUN`，并凝视充满了 “COMMODORE 64” 的屏幕，它一遍又一遍的重复。
![Commodore 64 显示反复打印 "Commodore 64" 的结果](/data/attachment/album/201907/12/125818twwb7dtssws6wdox.png)
你不确定这不会引爆你的计算机，过了一秒钟你才想起来应该单击 `RUN/STOP` 按键来打断循环。
手册接下来的一些部分向你介绍了变量，它告诉你变量像“在计算机中许多的盒子，它们每个可以容纳一个数字或一个文本字符串”。以一个 `%` 符号结尾的变量是一个整数，与此同时，以一个 `$` 符号结尾的变量是一个字符串。其余的所有变量是一些称为“浮点”变量的东西。手册警告你要小心变量名称，因为计算机仅会识别变量名称的前两个字母，尽管它不限制你想创建的名称有多长。（这并没有特别让你困扰，但是要是在 30 年后来看，这可能会让人们感到太疯狂了）
你接着学习 `IF... THEN...` 和 `FOR... NEXT...` 结构体。有了这些新的工具，你感觉有能力来解决接下来手册丢给你的重大挑战。“如果你是个有野心的人”，没错，“输入下面的程序，并查看会发生什么。”该程序比你目前为止看到的程序更长、更复杂，但是，你很想知道它做了什么：
```
10  REM BOUNCING BALL
20  PRINT "{CLR/HOME}"
25  FOR X = 1 TO 10 : PRINT "{CRSR/DOWN}" : NEXT
30  FOR BL = 1 TO 40
40  PRINT " ●{CRSR LEFT}";:REM (● is a Shift-Q)
50  FOR TM = 1 TO 5
60  NEXT TM
70  NEXT BL
75  REM MOVE BALL RIGHT TO LEFT
80  FOR BL = 40 TO 1 STEP -1
90  PRINT " {CRSR LEFT}{CRSR LEFT}●{CRSR LEFT}";
100 FOR TM = 1 TO 5
110 NEXT TM
120 NEXT BL
130 GOTO 20
```
上面的程序充分利用了 Commodore 64 最酷的功能之一。当把不可打印的命令字符作为字符串的一部分传递到 `PRINT` 命令时，它们会执行其操作，而不是被打印到屏幕上。这允许你重新摆放你程序中打印的字符串。（LCTT 译注：上述程序中如 `{CRSR LEFT}` 之类的控制字符执行类似 “在行中向左移动一个位置” 的操作，因此上述程序中利用这些字符操作了一个圆点字符四处移动，如下图。）
输入上面的程序你花费了很长时间。你犯一些错误，并不得不重新输入一些行。但是，你最终能够按下 `RUN`，并看到了一幅杰作：
![Commodore 64 反弹球](/data/attachment/album/201907/12/125819fjxyaojv3r38r82j.gif)
你觉得这恐怕是你见过的最酷的事了。不过你几乎转头就忘记了它，因为马上你就学到了 BASIC 的内置函数，像 `RND`（它返回一个随机数字）和 `CHR$`（它返回与一个给定数字代码匹配的字符），这个手册向你展示一个程序，这个程序有名到什么程度呢？直到许多年后，它仍然被当成了一个[短文选集](http://10print.org/)的标题：
```
10 PRINT "{CLR/HOME}"
20 PRINT CHR$(205.5 + RND(1));
40 GOTO 20
```
当运行时，上面的程序会生成一个随机的迷宫：
![Commodore 64 迷宫程序](/data/attachment/album/201907/12/125822gg7hc2l2140si531.gif)
这绝对是你曾经见过最酷的事。
### PEEK 和 POKE
现在你已经看过了 Commodore 64 手册的前四章节，包含那篇 “高级的 BASIC” 的章节，所以你感到十分自豪。在这个星期六早上，你学习到了很多东西。但是这个下午（在赶快吃了点午饭后），你将继续学习一些使这个放在你的客厅中的奇妙机器变得不再神秘的东西。
手册中的下一个章节标题是“高级颜色和图像命令”。它从回顾你今天早上首先键入的彩色条开始，并向你展示了如何在一个程序中做同样的事。然后它教给了你如何更改屏幕的背景颜色。
为此，你需要使用 BASIC 的 `PEEK` 和 `POKE` 命令。这些命令分别允许你检查和写入一个存储器地址。Commodore 64 有一个主背景颜色和一个边框背景颜色。每个都通过一个特定的内存地址控制。你可以把你喜欢的任何颜色值写入到这些地址，以使用这些背景颜色和边框颜色。
手册中解释：
> 
> 正像变量可以被认为机器中你放置信息的“盒子”一样，你也可以认为在计算机中代表特定内存位置的是一些特殊定义的“盒子”。
> 
> 
> Commodore 64 会查看这些内存位置来了解屏幕的背景和边框应该是什么样的颜色，什么样的字符应该被显示在屏幕上，以及显示在哪里，等等其它任务。
> 
> 
> 
你编写了一个程序来遍历所有可用的背景和边界的颜色的组合：
```
10 FOR BA = 0 TO 15
20 FOR BO = 0 TO 15
30 POKE 53280, BA
40 POKE 53281, BO
50 FOR X = 1 TO 500 : NEXT X
60 NEXT BO : NEXT BA
```
虽然 `POKE` 命令以及它的大操作数一开始时看起来很吓人，现在你看到那个数字的实际值其实不是很要紧。显然，你必须得到正确的数字，但是所有的数字代表的是一个“盒子”，Commodore 只是正好存储在地址 53280 处而已。这个盒子有一个特殊的用途：Commodore 使用它来确定屏幕背景应该是什么颜色。
![Commodore 64 更改背景颜色](/data/attachment/album/201907/12/125823yqddscktfks525bt.gif)
你认为这简直棒极了。只需要写入到内存中一个专用的盒子，你可以控制一台计算机的基础属性。你不确定 Commodore 64 的电路系统如何读取你写入在内存中的值并更改屏幕的颜色的，但是，你不知道这些也没事。至少你知道结果是怎么样的。
### 特殊容器
在那个周六，你没有读完整本手册，因为你现在有点精疲力尽了。但是你最终会全部读完它。在这个过程中，你学到更多的 Commodore 64 专用的盒子。有一些盒子你可以写入来控制在屏幕上显示什么——这也是一个盒子，事实上，是控制每一个位置出现的字符。在第六章节 “精灵图形” 中，你学到可以让你定义可以移动和甚至缩放图像的特殊盒子。在第七章节 “创造声音” 中，你学到能写入以便使你的 Commodore 64 歌唱 “Michael Row the Boat Ashore” 的盒子。Commodore 64，事实证明，它和你可能以后学习到的一个称为 API 的关系甚少。控制 Commodore 64 大多涉及写入到电路系统赋予特殊意义的内存地址。
多年来，你花费在这些特殊盒子的时光一直伴随着你。甚至几十年后，当你在一个拥有大量的图形或声音 API 的机器上编程时，你知道，隐藏于其背后的，这些 API 最终是写入到这些盒子之类的东西里面的。你有时会好奇那些只使用过 API 的年轻程序员，他们肯定是觉得 API 为他们做到的这一切。可能他们认为这些 API 调用了一些其它隐藏的 API。但是，那些隐藏的 API 调用了什么？你不由得同情这些年轻的程序员们，因为他们一定会非常迷惑。
如果你喜欢这篇文章，也喜欢它每两周发布的一篇新文章的话，那么请在 Twitter 上关注 [@TwoBitHistory](https://twitter.com/TwoBitHistory) 或订阅 [RSS 源](https://twobithistory.org/feed.xml)来确保你知道新的文章发布出来。
---
via：
作者：[Two-Bit History](https://twobithistory.org) 选题：[lujun9972](https://github.com/lujun9972) 译者：[robsean](https://github.com/robsean) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出