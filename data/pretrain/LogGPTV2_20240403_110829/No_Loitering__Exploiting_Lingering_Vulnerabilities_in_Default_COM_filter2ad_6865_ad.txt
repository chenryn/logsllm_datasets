relying on the COM infrastructure and the system as a
whole. Moreover, because the average Windows instal-
lation can have hundreds of known ﬂawed controls reg-
istered, COM provides attackers with an extremely wide
range of vulnerable surfaces through which to compro-
mise a system. We have demonstrated that each of the
per-application security policies for several popular ap-
plications can be bypassed – each allowing for the in-
stantiation of any of the hundreds of known ﬂawed con-
trols. In response, we have developed and characterized
the reference monitor-like COMBlocker, which inter-
poses itself on all COM instantiations to ensure that such
operations conform to a global policy. In so doing, we
have signiﬁcantly improved the resistance of the COM
architecture and applications relying upon it to transitive
trust-based exploits.
Acknowledgments
We would like to thank Ryan Smith for his contri-
butions to the research presented in this paper. Addi-
tionally, we thank Reiner Sailer and William Enck for
their help in providing early reviews of this work. This
publication represents the views of the authors and does
not necessarily represent IBM’s positions, strategies, or
opinions.
References
[1] V. Anupam and A. Mayer. Security of Web Browser
Scripting Languages: Vulnerabilities, Attacks, and
Remedies. In Proceedings of the USENIX Security Sym-
posium (SECURITY), 1998.
[2] L. Bauer, J. Ligatti, and D. Walker. Composing security
policies with polymer. In ACM Conference on Program-
ming Language Design and Implementation, June 2005.
[3] H. Chen and D. Wagner. MOPS: An Infrastructure for
Examining Security Properties of Software. In Proceed-
ings of the ACM Conference on Computer and Commu-
nications Security (CCS), 2002.
[4] M. Dowd, R. Smith, and D. Dewey.
Proceedings
Interoperability.
2009,
ing
Hat
blackhat.com/bh-usa-09/video/DOWD/
BHUSA09-Dowd-AtkInterop-VIDEO.mov.
Attack-
of Black
https://media.
[5] U. Erlingsson. The Inlined Reference Monitor Approach
to Security Policy Enforcement. PhD thesis, Cornell Uni-
versity, January 2004.
2009.
July
[6] D. Evans and A. Twyman. Flexible policy-directed code
safety. In Proceedings of the IEEE Symposium on Secu-
rity and Privacy (OAKLAND), May 1999.
[7] T. Fraser, N. L. Petroni, and W. A. Arbaugh. Apply-
ing Flow-Sensitive CQUAL to verify MINIX Authoriza-
tion Check Placement. In Proceedings of the Workshop
on Programming Languages and Analysis for Security,
2006.
[8] V. Ganapathy, T. Jaeger, and S. Jha. Automatic Place-
ment of Authorization Hooks in the Linux Security
the ACM
Modules Framework.
Conference on Computer and Communications Security
(CCS), 2005.
In Proceedings of
[9] V. Ganapathy, T. Jaeger, and S. Jha. Retroﬁtting legacy
code for authorization policy enforcement. In Proceed-
ings of the IEEE Symposium on Security and Privacy
(OAKLAND), 2006.
[10] V. Ganapathy, D. King, T. Jaeger, and S. Jha. Min-
ing Security-Sensitive Operations in Legacy Code Us-
ing Concept Analysis. In Proceedings of the Internation
Conference on Software Engineering (ICSE), 2007.
[11] G. Hunt and D. Brubacher. Detours: binary intercep-
tion of win32 functions. In WINSYM’99: Proceedings
of the 3rd conference on USENIX Windows NT Sympo-
sium, pages 14–14, Berkeley, CA, USA, 1999. USENIX
Association.
[12] N. Islam, R. Anand, T. Jaeger, and J. R. Rao. A ﬂexible
IEEE Soft-
security system for using internet content.
ware, 14:52–59, 1997.
[13] T. Jaeger, A. Edwards, and X. Zhang. Consistency Anal-
ysis of Authorization Hook Placement in the Linux Se-
curity Modules Framework. ACM Transactions on In-
formation and System Security (TISSEC), 7(2), 2004.
[14] T. Jaeger, A. D. Rubin, and A. Prakash. Building sys-
tems that ﬂexibly control downloaded executable con-
text. In Proceedings of the USENIX Security Symposium
(SECURITY), 1996.
[15] P. A. Loscocco, S. D. Smalley, P. A. Muckelbauer, and
R. C. Taylor. The inevitability of failure: The ﬂawed
assumption of security in modern computing environ-
ments. In Proceedings of the National Information Sys-
tems Security Conference, 1998.
[16] D. Malkhi and M. Reiter. Secure Execution of Java Ap-
IEEE Transactions
plets Using a Remote Playground.
on Software Engineering, 27(12):1197–1209, 2000.
[17] Microsoft.
Safe Initialization and Scripting for
ActiveX Controls. Microsoft Developer Network.
http://msdn.microsoft.com/en-us/
library/aa751977(VS.85).aspx.
[18] Microsoft. Working with the AppInitDLLs registry
value. Microsoft Support, November 2006. http:
//support.microsoft.com/kb/197571.
Security
Microsoft
Advisory
Microsoft TechNet, August 2008.
[19] Microsoft.
(953839).
http://www.microsoft.com/technet/
security/advisory/953839.mspx.
Security
[20] Microsoft.
(956391).
http://www.microsoft.com/technet/
security/advisory/956391.mspx.
Advisory
Microsoft TechNet, October 2008.
Microsoft
[21] Microsoft. How to stop an ActiveX control from run-
ning in Internet Explorer. Microsoft Support Center, Au-
gust 2009. http://support.microsoft.com/
kb/240797.
Security
Microsoft
Advisory
Microsoft TechNet, February 2009.
[22] Microsoft.
(960715).
http://www.microsoft.com/technet/
security/advisory/960715.mspx.
Security
[23] Microsoft.
(969898).
http://www.microsoft.com/technet/
security/advisory/969898.mspx.
Microsoft TechNet,
Advisory
2009.
Microsoft
June
[24] Microsoft.
Microsoft Security Bulletin MS09-
032.
http:
//www.microsoft.com/technet/security/
bulletin/ms09-032.mspx.
Microsoft TechNet,
July 2009.
[25] Microsoft. Microsoft Security Bulletin (MS09-034).
http://www.microsoft.com/technet/
security/bulletin/ms09-034.mspx,
2009.
July
[26] Microsoft Support. You are prompted to grant permis-
sion for ActiveX Controls when you open an Ofﬁce XP
or Ofﬁce 2003 document. Microsoft Support Center, Oc-
tober 2007. http://support.microsoft.com/
default.aspx?scid=kb;en-us;827742.
[27] G. C. Necula, S. McPeak, and W. Weimer. CCured:
Type-safe Retroﬁtting of Legacy Code. In Proceedings
of the ACM SIGPLAN-SIGACT Symposium on Princi-
ples of Programming Languages, 2002.
[28] N. Thompson. MFC/COM Objects 1: Creating a
Simple Object. Microsoft Developer Network, March
1995. http://msdn.microsoft.com/en-us/
library/ms809986.aspx.
[29] J. Yang, T. Kremenek, Y. Xie, and D. Engler. MECA: An
Extensible, Expressive System and Language for Stati-
In Proceedings of
cally Checking Security Properties.
the ACM Conference on Computer and Communications
Security, 2003.
[30] X. Zhang, A. Edwards, and T. Jaeger. Using CQUAL
for Static Analysis of Authorization Hook Placement.
In Proceedings of the USENIX Security Symposium (SE-
CURITY), 2002.
8 Appendix A
The following source code represents the CComVariant::ReadFromStream() method as distributed with ATL ver-
sion 6.0. This is the method that allows a developer to read a variant from a COM persistence stream. The key piece
is the call to OleLoadFromStream() (line 23) which is detailed in Appendix B:
return hr;
if (hr == S_FALSE)
hr = E_FAIL;
if (FAILED(hr))
return hr;
VARTYPE vtRead;
hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
ATLASSERT(pStream != NULL);
HRESULT hr;
hr = VariantClear(this);
if (FAILED(hr))
1 inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
2{
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
vt = vtRead;
int cbRead = 0;
switch (vtRead)
{
case VT_UNKNOWN:
case VT_DISPATCH:
punkVal = NULL;
hr = OleLoadFromStream(pStream,
(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
(void**)&punkVal);
if (hr == REGDB_E_CLASSNOTREG)
hr = S_OK;
return S_OK;
{
}
9 Appendix B
The following code was derived by ﬁrst disassembling Ole32.dll with IDA Pro. From there, the disassembly was
manually converted to the C/C++ equivalent shown below. This code shows that this method will read a CLSID from
a persistence stream and instantiate that object with a call to CoCreateInstance() (line 23). It should be noted that at
no time is there a check against a security policy before the object is loaded:
1 HRESULT OleLoadFromStream(LPSTREAM pStm,const IID *const iidInterface,
LPVOID *ppvObj)
2{
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44}
CLSID pclsid;
IID *riid;
HANDLE *ppvObj;
HANDLE *ppvStmObj;
HRESULT hr;
riid = iidInterface;
if (*ppvObj == 0)
return E_INVALIDARG;
. . .
if (!isValidInterface(pStm))
return E_INVALIDARG;
hr = ReadClassStm(pStm, &pclsid);
if (hr)
return hr;
hr = CoCreateInstance(pclsid, NULL, CLSCTX_NO_CODE_DOWNLOAD|
CLSCTX_REMOVE_SERVER|CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,
riid, ppvObj);
if (hr)
return hr;
hr = ppvObj->QueryInterface(IID_IPersistStream, ppvStmObj);
if (hr) {
ppvObj->Release();
return hr;
}
hr = ppvStmObj->Load(pStm);
ppvObj->Release();
if (hr) {
ppvObj->Release();
return hr;
}
. . .
return hr;