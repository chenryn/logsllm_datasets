### Relying on the COM Infrastructure and System as a Whole

The reliance on the COM (Component Object Model) infrastructure and the system as a whole introduces significant security risks. An average Windows installation can have hundreds of known flawed controls registered, providing attackers with a wide range of vulnerable surfaces to exploit. Our research has demonstrated that the per-application security policies for several popular applications can be bypassed, allowing the instantiation of any of these flawed controls.

In response to this, we have developed and characterized COMBlocker, a reference monitor-like solution. COMBlocker interposes itself on all COM instantiations to ensure that such operations conform to a global policy. This significantly improves the resistance of the COM architecture and the applications that rely on it against transitive trust-based exploits.

### Acknowledgments

We would like to thank Ryan Smith for his contributions to the research presented in this paper. Additionally, we extend our gratitude to Reiner Sailer and William Enck for their early reviews of this work. The views expressed in this publication are those of the authors and do not necessarily represent IBM’s positions, strategies, or opinions.

### References

1. V. Anupam and A. Mayer. "Security of Web Browser Scripting Languages: Vulnerabilities, Attacks, and Remedies." In Proceedings of the USENIX Security Symposium (SECURITY), 1998.
2. L. Bauer, J. Ligatti, and D. Walker. "Composing Security Policies with Polymer." In ACM Conference on Programming Language Design and Implementation, June 2005.
3. H. Chen and D. Wagner. "MOPS: An Infrastructure for Examining Security Properties of Software." In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2002.
4. M. Dowd, R. Smith, and D. Dewey. "Attack Interoperability." Black Hat USA 2009. [Video] (https://media.blackhat.com/bh-usa-09/video/DOWD/BHUSA09-Dowd-AtkInterop-VIDEO.mov)
5. U. Erlingsson. "The Inlined Reference Monitor Approach to Security Policy Enforcement." PhD thesis, Cornell University, January 2004.
6. D. Evans and A. Twyman. "Flexible Policy-Directed Code Safety." In Proceedings of the IEEE Symposium on Security and Privacy (OAKLAND), May 1999.
7. T. Fraser, N. L. Petroni, and W. A. Arbaugh. "Applying Flow-Sensitive CQUAL to Verify MINIX Authorization Check Placement." In Proceedings of the Workshop on Programming Languages and Analysis for Security, 2006.
8. V. Ganapathy, T. Jaeger, and S. Jha. "Automatic Placement of Authorization Hooks in the Linux Security Modules Framework." In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2005.
9. V. Ganapathy, T. Jaeger, and S. Jha. "Retrofitting Legacy Code for Authorization Policy Enforcement." In Proceedings of the IEEE Symposium on Security and Privacy (OAKLAND), 2006.
10. V. Ganapathy, D. King, T. Jaeger, and S. Jha. "Mining Security-Sensitive Operations in Legacy Code Using Concept Analysis." In Proceedings of the International Conference on Software Engineering (ICSE), 2007.
11. G. Hunt and D. Brubacher. "Detours: Binary Interception of Win32 Functions." In WINSYM'99: Proceedings of the 3rd Conference on USENIX Windows NT Symposium, pages 14–14, Berkeley, CA, USA, 1999. USENIX Association.
12. N. Islam, R. Anand, T. Jaeger, and J. R. Rao. "A Flexible Security System for Using Internet Content." IEEE Software, 14:52–59, 1997.
13. T. Jaeger, A. Edwards, and X. Zhang. "Consistency Analysis of Authorization Hook Placement in the Linux Security Modules Framework." ACM Transactions on Information and System Security (TISSEC), 7(2), 2004.
14. T. Jaeger, A. D. Rubin, and A. Prakash. "Building Systems that Flexibly Control Downloaded Executable Context." In Proceedings of the USENIX Security Symposium (SECURITY), 1996.
15. P. A. Loscocco, S. D. Smalley, P. A. Muckelbauer, and R. C. Taylor. "The Inevitability of Failure: The Flawed Assumption of Security in Modern Computing Environments." In Proceedings of the National Information Systems Security Conference, 1998.
16. D. Malkhi and M. Reiter. "Secure Execution of Java Applets Using a Remote Playground." IEEE Transactions on Software Engineering, 27(12):1197–1209, 2000.
17. Microsoft. "Safe Initialization and Scripting for ActiveX Controls." Microsoft Developer Network. (http://msdn.microsoft.com/en-us/library/aa751977(VS.85).aspx)
18. Microsoft. "Working with the AppInitDLLs Registry Value." Microsoft Support, November 2006. (http://support.microsoft.com/kb/197571)
19. Microsoft. "Security Advisory (953839)." Microsoft TechNet, August 2008. (http://www.microsoft.com/technet/security/advisory/953839.mspx)
20. Microsoft. "Security Advisory (956391)." Microsoft TechNet, October 2008. (http://www.microsoft.com/technet/security/advisory/956391.mspx)
21. Microsoft. "How to Stop an ActiveX Control from Running in Internet Explorer." Microsoft Support Center, August 2009. (http://support.microsoft.com/kb/240797)
22. Microsoft. "Security Advisory (960715)." Microsoft TechNet, February 2009. (http://www.microsoft.com/technet/security/advisory/960715.mspx)
23. Microsoft. "Security Advisory (969898)." Microsoft TechNet, June 2009. (http://www.microsoft.com/technet/security/advisory/969898.mspx)
24. Microsoft. "Microsoft Security Bulletin MS09-032." Microsoft TechNet, July 2009. (http://www.microsoft.com/technet/security/bulletin/ms09-032.mspx)
25. Microsoft. "Microsoft Security Bulletin (MS09-034)." Microsoft TechNet, July 2009. (http://www.microsoft.com/technet/security/bulletin/ms09-034.mspx)
26. Microsoft Support. "You Are Prompted to Grant Permission for ActiveX Controls When You Open an Office XP or Office 2003 Document." Microsoft Support Center, October 2007. (http://support.microsoft.com/default.aspx?scid=kb;en-us;827742)
27. G. C. Necula, S. McPeak, and W. Weimer. "CCured: Type-Safe Retrofitting of Legacy Code." In Proceedings of the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, 2002.
28. N. Thompson. "MFC/COM Objects 1: Creating a Simple Object." Microsoft Developer Network, March 1995. (http://msdn.microsoft.com/en-us/library/ms809986.aspx)
29. J. Yang, T. Kremenek, Y. Xie, and D. Engler. "MECA: An Extensible, Expressive System and Language for Statically Checking Security Properties." In Proceedings of the ACM Conference on Computer and Communications Security, 2003.
30. X. Zhang, A. Edwards, and T. Jaeger. "Using CQUAL for Static Analysis of Authorization Hook Placement." In Proceedings of the USENIX Security Symposium (SECURITY), 2002.

### Appendix A: CComVariant::ReadFromStream() Method

The following source code represents the `CComVariant::ReadFromStream()` method as distributed with ATL version 6.0. This method allows a developer to read a variant from a COM persistence stream. The key piece is the call to `OleLoadFromStream()` (line 23), which is detailed in Appendix B:

```cpp
inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
    HRESULT hr;
    ATLENSURE(pStream != NULL);
    hr = VariantClear(this);
    if (FAILED(hr))
        return hr;

    VARTYPE vtRead;
    hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
    if (FAILED(hr))
        return hr;

    vt = vtRead;
    int cbRead = 0;

    switch (vtRead)
    {
        case VT_UNKNOWN:
        case VT_DISPATCH:
            punkVal = NULL;
            hr = OleLoadFromStream(pStream,
                (vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
                (void**)&punkVal);
            if (hr == REGDB_E_CLASSNOTREG)
                hr = S_OK;
            return S_OK;
    }
}
```

### Appendix B: OleLoadFromStream() Method

The following code was derived by first disassembling `Ole32.dll` with IDA Pro. The disassembly was then manually converted to the C/C++ equivalent shown below. This code shows that the method reads a CLSID from a persistence stream and instantiates that object with a call to `CoCreateInstance()` (line 23). It should be noted that there is no check against a security policy before the object is loaded:

```cpp
HRESULT OleLoadFromStream(LPSTREAM pStm, const IID *const iidInterface, LPVOID *ppvObj)
{
    CLSID pclsid;
    IID *riid;
    HANDLE *ppvObj;
    HANDLE *ppvStmObj;
    HRESULT hr;

    riid = iidInterface;
    if (*ppvObj == 0)
        return E_INVALIDARG;

    if (!isValidInterface(pStm))
        return E_INVALIDARG;

    hr = ReadClassStm(pStm, &pclsid);
    if (hr)
        return hr;

    hr = CoCreateInstance(pclsid, NULL, CLSCTX_NO_CODE_DOWNLOAD | CLSCTX_REMOVE_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER, riid, ppvObj);
    if (hr)
        return hr;

    hr = ppvObj->QueryInterface(IID_IPersistStream, ppvStmObj);
    if (hr) {
        ppvObj->Release();
        return hr;
    }

    hr = ppvStmObj->Load(pStm);
    if (hr) {
        ppvObj->Release();
        return hr;
    }

    return hr;
}
```

This optimized version of the text aims to improve clarity, coherence, and professionalism.