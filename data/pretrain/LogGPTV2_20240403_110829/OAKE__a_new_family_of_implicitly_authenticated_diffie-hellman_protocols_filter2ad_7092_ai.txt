0
−1
0
0
0
0
Figure 3: Reduction from GDH to OAKE-HDR forgeries
26
Building the CDH solver C from the sOAKE-HDR forger F
Setup: same as in Figure 3 for the forger F against OAKE-HDR.
Signature query and RO query simulation: similar to those made for the forger against OAKE-HDR in
Figure 3, but with the following modiﬁcations:
• c = d = 1 and e = h(m ^Z; m ^B; ˆZ; Z; ˆB; B; X; Y ).
• In Step S.3 and RO queries, the challenger C checks that (cid:27) = Z cyX bd+ye by checking whether
CDH(X; B) = ((cid:27)=Z yX ye) via the DDH oracle.
Upon F’s termination. When F halts, C checks whether the following conditions hold:
F1. F outputs a valid HDR-signature ( ˆA; A; m1; m0; X0; Y0; r0), where ˆA ̸= ˆB is an uncorrupted player. In
, Y0 = gy0 (chosen by F), and
particular, it implies that r0 should be HK((cid:27)0), where (cid:27)0 = Ay0 X b+y0e0
e0 = h(m1; m0; ˆA; A; ˆB; B; X0Y0).
0
F2. ( ˆA; A; m1; m0; X0; Y0) did not appear in any of the above responses of the simulated sOAKE-HDR sig-
natures.
F3. The value e0 = h(m1; m0; ˆA; A; ˆB; B; X0Y0) was queried from the RO h, and the value HK((cid:27)0) was
queried from HK being posterior to the query e0. Otherwise, C aborts.
If these three conditions hold, C proceeds to the “repeat experiment” below, else it aborts.
The repeat experiment. C runs F again for a second time, under the same input (B; X0) and using the
same coins for F. C rewinds F to the point of making the RO query h(m1; m0; ˆA; A; ˆB; B; X0Y0), responds
∈R {0; 1}l. All subsequent actions of C (including random answers to
back a new independent value e
subsequent RO queries) are independent of the ﬁrst run. If in this repeated run F outputs a successful forgery
0) satisfying the conditions F1-F3 (otherwise, C aborts), which particularly implies
′
′
( ˆA
; A
′
0 = A
that r
where a and a
to be known to C). Note that ( ˆA
′
CDH(U; V ) = CDH(X0; B) = (cid:27)0=((gx0y0 )e0 · Y a
0 ).
,
(diﬀerent from ˆB, which are assumed
1) need not necessarily to equal ( ˆA; A; m1). Finally, C computes
′
′
0), (cid:27)
′
are the private keys of the uncorrupted ˆA and ˆA
, C computes CDH(X0; Y0) = gx0y0 = [((cid:27)0=Y a
′
′
; m
′
0 = HK((cid:27)
′
′
1; m0; X0; Y0; r
0 )](e0−e
′y0 X b+y0e
′
0=Y a
0 )=((cid:27)
; m
; A
′
0
′
0
0
′
−1
′
0)
Figure 4: Reduction from GDH to sOAKE-HDR forgeries
h
0
H
= (cid:27)] ≤ 1
2l−1 + Qs+Q2
where c = h(m ^Z; ˆZ; Z; Y ), d = h(m ^B; ˆB; B; X), e = h(X; Y ), c0 = h(m1; ˆA; A; Y0), d0 =
h(m0; ˆB; B; X0), e0 = h(X0; Y0), and (m0; m1; ˆA; A; ˆB; B; X0; Y0) ̸= (m ^A; m ^B; ˆZ; Z; ˆB; B; X; Y ).
By the NMJPOK and TBSS properties of OAKE, for any value (cid:27) ∈ G \ 1G and any
(m1; m0; ˆA; A; ˆB; B; X0; Y0), the probability Pr[Ac0y0X d0b+e0y0
2l−1 , where X0 is
the given random element in G\ 1G, ˆA and ˆB are uncorrupted players. This is true, even
if the public-key A (resp., B) is removed from c0 (resp., d0), as the public-keys A and
B are generated by the uncorrupted players ˆA and ˆB independently at random. Then,
by straightforward calculation, we can get that F succeeds in Case-2 with probability at
most O( Q2
Note: To rule out the possibility of Case-2, the analysis of HMQV-HCR requires the
KEA assumption [19]. Furthermore, to resist to birthday attacks in Case-2 (when the
number of messages in the system may be large), some modiﬁcations of HMQV are
recommended in [42]: (1) increase the output length, i.e., l, of h, e.g., from |q|=2 to |q|.
(2) Add random and fresh nonces (which cannot be oﬄine pre-computed) to the input
of h, or put the messages to be signed m ^A; m ^B into the input of HK. More details are
referred to [42].
2l−1 , the query HK((cid:27)0) is prior to any one of the queries {c0; d0; e0}.
• It is easy to check that, in case the forger F successfully outputs another diﬀerent forge satisfying
the conditions F1-F3 in the repeat experiment C1 or C2, the output of C is the correct value of
CDH(X0; B).
– With probability at most
).
2k
1
27
The similar observations can be easily checked for the algorithm C for sOAKE-HDR described in Figure
4. Putting all together, we have that: suppose for some uncorrupted player ˆA ̸= ˆB, the forger F
provides, with non-negligible probability, a successful forgery w.r.t. ˆA in its real interactions with the
signer of OAKE-HDR/sOAKE-HDR, then with also non-negligible probability (up to a negligible gap
speciﬁed by the above observations) F succeeds under the run of C. Then, by applying the forking
(cid:3)
lemma [60], the theorem is established.5
On the role of putting players’ public-keys into the inputs of c; d for OAKE-HDR and
e for sOAKE-HDR. We remark that the players’ public-keys in the inputs of c; d; e for (s)OAKE-
HDR actually play no role in the above security analysis. That is, the above security analysis is
actually with respect to a (public-key free) variant of (s)OAKE-HDR, with public-keys are removed
from the inputs of c; d; e. Recall that, players’ public-keys are only used for arguing the TBSS property
of (s)OAKE-HDR. Speciﬁcally, for any value (cid:27) ∈ G \ 1G and any (m1; m0; ˆA; A; ˆB; B; X0; Y0), the
probability Pr[(cid:27)0 = Ac0y0X d0b+e0y0
2l−1 , where c0 = h(m1; ˆA; A; Y0), d0 = h(m0; ˆB; B; X0)
e0 = h(X0; Y0) for OAKE-HDR (resp., c0 = d0 = 1 and e0 = h(m1; m0; ˆA; A; ˆB; B; X0; Y0) for sOAKE-
HDR), and the probability is taken over only the choice of the random function h. But, as we assume ˆA
and ˆB are both uncorrupted players, their public-keys are generated independently at random. Also, the
value X0 is the given random DH-component (not generated by the attacker). To aﬀect the distribution
of (cid:27)0, the only freedom of the attacker is to maliciously choose (Y0; m0; m1), which however does not
change the distribution of (cid:27)0. In particular, for any value (cid:27) ∈ G \ 1G and for any (Y0; m0; m1) chosen
2l−1 .
maliciously by the attacker w.r.t.
But, putting the public-keys into the input of c; d; e is useful for the security of (s,r)OAKE beyond the
CK-framework (e.g., security in the public computation model, session-key computational fairness, etc).
Security of (s)OAKE-HDR against the signer itself. The above security analysis consid-
ers the security of (s)OAKE-HDR against any other uncorrupted players other than the signer itself,
i.e., the (in)feasibility of outputting a successful forgery (m1; m0; ˆA; A; ˆB; B; X0; Y0; r0) where ˆA is an
uncorrupted player and ˆA ̸= ˆB. But, the forger F may also be against the signer ˆB itself. That is,
F may output a successful forgery of the form: (m1; m0; ˆB; B; ˆB; B; X0; Y0; r0) (i.e., ˆA = ˆB). Here,
the ﬁxed ( ˆA; A; ˆB; B; X0), it still holds that Pr[(cid:27)0 = (cid:27)] ≤ 1
= (cid:27)] ≤ 1
0
we further investigate the feasibility of successful forgeries of this form. We distinguish two cases: (1)
Y0 = X0, i.e., the successful forgery is of the form (m1; m0; ˆB; B; ˆB; B; X0; X0; r0). For this case, similar
to that of HMQV-HDR, we show (s)OAKE-HDR is secure under the traditional CDH assumption (not
the stronger GDH assumption) in the RO model; (2) Y0 ̸= X0. For this case, we show (s)OAKE-HDR
is secure under the GDH assumption, and additionally the KEA assumption, in the RO model. We
remark that the KEA assumption is only used to rule out the feasibility of successful forgeries in the
special case of Y0 ̸= X0 and ˆA = ˆB.
0 X d0
0 )bX e0x0
Corollary G.1 Under the computational Diﬃe-Hellman (CDH) assumption, (public-key free) (s)OAKE-
HDR signatures of ˆB, with oﬄine pre-computed and exposable (y; Y; Acy), are strongly secure in the
random oracle model, with respect to the signer ˆB itself and Y0 = X0.
Proof. This case implies that the forger F can output, with non-negligible probability, a successful
forgery of the form: (m1; m0; ˆB; B; ˆB; B; X0; X0; r0), where r0 = HK((cid:27)0), (cid:27)0 = Bc0x0X d0b+e0x0
=
, c0 = h(m1; ˆB; B; X0), d0 = h(m0; ˆB; B; X0), e0 = h(X0; X0) for OAKE-HDR (for
(X c0
sOAKE-HDR, c0 = d0 = 1 and e0 = h(m1; m0; ˆB; B; ˆB; B; X0; X0)). Note that from (cid:27)0 and ˆB’s secret-
key b, we can compute X x0
0 . But, the hardness of computing X x from random X is equivalent to that
of the CDH problem [48, 53].
With the above observations, we modify the algorithm C depicted in Figure 3 and Figure 4 as follows:
• C knows (sets) also the private key b for ˆB. By knowing the private key b, C dispenses with the
DDH-oracle in order to make the answers to signature queries and RO-queries to be consistent.
0
0
5We note that we can also use the more general and abstract forking lemmas [1, 5], but with a slightly diﬀerent security
argument procedure.
28
• After F outputs a successful forgery of the form (m1; m0; ˆB; B; ˆB; B; X0; X0; r0), satisfying the
from (cid:27)0 and the private-key b. Note that C does
conditions F1-F3, C simply computes out X x0
(cid:3)
not need to perform the rewinding experiments at all in this case.
Now we consider the case of Y0 ̸= X0. As mentioned, it is the only place we need to additionally
0
use the KEA assumption.
q and z ∈ {0; 1}∗
∗
Deﬁnition G.3 [Knowledge-of-Exponent Assumption (KEA)] Let G be a cyclic group of prime order
q generated by an element g, and consider algorithms that on input a triple (g; C = gc; z) output a
pair (Y; Z) ∈ G2, where c is taken uniformly at random from Z
is an arbitrary string
that is generated independently of C. Such an algorithm A is said to be a KEA algorithm if with
non-negligible probability (over the choice of g; c and A’s random coins) A(g; gc; z) outputs (Y; Z) ∈ G2
such that Z = Y c. Here, C = gc is the random challenge to the KEA algorithm A, and z captures the
auxiliary input of A that is independent of the challenge C.
We say that the KEA assumption holds over G, if for every probabilistic polynomial-time (PPT)
KEA algorithm A for G there exists another eﬃcient algorithm K, referred to as the KEA-extractor,
for which the following property holds except for a negligible probability: let (g; gc; z) be an input to A
and (cid:26) a vector of random coins for A on which A outputs (Y; Z = Y c), then, on the same inputs and
random coins, K(g; C; z; (cid:26)) outputs the triple (Y; Z = Y c; y) where Y = gy.
Corollary G.2 Under the GDH assumption, and additionally the KEA assumption, (public-key free)
(s)OAKE-HDR and sOAKE-HDR signatures of ˆB, with oﬄine pre-computed and exposable (y; Y; Acy),
is strongly secure in the random oracle model, with respect to the signer ˆB itself and Y0 ̸= X0.
Proof. The proof of Corollary G.2 follows the same outline of that of Theorem G.1. We highlight the
main diﬀerences, and how the KEA assumption comes into force in the security analysis. The analysis
is mainly w.r.t. OAKE-HDR (the similar, and actually simpler, holds also for sOAKE-HDR).
0
The main diﬀerence between the proof of Corollary G.2 and that of Theorem G.1 is that, here, the
forger outputs with non-negligible probability a successful forgery of the form: (m1; m0; ˆB; B; ˆB; B; X0;
Y0; r0), where r0 = HK((cid:27)0), (cid:27)0 = Bc0y0X d0b+e0y0
, c0 = h(m1; ˆB; B; Y0), d0 = h(m0; ˆB; B; X0), e0 =
h(X0; Y0) (for sOAKE-HDR, c0 = d0 = 1 and e0 = h(m1; m0; ˆB; B; ˆB; B; X0; X0)). The key point is
that, by performing the rewinding experiments, we cannot directly output the CDH(B; X0), as we do
not know the private key b of ˆB (recall that we are going to compute CDH(B; X0) by running the