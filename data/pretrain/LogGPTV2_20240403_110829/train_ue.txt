simultaneous asynchronous read or write operations using the same
.i aiocb
structure yield undefined results.
.pp
the current linux posix aio implementation is provided in user space by glibc.
this has a number of limitations, most notably that maintaining multiple
threads to perform i/o operations is expensive and scales poorly.
work has been in progress for some time on a kernel
state-machine-based implementation of asynchronous i/o
(see
.br io_submit (2),
.br io_setup (2),
.br io_cancel (2),
.br io_destroy (2),
.br io_getevents (2)),
but this implementation hasn't yet matured to the point where
the posix aio implementation can be completely
reimplemented using the kernel system calls.
.\" http://lse.sourceforge.net/io/aio.html
.\" http://lse.sourceforge.net/io/aionotes.txt
.\" http://lwn.net/articles/148755/
.sh examples
the program below opens each of the files named in its command-line
arguments and queues a request on the resulting file descriptor using
.br aio_read (3).
the program then loops,
periodically monitoring each of the i/o operations
that is still in progress using
.br aio_error (3).
each of the i/o requests is set up to provide notification by delivery
of a signal.
after all i/o requests have completed,
the program retrieves their status using
.br aio_return (3).
.pp
the
.b sigquit
signal (generated by typing control-\e) causes the program to request
cancellation of each of the outstanding requests using
.br aio_cancel (3).
.pp
here is an example of what we might see when running this program.
in this example, the program queues two requests to standard input,
and these are satisfied by two lines of input containing
"abc" and "x".
.pp
.in +4n
.ex
$ \fb./a.out /dev/stdin /dev/stdin\fp
opened /dev/stdin on descriptor 3
opened /dev/stdin on descriptor 4
aio_error():
    for request 0 (descriptor 3): in progress
    for request 1 (descriptor 4): in progress
\fbabc\fp
i/o completion signal received
aio_error():
    for request 0 (descriptor 3): i/o succeeded
    for request 1 (descriptor 4): in progress
aio_error():
    for request 1 (descriptor 4): in progress
\fbx\fp
i/o completion signal received
aio_error():
    for request 1 (descriptor 4): i/o succeeded
all i/o requests completed
aio_return():
    for request 0 (descriptor 3): 4
    for request 1 (descriptor 4): 2
.ee
.in
.ss program source
\&
.ex
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#define buf_size 20     /* size of buffers for read operations */
#define errexit(msg) do { perror(msg); exit(exit_failure); } while (0)
struct iorequest {      /* application\-defined structure for tracking
                           i/o requests */
    int           reqnum;
    int           status;
    struct aiocb *aiocbp;
};
static volatile sig_atomic_t gotsigquit = 0;
                        /* on delivery of sigquit, we attempt to
                           cancel all outstanding i/o requests */
static void             /* handler for sigquit */
quithandler(int sig)
{
    gotsigquit = 1;
}
#define io_signal sigusr1   /* signal used to notify i/o completion */
static void                 /* handler for i/o completion signal */
aiosighandler(int sig, siginfo_t *si, void *ucontext)
{
    if (si\->si_code == si_asyncio) {
        write(stdout_fileno, "i/o completion signal received\en", 31);
        /* the corresponding iorequest structure would be available as
               struct iorequest *ioreq = si\->si_value.sival_ptr;
           and the file descriptor would then be available via
               ioreq\->aiocbp\->aio_fildes */
    }
}
int
main(int argc, char *argv[])
{
    struct sigaction sa;
    int s;
    int numreqs;        /* total number of queued i/o requests */
    int openreqs;       /* number of i/o requests still in progress */
    if (argc  ...\en",
                argv[0]);
        exit(exit_failure);
    }
    numreqs = argc \- 1;
    /* allocate our arrays. */
    struct iorequest *iolist = calloc(numreqs, sizeof(*iolist));
    if (iolist == null)
        errexit("calloc");
    struct aiocb *aiocblist = calloc(numreqs, sizeof(*aiocblist));
    if (aiocblist == null)
        errexit("calloc");
    /* establish handlers for sigquit and the i/o completion signal. */
    sa.sa_flags = sa_restart;
    sigemptyset(&sa.sa_mask);
    sa.sa_handler = quithandler;
    if (sigaction(sigquit, &sa, null) == \-1)
        errexit("sigaction");
    sa.sa_flags = sa_restart | sa_siginfo;
    sa.sa_sigaction = aiosighandler;
    if (sigaction(io_signal, &sa, null) == \-1)
        errexit("sigaction");
    /* open each file specified on the command line, and queue
       a read request on the resulting file descriptor. */
    for (int j = 0; j aio_fildes = open(argv[j + 1], o_rdonly);
        if (iolist[j].aiocbp\->aio_fildes == \-1)
            errexit("open");
        printf("opened %s on descriptor %d\en", argv[j + 1],
                iolist[j].aiocbp\->aio_fildes);
        iolist[j].aiocbp\->aio_buf = malloc(buf_size);
        if (iolist[j].aiocbp\->aio_buf == null)
            errexit("malloc");
        iolist[j].aiocbp\->aio_nbytes = buf_size;
        iolist[j].aiocbp\->aio_reqprio = 0;
        iolist[j].aiocbp\->aio_offset = 0;
        iolist[j].aiocbp\->aio_sigevent.sigev_notify = sigev_signal;
        iolist[j].aiocbp\->aio_sigevent.sigev_signo = io_signal;
        iolist[j].aiocbp\->aio_sigevent.sigev_value.sival_ptr =
                                &iolist[j];
        s = aio_read(iolist[j].aiocbp);
        if (s == \-1)
            errexit("aio_read");
    }
    openreqs = numreqs;
    /* loop, monitoring status of i/o requests. */
    while (openreqs > 0) {
        sleep(3);       /* delay between each monitoring step */
        if (gotsigquit) {
            /* on receipt of sigquit, attempt to cancel each of the
               outstanding i/o requests, and display status returned
               from the cancellation requests. */
            printf("got sigquit; canceling i/o requests: \en");
            for (int j = 0; j aio_fildes);
                    s = aio_cancel(iolist[j].aiocbp\->aio_fildes,
                            iolist[j].aiocbp);
                    if (s == aio_canceled)
                        printf("i/o canceled\en");
                    else if (s == aio_notcanceled)
                        printf("i/o not canceled\en");
                    else if (s == aio_alldone)
                        printf("i/o all done\en");
                    else
                        perror("aio_cancel");
                }
            }
            gotsigquit = 0;
        }
        /* check the status of each i/o request that is still
           in progress. */
        printf("aio_error():\en");
        for (int j = 0; j aio_fildes);
                iolist[j].status = aio_error(iolist[j].aiocbp);
                switch (iolist[j].status) {
                case 0:
                    printf("i/o succeeded\en");
                    break;
                case einprogress:
                    printf("in progress\en");
                    break;
                case ecanceled:
                    printf("canceled\en");
                    break;
                default:
                    perror("aio_error");
                    break;
                }
                if (iolist[j].status != einprogress)
                    openreqs\-\-;
            }
        }
    }
    printf("all i/o requests completed\en");
    /* check status return of all i/o requests. */
    printf("aio_return():\en");
    for (int j = 0; j aio_fildes, s);
    }
    exit(exit_success);
}
.ee
.sh see also
.ad l
.nh
.br io_cancel (2),
.br io_destroy (2),
.br io_getevents (2),
.br io_setup (2),
.br io_submit (2),
.br aio_cancel (3),
.br aio_error (3),
.br aio_init (3),
.br aio_read (3),
.br aio_return (3),
.br aio_write (3),
.br lio_listio (3)
.pp
"asynchronous i/o support in linux 2.5",
bhattacharya, pratt, pulavarty, and morgan,
proceedings of the linux symposium, 2003,
.ur https://www.kernel.org/doc/ols/2003/ols2003\-pages\-351\-366.pdf
.ue
.sh colophon
this page is part of release 5.13 of the linux
.i man-pages
project.
a description of the project,
information about reporting bugs,
and the latest version of this page,
can be found at
\%https://www.kernel.org/doc/man\-pages/.
.\" copyright (c) 1993 by thomas koenig (PI:EMAIL)
.\"
.\" %%%license_start(verbatim)
.\" permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" since the linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  the author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  the author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%license_end
.\"
.\" modified wed jul 28 11:12:07 1993 by rik faith (PI:EMAIL)
.\" modified fri sep  8 15:48:13 1995 by andries brouwer (PI:EMAIL)
.th fgetc 3  2021-03-22 "gnu" "linux programmer's manual"
.sh name
fgetc, fgets, getc, getchar, ungetc \- input of characters and strings
.sh synopsis
.nf
.b #include 
.pp
.bi "int fgetc(file *" stream );
.bi "int getc(file *" stream );
.b "int getchar(void);"
.pp
.bi "char *fgets(char *restrict " s ", int " size ", file *restrict " stream );
.pp
.bi "int ungetc(int " c ", file *" stream );
.fi
.sh description
.br fgetc ()
reads the next character from
.i stream
and returns it as an
.i unsigned char
cast to an
.ir int ,
or
.b eof
on end of file or error.
.pp
.br getc ()
is equivalent to
.br fgetc ()
except that it may be implemented as a macro which evaluates
.i stream
more than once.
.pp
.br getchar ()
is equivalent to
.bi "getc(" stdin ) \fr.
.pp
.br fgets ()
reads in at most one less than
.i size
characters from
.i stream
and stores them into the buffer pointed to by
.ir s .
reading stops after an
.b eof
or a newline.
if a newline is read, it is stored into the buffer.
a terminating null byte (\(aq\e0\(aq)
is stored after the last character in the buffer.
.pp
.br ungetc ()
pushes
.i c
back to
.ir stream ,
cast to
.ir "unsigned char" ,
where it is available for subsequent read operations.
pushed-back characters
will be returned in reverse order; only one pushback is guaranteed.
.pp
calls to the functions described here can be mixed with each other and with
calls to other input functions from the
.i stdio
library for the same input stream.
.pp
for nonlocking counterparts, see
.br unlocked_stdio (3).
.sh return value
.br fgetc (),
.br getc (),
and
.br getchar ()
return the character read as an
.i unsigned char
cast to an
.i int
or
.b eof
on end of file or error.
.pp
.br fgets ()
returns
.i s
on success, and null
on error or when end of file occurs while no characters have been read.
.pp
.br ungetc ()
returns
.i c
on success, or
.b eof
on error.
.sh attributes
for an explanation of the terms used in this section, see
.br attributes (7).
.ad l
.nh
.ts
allbox;
lbx lb lb
l l l.
interface	attribute	value
t{
.br fgetc (),
.br fgets (),
.br getc (),
.br getchar (),
.br ungetc ()
t}	thread safety	mt-safe
.te
.hy
.ad
.sp 1
.sh conforming to
posix.1-2001, posix.1-2008, c89, c99.
.pp
it is not advisable to mix calls to input functions from the
.i stdio
library with low-level calls to
.br read (2)
for the file descriptor associated with the input stream; the results
will be undefined and very probably not what you want.
.sh see also
.br read (2),
.br write (2),
.br ferror (3),
.br fgetwc (3),
.br fgetws (3),
.br fopen (3),
.br fread (3),
.br fseek (3),
.br getline (3),
.br gets (3),
.br getwchar (3),
.br puts (3),
.br scanf (3),
.br ungetwc (3),
.br unlocked_stdio (3),
.br feature_test_macros (7)
.sh colophon
this page is part of release 5.13 of the linux
.i man-pages
project.
a description of the project,
information about reporting bugs,
and the latest version of this page,
can be found at
\%https://www.kernel.org/doc/man\-pages/.
.so man3/floor.3
.so man3/cpu_set.3
.\" copyright (c) 1995 andries brouwer (PI:EMAIL)
.\" and copyright (c) 2012, 2014 michael kerrisk 
.\"
.\" %%%license_start(verbatim)
.\" permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" since the linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  the author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  the author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%license_end
.\"
.\" written 11 june 1995 by andries brouwer 
.\" 2008-02-15, jeremy kerr 
.\"     add info on command type 10; add details on types 6, 7, 8, & 9.
.\" 2008-02-15, michael kerrisk 
.\"     update log_buf_len details; update return value section.
.\"
.th syslog 2  2021-03-22 "linux" "linux programmer's manual"
.sh name
syslog, klogctl \- read and/or clear kernel message ring buffer;
set console_loglevel
.sh synopsis
.nf
.br "#include " "        /* definition of " syslog_* " constants */"
.br "#include " "     /* definition of " sys_* " constants */"
.b #include 
.pp
.bi "int syscall(sys_syslog, int " type ", char *" bufp ", int " len );
.pp
/* the glibc interface */
.b #include 
.pp
.bi "int klogctl(int " type ", char *" bufp ", int " len );
.fi
.sh description
.ir note :
probably, you are looking for the c library function
.br syslog (),
which talks to
.br syslogd (8);
see
.br syslog (3)
for details.
.pp
this page describes the kernel
.br syslog ()
system call, which is used to control the kernel
.ir printk ()
buffer; the glibc wrapper function for the system call is called
.br klogctl ().
.ss the kernel log buffer
the kernel has a cyclic buffer of length
.b log_buf_len
in which messages given as arguments to the kernel function
.br printk ()
are stored (regardless of their log level).
in early kernels,