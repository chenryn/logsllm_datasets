# DLL劫持原理及其漏洞挖掘（一）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x0 前言
简单叙述下自己研究DLL劫持的原因。
  * 0.学习window的库加载思想
  * 1.为了在sangforSRC挖个洞去长沙打个卡。
  * 2.免杀及其权限持久化维持的一个思路
## 0x1 DLL是什么
动态链接库(Dynamic-Link-Library,缩写dll),
是微软公司在微软视窗操作系统中实现共享函数库概念的一种实现方式。这些库函数的扩展名是`.DLL`、`.OCX`(包含[ActiveX](https://zh.wikipedia.org/wiki/ActiveX)控制的库)或者`.DRV`(旧式的系统的[驱动程序](https://zh.wikipedia.org/wiki/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F))
>
> 所谓动态链接,就是把一些经常会共享的代码(静态链接的[OBJ](https://zh.wikipedia.org/w/index.php?title=OBJ&action=edit&redlink=1)程序库)制作成DLL档,当可执行文件调用到DLL档内的函数时，Windows操作系统才会把DLL档加载进存储器内，DLL档本身的结构就是可执行档，当程序有需求时函数才进行链接。通过动态链接方式，存储器浪费的情形将可大幅降低。[静态链接库](https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%80%A3%E7%B5%90%E5%87%BD%E5%BC%8F%E5%BA%AB)则是直接[链接](https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8)到可执行文件
>
>
> DLL的文件格式与视窗[EXE](https://zh.wikipedia.org/wiki/EXE)文件一样——也就是说，等同于[32位](https://zh.wikipedia.org/wiki/32%E4%BD%8D)视窗的[可移植执行文件](https://zh.wikipedia.org/wiki/Portable_Executable)（PE）和[16位](https://zh.wikipedia.org/wiki/16%E4%BD%8D)视窗的[New
> Executable](https://zh.wikipedia.org/w/index.php?title=New_Executable&action=edit&redlink=1)（NE）。作为EXE格式，DLL可以包括[源代码](https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%A7%8B%E7%A2%BC)、[数据](https://zh.wikipedia.org/w/index.php?title=Data_\(computing)&action=edit&redlink=1)和[资源](https://zh.wikipedia.org/w/index.php?title=Resource_\(Windows)&action=edit&redlink=1)的多种组合。
>
> 还有更广泛的定义,这个没必要去理解了。
一些与之相关的概念:
> 静态库与动态库的比较
>
> 静态库被链接后直接嵌入可执行文件中
>
> 好处: 不需要外部函数支持,无环境依赖,兼容性好。
>
> 坏处: 容易浪费空间，不方便修复bug。
>
> 动态库的好处与静态库相对。
>
> Linux下静态库名字一般是: `libxxx.a` window则是: `*.lib`、`*.h`
>
> Linux下动态库名字一般是:`libxxx.so` window则是: `.dll`、`.OCX`(..etc)
## 0x2 DLL的用途
DLL动态链接库，是程序进行动态链接时加载的库函数。
故动态链接最直接的好处是磁盘和内存的消耗减少，这也是dll最初的目的。
不过，dll也有缺点，就是容易造成版本冲突,比如不同的应用程序共享同一个dll,而它们需求的是不同的版本，这就会出现矛盾,解决办法是把不同版本的dll放在不同的文件夹中。
## 0x3 入门DLL的使用
###  0x3.1 编写TestDll.dll
1.采用vs2017新建DLL项目
2.分析DLL的组成
其中`dllmain.cpp`代码如下
每个DLL都可以有一个入口点函数DllMain,系统会在不同时刻调用此函数。
    // dllmain.cpp : 定义 DLL 应用程序的入口点。
    #include "pch.h"
    BOOL APIENTRY DllMain( HMODULE hModule, // 模块句柄
                           DWORD  ul_reason_for_call, // 调用原因
                           LPVOID lpReserved // 参数保留
                         )
    {
        switch (ul_reason_for_call) // 根据调用原因选择不不同的加载方式
        {
        case DLL_PROCESS_ATTACH: // DLL被某个程序加载
        case DLL_THREAD_ATTACH: // DLL被某个线程加载
        case DLL_THREAD_DETACH: // DLL被某个线程卸载
        case DLL_PROCESS_DETACH: //DLL被某个程序卸载
            break;
        }
        return TRUE;
    }
我们可以在该文件下引入`Windows.h`库,然后编写一个`msg`的函数。
    #include 
    void msg() {
        MessageBox(0, L"Dll-1 load  succeed!", 0, 0);
    }
接下来在解决方案资源管理下的项目下打开头文件中的`framework.h`来导出msg函数.
    #pragma once
    #define WIN32_LEAN_AND_MEAN             // 从 Windows 头文件中排除极少使用的内容
    // Windows 头文件
    #include 
    extern "C" __declspec(dllexport) void msg(void);
然后点击生成中的重新生成解决方案编译得到`TestDll.dll`文件。
可以用16进制文件查看下dll的文件头，正如上面所说的一样，和exe是一样的。
###  0x3.2 调用dll文件
解决方案处右键新建一个项目，选择>控制台应用取名`hello`
修改`hello.cpp`的文件内容如下:
    // hello.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
    #include 
    #include 
    using namespace std;
    int main()
    {
        // 定义一个函数类DLLFUNC
        typedef void(*DLLFUNC)(void);
        DLLFUNC GetDllfunc = NULL;
        // 指定动态加载dll库
        HINSTANCE hinst = LoadLibrary(L"TestDll.dll");
        if (hinst != NULL) {
            // 获取函数位置
            GetDllfunc = (DLLFUNC)GetProcAddress(hinst, "msg");
        }
        if (GetDllfunc != NULL) {
            //运行msg函数
            (*GetDllfunc)();
        }
    }
然后ctrl+F5,运行调试。
可以看到成功加载了我们写的msg函数。
有关代码中更多的细节的解释可以参考: [C++编写DLL文件](https://my.oschina.net/u/4338312/blog/3376870)
## 0x4 DLL劫持漏洞
###  0x4.1 原理简述
什么是DLL劫持漏洞(DLL Hijacking Vulnerability)?
> 如果在进程尝试加载一个DLL时没有并没有 **指定DLL的绝对路径**
> ，那么Windows会尝试去按照顺序搜索这些特定目录来查找这个DLL,如果攻击者能够将恶意的DLL放在优先于正常DLL所在的目录，那么就能够欺骗系统去加载恶意的DLL，形成”劫持”,CWE将其归类为
> **UntrustedSearch Path Vulnerability** ,比较直译的一种解释。