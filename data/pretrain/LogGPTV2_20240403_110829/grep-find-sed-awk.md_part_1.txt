find, grep, sed, & awk
Increasing productivity with
command-line tools.
Unix philosophy
“This is the Unix
philosophy: Write
programs that do one
thing and do it well.
Write programs to work
together. Write
programs to handle text
streams, because that is
a universal interface.”
--Doug McIlroy, inventor
of Unix pipes
Why learn command-line utils?
• Simple – “do one thing”
• Flexible – built for re-use
• Fast – no graphics, no overhead
• Ubiquitous – available on every machine
• Permanent – 40 years so far …
Part 0 – pipes and xargs
Some simple programs
List files in current working directory:
$ ls
foo bar bazoo
Count lines in file foo:
$ wc –l foo
42 foo
Putting programs together
$ ls | wc –l
3
$ ls | xargs wc –l
42 foo
31 bar
12 bazoo
85 total
Part 1: find
Basic find examples
$ find . –name Account.java
Basic find examples
$ find . –name Account.java
$ find /etc –name '*.conf'
Basic find examples
$ find . –name Account.java
$ find /etc –name '*.conf'
$ find . –name '*.xml'
Basic find examples
$ find . –name Account.java
$ find /etc –name '*.conf'
$ find . –name '*.xml'
$ find . -not -name '*.java' -maxdepth 4
Basic find examples
$ find . –name Account.java
$ find /etc –name '*.conf'
$ find . –name '*.xml'
$ find . -not -name '*.java' -maxdepth 4
$ find . \(-name '*jsp' –o –name '*xml'\)
Basic find examples
$ find . –name Account.java
$ find /etc –name '*.conf'
$ find . –name '*.xml'
$ find . -not -name '*.java' -maxdepth 4
$ find . \(-name '*jsp' –o –name '*xml'\)
• -iname case-insensitive
• ! == -not
• Quotes keep shell from expanding wildcards.
Find and do stuff
$ find . –name '*.java' | xargs wc –l | sort
Find and do stuff
$ find . –name '*.java' | xargs wc –l | sort
Other options:
$ find . –name '*.java' -exec wc –l {} \; | sort
$ find . –name '*.java' -exec wc –l {} + | sort
Find and do stuff
$ find . –name '*.java' | xargs wc –l | sort
Other options:
$ find . –name '*.java' -exec wc –l {} \; | sort
$ find . –name '*.java' -exec wc –l {} + | sort
Use your imagination. mv, rm, cp, chmod . . .
-exec or | xargs?
• -exec has crazy syntax.
• | xargs fits Unix philosophy.
• \; is slow, executes command once for
each line.
• \; not sensible, sorts 'alphabetically.'
• | xargs may fail with filenames containing
whitespace, quotes or slashes.
Find by type
Files:
$ find . –type f
Find by type
Files:
$ find . –type f
Directories:
$ find . –type d
Find by type
Files:
$ find . –type f
Directories:
$ find . –type d
Links:
$ find . –type l
By modification time
Changed within day:
$ find . –mtime -1
By modification time
Changed within day:
$ find . –mtime -1
Changed within minute:
$ find . –mmin -15
By modification time
Changed within day:
$ find . –mtime -1
Changed within minute:
$ find . –mmin -15
Variants –ctime, -cmin, -atime, -amin
aren't especially useful.
By modification time, II
Compare to file
$ find . –newer foo.txt
$ find . ! –newer foo.txt
By modification time, III
Compare to date
$ find . -type f -newermt '2010-01-01'
By modification time, III
Compare to date
$ find . -type f -newermt '2010-01-01'
Between dates!
$ find . -type f -newermt '2010-01-01' \
> ! -newermt '2010-06-01'
Find by permissions
$ find . –perm 644
$ find . –perm –u=w
$ find . –perm –ug=w
$ find . –perm –o=x
Find by size
Less than 1 kB:
$ find . –size -1k
Find by size
Less than 1 kB:
$ find . –size -1k
More than 100MB:
$ find . –size +100M
find summary:
• Can search by name, path, depth,
permissions, type, size, modification time,
and more.
find summary:
• Can search by name, path, depth,
permissions, type, size, modification time,
and more.
• Once you find what you want, pipe it to
xargs if you want to do something with it.
find summary:
• Can search by name, path, depth,
permissions, type, size, modification time,
and more.
• Once you find what you want, pipe it to
xargs if you want to do something with it.
• The puppy is for your grandmother.
Part 2: grep
global / regular expression / print
From ed command g/re/p
For finding text inside files.
Basic usage:
$ grep  
Basic usage:
$ grep  
$ grep 'new FooDao' Bar.java
Basic usage:
$ grep  
$ grep 'new FooDao' Bar.java
$ grep Account *.xml
Basic usage:
$ grep  
$ grep 'new FooDao' Bar.java
$ grep Account *.xml
$ grep –r 'Dao[Impl|Mock]' src
Basic usage:
$ grep  
$ grep 'new FooDao' Bar.java
$ grep Account *.xml
$ grep –r 'Dao[Impl|Mock]' src
• Quote string if spaces or regex.
• Recursive flag is typical
• Don't quote filename with wildcards!
Common grep options
Case-insensitive search:
$ grep –i foo bar.txt
Common grep options
Case-insensitive search:
$ grep –i foo bar.txt
Only find word matches:
$ grep –rw foo src
Common grep options
Case-insensitive search:
$ grep –i foo bar.txt
Only find word matches:
$ grep –rw foo src
Display line number:
$ grep –nr 'new Foo()' src
Filtering results
Inverted search:
$ grep –v foo bar.txt
Prints lines not containing foo.
Filtering results
Inverted search:
$ grep –v foo bar.txt
Prints lines not containing foo.
Typical use:
$ grep –r User src | grep –v svn
Filtering results
Inverted search:
$ grep –v foo bar.txt
Prints lines not containing foo.
Typical use:
$ grep –r User src | grep –v svn
Using find … | xargs grep … is faster.
More grep options
Search for multiple terms:
$ grep -e foo –e bar baz.txt
More grep options
Search for multiple terms:
$ grep -e foo –e bar baz.txt
Find surrounding lines:
$ grep –r –C 2 foo src
More grep options
Search for multiple terms:
$ grep -e foo –e bar baz.txt
Find surrounding lines:
$ grep –r –C 2 foo src
Similarly –A or –B will print lines before and
after the line containing match.
Example
Find tests that use the AccountDao interface.
Example
Find tests that use the AccountDao interface.
Possible solution (arrive at incrementally):
$ grep –rwn –C 3 AccountDao src/test
> | grep –v svn
grep summary:
• -r recursive search
• -i case insensitive
• -w whole word
• -n line number
• -e multiple searches
• -A After
• -B Before
• -C Centered
Part 3: sed
stream editor
For modifying files
and streams of
text.
sed command #1: s
$ echo 'foo' | sed 's/foo/bar/'
sed command #1: s
$ echo 'foo' | sed 's/foo/bar/'
bar
sed command #1: s
$ echo 'foo' | sed 's/foo/bar/'
bar
$ echo 'foo foo' | sed 's/foo/bar/'
sed command #1: s
$ echo 'foo' | sed 's/foo/bar/'
bar
$ echo 'foo foo' | sed 's/foo/bar/'
bar foo
sed command #1: s
$ echo 'foo' | sed 's/foo/bar/'
bar
$ echo 'foo foo' | sed 's/foo/bar/'
bar foo
's/foo/bar/g' – global (within line)
Typical uses
$ sed 's/foo/bar/g' old
Typical uses
$ sed 's/foo/bar/g' old
$ sed 's/foo/bar/g' old > new
Typical uses
$ sed 's/foo/bar/g' old
$ sed 's/foo/bar/g' old > new
$ sed –i 's/foo/bar/g' file
Typical uses
$ sed 's/foo/bar/g' old
$ sed 's/foo/bar/g' old > new
$ sed –i 's/foo/bar/g' file
$  | xargs sed –i 's/foo/bar/g'
Real life example I
Each time I test a batch job, a flag file gets
it's only line set to YES, and the job can't
be tested again until it is reverted to NO.
Real life example I
Each time I test a batch job, a flag file gets
it's only line set to YES, and the job can't
be tested again until it is reverted to NO.
$ sed –i 's/YES/NO/' flagfile
• Can change file again with up-arrow.
• No context switch.
Real life example II
A bunch of test cases say:
Assert.assertStuff which could be
assertStuff, since using JUnit 3.
Real life example II
A bunch of test cases say:
Assert.assertStuff which could be
assertStuff, since using JUnit 3.
$ find src/test/ -name '*Test.java' \
> | xargs sed –i 's/Assert.assert/assert/'
Real life example III
Windows CR-LF is mucking things up.
Real life example III
Windows CR-LF is mucking things up.
$ sed 's/.$//' winfile > unixfile
Replaces \r\n with (always inserted) \n
Real life example III
Windows CR-LF is mucking things up.
$ sed 's/.$//' winfile > unixfile
Replaces \r\n with (always inserted) \n
$ sed 's/$/\r/' unixfile > winfile
Replaces \n with \r\n.
Capturing groups
$ echo 'Dog Cat Pig' | sed 's/\b\(\w\)/(\1)/g'
Capturing groups
$ echo 'Dog Cat Pig' | sed 's/\b\(\w\)/(\1)/g'
(D)og (C)at (P)ig
Capturing groups
$ echo 'Dog Cat Pig' | sed 's/\b\(\w\)/(\1)/g'