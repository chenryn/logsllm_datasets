    }
从上面我们知道，要创建一个新用户，我们需要发送一个POST请求到`/api/admin/adduser`
其正文格式如下：`{ "first":"George", "last":"Orwell",
"email":"[PI:EMAIL](mailto:PI:EMAIL)"}`。
在Angular
1中，服务看起来略有不同。让我们看一下连接到[Firebase](https://firebase.google.com/)数据库的服务，以获得用户列表：
    angular
      .module('myApp.admin.services')
      .factory('AdminService', ['$firebaseArray', '$firebaseObject', '$http', '$q',
        function ($firebaseArray, $firebaseObject, $http, $q) {
          var AdminService = {
              allUsers: {},
              getAllUsers: getAllUsers,
          }
          // Get a reference to the Firebase
          var userProfilesRef = new Firebase("https://example.firebaseio.com/userprofiles/");
          function getAllUsers() {
              var deferred = $q.defer();
              AdminService.allUsers = $firebaseObject(userProfilesRef);
              Admin.allUsers.$loaded().then(function () {
                  deferred.resolve(AdminService.allUsers);
              }, function (error) {
                  deferred.reject(error);
              });
              return deferred.promise;
          }
上述服务逻辑告诉我们在 _example.firebaseio.com/userprofiles/_
上有一个Firebase端点，我们可以调用它来获取应用程序的用户列表。
服务还可以保存有趣的逻辑，用于与无服务器服务（如Firebase
)通信。在某些情况下，您可能会发现整个数据层逻辑都在客户端代码中，在这种情况下，您可以通过从浏览器控制台操作服务功能来枚举NoSQL数据库。我们将在本文的第二部分看到如何做到这一点。
###  控制器
如前所述，控制器是Angular 1.x概念。AngularJS应用程序使用控制器来操作DOM元素，并通过Angular的
`$scope`作用域设置侦听器和变量。例如，控制器可以保存页面中用户界面元素使用的变量，例如表单值和动态URLs，并且它们可以使用服务将这些表单提交给运行后端代码的服务器。此外，控制器可以保存作用域的变量，当这些变量发生变化时，会改变应用程序的行为。如果你需要找出是什么触发了页面上的特定更改，请寻找控制器逻辑。
###  组件
自从Angular
2发布后，Angular不再使用控制器，而是使用组件。组件控制视图或视图的一部分。组件不是作为带有闭包的函数来构建控制器，而是作为JavaScript类来构建，这些类可以保存自定义Web元素的标记模板、仅限于某个组件的CSS样式、该组件使用的变量以及控制该组件行为的逻辑。和AngularJS控制器一样，当你试图确定哪些变量可用于页面的特定部分时，你需要检查组件，以及当这些变量发生变化时会发生什么变化。
###  认证模式
大多数身份验证逻辑通常位于专用于这些目的的服务中。例如，以下是Angular2 +身份验证服务的常见做法:
    ...
    export class AuthenticationService extends BaseService {
      constructor(private http: HttpClient, private router: Router) {
        super();
      }
      ...
      login(username: string, password: string) {
        return this.http.post('/api/auth/login', { username: username, password: password, email: email })
          .pipe(map((res: any) => {
              // successful if there's a jwt token in the response
            if (res && res.auth_token) {
              // store username and jwt token in local storage to keep user logged in between page refreshes
              localStorage.setItem('currentUser', JSON.stringify({ username, auth_token: res.auth_token }));
            }
          }));
      }
      logout() {
        // remove user from local storage to log user out
        localStorage.removeItem('currentUser');
        this.router.navigateByUrl('/login');
      }
      //...
    }
上面告诉我们，在成功进行身份验证尝试时，`currentUser`会保存一个对象`localStorage`。注销函数简单地删除了该对象，因此迫使客户端向应用编程接口发送另一个请求来获取新令牌。这也告诉我们，注销后会话在服务器中可能不会失效。
请注意注销功能是如何强制重定向到登录页面的。如果我们在本地存储中手动添加`currentUser`会发生什么？应用程序是否允许您查看经过身份验证的路由？这些只是您在检查上述认证服务后可以查看的一些内容。
Angular 1.X中存在类似的模式，其在路由更改时检查身份验证。
    run(["$rootScope", "$location", "$templateCache", '$http',  function ($rootScope, $location, $templateCache,$http) {
        $.material.init();
        $rootScope.$on("$routeChangeError", function (event, next, previous, error) {
            if (error === "AUTH_REQUIRED" || error.status === 401) {
                $location.path("/login");
            }
        });
    }]);
另一种常见模式是使用Angular **拦截器**
进行授权。HTTP拦截器是每次提交请求和/或收到服务器响应时运行的函数。两种常见的拦截器是JWT拦截器和错误拦截器。错误拦截器可用于检测代码为401
(未授权）的响应，以通知客户端用户必须注销并重定向到登录页面：
    export class ErrorInterceptor implements HttpInterceptor {
      constructor(private authenticationService: AuthenticationService) { }
      intercept(request: HttpRequest, next: HttpHandler): Observable> {
        return next.handle(request).pipe(catchError(err => {
          if (err.status === 401) {
            // if any response has a code of 401, logout the user and reload the page, forcing a redirect to the login page
            this.authenticationService.logout();
            location.reload(true);
          }
          const error = err.error.message || err.statusText;
          return throwError(error);
        }))
      }
    }
虽然上面的拦截器看的是HTTP响应，但是JWT拦截器的工作是在所有的HTTP请求中包含一个JWT头令牌：
    export class JwtInterceptor implements HttpInterceptor {
      intercept(request: HttpRequest, next: HttpHandler): Observable> {
        // add authorization header with jwt token if available
        let currentUser = JSON.parse(localStorage.getItem('currentUser'));
        if (currentUser && currentUser.token) {
          request = request.clone({
            setHeaders: {
              Authorization: `Bearer ${currentUser.token}`
            }
          });
        }
        return next.handle(request);
      }
    }
同样，你可以使用这些信息来了解应用程序如何处理身份验证，如果可能的话，尝试更改功能，看看你是否能注意到对你的评估有价值的东西。
## 最后
希望这些信息能为你提供一些见解，有助于你将来对Angular应用的安全性评估。当你在网络应用程序中寻找安全漏洞时，理解Angular可以增加你的直觉。在这篇文章的第二部分，我们将探索一些方法，使用Angular提供的调试功能从浏览器控制台动态测试应用程序。