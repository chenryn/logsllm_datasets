## 保护模式下的内存管理但实模式有两个问题。其一是安全性。操作系统以及所有软件都运行在一起，相互之间可以随意修改对方的数据甚至程序指令，这样搞破坏就非常容易。其二是支持的软件复杂性低，同时可运行的软件数量少。一方面，软件越复杂，它的程序代码量就越多，需要的存储空间越大，甚至可能出现单个软件的大小超过计算机的可用内存，这时在实模式下就没法执行它。另一方面，哪怕单个软件可运行，但是一旦我们同时运行的软件多几个，操作系统对内存的需求量就会急剧增加。相比这么多软件加起来的内存需求量，内存的存储空间往往仍然是不足的。但是为什么平常我们可以毫无顾忌地不断打开新的软件，从来不曾担心过内存会不足呢？这就是保护模式的作用了。保护模式下，内存访问不再是直接通过物理内存，而是基于虚拟内存。虚拟内存模式下，整个内存空间被分成很多个连续的内存页。每个内存页大小是固定的，比如64K。这样，每次 CPU访问某个虚拟内存地址中的数据，它都会先计算出这是要访问哪个内存页，然后CPU再通过一个地址映射表，把虚拟的内存地址转为物理的内存地址，然后到这个物理内存地址去读取数据。地址映射表是一个数组，下标是内存页页号，值是该内存页对应的物理内存首地址。当然，也有可能某一个内存页对应的物理内存地址还不存在，这种情况叫缺页，没法读取数据，这时CPU 就会发起一个缺页的中断请求。![](Images/4b49c247f669d0f343a1d6bd54d75a3e.png){savepage-src="https://static001.geekbang.org/resource/image/ae/85/ae0a79ee0dabba34bca6a5de97d7af85.png"}这个缺页的中断请求会被操作系统接管。发生缺页时，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据。如果没有空闲的物理内存可以分配，它就会选择一个最久没有被访问的内存页进行淘汰。当然，淘汰前会把这个内存页的数据保存起来，因为下次 CPU访问这个被淘汰的内存页时一样会发生缺页中断请求，那时操作系统还要去恢复数据。通过这个虚拟内存的机制，操作系统并不需要一上来就把整个软件装进内存中，而是通过缺页中断按需加载对应的程序代码片段。多个软件同时运行的问题也解决了，内存不够用的时候，就把最久没有用过的内存页淘汰掉，腾出物理内存出来。运行软件的问题解决了。那么，操作系统如何分配内存给运行中的软件？其实，内存分配的问题也解决了，并不需要任何额外的机制。反正内存地址空间是虚拟的，操作系统可以一上来就给要运行的软件分配超级大的内存，你想怎么用随你。软件如果不用某个内存页，什么都不发生。软件一旦用了某个内存页，通过缺页中断，操作系统就分配真正的物理内存给它。通过引入虚拟内存及其缺页机制，CPU 很好地解决了操作系统和软件的配合关系。每个运行中的软件，我们把它叫进程，都有自己的地址映射表。也就是说，虚拟地址并不是全局的，而是每个进程有一个自己独立的虚拟地址空间。在保护模式下，计算机的基础架构体系和操作系统共同在努力做的一件事情，就是让每个软件"感觉"自己在独占整个计算机的资源。独立的虚拟地址空间很好地伪装了这一点：看起来我独自在享用所有内存资源。在实模式下的浮动地址的问题也解决了，软件可以假设自己代码加载的绝对地址是什么，不需要在加载的时候重新调整CPU 指令操作的地址。这和实模式很不一样。在实模式下，所有进程都在同在物理内存的地址空间里，它们相互可以访问对方的数据，修改甚至破坏对方的数据，进而导致其他进程（包括操作系统本身的进程）崩溃。内存是进程运行的基础资源，保持进程基础资源的独立性，是软件治理的最基础的要求。这也是保护模式之所以叫"保护"模式的原因。
## 架构思维上我们学到什么？虚拟内存它本质上要解决这样两个很核心的需求。其一，软件越来越大，我们需要考虑在外置存储上执行指令，而不是完整加载到内存中。但是外置存储一方面它的数据CPU并不知道怎么读；另一方面就算知道怎么读，也不知道它的数据格式是什么样的，这依赖文件系统的设计。让CPU 理解外置存储的实现细节？这并不是一个好的设计。其二，要同时运行的软件越来越多，计算机内存的供给与软件运行的内存需求相比，捉襟见肘。怎么才能把有限的内存的使用效率最大化？一个很容易想到的思路是把不经常使用的内存数据交换到外置存储。但是问题仍然是，CPU并不了解外置存储的实现细节，怎么才能把内存按需交换出去？通过把虚拟内存地址分页，引入缺页中断，我们非常巧妙地解决了这个问题。缺页中断很像是CPU 留给操作系统的回调函数，通过它对变化点实现了很好的开放性设计。
## 结语总结一下。我们今天先概要地阐述了计算机运行的全过程，并对每一步的核心意义做了简单的介绍。然后我们把话题转到我们这一节的重心：内存管理。谈内存管理，需要谈清楚两个核心问题：-   如何分配内存（给运行中的软件，避免它们发生资源争抢）；-   如何运行外置存储（比如硬盘）上的软件？我们分别就在实模式下和保护模式下的内存管理进行了讨论。如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。![](Images/66b9828c3d4de21b8f7a14213cf3c4e7.png){savepage-src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg"}
# 08 \| 操作系统内核与编程接口你好，我是七牛云许式伟。今天我们在开发软件的时候，已经处于一些基础的架构设计之中，像冯·诺依曼计算机体系，像操作系统和编程语言，这些都是我们开发一个应用程序所依赖的基础架构。在上一节第 7讲"[软件运行机制及内存管理](https://time.geekbang.org/column/article/93802)"中，我们着重介绍了软件是如何被运行起来的。**今天，我们着重聊一聊软件如何利用它所依赖的基础架构。****首先是冯·诺依曼计算机体系**，它由 "中央处理器 + 存储 +一系列的输入输出设备"构成。这一层，提供了编程接口的是中央处理器（CPU），编程接口是 CPU指令，但 CPU 指令非常难用。为此，人们发明了编程语言来降低 CPU 指令的使用门槛。编程语言面向人类，CPU指令面向机器，编译器负责将人类容易理解和掌握的编程语言的程序，翻译成机器能够理解的CPU 指令序列。**其次是编程语言**。虽然编程语言出现的起因是降低 CPU指令的使用门槛，第一门编程语言汇编语言的能力也很接近 CPU指令，但是语言的自然演化会越来越脱离 CPU所限制的条条框框，大部分语言都会演化出很多基础的算法库。比如，字符串算法库有：字符串连接（concat）、字符串子串（substring），字符串比较（compare）、字符串长度（length）等等。``{=html}