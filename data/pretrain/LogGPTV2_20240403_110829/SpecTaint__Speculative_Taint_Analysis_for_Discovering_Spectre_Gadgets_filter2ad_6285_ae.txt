s u f f i x [ ( T )−>p r e f i x s u f f i x m a p [
p r e f i x
BROTLI TRANSFORM PREFIX ID( T ,
I ) ] ] )
i n t B r o t l i T r a n s f o r m D i c t i o n a r y W o r d ( u i n t 8
c o n s t B r o t l i T r a n s f o r m s∗ t r a n s f o r m s ,
t∗ word ,
len ,
i n t
t∗ d s t ,
c o n s t
i n t
t r a n s f o r m i d x )
t∗ p r e f i x = BROTLI TRANSFORM PREFIX(
t r a n s f o r m i d x ) ;
Listing 5: Speculative BCB gadget found in Brotli.
Performance Overhead after Patching. Afterward, we ap-
plied a serialization tool to patch all reported gadget locations
in six programs and then compared the performance of six
programs after patching the reported gadgets. Speciﬁcally,
we used a modiﬁed version of Speculative Load Hardening
(SLH) [18] shipped with SpecFuzz and patched the pro-
grams. We only patched the gadgets reported by SpecFuzz
10
Fig. 3: The performance overhead after patching w.r.t native.
and SpecTaint, and compared the runtime performance with
fully hardened programs (patching all conditional branches).
In this experiment, we used benchmarks shipped with the
programs, if available, as well as test benchmarks provided by
SpecFuzz. Figure 3 shows the comparison results. As we can
see, patching the gadgets detected by SpecTaint introduces
negligible overhead, compared with patching gadgets detected
by SpecFuzz and full hardening. On average, the performance
overhead was reduced by 55% compared with SpecFuzz’s
patching and 73% compared with full hardening. As presented
in Table III, SpecTaint produced fewer gadget candidates
than SpecFuzz. Therefore, the runtime overhead introduced by
patching those gadgets were reduced greatly. We also found
that in some cases SLH patching introduces large runtime
overhead. For instance, SpecFuzz found three more gadget
candidates in HTTP, but the performance slowdown caused
by these three candidates is almost 60%. It is because these
three candidates are located on hot paths that are exercised
frequently. This also demonstrates the importance of high
precision in gadget detection.
E. Efﬁciency Evaluation
In this experiment, we evaluated the runtime performance
of SpecTaint on the six real-world applications. Since the
workﬂow of SpecTaint is fundamentally different from Spec-
Fuzz, it is not easy to have an end-to-end runtime comparison.
SpecFuzz extends the fuzzing technique and its fuzzing proce-
dure and gadget detector are closely coupled. While SpecTaint
is a detection tool and can receive test cases from fuzzers. In
this evaluation, we marked the user inputs as taint sources and
simulate speculative execution over tainted branches. Note that
SpecTaint is able to simulate speculative execution on every
conditional branch. The runtime of simulating speculative over
tainted branches is reasonable to reﬂect the efﬁciency because,
as presented in Table III, around 80% of detected gadgets are
enclosed by tainted branches (intra-process gadgets IV-B).
We collected several statistical results including the to-
tal number of executed branches at the normal mode, the
Lib Name
JSMN
Brotli
HTTP
LibHTP
YAML
SSL
# of Seeds
6204
100
944
155
2525
46
Binary Size
17K
440K
85K
549K
251K
11M
Analysis Time(h)
10.75
0.65
5.24
0.4
6.84
17.5
# of Branch
554017
33912
184044
108101
5311472
122694
# of Tainted Branch
178542
8900
22531
29836
604917
56914
# of Nested Branch
5498472
274948
94477
423263
30303111
189332
Path/Branch
31
31
5
14
50
4
Time/Path(ms)
7.0
8.6
200.0
3.4
0.8
432.0
TABLE V: Runtime Performance Results on real-world applications.
total number of tainted branches for speculative execution
simulation, the total number of nested branches explored in
speculative execution mode, and the number of speculative
execution paths on average to be explored. We also collected
the execution time for each simulated speculative execution
path. The execution time includes the taint analysis, path
exploration time, and gadget detection time.
Since SpecTaint extends a whole-system emulation plat-
form and performs dynamic taint analysis, by design it pays
more runtime overhead for speculative taint analysis. However,
as presented in Table V, we can see that SpecTaint
is
able to analyze large programs within a reasonable amount
of time. For example, for Brotli, SpecTaint ﬁnished 8,900
branches as switch points for speculative execution simulation
within 40 minutes. That means that SpecTaint can ﬁnish
the SE path exploration including state management,
taint
analysis, and pattern checking for one switch point within
0.04s. Besides, SpecTaint has reasonable analysis time. It
can ﬁnish the analysis within a few hours for most of the
programs; only JSMN and SSL exceed 10 hours. In fact, SSL
is substantially more complex than the other programs, and
running it in the emulator is already very slow. On average,
SpecTaint takes around 6.8 hours to analyze one program.
Compared with SpecFuzz, which takes 10 hours to reproduce
the results presented in Table III, the analysis time in Table V
suggests that SpecTaint can achieve precise simulation of
speculative execution and perform dynamic speculative taint
analysis without introducing much overhead.
F. Case Study
As presented in Table III, SpecTaint discovered 11 new
Spectre gadgets that were not detected by SpecFuzz [39].
After manual inspection, we conﬁrmed that ten of them are
exploitable and one gadget is considered a false positive (not
exploitable, see VII). In this section, we showcase one detected
Spectre gadget from Real-world V1 Dataset due to the page
limitation. To further demonstrate the capability of SpecTaint,
we present one Spectre gadget detected by SpecTaint from a
well-known machine learning framework, Caffe [1].
Speculative BCB in BROTLI. Brotli is a generic-purpose
lossless compression program. SpecTaint found an exploitable
in function ProcessCommandsInternal and
Spectre gadget
BrotliTransformDictionaryWord. Listing 5 presents the relevant
code snippets. Before calling the function BrotliTransformDic-
tionaryWord at line 11, it ﬁrst checks whether transform -
idx is less than num transforms to avoid potential
overﬂow. In function BrotliTransformDictionaryWord, it uses
transform idx as index to perform two memory ac-
cesses using a macro BROTLI TRANSFORM PREFIX (load
a value from an array using transform idx, then uses
the loaded value as index to read another array). If the
branch at line 5 was mispredicted during speculative execu-
tion, BROTLI TRANSFORM PREFIX would perform out-of-
bound memory access and leak the loaded value via converted
cache side channels.
In this example, three properties make this Spectre gadget
exploitable. Firstly, transform idx is marked as tainted,
which is propagated from user inputs. This means the attacker
can control its value by manipulating the input. Secondly,
computing the branch outcome at line 5 may take hundreds
of CPU cycles, when transforms->num transforms
is not in cache and needs to be fetched from memory. Thus
it opens a large speculative execution window and allows the
execution of the following gadget during speculative execution.
Finally, the macro BROTLI TRANSFORM PREFIX loads the
out-of-bound value using transform idx as an index, then
use the loaded value as an index to access another array;
it ﬁrst reads potential secret via an out-of-bound memory
access and leaks the secret by using the secret as an index
to access another array. Thus, the attacker can retrieve the
secret via the cache side channel. As mentioned, this gadget
is newly detected by SpecTaint. Although it is hard to ﬁnd
the reason why SpecFuzz missed this gadget, we speculate
that SpecFuzz failed to detect it due to incomplete speculative
execution simulation. As discussed earlier, SpecFuzz favors
fuzzing throughput by adopting a lightweight speculative ex-
ecution simulation strategy, which selectively overlooks some
speculative paths.
t e m p l a t e 
1
2 v o i d S o l v e r :: UpdateSmoothedLoss ( Dtype l o s s ,
i n t
l o s s ) {
i t e r ,
a v e r a g e
s t a r t
i n t
i f
( l o s s e s
l o s s e s
i n t
smoothed loss
l o s s ) {
. s i z e ( ) > code
c o d e