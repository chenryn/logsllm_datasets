作者：爬虫  
来源：[知乎专栏“区块链开发之北”](https://zhuanlan.zhihu.com/p/35989258?utm_source=wechat_session&utm_medium=social&wechatShare=2&from=groupmessage&isappinstalled=0
"知乎专栏“区块链开发之北”")
现在进入你还是先行者，最后观望者进场才是韭菜。 美图董事长蔡文胜曾在三点钟群，高调的说出了这句话，随即被大众疯传。
在他发表完言论没多久，2月美链（BEC）上交易所会暴涨4000%，后又暴跌。尽管他多次否认，聪明的网友早已扒出，他与BEC千丝万缕的关系。
庄家坐庄操控币价，美图的股价随之暴涨，蔡文胜顺利完成了他的韭菜收割大计。
但在币圈，割人者，人恒割之。
随着BEC智能合约的漏洞的爆出，被黑客利用，瞬间套现抛售大额BEC，60亿在瞬间归零。
而这一切，竟然是因为一个简单至极的程序Bug。
#### 背景
今天有人在群里说，[Beauty Chain
美蜜](https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d
"Beauty Chain 美蜜") 代码里面有bug，已经有人利用该bug获得了
57,896,044,618,658,100,000,000,000,000,000,000,000,000,000,000,000,000,000,000.792003956564819968
个 BEC
那笔操作记录是
[0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f](https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f
"0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f")
下面我来带大家看看，黑客是如何实现的！
我们可以看到执行的方法是 `batchTransfer`
那这个方法是干嘛的呢？（给指定的几个地址，发送相同数量的代币）
#### 整体逻辑是
你传几个地址给我(receivers),然后再传给我你要给每个人多少代币（value)
然后你要发送的总金额 = 发送的人数* 发送的金额
然后 要求你当前的余额大于 发送的总金额
然后扣掉你发送的总金额
然后 给receivers 里面的每个人发送 指定的金额（value)
从逻辑上看，这边是没有任何问题的，你想给别人发送代币，那么你本身的余额一定要大于发送的总金额的！
但是这段代码却犯了一个很傻的错!
#### 代码解释
这个方法会传入两个参数
  1. _receivers
  2. _value
_receivers 的值是个列表，里面有两个地址
[0x0e823ffe018727585eaf5bc769fa80472f76c3d7](https://etherscan.io/token/0xc5d105e63711398af9bbff092d4b6769c82f793d?a=0x0e823ffe018727585eaf5bc769fa80472f76c3d7
"0x0e823ffe018727585eaf5bc769fa80472f76c3d7")
[0xb4d30cac5124b46c2df0cf3e3e1be05f42119033](https://etherscan.io/token/0xc5d105e63711398af9bbff092d4b6769c82f793d?a=0xb4d30cac5124b46c2df0cf3e3e1be05f42119033
"0xb4d30cac5124b46c2df0cf3e3e1be05f42119033")
_value 的值是 `8000000000000000000000000000000000000000000000000000000000000000`
我们再查看代码（如下图）
我们一行一行的来解释
`uint cnt = _receivers.length;`
是获取 _receivers 里面有几个地址，我们从上面可以看到 参数里面只有两个地址，所以 cnt=2，也就是 给两个地址发送代币
`uint256 amount = uint256(cnt) * _value;`
#### uint256
首先 `uint256(cnt)` 是把cnt 转成了 uint256类型
那么,什么是uint256类型？或者说uint256类型的取值范围是多少...
uintx 类型的取值范围是 0 到 2的x次方 -1
也就是 假如是 uint8的话
则 uint8的取值范围是 0 到 2的8次方 -1
也就是 0 到255
那么uint256 的取值范围是
0 - 2的256次方-1 也就是 `0
到115792089237316195423570985008687907853269984665640564039457584007913129639935`
python 算 2的256次方是多少
那么假如说 设置的值超过了 取值范围怎么办？这种情况称为 溢出
举个例子来说明
因为uint256的取值太大了，所以用uint8来 举例。。。
从上面我们已经知道了 uint8 最小是0，最大是255
那么当我 255 + 1 的时候，结果是啥呢？结果会变成0
那么当我 255 + 2 的时候，结果是啥呢？结果会变成1
那么当我 0 - 1 的时候，结果是啥呢？结果会变成255
那么当我 0 - 2 的时候，结果是啥呢？结果会变成255
那么 我们回到上面的代码中，
`amount = uint256(cnt) * _value`
则 `amount = 2* _value`
但是此时 _value 是16进制的，我们把他转成 10进制
（python 16进制转10进制）
可以看到 `_value =
57896044618658097711785492504343953926634992332820282019728792003956564819968`
那么`amount = _value*2 =
115792089237316195423570985008687907853269984665640564039457584007913129639936`
可以在查看上面看到 uint256取值范围最大为
`115792089237316195423570985008687907853269984665640564039457584007913129639935`
此时，amout已经超过了最大值，溢出 则 `amount = 0`
下一行代码 `require(cnt > 0 && cnt  0 && balances[msg.sender] >= amount);`
这句要求 value 大于0，我们的value是大于0 的 且,当前用户拥有的代币余额大于等于 amount,因为amount等于0，所以
就算你一个代币没有，也是满足的！
`balances[msg.sender] = balances[msg.sender].sub(amount);`
这句是当前用户的余额 - amount
当前amount 是0，所以当前用户代币的余额没有变动
    for (uint i = 0; i 
* * *