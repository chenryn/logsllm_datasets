marks when HEAPTHERAPY+ runs. The average memory overhead is 4.3%.
overhead is only 5.2%, most of which is due to interposing al-
location/deallocation and maintaining metadata; it means that
the overhead can be further reduced if our system is integrated
into the underlying heap allocator. The throughput overhead
on real-world service programs is very low or negligible.
IX. DISCUSSION
A limitation of HEAPTHERAPY+ is that it can only handle
the overﬂow caused by continuous writes or reads, which is
the main form of buffer overﬂows, though. Overﬂows due to
discrete reads or writes cannot be handled by HEAPTHER-
APY+. Plus, if an overﬂow runs over an array which is an
internal ﬁeld of a structure, HEAPTHERAPY+ cannot detect it.
These limitations are shared by many existing countermeasures
against buffer overﬂows, such as AddressSanitizer [8] and
HeapTherapy [19]. A common challenge for heap security
tools that work via interception of allocation calls is to
make them work with custom allocators. Existing works like
MemBrush [61] may be leveraged to locate custom memory
allocations and address this challenge.
More precisely, the patches generated by HEAPTHERAPY+
are conﬁgurable runtime defenses, since they do not com-
pletely ﬁx a bug (e.g., DoS can still be triggered via overﬂows).
Our goal is not to replace conventional patching. Instead,
it is to complement the conventional patching procedure by
providing immediate protection when patches are not available
or fresh patches still need more time for testing.
540
It may occur that a heap vulnerability can be exploited
via multiple CCIDs. Thus, the attacker may develop different
attack inputs to exploit buffers with those CCIDs. However,
whenever the attack exploits a buffer allocated in a new calling
context, our system simply treats it as a new vulnerability
and starts another defense generation cycle. Based on our
evaluation and previous researches on context-sensitive de-
fenses [19], [33], [40], [48], such cases are rare.
When analyzing the use-after-free attack for programs that
have large memory proﬁles, the memory quota for the FIFO
queue of freed blocks may be drained. In this case, we can
replay attacks in multiple executions; speciﬁcally, we divide
the whole space of CCIDs into N subspaces, and each of the
N executions defers the deallocation of buffers that have the
allocation-time CCIDs in one of the subspaces. Now, each
execution is expected to consume 1/N of the memory.
X. CONCLUSIONS
We have combined heavyweight ofﬂine attack analysis and
lightweight online defense generation to build a new heap
memory defense system HEAPTHERAPY+. It demonstrates
how shadow memory that incurs tens of times of slowdown can
be used for generating defenses that imposes a very small over-
head. It has many prominent advantages: (1) patch generation
without manual efforts, (2) code-less patching, (3) versatile
handling of heap buffer overwrite, overread, use after free,
and uninitialized read, (4) imposing a very small overhead,
and (5) no dependency on speciﬁc allocators. The evaluation
shows that is effective and efﬁcient. The speed overhead is
only 5.2% when ﬁve patches are installed on SPEC CPU2006
benchmarks, and the overhead can be further reduced is the
system is integrated into the underlying allocator.
In addition, we have proposed targeted calling context
encoding, which achieves six times of speed boost compared
to the prior encoding technique and may interest researchers
applying or building calling context encoding techniques.
ACKNOWLEDGMENT
This project was supported by NSF CNS-1815144 and NSF
CNS-1856380. We thank the anonymous reviewers for their
invaluable comments and constructive suggestions.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:53:42 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier,
P. Wagle, Q. Zhang, and H. Hinton, “Stackguard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks.” in USENIX Security
Symposium, 1998, pp. 63–78.
[2] PaX, “The PaX project,” https://pax.grsecurity.net/.
[3] Microsoft, “Directives Reference,” https://msdn.microsoft.com/en-us/
library/16aexws6.aspx.
[4] Codenomicon, “The Heartbleed Bug,” http://heartbleed.com/.
[5] N. Grossman, “EternalBlue Everything There Is To Know,” https://
research.checkpoint.com/eternalblue-everything-know/.
[6] R. Roemer, E. Buchanan, H. Shacham, and S. Savage, “Return-oriented
programming: Systems, languages, and applications,” ACM Transactions
on Information and System Security (TISSEC), vol. 15, no. 1, p. 2, 2012.
[7] Linux, “mallopt-Linux man page,” https://linux.die.net/man/3/mallopt.
[8] K. Serebryany, D. Bruening, A. Potapenko, and D. D. Vyukov, “Ad-
dressSanitizer: A Fast Address Sanity Checker,” in USENIX ATC, 2012,
pp. 309–318.
[9] T. Liu, C. Curtsinger, and E. D. Berger, “Doubletake: fast and precise
error detection via evidence-based dynamic analysis,” in 38th Interna-
tional Conference on Software Engineering (ICSE), 2016, pp. 911–922.
[10] Q. Zeng, D. Wu, and P. Liu, “Cruiser: Concurrent Heap Buffer Overﬂow
Monitoring Using Lock-free Data Structures,” in Proceedings of the
32Nd ACM SIGPLAN Conference on Programming Language Design
and Implementation (PLDI), 2011, pp. 367–377.
[11] D. Tian, Q. Zeng, D. Wu, P. Liu, and C. Hu, “Kruiser: Semi-
synchronized Non-blocking Concurrent Kernel Heap Buffer Overﬂow
Monitoring,” in Proceedings of the 19th Annual Network and Distributed
System Security Symposium (NDSS), 2012.
[12] E. D. Berger and B. G. Zorn, “DieHard: Probabilistic Memory Safety
for Unsafe Languages,” in Proceedings of the 27th ACM SIGPLAN
Conference on Programming Language Design and Implementation
(PLDI), 2006, pp. 158–168.
[13] G. Novark and E. D. Berger, “DieHarder: Securing the Heap,” in
Proceedings of the 17th ACM Conference on Computer and Commu-
nications Security (CCS), 2010, pp. 573–584.
[14] S. Silvestro, H. Liu, C. Crosser, Z. Lin, and T. Liu, “FreeGuard: A
Faster Secure Heap Allocator,” in Proceedings of the ACM SIGSAC
Conference on Computer and Communications Security (CCS), 2017,
pp. 2389–2403.
[15] P. Akritidis, “Cling: A memory allocator to mitigate dangling pointers.”
in USENIX Security Symposium, 2010, pp. 177–192.
[16] Y. Younan, “FreeSentry: Protecting Against Use-After-Free Vulnerabil-
ities Due to Dangling Pointers,” in Proceedings of the 22nd Network
and Distributed System Security Symposium (NDSS), 2015.
[17] E. van der Kouwe, V. Nigade, and C. Giuffrida, “DangSan: Scalable Use-
after-free Detection,” in Proceedings of the 12th European Conference
on Computer Systems (EuroSys), 2017, pp. 405–419.
[18] B. Lee, C. Song, Y. Jang, T. Wang, T. Kim, L. Lu, and W. Lee, “Prevent-
ing Use-after-free with Dangling Pointers Nulliﬁcation.” in Proceedings
of the 22nd Annual Network and Distributed System Security Symposium
(NDSS), 2015.
[19] Q. Zeng, M. Zhao, and P. Liu, “HeapTherapy: An Efﬁcient End-to-End
Solution against Heap Buffer Overﬂows,” in 45th Annual IEEE/IFIP
International Conference on Dependable Systems and Networks (DSN),
2015, pp. 485–496.
[20] E. Stepanov and K. Serebryany, “MemorySanitizer: fast detector of
uninitialized memory use in C++,” in Proceedings of the 13th Annual
IEEE/ACM International Symposium on Code Generation and Optimiza-
tion (CGO), 2015, pp. 46–55.
[21] K. Lu, C. Song, T. Kim, and W. Lee, “UniSan: Proactive Kernel Memory
Initialization to Eliminate Data Leakages,” in Proceedings of the ACM
SIGSAC Conference on Computer and Communications Security (CCS),
2016, pp. 920–932.
[22] A. Milburn, H. Bos, and C. Giuffrida, “SafeInit: Comprehensive and
Practical Mitigation of Uninitialized Read Vulnerabilities,” in Proceed-
ings of the 24th Network and Distributed System Security Symposium
(NDSS), 2017.
[23] N. Nethercote and J. Seward, “Valgrind: A Framework for Heavyweight
Dynamic Binary Instrumentation,” in Proceedings of the 28th ACM
SIGPLAN Conference on Programming Language Design and Imple-
mentation (PLDI), 2007, pp. 89–100.
[24] Q. Zeng, M. Zhao, and P. Liu, “Poster: Targeted therapy for program
bugs,” in the 35th IEEE Symposium on Security and Privacy, 2014.
[25] S. Sidiroglou, G. Giovanidis, and A. D. Keromytis, “A dynamic mech-
anism for recovering from buffer overﬂow attacks,” in International
Conference on Information Security, 2005, pp. 1–15.
[26] S. Frei, “The Known Unknowns,” https://www.techzoom.net/Papers/
The Known Unknowns (2013).pdf, 2013.
[27] ——, “End-point security failures,
insight gained from secunia psi
scans,” in Predict Workshop, February, 2011.
[28] L. Bilge and T. Dumitras, “Before we knew it: an empirical study
of zero-day attacks in the real world,” in Proceedings of the ACM
conference on Computer and communications security (CCS), 2012, pp.
833–844.
[29] S. Beattie, S. Arnold, C. Cowan, P. Wagle, C. Wright, and A. Shostack,
“Timing the application of security patches for optimal uptime.” in LISA,
vol. 2, 2002, pp. 233–242.
[30] M. D. Bond and K. S. McKinley, “Probabilistic Calling Context,”
in Proceedings of the 22nd Annual ACM SIGPLAN Conference on
Object-Oriented Programming, Systems, Languages, and Applications
(OOPSLA), 2007, pp. 97–112.
[31] W. N. Sumner, Y. Zheng, D. Weeratunge, and X. Zhang, “Precise calling
context encoding,” in the 32nd International Conference on Software
Engineering (ICSE), 2010, pp. 525–534.
[32] Q. Zeng, J. Rhee, H. Zhang, N. Arora, G. Jiang, and P. Liu, “DeltaPath:
Precise and Scalable Calling Context Encoding,” in Proceedings of
Annual IEEE/ACM International Symposium on Code Generation and
Optimization (CGO), 2014, pp. 109–119.
[33] G. Novark, E. D. Berger, and B. G. Zorn, “Exterminator: automatically
correcting memory errors with high probability,” in Proceedings of
the Conference on Programming Language Design and Implementation
(PLDI), 2007, pp. 1–11.
[34] C. Kreibich and J. Crowcroft, “Honeycomb: creating intrusion detection
signatures using honeypots,” Computer Communication Review, vol. 34,
no. 1, pp. 51–56, 2004.
[35] H.-A. Kim and B. Karp, “Autograph: Toward Automated, Distributed
Worm Signature Detection,” in Proceedings of the 13th Conference on
USENIX Security Symposium - Volume 13, ser. SSYM’04. USENIX
Association, 2004, p. 19.
[36] J. Newsome, B. Karp, and D. Song, “Polygraph: automatically generat-
ing signatures for polymorphic worms,” in IEEE Symposium on Security
and Privacy (S&P), 2005, pp. 226–241.
[37] Z. Liang and R. Sekar, “Fast and Automated Generation of Attack Sig-
natures: A Basis for Building Self-protecting Servers,” in Proceedings of
the 12th ACM Conference on Computer and Communications Security
(CCS), 2005, pp. 213–222.
[38] Z. Li, M. Sanghi, Y. Chen, M.-Y. Kao, and B. Chavez, “Hamsa: fast
signature generation for zero-day polymorphic worms with provable
attack resilience,” in IEEE Symposium on Security and Privacy (S&P),
2006, pp. 15–29.
[39] J. Newsome, D. Song, J. Newsome, and D. Song, “Dynamic taint
analysis: Automatic detection, analysis, and signature generation of
exploit attacks on commodity software,” in Proceedings of the 12th
Network and Distributed Systems Security Symposium (NDSS), 2005.
[40] J. Xu, P. Ning, C. Kil, Y. Zhai, and C. Bookholt, “Automatic Diagnosis
and Response to Memory Corruption Vulnerabilities,” in Proceedings of
the 12th ACM Conference on Computer and Communications Security
(CCS), 2005, pp. 223–234.
[41] J. Newsome, D. Brumley, and D. Song, “Vulnerability-Speciﬁc Exe-
cution Filtering for Exploit Prevention on Commodity Software,” in
Proceedings of the 13th Symposium on Network and Distributed System
Security (NDSS), 2006.
[42] M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou, L. Zhang,
and P. Barham, “Vigilante: End-to-end Containment of Internet Worms,”
in Proceedings of the Twentieth ACM Symposium on Operating Systems
Principles (SOSP), 2005, pp. 133–147.
[43] A. Smirnov and T. Chiueh, “Automatic Patch Generation for Buffer
Overﬂow Attacks,” in Third International Symposium on Information
Assurance and Security, 2007, pp. 165–170.
[44] Z. Lin, X. Jiang, D. Xu, B. Mao, and L. Xie, “AutoPaG: Towards
Automated Software Patch Generation with Source Code Root Cause
Identiﬁcation and Repair,” in Proceedings of the 2nd ACM Symposium
on Information, Computer and Communications Security, 2007, pp. 329–
340.
[45] W. Weimer, T. Nguyen, C. L. Goues, and S. Forrest, “Automatically
ﬁnding patches using genetic programming,” in 31st International Con-
ference on Software Engineering (ICSE), 2009, pp. 364–374.
541
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:53:42 UTC from IEEE Xplore.  Restrictions apply. 
[46] D. Kim, J. Nam, J. Song, and S. Kim, “Automatic patch generation
learned from human-written patches,” in 35th International Conference
on Software Engineering (ICSE), 2013, pp. 802–811.
[47] F. Long and M. Rinard, “Automatic patch generation by learning correct
code,” in Proceedings of
the 43rd Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages (POPL), 2016,
pp. 298–312.
[48] F. Qin, J. Tucek, J. Sundaresan, and Y. Zhou, “Rx: treating bugs as
allergies - a safe method to survive software failures,” in Proceedings
of the 20th ACM Symposium on Operating Systems Principles (SOSP),
2005, pp. 235–248.
[49] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe, J. Bachrach,
M. Carbin, C. Pacheco, F. Sherwood, S. Sidiroglou, G. Sullivan et al.,
“Automatically patching errors in deployed software,” in Proceedings
of the ACM 22nd Symposium on Operating Systems Principles (SOSP),
2009, pp. 87–102.
[50] T. Ball and J. R. Larus, “Efﬁcient path proﬁling,” in Proceedings of the
29th annual ACM/IEEE International Symposium on Microarchitecture
(Micro), 1996, pp. 46–57.
[51] T. Mytkowicz, D. Coughlin, and A. Diwan, “Inferred call path proﬁling,”
in Proceedings of
the 24th Annual ACM SIGPLAN Conference on
Object-Oriented Programming, Systems, Languages, and Applications
(OOPSLA), 2009, pp. 175–190.
[52] M. L. Seidl and B. G. Zorn, “Segregating heap objects by reference be-
havior and lifetime,” in Proceedings of the 8th International Conference
on Architectural Support for Programming Languages and Operating
Systems (ASPLOS), 1998, pp. 12–23.
[53] H. H. Feng, O. M. Kolesnikov, P. Fogla, W. Lee, and W. Gong, “Anomaly
[54] N. Nethercote and J. Seward, “How to Shadow Every Byte of Memory
Used by a Program,” in Proceedings of the 3rd International Conference
on Virtual Execution Environments (VEE), 2007, pp. 65–74.
[55] N. Bettenburg, S. Just, A. Schr¨oter, C. Weiss, R. Premraj, and T. Zim-
mermann, “What makes a good bug report?” in Proceedings of the 16th
ACM SIGSOFT International Symposium on Foundations of software
engineering (FSE), 2008, pp. 308–318.
[56] B. Buck and J. K. Hollingsworth, “An API for runtime code patching,”
The International Journal of High Performance Computing Applications,
vol. 14, no. 4, pp. 317–329, 2000.
[57] S. Lu, Z. Li, F. Qin, L. Tan, P. Zhou, and Y. Zhou, “Bugbench:
Benchmarks for evaluating bug detection tools,” in In Workshop on the
Evaluation of Software Defect Detection Tools, 2005.
detection using call stack information,” in Symposium on Security and
Privacy (S&P), 2003, pp. 62–75.
[58] NIST, “SAMATE Reference Dataset,” http://samate.nist.gov/SRD.
[59] Z. Durumeric, F. Li, J. Kasten, J. Amann, J. Beekman, M. Payer,
N. Weaver, D. Adrian, V. Paxson, M. Bailey, and J. A. Halderman,
“The Matter of Heartbleed,” in Proceedings of the 2014 Conference on
Internet Measurement Conference, 2014, pp. 475–488.
[60] J. Wang, M. Zhao, Q. Zeng, D. Wu, and P. Liu, “Risk Assessment
of Buffer Heartbleed Over-Read Vulnerabilities,” in the 45th Annual
IEEE/IFIP International Conference on Dependable Systems and Net-
works (DSN), 2015, pp. 555–562.
[61] X. Chen, A. Slowinska, and H. Bos, “On the Detection of Custom
Memory Allocators in C Binaries,” Empirical Software Engineering,
vol. 21, no. 3, pp. 753–777, 2016.
542
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:53:42 UTC from IEEE Xplore.  Restrictions apply.