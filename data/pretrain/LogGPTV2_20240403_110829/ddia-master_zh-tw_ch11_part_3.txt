### 分割槽日志
透过网路传送资料包或向网路服务传送请求通常是短暂的操作，不会留下永久的痕迹。尽管可以永久记录（透过抓包与日志），但我们通常不这么做。即使是将讯息持久地写入磁碟的讯息代理，在送达给消费者之后也会很快删除讯息，因为它们建立在短暂讯息传递的思维方式上。
资料库和档案系统采用截然相反的方法论：至少在某人显式删除前，通常写入资料库或档案的所有内容都要被永久记录下来。
这种思维方式上的差异对建立衍生资料的方式有巨大影响。如 [第十章](ch10.md) 所述，批处理过程的一个关键特性是，你可以反复执行它们，试验处理步骤，不用担心损坏输入（因为输入是只读的）。而 AMQP/JMS 风格的讯息传递并非如此：收到讯息是具有破坏性的，因为确认可能导致讯息从代理中被删除，因此你不能期望再次运行同一个消费者能得到相同的结果。
如果你将新的消费者新增到讯息传递系统，通常只能接收到消费者注册之后开始传送的讯息。先前的任何讯息都随风而逝，一去不复返。作为对比，你可以随时为档案和资料库新增新的客户端，且能读取任意久远的资料（只要应用没有显式覆盖或删除这些资料）。
为什么我们不能把它俩杂交一下，既有资料库的持久储存方式，又有讯息传递的低延迟通知？这就是 **基于日志的讯息代理（log-based message brokers）** 背后的想法。
#### 使用日志进行讯息储存
日志只是磁碟上简单的仅追加记录序列。我们先前在 [第三章](ch3.md) 中日志结构储存引擎和预写式日志的上下文中讨论了日志，在 [第五章](ch5.md) 复制的上下文里也讨论了它。
同样的结构可以用于实现讯息代理：生产者透过将讯息追加到日志末尾来发送讯息，而消费者透过依次读取日志来接收讯息。如果消费者读到日志末尾，则会等待新讯息追加的通知。Unix 工具 `tail -f` 能监视档案被追加写入的资料，基本上就是这样工作的。
为了伸缩超出单个磁碟所能提供的更高吞吐量，可以对日志进行 **分割槽**（按 [第六章](ch6.md) 的定义）。不同的分割槽可以托管在不同的机器上，使得每个分割槽都有一份能独立于其他分割槽进行读写的日志。一个主题可以定义为一组携带相同型别讯息的分割槽。这种方法如 [图 11-3](../img/fig11-3.png) 所示。
在每个分割槽内，代理为每个讯息分配一个单调递增的序列号或 **偏移量**（offset，在 [图 11-3](../img/fig11-3.png) 中，框中的数字是讯息偏移量）。这种序列号是有意义的，因为分割槽是仅追加写入的，所以分割槽内的讯息是完全有序的。没有跨不同分割槽的顺序保证。
![](../img/fig11-3.png)
**图 11-3 生产者透过将讯息追加写入主题分割槽档案来发送讯息，消费者依次读取这些档案**
Apache Kafka 【17,18】、Amazon Kinesis Streams 【19】和 Twitter 的 DistributedLog 【20,21】都是基于日志的讯息代理。Google Cloud Pub/Sub 在架构上类似，但对外暴露的是 JMS 风格的 API，而不是日志抽象【16】。尽管这些讯息代理将所有讯息写入磁碟，但透过跨多台机器分割槽，每秒能够实现数百万条讯息的吞吐量，并透过复制讯息来实现容错性【22,23】。
#### 日志与传统的讯息传递相比
基于日志的方法天然支援扇出式讯息传递，因为多个消费者可以独立读取日志，而不会相互影响 —— 读取讯息不会将其从日志中删除。为了在一组消费者之间实现负载平衡，代理可以将整个分割槽分配给消费者组中的节点，而不是将单条讯息分配给消费者客户端。
然后每个客户端将消费被指派分割槽中的 **所有** 讯息。通常情况下，当一个使用者被指派了一个日志分割槽时，它会以简单的单执行绪方式顺序地读取分割槽中的讯息。这种粗粒度的负载均衡方法有一些缺点：
* 共享消费主题工作的节点数，最多为该主题中的日志分割槽数，因为同一个分割槽内的所有讯息被递送到同一个节点 [^i]。
* 如果某条讯息处理缓慢，则它会阻塞该分割槽中后续讯息的处理（一种行首阻塞的形式；请参阅 “[描述效能](ch1.md#描述效能)”）。
因此在讯息处理代价高昂，希望逐条并行处理，以及讯息的顺序并没有那么重要的情况下，JMS/AMQP 风格的讯息代理是可取的。另一方面，在讯息吞吐量很高，处理迅速，顺序很重要的情况下，基于日志的方法表现得非常好。
[^i]: 要设计一种负载均衡方案也是有可能的，在这种方案中，两个消费者透过读取全部讯息来共享分割槽处理的工作，但是其中一个只考虑具有偶数偏移量的讯息，而另一个消费者只处理奇数编号的偏移量。或者你可以将讯息摊到一个执行绪池中来处理，但这种方法会使消费者偏移量管理变得复杂。一般来说，单执行绪处理单分割槽是合适的，可以透过增加更多分割槽来提高并行度。
#### 消费者偏移量
顺序消费一个分割槽使得判断讯息是否已经被处理变得相当容易：所有偏移量小于消费者的当前偏移量的讯息已经被处理，而具有更大偏移量的讯息还没有被看到。因此，代理不需要跟踪确认每条讯息，只需要定期记录消费者的偏移即可。这种方法减少了额外簿记开销，而且在批处理和流处理中采用这种方法有助于提高基于日志的系统的吞吐量。
实际上，这种偏移量与单领导者资料库复制中常见的日志序列号非常相似，我们在 “[设定新从库](ch5.md#设定新从库)” 中讨论了这种情况。在资料库复制中，日志序列号允许跟随者断开连线后，重新连线到领导者，并在不跳过任何写入的情况下恢复复制。这里原理完全相同：讯息代理表现得像一个主库，而消费者就像一个从库。
如果消费者节点失效，则失效消费者的分割槽将指派给其他节点，并从最后记录的偏移量开始消费讯息。如果消费者已经处理了后续的讯息，但还没有记录它们的偏移量，那么重启后这些讯息将被处理两次。我们将在本章后面讨论这个问题的处理方法。
#### 磁碟空间使用
如果只追加写入日志，则磁碟空间终究会耗尽。为了回收磁碟空间，日志实际上被分割成段，并不时地将旧段删除或移动到归档储存。（我们将在后面讨论一种更为复杂的磁碟空间释放方式）
这就意味著如果一个慢消费者跟不上讯息产生的速率而落后得太多，它的消费偏移量指向了删除的段，那么它就会错过一些讯息。实际上，日志实现了一个有限大小的缓冲区，当缓冲区填满时会丢弃旧讯息，它也被称为 **回圈缓冲区（circular buffer）** 或 **环形缓冲区（ring buffer）**。不过由于缓冲区在磁碟上，因此缓冲区可能相当的大。
让我们做个简单计算。在撰写本文时，典型的大型硬碟容量为 6TB，顺序写入吞吐量为 150MB/s。如果以最快的速度写讯息，则需要大约 11 个小时才能填满磁碟。因而磁碟可以缓冲 11 个小时的讯息，之后它将开始覆盖旧的讯息。即使使用多个磁碟和机器，这个比率也是一样的。实践中的部署很少能用满磁碟的写入频宽，所以通常可以储存一个几天甚至几周的日志缓冲区。
不管保留多长时间的讯息，日志的吞吐量或多或少保持不变，因为无论如何，每个讯息都会被写入磁碟【18】。这种行为与预设将讯息储存在记忆体中，仅当伫列太长时才写入磁碟的讯息传递系统形成鲜明对比。当伫列很短时，这些系统非常快；而当这些系统开始写入磁碟时，就要慢的多，所以吞吐量取决于保留的历史数量。
#### 当消费者跟不上生产者时
在 “[讯息传递系统](#讯息传递系统)” 中，如果消费者无法跟上生产者传送资讯的速度时，我们讨论了三种选择：丢弃资讯，进行缓冲或施加背压。在这种分类法里，基于日志的方法是缓冲的一种形式，具有很大但大小固定的缓冲区（受可用磁碟空间的限制）。