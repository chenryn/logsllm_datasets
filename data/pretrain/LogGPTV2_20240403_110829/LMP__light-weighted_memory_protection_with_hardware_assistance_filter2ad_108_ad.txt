kBouncer [26] uses the Last Branch Record (LBR) x86 reg-
ister that stores recent branches that CPU executed. It vali-
dates if the return address points to an instruction follows a
call instruction, so the procedure is actually a heuristic mit-
igation of ROP attack. Using the same LBR register and
similar policy as kBouncer, the work of ROPecker [6] adds
additional static analysis to speculate future execution of a
program to defend against ROP gadgets running, unfortu-
nately however, is by-passible too [12]. The ROPGuard [16]
proposes to check if the stack pointer points to a memory
address outside of the stack, so the system would not allow
ROP attackers execute payloads on the heap, however, be-
467fore the target function is called the adversaries could still
modify the stack pointer. The above defenses are also vul-
nerable to attacks that leverage hooks and hide malicious
code within non-control data [36], if critical memory region
is not protected at runtime. O-CFI [25] explores random-
ization approach to conceal program control-ﬂow graph and
applies MPX in bound-checking for guarding the branch in-
structions. However, it is still a coarse-grained CFI method
and only provides probabilistic security guarantees since it
does not fully protect function return addresses. Our LMP
approach sticks to the original CFI policy in backward-edge
protection, i.e., checking every function return address and
ensuring the return address points to the function caller.
For forward-edge CFI protection, the paper that proposes
VTV [34] ﬁnds out more than 90% indirect calls are virtual
calls. Their method aims at protecting VTables from be-
ing hijacked, validates at runtime that the target VTables
in a legit set, before a virtual method call is made. Per-
formance of VTV depends on the size of legit VTable set,
so the complexity of C++ class hierarchy would aﬀect the
overhead. On the basis of the idea, VTrust [40] and VTable
Interleaving [3] improve the performance of VTV without
needing global class hierarchy, and prevent VTable hijack-
ing attacks. Our LMP system does not provide protection
with forward-edge CFI, because with above mentioned ap-
proaches, the LMP can be easily combined with them by
applying patches to the LMP-enabled compiler, thus a full-
CFI protection is possible.
There are CFI variants proposed with diﬀerent security
targets. The techniques of original CFI have been used for
the purpose of enforcing software-based fault isolation (S-
FI) [39]. XFI [14] also employs CFI policies with the help
of debugging information in Windows PDB ﬁles to defend
against ROP attacks. Data-ﬂow Integrity (DFI) [4] follows
CFI approach to prevent non-control data attacks. Hyper-
safe [38] is similar to ﬁne-grained CFI protection.
It has
a target table for indirect branches and aims at protecting
control-ﬂow integrity of hypervisor.
Code-Pointer Integrity (CPI) [23] explores a security mech-
anism that divides process memory into two parts:
safe
memory region and regular memory region. Through static
analysis, memory objects that have pointers including code
and data pointers are put into a safe memory region for
protection against illegal tampering. However, ﬂaws of CPI
approach have been pointed out [15] because its safe memo-
ry region is not well-protected. The essential idea of LMP is
also guarding the memory region where shadow stacks locat-
ed. We use new hardware feature of fast memory boundary
checking to ensure the allocated shadow stack region is pro-
tected eﬀectively and eﬃciently.
Other hardware-based CFI approaches have recently been
proposed, e.g., HCFI [8] and HAFIX [11] have their system
implemented running on customized FPGA board or SPAR-
C embedded system. In comparison, LMP is the ﬁrst system
with hardware-assisted memory protection compatible with
commercially available CPU and other hardware. Control-
Flow Enforcement Technology (CET) [21] was announced
in a technology preview as of June 2016. CET introduces a
new exception class (#CP) with interrupt vector 21 and a
new ENDBRANCH ISA instruction to help mark legal targets
for an indirect branch or jump. It also uses hardware pro-
tections to limit access to the shadow stack to only function
call and return instructions so that regular memory stores
are prohibited from modifying the shadow stack. Since CET
was only recently announced, and no hardware is available,
we are unable to evaluate the overhead of CET against LMP
at this time.
7. CONCLUSION
Memory protection is a keystone of all defense techniques
against memory corruption attacks. Without properly pro-
tecting the shadow stack, CFI approaches cannot eﬀectively
prevent ROP attackers and have been proven to be insecure
in general. Our work proposes a light-weighted memory pro-
tection system to prevent critical memory region storing re-
turn addresses of function call stacks, namely the shadow
stacks. Leveraging recent available MPX hardware features,
our approach achieves low overhead in enforcing only legal
accesses to the protected region is allowed, so that return ad-
dresses cannot be tampered with by an attacker. For future
work, we will complete the LMP protection on forwarding-
edge and explore the possibility of applying LMP without
the limitation of recompilation of the program, for exam-
ple, use the help of binary re-writing to perform the shadow
stack functions for protection.
Acknowledgement
We would like to thank Professor Ding Yuan, Mariana D’Angelo,
Michelle Wong, Beom Heyn Kim, Afshar Ganjali, Sukwon
Oh, Diego Bravo Velasquez and Peter Sun for their valuable
feedback. We also thank the anonymous reviewers for their
comments and help in improving the quality of this paper.
The research in this paper was supported by an NSERC
Discovery Grant.
8. REFERENCES
[1] Abadi, M., Budiu, M., Erlingsson, U., and
Ligatti, J. Control-ﬂow integrity. In Proceedings of
the 12th ACM Conference on Computer and
Communications Security (Alexandria, Virginia,
2005).
[2] Andersen, S., and Abella, V. Data execution
prevention. https://technet.microsoft.com/en-us/
library/bb457155.aspx, 2004. Last accessed:
2016-09-01.
[3] Bounov, D., Kici, R. G., and Lerner, S.
Protecting C++ dynamic dispatch through VTable
interleaving. In Proceedings of the 23rd Annual
Networked & Distributed System Security Symposium
(NDSS) (San Diego, California, 2016).
[4] Castro, M., Costa, M., and Harris, T. Securing
software by enforcing data-ﬂow integrity. In
Proceedings of the 7th Symposium on Operating
Systems Design and Implementation (Seattle,
Washington, 2006).
[5] Checkoway, S., Davi, L., Dmitrienko, A.,
Sadeghi, A.-R., Shacham, H., and Winandy, M.
Return-oriented programming without returns. In
Proceedings of the 17th ACM Conference on Computer
and Communications Security (Chicago, Illinois,
2010).
[6] Cheng, Y., Zhou, Z., Yu, M., Ding, X., and Deng,
R. ROPecker: A generic and practical approach for
defending against rop attacks. In Proceedings of the
46821st Annual Networked & Distributed System Security
Symposium (NDSS) (San Diego, California, 2014).
[7] Chiueh, T.-C., and Hsu, F.-H. RAD: A
compile-time solution to buﬀer overﬂow attacks. In
Proceedings of the The 21st International Conference
on Distributed Computing Systems (Washington, DC,
2001).
[8] Christoulakis, N., Christou, G.,
Athanasopoulos, E., and Ioannidis, S. HCFI:
Hardware-enforced control-ﬂow integrity. In
Proceedings of the 6th ACM Conference on Data and
Application Security and Privacy (2016).
[9] Criswell, J., Dautenhahn, N., and Adve, V.
Virtual Ghost: Protecting applications from hostile
operating systems. In Proceedings of the 19th
International Conference on Architectural Support for
Programming Languages and Operating Systems
(ASPLOS) (Salt Lake City, Utah, 2014).
[10] Dang, T. H., Maniatis, P., and Wagner, D. The
performance cost of shadow stacks and stack canaries.
In Proceedings of the 10th ACM Symposium on
Information, Computer and Communications Security
(Singapore, 2015).
[11] Davi, L., Hanreich, M., Paul, D., Sadeghi, A.-R.,
Koeberl, P., Sullivan, D., Arias, O., and Jin, Y.
HAFIX: Hardware-assisted ﬂow integrity extension. In
Proceedings of the 52nd Annual Design Automation
Conference (2015).
[12] Davi, L., Sadeghi, A.-R., Lehmann, D., and
Monrose, F. Stitching the gadgets: On the
ineﬀectiveness of coarse-grained control-ﬂow integrity
protection. In Proceedings of the 35th IEEE
Symposium on Security and Privacy (San Jose,
California, 2014).
[13] Durumeric, Z., Kasten, J., Adrian, D.,
Halderman, J. A., Bailey, M., Li, F., Weaver,
N., Amann, J., Beekman, J., Payer, M., and
Paxson, V. The matter of heartbleed. In Proceedings
of the 2014 Conference on Internet Measurement
Conference (Vancouver, BC, Canada, 2014).
[14] Erlingsson, U., Abadi, M., Vrable, M., Budiu,
M., and Necula, G. C. XFI: Software guards for
system address spaces. In Proceedings of the 7th
Symposium on Operating Systems Design and
Implementation (Seattle, Washington, 2006).
[15] Evans, I., Fingeret, S., Gonzalez, J.,
Otgonbaatar, U., Tang, T., Shrobe, H.,
Sidiroglou-Douskos, S., Rinard, M., and
Okhravi, H. Missing the point(er): On the
eﬀectiveness of code pointer integrity. In Proceedings
of the 36th IEEE Symposium on Security and Privacy
(San Jose, California, 2015).
[16] Fratri´c, I. ROPGuard: Runtime prevention of
return-oriented programming attacks. http://www.
ieee.hr/ download/repository/Ivan Fratric.pdf, 2012.
Last accessed: 2016-09-01.
[17] Ganesh, K. Pointer checker: Easily catch
out-of-bounds memory accesses.
https://software.intel.com/sites/products/
parallelmag/singlearticles/issue11/7080 2 IN
ParallelMag Issue11 Pointer Checker.pdf. Last
accessed: 2016-09-01.
[18] G¨oktas, E., Athanasopoulos, E., Bos, H., and
Portokalidis, G. Out of control: Overcoming
control-ﬂow integrity. In Proceedings of the 35th IEEE
Symposium on Security and Privacy (San Jose,
California, 2014).
[19] Hu, H., Shinde, S., Sendroiu, A., Chua, Z. L.,
Saxena, P., and Liang, Z. Data-oriented
programming: On the expressiveness of non-control
data attacks. In Proceedings of the 37th IEEE
Symposium on Security and Privacy (San Jose,
California, 2016).
[20] Hund, R., Willems, C., and Holz, T. Practical
timing side channel attacks against kernel space
ASLR. In Proceedings of the 34th IEEE Symposium on
Security and Privacy (Washington, D.C., 2013).
[21] Intel. Control-ﬂow enforcement technology preview,
Document Number: 334525-001, Revision 1.0. https:
//software.intel.com/sites/default/ﬁles/managed/4d/
2a/control-ﬂow-enforcement-technology-preview.pdf,
June 2016. Last Last accessed: 2016-09-01.
[22] Kil, C., Jim, J., Bookholt, C., Xu, J., and Ning,
P. Address space layout permutation (ASLP):
Towards ﬁne-grained randomization of commodity
software. In Proceedings of Computer Security
Applications Conference (ASAC) (Miami Beach,
Florida, 2006).
[23] Kuznetsov, V., Szekeres, L., Payer, M., Candea,
G., Sekar, R., and Song, D. Code-pointer integrity.
In Proceedings of the 11th USENIX Symposium on
Operating Systems Design and Implementation
(Broomﬁeld, Colorado, 2014).
[24] Liu, L., Han, J., Gao, D., Jing, J., and Zha, D.
Launching return-oriented programming attacks
against randomized relocatable executables. In
Proceedings of the 10th International Conference on
Trust, Security and Privacy in Computing and
Communications (TrustCom) (Changsha, China,
2011).
[25] Mohan, V., Larsen, P., Brunthaler, S., Hamlen,
K. W., and Franz, M. Opaque control-ﬂow integrity.
In Proceedings of the 22nd Annual Networked &
Distributed System Security Symposium (NDSS) (San
Diego, California, 2015).
[26] Pappas, V., Polychronakis, M., and Keromytis,
A. D. Transparent ROP exploit mitigation using
indirect branch tracing. In Proceedings of the 22nd
USENIX Security Symposium (Washington, D.C.,
2013).
[27] PaX-Team. PaX ASLR (address space layout
randomization).
http://pax.grsecurity.net/docs/aslr.txt, 2003. Last
Last accessed: 2016-09-01.
[28] Pincus, J., and Baker, B. Beyond stack smashing:
recent advances in exploiting buﬀer overruns. IEEE
Journal of Security and Privacy 2, 4 (July 2004),
20–27.
[29] Roemer, R., Buchanan, E., Shacham, H., and
Savage, S. Return-oriented programming: Systems,
languages, and applications. ACM Transaction on
Information and System Security 15, 1 (March 2012),
2:1–2:34.
469[30] Seibert, J., Okhravi, H., and S¨oderstr¨om, E.
Information leaks without memory disclosures:
Remote side channel attacks on diversiﬁed code. In
Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security (2014).
[31] Shacham, H., Page, M., Pfaff, B., Goh, E.-J.,
Modadugu, N., and Boneh, D. On the eﬀectiveness
of address-space randomization. In Proceedings of the
11th ACM Conference on Computer and
Communications Security (Washington, D.C., 2004).
[32] Snow, K. Z., Monrose, F., Davi, L., Dmitrienko,
A., Liebchen, C., and Sadeghi, A.-R. Just-in-time
code reuse: On the eﬀectiveness of ﬁne-grained
address space layout randomization. In Proceedings of
the 34th IEEE Symposium on Security and Privacy
(Washington, D.C., 2013).
[33] Strackx, R., Younan, Y., Philippaerts, P.,
Piessens, F., Lachmund, S., and Walter, T.
Breaking the memory secrecy assumption. In
Proceedings of the Second European Workshop on
System Security (2009).
[34] Tice, C., Roeder, T., Collingbourne, P.,
Checkoway, S., Erlingsson, U., Lozano, L., and
Pike, G. Enforcing forward-edge control-ﬂow integrity
in GCC & LLVM. In Proceedings of the 23rd USENIX
Security Symposium (San Diego, California, 2014).
[35] Tran, M., Etheridge, M., Bletsch, T., Jiang,
X., Freeh, V., and Ning, P. On the expressiveness
of return-into-libc attacks. In Proceedings of the 14th
International Conference on Recent Advances in
Intrusion Detection (Menlo Park, California, 2011).
[36] Vogl, S., Gawlik, R., Garmany, B., Kittel, T.,
Pfoh, J., Eckert, C., and Holz, T. Dynamic
hooks: Hiding control ﬂow changes within non-control
data. In Proceedings of the 23rd USENIX Security
Symposium (San Diego, California, 2014).
[37] Wahbe, R., Lucco, S., Anderson, T. E., and
Graham, S. L. Eﬃcient software-based fault
isolation. SIGOPS Operating System Review 27, 5
(Dec. 1993), 203–216.
[38] Wang, Z., and Jiang, X. HyperSafe: A lightweight
approach to provide lifetime hypervisor control-ﬂow
integrity. In Proceedings of the 31st IEEE Symposium
on Security and Privacy (San Jose, California, 2010).
[39] Zeng, B., Tan, G., and Morrisett, G. Combining
control-ﬂow integrity and static analysis for eﬃcient
and validated data sandboxing. In Proceedings of the
18th ACM Conference on Computer and
Communications Security (Chicago, Illinois, 2011).
[40] Zhang, C., Carr, S. A., Li, T., Ding, Y., Song,
C., Payer, M., and Song, D. VTrust: Regaining
trust on virtual calls. In Proceedings of the 23rd
Annual Networked & Distributed System Security
Symposium (NDSS) (San Diego, California, 2016).
470