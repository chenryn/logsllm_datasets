# OpenSSH客户端漏洞：CVE-2016-0777和CVE-2016-0778
|
##### 译文声明
本文是翻译文章，文章来源：360安全播报
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
**OpenSSH客户端漏洞：CVE-2016-0777和CVE-2016-0778**
**CVE-2016-0777可通过构造ssh恶意服务器,有可能泄漏客户端的内存私钥** **  
**
**本文内容概览**
| 信息综述
| 信息泄漏漏洞（CVE-2016-0777）
| －漏洞分析
| －私钥泄漏
| －漏洞缓解方式
| －实例
| 缓冲区溢出漏洞（CVE-2016-0778）
| －漏洞分析
| －私钥披露
| －文件描述符泄漏
| 致谢
| 概念验证实例
**信息综述**
从5.4版开始（发布于2010年3月8日），OpenSSH客户端就提供了一个名为“roaming（漫游）”的功能（该功能并未记录在介绍文档中）：如果客户端与SSH服务器的通信链接意外中断，当服务器同样支持roaming功能，那么客户端就可以与服务器重新连接，并重新恢复挂起的SSH会话操作。
虽然OpenSSH服务器并不支持roaming功能，但OpenSSH客户端是默认启用这一功能的，而这一功能却存在两个漏洞，恶意SSH服务器或者一台被入侵的可信服务器都可以利用这两个漏洞，并在目标系统中引起信息泄漏（内存泄漏）以及缓冲区溢出（基于堆的）。
在OpenSSH客户端的默认配置下，内存泄漏漏洞是可以直接被攻击者利用的。这个漏洞允许一台恶意SSH服务器直接窃取客户端的私钥，但是具体情况取决于客户端版本，编译器，以及操作系统。很多恶意攻击者可能已经在利用这一信息泄漏漏洞了，一些热门网站或者网络名人也许需要去重新生成他们的SSH密钥了。
另一方面，OpenSSH客户端在默认配置下，也存在一个缓冲区溢出漏洞。但如果攻击者要利用这个漏洞，还需要两个非默认的配置选项：其一为ProxyCommand，第二个选项为ForwardAgent(-A)或ForwardX11(-X)。因此，这个缓冲区溢出漏洞不太可能会对用户产生什么实际影响，但这一漏洞却非常值得我们进行研究和分析。
版本号在5.4至7.1之间的OpenSSH客户端均存在着两个漏洞，但解决这一问题却是非常简单的，用户只需要将“UseRoaming”选项设置为“no”即可，具体信息我们将在漏洞缓解方式这一章节中进行详细讲解。7.1p2版本的OpenSSH客户端（发布于2016年1月14日）默认禁用了roaming功能。
**信息泄漏漏洞（CVE-2016-0777）**
**漏洞分析**
如果OpenSSH客户端与一个提供密钥交换算法的SSH服务器进行了连接，那么在身份验证成功之后，它会向服务器发送一个全局请求“PI:EMAIL”。如果服务器接受了这个请求，客户端便会通过调用malloc()函数（并非调用calloc()）,并根据out_buf_size的值来为roaming功能分配一个缓冲区（即out_buf），需要注意的是out_buf_size的值是由服务器进行随机选取的：
    63 void
             64 roaming_reply(int type, u_int32_t seq, void *ctxt)
             65 {
             66         if (type == SSH2_MSG_REQUEST_FAILURE) {
             67                 logit("Server denied roaming");
             68                 return;
             69         }
             70         verbose("Roaming enabled");
             ..
             75         set_out_buffer_size(packet_get_int() + get_snd_buf_size());
             ..
             77 }
             40 static size_t out_buf_size = 0;
             41 static char *out_buf = NULL;
             42 static size_t out_start;
             43 static size_t out_last;
             ..
             75 void
             76 set_out_buffer_size(size_t size)
             77 {
             78         if (size == 0 || size > MAX_ROAMBUF)
             79                 fatal("%s: bad buffer size %lu", __func__, (u_long)size);
             80         /*
             81          * The buffer size can only be set once and the buffer will live
             82          * as long as the session lives.
             83          */
             84         if (out_buf == NULL) {
             85                 out_buf_size = size;
             86                 out_buf = xmalloc(size);
             87                 out_start = 0;
             88                 out_last = 0;
             89         }
             90 }
在客户端与SSH服务器的通信链接意外断开之后,OpenSSH客户端的roaming_write()函数(该函数是write()函数的升级版)会调用wait_for_roaming_reconnect(),并恢复与服务器的连接。该函数还会调用buf_append()函数,该函数可以将客户端发送至服务器的数据信息拷贝到roaming缓冲区out_buf之中。在重新连接的过程中,由于之前的通信连接意外断开,因此客户端会将服务器未接收到的信息重新发送给服务器。
     198 void
            199 resend_bytes(int fd, u_int64_t *offset)
            200 {
            201         size_t available, needed;
            202
            203         if (out_start  available)
            211                 fatal("Needed to resend more data than in the cache");
            212         if (out_last  out_last" (205-206行):out_buf已满(out_start实际上等于“out_last + 1”),此时out_buf中的数据总量实际上就等于整个out_buf_size的大小;
-"out_start == out_last" (205-206行):out-buf中并没有写入任何数据(此时out_start和out_last仍然为0),因为客户端在调用了roaming_reply()函数之后,并没有向服务器发送任何的数据,但是在 out_buf_size的值存在的情况下,客户端却会将整个未初始化的out_buf发送(泄漏)给了服务器(214行)。
恶意服务器可以成功利用这个信息泄漏漏洞,并从OpenSSH客户端的内存中提取出敏感信息(比如说,SSH私钥,或者在下一步攻击中需要用到的内存地址信息)。
**私钥泄漏**
一开始我们认为,恶意SSH服务器是无法利用这个存在于OpenSSH客户端roaming功能代码中的信息泄漏漏洞窃取客户端的私钥信息的,因为: