> ![](media/image710.jpeg)
>
> Source:
> https://payatu.com/wp-content/uploads/2018/08/dumb_pipe_redirection123.png
> Let\'s execute the command given in the following image in order to
> configure a dumb pipe redirector which would redirect to our C2 on
> port 8080/tcp:
>
> ![](media/image711.jpeg)
>
> Following are the commands that we can execute to perform dumb pipe
> redirection using iptables: **iptables -I INPUT -p tcp -m tcp \--
> dport 8080 -j ACCEPT**
>
> **iptables -t nat -A PREROUTING -p tcp \--dport 8080 -j DNAT
> \--to-destination 54.166.109.171:8080 iptables -t nat -A POSTROUTING
> -j MASQUERADE**
>
> **iptables -I FORWARD -j ACCEPT iptables -P FORWARD ACCEPT sysctl
> net.ipv4.ip_forward=1**
>
> The given commands needs to be executed and the result is shown in the
> following screenshot:
>
> ![](media/image712.jpeg)
>
> (Ignore the sudo error here. This has occurred because of the hostname
> that we changed) Using socat or iptables, the result would be same
> i.e. the network traffic on the redirector\'s interface will be
> forwarded to our C2.
# Filtration/smart redirection
> Filtration redirection, also known as **smart redirection**, doesn\'t
> just blindly forward the network traffic to the C2. Smart redirection
> will always process the network traffic based on the rules defined by
> the red team before forwarding it to the C2. In a smart redirection,
> if the C2 traffic is invalid, the network traffic will either be
> forwarded to a legitimate website or it would just drop the packets.
Only if the network traffic is for our C2 will the redirection work
accordingly:
> ![](media/image713.jpeg)
To configure a smart redirection, we need to install a web service and
configure it. Let\'s install Apache server on the redirector using the
sudo apt install apache2 command:
> ![](media/image714.jpeg)
>
> We need to execute the following commands as well in order to enable
> Apache modules to be rewritten, and also to enable SSL: **sudo apt-get
> install apache2 sudo a2enmod ssl rewrite proxy proxy_http**
>
> **sudo a2ensite default-ssl.conf sudo service apache2 restart**
>
> ![](media/image715.jpeg)These are all commands that needs to be
> executed. The result of the executed commands are shown in the
> following screenshot:
We also need to configure the Apache from its configuration:
> ![](media/image716.jpeg)
>
> We need to look for the Directory directive in order to change the
> AllowOverride from None to All so that we can use our custom .htaccess
> file for web request filtration.
>
> ![](media/image717.png)
We can now set up the virtual host setting and add this to
wwwpacktpub.tk
> (/etc/apache2/sites-enabled/default-ssl.conf):
>
> ![](media/image718.jpeg)
After this, we can generate the payload with a domain such as
wwwpacktpub.tk in order to get a connection.
# Domain fronting
> According to
> [https://resources.infosecinstitute.com/domain-fronting/](https://resources.infosecinstitute.com/domain-fronting/)):
> Domain fronting is a technique that is designed to circumvent the
> censorship employed for certain domains (censorship may occur for
> domains that are not in line with a company\'s policies, or they may
> be a result of the bad reputation of a domain). Domain fronting works
> at the HTTPS layer and uses different domain names at different layers
> of the request (more on this later). To the censors, it looks like the
> communication is happening between the client and a permitted domain.
>
> However, in reality, communication might be happening between the
> client and a blocked domain.
![](media/image719.jpeg)To make a start with domain fronting, we need to
get a domain that is similar to our target organization. To check for
domains, we can use the domainhunter tool. Let\'s clone the repository
to continue:
> We need to install some required Python packages before continuing
> further. This can be achieved by executing the pip install -r
> requirements.txt command as follows:
>
> ![](media/image720.jpeg)
>
> After installation, we can run the tool by executing the python
> domainhunter.py
command as follows:
> ![](media/image721.png)
>
> By default, this will fetch for the expired and deleted domains that
> have a blank name because we didn\'t provide one:
>
> ![](media/image722.png)
>
> Let\'s check for the help option to see how we can use domainhunter:
>
> ![](media/image723.jpeg)
>
> Let\'s search for a keyword to look for the domains related to the
> specified keyword. In this case, we will use packtpub as the desired
> keyword:
>
> ![](media/image724.png)
>
> We just found out that wwwpacktpub.com is available. Let\'s confirm
> its availability at domain searching websites as follows:
>
> ![](media/image725.jpeg)
>
> ![](media/image726.jpeg)This confirms that the domain is available on
> name.com and even on dot.tk for almost \$8.50:
>
> Let\'s see if we can find a free domain with a different TLD:
>
> ![](media/image727.jpeg)
We have found that the preceding-mentioned domains are free to register.
Let\'s select wwwpacktpub.tk as follows:
> ![](media/image728.jpeg)
We can again check the availability of
[www.packtpub.tk](http://www.packtpub.tk/) and obtain this domain for
free:
> ![](media/image729.jpeg)
>
> In the preceding setting, we need to set our redirector\'s IP address
> in the Use DNS field:
>
> ![](media/image730.jpeg)
>
> Let\'s review the purchase and then check out:
>
> ![](media/image731.jpeg)
>
> Our order has now been confirmed. We just obtained wwwpacktpub.tk:
>
> ![](media/image732.jpeg)
>
> Let\'s execute the dig command to confirm our ownership of this:
>
> ![](media/image733.jpeg)
>
> The dig command resolves wwwpacktpub.tk to our redirector\'s IP. Now
> that we have
>
> ![](media/image734.jpeg)obtained this, we can set the domain in the
> stager creation and get the back connection from wwwpacktpub.tk:
>
> Domain fronting can also be done using Cloudflare and other cloud
> network platforms. In the next chapter, we focus on different
> techniques in exfiltrating data from a target server.
# Summary
> In this chapter, we have introduced redirectors and why obfuscating
> C2s is required. We have also covered how we can obfuscate C2s in a
> secure manner so that we can protect our C2s from getting detected by
> the Blue team. In addition, we have learned about short-term and
> long-term C2s and redirectors. Next, the payload redirection type was
> covered. Here, we learned about dumb pipe redirection and smart
> redirection. At the end of the chapter, we saw how we obtained a
> domain which resembles [http://packtpub.com](http://packtpub.com/) and
> how this can be used to achieve further anonymity.
# Questions
1.  Can we use Microsoft Windows based redirector instead of Linux
    > based?
2.  Why should we configure and install our own redirector when we can
    > use a compromised server for the same job?
3.  Is it mandatory to use Apache Web server for smart redirection?
4.  Is it legal if we buy a domain similar to organization\'s domain for
    > the engagement ?
5.  Can we setup the redirectors on AWS?
# Further reading
> For more information on the topics discussed in this chapter, please
> visit the following links:
>
> 
> 
> 
> 
> 
>
> 
> [https://www.securityartwork.es/2017/01/31/simple-domain-fronting-poc-with-gae-c2-ser
> ver/](https://www.securityartwork.es/2017/01/31/simple-domain-fronting-poc-with-gae-c2-server/)
>
> 
> [https://theobsidiantower.com/2017/07/24/d0a7cfceedc42bdf3a36f2926bd52863ef28befc.htm
> l](https://theobsidiantower.com/2017/07/24/d0a7cfceedc42bdf3a36f2926bd52863ef28befc.html)
# Achieving Persistence
> In the previous chapters, we have looked at examples of different ways
> to gain a reverse shell on the system, as well as tools such as
> Empire, which help us with things like privilege escalation. The next
> step is achieving and maintaining persistent access to systems. When
> performing a red-team exercise, there is occasionally a Blue team
> whose goal is to detect and prevent the attacks from being carried out
> by the red team. In these cases, persistence comes into play.
Persistence can be achieved in two major ways:
> **Disk persistence**: This technique uses methods that end up writing
> files to the victim\'s physical drive. This is less recommended
> because when a file is written to the disk, there is a higher chance
> that an antivirus may flag it or the user may find it.
>
> **In-memory or fileless persistence**: This technique utilizes ways of
> executing payloads in the system without actually writing anything on
> the disk. Most malware uses this technique to avoid detection.
In this chapter, we will cover the following topics:
> Persistence via Armitage Persistence via Empire Persistence using
> Cobalt Strike
# Technical requirements
> Metasploit Framework (MSF) PGSQL (Postgres)
>
> Oracle Java 1.7 or above Cobalt Strike
>
> Empire Armitage
# Persistence via Armitage
> We have already covered this in previous chapters, but in this section
> we will look at some of the Windows exploitation scripts that allow us
> to achieve persistence on the victim host. We can look for all
> available exploits by searching for the keyword **persistence** in
> Armitage, as shown in the following screenshot. We can see that there
> are different exploits available that allow us to achieve persistence.
> Some of these are as follows:
>
> Cron_persistence: This module will work on a \*nix-based system and
> create a cron job that executes our payload.
>
> Registery_persistence: This module creates a payload that is run
> either when a user logs on or on system startup, through the registry
> value in CurrentVersion\\Run (depending on privilege). This payload is
> completely installed in the registry.
>
> Vss_persistence: This module creates a persistent payload in a new
> volume shadow copy.
>
> Wmi_persistence: This module will create a WMI event subscription. It
> is a file
>
> -less persistence.
>
> ![](media/image735.jpeg)
Let\'s try using wmi_persistence. This uses one of the following five
methods for persistence:
> **EVENT method**: This creates an event filter that will query the
> event log for an EVENT_ID_TRIGGER (the default failed logon request ID
> is usually 4625) to trigger the payload
>
> **INTERVAL method**: This will create an event filter that executes
> the payload after CALLBACK_INTERVAL, which is specified
>
> **LOGON method**: In this method, the payload is executed after a
> successful uptime of four minutes
>
> **Process method**: This will create an event filter that triggers the
> payload when the specified process is started
>
> **WAITFOR method**: This creates an event filter that utilizes the
> Microsoft binary waitfor.exe to wait for a signal specified by
> WAITFOR_TRIGGER before executing the payload
>
> ![](media/image736.jpeg)When we double-click on the wmi_persistence
> option, it will open a new window, as shown in the following
> screenshot:
>
> Here, we change the persistence method to PROCESS. This will use the
> process trigger method since the process_trigger we are using is
> CALC.exe. Whenever a calculator is opened on the system, we will get a
> reverse connection on our Armitage server as follows:
>
> ![](media/image737.jpeg)
>
> By clicking on launch, we will see that the exploit has been executed
> successfully:
>
> ![](media/image738.jpeg)
When the victim runs the Calculator, a new meterpreter shell will pop up
as follows:
> ![](media/image739.jpeg)
# Persistence via Empire
> Empire has a lot of inbuilt modules that allow us to use persistence
> on a system while performing a red team activity. These modules are
> divided into four main areas:
>
> PowerBreach: This is a series of in-memory PowerShell backdoors that
> provide triggers for various options
>
> userland: These are backdoors that execute on reboot without needing
> admin rights
>
> elevated: These are backdoors that execute on reboot with admin rights
> debugger triggers: These are backdoors that execute on a particular
> trigger (an example of this is sticky keys)
>
> In this section, we will cover some of the modules for Linux, Windows,
> and macOS systems.
## For Windows:
Assuming we have an agent connected on our empire from a Windows
Machine:
> ![](media/image740.jpeg)
>
> To view a list of available persistence modules, we interact with
> agents using the
>
> interact \ command.
![](media/image741.jpeg)Next, to view the available persistence module,
we type usemodule persistence and press *Tab*. This will show a list of
all available modules, as shown in the following screenshot:
> Let\'s try to use the backdoor_lnk module by typing info. This will
> show us a description of what the module does and the options we need
> to set in it:
>
> ![](media/image742.jpeg)
>
> In the following screenshot, we can see that we need to set the
> listener name and the path file of any shortcut icon on the victim\'s
> system:
>
> ![](media/image743.jpeg)
![](media/image744.jpeg)We set the path as shown in the following
screenshot. In our case, the user had a shortcut icon of Google Chrome
on his desktop:
Upon running the execute command, we will see that the module has
completed successfully:
> ![](media/image745.jpeg)
Let\'s try to understand what the module actually did. On the victim\'s
computer, if we see the shortcut icon\'s properties, we can see that it
has changed the target value with a PowerShell payload. Now, whenever
the victim opens Chrome from this shortcut, our payload will be executed
alongside it:
> ![](media/image746.jpeg)
Once the user runs Chrome, we will see a new agent connected to our
Empire:
> ![](media/image747.jpeg)
>
> Let\'s take a look at another elevated/schtasks module. This requires
> system-level privileges and creates a scheduled task to run our
> payload periodically, as described with the info command as shown in
> the following command:
>
> ![](media/image748.jpeg)
We set the listener name and the time when we want to run the task, and
run
execute. Our payload will then be executed at that time daily:
> ![](media/image749.jpeg)
## For macOS:
![](media/image750.jpeg)Just as we did for Windows, we have persistence
modules for macOS as well. As shown in the following screenshot, we
already have a macOS agent connected:
> ![](media/image751.jpeg)We run the usemodule persistence command and
> press *Tab* to see all available modules:
>
> Let\'s use the osx/loginhook command as follows:
>