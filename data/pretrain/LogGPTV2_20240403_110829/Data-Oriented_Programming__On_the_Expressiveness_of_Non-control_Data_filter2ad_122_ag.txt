Symposium, 2014.
[8] M. Zhang and R. Sekar, “Control Flow Integrity for COTS Binaries,”
in Proceedings of the 22nd USENIX Security Symposium, 2013.
[9] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou, “Practical Control Flow Integrity and Ran-
domization for Binary Executables,” in Proceedings of the 34th IEEE
Symposium on Security and Privacy, 2013.
[10] B. Niu and G. Tan, “Per-Input Control-Flow Integrity,” in Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications
Security, 2015.
[11] V. van der Veen, D. Andriesse, E. G¨oktas¸, B. Gras, L. Sambuc,
A. Slowinska, H. Bos, and C. Giuffrida, “Practical Context-Sensitive
CFI,” in Proceedings of the 22nd ACM SIGSAC Conference on Computer
and Communications Security, 2015.
[12] A. J. Mashtizadeh, A. Bittau, D. Boneh, and D. Mazi`eres, “CCFI:
Cryptographically Enforced Control Flow Integrity,” in Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications
Security, 2015.
[13] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song,
“Code-pointer Integrity,” in Proceedings of the 11th USENIX Conference
on Operating Systems Design and Implementation, 2014.
[14] D. Bigelow, T. Hobson, R. Rudd, W. Streilein, and H. Okhravi, “Timely
Rerandomization for Mitigating Memory Disclosures,” in Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications
Security, 2015.
[15] PaX Team, “PaX Address Space Layout Randomization (ASLR),” http:
//pax.grsecurity.net/docs/aslr.txt, 2003.
[16] Microsoft, “Data Execution Prevention (DEP),” 2006, http://support.
microsoft.com/kb/875352/EN-US/.
[17] B. Niu and G. Tan, “Modular Control-ﬂow Integrity,” in Proceedings of
the 35th ACM SIGPLAN Conference on Programming Language Design
and Implementation, 2014.
[18] J. Criswell, N. Dautenhahn, and V. Adve, “KCoFI: Complete Control-
Flow Integrity for Commodity Operating System Kernels,” in Proceed-
ings of the 35th IEEE Symposium on Security and Privacy, 2014.
[19] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer, “Non-Control-
Data Attacks Are Realistic Threats,” in Proceedings of the 14th USENIX
Security Symposium, 2005.
[20] “The Heartbleed Bug,” http://heartbleed.com/.
[21] Yu Yang, “ROPs are for the 99%, CanSecWest 2014,” https://cansecwest.
com/slides/2014/ROPs are for the 99 CanSecWest 2014.pdf, 2014.
[22] H. Hu, Z. L. Chua, S. Adrian, P. Saxena, and Z. Liang, “Automatic
the 24th
Generation of Data-Oriented Exploits,” in Proceedings of
USENIX Security Symposium, 2015.
[23] A. Homescu, M. Stewart, P. Larsen, S. Brunthaler, and M. Franz,
“Microgadgets: Size Does Matter in Turing-complete Return-oriented
Programming,” in Proceedings of
the 6th USENIX Conference on
Offensive Technologies, 2012.
[24] “SOP Bypass Demos,” https://goo.gl/4PfXEg.
[25] N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross, “Control-
Flow Bending: On the Effectiveness of Control-Flow Integrity,” in
Proceedings of the 24th USENIX Security Symposium, 2015.
[26] C. Planet, “A Eulogy for Format Strings,” http://phrack.org/issues/67/9.
[27] Microsoft, “ set printf count output,” https://msdn.microsoft.com/en-
html.
us/library/ms175782.aspx.
http://www.proftpd.org/.
[28] “ProFTPD — Highly conﬁgurable GPL-licensed FTP server software,”
[29] “WU-FTPD Server,” http://www.wu-ftpd.org/.
[30] “Nginx HTTP
Server
1.3.9-1.4.0 Chunked Encoding
Stack
http://mailman.nginx.org/pipermail/nginx-
Buffer
announce/2013/000112.html.
Overﬂow,”
[31] “Bitcoin - Open source P2P money,” https://bitcoin.org/.
[32] “SSH Communications Security,” www.ssh.com/.
[33] “Wireshark Go Deep.” https://www.wireshark.org/.
[34] “Glibc - Gnu,” https://www.gnu.org/s/libc/.
[35] “BusyBox,” www.busybox.net.
[36] “musl libc,” http://www.musl-libc.org/.
[37] “MCrypt,” mcrypt.sourceforge.net/.
[38] “Sudo Main Page,” http://www.sudo.ws/.
[39] “Buffer Overﬂow Vulnerability in UPnP library used by Bitcoin Core,”
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-6031.
[40] “musl libc inet pton.c Remote Stack Buffer Overﬂow Vulnerability,”
https://security-tracker.debian.org/tracker/CVE-2015-1817.
[41] “Stack-Based Buffer Overlfow in the MPEG parser in Wireshark,” http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2299.
[42] “ nginx: Stack-based Buffer Overﬂow,” https://cve.mitre.org/cgi-bin/
[43] “Stack-Based Buffer Overﬂow in Mcrypt,” http://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2013-2028.
cvename.cgi?name=CVE-2012-4409.
[44] “Sudo Format String Vulnerability,” http://www.sudo.ws/sudo/alerts/
sudo debug.html, 2012.
[45] “Stack-Based Buffer Overlfow in the sreplace Function in Proftpd,” http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5815.
[46] “Integer Overﬂow Vulnerability in SSH CRC-32 Compensation Attack
Detector,” https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-
0144.
[47] “Wu-Ftpd Remote Format String Stack Overwrite Vulnerability,” http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-0573.
[48] R. Shapiro, S. Bratus, and S. W. Smith, ““Weird Machines” in ELF: A
Spotlight on the Underappreciated Metadata,” in Proceedings of the 7th
USENIX Conference on Offensive Technologies, 2013.
[49] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen, A.-R. Sadeghi,
S. Brunthaler, and M. Franz, “Readactor: Practical Code Randomization
Resilient to Memory Disclosure,” in Proceedings of the 36th IEEE
Symposium on Security and Privacy, 2015.
[50] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham, “Efﬁcient
Software-based Fault Isolation,” in Proceedings of the 14th ACM Sym-
posium on Operating Systems Principles, 1993.
[51] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and
Y. Wang, “Cyclone: A Safe Dialect of C,” in Proceedings of the USENIX
Annual Technical Conference, 2002.
[52] G. C. Necula, S. McPeak, and W. Weimer, “CCured: Type-safe
Retroﬁtting of Legacy Code,” in Proceedings of
the 29th ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Lan-
guages, 2002.
[53] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, “SoftBound:
Highly Compatible and Complete Spatial Memory Safety for C,” in
Proceedings of the 30th ACM SIG-PLAN Conference on Programming
Language Design and Implementation, 2009.
[54] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, “CETS:
Compiler Enforced Temporal Safety for C,” in Proceedings of the 9th
International Symposium on Memory Management, 2010.
[55] P. Akritidis, “Cling: A Memory Allocator to Mitigate Dangling Point-
ers,” in Proceedings of the 19th USENIX Security Symposium, 2010.
[56] L. Szekeres, M. Payer, T. Wei, and D. Song, “SoK: Eternal War in
Memory,” in Proceedings of the 34th IEEE Symposium on Security and
Privacy, 2013.
[57] M. Castro, M. Costa, and T. Harris, “Securing Software by Enforcing
Data-Flow Integrity,” in Proceedings of the 7th Symposium on Operating
Systems Design and Implementation, 2006.
984984
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:14:56 UTC from IEEE Xplore.  Restrictions apply. 
[58] C. Song, B. Lee, K. Lu, W. R. Harris, T. Kim, and W. Lee, “Enforcing
Kernel Security Invariants with Data Flow Integrity,” in Proceedings of
the 23th Annual Network and Distributed System Security Symposium,
2016.
[59] S. Bhatkar and R. Sekar, “Data Space Randomization,” in Proceedings
of the 5th International Conference on Detection of Intrusions and
Malware, and Vulnerability Assessment, 2008.
[60] P. Chen, J. Xu, Z. Lin, D. Xu, B. Mao, and P. Liu, “A Practical Approach
for Adaptive Data Structure Layout Randomization,” in Proceedings of
the 20th European Symposium on Research in Computer Security, 2015.
[61] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and A.-
R. Sadeghi, “Just-In-Time Code Reuse: On the Effectiveness of Fine-
Grained Address Space Layout Randomization,” in Proceedings of the
34th IEEE Symposium on Security and Privacy, ser. SP ’13, 2013.
[62] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and
T. Holz, “Counterfeit Object-oriented Programming: On the Difﬁculty
of Preventing Code Reuse Attacks in C++ Applications,” in Proceedings
of the 36th IEEE Symposium on Security and Privacy, 2015.
[63] J. Oakley and S. Bratus, “Exploiting the Hard-working DWARF: Trojan
and Exploit Techniques with No Native Executable Code,” in Proceed-
ings of the 5th USENIX Conference on Offensive Technologies, 2011.
[64] J. Bangert, S. Bratus, R. Shapiro, and S. W. Smith, “The Page-fault
Weird Machine: Lessons in Instruction-less Computation,” in Proceed-
ings of the 7th USENIX Conference on Offensive Technologies, 2013.
[65] M. Rushanan and S. Checkoway, “Run-DMA,” in Proceedings of the
9th USENIX Conference on Offensive Technologies, 2015.
APPENDIX
A. Example of a Transition Table in MINDOP
Table VIII shows one example of transition table for simu-
lating a Turing machine that shifts the given input by one bit.
Transition table for a Turing machine that shifts the binary input by one bit
(equivalent to SHL instruction).
TABLE VIII
PPPPQ
Σ
q0
q1
q2
q3
Scur = 0
Snxt
0
0
0
-
qnxt
q1
q1
q3
HALT
D
1
1
1
-
qnxt
q1
q1
q3
HALT
Scur = 1
Snxt
1
1
1
-
D
1
1
1
-
Scur = σ0
qnxt
Snxt
q0
q2
q3
HALT
σ0
0
σ0
-
D
1
0
1
-
B. A Program Allowing DOP to Bypass TASR and CCFI
void (*foo)();
1 typedef struct _mystruct {
2
3 } mystruct;
4
5 void m1() = { printf{‘‘hello from m1’’}; }
6 void m2() = { printf{‘‘hello from m2’’}; }
7
8 mystruct ms1 = { .foo = m1 };
9 mystruct ms2 = { .foo = m2 };
10 mystruct *pms1 = &ms1, *pms2 = &ms2;
11
12 int main(int argc, char * argv[]) {
13
14
15
16
17
18
19
20
21 }
int old_value, new_value;
int *p = &old_value, *q = &new_value;
char buf[64];
memcpy(buf, argv[1]);
*p = *q;
// memory error
// assignment gadgets
pms1.foo();
Code 12. A simple program that enables DOP to build control attacks even
if TASR and CCFI are in place, as the data pointers are not protected.
985985
Code 12 shows a simple program where TASR and CCFI
cannot prevent the control attack built with the help of DOP,
as the data pointers are not protected by TASR or CCFI [12],
[14]. There are two data pointers, pms1 and pms2 and
they are also pointing to code pointers foo in corresponding
structures. Legitimately, the indirect function call in line 20
will call the function m1. With the memory error in line 17
and the assignment gadget in line 18, attackers can construct
non-control data exploit to swap the value of pms1 and pms2.
Then the code in line 20 will call function m2 instead.
C. Another Program Allowing DOP to Bypass TASR
jmp *0x08104004
jmp *0x08104008
jmp *0x08104000
1 Disassembly of section .plt
2
3 0804ada0 :
4
5 0804adb0 :
6
7 0804adc0 :
8
9
10 int server(int sockfd) {
11
12
13
14
15
16
17
18
19
20 }
read(sockfd, buf);
*p = *q;
while(connect_limit--) {
}
int old_value, new_value;
int *p = &old_value, *q = &new_value;
int connect_limit = 100;
char buf[64];
// memory error
// assignment gadgets
Code 13. A simple program that enables DOP to break TASR, as no write
operation is necessary during attack.
Code 13 shows a piece code to illustrate another method to
bypass TASR with DOP. This code invokes library functions,
like system and setuid, thus having the function addresses
in the .plt section. With the assignment gadget in line 18, the
attackers can copy the function addresses (e.g., addresses of
setuid and system) from the .plt section to the selected
memory region, like the stack location for server return
address. The gadget dispatcher in line 16 and 17 enables
attackers to prepare a complete stack context for a return-to-
libc attack. When the function returns, the return-to-libc attack
will be launched. TASR fails to prevent such attack as attackers
use DOP to prepare the payload on the stack in the memory,
without any address leakage through the write system call.
D. Using DOP to Break CFI Implementations and DEP
BinCFI. BinCFI uses a read-only table to store all legitimate
function entries and call-sites [8]. Each function call is allowed
to jump to any function entry, and each function return is
permitted to return to any call-site. A successful BinCFI attack
should lead the program call / return to arbitrary locations. We
show one vulnerable program in Code 14 that allows DOP
to mount a BinCFI attack. With the memory error in line
15, attackers can deliver malicious relocation metadata on the
stack and change the value of p and q. With the store gadget
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:14:56 UTC from IEEE Xplore.  Restrictions apply. 
void (*foo)();
1 typedef struct _mystruct {
2
3 } mystruct;
4
5 void m1() = { printf{‘‘hello from m1’’}; }
6
7 mystruct ms1 = { .foo = m1 };
8 mystruct *pms1 = &ms1;
9
10 int main(int argc, char * argv[]) {
11
12
13
14
15
16
17
18
19
20
21 }
int old_value, new_value;
int *p = &old_value, *q = &p;
char buf[64];
dlopen("mylib.so");
pms1.foo();
memcpy(buf, argv[1]);
**q = *p;
*p = *q;
// memory error
// store gadgets
// assignment gadgets
Code 14. A simple program that enables DOP to build control attacks to
bypass Bin-CFI and non-writable-tag based CFI.
in line 16, attackers can change the link_map structure link
list to make it link the malicious relocation metadata. One
functionality of dlopen is to patch the relocated addresses
before real execution. This makes dlopen able to modify
arbitrary memory location, even code pages or read-only data
sections. When dlopen is invoked, the malicious metadata
will trigger the dlopen’s internal gadgets to corrupt the read-
only table. By adding expected code addresses into the table,
attackers is allowed to make the execution jump to arbitrary
code region (line 19).
Protections based on Non-Writable Code Section. W⊕X
disallows the write permission on code section, or execute
permission on data section,
to protect code integrity [16]
and control-ﬂow integrity. For example, the CFI proposed
by Abadi et al. relies on read-only tags inside code region
to enforce the security check [6]. Speciﬁcally, it places tags
before legitimate control-ﬂow transfer targets and checks the
target tag with the predeﬁned tag before each control-ﬂow
transfer at runtime. DOP can help break defenses that are
based on non-writable code. First, attackers can use DOP to
invoke dlopen to corrupt arbitrary code region to mount
code injection attacks. Note that the data region is still non-
executable, even with DOP attacks. Second, DOP can help
change the CFI tags in code region to bypass the CFI solution.
Attackers either copy the tag from the legitimate code target
to the illegal location, or just overwrite both the checking code
to disable CFI.
986986
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:14:56 UTC from IEEE Xplore.  Restrictions apply.