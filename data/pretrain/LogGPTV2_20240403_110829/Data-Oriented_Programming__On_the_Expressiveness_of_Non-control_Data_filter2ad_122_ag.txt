### Symposium, 2014

**References:**

1. **M. Zhang and R. Sekar, "Control Flow Integrity for COTS Binaries,"** in *Proceedings of the 22nd USENIX Security Symposium*, 2013.
2. **C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant, D. Song, and W. Zou, "Practical Control Flow Integrity and Randomization for Binary Executables,"** in *Proceedings of the 34th IEEE Symposium on Security and Privacy*, 2013.
3. **B. Niu and G. Tan, "Per-Input Control-Flow Integrity,"** in *Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security*, 2015.
4. **V. van der Veen, D. Andriesse, E. Göktas, B. Gras, L. Sambuc, A. Slowinska, H. Bos, and C. Giuffrida, "Practical Context-Sensitive CFI,"** in *Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security*, 2015.
5. **A. J. Mashtizadeh, A. Bittau, D. Boneh, and D. Mazières, "CCFI: Cryptographically Enforced Control Flow Integrity,"** in *Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security*, 2015.
6. **V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song, "Code-pointer Integrity,"** in *Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation*, 2014.
7. **D. Bigelow, T. Hobson, R. Rudd, W. Streilein, and H. Okhravi, "Timely Rerandomization for Mitigating Memory Disclosures,"** in *Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security*, 2015.
8. **PaX Team, "PaX Address Space Layout Randomization (ASLR),"** http://pax.grsecurity.net/docs/aslr.txt, 2003.
9. **Microsoft, "Data Execution Prevention (DEP),"** 2006, http://support.microsoft.com/kb/875352/EN-US/.
10. **B. Niu and G. Tan, "Modular Control-flow Integrity,"** in *Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation*, 2014.
11. **J. Criswell, N. Dautenhahn, and V. Adve, "KCoFI: Complete Control-Flow Integrity for Commodity Operating System Kernels,"** in *Proceedings of the 35th IEEE Symposium on Security and Privacy*, 2014.
12. **S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer, "Non-Control-Data Attacks Are Realistic Threats,"** in *Proceedings of the 14th USENIX Security Symposium*, 2005.
13. **"The Heartbleed Bug,"** http://heartbleed.com/.
14. **Yu Yang, "ROPs are for the 99%, CanSecWest 2014,"** https://cansecwest.com/slides/2014/ROPs_are_for_the_99_CanSecWest_2014.pdf, 2014.
15. **H. Hu, Z. L. Chua, S. Adrian, P. Saxena, and Z. Liang, "Automatic Generation of Data-Oriented Exploits,"** in *Proceedings of the 24th USENIX Security Symposium*, 2015.
16. **A. Homescu, M. Stewart, P. Larsen, S. Brunthaler, and M. Franz, "Microgadgets: Size Does Matter in Turing-complete Return-oriented Programming,"** in *Proceedings of the 6th USENIX Conference on Offensive Technologies*, 2012.
17. **"SOP Bypass Demos,"** https://goo.gl/4PfXEg.
18. **N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross, "Control-Flow Bending: On the Effectiveness of Control-Flow Integrity,"** in *Proceedings of the 24th USENIX Security Symposium*, 2015.
19. **C. Planet, "A Eulogy for Format Strings,"** http://phrack.org/issues/67/9.
20. **Microsoft, "set printf count output,"** https://msdn.microsoft.com/en-us/library/ms175782.aspx.
21. **"ProFTPD — Highly configurable GPL-licensed FTP server software,"** http://www.proftpd.org/.
22. **"WU-FTPD Server,"** http://www.wu-ftpd.org/.
23. **"Nginx HTTP Server 1.3.9-1.4.0 Chunked Encoding Stack Buffer Overflow,"** http://mailman.nginx.org/pipermail/nginx-announce/2013/000112.html.
24. **"Bitcoin - Open source P2P money,"** https://bitcoin.org/.
25. **"SSH Communications Security,"** www.ssh.com/.
26. **"Wireshark Go Deep,"** https://www.wireshark.org/.
27. **"Glibc - GNU,"** https://www.gnu.org/s/libc/.
28. **"BusyBox,"** www.busybox.net.
29. **"musl libc,"** http://www.musl-libc.org/.
30. **"MCrypt,"** mcrypt.sourceforge.net/.
31. **"Sudo Main Page,"** http://www.sudo.ws/.
32. **"Buffer Overflow Vulnerability in UPnP library used by Bitcoin Core,"** https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-6031.
33. **"musl libc inet pton.c Remote Stack Buffer Overflow Vulnerability,"** https://security-tracker.debian.org/tracker/CVE-2015-1817.
34. **"Stack-Based Buffer Overflow in the MPEG parser in Wireshark,"** http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2299.
35. **"nginx: Stack-based Buffer Overflow,"** https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-4409.
36. **"Stack-Based Buffer Overflow in Mcrypt,"** http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2028.
37. **"Sudo Format String Vulnerability,"** http://www.sudo.ws/sudo/alerts/sudo_debug.html, 2012.
38. **"Stack-Based Buffer Overflow in the sreplace Function in Proftpd,"** http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5815.
39. **"Integer Overflow Vulnerability in SSH CRC-32 Compensation Attack Detector,"** https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0144.
40. **"Wu-Ftpd Remote Format String Stack Overwrite Vulnerability,"** http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-0573.
41. **R. Shapiro, S. Bratus, and S. W. Smith, "Weird Machines in ELF: A Spotlight on the Underappreciated Metadata,"** in *Proceedings of the 7th USENIX Conference on Offensive Technologies*, 2013.
42. **S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen, A.-R. Sadeghi, S. Brunthaler, and M. Franz, "Readactor: Practical Code Randomization Resilient to Memory Disclosure,"** in *Proceedings of the 36th IEEE Symposium on Security and Privacy*, 2015.
43. **R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham, "Efficient Software-based Fault Isolation,"** in *Proceedings of the 14th ACM Symposium on Operating Systems Principles*, 1993.
44. **T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and Y. Wang, "Cyclone: A Safe Dialect of C,"** in *Proceedings of the USENIX Annual Technical Conference*, 2002.
45. **G. C. Necula, S. McPeak, and W. Weimer, "CCured: Type-safe Retrofitting of Legacy Code,"** in *Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages*, 2002.
46. **S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, "SoftBound: Highly Compatible and Complete Spatial Memory Safety for C,"** in *Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation*, 2009.
47. **S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, "CETS: Compiler Enforced Temporal Safety for C,"** in *Proceedings of the 9th International Symposium on Memory Management*, 2010.
48. **P. Akritidis, "Cling: A Memory Allocator to Mitigate Dangling Pointers,"** in *Proceedings of the 19th USENIX Security Symposium*, 2010.
49. **L. Szekeres, M. Payer, T. Wei, and D. Song, "SoK: Eternal War in Memory,"** in *Proceedings of the 34th IEEE Symposium on Security and Privacy*, 2013.
50. **M. Castro, M. Costa, and T. Harris, "Securing Software by Enforcing Data-Flow Integrity,"** in *Proceedings of the 7th Symposium on Operating Systems Design and Implementation*, 2006.
51. **C. Song, B. Lee, K. Lu, W. R. Harris, T. Kim, and W. Lee, "Enforcing Kernel Security Invariants with Data Flow Integrity,"** in *Proceedings of the 23rd Annual Network and Distributed System Security Symposium*, 2016.
52. **S. Bhatkar and R. Sekar, "Data Space Randomization,"** in *Proceedings of the 5th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment*, 2008.
53. **P. Chen, J. Xu, Z. Lin, D. Xu, B. Mao, and P. Liu, "A Practical Approach for Adaptive Data Structure Layout Randomization,"** in *Proceedings of the 20th European Symposium on Research in Computer Security*, 2015.
54. **K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and A.-R. Sadeghi, "Just-In-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization,"** in *Proceedings of the 34th IEEE Symposium on Security and Privacy (SP '13)*, 2013.
55. **F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and T. Holz, "Counterfeit Object-oriented Programming: On the Difficulty of Preventing Code Reuse Attacks in C++ Applications,"** in *Proceedings of the 36th IEEE Symposium on Security and Privacy*, 2015.
56. **J. Oakley and S. Bratus, "Exploiting the Hard-working DWARF: Trojan and Exploit Techniques with No Native Executable Code,"** in *Proceedings of the 5th USENIX Conference on Offensive Technologies*, 2011.
57. **J. Bangert, S. Bratus, R. Shapiro, and S. W. Smith, "The Page-fault Weird Machine: Lessons in Instruction-less Computation,"** in *Proceedings of the 7th USENIX Conference on Offensive Technologies*, 2013.
58. **M. Rushanan and S. Checkoway, "Run-DMA,"** in *Proceedings of the 9th USENIX Conference on Offensive Technologies*, 2015.

### Appendix

#### A. Example of a Transition Table in MINDOP

Table VIII shows an example of a transition table for simulating a Turing machine that shifts the given input by one bit (equivalent to SHL instruction).

| Σ | q0 | q1 | q2 | q3 |
|---|----|----|----|----|
| Scur = 0 | Snxt = 0, qnxt = q1, D | Snxt = 0, qnxt = q1, D | Snxt = 0, qnxt = q3, HALT | - |
| Scur = 1 | Snxt = 1, qnxt = q1, D | Snxt = 1, qnxt = q1, D | Snxt = 1, qnxt = q3, HALT | - |
| Scur = σ0 | Snxt = σ0, qnxt = q0 | Snxt = 0, qnxt = q2 | Snxt = 1, qnxt = q3, HALT | - |

#### B. A Program Allowing DOP to Bypass TASR and CCFI

```c
void (*foo)();

typedef struct _mystruct {
    void (*foo)();
} mystruct;

void m1() { printf("hello from m1"); }
void m2() { printf("hello from m2"); }

mystruct ms1 = { .foo = m1 };
mystruct ms2 = { .foo = m2 };
mystruct *pms1 = &ms1, *pms2 = &ms2;

int main(int argc, char *argv[]) {
    int old_value, new_value;
    int *p = &old_value, *q = &new_value;
    char buf[64];
    memcpy(buf, argv[1], sizeof(buf));
    *p = *q; // memory error
    // assignment gadgets
    pms1->foo(); // indirect function call
}
```

**Explanation:**
This simple program demonstrates how DOP can be used to build control attacks even if TASR and CCFI are in place, as the data pointers are not protected. The two data pointers, `pms1` and `pms2`, point to code pointers `foo` in corresponding structures. Legitimately, the indirect function call in line 20 will call the function `m1`. With the memory error in line 17 and the assignment gadget in line 18, attackers can construct a non-control data exploit to swap the values of `pms1` and `pms2`. Consequently, the code in line 20 will call function `m2` instead.

#### C. Another Program Allowing DOP to Bypass TASR

```assembly
Disassembly of section .plt:
0804ada0: jmp *0x08104004
0804adb0: jmp *0x08104008
0804adc0: jmp *0x08104000

int server(int sockfd) {
    read(sockfd, buf);
    *p = *q; // memory error
    while(connect_limit--) {
        // assignment gadgets
    }
    int old_value, new_value;
    int *p = &old_value, *q = &new_value;
    int connect_limit = 100;
    char buf[64];
}
```

**Explanation:**
This code illustrates another method to bypass TASR with DOP. The code invokes library functions like `system` and `setuid`, thus having the function addresses in the `.plt` section. With the assignment gadget in line 18, attackers can copy the function addresses (e.g., addresses of `setuid` and `system`) from the `.plt` section to the selected memory region, such as the stack location for the `server` return address. The gadget dispatcher in lines 16 and 17 enables attackers to prepare a complete stack context for a return-to-libc attack. When the function returns, the return-to-libc attack will be launched. TASR fails to prevent such an attack as attackers use DOP to prepare the payload on the stack in memory without any address leakage through the write system call.

#### D. Using DOP to Break CFI Implementations and DEP

**BinCFI:**
BinCFI uses a read-only table to store all legitimate function entries and call-sites [8]. Each function call is allowed to jump to any function entry, and each function return is permitted to return to any call-site. A successful BinCFI attack should lead the program call/return to arbitrary locations. 

**Vulnerable Program:**

```c
void (*foo)();

typedef struct _mystruct {
    void (*foo)();
} mystruct;

void m1() { printf("hello from m1"); }

mystruct ms1 = { .foo = m1 };
mystruct *pms1 = &ms1;

int main(int argc, char *argv[]) {
    int old_value, new_value;
    int *p = &old_value, *q = &p;
    char buf[64];
    dlopen("mylib.so");
    pms1->foo();
    memcpy(buf, argv[1], sizeof(buf));
    **q = *p; // store gadgets
    *p = *q; // assignment gadgets
    // memory error
}
```

**Explanation:**
With the memory error in line 15, attackers can deliver malicious relocation metadata on the stack and change the value of `p` and `q`. With the store gadget in line 16, attackers can change the `link_map` structure link list to make it link the malicious relocation metadata. One functionality of `dlopen` is to patch the relocated addresses before real execution, making `dlopen` able to modify arbitrary memory locations, even code pages or read-only data sections. When `dlopen` is invoked, the malicious metadata will trigger `dlopen`'s internal gadgets to corrupt the read-only table. By adding expected code addresses into the table, attackers can make the execution jump to arbitrary code regions (line 19).

**Protections Based on Non-Writable Code Section:**
W⊕X disallows the write permission on code sections or execute permission on data sections to protect code integrity [16] and control-flow integrity. For example, the CFI proposed by Abadi et al. relies on read-only tags inside code regions to enforce security checks [6]. Specifically, it places tags before legitimate control-flow transfer targets and checks the target tag with the predefined tag before each control-flow transfer at runtime. DOP can help break defenses based on non-writable code. First, attackers can use DOP to invoke `dlopen` to corrupt arbitrary code regions to mount code injection attacks. Note that the data region is still non-executable, even with DOP attacks. Second, DOP can help change the CFI tags in code regions to bypass the CFI solution. Attackers either copy the tag from the legitimate code target to the illegal location or overwrite both the checking code to disable CFI.