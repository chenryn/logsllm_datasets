# 04 \| 三步走：如何了解一个软件的设计？你好！我是郑晔。 经过了前面几讲的铺垫，我们已经对软件设计是什么，以及要考虑哪些因素有了一个初步的了解。热身之后，就该开启正式的旅程了。 作为一个程序员，我们在职业生涯中免不了要接手新项目，承担维护该项目的职责。如果一个新项目摆在面前，你会怎么去研究它呢？ 很多人的第一反应就是去看源代码。但是，一头扎入代码中，很快你就会迷失其中，最初那股子探索精神，也会逐渐被迷茫所代替。回想一下，有多少次你满怀希望地打开一个开源项目，结果多半都是坚持不了多久就放弃了。你有没有想过，问题出在哪里呢？ 你的迷茫在于缺少对这个软件整体的了解，这就如同不带地图指南针闯入密林一般，迷路只是早晚的事。所以，虽然阅读源码是必经的一步，却不应该是你的第一步。我们应该先从了解软件的设计开始。那我们该如何了解一个软件的设计呢？ 模型、接口和实现了解一个软件的设计可以从三个部分着手：**模型、接口和实现**。这三者的关系就好比你去看代码，你会先去看有哪些类以及它们之间的关系，这就是看模型；然后你会打开一个具体的类，看它提供了哪些方法，这就相当于看接口；最后，你再来打开一个具体的方法，去看它的代码是怎么写的，这就是看实现。 好，接下来，我们具体地分析一下每一个部分。 首先是**模型**，它是一个软件的核心部分。在其它的材料里，也有人称之为抽象，为了统一，我这里就都叫模型了。我们在前面的课程里也说过，设计最关键的就是构建出模型。而理解一个设计中的模型，可以帮助我们建立起对这个软件整体的认知。 比如，你在编写分布式计算代码时，需要考虑怎样在不同的节点上调度计算；而使用MapReduce 时，只要考虑如何把计算分开（Map）最后再汇总（Reduce）；而到了Spark，注意力就集中在要做怎样的计算上。它们在解决同样的问题，只是抽象层次逐步提高了，越来越接近要解决的问题，越来越少地考虑计算在不同的机器上是如何执行的，由此，降低了理解的门槛。 当你知道了模型的重要性，目光甚至可以不局限在某一个软件上。如果把同一个领域不同阶段的多个模型联系起来看，你还能看到软件发展的趋势。 其次是**接口**，它决定了软件通过怎样的方式，将模型提供的能力暴露出去。它是我们与这个软件交互的入口。如何理解这句话呢？我给你举几个具体的例子。 1.  一个程序库的接口就是它的    API，但对于同样的模型，每个人会设计出不同的 API，而不同的 API    有着不同的表达能力。比如：Google 的 Guava 对 JDK 的一些 API    重新做了封装，其目的就是简化开发，而很多优秀的做法后来又被 JDK    学了回去。        2.  一个工具软件一般会提供命令行接口，比如，每个程序员必备的基本技能------Unix    命令行工具就是典型的命令行接口。        3.  一个业务系统的接口，就是对外暴露的各种接口，比如，它提供的各种    REST API，也可能是提供了 RPC    给其它系统的调用。        4.  ......        如果你想深入源码，去了解一个软件，接口是一个很好的指向标。你可以从一个接口进入到软件中，看它是怎样完成各种基本功能的。 最后是**实现**，就是指软件提供的模型和接口在内部是如何实现的，这是软件能力得以发挥的根基。这么说可能比较抽象，我再来举些例子。 1.  一个业务系统收到一个请求之后，是把信息写到数据库，还是转发给另外的系统。        2.  一个算法的实现，是选择调用与别人已有的程序库，还是需要自己实现一个特定的算法。        3.  一个系统中的功能，哪些应该做成分布式的，哪些应该由一个中央节点统一处理。        4.  一段业务处理，是应该做成单线程，还是多线程的。        5.  当资源有竞争，是每个节点自己处理，还是交由一个中间件统一处理。        6.  不同系统之间的连接，该采用哪种协议，是自己实现，还是找一个中间件。        7.  ......        讲到这，相信你一定发现了，"实现"里面的内容很多。所以，做每一个技术决策都应该结合自己所开发应用的特点，并不存在一个通用的解决方案。在实际的工作中，我发现许多人以为的设计其实是这里所讲的实现。 我也知道，"实现"很重要，但是，它必须建立在模型和接口的基础之上。因为在一个系统的设计中，模型是最核心的部分。如果模型变了，这个软件便不再是这个软件了，而接口通常反映的就是模型。所以，模型和接口的稳定度都要比实现高，实现则是要随着软件发展而不断调整。 举个例子，很多人都知道 Redis 这个键值对存储性能非常好，他们学习 Redis时，对其单线程模型印象深刻，因为它简单高效。但随着人们使用 Redis的增多，对 Redis 有了进一步的需求。所以，从 6.0开始，它开始支持多线程版本，以便于更好地满足人们的需求。但即便 Redis改成了多线程，它还是那个Redis，它的模型和接口还是一如既往，只是实现变了而已。 了解设计三步走之所以要把模型、接口和实现区分开来，是因为这三者的关注点是不同的，而很多人在讨论所谓的"设计"时，经常会把它们混在一起。 如果你在讨论的时候连"讨论的内容到底是什么"都没弄清楚，就很难得出一个清晰的结果。我参与过很多类似的讨论，经常有一种很混乱的感觉。我思考了很长时间才发现，问题就在于他们把不同层面的内容混在了一起。 所以正确的做法是什么呢？就是你在讨论设计时应该遵循一个顺序，**先模型，再接口，最后是实现**，同理，了解一个设计也应该遵循这样的顺序。 ![](Images/f4b6297b35cd4824afe71ef94da3c1e9.png)savepage-src="https://static001.geekbang.org/resource/image/b1/84/b1279d9a81d8b271c01270d3da8f0684.jpg"}如果模型都还没有弄清楚，就贸然进入细节的讨论，你很难分清哪些东西是核心，是必须保留的，哪些东西是可以替换的。如果你清楚了解了模型，也就知道哪些内容在系统中是广泛适用的，哪些内容必须要隔离。简单地说，分清模型会帮助你限制实现的使用范围。 下面是一张简化过的架构图，在这幅图里，订单模块完成处理之后，通过一个Kafka 队列把消息发给支付模块，支付模块处理之后，再通过一个 Kafka队列把消息发给物流模块。很多人都应该在自己的项目中见过类似的，但是更复杂的架构图。你能看出这张图的问题在哪吗？ ![](Images/3ae764b09ce95786586a524a4f4d5e59.png)savepage-src="https://static001.geekbang.org/resource/image/eb/3e/ebc3bf3cb03421de4b2a0f642940bd3e.jpg"}这张架构图的问题就在于，它把模型和实现混淆在一起了。图中的订单、支付和物流，说的都是模型层面的东西，但Kafka 的出现，就把实现层面的东西拉了进来。Kafka只是实现这个功能时的一个技术选型，这也就意味着，如果随着业务的发展，它不能很好地扮演它的角色，你就可以替换掉它，而整个设计是不用变的。 所以，实现这段代码的时候，必须把 Kafka相关的代码进行封装，不能在系统各处随意地调用，因为它属于实现，是可能被替换的。 我还要强调一点，在了解设计时，要按层次去了解，因为设计常常是分层的。每当我们打开一个层次，需要了解它的内部时，我们还要按照模型、接口和实现的顺序解读这个层次。 我用大家比较熟悉的操作系统来举个例子，如果你去了解它的内部，就知道它有内存管理、进程调度、文件系统等模块。我们可以按照模型、接口和实现去理解每个模块，就以进程管理为例： 1.  进程管理的核心模型就包括进程模型和调度算法；        2.  它的接口就包括，进程的创建、销毁以及调度算法的触发等；        3.  不同调度算法就是一个个具体的实现。        操作系统课程难以学习，很大程度上就在于，很多人没有搞清楚其中各个概念之间的关系。 即便层层展开到最后，到了一个具体类，甚至是一个具体的数据结构，我们依然可以按照模型、接口和实现这个结构来理解，比如很多Java 面试题常问到的 HashMap： 1.  它的模型就是我们在数据结构中学习的    HashMap；        2.  它定义了一些接口，比如，get、put    等；    3.  它的实现原来是用标准的 HashMap    实现，后来则借鉴了红黑树。        实际上，当你能够一层一层地去理解设计，就像一棵知识树逐渐展开一样，每一个知识节点在展开的时候，都会有下面一级更具体的内容。当你的头脑中有了这样一棵设计树，你也就掌握了整个系统的地图，再有新需求到来时，你就不会再盲目地去改代码了。 总结时刻今天，我们学习了如何了解一个软件设计，可以从三个部分入手：模型、接口和实现。 1.  模型，也可以称为抽象，是一个软件的核心部分，是这个系统与其它系统有所区别的关键，是我们理解整个软件设计最核心的部分。        2.  接口，是通过怎样的方式将模型提供的能力暴露出去，是我们与这个软件交互的入口。        3.  实现，就是软件提供的模型和接口在内部是如何实现的，是软件能力得以发挥的根基。        了解设计的顺序应该是，**先模型，再接口，最后是实现**。了解设计，需要一层一层地展开，在每个层次都按照模型、接口和实现进行理解，在头脑中形成一棵设计树。 现在你已经有了一个了解设计的基本方法，接下来几讲，我会用几个开源项目带你再进一步，去看看如何去了解模型、接口和实现。 如果今天的内容你只能记住一件事，那请记住：**了解设计，先模型，再接口，最后是实现**。 ![](Images/d7f5f7aa0ac7f042c47a911691901d52.png)savepage-src="https://static001.geekbang.org/resource/image/c3/37/c33374c66f20f52ce6119e64b53ae137.jpg"}思考题现在的开源项目越来越多，每个开源项目都会提供一些不同的特点，请你找一些自己感兴趣的开源项目，看看它们分别提供了什么，是新的模型、是新的接口，还是新的实现？欢迎在留言区分享你的思考。 感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。 
# 05 \| Spring DI容器：如何分析一个软件的模型？你好！我是郑晔。在上一讲中，我们讨论了如何了解一个软件的设计，主要是从三个部分入手：模型、接口和实现。那么，在接下来的三讲中，我将结合几个典型的开源项目，告诉你如何具体地理解一个软件的模型、接口和实现。今天这一讲，我们就先来谈谈了解设计的第一步：模型。如果拿到一个项目，我们怎么去理解它的模型呢？**我们肯定要先知道项目提供了哪些模型，模型又提供了怎样的能力。**这是所有人都知道的事情，我并不准备深入地去探讨。但如果只知道这些，你只是在了解别人设计的结果，这种程度并不足以支撑你后期对模型的维护。在一个项目中，常常会出现新人随意向模型中添加内容，修改实现，让模型变得难以维护的情况。造成这一现象的原因就在于他们对于模型的理解不到位。我们都知道，任何模型都是为了解决问题而生的，所以，理解一个模型，需要了解在没有这个模型之前，问题是如何被解决的，这样，你才能知道新的模型究竟提供了怎样的提升。也就是说，**理解一个模型的关键在于，要了解这个模型设计的来龙去脉，知道它是如何解决相应的问题。**今天我们以 Spring 的 DI容器为例，来看看怎样理解软件的模型。耦合的依赖Spring 在 Java 世界里绝对是大名鼎鼎，如果你今天在做 Java 开发而不用Spring，那么你大概率会被认为是个另类。今天很多程序员都把 Spring 当成一个成熟的框架，很少去仔细分析 Spring的设计。但作为一个从 0.8 版本就开始接触 Spring的程序员，我刚好有幸经历了 Spring 从渺小到壮大的过程，得以体会到 Spring给行业带来的巨大思维转变。如果说 Spring 这棵参天大树有一个稳健的根基，那其根基就应该是 Spring的 DI 容器。DI 是 Dependency Injection 的缩写，也就是"依赖注入"。Spring的各个项目都是这个根基上长出的枝芽。那么，DI容器要解决的问题是什么呢？它解决的是**组件创建和组装**的问题，但是为什么这是一个需要解决的问题呢？这就需要我们了解一下组件的创建和组装。在前面的课程中，我讲过，软件设计需要有一个分解的过程，所以，它必然还要面对一个组装的过程，也就是把分解出来的各个组件组装到一起，完成所需要的功能。为了叙述方便，我采用 Java语言来进行后续的描述。我们从程序员最熟悉的一个查询场景开始。假设我们有一个文章服务（ArticleService）提供根据标题查询文章的功能。当然，数据是需要持久化的，所以，这里还有一个ArticleRepository，用来与持久化数据打交道。熟悉 DDD 的同学可能发现了，这个仓库（Repository）的概念来自于DDD。如果你不熟悉也没关系，它就是与持久化数据打交道的一层，和一些人习惯的Mapper 或者 DAO（Data AccessObject）类似，你可以简单地把它理解成访问数据库的代码。    class ArticleService {      //提供根据标题查询文章的服务      Article findByTitle(final String title) {        ...      }    }    interface ArticleRepository {      //在持久化存储中，根据标题查询文章      Article findByTitle(final String title)；    }在 ArticleService 处理业务的过程中，需要用到 ArticleRepository辅助它完成功能，也就是说，ArticleService 要依赖于ArticleRepository。这时你该怎么做呢？一个直接的做法就是在 ArticleService中增加一个字段表示ArticleRepository。    class ArticleService {      private ArticleRepository repository;            public Article findByTitle(final String title) {        // 做参数校验        return this.repository.findByTitle(title);      }    }目前看起来一切都还好，但是接下来，问题就来了，这个字段怎么初始化呢？程序员一般最直接的反应就是直接创建这个对象。这里选用了一个数据库版本的实现（DBArticleRepository）。    class ArticleService {      private ArticleRepository repository = new DBArticleRepository();            public Article findByTitle(final String title) {        // 做参数校验        return this.repository.findByTitle(title);      }    }看上去很好，但实际上 DBArticleRepository并不能这样初始化。正如这个实现类的名字所表示的那样，我们这里要用到数据库。但在真实的项目中，由于资源所限，我们一般不会在应用中任意打开数据库连接，而是会选择共享数据库连接。所以，DBArticleRepository需要一个数据库连接（Connection）的参数。在这里，你决定在构造函数里把这个参数传进来。    class ArticlService {      private ArticleRepository repository;            public ArticlService(final Connection connection) {        this.repository = new DBArticleRepository(connection);      }            public Article findByTitle(final String title) {        // 做参数校验        return this.repository.findByTitle(title);      }    }好，代码写完了，它看上去一切正常。如果你的开发习惯仅仅到此为止，可能你会觉得这还不错。但我们并不打算做一个只写代码的程序员，所以，我们要进入下一个阶段：测试。一旦开始准备测试，你就会发现，要让 ArticleService 跑起来，那就得让ArticleRepository 也跑起来；要让 ArticleRepository跑起来，那就得准备数据库连接。是不是觉得太麻烦，想放弃测试。但有职业素养的你，决定坚持一下，去准备数据库连接信息。然后，真正开始写测试时，你才发现，要测试，你还要在数据库里准备各种数据。比如，要测查询，你就得插入一些数据，看查出来的结果和插入的数据是否一致；要测更新，你就得先插入数据，测试跑完，再看数据更新是否正确。不过，你还是没有放弃，咬着牙准备了一堆数据之后，你突然困惑了：我在干什么？我不是要测试服务吗？做数据准备不是测试仓库的时候应该做的事吗？那么，问题出在哪儿呢？其实就在你创建对象的那一刻，问题就出现了。分离的依赖为什么说从创建对象开始就出问题了呢？因为当我们创建一个对象时，就必须要有一个具体的实现类，对应到我们这里，就是那个DBArticleRepository。虽然我们的 ArticleService写得很干净，其他部分根本不依赖于DBArticleRepository，只在构造函数里依赖了，但依赖就是依赖。与此同时，由于要构造 DBArticleRepository 的缘故，我们这里还引入了Connection 这个类，这个类只与 DBArticleRepository的构造有关系，与我们这个 ArticleService的业务逻辑一点关系都没有。所以，你看到了，只是因为引入了一个具体的实现，我们就需要把它周边配套的东西全部引入进来，而这一切与这个类本身的业务逻辑没有任何关系。这就好像，你原本打算买一套家具，现在却让你必须了解树是怎么种的、怎么伐的、怎么加工的，以及家具是怎么设计、怎么组装的，而你想要的只是一套能够使用的家具而已。这还只是最简单的场景，在真实的项目中，构建一个对象可能还会牵扯到更多的内容：1.  根据不同的参数，创建不同的实现类对象，你可能需要用到工厂模式。        2.  为了了解方法的执行时间，需要给被依赖的对象加上监控。        3.  依赖的对象来自于某个框架，你自己都不知道具体的实现类是什么。        4.  ......        所以，即便是最简单的对象创建和组装，也不像看起来那么简单。既然直接构造存在这么多的问题，那么最简单的办法就是把创建的过程拿出去，只留下与字段关联的过程：    class ArticleService {      private ArticleRepository repository;            public ArticleService(final ArticleRepository repository) {        this.repository = repository;      }            public Article findByTitle(final String title) {        // 做参数校验        return this.repository.findByTitle(title);      }    }这时候，ArticleService 就只依赖 ArticleRepository。而测试ArticleService 也很简单，只要用一个对象将 ArticleRepository的行为模拟出来就可以了。通常这种模拟对象行为的工作用一个现成的程序库就可以完成，这就是那些Mock 框架能够帮助你完成的工作。或许你想问，在之前的代码里，如果我用 Mock 框架模拟 Connection类是不是也可以呢？理论上，的确可以。但是想要让 ArticleService的测试通过，就必须打开 DBArticleRepository的实现，只有配合着其中的实现，才可能让 ArticleService跑起来。显然，你跑远了。现在，对象的创建已经分离了出去，但还是要要有一个地方完成这个工作，最简单的解决方案自然是，把所有的对象创建和组装在一个地方完成：    ...    ArticleRepository repository = new DBArticleRepository(connection);    AriticleService service = new ArticleService(repository);    ...相比于业务逻辑，组装过程并没有什么复杂的部分。一般而言，纯粹是一个又一个对象的创建以及传参的过程，这部分的代码看上去会非常的无聊。虽然很无聊，但这一部分代码很重要，最好的解决方案就是有一个框架把它解决掉。在Java世界里，这种组装一堆对象的东西一般被称为"容器"，我们也用这个名字。    Container container = new Container();    container.bind(Connection.class).to(connection);    container.bind(ArticleReposistory.class).to(DBArticleRepository.class);    container.bind(ArticleService.class).to(ArticleService.class)    ArticleService service = container.getInstance(ArticleService.class);至此，一个容器就此诞生。因为它解决的是依赖的问题，把被依赖的对象像药水一样，注入到了目标对象中，所以，它得名"依赖注入"（DependencyInjection，简称 DI）。这个容器也就被称为 DI容器了。 至此，我简单地给你介绍了 DI 容器的来龙去脉。虽然上面这段和 Spring DI容器长得并不一样，但其原理是一致的，只是接口的差异而已。事实上，这种创建和组装对象的方式在当年引发了很大的讨论，直到最后Martin Fowler 写了一篇《反转控制容器和依赖注入模式slate-object="inline"》的文章，才算把大家的讨论做了一个总结，行业里总算是有了一个共识。那段时间，DI 容器也得到了蓬勃的发展，很多开源项目都打造了自己的 DI容器，Spring 是其中最有名的一个。只不过，Spring并没有就此止步，而是在这样一个小内核上面发展出了更多的东西，这才有了我们今天看到的庞大的Spring 王国。讲到这里，你会想，那这和我们要讨论的"模型"有什么关系呢？正如我前面所说，很多人习惯性把对象的创建和组装写到了一个类里面，这样造成的结果就是，代码出现了大量的耦合。时至今日，很多项目依然在犯同样的错误。很多项目测试难做，原因就在于此。这也从另外一个侧面佐证了可测试性的作用，我们曾在第 3 讲slate-object="inline"中说过：可测试性是衡量设计优劣的一个重要标准。由此可见，在没有 DI容器之前，那是怎样的一个蛮荒时代啊！有了 DI 容器之后呢？你的代码就只剩下关联的代码，对象的创建和组装都由DI容器完成了。甚至在不经意间，你有了一个还算不错的设计：至少你做到了面向接口编程，它的实现是可以替换的，它还是可测试的。与之前相比，这是一种截然不同的思考方式，而这恰恰就是DI 容器这个模型带给我们的。而且，一旦有了容器的概念，它还可以不断增强。比如，我们想给所有与数据库相关的代码加上时间监控，只要在容器构造对象时添加处理即可。你可能已经发现了，这就是AOP（Aspect OrientedProgramming，面向切面编程）的处理手法。而这些改动，你的业务代码并无感知。Spring 的流行，对于提升 Java世界整体编程的质量是大有助益的。因为它引导的设计方向是一个好的方向，一个普通的Java 程序员写出来的程序只要符合 Spring引导的方向，那么它的基本质量就是有保障的，远超那个随意写程序的年代。不过，如果你不能认识到 DI容器引导的方向，我们还是无法充分利用它的优势，更糟糕的是，我们也不能太低估一些程序员的破坏力。我还是见过很多程序员即便在用了Spring之后，依然是自己构造对象，静态方法满天飞，把原本一个还可以的设计，打得七零八落。你看，通过上面的分析，我们知道了，只有理解了模型设计的来龙去脉，清楚认识到它在解决的问题，才能更好地运用这个模型去解决后面遇到的问题。如果你是这个项目的维护者，你才能更好地扩展这个模型，以便适应未来的需求。总结时刻今天，我们学习了如何了解设计的第一部分：看模型。**理解模型，要知道项目提供了哪些模型，这些模型都提供了怎样的能力**。但还有更重要的一步就是，**要了解模型设计的来龙去脉**。这样，一方面，可以增进了我们对它的了解，但另一方面，也会减少我们对模型的破坏或滥用。我以 Spring 的 DI 容器为例给你讲解了如何理解模型。DI容器的引入有效地解决了对象的创建和组装的问题，让程序员们拥有了一个新的编程模型。按照这个编程模型去写代码，整体的质量会得到大幅度的提升，也会规避掉之前的许多问题。这也是一个好的模型对项目起到的促进作用。像DI这种设计得非常好的模型，你甚至不觉得自己在用一个特定的模型在编程。有了对模型的了解，我们已经迈出了理解设计的第一步，下一讲，我们来看看怎样理解接口。如果今天的内容你只能记住一件事，那请记住：**理解模型，要了解模型设计的来龙去脉。**![](Images/9f8d51952ee526ab2b0304051b96139f.png)savepage-src="https://static001.geekbang.org/resource/image/50/a2/50983d3d104c811f33f02db1783d4da2.jpg"}思考题最后，我想请你思考一个问题，DI容器看上去如此地合情合理，为什么在其他编程语言的开发中，它并没有流行起来呢？欢迎在留言区写下你的思考。感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。