ﬁles or registry keys for instances, should be carefully
handled.
An alternative approach is to run the two instances
in separate environments through the use of virtual ma-
chines. Virtual machines provide strong isolation in a
natural way, and this separation can be leveraged to pro-
vide a “physical” shield between public and sensitive
data. Also, virtual machine support is gaining increasing
attention as a commoditized product; most mainstream
hardware and software platforms provide some form of
virtualization today, and the trend is on the rise.
Our approach is therefore to have Ppublic execute
on a virtual machine environment (called V Mpublic).
Pprivate can be run on the same host platform, or in a
separate virtual machine. This design choice does not
affect conﬁdentiality as Pprivate will not anyway be al-
lowed to communicate over the network. Let us call the
environment in which Pprivate runs as V Mprivate.
Implementation In our approach, the virtual environ-
ment used to create and manage the two virtual ma-
chines is provided by VirtualBox [7], a general-purpose
full virtualizer for x86 hardware. The systems running
in the virtual machines are identical. To support simul-
taneous execution of the same process in both virtual
machines, the inputs to V Mpublic is augmented as de-
scribed in the next section.
325325
3.2 Providing simultaneous inputs
Recall from Figure 1 that both Ppublic and Pprivate need
to be provided identical public inputs and different pri-
vate inputs. Identical public inputs are required so that
the resulting system has the same behavior as P if con-
ﬁdentiality is respected. Differing private inputs are
needed so that any network communication resulting
from use of “constant” inputs can be allowed without
the fear of loss of conﬁdentiality.
We systematically divide the vectors that a program
may receive as inputs into three parts (1) input read from
the operating system resources such as ﬁle system and
registry (2) input obtained through user interaction such
as keyboard mouse input and (3) input from the network.
Furthermore, we require that both execution environ-
ments be identical except for any differences in sensitive
data.
Achieving identical initial environments.
It is also
important that the initial environments for V Mpublic and
V Mprivate be the same.
In our approach, the identi-
cal initial states of the two machines have been achieved
by cloning the virtual disk image of the ﬁrst virtual en-
vironment. We used the VirtualBox tool VBoxManage
for this purpose, which performs a physical one-to-one
copy of a virtual disk (source) into another one (destina-
tion). The only difference between the two virtual disks
is their VirtualBox identiﬁcation number (UUID). Sub-
sequently, these two virtual environments are allowed to
differ only in the contents of sensitive data as explained
below.
Providing Identical keyboard and mouse inputs.
When the user enters keyboard or mouse input that
is not sensitive, we need to relay that to V Mpublic.
This requires establishing a communication protocol be-
tween the two environments. A key implementation
technique in our approach to facilitate such identical
and simultaneous public inputs is to employ the pop-
ular VNC protocol [15], as the protocol to communi-
cate keyboard and mouse events, or more generally, the
same desktop events to be shared by both V Mpublic
and V Mprivate. We will use VNC to allow same in-
puts (mouse and keyboard) to be replicated on both
V Mprivate and V Mpublic.
A typical VNC application (such as TightVNC [19]),
is made up of two components: a client, whose function
is to send to the remote machine (the server) any event
generated by the virtual desktop, displayed inside a win-
dow; and the server, whose aim is to“inject” into the
hosting system the events sent by the client, as a normal
Win32 Event.
For our implementation, to obtain two environments
executing in parallel, we augmented the original behav-
ior of TightVNC client in the following way. At ﬁrst we
created a separate executable-DLL, in order to globally
“hook” [11] both the mouse and keyboard events. This
DLL was later loaded into the TightVNC application
(client-side), after the remote connection setup phase, so
that every mouse or keyboard event currently happening
in the system would also be redirected to this applica-
tion. In this way, the incoming events are processed by
Tight VNC application and sent to the remote machine.
The server component, of the TightVNC application, did
not require any enhancement. It relays all events from
the client to the Ppublic environment. By maintaining
the same resolution, and the same initial state of the two
virtual machines, the VNC module guarantees that the
two Windows desktops evolve almost concurrently.
A typical scenario of our implementation is the fol-
lowing: let us say the user is interacting directly with
V Mprivate (running Pprivate); further, using the mouse
she double-clicks on the Firefox icon on the Desktop.
The same mouse gestures are replicated in V Mpublic
so the browser starts up on both the machines. Let’s
suppose that the homepage is set to www.google.com;
the user now inputs a search-key through the keyboard
in the input ﬁeld and presses Enter. Since the key-
board and mouse keystrokes are identically replicated on
V Mpublic, now both machines will have an instance of
Firefox opened displaying the results of the performed
search.
Asymmetric private data ﬂow
Providing user input asymmetry. So far we have ex-
plained our solution for the problem of providing public
inputs through the keyboard and mouse. However, the
user may choose to enter private data into an application.
As explained in Figure 1, we need to provide “constant”
data to the public machine, in place of the private data.
Since the privacy requirements vary by user, we will re-
quire some amount of involvement from the user to iden-
tify and group private information. Our preliminary im-
plementation in providing such asymmetry is to require
each user to create a “Portfolio” of private information
and corresponding “constant” information, similar to the
one presented in Table 2. On the private environment,
we will need to supply the real information of a user,
while on the public environment we will need to supply
fake private information. When a user wants to provide
any such private information to the application, she will
simply copy and paste the information from the Portfo-
lio into the applications ﬁles. Our implementation has a
speciﬁc clipboard handler for the portfolio; every time
326326
a value is chosen for a private value, the corresponding
fake value is sent to the clipboard of the shadow virtual
machine. For instance, if the application requires a mail
address which the user considers private, the public en-
vironment will get the corresponding fake address.
Providing ﬁle asymmetry. Whenever the application
reads ﬁles that contain sensitive data, we will need to
replace such ﬁles by those that contain fake data, such
as a string of constant lengths. We have also augmented
our public virtual environment with a ﬁle interposition
mechanism in a dynamically linked library (DLL). This
DLL intercepts all I/O system calls (API) to ﬁles and
re-writes these calls to perform an action supplied by
our implementation. When writing to public ﬁles this
module has no effects. On the other hand, when writ-
ing on sensitive ﬁles, while on private environment the
WriteFile function will execute as normal, on V Mpublic
(through our interposition) it will perform a dummy
write through the injection of a constant string of char-
acters. This way, we maintain “dummy” modiﬁcations
on V Mpublic for every corresponding change in the sen-
sitive ﬁle in V Mprivate.
The File Access Monitor is based on Detour [6], an
interposition library provided by Microsoft for instru-
menting arbitrary Win32 functions.
3.3 Monitoring network output
Our approach inhibits network access to V Mprivate, the
one with private information, while it allows V Mpublic
to communicate over the network. It replays any result-
ing communication to V Mprivate.
Our approach for achieving this functionality in-
volves the use of a network proxy. Since most applica-
tions use HTTP protocol for receiving updates, our im-
plementation prototype focuses only on the HTTP proto-
col messages that are sent by the application. Our future
implementation will require employing similar proxies
to handle other network protocols. The rest of this sec-
tion focuses on the speciﬁcs of the HTTP proxy.
The purpose of our HTTP Proxy is to intercept re-
quests by both V Mprivate and V Mpublic, but only the
requests performed by V Mpublic will actually reach the
remote server, while the ones of V Mprivate, will be
“paused” at the proxy. When the remote server replies
to V Mpublic, its response will be forwarded to both
V Mprivate and V Mpublic. To achieve these require-
ments, we modiﬁed jProxy, an HTTP proxy for our pro-
totype implementation.
Note that every HTTP connection can be identiﬁed
by the  pair. We implemented a
data cache inside jProxy, based on this pair. This cache
V Mprivate
Client sends Req to Proxy
Proxy searching in Cache
Proxy gets a hit in the Cache
Proxy sends Res to Client
Entry removed from Cache
V Mpublic
Client sends Req to Proxy
Proxy sends Req to Server
Proxy receives Res from Server
Proxy saves Res in Cache
and forwards it to Client
Table 1. Steps executed by Proxy
is accessed by the working threads in the following man-
ner: when V Mpublic obtains a response to a previous re-
quest, the thread managing the connection saves the pair
. Since the two machines are
performing the same action, V Mprivate, at some point,
will perform the same request of V Mpublic. The request
of V Mpublic, however, is not forwarded to the remote
server: instead, the response will be searched inside the
cache, for a ﬁxed amount of time. If found, it will be sent
back to the application. In this way, V Mprivate never
really accesses the external network, but, at the same, is
able to obtain valid responses to its requests.
Since the actions on the two environments are not
perfectly synchronized, two scenarios can occur:
1. V Mpublic is the ﬁrst one performing the request
and obtaining the response before V Mprivate tries
to forward its request; in this case when V Mprivate
searches in the cache it will ﬁnd the correspond entry
in the cache and will fetch the content of the response.
2. V Mprivate is the ﬁrst one performing the request and
V Mprivate has not send the request yet or it did not re-
ceive the response so far; in this scenario, V Mprivate
will perform a ﬁxed amount of trials reading the proxy
cache until it ﬁnds the entry that it was looking for.
A sketch of concurrent execution on the two virtual ma-
chines is presented in Table 1.
4 Results
4.1 Functional Evaluation
We present a functional evaluation of our approach.
These tests were performed to verify the effectiveness
of our implementation to enforce conﬁdentiality, han-
dle different possible scenarios that may occur in a real
system, and guarantee the functionalities of applications
that preserve conﬁdentiality. In evaluating applications,
we used the tool Wireshark [24], which is an auto-
matic network protocol analyzer for Windows and Unix
327327
Country
Language
Zip Code
Birth Date
Sex
REAL
Italy
Italian
21100
1984
M
FAKE
Switzerland
English(US)
99999
1956
F
Table 2. Part of the Portfolio used for the
testing phase
that allows live examination of data from a network.
We based the functional evaluation on the following list
of programs:
• Adobe Reader, a popular viewer application for PDF
ﬁles. the functionality that we tested was the update
process of the application. This is a test case in which
we observed no leakage of information.
• Apple Update, a tool that allow to search for updates
for all the multimedia applications (such as Quick-
Time and iTunes) produced by Apple. The analysis
of network trafﬁc for this case shows a ﬂow of only
public information about the system.
• Real Player, a well known multimedia player. This
third test case focused on the update process per-
formed by the application. This time we observed an
attempt to leak sensitive information about the user.
• Mozilla Firefox, a popular web-browser. This test case
is useful to show how our platform behaves when the
functionalities tested are different from a simple pro-
gram update. The purpose was to understand whether
our approach was capable of dealing with more com-
plex pairs of requests and responses, especially when
interacting with highly dynamical websites.
Table 2 shows a scratch of the portfolio of data used
for all these experiments. Let us now have a closer look
at the results obtained by the evaluation of these pro-
grams.
Adobe Reader By inspecting the packets exchanged by
the two instances of Adobe Reader during the update
process, we observed that there are no differences. Since
the program respects the user’s conﬁdentiality in every
run we tested, its behavior is preserved by our approach.
In this test case analyzing the network
Apple Update
trafﬁc of the two instances, we noticed that the informa-
tion sent to the Apple server only included information
about the graphics controller of the system, and since
this happened to be the same in both the virtual ma-
Figure 2. Real Player Output - Real and Vir-
tual Machine
chines, no difference was reported, and the system was
successfully able to obtain all updates from Apple.com.
Real Player The results presented by this test case are
the most interesting ones. The output sent by RealPlayer
to the network is presented in Figure 2. A detailed anal-
ysis of the output showed that Real Player does leak
some information that could be considered conﬁdential
by a user. The behavior that raises potential concern
has been pointed out by the presence of two different
strings contained in the output: In the ﬁrst line of the
output transcript, at the end of the line, we highlight the
string “it21100” in V Mprivate and the string “ch99999”
in V Mpublic. The meaning of these two sequences of
characters is quite evident after a manual analysis: the
ﬁrst two characters represent the country through which
the program was registered, while the following num-
bers are the ZIP code. This information was supplied
by the user when installing the program, using a Port-
folio of data such as the one presented before. The
pair  represents location informa-
tion for a user, and can be considered sensitive.
Its
leakage over the network violates conﬁdentiality. How-
ever, in our case, using the portfolio, the user supplied
fake country (“ch”) and zip code (“99999”) and this was
communicated to the external network, and the program
successfully obtained its updates.
The second difference is located in the last line of the
output: the word “localization” points out an attempt of
tracking the user. This could represent a form of “track-
ing” of a user, using well-known concept of “cookies”.
While multiple use tracking at an external site is not
completely in our system’s control, the effect can be mit-
igated by sending a different fake localization value that
is unique for each instance.
Mozilla Firefox As remarked before, we ran this test case
328328
in order to see how the platform works when network
trafﬁc comes into play. We tested several highly dy-
namic websites: sites as Google Maps use lots of dy-
namically loaded content, in order to provide an easier
interface to the user. This eventually results in a con-
tinuous exchange of information between the client and
the server, “stressing” the HTTP cache. Moreover we
wanted to ensure that, even when loading a page con-
taining a huge number of advertisement banners, the
user would still be able to access the partial content of
the page in which he/ she is interested, within an accept-
able time.
Browsing tests performed on our system demon-
strated an overall smooth and acceptable behavior of the
platform: most of the pages were correctly loaded, with
full content displayed, include highly interactive sites
such as Google Maps and YouTube. The only exception
were those sites containing banners or other types of ad-
vertisements, that contained random strings, on which
V Mprivate times out after search.
4.2 Performance evaluation
In order to see how our prototype impacts on the overall
performance of the system, we took measurements re-
garding the execution time of the applications mentioned
in the previous subsection. Once again we used the tool
Wireshark to measure at packet level the total amount
of time that the network communication requires, from
the beginning of the ﬁrst request to the time when the