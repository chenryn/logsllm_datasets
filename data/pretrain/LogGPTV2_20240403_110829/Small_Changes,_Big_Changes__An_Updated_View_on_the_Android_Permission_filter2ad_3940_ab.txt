I
3
2
E
R
P
_
G
A
L
F
P
O
P
P
A
_
G
A
L
F
I
I
D
E
G
E
L
V
R
P
_
G
A
L
F
PROTECTION
LEVEL
0
I
I
R
E
F
R
E
V
_
G
A
L
F
MASK_FLAGS
MASK_BASE
(a)
Y
E
N
O
M
_
S
T
S
O
C
_
G
A
L
F
0
I
N
E
D
D
H
_
G
A
L
F
D
E
L
L
A
T
S
N
I
_
G
A
L
F
30
32
...
(b)
Fig. 2. “Protection Level” (a) and “Additional Flags” (b) ﬁeld map.
4.1 Protection Level
Figure 2a shows a map of the lower 16 bits of the protectionLevel ﬁeld (the
higher 16 bits are currently not in use). The lower 4 bits are used to specify
the protection level of a permission. The protection level value is determined by
applying bitwise AND operation to the protectionLevel ﬁeld and the MASK BASE
constant. Since a permission can only have one protection level, its values have
sequential order, where the normal protection level is equal to 0, dangerous
is 1, signature – 2, and signature|system is equal to 3. Interestingly, although
signature|system level has a higher protection level value, signature permissions
are considered as more sensitive. If a permission protection level is not speciﬁed
in the manifest ﬁle, by default, signature protection level is used.
Protection level ﬂags can be used only with signature permissions. Flags with
other protection levels will generate an error at the time of manifest parsing.
Protection level ﬂags are masked with the MASK FLAGS constant.
The ﬁrst ﬂag FLAG PRIVILEGED enforces that only apps either signed with the
same certiﬁcate or installed into the special location can obtain the permission.
Until Android 4.4 all applications installed on the system image were granted
with these privileged permissions by default. This means that even unprivileged
system apps, e.g., Calculator, were able to obtain such permissions. To reduce
the attack surface, system apps were later divided into the ordinary and privi-
leged ones [9]. The ordinary system apps remain in the /system/app directory,
but are not granted with privileged permissions anymore. To obtain privileged
permissions an app must be installed into a separate /system/priv-app folder.
Besides setting this ﬂag directly, the developer can achieve the same permission
behavior by setting the protection level to signature|system (deprecated since
Android 6.0).
In Android 4.1 [12], the development permissions (marked with the ﬂag
FLAG DEVELOPMENT) were introduced. These permissions usually protect the
functionality required to perform development tasks, e.g., read system logs
(READ LOGS). An app can request these permissions, but they will not be auto-
matically granted. At runtime the user can grant and revoke these permissions
on demand by using special commands pm grant and pm revoke of the Android
shell [30].
An Updated View on the Android Permission System
353
FLAG APPOP was introduced in Android 5.0 [4], although explicitly it has
started to be used only with Android 6.0. This ﬂag was added to allow selective
access to certain critical platform operations protected by signature permissions
to third-party apps, after an explicit approval from the user. As we mentioned,
typically, the signature protection level ensures that the corresponding platform
permission is automatically granted at install time to the apps signed with the
same certiﬁcate as the system image. Yet, this ﬂag relaxes the requirement that
the protected functionality can be used only by the system components. However,
upon installation, access to the resources is disabled by default to third-party
apps. For every permission of this appop type there is a separate conﬁguration
screen, where the user may explicitly grant or revoke access to these opera-
tions for system and third-party apps. E.g., Fig. 1b shows the screen for the
PACKAGE USAGE STATS permission. The ﬂag name shows that the enforcement of
this type of permissions happens through the AppOps system.
FLAG PRE23, as the name suggests, indicates that the corresponding permis-
sion is automatically granted to apps targeting pre-6.0 Android (API levels less
than 23) versions [11]. For instance, the permission to draw a window over other
apps SYSTEM ALERT WINDOW before Android 6.0 had the dangerous level, and
thus was granted automatically upon installation. In Android 6.0 the protection
level of this permission was changed to signature. However, apps targeting pre-
vious API versions are not aware of this change. Thus, during their execution
an invocation of the functionality protected with this permission will generate
an error. FLAG PRE23 permits to overcome this issue by automatically granting
the permission with this ﬂag set to apps targeting previous versions of Android.
The ﬂags FLAG INSTALLER and FLAG VERIFIER introduced in Android 6.0 [5]
indicate that permissions are automatically granted to the packages set as the
required installer and veriﬁer (see more in [30]). However, to use these permis-
sions the installer package must be installed on the system image, while the
veriﬁer package must be additionally granted with the PACKAGE VERIFICATION
AGENT permission which has the signature|privileged protection level.
Finally, FLAG PREINSTALLED added in Android 6.0 [8] indicates that the per-
mission can be granted not only to the apps installed into the privileged folder,
but to any app installed in the system partition.
4.2 Permission Flags
Permission ﬂags were introduced in Android 4.2 [3]. Internally, permission ﬂags
are also represented as an integer 32-bit ﬁeld which map is shown in Fig. 2b.
These ﬂags are controlled through the android:permissionFlags attribute of
the permission tag. It should be noted that only the FLAG COSTS MONEY and
FLAG HIDDEN ﬂags may be set through this attribute, while FLAG INSTALLED is
not accessible through a permission declaration.
The ﬂag FLAG COSTS MONEY introduced in Android 4.1 [3] inﬂuences how
a permission with this ﬂag set is presented to a user. These permissions are
marked with the “coins” sign displayed on the screen shown during app installa-
tion (in versions before Android 6.0). Interestingly, there are no restrictions on
354
Y. Zhauniarovich and O. Gadyatskaya
Table 1. Versions of the android platform used in our study
API level
Branch
Codename
Release date (mm-dd-yyyy)
23
22
21
19
18
17
16
15
14
10
9
8
7
6
5
4
android-6.0.0 r1
Marshmallow
android-5.1.0 r1
android-5.0.1 r1
android-4.4 r1
android-4.3 r1
android-4.2 r1
android-4.1.1 r1
Lollipop
Lollipop
KitKat
Jelly Bean
Jelly Bean
Jelly Bean
android-4.0.3 r1 Ice Cream Sandwich
android-4.0.1 r1 Ice Cream Sandwich
android-2.3.3 r1
android-2.3 r1
android-2.2 r1
android-2.1 r1
android-2.0.1 r1
android-2.0 r1
android-1.6 r1
Gingerbread
Gingerbread
Froyo
Eclair
Eclair
Eclair
Donut
10-05-2015
03-09-2015
12-02-2014
10-31-2013
07-24-2013
11-13-2012
07-11-2012
12-16-2011
10-21-2011
02-09-2011
12-06-2010
05-20-2010
01-12-2010
12-03-2009
10-26-2009
09-15-2009
the usage of this ﬂag, thus, even custom permissions could use it. Similarly, the
ﬂag FLAG HIDDEN added in Android 6.0 [7] also inﬂuences presentation, making
a permission hidden from the user’s sight. This ﬂag is used for the platform per-
missions that have become deprecated and removed from the system. However,
a developer may use this ﬂag to conceal custom dangerous permissions.
The ﬂag FLAG INSTALLED was introduced in Android 6.0 [10]. It is set by
the operating system itself. This ﬂag shows that the permission has been actu-
ally installed into the system, and inﬂuences presentation of permissions. For
instance, if a permission has not been declared by an application but is requested
by another app, it will not be shown in the list of requested permissions.
5 Analysis of Permission Changes
To investigate empirically how the Android permission system evolved across
platform updates, we retrieved the source code of the Android platform for ver-
sions released from 2009 till 2015 that resulted in the API level change (the
latest release at the time of writing is Android Marshmallow). Table 1 overviews
the Android platform releases covered in our study.
We performed the analysis aiming at detection of odds in the permission sys-
tem. In our study we focus on the Android platform permissions, and we do not
cover custom permissions, which are deﬁned by third-party applications to pro-
tect access to their resources. We divide platform permissions into 4 categories:
An Updated View on the Android Permission System
355
(a)
(b)
Fig. 3. Number of permissions for every platform release: (a) for core permissions;
(b) for package permissions.
– sample – permissions that are declared by the sample apps shipped with the
platform source code (appeared from API 21).
– test – permissions that are declared in the manifest ﬁles of packages developed
for testing purposes;
– package – permissions that are declared in various packages that complement
the framework, and that are not of test or sample groups;
– core – permissions that are declared in the core Android manifest ﬁle located
in the frameworks/base/core/res folder;
The categories discussed above reﬂect the basic purposes why permissions are
used within AOSP [1]: some permissions (from the categories core and package)
are the “true” permissions used for access control, while others are auxiliary
utilized in example applications (sample) or for testing (test). We focus our
study on core and package permissions, because they are the ones that truly
inﬂuence the behavior of the operating system.
The study done by Wei et al. in 2012 revealed that the number of permissions
steadily increased with each Android release [49]. Our study, as of the beginning
of 2016, conﬁrms that ﬁnding and shows that the total amount of permis-
sions declared within the Android platform continues to grow, reaching
314 in API 23 compared to 165 in API 15 (the last version analyzed by Wei
et al. [49]). Figure 3a and b illustrate the growth of the number of permissions
for core and package categories correspondingly. Obviously, the main contribu-
tor to the continuous increase are core permissions. The amount of the package
permissions ﬂuctuates, although still showing the overall upward trend. These
plots also demonstrate the changes in the amounts of permissions of diﬀerent
protection levels. Table 2 characterizes the changes between consequent API lev-
els. The data conﬁrms that almost every Android API release (besides the API
6, 7, 10) introduced new permissions, as access to the new platform functionality
often needs to be guarded.
356
Y. Zhauniarovich and O. Gadyatskaya
Table 2. Permission changes in core and package categories
API level
Amount of permission changes
Added Removed Type changed Protection level changed
Inc Dec