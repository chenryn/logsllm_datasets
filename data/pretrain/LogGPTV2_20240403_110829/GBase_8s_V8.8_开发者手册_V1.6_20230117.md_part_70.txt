的服务器上的工作负载。
在NUMA平台上运行的内储存数据库系统面临一些问题，例如访问远程主内存时，时
延增加和带宽降低。为了应对这些NUMA相关问题，NUMA感知必须被看作是数据库系统
基本架构的主要设计原则。
为了便于快速操作和高效利用NUMA节点，MOT为每个表的行分配一个指定的内存池，
同时为索引的节点分配一个指定的内存池。每个内存池由多个2MB的块组成。指定API从
本地NUMA节点、来自所有节点的页面或通过轮询分配这些块，每个块在下一个节点上分
配。默认情况下，共享数据池以轮询方式分配，以保持访问均衡，同时避免在不同NUMA
节点之间拆分行。但是，线程专用内存是从一个本地节点分配的，必须验证线程始终运行在
同一个NUMA节点中。
总结
MOT有一个智能内存控制模块，它预先为各种类型的内存对象分配了内存池。这种智
能内存控制可以提高性能，减少锁并保证稳定性。事务的内存对象分配始终是NUMA-local，
南大通用数据技术股份有限公司
501
GBase 8s V8.8开发者手册
从而保证了CPU内存访问的最佳性能，降低时延和争用。被释放的对象返回到内存池中。
在事务期间最小化使用操作系统的malloc函数可以避免不必要的锁。
13.3.9 MOT 索引
MOT 索引基于最先进的Masstree的免锁索引，用于多核系统的快速和可扩展的键值
（KV）存储，通过B+树的Trie实现。在多核服务器和高并发工作负载上，性能优异。它使
用各种先进的技术，如乐观锁方法、缓存感知和内存预取。
在比较了各种最先进的解决方案之后，我们选择了Masstree作为索引，因为它显示了
点查询、迭代和修改的最佳总体性能。Masstree是Trie和B+树的组合，用以谨慎利用缓存、
预取、乐观导航和细粒度锁定。它针对高争用进行了优化，并对其前代产品增加了许多优化，
如OLFIT。然而，Masstree索引的缺点是它的内存消耗更高。虽然行数据占用相同的内存大
小，但每个索引（主索引或辅助索引）的每行内存平均高了16字节——基于磁盘的表使用
基于锁的B树，大小为29字节，而MOT的Masstree大小为45字节。
我们的实证研究表明，成熟的免锁Masstree实现与我们对Silo的强大改进相结合，恰
能为我们解决这一方面的问题。
另一个挑战是对具有多个索引的表使用乐观插入。
Masstree索引是用于数据和索引管理的MOT内存布局的核心。我们的团队增强并显著
改进了Masstree，同时提交了一些关键贡献给Masstree开源。这些改进包括：
 每个索引都有专用内存池：高效分配和快速索引下移
 Masstree全球GC：快速按需内存回收
 具有插入键访问的大众树迭代器实现
 ARM架构支持
MOT的主要创新是增强了原有的Masstree数据结构和算法，它不支持非唯一索引（作
为二级索引）。设计细节请参见非唯一索引。
MOT支持主索引、辅助索引和无键索引（受不支持的索引DDL和索引中提到的限制）。
非唯一索引
一个非唯一索引可以包含多个具有相同键的行。非唯一索引仅用于通过维护频繁使用的
数据值的排序来提高查询性能。例如，数据库可能使用非唯一索引对来自同一家庭的所有人
员进行分组。但是，Masstree数据结构实现不允许将多个对象映射到同一个键。我们用于创
南大通用数据技术股份有限公司
502
GBase 8s V8.8开发者手册
建非唯一索引的解决方案（如下图所示）是为映射行的键添加一个打破对称的后缀。这个添
加的后缀是指向行本身的指针，该行具有8个字节的常量大小，并且值对该行是唯一的。当
插入到非唯一索引时，哨兵的插入总是成功的，这使执行事务分配的行能够被使用。这种方
法还使MOT能够为非唯一索引提供一个快速、可靠、基于顺序的迭代器。
图 13-5 非唯一索引
上图描述了一个MOT的T表的结构，它有三个行和两个索引。矩形表示数据行，索引
指向指向行的哨兵（椭圆形）。哨兵用键插入唯一索引，用键+后缀插入非唯一索引。哨兵
可以方便维护操作，无需接触索引数据结构就可替换行。此外，在哨兵中嵌入了各种标志和
参考计数，以便于乐观插入。
查找非唯一辅助索引时，会使用所需的键（如姓氏）。全串联键只用于插入和删除操作。
插入和删除操作总是将行作为参数获取，从而可以创建整个键，并在执行删除或插入索引的
特定行时使用它。
13.3.10MOT 持久性概念
持久性是指长期的数据保护（也称为磁盘持久性）。持久性意味着存储的数据不会遭受
任何形式的退化或破坏，因此数据不会丢失或损坏。持久性可确保在有计划停机（例如维护）
或计划外崩溃（例如电源故障）后数据和MOT引擎恢复到一致状态。
内存存储是易失的，需要电源来维护所存储的信息。另一方面，磁盘存储是非易失性的，
这意味着它不需要电源来维护存储的信息，因此它不用担心停电。MOT使用这两种类型的
存储，它拥有内存中的所有数据，同时将事务性更改持久化到磁盘，并保持频繁的定期MOT
检查点，以确保在关机时恢复数据。
用户必须保证有足够的磁盘空间用于日志记录和检查点操作。检查点使用单独的驱动器，
通过减少磁盘I/O负载来提高性能。
有关如何在MOT引擎中实现持久性的概述，请参见MOT关键技术。
南大通用数据技术股份有限公司
503
GBase 8s V8.8开发者手册
MOT的WAL重做日志和检查点启用了持久性，如下所述。
13.3.10.1 MOT 日志记录：WAL 重做日志概念
概述
预写日志记录（WAL）是确保数据持久性的标准方法。WAL的主要概念是，数据文件
（表和索引所在的位置）的更改只有在记录这些更改之后才会写入，即只有在描述这些更改
的日志记录被刷新到永久存储之后才会写入。
MOT全面集成GBase8s的封装日志记录设施。除持久性外，这种方法的另一个好处是
能够将WAL用于复制目的。
支持三种日志记录方式：两种标准同步和一种异步方式。标准GBase8s磁盘引擎也支
持这三种日志记录方式。此外，在MOT中，组提交（Group-Commit）选项还提供了特殊的
NUMA感知优化。Group-Commit在维护ACID属性的同时提供最高性能。
为保证持久性，MOT全面集成GBase8s的WAL机制，通过GBase8s的XLOG接口持
久化WAL记录。这意味着，每次MOT记录的添加、更新和删除都记录在WAL中。这确保
了可以从这个非易失性日志中重新生成和恢复最新的数据状态。例如，如果向表中添加了3
个新行，删除了2个，更新了1个，那么日志中将记录6个条目。
 MOT日志记录和GBase8s磁盘表的其他记录写入同一个WAL中。
 MOT只记录事务提交阶段的操作。
 MOT只记录更新的增量记录，以便最小化写入磁盘的数据量。
 在恢复期间，从最后一个已知或特定检查点加载数据；然后使用WAL重做日志完成从
该点开始发生的数据更改。
 WAL重做日志将保留所有表行修改，直到执行一个检查点为止（如上所述）。然后可
以截断日志，以减少恢复时间和节省磁盘空间。
为了确保日志IO设备不会成为瓶颈，日志文件必须放在具有低时延的驱动器上。
日志类型
支持两个同步事务日志选项和一个异步事务日志选项（标准GBase8s磁盘引擎也支持
这些选项）。MOT还支持同步的组提交日志记录与NUMA感知优化，如下所述。
根据您的配置，实现以下类型的日志记录：
南大通用数据技术股份有限公司
504
GBase 8s V8.8开发者手册
 同步重做日志记录
同步重做日志记录选项是最简单、最严格的重做日志记录器。当客户端应用程序提交事
务时，事务重做条目记录在WAL重做日志中，如下所示：
(1) 当事务正在进行时，它存储在MOT内存中。
(2) 事务完成后，客户端应用程序发送提交命令，该事务被锁定，然后写入磁盘上的WAL
重做日志。这意味着，当事务日志条目写入日志时，客户端应用程序仍在等待响应。
(3) 一旦事务的整个缓冲区被写入日志，就更改内存中的数据，然后提交事务。事务提交后，
客户端应用程序收到事务完成通知。
技术说明
当事务结束时，同步重做日志处理程序（SynchronousRedoLogHandler）序列化事务缓
冲区，并写入XLOGiLogger实现。
图 13-6 同步日志记录
总结
同步重做日志记录选项是最安全、最严格的，因为它确保了客户端应用程序和每个事务
提交时的WAL重做日志条目的完全同步，从而确保了总的持久性和一致性，并且绝对不会
丢失数据。此日志记录选项可防止客户端应用程序在事务尚未持久化到磁盘时将事务标记为
成功的情况。
同步重做日志记录选项的缺点是，它是三个选项中最慢的日志机制。这是因为客户端应
南大通用数据技术股份有限公司
505
GBase 8s V8.8开发者手册
用程序必须等到所有数据都写入磁盘，并且磁盘频繁写入（这通常使数据库变慢）。
 组同步重做日志记录
组同步重做日志记录选项与同步重做日志记录选项非常相似，因为它还确保完全持久性，
绝对不会丢失数据，并保证客户端应用程序和WAL重做日志条目的完全同步。不同的是，
组同步重做日志记录选项将事务重做条目组同时写入磁盘上的WAL重做日志，而不是在提
交时写入每个事务。使用组同步重做日志记录可以减少磁盘I/O数量，从而提高性能，特别
是在运行繁重的工作负载时。
MOT引擎通过根据运行事务的核的NUMA槽位自动对事务进行分组，使用非统一内存
访问（NUMA）感知优化来执行同步的组提交记录。
有关NUMA感知内存访问的更多信息，请参见NUMA-aware分配和亲和性。
当一个事务提交时，一组条目记录在WAL重做日志中，如下所示：
(1) 当事务正在进行时，它存储在内存中。MOT引擎根据运行事务的核的NUMA槽位对桶
中的事务进行分组。这意味着在同一槽位上运行的所有事务都被分在一组，并且多个组
将根据事务运行的核心并行填充。
这样，将事务写入WAL更为有效，因为来自同一个槽位的所有缓冲区都一起写入磁盘。
每个线程在属于单个槽位的单核/CPU上运行，每个线程只写运行于其上的核的槽位。
(2) 在事务完成并且客户端应用程序发送Commit命令之后，事务重做日志条目将与属于同
一组的其他事务一起序列化。
(3) 当特定一组事务满足配置条件后，如重做日志（MOT）小节中描述的已提交的事务数
或超时时间，该组中的事务将被写入磁盘的WAL中。这意味着，当这些日志条目被写
入日志时，发出提交请求的客户端应用程序正在等待响应。
(4) 一旦NUMA-aware组中的所有事务缓冲区都写入日志，该组中的所有事务都将对内存
存储执行必要的更改，并且通知客户端这些事务已完成。
技术说明
4种颜色分别代表4个NUMA节点。因此，每个NUMA节点都有自己的内存日志，允
许多个连接的组提交。
南大通用数据技术股份有限公司
506
GBase 8s V8.8开发者手册
图 13-7组提交——具有NUMA感知
总结
组同步重做日志记录选项是一个极其安全和严格的日志记录选项，因为它保证了客户端
应用程序和WAL重做日志条目的完全同步，从而确保总的持久性和一致性，并且绝不会丢
失数据。此日志记录选项可防止客户端应用程序在事务尚未持久化到磁盘时将事务标记为成
功的情况。
一方面，该选项的磁盘写入次数比同步重做日志记录选项少，这可能意味着它更快。缺
点是事务被锁定的时间更长，这意味着它们被锁定，直到同一NUMA内存中的所有事务都
写入磁盘上的WAL重做日志为止。
使用此选项的好处取决于事务工作负载的类型。例如，此选项有利于事务多的系统（而
对于事务少的系统而言，则较少使用，因为磁盘写入量也很少）。
 异步重做日志记录
异步重做日志记录选项是最快的日志记录方法，但是，它不能确保数据不会丢失。也就
是说，某些仍位于缓冲区且尚未写入磁盘的数据在电源故障或数据库崩溃时可能会丢失。当
客户端应用程序提交事务时，事务重做条目将记录在内部缓冲区中，并按预先配置的时间间
隔写入磁盘。客户端应用程序不会等待数据写入磁盘，而是继续到下一个事务。因此异步重
做日志记录的速度最快。
当客户端应用程序提交事务时，事务重做条目记录在WAL重做日志中，如下所示：
南大通用数据技术股份有限公司
507
GBase 8s V8.8开发者手册
(1) 当事务正在进行时，它存储在MOT内存中。
(2) 在事务完成并且客户端应用程序发送Commit命令后，事务重做条目将被写入内部缓冲
区，但尚未写入磁盘。然后更改MOT数据内存，并通知客户端应用程序事务已提交。
(3) 后台运行的重做日志线程按预先配置的时间间隔收集所有缓存的重做日志条目，并将它
们写入磁盘。
技术说明
在事务提交时，事务缓冲区被移到集中缓冲区（指针分配，而不是数据副本），并为事
务分配一个新的事务缓冲区。一旦事务缓冲区移动到集中缓冲区，且事务线程不被阻塞，事
务就会被释放。实际写入日志使用PostgresWALWRITER线程。当WALWRITER计时器到
期时，它首先调用异步重做日志处理程序（通过注册的回调）来写缓冲区，然后继续其逻辑，
并将数据刷新到XLOG中。
图 13-8 异步日志记录
总结
异步重做日志记录选项是最快的日志记录选项，因为它不需要客户端应用程序等待数据
写入磁盘。此外，它将许多事务重做条目分组并把它们写入一起，从而减少降低MOT引擎
速度的磁盘I/O数量。
异步重做日志记录选项的缺点是它不能确保在崩溃或失败时数据不会丢失。已提交但尚
南大通用数据技术股份有限公司
508
GBase 8s V8.8开发者手册
未写入磁盘的数据在提交时是不持久的，因此在出现故障时无法恢复。异步重做日志记录选
项对于愿意牺牲数据恢复（一致性）而不是性能的应用程序来说最为相关。
 日志记录设计细节
下面将详细介绍内储存引擎模块中与持久化相关的各个组件的设计细节。
图 13-9 三种日志记录选项
重做日志组件由使用内储存引擎的后端线程和WAL编写器使用，以便持久化其数据。
检查点通过Checkpoint管理器执行，由Postgres的Checkpointer触发。
 日志记录设计概述
预写日志记录（WAL）是确保数据持久性的标准方法。WAL的核心概念是，数据文件
（表和索引所在的位置）的更改只有在记录了这些更改之后才会写入，这意味着在描述这些
更改的日志记录被刷新到永久存储之后。
在内储存引擎中，我们使用现有的GBase8s日志设施，并没有从头开始开发低级别的
日志API，以减少开发时间并使其可用于复制目的。
 单事务日志记录
在内储存引擎中，事务日志记录存储在事务缓冲区中，事务缓冲区是事务对象（TXN）
的一部分。在调用addToLog()时记录事务缓冲区–如果缓冲区超过阈值，则将其刷新并重新
使用。当事务提交并通过验证阶段（OCCSILO[对比：磁盘与MOT]验证）或由于某种原因
中止时，相应的消息也会保存在日志中，以便能够在恢复期间确定事务的状态。
南大通用数据技术股份有限公司
509
GBase 8s V8.8开发者手册
图 13-10 单事务日志记录
并行日志记录由MOT和磁盘引擎执行。但是，MOT引擎通过每个事务的日志缓冲区、
无锁准备和单个日志记录增强了这种设计。
 异常处理
持久化模块通过Postgres错误报告基础设施（ereport）处理异常。系统日志中会记录每
个错误情况的错误信息。此外，使用Postgres内置的错误报告基础设施将错误报告到封装。
该模块上报有如下异常：
表 13-7异常处理
异常条件 异常码 场景描述 最终结果
WAL 写入失 ERRCODE_FDW_ERROR 在任何情况 事务终止
败 下，WAL写入
失败
文件IO错误： ERRCODE_IO_ERROR 检查点：在任 严重：进程存
写入、打开等 何文件访问错 在
误时调用
内存不足 ERRCODE_INSUFFICIENT_RESOURCES 检查点：本地 严重：进程存
内存分配失败 在
南大通用数据技术股份有限公司
510
GBase 8s V8.8开发者手册
逻辑、DB 错 ERRCODEINTERNAL 检查点：算法 严重：进程存
误 失败或无法检 在
错误
索表数据或索
引
13.3.10.2 MOT 检查点概念
在GBase8s数据库中，检查点是事务序列中一个点的快照，在该点上，可以保证堆和
索引数据文件已经同步了检查点之前写入的所有信息。
在执行检查点时，所有脏数据页都会刷新到磁盘，并将一个特殊的检查点记录写入日志
文件。
数据直接存储在内存中。MOT没有像GBase8s那样存储数据，因此不存在脏页的概念。
为此，使用CALC算法，用于主内存数据库系统中的低开销异步检查点。
CALC检查点算法：内存和计算开销低
检查点算法具有以下优点：
降低内存使用量-每条记录在任何时候最多存储两个副本。在记录处于活动且稳定版本
相同或没有记录任何检查点时，仅存储记录的一个物理副本，可以最大限度地减少内存使用。
 低开销：CALC的开销比其他异步检查点算法小。
 使用虚拟一致性点：CALC不需要静默数据库以实现物理一致性点。
检查点激活
MOT 检查点被集成到 GBase 8s 的封装的检查点机制中。检查点流程可以通过执行
CHECKPOINT；命令手动触发，也可以根据封装的检查点触发设置（时间/大小）自动触发。
检查点配置在mot.conf文件中执行，请参见检查点（MOT）部分。
13.3.11MOT 恢复概念
MOT恢复模块提供了恢复MOT表数据所需的所有功能。恢复模块的主要目标是在计
划（例如维护）关闭或计划外（例如电源故障）崩溃后，将数据和MOT引擎恢复到一致的
状态。
GBase8s数据库恢复（有时也称为冷启动）包括MOT表，并且随着数据库其余部分的
恢复而自动执行。MOT恢复模块无缝、全面地集成到GBase8s恢复过程中。
南大通用数据技术股份有限公司
511
GBase 8s V8.8开发者手册
MOT恢复有两个主要阶段：检查点恢复和WAL恢复（重做日志）。
MOT检查点恢复在封装的恢复发生之前执行。仅在冷启动事件（PG进程的启动）中执