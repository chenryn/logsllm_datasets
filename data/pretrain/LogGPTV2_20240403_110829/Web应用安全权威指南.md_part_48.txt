  d16fb36f09   xyz
但是如果直接去生成这样一个查找表的话，其大小将会过于庞大。所以有人又设想如果能按照某些规则，做出一个密码
1 →散列值 1 →密码 2 →散列值 2 →密码 3 →散列值 3
→...这样的链表的话，那么我们只需要记住链表的表头和表尾就可以了。这就是彩虹表的最显著特征。
为了建立这样一个链表，就需要知道如何从一个密码的散列值得到其后面的密码，实现这个功能的函数被称为还原函数（Reduction
Function）。还原函数的功能就是从给定的散列值，生成一个符合密码规范（可使用字符种类及密码长度）的新密码字符串。在链表里的不同位置需要使用不同的还原函数，而不能全部使用同一个还原函数。在图
5-13 的例子里，由于一共进行了 3 次散列值还原操作，所以相应地也就需要 3
个还原函数。
![{%}](Image00198.jpg)
**图 5-13 彩虹表的链表结构**
为了能多保存一些密码组合，首先需要选择链表的第一个元素，然后通过计算得到整个链表。在把彩虹表数据保存到文件的时候，只需要记录这个链表的头和尾的元素即可。图
5-14 是彩虹表在文件中保存的大概样子。
![{%}](Image00199.jpg)
**图 5-14 彩虹表的保存方法示例**
下面我们以散列值 a48927
为例来看看如何利用彩虹表来计算出该散列值对应的原密码。最开始检索的时候由于不知道这个散列值在链表的哪个位置上，所以需要对每个位置进行验证。首先，使用还原函数和散列函数分别计算出其在链表各个位置时的链表末尾元素的值，得到的结果是
lookie、abcxyz、root00 这三个值，如图 5-15 所示。
![{%}](Image00200.jpg)
**图 5-15 使用彩虹表进行检索的过程**
接着，依次查找这些产生的密码是否在彩虹表链表的最尾部，就找到了以 root00
为最末元素的链表。然后，在彩虹表里找到相应的链表的头元素，即 system。
以 system 开始，依次使用散列函数和还原函数进行链表计算，就能发现 system
的散列值就是 a48927，即需要检索的密码原文就是 system。
彩虹表的数据文件里只保存了每个链表的开头和结尾的元素，其大小只由组成密码的字符种类和密码长度决定，跟具体的散列算法无关。而且彩虹表的算法和具体的散列函数（比如
MD5）本身无关，可以针对任何散列函数创建彩虹表，比如已经有公开的适用于
SHA-1 的彩虹表了。预计今后也会创建针对 SHA-256 的彩虹表。
> **参考文献**
>
> ［1］Niels Ferguson, Bruce Schneier, Tadayoshi Kohno. (2010).
> *Cryptography Engineering* . Wiley Publishing, Inc.
## **5.2 账号管理** {#text00000.html#nav_point_69 line-num="973 974"}
本节将针对账号（用户）管理实现上需要注意的地方加以说明。在账号管理当中，用户
ID（登录
ID）、密码、邮箱地址等的管理和安全性关联特别紧密。以下功能和这几方面紧密有关，我们将主要对在实现这些功能时需要注意的安全事项进行说明。
-   用户注册
-   修改密码
-   修改邮箱地址
-   密码找回
-   账号冻结
-   账号删除
### **5.2.1 用户注册** {#text00000.html#nav_point_70 line-num="984 985"}
用户注册的时候，一般都会需要提供前面提到过的用户
ID、密码、邮箱地址等信息，需要注意的安全事项如下。
-   邮箱地址确认
-   防止用户 ID 重复
-   应对自动用户注册（即程序自动进行的机器人注册，此项内容为非必须事项）
-   关于密码的注意事项
上面第四点关于密码的相关问题，我们在前面的 5.1
节里面已经详细介绍过了，这里将不再讨论。
另外，除了上面提到的几点之外，用户注册时还容易发生下面两种安全漏洞。
-   SQL 注入漏洞（4.4.1 节）
-   邮件头注入漏洞（4.9.2 节）
关于上面两种脆弱性请参考第四章的相关章节。下面我们就开始对用户注册功能的注意事项进行说明。
#### **邮箱地址确认** {line-num="1002 1003"}
在需要认证的网站里邮箱地址有着举足轻重的地位，除了能够用它来找回密码，还能在修改密码或者账号被锁定时用来发送系统通知。特别是有密码找回功能的网站，如果密码通知邮件错误的发给了其他人邮箱的话，那就变成安全事故了。
所以在用户注册、修改电子邮箱地址的时候，需要确认用户提供的邮箱是否能收到系统发送的邮件，即进行邮箱的收信确认。具体的话有下面两种方法。
-   将带有令牌的 URL 通过邮件发送到用户邮箱，用户在收到邮件点击 URL
    后进行后续操作（方法 A）
-   用户输入邮箱地址后，转向令牌确认页面。令牌则通过邮件发送到用户输入的电子邮箱地址（方法
    B）
上面两种方法都会给用户指定的邮箱发送令牌，然后通过确认用户输入的令牌来进行邮箱地址合法性的验证。方法
A 和方法 B 不不同的地方是，方法 A 在邮件正文里提供了一个 URL，用户点击
URL 打开网页即可。方法 B
的话则需要用户手工在页面上输入在邮件里收到的令牌。
方法 A 的处理流程如图 5-16 所示。方法 A
的话在用户在输入邮箱地址后，验证过程会临时停止，等用户收到邮件并点击里面的
URL 后，又会继续后面的验证过程。
![{%}](Image00201.jpg)
**图 5-16 邮件收信确认（方法 A）**
和方法 A 不同的是，方法 B 只在邮件里发送令牌，而不带任何 URL
信息，且页面切换过程不会中断，用户需要在下一页面输入在邮件里收到的令牌。令牌在用户打开邮件之前属于秘密信息，不能放在
hidden 元素里在页面间传递，所以需要将令牌的值保存在会话中。
![{%}](Image00202.jpg)
**图 5-17 邮件收到确认（方法 B）**
下表总结了方法 A 和方法 B 各自的优缺点。
**表 5-4 用户邮箱地址确认方法的优点、缺点**
+-----------------------+-----------------------+-----------------------+
|                       | 方法 A                | 方法 B                |
+=======================+=======================+=======================+
| 优点                  |                       |                       |
|                       |                       |                       |
|                       | -   用户操作体验较好  | -   不                |
|                       | -   需要长时          | 必让用户再去访问其他  |
|                       | 间确认邮件时也能应对  |     URL               |
|                       |                       | -   容易实现          |
+-----------------------+-----------------------+-----------------------+
| 缺点                  |                       |                       |
|                       |                       |                       |
|                       | -   实现起来较麻烦    | -   需要用户输入验证  |
|                       | -   强                | 码，对用户来有点麻烦  |
|                       | 迫用户去访问邮件里的  | -   如果邮件发送      |
|                       |     URL 有点不太方便  | 后用户不能立即收到会  |
|                       | -   有的              | 导致验证失败无法注册  |
|                       | 邮件客户端的可能会把  | -   如果是用手机操    |
|                       |     URL               | 作的话可能会比较麻烦  |
|                       |     做截断处理        |                       |
|                       | ，导致用户点击后没反  |                       |
|                       | 应或者打开错误的页面  |                       |
+-----------------------+-----------------------+-----------------------+
实际中可能采用更多的是方法 A，但是在邮件里发送 URL
的话，可能会对预防钓鱼攻击措施带来不利影响，所以本书里反而推荐使用方法
B。
#### **防止用户 ID 重复** {line-num="1036 1037"}
用户
ID，即用户登录名，必须保持唯一性。笔者进行网站的安全咨询工作时，就遇到过能使用重复用户
ID 注册的情况，这里介绍一下笔者见过的用户 ID 重复的例子。
-   **例子 1：ID 相同密码不同可以注册的网站**
    有一个会员系统网站的用户 A 忘了自己的密码，作为尝试将用户 ID
    作为密码输入后竟然登录成功了，而且看到的个人信息也都是别人的。
    调查后发现，即使用户 ID
    相同，如果密码不同的话也能在这个网站上注册成功。而 A
    用户只是偶然地登录进和用户 ID 相同的其他账号而已。
-   **例子 2：用户 ID 没有添加唯一性约束的网站**
    笔者曾负责检查一个网站的安全漏洞，检查发现该网站在经过特殊的操作之后，可以使用重复的用户
    ID 注册多个账号。笔者建议网站的管理员在数据库的表定义上给用户 ID
    加上唯一（UNIQUE）约束，但是他们的系统在删除用户的时候做的是逻辑删除（即在数据库里给被删除的记录设置删除标记代表用户已被删除），所以不能在表定义上做唯一约束。
    这样的网站在现实中应该为数不少，如果应用程序存在 Bug 的话（比如竞争
    / 互斥处理不当等），就可能导致产生重复用户 ID 的问题。
    和例子 1 一样，如果相同的用户 ID
    能注册不同的用户的话，就存在用户登录到其他用户账号里的风险。最好是在数据库的定义上把表示用户
    ID
    的那一列加上唯一约束。如果现实不允许设置这种约束的话，那么至少在应用程序里必须要加入防止用户
    ID 重复的逻辑，在处理互斥等操作的时候也要格外细心。
#### **应对自动用户注册** {line-num="1053 1054"}
如果 Web
站点是能自由注册的话，那么攻击者有时候会通过程序自动注册大量机器人账号。攻击者为了各种目的到处注册大量这种机器人账号，比如在提供邮件服务的网站里注册大量用户，然后用这些用户发送垃圾邮件。
根据网站性质不同，这种大量自动注册用户带来的威胁也不一样，如果已经预估到这种风险或者已经因这种攻击而带来损失的话，可以采用
CAPTCHA（验证码）来做预防。
-   **利用 CAPTCHA 防止自动注册**
    CAPTCHA（验证码）是通过故意在页面显示经过变形处理的文字等，让用户确认后输入，来验证正在操作的是人而不是机器程序在执行而发明的一种方法。[18]{.注释编号}
    网上有很多公开的在 PHP 等中使用的 CAPTCHA
    库，可以根据自己的需求去选择合适的库使用。图 5-18 就是一个面向 PHP
    的叫作 cool-php-captcha[19]{.注释编号} 的画面截图，这个库基于 GPLv3
    许可证方式公开。在使用这样的库的时候，除了要看它们的功能和方便程度之外，许可证也是不可忽略的选择条件之一。
    ![{%}](Image00203.jpg)
    **图 5-18 cool-php-captcha 提供的例子画面**
    有时候使用 CAPTCHA
    会给用户的使用体验带来负面影响，最近也出现了一些使用声音代替图片的网站。下面的是
    Google 用户注册时的
    CAPTCHA，点击输入框右边的小喇叭图标的话，就会播放混着杂音的录音，在录音里播放作为验证码的字符。用户可以在收听验证码后输入。
    ![{%}](Image00204.jpg)
    **图 5-19 使用了声音的 CAPTCHA**
    如上文所述，使用 CAPTCHA
    可以在一定程度上达到阻止程序进行自动用户注册的恶意行为。
    即使在用户注册界面不使用 CAPTCHA
    功能，也不能说系统就存在安全上的隐患。但是如果考虑到系统被自动注册大量账号后可能会带来何种损失的话，那么请一定要考虑下使用
    CAPTCHA 功能。
[18]{.注释编号下} CAPTCHA 是卡内基梅隆大学的注册商标，但是他们在 2008 年
4 月 21 日放弃了该商标的所有权。请参考
[19]{.注释编号下} 
### **5.2.2 修改密码** {#text00000.html#nav_point_71 line-num="1079 1080"}
这一节我们介绍密码修改功能在安全上需要注意的事项，具体如下。
-   需要确认当前密码
-   修改密码后向用户发送邮件通知
另外，在修改密码时可能存在的以下安全漏洞。
-   SQL 注入漏洞
-   CSRF 漏洞
下面分别对这几项进行详细说明。
#### **确认当前密码** {line-num="1093 1094"}
当用户想要修改密码的时候，需要向用户确认当前密码（再认证）。这样做的话能防止会话劫持等情况下攻击者直接修改用户密码。而且，通过再认证，还能防止后面将要提到的
CSRF 漏洞。
图 5-20 是典型的修改密码的例子。
![](Image00205.jpg){.sgc-11 width="90%"}
**图 5-20 修改密码页面的示例**
#### **修改密码后向用户发送邮件通知** {line-num="1103 1104"}
当发生像修改密码这样比较重要的事件时，最好是将具体信息以邮件的方式通知用户。这样即使是攻击者恶意修改了密码，用户也能尽早发现并且采取措施防止受到进一步的损失。
#### **密码修改功能容易发生的漏洞** {line-num="1107 1108"}
密码修改功能中容易发生的漏洞有以下两点。
-   SQL 注入漏洞
-   CSRF 漏洞
如果修改密码的页面存在 SQL 注入漏洞的话，除了 4.4.1 节里讲的常见的 SQL
注入危害以外，还存在以下危害。
-   绕过再认证而直接就能修改密码
-   修改其他用户的密码
-   一次修改所有用户的密码
此外，如果修改密码页面存在 CSRF 漏洞的话，就会像第 4.5
节里说的那样，存在攻击者在修改掉密码后，使用新密码登录的风险。
但是如果修改密码时使用上面提到的再认证功能的话，就不存在 CSRF
攻击的风险了。