程序的输出如下所示：
$ menory5b
Segmentation fauit (core dumpedl
操作注释：
这一次我们尝试直接读取零地址。这一次GNU的libc函数库没有夹在我们和操作系统内核中
间，程序被终止了。读者会发现某些版本的UNIX操作系统确实允许从零地址处读取数据，但
Linux不允许。
7.1.5内存的释放
截止到目前，我们所做的事情只是简单地分配内存，并且希望到程序结束的时候我们用过
的内存还没有流失。幸运的是UNIX的内存管理系统有能力在一个程序结束运行的时候把分配给
它的内存收归系统。可大多数程序需要的并不是简单地申请一些内存，使用一小段时间，然后
再退出。更常见的做法是在必要的时候动态地使用内存。
动态使用内存的程序必须随时注意使用free调用把当时用不着的内存块释放给malloc内存管
理程序。这样做可以把彼此隔离的内存块重新合并到一起，并由malloc函数库去照顾内存，应用
程序不必掺和到内存管理方面的事情里。如果由一个运行中的程序（即进程）负责自己的内存
管理，在它使用并随后释放内存时，这块自由内存实际上仍将处于被分配给该程序的状态。如
果这块内存当时没有被使用，UNIX的内存管理程序就可能会把它从物理内存通过页面交换放到
交换空间去。内存被放到交换空间以后，它对资源的使用情况就没有什么太大的影响了。
#1nclude 
void free(void*ptr_to_mazory ):
调用free时使用的指针必须指向用malloc、calloc或者realloc调用分配的某段内存。calloc和
realloc马上就会介绍到。
动手试试：释放内存
加入jaVa编程群：524621833
---
## Page 221
第7章数据管理
203
我们给这个程序起名为memory6.c。下面是它的程序清单：
#include 
define ONE_K (1024)
int main()
int exit_code · EXIT_FAILURE:
some_memory s(char *)malloc(ONE_);
if (sone_meaoryI= NULL)(
exit_code = EXIT_SUCCESS
exit(exit_code):
操作注释：
这个程序简单地显示了怎样调用带有指向刚分配到的内存的指针参数的free调用：
注意：一旦调用free释放了一块内存，它就不再属于这个进程了。它将由malloc函
数库负责管理。在对一块内存做过free调用之后，就绝不要再对它进行读写了。
7.1.6其他内存分配函数
另外还有两个可以用来分配内存的函数，但它们不象malloc和free使用的那么频繁。这就是
calloc和realloc。它们的定义如下所示：
#include 
void *calloc（nixe_t nunber_of_elements,size_t element_sise))
void *zeslloc(void *existing_memory. sixo_t new_size))
虽然calloc分配的内存也能够通过free来释放，但它有着不同的参数。它的作用是为--个结
构数组分配内存，需要把数组中的元素个数和每个元素的长度尺寸作为自已的参数，而分配到
的内存都填满了零。如果calloc执行成功，就返回一个指向数组中第一个元素的指针。后续
calloc调用也不保证能够返回一个连续不断的内存空间，这方而它与malloc一样。因此，如果我
们想扩大一个由calloc创建的数组，简单地再次调用calloc并希望返回的内存正好接在第一次调
用返回的内存后面是不现实的。
realloc函数的作用是改变以前分配的内存块的长度。它要使用一个指针做参数，指针指
向通过以前的malloc、calloc或realloc调用分配到的一些内存，然后根据new_size参数做出上
下调整。为了完成自己的工作，realloc函数可能需要对数据进行移动，所以用realloc调用对
内存做过重新分配之后，就一定要使用新的指针，绝不要再用realoc调用之前设置的指针去访
问内存。
另外一个应该引起大家注意的问题是：realloc在不能对内存块长度做出调整时会返回一个空
指针。这就意味着在某些应用程序里，下面这样的代码是应该避免：
加入jaVa编程群：524621833
---
## Page 222
204Linux程序设计
my_ptr = rea11oc (myptr. BLcCK_S1z * 10) :
如果realloc函数的执行失败了.它会返回一个空指针；也就是说，my_ptr将指向null，而原
先通过malloc分配的内存将无法再通过my_ptr去访问，因此、从用户的利益考虑，在释放老内存
以前最好是先用malloc申请一块新内存，再用memcpy函数把老内存块里的数据拷贝到新内存块
里去。这样，即使出现错误，应用程序还是能够访问到保存在原来那块内存里的数据，我们可
以用这个办法让程序退出得干净利落。
7.2文件封锁
文件封锁在多用户多任务操作系统里扮演着--个非常重要的角色。程序经常需要共享数据，
而这经常是通过文件实现的：因此，给这些程序提供-个确立文件控制权的手段就十分重要了：
只有这样，对文件的修改才是安全的：当第一个程序对文件进行写人时，文件会临时进人一个
“不可侵犯”的状态，第二个准备读这个文件的程序会自动停下来等待前一个程序操作的完成。
UNIX为我们准备了儿个用来实现文件封锁功能的1具：最简单的办法是以原子操作的形式
创建一个锁文件，这个技巧的高明之处在于创建锁文件的时候系统将不允许任何其他的事件发
生。这就可以保证程序有办法创建出一个确实是独一无二的文件来，而这个文件是绝不可能被
其他程序在同一时刻创建出米的。
第.二个办法更高级一-些，它允许程序对文件的某个部分进行封锁，让自已独享文件这部分
内容的访问权。在符合X/Open技术规范的UNIX版本里，有两种不同的办法可以达到这第：种封
锁的目的。我们只对其中的一种做细致的分析，因为两种办法很类似一一第二种办法只不过有稍
微不问的程序设计接口而已。
7.2.1创建锁文件
许多应用程序只要能够针对某项资源创建一个锁文件就心满意足了。此后，其他程序可以
检查这个文件的状态，看它们自已是否被允许访问那项资源。
锁文件-般都被集中放置在一个固定的场所，并且从它们的文件名上就可以看出它们与变
控资源之间的关系。比方说，在使用调制解调器的时候，Linux就会在/usr/spool/ucp子目录里
创建出--个锁文件来。在大多数UNIX系统上，这个子目录被用来表明系统上有串行口存在。
请看：
$ 1s /usr/spool/uucp
LCK..ttyS
记住、锁文件的作用就象是些信号灯，它们的使用需要程序来配合。用专业术语来说，锁
文件只是建议性的，与此对立的封锁功能是强制性的。
要想创建一个用做封锁信号灯的文件，我们需要使用在fcntl.h文件（我们在第3章里介绍过
它）里定义的带O_CTREAT和O_EXCL标志的open系统调用。它使我们能够完成两项工作：确
定文件当时并不存在和只用一个原子操作就把它创建出来。
加入jaVa编程群：524621833
---
## Page 223
第7章数据管理
205
动手试试：创建一个锁文件
我们来看看lock1.c程序里是怎样做的。下面是它的程序清单：
#1nclude 
#include 
inelude 
*inelude 
nt min(]
int file_dese;
int save_errno;
fi1e_desc= open*
include 
#include 
#include 
#include 
const char *lock_file = */tnp/LcK.test2*;
int main()
int tries = 10:
int file_desc;
while (tries--)[
file_descopen(1ock_fi1e.O_RDWR |0_CREAT |O_EXCL,0444):
if ifile_desc =s-1)
printf(*§d - Lock already present\n*.getpid()):
sleep(3}:
、
else {
2)下面是关键节的开始：
printf(*sd - I have exclusive access\n*, getpid()1;
{void)close(file_desc);
sleep(1):
{void)unlink(1ock_file) ;
3)关键节到这里结束：
sleep 12};
exit IEXIT_SUCCESS):
在运行这个程序之前，我们先要用下面的命令确保锁文件不存在：
Srn -t /tap/LcK.test2
然后用下面这条命令同时运行这个程序的两份拷贝：
$1ock2&1ock2
下面是我们看到的输出结果：
1284 - I bave exclusive access
Lock already present
I have exclusive access
1284
1 have exclusive access
Lock aiready present
1284
Lock already present
1283
Ihave exclusive access
1284
Lock already present
1283
1284
Lock alreedy present
I have exclusive access
1283
Lock already present
I have exclusive access
12R4
1284
Lock already present
I have excusive access
128 3
fez
1have exciusive access
1284
1ock already present
1284
1 have exclusive access
加入jaVa编程群：524621833
---
## Page 225
第7章数据管理207
1283 -Lock a1ready present
1284 - Lock already present
283
从上面的结果可以看出同一程序的这两个实例是如何进行协调的。读者在做这个实验时看
到的进程标识代码可能会与上面输出中的不一样，但程序的行为应该的相同的。
操作注释：
出于演示的目的，我们让程序做了十次循环，使用的是while语句。程序通过创建一个独一
无二的锁文件/ump/LCK.test2开始访问关键性资源。如果因为文件已经存在面使创建文件的操作
失败了，程序会稍等片刻后再行尝试。如果它创建文件成功，就表示它已经获得了资源的访问
权，能够进驻关键节完成预定的独占性操作。
因为这只是一个演示，所以我们只需等待小会儿。当程序完成了对资源的操作后，它将
删除锁文件，解除对资源的封锁。在重新施行封锁之前，它可以先进行一些其他的处理工作
这个间题给每个程序一个“yes”或“no”的答案：我们将在第12章和第13章对信号量做进一步
学习。
这是一种协调性安排，我们必须为此编写出正确的积序来，认识到这一点是很重要的。即
使程序创建锁文件的操作失败了，也不允许它简单地通过先除再创建锁文件的办法来解决问
题。否则，它倒是可以创建锁文件了，可也要创建锁文件的其他程序却不知道自己已经不再拥
有对资源的独占权了，结果将是“一出悲剧在上演”。
7.2.2文件中的封锁区
用创建锁文件的办法来控制串行口这类资源的独占权是很不错的，但对一个大型的共享文
件来说，再这样做就不太合适了。这种大文件确实存在，一个程序把数据源源不断地写到这个
文件里，同一时间还有许多其他的程序在对它修修补补。一个程序负责记录长期以来连续收集
到的数据，其他一些程序负责对这些数据进行处理，这种情况在UNIX系统里是比较常见的。负
责处理数据的程序不可能等到负责记录的程序结束之后再开始运行-—因为负责记录的程序根本
就不会停下来，它们只能同时对同一个文件进行访问，这就需要为它们准备一些协调措施。
我们可以用文件中的封锁区来解决这个问题：文件的某个部分被封锁了，可其他程序可以
去访问这个文件的其他部分。UNIX（至少）有两个办法可以“搞据”这件事：一是使用fcntl系
统调用，二是使用lockf调用。我们的讨论将主要集中在fenti接口上，因为它相对来说更常见一
些。lockf与它大同小异。
我们在第3章里已经见过fcnt调用了，下面是它的定义：
#include 
int fcntlint fildes,1at command,...)1
fcntl对一个打开的文件描述符进行操作，并能根据command参数的指示完成不同的任务。它