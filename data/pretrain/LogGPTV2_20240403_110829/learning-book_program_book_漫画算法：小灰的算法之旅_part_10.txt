40.
array[parentIndex]=array[childIndex];
41.
parentIndex = childIndex;
42.
43.
44.
array[parentIndex]= temp;
45.}
46.
47. /**
48.
*构建堆
---
## Page 171
49.
*@paramarray
待调整的堆
50.
*/
51. public static void buildHeap(int[] array) {
52.
//从最后一个非叶子节点开始，依次做"下沉”调整
53.
（（）=）
54.
downAdjust(array, i,array.length);
55.
56.}
57.
58. public static void main(String[] args） {
59.
int[] array = new int[] {1,3,2,6,5,7,8, 9,10, 0};
60.
upAdjust(array) ;
61.
System.out.println(Arrays.toString(array));
62.
63.
array =new int[] {7,1,3,10,5,2,8,9,6};
64.
buildHeap(array);
65.
System.out.println(Arrays.toString(array));
66.}
代码中有一个优化的点，就是在父节点和孩子节点做连续交换时，并不
一定要真的交换，只需要先把交换一方的值存入temp变量，做单向覆
盖，循环结束后，再把temp的值存入交换后的最终位置即可。
---
## Page 172
咱们讲了这么多关于二叉堆的知
识，二叉堆究竞有什么用处呢？
二叉堆是实现堆排序及优先队列的
基础。关于这两者，我们会在后续的章节中详细介绍。
3.4什么是优先队列
3.4.1
优先队列的特点
---
## Page 173
大黄，上一次你说过，
叉堆是实现“优先队列”
的基础，这一次你给我讲
讲优先队列呗？
好啊，在介绍优先队列之
前，我们先来回顾一下普
通队列的特性，
队列的特点是什么？
在之前的章节中已经讲过，队列的特点是先进先出（FIFO）
入队列，将新元素置于队尾：
出队列，队头元素最先被移出：
---
## Page 174
那么，优先队列又是什么样子呢？
优先队列不再遵循先入先出的原则，而是分为两种情况。
·最大优先队列，无论入队顺序如何，都是当前最大的元素优先出
队
·最小优先队列，无论入队顺序如何，都是当前最小的元素优先出
队
例如有一个最大优先队列，其中的最大元素是8，那么虽然8并不是队头
元素，但出队时仍然让元素8首先出队。
2
8
2
3
5
6
要实现以上需求，利用线性数据结构并非不能实现，但是时间复杂度较
高。
哎呀，那该怎么办呢？
---
## Page 175
别担心，这时候我们的二叉堆就派上
用场了。
3.4.2
优先队列的实现
先来回顾一下二叉堆的特性。
1.最大堆的堆顶是整个堆中的最大元素。
2.最小堆的堆顶是整个堆中的最小元素。
因此，可以用最大堆来实现最大优先队列，这样的话，每一次入队操作
就是堆的插入操作，每一次出队操作就是删除堆顶节点。
入队操作具体步骤如下。
1.插入新节点5。
10
8
6
---
## Page 176
2.新节点5"上浮"到合适位置。
10
8
5
出队操作具体步骤如下。
1.让原堆顶节点10出队。
8
9
2.把最后一个节点1替换到堆顶位置。
---
## Page 177
8
3.节点1"下沉”，节点9成为新堆顶，
6
小灰，你说说这个优先队列的入队和
出队操作，时间复杂度分别是多少？
---
## Page 178
二叉堆节点“上浮"和"下沉"的时
间复杂度都是O(logn），所以优先队列入队和出队的时间复杂度也
是o(logn)!
说的没错，下面让我们来看一看代码
实现。
1. private int[] array;
2.private int size;
3.public PriorityQueue(){
4.
//队列初始长度为32
5.
array = new int[32];
6.}
7./**
8.
*入队
9.
*@paramkey
入队元素
10.
*/
11. public void enQueue(int key) {
---
## Page 179
12.
//队列长度超出范围，扩容
13.
if(size >= array.length){
14.
resize();
15.
16.
array[size++] = key;
17.
upAdjust();
18.}
19.
20.
/ **
21.
*
出队
22.
*/
23.
public int deQueue(） throws Exception {
24.
if(size θ && temp > array[parentIndex])
43.
44.
//无须真正交换，单向赋值即可
45.
array[childIndex] = array[parentIndex];
46.
childIndex = parentIndex;
47.
parentIndex =parentIndex/2;
48.
49.
array[childIndex]= temp;
50.}
51.
/**
52.
"下沉"调整
53.
*/
54.
private void downAdjust(）{
55.
//temp保存父节点的值，用于最后的赋值
56.
int parentIndex = 0;
57.
int temp = array[parentIndex];
58.
int childIndex = 1;
59.
while (childIndex = array[childIndex])
66.
break;
67.
//无须真正交换，单向赋值即可
68.
array[parentIndex] = array[childIndex];
69.
parentIndex = childIndex;
70.
childIndex = 2* childIndex + 1;
71.
72.
array[parentIndex]= temp;
73.}
74.
75.
/ **
76.
队列扩容
77.
*/
78.
private void resize(){
79.
//队列容量翻倍
80.
int newSize = this.size * 2;
81.
this.array = Arrays.copyof(this.array, newSize);
82.}
---
## Page 182
83.
84. public static void main(String[] args) throws Exception {
85.
PriorityQueue priorityQueue = new PriorityQueue();
86.
priorityQueue.enQueue(3);
87.
priorityQueue.enQueue(5);
88.
priorityQueue.enQueue(10);
89.
priorityQueue.enQueue(2);
90.
priorityQueue.enQueue(7);
91.
System.out.println("
出队元
素："
+priorityQueue.deQueue());
92.
System.out.println("
出队元
素：“+priorityQueue.deQueue（）);
93.}
上述代码采用数组来存储二叉堆的元素，因此当元素数量超过数组长度
时，需要进行扩容来扩大数组长度。
好了，关于优先队列我们就介绍到这
里，下一章再见！
小结
3.5
·什么是树
---
## Page 183
树是n个节点的有限集，有且仅有一个特定的称为根的节点。当n>1时，
其余节点可分为m个互不相交的有限集，每一个集合本身又是一个树，
并称为根的子树。
·什么是二叉树
包含完全二叉树和满二叉树两种特殊形式。
·二义树的遍历方式有儿种
根据遍历节点之间的关系，可以分为前序遍历、中序遍历、后序遍历、
层序遍历这4种方式：从更宏观的角度划分，可以划分为深度优先遍历
和广度优先遍历两大类。
·什么是二叉堆
二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。
在最大堆中，任何一个交节点的值，都大于或等于它左、右孩子节点的
值。
在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的
值。
·什么是优先队列
优先队列分为最大优先队列和最小优先队列。
在最大优先队列中，无论入队顺序如何，当前最大的元素都会优先出
队，这是基于最大堆实现的。
在最小优先队列中，无论入队顺序如何，当前最小的元素都会优先出
队，这是基于最小堆实现的。
第4章排序算法
---
## Page 184
4.1
引言
在生活中，我们离不开排序。例如上体育课时，同学们会按照身高顺序
进行排队：又如每一场考试后，老师会按照考试成绩排名次。
在编程的世界中，应用到排序的场景也比比皆是。例如当开发一个学生
管理系统时，需要按照学号从小到大进行排序：当开发一个电商平台
时，需要把同类商品按价格从低到高进行排序：当开发一款游戏时，需
要按照游戏得分从多到少进行排序，排名第一的玩家就是本场比赛的
MVP，等等。
综合
销量
信用
价格从低到高
￥4500.00
运费：0.00
广东深圳
￥4580.00
运费：0.00
￥4700.00
运费：0.00
浙江杭州
￥4750.00
运表：0.00
广东圳
由此可见，排序无处不在。
排序看似简单，它的背后却隐藏着多种多样的算法和思想。那么常用的
排序算法都有哪些呢？
根据时间复杂度的不同，主流的排序算法可以分为3大类。
---
## Page 185
1.时间复杂度为0(n2)的排序算法
·冒泡排序
·选择排序
·插入排序
·希尔排序（希尔排序比较特殊，它的性能略优于O(n”），但又比不
上O(nlogn)，姑且把它归入本类）
2.时间复杂度为O(nlogn)的排序算法
·快速排序
·归并排序
·堆排序
3.时间复杂度为线性的排序算法
·计数排序
·桶排序
·基数排序
当然，以上列举的只是最主流的排序算法，在算法界还存在着更多五花
八门的排序，它们有些基于传统排序变形而来：有些则是脑洞大开，如
鸡尾酒排序、猴子排序、睡眠排序等。
此外，排序算法还可以根据其稳定性，划分为稳定排序和不稳定排序
即如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序
算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则
这样的排序算法是不稳定排序。例如下面的例子。
---
## Page 186
原始数列：
8
G
3
不稳定排序
结果：
5
6
6
8
稳定排序
结果：
5