Laboratory for Dependable Distributed Systems • RWTH Aachen University
NoSEBrEaK - 
Defeating Honeynets
Maximillian Dornseif,  Thorsten Holz, Christian N. Klein
at
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Who and Why
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Honeynet
Honeywall
Honeypots
Honeynets
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Sebek
[...] monitoring capability to all activity on the honeypot 
including, but not limited to, keystrokes. If a ﬁle is copied to 
the honeypot, Sebek will see and record the ﬁle, producing 
an identical copy. If the intruder ﬁres up an IRC or mail 
client, Sebek will see those messages. [...] Sebek also provides 
the ability to monitor the internal workings of the honeypot 
in a glass-box manner, as compared to the previous black-box 
techniques. [...] intruders can detect and disable sebek. 
Fortunately, by the time Sebek has been disabled, the code 
associated with the technique and a record of the disabling 
action has been sent to the collection server.
Know Your Enemy: Sebek
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Workings of Sebek 
• Hijacks sys_read().
• Sends data passing through sys_read() 
over the network.
• Overwrites parts of the Network stack 
(packet_recvmsg) to hide Sebek data 
passing on the network.
• Packages to be hidden are identiﬁed by 
protocol (ETH_P_IP, IPPROTO_UDP), 
port  and magic.
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Hiding of Sebek
• Sebek loads as a kernel module with a 
random numeric name.
• Afterwards a second module is loaded 
which simply removes Sebek from the list 
of modules and unloads itself.
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Detecting Sebek
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Detecting Sebek
Several ways to detect a Sebek infected host 
come to mind:
• (The Honeywall)
• Latency
• Network trafﬁc counters
• Syscall table modiﬁcation
• Hidden module
• Other cruft in memory
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Latency
• dd-attack:
dd if=/dev/zero of=/dev/null bs=1
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Network Trafﬁc Counters
• dd-attack / backward running counters
• dev->get_stats->tx_bytes or 
dev->get_stats->tx_packets 
vs. /proc/net/dev or ifconfig output. 
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Syscall Table
sys_exit
sys_read
sys_write
sys_open
sys_close
sys_creat
.
.
.
vmlinux
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Syscall Table
sys_exit
sys_read
sys_write
sys_open
sys_close
sys_creat
.
.
.
vmlinux
mod_12345.o
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Syscall Table
before:       
 sys_read  = 0xc0132ecc
 sys_write = 0xc0132fc8
after:      
  sys_read  = 0xc884e748
  sys_write = 0xc0132fc8
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Finding Modules
• Find
• Extract variables
• Disable
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Module Header
include/linux/module.h:
struct module
{
  unsigned long size_of_struct; /* sizeof(module) */
  struct module *next;
  const char *name;
  unsigned long size;
  union {
    atomic_t usecount;
    long pad;
  } uc;  /* Needs to keep its size - so says rth */
  unsigned long flags;        /* AUTOCLEAN et al */
  unsigned nsyms;
  unsigned ndeps;  
  struct module_symbol *syms;
  struct module_ref *deps;
  struct module_ref *refs;
  int (*init)(void);
  void (*cleanup)(void);
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Module Header
➡
➡ 96
➡ Pointers into Kernel
include/linux/module.h:
struct module
{
  unsigned long size_of_struct; /* sizeof(module) */
  struct module *next;
  const char *name;
  unsigned long size;
  union {
    atomic_t usecount;
    long pad;
  } uc;  /* Needs to keep its size - so says rth */
  unsigned long flags;        /* AUTOCLEAN et al */
  unsigned nsyms;
  unsigned ndeps;  
  struct module_symbol *syms;
  struct module_ref *deps;
  struct module_ref *refs;
  int (*init)(void);
  void (*cleanup)(void);
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Module Header
➡
➡ 96
➡ Pointers into Kernel
➡ Pointers into the Module
include/linux/module.h:
struct module
{
  unsigned long size_of_struct; /* sizeof(module) */
  struct module *next;
  const char *name;
  unsigned long size;
  union {
    atomic_t usecount;
    long pad;
  } uc;  /* Needs to keep its size - so says rth */
  unsigned long flags;        /* AUTOCLEAN et al */
  unsigned nsyms;
  unsigned ndeps;  
  struct module_symbol *syms;
  struct module_ref *deps;
  struct module_ref *refs;
  int (*init)(void);
  void (*cleanup)(void);
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Module Header
➡
➡ 96
➡ Pointers into Kernel
➡ Pointers into the Module
➡ Variables with only a 
small range of 
“reasonable” values.
include/linux/module.h:
struct module
{
  unsigned long size_of_struct; /* sizeof(module) */
  struct module *next;
  const char *name;
  unsigned long size;
  union {
    atomic_t usecount;
    long pad;
  } uc;  /* Needs to keep its size - so says rth */
  unsigned long flags;        /* AUTOCLEAN et al */
  unsigned nsyms;
  unsigned ndeps;  
  struct module_symbol *syms;
  struct module_ref *deps;
  struct module_ref *refs;
  int (*init)(void);
  void (*cleanup)(void);
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Finding Modules
• A module header is allocated by the kernels 
vmalloc.
• The function vmalloc aligns memory to 
page boundaries (4096 bytes on IA32).
• Memory allocated by vmalloc starts at 
VMALLOC_START and ends 
VMALLOC_RESERVE bytes later.
for(p = VMALLOC_START; \
    p <= VMALLOC_START + VMALLOC_RESERVE-PAGE_SIZE; \
    p =+ PAGE_SIZE)
from module_hunter.c by madsys
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Retrieving Sebek’s variables
$bs =  128 + int(rand(128));
for($x=0;$x<38;$x++){ 
    $tmp = int(rand() * $bs); 
    if(!defined($values{$tmp})){ 
        $values{$tmp} = $x; 
        push(@fun,$tmp); 
    } else {$x--;}} 
($dip, $dport, $sip, $sport, $kso, $magic, $smac0 ... $dmac5, $m_if, 
$m_dip, $m_dmac, $m_dport, $m_sport, $m_kso, $m_magic, $m_block) = @fun; 
$m_block = int(rand(1000000000)); $mod_name = int(rand(1000000000)); 
printf"//----- autogenerated fudge.h file\n\n\n"; 
print "#define BS               $bs\n"; 
print "#define DIP_OFFSET       $dip\n"; 
print "#define DPORT_OFFSET     $dport\n"; 
print "#define SIP_OFFSET       $sip\n"; 
print "#define SPORT_OFFSET     $sport\n"; 
print "#define KSO_OFFSET       $kso\n"; 
print "#define MAGIC_OFFSET     $magic\n"; 
print "#define SMAC_0_OFFSET    $smac0\n"; 
... 
print "#define DMAC_5_OFFSET    $dmac5\n"; 
sebek.h: u32      BLOCK[BS]; 
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Retrieving Sebek’s variables
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Retrieving Sebek’s variables
00000000
00000000
PORT
00000000
00000000
00000000
00000000
MAC5
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
MAC2
00000000
MAC1
00000000
00000000
MAGIC
00000000
00000000
00000000
00000000
00000000
00000000
MAC4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
MAC0
00000000
00000000
00000000
00000000
MAC3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
IP
00000000
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Retrieving Sebek’s variables
00000000
00000000
00007a69
00000000
00000000
00000000
00000000
000000d9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
000000dc
00000000
0000000d
00000000
00000000
f001c0de
00000000
00000000
00000000
00000000
00000000
00000000
000000e5
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
0000003a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
d5495b1d
00000000
Laboratory for Dependable Distributed Systems • RWTH Aachen University
Retrieving Sebek’s variables
00000000
00000000
00007a69
00000000
00000000
00000000
00000000
000000d9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000