面，我们通过研究如下所示的normal.py，考察变量赋值、变量运算及最基本的print操
象读出，从后至前地将它们填入PyListobject对象中。
虚拟机在通过BUILD_LIST指令创建PyListObject对象之后，会从运行时栈中依次将对
object对象的元素先从consts中依次读入，并压入运行时栈。然后如之前描述的，Pyton
printc
[normal.py]
现在，对于指令“3STORENAME1”的作用我们已清楚。而对于指令“OLOAD_NAME
符号搜索
STORE_NAME
第1行Python代码我们已经很熟悉了，不再整述。现在看看第2行Python代码，变
在Python编译器对normal.py的编译成功结束之后，其对应的pycodeobject中的
到了这里，对于一般的声明语句（或者说常量赋值语句），我们都已经了如指掌。
对照图9-8所示的常量表，可以看到，Pyuon虚拟机确实会首先将应该填入PyList-
LOAD_NAME
P
b
一深度探索动态语言核心技术
一
-
(b)
图9-12
normal.pyc中的常量表和符号表
下
---
## Page 197
名字空间）、全局作用域（global名字空间）、内建作用域（builtin名字空间）依次上
Python虚拟机的运行。
符号。那么Pyton虚拟机的执行流程最终会到达代码清单9-1的[4]处，抛出异常，终止
这里会向运行时栈中压入一个PyIntobect对象5。
这个例子中，第1条Python代码的执行会在f_locals中插入（a”，5）的元素对，所以
系列的搜索动作，如代码清单9-1中的[1]、[2]、[3]所示：
然后Python虚拟机会在当前活动PyFrameObject对象中所维护的多个名字空间中进行一
元素，参考图9-12所示的normal.py编译结果，可知它是一个pystringobject对象“a”。
此复杂。面对LOAD_NAME指令，首先，Python虚拟机会从符号表names中抽取出第0个
代码清单9-1
[LOAD_NAME（有删节）
这样的行为正是Pyhon官方文档中所描述的变量的搜索会沿着局部作用域（1ocal
如果到了最后还搜索不到符号“a”，那么表示有错误发生
如果搜索到了与符号“a”对应的元素，那么就将该元素压入运行时栈中。在normal.py
STORE_NAME指令非常简单，
[1]
在local名字空间f_locals中搜索符号“a”：
中搜索“a”
如果f_globals中没有符号“a”，则在Python的builtin名字空间f_builtins
如果f_locals中没有符号“a”，则在global名字空间f_globals中搜索“a”；
PUSH(X):
X
/[1]：在1ocal名字空间中查找变量名对应的变量值
By
//获得变量名
=GETITEM(names)
PY_INCREF(X）
1/[2]
PyDiet
FPyDiat
//[3]：在builtin名字空间中查找变量名对应的变量值
NUL.L
x
brealk;
Fommat
PyDiot
在glocal名字空间中查找变量名对应的变量值
（/[4]：查找变量名失败，抛出异常
GetItem(v.w）:
GetItem(f-
但没想到看上去与它成逆运算的LOADNAME指令却会如
Getitem(f->f_builtins,w)
opargl
>f_globals,):
Python源码剖析
9.3其他一般表达式
一深度探索动态语言核心技术
程序引用了一
一个不存在的
167
---
## Page 198
Python源码剖析
168
图9-13显示了一次失败的符号搜索过程。
时是将python25.dll拷贝到了system32目录下，所以对于python25.dll，直接拷贝就可以了。
码清单9-1的[1]处添加的输出代码：
形象地展示这一符号的搜索过程，我们采用在剖析Python对象机制时，修改Pyhon源代
的d子目录中存在了。
socket_d.pyd，这意味着我们还得继续编译socket工程。所以我们选择在release模式下编
作。如果在debug模式下编译得到python25_d.dll，那么在importsocket时，就会寻找
使用Python标准库中的socketmodule：所以IDLE初始化时会进行importsocket的动
译出python25.dn文件。注意，这里一定要在release模式下编译。因为IDLE程序本身会
i#(sticmp(PyString_AsString (w),
码的方法，然后在运行时实时地观察这一过程。
泽
溯，直至搜索成功或全部搜完3个作用域，
python25.dll，因为当你在机器上安装Python后，_socket.pyd已经在Python安装目录下
现在很清楚了，在“b=a”执行完成后，Python虚拟机的状态如图9-14所示：
在编译完成之后，我们将python25.dl拷贝到Python的安装目录下。由于Python安装
Traceback （most recent call last):
[LOAD_NAME]
由于我们在这里使用IDLE来观察输出信息，所以修改了代码之后，我们需要自行编
我们在代码清单9-1的[1]、[2]、[3]、[4]处各添加一段输出信息，这里我们列出在代
第9章
LOAD NAME]
spxintf(temp,
Pyobject*|target =PySys_Getobject("stdout*)
File
print
SD
一深度探索动态语言核心技术
BO
Python虚拟机中的一般表达式
PythonVM
Search failed,throw exception
Search
[LoAD_NAME]:Search PyStrinobject &s in local name
PyString_AsString（w).x==NULL?"False":"Success"):
图9-13搜索符号“PythonVM”失败
图9-14b=a执行之后的虚拟机状态
Pvstrinobi
target):
notH
ect
PythonVM)==O）
defined
PythonVM
PythonVM
也就是我们之前提到的LGB规则。为了更加
builtin name space...False
Dame
---
## Page 199
9.3.2
会通过指令STORE_NAME将（e”，num）元素对插入到1ocal名字空间中。这里展示的
计算两个变量的和。假设加法运算的结果为num，那么Pyhon虚拟机在获得结果num之后，
local名字空间中读取出来，压入运行时栈，然后通过BINARY_ADD指令进行加法运算，
在a，b都是合法而有效的变量了，它们的结合就变得很有趣了：
代码清单9-2
如代码清单9-2所示。
算，有兴趣的读者可以自行考察一下其他运算所对应的字节码指令。
是变量之间的加法运算，当然，这里的加法运算实际上完全可以替换成减法运算、乘法运
[BINARY_ADD]
一个PyIntobject对象。这里在对字节码指令的分析中，我们再次看到了这一结论。现
数值运算
Python虚拟机首先会通过两条LOAD_NAME指令将变量名a和b所对应的变量值从
从前面我们对Pyntobject对象的分析可以知道，这两个5实际上指向内存中的同
akip_decref_vx:
slow_add:
STORE_NAME
BINARY ADD
LOAD_NAME
PY_DECREF(V)
一般对象相加的慢速通道
elsel
else ie
//[3]:PyStringObject对象相加的快速通道
1(PyInE_CheckExact(v）&&PyInt_CheckExact（w)）
x=PyNumber_Ada（v,w）
goto skip_decref_vx;
x=PyInt_FromLong(i）;
register
//[11：PyLntObect对象相加的快速通道
TOPO;
POP();
/[2]：
2（c)
0105
(（ia)
(PyString_CheckExact(v)
(b)
(a)
如果加法运算溢出，转向慢速通道
slow
long a
AS_LONG(W）
（ib）>file，"str"。那么所产生
实际上输出的时候会进行很多动作，但是在这里，我们只考虑其大致的流程。Pyhon
从两条加法通道的结构我们可以看出，Python2.5实际上假设了用户在使用Pyhon时，
PRINT_NEWLINE
PRINT
LOADNAME
VPOP（）：//获得待输出对象
stream = NULL
Py_XINCREF(W);
if
TTEM
err=PyFileWriteObject（v,w,Py_PRINT_RAW）;
(w=NULL&& PyFile SoftSpace(w,
W=PySys_Getobject("stdout");
(stream
err= PyFile_WriteStking（"
2（）
for PRINT opcodes
Python源码剖析
WI:
9.3其他一般表达式
一深度探索动态语言核心技术
PRINT_ITEM_TO:
171
---
## Page 202
Python源码剖析
172
后的救命稻草也失败了，Pyhon也无能为力了，只好返回失败信息。
先调用tpstr或tp_repr获得对象的字符串表示形式，然后将字符串输出。如果连这最
等待输出对象自身所携带的输出函数进行输出。如果对象没有定义tp_print，那么它会
stream设为了NULL，为下次输出时的判断做准备。
是否为NULL来确定是否需要输出到标准输出流。可以看到，在PRINT_ITEM最后，又将
stream的原因是变量w在别的字节码指令的实现中可能还会使用到，所以无法通过判断w
strean是作为一个判断条件来使用的，真正使用的输出目标是w。要多次使用这一个
执行PRINT_ITEM_To时，输出的目标就赋给了stream，同时也赋给了w。所以实际上
第9章Python虚拟机中的一般表达式
在获得了输出的目标和待输出的对象后，PRINT_ITEM将通过PyFile_WriteObject
图9-16给出了在PRINT_ITEM中输出目标的两种情况：
显然，这时在运行时栈中，在待输出对象之前，还会有一个对象，即输出的目标。在
一深度探索动态语言核心技术
图9-16PRINT_ITEM中W所代表的两种输出目标
wis a file with name:demo.txt
>>>print1
---