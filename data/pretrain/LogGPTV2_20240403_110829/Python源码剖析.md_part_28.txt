### 优化后的文本

#### 变量赋值、运算及 `print` 操作
我们通过研究 `normal.py`，来考察变量赋值、变量运算及最基本的 `print` 操作。首先，Python 虚拟机会通过 `BUILD_LIST` 指令创建一个 `PyListObject` 对象，并从 `consts` 中依次读取元素并压入运行时栈。随后，这些元素将从运行时栈中依次填入 `PyListObject` 对象。

对于指令 `3 STORE_NAME` 的作用已经明确。而对于指令 `0 LOAD_NAME`，它会从符号表中提取第0个元素（即 `PyStringObject` 对象 "a"），然后在当前活动的 `PyFrameObject` 对象所维护的多个名字空间中进行一系列搜索动作。具体来说，虚拟机会依次在局部作用域（local 名字空间）、全局作用域（global 名字空间）和内建作用域（builtin 名字空间）中搜索符号 "a"。如果搜索成功，则将该元素压入运行时栈；若搜索失败，则抛出异常。

#### 常量表与符号表
对照图9-8所示的常量表，可以看到 Python 虚拟机确实会首先将应该填入 `PyListObject` 的元素从 `consts` 中读入，并压入运行时栈。图9-12展示了 `normal.pyc` 文件中的常量表和符号表。

#### `LOAD_NAME` 指令
`LOAD_NAME` 指令的行为如下：
1. 在局部作用域 `f_locals` 中搜索符号 "a"。
2. 如果未找到，则在全局作用域 `f_globals` 中搜索符号 "a"。
3. 如果仍未找到，则在内建作用域 `f_builtins` 中搜索符号 "a"。
4. 如果所有作用域均未找到，则抛出异常。

这种行为符合 Python 官方文档中描述的变量搜索规则（LGB规则）。

#### `STORE_NAME` 指令
`STORE_NAME` 指令非常简单，它会在局部作用域 `f_locals` 中插入一个新的键值对。例如，在执行 `a = 5` 时，虚拟机会向 `f_locals` 插入 (`a`, 5) 这一对。

#### 加法运算
当计算两个变量的和时，假设加法运算的结果为 `num`，Python 虚拟机会通过两条 `LOAD_NAME` 指令将变量 `a` 和 `b` 的值从局部作用域中读取出来并压入运行时栈，然后通过 `BINARY_ADD` 指令进行加法运算。如果加法运算结果是一个整数，则会生成一个 `PyIntObject` 对象。这里展示的是变量之间的加法运算，但也可以替换成减法、乘法等其他运算。

#### `print` 操作
`print` 操作的大致流程如下：
1. 从运行时栈中获取待输出的对象。
2. 确定输出目标，默认为标准输出流 `stdout`。
3. 通过 `PyFile_WriteObject` 函数将对象输出到指定的目标。

图9-16展示了 `PRINT_ITEM` 中输出目标的两种情况：一种是输出到文件，另一种是输出到标准输出流。

通过以上分析，我们可以更清晰地理解 Python 虚拟机在处理变量赋值、运算及 `print` 操作时的具体行为。