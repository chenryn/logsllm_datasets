In Phong Q. Nguyen and David Pointcheval, editors,
PKC 2010, volume 6056 of LNCS, pages 312–331. Springer, Heidelberg, May 2010.
[27] Alexander Heinrich, Matthias Hollick, Thomas Schneider, Milan Stute, and Chris-
tian Weinert. Privatedrop: Practical privacy-preserving authentication for apple
airdrop. In 30th {USENIX} Security Symposium ({USENIX} Security 21), 2021.
[28] Yan Huang, David Evans, and Jonathan Katz. Private set intersection: Are gar-
bled circuits better than custom protocols? In NDSS 2012. The Internet Society,
February 2012.
[29] Bernardo A. Huberman, Matt Franklin, and Tad Hogg. Enhancing privacy and
trust in electronic communities. In ACM CONFERENCE ON ELECTRONIC COM-
MERCE. ACM, 1999.
[30] Mihaela Ion, Ben Kreuter, Ahmet Erhan Nergiz, Sarvar Patel, Mariana Raykova,
Shobhit Saxena, Karn Seth, David Shanahan, and Moti Yung. On deploying
secure computing commercially: Private intersection-sum protocols and their
business applications. Cryptology ePrint Archive, Report 2019/723, 2019. https:
//eprint.iacr.org/2019/723.
[31] Mihaela Ion, Ben Kreuter, Erhan Nergiz, Sarvar Patel, Shobhit Saxena, Karn
Seth, David Shanahan, and Moti Yung. Private intersection-sum protocol with
applications to attributing aggregate ad conversions. Cryptology ePrint Archive,
Report 2017/738, 2017. https://eprint.iacr.org/2017/738.
[32] Yuval Ishai, Joe Kilian, Kobbi Nissim, and Erez Petrank. Extending oblivious
transfers efficiently. In Dan Boneh, editor, CRYPTO 2003, volume 2729 of LNCS,
pages 145–161. Springer, Heidelberg, August 2003.
[33] Stanislaw Jarecki and Xiaomin Liu. Efficient oblivious pseudorandom function
with applications to adaptive OT and secure computation of set intersection. In
Omer Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 577–594. Springer,
Heidelberg, March 2009.
[34] Stanislaw Jarecki and Xiaomin Liu. Fast secure computation of set intersection.
In Juan A. Garay and Roberto De Prisco, editors, SCN 10, volume 6280 of LNCS,
pages 418–435. Springer, Heidelberg, September 2010.
[35] Lea Kissner and Dawn Xiaodong Song. Privacy-preserving set operations. In
Victor Shoup, editor, CRYPTO 2005, volume 3621 of LNCS, pages 241–257. Springer,
Heidelberg, August 2005.
[36] Vladimir Kolesnikov, Ranjit Kumaresan, Mike Rosulek, and Ni Trieu. Efficient
batched oblivious PRF with applications to private set intersection. In Edgar R.
Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai
Halevi, editors, ACM CCS 2016, pages 818–829. ACM Press, October 2016.
[37] Mark Manulis, Benny Pinkas, and Bertram Poettering. Privacy-preserving group
discovery with linear complexity. In Jianying Zhou and Moti Yung, editors, ACNS
10, volume 6123 of LNCS, pages 420–437. Springer, Heidelberg, June 2010.
[38] Daniel Masny and Peter Rindal. Endemic oblivious transfer. In Lorenzo Cavallaro,
Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019,
pages 309–326. ACM Press, November 2019.
[39] C. Meadows. A more efficient cryptographic matchmaking protocol for use in
the absence of a continuously available third party. In 1986 IEEE Symposium on
Security and Privacy, pages 134–134, April 1986.
[40] Ghita Mezzour, Adrian Perrig, Virgil D. Gligor, and Panos Papadimitratos. Privacy-
preserving relationship path discovery in social networks. In Juan A. Garay,
Atsuko Miyaji, and Akira Otsuka, editors, CANS 09, volume 5888 of LNCS, pages
189–208. Springer, Heidelberg, December 2009.
[41] R. Moenck and Allan Borodin. Fast modular transforms via division. In Switching
and Automata Theory, pages 90–96, 1972.
[42] Benny Pinkas, Mike Rosulek, Ni Trieu, and Avishay Yanai. SpOT-light: Light-
weight private set intersection from sparse OT extension. In Alexandra Boldyreva
and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS,
pages 401–431. Springer, Heidelberg, August 2019.
[43] Benny Pinkas, Mike Rosulek, Ni Trieu, and Avishay Yanai. PSI from PaXoS:
In Anne Canteaut and Yuval Ishai,
Fast, malicious private set intersection.
editors, EUROCRYPT 2020, Part II, volume 12106 of LNCS, pages 739–767. Springer,
Heidelberg, May 2020.
[44] Benny Pinkas, Thomas Schneider, Gil Segev, and Michael Zohner. Phasing:
Private set intersection using permutation-based hashing. In Jaeyeon Jung and
Thorsten Holz, editors, 24th USENIX Security Symposium, USENIX Security 15,
Washington, D.C., USA, August 12-14, 2015., pages 515–530. USENIX Association,
2015.
[45] Benny Pinkas, Thomas Schneider, and Michael Zohner. Faster private set inter-
section based on OT extension. In Kevin Fu and Jaeyeon Jung, editors, Proceedings
of the 23rd USENIX Security Symposium, San Diego, CA, USA, August 20-22, 2014.,
pages 797–812. USENIX Association, 2014.
[46] Peter Rindal and Mike Rosulek. Improved private set intersection against ma-
licious adversaries. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors,
EUROCRYPT 2017, Part I, volume 10210 of LNCS, pages 235–259. Springer, Hei-
delberg, April / May 2017.
[47] Peter Rindal and Mike Rosulek. Malicious-secure private set intersection via dual
execution. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan
Xu, editors, ACM CCS 2017, pages 1229–1242. ACM Press, October / November
2017.
[48] Peter Rindal and Phillipp Schoppmann. Vole-psi: Fast oprf and circuit-psi from
vector-ole. Cryptology ePrint Archive, Report 2021/266, 2021. https://eprint.iacr.
org/2021/266.
A SEMI-HONEST VARIANT
In this section we show a simpler semi-honest variant of our proto-
col.
The details of the protocol are given in Figure 5. The correctness
of the protocol boils down to the following observations:
Session 4C: Private Set Intersection CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1179Compact and Malicious Private Set Intersection for Small Sets
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
Parameters: finite field F
KA protocol KA with KA.M = F and |KA.K| ≥ 2𝜆+2 log 𝑛
ideal permutation Π, Π−1 : F → F
Sender
input 𝑋 = {𝑥1, . . . , 𝑥𝑛} ⊆ F
Receiver
input 𝑌 = {𝑦1, . . . , 𝑦𝑛} ⊆ F
1. 𝑎 ← KA.R
2. 𝑚 = KA.msg1(𝑎)
3.
4.
𝑚
𝑃
5. for 𝑖 ∈ [𝑛]:
𝑘𝑖 = KA.key1(𝑎, Π(𝑃(𝑥𝑖)))
6. 𝐾 = {𝑘1, . . . , 𝑘𝑛} (shuffled)
𝐾
7.
for 𝑖 ∈ [𝑛]:
𝑏𝑖 ← KA.R
𝑚′
𝑖 = KA.msg2(𝑏𝑖, 𝑚)
𝑓𝑖 = Π−1(𝑚′
𝑖)
𝑃 = interpolF
(cid:16){(𝑦𝑖, 𝑓𝑖) | 𝑦𝑖 ∈ 𝑌}(cid:17)
output {𝑦𝑖 | KA.key2(𝑏𝑖, 𝑚) ∈ 𝐾}
Figure 5: Semi-honest variant of our protocol.
• Suppose 𝑥𝑖 = 𝑦 𝑗 for some 𝑖, 𝑗 (i.e., 𝑥𝑖 is an item of the sender that
is in the intersection). Then by construction we have:
KA.key1(𝑎, Π(𝑃(𝑥𝑖))) = KA.key1(𝑎, Π(𝑓𝑗))
= KA.key1(𝑎, 𝑚′
𝑗)
= KA.key1(𝑎, KA.msg2(𝑏 𝑗 , 𝑚))
By the correctness of the KA protocol, this is equal to KA.key2(𝑏 𝑗 , 𝑚),
and the receiver will indeed include 𝑦 𝑗 (= 𝑥𝑖) in the output.
• Suppose 𝑥𝑖 ∉ 𝑌. In this case, our security proof will argue that
the corresponding 𝑘𝑖 value (computed by the sender) is pseudo-
random. The receiver only produces incorrect output if this 𝑘𝑖
happens to match one of the KA.key2(𝑏 𝑗 , 𝑚) values computed
by the receiver. For this particular 𝑘𝑖, this event happens with
probability (negligibly close to) 𝑛/|KA.K|. With a union bound
over at most 𝑛 such 𝑘𝑖 values, the overall probability of incorrect
output is at most (negligibly close to) 𝑛2/|KA.K|.
To limit the correctness error to a concrete value 2−𝜆 (for example,
𝜆 = 40 in our implementation), it suffices to use a KA protocol with
|KA.K| ≥ 2𝜆+2 log 𝑛.
Lemma A.1. The protocol of Figure 5 is secure against a semi-
honest sender, if KA is a pseudorandom-message KA (Definition 3.4)
and Π± is an ideal permutation.
Proof. Since the only protocol message from the receiver is 𝑃,
it suffices to show how to simulate 𝑃. In fact, we simply show that 𝑃
is indistinguishable from a polynomial of appropriate degree with
coefficients chosen uniformly in F.
𝑖 = KA.msg2(𝑏𝑖, 𝑚)” in
step 3 with “𝑚′
𝑖 ← KA.M (= F)”. This change is indistinguishable
to the sender by the pseudorandom-message property of KA. Then,
First, consider replacing “𝑏𝑖 ← KA.R; 𝑚′
since Π is a permutation, we see that 𝑓𝑖 becomes uniformly dis-
tributed on F. Finally, interpolating a polynomial on a set of points
{(𝑦𝑖, 𝑓𝑖)}, where each 𝑓𝑖 is uniform in F, results in a uniformly
chosen polynomial, independent of the 𝑦𝑖 values.
□
Lemma A.2. The protocol of Figure 5 is secure against a semi-
honest receiver, if KA is a secure KA (Definition 3.2) and Π± is an ideal
permutation.
Proof. First, we discuss the intuition of the proof. For each
𝑥𝑖 ∈ 𝑋, the sender interprets Π(𝑃(𝑥𝑖)) as a KA protocol message.
When 𝑥𝑖 ∈ 𝑋 \ 𝑌, the receiver never actively chooses the value at
𝑃(𝑥𝑖), and so presumably does not know the secret randomness
of the KA message Π(𝑃(𝑥𝑖)). From the receiver’s perspective, this
is just like watching a KA instance between two external parties,
so the resulting key 𝑘𝑖 should look random. We can formalize this
by having the simulator program Π(𝑃(𝑥𝑖)) to be a KA protocol
message whose underlying randomness is explicitly unknown to
the receiver.
More formally, define Hybrid #ℎ as follows (taking 𝑋 and 𝑌 both
as inputs):
• Steps 1-2: same as honest sender.
• Step 5:
– for 𝑥𝑖 ∈ (𝑋∩𝑌)∪{𝑥𝑖 | 𝑖 ≥ ℎ}: compute 𝑘𝑖 = KA.key1(𝑎, Π(𝑃(𝑥𝑖))).
– for all other 𝑥𝑖 ∈ 𝑋, choose 𝑘𝑖 ← KA.K.
• Step 6: set 𝐾 = {𝑘1, . . . , 𝑘𝑛}, shuffled.
Clearly Hybrid #0 corresponds to the real interaction. Furthermore,
Hybrid #𝑛 describes a valid simulation. Even though formally Hy-
brid #𝑛 gets the honest sender’s input 𝑋 as input, it does not need
to know any values in 𝑋 \ 𝑌 (only how many of them exist). Hence
Hybrid #𝑛’s behavior can be carried out given only 𝑌, 𝑋 ∩ 𝑌, and
|𝑋|.
Now define the following reduction algorithm 𝐴(ℎ, 𝑚1, 𝑚2, 𝑘∗, 𝑋, 𝑌):
• Initially, use the receiver’s honest behavior to anticipate what
𝑃 will be, playing the role of Π± honestly. If 𝑥ℎ ∉ 𝑋 ∩ 𝑌 then
program Π± so that Π(𝑃(𝑥ℎ)) = 𝑚2.2
• Steps 1-2: same as honest sender.
• Step 5:
– for 𝑥𝑖 ∈ (𝑋∩𝑌)∪{𝑥𝑖 | 𝑖 > ℎ}: compute 𝑘𝑖 = KA.key1(𝑎, Π(𝑃(𝑥𝑖))).
– if 𝑥ℎ ∉ 𝑋 ∩ 𝑌, hence not handled by the previous case, set
𝑘ℎ = 𝑘∗.
– for all other 𝑥𝑖 ∈ 𝑋, choose 𝑘𝑖 ← KA.K.
• Step 6: set 𝐾 = {𝑘1, . . . , 𝑘𝑛}, shuffled.
Observe that if 𝑘∗ is the key resulting from KA conversation (𝑚1, 𝑚2),
then 𝐴(ℎ, 𝑚1, 𝑚2, 𝑘∗, 𝑋, 𝑌) generates exactly Hybrid #ℎ. But if 𝑘∗ is
uniform and independent of (𝑚1, 𝑚2), then 𝐴(ℎ, 𝑚1, 𝑚2, 𝑘∗, 𝑋, 𝑌)
generates exactly Hybrid #(ℎ + 1). These two cases are indistin-
guishable by the standard real-vs-random security property of KA.
Hence, Hybrids #ℎ and #(ℎ + 1) are indistinguishable.
□
2Technically speaking, this step can fail if Π−1 was already defined on 𝑚2 while
the simulator was predicting how the sender computes 𝑃. This case happens with
negligible probability since only a negligible fraction of Π± is ever defined, and 𝑚2
messages are pseudorandom.
Session 4C: Private Set Intersection CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1180CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
Mike Rosulek and Ni Trieu
Proof. Let A be an adversary that wins the game with proba-
bility 𝜖. Using A we can compress a list (𝛼1, . . . , 𝛼𝑞, 𝛽1, . . . , 𝛽𝑞) by
giving the following information (in this order):
• the output polynomial 𝑃 ← A(𝛼1, . . . , 𝛼1, 𝛽1, . . . , 𝛽𝑞)
• a bipartite graph 𝐺 with left and right vertex sets [𝑞], left-degree
1, and an edge from left vertex 𝑖 to right vertex 𝑗 if 𝑃(𝛼𝑖) = 𝛽 𝑗
• for every connected component in 𝐺 (in some canonical order):
– If the component is a singleton right vertex 𝑖, give 𝛽𝑖
– If the component contains a left vertex, let 𝑖 be the lowest
numbered left vertex in the component, and give 𝛼𝑖. Then
for every left vertex 𝑖 except the lowest numbered one, give
an index 𝑣 such that 𝛼𝑖 is the 𝑣th root of 𝑃(·) − 𝑃(𝛼𝑖) in
lexicographic order.
Recovering the 𝛼𝑖 and 𝛽𝑖 inputs from this information amounts to
labeling each vertex in 𝐺 with the appropriate 𝛼𝑖 or 𝛽 𝑗, which can
be done in a straight-forward way.
Note that the graph 𝐺 has 2𝑞 vertices, and if it has 𝑒 edges then
it has 𝑐 = 2𝑞 − 𝑒 connected components. The number of possible
“compressed encodings” is at most the product of the following
terms:
• |F|𝑛, for the number of polynomials 𝑃
• (𝑞2)𝑒, for (an upper bound on) the number of bipartite graphs
• |F|𝑐, for listing one 𝛼𝑖 or 𝛽 𝑗 per component
• 𝑛𝑒, for the other information in each connected component —
there are at most 𝑒 left vertices in nontrivial connected compo-
nents, and each index 𝑣 names one of the 𝑛 roots of a deg < 𝑛
polynomial.
with 𝑞 + 𝑞 vertices and 𝑒 edges.
Hence, the number of such encodings is bounded by:
(cid:18) 𝑞2𝑛
(cid:19)𝑒
|F|
Yet the number of inputs to this compression algorithm is |F|2𝑞.
Hence the compression cannot succeed with probability better than
the ratio of inputs to outputs:
|F|2𝑞+𝑛−𝑛′ · 𝑞2𝑛′ · 𝑛𝑛′
|F|2𝑞
(𝑞2𝑛)𝑛′
|F|𝑛′−𝑛
=
□
|F|𝑛 · 𝑞2𝑒 · |F|2𝑞−𝑒 · 𝑛𝑒 = |F|2𝑞+𝑛 ·
Assume that the quantity in parentheses is less than 1, since if it
is not then the probability bound in the statement of the lemma
exceeds 1 and is therefore trivial. When A wins the game, then
𝑒 ≥ 𝑛′ and the number of encodings is bounded by:
(cid:18) 𝑞2𝑛
(cid:19)𝑛′
|F|
|F|2𝑞+𝑛 ·
B OPTIMIZATIONS
For all of these optimizations, we leave it as an exercise for the
reader to verify that the security proofs hold when using the opti-
mizations.
Elligator. Our protocol requires a KA protocol whose second
message is pseudorandom, since only the second KA message is
encoded into a polynomial. Elligator-DHKA requires parties to
re-sample randomness until they “hit” the elligator subset of the
elliptic curve. Only the receiver needs to do this in our PSI protocol;
the sender does not need to use elligator encodings for their KA
message.
Alternatives to Polynomials. Our PSI protocol requires the re-
ceiver to interpolate a polynomial over 𝑛 points, and the sender to
evaluate that polynomial on 𝑛 points, where 𝑛 is the size of their
sets (e.g., 𝑛 = 1M). Each of these procedures cost 𝑂(𝑛 log2 𝑛) field
operations.
One way to reduce the cost of this step is to encode the same infor-
mation in a different way. The purpose of 𝑃 is to convey mappings
of the form 𝑦𝑖 ↦→ 𝑓𝑖 in a way that hides the 𝑦𝑖 values. Concurrent to
this work, Garimella et al. [23] introduced oblivious key-value stores
(OKVS), which are an abstraction that provides the properties that
our protocol requires. They present an efficient OKVS alternative
to polynomials that has linear encoding time, but at a small (∼35%)
increase in communication size. This data structure can be used
in our protocol to replace polynomials, however: (1) Polynomial
interpolation over small (degree < 1000) polynomials is a very small
contribution to the protocol’s overall cost (even using a simpler
quadratic algorithm) compared to the cost of elliptic curve exponen-
tiations. (2) Even a 35% increase in size significantly undermines
our protocol’s contribution of minimal communication cost.
F
(𝑞):
C POLYNOMIAL OVERFITTING
Recall the polynomial overfitting game PolyOverfit𝑛,𝑛′
sample 𝛼1, . . . , 𝛼𝑞 ← F
sample 𝛽, . . . , 𝛽𝑞 ← F
give {𝛼1, . . . , 𝛼𝑞} and {𝛽1, . . . , 𝛽𝑞} to A
A outputs a polynomial 𝑃
if 0 < deg(𝑃) < 𝑛 and 𝑃(𝛼𝑖) ∈ {𝛽1, . . . , 𝛽𝑞} for at least 𝑛′ distinct 𝛼𝑖:
A wins the game
else A loses the game
We prove an unconditional bound for winning this game, based
on a compression argument.
Proposition C.1. Let 𝐸 : 𝐴 → 𝐵 and 𝐷 : 𝐵 → 𝐴 be functions.
Then Pr𝑎←𝐴[𝐷(𝐸(𝑎)) = 𝑎] ≤ |𝐵|/|𝐴|.
Proof. If 𝑎 ∉ range(𝐷), then we can never have 𝐷(𝐸(𝑎)) = 𝑎.
□
Furthermore, |range(𝐷)| ≤ |𝐵|.
Lemma C.2. The probability of any (computationally unbounded)
adversary winning PolyOverfit𝑛,𝑛′
(𝑞) is at most
F
(𝑞2𝑛)𝑛′/|F|𝑛′−𝑛
Session 4C: Private Set Intersection CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1181