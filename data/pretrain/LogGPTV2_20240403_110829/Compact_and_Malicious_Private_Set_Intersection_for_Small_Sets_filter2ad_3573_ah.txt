### References

1. **Phong Q. Nguyen and David Pointcheval (Eds.)**  
   *PKC 2010, Volume 6056 of LNCS, Pages 312–331.*  
   Springer, Heidelberg, May 2010.

2. **Alexander Heinrich, Matthias Hollick, Thomas Schneider, Milan Stute, and Christian Weinert**  
   *Privatedrop: Practical Privacy-Preserving Authentication for Apple Airdrop.*  
   In *30th USENIX Security Symposium (USENIX Security 21)*, 2021.

3. **Yan Huang, David Evans, and Jonathan Katz**  
   *Private Set Intersection: Are Garbled Circuits Better than Custom Protocols?*  
   In *NDSS 2012*. The Internet Society, February 2012.

4. **Bernardo A. Huberman, Matt Franklin, and Tad Hogg**  
   *Enhancing Privacy and Trust in Electronic Communities.*  
   In *ACM Conference on Electronic Commerce*. ACM, 1999.

5. **Mihaela Ion, Ben Kreuter, Ahmet Erhan Nergiz, Sarvar Patel, Mariana Raykova, Shobhit Saxena, Karn Seth, David Shanahan, and Moti Yung**  
   *On Deploying Secure Computing Commercially: Private Intersection-Sum Protocols and Their Business Applications.*  
   *Cryptology ePrint Archive, Report 2019/723*, 2019.  
   [https://eprint.iacr.org/2019/723](https://eprint.iacr.org/2019/723)

6. **Mihaela Ion, Ben Kreuter, Erhan Nergiz, Sarvar Patel, Shobhit Saxena, Karn Seth, David Shanahan, and Moti Yung**  
   *Private Intersection-Sum Protocol with Applications to Attributing Aggregate Ad Conversions.*  
   *Cryptology ePrint Archive, Report 2017/738*, 2017.  
   [https://eprint.iacr.org/2017/738](https://eprint.iacr.org/2017/738)

7. **Yuval Ishai, Joe Kilian, Kobbi Nissim, and Erez Petrank**  
   *Extending Oblivious Transfers Efficiently.*  
   In *Dan Boneh (Ed.), CRYPTO 2003, Volume 2729 of LNCS, Pages 145–161*.  
   Springer, Heidelberg, August 2003.

8. **Stanislaw Jarecki and Xiaomin Liu**  
   *Efficient Oblivious Pseudorandom Function with Applications to Adaptive OT and Secure Computation of Set Intersection.*  
   In *Omer Reingold (Ed.), TCC 2009, Volume 5444 of LNCS, Pages 577–594*.  
   Springer, Heidelberg, March 2009.

9. **Stanislaw Jarecki and Xiaomin Liu**  
   *Fast Secure Computation of Set Intersection.*  
   In *Juan A. Garay and Roberto De Prisco (Eds.), SCN 2010, Volume 6280 of LNCS, Pages 418–435*.  
   Springer, Heidelberg, September 2010.

10. **Lea Kissner and Dawn Xiaodong Song**  
    *Privacy-Preserving Set Operations.*  
    In *Victor Shoup (Ed.), CRYPTO 2005, Volume 3621 of LNCS, Pages 241–257*.  
    Springer, Heidelberg, August 2005.

11. **Vladimir Kolesnikov, Ranjit Kumaresan, Mike Rosulek, and Ni Trieu**  
    *Efficient Batched Oblivious PRF with Applications to Private Set Intersection.*  
    In *Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi (Eds.), ACM CCS 2016, Pages 818–829*.  
    ACM Press, October 2016.

12. **Mark Manulis, Benny Pinkas, and Bertram Poettering**  
    *Privacy-Preserving Group Discovery with Linear Complexity.*  
    In *Jianying Zhou and Moti Yung (Eds.), ACNS 2010, Volume 6123 of LNCS, Pages 420–437*.  
    Springer, Heidelberg, June 2010.

13. **Daniel Masny and Peter Rindal**  
    *Endemic Oblivious Transfer.*  
    In *Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz (Eds.), ACM CCS 2019, Pages 309–326*.  
    ACM Press, November 2019.

14. **C. Meadows**  
    *A More Efficient Cryptographic Matchmaking Protocol for Use in the Absence of a Continuously Available Third Party.*  
    In *1986 IEEE Symposium on Security and Privacy, Pages 134–134*.  
    April 1986.

15. **Ghita Mezzour, Adrian Perrig, Virgil D. Gligor, and Panos Papadimitratos**  
    *Privacy-Preserving Relationship Path Discovery in Social Networks.*  
    In *Juan A. Garay, Atsuko Miyaji, and Akira Otsuka (Eds.), CANS 2009, Volume 5888 of LNCS, Pages 189–208*.  
    Springer, Heidelberg, December 2009.

16. **R. Moenck and Allan Borodin**  
    *Fast Modular Transforms via Division.*  
    In *Switching and Automata Theory, Pages 90–96*.  
    1972.

17. **Benny Pinkas, Mike Rosulek, Ni Trieu, and Avishay Yanai**  
    *SpOT-light: Lightweight Private Set Intersection from Sparse OT Extension.*  
    In *Alexandra Boldyreva and Daniele Micciancio (Eds.), CRYPTO 2019, Part III, Volume 11694 of LNCS, Pages 401–431*.  
    Springer, Heidelberg, August 2019.

18. **Benny Pinkas, Mike Rosulek, Ni Trieu, and Avishay Yanai**  
    *PSI from PaXoS: Fast, Malicious Private Set Intersection.*  
    In *Anne Canteaut and Yuval Ishai (Eds.), EUROCRYPT 2020, Part II, Volume 12106 of LNCS, Pages 739–767*.  
    Springer, Heidelberg, May 2020.

19. **Benny Pinkas, Thomas Schneider, Gil Segev, and Michael Zohner**  
    *PHASING: Private Set Intersection Using Permutation-Based Hashing.*  
    In *Jaeyeon Jung and Thorsten Holz (Eds.), 24th USENIX Security Symposium, USENIX Security 2015, Washington, D.C., USA, August 12-14, 2015, Pages 515–530*.  
    USENIX Association, 2015.

20. **Benny Pinkas, Thomas Schneider, and Michael Zohner**  
    *Faster Private Set Intersection Based on OT Extension.*  
    In *Kevin Fu and Jaeyeon Jung (Eds.), Proceedings of the 23rd USENIX Security Symposium, San Diego, CA, USA, August 20-22, 2014, Pages 797–812*.  
    USENIX Association, 2014.

21. **Peter Rindal and Mike Rosulek**  
    *Improved Private Set Intersection Against Malicious Adversaries.*  
    In *Jean-Sébastien Coron and Jesper Buus Nielsen (Eds.), EUROCRYPT 2017, Part I, Volume 10210 of LNCS, Pages 235–259*.  
    Springer, Heidelberg, April/May 2017.

22. **Peter Rindal and Mike Rosulek**  
    *Malicious-Secure Private Set Intersection via Dual Execution.*  
    In *Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu (Eds.), ACM CCS 2017, Pages 1229–1242*.  
    ACM Press, October/November 2017.

23. **Peter Rindal and Phillipp Schoppmann**  
    *Vole-PSI: Fast OPRF and Circuit-PSI from Vector-OLE.*  
    *Cryptology ePrint Archive, Report 2021/266*, 2021.  
    [https://eprint.iacr.org/2021/266](https://eprint.iacr.org/2021/266)

### A Semi-Honest Variant

In this section, we present a simpler semi-honest variant of our protocol. The details are provided in Figure 5. The correctness of the protocol is based on the following observations:

- **Intersection Case**: If \( x_i = y_j \) for some \( i, j \) (i.e., \( x_i \) is an item in the intersection), then by construction:
  \[
  \text{KA.key1}(a, \Pi(P(x_i))) = \text{KA.key1}(a, \Pi(f_j)) = \text{KA.key1}(a, m'_j) = \text{KA.key1}(a, \text{KA.msg2}(b_j, m))
  \]
  By the correctness of the KA protocol, this is equal to \(\text{KA.key2}(b_j, m)\), and the receiver will include \( y_j \) (which is \( x_i \)) in the output.

- **Non-Intersection Case**: If \( x_i \notin Y \), the corresponding \( k_i \) value (computed by the sender) is pseudorandom. The receiver only produces incorrect output if \( k_i \) matches one of the \(\text{KA.key2}(b_j, m)\) values computed by the receiver. For a specific \( k_i \), this event happens with probability (negligibly close to) \( n / | \text{KA.K} | \). With a union bound over at most \( n \) such \( k_i \) values, the overall probability of incorrect output is at most (negligibly close to) \( n^2 / | \text{KA.K} | \).

To limit the correctness error to a concrete value \( 2^{-\lambda} \) (for example, \(\lambda = 40\) in our implementation), it suffices to use a KA protocol with \( | \text{KA.K} | \geq 2^{\lambda + 2 \log n} \).

#### Lemma A.1
The protocol in Figure 5 is secure against a semi-honest sender if KA is a pseudorandom-message KA (Definition 3.4) and \(\Pi^{\pm}\) is an ideal permutation.

**Proof:**
Since the only protocol message from the receiver is \( P \), it suffices to show how to simulate \( P \). In fact, we simply show that \( P \) is indistinguishable from a polynomial of appropriate degree with coefficients chosen uniformly in \( F \).

Consider replacing " \( b_i \leftarrow \text{KA.R}; m'_i = \text{KA.msg2}(b_i, m) \)" in step 3 with " \( m'_i \leftarrow \text{KA.M} (= F) \)". This change is indistinguishable to the sender by the pseudorandom-message property of KA. Since \(\Pi\) is a permutation, \( f_i \) becomes uniformly distributed on \( F \). Finally, interpolating a polynomial on a set of points \(\{(y_i, f_i)\}\), where each \( f_i \) is uniform in \( F \), results in a uniformly chosen polynomial, independent of the \( y_i \) values.
\(\blacksquare\)

#### Lemma A.2
The protocol in Figure 5 is secure against a semi-honest receiver if KA is a secure KA (Definition 3.2) and \(\Pi^{\pm}\) is an ideal permutation.

**Proof:**
First, we discuss the intuition of the proof. For each \( x_i \in X \), the sender interprets \(\Pi(P(x_i))\) as a KA protocol message. When \( x_i \in X \setminus Y \), the receiver never actively chooses the value at \( P(x_i) \), and so presumably does not know the secret randomness of the KA message \(\Pi(P(x_i))\). From the receiver's perspective, this is like watching a KA instance between two external parties, so the resulting key \( k_i \) should look random. We can formalize this by having the simulator program \(\Pi(P(x_i))\) to be a KA protocol message whose underlying randomness is explicitly unknown to the receiver.

More formally, define Hybrid #\( h \) as follows (taking \( X \) and \( Y \) both as inputs):

- **Steps 1-2**: same as honest sender.
- **Step 5**:
  - For \( x_i \in (X \cap Y) \cup \{x_i | i \geq h\} \): compute \( k_i = \text{KA.key1}(a, \Pi(P(x_i))) \).
  - For all other \( x_i \in X \), choose \( k_i \leftarrow \text{KA.K} \).
- **Step 6**: set \( K = \{k_1, \ldots, k_n\} \), shuffled.

Clearly, Hybrid #0 corresponds to the real interaction. Furthermore, Hybrid #\( n \) describes a valid simulation. Even though formally Hybrid #\( n \) gets the honest sender’s input \( X \) as input, it does not need to know any values in \( X \setminus Y \) (only how many of them exist). Hence, Hybrid #\( n \)'s behavior can be carried out given only \( Y \), \( X \cap Y \), and \( |X| \).

Now define the following reduction algorithm \( A(h, m_1, m_2, k^*, X, Y) \):

- Initially, use the receiver’s honest behavior to anticipate what \( P \) will be, playing the role of \(\Pi^{\pm}\) honestly. If \( x_h \notin X \cap Y \) then program \(\Pi^{\pm}\) so that \(\Pi(P(x_h)) = m_2\).
- **Steps 1-2**: same as honest sender.
- **Step 5**:
  - For \( x_i \in (X \cap Y) \cup \{x_i | i > h\} \): compute \( k_i = \text{KA.key1}(a, \Pi(P(x_i))) \).
  - If \( x_h \notin X \cap Y \), hence not handled by the previous case, set \( k_h = k^* \).
  - For all other \( x_i \in X \), choose \( k_i \leftarrow \text{KA.K} \).
- **Step 6**: set \( K = \{k_1, \ldots, k_n\} \), shuffled.

Observe that if \( k^* \) is the key resulting from KA conversation \((m_1, m_2)\), then \( A(h, m_1, m_2, k^*, X, Y) \) generates exactly Hybrid #\( h \). But if \( k^* \) is uniform and independent of \((m_1, m_2)\), then \( A(h, m_1, m_2, k^*, X, Y) \) generates exactly Hybrid #\((h + 1)\). These two cases are indistinguishable by the standard real-vs-random security property of KA. Hence, Hybrids #\( h \) and #\((h + 1)\) are indistinguishable.
\(\blacksquare\)

### B. Optimizations

For all of these optimizations, we leave it as an exercise for the reader to verify that the security proofs hold when using the optimizations.

- **Elligator**: Our protocol requires a KA protocol whose second message is pseudorandom, since only the second KA message is encoded into a polynomial. Elligator-DHKA requires parties to re-sample randomness until they “hit” the elligator subset of the elliptic curve. Only the receiver needs to do this in our PSI protocol; the sender does not need to use elligator encodings for their KA message.

- **Alternatives to Polynomials**: Our PSI protocol requires the receiver to interpolate a polynomial over \( n \) points, and the sender to evaluate that polynomial on \( n \) points, where \( n \) is the size of their sets (e.g., \( n = 1M \)). Each of these procedures costs \( O(n \log^2 n) \) field operations.

  One way to reduce the cost of this step is to encode the same information in a different way. The purpose of \( P \) is to convey mappings of the form \( y_i \mapsto f_i \) in a way that hides the \( y_i \) values. Concurrent to this work, Garimella et al. [23] introduced oblivious key-value stores (OKVS), which are an abstraction that provides the properties that our protocol requires. They present an efficient OKVS alternative to polynomials that has linear encoding time, but at a small (\(\sim 35\%\)) increase in communication size. This data structure can be used in our protocol to replace polynomials, however:
    1. Polynomial interpolation over small (degree < 1000) polynomials is a very small contribution to the protocol’s overall cost (even using a simpler quadratic algorithm) compared to the cost of elliptic curve exponentiations.
    2. Even a 35% increase in size significantly undermines our protocol’s contribution of minimal communication cost.

### C. Polynomial Overfitting

Recall the polynomial overfitting game \( \text{PolyOverfit}_{n, n'}(q) \):

- Sample \( \alpha_1, \ldots, \alpha_q \leftarrow F \)
- Sample \( \beta_1, \ldots, \beta_q \leftarrow F \)
- Give \(\{\alpha_1, \ldots, \alpha_q\}\) and \(\{\beta_1, \ldots, \beta_q\}\) to \( A \)
- \( A \) outputs a polynomial \( P \)
- If \( 0 < \deg(P) < n \) and \( P(\alpha_i) \in \{\beta_1, \ldots, \beta_q\} \) for at least \( n' \) distinct \( \alpha_i \):
  - \( A \) wins the game
- Else \( A \) loses the game

We prove an unconditional bound for winning this game, based on a compression argument.

#### Proposition C.1
Let \( E: A \to B \) and \( D: B \to A \) be functions. Then \( \Pr_{a \leftarrow A}[D(E(a)) = a] \leq |B| / |A| \).

**Proof:**
If \( a \notin \text{range}(D) \), then we can never have \( D(E(a)) = a \). Furthermore, \( |\text{range}(D)| \leq |B| \).
\(\blacksquare\)

#### Lemma C.2
The probability of any (computationally unbounded) adversary winning \( \text{PolyOverfit}_{n, n'}(q) \) is at most:
\[
\frac{(q^2 n)^{n'}}{|F|^{n' - n}}
\]

**Proof:**
Assume that the quantity in parentheses is less than 1, since if it is not, then the probability bound in the statement of the lemma exceeds 1 and is therefore trivial. When \( A \) wins the game, then \( e \geq n' \) and the number of encodings is bounded by:
\[
|F|^{2q + n} \cdot \left( \frac{q^2 n}{|F|} \right)^{n'}
\]
\(\blacksquare\)