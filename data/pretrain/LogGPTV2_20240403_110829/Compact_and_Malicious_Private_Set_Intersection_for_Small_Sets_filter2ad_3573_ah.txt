In Phong Q. Nguyen and David Pointcheval, editors,
PKC 2010, volume 6056 of LNCS, pages 312â€“331. Springer, Heidelberg, May 2010.
[27] Alexander Heinrich, Matthias Hollick, Thomas Schneider, Milan Stute, and Chris-
tian Weinert. Privatedrop: Practical privacy-preserving authentication for apple
airdrop. In 30th {USENIX} Security Symposium ({USENIX} Security 21), 2021.
[28] Yan Huang, David Evans, and Jonathan Katz. Private set intersection: Are gar-
bled circuits better than custom protocols? In NDSS 2012. The Internet Society,
February 2012.
[29] Bernardo A. Huberman, Matt Franklin, and Tad Hogg. Enhancing privacy and
trust in electronic communities. In ACM CONFERENCE ON ELECTRONIC COM-
MERCE. ACM, 1999.
[30] Mihaela Ion, Ben Kreuter, Ahmet Erhan Nergiz, Sarvar Patel, Mariana Raykova,
Shobhit Saxena, Karn Seth, David Shanahan, and Moti Yung. On deploying
secure computing commercially: Private intersection-sum protocols and their
business applications. Cryptology ePrint Archive, Report 2019/723, 2019. https:
//eprint.iacr.org/2019/723.
[31] Mihaela Ion, Ben Kreuter, Erhan Nergiz, Sarvar Patel, Shobhit Saxena, Karn
Seth, David Shanahan, and Moti Yung. Private intersection-sum protocol with
applications to attributing aggregate ad conversions. Cryptology ePrint Archive,
Report 2017/738, 2017. https://eprint.iacr.org/2017/738.
[32] Yuval Ishai, Joe Kilian, Kobbi Nissim, and Erez Petrank. Extending oblivious
transfers efficiently. In Dan Boneh, editor, CRYPTO 2003, volume 2729 of LNCS,
pages 145â€“161. Springer, Heidelberg, August 2003.
[33] Stanislaw Jarecki and Xiaomin Liu. Efficient oblivious pseudorandom function
with applications to adaptive OT and secure computation of set intersection. In
Omer Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 577â€“594. Springer,
Heidelberg, March 2009.
[34] Stanislaw Jarecki and Xiaomin Liu. Fast secure computation of set intersection.
In Juan A. Garay and Roberto De Prisco, editors, SCN 10, volume 6280 of LNCS,
pages 418â€“435. Springer, Heidelberg, September 2010.
[35] Lea Kissner and Dawn Xiaodong Song. Privacy-preserving set operations. In
Victor Shoup, editor, CRYPTO 2005, volume 3621 of LNCS, pages 241â€“257. Springer,
Heidelberg, August 2005.
[36] Vladimir Kolesnikov, Ranjit Kumaresan, Mike Rosulek, and Ni Trieu. Efficient
batched oblivious PRF with applications to private set intersection. In Edgar R.
Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai
Halevi, editors, ACM CCS 2016, pages 818â€“829. ACM Press, October 2016.
[37] Mark Manulis, Benny Pinkas, and Bertram Poettering. Privacy-preserving group
discovery with linear complexity. In Jianying Zhou and Moti Yung, editors, ACNS
10, volume 6123 of LNCS, pages 420â€“437. Springer, Heidelberg, June 2010.
[38] Daniel Masny and Peter Rindal. Endemic oblivious transfer. In Lorenzo Cavallaro,
Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019,
pages 309â€“326. ACM Press, November 2019.
[39] C. Meadows. A more efficient cryptographic matchmaking protocol for use in
the absence of a continuously available third party. In 1986 IEEE Symposium on
Security and Privacy, pages 134â€“134, April 1986.
[40] Ghita Mezzour, Adrian Perrig, Virgil D. Gligor, and Panos Papadimitratos. Privacy-
preserving relationship path discovery in social networks. In Juan A. Garay,
Atsuko Miyaji, and Akira Otsuka, editors, CANS 09, volume 5888 of LNCS, pages
189â€“208. Springer, Heidelberg, December 2009.
[41] R. Moenck and Allan Borodin. Fast modular transforms via division. In Switching
and Automata Theory, pages 90â€“96, 1972.
[42] Benny Pinkas, Mike Rosulek, Ni Trieu, and Avishay Yanai. SpOT-light: Light-
weight private set intersection from sparse OT extension. In Alexandra Boldyreva
and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS,
pages 401â€“431. Springer, Heidelberg, August 2019.
[43] Benny Pinkas, Mike Rosulek, Ni Trieu, and Avishay Yanai. PSI from PaXoS:
In Anne Canteaut and Yuval Ishai,
Fast, malicious private set intersection.
editors, EUROCRYPT 2020, Part II, volume 12106 of LNCS, pages 739â€“767. Springer,
Heidelberg, May 2020.
[44] Benny Pinkas, Thomas Schneider, Gil Segev, and Michael Zohner. Phasing:
Private set intersection using permutation-based hashing. In Jaeyeon Jung and
Thorsten Holz, editors, 24th USENIX Security Symposium, USENIX Security 15,
Washington, D.C., USA, August 12-14, 2015., pages 515â€“530. USENIX Association,
2015.
[45] Benny Pinkas, Thomas Schneider, and Michael Zohner. Faster private set inter-
section based on OT extension. In Kevin Fu and Jaeyeon Jung, editors, Proceedings
of the 23rd USENIX Security Symposium, San Diego, CA, USA, August 20-22, 2014.,
pages 797â€“812. USENIX Association, 2014.
[46] Peter Rindal and Mike Rosulek. Improved private set intersection against ma-
licious adversaries. In Jean-SÃ©bastien Coron and Jesper Buus Nielsen, editors,
EUROCRYPT 2017, Part I, volume 10210 of LNCS, pages 235â€“259. Springer, Hei-
delberg, April / May 2017.
[47] Peter Rindal and Mike Rosulek. Malicious-secure private set intersection via dual
execution. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan
Xu, editors, ACM CCS 2017, pages 1229â€“1242. ACM Press, October / November
2017.
[48] Peter Rindal and Phillipp Schoppmann. Vole-psi: Fast oprf and circuit-psi from
vector-ole. Cryptology ePrint Archive, Report 2021/266, 2021. https://eprint.iacr.
org/2021/266.
A SEMI-HONEST VARIANT
In this section we show a simpler semi-honest variant of our proto-
col.
The details of the protocol are given in Figure 5. The correctness
of the protocol boils down to the following observations:
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1179Compact and Malicious Private Set Intersection for Small Sets
CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Parameters: finite field F
KA protocol KA with KA.M = F and |KA.K| â‰¥ 2ğœ†+2 log ğ‘›
ideal permutation Î , Î âˆ’1 : F â†’ F
Sender
input ğ‘‹ = {ğ‘¥1, . . . , ğ‘¥ğ‘›} âŠ† F
Receiver
input ğ‘Œ = {ğ‘¦1, . . . , ğ‘¦ğ‘›} âŠ† F
1. ğ‘ â† KA.R
2. ğ‘š = KA.msg1(ğ‘)
3.
4.
ğ‘š
ğ‘ƒ
5. for ğ‘– âˆˆ [ğ‘›]:
ğ‘˜ğ‘– = KA.key1(ğ‘, Î (ğ‘ƒ(ğ‘¥ğ‘–)))
6. ğ¾ = {ğ‘˜1, . . . , ğ‘˜ğ‘›} (shuffled)
ğ¾
7.
for ğ‘– âˆˆ [ğ‘›]:
ğ‘ğ‘– â† KA.R
ğ‘šâ€²
ğ‘– = KA.msg2(ğ‘ğ‘–, ğ‘š)
ğ‘“ğ‘– = Î âˆ’1(ğ‘šâ€²
ğ‘–)
ğ‘ƒ = interpolF
(cid:16){(ğ‘¦ğ‘–, ğ‘“ğ‘–) | ğ‘¦ğ‘– âˆˆ ğ‘Œ}(cid:17)
output {ğ‘¦ğ‘– | KA.key2(ğ‘ğ‘–, ğ‘š) âˆˆ ğ¾}
Figure 5: Semi-honest variant of our protocol.
â€¢ Suppose ğ‘¥ğ‘– = ğ‘¦ ğ‘— for some ğ‘–, ğ‘— (i.e., ğ‘¥ğ‘– is an item of the sender that
is in the intersection). Then by construction we have:
KA.key1(ğ‘, Î (ğ‘ƒ(ğ‘¥ğ‘–))) = KA.key1(ğ‘, Î (ğ‘“ğ‘—))
= KA.key1(ğ‘, ğ‘šâ€²
ğ‘—)
= KA.key1(ğ‘, KA.msg2(ğ‘ ğ‘— , ğ‘š))
By the correctness of the KA protocol, this is equal to KA.key2(ğ‘ ğ‘— , ğ‘š),
and the receiver will indeed include ğ‘¦ ğ‘— (= ğ‘¥ğ‘–) in the output.
â€¢ Suppose ğ‘¥ğ‘– âˆ‰ ğ‘Œ. In this case, our security proof will argue that
the corresponding ğ‘˜ğ‘– value (computed by the sender) is pseudo-
random. The receiver only produces incorrect output if this ğ‘˜ğ‘–
happens to match one of the KA.key2(ğ‘ ğ‘— , ğ‘š) values computed
by the receiver. For this particular ğ‘˜ğ‘–, this event happens with
probability (negligibly close to) ğ‘›/|KA.K|. With a union bound
over at most ğ‘› such ğ‘˜ğ‘– values, the overall probability of incorrect
output is at most (negligibly close to) ğ‘›2/|KA.K|.
To limit the correctness error to a concrete value 2âˆ’ğœ† (for example,
ğœ† = 40 in our implementation), it suffices to use a KA protocol with
|KA.K| â‰¥ 2ğœ†+2 log ğ‘›.
Lemma A.1. The protocol of Figure 5 is secure against a semi-
honest sender, if KA is a pseudorandom-message KA (Definition 3.4)
and Î Â± is an ideal permutation.
Proof. Since the only protocol message from the receiver is ğ‘ƒ,
it suffices to show how to simulate ğ‘ƒ. In fact, we simply show that ğ‘ƒ
is indistinguishable from a polynomial of appropriate degree with
coefficients chosen uniformly in F.
ğ‘– = KA.msg2(ğ‘ğ‘–, ğ‘š)â€ in
step 3 with â€œğ‘šâ€²
ğ‘– â† KA.M (= F)â€. This change is indistinguishable
to the sender by the pseudorandom-message property of KA. Then,
First, consider replacing â€œğ‘ğ‘– â† KA.R; ğ‘šâ€²
since Î  is a permutation, we see that ğ‘“ğ‘– becomes uniformly dis-
tributed on F. Finally, interpolating a polynomial on a set of points
{(ğ‘¦ğ‘–, ğ‘“ğ‘–)}, where each ğ‘“ğ‘– is uniform in F, results in a uniformly
chosen polynomial, independent of the ğ‘¦ğ‘– values.
â–¡
Lemma A.2. The protocol of Figure 5 is secure against a semi-
honest receiver, if KA is a secure KA (Definition 3.2) and Î Â± is an ideal
permutation.
Proof. First, we discuss the intuition of the proof. For each
ğ‘¥ğ‘– âˆˆ ğ‘‹, the sender interprets Î (ğ‘ƒ(ğ‘¥ğ‘–)) as a KA protocol message.
When ğ‘¥ğ‘– âˆˆ ğ‘‹ \ ğ‘Œ, the receiver never actively chooses the value at
ğ‘ƒ(ğ‘¥ğ‘–), and so presumably does not know the secret randomness
of the KA message Î (ğ‘ƒ(ğ‘¥ğ‘–)). From the receiverâ€™s perspective, this
is just like watching a KA instance between two external parties,
so the resulting key ğ‘˜ğ‘– should look random. We can formalize this
by having the simulator program Î (ğ‘ƒ(ğ‘¥ğ‘–)) to be a KA protocol
message whose underlying randomness is explicitly unknown to
the receiver.
More formally, define Hybrid #â„ as follows (taking ğ‘‹ and ğ‘Œ both
as inputs):
â€¢ Steps 1-2: same as honest sender.
â€¢ Step 5:
â€“ for ğ‘¥ğ‘– âˆˆ (ğ‘‹âˆ©ğ‘Œ)âˆª{ğ‘¥ğ‘– | ğ‘– â‰¥ â„}: compute ğ‘˜ğ‘– = KA.key1(ğ‘, Î (ğ‘ƒ(ğ‘¥ğ‘–))).
â€“ for all other ğ‘¥ğ‘– âˆˆ ğ‘‹, choose ğ‘˜ğ‘– â† KA.K.
â€¢ Step 6: set ğ¾ = {ğ‘˜1, . . . , ğ‘˜ğ‘›}, shuffled.
Clearly Hybrid #0 corresponds to the real interaction. Furthermore,
Hybrid #ğ‘› describes a valid simulation. Even though formally Hy-
brid #ğ‘› gets the honest senderâ€™s input ğ‘‹ as input, it does not need
to know any values in ğ‘‹ \ ğ‘Œ (only how many of them exist). Hence
Hybrid #ğ‘›â€™s behavior can be carried out given only ğ‘Œ, ğ‘‹ âˆ© ğ‘Œ, and
|ğ‘‹|.
Now define the following reduction algorithm ğ´(â„, ğ‘š1, ğ‘š2, ğ‘˜âˆ—, ğ‘‹, ğ‘Œ):
â€¢ Initially, use the receiverâ€™s honest behavior to anticipate what
ğ‘ƒ will be, playing the role of Î Â± honestly. If ğ‘¥â„ âˆ‰ ğ‘‹ âˆ© ğ‘Œ then
program Î Â± so that Î (ğ‘ƒ(ğ‘¥â„)) = ğ‘š2.2
â€¢ Steps 1-2: same as honest sender.
â€¢ Step 5:
â€“ for ğ‘¥ğ‘– âˆˆ (ğ‘‹âˆ©ğ‘Œ)âˆª{ğ‘¥ğ‘– | ğ‘– > â„}: compute ğ‘˜ğ‘– = KA.key1(ğ‘, Î (ğ‘ƒ(ğ‘¥ğ‘–))).
â€“ if ğ‘¥â„ âˆ‰ ğ‘‹ âˆ© ğ‘Œ, hence not handled by the previous case, set
ğ‘˜â„ = ğ‘˜âˆ—.
â€“ for all other ğ‘¥ğ‘– âˆˆ ğ‘‹, choose ğ‘˜ğ‘– â† KA.K.
â€¢ Step 6: set ğ¾ = {ğ‘˜1, . . . , ğ‘˜ğ‘›}, shuffled.
Observe that if ğ‘˜âˆ— is the key resulting from KA conversation (ğ‘š1, ğ‘š2),
then ğ´(â„, ğ‘š1, ğ‘š2, ğ‘˜âˆ—, ğ‘‹, ğ‘Œ) generates exactly Hybrid #â„. But if ğ‘˜âˆ— is
uniform and independent of (ğ‘š1, ğ‘š2), then ğ´(â„, ğ‘š1, ğ‘š2, ğ‘˜âˆ—, ğ‘‹, ğ‘Œ)
generates exactly Hybrid #(â„ + 1). These two cases are indistin-
guishable by the standard real-vs-random security property of KA.
Hence, Hybrids #â„ and #(â„ + 1) are indistinguishable.
â–¡
2Technically speaking, this step can fail if Î âˆ’1 was already defined on ğ‘š2 while
the simulator was predicting how the sender computes ğ‘ƒ. This case happens with
negligible probability since only a negligible fraction of Î Â± is ever defined, and ğ‘š2
messages are pseudorandom.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1180CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Mike Rosulek and Ni Trieu
Proof. Let A be an adversary that wins the game with proba-
bility ğœ–. Using A we can compress a list (ğ›¼1, . . . , ğ›¼ğ‘, ğ›½1, . . . , ğ›½ğ‘) by
giving the following information (in this order):
â€¢ the output polynomial ğ‘ƒ â† A(ğ›¼1, . . . , ğ›¼1, ğ›½1, . . . , ğ›½ğ‘)
â€¢ a bipartite graph ğº with left and right vertex sets [ğ‘], left-degree
1, and an edge from left vertex ğ‘– to right vertex ğ‘— if ğ‘ƒ(ğ›¼ğ‘–) = ğ›½ ğ‘—
â€¢ for every connected component in ğº (in some canonical order):
â€“ If the component is a singleton right vertex ğ‘–, give ğ›½ğ‘–
â€“ If the component contains a left vertex, let ğ‘– be the lowest
numbered left vertex in the component, and give ğ›¼ğ‘–. Then
for every left vertex ğ‘– except the lowest numbered one, give
an index ğ‘£ such that ğ›¼ğ‘– is the ğ‘£th root of ğ‘ƒ(Â·) âˆ’ ğ‘ƒ(ğ›¼ğ‘–) in
lexicographic order.
Recovering the ğ›¼ğ‘– and ğ›½ğ‘– inputs from this information amounts to
labeling each vertex in ğº with the appropriate ğ›¼ğ‘– or ğ›½ ğ‘—, which can
be done in a straight-forward way.
Note that the graph ğº has 2ğ‘ vertices, and if it has ğ‘’ edges then
it has ğ‘ = 2ğ‘ âˆ’ ğ‘’ connected components. The number of possible
â€œcompressed encodingsâ€ is at most the product of the following
terms:
â€¢ |F|ğ‘›, for the number of polynomials ğ‘ƒ
â€¢ (ğ‘2)ğ‘’, for (an upper bound on) the number of bipartite graphs
â€¢ |F|ğ‘, for listing one ğ›¼ğ‘– or ğ›½ ğ‘— per component
â€¢ ğ‘›ğ‘’, for the other information in each connected component â€”
there are at most ğ‘’ left vertices in nontrivial connected compo-
nents, and each index ğ‘£ names one of the ğ‘› roots of a deg < ğ‘›
polynomial.
with ğ‘ + ğ‘ vertices and ğ‘’ edges.
Hence, the number of such encodings is bounded by:
(cid:18) ğ‘2ğ‘›
(cid:19)ğ‘’
|F|
Yet the number of inputs to this compression algorithm is |F|2ğ‘.
Hence the compression cannot succeed with probability better than
the ratio of inputs to outputs:
|F|2ğ‘+ğ‘›âˆ’ğ‘›â€² Â· ğ‘2ğ‘›â€² Â· ğ‘›ğ‘›â€²
|F|2ğ‘
(ğ‘2ğ‘›)ğ‘›â€²
|F|ğ‘›â€²âˆ’ğ‘›
=
â–¡
|F|ğ‘› Â· ğ‘2ğ‘’ Â· |F|2ğ‘âˆ’ğ‘’ Â· ğ‘›ğ‘’ = |F|2ğ‘+ğ‘› Â·
Assume that the quantity in parentheses is less than 1, since if it
is not then the probability bound in the statement of the lemma
exceeds 1 and is therefore trivial. When A wins the game, then
ğ‘’ â‰¥ ğ‘›â€² and the number of encodings is bounded by:
(cid:18) ğ‘2ğ‘›
(cid:19)ğ‘›â€²
|F|
|F|2ğ‘+ğ‘› Â·
B OPTIMIZATIONS
For all of these optimizations, we leave it as an exercise for the
reader to verify that the security proofs hold when using the opti-
mizations.
Elligator. Our protocol requires a KA protocol whose second
message is pseudorandom, since only the second KA message is
encoded into a polynomial. Elligator-DHKA requires parties to
re-sample randomness until they â€œhitâ€ the elligator subset of the
elliptic curve. Only the receiver needs to do this in our PSI protocol;
the sender does not need to use elligator encodings for their KA
message.
Alternatives to Polynomials. Our PSI protocol requires the re-
ceiver to interpolate a polynomial over ğ‘› points, and the sender to
evaluate that polynomial on ğ‘› points, where ğ‘› is the size of their
sets (e.g., ğ‘› = 1M). Each of these procedures cost ğ‘‚(ğ‘› log2 ğ‘›) field
operations.
One way to reduce the cost of this step is to encode the same infor-
mation in a different way. The purpose of ğ‘ƒ is to convey mappings
of the form ğ‘¦ğ‘– â†¦â†’ ğ‘“ğ‘– in a way that hides the ğ‘¦ğ‘– values. Concurrent to
this work, Garimella et al. [23] introduced oblivious key-value stores
(OKVS), which are an abstraction that provides the properties that
our protocol requires. They present an efficient OKVS alternative
to polynomials that has linear encoding time, but at a small (âˆ¼35%)
increase in communication size. This data structure can be used
in our protocol to replace polynomials, however: (1) Polynomial
interpolation over small (degree < 1000) polynomials is a very small
contribution to the protocolâ€™s overall cost (even using a simpler
quadratic algorithm) compared to the cost of elliptic curve exponen-
tiations. (2) Even a 35% increase in size significantly undermines
our protocolâ€™s contribution of minimal communication cost.
F
(ğ‘):
C POLYNOMIAL OVERFITTING
Recall the polynomial overfitting game PolyOverfitğ‘›,ğ‘›â€²
sample ğ›¼1, . . . , ğ›¼ğ‘ â† F
sample ğ›½, . . . , ğ›½ğ‘ â† F
give {ğ›¼1, . . . , ğ›¼ğ‘} and {ğ›½1, . . . , ğ›½ğ‘} to A
A outputs a polynomial ğ‘ƒ
if 0 < deg(ğ‘ƒ) < ğ‘› and ğ‘ƒ(ğ›¼ğ‘–) âˆˆ {ğ›½1, . . . , ğ›½ğ‘} for at least ğ‘›â€² distinct ğ›¼ğ‘–:
A wins the game
else A loses the game
We prove an unconditional bound for winning this game, based
on a compression argument.
Proposition C.1. Let ğ¸ : ğ´ â†’ ğµ and ğ· : ğµ â†’ ğ´ be functions.
Then Prğ‘â†ğ´[ğ·(ğ¸(ğ‘)) = ğ‘] â‰¤ |ğµ|/|ğ´|.
Proof. If ğ‘ âˆ‰ range(ğ·), then we can never have ğ·(ğ¸(ğ‘)) = ğ‘.
â–¡
Furthermore, |range(ğ·)| â‰¤ |ğµ|.
Lemma C.2. The probability of any (computationally unbounded)
adversary winning PolyOverfitğ‘›,ğ‘›â€²
(ğ‘) is at most
F
(ğ‘2ğ‘›)ğ‘›â€²/|F|ğ‘›â€²âˆ’ğ‘›
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1181