0
TABLE V: Details of driver initialization process
communicate with the hardware. The third, is an example of
how we used our framework to show that CVE-2014-9783 is,
in fact, a false positive and cannot really be triggered, even
on a device.
CVE-2014-9786. According to the CVE, this vulnerability
affects the camera actuator sensor driver in Google Nexus 5
and 7 devices. The vulnerability happens in an IOCTL used to
conﬁgure the sensor; triggering it requires issuing two IOCTLs
in a sequence. The ﬁrst IOCTL is used to allocate an array
of a user-deﬁned size. Inside the second IOCTL this array is
parsed inside a loop whose upper bound can be controlled by
the attacker. This is a challenging stress test for our system
since reaching vulnerable code requires the driver to stay in a
consistent state between the two IOCTLs.
CVE-2014-9785. This vulnerability happens in qseecom.ko
driver which enables communication between the Linux kernel
and QSEE, Qualcomm’s TrustZone implementation, which is
present on a wide variety of Android devices. The driver works
by issuing a Secure Monitor Call to request services inside
QSEE, and thus its functionality depends on TrustZone re-
turning speciﬁc values. Dependencies on speciﬁc functionality
that cannot be evaded without detailed information about the
hardware is what prevents three other qseecom.ko CVEs
from being triggered: in order for the driver to reach vulnerable
code QSEE needs to return a correct version number. However,
even though execution in this driver depends on the hardware
most of the time, this particular vulnerability could be executed
and reached in our evasion kernel. The vulnerability is due to
the use of __copy_from_user() function that does not
verify the pointer provided by the userspace.
CVE-2014-9783. Finally we consider a CVE describing a bug
in a camera control interface driver, msm_cci.ko. We could
not cause a crash in our evasion kernel and at ﬁrst decided that
it was due to our framework. However after additional manual
analysis, we found that the bug can not be in fact be triggered
on a real device either. According to the CVE, the bug is due
to unchecked “size” ﬁeld which in theory should cause an
out of bound memory access. However msm_cci.ko gets the
user-provided data from the v4l2 subsystem which passes only
the number of bytes as encoded by the ﬁrst, cmd, argument.
We found that there was another bug in the deﬁnition of
the cmd argument. As a result instead of copying the whole
second argument, only 4 bytes (a 32-bit pointer) were copied
from the userspace to the kernel space by the v4l2 subsystem.
This prevents the malicious payload (“size” ﬁeld) from ever
reaching the IOCTL code.
FIVE KNOWN BUT UNREPORTED BUGS IN THE MSM
APPENDIX E
KERNEL
In our experiments, we used 5 bugs that were ﬁxed in the
MSM kernel but not reported as CVE’s. We describe these
bugs in more detail in this section.
actuator-crash-1. This bug affects the camera actuator sensor
driver, msm_acutuator.ko, and is due to an attacker-
controlled upper bound of a loop. The vulnerable code we
analyzed pertains to the MSM kernel commit 212da48
and ioctl cmd VIDIOC_MSM_ACTUATOR_CFG. In more
# Module
Init
Probe
avtimer.ko
adsprpc.ko
vidc venc.ko
1
2 msm rotator.ko
3
4 msm adc.ko
5 msm serial hs.ko
6
7 msm led ﬂash.ko
8 msm.ko
9 msm gemini.ko
10 msm jpeg.ko
11 msm ispif.ko
12 msm cpp.ko
13 msm vpe.ko
14 msm rmnet.ko
15 msm rmnet bam.ko
16 msm rmnet sdio.ko
17 msm rmnet smux.ko
18 msm rmnet wwan.ko
19
20
21
22
23 msm actuator.ko
24 msm cci.ko
25
vidc vdec.ko
26 mdss rotator.ko
27 msm csid.ko
28 msm isp.ko
29 msm csiphy.ko
30
qfec.ko
dwc3-msm.ko
qseecom.ko
diagchar.ko
iris-radio.ko

















∓∓∓
∓∓∓













n/a

×××
n/a






∓∓∓
n/a
n/a
n/a

n/a
–


n/a








“dev”
ﬁle




–







–




–
–
–










Open


∓∓∓

–



S
S

∓∓∓
–


∓∓∓
∓∓∓
–
–
–










TABLE VI: Loading phase evaluation. – step succeeded;
∓∓∓ – function returned a negative error code; ××× – function
crashed; ’−−−’ – step failed due to errors at previous steps; n/a –
functionality not present; – ioctl analysis failed; S – surrogate
module was used.
the
bug
also
sensor
driver,
affects
can be
sometimes
such bugs
msm_acutuator.ko,
detail, structure a_ctrl->region_params is copied from
userspace in Listing 5, line 3. Later, step_bound ﬁeld of
this structure is used as a loop upper bound (lines 11 and 12)
with a crash at line 14.
actuator-crash-2. This
camera
and
actuator
caused by an uninitialized function pointer. Note
is
that
exploited to get
arbitrary code execution [13]. The vulnerable code we
analyzed pertains
commit e6edf78
and ioctl cmd VIDIOC_MSM_ACTUATOR_CFG. By
issuing
fuzzing this driver we immediately found that
the
in
to crash. This is due to
Listing 6 causes the kernel
a_ctrl->func_tbl in line 10 not being initialized
without ﬁrst
issuing the CFG_SET_ACTUATOR_INFO
subcommand in line 6.
diag-crash-1. This bug pertains to diagchar.ko, commit
1414d4a. This bug requires ﬁrst to issue two ioctl system
calls in sequence: DIAG_IOCTL_SWITCH_LOGGING and
DIAG_IOCTL_COMMAND_REG to switch the driver state; and
CFG_SET_DEFAULT_FOCUS
to MSM kernel
subcommand
1
2
3
4
5
6
7
8
9
10
11
12
13
14
static int32_t msm_actuator_init(...) {
...
if (copy_from_user(&a_ctrl->region_params, (
void *)set_info->af_tuning_params.
region_params, a_ctrl->region_size *
sizeof(struct region_params_t)))
return -EFAULT;
...
}
...
static int32_t msm_actuator_init_step_table(
struct msm_actuator_ctrl_t *a_ctrl,...)
{
...
step_boundary = a_ctrl->region_params[
region_index].step_bound[MOVE_NEAR];
for (; step_index step_position_table[step_index] =
cur_code;{
}
...
15
16
Listing 5: Bug 1 in msm_actuator.ko, commit
212da48
1
2
3
4
5
6
7
8
9
10
static int32_t msm_actuator_config(...)
{
...
switch (cdata.cfgtype) {
case CFG_SET_ACTUATOR_INFO:
rc = msm_actuator_init(a_ctrl, &cdata.cfg.
set_info);
...
case CFG_SET_DEFAULT_FOCUS:
rc = a_ctrl->func_tbl->
actuator_set_default_focus(a_ctrl, &
cdata.cfg.move);
...
11
Listing 6: Bug 2 in msm_actuator.ko, commit
e6edf78
then a write system call to trigger a crash. The reason for the
crash is a missing check for the lenght ﬁeld (see lines 4 and
6 in Listing 7).
diag-crash-2. This bug pertains to diagchar.ko, com-
mit 1414d4a. The bug is due to copying a user pointer
directly instead of using copy_from_user function in
DIAG_IOCTL_COMMAND_REG ioctl.
isp-crash-1.
happens
msm_isp.ko
driver,
in
bug
83789a7935f9.
VIDIOC_MSM_VFE_REG_CFG ioctl which is used to
write data to the peripheral using writeb_relaxed in
which the attacker controls both the data written and the
offset from the start of the control register. The driver does
not check this offset which leads to arbitrary memory write
primitive.
in
The
commit
This
bug
is
1
2
3
4
5
6
7
8
9
int diag_send_dci_pkt(struct diag_master_table
entry, unsigned char *buf, int len, int
index)
{
...
len = len - 4;
...
for (i = 0; i apps_dci_buf[i+9] = *(buf+i);
...
}
Listing 7: Bug 1 in diagchar.ko, commit 1414d4a
LIST OF DEFCONFIGS FOR AUTOMATIC RECOVERY
APPENDIX F
In this appendix, we list the eight layouts with default
conﬁgurations that were used to test our structure layout
recovery component.
msm7627a_defconfig
8226_defconfig, 8610_defconfig, 8960_defconfig
8660_defconfig
8974_defconfig
9615_defconfig, 9625_defconfig
All struct device options enabled
All struct device options disabled
PM_RUNTIME disabled but DEBUG_SPINLOCK enabled