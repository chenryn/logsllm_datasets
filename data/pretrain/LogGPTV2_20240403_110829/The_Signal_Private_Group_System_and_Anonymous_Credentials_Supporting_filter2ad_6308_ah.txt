1–11. Springer, Heidelberg, May / June 2006.
42
[CHK+11]
Jan Camenisch, Kristiyan Haralambiev, Markulf Kohlweiss, Jorn Lapon, and
Vincent Naessens. Structure preserving CCA secure encryption and applica-
tions.
In Dong Hoon Lee and Xiaoyun Wang, editors, ASIACRYPT 2011,
volume 7073 of LNCS, pages 89–106. Springer, Heidelberg, December 2011.
[CL03]
[CL04]
Jan Camenisch and Anna Lysyanskaya. A signature scheme with eﬃcient
protocols.
In Stelvio Cimato, Clemente Galdi, and Giuseppe Persiano, ed-
itors, SCN 02, volume 2576 of LNCS, pages 268–289. Springer, Heidelberg,
September 2003.
Jan Camenisch and Anna Lysyanskaya. Signature schemes and anonymous
credentials from bilinear maps. In Matthew Franklin, editor, CRYPTO 2004,
volume 3152 of LNCS, pages 56–72. Springer, Heidelberg, August 2004.
[CMZ14] Melissa Chase, Sarah Meiklejohn, and Greg Zaverucha. Algebraic MACs and
keyed-veriﬁcation anonymous credentials. In Gail-Joon Ahn, Moti Yung, and
Ninghui Li, editors, ACM CCS 2014, pages 1205–1216. ACM Press, November
2014.
[CPZ19]
Melissa Chase, Trevor Perrin, and Greg Zaverucha. The Signal private group
system and anonymous credentials supporting eﬃcient veriﬁable encryption.
Cryptology ePrint Archive, Report 2019/1416, 2019. https://eprint.iacr.
org/2019/1416.
[CS97]
[CS03]
[Cv91]
[CV02]
J. Camenisch and M. Stadler. Proof systems for general statements about
discrete logarithms. Technical Report TR 260, Institute for Theoretical Com-
puter Science, ETH Z¨urich, 1997.
Jan Camenisch and Victor Shoup. Practical veriﬁable encryption and decryp-
tion of discrete logarithms.
In Dan Boneh, editor, CRYPTO 2003, volume
2729 of LNCS, pages 126–144. Springer, Heidelberg, August 2003.
David Chaum and Eug`ene van Heyst. Group signatures. In Donald W. Davies,
editor, EUROCRYPT’91, volume 547 of LNCS, pages 257–265. Springer, Hei-
delberg, April 1991.
Jan Camenisch and Els Van Herreweghen. Design and implementation of the
idemix anonymous credential system. In Vijayalakshmi Atluri, editor, ACM
CCS 2002, pages 21–30. ACM Press, November 2002.
[DKPW12] Yevgeniy Dodis, Eike Kiltz, Krzysztof Pietrzak, and Daniel Wichs. Message
authentication, revisited. In David Pointcheval and Thomas Johansson, ed-
itors, EUROCRYPT 2012, volume 7237 of LNCS, pages 355–374. Springer,
Heidelberg, April 2012.
43
[FS87]
[GM17]
[Hal17]
Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions
to identiﬁcation and signature problems.
In Andrew M. Odlyzko, editor,
CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, Au-
gust 1987.
Matthew Green and Ian Miers. Bolt: Anonymous payment channels for decen-
tralized currencies. In Bhavani M. Thuraisingham, David Evans, Tal Malkin,
and Dongyan Xu, editors, ACM CCS 2017, pages 473–489. ACM Press, Oc-
tober / November 2017.
Harry Halpin. NEXTLEAP: decentralizing identity with privacy for secure
messaging. In Proceedings of the 12th International Conference on Availability,
Reliability and Security (ARES’17),, pages 92:1–92:10. ACM, 2017.
[HdVLA19] Mike Hamburg, Henry de Valence, Isis Lovecruft, and Tony Arcieri. The
Ristretto group, 2019. https://ristretto.group/.
[IHD16]
[JY09]
[KBC97]
[LdV17]
[Lun17]
[Mar14]
Marios Isaakidis, Harry Halpin, and George Danezis. Unlimitid: Privacy-
preserving federated identity management using algebraic macs. In Proceedings
of the 2016 ACM on Workshop on Privacy in the Electronic Society, WPES
16, page 139142, 2016.
David Jao and Kayo Yoshida. Boneh-Boyen signatures and the strong Diﬃe-
Hellman problem. In Hovav Shacham and Brent Waters, editors, PAIRING
2009, volume 5671 of LNCS, pages 1–16. Springer, Heidelberg, August 2009.
Hugo Krawczyk, Mihir Bellare, and Ran Canetti. HMAC: Keyed-hashing for
message authentication. IETF Internet Request for Comments 2104, February
1997.
Isis Agora Lovecruft and Henry de Valence. HYPHAE: Social secret sharing,
2017. https://patternsinthevoid.net/hyphae/hyphae.pdf.
Joshua Lund. Encrypted proﬁles for Signal now in public beta, September
2017. https://signal.org/blog/signal-profiles-beta/.
Moxie Marlinspike. Private group messaging, May 2014. https://signal.
org/blog/private-groups/.
[NPR99] Moni Naor, Benny Pinkas, and Omer Reingold. Distributed pseudo-random
functions and KDCs. In Jacques Stern, editor, EUROCRYPT’99, volume 1592
of LNCS, pages 327–346. Springer, Heidelberg, May 1999.
[NR95]
Moni Naor and Omer Reingold. Synthesizers and their application to the
parallel construction of pseudo-random functions. In 36th FOCS, pages 170–
181. IEEE Computer Society Press, October 1995.
44
[oST13]
[PS16]
[PZ13]
[RCE15]
[RMS17]
[RS06]
National Institute of Standards and Technology. Federal information process-
ing standards publication: Digital signature standard (DSS), July 2013. FIPS
PUB 186-4.
David Pointcheval and Olivier Sanders. Short randomizable signatures.
In
Kazue Sako, editor, CT-RSA 2016, volume 9610 of LNCS, pages 111–126.
Springer, Heidelberg, February / March 2016.
C. Paquin and G. Zaverucha. U-prove cryptographic speciﬁcation v1.1 (revi-
sion 2), 2013. Available online: www.microsoft.com/uprove.
Kai Rannenberg, Jan Camenisch, and Ahmad Sabouri (Editors). Attribute-
based credentials for trust, identity in the information society. Springer, 2015.
https://doi.org/10.1007/978-3-319-14439-9.
Paul R¨osler, Christian Mainka, and J¨org Schwenk. More is less: How
group chats weaken the security of instant messengers signal, WhatsApp,
and threema. Cryptology ePrint Archive, Report 2017/713, 2017. http:
//eprint.iacr.org/2017/713.
Phillip Rogaway and Thomas Shrimpton. Deterministic authenticated-
encryption: A provable-security treatment of the key-wrap problem. Cryp-
tology ePrint Archive, Report 2006/221, 2006. http://eprint.iacr.org/
2006/221.
[RST01]
Ronald L. Rivest, Adi Shamir, and Yael Tauman. How to leak a secret. In
Colin Boyd, editor, ASIACRYPT 2001, volume 2248 of LNCS, pages 552–565.
Springer, Heidelberg, December 2001.
[Sig19]
Signal. Technical information (speciﬁcations and software libraries), 2019.
https://www.signal.org/docs/.
[ZYHW16] Zhenfeng Zhang, Kang Yang, Xuexian Hu, and Yuchen Wang. Practical anony-
mous password authentication and TLS with anonymous client authentication.
In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C.
Myers, and Shai Halevi, editors, ACM CCS 2016, pages 1179–1191. ACM
Press, October 2016.
A Ideal Functionality for a Private Group System
In this section we give a deﬁnition of a secure private group system as an ideal functionality.
The functionality, denoted F, is a trusted party that implements the system, and interacts
with both honest and malicious users (the attacker) and either an honest or malicious
server.
45
The deﬁnition of F has two cases, depending on whether the server is honest.
Note that all (honest) protocols are initiated by a user, and their UID (denoted uid ) is
sent to F. The ideal functionality then shares information with a (potentially) malicious
server S∗, and allows S∗ to decide whether to deviate from the protocol, e.g., S∗ may reject
valid requests, or return incorrect information.
In
Fig. 2 we describe F when the server, denoted S, is honest. In this case we know that
the honest server will try to correctly manage the groups, and our main goal is to ensure
that malicious users cannot cause the server to perform an unauthorized group operation,
corrupt the state of honest groups (those which have no corrupt members), or learn about
the operations and membership of honest groups.
When the server is malicious, denoted S∗, we describe F in Fig. 3. Here there are
again two cases, depending on whether the relevant group contains a malicious user. If so,
then between the malicious user and S∗ they know all secrets (credential issuer secret keys
and group secret key) for that group, and can learn all group members and their proﬁle
keys (since the group was created), and modify the group arbitrarily. This case is rather
trivial from the perspective of a security deﬁnition, since no security is possible. The more
interesting case is when S∗ manages the state for a group where all users are honest. Here
S∗ can deviate from the protocol in many ways (e.g., delete members from a group, reject
requests to add a new user, etc.) but none of these deviations should allow, e.g., S∗ to
learn members of the group. Informally, the group should remain conﬁdential if all users
in it are honest. Some amount of integrity is possible as well, since S∗ does not know the
group key, it cannot add arbitrary users to a group.
By comparing Figs. 2 and 3 we can see how S∗ can deviate from the honest server
behavior, depending on whether the group is corrupted. S∗ can also abort a protocol at
any time, and we do not explicitly include this in our description. For groups that are
not corrupted, at any point S∗ can re-add a previous invitation in the group, or re-add a
previously removed user to the group, by ignoring the delete step in DeleteGroupMember.
When FetchGroupMembers is called for an honest group, S∗ can choose to return or omit
any of the members that have ever been in the group regardless of whether they have since
been removed with any proﬁle key they have used with that group. S∗ can also commit
to an arbitrary proﬁle key for any user, since proﬁle key commitments are stored on the
server, and could be replaced with commitments to arbitrary proﬁle keys. This operation
is modeled with the special function CommitToAdvProﬁleKey, only used by a malicious
server.
Setup and notation State in F is maintained in hash tables. Setup initializes tables
TU and TG. Table TU is a table of users in the system, a row TU [uid ] has TU [uid ].Times
a set of times at which uid can authenticate, and TU [uid ].ProﬁleKeys, a set of proﬁle
keys currently associated with uid , and TU [uid ].corrupt, a ﬂag that indicates whether uid
is a corrupt user. TG is a table of groups in the system, a row TG[gid] contains a set
of members indexed by UID {TG[gid][uid 1], . . . , TG[gid][uid n]}, each with a proﬁle key
46
TG[gid][uid ].ProﬁleKey that is currently in use, and a list of all proﬁle keys they have used
in this group, TG[gid][uid ].ProﬁleKeyHistory. Groups also have a list of all current and
past members, TG[gid].UIDHistory. The ﬂag TG[gid].corrupt indicates whether the group
contains a corrupted user. The corrupt ﬂags default to 1 (corrupted), since S∗ may create
groups without interacting with F. The function index() returns the position of an element
in a list, or ⊥ if the element is not in the list. Authentication credentials are valid for a
time period, denoted t, and when requesting credentials users may request a set of times,
denoted T .
Comments on the honest server case The function AuthAsMember is used as a
subroutine by F in other functions, and not exposed to users.
In AuthAsMember, a
user with UID uid authenticates as a member of the group with GID gid . We also deﬁne
AuthAsInvitedMember as the same except the check that the proﬁle key is not ⊥ is omitted.
The lines ensure AuthAsMember(. . . ) return an error if AuthAsMember fails (similarly
for AuthAsInvitedMember).
Honest users call CommitToProﬁleKey to register a new random proﬁle key with F.
This models the fact that honest users choose random proﬁle keys. Malicious users may
commit to (or update) an arbitrary proﬁle key using CommitToAdvProﬁleKey. The func-
tion UpdateProﬁleKey allows a user to update their own proﬁle key in a speciﬁc group, or
allows an invited member to set their proﬁle key.
A user uid , who is a member of the group gid , can add another user uid(cid:48) with Ad-
dGroupMember. Note that this will overwrite an invitation, should one exist, for uid(cid:48).
Comments on the malicious server case Note that we do not allow S∗ to add ar-
bitrary K(cid:48), to model model issuing bad proﬁle credentials, since S∗ can maintain it’s own
data structure, and behave as if K(cid:48) ∈ ProﬁleKeys.
When the user is honest, S∗ only learns that GetProﬁleCredential was called, and can
decide whether to issue the credential.
47
GetAuthCred(T ) from uid
CreateGroup(gid, K, t) from uid
if TU [uid] is not deﬁned
return Error: invalid user
Query S to ensure T valid for uid
if T is invalid for uid
return Error: invalid time(s)
Append T to TU [uid ].Times
return 1
CommitToProﬁleKey(t) from uid
if t (cid:54)∈ TU [uid ].Times
return Error: Authentication failure
if TG[gid] is deﬁned
return Error: group exists
if K (cid:54)∈ TU [uid ].ProﬁleKeys
return Error: invalid proﬁle key
if t (cid:54)∈ TU [uid ].Times
return Error: expired credential
Set TG[gid ][uid ].ProﬁleKey = K
Append K to TG[gid ][uid ].ProﬁleKeyHistory
Append uid to TG[gid ].UIDHistory
if TU [uid ].corrupt
Create new random K
Add K to TU [uid ].ProﬁleKeys
return K
GetProﬁleCredential(uid, K)
if K ∈ TU [uid].ProﬁleKeys
return 1
return 0
AuthAsMember(gid , t) from uid
if TG[gid ] not deﬁned
return Error: gid doesn’t exist
if TG[gid ][uid ].ProﬁleKey = ⊥
return Error: user invited, not added
if TG[gid ][uid ] not deﬁned
return Error: User not in group
if t (cid:54)∈ TU [uid].Times