title:User Interface Dependability through Goal-Error Prevention
author:Robert W. Reeder and
Roy A. Maxion
User Interface Dependability through Goal-Error Prevention
Robert W. Reeder and Roy A. Maxion
PI:EMAIL and PI:EMAIL
Dependable Systems Laboratory
Computer Science Department
Carnegie Mellon University
Pittsburgh, Pennsylvania 15213 / USA
Abstract
User interfaces form a critical coupling between humans
and computers. When the interface fails, the user fails, and
the mission is lost. For example, in computer security appli-
cations, human-made conﬁguration errors can expose en-
tire systems to various forms of attack.
To avoid interaction failures, a dependable user inter-
face must facilitate the speedy and accurate completion of
user tasks. Defects in the interface cause user errors (e.g.,
goal, plan, action and perception errors), which impinge on
speed and accuracy goals, and can lead to mission failure.
One source of user error is poor information represen-
tation in the interface. This can cause users to commit a
speciﬁc class of errors – goal errors. A design principle
(anchor-based subgoaling) for mitigating this cause was
formulated. The principle was evaluated in the domain of
setting Windows ﬁle permissions. The native Windows XP
ﬁle permissions interface, which did not support anchor-
based subgoaling, was compared to an alternative, called
Salmon, which did. In an experiment with 24 users, Salmon
achieved as much as a four-fold increase in accuracy for a
representative task and a 94% reduction in the number of
goal errors committed, compared to the XP interface.
1
Introduction
One locus of vulnerability in a computer system is the
user interface. Undependable interfaces are those that do
not meet their speciﬁcations in terms of the speed and ac-
curacy with which users should complete tasks. One rea-
son why some user interfaces fail to meet their speed and
accuracy speciﬁcations is human error. Researchers have
long recognized that human error has causes and manifes-
tations similar across all domains of human endeavor, from
aviation, to power plant operation, to making a cup of tea
[13, 15, 17, 21]. In the domain of software user interfaces,
human error leads people off the path of correctly complet-
ing a task and on to lengthy delays or partial or total task
failure. Thus, it is imperative for interface designers to un-
derstand the common types and causes of human error and
the ways in which they may be prevented. When interfaces
are designed to eliminate the conditions that lead humans to
make mistakes, interfaces will be more dependable.
One domain in which user interface accuracy is critically
important is computer security. Inaccurate security settings
can have a high cost – they can make sensitive data vul-
nerable, or they can leave an entire system open to attack.
Adding to this cost, security problems have what Whitten
and Tygar [20] have called the “barn door property” – once
a system has had a vulnerability for any length of time, there
may be no way to know if the vulnerability has been ex-
ploited, so the system will have to be considered compro-
mised, whether it has been or not.
The present work investigates user interface dependabil-
ity and human error in the security context of setting ﬁle
permissions under Microsoft’s Windows XP operating sys-
tem, which uses Microsoft’s NT ﬁle system (NTFS). A sig-
niﬁcant amount of anecdotal evidence suggests that setting
NTFS ﬁle permissions is a particularly error-prone task.
For example, there is the so-called “Memogate” scandal,
in which staffers from one party on the United States Sen-
ate Judiciary Committee stole conﬁdential memos from the
opposing party [19]. The memos were stored on a shared
NTFS server. The theft was possible in part because an in-
experienced system administrator had failed to set permis-
sions correctly on the shared server. As another example,
a Windows network administrator at Carnegie Mellon Uni-
versity reports that many users want to share their ﬁles so
they can access them both at work and at home; they ac-
cidentally make their private ﬁles accessible to all (several
hundred) users on the network, because it is too confusing to
set permissions as actually desired [18]. Finally, Microsoft
publishes a list of “best practices” for NTFS security that
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:40 UTC from IEEE Xplore.  Restrictions apply. 
advises users not to use several of the features of the NTFS
permissions model, such as negative (i.e., DENY) permis-
sions [10]. Use of these features “... could cause unexpected
access problems or reduce security.” Providing access to
features which are apparently problematic is bound to lead
to errors.
As these anecdotes indicate, setting and checking per-
missions cannot always be left to expert system adminis-
trators – users in many environments need or want to take
responsibility for protecting their own data. Nevertheless,
setting ﬁle permissions is not an everyday task; it may need
to be done only every few weeks or months. Thus, those
setting ﬁle permissions will often not be expert system ad-
ministrators – they will be novice or occasional users, who,
from time to time, want to restrict access to ﬁles or grant ac-
cess to a limited number of associates. They will not readily
remember arcane details about how to operate a permission-
setting interface. The present work adopts the position that
permission-setting interfaces should accommodate novice
and occasional users.
This paper reports an investigation into, and a solution
for, one type of human error encountered in permission-
setting interfaces. An existing interface for setting NTFS
permissions, the Windows XP File Permissions interface
(hereafter abbreviated XPFP), was shown to have accuracy
rates as low as 25% on permission-setting tasks. Errors
made by users of the XPFP interface were identiﬁed and
categorized into types according to an established human-
error framework. Goal errors, the failures of users to under-
stand what to do, were identiﬁed as the dominant type of
error. A primary cause of goal errors, namely a poor exter-
nal representation of the information needed to complete the
user’s root goal – a representation that is sometimes called
an anchor (for concepts held in human memory) – was iden-
tiﬁed. A design principle, anchor-based subgoaling, was
proposed to reduce goal errors, and was implemented in a
new interface, called Salmon, for setting NTFS ﬁle permis-
sions. The design principle was evaluated in a laboratory
user study comparing Salmon to XPFP. Salmon achieved
a success rate of 100% on the task on which XPFP had
achieved a 25% accuracy rate, and showed a 94% reduc-
tion in the number of goal errors users made on the same
task.
2 Problem and approach
The objective of the present work is to understand the
causes of user error in user interfaces generally, and in
XPFP in particular, and to determine what can be done to
mitigate or eliminate them. It is a further objective to ﬁnd
a design principle that can be applied to new generations of
user interfaces so that the same user errors are not encoun-
tered again and again in future user interfaces.
A visual inspection and informal use of the XPFP in-
terface revealed several instances of an interface problem.
Speciﬁcally, information that was necessary to complete
tasks accurately was hidden or was entirely missing from
the interface. Cognitive theory suggests that without ready
access to necessary information, users are likely to commit
goal errors (see Section 5.1). A solution was proposed to
reduce the occurrence of goal errors. This solution, called
anchor-based subgoaling, led to the following hypothesis:
Use of anchor-based subgoaling in user interface
design reduces the likelihood that users will com-
mit goal errors, and task accuracy rates should im-
prove when goal errors are reduced.
This hypothesis was tested by implementing an interface,
Salmon, designed in accordance with the anchor-based sub-
goaling procedure, and by conducting a laboratory user
study comparing the XPFP interface to Salmon. Task suc-
cess rates and goal-error occurrences were compared be-
tween XPFP and Salmon to determine whether anchor-
based subgoaling as implemented in Salmon was an effec-
tive means of improving successful task completion and re-
ducing goal errors.
3 Related work
File permissions are an instance of the broader area of
access control in which several authors have published re-
lated work. Those who have evaluated interfaces for setting
ﬁle access include Good and Krekelberg [7], Long et al. [9]
and Zurko et al. [24]. Zurko et al. conducted a user study
on the Visual Policy Builder, a graphical user interface for
specifying access control policies for their Adage system.
Good and Krekelberg showed that the Kazaa peer-to-peer
ﬁle-sharing service’s interface misled many users into unin-
tentionally sharing conﬁdential ﬁles. Long et al. evaluated a
preliminary, paper-based interface for limiting applications’
access to system resources. While these three interface eval-
uations were interesting in their speciﬁc task domains, none
appear to lead to any conclusion about design principles for
security interfaces in a larger context.
Other work in usable access control in various domains
includes Balfanz [2], Sampemane et al. [16], and Dewan
and Shen [5]. With the exception of the Adage project and
Long et al., work in this area involves outlining access con-
trol models, not evaluating access control interfaces, as the
present work sets out to do.
In the broader human-computer interaction and security
literature (an emerging ﬁeld known as HCISEC), those who
have proposed principles for better security interface de-
sign include Whitten and Tygar [20], Adams and Sasse [1],
Besnard and Arief [3], Zurko and Simon [25], and Yee [23].
These authors propose ideas for making security tasks eas-
ier to perform accurately, but the ideas are not evaluated
empirically, and neither do they appear to be grounded in
any theory of cognition.
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:40 UTC from IEEE Xplore.  Restrictions apply. 
The most closely related concept
in the traditional
human-computer interaction literature to anchor-based sub-
goaling is the concept of feedback. Norman deﬁnes feed-
back as “sending back to the user information about what
action has actually been done, what result has been accom-
plished [13].” Norman and Nielsen both include feedback
as an important user interface design principle [12, 13],
but neither explain how to ensure that adequate feedback
is provided. Anchor-based subgoaling includes an action-
able procedure (see Section 5.2) for ensuring that not only
feedback, but also other forms of needed information are
provided in the interface.
4 Problem in context
The problem of poor external representation can be
observed in the Windows XP ﬁle permissions interface
(XPFP). Users maintain mental models (internal represen-
tations) of tasks that may be incorrect or incomplete. In the
course of performing a task, they will update their model
with the information they perceive externally. Thus, for an
interface to be robust to inaccurate mental models, it must
provide the information users need to properly update their
mental models, and it must provide this information in a
way that users will perceive it. XPFP hides or does not show
much of the information necessary to foster understanding
of task requirements and state, while Salmon, an alternate
ﬁle permissions interface, prominently displays this infor-
mation and hence requires that only a minimal internal rep-
resentation be maintained. In order to understand what in-
formation is lacking in the XPFP interface and present in
Salmon, some background on the NTFS permissions model
is necessary, and is introduced forthwith.
A computer system using NTFS will be populated with
entities and objects. The entities are individual users and
groups of users on the system. The objects are the ﬁles
and folders on the system. NTFS deﬁnes 13 atomic permis-
sions1 that correspond to actions that users can perform on
ﬁles and folders.
The precise meanings of the 13 NTFS atomic permis-
sions are not relevant to this paper, but are described in [11].
For purposes of this paper, it is sufﬁcient to note that NTFS
permissions can be grouped into ﬁve disjoint sets: READ,
WRITE, EXECUTE, DELETE, and ADMINISTRATE 2. Of
these, only READ, WRITE, and ADMINISTRATE will ﬁg-
ure into the tasks for the present study. ADMINISTRATE
permission deserves one special note – an entity that is al-
lowed ADMINISTRATE permission can change its own per-
1Note that NTFS documentation uses the term special permission
where atomic permission is used here. The latter term makes it clearer
that these are the lowest-level, indivisible permissions in the system.
2Note that the XPFP interface and NTFS documentation use a different,
non-disjoint grouping of the 13 atomic permissions into six composite sets.
The disjoint grouping discussed here is the authors’ own, and is used for
clarity of presentation to those readers not already familiar with the NTFS
permissions model.
missions, so even if it were denied READ or WRITE per-
mission on an object, it would still be able to read or write
the object by allowing itself that permission ﬁrst.
NTFS uses an Access Control List (ACL) model of ﬁle
permissions. Under the ACL model, each ﬁle and folder
in the ﬁle system has an associated list of users and groups
who have permissions on that ﬁle or folder. An entry in
this list is called an access control entry. The access control
entry for each user or group on the list has a setting for
each of the atomic permissions. This setting’s value may
be ALLOW, DENY, or NOTSET. The meaning of ALLOW
and DENY are self-evident. NOTSET implicitly means that
neither ALLOW nor DENY has been checked, or turned on;
it acts as a DENY by default, but can be overridden by a
competing ALLOW setting, as described below.
Under the rule of group inheritance, if a group entity has
permissions on an object, all members of the group inherit
the group’s permissions for the object. Conﬂicts between a
user’s explicit permissions and their inherited permissions
are resolved through precedence rules. Speciﬁcally, DENY
settings take precedence over ALLOW settings, but ALLOW
settings take precedence over NOTSET settings. So if a user