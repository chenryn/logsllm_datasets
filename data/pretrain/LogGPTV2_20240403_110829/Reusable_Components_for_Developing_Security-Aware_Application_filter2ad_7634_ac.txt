components. The ProxyGenerator component is aware of 
the existing objects and can create secure object wrappers 
using  introspection.  In  fact,  the  Java  language  offers  a 
ready-to-use  component 
this  proxy 
generator. In other environments, this component has to 
be created using the language’s runtime information. 
realizes 
that 
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Objects  are  identified  via  a  unique  id  within  the 
framework.  This  id  is  computed  from  the  object’s  full-
qualified  class  name  and  an  instance  identifier.  The 
prefixed class name allows an easier lookup of the object 
and  administration  within  the  data  storages.  However, 
the algorithm for computing the object’s id is adaptable 
according to personal needs. 
3.3.3.  Authorizations.  The  Authorization  component 
realizes  the  type  of  access  rights  onto  a  resource. 
Authorizations  are  logically  separated  from  the  access 
control model to increase flexibility. Thus, authorizations 
are  implemented  by  the  business  application  developers 
and have a defined meaning for a given secure object. As 
a  consequence,  each  authorization  component  has  a 
checkAccess method. This method is called when access 
validation is done. The framework also offers specialized 
components  for  positive  (permissions)  and  negative 
(prohibitions)  authorizations.  The  usage  of  the  specific 
type of authorization depends on the closure assumption 
maintained by the access control model. 
Authorizations can be defined either on object level or 
for specific methods of an object. Thus, the developer of 
an authorization must additionally take care of different 
meanings  of  a  certain  authorization  (e.g.  an  execute 
permission  at  object  level  allows  the  invocation  of  all 
methods  whereas  at  method  level  it  allows  only  the 
execution  of  a  certain  method).  This  implies  also  that 
some authorizations are applicable only to object level or 
to method level. 
3.3.4. Constraints. The Constraint component allows to 
further  restrict  authorization  within  the  system  in  a 
flexible  way.  Some  constraints  are  specific  to  particular 
access  control  models  (e.g.  separation-of-duty).  These 
specific  constraints  influence  only  actions  and  tasks  of 
the  access  control  model  and  are  defined  and 
implemented  by  the  model  provider.  Other  constraints 
are  independent  of  the  current  active  access  control 
model  and  influence  the  application  as  a  whole.  They 
have  to  be  defined  and  implemented  by  the  framework 
architect.  Examples  include  location  constraints  (e.g. 
logins are only allowed from specific IP addresses),  time 
constraints (e.g. logins are allowed from 8am to 5pm). 
Similar to the authorization component, the constraint 
component  offers  a  checkAccess  method  that  is  able  to 
evaluate access. 
The 
3.4. Data Provider Components 
data 
provider 
the 
interoperation  with  underlying  backend  systems.  Each 
infrastructure  component  mentioned  in  section  3.3  (i.e. 
components 
realize 
subject, secure object, authorization and constraint) needs 
to have a specific data provider, which is able to read and 
write from and to persistent storage (compare  
Figure 5). A so-called security data provider manages 
the  configuration  of  the  framework  and  the  relation 
between an application and it’s specific data providers.  
Figure 5 Data provider components. 
these  data  providers 
This  security  data  provider  handles  the  framework’s 
configuration by interacting with an XML-based storage. 
The  configuration  file  points  to  various  other  data 
providers  that  are  able  to  communicate  with  various 
objects storages (e.g. LDAP, database). The security data 
provider  coordinates 
that  are 
necessary for the establishment of the authorization base. 
Each  security  component  has  its  own  data  provider 
which  allows  the  connection  to  different  systems  (e.g. 
users  can  be  taken  from  the  operating  systems  whereas 
objects  are  stored  within  a  database).  Furthermore,  data 
providers take care of the different needs of the security 
model (e.g. a DAC model merely needs users, an RBAC 
model  needs  users  and  roles),  thus  different  data 
providers  can  be  specified  for  different  models.  In 
general,  each  model  must  reference  to  a  subject  data 
provider that manages the model’s subject, an object data 
provider for the objects to be protected, an authorization 
data  provider  pointing  to  the  various  authorizations 
available, 
supplying 
constraints and the authorization base data provider that 
manages  the  authorization  statements  in  the  form  of 
subject, object, authorization and constraint tuples. 
constraint  data  provider 
If a tuple in the authorization base cannot be resolved 
due  to  missing  entities,  the  tuple  is  removed  and  an 
auditing message is generated. 
a 
4. Realization Issues 
We  now  want  to  discuss  particular  realization  issues 
framework. 
encountered  when 
Currently,  GAMMA 
is  available  as  beta-release 
implemented  in  Java.  As  mentioned  before,  we  want  to 
implementing 
the 
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
realize the platform and architecture independent design 
also within the .NET framework in future. 
4.1. Canonical Access Control Mechanism 
authorization 
of 
For  providing  generic  access  controls  an  extremely 
flexible way of enforcing access controls has to be found. 
The  basic  assumption  is,  that  access  controls  can  be 
stated  in  terms  of  subjects  accessing  protected  objects. 
Particular  access  control  models  have  to  implement 
stating 
particular 
the 
semantics 
that  model. 
Furthermore,  access  control  models  can  make  use  of 
constraints 
specific 
authorization  conditions  (e.g.  separation  of  duty)  or 
general  authorization  conditions  like  time  or  location 
constraints, 
the 
the  canonical  access  control 
particular  steps  of 
mechanism implemented in GAMMA. 
components, 
authorization  within 
instance.  Figure  6 
either  model 
illustrates 
capsulate 
that 
for 
Access Control 
Model 
1 
process 
request 
Authorization Base 
S 
O 
A 
Constraints 
2 
6 
Secure Object 
3 
Person o; 
... 
setName() 
Authorization 
Check(...) 
true/false 
Access Control Context 
+Subject 
+HostInformation 
+TargetInformation 
uses 
4 
5 
Time Constraint 
08:00 – 12:00 
Check(s, o, p); 
true/false 
b
o
o
l
Figure 6 Canonical access control mechanism. 
In general, a subject wants to access a protected object 
in  a  certain  way.  The  requested  operation  on  the  object 
defines  authorizations  that  are  necessary  in  order  to 
fulfill the task. The way how to decide whether an access 
is  granted  or  not  is  determined  by  the  access  control 
model,  the  authorization  objects  defined  for  that  model, 
and the constraint objects assigned to the authorizations. 
First the access controller receives a request from an 
authenticated  subject  for  a  certain  operation  on  a 
protected object, which has been mediated by the security 
manager.  The  request  is  passed  to  all  active  access 
control  models  according  to  a  particular  order  specified 
within  a  configuration  file.  Further  details  on  using 
multiple  concurrent  access  control  models  are  discussed 
in section 4.2. 
Each 
access 
control  model 
a 
subject/object combination in the authorization base (1), 
which matches the request. The search process returns a 
list  of  matching  authorization  rules  that  are  defined  for 
searches 
for 
that 
invoking 
is  defined  for 
is  evaluated.  Again, 
the  subject/object  combination.  Each  authorization  is 
explicitly  checked  by 
the  authorization’s 
checkAccess-method (2). However, there is the possibility 
of  defining  additional  constraints  that  further  restrict  a 
specified  access  operation  to  a  protected  object.  Thus, 
the  particular 
each  constraint 
authorization 
is 
delegated  by  invoking  the  checkAccess-method  of  the 
particular constraint (3/4). When both, the authorization 
and  any  constraint  suggest  granting  access,  the  access 
control model either reports a positive (access is granted) 
or negative (access is denied) result (5) depending on the 
closure assumption of the model (open/close world). This 
result  is  then  returned  to  the  security  manager  via  the 
access  controller,  which  finally  gives  or  prevents  access 
to the requested object (6). 
the  decision 
This  possibility  may  lead  to  conflicts  requiring  each 
model to have a conflict resolution strategy. We propose 
and  implemented  a  strategy,  where  –  in  that  order  – 
specific rules (assigned to an object’s method) win over 
general  ones  (defined  on  object-  or  class 
level), 
prohibitions over permissions, and any rule wins over the 
closure  assumption,  which  in  anyway  regulates  the  case 
of having no applicable authorization rule. Consequently, 
it  may  happen  that  a  specific  permission  wins  over  a 
general  prohibition.  For  instance,  a  bank  secretary  may 
be  generally  prohibited 
individual  bank 
accounts retrieving the name or other data.  However, the 
secretary may be specifically allowed to retrieve the total 
amount of money stored in a certain account by means of 
invoking  a  certain  method  (e.g.  getAmount)  in  order  to 
perform statistical measurements. However, it remains in 
the  hands  of  the  model  provider  to  define  the  conflict 
resolution  strategy  that  is  most  appropriate  to  the 
particular application’s security requirements. 
to  access 
Currently,  a  traditional  DAC  approach  as  well  as  an 
RBAC  approach  according  to  NIST  standardization 
efforts  (compare  [12])  has  been  realized  based  on  the 
aforementioned  canonical  access  control  mechanism. 
However,  we  plan  to  realize  multi-level  approaches  as 
one  of  the  next  steps  in  the  project  in  order  to  evaluate 
the  spectrum  of  applicability  of  our  canonical  access 
control mechanism. 
4.2. Multiple Concurrent Access Control Models 
When  using  multiple  access  control  models,  it  is 
probable  that  different  models  have  different  meanings 
concerning  access  privileges.  Thus  a  strategy  to  resolve 
such  conflicts  is  required.  An  example  of  concurrent 
access control models is given in section 5. 
Any  access  control  model  that  should  be  used  is 
specified  within  a  framework  configuration  file.  The 
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
sequence in which they are listed defines the domination 
of  the  models.  When  access  is  checked,  the  access 
controller  contacts  the  active  models,  starting  with  the 
first  one.  Each  model  can  return  four  values,  which 
indicate  either  strong  or  weak  results.  If  the  model 
returns a strong result, the access controller accepts this 
result  and  returns  it  to  the  security  manager,  thus  a 
strong  result  is  mandatory.  A  weak  result  indicates  that 
the  current  model  cannot  make  a  proper  choice  but 
returns  a  proposal  based  on  its  closure  assumption.  In 
this  case  the  access  controller  contacts  the  next  active 
access  control  model  as  long  as  a  strong  result  is 
returned.  If  each  model  returns  weak  results  indicating 
that no model is able to make a proper choice, the first 
weak result is returned. 
This mechanism ensures that a result is found and that 
the  access  control  mechanism  pays  attention  to  the 
domination order of the active access control models. If a 
more  dominant  model  is  able  to  make  an  obligatory 