Springer Berlin Heidelberg, 2010, pp. 181–195.
[4] Trusted Computing Group, “Trusted platform module library speciﬁca-
tion, family “2.0”,” 2014.
[5] L. Chen and J. Li, “Flexible and scalable digital signatures in TPM 2.0,”
in ACM CCS. ACM, 2013, pp. 37–48.
[6] C. Schnorr, “Efﬁcient signature generation by smart cards,” J. Cryptol-
ogy, vol. 4, no. 3, pp. 161–174, 1991.
[7] C. Paquin and G. Zaverucha,
speciﬁ-
v1.1
[Online]. Avail-
https://www.microsoft.com/en-us/research/publication/u-prove-
cation
able:
cryptographic-speciﬁcation-v1-1-revision-3/
3),” December
cryptographic
“U-prove
(revision
2013.
[8] L. Xi, K. Yang, Z. Zhang, and D. Feng, “DAA-related APIs in TPM 2.0
revisited,” in Trust and Trustworthy Computing: TRUST 2014, Springer
International Publishing, 2014, pp. 1–18.
[9] J. Camenisch, M. Drijvers, and A. Lehmann, “Universally composable
direct anonymous attestation,” in Public-Key Cryptography - PKC 2016,
Springer Berlin Heidelberg, 2016, pp. 234–264.
[10] ——, “Anonymous attestation using the strong difﬁe hellman assumption
revisited,” in Trust and Trustworthy Computing: TRUST 2016, Springer
International Publishing, 2016, pp. 1–20.
[11] J. Camenisch, S. Hohenberger, and A. Lysyanskaya, “Compact E-
Cash,” in Advances in Cryptology – EUROCRYPT 2005. Springer Berlin
Heidelberg, 2005, pp. 302–321.
[12] S. D. Galbraith, K. G. Paterson, and N. P. Smart, “Pairings for cryp-
tographers,” Discrete Applied Mathematics, vol. 156, no. 16, pp. 3113
– 3121, 2008, applications of Algebra to Cryptography.
[13] P. S. L. M. Barreto and M. Naehrig, “Pairing-friendly elliptic curves
of prime order,” in SAC 2005, Springer Berlin Heidelberg, 2006, pp.
319–331.
[14] D. Boneh and X. Boyen, “Short signatures without random oracles and
the SDH assumption in bilinear groups,” Journal of Cryptology, vol. 21,
no. 2, pp. 149–177, 2007.
[15] A. Lysyanskaya, R. Rivest, A. Sahai, and S. Wolf, “Pseudonym systems,”
in SAC 2000, ser. Lecture Notes in Computer Science, Springer Berlin
Heidelberg, 2000, vol. 1758, pp. 184–199.
[16] V. Shoup, “Lower Bounds for Discrete Logarithms and Related Prob-
lems,” in Advances in Cryptology – EUROCRYPT ’97. Springer Berlin
Heidelberg, 1997, pp. 256–266.
[17] J. Camenisch and A. Lysyanskaya, “Signature schemes and anonymous
credentials from bilinear maps,” in Advances in Cryptology - CRYPTO
2004, ser. Springer Berlin Heidelberg, 2004, vol. 3152, pp. 56–72.
[18] M. H. Au, W. Susilo, and Y. Mu, “Constant-size dynamic k-TAA,” in
Security and Cryptography for Networks: 5th International Conference,
SCN 2006, Springer Berlin Heidelberg, 2006, pp. 111–125.
[19] J. Camenisch and M. Stadler, “Efﬁcient group signature schemes for
large groups,” in Advances in Cryptology - CRYPTO ’97, ser. Springer
Berlin Heidelberg, 1997, vol. 1294, pp. 410–424.
[20] J. Camenisch, A. Kiayias, and M. Yung, “On the portability of general-
ized schnorr proofs,” in Advances in Cryptology - EUROCRYPT 2009,
Springer Berlin Heidelberg, 2009, vol. 5479, pp. 425–442.
[21] A. Fiat and A. Shamir, “How to prove yourself: Practical solutions
to identiﬁcation and signature problems,” in Advances in Cryptology
- CRYPTO ’86, ser. Springer Berlin Heidelberg, 1987, vol. 263, pp.
186–194.
[22] M. Bellare and P. Rogaway, “Random oracles are practical: A paradigm
for designing efﬁcient protocols,” in ACM CCS, ACM, 1993, pp. 62–73.
[23] L. Chen, D. Page, and N. Smart, “On the design and implementation
of an efﬁcient DAA scheme,” in Smart Card Research and Advanced
Application, Springer Berlin Heidelberg, 2010, vol. 6035, pp. 223–237.
[24] J. Camenisch, M. Drijvers, and A. Lehmann, “Anonymous attestation
with subverted tpms,” Cryptology ePrint Archive, Report 2017/200,
2017, http://eprint.iacr.org/2017/200.
[25] T. Acar, L. Nguyen, and G. Zaverucha, “A TPM difﬁe-hellman
2013,
ePrint Archive, Report
2013/667,
oracle,” Cryptology
http://eprint.iacr.org/.
[26] D. R. L. Brown and R. P. Gallant, “The static difﬁe-hellman
problem,” Cryptology ePrint Archive, Report 2004/306, 2004,
http://eprint.iacr.org/2004/306.
[27] J. H. Cheon, “Security analysis of the strong difﬁe-hellman problem,”
in Advances in Cryptology - EUROCRYPT 2006, 2006, pp. 1–11.
[28] E. Brickell and J. Li, “Enhanced privacy ID from bilinear pairing
for hardware authentication and attestation,” International Journal of
Information Privacy, Security and Integrity, vol. 1, no. 1, pp. 3–33,
2011.
[29] ——, “Enhanced privacy ID: A direct anonymous attestation scheme
with enhanced revocation capabilities,” in Proceedings of the 2007 ACM
Workshop on Privacy in Electronic Society New York, NY, USA: ACM,
2007, pp. 21–30.
[30] R. Canetti, “Universally composable security: A new paradigm for
cryptographic protocols,” Cryptology ePrint Archive, Report 2000/067,
2000, http://eprint.iacr.org/.
[31] International Organization for Standardization, “ISO/IEC 20008-2: In-
formation technology - Security techniques - Anonymous digital signa-
tures - Part 2: Mechanisms using a group public key,” 2013.
[32] L. Chen and R. Urian, “DAA-A: Direct anonymous attestation with
attributes,” in Trust and Trustworthy Computing: TRUST 2015, Springer
International Publishing, 2015, pp. 228–245.
[33] D. Bernhard, G. Fuchsbauer, E. Ghadaﬁ, N. Smart, and B. Warinschi,
“Anonymous attestation with user-controlled linkability,” International
Journal of Information Security, vol. 12, no. 3, pp. 219–249, 2013.
[34] J. Camenisch, M. Drijvers, A. Edgington, A. Lehmann, R. Lin-
implementa-
demann, and R. Urian, “FIDO ECDAA algorithm,
tion draft,” https://ﬁdoalliance.org/specs/ﬁdo-uaf-v1.1-id-20170202/ﬁdo-
ecdaa-algorithm-v1.1-id-20170202.html.
916
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
APPENDIX A
FORMAL SECURITY MODEL
This section introduces our formal security model of DAA,
which is based on the deﬁnition by Camenisch et al. [9], [10],
[24]. At the end of this section we also compare the captured
privacy guarantees in the presence of subverted TPM with
the existing privacy notions, and to optimal privacy [24] in
particular.
A1 Universal Composability
Our security deﬁnition has the form of an ideal functionality
Fpdaa+ in the Universal Composability (UC) framework [30].
In UC, an environment E gives inputs to the protocol parties
and receives their outputs. In the real world, honest parties ex-
ecute the protocol, over a network controlled by an adversary
A, who can also communicate freely with the environment
E. In the ideal world, honest parties forward their inputs to
the ideal functionality F. The ideal functionality internally
performs the deﬁned task and generates outputs for the honest
parties. As F performs the task at hand in an ideal fashion,
i.e., F is secure by construction.
Informally, a protocol Π is said to securely realize an ideal
functionality F if the real world is as secure as the ideal
world. To prove that statement one has to show that for every
adversary A attacking the real world, there exists an ideal
world attacker or simulator S that performs an equivalent
attack on the ideal world. More precisely, Π securely realizes
F if for every adversary A, there exists a simulator S such
that no environment E can distinguish the real world (with Π
and A) from the ideal world (with F and S).
A2 Session Identiﬁers and Input/Output
In the UC model, different instances of the protocol are
distinguished with session identiﬁers. Here we use session
(cid:3)) for some issuer I
identiﬁers of the form sid = (I, sid
. To allow several sub-sessions for
and a unique string sid
the join and sign related interfaces we use unique sub-session
identiﬁers jsid and ssid.
(cid:3)
Every party can give different inputs to the protocol. We
distinguish these by adding different labels to these inputs,
e.g., the host can give an input labeled with JOIN to request
to join, and an input labeled with SIGN to start signing a
message. Outputs are labeled in a similar way.
A3 Ideal Functionality Fpdaa+
This section formally introduces our ideal DAA function-
ality Fpdaa+, which deﬁnes DAA with attributes, signature-
based revocation, and strong privacy. It is based on Fpdaa
and F l
daa+ by Camenisch et al. [10], [24]. We now give an
informal overview of the interfaces of Fpdaa+, and present the
full deﬁnition in Fig. 5.
Setup. The SETUP interface on input sid = (I, sid
(cid:3)) initiates
a new session for the issuer I and expects the adversary
to provide algorithms (ukgen, sig, ver, link, identify) that will
be used inside the functionality. ukgen creates a new key
(cid:3)
(cid:3)
(cid:3)
, m
(cid:3)
, m
, σ, m, bsn).
, bsn) ↔ link(σ
gsk and a tracing trapdoor τ that allows Fpdaa+ to trace
signatures generated with gsk. sig, ver, and link are used
by Fpdaa+ to create, verify, and link signatures, respectively.
Finally, identify allows to verify whether a signature belongs
to a certain tracing trapdoor. This allows Fpdaa+ to perform
multiple consistency checks and enforce the desired non-
frameability and unforgeability properties.
Note that the ver and link algorithms assist the functionality
only for signatures that are not generated by Fpdaa+ itself. For
signatures generated by the functionality, Fpdaa+ will enforce
correct veriﬁcation and linkage using its internal records.
While ukgen and sig are probabilistic algorithms, the other
ones are required to be deterministic. The link algorithm also
has to be symmetric, i.e., for all inputs it must hold that
link(σ, m, σ
Join. A host Hj can request to join with a TPM Mi using the
JOIN interface. The issuer is asked to approve the join request,
and choose the platform’s attributes. Fpdaa+ is parametrized
by L and {Ai}0<i≤L, that offer support for attributes. L is
the amount of attributes every credential contains and Ai
the set from which the i-th attribute is taken. When the
issuer approves with attributes attrs ∈ A1 × . . . × AL,
the functionality stores an internal membership record for
Mi,Hj, attrs in Members indicating that from now on that
platform is allowed to create attestations.
If the host is corrupt, the adversary must provide Fpdaa+
with a tracing trapdoor τ. This value is stored along in
the membership record and allows the functionality to check
via the identify function whether signatures were created
by this platform. Fpdaa+ uses these checks to ensure non-
frameability and unforgeability whenever it creates or veri-
ﬁes signatures. To ensure that the adversary cannot provide
bad trapdoors that would break the completeness or non-
frameability properties, Fpdaa+ checks the legitimacy of τ
via the “macro” function CheckTtdCorrupt. This function
checks that for all previously generated or veriﬁed signatures
for which Fpdaa+ has already seen another matching tracing
(cid:4)= τ, the new trapdoor τ is not identiﬁed as a
trapdoor τ
matching key as well. CheckTtdCorrupt is deﬁned as follows:
CheckTtdCorrupt(τ ) =(cid:4) ∃(σ, m, bsn) :
(cid:6)
(cid:3)
(cid:7)
identify(σ, m, bsn, τ ) = identify(σ, m, bsn, τ
(cid:3)) = 1
Sign. After joining, a host Hj can use the SIGN interface to
request a signature on a message m with respect to basename
bsn while proving a certain predicate p holds for his attributes
and proving that he is not revoked by signature revocation list
SRL. The signature will only be created when the TPM Mi
917
(cid:5)σ, m, bsn,∗,∗(cid:6) ∈ Signed ∨
(cid:8)
(cid:5)σ, m, bsn,∗, 1(cid:6) ∈ VerResults
∧
(cid:7)
τ (cid:4)= τ
(cid:3) :
(cid:10) ∧
(cid:5)∗,∗,∗,∗, τ
(cid:3) ∧ (cid:9)(cid:5)∗,∗, τ
(cid:3)(cid:6) ∈ DomainKeys
(cid:3)(cid:6) ∈ Members ∨
∃τ
(cid:8)(cid:11)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
explicitly agrees to signing m, a join record for Mi,Hj, attrs
in Members exists such that attrs satisfy p (if the issuer is
honest), and the platform is not revoked by SRL.
When a platform wants to sign message m w.r.t. a fresh
basename bsn, Fpdaa+ generates a new key gsk (and tracing
trapdoor τ) via ukgen and then signs m with that key. The
functionality also stores the fresh key (gsk , τ ) together with
bsn in DomainKeys, and reuses the same key when the
platform wishes to sign repeatedly under the same base-
name. Using fresh keys for every signature naturally enforces
the desired privacy guarantees: the signature algorithm does
not receive any identifying information as input, and thus
the created signatures are guaranteed to be anonymous (or
pseudonymous in case bsn is reused).
non-frameability
checks
further
completeness,
freshly
every
our
generated key,
tracing trapdoor and signature does not
falsely match with any existing signature or key. More
precisely, Fpdaa+ ﬁrst uses the CheckTtdHonest macro
to verify whether
the new key does not match to any
existing signature. CheckTtdHonest is deﬁned as follows:
guarantee
functionality
and
that
To
CheckTtdHonest(τ ) =
∀(cid:5)σ, m, bsn,M,H(cid:6) ∈ Signed : identify(σ, m, bsn, τ ) = 0 ∧
∀(cid:5)σ, m, bsn,∗, 1(cid:6) ∈ VerResults : identify(σ, m, bsn, τ ) = 0
Likewise, before outputting σ, the functionality checks that
no one else already has a key which would match this newly
generated signature.
Finally, for ensuring unforgeability, the signed message,
basename, attribute predicate, signature revocation list, and
platform identity are stored in Signed, which will be used
when verifying signatures.
Verify. Signatures can be veriﬁed by any party using
the VERIFY interface. Fpdaa+ uses its internal Signed,
Members, and DomainKeys records to enforce unforgeabil-
ity and non-frameability. It uses the tracing trapdoors τ stored
in Members and DomainKeys to ﬁnd out which platform
created this signature. If no match is found and the issuer is
honest, the signature is a forgery and rejected by Fpdaa+. If
the signature to be veriﬁed matches the tracing trapdoor of
some platform with an honest host, but the signing records do
not show that they signed this message w.r.t. the basename,
attribute predicate, and signature revocation list, Fpdaa+ again
considers this to be a forgery and rejects. If the platform has
an honest TPM, only checks on the message and basename
are made. If the records do not reveal any issues with the
signature, Fpdaa+ uses the ver algorithm to obtain the ﬁnal
result.
The verify interface also supports veriﬁer-local revocation.
The veriﬁer can input a revocation list RL containing tracing
trapdoors, and signatures matching any of those trapdoors are
no longer accepted.
Link. Using the LINK interface, any party can check whether
(cid:3)) respectively, gen-
two signatures (σ, σ
(cid:3)) on messages (m, m
erated with the same basename bsn originate from the same
platform or not. Fpdaa+ again uses the tracing trapdoors
τ stored in Members and DomainKeys to check which
platforms created the two signatures. If they are the same,
Fpdaa+ outputs that they are linked. If it ﬁnds a platform that
signed one, but not the other, it outputs that they are unlinked,
which prevents framing of platforms with an honest host.
Conventions. The full deﬁnition of Fpdaa+ is presented in
Fig. 5. We use a number of conventions to simplify the deﬁni-
tion of Fpdaa+. First, we require that identify(σ, m, bsn, τ ) =
0 if σ or τ is ⊥. Second, whenever we need approval from the
adversary to proceed, Fpdaa+ sends an output to the adversary
and waits for a response. This means that in that join or
sign session, no other inputs are accepted except the expected
response from the adversary. Third, if any check that Fpdaa+
makes fails, the sub-session is invalidated and ⊥ is output to
the caller.
A4 Comparison of Fpdaa+ with Previous Deﬁnitions
Our functionality Fpdaa+ is based on previous UC-based
daa+ [10] which extends F l
DAA functionalities F l
with attributes and signature-based revocation, and Fpdaa [24],
which strengthens the privacy guarantees of F l
daa. We now
show how our functionality compares to these other DAA
functionalities.
daa [9], F l
daa
daa+ adds these features to F l
Attributes and Signature-based Revocation. Our function-
ality Fpdaa+ supports adding attributes to the membership