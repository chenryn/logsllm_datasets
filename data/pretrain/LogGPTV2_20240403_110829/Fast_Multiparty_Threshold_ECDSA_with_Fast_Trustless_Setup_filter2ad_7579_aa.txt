title:Fast Multiparty Threshold ECDSA with Fast Trustless Setup
author:Rosario Gennaro and
Steven Goldfeder
Fast Multiparty Threshold ECDSA with Fast Trustless
Setup
Rosario Gennaro1 and Steven Goldfeder2
1 City University of New York
PI:EMAIL
2 Princeton Universty§
PI:EMAIL
Abstract. A threshold signature scheme enables distributed signing among n players such
that any subgroup of size t + 1 can sign, whereas any group with t or fewer players cannot.
While there exist previous threshold schemes for the ECDSA signature scheme, we present
the ﬁrst protocol that supports multiparty signatures for any t ≤ n with eﬃcient, dealerless
key generation. Our protocol is faster than previous solutions and signiﬁcantly reduces the
communication complexity as well. We prove our scheme secure against malicious adversaries
with a dishonest majority. We implemented our protocol, demonstrating its eﬃciency and
suitability to be deployed in practice.
1 Introduction
A threshold signature scheme enables n parties to share the power to issue digital signatures
under a single public key. A threshold t is speciﬁed such that any subset of t + 1 players can
jointly sign, but any smaller subset cannot. Generally, the goal is to produce signatures that are
compatible with an existing centralized signature scheme. In a threshold scheme the key generation
and signature algorithm are replaced by a communication protocol between the parties, but the
veriﬁcation algorithm remains identical to the veriﬁcation of a signature issued by a centralized
party.
In recent years there has been renewed attention to this topic, in particular to the threshold
generation of ECDSA signatures, mostly due to the use of ECDSA in Bitcoin and other cryptocur-
rencies. Indeed, a secure threshold signature schemes for ECDSA would be an eﬀective counter-
measure to the constant theft of bitcoins due to the compromise of the secret signing key that
authorizes transactions. Securing Bitcoin is equivalent to securing these keys. Instead of storing
them in a single location, keys should be split and signing should be authorized by a threshold set
of computers. A breach of any one of these machines—or any number of machines less than the
threshold—will not allow the attacker to steal any money or glean any information about the key.
Before the advent of Bitcoin, the best ECDSA threshold signature scheme was the work by
Gennaro et al. [18], which has a considerable setback. To implement a security threshold of t
players (i.e. t or less players cannot sign) it is necessary to share the key among at least 2t + 1
players, and the participation of at least 2t + 1 players is required to sign. This limitation rules out
an n-of-n sharing where all parties are required to sign. Furthermore, it requires setting up many
servers holding key shares, which may be costly and also makes the job of the attacker easier in
some way (as there are more servers that can be targeted and while the honest participants need
2t + 1 players to sign, an attacker need only compromise t + 1 servers to steal the key).
In an attempt to address these issues, Mackenzie and Reiter built a specialized scheme for
the 2-out-of-2 signature case (i.e. t = 1 and n = 2) [29], a case not covered by Gennaro et al.’s
This is a minor revision of our paper [16] that appeared at ACM CCS 2018.
§ Steven Goldfeder has since joined Cornell Tech/IC3
2
Rosario Gennaro and Steven Goldfeder
scheme. Recently much improved 2-out-of-2 schemes have been presented [12, 27]. However 2-out-
of-2 sharing is very limited and can’t express more ﬂexible sharing policies that might be required
in certain applications.
Gennaro and others in [17] (improved in [4]) address the more general (t, n) case in the threshold
optimal setting, meaning n ≥ t + 1 and that only t + 1 players are needed to sign. However, their
scheme too has a setback in that the distributed key generation protocol is very costly.
Our Result: We present a new threshold-optimal protocol for ECDSA that improves in many
signiﬁcant ways over [4, 17]. Our new protocol is faster and requires much less communication than
[4, 17]; it is also conceptually simpler and does not require a complicated distributed key generation
protocol (details of the comparison appear below).
In concurrent work that appeared in the same proceedings, Lindell et al. present a similar
protocol for multiparty threshold ECDSA with an eﬃcient key generation [28].
1.1 Overview of our solution
Consider a “generic” DSA signature algorithm that works over any cyclic group G of prime order
q generated by an element g. It uses a hash function H deﬁned from arbitrary strings into Zq, and
another hash function H(cid:48) deﬁned from G to Zq. The secret key is x chosen uniformly at random in
Zq, with a matching public key y = gx. To sign a message M , the signer computes m = H(M ) ∈ Zq,
in G and r = H(cid:48)(R) ∈ Zq. Then
chooses k uniformly at random in Zq and computes R = gk−1
she computes s = k(m + xr) mod q. The signature on M is the pair (r, s) which is veriﬁed by
computing
R(cid:48) = gms−1 mod qyrs−1 mod q in G
and accepting if H(cid:48)(R(cid:48)) = r.
The technical complication with sharing DSA signatures comes from having to jointly compute
R (which requires raising g to the inverse of a secret value k) and to compute s which requires
multiplying two secret values k, x. As shown in [18], it is suﬃcient to show how to compute two
multiplications over secret values that are shared among the players. In [18] the values are shared
via Shamir’s secret sharing, i.e. as points on a polynomial of degree t with free term the secret.
The eﬀect of multiplication is that the degree of the polynomial is doubled, which explains why
the [18] solution requires at least 2t + 1 players to participate. To address this problem [29] uses a
multiplicative sharing of the secret key x as x = x1 · x2 (an approach taken also in [12, 27]) which
is however hard to generalize to t > 2.
A diﬀerent approach was taken in [17]: the secret key x is encrypted under a public key en-
cryption scheme E, and it is the secret key of E that is shared among the players, eﬀectively
providing a secret sharing of x. If E is an additively homomorphic encryption scheme (e.g. Pail-
lier’s [31]) they show that it is possible to construct a reasonably eﬃcient protocol, with a few
troubling bottlenecks. The major one is that the protocol requires a joint generation of the public
key/secret key pair for the additively homomorphic encryption E. When E is instantiated using
Paillier, this requires the distributed generation of an RSA modulus. Although solutions are known
for this problem (e.g. [23]), they are far from scalable and eﬃcient. To our knowledge the protocol
from [23] has never been implemented for the malicious multiparty case. The only benchmark we
are aware of for this protocol is that for the two-party semi-honest case it takes 15 minutes [27],
and we can extrapolate that it would take signiﬁcantly longer in the multiparty malicious setting.
Moreover the signature generation protocols in [4, 17] require long messages and complicated ZK
proofs.
In this paper we take a diﬀerent path inspired by the SPDZ approach to multiparty computation
[9]. Given two secrets a, b shared additively among the players, i.e. a = a1 + . . . + an and b =
b1 + . . . + bn where Pi holds ai, and bi, we want to generate an additive sharing of c = ab. We
i,j aibj and therefore to get an additive sharing of ab, it is suﬃcient to obtain an
note that ab =(cid:80)
Fast Multiparty Threshold ECDSA with Fast Trustless Setup
3
additive sharing of each individual term aibj. To that extent we use a 2-party protocol that allows
two parties to transform multiplicative shares of a secret to additive shares of the same secret. The
players engage in this protocol in a pairwise fashion to obtain an additive sharing of the product
ab.
Using this approach, we build a simple and elegant threshold ECDSA protocol for the general
multiparty setting. The players start with a (t, n) Shamir sharing of the secret key x. When t + 1
i ki and
i γi and they use the above idea to compute additive sharings of the products δ = kγ (which
i wi (which is kept shared). By multiplying the local
shares of γ by the public value δ−1 the players end up with an additive sharing3 of k−1. The value
. The value s is shared additively among
players want to sign, they generate an additive sharing of two random values k = (cid:80)
γ =(cid:80)
is reconstructed in the clear) and σ = kx =(cid:80)
R is then easily computed in the exponent R =(cid:81)
the players since each player holds si = kim + wir and s =(cid:80)
i gγiδ−1
i si.
1.2 Avoid expensive ZK Proofs in case of a Malicious Adversary
Following [27] we make minimal use of ZK proofs to detect malicious behavior by the players.
Instead we take an “optimistic” approach and run the protocol assuming everybody is honest.
We then check the validity of the resulting signature to detect if there were players who deviated
from the protocol (if the signature does not verify then obviously at least one player did not follow
the instructions).
At that point, because we possibly have a dishonest majority among the players, there is no
guarantee that we can generate a correct signature so the protocol stops and aborts. This creates
a technical complication in the proof as we have to make sure that the values revealed by the good
players do not leak any valuable information, not only in the case of good executions, but also in
the case of aborting executions. As we will see, this will require us to “distributively” check that the
shares si reconstruct a valid signature before revealing them. This check is somewhat reminiscent
of the way Canetti and Goldwasser solve a similar problem in [7] to construct threshold CCA secure
encryption based on the Cramer-Shoup scheme.
Range Proofs. Even when using the signature veriﬁcation step to detect cheating, we have to
run two relatively expensive ZK proofs during the share conversion protocol:
– a “range proof” that a value a encrypted under Paillier’s encryption scheme is “small”;
– a proof that a party knows x such that c = E(x) and y = gx where E is Paillier’s encryption
scheme.
As we discuss later, removing these ZK proofs creates an attack that leaks some information
about the DSA secret key (and the randomizer k used in each signature) shared among the servers.
We conjecture that this information is so limited that the protocol remains secure even without
them (see Section 5 for details).
1.3 Experimental Results
We implemented our scheme and found both the key generation and signing protocols to be very
eﬃcient.
The key generation protocol is easy to implement and is quite fast (under a second for any
reasonable choice of parameters). This is in stark contrast to [4, 17] for which the key generation
protocol has never been implemented, and it is hard to estimate what the actual running time
would be.
Our signing protocol is also extremely eﬃcient, and is a signiﬁcant improvement over previous
works both in terms of data transferred and running time.
With the combination of an eﬃcient key generation and signing protocol, our scheme is suitable
to be deployed in practice. We present full benchmarks and evaluations in Section 7.
3 This is the famous Bar-Ilan and Beaver inversion trick [1].
4
Rosario Gennaro and Steven Goldfeder
2 Preliminaries
Communication Model. We assume the existence of a broadcast channel as well as point-to-point
channels connecting every pair of players.
The Adversary. We assume a probabilistic polynomial time malicious adversary, who may de-
viate from the protocol description arbitrarily. The adversary can corrupt up to t players, and it
learns the private state of all corrupted players. As in previous threshold ECDSA schemes [4, 17,
18, 27], we limit ourselves to static corruptions, meaning the adversary must choose which players
to corrupt at the beginning of the protocol. There are standard techniques for converting a protocol
secure against static corruptions to secure against adaptive corruptions [6, 24], but these will incur
an overhead.
We assume a rushing adversary, meaning that the adversary gets to speak last in a given round
and, in particular, can choose his message after seeing the honest parties’ messages.
Following [4, 17] (but unlike [18]), we assume a dishonest majority, meaning t, the number
of players the adversary corrupts, can be up to n − 1. In this case, there is no guarantee that the
protocol will complete, and we therefore do not attempt to achieve robustness, or the ability to
complete the protocol even in the presence of some misbehaving participants.
security parameter and returns the private signing key sk and public veriﬁcation key pk.
2.1 Signature Schemes
A digital signature scheme S consists of three eﬃcient algorithms:
– (sk, pk)←Key-Gen(1λ), the randomized key generation algorithm which takes as input the
– σ←Sig(sk, m), the possibly randomized signing algorithm which takes as input the private
key sk and the message to be signed m and outputs a signature, σ. As the signature may be
randomized, there may be multiple valid signatures. We denote the set of valid signatures as
{Sig(sk, m)} and require that σ ∈ {Sig(sk, m)}.
– b ←Ver (pk, m, σ), the deterministic veriﬁcation algorithm, which takes as input a public key
pk, a message m and a signature σ and outputs a bit b which equals 1 if and only if σ is a valid
signature on m under pk.
To prove a signature scheme secure, we recall the standard notion of existential unforgeability
against chosen message attacks (EU-CMA) as introduced in [22].
Deﬁnition 1 (Existential unforgeability). Consider a PPT adversary A who is given public
key pk output by Key-Gen and oracle access to the signing algorithm Sig(sk,·) with which it can
receive signatures on adaptively chosen messages of its choosing. Let M be the set of messages
queried by A. A digital signature scheme S =(Key-Gen,Sig,Ver) is said to be existentially unforge-
able if there is no such PPT adversary A that can produce a signature on a message m /∈ M,
except with negligible probability in λ.
2.2 Threshold Signatures
Threshold secret sharing. A (t, n)−threshold secret sharing of a secret x consists of n shares
x1, . . . , xn such that an eﬃcient algorithm exists that takes as input t + 1 of these shares and
outputs the secret, but t or fewer shares do not reveal any information about the secret.
Threshold signature schemes. Consider a signature scheme, S=(Key-Gen, Sig, Ver). A (t, n)-
threshold signature scheme T S for S enables distributing the signing among a group of n players,
P1, . . . , Pn such that any group of at least t + 1 of these players can jointly generate a signature,
whereas groups of size t or fewer cannot. More formally, T S consists of two protocols:
Fast Multiparty Threshold ECDSA with Fast Trustless Setup
5
– Thresh-Key-Gen, the distributed key generation protocol, which takes as input the security
parameter 1λ. Each player Pi receives as output the public key pk as well as a private output
ski, which is Pi’s share of the private key. The values sk1, . . . , skn constitute a (t, n) threshold
secret sharing of the private key sk.
– Thresh-Sig, the distributed signing protocol which takes as public input a message m to be
signed as well as a private input ski from each player. It outputs a signature σ ∈ {Sig(sk, m)}.
Notice that the signature output by Thresh-Sig is a valid signature under Sig, the centralized
signing protocol. Thus we do not specify a threshold variant of the veriﬁcation algorithm as we
will use the centralized veriﬁcation algorithm, Ver.
In some applications, it may be acceptable to have a trusted dealer generate the private key
shares for each party. In this case, Thresh-Key-Gen would not be run.
Following [18, 19], we present a game-based deﬁnition of security analogous to EU-CMA.
Deﬁnition 2 (Unforgeable threshold signature scheme [18]). We say that a (t, n)-threshold
signature scheme T S =(Thresh-Key-Gen,Thresh-Sig) is unforgeable, if no malicious adversary who
corrupts at most t players can produce, with non-negligible (in λ) probability, the signature on any
new (i.e., previously unsigned) message m, given the view of the protocol Thresh-Key-Gen and of
the protocol Thresh-Sig on input messages m1, . . . , mk which the adversary adaptively chose as well
as signatures on those messages.
This is a game-based deﬁnition of security which is analogous to the notion of existential unforge-
ability under chosen message attack as deﬁned by Goldwasser, Micali, and Rivest [22]. Unlike in the