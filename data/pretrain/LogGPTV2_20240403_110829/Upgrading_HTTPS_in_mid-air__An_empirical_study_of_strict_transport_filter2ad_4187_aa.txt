title:Upgrading HTTPS in mid-air: An empirical study of strict transport
security and key pinning
author:Michael Kranch and
Joseph Bonneau
Upgrading HTTPS in Mid-Air:
An Empirical Study of Strict Transport Security and Key Pinning
Michael Kranch
Princeton University
PI:EMAIL
Joseph Bonneau
Princeton University
PI:EMAIL
Abstract—We have conducted the ﬁrst in-depth empirical
study of two important new web security features: strict transport
security (HSTS) and public-key pinning. Both have been added to
the web platform to harden HTTPS, the prevailing standard for
secure web browsing. While HSTS is further along, both features
still have very limited deployment at a few large websites and a
long tail of small, security-conscious sites. We ﬁnd evidence that
many developers do not completely understand these features,
with a substantial portion using them in invalid or illogical ways.
The majority of sites we observed trying to set an HSTS header
did so with basic errors that signiﬁcantly undermine the security
this feature is meant to provide. We also identify several subtle
but important new pitfalls in deploying these features in practice.
For example, the majority of pinned domains undermined the
security beneﬁts by loading non-pinned resources with the ability
to hijack the page. A substantial portion of HSTS domains and
nearly all pinned domains leaked cookie values, including login
cookies, due to the poorly-understood interaction between HTTP
cookies and the same-origin policy. Our ﬁndings highlight that
the web platform, as well as modern web sites, are large and
complicated enough to make even conceptually simple security
upgrades challenging to deploy in practice.
I.
INTRODUCTION
HTTPS [1], which consists of layering HTTP trafﬁc over
the TLS/SSL encrypted transport protocols [2] to ensure
conﬁdentiality and integrity, is the dominant protocol used
to secure web trafﬁc. Though there have been many subtle
cryptographic ﬂaws in TLS itself (see [3] for an extensive
survey), the most signiﬁcant problem has been inconsistent and
incomplete deployment of HTTPS. Browsers must seamlessly
support a mix of HTTP and HTTPS connections, enabling
stripping attacks [4] whereby network attackers attempt to
downgrade a victim’s connection to insecure HTTP despite
support for HTTPS at both the server and client.
The primary countermeasure to HTTPS stripping is strict
transport security (HSTS) [5] through which browsers learn
that speciﬁc domains must only be accessed via HTTPS. This
policy may be speciﬁed dynamically by sites using an HTTP
header or preloaded by browsers for popular domains. While
HSTS is conceptually simple, there are subtle interactions with
Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23162
other browser security features, namely the same-origin policy
and protections for HTTP cookies. This leads to a number of
deployment errors which enable an attacker to steal sensitive
data without compromising HTTPS itself.
Beyond HTTPS stripping,
there are growing concerns
about weaknesses in the certiﬁcate authority (CA) system.
The public discovery of commercial software to use compelled
certiﬁcates [6], as well as high-proﬁle compromises of several
trusted CAs, have spurred interest
in defending against a
new threat model in which the attacker may obtain a rogue
certiﬁcate for a target domain signed by a trusted CA.
While many protocols have been proposed to maintain
security against an attacker with a rogue certiﬁcate for a
target domain signed by a trusted CA [3], the only defense
deployed to date is public-key pinning (or just key pinning),
by which a browser learns to only connect to speciﬁc domains
over HTTPS if one of a designated set of keys is used. This
policy can be used to “pin” a domain to a whitelist of keys
of which at least one must appear somewhere in the server’s
certiﬁcate chain. This can be used to pin a domain to speciﬁc
end-entity keys, certiﬁcate authorities, or a mix of both. Key
pinning is currently deployed only as a browser-preloaded
policy with Chrome and Firefox, although support is planned
for dynamically declared header-based pins [7].
While both technologies are still in the early stages, there
is signiﬁcant enough deployment to draw some meaningful
lessons about their use in practice. In this work, we report
on the ﬁrst comprehensive survey of HSTS and key pinning.
We use OpenWPM [8] to perform realistic crawling (see
Section III) of both the list of domains with preloaded security
policies in Firefox and Chrome and the top million most
highly-visited domains as provided by Alexa [9], examining
both sites’ static code and dynamically generated trafﬁc.
We catalog several common security bugs observed in
practice (see Sections IV–VI). A summary of these errors is
provided in Table I. To the best of our knowledge, we provide
the ﬁrst published evidence of these bugs’ appearance in the
wild. Knowledge of these errors is useful for any administrator
seeking to deploy HSTS and/or pinning securely.
In summarizing our ﬁndings (Section VIII), we highlight
several underlying causes of these errors. In particular, we
believe the speciﬁcation of HSTS and pinning suffers from
both insufﬁcient ﬂexibility and a lack of sensible defaults.
These lessons are timely given the considerable amount of
ongoing research and development of new proposals for up-
grading HTTPS security.
TABLE I.
SUMMARY OF MAIN VULNERABILITIES FOUND
Error
Preloaded HSTS without dynamic HSTS
Erroneous dynamic HSTS conﬁguration
Pinned site with non-pinned active content
§
IV-E
IV-E
V
Pinned site with non-pinned passive content
V
Cookies scoped to non-pinned subdomains
Cookies scoped to non-HSTS subdomains
VI-C
VI-B
VI-B
%
34.6%
59.5%
3.0%
55.6%
3.0%
44.4%
1.8%
44.4%
23.8%
47.8%
#
349/1,008
7,494/12,593
8/271
5/9
8/271
4/9
5/271
4/9
182/765
2,460/5,099
Prevalence
studied domains
domains with preloaded HSTS
top 1M domains attempting to set HSTS
base domains with preloaded pins
non-Google base domains with preloaded pins
base domains with preloaded pins
non-Google base domains with preloaded pins
base domains with preloaded pins
non-Google base domains with preloaded pins
base domains with preloaded HSTS
base domains with dynamic HSTS
Security implications
HTTPS stripping possible on old browsers
HTTPS stripping possible
data theft with a rogue certiﬁcate
page modiﬁcations with a rogue certiﬁcate
cookie theft with a rogue certiﬁcate
cookie theft by active network attacker
cookie theft by active network attacker
II. OVERVIEW OF WEB SECURITY TECHNOLOGIES
The core protocols of the World Wide Web, namely HTTP
and HTML, were not designed with security in mind. As
a result, a series of new technologies have been gradually
tacked on to the basic web platform. All of these are to some
extent weakened by backwards-compatibility considerations.
In this section we provide an overview of relevant web security
concepts that we will study in this paper.
A. HTTPS and TLS/SSL
HTTPS is the common name for “HTTP over TLS” [1]
which combines normal HTTP trafﬁc with the TLS [2], [10],
[11] (Transport Layer Security) protocol
instead of basic
(insecure) TCP/IP. Most HTTPS implementations will also
use the older SSL v3.0 (Secure Sockets Layer) protocol [12]
for backwards compatibility reasons although it contains a
number of cryptographic weaknesses. TLS and SSL are often
used interchangeably to describe secure transport; in this paper
we will strictly refer to TLS with the understanding that our
analysis applies equally to SSL v3.0.
The goals of TLS are conﬁdentiality against eavesdroppers,
integrity against manipulation by an active network adversary,
and authenticity by identifying one or both parties with a
certiﬁcate. The main adversary in TLS is typically called a man
in the middle (MitM) or active network attacker, a malicious
proxy who can intercept, modify, block, or redirect all trafﬁc.
Formally, this adversary is referred to as a Dolev-Yao attacker
model [13]. We will not discuss cryptographic issues with TLS;
Clark and van Oorschot provide a thorough survey [3].
1) Certiﬁcates and Certiﬁcation Authorities: The ultimate
goal of HTTPS is to bind the communication channel to the
legitimate server for a given web domain, and is achieved with
the use of server certiﬁcates in TLS.1 Names are bound at the
domain level and are sometimes referred to as “hostname,”
“host,” or “fully-qualiﬁed domain name”. In this paper, we’ll
always use “domain” to refer to a fully-qualiﬁed domain name.
We’ll use the term “base domain” to refer to the highest-
level non-public domain in a fully-qualiﬁed domain name,
also sometimes referred to as “public sufﬁx plus 1” (PS+1).2
1TLS also supports mutual authentication in which both client and server
are identiﬁed with a long-term certiﬁcate. However, in nearly all use on the
web only the server is authenticated and the client authentication is left for
higher-level protocols (typically passwords submitted over HTTPS).
2Detecting base domains is not as simple as ﬁnding the domain immediately
below the top-level domain (TLD+1) due to the existence of public sufﬁxes
of more than one domain, such as .ca.us or .ac.uk. We use Mozilla’s
public sufﬁx list (https://publicsufﬁx.org/) as the canonical list.
For example, for www.example.com the base domain is
example.com.
HTTPS clients will check that the “common name” ﬁeld in
the server’s presented certiﬁcate matches the domain for each
HTTP request. The exact rules are somewhat complicated [14]
enabling the use of wildcards and the “subject alternative
name” extension to allow certiﬁcates to match an arbitrary
number of domains.
If name matching fails or a certiﬁcate is expired, mal-
formed, or signed by an unknown or untrusted certiﬁcate
authority, HTTPS clients typically show the user a warning.
Browser vendors have made the warnings more intrusive over
time and click-through rates have declined signiﬁcantly [15],
[16] to below 50% for Firefox. This decrease is generally
considered a positive development as the vast majority of
HTTPS warning messages represent false positives due to
server misconﬁgurations or expired certiﬁcates [17], [18].
B. Strict transport security
Because a large portion of web sites only support insecure
HTTP, user agents must support both HTTP and HTTPS.
Many domains serve trafﬁc over both HTTP and HTTPS. This
enables an active network attacker to attempt to downgrade
security to plain HTTP by intercepting redirects from HTTP
to HTTPS or rewriting URLs contained in an HTTP page to
change the protocol from HTTPS to HTTP. Such an attack
is called an SSL stripping or HTTPS stripping attack. While
the threat has long been known [19],
it gained increased
attention in 2009 when the popular sslstrip software package
was released to automate the attack [4].
Browsers use graphical indicators to tell the user whether
a connection is made over HTTP or HTTPS. Typically, this
UI includes showing https in the browser’s address bar and
a padlock icon. However, user studies have indicated that the
vast majority of users (upwards of 90%) do not notice if these
security indicators are missing and are still willing to transmit
sensitive data such as passwords or banking details [20]. Thus,
it is insufﬁcient to rely on users to detect if their connection
to a normally-secure server has been downgraded to HTTP by
an attacker.
To counter the threat of HTTPS stripping, Jackson and
Barth proposed “ForceHTTPS” [21] to enable servers to re-
quest clients only communicate over HTTPS. Their proposal
was ultimately renamed “HTTP strict transport security” and
2
standardized in RFC 6797 [5].3
1) HSTS security model: HSTS works as a binary (per
domain) security policy. Once set, the user agent must refuse
to send any trafﬁc to the domain over plain HTTP. Any
request which would otherwise be transmitted over HTTP (for
example, if the user clicks on a link with the http scheme
speciﬁed) will be upgraded from HTTP to HTTPS.
In addition to upgrading all trafﬁc to HTTPS, the HSTS
speciﬁcation recommends two other changes. First, any TLS
error (including certiﬁcate errors) should result in a hard fail
with no opportunity for the user to ignore the error. Second, it
is recommended (non-normatively) that browsers disable the
loading of insecure resources from an HSTS-enabled page; this
policy has since been adopted by Chrome and Firefox for all
HTTPS pages even in the absence of HSTS (see Section V).
By default, HSTS is declared for a speciﬁc fully-
an optional
qualiﬁed domain name,
to all
includeSubDomains directive which applies
the domain setting the policy. For ex-
subdomains of
ample,
an HSTS policy with
includeSubDomains, then all trafﬁc to example.com as
well as a.example.com and b.a.example.com must be
over HTTPS only.4
if example.com sets
though there
is
Note that while HSTS requires a valid TLS connection,