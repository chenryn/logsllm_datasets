the operation sequence of digression-inducing variables is
called CVDG-level corruption path, represented by a directed
path in the CVDG.
We ï¬rst deï¬ne several terms. Each primitive controller has
three inputs: sensor input S, ï¬‚ight mission M, and control pa-
rameter P, with M and P coming from ground control (GCS).
xI, rI, and kI denote the control state, reference, and parameter
(a vector) of the initial digressing controller â€“ denoted as CI.
xc, rc, and kc denote the control state, reference, and param-
eter of CIâ€™s child (i.e., immediate downstream) controller â€“
denoted as Cc, respectively. Now we present the inference of
CVDG-level corruption path as summarized in Figure 7.
If the initial digression is between xI and rI, we can infer
that xI failed to track rI. There are three possible causes for
this, which correspond to different CVDG-level corruption
paths:
â€¢ Type I: xI was corrupted â€œlocallyâ€ during the sensor input
data processing (e.g., ï¬ltering). In the CVDG, such cor-
ruption corresponds to path S â†’ xI â†’ rc as described in
Figure 7a.
â€¢ Type II: xI was corrupted indirectly via the control feed-
back loop. In this case, the control parameter kI was ï¬rst
corrupted via GCS input (e.g., a parameter-changing com-
mand), which then corrupted rc, the output of CI. In Ccâ€™s
effort to track the corrupted rc, it generated the corrupted
reference for its own child controller, and so on so forth.
Finally, the RAV motors physically changed the vehicleâ€™s
state, leading to the anomalous change of xI. In the CVDG,
(a) Type I CVDG-level path
(b) Type II CVDG-level path
(c) Type III CVDG-level path
(d) Type IV CVDG-level path
Figure 7: Summary of CVDG-level corruption paths accord-
ing to different corruption types.
such corruption corresponds to path P â†’ kI â†’ rc as de-
scribed in Figure 7b.
â€¢ Type III: xI was similarly (to Type II) corrupted via the
control feedback loop, due to the corruption of rc. Unlike
Type II, rcâ€™s corruption was not triggered by external input.
Instead, it was caused by some execution anomaly along
CVDG edge xI â†’ rc or rI â†’ rc as described in Figure 7c.
We point out that, between xI and rI, rI cannot be initially
corrupted by CIâ€™s parent (upstream) controller. This can be
proved by contradiction based on the CVDG model: If rI were
initially corrupted by its parent controller Cp, the corruption
would have happened before CIâ€™s initial digression. However,
without CIâ€™s digression, Cp would not be triggered by the
control feedback loop to generate a corrupted rI, unless CI
experienced a digression itself. But that would contradict with
the fact that CI is the ï¬rst digressing controller.
To determine if an accident is caused by Type I or II/III
corruption path, MAYDAY needs to check if xI is corrupted
locally or indirectly. This is done by checking the state consis-
tency between CI and Cc (i.e., between xI and xc). Intuitively,
the state consistency is an indication that Cc makes control
decisions following the â€œguidanceâ€ â€“ either right or wrong
â€“ of CI; and the observation of Cc is consistent â€“ according
to physics laws â€“ with that of CI. For example, if CI is a ve-
locity controller and Cc is an acceleration controller, then xI
(velocity) is consistent with xc (acceleration), provided that
the observed velocity xI closely matches the velocity com-
puted using the actual acceleration xc (via integration) in each
iteration. 1 Since xc did not digress from rc when xI digressed
from rI (by CIâ€™s deï¬nition), if xI and xc are consistent, then we
can infer that xI is not locally corrupted and the CVDG-level
path for xIâ€™s corruption should be of Type II or III. Otherwise,
the corruption path for xIâ€™s corruption should be of Type I.
If the initial digression is between rI and mission input M
1The formal deï¬nition of state consistency is given in Appendix A.
USENIX Association
29th USENIX Security Symposium    919
áˆ¶ğ‘¥ğ¼áˆ·ğ‘¥ğ‘áˆ¶ğ‘Ÿğ¼áˆ·ğ‘Ÿğ‘ParentControllerğ‘¥ğ‘ğ‘Ÿğ‘ğ‘˜ğ‘áˆ¶ğ‘˜ğ¼áˆ·ğ‘˜ğ‘ChildControllerPSMInitialDigressingControlleráˆ¶ğ‘¥ğ¼áˆ·ğ‘¥ğ‘áˆ¶ğ‘Ÿğ¼áˆ·ğ‘Ÿğ‘ParentControllerğ‘¥ğ‘ğ‘Ÿğ‘ğ‘˜ğ‘áˆ¶ğ‘˜ğ¼áˆ·ğ‘˜ğ‘InitialDigressingControllerChildControllerPSMáˆ¶ğ‘¥ğ¼áˆ·ğ‘¥ğ‘áˆ¶ğ‘Ÿğ¼áˆ·ğ‘Ÿğ‘ParentControllerğ‘¥ğ‘ğ‘Ÿğ‘ğ‘˜ğ‘áˆ¶ğ‘˜ğ¼áˆ·ğ‘˜ğ‘ChildControllerPSMInitialDigressingControlleráˆ¶ğ‘¥ğ¼áˆ·ğ‘¥ğ‘áˆ¶ğ‘Ÿğ¼áˆ·ğ‘Ÿğ‘ParentControllerğ‘¥ğ‘ğ‘Ÿğ‘ğ‘˜ğ‘áˆ¶ğ‘˜ğ¼áˆ·ğ‘˜ğ‘ChildControllerPSMInitialDigressingController(Type IV), we can infer that a mission input (e.g., a GCS
command to change trajectory or velocity) must have led to
the change of rI; and the new rI value made CI malfunction.
In the CVDG, the corruption of rI happened on path M â†’ rI,
as described in Figure 7d. Similar to Types I-III, we can prove
that the parent controller of CI cannot initially corrupt rI.
In summary, Table 1 shows all four types of CVDG-level
corruption paths and their determination conditions, to be ap-
plied during the investigation. Notice that the four types fully
cover the CVDG edges in the initial digressing controller.
Table 1: Four types of CVDG-level corruption paths.
CVDG-Level
Corruption Path
S â†’ xI â†’ rc
P â†’ kI â†’ rc
xI â†’ rc; rI â†’ rc
xI and xc
Consistent?
Initially Corrupted
Initial Digressing
Variables
Variable
Type
Between rI and xI
Between rI and xI
Between rI and xI
Between M and rI
No
Yes
Yes
Yes
M â†’ rI
I
II
III
IV
xI
kI
rc
rI
6.2 Program-Level Investigation
The control-level investigation generates two outputs: (1) the
initial digressing controller (and time) and (2) the CVDG-
level corruption path that had led to the digression. With these
outputs, MAYDAY transitions to its program-level investiga-
tion, analyzing a narrowed-down scope of the control program
execution log. The ï¬nal result of this investigation is a small
subset of control program code (in basic blocks) where the
bug causing the accident can be located.
6.2.1 Transition to Program-Level Investigation
MAYDAY ï¬rst makes the following preparations: (1) mapping
the control variables on the CVDG-level corruption path to
program variables, based on the control model â†’ program
mapping established during the ofï¬‚ine analysis (Section 5);
(2) locating the program trace for the initial digressing iter-
ation â€“ recall that the log has been indexed by control loop
iteration number â€“ as the starting point for (backward) log
analysis; and (3) restoring the LLVM instruction trace from
the encoded log for LLVM bitcode-level data ï¬‚ow analysis.
6.2.2 CVDG-Guided Program Trace Analysis
MAYDAY ï¬rst identiï¬es the data ï¬‚ows of program-level vari-
able corruptions representing the CVDG-level corruption path.
It runs Algorithm 2 to identify such data ï¬‚ows, starting from
the initial digressing iteration and going backward. There are
four inputs to Algorithm 2: (1) the restored LLVM bitcode-
level program trace, indexed by control loop iteration number;
(2) the initial digressing iteration number (idigress); (3) the
source and sink program variables that correspond to the start
and ending nodes on the CVDG-level corruption path; 2 (4)
the mapping between instructions in the trace and the program
basic blocks they belong to. The output of Algorithm 2 is a
2For a Type II CVDG-level path (Table 1), we also identify the program
variable that corresponds to the intermediate node kI on path P â†’ kI â†’ rc.
(cid:46) Get program-level data ï¬‚ows
(cid:46) Control loop iteration with the triggering input
(cid:46) Find additional data ï¬‚ows
Algorithm 2 Identiï¬cation of basic blocks implementing a
CVDG-level corruption path.
Input: CVDG (G), decoded program execution logs (L), CVDG-level corruption
path (Pcvdg), control loop iteration with initial digression (idigress)
Output: A set of basic blocks of the program-level corruption paths
1: Pprog â† BACKTRACK(Pcvdg,0,idigress)
2: itrigger â† Pprog.istart
3: while itrigger â‰¤ idigress do
idigress â† Pprog.iend âˆ’ 1
4:
Pprog â† Pprog âˆª BACKTRACK(Pcvdg,itrigger,idigress)
5:
6: return GETBB(Pprog)
7: function BACKTRACK(Pcvdg,istart ,iend)
8:
9:
10:
11:
12: function BACKTRACKSRCSINK(src,sink,istart ,iend)
13:
14:
15:
16:
17:
18:
19:
20:
21:
(cid:46) Backtrack the executed paths at every iteration
Pi â† G.GETDATAFLOWPATHS(L[i],src,sink) (cid:46) Between source and sink
for p âˆˆ Pi do
Pprog â† Pprog âˆª BACKTRACKSRCSINK(e.src,e.sink,istart ,iend )
if src = sink then
Pprog â† /0
for i âˆˆ {iend ...istart} do
Pprog â† Pprog âˆª BACKTRACKSRCSINK(src,sinkp,istart ,i)
Pprog â† /0
for e âˆˆ Pcvdg do
for sinkp âˆˆ p.sinks do
(cid:46) Consider intermediate variables
return Pprog
return Pprog
return /0
small subset of control program basic blocks that may have
been involved in the CVDG-level corruption path.
To explain Algorithm 2, we show a simple example in
Fig. 8: The initial digressing controller is the x-axis velocity
controller, and the CVDG-level corruption path is P â†’ Ë™kx â†’
Â¨rx. The initial digressing time is Iteration 4930. P, Ë™kx, and
Â¨rx are mapped to program variables (msg, _pi_vel_xy._kp,
and _accel_target.x). Algorithm 2 starts from the sink
variable (_accel_target.x) in Iteration idigress (4930) and
ï¬nds a variable-corruption data ï¬‚ow from source variable
msg, through intermediate variable _pi_vel_xy._kp (Line 1,
7-21), to sink variable _accel_target.x. Data ï¬‚ows that go
through the intermediate variables (e.g., _pi_vel_xy._kp)
are reconstructed using the additional sink information (Line
19-20). This information is retrieved via backward slicing
(Line 17) as described in Section 5.2. In Fig. 8, the data ï¬‚ow is
P4850 â†’ Ë™kx,4850 â†’ V4,4850 â†’ V8,4929 â†’ Â¨rx,4930, which realizes
CVDG-level path P â†’ Ë™kx â†’ Â¨rx. In particular, Iteration 4850
is the starting iteration of control variable corruption with the
triggering input (P). We denote this iteration as itrigger.
After identifying the latest (relative to idigress) program-
level variable corruption data ï¬‚ow, Algorithm 2 will con-
tinue to identify all earlier data ï¬‚ows that reï¬‚ect the same
CVDG-level corruption path between Iterations itrigger and
idigress (Line 3-5, 7-21). In Fig. 8, such an earlier data ï¬‚ow is
P4850 â†’ Ë™kx,4850 â†’ V4,4850 â†’ V8,4851 â†’ Â¨rx,4852. We point out
that, different from traditional program analysis, MAYDAY
needs to capture the inï¬‚uence on the corrupted control vari-
able (Â¨rx) in multiple control loop iterations towards (and in-
cluding) idigress. This is because, in a control system, each
update to that variable may contribute to the ï¬nal digression
of the controller â€“ either directly or via the control feedback
loop â€“ and hence should be held accountable.
Once Algorithm 2 ï¬nds all the data ï¬‚ows of program-level
920    29th USENIX Security Symposium
USENIX Association
Figure 8: An example showing the working of Algorithm 2.
variable corruption, it can identify the corresponding basic
blocks that implement each of the corrupting data ï¬‚ows (Line
6). In most cases, the multiple data ï¬‚ows will be mapped to
the same set of program basic blocks, because of the iterative
nature of control program execution. For example, the two
corruption data ï¬‚ows in Fig. 8 share the common segment
V4 â†’ V8 â†’ Â¨rx implemented by the same set of basic blocks.
This helps keep the number of basic blocks reported by Algo-
rithm 2 small, making it easy for investigators to examine the
source code of those basic blocks to ï¬nally pinpoint the bug
that caused the accident.
7 Implementation
We have implemented MAYDAY for an IRIS+ quadrotor with
a Raspberry Pi 3 Model B (RPi) [17] as the main processor
board powered by a 1.2 GHz 64 bit quadcore ARM Cortex-
A53 CPU with 1 GB SDRAM. Attached to the RPi are a
Navio2 sensor board and a 64 GB SD card. The sensor board
has a number of sensors (GPS, gyroscope, barometer, etc.)
and is equipped with four actuators and a telemetry radio
signal receiver. The control program is the popular ArduPilot
3.4 on Linux 4.9.45, with the main control loop running at a
default frequency of 400 Hz.
For MAYDAYâ€™s control program analysis (Section 5.2), we
leverage the SVF 1.4 static analysis tool [72] for the points-to
analysis. We modiï¬ed SVF to support our inter-procedural
backward slicing and control program instrumentation on
LLVM 4.0. MAYDAYâ€™s control- and program-level investiga-
tion functions (Section 6) are implemented in Python 2.7.6.
The entire MAYDAY system contains 10,239 lines of C++
code and 7,574 lines of Python code.
8 Evaluation
We evaluate MAYDAYâ€™s effectiveness with respect to RAV
accident investigation (Section 8.1) and bug localization (Sec-
tion 8.2); and MAYDAYâ€™s efï¬ciency with respect to runtime,
storage, and energy overhead (Section 8.3).
8.1 Effectiveness of Accident Investigation
Summary of Cases We investigated 10 RAV accidents
based on real control-semantic bugs in ArduPilot 3.4. Table 2
summarizes the nature of the 10 accidents, with respect to cat-
egorization, physical impact, triggering condition, nature of
control program bug, patching status, and vulnerability status.
We chose these cases by the following criteria: (1) their root
causes are real control-semantic bugs; (2) the speciï¬c nature
of the bugs should be representative (e.g., invalid control/mis-
sion parameter values, integer overï¬‚ow, and divide-by-zero);
(3) the initial digressing controllers in these cases should
cover all six degrees of 6DoF; and (4) the CVDG corruption
paths in these cases should show diversity.
Speciï¬cally, Cases 1-4 are caused by controller parameter
corruption, which corresponds to Type II CVDG-level path
in Table 1 (Section 6.1) and results in unrecoverable vehicle
instability, deviation, or even crashes. Cases 5-7 are caused by
corruption of ï¬‚ight missions (e.g., location, velocity), which
corresponds to Type IV CVDG-level path in Table 1. Cases 8-
10 are caused by data (e.g., sensor or GCS input) processing
errors such as divide-by-zero, which corresponds to either
Type I (Case 10) or Type II (Cases 8-9) CVDG-level path in
Table 1.
The root causes of these accidents are real control-semantic
bugs that exist in ArduPilot 3.4 or earlier. The ones in Cases 5-
10 are known bugs that have since been patched; whereas the
bugs in Cases 1-4 still exist in the later version of ArduPilot
3.5. Our code review shows that the patches for those four
bugs only ï¬x the RAVâ€™s pre-ï¬‚ight parameter-check code, but
not the in-ï¬‚ight parameter adjustment code. We alerted the
ArduPilot team that the bugs in Cases 1-4 are not fully patched.
Their reply was that, the four bugs were recently reported and
conï¬rmed along with other â€œinvalid parameter range checkâ€
bugs. However, if ArduPilot ï¬xes every parameter check, the
ï¬rmware size may not ï¬t in the memory of some resource-
constrained micro-controllers supported by ArduPilot 3.
the
patch commit numbers
The â€œPatch Commit Numberâ€ column in Table 2
cases.
shows
Detailed ArduPilot
includ-
ing the code snippets involved, can be accessed at:
https://github.com/ArduPilot/ardupilot/commit/[commit
number].
bug-patching
for all
history,
Note that these accidents are not easy to reproduce or in-
vestigate. Their occurrences depend on vehicle-, control-, and
program-level conditions. For example, the control program
bugs may be triggered only when the vehicle takes a certain
trajectory (Cases 1-4) and/or accepts a certain controller pa-