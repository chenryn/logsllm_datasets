# 09 \| exception：怎样才能用好异常？你好，我是 Chrono。上节课，我建议尽量不用裸指针、new 和delete，因为它们很危险，容易导致严重错误。这就引出了一个问题，如何正确且优雅地处理运行时的错误。实际上，想要达成这个目标，还真不是件简单的事情。程序在运行的时候不可能"一帆风顺"，总会遇到这样那样的内外部故障，而我们写程序的人就要尽量考虑周全，准备各种"预案"，让程序即使遇到问题也能够妥善处理，保证"健壮性"。C++ 处理错误的标准方案是"异常"（exception）。虽然它已经在Java、C#、Python 等语言中得到了广泛的认可和应用，但在 C++里却存在诸多争议。你也可能在其他地方听到过一种说法："**现代 C++里应该使用异常**。"但这之后呢？应该怎么去用异常呢？所以，今天我就和你好好聊聊"异常那些事"，说一说为什么要有异常，该怎么用好异常，有哪些要注意的地方。为什么要有异常？很多人认为，C++里的"异常"非常可怕，一旦发生异常就是"了不得的大事"，这其实是因为没有理解异常的真正含义。实际上，你可以按照它的字面意思，把它理解成"**异于正常**"，就是正常流程之外发生的一些特殊情况、严重错误。一旦遇到这样的错误，程序就会跳出正常流程，甚至很难继续执行下去。归根到底，**异常只是 C++为了处理错误而提出的一种解决方案，当然也不会是唯一的一种**。在 C++之前，处理异常的基本手段是"错误码"。函数执行后，需要检查返回值或者全局的errno，看是否正常，如果出错了，就执行另外一段代码处理错误：    int n = read_data(fd, ...);    // 读取数据    if (n == 0) {      ...                    // 返回值不太对，适当处理    }    if (errno == EAGAIN) {      ...                    // 适当处理错误    }这种做法很直观，但也有一个问题，那就是**正常的业务逻辑代码与错误处理代码混在了一起**，看起来很乱，你的思维要在两个本来不相关的流程里来回跳转。而且，有的时候，错误处理的逻辑要比正常业务逻辑复杂、麻烦得多，看了半天，你可能都会忘了它当初到底要干什么了，容易引起新的错误。（你可以对比一下预处理代码与C++ 代码混在一起的情景。）错误码还有另一个更大的问题：**它是可以被忽略的**。也就是说，你完全可以不处理错误，"假装"程序运行正常，继续跑后面的代码，这就可能导致严重的安全隐患。（可能是无意的，因为你确实不知道发生了什么错误。）"没有对比就没有伤害"，现在你就应该明白了，作为一种新的错误处理方式，异常就是针对错误码的缺陷而设计的，它有三个特点。1.       **异常的处理流程是完全独立的**        ，throw    抛出异常后就可以不用管了，错误处理代码都集中在专门的 catch    块里。这样就彻底分离了业务逻辑与错误逻辑，看起来更清楚。        2.       **异常是绝对不能被忽略的，必须被处理**        。如果你有意或者无意不写 catch    捕获异常，那么它会一直向上传播出去，直至找到一个能够处理的 catch    块。如果实在没有，那就会导致程序立即停止运行，明白地提示你发生了错误，而不会"坚持带病工作"。        3.       **异常可以用在错误码无法使用的场合**        ，这也算是 C++ 的"私人原因"。因为它比 C 语言多了构造    /    析构函数、操作符重载等新特性，有的函数根本就没有返回值，或者返回值无法表示错误，而全局的    errno 实在是"太不优雅"了，与 C++    的理念不符，所以也必须使用异常来报告错误。        记住这三个关键点，是在 C++里用好异常的基础，它们能够帮助你在本质上理解异常的各种用法。异常的用法和使用方式C++里异常的用法想必你已经知道了：**用 try 把可能发生异常的代码"包"起来，然后编写 catch块捕获异常并处理**。刚才的错误码例子改用异常，就会变得非常干净清晰：    try    {      int n = read_data(fd, ...);    // 读取数据，可能抛出异常            ...                         // do some right thing          catch(...)    {        ...                       // 集中处理各种错误情况    }基本的 try-catch谁都会写，那么，怎样才能用好异常呢？首先你要知道，C++ 里对异常的定义非常宽松，任何类型都可以用 throw抛出，也就是说，你可以直接把错误码（int）、或者错误消息（char\*、string）抛出，catch也能接住，然后处理。但我建议你最好不要"图省事"，因为 C++已经为处理异常设计了一个配套的异常类型体系，定义在标准库的 \头文件里。 下面我画了个简单的示意图，你可以看一下。![](Images/a687ad77d261e06abb121700642d7bb0.png)savepage-src="https://static001.geekbang.org/resource/image/8b/67/8ba78367ce53d54a393a8963bb62e867.jpg"}标准异常的继承体系有点复杂，最上面是基类exception，下面是几个基本的异常类型，比如bad_alloc、bad_cast、runtime_error、logic_error，再往下还有更细致的错误类型，像runtime_error 就有range_error、overflow_error，等等。我在 [第 5节课  slate-object="inline"讲过，如果继承深度超过三层，就说明有点"过度设计"，很明显现在就有这种趋势了。所以，我建议你最好选择上面的第一层或者第二层的某个类型作为基类，不要再加深层次。比如说，你可以从 runtime_error派生出自己的异常类：    class my_exception : public std::runtime_error    {    public:        using this_type     = my_exception;        // 给自己起个别名        using super_type    = std::runtime_error;  // 给父类也起个别名    public:        my_exception(const char* msg):            // 构造函数            super_type(msg)                      // 别名也可以用于构造        {}          my_exception() = default;                // 默认构造函数       ~my_exception() = default;                // 默认析构函数    private:        int code = 0;                            // 其他的内部私有数据    };在抛出异常的时候，我建议你最好不要直接用 throw关键字，而是要封装成一个函数，这和不要直接用 new、delete关键字是类似的道理------**通过引入一个"中间层"来获得更多的可读性、安全性和灵活性**。抛异常的函数不会有返回值，所以应该用第 4 节课slate-object="inline"里的"属性"做编译阶段优化：    [[noreturn]]                      // 属性标签    void raise(const char* msg)      // 函数封装throw，没有返回值    {        throw my_exception(msg);     // 抛出异常，也可以有更多的逻辑    }使用 catch 捕获异常的时候也要注意，C++ 允许编写多个 catch块，捕获不同的异常，再分别处理。但是，**异常只能按照 catch块在代码里的顺序依次匹配，而不会去找最佳匹配**。这个特性导致实际开发的时候有点麻烦，特别是当异常类型体系比较复杂的时候，有可能会因为写错了顺序，进入你本不想进的catch 块。所以，**我建议你最好只用一个 catch块，绕过这个"坑"**。写 catch 块就像是写一个标准函数，所以入口参数也应当使用"const&"的形式，避免对象拷贝的代价：    try    {        raise("error occured");     // 函数封装throw，抛出异常    }    catch(const exception& e)      // const &捕获异常，可以用基类    {        cout ）。 当然了，实际开发中不会有这么简单的 lambda表达式，它的函数体里可能会有很多语句，所以一定**要有良好的缩进格式**------特别是有嵌套定义的时候，尽量让人能够一眼就看出lambda表达式的开始和结束，必要的时候可以用注释来强调。    auto f2 = []()                 // 定义一个lambda表达式    {        cout  v = {3, 1, 8, 5, 0};     // 标准容器    cout = 5;        // 用做算法的谓词判断条件                 }                        // lambda表达式结束            )         ```    int x = 33;               // 一个外部变量    auto f1 = [=]()           // lambda表达式，用“=”按值捕获    {        //x += 10;            // x只读，不允许修改    };    auto f2 = [&]()         // lambda表达式，用“&”按引用捕获    {        x += 10;            // x是引用，可以修改    };    auto f3 = [=, &x]()       // lambda表达式，用“&”按引用捕获x，其他的按值捕获    {        x += 20;              // x是引用，可以修改    };"捕获"也是使用 lambda表达式的一个难点，关键是要理解"**外部变量**"的含义。我建议，你可以简单地按照其他语言的习惯，称之为"**upvalue**"，也就是在 lambda表达式定义之前所有出现的变量，不管它是局部的还是全局的。这就有一个变量生命周期的问题。使用"\[=\]"按值捕获的时候，lambda表达式使用的是变量的独立副本，非常安全。而使用"\[&\]"的方式捕获引用就存在风险，当lambda表达式在离定义点"很远的地方"被调用的时候，引用的变量可能发生了变化，甚至可能会失效，导致难以预料的后果。所以，我建议你在使用捕获功能的时候要小心，对于"就地"使用的小 lambda表达式，可以用"\[&\]"来减少代码量，保持整洁；而对于非本地调用、生命周期较长的lambda表达式应慎用"\[&\]"捕获引用，而且，最好是在"\[\]"里显式写出变量列表，避免捕获不必要的变量。    class DemoLambda final    {    private:        int x = 0;    public:        auto print()              // 返回一个lambda表达式供外部使用        {            return [this]()      // 显式捕获this指针            {                cout ;  // string其实是一个类型别名这个特化是什么意思呢？所谓的字符串，就是字符的序列。字符是人类语言、文字的计算机表示，而人类语言、文字又有很多种，相应的编码方式也有很多种。所以，C++就为字符串设计出了模板类basic_string，再用模板来搭配不同的字符类型，就能够更有"弹性"地处理各种文字了。说到字符和编码，就不能不提到Unicode，它的目标是用一种编码方式统一处理人类语言文字，使用 32 位（4个字节）来保证能够容纳过去或者将来所有的文字。但这就与 C++ 产生了矛盾。因为 C++ 的字符串源自 C，而 C里的字符都是单字节的 char 类型，无法支持Unicode。 为了解决这个问题，C++ 就又新增了几种字符类型。C++98 定义了wchar_t，到了 C++11，为了适配 UTF-16、UTF-32，又多了char16_t、char32_t。于是，basic_string在模板参数里换上这些字符类型之后，就可以适应不同的编码方式了。    using wstring = std::basic_string;    using u16string = std::basic_string;    using u32string = std::basic_string;不过在我看来，虽然 C++做了这些努力，但其实收效并不大。因为字符编码和国际化的问题实在是太复杂了，仅有这几个基本的字符串类型根本不够，而C++一直没有提供处理编码的配套工具，我们只能"自己造轮子"，用不好反而会把编码搞得一团糟。这就导致 wstring等新字符串基本上没人用，大多数程序员为了不"自找麻烦"，还是选择最基本的string。万幸的是 Unicode 还有一个 UTF-8 编码方式，与单字节的 char完全兼容，用 string也足以适应大多数的应用场合。所以，我也建议你只用 string，而且在涉及Unicode、编码转换的时候，尽量不要用C++，目前它还不太擅长做这种工作，可能还是改用其他语言来处理更好。接下来，我就讲一讲，该怎么用好String。 用好字符串string 在 C++标准库里的身份也是比较特殊，虽然批评它的声音有不少，比如接口复杂、成本略高，但不像容器、算法，直到现在，仍然有且只有这么一个字符串类，"只此一家，别无分号"。所以，在这种"别无选择"的情况下，我们就要多了解它的优缺点，尽量用好它。首先你要看到，string是一个功能比较齐全的字符串类，可以提取子串、比较大小、检查长度、搜索字符......基本满足一般人对字符串的"想象"。    string str = "abc";    assert(str.length() == 3);     assert(str `，它的含义十分"纯粹"，只存储字符，没有string那些不必要的成本，用起来也就更灵活一些。接下来我们再看看 string的一些小技巧。**1. 字面量后缀**C++11为方便使用字符串，新增了一个字面量的**后缀"s"**，明确地表示它是 string 字符串类型，而不是 C字符串，这就可以利用 auto来自动类型推导，而且在其他用到字符串的地方，也可以省去声明临时字符串变量的麻烦，效率也会更高：    using namespace std::literals::string_literals;  //必须打开名字空间    auto str = "std string"s;      // 后缀s，表示是标准字符串，直接类型推导    assert("time"s.size() == 4);   // 标准字符串可以直接调用成员函数不过要提醒你的是，**为了避免与用户自定义字面量的冲突，后缀"s"不能直接使用，必须用using 打开名字空间才行**，这是它的一个小缺点。**2. 原始字符串**C++11 还为字面量增加了一个"**原始字符串**"（Raw stringliteral）的新表示形式，比原来的引号多了一个大写字母 R和一对圆括号，就像下面这样：    auto str = R"(nier:automata)";    // 原始字符串：nier:automata这种形式初看上去显得有点多余，它有什么好处呢？你一定知道，C++的字符有"转义"的用法，在字符前面加上一个"\\"，就可以写出"\\n""\\t"来表示回车、跳格等不可打印字符。但这个特性也会带来麻烦，有时我们不想转义，只想要字符串的"原始"形式，在C++里写起来就很难受了。特别是在用正则表达式的时候，由于它也有转义，两个转义效果"相乘"，就很容易出错。比如说，我要在正则里表示"`\$`"，需要写成\"`\\\$`\"，而在 C++里需要对"\\"再次转义，就是"`\\\\\\$`"，你能数出来里面到底有多少个"\\"吗？如果使用原始字符串的话，就没有这样的烦恼了，它不会对字符串里的内容做任何转义，完全保持了"原始风貌"，即使里面有再多的特殊字符都不怕：    auto str1 = R"(char""'')";    // 原样输出：char""''    auto str2 = R"(\r\n\t\")";    // 原样输出：\r\n\t\"    auto str3 = R"(\\\$)";        // 原样输出：\\\$    auto str4 = "\\\\\\$";         // 转义后输出：\\\$不过，想要在原始字符串里面写引号 +圆括号的形式该怎么办呢？对于这个问题，C++ 也准备了应对的办法，就是在圆括号的两边加上最多 16个字符的特别"界定符"（delimiter），这样就能够保证不与字符串内容发生冲突：    auto str5 = R"==(R"(xxx)")==";// 原样输出：R"(xxx)"**3. 字符串转换函数**在处理字符串的时候，我们还会经常遇到与数字互相转换的事情，以前只能用C 函数 atoi()、atol()，它们的参数是 C 字符串而不是string，用起来就比较麻烦，于是，C++11就增加了几个新的转换函数：1.  stoi()、stol()、stoll()    等把字符串转换成整数；        2.  stof()、stod()    等把字符串转换成浮点数；        3.  to_string()    把整数、浮点数转换成字符串。        这几个小函数在处理用户数据、输入输出的时候，非常方便：    assert(stoi("42") == 42);          // 字符串转整数    assert(stol("253") == 253L);       // 字符串转长整数    assert(stod("2.0") == 2.0);       // 字符串转浮点数    assert(to_string(1984) == "1984");       // 整数转字符串**4. 字符串视图类**再来说一下 string的成本问题。它确实有点"重"，大字符串的拷贝、修改代价很高，所以我们通常都尽量用const string&，但有的时候还是无法避免（比如使用 C字符串、获取子串）。如果你对此很在意，就有必要找一个"轻量级"的替代品。在 C++17 里，就有这么一个完美满足所有需求的东西，叫string_view。顾名思义，它是一个字符串的视图，成本很低，内部只保存一个指针和长度，无论是拷贝，还是修改，都非常廉价。唯一的遗憾是，它只出现在 C++17 里，不过你也可以参考它的接口，自己在C++11里实现一个简化版本。下面我给你一个简单的示范，你可以课下去扩展：    class my_string_view final        // 简单的字符串视图类，示范实现    {    public:        using this_type = my_string_view;     // 各种内部类型定义        using string_type = std::string;        using string_ref_type = const std::string&;        using char_ptr_type = const char*;        using size_type = size_t;    private:        char_ptr_type ptr = nullptr;     // 字符串指针        size_type len = 0;               // 字符串长度    public:        my_string_view() = default;       ~my_string_view() = default;        my_string_view(string_ref_type str) noexcept            : ptr(str.data()), len(str.length())        {}    public:        char_ptr_type data() const     // 常函数，返回字符串指针        {            return ptr;        }        size_type size() const        // 常函数，返回字符串长度        {            return len;        }    };正则表达式说了大半天，其实我们还是没有回答这节课开头提出的疑问，也就是“在 C++ 里该怎么处理文本”。string 只是解决了文本的表示和存储问题，要对它做大小写转换、判断前缀后缀、模式匹配查找等更复杂的处理，要如何做呢？使用标准算法显然是不行的，因为算法的工作对象是容器，而刚才我就说了，字符串与容器是两个完全不同的东西，大部分算法都无法直接套用到字符串上，所以文本处理也一直是C++ 的"软肋"。好在 C++11 终于在标准库里加入了正则表达式库regex（虽然有点晚），利用它的强大能力，你就能够任意操作文本、字符串。很多语言都支持正则表达式，关于它的语法规则我也就不细说了（课下你可以参考下这个链接：https://www.pcre.org/），我就重点介绍一下在 C++里怎么用。 C++ 正则表达式主要有两个类。1.  regex：表示一个正则表达式，是 basic_regex    的特化形式；        2.  smatch：表示正则表达式的匹配结果，是 match_results    的特化形式。        C++正则匹配有三个算法，注意它们都是"只读"的，不会变动原字符串。1.  regex_match()：完全匹配一个字符串；        2.  regex_search()：在字符串里查找一个正则匹配；        3.  regex_replace()：正则查找再做替换。        所以，你只要用 regex定义好一个表达式，然后再调用匹配算法，就可以立刻得到结果，用起来和其他语言差不多。不过，在写正则的时候，记得最好要用"原始字符串"，不然转义符绝对会把你折腾得够呛。下面我举个例子：    auto make_regex = [](const auto& txt)    // 生产正则表达式    {        return std::regex(txt);    };    auto make_match = []()                  // 生产正则匹配结果    {        return std::smatch();    };    auto str = "neir:automata"s;          // 待匹配的字符串    auto reg =         make_regex(R"(^(\w+)\:(\w+)$)");  // 原始字符串定义正则表达式    auto what = make_match();             // 准备获取匹配的结果这里我先定义了两个简单的 lambda表达式，生产正则对象，主要是为了方便用 auto自动类型推导。当然，同时也隐藏了具体的类型信息，将来可以随时变化（这也有点函数式编程的味道了）。然后我们就可以调用 regex_match() 检查字符串，函数会返回 bool值表示是否完全匹配正则。如果匹配成功，结果存储在 what里，可以像容器那样去访问，第 0号元素是整个匹配串，其他的是子表达式匹配串：    assert(regex_match(str, what, reg));  // 正则匹配    for(const auto& x : what) {          // for遍历匹配的子表达式        cout  arr;                // 初始一个array，长度是2    assert(arr.size() == 2);        // 静态数组的长度总是2    vector v(2);              // 初始一个vector，长度是2    for(int i = 0; i  d;                  // 初始化一个deque，长度是0    d.emplace_back(9);              // 末端添加一个元素    d.emplace_front(1);              // 前端添加一个元素    assert(d.size() == 2);          // 长度动态增长到2vector 和 deque里的元素因为是连续存储的，所以在中间的插入删除效率就很低，而 list 和forward_list是链表结构，插入删除操作只需要调整指针，所以在任意位置的操作都很高效。链表的缺点是查找效率低，只能沿着指针顺序访问，这方面不如 vector随机访问的效率高。list 是双向链表，可以向前或者向后遍历，而forward_list，顾名思义，是单向链表，只能向前遍历，查找效率就更低了。链表结构比起数组结构还有一个缺点，就是存储成本略高，因为必须要为每个元素附加一个或者两个的指针，指向链表的前后节点。vector/deque 和 list/forward_list都可以动态增长来容纳更多的元素，但它们的内部扩容机制却是不一样的。当 vector的容量到达上限的时候（capacity），它会再分配一块两倍大小的新内存，然后把旧元素拷贝或者移动过去。这个操作的成本是非常大的，所以，你在使用vector 的时候最好能够"预估"容量，使用 reserve提前分配足够的空间，减少动态扩容的拷贝代价。vector 的做法太"激进"，而 deque、list的的扩容策略就"保守"多了，只会按照固定的"步长"（例如 N个字节、一个节点）去增加容量。但在短时间内插入大量数据的时候就会频繁分配内存，效果反而不如vector 一次分配来得好。说完了这 5个容器的优缺点，你该怎么选择呢？我的看法是，如果没有什么特殊需求，首选的容器就是 array 和vector，它们的速度最快、开销最低，数组的形式也令它们最容易使用，搭配算法也可以实现快速的排序和查找。剩下的 deque、list 和 forward_list则适合对插入删除性能比较敏感的场合，如果还很在意空间开销，那就只能选择非链表的deque 了。 ![](Images/d263ff2f450e89d26a4db39741eea365.png)savepage-src="https://static001.geekbang.org/resource/image/6a/24/6ac671f2c8523c09343a34811ad7e324.jpg"}有序容器顺序容器的特点是，元素的次序是由它插入的次序而决定的，访问元素也就按照最初插入的顺序。而有序容器则不同，它的元素在插入容器后就被按照某种规则自动排序，所以是"有序"的。C++的有序容器使用的是树结构，通常是红黑树------有着最好查找性能的二叉树。标准库里一共有四种有序容器：set/multiset 和 map/multimap。set是集合，map是关联数组（在其他语言里也叫"字典"）。有 multi 前缀的容器表示可以容纳重复的key，内部结构与无前缀的相同，所以也可以认为只有两种有序容器。因为有序容器的数量很少，所以使用的关键就是要理解它的"有序"概念，也就是说，**容器是如何判断两个元素的"先后次序"，知道了这一点，才能正确地排序**。这就导致了有序容器与顺序容器的另一个根本区别，**在定义容器的时候必须要指定 key的比较函数**。只不过这个函数通常是默认的less，表示小于关系，不用特意写出来：    template class vector;                      // vector    template  // 比较函数    > class set;                        // 集合    template  // 比较函数    > class map;                        // 关联数组C++ 里的 int、string等基本类型都支持比较排序，放进有序容器里毫无问题。但很多自定义类型没有默认的比较函数，要作为容器的key就有点麻烦。虽然这种情况不多见，但有的时候还真是个"刚性需求"。**解决这个问题有两种办法：一个是重载"\ s;                    // 现在就可以正确地放入有序容器    s.emplace(7);    s.emplace(3);另一种方式是编写专门的函数对象或者 lambda表达式，然后在容器的模板参数里指定。这种方式更灵活，而且可以实现任意的排序准则：    set s = {7, 3, 9};           // 定义集合并初始化3个元素    for(auto& x : s) {                // 范围循环输出元素        cout  b;                // 定义大于关系    };      set gs(comp)  // 使用decltype得到lambda的类型    std::copy(begin(s), end(s),          // 拷贝算法，拷贝数据              inserter(gs, gs.end()));  // 使用插入迭代器    for(auto& x : gs) {                // 范围循环输出元素        cout ;      // 使用无序关联数组    map_type dict;                      // 定义一个无序关联数组    dict[1] = "one";                      // 添加三个元素    dict.emplace(2, "two");    dict[10] = "ten";    for(auto& x : dict) {                // 遍历输出        cout "           // 顺序不确定             ,        // 计算散列值的函数对象        class KeyEqual = std::equal_to // 相等比较函数    > class unordered_map; 它要求 key具备两个条件，一是**可以计算 hash值**，二是**能够执行相等比较操作**。第一个是因为散列表的要求，只有计算 hash值才能放入散列表，第二个则是因为 hash 值可能会冲突，所以当 hash值相同时，就要比较真正的 key值。 与有序容器一样，要把自定义类型作为 key放入无序容器，必须要实现这两个函数。"=="函数比较简单，可以用与"\()(p.x);  // 调用标准hash函数对象计算    };有了相等函数和散列函数，自定义类型也就可以放进无序容器了：    unordered_set s(10, hasher);    s.emplace(7);    s.emplace(3);有序容器和无序容器的接口基本一样，这两者该如何选择呢？其实看数据结构就清楚了，**如果只想要单纯的集合、字典，没有排序需求，就应该用无序容器，没有比较排序的成本，它的速度就会非常快**。小结好了，今天我从数据结构的角度全面介绍了 C++标准库里的各种容器，只要你了解这些容器的基本特性，知道内部结构上的优缺点，今后在写程序的时候，也就不会再犯"选择困难症"了。判断容器是否合适的基本依据是"**不要有多余的操作**"，也就是说，不要为不需要的功能付出代价。比如，只在末尾添加元素，就不要用deque/list；只想快速查找元素，不用排序，就应该选unordered_set。再简单小结一下今天的内容：1.       标准容器可以分为三大类，即顺序容器、有序容器和无序容器；        2.       所有容器中最优先选择的应该是 array 和    vector，它们的速度最快，开销最低；        3.       list    是链表结构，插入删除的效率高，但查找效率低；        4.       有序容器是红黑树结构，对 key    自动排序，查找效率高，但有插入成本；        5.       无序容器是散列表结构，由 hash    值计算存储位置，查找和插入的成本都很低；        6.       有序容器和无序容器都属于关联容器，元素有 key    的概念，操作元素实际上是在操作 key，所以要定义对 key    的比较函数或者散列函数。        ![](Images/28d6237cd4731dc30a55cbba23a87a0e.png)savepage-src="https://static001.geekbang.org/resource/image/8e/85/8e935b3e8573ab5a6eb417c314cea285.jpg"}我再教你一个使用这些容器的小技巧，就是**多利用类型别名，而不要"写死"容器定义**。因为容器的大部分接口是相同的，所以只要变动别名定义，就能够随意改换不同的容器，对于开发、测试都非常方便。课下作业最后是课下作业时间，给你留两个思考题：1.       试着用自己的语言说一下这些容器的优点、缺点和区别。        2.       你最喜欢、最常用的是哪种容器？为什么？        欢迎在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。![](Images/447c09f579dda6980edf3458a3328fe1.png)savepage-src="https://static001.geekbang.org/resource/image/18/54/1802953e56e91e6a06e1d601e6f8c854.jpg"}
# 13 \| 五花八门的算法：不要再手写for循环了你好，我是 Chrono。上节课我提到了计算机界的经典公式"算法 + 数据结构 =程序"，公式里的"数据结构"就是 C++里的容器，容器我们已经学过了，今天就来学习下公式里的"算法"。虽然算法是STL（标准库前身）的三大要件之一（容器、算法、迭代器），也是 C++标准库里一个非常重要的部分，但它却没有像容器那样被大众广泛接受。从我观察到的情况来看，很多人都会在代码里普遍应用vector、set、map，但几乎从来不用任何算法，聊起算法这个话题，也是"一问三不知"，这的确是一个比较奇怪的现象。而且，很多语言对算法也不太"上心"。但是，在 C++里，算法的地位非常高，甚至有一个专门的"算法库"。早期，它是泛型编程的示范和应用，而在C++ 引入 lambda表达式后，它又成了函数式编程的具体实践，所以，**学习掌握算法能够很好地训练你的编程思维，帮你开辟出面向对象之外的新天地**。认识算法从纯理论上来说，算法就是一系列定义明确的操作步骤，并且会在有限次运算后得到结果。计算机科学里有很多种算法，像排序算法、查找算法、遍历算法、加密算法，等等。但是在C++里，算法的含义就要狭窄很多了。C++ 里的算法，指的是**工作在容器上的一些泛型函数**，会对容器内的元素实施的各种操作。C++标准库目前提供了上百个算法，真的可以说是"五花八门"，涵盖了绝大部分的"日常工作"。比如：1.  remove，移除某个特定值；        2.  sort，快速排序；        3.  binary_search，执行二分查找；        4.  make_heap，构造一个堆结构；        5.  ......        不过要是"说白了"，算法其实并不神秘，因为所有的算法本质上都是 for 或者while，通过循环遍历来逐个处理容器里的元素。比如说 count算法，它的功能非常简单，就是统计某个元素的出现次数，完全可以用 range-for来实现同样的功能：    vector v = {1,3,1,7,5};    // vector容器    auto n1 = std::count(          // count算法计算元素的数量         begin(v), end(v), 1        // begin()、end()获取容器的范围    );      int n2 = 0;    for(auto x : v) {              // 手写for循环        if (x == 1) {              // 判断条件，然后统计            n2++;        }    }  你可能会问，既然是这样，我们直接写 for循环不就好了吗，为什么还要调用算法来"多此一举"呢？在我看来，这应该是一种"境界"，**追求更高层次上的抽象和封装**，也是函数式编程的基本理念。每个算法都有一个清晰、准确的命名，不需要额外的注释，让人一眼就可以知道操作的意图，而且，算法抽象和封装了反复出现的操作逻辑，也更有利于重用代码，减少手写的错误。还有更重要的一点：和容器一样，算法是由那些"超级程序员"创造的，它的内部实现肯定要比你随手写出来的循环更高效，而且必然经过了良好的验证测试，绝无Bug，无论是功能还是性能，都是上乘之作。如果在以前，你不使用算法还有一个勉强可以说的理由，就是很多算法必须要传入一个函数对象，写起来很麻烦。但是现在，因为有可以"**就地定义函数**"的 lambda表达式，算法的形式就和普通循环非常接近了，所以刚刚说的也就不再是什么问题了。用算法加上 lambda表达式，你就可以初步体验函数式编程的感觉（即函数套函数）：    auto n = std::count_if(      // count_if算法计算元素的数量        begin(v), end(v),       // begin()、end()获取容器的范围        [](auto x) {            // 定义一个lambda表达式            return x > 2;       // 判断条件        }    );                          // 大函数里面套了三个小函数认识迭代器在详细介绍算法之前，还有一个必须要了解的概念，那就是迭代器（iterator），它相当于算法的“手脚”。虽然刚才我说算法操作容器，但实际上它看到的并不是容器，而是指向起始位置和结束位置的迭代器，算法只能通过迭代器去"**间接**"访问容器以及元素，算法的能力是由迭代器决定的。这种间接的方式有什么好处呢？这就是泛型编程的理念，与面向对象正好相反，**分离了数据和操作**。算法可以不关心容器的内部结构，以一致的方式去操作元素，适用范围更广，用起来也更灵活。当然万事无绝对，这种方式也有弊端。因为算法是通用的，免不了对有的数据结构虽然可行但效率比较低。所以，对于merge、sort、unique等一些特别的算法，容器就提供了专门的替代成员函数（相当于特化），这个稍后我会再提一下。C++里的迭代器也有很多种，比如输入迭代器、输出迭代器、双向迭代器、随机访问迭代器，等等，概念解释起来不太容易。不过，你也没有必要把它们搞得太清楚，因为常用的迭代器用法都是差不多的。你可以把它简单地理解为另一种形式的"智能指针"，只是它**强调的是对数据的访问**，而不是生命周期管理。容器一般都会提供 begin()、end()成员函数，调用它们就可以得到表示两个端点的迭代器，具体类型最好用 auto自动推导，不要过分关心：    vector v = {1,2,3,4,5};    // vector容器    auto iter1 = v.begin();        // 成员函数获取迭代器，自动类型推导    auto iter2 = v.end();不过，我建议你使用更加通用的全局函数begin()、end()，虽然效果是一样的，但写起来比较方便，看起来也更清楚（另外还有cbegin()、cend()函数，返回的是常量迭代器）：    auto iter3 = std::begin(v);   // 全局函数获取迭代器，自动类型推导    auto iter4 = std::end(v);迭代器和指针类似，也可以前进和后退，但你不能假设它一定支持"`++`""`--`"操作符，最好也要用函数来操作，常用的有这么几个：1.  distance()，计算两个迭代器之间的距离；        2.  advance()，前进或者后退 N    步；    3.  next()/prev()，计算迭代器前后的某个位置。        你可以参考下面的示例代码快速了解它们的作用：    array arr = {0,1,2,3,4};  // array静态数组容器    auto b = begin(arr);          // 全局函数获取迭代器，首端    auto e = end(arr);            // 全局函数获取迭代器，末端    assert(distance(b, e) == 5);  // 迭代器的距离    auto p = next(b);              // 获取“下一个”位置    assert(distance(b, p) == 1);    // 迭代器的距离    assert(distance(p, b) == -1);  // 反向计算迭代器的距离    advance(p, 2);                // 迭代器前进两个位置，指向元素'3'    assert(*p == 3);    assert(p == prev(e, 2));     // 是末端迭代器的前两个位置最有用的算法接下来我们就要大量使用各种函数，进入算法的函数式编程领域了。手写循环的替代品首先，我带你来认识一个最基本的算法 for_each，它是手写 for 循环的真正替代品。for_each 在逻辑和形式上与 for循环几乎完全相同：    vector v = {3,5,1,7,10};   // vector容器    for(const auto& x : v) {        // range for循环        cout  9;        }    );     for_each(begin(v), pos, print);         // 输出分组后的数据      // min/max    auto value = std::minmax_element(        //找出第一名和倒数第一        cbegin(v), cend(v)    );在使用这些排序算法时，还要注意一点，它们对迭代器要求比较高，通常都是随机访问迭代器（minmax_element除外），所以**最好在顺序容器 array/vector上调用**。如果是 list 容器，应该调用成员函数sort()，它对链表结构做了特别的优化。有序容器 set/map本身就已经排好序了，直接对迭代器做运算就可以得到结果。而对无序容器，则不要调用排序算法，原因你应该不难想到（散列表结构的特殊性质，导致迭代器不满足要求、元素无法交换位置）。查找算法排序算法的目标是让元素有序，这样就可以快速查找，节约时间。算法binary_search，顾名思义，就是在已经排好序的区间里执行二分查找。但糟糕的是，它只返回一个bool 值，告知元素是否存在，而更多的时候，我们是想定位到那个元素，所以binary_search 几乎没什么用。    vector v = {3,5,1,7,10,99,42};  // vector容器    std::sort(begin(v), end(v));        // 快速排序    auto found = binary_search(         // 二分查找，只能确定元素在不在        cbegin(v), cend(v), 7    ); 想要在已序容器上执行二分查找，要用到一个名字比较怪的算法：lower_bound，它返回第一个"**大于或等于**"值的位置：    decltype(cend(v)) pos;            // 声明一个迭代器，使用decltype    pos = std::lower_bound(          // 找到第一个>=7的位置        cbegin(v), cend(v), 7    );      found = (pos != cend(v)) && (*pos == 7); // 可能找不到，所以必须要判断    assert(found);                          // 7在容器里    pos = std::lower_bound(               // 找到第一个>=9的位置        cbegin(v), cend(v), 9    );      found = (pos != cend(v)) && (*pos == 9); // 可能找不到，所以必须要判断    assert(!found);                          // 9不在容器里lower_bound的返回值是一个迭代器，所以就要做一点判断工作，才能知道是否真的找到了。判断的条件有两个，一个是迭代器是否有效，另一个是迭代器的值是不是要找的值。注意 lower_bound的查找条件是"**大于等于**"，而不是"等于"，所以它的真正含义是"大于等于值的第一个位置"。相应的也就有"大于等于值的最后一个位置"，算法叫upper_bound，返回的是第一个"**大于**"值的元素。    pos = std::upper_bound(             // 找到第一个>9的位置        cbegin(v), cend(v), 9    );因为这两个算法不是简单的判断相等，作用有点"绕"，不太好掌握，我来给你解释一下。它俩的返回值构成一个区间，这个区间往前就是所有比被查找值小的元素，往后就是所有比被查找值大的元素，可以写成一个简单的不等式：    begin  s = {3,5,1,7,7,7,10,99,42};  // multiset，允许重复    auto pos = s.find(7);                      // 二分查找，返回迭代器    assert(pos != s.end());                   // 与end()比较才能知道是否找到    auto lower_pos = s.lower_bound(7);       // 获取区间的左端点    auto upper_pos = s.upper_bound(7);       // 获取区间的右端点    for_each(                                // for_each算法        lower_pos, upper_pos, print          // 输出7,7,7    );除了 binary_search、lower_bound 和upper_bound，标准库里还有一些查找算法可以用于未排序的容器，虽然肯定没有排序后的二分查找速度快，但也正因为不需要排序，所以适应范围更广。这些算法以 find 和 search命名，不过可能是当时制定标准时的疏忽，名称有点混乱，其中用于查找区间的find_first_of/find_end，或许更应该叫作search_first/search_last。这几个算法调用形式都是差不多的，用起来也很简单：    vector v = {1,9,11,3,5,7};  // vector容器    decltype(v.end()) pos;          // 声明一个迭代器，使用decltype    pos = std::find(                 // 查找算法，找到第一个出现的位置        begin(v), end(v), 3    );      assert(pos != end(v));         // 与end()比较才能知道是否找到    pos = std::find_if(            // 查找算法，用lambda判断条件        begin(v), end(v),        [](auto x) {              // 定义一个lambda表达式            return x % 2 == 0;    // 判断是否偶数        }    );      assert(pos == end(v));        // 与end()比较才能知道是否找到    array arr = {3,5};    // array容器    pos = std::find_first_of(      // 查找一个子区间        begin(v), end(v),        begin(arr), end(arr)    );      assert(pos != end(v));       // 与end()比较才能知道是否找到小结C++ 里有上百个算法，我们不可能也没办法在一节课的时间里全部搞懂，所以我就精挑细选了一些我个人认为最有用的 for_each、排序和查找算法，把它们介绍给你。在我看来，C++ 里的算法像是一个大宝库，非常值得你去发掘。比如类似memcpy 的 copy/move 算法（搭配插入迭代器）、检查元素的 all_of/any_of算法，用好了都可以替代很多手写 for循环。 你可以课后仔细阅读标准文档slate-object="inline"，对照自己的现有代码，看看哪些能用得上，再试着用算法来改写实现，体会一下算法的简洁和高效。简单小结一下这次的内容：1.       算法是专门操作容器的函数，是一种"智能 for 循环"，它的最佳搭档是    lambda 表达式；        2.       算法通过迭代器来间接操作容器，使用两个端点指定操作范围，迭代器决定了算法的能力；        3.       for_each 算法是 for    的替代品，以函数式编程替代了面向过程编程；        4.       有多种排序算法，最基本的是    sort，但应该根据实际情况选择其他更合适的算法，避免浪费；        5.       在已序容器上可以执行二分查找，应该使用的算法是    lower_bound；        6.       list/set/map    提供了等价的排序、查找函数，更适应自己的数据结构；        7.       find/search    是通用的查找算法，效率不高，但不必排序也能使用。        和上节课一样，我再附送一个小技巧。因为标准算法的名字实在是太普通、太常见了，所以建议你一定要显式写出"std::"名字空间限定，这样看起来更加醒目，也避免了无意的名字冲突。课下作业最后是课下作业时间，给你留两个思考题：1.       你觉得 for_each 算法能完全替代 for    循环吗？        2.       试着自己总结归纳一下，这些排序和查找算法在实际开发中应该如何使用。        欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。![](Images/917f01649ee60e9ef84803e59fe43ec3.png)savepage-src="https://static001.geekbang.org/resource/image/77/d4/77cbcdf7cf05fe7c6fac877649d627d4.jpg"}