5.5 Collecting Pinned VTables
To further investigate our garbage collection performance, we
evaluated the time for VTPin to scan memory and collect pinned
pointers. For this purpose, Table 5 lists the time needed for scan-
ning the heap (which dominates the scanning time) of Mozilla Fire-
fox for collecting 10K, 100K and 1M pinned pointers. All pinned
pointers are stored in one of two C++ unordered_maps, as pro-
vided by STL, and when the heap scan runs one buffer is freed
while the other continues to ﬁll via new free calls. This strat-
egy eliminates the need to block other threads while the heap is
scanned. Our results show that, even for large heap sizes (of sev-
eral MBs), such as the one of Mozilla Firefox, the scanning process
can complete in a few seconds (up to 10 seconds for scanning 10M
of pinned pointers on a single thread). In addition, our results con-
ﬁrm that our garbage collection strategy is heavily parallelizable,
with a scan being up to 3 times faster with 4 threads running on
different cores compared to the single thread scenario. Since such
scan takes place infrequently (every 100 MB of pinned pointers by
default), the overall performance of the protected program is not
affected in practice. This is also reﬂected in the performance over-
head results presented for our benchmarks earlier.
6. RELATED WORK
Many techniques have been proposed for defending against var-
ious exploitation approaches. Control-ﬂow Integrity (CFI) [10] is
a generic concept for ensuring that an attacker cannot tamper-with
the control ﬂow of a running process. In the case of VTable hijack-
ing, CFI can protect the vulnerable program, as VTable pointers
are constrained and thus unable to point-to any foreign VTable in-
troduced at runtime [53]. Alas, CFI requires perfect knowledge of
the Control Flow Graph (CFG), and, in practice, can be only real-
ized as an approximation. Speciﬁcally, all coarse-grained forms of
CFI [60, 61] suffer from inherent limitations and it has been shown
that they can be bypassed [26].
456Benchmark
SPEC CPU2006
483.xalanc
447.dealII
450.soplex/1
450.soplex/2
462.libquantum
444.namd
453.povray
473.astar
Firefox
SunSpider
Kraken
Peacekeeper
Octane
Chromium
SunSpider
Kraken
Peacekeeper
Octane
Vanilla
VTPin (overhead)
183.42
23.3
32.06
4.33
74.66
43.802
174.51
319.3
192.5 (1.049x)
23.73 (1.018x)
32.564 (1.015x)
4.39 (1.013x)
75.19 (1.007x)
44.859 (1.024x)
175.2 (1.004x)
321.76 (1.007x)
400.3ms ± 2.0% 416.7ms ± 3.3% (1.041x)
1,653.3 ± 1.1% 1,674.4 ± 1.2% (1.012x)
2,919 ± 0.4% (1.027x)
2,843 ± 0.1%
18,320 ± 1.5%
18,378 ± 1.9% (1.003x)
3,616ms ±3.1 % 3,668ms ± 1.4% (1.014x)
13,137 ± 1.9% (1.015x)
12,945 ±1.8 %
160 ± 0.7% (1.036x)
166 ±1.4 %
3,636 ± 1.3%
3,670 ± 1.2% (1.009x)
Table 4:
Performance overhead of SPEC CPU2006, and
Firefox and Chromium when running popular web browser
benchmarks. For SunSpider and Kraken, which mainly stress
JavaScript operations, VTPin imposes an overhead of 4.1%
and 1.2%, respectively on Firefox. The overhead imposed to
benchmarks that do not heavily use virtual objects is practi-
cally zero. On the other hand, xalanc, an XML-based bench-
mark, which massively allocates and deallocates memory has
an overhead of 4.9%. Notice, also, that for Firefox/Peacekeeper
the overhead includes the garbage-collection phase, which is
applied when the amount of pinned virtual objects exceeds the
size of 100MB.
Heap size Objects GC (1 thread) GC (4 threads)
64,675 KB
0.60sec
0.71sec
64,675 KB
0.87sec
64,675 KB
0.68sec
128,675 KB
0.77sec
128,675 KB
1.76sec
128,705 KB
2.85sec
512,675 KB
2.94sec
512,675 KB
5.64sec
512,675 KB
1.30sec
1.41sec
1.73sec
1.59sec
2.59sec
2.77sec
6.17sec
9.67sec
10.87sec
10K
100K
1M
10K
100K
1M
10K
100K
1M
Table 5: Time needed for scanning the heap (which dominates
the scanning time) of Mozilla Firefox for collecting 10K, 100K,
and 1M of pinned pointers, respectively. Since this is easily par-
allelizable, duration was also measured when running garbage
collection on 4 CPU cores.
Since VTables are a primary asset for attackers, the research
community has focused on applying narrow-scoped CFI just for
protecting VTables [24, 32, 43, 53, 59]. All techniques that work
with binaries [24, 43, 59] have been demonstrated imperfect, since
recovering correctly all the semantics related to the C++ class hier-
archy (without access to source code) is still an open problem [47].
For techniques that work at the source level [32, 53] it is still ques-
tionable if they are indeed bullet-proof. Compared to all CFI-based
solutions for protecting VTables, VTPin can work directly with bi-
naries, without suffering from problems related to the C++ class
hierarchy [47], and can offer a sound solution.
VTPin protects VTables only from use-after-free vulnerabilities.
This particular type of vulnerability has been addressed by many
studies [15, 33, 57]. However, in contrast to VTPin, for all these
proposals access to source code is required. Another option is to
provide a custom memory allocator that carefully re-uses mem-
ory [11, 13, 38], but this option needs the program allocator to be
replaced. On the other hand, VTPin aims at being as transparent
as possible, and for that reason it is not offered as an allocator re-
placement. In fact, VTPin can be freely used in cooperation with
any custom allocator, even in combination with allocators that pro-
tect against use-after-free bugs, as it handles specially only deal-
locations associated with virtual objects. For example, Cling [11]
protects against use-after-free exploitation, but it is possible for an
object of the same type to be allocated at a memory area previously
occupied. This particular instance of use-after-free vulnerability
can be prevented by VTPin at a low cost, without disabling Cling.
Finally, there are memory analyzers [28, 39, 49], which offer
managed memory allocation, but their imposed overhead is dramat-
ically high, making them suitable only for debugging. In contrast,
VTPin experiences low overheads: 1%–4.1% when running pop-
ular web browser benchmarks, and 0.4%–4.9% when running the
SPEC CPU2006 suite.
7. CONCLUSION
In this paper we proposed VTPin: a system for protecting C++
binaries from VTable hijacking. Compared to existing protection
mechanisms, VTPin exhibits certain characteristics that make it
suitable for practical and instant deployment in production soft-
ware. First, VTPin protects binaries directly without requiring ac-
cess to the source code or relying on complex binary analysis and
rewriting techniques. Second, VTPin is not an allocator replace-
ment, and as such, it does not interfere with the allocator’s strate-
gies and policies; VTPin intervenes in the deallocation process only
when a virtual object is to be freed, so as to preserve the VTable
pointer. Third, VTPin is fast. Mozilla Firefox experiences an over-
head ranging from 1% to 4.1%, on popular browser benchmarks,
while the overhead of SPEC CPU2006 ranges from 0.4% to 4.9%.
Availability
Our prototype implementation of VTPin is freely available at:
https://github.com/uberspot/VTPin.
Acknowledgments
We thank the anonymous reviewers for their valuable comments.
This work was supported by the European Commission through
project H2020 ICT-32-2014 “SHARCS” under Grant Agreement
No. 644571.
8. REFERENCES
[1] Advanced Exploitation of Mozilla Firefox Use-after-free
Vulnerability (MFSA 2012-22). http: