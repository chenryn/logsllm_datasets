setpgid
setsid
setuid
sigaction
sigaddset
sigdelset
sigemptyset
sigfillset
sigismember
signal
sigpending
sigprocmask
puadsns3is
sleep
stat
juoosAs
tedrain
teflow
teflush
tcgetattr
tcgetpgrp
tcsendbreak
tcsetatt
tcsetpgrp
time
times
umask
uname
unlink
utime
wait
waitpid
write
加入java编程群
：524621833
---
## Page 342
324
Linux程序设计
2.常用信号参考
我们将在这一小节对UNIX程序常用的信号和它们的默认行为做一个总结。
表10-7里的信号其默认动作都是进程因随后的_exit调用（它类似于exir，但在返回到内核之
前不做任何扫尾工作）而非正常结束。但它们的结束状态能够传递到wait和waitpid函数里去、
从而指明进程是因某个特定的信号而非正常结束的。
表10-7
偏号名称
说明
SIGALRM
由alarm函数设重的定时器产生
SIGHUP
由一个处于非连接状态的终端发送给随控进程，或者由施控进程在自身结来
时发选给每一个前台进程
SIGINT
般由从终端敲人的“Curl-C”组合键或预先设置好的中新字符产生
SIGKILL
因为这个信号不能被捕捉或屏蔽，所以通常是从shell用来强行结束一个异常
进
SIGPIPE
如果在向一个管道写数据时没有与之对应的读数据进程，就会产生这个信号
SIGTERM
请求其他进程结束运行。UNIX在关机时用这个信号请求系统服务停止运行，
这是kil命令使用的默认信号
SIGUSR1, SIGUSR2
进程可以用这个信号进行通信，比如让进程报告状态信息等
在默认的情况下，表10-8里的信号也会引起进程的非正常结束。但可能会有一些与操作系统
具体实现情况有关的额外动作，比如创建一个core文件等。
表10-8
信号名称
说明
SIGFPE
由浮点算术运算例外产生
SIGILL
处理器执行了一条非法指令。大多是由一个期潢了的程序或者无效的共享内存模块引起
的
SIGQUIT
SIGSEGV
内存段冲奕，--般因对内存中的一个无效地址进行读写面引起，比如超越数组边界或对
无效指针进行操作等。当一个函数返回到一个非法地址的时候，覆盖一个局部数组变量和
引起堆栈期溃都会引发一个SIGSEGV信号
在默认的情况下，进程接收到列在表10-9里的一个信号时会被挂起。
表10-9
信号名称
说明
SIGSTOP
停止执行（不能披械提或屏蔽）
SIGTSTP
终停止信号，通常因按下“Curl-C”组合键产生
SIGTTIN, SIGTTOU
shel用这两个信号表明后台作业因需要从终增读取输人或产生输出而停止
运行
SIGCONT信号的作用是让进程重新开始继续执行，如果进程没有停止，就将忽略它。
SIGCHLD信号在默认情况下总是被忽略的见表10-10。
加入jaVa编程群：524621833
---
## Page 343
第10章进程和信号
325
表10-10
信号名称
说明
SIGCONT
如果是停止的，就开始继续执行
SIGCHID
子进程停止或湛出时产生
10.5本章总结
在这一章里，我们对进程这UNIX操作系统的基石进行了学习。我们学习了如何启动进程，
如何结束进程和如何查看进程；并且用它们解决了一些程序设计问题。
我们还对信号这种可以用来控制程序运行行为的事件进行了研究。我们看到，各种UNIX功
能，包括init在内，都使用着同样的系统调用，每一个程序员都可以利用它们来开发自己的程序。
加入jaVa编程群：524621833
---
## Page 344
第11章POSIX线程
在上一章里，我们学习如何在Linux（事实上是UNIX）中对进程进行处理。UNIX类别的操
作系统早就具备这些多进程功能了，但行时人们认为用fork来创建一个新进程的代价还是太大。
如果能让一个程序同时干两件事，或者至少看起来如此，岂不是更有用。而且，也许用户正希
望两件或更多件事情以一种更密切的关系同时发生呢，
11.1什么是线程
在-个程序里的多个执行路线就叫做线程（thread）：更准确的定义是：线程是“一个进程
内部的个控制序列”。虽然Linux和其他一些操作系统一样很擅长同时运行多个进程，但我们
到目前为止见过的所有程序在执行时都被看做是个进程。事实上，一切进程都至少有一个执
行线程。我们到目前为止见过的所有进程都只有一个执行线程。
fork系统调用和创建新线程是有区别的，弄清楚这一点很重要。当一个进程执行一个fork调
用的时候，会创建出进程的一个新拷贝，新进程将拥有它自已的变量和它自已的PID。这个新进
程的运行时间是独立的，它在执行时（通常）几乎完全独立于创建它的进程。而当我们在进程
里创建一个新线程的时候，新的执行线程会拥有自已的堆栈（因此也就有自己的局部变量），但
要与它的创建者共享全局变量、文件描述符、信号处理器和当前的子目录状态。
线程的概念已经出现很长时间了，但在IEEEPOSIX委员会发布有关标准之前，提供了线程
功能的UNIX类操作系统并不是很多：而具备线程功能的实现版本在具体做法上也会因开发商的
不同面有所差异。POSIX1003.1c技术规范的发布把这一切都改变了；它不仅把线程的标准化工
作向前推进了一大步，也使线程普遍出现在大多数Linux发行版本上。
线程的优点和缺点
在某些情况下，创建一个新线程要比创建一个新进程有更鲜明的优势。而创建一个新线程
的代价要比创建一个新进程小得多。（与其他一些操作系统相比，Linux在创建新进程方面的效
率是很高的。）
有时候，让一个程序看起来好象是在同时做两件事情是很有用的。经典例子是在编辑文本
的同时对文档中的单词个数进行统计。一个线程负贵处理用户的输人并进行着文本的编辑工作，
另一个则不断地刷新着一个单词计数器变址，两个线程都能看见整个文档的内容。第一个线程
（其至可以是第三个线程）通过这个共享的计数器变量让用户能够随时了解自己工作的进展情况。
另一个更具现实意义的例子是多线程的数据库服务器，这是个明显的单进程服务多客户的情
况，它会在响应某些服务请求的同时阻塞另外一些请求使之等待磁盘操作，用这种办法改善整
体上的数据吞吐量。对数据库服务器来说，这个明是的多任务工作如果用多进程的办法来完成
加入java编程群：524621833
---
## Page 345
第II章POSIX线程
327
是很难做到高效率低成本的，因为各个不同的进程必须合作得非常紧密才能满足数据封锁和数
据稳定性方面的要求。可这个工作要是用多线程来完成，就会比多进程容易多了。
线程也有不足之处。因为它们相对来说还算是新牛事物，所以它们不如久经考验的功能那
样具有广泛的群众基础。编写多线程程序需要更全面更深人的思考、在·个多线程程序里，因
时间分配上的细微偏差或者因共享了不该共享的变缺面造成不良影响的可能性是很大的。调试
一个多线程程序也比调试一个单线程程序困难得多。
-个把大量计算分成两个部分并把这两个部分运行为两个线程的程序在一台单处理器机器
上并不见得运行得更快，因为总的计算量还是那么多、并没有因此而减少！
尽管如此，线程还是有大显身手的地方的，比如说，一个混杂着输人、计算和输出的应用
程序就会因把这儿个部分各自运行为三个线程而大大改善其整体性能。当输入或输出线程在等
待数据连接的时候，另外一个线程可以继续执行、因此，如果一个应用程序在任一时刻最多只
能做一项工作，我们就可以让它在等待数据连接之类的东西时另外做些有用的事。
与进程之间的切换相比，线程之间的切换需要操作系统微的工作至少在理论上要少很多一
这意味看线程占用的资源要比进程少很多；并且，如果程序自身的逻辑确实需要有多个执行线
程，在单处理器系统上把它运行为一个多线程程字也更符合实际情况。但在实践上，操作系统
为切换线程而做的工作就不一定总是比切换进程时少了、就拿Linux系统来说吧，它用-个clone
系统调用来实现线程，进程里的一个新线程与一个新进程其实是很相似的：对大多数用户来说，
软件只要好用就行，它具体是怎样实现的并不重要、在Linux系统里，使用线程可以节约进程方
面的开销可不是一个很站得住脚的观点。请大家注意这一点。
我们将在这一章里学习以下内容：
·检查你的计算机平台能否支持线程。
·在进程里创建新线程。
·在同一进程里的各个线程之间同步它们访问的数据。
·改变--个线程的属性。
·从一个线程控制另一个线程，而这两个线程都属于同一个进程。
11.2检查有无线程支持
在使用线程之前，先要确定对线程的支持确实存在并且符合POSIX标准，这是很有必要的。
C语言编译器在编译代码的时候会设置一些内部使用的常数，而包括在程序中的头文件还会再添
加一些。通过在编译代码时检查其中都有些什么样定义，我们就可以对编译器和函数库有一个
比较全面的认识，我们在这里最感兴趣的是它们对线程的支持情况。
有两种办法可以查出这一点，种复杂点儿，另一种简单些。复杂的办法是分析几个头文
件，包括limits.h、unistd.h和（Linux系统专用的）features.h等。简单的办法是编写一个很短的
小程序，让它替我们查。
义，就表示系统中根本就没有POSIX支持。如果它有定义，它的不同取值将告诉我们系统提供
了什么级别的支持。一个等于或大于“199506L”的值表示系统提供了对线程的完整支持。如果
加入jaVa编程群：524621833
---
## Page 346
328
Linux程序设计
_POSIX_VERSION的值小于这个数，就表示只有部分线程支持，可能还能应付本章中的大部分
示例。
动手试试：POSIX兼客性测试
我们来检查系统对POSIX支持的级别。下面是程序thread1.c的代码清单。除了在编译程序时
使用的函数库里查验系统对线程的支持情况以外，它就没有其他功能了。
inc)ude 
#include 
include 
int main(}(
printf(*POsIx version is_set to eld\n*._POSIx_VERSIoN) ;
if（_POSIX_VERSION=199506L)(
printf(*Sorry. you systen does not support PosIx1003.1c threads\n*);
printf(*Try again with -D_P0SIX_C_S0URCE=199506L\n*1;
else(
printf(*Your Bystem supports PoSIx1003.1c threads,\n");
ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
#else
priatf(*including support for priority scheduling\n*}:
printf(*but does not support priority scheduling\n°);
tendif
exi t EXIT_SUCCESS1 :
我们用include语句包括了几个标准的头文件，然后检查_POSIX_VERSION的值。在Linux系
统上，编译器通常会把_POSIX_C_SOURCE自动定义为一个大于或等于“199506L”的值，这样
才会设置其他的定义。如果对_POSIX_VERSION的检查失败了，我们就要检查
_POSIX_C_SOURCE的值，而编译器也确实设置了这个值。在两位作者的机器上，程序运行的结
果都是下面这样的：
$./chreadl
Your system supports POsIx1003.1c threads,
POSIX version is set to 199506
including support for priority scheduling
如果读者的系统没有报告出支持，或者程序根本就不能编译，就需要在命令行上设
POSIX_C_SOURCE标志后再次编译这个程序，如下所示：
$ cc -D_P0SIx_C_S0URCE=199506L thread1.c -o thread1
如果读者的系统还是没有报告出支持POSIX1003.1c线程，那你可能就无法测试本章给出的
程序示例了，或者它们的工作情况将与我们预计的不一样。
操作注释：
用include语句包括上几个标准的头文件后，程序在代码编译时就会对有关定义是否存在进
加入jaVa编程群：524621833
---
## Page 347
第11章POSIX线程
329
行检查。
11.3第一个线程程序
的。为了使用这些函数库，我们必须对_REENTRANT宏进行定义，这个宏包括在头文件
在设计最初的库例程时，其大前提是假设每个进程里都只有一个执行线程。最明显的例子
就足errno，如果对某个函数的调用失败了，人们就会用这个变量来检索错误信息。在一个多线
程程序里，缺省的设置情况是只有一个errno变量供所有的线程共享。在-个线程有机会检索刚
才的错误代码之前，这个变量很容易被另一个线程中的一个调用改变。类似的问题还存在于
fputs等函数，这些函数通常只使用一个全局性的区城米缓冲保存输出数据，
的线程，也可以是某种形式的嵌套性调用：但调用次数并不会影响它的正常功能。因此，代码
的可重人部分通常只使用局部变量，这就使对这部分代码的每一个调用都有它们白己独一无二
的一份数据
我们必须在多线程程序里告诉编译器我们将要用到这些功能，这就需要在程序里的任何“#
include”语句之前加上对_REENTRANT宏的定义。它会为我们做三件事，并且能够做得很完美，