        }
        function islogin($token)
          if ( 会话中是否有认证信息 )
            return 认证成功 ;   // 用户已经是登录中状态了
          // 从下面开始是会话已经超时，开始自动登录处理
          $id = check_auth_token($token);
          if ($id !== false) {
            将认证信息放到会话 ;
            放弃旧认证令牌 ;
            设置新的认证令牌（及新的有效期间）;
            return 认证成功 ;
          }
          return 认证失败 ;  // 自动登录失败的时候
        }
        // 需要编写批处理程序来定期从数据库删除已经过期的认证令牌记录
        ```
        `islogin`
        函数先判断现在会话里是否有用户的登录信息，如果有的话就认为用户已经登录了，将直接返回成功。如果会话里不存在用户的登录信息的话，则继续调用
        `check_auth_token` 函数，尝试进行自动登录。在 `check_auth_token`
        方法里根据传过来的令牌信息来查找用户的自动登录数据，如果数据库中存在此令牌数据，且有效期间没有过期的话，则返回登录中的用户
        ID。
        如果执行自动登录成功的话，需要先删掉旧的令牌信息，然后再生成新的令牌并保存到数据库中。之所以选择删除原来的令牌再创建新的，而不是简单地更新原令牌的有效期间，是因为如果原令牌如果由于某些原因被泄露的话，有可能被别人拿来进行恶意攻击，所以最好采取删除原令牌的方法。同样的原因，在用户修改密码后，也应该对令牌信息做类似的处理。
    -   **退出登录**
        在进行退出登录处理的时候，需要以用户 ID
        为查询条件，在用户自动登录数据表里把这个用户对应的令牌信息删除。考虑到用户可能在不同的终端上登录并且启用了自动登录，所以这里删除用户的自动登录数据的时候，需要以用户
        ID 为条件而不能用令牌。
        > **代码清单 退出登录处理（伪代码）**
        ``` 代码无行号
        $_SESSION = array();  // 销毁 $_SESSION 变量
        session_destroy(); // 销毁会话（退出登录）
        // 根据用户 ID 删除该用户所有自动登录数据
        准备删除语句 ('delete from autologin where id=?');
        执行删除语句  ($id);
        ```
-   **基于认证票的自动登录方式**
    认证票是为了在不同的服务器之间共享用户的认证数据（用户名，有效期间）而设计的。为了防止伪造或者信息泄露，认证票可能会需要电子署名或者加密。Windows
    所采用的 Kerberos 认证，以及 ASP.NET 的表单认证（From
    认证）等都采用了认证票的方法。
    认证票方法的优点是可以跨服务器共享用户的认证信息。但是实现认证票功能的话需要比较专业的加密或者安全方面的知识，尽量避免自己去实现。
    如果想在在多台服务器之间共享认证数据的话，推荐采用第三方的单点登录系统（SSO），或者使用
    OpenID 等开放的认证平台产品。
-   **三种方法的比较**
    关于如何实现用户自动登录功能，上面我们介绍了延长会话超时时间、令牌和认证票等三种方法。这之中，使用令牌方式是比较好的选择。令牌方式的优点有如下几条。
    -   对不想使用自动登录功能的用户不构成任何影响
    -   针对使用多终端登录的用户可以实现一次全部退出登录
    -   管理员可以强制使指定的用户退出登录
    -   在客户端不额外保存敏感信息，不存在被恶意利用的风险
[15]{.注释编号下} 服务器在收到客户端请求时，会以 session.gc_probability
/ session.gc_divisor 的概率进行会话回收工作，清理存活时间已经超过
session.gc_maxlifetime
的会话，所以会话被清理的时机不是实时的，会有一定的延迟。
#### **如何降低自动登录带来的风险** {line-num="798 799"}
自动登录带来的问题是用户的认证状态会持续很长时间，这会增加用户遭受 XSS
或 CSRF 等被动攻击的风险。
针对此问题，可以在关键操作，比如查看重要信息（个人信息等）、重要的操作（购物、转账、修改密码）之前加入密码确认步骤。亚马逊就是采用这种方法的网站之一，通常情况下用户访问亚马逊是在登录状态下进行的，但是用户如果想下单或者查看历史订单等重要操作前就会被要求再次输入密码进行验证。
### **5.1.5 登录表单** {#text00000.html#nav_point_65 line-num="804 805"}
这一节我们将对登录表单（用户输入 ID
和密码的页面）的安全性要求做一下说明。实现登录表单的时候最基本的原则如下。
-   密码输入框需要掩码（Mask）显示
-   如果应用需要使用 HTTPS 的话，从登录表单显示页面开始就应该使用 HTTPS
所谓输入密码的掩码显示，是指使用类型是 password
的输入控件，使用这种控件后，输入的密码在页面上显示时会以"\*"的符号显示出来。这样就能降低因
shoulder hack 导致密码被盗取的风险。
下面说一下为什么需要在登录表单显示页面就要使用
HTTPS。在输入密码的页面和进行登录处理的页面中，如果把后面的页面放在
HTTPS
下的话，用户输入的密码会被加密后传递给服务器，这样就能防止密码被盗取了。但是如果在输入密码的页面不使用
HTTPS 的话，就可能会存在如下风险。
-   登录表单被篡改，跳转目的地址被设为攻击者的地址
-   如果遭受 DNS 欺骗（DNS cache poisoning 或 DNS
    spoofing）攻击的话，用户可能会被转到攻击者的网站
如果我们在显示登录表单的页面开始使用 HTTPS
的话，就能防止该页面的内容被篡改。即使用户被诱骗到其他网站，浏览器也会显示出错信息，提醒用户注意（用户需要确认域名是否正确）。
所以说，如果要使用 HTTPS 的话，请一定在登录显示页面开始就使用 HTTPS。
> **专栏：密码确实需要掩码显示吗**
>
> 现在编写登录页面时，将密码输入框做掩码处理应该算是最基本的常识了，但是笔者却对此有些疑问。如果对输入框进行了掩码设置，那么输入包含符号、大小写字母的密码会变得稍微有点麻烦，用户可能会有选择更简单的密码，这对系统安全性来说反而是一个不利因素，这也是笔者对掩码处理持有疑问的原因。
>
> 美国关于 Web 使用方便性的权威 Jakob Nielsen 在 2009 年 6
> 月发表了一篇"请停止隐藏密码显示"[16]{.注释编号}
> 的专栏文章，这篇文章里列举了很多隐藏密码明文显示的缺点，当时出现了很多反对的意见，但是
> SANS 的博客里却对此表示了赞同的看法[17]{.注释编号}
> 。这篇文章也成了当时大家关注的话题。
>
> 把目光转向 Web
> 网站以外，可以发现在桌面端应用程序里面，有很多软件都提供了在密码的明文显示和掩码显示之间的切换功能。比如下面的图显示的就是
> Windows Vista 的 VPN 设置画面，画面里有一个"显示字符"的复选框。
>
> ![{%}](Image00196.jpg)
>
> **图 5-11 密码显示 / 不显示的例子**
>
> 密码认证的最大的威胁是跨越网络的暴力破解，而预防抗暴力破解的最好的方法就是选择安全的密码。以后提供"显示密码字符"复选框的网站数量也许会增加。但是如果使用浏览器的密码自动保存功能的话，有可能画面一显示出来就把明文密码都暴露了，会被别人看见，这是个比较麻烦的问题，所以"显示密码字符"的复选框需要默认为不被选中。
[16]{.注释编号下}
[17]{.注释编号下}
### **5.1.6 如何显示错误消息** {#text00000.html#nav_point_66 line-num="836 837"}
本节将说明一下如何在用户登录界面正确的显示错误消息。
不管什么错误消息，其原则都是不能留给攻击者任何提示。在登录功能里像下面的两个错误消息都是对安全不利的：
"指定的用户不存在"
"密码不正确"
因为攻击者从这些消息里就可以知道到底是用户 ID
错了还是密码错了，使得暴力破解将会更有针对性。图 5-12 是在知道用户 ID/
密码哪个错误和不知道用户 ID/
密码哪个错误这两种情况下，攻击所需要成本的对比。
![{%}](Image00197.jpg)
**图 5-12 如果知道登录 ID 或者密码哪个错了的话破解将会变容易**
如果是用户 ID
不正确（不存在）的话，如左图，首先攻击者会一直尝试使用不同的用户
ID，直到找到了系统里存在的用户
ID，然后再开始进行猜测密码，这样的话最多需要尝试 2
万次就够了。如果攻击者不知道登录 ID
或者密码哪个不正确的话，就需要尝试所有的用户 ID
和密码的组合，也就是至少需要尝试 1 万 ×1 万，即 1
亿次才行。可以看出，错误消息可以在很大程度上对攻击者的攻击效率产生影响。
同样，有时候攻击者也可以通过用户账号被锁定时显示的错误信息来推测用户 ID
是否存在，所以推荐在发生账号被锁定的时候使用类似下面那样的消息（如果系统支持账号锁定功能的话）：
"ID 或者密码错误，账号已被锁定"
尽管这样会让真正的用户不知道到底是自己的用户 ID
错了还是密码错了，但我们在 5.1.2
节提到了，用户账号被锁定的时候，最好同时给用户发送邮件通知。所以如果在上面弹出的错误消息后面加上类似下面这段文字的话，用户体验会更好一些。
> ※
> 账号锁定时将发送邮件通知账号所有者，如果有什么疑问，请查看邮件内容进行确认。
### **5.1.7 退出登录功能** {#text00000.html#nav_point_67 line-num="862 863"}
比较安全的退出登录处理的做法是销毁会话对象。另外，有时候需要在退出登录的时候加入防止
CSRF
漏洞的逻辑，但是如果由第三方强制退出登录没有什么大的不利影响的话，也可以考虑省略预防
CSRF 的处理。
下面是在退出登录需要做的事。
-   退出登录处理有副作用所以用 POST 提交退出登录请求
-   在退出登录处理中销毁会话对象
-   根据需要选择是否加入 CSRF 处理
发起退出登录请求的页面实现示例请参考下面的代码。
> **代码清单 /51/51-011.php**
``` {.代码无行号 line-num="876 877 878 879 880 881 882 883"}
【前面省略】// 这里假设已经执行了 session_start();
">
```
这段代码通过 POST
方式向执行退出操作的脚本（51-012.php）发起请求，作为预防 CSRF
的措施，同时传一个 hidden 的参数 token，token 直接使用了会话 ID 的值。
执行退出登录的处理如下所示。
> **代码清单 /51/51-012.php**
``` {.代码无行号 line-num="890 891 892 893 894 895 896 897 898 899 900 901 902"}
```
在这段代码的前半部分是进性预防 CSRF 的令牌检查，关于 CSRF
对策的详细内容可以参考 4.5.1 节。
上面脚本的后半部分是执行退出登录处理的中心内容，先对 `$_SESSION`
变量进行了清空操作，然后又销毁了会话。如果只是退出登录的话，不必对
`$_SESSION`
进行清空操作，但是为了防止以后在退出登录后增加逻辑时不小心发生其他问题，安全起见对这个变量进行了清空处理。
### **5.1.8 认证功能总结** {#text00000.html#nav_point_68 line-num="907 908"}
这一节我们介绍了几种能增强系统认证功能安全性的一些方法。用户 /
密码认证作为现在主流的认证方式，可以采用下面的方法来提高其安全性。
-   密码可用字符种类和长度的要求
    -   请参考 5.1.1 节
    -   请参考 5.1.1 节
-   针对暴力破解的对策
    -   请参考 5.1.2 节
-   密码保存方法
    -   请参考 5.1.3 节
-   输入页面和错误信息的需求
    -   请参考 5.1.5 节
    -   请参考 5.1.6 节
此外，本节还介绍了如何安全的实现自动登录和退出登录功能。
#### **参考：彩虹表原理** {line-num="930 931"}
即使攻击者得到了密码的散列值去暴力破解，时间成本还是非常高的，于是有人提出了用反向查找表来提高查询速度的方法。这里所说的反向查找表是指把密码的散列值作为查找表的键（Key），而把密码原文作为查找表的值（Value）存储。表
5-3 是一个的反向查找表例子。
**表 5-3 散列值反向查找表示例**
  散列值       密码
  ------------ ----------
  098f6bcd46   test
  5f4dcc3b5a   password
  900150983c   abc