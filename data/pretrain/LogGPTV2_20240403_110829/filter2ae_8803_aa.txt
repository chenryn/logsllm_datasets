原文：[Art of Anti Detection 2 – PE Backdoor
Manufacturing](https://pentest.blog/art-of-anti-detection-2-pe-backdoor-manufacturing/)  
译者： **MyKings@知道创宇404实验室**  
前文回顾：[反检测技术之反病毒检测](http://paper.seebug.org/222/)
本文主要讲述在网络攻防演练中红队如何在PE(Portable
Executable)文件中放置后门的几种方法。为了让读者能够充分掌握本文的内容，您需要具有中级x86汇编知识，并熟悉调试器与PE文件格式。
## 1\. 背景说明
目前几乎所有的安全研究人员、渗透测试人员和恶意软件分析师每天都在处理后门程序，将后门放置到系统或具体某个应用程序是一种较为常见的攻击方式。
本文的大部分内容是关于将后门植入32位PE文件的方法, 但由于PE文件格式是Unix COFF（Common Object File Format,
通用对象文件格式）的修改版本，所以这些方法也可以用于其他可执行二进制文件类型。
此外，后门的隐蔽性尤为重要，这里也会分析一些反检测技术的方法。在阅读本文之前，您可以先阅读 [Introduction To AV & Detection
Techniques ](https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/)([反检测技术之反病毒检测](http://paper.seebug.org/222/)) ,
这将有助于您了解反病毒产品的内部工作原理和反检测技术的基本思想。
## 2\. 专业术语
**红队(Red Team Pentesting):**
在网络攻防演练中，红队是由一群白帽黑客组成，作为攻击者负责攻击组织(通常为蓝队)的数字基础设施，以测试组织的防御能力（通常称为“渗透测试”）。
其好处体现在先入为主的观念与挑战，发现更多的潜在威胁减少安全问题。其次可更准确地了解敏感信息是如何被泄漏的，以及可利用的模式。目前包括微软在内的一些公司会定期进行红队与蓝队的网络对抗演练。
 _图片译者添加_
**地址空间布局随机化(ASLR):**
`ASLR` 是一种针对缓冲区溢出的安全保护技术。为了防止攻击者能够直接定位内存中攻击代码位置，`ASLR` 随机排列进程的关键数据区域的内存地址，如:
可执行文件的基址、栈、堆和库的位置。
**代码洞(Code Caves):**
`Code Caves`是由另一个程序写入另一个进程的内存的一段代码。这段代码可以通过在目标进程内创建远程线程来执行。代码的`Code
Caves`通常是对代码的脚本函数的一部分的引用，该脚本函数具有注入自定义指令的能力。例如，如果脚本的内存允许5个字节，并且只使用3个字节，则剩余的2个字节可以用于向脚本添加外部代码,
这就是所谓的代码洞。
**校验和(Checksum):**
`校验和`是来自数字数据块的小尺寸数据，用于检测在其传输或存储期间可能引入的错误。它通常从远端服务器下载到本地接收到之后应用于安装文件。通过自身，校验和通常用于验证数据完整性，但不依赖于验证数据的真实性。
> 译者注: "校验和" 是冗余校验的一种形式。
> 它是通过错误检测方法，对经过空间（如通信）或者时间（如计算机存储）传送的数据的完整性进行检查的一种简单方法。计算机领域常见的校验和的方法有:
> CRC、MD5、SHA家族等。
## 3\. 基本流程
本文中将通过 [putty.exe](http://www.putty.org/)
这个SSH客户端来做示例演示。这里使用`putty`的主要原因有如下几个:
  * `putty` 客户端是一个使用多个库和 Windows API 的本地 C++ 项目;
  * SSH客户端的后门吸引较少关注，因为程序主要就是执行TCP连接，这将更容易避免蓝色团队网络监控。
这个后门代码将使用 [`metasploit`](https://github.com/rapid7/metasploit-framework) 项目中
Stephen Fever’s 开发的TCP反向链接的
[`ShellCode`](https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/stager/stager_reverse_tcp_nx.asm)。
主要将 `ShellCode` 注入目标PE文件中，并且不影响程序的正常功能。注入的 `ShellCode`
将在一个新的线程上执行，并不断地尝试连接到控制端。完成以上目标后我们还要做一些免杀, 来减少被检测到的风险。
大致流程主要分以下四个步骤:
  * 完成可用空间的后门代码(添加区段)
  * 劫持执行流程
  * 注入后门代码
  * 恢复执行流程
在每一个步骤中都有一些关键操作, 这些细节保证了后门的隐蔽与降低被检测到的风险。
## 4\. 可用空间问题
第一步我们需要找到可用空间，如何在PE文件中选择合适的空间来插入后门代码非常重要, 这将影响到后门被检测到的风险系数。 有如下两种方法解决空间大小问题:
### 4.1 添加新区段
与其他方法相比，这种方法容易被检测引擎检测到，但另一个好处是附加了一个新的区段，对于将被植入的后门代码没有空间限制。
使用一个汇编程序或PE编辑器(如`LordPE`)，所有的PE文件可以添加一个新的段头，这是 `putty` 可执行文件的节表，借助PE编辑器添加了一个
"`NewSec`" 区段, 大小为 1000 字节，
当创建一个新的区段时，将段标志设置为 “读/写/执行” 对于当PE映像映射到内存时运行后门 `ShellCode` 至关重要。
在添加段头之后，需要调整文件大小，这可以通过在十六进制编辑器中添加空文件和文件末尾的段大小来实现。
在这些操作之后，新的空段被成功地添加到PE文件中，运行修改后的 `putty` 文件，如果正常运行, 则新段可以在调试器上被修改。
为了解决空间问题，我们添加一个新的区段，但是几乎所有的AV产品都能识别不常见的区段，同时给一个不常见的区段所有（读/写/执行）权限肯定是非常可疑的。即使向putty可执行文件添加空的完整权限，也会被某些AV产品标记为恶意。
### 4.2 代码洞(Code Caves)
解决空间问题的第二种方法是使用目标可执行文件的`Code Caves`。几乎所有编译的二进制文件都有`Code
Caves`，可以在进行后门操作时使用。使用`Code
Caves`而不是新添加的区段的方法将降低被AV产品检测的风险，因为使用已经存在的公共部分。此外，PE文件的总体大小在添加后门结束时不会被改变，但是该方法也具有缺点。
`Code Caves`的数量和大小根据文件的不同而不同，与添加区段比通常没有太多的空间。当使用`Code
Caves`时，后门代码应尽可能短小。另一个缺点是段标志, 由于应用程序的执行将被重定向到 Caves，包含 Caves 的部分应该具有 “execute”
权限，甚至一些shellcode（以自修改的方式编码或混淆）也需要 “write” 权限，以便进行更改里面的区段。
使用多个`Code
Caves`将有助于克服空间限制问题，也将后门代码分割为块同时降低了被AV检测的风险，但不幸的是更改段特权将看起来可疑。有一些高级方法可以修改运行时的内存区域权限，来避免直接更改段权限，但由于这些方法需要定制的
`ShellCode` 编码和IAT解析技术，它将在下一篇文章中来介绍。
借助于一个名为`Cminer`的工具，很容易枚举二进制文件的所有代码洞，`./Cminer putty.exe 300` 命令枚举`Code
Caves`大于300字节。
在这种情况下，有5个好的`Code
Caves`可以使用。起始地址给出了`Caves`的虚拟内存地址（VMA）。这是`Caves`的地址，当PE文件加载到内存中时，文件偏移量是以字节为单位的PE文件内的`Caves`地址。
看来大部分`Caves`都在数据段内，因为数据段没有执行特权段标志,
这里需要更改。后门代码将在400-500字节左右，所以5个`Caves`应该是足够的。`Caves`的起始地址应该被保存，在将段特权更改为R/W/E后，第一步的后门过程就完成了。
下面开始需要重定向执行的时候了。
## 5\. 劫持执行流程