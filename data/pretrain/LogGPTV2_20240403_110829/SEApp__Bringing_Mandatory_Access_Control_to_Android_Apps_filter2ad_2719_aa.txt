title:SEApp: Bringing Mandatory Access Control to Android Apps
author:Matthew Rossi and
Dario Facchinetti and
Enrico Bacis and
Marco Rosa and
Stefano Paraboschi
SEApp: Bringing Mandatory Access Control to 
Android Apps
Matthew Rossi, Dario Facchinetti, and Enrico Bacis, Università degli 
Studi di Bergamo; Marco Rosa, SAP Security Research; Stefano Paraboschi, 
Università degli Studi di Bergamo
https://www.usenix.org/conference/usenixsecurity21/presentation/rossi
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.SEApp: Bringing Mandatory Access Control to
Android Apps
Matthew Rossi
Dario Facchinetti
Università degli Studi di Bergamo
Università degli Studi di Bergamo
PI:EMAIL
PI:EMAIL
Enrico Bacis∗
Università degli Studi di Bergamo
PI:EMAIL
Marco Rosa
SAP Security Research
PI:EMAIL
Stefano Paraboschi
Università degli Studi di Bergamo
PI:EMAIL
Abstract
Mandatory Access Control (MAC) has provided a great con-
tribution to the improvement of the security of modern op-
erating systems. A clear demonstration is represented by
Android, which has progressively assigned a greater role to
SELinux since its introduction in 2013. These beneﬁts have
been mostly dedicated to the protection of system compo-
nents against the behavior of apps and no control is offered
to app developers on the use of MAC. Our solution over-
comes this limitation, giving developers the power to deﬁne
ad-hoc MAC policies for their apps, supporting the internal
compartmentalization of app components.
This is a natural evolution of the security mechanisms al-
ready available in Android, but its realization requires to con-
sider that (i) the security of system components must be main-
tained, (ii) the solution must be usable by developers, and
(iii) the performance impact should be limited. Our proposal
meets these three requirements. The proposal is supported by
an open-source implementation.
1
Introduction
Security in operating systems has greatly evolved and has
been able to address many of the threats originating by an
extensive and varied collection of adversaries.
The mitigation of security threats is particularly important
for mobile operating systems, due to their wide deployment
and the conﬁdential information they hold.
Both Android and iOS have seen signiﬁcant investments
toward the realization of advanced security techniques, which
have led to a great increase in the level of protection offered to
users [58]. The strength of security and the value of protected
resources is testiﬁed, for instance, by the payouts associated
with working exploits in markets like Zerodium [72], where
the payouts for mobile operating systems are the highest1.
∗now at Google
1At the time of writing, US$2.5M and US$2M are paid for a zero click
solution able to subvert the security of Androd and iOS, respectively.
A peculiar threat that characterizes mobile operating sys-
tems is the need to balance on one side the high sensitivity of
the information, and on the other hand the need for users to
install into the system a large number of applications (called
simply apps in this domain) often produced by unknown de-
velopers, which may hide malicious functions. A ﬁrst level of
protection is offered, both in iOS and Android, by a prelimi-
nary screening of apps before they are made available on the
platform market [2] or installed to a device, but this approach
cannot provide a strong guarantee. Security mechanisms in-
ternal to the operating system are needed in order to constrain
the apps to only operate within the boundaries speciﬁed by
the device owner at installation time.
The approach used in the design of mobile operating sys-
tems considers as the ﬁrst requirement the protection of sys-
tem resources. Focusing on Android, which is open source
and more accessible to researchers, we notice a signiﬁcant evo-
lution in its internal security architecture. This architecture is
quite rich and consists of many security measures [44, 58]. In
this environment, we speciﬁcally look at the role of SELinux.
SELinux implements the Mandatory Access Control (MAC)
mechanism, which relies on a system-level policy to declare
the operations that a process can execute over a resource
based on the security labels associated with them. Compared
to classical Discretionary Access Control (DAC), still used
in Android in an extensive way, MAC is more rigid and pro-
vides stronger guarantees against unwanted behaviors. When
SELinux was introduced into Android 4.3 in 2013 (see Fig-
ure 1), it used a limited set of system domains and it was
mainly aimed at separating system resources from user apps.
In the next releases, the conﬁguration of SELinux has progres-
sively become more complex, with a growing set of domains
isolating different services and resources, so that a bug or
vulnerability in some system component does not lead to a
direct compromise of the whole system.
The introduction of SELinux into Android has been a clear
success. Unfortunately, the stronger protection beneﬁts do
not extend to regular apps which are assigned with a single
domain named untrusted_app. Since Android 9, isolation
USENIX Association
30th USENIX Security Symposium    3613
of apps has increased with the use of categories, which guar-
antees that distinct apps operate on separate security contexts.
Our proposal, SEApp, builds upon the observation that giving
app developers the ability to apply MAC to the internal struc-
ture of the app would provide more robust protection against
other apps and internal vulnerabilities.
2 Android security for apps
One of the major requirements considered in the design of
mobile operating systems is the need to constrain the ability
of apps to manipulate the execution environment. Apps may
hide functions that are meant to gain system privileges or
capture valuable information from other apps. Compared to
classical desktop operating systems, there is greater reliance
on the use of apps to access resources or get services, with
more attention paid to limit the ability of apps to operate in the
system. Advancements in this context can have an impact on
how security for applications is managed in other domains [1].
The basic principle adopted to manage the threat introduced
by apps is the design of a sandbox, a restricted environment
for app execution, where anomalous actions by the app are
not able to access resources beyond what has been authorized
at app installation time. The sandbox can be considered a
realization of the “least privilege” security principle.
The construction of the app sandbox is based on three
access control mechanisms: Android permissions [14, 44, 45],
Discretionary Access Control (DAC) [38], and Mandatory
Access Control (MAC) [63]; each of them roughly aligning
with how users, developers, and the platform grant consent,
respectively.
Android permissions restrict access to sensitive data and
services. In ﬁle AndroidManifest.xml [16], each app stat-
ically lists the Android permissions needed to fully operate.
Not all of them may be granted; depending on the threat they
pose from a security and privacy standpoint, they may be
granted as part of the installation procedure, or prompted to
the user when the app needs them.
DAC restricts access to resources based on user and group
identity. By assigning each application a unique UNIX user
ID (UID) and a dedicated directory, Android isolates apps
from each other and from the system. However, UID sandbox-
ing has a number of shortcomings. As an example, processes
running as root are not subject to these restrictions. For this
reason, when such a process is misbehaving, for instance due
to a bug, it can access private app data ﬁles. DAC discretion-
ality itself is a problem. Indeed, as apps and system processes
could override safe defaults, they are more susceptible to dan-
gerous behavior, such as leaking ﬁles or data across security
boundaries via IPC or fork/exec. Despite its deﬁciencies, UID
sandboxing is still the primary enforcement mechanism that
separates apps from each other, establishing the foundation
upon which further sandbox restrictions have been built.
Figure 1: Evolution of the MAC policy in Android. Before 4.3,
MAC was not used. Starting with 4.3, MAC protects system
components. Since 9, categories offer rigid MAC protection
for apps. Our proposal offers ﬂexible MAC protection to apps.
MAC dictates which actions are allowed based on the secu-
rity policy deﬁned by the system. Speciﬁcally, only actions ex-
plicitly granted by the policy are permitted. To decide whether
to permit or deny an action, a set of policy rules concerning
the security contexts (i.e., collections of security labels that
classify resources) of the involved parties is evaluated.
In Android, MAC is implemented using SEAndroid, a set
of kernel modiﬁcations part of the Linux Security Module
(LSM) framework [70]. Since its ﬁrst introduction with the Se-
curity Enhanced Android (SEAndroid) project [65], SELinux
has been extensively applied to protect system components.
Initially, it was used to assert the security model requirements
during compatibility testing, then its usage grew further at
each release. In the current version Android 11, SELinux
is also used to isolate the rendering of untrusted web con-
tent (by the isolated_app domain), to restrict ioctl system
calls [56], thus limiting the reachability of potential kernel
vulnerabilities, and to support multi-user separation and app
sandboxing with SELinux categories. This last aspect permits
to enforce app separation both at DAC and MAC. Android
dynamically assigns categories to apps during app installa-
tion, so that: (i) an app running on behalf of a user cannot
read or write ﬁles created by the same app on behalf of an-
other user (since Android 6 [9]); and, (ii) an app cannot read
or write ﬁles created by another app (since Android 9 [11]).
Before Android 9, this separation was only enforced at DAC
level. This overlap of security measures is of extreme rele-
vance to the enforcement of the Android Security Model and
our proposal moves in the same direction. To bypass these
protections, a process should be granted root permissions,
DAC_OVERRIDE or DAC_READ_SEARCH, and run as SELinux
mlstrustedsubject; only a few critical system services run
in this conﬁguration.
Android restricts the SELinux implementation to the policy
enforcement, ignoring most policy management functions.
The motivation is that the system policy only changes between
releases, therefore support to runtime changes is not needed.
3614    30th USENIX Security Symposium
USENIX Association
BeforeAndroid 4.3Android 4.3 -Android 8SinceAndroid 9OurProposalsystem servicessystem servicessystem servicessystem services     app          app     app          app     app          app     app          app121212123 Motivation
As discussed above, SELinux and the MAC support have
been a crucial factor in the realization of a secure design and
the construction of a robust app sandbox. A limitation of
the current design is that this is the only way that apps can
beneﬁt from MAC support. There is currently no option to let
the app developer control the use of the MAC level, as only
platform, vendor, ODM and OEM developers are allowed to
introduce new policy segments [24]. Our solution overcomes
this limitation, giving the application developer the power to
specify new SELinux types and associated permissions.
3.1 Use cases
We envision several scenarios that justify the use of SEApp.
Many of them have been previously considered by researchers
as motivations for the introduction in Android of dedicated
components [33, 41, 55].
In this Section we give a tour of SEApp capabilities us-
ing a showcase app2. The architecture of the showcase app
is shown in Figure 2. Our description is based on three use
cases: ﬁne-granularity in access to ﬁles, ﬁne-granularity in
access to services, and isolation of vulnerability prone compo-
nents. Each of the use cases emphasizes the intra-app security
features introduced by SEApp. A dedicated description, along
with policy ﬁles that show concretely how to enforce these use
cases, appears in the Appendix; we provide there a technical
demonstration of how SEApp can provide protection against
a number of common security problems in Android apps [51]
that were implemented in the showcase app.
3.1.1 Fine-granularity in access to ﬁles
Android apps can collect data from multiple sources, and
the system provides many options to store it. The default
one is Internal Storage: a ﬁlesystem region, located at
/data/data/packageName, reserved to each package. Its
content is available to all app’s internal components and in-
accessible to any other app. Since data can be extremely
sensitive, the developer may be interested in restricting its
visibility to only some internal components, labeling sensitive
and non-sensitive data with distinct SELinux types (use case
1). Yet, in the current Android security model, apps do not
have the option to assign distinct MAC labels to different
resources, as all internal ﬁles are labeled app_data_file.
SEApp allows the developer to introduce dedicated types,
and to organize the app’s structure with a separation between
components managing non-sensitive data and those requir-
ing access to sensitive data. The sensitive components will
be associated with a more stringent MAC domain. Figure 2
shows an example in which the conﬁdential ﬁles are made
2The showcase app is available in the SEApp repository along with the
set of modiﬁcations to the AOSP.
Figure 2: Security Enhanced App
accessible to :core_logic processes and inaccessible to any
other process.
In Appendix A.1 we give a demonstration of how conﬁ-
dential ﬁles are made inaccessible to non-conﬁdential compo-
nents in the presence of a path traversal vulnerability.
3.1.2 Fine-granularity in access to services
Often developers introduce into their applications code com-
ing from external sources, which they do not fully trust [40,
46, 61]. For instance, a common need of app developers is
to get revenue from their apps and a simple approach is to
include an Ad delivery library within the app. The library is
a relatively complex piece of code, with local computation
necessities and the need to manage a dialogue with remote
servers. The app developer is clearly interested in supporting
the execution of the library, but may want to have guarantees
that the library cannot abuse the access privileges granted by
the user to the whole application sandbox (use case 2). A com-
mon concern is preventing access to system services such as
location. These requirements can be managed by SEApp with
the deﬁnition of a separate MAC domain for the library. The
process managing the delivery of Ads will be associated with
this domain, which will provide only the necessary privileges
to access the dedicated resources needed for the library exe-
cution. SELinux will then guarantee the conﬁnement of the
library, preventing access to the location service even if the
ACCESS_FINE_LOCATION permission is granted to the app.
Figure 2 shows an example in which the :adlibrary process is
granted access to the network but is prevented from accessing
location service.
In Appendix A.2 we give a demonstration of how the show-
case app can support the execution of the Unity Ads [69]
framework with a dedicated SELinux domain. We also de-
scribe in detail how SEApp prevents a malicious component,
which was deliberately injected by us into the library process,
to capture the device location.
USENIX Association
30th USENIX Security Symposium    3615
libmedia.so/data/data/SEApp/filesconfidential/ActivityActivity:core_logic:adlibraryActivityads_cache/Service:mediaServiceKernel API               DAC  +       MAC ads_d    → ads_tcore_logic_d → confidential_tmedia_d   → media_tuserspaceﬁlesystemkernelService APIPermissionsBinder modulecameraservicelocationserviceSEAppSystem ServerNetwork1233.1.3 Isolation of vulnerability prone components
App developers often have to consider that the input provided
to the app can come from untrusted sources. A typical exam-
ple is the rendering of complex Javascript code performed by
WebView. The solution currently offered by Android is to ex-
ecute these potentially dangerous actions within a sandbox us-
ing isolatedprocess, i.e., a special process that is isolated from
the rest of the system and has no permissions of its own [6].
It runs under a dedicated UID and SELinux domain, and it
can only interact with a restricted number of services [8].
A common need of app developers is to take advantage of
complex media or processing libraries, components that are
not considered malicious, but due to their size and complexity
are more likely to have security bugs. The developer is then in-
terested in isolating these potentially vulnerable components
(use case 3). Isolatedprocess offers a high protection level
in Android, however, its use imposes several restrictions on
the developers. For instance, isolatedprocess cannot perform
many of the core Android IPC functions, and the only way to
interact with it is through the bound service API [7]. Also, iso-
latedprocess can only access already open app ﬁles received
over Binder. Another shortcoming is that each invocation of
an isolatedprocess requires the creation of a new process. If
a series of requests are made by the app, the performance
impact can be signiﬁcant. SEApp offers an easier way to do
this compared to isolatedprocess, as it permits to assign a
domain to the process in which the component is executed,
and then conﬁgure the required permissions at MAC level. In
terms of performance, the management of multiple requests
does not require the system to activate a new process with a
new UID and a dedicated SELinux category. Figure 2 shows
how to conﬁne the :media component.