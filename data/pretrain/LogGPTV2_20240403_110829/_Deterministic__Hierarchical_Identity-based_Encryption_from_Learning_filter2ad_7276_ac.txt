the input with public parameter PP, a private key
SKid(cid:96) corresponding to an identity id(cid:96) = {i1, ..., i(cid:96)}
and an identity id(cid:96)+1 = {i1, ..., i(cid:96)+1}, the algorithm
works as follows:
1. Inquire the hash function H with identity idi for
i = 1 to (cid:96) and set Rid(cid:96) = H(id(cid:96))··· H(id2)H(id1).
and SKid(cid:96) is a
Then compute Fid(cid:96) = AR
short basis for Λ⊥
−1
id(cid:96)
2. Compute R = H(id(cid:96)+1) and let Fid(cid:96)+1 = Fid(cid:96) R−1;
3. Evaluate T(cid:48) ← BasisDel(Fid(cid:96) , R, SKid(cid:96) , σ(cid:96)+1)
where σ(cid:96)+1 > (cid:107)(cid:103)SKid(cid:96)(cid:107) · σR · √
q (Fid(cid:96)+1 ),
m · ω(log3/2 m);
to obtain a short random basis for Λ⊥
q (Fid(cid:96) );
4. Output the private key SKid(cid:96)+1 = T(cid:48).
Enc(PP, id, m) → c: Given the input with public
parameter PP, an identity id of depth |id| = (cid:96) and
a message m ∈ Zm
p , the algorithm computes Rid :=
H(id(cid:96))··· H(id2)H(id1) and lets Fid = AR
−1
id . Then
the algorithm randomly chooses s ← Zn∗
q and outputs
the ciphertext c = (c0, c1), where
c0 := (cid:98)Ft
ids(cid:99)p; c1 := (cid:98)At
1s(cid:99)p + m mod p
Dec(PP, SKid, c) → m or ⊥: Given the input with
public parameter PP, an identity id of depth |id| = (cid:96)
with the private key SKid and a ciphertext c, the al-
gorithm computes Fid = AR
as before and
restores the randomness s from LWRInvert2(SKid,
Fid, c0). Finally, the algorithm recovers the message
m = c1 − (cid:98)At
id ∈ Zn×m
−1
1s(cid:99)p mod p.
q
3.1.1 Parameter and Correctness
In this scheme, the choice of parameter should match the
requirement of algorithm BasisDel for diﬀerent depth (cid:96)  m
2 d+1 ·
ω(log2d m), q ≥ 4mpB and p divides q, given the matrix
A ∈ Zn×m
q (A) generated by
GenTrap(1n, 1m, q), the decryption algorithm Dec(PP,
with a short basis TA for Λ⊥
q
3
SKid, c) will output m with overwhelming probability over
all choices of PP, msk and the message m $←− Zm
p .
rectly when σ(cid:96) satisﬁes σ(cid:96) > (cid:107)(cid:103)SKid(cid:96)−1(cid:107)·σR·√
SKid(cid:96)−1 at level (cid:96) − 1 satisﬁes (cid:107)(cid:103)SKid(cid:96)−1(cid:107) ≤ σ(cid:96)−1 · √
Proof. Algorithm BasisDel at level (cid:96) can operate cor-
m·ω(log3/2 m)
according to lemma 3. From Lemma 2, the private key
m
with overwhelming probability. Then the requirement on σ(cid:96)
follows from σ(cid:96) > σ(cid:96)−1·m3/2·ω(log2 m), with which we have
(cid:26) σ(cid:96) > σ1 · [m3/2 · ω(log2 m)](cid:96)−1
σ1 > (cid:107)(cid:103)TA(cid:107) · σR · √
3
3
3
2 (cid:96)+ 1
2 (cid:96)− 1
2 (cid:96) · ω(log2(cid:96) m) ≤ m
m · ω(log3/2 m)
2 ·ω(log2(cid:96) m). Thus, under
such condition on σ(cid:96) the BasisDel can delegate the private
key SKid(cid:96) at level (cid:96). From Lemma 1, we have
and imply that σ(cid:96) > (cid:107)(cid:103)TA(cid:107)·m
(cid:107)SKid(cid:96)(cid:107) ≤ (cid:107)(cid:103)TA(cid:107) · m
2 · ω(log2(cid:96) m)
2 d+1 · ω(log2d m), we have
√
With the parameter that p > m
(cid:107)SKid(cid:96)(cid:107) ≤ p/(2
m), which meets the requirement of Lem-
ma 5, for each (cid:96) = 1, ..., d. Given the ciphertext c = (c0, c1),
we can reconstruct the randomness s correctly with over-
whelming probability by the LWR inversion algorithm L-
WRInvert2(SKid, Fid, c0). With the randomness s, the
decryption algorithm can deterministically reconstruct the
message m from c1 − (cid:98)At
3.1.2
Based on the LWR assumption we can prove our HIBE
INDr-ID-CPA Security
1s(cid:99)p mod p.
3
scheme with random oracles is adaptive secure.
Theorem 2. If there is an INDr-ID-CPA adversary A
attacking the HIBE scheme with the parameter in Lemma
6, the hash function H is a random oracle deﬁned as before
and QH is the maximum number of queries to H that A
can issue, then there exists an algorithm B attacking the
LWR2m,n,q,p problem. In particular, the advantage of A is
Advindr-id-cpa
HIBE,A
≤ dQd
H · Adv
B
LWR2m,n,q,p + negl (λ)
d
r ··· R∗
1, ..., R∗
1, ..., Q∗
(Proof of sketch). The algorithm B randomly chooses d in-
$←− [QH] and samples d random matri-
dexes Q∗
d ← Dm×m. Then B constructs A0 from the
ces R∗
given LWR challenge, chooses a random r ∈ [d] uniformly
and sets A := A0R∗
1. By calling SampleRwithBa-
1)−1, B can answer hash
sis(Ai) for Ai := A(R∗
queries and private key queries for every node in the hierar-
chy except for the challenge identity id∗. Then B generate
a ciphertext respect to id∗ with the given LWR challenge
and send it to A. We observe that B’s advantage is that
same as A’s, conditioned on B not aborting. By a stan-
dard argument, the probability that B does not abort is
Pr[S not abort] ≥ 1
i−1 ··· R∗
− negl(λ).
2R∗
dQd
H
3.2 A D-HIBE scheme with Random Oracles
From the above HIBE scheme, we can easily construct
our D-HIBE scheme with random oracles based on the L-
WR problem. The algorithm of our D-HIBE scheme in the
random oracle model is described as follows:
KeyGen(1λ)→ (PP, msk ): The algorithm calls Gen-
Trap(1n, 1m, q) to sample a matrix A ∈ Zn×m
with
q
910a short basis TA for Λ⊥
and master key msk are
q (A). Then the public key PP
PP := A; msk := TA
Derive(PP, msk, id(cid:96)+1,SKid(cid:96) ) → SKid(cid:96)+1 : The De-
rive algorithm is as the same with the algorithm in
our above HIBE scheme in the random oracle model.
Enc(PP, id, m) → c: Given the input with the pub-
lic key PP, an identity id of depth |id| = (cid:96) and a
message m ∈ {0, 1}n, the algorithm computes Rid :=
H(id(cid:96))··· H(id2)H(id1) and lets Fid = AR
−1
id . Final-
idm(cid:99)p.
ly, the algorithm outputs the ciphertext c := (cid:98)Ft
Dec(PP, SKid, c) → m or ⊥: Given the input with
public key PP, an identity id of depth |id| = (cid:96) with
the private key SKid and a ciphertext c, the algorithm
−1
id as before and then recovers
constructs Fid = AR
the message m from LWRInvert2(SKid, Fid, c).
3.2.1 Parameter and Correctness
In this scheme, the choice of parameter is similar with
Lemma 6, the diﬀerence is the setting of the parameter for
the underlying LWR problem. The parameter and correct-
ness of this scheme are stated in Lemma 7.
Lemma 7. For any n ≥ 1, m ≥ O(n log q), p > m
2 d+1 ·
ω(log2d m) and q ≥ 2mpB is a prime, given the matrix
A ∈ Zn×m
q (A) generated
by GenTrap(1n, 1m, q), the decryption algorithm Dec(PP,
SKid, c) will output m with overwhelming probability over
all choices of PP, msk and the message m ∈ {0, 1}n.
with a short basis TA for Λ⊥
q
3
Proof. This proof is similar to Lemma 6, except that
the choice of p and q. According to the requirement of the
LWRm,n,q,p problem in 1, we need q ≥ 2mpB is a prime,
which allows that the choice on the message m can be any
distribution over Zn
q .
3.2.2 PRIV1-IND-ID Security
For security, the messages are chosen from the distribu-
tions with suﬃcient entropy over {0, 1}n. Based on the hard-
ness of the LWR problem we can prove our D-HIBE scheme
with random oracles is PRIV1-IND-ID secure.
Theorem 3. If there is an PRIV1-IND-ID adversary A
attacking the D-HIBE scheme with above parameter in Lem-
ma 7 for any x sources messages where x ≥ t log q+ω(log n),
the hash function H is a random oracle deﬁned as before
and QH is the maximum number of queries to H that A
can issue, then there exists an algorithm B attacking the
LWRm,n,q,p problem. In particular, the advantage of A is
Advpriv1-ind-id
D-HIBE,A ≤ dQd
H · Adv
B
LWRm,n,q,p + negl (λ)
(Proof of sketch). Similarly to the proof in Theorem 2, we
can construct an algorithm B which can utilize the ability
of adversary A to solve the LWRm,n,q,p problem. The dif-
ference from the proof in Theorem 2 is the phase of gener-
ating the challenge ciphertext. Given the challenge identity
id∗={i∗
(cid:96)} of length |id∗| = (cid:96) and messages m0, m1
∈ {0, 1}n, B sets Fid∗ := A · R
··· R
(cid:96),i(cid:96)∗ = A0 ∈ Zn×m
−1
id∗ mb(cid:99)p = (cid:98)A0mb(cid:99)p.
and outputs the ciphertext c∗ = (cid:98)Ft
Under the LWR assumption, we have (A0,(cid:98)At
0m0(cid:99)p) ≈c
(A0,(cid:98)u(cid:99)p) ≈c (A0,(cid:98)At
0m1(cid:99)p), where u $←− Zm
q .
1, ..., i∗
−1
1,i∗
q
1
Next, we use the notion of binary tree encryption, which
means that the identities at each level are binary, to remove
the random oracles in the above HIBE and D-HIBE schemes.
Then, we will introduce our HIBE and D-HIBE schemes with
depth d that are selective-secure in the standard model.
3.3 A HIBE Scheme in the Standard Model
The algorithm of our HIBE scheme in the standard model
is described as follows:
KeyGen(1λ)→ (PP, msk ): The algorithm calls Gen-
Trap(1n, 1m, q) to sample a random matrix A ∈ Zn×m
with a short basis TA for Λ⊥
q (A), samples 2d matrices
R1,0, R1,1, ..., Rd,0, Rd,1 from the distribution Dm×m
and chooses a random matrix A1 uniformly from Zn×m