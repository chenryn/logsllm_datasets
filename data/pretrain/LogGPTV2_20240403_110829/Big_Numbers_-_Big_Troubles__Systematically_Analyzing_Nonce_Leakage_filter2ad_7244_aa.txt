title:Big Numbers - Big Troubles: Systematically Analyzing Nonce Leakage
in (EC)DSA Implementations
author:Samuel Weiser and
David Schrammel and
Lukas Bodner and
Raphael Spreitzer
Big Numbers - Big Troubles: Systematically Analyzing 
Nonce Leakage in (EC)DSA Implementations
Samuel Weiser, David Schrammel, and Lukas Bodner, 
Graz University of Technology; Raphael Spreitzer, SGS Digital Trust Services
https://www.usenix.org/conference/usenixsecurity20/presentation/weiser
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.Big Numbers – Big Troubles: Systematically
Analyzing Nonce Leakage in (EC)DSA Implementations
Samuel Weiser
Graz University of Technology
David Schrammel
Graz University of Technology
Lukas Bodner
Graz University of Technology
Raphael Spreitzer
SGS Digital Trust Services
Abstract
Side-channel attacks exploiting (EC)DSA nonce leakage eas-
ily lead to full key recovery. Although (EC)DSA implementa-
tions have already been hardened against side-channel leakage
using the constant-time paradigm, the long-standing cat-and-
mouse-game of attacks and patches continues. In particular,
current code review is prone to miss less obvious side chan-
nels hidden deeply in the call stack. To solve this problem, a
systematic study of nonce leakage is necessary.
We present a systematic analysis of nonce leakage in cryp-
tographic implementations. In particular, we expand DATA,
an open-source side-channel analysis framework, to detect
nonce leakage. Our analysis identiﬁed multiple unknown
nonce leakage vulnerabilities across all essential computation
steps involving nonces. Among others, we uncover inherent
problems in Bignumber implementations that break claimed
constant-time guarantees of (EC)DSA implementations if
secrets are close to a word boundary. We found that lazy re-
sizing of Bignumbers in OpenSSL and LibreSSL yields a
highly accurate and easily exploitable side channel, which
has been acknowledged with two CVEs. Surprisingly, we also
found a tiny but expressive leakage in the constant-time scalar
multiplication of OpenSSL and BoringSSL. Moreover, in the
process of reporting and patching, we identiﬁed newly intro-
duced leakage with the support of our tool, thus preventing
another attack-patch cycle. We open-source our tool, together
with an intuitive graphical user interface we developed.
1 Introduction
Digital signatures are an essential building block for en-
crypted communication channels, e.g., via Transport Layer
Security (TLS) and the underlying public key infrastructures,
SSH, as well as for cryptocurrencies. The extensive and ubiq-
uitous usage of digital signature schemes demands good secu-
rity arguments, not only from a cryptanalytic perspective but
also regarding their implementation, as a single implementa-
tion vulnerability can completely break the scheme [14].
Most digital signature schemes used today are susceptible
to attacks on their so-called nonces [40]. Even partial knowl-
edge of nonces leads to full recovery of private keys, thus al-
lowing an attacker to issue fake signatures, impersonate users,
intercept communication channels, steal money, etc. In light
of these threats, digital signature implementations need exten-
sive hardening against nonce leakage. While biased random
number generation [14] is a common implementation pitfall,
also side channels [15] have been proven a powerful way
of leaking nonce bits. Especially side-channel attacks con-
stantly improve along several axes. This includes advanced
side-channel observation methods, a reduction of required
knowledge, faster key recovery attacks, and most importantly,
the continued discovery of new side-channel leakage.
Modern cryptographic libraries already explicitly address
nonce leakage by relying on constant-time code execution.
Unfortunately, efforts to make implementations side-channel
resistant are not being evaluated thoroughly enough, leading
to a continuous cycle of vulnerability disclosure and patching.
To break this cycle, a more systematic approach for nonce
leakage analysis is required. However, this seems to be a
challenging endeavor for the following reasons:
1. Although side-channel evaluation is actively researched,
complex code bases such as OpenSSL are hard to evaluate.
2. Popular libraries use randomization, e.g., blinding, to
avoid leakage in vulnerable non-constant-time code. How-
ever, analyzing blinded computations for side channels is
non-trivial; and insufﬁcient blinding is exploitable.
3. Cryptographic libraries use non-constant-time code when
computing on public data. Although legitimate, this puts
additional burden on code analysis to avoid false positives.
4. Although tool support for side-channel analysis is grow-
ing, existing tools do not address nonce leakage.
We address these challenges by extending the DATA frame-
work [55]. In particular, we adapt DATA to recognize nonces
as additional secrets in a backward manner and develop leak-
age models tailored for detecting nonce leakage. With our
statistical tests, we ﬁlter leakage results with respect to nonce
leakage. We also develop a graphical user interface for vi-
USENIX Association
29th USENIX Security Symposium    1767
ARTIFACTEVALUATEDPASSEDsualizing leakage results. This allows us to systematically
analyze three popular cryptographic libraries for (EC)DSA
nonce leakage, namely OpenSSL, LibreSSL, and BoringSSL.
We systematically analyze the whole lifetime of a nonce,
i.e., from its generation to its ﬁnal use. Rather than prov-
ing code secure—which would typically require formal mod-
els and static analysis approaches—we focus on ﬁnding ac-
tual side-channel vulnerabilities. We uncovered numerous
unknown vulnerabilities leaking nonce bits, and thereby high-
light a fundamental problem in the Bignumber representation
in OpenSSL and LibreSSL. In particular, if the nonce is close
to a machine word boundary, the Bignumber implementations
possibly leak whether the nonce crosses this boundary in
either direction. We found that lazy resize operations involv-
ing the nonce leak several nonce bits via Flush+Reload [61],
as documented under CVE-2018-0734 and CVE-2018-0735.
Surprisingly, this leakage occurs due to a side-channel defense
mechanism. We also found that small nonces can leak nine
nonce bits at once for the secp521r1 curve. The Bignumber im-
plementation of BoringSSL [7] prevents size-related Bignum-
ber issues by design. Yet, we found a tiny but expressive leak
in the constant-time scalar multiplication of BoringSSL and
OpenSSL. During responsible disclosure, we identiﬁed a ﬂaw
in the OpenSSL patches that would have downgraded expo-
nentiation to a vulnerable implementation (cf. [24]). We re-
port residual leakage in the patched OpenSSL version, which
we exploit via controlled-channel attacks [59] for full key
recovery. Due to our ﬁndings, the OpenSSL team decided to
rework Bignumber arithmetic, similar to BoringSSL [19].
This work provides a snapshot of the current situation of
nonce leakage in popular cryptographic libraries. With the
help of our GUI we analyzed known and unknown vulnerabil-
ities and document their potential damage, exploitability, and
patching state. We open-source both our tool and the GUI to
facilitate reproducibility and future side-channel analysis. 1
Contributions. Our contributions are as follows:
• We expand an analysis framework for automated nonce
leakage detection, and present results in an intuitive GUI.
• We systematically analyze nonce leakage in three popular
crypto libraries: OpenSSL, LibreSSL, and BoringSSL.
• We document several unknown leakage vulnerabilities
resulting from fundamental ﬂaws in the Bignumbers rep-
resentation of OpenSSL and LibreSSL, among others.
• We responsibly disclosed vulnerabilities, proposed ﬁxes,
and document residual leakage that remains unﬁxed.
Outline. Section 2 gives background information. Section 3
discusses related work on nonce attacks and side-channel
analysis tools. Section 4 presents our automated side-channel
analysis tool. Section 5 outlines analysis results and Section 6
discusses the vulnerabilities in detail. Section 7 evaluates our
leakage models. We discuss the implications of our work in
Section 8 and conclude in Section 9.
1Our tool and the GUI is available under https://github.com/
Fraunhofer-AISEC/DATA and https://github.com/IAIK/data-gui
2 Background
2.1 Digital Signatures
DSA. The Digital Signature Algorithm (DSA) [29] is based
on prime ﬁelds. It relies on two primes p and q, where
q divides p − 1. Parameter g serves as generator over p
such that gq ≡ 1 mod p. Keys are generated as follows:
x R← [1,q− 1]
y ← gx mod p
(1)
kinv ← k−1 mod q
(2)
The private key x is sampled uniformly from [1,q− 1]. The
public key y is obtained by Equation (2). The signature (r,s)
for message m involves a random value k denoted as nonce:
k R← [1,q− 1]
(3)
r ← gk mod q (4)
(5)
s ← kinv· (m + xr) mod q (6)
Other DSA Constructions. Several DSA variants exist.
Schnorr signatures [47] omit the inversion step in Equation (5).
Deterministic schemes [28, 44] derive unique nonces from
the message input instead of using random numbers in Equa-
tion (3). ECDSA [29] is one of the most widely used signature
algorithms nowadays. It computes r in Equation (4) via scalar
multiplication over an elliptic curve generator G as follows:
r = k· G
(7)
Nonce Attacks. DSA-like cryptosystems strongly rely on the
secrecy and the uniformity of the nonce k. It has been shown
that even partial knowledge of the nonce sufﬁces to break the
scheme [40]. This knowledge can be obtained by weak nonce
generation algorithms [5] or side channels [15]. By collecting
enough “leaky” signatures, one can formulate a so-called Hid-
den Number Problem (HNP) [10] and recover the private key
with lattice or Bleichenbacher attacks. Thus, an implementa-
tion needs to properly address both cases and protect nonces
throughout their whole lifetime (cf. Equations (3) to (6)).
2.2 The Hidden Number Problem
Nonce leakage can be encoded as a Hidden Number Prob-
lem (HNP). Solving the HNP via lattice attacks or more
generic Bleichenbacher attacks reveals the private key.
HNP. The HNP [10, 11] denotes the problem of ﬁnding a
hidden number given partial information about multiples of
the hidden number. Following [6, 46], we denote (cid:98)·(cid:99)q as the
value modulo q and |·|q as reducing the argument modulo q
into the range [−q/2,q/2] and then taking the absolute value.
MSBL,q(k) denotes knowledge about the L most signiﬁcant
bits of k, i.e., an integer u satisfying |k− u|q < q/2L+1.
The HNP attempts to recover a hidden number x ∈ [1,q−1],
given knowledge of its multiples t1, ...,td ∈ Fq for a known
prime q as well as knowledge about ui = MSBL,q((cid:98)tix(cid:99)q). This
yields a system of d inequalities:
|(cid:98)tix(cid:99)q − ui|q < q/2Li+1 for all i ∈ {1, ...,d}
(8)
1768    29th USENIX Security Symposium
USENIX Association
(EC)DSA can be encoded as an instance of the HNP to
recover the private key x from signatures (r,s) and known
nonce bits u = MSBL,q(k). Using Equation (6) gives:
nonce bias for 160-bit ECDSA using 233 signatures. De Mul-
der et al. [35] used a BKZ-based method to exploit a 5-bit
leakage of 384-bit ECDSA using 4000 signatures.
|k− u|q
|(cid:98)(m + xr)· s−1(cid:99)q − u|q
|(cid:98)(cid:98)s−1r(cid:99)q · x(cid:99)q −(cid:98)u− s−1m(cid:99)q|q
< q/2L+1
< q/2L+1
< q/2L+1
(9)
(10)
(11)
Applying Equation (11) to d signatures (ri,si) and nonce
bits ui yields an HNP. The HNP can also be applied when
leaking inverse nonces, least signiﬁcant nonce bits, or a block
of contiguous [27] or non-contiguous bits [26].
Lattice. Boneh et al. [10] mapped the HNP to a Closest Vector
Problem (CVP). Let t = (t1, ...,td,1) and tx = (t1x, ...,tdx,x).
According to the HNP, (cid:98)tx(cid:99)q will be a close vector to u =
(u1, ...,ud,0) with a distance smaller than q/2Li+1 for the ﬁrst
d components, i.e., (cid:98)tx(cid:99)q − u will be small multiples of q. By
constructing a lattice basis B from t and solving the CVP, the
closest vector tx reveals the private key x. Boneh et al. solved
the CVP by using LLL [33] lattice reduction and Babai’s
nearest plane algorithm [4] to recover Difﬁe-Hellman keys.
Different representations of the lattice exist [6, 38, 39]. To
ensure that the closest vector reveals the private key x, the ﬁrst
d components of t and u are scaled by 2Li+1. Following [6],
this gives a d + 1-dimensional row-wise lattice basis B:
B =
2L1+1q
2L1+1t1
. . .
. . .
2Ld +1q
2Ld +1td
0
...
0
1
(12)
(13)
Instead of using Babai’s nearest plane algorithm, it is also
possible to embed the CVP into a Shortest Vector Problem
(SVP) and solve it directly via lattice reduction [22, 40, 57].
The idea is to include the scaled vector u(cid:48) in the lattice basis:
(cid:20)B 0
(cid:21)
B(cid:48) =
u(cid:48)
q
Boneh et al. [10] showed that this requires at least L =
log2 log2 q bit leakage. Howegrave-Graham and Smart [27]
recovered the private key for 160-bit DSA given 30 signatures
and knowledge of 8 bits for each nonce. Naccache et al. [37]
only required 27 signatures for the same leakage using the
block Korkin-Zolotarev (BKZ) algorithm. Given 200 signa-
tures and two shared LSBs of the nonce, Faugère et al. [22]
recovered the private key using a lattice attack. Besides, they
recovered the private key with a probability of 90% with just
a single shared LSB and 400 signatures.
Bleichenbacher. Bleichenbacher [9] proposed an FFT-based
attack using exponential sums to detect inﬂuences of small bi-
ases. Compared to lattice attacks, this requires more samples
but is noise-tolerant and works with small and even fractional
bit leaks [35, 36]. Aranha et al. [3] exploited a single-bit
2.3 Side-Channel Attacks
Side-channel attacks allow breaking cryptographic implemen-
tations via unintended information leakage. They range from
observing the overall execution time [30] to more ﬁne-grained
microarchitectural effects. Cache attacks target code accesses
on a cache-line granularity via Flush+Reload [61] or data ac-
cesses via the more generic but coarse-grained Prime+Probe
technique [42, 50]. In an SGX setting, powerful controlled-
channel attacks [59] leak page accesses with high accuracy. In
this work we consider address leakage, as a generalization of
above side channels. Physical side channels are out of scope.
3 Related Work
3.1 Side-Channel Attacks
Modular Exponentiation. Square-and-multiply is a com-
mon technique for computing modular exponentiations and
was targeted by Yarom and Falkner [61] in GnuPG. They
extracted 97% of an RSA key from a single sign operation
observed with Flush+Reload. Similarly, Prime+Probe attacks
have been launched against GnuPG [34] and libgcrypt [64].
A faster alternative is the sliding window approach [12].
Percival [42] attacked OpenSSL’s sliding window implemen-
tation by a technique that became known as Prime+Probe [50].
Similarly, the sliding window implementations of libgcrypt
RSA [8] and GnuPG ElGamal [34] have been attacked.
Using ﬁxed windows eradicates leakage due to conditional
code execution in the sliding window approach. However,
an implementation ﬂaw in an earlier version of OpenSSL
allowed bypassing the ﬁxed window implementation [24].
To prevent leakage of the window multipliers, the scatter-
gather technique aligns multipliers in memory such that the
same cache lines are accessed all the time. Yarom et al. [62]
exploited cache-bank conﬂicts to attack OpenSSL’s scatter-
gather implementation.
In the SGX setting, Prime+Probe attacks have been
launched from malicious operating systems against the ﬁxed-
window exponentiation during the RSA decryption in the
Intel IPP library [13]. Besides, Prime+Probe attacks have also