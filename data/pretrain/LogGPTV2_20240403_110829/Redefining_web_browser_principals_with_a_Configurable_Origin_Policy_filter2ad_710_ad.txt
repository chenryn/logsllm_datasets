Type a URL
HyperLink
such as 
Scripts or Stylesheet
Embeded Object, like
iframe and img tag
XMLHTTPRequest
empty originID from a new empty principal
URL in PSL: originID from the current principal
URL not in PSL: empty value
secret originID
URL in PSL: originID from the current principal
URL not in PSL: empty value
URL in PSL: originID from the current principal
URL not in PSL: secret originID
of policies for association of originID with these resources:
inheritance and dynamic generation.
Inheritance is the default enforced policy. As shown in
Figure 7, we create an iframe ifr1, which inherits the same
originID from the HTML document (line 1). However, an
originID can also be speciﬁed dynamically. As shown line 4
of Figure 7, the iframe ifr2 is created and is given a unique
but different originID value through generateoriginID() (line
7).
D. Transfer of Resources
Resources are transferred from the server to the client
and across browser principals. In this section, we describe
how COF secures client-server communications and how the
browser mediates cross principal communications.
1) Client-server Communication - HTTP: As shown in
Figure 6(a), the HTTP exchanges between the server and
client are associated with an originID. As in the spirit of
veriﬁable origin policy [2], the originID of the request from a
principal does not decide whether the corresponding response
is accessible to the principal, and this principal is allowed to
access the response only if the response carries the same
originID as the principal’s originID or default originID. (For
default originID in the response, if the principal is empty,
client browser will generate a new originID.) Now we discuss
how the originID is used in the communication.
TABLE III.
ORIGINID IN HTTP RESPONSE ACCORDING TO
DIFFERENT HTTP REQUESTS AND SERVER’S DECISIONS.
OriginID
in HTTP
Request
empty
OID1
secret
Join
Operation
N/A
OID1
N/A
OriginID in HTTP Response
Create
Comm inside
Principal
Operation
N/A
OID1
N/A
New Value
N/A
N/A
Cacheable
Content
default
default
default
To achieve those three requests, in COF, a principal can
conﬁgure whether an HTTP request is from the current prin-
cipal or a different one by specifying originID such as . However, to be convenient for pro-
grammers and compatible with SOP, the client browser can
also attach an originID for those HTTP requests without orig-
inIDs speciﬁed explicitly, as shown in Table II. The default
policy aligns with SOP.
HTTP Response. An HTTP response is generated by the
web server according to the HTTP request received. Based
on different originIDs in the request and operations that the
web server wants to perform, the web server will attach
different originIDs in the response as listed in Table III. For
example, when the web server receives a request with a empty
originID, it will send its response with a new originID and
the client browser will adopt this originID as the originID for
that empty principal.
An Example. Suppose a web page has an iframe . The browser will
ﬁrst create a principal with OID1 for the iframe. Then it will
send a request with OID1 to example.com. If example.com
agrees to join the principal, it will send an HTTP response
with header ”originID: OID1”. Therefore, the browser will
render the response inside the OID1 principal. If example.
com does not agree, it will send a 404 HTTP response or
other error messages.
2) Communications between Principals: The postMessage
channel facilitates cross-principal communication at client
side. The usage of postMessage2 is like popup.postMessage2
(”hello!”, popup.publicID); due to the attack in Section II-B1.
While postMessage takes an SOP origin as its second argu-
ment and performs an SOP check, postMessage2 replaces
this with a publicID check. The attack in Section II-B1 is
mitigated because a malicious gadget always has a different
publicID from a benign one.
E. Discussion on Compatibility
We present whether COP feature can be compatible with
existing web servers, existing browsers and new HTML5
features.
HTTP Request. HTTP requests in different operations have
different behaviors. (i) Communication inside the current
principal (a request to a server in PSL): launched from the
current principal with its originID. (ii) Join operation (a
request to a server NOT in PSL): launched from the current
principal with its originID and PSL (iii) Create Operation
(no matter whether the requested server is in PSL or not):
launched from a different principal with that principal’s orig-
inID.
Compatibility with Existing Servers. Existing servers don’t
specify an originID in their transmission. However, we can
still be backward compatible with existing servers. We use
a SOP tuple as an originID because SOP can be viewed as
a special case of COP. We can still assign each SOP origin
a principal if originID is not speciﬁed. Other COP-enabled
principals are not allowed to switch their originID to any SOP
tuple. At the same time, we need to allow document.domain.
The security of older web sites neither improves nor worsens.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:23 UTC from IEEE Xplore.  Restrictions apply. 
Compatibility with Existing Browsers. There are two pos-
sible options to make COP-enabled servers compatible with
existing client browsers. First, existing servers can detect the
client browser and deliver content accordingly, but this can be
inconvenient. We have taken the second approach to convey
originIDs in a new protocol ﬁeld that older browsers will
ignore. We have shown earlier in the section how this is
accomplished for HTML and HTTP.
Compatibility with new HTML5 features. Some new fea-
tures in HTML5, such as localStorage and FileSystem, are de-
signed to grant access to a long-term identiﬁer. Those features
can be still supported in COP. Take localStorage for example.
It can be modiﬁed to allow access from those principals
with the same PSL. Therefore, a merged principal from both
Yelp and Facebook cannot access the localStorage of pure
Facebook.
V. SECURITY ANALYSIS
In this section, we ﬁrst analyze possible attacks on COP
and how such attacks can be mitigated. Then, we discuss
whether COP can help defend against existing web attacks,
such as CSRF. In the end, we perform a formal security
analysis based on an existing web security model.
A. COP-Speciﬁc Attacks and Mitigation
1) Leaking OriginIDs: OriginID is an essential and secret
identity for a principal. We neet to prevent leaking originIDs.
Protecting OriginIDs. Given the similarity between orig-
inIDs and session cookies, methods of protecting session
cookies can also be used for protecting originIDs.
• Server-side protection: Reusing protection mechanisms
for session cookies. OriginIDs are generated dynamically
and stored safely the same as session cookies on server
side.
• Protection during transmission: HTTPS.
• Client-side protection: (i) Preventing originID access from
a different principal through a sandbox approach [37] or
JavaScript rewriting approaches [38]. (ii) Channel bound
originID. Similar to channel-bound cookies [39], originID
can be made channel-bound too. Even if an attacker ac-
quires a channel-bound originID, he cannot authenticate it
with the server via other connections.
How do we prevent originID leaks by a careless pro-
grammer’s mistake? Two methods are adopted to prevent
leaking originID by a mistake: (i) Defaulting safe behaviors.
As shown in Table II, default behaviors of sending originIDs
are restricted within known servers (if no merging occurs,
there is only SOP server). (ii) Using secret originID. In case
that the programmer does not know how to use originID
correctly, he can use secret originID to prevent originID leaks.
Given two aforementioned protection mechanisms, we be-
lieve a web site will seldom send its originID to a malicious
source by, for example, including third-party content through
iframes in a wrong way. It is the same as the fact that a web
site rarely includes a malicious script directly or carelessly
sends its session cookie to a malicious server.
What if originID is leaked through an HTTP connec-
tion? Let us discuss a scenario where a web site benign.com
is using HTTP and originID can be sniffed. We have the
following two arguments: (i) Overall small chance. (ii) Even
if it happens, there is no additional damages brought by COP.
First, the chance that the contents of benign.com can be
manipulated is small. Clients need to visit benign.com in an
open network such as coffee shop. Then, the attacker needs
to lure the client to visit malicious.com in the same browser
in order to join and manipulate benign.com’s principal.
Secondly, even if those two conditions are satisﬁed, the
damage an attacker could make is the same as what he could
do from snifﬁng the network and luring people to visit ma-
licious.com.
• Contents of benign.com can be directly sniffed or acquired
by a sniffed session cookie. Meanwhile, the attacker can
also make changes to user’s contents on benign.com by the
sniffed session cookie.
• If benign.com does not have session cookie, phishing by
altering contents in a merged principal is not different
from the one in pure malicious.com, because after merging,
malicious.com is in PSL, which is easily visible to users
in COF.
What is the security implication for Principal A to give
its originID to Principal B in order to conﬁgure Princi-
pal A? It means that Principal A totally trusts Principal B.
For example, ads.cnn.com completely trusts www.cnn.com,
however, they currently use document.domain = ’cnn.com’
to communicate with each other, which is error-prone, as
shown by Singh et al [1]. In COP, A (ads.cnn.com) can give
its originID to B (www.cnn.com).
2) Potential Attacks when Combining SOP and COP:
Interaction of web content following COP and web con-
tent following SOP may lead to attacks. In a web integrator
where all its isolated gadgets are from the same domain,
an attacker might modify a principal with originID back to
a principal with SOP origin by removing the originID, so
that the attacker can access another principal with the same
SOP origin but not the same COP origin. We resolve this
problem by always using COP when either of two principals
is using COP. The originID of a SOP site will be derived
from the SOP triple and hence will be different from every
COP originID. In this case, two principals need to use the
postMessage channel to communicate with each other.
Another attack is to integrate COP web sites with SOP
web sites. For example, an SOP web site is embedded inside
a COP web site using an iframe. COF can deal with this
case because SOP is a special case in COP. If we don’t
ﬁnd originID speciﬁed, we will consider the  to be a special originID which is different from any
other originID speciﬁed by COP web sites. COF will always
put contents in the iframe from SOP sites into a separate
principal. We can always differentiate COP and SOP web
sites because COP web sites will always have an originID
HTTP header.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:23 UTC from IEEE Xplore.  Restrictions apply. 
3) Principal Hijacking Attack: Given the similarity be-
tween a session cookie and an originID, the attacks to session
cookies, such as session substitution/ﬁxation [40], also need
to be considered here. Translated to originID attack, a session
substitution/ﬁxation will be as follows.
An attacker M visits benign.com on his own and ac-
quire the originID OID1 for his principal A. The attacker
triggers the client to visit his own web page malicious.com
and set the originID of the malicious principal B to OID1.
The malicious principal B sends a request to benign.com.
Then, benign.com will consider the OID1 to be within the
attacker’s principal A and return contents. Client user will
see a web page from benign.com but controlled by M .
Defense. When the malicious principal B sends a request to
benign.com, since benign.com is not in the PSL of B, the
client browser will ask benign.com to join B with B’s orig-
inID and PSL (malicious.com). Benign.com can recognize
that B is controlled by malicious.com and thus decline the
request.
B. Mitigating Existing Attacks
Cross-Origin CSS Attacks. Cross-Origin CSS attacks were
described recently by Huang et al. [9]. The attacker may
inject some crafted content into example.com using blog posts
or wall posts and then use their site attack.com to import
example.com as a CSS stylesheet. When a user visits at-
tack.com, the conﬁdential information of that user from exam-
ple.com will be stolen. If COF were adopted here, because the
server will check the originID of the principal that sends the
request, example.com will reject the request, thus preventing
attack.com from importing its contents as a stylesheet.
Document.domain Threat. Document.domain threat is de-
scribed by Singh et al [1]. For example, when a web page
from x.a.com sets its domain to a.com, a web page from
y.a.com, which is compromised by the attacker, can access
the resource of that web page of x.a.com by setting its domain
to a.com. This disobeys least privilege, as access control is
relaxed too broadly.
In COF, only web pages that know the originID belong to
the same principal. For the document.domain example above,
even if an attacker compromises y.a.com, he cannot access
any resource from x.a.com in a COP principal because he
doesn’t know the originID at client side.
Cross-Site Request Forgery (CSRF). CSRF is an attack
which forces execution of unwanted actions from an end user
on a web application in which s/he is currently authenticated
[8]. A typical example of CSRF is an img tag such as
 .
When embedded inside a web page, it triggers browsers
to fetch this link, causing the server to execute the ”transfer”
action. As we can see, there are several steps in CSRF. First,
the link needs to be embedded on the web site. Second, the
browser needs to send the request. Third, the server (the bank
in this case) needs to allow this action. Defenses involve
mitigation at any of the above steps.
Barth et al. [41] have analyzed CSRF and defenses against
it comprehensively. They propose the origin header, which is
similar to the referrer header but without the path and query
parameters so as to ensure user privacy.
In COF, the originID header can effectively play the role
of the origin header. In step three, the web server will use the
originID (sent in step two) to determine if the request orig-
inated from its own principal and thus avoid CSRF attacks
by declining the action from a different principal.
Origin Spooﬁng Attacks. As discussed in Section II-B, an
origin spooﬁng attack is launched by a merged or separated
principal using an old SOP origin to camouﬂage itself. In
COF, we deﬁne originID as the new principal’s label, which
can be checked by a client browser or a web server, thus
mitigating origin spooﬁng attacks.
C. Formal Security Analysis
Background. Akhawe et al. [11] abstract a formal web se-
curity model and build the model based on Alloy, “a model
ﬁnder: given a logical formula, it ﬁnds a model of the for-