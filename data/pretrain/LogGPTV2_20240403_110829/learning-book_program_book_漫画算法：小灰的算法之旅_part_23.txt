解法2：
---
## Page 425
先把数组元素从小到大进行排序，然后遍历已经有序的数组，如果发现
某两个相邻元素并不连续，说明缺少的就是这两个元素之间的整数。
假设数组长度是n，如果用时间复杂度为O(nlogn)的排序算法进行排序，
那么该解法的时间复杂度是O(nlogn)，空间复杂度是O(1)。
OK，这个解法没有开辟额外的空间，但
是时间复杂度又太大了。有没有办法对时间复杂度和空间复杂度都
进行优化呢？
哦，让我想想..
有了！先算出1～100的累加和，然后
再依次减去数组里的所有元素，最后的差值就是所缺少的整数。这
么简单的办法我竞然才想到！
---
## Page 426
解法3：
这是一个很简单也很高效的方法，先算出1+2+3+...+100的和，然后依
次减去数组里的元素，最后得到的差值，就是那个缺失的整数。
假设数组长度是n，那么该解法的时间复杂度是O(n)，空间复杂度是
0(1)。
OK，对于没有重复元素的数组，这个解
法在时间和空间上已经最优了。但如果把问题扩展一下...
5.12.2
问题扩展
题目第1次扩展：
一个无序数组里有若干个正整数，范围是1～100，其中99个整数都出现
了偶数次，只有1个整数出现了奇数次，如何找到这个出现奇数次的整
数？
哦，让我想想...
---
## Page 427
按照刚才的方法先求和肯定不行，因为
根本不知道每个整数出现的次数.....同时又要保证时间和空间复杂
度的最优，怎么办呢？
让我提示你一下吧，你知道异或运算
吗？
1010111
XOR1101100
0111011
异或运算，我当然知道，在进行位运算
时，相同位得0，不同位得1。可是怎么应用到这个题目上面呢？
---
## Page 428
啊，我想到了！只要把数组里所有元
素依次进行异或运算，最后得到的就是那个缺失的整数！
解法：
遍历整个数组，依次做异或运算。由于异或运算在进行位运算时，相同
为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有
唯一出现奇数次的整数会被留下。
让我们举一个例子：给出一个无序数组{3,1,3,2，4,1,4}。
异或运算像加法运算一样，满足交换律和结合律，所以这个数组元素的
异或运算的结果如下图所示。
无序数组：
3132414
异或运算：3xor1xor3xor2xor4xor1
=
=2
假设数组长度是n，那么该解法的时间复杂度是O(n)，空间复杂度是
0(1)。
这个方案已经非常好了。我们把问题最后扩展一下，如果数组里有
2个整数出现了奇数次，其他整数出现偶数次，该如何找出这2个
整数呢？
题目第2次扩展：
---
## Page 429
假设一个无序数组里有若干个正整数，范围是1～100，其中有98个整数
出现了偶数次，只有2个整数出现了奇数次，如何找到这2个出现奇数
次的整数？
啊，这次要找2个整数，刚才的方法已经
不够用了。因为把数组所有元素进行异或运算，最终只会得到2个
整数的异或运算结果。
我来提示你一下吧，你知道分治法吗？
说起分治法，我似乎想到了什么...如
果把数组分成两部分，保证每一部分都包含1个出现奇数次的整
数，这样就与上一题的情况一样了。
---
## Page 430
终于想到了！首先把数组元素依次进
行异或运算，得到的结果是2个出现了奇数次的整数的异或运算结
果，在这个结果中至少有1个二进制位是1。
解法：
把2个出现了奇数次的整数命名为A和B。遍历整个数组，然后依次做异
或运算，进行异或运算的最终结果，等同于A和B进行异或运算的结
果。在这个结果中，至少会有一个二进制位是1（如果都是0，说明A和
B相等，和题目不相符）。
举个例子，给出一个无序数组{4,1,2,2,5,1,4,3}，所有元素进行异或运算
的结果是00000110B。
无序数细：
41225143
异或运算：4xor1xor2xor2xor5xor1xor4xor3
=3x0r5
=00000110B
选定该结果中值为1的某一位数字，如00000110B的倒数第2位是1，这说
明A和B对应的二进制的倒数第2位是不同的。其中必定有一个整数的倒
数第2位是0，另一个整数的倒数第2位是1。
根据这个结论，可以把原数组按照二进制的倒数第2位的不同，分成两
部分，一部分的倒数第2位是0，另一部分的倒数第2位是1。由于A和B
的倒数第2位不同，所以A被分配到其中一部分，B被分配到另一部分，
绝不会出现A和B在同一部分，另一部分既没有A，也没有B的情况。
---
## Page 431
无序数组：
412
5
1
5
4
2
到数第2位为0
到数第2位为1
这样一来就简单多了，我们的问题又回归到了上一题的情况，按照原先
的异或算法，从每一部分中找出唯一的奇数次整数即可。
假设数组长度是n，那么该解法的时间复杂度是O(n)。把数组分成两部
分，并不需要借助额外的存储空间，完全可以在按二进制位分组的同时
来做异或运算，所以空间复杂度仍然是0(1)。
没错，就是这个思路。请你按照这个思
路来写一下代码。
好的，我来试试！
1. public static int[] findLostNum(int[] array) {
---
## Page 432
2.
//用于存储2个出现奇数次的整数
3.
int result[] = new int[2];
4.
//第1次进行整体异或运算
5.
int xorResult = θ;
6.
for(int i=0;i<array.length;i++){
7.
xorResult^=array[i];
8.
9.
//如果进行异或运算的结果为0，则说明输入的数组不符合题目要求
10.
if(xorResult == θ){
11.
return null;
12.
13.
//确定2个整数的不同位，以此来做分组
14.
int separator = 1;
15.
while （0==(xorResult&separator)){
16.
separator<<=1;
17.
18.
//第2次分组进行异或运算
19.
for(int i=0;i<array.length;i++){
20.
if(o==(array[i]&separator)){
21.
result[]^=array[i];
22.
}else{
23.
result[1]^=array[i];
24.
25.
---
## Page 433
26.
27.
return result;
28.}
29.
30.public static void main(String[] args）{
31.
int[] array = {4,1,2,2,5,1,4,3};
32.
int[] result = findLostNum(array);
33.
System.out.println(result[o] + "," + result[1]);
34.}
很好，我们的技术面试就到这里。请你稍等一下，我去叫HR来和你谈
谈。10min后....
小灰，你好。我是这里的积
恭
喜你通过了本公司的技术面试
我来和你聊一下薪酬
太好了，我的努力
终于有回报了
就这样，小灰拿到了职业生涯中的第一个offer，但这并不意味着结束，
小灰的程序员之路才刚刚开始。
---
## Page 434
第6章算法的实际应用
6.1
小灰上班的第1天
小灰，听说你收到oe
了7恭喜呀
谢谢，多亏你这段时间的
辅导呢：我再过几天就要
入职了，恐怕以后再也用
不到算法了吧？
不，不，不，虽然在工作中我
们很少直接去写某个算法，包
是当调用某个API，或访问某
个数据库时，底层都在情情地
执行着各种各样的算法呢。
---
## Page 435
我懂了
我还不能够松
一定要继续提高白
己，追求对算法更深刻的
理解
几天之后，小灰高高兴兴地去公司报到了
小灰，你好，我是公司的产
品经理小红，请多多指教。
姨，你不是面试
过我的吗？
哦。我刚刚内部转岗啦。
望今后合作输快哦！
---
## Page 436
放心我们一定会微
出最优秀的产品
就这样，小灰正式进入了职场。接下来等待他的会是什么样的挑战呢？
6.2
Bitmap的巧用
6.2.1
一个关于用户标签的需求
小灰，我有一个需
求要和你说谈，
好呀，好呀，有什
么需求你施便提：
---
## Page 437
为了帮助公司精准定位用户群体，咱们需要
开发一个用户画像系统，实现用户信息的标签化，
用户标签包括用户的社会属性、生活习惯、
消费行为等信息，例如下面这个样子。
小灰的用户标签
程序员
有驾照
90后
单身
用苹果手机
从不出差
喜欢美剧
喜欢骑行
租房
---
## Page 438
通过用户标签，我们可以对多样的用户群体
进行统计。例如统计用户的男女比例、统计喜欢旅游的用户数量
等。
放心吧，这个需求交给我一定会妥妥
的！
为了满足用户标签的统计需求，小灰利用关系型数据库设计了如下的表
结构，每一个维度的标签对应着数据库表中的一列。
Name
Sex
Age
Occupation
Phone
小灰
男
90后
程序员
苹果
大黄
男
90后
程序员
三星
小白
女
00后
学生
小米
要想统计所有“90后"的程序员，该怎么做呢？
用一条求交集的SQL语句即可。
Select
count(distinct
Name)
as
用户
数fromtablewhereage='90后’and0ccupation=’程序员’；
---
## Page 439
要想统计所有使用苹果手机或“00后"的用户总和，该怎么做呢？
用一条求并集的SQL语句即可。
Select
count
(distinct
Name)
as
用户
数from table where Phone =
看起来很简单嘛，嘿嘿....
两个月之后...
事情没那么简单，现在标签越来越多，
例如用户去过的城市、消费水平、爱吃的东西、喜欢的音乐..都
快有上千个标签了，这要给数据库表增加多少列啊！
筛选的标签条件过多的时候，拼出来的
SQL语句像面条一样长....
---
## Page 440
不仅如此，当对多个用户群体求并集
时，需要用distinct来去掉重复数据，性能实在太差了....
天响这可怎么办？
6.2.2
用算法解决问题
小灰，你怎么愁眉苦脸的呀？
---
## Page 441
喉，还不是被一个需求折腾的！
事情是这样子的.....（小灰把工
作中的难题告诉了大黄）
哈哈，小灰，你听说过Bitmap算法
吗？在中文里又叫作位图算法。
我又不是搞计算机图形学的，研
---
## Page 442
究位图算法干什么？
这里所说的位图并不是像素图片的位
图，而是内存中连续的二进制位（bit）所组成的数据结构，该算法
主要用于对大量整数做去重和查询操作。
举个例子，假设给出一块长度为10bit
的内存空间，也就是Bitmap，想要依次插入整数4、2、1、3，需要
怎么做呢？
很简单，具体做法如下。
第1步，给出一块长度为10的Bitmap，其中的每一个bit位分别对应着从0
到9的整型数。此时，Bitmap的所有位都是0（用紫色表示）。
8
5
4
3
0
第2步，把整型数4存入Bitmap，对应存储的位置就是下标为4的位置，
将此bit设置为1（用黄色表示）
---
## Page 443
第3步，把整型数2存入Bitmap，对应存储的位置就是下标为2的位置，
将此bit设置为1。
第4步，把整型数1存入Bitmap，对应存储的位置就是下标为1的位置，
将此bit设置为1。
第5步，把整型数3存入Bitmap，对应存储的位置就是下标为3的位置，
将此bit设置为1。
如果问此时Bitmap里存储了哪些元素。显然是4、3、2、1，一目了然。
Bitmap不仅方便查询，还可以去掉重复的整数。
看起来有点意思，可是Bitmap算
法跟我的项目有什么关系呢？
---
## Page 444
你仔细想一想，你所做的用户标签能
不能用Bitmap的形式进行存储呢？
我的每一条用户数据都对应着成百上千
个标签，怎么也无法转换成Bitmap的形式啊？
别急，我们不妨把思路逆转一下，为
什么一定要让一个用户对应多个标签，而不是一个标签对应多个用
户呢？
---
## Page 445
一个标签对应多个用户？让我想想
我明白了！信息不一定非要以用户为
中心，也能够以标签为中心来存储，让每一个标签存储包含此标签
的所有用户ID，就像倒排索引一样！
第1步，建立用户名和用户ID的映射。
---
## Page 446
Name
Sex
Age
Occupation
Phone
小灰
男
90后
程序员
苹果
大黄
男
90后
程序员
三星
小白
女
00后
学生
小米
ID