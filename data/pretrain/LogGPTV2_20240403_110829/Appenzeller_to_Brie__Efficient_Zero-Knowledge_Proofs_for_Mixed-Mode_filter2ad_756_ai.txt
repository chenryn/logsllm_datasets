ComZK
The method calls are simulated as follows:
to generate
a commitment [ğ‘Ÿ] of the form ğ‘€[ğ‘Ÿ] = Î” Â· Ë†ğ‘Ÿ + ğ¾[ğ‘Ÿ]. Since, Pâˆ— is
corrupted, it is allowed to choose its outputs Ë†ğ‘Ÿ, ğ‘€[ğ‘Ÿ] âˆˆ Z2ğ‘˜+ğ‘  . S
sends (Random) on behalf of Pâˆ— to F Z2ğ‘˜
and chooses ğ‘Ÿ := Ë†ğ‘Ÿ mod
2ğ‘˜ as value of the commitment. Hence, Pâˆ— receives Ë†ğ‘Ÿ, ğ‘€[ğ‘Ÿ] âˆˆğ‘…
For Random, the parties call the Expand of F ğ‘ ,ğ‘˜+ğ‘ 
ComZK
vole2k
vole2k
vole2k
ComZK
ComZK
-hybrid model). And S
Z2ğ‘˜+ğ‘  as in the real protocol (in the F ğ‘ ,ğ‘˜+ğ‘ 
keeps track of all the commitments generated.
Affine is purely local, so there is no interaction to be simulated.
S instructs the ideal functionality to perform the corresponding
operations and computes the resulting commitments.
For CheckZero, S first simulates the calls to Random, and runs
the protocol with the simulated parties. Then it sends the CheckZero
. If the simulated verifier aborts, then S sends
message to F Z2ğ‘˜
(abort) to F Z2ğ‘˜
, which results in the ideal verifier aborting. To
show that the verifierâ€™s output is indistinguishable between the real
execution and the simulation we combine the following two facts:
1. If the verifier aborts in the real execution, then it does the same
in the simulation. This holds by definition of the simulation. 2. If
the verifier outputs (success) in the real execution, then it does
the same in the simulation except with probability at most ğœ€cz (de-
fined in Lemma 5.2). We show the contraposition, i.e. if the verifier
aborts in the simulation, then it does the same in the real execution
except with the given probability. By definition of F Z2ğ‘˜
, the
premise hold if one of the input commitments contains a non-zero
value. Thus, we can apply Lemma 5.2, which gives us the desired
consequence.
For Input, the parties first invoke Random to obtain a commit-
ment [ğ‘Ÿ], so S simulates this (see above). Input is the only method,
where the prover has a private input. The simulator can extract it
from Pâˆ—â€™s message ğ›¿ âˆˆ Z2ğ‘˜ by computing ğ‘¥ â† ğ›¿ + ğ‘Ÿ (it knows ğ‘Ÿ
because it simulates the F ğ‘ ,ğ‘˜+ğ‘ 
functionality). Then S can send
(Input, ğ‘¥) on behalf of the corrupted prover to the ideal functional-
ity F Z2ğ‘˜
. For correctness, note that a commitment [ğ‘Ÿ] + (ğ‘¥ âˆ’ ğ‘Ÿ)
contains the value ğ‘¥ iff. [ğ‘Ÿ] is a commitment to ğ‘Ÿ.
Since Open is implemented in terms of Affine and CheckZero,
and we have that a commitment [ğ‘¥] contains a value ğ‘¥ iff. [ğ‘¥] âˆ’ ğ‘¥
is a commitment to 0. We can simulate the methods as describe
above. Hence, the simulation of Open fails exactly if the simulation
of CheckZero fails.
CheckMult is simulated in the same way as CheckZero. Here,
we apply Lemma 5.3, and get that the output of V is the same in
the simulation and in the real execution except with probability at
most ğœ€cz + ğœ€cm.
This concludes the proof for the case of a corrupted prover. As
shown above, we can simulate its view perfectly for all methods.
Overall, by the union bound, the environment has an distinguishing
ComZK
ComZK
vole2k
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea208advantage of
(ğ‘cz + ğ‘cm) Â· ğœ€cz + ğ‘ğ‘š Â· ğœ€cm.
.
vole2k
ComZK
Malicious Verifier. The setup of the simulation in case of a cor-
rupted verifier Vâˆ— is similar as before. S sends (corrupted,V) to
the ideal functionality F Z2ğ‘˜
. It creates copies of the prover P and
verifier Vâˆ—. The prover is run according to the protocol, whereas
the environment controls the verifier. For this, S simulates the
functionality of F ğ‘ ,ğ‘˜+ğ‘ 
with corrupted V. For all methods, since
V does not have any private inputs no input extraction is neces-
sary. So the simulator can just send the corresponding message on
behalf of the verifier to F Z2ğ‘˜
. The method calls are simulated as
follows:
During initialization, S allows Vâˆ— to choose its MAC key Î” with
the simulated F ğ‘ ,ğ‘˜+ğ‘ 
For Random, the parties call the Expand of F ğ‘ ,ğ‘˜+ğ‘ 
to generate
a commitment [ğ‘Ÿ] of the form ğ‘€[ğ‘Ÿ] = Î” Â· Ë†ğ‘Ÿ + ğ¾[ğ‘Ÿ] where Vâˆ— can
choose ğ¾[ğ‘Ÿ]. S sends (Random) on behalf of Vâˆ— to F Z2ğ‘˜
As before, Affine is purely local, so there is no interaction to be
simulated. S instructs the ideal functionality to perform the corre-
sponding operations and computes the resulting commitments.
functionality.
ComZK
ComZK
vole2k
vole2k
ComZK
ComZK
ComZK
For CheckZero, S sends the respective message to F Z2ğ‘˜
. If it
aborts, then S instructs the simulated P to also abort by sending
(abort) to the simulated V, which finishes the simulation. Other-
wise, S simulates the normal protocol execution: It first simulates
the calls to Random. Since F Z2ğ‘˜
did not abort, we know that ğ‘¥1 =
Â· Â· Â· = ğ‘¥ğ‘› = 0. We also know Î”, ğ¾[ğ‘¥1], . . . , ğ¾[ğ‘¥ğ‘›], ğ¾[ğ‘Ÿ1], . . . , ğ¾[ğ‘Ÿğ‘›],
so we can sample ğ‘1, . . . , ğ‘ğ‘› âˆˆğ‘… Z2ğ‘  and compute ğ‘€[ğ‘¦ğ‘–]â€² â† Î” Â·
2ğ‘˜ Â· ğ‘ğ‘– + ğ¾[ğ‘¥ğ‘–] + 2ğ‘˜ Â· ğ¾[ğ‘Ÿğ‘–] for ğ‘– = 1, . . . , ğ‘›. Then, the ğ‘ğ‘– and
â„ := ğ»(ğ‘€[ğ‘¦1]â€², . . . , ğ‘€[ğ‘¦ğ‘›]â€²) are as expected by the verifier.
For Input, S first simulates the call to Random as above, and
then sends a random value ğ›¿ âˆˆğ‘… Z2ğ‘˜ to the simulated verifier. Also,
S sends (Input) on behalf of Vâˆ— to F Z2ğ‘˜
For Open, S sends the Open on behalf of Vâˆ— to F Z2ğ‘˜
and
receives the committed values ğ‘¥1, . . . , ğ‘¥ğ‘› âˆˆ Z2ğ‘˜ as output. It sends
these values to the simulated verifier, and then simulates Affine and
CheckZero as above. So the view is distributed identically to the
real protocol.
For CheckMult, S sends the corresponding message on behalf of
the corrupted verifier to F Z2ğ‘˜
. If it aborts, then S instructs the
simulated P to also abort by sending (abort) to the simulated V.
Otherwise, S simulates the complete protocol using the constant
value 0 for all of the proverâ€™s commitments. Because the simulated
P behaves like an honest prover, it samples all multiplication triples
([ğ‘¥ğ‘–], [ğ‘¦ğ‘–], [ğ‘§ğ‘–])â„“
ğ‘–=1 correctly. Since the view of the V is distributed
identically to the real execution and independent of the proverâ€™s
real inputs: The opened triples in Step 6 are uniformly distributed,
valid multiplication triples. The values ğ‘‘, ğ‘’ revealed in Step 8a are
distributed uniformly in Z2ğ‘˜ , and the CheckZero passes since the
ğ‘¤ğ‘˜ are all 0.
This concludes the proof for the case of a corrupted verifier. As
shown above, we can simulate its view perfectly for all methods.
Overall, the environment has a distinguishing advantage as stated
in the theorem.
â–¡
ComZK
ComZK
.
1 + ğ¾[ğ‘¦1], . . . , Î”Â·2ğ‘˜ Â· ğ‘â€²
E.2 Proof of Lemma 5.2
Proof of Lemma 5.2. Suppose Pâˆ— and V run the protocol on
commitments [ğ‘¥1], . . . , [ğ‘¥ğ‘›], but (ğ‘¥1, . . . , ğ‘¥ğ‘›) (cid:46)ğ‘˜ (0, . . . , 0). Hence,
there is an index ğ‘–âˆ— âˆˆ {1, . . . , ğ‘›} with ğ‘¥ğ‘–âˆ— (cid:46)ğ‘˜ 0. Thus, also ğ‘¦ğ‘–âˆ— (cid:46)ğ‘˜ 0.
Write Ëœğ‘¦ğ‘–âˆ— = 2ğ‘˜Â·ğ‘ğ‘–âˆ—+ğ›¿ with ğ›¿ âˆˆ Z2ğ‘˜ \{0}. Let ğ‘â€²
ğ‘– âˆˆ Z2ğ‘  for ğ‘– = 1, . . . , ğ‘›
denote the values sent by the prover instead of ğ‘1, . . . , ğ‘ğ‘› and define
ğ‘ := (Î”Â·2ğ‘˜ Â· ğ‘â€²
ğ‘› + ğ¾[ğ‘¦ğ‘›]). Let â„ = ğ»(ğ‘) be the
message an honest prover would send, and â„â€² âˆˆ {0, 1}ğ‘  the message
that Pâˆ— actually sends. V outputs (success), if â„â€² = â„ holds. We
make a case distinction on how Pâˆ— could produce such an â„â€²:
(1) First, Pâˆ— could try to compute the message ğ‘ that V inputs
into ğ», and then compute â„â€² := ğ»(ğ‘) = â„. To this end, given
ğ‘€[ğ‘¦ğ‘–âˆ—] = Î” Â· Ëœğ‘¦ğ‘–âˆ— + ğ¾[ğ‘¦ğ‘–âˆ—], Pâˆ— needs to come up with a value
ğ‘€[ğ‘¦ğ‘–âˆ—]â€² = Î” Â· 2ğ‘˜ Â· ğ‘â€²
ğ‘–âˆ— + ğ¾[ğ‘¦ğ‘–âˆ—]. Let ğ‘£ âˆˆ N maximal such that
2ğ‘£ | ğ›¿. By computing
ğ‘€[ğ‘¦ğ‘–âˆ—] âˆ’ ğ‘€[ğ‘¦ğ‘–âˆ—]â€²
(cid:32) 2ğ‘˜ Â· (ğ‘ğ‘–âˆ— âˆ’ ğ‘â€²
(cid:33)âˆ’1
ğ‘–âˆ—) + ğ›¿
(mod 2ğ‘˜+ğ‘ âˆ’ğ‘£),
Î” =
Â·
2ğ‘£
2ğ‘£
Pâˆ— could recover Î” âˆˆ Zğ‘ . Hence, this strategy is successful with
probability at most 2âˆ’ğ‘ .
(2) If Pâˆ— is not able to compute ğ‘, then â„ = ğ»(ğ‘) is uniformly
random from Pâˆ—â€™s view. So whatever message â„â€² it sends, â„ = â„â€²
holds with probability at most 2âˆ’ğ‘ .
By the union bound, Pâˆ— can produce such an â„â€² with probability
at most 2âˆ’ğ‘ +1.
â–¡
E.3 Proof of Lemma 5.3
Proof of Lemma 5.3. Suppose Pâˆ— and V run the CheckMult
protocol with inputs as described in the lemma.
If the proposed multiplication triples ([ğ‘¥ğ‘–], [ğ‘¦ğ‘–], [ğ‘§ğ‘–])â„“
ğ‘–=1 are valid,
i.e. ğ‘¥ğ‘– Â· ğ‘¦ğ‘– = ğ‘§ğ‘– for ğ‘– = 1, . . . , â„“, and all commitments are opened
to the correct values, then the values ğ‘¤ğ‘˜ â‰  0 for the invalid input
triples due to the correctness of Beaver multiplication [5]. So the
verifier outputs (failure).
Therefore, Pâˆ— has two possible options: 1. It can try to cheat
during the CheckZero in Step 9 to reveal some different values
ğ‘‘â€², ğ‘’â€² â‰  ğ‘‘, ğ‘’ or ğ‘¤ğ‘˜ â‰  0 in Step 8. This succeeds with probability
at most ğœ€cz (see Lemma 5.2). 2. It can choose to generate invalid
multiplication triples. This can only be successful, if no invalid
triples are detected in Step 7, and then invalid triples are paired up
with invalid inputs in the right way. Weng et al. [31] have formalized
this as a â€œballs and bins gameâ€. According to Lemma 2 of [31], an
adversary wins this game with probability at most ğœ€cm =(cid:0)ğ‘›ğµ+ğ¶
By the union bound, Pâˆ— can make V output (success) with
â–¡
(cid:1)âˆ’1.
ğµ
probability at most ğœ€cz + ğœ€cm.
E.4 Proof of Theorem 5.4
Z2ğ‘˜
ComZK-b
Z2ğ‘˜
ComZK-a
Proof of Theorem 5.4. Since most of Î 
tical to Î 
parts, and focus on the differences here.
is actually iden-
we will refer to the Proof of Theorem 5.1 for these
The subroutines CheckZero and CheckZeroâ€² are only very slightly
modified from the CheckZero from Î 
. The latter is exactly
the same as in before, but for the larger message space Z2ğ‘˜+ğ‘  , and
Z2ğ‘˜
ComZK-a
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea209the former additionally hides some more bits. Hence, the same
Lemma 5.2 can be applied here.
The remaining part of the proofs considers the different imple-
mentation of CheckMult:
ComZK
Malicious Prover. The setup of the simulation is the same as in
the Proof of Theorem 5.1, i.e. S sends (corrupted, P) to the ideal
functionality F Z2ğ‘˜
and simulates copies of prover and verifier.
For the method CheckMult, S can exactly simulate the protocol
since it knows all the commitments, and ğœ‚ is sampled uniformly at
random from Z2ğ‘  .
If the simulated verifier aborts, it sends (abort) to F Z2ğ‘˜
. Thus,
if the verifier aborts in the real execution, then it does the same
in the simulation. On the other hand, if the verifier aborts in the
simulation, then by Lemma 5.5 it also aborts in the real protocol,
except with probability ğœ€cz + ğœ€â€²
cm.
ComZK
and simulates copies of prover and verifier.
Malicious Verifier. Again, we have the same setup as before,
i.e. the simulator sends (corrupted,V) to the ideal functionality
F Z2ğ‘˜
ComZK
For CheckMult, we use the same strategy as in the Proof of
Theorem 5.1: S sends the corresponding message on behalf of
the corrupted verifier to F Z2ğ‘˜
. If it aborts, then S instructs the
simulated P to also abort by sending (abort) to the simulated V.
Otherwise S simulates the complete protocol using the constant
value 0 for all of the proverâ€™s commitments so that the verifierâ€™s
view is the same as in the real execution.
Summarizing, we have shown that no environment can distin-
guish the simulation from a real execution of the protocol with
more than the stated advantage.
â–¡
ComZK
E.5 Proof of Lemma 5.5