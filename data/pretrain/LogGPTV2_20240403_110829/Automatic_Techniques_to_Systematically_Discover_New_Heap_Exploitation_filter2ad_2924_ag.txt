//c-ares.haxx.se/adv_20160929.html, 2016.
[32] H. Han and S. K. Cha. IMF: Inferred model-based fuzzer. In Proceed-
ings of the 24th ACM Conference on Computer and Communications
Security (CCS), Dallas, TX, Oct.–Nov. 2017.
[33] S. Heelan, T. Melham, and D. Kroening. Automatic heap layout
manipulation for exploitation. In Proceedings of the 27th USENIX
Security Symposium (Security), Baltimore, MD, Aug. 2018.
[34] S. Heelan, T. Melham, and D. Kroening. Gollum: Modular and greybox
exploit generation for heap overflows in interpreters. In Proceedings of
the 26th ACM Conference on Computer and Communications Security
(CCS), London, UK, Nov. 2019.
[35] C. Holler, K. Herzig, and A. Zeller. Fuzzing with code fragments.
In Proceedings of the 21st USENIX Security Symposium (Security),
Bellevue, WA, Aug. 2012.
[36] huku. Yet another free() exploitation technique. http://phrack.
org/issues/66/6.html, 2009.
[37] K. Istvan. ptmalloc fanzine. http://tukan.farm/2016/07/26/
ptmalloc-fanzine/, 2016.
[38] jp. Advanced Doug lea’s malloc exploits. http://phrack.org/
issues/61/6.html, 2003.
[39] S. Y. Kim, S. Lee, I. Yun, W. Xu, B. Lee, Y. Yun, and T. Kim. CAB-
Fuzz: Practical Concolic Testing Techniques for COTS Operating
Systems. In Proceedings of the 2017 USENIX Annual Technical Con-
ference (ATC), Santa Clara, CA, July 2017.
[40] G. Klees, A. Ruef, B. Cooper, S. Wei, and M. Hicks. Evaluating fuzz
testing. In Proceedings of the 25th ACM Conference on Computer and
Communications Security (CCS), Toronto, ON, Canada, Oct. 2018.
[41] D. Lea and W. Gloger. A memory allocator, 1996.
[42] B. Lee, C. Song, Y. Jang, T. Wang, T. Kim, L. Lu, and W. Lee. Prevent-
ing use-after-free with dangling pointers nullification. In Proceedings
of the 2015 Annual Network and Distributed System Security Sympo-
sium (NDSS), San Diego, CA, Feb. 2015.
[43] D. Leijen.
mimalloc.
mimalloc, 2019.
https://github.com/microsoft/
[44] Y. Li, B. Chen, M. Chandramohan, S.-W. Lin, Y. Liu, and A. Tiu.
Steelix: program-state based binary fuzzing. In Proceedings of the
11th Joint Meeting of the European Software Engineering Conference
(ESEC) and the ACM SIGSOFT Symposium on the Foundations of
USENIX Association
29th USENIX Security Symposium    1125
Computer and Communications Security (CCS), Dallas, TX, Oct.–Nov.
2017.
[65] S. Silvestro, H. Liu, T. Liu, Z. Lin, and T. Liu. Guarder: A tunable se-
cure allocator. In Proceedings of the 27th USENIX Security Symposium
(Security), Baltimore, MD, Aug. 2018.
[66] st4g3r. House of einherjar - yet another heap exploitation technique on
GLIBC. https://github.com/st4g3r/House-of-Einherjar-
CB2016, 2016.
[67] Trail of Bits.
How we faired in the Cyber Grand Chal-
lenge. https://blog.trailofbits.com/2015/07/15/how-we-
fared-in-the-cyber-grand-challenge/, 2015.
[68] J. Wang, B. Chen, L. Wei, and Y. Liu. Skyfire: Data-driven seed
generation for fuzzing. In Proceedings of the 38th IEEE Symposium
on Security and Privacy (Oakland), San Jose, CA, May 2017.
[69] S. Wang and D. Wu. In-memory fuzzing for binary code similarity
analysis. In Proceedings of the 32nd IEEE/ACM International Confer-
ence on Automated Software Engineering (ASE), Urbana-Champaign,
IL, Oct.–Nov. 2017.
[70] Y. Wang, C. Zhang, X. Xiang, Z. Zhao, W. Li, X. Gong, B. Liu, K. Chen,
and W. Zou. Revery: From proof-of-concept to exploitable. In Proceed-
ings of the 25th ACM Conference on Computer and Communications
Security (CCS), Toronto, ON, Canada, Oct. 2018.
[71] D. Weston and M. Miller. Windows 10 mitigation improvements. In
Black Hat USA Briefings (Black Hat USA), Las Vegas, NV, Aug. 2016.
[72] T. Xie, Y. Zhang, J. Li, H. Liu, and D. Gu. New exploit methods against
ptmalloc of glibc. In Trustcom/BigDataSE/ISPA, 2016 IEEE, pages
646–653. IEEE, 2016.
[73] X. Yang, Y. Chen, E. Eide, and J. Regehr. Finding and understanding
In Proceedings of the 2011 ACM SIGPLAN
bugs in c compilers.
Conference on Programming Language Design and Implementation
(PLDI), San Jose, CA, June 2011.
[74] W. You, P. Zong, K. Chen, X. Wang, X. Liao, P. Bian, and B. Liang.
SemFuzz: Semantics-based automatic generation of proof-of-concept
exploits. In Proceedings of the 24th ACM Conference on Computer
and Communications Security (CCS), Dallas, TX, Oct.–Nov. 2017.
[75] M. Zalewski. american fuzzy lop. http://lcamtuf.coredump.cx/
afl/, 2014.
[76] A. Zeller. Yesterday, my program worked. today, it does not. why?
In Proceedings of the 7th European Software Engineering Confer-
ence (ESEC) / 7th ACM SIGSOFT Symposium on the Foundations of
Software Engineering (FSE), Toulouse, France, Sept. 1999.
[77] H. Zhao, Y. Zhang, K. Yang, and T. Kim. Breaking turtles all the
way down: An exploitation chain to break out of vmware esxi. In
Proceedings of the 13th USENIX Workshop on Offensive Technologies
(WOOT), Santa Clara, CA, USA, Aug. 2019.
Software Engineering (FSE), Paderborn, Germany, Aug. 2018.
[45] LLVM Project. Scudo hardened allocator. https://llvm.org/docs/
ScudoHardenedAllocator.html, 2019.
[46] K. Lu, M.-T. Walter, D. Pfaff, S. Nürnberger, W. Lee, and M. Backes.
Unleashing use-before-initialization vulnerabilities in the linux kernel
In Proceedings of the 2017 Annual
using targeted stack spraying.
Network and Distributed System Security Symposium (NDSS), San
Diego, CA, Feb.–Mar. 2017.
[47] Meh. Exim off-by-one RCE: Exploiting CVE-2018-6789 with fully mit-
igations bypassing. https://devco.re/blog/2018/03/06/exim-
off-by-one-RCE-exploiting-CVE-2018-6789-en/, 2019.
[48] M. Miller. A snapshot of vulnerability root cause trends for Micrsoft
Remote Code Execution (RCE) CVEs, 2006 through 2017. https://
twitter.com/epakskape/status/984481101937651713, 2018.
[49] G. Novark and E. D. Berger. Dieharder: securing the heap. In Proceed-
ings of the 17th ACM Conference on Computer and Communications
Security (CCS), Chicago, IL, Oct. 2010.
[50] Offensive Security. Exploit database - exploits for penetration testers,
researchers, and ethical hackers. https://www.exploit-db.com/,
2009.
[51] K. Pei, Y. Cao, J. Yang, and S. Jana. Deepxplore: Automated whitebox
testing of deep learning systems. In Proceedings of the 26th ACM
Symposium on Operating Systems Principles (SOSP), Shanghai, China,
Oct. 2017.
[52] H. Peng, Y. Shoshitaishvili, and M. Payer. T-fuzz: fuzzing by pro-
gram transformation. In Proceedings of the 39th IEEE Symposium on
Security and Privacy (Oakland), San Francisco, CA, May 2018.
[53] T. Petsios, A. Tang, S. Stolfo, A. D. Keromytis, and S. Jana. Nezha:
Efficient domain-independent differential testing. In Proceedings of
the 38th IEEE Symposium on Security and Privacy (Oakland), San
Jose, CA, May 2017.
[54] T. Petsios, J. Zhao, A. D. Keromytis, and S. Jana. Slowfuzz: Automated
domain-independent detection of algorithmic complexity vulnerabil-
ities. In Proceedings of the 24th ACM Conference on Computer and
Communications Security (CCS), Dallas, TX, Oct.–Nov. 2017.
[55] P. Phantasmagoria. Exploiting the wilderness. http://seclists.
org/vuln-dev/2004/Feb/25, 2004.
[56] B. Powers, D. Tench, E. D. Berger, and A. McGregor. Mesh: Com-
pacting memory management for C/C++ applications. In Proceedings
of the 2019 ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), Phoenix, AZ, June 2019.
[57] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida, and H. Bos.
Vuzzer: Application-aware evolutionary fuzzing. In Proceedings of
the 2017 Annual Network and Distributed System Security Symposium
(NDSS), San Diego, CA, Feb.–Mar. 2017.
[58] D. Repel, J. Kinder, and L. Cavallaro. Modular synthesis of heap ex-
ploits. In Proceedings of the ACM SIGSAC Workshop on Programming
Languages and Analysis for Security, Dallas, TX, Oct. 2017.
[59] Rich Felker. musl libc. https://www.musl-libc.org/, 2011.
[60] E. J. Schwartz, T. Avgerinos, and D. Brumley. Q: Exploit hardening
made easy. In Proceedings of the 20th USENIX Security Symposium
(Security), San Francisco, CA, Aug. 2011.
[61] shellphish. how2heap: A repository for learning various heap exploita-
https://github.com/shellphish/how2heap,
tion techniques.
2016.
[62] Shellphish. DARPA CGC – shellphish. http://shellphish.net/
cgc/, 2016.
[63] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vi-
gna. SoK: (State of) The Art of War: Offensive Techniques in Binary
Analysis. In IEEE Symposium on Security and Privacy, 2016.
[64] S. Silvestro, H. Liu, C. Crosser, Z. Lin, and T. Liu. Freeguard: A faster
secure heap allocator. In Proceedings of the 24th ACM Conference on
1126    29th USENIX Security Symposium
USENIX Association
A Appendix
Challenge
CROMU_00003
CROMU_00004
KPRCA_00002
KPRCA_00007
NRFIN_00007
NRFIN_00014
NRFIN_00024
NRFIN_00027
NRFIN_00032
OC
✓
✓
✓
✓
✓
✓
✓
✓
Impacts of exploitation
OC
✓
✓
✓
✓
✓
✓
✓
RW
✓
✓
✓
✓
✓
✓
✓
✓
AW
✓
✓
✓
✓
✓
✓
✓
Table 13: Exploitation techniques found by ARCHEAP in custom
allocators of CGC. Except for NRFIN_00007 that implements the
page heap, ARCHEAP successfully found exploitation techniques in
the custom allocators.
A.1 Security of Custom Allocators
To further evaluate the generality of ARCHEAP, we applied ARCHEAP to
all custom heap allocators implemented for the DARPA CGC competition—
since many challenges share the implementation, we selected nine unique
ones for our evaluation (see, Table 13). We implemented a missing API,
(i.e., malloc_usable_size()) to get the size of allocated objects and ran the
experiment for 24 hours for each heap allocator. Similar to the previous one,
no specific model is provided.
ARCHEAP found exploitation primitives for all of the tested allocators,
except for NRFIN_00007, which implements page heap.Such allocator looks
secure in terms of metadata corruption, but it is impractical due to its memory
overheads causing internal fragmentation. During this evaluation, we found
two interesting results. First, ARCHEAP found exploitation techniques for
NRFIN_00032, which has a heap cookie to overflows. Although this cookie-
based protection is not bypassable via heap metadata corruption, ARCHEAP
found that the implementation is vulnerable to an integer overflow and
could craft two overlapping chunks without corrupting the heap cookie.
Second, ARCHEAP found the incorrect implementation of the allocator in
CROMU_00004, which returns a chunk that is free or its size is larger than the
request. ARCHEAP successfully crafted a PoC code resulting in overlapping
chunks by allocating a smaller chunk than the previous allocation. This
experiment indicates that our common heap designs are indeed universal
even for in modern and custom heap allocators (§2.1).
A.2 Search Heuristics in HeapHopper
We also evaluated all search heuristics [63] supported by HeapHopper, which
can be applied without exploit-specific information; for example, we ex-
clude the strategy called ManualMergepoint, which requires an address in a
binary to merge states. As a result, we collected five search heuristics: DFS,
which is the default mode of HeapHopper; Concretizer, which aggressively
concretizes symbolic values to reduce the number of paths; Unique, which
selects states according to their uniqueness for better coverage; Stochas-
tic, which randomly selects the next states to explore; and Veritesting [5],
which merges states to suppress path explosion combining static and dynamic
symbolic execution.
Unfortunately, as shown in Table 14, none of them was helpful in our
evaluation; the default mode (DFS) shows the best performance. First, these
heuristics only help to mitigate, but cannot solve the fundamental problems
of HeapHopper: path explosion and exponential growing combinations of
transactions. More seriously, they cannot exploit a concrete model from
HeapHopper to alleviate the aforementioned issues unlike DFS. This explains
DFS’s best performance and Stochastic’s worst performance. Veritesting
failed due to its incorrect handling of undefined behaviors (e.g., NULL
dereference) in merged states, which are common in our task assuming
memory corruptions.
New Techniques
Old Techniques (Bug+Impact+Chunks)
UBS
∞
∞
∞
∞
∞
HUE
∞
∞
∞
∞
∞
UDF
∞
∞
∞
∞
∞
DFS (Default)
Concretizer
Stochastic
Unique
Veritesting
Table 14: Results of §8.1 with various search heuristics supported
by HeapHopper
PN
HS
∞
31.4s
1.96 m ∞
∞
∞
2.02 m ∞
∞
∞
HL
∞
∞
∞
∞
∞
OC
∞
∞
∞
∞
∞
OCS
∞
∞
∞
∞
∞
FD
3.8m
2.90 h
∞
2.91 h
∞
UU
∞
∞
∞
∞
∞
UB
21.8s
5.25 m
∞
51.91 s
∞
HE
∞
∞
∞
∞
∞
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
fsz: fast bin size
sz: non-fast-bin size
lsz: size larger than page (> 4096)
xlsz: very large size that cannot be allocated
// [PRE-CONDITION]
//
//
//
//
// [BUG] buffer overflow
// [POST-CONDITION]
//
malloc(sz) == dst