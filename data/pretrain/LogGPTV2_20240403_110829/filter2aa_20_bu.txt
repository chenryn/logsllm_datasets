  session_start();
  header('Content-Type: text/html; charset=Shift_JIS');
?>
姓名 ：">
邮箱地址 ： ">
当不带表单查询字符串（Query String）的时候，页面显示如下图 6-7 所示。
图 6-7 63-001.php 的页面显示
下面，我们再通过下面的 URL 来运行刚才的例子。
http://example.jp/63/63-001.php?name=1%82&mail=onmouseover%3dalert(document.cookie)//
如图 6-8 所示，可以看到页面里本来有两个的输入框现在变成只有一个了。
图 6-8 63-001.php 页面显示被修改
如果我们再把鼠标移动到输入框上面去，则 JavaScript 代码会被执行，弹出如图 6-9 那样的对话框。
图 6-9 植入的 JavaScript 代码被执行
这时候我们再来看看页面的源代码（关键部分），如下所示。
邮箱地址  :
这里只显示了表单里和 input 属性值相关的内容，其中由程序生成的内容以网格线显示。
图 6-10 应用程序生产的属性值
其中 0x82 是 Shift_JIS 编码里两字节字符中的第一个字节，很多浏览器（包括 Internet Explorer 和 Firefox 等），都将 0x82 和后面的 " 作为一个字符看待。所以本来表示属性值结束位置的双引号 " 被作为 Shift_JIS 编码字符的第二字节使用，直到 input 元素的“value=
 ”为止（上述 HTML 代码中的阴影部分），都被作为前一元素的 value 属性来处理了。
图 6-11 0x82 和 " 被合起来当作一个字符来处理
由于前一属性的值的闭合双引号一直延续到了下一个属性的“value=”，所以通过参数 mail= 指定的“onmouseover=alert(document.cookie)//
 ”被“挤到”了属性值的外面，从而被识别成了 HTML 元素的鼠标事件绑定了。
我们会在后面说明如何从根本上解决这个问题的。这里我们先看一下如何通过指定 htmlspecialchars
 函数的第三个参数来设置正确的字符编码方式，以消除 XSS 隐患。
代码清单 63/63-002.php（部分代码）
姓名 ：">
邮箱地址 ： ">
修改后的代码执行结果可以参考下面的图 6-12。 在这个图中，我们可以看到 onmouseover 事件作为纯文本显示在了文本框中，而没有被解释为 JavaScript 脚本来执行。
图 6-12 消除 XSS 隐患后
EUC-JP
EUC-JP 是为了在 Unix 上处理日语而设计的字符编码方式。对于 US-ASCII 字符集的字符，EUC-JP 直接使用其编码，对于 JIS X 0208 字符集规定的日语字符，则使用两个字节的 0xA1～0xFE 范围。
图 6-13 是 EUC-JP 的各个字节的分布示意图
图 6-13 EUC-JP 的各字节分布
从上图可以看出，由于 2 字节长字符的后置字节不会和 1 字节字符发生重合，所以不存在 Shift_JIS 中的“5C”问题。但是，EUC-JP 里 2 字节长字符的前置字节和后置字节范围是一样的，所以如果将日语字符串移位一个字节的话，就会发生字符串匹配问题。图 6-14 是在字符串“ラリルレロ”中匹配“蛍”的例子。
图 6-14 字符串“ラリルレロ”中匹配“蛍”成功
下面的代码（需要将文件保存为 EUC-JP 编码方式）展示了如何再现这个问题。脚本的运行结果会打印出来显示 3（strpos
 的返回结果是从源字符串的位置 0 开始计算的）。
<?php
$p = strpos(' ラリルレロ ', ' 萤 ');
var_dump($p);
要想解决这个问题也很简单，和 Shift_JIS 一样，使用多字节版本的 mb_strpos
 就可以了。同样，内部字符编码方式需要设置为 EUC-JP。
非法的 EUC-JP 编码数据
什么算得上是非法的 EUC-JP 编码数据？其条件和前面讲到的“非法的 Shift_JIS 编码数据”中提到的内容是一样的。而且，和 Shift_JIS 一样，非法 EUC-JP 编码数据也会造成系统漏洞。
ISO-2022-JP
8
 中文编码也有类似的问题，可以参考后面 GB2312 部分的相关内容。——译者注
9
 mb.internal_encoding
ISO-2022-JP 采用的是 7 比特的字符编码方式，采用转义序列 10
 的方式来在 US-ASCII 和 JIS X 0208 之间进行交替编码的方法。有时候 ISO-2022-JP 也被称为“JIS 编码”。图 6-15 是转义序列的一个例子，其表示的是用 ISO-2022-JP 编码方式的日语字符串“ABC と汉字！”在内存的存储情况。
10
 Escape Sequence。通过一定的组合来表示不能直接显示的字符的方法。狭义上来指以转义字符“0x1B”即 ESC 开始的字符串。——译者注
图 6-15 ISO-2022-JP 字符串编码示例
在上面的图里，以“ESC $ B”开头的为 JIS X 0208 编码的数据，以“ESC ( B”开头的数据则为 US-ASCII 编码的数据。由于 ISO-2022-JP 交替使用了两种不同的编码方式，所以并不适合在计算机内部进行处理和查询等操作。这种编码方式主要用于在通信网络中进行数据传输，比较典型的使用场景就是电子邮件的传输。
也许大家听说过“在网络上不要使用半角片假名”这种说法，其由来也和 ISO-2022-JP 编码有关，因为 ISO-2022-JP 编码中并不支持半角片假名（JIS X 0201）。
以上我们已经针对 Shift_JIS、EUC-JP、ISO-2022-JP 等基于 JIS 系列字符集的编码方式进行了相应的说明，下面开始我们再来看看 Unicode 编码的两种主要编码方式：UTF-16 和 UTF-8。
UTF-16
Unicode 在最初设计的时候曾想使用 16 比特的长度来容纳世界上所有的字符，所以当时直接使用 16 比特码位（Code Point）的编码方式 USC-2，这也是当时使用最普及的 Unicode 编码方式。但是之后 Unicode 长度扩展到了 21 比特，随之出现的是 UTF-16 编码方式。这种编码方式在兼容 UCS-2 的同时，也支持 BMP 之外的字符。
UTF-16 通过使用代理对（Surrogate Pair）技术来实现支持 BMP 之外的字符。它通过在 16 比特的 Unicode 范围内预留两个 1024（2 的 10 次方）字符长度的区域（0xD800～0xDBFF 以及 0xDC00～0xDFFF），这两个区域组合的话则一共可以表示 2 的 20 次方（大约 100 万）个字符。
我们来看一下具体的实例，比如 BMP 以外的日语汉字“𠮷”，这个汉字读作“つちよし”， Unicode 编码为 U+20BB7，转换为代理对之后，其存储结构为 D842-DFB7，如下图所示，图中显示的是“𠮷田”用 UTF-16 进行编码后的样子。
图 6-16 将“𠮷田”进行 UTF-16 编码的结果
UTF-8
UTF-8 是和 US-ASCII 保持兼容的 Unicode 的一种编码方式。UTF-8 按照表 6-3 的规则根据 Unicode 的码位范围不同采用不同的方法进行编码，最终编码后的字节长度为 1 字节到 4 字节的可变长度。
表 6-3 UTF-8 编码比特位模式
图 6-17 显示的是 UTF-8 编码后各字节的分布示意图。
图 6-17 UTF-8 编码后各字节分布
从图 6-17 中我们可以看到，用 UTF-8 方式编码后各前置字节和后置字节不存在重合的部分，给定某一字符串中的任一字节，立刻就可以知道这一字节是字符编码后的首字节还是后置字节。因此 UTF-8 不会像 Shfit_JIS 那样发生“5C”问题，也不存在像 Shift_JIS 和 EUC-JP 那样在字符匹配时从字符中间开始匹配的问题。
使用 UTF-8 编码方式对日语字符进行编码的时候，JIS X0208 规定的汉字基本上都会编码为 3 字节长，JIS X 0213 规定的第 3 基准和第 4 基准汉字会有部分编码为 4 字节。比如前面说道的“𠮷”（U+20BB7），在 UTF-8 里会编码为“F0 A0 AE B7”4 个字节。下图 6-18 显示的是“𠮷”字编码后的结果。
图 6-18 将“𠮷田”进行 UTF-8 编码的结果
从整体上来说，UTF-8 是现在字符编码里使用最方便也是最安全的编码方式，但是它也有需要注意的地方，那就是非最短形式的问题。
UTF-8 的非最短形式（non-shortest form）问题
我们再看一下表 6-3。在 UTF-8 里 U+007F 之前的字符都可以用 1 个字节来表现，但是从形式上说，本来应该用 1 个字节表示的字符，用两个字节也可以表示。接着我们可以看个具体的例子，比如表 6-4 是把斜线“/”（U+002F）编码为 1 字节～4 字节的结果。
表 6-4 “/”的非最短形式
UTF-8 非最短形式引起的漏洞
有时候 UTF-8 的非最短形式编码的数据可能会引起系统的漏洞。系统出现漏洞的流程如下。
安全检查的时候并未将非最短形式 0xC0 0xAF 识别为斜线 0x2F
而后续处理中将输入数据作为文件名等处理，误将 0xC0 0xAF 作为斜线来看待
之所以出现上面这样的结果，是因为将用 UTF-8 的非最短形式编码的 0xC0 0xAF 机械地转换为其他编码方式（Shift_JIS、UTF-16 等）的时候，会被转换为普通的斜线。也就是用非最短形式编码的斜线在安全检查时被遗漏，而在打开文件操作时非最短形式的斜线被当作普通的斜线处理了。如果将上面的描述画成一张图进行说明的 话，可以参考图 6-19。
图 6-19 安全检查中非最短形式编码数据被漏 掉的例子
由于这个问题的存在，所以在 UTF-8 的最新标准（RFC3629）里规定必须将非最短形式的编码数据作为非法数据进行处理。然而实际上根据实际情况不同，还有很多允许非最短形式编码数据存在的系统，需要格外注意。
下面是最近出现的允许非最短形式编码的 UTF-8 处理而导致出现问题的例子。当然实际上出现的问题不只这些，需要我们注意时常更新软件。
Java SE6 Update 10 之前的 JRE（Java 运行时环境）
PHP5.3.1 以前的 htmlspecialchars
 函数
其他非法的 UTF-8 编码
ISO/IEC 10646 是和 Unicode 非常相像的国际标准，在 2006 改版之前它使用比 Unicode 更宽阔的 31 比特空间来容纳各种字符，如果用 UTF-8 进行编码的话，1 个字符最大可能需要 6 个字节的存储空间。但是随着 ISO/IEC 10646 在 2006 年的改版，实质上它已经和 Unicode 是相同的字符集了，UTF-8 编码后的最大长度也变为 4 字节了。
但是 PHP 的字符编码方式检查函数 mb_check_encoding
 非常重视对老标准的兼容性，即使是 UTF-8 编码后长度为 5 个字节的数据都认为是正常的编码数据 11
 。
另外，如果将代理对的预分配范围（0xD800～0xDBFF 和 0xDC00～0xDFFF）内的码位机械变换为 UTF-8 的话，会占用 3 个字节。比如将 U+D800 机械地变成 UTF-8 编码的话会得到“ED A0 80”，但是作为 UTF-8 来讲这个数据是非法的 UTF-8 编码数据。在将代理对表示的字符转换为 UTF-8 的时候，需要先将原数据进行 UTF-32 编码为 32 位的形式，然后在转换为 UTF-8 的形式，最终编码后的长度应该为 4 个字节。
在 PHP5.2 之前版本的 mb_check_encoding
 会把上面说的直接将代理对表示的字符机械地转换为 UTF-8 得到的数据看作是正常的数据，这个问题在 5.3.0 及以后的版本已经被修正了。在 PHP5.2 分支中，官方已经宣布最终支持的版本为 5.2.17 了，所以强烈推荐升级到 5.3 以后的新版本。
GB2312
GB2312 中对所收录的汉字进行了“分区”处理，每区含有 94 个汉字 / 符号，这种表示方式也称为区位码。具体分区情况如下。
01～09 区为符号和数字
16～55 区为一级汉字，按拼音排序
56～87 区为二级汉字，按部首 / 笔画排序
88～94 区为有待进一步标准化的空白区
在 GB2312 编码中，每个汉字及符号使用两个字节来表示。其中第一个字节称为“高位字节”，第二个字节称为“低位字节”。
高位字节的编码范围为 0xA1～0xF7（将 01～87 区的区号加上 0xA0），低位字节则使用了 0xA1～0xFE。由于一级汉字从 16 区起始，因此汉字区的高位字节的范围是 0xB0～0xF7，低位字节的范围是 0xA1～0xFE。
以“安”字为例，它在 GB2312 字符集中的区位码为 1618，分别加上 0xA1 后，就可以得到它在 GB2312 中的编码为 0xB0B2（0xB0 = 0xA1 + 16，0xB2 = 0xA1 + 18）。
对字符匹配的影响
GB2312 编码也存在和 EUC-JP 类似的问题，即它的第一个字节和第二个字节的范围是互相重叠的。我们也可以参考上面的例子，编写如下测试代码。
<?php
mb_internal_encoding("GB2312");
$p1 = strpos(" 安炒 ", ' 渤 ');
// int(1)
var_dump($p1);
$p2 = mb_strpos(" 安炒 ", ' 渤 ');
// bool(false)
var_dump($p2);
汉字“安”的区位码为 1618，“渤”为 1819，而“炒”为 1920，“安炒”连起来为 16181920，如果忽略双字节编码因素，就会导致 1819 被单独拿出来并被匹配为“渤”字。
使用 GB2312 编码格式保存此文件并执行的话，将分别输出 int(1)
 和 bool(false)
 。
在 GB2312 中解决这个问题的方法和 EUC-JP 等类似，可以在设置内部编码为 GB2312 之后，使用 mb_strpos
 等支持多字节字版本的字符串函数。
非法 GB23122 编码数据
这也和 Shift_JIS 类似，请各位读者参考前面章节中的说明。
GBK
GBK 字符有单字节和双字节编码。单字节编码范围为 0x00～0x7F，这是和 ASCII 保持一致的。
在双字节编码中，GBK 的第一字节的取值范围为 0x81～0xFE，第二字节的一部分为 0x40～0x7E，另一部分为 0x80～0xFE。也就是说它的码位空间为 0x8140～0xFE7E 和 0x8180～0xFEFE。
码位范围导致的问题
从上面 GBK 编码中两个字节的取值范围可以看出它存在如下两个问题。
前置字节和后置字节的取值范围部分重复
第二字节可能包含字符 0x5C
第一个问题和前面提到的 GB2312 类似，这里就不详细说明了。而第二个问题则更为严重，PHP 就曾经出现过一个和此相关的非常严重的安全漏洞。
这个漏洞发生在 PHP 中的 addslashes
 函数中。该函数的作用是使用反斜线对字符串中的特殊字符进行转义，这些字符为单引号（'）、双引号（"）、反斜线（\）和 NUL（NULL 字符）。
该漏洞发生的根本原因是 addslashes
 函数并未考虑字符编码的问题，而 \ 的 ASCII 码是 0x5C，正好落在 GBK 扩充集的低字节范围内。假设用户输入了字符 0xD527，由于 0x27 是单引号，而此函数又不关心字符编码方式，因此 0xD527 会被转义为 0xD55C0x27。而 0xD50x5C 又是一个合法的 GBK 汉字（“诚”字），也就是说输入变成了诚 '，从而导致单引号被保留，进而被用于 SQL 注入攻击。
要想避免此问题，最根本的解决办法就是统一使用 UTF-8 编码。
GB18030
GB18030 是多字节字符集，它的字符可以用一个、两个或四个字节表示。GB18030 编码的各字节分配情况如下表所示。
表 6-5 GB18030 编码的各字节分配情况
1 字节字符
0x00～0x7F
2 字节字符