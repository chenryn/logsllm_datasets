cluding three TLS v1.3 cipher suites. It only provides RSA
and ECDHE as key exchange algorithms (“KEM schemes” in
our context) for the handshake protocol of TLS v1.2 or lower
versions. The library does not provide DH and ECDH, which
do not support ephemeral private keys of the server.
• IA2-TLS Inspector is a non-real time inspector agent, which
needs functionalities of capturing and analzying the TLS
traffic. We used tshark to capture the TLS traffic. (Note that
tshark [27] is a command line version of Wireshark.) Using
the BoringSSL [24] library, we developed an analysis tool,
Figure 6: The List of Affected Files and Functions
which generates the PMS value and decrypts the captured
traffic.
• The IA2-TLS protocol is fully compatible with any websites
offering HTTPS service. Therefore, we do not need to imple-
ment TLS Server. We can use any commercial website as a
TLS Server.
The core difference between IA2-TLS Client and the usual TLS
Client is how the random coin 𝑟 (which will be used to calculate a
PMS) is generated. In the usual TLS Client, 𝑟 is generated through
the system random entropy in /dev/urandom. However, in our
IA2-TLS Client, the random coin is generated through a pseudo-
random function, which takes as inputs inspection key ( ˜𝑘), the
client random nonce (𝜇𝑐) and the server random nonce (𝜇𝑠). That
is, 𝑟 ← 𝑃𝑅𝐹( ˜𝑘, 𝜇𝑐||𝜇𝑠).
IA2-TLS Inspector works precisely the same way as the Client
except that it uses the captured traffic (if the inspection is performed
offline) or duplicated traffic (if the inspection is performed online).
In the following subsections, we explain how each of the com-
ponents was implemented in detail.
5.2 Implementation of IA2-TLS Client
Implementing our IA2-TLS Client is done through modifying the
client handshake protocol in the BoringSSL library of Chromium,
which can be found in the folder chromium/third_party/boringssl.
Implemented files for the client handshake protocol are located
in ssl folder. The folder path and a list of the files are depicted in
Figure 6.
As we explained in the preceding sections, we modify the gen-
eration of random coins to create the private random value of the
client (in the case of the DH-KEM) or the PMS itself (in the case
the RSA-KEM). That modification affects the following three files
in BoringSSL as shown in Figure 6.
The handshake_cllient.cc file contains the codes to perform the
SSL/TLS handshake in the client side. The ClientHello and
ClientKeyExchange messages are set up by the codes. Importantly,
when the ClientKeyExchange message is constructed, PMS and
master MS are computed in ssl_key_share.cc through the classes
inherited from SSLKeyshare class when ECDHE is used as a KEM
scheme. As a pseudorandom function (PRF) for generating the
random coins in our IA2-TLS Client, we use the hash algorithm
from the agreed cipher suite. Note that in BoringSSL, only three
hash algorithms, SHA, SHA256 and SHA384, are supported in the
cipher suites.
RSA-Based IA2-TLS. When RSA-KEM is used to share MS, a ran-
dom PMS must be directly generated by the client. In BoringSSL,
the PMS is generated when the ClientKeyExchange massage is
Session 3: Network Security ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan122constructed. In particular, handshake_client.cc contains the codes
to generate random bytes for PMS in the function ssl_hs_wait_t
do_send_client_key _exchange. For example, a PMS for the RSA-
KEM is generated by calling RAND_bytes function from OpenSSL.
We replaced this function with a PRF which takes the inspection
key ( ˜𝑘), the client random (𝜇𝑐) and the server random (𝜇𝑠) as input:
𝑃𝑀𝑆 := 𝑃𝑅𝐹( ˜𝑘, 𝜇𝑐||𝜇𝑠)
We used tls1_prf, which is already implemented in tls_enc.cc
as a PRF function. Also, we were able to get the values of the
hash function, client random and server random from the hand-
shake object hs. More precisely, they can be obtained from hs->ssl-
>s3->client_random and hs->ssl->s3->server_random, respectively,
where ssl is a ssl object belonging to the handshake object hs (i.e.
SSL *const ssl = hs->ssl).
ECDHE-Based IA2-TLS. In Boring SSL library, generating the PMS
of the ECHDE-KEM is implemented in handshake_client.cc. In par-
ticular, we can use the key_shares object to generate a PMS value
as described below:
• The key_shares object is defined as a SSLKeyShare class ob-
ject in a function ssl_hs_wait_t_do_read_server_key_exchange,
specified in handshake_client.cc as follows:
hs->key_shares[0] = SSLKeyShare::Create(group_id) (Note
that the SSLKeyShare class is defined in ssl_key _share.cc
and group_id is an identity that specifies the type of elliptic
curve for the ECDHE protocol.)
• We can call the object to generate a PMS value by using ssl_hs
_wait_t_do_send_client_key_exchange in handshake_client.cc
as follows:
hs->key_shares[0]->Accept(&child, &pms, &alert, hs->peer
_key)
Below, we explain the variables that Accept take as input in
detail:
(1) “child" is a variable that represents the client’s CT-value
(Recall that CT is a KEM ciphertext. For example, 𝑔𝑎 is the
client’s CT-value, where 𝑔 is the generator of the agreed
elliptic curve group in the ServerKeyExchange message and
𝑎 is the client’s private random value.)
(2) “hs->peer_key" is a variable that represents the server’s pub-
lic key (For example, 𝑔𝑏 is the server’s public key where 𝑏 is
the server’s private key.)
(3) “pms" is a variable that represents the PMS value (For exam-
(4) “alert" is a variable to store an error code if the algorithm
ple, 𝑔𝑎𝑏 is PMS.)
encounters an error.
The existing Accept function of BoringSSL does not take client
random and server random as input. However, it is essential for IA2-
TLS PRF to take those values as they are needed to compute PMS.
We addressed this issue by making the Accept function take the
parameter hs->ssl which contains all the necessary values including
client random and server random. We implemented this new Accept
function in SSLKeyShare class.
When the Accept function is called, it will also call two functions:
• Offer (out_public_key)
• Finish (out_secret, out_alert, peer_key)
The function Offer is a core function that generates a random
private value for the client, which is the exponent of client’s CT-
value. IA2-TLS revises this random private value to the pseudo-
random value associated with the inspection key. To achieve this,
we modified the Offer function to take hs->ssl as input. In the same
way we did in RSA, we use tls1_prf as a PRF function. (It should
be noted that the result of PRF is not PMS, but the client private
random value in ECDHE protocol.)
The private random value generated by the Offer function is
stored in a variable private_key_ by default and is shared with Finish
function which actually computes PMS. Then, MS is generated
based on the pseudorandom PRF. The rest of the process remains
the same.
5.3 Implementation of IA2-TLS Inspector
The aim of IA2-TLS Inspector is to enable an inspector to decrypt
and look into the TLS traffic without receiving any auxiliary in-
formation from the client or the server. In order to achieve this,
the inspector should be able to produce the same PMS (and hence
MS) by applying the inspection key to the captured TLS traffic.
We developed IA2-TLS Inspector to achieve this using the same
BoringSSL library [24].
To use the same function that we use to generate PMS in the
Chromium browser, we created a new file in the tool folder for
the inspector implementation and added the internal header file as
follows.
#include “internal.h"
#include “../crypto/fipsmodule/tls/internal.h"
In particular, ../crypto/fipsmodule/tls/internal.h enables us to
access the prf implementation of BoringSSL, CRYPTO_tls1_prf,
which is almost equivalent to tls1_prf we used in Subsection 5.2.
We captured TLS network traffic using tshark and converted it
to JSON format for the analysis. From the converted JSON file, our
IA2-TLS Inspector program reads the handshake information from
the following data field:
_source→ layers→ ssl→ ssl.record
→ ssl.handshake
In the ssl.handshake field, ssl.handshake.type can particularly be
used to detect the ClientHello (if the value is 1) and ServerHello
(if the value is 2) messages. We then obtained the client and server
random values (𝜇𝐶 and 𝜇𝑆) from ssl.handshake.random. The server’s
public key information can be found where ssl.handshake.type is
0x12, equivalent to 18 in decimal number. The curve type and name
are specified in ssl.handshake .server_curve_type and ssl.handshake.
server_named_curve, respectively. The server’s public key is writ-
ten in ssl.handshake.server_point_len and ssl.handshake.server
_point.
By extracting all the necessary information, i.e., client random,
server random, curve type and name, and server’s public key, from
the captured traffic, the inspector can compute PMS externally. We
were able to verify whether the generated PMS is correct or not
by decrypting the actual traffic or Finished message. In case of
the ECDHE protocol, we verified the client’s private random value
Session 3: Network Security ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan123instead of PMS by observing the client’s CT-value and a generator of
the elliptic curve group, which is included in ClientKeyExchange.
The rationale behind this is that the CT-value must be identical to
𝑔𝑎 where 𝑔 is the generator and 𝑎 is the client’s private random
value.
6 RELATED WORK
The most popular approach to TLS inspection is to have a middle-
box, refereed to as a TLS/SSL proxy, decrypt and re-encrypt the
traffic between the client and the server. The most obvious prob-
lem in this approach is that the proxy needs to force the client to
accept its certificate to establish TLS connection. The implications
of this TLS interception proxy approach have been well reported
[6][10][7][12][18].
The multi-context TLS protocol extends TLS to allow middle-
boxes in such a way that both endpoints explicitly approve each
middlebox [16]. Although it certainly addresses some privacy con-
cerns, it is fundamentally an approach based on the TLS interception
proxy technique and incurs more computations and communica-
tions.
The DPI techniques based on searchable encryption [22] to de-
tect malicious activities over encrypted TLS traffic were proposed
[21][4]. These techniques allow the middlebox to match encrypted
detection rules within encrypted packets without decrypting them,
thereby provide good user privacy. However, their performance
is not adequate for use with common Internet protocols and ap-
plications as they require intensive computational power during
a connection set-up stage or a significant delay is expected when
traffic tokens are matched with the encrypted detection rules.
The approach suggested in [9] enables the middlebox with spe-
cial hardware to obtain the user’s session keys in real time. However,
the problems of this approach are that the middlebox should be
online all the time to provide inspection, and there must be a secure
channel between the client and the middlebox.
The recent technical specification of the European Telecommu-
nications Standards Institute (ETSI) [28] proposes a technique for
inspecting the TLS communication, which, it says, is a real demand
in the cybersecurity area. However, the ETSI proposal is fundamen-
tally different from ours as it monitors the TLS traffic by sharing the
server’s private key with the middlebox. Moreover, this approach
assumes an additional firewall to decrypt, and re-encrypt traffics,
which is computationally expensive.
7 DISCUSSION
7.1 Support for TLS v1.3
One of the critical questions about IA2-TLS is whether it can be
extended to TLS v1.3 [20]. Our answer is positive. The rationale
behind this is that in TLS v1.3, 1) the client random nonce is pro-
duced and 2) the ephemeral DH (DHE) key encapsulation is still
supported. Below, we explain the reason more precisely.
In the TLS v1.3 handshake protocol, the client begins a session
by sending the server the ClientHello message, which includes
• client random nonce 𝜇𝐶;
• a list of cipher suites that the client supports; and
• key_share 𝑔𝑟 that the server might find suitable for key
exchange.
Upon receiving the ClientHello message, the server responds
with the following ServerHello message, which includes
• server random nonce 𝜇𝑆;
• a selected cipher suite; and
• key_share 𝑔𝑠 that the client can use for key exchange.
After the client and the server have exchanged the key_share
value, both parties can come up with the (same) “traffic key”,
which is produced by applying HMAC-based Key Derivation Func-
tion (HKDF) [14] to the “Secret” value 𝑍 = 𝑔𝑟𝑠, which is a DH-KEM