150
1.5.7 内存管理
#include 
#include 
void main() {
void *curr_brk, *tmp_brk, *pre_brk;
printf("当前进程 PID：%d\n", getpid());
tmp_brk = curr_brk = sbrk(0);
printf("初始化后的结束地址：%p\n", curr_brk);
getchar();
brk(curr_brk+4096);
curr_brk = sbrk(0);
printf("brk 之后的结束地址：%p\n", curr_brk);
getchar();
pre_brk = sbrk(4096);
curr_brk = sbrk(0);
printf("sbrk 返回值（即之前的结束地址）：%p\n", pre_brk);
printf("sbrk 之后的结束地址：%p\n", curr_brk);
getchar();
brk(tmp_brk);
curr_brk = sbrk(0);
printf("恢复到初始化时的结束地址：%p\n", curr_brk);
getchar();
}
开启两个终端，一个用于执行程序，另一个用于观察内存地址。首先我们看关闭了
ASLR 的情况。第一步初始化：
# echo 0 > /proc/sys/kernel/randomize_va_space
$ ./a.out
当前进程 PID：27759
初始化后的结束地址：0x56579000
151
1.5.7 内存管理
# cat /proc/27759/maps
...
56557000-56558000 rw-p 00001000 08:01 28587506
/home/a.out
56558000-56579000 rw-p 00000000 00:00 0
[heap]
...
数据段结束地址和堆开始地址同为 0x56558000 ，堆结束地址为 0x56579000 。
第二步使用 brk() 增加堆空间：
$ ./a.out
当前进程 PID：27759
初始化后的结束地址：0x56579000
brk 之后的结束地址：0x5657a000
# cat /proc/27759/maps
...
56557000-56558000 rw-p 00001000 08:01 28587506
/home/a.out
56558000-5657a000 rw-p 00000000 00:00 0
[heap]
...
堆开始地址不变，结束地址增加为 0x5657a000 。
第三步使用 sbrk() 增加堆空间：
152
1.5.7 内存管理
$ ./a.out
当前进程 PID：27759
初始化后的结束地址：0x56579000
brk 之后的结束地址：0x5657a000
sbrk 返回值（即之前的结束地址）：0x5657a000
sbrk 之后的结束地址：0x5657b000
# cat /proc/27759/maps
...
56557000-56558000 rw-p 00001000 08:01 28587506
/home/a.out
56558000-5657b000 rw-p 00000000 00:00 0
[heap]
...
第四步减小堆空间：
$ ./a.out
当前进程 PID：27759
初始化后的结束地址：0x56579000
brk 之后的结束地址：0x5657a000
sbrk 返回值（即之前的结束地址）：0x5657a000
sbrk 之后的结束地址：0x5657b000
恢复到初始化时的结束地址：0x56579000
153
1.5.7 内存管理
# cat /proc/27759/maps
...
56557000-56558000 rw-p 00001000 08:01 28587506
/home/a.out
56558000-56579000 rw-p 00000000 00:00 0
[heap]
...
再来看一下开启了 ASLR 的情况：
# echo 2 > /proc/sys/kernel/randomize_va_space
$ ./a.out
当前进程 PID：28025
初始化后的结束地址：0x578ad000
# cat /proc/28025/maps
...
5663f000-56640000 rw-p 00001000 08:01 28587506
/home/a.out
5788c000-578ad000 rw-p 00000000 00:00 0
[heap]
...
可以看到这时数据段的结束地址 0x56640000 不等于堆的开始地址
0x5788c000 。
mmap() 的声明如下：
#include 
void *mmap(void *addr, size_t len, int prot, int flags,
int fildes, off_t off);
154
1.5.7 内存管理
mmap() 函数用于创建新的虚拟内存区域，并将对象映射到这些区域中，当它不
将地址空间映射到某个文件时，我们称这块空间为匿名（Anonymous）空间，匿名
空间可以用来作为堆空间。 mmap() 函数要求内核创建一个从地址 addr 开始的
新虚拟内存区域，并将文件描述符 fildes 指定的对象的一个连续的片
（chunk）映射到这个新区域。连续的对象片大小为 len 字节，从距文件开始处
偏移量为 off 字节的地方开始。 prot 描述虚拟内存区域的访问权限
位， flags 描述被映射对象类型的位组成。
munmap() 则用于删除虚拟内存区域：
#include 
int munmap(void *addr, size_t len);
例子：源码
#include 
#include 
#include 
void main() {
void *curr_brk;
printf("当前进程 PID：%d\n", getpid());
printf("初始化后\n");
getchar();
char *addr;
addr = mmap(NULL, (size_t)4096, PROT_READ|PROT_WRITE, MAP_PR
IVATE | MAP_ANONYMOUS, 0, 0);
printf("mmap 完成\n");
getchar();
munmap(addr, (size_t)4096);
printf("munmap 完成\n");
getchar();
}
第一步初始化：
155
1.5.7 内存管理
$ ./a.out
当前进程 PID：28652
初始化后
# cat /proc/28652/maps
...
f76b2000-f76b5000 rw-p 00000000 00:00 0
f76ef000-f76f1000 rw-p 00000000 00:00 0
...
第二步 mmap：
]$ ./a.out
当前进程 PID：28652
初始化后
mmap 完成
# cat /proc/28652/maps
...
f76b2000-f76b5000 rw-p 00000000 00:00 0
f76ee000-f76f1000 rw-p 00000000 00:00 0
...
第三步 munmap：
$ ./a.out
当前进程 PID：28652
初始化后
mmap 完成
munmap 完成
156
1.5.7 内存管理
# cat /proc/28652/maps
...
f76b2000-f76b5000 rw-p 00000000 00:00 0
f76ef000-f76f1000 rw-p 00000000 00:00 0
...
可以看到第二行第一列地址从 f76ef000 -> f76ee000 -> f76ef000 变
化。 0xf76ee000-0xf76ef000=0x1000=4096 。
通常情况下，我们不会直接使用 brk() 和 mmap() 来分配堆空间，C 标准库提
供了一个叫做 malloc 的分配器，程序通过调用 malloc() 函数来从堆中分配
块，声明如下：
#include 
void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);
示例：
157
1.5.7 内存管理
#include
#include
void foo(int n) {
int *p;
p = (int *)malloc(n * sizeof(int));
for (int i=0; i: push ebp
0x0000066e : mov ebp,esp
0x00000670 : push ebx
0x00000671 : sub esp,0x14
0x00000674 : call 0x570 
0x00000679 : add ebx,0x1987
0x0000067f : mov eax,DWORD PTR [ebp+0x8]
0x00000682 : shl eax,0x2
0x00000685 : sub esp,0xc
0x00000688 : push eax
0x00000689 : call 0x4e0 
0x0000068e : add esp,0x10
0x00000691 : mov DWORD PTR [ebp-0xc],eax
0x00000694 : mov DWORD PTR [ebp-0x10],0x0
0x0000069b : jmp 0x6d9 
0x0000069d : mov eax,DWORD PTR [ebp-0x10]
0x000006a0 : lea edx,[eax*4+0x0]
0x000006a7 : mov eax,DWORD PTR [ebp-0xc]
0x000006aa : add edx,eax
0x000006ac : mov eax,DWORD PTR [ebp-0x10]
0x000006af : mov DWORD PTR [edx],eax
0x000006b1 : mov eax,DWORD PTR [ebp-0x10]
0x000006b4 : lea edx,[eax*4+0x0]
0x000006bb : mov eax,DWORD PTR [ebp-0xc]
0x000006be : add eax,edx
0x000006c0 : mov eax,DWORD PTR [eax]
0x000006c2 : sub esp,0x8
0x000006c5 : push eax
0x000006c6 : lea eax,[ebx-0x17e0]
0x000006cc : push eax
0x000006cd : call 0x4b0 
0x000006d2 : add esp,0x10
0x000006d5 : add DWORD PTR [ebp-0x10],0x1
0x000006d9 : mov eax,DWORD PTR [ebp-0x10]
0x000006dc : cmp eax,DWORD PTR [ebp+0x8]
0x000006df : jl 0x69d 
0x000006e1 : sub esp,0xc
0x000006e4 : push 0xa
0x000006e6 : call 0x500 
0x000006eb : add esp,0x10
159
1.5.7 内存管理
0x000006ee : sub esp,0xc
0x000006f1 : push DWORD PTR [ebp-0xc]
0x000006f4 : call 0x4c0 
0x000006f9 : add esp,0x10
0x000006fc : nop
0x000006fd : mov ebx,DWORD PTR [ebp-0x4]
0x00000700 : leave
0x00000701 : ret
End of assembler dump.
关于 glibc 中的 malloc 实现是一个很重要的话题，我们会在后面的章节详细介绍。
160
1.5.8 glibc malloc
1.5.8 glibc malloc
glibc
malloc
参考资料
下载文件
glibc
glibc 即 GNU C Library，是为 GNU 操作系统开发的一个 C 标准库。glibc 主要由
两部分组成，一部分是头文件，位于 /usr/include ；另一部分是库的二进制文
件。二进制文件部分主要是 C 语言标准库，有动态和静态两个版本，动态版本位于
/lib/libc.so.6 ，静态版本位于 /usr/lib/libc.a 。
这一章中，我们将阅读分析 glibc 的源码，下面先把它下载下来，并切换到我们需
要的版本：
$ git clone git://sourceware.org/git/glibc.git
$ cd glibc
$ git checkout --track -b local_glibc-2.23 origin/release/2.23/m
aster
下面来编译它，首先修改配置文件 Makeconfig，将 -Werror 注释掉，这样可以
避免高版本 GCC（v8.1.0） 将警告当做错误处理：
$ cat Makeconfig | grep -i werror | grep warn
+gccwarn += #-Werror
接下来需要打上一个 patch：
161