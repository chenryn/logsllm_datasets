的最高级的模糊测试框架。然而，其设计思想的简单性和直观性使其成为了学习框架设计的一
个很好的实例，因此下面将对它进行更加深人的研究。
构成Dfuz的基本组成部分包括数据、函数、列表、选项、协议以及变量。这些不同的组成
http://www.genexx.org/dfuz/
---
## Page 265
250第三部分高级模糊测试技术
部分被用来定义了一组规则集，模糊测试引擎可以对这些规则集进行解析以生成和传输数据。
可以使用下面熟悉而又简单的语法来在规则文件中定义变量：
var ref_other-“1234",Smy_variable,0x00
var my_variab1e = my_data
变量通过简单的前缓var来定义，并且可以通过在变量前面加上一个美元符号（即s，同
Perl和PHP中一样）的前缓来从其他位置进行引用。模糊器的整个创建过程是自包含的。这意
味着与antiparser不同，例如，在此框架上创建一个模糊器完全是使用其自己定制的脚本语言。
Dfuz定义了不同的函数来实现经常需要的一些功能。这些函数非常易于识别，因为它们的
名字前面具有百分号字符（%）的前缀。所定义的函数如下所示：
%attach（）：在按下Enter或者Return键之前一直处于等待状态。当想要将模糊器暂停以完
成其他任务时，该函数就是有用的。例如，如果你的模糊测试目标生成了一个新的线程
以处理引入的连接，并且你希望将一个调试器关联到这个新线程，那么就在初始连接被
建立之后插人一个对%attach（）的调用，然后定位井关联到目标线程。（）
·%length（）或%calc（）：计算所提供参数的大小，并且将其以二进制格式插入二进制流中。
例如，%1ength（“AAAA"）将会把二进制值0x04插人到二进制流中。这些函数的默认输
出大小是32位，但是可以通过调用%length：uint8（）将大小改为8位，也可以通过调
用%1ength：uint16（）将大小改为16位。
·%put：（numher）：将所指定的数字插人到二进制流中.该大小可以被指定为一个
字节，一个字或者是两个字，它们所对应的别名分别是uint8uint16和uint32。
·%random：（）：将针对指定大小，生成并插人一个随机二进制值，同%put（）相类似，
该大小也可以被指定为一个字节，一个字或者是两个字，它们所对应的别名分别是
uint8,uint16和uint32。
·%random：data（，）：生成并插人随机数据。长度指明了将要生成的字节
数量。类型指定了将要生成的随机数据的种类，它可以被指定为一个ASCII码，一个字母
和数字的组合体，一个无格式数以及图形。
·%dec2str（num）：将一个十进制数转换为字符串，并且将其插人到二进制流中。例
如，%dec2str（123）将生成123。
·%fry（）：随机的修改前面所定义的数据.例如，规则“AAAA”，xfry（）将会导致字符串
·%str2bin（）：对不同的十六进制字符串表示进行解析，将其转换为原始值。例如，4141，
4141和41-41都将会转换为AA。
可以采用许多不同的方法来表示数据，定制的脚本语言支持指定字符串、原始字节、地址、
数据重复以及基本数据循环的语法。通过使用逗号分隔符，可以将多个数据定义串接起来以形
成一个简单的列表。下面的例子说明了可以采用不同的方法来定义数据（可以参阅相关的文档，
以获得更加详细的信息）：
---
## Page 266
第21章模糊测试框架
257
var my_variable1 = "a string"
var my_variab1e2 = 0x41,10xdeadbeef1, [Px50], [\x41*200],100
列表的声明格式如下：首先是关键字list，其后面是列表的名字，然后是关键字begin，再
后面是以新行来分隔的数据值的列表，最后是以关键字end作为终结符。可以使用一个列表来
定义井索引一个数据序列。例如下面的代码：
1ist my_1ist:
ufaq
some_data
more_data
end
类似于变量，也可以通过在列表的前面加上一个美元符号（$）前缓来从其他位置引用该
列表。同其他脚本语言如Perl和PHP的语法相类似，一个列表的元素可以通过方括号
$my_1ist[1]来进行索引l。通过使用关键字rand，用如下的形式smy_1ist[rand]就可以实现列
表中的随机索引。
有一些选项可以用来控制整个引擎的行为，这些选项如下所示：
·keep_connecting:继续执行模糊测试，即使是在一个连接不能够建立的情况下。
·big_endian：将数据生成的字节顺序改变为将高位字节先存放在低地址处的顺序（默认是
将低位字节先存放在低地址处的顺序）。
·little_endian：将数据生成的字节顺序改变为将低位字节先存放在低地址处的顺序（默认
情况）
·tcp：指定应当通过TCP来建立socket连接。
·udp：指定应当通过UDP来建立socket连接。
·client_side：指定引擎将作为一个客户端来对服务器进行模糊测试。
·server_side：指定引擎将作为等待连接的一个服务器来对客户端进行模糊测试。
usc_stdout将数据生成到标准的输出（控制台），而不是一个socket连接的输出点。该选
项必须被关联上一个主机值“stdout”。
为了将重新生成经常被模糊测试的协议的工作进行简化，Dfuz可以模拟FTP，POP3，
Telnet以及服务器消息块（SMB）等协议.该功能的实现通过提供以下函数来完成：
ftp:user(）,ftp:pass（）,ftp:mkd（）,pop3:user（),pop3:pass（),pop3:de1e（),te1net:user（）,
telnet：pass（）以及smb：setup（）等等。可以参阅Dfuz的相关文档以得到一个完整的函数列表。
这些基本的组成部分必须要同某些附加指令结合在一起才能创建规则文件。作为一个简
单而又完整的例子，考虑如下的对一个FTP服务器进行模糊测试的规则文件（同该框架绑定
在一起）：
d/tz=od
peer write: eftp:user(“user")
peer read
---
## Page 267
252第三部分高级模糊测试技术
peer write: 0ftp:pass("pass")
peer read
peer write:“Cao /°,%random:data(1024,a1phanum).0x0a
peer write:eftp:quitO
peer read
peer read
repeat-1024
wait=1
# No Options
第一条指令指明了该引擎必须要通过TCP端口21来进行连接。由于没有选项被指定，因此
在默认情况下它是作为一个客户端来进行操作的。peerread和peerwrite指令分别为引擎指
示了应当何时从模糊测试目标中读取数据，以及何时将数据写入模糊测试目标中。在这个特定
的规则文件中，使用了FTP协议功能来对目标FTP服务器进行验证。接下来，改变工作区目录
（ChangeWorkingDirectory.CWD）命令被手工创建并传输给服务器。CWD命令的内容是1024
字节的字母与数字相组合的数据，其后面跟着一个表示终结的新行（0x0a）。最后连接被关闭。
最后的repeat指令指明了peerread和peerwrite代码块应当被执行1024次。对于每一个测试用
例，Dfuz将建立起一个同FTP服务器的经过验证的连接，发出一个以随机的1024字节的字母数
字的混合字符串为参数的CWD命令，然后销毁该连接。
Dfuz是一个简单而又功能强大的模糊测试框架，可以使用它对许多协议和文件格式进行复
制和模糊测试。在某些基本的命令行脚本支持下，stdout（标准输出）的组合就可以将该框架
转化为一个针对文件格式、环境变量以及命令行参数的模糊器。Dfuz具有一个相对较快的学习
曲线，并且以较快的开发速度来节省时间。完全依靠自己的脚本语言来实现模糊器的开发这样
一个事实是一把双刃剑。其有利的方面是，没有经验的程序员可以在该框架上对协议进行描述
并实施模糊测试，而其负面影响是，有经验的程序员不能够利用成熟的编程语言所提供的内在
功能和特性。Dfuz在某种程度上促进了代码的重用，但是不如其他框架如Peach那样全面。目前
该框架所欠缺的一个关键特性是一个智能化启发式攻击集的可用性。总之，对于具有良好设计
的模测试框架来说，Dfuz是一个有趣的研究实例，并且可以作为一个好的工具供日常使用。
21.2.3SPIKEθ
DaveAitel所编写的SPIKE可能是使用最为广泛并且最被人所熟知的模糊测试框架。SPIKE
是采用C语言来编写的，它提供了一个API以用于快速有效地开发网络协议模糊器。SPIKE是一
个开源的工具，并且在具有灵活性的通用公共许可（GPL）的控制下发布。这个备受欢迎的
许可允许创建该框架的另外一个版本SPIKEfile，它是特别被设计用于对文件格式进行模糊测试
的（可以参见第12章“文件格式模糊测试：UNIX平台上的自动化测试”）。SPIKE利用了一种
新技术以对网络协议进行表示，并且对其实施模糊测试。协议数据结构被分割并被表示为块，
其中包含二进制数据和该块的大小。基于块的协议表示就允许抽象地创建不同的协议层，并且
http:/www.immunitysec.com/resources-freesoftware.shtml
 http://www.gnu.org/copyleft/gpl.html
---
## Page 268
第21章模棚测试柜架253
可以自动计算大小。为了更好的理解基于块的概念，考虑下面这个简单的例子，该例子来自于
白皮书《基于块的协议分析在安全测试中的优越性》（TheAdvantagesof Block-BasedProtocol
Analysis for Security Testing)
s_b1ock_size_brinary_bi gendi an_word(“somepacketdata");
s_b1ock_start("sonepacketdata")
s_binary(“01020304°);
这个基本的SPIKE脚本（SPIKE脚本是采用C语言编写的）定义了一个名为somepacketdata
的块，将4个字节值0x01020304放入该块中，并且将块的长度作为前级加到块的前面。在这个
例子中，块的长度将被计算为4，并以将高位字节先存放在低地址处的顺序而被保存为一个字。
注意大多数的SPIKEAPI都具有前缓s_或者spike_。s_binary（）API被用来将二进制数据添加
到一个块中，其参数的格式是非常自由的，以允许该API来处理范围很广的不同的被复制以及
粘贴的输入，例如字符串4141x410x4141004100。尽管这个例子非常简单，但是它却说明
了构建SPIKE的基本的以及全部的方法。由于SPIKE允许将块嵌入到其他块中，因此任意复杂
的协议能够被非常简单地分解为最小的原子组成。下面将前面的例子进行扩展：
s_block_size_binary_bigendian_word(*somepacketdata"):
s_block_start("somepacketdata")
s_b1ocksize_halfword_bigendian("innerdata");
s_binary("00 01");
s_b1nary_b1gend1an_wora_var1an1e(uxuz);
s_string_variab1e(*SELECT");
s_bTock_end("innerdata");
在这个例子中，定义了somepacketdata和innerdata两个块。第二个块包含在第一个块内部，
并且每一个块都以一个大小值作为前级。新定义的innerdata块以一个静态的两字节值0x0001作
为开始，后面跟着一个默认值为0x02的4字节变量整数，最后是一个默认值为SELECT的字符串
变量。s_binary_bigendian_word_vari-ab1e（）和s_string_variable（）API将分别循环遍历
一个预定义的整数和字符串变量集（启发式攻击），其目的我们在前面已经知道是为了发现安
全漏洞。SPIKE开始执行时，将首先循环遍历可能的字变量变异，然后就开始对字符串变量实
施变异。该框架的真正威力在于SPIKE将会自动化的更新每个大小字段的值，就好像实施了不
同的变异操作一样。为了研究并扩展当前的模糊变量列表，可以查看SPIKE/src/spike.c。该框
架的2.9版包含一个大约有700个可诱发错误的启发式攻击列表。
使用上一个例子中所描述的基本概念，你就可以看到在这个框架中，如何对任意复杂的协
议进行建模。这里还有一些额外的API和例子，可以查阅SPIKE的相关文档以获取更多的信息。
让我们仍然来关注运行中的例子，下面的代码片段引自于同SPIKE一起发布的一个FTP模糊器。
因为没有块被实际定义，因此这并不是对SPIKE功能最好的展现，但是它可以有助于进行同类
http:/www.immunitysec.com/downloads/advantages_of_block_based_analysis.pdf
---
## Page 269
254
第三部分高级模糊测试技术
工具之间的比较。
大计自
s_string(°HOST ");
s_string_variab1e(“10.20.30.40");
(_u)ss
nils qnu? m) aiz(in/
an ihanap hd_y renid_ssre_xpal d_.
s_string_variable(*uSER");
"k0t0s010°1v=nia_2
321672_x20fd_
qo,getss
s_string(a v);
s_string("\r\n");
sasnoe")bm9,.zo[d_
）本本个
s_string_variable(²bob"):
s_string（"\r\n²);
1时15010x0个，
s_string("SITE");
书区莫头的中午
s_string_variable("sEDV");
s_string（"\r\n"):