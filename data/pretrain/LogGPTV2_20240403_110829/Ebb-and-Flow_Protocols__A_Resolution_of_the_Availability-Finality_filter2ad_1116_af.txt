able ledger LOGda is guaranteed to be safe and live at
all times, if fewer than 66% of validators are adversarial,
fewer than 50% of awake hash rate is adversarial, and
awake hash rate is bounded away from zero.
Security is proved analogously to Section III-C. Observe
that the 33% bound on adversarial validators under P1 and the
50% bound on adversarial hash rate under P2 are analogous
to the permissioned case analyzed in this paper. The snap-and-
chat construction for permissioned ﬁnality on top of permis-
sionless PoW Nakamoto has further requirements. Under P1,
fewer than 50% of awake hash rate have to be adversarial,
and awake hash rate has to be bounded away from zero, since
otherwise Πlc might not be live and there would be no input
for Πbft to ﬁnalize – then LOGﬁn would not be live. Similarly,
under P2, fewer than 66% of validators have to be adversarial,
since otherwise adversarial validators could ﬁnalize Πlc blocks
that are not on the longest chain, which would later enter the
preﬁx of LOGda – then LOGda would not be safe. It remains
an open question whether these additional requirements are
fundamental or a limitation of the snap-and-chat construction.
13
C. Snap-and-Chat Protocols for Ethereum 2.0
Our construction yields provably secure ebb-and-ﬂow pro-
tocols from off-the-shelf sub-protocols and provides a ﬂexible
resolution of the availability-ﬁnality dilemma. In addition, the
composition enables us to beneﬁt from advances in the design
of sub-protocols and to pass along (rather than having to build
from scratch) additional features of the constituent protocols
which are desired from a decentralized Internet-scale open-
participation consensus infrastructure such as Ethereum.
a) Scalability to Many Nodes: The partially synchronous
BFT sub-protocol Πbft used in the snap-and-chat construction
presents the main scalability bottleneck. HotStuff is the BFT
protocol with the lowest known message complexity O(n).
When used alongside a longest-chain-based protocol, which
are known to scale well to many participants, the overall snap-
and-chat protocol promises good scalability.
b) Accountability: Gasper [21] provides accountability in
the form that a safety violation implies that at least a third of
nodes have provably violated the protocol. As a punitive and
deterrent response, those nodes’ stake is slashed. This attaches
a price tag to safety violations and leads to notions of eco-
nomic security. Snap-and-chat protocols inherit accountability
properties from the BFT sub-protocol Πbft for the ﬁnalized
ledger LOGﬁn. For instance, for many partially synchronous
BFT protocols following the propose-and-vote paradigm, such
as HotStuff, PBFT or Streamlet, a safety violation requires
equivocating votes from more than a third of the nodes. (Recall
that this fact is the cornerstone of these protocols’ safety
argument.) Due to the use of digital signatures, equivocating
votes can be attributed to nodes irrefutably, and equivocating
nodes can be held accountable for the safety violation (cf.
[38], [39]) , e.g., by slashing the nodes’ stake. To what extent
accountability can be provided for the available ledger LOGda
is less clear at this point, both because accountability has not
been widely studied in the context of dynamically available
protocols, as well as due to the non-trivial ledger extraction
that leads to LOGda.
c) High Throughput: High transaction throughput can be
achieved by choosing a high throughput Πlc, such as a longest
chain protocol with separate transaction and backbone blocks
(cf. Prism [40]) or OHIE [41] or ledger combiners [42].
d) Fast Conﬁrmation Latency: Using ledger combiners
[42] or Prism [40] for Πlc, fast latency, in particular, latency
independent of the conﬁrmation error probability, can be
achieved by snap-and-chat protocols. For Πbft, responsive
BFT protocols can be used which ﬁnalize snapshots with a
latency in the order of the actual network delay rather than the
delay bound ∆. Hence, Πbft does not present a bottleneck in
terms of reducing the latency of snap-and-chat protocols and
the ﬁnalized ledger LOGﬁn can catch up with the available
ledger LOGda very quickly, when network conditions allow.
ACKNOWLEDGMENT
We thank Yan X. Zhang, Danny Ryan and Vitalik Buterin
for fruitful discussions. JN is supported by the Reed-Hodgson
Stanford Graduate Fellowship. ENT is supported by the Stan-
ford Center for Blockchain Research.
REFERENCES
[1] J. Neu, E. N. Tas, and D. Tse, “Ebb-and-ﬂow protocols: A resolution
of the availability-ﬁnality dilemma,” Preprint, arXiv:2009.04987, 2020.
[2] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” https:
//bitcoin.org/bitcoin.pdf, 2008.
[3] R. Pass and E. Shi, “The sleepy model of consensus,” in ASIACRYPT
(2), ser. LNCS. Springer, 2017, pp. 380–409.
[4] P. Daian, R. Pass, and E. Shi, “Snow White: Robustly reconﬁgurable
consensus and applications to provably secure proof of stake,” in
Financial Cryptography, ser. LNCS. Springer, 2019, pp. 23–41.
[5] B. David, P. Gazi, A. Kiayias, and A. Russell, “Ouroboros Praos:
An adaptively-secure, semi-synchronous proof-of-stake blockchain,” in
EUROCRYPT (2), ser. LNCS. Springer, 2018, pp. 66–98.
[6] C. Badertscher, P. Gazi, A. Kiayias, A. Russell, and V. Zikas, “Ouroboros
Genesis: Composable proof-of-stake blockchains with dynamic avail-
ability,” in CCS. ACM, 2018, pp. 913–930.
[7] S. Deb, S. Kannan, and D. Tse, “PoSAT: Proof-of-work availability
the work,” in To appear in Financial
and unpredictability, without
Cryptography, arXiv:2010.08154, 2021.
[8] M. Castro and B. Liskov, “Practical Byzantine fault tolerance,” in OSDI.
USENIX Association, 1999, pp. 173–186.
[9] E. Buchman, “Tendermint: Byzantine fault
tolerance in the age of
blockchains,” Master’s thesis, University of Guelph, 2016.
[10] E. Buchman, J. Kwon, and Z. Milosevic, “The latest gossip on BFT
consensus,” Preprint, arXiv:1807.04938, 2018.
[11] M. Yin, D. Malkhi, M. K. Reiter, G. Golan-Gueta, and I. Abraham,
“HotStuff: BFT consensus with linearity and responsiveness,” in PODC.
ACM, 2019, pp. 347–356.
[12] B. Y. Chan and E. Shi, “Streamlet: Textbook streamlined blockchains,”
in AFT. ACM, 2020, pp. 1–11.
[13] Libra Association, “White paper,” https://libra.org/en-US/white-paper/,
2020.
[14] M. Baudet, A. Ching, A. Chursin, G. Danezis, F. Garillot, Z. Li,
D. Malkhi, O. Naor, D. Perelman, and A. Sonnino, “State machine
replication in the Libra blockchain,” Report, Libra Association, 2018.
[15] J. Chen and S. Micali, “Algorand,” Preprint, arXiv:1607.01341, 2016.
[16] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich, “Algorand:
Scaling Byzantine agreements for cryptocurrencies,” in SOSP. ACM,
2017, pp. 51–68.
[17] S. Gilbert and N. A. Lynch, “Brewer’s conjecture and the feasibility
of consistent, available, partition-tolerant web services,” SIGACT News,
vol. 33, no. 2, pp. 51–59, 2002.
[18] A. Lewis-Pye and T. Roughgarden, “Resource pools and the CAP
theorem,” Preprint, arXiv:2006.10698, 2020.
[19] Y. Guo, R. Pass, and E. Shi, “Synchronous, with a chance of partition
tolerance,” in CRYPTO (1), ser. LNCS. Springer, 2019, pp. 499–529.
[20] D. Malkhi, K. Nayak, and L. Ren, “Flexible Byzantine fault tolerance,”
in CCS. ACM, 2019, pp. 1041–1053.
[21] V. Buterin, D. Hernandez, T. Kamphefner, K. Pham, Z. Qiao, D. Ryan,
J. Sin, Y. Wang, and Y. X. Zhang, “Combining GHOST and Casper,”
Preprint, arXiv:2003.03052, 2020.
[22] V. Buterin and V. Grifﬁth, “Casper the friendly ﬁnality gadget,” Preprint,
arXiv:1710.09437, 2017.
[23] V. Buterin. (2020) Explaining the liveness guarantee (comment 8).
[Online]. Available: https://ethresear.ch/t/4228/8
[24] D. Ryan, Ethereum Foundation, Personal communication, June 2020.
[25] C. Cachin and M. Vukoli´c, “Blockchain consensus protocols in the wild,”
Preprint, arXiv:1707.01873, 2017.
[26] A. Stewart and E. Kokoris-Kogia, “GRANDPA: a Byzantine ﬁnality
gadget,” Preprint, arXiv:2007.01560, 2020.
[27] E. Blum, J. Katz, and J. Loss, “Synchronous consensus with optimal
asynchronous fallback guarantees,” in TCC (1), ser. LNCS. Springer,
2019, pp. 131–150.
[28] V. Buterin and A. Stewart. (2018) Beacon chain Casper mini-spec
(comments 17 and 19). [Online]. Available: https://ethresear.ch/t/2760/17
[29] R. Nakamura. (2019) Analysis of bouncing attack on FFG. [Online].
[30] ——.
(2019) Prevention of bouncing attack on FFG.
[Online].
Available: https://ethresear.ch/t/6113
Available: https://ethresear.ch/t/6114
14
[31] J. Neu, E. N. Tas, and D. Tse. (2020) A balancing attack on Gasper,
the current candidate for Eth2’s beacon chain. [Online]. Available:
https://ethresear.ch/t/8079
[32] A. Kiayias, A. Russell, B. David, and R. Oliynykov, “Ouroboros: A
provably secure proof-of-stake blockchain protocol,” in CRYPTO (1),
ser. LNCS. Springer, 2017, pp. 357–388.
[33] C. Dwork, N. A. Lynch, and L. J. Stockmeyer, “Consensus in the
presence of partial synchrony,” J. ACM, vol. 35, no. 2, pp. 288–323,
1988.
[34] G. Golan-Gueta, I. Abraham, S. Grossman, D. Malkhi, B. Pinkas, M. K.
Reiter, D. Seredinschi, O. Tamir, and A. Tomescu, “SBFT: A scalable
and decentralized trust infrastructure,” in DSN.
IEEE, 2019, pp. 568–
580.
[35] A. Skidanov, “Fast ﬁnality and resilience to long range attacks with
proof of space-time and Casper-like ﬁnality gadget,” http://near.ai/post,
2019.
[36] T. Dinsdale-Young, B. Magri, C. Matt, J. B. Nielsen, and D. Tschudi,
“Afgjort: A partially synchronous ﬁnality layer for blockchains,” in SCN,
ser. LNCS. Springer, 2020, pp. 24–44.
[37] R. Nakamura. (2020) Hierarchical ﬁnality gadget. [Online]. Available:
https://ethresear.ch/t/6829
[38] J. Neu, E. N. Tas, and D. Tse, “Snap-and-chat protocols: System
aspects,” Preprint, arXiv:2010.10447, 2020.
[39] P. Sheng, G. Wang, K. Nayak, S. Kannan, and P. Viswanath, “BFT
protocol forensics,” Preprint, arXiv:2010.06785, 2020.
[40] V. K. Bagaria, S. Kannan, D. Tse, G. C. Fanti, and P. Viswanath, “Prism:
Deconstructing the blockchain to approach physical limits,” in CCS.
ACM, 2019, pp. 585–602.
[41] H. Yu, I. Nikolic, R. Hou, and P. Saxena, “OHIE: blockchain scaling
made simple,” in IEEE Symp. Secur. Privacy, 2020, pp. 90–105.
[42] M. Fitzi, P. Gazi, A. Kiayias, and A. Russell, “Ledger combiners for
fast settlement,” Cryptology ePrint Archive, Report 2020/675, 2020.
[43] N. A. Lynch, Distributed Algorithms. San Francisco, CA, USA: Morgan
Kaufmann Publishers Inc., 1996.
[44] A. Dembo, S. Kannan, E. N. Tas, D. Tse, P. Viswanath, X. Wang, and
O. Zeitouni, “Everything is a race and Nakamoto always wins,” in CCS.
ACM, 2020, pp. 859–878.
DETAILS OF THE LIVENESS ATTACK ON GASPER
APPENDIX A
A. Setting of the Attack
This appendix describes an attack on the liveness of the
Gasper protocol [21]. We ﬁrst state the assumptions about
the adversary’s capabilities and control over the network that
sufﬁce for the adversary to launch our attack. Subsequently,
we describe the attack in detail. (The attack is summarized in
Section II.) Then we demonstrate using probabilistic analysis
and Monte Carlo simulation that the adversary is likely in a
position to launch the attack within a short period of time.
1) Goal: We describe an attack on the liveness of the
Gasper protocol [21]. That is, we describe a situation which is
likely to occur and a sequence of adversarial actions such that
the adversary can prevent any Casper ﬁnalizations indeﬁnitely.
Our exposition assumes the reader is familiar with Gasper
[21], Casper [22], and the synchronous network model [43].
2) Assumptions: We assume an adversary has the follow-
ing capabilities: (a) The adversary knows at what point in
time honest validators execute the Gasper fork choice rule
HLMD(G) [21, Algorithm 4.2]. (b) The adversary is able to
target a message (such as a block or a vote) for delivery to an
honest validator just before a certain point in time. (c) Honest
validators cannot update each other arbitrarily quickly about
messages they have just received.
Note that (a) is given by design of Gasper which has
predetermined points in time at which honest validators are
supposed to cast their votes. Conditions (b) and (c) are sat-
isﬁed in standard consensus-theoretic adversary and network
models such as ∆-synchrony [43] or ∆-partial-synchrony [33]
where the adversary controls network delay. The probabilistic
liveness proof of [21] does not apply because it assumes a
weaker adversary (network delays are assumed to be stochastic
rather than adversarial in [21]) which does not have capability
(b).
3) Terminology: Recall
that Gasper proceeds in epochs
which are subdivided into slots. We assume that Gasper is
run with C slots per epoch, n validators in total, of which f
are adversarial. Let β (cid:44) f /n. We assume that C divides n
such that every slot has a committee of integer size n/C. For
each epoch, a random permutation of all n validators ﬁxes the
assignment of validators to committees. The ﬁrst validator in
every committee is the designated proposer for the respective
slot and gets to propose a new block at a location in the block
tree determined by HLMD(G). Then, each validator of the
slot’s committee executes HLMD(G) in its own view G to
determine what block to vote for.
A vote consists of a GHOST vote and a Casper (FFG) vote.
The Casper vote’s source and target blocks are deterministic
functions of the block the GHOST vote is cast for (see [21,
Deﬁnition 4.7]). A block can only become ﬁnalized if a
supermajority of ≥ 2n/3 validators vote for it. The goal of the
attack is to keep honest validators split between two options
(a ‘left’ and a ‘right’ chain, see Figure 4, p. 5) indeﬁnitely,
such that no supermajority of ≥ 2n/3 validators ever votes for
one of the two options and thus no block ever gets ﬁnalized.
B. Attack
In this section we describe our attack in detail, cf. [31]. For
an illustration of the attack, see Figure 4 (p. 5).
1) Recap: Proposing and Voting in Gasper: To understand
how the adversary can keep the honest nodes split indeﬁnitely
between two chains it is necessary to revisit the proposing
and voting algorithms of Gasper. For each of the two roles,
proposing and voting, honest validators use the fork chain rule
HLMD(G) (see [21, Algorithm 4.2]) in their local view G to
determine (a) when proposing, what block to extend, and (b)
when voting, what block to endorse with a vote.
Roughly speaking, HLMD(G) does this. First, HLMD(G)
ﬁnds the justiﬁed pair with highest attestation epoch among all
possible chains, but taking into account only votes that have
already been referenced on said chain (see [21, Algorithm 4.2],
line 3, ‘J(ﬀgview(Bl))’). Votes that the validator might have
received from the network but have not yet been referenced in
a block are not considered. Second, HLMD(G) ﬁlters for only
those chains that contain said highest justiﬁed pair, i.e., are
consistent with the prior justiﬁcation (see [21, Algorithm 4.2],
lines 4 and 5). Third, among the remaining chains, HLMD(G)
picks greedily the ‘heaviest’ chain (GHOST paradigm), i.e.,
the chain which among the most recent votes for each val-
idator has received the most votes (LMD paradigm, see [21,
Algorithm 4.2], lines 7 to 10).
15
In addition, to vote, the source and target of the Casper
vote are determined as follows (see [21, Deﬁnition 4.7]). The
Casper vote’s source LJ is the last justiﬁed pair, considering
only votes that have been included in blocks on the chain
determined by HLMD(G). This ensures that all validators
voting for the tip of a certain chain have a consistent view of
and vote from the last justiﬁed pair. The Casper vote’s target
LE is the last epoch boundary pair (i.e., of the current epoch)
on the chain determined by HLMD(G). Again, all validators
voting for the tip of a certain chain have a consistent view of
and vote for the same last epoch boundary pair.
2) How to Sway Honest Validators: Suppose there are two
competing chains as depicted in Figure 4. The only time a non-
trivial fork choice occurs in HLMD(G) (see [21, Algorithm
4.2], line 9) is when a validator chooses whether to go down
the ‘left’ or the ‘right’ chain. This decision is based on where
the majority of the most recent votes (one per validator) fall,
in the instant when HLMD(G) is executed. Thus, if half of
the most recent votes are ‘left’ and the other half is ‘right’,
then the adversary can release a single withheld vote to an
honest validator who is just about to execute HLMD(G) and
thereby ‘tip the balance’ and sway that honest validator to
vote on a chain of the adversary’s choosing. Note that the
adversary can release that same withheld vote to multiple
honest validators, all of which will then vote for the chain of
the adversary’s choice. Furthermore, note that the adversary
can release two different withheld votes to different sets of
honest validators and thus steer one group towards ‘left’ and
the other group towards ‘right’. Ultimately (due to the as-
sumption of there being a bound ∆ on the maximum network
delay the adversary can inﬂict on a message, and the fact that
honest validators gossip about recently received messages in
an attempt to keep consistent views of the protocol execution)
the withheld votes will become known to all honest validators,
but (a) the adversary can prevent this synchronization until
after the honest validators have cast their votes by releasing
the withheld votes just before the honest validators execute
HLMD(G), and (b) after two withheld votes, one for ‘left’
and one for ‘right’, are released, and if the honest validators
either vote ‘left’ and ‘right’ in equal number (during epoch
0) or simply reafﬁrm their prior votes (during epoch 1 and
beyond), then after sharing all votes with all honest validators
there is still an equal number of votes for ‘left’ and ‘right’,
respectively. Thus, in the next slot the adversary can release
another two withheld votes to continue keeping up the equal
split of honest validators. And so on.
Swaying honest validators by releasing withheld votes se-
lectively is the key technique underlying our attack. Since
the Casper votes are consistent with the GHOST votes by
construction, as long as the GHOST votes are split equally
between the two chains, the Casper votes are split equally be-
tween the two chains. Thus, neither of the two chains will ever
receive a supermajority of ≥ 2n/3 votes as would be necessary
for a justiﬁcation or ﬁnalization. Thus, no epoch boundary pair
will ever get ﬁnalized and thus liveness is lost indeﬁnitely
and with certainty, once the attack has been launched. In the
remainder of this section we describe under what sufﬁcient
condition and with what sequence of adversarial actions the
adversary is able to affect a permanent split among honest
validators and thus a permanent loss of liveness of Gasper.
3) Epoch 0: Kick-Starting the Attack: The adversary waits
for an opportune epoch to kick-start the attack. For ease of
exposition, we assume that epoch 0 is opportune. An epoch is
opportune if there are enough adversarial validators in every
slot of the epoch to ﬁll the following roles:
• The proposer of slot 0 needs to be adversarial. The ad-
versarial proposer equivocates and produces two conﬂicting
blocks (‘left’ and ‘right’, dashed blocks 0 and 0(cid:48) in Figure 4)
which it reveals to two suitably chosen subsets of the
validators in slot 0. Thus, the honest validators’ votes are
split equally between the two chains. (Equivocating on
block production is a slashable offense and thus the stake
corresponding to the adversarial block producer will be
slashed. Besides this equivocation, none of the adversarial
actions are slashable. We note that there are variants of our
attack that do not require any slashable adversarial actions,