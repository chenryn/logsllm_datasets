命中率很难预测，但对现在中等规模的Web缓存来说，40%的命中率是很合理的。
缓存的好处是，即使是中等规模的缓存，其所包含的常见文档也足以显著地提高性
能、减少流量了。缓存会努力确保将有用的内容保存在缓存中。
7.5.3 字节命中率
由于文档并不全是同一尺寸的，所以文档命中率并不能说明一切。有些大型对象被
访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大。因此，
有些人更愿意使用字节命中率（byte hit rate）作为度量值（尤其那些按流量字节付
费的人！）。
字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。通过这种度
量方式，可以得知节省流量的程度。100%的字节命中率说明每个字节都来自缓存，
没有流量流到因特网上去。
文档命中率和字节命中率对缓存性能的评估都是很有用的。文档命中率说明阻止了
多少通往外部网络的Web事务。事务有一个通常都很大的固定时间成分（比如，建
立一条到服务器的TCP连接），提高文档命中率对降低整体延迟（时延）很有好处。
167 字节命中率说明阻止了多少字节传向因特网。提高字节命中率对节省带宽很有利。
7.5.4 区分命中和未命中的情况
不幸的是，HTTP没有为用户提供一种手段来区分响应是缓存命中的，还是访问原
始服务器得到的。在这两种情况下，响应码都是200 OK，说明响应有主体部分。有
些商业代理缓存会在Via首部附加一些额外信息，以描述缓存中发生的情况。
客户端有一种方法可以判断响应是否来自缓存，就是使用Date首部。将响应中
Date首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可
注4： 术语“命中比例”可能比“命中率”要好，因为“命中率”会让人错误地想到时间因素。但是“命中
率”这个词很常用，所以这里我们也使用它。
注5： 有时，人们会在命中率中包括再验证命中，但有时候命中率和再验证命中率是分别测量的。在检测命
中率的时候，要确定自己知道什么才是“命中”。
176 ｜ 第7章
以认为这是一条缓存的响应。客户端也可以通过Age首部来检测缓存的响应，通过
这个首部可以分辨出这条响应的使用期（参见附录C中的Age首部）。
7.6 缓存的拓扑结构
缓存可以是单个用户专用的，也可以是数千名用户共享的。专用缓存被称为私有缓
存（private cache）。私有缓存是个人的缓存，包含了单个用户最常用的页面（参见
图7-7a）。共享的缓存被称为公有缓存（public cache）。公有缓存中包含了某个用户
团体的常用页面（参见图7-7b）。
（a）访问私有缓存
因特网
客户端 Web服务器
私有缓存
（b）访问共享的公有缓存
因特网
客户端
Web服务器
客户端 公有缓存
图7-7 公有和私有缓存
7.6.1 私有缓存
私有缓存不需要很大的动力或存储空间，这样就可以将其做得很小，很便宜。Web浏
览器中有内建的私有缓存——大多数浏览器都会将常用文档缓存在你个人电脑的磁盘
和内存中，并且允许用户去配置缓存的大小和各种设置。还可以去看看浏览器的缓存中
有些什么内容。比如，对微软的Internet Explorer来说，可以从Tools（工具）→Internet 168
Options...（因特网选项）对话框中获取缓存内容。MSIE将缓存的文档称为“临时
文件”，并将其与相关的URL和文档过期时间一起在文件列表中列出。通过特殊的
URL about:cache可以查看网景的Navigator的缓存内容，这个URL会给出一个
显示了缓存内容的“磁盘缓存统计”页面。
7.6.2 公有代理缓存
公有缓存是特殊的共享代理服务器，被称为缓存代理服务器（caching proxy server），
缓 存 ｜ 177
或者更常见地被称为代理缓存（proxy cache）（第6章讨论过代理）。代理缓存会从
本地缓存中提供文档，或者代表用户与服务器进行联系。公有缓存会接受来自多个
用户的访问，所以通过它可以更好地减少冗余流量。6
在图7-8a中，每个客户端都会重复地访问一个（还不在私有缓存中的）新的“热
门”文档。每个私有缓存都要获取同一份文档，这样它就会多次穿过网络。而如图
7-8b所示，使用共享的公有缓存时，对于这个流行的对象，缓存只要取一次就行
了，它会用共享的副本为所有的请求服务，以降低网络流量。
（a）来自私有缓存的重复访问
客户端 因特网
客户端
服务器
客户端
（b）共享缓存可以减少流量
客户端 因特网
客户端
缓存
服务器
客户端
图7-8 共享的公有缓存可以降低网络流量
代理缓存遵循第6章描述的代理规则。可以通过指定手工代理，或者通过代理自动
配置文件，将你的浏览器配置为使用代理缓存（参见6.4.1节）。还可以通过使用拦
截代理在不配置浏览器的情况下，强制HTTP请求经过缓存传输（参见第20章）。
注6： 公有缓存要缓存用户群体中各种不同的兴趣点，所以要足够大才能承载常用的文档集，而不会被单个
用户所感兴趣的文档占满。
178 ｜ 第7章
7.6.3 代理缓存的层次结构
在实际中，实现层次化（hierarchy）的缓存是很有意义的，在这种结构中，在较小
缓存中未命中的请求会被导向较大的父缓存（parent cache），由它来为剩下的那些
“提炼过的”流量提供服务。图7-9显示了一个两级的缓存层次结构。7其基本思想
是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能
更强的缓存来装载多用户共享的文档。8
原始服务器 原始服务器 原始服务器
广域网 广域网 广域网
X X X
第二级缓存 第二级缓存 第二级缓存
地区性网络 地区性网络 地区性网络
第一 第一 第一
X X X X X X
级缓存 级缓存 级缓存
（a）第一级缓存命中 （b）第二级缓存命中 （ c）第二级缓存未命中
图7-9 在两级的缓存层次结构中访问文档
我们希望大部分用户都能在附近的第一级缓存中命中（参见图7-9a）。如果没有命
中，较大的父缓存可能能够处理它们的请求（参见图7-9b）。在缓存层次结构很深 169
的情况下，请求可能要穿过很长一溜缓存，但每个拦截代理都会添加一些性能损耗，
当代理链路变得很长的时候，这种性能损耗会变得非常明显。9
注7： 如果客户端浏览器自带缓存，那么从技术上来讲，图7-9显示的就是一个三级的缓存层次结构。
注8： 父缓存可能要更大一些，以便装载在多用户间流行的文档，它们还要接收来自很多子缓存的聚合流量，
这些子缓存的兴趣点可能很分散，所以还需要更高的性能。
注9： 在实际中，网络结构会尝试着将其深度限制在连续的两到三个代理以内。但是，新一代的高性能代理
服务器会使代理链的长度变得不那么重要。
缓 存 ｜ 179
7.6.4 网状缓存、内容路由以及对等缓存
有些网络结构会构建复杂的网状缓存（cache mesh），而不是简单的缓存层次结构。
网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决
策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。
这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为
内容路由器（content router）。
网状缓存中为内容路由设计的缓存（除了其他任务之外）要完成下列所有功能。
• 根据URL在父缓存或原始服务器之间进行动态选择。
170 • 根据URL动态地选择一个特定的父缓存。
• 前往父缓存之前，在本地缓存中搜索已缓存的副本。
• 允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的
缓存。
缓存之间这些更为复杂的关系允许不同的组织互为对等（peer）实体，将它们的
缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为兄弟缓存（sibling
cache）（参见图7-10）。HTTP并不支持兄弟缓存，所以人们通过一些协议对HTTP
进行了扩展，比如因特网缓存协议（Internet Cache Protocol，ICP）和超文本缓存协
议（HyperText Caching Protocol，HTCP）。我们将在第20章讨论这些协议。
X
Y
原始服务器
B的访问点 A的访问点
广域网
X
兄弟
组织A 组织B
图7-10 兄弟缓存
180 ｜ 第7章
7.7 缓存的处理步骤
现代的商业化代理缓存相当地复杂。这些缓存构建得非常高效，可以支持HTTP和
其他一些技术的各种高级特性。但除了一些微妙的细节之外，Web缓存的基本工作
原理大多很简单。对一条HTTP GET报文的基本缓存处理过程包括7个步骤（参见
图7-11）。
(1) 接收——缓存从网络中读取抵达的请求报文。
(2) 解析——缓存对报文进行解析，提取出URL和各种首部。 171
(3) 查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保
存在本地）。
(4) 新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是
否有任何更新。
(5) 创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。
(6) 发送——缓存通过网络将响应发回给客户端。
(7) 日志——缓存可选地创建一个日志文件条目来描述这个事务。
GET /www.joes-hardware.com/index.html HTTP/1.1
User-agent: Superbrowser 2.0
Host: www.joes-hardware.com
Accept: *.*
（1）接收HTTP请求报文
（2）对报文进行解析 （3）缓存
中有吗？
（5）创建响应首部
客户端 新 服务器 是的服务器 服务器
首部 首部 首部
主体 是的 主体 主体
（4）新鲜吗？
缓存
（6）发送响应
HTTP/1.1 200 OK
Content-length: 2140
Content-type: text/html
Cache-control: max-age=86400
Age: 21562
Via: ...
Joe’s Hardware Home Page
Welcome to Joe's Hardware...
图7-11 处理一个新鲜的缓存命中
7.7.1 第一步——接收
在第一步中，缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会
缓 存 ｜ 181
同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。
7.7.2 第二步——解析
接下来，缓存将请求报文解析为片断，将首部的各个部分放入易于操作的数据结构
172 中。这样，缓存软件就更容易处理首部字段并修改它们了。10
7.7.3 第三步——查找
在第三步中，缓存获取了URL，查找本地副本。本地副本可能存储在内存、本地磁
盘，甚至附近的另一台计算机中。专业级的缓存会使用快速算法来确定本地缓存中
是否有某个对象。如果本地没有这个文档，它可以根据情形和配置，到原始服务器
或父代理中去取，或者返回一条错误信息。
已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中
时返回正确的服务器首部。已缓存对象中还包含了一些元数据（metadata），用来记
录对象在缓存中停留了多长时间，以及它被用过多少次等。11
7.7.4 第四步——新鲜度检测
HTTP通过缓存将服务器文档的副本保留一段时间。在这段时间里，都认为文档是
173 “新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但一旦已缓存副
本停留的时间太长，超过了文档的新鲜度限值（freshness limit），就认为对象“过
时”了，在提供该文档之前，缓存要再次与服务器进行确认，以查看文档是否发生
了变化。客户端发送给缓存的所有请求首部自身都可以强制缓存进行再验证，或者
完全避免验证，这使得事情变得更加复杂了。
HTTP有一组非常复杂的新鲜度检测规则，缓存产品支持的大量配置选项，以及与
非HTTP新鲜度标准进行互通的需要则使问题变得更加严重了。本章其余的大部分
篇幅都用于解释新鲜度的计算问题。
7.7.5 第五步——创建响应
我们希望缓存的响应看起来就像来自原始服务器的一样，缓存将已缓存的服务器响
注10： 解析程序还要负责首部各部分的标准化，将大小写或可替换数据格式之类不太重要的区别都看作等
效的。而且，某些请求报文中包含有完整的绝对URL，而其他一些请求中包含的则是相对URL和
Host首部，所以解析程序通常都要将这些细节隐藏起来（参见2.3.1节）。
注11： 复杂的缓存还会保留引发服务器响应的原始客户端响应首部的一份副本，以用于HTTP/1.1内容协商
（参见第17章）。
182 ｜ 第7章
应首部作为响应首部的起点。然后缓存对这些基础首部进行了修改和扩充。