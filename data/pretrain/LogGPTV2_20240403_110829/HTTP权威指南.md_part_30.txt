### 命中率的预测与缓存性能

命中率难以准确预测，但对于中等规模的Web缓存而言，40%的命中率是合理的。即使是中等规模的缓存，其包含的常见文档也足以显著提升性能并减少流量。缓存会努力确保将有用的内容保存在其中。

#### 7.5.3 字节命中率

由于文档大小不一，文档命中率并不能全面反映缓存效果。有些大型对象访问次数较少，但由于体积大，对总数据流量贡献更大。因此，字节命中率（byte hit rate）作为度量值更为合适，特别是对于按流量付费的情况。

字节命中率表示缓存提供的字节占传输总字节的比例。通过这种度量方式，可以了解节省流量的程度。100%的字节命中率意味着所有字节都来自缓存，没有流量流向互联网。

文档命中率和字节命中率都是评估缓存性能的重要指标。文档命中率反映了阻止了多少外部网络请求，从而降低整体延迟；而字节命中率则表明了节省了多少带宽。

#### 7.5.4 区分命中和未命中的情况

不幸的是，HTTP并未提供一种手段来区分响应是来自缓存还是原始服务器。两种情况下，响应码均为200 OK，表示响应有主体部分。一些商业代理缓存会在Via首部附加额外信息，以描述缓存中的情况。

客户端可以通过比较响应中的Date首部与当前时间来判断响应是否来自缓存。如果响应中的日期较早，通常可认为这是缓存响应。客户端还可以通过Age首部来检测缓存响应，该首部显示了响应的使用期（参见附录C中的Age首部）。

注4：术语“命中比例”可能比“命中率”更恰当，因为后者容易让人误解为涉及时间因素。但“命中率”这个词很常用，所以这里我们也使用它。

注5：有时，人们会在命中率中包括再验证命中，但有时会分别测量。在检测命中率时，要明确什么是“命中”。

### 7.6 缓存的拓扑结构

缓存可以是单个用户专用的私有缓存，也可以是数千名用户共享的公有缓存。私有缓存是个人的缓存，包含单个用户最常用的页面（参见图7-7a）。公有缓存则包含某个用户团体的常用页面（参见图7-7b）。

#### 7.6.1 私有缓存

私有缓存不需要很大的动力或存储空间，可以做得小且便宜。大多数Web浏览器内置私有缓存，允许用户配置缓存大小和设置。例如，在微软的Internet Explorer中，可以通过Tools（工具）→ Internet Options...（因特网选项）对话框查看缓存内容。MSIE将缓存的文档称为“临时文件”，并列出相关URL和过期时间。通过特殊的URL about:cache可以查看Netscape Navigator的缓存内容，该URL会显示一个“磁盘缓存统计”页面。

#### 7.6.2 公有代理缓存

公有缓存是特殊的共享代理服务器，被称为缓存代理服务器（caching proxy server），或更常见的代理缓存（proxy cache）。代理缓存从本地缓存中提供文档，或代表用户与服务器联系。公有缓存接受多个用户的访问，从而更好地减少冗余流量（参见图7-8）。

#### 7.6.3 代理缓存的层次结构

实际中，实现层次化的缓存是有意义的。在这种结构中，较小缓存中未命中的请求会被导向较大的父缓存，由它来处理剩余的流量。图7-9显示了一个两级缓存层次结构。基本思想是在靠近客户端的地方使用小型廉价缓存，而在更高层次中逐步采用更大、功能更强的缓存来装载多用户共享的文档。

我们希望大部分用户能在附近的第一级缓存中命中（参见图7-9a）。如果没有命中，较大的父缓存可能能够处理这些请求（参见图7-9b）。在缓存层次结构很深的情况下，请求可能要穿过很长一溜缓存，每个拦截代理都会增加一些性能损耗，当代理链路变得很长时，这种损耗会变得非常明显。

注7：如果客户端浏览器自带缓存，那么从技术上讲，图7-9显示的是一个三级缓存层次结构。

注8：父缓存可能需要更大，以便装载多用户间流行的文档，并接收来自许多子缓存的聚合流量，这些子缓存的兴趣点可能很分散，因此需要更高的性能。

注9：实际中，网络结构会尝试将其深度限制在连续的两到三个代理以内。然而，新一代高性能代理服务器使得代理链的长度变得不那么重要。

#### 7.6.4 网状缓存、内容路由以及对等缓存

有些网络结构构建复杂的网状缓存（cache mesh），而不是简单的缓存层次结构。网状缓存中的代理缓存之间以更复杂的方式进行通信，动态决定与哪个父缓存对话，或直接连接原始服务器。这种代理缓存被称为内容路由器（content router）。

网状缓存中的内容路由器需完成以下功能：
- 根据URL在父缓存或原始服务器之间进行动态选择。
- 根据URL动态选择特定的父缓存。
- 在前往父缓存之前，在本地缓存中搜索已缓存的副本。
- 允许其他缓存对其部分内容进行访问，但不允许互联网流量通过它们的缓存。

不同的组织可以通过兄弟缓存（sibling cache）互为对等实体，将它们的缓存连接起来以实现共赢。HTTP并不支持兄弟缓存，因此通过扩展协议如ICP和HTCP来实现（参见第20章）。

### 7.7 缓存的处理步骤

现代商业化代理缓存非常复杂，支持HTTP和其他技术的各种高级特性。但除了一些细节外，Web缓存的基本工作原理相对简单。对一条HTTP GET报文的基本缓存处理过程包括七个步骤（参见图7-11）：

1. **接收**：缓存从网络中读取抵达的请求报文。
2. **解析**：缓存对报文进行解析，提取出URL和各种首部。
3. **查询**：缓存查看是否有本地副本可用，如果没有，就获取一份副本并存储在本地。
4. **新鲜度检测**：缓存检查已缓存副本是否足够新鲜，如果不是，就询问服务器是否有更新。
5. **创建响应**：缓存用新的首部和已缓存的主体构建一条响应报文。
6. **发送**：缓存通过网络将响应发回给客户端。
7. **日志**：缓存可选地创建一个日志文件条目来描述这个事务。

#### 7.7.1 第一步——接收

在第一步中，缓存检测到网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，并在整条报文抵达之前开始处理事务。

#### 7.7.2 第二步——解析

接下来，缓存将请求报文解析为片段，将首部的各个部分放入易于操作的数据结构中，使缓存软件更容易处理和修改首部字段。

#### 7.7.3 第三步——查找

在第三步中，缓存获取URL并查找本地副本。本地副本可能存储在内存、本地磁盘，甚至附近的另一台计算机中。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。如果本地没有该文档，它可以根据情形和配置，到原始服务器或父代理中去取，或者返回一条错误信息。

已缓存对象包含服务器响应主体和原始服务器响应首部，以在缓存命中时返回正确的服务器首部。此外，还包含元数据，记录对象在缓存中的停留时间和使用频率。

#### 7.7.4 第四步——新鲜度检测

HTTP通过缓存保留服务器文档的副本一段时间，在这段时间内，文档被认为是“新鲜的”，缓存可以在不联系服务器的情况下直接提供该文档。一旦已缓存副本超过新鲜度限值，就认为对象“过时”，缓存必须再次与服务器确认文档是否有变化。客户端发送给缓存的所有请求首部都可以强制缓存进行再验证或完全避免验证，这使得事情更加复杂。

HTTP有一组复杂的新鲜度检测规则，缓存产品支持的大量配置选项以及与非HTTP新鲜度标准的互通需求进一步增加了复杂性。本章其余部分将详细解释新鲜度的计算问题。

#### 7.7.5 第五步——创建响应

缓存希望其响应看起来像来自原始服务器一样，因此将已缓存的服务器响应首部作为响应首部的起点，并对其进行修改和扩充。

注10：解析程序负责标准化首部各部分，忽略大小写或数据格式等不太重要的区别。某些请求报文中包含完整的绝对URL，而其他请求中包含相对URL和Host首部，解析程序通常会隐藏这些细节（参见2.3.1节）。

注11：复杂的缓存还会保留引发服务器响应的原始客户端请求首部的副本，用于HTTP/1.1内容协商（参见第17章）。