mtd4:
mtd5:
Size
0x000e0000 896KB
0x00500000 5MB
0x00280000 2.5MB
0x09100000 145MB
0x05f00000 95MB
0x0c440000 196.24MB userdata
Name
misc
recovery
boot
system
cache
Range
0x000003ee0000-0x000003fc0000
0x000004240000-0x000004740000
0x000004740000-0x0000049c0000
0x0000049c0000-0x00000dac0000
0x00000dac0000-0x0000139c0000
0x0000139c0000-0x00001fe00000
Erasesize
0x00020000
0x00020000
0x00020000
0x00020000
0x00020000
0x00020000
Table 3: Google’s Nexus One NAND Partition Layout.
physical loading address, product name, kernel command
line options (512bytes), timestamp, sha1 hash. 0x800:4K
page aligned kernel zimage with zero trailing paddings after
that is the ram-disk which also 4K page aligned and zero
padded. The last part is a second optional kernel for testing
and do not normally appear in device. We use such knowl-
edge to repack the boot.img ﬁle which includes malicious
code.
Google maintains regular release and updates for Android
system, and all the boot.img ﬁles are publicly available as
well as other system ﬁles. The user may update the boot.img
on it’s own and we can not assume it has the same boot.img
as Google’s released standard ones. For a particular vic-
tim device, we do not have the prior knowledge about this
boundary information between the kernel and the ram-disk.
Since the magic string of gzip ﬁle is 0x1F8B, we use 0x000000001F8B
which is the trailing padding zeroes plus the gzip magic
string as the identiﬁcation of the start ram-disk content, and
rewrite them to separate ﬁles. After we get the ram-disk ﬁle,
we unpack it and get direct access to init.rc ﬁle. This ﬁle
is parsed by init program which is also the ﬁrst process of
the system. It sets up the basic environment for the system
and then launches critical system daemon processes and ser-
vices. The init binary and init.rc include Android speciﬁc
system features (e.g some global system properties are de-
ﬁned and parsed here) and are critical to the entire system.
Until now, we assumed direct access to all the resources to
insert our malicious logic into the system. Initially, we bind
the adbd daemon process with root permission by changing
the adbd parameters init.rc ﬁle. This will provide root shell
access to the whole system when we launch adb connection
from our desktop system as a attack vector. Afterwards, we
use the command in init.rc to remount system partition as
read-only or we can run“(mount yaﬀs2 mtd@system /system
ro remount,mount rootfs rootfs / ro remount)” to achive full
ﬁlesystem privileges regardless of the system settings. Then,
we add new command in init.rc ﬁle to launch the malicious
program as a system service which will be pushed into the
system as a separate step so that it is persistent and still
running after phone reboot or battery outage. It is worth
mentioning that this makes the malicious program persis-
tent at bootup and is agnostic to the malware code itself.
If the malicious binary is removed, such automated initial-
ization will fail. The path need to match the corresponding
path of the binary.
After performing the aforementioned modiﬁcations, we
repack the boot.img from the modiﬁed sources and ﬂash it
back to boot partition on the device. The repack process
is straightforward: we compress the modiﬁed ram-disk ﬁles
and directory structures into a single ramdisk.cpio.gz ﬁle.
We then combine it with the kernel and kernel command line
362
options by mkbootimg program which is available in Android
repository. The ﬂashing process merely takes 2 seconds for
a 2560KB boot.img ﬁle by issuing command fastboot ﬂash
boot boot.img where fastboot is a program having the min-
imal functionality of maintaining the device in boot-loader
mode (e.g. updating partitions of the device). This pro-
gram is available for Windows, Linux, and Mac OSX. After
all the above steps, we have gained full control of the vic-
tim device and prepared automated launching of the mali-
cious code. We reboot the phone back to normal mode from
boot-loader mode and push our malicious binary to the sys-
tem partition by adb push evilprog /system/xbin and change
the permission for execution. The detailed malicious action
that this evil binary can do is beyond the scope of this pa-
per. For proof-of-concept demonstration purposes, we wrote
a program for collecting the device information and send
them to a pre-conﬁgured internal collection server stealthily
over TCP/IP via cellular data network or wireless network
whichever available. This program is cross-compiled against
Android’s bionic C libraries with arm-eabi toolchains. Some
more developed and foreseen real attacks are discussed in
Section 4. Note that this program is written in C and ex-
ecuted as the ARM ELF binary at the system utility level
which is lower than Davik Java virtual machine and bypass
all Android’s permission checks for application at JVM [14].
Our server successfully collected the device information sent
by the program, which includes the serial number of the de-
vice, the kernel version and a list of installed applications.
As we mentioned earlier in this section, all the above logic
and operation sequences are programmed as a malicious dae-
mon running on the desktop system. The complete process
takes 300 seconds, which corresponds to the sum of every
steps.
3.4 Phone-to-Phone Attacks
The inherent mobility and programmability of the third-
generation smart phones gave rise to a new type of insider
attack. The phone is fully capable of assuming the role of
a computer host by setting its USB port to be a USB Hub.
This type of attack is similar to the attacks described in
Section 3.3. For phone-to-phone attacks, a malicious user
connects a subverted device to a victim device and then
take over it stealthily. This can happen, for instance, when
the victim device is left unattended.
In this section, we
show how to perform a phone-to-phone attack via a single
USB interface as the infection vector. The key capability
is to enable the USB host mode on one device, a Motorola
Droid in our case, which ﬁrst time provides the ability of
controlling a Android device from another Android device.
The rest of the attack is similar to the one described in
Section 3.3. When the manipulated Motorola Droid device
High mobility take over
Install malware
USB Host Mode
USB Peripheral/Gadget 
Figure 4: The Phone-to-Phone Attacks over the USB Connection.
Figure 5: The Micro B USB Connector Dongle.
Figure 6: The Crafted USB Cable for Phone-to-Phone
Attacks.
connected to another device, the malicious daemon will send
pre-programmed command and the victim device will treat
it as from a normal desktop system.
For our purposes, we leverage the advanced USB chip in
recent released Google Nexus One by HTC and Motorola
Droid devices and enable the device’s USB host mode ca-
pabilities. In regular operation, the phone devices only act
as peripheral devices at the USB protocol level. The desk-
top system will send the ﬁrst USB packet and initiate the
USB connection link. We instead enable the USB OTG
(On-the-Go) driver in the device with such hardware sup-
port, and ﬂip a normal smart phone device as the USB
host. To be more speciﬁc, both Nexus One’s Qualcomm
QSX8250 chipset and Motorola Droid’s Texas Instruments
OMAP3430 chipset support USB OTG speciﬁcation [9]. Our
experiment on Google Nexus One device failed due to limited
SoC depended kernel code support for Qualcomm QSX8250
chipset. However, the OMAP series chipset integrated with
the Philips ISP1301 USB OTG transceiver has more mature
code in the kernel source. By checking the following kernel
compilation options, we can enable the OTG software.
CONFIG_ARCH_OMAP_OTG=y
CONFIG_USB_OTG=y
CONFIG_USB_MUSB_OTG=y
CONFIG_USB_OTG_UTILS=y
After we activate the kernel driver, we need the specially
crafted USB connectors and cable to trigger the USB host
mode of the USB OTG device and connect other periph-
eral devices. By soldering the 4th pin and 5pin of the micro
USB connector from a car charger, we changed a micro B
connector to a micro A connector, to identify itself as a host
side connector. Unfortunately, most oﬀ- the-shelf product
do not specify it is a A connector or a B connector. Figure 5
shows the micro B dongle we had to solder to achieve our
goal. To place the device in the USB hub mode, we have
to perform a hard reboot while the micro B connector is
inserted in the Droid USB interface. Moreover, we have to
unplug the micro-dongle as soon as the Motorola logo disap-
pears as the Droid logo appears. This forces the hardware
initialization process to identify the USB hardware in the
host mode. After the system boots up, we can verify that
the USB is in host mode by running the following command
“cat /sys/devices/platform/musb hdrc/mode”.
If the out-
put of the command is “a host” then we are in host mode.
Notice that we need to enable the wireless connectivity and
use secure shell connection for shell access because the USB
interface is in host mode and thus traditional adb shell access
over USB is disabled.
To connect other peripheral devices, in our case a vic-
tim phone, we make the special USB cable with both end
micro USB by cutting two cables and put two micro connec-
tor in a single cable by soldering the same color together.
Our additional experiments shows the device can support
additional USB-to-Serial converter but for USB ﬂash driver
devices, we have to use external USB power hub to supply
additional power to the Vcc line. Figure 6 depicts a snap-
shot of the cable we made with the micro USB connectors
at both ends. It is worth mentioning here that due to the
requirement that the D+ and D- must be twisted for syn-
chronization purposes, we can only break the cable within a
limited distance for soldering.
Another important aspect of the attack is that the pe-
ripheral device driver must be compiled in the host mode
device. To limit unnecessary code, most of the non-required
kernel options and device drivers are turned oﬀ by manufac-
ture conﬁguration. We performed our experiments using a
Motorola Droid to attack a Nexus One phone. The generic
363
USB hub driver on the Droid kernel is compiled as part of
the Linux Kernel. The ﬁnal step is compiling the user level
program against the Android system libraries. adb provides
the ability of controlling a Android device from another An-
droid device. The rest of the attack is similar to the one
described in Section 3.3 where the host is replaced with the
Droid device. When the malicious Motorola Droid device
connects to the victim device, the malicious daemon will
send the pre-programmed command over the USB and the
victim device will treat it similarly as it did for the host
computer.
4. DISCUSSION
Our attacks are primarily implemented on the Android
framework because of its open source nature and the ease
that we can demonstrate and detail our results making them
reproducible. However, we posit that attacks that abuse the
USB physical link and hardware programmability exist also
for other mobile phone platforms such as the Apple iPhone
OS, Microsoft Windows CE and Symbian OS. Moreover,
there are scenarios where the described classes of attacks
are easier to be accomplished on other platforms. Taking
iPhone OS as an example, an adversary can take advantage
of the default music play functionality that iTunes software
oﬀers to craft malware media ﬁles and “synchronize” them
with the connected computer. In addition, antivirus prod-
ucts normally scan the external storage in the device which
appears as a ﬂash drive from the operating system’s view.
However, such scans are based on well-known ﬁle formats
and none of them can scan the internal ROM or raw data
stored in the hand-held devices, to the best knowledge of
the authors. This represents a clear defense gap.
The common theme behind the USB attacks is the estab-
lished belief that physical cable connectivity can be inher-
ently trusted and that peripherals are not capable of abusing
the USB connection. To protect the end-point devices, there
is a need to shed that belief. Instead we have to focus on
how to establish trust that is not implicit but explicit and
puts the human on the loop. Therefore, a possible defense
strategy is to authenticate the USB connection establish-
ment phase and communications using similar techniques
that were developed for Bluetooth devices. This will give
a visual input to the user and will allow her to verify that
a device that attempts to connect as a peripheral is indeed
allowed to connect. Moreover, there is a need to identify
and communicate to the user the type of the USB device
that attempts to connect as a peripheral. This will prevent
attacks that pretend to be HID devices and connect without
any user interaction.
Unfortunately, attacks that exploit the USB while the vic-
tim device is in “slave” mode are more diﬃcult to thwart
because some of the functionality is required to control the
“slave” device. However, smart phone vendors can try to ﬁl-
ter and vet the USB communications using a USB ﬁrewall.
Similar to network ﬁrewall, this USB ﬁrewall will inspect
all USB packets coming to the device and check the content