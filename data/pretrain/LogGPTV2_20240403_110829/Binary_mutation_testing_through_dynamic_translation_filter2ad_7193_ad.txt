s
n
e
S
t
c
e
r
r
o
C
u
d
e
d
o
M
g
n
i
l
e
u
F
r
e
t
n
u
o
C
l
i
a
F
s
n
e
S
1
T
1
I
p
t
n
I
D
2
b
a
T
c
1
T
7
1
S
x
d
I
b
a
T
w
o
ﬂ
r
i
A
e
t
a
l
u
c
l
a
C
6
2
c
C
Test case set Metric
Engine Model:
150s sim. time
15000 tests
Delta Gen.:
Step size 2048
1048576 tests
Combined:
1048576 +
15000 tests
*Instruction coverage is only provided through binary testing
Instruction coverage*
Mutation coverage
Killed mutants
Instruction coverage*
Mutation coverage
Killed mutants
Instruction coverage*
Mutation coverage
Killed mutants
6/100%
5/83%
6/100%
6/100%
6/100%
6/100%
l
i
a
F
t
c
e
t
e
TOTAL
D
1720/97% 456/100% 256/83% 792/63% 360/69% 344/56% 272/91% 764/98% 852/98% 688/92% 6504/85%
12/100% 26/100% 16/100% 210/91%
74/97%
147/64%
52/68%
9/75%
1780/100% 456/100% 308/100% 656/52% 520/100% 612/100% 300/100% 776/100% 856/98% 704/95% 6968/91%
12/100% 26/100% 16/100% 216/94%
76/100%
171/74%
55/72%
12/100% 19/73% 14/88%
1780/100% 456/100% 308/100% 960/76% 520/100% 612/100% 300/100% 776/100% 856/98% 704/95% 7272/95%
12/100% 26/100% 16/100% 230/100%
76/100%
186/81%
12/100% 21/81% 14/88%
55/72%
26/65% 32/100% 12/100% 6/100%
19/48% 28/88%
6/100%
40/100% 32/100% 12/100% 6/100%
6/100%
32/80% 28/88%
32/80% 26/81%
24/60% 19/59%
18/69% 11/69%
10/83%
2/17%
6/100%
6/100%
4/100%
3/75%
4/100%
3/75%
2/50%
1/25%
9/75%
9/75%
TEST CONFIDENCE METRICS FOR THE FUEL INJECTION CONTROLLER SOFTWARE.
Table VI
D. Performance
Fig. 9(a) shows the performance numbers comparing the
different testing approaches. The experiments were carried
out on an Intel Xeon Quadcore HT processor running at 3.4
GHz. Here, the y-axis denotes the measured testing time in
seconds. Again, the x-axis denotes the number of applied
test cases per mutant. As each test case is applied to all
mutants for the delta generator 230∗ 1048576 = 241172480
test cases have to be investigated in total (assuming a step
size of 2048). Basically, we can see that all mutation testing
approaches scale well, i.e., almost linearly according to the
the number of test cases per mutant. As expected, source
code mutation testing comes with a quite high base effort
related to the number of mutants as each mutant is generated
separately by compilation. Thus,
the native approach is
dominated by compilation efforts, i.e., testing time increases
only slightly with the number of test cases per mutant.
Fig. 9(a) shows that the break even for the GDB/ARMulator
is only below 10-100 test cases per mutant. With QEMU the
break even is below 100,000-1,000,000 test cases per mutant.
In average, the QEMU approach performs 100-1000x faster
than GDB/ARMulator. Fig. 9(c) demonstrates the speed up
achieved by online detection and mutant skipping extensions
applied to QEMU. Finally, Fig. 9(b) depicts the additional
speed up that can be achieved by utilizing multicore hosts.
With the proposed parallelization approach the testing effort
can be almost divided by the number of available cores
imposing no extra synchronization overhead. Here, four full
cores with hyper threading are utilized.
V. RELATED WORK
Mutation testing has inherent higher execution costs,
hence various mutant reduction and execution cost reduc-
tion techniques have been proposed [11]. Most of the
existing approaches focus on white-box testing and source
code instrumentation, so the source code or intermediate
object code of the design-under-veriﬁcation, such as Java
bytecode in [12], has to be available for the generation
of mutants. Moreover, most frameworks focus on high-
level software programming languages such as C# and Java
[13]. For example, a large set of C language mutation
operators were introduced in [14]. Later it was showed
in [15] that a reduced number of operators still achieves
a high mutation score. For hardware design, SpringSoft
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:48:31 UTC from IEEE Xplore.  Restrictions apply. 
(a) Speed comparison w.r.t. GDB/ARMulator and native execution.
(b) Speed up through online detection and mutant skipping.
(c) Speed up through multicore utilization.
Figure 9. Evaluation of mutation testing performance.
CERTITUDE supports functional qualiﬁcation for C and
VHDL/Verilog [16]. In [17] mutation operators for IP-
XACT electronic component descriptions were introduced.
In contrast
to prior mentioned related work we aim to
leverage mutation testing in the embedded software domain,
which is mainly C and SystemC based, by doing so, also
targeting mutation faults at the application binary interface
(ABI) for COTS libraries [18]. In [19] the authors modiﬁed
a GNU C compiler chain to generate patches in order to
enable compiler-integrated mutant generation. In [20] the
authors propose a SystemC error and mutation injection tool
based on compiler injection via a plugin for the gcc compiler.
In total, four mutant operators are introduced. Another
approach for SystemC and TLM mutation testing [21] allows
to selectively activate one mutant at a time through the
use of a fault_number variable, properly driven by the
testbench during the simulation phase. In contrast to the
presented compiler-induced and super mutant
techniques
our proposed binary translation based approach allows to
perform mutation testing for different ISAs and offers much
greater mutation ﬂexibility by means of the event-triggered
callbacks mechanism during translation. Moreover, targeting
COTS libraries (with no source code available) our approach
is language and compiler independent. In [22] the authors
propose a software fault injection technique for the IA32
platform by means of machine-code level patterns. Muta-
tions are applied directly to the target code. As their focus is
on the emulation of residual software they do not consider
efﬁcient fault injection/detection for mutation testing such
as our binary translation based technique. Moreover, their
proposed system does not provide cross platform support
for typical embedded systems instruction set architectures
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:48:31 UTC from IEEE Xplore.  Restrictions apply. 
such as ARM. Besides that, our framework provides the
veriﬁcation engineer with feedback on the achieved test
conﬁdence by means of a binary CFG annotated with
results such as undetected mutations and their corresponding
addr2line information.
VI. CONCLUSION
We introduced a novel approach for mutation testing
of binary software. The testing is seamlessly integrated
into binary translation cycle of software emulation runtime.
Mutants are derived from the original software binary under
test by a control ﬂow analysis prior to its execution. Though
we introduce our approach by mutation operators for the
ARM instruction set, the basic principles are well applicable
to other embedded processors. Our approach comes with
several signiﬁcant advantages: (i) it does not presume the
availability of the source code nor does it require modiﬁca-
tions of the applied target compiler; (ii) we can capture faults
speciﬁc to a target instruction set architecture and tool chain,
e.g., compiler bugs and anomalies in the code optimization.
Experiments were conducted with a case study from the
automotive industry, a fault tolerant fuel injection control
system. Our experiments reached a 100% accuracy com-
pared to source code mutation testing at the same time
providing a speed up of up to 100-1000x compared to the
execution of GDB/ARMulator ISS. We can even outperform
native execution as our approach avoids individual mutant
compilation and testing relies on an efﬁcient framework
extending the QEMU binary translator. The utilization of
multicore hosts through efﬁcient multi-threading further
improves testing speed with the number of available cores.
VII. FUTURE WORK
Our future work will focus on a more complete evaluation
of the proposed mutator classes for ARM and their efﬁcient
application to testing low level faults such as ABI mis-
matches. Further work will consider automatic test pattern
generation (ATPG) from binary CDFG analysis and porting
the framework to QEMU system mode in order to cover also
system software such as operating systems, device drivers,
and boot ﬁrmware.
ACKNOWLEDGMENTS
This work was partly funded by the DFG SFB 614
and the German Ministry of Education and Research
(BMBF) through the project SANITAS (01M3088I) and the
ITEA2 projects VERDE (01S09012H) and TIMMO-2-USE
(01IS10034A).
REFERENCES
[1] R. A. DeMillo, R. J. Lipton, and F. G. Sayward, “Hints
on test data selection: Help for the practicing programmer,”
Computer, vol. 11, pp. 34–41, April 1978.
[2] R. H. Untch, A. J. Offutt, and M. J. Harrold, “Mutation
analysis using mutant schemata,” in Proceedings of the 1993
ACM SIGSOFT international symposium on Software testing
and analysis, ser. ISSTA ’93. New York, NY, USA: ACM,
1993, pp. 139–148.
[3] W. E. Howden, “Weak mutation testing and completeness of
test sets,” IEEE Trans. Softw. Eng., vol. 8, pp. 371–379, July
1982.
[4] ARM Architecture Ref. Manuals, http://infocenter.arm.com.
[5] A. Sloss, D. Symes, and C. Wright, ARM System Developer’s
Guide: Designing and Optimizing System Software.
San
Francisco, CA, USA: Morgan Kaufmann Publishers Inc.,
2004.
[6] F. Bellard, “QEMU, a Fast and Portable Dynamic Translator,”
in ATEC ’05: Proceedings of
the Annual Conference on
USENIX Annual Technical Conference. Berkeley, CA, USA:
USENIX Association, 2005, pp. 41–41.
[7] QEMU - Open Source Processor Emulator, http://www.qemu.
org.
[8] M. Gligor, N. Fournel, and F. P´etrot, “Using Binary Transla-
tion in Event Driven Simulation for Fast and Flexible MPSoC
Simulation,” in CODES+ISSS ’09: Proceedings of the 7th
IEEE/ACM International Conference on Hardware/Software
Codesign and System Synthesis. New York, NY, USA: ACM,
2009, pp. 71–80.
[9] C. Guillon, “Program Instrumentation with QEMU,” in DATE
’11: Proceedings of the Conference on Design, Automation
and Test in Europe, Grenoble, France, 2011.
[10] TargetLink, dSPACE GmbH, http://www.dspace.com.
[11] Y. Jia and M. Harman, “An analysis and survey of the devel-
opment of mutation testing,” IEEE Transactions on Software
Engineering, 2010.
[12] Y. seung Ma, J. Offutt, and Y. R. Kwon, “Mujava: an auto-
mated class mutation system,” Software Testing, Veriﬁcation
& Reliability, vol. 15, pp. 97–133, 2005.
[13] B. Bogacki and B. Walter, “Aspect-oriented response injec-
tion: an alternative to classical mutation testing,” in Software
Engineering Techniques: Design for Quality, ser. IFIP Inter-
national Federation for Information Processing, K. Sacha, Ed.
Springer Boston, 2007, vol. 227, pp. 273–282.
[14] H. A. Richard, R. A. Demillo, and B. H. et al., “Design of
Mutant Operators for the C Programming Language,” Tech.
Rep., 1989.
[15] A. S. Namin, J. H. Andrews, and D. J. Murdoch, “Sufﬁcient
mutation operators for measuring test effectiveness,” in IN
PROC. ICSE, 2008, pp. 351–360.
[16] SpringSoft Inc., “CERTITUDE Functional Qualiﬁcation Sys-
tem,” 2011.
[17] T. Xie, W. Mueller, and F. Letombe, “IP-XACT based system
level mutation testing,” in High Level Design Validation and
Test Workshop (HLDVT), 2011 IEEE International, nov. 2011.
[18] C. Kuznik and W. Mueller, “Native binary mutation analysis
for embedded software and virtual prototypes in SystemC,”
The 17th IEEE Paciﬁc Rim International Symposium on
Dependable Computing (PRDC 2011), 2011.
[19] R. DeMillo, E. Krauser, and A. Mathur, “Compiler-integrated
program mutation,” in Computer Software and Applications
Conference, 1991. COMPSAC ’91., Proceedings of the Fif-
teenth Annual International, sep 1991, pp. 351 –356.
[20] P. Lisherness and K.-T. T. Cheng, “SCEMIT: a systemc
error and mutation injection tool,” in Proceedings of the 47th
Design Automation Conference, ser. DAC ’10. New York,
NY, USA: ACM, 2010, pp. 228–233.
[21] V. Guarnieri, N. Bombieri, G. Pravadelli, F. Fummi,
H. Hantson, J. Raik, M. Jenihhin, and R. Ubar, “Muta-
tion analysis for systemc designs at tlm,” in Test Workshop
(LATW), 2011 12th Latin American, march 2011, pp. 1 –6.
[22] J. ao A. Dur˜aes and H. S. Madeira, “Emulation of software
faults: A ﬁeld data study and a practical approach,” IEEE
Transactions on Software Engineering, vol. 32, pp. 849–867,
2006.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:48:31 UTC from IEEE Xplore.  Restrictions apply.