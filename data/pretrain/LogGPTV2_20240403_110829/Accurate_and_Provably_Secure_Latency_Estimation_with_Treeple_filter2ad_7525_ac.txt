cept with negligible probability in the security parameter.
Additionally we assume that each end-host h has access to
two functions: h.route(g) returns a list of routers along
the path from h to g; and h.rtt(g) returns the round-trip
time between h and g. For clarity, the “system parame-
ters” generated in GlobalInit are passed as implicit argu-
ments to other procedures. Finally, we assume a ﬁxed set
of k trusted vantage points whose addresses are included in
the global parameters, but are not chosen by the protocols.
These nodes serve as a “root of trust” in the scheme. We
brieﬂy discuss algorithms for choosing from among several
possible vantage points in Section 4.
3.2. Security
Theorem 1. Assuming the set {T1, . . . , Tk} of vantage
points are honest, Treeple is a secure network latency esti-
mation scheme.
Proof. Fix a network graph and condition sequence χ,
along with a set of adversarial peers A such that A ∩
{T1, . . . , Tk} = ∅. Suppose that there exists a pair of peers
(A, B) that violate the security condition of section 2; we
will show that, except with negligible probability, the ex-
istence of this pair must imply a signature forgery. We let
Deﬁne Treeple.GlobalInit:
Deﬁne Treeple.LocalInit(N):
Deﬁne Treeple.Udpate(N, t):
For each trusted Ti ∈ {T1, . . . , Tk} :
set posN ← getPosition(N, time()).
Ti:
Ti:
choose (vki, ski) ← Gen(λ).
send (i, vki) to {T1, . . . , Tk}.
Output: hvk1, . . . , vkki.
Deﬁne Treeple.getPosition(N, t):
N: choose ridt ←R {0, 1}λ. Set posN.rid = ridt.
Foreach Ti ∈ {T1, . . . , Tk} do:
N:
N:
Ti:
Ti:
Ti:
Ti:
Ti:
Ti:
Ti:
Ti:
Ti:
Ti:
Ti
N:
N:
N:
N:
choose ridi ←R {0, 1}λ.
send pos-request(ridt, ridi, t) to Ti
on pos-request(ridt, ridi, t) from N:
set rt ← hi
rt.rid ← ridi.
rt.t ← t.
if |t − time()| > τ : abort.
compute hr1, . . . rℓi = Ti.route(N).
for each rj ∈ hr1, . . . , rℓ = Ni:
rt.hostj ← rj .
rt.rttj ← Ti.rtt(rj)
rt.sig ← Signski (rt.host, rt.rtt, ridt, ridi, t).
send route-reply(rt) to N.
on route-reply(rt) from Ti:
if Verifyvki ((rt.host, rt.rtt, ridi, ridt, t), sig):
set posN.routei = rti.
else, set posN.routei = ⊥.
Output: posN.
if length(posN) < k
or posN is stale:
set posN ← getPosition(N, t).
Deﬁne Treeple.Distance(posA, posB):
set dist ← ∞.
if (|posA.t − posB.t| ≤ τ ):
For each Ti ∈ {T1, . . . , Tk} do:
if (verify(i, posA) and verify(i, posB)):
set lca ← ﬁnd-lca(posA.routei, posB.routei).
set di ←(posA.routei.rttA − posA.routei.rttlca)+
(posB.routei.rttB − posB.routei.rttlca).
Update dist ← min(dist, di).
Output: dist
Deﬁne ﬁnd-lca(rt1, rt2):
Output: max{j|rt1.hostj = rt2.hostj}.
Deﬁne verify(i, ρ):
if ρ.routei =⊥: output False
else:
set mi ← hρ.routei.host, ρ.routei.rtt, ρ.routei.rid, ρ.rid, ρ.ti.
output Verifyvki (mi, ρ.routei.sig).
Figure 3. Treeple algorithms, assuming the existence of a digital signature scheme (Gen, Sign, Verify)
and a pre(cid:173)selected set of trusted vantage points {T1, . . . , Tk}. Here a position consists of a time t,
a global random identifer rid, plus an indexed array route, where each entry routei is either ⊥ or a
record consisting of indexed arrays host and rtt along with a signature ﬁeld and a local identiﬁer.
α denote the total number of messages sent by adversarial
nodes in the adversarial trace.
First, notice that for any honest peer h, at any time t,
posh must be identical in both the adversarial and non-
adversarial execution traces, except with negligible proba-
bility. This is because the “request identiﬁer” ridi generated
in getPosition(h), combined with signature veriﬁcation on
received route messages, ensures that h only updates its
coordinates when it receives authentic responses to its own
requests, from trusted nodes. Since calls to getPosition(h)
and are only initiated by h and our adversarial model ex-
cludes dropping and interception of honest messages, it fol-
lows that in any pair of execution traces with identical net-
work conditions, an honest node will have equivalent posi-
tions.
Speciﬁcally, an honest node only changes its position
when it receives a message that is signed and contains its
most recent, randomly chosen identiﬁer. Since adversarial
nodes do not see the requests generated by honest nodes, the
probability of correctly guessing a request identiﬁer in α at-
tempts is at most ℓnα
2λ (where ℓ is the length of the trace,
n is the number of peers, and λ is the length of request
identiﬁers). Given that the adversary does not correctly
guess request identiﬁers, it can only cause an honest node
to accept a position that is different than the non-adversarial
trace by generating a response message route′ that is appar-
ently signed by one of the trusted vantage points. Notice
that given the sequence of network conditions and a signing
oracle, it is easy to generate all the messages a set of adver-
sarial nodes would see in the adversarial execution (because
the honest nodes follow the protocol), and thus it follows
that this route′ and its signature would constitute a forgery.
If we denote the (negligible) probability of a forgery with
nℓ + α signature queries by ǫ, then the probability of this
event is at most kǫ by the standard reduction that guesses
which trusted party the adversary will forge against.
Thus, if the pair (A, B) is honest, the presence of ad-
versaries is irrelevant: Distance(posA, posB) will be the
same in both traces. On the other hand, consider the variable
posA assigned to an adversarial node A at time t. Since the
adversarial node initiates the same requests in both traces, it
can only manipulate its position by either manipulating the
measurement of Ti.rtt(A) for some Ti (by assumption the
measurement of route(Ti, A) and Ti.rtt(x) for x 6= A are
not vulnerable to manipulation) or by substituting a differ-
ent value for some routei. By assumption on the rtt func-
tionality, the ﬁrst type of manipulation will only inﬂate the
distance between A and its “last hop”, which will inﬂate the
distance to other nodes (uniformly). So the only remaining
option to violate the security condition is to replace some
routei. The requirement that all route messages in a po-
sition have the same request identiﬁer prevents “mix-and-
match” substitution of routes between requests. Dropping
any route message that does not give the minimal distance
to a particular position will not affect the distance calcula-
tion, while dropping the minimal distance route will only
increase the distance. Finally, producing a signed routei
with different rtt or host entries would constitute a forgery,
and thus an adversary would again successfully produce this
forgery with probability at most kǫ.
4. Evaluation
4.1. Experimental Setup
To evaluate our approach, we used the iPlane [21]
dataset. This data set contains the results of periodic tracer-
outes from 250 Planetlab [26] nodes to all other Planetlab
nodes and thousands of other IP addresses. We note that
the iPlane dataset is “live”; every day, each of the Planet-
Lab nodes performs multiple traceroutes to over 100,000
IP addresses and publishes the results. We downloaded the
traceroute datasets from Dec 1st, 2009 to Dec 22nd, 2009.
The dataset presented 250 possible trusted nodes to choose
from; each trusted node contacted more than 130, 000 IP
addresses on average, and each tree constructed from the
traceroutes contained on average 200, 000 unique nodes (in-
cluding intermediate nodes). In constructing the paths from
trusted nodes to peers, we always used the minimum RTT
measured at each hop, and when repeated traceroutes re-
sulted in different routes, we selected the shorter route.
To determine the accuracy of a given set T of vantage
points, we considered all pairs of nodes (A, B) such that (i)
all vantage points in the set had successfully completed a
traceroute to both A and B, allowing us to compute posi-
tions posA, posB; and (ii) we had measured the RTT be-
tween A and B. For each such pair, we computed the rela-
tive error,
|Distance(posA, posB) − RT TA,B|
RT TA,B ,
to measure the accuracy in estimating the latency between
A and B using T ; lower relative error indicates a better esti-
mate of the latency. Because the iPlane measurement apara-
tus does not retry traceroutes that fail, the size of the evalua-
tion set will vary across sets T ; in all cases the size was over
200,000. In order to compare between these evaluation sets,
we used the median relative error for each. Additionally, for
our “best choice” of 20 vantage points T , we also measured
the size of the coordinates posA and posB and the number
of node comparisons required to estimate the distance.
4.2. Selecting a set of vantage points
Determining the accuracy of Treeple is not as straight-
forward as for a network coordinate system. The relative
error is still used to determine whether an estimated net-
work distance is accurate – the lower the error, the more
accurate the estimation. However, using the iPlane dataset,
there are 250 possible vantage points.
It is clear that, in
general, different vantage point sets will produce different
accuracy. An important question, both for evaluation and
eventual deployment, is how to select a good set of vantage
points.
Determining the “best possible” single vantage point is
relatively straightforward – compute the median relative er-
ror for each pair of end hosts’ network distance estimation,
for each of the 250 vantage points, and the one with the low-
est median relative error is the most accurate. When k = 2,
we could pick the very best combination of any two vantage
points such that the combination would result in the lowest
median relative error among all the possible combinations
(total of 250 × 249 = 62, 250 combinations). However, this
approach is not scalable, as when k = 3, there are a possi-
ble 250× 249× 248 = 15, 438, 000 combinations to choose
from. Although this approach provides the very best combi-
nation of vantage points to produce the lowest median rela-
tive error, it does not scale past k = 3, and worse, would not
give conﬁdence in the future performance of this set, due to
overﬁtting.
In this paper, we selected vantage sets of different sizes k
using a greedy sampling algorithm, which works as follows.
First, we chose at random a set S of 1, 000 pairs (A, B) be-
tween which we had measured latencies. We start by pick-
ing the best vantage point T1 for the pairs in S among the
250 possible choices. Then we pick the best second van-
tage point T2 that combined with T1 would produce the
lowest median relative error on S, and so on until k van-
tage points have been chosen. Using this algorithm to se-
lect k of n possible vantage points requires O(nk) steps,
as compared to nk for the previous approach. Furthermore,
because we evaluate only on a sample, we avoid overﬁtting
vantage points to our test set.
Although it is clear that the “greedy” approach is scal-
able for arbitrary k, it remains to be seen whether it pro-
duces a good result, that is, whether it can pick vantage
points that can accurately estimate network distances be-
tween any pair of nodes. Figure 4 shows the CDF for the
F
D
C
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0
r
o
r
r
E
e
v
i
t
l
a
e
R
 0.34
 0.33
 0.32
 0.31
 0.3
 0.29
 0.28
 0.27
 0.26
 0.25
 0.24
t = 2
t = 3
G-2
G-3
 0
 0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8
 0
 10
 20
 30
 40
 50
 60
Relative Error
Time (ticks)
Figure 4. The CDF for the relative error for the estima-
tions for the “best” (t = 2, 3) and “greedy” sets, with vary-
ing k.
Figure 5. The Vivaldi simulation of 100 runs for our
250x250 dataset with error bars representing the standard
deviation.
relative error (amongst all pairs) using greedy sampling to
select vantage sets of size k ∈ {1, 2, 3}. For comparison,
the ﬁgure also includes the CDF of relative error for the k-