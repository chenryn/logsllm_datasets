


























LOC
6685
# States
1.5×1020
6746
1186
1186
408
110
227
3.5×1013
2.1×1096
2.1×1096
1
2
2
91
43
2
2
2
1
1
68
14635
9.4×1021
4
4
2
4
2
2
1
4
1
24
24
57
1
1
1
1
1
1
1
1
1
1
1
436
436
887
436
1119
1152
191
436
134
2651
2651
8955
65
751
282
392
745
406
303
441
65
282
151
1
16
1
16
32
4
1
16
1
1
N/A
1
1
N/A
N/A
1
1
16
1
1
1
1
4
218    28th USENIX Security Symposium
USENIX Association
data and instruction translation lookaside buffers (TLBs), a
hardware page table walker, and a branch prediction unit to
enable speculative execution. Figure 4 in Appendix A shows
its high-level microarchitecture.
PULPissimo is an SoC based on a simpler RISC-V core
with both instruction and data RAM as shown in Figure 2. It
provides an Advanced Extensible Interface (AXI) for access-
ing memory from the core. Peripherals are directly connected
to an Advanced Peripheral Bus (APB) which connects them
to the AXI through a bridge module. It provides support for
autonomous I/O, external interrupt controllers and features a
debug unit and an SPI slave.
TLB Page Fault Timing Side Channel (L-1 & L-2).
While analyzing the Ariane RTL, we noted a timing
side-channel leakage with TLB accesses. TLB page faults
due to illegal accesses occur in a different number of clock
cycles than page faults that occur due to unmapped memory
(we contacted the developers and they acknowledged the
vulnerability). This timing disparity in the RTL manifests
in the microarchitectural behavior of the processor. Thus,
it constitutes a software-visible side channel due to the
measurable clock-cycle difference in the two cases. Previous
work already demonstrated how this can be exploited by
user-space adversaries to probe mapped and unmapped
pages and to break randomization-based defenses [24, 29].
Timing ﬂow properties cannot be directly expressed by
simple properties or modeled by state-of-the-art veriﬁcation
techniques. Moreover, for this vulnerability, we identify at
least seven RTL modules that would need to be modeled,
analyzed and veriﬁed in combination, namely: mmu.sv -
nbdcache.sv - tlb.sv instantiations - ptw.sv - load_unit.sv
- store_unit.sv. Besides modeling their complex inter- and
intra-modular logic ﬂows (L-1), the timing ﬂows need to be
modeled to formally prove the absence of this timing channel
leakage, which is not supported by current industry-standard
tools (L-2). Hence, the only alternative is to verify this
property by manually inspecting and following the clock
cycle transitions across the RTL modules, which is highly
cumbersome and error-prone. However, the design must still
be analyzed to verify that timing side-channel resilience is
implemented correctly and bug-free in the RTL. This only
becomes far more complex for real-world industry-standard
SoCs. We show the RTL hierarchy of the Ariane core in
Figure 5 in Appendix A to illustrate its complexity.
Pre-Fetched Cache State Not Rolled Back (L-1 & L-3).
Another issue in Ariane is with the cache state when a system
return instruction is executed, where the privilege level of the
core is not changed until this instruction is retired. Before
retirement, linear fetching (guided by branch prediction) of
data and instructions following the unretired system return
instruction continues at the current higher system privilege
level. Once the instruction is retired, the execution mode of the
core is changed to the unprivileged level, but the entries that
FIGURE 2: Hardware overview of the PULPissimo SoC. Each
bug icon indicates the presence of at least one security vulner-
ability in the module.
were pre-fetched into the cache (at the system privilege level)
do not get ﬂushed. These shared cache entries are visible to
user-space software, thus enabling timing channels between
privileged and unprivileged software.
Verifying the implementation of all the ﬂush control signals
and their behavior in all different states of the processor
requires examining at least eight modules: ariane.sv -
controller.sv - frontend.sv - id_stage.sv - icache.sv - fetch_ﬁfo
- ariane_pkg.sv - csr_regﬁle.sv (see Figure 5). This is complex
because it requires identifying and deﬁning all the relevant
security properties to be checked across these RTL modules.
Since current industry-standard approaches do not support
expressive capturing and the veriﬁcation of cache states, this
issue in the RTL can only be found by manual inspection.
Firmware-Conﬁgured Memory Ranges (L-4).
In PULPissimo, we added peripherals with injected bugs to
reproduce bugs from CVEs. We added an AES encryption/de-
cryption engine whose input key is stored and fetched from
memory tightly coupled to the processor. The memory ad-
dress the key is stored in is unknown, and whether it is within
the protected memory range or not is inconclusive by observ-
ing the RTL alone. In real-world SoCs, the AES key is stored
in programmable fuses. During secure boot, the bootload-
er/ﬁrmware senses the fuses and stores the key to memory-
mapped registers. The access control ﬁlter is then conﬁgured
to allow only the AES engine access to these registers, thus
protecting this memory range. Because the open-source SoC
we used did not contain a fuse infrastructure, the key storage
was mimicked to be in a register in the Memory-Mapped I/O
(MMIO) space.
Although the information ﬂow of the AES key is deﬁned
in hardware, its location is controlled by the ﬁrmware.
Reasoning on whether the information ﬂow is allowed or
not using conventional hardware veriﬁcation approaches is
inconclusive when considering the RTL code in isolation.
USENIX Association
28th USENIX Security Symposium    219
RISC-VCore Peripheral Interface TimerCLKDebugTightly Coupled Data Memory Interconnect ROML2  BankL2  BankEventAXIAdvancedDebug UnitGPIOuDMAUARTI2CI2SSPIMaster CameraInterface HWPEAPB= Security VulnerabilityJTAGGPIOI2SSPICPII2CUARTAXIThe vulnerable hardware/ﬁrmware interactions cannot be
identiﬁed unless they are co-veriﬁed. Unfortunately, current
industry-standard tools do not support this.
Memory Address Range Overlap (L-1 & L-4).
PULPissimo provides I/O support to its peripherals by map-
ping them to different memory address ranges. If an address
range overlap bug is committed at design-time or by ﬁrmware,
this can break access control policies and have critical secu-
rity consequences, e.g., privilege escalation. We injected an
RTL bug where there is address range overlap between the
SPI Master Peripheral and the SoC Control Peripheral. This
allowed the untrusted SPI Master to access the SoC Control
memory address range over the APB bus.
Verifying issues at the SoC interconnect in such complex
bus protocols is challenging since too many modules needed
to support the interconnect have to be modeled to properly
verify their security. This increases the scope and the com-
plexity of potential bugs far beyond just a few modules, as
shown in Table 1. Such an effect causes an explosion of the
state space since all the possible states have to be modeled
accurately to remain sound. Proof kits for accelerated veriﬁca-
tion of advanced SoC interconnect protocols were introduced
to mitigate this for a small number of bus protocols (AMBA3
and AMBA4). However, this requires an add-on to the default
software and many protocols are not supported4.
5 Crowdsourcing Detection
We organized and conducted a capture-the-ﬂag competition,
Hack@DAC, in which 54 teams (7 from leading industry
vendors and 47 from academia) participated. The objective
for the teams was to detect as many RTL bugs as possi-
ble from those we injected deliberately in real-world open-
source SoC designs (see Table 1). This is designed to mimic
real-world bug bounty programs from semiconductor com-
panies [17, 32, 62, 63]. The teams were free to use any tech-
niques: simulation, manual inspection, or formal veriﬁcation.
5.1 Competition Preparation
RTL of open-source RISC-V SoCs was used as the testbed
for Hack@DAC and our investigation. Although these SoCs
are less complex than high-end industry proprietary designs,
this allows us to feasibly inject (and detect) bugs into less
complex RTL. Thus, this represents the best-case results for
the veriﬁcation techniques used during Hack@DAC and our
investigation. Moreover, it allows us to open-source and show-
case our testbed and bugs to the community.Hack@DAC con-
sisted of two phases: a preliminary Phase 1 and ﬁnal Phase 2,
which featured the RISC-V Pulpino and PULPissimo SoCs,
4http://www.marketwired.com/press-release/jasper-
introduces-intelligent-proof-kits-faster-more-accurate-
verification-soc-interface-1368721.htm
respectively. Phase 1 was conducted remotely over a two-
month period. Phase 2 was conducted in an 8-hour time frame
co-located with DAC (Design Automation Conference).
For Phase 1, we chose the Pulpino [60] SoC since it was
a real-world, yet not an overly complex SoC design for the
teams to work with. It features a RISC-V core with instruction
and data RAM, an AXI interconnect for accessing memory,
with peripherals on an APB accessing the AXI through a
bridge module. It also features a boot ROM, a debug unit and
a serial peripheral interface (SPI) slave. We inserted security
bugs in multiples modules of the SoC, including the AXI,
APB, debug unit, GPIO, and bridge.
For Phase 2, we chose the more complex PULPissimo [61]
SoC, shown in Figure 2. It additionally supports hardware pro-
cessing engines, DMA, and more peripherals. This allowed us
to extend the SoC with additional security features, making
room for additional bugs. Some native security bugs were dis-
covered by the teams and were reported to the SoC designers.
5.2 Competition Objectives
For Hack@DAC, we ﬁrst implemented additional security
features in the SoC, then deﬁned the security objectives and
adversary model and accordingly inserted the bugs. Specify-
ing the security goals and the adversary model allows teams to
deﬁne what constitutes a security bug. Teams had to provide
a bug description, location of RTL ﬁle, code reference, the se-
curity impact, adversary proﬁle, and the proposed mitigation.
Security Features: We added password-based locks on the
JTAG modules of both SoCs and access control on certain
peripherals. For the Phase-2 SoC, we also added a crypto-
graphic unit implementing multiple cryptographic algorithms.
We injected bugs into these features and native features to
generate security threats as a result.
Security Goals: We provided the three main security goals
for the target SoCs to the teams. Firstly, unprivileged code
should not escalate beyond its privilege level. Secondly, the
JTAG module should be protected against an adversary with
physical access. Finally, the SoCs should thwart software
adversaries from launching denial-of-service attacks.
5.3 Overview of Competition Bugs
As described earlier in Section 3.2, the bugs were selected
and injected together with our Intel collaborators. They are
inspired by their hardware security expertise and real-world
CVEs (cf. Table 1) and aim to achieve coverage of different
security-relevant components of the SoC. Several participants
also reported a number of native bugs already present in the
SoC that we did not deliberately inject. We describe below
some of the most interesting bugs.
UDMA address range overlap: We modiﬁed the memory
address range of the UDMA so that it overlaps with the master
port to the SPI. This bug allows an adversary with access to
220    28th USENIX Security Symposium
USENIX Association
the UMDA memory to escalate its privileges and modify the
SPI memory. This bug is an example of the "Memory Address
Range Overlap" HardFail type in Section 4. Other address
range conﬁguration bugs (#1, 2, 6 and 8) were also injected
in the APB bus for different peripherals.
GPIO errors: The address range of the GPIO memory was
erroneously declared. An adversary with GPIO access can
escalate its privilege and access the SPI Master and SoC Con-
trol. The GPIO enable was rigged to display a ﬁxed erroneous
status of ’1’, which did not give the user a correct display of
the actual GPIO status. The GPIO lock control register was
made write-accessible by user-space code, and it was ﬂawed
to clear at reset. Bugs #4, 5, 24 and 31 are such examples.
Debug/JTAG errors: The password-checking logic in the
debug unit was ﬂawed and its state was not being correctly
reset after a successful check. We hard-coded the debug unit
password, and the JTAG interface was not password protected.
Bugs #9, 10, 11, 16, 26, and 28 are such examples.
Untrusted boot ROM: A native bug (bug #22) would allow
unprivileged compromise of the boot ROM and potentially
the execution of untrusted boot code at a privileged level, thus