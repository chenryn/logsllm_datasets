May 16 22:14:49 : root : TTY=pts/1 ; PWD=/root ; USER=root ;
COMMAND=list
Feb 22 22:35:43 : softadm : TTY=pts/11 ; PWD=/home/softadm ; USER=root ;
COMMAND=/bin/systemctl status httpd
3 案例3：提高SSH服务安全
3.1 问题
本案例要求提高Linux主机上SSH服务端的安全性，完成以下任务：
配置基本安全策略（禁止root、禁止空口令）
针对SSH访问采用仅允许的策略，未明确列出的用户一概拒绝登录
实现密钥验证登录（私钥口令）、免密码登入
确认密钥验证使用正常后，禁用口令验证
3.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：配置基本安全策略
1）调整sshd服务配置，并重载服务
\[root@proxy \~\]# vim /etc/ssh/sshd_config
.. ..
Protocol 2 //SSH协议
PermitRootLogin no //禁止root用户登录
PermitEmptyPasswords no //禁止密码为空的用户登录
UseDNS no //不解析客户机地址
LoginGraceTime 1m //登录限时
MaxAuthTries 3 //每连接最多认证次数
.. ..
\[root@proxy \~\]# systemctl restart sshd
2）测试基本安全策略
尝试以root用户SSH登录，失败：
\[root@proxy \~\]# ssh root@192.168.4.5
root@192.168.4.5\'s password:
Permission denied, please try again.
将服务器上用户kate(如无该账户则先创建)的密码设为空，尝试SSH登录，也会失败：
\[root@proxy \~\]# passwd -d kate //清空用户口令
清除用户的密码 kate。
passwd: 操作成功
\[root@proxy \~\]# ssh kate@192.168.4.5
kate@192.168.4.5\'s password:
Permission denied, please try again.
步骤二：针对SSH访问采用仅允许的策略，未明确列出的用户一概拒绝登录
1）调整sshd服务配置，添加AllowUsers策略，仅允许用户zhangsan、tom、useradm，其中useradm只能从网段192.168.4.0/24登录。
注意：如果没有这些用户，需要提前创建用户并设置密码。
\[root@proxy \~\]# vim /etc/ssh/sshd_config
.. ..
AllowUsers zhangsan tom useradm@192.168.4.0/24 //定义账户白名单
##DenyUsers USER1 USER2 //定义账户黑名单
##DenyGroups GROUP1 GROUP2 //定义组黑名单
##AllowGroups GROUP1 GROUP2 //定义组白名单
\[root@proxy \~\]# systemctl restart sshd
2）验证SSH访问控制，未授权的用户将拒绝登录。
\[root@proxy \~\]# ssh useradm@192.168.4.5 //已授权的用户允许登录
useradm@192.168.4.5\'s password:
\[useradm@proxy \~\]\$ exit
\[root@proxy \~\]# ssh root@192.168.4.5 //未授权的用户被拒绝登录
root@192.168.4.5\'s password:
Permission denied, please try again.
步骤三：实现密钥对验证登录（私钥口令）、免密码登入
1）准备客户机测试环境
为客户机的用户root建立SSH密钥对
使用ssh-keygen创建密钥对，将私钥口令设为空（直接回车）：
\[root@client \~\]\$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):
Created directory \'/root/.ssh\'.
Enter passphrase (empty for no passphrase): //直接回车将口令设为空
Enter same passphrase again: //再次回车确认
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
63:6e:cf:45:f0:56:e2:89:6f:62:64:5a:5e:fd:68:d2
The key\'s randomart image is:
+\--\[ RSA 2048\]\-\-\--+
\| \|
\| \|
\| . . . \|
\| = = \|
\| S = B . \|
\| o B = . o \|
\| + + = E .\|
\| . + + o \|
\| o \|
+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--+
\[root@client \~\]\$ ls -lh \~/.ssh/id_rsa\* //确认密钥对文件
-rw\-\-\-\-\-\--. 1 root root 1.8K 8月 15 10:35 /root/.ssh/id_rsa
-rw-r\--r\--. 1 root root 403 8月 15 10:35 /root/.ssh/id_rsa.pub
2）将客户机上用户root的公钥部署到SSH服务器
以用户root登入客户机，使用ssh-copy-id命令将自己的公钥部署到服务器：
\[root@client \~\]\$ ssh-copy-id root@192.168.4.5
root@192.168.4.5\'s password:
Now try logging into the machine, with \"ssh \'root@192.168.4.5\'\", and
check in:
.ssh/authorized_keys
to make sure we haven\'t added extra keys that you weren\'t expecting.
3）在服务器上确认客户机用户root上传的公钥信息
默认部署位置为目标用户的家目录下 \~/.ssh/authorized_keys文件：
\[root@proxy \~\]# tail -2 \~/.ssh/authorized_keys
ssh-rsa
AAAAB3NzaC1yc2EAAAABIwAAAQEAzz+5AiFMGQ7LfuiV7eBnOcmRO9JRTcqRoynGO2y5
RyFL+LxR1IpEbkNrUyIZDk5uaX1Y8rwsf+pa7UZ2NyqmUEvNSUo0hQyDGsU9SPyAdzRCCvDgwpOFhaHi/OFnT+zqjAqXH2M9fFYEVUU4PIVL8HT19zCQRVZ/q3acQA34UsQUR0PpLJAobsf1BLe2EDM8BsSHckDGsNoDT9vk+u3e83RaehBMuy1cVEN5sLAaIrIeyM8Q0WxQNlqknL908HRkTlTeKrRoHbMnOBFj8StwlnscKHlkrsKkhUf8A9WWz/vL4GDwGND5jdca3I2hdITAySjMdfL1HMHnMYOgMjPM0Q==
PI:EMAIL
4）在客户机上测试SSH密钥对验证
在客户机用户root的环境中，以远程用户root登入192.168.4.5主机时，无需验证口令即可登入（因为私钥口令为空）：
\[root@client \~\]\$ ssh root@192.168.4.5 //免交互直接登入
Last login: Thu Aug 15 10:48:09 2013 from 192.168.4.100
步骤四：确认密钥验证使用正常后，禁用口令验证
1）调整sshd服务配置，将PasswordAuthentication设为no
\[root@proxy \~\]# vim /etc/ssh/sshd_config
.. ..
PasswordAuthentication no //将此行yes改成no
\[root@proxy \~\]# systemctl restart sshd
4 案例4：SELinux安全防护
4.1 问题
本案例要求熟悉SELinux防护机制的开关及策略配置，完成以下任务：
将Linux服务器的SELinux设为enforcing强制模式
从/root目录下移动一个包文件到FTP下载目录，调整策略使其能够被下载
4.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：将Linux服务器的SELinux设为enforcing强制模式
1）固定配置：修改/etc/selinux/config文件
确认或修改SELINUX为enforcing模式：
\[root@proxy \~\]# vim /etc/selinux/config
SELINUX=enforcing //设置SELinux为强制模式
SELINUXTYPE=targeted //保护策略为保护主要的网络服务安全
2）临时配置：使用setenforce命令
查看当前SELinux状态，如果是disabled则需要根据第1）步的配置重启系统；如果是permissive则使用setenforce命令修改为enforcing即可：
\[root@proxy \~\]# getenforce //查看当前状态为警告模式
Permissive
\[root@proxy \~\]# setenforce 1 //设置SELinux为强制模式
\[root@proxy \~\]# getenforce //查看当前模式为强制模式
Enforcing
\[root@proxy \~\]# setenforce 0 //设置SELinux为强制模式
\[root@proxy \~\]# getenforce //查看当前模式为警告模式
Permissive
步骤二：在SELinux启用状态下，调整策略打开vsftpd服务的匿名上传访问
1）配置一个允许匿名上传的vsftpd服务作为测试环境
\[root@proxy \~\]# setenforce 1
\[root@proxy \~\]# yum -y install vsftpd
.. ..
\[root@proxy \~\]# vim /etc/vsftpd/vsftpd.conf
anonymous_enable=YES //开启匿名访问
anon_upload_enable=YES //允许上传文件
anon_mkdir_write_enable=YES //允许上传目录
\[root@proxy \~\]# systemctl start vsftpd //启动服务
//默认Vsftpd共享目录为/var/ftp/
步骤三：从/root目录下移动2个包文件到FTP下载目录，调整文件的安全上下文
1）建立两个FTP下载用的测试文件
由root用户创建两个测试压缩包，一个直接建立到/var/ftp/目录下，另一个先在/root/下建立，然后移动至/var/ftp/目录。
//测试文件1，直接在ftp目录下创建文件
\[root@proxy \~\]# tar -czf /var/ftp/log1.tar /var/log
\[root@proxy \~\]# ls -lh /var/ftp/
-rw-r\--r\--. 1 root root 8M 8月 16 10:16 log1.tar
\[root@proxy \~\]# ls -Z /var/ftp/
-rw-r\--r\--. root root unconfined_u:object_r:public_content_t:s0
log1.tar
//测试文件2，在/root下建立，然后移动至/var/ftp目录
\[root@proxy \~\]# tar -czf log2.tar /var/log
\[root@proxy \~\]# mv log2.tar /var/ftp/
\[root@proxy \~\]# ls -lh /var/ftp/
-rw-r\--r\--. 1 root root 8M 8月 16 10:16 log2.tar
\[root@proxy \~\]# ls -Z /var/ftp/
-rw-r\--r\--. 1 root root unconfined_u:object_r:admin_home_t:s0 log2.tar
3）通过FTP方式测试下载
使用wget命令分别下载这两个包文件，第二个包将会下载失败（看不到文件）。
\[root@proxy \~\]# wget ftp://192.168.4.5/log1.tar
//下载第一个文件，成功
\[root@proxy \~\]# wget ftp://192.168.4.5/log2.tar
//下载第二个文件，失败
4）检查该测试包的安全上下文，正确调整后再次下载第二个包成功。
文件已经存放到共享目录下，但客户端无法访问下载，是因为被SELinux拦截了！
\[root@proxy \~\]# ls -Z /var/ftp/
-rw-r\--r\--. root root unconfined_u:object_r:public_content_t:s0
log1.tar
-rw-r\--r\--. 1 root root unconfined_u:object_r:admin_home_t:s0 log2.tar
\[root@proxy \~\]# chcon -t public_content_t /var/ftp/d2.tar.gz
\[root@proxy \~\]# ls -Z /var/ftp/log2.tar
-rw-r\--r\--. root root unconfined_u:object_r:public_content_t:s0
log2.tar
\[root@proxy \~\]# wget ftp://192.168.4.5/log2.tar //再次下载，成功
注意：上例中的chcon操作可替换为（效果相同）：
\# restorecon /var/ftp/log2.tar.gz
或者
\# chcon \--reference=/var/ftp/log1.tar.gz /var/ftp/log2.tar.gz
# NSD SECURITY DAY02
# 1加密与解密
加解密概述
发送方加密
接收方解密
**对称加密:**
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。
常用的算法有：
DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK等。
**非对称加密:**
非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
常用算法:
RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。
# 2 MD5完整性检验
![20170627153441520](media/image2.jpeg){width="5.759027777777778in"
height="2.558333333333333in"}
# 3 GPG加/解密工具
GnuPG 软件（简称 GPG），它是目前最流行、最好用的加密工具之一。
## GPG命令集:
\]# gpg \--version
\]# gpg \--help
**对称加密命令:**
\]\$ gpg -c a.txt
\]\$ gpg -d a.txt.gpg \>a.txt
**非对称加密命令:**
\]\$ gpg \--gen-key #生成秘钥对
\]\$ gpg -a \--export \>/tmp/userb.pub #导出公钥
\]\$ gpg \--import /tmp/userb.pub #导入公钥
\]\$ gpg -e -r hksbdb test.txt #公钥加密 (hksbdb密码)
\]\$ gpg -d test.txt.gpg \>b.txt #输入密码,进行解密
\[root@room9pc01 \~\]# **gpg \--version**
gpg (GnuPG) 2.0.22
libgcrypt 1.5.3
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later
\
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Home: \~/.gnupg
支持的算法：
公钥：RSA, ?, ?, ELG, DSA
对称加密：IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256,
TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256
散列：MD5, SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224
压缩：不压缩, ZIP, ZLIB, BZIP2
\[root@room9pc01 \~\]# gpg \--help
## 对称加/解密方式：
1、实用gpg完成文件加密