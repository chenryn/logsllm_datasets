r ∈ response(x, y).
2.2 Threat Model and Security Deﬁnition
We consider an eavesdropping adversary who can eaves-
drop on the communications between User and Server, i.e.,
recording the challenges, the responses sent by the user, and
the result of whether the responses are correct or not. In
this paper, we limit ourselves to an eavesdropping adversary
because an eavesdropping adversary is suﬃcient for breaking
the security of the concrete SVAPs we discuss here. The ob-
jective of the attacker is to successfully impersonate a user,
by correctly answering the challenges in one session, without
possessing the secret key. We adapt the security deﬁnition
from [25] as follows.
Definition 1
(((cid:96), p)-break). We say that an algo-
rithm ((cid:96), p)-breaks an SVAP if and only if when given (cid:96) match-
ing challenge-response pairs and an additional challenge, the
algorithm’s response to the additional challenge is accepted
with probability p on average.
no digitdigit: 2digit: 2123456710111011234567001101012345671011101keychallengewhat user seesframe 3: Pframe 4: 8frame 5: 5frame 6: 9frame 7: 6position 2......605If an SVAP is (0, p) breakable, then an adversary without
eavesdropping ability can impersonate a user with proba-
bility p on average in one attempt. When p is above some
acceptable threshold, this implies that the protocol is ex-
tremely insecure.
3. DESIGN OF SVAPS
We now present two classes of concrete SVAPs which we
call the uni-symbol SVAPs and multi-symbol SVAPs. We as-
sume seven-segment LED-style images for displaying digits
are used, as in PassWindow.
3.1 Uni-Symbol SVAPs
In this class of protocols, each frame shows at most one
symbol. We categorize these protocols along three design
dimensions.
3.1.1 Design Dimensions
1. Noisy Frames or Not. In PassWindow, each authen-
tication session consists of α = 15 frames; however, only
4 of them displays a digit, and the 4-digit sequence is the
response. These 15 frames are displayed in an animation
where each frame displays for around 2 seconds. The an-
imated image loops back to the ﬁrst challenge frame after
the last frame is displayed. A frame encoding the symbol
P alerts the users that the next 4 frames encode the digits.
The other 10 frames do not display any digit and are known
as noisy frames.
We call this design the NSD (for Noisy-frame Single
Digit) scheme, and the other design that does not use noisy
frames and simply shows 4 digit-encoding frames with the
response being the corresponding 4-digit sequence the BSD
(for Basic Single Digit) scheme. In BSD, the 4 challenge
frames can be shown one by one, with each new frame dis-
played after another digit is entered. This way, users can
respond at their pace.
The use of noisy frames aims at increasing the uncertainty
for the adversary regarding which frames encode which sym-
bols. It comes at the usability cost of increasing the time
it takes to complete an authentication session and is likely
to introduce some stress since users need to decode visually
under time pressure. In Section 6 we shall show that using
noisy frames decreases the level of security since the noisy
frames leak additional information.
2. Key and Challenge Generation Algorithms. We
consider two kinds of generation algorithms.
In the ﬁrst
kind, keys and challenges are generated by randomly decid-
ing whether each segment should be turned on or oﬀ. In the
next kind, keys and challenges are generated by randomly
selecting a 7-segment pattern for each position.
In both
cases, additional checks are needed to ensure that the key
does not already encode a digit, and the challenges when
overlaid with the key, resulting in acceptable images (e.g.,
not encoding two digits in one frame). In this paper, unless
explicitly mentioned, the protocols use a random pattern-
based algorithms.
3. Shared Edges or Separate Columns. In PassWin-
dow, the two adjacent 7-segment positions share a common
vertical edge; we call this design Shared Edges (SE, see See
Figure 4). The alternative design is not to use shared edges
(see Figure 1). In this paper, unless explicitly mentioned,
the protocols do not use shared edges.
As will be shown in the experiment (Section 6), we will
show these three choices’ inﬂuence on security one by one.
Here we describe ﬁve concrete schemes. They each diﬀer
from its previous one in one dimension. The ﬁrst two use
noisy frames, and the latter three do not.
3.1.2 Protocols
1.
[NSD(7%+SE)] Noisy-frame Single Digit ran-
domly displaying 7% Shared Edges. The ﬁrst proto-
col we want to evaluate is PassWindow. NSD (7%+SE) mimics
PassWindow by using 15 frames with 10 noisy frames. It uses
random segment generation algorithms (which produce key
and challenge with a density close to the PassWindow exam-
ples that are publicly available [4, 1]), noisy frames, and
shared edges. Speciﬁcally, the generation algorithms are as
follows:
keyGen. Segments are turned on randomly with a probability
of 25%; further check ensures that no position in the key
displays any symbol.
challengeGen. One ﬁrst chooses a random symbol σ from Σ,
then randomly selects a position p in the challenge frame and
then turns segments in position p on so that σ is displayed in
position p when combined with the key. For the other non-
encoding positions, the segments are turned on randomly
such that the challenge frame has a density of about 7%.
Further sanity checks ensure that no other position encodes
a symbol when overlaid with the key.
[NSD(20%+SE)] Noisy-frame Single Digit ran-
2.
domly displaying 20% Shared Edges. This protocol is
motivated by the observation (from experiments) that chal-
lenge frames in NSD (7%+SE) have limited entropy since the
position on the challenge frame with the most number of
segments turned on is almost certainly the one encoding the
digit. To mitigate this, NSD (20%+SE) displays 20% segments
on the challenge frame.
3. [BSD(20%+SE)] Basic Single Digit randomly dis-
playing 20% Shared Edges. This protocol diﬀers from
NSD (20%+SE) in that it does not use any noisy frame. There-
fore α = 4.
4. [BSD(20%)] Basic Single Digit randomly display-
ing 20% non-shared edges. This protocol diﬀers from
BSD (20%+SE)in that no shared edge is used.
5.
[BSD] Basic Single Digit randomly displaying
valid patterns. BSD diﬀers from BSD (20%)in that the gen-
eration algorithms are based on randomly choosing a pat-
tern, as follows:
keyGen. A valid key pattern is any seven-segment pattern
such that it has between 1 and 6 segments that are turned
on, and it does not display any digit. For each position of
the key, randomly choose a valid key pattern.
challengeGen. A challenge is generated using the following
steps: (1) Randomly choose 4 symbols and 4 patterns such
that each pattern is compatible with at least 3 of the chosen
symbols. A challenge pattern is compatible with a symbol
if there exists a valid key pattern that displays the symbol
when overlaid with the challenge. This step aims to ensure
that even if the symbol is known, there are at least 3 possi-
bilities for its position. (2) Place these 4 patterns randomly
in 4 positions of the frame such that only one position dis-
606plays a symbol when combined with the key. The segments
in all other positions of the challenge frame are oﬀ. This step
is intended to minimize the amount of information leakage,
and will be explained later.
3.2 Multi-Symbol SVAPs
Section 6 demonstrates a fundamental weakness of uni-
symbol SVAPs. The information that a frame displays a par-
ticular symbol entails that all other symbols are not dis-
played at any position. To defeat attacks exploiting this
insight, we introduce multi-symbol SVAPs, where each chal-
lenge frame can generate more than one digit.
We give three concrete protocols, they all use the same
keyGen as in BSD, which is more secure than ones based on
random segments.
1.
[HDD] Hashing-based Double Digit. In HDD, each
challenge frame generates two digits d1 and d2. The corre-
sponding response is the one’s digit of the sum of d1 and d2,
which can be viewed as a simple human computable hashing
function: (d1 + d2) mod 10. This scheme makes it more dif-
ﬁcult to rule out which digit is not displayed when knowing
the response digit. However, because 1 is never displayed,
this protocol still leaks some deterministic information. For
example, if 9 is the response digit, then 8 cannot be displayed
since it would require an 1 to result in 9.
challengeGen. Randomly choose 2 − 9 positions in the chal-
lenge frame and randomly choose the same number of valid
patterns to show in those positions in the following way: (a)
every digit in Σ is compatible with at least 2 patterns; (b)
when combined with the key only 2 of the challenge positions
display digits.
2. [HTD] Hashing-based Triple Digit. HTD eliminates
deterministic leakage of HDD by having each frame display
three digits d1, d2, and d3. The response is the one’s digit
of the sum of d1, d2, and d3, that is: (d1 + d2 + d3) mod 10.
This scheme requires more computation than other schemes,
which may lead to worse usability. The challengeGen for HTD
is similar to HDD, except that each frame in HTD displays 3
digits instead of 2.
3.
[EDD] Either of Double Digit. EDD prevents the
deterministic leakage of BSD without resorting to arithmetic.
A challenge frame superimposed by the visual key induces
two digits d1 and d2; however, instead of responding with
d1 + d2 mod 10, one is asked to respond with either d1 or
d2. This reduces the entropy of each frame by one bit, but
when observing one digit being the response code, any other
digit could still be displayed.
4. BREAKING UNI-SYMBOL SVAPS
We now present Search, an attack against single-symbol
SVAPs. For ease of description, we assume that each posi-
tion that can display a symbol which consists of 7 segments.
The attack equally applies to other settings. The attack
is based on the idea that after observing each successful
authentication session, one can eliminate the keys that are
incompatible with the transcript.
Definition 2
(Compatibility). Given an SVAP AV =
(cid:104)PV, α, λ, keyGen, challengeGen, response(cid:105), and a transcript
of (cid:96) successful authentications, (cid:104)Y = (cid:104)y1, . . . , y(cid:96)(cid:105), R =
(cid:104)r, . . . , r(cid:96)(cid:105)(cid:105), we say that a key x is compatible with the
if and only if ∀i ∈ {1, . . . , (cid:96)}, ri ∈
transcript (Y, R),
response(x, yi).
4.1 Key Universe Representation
One straightforward way to exploit compatibility is to ex-
plicitly maintain the set of all keys that are compatible with
the transcript seen so far. This requires maintaining one
bit for each possible key (whether it is compatible with the
transcript), and is infeasible as the resulting state size will
be linear in the size of the key space (e.g., for NSD (7%+SE),
this is approximately 25λ+2, which is 277 when λ = 15).
Thus the ﬁrst major challenge to exploit compatibility
is to decide how to represent the knowledge about the set
of plausible keys. A natural approach is to maintain for
each segment, whether it must be “on”, must be “oﬀ”, or
is uncertain. Using 2 bits for each segment, this requires
2 × (5λ + 2) bits for NSD (7%+SE), which is 144 bits when
λ = 15. However, this fails to capture information regarding
the inter-relationship among segments. Suppose that from
a challenge/response pair, one can conclude that one of two
segments must be oﬀ (since otherwise it can be decoded into
a diﬀerent response); however, when one maintains informa-
tion about segment independently, one can only record that
this information.
Our solution exploits the structured and segmented nature
of SVAPs. We maintain information regarding each position
consisting of 7 segments. For a 7-segment position, there are
128 patterns, and we use one bit for each pattern, indicat-
ing whether this pattern is plausible in this position. This
requires a total space of 128λ bits, which is 1920 bits when
λ = 15.
More speciﬁcally, we maintain the global plausible pat-
tern set K = (cid:104)Π1, Π2, . . . , Πλ(cid:105), where Πi : {0, 1}7 → {0, 1}
gives the set of compatible patterns in the i’th position.
The downside of K, of course, is that such a representa-
tion loses inter-position information (e.g., if this position
takes this pattern, then another position cannot be that
pattern). However, such information is still preserved in the
transcript, and can be dynamically exploited by searching,
as we explain below.
4.2 Deterministic Reduction of Key Universe
The critical step in breaking an SVAP using searching is to
reduce the global plausible pattern set K = (cid:104)Π1, Π2, . . . , Πλ(cid:105);
this requires deﬁnite knowledge regarding each position.
This led us to discover a fundamental weakness of uni-
symbol SVAPs: Every challenge-response pair leaks deter-
ministic information. For example, knowing that a frame
encodes the digit 4 means that one knows for certain that
none of the other digits is encoded in any position, even if
one does not know where 4 occurs. Thus, using the challenge
pattern at each position, one could reduce the Πi’s.
Because of such information leakage, the random pattern
challenge generation algorithm we introduced for BSD uses
empty positions in the challenge whenever possible. A few
positions must be non-empty, to provide some uncertainty
as to where a response digit is displayed. However, each
new challenge pattern that appears in a position enables
one to eliminate key patterns that when combined with the
challenge pattern would display digits not in the response.
4.3 Search Trees
While the deterministic information can help prune the
607global plausible pattern set K, combining that with search-
ing can help further reﬁne K. The key challenge is to limit
the total space consumed by the search trees to be below
the available resources.
Conceptually, we construct one search tree for each ses-
sion. For each session, there are a number of choices. For
example, for protocols that use noisy frames, the ﬁrst choice
is which frame is the ﬁrst frame that encodes a symbol. In
addition, for each such frame, there is a choice on which
position displays a symbol. In each node n, we store Kn, a
set of plausible keys consistent with choices made to reach
that node. The root node uses the global plausible pattern
set K. Each node starts with the set from its parent, and
uses the current choice made to create the current node to
eliminate keys that are incompatible with this choice. For
example, against NSD schemes, once we have made a choice
about which one among the α = 15 frames displays P , we
know which symbol (if any) each frame encodes; this can
be used to reduce Kn. If a node has Kn = (cid:104)Πn
λ(cid:105)
2 , . . . , Πn
i = ∅, we know the current
such that one of its component Πn
choice is inconsistent with the transcript, as no key pattern
can be used on the i’th position; thus the node can be re-
moved from the tree.
1 , Πn
We construct a tree by maintaining a queue of the frontier
nodes to be expanded. To avoid exhaust the memory, we
will expand a tree only when its frontier consists of no more
than N nodes, where N is set to 1000 in our experiments.
Whenever we expand a node (i.e., making another guess),
we simultaneously add all the children nodes into the search
tree. We know that one of the node in the frontier must be
the correct one; however, we do not know which one it is.
Let F be the forest consisting of all trees. For each tree