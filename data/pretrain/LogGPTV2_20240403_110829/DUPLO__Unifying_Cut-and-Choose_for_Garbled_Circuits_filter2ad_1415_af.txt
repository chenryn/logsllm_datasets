â„))
The full garbling procedure can be obtained by composing
the above functions. On input a circuit ğ¶ and a boolean
vector ğ‘¥, it picks random labels for the input wires using
ğ™»ğšŠğš‹ğšğš•, calls ğ™¶ğš‹ to generate a garbled circuit
Ìƒğ¶ and output
labels, and then calls ğ™¶ğ™´ğš—ğšŒ and ğ™¶ğ™¼ğšŠğšœğš” to produce a garbled
input Ìƒğ‘¥. Note that the second parameter of ğ™¶ğ™´ğš—ğšŒ is a bundle of
bits rather than a boolean vector. In the deï¬nition of ğ™¶ğšŠğš›ğš‹ğš•ğš
below we slightly abuse notation and use ğ‘¥ to denote a bundle
of bits ğ‘¥1, â€¦ , ğ‘¥ğ‘› of a suitable shape, which can be eï¬ƒciently
constructed from ğ‘¥ and ğ‘ .
ğ™¶ğšŠğš›ğš‹ğš•ğš :: Circuit(ğ‘ , ğ‘¡) Ã— {0, 1}ğ‘› â†’ ğ„ğ±ğ©
ğ™¶ğšŠğš›ğš‹ğš•ğš(ğ¶, ğ‘¥) = ( Ìƒğ¶, Ìƒğ‘¥) where
ğ‘¢ â† ğ™»ğšŠğš‹ğšğš•(ğ‘ )
Ìƒğ¶, ğ‘£ = ğ™¶ğš‹(ğ¶, ğ‘¢)
Ìƒğ‘¥ = (ğ™¶ğ™´ğš—ğšŒ(ğ‘¢, ğ‘¥), ğ™¶ğ™¼ğšŠğšœğš”(ğ‘£))
Next, we consider the garbled circuit evaluation algorithm
ğ™¶ğ™´ğšŸğšŠğš•. The core part of ğ™¶ğ™´ğšŸğšŠğš• is a recursive function ğ™¶ğ™´ğšŸ
that takes a garbled circuit and an encoded input expression,
producing an encoded output expression. Any encoded output
is also an encoded input for evaluating subsequent garbled
circuits. We include a circuit as another input of ğ™¶ğ™´ğšŸ, which
is used to determine the shapes of output wires. Ideally we
can use the circuitâ€™s topology instead, but for simplicity we
just use the circuit itself and we do not exploit the function
computed by a circuit.
ğ™¶ğ™´ğšŸ âˆ¶âˆ¶ Circuit(ğ‘ , ğ‘¡) Ã— ğ„ğ±ğ© Ã— ğ„ğ±ğ© â†’ ğ„ğ±ğ©
ğ™¶ğ™´ğšŸ(ğ’ğ°ğšğ©, ğœ–, (ğ‘¢, ğ‘£)) = (ğ‘£, ğ‘¢)
ğ™¶ğ™´ğšŸ(ğ€ğ¬ğ¬ğ¨ğœ, ğœ–, (ğ‘¢, (ğ‘£, ğ‘¤)) = ((ğ‘¢, ğ‘£), ğ‘¤)
ğ™¶ğ™´ğšŸ(ğ”ğ§ğšğ¬ğ¬ğ¨ğœ, ğœ–, (ğ‘¢, (ğ‘£, ğ‘¤)) = ((ğ‘¢, ğ‘£), ğ‘¤)
ğ™¶ğ™´ğšŸ(ğƒğ®ğ©, ğœ–, (ğ‘, ğ‘˜) = ((ğ‘, ğ–¦0(ğ‘˜)), (ğ‘, ğ–¦1(ğ‘˜)))
ğ™¶ğ™´ğšŸ(ğğ€ğ§ğ, Ìƒğ¶, ((ğ‘â€²
0
, ğ‘˜0), (ğ‘â€²
1
, ğ‘˜1))) = (ğ‘, ğ‘˜) where
ğœ‹[ğ‘0](ğ‘Ÿ0, ğ‘Ÿ1) = Ìƒğ¶
ğœ‹[ğ‘1](ğ‘’0, ğ‘’1) = if ğ‘â€²
â¦ƒâ¦ƒ(ğ‘, ğ‘˜)â¦„ğ‘˜1
â¦„ğ‘˜0 = if ğ‘â€²
0 â‰¡ ğ‘0 then ğ‘Ÿ0 else ğ‘Ÿ1
1 â‰¡ ğ‘1 then ğ‘’0 else ğ‘’1
ğ™¶ğ™´ğšŸ(ğ¶0 â‹™ ğ¶1, ( Ìƒğ¶0, Ìƒğ¶1), ğ‘¢) = ğ™¶ğ™´ğšŸ(ğ¶1, Ìƒğ¶1, ğ‘¤) where
ğ™¶ğ™´ğšŸ(ğ…ğ¢ğ«ğ¬ğ­(ğ¶), Ìƒğ¶, (ğ‘¢, ğ‘¤)) = (ğ‘£, ğ‘¤) where
ğ‘¤ = ğ™¶ğ™´ğšŸ(ğ¶0, Ìƒğ¶0, ğ‘¢)
ğ‘£ = ğ™¶ğ™´ğšŸ(ğ¶, Ìƒğ¶, ğ‘¢)
We brieï¬‚y explain how ğ™¶ğ™´ğšŸ works. For the basic circuits
ğ’ğ°ğšğ©, ğ€ğ¬ğ¬ğ¨ğœ, ğ”ğ§ğšğ¬ğ¬ğ¨ğœ, and ğƒğ®ğ© whose corresponding gar-
bled circuits are ğœ–, it simply rearranges the bits and keys in
the encoded input to form an encoded output, except for ğƒğ®ğ©
where it generates and then splits a pseudo-random key in
the encoded output. For ğğ€ğ§ğ, it parses the corresponding
garbled circuit as permutations controlled by atomic bits ğ‘0, ğ‘1,
and it selects the entry corresponding to the bits ğ‘â€²
1. In
0
the above deï¬nition, we use pattern matching syntax that is
Ìƒğ¶
usually found in functional programming languages to parse
and select the subexpression â¦ƒâ¦ƒ(ğ‘, ğ‘˜)â¦„ğ‘˜1
â¦„ğ‘˜0 . One can verify
ğ‘– âˆˆ {ğ‘ğ‘–, Â¬ğ‘ğ‘–} and the entry selected using bits ğ‘â€²
0
, ğ‘˜ğ‘–) is in the encoded input to ğğ€ğ§ğ for ğ‘– âˆˆ {0, 1},
that, if (ğ‘â€²
then ğ‘â€²
1 are
doubly encrypted under keys ğ‘˜0,ğ‘˜1. So the expression (ğ‘, ğ‘˜)
extracted by ğ™¶ğ™´ğšŸ is well-deï¬ned. For the composite circuits
ğ¶0 â‹™ ğ¶1 and ğ…ğ¢ğ«ğ¬ğ­(ğ¶), ğ™¶ğ™´ğšŸ produces an encoded output
expression recursively in a way similar to how ğ„ğ¯ evaluates
these circuits.
Notice that the output of ğ™¶ğ™´ğšŸ are bit symbols rather than
boolean values. The function ğ™³ğšğšŒğš˜ğšğš uses the output masks
to decode a garbled output into a boolean vector:
, ğ‘â€²
, ğ‘â€²
ğ‘–
ğ™³ğšğšŒğš˜ğšğš((ğ‘, ğ‘˜), ğ‘â€²) = if ğ‘ â‰¡ ğ‘â€² then 0 else 1
ğ™³ğšğšŒğš˜ğšğš((ğ‘¢0, ğ‘¢1), (ğ‘‘0, ğ‘‘1)) = (ğ™³ğšğšŒğš˜ğšğš(ğ‘¢0, ğ‘‘0), ğ™³ğšğšŒğš˜ğšğš(ğ‘¢1, ğ‘‘1))
Finally, the full evaluation algorithm ğ™¶ğ™´ğšŸğšŠğš• is deï¬ned as4:
ğ™¶ğ™´ğšŸğšŠğš• âˆ¶âˆ¶ Circuit(ğ‘ , ğ‘¡) Ã— ğ„ğ±ğ© Ã— ğ„ğ±ğ© â†’ {0, 1}ğ‘›
ğ™¶ğ™´ğšŸğšŠğš•(ğ¶, Ìƒğ¶, Ìƒğ‘¥) = ğ™³ğšğšŒğš˜ğšğš(ğ™¶ğ™´ğšŸ(ğ¶, Ìƒğ¶, ğ‘¢), ğ‘‘) where
(ğ‘¢, ğ‘‘) = Ìƒğ‘¥
The following theorem shows that our garbling scheme
is correct. Brieï¬‚y speaking, the encoded input expressions
contain the suï¬ƒcient bits and keys to obtain the encoded
output from the garbled circuit expression, and the output
masks provide information for decoding the encoded output.
The formal proof can be found in the full version [35].
Theorem 4. For any circuit ğ¶ âˆˆ Circuit(ğ‘ , ğ‘¡) and any boolean
vector ğ‘¥ of shape ğ‘ , ğ™¶ğ™´ğšŸğšŠğš•(ğ¶, ğ™¶ğšŠğš›ğš‹ğš•ğš(ğ¶, ğ‘¥)) = ğ¶(ğ‘¥).
4Notice that ğ™³ğšğšŒğš˜ğšğš outputs a bundle of bits. Here we slightly abuse
notation and assume a boolean vector can be extracted from a bundle of
bits.
155
V. SYMBOLIC SIMULATION AND PROOF OF SECURITY
In this section we deï¬ne a simulator ğš‚ğš’ğš–ğšğš•ğšŠğšğš(â‹…, â‹…), and
for any circuit ğ¶ and
we then present our proof
the expressions ğ™¶ğšŠğš›ğš‹ğš•ğš(ğ¶, ğ‘¥) and
any boolean vector ğ‘¥,
ğš‚ğš’ğš–ğšğš•ğšŠğšğš(ğ¶, ğ¶(ğ‘¥)) are equivalent up to renaming. Together
with the computational soundness theorem of our symbolic
framework, such proof implies that the garbled circuit scheme
of the previous section is computationally secure.
that,
j) Symbolic simulator: Recall that a simulator must out-
put a symbolic expression that represents a garbled circuit and
a garbled input, and a garbled input consists of an encoded
input and output masks. The simulator has no access to the
circuit input values, so it picks the random bit and the ï¬rst
random key from each label to form the encoded input:
ğš‚ğ™´ğš—ğšŒ((ğ–¡, (ğ–ª0, ğ–ª1))) = (ğ–¡, ğ–ª0)
ğš‚ğ™´ğš—ğšŒ((ğ¿0, ğ¿1)) = (ğš‚ğ™´ğš—ğšŒ(ğ¿0), ğš‚ğ™´ğš—ğšŒ(ğ¿1))
In order to correctly evaluate the simulated garbled circuit
on the simulated garbled input, we adjust the output masks
according to the circuit output value. Given a label expression
and a boolean vector representing the circuit output value, the
function ğš‚ğ™¼ğšŠğšœğš” computes the output masks:
ğš‚ğ™¼ğšŠğšœğš”((ğ–¡, (ğ–ª0, ğ–ª1)), 0) = ğ–¡
ğš‚ğ™¼ğšŠğšœğš”((ğ–¡, (ğ–ª0, ğ–ª1)), 1) = Â¬ğ–¡
ğš‚ğ™¼ğšŠğšœğš”((ğ¿0, ğ¿1), (ğ‘¦0, ğ‘¦1)) = (ğš‚ğ™¼ğšŠğšœğš”(ğ¿0, ğ‘¦0), ğš‚ğ™¼ğšŠğšœğš”(ğ¿1, ğ‘¦1))
The core of our simulator is a recursive function ğš‚ğš’ğš– that
consumes a circuit and a label expression for input wires,
and produces a symbolic expression of the simulated garbled
circuit and a label expression for output wires:
ğš‚ğš’ğš– :: Circuit(ğ‘ , ğ‘¡) Ã— ğ„ğ±ğ© â†’ ğ„ğ±ğ© Ã— ğ„ğ±ğ©
ğš‚ğš’ğš–(ğ’ğ°ğšğ©, (ğ‘¢, ğ‘£)) = ğœ–, (ğ‘£, ğ‘¢)
ğš‚ğš’ğš–(ğ€ğ¬ğ¬ğ¨ğœ, (ğ‘¢, (ğ‘£, ğ‘¤))) = ğœ–, ((ğ‘¢, ğ‘£), ğ‘¤)
ğš‚ğš’ğš–(ğ”ğ§ğšğ¬ğ¬ğ¨ğœ, ((ğ‘¢, ğ‘£), ğ‘¤)) = ğœ–, (ğ‘¢, (ğ‘£, ğ‘¤))
ğš‚ğš’ğš–(ğ¶0 â‹™ ğ¶1, ğ‘¢) = ( Ì‚ğ¶0, Ì‚ğ¶1), ğ‘£ where
Ì‚ğ¶0, ğ‘¤ = ğš‚ğš’ğš–(ğ¶0, ğ‘¢)
Ì‚ğ¶1, ğ‘£ = ğš‚ğš’ğš–(ğ¶1, ğ‘¤)
ğš‚ğš’ğš–(ğ…ğ¢ğ«ğ¬ğ­(ğ¶), (ğ‘¢, ğ‘¤)) = Ì‚ğ¶, (ğ‘£, ğ‘¤) where
ğš‚ğš’ğš–(ğƒğ®ğ©, (ğ‘, (ğ‘˜0, ğ‘˜1))) = ğœ–, ğ‘¤ where
Ì‚ğ¶, ğ‘£ = ğš‚ğš’ğš–(ğ¶, ğ‘¢)
ğ‘¤ = ((ğ‘, (ğ–¦0(ğ‘˜0), ğ–¦0(ğ‘˜1))), (ğ‘, (ğ–¦1(ğ‘˜0), ğ–¦1(ğ‘˜1))))
ğš‚ğš’ğš–(ğğ€ğ§ğ, ((ğ‘ğ‘–, (ğ‘˜0
, ğ‘˜1
ğ‘– )), (ğ‘ğ‘—, (ğ‘˜0
ğ‘—
, ğ‘˜1
ğ‘—)))) = Ì‚ğ¶, ğ‘¤ where
ğ‘–
â„ â† new
Ì‚ğ¶ = ğœ‹[ğ–¡ğ‘–](ğœ‹[ğ–¡ğ‘—](â¦ƒâ¦ƒ(ğ–¡â„, ğ–ª0
â„)â¦„ğ‘˜0
ğœ‹[ğ–¡ğ‘—](â¦ƒâ¦ƒ(ğ–¡â„, ğ–ª0
â„)â¦„ğ‘˜0
ğ‘—
â¦„ğ‘˜0
â¦„ğ‘˜1
ğ‘–
ğ‘–
ğ‘—
,â¦ƒâ¦ƒ(ğ–¡â„, ğ–ª0
â„)â¦„ğ‘˜1
,â¦ƒâ¦ƒ(ğ–¡â„, ğ–ª0
â„)â¦„ğ‘˜1
ğ‘—
ğ‘—
â¦„ğ‘˜0
â¦„ğ‘˜1
ğ‘–
ğ‘–
),
))
ğ‘¤ = (ğ–¡â„, (ğ–ª0
â„
, ğ–ª1
â„))
Notice that, for any circuit ğ¶ and any label expression ğ‘¢, if
Ì‚ğ¶, ğ‘¤ = ğš‚ğš’ğš–(ğ¶, ğ‘¢), then the subscript â„ of
â„ that appears in ( Ìƒğ¶, ğ‘£) and ( Ì‚ğ¶, ğ‘¤)
Ìƒğ¶, ğ‘£ = ğ™¶ğš‹(ğ¶, ğ‘¢) and
any atomic key symbol ğ–ªğ‘–
follows the same ordering.
Our simulator is composed of the above functions. It takes
a circuit ğ¶ and a boolean vector ğ‘¦ as input, and it generates
a simulated garbled circuit using ğš‚ğš’ğš– and a simulated garbled
input using ğš‚ğ™´ğš—ğšŒ and ğš‚ğ™¼ğšŠğšœğš”:
ğš‚ğš’ğš–ğšğš•ğšŠğšğš :: Circuit(ğ‘ , ğ‘¡) Ã— {0, 1}ğ‘š â†’ ğ„ğ±ğ©
ğš‚ğš’ğš–ğšğš•ğšŠğšğš(ğ¶, ğ‘¦) = ( Ì‚ğ¶, Ì‚ğ‘¥) where
ğ‘¢ â† ğ™»ğšŠğš‹ğšğš•(ğ‘ )
Ì‚ğ¶, ğ‘£ = ğš‚ğš’ğš–(ğ¶, ğ‘¢)
Ì‚ğ‘¥ = (ğš‚ğ™´ğš—ğšŒ(ğ‘¢), ğš‚ğ™¼ğšŠğšœğš”(ğ‘£, ğ‘¦))
k) Symbolic proof of security: For this paper we present
a pen-and-paper symbolic security proof, which can also be
adapted to a machine-checked proof using veriï¬cation tools.
For any bit expression ğ‘ âˆˆ ğğšğ­(ğ”¹) and any ğ‘¥ âˆˆ {0, 1}, we
introduce the notation ğ‘âŠ•ğ‘¥
to shorten our proofs:
{
ğ‘âŠ•ğ‘¥ =
ğ‘
Â¬ğ‘
if ğ‘¥ = 0