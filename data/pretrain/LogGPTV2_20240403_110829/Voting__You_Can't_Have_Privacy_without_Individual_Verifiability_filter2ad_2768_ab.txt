Example 2.1. Consider a finite set of candidates C = {a1, . . . , ak}.
In case voters should select between k1 and k2 candidates or vote
blank, we can represent valid votes by vectors representing the
selection of candidates
(cid:40)
v ∈ {0, 1}k | k1 ≤ k
Vk1,k2 =
(cid:41)
vi ≤ k2
i =0
where vblank is the null vector (0, . . . , 0), representing a blank vote.
In a mixnet-based tally, all the individual votes are revealed. Thus
R is the set of multisets of votes in Vk1,k2 and ∗ is the union of
multisets. The corresponding counting function is ρmix(V) = V ,
where V is a multiset of elements of Vk1,k2.
In an homomorphic-based tally, the votes are added together.
Thus R = Nk, the set of vectors of k elements, and ∗ is the addition
of vectors. The corresponding counting function is ρhom(V) =
v ∈V v.
Both ρmix and ρhom have the partial tally property. The vote
vblank is a neutral vote w.r.t. ρhom but not ρmix .

The result of the election r may have several representations. For
example, a multiset may be represented by several lists (where the
order changes). In symbolic models, the result will be represented
by abstract terms and we wish our result to be independent of a
particular choice of representation. Therefore, we will simply say
that a representation R is a function that associates to a result r ∈ R
a set of possible representations with an injectivity property:
∀r (cid:44) r
′
. R(r) ∩ R(r
′) = ∅
Intuitively, a result can be associated to several representations but
a given representation can correspond to at most one result.
For our proofs in a cryptographic setting, we will also assume
that given an election result r and a set of votes V , one can decide
efficiently (in polynomial time) whether r includes all the votes of
V , that is, whether there exists V ′ such that r = ρ(V ⊎ V ′). This
condition is satisfied by ρmix and ρhom and all standard counting
functions.
3
∪ {vblank}
Fc = {pk/1, enc/2, aenc/2, ⟨·,·⟩/2, +/2}
3 SYMBOLIC MODEL
3.1 Model
In symbolic models, security protocols are often modelled through a
process algebra, in the spirit of the applied pi-calculus [3], that offers
a small, abstract language for specifying communications, where
messages are represented as terms. We present here a calculus
inspired from the calculus underlying the ProVerif tool [10].
3.1.1 Terms. We consider an infinite set of names N that model
fresh values such as nonces and keys. We distinguish the set FN
of free nonces (generated by the attacker) and the set BN of bound
nonces (generated by the protocol agents). We also assume an infi-
nite set of variables V = X ⊎ AX where X contains variables used
in processes (agent’s memory) while AX contains variables used
to store messages (adversary’s memory). Cryptographic primitives
are represented through a set of function symbols, called signa-
ture F . Each function symbol has an arity, that is, the number of its
arguments. We assume an infinite set C ⊆ F of public constants,
which are functions of arity 0.
Example 3.1. The standard primitives, public keys, symmetric
and asymmetric encryption, concatenation, as well as addition, can
be modelled by the following signature.
The companion primitives (symmetric and asymmetric decryp-
tion, projections) are then represented by the following signature:
Fd = {dec/2, adec/2, π1/1, π2/1}
Given a signature F , a set of names N, a set of variables V, the
set of terms T(F ,V,N) is the set inductively defined by applying
functions to variables in V and names in N. The set of names
resp. variables) occurring in t is denoted names(t) (resp. vars(t)). A
term is ground if it does not contain any variable. The set of terms
T(F , AX, FN) represents the attacker terms, that is, terms built
from the messages sent on the network and stored thanks to the
variables in AX.
A substitution σ = {M1/x1, . . . , Mk/xk} maps variables x1, ...,
xk ∈ V to messages M1, . . . , Mk. Its domain is denoted dom(σ) =
{x1, . . . , xk}. The application of σ to a term t is denoted tσ and is de-
fined as usual. A substitution σ is ground if its messages M1, . . . , Mk
are ground.
The properties of the cryptographic primitives are modelled
through an equational theory E, which is a finite set of equations of
the form M = N where M, N ∈ T(F ,X, ∅) are messages without
names. Equality modulo E, denoted by =E, is defined as the smallest
equivalence relation on terms that is closed under context and
substitution. We denote disequalities modulo E by M (cid:44)E N .
Example 3.2. Considering the signature Fc ∪ Fd ∪ C from Ex-
ample 3.1, the following equational theory describes the ability to
decrypt symmetrically, asymmetrically, and to project pairs. It also
Processes:
P, Q ::=
0
ν n.P
out(c, M).P
in(c, x).P
event(M1, . . . , Mn).P
P | Q
let x = M in P
if M = N then P else Q
!P
|
|
|
|
|
|
|
|
for n ∈ BN (n bound in P)
for x ∈ X (x bound in P)
for event ∈ Ev of arity n
for x ∈ X (x bound in P)
where M, N , M1, . . . , Mn are messages and c ∈ Ch is a channel.
Figure 1: Syntax for processes.
are equal modulo E, and behaves like Q otherwise. The replicated
process !P behaves as an unbounded number of copies of P.
We denote by w−−−→∗ the reflexive transitive closure of α−−→, where
w is the concatenation of all actions. We also write equality up to
silent actions and events =τ .
A trace of a process P is any possible sequence of transitions
starting from P. Traces correspond to all possible executions in the
presence of an attacker that may read, forge, and send messages.
Formally, the set of traces trace(P) is defined as follows.
trace(P) = {(w, new E.ϕ)|(∅; {P}; ∅) w−−−→∗ (E; P; ϕ)}
A sequence of actions t is blocking in a process P if it cannot be
executed.
characterises + as an associative and commutative operator.
blocking(t, P) def= ∀ϕ. (t, ϕ) (cid:60) trace(P).
dec(enc(x, y), y) = x
adec(aenc(x, pk(y)), y) = x
π1(⟨x, y⟩) = x
π2(⟨x, y⟩) = y
x + (y + z) = (x + y) + z
x + y = y + x
3.1.2 Processes. The behaviour of protocol parties is described
through processes. Let Ch be an infinite set of channel names, rep-
resenting the channels on which the messages are exchanged. All
channels will be public. We consider different channels nevertheless
to model the fact that an attacker can identify the provenance of a
message. We also consider a finite set Ev of event symbols, given
together with their arity. Events are used to record that partici-
pants have reached a certain step, with some associated knowledge.
Protocols are modelled through a process algebra, whose syntax is
displayed in Figure 1.
ture of bound names and variables.
processes;
As usual, we identify processes up to α-renaming, to avoid cap-
A configuration of the system is a triple (E; P; ϕ) where:
• P is a multiset of processes that represents the current active
• E is a set of names, which represents the private names of
• ϕ is a substitution with dom(ϕ) ⊆ AX that represents the
messages sent on the network. We assume ϕ to be ground,
that is for any x ∈ dom(ϕ), ϕ(x) is a ground term.
the processes;
The semantics of processes is given through a transition relation
α−−→ provided in Figure 2, where α is the action associated to the
transition. τ denotes a silent action. Events are recorded but will
be invisible to the attacker. Intuitively, process ν n.P creates a fresh
nonce, stored in E, and behaves like P. Process out(c, M).P emits M
on c and behaves like P. Process in(c, x).P inputs a term computed
by the attacker (that is a term built from ϕ using an attacker term)
on channel c and then behaves like P. Process event(M1, . . . , Mn).P
triggers the event event(M1, . . . , Mn), and then behaves like P. Pro-
cess P | Q corresponds to the parallel composition of P and Q.
Process let x = M in P behaves like P in which x is replaced with
M. Process if M = N then P else Q behaves like P if M and N
Example 3.3. Helios [4] is a simple voting protocol used in several
elections, like the election of the recteur of the university of Louvain-
la-Neuve. A voter simply encrypts her vote with the public key of
the election. This encrypted vote forms the ballot, which is sent
to the ballot box. The voter may check that her ballot is on the
ballot box since the ballot box is public. There are two ways for
tallying, either homomorphic tally or mixnet-based tally. We model
here the two options in an abstract way: given the ballots, the
talliers output the aggregation of the decryption of the ballot. This
aggregation could be the addition or just the votes in a random
order. For simplicity, we describe here a simple version with only
two honest voters A and B, a dishonest voter C, and a voting server
S. This protocol can be modelled by the following process.
PHelios(va, vb) =
ν kas , kbs , kcs , ke .
(out(c, kcs).out(c, pk(ke)) |
Voter(A, va, ca, c′
TallyHelios(ca, cb , cc , cs , kas , kbs , kcs , ke))
a, kas , ke) | Voter(B, vb , cb , c′
b , kbs , ke) |
where Voter(a, v, c, c′, k, ke) represents voter a willing to vote for v
using the channels c and c′, the election key ke and the credential k
to authenticate to the server, while TallyHelios represents the voting
server.
Voter(a, v, c, c′, k, ke) simply sends an encrypted vote. To model
the fact that voters communicate with the ballot box through an
authenticated channel, we assume that a voter first sends her ballot
privately to the server (using the encryption with k) and then
sends the ballot on a public channel. Note that the key k is just a
modelling artefact to abstract away the underlying password-based
authenticated channel.
Voter(a, v, c, c′, k, ke) =
ν r . out(c, enc(aenc(⟨v, r⟩, pk(ke)), k)). Voted(a, v).
out(c′, aenc(⟨v, r⟩, pk(ke)))
The voting server receives ballots from voters A, B, and C and
then outputs the decrypted ballots, after some mixing, modelled
4
(E; {P1 | P2} ∪ P; ϕ)
(E; {0} ∪ P; ϕ)
(E; {ν n.P} ∪ P; ϕ)
(E; {out(c, M).P} ∪ P; ϕ)
(E; {in(c, x).P} ∪ P; ϕ)
(E; {event(M1, . . . , Mn).P} ∪ P; ϕ)
(E; {let x = M in P} ∪ P; ϕ)
(E; {if M = N then P else Q} ∪ P; ϕ)
(E; {if M = N then P else Q} ∪ P; ϕ)
(E; {!P} ∪ P; ϕ)
τ−−→
τ−−→
τ−−→
(E; {P1, P2} ∪ P; ϕ)
(E; P; ϕ)
(E ∪ {n}; {P} ∪ P; ϕ)
in(c,R)
−−−−−−−→
ν axn .out(c,axn)
−−−−−−−−−−−−−−−−→ (E; {P} ∪ P; ϕ ∪ {M/axn})
if M is a ground term, axn ∈ AX and n = |ϕ| + 1
(E; {P[Rϕ/x]} ∪ P; ϕ)
τ−−→
event(M1, ...,Mn)
−−−−−−−−−−−−−−−−→ (E; {P} ∪ P; ϕ)
if R is an attacker term such that vars(R) ⊆ dom(ϕ)
if ∀i. Mi is a ground message
(E; {P[M/x]} ∪ P; ϕ)
if M is ground
(E; {P} ∪ P; ϕ)
(E; {Q} ∪ P; ϕ)
(E; {P, !P} ∪ P; ϕ)
if M, N are ground messages such that M (cid:44)E N
if M, N are ground messages such that M =E N
τ−−→
τ−−→
τ−−→
Par
Zero
New
Out
In
Event
Let-In
If-Then
If-Else
Repl
through the + operator.
TallyHelios(ca, cb , cc , cs , kas , kbs , kcs , ke) =
in(ca, x1).in(cb , x2).in(cc , x3).
let y1 = dec(x1, kas) in
let y2 = dec(x2, kbs) in
let y3 = dec(x3, kcs) in
if x1 (cid:44) x2 ∧ x1 (cid:44) x3 ∧ x2 (cid:44) x3 then
out(cs , π1(adec(y1, ke)) + π1(adec(y2, ke))
+ π1(adec(y3, ke)))
where we omit the null else-branches. ∧ is syntactic sugar for a
succession of tests and if M (cid:44) N then P is syntactic sugar for
if M = N then 0 else P.
3.1.3 Equivalence. Sent messages are stored in a substitution ϕ