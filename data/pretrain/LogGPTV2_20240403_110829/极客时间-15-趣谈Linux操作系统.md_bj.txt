# fdisk -l  Disk /dev/vda: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000a4c75     Device Boot      Start         End      Blocks   Id  System/dev/vda1   *        2048    41943006    20970479+  83  Linux  Disk /dev/vdc: 107.4 GB, 107374182400 bytes, 209715200 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes例如，从上面的命令的输出结果可以看出，vda 这块盘大小21.5G，是格式化了的，有一个分区 /dev/vda1。vdc 这块盘大小107.4G，是没有格式化的。我们可以通过命令**mkfs.ext3**或者**mkfs.ext4**进行格式化。    mkfs.ext4 /dev/vdc执行完这个命令后，vdc 会建立一个分区，格式化为 ext4文件系统的格式。至于这个格式是如果组织的，我们下一节仔细讲。当然，你也可以选择不将整块盘格式化为一个分区，而是格式化为多个分区。下面的这个命令行可以启动一个交互式程序。    fdisk /dev/vdc在这个交互式程序中，你可以输入**p**来打印当前分了几个区。如果没有分过，那这个列表应该是空的。接下来，你可以输入**n**新建一个分区。它会让你选择创建主分区primary，还是扩展分区 extended。我们一般都会选择主分区 p。接下来，它会让你输入分区号。如果原来没有分过区，应该从 1开始。或者你直接回车，使用默认值也行。接下来，你可以一路选择默认值，直到让你指定这个分区的大小，通过 +sizeM或者 +sizeK 的方式，默认值是整块盘都用上。你可以 输入 +5620M 分配一个 5G的分区。这个时候再输入 p，就能看到新创建的分区了，最后输入w，将对分区的修改写入硬盘。分区结束之后，可能会出现 vdc1, vdc2 等多个分区，这个时候你可以 mkfs.ext3/dev/vdc1 将第一个分区格式化为 ext3，通过 mkfs.ext4 /dev/vdc2将第二个分区格式化为 ext4.格式化后的硬盘，需要挂在到某个目录下面，才能作为普通的文件系统进行访问。    mount /dev/vdc1 / 根目录 / 用户 A 目录 / 目录 1例如，上面这个命令就是将这个文件系统挂在到"/ 根目录 / 用户 A 目录 / 目录1"这个目录下面。一旦挂在过去，"/ 根目录 / 用户 A 目录 / 目录1"这个目录下面原来的文件 1 和文件 2 就都看不到了，换成了 vdc1这个硬盘里面的文件系统的根目录。有挂载就有卸载，卸载使用**umount**命令。    umount / 根目录 / 用户 A 目录 / 目录 1前面我们讲过，Linux 里面一切都是文件，那从哪里看出是什么文件呢？要从 ls-l 的结果的第一位标识位看出来。-   \- 表示普通文件；-   d 表示文件夹；-   c 表示字符设备文件，这在设备那一节讲解；-   b 表示块设备文件，这也在设备那一节讲解；-   s 表示套接字 socket 文件，这在网络那一节讲解；-   l    表示符号链接，也即软链接，就是通过名字指向另外一个文件，例如下面的代码，instance    这个文件就是指向了 /var/lib/cloud/instances    这个文件。软链接的机制我们这一章会讲解。```{=html}```    
# ls -llrwxrwxrwx 1 root root   61 Dec 14 19:53 instance -> /var/lib/cloud/instances
## 文件系统相关系统调用看完了命令行，我们来看一下，如何使用系统调用在操作文件？我们先来看一个完整的例子。    #include #include #include #include   int main(int argc, char *argv[]){    int fd = -1;  int ret = 1;  int buffer = 1024;  int num = 0;    if((fd=open("./test", O_RDWR|O_CREAT|O_TRUNC))==-1)  {    printf("Open Error\n");    exit(1);  }    ret = write(fd, &buffer, sizeof(int));  if( ret #include #include #include #include #include #include   int main(int argc, char *argv[]){  struct stat sb;  DIR *dirp;  struct dirent *direntp;  char filename[128];  if ((dirp = opendir("/root")) == NULL) {    printf("Open Directory Error%s\n");    exit(1);  }  while ((direntp = readdir(dirp)) != NULL){    sprintf(filename, "/root/%s", direntp->d_name);    if (lstat(filename, &sb) == -1)    {      printf("lstat Error%s\n");      exit(1);    }      printf("name : %s, mode : %d, size : %d, user id : %d\n", direntp->d_name, sb.st_mode, sb.st_size, sb.st_uid);    }  closedir(dirp);    return 0}opendir 函数打开一个目录名所对应的 DIR 目录流。并返回指向 DIR目录流的指针。流定位在 DIR 目录流的第一个条目。readdir 函数从 DIR 目录流中读取一个项目，返回的是一个指针，指向 dirent结构体，且流的自动指向下一个目录条目。如果已经到流的最后一个条目，则返回NULL。closedir() 关闭参数 dir 所指的目录流。到这里，你应该既会使用系统调用操作文件，也会使用系统调用操作目录了。下一节，我们开始来看内核如何实现的。
## 总结时刻这一节，我们对于文件系统的主要功能有了一个总体的印象，我们通过下面这张图梳理一下。-   在文件系统上，需要维护文件的严格的格式，要通过 mkfs.ext4    命令来格式化为严格的格式。-   每一个硬盘上保存的文件都要有一个索引，来维护这个文件上的数据块都保存在哪里。-   文件通过文件夹组织起来，可以方便用户使用。-   为了能够更快读取文件，内存里会分配一块空间作为缓存，让一些数据块放在缓存里面。-   在内核中，要有一整套的数据结构来表示打开的文件。-   在用户态，每个打开的文件都有一个文件描述符，可以通过各种文件相关的系统调用，操作这个文件描述符。![](Images/62bbfc95c0450429710565b30660612f.png){savepage-src="https://static001.geekbang.org/resource/image/27/50/2788a6267f8361c9b6c338b06a1afc50.png"}
## 课堂练习你可以试着将一块空闲的硬盘，分区成为两块，并安装不同的文件系统，进行挂载。这是Linux 运维人员经常做的一件事情。欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。![](Images/1a5564dd4e1c9f25d4772c7f844ca84a.png){savepage-src="https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg"}