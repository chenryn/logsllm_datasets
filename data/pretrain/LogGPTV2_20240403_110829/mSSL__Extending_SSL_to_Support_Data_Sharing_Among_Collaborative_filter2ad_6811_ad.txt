 70
 60
 50
 40
 30
 20
 10
)
s
(
e
m
i
t
g
n
i
r
r
e
f
s
n
a
r
t
a
t
a
D
 0
32k
64k
128k
256k
1M
2M
512k
File size (bytes)
4M
8M
16M
32M
Figure 7. Data transferring time under basic
scenarios
Figure 8 shows the data transferring time when support-
ing all different combined mSSL security functionalities.
The AIP scenario (i.e. P ) is the slowest, and AC is the
fastest, while AI or AIC (equivalent because of ofﬂine en-
cryption/decryption) are just slightly slower than AC. The
reasons for the speed differences are similar to above.
6.4 Storage Overhead
While the none scenario will incur the same storage
overhead as in the conventional SSL, more security func-
tionalities lead to extra storage overhead. Assuming the
server is S and a recipient r is obtaining a data object O
from a provider p, extra storage overhead related to each
security function is:
• Client authentication: r needs to store a ticket for O. In
our implementation, a ticket is approximately 160 bytes.
• Integrity: Both p and r need to store the Merkle hash tree
of O. If O is 1 GB, each block is 8 KB, and every hash
value is 16 bytes, the tree will be approximately 4 MB.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply. 
AC
AI, AIC
AIP
 80
 70
 60
 50
 40
 30
 20
 10
)
s
(
e
m
i
t
g
n
i
r
r
e
f
s
n
a
r
t
a
t
a
D
 0
32k
64k
128k
256k
1M
2M
512k
File size (bytes)
4M
8M
16M
32M
Figure 8. Data transferring time under com-
bined scenarios
• Conﬁdentiality: p needs to store an encrypted copy of O
(unless p encrypts O on the ﬂy) and S needs to store the
decryption key.
• Proof of service: p and r need to store certiﬁcates of their
public keys, and p also needs to store necessary acknowl-
edgments from r. Due to the aggregation feature built into
the acknowledgment mechanism, only a small number of
acknowledgments are needed and each acknowledgment
in our implementation is typically 150-200 bytes.
6.5 Volume of Control Trafﬁc
Similarly, while the none scenario will incur the same
volume of control trafﬁc as in the conventional SSL, more
security functionalities lead to extra control trafﬁc. Again,
assuming the server is S and a recipient r is obtaining a
data object O from a provider p, extra trafﬁc purely related
to each of the following is:
• Client authentication: the delivery of a ticket from S to r
and from r to p.
• Integrity: assuming O has n blocks, the extra trafﬁc will
be n−1 hash values from p to r (we omit the proof to save
space) and a small amount of request trafﬁc from r to p.
• Conﬁdentiality: S needs forward the decryption key to r.
• Proof of service: p and r need to send each other a cer-
tiﬁcate of their own public keys. r also needs to send an
acknowledgment for each encrypted block of O. p also
needs to send a protected block key to r (see Section 4).
p may also contact S to present the proof of its service,
which will be the size of an acknowledgment (recall it is
typically 150-200 bytes in our implementation). r may
also burden S with a small amount of trafﬁc when r has
trouble with block keys.
6.6 Summary
Our comprehensive cost and performance study of mSSL
shows that in general, more security functionalities lead to
higher storage and trafﬁc overhead while decreasing server
capacity and lengthening ﬁle downloading time. But over-
all, the extra overhead it introduces is at a reasonable level
and generally very small.
7 Related Work
Works related to mSSL can be categorized into related
security protocols, related data integrity solutions, and in-
centive mechanisms in peer-to-peer environment.
7.1 Security Protocols
We discuss security protocols that could potentially be
used for the hybrid peer-to-peer paradigm to support func-
tions that mSSL is designed for.
SSL/TLS: SSL [17], or SSL/TLS, provides data encryp-
tion and authentication between a client and a server. It is
the most common security scheme today for securing web-
based services and has also been used for many other ser-
vices. However, SSL is designed to secure point-to-point
communications. To use SSL in securing the sharing of data
from a server among its clients, it must be applied separately
to every client-server and client-client connection, resulting
in a high overhead.
Kerberos: mSSL’s ticket-based authentication mecha-
nism has some similarities with Kerberos. Kerberos allows
a client to contact a trusted third party, a Key Distribution
Center (KDC), to obtain a ticket-granting ticket (TGT), and
then use the TGT to obtain a ticket related to a particular
service. However, designed for this hybrid P2P environ-
ment, mSSL avoids the reliance on a trusted third party. It
allows the server to issue a ticket directly to a client.
Group Management: If all authenticated clients of a
server are treated as a group, some group management tech-
niques could be useful. For example, SDSI [18] uses a sim-
ple PKI to manage memberships and secret communication
among members. Various group key management schemes
have also been designed,
such as [23, 12, 7]. However,
these schemes are mainly to support conﬁdential communi-
cation among group members, whereas mSSL must handle
not only conﬁdentiality, but also other security functionali-
ties such as integrity and proof of service.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply. 
7.2 Data Integrity Mechanisms
8 Conclusions
Existing peer-to-peer ﬁle-sharing applications provide
data integrity functionalities. PROOFS [21] and Slurpie
[20] recommend the use of MD5 or similar checksum al-
gorithms. BitTorrent [5] adopts a superblock-based mech-
anism, which can have a high startup latency (as we dis-
cussed in Section 3). Solutions based on a Merkle hash
tree have also been proposed for peer-to-peer environments,
such as [6]. Different from those works, mSSL does not re-
quire pre-downloading of hash values, and for each block
a client can just request an integrity path instead of a nor-
mally much longer authentication path. Integrity solutions
also exist in different contexts; for example, TESLA [16]
allows a large number of recipients to check the integrity of
packets being delivered from a single source.
Researchers have also proposed solutions that are com-
plementary to mSSL’s integrity solution, including storage
mechanisms of block-level integrity information (such as
[15]), optimization of Merkle hash trees (such as [22]).
7.3 Offering Proofs of Service
Proof of service in this paper can be regarded as one par-
ticular case of a non-repudiation service. There have been
quite a few non-repudiation schemes designed in different
contexts, focusing on non-repudiation of origin, receipt,
submission, and delivery [10, 13]. Veriﬁcation of non-
repudiation schemes have also been studied [26, 19, 11].
Proof of service is also similar to the strong fair exchange
of information. In the context of this paper, fairness would
mean for a provider to receive a proof of its service and for
a recipient to receive the desired data. Solutions with a TTP
can be created using an inline TTP (such as [4, 2] where
the TTP is required to mediate every communication be-
tween a sender and a receiver), using an online TTP (such
as [24, 25] where the sender and the receiver can directly
communicate, but still need the TTP to store and fetch in-
formation), and using an ofﬂine TTP (such as [1, 9], where
the TTP will be involved only when a problem occurs).
The most closely related to this paper is the fair exchange
with an ofﬂine TTP. While leveraging current schemes, our
solution for the hybrid peer-to-peer paradigm has an impor-
tant difference in that a server itself can act as a TTP for
its own provider and recipient clients. This is also an inher-
ent advantage for enforcing fairness. Further note that the
server is also the original source of the data that a provider
offers to a recipient, bringing us another advantage in de-
signing a solution in this hybrid paradigm.
If needed, a
server can verify the data without requesting them from
other nodes, thus avoiding a drawback in many TTP-based
solutions, especially when the amount of data is large.
As we continue to see the trend that the conventional
client-server communication paradigm is enhanced with
peer-to-peer communications among clients, often with dra-
matic advantages, serious security concerns arise in this hy-
brid communication environment. Compared to receiving
data directly from a server, receiving data from arbitrary,
often less trustworthy peer clients is subject to much higher
security risks. Malicious clients may sneak into the sys-
tem to corrupt the hybrid communications. Data integrity
and data conﬁdentiality are more easily breached. Mecha-
nisms to reward peer clients for sharing data, such as credit-
ing those providing data to others, are also vulnerable since
clients may lie about peer-level service.
We designed and evaluated the mSSL protocol to address
these security concerns. In contrast to the SSL protocol that
protects conventional client-server communications, mSSL
allows clients to share data from their server in a peer-to-
peer fashion with a strong security. It protects both client-
server and client-client communications. Furthermore, to
strengthen the security of a wide range of Internet appli-
cations running with a hybrid communication paradigm,
mSSL provides strong and ﬂexible support for addressing
both conventional security issues, such as client authentica-
tion, data integrity and data conﬁdentiality, and new secu-
rity issues such as proof of service in this special context.
mSSL’s contributions also include its special attention
to designing effective and efﬁcient data integrity protec-
tion and proof-of-service mechanisms. It introduced an “in-
tegrity path” concept to allow prompt, block-level integrity
veriﬁcation with low communication and computation over-
head. Its proof-of-service mechanism has minimal server
overhead, uses small-sized proofs for the service of a very
large number of blocks, and ensures the service of every
block to be credited accurately. Our evaluation agrees with
our design, and has shown an acceptable overhead under
different scenarios where mSSL might be used.
References
[1] N. Asokan, V. Shoup, and M. Waidner. Asynchronous Pro-
tocols for Optimistic Fair Exchange.
In Proceedings of
the IEEE Symposium on Research in Security and Privacy,
pages 86–99, 1998.
[2] A. Bahreman and J. Tygar. Certiﬁed Electronic Mail.
In
Proc. of Symposium on Network and Distributed Systems Se-
curity, pages 3–19, 1994.
[3] BitTorrent, Inc. BitTorrent. http://bittorrent.com,
2005.
[4] T. Coffey and P. Saidha. Non-Repudiation with Manda-
tory Proof of Receipt. SIGCOMM Comput. Commun. Rev.,
26(1):6–17, 1996.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply. 
[5] B. Cohen. Incentives Build Robustness in BitTorrent. Work-
[24] N. Zhang and Q. Shi. Achieving Non-Repudiation of Re-
ceipt. The Computer Journal, 39(10), 1996.
[25] J. Zhou and D. Gollmann. A Fair Non-Repudiation Proto-
col. In Proceedings of the IEEE Symposium on Research in
Security and Privacy, pages 55–61, Oakland, CA, 1996.
[26] J. Zhou and D. Gollmann. Towards Veriﬁcation of Non-
Repudiation Protocols. In Proceedings of 1998 International
Reﬁnement Workshop and Formal Methods Paciﬁc, pages
370–380, Canberra, Australia, 1998.
shop on Economics of Peer-to-Peer Systems, 2003.
[6] A. Habib, D. Xu, M. Atallah, B. Bhargava, and J. Chuang.
Verifying Data Integrity in Peer-to-Peer Media Streaming.
In Twelfth Annual Multimedia Computing and Networking
(MMCN ’05), 2005.
[7] Y. Kim, A. Perrig, and G. Tsudik. Tree-Based Group Key
Agreement. ACM Trans. Inf. Syst. Secur., 7(1):60–96, 2004.
[8] K. Kong and D. Ghosal. Mitigating Server-Side Congestion
IEEE/ACM Trans.
in the Internet through Pseudoserving.
Netw., 7(4):530–544, 1999.
[9] S. Kremer and O. Markowitch. Optimistic Non-Repudiable
Information Exchange. In Proceedings of the 21st Sympo-
sium on Information Theory in the Benelux, pages 139–146,
Wassenaar, The Netherlands, 2000.
[10] S. Kremer, O. Markowitch, and J. Zhou. An Intensive Sur-
vey of Fair Non-Repudiation Protocols. Computer Commu-
nications, 25(17), 2002.
[11] S. Kremer and J.-F. Raskin. A Game-Based Veriﬁcation
of Non-Repudiation and Fair Exchange Protocols. Lecture
Notes in Computer Science, 2154:551+, 2001.
[12] X. S. Li, Y. R. Yang, M. G. Gouda, and S. S. Lam. Batch
Rekeying for Secure Group Communications. In Proceed-
ings of the 10th International Conference on World Wide
Web, pages 525–534. ACM Press, 2001.
[13] P. Louridas. Some Guidelines for Non-Repudiation Pro-
SIGCOMM Computer Communication Review,
tocols.
30(5):29–38, 2000.
[14] M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow. IETF
RFC 2018: TCP Selective Acknowledgement Options,
1996.
[15] A. Oprea, M. Reiter, and K. Yang. Space-Efﬁcient Block
In The 12th Annual Network and Dis-
Storage Integrity.
tributed System Security Symposium, 2005.
[16] A. Perrig, R. Canetti, J. D. Tygar, and D. Song. The tesla
broadcast authentication protocol. 5(2):2–13, 2002.
[17] E. Rescorla. SSL and TLS: Designing and Building Secure
Systems. Addison-Wesley, 2000.
[18] R. Rivest and B. Lampson. SDSI: A Simple Distributed Se-
curity Infrastructure. http://theory.lcs.mit.edu/˜cis/sdsi.html,
1996.
[19] S. Schneider. Formal Analysis of a Non-Repudiation Proto-
col. In CSFW ’98: Proceedings of the 11th IEEE Computer
Security Foundations Workshop, page 54, Washington, DC,
USA, 1998.
[20] R. Sherwood, R. Braud, and B. Bhattacharjee. Slurpie: A
Cooperative Bulk Data Transfer Protocol. IEEE INFOCOM,
2004.
[21] A. Stavrou, D. Rubenstein, and S. Sahu. A Lightweight,
In the 10th
Robust P2P System to Handle Flash Crowds.
ICNP, pages 226–235, 2002.
[22] D. Williams and E. G. Sirer. Optimal Parameter Selection
for Efﬁcient Memory Integrity Veriﬁcation Using Merkle
Hash Trees. In Proceedings of Network Computing and Ap-
plications, Trusted Network Computing Workshop, 2004.
[23] C. K. Wong, M. Gouda, and S. S. Lam. Secure Group Com-
munications Using Key Graphs. IEEE/ACM Trans. Netw.,
8(1):16–30, 2000.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply.