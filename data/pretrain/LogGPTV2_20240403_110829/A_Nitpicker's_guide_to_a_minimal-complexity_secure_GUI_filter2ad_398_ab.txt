are not possible by deﬁnition.
All the presented label-placement strategies do have one
problem in common: A Trojan Horse can mimic a complete
desktop by creating a window that is bigger than the whole
screen and placing the window in a way that all window
controls are outside of the screen area. Such a fullscreen
window could present a picture of a trusted client, including
the faked labeling information. This example illustrates that
we need to preserve a dedicated screen space for presenting
labeling information only. The DOpE window server uses
a region at the top of the screen for displaying information
about the currently focused window. This area cannot be
covered by windows and the information is always visible.
However, the top of the screen is not in the focus of the
user when he interacts with windows and he may miss to
pay attention to the labeling information. We desire a more
noticeable way to present labeling information.
Another idea to preserve a unique capability for present-
ing labeling information is to cut the color space into two
regions. The currently focused client and all labeling in-
formation is presented in full color while the brightness of
all other clients is dimmed. This guides the user’s attention
to one bright spot on the screen that displays one clearly
visible communication partner at a time. Dimming is im-
plemented in the Exposé function of Mac OS X [1] and in
EWS.
For Nitpicker, we combine the reserved area and dim-
ming techniques with a new label placement strategy:
Floating labels. Nitpicker dimms all views that do not be-
long to the focused client. All views are surrounded by a
thin bright border. The focused view is additionally high-
lighted by a border of a different color. In contrast to ex-
isting label placement strategies, Nitpicker analyzes the ar-
rangement of visible views and places all labels in a way
that they are visible. Nitpicker chooses the topmost position
within the view where the complete label is visible. If the
label cannot be completely displayed, it is placed in a way
that the ﬁrst—most important—part of the label remains
visible. Labels ﬂoat over their corresponding view while
always covering a part of the view’s content. All labels are
drawn in the same color as their corresponding view border
and feature a black outline so that they are clearly readable
on any background color. Because of the maximum bright-
ness of the label text, a dimmed view can never mimic or
faze a label because it is doomed to paint gray instead of
white. When looking at the screen, the most noticeable in-
formation are the view borders, the labels and the focused
view. Similar to DOpE, a bar at the top of the screen dis-
plays the information about the focused view.
In MLS systems, Nitpicker could tint unfocused views
of different classiﬁcation levels with different colors. For
application areas where extremely paranoid security poli-
cies are needed, the dimming may completely blend out the
content of unfocused clients. Just for the sake of nitpick-
ing, we must consider that the dimming technique does not
prevent Trojan Horses from faking trusted clients that use
only dark colors. Still, the view borders and labels cannot
be faked.
There are other application areas, where productivity is
needed. For example, a user wants to watch a full-color
movie while coding. In this scenario, dimming would re-
duce inspiration and consequently, lower his efﬁciency. For
this, we introduce a way to toggle two modes by using a
magic key. In Flat mode, no labels, no borders and no dim-
ming is displayed. The only visible part of Nitpicker is a red
shaded bar at the top of the screen that displays the labeling
information of the focused view. In X-ray mode, dimming,
ﬂoating labels, and the view borders are active. The bar at
the top of the screen is shaded gray, signalling that X-ray
mode is active. The toggling between both modes can only
be performed by the user. However, clients can request the
currently active mode. If a security-sensitive client detects
Flat mode, it should ask the user to switch to X-ray mode
before it starts processing sensitive data. Passwords should
never be entered in Flat mode. For daily use at home or
in productive environments, Flat mode may be default and
X-ray mode will be used occasionally to perform sensitive
tasks, for example bank transactions. In contrast, for highly
secure systems, switching to Flat mode could be disabled.
Figure 2. One buffer per view.
Figure 3. Two window systems as clients.
2.5 Bring Nitpicker to life
After describing raw mechanisms, we outline two ways
of implementing a window system on top of them.
The straight forward approach for implementing a win-
dow system using buffers and views is to render each win-
dow into a dedicated buffer and create one view for dis-
playing the buffer on screen. Figure 2 illustrates this ap-
proach, which basically corresponds to the implementation
of EWS and Apple Quartz. The obvious advantage is sim-
plicity. The performance of moving windows and changing
the stack layout is great because no rerendering of windows
is needed in such situations. The performance only depends
on the blitting operation of Nitpicker. For resizing win-
dows, reallocation of the buffer and a new render process
is needed. Of course, the buffer-per-view approach implies
high memory requirements. Each window requires a buffer
of the window’s size regardless of whether the window is
visible or covered by other windows. The authors of EWS
argument that modern graphics cards provide an abundance
of memory. On the other hand, one can argue that graph-
ics memory should be available to applications instead of
the window system. Additionally, when looking at mobile
platforms and embedded devices, graphics memory is a pre-
cious resource.
Another way to deploy Nitpicker’s mechanisms is to use
only one buffer and render a complete windowed desktop
into this buffer. The client is indeed a window system by it-
self. In the following, we use the term client window to en-
title a window on a desktop managed and rendered entirely
by the client. Instead of using one view to make the whole
buffer visible on screen, we create one view for each client
window. Each view is positioned exactly to the geometry
of its corresponding client window. Consequently, the set
of views reveal the part of the buffer that is occupied by the
client windows. Furthermore, we keep the stacking order of
views consistent with the stacking order of the client win-
dows by applying all state changes of the client windows
to their corresponding views, too. For example, when the
client raises a client window, it also raises the correspond-
If all state changes of client
ing view at the same time.
windows are consistently applied to Nitpicker’s views, the
stacking layout of the views is equal to the stacking layout
of the client window system.
If multiple client window systems come into play as
illustrated in Figure 3, each client window system manages
its local desktop and its local stack of views while isolation
between clients is preserved. Nitpicker alone knows the
global stacking order that consists of the interlocked view
stacks of all clients. Consequently, each protection domain
in the system can implement a custom window system with
the desired functionality. This technique and a number
of applications are described in more detail in [15]. With
regard to memory consumption,
this technique scales
well with the number of windows on screen because all
windows of one Nitpicker client are using one and the same
buffer. On the other hand, moving windows and changing
the stacking layout require the client to refresh the affected
areas on its local desktop. This makes the client more
complex and involves costly rendering operations.
Nitpicker enables the usage of both techniques by dif-
ferent clients at the same time. A Nitpicker client can im-
plement the window handling policy for single windows by
itself while another client can be a full-ﬂedged window sys-
tem that manages a number of sub-clients and thus, provid-
ing convenience to application programmers at the cost of
increased complexity.
2.6 Drag-and-drop
Drag-and-drop is a widely used paradigm to transfer data
from an application to another by dragging an item with the
mouse. Nitpicker does not need to provide support for drag-
and-drop between views of one client. Proprietary drag-
and-drop protocols can be used, thanks to the input routing
BuffersViewsBuffersViewsFigure 4. Picking an item.
Figure 6. Releasing an item.
Figure 5. Dragging the item.
policy, described in Section 2.3. More challenging is the use
of drag-and-drop for establishing communication between
different clients of Nitpicker.
In [22], J. Shapiro proposed a drag-and-drop proto-
col and multi-level-security (MLS) format negotiation for
EWS. The proposed solution relies on the capability con-
cept of EROS. It has slight shortcomings such as the lack
of user feedback from the target client during the dragging
phase. In this section, we present a drag-and-drop protocol
that is derived from EWS and reﬁned for Nitpicker.
Communication via drag-and-drop is restricted by the
action of the user and global policy, for example the per-
mitted information ﬂow in a MLS system. We introduce
a dedicated component—the negotiator—for representing
the global policy.
Our drag-and-drop protocol consists of three phases:
Picking an item at the source client, dragging the item over
the views of potential target clients, and releasing the item
at the target client.
Picking an item (Figure 4): When the user clicks on a
view, only the client knows the meaning of the clicked ob-
ject. If the selected object is drag-able, the client tells Nit-
picker about the special meaning of this mouse transaction
and the mouse cursor is set to transport mode. The client
deposits a list of MIME types at the negotiator, who may
ﬁlter the list.
Dragging the item (Figure 5): While the mouse is
moved in transport mode, the user expects feedback from
the potential target client. Each time, the mouse cursor
crosses a view border, Nitpicker tells the negotiator about
the new pointed client (1). In turn, Nitpicker receives the
policy decision about the information ﬂow from the source
to the target client (2). If permitted and the user moves the
mouse, Nitpicker sends motion events to the source client
and ﬂoating events to the potential target client (3). When a
potential target client receives ﬂoating events, it can request
the offered list of MIME types at the negotiator (4). The
negotiator denies the request if the client is not equal to the
currently pointed client as told by Nitpicker. If the potential
target client receives the list of MIME types and a type is
supported, it gives feedback to the user.
Releasing the item (Figure 6): When the mouse button
is released, Nitpicker tells the negotiator that the user
accepts the transaction (1). Subsequently, Nitpicker sends
a release event to the source client (2) and a drop event
to the target client (3). The target client can now request
one MIME type at the negotiator and supplies a target
memory buffer via shared memory (4). When the source
client receives the release event, it polls the requested type
information at the negotiator and, in turn, transfers a source
memory buffer with the payload to the negotiator (5). Now,
the negotiator can copy the payload from the source to the
target memory buffer and conﬁrm the transaction.
Nitpicker neither deals with type negotiation, nor imple-
ments the policy of information ﬂow, and is not involved
in payload transfer. The whole job of Nitpicker during a
drag-and-drop transaction is to supply input events to both
clients and the negotiator. The implementation of the nego-
tiator is highly platform-speciﬁc whereas Nitpicker’s mech-
anisms are the same for all potential target platforms.
There is one low-bit-rate communication channel from
the target client to the source client. The target client could
encode data in the actual decision of what type from the
MIME type list it requests. However, the proposed protocol
keeps the involved clients anonymous and the channel is
bounded by user action.
Beside drag-and-drop, the most popular mechanism to
transfer information among applications is cut-and-paste.
In contrast to drag-and-drop, which requires support by the
GUI as described previously, cut-and-paste can be imple-
mented aside the GUI server. Clients can directly communi-
cate with a clipboard component that enforces the policy of
information ﬂow and performs format negotiation. There-
fore, we do not discuss cut-and-paste within this paper.
SourceClientTargetClientNegotiatorNitpicker(1) PRESS(2) TRANSPORT MODE(3) MIME-TYPE LISTSourceClientTargetClientNegotiatorNitpickerMOTION(1) POINTEDAPPLICATION(2) PERMIT(3) FLOATING(4) REQUEST TYPESSourceClientTargetClientNegotiatorNitpicker(2) RELEASE(1) ACCEPT        (3) DROP(4) REQUEST TYPE(5) POLL TYPEAND SUBMIT2.7 Resource management
A server that allocates resources on request of a client
is vulnerable to denial-of-service attacks. One malicious
client can exhaust server-side resources and reduce the qual-
ity of other clients and even make the server unavailable.
In the case of Nitpicker, critical server-side resources are
the heap that holds client-speciﬁc data structures and the
processing time that is consumed to serve a client. For pro-
viding robustness against heap exhaustion, a client must do-
nate memory to Nitpicker. If a client requests the creation of
a new view, Nitpicker returns an out-of-memory error. The
client resolves this error by donating a memory region to
Nitpicker. Thereafter, the memory area is accessible for Nit-
picker only and the client cannot revoke this memory area
from Nitpicker. Nitpicker uses this memory region exclu-
sively for this particular client and frees the memory region
on client exit.
Nitpicker consumes CPU time on request of its clients.
Serving a buffer refresh request requires a signiﬁcant
amount of processing time and bus bandwidth because
pixel data must be copied. Long-taking atomic operations
may delay other clients and the used CPU resources could
wrongly be accounted on Nitpicker. With our past research
on the DOpE [14] real-time window server, we addressed
these problems by introducing redraw dropping and redraw
splitting. These techniques can be applied to Nitpicker as
well.
3 Target platforms
The design of Nitpicker is applicable on all platforms
that provide isolation between security domains. These
platforms reach from virtual machine monitors (VMM) pro-
viding coarse-grained isolation of virtual machines (VM) to
ﬁne-grained multi-server OSs.
VMMs such as VMware [9] enable the execution of mul-
tiple guest OSs on one host OS at the same time. However,
there exists no convenient way of user interaction with mul-
tiple VMs. The graphical output of different VMs is either
displayed in separate windows of a host window system or
in separate virtual consoles. With Nitpicker running on the
host OS and exporting its client interface as a network ser-
vice, guest OSs are able to use the view mechanism via a
virtual network device. The guest OS could run a service
that forwards window state changes to Nitpicker and there-
fore, achieves a tight integration of its GUI with other guest
OSs running on separate VMs. Still, isolation between dif-
ferent guest OSs is maintained.
Hypervisor architectures such as the Xen VMM [11]
support the execution of multiple isolated (para-) virtual-
ized OSs.
In [16], the developers of Xen describe tech-
niques for the reuse of legacy drivers in dedicated virtual
machines and give an outlook toward Xen as multi-level se-
cure system. As Xen’s primary focus is server consolida-
tion, the supported device families are network and mass-
storage devices. However, the mechanisms for supporting
legacy drivers are suitable for video, too. Nitpicker, exe-
cuted within an I/O isolation space, could be one special
virtual video device that multiplexes the graphical output of
multiple VMs and performs the access to the physical video
hardware. The upcoming Windows Virtualization Archi-
tecture [6, 20] envisions a microkernelized hypervisor that
executes drivers within de-privileged protection domains
alongside unmodiﬁed legacy OSs and protected secure ap-
plications. According to [7], such applications will have
only limited GUI support (e. g., no support for overlapping
windows). Nitpicker however, could provide a seamless in-
tegration of such applications with the full-ﬂedged GUI of
the Windows OS while preserving the required isolation.
Nitpicker could enhance the application area of remote
desktop protocols (RDP). For example, German embassies
deploy the Secure Inter-Network Architecture (SINA) [8]
for processing classiﬁed information. The SINA Thin-client
as end-user component handles different classiﬁcation lev-