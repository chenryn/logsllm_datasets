tion algorithms. The quality of a signature generated
by pattern-extraction techniques generally improves as
the number of exploit samples increase. Our tech-
niques can be used to iteratively generate a new exploit
sample x(cid:2) that is different than the sample exploit x.
In this scenario, we can give x(cid:2) to the pattern-extractor
as a labeled exploit, which it then uses to improve an
existing signature. Note that in previous scenarios pat-
tern extraction would be limited to only x.
In addi-
tion, we may be able to label tokens within x which
may further help the analysis. Finally, we note that
our analysis could also be used to help defend against
“red-herring” and “coincidental token” attacks.
• Perform robust vulnerability identiﬁcation. Often it is
not known whether a known bug is exploitable. Here,
the developer would set vinit to the appropriate read
statement and vﬁnal to the line for the bug. Our tech-
niques will generate a sample exploit when possible,
conﬁrming whether a bug is exploitable or not.
• Vendor patches often miss all possible paths to a vul-
nerability. Missing alternate paths is not only a secu-
rity problem, but can also be an embarrassment to the
vendor because even “patched” systems may still be
compromised [11]. Our techniques can be adapted to
see if a given patch covers all possible ways a vulnera-
bility may be exploited.
Complete but unsound signatures. Every satisfying so-
lution to the generated symbolic equations is an exploit
string, thus the signature is sound but not complete. A com-
plete but potentially unsound signature, i.e., no false nega-
tives but false positives, can be created by setting the initial
signature to Σ∗ and removing any input that leads to BE-
NIGN state.
Identifying sources of signature imprecision. Our con-
struction allows a signature creator to tune accuracy and
generation time in several ways. First, the creator has a
choice of signature representations. Second, the creator
can choose how much information to retain for less ex-
pressive representations. For example, when creating a
symbolic representation the creator may choose how many
times loops are unrolled. Third, the creator can choose how
much analysis to perform. For example, when creating a
regular expression signature theorem proving can be em-
ployed to enumerate every input string that may exploit the
program, or faster but less accurate data-ﬂow analysis. We
believe these choices allow a creator to gain a fundamental
understanding of the overall accuracy of the ﬁnal generated
signature by comparing their generated signature to the per-
fect TM signature.
6 Related Work
Signature creation. In Section 1 we detailed most pre-
vious work in this area. Here we mention that Vigilante
has independently proposed signatures which are essen-
tially straight-line programs, not regular expressions [17],
much like our MEP symbolic constraint signatures. How-
ever, Vigilante only creates a signature for the execution
path taken by the sample exploit, and does not explore more
extensive coverages or other vulnerability signature repre-
sentations.
Estimating language classes. A signiﬁcant part of cre-
ating a vulnerability signature boils down to conservatively
estimating the higher-powered language such as a Turing
machine with a lower-power language such as a regular ex-
pression. Our techniques provide one way of accomplish-
ing this. For example, Mohri and Nederhof present an al-
gorithm for converting certain context-free languages into
regular expressions [39]. We are unaware of other signiﬁ-
cant work in this area.
Program analysis. We use many static analysis tech-
niques such as symbolic execution [31], abstract interpreta-
tion [18], model checking [15], theorem proving [20], data-
ﬂow analysis [29], and program slicing [57]. Each of these
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
areas is an active research area in which we can beneﬁt from
new or more advanced techniques. It would be impossible
to note all related work in static analysis; the reader is re-
ferred to [4, 41] for an overview of the subject.
Automatic test case generation research explores the
problem of automatically creating an input that reaches a
particular point in the program [10, 22, 23, 24, 25]. We are
interested in a very similar problem where we want to ap-
proximate all inputs that reach a certain location. Also, our
problem setting is relaxed since we may tolerate signatures
with false positives and/or negatives.
Another closely related area is static analysis of program
generated string expressions. This line of work aims at dis-
covering possible strings generated, as opposed to accepted
by a program. Christensen et. al. performed string analysis
on Java programs where type information is available [13].
Christodorescu et. al. extended Christensen’s work to x86
binaries [14]. These techniques are exciting, though more
research is needed to apply their techniques to our problem
setting. In particular, this approach only handles strings and
not other types such as integers.
7 Conclusion
We presented a general framework for obtaining a new
type of signature called vulnerability signatures. Given a
single sample exploit, we presented techniques for automat-
ically generating a signature of higher quality than previ-
ous approaches.
In addition, our formulation opens up a
wide variety of signature representations. In particular, we
discuss three distinct types of vulnerability signature repre-
sentations: Turing machine, symbolic constraints, and reg-
ular expressions. We provide theoretical and practical in-
sights into these three signature representations. We con-
clude that our approach is promising alternative to exploit-
centric techniques.
References
[1] Dynamorio.
http://www.cag.lcs.mit.edu/
dynamorio/.
[2] K2,
admmutate.
http://www.ktwo.ca/c/
ADMmutate-0.8.4.tar.gz.
[3] Metasploit. http://metasploit.org.
[4] A. Aho, R. Sethi, and J. Ullman. Compilers: Principles,
Techniques, and Tools. Addison-Wesley Publishing Com-
pany, 1986.
[5] P. Bosch, A. Carloganu, and D. Etiemble. Complete x86
instruction trace generation from hardware bus collect. In
23rd IEEE EUROMICRO Conference, 1997.
[6] F. Bourdoncle. Efﬁcient chaotic iteration strategies with
widenings. In Proc. of the International Conference on For-
mal methods in Programming and their applications (LNCS
735), 1993.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
[7] D. Brumley, L.-H. Liu, P. Poosank, and D. Song. Design
space and analysis of worm defense systems. In Proc of the
2006 ACM Symposium on Information, Computer, and Com-
munication Security (ASIACCS), 2006. CMU TR CMU-CS-
05-156.
[8] D. Brumley, J. Newsome, D. Song, H. Wang, and S. Jha.
Towards automatic generation of vulnerability-based signa-
tures. Technical Report CMU-CS-06-108, Carnegie Mellon
University, 2006.
[9] R. E. Bryant, S. K. Lahiri, and S. A. Seshia. Modeling and
verifying systems using a logic of counter arithmetic with
lambda expressions and uninterpreted functions.
In Proc.
Computer-Aided Veriﬁcation (CAV), 2002.
[10] C. Cadar and D. Engler. Execution generated test cases:
How to make system code crash itself. Technical Report
CSTR-2005-04, Stanford, 2005.
[11] C. Cerrudo. Story of a dumb patch. http://argeniss.
com/research/MSBugPaper.pdf, 2005.
[12] CERT/CC. ISC BIND 8 contains buffer overﬂow in trans-
action signature TSIG handling code. http://www.kb.
cert.org/vuls/id/196945.
[13] A. S. Christensen, A. Møller, and M. I. Schwartzbach. Pre-
cise analysis of string expressions.
In Proc. 10th Interna-
tional Static Analysis Symposium, SAS ’03, volume 2694 of
LNCS, pages 1–18. Springer-Verlag, June 2003. Available
from http://www.brics.dk/JSA/.
[14] M. Christodorescu, N. Kidd, and W.-H. Goh. String analysis
in x86 binaries. In Proc. of the 6
ACM Workshop on Pro-
gram Analysis for Software Tools and Engineering PASTE,
2005.
th
[15] E. Clarke, O. Grumberg, and D. Peled. Model Checking.
The MIT Press, 1999.
[16] E. Clarke, D. Kroening, and F. Lerda. A tool for checking
ANSI-C programs. In K. Jensen and A. Podelski, editors,
Tools and Algorithms for the Construction and Analysis of
Systems (TACAS 2004), volume 2988 of Lecture Notes in
Computer Science, pages 168–176. Springer, 2004.
[17] M. Cost, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou,
L. Zhang, and P. Barham. Vigilante: End-to-end contain-
ment of internet worms. In 20
ACM Symposium on Oper-
ating System Principles (SOSP 2005), 2005.
th
[18] P. Cousot and R. Cousot. Abstract interpretation: a uniﬁed
lattice model for static analysis of programs by construction
or approximation of ﬁxpoints.
ACM Sympo-
sium on Principles of Programming Languages (POPL), Jan
1977.
In Proc. 4
th
[19] J. Crandall, Z. Su, S. F. Wu, and F. Chong. On deriving un-
known vulnerabilities from zero-day polymorphic and meta-
morphic worm exploits. In Proc. 12th ACM Conference on
Computer and Communications Security (CCS), 2005.
[20] D. Detlefs, G. Nelson, and J. Saxe. Simplify: A theorem
prover for program checking. Technical Report HPL-2003-
148, HP Labs, 2003.
[21] T. Detristan, T. Ulenspiegel, Y. Malcom, and M. V. Under-
duk. Polymorphic shellcode engine using spectrum analysis.
http://www.phrack.org/show.php?p=61&a=9.
[22] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed au-
tomated random testing. In Proc. of the 2005 International
Conference on Programming Language Design and Imple-
mentation (PLDI), 2005.
[23] A. Gotlieb, B. Botella, and M. Rueher. Automatic test data
In ACM
generation using constraint solving techniques.
Symposium on Software Testing and Analysis, 1998.
[24] A. Gotlieb, B. Botella, and M. Rueher. A clp framework for
computing structural test data. In First International Con-
ference on Computational Logic, 2000.
[25] N. Gupta, A. Mathur, and M. L. Soffa. Automated test data
generation using an iterative relaxation method.
In ACM
SIGSOFT Symposium on Foundations of Software Engineer-
ing, 1998.
[26] J. Hopcroft, R. Motwani, and J. Ullman.
Introduction to
automata theory, langauges, and computation. Addison-
Wesley, 2001.
[27] D. Jackson and E. Rollins. Chopping: A generalization of
slicing. In Proc. of the Second ACM SIGSOFT Symposium
on the Foundations of Software Engineering, 1994.
[28] M. Jordan. Dealing with metamorphism. In Virus Bulletin
Magazine, 2002.
[29] G. Kildall. A uniﬁed approach to global program optimiza-
tion. In 1st ACM Symposium on Principles of Programming
Languages (POPL), 1973.
[30] H.-A. Kim and B. Karp. Autograph:
toward automated,
distributed worm signature detection. In Proc. of the 13th
USENIX Security Symposium, August 2004.
[31] J. King. Symbolic execution and program testing. Commu-
nications of the ACM, 19:386–394, 1976.
[32] C. Kreibich and J. Crowcroft. Honeycomb - creating intru-
sion detection signatures using honeypots. In Proc. of the
Second Workshop on Hot Topics in Networks (HotNets-II),
November 2003.
[33] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vi-
gna. Polymophic worm detection using structural informa-
tion of executables. In Rapid Advances in Intrusion Detec-
tion (RAID), 2005.
[34] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. Static
In Proc. of the 13th
disassembly of obfuscated binaries.
USENIX Security Symposium, 2004.
[35] Z. Liang and R. Sekar. Fast and automated generation of at-
tack signatures: A basis for building self-protecting servers.
In Proc. of the 12th ACM Conference on Computer and
Communications Security (CCS), 2005.
[36] M. E. Locasto, K. Wang, A. D. Keromytis, and S. J. Stolfo.
In Proc. of
International Symposium on Recent Advances in In-
FLIPS: Hybrid adaptive intrustion prevention.
the 8
trusion Detection (RAID 2005), 2005.
th
[37] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood. Pin:
Building customized program analysis tools with dynamic
instrumentation. In Proc. of 2005 Programming Language
Design and Implementation (PLDI) conference, june 2005.
[38] A. Milenkovic, M. Milenkovic, and J. Kulick. N-tuple com-
pression: A novel method for compression of branch in-
struction traces. In Proc. of the 16
international confer-
ence on parallel and distributed computing, 2003.
th
[39] M. Mohri and M.-J. Nederhof. Robustness in Language and
Speech Technology. Kluwer Academic Publishers, 2001.
[40] D. Moore, C. Shannon, G. Voelker, and S. Savage. Internet
quarantine: Requirements for containing self-propagating
code. In 2003 IEEE Infocom Conference, 2003.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
[41] S. Muchnick. Advanced Compiler Design and Implementa-
tion. Academic Press, 1997.
[42] N. Nethercote and J. Seward. Valgrind: A program supervi-
sion framework. In Proc. of the Third Workshop on Runtime
Veriﬁcation (RV’03), Boulder, Colorado, USA, July 2003.
[43] J. Newsome, B. Karp, and D. Song. Polygraph: Automati-
cally generating signatures for polymorphic worms. In Proc.
of the IEEE Symposium on Security and Privacy, May 2005.
[44] J. Newsome and D. Song. Dynamic taint analysis for au-
tomatic detection, analysis, and signature generation of ex-
ploits on commodity software.
In Proc. of the 12th An-
nual Network and Distributed System Security Symposium
(NDSS), February 2005.
[45] B. C. Pierce. Types and Programming Languages. The MIT
Press, 2002.
[46] r code.
ATPhttpd exploit.
http://www.cotse.
com/mailing-lists/todays/att-0003/
01-atphttp0x06.c.
[47] Y. Ramin. ATPhttpd. http://www.redshift.com/
∼yramin/atp/atphttpd/.
[48] T. Reps and G. Rosay. Precise interprocedural chopping. In
Proc. of the Third ACM SIGSOFT Symposium on the Foun-
dations of Software Engineering, 1995.
[49] P. A. Sandon, Y. Liao, T. Cook, D. Schultz, and P. M.
de Nicolas. Nstrace: A bus-driven instruction trace tool for
powerpc microprocessors. IBM Journal of Research and De-
velopment, 41(3), 1997.
[50] S. Singh, C. Estan, G. Varghese, and S. Savage. Automated
worm ﬁngerprinting. In Proc. of the 6th ACM/USENIX Sym-
posium on Operating System Design and Implementation
(OSDI), Dec. 2004.
[51] S. Staniford, V. Paxson, and N. Weaver. How to 0wn the
Internet in your spare time. In 11th USENIX Security Sym-
posium, 2002.
[52] P. Szor. Hunting for metamorphic. In Virus Bulletin Confer-
ence, 2001.
[53] R. A. Uhlig and T. Mudge. Trace-driven memory simula-
tion: a survey. ACM Computing Surveys, 29, 1997.
[54] US-CERT. Vulnerability note vu#196945 - isc bind 8 con-
tains buffer overﬂow in transaction signature (tsig) han-
dling code. http://www.kb.cert.org/vuls/id/
196945.
[55] P. Vixie, O. Gudmundsson, D. Eastlake, and B. Wellington.
RFC 2845: Secret key transaction authentication for dns
http://www.ietf.org/rfc/rfc2845.
(TSIG).
txt.
[56] H. J. Wang, C. Guo, D. Simon, and A. Zugenmaier. Shield:
Vulnerability-driven network ﬁlters for preventing known
vulnerability exploits. In Proc. of the 2004 ACM SIGCOMM
Conference, August 2004.
[57] M. Weiser. Programmers use slices when debugging. Com-
munications of the ACM, 25:446–452, 1982.
[58] J. Xu, P. Ning, C. Kil, Y. Zhai, and C. Bookholt. Automatic
diagnosis and response to memory corruption vulnerabili-
ties. In Proc. of the 12
ACM Conference on Computer and
Communication Security (CCS), 2005.
th