## Page 213
这样就能看到，它是只在特定时机发生，还是频繁发生。
路径（尽管本来并非用于该目的），输出的信息可以从视觉上确认，这也是个优点。
WARN_ON()是内核内部的宏，可以显示栈跟踪以引起注意。这里用它来确认函数调用
3-1. 用WARN_ON()确认
的话，某个 inode一开始被创建就应该会被 iput()释放。这里用 WARN_ON()确认路径
inode 是种缓存，可以加速对同一文件的访问，因此反复进行文件创建、删除操作
以便将其释放。然后执行 clear_inode()、destroy_inode()删除该 inode。
iput()是什么函数。iput()给 inode 加上个标志表示已释放，并从管理列表中删除
generic_drop_inode()。由于数量很多，全部确认相当花时间，因此首先调查一下
考虑图 5-5 中的进程 X。许多路径都会调用 iput()，而iput()会调用
3. 确认路径 1
首先要调查源代码，从某种程度上确认假说是否成立。
试程序。
进程X和Y互斥后，可能会发生 panic 或其他故障。为证实这一点，下面来编写测
调查源代码，并将互斥的原理总结如图5-5。
2.调查源代码
1是否会被执行。
inode_lock的可能性就更高了。
CONFIG_PREEMPT，那么等待获取 inode_lock 的进程可能会自行切换，其他 CPU 获得
像这样在中途解锁之后，其他 CPU 就有可能获得 inode_lock。如果启用了
destroy_inode(inode);
clear_inode(inode);
truncate_inode_pages(&inode->i_ data, 0); 
if (inode->i_data.nrpages)
spin_unlock(&inode_lock) ;
www.TopSage.com
HACK#35  kernel panic I  195
”所以要在锁保护中做减操作
解锁
202
201
---
## Page 214
文件系统为 ext3。
的行为和原理"。inode 依赖于文件数量，因此将文件大小设小一些，设置为10MB，
应用下面的补丁后，
图 5-5 互斥的原理
1961第5章实践内核调试
@@ -1035,6 +1036,7 @@ static void generic_forget_incde(struct
+++ fs/incde.c 2008-10-13 21:47:40.000000000 +0900
--- fs/inode.c.orig
进程X
路径1
write_inode_now(inode, l);
if (!sb ll (sb->s_flags & MS_ACTIVE))
WARN_ON(1);
spin_unlock(&inode_lock) ;
inodes_stat.nr_unused++;
iput_final()
return;
list_move(&inode->i_list, &inode_unused);
重新编译内核。
2005-06-18 04:48:29.000000000 +0900
www.TopSage.com
spin_lock(inode_lock)
spin_unlock(inode_lock)
generic_drop_inode()
destroy_inode()
clear_inode()
←
{generic_drop_inode+152){prune_dcache+806}
Badnessingeneric_forget_inode atfs/inode.c:1038
#stress --hdd 1 --hdd-bytes 10M
{autoremove_wake_function+0){sys_unlink+313}
{:ext3:ext3_file_write+22}
{generic_file_aio_write+126}
{generic_file_aio_write_nolock+32}
_generic_file_aio_write_noloc+731}
{generic_file_buffered_write+413}
{shrink_dcache_memory+20}{shrink_slab+188]
{error_exit+0)
{thread_return+0}{thread_return+88}
{handle_m_fault+226}{do_page_fault+520}
{get_zeroed_page+26}{pte_alloc_map+47}
{try_to_free_pages+348}{_alloc_pages+527}
{shrink_dcache_memory+20}{shrink_slab+188}
www.TopSage.com
lopSage.com
203
---
## Page 216
204
件删除或内存释放时，释放处理不会立即被执行，只有在内存不足时才会进行释放
起释放掉。此时，似乎会执行 prune_icache()，这是因为，Linux 的结构决定了文
在没有空闲内存的状态下试图分配内存时，__alloc_page()就会将无用的 inode 一
接下来根据源代码确认--下 prune_icache()路径。调查的结果如图 5-6 所示。
进行了操作。
的 prune_icache()，这是因为 prune_icache()也对 inode_Lock 和 inode_unused 链表
inode_lock 加锁之后，对 inode_unused链表进行了操作。因此，请注意 fs/inode.c
下面调查一下，执行路径 2 的进程 Y 属于什么情况。这里进程 X 中的 iput()对
4.路径2的确认
这样就能确认，刚才的 stress 命令和 umount 命令执行后，路径1被执行了。
执行umount后，控制台显示内容如下。
因此在挂载的文件系统上写入大量文件，然后删除，再卸载。
系统时，文件会执行 sync，相关的缓存就会被全部删除。
调查源代码就会发现，卸载（unmount）处理也会调用iput()。这是因为卸载文件
198丨第5章实践内核调试
处理。
 Badness in generic_forget_inode at fs/inode.c:1038 
Call Trace:{generic_drop_inode+152) :jbd: joumal_ destroy557}
# umount /mnt/10
# cd-
# rm -rfv * 
# stress --hdd 5 --hdd-bytes 10M --hdd-noclean -t 5
# cd /mnt/10
# mount /dev/sda10 /mnt/10
{system_call+126}
(sys_ ewstat+17> fff80110d9d-error_ ext+0}
{deactivate_super+95) sys_umount+925}
{:ext3:ext3_put_super+38][:ext3:ext3_put_super+0}
[autoremove_wake_function+] [autoremove_wake_ function+0}
sys_write+69) system_cal+126}
www.TopSage.com
---
## Page 217
除刚才 generic_forget_inode()中的 WARN_ON(1)。补丁如下。
接下来重新编译内核，同样利用 wARN_ON()确认 prune_icache()是否被执行，同时删
内存的问题。
中也会调用 iput()。如果互斥处理不完善，就可能产生双重释放进程X 已释放的
由于是kswapd()，所以只需消耗内存，让交换区工作应该就可以。prune_icache()
图5-7确认路径 2(2)
图5-6确认路径2
还有一条由kswapd开始的路径（图5-7)。
@ -1035,7 +136,6 c@ static void generic_forget_inode(struct
@ -443,6 +443,7 @@ static void prune_icache(int nr_to_scan)
+++ fs/inode.c.next 2008-10-14 22:30:04.00000000 +0900
--- fs/inode.c 2008-10-14 22:47:19.00000000 +0900
if (inode_has_buffers(inode) ll inode->i_data.nrpages) {
>try_to_free_pages()
iput(inode);
if (remove_inode_buffers(inode))
WARN 0N(1);
spin_unlock(&inode_lock);
-_iget(inode);
> shrink slab()
reap += invalidate_inode_pages(&inode->i_data);
kswapd()
>shrink_ icache_memory()
> shrinker->shrinker
balance_pgdat()
www.TopSage.com
> prune_icache()
> shrink slab()
>iput()
> prne_icache()
/÷释放 inode ★/
/★由 set,shrinker设置*/
/±试图释放slab缓存+/
/★如果没有空闲内存★/
HACK#35 kernel panic 1 199
---
## Page 218
206
以用 crash在运行中的系统上确认。
通常，shrink_icache_memory()只会处理未使用的 inode 数 nr_unused。 nr_unused 可
释放的 inode 数。
/proc/sys/vm/vfs_cache_pressure 改变。增大该值,可以增加 shrink_icache_memory()
return 值变化。sysctl_vfs_cache_pressure 是sysctl的参数，可以通过
从 shrink_icache_memory()的代码可见，sysctl_vfs_cache_pressure 的值会导致
4-1. 调整参数 vfs_cache_pressure 
然而并没有出现 WARN_ON()信息，也就是说路径2未通过。那调整一下参数试试看。
vm_stress.sh在后台执行，20 秒内给内存增加负载，然后休息2秒。
__alloc_pages()就会执行 OOM Killer，因此要让内存负载分出强弱来。下面的脚本
__alloc_pages()会尽可能释放 inode 等未使用的缓存，但如果无法分配足够的内存,
接下来要给这个内核增加负载，但执行时间过长途中就会被 OOM Kiler 中断。
200
crash> struct -o inodes_stat_t inodes_stat
# stress --hdd 1 --hdd-bytes 10M
# ./vm_stress.sh &
while[0］;do
#!/bin/bash
# cat vm_stress.sh
struct inodes_stat_t {
dummy = {0, 0, 0, 0, 0} 
nr_unused = 15, 
nr_inodes = 1658,
done
sleep 2
  1o-- daa--- wo sa--- -- 
第5章实践内核调试
write_inode_now(inode, 1);
if (!sb [1 (sb->s_flags & MS_ACTIVE))
WARN_ON(1) ;
spin_unlock(&inode_lock);
inodes_stat.nr_unused++;
return;
list_move(&inode->i_list, &inode_unused);
www.TopSage.com
---
## Page 219
页面（http://www.oreilly.co.jp/books/9784873114040/） 下载。
执行脚本 inode.sh后，kswapd模式的信息也出现了（inode.sh脚本请从本书的支持
载的分区，每个分区上用4个 stress 进程执行I/O。
但是，kswapd模式的信息并没有输出，那再加一些进程试试。准备 4个测试 I/O 负
执行 vm_stress.sh后，wARN_ON()输出了信息。
们将 vfs_cache_pressure 设置为 5000（50 倍)。
于 nr_unused，prune_icache()执行期间增加的未使用的 inode 也能被释放。所以我
设置到100 以上，那么 shrink_icache_memory()开始执行时，即使未使用 inode 数等
nr_unused 为系统此刻的值，在有负载的情况下会不断增加。将 vfs_cache_pressure
# echo 5000 > /proc/sys/vm/vfs_cache_pressure
Call Trace:[shrink_icache_memory309}
Badness in prune_icache at fs/inode.c:446
#./inode.sh
# ./vm_stress.sh &
Call Trace:{shrink icache_ memory309} (shrink_ slab+188}
 Badness in prune_icache at fs/inode.c:446
crash>
{shrink_slab+188}
_up write+20x -eror_ exit+0}
{thread_return+88} {do_mmap_pgoff+1581]
{try_to_ free_pages+348} {_alloc_pages+527}
{kswapd+0}
{child_rip+8}
{autoremove_wake_function+0}
{autoremove_wake_function+0}
{kswapd+252}
{balance_pgdat+538}
www.TopSage.com
HACK#35 kernel panic | 201
207
---
## Page 220
208
用下面的修改程序试试看。mdelay（）延迟了50毫秒。
用mdelay()提高复现率
内核中还有个msleep（）睡眠函数，但它会导致进程调度，所以这里不用它。
的时机也就容易捕获了。
行延迟。这样就能延长 spin_unlock()到spin_Lock()的时间，进程X和进程Y互斥
为了让复现更容易些，我们添加了mdelay（）。mdelay(）的意思是不进行调度，只进
在不包含WARN_ON(）的正常内核上执行脚本几个小时，bug都没有复现。
5-1.在正常内核上进行复现试验
vm_stress.sh和inode.sh。两条路径都是瞬间走完的，所以故障也不可能立即发生。
发生。我们同时执行通过路径1的umount命令和通过路径2的复现测试程序
接下来使用刚才建立的脚本，在没有添加WARN_ON()的正常内核上看看bug是否能
5.复现bug
之后，就会通过路径2。
2021
@-1035,6+1036,7@@ static void generic_forget_inode(struct
@@-443,6+443,7@@ staticvoid prune_icache（intnr_to_scan)
++fs/inode.c2008-10-1620:39:42.000000000+0900
---fs/inode.c.0rig2008-10-16 20:47:38.0000000+0900
第5章实践内核调试
if(inode_has_buffers(inode) | inode->i_data.nrpages){
if（!sb ||(sb->s_flags&MS_ACTIVE))
mdelay(50);
spin_unlock(&inode_lock);
inodes_stat.nr_unused++;
return;
list_move(&inode->i_list,&inode_unused）;
iput(inode);
if(remove_inode_buffers(inode))
mdelay(50);
spin_unlock(inode_lock);
_iget(inode);
reap +=invalidate_inode_pages(&inode->i_data);
www.TopSage.com
---
## Page 221
应用内核2.6.12 的补丁（backport）后，这个 bug 就被修改了。
6．确认社区的修改历史
是获得转储的 backtrace。umount 命令调用 generic_drop_inode()时发生了 panic。
利用加入了 mdelay()的内核和改进后的测试程序，几分钟后 bug 就复现了。下面就
9784873114040/）下载)。
我们还进一步改进了复现测试程序，调整了睡眠时间、IVO 大小、内存负载的比例
#15 [10042975f50] error_exit at fffffff8011d9d
#14 [10042975ef0] sys_newstat at fffffff80182a44
PID: 4733 TASK: 100139c27f0
crash> bt
#
ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018
R13: 000001013ab46800 R14: 000001013a187d78 R15: 0000010042975d58
[10042975ed0] sys_umount at ffff80195217
[10042975e50] ext3_put_super at ffffffa00913dd
[10042975d50] write_inode_now_err at ffffffff80199204
[10042975d10]
RIP: ffffffff80199088 RSP: 0000010042975d18 RFLAGS: 00010246
[exception RIP: _writeback_single_inode+643]
[10042975ea0]
[10042975e80]g
[10042975db0] generic_drop_inode at ffffffff80193388
[10042975c00] find_get_pages_tag at fffffff8015b24c
[10042975b80] do_page_fault at fffffff80123978
[10042975b70] try_crashdump at ffffff8014bd01
[10042975b40] start_disk_dump at fffffffa01a336d
[10042975eb0]d
10042975dd0]i
确认即使加入 mdelay()也不会复现，是很重要的。
write_inode_now(inode, 1);
generic_shutdown_super at fffffff8017f855
writeback_single_inode at ffffff80198f96