- 去重：通过排序或者散列来实现，去除蛋复的代价相对较大，所以需要显式指明
- 投影：需要做的就是去除重复元组
- 集合运算：一种实现方式是在内存中将一个关系建立散列表，提升对比速度
- 外连接：在连接的基础上，要考虑某一个集合没有值的情况，并将没值的情况写入结果集
- 聚合运算：也可以通过排序与散列来实现，可以边遍历记录，边计算结果
### 表达式计算
- 物化：计算的中间结果写入磁盘，这种计算的代价还要考虑写磁盘的代价
- 流水线：多个运算组合成一个操作的流水线，一个记录经过操作完成之后，马上就可以传送到下一个操作，相比物化，这种不仅可以减少写临时磁盘的代价，而且流水线还能让用户更早看到结果，流水线的实现：
  - 消费者驱动：各个操作节点都有一个迭代器，不断获取下一条记录，下一条记录都是来自于上一个操作节点
  - 生产者驱动：从源头输入数据，同时维护一个缓存区域用来存放中间结果，数据直接在各个操作节点之间单向流动
## 查询优化原理
一个给定的查询，通常会有许多种可能的执行策略，查询优化就是从这许多策略中找出最搞笑的查询执行计划的过程
产生逻辑一致的表达式 -> 产生不同的查询计划 -> 评估查询计划，选择代价最小的
### 关系表达式的转换
如果两个关系表达式在每一个有效数据库实例中都会产生相同的元组集，则称它们是等价的
#### 等价规则
如集合的结合律：$$(E1\cup E2) \cup E3 = E1\cup (E2 \cup E3)$$
#### 连接的次序
巧妙编排连接中关系的顺序可以有效减少临时结果大小
一个小关系连接大关系比大关系连接小关系查的更快
#### 等价表达式的枚举
为了查询得到所有等价表达式，通过递归将子表达式进行等价替换来得到所有等价的表达式，在枚举这些表达式的过程中，可以根据代价来对一些表达式进行剪枝
### 表达式结果集统计大小的估计
为了计算查询的代价，要通过一些统计信息来进行，这个估计并不十分精确，这些统计数据大部分都是通过随机抽样来生成的，还有些数据库不会自动更新统计数据，而是让 DBA 手动运行命令的方式来进行生成
整体来说，这一部分就是要通过计算概率的方式，来计算出执行的代价
- 目录信息：根据表的记录数、每条记录的大小等信息
- 选择运算结果大小的估计：选择的数据占总体数据的量
- 连接运算结果大小的估计：两张表进行连接，最简单的形式就是笛卡尔积，数量是两张表相乘，其他的则要根据连接的属性来进行估算
### 执行计划选择
- 基于代价的连接顺序选择：多个关系连接的最优方式，可以看作是一个动态规划问题，找到这些关系的最优连接方式
- 等价规则的基于代价的优化器：为了在众多的查询计划找到最优的计划，要做到：如何用较少的空间表达查询计划、如何检测相同的表达式、如何使用动态规划高效找出最优计划、通过贪心 + 剪枝的方式找到最优...
- 启发式优化：这种优化方式尽早执行运算，比如选择运算不一定可以降低执行代价，但有时投影运算可以大大减小关系，通过配合基于代价的优化，来达到一个不错的效果
- 嵌套子查询的优化：对于每个元组，都会执行一次子查询，代价很大，一种优化方式是将其转成连接，但是很多嵌套子查询没有转连接的通用算法，还是要在使用上，避免使用子查询
### 物化视图
通过冗余，其内容已计算并存储的识图，这种物理视图的读取代价比逻辑视图低
#### 视图维护
手工代码维护：真正的数据修改之后，再额外去修改物化视图的数据
增量视图维护：这种就是根据视图的查询语句，计算每次更新与物理视图会产生什么差异，再由系统去修改视图的数据，如：
- count：删除数据-1，插入数据+1
- ...
#### 查询优化和物化视图
物化视图可以被用来优化一些查询，假设要查询 a join b join c
现有 物化视图 v = a join b，通过 v join c 可以有效降低临时结果，降低查询代价
反过来也是 如果物化视图查询代价过高，可以把它拆分成原始查询
### 其他优化
- top-K优化：取出前 k 个最大的数据。一种方式是通过流水线，可以源源不断产生数据，另外一种方式则是估计出前 K大的值是什么，然后遍历直至找到
- 连接简化：某些查询下，连接是没有意义的，可以优化掉，一般是定义视图，视图又连接其他关系，导致重复
- 多查询优化和共享式扫描：同时提交的查询语句，可以有共用的表达式，那就可以缓存表达式，提升效率
- 参数化查询优化：在选取最优查询计划时，还要考虑条件的参数值，不同的参数值执行代价可能不一样
## 数据库体系结构
- 两层体系结构：客户端直接与数据进行交互
- 三层体系结构：客户端通过一个服务端与数据进行交互
### 集中式系统
运行在单台计算机系统上，不与其他计算机系统交互
粗粒度并行的机器只有几个核心，一般一个查询只会跑在一个核心上
细粒度并行的机器则有大量处理器，将并行执行用户提交的查询
### CS系统
```mermaid
sequenceDiagram
  客户端 ->> 服务端: 提交查询
  服务端 ->> 客户端: 返回结果
```
### 服务器系统体系结构
![20230508204638](/assets/20230508204638.png)
### 并行系统
通过增加并行度在更短的时间内运行一个给定的任务称为加速比(speedup)。通过增加并行度来处理更大的任务称为扩展比(scaleup)
![20230508204919](/assets/20230508204919.png)
![20230508204943](/assets/20230508204943.png)
![并行数据库体系结构](/assets/20230508205241.png)
## 并行数据库
并行系统设计需注意到的可用性问题：
- 硬件发生故障时的恢复性
- 数据和模式支持在线变更
### IO 并行
将关系划分到多张磁盘上来缩减从磁盘上对关系进行检索所需的时间，是一种数据分区
划分技术：
- 轮转分区
- 散列分区
- 范围分区
除了轮转分区，其他两种方式都有可能产生数据倾斜，为了规避倾斜，通常有两种方式：
1. 事先进行统计，根据数据的分布规划分区
2. 一致性哈希
### 查询间并行
> 不同查询或事务彼此并行执行
这种并行需要考虑不同节点之间的数据一致性问题
### 查询内并行
> 单个查询在多个处理器和磁盘上并行执行
- 操作内并行：并行地执行每个运算来提升速度，像是并行归并排序、根据属性分区后并行join
- 操作间并行：并行地执行一个查询表达式中的多个不同的运算来提升速度，如流水线并行，不需要等待结果全部计算完毕，就可以把中间结果源源不断发射给下游，还有就是互不依赖的运算也可以独立并行
并行需要考虑以下代价：
1. 启动运算的代价
2. 数据倾斜导致计算不均衡
3. 数据的并发竞争
4. 各个节点计算完成之后统一汇总的代价
并行使得查询优化更复杂：代价模型更复杂、考虑倾斜、并发竞争...
## 分布式数据库
> 服务于写多读少、低延时、海量并发 OLTP 场景的，具备海量数据存储能力和高可靠性的关系型数据库
### 一致性
观察数据一致性的两个视角：
- 状态一致性是指，数据所处的客观、实际状态所体现的一致性
- 操作一致性是指，外部用户通过协议约定的操作，能够读取到的数据一致性
### 架构风格
#### PostgreSQL-XC
- 分片、分布式事务、跨节点查询和全局时钟
![20221212171450](/assets/20221212171450.webp)
#### NewSQL
- 基于分布式KV存储系统，存储与计算分离，拥有更高的伸缩性
![20221212171629](/assets/20221212171629.webp)
很多产品为了获得更好的计算性能，会尽量将更多计算下压到存储节点执行，更偏向于PostgreSQL-XC风格
### 全局时钟
- 时间源
- 时钟类型
- 授时点
#### TrueTime
时间源是 GPS 和原子钟，所以属于多时间源和物理时钟，同时它也采用了多点授时机制，依赖于特定硬件设备
#### HLC
每个节点会使用本地时钟作为参照，但不受到时钟回拨的影响，可以保证单调递增。本质上，HLC 还是 Lamport 逻辑时钟的变体，所以对于不同节点上没有调用关系的两个事件，是无法精确判断先后关系的
#### TSO
![20221212172944](/assets/20221212172944.webp)
#### STP
![20221212173331](/assets/20221212173331.webp)
### 可用性
分布式数据库为了提升可用性：
- 基于多数的方法：读写操作都要通过超过半数节点才认为成功
- 读一个写所有：可以从任意一个节点读数据，但写数据要所有节点写成功才认为是成功
- 牺牲一致性：BASE
### 分布式查询处理
由于分布式数据库引入了分区，在进行查询时就没那么方便了，执行器要根据where条件决定去哪里查，还有join也封复杂了，查询符合条件的数据要如何查代价才小，还有查询完成之后的汇总合并
## 特种数据库
- 面向对象数据库
- 半结构化数据库
## 数据库系统的历史
- 1950s-1960s：磁带存储
- 1960s-1970s：硬盘
- 1980s：关系数据库取代网状数据库
- 1990s：互联网与数据库
- 2000s：数据分析与数据库
## NoSQL
充分利用各种不同NoSQL数据库的特性来助推业务
- MongoDB 的文档特性
- Redis 的快速寻址特性
- ...