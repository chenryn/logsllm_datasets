复杂很多，而且会得到一个速度很慢的正则表达式。
逐行处理字符事还使得我们可以比较容易对正则表达式进行取反。正则表达式并没有
提供简单的方式来解决“匹配不包含这个或那个单词的一行内容”。只有字符类才能很
容易地被取反。但是如果你已经把字符事拆分成了行，那么找到不包含某个单词的行
就变得非常容易，你只需在所有行上进行字面文本查找，然后去掉那些没有找到该单
词的行即可。
实例3.19中讲解了如何把一个字符串拆分为数组。正则表达式（lrlin）会匹配一对CR
和LF字符，它们是在MicrosoftWindows平台上使用的换行符号。来对它进行
拆分。通过把CR变成可选的，这个正则式就可以同时匹配一个CRLFWindows换行，
或者一个LFUnix换行。
一旦把字符事放到了数组中，你就可以很容易地对它进行循环访问。在循环中，按照
实例3.5中给出的解决方案来检查哪些行会匹配，而哪些行不会匹配。
参见
实例3.11和3.19
202第3章
www.TopSage.com
---
## Page 219
第4章
合法性验证和格式化
本章的实例会讲解如何对常见类型的用户输人进行合法性验证和格式化。其中有些解
决方案会向读者展示如何支持合法输人的不同变种，例如，美国邮政编码可以包含5
位或者9位数字。其他一些实例中的正则表达式则会对诸如电话号码、日期和信用卡
号码等数据对应的常见格式进行矫正或整理。
除了可以帮助你完成排除不合法输人的任务之外，这些实例还会帮助你改进应用程序的用
户体验。如果经常在电话或信用卡号码输人框旁边显示诸如“缺少空格或连字符”的消息，
就会让用户感到很沮丧，有时还会被用户直接忽略。幸运的是，在许多情况下，你只需要
做很少量的工作，正则表达式就可以允许用户按照他们认为熟悉和方便的格式输人数据。
某些编程语言会在它们的内置类或函数库中提供与本章中某些实例类似的功能。根据
你的具体需要，也可能使用这些内置的方式会更好一些，因此我们也会在适当的时候
指出你可能拥有的选择。
4.1E-mail地址的合法性验证
问题描述
在你的网站或者应用程序的对话框中，有一个输人框要求用户输人-个电子邮件
(E-mail）地址。在使用这个地址发送E-mail之前，你要使用一个正则表达式来对它进
行合法性验证，这会有助于减少你可能会收到的由于无法投递而返回的邮件数量。
解决方案
简单形式
这第一个解决方案只进行非常简单的检查。它只会验证E-mail地址中包含了单个的@
203
www.TopSage.com
---
## Page 220
符号，并且不包含任何空白：
\S+@\S+$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
\A\S+S+
正则选项：无
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
对字符加限制的简单形式
在@符号之后的域名部分被限制为只能使用域名中允许的字符。在@符号之前的用户
名部分被限制为只能使用在E-mail用户名中常见的字符，这比大多数邮件客户端和服
务器所接受的标准要更为严格：
s+[-'6-02-]+[-·+6-02-]
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
\A[A-Z0-9+_.-]+@[A-Z0-9.-]+\Z
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
包括所有字符的简单形式
这个正则表达式对上一个进行了扩展，它允许在用户名中使用更大范围的较少使用的
学符。不是所有的E-mail软件都能够处理所有这些字符，但是我们在这里包括了规定
E-mail消息格式的RFC2822标准中充许的所有字符。在这些允许的字符中，如果直接
把它们从用户输人传递给一个SQL语句，其中有些字符可能会带来潜在的安全风险，
比如单引号（）和管道符号（1）。当你把E-mail地址插人到传递给另外一个程序的字
符串中之前，一定要记住对这些敏感字符进行转义，这样就可以避免诸如SQL注人攻
击这样的安全漏洞。
$+[-*6-0z-]+[-*~{1}=/+S#i\]
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
2\+[-*6-02-]+[-*~{1}=/+#M\]
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
不充许前导、拖尾或连续的点号
在用户名和域名中都可以包含一个或多个点号，但是不允许出现两个连续的点号。另
外，在用户名和域名中的第一个和最后一个字符都不允许是点号：
（+[-~{1}=/+，9%S#i]·\：2)+[-~{1}=/+3名S#iM\]
[A-Z0-9-]+(?:\.[A-20-9-]+) *$
204第4章
www.TopSage.com
---
## Page 221
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
￥（+[=~{1}=/+，9S#i]·\：）+[-~{1}=/+，9S#iM\]\
[A-Z0-9-]+(?:\.[A-Z0-9-]+) *\Z
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
顶级域名必须包含2~6个字母
在前一个版本的正则表达式上添加了新的要求：域名必须至少包含一个点号，而且在
最右边的点号之后的域名只能包含字母。也就是说，域名必须至少包含两级，例如
secondlevel.com或thirdlevel.secondlevel.com。而顶级域名，比如.com，则必须由2～6
个字符组成。所有国家代码的顶级域名都包含2个学母。而普通顶级域名则会包含
3（.com）～6个字母（.museum）：
[\w1$&*+/=？*{1}~-]+(？:\.[#$&*+/=？*{1} ~] +) *@
(?：[A-20-9-]+\.)+[A-2]{2,6}S
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
（+[-~{1]，=/+，9S#i]\：）+[-~{1}=/+9S#iM\]\
(？:[A20-9-]+\.)+[A-Z]{2, 6}\2
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
讨论
关于E-mail地址
如果你认为像验证E-mail地址这样概念上很简单的任务，可以使用一个简单普适的正
则表达式解决方案，那就大错特错了。这个实例告诉我们，在你开始写正则表达式之
前，你必须先严格地确定到底想要匹配什么。至于说哪些E-mail地址合法而哪些不合
法，并没有普遍认可的规则。这要取决于你如何来定义合法性。
根据定义E-mail地址语法的RFC2822标准，PI:EMAIL是合法的。但是如果在你
的定义中要求一个合法E-mail地址必须是可以接收邮件的地址，那么上述地址就是不
合法的。因为并不存在asdf这样的顶级域名。
对合法性问题的简单回答是：如果你实际上不去尝试给PI:EMAIL发送
邮件，就不可能确切知道它是不是一个可以接收邮件的地址。事实上，就算你发了邮
件，如果没有收到回复，你也不知道是somewhere.com域名把发送给不存在的邮箱的
邮件悄悄丢掉了，还是JohnDoe自已删除了你的邮件，抑或是他的垃圾邮件过滤器先
他一步把你的邮件删掉了。
合法性验证和格式化205
www.TopSage.com
---
## Page 222
因为你最终反正都需要实际发一封邮件才能检查该地址是否真的存在，因此可以选择
使用一个稍微简单一些、不是那么严格的正则表达式来检查它。充许出现一些不合法
的地址，可能会比不接受合法的地址让人觉得更容易接受。基于这个原因，你可能会
倾向于选择前面“包含所有字符的简单形式”的正则表达式。虽然它显然会接受很多
不是E-mail地址的输入，比如说#$%@，但是这个正则式速度快而简单，并且它拥有
也不可能拒绝任何合法的E-mail地址。
如果你想要避免发送太多无法投递的邮件，而依然不想拒绝任何真实E-mail地址，那
么你应当选择在“顶级域名必须包含2～6个字母”中的正则表达式。
你还必须要考虑充许正则表达式复杂到什么程度。如果在验证用户输入，那么你可能
想要一个更复杂的正则式，因为用户可能会输入任何东西。但是如果是在扫描一个数
据库文件，而你知道其中只会包含合法邮件地址的话，那么就可以使用一个非常简单
的正则式，只需把E-mail地址同其他数据区分开来即可。即使在前面的“简单形式”
小节中的解决方案也足以应付这种情况。
最后，你还必须要考虑是否期待你的正则表达式满足未来可能发生的变化。在过去，
一种合理的做法是把顶级域名限制为只能使用2个字母的国家代码组合，并且列出所
有可能的普通顶级域名，也就是使用。由于总是会有新的顶级域名
不断加人，所以这样的正则表达式很快就会过时。
正则表达式的语法
这个实例所给出的正则表达式中，使用了正则表达式语法的所有基本组成部分。如
果阅读了第2章中的相关部分，那么你已经可以完成正则表达式最适合解决的问题
的90%
本实例中的所有正则表达式都要求打开不区分大小写的选项。否则，在邮件地址中就
会只允许出现大写字符。在把这个选项打开之后，你就可以输人[A-Z]，而不必再用
和是简写的字符类，它们在实例2.3中进行了讲解。会匹配任意非空白字
符，而w会匹配一个单词字符。
《@>和<>会分别匹配一个字面的@符号和一个点号。由于点号在字符类之外使用时是
一个元字符，所以需要对它使用反斜杠来转义。在本书中介绍的所有正则表达式流派
中，@符号都不会拥有任何特殊含义。实例2.1中给出了所有需要转义的元字符的一个
列表。
和位于方括号之间的其他序列是字符类。这个字符类允许出现在A和Z之
间的所有字母、0和9之间的所有数字，以及一个字面的点号和连字符。尽管连字符通
206第4章
www.TopSage.com
---
## Page 223
常会在字符类中创建一个范围，但是当它出现在字符类中的最后一个字符时，还是会
被当做-一个字面量。
实例2.3中讲解了关于字符类的内容，包括如何使用简写把它们组合起来，例如
。这个类会匹配一个单词字符，或者是其中列出的19个标点
字符之一。
当在字符类之外使用的时候，（+）和*是量词。加号会重复它前面的正则记号一次或
多次，而星号则会重复0次或多次。在这些正则表达式中，被量化的记号通常是一个
字符类，有时候也会是一个分组。因此，会匹配一个或多个字符、数字、
点号和/或连字符。
再举一个使用分组的例子，（?：[A-Z0-9-]+\.+>会匹配一个或多个字符、数字和/或连字
符，后面紧跟着一个字面点号。加号会重复这个分组一次或多次。因此该分组会被至
少匹配一次，但是可以匹配任意多次。实例2.12中详细解释了类似这样结构的工作
原理。
和S>的正则式都会匹配dropdatabase；-
LFjoe@server.comLFhaha!，其中LF代表的是换行符。
为了避免这种情况的出现，就应当转而使用。除了JavaScript之外，在本书
讨论的所有流派中，这两个定位符不管在任何选项之下，都只会匹配字符事的起始和
结束。JavaScript根本不支持和。实例2.5会讲解这些定位符。
合法性验证和格式化207
www.TopSage.com
---
## Page 224
提示
的问题在所有用来验证输入的正则表达式之上都存
：在。在本书中这样的情况会出现多次。虽然我们会偶尔提供一些提醒，
但并不会总是重复这个建议，或者在每个实例中都为JavaScript和Ruby
给一份单独的解决方案。在许多情况下，我们只会给出一个使用脱字符
和美元符号的解决方案，而把Ruby列为一种兼容流派。如果你使用的是
Ruby，而且想要避免在一个多行字符串中匹配到一行，那么就要记住使
用
构造正则表达式的步骤
下面讲解如何逐步构造一个正则表达式。这里讲的技巧尤为适合手边有一个正则表达
式测试工具（比如RegexBuddy）的读者。
首先，在工具中加载一大堆合法和不合法的样例数据。对这个实例来说，也就是需要
一个合法E-mail地址的列表，和一个不合法的E-mail地址的列表。
然后，写一个正则表达式来匹配所有合法的E-mail地址。现在先暂时不考虑不合法的