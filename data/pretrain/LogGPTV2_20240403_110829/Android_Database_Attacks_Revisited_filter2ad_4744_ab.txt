18
19
20
21
22
23
24
25
26
27
28
29
30
31
32 }
33 class P u b l i c D B H e l p e r extends S Q L i t e O p e n H e l p e r {
34
35
case " 1 " : return " S c h e d u l e d M e s s a g e " ;
default : return " " ;
}
String g e t T a b l e N a m e ( String id ) {
db . execSQL ( " CREATE TABLE S c h e d u l e d M e s s a g e (
public void o n C r e a t e ( S Q L i t e D a t a b a s e db ) {
}
}
}
...
36
37
38
39 }
message TEXT , ... ) " ) ;
db . execSQL ( " CREATE TABLE C o n t a c t s ( _id INTEGER
, ...) " ) ;
}
...

Listing 1: Public database example code in app A.
tern is protected by the writePermission. However, since
the ﬁrst URI pattern is not protected by any permission,
malware can use it to pollute the database by invoking the
insert() API in the content provider.
Now, we explain the public database attack launched by
app M, the malware in Listing 4. The insert() method of
the content provider in app A at Line 9 in Listing 1 is called
once app M calls ContentResolver.insert() at Line 7 in List-
ing 4. App M also passes appropriate data as arguments of
this method to send sensitive messages to the contact list
on the device. The targetUri at Line 3 is crafted by the
attacker in a way to pass the check at Line 11 in Listing 1
to reach the SQLiteDatabase.insert() statement at Line 15.
In this example, the bug which leads to the public database
attacks can be ﬁxed either by enforcing proper permissions
in the manifest ﬁle or changing the implementation of the
content provider. Instead of protecting a particular subset
of paths in the manifest ﬁle, the developer can protect the
whole provider by the writePermission but this is inﬂexi-
ble. Alternatively, Line 6 in Listing 1 could be removed to
only allow the path patterns that are already protected in
the manifest ﬁle to execute the code to reach the insert()
method.
627

1 public class E x a m p l e B r o a d c a s t R e c e i v e r extends
1 
2 
3 ...
4 
5
6 
7 
10
11 
8
9


Listing 3:
speciﬁcation of app A (victim app) speciﬁed in its manifest ﬁle.
The content provider and broadcast
receiver
1 class D a t a b a s e M a l w a r e extends A c t i v i t y {
2
3
void i n s e r t P u b l i c () {
Uri t a r g e t U r i t a r g e t U r i = Uri . parse ( " content
4
5
6
7
8
9
10
11
12
13
:// com . example . app . P u b l i c D a t a b a s e /1 " ) ;
C o n t e n t V a l u e s values = new C o n t e n t V a l u e s () ;
values . put ( " message " ," S e n s i t i v e Data " ) ;
C o n t e n t R e s o l v e r c o n t e n t R e s o l v e r =
g e t C o n t e n t R e s o l v e r () ;
Uri c o n f i r m a t i o n U r i =
c o n t e n t R e s o l v e r . insert (
targetUri , values ) ;
if ( c o n f i r m a t i o n U r i != null ) {
// attack has been l a u n c h e d s u c c e s s f u l l y .
}
}
void i n s e r t P r i v a t e ( int phoneNo , String message ) {
Intent intent = new Intent ( " com . example . app .
event . Trigger " ) ;
intent . p u t E x t r a ( " task " , " message " ) ;
intent . p u t E x t r a ( " data " , message ) ;
intent . p u t E x t r a ( " contact " , phoneNo ) ;
s e n d B r o a d c a s t ( intent ) ;
14
15
16
17
18
19 }
}
Listing 4: App M is a malware which accesses the public and
private databases of the victim app A.


app implementation. We propose a more ﬂexible mitigation
mechanism addressing both public and private database at-
tacks. It can be thought of as adding new private database
access controls which are akin to the public ones (see Sec.
5).
The previous examples also show that detecting and gen-
erating exploits for database attacks demands accurate anal-
ysis of complex objects. A malware installed on the device
can construct malicious inputs using data structures and
objects which are more complex than primitive types. We
also see that there are several libraries with particular se-
mantics for their operations on the execution path. These
libraries need to be correctly handled in the analysis to get
accuracy.
In addition, as the number of entry points for
the private database attacks can be large and the private
databases can be implemented anywhere in the code-base,
the analysis needs to be suﬃciently scalable.
4. DETECTION AND EXPLOITATION
Our goal is to detect and exploit the public and private
database vulnerabilities in benign apps. At the high level,
628ﬁnding database vulnerabilities of an Android app can be
considered a source to sink reachability analysis problem.
The public and private database attacks are triggered by
the invocation of the content provider and Intent recipient
APIs (e.g., getIntent()) respectively followed by execution
paths which reach the sink methods (e.g., SQLiteDatabase
APIs). In general, static analysis techniques only give po-
tential reachability and existing techniques for Android apps
[1, 21, 11] are no diﬀerent. Moreover, the results of these
techniques may give many potential source-sink ﬂows with
possibly many false positives [12]. We aim to generate inputs
which can exploit these vulnerabilities. ContentScope [31]
analyzes public database vulnerabilities using reachability
analysis and constraint solving. However, it does not deal
with the private database vulnerabilities. Our experience
shows that private database vulnerabilities are more scat-
tered throughout the code-base of Android apps. Hence,
while more shallow analysis may suﬃce to ﬁnd some public
vulnerabilities, private vulnerabilities require a deeper anal-
ysis with the attendant scalability challenges and neccesity
to handle framework libraries more precisely.
We present DBDroidScanner which is based on the anal-
ysis proposed in W2AIScanner [12]. In this paper, several
components are extended to deal with the analysis and ex-
ploitation of database vulnerabilities. W2AIScanner focuses
on detecting and exploiting web-to-app injection vulnerabil-
ities. Symbolic execution [5] is used as the core analysis to
generate proof-of-concept exploits. In order to balance be-
tween precision and eﬃciency, static information-ﬂow anal-
ysis is combined with symbolic execution and dynamic test-
ing. An important diﬀerence between DBDroidScanner and
W2AIScanner is in the input types supported for exploit
generation. The generated exploits in [12] are primitive
types (string, integer, etc.). However, DBDroidScanner also
needs to support input parameters of non-primitive types
which are used by malware to call APIs for exploiting vul-
nerabilities. Another diﬀerence is in the symbolic models
used for URI-based libraries. The models utilized by DB-
DroidScanner support more complex semantics which is nec-
essary to automatically exploit the database vulnerabilities
presented in this paper.
In this section, we describe our
extensions to the analysis in [12].
The analysis framework in [12] employs an initial static
dataﬂow analysis which is fast but imprecise. This is fol-
lowed by static symbolic execution – a more precise but
slower phase. The ﬁnal dynamic testing of Android apps
was found to be the most time consuming phase in practice.
Thus, the number of ﬂows generated statically which have
to be tested and conﬁrmed by the dynamic testing phase are
reduced by having more accurate static analysis.
Similar to [12], DBDroidScanner works in the following
phases: (1) it identiﬁes the pairs of source and sink program
points and creates the initial CFG (control ﬂow graph); (2)
it takes the source-sink pairs produced by the previous step
and performs a sink reachability analysis which is utilized as
a pre-computation for the search heuristic in the next step;
(3) it performs bounded static symbolic execution which re-
sults in input constraints which will be employed to generate
concrete inputs used in the exploits; (4) the runtime execu-
tor constructs the ﬁnal exploits run on the app to log the
execution trace to validate the exploit. In addition, there
is feedback from phase 4 to phase 3 to incorporate concrete
values obtained from the runtime execution with the path
constraints which are solved again by the solver to generate
possibly more precise exploits. The static analysis is per-
formed on Jimple, the intermediate representation used in
Soot [18]. Next, we discuss the extensions needed for dif-
ferent components of the analyzer to ﬁnd and exploit public
and private database vulnerabilities.
4.1 Source-Sink Pair Identiﬁcation
The ﬁrst component of our analysis framework identiﬁes
the source-sink pairs. In order to ﬁnd the entry points which
lead to the database sink methods, ﬁrst, we study possible
ways of accessing the public and private databases in the
Android apps. We classify sink methods into leakage, pol-
lution and ﬁle access categories.5 The sink methods used in
our analysis for the privilege escalation attacks are the Con-
tentResolver APIs (e.g., ContentResolver.insert()). These
sinks are used to detect both public and private database
vulnerabilities.
Direct Invocation of Content Provider APIs (Pub-
lic Database Sources). Content provider components are
specially designed to provide shared content among apps.
They encapsulate local app data and export them through
standardized APIs: query(), insert(), openFile(), etc. These
interfaces can be invoked by other apps to operate on the
app’s internal SQLite database and internal ﬁles. A mali-
cious app can call these (standardized) APIs to launch pol-
lution, leakage or ﬁle access attacks. Once the possible entry
methods are determined, we mark the parameters of these
methods as source variables.
A content provider is a candidate for analysis if it is not
fully protected by appropriate attributes and permissions
in the manifest ﬁle. A content provider is fully protected:
(1) by default (equivalent to exported="false") in Android
SDK 17 and higher; (2) if exported="false" is speciﬁed ex-
plicitly; (3) if the android:permission attribute is speciﬁed in
the  tag in the manifest ﬁle.6 A content provider