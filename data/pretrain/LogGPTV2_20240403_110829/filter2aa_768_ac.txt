图标类（MB_ICONMASK） 
0x000000F0L 
用来定义包含的图标 
MB_ICONHAND 
0x00000010L 
带有停止符号的图标 
MB_ICONQUESTION 
0x00000020L 
带有问号的图标 
MB_ICONEXCLAMATION 
0x00000030L 
带有惊叹号的图标 
MB_ICONASTERISK 
0x00000040L 
带有字母 i 的图标 
MB_USERICON 
（仅用于 MessageBoxIndirect） 
0x00000080L 
通过 MSGBOXPARAMS 结构的
lpszIcon 指定图标资源 
MB_ICONWARNING 
0x00000030L 
带有惊叹号的图标 
MB_ICONERROR 
0x00000010L 
带有停止符号（X）的图标 
宏定义/类 
值/类掩码 
含义 
MB_ICONINFORMATION 
0x00000040L 
带有字母 i 的图标 
MB_ICONSTOP 
0x00000010L 
带有停止符号（X）的图标 
默认按钮（MB_DEFMASK） 
0x00000F00L 
定义默认（含初始焦点的按钮）按钮 
MB_DEFBUTTON1 
0x00000000L 
第一个按钮为默认按钮 
MB_DEFBUTTON2 
0x00000100L 
第二个按钮为默认按钮 
MB_DEFBUTTON3 
0x00000200L 
第三个按钮为默认按钮 
MB_DEFBUTTON4 
0x00000300L 
第四个按钮为默认按钮 
模态（modality） 
（MB_MODEMASK） 
0x00003000L 
指定窗口的模态性 
MB_APPLMODAL 
0x00000000L 
应用程序级模态（见下文） 
MB_SYSTEMMODAL 
0x00001000L 
系统级模态（见下文） 
MB_TASKMODAL 
0x00002000L 
任务级模态（见下文） 
杂项（MB_MISCMASK） 
0x0000C000L 
《软件调试》补编 
- 13 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
MB_HELP 
0x00004000L 
包含 Help 按钮，当用户按此按钮
时，向 hWnd 窗口发送 WM_HELP
消息 
MB_NOFOCUS 
0x00008000L 
内部使用，参见微软知识库 87341
号文章 
其他 
N/A 
MB_SETFOREGROUND 
0x00010000L 
对消息框窗口调用
SetForegroundWindow 
MB_DEFAULT_DESKTOP_ONLY 
0x00020000L 
仅在默认桌面显示消息框 
MB_TOPMOST 
0x00040000L 
消息框具有 WS_EX_TOPMOST 属性 
MB_RIGHT 
0x00080000L 
文字右对齐 
MB_RTLREADING 
0x00100000L 
按从右到左的顺序显示标题和消
息文字 
MB_SERVICE_NOTIFICATION 
0x00200000L 
供系统服务（system service）程序
使用 
MB_SERVICE_NOTIFICATION 
0x00040000L 
用于 NT 4 之前的 Windows 版本 
MB_SERVICE_NOTIFICATION_NT3X 
0x00040000L 
用于 NT 3.51 
其中，模态性用来定义消息框弹出后，消息框窗口对用户输入的垄断性，如果模态性
为 MB_APPLMODAL，那么，hWnd 参数所指定的父窗口将被禁止，直到消息框关闭后
才恢复响应。如果模态性为 MB_SYSTEMMODAL，那么，除了具有 MB_APPLMODAL
的特征外，消息框窗口还会被授予 WS_EX_TOPMOST 属性，也就是成为最上层窗口，这
样，如果它不被关闭，就总显示在最顶层，目的是让用户始终看到，但这时用户可以与
hWnd 参数外的其他窗口交互。如果指定 MB_TASKMODAL，即使 hWnd 参数为 NULL，
则当前线程的所有顶层窗口也将被禁止，这是为了在不知道顶层窗口句柄时也将其禁止。 
13.1.6  返回值 
MessageBox API 的返回值是一个整数，如表 13-2 所示。 
表 13-2  MessageBox 函数的返回值 
宏定义 
值 
宏定义 
值 
IDOK 
1 
IDNO 
7 
IDCANCEL 
2 
IDCLOSE 
8 
IDABORT 
3 
IDHELP 
9 
IDRETRY 
4 
IDTRYAGAIN 
10 
IDIGNORE 
5 
IDCONTINUE 
11 
IDYES 
6 
IDTIMEOUT 
32000 
通过以上返回值，可以知道用户对消息框的响应结果，例如 IDYES 代表用户选择了
Yes 按钮，等等。 
13.1.7  归纳 
前面我们介绍了 MessageBox 函数的工作原理和几个相关的 API 及内部函数。图 13-2
归纳出了这些函数的相互关系。 
《软件调试》补编 
- 14 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 13-2  MessageBox 和有关 API 的调用关系 
使用 MessageBox API 来实现错误提示的优点是简单易用，但是这种方法存在如下局
限。首先，MessageBox 是一个用户态的 API，内核代码无法直接使用。第二，MessageBox
是工作在调用者（通常是错误发生地）的进程和线程上下文中的，如果当前进程/线程的
数据结构（比如消息队列）已经由于严重错误而遭到损坏，那么 MessageBox 可能无法工
作。第三，对于系统启动关闭等特殊情况，MessageBox 是无法工作的。 
《软件调试》补编 
- 15 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
补编内容
补编内容
补编内容
补编内容 2 堆检查之实例分析
堆检查之实例分析
堆检查之实例分析
堆检查之实例分析 
补编说明： 
这一节本来属于《软件调试》第 23 章的第 16 节，也就是最后一节，旨在通
过一个真实案例来总结和巩固这一章前面各节的内容。案例涉及动态链接库
模块和 EXE 模块，是在同一进程中有多个 C 运行库实例的情况。 
在《软件调试》正式出版前压缩篇幅时，这一节被删除了。主要原因是虽
然这个例子挺好的，但是毕竟是例子，为了确保原理性的内容，还是把这
个例子删了。 
23.16  实例分析 
前面几节我们介绍了 Win32 堆、CRT 堆，以及它们的调试支持。本节我们通过一个
实例来巩固大家的理解。在现实的软件产品中，一个应用程序通常由很多个模块组成，这
些模块可能是不同团队或不同公司和组织开发的。这就很可能有多个模块都使用了 CRT
库，但是使用的版本和链接方式是不同的。对于这种一个进程内的多个模块（EXE 和 DLL）
都使用了 CRT 堆的情况，它们使用的是多个 CRT 堆还是一个 CRT 堆呢？这个问题的答案
主要和链接 CRT 的方式有关。简单地说，如果一个模块（EXE 或 DLL）静态链接 CRT，
那么这个模块便会创建和使用自己的 CRT 堆。如果一个模块动态链接 CRT，那么这个模
块便与同一进程内动态链接这个 CRT DLL 的所有模块共享一个 CRT 堆。下面以分别使用
VC6 和 VC2005（即 VC8）创建的 Win32 DLL 和 Win32 应用程序为例进行分析。 
23.16.1  FaultDll 和 FaultApp 
FaultDll 是使用 VC6 创建的标准 Win32 DLL，操作步骤为 File>New>选择 Win32 
Dynamic-Link Library 并命名为 FaultDll>选择 A Dll that exports some symbols。FaultApp 是
使用 VC6 创建的标准 Win32 应用程序，操作步骤为 File>New>选择 Win32 Application 并
命名>选择 A typical “Hello World” application。以上两个项目除了将输出目录设置到同一
个目录外，其他选项都是默认的。 
在 FaultDll 中我们实现并输出一个简单的类 CFaultClass，它有一个公开的成员，类
型为 STL（Standard Template Libarary，即标准模板库）中的 std::string 类。在 FaultApp
中我们加入一个名为 FaultCase 的函数来使用 CFaultClass 类，清单 23-35 给出了相关的
《软件调试》补编 
- 16 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
代码。 
清单 23-35  CFaultClass 类的定义和使用 
#include  
using namespace std; 
//使用 STL 的命名空间 
class FAULTDLL_API CFaultClass  
//定义并输出一个 C++类 
{ 
public: 
    CFaultClass(void); 
//构造函数，内部没有做任何操作 
    string m_cstrMember; 
//定义一个字符串成员 
}; 
//以下是 FaultApp.cpp 中的代码 
#include "../faultdll.h" 
//包含声明 CFaultClass 类的头文件 
void FaultCase(HWND hWnd) 
//使用 CFaultClass 类的 FaultCase 函数 
{ 
    CFaultClass fc; 
//定义一个实例 
    fc.m_cstrMember="AdvDbg.org"; 
//直接对公开的成员赋值 
    MessageBox(hWnd, fc.m_cstrMember.c_str(), "FaultApp",MB_OK);  
//显示成员的当前值 
} 
//返回 
最后在 FaultApp 程序中加入一个菜单项 IDM_FAULT，并在响应这个菜单项命令时调
用 FaultCase 函数。 
以上代码选摘自一个实际的软件项目，看起来非常简单，似乎也没什么问题，但是实
际上它却隐藏着严重的问题，我们先来看调试版本的运行情况。 
23.16.2  运行调试版本 
编译以上两个项目，会有一个 c4251 警告，我们稍后再讨论它。直接执行（非调试）
调试版本的 FaultApp 程序（位于 code\bin\debug 目录），点击 File 菜单的 Triger Fault 项后，
会得到图 23-10 所示的断言失败对话框。 
图 23-10  内存检查断言失败对话框 