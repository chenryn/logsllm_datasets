作为一个边缘 pwn 手，一直很喜欢研究逆向工具的原理。不久前
[Ghidra](https://github.com/NationalSecurityAgency/ghidra)
的发布终于给了我一个动力开始深入研究，毕竟在此之前开源社区基本上没有能用的逆向工具。[Radare2](https://github.com/radare/radare2)
虽然一直也致力于做一个能用的逆向工具，但是从我自己用下来的感觉来说，他基本上还达不到能够成为主力逆向工具的程度，最多只能作为其他逆向工具的辅助。关于对这些工具的对比，如果有空，我会写一篇文章发表一下我自己了解的一些看法，大家也不需要因为这个吵起来，毕竟工具这个东西，各有优劣。
这一个系列我不确定我会写多少，主要是基于我现在学习的一些东西，觉得有意思的地方，或者比较难懂，比较难记的东西，我会写一下。据我所知，国内对逆向工具研究很深的并不太多，所以也希望通过我的介绍，能够揭开逆向工具的神秘面纱，让大家都理解其中的原理，在必要时候能够在开源基础上做出改动，或是为开源社区做出贡献。
本系列内容目前以 Ghidra 作为背景，其中内容会以 Ghidra 为例。
## 背景知识
本文假设读者拥有二进制方面的基础，主要是逆向或是 pwn 方面的基础，至少需要了解汇编语言、处理器工作方式等内容。
## 逆向工具、逆向框架简介
作为这个系列的第一篇，需要先简要介绍一下逆向工具本身。
作为二进制选手，大家都使用过逆向工具，包括目前业界标准的 IDA pro，NSA 新开源的 Ghidra ，价格不算太贵但是收费的
[BinaryNinja](https://binary.ninja/) 还有一直活跃的 Radare2 ，那么一个逆向工具都包括什么？需要有什么功能？
这个我想大家心里都有数，这里我主要介绍下一个逆向工具（逆向框架、逆向平台），都包含哪些部分。
这是一个典型的逆向工具包含的内容：
    +------+  +------+  +-------+
        | 插件 |  | 插件 |  |  ...  |
        +------+  +------+  +-------+
            |         |        |
            +---------+--------+
                      v
                +--------------+
                |   插件管理   |
                +--------------+
         +--------------^--------------+
         |              |              |
         v              v              v
    +----------+   +----------+   +----------+
    | 文件格式 |-->|  反汇编  |-->|   界面   |
    +----------+   +----------+   +----------+
其中主要的部分是文件格式解析、反汇编和界面，当然光有这些还无法成为一个完整的逆向工具，在这几个部分中也有许多具体的内容，这里只是说明一个逆向工具需要的几个大体部分。
文件格式解析部分负责分析二进制文件，按照其特点分析为不同的文件，按照不同的文件进行分类，解析之后，还会构造程序的映射，这样才能够确认哪些部分是可执行部分，从而为后续的反汇编流程提供必要条件。
反汇编部分功能就比较显然了，负责将文件格式解析后，确认为将要执行的内容进行分析，包括找到指令所在位置等。之后，将指令进行解码，识别出二进制机器码对应的具体指令。
界面部分当然就是负责显示了，这一部分其实可以脱离前面的核心部分，从而支持所谓的 `headless analysis`，也就是不启动界面进行分析。
最后，也是最关键的部分，就是插件管理。作为“框架”，或是“平台”，只有支持了插件才算是完整的。插件的支持为逆向工具提供了无限的可能，我们熟知的
Hexrays 反编译工具就是在 IDA pro
上的一个插件。对于一个设计合格的逆向工具，插件能够插入到功能当中的每一个部分，甚至扩展功能本身。事实上，虽然我将逆向工具划分了三个主要功能，但是理论上只需要有插件就足够了，因为其他部分均可以通过插件的方式进行管理，并且提供。
另外，需要声明这里的归类，包括三类主要功能，都是我自己归类的，事实上如果具有适当的插件管理，那么其他所有部分均可以通过插件进行处理。但是由于这三类功能在我自己看来足够重要，所以单独提出。
## 架构规范（Architecture Specification）
既然这一篇是讲架构规范，我们肯定首先需要了解什么是架构规范（Architecture Specification）。
这里的架构是指处理器架构，架构规范，指的是处理器规范，可以理解为通过形式化语言将一个架构描述下来。大家最熟悉的例子应该是 x86 架构，或是 arm
架构，这些都是处理器架构，而处理器规范的意义，就是通过一个形式化的语言，或者更通俗地讲，就是通过一个更加规范的语言将处理器的架构描述出来。
所以为什么需要描述处理器架构呢？我们不是有 Intel 手册可以了解 x86
架构的功能、用法、指令集了吗？的确，手册是处理器厂商官方给出的，非常权威，我们完全可以依赖手册了解我们面对的架构，但是手册的问题也很明显： **不够规范**
。官方的手册都是用自然语言描述的，虽然我们可以更容易地看懂，但是也带来了问题。自然语言描述是不利于机器处理的，换言之，官方的手册，从来没有考虑过需要你用机器处理。
这就引出了对处理器架构用规范语言描述，即，架构规范的一大意义： **便于编程处理** 。
那为什么编程自动化处理架构这么重要呢？因为，我们在写逆向工具呀！:)
思考一下，逆向工具需要什么功能？反汇编、反编译？交叉引用？分析跳转目标？这些似乎都是逆向工具需要的功能，其中最为重要的一个环节，反汇编，是一个非常繁重的工作。一个逆向工具增加对一个架构的支持，就需要对其架构细节进行处理，包括它的指令集、它的特点（例如一些架构具有的寄存器窗口、delay
slot、或是像 arm 具有 thumb
模式），因为只有处理了这些特点，才能够正确分析出一些有价值的信息，包括交叉引用等。交叉引用，只有在分析出了跳转的目标，或是引用的目标，才能够正确找出来对吧？如果没有正确处理这些信息，逆向工具又如何找出来跳转目标呢？更不用说反汇编本身指令集的处理了，连指令都无法识别，这些功能就无从谈起了。
现在，我们思考一下，逆向工具对一个架构的支持有什么方式。我们以最基础的部分，指令解码为例。指令解码指将二进制机器码形式的内容识别为某条汇编指令的过程。事实上，这个过程是最复杂的，因为再简单的架构，也会拥有大量指令（例如会包含向量指令扩展、浮点数计算扩展等，导致指令数量不会太少），更不用说像
x86 这样的 CISC 架构，指令本身设计时就非常多，扩展起来就更多了。
一种最简单的方式，就是通过写代码直接进行指令解码。这种方式看似简单，也是最容易想到的方式，事实上工作量非常大。一大原因就是指令数量实在太多，识别到具体指令的过程非常复杂，特别是像
x86 这样的变长指令集。
那么还有什么方式呢？有一句名言，”软件工程的所有问题，都可以通过加一层的方式解决“，在这也不例外。我们通过加入新的一层，也就是 ——
架构规范，来解决这个问题。在之前，我们的指令解码过程如下：
    +------+    解码逻辑（代码）    +------+
    | bin  |   --------------->     | 汇编 |
    +------+                        +------+
现在，加入架构规范之后，我们的解码过程：
    +-----------+  生成   +---------+
    |  架构规范 | ------> | 解码器  |
    +-----------+  (代码）+---------+
                               |
                               |
    +-----------+              v          +-------+
    |  bin      | ------------>+--------->|  汇编 |
    +-----------+                         +-------+
区别是什么？区别在于，我们实现生成解码器过程的代码是复用的！所以在支持不同的架构的时候，原来我们需要写针对不同架构的解码逻辑，现在，我们只需要编写不同的架构规范！
好吧，看起来没什么不同，但是事实上是，由于架构规范不止能够生成解码器，甚至可以生成编码器（在汇编过程中用到），或是指明语义（用于生成中间语言，或是其他语言，例如从
x86 翻译到
arm），这种情况下，原本我们需要针对不同的架构编写不同的解码器、编码器，现在，我们只需要写一个足够好的，从架构规范生成解码器和生成器的”生成代码“，之后，我们支持其他架构，只需要加入架构规范了。
这种方式，我们得到两个好处：
  1. 加入新架构时，减少了代码量
  2. 更容易维护现有架构，因为架构规范本身不像代码那样难以阅读（想象一下分析指令过程中的层层 if ..）
除此以外，一些研究方向也注重于使用规范的方式描述架构，从而进行形式化验证（一般是 Instruction Set
Specification，不过在本文中我没有区别两者）。
在我自己看来，使用架构规范的方式进行解码器和编码器的生成是反汇编的一个关键。一个不恰当的例子就是[llvm的反汇编器](https://github.com/llvm/llvm-project/blob/master/llvm/lib/Target/X86/Disassembler/X86DisassemblerDecoder.cpp)。虽然
llvm
使用了[类似架构规范的描述语言](https://llvm.org/docs/TableGen/index.html)，但是因为其设计之初只考虑了编译过程，没有考虑生成解码器的过程（编译过程不需要解码器，只需要编码器，而且编译器理论上不需要支持所有指令，一些冷门指令可以被其他指令代替，所以指令支持不全），导致解码器编写过程非常复杂。
## [SLEIGH](https://ghidra.re/courses/languages/html/sleigh.html) 语言
SLEIGH 语言是 Ghidra 逆向工具中用到的架构描述语言（架构规范），在这里我们介绍 SLEIGH
语言的一些基本要素，从而让大家了解架构规范在现实中的用法情况。
另外，这一部分也可作为 SLEIGH 语言的基础教程，帮助大家了解 SLEIGH 语言的基本结构，对于我自己来说，主要是对这个语言起总结作用。
注意，本文的内容远不足以当做 SLEIGH 语言教程，只可当做 SLEIGH 语言总览，需要继续学习，请参照官方文档，本文只可用于辅助理解。
### 启发
SLEIGH 语言的思路来源于[UQBT: adaptable binary translation at low
cost](https://ieeexplore.ieee.org/abstract/document/825697)，据说 IDA pro
的设计也参考了文章中的一些内容。
这篇文章主要通过定义架构描述语言，实现了两个架构之间的转换。其中用到了[Specifying Representations of Machine
Instructions](https://www.cs.tufts.edu/~nr/pubs/specifying.pdf)一文中的 SLED
描述语言的一些设计，还用到了[Specifying the semantics of machine
instructions](https://ieeexplore.ieee.org/abstract/document/693332)的一些设计。