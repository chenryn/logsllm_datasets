内存范围是0xc00000000到0xFFFFFFFF（“最高”1GB虚拟内存），然而每一个进程可
以自由地使用这个范围之后的所有地址（“最低”3GB虚拟内存）。
·隔离的内核和进程地址空间在这种情形下，内核和用户态应用程序各有一个完全的、
独立的地址空间。换句话说，不论是内核态还是用户态应用程序都可以使用可用的虚拟
内存的地址空间。
从漏洞利用的角度来讲，第一种方法比第二种方法更便于进行漏洞利用，但是为了更好地
理解这一点，需要先介绍一下执行环境上下文的概念。只要CPU处于管态模式（例如，它在执
---
## Page 22
第1章从用户态利用到内核态利用13
行一个给定的内核执行路径），如果一个操作没有后备进程（backingprocess），那么将进入中
断上下文。这种情况的一个示例是硬件生成的中断，如数据包到达时网卡发出的中断或磁盘在
一个操作结束时发出的中断。命令的执行将转移到中断服务程序，并且将关闭CPU上运行的任
何程序。不能阻塞中断上下文中的代码（例如，等待请求页面带入一个引用页面）或者挂起：
调度程序不知道什么时候挂起代码（或者什么时候唤醒它）。
如果有一个关联的进程，就说一个内核执行路径会在进程上下文中执行，关联的进程经常
是那个激发内核代码路径的进程（例如，执行系统调用的结果）。这样的“代码”不受任何在
中断上下文中执行的代码的限制，这是最常见的内核执行模式。这样做主要是尽量减少中断服
务程序的任务。
我们刚才简要揭示了“有一个后备进程”的含义：许多进程相关的信息是可用的并且能被
内核执行路径在没有明确装载或查找的情况下使用。这意味着在内核中有一个保存当前进程信
息的变量，这个变量会在当进程在CPU上切换时发生改变。很多内核的函数使用这个变量，从
而基于这些信息的操作就关联到了一个后备进程。
因为可以控制后备进程（例如，您能执行一个特定的系统调用），所以无疑可以控制低地
址的内存。现在假设找到了一个内核漏洞，这个漏洞充许将执行流重定向到任何您想执行的地
方。只要重定向到您知道的地址就能在用户态取得控制权，这不是挺好吗？这正是采用内核态
内存空间代表用户态内存空间的系统做的事情。因为内核的页表项被复制到了所有进程的页表
中，一个单独的虚拟地址空间由内核部分和您进程用户态映射组成，当它处于活动状态时，可
以在虚拟地址空间中随心所欲地获取指针中的值。很明显，您需要处在进程上下文中，就像在
中断上下文中一样，您可能并不知道中断了哪个进程。对漏洞利用来说，把用户态地址空间和
内核地址空间融合起来有很多好处：
·不必猜测shellcode在哪里，可以用C语言写shellcode，编译器将负责装配它。当触发漏
洞的代码将许多内核结构破坏后，将会有一个恢复阶段。
·不必费心去寻找一个大而安全的存放shellcode的地方。因为您有3GB可用的地址空间。
·不必担心不可执行的页保护。因为您控制了内存的地址空间，所以可以将它映射到内存
中任何您喜欢的地方。
·可以把一大块的地址空间映射到内存里，然后用NOP指令或者类NOP指令/数据填充
它，这将明显增加成功的几率。正如将要看到的，有时也许只能重写一部分返回地址，
所以拥有一个大的返回地址空间是完成一次可靠的漏洞利用的必由之路。
·能轻易地利用用户态取值（还有NULL指针取值）的错误，我们将在第2章详细讲述这
一点。
同样的虚拟地址在内核态内存区和用户态内存区有着不同的含义。在漏洞利用的过程中，不能
在进程地址空间使用任何的映射。可以说融合用户态和内核态地址空间的方法是最好的：为了提
高效率，隔离内核地址空间和进程地址空间的方法需要来自底层架构的帮助，例如UltraSPARC
持。这主要得看带来的性能损耗的严重程度。
---
## Page 23
14第一部分内核态
开源操作系统和闭源操作系统
在本章最后，我们介绍本书涉及的各种操作系统中用到的内核实现概念，将重点介绍
3个内核家族：Linux（作为UNIX操作系统中的一个经典例子）、MacOSX（采用了混合
microkernel/UNIX的设计）和Windows。将在第4、5、6章分别详细地讨论它们。最后，我们
简单地介绍了开源和闭源的传奇故事。
特定的许可下公开发布，这个许可是GNU公共许可（GNUPublicLicense，GPL），允许人们
自由地分发和下载内核源代码。实际上，GPL并不像听起来的这么简单，它明确地规定了人们
能对源代码做什么和不能做什么。例如，如果一个大项目中引I用了部分GPL下的代码，那么
整个项目也必须发布在GPL下。UNIX的其他分支（全部或大部分）也都是开源的，这些操
作系统也都有不同的许可（通常比GPL更自由一些）。这些操作系统有FreeBSD、OpenBSD、
NetBSD、OpenSolaris，即使是混合内核的MacOSX，它们都允许您研究全部或者大部分的内
核代码。与此不同的是闭源操作系统，其中有微软的Windows家族和一些商业的UNIX分支，
比如IBMAIX和HP-UX。
获取源代码对于漏洞利用者很有帮助，它能帮助漏洞利用者更快地理解他所关注的子系统
或内核的内部实现，从而更容易地寻找漏洞。人们通常认为，发现开源操作系统的漏洞要比发
现闭源操作系统的漏洞容易：对一个闭源操作系统进行逆向工程是很费时间的，而且还要通过
阅读大量的汇编代码来对此闭源操作系统有一个全局的把握。另一方面，开放源代码系统可能
更“健壮”，因为更多的人在检查代码，并公开发现的问题和漏洞，而闭源操作系统可能在很
长一段时间内对潜在的问题浑然不觉（也许只是发现了但没有公开）。系统的优秀和安全性取
决于它的开发和测试过程的质量，对于某个熟练的研究人员或攻击者来说，发现漏洞并写出可
靠的漏洞利用方案只是时间问题。
小结
本章介绍了我们的目标一内核，以及漏洞利用开发人员对其感兴趣的原因。过去的实践
已证明内核漏洞利用不仅是可能的，还是高效的，特别当系统安装安全补丁之后。这种能力来
源于对内核源代码更深入广泛的理解和在开发漏洞利用时更多的努力。我们从介绍一些通用的
强制性的核心概念人手开启了通往内核漏洞利用领域的道路：内核怎样跟踪和选择进程来运行，
虚拟内存怎么让每一个进程在运行时好像自己有一个大而连续的私有地址空间。当然，这只是
一个很浅的概述：我们将在本书剩下的部分里更深人地了解子系统的细节。现在就想知道更多
信息的读者可以参考本章最后的“相关阅读”列表，那里列出了关于漏洞利用、审计和开发
shellcode的相关资料。
本章还讨论了融合用户态内存和内核态内存地址空间的设计与隔离这两种地址空间的设
计。因为这部分内容对漏洞利用的影响非常大，所以我们花了一整节的篇幅来介绍它。实际
上，在融合两种级别地址空间的设计中有很多我们可以使用的方法或工具。在我们控制的进程
---
## Page 24
第1章从用户态利用到内核态利用15
地址空间里，最起码能够取得任意地址上的值。
在本章最后温习了一些关于开源与闭源的概念，是为了指出将要介绍的大部分操作系统
（除了著名的Windows系列）都提供了源代码供人们自由下载。正如您所能想象的，这对于漏
洞利用的开发和漏洞研究提供了很大的帮助。
现在您已经知道了内核态的漏洞利用充满了挑战、让人痴迷和向往，我们将开始第2章的
学习，在那里将讨论如何使得漏洞利用的过程更加高效、重要和可靠。让我们开始充满乐趣的
旅行吧。
相关阅读
审计
Dowd,M.,McDonald,J.,andSchuh,J.2006.TheArtofSoftwareSecurityAssessment:Identifying
andPreventingSoftwareVulnerabilities(Addison-WesleyProfessional))
操作系统的通用概念
Tanenbaum,A.2007.Modern OperatingSystems,Third Edition(PrenticeHall Press).
(Wiley).
特定的操作系统的设计与实现
Singh,A.2006.MacOSXInternals(Addison-WesleyProfessional)
Russinovich,M.E.,and Solomon,D.,with Ionescu,A.2009.Microsoft Windows Internals,
FifthEdition(MicrosoftPress).
Mauro,J.,andMcDougall,R.2006.Solaris Internals,SecondEdition(PrenticeHall PTR).
尾注
1.Solar Designer.Getting aroundnon-executable stack(and fix).E-mail sent to the bugtraq
mailinglist,http://marc.info/?1=bugtraq&m=87602746719512;1997[accessed07.18.10]
9
---
## Page 25
第2章
内核漏洞分类
本章主要内容
·未初始化的/未验证的/已损坏的指针解引用
·内存破坏漏洞
·整数误用
·竞态条件
·逻辑bug
引言
软件总会有bug。bug是程序中的一个故障，会导致程序输出错误结果、非正常行为或
者直接导致异常崩溃。在多数情况下，bug是程序错误的结果，如下例，这段代码来自Linux
V2.6.9的内核：
staticint bluez_sock_create(struct socket*sock,int proto)
if（proto>=BLUEZ_MAX_PROTO)
return-EINVAL;
[...]
returnbluez_proto[proto]->create(sock,proto);
这段代码里，用作数组下标的参数proto与一个最大值BLUEZ_MAS_PROTo进行比较，以
避免读取操作超出数组bluez_proto的范围。但是，proto是一个有符号整数，因此它可以
取负值。所以，如果proto小于0，则在bluez_proto数组之前的内存都可以被访问。由于
这些内存用于存放函数指针，因此这个bug可能会导致程序崩溃，一方面可能会引用一组未映
射的地址；另一方面可能导致程序错误地访问其他某内存地址，以至于执行一段随机的字节码
序列。修复该bug的较为容易方法是，在这段函数前面检测proto是否小于0，如果是则报错
（而这也是2005年Linux开发人员发现该问题后的举措）。
如果不是程序错误，则bug往往是由设计缺陷引起的（尤其是大型的项目，比如操作系统
---
## Page 26
第2章内核漏洞分类17
的内核）。设计缺陷，顾名思义，是软件架构上的问题，且往往是跟语言无关的（即不管用什
么语言实现该软件，安全问题仍会出现）。设计缺陷的一个经典例子是依赖于一个存在漏洞的
加密机制或者是完全相信架构的某个组件，而入侵者可能假冒或操纵这个组件，且不需要某种
权限。在本章稍后的“内存破坏漏洞”一节里会详细介绍一个设计缺陷的例子。
当然，不是所有bug都是安全bug。事实上，bug通常都跟安全问题无关。简而言之，只是有
些人发现可以利用该bug获取某些权限时，bug就变成了安全问题。有时候利用一个bug时所使用
的方法可以重用到类似的bug。这里，我们所指的是bug类型和bug利用技术。对bug定义和分类
越精细，bug利用技术就会越准确和可靠。这就是我们本章进行分类的目标。
未初始化的/未验证的/已损坏的指针解引用
大概最有名的内核bug类型就是NULL指针解引I用了。正如每本C语言手册提到的，指
针是一个变量，存放内存中另一个变量的地址。每次指针被解引用的时候，指针存放的内
存地址里所含有的值就要被取出。ISOC标准指出，一个静态的、未初始化的指针有一个
NULL（OxO）值，并且NULL又常常是表示内存分配失败的返回值。如果内核路径想要取一
个NULL指针的值的时候，就相当于是使用内存地址0x0，而这会导致严重错误，因为该地
址一般不会放置任何东西。内核中发现的NULL指针解引I用的bug数量惊人的多，使用搜索
引擎一搜便知。
的一个子集，这类漏洞涵盖了所有使用指针的情况，所指内容遭到破坏，再也不能适当设置，
或是没有得到确认。我们都知道，一个静态声明的指针被初始化为NULL，但一个被声明为函数
的局部变量指针呢？一个指向刚刚分配了内存的结构体的指针指向的内容是什么？在这些指针被
一个指针是一个变量，和任何变量一样，它有大小，需要存储在内存中以便使用。指针
的大小依赖于系统使用的数据模型（datamodel），架构往往直接决定了指针的大小，·数据模
型通常用int、long和pointer的大小标记来表示；例如，ILP32表示所有的ints、longs和指
针都是32位的系统，而LP64表示所有的longs和指针都是64位的系统，但整数不是（事实
上，整数是32位，但没有明确说明）。表2.1为每个模型提供了数据类型的大小的概述（大
小用位数表示）。
表2.1不同数据模型的数据类型大小
数据类型
LP32
ILP32
LP64
ILP64
LLP64
Char
8
8
8
8
8
Short
16
16
16
16
16
Int
16
32
32
64
32
Long
32
32
64
64
32
Longlong
64
64
64
64
64
Pointer
32
32
64
64
64
---
## Page 27
18第一部分内核态
现在，假设有了ILP32模型。那么，指针变量在内存中占据4个字节。当指针变量没有初
始化的时候，分配的内存中用来存储指针变量的值是任意的，而这个指针变量的值也就可能是
任意的。想利用此漏洞的攻击者会考虑，可不可以预测指针的内容并加以利用呢？答案是肯定
的，或者说，在很多情况下是可以的。比如，一个指针被声明为本地变量，如以下代码所示，
那么该指针被存储在栈中，它的值其实是该栈的前一个函数在栈中留下的内容：
#include
#include
voidbig_stack_usage()1
charbig[200]:
memset（big,'A',200);
voidptr_un_initialized（){