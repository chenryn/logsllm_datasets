需要实现Exactly-Once以保障数据计算的精确性
●
系统高可用，不能有卡顿和不可用的情况
●
这个应用场景的SLA非常高，要求秒级延迟和数据的精确性，但它的计算并不
新智能  9年双11：互联网技术超级工程
3.实时A/B Testing
用户的Query也有可能是基于实时数据的不断变化的，典型的例子有实时的A/
B Testing。
算法工程师在调优Model时会测试并对比多种Model，不同的Model有不同的
计算模式和方法，产生不同的计算结果。因此，往往会有不同的Query订阅实时数
据，产生结果后根据用户回馈迭代Model，最终得到最优模型。A/B Testing的挑战
在于算法工程师往往需要计算很多Metrics。如果所有的Metrics都通过实时计算进
行统计，会浪费大量资源。
针对这个挑战，我们设计了A/B Testing的框架开发平台。它用来同步算法工程
师感兴趣的Metrics进行聚合，收集起来并发送到Druid引擎。这样，算法工程师根
新智能  9年双11：互联网技术超级工程
1. Blink Runtime
主要包括存储、调度和计算，不同公司在使用Flink时，存储、调度以及底层优
化等方面会有诸多不同，阿里巴巴的blink内部也对Runtime做了诸多个性化
的优化，这一层不好与Apache Flink社区统一，我们称之为Blink Runtime。
2. Flink SQL
原生的Flink只有比较底层的DataStream API，用户在使用时需要设计实现
大量的代码，次外DataStream本身也有设计上的缺陷。为了方便用户使用，
阿里巴巴团队设计了流计算的Flink SQL并推回了社区。取名Flink SQL而
不是Blink SQL，主要原因Blink和Flink在SQL这个用户API上面是完全
和社区统一的，另外Apache Flink的大部分功能都是阿里巴巴贡献的，所以
说Flink SQL就是Blink SQL，没有特别大的区别。
Blink Runtime核心优化解密
1.调度和资源管理的优化
这部分的优化主要包含以下几点：
Blink Runtime解决了大规模部署问题。早期的Flink中一个Cluster只有一
●
个JobMaster来管理所有的Job。随着Job的不断增加，单一的Master无
新智能  9年双11：互联网技术超级工程
的checkpoint的间隔需要设置的很大，不能小于1分钟。越大的checkpoint的间
隔， failover的时候回退的计算就越大，造成的数据延迟也就越严重。
为了减少checkpoint间隔，我们提出了Incremental Checkpoint的设计。概
括的说就是在checkpoint的时候只存储增量的state变化的数据。由于历史上每个
checkpoint的数据都已经保存，后面的checkpoint只需要将不同的数据放入存储，
这样每次做checkpoint需要更新的数据量就非常小，使得checkpoint可以在若干
秒级内完成，这就大大减小了failover时可能引起的延迟。
3.异步IO
很多时候我们不得不将数据放在外部存储中，这样在计算过程中就需要通过网络
IO读取数据。传统的方式使用Sync-IO的读取方式，在发出数据请求之后，只有等
待到结果返回之后才能开始下一个数据请求，这种做法造成了CPU资源的浪费，因
为CPU在大多数情况下都在等待网络IO的请求返回。Sync-IO使得CPU的资源
利用率无法提高到极致，也就大大影响了单位CPU下的计算吞吐。为此提升计算吞
吐，我们设计了Async-IO的数据读取框架，它允许异步地多线程地读取数据。每
次数据请求发出后不需要等待数据返回就继续发送下一个数据请求。当数据请求从
外部存储返回后，计算系统会调用callback方法处理数据。如果数据计算不需要保
新智能  9年双11：互联网技术超级工程
2.流处理VS批处理
要想设计和批处理统一的流计算SQL，就要了解流处理和批处理的区别。两者
的核心区别在于流处理的数据是无穷的而批处理的数据是有限的。这个本质区别又能
引入另外三个更具体的区别：
流处理会不断产生结果而不会结束，批处理往往只返回一个最终结果并且结
●
束。比方说，如果要统计双11的交易金额，使用批处理计算就要在双11当
天的所有交易结束后，再开始计算所有买家花费的总金额并得到一个最终数
值。而流处理需要追踪实时的交易金额，实时的计算并更新结果。
流计算需要做checkpoint并保留状态，这样在failover的时候能够快速续
●
跑。而批计算由于它的输入数据往往是被持久化存储过的，因此往往不需要
保留状态。
流数据会不断更新，例如某一买家的花费总金额在不断变化，而批处理的数据
●
是一天花费的总金额，是固定的，不会变化的。流数据处理是对最终结果的一
个提前观测，往往需要把提前计算的结果撤回（Retraction）做更改而批计算
则不会。