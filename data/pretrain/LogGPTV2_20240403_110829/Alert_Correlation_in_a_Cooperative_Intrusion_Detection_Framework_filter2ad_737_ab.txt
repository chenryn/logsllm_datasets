that
specifies  the  effect  of  the  attack  when  this  attack
succeeds.
logical  condition 
•  Attack  scenario:  The  combination  of  events  the
intruder performs when executing the attack.
•  Detection scenario: The combination of events that are
necessary to detect an occurrence of the attack.
•  Verification  scenario:  A  combination  of  events  to  be
launched to check if the attack succeeds.
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
whose IP address is Target_address and Partition must be
a mounted partition.
The post condition of this attack says:
•  can_access(Source_user,Partition)
That is the intruder Source_user gets an access on the
mounted partition Partition.
Notice that sometimes the effect of an attack is simply
a knowledge gain for the attacker about the target system.
This is for instance the case of attack TCPScan in figure
2. Describing this kind of attacks is very important since
their occurrence often corresponds to preliminary steps of
a  more  global  attack  scenario.  In  order  to  represent  a
knowledge  gain,  we  extend  language  L1  so  that  it  also
includes  a  meta-predicate  (actually  a  logical  modality)
knows.  For  instance,  if  bad_guy  is  the  attacker,  then
knows(bad_guy, 
use_service(192.168.12.3,’NetBios’))
means  that  bad_guy  knows  that  NetBios  is  an  active
service of system whose IP address is 192.168.12.3.
The other fields of an attack description in LAMBDA
correspond  to  attack  scenario,  detection  scenario  and
verification scenario2. These scenarios are specified using
event  calculus  algebra.  This  algebra  enables  us  to
combine  several  events  using  operators  such  as:  ;
(sequential  composition), 
(parallel  unconstrained
execution), ? (non deterministic choice), & (synchronized
execution) and if_not (exclusion of an event when another
event  occurs).  However,  all  the  examples  of  attacks  we
shall  use  in  this  paper  (including  examples  presented  in
figure  2)  actually  correspond  to  elementary  scenarios
based on a single event. This is represented by:
•  Action
| 
to specify that Action is the single event corresponding
to the attack scenario.
•  Alert
to specify that Alert is the single event corresponding
to the detection of the attack.
Finally,  conditions  appearing  in  fields  cond_scenario
and  cond_detection  are  used  to  formulate  description  of
the  event  specified  in  the  scenario  and  detection  fields.
The  cond_scenario  field  is  generally  specified  using  the
script  predicate  to  represent  the  command  the  intruder
runs  to  perform  the  attack.  The  cond_detection  field  is
used to describe the main attributes of the alert we expect
when  the  attack  occurs.  This  corresponds  to  a  logical
expression  without  restriction  (that  is,  it  can  include
conjunction, disjunction or negation). It is built using the
predicates we introduced in section 2.2 to logically model
an alert. For instance, expression:
•  alert(Alert), classification(Alert,"MIR-0163"),
source(Alert,Source),
source_user(Source,Source_user)
2  Actually,  description  of  the  verification_scenario  field  is  not
provided in the examples of figure 2.
Notice that other fields might be included in the attack
description.  For  instance,  the  ADELE  language  [11]
suggests  introducing  a  “reaction”  field  to  specify  the
actions  to  be  launched  when  the  attack  is  detected.
Actually,  in  the  remainder  of  this  paper,  we  shall  only
consider 
the  “Pre-condition”,  “Post-condition”  and
“Detection scenario” fields.
The  pre-condition  and  post-condition  of  an  attack
correspond to description of conditions over the system’s
state.  For  this  purpose,  we  use  a  language,  denoted  L1,
which is based  on  the  logic  of  predicates.  Predicates  are
used  to  describe  properties  of  the  state  relevant  to  the
description  of  an  attack.  The  set  of  predicates  used  to
represent these state conditions is partly inspired from the
taxonomy suggested by the Darpa to classify attacks (see
[8]  for  a  complete  presentation  of  this  taxonomy).  More
specifically, we shall use:
•  A predicate to specify the access level of the intruder
over the target system: access_level. For example, the
fact 
access_level(bad_guy,192.168.12.3,local)
specifies that the user whose name is “bad_guy” has a
local  access  to  host  192.168.12.3.  Possible  values  of
the  access  level  are  remote,  local,  user,  root  and
physical.
target  system.  This  set 
•  A set of predicates to specify the effects of attacks on
the 
includes  predicates
deny_of_service,  alter  and  (illegal)  use.  For  instance,
the  fact  deny_of_service(192.168.12.3)  specifies  that
the  attack  causes  a  deny  of  service  on  host
192.168.12.3.
or 
target 
For 
systems. 
•  Predicates  to  specify  conditions  on  the  state  of  the
source 
instance
use_service(192.168.12.3,showmount)  specifies  that
service showmount is active on host 192.168.12.3.
These  predicates  are  combined  using  the  logical
connectives  “,”  (conjunction  denoted  by  a  comma)  and
“not”  (negation).  Currently,  we  do  not  allow  using
disjunction in  the  pre  and  post  descriptions  of  an  attack.
Another  restriction  is  that  negation  only  applies  to
predicates, not to conjunctive expressions.1
Figure  2  provides  4  examples  of  attacks  specified  in
LAMBDA:  NFS  mount,  Modification  of  .rhost  file,
TCPScan and Winnuke. In this description, terms starting
with an upper case letter correspond to variables and other
terms correspond to constants. For instance, pre-condition
of NFS mount attack says:
•  access_level(Source_user,Target_address,remote),mou
nted_partition(Target_address,Partition)
that  is,  to  perform  NFS  mount  attack,  the  intruder
Source_user  must  have  a  remote  access  on  the  target
1 The reason of these restrictions will be explained in section 4.2.
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
mount partition
access_level(Source_user,Target_address,remote),
          mounted_partition(Target_address,Partition),
can_access(Source_user,Partition)
Action
  script(Action,’mount -t nfs $Partition:$Target_address $Partition’)
Alert
alert(Alert),
modification du .rhost
access_level(Source_user,Target_address,remote),
         can_access(Source_user,Partition),
         owner(Partition,Target_User),
         userid(Target_user,Target_address,Userid),
 access_level(Source_user,Target_address,user)
Action
script(Action,’cat "++" > .rhost’)
Alert
alert(Alert),
source(Alert,Source),
source_user(Source,Source_user),
target(Alert,Target),
target_node(Target,Target_node),
address(Node,Target_address),
classification(Alert,"MIR-0163")
source(Alert,Source),
source_user(Source,Source_user),
target(Alert,Target),
target_node(Target,Target_node),
address(Target_node,Target_address),
classification(Alert,"MIR-0164")
Lambda attack MIR-0163 – NFSMount
Lambda attack MIR-0163 – Modification of .rhost
winnuke sur la cible
use_os(Target_address,windows),
state(Target_address,available),
dns_server(Target_address)
deny_of_service(Target_address)
Action
    script(Action,’winnuke $Target_address’)
Alert
alert(Alert),
source(Alert,Source),
source_node(Source,Source_node),
address(Source_node,Source_address),
target(Alert,Target),
target_node(Target,Target_node),
address(Target_node,Target_address),
classification(Alert,"MIR-0036")
tcpscan sur la cible
use_soft(Source_address,tcpscan),
          use_service(Target_address,Target_service),
         service_type(Target_service,tcp)
   knows(Source_user,use_service(Target_address,Target_service))
Action
script(Action,’tcpscan $Target_address’)
Alert
alert(Alert),
source(Alert,Source),
source_node(Source,Source_node),
address(Source_node,Source_address),
source_user(Source,Source_user),
target(Alert,Target),
target_node(Target,Target_node),
target_service(Target,Target_service),
classification(Alert,"MIR-0074")
Lambda attack MIR-0036 – Winnuke
Lambda attack MIR-0074 – TCPScan
Figure 2 : Attack specification in Lambda
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
the 
For 
that 
instance, 
fact  attack_correlation(“MIR-
to
0066”,”MIR-0162”)  specifies 
is  possible 
correlate  attack  “MIR-0066”  (which  corresponds 
to
“rpcinfo”) with attack “MIR-0162” (which corresponds to
“showmount”).  This  is  because  the  attack  “rpcinfo”
enables the intruder to learn if rpc service “showmount” is
active.
it 
However, our objective  is  not  to  correlate  attacks  but
to  correlate  alerts.  Predicate  “attack_correlation”  is  too
coarse  for  this  purpose  because  it  does  not  provide
conditions  the  alerts  must  satisfy  to  correlate  them.  For
instance,  we  can  only  consider  that  alerts  corresponding
to attacks  “MIR-0066” and “MIR-0162” are steps of  the
same  scenario  if  the  target  systems  appearing  in  these
alerts are equal. If this condition is not satisfied, there is
no reason to correlate these alerts.
Therefore, we also introduce the following predicate:
•  alert_correlation(Alert1,Alert2):  this  predicate  says
that Alert1 is correlated with Alert2.
This predicate is used to specify correlation rules. The
conclusion  of  a  correlation  rule  has  always  the  form
alert_correlation(Alert1,Alert2).  Its  premise  specifies  the
conditions Alert1 and Alert2 must satisfy to conclude that
Alert1  and  Alert2  can  be  correlated  as  part  of  a  given
attack scenario.
For instance, figure 3 presents the rule to correlate two
alerts whose classifications are respectively  “MIR-0066”
and  “MIR-0162”.  The  premise  of  a  correlation  rule  has
always  three  parts.  Part  1  and  2  respectively  provide  a
description  of  the  two  alerts  to  be  correlated.  These
descriptions correspond to logical conditions expressed in
the language presented in section 2.2 to model alerts. Part
3 of the premise expresses the conditions to be satisfied to
correlate  the  two  alerts.  In  the  above  example,  there  are
two such conditions:
•  Condition 1 says that the target addresses appearing in
the alerts must be equal (meaning that attacks rpcinfo
and showmount applies to the same target)
•  Condition  2  says  that  the  service  name  appearing  in
Alert1  must  be  equal  to  service  “mountd”  (meaning
that one of the services provided by rpcinfo is equal to
“mountd”)
Notice  that  there  is  always  an  implicit  condition  to
correlate two alerts Alert1 and Alert2. This condition says
that  Alert1  must  occur  before  Alert2.  It  is  checked  by
comparing the detect time of Alert1  with the detect time
of  Alert2.  However, 
is  not  directly
expressed in the correlation rules because it would simply
burden specification. Instead, it is  systematically checked
when  the  correlation  rules  are  evaluated  (see  section  4.5
for more details on application of correlation rules).
this  condition 
specifies  that  Alert  is  analert  whose  classification  is
"MIR-0163"  and  source  must  match  a  given  variable
Source.  The  user  associated  with  this  source  is  another
variable  Source_user.  This  description  enables  us  to
formulate  constraints  between  the  various  fields  of  an
alert  and  the  variables  used  in  the  pre_condition  and
post_condition description of an attack.
Notice  that,  in  the  following,  the  alert  classification