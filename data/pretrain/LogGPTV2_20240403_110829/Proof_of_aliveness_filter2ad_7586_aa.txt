title:Proof of aliveness
author:Chenglu Jin and
Zheng Yang and
Marten van Dijk and
Jianying Zhou
Proof of Aliveness
Chenglu Jin1, Zheng Yang2, Marten van Dijk1, Jianying Zhou2
1University of Connecticut, 
2Singapore University of Technology and Design
*Jin and Yang share the first authorship
Aliveness of devices in cyber-physical 
systems
• Aliveness ≈ Continue to exist and work
• Importance of Aliveness:  
° Work collaboratively
° Critical component
° Safety Issues
➢ Overflow
- Water treatment system (2018 SUTD)
➢ Blackout 
- Power grid (2017 US)
Check the aliveness
• Track the running status of the devices
• Immediately raise alarm, and fix it
On-site check
Remote Monitor
Issues on checking the aliveness
• Unpredictable aliveness broken timing
° System failures/damages, replacement, malicious program update
• Inject fraud data against automatic check
data
Fraud data
watch-man
Client
Server
• Hard to identify the death promptly
This work: Proof of Aliveness
• Cryptographic notion - PoA
° Two-party protocol: prover (client), verifier (server)
° Heartbeat pattern: prover periodically sends proofs to verifier with a fixed 
time interval ∆𝑠, e.g., every ∆𝑠=30 seconds
° Dead if no valid proof within aliveness tolerance time Tatt, e.g., Tatt=3 minutes 
proofi
Prover: Client
Verifier: Server
∆𝑠
Security model for PoA
• Adversary model
Prover: Client
Verifier: Server
Security model for PoA
• Adversary model
1
Get proofi
Prover: Client
Verifier: Server
Security model for PoA
• Adversary model
1
Get proofi
2
Send proofj
Prover: Client
Verifier: Server
Security model for PoA
• Adversary model
1
Get proofi
2
Send proofj
Prover: Client
3
Get all info of verifier
Verifier: Server
Security model for PoA
• Adversary model
1
Get proofi
2
Send proofj
Prover: Client
3
Get all info of verifier
Verifier: Server
• Security goal: no adversary can forge a valid aliveness proof (especially 
when the prover is dead)
How to realize PoA
• Digital signature
° Inefficient for resource-constrained devices
• Message authentication code
° Subject to Server compromise impersonation attack
• Time-based one-time password
° Lightweight, rely on hash or one-way function (OWF)
° Server compromise resilience, e.g.,  T/Key [DMB17]
° Passwords=Proofs sent in a constant pace, every ∆𝑠 seconds
Single-chain PoA OWF from [Lam81] 
• One-way function F: {0,1}𝑚 → {0,1}𝑚
x0
Initial check-secret
Single-chain PoA OWF from [Lam81] 
• One-way function F: {0,1}𝑚 → {0,1}𝑚
x0
F
x1
F
x2
F
xN-1
F
xN
Initial check-secret
Initial verify-point
Single-chain PoA OWF from [Lam81] 
• One-way function F: {0,1}𝑚 → {0,1}𝑚
x0
F
x1
F
x2
F
xN-1
F
xN
Initial check-secret
Tend
Usage direction
Initial verify-point
Tstart
Single-chain PoA OWF from [Lam81] 
• One-way function F: {0,1}𝑚 → {0,1}𝑚
x0
F
x1
F
x2
F
xN-1
F
xN
Initial check-secret
Tend
x0
Usage direction
xi
Initial verify-point
Tstart
Verify-point xj (i+1 ≤j≤N)
Check xj ?= F(… F(F(xi)))
Prover: Client
Verifier: Server
Update xj:=xi
Single-chain PoA OWF from [Lam81] 
• One-way function F: {0,1}𝑚 → {0,1}𝑚
x0
F
x1
F
x2
F
xN-1
F
xN
Initial check-secret
Initial verify-point
• Checkpoints
° Prover stores, e.g., x100, x200, x300, … etc. 
° Facilitate the proof generation: computing from the nearest checkpoint
OWF:the limitations
• Limited proofs
° The proof number N=1 million → 1 years with ∆𝑠 =30 seconds intervals
° What if ∆𝑠 is shorter? e.g., 3s needs 10N proofs
• Larger N → larger bit-length of proofs→ less efficiency
° Security results (shown later)
• Lack of password replenishment
° Assume no long-term key public/secret key
* Can we auto-replenish the password by the protocol itself? 
• Cache many checkpoints
° How to reduce the storage overhead for the client?
PRG
Multiple-chain PoA OWF
• One-way function F: {0,1}𝑚 → {0,1}𝑚
• Pseudorandom generator G: {0,1}s → 0,1 𝑚 + 𝑠
• Lamport OTS [Lam79] – auto-replenishment (as an example)
° 2×128 secrets keys, i.e., {xi}1≤i≤256
° 2×128 verification keys, i.e., {vki=F(xi)} 1≤i≤256
° m= (0,1,1,0,0,0,1,0,1,0,0,1,…,1,0,1), the signature is: 
1
2
3
4
5
6
7
8
9
10 11 12
128
0
1
PRG
Multiple-chain PoA OWF
• One-way function F: {0,1}𝑚 → {0,1}𝑚
• Pseudorandom generator G: {0,1}s → 0,1 𝑚 + 𝑠
• Lamport OTS [Lam79] – auto-replenishment (as an example)
° 2×128 secrets keys, i.e., {xi}1≤i≤256
° 2×128 verification keys, i.e., {vki=F(xi)} 1≤i≤256
° m= (0,1,1,0,0,0,1,0,1,0,0,1,…,1,0,1), the signature is: 
1
2
3
4
5
6
7
8
9
10 11 12
128
0
1
PRG
Multiple-chain PoA OWF
Tstart
Usage direction
Tend
ss0
G
ss1 G
ss2 G
ss255 G
ss256
1
Tend
n
o
i
t
c
e
r
i
d
e
g
a
s
U
1
Tstart=Tstart
1
x0
F
1
x1
F
1
x2
1
xN
T’start
2
x0
F
2
x1
F
2
x2
2
xN
256
x0
F
256
x1
F
256
x2
256
xN
13
PRG
Multiple-chain PoA OWF
Tstart
Usage direction
Tend
ss0
G
ss1 G
ss2 G
ss255 G
ss256
1
Tend
n
o
i
t
c
e
r
i
d
e
g
a
s
U
1
Tstart=Tstart
1
x0
F
1
x1
F
1
x2
1
xN
T’start
2
x0
F
2
x1
F
2
x2
2
xN
an 𝐎𝐖𝐅 instance
256
x0
F
256
x1
F
256
x2
256
xN
13
PRG
Multiple-chain PoA OWF
Tstart
Usage direction
Tend
ss0
G
ss1 G
ss2 G
ss255 G
ss256
1
Tend
n
o
i
t
c
e
r
i
d
e
g
a
s
U
1
Tstart=Tstart
1
x0
F
1
x1
F
1
x2
1
xN
T’start
2
x0
F
2
x1