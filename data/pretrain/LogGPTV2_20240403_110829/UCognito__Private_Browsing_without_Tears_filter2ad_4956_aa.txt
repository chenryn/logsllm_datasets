title:UCognito: Private Browsing without Tears
author:Meng Xu and
Yeongjin Jang and
Xinyu Xing and
Taesoo Kim and
Wenke Lee
UCognito: Private Browsing without Tears
Meng Xu, Yeongjin Jang, Xinyu Xing, Taesoo Kim, and Wenke Lee
School of Computer Science, Georgia Institute of Technology
{meng.xu, yeongjin.jang, taesoo}@gatech.edu, {xinyu.xing, wenke}@cc.gatech.edu
ABSTRACT
While private browsing is a standard feature, its implementation has
been inconsistent among the major browsers. More seriously, it often
fails to provide the adequate or even the intended privacy protection.
For example, as shown in prior research, browser extensions and add-
ons often undermine the goals of private browsing. In this paper, we
first present our systematic study of private browsing. We developed
a technical approach to identify browser traces left behind by a
private browsing session, and showed that Chrome and Firefox do
not correctly clear some of these traces. We analyzed the source code
of these browsers and discovered that the current implementation
approach is to decide the behaviors of a browser based on the current
browsing mode (i.e., private or public); but such decision points are
scattered throughout the code base. This implementation approach
is very problematic because developers are prone to make mistakes
given the complexities of browser components (including extensions
and add-ons). Based on this observation, we propose a new and
general approach to implement private browsing. The main idea is
to overlay the actual filesystem with a sandbox filesystem when the
browser is in private browsing mode, so that no unintended leakage
is allowed and no persistent modification is stored. This approach
requires no change to browsers and the OS kernel because the
layered sandbox filesystem is implemented by interposing system
calls. We have implemented a prototype system called UCOGNITO
on Linux. Our evaluations show that UCOGNITO, when applied to
Chrome and Firefox, stops all known privacy leaks identified by
prior work and our current study. More importantly, UCOGNITO
incurs only negligible performance overhead: e.g., 0%-2.5% in
benchmarks for standard JavaScript and webpage loading.
Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—Secu-
rity and protection; K.4.1 [Computers and Society]: Public Policy
Issues—Privacy
Keywords
private browsing; browser implementation; filesystem sandbox
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear
this notice and the full citation on the first page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior specific permission and/or a fee. Request
permissions from permissions@acm.org.
CCS’15 October 12–16, 2015, Denver, Colorado, USA.
c⃝ 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813716.
1.
INTRODUCTION
Private browsing mode is an essential security feature that has
been implemented in major web browsers, such as Firefox, Chrome
and Opera. The main goal of private browsing is to let users browse
the web without storing local data that could provide some indication
of the user’s activities during a browsing session. For example, by
setting a browser to private browsing mode, a user can browse the
Internet without saving any information about which websites and
webpages he has visited. A pilot study performed by Mozilla [33]
found that users mostly switch into private browsing mode during the
lunch break, presumably because users do not want their employers
to know what they were looking at during their lunch break.
However, prior studies have shown that an adversary can easily
compromise such a privacy goal. For example, Aggarwal et al. [1]
demonstrated that browser extensions and add-ons can easily under-
mine the security of private browsing. Their study also resulted in
a change in Google Chrome which disables all extensions while a
user remains in private browsing mode.
In this paper, we examine the security of private browsing in
Google Chrome and Mozilla Firefox. In particular, we develop an
automatic tool to identify the browser traces left behind by a private
browsing session. We find that Chrome and Firefox browsers do
not correctly clear browser traces left by some browser components
when they exit a private browsing session. We demonstrate that
the failure of handling these components completely undermine the
goals of of private browsing. For example, as we will show in §3, an
adversary can infer the websites that a user has visited by accessing
the OCSP (online certificate status protocol) cache left behind by a
private browsing session.
An instinctive reaction to the above finding would be to make the
aforementioned components aware of the private browsing mode, in
particular, by preventing them from writing anything to disk while
in this mode. However, such a privacy-aware development approach
relies on developers to carefully insert condition checks on the cur-
rent browsing mode and implement the correct logic for each mode.
Given the complexities of browsers (and its extensions and add-ons),
developers are prone to make mistakes and as a result, some browser
components would remain privacy-unaware, as shown in several
recent reports [8, 37].
In order to overcome the limitation of the privacy-aware devel-
opment approach, we design and implement UCOGNITO, a uni-
versal framework for private browsing mode. With UCOGNITO,
inadvertent disclosure of private information can be avoided in
spite of privacy-unaware implementation by browser developers.
UCOGNITO achieves this by overlaying the actual filesystem with
a sandbox filesystem and restricting all the modifications made by
a web browser to the sandbox filesystem when the browser is run-
ning in private browsing mode. Once the browser exits its private
browsing mode, UCOGNITO discards the sandbox filesystem and no
persistent modification is stored. Considering that different browsers
define private browsing differently, UCOGNITO also provides a set
of privacy policies, thus allowing each browser to implement its
private browsing mode according to its own definition.
UCOGNITO does not require any change to browser implemen-
tation. As a result, any browsers or browser-support applications
(e.g., Chrome apps) can be run in private browsing mode no mat-
ter if the browsers or applications support private browsing mode.
Since UCOGNITO implements the layered sandbox filesystem by
interposing system calls, it does not require any modification to the
OS kernel.
In summary, this paper makes the following contributions.
• We propose an automatic tool, called UVERIFIER, that exam-
ines the security of private browsing and identifies previously
unknown privacy violations in major browsers.
• We design UCOGNITO and demonstrate how it helps to im-
plement private browsing mode for both Chrome and Firefox
and how users can customize the system to suit their privacy
needs.
• We implement UCOGNITO and evaluate its functionality and
performance on Linux. We show that UCOGNITO is effective
in preventing privacy violations with negligible overheads.
The rest of the paper is organized as follows. §2 discusses the
threat model and the security goals of private browsing. §3 examines
the security of private browsing and identifies privacy unaware im-
plementation in web browsers. §4 presents the design of UCOGNITO
followed by its implementation and evaluation in §5 and §6, respec-
tively. §7 and §8 discuss the extensibility of UCOGNITO and related
work. Finally, we conclude our work in §9.
2. BACKGROUND: PRIVATE BROWSING
In this section, we begin with the threat model and security goals
of private browsing. Then, we discuss how web browsers achieve
these security goals from the perspective of their implementations.
In particular, we review the implementation of private browsing in
two open source browsers: Chrome and Firefox.
2.1 Private Browsing Mode
According to [11], private mode is commonly perceived by nor-
mal users as a mode that could provide additional privacy protection
on users’ browsing activities compared with public mode. In prac-
tice, however, it is up to the browser vendor to define what these
additional privacy protections are and some of them may not even
align with an individual user’s expectation or privacy needs.
Table 1 shows the differences in the interpretation of private
mode by five mainstream browsers. Most notably, Chrome provides
two implementations of private mode, termed Incognito Mode and
Guest Mode, respectively, and states that the Guest Mode provides
stronger privacy protection than the Incognito Mode in the sense
that accesses to persistent data stored in existing user profile, such as
browsing history, autofill, etc, are blocked [12]. All other browsers
we surveyed do not provide such a Guest Mode. There are other
differences. For example, Safari allows persisting per-site permis-
sion (such as using Notification API [34]) learned in private mode
in favor of usability, while other browsers disallow such operation
in favor of privacy.
We also observed conflicts between users’ privacy needs and
browser vendors’ decisions in terms of what traces should be stored
and used in private mode. For example, in one Firefox bug report
in 2009 [23], the user is having concerns that SSL client certificate
obtained in private mode should not be persisted, although Firefox
until now is still persisting such data. In a recent survey on pri-
vate browsing [11], some participants even indicate that they would
like to keep previously acquired cookies in private mode to enable
auto-login in most websites, trading privacy for usability. In cur-
rent private mode implementation, there is no way to resolve these
conflicts because developers’ decisions are in fact hard-coded in the
browser and the only option left to users is to either manually clean
this trace (which is non-trivial) or accept developers’ decisions. Our
goal is not only to respect each browser vendor but also to give
freedom and control back to users for their pleasure.
2.2 Privacy Goals
Given the heterogeneity in the interpretation of private browsing
mode, it is not possible to define private browsing mode in terms
of a set of specific data allowed to be stored or used. In this pa-
per, we respect this heterogeneity and instead define the high-level
properties of private browsing. More specifically, we say that the
implementation of a private browsing mode achieves the intended
privacy protection if both goals are satisfied:
• Stealthiness: any data in private mode should not be stored
unless explicitly communicated to and agreed by the user. If
this goal fails, knowing of such persistent data would increase
the probability of recovering users’ online activities in private
browsing session.
• Freshness: any persistent data obtained from previous brows-
ing sessions should not be used in private mode unless explic-
itly communicated to and agreed upon by the user. If this goal
fails, knowing of such trace would increase the probability
of recovering users’ online activities in previous browsing
sessions.
Threat Model. We assume a same computer host-guest threat
model which both can be malicious: (1) A guest launches private
mode to prevent the host from inferring his browsing activity. The
host is assumed to have full control of filesystem after the guest
browsing session. (2) A host restricts a guest in private mode to
prevent his browsing activity from being inferred by the guest. A
guest is allowed to perform any browsing permitted by browser
during the private browsing session.
2.3 Complexity of Implementation
A naive implementation of private mode would be to disable
all features that could persistently store data in filesystem, such as
cookies, HTML5 local storage, etc. However, such an approach
would allow a website to easily detect whether the user is in private
mode by testing whether such features are accessible. In fact, for
features that persist data in public mode, browsers tend to imple-
ment a similar but non-persistent version to give the website an
impression that such features is available and hence hide any visible
effect of browsing in private mode. Such “mimicking” approach
is to satisfy the indistinguishability requirement that states that the
website should not be able to distinguish in which mode a user visits.
However, it also makes the private mode implementation inherently
complex and brings about issues that defeat the two privacy goals.
Indeed, when we reviewed the source code of Chrome 37.0.1 and
Firefox 42.0.2331, we found that both browsers follow the “mimick-
ing” approach. Moreover, the way the “mimicking” is implemented
is ad-hoc with heavy use of if-else branches and polymorphism to
achieve logic separation between public mode and private mode,
which exponentially increase code complexity.
Category
Persistent data
Firefox
Transparent to user
User action involved
Add-on support
Browsing history
Cookies
Cache
HTML5 local storage
Flash storage
Download entries
Autofills
Bookmarks
Per-site zoom level
Per-site permission
SSL self-signed cert
SSL client cert
Add-on storage
Add-on enabled by default
✓
✗
✗
✗
✗
✗
✓
✓
✓
✓
✓
✓
✓
✓
Use
Chrome
Incognito
✓
✗
✗
✗
✗
✓
✓
✓
✓
✓
✗
✓
✓
✗
Guest
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✓
-
✗
Opera
Safari
IE
Firefox
✓
✗
✗
✗
✗
✓
✓
✓
✓
✓
✗
✓
✓
✗
✓
✗
✗
✗
✗
✓
✓
✓
-
✓
✓
✓
✓
✓
✓
✗
✗
✗
✗
✗
✓
✓
-
✗
✗
✓
✓
✓
✗
✗
✗