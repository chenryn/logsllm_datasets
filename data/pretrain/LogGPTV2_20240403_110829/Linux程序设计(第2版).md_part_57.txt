续本章的学习，可以跳到debug4.c程序，到那时我们已经把内存访问方面的第一个问题弥补好了。
请看下面的操作：
Starting program: /home/neil/debug3
(gdb)ran
Progranreceived signal SIGSBGv, Segmentation fault
0x8048488 in 80rt (a=0x8049684,n=5) at debug3.c:23
23
/*23/
if [al51.key > a[{+1].key] {
(gdb)
程序运行依然不正确。程序运行失败的时候，gdb会报告出失败的原因和程序失败时所处的
位置。下面我们来调查问题的根源。
根据读者的操作系统内核、C语言库和编译器版本的具体情况，你可能会看到冲突发生在一
个稍微不同的地点，比如发生在交换数组元素的第25行面不是发生在比较数组元素关键字的第
23行。如果是前一种情况，你应该看到象下面这样的信息：
Progran roceived signal SIGSEGv,Segmentation fault
25
/25/
[+1 =[5]
两个问题的根源是一样的，你还是可以沿着我们的gdb操作示例继续学习。
9.3.3堆栈跟踪
程序停在sort函数里，地点是源文件debug3.c的第23行。如果编译程序时没有（用cc命令的
“-g”选项）添加调试信息，我们就无法看到程序失败时停在了什么地点，也不能用变量名检查
数据。
用backtrace命令可以查出程序是如何到达这一位置的，如下所示：
0x8048488 in sort (ax0x8049684,n=5) at debug3.c:23
加入jaVa编程群：524621833
---
## Page 301
第9章调试与纠错
283
#1
0x804859e in main () at debug3.c:37
2
0x40031cb3in
_1ibc_start_main (mainCx84d5fc , argc=1,
rt.1d_fini=0x4000a350  a[j▪11.key]{
调试器能够对函数参数的内容、局部变量和全局性数据等进行检查。print命令的作用就是
给出变射或其他表达式的内容，如下所示：
axd(qp5）
$1 = 4
我们看到局部变量“的值是4。这就是说，程序曾经尝试执行这样一条语句：
if(a[4] .xey > a[4+1] .key)
我们传递给sor函数的数组array只有五个元素，它们的下标是从0到4。因此，这个语句实际
上是在读一个并不存在的数组元素“array[5]”。循环计数器变量“j”取了一个错误的值。
如果读者用这个例子做练习时程序停在了第25行，就说明你的系统是在准备交换数组元素
时才检测到“读数组时越界”错误的，当时执行的语句是：
/*25▪/a[j]=a[5+1];
当“j”取值为4时将造成下面这样的结果：
a[4] ± a[4+1]:
要想查看已经处理完的数组元素，需要在print命令里使用一个表达式。gdb允许我们使用儿
乎一切合法的C语言表达式来查看变量的取值、数组元素和指针。
gdb
gdb把命令的结果保存在伪变量“S”里。最近一次操作的结果永远是“S"，倒数第
2次操作的结果是“SS”。这使我们可以把某次操作的结果用在另一个命令里。请看下面的例子：
加入jaVa编程群：524621833
---
## Page 302
284
Linux程序设计
(gdb) print j
{gdb)print a[$-1].key
$3 = 4
$4 = 1
9.3.5列出程序清单
在gdb里我们可以用list命令列出程序的源代码清单来。这个命令会给出当前位置前后周围的
一段代码：继续使用list命令将显示得更多。我们可以给list一个行号或者一个函数名做参数，而
它就会把指定地点附近的代码列出来。
(gdb)11st
18*/
19
19
int s = 1;
2.0
/
20
fot(: 1  {
21
/*
21
22
22
fort-0：ja[+1].key}{
25
iten t = a[jl
26
/*26
a[j+1] = t:
a[j] = a[j+1]:
27
/27/
(gdb)
s++
我们可以看到，在第22行上，循环被设置为“当变量j小于n时继续执行”。在我们的例子电，
n等于5，所以j的最大取值是4，再大就退出循环了。当j取值为4的时候，参加比较的数组元素分
别是a[4]和a[5]、而这就引起了内存段冲突。这个问题的解决办法之一是把终止循环的条件改正
为j ,key =3}
要想查看一组连续的数据项，我们可以用“@”记号让gdb打印出指定个数的数组
元素来。使用下面的命令可以把数组中的五个元素都打印出来：
(gdh]print arrayto]es
\000·,key3）.
data =*john*.
000
,
key =4).{
data = *rick",
\000
,
key = 2).
key 51.
data =*alex*,*\000·, key = 1}}
我们对输出结果做了些修饰，让它们读起来容易一些。因为这是循环语句第一次执行时的
情况，所以数组还没有发生变化。我们让程序继续执行，随着程序执行的进展，我们将看到数
组array后续的变化：
(gdb)cont
加入java编程群：524621833
---
## Page 304
286
Linux程序设计
Cont inuing.
Breakpo1nt 1, sort (a=0x8049684. n-4) at debug4.c:2C
20
20
for{; i , key = 3).{
'\000*
.
key * 1}.
key - 4},
.000.x.=p
, key = 5}!
(gdb)
我们可以通过display命令对gdb进行设置，让它在程序停在每一个断点位置的时候都把数组
打印出米，如下所示：
(gdb）display array[0]e5
=x.000.u.=e2
data = *neil*,
\000·，key-4}.（
{{SAay 160 s1eeda>000）.x,= eep
data 、*alex",
\000′crepeats 4091 times,key =11,
f
我们还可以对断点做进一步设置，使程序不是在断点停下米，而是把我们要求的数据显示
出来后继续往下执行。我们用command命令来完成这一工作，它的作用是让我们指定在程序到
达断点位置时将要执行的调试器命令。因为我们已经设置了一个displsy显示命令，所以我们只
需把断点位置上的命令设置为继续执行就行了。如下所示：
Type conmands fur when breakpoint 1 1s hit, one per line.
(gdb)conpands
End with a line saying just *end".
>cont
> end
现在，当我们让程序继续执行的时候，它将一直执行到结束；外层循环每执行一次都会把
数组的值打印一次。如下所示：
(gdb) oont