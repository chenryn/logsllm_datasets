935934e00e9d96ae7ce3e0db311466e4c706d137e28f6b34147978d6777198b0
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
2
STATUS PORTS NAMES
935934e00e9d training/webapp:latest "python app.py" 5 seconds ago
Up 3 seconds 0.0.0.0:49153->5000/tcp suspicious_hoover
3
可以看到，这里定义了/webapp数据卷。
此外，我们可以通过docker inspect命令查看容器的数据卷，定位到数据卷相关的字段内容， 4
具体为：
5
$ docker inspect suspicious_hoover
...
"Volumes": {
6
"/webapp":
"/var/lib/docker/vfs/dir/6fd914759fac2a0bff479e94a5961ec8b3a8505fc7f95e4921d24ff9f9d3ab74"
},
7
"VolumesRW": {
"/webapp": true
}
... 9
邮 当然，也可以直接通过格式化参数--format来查看指定数据卷部分的数据，具体操作为：
8
电 $ docker inspect --format {{.Volums}} suspicious_hoover
map[/webapp:/var/lib/docker/vfs/dir/6fd914759fac2a0bff479e94a5961ec8b3a8505fc7f95e4
921d24ff9f9 d3ab74] 10
可以看出，默认情况如果只是声明数据卷而没有映射到宿主主机上的具体目录，Docker会在
/var/lib/docker/vfs/dir/下分配一个具有唯一名字的目录给该数据卷。 10
我们可以通过在宿主主机上使用ls参数验证该目录是否存在：
11
$ sudo ls -l /var/lib/docker/vfs/dir/
总用量 4
drwxr-xr-x 2 root root 4096 12月 17 14:11 13
6fd914759fac2a0bff479e94a5961ec8b3a8505fc7f95e4921d24ff9f9d3ab74
可以看到，在宿主主机上已经为该数据卷建立了一个独一无二的目录。 14
4.2.2 挂载主机目录作为数据卷 15
除了上述的仅仅声明一个数据卷外，我们还可以指定宿主主机上的某个目录作为数据卷。例
16
如，我想把当前目录挂载为容器的/opt/webapp数据卷，具体操作为：
$ docker run -d -P --name webapp -v .:/webapp training/webapp python app.py
17
41be1170a753614d96aa2d7f0eb05d9b16b174be84ae673312a0a984cae009c6
2014/12/17 14:44:24 Error response from daemon: Cannot start container
41be1170a753614d96aa2d7f0eb05d9b16b174be84ae673312a0a984cae009c6: cannot bind mount volume: . volume 18
paths must be absolute.
56 第4章 数据卷及容器连接
提示挂载出错！为什么呢？输出提示为数据卷的路径必须是绝对路径。所以“.”这个相对路径
是会挂载失败的。正确的做法是：
$ docker run -d -P --name webapp -v `pwd`:/webapp training/webapp python app.py
295d19d19fbb0880eab75aa0e154be7f17cb1bb47bf2a67b4e5ec977470a91dd
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
295d19d19fbb training/webapp:latest "python app.py" 2 seconds ago
Up 2 seconds 0.0.0.0:49164->5000/tcp webapp
查看并定位到数据卷字段信息：
$ docker inspect webapp
...
"Volumes": {
"/webapp": "/home/micall/docker"
},
"VolumesRW": {
"/webapp": true
}
...
可以看到，在Volumes字段中，容器内的/webapp目录映射到了宿主主机上的/home/micall/docker
目录。
通过挂载本地目录到容器的数据卷，宿主主机对目录内的改变会同步反映到容器中，反过来
也一样。我们可以利用这种方法把本地的一些数据复制到挂载目录下，提供给容器处理。容器也
可以将处理结果写到该目录下，方便本地用户查看。需要说明的是，如果容器内部已经存在
/webapp目录，那么挂载宿主目录之后，它的内容将会被覆盖。
需要注意的是，Dockerfile并不支持挂载本地目录到数据卷，这主要是因为不同操作系统的
目录格式不尽相同。为了保证Dockerfile的移植性，所以不支持挂载本地目录到数据卷。
在上述inspect输出信息中，有一个字段是VolumesRW，配置的是数据卷的读写权限，默认情
况下是读写，我们可以改变它的读写权限。具体做法是在创建数据卷的后面跟上权限控制，例如
要将webapp数据卷由默认的wr可读可写变成ro只读。具体操作为：
$ docker run -d -P --name webapp -v `pwd`:/webapp:ro training/webapp python app.py
$ docker inspect webapp
...
"Volumes": {
"/webapp": "/home/micall/docker"
},
"VolumesRW": {
"/webapp": false
}
...
可以看到，VolumesRW中/webapp的值为false。
4.2 数据卷 57
4.2.3 挂载主机文件作为数据卷
1
除了可以将主机目录挂载为数据卷外，还可以将单个主机的文件挂载为容器的数据卷。例如，
2
在本地的当前目录下建立一个text.txt文件，里面输入一行“hello world”，然后将该文件挂载为数
据卷。具体操作如下：
3
$ touch test.txt
$ gedit test.txt
$ docker run --rm -it -v ~/docker/test.txt:/test.txt ubuntu:latest /bin/bash 4
root@6e3ece82bfbc:/# ls
bin dev home lib64 mnt proc run srv test.txt usr
boot etc lib media opt root sbin sys tmp var 5
root@6e3ece82bfbc:/# cat test.txt
hello world
root@08554d5bc816:/# vi test.txt 6
root@08554d5bc816:/# cat test.txt
hello world
hello docker 7
root@08554d5bc816:/# exit
exit
micall@micall-ThinkPad:~/docker$ cat test.txt 9
hello world
hello docker
8
在上述操作中，我们先在本地文件系统中创建了一个test.txt，并在里面添加了一行“hello
world”，然后运行ubuntu容器，并将刚刚新建的text.txt文件挂载到容器内的/text.txt。ls命令的输
10
出表明该文件映射成功了，使用cat命令查看该文件的内容，输出即为hello world。然后在容器
中通过vi编辑器编辑该文件，加入hello docker这行字符串。退出容器，到本地文件系统打开该
10
文件，发现容器对它的改变也会同步到本地。
11
4.2.4 数据卷容器
数据卷容器是指一个专门用于挂载数据卷的容器，以供其他容器引用和使用。它主要用在多 13
个容器需要从一处获得数据时。在实际操作时，需要将数据容器命名，有了确定的容器名之后，
对它有依赖关系的其他容器就可以通过--volumes-from引用它的数据卷。 14
首先，建立一个数据卷容器，名为dbdata,并为该容器新建数据卷/dbdata。具体操作为：
15
$ docker run -d -v /dbdata --name dbdata training/postgres
a8d875ccbfbbf9188b450fc9aee68f34581d6f6cd39306a196991da73feaf394
$ docker ps 16
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
a8d875ccbfbb training/postgres:latest "su postgres -c '/us 3 seconds ago 17
Up 2 seconds 5432/tcp dbdata
接着创建一个容器db1，它引用dbdata的数据卷，具体操作为： 18
58 第4章 数据卷及容器连接
$ docker run -d --volumes-from=dbdata --name db1 training/postgres
24ea52056abb9f2b2f02f22c421f2e901072a28de437e9442e01bdcf85906614
为了验证db1引用的是dbdata的数据卷，可以通过docker inspect命令来分别查看db1和dbdata
容器，具体操作为：
$docker inspect dbdata
...
"Volumes": {
"/dbdata":
"/var/lib/docker/vfs/dir/886e6809b26d7dd765f1f59e93ff5be93d8c30a91e9e5ab14a244e638b
d946e1"
},
"VolumesRW": {
"/dbdata": true
}
...
$docker inspect db1
...
"Volumes": {
"/dbdata":
"/var/lib/docker/vfs/dir/886e6809b26d7dd765f1f59e93ff5be93d8c30a91e9e5ab14a244e638b
d946e1"
},
"VolumesRW": {
"/dbdata": true
}
...
可以看到，二者的数据卷是一样的。也就是说，db1容器和dbdata容器使用的是同一个数据
卷/dbdata。需要说明的是，数据卷一旦声明，它的生命周期和声明它的那个容器就无关了。当
声明它的容器停止了，数据卷也依然存在，除非所有引用它的容器都被删除了并且显式地删除了
该数据卷。此外，一个容器引用一个数据卷容器时，并不要求数据卷容器是运行的。
我们可以让多个容器引用数据卷容器。例如，新建一个容器db2，它也引用dbdata容器的数
据卷，相关操作为：
$ docker run -d --name db2 --volumes-from=dbdatatraining/postgres
此外，数据卷容器还可以级联引用。例如，新建一个容器db3，它引用db1容器的数据卷，具
体操作为：
$ docker run -d --name db3 --volumes-from=db1 training/postgres
同样，可以用docker inspect查看其数据卷，结果是一样的。和dbdata、db1、db2一样，它
们共用一个数据卷。
无论是声明数据卷的容器还是后续引用该数据卷的容器，容器的停止和删除都不会导致数据
卷本身删除。如果需要删除数据卷，那么需要删除所有依赖它的容器，并且在删除最后一个依赖
4.2 数据卷 59
容器时加入-v标志。这里，假如dbdata、db1和db2都已经删除了，那么删除db3的时候加上-v参数， 1
就可以删除数据卷，具体为：
2
$ docker rm -v db3
此时你会发现在/var/lib/docker/vfs/dir/目录下就没有该数据卷对应的目录了。
3
4.2.5 数据的备份与恢复
4
利用数据卷容器，还可以进行数据的备份和恢复等。
5
1. 备份
利用数据卷容器，我们可以备份一个数据卷容器的数据。
6
首先，建立了一个数据卷容器，相关操作为：
7
$ docker run -d -v /dbdata --name dbdata training/postgres
这里通过-v创建了数据卷/dbdata，并将容器命名为dbdata。假如容器在运行过程中把产生的
9
数据都保存到了/dbdata目录下。现在，我们想把它的数据备份到本地，相关操作为：
$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf 8
/backup/backup.tar /dbdata
这里我们通过ubuntu镜像新建了一个容器，它引用了dbdata容器的数据卷，并创建了一个数 10
据卷映射，将本地文件系统的当前工作目录映射到容器的/backup目录。通过tar命令将/dbdata目
录打包到/backup数据卷中，而该数据卷又因映射到了本地，所以dbdata容器的数据卷内的数据就
10
保存到了本地的当前目录，文件名为backup.tar。
2. 恢复数据 11
恢复数据和备份数据一样简单。我们的目的是将本地的备份压缩包解压并加载进某个容器
13
内，让其基于该备份的数据继续运行。
首先，我们先声明一个需要恢复的数据容器，操作为：
14
$ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash
15
该命令通过ubuntu镜像创建名为dbdata2的容器，该容器还创建了数据卷/dbdata。
然后，我们利用另一个引用它的容器来关联到本地目录，并将本地的数据解压进数据卷中去，
16
具体做法为：
$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf
17
/backup/backup.tar
该命令使用busybox镜像创建一个容器，该容器引用dbdata2的数据卷，并且也创建了另一个 18
60 第4章 数据卷及容器连接
数据卷/backup，/backup被映射到本地文件系统中的当前目录。本地的当前目录存有backup.tar
压缩包，然后通过tar解压到/dbdata数据卷下，这样就把备份好的数据重新恢复到容器内部。
4.3 容器连接
在4.1节中，我们使用了-P或者-p来暴露容器端口，以供外界使用该容器。在这一节中，我们
要说明另一种容器对外提供服务的方法——容器连接。容器连接包含源容器和目标容器：源容器
是提供服务的一方，对外提供指定服务；目标容器连接到源容器后，就可以使用其所提供的服务。
容器连接依赖于容器名，所以当需要使用容器连接时，首先需要命名容器，然后使用--link参数
进行连接。
4.3.1 容器命名
容器连接依赖于容器的名字。虽然容器启动后，Docker会自动为容器赋予一个名字，但是这
个随即分配的名字并没有实质的意义。自己给容器命名有如下两个好处。
 一个有意义的名字能够表明该容器的用途，这样方便记忆。例如，你可以将一个Web应
用容器命名为web，而Docker自动分配名字的话，或许它就是david。很明显，我们更喜
欢前者。
 命名后的容器在容器连接中能够清晰地表征容器之间的逻辑依赖关系。例如，一个源容
器里面包含的是数据库应用，我们将其命名为dbdata容器，然后目标容器是一个Web应用
容器，这样连接的时候，我们就知道Web应用需要用到数据库服务。
介绍完容器连接中容器命名的重要性之后，现在通过--name参数来命名容器，具体操作为：
$ docker run -d -P --name web training/webapp python app.py
这里我们使用training/webapp镜像创建了一个名为web的容器，容器运行python命令。通过
docker ps命令查看容器状况，如下：
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
d15c6e42de4b training/webapp:latest "python app.py" 4 seconds ago
Up 2 seconds 0.0.0.0:49166->5000/tcp web
可以看到，我们的webapp容器已经已经运行起来了。
4.3.2 容器连接
连接的格式为--link name:alias，其中name是源容器的名称，alias是这个连接的别名。