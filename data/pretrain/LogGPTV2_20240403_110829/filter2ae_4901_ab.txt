——————————————————————————————————————————————————————————————————
①首先，在攻击前，我们要知道代码的CRC检测是针对代码段的
②代码段是用来执行的，正常情况下不会有其他数据访问代码段，被访问的大多是数据段，代码段被访问，很可疑就是CRC检测
③此处说的“访问”的概念，大家可以通过CheatEngine工具中的“找出是什么访问了这个地址”来理解
开干！
⒈针对0x402000这个地址，在CheatEngine工具中鼠标右键，查找访问，操作如下：
2.检测出现了！
我们记录一下该处的访问代码：
    0040103F - movsx ecx,byte ptr [eax]
因为Ollydbg的调试体验要更好一些，所以我们记录地址：0x40103F，并转到Ollydbg去分析：
Ollydbg舒服就舒服在还能把你的代码分析出来，太强了！
⒊下断走一遍流程
刚开始的时候，注意观察eax：
单步往下执行，下面会有个强制性的向上跳转：
继续执行走到初始位置：
总结：发现eax由0x400000变成了0x400001，也就是说，它在循环的递增检测所有范围内的内存代码数据
⒋返回上一层观查一下函数
通常，大家可能会CTRL+F9返回上一层，或者按如下图中返回：
这样做后就发现无论如何都无法返回，那应该怎样做呢？
很简单，我们可以从堆栈中返回，堆栈窗口有个神奇的功能就是返回数据：
对着“返回到”敲下回车键，抽个烟的时间：
奇迹竟然发生了：
瞧瞧我们看见了什么？
①我们自己写的CRC检验函数  
②检验函数上面就是我们的参数，起始检测地址和检测范围  
③我们自己写的信息框函数和Sleep函数
这个位置，相当于代码中的：
    //初始内存校验值
    unsigned int uMainMoudleSumA = Calc_Crc32(0, (char*)0x400000, 0x1F000);//400000- 41D000
    //while循环开启CRC检测
    while (1)
    {
        //CRC循环检测内存实时校验值
        unsigned int TmpCrcSum = Calc_Crc32(0, (char*)0x400000, 0x1F000);
        if (TmpCrcSum != uMainMoudleSumA)
        {
            //封号处理-掉线处理
            MessageBoxA(NULL, "CRC代码校验检测到您修改了代码！", "Caption", MB_OK);
        }
        Sleep(2000);
    }
对比图：
怎么样，是不是很刺激？
**0x05：对自己的CRC程序的攻击测试**
——————————————————————————————————————————————————————————————————
在这里呢，我们简单的讲几种过掉的姿势：
⒈跳转jmp直接Pass
分析：这个位置直接Pass掉下方的CRC校验函数，直接跳转到了getchar函数，过于简单粗暴，仅适用于该程序，不适用于网络游戏哦~
⒉Nop大法
Nop大法尤其要注意Nop一定要Nop彻底！另外一定要堆栈平衡！否则被检测或者程序崩溃！
⒊分析代码更改判断条件
下断看eax，eax根据代码结合内层函数得知，是我们的CRC校验值：
内层函数：
单步执行，根据我们观察eax，发现该处是初始校验值和实时校验值的比较处：
那么我们干脆一不做二不休，直接cmp ecx,ecx，让他跳转永远相等，就永远不检测了：
当然还有其他的一些方法，在这里大家可以开动想象力，自行实践哦~
总结：
①要充分观察寄存器窗口数据的变化  
②注意疑似校验值的数据以及校验值的判断和计算  
③Nop要彻底，并且保证堆栈平衡  
④大家自由发挥
**0x06：对某厂商的网络FPS游戏实战CRC对抗测试**
——————————————————————————————————————————————————————————————————
⒈看一下游戏的样子：
该游戏可实现除草功能，地图除草方法：
CheatEngine工具搜索字节数组：55 8B EC 8B 45 08 83 EC 08 8B 48 10 8B
01，找到的地址减去0x22，对该地址nop即可实现除草
⒉分析一下除草地址的检测
由于我们是搜索特征得到的，该游戏的除草功能也是通过修改代码段nop实现的，所以触发了代码的CRC校验检测，符合我们今天讲的知识
查找访问，发现四条访问地址，这个即为我们的CRC检测的访问：
查看相关的汇编代码：
发现：
①疑似加密密匙的东西  
②所有的四条访问均来源于同一个代码段，观看代码得知属于同一个Call，也就是检测Call  
③由于该检测Call被厂商修改过，所以属于比较特殊的变形CRC
⒊下断检测的代码，观察寄存器
只能推断EAX有可能是校验的次数，也就校验的大小，其他的寄存器并无法得知是否是校验值
⒋去函数的头部看一看
头部下断：eax疑似校验值，edx疑似校验大小，也就是循环的次数
继续运行，发现eax和edx同时变化：
edx在这里变化了两次，第一次为我们的计次，第二次为edi的数据，我们尝试修改头部的数据进行攻击测试：
[由于涉及游戏安全和平衡，在这里，我不将写入的数据进行公开，大家有兴趣的可以自行研究实践]
下hook处理：
①分配内存写数据
因为是jmp 5字节hook，所以要注意写法
②跳转至hook位置
OK，接下来就是漫长的等待~
只要CheatEngine工具的访问不出现新的访问，那么检测就过掉了
北京时间比较准确：
CRC一直没有访问，尝试开启除草功能：
开启后效果：
几分钟过去了，CRC依然没有访问，玩家死亡依然没有访问：
继续开一局游戏：
至此，该功能检测被过掉，检测稳定了.
**0x07：总结**
⒈外x挂和反外x挂的斗争依然在继续，各大游戏厂商必须加强游戏的检测防护，避免外x挂产业泛滥！  
2.多层嵌套的检测是必须的，在嵌套的同时，还应该注意代码混淆的程度也要加大！  
3.务必加强对CheatEngine等工具的检测，一旦发现，就封号处理，提高逆向难度！
**0x08：声明**
1.游戏逆向仅限于技术交流，切勿用于违法犯罪，切勿开发违法犯罪的相关外x挂、辅x助等工具！  
2.本文章由个人原创作品，如需转载，请务必带上出处！  
3.如果本人中有疏漏和错误，请及时提醒我更正，万分感激！
**0x09：参考文献**
《加密与解密第四版》——段钢  
《百度百科》——   
《维基百科》——
**0x10：最后要说的话**
1.逆向一时爽，一直逆向一直爽，爽的同时千万千万不要误入歧途，违反法律，不然警察叔叔上门送温暖了~
2.八月份，新的月份，祝大家顺顺利利，万事如意，七夕快到了，做人不缺爱，做x不缺人，团团圆圆，心想事成