个状态对应的符号是F，见第3 行。
部)上的转换。在图4-31中，状态0有--个F上的到达状态3 的转换，因此我们压人状态3。
体是id)弹出栈并将产生式头(在这个例子中是 F)压人栈中来实现的。现在栈中保存的是状态,
5(符号id)已经被压人到栈中。从状态5 出发没有输人＊上的转换，因此我们选择归约。根据状
因此我们选择移人。在第2行，状态
态
底标记$。
动
号"列中。在第1行，栈中存放了
状态所对应的文法符号显示在“
个栈来保存状态。为清晰起见，栈
例4.43
动机和一个状态栈来做出移入－归约语法分析决定。
们使用哪个产生式进行归约。
所有的状态都是接受状态。我们说的“状态”指的是对应于项集！的状态。
示过了。
LR(0)自动机已经在前面的图4-31中显
甲
范
LR(O)自动机。这个自动机的状态是
析技术）的中心思想是根据文法构造
中的转换表示。
例4.42
可以从相应状态中获取，因此它的栈只保存状态。
5 的转换，因此我们将状态5(符号id)压人栈中。状态5 没有转换，因此我们按照F→id进行
们弹出和符号id对应的状态5，使得状态0 成为栈顶。然后我们寻找一个 F（即该产生式的头
5 中的项[F→id·］，这次归约应用产生式 F→id。
id上有－-个到达状态5 的转换。
机的开始状态0，相应的符号是
1*id时采取的动作。我们使用-
为α且状态j有一个在α上的转换，就移人α。否则我们就选择归约动作。状态j的项将告诉我
GOTO 函数给出。表达式文法(4.1)的
LR(0)项集族中的元素，而它的转换
语法分析
我们看另一个例子，考虑第5行，状态7(符号＊)位于栈顶。这个状态有一个id上的到达状
下一个输人符号是id，而状态（
将在4.6.3节中介绍的LR 语法分析算法用它的栈来跟踪状态及文法符号。实际上，文法符
LR(O)自动机是如何帮助做出移人－归约决定的呢？移人－规约决定可以按照如下方式做
这个LR(O）自动机的开始状态是CLOSURE（［S'→·S]），其中S'是增广文法的开始符号。
如果栈中保存的是文法符号，那么归约就是通过将相应产生式的体(在第2行中,产生式的
假设文法符号串使LR(0)自动机从开始状态0运行到某个状态j。那么如果下一个输入符
“简单LR 语法分析技术"（即 SLR 分
LR(O)自动机的用法
图4-34 给出了一个使用图 4-31中的 LR(0）自动机的移人－归约语法分析器在分析
文法(4.1)的规范 LR(0)项集族和 GOTO 函数如图 4-31所示。其中,GOTO 函数用图
栈
自
符
0
口
行号
void items(G') {
02710
0275
027
3
until 在某--轮中没有新的项集被加入到C中；
repeat
图4-33规范 LR(0)项集族的计算
={CLOSURE([S' → ·S])):
下面的例子将展示如何使用一个LR(O）自
图 4-34id*id 的语法分析
for（C中的每个项集I）
的
的
输人
社过
S
按接
移
按移
按
人到5
人到7
照T→F归约
照F
E→T归约
→id归约
→id归约
动作
157
这
口
---
## Page 174
它表示最右句型的方法本质上和一个移人－归约语法分析器的表示方法相同。唯一的不同之处
的对。其中,第一个分量是栈中的内容(右侧是栈顶)，第二
L
张
语
那么（
节和4.9.4 节中进一步讨论这样的错误恢复例程是如何工作的。
是使用状态来代表α。
ACTION[i，α］的取值可以有下列四种形式：
相关联。
转换一定对应于同一个文法符号X。因此，除了开始状态0之外,每个状态都和唯一的文法符号
个项集对应，并且有一个从状态i到状态j的转换当且仅当GOTO(I，X）=I。所有到达状态j的
SLR 方法类似。根据构造方法，每个状态都有一个对应的文法符号。回顾一下，各个状态都和某
中sm位于栈顶。在SLR方法中，栈中保存的是LR(O)自动机中的状态，规范LR 和LALR 方法和
容所含信息的摘要。
应的状态。每个状态都是对栈中该状态之下的内
移人一个符号时，LR语法分析器移入的是一个对
区逐个读人符号。当--个移人－归约语法分析器
分析器的不同而变化的。语法分析器从输人缓丫
器的驱动程序都是相同的,而语法分析表是随语
两个部分（ACTION 和 GOTO）。所有 LR 语法分析
动程序和一个语法分析表组成。这个分析表包
4.6.3LR 语法分析算法
如下的最右句型：
如：
语法分析器的完整状态包括：它的栈和余下的输人。LR 语法分析器的格局（configuration)是一个
其逆命题不一定成立。也就是说，多个状态可能对应于同一个文法符号。例如,图4-31中的 LR(0)自动机的状态：
2）我们把定义在项集上的 GOTO 函数扩展为定义在状态集上的函数：如果 GOTO[1，A］=1，
分析器的栈存放了一个状态序列 sos"`$m，其
图4-35 中显示了一个 LR 语法分析器的示意图。
描述 LR 语法分析器的行为时，我们需要一个能够表示 LR 语法分析器的完整状态的方法。
④ 报错。语法分析器在它的输人中发现了一个错误并执行某个纠正动作。我们将在4.8.3
①移人j，其中j是一个状态。语法分析器采取的动作是把输入符号α高效地移人栈中，但
158
LR语法分析器的格局
GOTO 也把状态i和一个非终结符号A 映射到状态j。
③ 接受。语法分析器接受输入并完成语法分析过程。
② 归约 A→β。语法分析器的动作是把栈项的β高效地归约为产生式头 A。
1）ACTION 函数有两个参数：一个是状态i,另一个是终结符号α（或者是输入结束标记$）。
语法分析表由两个部分组成：
LR 语法分析表的结构
1 和8,进人它们的都是E上的转换；而对于状态2 和9,它们都是通过T上的转换进人。
(sos..sm; aiai+!..an $)
一个语法分析动作函数 ACTION 和---个转换函数GOTO。
uD...1+!D?D"x...x'x
冲
法
括
图。它由一个输人、一-个输出、一个栈、一个驱
栈
第二个分量是余下的输入。这个格局表示
图4-35
Sm-1
输人
A
一个 LR 语法分析器的模型
ACTION
LR
GOTO
序
[as
第4章
输出
号
---
## Page 175
下面再次给出文法(4.1），并对它们的产生式进行编号：
例4. 45图4-37显示了表达式文法(4.1)的一个 LR 语法分析表中的 ACTION 和 GOTO 函数。
分析器执行图 4-36 中的程序。
函数。
算法4.44
器之间的唯一区别是它们的语法分析表的 ACTION 表项和 GOTO 表项中包含的信息不同。
恢复例程。
的输出。我们暂时假设输出的内容仅仅包括打印出归约产生式。
的文法符号序列 Xm-+".Xm总是等于β，即归约使用的产生式的右部。
动作中，当前的输人符号不会改变。对于我们将构造的LR 语法分析器，对应于被弹出栈的状态
其中,r是β的长度，且s=GOTO[sm-
在，
入栈中，进人格局
的格局如下：
然后在分析动作表中查询条目 ACTOIN[sm，α;]。对于前面提到的四种动作，每个动作结束之后
为栈底标记，同时也在语法分析过程中担负了重要的角色。
在于栈中存放的是状态而不是文法符号，从这些状态能够复原出相应的文法符号。也就是说，X;
误指示。
方法:最初，语法分析器栈中的内容为初始状态so，输人缓冲区中的内容为w串。然后,语法
1）如果ACTION[sm，α”=移人s，那么语法分析器执行－次移人动作；它将下--个状态s移
语法分析
输
输入：一个输人串 w和一个LR语法分析表,这个表描述了文法G的 ACTION 函数和 GOTO
LR 语法分析算法总结如下。所有的LR 语法分析器都按照这个方式执行，两个LR 语法分析
2） rj表示按照编号为j的产生式进行归约。
 在一次归约动作之后，LR语法分析器将执行和归约所用产生式关联的语义动作，生成相应
2）如果ACTION[sm，α;］=规约A→β，那么语法分析器执行--次归约动作，进人格局
当前的输入符号是αi+1。
符号α;不需要存放在栈中，因为在需要时（在实践中从不需要α;)可以根据s恢复出α。现
语法分析器根据上面的格局决定下一个动作时，首先读人当前输人符号α;和栈顶的状态 sm,
1） si 表示移人并将状态i压栈。
各种动作在此图中的编码方法如下：
LR 语法分析器的行为
出：如果w在L(G)中，则输出w的自底向上语法分析过程中的归约步骤;否则给出一个错
LR 语法分析算法。
(3) T→T*F
(2) E→T 
(1) E-→E + T
(sos!..sm$, ai+.".an$)
，A］。在这里，语法分析器首先将个状态符号弹出栈，
(6) F→id
(5) F→(E)
(4) T→F
159
口
---
## Page 176
人，将状态5压
符号，而第一个输人符号是id。图
于状态0上。这是初始状态，没有对应的文法
序列。比如，在
图
内
来处理这个问题。
的表中各个条目
GOTO[s，A]的值。
TO条目给出了对应于非终结符·
上对应于状态α的移人动作一起给出。