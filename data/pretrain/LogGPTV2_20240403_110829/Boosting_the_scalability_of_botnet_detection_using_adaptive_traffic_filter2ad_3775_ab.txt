tector module. We developed a Fine-Grained Detector de-
rived from BotMiner [7] and BotSniﬀer [5], and we plugged
it into our botnet detection framework.
In particular, we
used two components: i) an implementation of the malicious
activities detector derived from BotMiner’s A-Plane moni-
tor, which can identify groups of similar malicious activities
based on the attack features (e.g., the scanned port, the ex-
ploits or binary content), and ii) BotSniﬀer’s IRC-based bot-
net detection module. Similar to the Cross-Plane correlation
in BotMiner, the correlation component correlates commu-
nication patterns and activity patterns to detect bots. Any
pair of IPs that share persistently similar communication
patterns (generated by Flow-Correlation) and similar mali-
cious activities (generated by the malicious activities detec-
tor) are labeled as bots by the correlation component. And
any host identiﬁed by the BotSniﬀer’s IRC-based botnet de-
tection module will be labeled as bot.
4. FLOW CAPTURE
The Flow-Capture performs packet sampling and reassem-
bles raw ﬂows using a novel botnet-aware adaptive sampling
algorithm, which we call B-Sampling. Our B-Sampling al-
gorithm leverages the intrinsic characteristic of bots, namely
group similarity, to guide the sampling procedure. Given
a pre-deﬁned target sampling rate, B-Sampling adaptively
tunes the instant sampling probabilities for diﬀerent cate-
gories of IPs. For example, priority will be given to packets
related to IPs that share similar communication patterns,
while keeping the overall sampling rate close to the overall
target sampling rate SRT arget. The target sampling rate
is usually suggested by the process capacity of the monitor
device and the traﬃc speed of the monitored network. For
example, the monitor device with capacity of Capdevicebps
and the network with the speed of Capnetworkbps indicate
SRT arget = Capdevice
Capnetwork
.
4.1 Packet Sampling
As described in Figure 2, Packet-Sampling has four
components: Counting-Sketch, Sampling-Sketch, Syn-
chronized IPs Detector (SID), and Priority-based Sam-
pling Probability Calculation (PSPC). Counting-Sketch
tracks the number of packets sent from a SrcIP to a DstIP.
After each time interval of T , Packet-Sampling transfers the
Counting-Sketch to the SID, and then resets the Counting-
Sketch to 0 for next interval. The end of each time interval
also triggers the SID and PSPC to identify IP addresses with
synchronized behaviors and recalculate the instant sampling
probability for each category of IPs. Sampling-Sketch gets
the instant sampling probability for a packet and decides
whether this packet is going to be sampled.
4.1.1 Counting/Sampling Sketch
a
table
indexed
is
The Counting-Sketch
by
Hash(SrcIP ||DstIP ) for TCP and UDP packets, where
each entry in the table is deﬁned as a track-ﬂow. Each en-
try contains a pair of IPs (SrcIP and DstIP ) and a counter
cnt, which represents the number of packets for this pair
of IPs. For TCP packets, the entry keeps SYN/SYNACK
ﬂag. On arrival of a packet, the SrcIP and DstIP will be
recorded and the counter in the corresponding entry will
be increased by 1. The Counting-Sketch only handles the
packets from internal networks to external networks. Such
design can simplify the system implementation by just
monitoring the separated physical line for outgoing traﬃc.
Moreover, it reduces the time and memory consumption to
access the table. Counting-Sketch is reset to be 0 after the
time interval T (currently 15 minutes).
Each entry in Sampling-Sketch records a category/set of
IPs, a counter of packets related to these IPs, a sampling
probability and a priority. On arrival of a packet, Sampling-
Sketch checks the category of this packet based on its SrcIP
and DstIP. It then ﬁnds the instant sampling probability
(pi) for the corresponding category and samples this packet
with probability pi. The sampled packets, together with
their sampling probabilities, are sent to Flow-Assembler.
4.1.2 Synchronized IPs Detector
The SID identiﬁes two kinds of hosts with synchronized
behaviors:
i) syn-servers: the hosts in external networks
whose clients have similar network behaviors; ii) syn-clients:
the hosts in internal networks that share similar network be-
haviors to multiple destination hosts.
The detection of syn-servers is motivated by the network
behavior of C&C servers for centralized-based botnets, where
their clients (bots) are synchronized and thus share similar
network behaviors. For the legitimate servers, especially the
popular ones, their clients’ behaviors usually diverse from
each other due to various usage patterns of diﬀerent users.
The detection of syn-clients is motivated by the network
behaviors of P2P-based C&Cs. P2P-based bots usually ac-
tively query their peers to maintain the overlay P2P network
for botnet C&Cs. Such behaviors will cause many similar
connections to multiple peer bots.
To detect syn-servers and syn-clients, we introduce “homo-
server” and “similar-client”.
1. Homo-server: We aggregate entries in Counting-Sketch
based on each DstIP. For each DstIP that has at least
two SrcIPs, we calculate the variance of the track-ﬂow
sizes. We sort the variances and get the medium value
vmedium. For one DstIP, if its variance vi  priority2 · · · > priorityn. {p1, p2, . . . , pn}
Algorithm 1: Identify Synchronized Hosts
Input: Counting Sketch, Setd, tcur
Output: Setd: Records for syn-clients/servers.
begin
foreach Record R ∈ Setd do
if tcur − R.timestamp ≥ Trec then
Remove R from Setd;
foreach DstIP dhi in the Counting Sketch do
if dhi is homo-server then
Arr.get(dhi).score+ = stepup ;
if Arr.get(dhi).score ≥ T Hsyn−server then
setd.add(dhi, tcur);
Arr.get(dhi).score = T Hsyn−server;
if dhi is non-homo-server then
Arr.get(dhi).score− = stepdown ;
if Arr.get(dhi).score ≤ T Hdown then
Arr.get(dhi).score = T Hdown;
foreach SrcIP shi in the Counting Sketch do
if shi is similar-client then
Arr.get(shi).score+ = stepup ;
if Arr.get(shi).score ≥ T Hsyn−client then
setd.add(shi, tcur);
Arr.get(shi).score = T Hsyn−client;
else
Arr.get(shi).score− = stepdown ;
if Arr.get(shi).score ≤ T Hdown then
Arr.get(shi).score = T Hdown;
return Setd;
end
is a set of instant sampling rates for diﬀerent priorities and
budget is for the available budget.
i=1 fi(Pt
bi
fi
bi
fi
) = KPt Pn
i=1 Kfipi = K Pn
The following equation illustrates how the budget alloca-
tion helps the sampling component to keep a target sampling
rate. Suppose there are a total of K packets and the target
sampling rate is Pt. Given n categories and suppose each
category has fi fraction of the total packets and we give bud-
get bi to this category, we can calculate the sampling prob-
ability for category i as pi = Pt
. In this case, the number
of sampled packets Q and overall sampling rate would be
Q = Pn
i=1 bi. Ac-
cording to this equation, as long as Pn
i=1 bi = 1, the over-
all sampling rate Q
K would be Pt, the target sampling rate.
Since fi cannot be obtained precisely in advance, we dy-
namically estimate fi using W M A (weighted moving aver-
age) based on the observed value for it in the previous and
current intervals, which is fi = w1f prev
where
w1 = 0.2 and w2 = 0.8 in our current design. The system
can dynamically assign priority1 or priority2 to syn-servers
or syn-clients. The fewer the packets related to one of these
two categories, the higher priority it has. The intuition be-
hind such design is to use enough resource to build the ac-
curate ﬂows for the category that requires least resource.
In practice, operators can also ﬁx the priority or introduce
more categories/priorities based on known knowledge (e.g.,
a category for the packets that are sent to conﬁrmed bot
peers). The packets related to the rest of IPs are labeled as
+ w2f curr
i
i
the lowest priority (priority3).
4.2 Flow Assembler
The Flow-Assembler assembles sampled packets to gen-
erate raw ﬂows, where each raw ﬂow is identiﬁed by 5-
tuple key (SrcIP, SrcPort, DstIP, DstPort, Proto). For TCP
ﬂow, the ﬁrst two handshake packets (SYN and SYNACK )
can be used to identify the ﬂow direction. However, since
packet sampling may result in the loss of TCP handshake
packets, we use following approaches to identify TCP ﬂow
direction. First, if one of these two handshake packets is
sampled, we can easily identify the ﬂow direction. Second,
for a TCP ﬂow without TCP handshake packets sampled,
we take this ﬂow as it is initiated from internal networks
(e.g., its SrcIP is from internal network). These approaches
guarantee that every TCP ﬂow from internal network will be
attributed to the correct direction. Flow-Assembler outputs
a ﬂow if the ﬂow is ﬁnished (e.g., the TCP FIN/RST ﬂag is
observed) or it expires (e.g., no packet comes for this ﬂow for
10 minutes). For one raw ﬂow, we record information includ-
ing timeStart, timeEnd, sizeActual (# of packets observed),
byteActual (# of bytes observed) and sizeEst. sizeEst is the
estimated ﬂow size based on the sampled packets and their
corresponding instant sampling probabilities. Suppose there
are n packets for one raw ﬂow and each packet has bi bytes
and sampling probability of pi, we compute the metrics for
this raw ﬂow as follows: sizeEst = Pn
, sizeActual = n,
byteActual = Pn
1
pi
i=1
i=1 bi.
Algorithm 2: Priority-based Sampling Algorithm
Input: Pt, f1, f2, . . . , fn
Output: p1, p2, . . . , pn
begin
budget = 1;
foreach i = 1 . . . n do
if fi == 0 or budget ≤ 0 then
pi = 0;
continue;
else
pi = budget ∗ Pt
;
fi
pi = pi > 1?1 : pi;
budget− = pi ∗ fi
Pt
;
return {p1, p2, . . . , pn};
end
5. FLOW CORRELATION
The goal of Flow-Correlation is to identify hosts with
persistently similar communication patterns. By evaluat-
ing the capacity of the ﬁne-grained detectors and the mon-
itored network, operators can estimate the percentage of
hosts P erExp (as described in Figure 1) that ﬁne-grained
detectors can aﬀord to monitor. For example, if we assume
that the traﬃc is evenly distributed over the hosts in the
monitored network, the capacity of a ﬁne-grained detector
(Capdetectorbps) and the network speed (Capnetworkbps) in-
dicate a P erExp = Capdetector
. The Flow-Correlation com-
Capnetwork
ponent identiﬁes groups of hosts (up to P erExp) that share
most similar communication patterns and show persistence.
cluster: gi
cluster: gi
group: c1
A, B, C
group: c2
A, B
group: c3
A, B, D
c2
c1
A, B
c3
Figure 3: An Example of Cross-Epoch-Correlation
5.1 Flow Aggregation
We use C-ﬂow to represent the communication pattern
from a host to a remote host and port. We deﬁne a C-ﬂow as
a set of raw ﬂows sharing same tuple of (SrcIP, DstIP, Dst-
Port, Proto) in a certain epoch E (currently E = 12hours),
denoted as c = {f1, . . . , fn}. To get C-ﬂows, we ﬁlter out the
raw ﬂows that satisfy either of two conditions:
i) The raw
ﬂow is initiated from external network to internal network,
where the reason is discussed in Section 4.1. ii) The raw ﬂow
has traﬃc in only one direction, which indicates an unsuc-
cessful connection. We represent a C-ﬂow (c = {f1, . . . , fn})
using the following 10 features.
1. The means and variances of f ph (the number of ﬂows
per hour), ppf (the number of packets per ﬂow), bpp
(the number of bytes per packet), pps (the number of
packets per second), which have similar deﬁnition in
BotMiner [7]. We use sizeEst to compute ppf and
pps, while byteActual
sizeActual
is used for bpp.
2. f phmax: the maximum number of ﬂows per hour.
3. timem: the median time interval of two consecutive
ﬂows.
5.2 Cross-Epoch Correlation
Given P erExp, cross-epoch correlation identiﬁes pairs of
IPs where each pair shares persistently similar communica-
tion patterns for at least M epochs out of totally N epochs
(M ≤ N ).
i , c2
i . . . cN
i ∪ c2
i · · · ∪ cN