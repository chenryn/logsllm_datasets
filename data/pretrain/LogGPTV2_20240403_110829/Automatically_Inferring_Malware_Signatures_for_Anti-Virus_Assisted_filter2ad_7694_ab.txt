matching region is speciﬁed in the second parameter (162970)
and in the latter case in the ﬁrst parameter (81920). The
type of the hash function is derived by ClamAV based on
the size of the hash sum or the database ﬁle it is stored in.
Similarity Measures
2.2.3
Aside from byte patterns and hash sums, anti-virus soft-
ware often employs other measures to identify security threats,
that allow to more generally describe a malware binary or
its behavior. These may include the inspection of instruction
counts, the analysis of API usage, n-gram detection models,
and in some cases even machine learning techniques. In com-
parison to signatures based on byte patterns and hash sums,
these detection approaches are often bound to a concrete
execution context and can capture complex semantics, such
as diﬀerent events necessary to trigger an infection. Due to
this complexity such detection schemes are less suitable for
constructing malicious markers and we thus put our focus
solely on pattern-based signatures.
3.
INFERRING MALWARE SIGNATURES
A classic approach for deriving signatures from virus scan-
ners is reverse engineering the respective analysis engines
and dumping the signature database [42]. Such reverse engi-
neering, however, relies on tedious manual work and needs
to be repeated for each individual scanner. We in contrast
introduce a simple and intuitive, yet generic method that is
agnostic to the inspected virus scanner: Given a set of known
malware samples, we strategically create modiﬁcations of
these ﬁles and scan them to see whether the scanner still
ﬂags them as malicious. This procedure allows us to derive
a signature by piecing together bytes that are observed to
be relevant for detection over diﬀerent samples and runs.
Although simple in design this method is suﬃcient to obtain
suitable markers for anti-virus assisted attacks as introduced
in Section 2.
Our method for the derivation of signatures executes the
following three steps which can be applied to any possible
virus scanner:
1. Detecting relevant bytes. First, we determine relevant
bytes in each malware sample by utilizing feedback
from the virus scanner over multiple runs (Section 3.1).
2. Sequence alignment and merging. We proceed to align
the relevant bytes from samples with the same signature
and merge them into a single sequence (Section 3.2).
3. Creation of signatures. Finally, we transform the merged
sequences into a valid signature format, yielding the
ﬁnal signature (Section 3.3).
In the following, we discuss each of these steps in detail and
describe the optimizations we perform compared to a naive
implementation.
5893.1 Detecting Relevant Bytes
We begin our analysis by processing each malware sam-
ple independently to derive bytes relevant for detection.
To achieve this, the main idea is to simply ﬂip—bitwise
negate—one byte after another and run the target virus
scanner on the resulting ﬁle. If the modiﬁed ﬁle does not
trigger an alarm, the changed byte is relevant for detection
and thus we include the original value of that byte in our
signature. If in contrast, the scanner shows no reaction to
our modiﬁcation, the byte seems to be irrelevant.
There are three problems with this approach in practice.
First, determining the exact signature requires to exhaus-
tively test all possible combinations rather than simply ﬂip-
ping bytes. Second, the largest portion of a virus scanner’s
runtime is taken up by its initialization. Passing each ﬁle
variation to the scanner separately therefore induces a high
runtime overhead. Third, a naive implementation of this
approach requires quadratic disk space and its runtime is
dominated by the disk’s I/O operations.
As a remedy, we restrict the derivation to signatures that
match all samples in our dataset of the same malware family
but are not necessarily complete. For the application as
malicious markers this however is a suﬃciently good approx-
imation. Moreover, we reduce the runtime overhead induced
by the scanner’s initialization by passing samples to the
scanner in large batches rather than separately. We ﬁnally
address the third problem by formulating the following algo-
rithm that follows a divide-and-conquer approach to perform
byte ﬂipping: The complete ﬁle is ﬁrst divided into k parti-
tions. For each partition, all bytes are ﬂipped and the virus
scanner is applied to the modiﬁed ﬁle. If a partition does not
contain relevant bytes (the scanner still detects the malware)
no further inspection is needed and the complete partition is
considered to be irrelevant for the signature. Otherwise, the
same procedure is recursively applied until partitions can no
longer be divided. In eﬀect, large portions of a ﬁle can be
quickly marked as irrelevant and dismissed.
The procedure presented thus far is well suited for signa-
tures based on byte patterns but ineﬃcient when dealing
with hash-based signatures, particularly if the hash sum is
calculated over the entire ﬁle. Our approach would ﬂip all n
bytes individually and requires to scan the resulting n ﬁles
in order to derive this relation. To speed up this process
we introduce two thresholds th and tp. The ﬁrst relates to
the ratio of bytes considered relevant during one iteration
of the divide-and-conquer process. The second speciﬁes the
partition sizes for which our heuristic is applied: if th = 99%
of a partition with at least tp = 25, 000 bytes are marked
as relevant, we conclude that we are dealing with a hash-
based signature and focus the search on the edges of the
partition to determine the exact region the hash is calcu-
lated on. This allows us to decide whether or not we are
dealing with a hash-based signature at an early stage and
accelerate the process signiﬁcantly.
As a result of this analysis, we obtain a preliminary sig-
nature s = (w, l, h) for each sample x composed of m bytes
x1, . . . , xm. We construct this signature by ﬁrst creating a
format description ˆw where ˆwi = (cid:63) if xi corresponds to an
irrelevant byte, and ˆwi = {xi} if xi is a relevant byte. We
proceed to create a compressed form of ˆw referred to as w
by scanning ˆw from left to right and merging consecutive
irrelevant bytes (gaps). Relevant bytes, however, are pre-
served for the sake of signature alignment as described in
Section 3.2. We additionally store information about the
length of the gaps as the minimum and maximum number
of repetitions. That is, for each byte wi, we set l(i) and h(i)
to the number of symbols of ˆw merged to obtain wi. The
resulting signature may still be changed in the next step to
account for information contained in other samples tagged
with the same signature label.
3.2 Sequence Alignment
We proceed by grouping malware samples according to
the label assigned by the scanner. For a given group of
corresponding signatures X, we then create a joint signature
by employing the Needleman-Wunsch algorithm [39]. That
is, we align their corresponding format descriptions given by
the set {w | (w, l, h) ∈ X}. During this procedure we ignore
the minimum and maximum number of repetitions encoded
by the functions l and h at ﬁrst and merely compare the
signature’s format descriptions.
Given two strings v and w, the Needleman-Wunsch algo-
rithm attempts to align these strings, that is, it creates new
strings ˆv and ˆw from v and w respectively by introducing an
arbitrary number of irrelevant bytes denoted as (cid:63) between
bytes of v and w. These additional irrelevant bytes serve
as padding, ensuring that ˆv and ˆw are of same size. The
algorithm attempts to ensure that ˆwi is equal to ˆvi for as
many of the strings’ positions i as possible. For merging the
resulting alignment we combine the length speciﬁcations de-
noted by l and h and extend the bounds such that the range
is maximized. Moreover, for positions i where ˆvi and ˆwi are
unequal, we simply merge the sets ˆvi and ˆwi by applying
the union operator. To create a signature for an entire set
of strings, we iteratively apply the Needleman-Wunsch algo-
rithm to merge one signature at a time with the preliminary
version of our ﬁnal signature.
To further detail the range speciﬁcations one can employ
a similar approach as used for identifying relevant bytes
(see Section 3.1). We insert or delete dummy bytes at the
locations of irrelevant bytes to determine the number of bytes
that may occur in between sequences of relevant bytes and
apply the virus scanner to it. To this end, we again make
use of a (binary) divide-and-conquer strategy in order to
speed up the process. While this approach provides a precise
solution, this strategy is time consuming and thus we omit
this step for our experiments and exclusively rely on the
alignment described above.
As a result of this step, we obtain a signature for each
group of samples, that is, a tuple (w, l, h) where w describes
the signatures format as a sequence of disjunctions over bytes,
and l(i) and h(i) are the minimum and maximum number of
repetitions of the i-th symbol in w.
3.3 Creation of Signatures
We ﬁnally construct signatures compliant with those used
by ClamAV and in accordance with our formal deﬁnition.
To this end, we join the values of each symbol wi using the
alternate operator ’|’ surrounded by brackets, which may be
omitted if a symbol contains one value only. Additionally, we
annotate this speciﬁcation of a symbol with its minimum and
maximum number of repetitions expressed as ranges {n-m},
where n and m are speciﬁed by a signature’s functions l and
h. Strictly speciﬁed ranges such as {n-n} are simpliﬁed to
{n}. Repetitions of exactly one, {1-1} and {1} respectively,
are omitted yielding a ﬁnal signature as shown in Figure 3.
590(8a|86)0666(29|31)(c8|d0|d8|e8|f8)(86|88)0646
(a) ClamAV signature W32.Virut.si
(86|8a)0666(29|31)(c8|d0|
e8
)(86|88)0646
Type
PE32
PE32+
MS-DOS executable
Archive formats
# Type
9,721 Windows shortcuts
38 HTML/XML
38 Text
14 Others
#
21
121
15
1
(b) Derived signature for W32.Virut.si.
Table 1: Overview of the evaluation dataset.
Figure 3: Signatures for the Virut malware (a) as
found in ClamAV ’s database and (b) derived by our
method (missing bytes are indicated by spaces).
4. EMPIRICAL STUDY
Equipped with a method for automatically deriving sig-
natures from virus scanners, we conduct an empirical study
with four popular anti-virus products and the open-source
scanner ClamAV . As we are not interested in comparing
individual security vendors but in gaining insights into used
signatures, we reference these scanners in the following as
AV1 to AV5 , with ClamAV being AV1 as our baseline. In
particular, we carry out four experiments on a recent malware
dataset that is detailed in Section 4.1:
• First, we demonstrate the viability of the proposed
method for signature derivation in a controlled experi-
ment using ClamAV (Section 4.2).
• Second, we apply our method to the virus scanners we
do not have ground truth for and perform a quantitative
study of the derived signatures (Section 4.3).
• Third, we investigate whether or not signatures from
diﬀerent vendors overlap, that is, cover identical mal-
ware bytes, and if so, to which extend (Section 4.4).
• Fourth, we study the quality of deployed signatures
with special focus on semantics and whether or not
they are bound to a speciﬁc context (Section 4.5).
4.1 Malware Dataset
The quality of derived signatures hinges on a representative
dataset of malware for deriving corresponding signatures. We
thus collect 9,969 malware samples that are detected by all
ﬁve scanners considered in our evaluation.
In particular,
we have been given access to submissions to the VirusTotal
service, allowing us to gather a broad selection of recently
submitted ﬁles. A brief overview of the dataset is presented
in Table 1. The vast majority of the ﬁles are applications
or dynamic libraries in the Portable Executable format. The
remaining ﬁles correspond to archives, Windows shortcuts
and other carriers of malicious code. Depending on the
applied virus scanner, the ﬁles in the dataset are assigned
to roughly 250 malware families, where the concrete number
of diﬀerent signature labels assigned by the scanners ranges
from 277 up to 1,327 (see the ﬁrst column in Table 2).
4.2 Controlled Experiment: ClamAV
In the ﬁrst experiment, we evaluate our approach in a
controlled setup using the open-source scanner ClamAV for
which all signatures are publicly available and we thus have
ground truth to assess the reconstruction capabilities of our
approach. To this end, we ﬁrst derive signatures for all
samples in our datasets and then compare the output to
the corresponding signatures of ClamAV using the string
edit distance [32].
In this experiment we focus on static
pattern-based signatures as returned by our method, but
skip hash-based signatures as these are not suitable for being
used as malicious markers (cf. Section 2). Moreover, we
replace gaps in all signatures with a generic wildcard to
account for minor diﬀerences in the gap ranges.
Figure 4: Quality of derived signatures, measured as
the normalized edit distance between the derived sig-
natures and the corresponding ClamAV signatures.
Figure 4 presents the results of this comparison as the
distribution of the observed distances to the original sig-
natures. To achieve a comparison between signatures of
diﬀerent lengths, we normalize the edit distance d(x, y) be-
tween two signatures x and y as follows:
˜d(x, y) =
d(x, y)
max(|x|,|y|)
∈ [0, 1]
where |x| and |y| correspond to the lengths of the signatures.
The resulting distribution of normalized distances has a sharp
peak close to 0.0 and roughly 50% of all derived signatures
match their counterpart in the ClamAV database almost
perfectly. Moreover, 75% of the derived byte patterns diﬀer
from the original signature by at most 4% of the content
and only a minor fraction cannot be correctly derived by our
method.
As an example of this experiment, let us re-consider the
derived signature shown in Figure 3. The two expressions
are almost identical except for the third disjunction, where
the derived signature misses two out of ﬁve possible bytes
(indicated as spaces). As shown in Figure 1, this signature
corresponds to a simple decryption loop that is varied by
the malware authors using diﬀerent instructions and regis-
ters. Our dataset comprises samples of the Virut malware
with three of the ﬁve variants encoded in the ClamAV sig-
nature and thus the derived signature does not match its
counterpart exactly. Still, the rest of the byte patterns and
their disjunctions are precisely uncovered by our approach.
In addition to the successful derivations, we also inspect
0.00.10.20.30.40.50.60.70.80.91.0Distance to ClamAV signatureDensity75%90%95%DistributionMeasurements591cases where our method fails to arrive at a good approx-
imation of the original signature. One example is a vari-
ant of the malware family Adware.Somoto1 which ClamAV
identiﬁes using a compact byte pattern that our approach
misses. A closer investigation reveals that the corresponding
sample is a self-extracting archive of the Nullsoft Scriptable
Install System (NSIS) for which ClamAV introduced an un-
packer in version 0.91. Dynamic analyses and unpacking are
out of scope of our method.
4.3 Quantitative Study: AV2–AV5
We proceed to derive signatures for the remaining four