number of distinct values, this assumption does not hold.
As a result, meaningless relations are often learnt, such as
the relationship between a ﬁle descriptor argument of read
and an open of an entirely different ﬁle that was opened
and closed long ago. To address this problem, we specify
that when a close(fd) occurs, no more relationships in-
volving that fd should be learnt. This is speciﬁed in the
conﬁguration ﬁle using a “terminate” ﬂag with the close
operation.
Another related problem involving ﬁle descriptors is that
a number of “useless” relationships are learnt. Suppose that
a program opens a ﬁle at location (cid:2)0 and then performs
read operations on this ﬁle from locations (cid:2)1,..,(cid:2)n. Let X0,
X1,..,Xn be the corresponding argument names. Our algo-
rithm will learn that Xn has equality relationships with X0
through Xn−1, that Xn−1 has equality relationships with
X0 through Xn−2, and so on. From a security perspective,
it is clear that a relationship between Xi and X0 is useful,
for 0 pw_uid);
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:47:23 UTC from IEEE Xplore.  Restrictions apply. 
In the above code, setsockopt() operation requires
root privilege. For this reason, the privilege is temporar-
ily escalated using seteuid(0), and then dropped after-
words using seteuid(pw->pw uid). The attack exploits
the format-string vulnerability to change pw->pw uid to 0.
Therefore, the root privilege is maintained even after sec-
ond seteuid() call, which allows the remote attacker to
upload and download arbitrary ﬁles as a root user.
In our experiments, we did not use the actual format-
string attack, but simulated it by instrumenting the code
to change value of pw->pw uid under attack scenario.
Our implementation detected this attack because it learns
an equality relation between the argument of seteuid at
line L2 and another setuid call appearing in the function
pass(), which is invoked when the user ﬁrst logs in. This
equality relation is violated in an attack. It is important to
detect this attack as a violation of this relationship: an alter-
native, such as raising an alarm when the absolute value of
seteuid argument at L2 is zero, would raise a false alarm
when root uses this server.
Netkit Telnetd: Corruption of ﬁlename to be executed [5].
At the beginning of each client connection, the telnet dae-
mon authenticates its user with an external program. The
name of this program is stored in a variable loginprg. In
this attack, a heap overﬂow vulnerability is used to over-
write this variable with the value /bin/sh, so that a subse-
quent authentication attempt by a user will result in a root
shell. We simulated this attack in the similar manner as the
previous attack.
With typical conﬁgurations of telnetd, loginprg al-
ways has the value /bin/login. In this conﬁguration, it is
easy to detect the attack as a violation of the value normally
observed as the argument of execve. It is more interest-
ing to note that our models are successfully able to handle
atypical conﬁgurations as well, where telnetd may be in-
voked with different command line parameters specifying
different authentication programs. In this case, recall that
the tracer introduces a synthetic event to record the com-
mand line argument. The model captures the relationship
between this argument and the argument of execve. In this
manner, a model that is produced in an environment using
a login program x can be deployed in another environment
with a login program named y, and still be able to detect
this attack.
GHTTPD: Directory traversal by corrupting ﬁlename [5].
A stack overﬂow in GHTTPD web server can be used
to evade path name checks, and execute an arbitrary pro-
gram [5]. Attack occurs in the following code fragment in
serverconnection function:
if (strstr(ptr, "/.."))
return ... //reject request
Log(...);
L1: if (strstr(ptr, "cgi-bin")) execve(ptr, ...)
Variable ptr is a pointer to a text string of the
URL requested by a remote client.
The function
serverconnection() checks the absence of "/..", and
the presence of "cgi-bin" in the URL before the CGI
request is handled. The purpose of these checks is to en-
sure that only programs in the CGI-BIN directory are exe-
cuted by the server. The function Log() has a buffer over-
ﬂow vulnerability which is exploited to change ptr to point
to a string /cgi-bin/../../../../bin/sh (details can
be found in [5]). The subsequent check strstr(ptr,
"/cgi-bin") is successful and spawns a shell. We used
an actual buffer overﬂow to produce this attack.
Our system learns that
the common preﬁx of all
ﬁles executed at L1 is the CGI-BIN directory,
i.e.,
F isWithinDir CGI-BIN directory, where F is the ﬁle
name argument of execve. Since this condition is violated
by the above attack, our approach was able to detect it.
Fingerd symlink vulnerability. Some programs assume
that ﬁle names given to them are regular names and do not
contain symbolic links. Attacks can be crafted by violat-
ing this assumption. We describe an example of symlink
vulnerability in old versions of BSD fingerd [8]. This
server uses a local finger client program to serve remote
requests. The server runs with root privileges, and executes
the client without dropping these privileges. This allows the
following attack: a user can create a symbolic link called
.plan in his home directory that points to a ﬁle readable
only to root (e.g., the shadow password ﬁle). Now, by run-
ning a ﬁnger on himself from a remote site, he can see the
contents of this ﬁle.
The vulnerability arises in the following code snippet in
show text() function, which veriﬁes the presence of a ﬁle
to be shown, but does not check if it is a symbolic link.
if (lstat(tbuf, &sbuf1)) return 0;
L1: fd = open(tbuf, O_RDONLY); ...
fp = fdopen(fd, "r"); ...
As essential aspect of this attack is that the ﬁle name that
is actually read isn’t within the directory of the user. This
is detected in our approach as a violation of the relation-
ship between the command-line argument, which speciﬁes
the name of the user to be ﬁngered, and the directory of the
ﬁlename opened at L1. (Recall that we resolve symbolic
links in ﬁlenames before using them for learning or detec-
tion.) The attack could potentially be detected by observing
that the resolved ﬁlename is something other than .plan,
but this would raise a false alarm if the user were to use
the symbolic link in a benign way, say, by linking .plan to
another ﬁle named schedule.
Race condition attacks. Race conditions in ﬁle access oc-
cur when applications incorrectly assume that a sequence
of operations on ﬁles is atomic. The prototypical example
is that of a setuid-to-root program using access system call
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:47:23 UTC from IEEE Xplore.  Restrictions apply. 
to check if its real user ruid has access to a ﬁle f, and then
using open(f) to open it. In between the two calls, an at-
tacker (who is typically the real user) can change f, so that
the access call will succeed, but by the time open is exe-
cuted, f points to a ﬁle that isn’t accessible to ruid. Race
condition attacks are among the hardest attacks to detect,
and this has led to the development of detection techniques
speciﬁcally targeting them [28, 16, 20, 29]. It is interesting
to note that without any specialized effort, our approach can
detect them.
To demonstrate the ability of our approach to detect real-
world race attacks, we selected race condition in rm [24]
from GNU ﬁle utilities package. The attack exploits the fact