              android:multiprocess="false"
              android:exported="true" />
正因如此，攻击者就可以轻松借助任何恶意的应用程序来调用以下代码，从而在不请求任何权限的情况下更新用户个人字典中的内容：
    ContentValues values = new ContentValues();
    values.put(UserDictionary.Words.WORD, "IOActive");
    getContentResolver().update(UserDictionary.Words.CONTENT_URI, values,
            null, null);
同样，删除个人字典中的任何内容（甚至是全部个人字典）也非常轻松：
    getContentResolver().delete(UserDictionary.Words.CONTENT_URI, null, null);
理论上，在执行更新和删除这两类方法之后，都应该返回受影响字段的数量。而实际中，如果进行了非法调用，其返回值将始终为0。这样一来，攻击者会难以根据内容提供者的信息来判断其中的内容。  
到目前为止，我们已经知道，攻击者有能力对个人字典进行更新和删除操作。但一些攻击者可能不止局限于此，他们还希望能够访问个人数据。  
尽管查询函数的校验机制不存在上述漏洞，但攻击者仍然可以利用基于时间的侧信道攻击方式，来转储其中的全部内容。由于where参数可以完全被攻击者控制，并且成功执行更新操作的语句与不执行任何操作的同一语句相比用时更长，所以这一攻击过程被证明是有效的。
## 简要概念证明
恶意应用程序可以在本地运行以下代码片段：
    ContentValues values = new ContentValues();
    values.put(UserDictionary.Words._ID, 1);
    long t0 = System.nanoTime();
    for (int i=0; i N  
请注意，我们无法直接检索任何数值或字符串值，因此就需要将这些表达式转换成一组布尔查询，并根据其执行时间将其评估为True或False。这就是二进制搜索算法的工作原理，我们不是直接查询数字，而是去查询它是否大于X。在每次迭代中调整X的值，直到我们在log(n)次查询后找到正确的值。举例来说，如果要检索的当前值是97，那么我们对算法执行跟踪，如下所示：  
## PoC工具
上述过程已经在我们的PoC工具中实现，如下所示。大家可以从我们的GitHub中找到此PoC的源代码和已经编译过的APK：
 。  
接下来，我们来看看该工具的用户界面和特性。  
应用程序所做的第一件事就是尝试直接访问个人字典的内容提供者，并查询条目数。在正常情况下（不以root等身份运行），我们是不应该具有访问权限的。  
如前文所述，只需要调整两个参数：  
初始迭代次数：重复同一次调用的次数；  
最小时间阈值（以毫秒为单位）：将被视为最低可接受值的时间。  
尽管当前版本的工具会自动调整这两个值，但在最开始的阶段，一切都要手动进行。  
从理论上说，这些值越大，我们获得的准确度就越高，但提取速度也会相对慢一些；这些值越小，运行的速度将会越快，但结果可能就不是那么准确。正因如此，我们设置的默认迭代次数为10次，默认最小时间阈值为200毫秒。  
在按下START按钮后，应用程序将开始自动调整参数。首先，它会运行一些查询并丢弃结果。因为最初的查询准确率较低，没有一定的代表性。随后，它将执行初始的迭代次数，并估算相应的阈值。如果获得的阈值高于我们配置的最小值，那么将会连续运行20次查询来测试其准确度，测试过程交替使用真假语句。如果准确度不够高（只允许出现1次错误），那么工具将会增加迭代次数，并重复该过程，直至调整为合理的参数。  
在进程启动后，一些控件将会被禁用，我们能够在下面的日志窗口中看到详细的输出（也可以通过logcat），包括当前行的标识符、所有SQL子查询、总时间和评估的准确性。如果检索到任何字符，会立即出现在上面一行。  
最后，右侧的“UPD”和“DEL”按钮负责实现对内容提供者的直接调用，以执行UPDATE操作和DELETE操作。它们被限制为仅能影响以“123”开头的单词，目的是为了避免意外删除任何个人字典。为了进行测试，我们需要手动添加这一条目。
## 演示
在下面视频中，我们使用了真实设备对这一工具进行了演示：  
## 其他需要考虑的因素
由于理论和实践之间会存在差距，所以我想在这里分享一下我在设计和开发这个PoC过程中所遇到的一些问题。首先，这个工具是一个快速编写而成的PoC，主要目的是证明这一漏洞的确实存在，因此该PoC具有一些限制，并且其中的代码没有遵循良好的编程原则。  
在初始阶段，我并没有关注UI涉及，所有内容都被转储到Android日志中作为输出。当我决定在GUI中显示结果时，我必须在单独的线程中运行所有代码，以避免阻塞UI线程（这可能会导致应用程序被系统认为无响应而被强行结束）。在进行这一个简单的更改之后，其准确性大幅降低，原因在于该线程的优先级不高。因此，我将其设置为“-20”，这是系统允许的最大优先级，在设置完成后一切恢复正常。  
如果从单独的线程更新UI，可能会导致崩溃。因此，为了显示日志消息，我必须使用runOnUiThread调用来对其进行调用。在真正的漏洞利用中，其实根本不需要UI。  
如果个人字典为空，我们就不能强制任何行进行更新，因此所有查询的耗时将非常相似。在这种情况下，由于没有任何内容可以被提取，同时工具也不能调整参数，因此最终工具会停止运行。在一些特殊情况下，我们即使使用空数据库也可以随机进行校准，这时将会尝试提取垃圾数据或伪随机数据。  
在一般的智能手机中，操作系统会在一段时间后进入睡眠模式，而在睡眠模式工具的性能会大幅降低，导致执行时间超过预期值，因此所有调用都会被评估为“True”。针对这一问题，我选择了一个比较简单的解决方案：保持屏幕开启，并通过电源管理器唤醒设备，以防止操作系统暂停应用程序。但我所发布的版本没有加入这一特性，只在这里特别提出。  
同样，旋转屏幕也会造成一些问题，因此我强制该应用程序始终是横屏模式，避免发生自动旋转，同时横屏也有助于尽可能在一行中显示完整的信息。  
在按下“START”按钮后，某些控件将会永久禁用。如果需要重新调整参数或者多次运行，那么需要将其关闭并重新打开。  
并行的一些外部事件和执行（例如：同步电子邮件、接收推送消息）可能会干扰应用程序的行为，从而导致不准确的结果。如果发生了这种情况，需要在不被干扰的状态下再次尝试，例如可以禁用网络，或者关闭所有其他程序。  
UI不支持国际化，该工具没有为提取Unicode中的单词而专门设计。同时，该工具故意设定成只能提取前5个单词并按照其内部标识符排序，以避免被用于非法用途。
## 漏洞修复
从源代码的角度来看，漏洞修复方法非常简单。只需要将负责检查权限的调用移动到受影响函数的开头就可以解决问题。除了提供漏洞信息之外，我们还向Google提供了一个补丁文件，其中包含建议的修复程序：
。  
由于该漏洞已经被官方修复，因此作为最终用户，大家必须确保当前安装的安全补丁中包含CVE-2018-9375的补丁。例如，在Google
Pixel/Nexus中，该补丁是在2018年6月发布的：
。  
如果由于任何原因，用户无法对设备进行更新，那么就应该检查个人字典中的内容，并确保其中不包含任何敏感信息。
## 总结
软件开发是一个复杂的过程，一个微小的错位就会导致漏洞的出现。这一漏洞的成因原本是为了提高个人字典的安全性，使其不易被访问，但却因为一个疏漏获得了截然相反的结果，并且近3年来都没有被注意到。  
要发现这类漏洞，我们需要阅读并理解源代码，只需要遵循执行流程认真阅读。自动化测试可能会有助于在早期阶段发现此类问题，但这一过程通常并不是那么易于实现和维护。  
此外，我们在这个过程中，还学会了如何从一个漏洞中获得最大的效益，这个漏洞原本只允许我们盲目地破坏或篡改数据，但我们利用了侧信道攻击方式，最终获取到了字典中全部的内容。  
作为白帽，应该始终跳出固有的思维模式考虑问题，并且牢记：时间是最宝贵的资源之一，每一纳秒都很重要。