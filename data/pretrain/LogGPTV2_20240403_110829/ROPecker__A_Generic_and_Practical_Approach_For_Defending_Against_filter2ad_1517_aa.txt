title:ROPecker: A Generic and Practical Approach For Defending Against
ROP Attacks
author:Yueqiang Cheng and
Zongwei Zhou and
Miao Yu and
Xuhua Ding and
Robert H. Deng
ROPecker: A Generic and Practical Approach for Defending Against ROP Attacks
Yueqiang Cheng†, Zongwei Zhou§, Miao Yu§, Xuhua Ding†, Robert H. Deng†
† School of Information Systems, Singapore Management University
† {yqcheng.2008, xhding, robertdeng}@smu.edu.sg
§ ECE Department and CyLab, Carnegie Mellon University
§ {stephenzhou, superymk}@cmu.edu
Abstract—Return-Oriented Programming (ROP) is a sophis-
ticated exploitation technique that is able to drive target applica-
tions to perform arbitrary unintended operations by constructing
a gadget chain reusing existing small code sequences (gadgets).
Existing defense mechanisms either only handle speciﬁc types
of gadgets, require access to source code and/or a customized
compiler, break the integrity of application binary, or suffer from
high performance overhead.
In this paper, we present a novel system, ROPecker, to
efﬁciently and effectively defend against ROP attacks without
relying on any other side information (e.g., source code and
compiler support) or binary rewriting. ROPecker detects an ROP
attack at run-time by checking the presence of a sufﬁciently long
chain of gadgets in past and future execution ﬂow, with the
assistance of the taken branches recorded in the Last Branch
Record (LBR) registers and an efﬁcient technique combining
ofﬂine analysis with run-time emulation. We also design a sliding
window mechanism to invoke the detection logic in proper tim-
ings, which achieves both high detection accuracy and efﬁciency.
We build an ROPecker prototype on x86-based Linux computers
and evaluate its security effectiveness, space cost and performance
overhead. In our experiment, ROPecker can detect all ROP
attacks from real-world examples and generated by the general-
purpose ROP compiler Q. It has small footprints on memory and
disk storage, and only incurs acceptable performance overhead
on CPU computation, disk I/O and network I/O.
I.
INTRODUCTION
Return-Oriented Programming (ROP) is a code-reuse secu-
rity exploitation technique introduced by Shacham et al. [12]–
[14]. By chaining together existing small instruction sequences
(gadgets) from target programs, ROP empowers a remote
adversary to perform Turing-complete computation without
injecting any malicious code. Due to its great threat, recent
years have witnessed many proposed methods (Table I) to
defend against ROP attacks [1]–[9], [11], [15].
The approaches, such as DROP [1], ROPDefender [2],
ROPGuard [3] and Return-less kernel [4], only focus on the
ROP gadgets ended with return instructions (e.g., ret-based),
allowing the adversary to use other gadgets (e.g., jmp-based).
In addition, the ﬁrst two schemes [1], [2] also incur high
overhead to their protected applications. Defense mechanisms,
Permission(cid:1) to(cid:1) freely(cid:1) reproduce(cid:1) all(cid:1) or(cid:1) part(cid:1) of(cid:1) this(cid:1) paper(cid:1) for(cid:1) noncommercial(cid:1)
purposes(cid:1)is(cid:1)granted(cid:1)provided(cid:1)that(cid:1)copies(cid:1)bear(cid:1)this(cid:1)notice(cid:1)and(cid:1)the(cid:1)full(cid:1)citation(cid:1)
on(cid:1)the(cid:1)ﬁrst(cid:1)page.(cid:1) Reproduction(cid:1)for(cid:1)commercial(cid:1)purposes(cid:1)is(cid:1)strictly(cid:1)prohibited(cid:1)
without(cid:1)the(cid:1)prior(cid:1)written(cid:1)consent(cid:1)of(cid:1)the(cid:1)Internet(cid:1)Society,(cid:1)the(cid:1)ﬁrst-named(cid:1)author(cid:1)
(for(cid:1) reproduction(cid:1) of(cid:1) an(cid:1) entire(cid:1) paper(cid:1) only),(cid:1) and(cid:1) the(cid:1) author’s(cid:1) employer(cid:1) if(cid:1) the(cid:1)
paper(cid:1)was(cid:1)prepared(cid:1)within(cid:1)the(cid:1)scope(cid:1)of(cid:1)employment.
NDSS(cid:1)’14,(cid:1)23-26(cid:1)February(cid:1)2014,(cid:1)San(cid:1)Diego,(cid:1)CA,(cid:1)USA
Copyright(cid:1)2014(cid:1)Internet(cid:1)Society,(cid:1)ISBN(cid:1)1-891562-35-5
http://dx.doi.org/(cid:18)(cid:17)(cid:15)(cid:18)(cid:21)(cid:24)(cid:19)(cid:19)(cid:16)(cid:79)(cid:69)(cid:84)(cid:84)(cid:15)(cid:19)(cid:17)(cid:18)(cid:21)(cid:15)(cid:19)(cid:20)(cid:18)(cid:22)(cid:23)
such as CFLocking [5] and G-Free [6], aim to defend against
all types of ROP attacks, but they require the knowledge of
side information (e.g., source code and/or customized compiler
tool chain). In fact, this side information is often unavailable
to the end users in the real world.
Recent proposals, such as ILR [7], Binary stirring [8],
IPR [9], CCFIR [10] and KBouncer [11], cover all ROP
attack types, achieves good attack-type coverage and run-
time efﬁciency, and requires no side information. However,
they all leverage binary rewriting technique to instrument the
code, in the purposes of randomly shufﬂing instructions, en-
forcing control ﬂow integrity, or monitoring abnormal control
transfers. Binary instrumentation breaks the integrity of the
binary code, which raises compatibility issues against security
mechanisms, such as Window 7 system library protection,
Integrity Measurement Architecture (IMA) [16], and remote
attestation. In addition, KBouncer [11] only monitors the
application execution ﬂow on selected critical paths, e.g.,
system APIs. It inevitably misses the ROP attacks that do not
use those paths.
This paper presents the ﬁrst generic and practical ROP
countermeasure, called ROPecker, that effectively and efﬁcient-
ly defends against all types of ROP attacks without requiring
source code access, customized compiler support and binary
rewriting, as summarized in Table I. We observe that the dis-
tinguishing feature of an ROP attack is that the execution ﬂow
of a victim application consists of a sufﬁciently long sequence
of gadgets chained together by branching instructions. Thus,
ROPecker analyzes all gadgets located in the target application
binary and shared libraries via ofﬂine pre-processing. During
run-time check points, ROPecker identiﬁes the gadget chain
in the past execution ﬂow, using the history of taken branches
recorded in the Last Branch Record (LBR) registers, and also
inspects the future execution ﬂow to detect any ROP gadget
chain, leveraging the information from ofﬂine analysis and
occasional instruction emulation.
We also propose a novel sliding window mechanism to
decide run-time check points, which sets the most recent
visited code regions of the protected application as executable,
and leaves the application code outside of the window as
non-executable. Any attempt to execute the code beyond the
window boundary automatically triggers the ROP checking
logic, while the application execution within the window re-
mains unaffected. The sliding window design takes advantage
of the temporal and spatial locality of application code and
the sparsely distribution of meaningful gadgets across the
application code base, to achieve both run-time efﬁciency and
detection accuracy.
TABLE I.
THE COMPARISON OF SEVERAL TYPICAL ROP DEFENDING APPROACHES.
Run-time
Efﬁciency
ROP Types No Source No Binary
Rewriting
Ret-based
Ret-based
Ret-based
Ret-based
DROP [1]
ROPDefender [2]
ROPGuard [3]
Return-less Kernel [4]
CFLocking [5]
G-Free [6]
ILR [7]
Binary Stirring [8]
IPR [9]
CCFIR [10]
KBouncer [11]
ROPecker
All
All
All
All
All
All
All
All
Code
p
p
p
X
X
X
p
p
p
p
p
p
X
X
X
p
p
p
X
X
X
X
X
p
X
X
p
p
p
p
p
p
p
p
p
p
We build an ROPecker prototype on x86-based Linux plat-
form, though our design can be extended to other commodity
operating systems. We experiment ROPecker with real world
ROP attacks and those generated by the ROP compiler Q [17].
The results demonstrate that ROPecker successfully detects all
of them. We also evaluate the space cost of ROPecker on the
Ubuntu Linux 12.04 distribution. The experiment results show
that the database for all 2393 shared libraries under under
/lib and /usr/lib is surprising small, which can be compressed
to about 19M B using bzip2. Moreover, We evaluate the
performance by running several macro-benchmark (e.g., SPEC
INT2006, bonnie++, and Apache server httpd) and micro-
benchmark tools. The results show that ROPecker introduces
reasonable performance overhead on CPU computation, disk
I/O, and network I/O. Speciﬁcally, ROPecker incurs only
2.60% overhead on average on CPU computation, 1.56%
overhead on disk I/O, and 0.08% overhead on typical (4KB)
HTTP communications.
Contributions.
tions:
•
In speciﬁc, we make the following contribu-
Design the ﬁrst generic and practical ROP counter-
measure to protect legacy applications from all types
of ROP attacks without side information and binary
rewriting.
Propose novel techniques combining sliding window,
ofﬂine gadget analysis with run-time instruction emu-
lation to achieve high efﬁciency without compromis-
ing detection accuracy.
Implement an ROPecker prototype on x86-based Lin-
ux platform and evaluate its security effectiveness,
space cost and run-time performance.
•
•
Organization. The rest of the paper is structured as fol-
lows. In Section II and Section III, we brieﬂy describe the
background knowledge, and highlight our system goals, threat
model and assumptions. We introduce in detail the design
rationale, system architecture and implementation of ROPecker
in Sections IV, V, and VI, respectively. Section VII discusses
the parameter effects on the performance and accuracy, and
Section VIII presents the security, space and performance
evaluation of ROPecker. In Sections IX and Section X, we
discuss several subtle attacks and compare our system with
the existing work. At last, we conclude this paper and discus
2
the future work in Section XI.
II. BACKGROUND
A. Return-Oriented Programming
The main idea of ROP attack is to reuse instructions from
existing code space to perform malicious operations. There
are two major steps to launch an ROP attack: (1) to identify
a set of useful instruction sequences, called gadgets, from the
entire code segment, e.g., the application code and the shared
libraries; (2) to link the selected gadgets into a gadget chain
through a crafted payload. Note that the gadgets are not limited
to using aligned instructions, e.g., on x86 platform, a sequence
of unaligned instructions may also be converted to a valid
gadget.
A typical gadget has a code section for computation
operations (e.g., assigning a value to a general CPU register),
and a link section manipulating the control ﬂow to link
gadgets. The control ﬂow manipulation is achieved through the
indirect branch instructions such as ret and indirect jmp/call
instructions1. According to the difference of the link section,
ROP attacks are classiﬁed into ret-based ROP and jmp-based
ROP or JOP. In a real-life ROP attack, the adversary may
mix both types of gadgets. The gadgets used in ROP attacks
typically have the following features.
Small Size. A gadget’s code section is usually small, e.g.,
consisting of 2 to 5 instructions [18], which leads to the lack
of the functionality of a single gadget. Though the gadgets
with large code sections can perform more operations, they
inevitably lead to more side effects and some of them may
conﬂict with each other, e.g., a gadget accidentally changes the
stack pointer, which may lead to the failure of the execution
of the next gadget. In fact, the adversary usually prefers to
collect the gadgets only with the intended operations, instead
of using long gadgets2. Thus, a real ROP attack usually needs
many such small gadgets, e.g., as illustrated in [14], a jump-
oriented Turing-complete JOP needs up to 34 small gadgets.
1Traditionally, the direct branch instructions can not be used as the link
section, since their destinations are ﬁxed. However, we identify the gadget
gluing attack (Section IX-B) that may leverage direct branches to foil our
detection. For completeness, we discuss the extension of ROPecker to mitigate
such attacks in Section IX-B.
2Our mechanism can be tuned to detect gadgets of different length, as
discussed in Section VII-B
Sparse Distribution. Although the gadgets are distributed
across the entire code space, the ones meeting for the ad-
versary’s needs are not guaranteed to exist due to the sparse
density. To have higher success probability, the adversaries
usually need a large code base to collect enough gadgets to
perform the malicious operations. The experiment results of
Q [17] imply that the adversaries has low possibility to launch
a meaningful ROP attack, if we can limit the size of the
executable code within 20KB at any time. If we can further
reduce the size, the possibility will consequently go down.
B. Last Branch Record
In our solution, we leverage Last Branch Record (LBR)
registers to provide reliable information about the execution
trace of the protected application. LBR are dedicated CPU
registers widely available on modern Intel and AMD proces-
sors. LBR provides a looped buffer to store the sources and
destinations of the most recently executed branch instructions.
The length of the buffer is limited, e.g., the Intel i5 only has
16 register pairs for recording the branches. It leads to that the
new records inevitably override the old ones when the LBR
buffer gets full.
The LBR functionality is disabled by default, and can only
be enabled/disabled through certain Model Speciﬁc Registers
(MSRs). Without the kernel privilege (i.e., ring-0), the user
space applications cannot modify the value in the LBR MSRs.
The LBR can be conﬁgured to only record the branches taken
in user space. However, when recording user-space branches,
the LBR does not distinguish branches in different processes.
Thus, we have to ﬁlter out the unavoidable noise records
to get the ones relevant to a speciﬁc process. Note that the
branch recording is performed by the hardware processor and
it introduces almost zero overhead for application executions.
III. PROBLEM DEFINITION
A. System Goals
Our goal is to design a security system to detect and prevent
ROP attacks at run-time with the following features.
G1: Generic. We aim to protect binary applications against
all types of user space ROP attacks. The ROP gadget chain
can be constructed by ret-based gadgets, jmp-based gadgets,
or both of them.
G2: Transparent. Our system should transparently work for
the legacy binary applications. In addition, 1) it does not rely
on source code or customized compiler tools; 2) it does not
instrument the binary code.
G3: Efﬁcient. We aim to minimize the performance overhead.
Our system should not incur high performance overhead to
protected applications, as well as the OS and other applications
that coexist on the same platform.
B. Threat Model
In this paper, we focus on defending against application-
level ROP attacks. We consider a remote adversary attacking
a target application by manipulating inputs in order to launch
an ROP attack. We suppose that
the adversary knows all
implementation details of the target application and can send
arbitrary inputs. Nonetheless,
the target
platform’s hardware (e.g., MMU) and the operating system
services (e.g., page table permissions) to their favor.
it cannot subvert
C. Assumptions
We assume that both the processor and the operating
system enable the Data Execution Prevention (DEP) mech-
anism. In fact, the DEP mechanism is supported by default in
modern operating systems. We do not assume that the Address