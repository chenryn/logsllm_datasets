Total (sde):
Reads Queued: 19, 76KiB Writes Queued: 142,183, 568,732KiB
Read Dispatches: 19, 76KiB Write Dispatches: 25,440, 568,732KiB
Reads Requeued: 0 Writes Requeued: 125
Reads Completed: 19, 76KiB Writes Completed: 25,315, 568,732KiB
Read Merges: 0, 0KiB Write Merges: 116,868, 467,472KiB
IO unplugs: 20,087 Timer unplugs: 0
概述显示平均 I/O 速度、合并活动，并对比读负载和写负载。但 blkparse 输出结果因太过繁琐而变得没有
意义。还好有一些工具可以帮助您解析这些数据：
btt 提供对 I/O 在 I/O 栈中不同区域所花费时间的分析。这些区域为：
Q — 将块 I/O 排队
G — 获得请求
新排队的块不能作为与现有请求合并的人选，因此会分配一个新的块层请求。
M — 将 I/O is 与现有请求合并。
I — 在设备队列中插入一个请求。
D — 已向设备发出一个请求。
C — 驱动程序已完成请求。
P — 已插上块设备队列以便允许整合请求。
U — 已撤销设备队列，允许向该设备发出整合的请求。
btt 将消耗在每个区域以及在各个区域间转换的时间分段，比如：
Q2Q — 将请求发送到块层的时间
Q2G — 从将块 I/O 排队到为其分配一个请求之间所需要的时间
G2I — 从为其分配一个请求到将其插入设备队列之间所需时间
Q2M — 将块 I/O 排队到将其与现有请求合并之间所需时间
I2D — 从将请求插入设备队列到实际向该设备发出请求之间所需时间
M2D — 从将块 I/O 与现有请求合并到向该设备发出该请求之间所需时间
46
第 6 章 输入/输出
M2D — 从将块 I/O 与现有请求合并到向该设备发出该请求之间所需时间
D2C — 该设备请求的服务时间
Q2C — 为一个请求消耗在块层中的时间总量
您可以从上述表格中推断处大量有关负载的信息。例如：如果 Q2Q 比 Q2C 大很多，则意味着程序没有以快
速连续法式发出请求。因此您的性能问题可能与 I/O 子系统无关。如果 D2C 很高，那么该设备服务请求的时
间就很长。这可能表示该设备只是超载了（可能是由共享资源造成的），或者是因为发送给给设备的负载未
经优化。如果 Q2G 很高则意味着队列中同时有大量请求。这可能代表该存储无法承担 I/O 负载。
最后，seekwatcher 消耗 blktrace 二进制数据并生成一组绘图，其中包括逻辑块地址（LBA），流量，每
秒查找次数以及每秒的 I/O 量（IOPS）。
图图 6.2. seekwatcher 输输出出结结果果示示例例
47
红帽企业版 Linux 6 性能调节指南
所有绘图都使用时间作为 X 轴。LBA 图用不同的颜色显示读操作和写操作。关注吞吐量与每秒查询次数图很
有意思。对查询敏感的存储这两个图形是反的。如果您没有从设备中获得预期的流量，但已达到 IOPS 极
限，则需要查看 IOPS 图。
6.4. 配配置置
首先要决定使用那个 I/O 调度程序。本小节提供主要调度程序概述以帮助您确定最适合您的负载的那一款。
6.4.1. 完完全全公公平平调调度度（（CFQ））
CFQ 尝试根据启动 I/O 的进程决定公平的 I/O 调度。可提供三个不同的调度等级：实时（RT），最佳效果
（BE）和闲置。可使用 ionice 命令手动分配调度等级，或者使用 ioprio_set 系统调用编程分配。默
认情况下将进程设定为最佳效果调度等级。在实时调度等级和最佳效果调度等级中有分为八个 I/O 优先级，
其中 0 代表最高优先权，7 代表最低优先权。采用实时调度等级的进程比采用最佳效果和闲置等级的进程会
被更频繁地调度，因此所有调度的实时 I/O 都要在最佳效果或者闲置 I/O 前执行。这意味着实时优先权 I/O
可耗尽最佳效果和闲置等级。最佳效果调度是默认调度等级，且给等级中的默认优先权为 4。停滞调度等级
中的进程只有在系统中没有其他等待处理的 I/O 时才会执行。因此请记住只有在进程 I/O 完全不需要向前进
行时方可将进程调度等级设定为闲置。
CFQ 通过为每个执行 I/O 的进程分配时间片段提供公平。在其时间片段中，进程每次最多可有八个请求（默
认）。调度程序会尝试根据历史数据估计某个程序是否会在近期发出更多 I/O，然后 CFQ 会闲置，等待那个
I/O，即使有其他进程正在等待发出 I/O。
由于 CFQ 执行的闲置操作通常并不适合哪些不会受大量查询惩罚（seek penalty）影响的硬件，比如快速外
置存储阵列或者固态硬盘。如果要求在此类存储中使用 CFQ（例如：如果您还喜欢使用 cgroup 加权 I/O 调
度程序），则需要调节一些设置以改进 CFQ 性能。请在 /sys/block/device/queue/iosched/ 中同一
名称的文件中设定以下参数：
slice_idle = 0
quantum = 64
group_idle = 1
将 group_idle 设定为 1 后，可能会产生 I/O 停止（而由于闲置后端存储并不繁忙）。但这些停止的情况并
不比系统队列中的闲置情况出现得频繁。
CFQ 是非工作守恒（non-working-conserving）I/O 调度程序，就是说即使在有等待处理的请求时也可以闲
置（如前所述）。非工作守恒调度程序栈可在 I/O 路径中产生很大延迟。此类栈的示例为在基于主机的硬件
RAID 控制器顶层使用 CFQ。该 RAID 可部署其自身的非工作守恒调度程序，因此可在该栈的两级中造成延
迟。非工作负载调度程序可在有尽可能多的数据供其做决定时操作最佳。在使用该调度算法的栈中，最底层
的此奥读程序只能看到上层调度程序发送的数据。因此底层看到的 I/O 模式并不完全代表实际负载。
可可调调参参数数
back_seek_max
反向查询通常对性能有负面影响，因为它比正向查询标头重置时间要长很多。但如果负载较小，则
CFQ 仍执行此查询。这个可调参数以 KB 为单位控制 I/O 调度程序允许反向查询的间距。默认为
16 KB。
back_seek_penalty
由于反向查询的效率低，每项反向查询都有惩罚与之关联。惩罚是一个乘数。例如：视磁头位置在
1024KB。假设在队列中有两个请求，一个在 1008KB，一个在 1040KB。这两个请求到当前磁头
48
第 6 章 输入/输出
位置登距。但如果应用反向查询惩罚（默认：2），则磁盘中距离较远的请求现在与较近的请求的
距离缩短了一倍。因此磁头将向前移动。
fifo_expire_async
这个可调参数控制异步（缓存写入）请求等待的时间长度。过期后（以毫秒计）会将无法满足的异
步请求移动到调度表中。默认为 250 毫秒。
fifo_expire_sync
这个参数与 fifo_expire_async 相同，用于同步请求（读取和 O_DIRECT 写入）。默认为 125 毫
秒。
group_idle
设定后，CFQ 会在最后一个进程 cgroup 中发出 I/O 后闲置。当使用加权 I/O cgroup 并将
slice_idle 设定为 0 后将其设定为 1（通常用于快速存储）。
group_isolation
如果启用组隔离（设定为 1），它可以吞吐量为代价提供组群间更强大的隔离。一般来说，如果禁
用组隔离，则只为连续负载提供公平机制。启用组隔离则会为连续以及随机负载提供公平机制。默
认值为 0（禁用）。详情请参考 Documentation/cgroups/blkio-controller.txt。
low_latency
启用低延迟后（设定为 1），CFQ 会尝试为设备中每个发出 I/O 的进程提供最长 300 ms 的等待时
间。禁用低延迟（设定为 0）可忽略目标延迟，这样就可允许系统中的每个进程获得全部时间片
段。默认启用低延迟。
quantum
quantum 参数控制 CFQ 每次向该存储发出的 I/O 数，主要是限制设备队列深度。默认情况下将其
设定为 8。该存储可能支持更深的队列深度，但增加 quantum 还将对延迟产生负面影响，特别是
有大量连续写操作的时候。
slice_async
这个可调参数控制分配给每个发出异步（缓存写入）I/O 的进程的时间片段。默认将其设定为 40
毫秒。
slice_idle
这个参数指定 CFQ 在等待进一步请求时应闲置的时间。红帽企业版 Linux 6.1 以及更早版本中的默
认值为 8 毫秒。在红帽企业版 Linux 6.2 以及之后的版本中默认值为 0。这个 0 值可通过删除队列
以及服务树层中的所有闲置提高外置 RAID 存储流量。但 0 值可降低内置非 RAID 存储的流量，因
为它会增加查询总量。对于非 RAID 存储建议您将 slice_idle 值设定在 0 以上。
slice_sync
这个可调参数专门用于发出同步（读取或者直接写入）I/O 进程的时间片段。默认值为 100 毫秒。
49
红帽企业版 Linux 6 性能调节指南
6.4.2. 最最后后期期限限 I/O 调调度度程程序序
最后期限 I/O 调度程序尝试为请求提供保证的延迟。请注意只有当请求进入 I/O 调度程序后方开始计算延迟
（这个区别非常重要，因为可能会让程序进入睡眠等待模式以便释放请求描述符）。默认情况下读取比写入
的优先权高，因为程序更容易因读取 I/O 而被阻断。
最后期限调度以批形式分派 I/O。一批是一些列连续的读或者写 I/O，按 LBA 顺序递增（单向递增）。处理
完每批进程后，I/O 调度程序会检查是否有写请求已等待太久，然后决定是否开始新一批读或者写操作。只
在开始新一批时检查过期请求的请求 FIFO 列表。因此，如果选择批写入，且同时有过期的读取请求，那么
只有在批写入完成后方可执行读取请求。
可可调调参参数数
fifo_batch
这样可以决定单一批次中发出的读取或者写入数。默认为 16。设为更高的数值可获得更好的流
量，但也会增加延迟。
front_merges
如果您找到负载永远不会生成前合并，则您可以将这个可调参数设定为 0。除非您已了解这个检查
的代价，建议将其设定为默认值，即 1。
read_expire
这个可调参数可让您已毫秒为单位设定读取操作速度。默认将其设定为 500 毫秒（即半秒）。
write_expire
这个可调参数可让您已毫秒为单位设定写入操作速度。默认将其设定为 5000 毫秒（即五秒）。
writes_starved
这个可调参数控制处理单一写入批之前可以处理多少读取批。这个值越高，越倾向于读取操作。
6.4.3. Noop
Noop I/O 调度程序采用先入先出（FIFO）调度算法。合并原始块层中的请求，但只是一个最后命中缓存
（last-hit cache）。如果系统与 CPU 捆绑，且使用高速存储，这就是可以使用的最佳 I/O 调度程序。
以下是块层中可以使用的可调参数。