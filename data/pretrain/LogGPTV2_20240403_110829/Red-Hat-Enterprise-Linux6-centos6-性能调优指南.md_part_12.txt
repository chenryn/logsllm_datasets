### I/O性能概述与分析

#### 概述
总览（sde）:
- 读队列: 19, 76KiB
- 写队列: 142,183, 568,732KiB
- 读派发: 19, 76KiB
- 写派发: 25,440, 568,732KiB
- 读重排队: 0
- 写重排队: 125
- 读完成: 19, 76KiB
- 写完成: 25,315, 568,732KiB
- 读合并: 0, 0KiB
- 写合并: 116,868, 467,472KiB
- I/O拔出: 20,087
- 定时器拔出: 0

此概览显示了平均I/O速度、合并活动，并对比了读负载和写负载。然而，blkparse输出结果因过于繁琐而难以理解。幸运的是，有一些工具可以帮助解析这些数据。

#### 工具：btt
**btt** 提供对I/O在不同区域所花费时间的详细分析。这些区域包括：
- **Q**: 将块I/O排队
- **G**: 获得请求
- **M**: 将I/O与现有请求合并
- **I**: 在设备队列中插入一个请求
- **D**: 向设备发出一个请求
- **C**: 驱动程序已完成请求
- **P**: 插上块设备队列以允许整合请求
- **U**: 撤销设备队列，允许向该设备发出整合的请求

btt将消耗在每个区域以及在各个区域间转换的时间分段，例如：
- **Q2Q**: 将请求发送到块层的时间
- **Q2G**: 从将块I/O排队到为其分配一个请求之间所需的时间
- **G2I**: 从为其分配一个请求到将其插入设备队列之间所需时间
- **Q2M**: 将块I/O排队到将其与现有请求合并之间所需时间
- **I2D**: 从将请求插入设备队列到实际向该设备发出请求之间所需时间
- **M2D**: 从将块I/O与现有请求合并到向该设备发出该请求之间所需时间
- **D2C**: 设备请求的服务时间
- **Q2C**: 为一个请求消耗在块层中的时间总量

通过上述表格，您可以推断出大量有关负载的信息。例如：
- 如果 **Q2Q** 比 **Q2C** 大很多，则意味着程序没有快速连续地发出请求，性能问题可能与I/O子系统无关。
- 如果 **D2C** 很高，则表示设备服务请求的时间很长，可能是因为设备超载或负载未优化。
- 如果 **Q2G** 很高，则意味着队列中有大量请求同时存在，这可能表明存储无法承受I/O负载。

#### 工具：seekwatcher
**seekwatcher** 可以处理blktrace二进制数据并生成一系列图表，包括逻辑块地址（LBA）、流量、每秒查找次数以及每秒I/O量（IOPS）。所有图表都使用时间为X轴。LBA图用不同颜色显示读操作和写操作。吞吐量与每秒查询次数图非常有用。对于查询敏感的存储，这两个图形是相反的。如果您没有从设备中获得预期的流量，但已达到IOPS极限，则需要查看IOPS图。

### 配置
首先，您需要决定使用哪个I/O调度程序。本节提供主要调度程序的概述，以帮助您确定最适合您的负载的那个。

#### 完全公平调度（CFQ）
CFQ尝试根据启动I/O的进程来决定公平的I/O调度。提供了三个不同的调度等级：实时（RT）、最佳效果（BE）和闲置。可以使用`ionice`命令手动分配调度等级，或者使用`ioprio_set`系统调用编程分配。默认情况下，进程被设定为最佳效果调度等级。在实时调度等级和最佳效果调度等级中，分为八个I/O优先级，其中0代表最高优先权，7代表最低优先权。采用实时调度等级的进程比采用最佳效果和闲置等级的进程会被更频繁地调度，因此所有调度的实时I/O都要在最佳效果或者闲置I/O前执行。这意味着实时优先权I/O可耗尽最佳效果和闲置等级。最佳效果调度是默认调度等级，且该等级中的默认优先权为4。停滞调度等级中的进程只有在系统中没有其他等待处理的I/O时才会执行。

CFQ通过为每个执行I/O的进程分配时间片段来提供公平性。在其时间片段中，进程每次最多可有八个请求（默认）。调度程序会尝试根据历史数据估计某个程序是否会在近期发出更多I/O，然后CFQ会闲置，等待那个I/O，即使有其他进程正在等待发出I/O。

由于CFQ执行的闲置操作通常不适合那些不受大量查询惩罚影响的硬件（如快速外置存储阵列或固态硬盘），如果要求在此类存储中使用CFQ（例如，如果您还喜欢使用cgroup加权I/O调度程序），则需要调节一些设置以改进CFQ性能。请在`/sys/block/device/queue/iosched/`中设定以下参数：

- `slice_idle = 0`
- `quantum = 64`
- `group_idle = 1`

将`group_idle`设定为1后，可能会产生I/O停止（因为闲置后端存储并不繁忙）。但这些停止的情况并不比系统队列中的闲置情况出现得频繁。

CFQ是非工作守恒（non-working-conserving）I/O调度程序，即即使在有等待处理的请求时也可以闲置。非工作守恒调度程序栈可在I/O路径中产生很大延迟。此类栈的示例是在基于主机的硬件RAID控制器顶层使用CFQ。该RAID可部署其自身的非工作守恒调度程序，因此可在该栈的两级中造成延迟。非工作负载调度程序在有尽可能多的数据供其做决定时操作最佳。在使用该调度算法的栈中，最底层的调度程序只能看到上层调度程序发送的数据。因此，底层看到的I/O模式并不完全代表实际负载。

#### 可调参数
- **back_seek_max**
  - 反向查询通常对性能有负面影响，因为它比正向查询标头重置时间要长很多。但如果负载较小，CFQ仍执行此查询。这个可调参数以KB为单位控制I/O调度程序允许反向查询的间距。默认为16 KB。

- **back_seek_penalty**
  - 由于反向查询的效率低，每项反向查询都有惩罚与之关联。惩罚是一个乘数。例如：视磁头位置在1024KB。假设在队列中有两个请求，一个在1008KB，一个在1040KB。这两个请求到当前磁头位置的距离。但如果应用反向查询惩罚（默认：2），则磁盘中距离较远的请求现在与较近的请求的距离缩短了一倍。因此磁头将向前移动。

- **fifo_expire_async**
  - 这个可调参数控制异步（缓存写入）请求等待的时间长度。过期后（以毫秒计）会将无法满足的异步请求移动到调度表中。默认为250毫秒。

- **fifo_expire_sync**
  - 这个参数与`fifo_expire_async`相同，用于同步请求（读取和O_DIRECT写入）。默认为125毫秒。

- **group_idle**
  - 设定后，CFQ会在最后一个进程cgroup中发出I/O后闲置。当使用加权I/O cgroup并将`slice_idle`设定为0后将其设定为1（通常用于快速存储）。

- **group_isolation**
  - 如果启用组隔离（设定为1），它可以以吞吐量为代价提供组群间更强大的隔离。一般来说，如果禁用组隔离，则只为连续负载提供公平机制。启用组隔离则会为连续以及随机负载提供公平机制。默认值为0（禁用）。详情请参考`Documentation/cgroups/blkio-controller.txt`。

- **low_latency**
  - 启用低延迟后（设定为1），CFQ会尝试为设备中每个发出I/O的进程提供最长300 ms的等待时间。禁用低延迟（设定为0）可忽略目标延迟，这样就可允许系统中的每个进程获得全部时间段。默认启用低延迟。

- **quantum**
  - `quantum`参数控制CFQ每次向该存储发出的I/O数，主要是限制设备队列深度。默认情况下将其设定为8。该存储可能支持更深的队列深度，但增加`quantum`还将对延迟产生负面影响，特别是有大量连续写操作的时候。

- **slice_async**
  - 这个可调参数控制分配给每个发出异步（缓存写入）I/O的进程的时间片段。默认将其设定为40毫秒。

- **slice_idle**
  - 这个参数指定CFQ在等待进一步请求时应闲置的时间。红帽企业版Linux 6.1及更早版本中的默认值为8毫秒。在红帽企业版Linux 6.2及之后的版本中，默认值为0。这个0值可通过删除队列和服务树层中的所有闲置提高外置RAID存储流量。但0值可降低内置非RAID存储的流量，因为它会增加查询总量。对于非RAID存储，建议您将`slice_idle`值设定在0以上。

- **slice_sync**
  - 这个可调参数专门用于发出同步（读取或直接写入）I/O进程的时间片段。默认值为100毫秒。

#### 最后期限I/O调度程序
最后期限I/O调度程序尝试为请求提供保证的延迟。请注意，只有当请求进入I/O调度程序后才开始计算延迟（这个区别非常重要，因为可能会让程序进入睡眠等待模式以便释放请求描述符）。默认情况下，读取比写入的优先权高，因为程序更容易因读取I/O而被阻断。

最后期限调度以批形式分派I/O。一批是一系列连续的读或写I/O，按LBA顺序递增（单向递增）。处理完每批进程后，I/O调度程序会检查是否有写请求已等待太久，然后决定是否开始新一批读或写操作。只在开始新一批时检查过期请求的请求FIFO列表。因此，如果选择批写入，且同时有过期的读取请求，那么只有在批写入完成后方可执行读取请求。

#### 可调参数
- **fifo_batch**
  - 这样可以决定单一批次中发出的读取或写入数。默认为16。设为更高的数值可获得更好的流量，但也会增加延迟。

- **front_merges**
  - 如果您发现负载永远不会生成前合并，则可以将这个可调参数设定为0。除非您已了解这个检查的代价，建议将其设定为默认值，即1。

- **read_expire**
  - 这个可调参数可让您以毫秒为单位设定读取操作速度。默认将其设定为500毫秒（即半秒）。

- **write_expire**
  - 这个可调参数可让您以毫秒为单位设定写入操作速度。默认将其设定为5000毫秒（即五秒）。

- **writes_starved**
  - 这个可调参数控制处理单一写入批之前可以处理多少读取批。这个值越高，越倾向于读取操作。

#### Noop I/O调度程序
Noop I/O调度程序采用先入先出（FIFO）调度算法。合并原始块层中的请求，但只是一个最后命中缓存（last-hit cache）。如果系统与CPU捆绑，且使用高速存储，这就是可以使用的最佳I/O调度程序。

以下是块层中可以使用的可调参数。