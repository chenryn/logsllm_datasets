Keyed hash-based MAC function with a key k
on m
Authenticated encryption on m with a key k
Entity ei’s (secret key, public key) pair
Entity ei’s certiﬁcate
Identity of ei. IDi = H(pki)
Generator of a DH group
Ephemeral DH key pair
Security parameters that includes the negotiated
version, the negotiated ciphersuite, the hashed
master secret, and the transcript between ei and
ej
Accountability key of ei established with ej
(We simply write aki when j is ﬁxed in the
context)
The result of Hmac(k, m) by ei
Modiﬁcation log generated by ei
TABLE II: Notation used in this paper
policy. For example, the client might abort the connection if
any of the segments is established with a weak algorithm such
as an RC4 [36].
(3) Valid Modiﬁcation Check allows a client to audit which
entity has modiﬁed the message. When an entity forwards a
message to the next entity it also generates a cryptographic
proof, called a modiﬁcation log (ML). Basically,
is to
compare the incoming and outgoing message from the entity
by attaching (1) a HMAC generated from both received and
sending message using its accountability keys (aki), (2) a
digest of the received message (H(mi+1)), and its identiﬁer
(IDi). Assuming that the message is coming from the server
(en) to the client (e0), we can deﬁne the ML generated from
the ei, which is denoted as M Li:
IDi||H(mi+1)||Hmac(aki,0, H(mi)||H(mi+1))||M Li+1
it
Here, we can apply some optimization techniques to reduce
the size of the MLs in speciﬁc scenarios. First, the server does
not have a prior message, thus the M Ln can be deﬁned as
IDn||Hmac(akn,0, H(mn)). Second, when an entity (ei) does
not modify any message (i.e., read-only middlebox), we can
further reduce the size of the M Li by (1) simply generating a
HM ACi from the previous HM ACi+1 and (2) omitting its
received digest (H(mi+1)) and even its ID (IDi). Thus, if the
client detects a omitted ID while parsing the received ML, it
can assume that the message has not been modiﬁed among the
middleboxes with the omitted IDs. For example, if an entity
(ei) receives a message that has never been modiﬁed, the ML
8
that the entity received will be
IDn||Hmac(aki+1,0, Hmac(aki+2,0,··· ,
Hmac(akn,0, H(mn)))
Once ei modiﬁes the message, however, the ML produced
from ei will be
IDi||H(mi+1)||Hmac(aki,0, H(mi)||H(mi+1))
||IDn||HM ACi+1
which implies that the message between the middlebox
ei+1 and en has never been modiﬁed.
Once the receiver (i.e., the client in this example) obtains
the series of MLs, it can extract the digests of all the modiﬁed
messages, track the identiﬁers of the middleboxes that per-
formed the write operation, and ﬁnally verify each ML using
its HMAC.
C. maTLS Handshake Protocol
A client performs an maTLS handshake to negotiate ac-
countability keys, to authenticate the server and middleboxes,
and to perform security parameter veriﬁcation. The maTLS
handshake protocol, which extends TLS 1.2,
is shown in
Figure 3a. In the ﬁrst round-trip,
the client expresses its
preference to perform the maTLS protocol by adding the
M iddlebox_Aware extension to the ClientHello mes-
sage. The client generates its DH key pair (say, (a, ga)) and
inserts the DH public key (ga) into the extension. Then, the
client sends the ClientHello message with the highest
possible TLS version and a set of supporting ciphersuites.
On receiving the ClientHello, each middlebox ﬁnds the
client’s maTLS extension, generates its own DH key pair, and
extracts the list of DH public keys from the maTLS extension.
After that, it appends its own DH public key, and sends the new
ClientHello with the DH public keys toward the client’s
intended server. This process is repeated at every middlebox
on the way to the server.
The server generates its own DH key pair (say, (b, gb))
and sends the ServerHello message with the DH pub-
lic key (gb) and the selected TLS version and ciphersuite
for the maTLS segment. On receiving ServerHello, each
middlebox processes the message as the middlebox do on
ClientHello and determines the TLS version and the
ciphersuite to be used in the maTLS segment.
Then, each entity negotiates the TLS version and the
ciphersuite with its neighbor entity for each maTLS segment.
Furthermore, both endpoints receive the DH public keys from
all entities and each middlebox has two DH public keys (i.e.
the client’s and the server’s). With their own DH private keys,
all entities generate the accountability keys by using the PRF
function deﬁned in [9] with the server’s DH public key and
the client’s DH public key as seeds. For a label, one of
the input parameters of the PRF function, we use the string,
“accountability key.”
The ServerCertificate message is sent after the
Hello messages. The server sends its own certiﬁcate and
each middlebox appends its middlebox certiﬁcate. The client
(a) The maTLS-DHE handshake protocol on TLS 1.2 (server-only authentication)
(b) The maTLS record protocol with a modiﬁcation log.
Fig. 3: The maTLS protocol. The maTLS handshake protocol is responsible for explicit authentication and security parameter
veriﬁcation, while the maTLS record protocol executes valid modiﬁcation checks.
performs explicit authentication in order to accept the server
and the middleboxes. Then, the client maps each accountability
key to the corresponding identity, where an identity is a digest
of an entity’s public key. Although the server does not receive
the certiﬁcates, the server can identify the client from the
accountability key.
After receiving the certiﬁcates, each maTLS segment ex-
changes key materials via the ServerKeyExchange and
ClientKeyExchange messages. Using the key material, all
entities generate shared secrets of the segment.
Finally, Finished messages are exchanged to verify the
handshake between two peers in each segment, followed by a
newly deﬁned ExtendedFinished message that includes
security parameter blocks from the server to the client. The
client performs security parameter veriﬁcation and conﬁrms
the proofs of private key possession by verifying the signatures
by processing the ExtendedFinished message.
D. maTLS Record Protocol
The maTLS record protocol provides data source authen-
tication, modiﬁcation accountability, and path integrity during
data exchange. The maTLS record protocol is illustrated in
Figure 3b. For each message, the record protocol generates the
data source, initializes an ML, and inserts its source MAC. On
receiving the message and its ML, each middlebox processes
the ML as mentioned earlier. A read-only middlebox extracts
the ﬁnal HMAC from the ML, performs the HMAC operation
over the previous HMAC to put its ﬁngerprint, and updates the
MAC. A writer middlebox appends the modiﬁcation MAC to
the ML.
Upon receipt of the message,
the destination performs
valid modiﬁcation checks by validating the ML, aborting the
connection if there has been an invalid modiﬁcation by middle-
boxes. The destination also veriﬁes the source of the incoming
message; for example, a server can abort the connection if the
HTTP request message (over maTLS) did not originate from
the client. Furthermore, since all the middleboxes in the session
leave their own MACs in the ML whenever the data is passed
the middleboxes, the endpoints can conﬁrm whether the order
of the middleboxes is preserved by verifying the MACs with
the accountability keys in sequence.
9
Security Goal
Code Snippet
All C S nonces #tc.
C_HandshakeComplete(C, S, nonces)@tc
Server Authentication
==>
Ex #ts.
S_HandshakeComplete(C, S, nonces)@ts &
(#ts 
Ex #tmb.
MB_C_HandshakeComplete(C, MB, last, next, nonces)@tmb
&
(#tmb 
Ex #tmb.
MB_SecurityParameters(C, M, nonces, params)@tmb &
(#tmb  (
All a1 a2 b1 b2 keyA keyB #tmb1 #tmb2.
SegmentKeyMade(a1, a2, nonces, keyA)@tmb1 &
SegmentKeyMade(b1, b2, nonces, keyB)@tmb2
Individual Secrecy
==> (
not (keyA = keyB) |
(a1 = b1 & a2 = b2)
))
Description
When a client believes she has
ﬁnished an maTLS handshake, the
corresponding server also believes
he has established a session with
the client, sharing the same ac-
countability key data
When the client conﬁrms a mid-
dlebox as part of the handshake,
the client shares accountability key
data with them
When the maTLS session is estab-
lished, a client correctly veriﬁes the
security parameters used in each
segment
At
the end of an maTLS hand-
shake, each segment has estab-
lished distinct TLS keys
All C S nonces req resp #trecv.
C_BelievesSentFromServer(C, S, nonces, req, resp)
Data Authentication
@trecv
==>
Ex #tresp.
S_Sent(C, S, nonces, req, resp)@tresp
When a client receives a message
from the server during the maTLS
record phase, the hash value from
the server is a faithful digest of the
original message
Modiﬁcation
Accountability
Path Integrity
All C S nonces req #trecv.
C_ReceiveResponse(C, S, req, nonces)@trecv
==> (
All before after M #tc.
C_ModificationChecks(C, M, req, nonces, before,
after)@tc &
( #tc  (
Ex #tmb.
MB_Modification(C, M, req, nonces, before, after)
@tmb
&
#tmb  (
All id #tf. ForwardAction(nonces, id, a2, a3)@tf
==> (
Ex #tp. ForwardAction(nonces, id, a1, a2)@tp &
#tp < #tf
))
When a client receives a message
during the maTLS record phase,
the client believes that a middlebox
has changed the message if and
only if that middlebox did make a
change
The client knows the order of
the intermediate middleboxes in an
maTLS session. Messages will al-
ways travel in this order.
TABLE III: Security Lemmas. Tamarin representations of the core security goals of the maTLS handshake and record phase
protocols. The full speciﬁcations are presented in our public repository.
10
VI. SECURITY VERIFICATION
We analyzed the security goals of the maTLS protocol
using Tamarin [24], an automated veriﬁcation tool. Tamarin
is built upon a multiset rewriting model, which supports the
unbounded analysis of security protocols based on a robust
equational theory. Tamarin is capable of accurately modeling
Difﬁe-Hellman style key exchange, and is built upon the
Dolev-Yao adversary.
The Tamarin execution model observes the development of
a series of states, each of which is a multiset of facts. Each fact
represents a detail about the current execution: for example, the
Out(msg) fact indicates that the message msg has been sent
out to the communication network, while the fact Ltk(A, k)
might represent that the agent A has a long-term encryption
key k. Facts are added and removed from the state through
a series of user-deﬁned rules, each of which is denoted by a
triple l → [ a ] → r. Here, l, a, and r are collections
of facts — for the rule to execute, the facts l are removed
from the state and replaced by the facts r. The facts a form a
trace: an indelible history of event markers that describe the
progression of the protocol’s execution.
Security goals, named lemmas, are expressed as ﬁrst-order
logic formulae describing requirements on the existence and
ordering of certain events, usually quantiﬁed over all possible
executions. If a formula is violated (generally indicating that
a goal has not been met), Tamarin generates a graph showing