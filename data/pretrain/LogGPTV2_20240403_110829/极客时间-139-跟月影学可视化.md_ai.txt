# 05 \| 如何用向量和坐标系描述点和线段？你好，我是月影。 为什么你做了很多可视化项目，解决了一个、两个、三个甚至多个不同类型的图表展现之后，还是不能系统地提升自己的能力，在下次面对新的项目时依然会有各种难以克服的困难？这是因为你陷入了细节里。 什么是细节？简单来说，细节就是各种纯粹的图形学问题。在可视化项目里，我们需要描述很多的图形，而描述图形的顶点、边、线、面、体和其他各种信息有很多不同的方法。并且，如果我们使用不同的绘图系统，每个绘图系统又可能有独特的方式或者特定的API，去解决某个或某类具体的问题。 正因为有了太多可以选择的工具，我们也就很难找到最恰当的那一个。而且**如果我们手中只有解决具体问题的工具，没有统一的方法论，那我们也无法一劳永逸地解决问题的根本**。 因此，我们要建立一套与各个图形系统无关联的、简单的基于向量和矩阵运算的数学体系，用它来描述所有的几何图形信息。这就是我在数学篇想要和你讨论的主要问题，也就是**如何建立一套描述几何图形信息的数学体系，以及如何用这个体系来解决我们的可视化图形呈现的问题**。 那这一节课，我们先学习用坐标系与向量来描述基本图形的方法，从如何定义和变换图形的直角坐标系，以及如何运用向量表示点和线段这两方面讲起。 坐标系与坐标映射首先，我们来看看浏览器的四个图形系统通用的坐标系分别是什么样的。 HTML 采用的是窗口坐标系，以参考对象（参考对象通常是最接近图形元素的position 非 static 的元素）的元素盒子左上角为坐标原点，x 轴向右，y轴向下，坐标值对应像素值。 SVG 采用的是视区盒子（viewBox）坐标系。这个坐标系在默认情况下，是以svg 根元素左上角为坐标原点，x 轴向右，y 轴向下，svg根元素右下角坐标为它的像素宽高值。如果我们设置了 viewBox 属性，那么 svg根元素左上角为 viewBox 的前两个值，右下角为 viewBox的后两个值。 Canvas采用的坐标系我们比较熟悉了，它默认以画布左上角为坐标原点，右下角坐标值为Canvas 的画布宽高值。 WebGL的坐标系比较特殊，是一个三维坐标系。它默认以画布正中间为坐标原点，x轴朝右，y 轴朝上，z 轴朝外，x 轴、y 轴在画布中范围是 -1 到1。 尽管这四个坐标系在原点位置、坐标轴方向、坐标范围上有所区别，但都是**直角坐标系**，所以它们都满足直角坐标系的特性：不管原点和轴的方向怎么变，用同样的方法绘制几何图形，它们的形状和相对位置都不变。 ![](Images/6689fd60812b9c9cfd6a9fad7187f5d1.png)savepage-src="https://static001.geekbang.org/resource/image/5e/89/5e3bc7cd089e2e28c527b57a1df5cb89.jpeg"}为了方便处理图形，我们经常需要对坐标系进行转换。转换坐标系可以说是一个非常基础且重要的操作了。正因为这四个坐标系都是直角坐标系，所以它们可以很方便地相互转化。其中，HTML、SVG和 Canvas 都提供了 transform 的 API 能够帮助我们很方便地转换坐标系。而WebGL 本身不提供 tranform 的 API，但我们可以在 shader里做矩阵运算来实现坐标转换，WebGL的问题我们在后续课程会有专门讨论，今天我们先来说说其他三种。那接下来我们就以Canvas 为例，来看看用 transform API怎样进行坐标转换。 如何用 Canvas 实现坐标系转换？假设，我们要在宽 512 \* 高 256 的一个 Canvas画布上实现如下的视觉效果。其中，山的高度是 100，底边200，两座山的中心位置到中线的距离都是 80，太阳的圆心高度是150。 当然，在不转换坐标系的情况下，我们也可以把图形绘制出来，但是要经过顶点换算，下面我们就来说一说这个过程。 ![](Images/ff0450f9c859c40a4e9da9feb5d0184d.png)savepage-src="https://static001.geekbang.org/resource/image/a8/09/a8ec91897b2ede72d5c48d4d6b2d5409.jpeg"}首先，因为 Canvas 坐标系默认的原点是左上角，底边的 y 坐标是256，而山的高度是 100，所以山顶点的 y 坐标是 256 - 100 =156。而因为太阳的高度是 150，所以太阳圆心的 y 坐标是 256 - 150 =106。 然后，因为 x 轴中点的坐标是 512 / 2 = 256，所以两座山顶点的 x坐标分别是 256 - 80 和 256 + 80，也就是 176 和336。又因为山是等腰三角形，它的底边是 200，所以两座山底边的 x坐标计算出来，分别是 76、276、236、436（176 - 100 =76、176 +100=276、336 - 100=236、 336 +100=436）。 ![](Images/d0638f1dcd98b5137adf96d72b2b1bda.png)savepage-src="https://static001.geekbang.org/resource/image/55/29/552676f6f0268d2091b838e268651929.jpeg"}计算出这些坐标之后，我们很容易就可以将这个图画出来了。不过，为了增加一些趣味性，我们用一个Rough.jsslate-object="inline"的库，绘制一个手绘风格的图像（Rough.js 库的 API 和 Canvas差不多，绘制出来的图形比较有趣）。绘制的代码如下所示：     const rc = rough.canvas(document.querySelector('canvas'));    const hillOpts = {roughness: 2.8, strokeWidth: 2, fill: 'blue'};    rc.path('M76 256L176 156L276 256', hillOpts);    rc.path('M236 256L336 156L436 256', hillOpts);    rc.circle(256, 106, 105, {      stroke: 'red',      strokeWidth: 4,      fill: 'rgba(255, 255, 0, 0.4)',      fillStyle: 'solid',    });最终，我们绘制出的图形效果如下所示：![](Images/5c3a3d77e193b409bc2c5da4bfd5566f.png)savepage-src="https://static001.geekbang.org/resource/image/cd/cb/cddabd7aeca8e5yy0c22c85879f5dccb.jpeg"}到这里，我们通过简单的计算就绘制出了这一组图形。但你也能够想到，如果每次绘制都要花费时间在坐标换算上，这会非常不方便。所以，为了解决这个问题，我们可以采用坐标系变换来代替坐标换算。这里，我们给 Canvas 的 2D 上下文设置一下 transform变换。我们经常会用到两个变换：translate 和scale。 首先，我们通过 translate 变换将 Canvas 画布的坐标原点，从左上角 (0,0) 点移动至 (256, 256)位置，即画布的底边上的中点位置。接着，以移动了原点后新的坐标为参照，通过scale(1, -1) 将 y 轴向下的部分，即 y\>0 的部分沿 x 轴翻转 180度，这样坐标系就变成以画布底边中点为原点，x 轴向右，y轴向上的坐标系了。![](Images/26d5a76315caaf1c74cccde24624c2b3.png)savepage-src="https://static001.geekbang.org/resource/image/8a/de/8a1f3ed166942736206124aba16965de.jpeg"}坐标系执行了这个坐标变换，也就是让坐标系原点在中间之后，我们就可以更方便、直观地计算出几个图形元素的坐标了。两个山顶的坐标就是 (-80, 100) 和 (80, 100)，山脚的坐标就是 (-180,0)、(20, 0)、(-20, 0)、(180, 0)，太阳的中心点的坐标就是 (0,150)。那么更改后的代码如下所示。    const rc = rough.canvas(document.querySelector('canvas'));    const ctx = rc.ctx;    ctx.translate(256, 256);    ctx.scale(1, -1);    const hillOpts = {roughness: 2.8, strokeWidth: 2, fill: 'blue'};    rc.path('M-180 0L-80 100L20 0', hillOpts);    rc.path('M-20 0L80 100L180 0', hillOpts);    rc.circle(0, 150, 105, {      stroke: 'red',      strokeWidth: 4,      fill: 'rgba(255,255, 0, 0.4)',      fillStyle: 'solid',    });好了，现在我们就完成了坐标变换。但是因为这个例子要绘制的图形很少，所以还不太能体现使用坐标系变换的好处。不过，你可以想一下，在可视化的许多应用场景中，我们都要处理成百上千的图形。如果这个时候，我们在原始坐标下通过计算顶点来绘制图形，计算量会非常大，很麻烦。那采用坐标变换的方式就是一个很好的优化思路，**它能够简化计算量，这不仅让代码更容易理解，也可以节省 CPU运算的时间**。理解直角坐标系的坐标变换之后，我们再来说说直角坐标系里绘制图形的方法。**那不管我们用什么绘图系统绘制图形，一般的几何图形都是由点、线段和面构成。其中，点和线段是基础的图元信息，因此，如何描述它们是绘图的关键**。如何用向量来描述点和线段？那在直角坐标系下，我们是怎么表示**点和线段的呢**？我们一般是用向量来表示一个点或者一个线段。前面的例子因为包含 x、y两个坐标轴，所以它们构成了一个绘图的平面。因此，我们可以用二维向量来表示这个平面上的点和线段。二维向量其实就是一个包含了两个数值的数组，一个是x 坐标值，一个是 y 坐标值。![](Images/38805c64d0ddebe2bf4b80e7f97027a0.png)savepage-src="https://static001.geekbang.org/resource/image/0d/58/0de1596f2df5002c3a8b26723f0f0558.jpeg"}假设，现在这个平面直角坐标系上有一个向量 v。向量 v有两个含义：一是可以表示该坐标系下位于 (x, y)处的一个点；二是可以表示从原点 (0,0) 到坐标 (x,y)的一根线段。接下来，为了方便你理解，我们先来回顾一下关于向量的数学知识。**首先，向量和标量一样可以进行数学运算。**举个例子，现在有两个向量，v1] slate-object="inline"和 v2] slate-object="inline"，如果让它们相加，其结果相当于将v1] slate-object="inline"向量的终点（x1] slate-object="inline", y1] slate-object="inline"），沿着 v2] slate-object="inline"向量的方向移动一段距离，这段距离等于v2] slate-object="inline"向量的长度。这样，我们就可以在平面上得到一个新的点（x1] slate-object="inline" + x2] slate-object="inline", y1] slate-object="inline" + y2] slate-object="inline"），一条新的线段\[(0, 0),(x1] slate-object="inline" + x2] slate-object="inline", y1] slate-object="inline" + y2] slate-object="inline")\]，以及一段折线：\[(0, 0),(x1] slate-object="inline", y1] slate-object="inline") , (x1] slate-object="inline" + x2] slate-object="inline", y1] slate-object="inline" + y2] slate-object="inline")\]。![](Images/50bc242ab8b93406dfcfe15c34669949.png)savepage-src="https://static001.geekbang.org/resource/image/8e/29/8ebb3963e385ba9fda2dab46d7277e29.jpeg"}**其次，一个向量包含有长度和方向信息**。它的长度可以用向量的 x、y 的平方和的平方根来表示，如果用JavaScript 来计算，就是：    v.length = function(){return Math.hypot(this.x, this.y)};它的方向可以用与 x轴的夹角来表示，即：    v.dir = function() { return Math.atan2(this.y, this.x);}在上面的代码里，Math.atan2 的取值范围是 -π到π，负数表示在 x轴下方，正数表示在 x 轴上方。最后，根据长度和方向的定义，我们还能推导出一组关系式：    v.x = v.length * Math.cos(v.dir);    v.y = v.length * Math.sin(v.dir);这个推论意味着一个重要的事实：我们可以很简单地构造出一个绘图向量。也就是说，如果我们希望以点(x0] slate-object="inline", y0] slate-object="inline") 为起点，沿着某个方向画一段长度为 length的线段，我们只需要构造出如下的一个向量就可以了。![](Images/6c8c7eef202b1cf4e42811e92e9e2449.png)savepage-src="https://static001.geekbang.org/resource/image/7c/a3/7cf68477844ee77a31163008d2bb39a3.jpeg"}这里的α是与 x 轴的夹角，v 是一个单位向量，它的长度为1。然后我们把向量 (x0] slate-object="inline", y0] slate-object="inline") 与这个向量 v1] slate-object="inline"相加，得到的就是这条线段的终点。这么讲还是比较抽象，我们看一个例子。实战演练：用向量绘制一棵树我们用前面学到的向量知识来绘制一棵随机生成的树，想要生成的效果如下：![](Images/fc140c79e605bf97c8a0052399b3be69.png)savepage-src="https://static001.geekbang.org/resource/image/6y/f4/6yydf8017e95529yybb987d97e9yy9f4.jpeg"}我们还是用 Canvas2D来绘制。首先是坐标变换，原理前面讲过，我就不细说了。这里，我们要做的变换是将坐标原点从左上角移动到左下角，并且让y 轴翻转为向上。    ctx.translate(0, canvas.height);    ctx.scale(1, -1);    ctx.lineCap = 'round';然后，我们定义一个画树枝的函数drawBranch。    function drawBranch(context, v0, length, thickness, dir, bias) {      ...    }这个函数有六个参数：1.  context 是我们的 Canvas2D    上下文    2.  v       [0        ] slate-object="inline"    是起始向量        3.  length 是当前树枝的长度        4.  thickness    是当前树枝的粗细        5.  dir 是当前树枝的方向，用与 x    轴的夹角表示，单位是弧度。        6.  bias    是一个随机偏向因子，用来让树枝的朝向有一定的随机性        因为 v0] slate-object="inline"是树枝的起点坐标，那根据前面向量计算的原理，我们创建一个单位向量(1, 0)，它是一个朝向 x 轴，长度为 1 的向量。然后我们旋转 dir弧度，再乘以树枝长度length。这样，我们就能计算出树枝的终点坐标了。代码如下：     const v = new Vector2D(1, 0).rotate(dir).scale(length);     const v1 = v0.copy().add(v);向量的旋转是向量的一种常见操作，对于二维空间来说，向量的旋转可以定义成如下方法（这里我们省略了数学推导过程，有兴趣的同学可以去看一下数学原理slate-object="inline"）。这个方法我们后面还会经常用到，你先记一下，后续我们讲到仿射变换的时候，会有更详细的解释。    class Vector2D {      ...        rotate(rad) {        const c = Math.cos(rad),          s = Math.sin(rad);        const [x, y] = this;        this.x = x * c + y * -s;        this.y = x * s + y * c;        return this;      }    }我们可以从一个起始角度开始递归地旋转树枝，每次将树枝分叉成左右两个分枝：      if(thickness > 2) {        const left = dir + 0.2;        drawBranch(context, v1, length * 0.9, thickness * 0.8, left, bias * 0.9);        const right = dir - 0.2;        drawBranch(context, v1, length * 0.9, thickness * 0.8, right, bias * 0.9);      }![](Images/a7aaa9c1b2ffe2e09e5aa00e6d78fef2.png)savepage-src="https://static001.geekbang.org/resource/image/1f/y1/1f95a7d1e6ecf30c7db0ef0afc0f7yy1.jpeg"}这样，我们得到的就是一棵形状规律的树。接着我们修改代码，加入随机因子，让迭代生成的新树枝有一个随机的偏转角度。      if(thickness > 2) {        const left = Math.PI / 4 + 0.5 * (dir + 0.2) + bias * (Math.random() - 0.5);        drawBranch(context, v1, length * 0.9, thickness * 0.8, left, bias * 0.9);        const right = Math.PI / 4 + 0.5 * (dir - 0.2) + bias * (Math.random() - 0.5);        drawBranch(context, v1, length * 0.9, thickness * 0.8, right, bias * 0.9);      }这样，我们就可以得到一棵随机的树。![](Images/f461900a0a8bfe6659e30854b3d86c45.png)savepage-src="https://static001.geekbang.org/resource/image/53/7f/5350becdbb756ce4dae1289b7beba37f.jpeg"}最后，为了美观，我们再随机绘制一些花瓣上去，你也可以尝试绘制其他的图案到这棵树上。      if(thickness  Math.PI / 3 && v0.dir     \|\|b\|\|v\|sin(30°)\| = \|sin(30°)\| =    0.5。    ![](Images/30051ca13c2c30785719f9314e1c1acd.png)savepage-src="https://static001.geekbang.org/resource/image/9e/4a/9ea951c875b5dc3bc3169dda68fea94a.jpg"}因此，只要任意一点所在的向量与单位向量的叉积结果的绝对值不大于0.5（即sin30°），就说明这个点在扫描范围内。所以我们可以用如下代码来判断：    const isInRange = Math.abs(new Vec2(0, 1).cross(v0.normalize()))  25 * t,      t => 25 * t ** 2,    );    // 绘制抛物线    para(-5.5, 5.5).draw(ctx);再比如，我们可以绘制出阿基米德螺旋线，代码如下：    const helical = parametric(      (t, l) => l * t * Math.cos(t),      (t, l) => l * t * Math.sin(t),    );    helical(0, 50, 500, 5).draw(ctx, {strokeStyle: 'blue'});以及，我们还可以绘制星形线，代码如下：    const star = parametric(      (t, l) => l * Math.cos(t) ** 3,      (t, l) => l * Math.sin(t) ** 3,    );    star(0, Math.PI * 2, 50, 150).draw(ctx, {strokeStyle: 'red'});同时绘制三条曲线后的效果，如下图所示。详细的代码，我都放到了GitHub 仓库slate-object="inline"。你可以自己动手试一试，看看怎么把它们组合成更多有趣的图形。![](Images/5caa680e5b337a80f45ab0432a50b519.png)savepage-src="https://static001.geekbang.org/resource/image/3e/b4/3e20fa773a4bfd78a22160832e2fdbb4.jpg"}4. 画贝塞尔曲线前面我们说的这些曲线都比较常见，它们都是符合某种固定数学规律的曲线。但生活中还有很多不规则的图形，无法用上面这些规律的曲线去描述。那我们该如何去描述这些不规则图形呢？**贝塞尔曲线**（BezierCurves）就是最常见的一种解决方式。它在可视化领域中也是一类非常常用的曲线，它通过起点、终点和少量控制点，就能定义参数方程来生成复杂的平滑曲线，所以它通常被用来构建数据信息之间连接线。![](Images/ed2da7e593045c4c045b1489a458c8a1.png)savepage-src="https://static001.geekbang.org/resource/image/54/29/546a855fc34c45cb7e654ffda4f88f29.png"}贝塞尔曲线示意图贝塞尔曲线又分为**二阶贝塞尔曲线**（Quadratic BezierCurve）和**三阶贝塞尔曲线**（Qubic BezierCurve）。顾名思义，二阶贝塞尔曲线的参数方程是一元二次多项式，那么三阶贝塞尔曲线的参数方程是一元三次多项式。接下来，我们就分别说说它们的公式和描述曲线的方法其中，二阶贝塞尔曲线由三个点确定，P0] slate-object="inline"是起点，P1] slate-object="inline"是控制点，P2] slate-object="inline"是终点，示意图如下：![](Images/6f342e453dcbf6a7096a39950f7c64d6.png)savepage-src="https://static001.geekbang.org/resource/image/5a/36/5a15bb08a9815723a7745119b6328436.jpeg"}我们可以用 parametric构建并绘制二阶贝塞尔曲线，代码如下所示：    const quadricBezier = parametric(      (t, [{x: x0}, {x: x1}, {x: x2}]) => (1 - t) ** 2 * x0 + 2 * t * (1 - t) * x1 + t ** 2 * x2,      (t, [{y: y0}, {y: y1}, {y: y2}]) => (1 - t) ** 2 * y0 + 2 * t * (1 - t) * y1 + t ** 2 * y2,    );    const p0 = new Vector2D(0, 0);    const p1 = new Vector2D(100, 0);    p1.rotate(0.75);    const p2 = new Vector2D(200, 0);    const count = 30;    for(let i = 0; i  (1 - t) ** 3 * x0 + 3 * t * (1 - t) ** 2 * x1 + 3 * (1 - t) * t ** 2 * x2 + t ** 3 * x3,      (t, [{y: y0}, {y: y1}, {y: y2}, {y: y3}]) => (1 - t) ** 3 * y0 + 3 * t * (1 - t) ** 2 * y1 + 3 * (1 - t) * t ** 2 * y2 + t ** 3 * y3,    );    const p0 = new Vector2D(0, 0);    const p1 = new Vector2D(100, 0);    p1.rotate(0.75);    const p2 = new Vector2D(150, 0);    p2.rotate(-0.75);    const p3 = new Vector2D(200, 0);    const count = 30;    for(let i = 0; i  {      const {x, y} = evt;      // 坐标转换      const offsetX = x - left;      const offsetY = y - top;      ctx.clearRect(-256, -256, 512, 512);      if(ctx.isPointInPath(offsetX, offsetY)) {        draw(ctx, poitions, 'transparent', 'green');      } else {        draw(ctx, poitions, 'transparent', 'red');      }    });最后，上面代码运行效果如下图：![](Images/34903c6dbcc1a9f6c2c7bd2d954fa4aa.png)savepage-src="https://static001.geekbang.org/resource/image/4f/97/4f370d3187e964efc733294a3ed2de97.gif"}这个运行结果是没有问题的，但 isPointInPath这个方法实际上并不好用。因为 isPointInPath方法只能对当前绘制的图形生效。这是什么意思呢？我来举个例子。假设，我们要在 Canvas 中绘制多边形 c 和小三角形。那我们先绘制多边形c，再绘制小三角形。绘制代码如下：    draw(ctx, poitions, 'transparent', 'red');    draw(ctx, [[100, 100], [100, 200], [150, 200]], 'transparent', 'blue');    const {left, top} = canvas.getBoundingClientRect();    canvas.addEventListener('mousemove', (evt) => {      const {x, y} = evt;      // 坐标转换      const offsetX = x - left;      const offsetY = y - top;            ctx.clearRect(-256, -256, 512, 512);            // 判断 offsetX、offsetY 的坐标是否在多边形内部      if(ctx.isPointInPath(offsetX, offsetY)) {        draw(ctx, poitions, 'transparent', 'green');        draw(ctx, [[100, 100], [100, 200], [150, 200]], 'transparent', 'orange');      } else {        draw(ctx, poitions, 'transparent', 'red');        draw(ctx, [[100, 100], [100, 200], [150, 200]], 'transparent', 'blue');      }    });这里，我们还通过 isPointInPath方法判断点的位置，这样得到的结果如下图：![](Images/86221cb3d22647e4a6048e7cabb1ddf8.png)savepage-src="https://static001.geekbang.org/resource/image/5e/3e/5e566597db9519bcb0fdc09ce6390e3e.gif"}你会看到，当我们将鼠标移动到中间大图时，它的颜色并没有发生变化，只有移动到右上角的小三角形时，这两个图形才会同时变色。这就是因为，isPointInPath仅能判断鼠标是否在最后一次绘制的小三角形内，所以大多边形就没有被识别出来。要解决这个问题，一个最简单的办法就是，我们自己实现一个 isPointInPath方法。然后在这个方法里，重新创建一个 Canvas 对象，并且再绘制一遍多边形 c和小三角形。这个方法的核心，其实就是在绘制的过程中获取每个图形的isPointInPath 结果。代码如下：    function isPointInPath(ctx, x, y) {      // 我们根据ctx重新clone一个新的canvas对象出来      const cloned = ctx.canvas.cloneNode().getContext('2d');      cloned.translate(0.5 * width, 0.5 * height);      cloned.scale(1, -1);      let ret = false;      // 绘制多边形c，然后判断点是否在图形内部      draw(cloned, poitions, 'transparent', 'red');      ret |= cloned.isPointInPath(x, y);      if(!ret) {        // 如果不在，在绘制小三角形，然后判断点是否在图形内部        draw(cloned, [[100, 100], [100, 200], [150, 200]], 'transparent', 'blue');        ret |= cloned.isPointInPath(x, y);      }      return ret;    }但是，这个方法并不通用。因为一旦我们修改了绘图过程，也就是增加或者减少了绘制的图形，isPointInPath方法也要跟着改变。当然，我们也有办法进行优化，比如将每一个几何图形的绘制封装起来，针对每个图形提供单独的isPointInPath 判断，但是这样也很麻烦，而且有很多无谓的 Canvas绘图操作，性能会很差。2. 实现通用的 isPointInPath 方法那一个更好的办法是，我们不使用 Canvas 的 isPointInPath方法，而是直接通过点与几何图形的数学关系来判断点是否在图形内。但是，直接判断一个点是不是在一个几何图形内还是比较困难的，因为这个几何图形可能是简单多边形，也可能是复杂多边形。这个时候，我们完全可以把视线放在最简单的多边形，也就是三角形上。因为对于三角形来说，我们有一个非常简单的方法可以判断点是否在其中。这个方法就是，已知一个三角形的三条边分别是向量 a、b、c，平面上一点 u连接三角形三个顶点的向量分别为u1] slate-object="inline"、u2] slate-object="inline"、u3] slate-object="inline"，那么 u点在三角形内部的充分必要条件是：u1] slate-object="inline" X a、u2] slate-object="inline" X b、u3] slate-object="inline" X c 的符号相同。你也可以看我下面给出的示意图，当点 u 在三角形 a、b、c 内时，因为u1] slate-object="inline"到 a、u2] slate-object="inline"到 b、u3] slate-object="inline"到 c 的小角旋转方向是相同的（这里都为顺时针），所以u1] slate-object="inline" X a、u2] slate-object="inline" X b、u3] slate-object="inline" X c 要么同正，要么同负。当点 v在三角形外时，v1] slate-object="inline"到 a方向是顺时针，v2] slate-object="inline"到 b方向是逆时针，v3] slate-object="inline"到 c方向又是顺时针，所以它们叉乘的结果符号并不相同。![](Images/6e16af9aff9ce061aab2c97141497edd.png)savepage-src="https://static001.geekbang.org/resource/image/34/c3/3402b08454dbc39f9543cb4c597419c3.jpg"}根据这个原理，我们就可以写一个简单的判定函数了，代码如下：    function inTriangle(p1, p2, p3, point) {      const a = p2.copy().sub(p1);      const b = p3.copy().sub(p2);      const c = p1.copy().sub(p3);      const u1 = point.copy().sub(p1);      const u2 = point.copy().sub(p2);      const u3 = point.copy().sub(p3);      const s1 = Math.sign(a.cross(u1));      const s2 = Math.sign(b.cross(u2));      const s3 = Math.sign(c.cross(u3));      return s1 === s2 && s2 === s3;    }你以为到这里就结束了吗？还没有。上面的代码还有个Bug，它虽然可以判定点在三角形内部，但却不能判定点恰好在三角形某条边上的情况。这又该如何优化呢？在学习了向量乘法之后，我们知道。如果一个点 u 在三角形的一条边 a上，那就会需要满足以下 2个条件： 1.       a.cross(u1) === 0        2.       0 \= 0 && p = 0 && p = 0 && p  {        triangle.u_time = (performance.now() - triangle.startTime) / 1000;        setUniforms(gl, triangle);        gl.drawArrays(gl.TRIANGLES, 0, position.length / 2);      });      // 移除已经结束动画的三角形      triangles = triangles.filter((triangle) => {        return triangle.u_time  {      return multiply([], b, a);    });    console.log(res);    /*    [1.299038105676658, -0.7499999999999999, 61.60254037844388,       0.7499999999999999, 1.299038105676658, 93.30127018922192,      0, 0, 1    */所以呢，我们最终就可以将上面的 transform用一个矩阵表示：    div.block {      transform: matrix(1.3,0.75,-0.75,1.3,61.6,93.3)；    }这样的 transform 效果和之前 rotate、translate 和 scale分开写的效果是一样的，但是字符数更少，所以能减小 CSS文件的大小。那在我们介绍完仿射变换之后，你是不是对 CSS transform的理解也更深了呢？没错，不光是transform，在我们之后的学习中，你也可以多想想，还有哪些内容在 CSS中也有相似的作用，是不是也能利用在可视化中学到的知识来优化性能。要点总结这一节课我们介绍了用向量和矩阵运算来改变几何图形的形状、大小和位置。其中，向量的平移、旋转和缩放都属于仿射变换，而仿射变换具有2 个性质： 1.       变换前是直线段的，变换后依然是直线段        2.       对两条直线段 a 和 b    应用同样的仿射变换，变换前后线段长度比例保持不变        那仿射变换中的旋转和缩放又属于线性变换，而线性变换在仿射变换性质的基础上还有2 个额外的性质：1.       线性变换不改变坐标原点（因为如果    x       [0        ] slate-object="inline"    、y        [0        ] slate-object="inline"    等于零，那么 x、y 肯定等于    0）    2.       线性变换可以叠加，多个线性变换的叠加结果就是将线性变换的矩阵依次相乘，再与向量相乘        通过齐次坐标和齐次矩阵，我们可以将平移这样的非线性仿射变换用更高维度的线性变换来表示。这么做的目的是让我们能够将仿射变换的组合简化为矩阵乘法运算。到这里，数学基础篇的内容我们就学完了。在这一篇的开头，我们说了要总结出一个通用的基础数学绘图体系，这样才不至于陷入细节里。所以啊，我总结了一个简单的知识脑图，把我们在数学篇里讲过的数学知识汇总到了一起，它肯定不会是一个非常完整的数学绘图体系，但是对我们之后的学习来说，已经足够用了。![](Images/766af8f12dbded20bf7f4d7608ed7f68.png)savepage-src="https://static001.geekbang.org/resource/image/bf/7c/bfdd8c7f5f15e5b703128cdaf419f07c.jpg"}最后呢，我还想再啰嗦几句。图形学作为可视化的基础，是一门很深的学问。它牵涉的数学内容非常多，包括线性代数、几何、微积分和概率统计等等。那这门课里我们所介绍的数学知识，其实还都只是一些入门知识。那如果你对图形学本身很感兴趣，想要深入学习它在其他领域，比如游戏、视频、AR/VR等领域的应用，这里我推荐你一些深入学习的资料。1.       [3Blue1Brown    的数学和图形学基础课程                讲得深入浅出，是非常棒的入门教程。        2.       [《Fundamentals of Computer    Graphics》            slate-object="inline"    这本书是图形学入门的经典教材。        小试牛刀1.       在实现粒子动画的时候，我们让 translateMatrix \* rotateMatrix \*    scaleMatrix，这三个矩阵按这样的顺序相乘。那如果我们颠倒它们的相乘次序，把    roateMatrix 放到 translateMatrix 前面，或者把 scaleMatrix 放到    translateMatrix    前面，会产生什么样的结果呢？为什么呢？你可以思考一下，然后从 GitHub    上 fork 代码，动手试一试。        2.       我们知道，CSS 的 transform 除了 translate、rotate 和 scale    变换以外，还有 skew 变换。skew    变换是一种沿着轴向的扭曲变换，它也属于一种线性变换，它的变换矩阵是：        你可以使用这个矩阵，给我们的粒子动画加上随机的扭曲效果吗？1.       因为齐次坐标和齐次矩阵的概念，可以从二维一直推广到 N 维，而且 CSS    的 transform 还支持 3D 变换。那你可以用齐次矩阵的原理对 CSS 属性的    3D 变换应用 matrix3d，实现出有趣的 3D 变换效果吗？（💡小提示：要支持    3 维的齐次坐标，需要 4    维齐次矩阵）？        欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课见！  源码\[1\]粒子动画的slate-object="mark"}完整代码slate-object="mark"}\[2\]矩阵运算数学库的slate-object="mark"}完整代码slate-object="mark"}推荐阅读\[1\]WebGL 的 uniform 变量设置slate-object="mark"}官方文档slate-object="mark"}\[2\] [[3Blue1Brown的数学和图形学基础课程slate-object="mark"} \[3\]图形学入门经典教材slate-object="mark"}《Fundamentals of ComputerGraphics》  