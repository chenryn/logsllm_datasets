该方法返回由待拼接的字符串与str1、str2等参数拼接形成的新字符串：
String.prototype.toLowerCase()
该方法将原字符串中的字符转换为小写并返回：
String.prototype.toLocaleLowerCase()
该方法的功能与toLowerCase()一样，但是转换时其遵循本地规则。根据ECMAScript规范：“只有在语言转换规则与常规字符大小写映射有冲突的少数情况下（例如土耳其语）会有所差异。”
String.prototype.toUpperCase()
该方法将原字符串中的字符转换为大写并返回：
String.prototype.toLocaleUpperCase()
该方法的功能与toUpperCase()一样，但是转换时其遵循本地规则。
12.10.3 字符串的检索和比较
下面这些方法用于检索和比较字符串：
String.prototype.indexOf(searchString, position?)
该方法从字符串的position位置（默认为0）开始检索，返回searchString在字符串中出现的位置，若未找到则返回−1：
需要注意的是，当该方法用于检测字符串是否包含文本时，正则表达式可以达到相同的效果。例如，以下两个表达式是等价的：
String.prototype.lastIndexOf(searchString, position?)
该方法从字符串的position位置（默认为结尾位置）从后向前检索，返回searchString在字符串中出现的位置，若未找到返回−1：
String.prototype.localeCompare(other)
该方法用本地特定的顺序对字符串和other进行比较。其返回值为数字：
字符串在字母表中排在other前面时返回值小于0；
字符串等于other时返回值等于0；
字符串在字母表中排在other后面时返回值大于0。
示例如下：
警告：
 并不是所有的JavaScript引擎都能恰当地支持该方法。一些引擎仅仅是通过比较运算符来实现该方法。然而，ECMAScript国际化API（参见30.3“ECMAScript的国际化API”）的确提供了字符感知的实现。即如果该API在引擎中是可用的，那么localCompare()也是可用的。
如果JavaScript引擎能够支持，那么在比较字符串时localCompare()是优于比较运算符的选择。详情参见12.5“字符串比较”。
12.10.4 支持正则表达式的方法
以下这些方法支持正则表达式：
String.prototype.search(regexp)（详情参见19.5“String.prototype. search：匹配位置的索引”）
该方法返回字符串中第一个与regexp相匹配的子字符串的起始位置（若未匹配返回−1）：
String.prototype.match(regexp)(详情参见19.7“String.prototype. match：捕获分组或返回所有匹配的子字符串”)
该方法将regexp与字符串进行匹配。若regexp未设置全局标志/g则返回一个对象，它存放了第一次匹配相关的信息：
如果设置了/g标志，则将所有匹配的子字符串存放在一个数组中返回：
String.prototype.replace(search, replacement)（详情参见19.8“String.prototype.replace：查找和替换”）
该方法检索与search匹配的子字符串并用replacement替换。search可以是字符串或正则表达式，replacement可以是字符串或函数。除非search是设置了/g标志的正则表达式，否则仅第一个匹配项会被替换：
替换字符串中的$符号允许使用完全匹配或捕获分组进行替换：
也可以通过函数进行替换：
[1] 严格地说，JavaScript字符串由一系列UTF-16编码单元组成。也就是说，JavaScript字符都是Unicode编码单元（参见第24章）。
第13章 语句
这章覆盖了JavaScript的语句：变量声明、循环、条件语句等内容。
13.1 声明和变量赋值
var用来声明变量，你可以用它来创建变量并使用变量。其中等号运算符被用来给变量赋值：
你也可以把这两句整合为一个var语句：
你还可以将多个var语句合并为一个：
更多与变量相关的知识可以参考第16章。
13.2 循环语句和条件语句的主体
合成语句（例如循环或条件语句）往往包含有多个“主体”，例如while循环：
对于主体«statement»，你可以直接使用一条语句：
也可以使用块（其中包含了一条语句）：
而主体包含多条语句时则需要使用块。尽管多条语句可以被合成为一条语句写在一行中，不过我还是更倾向使用块。
13.3 循环
这一节我们来看一下循环语句。
13.3.1 循环的机制
以下的机制可以用在循环中：
break «label»
跳出整个循环。
Continue «label»
跳出本地的循环体，立即进入下一次的循环体。
标签
标签是一个紧跟了冒号的标示符。当标签在循环体之前时，你可以从循环体(甚至是嵌套的循环)中使用标签跳出整个或单个循环。当标签在块之前时，你可以用标签跳出块。这两种情况下，标签名都是作为break或者continue的参数进行使用。下面是一个跳出块的例子：
13.3.2 while
一个while循环如下：
如果condition条件满足，就会一直循环执行statement。如果条件永远是true，那将会产生一个无限的循环：
以下例子，我们删除一个数组的所有元素并将它们打印在console里面：
这是输出：
13.3.3 do-while
一个do-while循环：
首先至少会执行一次statement，接下来看condition是否为true来判断是否执行statement。例如：
13.3.4 for
在一个for循环中：
init部分在进入循环时会执行一次，而如果condition不为false的话，循环就会一直执行。你可以在init部分使用var来定义变量，要注意的是这些变量的作用域永远是包含这个循环的函数。post_iteration部分在每一次循环个体结束后执行。将所有的内容考虑在一起，之前的for循环就等同于下面的while循环：
下面的例子是一个典型的数组遍历的例子（其他的方式详见18.14“最佳实践：遍历数组”）。
如果你省略了一个for循环头中所有部分，for循环将会成为一个无限的循环：
13.3.5 for-in
一个for-in循环如下：
它可以遍历一个对象中的所有的键值，包含所继承的键值。如果某个键值是不可枚举的，则会被忽略（可见17.8“属性特性和属性描述符”）。下面是一些适用于for-in循环的规则。
你可以在循环中使用var声明变量，但是变量的作用域永远是当前包含循环的函数体。
在遍历属性时，属性可以被删除。
最佳实践：不要用for-in来遍历数组
不要使用for-in来遍历数组。第一，for-in只会遍历索引，而不是数组元素：
其次，for-in还会遍历所有的(非索引)属性值。下面的例子显示如果你给一个数组添加一个foo属性会产生的结果：
因此，最好使用for循环或者数组的forEach()方法(可见18.14“最佳实践：遍历数组”)。
最佳实践：留心for-in作用于对象的细节
for-in循环会遍历所有的（可枚举的）属性，其中包括了继承来的属性。这些属性有时候不是你所希望要的。我们用一个构造器来展现这个问题：
Person的实例从Person.prototype上面继承了describe属性。我们通过for-in可以看到：
输出：
通常，我们可以使用hasOwnProperty()来在for-in中排除对象所继承的属性：
这时候只输出name：
还有一点要注意的：实例person可能也有一个hasOwnProperty的属性，这可能导致以上的方式失效。安全起见，你可以使用最通用的方式（详情可见17.15“泛型方法：借用原型方法”）：
此外，你还可以参考17.6“最佳实践：遍历自有属性”中所罗列的更多更合适的遍历属性的方式。
13.3.6 for each-in
这种循环只在Firefox中有效。不建议使用。
13.4 条件语句
这一节我们来讨论一下JavaScript的条件语句。
13.4.1 if-then-else
在一个if-then-else语句中：
then_branch和else_branch既可以是单句语句也可以是语句块（详情可参考13.2“循环语句和条件语句的主体”）。
链式if语句
你可以连接多个if语句：
注意，在以上例子中，所有的else分支都是单句语句（if语句）。在JavaScript中，如果你还要连接更多的else语句块，你就需要另一个else if分支。
陷阱：模糊的else
下面的else的使用并不明确，因为这样写，我们分不清这个else属于哪一个if语句：
对此，有一个很简单有效的规则：使用括号。上面的代码片段与下面的是等价的（而明显下面的代码更清晰地展现了else的所属关系）：
13.4.2 switch
以下这个switch语句：
首先，会执行expression，然后会根据expression的结果与每条case中的label比较来判断要跳到哪个case语句。如果没有匹配的label，switch就会尝试执行default中的语句。
case之后的操作可以是任何的语句，而判断进入哪一个case是通过“===”全等于来比较的。
如果你不在某一条case中使用“终止”语句，JavaScript会自动执行下一条case中的语句。在switch中最常用的“终止”语句是break。事实上，return和throw也同样有“终止”作用。只是它们做的不只是结束switch语句中的逻辑。
下面的例子中使用了throw和return，此时就没有必要使用break：
而在以下这个例子中，没有default的分支。因此如果没有匹配的fruit时，什么也不会执行：
此外，我们也可以将多个case排在一列：
这个例子证明了case后的内容可以是任意的语句：
上面的switch语句会将其参数true与各个case中的表达式的值做比较。如果其中一个表达式的值为true，那么就会执行其后面的代码体。因此上面的代码与下面的if语句是等价的：
你可能更倾向于后一种，因为它的可读性更好。
13.5 with语句
这一节会解释JavaScript中的with语句是如何工作的，以及为何它会被废弃。
13.5.1 语法与语义
with语句的语法如下：
它会将object的属性转变为本地变量提供给statement语句部分。例如：
它往往被用于避免过于冗余的对象调用。下面的例子说明了这个道理：
使用with可以缩短调用：
13.5.2 with语句已被废弃
with语句已经不推荐使用了（下一节，我们会解释原因）。例如，它在strict模式下面是被禁用的：
如何避免使用with语句
要避免这样的代码：
你可以使用一个临时变量来替代：
如果你不想在当前的作用域引入临时变量，你可以使用IIFE（详见16.6“通过IIFE引入新的作用域”）：
你也可以把IIFE要访问的参数作为一个选项传入IIFE：
13.5.3 废弃with的原因
要理解为什么要废弃with，我们来看一下下面的这个例子，看看函数的参数是如何发生巨大的变化的：
如果opts有一个msg属性，那么语句中的行（1）就不会再访问参数msg，转而访问opts的这个属性：
with语句会产生3种问题。
（1）性能问题
变量查找会变得更慢，因为对象是临时性地插入到作用域链中的。
（2）代码可能会产生不可预期的结果
仅仅通过标识符周围的上下文，你无法预知一个标识符会指向什么。据Brendan Eich的解释（http://bit.ly/ijCrTKj），这就是with被废弃的真正原因，而并非是性能上的问题：
with可能会违背当前的代码上下文，使得程序的解析（例如安全性）变得困难而繁琐。
（3）代码压缩工具（在第32章中有说明）不会压缩with语句中的变量名
在一个with语句中，你不能确定一个变量名究竟是指向一个变量还是一个属性。而对于代码压缩工具来说，只有变量可以被重命名。
下面的例子中，使用with的代码不能被压缩：
你无法阻止行（3）中的函数运行，即使你无法访问到数组myData。
那怎么办呢，你可以给Array.prototype添加一个方法，例如：
这时，行（2）就调用了someArray.values.someMethod()方法，而没有调用values.some Method()方法。这是因为在with语句中，values指向了someArray.values而非行（1）中的本地变量。
这并不是我们假设出来的例子：事实上在Firefox中，数组被添加了一个values()方法来打破TYPO3的上下文管理系统。Brandon Benvie指出了这个问题（http://mzl.la/1jCrXti）。
13.6 debugger语句
debugger语句的语法如下：
如果执行到了一个debugger语句，这个语句会报一个断点；如果执行不到，不会发生任何事情。
第14章 异常捕获
这章我们来看看JavaScript的异常捕获是怎么工作的。首先我们来看看异常捕获的概念。
14.1 什么是异常捕获
在异常捕获中，出问题的语句总是捆绑在一起的。如果你执行的语句中有一句产生了错误，那么接下来的语句就不会继续运行。因此，你就会尽可能地避免错误的产生。这难免让人联想到数据库的事务这一概念（暂且抛开其原子性不说）。
我们来看看这段没有异常捕获的代码：
如何能够最好地响应在行（2）中openFile()的错误呢？很明显，这时行（1）中的语句不会再执行。但是我们又不想终止extractAllEntries()的调用。因此，我们需要跳过目前的文件转而进行下一个的操作。这时候，我们就要对前面的代码添加异常捕获：
对于异常捕获有两个原则：如果一处出错的含义不能被描述，那么就抛错；找到一个可以捕获错误的位置，捕获异常。
在（1）处，执行的结构如下：
（1）处的throw语句遍历树和叶子上所有的结构语句，直到遇到正在执行的try语句。然后调用该语句的catch语句块，并传入异常值。
14.2 JavaScript中的异常捕获