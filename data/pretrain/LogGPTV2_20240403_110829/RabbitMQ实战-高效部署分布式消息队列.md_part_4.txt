12.3.4测试你的插件
267
12.4总结
.271
附录A在Java和.NET上使用Rabbit
.273
附录B在线资源
302
附录C在Windows上安装RabbitMQ
307
---
## Page 23
天降奇兵
本章要点
■开放协议的诉求——AMQP
■RabbitMQ简史
■安装RabbitMQ
■第一个程序—HelloWorld
我们生活在一个实时信息持续可用的世界当中。我们编写的应用程序需要以简
单的方式可靠且迅速地路由给众多的接收者。更为重要的是，我们需要找到改变信
息接收者的方式，而无须频繁地重写它们。应用程序信息经常会沦为孤岛，新的程
序如果不将原始信息的生产者重写（或者推倒重来）的话就无法对其进行访问。你
也许会自言自语：“好吧，不过消息队列或者RabbitMQ如何帮助我来解决这些问题
呢？”让我们先来反思下面的场景为何如此熟悉。
你刚刚为公司的杀手级Web应用实现了一个非常棒的认证模块。它看起来非常
不错。对于每一个页面单击，程序代码会非常高效地和认证服务器通信以确保用户
只能访问他们能够访问的页面。你有点沾沾自喜，因为公司的世界顶级牛油果分布
网站上的每一次用户单击都会触发你的代码。正在这时，老板进来和你说公司需要
---
## Page 24
2
第1章天降奇兵
记录每次成功和失败的权限尝试，以便进行数据挖掘。在你婉转地表达了这应该是
认证服务器的工作时，老板没好气地通知你，你无法访问那些数据。认证服务器将
数据以适当的格式记录下来。现在这成为你需要解决的问题。仔细思考了目前的情
况之后，你的脑袋一阵剧痛。你发现自己不得不去修改认证模块，还有可能在处理
的时候中断每个页面。毕竟，这些精彩的代码几乎涉及所有的站点访问。让我们先
设你从第一天开始就决定在设计中好好利用消息队列。
通过使用RabbitMQ，你聪明地利用消息队列解耦了模块和认证服务器。认证
模块被设计为在每一次页面请求时，发送一条认证请求消息到RabbitMQ。然后认
证服务器监听RabbitMQ队列并接收该请求消息。一旦请求被获准，认证服务器会
向RabbitMQ发送一个应答消息。RabbitMQ会将该消息路由到认证模块所监听的那
块或者重写一个。所有需要做的是编写一个简单的应用程序连接到RabbitMQ并且
订阅认证请求。无须更改任何代码。之前编写的代码都不需要知道发生了什么变更。
这太简单了，以至于你脸上露出了满意的笑容。这就是消息通信的力量！它让你的
日常工作变得如此轻松。
消息队列（message queuing）使用消息将应用程序连接起来。这些消息通过像
RabbitMQ这样的消息代理服务器在应用程序之间路由。这就像是在应用程序之间
放置一个邮局。现实的情况是，这个解决方法并不仅仅针对的是金融行业实时通信
问题，它同时也解决了我们开发人员每天要面对的问题。作为作者的我们并没有金
融服务行业的背景。当我们需要扩大应用规模的时候，我们搞不清楚什么是“企业
消息通信”。我们和你一样只是开发人员，想要解决的这个问题就是处理庞大的实
时信息，并把它们快速路由到众多的消费者。我们要在不阻塞消息生产者的情况下
做到这一点，同时也无须让生产者知道最终消费者是谁。RabbitMQ帮助我们轻松
解决这些常见问题，并用一种基于标准的方法来确保应用程序之间相互通信，而不
管应用是用Python、PHP还是Scala编写的。
在接下来的几个章节里，我们会带你做更深人的了解。我们会从解释消息队列
的工作机制、历史以及为何RabbitMQ可以满足需求开始。然后我们会带你漫步于
真实世界的案例，你可以将它们应用于自己的可扩展性和可操作性挑战。最后会教
你如何将Rabbit打造成一部运转良好的机器，“对岩机说再见！”
---
## Page 25
1.1住在别人的地下城堡
3
我们希望本书能指引你迈过消息通信的“荒野”。我们希望你能从我们的经验
和伤痕中受益，能够解放自己去创造美妙的应用程序。在结束本章之前，你会清楚
地了解消息通信简史，以及RabbitMQ的安装和运行。闲话少说，让我们看看消息
通信的起源吧。
1.1住在别人的地下城堡
消息队列的世界并非从潮湿和狭小的地下城开始，其中大多数人屈从于占据该
领地的霸主。它起源于另一处拜占庭软件景观的一缕阳光。在1983年那年，一位
来自孟买的26岁工程师脑海里浮现了一个激进的想法：为什么没有一种通用的软
件“总线”一一一种通信系统，可以解决应用程序间繁重的信息通信工作呢？来自
MIT的硬件设计教育工作者VivekRanadivé设想了一种通用软件总线，就像主板上
的总线那样，供其他应用程序接人（请查阅http://hbswk.hbs.edu/archive/1884.html）。
因此，在1983年Teknekron诞生了。手上握看崭新的哈佛MBA证书，脑袋里拥有
强大的想法，Vivek为世界各地的开发者开垦了一条捷径。
拥有美好的想法是一回事，而为它找到杀手级的应用则是另一回事。在1985
年的高盛，Ranadive找到了他的第一位客户以及软件总线天生用来解决的问题：金
融交易。当时交易员的小隔间内挤满了用来完成交易的不同终端，每台终端上显示
着不同类型的信息。Teknekron发觉这是个机会：替换掉所有那些终端和孤立的应
用程序。在交易员位置上的将会是Ranadive的软件总线。而桌上只会剩下一台工作
站。而工作站的显示程序可以作为消费者接入Teknekron软件总线，并允许交易员“订
阅”他想要看到的信息。于是发布订阅模式（PubSub）诞生了，同时还诞生了世界
上第一个现代消息队列软件：Teknekron的TheInformationBus（TIB）。
用不了多久，这种数据传输模型就找到了更多杀手级用途。最终，发布数据的
应用和消费数据的应用再也不用直接连接在一起了。它们甚至都不需要对方的存在。
Teknekron的TIB允许应用开发者建立一系列规则去描述消息内容。只要消息按照
这些规则发布出去，任何消费者应用都能订阅感兴趣的消息。现在，信息的生产者
和消费者之间可以完全解耦，并且可以在传输过程中灵活混合。PubSuib模型（生产
者/消费者）的任意一边可以完全互换而不会影响到另一边。唯一需要保持稳定的
是TIB软件以及标记和路由信息规则。由于在那个时期金融交易行业门庭若市，因
此TIB迅速传播开来。它引起了电信特别是新闻机构的注意。这些行业也特别需要
---
## Page 26
第1章天降奇兵
将信息及时发布给千变万化的客户。这也解释了为什么在1994年大型新闻机构路
透社收购了Teknekron。
与此同时，这个迅猛发展的企业软件引起了蓝色巨人的注意。毕竟IBM最大的
几位客户都来自于金融服务行业。而且，Teknekron的TIB软件通常会运行在IBM
的硬件和操作系统上。除了WhitePlains的那群孩子外所有人都从中获得了好处。
因此20世纪80年代后期，IBM开始研究开发自己的消息队列软件，运用他们在
开发DB2时信息投递的丰富经验（参见http://www-01.ibm.com/software/integration/
wmq/MQ15Anniversary.html）。开发工作起始于1990年，就在IBM的英国温切斯特
附近的Hursely公园实验室。3年之后，消息队列服务器软件IBMMQ产品系列面世。
之后的17年，MQ系列进化成了WebSphereMQ并统治着商业消息队列平台市场。
在那段时间，Ranadive的TIB并没有消失在路透社腹中。相反，它仍然是企业通信
市场的主要参与者，并且通过更名为Rendezvous而走向繁荣。在1997年Teknekron
以TIBCO的形式作为一家独立公司再度出现。同年，微软也在消息通信市场崭露
头角：微软消息队列（MSMQ）。
通过这一系列的革新，消息队列（message queuing，MQ）软件主要留住了大
型组织机构，它们需要可靠性、解耦以及实时消息通信。为什么MQ不去寻找更
大的市场呢？它是如何度过20世纪90年代末网络泡沫的呢？毕竟，从Twitter到
Salesforce.com，当今所有的这些企业都在努力创建内部方案来解决25年前TIB就
已经解决的PubSub问题。一句话：供应商壁垒。商业MQ供应商想要解决应用互
通的问题，而不是去创建标准接口来允许不同的MQ产品互通，或者（但愿不是这样）
允许应用程序来更改MQ平台。供应商壁垒维持着足够高的价格和利润率，并使得
这些商业MQ软件对那些当今繁荣昌盛的初创公司和Web2.0公司来说遥不可及。
结果，中小技术公司并不是唯一一个对高价格MQ供应商感到不满的。那些造
就MQ产业的金融服务公司对此也激动不起来。越是大型的金融公司越不可避免地
使用来自众多供应商的MQ产品，来服务企业内部的不同应用。如果应用已经订阅
了TIBCOMQ信息，若突然需要消费来自IBMMQ的消息，则实现起来会非常困
难。这些产品使用不同的API、不同的协议，因而毫无疑问无法联合起来组成单一
的总线。为了解决这个问题，Java Message Service（JMS）在2001年诞生了（请查
阅 http://en.wikipedia.org/wiki/Java_Message_Service）。JMS 试图通过提供公共 Java
1IBM总部所在地。一—译者注
---
## Page 27
1.2救世主AMQP
5
API的方式，隐藏单独MQ产品供应商提供的实际接口，从而跨越了壁垒和解决了
互通问题。从技术上讲，Java应用程序只需针对JMSAPI编程，选择合适的MQ驱
动即可。JMS会打理好其他部分的。问题是你在尝试使用单独标准化接口来胶合众
多不同的接口。这就像是把不同类型的衣服黏在一起：缝合处终究会裂开，真相会
暴露出来。使用JMS的应用程序会变得更加脆弱。我们需要新的消息通信标准化方
案。
1.2救世主AMQP
2004年，JPMorganChase需要一个更好的消息通信解决方案，并开始和iMatix
公司一起合作开发Advanced MessageQueuingProtocol（AMQP，高级消息队列协议，
参见 http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol#Development )。
AMQP从一开始就设计成为开放标准，以解决众多的消息队列需求和拓扑结构问
题。凭借开放，任何人都可以执行这一标准，针对标准编码的任何人都可以和任意
AMQP供应商提供的MQ服务器进行交互。
在很多方面，AMQP承诺把我们从厂商的“地下城”中解救出来，并且实现
Ranadivé最初的愿景：从任何发布者到任何感兴趣的消费者之间的信息，通过一条
软件总线实时动态连接起来。
1.3RabbitMQ简史
在本世纪初，一位年轻的伦敦金融部门的企业家创办了一家专门研究Java对象
缓存的公司：Metalogic。对AlexisRichardson来说，理论很简单：使用Java对象做
分布式计算，同时为了传输性能对它们进行缓存。事实上却大相径庭。不同版本的
Java虚拟机，以及客户端和服务器端不同的类库，都会使得接收到的对象不可用。
Metalogic方法论的成功之路需要面对现实世界中太多的环境变数。Metalogic促成
了Alexis和MatthiasRadestock的会面（见图1.1）。
Matthias在LShift工作，而Alexis正巧也在那里转租了一件办公室。当时
LShif正投入和一家大型软件供应商的合同，专注于语言建模和分布式计算。这些
领域方面的背景触发了Matthias对Erlang的兴趣。Erlang是Ericsson原本为了电话
交换机而开发的编程语言。引起Matthias注意的是Erlang在分布式编程和健壮的故
---
## Page 28
第1章天降奇兵
障恢复方面表现出色。可惜的是，当时Erlang不是开源的。同时，Metalogic结束了
运营，LShift的主要分布式计算合同也接近了尾声。Alexis在Metalogic的经历中学
到了非常有价值的两课：分布式计算环境的工作机制和哪些公司需要这些环境。
RabbiMQ10
项世
IBM
（TIB）开发
MQ系列面世
BM开始开发
路透社发布
OW
1983
1988
徽软MQ
MOP在
TIB被量
开始开发
图1.1消息队列简史
Alexis知道自己想要开一家新的公司去解决分布式环境下的通信问题。他也知
道他开的下一家公司将会是开源的，并且将采用JBoss和MySQL成功实践的模型。
回顾Metalogic解决方案碰到的问题，Alexis逐渐认识到消息通信才是分布式计算的
解决方案。更重要的是，2004年左右的技术领域正面临开源消息通信的空白。除了
商业供应商外，没有人提供消息通信的解决方案。“企业”开源在数据库（MySQL）
和应用服务器方面（JBoSS）热火朝天，但却没有人去触碰消息通信那片空白。有
趣的是：就在2004年，在JPMorganChase，AMQP正开始开发。因为在金融行业
的背景，Alexis被引l荐给了在JPMorgan的AMQP主要驱动者JohnO'Hara（将来
的AMQP工作组创始人）。通过O'Hara，Alexis接触到了AMQP，并开始着手构建
RabbitMQ。
在2005年左右，Alexis创办了CohesiveFT。他和他的合伙人在美国开办了公司，
提供应用栈和工具，在今天逐渐成为云计算。对Alexis来说，应用栈的最关键部
---
## Page 29
1.3RabbitMQ简史
7
分是分布式消息通信。他（仍然在LShift那里办公）开始找Matthias探讨AMQP。
Matthias清楚他已经找到了想要用Erlang实现的应用。但在动手之前，Alexis和
Matthias聚焦在三个向题上。这三个问题是决定了用Erlang实现的AMQP开源版本
能否成功的关键：
（1）那些大型金融机构是否会在意他们的消息代理服务器是用Erlang语言编写
的？
（2）Erlang语言是否真的是编写AMQP服务器的最佳选择？
（3）如果采用Erlang语言编写的话，是否会影响开源社区对它的采纳？
第一个问题立马就被一家金融公司解决了：他们不在乎软件是用什么语言编写
的，只要它能够帮助减少集成上的花费即可。第二个问题由就职于ErlangSolutions
的FrancescoCesarini回答：从他对AMQP的分析来看，这份规格说明展现的就是
每一部电话交换机的架构。换句话说，你无法找到比Erlang更好的实现语言来构造
AMQP代理服务器。最后一个问题则是被完全不同的消息通信服务器ejabberd解决
了。直到2005 年，Extensible Messaging and Presence Protocol（XMPP）已经逐渐成
为受人尊敬的开放即时通信标准，并且首选的实现就是AlexeyShchepin编写的基子
Erlang 的ejabberd 服务器包。ejabberd 被广泛地使用在众多不同的组织机构里。它
是由Erlang实现的这一点似乎并未阻挡其流行的步伐。
通过解决这三个主要的问题，Alexis和Matthias说服了CohesiveFT和LShift共
同支持这个项目。他们首先做的是签约了MatthewSackman（他现在是Rabbit核心
开发人员），让他用Erlang写了一个原型测试网络延迟。他们很快就发现用Erlang
编写的分布式计算库有着和原生socket一样的延迟，简直不可思议。他们对名称
很快有了共识：所有人都认可Rabbit这个名字。毕竟，兔子是行动非常迅速的动
物而且繁殖起来也非常疯狂，把它用于分布式软件的命名再合适不过了。至少选择
Rabbit这个名字也便于记忆。因此在2006年，RabbitTechnologies诞生了：一家由
CohesiveFT和LShift的合资企业，其拥有着RabbitMQ的知识产权。
时机总是如此的恰到好处，就在当时，AMQP规范的第一份公开草案也公之于
世了。作为一份新的规范，AMQP正快速修订。这正是Erlang可以施展拳脚的地方。
通过使用Erlang，RabbitMQ可以快速开发并跟上AMQP标准前进的节奏。令人惊
讶的是，核心开发人员TonyGarnock-Jones仅仅用了两个半月的时间就将RabbitMQ
---
## Page 30
8
第1章天降奇兵
1.0版本开发完成了。最初，RabbitMQ实现了AMQP的一个关键特性，使其有别
于TIBCO和IBM：使用协议本身就可以对像队列和交换器这样的资源进行配置。
对商业供应商来说，资源配置需要通过特定的管理终端的特定工具才可以完成。
RabbitMQ的资源配置能力使其成为构建分布式应用的最完美的通信总线，特别有
助于充分利用基于云的资源和快速开发。
就这样一直到今天，RabbitMQ广泛使用在小到硅谷的初创公司，大到互联网
巨头。对RabbitMQ来说，那也许是最好的事了，创始人感到非常惊讶：Rabbit的
客户主要是技术公司而并非金融公司。对于那些只有少量预算同时也要解决消息通
信的人来说，RabbitMQ实现了Ranadivé的愿景。那正是RabbitMQ吸引我们的地方。
我们并不知道自己是在找寻消息队列软件。我们知道的是自已需要解决应用集成和
高强度事务处理负载的问题。RabbitMQ为我们提供了一个强大的工具来解决那些
问题，并给我们带来了一段丰富的消息通信历史，以及适合所有人的可拔插的信息
总线。
1.4百里挑一