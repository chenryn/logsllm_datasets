    end
    end
    c = C.new
    p c.meth        #=> C#meth
    ```
- 在同一个类中包含多个模块时，优先使用最后一个包含的模块。
    ```ruby
    module M1
    ┊
    end
    module M2
    ┊
    end
    class C
    include M1        #=> 包含M1
    include M2        #=> 包含M2
    end
    p C.ancestors       #=> [C, M2, M1, Object, Kernel]
    ```
- 嵌套 `include` 时，查找顺序也是线性的。
    ```ruby
    module M1
    ┊
    end
    module M2
    ┊
    end
    module M3
    include M2        #=> 包含M2
    end
    class C
    include M1        #=> 包含M1
    include M3        #=> 包含M3
    end
    p C.ancestors       #=> [C, M3, M2, M1, Object, Kernel]
    ```
- 相同的模块被包含两次以上时，第 2 次以后的会被省略。
    ```ruby
    module M1
    ┊
    end
    module M2
    ┊
    end
    class C
    include M1        #=> 包含M1
    include M2        #=> 包含M2
    include M1        #=> 包含M1
    end
    p C.ancestors       #=> [C, M2, M1, Object, Kernel, BasicObject]
    ```
**extend 方法**
利用 `Object#extend` 方法，我们可以实现批量定义单例方法。`extend` 方法可以使单例类包含模块，并把模块的功能扩展到对象中。
```ruby
module Edition
  def edition(n)
    "#{self} 第#{n} 版"
  end
end
str = "Ruby 基础教程"
str.extend(Edition)     #=> 将模块Mix-in 进对象
p str.edition(4)        #=> "Ruby 基础教程第4 版"
```
`include` 可以帮助我们突破继承的限制，通过模块扩展类的功能；而 `extend` 则可以帮助我们跨过类，直接通过模块扩展对象的功能。
**类与 Mix-in**
在 Ruby 中，所有类本身都是 `Class` 类的对象。我们之前也介绍过接收者为类本身的方法就是类方法。也就是说，类方法就是类对象的实例方法。我们可以把类方法理解为：
- Class 类的实例方法
- 类对象的单例方法
继承类后，这些方法就会作为类方法被子类继承。对子类定义单例方法，实际上也就是定义新的类方法。
除了之前介绍的定义类方法的语法外，使用 `extend` 方法也同样能为类对象追加类方法。下面是使用 `extend` 方法追加类方法，并使用 `include` 方法追加实例方法的一个例子。
```ruby
module ClassMethods    # 定义类方法的模块
  def cmethod
    "class method"
  end
end
module InstanceMethods # 定义实例方法的模块
  def imethod
    "instance method"
  end
end
class MyClass
  # 使用extend 方法定义类方法
  extend ClassMethods
  # 使用include 定义实例方法
  include InstanceMethods
end
p MyClass.cmethod        #=> "class method"
p Myclass.new.imethod    #=> "instance method"
```
> 在 Ruby 中，所有方法的执行，都需要通过作为接收者的某个对象的调用。换句话说，Ruby 的方法（包括单例方法）都一定属于某个类，并且作为接收者对象的实例方法被程序调用。从这个角度来说，人们只是为了便于识别接收者的类型，才分别使用了“实例方法”和 “类方法”这样的说法。
# 面向对象程序设计
“面向对象”这个概念，被广泛地应用在问题分析、系统设计或程序设计等系统和程序开发领域中。虽然这个概念目前被用在了各种各样的领域中，但首先使用这个概念的是与程序设计相关的领域。
由于本书是程序设计语言的入门书，因此这里并不会向其他领域过多延伸，而只会介绍与程序设计语言（当然就是 Ruby 了）相关的对象和面向对象方面的基础知识。
下面，我们暂且不讨论具体如何编写程序，而是先来了解一下编写程序时的一些思考方法。
**对象是什么**
包括 Ruby 在内，世界上有多种面向对象的程序设计语言。不同的语言，不仅语法不一样，功能也千差万别，但它们几乎都有一个共通点，就是将程序处理的主体作为“对象”来考虑。
一般情况下，程序语言的处理主体是数据。之前提到的数值、字符串、数组等都是简单的数据。
而面向对象的语言中的“对象”就是指数据（或者说数据的集合）及操作该数据的方法的组合。之前我们提到过 Ruby 里的数值 3.14 是 `Float` 类的实例。这个 3.14 不仅是表示 3.14 这个数值的数据，还包括与数值相关的操作方法。
```ruby
f = 3.14
p f.round   #=> 3 （四舍五入）
p f.ceil    #=> 4 （进位）
p f.to_i    #=> 3 （整数变换）
```
像这样，把数据以及处理数据的操作方法作为对象合并在一起贯穿整体，在面向对象程序设计中是很常见的。例如，将浮点数做四舍五入处理的 `round` 方法是可以被作为 `Float` 类的一部分来提供的，这样一来，数据以及处理数据的方法的组合也不会出现错误。
如果只是简单的数值处理，并不会有太大的问题，但大部分程序都需要更复杂的数据构成。例如，在一个处理图片的程序中，图片的长宽、颜色、包括图片本身的内容都需要转换为二进制数据。如果能把一个图片作为一个零部件来处理，那么像图册这样复杂的应用程序也就变得容易编写了
在开发大型程序的时候，若不将大量的数据整合到一起并根据一定的规则进行整理，程序处理本身的统一性会荡然无存。面向对象程序设计会把这种归类统一的数据作为各种各样的对象来看待。在对象中，数据以及处理数据的方法也是成套存在的，而且还负有处理数据的责任。
另外，就像网络上的服务器管理的文件一样，远程数据也可以作为程序的处理对象来考虑。在网络程序设计里，Web、邮件等不同的应用程序，都需要遵守各自不同的规范（也称为协议）。用程序来实现协议的情况下，一般会把管理消息格式、规范等的程序抽象成库（library）。Ruby 的库里就有现成的 `Net::HTTP`、`Net::POP` 等类，可以非常轻松地编写网络程序。
**面向对象的特征**
- 封装
    所谓封装（encapsulation），就是指使对象管理的数据不能直接从外部进行操作，数据的更新、查询等操作都必须通过调用对象的方法来完成。通过封装，可以防止因把非法数据设置给对象而使程序产生异常的情况发生。
    为此，就需要编写不会让对象内部产生异常的方法。最理想的做法是，在定义方法时就考虑如何避免错误的发生，而不是在使用方法编写程序时才开始注意。
    Ruby 对象在默认情况下是强制被封装的，因此无法从外部直接访问 Ruby 对象的实例变量。虽然有像 `attr_accessor` 这样简单定义访问级别的方法，但也不要过度使用，建议只在需要公开时才使用。
    封装的另外一个好处就是，可以隐藏对象内部数据处理的具体细节，把内部逻辑抽象地表现出来。例如，通过使用 `Time` 类，就可以进行从系统获取当前时间、从时间里提取年月日等操作。
    ```ruby
    t = Time.now    # 从系统获取当前时间
    p t.year        #=> 2013（从时间里提取年）
    ```
    从系统获取当前时间时是如何处理的、`Time` 对象内部是以什么形式管理时间的、以及从时间中提取年时要进行何种运算等等，以上这些事情都由 `Time` 类的方法来实现。就算对象内部的数据结构改变了，只要公开给外部的方法名、功能等没有改变，类的使用者就完全不需要理会内部逻辑作出了怎样的修改，照常使用即可。相反，类的编写者只要提供的方法恰当，就可以直接修改类的内部逻辑，而不需要在意类的使用者。可见，封装对类的编写者和使用者来说都非常有好处。
- 多态
    对象是数据及其处理的组合。对象知道数据是怎样被处理的。换句话说，各个对象都有自己独有的消息解释权。一个方法名属于多个对象（不同对象的处理结果也不一样）这种现象，用面向对象的术语来说，就是多态（polymorphism）。
    例如，我们可以观察一下对 `Object` 类、`String` 类和 `Float` 类的各对象调用 `to_s` 方法的运行结果，可以看出，不同的类得到的结果是不一样的。
    ```ruby
    obj = Object.new    # 对象（Object）
    str = "Ruby"        # 字符串（String）
    num = Math::PI      # 数值（Float）
    p obj.to_s          #=> "#"
    p str.to_s          #=> "Ruby"
    p num.to_s          #=> "3.141592653589793"
    ```
    三者的 `to_s` 方法名一样，含义也都是“以可以显示的形式把数据转换为字符串”，但实际的字符串转换方式却因对象而异。`String` 类和 `Float` 类都是继承自 `Object` 类，也都重新定义了从 `Object` 类继承的 `to_s` 方法，并提供了更适合自己语义的 `to_s` 方法。
**鸭子类型**
下面，我们来看一种结合对象特征，灵活运用多态的思考方法——鸭子类型（duck typing）。鸭子类型的说法来自于“能像鸭子那样走路，能像鸭子一样啼叫的，那一定就是鸭子”这句话。这句话的意思是，对象的特征并不是由其种类（类及其继承关系）决定的，而是由对象本身具有什么样的行为（拥有什么方法）决定的。例如，假设我们希望从字符串数组中取出元素，并将字母转换成小写后返回结果。
```ruby
def fetch_and_downcase(ary, index)
  if str = ary[index]
    return str.downcase
  end
end
ary = ["Boo", "Foo", "Woo"]
p fetch_and_downcase(ary, 1)  #=> "foo"
```
实际上，除了数组外，我们也可以像下面那样，把散列传给该方法处理。
```ruby
hash = {0 => "Boo", 1 => "Foo", 2 => "Woo"}
p fetch_and_downcase(hash, 1)  #=> "foo"
```
`fetch_and_downcase` 方法对传进来的参数只有两个要求：
- 能以 `ary[index]` 形式获取元素
- 获取的元素可以执行 `downcase` 方法
只要参数符合这两个要求，`fetch_and_downcase` 方法并不关心传进来的到底是数组还是散列。
Ruby 中的变量没有限制类型，所以不会出现不是某个特定的类的对象，就不能给变量赋值的情况。因此，在程序开始运行之前，我们都无法知道变量指定的对象的方法调用是否正确。
这样的做法有个缺点，就是增加了程序运行前检查错误的难度。但是，从另外一个角度来看，则可以非常简单地使没有明确继承关系的对象之间的处理变得通用。只要能执行相同的操作，我们并不介意执行者是否一样；相反，虽然实际上是不同的执行者，但通过定义相同名称的方法，也可以实现处理通用化。这就是鸭子类型思考问题的方法。
利用鸭子类型实现处理通用化，并不要求对象之间有明确的继承关系，因此，要想灵活运用，可能还需要花不少功夫。例如刚才介绍的 `obj[index]` 的形式，就被众多的类作为访问内部元素的手段而使用。刚开始时，我们可以先有意识地留意这种简单易懂的方法，然后再由浅入深，慢慢地就可以抓住窍门了。
**面向对象的例子**
接下来让我们通过一个实际的例子，来看看对象是如何被构造的。
利用 `Net::HTTP` 类取得 Ruby 官网首页的 HTML，并将其输出到控制台的脚本。
```ruby
require "net/http"
require "uri"
url = URI.parse("http://www.ruby-lang.org/ja/")
http = Net::HTTP.start(url.host, url.port)
doc = http.get(url.path)
puts doc
```
程序的第 1、2 行中引用了 `net/http` 库以及 `uri` 库。这样，我们就可以使用 `Net::HTTP` 类和 `URI` 模块了。第 3 行使用了 `URI` 模块的 `parse` 方法来解析 `URL` 的字符串，返回的结果是字符串解析后的 `URI::HTTP` 类的对象。根据 `URL` 的编写规则，`URL` 会被分解成多个属性。
```ruby
require "uri"
url = URI.parse("http://www.ruby-lang.org/ja/")
p url.scheme    #=> "http"                 （体系：URL 的种类）
p url.host      #=> "www.ruby-lang.org"    （主机名）
p url.port      #=> "80"                   （端口号）
p url.path      #=> "/ja/"                 （路径）
p url.to_s      #=> "http://www.ruby-lang.org/ja/"
```
体系（scheme）是指使用哪种通信协议。连接网络上的服务器时，需要知道服务器的主机名以及端口号。路径用于定位服务器上管理的文件。`URI::HTTP` 类的作用就是，把 URL 字符串解析后分解出来的信息，以对象的形式再次整合在一起。
需要注意的是，模块名是 `URI` 而不是 `URL`。URL 指的是 URI 标识符中某种特定种类的东西。关于两者的关系，这里不再详细介绍，现阶段我们只需要知道 URL 是 URI 的一种就可以了。
在程序第 4 行，把主机名和端口号传给 `Net::HTTP` 类的 `start` 方法，并创建 `Net::HTTP` 对象。在程序第 5 行，对 `Net::HTTP` 的 `get` 方法指定路径，获取文档内容。最后，在程序第 6 行，把得到的文档内容输出到控制台。由于得到的文档内容是 `String` 对象，因此后续处理与 `Net::HTTP` 类没有关系。
调用 `Net::HTTP#get` 方法的时候，对象内部会做以下处理：
1. 使用主机名和端口号，与服务器建立通信（叫做 socket，套接字）
2. 使用路径，创建代表请求信息的 `Net::HTTPRequest` 对象
3. 对套接字写入请求信息
4. 从套接字中读取数据，并将其保存到代表响应信息的 `Net::HTTPResponse` 对象中
5. 利用 `Net::HTTPResponse` 本身提供的功能，解析响应信息，提取文档部分并返回。
流程图如下所示。
在这个例子中，URL 解析由 `URI::HTTP` 负责，网络连接由套接字负责，与信息交换相关的操作由 `Net::HTTPRequest` 和 `Net::HTTPResponse` 负责，通信中必要的套接字、请求、响应等相关操作由 `Net::HTTP` 负责。像这样，不同的对象各司其职，决定应该如何配置参数、该执行什么样的处理等事项。
这些事项不仅在新建程序时有用，在扩展、修改已有程序时也非常有用。对象之间通过方法交换信息，而至于这些信息在彼此内部是如何被处理的，则并不需要关心。在生成类时，我们只要牢记把适当的信息交给适当的方法处理，就可以设计出易于读写的程序。
重要的是如何自然地写出程序 这除了需要丰富的程序设计经验外，还需要拥有设计模式等类结构相关的知识。“自然”这样的说法可能有点夸张，但通过指把事物的外部特征作为参考依据，我们就可以使用与实际事物相近的模型去组织、构建程序。