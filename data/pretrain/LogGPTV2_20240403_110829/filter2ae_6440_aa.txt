**译者：知道创宇404实验室翻译组**  
**原文链接：**
## 前言
2020年7月，NVISO检测到一组恶意Excel文档，也称为“
maldocs”，它们通过VBA激活的电子表格传递恶意软件。尽管我们曾见过恶意的VBA代码和掉落的有效载荷，但创建Excel文档本身的特定方式引起了我们的注意。
恶意Excel文档的创建者使用了一种技术，使他们无需实际使用Microsoft
Office即可创建装载宏的Excel工作簿。但是在这种特定工作方式下，这些文档的检测率通常低于标准maldocs。
这篇文章概述了这些恶意文档的产生方式。此外，它简要描述了观察到的有效负载，最后以建议和危害指标结尾，以帮助保护组织免受此类攻击。
## 主要发现
恶意的Microsoft Office文档是使用EPPlus软件而不是Microsoft Office
Excel创建的，这些文档可能与典型的Excel文档不同，所以可能会受到关注。
NVISO基于上载到VirusTotal等服务的有限数量的文件，以及整个活动中有效载荷传递的相似性，以中等可信度评估该活动，这是由单个攻击者执行的。
直到这篇文章发布之日为止，观察到的有效负载在大多数情况下都是所谓的信息窃取者，他们的目的是从浏览器，电子邮件客户端等中获取密码。
这些文件中产生的有效载荷仅在混淆和伪装方面有所发展。
## 分析
下面的分析部分分为两个部分，涉及感染链中的特定链接。
#### 恶意文件分析
在较早的文章中，我们写了有关“ VBA清除” [[1]](https://blog.nviso.eu/2020/02/25/evidence-of-vba-purging-found-in-malicious-documents/
"\[1\]")的技术，该技术可从VBA项目中删除已编译的VBA代码。我们很想知道是否有在野外发现的恶意文件正在采用这种技术（它降低了防病毒产品的初始检测率）。
最初，我们认为它们是使用Excel创建的，然后被VBA清除。但是仔细研究，我们发现，这些文档是使用.NET库创建的，该库创建了Office Open
XML（OOXML）电子表格。如我们的VBA清除博客文章所述，使用完全独立于Microsoft
Office的工具创建Office文档时，它们也可能缺少已编译的VBA代码。EPPlus是这样的工具。我们对这个.NET库很熟悉，因为几年来一直在使用它来为我们的红色团队和渗透测试人员创建恶意文档（“
maldocs”）。
当我们注意到maldocs没有经过编译的代码，并且也缺少Office元数据时，我们很快想到了EPPlus。该库还将创建OOXML文件，而无需编译VBA代码和Office元数据。
OOXML文件格式是一种开放包装约定（OPC）格式：一种ZIP容器，主要包含XML文件，可能还包含二进制文件（如图片）。它是由Microsoft在Office
2007发行版中首次引入的。OOXML电子表格使用扩展名.xlsx和.xlsm（用于带有宏的电子表格）。
使用EPPlus创建VBA项目时，它不包含已编译的VBA代码。EPPlus没有创建编译代码的方法：创建编译VBA代码的算法是Microsoft专有的。
我们检测到的第一个恶意文档是在2020年6月22日创建的，从那时起，我们在2个月的时间里发现了200多个恶意文档。在过去的几周里，攻击者增加了他们的活动，现在我们有时会看到10多个新的恶意文档。
图1-每天观察到的独特的maldocs。
在两个月的时间内发现的maldocs具有许多与Microsoft
Office创建的文档的属性完全不同的属性。我们认为是这是因为它们是使用独立于Microsoft
Excel的工具创建的。尽管我们没有攻击者用来创建这些恶意文档的确切工具的副本，但此工具创建的恶意文档具有许多属性，这些属性使我们确信它们是使用上述EPPlus软件创建的。
EPPlus的某些属性包括但不限于：
  * 功能强大且用途广泛的库：它不仅可以创建包含VBA项目的电子表格，而且还可以对该项目进行密码保护和/或数字签名。它不依赖Microsoft Office。它也可以在Mono（跨平台，开源.NET）上运行。
  * 用EPPlus创建的OOXML文件具有一些属性，可将它们与用Excel创建的OOXML文件区分开。这里是一个概述：
ZIP日期：ZIP文件中包含的每个文件都有一个时间戳（ZIPFILE记录中的DOSDATE和DOSTIME字段）。对于使用Microsoft
Office创建（或编辑）的文档，此时间戳始终为1980-01-01
00:00:00（DOSDATE为0x0021，DOSTIME为0x0000）。使用EPPlus创建的OOXML文件具有与文档创建时间相对应的时间戳。通常，OOXML文件中的所有文件的时间戳都是相同的，但是由于执行延迟，时间戳之间可能相差2秒。2秒是DOSTIME格式的分辨率。
图2 – DOSTIME差异（左：EPPlus创建的文件）
  * 额外的ZIP记录：一个典型的ZIP文件由ZIP文件记录（magic 50 4B 03 04）和（压缩）文件内容组成。然后是ZIP目录条目（magic 50 4B 01 02），后面是一个ZIP结束的目录记录（magic 50 4B 05 06）。Microsoft Office创建包含这3种ZIP记录类型的OOXML文件。EPPlus创建包含4个ZIP记录的OOXML文件：在每个ZIP文件记录之后还包括一个ZIP数据描述记录（magic504b0708）。
图3 –额外的ZIP记录（左：EPPlus创建的文件）
  * 缺少Office文档元数据：使用Microsoft Office创建的OOXML文档包含元数据（作者，标题等）。此元数据存储在docProps文件夹中的XML文件中。默认情况下，使用EPPlus创建的文档没有元数据：ZIP容器内没有docProps文件夹。
图4 –缺少元数据（左：EPPlus创建的文件）。
  * 已清除VBA：具有通过Microsoft Office创建的VBA项目的OOXML文件包含OLE文件（vbaProject.bin），该文件的流包含已编译的VBA代码和已压缩的VBA源代码。使用EPPlus创建的文档不包含已编译的VBA代码，而仅包含压缩的VBA源代码。这意味着： 模块流仅包含压缩的VBA代码。
没有SRP流（SRP流包含特定于实现和版本的编译代码，其名称以__SRP_开头）。
_VBA_PROJECT流不包含已编译的VBA代码。实际上，_VBA_PROJECT流的内容被硬编码在EPPlus源代码中：始终为CC 61 FF FF
00 00 00。
图5 –硬编码的流内容（左：EPPlus创建的文件）。
除上述内容外，我们还观察到了VBA源代码的某些属性，这些属性提示使用基于EPPlus之类的库的创建工具。
actor使用的VBA源代码有两个变体（一些变体使用PowerShell来下载有效负载，其他变体使用纯VBA代码）。但是所有这些变体都包含一个调用程序，该调用程序具有一个参数，即带有URL的字符串（BASE64或十六进制编码）。像这样（十六进制示例）：`Loader"68
74 74 70…"`
请注意，函数名称和参数之间没有空格字符：Loader与“ 68 74 74 70…”之间没有空格。
这表明VBA代码不是通过Office中的VBA EDI输入的：当输入这样的语句时，如果没有空格字符，VBA
EDI会自动为您添加一个空格字符（即使您复制/粘贴该代码也是如此）。
缺少此空格字符说明该代码不是通过VBA EDI输入的，而是可能通过EPPlus之类的库输入的。
为了说明这些属性上的差异，我们使用EPPlus库使用内部工具之一（ExcelVBA）显示示例。我们使用工具ExcelVBA在文本文件vba.txt中用vba代码创建vba.xlsm文件，并显示其某些属性：
图6 – NVISO使用EPPlus库创建的XLSM文件。
图7 –运行oledump.py显示该文档是使用EPPlus库创建的。
一些恶意文档包含使用EPPlus Wiki上的示例代码清楚地由EPPlus创建的对象。我们通过以下示例（此广告系列中的第一个文档）进行说明：
**文件名** ：扫描顺序列表.xlsm  
**MD5** ：8857fae198acd87f7581c7ef7227c34d  
**SHA256** :8a863b5f154e1ddba695453fdd0f5b83d9d555bae6cf377963c9009c9fa6c9be  
**文件大小** ：5.77 KB（5911字节）  
**最早内容修改** ： 2020-0646
本文档包含一个具有以下名称的drawing1.xml对象（圆角矩形）：`name =" VBASampleRect"。`
图8 – maldoc的zipdump。
图9 –选择drawing1.xml对象显示名称。
这是使用EPPlus Wiki [[2]](https://github.com/EPPlusSoftware/EPPlus/wiki/VBA
"\[2\]")上的示例代码创建的：
图10 – EPPlus示例代码，清楚地显示了相似之处。
值得注意的是，我们观察到的所有恶意文档的VBA项目均受密码保护。有趣的是，VBA代码本身未经编码/加密，而是以明文形式存储（尽管经过压缩）[[3]](https://blog.didierstevens.com/2020/07/20/cracking-vba-project-passwords/
"\[3\]")。当打开具有受密码保护的VBA项目的文档时，VBA宏将在没有密码的情况下执行：用户不需要提供密码。仅在VBA