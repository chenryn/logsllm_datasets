response = conn.getresponse()
回critical状态
if.response.status > 299:
print "cRITICAL:Broker not alive:%s" response.read()
exit(EXIT_CRITICAL)
8RabbitMQ正常运
print "oK:Broker alive:%s"% response.read()
行，返回OK状态
exit(EXIT_OK)
就像在AMQP健康检测中做的那样，首要任务是为退出代码设置常量·，并
解析命令行参数?。该健康检测程序接收和AMQP健康检测程序一样的参数，并
对API服务器的server和port 做了相应的更改（替换了RabbitMQ服务器的配置）。
和AMQP健康检测程序完全不同的地方是，你构建一条到API服务器的HTTP
连接③，而不是AMQP连接。在构建好了到API服务器的HTTP连接后，你为
aliveness-test创建了请求路径4。你将vhost附加在路径的结尾处，用于创建
测试队列。由于可能会有名为“”（HTTP路径分隔符）的vhost，因此你需要在添
---
## Page 217
10.1监控RabbitMQ：密切关注你的warren
195
加到路径之前，使用urllib.quote对vhost进行转义。这里的safe=""参数告
诉urllib.quote方法需要无一例外地转义所有特殊字符（默认情况下，urllib，
quote 不会转义“/”字符）。同时,因为你通过 API来获取信息,而非修改或者创建，
所以此处将请求方法设定为GET。
在创建厂HTTP连接和请求路径之后，你准备好了编码凭证S并将请求发送
到API服务器。如果无法连接上API服务器6的话，程序将返回EXIT_CRITICAI
作为状态退出代码。由于从技术上来讲，你只知道是API服务器宕机了而不是
RabbitMQ服务器，所以可以返回warning或者unknown状态。但是由于API是
RabbitMQ的一个插件，所以不太可能API服务器岩机了而RabbitMQ服务器没有。
假设你能连接上API服务器并发送请求，你会接收到一个响应对象。响应对
象将HTTP状态码存储在response.status中，并且可以像访问文件描述符那样
通过response.read（）来访问响应内容。你最关心的就是HTTP状态码了。如
果aliveness-test方法调用成功的话，它会返回200的HTTP状态码。任何高
于299的代码要么代表错误，要么就是发送给客户端的额外指令。因此，如果你收
到了大于299的HTTP状态码7的话，你可以返回critical状态（EXIT_CRITICAL）
给Nagios，用于表明健康检测失败了。否则，方法调用成功，并且服务器工作正常
⑧。由于成功调用返回的正文内容是简单的JSON格式字串{'status’：'ok'（你
熟悉的HTTP状态码之一），因此你可以忽略它，也可以将其附加到响应中去。
那么，如果针对本地开发机器运行APIping健康检测的话会如何呢？
>python api_ping_check.py 1ocalhost:55672/ guest guest
OK:Brokeralive:("status":"ok")
>echo$?
0
健康检测程序正确检测出RabbitMQ服务器正常运行，并且能够生产和消费消
息。但是，如果我们模拟节点故障来响应健康检查的话会发生什么呢？
> rabbitmqctl -n rabbit@Phantome stop_app
Stopping node rabbit@Phantome ...
...done.
>python api_ping_check.py localhost:55672/ guest guest
CRITICAL: Broker not alive: 500 Internal
Server ErrorInternal Server ErrorThe
1在第9章RESTAPI的介绍中有针对如何构造HTTPBasic认证头的详细介绍。
---
## Page 218
196
第10章监控
server encountered an error while processing this request:
{exit,{aborted,{no_exists,[rabbit_user,>]}},
[(mnesia,abort,l},
{rabbit_misc,dirty_read,l},
(rabbit_auth_backend_internal,internal_check_user_login,2},
{rabbit_access_control,'-check_user_login/2-fun-0-',4},
{lists,foldl,3},
{rabbit_mgmt_util,is_authorized,3},
{webmachine_resource,resource_call,3},
{webmachine_resource,do,3}] }
mochiweb+webmachine
webserver
> echo $?.
2
喔，一大堆输出。虽然Nagios只会读取退出代码（2）来判定健康检测是否失败，
但是它会将生成的告警内容包括从CRITICAL：.··到·：.全部发送给你。
aliveness-test调用返回的内容，以及健康检测程序逐字输出的内容，都是因为
API无法和RabbitMQ进行通信而生成的内部Erlang崩溃报告。因此，如果有人关
闭了RabbitMQ节点，则不仅监控系统能够及时通知你，同时它也会给你一份详细
的Erlang崩溃报告，你可以用它来追踪为何Rabbit会发生这样的问题。
现在你不仅有能力监控RabbitMQ是否能接收连接，同时也能检测它是否能成
功路由消息。但是如果有人将队列的持久化属性修改为非持久化，从而更容易遭受
消息丢失的话，你该怎么办呢？你如何保护Rabbit配置免遭危险的修改？要知道，
这样的修改通过普通的RabbitMQ服务器健康检测是无法察觉到的。不过这也很简
单：只要编写一个能够监控队列（或者交换器）配置的健康检测即可。
10.1.4监控配置文件修改
验证RabbitMQ健康运行只是确保消息通信架构可靠性的一部分。同时，你也
需要确保消息通信结构配置没有遭受意外修改，从而避免应用消息丢失。举例来
说，想象一下努力工作的开发人员Rolf正在部署遛狗应用的最新版本。由于你明智
地编写了应用来配置所需的队列、交换器和绑定，所以你不必担心由于RabbitMQ
服务器缺失了消息通信结构中的一部分，会在启动时（应用会创建丢失的部分）崩
溃。但是今天早上这份通信结构自动化配置引发了问题，这是因为昨晚Rolf解决了
DogWalker10.0最后一个bug而工作到很晚，并且不小心犯了个错误。不凑巧的是，
Rolf将应用启动时创建walking_orders队列的代码删除了。在发现了这个问题
---
## Page 219
10.1监控RabbitMQ：密切关注你的warren
197
之后，他在将代码提交到产品代码库之
前，重新添加了队列声明。问题在于当
设置
Rolf重新编写队列声明时，他忘记将队
可持久化
自动删除
列设置为可持久化了。这可是个大问题，
Q1
因为在生产环境中如果RabbitMQ服务器
RabbitMQ
节点
遇到了供电故障的话，所有队列上的遛
狗订单就都消失不见了。但是由于该队
通过RabbitMQAPI监控
列确实存在并且名称也是对的，因而你
不会发现任何问题，直到供电故障时则
为时已晚。由于我们总是会成为Rolf这
设置
设置
样的人，因此你需要创建健康检测来监
可持久化
可持久化
自动删除
非自动删除
控队列配置，在队列发生变化时你能主
买际
期望
动收到通知。来看看图10.1吧。
认列配置
健康检测
在RabbitManagement插件和API以
前，我们很难对队列（或者交换器）的
配置进行监控。唯一你可以验证队列配
告警！
置的方式是，尝试用对应的参数来重新
声明队列，并且相信RabbitMQ会在声明
图10.1队列配置健康检测
的配置与现存队列的配置不同时加以拒
绝。该方法的最大问题在于，由于是通
过声明队列的方式来检测故障，所以会主动更改消息通信结构。换句话说，如果健
康检测有bug的话，它可能就会碰巧更改了队列的配置。幸运的是，通过使用现成
的RabbitMQAPI，你有了更好的解决方案。
RabbitManagementAPI提供了一个方法允许你查看任何vhost上的任何队列：
/api/queues//。你不仅可以查看配置详情，也可以查看队列的
数据统计，例如队列消耗的内存，或者队列的平均消息通信吞吐量。在下列清单中，
让我们使用curl来快速查看在“”vhost（注意“”在URL中会被编码为%2F）
上样本队列my_queue的配置和状态。
---
## Page 220
198
第10章监控
清单10.4：/api/queues//curl输出
$curl-i-uguest:guesthttp://1ocalhost:55672/api/queues/$2F/my_queue
HTTP/1.1 200 OK
Server:MochiWeb/1.1 WebMachine/1.7(participate in the frantic)
Date:Tue,16 Aug 2011 23:25:14GMT
Content-Type:application/json
Content-Length:670
Cache-Control:no-cache
1队列内存使用
"memory":8400,
"idle_since":"2011-8-16 17:24:46",
"exclusive_consumer_pid":"",
"exclusive_consumer_tag":"",
"messages_ready":0,
2消息计数
"messages_unacknowledged":0,
"messages":0,
"consumers":0,
"backing_queue_status":
"q1":0,
"name":"my_queue",
"vhost":"/",
"durable":true,
 299:
print "UNKNOwN: Unexpected API error: %s" %\
②返回unknown代码
response.read()
解析API3
exit(EXIT_UNKNOWN)
4队列的auto_delete
标记不正确，返回