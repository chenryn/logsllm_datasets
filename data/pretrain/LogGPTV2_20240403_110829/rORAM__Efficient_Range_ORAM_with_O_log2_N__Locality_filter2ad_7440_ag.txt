improvement is achieved by observing that an access for a
range of length r consists of essentially three stages:
1) 2 position map accesses in the target ORAM tree
2) 2 range-r read operations in the target ORAM tree
3) r batch evictions in each of the O(log N ) ORAM trees.
Step 2 already incurs only O(log N ) seeks which ﬁts the
bound stated above. For Step 3, roughly (log N )/k ORAM
trees are stored on each of the k disks which allows for batch
evictions to occur in parallel, meeting the stating bound.
The position map access (Step 1) is more challenging
due to the recursion which must occur sequentially because
the path to access in the next smaller recursive ORAM is
only revealed once the path in the larger ORAM has been
accessed, leading to O(log2 N ) seeks. However, retrieving
each of the buckets along the path is deterministic and can
be completed using parallel seeks by distributing the levels of
the recursive ORAMs across k disks. Fetching a single path
at a single recursive level incurs O((log N )/k) parallel seeks,
and repeating this sequentially for each of the recursive levels
gives the cost stated above.
13
B. Reducing position map costs
Parallel seeks can improve the performance of the position
map, but there are other optimizations for decreasing the cost
of the position map and increasing the overall performance of
the rORAM if we consider larger client storage scenarios.
O(log N ) seeks with larger block sizes. First observe that
larger block sizes improve the performance of a position map
because the number of seeks for a single position map access
is only O(log2 N/ log B), where B is the size of a block.
For example, with 4KB blocks and 1GB total storage, the
number of recursive levels in any position map is just 2. More
generally, if the block size B is large enough to store N α
pointers for some constant 0 < α < 1, then the number of
seeks per position map operation is only O(log N ). In this
setting, there are O(1) levels of recursion for the position map
and the total cost is O(1) with parallel seeks across levels.
Locally-stored position map optimizations.
If the position
map can be stored locally in persistent storage, it does afford
a number of optimizations. The most obvious of these is that
a single global position map sufﬁces, rather than one for each
tree. The second optimization is that locally-stored position
maps can be reduced if smaller ranges are not supported.
A position map for all the O(log N ) ORAM trees could
require O(N ) local storage for the position map, but many
of those stored positions are a result of tracking locations in
the smaller range trees. The position maps in the larger sub-
ORAMs are signiﬁcantly smaller since only the position of
the ﬁrst block in the range is required to reveal the other
blocks due to the bit-reversed position ordering within a
range. By eliminating a small portion of the smaller range
trees, the position map size is dramatically reduced without
greatly effecting the functionality of the system. For example,
in the situation with 1GB total data split into 4KB blocks,
the total storage for a local position map is roughly 11MB.
Removing the bottom 3 sub-ORAMs, reasonably requiring that
all accesses are on ranges of at least 8 blocks, reduces the
global position map size to less than 1MB.
C. Revealing operation type
The security deﬁnition for range ORAM requires that any
two access patterns with the same range sizes are indistin-
guishable, hiding the contents, addresses, and operation type
of each access. Only the size of the range is leaked. An in-
teresting security/performance tradeoff to consider is relaxing
the deﬁnition to reveal the operation type (read or write) to
an observer in addition to the range. Roughly speaking, such
a security deﬁnition allows for leakage of the direction of
information ﬂow which may be acceptable in some situations.
If operation type is leaked, we claim that the number of
seeks per operation can be reduced to just O(log N ) without
affecting the bandwidth under the following conditions.
1) The position map seek cost is O(log N ) using some ideas
from the previous subsection.
2) The operation type (read or write) is revealed.
3) Each write operation is for a single block at a time.
In particular, such a construction still reads ranges, but only
writes single blocks. We argue this scenario is actually quite
common and useful; for example, revealing the operation type
and limiting updates to one block at a time are quite common
in searchable symmetric encryption (SSE) scenarios [13, 16].
O(log N ) seeks per read. For reading a range of size r = 2i,
two accesses occur on the ORAM tree Ri and r batch evictions
in every tree, but for a read operation the data is not actually
modiﬁed. If the operation type is revealed, batch evictions on
the other Rj where j 6= i other ORAM trees does not need to
occur because there is no update to the data blocks, reducing
the seek cost to O(log N ).
O(log N ) seeks per write. Consider ﬁrst that while writing
a single item, the R0 ORAM tree needs to be updated, at a
cost of O(log N ) seeks, and the modiﬁed item must also be
updated in all the other ORAM trees. If those evictions are
performed immediately, the cost would be O(log2 N ) seeks.
However, because the write was only to a single block, we can
delay those evictions by simply appending the updated block
to each stash and only performing a single batch eviction on
one other tree, deterministically. With single item writes, i.e.,
no range writes, we can achieve O(log N ) seeks.
Speciﬁcally, say the construction contains ℓ ∈ O(log N )
ORAM trees. Then each single block write always updates the
R0 tree, appends the updated block to all ℓ − 1 other stashes,
and then performs a batch eviction of size (ℓ−1) for tree index
(i mod (ℓ−1))+1. All three steps — updating R0, appending
to ℓ − 1 other stashes, and performing a single batch eviction
— require O(log N ) seeks. Furthermore, because each stash
is cleared out after O(log N ) updates, the size of stash for
each ORAM tree no more than doubles.
D. Malicious security
The rORAM construction, as described, is secure against an
honest-but-curious adversary who always follows the protocols
correctly, but may observe and remember all communication
and past states of the remote storage. Achieving a higher level
of security against a malicious adversary who may actually
change the contents of remote storage or otherwise disobey
the protocol requires relatively straightforward techniques for
ensuring integrity [12, 41].
As in prior works, a Merkle tree can be embedded within
each individual ORAM trees to ensure integrity. However,
there is one important difference which is critical for minimiz-
ing the number of disk seeks. In a typical Merkle tree, each
node stores a combined hash of its two children. However,
doing this would require doubling the number of seeks because
updating a single tree path requires reading all sibling nodes
in the path as well.
Instead, each ORAM tree node stores a separate hash
of each child node so that updating a path in any of the
ORAM trees only requires reading and re-writing the nodes
in that path. The extra hashes introduce a (small) constant
factor increase in the bandwidth and remote storage size but
does not change the number of seeks. The hashes are stored
contiguously with the data.
Finally, the individual hashes of all O(log N ) ORAM trees
are collected into a single “root block” of hashes, which is
stored contiguously with the root node of any one of the
14
ORAM trees. Reading the root block on every access does
not introduce any extra seeks, and the client only needs to
store the hash of this root block locally in persistent storage.
A. Juels, R. N. Wright, and S. Vimercati, Eds. Alexandria, Virginia, USA: ACM
Press, Oct. 30 – Nov. 3, 2006, pp. 79–88.
[17] J. Dean, “Latency numbers every programmer should know,” Online, 2018,
https://gist.github.com/jboner/2841832.
IX. CONCLUSION
rORAM is an ORAM speciﬁcally suited for accessing
ranges of sequential
logical blocks while minimizing the
number of random physical disk seeks. rORAM is signiﬁcantly
more efﬁcient than prior designs [9], reducing a O(log N )
multiplicative factor both in the number of seeks and in
communication complexity.
A rORAM implementation is 30-50x times faster than Path
ORAM for similar range-query workloads on local HDDs, 30x
faster for local SSDs, and 10x faster for network block devices.
rORAM’s novel disk layout can also speed up standard ORAM
constructions, e.g., resulting in a 2x faster Path ORAM variant.
rORAM’s novel disk layout can also speed up standard ORAM
constructions, e.g., resulting in a 2x faster Path ORAM variant.
Importantly, experiments demonstrate suitability for real world
applications – rORAM is up to 5x faster running a ﬁle server
and up to 11x faster running a range-query intensive video
server workloads compared to standard Path ORAM.
rORAM raises the signiﬁcant practical issue of data locality
as an important factor in ORAM design. Even for ORAMs
that do not naturally support range queries, locality can have
a large impact on performance and seek optimization should
be a design criteria for future ORAM technology.
X. ACKNOWLEDGMENTS
This work is supported by the National Science Foundation
under awards 1526707, 1526102, 1319994, 1406177, 1618269
and by the Ofﬁce of Naval Research. We thank our shepherd,
Dimitrios Papadopoulos and the anonymous reviewers for their
valuable suggestions and comments.
REFERENCES
[1] “Amazon elastic block storage,” April, 23 2018, https://aws.amazon.com/ebs/.
[2] “Home of the curious framework,” April, 23 2018, http://seclab.soic.indiana.edu/
curious/.
[3] “Ext4 disk layout,” April, 23 2018, https://ext4.wiki.kernel.org/index.php/Ext4
Disk Layout.
[4] “roram implementation on github,” https://github.com/anrinch/rORAM.
[5] “Linux-iscsi project,” April, 23 2018, http://linux-iscsi.sourceforge.net/.
[6] “iperf,” April, 23 2018, https://iperf.fr/.
[7] “Specsfs benchmark suite,” https://www.spec.org/sfs2014/.
[8] G. Asharov, M. Naor, G. Segev, and I. Shahaf, “Searchable symmetric encryption:
optimal locality in linear space via two-dimensional balanced allocations,” in 48th
ACM STOC, D. Wichs and Y. Mansour, Eds. Cambridge, MA, USA: ACM Press,
Jun. 18–21, 2016, pp. 1101–1114.
[9] G. Asharov, T.-H. H. Chan, K. Nayak, R. Pass, L. Ren, and E. Shi, “Oblivious
computation with data locality,” Cryptology ePrint Archive, Report 2017/772, 2017,
http://eprint.iacr.org/2017/772.
[10] V. Bindschaedler, M. Naveed, X. Pan, X. Wang, and Y. Huang, “Practicing oblivious
access on cloud storage: the gap, the fallacy, and the new way forward,” in ACM
CCS 15. ACM Press, Oct. 12–16, 2015, pp. 837–849.
[11] E.-O. Blass, T. Mayberry, G. Noubir, and K. Onarlioglu, “Toward robust hidden
volumes using write-only oblivious ram,” in CCS, 2014, pp. 203–214.
[12] E.-O. Blass, T. Mayberry, and G. Noubir, “Multi-client oblivious RAM secure
Springer,
against malicious servers,” in ACNS 17, ser. LNCS, vol. 10355.
Heidelberg, Germany, 2017, pp. 686–707.
[13] C. B¨osch, P. Hartel, W. Jonker, and A. Peter, “A survey of provably secure
searchable encryption,” ACM Comput. Surv., vol. 47, no. 2, pp. 18:1–18:51, Aug.
2014.
[14] D. Cash and S. Tessaro, “The locality of searchable symmetric encryption,” in
Copenhagen, Denmark: Springer,
EUROCRYPT 2014, ser. LNCS, vol. 8441.
Heidelberg, Germany, May 11–15, 2014, pp. 351–368.
[15] A. Chakraborti, C. Chen, and R. Sion, “DataLair: Efﬁcient block storage with
plausible deniability against multi-snapshot adversaries,” Proceedings on Privacy
Enhancing Technologies, vol. 2017, pp. 175–193, Jul. 2017.
[16] R. Curtmola, J. A. Garay, S. Kamara, and R. Ostrovsky, “Searchable symmetric
encryption: improved deﬁnitions and efﬁcient constructions,” in ACM CCS 06,
[19]
[18] E. D. Demaine, “Cache-oblivious algorithms and data structures,” in Lecture Notes
from the EEF Summer School on Massive Data Sets, 2002, http://erikdemaine.org/
papers/BRICS2002/.
I. Demertzis and C. Papamanthou, “Fast searchable encryption with tunable
locality,” in SIGMOD, 2017, pp. 1053–1067.
I. Demertzis, S. Papadopoulos, O. Papapetrou, A. Deligiannakis, and M. Garo-
falakis, “Practical private range search revisited,” in SIGMOD ’16, 2016, pp. 185–
198.
I. Demertzis, D. Papadopoulos, and C. Papamanthou, “Searchable encryption
with optimal locality: Achieving sublogarithmic read efﬁciency,” in Advances in
Cryptology – CRYPTO 2018, 2018, pp. 371–406.
[20]
[21]
[22] J. Doerner and A. Shelat, “Scaling ORAM for secure computation,” in ACM CCS
17, B. M. Thuraisingham, D. Evans, T. Malkin, and D. Xu, Eds. Dallas, TX,
USA: ACM Press, Oct. 31 – Nov. 2, 2017, pp. 523–535.
[23] S. Faber, S. Jarecki, H. Krawczyk, Q. Nguyen, M.-C. Rosu, and M. Steiner,
“Rich queries on encrypted data: Beyond exact matches,” IACR Cryptology ePrint
Archive, vol. 2015, p. 927, 2015.
[24] C. W. Fletcher, L. Ren, A. Kwon, M. van Dijk, and S. Devadas, “Freecursive
ORAM: [nearly] free recursion and integrity veriﬁcation for position-based obliv-
ious RAM,” in ASPLOS, 2015, pp. 103–116.
[25] C. W. Fletcher, L. Ren, A. Kwon, M. van Dijk, E. Stefanov, D. N. Serpanos,
and S. Devadas, “A low-latency,
low-area hardware oblivious ram controller,”
2015 IEEE 23rd Annual International Symposium on Field-Programmable Custom
Computing Machines, pp. 215–222, 2015.
[26] C. Gentry, K. A. Goldman, S. Halevi, C. S. Jutla, M. Raykova, and D. Wichs,
“Optimizing ORAM and using it efﬁciently for secure computation,” in PETS,
2013, pp. 1–18.
[27] O. Goldreich, “Towards a theory of software protection and simulation by oblivious
RAMs,” in 19th ACM STOC, A. Aho, Ed. New York City, NY, USA: ACM Press,
May 25–27, 1987, pp. 182–194.
[28] M. S. Islam, M. Kuzu, and M. Kantarcioglu, “Access pattern disclosure on
searchable encryption: Ramiﬁcation, attack and mitigation,” in in Network and
Distributed System Security Symposium (NDSS, 2012.
[29] C. Liu, A. Harris, M. Maas, M. W. Hicks, M. Tiwari, and E. Shi, “Ghostrider: A
hardware-software system for memory trace oblivious computation,” in ASPLOS,
2015, pp. 87–101.
[30] C. Liu, X. S. Wang, K. Nayak, Y. Huang, and E. Shi, “ObliVM: A programming
framework for secure computation,” in 2015 IEEE Symposium on Security and
Privacy. San Jose, CA, USA: IEEE Computer Society Press, May 17–21, 2015,
pp. 359–376.
[31] T. Mayberry, E.-O. Blass, and A. H. Chan, “Efﬁcient private ﬁle retrieval by
combining ORAM and PIR,” in NDSS 2014. San Diego, CA, USA: The Internet
Society, Feb. 23–26, 2014.
I. Miers and P. Mohassel, “IO-DSSE: scaling dynamic searchable encryption to
millions of indexes by improving locality,” in NDSS, 2017.
[32]
[33] O. Ohrimenko, M. T. Goodrich, R. Tamassia, and E. Upfal, “The melbourne shufﬂe:
Improving oblivious storage in the cloud,” in ICALP, 2014, pp. 556–567.
[34] L. Ren, C. W. Fletcher, A. Kwon, E. Stefanov, E. Shi, M. van Dijk, and S. Devadas,
“Constants count: Practical improvements to oblivious RAM,” in USENIX Security
15, 2015, pp. 415–430.
[35] D. S. Roche, A. J. Aviv, and S. G. Choi, “A practical oblivious map data structure
with secure deletion and history independence,” in 2016 IEEE Symposium on
Security and Privacy. San Jose, CA, USA: IEEE Computer Society Press, May 22–
26, 2016, pp. 178–197.
[36] D. S. Roche, A. J. Aviv, S. G. Choi, and T. Mayberry, “Deterministic, stash-free
write-only ORAM,” in ACM CCS 17, B. M. Thuraisingham, D. Evans, T. Malkin,
and D. Xu, Eds. Dallas, TX, USA: ACM Press, Oct. 31 – Nov. 2, 2017, pp.
507–521.
[37] C. Sahin, V. Zakhary, A. E. Abbadi, H. Lin, and S. Tessaro, “Taostore: Overcoming
asynchronicity in oblivious data storage,” in 2016 IEEE Symposium on Security and
Privacy (SP), May 2016, pp. 198–217.
[38] E. Shi, T.-H. H. Chan, E. Stefanov, and M. Li, “Oblivious RAM with O((log N )3)
worst-case cost,” in ASIACRYPT 2011, ser. LNCS, vol. 7073. Springer, Heidelberg,
Germany, Dec. 4–8, 2011, pp. 197–214.
[39] E. Stefanov and E. Shi, “ObliviStore: High performance oblivious distributed cloud
data store,” in NDSS 2013. San Diego, CA, USA: The Internet Society, Feb. 24–27,
2013.
[40] E. Stefanov, E. Shi, and D. X. Song, “Towards practical oblivious RAM,” in
NDSS 2012. San Diego, CA, USA: The Internet Society, Feb. 5–8, 2012.
[41] E. Stefanov, M. van Dijk, E. Shi, C. W. Fletcher, L. Ren, X. Yu, and S. Devadas,
“Path ORAM: an extremely simple oblivious RAM protocol,” in ACM CCS 13.
Berlin, Germany: ACM Press, Nov. 4–8, 2013, pp. 299–310.
[42] X. Wang, T.-H. H. Chan, and E. Shi, “Circuit ORAM: On tightness of the
Goldreich-Ostrovsky lower bound,” in ACM CCS 15. Denver, CO, USA: ACM
Press, Oct. 12–16, 2015, pp. 850–861.
[43] X. Wang, D. Gordon, and J. Katz, “Simple and efﬁcient two-server oram,” in
Asiacrypt, 2018, pp. 141–157.
[44] X. S. Wang, K. Nayak, C. Liu, T.-H. H. Chan, E. Shi, E. Stefanov, and Y. Huang,
“Oblivious data structures,” in ACM CCS 14. Scottsdale, AZ, USA: ACM Press,
Nov. 3–7, 2014, pp. 215–226.
[45] P. Williams and R. Sion, “Single round access privacy on outsourced storage,” in
ACM CCS 12, T. Yu, G. Danezis, and V. D. Gligor, Eds. Raleigh, NC, USA:
ACM Press, Oct. 16–18, 2012, pp. 293–304.
15