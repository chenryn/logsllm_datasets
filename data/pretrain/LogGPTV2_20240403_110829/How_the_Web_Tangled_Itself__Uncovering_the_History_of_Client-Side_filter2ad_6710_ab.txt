i.e., JavaScript, Flash, Java, and Silverlight.
Figure 2 shows the technologies we discovered in the
top-ranked sites in our study over time. We observe that
starting from the beginning our of study in 1997, Java-
Script was widely deployed, while initially Java applets
could also be discovered in few cases. Generally speak-
ing, though, Java and Silverlight did not play a signif-
icant role in active technologies used by the top sites.
Over the years, JavaScript usage increased, spiking from
about 60% to 85% in 2003, reaching its peak in 2009
with 98.3% of all sites using JavaScript. This number
remained stable until 2016. Curiously, not all sites ap-
pear to be using JavaScript. This, however, is caused
by two factors: on the one hand, the Alexa top 500
list contains a number of Content Distribution Networks,
which do not carry any JavaScript on their static HTML
front pages. Moreover, we found that in some cases the
Archive crawler could not store the included JavaScript.
As our analysis only considers executed JavaScript, this
makes for the second part of non-JavaScript domains.
Starting from 2002, we can also observe an increase in
the usage of Flash. Its share increased, also reaching its
Figure 2: Technologies used by top 500 sites
peak in 2009 with 48%. However, we also observe that
the use of Flash decreases noticeably in the following
years ending with only approximately 20% of the 2016
site population using it. This is in part related to modern
browsers nowadays switching off Flash by default, and
moreover the fact that HTML5 can be used to develop
interactive advertisements instead of Flash.
In addition to the core technologies, we considered
jQuery in our analysis, since it is one of the main drivers
behind powerful JavaScript applications. We ﬁnd that af-
ter it was ﬁrst introduced in 2006, the major sites quickly
picked up on its use. Until 2011, coverage quickly grew
to over 65% of all sites using it, whereas by 2016, almost
75% of the major sites were using jQuery.
JavaScript as the Powerhouse of the Web 2.0 As we
observed in the previous section, at least starting in 2003,
JavaScript was omnipresent on the Web. To understand
the magnitude of its success, we analyzed all JavaScript
which was included in external scripts (not considering
libraries like jQuery). We selected these instead of inline
scripts (i.e., such scripts that do not have a src attribute,
but contain the code in the script tags) as the major func-
tionality of Web sites is mostly contained in such external
scripts instead of being intermixed with the HTML code.
Figure 3 shows the average number of statements in each
external script by year, i.e., whenever a domain included
a single external ﬁle in 2016, it contained more than 900
statements. As the ﬁgure shows, this number increased
steadily over the years, while at the same time, the aver-
age number of scripts included in each frame remained
stable at about four scripts per frame.
Moreover, we analyzed the Cyclomatic Complexity of
all scripts per year. Designed by McCabe [22] in 1976, it
measures the number of potential paths through the pro-
gram, which equals the number of different test cases
needed to cover all branches of the program. Figure 4
shows the results of our analysis, averaged per exter-
nal script (excluding well-known libraries) in each year.
974    26th USENIX Security Symposium
USENIX Association
19972002200720120%20%40%60%80%100%JavaScriptjQueryFlashJavaSilverlightFigure 3: JavaScript Statement Statistics
Figure 5: JavaScript Inclusion Statistics
sively demonstrated, the inclusion of third-party scripts
has an immediate impact on a Web site’s security char-
acteristics, that scales negatively with the number of ex-
ternal code sources. Figure 5 shows the evolution of re-
mote inclusions over time, plotting the number of distinct
remote origins used in average domains. Starting from
2000, domains started using third-party inclusions. The
trend since then is clearly pointing upwards, reaching al-
most 12 distinct remote origins per domain by 2016.
Cross-Domain Data Access Modern Web sites are of-
ten interconnected, bringing the need for cross-domain
communication and data access. However, such commu-
nication is prohibited by the Same-Origin Policy (SOP),
which states that resources may only access each other
if they share an origin, i.e., protocol, host, and port
match [41]. To nevertheless allow applications to com-
municate across these boundaries, different technologies
can be used. One technique to do so is called JSONP,
short for JSON with padding. The SOP has certain ex-
emptions, such as the fact that including scripts from a
remote origin is permitted. JSONP leverages this by pro-
viding data in the form of a script, where the data is con-
tained as JSON, wrapped in a call to a function which
is typically speciﬁed as a URL parameter. This way, a
site may include the script from a remote origin, effec-
tively getting the data as the parameter to the speciﬁed
callback function. There are, however, a number of se-
curity issues associated with this, such as cross-domain
data leakage [18] or the Rosetta Flash attack [32]. To
detect JSONP in the data, we pre-ﬁltered all scripts in
which any given URL parameter was contained in the
response as a function call. Subsequently, we manually
checked the results to ﬁlter out false positives. The re-
sults of our analysis are depicted in Figure 6, showing
that at most about 17% of all sites used JSONP during
our study timeframe. Moreover, we observe a slight de-
crease since 2014.
Figure 4: Cyclomatic Complexity Statistics
By 2016, each external script on average had more than
300 paths to cover. Also, the graph depicts the trend of
an ever-increasing number of paths, underlining the in-
creased complexity of modern applications.
These ﬁgures clearly show that modern JavaScript ap-
plications are more powerful than ever, but also incur a
higher complexity due to the large code base to maintain.
Script Inclusions from Remote Domains Next to the
amount of JavaScript code, we investigated the origin of
the code. Browsers allow for Web sites to include script
content from remote origins, which is often used to in-
corporate third-party services (e.g., for site analytics, ad-
vertising, or maps) or to reduce trafﬁc on a site (e.g., by
including jQuery from Google). However, when such re-
mote scripts are included, they operate in the origin of the
including site, i.e., they can modify both the global Java-
Script state as well as the DOM. This adds more com-
plexity to the page, since inclusion of third-party content
might have side-effects, ranging from modiﬁed function-
ality all the way to vulnerabilities introduced by third-
party code. As Nikiforakis et al. [24] have comprehen-
USENIX Association
26th USENIX Security Symposium    975
199719981999200020012002200320042005200620072008200920102011201220132014201520160200400600800Averagestatementsperexternalscript19971998199920002001200220032004200520062007200820092010201120122013201420152016050100150200250300350Averagecyclomaticcomplexityperexternalscript19971998199920002001200220032004200520062007200820092010201120122013201420152016024681012Averageincludeddomainscuring a modern Web application with all its different
components is challenging. Hence, in the following sec-
tions, we analyze how security evolved over time by ﬁrst
discussing a number of issues we discovered, and subse-
quently showing which countermeasures were deployed.
4 Discovered Security Issues
Based on the technologies we identiﬁed as most preva-
lent in the previous section, in this section, we highlight
security issues pertaining to these technologies, as dis-
covered in our study. To that end, we report on the Client-
Side XSS vulnerabilities we found, analyze the insecure
usage of postMessages over time, outline the (in)security
of cross-domain communication in Flash, and show the
general pattern of including outdated third-party library
versions.
4.1 Client-Side XSS Vulnerabilities
The term Cross-Site Scripting (XSS) was ﬁrst intro-
duced in 2000 by a group of security engineers at Mi-
crosoft [29]. At ﬁrst, this issue was believed to only
be caused by insecure server-side code. In 2005, Amit
Klein wrote an article about what he dubbed DOM-
based Cross-Site Scripting [12], detailing the risk of
XSS through insecure client-side code. He called it
DOM-based since he argued that it was caused by using
attacker-provided data in interactions with the Document
Object Model (DOM). Nowadays, this does not hold true
anymore considering that the eval construct allows for
JavaScript execution without the use of any DOM func-
tionality. Hence, this type of issue is also referred to as
Client-Side Cross-Site Scripting [34].
In contrast to Cross-Site Scripting caused by server-
side code, Client-Side XSS can be discovered in the
HTML and JavaScript code that was delivered to the
client and in this case to the Archive crawler. There-
fore, this data source allows us to investigate when the
ﬁrst instances of this attack occurred and how many sites
were affected over the course of the last 20 years. To that
end, we used an automated system developed by us to
crawl the pages, collect potentially dangerous data ﬂows,
and generate proof-of-concept exploits for each of the
ﬂows [17].
Compared to our previous work, which was conducted
on live Web sites, the archived data has one drawback:
in case an exploit could only be triggered by modify-
ing a search parameter, this effectively changed the URL
and, hence, the corresponding page was not contained in
the Archive. Therefore, for each site without a veriﬁed
exploit, we sampled one potentially vulnerable ﬂow and
analyzed the JavaScript code manually. In doing so, we
Figure 6: Cross-Origin Data Sharing Techniques
While with JSONP, the developer has to ensure that
no unauthorized origin can include the endpoint, Cross-
Origin Resource Sharing (CORS) is secure by default.
CORS is a policy deployed by the server and is meant
to control data access when a request is conducted with
the XMLHttpRequest API [41]. By default, such a re-
quest does not carry authentication credentials in the
form of cookies. If a snippet wants to do such an au-
thenticated request across domains, the remote HTTP
server has to speciﬁcally allow the snippet’s origin in the
Access-Control-Allow-Origin header; a wildcard is
not sufﬁcient to grant access. In our study, we found that
CORS deployment has overtaken the use of JSONP in
2014 and has increased drastically resulting in 20% of
the investigated sites to deploy such a header.
The most recent addition to the technologies which
may be used for cross-domain communication, which
was introduced with HTML5, is postMessage [7]. This
API allows for cross-domain message exchange when-
ever two sites are rendered in the same browser tab (or
popup window). It can be used to convey even complex
JavaScript objects allowing for a seamless communica-
tion between origins. The API has gained a lot of popu-
larity since its inception and we ﬁnd that over 65% of the
sites in 2016 either received postMessages or sent them.
Summary To sum up, we observe that over time, Java-
Script has remained the most important scripting lan-
guage on the Web. At the same time, with increas-
ingly powerful applications, the complexity of the Web
platform has risen, and new APIs are constantly added
to browsers.
In turn, JavaScript applications have be-
come much more complex, showing a steady increase
in the amount of code executed by the client, including
code from an increasing amount of different sources, and
exchanging data across the trust boundaries of the do-
main. Moreover, even legacy technology like Flash still
remains in use by a notable fraction of sites. Thus, se-
976    26th USENIX Security Symposium
USENIX Association
2007200820092010201120122013201420152016year0%10%20%30%40%50%60%70%JSONPpostMessageCORSpostMessage
received
0.5%
10.8%
18.5%
32.7%
31.9%
40.0%
50.5%
48.0%
no origin
check
0%
2.4%
8.4%
11.4%
21.8%
19.6%
18.1%
26.3%
postMessage
sent
20.9%
5.9%
19.0%
32.7%
41.2%
52.2%
62.9%
64.1%
wildcard
target
2.2%
3.9%
14.8%
17.9%
22.8%
33.0%
45.8%
50.3%
2009
2010
2011
2012
2013
2014
2015
2016
Table 1: postMessage Statistics
ever a site used at least one postMessage receiver without
an origin check, we marked this domain as not using the
origin check. We ﬁnd that the data does not show a trend
towards more secure usage. On the contrary: in 2016,
more than half of the pages which received postMessages
had at least one receiver without an origin check.
A missing origin check does not necessarily result in a
vulnerability, as pointed out by Son and Shmatikov [31].
In their work, only 13 out of 136 distinct receivers led to
an actual vulnerability. Their analysis efforts, however,
were mostly manual; hence, while an in-depth analysis
of the discovered receivers is not feasible for our work,
we leave a more automated approach to such analyses to
future work.
Apart from the authenticity issue of postMessages, not
specifying a target origin might endanger the conﬁden-
tiality of an application’s data. Table 1 shows the re-
sults of our analysis. Note that in comparison to received
postMessages the numbers vary, since not every site that
sends postMessages also receives them. Moreover, the
high number of postMessage senders in 2009 is related to
Google page ads, which featured postMessages in 2009,
but removed its usage in 2010. Even though not every
message with a wildcard target is necessarily security-
critical, we ﬁnd that by 2016, more than half of the sites
we analyzed sent at least one such message. We leave
further investigation of the actual exploitability of such
insecure postMessages to future work.
4.3 Flash Cross-Domain Policies
Similar to JavaScript, Flash also offers APIs to conduct
HTTP requests, either to the same site or across domain
boundaries. To nevertheless ensure the user’s protection
against cross-domain data leakage, Flash tries to down-
load a policy ﬁle (crossdomain.xml) from the remote
origin before allowing access to that site’s content.
If
it is missing, no data can be exchanged between the
sites [35]. If it exists, the policy ﬁle can specify which
origins may access the site’s data, and can contain wild-
cards, e.g., to allow for all subdomains of a given domain
Figure 7: Client-Side XSS Vulnerabilities per year
could manually verify that 33% (142/427) of the sampled
domains were in fact vulnerable.
Figure 7 shows the results of our analysis. Even back
in 1997, sites were vulnerable to Client-Side XSS. We
also notice a distinctive increase in vulnerabilities start-
ing from 2003, which coincides with the advent of the
Web 2.0. Moreover, the results are stable at around 12%
to 14% from 2007 to 2012. In 2013, when we published
our work on discovering Client-Side XSS, we found ap-
proximately 10% of the Top 10.000 sites to be vulnera-
ble, which aligns with our ﬁndings. After 2013, the num-
bers slightly drop, leaving about 8% of the 2016 sites
exploitable.
Insecure postMessage Handling
4.2
To allow for an easy cross-domain communication chan-