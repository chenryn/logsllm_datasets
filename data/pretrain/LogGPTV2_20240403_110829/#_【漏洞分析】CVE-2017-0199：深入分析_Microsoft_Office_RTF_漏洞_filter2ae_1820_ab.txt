    001efe18 2fb91ec2 2fb90000 00000000 0121ffd1 winword!wdGetApplicationObject+0x63a
    001efea8 7728ef8c 7ffd8000 001efef4 7713367a winword!wdGetApplicationObject+0x894
    001efeb4 7713367a 7ffd8000 366f1751 00000000 kernel32!BaseThreadInitThunk+0xe
    001efef4 7713364d 2fb92045 7ffd8000 ffffffff ntdll!__RtlUserThreadStart+0x70
    001eff0c 00000000 2fb92045 7ffd8000 00000000 ntdll!_RtlUserThreadStart+0x1b
图 8: 文档中的超链接在点击后被ParseDisplayName函数解析
概括地来说，scriptlet又称为Windows Script
Component（WSC），其设计目的是执行Javascript、VBScript以及PerlScript等脚本语言，同样也可以执行XML文件中的脚本代码。通过相关逆向分析，我们发现当一个超链接被触发后，scriptlet的解释器会通过文件后缀将关联URL的文件识别为脚本文件，导致HLINK.dll加载并实例化WSC、CROBJ.dll继而执行该文件。
下面的栈结构反映了关联超链接的scriptlet文件的执行过程：
    0:000> kb
    ChildEBP RetAddr  Args to Child             
    0027a25c 6a720899 00000000 00000000 14bf8ff0 jscript!COleScript::ExecutePendingScripts
    0027a278 6cb6831f 14bf0de8 00000001 14baae28 jscript!COleScript::SetScriptState+0x51
    0027a288 6cb68464 14bdefd8 14bdefe4 00000000 scrobj!ScriptEngine::Activate+0x1a
    0027a2a0 6cb699d3 00000000 1420ffd0 00000000 scrobj!ComScriptlet::Inner::StartEngines+0x6e
    0027a2f0 6cb6986e 00000000 015dffb0 0027a320 scrobj!ComScriptlet::Inner::Init+0x156
    0027a300 6cb6980b 015dffb0 14b9cf10 00000000 scrobj!ComScriptlet::New+0x3f
    0027a320 6cb697d0 14b9cf10 00000000 00000000 scrobj!ComScriptletConstructor::CreateScriptletFromNode+0x26
    0027a340 6cb737e2 015dffb0 00000000 00000000 scrobj!ComScriptletConstructor::Create+0x4c
    0027a360 6cb74545 00000000 71a6245c 0027a460 scrobj!ComScriptletFactory::CreateScriptlet+0x1b
    0027a380 7671b53d 015d1ff0 1417efc8 1420ffd0 scrobj!ComScriptletMoniker::BindToObject+0x4d
    0027a3b4 71a6a858 138a4fd0 1417efc8 00000000 ole32!CCompositeMoniker::BindToObject+0x105 [d:w7rtmcomole32commoniker2ccompmon.cxx @ 1104]
    0027a3f0 71a65ab7 1390ff78 00000001 14158fe0 hlink!HLBC::GetObjectA+0x143
    0027a468 65638cb8 00000000 00000000 00000000 hlink!HLNK::Navigate+0x2ae
    WARNING: Stack unwind information not available. Following frames may be wrong.
    0027a488 71a68352 13b1efd0 00000000 00000000 mso!Ordinal10017+0x2b87
    0027a4b0 6524c724 13b1efd0 00000000 00000000 hlink!HlinkNavigate+0xc0
    0027ba88 6564f384 13b1efd0 00000000 00000000 mso!Ordinal8417+0x52f
    0027baac 66684415 13b1efd0 00000000 00000000 mso!Ordinal2959+0x1c
    0027bafc 66685377 00000000 00000000 0e9bc948 wwlib!DllGetLCID+0x7edf8f
    0027bbb0 66687190 0e9bc948 00000000 00000087 wwlib!DllGetLCID+0x7eeef1
    0027bbd8 66264c1d 66b74400 00000087 0000007d wwlib!DllGetLCID+0x7f0d0a
    0027da20 6625facc 00000087 0000007d 00000000 wwlib!DllGetLCID+0x3ce797
    0027da50 661bbe3c 03d152b0 00000201 00000009 wwlib!DllGetLCID+0x3c9646
    0027dadc 65c94acd 0008094e 00000201 00000009 wwlib!DllGetLCID+0x3259b6
    0027db1c 757ec4b7 0008094e 00000201 00000009 wwlib!DllGetClassObject+0xf471
    0027db48 757ec5b7 65c94a8c 0008094e 00000201 USER32!InternalCallWinProc+0x23
    0027dbc0 757ecbe9 00000000 65c94a8c 0008094e USER32!UserCallWinProcCheckWow+0x14b
    0027dc20 757ecc40 65c94a8c 00000000 0027dc40 USER32!DispatchMessageWorker+0x357
    0027dc30 65ce426d 66b6e630 66b6e630 0027dc58 USER32!DispatchMessageW+0xf
    0027dc40 65ce3e05 66b6e630 757e2b1d 66b6e630 wwlib!GetAllocCounters+0x4da95
    0027dc58 65ce3d4b 00000001 12accfe4 12ad0f8c wwlib!GetAllocCounters+0x4d62d
    0027dc80 65ce2cf0 65c8517d 7728cebc 65c80000 wwlib!GetAllocCounters+0x4d573
    0027fde0 2f1d1c68 2f1d0000 00000000 0008ffd1 wwlib!GetAllocCounters+0x4c518
    0027fe04 2f1d1ec2 2f1d0000 00000000 0008ffd1 winword!wdGetApplicationObject+0x63a
    0027fe94 7728ef8c 7ffdd000 0027fee0 7713367a winword!wdGetApplicationObject+0x894
    0027fea0 7713367a 7ffdd000 45b88b21 00000000 kernel32!BaseThreadInitThunk+0xe
    0027fee0 7713364d 2f1d2045 7ffdd000 ffffffff ntdll!__RtlUserThreadStart+0x70
    0027fef8 00000000 2f1d2045 7ffdd000 00000000 ntdll!_RtlUserThreadStart+0x1b
微软目前已经将上述两个能够导致远程代码执行的COM对象加入黑名单，但该做法近乎简单粗暴，同时也不排除未来发现新的具备相同的效果的COM对象。
**0x02 样本分析**
* * *
下面我们分析两个样本的部分结构来探讨一下样本设计者规避检测的思路。
**样本1**
sha256：
    94d324cbd50ab65e2170514c49ce0e91c73335d0ec8af978d0ac99c62d8a431e
    b48055a517fe1077b95860c8816e3ae75174affac487554d7f812f3c96c36eae
样本1的RTF部分结构如下：
图 9: 样本1的RTF结构
在上图中我们发现“objdata”包含的控制字段“deftabN”将“objdata”包含的16进制字符串分隔成了两段。根据RTF的定义，“deftabN”必须跟在一个10进制值后面，这里如果我们忽略“deftab”跟随的10进制值，图9中高亮部分的16进制字符串会被解析为：
图 10: 样本的解析结果被改变
这种16进制字符串并没有影响Word
RTF的解析器，但是却巧妙地回避了一些利用静态特征检测恶意URL的规则。目前已发现的大部分样本主要通过将“objlink”替换为“objemb”来触发漏洞。
**样本2**
sha256：
    e0320c0066c69aa35a654d01e951fdc9e489bf66b4c79608156ad446f10d88dd
经过测试发现，样本2仍然能够通过大部分杀软的静态检测。目前很多杀软的做法是尝试发现RTF文件中嵌入的OLE数据流，而OLE数据流一般通过定位“objdata”关键字来确定。根据RTF官方定义，“objdata”必须跟随“*”控制字符，在样本2中，“*”被一个任意字符取代。而对于Word
RTF解析器，如果遇到无法识别的控制符号，则直接跳过，继续解析关键字“objdata”后面的数据，而这一点可能就是绕过检测的主要原因。
**0x03 总结**
* * *
本文以CVE-2017-0199漏洞补丁的分析为切入点，发现其解决针对Microsoft Office的scriptlet
COM远程代码执行的工作机制，这一方面在之前分析CVE-2017-0199漏洞的文章中鲜有提及；此外，本文提到的一些RTF样本躲避静态检测的技巧对安全防护的设计也有一定的启发作用。要防御该漏洞，最好的办法是使用最新的Microsoft
Office，同时及时更新操作系统补丁。
**0x04 参考文献**
* * *
[1] [http://blog.fortinet.com/2017/05/30/spear-phishing-fileless-attack-with-cve-2017-0199](http://blog.fortinet.com/2017/05/30/spear-phishing-fileless-attack-with-cve-2017-0199)
[2] [https://msdn.microsoft.com/en-us/library/ms775147(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms775147\(v=vs.85\).aspx)
[3]
[https://twitter.com/enigma0x3/status/859124491720458247](https://twitter.com/enigma0x3/status/859124491720458247)