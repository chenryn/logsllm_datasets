comparison because the corresponding constraint is not relevant to
the practice of restricting kernel execution from flowing towards
the leaking anchor.
Object and vulnerability pairing. In our implementation, ELOISE
utilizes the Z3 solver [60] to pair a vulnerability with elastic ob-
jects. More specifically, we use BitVec to represent the layout of
an object and machine arithmetic to describe the corresponding
memory range. For example, given a constraint "[8, 16)> (112*8) to depict its
range [8, 16), and finally employ the representation (x >
(cid:44)→ (112*8)< 8) to indicate the constraint. Given an elastic object,
for each path towards a leaking anchor, ELOISE first conjuncts the
corresponding constraints on that path with a set of constraints
indicating the capability of the corresponding vulnerability. Then,
ELOISE feeds those combined constraints to the Z3 solver. If a so-
lution is successfully identified, it means the elastic object could
be paired with the capability of the vulnerability and can be used
for exploitation. Otherwise, we conclude that the elastic object
under our examination cannot facilitate the exploitation of that
vulnerability. It should be noted that, in the process of pairing, if
one of the constraints tied to a path involves a variable (e.g., [0,
8)<cache_detail.20), ELOISE conservatively skips that path simply
because the lack of information about that variable introduces un-
certainty for using that object for exploitation. Admittedly, this
implementation inevitably influences the number of elastic objects
available for exploitation. However, as we will show and discuss in
Section 5, even with such a conservative implementation, for nearly
all kernel vulnerabilities, ELOISE can point out at least one elastic
kernel object for bypassing corresponding exploit mitigation.
5 EVALUATION
We design three experiments to evaluate the effect of elastic ob-
jects on kernel protection circumvention across three open-sourced
kernels (Linux, FreeBSD, and XNU).
5.1 Experiment Design
Experiment I: evaluating our tool and characterizing elastic
objects. As is described and discussed above, ELOISE relies upon
static analysis. However, the accuracy of static analysis heavily
relies upon the correctness of the kernel’s control flow graph and
the level of optimization introduced at the compilation stage. As a
result, ELOISE inevitably introduces false positives (i.e., mistakenly
identifying an object as an elastic one) and false negatives (i.e.,
failing to pinpoint an elastic object or successfully identifying an
elastic object but failing to associate it with a disclosure channel). In
this work, we design an experiment to evaluate the false positives
(FP) and false negatives (FN).
To evaluate false negatives, ideally, we should follow a two-
step procedure. First, we go through all the object allocation sites
in the kernel implementation and determine whether the type
of the allocated objects is one of the elastic structures defined in
Section 3.1. Second, for every elastic object confirmed in the first
step, we extract its corresponding elastic buffer and then examine
whether the kernel can pass the data in the elastic buffer to the
userland through the disclosure functions defined in Table 3 (e.g.,
copy_to_user() or copyout() ). After each step, we compare the results
obtained through the manual efforts with those reported by ELOISE
and thus pinpoint the false negatives accordingly.
Given the complexity and huge codebase of kernel implemen-
tation, this manual approach, however, is infeasible. Take Linux
kernel as an example. Its implementation (v5.5.3) contains about
14 million lines of C code, 53,775 allocation sites, and 75,100 sites
that invokes one of the kernel functions listed in Table 3. Even
after successfully confirming an allocated object is in the type of
an elastic structure, a kernel expert still needs to manually walk
through tens of thousands of C code lines to determine whether
the allocated object has a connection with the corresponding dis-
closure kernel functions. As such, we study false negatives through
a random sampling approach.
First, we randomly sampled 800 out of 6,383 elastic structures
(Note that these structures have no FN for sure). Then, we manually
identify all of their allocation sites in Linux, followed by checking
their connection with the disclosure functions. In this work, we
identify false negatives by comparing our manually analyzed re-
sults with those of ELOISE. We argue this false-negative measure
is representative even if we do not perform this analysis on all the
allocation sites nor apply this manual effort on other kernels (i.e.,
FreeBSD and XNU). It is because ❶ our allocation site sampling is
random, covering 12.5% of the kernel allocation sites; ❷ the design
of three kernels shares many common properties, and the false
negatives observed on one kernel could be potentially generalized
to other kernels; ❸ our manual analysis relies upon the workforce
of three Linux kernel researchers who have extensive experience
in reporting Linux kernel bugs and publishing kernel research at
top tier system and security conferences.
To evaluate false positives, we leverage automated tools along
with our manual effort. For Linux and FreeBSD kernels, we first
instrument panic functions at the sites where ELOISE identifies the
allocation of elastic objects, and the sites where ELOISE discovers
the disclosure of the data from an elastic buffer. Then, for each
instrumented site, we use Syzkaller[25] to assist us in checking
whether there is indeed a concrete input that could reach these sites
to allocate elastic objects and thus disclose data in the elastic buffers.
Following the kernel fuzzing, we manually examine the sites which
the fuzzing fails to reach because these unreachable sites could
result from either our inaccurate static analysis or the limitation
of our fuzzing technique. In this work, we take the unreachable
cases as the false positives of ELOISE only if our manual review
still cannot find a concrete input to reach out to our interest sites.
It should be noted that there are no fuzzing tools publicly available
for the XNU kernel. As a result, we solely rely upon manual effort
for the false-positive study on XNU. For all the true positives, we
then conduct further experiment to understand the pervasiveness
of elastic objects and study their characteristics.
Experiment II: evaluating the ability to bypass mitigation.
Recall that one of our objectives is to study whether elastic kernel
objects could enable many kernel vulnerabilities to bypass widely
deployed exploit mitigation methods, such as KASLR, heap protec-
tor, and stack canary. To answer this question, we select 40 kernel
vulnerabilities and summarize the capability of each kernel vul-
nerability. Then, we use ELOISE to examine whether one of the
identified elastic objects could be paired with these vulnerabilities
and hence enable kernel protection bypassing.
Due to the space limit, we list these 40 vulnerabilities in Table 7
and describe how we manually summarize vulnerability capabil-
ity in the Appendix. We argue that the selected vulnerabilities
are representative. First, this list includes all types of vulnerabili-
ties that corrupt data on the kernel heap (i.e., out-of-bound write,
use-after-free, and double-free). Second, it covers all the heap cor-
ruption vulnerabilities used in various Linux kernel exploitation
research (e.g., [11, 39, 79, 80]). Third, it includes 10 Linux kernel
vulnerabilities randomly sampled from syzbot [26] (a Linux kernel
vulnerability dashboard). These randomly sampled vulnerabilities
are identified by Syzkaller recently but have not yet assigned with
an CVE ID. Finally, it encloses all XNU and FreeBSD vulnerabilities
publicly disclosed in the past three years.
It should be noted that, although the National Vulnerability Data-
base lists many CVEs relevant to FreeBSD and XNU, a majority of
them cannot be used for our evaluation because the detail of the
vulnerabilities is incomplete or completely missing or the trigger
of the vulnerabilities requires a particular hardware. As such, we
chose our FreeBSD and XNU test cases by following three criteria.
❶ A vulnerability has to demonstrate its capability through a PoC
program that triggers the vulnerability but, not necessarily, has to
perform actual exploitation. ❷ The vulnerability has to allow us
to trigger it without requiring a particular hardware device nor
root privilege. ❸ By running the publicly released PoC program
to trigger the vulnerability, the kernel panic or failure (typically
declared along with a released writeup) has to be reproducible. To
ease our experiment, we migrate the Linux, FreeBSD, and XNU vul-
nerabilities above to one particular version of Linux kernel (v5.5.3),
one specific FreeBSD (v12.1), and one specific XNU kernel (XNU-
4903.221.2), respectively. They are all the latest versions of the
kernels at the time we conduct our experiment.
Experiment III: evaluating the utility of ELOISE in exploit
development assistance. To evaluate the effectiveness of ELOISE
in expediting exploit development, we conduct a user study un-
der IRB permission (#STUDY00010080). In particular, we recruit
our subjects from a pool of CTF players and a pool of security
analysts who have extensive experience in debugging Linux ker-
nel and writing kernel patches. Our primary recruitment method
is to invite participants through emails. In our invitation email,
we describe our study objective as a paid task that quantitatively
measures the time spent on exploit development and qualitatively
surveys the difficulty in writing an exploit. In our email, we also
require all the participants to ❶ have experience in exploiting Linux
kernel vulnerabilities, ❷ be familiar with the commonly adopted
exploitation method discussed in this paper, and ❸ be comfortable
for conducting this study online. To evaluate whether applicants
qualify for this study and form groups, we asked all applicants to
sign the participation agreement and complete a self-assessment
form (see Figure 6 in Appendix A.5). The collected self-assessment
forms indicate that, among the 8 participants, 6 subjects meet with
our requirements. Regarding the expertise level, 4 subjects have
about three years of experience in exploiting kernel vulnerabilities
(high expertise), and the rest 2 subjects have about one year of
the corresponding experience (moderate expertise). Based on these
responses, we randomly assign each group with 2 highly skillful
subjects and 1 subject with moderate experience. From the highly
skillful subjects, we randomly picked one from each group as the
leader to fill in the short survey form during the experiment.
We only include Linux kernel vulnerabilities in the experiment
because the Linux kernel is fully open-sourced and thus we avoid
introducing the reverse engineering skillset which is noise to our
experiment. While conducting the user study, it is possible that
some participants have already established the prior knowledge for
some Linux kernel vulnerabilities or already known some public
exploits that leverage elastic objects to bypass KASLR. As a result,
to prevent the measurement bias introduced by these prior knowl-
edge, we design our kernel vulnerability sets without those kernel
vulnerabilities that already covered by the participants’ knowledge
base (Question 6 in self-assessment form, Figure 6). In the the first
row of Table 9, we list the 5 vulnerabilities satisfying our selection
criteria.
For both groups, we first gave the 5 vulnerabilities and their
corresponding PoCs that trigger the vulnerabilities but not perform
exploitation. Then, we asked both groups to develop exploits to
bypass KASLR by using the exploitation method mentioned in this
paper. We provided the kernel objects with function pointer for the
two groups to help them leak the base address. For Group A, we
also equipped them with our tool ELOISE, which assists them in
Cache
Struct
kmem.32
i40e_nvm_access
Potential
FreeBSD
H
kmalloc-8
kmalloc-16
kmalloc-32
kmalloc-192
ipv6_opt_hdr
ldt_struct
ip_options⋆
fb_info
ip_sf_socklist⋆
cache_reader †
cfg80211_scan_request⋆
mbuf
mbuf
Linux
H
H & A
anchor1: H
anchor2: S
H
H
H
H & A
XNU
H
Privilege
Constraints
∅
∅
∅
∅
∅
∅
NET_ADMIN
NET_ADMIN
[12, 16) < 4097
[1, 2) < Arg
[8, 12) < 65536
anchor1: [8, 9) < Arg
anchor2: [8, 9) (cid:44) 0
[768, 776) = kaddr
[4, 8) (cid:44) 0
[0, 8) (cid:44) cache_detail.20
[24, 32) (cid:44) null
∅
∅
Table 1: Elastic kernel objects sampled from Table 4∼6. The
“Potential” column specifies the potential that the object
provides for a vulnerability. H and S indicate the potential of
leaking data from the heap and stack region, respectively. A
indicates the potential of performing arbitrary kernel read.
In the “constraints” column, ∅ denotes data disclosure im-
poses no critical constraints. Arg represents a system call ar-
gument under a user’s control; kaddr stands for any valid ker-
nel address; cache_detail.20 indicates the 20th field of the vari-
able in the type of struct cache_detail.
searching elastic objects and pairing vulnerabilities with objects
accordingly.
In this experiment, we kept track of the performance of two
groups through short surveys every 30 minutes and thus evaluated
the utility of ELOISE both quantitatively and qualitatively. As is
shown in Figure 7, the survey partitions an exploit development
into 3 critical stages – ❶ vulnerability capability exploration, ❷
elastic object identification, ❸ memory layout manipulation. While
receiving the survey, the participants need to specify the stage of
their exploit development and report their progress at that stage.
This short survey could be completed in one minute without in-
tervening the exploitation development too much. If completing
one stage of exploit development, the participants also need to
turn in their results. From the response to the survey inquiry, we
roughly measured the time spent at each stage and thus quantify
the utility of ELOISE. At the end of the user study, we also handed
out a post-test survey (see Figure 8) through which we qualitatively
evaluate the utility of ELOISE and understand the challenges in
exploit development. Due to the space limit, we leave the three
survey forms in Appendix A.5.
5.2 Results of Experiment I
Falsely identified & missing elastic objects (FP/FN). By using
ELOISE, we track down 97 elastic kernel objects tied to 98 disclo-
sure functions on Linux, FreeBSD, and XNU. We compare these
objects and disclosure functions with those randomly sampled and
manually confirmed. We find our manually audited objects and dis-
closure functions are a subset of those pinpointed by ELOISE. This
discovery cannot directly conclude zero false negatives because
the kernel’s scale limits our ability to manually audit all objects.
However, it implies the false negatives of ELOISE are minimal.
For 97 kernel objects that ELOISE identifies, we confirm 74 as the
true positives, which indicates the false positives are moderate, and
the reporting results of our proposed method is valuable. For those
falsely identified elastic objects, we further explore the root cause
and discover the false positives root in the inaccurate kernel call
graph construction. For example, for the kernel objects probe_resp
(cid:44)→ and ctl_table, the allocation of which can only occur in the
functions ieee80211_set_probe_resp() and register_leaf_sysctl_tables
(cid:44)→ () when hardware devices are plugged in, ELOISE mistakenly
links these objects with unprivileged system calls.
Objects’ exploitability & pervasiveness. For the elastic kernel
objects surviving from our examination (i.e., true positives), we
sample a small amount from Table 4∼6 and list them in Table 1. The
results in both tables specify the kind of exploitation the elastic ob-
ject could potentially facilitate. As we can observe from Table 4∼6,
for nearly all kernel objects identified (70 out of 74), they can po-
tentially facilitate a vulnerability to disclose data from kernel heap
and thus bypass exploitation mitigations such as KASLR and heap
cookie protector. For 28 elastic kernel objects, we observe they can
potentially perform arbitrary kernel read because these objects
enclose both the length field and a pointer referencing the elastic
buffer. For a small number of elastic objects (5 out of 74), they can
provide a vulnerability with the potential to overread data from
kernel stack and thus leak stack canary accordingly. By manually
examining kernel code, we note that Linux, FreeBSD, and XNU
use these kernel objects widely (with 39,483, 44,956, and 22,307
sites allocating or using one of these objects in Linux, FreeBSD,
and XNU, respectively). Following all these observations, we safely
conclude the elastic kernel objects and their usage are pervasive in
three different kernels.
Elastic objects that require high privilege. In Table 1, 4, 5 and 6,
we also specify the privilege needed for reaching out to these ob-
jects. As we can observe, most of the elastic kernel objects (60 out of
74) require no permission for allocation and information disclosure
(indicated by ∅ in the table). For the remaining kernel objects, either
their allocation or consecutive information disclosure requires the
privilege such as CAP_NET_ADMIN or CAP_AUDIT_READ. By default,
the kernel does not grant both of these permissions to an ordinary
user. However, this does not mean these objects are not helpful
for exploitation because a recent research [13] has already demon-
strated that an ordinary user can create a user namespace and thus
naturally bypass the permission check accordingly.
Objects’ cache/zone coverage. In Table 1, 4, 5 and 6, we also
categorize the elastic kernel objects based on the cache or zone to
which they belong. As we can observe from Table 4∼6, the identified
objects cover most of the general and some special caches/zones
(e.g., kmalloc-16384 in Linux, mbuf in FreeBSD, and pipe_zone in XNU).
For some objects that enclose the elastic buffer, their size can vary.
Therefore, the kernel can allocate them to general caches/zones
with the size greater than that specified in the table. In Table 1, 4, 5
and 6, we also highlight these objects with a star symbol. These
cache/zone-flexible kernel objects (18 out of 74) could significantly
enrich the availability of kernel objects for exploitation and thus
potentially escalate the exploitability of a vulnerability.
Constraints tied to objects & their security implication. In
Table 1, 4, 5, and 6, we finally specify the constraint set that one
has to satisfy in order for disclosing kernel data to the userland
successfully. As we can observe, there are only one kernel object
ip_options that contains more than one set of constraints tied to
different leaking anchors. It indicates that, except for this object,
every elastic object discloses kernel data from only one leaking
CVE-ID or
Syzkaller-ID
2016-1887
bf96...[74]
2018-6555
2018-5703
2017-8890
2017-7533
2017-15649
2019-8605
2017-2370
Capability