29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52 }
}
Fig. 1.
Java Code for the Running Example
even though the malicious app is not granted with the related
permissions.
B. Problem Statement
Fig. 2. Deployment of AppSealer
patch can serve as a permanent solution for most cases (if not
all).
In addition, it is also possible to deploy our technique
with more ad-hoc schemes. For instance, an enterprise can
maintain its private app repository and security service too.
The enterprise service conducts vetting and necessary patching
before an app gets into the internal app pool, and thus
employees are protected from vulnerable apps. Alternatively,
establishing third-party public services and repositories is also
viable and can beneﬁt end users.
Speciﬁcally, we would like to achieve the following design
goals:
•
•
No source code access. Our technique should not re-
quire the application source code for patch generation.
It is particularly important for Android ecosystem,
because the developers only submit the executables
(in form of .APK ﬁles) to the marketplace.
Vulnerability-speciﬁc patching. The generated patch
using our technique should effectively disable the
vulnerability as a whole, not just a particular set of
exploitation instances.
• Minimal performance overhead. The extra perfor-
mance overhead induced by the patch should be min-
imal, such that the user experience is not affected. In
the context of patch generation, it means that the in-
serted instructions (as the patch) should be minimally
necessary to ﬁx the vulnerability.
• Minimal impact on usability. The normal operations
on the patched app should remain intact. The inter-
vention introduced in the patch should only take place
while an attack is about to take into effect.
We anticipate our proposed technique to be deployed as a
security service in the Android marketplace, as illustrated in
Figure 2. Both the existing apps and the newly submitted apps
must go through the vetting process by using static analysis
tools like CHEX [5]. If a component hijacking vulnerability
is discovered in an app, its developer will be notiﬁed, and a
patch will be automatically generated to disable the discovered
vulnerability. So the vulnerable apps will never reach the end
users. This approach wins time for the developer to come up
with a more fundamental solution to the discovered security
problem. Even if the developer does not have enough skills to
ﬁx the problem or is not willing to, the automatically generated
C. Approach Overview
Figure 3 depicts the workﬂow of our automatic patch
generation technique. It takes the following steps:
(1) IR Translation. An Android app generally consists of
a Dalvik bytecode executable ﬁle, manifest ﬁles, native
libraries, and other resources. Our patch generation is per-
formed on the Dalvik bytecode program. So the other ﬁles
remain the same, and will be repackaged into the new app
in the last step. To facilitate the subsequent static analysis,
code insertion, and code optimization, we ﬁrst translate
Dalvik bytecode into an Intermediate Representation (IR).
3
Android App MarketIn-Cloud App Inspection & PatchingReportPatchingEnd UserVulnerable App VSubmissionDeveloper BGood App GPatched  V’Original GInstallDeveloper AFig. 3. Architecture of AppSealer
In particular, we ﬁrst convert the DEX into Java bytecode
program using dex2jar [16], and then using Soot [15],
translate the Java bytecode into Jimple IR.
(2) Slice Computation. On Jimple IR, we perform ﬂow-
sensitive context-sensitive inter-procedural dataﬂow anal-
ysis to discover component hijacking ﬂows. We track
the propagation of certain “tainted” sensitive information
from sources like internal data storage and exposed in-
terfaces, and detect if the tainted information propagates
into the dangerous data sinks. By performing both forward
dataﬂow analysis and backward slicing, we compute one
or more program slices that directly contribute to the
dangerous information ﬂow. To distinguish with other
kinds of program slices, we call this slice taint slice, as it
includes only the program statements that are involved in
the taint propagation from a source to a sink.
(3) Patch Statement Placement. With the guidance of the
computed taint slices, we place shadow statements into
the IR program. The inserted shadow statements serve
as runtime checks to actually keep track of the taint
propagation while the Android application is running. In
addition, guarding statements are also placed at the sinks
to block dangerous information ﬂow right on site.
(4) Patch Statement Optimization. We further optimize the
inserted patch statements. This is to remove the redundant
statements that are inserted from the previous step. As
Soot’s built-in optimizations do not apply well on these
patch statements, we devise three custom optimization
techniques to safely manipulate the statements and remove
redundant ones. Thereafter, the optimized code is now
amenable to the built-in optimizations. Consequently, after
going through both custom and built-in optimizations, the
added patch statements can be reduced to the minimum,
ensuring the best performance of the patched bytecode
program.
(5) Bytecode Generation. At last, we convert the modiﬁed
Jimple IR into a new package (.APK ﬁle). To do so,
we translate the Jimple IR to Java package using Soot,
and then re-target Java bytecode to Dalvik bytecode using
Android SDK. In the end, we repackage the patched DEX
ﬁle with old resources and create the new .APK ﬁle.
III. TAINT SLICE COMPUTATION
Taking a Jimple IR program and the sources and sinks
speciﬁed in the security policies as input, our application-
wide dataﬂow analysis will output one or more taint slices
for dangerous information ﬂows. Our analysis takes the fol-
4
lowing steps: 1) we locate the information sources in the IR
program, and starting from each source, we perform forward
dataﬂow analysis to generate a taint propagation graph; 2) if
a corresponding sink is found in this taint propagation graph,
we perform backward dependency analysis from the sink node
and generate a taint slice.
A. Forward Dataﬂow Analysis
For each identiﬁed taint source, we perform context-
sensitive ﬂow-sensitive forward dataﬂow analysis to generate
a taint propagation graph. This application-wide dataﬂow
analysis leverages intra-procedural def-use chain analysis and
call graph analysis, which are provided in Soot. The basic
algorithm is fairly standard and similar to other static dataﬂow
analysis systems, such as CHEX [5]. In comparison, our anal-
ysis serves as the foundation for automatic patch generation,
and thus needs to be conservative and complete.
Basic Algorithm. More concretely, the algorithm proceeds
as follows. For each located taint source, we perform def-
use chain analysis to identify how this taint propagates in
the hosting function. If a function call is identiﬁed to be
included in this def-use chain, we further perform def-use
chain analysis within the callee function. If the callee function
is an API, we will apply our pre-deﬁned Android API model.
After completing def-use chain analysis for one function, its
return value, “this” pointer, some class members, and/or some
function parameters, may be identiﬁed to be tainted. In this
case, we will pass this result back to the caller function, and
def-use chain analysis will resume in the context of caller
function. Therefore, this analysis process is recursive in nature.
Special Considerations for Android Apps. To ensure com-
pleteness in our dataﬂow analysis, we have several special
considerations for analyzing Android applications, due to their
object-oriented and event-driven characteristics.
Static ﬁeld, serving as global variable in Java, can be
shared by multiple methods for asynchronous communication.
In order not to miss the information ﬂow through shared global
region, we conservatively treat all the tainted static ﬁelds as
new sources. Though this may yield false positives for analysis,
our inserted runtime checks will guarantee the correct order of
“set” and “get” operations, eliminating the uncertainty during
patch generation phase.
Instance ﬁeld, unlike a static ﬁeld,
is only accessible
through one certain instance object. In a sense, an instance
TranslationTaint Slice ComputationPatch Statement PlacementPatch OptimizationCodeGenerationIRSlicesNew IROptimized IRdexResourcesdexVulnerable AppPatched AppResourcesﬁeld in Java is analogous to a structure ﬁeld of a heap
object in C. Although it is possible to statically distinguish
certain accesses to an instance ﬁeld of two different instance
objects by performing pointer analysis, it is rather difﬁcult
for Android applications. For each Android application, a
signiﬁcant portion of the program execution is actually done
by the Android framework. The application only serves as a
“plug-in” to this framework. The analysis result that is only
based on the application code will not be complete and correct.
In this work, we adopt a rather simple memory model. That
is, any access to an instance ﬁeld of an object may reﬂect
to all the objects of the same class. Again, we take a simple
but conservative analysis approach, and the subsequent patch
generation can ensure the correctness of information ﬂow
detection. Notice that the primitive wrapper class (e.g., Byte,
Integer, etc.) and their combination such as String or Integer
array essentially also contain instance ﬁelds. However, static
analysis on bytecode level does not see their internal ﬁelds
and always treats them as atomic primitive types. Therefore,
this simple memory model does not apply to them and will
not cause false positives.
Intent
is a unique feature in Android applications for
message passing, and thus a possible medium for propagating
information. Explicit Intents are used for inter-class commu-
nications. The sender class can create an explicit Intent by
specifying the name of receiver class, and trigger the receiver
with the Intent via for example startActivity(Intent) or
startActivityForResult(Intent, int). As long as the
receiver’s name is resolvable, the subsequent calling sequence
can be determined statically. Otherwise, we conservatively
consider all the potential targets, reading Intent information
via Intent.getData() or Intent.getExtras(), as prop-
agation destinations. Implicit Intents are used to broadcast. The
manifest.xml, which speciﬁes the registration of BroadcastRe-
ceiver, thus helps construct the relationship between sender and
receiver. Senders and listeners of Android components are so
far handled manually. It is possible to leverage prior work [17]
for better target resolution.
Class inheritance is an object-oriented feature, which al-
lows method overriding. Again, it requires points-to analysis
to determine the type of object instance and thus the call
target. In practice, we leverage Soot’s capability to do call-
graph analysis, which performs class hierarchy analysis. We
then conservatively go through all the possible call targets for
data propagation.
Thread is not unique to Android but needs special consid-
erations. The calling convention for Thread is that, while the
caller makes a call to Thread.start(), the control is passed
over to a corresponding Thread.run(). Therefore, we need
to consider the start-run pair and handle this case in call-graph
analysis.
B. Backward Dependency Analysis
After one or more sinks are identiﬁed in the taint prop-
agation graph, we further remove the nodes that can reach
none of the sink nodes. To do that, we ﬁrst compute a reverse
graph and then start from each sink node to traverse the graph.
After traversal, any unvisited nodes will be removed from the
original graph. In this way, we compute the taint slice, which
encompasses all the IR statements involved in the dangerous
information ﬂow from a given source to a given sink.
C. Running Example
Figure 4 illustrates the taint slices for the running example,
after using both forward dataﬂow analysis and backward
dependency analysis. There are two slices in this graph,
each one of which represents the data propagation of one
source. The left branch describes the taint propagation of
“gps” information, which originates from the invocation of
getLastKnownLocation(). The data is then saved to a
static ﬁeld location, before a series of long-to-string and
string-to-bytearray conversions in onDestroy(). Converted
byte array is further passed to crypt() for byte-level en-
cryption. The right branch begins with Intent receiving in
onCreate(). The piggybacked “url” data is thus extracted
from the Intent and stored into an instance ﬁeld addr.
The two branches converge at post(String,byte[]),
when both the encrypted byte array and “addr” string are
fed into the two parameters, respectively. “addr” string is
used to construct an URL,
then a connection, and fur-
ther an OutputStream object, while the byte array serves
as the payload.
In the end, both sources ﬂow into the
sink OutputStream.write(byte[],int,int), which
sends the payload to the designated address.
IV. PATCH STATEMENT PLACEMENT
With taint slices in hand, we have a big picture of how
the taint may propagate within the program. The next step
is to place patch statements with the guidance of the taint
slices. We ﬁrst brieﬂy introduce our tainting policy. Then we
describe how we create shadow variables to record taint status
for different kinds of data variables in the program. Finally,
we explain how to place shadow instructions to keep track of
taint propagation at runtime and block the dangerous tainted
information at the sink nodes.
A. Tainting Policy
We adopt a tainting policy similar to the one in Taint-
Droid [18], striking a balance between precision and per-
formance. However, a key difference between our technique
and TaintDroid is that our technique directly modiﬁes the
bytecode program to keep track of selected tainted information,
whereas TaintDroid modiﬁes the Dalvik Virtual Machine to
monitor taint propagation on the execution of every single
Dalvik instruction. To be more speciﬁc, we aim to monitor
dangerous information ﬂow on multiple granularity levels: we
perform variable-level tainting for local variables and objects,
ﬁeld-level tainting for instance and static ﬁelds, message-level
tainting for IPC and ﬁle-level tainting for external storage. In
other words, we store one shadow variable (taint status) for
each single local variable, ﬁeld, message or ﬁle. In addition, we
store one shadow variable for entire array, in order to achieve
memory efﬁciency. We also support table lookup, meaning if
either an array base b or an array index i is tainted, and an
element is obtained from b[i], this element is also tainted.
For structural objects, such as Vector, Hashtable, etc,
we model corresponding APIs for taint propagations. Further
discussion is in Section IV-D.
5
Fig. 4. Taint Slices for the Running Example.
B. Creating Shadow Variables
In order to keep track of taint propagation at runtime,
we need to create a shadow for each data entity that may