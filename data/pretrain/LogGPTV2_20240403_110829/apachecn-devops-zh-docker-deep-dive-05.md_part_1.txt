## 五、Docker 引擎
在这一章中，我们将快速浏览一下 Docker 引擎的引擎盖。
您可以使用 Docker，而无需了解我们将在本章中介绍的任何内容。所以，请随意跳过它。然而，要成为真正的大师，你需要了解幕后发生了什么。所以，要成为一个真正的 Docker 师傅，你需要知道本章的内容。
这将是一个基于理论的章节，没有动手练习。
由于这一章是本书**技术部分**的一部分，我们将采用三层方法，将这一章分为三个部分:
*   **TLDR:排队喝咖啡时，你可以快速阅读两三段文字**
*   **深潜:**我们进入细节的真正长的部分
*   **命令:**快速回顾一下我们学习的命令
让我们去了解一下 Docker 引擎吧！
### 对接引擎 tldr
*Docker 引擎*是运行和管理容器的核心软件。我们通常简称它为*Docker*。如果您对 VMware 略知一二，那么将其视为 ESXi 可能会有所帮助。
Docker 引擎采用模块化设计，由许多小型专业工具构建而成。在可能的情况下，这些标准基于开放标准，如开放容器倡议(OCI)所维护的标准。
从很多方面来说，Docker Engine 就像一台汽车发动机——两者都是模块化的，并且是通过连接许多小的专门部件而创建的:
*   汽车发动机是由许多专门的零件组成的，这些零件一起工作来驱动汽车——进气歧管、节气门体、气缸、火花塞、排气歧管等。
*   Docker 引擎是由许多专门的工具组成的，这些工具协同工作来创建和运行容器——API、执行驱动程序、运行时、垫片等。
在撰写本文时，组成 Docker 引擎的主要组件有: *Docker 守护程序*、*容器*、 *runc* ，以及网络和存储等各种插件。这些一起创建和运行容器。
图 5.1 显示了一个高级视图。
![Figure 5.1](img/figure5-1.png)
Figure 5.1
在整本书中，我们会用小写的“r”和“c”来指代`runc`和`containerd`。这意味着以`runc`或`containerd`开头的句子不会以大写字母开头。这是故意的，不是错误。
### Docker 引擎-深潜
当 Docker 首次发布时，Docker 引擎有两个主要组件:
*   Docker 守护进程(以下简称为“守护进程”)
*   LXC
Docker 守护程序是一个整体的二进制文件。它包含了 Docker 客户端、Docker API、容器运行时、映像构建的所有代码，还有更多。
LXC 为守护进程提供了对 Linux 内核中存在的容器的基本构造块的访问。像*命名空间*和*控制组(cggroups)*这样的东西。
图 5.2。展示了守护进程、LXC 和操作系统在 Docker 的旧版本中是如何交互的。
![Figure 5.2 Original Docker architecture](img/figure5-2.png)
Figure 5.2 Original Docker architecture
#### 摆脱 LXC
对 LXC 的依赖从一开始就是一个问题。
首先，LXC 是特定于 Linux 的。对于一个渴望成为多平台的项目来说，这是一个问题。
其次，依赖外部工具完成如此核心的项目是一个巨大的风险，可能会阻碍发展。
因此，多克。公司开发了他们自己的名为 *libcontainer* 的工具来代替 LXC。 *libcontainer* 的目标是成为一个平台无关的工具，为 Docker 提供对主机内核中存在的基本容器构建块的访问。
Libcontainer 取代 LXC 成为 Docker 0.9 中默认的*执行驱动程序*。
#### 摆脱单一的 Docker 守护进程
随着时间的推移，Docker 守护进程的整体性变得越来越成问题:
1.  很难创新
2.  它变得更慢了
3.  这不是生态系统想要的
Docker，Inc .意识到了这些挑战，并开始了一项巨大的努力来分解单体守护进程并将其模块化。这项工作的目的是从守护进程中分离出尽可能多的功能，并在较小的专用工具中重新实现它。这些专用工具可以换出，也可以很容易地被第三方重用来构建其他工具。这个计划遵循了久经考验的 Unix 哲学，即构建可以拼凑成更大工具的小型专用工具。
分解和重新分解 Docker 引擎的工作已经将所有的*容器执行*和容器*运行时*代码从守护进程中完全移除，并重构为小的专用工具。
图 5.3 显示了当前 Docker 引擎架构的高级视图，并附有简要描述。
![Figure 5.3](img/figure5-3.png)
Figure 5.3
#### 开放式容器倡议的影响(OCI)
当 Docker，Inc .正在分解守护进程并重构代码时， [OCI](https://www.opencontainers.org/) 正在定义两个与容器相关的规范(也称为标准):
1.  [映像规格](https://github.com/opencontainers/image-spec)
2.  [容器运行时间规格](https://github.com/opencontainers/runtime-spec)
这两个规范都是在 2017 年 7 月作为 1.0 版本发布的，我们不应该看到太多的变化，因为稳定性是这里游戏的名字。最新的映像规范是 2017 年 11 月发布的 v1.0.1。最新的运行时规范是 2020 年 3 月发布的 v1.0.2。
Docker，Inc .大量参与创建这些规范，并贡献了大量代码。
截至 Docker 1.11(2016 年初)，Docker 引擎尽可能紧密地实现了 OCI 规范。例如，Docker 守护程序不再包含任何容器运行时代码—所有容器运行时代码都在一个独立的 OCI 兼容层中实现。默认情况下，Docker 对此使用 *runc* 。runc 是 OCI 容器运行时规范的*参考实现*。这是图 5.3 中的`runc`容器运行时层。
除此之外，Docker 引擎的*容器*组件确保 Docker 映像作为有效的 OCI 包呈现给 *runc* 。
#### runc
如前所述， *runc* 是 OCI 容器运行时规范的参考实现。Docker 公司大量参与了规范的定义和 runc 的开发。
如果你把其他东西都去掉，runc 是 libcontainer 的一个小的、轻量级的 CLI 包装器(记住 libcontainer 最初在早期的 Docker 架构中用主机操作系统代替了 LXC 作为接口层)。
runc 在生活中只有一个目的——创造容器。它非常擅长这个。而且要快！但是由于它是一个命令行界面包装器，它实际上是一个独立的容器运行时工具。这意味着您可以下载并构建二进制文件，您将拥有构建和使用 runc (OCI)容器所需的一切。但这是赤裸裸的，非常低级的，这意味着你将没有成熟的 Docker 引擎带来的丰富性。
我们有时称 runc 运行的层为“OCI 层”。见图 5.3。
您可以在以下网址查看 runc 版本信息:
*   https://github.com/opencontainers/runc/releases
#### 包含在内
作为将功能从 Docker 守护程序中剥离出来的努力的一部分，所有的容器执行逻辑都被剥离出来，并重构到一个名为 container der(发音为 container-dee)的新工具中。它一生的唯一目的是管理容器的生命周期运营。
containerd 可以作为 Linux 和 Windows 的守护程序，Docker 从 1.11 版本开始就在 Linux 上使用它。在 Docker 引擎栈中，containerd 位于守护进程和 OCI 层的 runc 之间。
如前所述，containerd 最初旨在小型、轻量级，并针对生命周期中的单一任务(容器生命周期操作)而设计。然而，随着时间的推移，它已经扩展并承担了更多的功能。像映像拉力、体积和网络。
增加更多功能的原因之一是为了在其他项目中更容易使用。例如，在像 Kubernetes 这样的项目中，containerd 做一些额外的事情是有益的，比如推拉映像。由于这些原因，containerd 现在不仅仅是简单的容器生命周期管理。然而，所有额外的功能都是模块化和可选的，这意味着您可以选择您想要的位。因此，在像 Kubernetes 这样的项目中包含 containerd 是可能的，但是只能包含项目需要的部分。
containerd 由 Docker 公司开发，并捐赠给云原生计算基金会(CNCF)。在撰写本文时，containerd 是一个完全毕业的 CNCF 项目，这意味着它是稳定的，并被认为已准备好投入生产。您可以在此处查看最新版本:
*   https://github.com/containerd/containerd/releases
#### 启动新容器(示例)
现在，我们已经看到了全局，也看到了一些历史，让我们走完创建新容器的过程。
启动容器的最常见方式是使用 Docker CLI。以下`docker container run`命令将基于`alpine:latest`映像启动一个简单的新容器。
```
$ docker container run --name ctr1 -it alpine:latest sh 
```
 `当您在 Docker CLI 中键入这样的命令时，Docker 客户端会将它们转换为适当的 API 负载，并将它们发布到 Docker 守护程序公开的 API 端点。
该应用编程接口在守护进程中实现，可以通过本地套接字或网络公开。在 Linux 上插座是`/var/run/docker.sock`，在 Windows 上是`\pipe\docker_engine`。
一旦守护程序收到创建新容器的命令，它就会调用 containerd。记住，守护进程不再包含任何代码来创建容器！
守护进程通过 CRUD 风格的应用编程接口通过 [gRPC](https://grpc.io/) 与容器进行通信。
不管它的名字是什么，容器实际上不能创建容器。它使用 *runc* 来做到这一点。它将所需的 Docker 映像转换成 OCI 包，并告诉 runc 使用它来创建一个新的容器。
runc 与 OS 内核接口，将创建容器(名称空间、cgroups 等)所需的所有构造集合在一起。).容器进程作为 runc 的子进程启动，一旦启动，runc 就会退出。
瞧啊。容器现在已启动。
该过程总结在图 5.4 中。
![Figure 5.4](img/figure5-4.png)
Figure 5.4
#### 这种模式的一个巨大好处是
从守护进程中移除启动和管理容器的所有逻辑和代码意味着整个容器运行时与 Docker 守护进程解耦。我们有时称之为“无 daemonless containers”，它使得在 Docker 守护程序上执行维护和升级而不影响正在运行的容器成为可能！
在旧模型中，所有容器运行时逻辑都在守护程序中实现，启动和停止守护程序会杀死主机上所有正在运行的容器。这在生产环境中是一个巨大的问题——尤其是当您考虑到 Docker 的新版本发布的频率时！每次守护程序升级都会杀死该主机上的所有容器，这可不好！
幸运的是，这不再是一个问题。
#### 这个垫片是怎么回事？
本章中的一些图表显示了一个垫片组件。
shim 是 daemonless 容器实现中不可或缺的一部分(我们刚才提到的将运行容器从守护进程中分离出来，例如守护进程升级)。
我们之前提到*容器*使用 runc 来创建新的容器。事实上，它为它创建的每个容器分叉一个 runc 的新实例。但是，一旦创建了每个容器，父 runc 进程就会退出。这意味着我们可以运行数百个容器，而不必运行数百个 runc 实例。
一旦容器的父 runc 进程退出，关联的 containerd-shim 进程就成为容器的父进程。shim 作为容器的父代执行的一些职责包括:
*   保持任何 STDIN 和 STDOUT 流打开，这样当守护进程重新启动时，容器不会因为管道关闭等原因而终止。
*   向守护进程报告容器的退出状态。
#### 如何在 Linux 上实现
在 Linux 系统上，我们讨论的组件被实现为单独的二进制文件，如下所示:
*   `dockerd`(Docker 守护程序)
*   `docker-containerd`(容器)
*   `docker-containerd-shim`(垫片)
*   `docker-runc`
通过在 Docker 主机上运行`ps`命令，您可以在 Linux 系统上看到所有这些。显然，只有当系统有运行的容器时，它们中的一些才会出现。
#### 守护进程有什么意义
随着所有的执行和运行时代码从守护进程中剥离出来，您可能会问这样一个问题:“守护进程中还剩下什么？”。
显然，随着越来越多的功能被剥离和模块化，这个问题的答案会随着时间的推移而改变。然而，在编写本文时，守护进程中仍然存在的一些主要功能包括:映像管理、映像构建、REST API、认证、安全性、核心网络和编排。
#### 保护客户端和守护进程的通信
让我们看一下如何通过网络保护守护进程来结束这一章。
Docker 实现了一个客户机-服务器模型。
*   客户端组件实现命令行界面
*   服务器(守护程序)组件实现功能，包括面向公共的 REST 应用编程接口
客户端在 Windows 上称为`docker` ( `docker.exe`)，守护进程在 Windows 上称为`dockerd` ( `dockerd.exe`)。默认安装将它们放在同一台主机上，并将其配置为通过本地 IPC 套接字进行通信:
*   `/var/run/docker.sock`在 Linux 上
*   `//./pipe/docker_engine`在窗户上
也可以将它们配置为通过网络进行通信。默认情况下，网络通信通过端口`2375/tcp`上不安全的 HTTP 套接字进行。
![Figure 5.5](img/figure5-5.png)
Figure 5.5
像这样不安全的配置可能适合实验室，但对其他任何东西来说都是不可接受的。