title:Resolving the Predicament of Android Custom Permissions
author:G&quot;uliz Seray Tuncay and
Soteris Demetriou and
Karan Ganju and
Carl A. Gunter
Resolving the Predicament
of Android Custom Permissions
G¨uliz Seray Tuncay, Soteris Demetriou, Karan Ganju, Carl A. Gunter
University of Illinois at Urbana-Champaign
{tuncay2, sdemetr2, kganju2, cgunter}@illinois.edu
Abstract—Android leverages a set of system permissions to
protect platform resources. At the same time, it allows untrusted
third-party applications to declare their own custom permissions
to regulate access to app components. However, Android treats
custom permissions the same way as system permissions even
though they are declared by entities of different trust levels. In
this work, we describe two new classes of vulnerabilities that arise
from the ‘predicament’ created by mixing system and custom
permissions in Android. These have been acknowledged as serious
security ﬂaws by Google and we demonstrate how they can be
exploited in practice to gain unauthorized access to platform
resources and to compromise popular Android apps. To address
the shortcomings of the system, we propose a new modular
design called Cusper for the Android permission model. Cusper
separates the management of system and custom permissions and
introduces a backward-compatible naming convention for custom
permissions to prevent custom permission spooﬁng. We validate
the correctness of Cusper by 1) introducing the ﬁrst formal
model of Android runtime permissions, 2) extending it to describe
Cusper, and 3) formally showing that key security properties
that can be violated in the current permission model are always
satisﬁed in Cusper. To demonstrate Cusper’s practicality, we
implemented it in the Android platform and showed that it is
both effective and efﬁcient.
I.
INTRODUCTION
Android’s permission model forms the security basis for
the critical operations that can be performed on the plat-
form by the apps. In a nutshell, the main purpose of this
model is to regulate access to platform and app resources,
which is achieved by utilizing a set of security labels, called
permissions. In order to protect the platform resources (e.g.,
microphone, Internet etc.), the platform uses system permis-
sions, which are a predeﬁned set of permissions introduced
by the platform itself. The permission model also provides
the platform with ﬁner-grained security as a means to protect
Inter-Process Communication (IPC) between different app or
system components. Speciﬁcally for this purpose, Android
introduces custom permissions: these are application-deﬁned
permissions which allow developers to regulate access to their
app components by other apps. In fact, the use of custom
permissions is very common among third-party applications.
According to our study on the top free apps on the Google
Network  and  Distributed  Systems  Security  (NDSS)  Symposium  2018 
18-21  February  2018,  San  Diego,  CA,  USA
ISBN  1-891562-49-5
http://dx.doi.org/10.14722/ndss.2018.23210
www.ndss-symposium.org
Play Store, 65% of the apps deﬁne custom permissions, while
70% request them for their operation.
Unfortunately, design ﬂaws and vulnerabilities in custom
permissions can completely compromise the security of IPC,
inevitably leading to exploits on third-party apps and the
platform itself. Previous work has consistently found custom
permissions to be problematic [30], [28], and as a response to
these studies, Google made an effort to address the identiﬁed
problems by releasing bug ﬁxes. However, similar vulnera-
bilities still exist even after Google patched this initial wave
of vulnerabilities. In this work, we present two classes of
attacks that exploit the vulnerabilities in custom permissions
to get unauthorized access to platform and app resources.
With one of our attacks, a malicious app can bypass the
user interaction requirements for acquiring dangerous system
permissions on Android versions that support runtime permis-
sions and stealthily access high-risk platform resources (e.g.,
camera, microphone etc.). With our other attack, a malicious
app can escalate its privileges to gain elevated access to the
protected components of other apps. We further demonstrate
how an adversary can utilize the aforementioned vulnerabilities
to target high proﬁle apps with millions of downloads, such
as CareZone and Skype, and access sensitive user data (e.g.,
medical conditions, insurance information) and functionalities
(e.g., VoIP calls). We have ofﬁcially reported these attacks to
Google, which acknowledged them as severe ﬂaws that need
to be addressed in the next versions of Android.
In our investigation of the Android permission model
and its respective source code, we observed that there is no
separation of trust between system and custom permissions
in the Android framework, which leads to the manifestation
of permission vulnerabilities; we call this failure to distin-
guish custom permissions in the system, the ‘predicament’
of custom permissions. First, system and custom permissions
are currently insufﬁciently isolated and they receive the same
kind of treatment from Android, which opens up opportunities
for malicious apps to utilize custom permissions to obtain
unauthorized access to platform resources. Second, there is
currently no enforced naming convention for when declaring
custom permissions—apps are allowed to declare custom per-
missions with any name they desire. This creates a confused
deputy problem where a privileged app’s protected resources
can be utilized by unauthorized apps that possess different
custom permissions declared with the same name as of the ones
used by the privileged app to protect its resources. In order to
systematically address these problems, we propose a design
and corresponding implementation which we call Cusper.
Cusper decouples the handling of custom permissions from
system permissions to prevent an adversary from escalating
their privileges and stealthily acquiring system resources. Ad-
ditionally, Cusper implements an OS-level naming convention
for custom permissions to prevent custom permission spooﬁng.
This is backward-compatible with existing apps and enables
the system to properly identify custom permissions according
to the developer signature of their deﬁner apps.
To prove the correctness of Cusper, one could employ
traditional analysis methods such as testing and static analysis.
However, these are typically insufﬁcient since they depend on
the analyst determining all possible test cases, a challenging
endeavor. In contrast, formal methods can be leveraged to build
models and verify that key properties are never violated in
a proposed system. In fact, previous work has already used
the latter approach to formally model the Android permission
model [20], [21], [29]. Unfortunately, the proposed formal
models are outdated since they correspond to the install time
permission model of Android. In order to verify the correctness
of Cusper, we build the ﬁrst formal model of the Android run-
time permission model using the Alloy speciﬁcation language.
Speciﬁcally, we model the data abstractions for permission-
related structures and the behavior of system operations (e.g.,
install, uninstall, update) that concern permissions for the
runtime model, which signiﬁcantly differ in terms of both
abstractions and behavior from the previous model. We found
that the original permission model violates two fundamental
security properties regarding access to app and platform re-
sources: 1) there should be no unauthorized component access,
and 2) there should be no access to high-risk (‘dangerous’)
platform resources without user’s consent. We leverage our for-
mal model to demonstrate the existence of vulnerabilities that
violate these invariants in the original permissions model and
show that, in contrast, Cusper always satisﬁes them. Finally, to
illustrate Cusper’s practicality, we implement it in Android and
show that it effectively resolves the identiﬁed vulnerabilities
while incurring a negligible overhead. Our contributions can
be summarized as follows:
1) We identify severe—as acknowledged by Google—
vulnerabilities in custom permissions and demon-
strate how they can be exploited in practice to ob-
tain unauthorized access to critical platform and app
resources.
2) We study the identiﬁed vulnerabilities in detail to un-
derstand the design ﬂaws leading to their occurrence,
and based on our observations, we propose a modular
design, Cusper, which aims to systematically eradi-
cate and prevent custom permission vulnerabilities.
3) We implement the ﬁrst formal model of the Android
runtime permission model, and formally prove the
correctness of Cusper.
4) We implement Cusper on Android and show that it
resolves the identiﬁed vulnerabilities effectively and
efﬁciently.
The rest of the paper is organized as follows: Section II
covers the background information. Section III presents our
analysis on the use of custom permissions by the most popular
apps on Google Play. Section IV describes our attacks that ex-
ploit the custom permission vulnerabilities. Section V presents
our design and implementation of Cusper. Section VI presents
our Alloy formal model of Android permissions. Section VIII
2
discusses related work on Android permissions. Finally, we
conclude the paper in Section IX.
II. BACKGROUND
In this section, we will cover the background on Android
permissions, IPC on Android, and formal veriﬁcation using
Alloy.
A. Android Permissions
In Android, each app runs as a separate Linux user within
its assigned sandbox with limited access to resources to ensure
the integrity of the system and the apps. When an app wishes
to use a resource outside its sandbox, it has to conform to
Android’s permission model and explicitly request it.
Permission Essentials. Android associates permissions with
protection levels depending on their severity. There are cur-
rently three protection levels in Android: normal, signature,
and dangerous. Normal permissions are used to protect re-
sources (e.g., Internet) that constitute very little risk to user’s
privacy or the operation of other apps; whereas dangerous
permissions are associated with very high risk operations (e.g.,
accessing a user’s contact list). Signature permissions protect
private resources of apps, where the requester can be granted
the permission only if it is signed with a matching certiﬁcate to
that of the deﬁner of the permission of interest. Additionally,
Android has permission groups that cluster permissions based
on their utility [4].
Before Android 6.0 (API level 23), all permissions were
granted at application installation time. However, starting with
version 6.0, Android adopted the runtime permission model,
where dangerous permissions are granted to an app at runtime
by the user the ﬁrst time they are used by this app, and the
user is given the ability to revoke these permissions to apps at
any time. Normal and signature permissions are still granted
at installation and cannot be revoked by the user. According to
the runtime model, if a dangerous permission in a permission
group is granted to an app, all the dangerous permissions in
that group will also be granted (if explicitly requested by the
app) in order to minimize user’s effort.
Custom Permissions. Third-party apps are allowed to deﬁne
new permissions on Android. These permissions, called custom
permissions, are used to protect an app’s own resources from
others. In order to deﬁne a new custom permission, an app
must provide a permission name and can optionally include
a permission group to which this permission belongs and
a description regarding the utility of the permission in its
manifest as shown in the lines 1 - 6 of Listing 1. Additionally,
in order to request a permission, an Android app needs to
declare the use of the permission by referring to it with its
name, as shown in line 8 of Listing 1. Furthermore, Android
allows applications to create custom permissions dynamically
via the use of the addPermission() API method. In order
for this method to work successfully, apps need to declare
permission trees in their manifest ﬁle which state the domain
name under which the dynamic permissions will be created.
Although it is suggested that reverse domain name notation
should be used for custom permission names, there is currently
Listing 1: Creating and requesting custom permissions
android:name="com.example.PERM_NAME"
android:protectionLevel="normal"
android:permissionGroup=
"android.permission-group.STORAGE">
1
2
3
4
5
6
7
8
no naming convention enforced by the system for custom per-
missions and apps can use any name they desire when creating
new custom permissions. One exception is that Android does
not allow two different permissions to coexist on the same
device if they have the same name; hence, installation of an
app which deﬁnes a permission with a name that belongs to an
existing permission on the device will be denied by the system.
Conventional use case for custom permissions is for apps to
deﬁne custom permissions with the signature protection level
so that only the apps that are signed with the same certiﬁcate
(e.g., apps that belong to the same developer) can utilize the
deﬁner app’s resources.
B. Inter-Component Communication
The Android operating system relies on IPC (also called
ICC on Android) in order to achieve re-usability. Here, we
present the details on how IPC is achieved and protected on
Android.
App Components. Android apps can comprise of four com-
ponents: activities, services, broadcast receivers, and con-
tent providers. Each of these components (except content
providers) can be an entry point to the apps. Activities are
components that present the user with a graphical user interface
to perform a single task. Services run in the background
to perform long-running operations with no user interface.
Broadcast receivers are used to receive broadcast messages
from the system or the other apps. Content providers allow
storing and sharing data between apps via a relational database
interface. Communication between components is achieved
through the Intent mechanism on Android. Intents are asyn-
chronous messages between components in the same app or
different apps that are used for activation of components.
IPC Security. Android ensures the security of IPC by utilizing
its permission model. When two components communicate,
both the caller and the callee can require the other party to
hold certain permissions for a successful communication. More
speciﬁcally, this protection can be achieved through the use of
custom permissions, which are used by app developers to re-
strict access to their components. For example, if a component
is protected with a signature permission, only the apps that are
signed with the same certiﬁcate as that of the component owner
can access it. Both third-party app developers and the system
rely on the correct operation of custom permissions for their
security; hence, it is of paramount importance to ensure the
security of custom permissions.
C. Formal Veriﬁcation via Alloy
Alloy is a declarative speciﬁcation language that is used
to model the behavior and structural constraints of complex
systems [1]. It provides a modeling tool called Alloy Analyzer
that operates based on ﬁrst-order (i.e., predicate) logic and
can be used to analyze formal models created with the Alloy
language.
Alloy Language. Statements in Alloy can be interpreted both
from object-oriented (OO) programming paradigm and from
set theory perspectives. Signature is a declaration of a schema,
which deﬁnes the vocabulary of the model. It is similar to
the concept of a class in OO paradigm and to a set in set
theory. It can consist of several ﬁelds, which are equivalent to
ﬁelds in OO paradigm and to relations from a set theoretical
perspective. Facts are global constraints to the model that
are always supposed to hold. Predicates deﬁne parametrized
constraints, which can be interpreted as operations that can
be performed in the model. Functions are expressions with
declaration parameters and they return a result based on the
parameters. Assertions are assumptions made on the model
and they can be validated via the Alloy analyzer. Addition-
ally, Alloy allows using multiplicity keywords as quantiﬁers
in quantiﬁed constraints: all (universal quantiﬁer), some
(existential quantiﬁer), lone (zero or one), one (exactly
one), no (zero). Also, it is possible to use some (or set
interchangeably), lone, and one for ﬁeld declarations in
signatures to indicate the number of elements a ﬁeld can take
and also for signature declarations to indicate the number of
elements that can belong to the set of the signature.
Alloy Analyzer. The Alloy Analyzer tool performs only ﬁnite
scope checks on the models. The analysis is sound since it can
never return false positives and is complete up to a scope as
the tool will never miss any counterexamples that are equal
or smaller than the speciﬁed scope. As in traditional model
checking, Alloy models are inﬁnite, that is, the speciﬁcation
dictates how the components of a system should behave
without any restrictions on their quantity. The analyzer also
provides automated analysis by allowing automatic generation
of examples that satisfy a given model as well as counterex-
amples to claims (i.e., assertions) that are expected to hold in
the model.
III. USE OF CUSTOM PERMISSIONS
Custom permissions provide security to IPC that apps
harness for their operation. They are utilized by app developers
to restrict access to components as per the sensitivity of
the protected resource. In this section, we investigate the
prevalence of custom permissions among the top free apps
on Google Play and showcase two high-proﬁle apps that we
selected to launch attacks on by exploiting the vulnerabilities
in custom permissions.
A. Prevalence
We collected 50 top free apps from each of the Google Play