# Shiro 权限绕过的历史线（下）
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x5 CVE-2020-13933
###  0x5.1 漏洞简介
影响版本: shiro
                org.apache.shiro
                shiro-web
                1.5.3
                org.apache.shiro
                shiro-spring
                1.5.3
Shiro配置,这个洞也是有限制的只能是ant的风格为单*号才可以:
    map.put("/hello/*", "authc");
        @ResponseBody
        @RequestMapping(value="/hello" +
                "" +
                "/{index}", method= RequestMethod.GET)
        public  String hello1(@PathVariable String index){
            return "Hello World"+ index.toString() + "!";
        }
###  0x5.3 漏洞演示
访问302，然后poc:
`/hello/%3bluanxie`
看到这个POC的时候，我当时就觉得我前面分析两个洞的时候，是不是漏了什么关键点没去分析。
然后最让我头疼的的是，为什么需要对`;`要编码才能利用成功,下面我们通过分析来复盘我们前两次学习过程出现的问题。
###  0x5.4 漏洞分析
断点依然是在上一次的修补点:
    org.apache.shiro.web.util.WebUtils#getPathWithinApplication
这里我们逐步跟进去，上一次我没跟`removeSemicolon`,
因为从函数名这个其实就是Shiro一直以来的操作，就是去除`;`号后面的内容,然后`normalize`,这个并没有很大问题。
然后函数返回的结果是这个:
本来应该获取到uri的是`/hello/`,然后因为最早的那个shiro-682的洞，所以会执行去掉末尾的斜杆。
                if (requestURI != null && !"/".equals(requestURI) && requestURI.endsWith("/")) {
                    requestURI = requestURI.substring(0, requestURI.length() - 1);
                }
变成了:`/hello`
首先通过，`Iterator var6 =
filterChainManager.getChainNames().iterator()`获取了我们定义的filter，进入do循环逐个取值给`pathPattern`
其实都没必要去看这个算法怎么做匹配的，因为`/hello/*`本来就不会匹配`/hello`,
那么这样,如果是这样呢,`map.put("/hello/", "authc");`,emm,在取出来进行匹配的时候，
就会被去掉`/`,那么我来多几个呗。
     map.put("/hello//", "authc");
稍微绕过了
这个时候我们就可以回头去读一下Shiro的匹配算法了。
> 首先是如果`pattern`和`path`开头不一样直接false
>
> 然后就是`StringUtils.tokenizeToStringArray`分割字符串得到数组
>
> 然后一个循环，比较，如果出现某数组字符串不匹配，除开`**`就会返回`false`
>
> 只要没有`**`出现的话，且字符串数组=1，就没那么复杂的解析过程，直接返回
>  
>  
>     pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator)
> : !path.endsWith(this.pathSeparator);
>  
>
> 如果pattern是以/结尾的话，那么是
> True,返回`path.endsWith(this.pathSeparator)`,这个时候path不是以`/`结尾的，所以最终也不匹配。
>
> 如果是`/*`的话，字符串数组>1,
>
> 那么最终会进入
>
> 
>
> 这个过程说明,`/hello/*`
> 可以匹配`/hello/`,但是没办法匹配到`/hello`,然后shiro又做了去除/处理，emmm，根本不可能构造出`/hello/`，构造出来也没啥可用的
>
>
> 但是如果是,`/hello/**`,这里就不返回false，直接跳到下面了，最终会返回True，没办法绕过。说明`/hello/**`可以匹配到`/hello`
其实来到这里我们就明白了，第一步通过`%3b`解码成`;`,然后以前的洞删掉了`/`,导致了bypass Shiro。
如果我们不用`%3b`,而是直接
那么`;`直接会被`request.getServletPath()`处理掉，从而变成了`/hello/aa`,被`/hello/**`这种ant所匹配，导致第一层都没办法绕过。(这个其实就是cve2020-1957的绕过思路呀！肯定是没办法的呀)
###  0x5.5 漏洞修复