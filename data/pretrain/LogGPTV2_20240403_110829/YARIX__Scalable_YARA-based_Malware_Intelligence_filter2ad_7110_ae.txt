study one rule that performed well and the three rules that
performed the worst and had no empty result, and discuss the
reasons and mitigations for their poor performance.
Case Studies. First, an example that performed well is a
YARA rule for the Retefe [16] banking trojan that matches 16
indexed samples. This rule consists of a single all of them
expression which requires 7 plain strings to be present
in the sample. All plain strings are of adequate length
and can thus be captured by YARIX. The longest of those
is "security add-trusted-cert -d -r trustRoot -k
/Library/Keychains/System.keychain %@".
Using YARIX with this string already yields the 16 actual
matches.
Next, an example that performed poorly is a rule for the
PlugX malware [29]. In this case YARIX ﬁltered a set of
12M candidates and a sequential YARA scan yielded merely
84 actual matches. The condition of the rule is of the form
x0 ∨ x1 ∨ x2 and x0 is {E8 00 00 00 00 58} at 0, which
requires the x86 instructions call 0x5 ; pop eax (“get pro-
gram counter” gadget) to be present at offset 0 of the sample.
Given that YARIX is offset-free and thus has to abstract from
the at constraint, any ﬁle that contains
E8 00 00 00, 00 00 00 00 or 00 00 00 58 will be a can-
didate for sequential YARA scanning. This is the case for
almost all 12M ﬁles and is thus the culprit of the problem.
After reverse-engineering the malware, we found that x1 and
x2 are used to capture the custom API importing scheme
of the malware. Both x1 and x2 are characteristic enough to
identify the malware, and hence, we removed x0 from the
condition. As a result, the index now yielded the 84 actual
matches, which is a perfect optimization.
Another bad performing example is a rule for the
Smokeloader malware [26] that delivered roughly 10M
candidate ﬁles, of which only 2 remained after sequen-
tial scanning. The root cause of this is the hex string
53 56 57 8B 7? 0C B? [4] E8 [4] 68 [4] 5?, which
checks for a sequence of x86 instructions. The problem here
is that YARIX can only handle the ﬁrst 4 bytes because of the
wildcards. This sequence 53 56 57 8B is the encoding of
push ebx ; push esi ; push edi; mov ??, i.e., a series
of pushes and moves. This is a common pattern found in
binaries and is responsible for almost all 10M candidates.
We reverse-engineered the Smokeloader samples of our
dataset and additionally acquired more samples and found
that the wildcards introduced by the authors do not seem to
be necessary. We thus hard-coded some of the offsets and
3552    30th USENIX Security Symposium
USENIX Association
String Type
Plain
Hex
Regex
Optimizable
99.48% (3616)
Optimizable
#
w/o null bytes
3635
99.09% (3602)
11753 99.83% (11380) 95.20% (11189)
91
93.41% (85)
92.31% (84)
Table 2: A breakdown of how removing null bytes affects
string optimizability. 31.13% of the rules contain plain strings,
30.13% hex strings, and 1.28% regular expressions.
constants, which reduced the set of candidates to 2. While
such hard-coding makes the rule less generic as it now can
be evaded by changing an offset, this is merely a theoretical
limitation as YARA rules are in general not resistant to
this kind of instruction-level obfuscation. In general, any
obfuscation or packing attempt to evade YARIX boils down
to evading YARA, as YARIX is both sound and complete.
Last, a rule for a dropper of the SnatchLoader [28] malware
has 3 matches, but YARIX only manages to narrow down the
search to roughly 7M samples. The rule consist of a single
3 of them expression where them refers to 4 hex strings.
Two of those strings have no streak of 4 consecutive bytes,
which is why YARIX simpliﬁes the expression to 1 of them.
One of the strings has only one streak which is the hex string
00 00 ff 24, which is responsible for all the 7M candidates.
After analyzing the malware, we found that all hex strings
by themselves are good and characteristic indications of the
custom self-written loader of the malware. We thus decided
to remove one of the hex strings that has no streak of 4 con-
secutive bytes, which simpliﬁed the expression to 2 of them.
This caused the number of candidates to drop to the 3 actual
matches.
Future Work. Another more general problem are UTF-
16 encoded (wide) strings, which are common in Windows
applications. YARIX faces the problem that wide strings are
mostly used in practice with code points that ﬁt into 8-bits,
which makes every second byte a null byte. Consider, for
example, the string nice which is 6E 69 63 65 in ASCII and
6E 00 69 00 63 00 65 00 in UTF-16LE. The 4-grams of
these strings suffer from entropy, as every second byte will
be a null byte and is thus more likely to be present in many
ﬁles as it can be compared to searching for the 2-grams of
an ASCII string. This could be solved by not indexing null
bytes completely. That is, during indexing and before query-
ing a posting list, all null bytes are removed. This would solve
the problem with UTF-16 strings and could potentially also
improve disk space as null bytes occur often in binary ﬁles.
However, stripping null bytes could also lead to cases where
not enough consecutive bytes are found in a hex string, for ex-
ample. We experimented with this idea on a subset of 100000
samples. Disk footprint was reduced by 46.84% compared
to ordinary indexing. Regarding the string optimizability, Ta-
ble 2 breaks down the types of the strings that are contained
in all rules and how the feasibility is affected. As expected,
hex strings are affected the most, while the other cases remain
rather unchanged by this optimization. We leave a thorough
evaluation of this idea as future work.
Overall, these ﬁndings make us believe that in practice
most YARA rules can be used with YARIX and it is feasible
in practice to convert YARA rules to practically equivalent
ones in case searches with YARIX require optimization. In
particular, if YARIX gets incorporated into an existing work-
ﬂow, the malware analysts can optimize a rule a priori as
opposed to modiﬁcations by a third person a posteriori. In
the future we plan to investigate to what extent rules can be
optimized in an automated fashion. For example, if we have
enough samples that match a rule, we could systematically
reason about whether or not all wildcards in a string are re-
quired if all the matched samples have the same byte at the
wildcard position. Similarly, YARIX could be used to auto-
matically generate YARA signatures for a malware family.
Given enough samples of the family, shared sequences of
bytes could be extracted and YARIX could quickly check if
these sequences do not appear in other samples.
6 Related Work
While there are other approaches tackling the problem of
searching content in large malware collections [30, 31] us-
ing ﬁle index technologies, none of these solutions support
YARA scanning. Additionally, these approaches show worse
performance in both disk space and index build time than
YARIX. Related efforts for improving YARA scalability such
as KLara [22] parallelize the YARA scans with distributed
computing techniques. Apart from being more resource de-
manding by nature, such efforts also do not offer the same
magnitude of speedup in practice (multiple TiB in 30 minutes
with KLara vs seconds with YARIX).
So far, academic efforts mainly aimed to improve the scal-
ability of malware analysis and malware detection. For ex-
ample, several sandboxes [7, 14, 38] provide a framework
that allows observing the dynamic behavior of malware in a
scalable fashion. Based on these efforts, various reﬁnements
focus on the scalability of analyzing special dynamic behav-
iors, such as evasive behavior [5, 25] or understanding the
obfuscation techniques of malware [9, 36]. Similarly, to ob-
tain a better picture of the malware landscape, related work
proposed scalable clustering [6,32] or malware triage [19,35]
approaches. Closer to our goal, scalable approaches to detect
special types of malware [23, 41, 42] have been proposed.
While there are a few scalable methodologies proposed that
operate statically [18,24], the majority of these efforts operate
in a dynamic analysis setting. Dynamic analysis has, however,
an inherent cost associated with it that cannot be compared
to our case, as we do not perform any execution or emulation
of the malware. Finally, also related are malware signature
generators [1, 8, 12] that automatically try to create (YARA)
rules for malware analysis. Our approach is orthogonal to
USENIX Association
30th USENIX Security Symposium    3553
these solutions and tackles a different problem, i.e., scaling
complex static malware signatures to large malware data sets.
One of our main contributions is a scalable and efﬁcient
search methodology that can be used with arbitrary rules spec-
iﬁed in YARA, a widely-used industry standard. We therefore
present the ﬁrst malware search methodology that retains full
compatibility to off-the-shelf YARA rules. Earlier attempts
to efﬁciently index malware have taken different directions
and lack such support. Hu et al. [17] propose a system called
Symantec Malware Indexing Tree (SMIT) that indexes mal-
ware using their function-call graphs. Function-call graphs
are a high-level abstraction of malware and thus creating and
processing them is relatively costly. Jin et al. [20] propose
BIGGREP, a ﬁle index for malware. The authors also use an
offset-free inverted n-gram index and a similar delta encod-
ing scheme. However, BIGGREP is restricted to plain n-gram
string search only and does not support any sort of rule lan-
guage (such as YARA) or more complex constructs (such as
regular expressions). That is, our contribution goes beyond
providing just an index. When looking at the index itself,
there are further differences between YARIX and BIGGREP.
First, we introduce ﬁle ID grouping, an effective compres-
sion methodology that reduces the disk footprint by over 45%
while maintaining search performance. Second, our optimal
variable length encoding is superior to the static 7-bit encod-
ing used by Jin et al.. The disk footprint reported by Jin et al.
is thus signiﬁcantly higher than ours. In BIGGREP, storing the
posting lists requires up to 700% of the disk space of the in-
dexed samples. With YARIX, we have shown that the expected
relative disk space for 232 samples is much smaller: 149.5%
without grouping and 74% with grouping. Third, the index
query time of YARIX outperforms the related work. Jin et
al. mention that querying the string \drivers\mrxcls.sys
requires 17.38 seconds, which only takes 0.8 seconds with
YARIX. When accounting for the fact that Jin et al. have in-
dexed 6 million fewer samples than we did, YARIX is over 26
times faster and thus poses a major improvement.
The challenge to efﬁciently compress indexes has been
explored in depth outside of the security community. Wang et
al. [37] give a complete overview of the different techniques
that have been developed in the past decades. Most of the
presented techniques are based on a simple variable delta
encoding [11] similar to our version, although we use the op-
timal bit encoding. The objective of these different methods
is, however, usually more targeted towards micro optimizing
the encoding and decoding. For example GroupVB [13] is
an optimized version of variable delta encoding that aims at
microarchitectural improvements to reduce branches taken
by the CPU. Another example is PForDelta [43] that works
by collecting blocks of deltas by choosing the smallest b in
the block such that a majority of the deltas can be encoded
in b bits. The optimized versions of PForDelta, i.e., NewP-
ForDelta [39], OptPforDelta [39], and SIMDPforDelta [27]
are based on the same compression principle and only aim at
encoding and decoding performance. This is different to our
ﬁle ID grouping method that is more targeted towards improv-
ing the disk footprint using a justiﬁable over-approximation.
Existing lossy index compression approaches mainly rely
on bloom ﬁlters, which however cannot be used to intersect
and thus reduce the set of search candidates across multiple
combined searches—a vital aspect of our novel grouping.
7 Conclusion
We presented YARIX, a novel YARA search engine that sig-
niﬁcantly optimizes searches for malware ﬁles with arbitrary
off-the-shelf YARA rules. We introduced a methodology to
convert YARA rules into search terms that can be fed to the
inverted n-gram index of YARIX to optimize YARA searches.
Our evaluation of YARIX demonstrates that its inverted n-
gram index can drastically reduce the ﬁles that have to be
scanned sequentially. At the same time, the index footprint is
reasonably small due to several compression techniques used
including a novel grouping-based compression scheme. That
is, while optimizing YARA searches by ﬁve orders of magni-
tude, only 74% of the accumulated disk space of all samples
is required to store the inverted n-gram index of YARIX.
Availability
The YARIX reference implementation can be obtained at
https://github.com/mbrengel/yarix.
Acknowledgments
We would like to thank the anonymous USENIX reviewers of
this paper as well as Giuliano Schneider, Benedikt Birtel and
the anonymous AEC reviewers for testing YARIX. We would
also like to thank VirusShare and our anonymous partners
from the AV industry who supplied us with malware samples.
Our thanks also goes to Veelasha Moonsamy for shepherding
this paper. Finally, we would like to thank Tillmann Werner
for initial brainstorming about the general problem in summer
2018. We apologize for neglecting your idea to use preﬁx
trees to solve this problem.
References
[1] Mohannad Alhanahnah, Qicheng Lin, Qiben Yan, Ning
Zhang, and Zhenxiang Chen. Efﬁcient Signature Gener-
ation for Classifying Cross-Architecture IoT Malware.
In Conference on Communications and Network Secu-
rity (CNS), 2018. doi:10.1109/cns.2018.8433203.
[2] Victor Manuel Alvarez. YARA – The pattern matching
swiss knife for malware researchers, 2020. URL: https:
//virustotal.github.io/yara/.
3554    30th USENIX Security Symposium
USENIX Association
[3] AV-TEST. Malware Statistics & Trends Report, 2020.
Last accessed at: June 19, 2020. URL: https://www.
av-test.org/en/statistics/malware/.
[4] Ricardo A. Baeza-Yates and Berthier Ribeiro-Neto.
Modern Information Retrieval. Addison-Wesley Long-
man Publishing Co., Inc., 1999.
[5] Davide Balzarotti, Marco Cova, Christoph Karlberger,
Christopher Kruegel, Engin Kirda, and Giovanni Vigna.
Efﬁcient Detection of Split Personalities in Malware.
In Proceedings of the Network and Distributed System
Security Symposium (NDSS), 2010.
[6] Ulrich Bayer, Paolo Milani Comparetti, and Engin Kirda.
Scalable, Behavior-Based Malware Clustering. In Pro-
ceedings of the Network and Distributed System Security
Symposium (NDSS), 2009.
[7] Ulrich Bayer, Imam Habibi, Davide Balzarotti, Engin
Kirda, and Christopher Kruegel. A View on Current Mal-
ware Behaviors. In Proceedings of the USENIX Work-
shop on Large-Scale Exploits and Emergent Threats
(USENIX LEET), 2009.
[8] Felix Bilstein and Daniel Plohman. YARA-Signator: