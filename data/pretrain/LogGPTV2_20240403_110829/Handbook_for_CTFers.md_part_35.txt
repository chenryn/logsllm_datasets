int v10; //[rsp+94h][rbp-1ch]
11
unsigned _int64 v11; // [rsp+9sh][rbp-18h]
13
v11 =
_readfsqword(ex28u);
14
strcpy(TRUE_ANS，"zpdt(Pxn_zxnd1_tnf_ddzbff1}");
15
memset(input, θ, sizeof(input));
16
v9=0;
17
printf("Input your answer:",argv,&v10);
18
len -strlen（input);
_isoc99_scanf（"%s",input);
19
28
if （1len = strlen(TRUE_AIS))
21
22
for（1 =θ;i122)
25
26
if（input[i]9θ]
27
enc=input[1];
28
else
29
enc =（102 *（input[] -65）+ 3） % 26+ 65;
30
31
else
33
enc=（102*（input[]-97)+3) %26+97;
35
34
if ( enc 1= TRUE_ANS[i])
36
37
puts(“urong answer!");
return 1;
48
41
puts("Congratulations!");
42
result =0;
43
1
44
45
else
puts(°Hrong input length1°);
result=1;
48
49
return result;
50}
Fig, 5.22 2-simpleCrackme.c pseudo code
---
## Page 333
5.2 Static Analysis
319
n-dod xL 's 8
shortcut
Hexadecinol
Octol
Chor.
R
Enun
M
Invert siqn
Bituise negote
Structure otfses
T
Edit conment
/
Edit block comnent
Ins
Hlde costs
1
uess allocotion
Structures ulth thls slze
Eont...
if（input[i]9θ）
enc = input[i];
else
.+9Zx（∈+（.v.-[]ndu）。99xe）=u
else
{
e,+9zx（∈+（.e.-[]ndu）99xθ）=u
if (enc I= TRUE_ANS[i])
Fig, 5.24 Pseudo code
• Hexadecimal: hexadecimal display, shortcut key is H, can convert from other
• Oetal: Octal display.
formats back to numbers.
Char: convert constant to a format like *A', shortcut is R.
•Enum: convert constant to a value in the enum, shortcut key is M.
• Invert sign: parse a constant into a negative number according to its complement,
the shortcut key is _-
• Bitwise negate: Invert a constant bitwise, like ~OxF0 in C. The shortcut is ~,
After manually converting the display format, the decompiled pseudo-code is more
consistent with the source code, as shown in Fig. 5.24.
HexRays shortcuts cannot be trigger sometimes, try using the right-click shortcut
menu when fails.
---
## Page 334
320
5  Reverse Engineering
5. Modify variable types
The challenge for this section is 2-simpleCrackme_O3. It is exponentially more
difficult to recover semantics after compiler optimizations. Even though HexRays is
extremely powerful, it often has problems when faced with complex compiler
soezndo
This section uses the executable file generated by GCC with O3 optimization.
The same source code can undergo a complex compiler optimization processs that
generates pseudocode that changes quite dramatically, see Fig. 5.25.
In fact, the original string assignment operation has become a 128-bit floating-
point assignment and 64-bit qword assignment and 32-bit dword assignment, so
HexRays identifies the string array as three variables: __m128i type v6,  _int64
type v7 and int type v8, resulting in poor readability of the generated pseudocode.
Hint: byte - 1-byte integer, 8 bits, char,  _int8.
word - 2-byte integer, 16 bits, short,  _int16.
dword - 4-byte integer, 32 bits, int,  _int32.
qword - 8-byte integer, 64 bits,  _int64, long long.
The variables v6, v7, and v8 are actually entire string arrays, The accuracy and
readability of decompilation is greatly improved if the user can specify the corect
type of variables.
HexRays takes full advantage of IDA's type analysis system described above.
Pressing Y on the identifier to be modified, bring up a dialog box and modify the
type. For this program, it is calculated that these three variables are actually a char
array of 28 (16+8+4) starting with v6, so the corresponding C type is char[28] (you
can omit the identifier in the type declaration).
So move the cursor over v6, and then press Y. Type “char[28]", and a confirma-
tion dialog box will pop up to see if it overwrites subsequent variables.
Renaming these variables again makes the pseudocode more readable, as shown
in Fig. 5.26.
HexRays supports not only type modification of local variables, but also param-
eter types, function prototypes, global variable types, etc. In fact, HexRays not only
o pue ss sua snsu ose q sd adus as soddns
C language types. Press Shift+F1 to bring up the Local Types window, from which
you can manipulate various types in C. Press Insert, or right-click to bring up the
Add Types dialog box, see Fig. 5.27. IDA will parse and store them. In addition, you
can load a C header file by pressing Ctrl+F9 or by selecting the “File  Load File 
Parse C header file? menu command.
After adding custom types you can using them when setting variable types.
HexRays will automatically perform parsing operations based on the type, such as
a suogeana Suskedsp ssoooe ponns Sukedsp
In the reverse process, various types may be misidentified, and we need to use our
experience with C programming to set variables such as constructs, normal pointers,
structure pointers, and integers correctly.
---
## Page 335
5.2 Static Analysis
321
int
R
_int64v3;//rs
unsigned int v4;// eax
int64v7;//[rsp+1eh][rbp-88h]
m128iv6;//[rsp+eh][rbp-98h]
Int v8//[rsp+18h][rbp-8oh]
8
]]]
int v10;//[rsp+8eh][rbp-18h]
eT
uns1gned
_int64v11;// [rsp+8sh][rbp-1eh]
11
0 12
v7-7377593711185585774LL;
v11 *
__readfsqword（ex28u);
13
14
fess00z8-8A
ST
v6 =_mm_load_si128((const
nemset（v9, 0,sizeof(v9));
16
017
printf_chk(ill,
v10=0;
18
isoc99_scanf("%s",v9);
“Input your answer:“,envp);
19
f（strlen（v9）127）
21
1
puts(*wrong input length1");
return 1;
24
25
v3 = θLL;
26
27
%
LOBYTE(v4)-V9[v3];
if ((unsigned _int8)(v4 ·97)@x19u )
8E 0
39
（s9 + mx %（∈ +（s9 -））zt） 1[]ztg ）
goto LABEL_4;
40
ABEL_9:
42
(_iJansue Suoum_)snd
44
return 1;
45LABEL_5:
46
++v3;
Fig, 5.25 2-simpleCrackme_O3 pseudo code
You can force an increase in the length of a variable type (change _m128 to char
[28] as described above) in HexRays, but changing a long variable type to a short
one will often result in the alarm °Sorry, can not change variable type" (For example,
changing the variable char[28] above back to char[27] will result in an error,). So
you need to be careful when lengthening variable types. If you inadvertently modify
---
## Page 336
322
5 Reverse Engineering
R
unsigned int enc; // eax
int64v3;//rsl
char TRUE_ANS[28];//[rsp+h][rbp-98h]
6
char input[96]; //[rsp+2oh][rbp-78h]
Intv8//[rsp+8oh][rbp-18h]
unsigned _int64 v9; // [rsp+88h] [rbp-1eh]
10
V9=
_readfsqword(ex28u);
11
012
fs[]ss（.）
nenset(ingut, 0, sizeof(input));
14
*(_m128i *)TRUE_AN5 =_mm_load_si128((comst _m128i *)8xmm
VB =0;
mmord_9Fe);
15
017
If（strlen(1nput)1=27)
isoc99_scanf（"%s",input);
18
19
20
puts("wrong Input length1°);
21
return 1;
22
2
V3 = 0LL;
25
do
26
[]and -（u）a
27
if （ (unsigned ints)(enc -*a*)  25u）
36
37
（,, + n9z x（∈ +(s9 - u(e>)) 。 9gxe) =1[c]sNanL ）
goto LABEL_4;
39|LABEL_9:
BE
puts("wrong answerI°);
41
42
return 1;
43|LABEL_5:
44
45
46
while （v3 1-28）;
puts(“Congratulatlons!");
49}
return e;
/
Fig, 5.26 2-simpleCrackme_O3
---
## Page 337
5.2  Static Analysis
323
eis
_ []
se_ist[s]_jx
Fig, 5.27 Local Types window
the error, you can delete the function and redefine the function to reset various
information about it.
6. complete the analysis
After fine-tuning the pseudo-code to a level which suitable for your reading, you can
start your analysis. Obviously, this program implements an affine code, and the
method for reversing it is simple enough. You can complete the decryption by
yourself.
5.2.3Advanced Use ofIDA andHexRays
The above describes the basic operation of IDA and HexRays, and the following
describes how to deal with some common problems.
1. How to find the main() function
Many executables do not start with the main() function in Windows or Linux. They
may initialized by the CRT (C runtime) and then go to the mainO function.
Tips for finding the main() function are as follows.
• The main) function is often in the front of the executable (because many linkers
deal with object files first).
•VC's entry point (IDA's start( ) function) will call the main( ) function directly,
and the function called in the start( ) function has three arguments, and the returm
value is passed to the exit( ) function.
• GCC passes the address of the mainO function to  _libc_start_main to call the
main) function, and you can find the address of the mainO function by looking at
the parameters of the call.
---
## Page 338
324
5Reverse Engineering
LIA Vier-k
Bar Yiea1
FiLe
Stote
Ffunc Library none
2wo64sbkgplied
SEH fer vo64 7-14
Fig, 5.28 List of applied library modales
brury funetion  Begular funetion  Instruetion  Data Unexplored External
etions vindov
5×
IDA Viev-A
Ion none
Seqnent
File
State
Looal_stdio_printf_options
Local_stdio_scanfoptians.
text
wo64sehApplied
.teut.
Fig, 5.29 Navigation bar
2. manually apply the FLIRT signature
In IDA, there is one type of functions that is different: functions that have a cyan
background color in the list of functions. These functions recognited by IDA's
FLIRT function signature recognition library.
Pressing Shift+F5 to open the Signature list, which shows the library of applied
function signatures, see Fig. 5.28. In fact, this file was generated by the VS2019
Preview, while IDA 7.0 was released in 2017, so it has poor support for the latest
version of VS (Fig. 5.29).
In fact, IDA can recognite most of the functions. Press Insert in the list of function
signature libraries, you can add new signature to match, see Fig. 5.30.
A large number of functions can be identified by applying the appropriate
function signature library as described, see Fig. 5.31.
3. Handle HexRays failure cases
The challenge accompanies this section is 3-UPX_packed_dump_SCY.exe.
HexRays often fails in various situations, especially for no symbol, highly
optimized programs. Most of the failures are caused by some parameters associated
with the function are set incorrectly, such as an error in the call convention of a
function, resulting in a failed parameter resolution or stack imbalance before and
after the call.
For example, if a  _stdcall function is mistakenly using the  _cdecl call
convention, whiches call convention clean up the parameter space in different
ways, causing problems when tracking stack pointers; If a _ _thiscall function is
mistakenly recognized as a __fastcall,the function will have an extra argument that
does not exist; For various reasons if a _ _fastcall function is incorrectly identified as
3 _cdecl function with one argument, the decompiler has cannot find the arguments
on the stack, since it is actually using register to pass parameter.
The following is a brief description of two scenarios.