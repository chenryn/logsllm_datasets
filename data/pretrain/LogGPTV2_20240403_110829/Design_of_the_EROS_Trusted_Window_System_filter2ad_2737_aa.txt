title:Design of the EROS Trusted Window System
author:Jonathan S. Shapiro and
John Vanderburgh and
Eric Northup and
David Chizmadia
USENIX Association
Proceedings of the
13th USENIX Security Symposium
San Diego, CA, USA
August 9–13, 2004
© 2004 by The USENIX Association
Phone: 1 510 528 8649
All Rights Reserved
FAX: 1 510 548 5738
Rights to individual papers remain with the author or the author's employer.
Email: PI:EMAIL
For more information about the USENIX Association:
WWW: http://www.usenix.org
 Permission is granted for noncommercial reproduction of the work for educational or research purposes.
This copyright notice must be included in the reproduced paper. USENIX acknowledges all trademarks herein.
Design of the EROS Trusted Window System
Jonathan S. Shapiro
PI:EMAIL
John Vanderburgh
PI:EMAIL
Eric Northup
David Chizmadia
PI:EMAIL
PI:EMAIL
Systems Research Laboratory
Johns Hopkins University
Promia, Inc.
Abstract
Window systems are the primary mediator of user input and output in modern computing systems. They are also
a commonly used interprocess communication mechanism. As a result, they play a key role in the enforcement
of security policies and the protection of sensitive information. A user typing a password or passphrase must
be assured that it is disclosed exclusively to the intended program. In highly secure systems, global policies
concerning information ﬂow restrictions must be honored. Most window systems today, including X11 and
Microsoft Windows, have carried forward the presumptive trust assumptions of the Xerox Alto from which
they were conceptually derived. These assumptions are inappropriate for modern computing environments.
In this paper, we present the design of a new trusted window system for the EROS capability-based operating
system. The EROS Window System (EWS) provides robust traceability of user volition and is capable (with
extension) of enforcing mandatory access controls. The entire implementation of EWS is less than 4,500 lines,
which is a factor of ten smaller than previous trusted window systems such as Trusted X, and well within the
range of what can feasibly be evaluated for high assurance.
1 Introduction
Window systems play a key role in modern computing
systems. They serve as the primary mediator of user input
and output, and provide an interprocess communication
mechanism (cut and paste) that is widely used and uni-
versally expected. Most modern window systems trace
their conceptual ancestry to the Xerox Alto [31]. In the
Alto design, applications are presumptively friendly and
the computer display is a single-user device. A basic goal
of the Alto design was to encourage cooperation among
applications in an environment of trust. These assump-
tions and goals are inherited by both the X Window Sys-
tem [27] and Microsoft Windows. Unfortunately, these
assumptions of trust are incompatible with even minimal
standards of security.
Window systems have direct access to sensitive informa-
tion, both in the form of sensitive input (e.g. passphrases)
and timing data. They implement critical paths in support
of selected trusted applications (e.g.
the login service).
They are necessarily party to the enforcement of global
information ﬂow restrictions when systemwide manda-
tory access controls are in effect. Current designs include
shared mutable resources, which are an obvious no-no,
and provide a remarkable amount of server-side resource
used to hold client data, creating a rich ﬁeld of opportu-
nity for storage denial of service. They perform opera-
tions that have high variance and observable latency, the
combination of which facilitates both timing denial of ser-
vice and covert channel construction. As a result, window
systems provide a wealth of vulnerabilities that attackers
can exploit – even in otherwise compartmentalized sys-
tems. Attention to security in their design is vital.
In the late 1980’s there was a ﬂurry of work on com-
partmented mode workstation (CMW) implementations.
Proceeding from requirements put forward by Mitre [33],
TRW developed Trusted X, an implementation of the X
Window System suitable for multilevel secure environ-
ments based on the CMW requirements [10]. This effort
identiﬁed both major and minor design ﬂaws in X, many
of which could not be ﬁxed compatibly and remain issues
today. Related work at Mitre was conducted as part of the
compartmented mode workstation effort [4, 20].
The CMW effort gave essentially no attention to poten-
tially hostile actions occurring within an MLS compart-
ment. As noted by Abrams [1], this is also true of the
Trusted Computer System Evaluation Criteria [7] and (in
our opinion) the Common Criteria [14]. Viewed in light
of current-day commercial threats, this ommission seems
problematic. Defense against a scripting virus that sim-
ulates a password request prompt or creates an exces-
sive number of windows falls outside of the scope of
most compartmentation strategies; these are problems of
trusted path and discretionary control. In today’s environ-
ment, it seems optimistic to assume that two applications
in a single mandatory access control domain are mutu-
ally friendly. The mandatory policy does not object to
information moving between these two processes, but it
would be useful to ensure positive conﬁrmation of user
intent: some identiﬁably authorizing action performed by
the user, such as a keystroke corresponding to a “paste”
It was an explicit goal of X Version 11 to specify
mechanism, not policy.
David Rosenthal, Inter-Client Communications
Conventions Manual [26]
Figure 1: X11 Design Philosophy
operation.
This paper presents the objectives, design, and analysis of
the EROS Window System (EWS). EWS is a new trusted
window system for the EROS capability-based operating
system. It is a “fresh start” design that provides robust
traceability of user volition and is capable (with minor ex-
tension) of enforcing mandatory access controls. Building
on the primitive mechanisms of the EROS operating sys-
tem, we have created a window system that is a factor
of ten smaller than previous trusted window systems such
as Trusted X. The implementation provides an efﬁcient,
double-buffered display system that signiﬁcantly reduces
the number of resources that must be managed by the dis-
play system, and ensures that all resources used in support
of a client session are allocated from client resources. The
implementation is under 4,500 lines of code. Future en-
hancements will include a high-performance 3D graphics
rendering pipeline comparable in performance to the di-
rect rendering [15] of X11 or Microsoft’s DirectX mech-
anism. This enhancement is not expected to signiﬁcantly
increase the size of the security-enforcing code.
2 Objectives and Overview
In their extensive security review of X11, Epstein and Pis-
ciotto [9] state that “Authentication is the most obvious
security problem with X.” In today’s commercial threat
environment, this characterization seems generous. The
most obvious security problem in X is the absence of pol-
icy of any sort (Figure 1). The goal of the X11 designers
was to maximize the ability of applications to interoper-
ate, partly to promote a new vision of computer interac-
tion. In the quest for a policy-free design, even the user
is disintermediated from control. Given a request for the
content of the paste buffer from an application, there is no
way that an X server can determine whether the user has
performed any action authorizing that paste. X assumes
not only that applications are cooperative, but that their
actions reﬂect the volition of the user. In a world of in-
creasingly hostile applications, this trust assumption has
become an unsupportable luxury.
EWS proceeds from the diametrically opposing position:
our goal is to ensure that the user is actively in the deci-
sion loop, and complete isolation between applications is
our default. Having adopted conﬁnement as a fundamen-
tal organizing principle within the EROS system, we are
unwilling to permit unrestricted information ﬂow at the
window system. Our goal is to ensure that any commu-
nication between window system clients is authorized by
both the user and the applicable mandatory control policy,
and that this communication proceeds only in the direc-
tion that the user and policy indicated. Capability sys-
tems provide natural underpinnings for direct manipula-
tion, which simpliﬁes secure user interface design [35].
That said, there is an enormous user investment in the id-
ioms of current window systems. In particular, the “cut
and paste” and “drag and drop” idioms are now univer-
sally adopted and expected. Users have become accus-
tomed to overlapping window systems, and to applica-
tions with closely coupled, render-intensive interaction
loops. Given this, we wished to create a window system
in which the “look and feel” of current usage idioms could
be largely preserved.
2.1 Principles and Goals
After reviewing the conclusions of Epstein and Piccioto,
we arrived at a list of design principles and goals for EWS:
R1. Isolation No operation performed on one
client session should be able to affect or ob-
serve state associated with other sessions – in
most cases, not even the state of subsessions.
R2. No Mutable Sharing The display server
should provide no shared mutable state to
clients.
R3. Minmize Server Resource Types The total
number of resource types managed and/or al-
located by the server should be minimized.
This is one aspect of overall complexity re-
duction.
R4. Minimize Algorithmic Complexity Many
graphics operations are complex and have
high variance. The number and complexity
of algorithms and data structures in the server
should be minimized.
R5. Restricted Communication The display
server should provide strictly limited inter-
process communication facilities. Provide
what is necessary to support current usabil-
ity idioms; nothing more.
R6. Volitional Traceability No communication
may occur between applications through the
display server unless we can demonstrate an
authorizing user action.
R7. Resource Conservatism The display server
should not enqueue either input requests or
events. Both promote resource denial of
service and covert channels. Output events
may be queued, but total output queue length
should be bounded. More generally,
the
display server should operate using only
bounded resources. Dynamically allocated
resources,
if any, should come from the
client.
R8. Small Size The display server should be
small enough to be evaluable. Our initial goal
was to achieve the 30,000 LOCC target of
Trusted X.
R9. Low Variance Each input event should be
delivered to exactly one recipient application,
and each operation should complete in ﬁxed,
small time. The display server should not
multiply messages. Similarly, each incoming
request should in general have one response.
When more than one response is necessary,
the total number should be a small constant
integer.
With three exceptions, we were able to achieve these ob-
jectives:
1. Clipboard interaction establishes a temporary uni-
directional communication channel. It necessarily
involves notiﬁcation of both sides by the display
server, which is a small multiplication of messages
(and therefore violates R7).
2. Our design supports hierarchical client subsessions.
This hierarchy expresses visual containment only;
subsessions are fully isolated from their parent ses-
sions for communication purposes with one excep-
tion: destruction of a session implies destruction of
all descendant subsessions (violates R1).
3. Window structures are dynamically allocated using
display server memory (violates R5). A quota sys-
tem is needed to limit communication achieved by
exhausing the total number of available server win-
dow structures. A quota of this sort will also limit
attacks that operate by creating large numbers of
windows. This has not yet been implemented.
2.2 Design Overview
The functions of a display server can be divided into ﬁve
main categories:
1. Input processing, including events and client re-
quests
2. Rendering and display update.
3. Interprocess communication (cut and paste).
4. Trusted user interaction and feedback, which in-
cludes window decorations, labeling, and trusted
path management.
5. Isolation support.
We will discuss how each of these is approached in EWS
in the sections that follow, and then examine how a variety
of security concerns are addressed by the design.
As a capability system, EROS is object-based. In conse-
quence, EWS is an “object server,” and requests are per-
formed by synchronously invoking operating system pro-
tected capabilities. It has become conventional to speak
of a server that responds to interprocess procedure calls in
this fashion as an “RPC Server.” We emphasize that all in-
terprocess communications in EWS are local remote pro-
cedure calls [5]. The EROS capability invocation mecha-
nism [29] provides a high-performance transport for such
invocations. For reasons that will become clear below, the
synchrony of these invocations is not a bottleneck to dis-
play performance.
The EWS display server does not directly implement re-
mote connection or cryptographic transport layer pro-
tection. Both are cleanly separable functions that have
generic utility for many applications. There is no rea-
son that the display system should duplicate this function
when it can be satisfactorily implemented in a separably
assurable component. Cox et al. [6] propose a compelling
architecture for separating transport security and key man-
agement from applications.
The display server also omits authentication functional-
ity. In a capability system posession of a capability is a
necessary and sufﬁcient proof of authority to perform the
operations invokable through that capability. In the con-
text of EWS, a client either possesses a Session capa-
bility or they do not, and distribution of capabilities is a
separable problem. User accounts are created with an ini-
tial desktop session that can be detached and reattached
by the login subsystem. Responsibility for subsession
Kbd
Helper
Mouse
Helper
Display
Server
Client
Client
Client
Figure 2: EWS Components
creation initially lies with the user’s primary “shell.” In
a multilevel secure system, this shell would be a trusted
application have responsibility for creating compartments
and associating security labels with the subordinate Ses-
sion capabilities that it grants to applications within these
compartments.
3 Input Processing
cessing imposes three constraints on the display server:
1. Requests must be “prompt,” by which we mean
that their completion must not involve any opera-