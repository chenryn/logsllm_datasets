We can use kextload to load the kext manually.
$ sudo kextload -v /tmp/DummySysctl.kext
kextload: extension /tmp/DummySysctl.kext appears to be valid
kextload: loading extension /tmp/DummySysctl.kext
kextload: sending 1 personality to the kernel
kextload: /tmp/DummySysctl.kext loaded successfully
If the kext fails to load, the -t (test) option of kextload may provide information about possible problems.
For example, suppose we specified an unavailable version of a dependencysay, version 7.9.9 for
com.apple.kpi.libkernthen the -t option would be helpful in identifying the cause of the problem.
$ sudo kextload -v /tmp/DummySysctl.kext
kextload: extension /tmp/DummySysctl.kext appears to be valid
kextload: loading extension /tmp/DummySysctl.kext
kextload: cannot resolve dependencies for kernel extension /tmp/DummySysctl.kext
$ sudo sysctl -v -t /tmp/DummySysctl.kext
...
kernel extension /tmp/DummySysctl.kext has problems:
...
Missing dependencies
{
"com.apple.kpi.libkern" =
"A valid compatible version of this dependency cannot be found"
}
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 29 of 79
When the -t option is specified, kextload neither loads the kext nor sends its personality to the kernel. It
only performs a series of tests on the kext and determines whether it is loadable. The tests include validation,
authentication, and dependency resolution.
Besides dependency resolution failures, other reasons for a kext's failure to load include incorrect file
permissions, a flawed bundle structure, a missing CFBundleIdentifier property in the kext's Info.plist
file, and a missing or syntactically invalid Info.plist file.
We can use the kextstat command to check whether our kext is currently loaded in the kernel.
$ kextstat
Index Refs Address Size Wired Name (Version) 
1 1 0x0 0x0 0x0 com.apple.kernel (8.6.0)
2 11 0x0 0x0 0x0 com.apple.kpi.bsd (8.6.0)
3 12 0x0 0x0 0x0 com.apple.kpi.iokit (8.6.0)
4 12 0x0 0x0 0x0 com.apple.kpi.libkern (8.6.0)
...
133 0 0x5cbca000 0x2000 0x1000 com.osxbook.kext.DummySysctl (1.0.0d1) 
The value 133 in the kextstat output indicates the index at which the kext is loaded. The kernel uses these
indices for tracking interkext dependencies. The second value, which is 0 in our case, shows the number of
references to this kext. A nonzero reference indicates that one or more kexts are using this kext. The next
value, 0x5cbca000, is the kext's load address in the kernel's virtual address space. The next two values,
0x2000 and 0x1000, represent the amounts (in bytes) of kernel memory and wired kernel memory,
respectively, used by the kext. The final value in the column is a list of indices of all other kexts that this
kext references. We see that DummySysctl references two kexts: the ones loaded at indices 4
(com.apple.kpi.libkern) and 2 (com.apple.kpi.bsd).
We can unload the kext manually by using the kextunload command.
$ sudo kextunload -v /tmp/DummySysctl.kext
kextunload: unload kext /tmp/DummySysctl.kext succeeded
In a deployment scenario, one does not have to run kextload or kextunload manuallykexts are loaded
automatically when they are needed and unloaded when they are not being used.
The output from the printf() statements we inserted in our kext should appear in /var/log/system.log.
$ grep DummySysctl_ /var/log/system.log
Mar 14 17:32:48 g5x4 kernel[0]: DummySysctl_start
Mar 14 17:34:48 g5x4 kernel[0]: DummySysctl_stop
10.6.2. Implementing Sysctl Variables Using a Generic Kext
Let us extend our generic kext from Section 10.6.1 to implement a sysctl node with two variables: an integer
and a string. We will call the new node osxbook, and it will have the following properties.
It will be a subcategory of the existing top-level sysctl node called debug. In other words, the new
node's MIB-style name would be debug.osxbook.
One of its two children will be called uint32, which will hold a 32-bit unsigned integer. The integer's
value will be readable or writable by any user.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 30 of 79
The second of its children will be called string, which will hold a string up to 16 characters in length
(including the terminating NUL character). The string's value will be readable by anyone but writable
only by the root user.
When our sysctl kext is loaded, the kernel's sysctl hierarchy would look like the one shown in Figure 1014,
with possibly other top-level categories depending on the kernel version.
Figure 1014. The kernel's sysctl hierarchy
The most general way to create a sysctl variable is to use the SYSCTL_PROC() macro, which allows a handler
function to be specified for the sysctl. The handler is called when the variable is accessed for reading or
writing. There exist data-type-specific macros such as SYSCTL_UINT() for unsigned integers and
SYSCTL_STRING() for strings. The sysctls defined using these macros are served by predefined type-specific
functions such as sysctl_handle_int() and sysctl_handle_string(). We will use SYSCTL_PROC() to
define our sysctl variables, with our own handler functions, although we will simply call the predefined
handlers from our handlers. Figure 1015 shows the updated contents of DummySysctl.c. Note that we
register the three sysctl entriesdebug.osxbook, debug.osxbook.uint32, and debug.osxbook.stringin the
kext's start routine and unregister them in the stop routine.
Figure 1015. Implementing sysctl nodes
// DummySysctl.c
#include 
#include 
#include 
static u_int32_t k_uint32 = 0; // the contents of debug.osxbook.uint32
static u_int8_t k_string[16] = { 0 }; // the contents of debug.osxbook.string
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 31 of 79
// Construct a node (debug.osxbook) from which other sysctl objects can hang.
SYSCTL_NODE(_debug, // our parent
OID_AUTO, // automatically assign us an object ID
osxbook, // our name
CTLFLAG_RW, // we will be creating children, therefore, read/write
0, // handler function (none needed)
"demo sysctl hierarchy");
// Prototypes for read/write handling functions for our sysctl nodes.
static int sysctl_osxbook_uint32 SYSCTL_HANDLER_ARGS;
static int sysctl_osxbook_string SYSCTL_HANDLER_ARGS;
// We can directly use SYSCTL_INT(), in which case sysctl_handle_int()
// will be assigned as the handling function. We use SYSCTL_PROC() and
// specify our own handler sysctl_osxbook_uint32().
//
SYSCTL_PROC(
_debug_osxbook, // our parent
OID_AUTO, // automatically assign us an object ID
uint32, // our name
(CTLTYPE_INT | // type flag
CTLFLAG_RW | CTLFLAG_ANYBODY), // access flags (read/write by anybody)
&k_uint32, // location of our data
0, // argument passed to our handler
sysctl_osxbook_uint32, // our handler function
"IU", // our data type (unsigned integer)
"32-bit unsigned integer" // our description
);
// We can directly use SYSCTL_STRING(), in which case sysctl_handle_string()
// will be assigned as the handling function. We use SYSCTL_PROC() and
// specify our own handler sysctl_osxbook_string().
//
SYSCTL_PROC(
_debug_osxbook, // our parent
OID_AUTO, // automatically assign us an object ID
string, // our name
(CTLTYPE_STRING | CTLFLAG_RW), // type and access flags (write only by root)
&k_string, // location of our data
16, // maximum allowable length of the string
sysctl_osxbook_string, // our handler function
"A", // our data type (string)
"16-byte string" // our description
);
static int
sysctl_osxbook_uint32 SYSCTL_HANDLER_ARGS
{
// Do some processing of our own, if necessary.
return sysctl_handle_int(oidp, oidp->oid_arg1, oidp->oid_arg2, req);
}
static int
sysctl_osxbook_string SYSCTL_HANDLER_ARGS
{
// Do some processing of our own, if necessary.
return sysctl_handle_string(oidp, oidp->oid_arg1, oidp->oid_arg2, req);
}
kern_return_t
DummySysctl_start(kmod_info_t *ki, void *d)
{
// Register our sysctl entries.
sysctl_register_oid(&sysctl__debug_osxbook);
sysctl_register_oid(&sysctl__debug_osxbook_uint32);
sysctl_register_oid(&sysctl__debug_osxbook_string);
return KERN_SUCCESS;
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 32 of 79
}
kern_return_t
DummySysctl_stop(kmod_info_t *ki, void *d)
{
// Unregister our sysctl entries.
sysctl_unregister_oid(&sysctl__debug_osxbook_string);
sysctl_unregister_oid(&sysctl__debug_osxbook_uint32);
sysctl_unregister_oid(&sysctl__debug_osxbook);
return KERN_SUCCESS;
}
Let us compile and load the kext to test it. Once it is loaded, the sysctl command can be used to get and set
the values of our sysctl variables.
$ sysctl debug
...
debug.osxbook.uint32: 0
debug.osxbook.string:
$ sysctl -w debug.osxbook.uint32=64
debug.osxbook.uint32: 0 -> 64
$ sysctl debug.osxbook.uint32
debug.osxbook.uint32: 64
$ sysctl -w debug.osxbook.string=kernel
debug.osxbook.string:
sysctl: debug.osxbook.string: Operation not permitted
$ sudo sysctl -w debug.osxbook.string=kernel
debug.osxbook.string: -> kernel
$ sysctl debug.osxbook.string
debug.osxbook.string: kernel
10.6.3. I/O Kit Device Driver Kext
As we saw in Section 10.4.2, an I/O Kit driver is a kext that uses C++ in its implementationit runs in the
kernel's C++ runtime environment provided by the I/O Kit. The Info.plist file of an I/O Kit driver kext
contains one or more driver personality dictionaries. Moreover, unlike a generic kext, the driver
implementor does not provide start/stop routines for the kext because, as we saw earlier, these routines are
used as hooks to initialize/terminate the C++ runtime. However, an I/O Kit driver has several other entry
points. Depending on the type and nature of the driver, many of these entry points can be optional or
mandatory. The following are examples of I/O Kit driver entry points.
 init() During active matching, the I/O Kit loads a candidate driver's code and creates an instance of
the driver's principal class, which is specified in the driver's personality. The first method called on
each instance of the driver's class is init(), which may be semantically seen as a constructor and may
allocate resources needed by the instance. It is passed a dictionary object containing the matching
properties from the selected driver personality. A driver may or may not override the init() method.
If it does, it must call the superclass's init() as the first action.
 free() The free() method is called when the driver is unloaded. It should free any resources
allocated by init(). If init() calls the superclass's init(), free() must make a corresponding call
to the superclass's free(). Note that unlike the start and stop entry points of a kmod, init() and
free() are called once for each instance of the driver's class.
 probe() This method is called to probe the hardware to determine whether the driver is suited for that
hardware. It must leave the hardware in a sane state after it has finished probing. It takes as arguments
the driver's provider and a pointer to a probe scorea signed 32-bit integer initialized to the value of the
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 33 of 79
IOProbeScore key in the driver's personality, or to zero if the personality does not contain this key.
The I/O Kit gives the driver with the highest probe score the first opportunity to drive the hardware.
 start() This is the actual starting point of the driver's lifecycle. Here the driver advertises its services
and publishes any nubs. If start() returns successfully, it means that the device hardware has been
initialized and is ready for operation. Thereafter, the I/O Kit will not consider any remaining candidate
driver instances.
 stop() This method represents the end point of the driver's lifecycle. Here the driver unpublishes any
nubs and stops providing its services.
 attach() This method attaches the driver (an IOService client) to a provider (nub) through
registration in the I/O Registry. In other words, when called in a driver, it enters the driver in the I/O
Registry as a child of the provider in the Service plane.
 detach() This method detaches the driver from a nub.
Let us implement an I/O Kit driver kext by starting with the IOKit Driver Xcode template. We will call our
driver DummyDriver. Xcode will generate a header file (DummyDriver.h), a C++ source file
(DummyDriver.cpp), and an Info.plist file, besides other project-related files. As we will see, it takes
somewhat more work to create a trivial I/O Kit driver than a trivial generic kext.
Figure 1016 shows the key contents of the driver's property list file.
Figure 1016. An I/O Kit driver's personality and dependencies
...
...
IOKitPersonalities
DummyPersonality_0
CFBundleIdentifier
com.osxbook.driver.DummyDriver
IOClass
com_osxbook_driver_DummyDriver
IOKitDebug
65535
IOMatchCategory
DummyDriver
IOProviderClass
IOResources
IOResourceMatch
IOKit
OSBundleLibraries
com.apple.kpi.iokit
8.0.0
com.apple.kpi.libkern
8.0.0
As in the case of DummySysctl, we identify our driver kext using a reverse-DNS-style name. The
IOKitPersonalities property, which is an array of personality dictionaries, contains properties for
matching and loading the driver. Our driver contains only one personality called DummyPersonality_0.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 34 of 79
The IOClass key in the personality specifies the name of the driver's primary class, based on the driver
kext's bundle identifier for uniformity. Note, however, that the name of the driver class cannot contain dots.
Therefore, we translate dots to underscores while naming our driver's class.
DummyDriver neither controls any hardware nor implements any real functionality. In order for it to load and
match successfully, we specify its IOProviderClass property as IOResources, which is a special nub that
can be matched against any driver. Note that it is possible for real drivers that do not attach to any hardware
to match against IOResources. The BootCache kext (BootCache.kext)[9] is an exampleit operates within
the Mach and BSD portions of the kernel but implements minimal glue code for the I/O Kit. It also specifies
IOResources as its provider class. Figure 1017 shows the personality specification from the BootCache
kext's Info.plist file.
[9] We discussed BootCache in Section 4.14.
Figure 1017. The driver personality of the BootCache kernel extension
...
IOKitPersonalities
BootCache
CFBundleIdentifier
com.apple.BootCache
IOClass
com_apple_BootCache
IOMatchCategory
BootCache
IOProviderClass
IOResources
IOResourceMatch
IOKit
...
IOMatchCategory is a special property that allows multiple drivers to match a single nub. Examples of
kexts whose driver personalities specify this property include AppleRAID, IOFireWireFamily,
IOGraphicsFamily, IOSerialFamily, IOStorageFamily, and IOUSBFamily. Note that a kext that specifies
an IOResourceMatch property is eligible for loading after the subsystem named by the value of
IOResourceMatch has been published as available.
The iPod Driver
The iPod driver kext (iPodDriver.kext) is an example of a driver containing multiple
personalities. Figure 1018 shows an excerpt from the iPod driver's Info.plist file.
Figure 1018. An excerpt from the iPod driver's property list file
...
IOKitPersonalities
iPodDriver