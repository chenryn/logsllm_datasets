第6章可执行文件的装载与进程
exccve0系统调用相应的入口是sys_execve()，它被定义在archi386kermelProcess.c。
sys_execve(进行一些参数的检查复制之后，调用do_exccveO.do_exccve0会首先查找被执
行的文件，如果找到文件，则读取文件的前128个字节。为什么要这么做呢？因为我们知道，
Linux支持的可执行文件不止ELF一种，还有aout、Java程序和以“#”开始的脚本程序。
Linux还可以支持更多的可执行文件格式，如果某一天Linux须支持WindowsPE的可执行
文件格式，那么我们可以编写一个支持PE装载的内核模块来实现Linux对PE文件的支持。
这里do_exccveO读取文件的前128个字节的目的是判断文件的格式，每种可执行文件的格
式的开头儿个字节都是很特殊的，特别是开头4个字节，常常被称做魔数（MagicNumber），
通过对魔数的判断可以确定文件的格式和类型，比如ELF的可执行文件格式的头4个字节
为0x7F、’e'、T、‘f：而Java的可执行文件格式的头4个字节为'c'、‘a'、“f、'e'：如果
被执行的是Shell脚本或ped、python等这种解释型语言的脚本，那么它的第一行往往是
魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的
路径。
当 do_execve()读取了这128个字节的文件头部之后，然后调用 search_binary_handle()
去搜索和匹配合适的可执行文件装载处理过程。Linux中所有被支持的可执行文件格式部有
相应的装载处理过程，search_binary_handleO会通过判断文件头部的魔数确定文件的格式，
并且调用相应的装载处理过程。比如ELF可执行文件的装载处理过程叫做load_elf_binaryO：
aout可执行文件的装载处理过程叫做load_aout_binaryO：而装载可执行脚本程序的处理过
程叫做load_scriptO.这里我们只关心 ELF可执行文件的装载，load_elf_binaryO被定义在
fs/Binfmt_elf.c，这个函数的代码比较长，它的主要步骤是：
（1）检查ELF可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。
（2）寻找动态链接的“interp”段，设置动态链接器路径（与动态链接有关，具体请
（夏6年
（3）根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、
只读数据。
（4）初始化ELF进程环境，比如进程启动时 EDX寄存器的地址应该是DT_FINI的地
址（参照动态链接）。
（5）将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序
的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中
c_entry所指的地址：对于动态链接的ELF可执行文件，程序入口点是动态链接器。
当 load_elf_binaryO执行完毕，返回至do_execve(再返回至sys_execveO时，上面的第5
程序员的自我修养—链接、装载与库
---
## Page 198
6.6Windows PE 的装载
175
步中已经把系统调用的返回地址改成了被装载的ELF程序的入口地址了.所以当sys_execve)
系统调用从内核态返回到用户态时，EIP寄存器直接跳转到了ELF程序的入口地址，于是新
的程序开始执行，ELF可执行文件装载完成，
6.6WindowsPE的装载
PE文件的装载跟ELF有所不同，由于PE文件中，所有段的起始地址都是页的倍数，
段的长度如果不是页的整数倍，那么在映射时向上补齐到页的整数倍，我们也可以简单地认
为在32位的PE文件中，段的起始地址和长度都是4096字节的整数倍。由于这个特点，PE
文件的映射过程会比ELF简单得多，因为它无须考虑如ELF里面诸多段地址对齐之类的间
题，虽然这样会浪费一些磁盘和内存空间。PE可执行文件的段的数量一般很少，不像ELF
文件中，链接器在生产可执行文件时，往往将所有的段尽可能地合并，所以一般只有代码段、
数据段、只读数据段和BSS等为数不多的儿个段。
在讨论结构的具体装载过程之前，我们要先引入一个PE里面很常见的术语叫做RVA
（RelativeVirtualAddress），它表示一个相对虚拟地址。这个术语看起来比较晦涩难懂，
其实它的概念很简单，就是相当于文件中的偏移量的东西。它是相对于PE文件的装载基地
址的一个偏移地址。比如，一个PE文件被装载到虚拟地址（VA）0x00400000，那么一个
RVA为0x1000的地址就是0x00401000。每个PE文件在装载时都会有一个装载目标地址
（TargetAddress），这个地址就是所请的基地址（Base Address）。由于PE文件被设计成
可以装载到任何地址，所以这个基地址并不是固定的，每次装载时都可能会变化。如果PE
文件中的地址都使用绝对地址，它们都要随着基地址的变化而变化。但是，如果使用RVA
这样一种基于基地址的相对地址，那么无论基地址怎么变化，PE文件中的各个RVA都保持
一致。这里涉及PE可执行文件装载的一些内容，我们只是简单介绍一下，更加详细的内容
将留到本书后面有关PE文件的 Rebasing机制时再进行分析。
装载一个PE可执行文件并且装载它，是个比ELF文件相对简单的过程：
·先读取文件的第一个页，在这个页中，包含了DOS头、PE文件头和段表。
·检查进程地址空间中，目标地址是否可用，如果不可用，则另外选一个装载地址。这
个问题对于可执行文件来说基本不存在，因为它往往是进程第一个装入的模块，所以
目标地址不太可能被占用。主要是针对DLL文件的装载面言的，我们在后面的
“Rebasing”这一节还会具体介绍这个问题。
·使用段表中提供的信息，将PE文件中所有的段一一映射到地址空间中相应的位置。
·如果装载地址不是目标地址，则进行Rebasing。
程序员的自我修养一链接、装载与库
---
## Page 199
176
第6章可执行文件的装载与进程
装载所有PE文件所需要的DLL文件。
对PE文件中的所有导入符号进行解析。
根据PE头中指定的参数，建立初始化栈和堆。
建立主线程并且启动进程。
PE文件中，与装载相关的主要信息都包含在PE扩展头（PEOptional Header）和段表，
我们在第2部分已经介绍过了PE扩展头部分结构，这里我们将选择几个跟装载相关的成员
来分析它们的含义（见表6-6），当然还有一部分成员是跟进程初始化和运行库有关的，我
们把它们留到本书的第4部分介绍。
表6-6
成员
含义
Image Base
PE文件的优先装载地址，比如，如果谊值是0x00400000，PE装
载器将需试把文件装到虚拟地址空间的0x00400000处，若该地
址区域已被其他目标文件占用，邢PE装载器会选用其他空闭地
址。对于可知文件来说，它一般是0x00400000，对于DLL来说
它一般是0x10000000
AddressOfEntryPoint
PE浆载器准备运行的PE文件的第一个指令的RVA.如果我们需
要改变整个执行的流程，可以将该值指定到新的RVA，这样当
PE文件被开始执行时、会从新RVA处的指令首先被执行。这经
需是一些病毒感染PE文件后所做的第一件事
SectionAlignment
内存中段对券的粒度，致认情况下一般是系统页面的大小，x86
下是4096字节
FileAlignment
文件中段对齐的粒度，这个值必须是2的指数倍，从512到64KB
默认一般是512字节
MajorSubsystemVersion
程序运行所需要的Win32子系统版本，我们在本书的后面章节还
MinorSubsystemVersion
会介绍Windows子系统相美内容
SizeOftmage
内存中整个PE映像体的尺寸。它是所有头和节经过节对齐处理
后的大小
SizeOfHeaders
所有头+节表的大小，也就是等于文件尺寸减去文件申所有节的
尺寸，可以以此值作为PE文件第一节的文件偏移量
Subsystem
NT用来识别PE文件属于哪个子系统，对于大多数Win32程序，
只有两类值：Windows GUI和Windows CUI（控制台）
SizeOfCode
代码段的长度
SizeOflnitializedData
初始化了的数据段长度
SizeOfUninitializedData
未初始化的数据段长度
BaseOfCode
代码段起始RVA
BaseOfData
数据投起给RVA
程序员的自我修养—链接、装载与库
---
## Page 200
6.7本章小结
177
6.7本章小结
在这一章中，我们探讨了程序运行时如何使用内存空间的问题，即进程虚拟地址空间问
题。接着我们围绕程序如何被操作系统装载到内存中进行运行，介绍了覆盖装入和页映射的
模式，分析了为什么要以页映射的方式将程序映射至进程地址空间，这样做的好处是什么，
并从操作系统的角度观察进程如何被建立，当程序开始运行时发生页错误该如何处理等。
我们还详细介绍了进程虚拟地址空间的分布，操作系统如何为程序的代码、数据、堆、
栈在进程地址空间中分配，它们是如何分布的。最后两个章节我们分别深入介绍了Linux和
Windows程序如何装载并且运行ELF和PE程序。在这一章中，我们假设程序都是静态链接
的，那么它们都只有一个单独的可执行文件模块。下一章中我们将介绍一种与静态链接程序
不同的概念，即一个单一的可执行文件模块被拆分成若干个模块，在程序运行时进行链接的
一种方式。
程序员的自我修养一链接、装载与库
---
## Page 202
动态链接
7.1为什么要动态链接
7.2简单的动态链接例子
7.3地址无关代码
7.4延迟绑定（PLT）
7.5动态链接相关结构
7.6动态链接的步骤和实现
7.7显式运行时链接
7.8本章小结
程序员的自我修养—链接、装载与库
---
## Page 203
180
第7章动态链接
7.1
为什么要动态链接
静态链接使得不同的程序开发者和部门能够相对独立地开发和测试自己的程序模块，从
某种意文上来讲大大促进了程序开发的效率，原先限制程序的规模也随之扩大。但是慢慢地
静态链接的诸多缺点也逐步暴露出米，比如浪费内存和磁盘空间、模块更新困难等问题，使
得人们不得不寻找一种更好的方式来组织程序的模块。
内存和磁盘空间
静态链接这种方法的确很简单，原理上很容易理解，实践上很难实现，在操作系统和硬
快就暴露出来了，那就是静态连接的方式对于计算机内存和磁盘的空间浪费非常严重。特别
是多进程操作系统情况下，静态链接极大地浪费了内存空间，想象一下每个程序内部除了都
保留着printfO函数、scanfO函数、strlenO等这样的公用库函数，还有数量相当可观的其他库
函数及它们所需要的辅助数据结构，在现在的Linux系统中，一个普通程序会使用到的C
语言静态库至少在1MB以上，那么，如果我们的机器中运行着100个这样的程序，就要浪
费近100MB的内存：如果磁盘中有2000个这样的程序，就要浪费近2GB的磁盘空间，
很多Linux的机器中，/usr/bin下就有数千个可执行文件。
比如图7-1所示的Program1和Program2分别包含Program1.o和Program2.o两个模块，
0xFFFFFFFF
Progan2 
0x10000000
0x00000000
Physical Memory
图7-1静态链接时文件在内存中的副本
程序员的自我修养一链接、装载与库
---
## Page 204
7.1为什么要动态键接
181
并且它们还共用Lib.o这两模块，在静态连接的情况下，因为Program1和Program2都用到
了Lib.o这个模块，所以它们同时在链接输出的可执行文件Program1和 Program2有两个副
本。当我们同时运行 Program1和 Program2 时，Lib.o 在磁盘中和内存中都有两份副本。当
系统中存在大量的类似于Lib.o的被多个程序共享的目标文件时，其中很大一部分空间就被
浪费了，在静态链接中，C语言静态库是很典型的浪费空间的例子，还有其他数以千计的库
如果都需要静态链接，那么空间浪费无法想象，
程序开发和发布
空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也
会带来很多麻烦。比如程序Program1所使用的Lib.o是由一个第三方厂商提供的，当该厂
要拿到最新版的 Lib.o，然后将其与Programl.o链接后，将新的Program1整个发布给用户。
这样做的缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新链接、发布给用户。
比如一个程序有20个模块，每个模块1MB，那么每次更新任何一个模块，用户就得重新获
取这个20MB的程序。如果程序都使用静态链接，那么通过网络来更新程序将会非常不便，
因为一旦程序任何位置的一个小改动，都会导致整个程序重新下载。
动态链接
要解决空间浪费和更新困难这两个问题最简单的办法就是把程序的模块相互分割开来，
形成独立的文件，而不再将它们静态地链接在一起。简单地讲，就是不对那些组成程序的目
标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行
时再进行，这就是动态链接（DynamicLinking）的基本思想。
个目标文件。当我们要运行Programl这个程序时，系统首先加载Programl.o，当系统发现
Programl.o中用到了Lib.o，即Programl.o依赖于Lib.o，那么系统接若加载Lib.o，如果
Programl.o或Lib.o还依赖于其他目标文件，系统会按照这种方法将它们全部加载至内存。
所有需要的目标文件加载完毕之后，如果依赖关系满足，即所有依赖的目标文件都存在于磁
盘，系统开始进行链接工作。这个链接工作的原理与静态链接非常相似，包括符号解析、地
址重定位等，我们在前面已经很详细地介绍过了，完成这些步骤之后，系统开始把控制权交
给Programl.o的程序入口处，程序开始运行，这时如果我们需要运行Program2，那么系统
只需要加载Program2.o，而不需要重新加载Lib.o，因为内存中已经存在了一份Lib.o的副本
（见图7-2），系统要做的只是将Program2.o和Lib.o链接起来。
很明显，上面的这种做法解决了共享的目标文件多个副本浪费磁盘和内存空间的问题，
可以看到，磁盘和内存中只存在一份Lib.o，而不是两份。另外在内存中共享一个目标文件
程序员的自我修养一链接、装载与库
---
## Page 205
182
第7章动态链接
0xFFFFFFFF
0x10000000
Pogen2.
Lb.9e
..Pogent....
S6MB
....
0x00000000
Physical Memory
图7-2动态链接时文件在内存中的副本
模块的好处不仅仅是节省内存，它还可以减少物理页面的换入换出，也可以增加CPU缓存
的命中率，因为不同进程间的数据和指令访间都集中在了同一个共享模块上。
上面的动态链接方案也可以使程序的升级变得更加容易，当我们要升级程序库或程序共
享的某个模块时，理论上只要简单地将旧的目标文件覆盖掉，而无须将所有的程序再重新链
接一遍，当程序下一次运行的时候，新版本的目标文件会被自动装载到内存并且链接起来，
程序就完成了升级的目标。
当一个程序产品的规模很大的时候，往往会分割成多个子系统及多个模块，每个模块都
更加独立，耦合度更小，便于不同的开发者和开发组织之间独立进行开发和测试。
程序可扩展性和兼容性