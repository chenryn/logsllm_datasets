passwords containing only lowercase alphabetical characters produces
more than three million permutations — more than can practically be
tested with only remote access to the application.
n “Character frobber” and “bit fl ipper” functions, which can be used to
systematically manipulate parts of a parameter’s existing value to probe
the application’s handling of subtle modifi cations (see Chapter 7).
In addition to the payload generation functions, you can confi gure rules to
perform arbitrary processing on each payload’s value before it is used. This
includes string and case manipulation, encoding and decoding in various
schemes, and hashing. Doing so enables you to build effective payloads in many
kinds of unusual situations.
cc1144..iinndddd 559933 88//1199//22001111 1122::1155::2233 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 594
594 Chapter 14 n Automating Customized Attacks
Burp Intruder by default URL-encodes any characters that might invalidate
your request if placed into the request in their literal form.
Confi guring Response Analysis
For many kinds of attacks, you should identify the attributes of the server’s
responses that you are interested in analyzing. For example, when enumerating
identifi ers, you may need to search each response for a specifi c string. When
fuzzing, you may want to scan for a large number of common error messages
and the like.
By default, Burp Intruder records in its table of results the HTTP status code,
the response length, any cookies set by the server, and the time taken to receive
the response. As with JAttack, you can additionally confi gure Burp Intruder to
perform some custom analysis of the application’s responses to help identify
interesting cases that may indicate the presence of a vulnerability or merit fur-
ther investigation. You can specify strings or regex expressions that responses
will be searched for. You can set customized strings to control extraction of data
from the server’s responses. And you can make Intruder check whether each
response contains the attack payload itself to help identify cross-site scripting
and other response injection vulnerabilities. These settings can be confi gured
before each attack is launched and can also be applied to the attack results after
the attack has started.
Having confi gured payload positions, payload sources, and any required
analysis of server responses, you are ready to launch your attack. Let’s take a
quick look at how Intruder can be used to deliver some common customized
automated attacks.
Attack 1: Enumerating Identifi ers
Suppose that you are targeting an application that supports self-registration for
anonymous users. You create an account, log in, and gain access to a minimum
of functionality. At this stage, one area of obvious interest is the application’s
session tokens. Logging in several times in close succession generates the fol-
lowing sequence:
000000-fb2200-16cb12-172ba72551
000000-bc7192-16cb12-172ba7279e
000000-73091f-16cb12-172ba729e8
000000-918cb1-16cb12-172ba72a2a
000000-aa820f-16cb12-172ba72b58
000000-bc8710-16cb12-172ba72e2b
cc1144..iinndddd 559944 88//1199//22001111 1122::1155::2233 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 595
Chapter 14 n Automating Customized Attacks 595
You follow the steps described in Chapter 7 to analyze these tokens. It is evident
that approximately half of the token is not changing, but you also discover that
the second portion of the token is not actually processed by the application either.
Modifying this portion entirely does not invalidate your tokens. Furthermore,
although it is not trivially sequential, the fi nal portion clearly appears to be
incrementing in some fashion. This looks like a promising opportunity for a
session hijacking attack.
To leverage automation to deliver this attack, you need to fi nd a single request/
response pair that can be used to detect valid tokens. Typically, any request for
an authenticated page of the application will serve this purpose. You decide to
target the page presented to each user following login:
GET /auth/502/Home.ashx HTTP/1.1
Host: mdsec.net
Cookie: SessionID=000000-fb2200-16cb12-172ba72551
Because of what you know about the structure and handling of session tokens,
your attack needs to modify only the fi nal portion of the token. In fact, because
of the sequence identifi ed, the most productive initial attack modifi es only the
last few digits of the token. Accordingly, you confi gure Intruder with a single
payload position, as shown in Figure 14-2.
Figure 14-2: Setting a custom payload position
cc1144..iinndddd 559955 88//1199//22001111 1122::1155::2233 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 596
596 Chapter 14 n Automating Customized Attacks
Your payloads need to sequence through all possible values for the fi nal three
digits. The token appears to use the same character set as hexadecimal numbers:
0 to 9 and a to f. So you confi gure a payload source to generate all hexadecimal
numbers in the range 0x000 to 0xfff, as shown in Figure 14-3.
Figure 14-3: Configuring numeric payloads
In attacks to enumerate valid session tokens, identifying hits is typically
straightforward. In the present case you have determined that the application
returns an HTTP 200 response when a valid token is supplied and an HTTP 302
redirect to the login page when an invalid token is supplied. Hence, you don’t
need to confi gure any custom response analysis for this attack.
Launching the attack causes Intruder to quickly iterate through the requests.
The attack results are displayed in the form of a table. You can click each
column heading to sort the results according to the contents of that column.
Sorting by status code enables you to easily identify the valid tokens you have
discovered, as shown in Figure 14-4. You can also use the fi ltering and search
functions within the results window to help locate interesting items within
a large set of results.
cc1144..iinndddd 559966 88//1199//22001111 1122::1155::2233 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 597
Chapter 14 n Automating Customized Attacks 597
Figure 14-4: Sorting attack results to quickly identify hits
The attack is successful. You can take any of the payloads that caused HTTP
200 responses, replace the last three digits of your session token with this, and
thereby hijack the sessions of other application users. However, take a closer look
at the table of results. Most of the HTTP 200 responses have roughly the same
response length, because the home page presented to different users is more or
less the same. However, two of the responses are much longer, indicating that
a different home page was returned.
You can double-click a result item in Intruder to display the server’s response
in full, either as raw HTTP or rendered as HTML. Doing this reveals that the
longer home pages contain more menu options and different details than your
home page does. It appears that these two hijacked sessions belong to more-
privileged users.
TRY IT!
http://mdsec.net/auth/502/
cc1144..iinndddd 559977 88//1199//22001111 1122::1155::2233 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 598
598 Chapter 14 n Automating Customized Attacks
TIP The response length frequently is a strong indicator of anomalous
responses that merit further investigation. As in the preceding case, a dif-
ferent response length can point to interesting differences that you may not
have anticipated when you devised the attack. Therefore, even if another
attribute provides a reliable indicator of hits, such as the HTTP status code,
you should always inspect the response length column to identify other
interesting responses.
Attack 2: Harvesting Information
Browsing further into the authenticated area of the application, you notice that
it uses an index number in a URL parameter to identify functions requested
by the user. For example, the following URL is used to display the My Details
page for the current user:
https://mdsec.net/auth/502/ShowPage.ashx?pageid=32010039
This behavior offers a prime opportunity to trawl for functionality you have
not yet discovered and for which you may not be properly authorized. To do
this, you can use Burp Intruder to cycle through a range of possible pageid
values and extract the title of each page that is found.
In this situation, it is often sensible to begin trawling for content within a
numeric range that is known to contain valid values. To do this, you can set
your payload position markers to target the fi nal two digits of the pageid, as
shown in Figure 14-5, and generate payloads in the range 00 to 99.
You can confi gure Intruder to capture the page title from each response
using the Extract Grep function. This works much like the extract function of
JAttack — you specify the expression that precedes the item you want to extract,
as shown in Figure 14-6.
Launching this attack quickly iterates through all the possible values for
the last two digits of the pageid parameter and shows the page title from each
response, as shown in Figure 14-7. As you can see, several responses appear
to contain interesting administrative functionality. Furthermore, some of the
responses are redirections to a different URL, which warrant further investi-
gation. If you want to, you can reconfi gure your Intruder attack to extract the
target of these directions, or even to automatically follow them and show the
page title from the eventual response.
TRY IT!
http://mdsec.net/auth/502/
cc1144..iinndddd 559988 88//1199//22001111 1122::1155::2233 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 599
Chapter 14 n Automating Customized Attacks 599
Figure 14-5: Positioning the payload
Figure 14-6: Configuring Extract Grep
cc1144..iinndddd 559999 88//1199//22001111 1122::1155::2233 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 600
600 Chapter 14 n Automating Customized Attacks
Figure 14-7: Cycling through function index values and extracting the title
of each resulting page
Attack 3: Application Fuzzing
In addition to exploiting the bugs already identifi ed, you should, of course, probe
the target application for common vulnerabilities. To ensure decent coverage,
you should test every parameter and request, starting from the login request
onward.
To perform a quick fuzz test of a given request, you need to set payload posi-
tions at all the request parameters. You can do this simply by clicking the auto
button on the positions tab, as shown in Figure 14-8.
You then need to confi gure a set of attack strings to use as payloads and some
common error messages to search responses for. Intruder contains built-in sets
of strings for both of these uses.
As with the fuzzing attack performed using JAttack, you then need to manually
review the table of results to identify any anomalies that merit further investiga-
tion, as shown in Figure 14-9. As before, you can click column headings to sort
the responses in various ways to help identify interesting cases.
cc1144..iinndddd 660000 88//1199//22001111 1122::1155::2244 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 601
Chapter 14 n Automating Customized Attacks 601
Figure 14-8: Configuring Burp Intruder to fuzz a login request
Figure 14-9: Results from fuzzing a single request
cc1144..iinndddd 660011 88//1199//22001111 1122::1155::2244 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 602
602 Chapter 14 n Automating Customized Attacks
From an initial look at the results, it appears that the application is vulnerable
to SQL injection. In both payload positions, when a single quotation mark is
submitted, the application returns a different response with a message contain-
ing the strings quotation and syntax. This behavior defi nitely warrants some
manual investigation to confi rm and exploit the bug.
TRY IT!
http://mdsec.net/auth/502/
TIP You can right-click any interesting-looking result and send the response
to the Burp Repeater tool. This enables you to modify the request manually
and reissue it multiple times to test the application’s handling of different
payloads, probe for fi lter bypasses, or deliver actual exploits.
Barriers to Automation
In many applications, the techniques described so far in this chapter can be
applied without any problems. In other cases, however, you may encounter
various obstacles that prevent you from straightforwardly performing custom-
ized automated attacks.
Barriers to automation typically fall into two categories:
n Session-handling mechanisms that defensively terminate sessions in
response to unexpected requests, employ ephemeral parameter values
such as anti-CSRF tokens that change per request (see Chapter 13), or
involve multistage processes.
n CAPTCHA controls designed to prevent automated tools from accessing a
particular application function, such as a function to register new user accounts.
We will examine each of these situations and describe ways in which you
may be able to circumvent the barriers to automation, either by refi ning your
automated tools or by fi nding defects in the application’s defenses.
Session-Handling Mechanisms
Many applications employ session-handling mechanisms and other stateful
functionality that can present problems for automated testing. Here are some
situations in which obstacles can arise:
cc1144..iinndddd 660022 88//1199//22001111 1122::1155::2255 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 603
Chapter 14 n Automating Customized Attacks 603
n While you are testing a request, the application terminates the session
being used for testing, either defensively or for other reasons, and the
remainder of the testing exercise is ineffective.
n An application function employs a changing token that must be supplied
with each request (for example, to prevent request forgery attacks).
n The request being tested appears within a multistage process. The request
is handled properly only if a series of other requests have fi rst been made
to get the application into a suitable state.
Obstacles of this kind can always be circumvented in principle by refi ning
your automation techniques to work with whatever mechanisms the appli-
cation is using. If you are writing your own testing code along the lines of
JAttack, you can directly implement support for specifi c token-handling or
multistage mechanisms. However, this approach can be complex and does
not scale very well to large applications. In practice, the need to write new
custom code to deal with each new instance of a problem may itself present a
signifi cant barrier to using automation, and you may fi nd yourself reverting
to slower manual techniques.
Session-Handling Support in Burp Suite
Fortunately, Burp Suite provides a range of features to handle all these situations
in as painless a manner as possible, allowing you to continue your testing while
Burp deals with the obstacles seamlessly in the background. These features are
based on the following components:
n Cookie jar
n Request macros
n Session-handling rules
We will briefl y describe how these features can be combined to overcome
barriers to automation and allow you to continue testing in the various situ-
ations described. More detailed help is available in the Burp Suite online
documentation.
Cookie Jar
Burp Suite maintains its own cookie jar, which tracks application cookies used
by your browser and by Burp’s own tools. You can confi gure how Burp auto-
matically updates the cookie jar, and you also can view and edit its contents
directly, as shown in Figure 14-10.
cc1144..iinndddd 660033 88//1199//22001111 1122::1155::2255 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 604
604 Chapter 14 n Automating Customized Attacks
Figure 14-10: The Burp Suite cookie jar
In itself, the cookie jar does not actually do anything, but the key values it tracks
can be used within the other components of Burp’s session-handling support.
Request Macros
A macro is a predefi ned sequence of one or more requests. Macros can be used
to perform various session-related tasks, including the following:
n Fetching a page of the application (such as the user’s home page) to check
that the current session is still valid
n Performing a login to obtain a new valid session
n Obtaining a token or nonce to use as a parameter in another request
n When scanning or fuzzing a request in a multistep process, performing
the necessary preceding requests to get the application into a state where
the targeted request will be accepted
Macros are recorded using your browser. When defi ning a macro, Burp dis-
plays a view of the Proxy history, from which you can select the requests to be
used for the macro. You can select from previously made requests, or record the
macro afresh and select the new items from the history, as shown in Figure 14-11.
For each item in the macro, the following settings can be confi gured, as shown
in Figure 14-12:
n Whether cookies from the cookie jar should be added to the request
n Whether cookies received in the response should be added to the cookie jar
n For each parameter in the request, whether it should use a preset value
or a value derived from a previous response in the macro
cc1144..iinndddd 660044 88//1199//22001111 1122::1155::2255 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 605
Chapter 14 n Automating Customized Attacks 605
Figure 14-11: Recording a request macro in Burp Suite
Figure 14-12: Configuring cookie and parameter handling for a macro item
cc1144..iinndddd 660055 88//1199//22001111 1122::1155::2255 PPMM
Stuttard c14.indd V3 - 08/11/2011 Page 606
606 Chapter 14 n Automating Customized Attacks
The ability to derive a parameter’s value from a previous response in the
macro is particularly useful in some multistage processes and in situations
where applications make aggressive use of anti-CSRF tokens. When you
defi ne a new macro, Burp tries to automatically fi nd any relationships of
this kind by identifying parameters whose values can be determined from
the preceding response (form fi eld values, redirection targets, query strings
in links).
Session-Handling Rules
The key component of Burp Suite’s session-handling support is the facility to