P17) executables compiled using Visual Studio and ELF executables
(P18-P25) compiled using g++.
Table 1 summarizes the 25 C++ programs. For each program, it
shows the program identifier, the program name, the project the
program belongs to, and source code and binary code statistics.
4
Nc
i =1
Nc
i =1
Nc
i =1
(i)
1
F
Evaluation metrics. We measure the overall performance of BCD
by computing the Precision P, Recall R, and F1 score values. The
number of functions in a component may have high variance (i.e.,
a few components may have a small number of functions, while
others may have a large number of functions). Such cases may
mislead our analysis if a simple average of component scores is
considered. Thus, we report a weighted average of scores [25] across
all components. This macro-averaged score is computed as
,
Ri
,
Pi
(1)
ni
Nf
ni
Nf
Pw =
Rw =
F w1 =
ni
Nf
(i)
where Pi, Ri, and F
1 are the scores for component Ci; Nf is the
total number of functions in all components; ni is the number of
functions in component Ci; and Nc is the total number of compo-
nents in the executable.
Graph weight hyperparameter training. In the decomposition
graph construction, hyperparameters α, β, and γ determine the
contribution of edge weights from the sequence graph, function-call
graph, and data-reference graph, respectively. For normalization,
we constrain α + β + γ = 1. To empirically obtain the value of
hyperparameters, we perform a grid-search over the range values.
Specifically, given a dataset of binary executables, we apply 5-fold
cross-validation by running BCD on the dataset for different values
of α, β ∈ [0, 1] with a step size of 0.1, and assign γ = 1 − α − β. The
final choice of hyperparameter values corresponds to the maximum
cross-validated average F w1 score.
Session 9: Software SecurityASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea396e
r
o
c
S
w1
F
1.0
0.8
0.6
0.4
0.2
1.0
0.8
0.6
0.4
0.2
e
r
o
c
S
PE
ELF
PE
ELF
P1
P8
P16
(a)
P25
P1
P8
P16
(b)
P25
Figure 2: (a) F w1
programs using different feature sets. (
score comparison for decomposing
CG-BCD,
All-BCD). (b)
recall and
DRG-CG-BCD,
Weighted-macro-averaged
precision,
DRG-BCD,
F1 scores.
Baseline. We compare the accuracy of BCD with three baseline
methods that use some (but not all) of the decomposition properties.
The first two baselines use a single decomposition property, i.e.,
either a CG (denoted by CG-BCD) or a DRG (denoted by DRG-BCD).
We avoid using the SG as baseline since it would result in either a
single component, or in each function forming its own component.
The third baseline uses a combination of edges from DRG and CG to
form the decomposition graph, denoted as DRG-CG-BCD. Finally,
we denote BCD by All-BCD, emphasizing that edges from all three
graphs are used to construct the decomposition graph.
3.2 Results
Figure 2-(a) shows the F w1 scores for the decomposition into compo-
nents output by BCD and the baseline methods. Here, PX indicates
the program identifier as per Table 1. For both PE and ELF exe-
cutables, the results clearly indicate that the highest F w1 score is
obtained by All-BCD, which outperforms the baseline methods.
Moreover, the baseline method DRG-CG-BCD, which combines
CG and DRG edges, performs better compared to the other base-
lines that use a single decomposition property (i.e. DRG-BCD and
CG-BCD). This supports our claim that a linear combination of
the edge weights from all three graphs improves the recovery of
components compared to the individual decomposition properties.
In addition, the difference in F w1 between PE and ELF programs is
negligible, indicating that BCD is robust to variations in executables
produced by different compilers. Moreover, function re-ordering
(from employing different compilers) can vastly affect the code
locality property, i.e., the sequence graph. The results of DRG-CG-
BCD perform close to All-BCD, indicating the robustness of BCD
to such transformations by ignoring SG edges during partitioning.
Analysis of errors. As BCD automatically determines the number
of components using Newman’s community detection method, the
resulting components may not always agree with the true number
of components in an executable, according to the ground truth. A
phenomenon called under-splitting occurs when functions truly
belonging to two or more classes are grouped into a single com-
ponent by BCD. Conversely, a phenomenon called over-splitting
occurs when a set of functions truly belonging to a single class are
distributed across multiple components.
5
We examine the performance of BCD in decomposing program
executables into components using the weighted macro-averaged
scores of precision, recall and F1. As illustrated in Figure 2-(b),
the median F w1 score of programs containing PE executables (and
corresponding variance) is 0.88±0.0036, and that of ELF executables
is 0.84 ± 0.001. Particularly, we observed that component under-
fitting occurs mainly in classes with only one or two functions.
These small-sized components lack strong code and data locality
features. For example, program P18 resulted in the least F w1 score.
This program has 7 classes, each having a single function. As a
result, we observed 2 under-split partitions, each having functions
from at least 3 different classes.
Hyperparameter sensitivity. We measure BCD’s sensitivity to
meta-weight parameter values by measuring the variance of α, β
and γ obtained during the 5 fold cross-validation. The average value
of meta-weight parameters yielding the highest F w1 score in each
run are α = 0.237±0.0026, β = 0.362±0.0026, and γ = 0.4±0.0028.
From these results, it can be observed that the performance of BCD
is not significantly sensitive to the training data.
Runtime. We measure the runtime for BCD by aggregating the
time spent during each step, i.e., decomposition properties extrac-
tion, decomposition graph construction, and partitioning. We use a
Windows 32-bit machine with 4GB RAM and disassemble the exe-
cutables using IDA [8]. The extraction of decomposition property
graphs took 3s for the smallest program (P3) and 30s for the pro-
gram (P24) with highest number of functions. Decomposition graph
construction took an average of 10s per program. BCD spends a
majority of time performing graph partitioning. Each iteration of
the LinLogLayout toolkit [24] took a minimum time of 3s for P6,
and a maximum time of 150s for P24.
4 RELATED WORK
There are numerous closely-related problems to binary decomposi-
tion. They include recovery of class hierarchy in C++ programs [30],
code clone detection [27], program diffing [13, 34], and identifica-
tion of functions with the same semantics [10, 15]. However, these
differ from binary decomposition in their goal. Our goal is to stati-
cally decompose an executable into groups of structurally related
functions. Functions belonging to the same component are likely
to have related structural properties, but they may have very differ-
ent syntactic representations and input-output relationships. For
example, an encryption routine is highly related to its decryption
routine and both are likely located in the same (cryptographic)
component, but their input-output relationships are very different
and can operate of very different data.
Most related are works on software module clustering [2, 19],
which cluster program source code to recommend the best split into
components to the developer. In contrast, our approach operates on
program executables and tries to recover the component structure
that the developer used, which are lost during compilation, rather
than recommending a new component structure.
5 DISCUSSION
Obfuscation. When designing BCD, we assume that the binary is
unobfuscated. In other words, our decomposition graph assumes
Session 9: Software SecurityASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea397that the function sequence is unchanged. However, we also evalu-
ated the robustness of BCD using only call-graph and data-reference
graphs. In our test, when function sequence graph is excluded, BCD
F w1 score reduces to from 0.86 to 0.78 for C++ applications. Al-
though an adversary could use obfuscation to defeat BCD, those
obfuscations might well have the side-effect of raising detection
alarms. For example, if BCD encounters a binary that seems to have
extremely chaotic locality properties, that in itself could be used as
a malware detection strategy. One way to address obfuscation is
to de-obfuscate before applying BCD, e.g., using solutions such as
dynamic unpackers [9].
Dynamic features. For simplicity, we have focused on features ex-
tracted statically from the executable. However, features extracted
from program executions could also be incorporated into the decom-
position graph, improving its efficiency. Some example dynamic
features that may provide useful modularity information are func-
tions used in a certain order and functions that access the same
data structures in heap-allocated memory.
6 CONCLUSION
This paper introduced the problem of binary code decomposition
and addressed its challenges by proposing a novel approach, called
BCD, for decomposing a program executable into components. BCD
takes a binary executable as input, and extracts code locality, data
references, and calling relationships to build a decomposition graph.
It then applies a graph-theoretic approach to partition the decompo-
sition graph into disjoint components. Our evaluation results show
that BCD is able to achieve a high precision and recall for decom-
posing the tested programs into components having structurally
related functions.
ACKNOWLEDGEMENTS
We would like to thank the anonymous reviewers for their valuable
comments. This work was partially supported by AFOSR awards
FA9550-14-1-0119 and FA9550-14-1-0173, ONR awards N00014-
14-1-0030 and N00014-17-1-2995, and NSF awards 1054629 and
1513704. Partial support was also provided by the Regional Gov-
ernment of Madrid through the N-GREENS Software-CM project
S2013/ICE-2731, the Spanish Government through the DEDETIS
grant TIN2015-7013-R, and the European Union through the ElasTest
project ICT-10-2016-731535.
REFERENCES
[1] Saed Alrabaee, Noman Saleem, Stere Preda, Lingyu Wang, and Mourad Debbabi.
2014. OBA2: An Onion Approach to Binary Code Authorship Attribution. In
Digital Investigation, Vol. 11. S94–S103.
[2] Nicolas Anquetil and Timothy C. Lethbridge. 1999. Experiments with Clustering
as a Software Remodularization Method. In Proc. 6th Working Conf. Reverse
Engineering (WCRE). 235–255.
[3] Tiffany Bao, Jonathan Burket, Maverick Woo, Rafael Turner, and David Brumley.
2014. BYTEWEIGHT: Learning to Recognize Functions in Binary Code. In Proc.
23rd USENIX Security Sym. 845–860.
[4] David Brumley, JongHyup Lee, Edward J. Schwartz, and Maverick Woo. 2013.
Native x86 Decompilation Using Semantics-preserving Structural Analysis and
Iterative Control-flow Structuring. In Proc. 22nd USENIX Security Sym.
[5] Juan Caballero, Noah M. Johnson, Stephen McCamant, and Dawn Song. 2010.
Binary Code Extraction and Interface Identification for Security Applications. In
Proc. 17th Annual Network & Distributed System Security Sym. (NDSS).
6
[6] Juan Caballero, Pongsin Poosankam, Stephen McCamant, Domagoj Babic, and
Dawn Song. 2010. Input Generation Via Decomposition and Re-Stitching: Finding
Bugs in Malware. In Proc. 17th ACM Conf. Computer and Communications Security
(CCS). 413–425.
[7] Richard Cole, Lee-Ad Gottlieb, and Moshe Lewenstein. 2004. Dictionary Matching
and Indexing with Errors and Don’t Cares. In Proc. 36th Annual ACM Sym. Theory
of Computing (STOC). 91–100.
[8] Chris Eagle. 2008. The IDA Pro Book: The Unofficial Guide to the World’s Most
Popular Disassembler. No Starch Press, San Francisco, CA, USA.
[9] Manuel Egele, Theodoor Scholte, Engin Kirda, and Christopher Kruegel. 2012. A
Survey on Automated Dynamic Malware-analysis Techniques and Tools. ACM
Computing Surveys (CSUR) 44, 2 (2012).
[10] Manuel Egele, Maverick Woo, Peter Chapman, and David Brumley. 2014. Blanket
Execution: Dynamic Similarity Testing for Program Binaries and Components.
In Proc. 23rd USENIX Security Sym.
[11] M. Van Emmerik and T. Waddington. 2004. Using a Decompiler for Real-world
Source Recovery. In Proc. 11th Working Conf. Reverse Engineering (WCRE). 27–36.
[12] Free Software Foundation. 1983. GNU Software Repository. www.gnu.org/
software/software.html. (1983). Retrieved 3/30/2018.
[13] Debin Gao, Michael K. Reiter, and Dawn Song. 2008. Binhunt: Automatically
finding semantic differences in binary programs. In ICICS.
[14] Emily R. Jacobson, Nathan Rosenblum, and Barton P. Miller. 2011. Labeling
Library Functions in Stripped Binaries. In Proc. 10th ACM SIGPLAN-SIGSOFT
Work. Program Analysis for Software Tools and Engineering (PASTE). 1–8.
[15] Lingxiao Jiang and Zhendong Su. 2009. Automatic Mining of Functionally Equiv-
alent Code Fragments Via Random Testing. In Proc. 18th Int. Sym. Software Testing
and Analysis (ISSTA). 81–92.
[16] Wei Ming Khoo, Alan Mycroft, and Ross Anderson. 2013. Rendezvous: A Search
Engine for Binary Code. In Proc. 10th Working Conf. Mining Software Repositories
(MSR). 329–338.
[17] Dohyeong Kim, William N. Sumner, Xiangyu Zhang, Dongyan Xu, and Hira
Agrawal. 2014. Reuse-oriented Reverse Engineering of Functional Components
From x86 Binaries. In Proc. 36th Int. Conf. Software Engineering (ICSE). 1128–1139.
[18] Clemens Kolbitsch, Thorsten Holz, Christopher Kruegel, and Engin Kirda. 2010.
Inspector Gadget: Automated Extraction of Proprietary Gadgets From Malware
Binaries. In Proc. 31st IEEE Sym. Security & Privacy (S&P).
[19] Spiros Mancoridis, Brian S. Mitchell, Yihfarn Chen, and Emden R. Gansner. 1999.
Bunch: A Clustering Tool for the Recovery and Maintenance of Software System
Structures. In Proc. IEEE Int. Conf. Software Maintenance (ICSM). 50–59.
[20] Xiaozhu Meng. 2016. Fine-grained Binary Code Authorship Identification. In Proc.
24th ACM SIGSOFT Int. Sym. Foundations Software Engineering (FSE). 1097–1099.
[21] Microsoft. 2007. Visual Studio sample codes. code.msdn.microsoft.com/vstudio.
(2007). Retrieved 3/30/2018.
[22] Mark E.J. Newman. 2004. Fast Algorithm for Detecting Community Structure in
Networks. Physical Review E 69, 6 (2004), 066133.
[23] Beng Heng Ng and Atul Prakash. 2013. Exposé: Discovering Potential Binary
Code Re-use. In Proc. 37th IEEE Annual Computer Software and Applications Conf.
(COMPSAC). 492–501.
[24] Andreas Noack. 2009. LinLogLayout: Graph Clustering and Force-directed Graph
Layout. code.google.com/p/linloglayout. (2009). Retrieved 3/30/2018.
[25] Arzucan Özgür, Levent Özgür, and Tunga Güngör. 2005. Text Categorization
with Class-based and Corpus-based Keyword Selection. In Proc. 20th Int. Sym.
Computer and Information Sciences (ISCIS). 606–615.
[26] Nathan Rosenblum, Xiaojin Zhu, and Barton P. Miller. 2011. Who Wrote This
Code? Identifying the Authors of Program Binaries. In Proc. 16th European Conf.
Research in Computer Security (ESORICS). 172–189.
[27] Andreas Sæbjørnsen, Jeremiah Willcock, Thomas Panas, Daniel Quinlan, and
Zhendong Su. 2009. Detecting Code Clones in Binary Executables. In Proc. 18th
Int. Sym. Software Testing and Analysis (ISSTA). 117–128.
[28] Slashdot Media. 1999. SourceForge. sourceforge.net. (1999). Retrieved 3/30/2018.
[29] Randy Smith and Susan Horwitz. 2009. Detecting and Measuring Similarity in
Code Clones. In Proc. 3rd REF/TCSE Int. Work. Software Clones (IWSC). 28–34.
[30] Venkatesh Srinivasan and Thomas Reps. 2014. Recovery of Class Hierarchies and
Composition Relationships From Machine Code. In Proc. 23rd Int. Conf. Compiler
Construction (CC). 61–84.
[31] Wenhao Wang, Xiaoyang Xu, and Kevin W. Hamlen. 2017. Object Flow Integrity.
In Proceedings of the 24th ACM Conference on Computer and Communications
Security (CCS). 1909–1924.
[32] Xinran Wang, Yoon-Chan Jhi, Sencun Zhu, and Peng Liu. 2009. Behavior Based
Software Theft Detection. In Proc. 16th ACM Conf. Computer and Communications
Security (CCS). 280–290.
[33] Fangfang Zhang, Yoon-Chan Jhi, Dinghao Wu, Peng Liu, and Sencun Zhu. 2012.
A First Step Towards Algorithm Plagiarism Detection. In Proc. 21st Int. Sym.
Software Testing and Analysis (ISSTA). 111–121.
[34] Zynamics. 2004. BinDiff. www.zynamics.com/bindiff.html. (2004). Retrieved
3/30/2018.
Session 9: Software SecurityASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea398