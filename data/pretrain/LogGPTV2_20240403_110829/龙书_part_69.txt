---
## Page 268
个函数应用和名字构成。这些名字具有预定义的多态类型。
个合一算法。
的是最一般化的合一置换，这种合一置换对表达式中的变量施加的约束最少。6.5.5节给出了一
式t和tz可以合一{unify)的条件是存在某个置换 S使得 S(t,）=S(t2）。在实践中，我们感兴趣
应用置换S后得到的结果写作S(t)，详细信息请参见“置换、实例和合一"部分。两个类型表达
式，从而使得s和t在结构上等价。
算法6.16
两种类型“合--”。非正式地讲，我们将确定是否可以将类型变量和替换为特定的类型表达
类型为 s-→s'的E;应用到类型为的E2上。我们不能简单地确定s和是否等价，而是必须将这
元素类型的占位符，也就是说，x的类型为"α的列表”。
列表上，所以×必须是一-个列表。我们使用变量α作为列表
左到右考虑标号为 if 的结点的子结点。因为 null 要被应用在
数”
被求值并不是问题。它们不会被同时计算）。
的三元组上（对于类型检查，究竟是 then 分支还是 else 分支
标号为if的结点表示将运算符if应用于它的三个子结点组成
标号为+的结点表示对两个子结点应用运算符+。类似的，
它表示函数定义。其他的非叶子结点可以看作是函数应用。
例6.15
导规则。这里再重复一下：
说，S'对施加的限制比S施加的限制更多。
的一个实例，那么我们就说 S 是t和 l2 的最一-般化的合一替换(most general unifier）。换句话
如果对于和t2的任何合一替换，比如说S"，下面的条件成立：对于任意的t，S"（t)是 S（t)
必须将α的所有出现替换为相同的类型表达式。
S(t)被称为的---个实例（instance）。例如，list(integer）是list(（α）的-一个实例，因为它是将 list
那么我们用 S(t)来表示将：中的每个类型变量α的所有出现替换为 S(α)后得到的结果。
输入：一个由－-系列函数定义以及紧跟其后的待求值表达式组成的程序。一个表达式由多
我们可以根据函数 length 的函数体推导出它的类型。
置换（substitution)是--个从类型变量到类型表达式的映射。我们把对类型表达式中的变量
如果 null(x)为真，则length(x)为 0。因此，length 的类型一-定是“从α的列表到整型的函
252
对于类型表达式和t2，如果S(）=S(t2），那么置换 S就是--个合一替换(unier)。
因为在类型表达式中可能出现变量，所以我们必须重新审视一下类型等价的概念。设想将
。这个推导得到的类型和在 else 分支length（tl(x））+1 中对 length 的使用是--致的。
如果t是--个类型表达式，且S是一个置换（即一个从类型变量到类型表达式的映射）
一个例子对length 类型进行了非正式的推导，推导过程中隐式地使用了公式(6.9)中的推
图6-29 中的抽象语法树表示图6-28 中对 lengh 的定义。这棵树的根的标号为 fun,
多态函数的类型推导。
then 对某些α 和β,f的类型为 α→β 且x 的类型为 α
if f(x)是一-个表达式
置换、实例和合一
图6-29图6-28中的函数定义
iergth
对应的抽象语法分析树
null
apply
un
length.
appiy
cepply
第6章
+
---
## Page 269
匹配，见第5行。
null)来替换受限变量α，见第4 行。因为 null 被应用于，我们推导出x的类型β 必须和 list（α,)
两个子结点的类型必须和α;合一。
if)，并移除V，见图 6-30 中的第三行。函数i的左子结点的类型必须和 boolean 类型合一，其他
尔型变量以及两个分别代表 then 和 else 分支的表达式。函数 if 的类型是Vα.boolean ×α×α一α。
的1~2行。
数定义，因此我们引l人变量β和y，并将类型 β→关联到函数 length，将 β 关联到x。见图 6-30
例6.17
导得到的该函数的类型。
通过检查s 是否和α的类型匹配，s 是否和b的类型匹配，就可以检查表达式f(α，b)的类型。
其类型表示为s×s2→t，其中 s 和 s2 分别是x和x2 的类型，而t是函数f(x，2)的结果类型。
中间代码生成
预定义函数 null的类型为Vα. ist(α）-→boolean。我们使用--个新的类型变量α,（其中n 表示
在根的右子结点上，我们把看作一个应用到三元组上的多态函数，这个三元组包括--个布
检查输人序列中的函数定义和表达式。当一个函数在其后的表达式中被使用时，就使用推
在if的第一个子结点上，null(x)的类型 bolean 和 if 函数预期的类型相匹配。在第二个子结
·对于第一次碰到的变量，引人一个新的类型变量来代表它的类型。
对一个函数定义 fun id,（idz）=E，创建一个新的类型变量α 和 β。将函数 id，与类型
输出：推导出的程序中名字的类型。
移除V量词。替换得到的类型表达式就是这个多态函数的本次出现所对应的推导类型。
对一个多态函数的每次出现，将它的类型表达式中的受限变量替换为互不相同的新变量，并
返回类型错误，否则推导得到的E（E2）的类型为s'。
变量）。假定推导得到的 E2的类型为t。对s和t进行合一处理。如果合一失败，表达式
定具有 s→>s`的形式(从技术上来说，E, 的类型必须和β→合一，其中β和是新的类型
对于函数应用E,（E2），推导出E,和E2的类型。因为E，被用作一个函数，它的类型-
用V量词来限制s-→中任何未受约束的类型变量。
行类型推导之后，α表示类型s而β 表示类型t。推导得到的函数id，的类型就是s-→l。
α一→β相关联，参数 id,和类型α 相关联。然后，推导出表达式E 的类型。假设在对 E进
在图6-30 中，我们为函数 length 推导出一-个类型。图6-29 中语法树的根表示--个函
length(t(x) + 1
length(t(±)
图6-30推导图6-28 中的函数 length 的类型
length
表达式：类型
tl(2)
integer
integer
integer
list(αn)
X0;X0i→li
253
口
使
---
## Page 270
的结点被合一后，各个结点所属的等价类的编号。
这两个表达式被表示为图6-31中标号为→：1的两个结点。结点上的整数编号指明了在编号为1
这个置换将上述两个类型表达式映射成如下的表达式
下列的置换S是这两个表达式的最一般化的合一替换：
例6.18
有同样的类型构造算子，且它们的对应子结点必须等价。
个等价类中，那么它们代表的类型表达式就必须合一。因此，同一个等价类中的内部结点必须具
叶子结点表示，类型构造算子用内部结点表示。结点被分成若干的等价类。如果两个结点在同一
环类型的结构等价性。
t合一当且仅当它们完全相同。本节中的合一算法可以处理含有环的图，因此它可以用于测试循
和t相同。测试表达式是否等价是合一的一个特殊情况。如果s和t中只有常量没有变量，则s和
6.5.5一个合一算法
此，我们可以把它变成一-个受限变量，并把length 的类型写作：
length 的类型中。因为没有对α,作出任何假设，当使用该函数时α，可以被替换为任何类型。因
推出 length 的类型为 list（α,）→integer。在检查完这个函数定义之后，类型变量α,，仍然保留在
中t表示“tail"），见第8行。根据tl(x)的应用，我们推导出 List（α,）=β=list（α,），见第9行。
点上，类型α;与 integer 进行合一，见第6 行。
在有些应用中，对一个变量和一个包含该变量的表达式进行合一是错误的。算法6.19 允许这种替换。
非正式地讲，合一就是判断能否通过将两个表达式s和：中的变量替换为某些表达式，使得
现在考虑子表达式length(t(x)）+1。我们为t类型中的约束变量α建立新的临时变量α（其
我们将实现一种基于图论表示方法的合--算法，其中类型被表示成图的形式。类型变量用
因为length(tl(x))是+的一个运算分量，它的类型必须和 integer 合一-，见第 10 行。可以
254
考虑下列两个类型表达式
((α→α2）×list(α))→list(α2)
((αg→α4）×list(α3)）→αs
((α→α2)×list(αs))→list(α2)
图6-31合一后的等价类
list :6
list :8
Q5
8
list(α2)
S(x)
α3:4
04:5
list : 6
05 : 8
第6章
口
口
---
## Page 271
算子，或者是一个基本类型。那么，fnd 将会返回一个反映该类型构造算子或基本类型的代表结
人满足下面条件的等价类中，即这个等价类中的一个结点代表的表达式或者带有-个类型构造
达式的结点所在的等价类中。假设m 或n 表示一个变量的叶子结点，同时假设这个结点已经
归检查子结点之前减少了等价类的个数，因此算法终止。
并它们的等价类，并递归地检查它们的各个子结点是否等价。因为首先进行合并操作，我们在递
uniy(m，n)返回 true。如果s和t都是代表某个二目类型构造算子的内部结点，那么我们尝试合
m和n 在同-个等价类中，那么代表结点s和相等。如果s和t表示相同的基本类型，则调用
的指针前进，直到到达代表结点(即 set字段指针为空指针的结点)为止。
一个等价类的代表结点即可。为了找到-一个结点所属的等价类，我们沿着各个结点的 sct 字段中
的代表结点。
间接地)指向该等价类的代表结点。在初始时刻，每个结点n自身组成一个等价类，n是它自己
表，它的 set 字段包含一个空指针。等价类中其他结点的 set 字段(可能通过该集合中的其他结点
点的指针。字段 se 用于保存等价结点的集合。每个等价类都有一个结点被选作这个类的唯一代
算法6.19
将一个变量置换为一个表达式的实现方法如下：把代表该变量的叶子结点加人到代表该表
请注意，图6-32 中的算法分别使用s=find(m)和t=find(n），而不是直接使用m 和 n。如果
中间代码生成
集合的 union 操作的实现很简单，只需要改变一个等价类的代表结点的 set 字段，使之指向另
·union(m，n)将包含结点 m和n 的等价类合并。如果 m和 n 所对应的等价类的代表结点
? find( n)返回当前包含结点 n 的等价类的代表结点。
如图6-32所示的合一算法在结点上进行如下两种操作：
方法：结点用一个记录实现，记录中的字段用于存放一个二元运算符和分别指向其左右子结
输
输入：一个表示类型的图，以及需要进行合一处理的结点对 m和 n。
出：如果结点 m 和n 表示的表达式可以合一，返回布尔值 true。反之，返回 false。
过该变量被合一
型，我们就不能用一个变量作为该等价类的代表。否则，两个不等价的表达式可能会通
性非常重要，因为如果一个等价类对应于一个带有类型构造算子的类型表达式或基本类
否则，union 把任意一个原代表结点作为新的代表结点。这种在 union 的规约中的非对称
中有一个是非变量的结点，则 union 将这个非变量结点作为合并后的等价类的代表结点;
类型图中的一对结点的合一处理。
else return false;
else if(s或者t表示一个变量)
else
return unify(s1,t:) and unify(s2;t2):
union(s,t);
图6-32合一算法
t是一个带有子结点t和t的op-结点）{
放
---
## Page 272
式用来改变控制流，而一个赋值语句右部的表达式用来表示一个逻辑值。有多种方式可以描述
术表达式一样，使用带有逻辑运算符的三地址指令进行求值。
的取值为真。
由程序到达的某个位置隐含地指出。例如，在讯(E)S中，如果运行到语句S，就意味着表达式E
计语言中，布尔表达式经常用来：
6.6控制流
下地确定属性 umnique 的值，这个属性表示各个子表达式的类型。
自底向上的方式综合得到一个可能类型的集合。在确定了整个表达式的唯一类型之后，自顶向
描述一个可以确定每个子表达式的唯一类型的语法制导定义(SDD)。它首先使用属性type，按照
生式为E→E（E2）)有如下规则：
子表达式本身只能推导出一个可能类型的集合。也就是说，将函数E，应用于参数E2（其文法产
下列表达式。假定c和d是字符型，s和t是短整型，i和j为整型，x是浮点型。
6.5.66.5节的练习
置换 S 的结果如例 6.18 所示。
我们看到α3 的代表结点为4，这个结点表示α。结点8是αs 的代表结点，这个结点表示 ist（α2）。
个变量α,find(α)给出α 的等价类的代表结点 n。n 所表示的表达式为 S(α)。例如，在图 6-31 中,
行 uni访(1,9)得到的结果就是前面在图 6-31 中显示的图。
一个运算符。因此将结点1和9合并成同--个等价类，并调用 unify(2，10）和 uniy(8，14)。执
在的等价类仅仅包含该结点。当应用算法6.19 来计算 unijy(1,9)时，注意到结点1和9 表示同