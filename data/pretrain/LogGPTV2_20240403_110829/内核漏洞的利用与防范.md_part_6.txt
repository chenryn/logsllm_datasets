char*p:
printf("Pointervalue:%p\n".p);
intmain(）
big_stack_usage();
ptr_un_initialized();
编译执行该程序，我们得到（注意，字母A的十六进制值是0x41）：
macosxbox$gcc-oppointer.c
macosxbox$./p
Pointerva1ue:0x41414141
macosxbox$
可以看到，指针分配的地方恰恰是前面的函数ptr_un_initializedO在栈里留下的内容。
事实上，这一部分使用过后的剩留内存称为“死内存”或“死栈”。当然了，是我们自己编写了上
述例子，.您会认为这种情况发生几率很低，那么请看如下真实存在的代码，来自FreeBSD8.0：3
structucred ucred,*ucp:
[1]
[...]
refcount_init(&ucred.cr_ref,1);
ucred.cr_uid=ip->i_uid;
ucred.cr_ngroups=1:
ucred.cr_groups[o]-dp->i_gid;
[2]
ucp-&ucred;
注意在[1]处，ucred在栈中声明。而后，在[2]处，cr-groups[o]被赋值为dp->i
gid，遗憾的是，ucred结构体是这样定义的：
structucred{
u_int
cr_ref;
*引用计数*/
[...]
gid_t
*cr_groups;/*组*/
int
cr_agroups；/*可用的组*/
1：
---
## Page 28
第2章内核漏洞分类19
正如所看到的，cr_groups是一个指针，并且它没有被初始化，而是会被直接使用。这意
味着，dp->i_gid的值在栈中刚才ucred所在的位置。
洞”一节介绍），可以把指针所指的地方的一个或多个字节更改掉。这种情况要比简单地解引
用NULL指针更常见，也常常能给利用者带来某种控制权限。
“未经验证的”指针常常在内核区域的多用户寻址空间显示巨大威力。正如第1章提到的，
内核区域地址在用户区域之上，它的页表在所有进程的页表上都有备份。有些虚拟地址被选作
“限定地址”，所以这个地址以上或以下的归内核使用，而其他的归用户进程使用。内核函数使
用这个“限定地址”来判断一个指针指向的是内核还是用户进程。如果一个指针是前者可能不
需要这样的验证，但如果是后者则需要非常小心。如果没有经过验证，或许一个指向用户区域
的指针就可能被赋予过多的权限。
下面举一个例子，注意下面的Linux路径：
error=get_user(base,&iov->iov_base);
[1]
[...]
if(unlikely(!base）)1
error=-EFAULT;
break:
[...]
sd.u.userptr=base;
[2]
[...]
size=__splice_from_pipe(pipe,&sd,pipe_to_user);
[...]
staticintpipe_to_user(structpipe_inode_info*pipe,struct
pipe_buffer*buf.
structsplice_desc*sd)
if(!fault_in_pages_writeable(sd->u.userptr,sd->len))1
src=buf->ops->map(pipe,buf,1);
ret=__copy_to_user_inatomic(sd->u.userptr,src
buf->offset,sd->1en):
[3]
buf->ops->unmap(pipe,buf,src);
[..]
这段代码的第一部分来自vmspTice_to_userO）函数，在[i]处使用了get_userO函数
获得目标指针。而目标指针在没有经过验证的情况下在[2]处传递给了_splice_from_pipe（）
函数，同时传给作为帮助函数的pipe_to_userO。这个函数也没有做任何的检查并且在结
尾处也就是[3]处调用了_copy_to_user_inatomic（）函数。我们将在本书的剩下部分讨论
各种从内部的内核态向用户态或者是用户态向用户态拷贝数据的方法；目前，只知道Linux中
以下划线开头的函数（例如_copy_to_user_inatomicO））是不会对所提供的目标用户指针
（或者是源指针）进行检查验证的。这个漏洞使得用户将一个内核地址传递到内核，从而直接
访问（或修改）内核内存。
---
## Page 29
20第一部分内核态
目前我们已经讨论了指针解引用的问题，但是还没有讨论使用它们的内核路径有哪些可执
行的访问方式。当内核试图从销毁的指针处读取数据时，将会发生任意读的情况，而当内核试
图向指针所关联的内存地址中存储一个值时（也就是前述的例子中的情况），将会发生任意写
的情况。而且，当利用者能够全部或者部分控制指针指向的地址时，就会发生一个受控的或是
部分受控的读/写操作，而当利用者也无法控制被销毁的指针的值时，就会发生一个不可控的
的地址，因此也能够成功地、可靠地利用这种情况。
内存破坏漏洞
下面要集中谈的是另一大类的bug，是关于内核区域内存破坏的，是由程序中的错误操作
重写了内核区域的内存导致的。基本上可以分为两大类：一类是内核栈漏洞，与内核态运行的
进程和线程相关：另一类是内核堆漏洞，往往与在内核区域中分配空间的小型对象和临时区域
有关。
与上节相同，我们把如何利用这些漏洞放在第二部分的第3章中讲解。
内核栈漏洞
首先要讨论的内存类型是内核栈，每个在系统中运行着的用户进程都至少会有两个栈：用
户态栈和内核态栈，每次当进程进入到内核态时，内核栈就会发挥作用（即，每次当进程从内
核处请求服务时：例如，分配一个系统调用就会产生这样的结果）。
内核态栈的功能和典型的用户态栈的功能是一样的，而且内核态栈也遵循用户态栈
在架构上的一些惯例和约定。这些约定包括增长方向（要么是向下增长的，即从高地址
向低地址增长或者是相反），存放栈顶指针的寄存器（通常称为栈指针），以及程序与之
相互作用的方式（局部变量如何存储的，参数如何传递的，嵌入的调用是如何链接在一
起的等）。
虽然内核态栈和用户态栈在功能方面是相同的，但是也有一些细微差异。例如，内核栈在
大小上通常有限制（在x86架构中通常是4KB或者8KB），因此采用那种使用尽可能少的局部
变量的方式进行内核编程。并且，所有进程的内核栈都是一个相同的虚拟地址空间（内核地址
空间）的一部分，它们开始于不同的虚拟地址也占据不同的虚拟地址。
注意有些操作系统如Linux使用所谓的中断栈。这个栈用于处理硬件产生的中断，
以分流内核栈的压力（前面提到过内核栈往往很小）。在小内核栈的情况下，这个特
殊的栈用于防止对内核态栈的容量产生过大压力。
正如您在这段介绍中看到的，内核栈漏洞与普通用户栈漏洞非常类似，它们都是由越界写
人造成的，比如下面这些情况：
·使用不安全的C函数，如strcpy（）或sprintf（）。这两个函数都是向目标缓冲区写入
内容直到遇到\0结束符，而不检查写入了多少。
---
## Page 30
第2章内核漏洞分类21
·或者，不正确的循环结束条件也可能造成类似问题：
#defineARRAY_SIZE10
voidfunc（）
intarray[ARRAY_SIZE]:
for（j=O:jp_aio:
if（aiop==NULL1|nent<=0）
[2]
return（EINVAL):
if（model==DATAMODEL_NATIVE)
ssize=(sizeof（aiocb_t*)*nent);
else