- / -
- / -
- / -
0.5 ± 0.2 / 2.3 ± 1.2
0.5 ± 0.1 / 5.7 ± 2.4
0.7 ± 0.3 / 3.4 ± 2.3
5.3 ± 0.1 / 11.3 ± 0.6
7.5 ± 0.2 / 15.9 ± 3.8
runs to the right, and Mario is killed when he stops moving.
This decision was made to produce speed run like results,
with short execution times. We use both AFL and AFL in
combination with IJON annotations to play the game and
observe the progress made in the game.
We ran AFL without annotations for 12 hours and observed
how far into the different levels Mario was able to reach. We
added a simple annotation that uses the ijon_max primitive.
We create one slot for each possible height (measured in tiles).
In each slot, we maximize the x coordinate of the player. The
changed code was shown earlier in Listing 9. The results can
be seen in Table III, an example was shown earlier in Figure 1.
With this simple one line annotation, the fuzzer solved nearly
all levels in a matter of minutes. In fact, using IJON, AFL
is able to solve all but 3 levels. It should be noted that only
one of these levels (level 6-2) can be solved. The fact that
it remained unsolved is due to the inherent randomness in
fuzzing. In another ofﬂine experiment, IJON was sometimes
able to solve the level in less than 6 hours. Level 4-4 is
unsolvable due to a bug in the emulation. The last level seems
impossible/extremely hard to solve due to the modiﬁcations
we made in the game.
Plain AFL, on the other hand, struggles: It takes signiﬁ-
cantly longer to solve far fewer levels and makes less progress
in the levels it did not solve. Note that AFL is in fact
surprisingly good. On the ﬁrst look, it might seem that AFL
should have nearly no feedback to uncover as it advances
throughout the levels. Yet, it appears that the edge counts for
events such as “spawn a pipe, cloud, enemy, or bush” is already
good enough to solve about one-third of the levels.
a) Glitches: Super Mario Bros. contains various well-
known glitches and secret passages, commonly exploited by
Level
Solved
AFL
Time % Distance
Solved
IJON
Time % Distance
1-1
1-2
1-3
1-4
2-1
2-2
2-3
2-4
3-1
3-2
3-3
3-4
4-1
4-2
4-3
4-4
5-1
5-2
5-3
5-4
6-1
6-2
6-3
6-4
7-1
7-2
7-3
7-4
8-1
8-2
8-3
1
3

1
3
2
3






2
3
1
3





2
3
1
3

2
3
2
3





2
3
07:11
07:12
08:39
08:37
09:55
07:31
09:25
00:31
08:16
07:15
08:36
09:35
05:41
02:07
11:24
02:22
11:11
11:27
09:19
04:32
08:56
09:57
06:01
06:01
04:44
06:37
10:08
08:07
01:36
07:17
07:18
91%
61%
71%
100%
42%
57%
88%
65%
33%
80%
100%
77%
83%
95%
100%
82%
60%
73%
100%
100%
93%
36%
100%
100%
63%
58%
92%
100%
21%
60%
100%
00:25
00:59
00:20
00:23
06:44
00:16
00:18
00:06
02:42
00:28
00:03
00:40
00:11
02:06
00:16
00:06
00:45
00:23
00:26
00:12
00:36
06:32
00:08
00:07
00:25
00:13
00:24
00:06
06:02
03:12
00:18
100%
100%
100%
100%
94%
100%
100%
100%
100%
100%
100%
100%
100%
118%
100%
82%
100%
100%
100%
100%
100%
82%
100%
100%
100%
100%
100%
100%
100%
100%
100%



2
3
2
3
speed-runners. Our fuzzer was able to ﬁnd and exploit at least
two of those. First, we were able to exit the top of the level in
stage 4-2, leading to the famous warp zone. Second, at various
times Mario used a “wall-jump” and escape certain deaths. To
perform a wall-jump, Mario has to jump into a wall, landing
exactly at the corner of a tile. For one frame, Mario’s foot
enters the wall, before the physics engine pushes Mario out of
the wall again. In this frame, Mario is able to jump again. This
trick requires both perfect timing, as well as very precisely
hitting the corner of a wall tile (Mario’s position is tracked
with sub-pixel accuracy).
D. Structured Input Formats – State Change Logging
To demonstrate the ability to explore structured input for-
mats using state change logging, we evaluate AFL with IJON
on three examples. The ﬁrst two are taken from evaluation of
AFLSMART [44]. In their paper, Pham et al. present multiple
case studies; in particular, the paper discusses two examples
(libpng and WavPack) in more detail. We picked both ex-
amples and added a simple state_change_log annotation
as described in Section III-A2. We ran both annotated versions
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:17:13 UTC from IEEE Xplore.  Restrictions apply. 
1606
for 24 hours on an Intel Core i7-6700 CPU clocked at 3.40
GHz with 16 GB of RAM. We also provided the ﬁrst 1024
bytes of a random wav/png ﬁle as seed and used a dictionary
of strings from the source code. With this simple annotation,
we were able to uncover bugs in both targets, while AFL did
not ﬁnd any of the bugs. Additionally, we found another out-
of-bounds read in libpng that is still present (but reported)
in the most up-to-date version of libpng. This demonstrates
that for these structured input formats, a grammar is not
actually needed to discover these security issues. Adding a
small annotation in the parser code can sometimes provide
the exact same beneﬁt at much smaller cost to the analyst.
To further substantiate this observation, we picked an-
other example to demonstrate how AFL with the same
state_change_log annotation explores a much larger
combination of features than plain AFL would. LIBTPMS
is a software emulator for Trusted Platform Module (TPM)
security co-processors. It is commonly used in virtualization
solutions to create virtualized modules. TPM speciﬁes a
protocol that can be used to interact with the co-processor.
The protocol consists of a wide variety of possible messages,
each of which has a speciﬁc parser. This situation reassembles
Listing 2. We demonstrate that AFL only explores a small
subset of all possible message sequences. Then we introduce
a single IJON annotation (two lines). In AFL, we now observe
a massive increase in the number of combinations of messages
explored. Note that we used AFL’s persistent mode to improve
performance of the fuzzing and obtain more sound results
within the allocated times. However, other tools such as
ANGORA and QSYM are incompatible with this approach.
This is less problematic, since in this experiment we do not
care about solving individual constraints. Instead, we care
about
the number of distinct message sequences explored
which neither ANGORA nor QSYM provides a better feedback
for this kind of scenario. As a consequence, we chose to only
evaluate AFL and AFL with IJON.
a) Initial Run: We ran AFL for 24h and plotted the
subset of the paths found. The results can be seen in Table IV
in the columns labeled “plain”. To visualize, we also included
the graph of all messages found for one run. Each node is
a message that was successfully parsed and handled. If we
successfully handled message A and message B after each
other, we add an edge between node A and B.
b) IJON: We added a change log based annotation that
stores the last 4 successfully parsed and handled message IDs.
Then we use these IDs to create additional feedback. The
annotated code is displayed in Listing 7. Using this annotation,
we performed another 24-hour run. The number of paths found
can be seen in Table IV in the columns labeled “IJON”.
We observe, that IJON leads to signiﬁcantly more complex
interactions.
From both the experiments on the AFLSMART examples
and on TPM, it can be seen that using state change log
annotation drastically increases the ability to explore different
chains of messages (and therefore state) that would not be cov-
ered using current techniques. In particular, our experiments
TABLE IV: The number of distinct message sequences found by AFL and
AFL + IJON fuzzing TPM
Seq. Length
AFL Plain
AFL +IJON
Improvement
1
2
3
4
14
53
85
79
14
156
1636
2532
1x
2x
18x
32x