ordered by these type codes (numerically in ascending order), with some attribute types appearing 
more than once—if a file has multiple data attributes, for example, or multiple file names. All possible 
attribute types (and their names) are listed in the AttrDef metadata file.
Each attribute in a file record is identified with its attribute type code and has a value and an op-
tional name. An attribute’s value is the byte stream composing the attribute. For example, the value of 
the FILE_NAME attribute is the file’s name; the value of the DATA attribute is whatever bytes the user 
stored in the file.
Most attributes never have names, although the index-related attributes and the DATA attribute 
often do. Names distinguish between multiple attributes of the same type that a file can include. For 
example, a file that has a named data stream has two DATA attributes: an unnamed DATA attribute 
storing the default unnamed data stream, and a named DATA attribute having the name of the alter-
nate stream and storing the named stream’s data.
664
CHAPTER 11
Caching and file systems
File names
Both NTFS and FAT allow each file name in a path to be as many as 255 characters long. File names can 
contain Unicode characters as well as multiple periods and embedded spaces. However, the FAT file 
system supplied with MS-DOS is limited to 8 (non-Unicode) characters for its file names, followed by 
a period and a 3-character extension. Figure 11-35 provides a visual representation of the different file 
namespaces Windows supports and shows how they intersect.
Windows Subsystem for Linux (WSL) requires the biggest namespace of all the application execu-
tion environments that Windows supports, and therefore the NTFS namespace is equivalent to the 
WSL namespace. WSL can create names that aren’t visible to Windows and MS-DOS applications, 
including names with trailing periods and trailing spaces. Ordinarily, creating a file using the large 
POSIX namespace isn’t a problem because you would do that only if you intended WSL applications 
to use that file.
"TrailingDots..."
"SameNameDifferentCase"
"samenamedifferentcase"
"TrailingSpaces   "
Examples
"LongFileName"
"UnicodeName.Φ∆ΠΛ"
"File.Name.With.Dots"
"File.Name2.With.Dots"
"Name With Embedded Spaces"
".BeginningDot"
"EIGHTCHR.123"
"CASEBLND.TYP"
WSL
Windows
subsystem
MS-DOS–Windows
clients
FIGURE 11-35 Windows file namespaces.
The relationship between 32-bit Windows applications and MS-DOS and 16-bit Windows applica-
tions is a much closer one, however. The Windows area in Figure 11-35 represents file names that the 
Windows subsystem can create on an NTFS volume but that MS-DOS and 16-bit Windows applications 
can’t see. This group includes file names longer than the 8.3 format of MS-DOS names, those contain-
ing Unicode (international) characters, those with multiple period characters or a beginning period, 
and those with embedded spaces. For compatibility reasons, when a file is created with such a name, 
NTFS automatically generates an alternate, MS-DOS-style file name for the file. Windows displays these 
short names when you use the /x option with the dir command.
The MS-DOS file names are fully functional aliases for the NTFS files and are stored in the same 
directory as the long file names. The MFT record for a file with an autogenerated MS-DOS file name is 
shown in Figure 11-36.
CHAPTER 11
Caching and file systems
665
Standard
information
NTFS
file name
MS-DOS
file name
Data
New file name
attribute
FIGURE 11-36 MFT file record with an MS-DOS file name attribute.
The NTFS name and the generated MS-DOS name are stored in the same file record and therefore 
refer to the same file. The MS-DOS name can be used to open, read from, write to, or copy the file. If 
a user renames the file using either the long file name or the short file name, the new name replaces 
both the existing names. If the new name isn’t a valid MS-DOS name, NTFS generates another MS-DOS 
name for the file. (Note that NTFS only generates MS-DOS-style file names for the first file name.)
Note Hard links are implemented in a similar way. When a hard link to a file is created, NTFS 
adds another file name attribute to the file’s MFT file record, and adds an entry in the Index 
Allocation attribute of the directory in which the new link resides. The two situations differ in 
one regard, however. When a user deletes a file that has multiple names (hard links), the file 
record and the file remain in place. The file and its record are deleted only when the last file 
name (hard link) is deleted. If a file has both an NTFS name and an autogenerated MS-DOS 
name, however, a user can delete the file using either name.
Here’s the algorithm NTFS uses to generate an MS-DOS name from a long file name. The algo-
rithm is actually implemented in the kernel function RtlGenerate8dot3Name and can change in future 
Windows releases. The latter function is also used by other drivers, such as CDFS, FAT, and third-party 
file systems:
1.
Remove from the long name any characters that are illegal in MS-DOS names, including spaces
and Unicode characters. Remove preceding and trailing periods. Remove all other embedded
periods, except the last one.
2.
Truncate the string before the period (if present) to six characters (it may already be six or fewer
because this algorithm is applied when any character that is illegal in MS-DOS is present in the
name). If it is two or fewer characters, generate and concatenate a four-character hex checksum
string. Append the string n (where n is a number, starting with 1, that is used to distinguish
different files that truncate to the same name). Truncate the string after the period (if present)
to three characters.
3.
Put the result in uppercase letters. MS-DOS is case-insensitive, and this step guarantees that
NTFS won’t generate a new name that differs from the old name only in case.
4.
If the generated name duplicates an existing name in the directory, increment the n string. If n
is greater than 4, and a checksum was not concatenated already, truncate the string before the
period to two characters and generate and concatenate a four-character hex checksum string.
666
CHAPTER 11
Caching and file systems
Table 11-8 shows the long Windows file names from Figure 11-35 and their NTFS-generated MS-DOS 
versions. The current algorithm and the examples in Figure 11-35 should give you an idea of what NTFS-
generated MS-DOS-style file names look like.
Note Since Windows 8.1, by default all the NTFS nonbootable volumes have short 
name generation disabled. You can disable short name generation even in older ver-
sion of Windows by setting HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\
NtfsDisable8dot3NameCreation in the registry to a DWORD value of 1 and restarting the 
machine. This could potentially break compatibility with older applications, though.
TABLE 11-8 NTFS-generated file names
Windows Long Name
NTFS-Generated Short Name
LongFileName
LONGFI1
UnicodeName.FDPL
UNICOD1
File.Name.With.Dots
FILENA1.DOT
File.Name2.With.Dots
FILENA2.DOT
File.Name3.With.Dots
FILENA3.DOT
File.Name4.With.Dots
FILENA4.DOT
File.Name5.With.Dots
FIF5961.DOT
Name With Embedded Spaces
NAMEWI1
.BeginningDot
BEGINN1
25.two characters
2554401.TWO
©
6E2D1
Tunneling
NTFS uses the concept of tunneling to allow compatibility with older programs that depend on the file 
system to cache certain file metadata for a period of time even after the file is gone, such as when it 
has been deleted or renamed. With tunneling, any new file created with the same name as the original 
file, and within a certain period of time, will keep some of the same metadata. The idea is to replicate 
behavior expected by MS-DOS programs when using the safe save programming method, in which 
modified data is copied to a temporary file, the original file is deleted, and then the temporary file is 
renamed to the original name. The expected behavior in this case is that the renamed temporary file 
should appear to be the same as the original file; otherwise, the creation time would continuously 
update itself with each modification (which is how the modified time is used).
NTFS uses tunneling so that when a file name is removed from a directory, its long name and short 
name, as well as its creation time, are saved into a cache. When a new file is added to a directory, the 
cache is searched to see whether there is any tunneled data to restore. Because these operations apply 
to directories, each directory instance has its own cache, which is deleted if the directory is removed. 
CHAPTER 11
Caching and file systems
667
NTFS will use tunneling for the following series of operations if the names used result in the deletion 
and re-creation of the same file name:
I 
Delete + Create
I 
Delete + Rename
I 
Rename + Create
I 
Rename + Rename
By default, NTFS keeps the tunneling cache for 15 seconds, although you can modify this time-
out by creating a new value called MaximumTunnelEntryAgeInSeconds in the HKLM\SYSTEM\
CurrentControlSet\Control\FileSystem registry key. Tunneling can also be completely disabled by 
creating a new value called MaximumTunnelEntries and setting it to 0; however, this will cause older 
applications to break if they rely on the compatibility behavior. On NTFS volumes that have short name 
generation disabled (see the previous section), tunneling is disabled by default.
You can see tunneling in action with the following simple experiment in the command prompt:
1.
Create a file called file1.
2.
Wait for more than 15 seconds (the default tunnel cache timeout).
3.
Create a file called file2.
4.
Perform a dir /TC. Note the creation times.
5.
Rename file1 to file.
6.
Rename file2 to file1.
7.
Perform a dir /TC. Note that the creation times are identical.
Resident and nonresident attributes
If a file is small, all its attributes and their values (its data, for example) fit within the file record that 
describes the file. When the value of an attribute is stored in the MFT (either in the file’s main file record 
or an extension record located elsewhere within the MFT), the attribute is called a resident attribute. 
(In Figure 11-37, for example, all attributes are resident.) Several attributes are defined as always being 
resident so that NTFS can locate nonresident attributes. The standard information and index root at-
tributes are always resident, for example.
Each attribute begins with a standard header containing information about the attribute—informa-
tion that NTFS uses to manage the attributes in a generic way. The header, which is always resident, 
records whether the attribute’s value is resident or nonresident. For resident attributes, the header also 
contains the offset from the header to the attribute’s value and the length of the attribute’s value, as 
Figure 11-37 illustrates for the file name attribute.
When an attribute’s value is stored directly in the MFT, the time it takes NTFS to access the value 
is greatly reduced. Instead of looking up a file in a table and then reading a succession of allocation 
668
CHAPTER 11
Caching and file systems
units to find the file’s data (as the FAT file system does, for example), NTFS accesses the disk once and 
retrieves the data immediately.
Standard
information
File name
Data
“RESIDENT”
Offset: 8h
Length: 18h
Attribute header
Attribute value
MYFILE.DAT
FIGURE 11-37 Resident attribute header and value.
The attributes for a small directory, as well as for a small file, can be resident in the MFT, as Figure 11-38 
shows. For a small directory, the index root attribute contains an index (organized as a B-tree) of file 
record numbers for the files (and the subdirectories) within the directory.
Standard
information
File name
Index root
Index of files
file1, file2, file3, ...
Empty
FIGURE 11-38 MFT file record for a small directory.
Of course, many files and directories can’t be squeezed into a 1 KB or 4 KB, fixed-size MFT record. If a 
particular attribute’s value, such as a file’s data attribute, is too large to be contained in an MFT file record, 
NTFS allocates clusters for the attribute’s value outside the MFT. A contiguous group of clusters is called 
a run (or an extent). If the attribute’s value later grows (if a user appends data to the file, for example), 
NTFS allocates another run for the additional data. Attributes whose values are stored in runs (rather than 
within the MFT) are called nonresident attributes. The file system decides whether a particular attribute is 
resident or nonresident; the location of the data is transparent to the process accessing it.
When an attribute is nonresident, as the data attribute for a large file will certainly be, its header 
contains the information NTFS needs to locate the attribute’s value on the disk. Figure 11-39 shows a 
nonresident data attribute stored in two runs.
NTFS
extended
attributes
Standard
information File name
Data
Data
Data
FIGURE 11-39 MFT file record for a large file with two data runs.
CHAPTER 11
Caching and file systems
669
Among the standard attributes, only those that can grow can be nonresident. For files, the attributes 
that can grow are the data and the attribute list (not shown in Figure 11-39). The standard information 
and file name attributes are always resident.
A large directory can also have nonresident attributes (or parts of attributes), as Figure 11-40 shows. 
In this example, the MFT file record doesn’t have enough room to store the B-tree that contains the 
index of files that are within this large directory. A part of the index is stored in the index root attribute, 
and the rest of the index is stored in nonresident runs called index allocations. The index root, index 
allocation, and bitmap attributes are shown here in a simplified form. They are described in more detail 
in the next section. The standard information and file name attributes are always resident. The header 
and at least part of the value of the index root attribute are also resident for directories.
Index
allocation
Bitmap
Standard
information File name
Index root
Index buffers
file1  file2  file3
file5  file6
Index of files
file4
file8
FIGURE 11-40 MFT file record for a large directory with a nonresident file name index.
When an attribute’s value can’t fit in an MFT file record and separate allocations are needed, NTFS 
keeps track of the runs by means of VCN-to-LCN mapping pairs. LCNs represent the sequence of 
clusters on an entire volume from 0 through n. VCNs number the clusters belonging to a particular file 
from 0 through m. For example, the clusters in the runs of a nonresident data attribute are numbered 
as shown in Figure 11-41.
Standard
information
0
1
2
3
1355
1356
1357
1358
File name
Data
Data
Data
File 16
4
5
6