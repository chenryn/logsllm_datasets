（breakpoint）功能，因此INT 3指令又称为断点指令。
4.1.1 INT 3
下面通过一个小实验来感受一下INT 3指令的工作原理。在Visual
C++ Studio 6.0（以下简称为VC 6）中创建一个简单的HelloWorld控制台
程序HiInt3，然后在main()函数的开头通过嵌入式汇编插入一条INT 3指
令：
int main(INT argc, char* argv[])
{
   // manual breakpoint 
   _asm INT 3;
   printf("Hello INT 3!\n");
   return 0;
}
在VC环境中执行以上程序时，会得到图4-1所示的对话框。单击OK
按钮后，程序便会停在INT 3指令所在的位置。由此看来，我们刚刚插
入的一行指令（_asm INT 3）相当于在那里设置了一个断点。实际上，
这也正是通过注入代码手工设置断点的方法，这种方法在调试某些特殊
的程序时非常有用。
图4-1 CPU遇到INT 3指令时会把执行权移交给调试设施
此时打开反汇编窗口，可以看到内存地址00401028处确实是INT 3
指令：
10:       _asm INT 3;
00401028   int         3
打开寄存器窗口，可以看到程序指针寄存器的值也是00401028：
EAX = CCCCCCCC EBX = 7FFDE000 ECX = 00000000 EDX = 00371588
ESI = 00000000 EDI = 0012FF80
EIP = 00401028 ESP = 0012FF34 EBP = 0012FF80 ……
根据我们在第3章中的介绍，断点异常（INT 3）属于陷阱类异常，
当CPU产生异常时，其程序指针是指向导致异常的下一条指令的。但
是，现在我们观察到的结果却是指向导致异常的这条指令的。这是为什
么呢？简单地说，是操作系统为了支持调试对程序指针做了调整。我们
将在后面揭晓答案。
4.1.2 在调试器中设置断点
下面考虑一下调试器是如何设置断点的。当我们在调试器（例如
VC6或Turbo Debugger等）中对代码的某一行设置断点时，调试器会先
把这里本来指令的第一个字节保存起来，然后写入一条INT 3指令。因
为INT 3指令的机器码为11001100b（0xCC），仅有一个字节，所以设
置和取消断点时也只需要保存和恢复一个字节，这是设计这条指令时须
考虑好的。
顺便说一下，虽然VC6是把断点的设置信息（断点所在的文件和行
位置）保存在和项目文件相同位置且相同主名称的一个.opt文件中，但
是请注意，该文件并不保存每个断点处应该被INT 3指令替换掉的那个
字节，因为这种替换是在启动调试时和调试过程中动态进行的。这可以
解释，有时在VC6中，在非调试状态下，我们甚至可以在注释行设置断
点，当开始调试时，会得到一个图4-2所示的警告对话框。这是因为当
用户在非调试状态下设置断点时，VC6只是简单地记录下该断点的位置
信息。当开始调试（让被调试程序开始运行）时，VC6会一个一个地取
出OPT文件中的断点记录，并真正将这些断点设置到目标代码的内存映
像中，即要将断点位置对应的指令的第一个字节先保存起来，再替换为
0xCC（即INT 3指令），这个过程称为落实断点（resolve breakpoint）。
在落实断点的过程中，如果VC6发现某个断点的位置根本对应不到
目标映像的代码段，那么便会发出图4-2所示的警告。
图4-2 VC6在开始调试时才真正设置断点，会对无法落实的断点发出警告
4.1.3 断点命中
当CPU执行到INT 3指令时，由于INT 3指令的设计目的就是中断到
调试器，因此CPU执行这条指令的过程也就是产生断点异常
（breakpoint exception，即#BP）并转去执行异常处理例程的过程。在跳
转到处理例程之前，CPU会保存当前的执行上下文（包括段寄存器、程
序指针寄存器等内容）。清单4-1列出了CPU工作在实模式时执行INT 3
的过程（摘自《英特尔IA-32架构软件开发手册（卷2A）》）。
清单4-1 实模式下INT 3指令的执行过程
1    REAL-ADDRESS-MODE:
2    IF ((vector_number ∗ 4) + 3) is not within IDT limit
3    THEN #GP;
4    FI;
5    IF stack not large enough for a 6-byte return information
6    THEN #SS;
7    FI;
8    Push (EFLAGS[15:0]);
9    IF ← 0; (* Clear interrupt flag *)
10   TF ← 0; (* Clear trap flag *)
11   AC ← 0; (* Clear AC flag *)
12   Push(CS);
13   Push(IP);
14   (* No error codes are pushed *)
15   CS ← IDT(Descriptor (vector_number ∗ 4), selector));
16   EIP ← IDT(Descriptor (vector_number ∗ 4), offset)); (* 16 bit offset
 AND 
17   0000FFFFH *)
18   END
其中第2行是检查根据中断向量号计算出的向量地址是否超出了中
断向量表的边界（limit）。实模式下，中断向量表的每个表项是4个字
节，分别处理例程的段和偏移地址（各两字节）。如果超出了，那么便
产生保护性错误异常。#GP即General Protection Exception，通用保护性
异常。第7行的FI是IF语句的结束语句。
第5行是检查栈上是否有足够的空间来保存寄存器，当堆栈不足以
容纳接下来要压入的6字节的（CS、IP和EFLAGS的低16位）内容时，
便产生堆栈异常#SS。第9行到第11行是清除标志寄存器的IF、TF和AC
位。第12行和第13行是将当前的段寄存器和程序指针寄存器的内容保存
在当前程序的栈中。
第15行和第16行是将注册在中断向量表（IDT）中的异常处理例程
的入口地址加载到CS和IP（程序指针）寄存器中。这样，CPU执行好这
条指令后，接下来便会执行异常处理例程的函数了。
对于DOS这样的在实模式下的单任务操作系统，断点异常的处理例
程通常就是调试器程序注册的函数，因此，CPU便开始执行调试器的代
码了。当调试器执行好调试功能需要恢复被调试程序执行时，它只要执
行中断返回指令（IRET），便可以让CPU从断点的位置继续执行了（见
下文）。
在保护模式下，INT 3指令的执行过程虽然有所不同，比如是在由
IDTR寄存器标识的IDT中寻找异常处理函数，找到后会检查函数的有效
性，但其原理是一样的，也是保存好寄存器后，便跳转去执行异常处理
例程。
对于Windows这样工作在保护模式下的多任务操作系统，INT 3异
常的处理函数是操作系统的内核函数（KiTrap03）。因此执行INT 3会
导致CPU执行nt!KiTrap03例程。因为我们现在讨论的是应用程序调试，
断点指令位于用户模式下的应用程序代码中，因此CPU会从用户模式转
入内核模式。接下来，经过几个内核函数的分发和处理（见第11章），
因为这个异常是来自用户模式的，而且该异常的拥有进程正在被调试
（进程的DebugPort非0），所以内核例程会把这个异常通过调试子系统
以调试事件的形式分发给用户模式的调试器，对于我们的例子也就是
VC6。在通知VC6后，内核的调试子系统函数会等待调试器的回复。收
到调试器的回复后，调试子系统的函数会层层返回，最后返回到异常处
理例程，异常处理例程执行中断返回指令，使被调试的程序继续执行。
在调试器（VC6）收到调试事件后，它会根据调试事件数据结构中
的程序指针得到断点异常的发生位置，然后在自己内部的断点列表中寻
找与其匹配的断点记录。如果能找到，则说明这是“自己”设置的断点，
执行一系列准备动作后，便允许用户进行交互式调试。如果找不到，就
说明导致这个异常的INT 3指令不是VC6动态替换进去的，因此会显示
一个图4-1所示的对话框，意思是说一个“用户”插入的断点被触发了。
值得说明的是，在调试器下，我们是看不到动态替换到程序中的
INT 3指令的。大多数调试器的做法是在被调试程序中断到调试器时，
会先将所有断点位置被替换为INT 3的指令恢复成原来的指令，然后再
把控制权交给用户。对于不做这种断点恢复的调试器（如VC6），它的
反汇编功能和内存观察功能也都有专门的处理，让用户看到的始终是断
点所在位置本来的内容。本节后面我们会给出两种观察方法。
在Windows系统中，操作系统的断点异常处理函数（KiTrap03）对
于x86 CPU的断点异常会有一个特殊的处理，会将程序指针寄存器的值
减1。
nt!KiTrap03+0x9a:
8053dd0e 8b5d68    mov    ebx,dword ptr [ebp+68h]
8053dd11 4b    dec    ebx
8053dd12 b903000000    mov    ecx,3
8053dd17 b803000080    mov    eax,80000003h
8053dd1c e8a3f8ffff    call    nt!CommonDispatchException (8053d5c4)
出于这个原因，我们在调试器看到的程序指针指向的仍然是INT 3
指令的位置，而不是它的下一条指令。这样做的目的有如下两个。
调试器在落实断点时，不管所在位置的指令是几个字节，它都只替
换一个字节。因此，如果程序指针指向下一个指令位置，那么指向
的可能是原来的多字节指令的第二个字节，不是一条完整的指令。
因为有断点在，所以被调试程序在断点位置的那条指令还没有执
行。按照“程序指针总是指向即将执行的那条指令”的原则，应该把
程序指针指向这条要执行的指令，也就是倒退回一个字节，指向原
来指令的起始地址。
这也就是前面问题的答案。
综上所述，当CPU执行INT 3指令时，它会跳转到异常处理例程，
让当前的程序接受调试，调试结束后，异常处理例程使用中断返回机制
让CPU再继续执行原来的程序。下面我们将详细介绍恢复执行的过程。
4.1.4 恢复执行
当用户结束分析希望恢复被调试程序执行时，调试器通过调试API
通知调试子系统，这会使系统内核的异常分发函数返回到异常处理例
程，然后异常处理例程通过IRET/IRETD指令触发一个异常返回动作，
使CPU恢复执行上下文，从发生异常的位置继续执行。注意，这时的程
序指针指向断点所在的那条指令，此时刚才的断点指令已经被替换成本
来的指令，于是程序会从断点位置的原来指令继续执行。
这里有一个问题，前面我们说当断点命中中断到调试器时，调试器
会把所有断点处的INT 3指令恢复成本来的内容。因此，在用户发出恢
复执行命令后，调试器在通知系统真正恢复程序执行前，需要将断点列
表中的所有断点再落实一遍。但是对于刚才命中的这个断点需要特别对
待，试想如果把这个断点处的指令也替换为INT 3，那么程序一执行便
又触发断点了。但是如果不替换，那么这个断点便没有被落实，程序下
次执行到这里时就不会触发断点，而用户并不知道这一点。对于这个问
题，大多数调试器的做法都是先单步执行一次。具体地说，就是先设置
单步执行标志（见 4.2 节），然后恢复执行，将断点所在位置的指令执
行完。因为设置了单步标志，所以CPU执行完断点位置的这条指令后会
立刻再中断到调试器中，这一次调试器不会通知用户，会做一些内部操
作后便立刻恢复程序执行，而且将所有断点都落实（使用INT 3替
换），这个过程一般被称为“单步走出断点”。如果用户在恢复程序执行
前已经取消了当前的断点，那么就不需要先单步执行一次了。
4.1.5 特殊用途
因为INT 3指令的特殊性，所以它有一些特别的用途。让我们从一
个有趣的现象说起。当用VC6进行调试时，我们常常会观察到一块刚分
配的内存或字符串数组里面被填满了“CC”。如果是在中文环境下，因
为0xCCCC恰好是汉字“烫”字的简码，所以会观察到很多“烫烫
烫……”（见图4-3），而0xCC又正好是INT 3指令的机器码，这是偶然
的么？当然不是。因为这是编译器故意这样做的。为了辅助调试，编译
器在编译调试版本时会用0xCC来填充刚刚分配的缓冲区。这样，如果
因为缓冲区或堆栈溢出时程序指针意外指向了这些区域，那么便会因为
遇到INT 3指令而马上中断到调试器。
图4-3 填充了INT 3指令的缓冲区
事实上，除了以上用法，编译器还用INT 3指令来填充函数或代码
段末尾的空闲区域，即用它来做内存对齐。这也可以解释为什么有时我
们没有手工插入任何对INT 3的调用，但还会遇到图4-1所示的对话框。
4.1.6 断点API
Windows操作系统提供了供应用程序向自己的代码中插入断点的
API。在用户模式下，可以使用DebugBreak() API，在内核模式下可以使
用DbgBreakPoint()或者DbgBreakPointWithStatus()API。
把前面HiInt3程序中对INT 3的直接调用改为调用Windows API
DebugBreak()（需要在开头加入include ），然后执行，可
以看到产生的效果是一样的。通过反汇编很容易看出这些API在x86平台
上其实都只是对INT 3指令的简单包装：
1    lkd> u nt!DbgBreakPoint
2    nt!DbgBreakPoint:
3    804df8c4 cc               int     3
4    804df8c5 c3               ret
以上反汇编是用WinDBG的本地内核调试环境而做的。提示符lkd>
的含义是“local kernel debug”，即本地内核调试——需要Windows XP或
以上的操作系统才能支持。
DbgBreakPointWithStatus()允许向调试器传递一个整型参数：
lkd> u nt!DbgBreakPointWithStatus