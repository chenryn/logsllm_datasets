ing data for the experiments in Section 8. Sumeet Bedi
led this eﬁort with assistance from Watee Arjsamat,
Sonal Ghandi, Kevin Lux, and Aloka Singh. We also
received useful comments from Karthikeyan Bharga-
van, Ran Canetti, Michael Greenwald, Klara Nahrst-
edt, Adrian Perrig, and Jonathan Smith. We thank
Luigi Rizzo for assistance and the use of his FEC pack-
age. Research of Gunter and Tan was supported in part
by NSF EIA00-88028 and ONR N00014-02-1-0715. Re-
search of Khanna was supported in part by an Alfred
P. Sloan Research Fellowship and by an NSF Career
Award CCR-0093117
[14] A. Pannetrat and R. Molva. E–cient multicast
packet authentication. In Proceedings of the NDSS
Symposium, 2003.
[15] J. M. Park, E. K. P. Chong, and H. J. Siegel. E–-
cient multicast stream authentication using era-
sure codes. ACM Transactions on Information
and System Security, 6(2):258{285, 2003.
[16] Adrian Perrig. The biba one-time signature and
broadcast authentication protocol. In ACM Con-
ference on Computer and Communications Secu-
rity, pages 28{37, 2001.
[17] Adrian Perrig, Ran Canetti, Dawn Xiaodong
Song, and J. D. Tygar. E–cient and secure source
authentication for multicast. In Proceedings of the
NDSS Symposium, 2001.
[18] Adrian Perrig, Ran Canetti, J. D. Tygar, and
Dawn Xiaodong Song. E–cient authentication
and signing of multicast streams over lossy chan-
In IEEE Symposium on Security and Pri-
nels.
vacy, pages 56{73, 2000.
[19] Adrian Perrig and J. D. Tygar. Secure Broadcast
Communication in Wired and Wireless Networks.
Kluwer, 2003.
[20] Luigi Rizzo. Eﬁective erasure codes for reliable
computer communication protocols. ACM Com-
puter Communication Review, 27(2):24{36, 1997.
[21] Pankaj Rohatgi. A compact and fast hybrid sig-
nature scheme for multicast packet authentication.
In ACM Conference on Computer and Communi-
cations Security, pages 93{100, 1999.
[22] S. M. Ross. Stochastic Processes. Wiley, second
edition, 1996.
[23] H. Schulzrinne, S. Casner, R. Frederick, and V. Ja-
cobson. RTP: a transport protocol for real-time
applications. RFC 1889, IETF, January 1996.
[24] Wong and Lam. Digital signatures for (cid:176)ows and
multicasts. IEEE/ACM Transactions on Network-
ing, 7, 1999.
References
[1] Ran Canetti, Juan Garay, Gene Itkis, Daniele Mic-
ciancio, Moni Naor, and Benny Pinkas. Multicast
security: A taxonomy and some e–cient construc-
tions. In INFOCOMM’99, 1999.
[2] H. Chernoﬁ. A measure of the asymptotic e–-
ciency of tests of a hypothesis based on a sum of
observations. Ann. Math. Stat., 23:493{507, 1952.
[3] Danny Dolev and Andrew C. Yao. On the secu-
IEEE Transactions
rity of public-key protocols.
on Information Theory, 2(29):198{208, 1983.
[4] David C. Feldmeier, Anthony J. McAuley,
Jonathan M. Smith, Deborah S. Bakin, William S.
Marcus, and Thomas M. Raleigh. Protocol boost-
ers. IEEE Journal on Selected Areas in Commu-
nications, 16(3):437{443, 1998.
[5] Rosario Gennaro and Pankaj Rohatgi. How to sign
digital streams. In Proceedings of Crypto’97, pages
180{197, 1997.
[6] Philippe Golle and Nagendra Modadugu. Authen-
ticating streamed data in the presence of random
packet loss. In Proceedings of the NDSS Sympo-
sium, 2001.
[7] W. Hoeﬁding. Probability inequalities for sums of
bounded random variables. J. Amer. Stat. Assoc.,
58:13{30, 1963.
[8] H. Krawczyk, M. Bellare, and R. Canetti. Hmac:
Keyed-hashing for message authentication. RFC
2104, IETF, February 1997.
[9] M. Luby, L. Vicisano, J. Gemmell, L. Rizzo,
M. Handley, and J. Crowcroft. Forward error cor-
rection (fec) building block. RFC 3452, IETF, De-
cember 2002.
[10] F. J. MacWilliams and N. J. A. Sloane. The The-
ory of Error-Correcting Codes. North-Holland,
1977.
[11] R. J. McEliece. The Theory of Information and
Coding. Addison-Wesley, 1977.
[12] Ralph Merkle. A certiﬂed digital signature.
Proceedings of Crypto’89, pages 218{238, 1990.
In
[13] Sara Miner and Jessica Staddon. Graph-based
authentication of digital streams. In IEEE Sym-
posium on Security and Privacy, pages 277{288,
2001.
A Forward Error Correction
Several unicast protocols utilize a combination of a low
complexity error-detection code (typically a cyclic re-
dundancy check (CRC) code) coupled with feedback
in the form of automatic repeat requests (ARQs) to
recover from errors and losses in transmission. Such
ARQ-based protocols, while well understood, unfortu-
nately do not scale well in multicast settings. In such
cases, coding introduced in the transmission to cope
with errors and losses in the authentication stream
must be su–ciently powerful to allow each recipient
to unambiguously reconstruct the entire authentica-
tion stream corresponding to a group of data with very
high conﬂdence (so that each recipient loses only a very
small fraction of transmissions to non-authentication).
As feedback is eschewed, the entire process of coding,
transmission, and decoding is accomplished in a single
forward pass.
In general, error-control coding adds redundancy to
the stream. Repetition codes, for instance, constitute
a na˜‡ve application of this idea whereby each packet
to be protected is simply retransmitted a ﬂxed num-
ber of times. From the perspective of erasure recovery,
however, repetition codes have simplicity commending
them but little else. As we see in the next section, it
is easy to get a ﬂve- to ten-fold improvement in cod-
ing overhead over repetition codes with a modicum of
eﬁort.
For our present purposes we focus on a very pow-
erful and practical family of codes called the Reed-
Solomon (RS) codes over the ﬂnite ﬂeld GF (2m) (c.f.,
MacWilliams and Sloane [10] or McEliece [11], for in-
stance) for some positive integer m. An RS(n; k) code
will consist of n = 2m ¡ 1 symbols in GF (2m) out of
which the ﬂrst k are source symbols and the remaining
are parity check symbols that add redundancy.
Several features of the Reed-Solomon codes make
them particularly appealing for our application. The
codes can be implemented very e–ciently using public
domain software. No special tweaking or proprietary
material is needed. The codes are very well suited
to situations where errors in bit transmissions occur
in bursts. And the Reed-Solomon codes can be e–-
ciently combined or concatenated with other codes to
form even more powerful codes.
Most importantly, an RS(n; k) code can recover from
any combination of up to n ¡ k erasures. Suppose it
is desired to provide erasure protection for up to ‘ era-
sures out of k source symbols. Then any Reed-Solomon
code with length n ‚ k + ‘ and dimension k will pro-
vide the requisite level of erasure protection and more.
Indeed, if ‘ ¿ n ¡ k, the code protects against much
more than the requisite ‘ erasures. In this case one can
elect to keep just, say, the ﬂrst ‘ parity check symbols
in each codeword together with the k source symbols
and cheerfully drop the remaining n¡k¡‘ parity check
symbols. The resulting code is called a punctured Reed-
Solomon code; in the punctured code, each codeword
consists of only k + ‘ symbols. We can still aﬁord to
lose up to ‘ more symbols before the code falters. The
beneﬂt of puncturing the code thus is that we have now
boosted the rate of the code to k=(k + ‘) which may
eﬁect a substantial reduction in coding overhead over
the original k=n rate. Thus, erasure protection may be
continuously traded-oﬁ against rate by puncturing the
code.
Other codes with roughly similar characteristics such
as Rabin’s Information Dispersal Algorithm may also
be used. While coding overheads in our application
are typically low and coding and decoding costs are
not signiﬂcant, in situations where decoding cost is im-
portant one may trade-oﬁ space for time using codes
such as Tornado codes. For these and related ideas see
Luby, et al [9], Park, et al [15], and Rizzo [20].
B Formal Analysis of BAS
In this section we describe the theoretical foundations
of the protocol and provide analyses of diﬁerent loss
and DoS attack models.
B.1 Loss Recovery Analysis
The simplest loss model occurs when packets are as-
sumed to be dropped independently with some ﬂxed
probability p. Suppose the hash/parity stream of a
0 packets comprised of
transmission group consists of n
0 ¡ k parity packets. As be-
k hash packets and ‘ = n
fore, we suppose that the ‘ parity packets are obtained
by puncturing an (n; k) systematic Reed-Solomon code
and selecting ‘ • n ¡ k parity packets. Consider the
0 = k + ‘ hash/parity packets over
transmission of the n
a packet erasure channel with packet loss probability p.
Assume for the nonce that there are no packet inser-
tions, i.e., no DoS attack on the hash/parity stream.
Let the integer-valued random variable S denote the
number of dropped packets in the hash/parity stream
of the transmission group. We can interpret the prob-
ability that S does not exceed ‘ as our conﬂdence in
the recoverability of all hash packets corresponding to a
given transmission group. Alternatively, the conﬂdence
represents the long-run fraction of transmission groups
that are authenticatable, DoS attacks in abeyance, in
the sense that the hash packets of these groups are re-
covered. We typically require a conﬂdence of at least
k = 11
(‘H)
(8)
(12)
(22)
0
‘
22
44
77
‘
5
11
22
k = 57
(‘H)
(17)
(33)
(67)
0
‘
114
285
513
‘
10
30
66
p
0:05
0:20
0:40
More sophisticated Markovian loss models can be
constructed to capture time correlations in packet
losses. Similar results can be derived for these models
though we will not describe them here in the interests
of brevity.
Table 3: Coding overhead for Reed-Solomon and repe-
tition codes.
99 percent that all hash packets in a group are recov-
ered so that fewer than one in a hundred groups are
compromised.
As packet drops are independent, S conforms to a
binomial distribution and a selection of exponential tail
bounds may be deployed to provide crisp estimates for
the tail probability,
¡
n
¡(k + ‘)D
PrfS > ‘g < exp
¡
‰¡2
< exp
(1 ¡ p)‘ ¡ kp
k + ‘
‘
k+‘
(Chernoﬁ bound)
¢o
(cid:176)(cid:176) p
¢2
(cid:190)
;
(Hoeﬁding bound)
where, with logarithms to base e,
¡
¢
(cid:176)(cid:176) p
¢
D
‘
k+‘
= ‘
k+‘ log
‘
p(k+‘) + k
k+‘ log
k
(1¡p)(k+‘)
‘
k+‘ ; k
k+‘
denotes the Kullback-Leibler divergence between the
and (p; 1¡ p). The
probability distributions
ﬂrst bound is that of Chernoﬁ [2], the second, slightly
more analytically amenable, is due to Hoeﬁding [7].
Given a value of k and a desired conﬂdence 1¡– (where
– = 0:01, say) one typically wishes to determine a value
of ‘ for which the desired conﬂdence is attained. In-
verting Hoeﬁding’s bound, for instance, we obtain that
if the number of parity packets per transmission group
satisﬂes
¡
•
‘ ‚ kp
1 ¡ p
¡ log –
4(1 ¡ p)2
1 +
s
1 ¡ 8k(1 ¡ p)
log –
‚
(1)
then all k hash packets in a given transmission group
can be recovered with conﬂdence at least 1 ¡ –. As a
practical matter, the values of ‘ provided by Hoeﬁd-
ing’s bound are only slightly larger than those provided
by Chernoﬁ’s bound; see Table 3 where, for a given
value of k, ‘ denotes the Chernoﬁ estimate of the par-
ity overhead, ‘H denotes the Hoeﬁding estimate, and
0 is the parity overhead that
for comparative purposes, ‘
results if a na˜‡ve repetition code were to be used in lieu
of a Reed-Solomon code.
B.2 Denial of Service Attacks
A DoS attack may focus on the data stream,
hash/parity stream, or signature stream. Or an at-
tacker may elect to spread his resources in an attack
on some combination of these streams.
In a shared
channel model the attack is in the form of a (cid:176)ood of
spurious packets having the apparent characteristic of
the packets in the stream under attack, for instance,
by bearing sequence numbers of legitimately expected
packets.
We may consider attacks on each of the three streams
in isolation; a combination attack eﬁectively reduces
the attack factor of the adversary in each stream as
his resources have to be spread across the streams. A
successful attack on a data packet will result in the ef-
fective loss of that packet as it cannot be veriﬂed; a suc-
cessful attack on a hash packet will result in the invali-
dation of the group of data packets whose hashes have
been compromised; a successful attack on a signature
packet will compromise the entire transmission group.
Of such attacks, a signature (cid:176)ood attack is potentially
the most damaging as an adversary can invalidate an
entire transmission group in one fell swoop if the at-
tack is successful. We hence begin with an analysis of
signature (cid:176)ooding attacks and how the BAS protocol
copes with such attacks.
As a design parameter we require that the proto-
col provide a guaranteed conﬂdence of 1 ¡ – that any
given transmission group is veriﬂable. Here – 2 (0; 1)
is our conﬂdence parameter. We may think of – as
some suitably small number (we selected – = 0:01 in
our simulations) but for purposes of analysis we leave
this as an application-speciﬂed parameter. Two ad-
ditional design parameters are the authentication and
loss recovery overhead o which is the fraction of pack-
ets in a transmission group devoted to authentication
and error or loss recovery and the sender-side authen-
tication latency ¿ which is the delay between the be-
ginning of transmission of data in a transmission group
and the completion of transmission of packets needed
to authenticate the group. Of course, the overhead and
latency are related. In our analysis we assume that the
maximum overhead o is speciﬂed as a design parame-
ter; the latency ¿ is then determined as a function of o
and –. As will become clear, we could equally well have
speciﬂed a maximum latency that the application can
withstand and determine the overhead that is incurred
in consequence. The latter may be more appropriate