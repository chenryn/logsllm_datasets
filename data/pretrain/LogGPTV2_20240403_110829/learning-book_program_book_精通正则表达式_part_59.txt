regionStart
388
useAnchoringBounds
390
hitEnd
378
replaceAl1
393
usePattern
376
lookingAt
382
replaceAllRegion
387
useTransparentBounds
这张表格供简要查询，详细的API讲解从第371页开始。
在这里我还是要强调，尽管第367页的表格查阅起来很方便，第3章第114和第123页的
表格也是如此，但本书的目的不是作为参考手册，而是“掌握”正则表达式的详细教程。
前面几章已经出现过java.uti1.regex的例子（r81、95、98、217、235），本章在讲解
各种类及其实际应用时会给出更多的例子。不过，首先还是来看Java支持的正则流派，以
及对应的修饰符。
Java的正则流派
Java‘s Regex Flavor
java.uti1.regex使用传统型NFA，所以第4、5、6章介绍的丰富特性都适用于它。下页
的表8-2总结了它的元字符。此流派的某些方面已经发生了变化，原因是各种匹配模式，匹
配模式的启用通过各种method和factory来设定标志位，或者内嵌在表达式中的
(?mods-mods）和（?mods-mods：.）：修饰符。这些模式在第368页的表8-3中有列出。
下面是对表8-2的说明：
①只有在字符组内部，\b才代表退格字符。在其他场合，\b都代表单词分界符。
表中给出的是“纯（raw）”反斜线，但是用作Java正则表达式的字符串时必须使用双
反斜线。例如，表中的ni在Java的字符串中必须写作“\\n”。请参考“作为正则表
达式的字符串”（101）。
x##容许且只容许出现两位十六进制数字，所以xFcber匹配‘uber”。
---
## Page 393
Java的正则流派
367
表8-2：java.util.regex的正则流派
字符缩略表示法
115(c)
\a[\b]\e\f\n\r\t\0octal\x#\u####\cchar
字符组及相关结构
118 (c)
字符组：[][A]（可包含集合运算符125）
119
几乎任何字符：点号（根据模式的不同，有各种含义）
120(c)
字符组缩略表示法：\w\d\s\W\D\S
121(c)
Unicode属性和区块：\p（Prop）\P(Prop)
锚点及其他零长度断言
370
行/字符串起始位置：\A
370
行/字符串结束位置：$\z\Z
370
当前匹配的起始位置：\G
133
单词分界符：\b\B
133
环视结构：（？=.）（？！….）（？）
139
多选结构：1
141
匹配优先量词：*+？（n）（n，）（x，y）
141
忽略优先量词：*？+？？？（n）？（n，）？（x，y）？
142
占有优先量词：*+++?+（n）+（n，）+（x，y）+
（c）一可用于字符组内部
①.见说明
\u####容许且只容许四位十六进制数字，例如，\u00FCberi匹配“uber”，\u20AC
匹配‘”。
\0octal要求开头为0，后接1到3位十进制数字。
Acchar是区分大小写的，直接对后面字符的十进制编码进行异或（xoring）操作。与我
见过的任何流派都不一样，在这里\cA和\ca是不同的。\cA等于传统意义上的\x01，
\ca则等价于\x21，匹配‘！”。
②\w、\a和\s（以及对应的大写缩略法）只适用于ASCII字符，而不包括其他的字母、
数字或者Unicode空白字符。也就是说，\d等价于[0-9]，\w等价于[0-9a-zA-Z]，
s等价于[\t\n\f\r\xOB]（\x0B是ASCII中基本不用的VT字符）。
---
## Page 394
368
AB真8L
要覆盖完整的Unicode字符，可以使用Unicode属性（121）：用\p（L）表示\w，\p（Nd）
表示\d，用\p(Z）表示\s。（把小写的p替换为大写的P，就可以对应\W、\D和\S)。
③\p{…)和\P(…)支持Unicode属性和区块，以及某些额外的“Java属性”。它不支持
Unicode字母表。详细信息在下一页。
④对单词分界符元字符\b和\B来说，“单词字符”的规定不同于\w和\W。单词分界符能
够识别Unicode字符，而\w和\W只能识别ASCII字符。
③顺序环视结构中可以使用任意正则表达式，但是逆序环视中的子表达式只能匹配长度有
限的文本。也就是说，？可以出现在逆序环视中，但“*和+则不行。请参考第3章133
页开始的内容。
只有在使用/x修饰符，或者使用Pattern.COMMENTS选项（368）（请不要忘记在多
行文本字符串中添加换行符，如第401页的例子）时，#才算注释。没有转义的ASCII
字空白字符会被忽略。注意：这一点与大多数支持此模式的正则引擎不同，在Java中
字符组内部的注释和空白字符也会被忽略。
\Q\E一直是被支持的，但在Java1.6之前，字符组内部的此种结构是不可靠的。
表8-3：java.util.regex中Match和Regex的方法
编译选项
(ao)
描述
Patern.UNIX_LINES
d
更改点号和的匹配（370）
Pattern.DOTALL
S
点号能匹配任何字符（111）
Pattern.MULTILINE
m
扩展和S的匹配规定（370）
Pattern.COMMENTS
X
宽松排列和注释模式（在宇符组内部也有效）
(72)
Pattern.CASE_INSENSITIVE
i
对ASCII字符进行不区分大小写的匹配
Pattern.UNICODE_CASE
u
对Unicode字符进行不区分大小写的匹配
Unicode“按规则等价（canonicalequivalence）”
Pattern. CANNON_EQ
匹配模式（不同编码中的同样字符视为相等
108)
Pattern.LITERAL
将regex参数作为文字文本，而非正则表达式
---
## Page 395
Java的正则流派
369
Java对\p{..}和\P{.}的支持
ava Support forp/.andP
\p(）和P(·)）结构支持Unicode的属性和区块，也支持特殊的“Java”字符属性。这
种支持针对UnicodeVersion4.0.0（Java1.4.2只支持UnicodeVersion3.0.0)。
Unicode属性
Unicode属性是通过\p（Lu）之类的缩写名字来引用的（参加122页的列表）。单字母属性名
可以省略括号，\pL等价于\p(L)。而\p{Lowercase_Letter）之类的长名称是不支持的。
Java1.5及之前的版本是不支持Pi和Pf属性的，因此，具有这种属性的字符不能用\p（P）
来匹配（Java1.6支持）。
“未赋值的代码点”属性\p（Cn}匹配的字符，不能由“其他字符”属性\p{C）来匹配。
Java不支持组合属性\p（L&）。
Java支持伪属性\p(all)，它等价于（?S：.）)，但不支持\p{assigned)和\p(unassigned）
伪属性，不过我们可以用\P（Cn）和\p（Cn）来代替。
Unicode区块
Unicodeblock的支持要求使用'In'前缀。请翻到第402页查阅具体的版本信息，了解\p（}
和P（）中能够出现的区块名称。
为了保持向后兼容性，Java1.5中有两个Unicode区块在UnicodeVersion3.0和4.0之间发生
了变化。除了Unicode4.0提供的CombiningDiacriticalMarksforSymbols和Greekand
Coptic之外，还可以使用本不属于Unicode4.0的名称CombiningMarksforSymbols和
Greek,
Java1.4.2有个涉及ArabicPresentationForms-B和LatinExtended-B的bug，在Java1.5
中已经修正。
特殊的Java字符属性
从Java1.5.0开始，\p(）和\P（...)结构能够支持java.lang.Character中未弃用
（non-deprecated）的isSomething方法。为了在正则表达式中使用此功能，请把方法名开头
的‘is’替换成‘java’，然后使用\p()和\P{·))。例如，由java.lang.Characer.
isJavaIdentifierStart匹配的字符也能用正则表达式'p{javaJavaIdentifierStart）
来匹配（请参考java.lang.Character类的文档）。
---
## Page 396
370
第8章：Java
Unicode行终结符
LlnicodeLineTerminators
在Unicode之前的传统正则流派中，点号、^、S和\z会对换行符（ASCII中的LF字符）进
行特殊处理。在Java中，大多数Unicode行终结符（109）也会这样特殊处理。
正常情况下，Java会把下面的这些字符当作行终结符：
字符代码
名称
说明
U+000A
LF
ASCⅡI换行符（“newline”）
U+000D
CR
\r
ASCII回车
U+000DU+000A
CR/LF\r\n
ASCII回车/换行序列
U+0085
NEL
UnicodeNEXT LINE（Unicode换行符）
U+2028
LS
UnicodeLINESEPERATOR（Unicode行分隔符）
U+2029
PS
UnicodePARAGRAPHSEPARATOR（Unicode段分隔符）
根据匹配模式（368）的不同，点号、^、$和\z会对这些符号进行特殊处理：
匹配模式
受影响符号
说明
UNIX_LINE
.$\Z
恢复到传统模式，只把换行符作为一行的终结
MULTILINE
S
字符串中的行终结符也可以由~和S匹配
DOTALL
二
行终结符不再另行处理，点号可以匹配所有字符
作为行终结标志的双字符CR/LF值得一提。默认情况（没有使用UNIX_LINES时）是识别
完整的行终结符，匹配文本行边界的元字符会把CR/LF视为不可分隔的单位，一次性匹配
这两个学符。
举例来说，S和\Z通常会匹配行终结符之前的位置。LF是行终结符，但只有在它不属于
CR/LF（也就是说，LF之前没有CR）的情况下，$和\Z才能匹配字符串末尾的LF之前的
位置。
MUTILINE模式中的S和^也是如此，在这种模式下，只有在CR之后没有LF的情况下，才
能匹配CR之后的位置；只有在LF之前不是CR的情况下，$才能匹配LF之前的位置。
必须说清楚的是，DOTALL对CR/LF的处理没有影响（DOTALL只影响点号，而点号总是逐
个处理字符的），UNIX_LINES根本不存在此类问题（它只识别CR，所有其他行终结符都不
需要特殊处理)。
---
## Page 397
使用java.util.regex
371
使用java.util.regex
Ulsing java.util.regex
通过java.util.regex使用正则表达式非常简单，功能由两个类，一个接口和一个
uncheckedexception组成。
java.util.regex.Pattern