      size = Size;
      code_2 = code_1;
      memset(code_1, 0, Size + 1);
      src = Src;
      if ( v25 ,std::allocator>::~basic_string,std::allocator>();//析构函数
    }
看看那个表：
用lazyida可以提取出来：
    [+] Dump 0x1093020 - 0x109305F (63 bytes) :
    [0x37, 0x34, 0x35, 0x32, 0x33, 0x30, 0x31, 0x3E, 0x3F, 0x3C, 0x3D, 0x3A, 0x3B, 0x38, 0x39, 0x26, 0x27, 0x24, 0x25, 0x22, 0x23, 0x20, 0x21, 0x2E, 0x2F, 0x2C, 0x17, 0x14, 0x15, 0x12, 0x13, 0x10, 0x11, 0x1E, 0x1F, 0x1C, 0x1D, 0x1A, 0x1B, 0x18, 0x19, 0x06, 0x07, 0x04, 0x05, 0x02, 0x03, 0x00, 0x01, 0x0E, 0x0F, 0x0C, 0x46, 0x47, 0x44, 0x45, 0x42, 0x43, 0x40, 0x41, 0x4E, 0x4F, 0x5D]
这是lazyida的一个弊端，明明64位的，把最后一位给弄丢了，去看看：
把0x59给漏掉了，补上，我们的表就出来了：
    int table[64] = {
    0x37, 0x34, 0x35, 0x32, 0x33, 0x30, 0x31, 0x3E, //下标0到7
    0x3F, 0x3C, 0x3D, 0x3A, 0x3B, 0x38, 0x39, 0x26,
    0x27, 0x24, 0x25, 0x22, 0x23, 0x20, 0x21, 0x2E, 
    0x2F, 0x2C, 0x17, 0x14, 0x15, 0x12, 0x13, 0x10,
    0x11, 0x1E, 0x1F, 0x1C, 0x1D, 0x1A, 0x1B, 0x18,
    0x19, 0x06, 0x07, 0x04, 0x05, 0x02, 0x03, 0x00,
    0x01, 0x0E, 0x0F, 0x0C, 0x46, 0x47, 0x44, 0x45,
    0x42, 0x43, 0x40, 0x41, 0x4E, 0x4F, 0x5D，0x59};//下标56到63
那么这里逻辑很清楚了：
1、将密文v8 = reverse+ 先异或0x76得到新密文
2、新密文即是在那个表中找到的字符值(因为有些字符是不可见的，所以统一用16进制表示)，查表可以知道字符对应的下标值，将下标值进行Base64解密（6位转8位）得到我们上一关刚进去时的v8的值
3、v8知道了，爆破就可以直接解出来flag了
    #include
    #include 
    using namespace std;
    int main()
    {
     char b[100] = {"reverse+"};
     cout>4); //取出第一个的前6位与第二个后2位进行组合  
            code3[j+1] = ((a[i+1] & 0xf)>2); //取出第二个的后4位与第三个的后4位进行组合  
            code3[j+2] = ((a[i+2] & 0x3)9)
                   {
                       j+=55;
                       input[m++] = char(j);
                   }
                   else
                   {
                       j+=48;
                       input[m++] = char(j);
                   }
                   cout9)
                   {
                      i+=55;
                      input[m++] = char(i);
                   }
                   else
                   {
                      i+=48;
                      input[m++] = char(i);
                   }
                 }
              }
        cout
    #include 
    using namespace std;
    int main()
    {
       char b[100] = {"reverse+"};
       cout>4); //取出第一个的前6位与第二个后2位进行组合  
            code3[j+1] = ((a[i+1] & 0xf)>2); //取出第二个的后4位与第三个的后4位进行组合  
            code3[j+2] = ((a[i+2] & 0x3)<<6) | (a[i+3]);//取出第三个字符的后2位与第4个字符进行组合  
            j+=3;