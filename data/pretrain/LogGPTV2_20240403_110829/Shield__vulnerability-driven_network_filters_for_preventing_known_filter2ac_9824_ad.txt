### 2. Shield Language and Comparison with Bro

The Shield language is designed to be simpler than the Bro language [27], which is used for scripting security policies in the Bro Network Intrusion Detection System (NIDS). Bro is a powerful tool that performs network monitoring and intrusion detection at the network layer and above, as well as cross-application and cross-session interaction monitoring based on various attack patterns. In contrast, Shield focuses specifically on application-specific traffic over the transport layer and higher-level protocols such as HTTP and RPC.

A key advantage of Shield's vulnerability-driven approach over attack- or exploit-driven approaches like NIDS is that Shield does not need to consider attack activities before the vulnerable application is involved. For example, in multi-stage attacks, where an attack setup stage precedes the actual vulnerability exploitation, Shield only needs to screen the traffic of particular vulnerable applications. This reduces the complexity and overhead of the system.

### 6. Analysis

#### 6.1 Scalability with Number of Vulnerabilities

In this section, we discuss how Shield scales with the number of vulnerabilities on a machine.

The number of shields on an end host should not grow arbitrarily large, as each shield is typically removed when its corresponding vulnerability is patched. Additionally, Shields are application-specific, adding negligible overhead to applications to which they do not apply. Therefore, N shields for N different applications are equivalent to a single shield in terms of their impact on the performance of any single application.

An application may have multiple vulnerabilities over time. The state machines that model these vulnerabilities should preferably be merged into a single one. Otherwise, each state machine must be traversed for each packet, resulting in linear overhead. When these vulnerabilities appear on disjoint paths of the merged state machine, per-packet shield processing overhead for them is almost equivalent to the overhead for just one vulnerability. For vulnerabilities that share paths in the state machine, however, shield overhead may be cumulative. However, our data on vulnerabilities presented in Section 8.1 suggests that this cumulative effect is not significant: for worm-exploitable vulnerabilities, no more than three vulnerabilities ever appeared over a single application level protocol throughout the whole year.

For vulnerable applications, the application throughput with Shield, at worst, is about halved, since the network traffic is processed at most twice—once in Shield and once in the application. Moreover, our experiments with our Shield prototype indicate that Shield’s impact on application throughput is small (Section 8.2).

#### 6.2 False Positives

By design, shields are able to recognize and filter only traffic that exploits a specific vulnerability, and hence should have very low false positives. However, false positives may arise from incorrect policy specification due to misunderstanding of the protocol state machines or payload formats. Such incorrect policy specifications can be debugged with stress test suites or by replaying a substantial volume of application traffic traces. Trace replay at the application level is relatively easy, as it is not necessary to replay the precise transport protocol behavior.

Another source of false positives may be state-sensitive application behavior upon receiving an exploit event. The application state machine embedded at that state may only trigger the vulnerable code based on local machine settings or some runtime conditions. While such information can be incorporated into Shield, it is difficult to generalize such application-specific implementation details into simple and safe policy language constructs. For the vulnerabilities with which we have experimented, we have not observed such false positives.

### 7. Implementation

We have prototyped an end host-based Shield system on Microsoft Windows XP. Specifically, we implemented Shield as a Microsoft WinSock2 Layered Service Provider (LSP) [16]. WinSock2 API is the latest socket programming interface for network applications on Windows. At runtime, these network applications link in the appropriate socket functions from the WinSock2 dynamically linked library (DLL) when making socket function calls. The LSP mechanism in WinSock2 allows new service providers to intercept WinSock2 calls to the kernel socket system calls. An LSP is compiled into a dynamically linked library. Upon installation, any applications making WinSock2 calls link in both the WinSock2 DLL and the LSP DLL. We use this mechanism to implement Shield for intercepting vulnerable application traffic above the transport layer, as shown in Figure 6.

**Figure 6: Shield Prototype Using WinSock2 LSP**

Our Shield LSP implements the architecture depicted in Figure 2 with 10,702 lines of C++ code. We employ Flex [26] and Byacc [4] to parse the syntax of the Shield policy language, and the Policy Loader calls the Byacc API to obtain the syntax trees of the policy scripts.

We have used the vulnerabilities behind Slammer [40], MSBlast [24], CodeRed [7], and twelve other vulnerabilities from Microsoft security bulletins to drive our design and implementation. These are all input validation failure vulnerabilities, such as buffer overruns, integer overflows, or malformed URLs. Slammer exploits a proprietary application-level protocol, SSRP [40], on top of UDP. MSBlast exploits RPC [34] over either TCP or UDP. CodeRed uses HTTP [12]. Other vulnerabilities exploit Telnet [29], SMB [38], HTTP, or RPC. We have also examined some other protocols such as RTP [36] and SMTP [17] during the design of our policy language.

### 8. Evaluations

#### 8.1 Applicability of Shield

How applicable is Shield to real-world vulnerabilities? Shield was designed to catch exploits in a wide variety of application-level protocols, but there are several potential gaps in its coverage:

- **Deeply Embedded Logic Bugs:** Vulnerabilities that result from bugs deeply embedded in the application’s logic are difficult for Shield to defend against without replicating that application logic in the network. For example, browser-based vulnerabilities that can be exploited using HTML scripting languages are difficult for Shield to prevent, as those languages are so flexible that incoming scripts would likely have to be parsed and run in simulation to discover if they are in fact exploits.
- **Protocol-Independent Application Objects:** Even simple vulnerabilities that are exploitable by malformed, network protocol-independent application objects (such as files) are difficult for Shield to catch. For example, a shield against otherwise simple buffer overruns in application file format parsers would have to spot an incoming file arriving over many different protocols. For file-based vulnerabilities, vulnerability-specific anti-virus software (rather than the exploit-signature-based kind typically used today) would be more appropriate. Such software already has to deal with the polymorphism sometimes exhibited by viruses.
- **Application-Specific Encryption:** Application-specific encryption poses a problem for Shield, as mentioned in Section 1.

To assess the significance of these obstacles, we analyzed the entire list of security bulletins published by the Microsoft Security Response Center (MSRC) for the year 2003. Table 1 summarizes our findings. Of the 49 bulletins, six described vulnerabilities that were purely local, not involving a network in any way. Of the rest, 24 described "user-involved" vulnerabilities, requiring local user action on the vulnerable machine—such as navigating to a malicious website or opening an emailed application—to trigger. The remaining 19 described server vulnerabilities, possible to trigger via the network, from outside the machine.

**Table 1: Applicability of Shield for vulnerabilities of MSRC over the year 2003.**

| # of Vuln. | Nature | Wormable | Shieldable |
|------------|--------|----------|------------|
| 6          | Local  | No       | No         |
| 24         | User-involved | No | Usually Hard |
| 12         | Server buffer overruns | Yes | Easy |
| 3          | Cross-site scripting | No | Hard |
| 3          | Server Denial-of-service | No | Varies |

The user-involved vulnerabilities generally appear difficult to design shields for. However, none of them are likely to result in self-propagating worms, as they cannot be exploited without some kind of user action upon the browser. For example, seven involved application file formats. Two were email client vulnerabilities, one was a media player vulnerability, and the rest were found in the browser, invoked via HTML or client-side scripting.

Of the server vulnerabilities, twelve might conceivably be exploitable by worms under "ideal" conditions—i.e., the server application being very widely deployed in an unprotected, unpatched, and unfirewalled configuration. The remainder included three denial-of-service attacks, three "cross-site scripting" attacks, and a potential information disclosure. These are not vulnerable to exploitation by worms.

Of the potentially worm-exploitable vulnerabilities, five involved application-level protocols running over HTTP. The rest involved specific application-level protocols—typically directly over TCP or UDP—none of which appear inherently incompatible with the Shield approach. Moreover, all twelve were based on buffer overruns and hence amenable to shielding.

Thus, while many vulnerabilities may not appear to be suitable for the Shield treatment, in fact, the most threatening—those prone to exploitation by worms—appear to be disproportionately Shield-compatible.

We also assessed the reliability of the patches associated with our sample set of security bulletins. Of the patches associated with the 49 bulletins, ten (including three repairing potentially worm-exploitable vulnerabilities) were updated at least once following their initial release. Eight of those (including two involving wormable vulnerabilities) were updated to mitigate reported negative side effects of the patch. The others were augmented with extra patches for legacy versions of the product. These side effects would likely have been avoided had Shield been used in place of the patch, as a key advantage of shields over patches is their easy testability (see Section 1).

Finally, with the exception of HTTP-related vulnerabilities, no single application-level protocol exhibited more than RPC’s three vulnerabilities during the entire year. Hence, apart from the HTTP port, no port is likely to be burdened with so many combined shields at a given time that the cumulative performance cost of multiple shields becomes an issue separate from the overhead of shielding the port in the first place.

#### 8.2 Application Throughput

To evaluate the impact of Shield on application throughput and CPU usage, we devised the following experiment: We have multiple clients establishing simultaneous sessions over TCP with a server. The server is a Dell PWS650 with a 3.06 GHz CPU and 1 GB of RAM. The clients and the server are connected via a 100 Mbps or 1 Gbps Ethernet switch. All computers run Windows XP SP1.

We use the following client-server protocol:

**Figure 7: Excerpt from our throughput experiment policy**

```
SHIELD (ThroughputTest, TCP, (9898))
STATE_MACHINE = {
    (S_WaitForBind, E_Bind, H_Bind),
    (S_WaitForBindAck, E_BindAck, H_BindAck),
    (S_WaitForRequest, E_Request, H_Request),
    (S_WaitForResponse, E_Response, H_Response),
    (S_WaitForRequest, E_Shutdown, H_Shutdown),
};
PAYLOAD_STRUCT {
    BYTES(1024) item,
} P_Unit;
PAYLOAD_STRUCT {
    field1,
    BYTES(4)
    # upto 1024 bytes of data is buffered for each session
    P_Unit[1024] MBytes,
    P_RESPONSE;
}
HANDLER H_Response (P_RESPONSE) {
    FOREACH (P_unit IN >>P_RESPONSE.MBytes) {
        # touching each byte of the 1 MB data
        PRINT (>>P_Unit.item);
    }
    RETURN (S_FINAL);
};
```

**Figure 8: CPU Comparison for 100 Mbps Switch**

1. Client -> Server: BIND
2. Server -> Client: BIND_ACK
3. Client -> Server: MSG_REQUEST
4. Server -> Client: MSG_RESPONSE of 1 MB data
5. Goto 1

We used the policy script shown in Figure 7. 1 MB of data in MSG RESPONSE is represented as an array of P Units that consists of 1024 bytes. This increases the experiment’s stress on resources, as each session will buffer up to 1KB.

We measure the server’s throughput and CPU usage in three scenarios, using either a 100 Mbps Ethernet switch or a 1 Gbps one: 1) without LSP and Shield; 2) with LSP, but without Shield (i.e., the packets just pass through the LSP); 3) with LSP and Shield.

With the 100 Mbps switch, all three scenarios achieve a maximum possible throughput of 92.8 Mbps. However, we observe that LSP incurs 11-28% CPU overhead when the number of clients is low (≤ 50), and Shield logic adds just a few percent on top of the LSP overhead. Figure 8 shows the CPU usage comparison. With a 1 Gbps Ethernet switch, the high-speed switching saturated CPU usage for all cases. Nevertheless, we can observe the differences in throughput for all three scenarios, as shown in Figure 9. As the number of clients increases, the throughput decreases for all scenarios: LSP degrades throughput by 12%, and Shield further degrades the throughput by another 11%. While such overhead is manageable, we observe that much of the overhead is due to the WinSock LSP design [16]. WinSock LSP is designed to allow multiple LSPs (like Shield) to be chained as layers of providers and consumers. A socket instance of an LSP inherits the context information from its provider through socket replication. The base provider is the respective kernel socket. Further, cross-layer socket associations and translations must also be carried out by LSPs. This becomes especially inefficient when "select" calls are used over a large number of sockets for I/O multiplexing, which is the case for our experiment. We suspect that a well-designed kernel implementation of Shield could eliminate much of the overhead incurred by LSP.

**Figure 9: Throughput Comparison for 1 Gbps Switch**

#### 8.3 False Positives

As mentioned in Section 6.2, false positives come from either incorrect policy specification or state-sensitive application behavior. Incorrect policy specifications can be debugged with stress test suites or by replaying a substantial volume of application traffic traces. State-sensitive application behavior can be challenging to handle, but for the vulnerabilities we have experimented with, we have not observed such false positives.