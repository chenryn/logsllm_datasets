25, 11], that are appropriate for the purphose of shielding.
Our language is simpler than the Bro language [27] that is
used for scripting the security policies of the Bro Nework In-
trusion Detection System (NIDS). This is because Bro per-
forms network monitoring and intrusion detection for the
network layer and above of the network stack, and also
monitors cross-application, cross-session interactions based
on various attack patterns. In contrast, Shield is only con-
cerned with application-speciﬁc traﬃc passing over trans-
port layer, or of even higher-level protocols such as HTTP
and RPC. Furthermore, a key advantage of the vulnerability-
driven approach of Shield over attack- or exploit-driven ap-
proachs such as NIDS is that Shield does not need to con-
sider attack activities before the vulnerable application is
involved, as in, for example, multi-stage attacks, where an
attack setup stage precedes the actual vulnerability exploita-
tion. Shield only needs to screen the traﬃc of particular
vulnerable applications.
6. ANALYSIS
6.1 Scalability with Number of Vulnerabilties
In this section, we discuss how Shield scales with the num-
ber of vulnerabilities on a machine.
The number of shields on an end host should not grow
arbitrarily large, because each shield will presumably be
removed when its corresponding vulnerability is patched.
Also, Shields are application-speciﬁc, adding negligible over-
head to applications to which they do not apply. Hence, N
Shields for N diﬀerent applications are equivalent to a sin-
gle shield in terms of their eﬀect on the performance of any
single application.
An application may have multiple vulnerabilities over time.
The state machines that model these vulnerabilities should
preferably be merged into a single one. Otherwise, each state
machine must be traversed for each packet, resulting in lin-
ear overhead. When these vulnerabilities appear on disjoint
paths of the merged state machine, per-packet shield pro-
cessing overhead for them is almost equivalent to the over-
head for just one vulnerability. For vulnerabilities that share
paths in the state machine, however, shield overhead may be
cumulative. On the other hand, our data on vulnerabilities
presented in Section 8.1 suggests that this cumulative eﬀect
is not signiﬁcant: For worm-exploitable vulnerabilities, no
more than three vulnerabilities ever appeared over a single
application level protocol throughout the whole year.
In any case, for vulnerable applications, the application
throughput with shield is, at worst, about halved, since the
network traﬃc is processed at most twice — once in Shield
and once in the application. Moreover, our experiments with
our Shield prototype indicate that Shield’s impact on appli-
cation throughput is small (Section 8.2).
6.2 False Positives
By design, shields are able to recognize and ﬁlter only traf-
ﬁc that exploits a speciﬁc vulnerability, and hence should
have very low false positives. However, false positives may
arise from incorrect policy speciﬁcation due to misunder-
standing of the protocol state machines or payload formats.
Such incorrect policy speciﬁcation can be debugged with
stress test suites or simply by replaying a substantial volume
of application traﬃc traces. Trace replay at the application
level is easy since it is not necessary to replay the precise
transport protocol behavior.
Another source of false positives may be state-sensitive
application behavior upon receiving an exploit event. The
application state machine embedded at that state may only
trigger the vulnerable code based on the local machine set-
ting or some runtime conditions. While such information
can also be incorporated into Shield, it is diﬃcult to gen-
eralize such application-speciﬁc implementation details to
simple and safe policy language constructs. For the vul-
nerabilities with which we have experimented, we have not
observed such false positives.
7.
IMPLEMENTATION
We have prototyped an end host-based Shield system on
Microsoft Windows XP. In particular, we have implemented
Shield as a Microsoft WinSock2 Layered Service Provider
(LSP) [16]. WinSock2 API is the latest socket programming
interface for network applications on Windows. At runtime,
these network applications link in the appropriate socket
functions from the WinSock2 dymamically linked library
(DLL) when making socket function calls. The LSP mecha-
nism in WinSock2 allows new service providers to be created
for intercepting WinSock2 calls to the kernel socket system
calls. An LSP is compiled into a dynamically linked library.
Upon installation, any applications making WinSock2 calls
link in both the WinSock2 DLL and the LSP DLL. We use
this mechanism to implement Shield for intercepting vulner-
able application traﬃc above the transport layer as shown
in Figure 6.
Figure 6: Shield Prototype Using WinSock2 LSP
Our Shield LSP implements the architecture depicted in
TCP/IPATMOthers.Windows Socket Kernel Mode Driver (AFD.SYS)Shield Layered Service Provider (SHIELDLSP.DLL)Winsock 2.0 (WS2_32.DLL)ApplicationsKernelUserFigure 2 with 10,702 lines of C++ code3. We employ Flex [26]
and Byacc [4] to parse the syntax of the Shield policy lan-
guage, and the Policy Loader calls the Byacc API to obtain
the syntax trees of the policy scripts.
We have used the vulnerabilities behind Slammer [40],
MSBlast [24], CodeRed [7], and twelve other vulnerabili-
ties from Microsoft security bulletins to drive our design
and implementation. They are all input validation failure
vulnerabilities, such as buﬀer overruns, integer overﬂows,
or malformed URLs. Slammer exploits a proprietary ap-
plication level protocol, SSRP [40], on top of UDP. MS-
Blast exploits RPC [34] over either TCP or UDP. CodeRed
uses HTTP [12]. Other vulnerabilities exploit Telnet [29],
SMB [38], HTTP or RPC. We have also examined some
other protocols such as RTP [36] and SMTP [17] during the
design of our policy language.
8. EVALUATIONS
8.1 Applicability of Shield
How applicable is Shield to real-world vulnerabilities? Shield
was designed to catch exploits in a wide variety of application-
level protocols, but there are several potential gaps in its
coverage:
• Vulnerabilities that result from bugs that are deeply
embedded in the application’s logic are diﬃcult for
Shield to defend against without replicating that ap-
plication logic in the network. For example, browser-
based vulnerabilities that can be exploited using HTML
scripting languages are diﬃcult for Shield to prevent,
since those languages are so ﬂexible that incoming
scripts would likely have to be parsed and run in sim-
ulation to discover if they are in fact exploits.
• Even simple vulnerabilities that are exploitable by mal-
formed, network protocol-independent application ob-
jects (such as ﬁles) are diﬃcult for Shield to catch.
For example, a shield against otherwise simple buﬀer
overruns in application ﬁle format parsers would have
to spot an incoming ﬁle arriving over many diﬀerent
protocols. For ﬁle-based vulnerabilities, vulnerability-
speciﬁc anti-virus software (rather than the exploit-
signature-based kind typically used today) would be
more appropriate. Such software already has to deal
with the polymorphism sometimes exhibited by viruses.
• Application-speciﬁc encryption poses a problem for Shield,
as mentioned in Section 1.
To assess the signiﬁcance of these obstacles, we analyzed
the entire list of security bulletins published by the Microsoft
Security Response Center (MSRC) for the year 2003. Ta-
ble 1 summarizes our ﬁndings. Of the 49 bulletins, six de-
scribed vulnerabilities that were purely local, not involv-
ing a network in any way. Of the rest, 24 described “user-
involved” vulnerabilities, in the sense of requiring local user
action on the vulnerable machine — such as navigating to a
malicious Website, or opening an emailed application — to
trigger. The remaining 19 described server vulnerabilities,
in the sense of being possible to trigger via the network,
from outside the machine.
The user-involved vulnerabilities generally appear diﬃcult
to design shields for. However, none of them are likely to
3This line count does not include the generated Flex and
Byacc ﬁles.
# of Vuln. Nature
6
24
12
3
3
Wormable
No
Local
No
User-involved
Yes
Server buﬀer overruns
Cross-site scripting
No
Server Denial-of-service No
Shieldable
No
Usually Hard
Easy
Hard
Varies
Table 1: Applicability of Shield for vulnerabilities of
MSRC over the year 2003.
result in self-propagating worms, because they cannot be
exploited without some kind of user action upon the browser.
For example, seven involved application ﬁle formats. Two
were email client vulnerabilities, one was a media player
vulnerability, and the rest were found in the browser, and
hence invoked via HTML or client-side scripting.
Of the server vulnerabilities, twelve might conceivably be
exploitable by worms, under “ideal” conditions — i.e., the
server application being very widely deployed in an unpro-
tected, unpatched and unﬁrewalled conﬁguration. The re-
mainder included three denial-of-service attacks, three “cross-
site scripting” attacks, and a potential information disclo-
sure. These are not vulnerable to exploitation by worms.
Of the potentially worm-exploitable vulnerabilities, ﬁve
involved application level protocols running over HTTP. The
rest involved speciﬁc application level protocols — typically
directly over TCP or UDP — none of which appear inher-
ently incompatible to the Shield approach. Moreover, all
twelve were based on buﬀer overruns, and hence amenable
to shielding.
Thus, while many vulnerabilities may not appear to be
suitable for the Shield treatment, in fact the most threaten-
ing — those prone to exploitation by worms — appear to
be disproportionately Shield-compatible.
We also assessed the reliability of the patches associated
with our sample set of security bulletins. Of the patches as-
sociated with the 49 bulletins, ten (including three repairing
potentially worm-exploitable vulnerabilities) were updated
at least once following their initial release. Eight of those
(including two involving wormable vulnerabilities) were up-
dated to mitigate reported negative side eﬀects of the patch.
The others were augmented with extra patches for legacy
versions of the product. These side eﬀects would likely have
been avoided had Shield been used in place of the patch,
since a key advantage of shields over patches is their easy
testability (see Section 1).
Finally, with the exception of HTTP-related vulnerabili-
ties, no single application-level protocol exhibited more than
RPC’s three vulnerabilities during the entire year. Hence,
apart from the HTTP port, no port is likely to be burdened
with so many combined shields at a given time that the cu-
mulative performance cost of multiple shields becomes an
issue separate from the overhead of shielding the port in the
ﬁrst place.
8.2 Application Throughput
To evaluate the impact of Shield on application through-
put and CPU usage, we have devised the following exper-
iment: We have multiple clients establishing simultaneous
sessions over TCP with a server. The server is a Dell PWS650
with a 3.06 Ghz CPU and 1 GB of RAM. The clients and
the server are connected via a 100 Mbps or 1 Gbps Ethernet
switch. All computers run Windows XP SP1.
We use the following client-server protocol:
SHIELD (ThroughputTest, TCP, (9898))
STATE_MACHINE = {
(S_WaitForBind, E_Bind, H_Bind),
(S_WaitForBindAck, E_BindAck, H_BindAck),
(S_WaitForRequest, E_Request, H_Request),
(S_WaitForResponse, E_Response, H_Response),
(S_WaitForRequest, E_Shutdown, H_Shutdown),
};
PAYLOAD_STRUCT {
BYTES(1024) item,
} P_Unit;
PAYLOAD_STRUCT {
field1,
BYTES(4)
# upto 1024 bytes of data is buffered for each session
P_Unit[1024] MBytes,
P_RESPONSE;
}
HANDLER H_Response (P_RESPONSE)
{
FOREACH (P_unit IN >>P_RESPONSE.MBytes) {
# touching each byte of the 1 MB data
PRINT (>>P_Unit.item);
}
RETURN (S_FINAL);
};
Figure 7: Excerpt from our throughput experiment
policy
Figure 8: CPU Comparison for 100 Mbps Switch
1. Client -> Server: BIND
2. Server -> Client: BIND_ACK
3. Client -> Server: MSG_REQUEST
4. Server -> Client: MSG_RESPONSE of 1 MB data
5. Goto 1
We used the policy script shown in Figure 7. 1 MB of data
in MSG RESPONSE is represented as an array of P Units
that consists of 1024 bytes. This increases the experiment’s
stress on resources, since each session will buﬀer up to 1KB.
We measure the server’s throughput and CPU usage in
three scenarios, using either a 100 Mbps Ethernet switch or
a Gbps one: 1) without LSP and Shield; 2) with LSP, but
without Shield (i.e., the packets just pass through the LSP);
3) with LSP and Shield.
With the 100 Mbps switch, all three scenarios achieve a
maximum possible throughput of 92.8 Mbps. However, we
observe that LSP incurs 11-28% CPU overhead when the
number of clients is low (≤ 50), and Shield logic adds just a
few percent on top of the LSP overhead. Figure 8 shows the
CPU usage comparison. With a 1 Gbps Ethernet switch,
the high-speed switching saturated CPU usage for all cases.
Nevertheless, we can observe the diﬀerences in throughput
for all three scenarios, as shown in Figure 9. As the number
of clients increases, the throughput decreases for all scenar-
ios: LSP degrades throughput by 12%, and Shield further
degrades the throughput by another 11%. While such over-
head is manageable, we observe that much of the overhead
is due to the WinSock LSP design [16]. WinSock LSP is
Figure 9: Throughput Comparison for 1 Gbps
Switch
designed to allow multiple LSPs (like Shield) to be chained
as layers of providers and consumers. A socket instance of
an LSP inherits the context information from its provider
through socket replication. The base provider is the respec-
tive kernel socket. Further, cross-layer socket associations
and translations must also be carried out by LSPs. This be-
comes especially ineﬃcient when “select” calls are used over
a large number of sockets for I/O multiplexing, which is the
case for our experiment. We suspect that a well-designed
kernel implementation of Shield could eliminate much of the
overhead incurred by LSP.
8.3 False Positives
As mentioned in Section 6.2, false positives come from ei-