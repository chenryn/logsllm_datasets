tion, network I/O and disk I/O using the same settings as we measure the kernel
attack surface reduction. Benchmark tools are conducted with two groups, i.e.,
one is called Original (HVM with an unmodiﬁed Xen), the other is KASR.
Speciﬁcally, SPECint has 12 sub-programs and the CPU overhead caused by
KASR within each sub-program is quite small and stable. In particular, the max-
imum performance overhead is 1.47% while the average performance overhead
is 0.23% for the overall system.
Httperf tests the Apache Web server inside the HVM using diﬀerent request
rates. Compared to the Original, the network I/O overhead introduced by KASR
ranges from 0.00% to 1.94% and the average is only 0.90%.
706
Z. Zhang et al.
Fig. 4. In the case of LAMP, its database
is built from scratch and keeps its size
increasing until the round 6th.
Fig. 5.
Incremental oﬄine training.
Compared to that of Fig. 4, only 2 more
oﬄine training rounds based on a pro-
vided database are needed to reach the
same stable state, largely reducing the
oﬄine training cost.
The disk I/O results are generated by bonnie++ based on two test settings,
i.e., sequential input and sequential output. For each setting, the read, write and
rewrite operations are performed and their results indicate that KASR only
incurs a loss of 0.49% on average.
6.4 Oﬄine Training Eﬃciency
We take LAMP server as an example to illustrate the oﬄine training eﬃciency,
indicating how fast to construct a stable database for a given workload. Speciﬁ-
cally, we repeat the oﬄine training stage for several rounds to build the LAMP
database from scratch. After the ﬁrst round, we get 1038 code pages, 99% of the
ﬁnal page number. After that, 9 successive oﬄine training rounds are completed
one by one, each of which updates the database based on previous one, ensuring
that the ﬁnal database records all used pages. From Fig. 4, it can be seen that
the database as a whole becomes steady after multiple rounds (i.e., 6 in our
experiments). This observation is also conﬁrmed in other cases.
In fact, it is still time-consuming to build a particular database from scratch.
To further accelerate this process, we attempt to do the oﬄine training stage
from an existing database. In our experiments, we integrate every database gen-
erated respectively for SPECint, httperf, bonnie++ into a larger one, and try to
generate the LAMP database using incremental training. Based on the integrated
database, we ﬁnd that only 2 rounds are enough to generate the stable database
for LAMP, shown in Fig. 5, signiﬁcantly improving the oﬄine training eﬃciency.
A Reliable and Practical Approach to Kernel Attack Surface Reduction
707
7 Discussion
In this section, we will discuss limitations of our approach.
Training Completeness. Similar to Ktrim [17], KRAZOR [16] and Face-
Change [10], KASR also uses a training-based approach. As the approach might
miss some corner cases, it may cause KASR to mark certain pages that should
be used as unused, resulting in an incomplete oﬄine training database. Theoret-
ically speaking, it is possible for such situations to occur. However, in practice,
they have never been observed in our experiments so far. Interestingly, Kurmus
al et. [18] found that a small oﬄine training set is usually enough to cover all used
kernel code for a given use case, implying that the corner cases usually do not
increase the kernel code coverage. If the generated database is incomplete, EPT
violations may have been triggered at runtime. For such situations, KASR has
two possible responses. One is to directly stop the execution of the guest, which
is suitable for the security sensitive environment where any violations may be
treated as potential attacks. The other one is to generate a log message, which is
friendly to the applications that have high availability requirements. The gener-
ated log contains the execution context and the corresponding memory content
to facilitate a further analysis, e.g., system forensics.
Fine-Grained Segmentation. By default, we have three segmented phases
(i.e., startup, runtime, and shutdown). Actually, the whole lifecycle could be
segmented into more phases, corresponding to diﬀerent working stages of a user
application. Intuitively, a more ﬁne-grained segmentation will achieve a better
kernel attack surface reduction. Nonetheless, more phases will introduce more
performance overhead, such as the additional phase switches. In addition, it will
increase the complexity of the KASR oﬄine training processor, and consequently
increases the trusted computing base (TCB). At last, the KASR module has
to deal with the potential security attacks, e.g., malicious phase switches. To
prevent such attacks, a state machine graph of phases should be provided, where
the predecessor, successor and the switch condition of each phase should be
clearly deﬁned. At runtime, the KASR module will load this graph and enforce
the integrity: only the phase switches existing in the graph are legal, and any
other switches will be rejected.
8 Related Work
In this section, we provide an overview of existing approaches to enhance the
kernel security that require no changes to the kernel. Speciﬁcally, the approaches
are either kernel or hypervisor-dependent.
Kernel customizations [18,33] present automatic approaches of trimming ker-
nel conﬁgurations adapted to speciﬁc use cases so that the tailored conﬁgurations
can be applied to re-compile the kernel source code, thus minimizing the kernel
attack surface. Similarly, Seccomp [26] relies on the kernel source code to sand-
box speciﬁed user processes by simply restricting them to a minimal set of system
708
Z. Zhang et al.
calls. Lock-in-Pop [19] modiﬁes and re-compiles glibc to restrict an application’
access to certain kernel code. In contrast, both Ktrim [17] and KRAZOR [16]
utilize kprobes to trim oﬀ unused kernel functions and prevent them from being
executed. All of the approaches above aim at providing a minimized kernel view
to a target application.
In the virtualized environment, both Secvisor [27] and NICKLE [25] only
protect original kernel TCB and do nothing to reduce it. Taking a step further,
unikernel [20] provides a minimal kernel API surface to speciﬁed applications
but developing the applications is highly dependent on the underlying unikernel.
Face-Change [10] proﬁles the kernel code for every target application and uses
the Virtual Machine Introspection (VMI) technique to detect process context
switch and thus provide a minimized kernel TCB for each application. However,
Face-Change has three disadvantages: (1) Its worst-case runtime overhead for
httperf testing Apache web server is 40%, whereas our worst overhead is 1.94%
(see Sect. 6.3), making it impractical in the cloud environment. (2) Its design
naturally does not support KASLR, which is an important kernel security fea-
ture and has been merged into the Linux kernel mainline since kernel version
3.14. In contrast, KASR is friendly to the security feature. (3) While multiple-
vCPU support is critical to system performance in the cloud environment, it
only supports a single vCPU within a guest VM, whereas KASR allocates four
vCPUs to the VM.
9 Conclusion
Commodity OS kernels provide a large number of features to satisfy various
demands from diﬀerent users, exposing a huge surface to remote and local attack-
ers. In this paper, we have presented a reliable and practical approach, named
KASR, which has transparently reduced attack surfaces of commodity OS ker-
nels at runtime without relying on their kernel source code. KASR deploys two
surface reduction approaches. One is spatial, i.e., the permission deprivation
marks never-used code pages as non-executable while the other is temporal, i.e.,
the lifetime segmentation selectively activates appropriate used code pages. We
implemented KASR on the Xen hypervisor and evaluated it using the Ubuntu OS
with an unmodiﬁed Linux kernel. The experimental results showed that KASR
has eﬃciently reduced 64% of kernel attack surface, 40% of CVEs in all given
use cases. In addition, KASR defeated all 6 real-world rootkits and incurred low
performance overhead (i.e., less than 1% on average) to the whole system.
In the near future, our primary goals are to apply KASR to the kernel attack
surface reduction of a Windows OS since KASR should be generic to protect all
kinds of commodity OS kernels.
References
1. Accetta, M., et al.: Mach: a new kernel foundation for UNIX development (1986)
2. AMD Inc.: Secure virtual machine architecture reference manual, December 2005
A Reliable and Practical Approach to Kernel Attack Surface Reduction
709
3. ARM Inc.: Armv8 (2011). https://community.arm.com/docs/DOC-10896
4. Azab, A.M., Ning, P., Wang, Z., Jiang, X., Zhang, X., Skalsky, N.C.: HyperSentry:
enabling stealthy in-context measurement of hypervisor integrity. In: Proceedings
of the 17th ACM Conference on Computer and Communications Security, CCS
2010, pp. 38–49 (2010)
5. Bonnie (1999). http://www.coker.com.au/bonnie++
6. Cheng, Y., Ding, X.: Guardian: hypervisor as security foothold for personal com-
puters. In: Huth, M., Asokan, N., ˇCapkun, S., Flechais, I., Coles-Kemp, L. (eds.)
Trust 2013. LNCS, vol. 7904, pp. 19–36. Springer, Heidelberg (2013). https://doi.
org/10.1007/978-3-642-38908-5 2
7. Colp, P., et al.: Breaking up is hard to do: security and functionality in a commodity
hypervisor. In: Proceedings of the Twenty-Third ACM Symposium on Operating
Systems Principles, SOSP 2011, pp. 189–202. ACM (2011)
8. Cook, K.: Linux kernel ASLR (KASLR). In: Linux Security Summit (2013)
9. Dautenhahn, N., Kasampalis, T., Dietz, W., Criswell, J., Adve, V.: Nested kernel:
an operating system architecture for intra-kernel privilege separation. In: Proceed-
ings of the Twentieth International Conference on Architectural Support for Pro-
gramming Languages and Operating Systems, ASPLOS 2015, pp. 191–206 (2015)
10. Gu, Z., Saltaformaggio, B., Zhang, X., Xu, D.: Face-change: application-driven
dynamic kernel view switching in a virtual machine. In: 44th Annual IEEE/IFIP
International Conference Dependable Systems and Networks (DSN), DSN 2014,
pp. 491–502. IEEE (2014)
11. Herder, J.N., Bos, H., Gras, B., Homburg, P.: MINIX 3: a highly reliable, self-
repairing operating system. ACM SIGOPS Oper. Syst. Rev. 40(3), 80–89 (2006)
12. Herder, J.N., Bos, H., Gras, B., Homburg, P., Tanenbaum, A.S.: Construction
of a highly dependable operating system. In: Proceedings of the 6th European
Dependable Computing Conference, EDCC 2006, pp. 3–12. IEEE (2006)
13. Intel Inc.: Intel 64 and IA-32 architectures software developer’s manual combined
volumes: 1, 2a, 2b, 2c, 3a, 3b and 3c, October 2011
14. Klein, G., et al.: seL4: formal veriﬁcation of an operating-system kernel. Commun.
ACM 53(6), 107–115 (2010)
15. Kornblum, J.: Fuzzy hashing and ssdeep (2010)
16. Kurmus, A., Dechand, S., Kapitza, R.: Quantiﬁable run-time kernel attack sur-
face reduction. In: Dietrich, S. (ed.) DIMVA 2014. LNCS, vol. 8550, pp. 212–234.
Springer, Cham (2014). https://doi.org/10.1007/978-3-319-08509-8 12
17. Kurmus, A., Sorniotti, A., Kapitza, R.: Attack surface reduction for commodity
OS kernels: trimmed garden plants may attract less bugs. In: Proceedings of the
Fourth European Workshop on System Security. ACM (2011)
18. Kurmus, A., et al.: Attack surface metrics and automated compile-time OS kernel
tailoring. In: Proceedings of the 20th Annual Network and Distributed System
Security Symposium, NDSS 2013 (2013)
19. Li, Y., Dolan-Gavitt, B., Weber, S., Cappos, J.: Lock-in-Pop: securing privileged
operating system kernels by keeping on the beaten path. In: USENIX Annual
Technical Conference, pp. 1–13. USENIX Association (2017)
20. Madhavapeddy, A., et al.: Unikernels: library operating systems for the cloud. In:
ACM SIGPLAN Notices, vol. 48, pp. 461–472. ACM (2013)
21. Mao, Y., Chen, H., Zhou, D., Wang, X., Zeldovich, N., Kaashoek, M.F.: Software
fault isolation with API integrity and multi-principal modules. In: Proceedings of
the Twenty-Third ACM Symposium on Operating Systems Principles, pp. 115–
128. ACM (2011)
710
Z. Zhang et al.
22. Michal, Z., Niels, H., Sebastian, R. (2010). https://code.google.com/archive/p/
skipﬁsh
23. Mosberger, D., Jin, T.: Httperf - a tool for measuring web server performance.
SIGMETRICS Perform. Eval. Rev. 26(3), 31–37 (1998)
24. Nguyen, A., Raj, H., Rayanchu, S., Saroiu, S., Wolman, A.: Delusional boot: secur-
ing hypervisors without massive re-engineering. In: Proceedings of the 7th ACM
European Conference on Computer Systems, EuroSys 2012, pp. 141–154 (2012)
25. Riley, R., Jiang, X., Xu, D.: Guest-transparent prevention of kernel rootkits with
VMM-based memory shadowing. In: Lippmann, R., Kirda, E., Trachtenberg, A.
(eds.) RAID 2008. LNCS, vol. 5230, pp. 1–20. Springer, Heidelberg (2008). https://
doi.org/10.1007/978-3-540-87403-4 1
26. Seccomp (2005). https://lwn.net/Articles/332974
27. Seshadri, A., Luk, M., Qu, N., Perrig, A.: SecVisor: a tiny hypervisor to provide
lifetime kernel code integrity for commodity OSES. In: ACM SIGOPS Operating
Systems Review, vol. 41, pp. 335–350. ACM (2007)
28. Smalley, S., Vance, C., Salamon, W.: Implementing SELinux as a linux security
module. NAI Labs Rep. 1(43), 139 (2001)
29. Standard Performance Evaluation Inc.: SPECint (2006). http://www.spec.org
30. Sullo, C. (2012). https://cirt.net/nikto
31. Swift, M.M., Martin, S., Levy, H.M., Eggers, S.J.: Nooks: an architecture for reli-
able device drivers. In: Proceedings of the 10th Workshop on ACM SIGOPS Euro-
pean Workshop, pp. 102–107. ACM (2002)
32. Szefer, J., Keller, E., Lee, R.B., Rexford, J.: Eliminating the hypervisor attack
surface for a more secure cloud. In: Proceedings of the 18th ACM Conference on
Computer and Communications Security, CCS 2011, pp. 401–412 (2011)
33. Tartler, R., et al.: Automatic OS kernel TCB reduction by leveraging compile-
time conﬁgurability. In: Proceedings of the 8th Workshop on Hot Topics in System
Dependability, p. 3 (2012)
34. Wang, Z., Jiang, X.: HyperSafe: a lightweight approach to provide lifetime hypervi-
sor control-ﬂow integrity. In: Proceedings of the 2010 IEEE Symposium on Security
and Privacy, SP 2010, pp. 380–395 (2010)
35. Wang, Z., Wu, C., Grace, M., Jiang, X.: Isolating commodity hosted hypervisors
with hyperlock. In: Proceedings of the 7th ACM European Conference on Com-
puter Systems, EuroSys 2012, pp. 127–140 (2012)