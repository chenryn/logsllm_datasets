# 接口     https://time.geekbang.org/sendcoin    
# 参数    
## 目标用户    user    
## 目标金额    number有了上面的转账接口，我们就可以来模拟 CSRF攻击了。 1. 自动发起 Get 请求黑客最容易实施的攻击方式是自动发起 Get请求，具体攻击方式你可以参考下面这段代码：                        黑客的站点：CSRF 攻击演示                   这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在img标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起img的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的100极客币就被转移到黑客的账户上去了。 2. 自动发起 POST 请求除了自动发送 Get 请求之外，有些服务器的接口是使用 POST方法的，所以黑客还需要在他的站点上伪造 POST请求，当用户打开黑客的站点时，是自动提交 POST请求，具体的方式你可以参考下面示例代码：                    黑客的站点：CSRF 攻击演示                                           在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点POST 数据提交。 3. 引诱用户点击链接除了自动发起 Get 和 Post请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：                            点击下载美女照片          这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。 以上三种就是黑客经常采用的攻击方式。如果当用户登录了极客时间，以上三种CSRF攻击方式中的任何一种发生时，那么服务器都会将一定金额的极客币发送到黑客账户。 到这里，相信你已经知道什么是 CSRF攻击了。 **和 XSS不同的是，CSRF攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击**。 如何防止 CSRF 攻击了解了 CSRF 攻击的一些手段之后，我们再来看看 CSRF攻击的一些"特征"，然后根据这些"特征"分析下如何防止 CSRF攻击。下面是我总结的发起 CSRF攻击的三个必要条件： 1.  第一个，目标站点一定要有 CSRF    漏洞；    2.  第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；        3.  第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。        满足以上三个条件之后，黑客就可以对用户进行 CSRF攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于CSRF攻击我们主要的防护手段是提升服务器的安全性。 要让服务器避免遭受到 CSRF攻击，通常有以下几种途径。 1. 充分利用好 Cookie 的 SameSite 属性通过上面的介绍，相信你已经知道了黑客会利用用户的登录状态来发起 CSRF攻击，而 **Cookie正是浏览器和服务器之间维护登录状态的一个关键数据**，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie上来做文章。 通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie的发送，因此在浏览器通过不同来源发送 HTTP请求时，有如下区别： 1.  如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键    Cookie 数据到服务器；        2.  如果是同一个站点发起的请求，那么就需要保证 Cookie    数据正常发送。        而我们要聊的 Cookie 中的 SameSite属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF攻击的风险。 那 SameSite 是怎么防止 CSRF攻击的呢？ 在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上SameSite 选项，如下：     set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none**SameSite 选项通常有 Strict、Lax 和 None三个值。** 1.  Strict 最为严格。如果 SameSite 的值是    Strict，那么浏览器会完全禁止第三方    Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ    的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie    是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ    的资源时，才会带上这些    Cookie。    2.  Lax    相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交    Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用    Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带    Cookie。    3.  而如果使用 None 的话，在任何情况下都会发送 Cookie    数据。    关于 SameSite的具体使用方式，你可以参考这个链接：https://web.dev/samesite-cookies-explained。 对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie就不会被发送到服务器，从而使得黑客的 CSRF攻击失效。 2. 验证请求的来源站点接着我们再来了解另外一种防止 CSRF攻击的策略，那就是**在服务器端验证请求来源的站点**。由于 CSRF攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？ 这就需要介绍 HTTP 请求头中的 Referer 和 Origin属性了。 **Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP请求的来源地址**。比如我从极客时间的官网打开了 InfoQ 的站点，那么请求头中的Referer 值是极客时间的URL，如下图： ![](Images/ae9dc42beac0eee3ead7c32f22951bd2.png)savepage-src="https://static001.geekbang.org/resource/image/15/c9/159430e9d15cb7bcfa4fd014da31a2c9.png"}HTTP 请求头中的 Referer 引用slate-object="mark"} 虽然可以通过 Referer 告诉服务器 HTTP请求的来源，但是有一些场景是不适合将来源 URL暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer值，具体可参考**ReferrerPolicy**。 但在服务器端验证请求头中的 Referer并不是太可靠，因此标准委员会又制定了**Origin 属性**，在一些重要的场合，比如通过 XMLHttpRequest、Fecth发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin属性，如下图： ![](Images/d30022989ee1254a1c55522f15be9368.png)savepage-src="https://static001.geekbang.org/resource/image/25/03/258dc5542db8961aaa23ec0c02030003.png"}Post 请求时的 Origin 信息slate-object="mark"} 从上图可以看出，Origin 属性只包含了域名信息，并没有包含具体的 URL路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。 因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin属性，再根据实际情况判断是否使用 Referer值。 3. CSRF Token除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token来验证，这个流程比较好理解，大致分为两步。 第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRFToken其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：                                                                             第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRFToken，然后服务器会验证该 Token是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token的值，所以即使发出了请求，服务器也会因为 CSRF Token不正确而拒绝请求。 总结好了，今天我们就介绍到这里，下面我来总结下本文的主要内容。 我们结合一个实际案例介绍了 CSRF 攻击，要发起 CSRF攻击需要具备三个条件：目标站点存在漏洞、用户要登录过目标站点和黑客需要通过第三方站点发起攻击。 根据这三个必要条件，我们又介绍了该如何防止 CSRF攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite属性、验证请求的来源站点和使用 CSRFToken。这三种方式需要合理搭配使用，这样才可以有效地防止 CSRF攻击。 再结合前面两篇文章，我们可以得出页面安全问题的主要原因就是浏览器为同源策略开的两个"后门"：一个是在页面中可以任意引用第三方资源，另外一个是通过CORS 策略让 XMLHttpRequest 和 Fetch去跨域请求资源。 为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键Cookie，引入了 SameSite 和 Origin 来防止 CSRF攻击。 通过这三篇文章的分析，相信你应该已经能搭建**Web 页面安全**的知识体系网络了。有了这张网络，你就可以将 HTTP请求头和响应头中各种安全相关的字段关联起来，比如 Cookie中的一些字段，还有X-Frame-Options、X-Content-Type-Options、X-XSS-Protection等字段，也可以将 CSP、CORS这些知识点关联起来。当然这些并不是浏览器安全的全部，后面两篇文章我们还会介绍**浏览器系统安全**和**浏览器网络安全**两大块的内容，这对于你学习浏览器安全来说也是至关重要的。 思考题今天留给你的思考题：什么是 CSRF 攻击？在开发项目过程中应该如何防御CSRF 攻击？ 欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。 ![](Images/7e91bd5c116048de87e68468f727fc3c.png)savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 35 \| 安全沙箱：页面和系统之间的隔离墙前面三篇文章我们主要围绕同源策略介绍了 Web页面安全的相关内容，那今天我们把视野向外延伸，来聊聊页面安全和操作系统安全之间的关系。在 [《01 \| Chrome架构：仅仅打开了 1 个页面，为什么有 4个进程？》  slate-object="inline"那篇文章中，我们分析了浏览器架构的发展史，在最开始的阶段，浏览器是单进程的，这意味着渲染过程、JavaScript执行过程、网络加载过程、UI绘制过程和页面显示过程等都是在同一个进程中执行的，这种结构虽然简单，但是也带来了很多问题。**从稳定性视角来看，单进程架构的浏览器是不稳定的**，因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器，如页面卡死、浏览器崩溃等。不过浏览器的稳定性并不是本文讨论的重点，我们今天主要聊的是**浏览器架构是如何影响到操作系统安全的**。浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用**缓冲区溢出**，不过需要**注意这种类型的攻击和 XSS注入的脚本是不一样的**。1.  XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些    Cookie 相关的数据，但是 XSS    无法对操作系统进行攻击。        2.  而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。        和 XSS攻击页面相比，这类攻击无疑是枚"核弹"，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。安全视角下的多进程架构现代浏览器的设计目标是**安全、快速**和**稳定**，而这种核弹级杀伤力的安全问题就是一个很大的潜在威胁，因此在设计现代浏览器的体系架构时，需要解决这个问题。我们知道现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离，完整的进程架构我们已经在《01 \| Chrome 架构：仅仅打开了 1 个页面，为什么有 4个进程？》  slate-object="inline"那篇文章中介绍过了，这里我就不重复介绍了。下面我们重点从操作系统安全的视角来看看浏览器的多进程架构，如下图：![](Images/6d218811a6aef6f2cc6f76bcc6ebadbb.png)savepage-src="https://static001.geekbang.org/resource/image/b8/b1/b83693a1ace43f43f9cab242982de6b1.png"}浏览器内核和渲染进程slate-object="mark"}观察上图，我们知道浏览器被划分为**浏览器内核**和**渲染内核**两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和GPU进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。在 [《01 \| Chrome架构：仅仅打开了 1 个页面，为什么有 4个进程？》  slate-object="inline"中我们分析过，设计现代浏览器体系架构时，将浏览器划分为不同的进程是为了增加其稳定性。虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：1.  为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？        2.  为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC    通知浏览器内核模块，然后让浏览器内核去负责展示图片？        通过以上方式不是增加了工程的复杂度吗？要解释现代浏览器为什么要把这个流程弄得这么复杂，我们就得从系统安全的角度来分析。安全沙箱不过在解释这些问题之前，我们得先看看什么是安全沙箱。上面我们分析过了，由于渲染进程需要执行 DOM 解析、CSS解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。我们知道，如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析HTML、解析 CSS、执行JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。**将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱**。浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过IPC 转发给渲染进程。安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。安全沙箱如何影响各个模块功能我们知道安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用GPU 接口等。了解了被安全沙箱保护的进程会有一系列的受限操作之后，接下来我们就可以分析渲染进程和浏览器内核各自都有哪些职责，如下图：![](Images/4dcbf3dab70fcf6a2f23f38a39d69e32.png)savepage-src="https://static001.geekbang.org/resource/image/f8/1b/f8cc6394832ed238f18a01eff5726f1b.png"}浏览器内核和渲染进程各自职责slate-object="mark"}通过该图，我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。那安全沙箱是如何影响到各个模块功能的呢？1. 持久存储我们先来看看安全沙箱是如何影响到浏览器持久存储的。由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问Cookie的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过IPC 将操作结果转发给渲染进程。具体地讲，如下文件内容的读写都是在浏览器内核中完成的：1.  存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie    的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie    时，渲染进程会通过 IPC 将读取 Cookie    的信息发送给浏览器内核，浏览器内核读取 Cookie    之后再将内容返回给渲染进程。        2.  一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。        2. 网络访问同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS的站点中是否包含了 HTTP的请求。 3. 用户交互渲染进程实现了安全沙箱，还影响到了一个非常重要的用户交互功能。通常情况下，如果你要实现一个 UI程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window统称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。由于渲染进程不能直接访问**窗口句柄**，所以渲染进程需要完成以下两点大的改变。第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过IPC 将这些事件发送给渲染进程。上面我们分析了由于渲染进程引入了安全沙箱，所以浏览器的持久存储、网络访问和用户交互等功能都不能在渲染进程内直接使用了，因此我们需要把这些功能迁移到浏览器内核中去实现，这让原本比较简单的流程变得复杂了。理解这些限制，我们就能解释开始提出的两个问题了。站点隔离（Site Isolation）所谓站点隔离是指 Chrome将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。最开始 Chrome划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个iframe，而这些 iframe又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe同时运行在同一个渲染进程中。目前所有操作系统都面临着两个 A级漏洞------幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe利用这两个 A级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome中的站点隔离。实现了站点隔离，就可以将恶意的 iframe隔离在恶意进程内部，使得它无法继续访问其他 iframe进程的内容，因此也就无法攻击其他站点了。值得注意是，2019 年 10 月 20 日 Chrome 团队宣布安卓版的 Chrome已经全面支持站点隔离，你可以参考文中链接slate-object="inline"。总结好了，今天的内容就介绍到这里，下面我来总结下本文的主要内容。首先我们分析了单进程浏览器在系统安全方面的不足，如果浏览器存在漏洞，那么黑客就有机会通过页面对系统发起攻击。因此在设计现代浏览器的体系架构时，就考虑到这个问题了。于是，在多进程的基础之上引入了安全沙箱，有了安全沙箱，就可以将操作系统和渲染进程进行隔离，这样即便渲染进程由于漏洞被攻击，也不会影响到操作系统的。由于渲染进程采用了安全沙箱，所以在渲染进程内部不能与操作系统直接交互，于是就在浏览器内核中实现了持久存储、网络访问和用户交互等一系列与操作系统交互的功能，然后通过IPC 和渲染进程进行交互。最后我们还分析了 Chrome中最新的站点隔离功能。由于最初都是按照标签页来划分渲染进程的，所以如果一个标签页里面有多个不同源的iframe，那么这些 iframe也会被分配到同一个渲染进程中，这样就很容易让黑客通过 iframe来攻击当前渲染进程。而站点隔离会将不同源的 iframe分配到不同的渲染进程中，这样即使黑客攻击恶意 iframe的渲染进程，也不会影响到其他渲染进程的。今天介绍的内容和概念都比较多，看上去离前端比较远，不过这些内容会影响你对浏览器整体架构的理解，而深入理解了浏览器架构能帮助你更加深刻地理解前端内容。为了方便你的理解，我把一些参考资料放到了文章的最后，有需要的话你可以拿来参考。思考时间今天留给你的思考题：你认为安全沙箱能防止 XSS 或者 CSRF一类的攻击的吗？为什么？欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。参考资料1.       安全沙箱的设计参考了        [最小权限原则            2.       [The Security Architecture of the Chromium    Browser         3.       [The Security Architecture of the Chromium    Browser-ppt            4.       [chromium site-isolation            5.       [Site Isolation            6.       [Site Isolation: Process Separation for Web Sites within the    Browser         ![](Images/7e91bd5c116048de87e68468f727fc3c.png)savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 36 \| HTTPS：让数据传输更安全浏览器安全主要划分为三大块内容：页面安全、系统安全和网络安全。前面我们用四篇文章介绍了页面安全和系统安全，也聊了浏览器和Web开发者是如何应对各种类型的攻击，本文是我们专栏的最后一篇，我们就接着来聊聊网络安全协议HTTPS。 我们先从 HTTP的明文传输的特性讲起，在上一个模块的三篇文章中我们分析过，起初设计 HTTP协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以HTTP一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中，如下图：![](Images/2c8cb1b4aadb46bf18b1db910aa237f3.png)savepage-src="https://static001.geekbang.org/resource/image/11/e2/118ced11537bd1e257f8df09380f33e2.png"}中间人攻击slate-object="mark"}从上图可以看出，我们使用 HTTP传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为**中间人攻击**。具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的HTTP 请求的内容。或者用户一不小心连接上了 WiFi钓鱼路由器，那么数据也都能被黑客抓取或篡改。在 HTTP 协议栈中引入安全层鉴于 HTTP的明文传输使得传输过程毫无安全性可言，且制约了网上购物、在线转账等一系列场景应用，于是倒逼着我们要引入**加密方案**。从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP之间插入一个安全层，所有经过安全层的数据都会被加密或者解密，你可以参考下图：![](Images/b32edb4fc06441017e6db1b326aff2f4.png)savepage-src="https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png"}HTTP VS HTTPSslate-object="mark"}从图中我们可以看出 HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS所有的安全核心都在安全层，它不会影响到上面的 HTTP协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS是如何工作的，就要弄清楚安全层是怎么工作的。总的来说，安全层有两个主要的职责：**对发起 HTTP请求的数据进行加密操作**和**对接收到 HTTP的内容进行解密操作**。我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的HTTPS 协议。第一版：使用对称加密提到加密，最简单的方式是使用对称加密。所谓**对称加密是指加密和解密都使用的是相同的密钥**。了解了对称加密，下面我们就使用对称加密来实现第一版的HTTPS。 要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在HTTPS发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：![](Images/ac4f79c1e8261e5a4812cc585a4de8dd.png)savepage-src="https://static001.geekbang.org/resource/image/d8/3b/d86648267d5504c7813b2d692620503b.png"}使用对称加密实现 HTTPSslate-object="mark"}通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：1.  浏览器发送它所支持的加密套件列表和一个随机数    client-random，这里的        **加密套件是指加密的方法**        ，加密套件列表就是指浏览器能支持多少种加密方法列表。        2.  服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数    service-random，并将 service-random    和加密套件列表返回给浏览器。        3.  最后浏览器和服务器分别返回确认消息。        这样浏览器端和服务器端都有相同的 client-random 和 service-random了，然后它们再使用相同的方法将 client-random 和 service-random混合起来生成一个密钥 master secret，有了密钥 master secret和加密套件之后，双方就可以进行数据的加密传输了。通过将对称加密应用在安全层上，我们实现了第一个版本的HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和service-random的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。第二版：使用非对称加密不过非对称加密能够解决这个问题，因此接下来我们就利用非对称加密来实现我们第二版的HTTPS，不过在讨论具体的实现之前，我们先看看什么是非对称加密。和对称加密只有一个密钥不同，**非对称加密算法有 A、B 两把密钥，如果你用 A密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B密钥来加密，那么只能用 A密钥来解密**。在 HTTPS中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为**公钥**，服务器自己留下的那个密钥称为**私钥**。顾名思义，**公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开**。下图是使用非对称加密改造的 HTTPS协议： ![](Images/8bc65e9ae879d82478a777ba03734334.png)savepage-src="https://static001.geekbang.org/resource/image/b2/50/b2b893921491c62b29aaddc1d4fa9550.png"}非对称加密实现 HTTPSslate-object="mark"}根据该图，我们来分析下使用非对称加密的请求流程。1.  首先浏览器还是发送加密套件列表给服务器。        2.  然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密    HTTP    数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。        3.  最后就是浏览器和服务器返回确认消息。        这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种方式依然存在两个严重的问题。1.  **第一个是非对称加密的效率太低**        。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。        2.  **第二个是无法保证服务器发送给浏览器的数据安全**        。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。        第三版：对称加密和非对称加密搭配使用基于以上两点原因，我们最终选择了一个更加完美的方案，那就是**在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输**。下图就是改造后的版本：![](Images/6fa6665ac756f3b4288aa78b392adeb6.png)savepage-src="https://static001.geekbang.org/resource/image/b5/ac/b5bffdc1dd47cb1fa2180c62ae9c77ac.png"}混合加密实现 HTTPSslate-object="mark"}从图中可以看出，改造后的流程是这样的：1.  首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数    client-random；        2.  服务器保存随机数    client-random，选择对称加密和非对称加密的套件，然后生成随机数    service-random，向浏览器发送选择的加密套件、service-random    和公钥；        3.  浏览器保存公钥，并利用 client-random 和 service-random 计算出来    pre-master，然后利用公钥对 pre-master    加密，并向服务器发送加密后的数据；        4.  最后服务器拿出自己的私钥，解密出 pre-master    数据，并返回确认消息。        到此为止，服务器和浏览器就有了共同的 client-random、service-random 和pre-master，然后服务器和浏览器会使用这三组随机数生成**对称密钥**，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。需要特别注意的一点，**pre-master 是经过公钥加密之后传输的，所以黑客无法获取到pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了**。第四版：添加数字证书通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开极客时间的官网，但是黑客通过DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。所以我们还需要服务器向浏览器提供证明"我就是我"，那怎么证明呢？这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个**权威机构**，并通过这个权威机构给你颁发一个**证书**：房产证。同理，极客时间要证明这个服务器就是极客时间的，也需要使用权威机构颁发的证书，这个权威机构称为**CA（CertificateAuthority）**，颁发的证书就称为**数字证书（DigitalCertificate)**。对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。接下来我们看看含有数字证书的 HTTPS的请求流程，你可以参考下图：![](Images/cf33892113a56a560b849f10cd2e7a40.png)savepage-src="https://static001.geekbang.org/resource/image/f5/f8/f509dedc99e740e57ff2c9d5cc8478f8.png"}完整的 HTTPS 请求流程slate-object="mark"}相较于第三版的 HTTPS协议，这里主要有两点改变：1.       服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；        2.       在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。        通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。数字证书的申请和验证通过上面四个版本的迭代，我们实现了目前的 HTTPS架构。 在第四版的 HTTPS中，我们提到过，有了数字证书，黑客就无法欺骗用户了，不过我们并没有解释清楚如何通过数字证书来证明用户身份，所以接下来我们再来把这个问题解释清楚。如何申请数字证书我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA去申请数字证书，通常的申请流程分以下几步：1.  首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；        2.  然后极客时间向 CA    机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；        3.  CA    通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；        4.  如信息审核通过，CA    会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA    的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA    生成的签名。        这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先CA 使用 **Hash函数**来计算极客时间提交的明文信息，并得出**信息摘要**；然后 CA再使用它的私钥对信息摘要进行加密，**加密后的密文就是 CA颁给极客时间的数字签名**。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该CA 颁发的。 浏览器如何验证数字证书有了 CA签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用CA 签名时相同的 Hash函数来计算并得到**信息摘要 A**；然后再利用对应 CA的公钥解密签名数据，得到**信息摘要 B**；对比信息摘要 A 和信息摘要B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。这时候相当于验证了 CA 是谁，但是这个 CA可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA颁发证书的 CA，再以同样的方式验证它上级 CA的可靠性。通常情况下，操作系统中会内置信任的顶级 CA的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的CA，证书也会被判定非法。另外，在申请和使用证书的过程中，还需要注意以下三点：1.       申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；        2.       数字证书最核心的是 CA    使用它的私钥生成的数字签名；        3.       内置 CA    对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。        总结好了，今天就介绍到这里，下面我来总结下本文的主要内容。由于 HTTP的明文传输特性，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这倒逼着我们需要引入加密机制。于是我们在HTTP 协议栈的 TCP 和 HTTP层之间插入了一个安全层，负责数据的加密和解密操作。我们使用对称加密实现了安全层，但是由于对称加密的密钥需要明文传输，所以我们又将对称加密改造成了非对称加密。但是非对称加密效率低且不能加密服务器到浏览器端的数据，于是我们又继续改在安全层，采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，这样我们就解决传输效率和两端数据安全传输的问题。采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由CA签名过的，所以浏览器能够验证该证书的可靠性。另外百看不如一试，我建议你自己亲手搭建一个 HTTPS 的站点，可以去freeSSL申请免费证书。链接我已经放在文中了：1.  中文：        [https://freessl.cn/            2.  英文：        [https://www.freessl.com/            思考时间今天留给你的作业：结合前面的文章以及本文，你来总结一下 HTTPS的握手过程。欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png)savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}