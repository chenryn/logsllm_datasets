3248
3342
2433
1393
1682
1416
31778
12953
10111
12842
377
102
110
110
35983
13804
14888
17360
4552
3992
3719
3501
4991
4090
3425
3328
4801
3992
3593
4051
85386
66894
79581
78347
709
302
342
341
17155
12093
10863
12182
1324
16
23
22
27812
19086
18609
18401
16894
12398
11021
11141
1298
963
1096
1206
2638
1579
1805
1632
781
568
582
547
10935
8019
8640
8302
1506
213
268
266
636
298
322
413
1699
1548
1484
1381
5823
4891
4914
5112
188274 163097 271408
190607 168372
1% ↓
42% ↑
11% ↓
3393
5525
191
146
3844
1818
1491
1121
22597
12594
362
110
28797
14498
2298
3914
3956
2304
2638
4052
59616
71671
509
322
15682
12085
447
20
25621
20655
16771
14381
1081
721
1486
2482
586
587
10169
9509
1429
230
294
580
1039
1593
5691
4881
186213 209574
2% ↓
9% ↑
2973
132
2981
1552
11984
149
13172
3880
3243
4012
60348
323
10492
24
17707
12557
1184
1636
606
7040
365
300
1496
4941
14%↓
–
The ﬁrst six columns of Table 6 reveal the issue of the per-
formance variation in those base fuzzers, as they perform var-
iously on different applications. Comparing AFL family tools,
AFL performs better than the other two optimized fuzzers on
14 applications. Compared with AFL, libFuzzer performs bet-
ter on 15 applications, but worse on 9 applications. Radamsa
performs better on 8 applications, but also worse on 16 ap-
plications. QSYM performs better on 9 applications, but also
worse on 15 applications. Table 7 and Table 8 show similar
results on branch coverage and bugs.
From Table 6, it is interesting to see that compared with
those optimized fuzzers based on AFL (AFLFast, FairFuzz,
Radamsa and QSYM), original AFL performs the best on
14 applications in parallel mode with 4 CPU cores. For the
total number of paths executed, AFL performs the best and
AFLFast performs the worst in parallel mode. While in single
mode with one CPU core used, the situation is exactly the
opposite, and the original AFL only performs the best on 5
applications, as presented in Table 14 of the appendix.
The reason for performance degradation of these optimiza-
tions in parallel mode is that their studies lack the consider-
ation for synchronizing the additional guiding information.
Take AFLFast for example, it models coverage-based fuzzing
as Markov Chain, and the times of random mutation for each
seed will be computed by a power scheduler. This strategy
works well in single mode, but it would fail in parallel mode
because the statistics of each fuzzer’s scheduler are limited
in current thread. Our evaluation demonstrates that many op-
timized fuzzing strategies could be useful in single mode,
but fail in the parallel mode even if this is the mode widely
used in industry practice. This experiment has been missing
by many prior literature studies. A potential solution for this
degradation is to synchronize the additional guiding informa-
tion in their implementation, similar to the work presented in
PAFL [27].
Table 7: Average number of branches covered by each tool on
n Google’s fuzzer-test-suite for ten times.
Project
boringssl
c-ares
guetzli
lcms
libarchive
libssh
libxml2
openssl-1.0.1
openssl-1.0.2
openssl-1.1.0
pcre2
proj4
re2
woff2
freetype2
harfbuzz
json
libjpeg
libpng
llvm
openthread
sqlite
vorbis
wpantund
Total
Improvement
3635
276
2723
3681
9267
614
14845
3967
4004
9075
48004
267
17069
120
52404
36313
6622
11350
4393
56619
2959
2847
13524
40867
AFL AFLFast FairFuzz LibFuzzer Radamsa QSYM EnFuzz
4108
3863
3834
3680
285
285
285
202
4016
3644
3022
3011
4169
3985
3015
3731
13949
9416
8635
10580
636
573
614
614
21899
13346
15204
14747
4673
3715
4011
4032
4216
3923
4079
3892
9827
9125
9058
8712
53912
36539
50558
36208
907
798
267
261
19688
17918
16001
16323
3945
2785
120
121
58192
53339
57325
48547
44708
39712
38194
38163
7339
7169
6583
7048
17071
10342
12345
11468
4696
4003
4135
4085
62918
57021
55003
48008
5579
3109
5421
3634
3216
3123
2850
2853
14318
12849
10032
12136
43217
39816
40556
40667
322764 407090
352397 345445 360466 339501
3% ↑
8%↓
16% ↑
3880
285
3177
2857
11415
614
19865
4117
4074
9017
51881
267
17312
120
52715
37959
7231
12009
3961
54312
3102
3012
11234
40317
354733
0.6% ↓
3894
285
1514
3642
8646
614
14298
3996
4021
9123
49430
267
17360
120
56653
43077
5138
15688
4110
58306
2989
2838
13053
41404
2% ↓
–
1% ↓
Table 8: Average number of unique bugs found by each tool
on n Google’s fuzzer-test-suite for ten times.
Project
boringssl
c-ares
guetzli
lcms
libarchive
libssh
libxml2
openssl-1.0.1
openssl-1.0.2
openssl-1.1.0
pcre2
proj4
re2
woff2
freetype2
harfbuzz
json
libjpeg
libpng
llvm
openthread
sqlite
vorbis
wpantund
Total
Improvement
AFL AFLFast FairFuzz LibFuzzer Radamsa QSYM EnFuzz
1
3
1
2
1
2
3
4
6
6
8
3
2
1
0
1
3
0
0
2
4
3
4
0
60
76% ↑
0
3
0
1
0
0
1
3
4
5
5
1
1
0
0
1
0
0
0
2
0
0
3
0
30
12% ↑
0
2
0
1
0
0
1
2
4
5