  1. 手机以 DFU 模式开机后，负责处理 USB 的主模块会先调用`usb_dfu_init()`函数，初始化 DFU 子模块。初始化过程主要做两件事：
    1. 分配一块 2048 字节的内存作为缓冲区，我们叫它`io_buffer`。
    2. 把 DFU 事件处理函数提交给 USB 驱动 ，等待用户发来的 DFU 请求。
  2. 当用户想要加载临时系统时，会先发送一个`DFU_DNLOAD`请求。主模块将它转发给 DFU 事件处理函数。
  3. DFU 检查这个请求，如果用户想要发来一段长度为`wLength`的数据，那么 DFU 将会检查`wLength`是否超过 2048 字节。
    * 超过的话，发送一个 STALL 包掐断 USB 会话，向主模块返回-1。
    * 不超过的话，用指针将 **`io_buffer`传递给一个全局变量** ，向主模块返回`wLength`。
  4. 主模块把`wLength`等信息记录到另一个全局变量中，为接下来接收数据做好准备。
  5. 用户接下来将数据陆续发送给主模块，主模块将这些数据复制到`io_buffer`中。等到所有的数据都接收完毕后，主模块通知 DFU 模块处理这些数据。
  6. DFU 模块拿到`io_buffer`，确认里面数据的长度确实是用户刚开始允诺的`wLength`，然后将这些数据复制到临时系统的加载地址，比如`0x18001C000`（iPhone 8/X）。
  7. 缓冲区数据处理完毕之后，主模块 **清空之前的所有全局变量** ，准备接受下一个 USB 请求。
  8. 当用户分批发送完临时系统的所有内容后，会发送一个`DFU_DONE`请求。主模块将它转发给 DFU ，通知 DFU 开机，于是 DFU 模块 **释放掉`io_buffer`** ，尝试开机。如果开机失败，再次执行`usb_dfu_init()`，开始第二轮 DFU 启动。
有了我加黑标粗的几个关键点，有人也许已经能看出来这次漏洞的原理了。
第3步 DFU 将`io_buffer`地址记录到了一个全局变量里，如果用户接着发送一个`DFU_DONE`请求的话，5~7步就会被直接跳过。第8步 DFU
释放掉`io_buffer`这块内存，开机失败跳回到第1步，开始第二轮 DFU 启动。
**这时之前那个全局变量记录的，还是已经释放掉的`io_buffer`，这就构成了一个 Use-After-Free 漏洞。**
在这个 UAF 漏洞的基础上，只要找到一个合适的攻击目标，用堆风水引导 malloc
把攻击目标分配到`io_buffer`上，就能通过写`io_buffer`修改这个攻击目标的内容了。
说到这里，我忍不住想说句八卦。 littlelailo 在推特上抱怨说，自己早在今年3月就发现了 checkm8 漏洞，但由于他只攻破了 A8 和 A9
处理器，所以就没掀起什么波澜。我没看过他的攻击代码，不知道跟 ani0mX
的代码比起来到底差了哪里。但既然大家原理一模一样，那搞不好就是堆风水的时候出了差别。由此可见，玩风水的造诣确实是能决定一个黑客的运势，古人诚不欺我啊。
最后，给想要自己逆向的读者指个路吧。在 iPhone 8 / iPhone X 的 ROM 中，几个关键函数的位置分别位于：
  * USB 主模块代码：`0x10000B24C`
  * DFU 请求处理代码：`0x10000BCCC`
  * DFU 数据处理代码：`0x10000BEF4`
* * *
## 0x03 构建ROP
这一节我其实本来想顺着聊聊 checkm8 里面堆风水的处理的，然而由于我这篇文章写得三天打鱼两天晒网，所以写到这里的时候外网已经有人发文章详细讨论过
checkm8 堆风水的处理了，还配了好看又细致的插图。那我觉得就没必要再写一遍了，反正也写不过人家，干脆直接贴个链接（[Technical
analysis of the checkm8
exploit](https://m.habr.com/en/company/dsec/blog/472762/)），然后往下跳到构建 ROP 的部分。
为了构建 ROP 调用链， ani0mX 盯上了一个名叫`usb_device_io_request`的数据结构。这个数据结构里面保存着发给 USB 驱动的
IO 请求，正常情况下，USB 驱动会挨个处理这些请求，完成数据收发。但是如果用户要求重置 USB 会话的话，驱动就会 **一口气清空所有请求** ，并且
**调用每个请求的回调函数** 。
通过逆向 iPhone 8 的 Secure ROM ，我整理出了这个请求的具体数据结构：
![struct
usb_device_io_request](https://images.seebug.org/content/images/2019/10/29/1572329501000-usb_device_io_request.png-w331s)
这个结构里面，我们主要看两个成员：
  * `next`指针，用来指向下一个要处理的请求对象，构成一串请求链表。
  * `callback`回调函数，虽然图里我把它标成一个`void *`，但它实际的类型是一个函数指针，`void (*callback) (struct usb_device_io_request *io_request)`。
整个攻击思路是这样的：
  1. 构建一串假的 IO 请求，让它们的`callback`依次指向我们想执行的 gadget 。
  2. 布置一套堆风水布局，操纵 malloc 把一个真请求放到我们掌控的`io_buffer`上。
  3. 向`io_buffer`写数据，把那串假请求写进内存，接到真请求的后面。
  4. 发送 USB reset 请求，重置会话，让 USB 驱动执行 ROP 链。
有了这套思路之后，剩下的就是选 gadget 之类的细节了，我们暂不赘述。至此，checkm8 的攻击原理已经算是基本揭露完了。
想要自己动手逆向本节内容的读者，我再给你们指个路吧。在iPhone 8 / X 的 Secure ROM 中，几个关键的函数分别位于：
  * USB 主模块 reset 请求处理函数：`0x10000B84C`
  * USB 驱动 reset 请求处理函数：`0x100004A44`
* * *
## 0x04 后记
从这次的 checkm8 漏洞里我们能学到什么？
首先，我觉得最重要的一点就是再次强调了那个业界共识：“ **保密不等于安全** ”。
当然啦，一定会有人反问我：苹果的这套保密体系不是效果很好吗？这么显眼的漏洞，将近十年都没被黑客发现啊？这还不够安全吗？
然而我们要注意一点， ROM 漏洞并不是将近十年 **没人发现** ，而是将近十年 **没人公布** ，这两字之差就是天壤之别。
在漏洞挖掘这个领域，大家所求的东西各不相同，但顶尖玩家一般就三种：有求名的，比如腾讯、360、知道创宇这些公司的实验室，需要 Apple、Google
时不时发感谢信来维护实验室的招牌。有求财的，比如 Zerodium 这些网络军火商，同样的漏洞苹果顶多悬赏 20~100
万美金，而这帮军火商开口就是150万美金，因为这些漏洞落到他们手里能变现出更大的利益。剩下一批顶尖玩家是各国的国家队，揣着明确的军事目标在挖掘漏洞。
当某个产品漏洞挖掘的门槛抬得过高时（比如 Secure
ROM），各家实验室会迫于经营压力/指标压力，转去寻找更好拿下的山头。整个赛场上就只剩下军火商和国家队，这两种人目标明确，苹果悬赏区区50万、100万根本打动不了他们，挖出的漏洞也就全被他们悄悄吞下来了。
所以对于大公司来说，最好的安全策略其实是拥抱透明，把求名的伙计们更多地拉下场，把愿意公布漏洞赚干净钱的白帽黑客拉下场。如果 Apple 采用这个战略的话，
checkm8 可能根本没机会发展成一个横跨7、8代苹果产品的史诗级漏洞，而是会在 iPhone 5、iPhone 6
发布的时候就被腾讯玄武实验室之类的白帽组织报了出来。然后苹果只要发发锦旗、奉上20万50万美元的赏金，事情就解决了，哪有今天这个尴尬局面？
其次，我觉得这个漏洞还说明了一点：对所有出现数据吞吐的地方，都应该进行细致的 fuzz 测试。
这次 checkm8 的成因，主要是对 USB 请求处理不当造成的 UAF 漏洞。个人感觉这个完全可以用 fuzz 检测出来啊？发完 setup 包之后跳过
data phase ，这个 ROM 程序应该就直接炸了啊？Secure ROM 作为安全启动链的起点，就算不做彻底的形式化验证， fuzz
也应该会做到位吧？感觉有点搞不懂苹果为什么在这里会漏下一个大坑漏了这么多年，感觉有点不可思议。
嘛，这次的文章就写到这里吧，正文有什么错误欢迎在评论区指正，就这样了。
* * *