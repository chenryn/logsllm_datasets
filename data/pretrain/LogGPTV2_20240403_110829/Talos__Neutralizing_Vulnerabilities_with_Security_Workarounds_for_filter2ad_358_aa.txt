title:Talos: Neutralizing Vulnerabilities with Security Workarounds for
Rapid Response
author:Zhen Huang and
Mariana D'Angelo and
Dhaval Miyani and
David Lie
2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy
Talos: Neutralizing Vulnerabilities with Security
Workarounds for Rapid Response
Zhen Huang
David Lie
{z.huang,mariana.dangelo,dhaval.miyani}@mail.utoronto.ca,PI:EMAIL
Mariana D’Angelo
University of Toronto
Dhaval Miyani
Abstract—There is often a considerable delay between the
discovery of a vulnerability and the issue of a patch. One way to
mitigate this window of vulnerability is to use a conﬁguration
workaround, which prevents the vulnerable code from being
executed at the cost of some lost functionality – but only if one
is available. Since application conﬁgurations are not speciﬁcally
designed to mitigate software vulnerabilities, we ﬁnd that they
only cover 25.2% of vulnerabilities.
To minimize patch delay vulnerabilities and address the
limitations of conﬁguration workarounds, we propose Security
Workarounds for Rapid Response (SWRRs), which are designed
to neutralize security vulnerabilities in a timely, secure, and un-
obtrusive manner. Similar to conﬁguration workarounds, SWRRs
neutralize vulnerabilities by preventing vulnerable code from
being executed at the cost of some lost functionality. However,
the key difference is that SWRRs use existing error-handling
code within applications, which enables them to be mechanically
inserted with minimal knowledge of the application and minimal
developer effort. This allows SWRRs to achieve high coverage
while still being fast and easy to deploy.
We have designed and implemented Talos, a system that
mechanically instruments SWRRs into a given application, and
evaluate it on ﬁve popular Linux server applications. We run ex-
ploits against 11 real-world software vulnerabilities and show that
SWRRs neutralize the vulnerabilities in all cases. Quantitative
measurements on 320 SWRRs indicate that SWRRs instrumented
by Talos can neutralize 75.1% of all potential vulnerabilities
and incur a loss of functionality similar to conﬁguration work-
arounds in 71.3% of those cases. Our overall conclusion is
that automatically generated SWRRs can safely mitigate 2.1×
more vulnerabilities, while only incurring a loss of functionality
comparable to that of traditional conﬁguration workarounds.
I. INTRODUCTION
Patches are the commonly-accepted solution for completely
preventing a security vulnerability from being exploited.
Patches ﬁx security vulnerabilities and, in most cases, do so
with no loss of functionality or performance for the applica-
tion. However, despite their beneﬁts, patches are not perfect.
An often ignored drawback of patches is the pre-patch
window of vulnerability that exists between the time a vul-
nerability is discovered and the time a patch is issued. This
vulnerability window is inherent to security patches because
patches must be manually created and tested, which takes
time and effort
to do correctly. Although a large number
of techniques have been proposed to automatically generate
patches to ﬁx vulnerabilities [31], [32], [39], [44], [48], [58],
[59], to the best of our knowledge, none have been widely
adopted in practice. As a recent study [49] and our own
ﬁndings in Section II demonstrate, the length of this window
2375-1207/16 $31.00 © 2016 IEEE
© 2016, Zhen Huang. Under license to IEEE.
DOI 10.1109/SP.2016.43
DOI 10.1109/SP.2016.43
618
618
Motivated by the problems of the pre-patch vulnerabil-
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:15:48 UTC from IEEE Xplore.  Restrictions apply. 
can be signiﬁcant, and is unlikely to decrease on average
due to the complexity of creating a security patch. While
the risk of exploitation during the pre-patch window can
be reduced by keeping the vulnerability secret, this is just
security-through-obscurity. As the highly active market of
zero-day vulnerabilities demonstrates, there is no shortage of
instances where attackers may be aware of and be able to
exploit vulnerabilities during this window [23].
While the period before a vulnerability is known can be
reduced by better vulnerability detection and software engi-
neering practices, we believe we can address the window of
vulnerability that exists between the time the vulnerability is
known to the developer (or to the public) and when the patch
is issued. To do this, we take inspiration from conﬁguration
workarounds, which are a commonly used mechanism to
address the pre-patch window of vulnerability. Conﬁguration
workarounds disable functionality related to the vulnerable
code so that it cannot be triggered by an attacker. For example,
the Android Stagefright bug, discovered in 2015, is a perfect
example of this. This remote code execution vulnerability,
which affected almost 1 billion devices, was discovered as
early as April 2015, although not publicly disclosed until July.
A patch was not available until August 2015, several months
after the vulnerability was discovered, and even at the time of
writing, many smartphones models still do not have a usable
patch [42], [43]. Fortunately, the worst methods of exploitation
via a malicious MMS can be prevented by conﬁguring the
MMS client on the phone to not automatically download media
ﬁles from MMS messages. In exchange for some minor loss of
functionality, the conﬁguration workaround protects the user
from the exploitation of a very serious vulnerability.
However, conﬁguration workarounds are far from ideal
for mitigating security vulnerabilities. Again, as we show
in Section II, conﬁguration workarounds have low coverage
– there are many vulnerabilities for which no conﬁguration
workaround exists because there is no conﬁguration option
that can disable the vulnerability. Conﬁguration options are
designed to allow users to easily alter the behaviour of a
program, and thus only cover functionality that most users
would like to enable or disable. Thus it is hardly surprising
that very few vulnerabilities have conﬁguration workarounds,
and it essentially becomes a matter of random serendipity
whether a vulnerability can be neutralized with a conﬁguration
workaround or not.
ity window and the low coverage of conﬁguration work-
arounds, we propose Security Workarounds for Rapid Re-
sponse (SWRRs), workarounds that can be mechanically gener-
ated to address a large percentage of vulnerabilities. The main
challenge in designing SWRRs is that they must work in a
broad range of circumstances. By their nature, vulnerabilities
are not known a priori, and thus SWRRs must work for
any vulnerability that can occur. Another challenge is that
vulnerabilities can occur anywhere in an application, and be
related to almost any type of functionality, but an SWRR
must ensure that the application continues to work after the
SWRR is applied. Thus, we design SWRRs to be simple
and generic, relying on very few assumptions about either
applications or vulnerabilities. The cost of this generality is
that, like conﬁguration workarounds, users must be willing to
accept some minor loss of functionality in return for protection
from a vulnerability until a patch is issued.
Our key insight for making SWRRs generic and cheap to
deploy is that application error-handling code, whose purpose
is to gracefully return an application to a good state when
an unexpected error arises, can be found and invoked using
static analysis. Based on this insight, we have designed and
implemented a system called Talos, which detects such error-
handling code using static analysis and adds SWRRs into a
given application. Each SWRR prevents the execution of code
where a vulnerability is located, and calls the error-handling
code instead. With Talos, developers can deploy SWRRs either
as patches or in-place as part of an application so that they
can be activated with run-time loadable conﬁgurations.
In summary, SWRRs provide beneﬁts for both software
developers and users at a small cost. For the cost of having to
run Talos and issue the resulting patch, software developers
beneﬁt by having a solution that protects their users; this
affords them more time and less immediate pressure to create,
test, and deploy a patch. Users beneﬁt by having a solution
that protects them during the pre-patch vulnerability window
at the cost of having to accept some loss of functionality.
In addition, in cases where users cannot install a patch for
compatibility reasons or where no patch exists because the
software is no longer supported, users can still use an SWRR
to protect themselves.
This paper makes the following contributions:
1) We propose SWRRs, which provide a low-cost way for
software developers to quickly protect users during the
pre-patch vulnerability window.
2) We design and implement a software tool called Talos
to demonstrate that SWRRs can be practically deployed.
To safely continue the execution of an application,
Talos heuristically identiﬁes error-handling code in the
program and transfers execution to those paths to avoid
having to execute vulnerable code.
3) We evaluate the effectiveness and coverage of
the
SWRRs inserted by Talos into 5 popular applications.
When tested against 11 vulnerabilities, SWRRs gener-
ated by Talos successfully neutralize the vulnerabilities
in all cases. Empirical
tests on 320 Talos-generated
TABLE I
SECURITY PATCH STATISTICS.
App.
lighttpd
apache
squid
proftpd
sqlite
AVERAGE
Vulns.
27
30
46
16
12
26
Delay (Days)
54
61
73
9
62
52
SLOC
49
47
64
95
17
54
Funcs
2
2
6
4
4
4
Files
2
2
3
2
3
2
SWRRs show that they can achieve an effective coverage
is 2.1× that of traditional conﬁguration work-
that
arounds.
We begin in Section II with a study based on data we
collected that demonstrates the motivation behind SWRRs.
Then we give an overview of SWRRs in Section III and
describe Talos, our tool for automatically inserting SWRRs
into application source code, in Section IV. We provide details
about the implementation of Talos in Section V. We then
evaluate the SWRRs that Talos instruments into applications
in Section VI. We discuss the limitations and other issues of
SWRRs in Section VII. We then provide a comparison with
related work in Section VIII and conclude in Section IX.
II. MOTIVATION
A. The pre-patch vulnerability window
We begin with a study of the lifecycle and complexity
of software patches for recent security vulnerabilities. The
vulnerabilities used in our study were collected from various
sources, including common vulnerability databases [6], [8],
[13], [17], vendor-speciﬁc security bulletins [2], [7], [12], and
software bug databases [5], [10], [16].
For our study, we need information on the disclosure date
of vulnerabilities, the release/commit date of patches, and the
source code of the patches. Hence we choose open-source
applications that are popular, reasonably complex, mature,
being actively developed and maintained, and have a decent
number of vulnerabilities. For each application, we selected
as many vulnerabilities as possible that have the required
information for manual examination. Our results are shown
in Table I. Column “Vulns.” shows the number of examined
vulnerabilities. Column “Delay” shows the average number
of days between the disclosure of security vulnerabilities and
the release of corresponding software patches. We obtain the
date when a vulnerability is disclosed from either an ofﬁcial
vulnerability disclosure or the bug report for the vulnerability.
For some vulnerabilities, we could not ﬁnd an ofﬁcial dis-
closure date, so we approximate this using the earliest dated
document in which they are referenced. From the collected
data, we can see that it takes considerable time to release
a patch and the size of the pre-patch vulnerability window is
signiﬁcant, averaging around 1.5 months after the vulnerability
is disclosed.
We ﬁnd that 43.4% of the vulnerabilities were patched
within 7 days after the vulnerabilities were disclosed, 23.3% of
619619
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:15:48 UTC from IEEE Xplore.  Restrictions apply. 
them were patched between 7 days and 30 days, and 33.3% of
them were patched after 30 days. Similarly, a recent study on
the lifecycle of security vulnerabilities in operating systems
and web browsers shows that among open source vendors,
65% of the vulnerabilities were patched within 7 days, 9%
of them were patched between 7 days and 30 days, and 18%
of them were patched after 30 days [49]. Both our study and
their study indicate that a signiﬁcant number of vulnerabilities
were patched after 30 days.
To understand the bottleneck in releasing a patch, we break
the task of releasing a patch into steps including vulnerability
triage, constructing a patch, and regression test. We study
the time spent in each step by examining the bug reports of
vulnerabilities. Unfortunately, we were only able to locate the
bug reports for 21 of the vulnerabilities that are shown in
Table I.
As most of these bug reports do not contain the time when
a developer was assigned or when a tester was assigned, we
conservatively assign the period of time between when the bug
is reported and when the ﬁrst patch attempt is created as the
time spent for vulnerability triage, the period of time between
when the ﬁrst patch attempt is created and when the last patch
attempt is created as the time spent to construct a patch, and
the period of time between when the last patch attempt is
created and when the patch is committed as the time spent for
regression test.
For these vulnerabilities, we ﬁnd that the time and effort
spent in constructing a patch is very signiﬁcant. For the 8
vulnerabilities that took more than one day to create a patch,
89% of the time was spent in constructing a patch. And 9 of the
vulnerabilities took between two to six attempts to patch cor-
rectly. Particularly the bug report of one proftpd vulnerability
(CVE-2012-6095 [4]) contains ﬁve patch attempts, of which
the last patch attempt was created 96 days after the ﬁrst patch
attempt was created, and 29 comments from the developer
and the testers, of which the comments from the developer
along the time line include “This updates the previous patch
...”, “This patch builds on the previous one ...”, “I’ve just
committed more changes ...”, “Hopefully the combination of ...
addresses the remaining issues.”, “Unfortunately I don’t have
a good/easy ﬁx/solution for this yet.”, and one of the very last
comments from the testers is still “I’m afraid I found a bug
in ...”.
To understand further why constructing a patch is non-
trivial, we further study the complexity of the patches, which
are available for all the vulnerabilities shown in Table I. We
use column “SLOC” to show the number of lines of source
code in patches, column “Funcs” to show the number of
functions that are changed by patches, and column “Files”
to show the number of source code ﬁles that are changed
by patches. We ﬁnd that on average patches consist of 54
lines of source code and span 4 functions in 2 source code
ﬁles. This suggests that on average, patches involve non-trivial
changes to the application code. As a result, the vulnerability
window is likely inherent to patches, as time must be spent by
human engineers to understand the vulnerability, design and
CONFIGURATION WORKAROUND STATISTICS.
TABLE II
Vulns. Workaround
App.
lighttpd
apache
squid
proftpd
IE