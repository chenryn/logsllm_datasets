steal the secret:
A: through dynamic property access (line 1),
B: using this, which resolves to global object (lines 2-5),
3Requires cross-origin resource sharing (CORS).
1
2
3
4
5
6
7
8
9
10
11
12
13
jate.enterContext("facebook.com");
var scope = jate.createScope("facebook.com");
try {
with (scope) {
var s = f u n c t i o n s () {
var stolen =processThis(this). d a t a . s e c r e t ;
};
var stolen = data [ " se " + " cret " ];
s () ;
stolen = d a t a . g e t S e c r e t () ;
eval (processEval(" stolen = t h i s . d a t a . s e c r e t "))
}
} finally { jate.exitContext(); }
Figure 3: Rewritten malicious “Like” script. Underlined
code segments are added by JaTE.
C: using a function deﬁned in ﬁrst-party code (line 6), and
D: by executing dynamic code (line 7).
Listing 3 shows the rewritten script, with the transforma-
tions underlined. First, we introduce a preamble to setup a
scope and enclose the original script using a with statement
(used to intercept free variable access). The script is then
transformed using three simple rules:
1. a global function declaration (e.g., function s) is turned
into variable declaration and assignment and moved to
the top of the script to simulate declaration hoisting,
2. this is replaced with processThis(this), and
3. direct eval is transformed to rewrite its argument before
evaluation.
Using these rules, JaTE is able to mediate all cross-compart-
ment accesses, even those from dynamic code.
Step (3) in Figure 1 shows the eﬀect of lines 2-4 from the
rewritten script: this setup creates a new compartment for
facebook.com. This compartment starts its life cycle with
only a mediated reference to window as a global object, but,
if permitted by the policy, it can obtain mediated references
to objects reachable by the original window. Mediation is
achieved using ECMAScript 6 Proxies, which enable trans-
parent interception of all operations on objects.
Compartments represent trust boundaries within the same
JavaScript execution environment: each party is conﬁned
within its own compartment (see Figure 1), and JaTE me-
diates all cross-compartment interactions. While the JaTE
framework itself is general enough to support mutually dis-
trusting ﬁrst- and third-parties, the threat model considered
in this paper is more limited: our goal is to (a) protect the
153
ﬁrst-party from third-party, and (b) if there are multiple
(mutually distrusting) third parties, then protect them from
each other. In this scenario, there is no need to transform
ﬁrst-party scripts, and hence the host compartment holds
an unmediated reference to window. Although the host code
does not run in a compartment set up by JaTE, it is helpful
to think of it as running in privileged compartment.
Step (4) in Figure 1 depicts the eﬀect of variable dec-
laration and assignment (lines 5 to 7) in Figure 3, which
was originally a function declaration (lines 2 to 4) in Figure
2. Note that the object s is unmediated in facebook.com’s
compartment because it is created by facebook.com. Step
(5) shows the eﬀect of line 8: the policy permits obtaining a
mediated reference to data, but does not allow reading the
value of secret (Step 6), which is a primitive value of type
String. This stops attack (A).
Line 9 is an unmediated function call. However, since
our transformation has rewritten the body of s, accesses to
this now return a reference to a mediated version of window.
When this mediated version is dereferenced, the policy once
again stops reading of secret, thus stopping attack (B).
Line 10 obtains a mediated reference to getSecret (Step
7) and performs a mediated cross-compartment function call,
which is denied by the policy, stopping attack (C).
Finally, line 11 evaluates the string after rewriting it just-
in-time. Note that the exact same technique of Step (2) is
applied again, using the same light-weight rewriting based
on lexical analysis. The rewritten code is:
s t o l e n = p r o c e s s T h i s ( this ) . d a t a . s e c r e t
This makes the attack semantically equivalent to the one on
line 6 (Figure 2), and hence attack (D) is also stopped.
4. DESIGN
This section presents the core mechanisms to implement
the compartment model for multiple mutually-distrusting
principals. Speciﬁcally, Sections 4.1 and 4.2 describe JaTE’s
compartments, while Section 4.3 describes the handling of
JavaScript’s challenging features outlined in Section 2. Fi-
nally, Section 4.4 addresses secure DOM access.
Our compartment design relies on Proxies, a feature of the
recently ﬁnalized ECMAScript 6 (ES 6) standard. A proxy
could be created for any object w as follows:
pw = new Proxy (w , { g e t : g e t H a n d l e r })
where getHandler is a function. A read operation pw.x will
invoke the function getHandler. This function can check
if the access should be permitted, and if so, invoke w.x. If
the policy check fails, the operation is not passed on to w,
but instead, our handler raises an exception. (Alternatively,
a safe default value can be returned, allowing the caller to
continue normally.) Thus pw behaves like w, while enabling
transparent interposition of policy checks before any access.
ES 6 deﬁnes several traps in addition to the get-trap illus-
trated above. These include the has trap (invoked to check if
an object possesses a certain property), the set trap (invoked
when a property is modiﬁed), and the call trap (invoked be-
fore calling a member function). Any subset of these trap
handlers can be speciﬁed in the second argument to Proxy.
4.1 Mediating global object access
Assuming that caller, this, native prototypes and DOM
are safely handled, the only way third-party code can access
the global object is through free variables, which are inter-
preted in JavaScript as accesses to properties of the global
object. We intercept all free variable accesses by exploiting
JavaScript’s dynamic nature: we construct a scope object
as shown in Figure 3, and enclose third-party code inside a
with (scope) { } block. This causes all free variable ac-
cesses in the enclosed code to be looked up on scope.
We construct scope to be a proxy object, and deﬁne its
has-trap so that it returns true. As a result, JavaScript run-
time never looks up any variable outside the with statement,
thwarting any attempt by third-party code to directly ac-
cess the global object. We also deﬁne the remaining traps of
scope so that it forwards these accesses to the virtual global
object, which is a proxy of the global object. This enables
all policy checks to be performed in the virtual global object.
While the discussion so far has considered accesses, dec-
larations require additional care:
• global variable declarations (var a): The with-statement
does not prevent enclosed code from declaring a as a prop-
erty of the global object. However, note that this decla-
ration has no eﬀect if a is already a property of the global
object. If not, it ends up declaring a new property with
the value undefined. Note that any subsequent access to
a will be intercepted by scope, so this declaration won’t
allow the enclosed code to bypass policy checks
• global variable declaration with initialization (var a = 1).
This case is treated by JavaScript as if it consisted of a
variable declaration, followed by an assignment. Since we
have already dealt with both statements, JaTE needs to
take no additional step for this case.
• global function declarations (function f() {}): We trans-
form this as var f = function f(){}, and move it to the
top of the script. This means function declarations get
handled in the same way as variable declarations.
.
4
4.2 Mediating cross-compartment accesses
In our construction, the ﬁrst-party (aka “host”) has direct
access to the global object, as well as most built-in objects.
We say that these objects are within the host compartment.
The third-party code, as discussed in the above construction,
starts its execution with just the virtual global object in its
compartment.
During execution, a principal can introduce new objects
into its compartment in two ways:
• It can create new objects. Ultimately, all object construc-
tion occurs using literals (e.g., []), or built-in construc-
tors (e.g., Array). We refer to these as direct objects, i.e.,
the principal’s accesses to these objects are not mediated.
Thus, JaTE introduces no additional overheads when a
principal accesses the objects it owns.
• The principal can import objects owned by other princi-
pals through interactions that get mediated in the follow-
ing proxy traps:
– get:
If a principal A reads a property of an object
owned by principal B, and the result is an object owned
by A, then a direct reference is returned. Otherwise, a
proxy for that object is created and returned to A.
4There is a possibility that ﬁrst party code will behave diﬀerently
based on the existence of property a, and in this case, third-
party can alter the behavior of ﬁrst-party code. We consider
this a side-channel that is unlikely to pose a security threat. A
safer alternative, however, would be to simply delete any var
declarations at the top level in the enclosed script.
154
– set: This is handled in a similar manner, except that
the direction of transfer is reversed in this case.
– call: A call can be treated as a switch from caller’s
to callee’s compartment, followed by get operations to
retrieve actual parameter values from the caller’s com-
partment. When the function returns, a switch back to
the caller’s compartment takes place, followed by a get
operation to retrieve the return value from the callee.
Note that all these operations are subject to the permissions
speciﬁed by the policy. In other words, the above behavior
would be observed with a default “allow all” policy, while a
more restrictive policy would deny some of these accesses.
Also note that other traps can be handled similarly, e.g.,
deleteProperty can be handled like the set trap.
Tracking current context. JaTE relies on the single-
threaded nature of JavaScript: the context can only explic-
itly switch in two ways, either at the beginning and at the
end of third-party code execution (handled by rewriting), or
during a cross-compartment function call (handled by the
call trap). In both cases, JaTE tracks the current context
by updating the property jate.currentContext.
Tracking object ownership. JaTE does not need to know
the owner of a direct object until it ﬁrst crosses a compart-
ment. When this happens, a proxy for the object is created,
and its owner is determined and stored for future use.
Cross-Compartment Exceptions. As a general rule, a
principal should always have direct access to its own ob-
jects, but only have proxies to the objects owned by other
principals. However, there are a few exceptions: (a) certain
built-in functions are frozen and always seen as direct to im-
prove performance, (b) certain objects such as DOM nodes
are always accessed via proxies, even by their owner, and
(c) for security reasons, even the host sees only proxies of
built-in constructors.
4.3 Handling JavaScript challenges
4.3.1 Handling this
JaTE replaces all occurrences of the this keyword with
processThis(this), where processThis returns the virtual
global object if this is the global object.
4.3.2 Handling caller
Note that it is not possible to statically recognize and
rewrite occurrences of caller: such an approach can be cir-
cumvented by obfuscation, e.g., f["c"+"aller"]. Moreover,
since caller is non-standard, we cannot rely on its “oﬃcial”
semantics either. Instead, we have developed a solution that
is based on how it has been implemented on major browsers,
including Chrome, Firefox, Safari, and Internet Explorer.
On these browsers, caller is not determined from a stack
frame, but simply has a single value that records the most
recent (and still active) caller of a function. As a result, if a
function f is recursive, after the ﬁrst recursive call, f.caller
becomes f. Hence
(f.caller). caller =
f. caller = f
In otherwords, regardless of how many times caller is in-
voked, it becomes impossible to get to the caller of the out-
ermost invocation of f.
JaTE relies on the above semantics of caller to ensure
that third-party code, when called by another principal X,
cannot reach X’s stack frames. To illustrate the approach,
suppose that g is a host function that needs to call a third-
party function h. Since this is a cross-compartment call,
it will go through a call-trap handler, which then calls a
function f deﬁned below:
var t =1;
f u n c t i o n f () { if ( t ) { t =0; f () ;} else h () ;}
When h tries to use caller to get to functions in the call
stack, it cannot get any further than f, hence it cannot get
to g.
4.3.3 Handling native prototypes
Intercepting native prototype accesses. JaTE lets prin-
cipals handle direct references to the objects they create.
However, a direct object contains references to the object’s
native prototype and its properties. Since native proto-
types are shared among all principals, JaTE must ensure
that third-party code does not obtain direct references to
them. The most natural way to achieve this is to set a native
prototype to a proxy. Unfortunately, all native prototypes
are non-conﬁgurable and non-writable, and so JaTE cannot
change them. For instance, Object.prototype cannot be
made to point to a proxy of the real prototype.
Instead,
it is necessary to intercept every possible way to get to a
native prototype, and at that point, return a proxy.
Native prototypes can be accessed through native con-
structors or __proto__. For example, native Array proto-
type can be accessed using Array.prototype or x.__proto__
(where x denotes any array value). Therefore, we ﬁrst re-
place native constructors with proxies. This is done for all
native constructors such as Object and Array. For instance,
Object is transformed as:
var o r i g O b j e c t = Ob j e c t ;
O b j e c t = j a t e . c r e a t e P r o x y ( o r i g O b j e c t ) ;
o r i g O b j e c t . p r o t o t y p e . c o n s t r u c t o r = O bj e ct ;
To handle __proto__, we replace __proto__’s built-in get-
ter. The new getter will return a proxy if it is one of the
native prototype objects.
Handling accesses to native prototype properties.
For performance reasons, we identiﬁed and white-listed na-
tive prototype functions that can be safely called directly
by any principal, e.g., prototype functions of Array, Object
and String. These functions are frozen to prevent mali-
, and
cious principals from replacing their implementations
then a direct reference to these functions is returned. For
functions determined unsafe (for direct calls from untrusted
code), only a proxy is returned. While performing this safety
analysis, we found a bug in V8’s Array prototype functions.
This bug, which led to a leak of the global object, was re-
ported [7] and promptly ﬁxed by Google.
5
For any property p that is newly added to native proto-
6
, JaTE instead stores a proxy to p. When the current
types
context is switched to a principal P , JaTE converts all prop-
erties added to native prototypes and owned by P to direct
references, while properties added or owned by other prin-
cipals are replaced by proxies. (We don’t have to do such
replacements for user-deﬁned prototypes because they are
5In theory, this can aﬀect transparency as it would break code
that attempts such replacement.
In practice, however, we ﬁnd
that overwriting of these built-in functions don’t seem to occur.
6Even though this is considered a bad practice, it seems to be
fairly common — our tests have shown that nearly half of the Top
500 websites extend native prototypes, perhaps because many of
them use the popular Prototype library.
155
// i n d i r e c t eval c a l l s
(1 , eval ) ( ' ... ' )
var e = eval; e ( ' ... ' ) ;
w i n d o w . e v a l ( ' ... ' )
this [ ' eval ' ]( ' ... ' )
// d i r e c t e va l c a l l s
eval ( ' ... ' )
( eval ) ( ' ... ' )
with ({ eval: eval }) eval ( ' ... ' )
Figure 4: Examples of direct and indirect eval’s.
already handled through proxies; it is the non-conﬁgurability
of native prototypes that necessitates this special handling.)
4.3.4 Handling eval
ECMAScript deﬁnes four constructs to execute dynamic
code: eval, Function, setTimeout and setInterval. Use
of eval can either be direct or indirect [2], as illustrated in
Figure 4 using examples. All of these instances of dynamic
code, with the exception of direct eval, are to be executed in
the global scope. JaTE wraps these instances using a func-
tion, while third-party code is given a proxy to this function.
At the call-trap of this proxy, we ﬁrst rewrite the code con-
tained in the string argument to perform the transformations
needed to ensure its safe execution. The rewritten string is
then evaluated within the compartment of the currently ex-
ecuting principal.
Direct eval cannot be handled this way since it should
not execute in the global scope, but in the same scope in
which it appears. Therefore, we cannot use the method
described above for handling indirect eval. We describe
correct handling of direct eval below. Our evaluation shows
that about 30.9% of Alexa top 500 websites use direct eval.
Almost all direct eval calls can be identiﬁed because they