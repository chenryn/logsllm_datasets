### SUSER、SUID和SHOME环境变量

SUSER、SUID和SHOME环境变量用于显示已登录用户的有关信息。例如，脚本输出如下：

```
Z18eq x+n powos
---
## Page 230
11.4 使用变量
215
-/test2
User info for userid: Samantha
HOME: /home/Samantha
UID: 1001
```

在脚本中，`echo`命令中的环境变量会在运行时替换成当前值。此外，在第一个字符串中可以将`$SUSER`系统变量放在双引号中，而Shell仍然能够正确解析。但这种方法也有问题。例如：

```sh
$ echo "The cost of the item is $15"
The cost of the item is 5
```

显然这不是我们想要的结果。只要脚本在引号中出现美元符，它就会认为你在引用一个变量。在这个例子中，脚本会尝试显示变量`$1`（但并未定义），再显示数字5。要显示美元符，你必须在其前面放置一个反斜线。

```sh
$ echo "The cost of the item is \$15"
The cost of the item is $15
```

这样看起来好多了。反斜线允许Shell脚本将美元符解读为实际的美元符，而不是变量。

### 11.4.2 用户变量

除了环境变量，Shell脚本还允许在脚本中定义和使用自己的变量。定义变量可以临时存储数据并在整个脚本中使用，从而使Shell脚本更像一个真正的计算机程序。

用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个字符。用户变量区分大小写，所以`Var1`和`var1`是不同的。这个小规则经常让脚本编程初学者感到困惑。

使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。以下是一些给用户变量赋值的例子：

```sh
var1=10
var2=57
var4="still more testing"
var3=testing
```

Shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在脚本结束时会被删除。

与系统变量类似，用户变量可通过美元符引用。例如：

```sh
$ cat test3
#!/bin/bash
guest="Katie"
days=10
echo "$guest checked in $days days ago"
days=5
guest="Jessica"
echo "$guest checked in $days days ago"
```

运行脚本会有如下输出：

```sh
$ chmod u+x test3
$ ./test3
Katie checked in 10 days ago
Jessica checked in 5 days ago
```

每次引用变量时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而在对变量进行赋值时则不要使用美元符。通过一个例子来说明：

```sh
$ cat test4
#!/bin/bash
value1=10
echo "The resulting value is $value2"
value2=$value1
```

这段代码产生如下输出：

```sh
$ chmod u+x test4
$ ./test4
The resulting value is 10
```

如果忘了用美元符，使得`value2`的赋值行变成了这样：

```sh
value2=value1
```

那么你会得到如下输出：

```sh
$ ./test4
The resulting value is value1
```

没有美元符，Shell会将变量名解释成普通的文本字符串，通常这不是你想要的结果。

### 11.4.3 命令替换

Shell脚本中最有用的特性之一是从命令输出中提取信息，并将其赋给变量。有两种方法可以将命令输出赋给变量：

- 反引号字符（`` ` ``）
- `$()`格式

反引号字符不是普通的单引号字符。在标准键盘上，它通常和波浪线（~）位于同一键位。

命令替换允许你将Shell命令的输出赋给变量。尽管这看起来并不那么重要，但它却是脚本编程中的一个主要组成部分。

要么用一对反引号把整个命令行命令围起来：

```sh
testing=`date`
```

要么使用`$()`格式：

```sh
testing=$(date)
```

Shell会运行命令替换符号中的命令，并将其输出赋给变量`testing`。注意，赋值等号和命令替换字符之间没有空格。这里有个使用普通的Shell命令输出创建变量的例子：

```sh
$ cat test5
#!/bin/bash
testing=$(date)
echo "The date and time are: $testing"
```

运行这个Shell脚本生成如下输出：

```sh
$ chmod u+x test5
$ ./test5
The date and time are: Mon Jan 31 20:23:12 EDT 2014
```

这个例子毫无吸引人的地方（也可以干脆将该命令放在`echo`语句中），但只要将命令的输出放到了变量里，你就可以想干什么就干什么了。

下面这个例子很常见，它在脚本中通过命令替换获得当前日期并用它来生成唯一文件名：

```sh
#!/bin/bash
# Copy the /usr/bin directory listing to a log file
ls /usr/bin -al > log.$today
today=$(date +%y%m%d)
```

`today`变量被赋予格式化后的`date`命令的输出。这是提取日期信息来生成日志文件名常用的一种技术。`+%y%m%d`格式告诉`date`命令将日期显示为两位数的年月日的组合。

```sh
$ date +%y%m%d
140131
```

这个脚本将日期值赋给一个变量，之后再将其作为文件名的一部分。文件自身含有目录列表的重定向输出（将在11.5节详细讨论）。运行该脚本之后，应该能在目录中看到一个新文件。

```sh
$ ls -l
-rw-r--r-- 1 user 769 Jan 31 10:15 log.140131
```

目录中出现的日志文件采用`$today`变量的值作为文件名的一部分。日志文件的内容是`/usr/bin`目录内容的列表输出。如果脚本在明天运行，日志文件名会是`log.140201`，从而为新的一天创建一个新文件。

**警告**：命令替换会创建一个子Shell来运行对应的命令。子Shell是由运行该脚本的Shell所创建出来的一个独立的子Shell。正因如此，由该子Shell所执行的命令无法使用脚本中所创建的变量。在命令行提示符下使用路径`./`运行命令的话，也会创建出子Shell；如果是运行命令时不加入路径，则不会创建子Shell。如果你使用的是内建的Shell命令，并不会涉及子Shell。在命令行提示符下运行脚本时一定要留心！

### 11.5 重定向输入和输出

有时你想要保存某个命令的输出而不仅仅只是让它显示在显示器上。bash Shell提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。本节介绍了如何在Shell脚本中使用重定向。

#### 11.5.1 输出重定向

最基本的重定向将命令的输出发送到一个文件中。bash Shell用大于号（`>`）来完成这项功能：

```sh
command > output.file
```

之前显示器上出现的命令输出会被保存到指定的输出文件中。

```sh
$ date > test6
$ ls -l test6
-rw-r--r-- 1 user 29 Feb 10 17:56 test6
$ cat test6
Thu Feb 10 17:56:58 EDT 2014
```

重定向操作符创建了一个文件`test6`（通过默认的umask设置），并将`date`命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。

```sh
$ who > test6
$ cat test6
user   pts/0        Feb 10 17:55
```

现在`test6`文件的内容就是`who`命令的输出。

有时，你可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如你正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号（`>>`）来追加数据。

```sh
$ date >> test6
$ cat test6
Thu Feb 10 18:02:14 EDT 2014
user   pts/0        Feb 10 17:55
```

`test6`文件仍然包含早些时候`who`命令的数据，现在又加上了来自`date`命令的输出。

#### 11.5.2 输入重定向

输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。

输入重定向符号是小于号（`<`）。例如：

```sh
$ sort < input.txt
```

输入重定向将`input.txt`文件的内容作为`sort`命令的输入。

#### 11.5.3 内联输入重定向

内联输入重定向允许你直接在命令行中提供输入数据。内联输入重定向使用`<<`符号，后面跟着一个标记符。例如：

```sh
$ wc << EOF
> test string 1
> test string 2
> EOF
```

在命令行上使用内联输入重定向时，Shell会用PS2环境变量中定义的次提示符（参见第6章）来提示输入数据。`wc`命令会对内联输入重定向提供的数据进行行、词和字节计数。

### 11.6 管道

有时需要将一个命令的输出作为另一个命令的输入。这可以用重定向来实现，但有些笨拙。例如：

```sh
$ rpm -qa > rpm.list
$ sort < rpm.list
abrt-1.1.14-1.fc14,1686
abrt-addon-ccpp-1.1.14-1.fc14,1686
abrt-addon-python-1.1.14-1.fc14,1686
...
```

通过标准输出重定向，`rpm`命令的输出被重定向到了文件`rpm.list`。命令完成后，`rpm.list`保存着系统中所有已安装的软件包列表。接下来，输入重定向将`rpm.list`文件的内容发送给`sort`命令，该命令按字母顺序对软件包名称进行排序。

这种方法的确管用，但仍然是一种比较繁琐的信息生成方式。我们用不着将命令输出重定向到文件中，可以将其直接重定向到另一个命令。这个过程叫作管道连接（piping）。

和命令替换所用的反引号（`` ` ``）一样，管道符号在Shell编程之外也很少用到。该符号由两个竖线构成，一个在另一个上面。然而管道符号的印刷体通常看起来更像是单个竖线（`|`）。在美式键盘上，它通常和反斜线（`\`）位于同一个键。管道被放在命令之间，将一个命令的输出重定向到另一个命令中：

```sh
command1 | command2
```

不要以为由管道串起的两个命令会依次执行。Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。

现在，可以利用管道将`rpm`命令的输出送入`sort`命令来产生结果。

```sh
$ rpm -qa | sort
abrt-1.1.14-1.fc14,1686
abrt-addon-ccpp-1.1.14-1.fc14,1686
abrt-addon-python-1.1.14-1.fc14,1686
...
```

除非你的眼神特别好，否则可能根本来不及看清楚命令的输出。由于管道操作是实时运行的，所以只要`rpm`命令一输出数据，`sort`命令就会立即对其进行排序。等到`rpm`命令输出完数据，`sort`命令就已经将数据排好序并显示在显示器上。

可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细化操作。

在这个例子中，`sort`命令的输出会一闪而过，所以可以用一条文本分页命令（例如`less`或`more`）来强行将输出按屏显示。

```sh
$ rpm -qa | sort | more
```

这行命令序列会先执行`rpm`命令，将它的输出通过管道传给`sort`命令，然后再将`sort`的输出通过管道传给`more`命令来显示，在显示完一屏信息后停下来。这样你就可以在继续处理前停下来阅读显示器上显示的信息，如图11-1所示。

```
file Edit View Search Terminal help
abrt-1.1.14-1.fc14,1686
ac1-2.2.49-8.fc14,1686
alsa-firmware-1.0.23-1.fc14.x86_64
alsa-lib-1.0.23-2.fc14.i686
alsa-utils-1.0.23-3.fc14.i686
apr-1.3.9-3.fc13.i586
-More
```

图11-1 通过管道将数据发送给`more`命令