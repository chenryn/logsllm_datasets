# Linux的系统调用机制
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 概述
处于用户态的程序只能执行非特权指令, 如果需要使用某些特权指令, 比如: 通过io指令与硬盘交互来读取文件, 则必须通过系统调用向内核发起请求,
内核会检查请求是否安全, 从而保证用户态进程不会威胁整个系统
write(1, ptr, 0x10)系统调用为例子, 汇编可以写为如下, 内核收到请求后会向显存中写入数据, 从而在显示器上显示出来
    mov rax, 1
    mov rdi, 1
    mov rsi, ptr
    mov rdx, 0x10
    syscall
C库会首先实现一个write的包裹函数, 为这个系统调用进行一些简单的参数检查和错误处理
由于write的功能十分简单, 不方面使用因此还会根据write衍生出更高级的函数printf()供用户使用
整体结构如下:
接下来我们主要研究系统调用是怎么进入和退出的, 并不研究具体处理函数的实现
## i386下处理系统调用
i386的系统调用是通过中断实现的, 因此放在了arch/i386/traps.c里面, 通过system_call()处理int 0x80的中断
system_call()声明
system_call()定义
sys_call_table就是一个函数指针数组, 定义在arch/i386/syscall.c中, 通过包含文件完成数组的初始化
unistd.h中定义了系统调用号与处理函数的句柄, 这个文件位于源码顶层, 是所有架构都必须满足的, 处理函数的举报由各个架构自己实现
总结
## 预备知识
###  段选择子
实模式下下: 实际物理地址 = (段地址
###  swapgs指令
swapgs指令: 把gs的值与IA32_KERNEL_GS_BASE MSR进行交换
刚刚切换到内核态时, 所有的通用寄存器与段寄存器都被用户使用, 内核需要想办法找到内核相关信息, 解决方法为:
  * 令gs指向描述每个cpu相关的数据结构
  * 当要切换到用户态时就调用swapgs把值保存在MSR寄存器中. 由于操作MSR的指令为特权指令, 因此用户态下是无法修改的MSR
## x86_64下处理系统调用
kernel初始化时, 调用arch/x86/kernel/s.c:syscall_init()对MSR进行初始化,
设置entry_SYSCALL_64为处理系统调用的入口点
由于有些指令entry_SYSCALL_64的任务可以分为三部分
  * 进入路径: 汇编实现, 目的是保存syscall的现场, 切换到内核态的执行环境, 创建一个适当的环境, 然后调用处理程序
  * 处理程序: C实现, 负责具体的处理工作
  * 退出路径: 汇编实现, 目的是从中断环境中退出, 切换到用户态, 恢复用户态的程序执行
进入路径部分:
  * 先通过swapgs指令切换到内核态的gs, 并保存用户态的gs 
    * 这是一个特权指令, 但是CPU处理system指令时已经把CS的RPL设为00, 因此现在运行在内核态, 可以执行特权指令
  * 然后通过gs保存用户的rsp, 并找到内核态的rsp, 至此切换到内核态堆栈
  * 然后保存所有内核态会使用的寄存器到栈上
接下来涉及到slow_path和fast_path相关, 这只是一个优化, 其本质工作就是下面这条指令
sys_call_table是一个函数指针数组, 指向各个系统调用的处理函数
处理函数结束后会ret到entry_SYSCALL_64中, 进入退出路径部分, 这部分进行的工作为
  * 把处理函数的返回值写入到内核栈上的pt_regs中
  * 利用pt_regs结构恢复用户态的执行环境
  * 交换gs, 切回用户态的gs, 并把内核态的gs保存在MSR中
  * sysretq, 从syscall中退出
## 总结
i386:
x86_64