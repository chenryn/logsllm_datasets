## 什么是 B 树如果用二叉树作为索引的实现结构，会让树变得很高，增加硬盘的 I/O次数，影响数据查询的时间。因此一个节点就不能只有 2个子节点，而应该允许有 M 个子节点 (M\>2)。B 树的出现就是为了解决这个问题，B 树的英文是 BalanceTree，也就是平衡的多路搜索树，它的高度远小于平衡二叉树的高度。在文件系统和数据库系统中的索引结构经常采用B 树来实现。B 树的结构如下图所示：![](Images/ffe1004b7f548279306fe887c4eb23d3.png){savepage-src="https://static001.geekbang.org/resource/image/18/44/18031c20f9a4be3e858743ed99f3c144.jpg"}\B 树作为平衡的多路搜索树，它的每一个节点最多可以包括 M 个子节点，M 称为B树的阶。同时你能看到，每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了x 个关键字，那么指针数就是 x+1。对于一个 100 阶的 B 树来说，如果有 3层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。一个 M 阶的 B 树（M\>2）有以下的特性：1.  根节点的儿子数的范围是 \[2,M\]。2.  每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量    +1，k 的取值范围为 \[ceil(M/2), M\]。3.  叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为    \[ceil(M/2), M\]。4.  假设中间节点节点的关键字为：Key\[1\], Key\[2\], ...,    Key\[k-1\]，且关键字按照升序排序，即 Key\[i\]\`{=html}我们知道 Python的数据结构中有数组和字典两种，其中数组检索数据类似于全表扫描，需要对整个数组的内容进行检索；而字典是由Hash 表实现的，存储的是 key-value 值，对于数据检索来说效率非常快。对于 Hash的检索效率，我们来个更直观的认知。下面我们分别看一下采用数组检索数据和采用字典（Hash）检索数据的效率到底有怎样的差别。实验 1：在数组中添加 10000 个元素，然后分别对这 10000个元素进行检索，最后统计检索的时间。代码如下：    import time
# 插入数据result = []for i in range(10000):       result.append(i)
# 检索数据time_start=time.time()for i in range(10000):       temp = result.index(i)time_end=time.time()print('检索时间', time_end-time_start)运行结果：检索时间为 1.2436728477478027 秒实验 2：采用 Hash 表的形式存储数据，即在 Python 中采用字典方式添加 10000个元素，然后检索这 10000 个数据，最后再统计一下时间。代码如下：    import time
# 插入数据result = {}for i in range(1000000):       result[i] = i
# 检索数据time_start=time.time()for i in range(10000):       temp = result[i]time_end=time.time()print('检索时间：',time_end-time_start)运行结果：检索时间为 0.0019941329956054688 秒。你能看到 Hash 方式检索差不多用了 2毫秒的时间，检索效率提升得非常明显。这是因为 Hash只需要一步就可以找到对应的取值，算法复杂度为O(1)，而数组检索数据的算法复杂度为 O(n)。
## MySQL 中的 Hash 索引采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I/O操作，从效率来说 Hash 比 B+ 树更快。我们来看下 Hash 索引的示意图：![](Images/e77b16887c9150a1d244cdc8bab386ca.png){savepage-src="https://static001.geekbang.org/resource/image/d8/b6/d8ef0bc1ea85b9e5408fcf0126b2a2b6.png"}\键值 key 通过 Hash 映射找到桶bucket。在这里桶（bucket）指的是一个能存储一条或多条记录的存储单位。一个桶的结构包含了一个内存指针数组，桶中的每行数据都会指向下一行，形成链表结构，当遇到Hash 冲突时，会在桶中进行键值的查找。那么什么是 Hash 冲突呢？如果桶的空间小于输入的空间，不同的输入可能会映射到同一个桶中，这时就会产生Hash 冲突，如果 Hash 冲突的量很大，就会影响读取的性能。通常 Hash 值的字节数比较少，简单的 4 个字节就够了。在 Hash值相同的情况下，就会进一步比较桶（Bucket）中的键值，从而找到最终的数据行。Hash 值的字节数多的话可以是 16 位、32 位等，比如采用 MD5函数就可以得到一个 16 位或者 32 位的数值，32 位的 MD5已经足够安全，重复率非常低。我们模拟一下 Hash索引。关键字如下所示，每个字母的内部编码为字母的序号，比如 A 为 01，Y 为25。我们统计内部编码平方的第 8-11 位（从前向后）作为 Hash 值：![](Images/99d94d6d67749c3be4d35d9e94a156de.png){savepage-src="https://static001.geekbang.org/resource/image/6b/3d/6bff085844127931e59e6faa368e223d.png"}
## Hash 索引与 B+ 树索引的区别我们之前讲到过 B+ 树索引的结构，Hash 索引结构和 B+树的不同，因此在索引使用上也会有差别。1.  Hash 索引不能进行范围查询，而 B+ 树可以。这是因为 Hash    索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。2.  Hash    索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用），而    B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash    值的时候是将索引键合并后再一起计算 Hash    值，所以不会针对每个索引单独计算 Hash    值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。3.  Hash 索引不支持 ORDER BY 排序，因为 Hash    索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+    树索引数据是有序的，可以起到对该字段 ORDER BY    排序优化的作用。同理，我们也无法用 Hash 索引进行模糊查询，而 B+    树使用 LIKE 进行模糊查询的时候，LIKE 后面前模糊查询（比如 %    开头）的话就可以起到优化作用。对于等值查询来说，通常 Hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。
## 总结我今天讲了 Hash 索引的底层原理，你能看到 Hash索引存在着很多限制，相比之下在数据库中 B+树索引的使用面会更广，不过也有一些场景采用 Hash索引效率更高，比如在键值型（Key-Value）数据库中，Redis 存储的核心就是Hash 表。另外 MySQL 中的 Memory 存储引擎支持 Hash存储，如果我们需要用到查询的临时表时，就可以选择 Memory存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用Hash 索引是个不错的选择。另外 MySQL 的 InnoDB 存储引擎还有个"自适应 Hash索引"的功能，就是当某个索引值使用非常频繁的时候，它会在 B+树索引的基础上再创建一个 Hash 索引，这样让 B+ 树也具备了 Hash索引的优点。![](Images/67047c7ea909da8330f4d3564961eb7c.png){savepage-src="https://static001.geekbang.org/resource/image/7f/c0/7f970dd51170fe42a7192e5811102fc0.png"}\今天的内容到这里就结束了，我留两道思考题吧。查找某个固定值时 Hash 索引比B+ 树更快，为什么 MySQL 还要采用 B+ 树的存储索引呢？另外，当两个关键字的Hash 值相同时会发生什么？欢迎你在评论区写下你的思考，我会和你一起交流，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。![](Images/3966c46b158eaaf5df4bf8252216b20d.png){savepage-src="https://static001.geekbang.org/resource/image/4f/58/4fd70a3267ad5aeb8c531f0996642f58.jpg"}
# 26丨索引的使用原则：如何通过索引让SQL查询效率最大化？我之前讲了索引的使用和它的底层原理，今天我来讲一讲索引的使用原则。既然我们的目标是提升SQL 的查询效率，那么该如何通过索引让效率最大化呢？今天的课程主要包括下面几个部分：1.  什么情况下使用索引？当我们进行数据表查询的时候，都有哪些特征需要我们创建索引？2.  索引不是万能的，索引设计的不合理可能会阻碍数据库和业务处理的性能。那么什么情况下不需要创建索引？3.  创建了索引不一定代表一定用得上，甚至在有些情况下索引会失效。哪些情况下，索引会失效呢？又该如何避免这一情况？