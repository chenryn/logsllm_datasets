● Like RPC, COM services must define their interface using an IDL file. This must be registered.
DLL containing
implementation
Supported
Proxies/Stubs
74
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
COM Security
Launch = Create a new instance of the server.
Access = Call methods on existing objects.
Activate = Create new object on existing server.
Enforced in Server Process
75
Enforced in RPCSS
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
AppIDs and RunAs User
● A COM class be be registered within an AppID (again a GUID)
● The AppID can change the behaviour of the activated COM
class
○ Specify non-default Launch or Access permissions
○ Specify a Surrogate Executable to host DLL classes out of the process
○ Specify a Windows Service which will host the class
○ Specify a specific “RunAs” user to run the server under
● RunAs is typically specified as “Interactive User”
○ This means as the current session’s default user, not the caller
○ If a server is registered as “Interactive User” and the caller has permission to
Launch/Activate then a sandboxed user can interact with it to try and escape
the sandbox
76
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
User Account Control
● Default Windows user is a “split-token” administrator
● Means that normally user is limited in privileges but can
become a full administrator on demand
● Implemented in the AppInfo service
● Plenty of ways of bypassing this, but not normally without
prompts
● Also supports special UI Access processes due to block on
sending window messages to higher IL procesesses
○ UI Access bypasses the checks
77
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
UAC Auto-Elevation
● UAC isn’t a security boundary, but still most users still run as
administrators
● Since UAC was introduced supports auto-elevation for special
UI access binaries
○ Signed by a known certificate and in a “secure” location
○ Has the UIAccess element in its manifest
● Since Windows 7, UAC supports auto-elevation for executables
if they meet the following criteria
○ Signed by a Microsoft and in a “secure” location
○ Has an autoElevate element in its manifest
● Also supports auto-elevation of out-of-process COM objects
78
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 4: Inspecting Accessible COM Services
79
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Bug Classes and Exploitation
80
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Example Vulnerabilities
● Toolkit comes with some example vulnerabilities that we can
exploit.
○ LogicalEoPWorkshopDriver - Simple kernel driver containing a number of logical
vulnerabilities
○ RpcServer - Simple RPC server containing a number of logical vulnerabilities
○ COMServer - Simple COM server in .NET to demonstrate COM based
vulnerabilities, is also a client to exploit the an IStorage vulnerability.
● Exploitation Tools
○ DemoClient - Simple interface to “exploit” the majority of vulnerabilities
○ ExploitDotNetDCOMSerialization - Tool we’ll use to exploit the COM Server via
.NET DCOM
81
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Dynamic Analysis with Process Monitor
82
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Reverse Engineering with IDA Pro
83
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Bug Class List
● File path abuse
○ Path Traversal
○ TOCTOU
● Impersonation
○ File/Process Access Under Impersonation
○ Insecure kernel Impersonation and Token Usage
● Insecure Kernel Resource Access
● COM Bugs
○ .NET DCOM Service
○ Bound objects
84
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Path Canonicalization
bool TestLoadLibrary(const wchar_t* name)
{
wstring full_path = L"C:\\Windows\\" + name;
HMODULE hModule = LoadLibrary(full_path.c_str());
if (hModule != nullptr)
{
printf("Loaded module: %p\n", hModule);
No verification
FreeLibrary(hModule);
on name
return true;
}
return false;
}
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 5 : Exploiting Path Canonicalization
86
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Insecure Path Usage
bool TestLoadLibraryCanonical(const wchar_t* name)
{
if (wcschr(name, '\\') || wcschr(name, '/'))
{
printf("Error, name contains path separators\n");
return false;
}
Disallow
return TestLoadLibrary(name);
canonicalization
}
● All paths will be c:\windows\name
● We can’t write to c:\Windows, or can we?
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
NTFS Alternate Data Streams (ADS)
● ADS allows you to create substreams on NTFS files by
separating using the ‘:’ separtor
○ E.g. abc:xyz is stream named ‘xyz’ on the existing file ‘abc’
● Also works for directories as if we’ve got AddSubDirectory
access
C:\Windows\Tracing we can write an ADS to!
88
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 6: Exploiting Named Streams
89
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
File Time-of-check Time-of-use
bool TestLoadLibraryTocTou(const wchar_t* lib_path) {
if (VerifyEmbeddedSignature(lib_path)) {
HMODULE hModule = LoadLibrary(lib_path);
if (hModule != nullptr) {
printf("Loaded module: %p\n", hModule);
FreeLibrary(hModule);
return true; Verifies that the
DLL is signed
}
}
return false;
Load the library
}
path is signed
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Exploiting TOCTOU
● A few different ways to exploit:
○ Race condition between check time and library loading
■ We could rewrite the file in between the check and the load.
○ Exploit differing path parsing behaviours between functions
■ LoadLibrary will search the PATH for a filename which isn’t an absolute path
■ Accessing a file takes path verbatim, LoadLibrary plays some games with extensions
lpFileName [in]
...
If the string specifies a module name without a path and the file name extension is
omitted, the function appends the default library extension .dll to the module name.
To prevent the function from appending .dll to the module name, include a trailing
point character (.) in the module name string.
c:\abc becomes c:\abc.dll when loaded
91
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Exploitation
1) Copy a signed binary to a known location with the name abc.
Doesn’t have to be a DLL, can be anything signed.
a) Kernel32.dll works on Windows 10 AE.
2) Copy the DLL you want to load to abc.dll in the same directory.
3) Pass path to service specifying abc as the filename
4) Your desired DLL should be loaded
92
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 7 : TOCTOU on Name
93
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
File Time-of-check Time-of-use
bool TestLoadLibraryTocTouHardened(const wchar_t* lib_path)
{
LPWSTR ext = PathFindExtensionW(lib_path);
if (ext == nullptr || _wcsicmp(ext, L".dll") != 0)
return false;
HANDLE handle = CreateFile(lib_path, ...);
Ensure
if (!CheckFileIsInSystem(handle)) { extension is
.DLL
return false; Lock file so can’t
be written to
}
return LoadLibrary(lib_path);
}
Check opened file is in
system directory
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Windows Symbolic Links
Windows 2000 - Feb 17 2000
NTFS Mount Points and
Directory Junctions
Windows Vista - Nov 30 2006
NTFS Symbolic Links
Windows NT 3.1 - July 27 1993
Object Manager Symbolic Links
Registry Key Symbolic Links
95
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Opportunistic Locks (OPLOCK)
● Winning the TOCTOU race means either brute force or finding
some what of timing the request.
● We can win the race in many cases using OPLOCKS
○ Locks a file to prevent access, can select Read/Write/Delete or Exclusive
○ Gets a callback when someone else tries to open the file. Closing handle allows
that use to continue.
DeviceIoControl(g_hFile,
FSCTL_REQUEST_OPLOCK_LEVEL_1,
NULL, 0,
NULL, 0,
&bytesReturned,
&g_o);
Note: Must use a Level 1 “Exclusive” lock for system files as
normal user always gets Read sharing access.
96
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 8 : Symbolic Link TOCTOU
97
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Reading Files Under Impersonation
bool TestCreateProcess() { Calling User is
Impersonated
RpcImpersonateClient();
WCHAR cmdline[] = L"c:\\windows\\notepad.exe";
if (CreateProcess(cmdline, cmdline, ...)) {
return true;
}
Created process uses current
return false;
process token, not
}
impersonated token
● CreateProcess uses the current process’s token by default, not any
impersonation token
● However the file is accessed under the identity of the impersonated user
● Can we exploit this?
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Current User’s DosDevices Directory
● Current user’s DosDevices directory is stored in
\Sessions\0\DosDevices\X-Y
○ X-Y is the current user’s login ID
● This is writable by the current user for obvious reasons
● We can re-direct C: to anywhere we like and get arbitrary
process running with the identity of the RPC server
NOTE: This will won’t work in a sandbox. It also used
to work for DLLs but Microsoft fixed that glitch (cid:677)
99
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 9 : DosDevices Redirect
100
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Incorrect Handle Duplication
int TestDuplicateHandle(int handle) {
unsigned long pid;
I_RpcBindingInqLocalClientPID(hBinding, &pid);
HANDLE process = OpenProcess(PROCESS_DUP_HANDLE, pid);
HANDLE ret;
DuplicateHandle(process, handle, process,
Opening Calling
&ret, 0, FALSE, DUPLICATE_SAME_ACCESS))
Process
return (int)ret;
Duplicate handle to and
} from same process
● Surely this isn’t very useful? Can only duplicate a handle we
already have back into our own process?
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Hard-coded Handle Values
● The Windows kernel supports two pseudo handle values which
are used whenever handles are accessed
○ -1 = Handle to the current process
○ -2 = Handle to the current thread
● When duplicating handles -1 refers to source process, which in
this case is our own process (useless)
● However -2 refers to the calling thread, which is actually the
thread in the RPC server. We can use this to get arbitrary code
execution in the server process.
NOTE: If the handle is transported as a DWORD this
will fail on 64 bit platforms as the value will zero
extended to HANDLE (cid:677)
102
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 10 : Handle Duplication
103
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Insecure Kernel Resource Access
NTSTATUS CreateFile(PUNICODE_STRING Path) {
OBJECT_ATTRIBUTES obj_attr = { 0 };
HANDLE Handle = NULL;
ULONG AttributeFlags = OBJ_KERNEL_HANDLE;
InitializeObjectAttributes(&obj_attr,
Setting attribute
Path, AttributeFlags);
flags
return ZwCreateFile(&Handle,
MAXIMUM_ALLOWED,
Calling Zw* function,
&obj_attr ...);
will transition to Kernel
}
previous process mode
● Calls to Zw functions transition to kernel mode (when
called from kernel code) which disables all security.
● Should be setting OBJ_FORCE_ACCESS_CHECK flag.
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Resource Access
● File/Registry Key/Resource by default created with inherited
security descriptor for parent
● However as long as call takes place inside the current process
then the OWNER of the file will be the current user
● If inherited descriptor has CREATOR OWNER ACE we get those
access rights
● Even if not we’re owner so can open for WRITE_DAC access
and modify at will
105
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 11 : Privileged Resource Creation
106
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Missing Impersonation Level Checks
BOOLEAN GetTokenElevated(PACCESS_TOKEN Token)
{
PTOKEN_ELEVATION Elevation = NULL;
BOOLEAN ret = FALSE;
if (NT_SUCCESS(SeQueryInformationToken(Token,
TokenElevation, &Elevation)))
{
No check that token is
ret = !!Elevation->TokenIsElevated;
not at impersonation level
} < Impersonation
return ret;
}
● Kernel might check current caller is an administrator or
elevated.
● Must ensure that token is not an identification token
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Exploiting Split-Token Admin
● Numerous ways of getting an Identification level token for a
privileged user
108
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Insecure Impersonation in System Thread
void SystemThread(PACCESS_TOKEN token) {
UNICODE_STRING file;
CHECK_STATUS(PsImpersonateClient(KeGetCurrentThread(),
token, FALSE, FALSE, SecurityImpersonation));
RtlInitUnicodeString(&file, L"\\SystemRoot\\demo.txt");
CHECK_STATUS(CreateFileSecure(&file));
} Forces Impersonation
Level
void BadImpersonation() {
SeCaptureSubjectContext(&subject_context);
PsCreateSystemThread(SystemThread,
SeQuerySubjectContextToken(&subject_context));
Runs in a
} System Thread
● System Threads run in the System process which has
SeImpersonatePrivilege access
● If system thread misuses impersonation can elevate privileges
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 12 : Admin Token Check Bypass
110
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Bound COM Objects
Client Application Server Application
User Administrator
COM Client CreateSomeFile() COM Server
A “secure” server should
impersonate the user
when creating new
resources.
New File
111
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Bound COM Objects
Client Application Server Application
User Administrator
COM Client CreateSomeObject() COM Server
ExecuteJavaScript()
Dangerous Object
112
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
.NET DCOM Services
[ComVisible(true),
Guid("801445A7-C5A9-468D-9423-81F9D13FEE9B")]
public class COMService : ICOMInterface {
}
int cookie = reg_services.RegisterTypeForComClients(
typeof(COMService),
RegistrationClassContext.LocalServer,
RegistrationConnectionType.MultipleUse);
Console.ReadLine();
reg_services.UnregisterTypeForComClients(cookie);
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
.NET DCOM Objects (Binary Serialization)
Client Application Server Application
User Administrator
COM Client IManagedObject([Serialized Delegate]) .NET COM Server
Invoke
Delegate()
.NET Delegate
New File
114
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
DEMO 13 : .NET DCOM Elevation
115
Tools/Examples at: https://goo.gl/HzZ2Gw - Wookbook at:
https://goo.gl/P4Q9GN
Resources
https://github.com/google/sandbox-attacksurface-analysis-tools
https://github.com/google/symboliclink-testing-tools
https://github.com/tyranid/oleviewdotnet
https://github.com/tyranid/ExploitDotNetDCOM
116