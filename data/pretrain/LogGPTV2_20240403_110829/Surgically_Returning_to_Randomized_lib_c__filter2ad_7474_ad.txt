0x4443,%ax
$0x10,%eax
$0x4241,%ax
0x80600a4,%eax
3
:
80497d8
:
80497e8
PLT
jmp 0x8078177
jmp 0x807838d
:
80600a4
:
80600a8
GOT
0xf3b67045
0x87489732
Fig. 7. Layout of the sample vulnerable process with our of GOT encryption protection enabled
1) Automation of the attack: For the evaluation we have
implemented a prototype tool, called SARATOGA, that auto-
matically analyzes a ELF-32 or ELF-64 executable (for x86
and x86-64 architectures respectively), detects whether the
program is predisposed to any of the two variations of the
attack, and generates a stack conﬁguration that can be used to
exploit a vulnerability in the program. To ﬁnd code chunks
in an executable, SARATOGA uses the algorithm presented
by Shacham et al. [10]. SARATOGA combines available code
chunks using a custom algorithm we have developed. Our
algorithm is goal-oriented and rule-based. Given a code chunk
that either allows to dereference or to overwrite a GOT entry,
the algorithm assigns a predetermined value to each possible
use of the code chunk (e.g., the source operands of the instruc-
tions in the chunk). The algorithm uses a set of combination
rules and tries to apply them recursively,
to combine the
available code chunks to perform the requested assignments.
If multiple combinations are possible, the algorithm selects
the one consuming less stack space. For output, SARATOGA
produces a stack conﬁguration containing the gadgets for the
exploitation.
2) Exploiting a real vulnerability: We tested our attack
against a vulnerable version of Ghostscript [16]. We initially
developed a conventional exploit and tested it against the
program with W⊕X and ASLR disabled. The exploit worked
correctly and gave us a shell. Subsequently, we enabled the
two protections and veriﬁed that the exploit stopped working.
We run SARATOGA on the image of the program under attack
and, in few seconds, obtained two stack conﬁgurations for the
two variants of the attack. We constructed two exploits using
the results provided by SARATOGA, and successfully exploited
the vulnerability and obtained a shell with both.
3) Wide-scale applicability of
the attack: The evalua-
tion targeted the executables found in the directories /bin,
/sbin, /usr/bin, and /usr/sbin of the following distri-
butions: GNU/Debian “Squeeze” (x86), GNU/Debian “Lenny”
(x86-64), Fedora “Cambridge” (x86), OpenBSD 4.5 (x86-64).
For the total set of executables found in each distributions
we selected for the evaluation only those whose code size
was greater than 20Kb. The rationale was that excessively
small executables have a limited functionality and very seldom
attract attackers. On the contrary, commonly-attacked executa-
bles (e.g., Ghostscript, Samba, Apache) are bigger, of the order
of tens or hundreds of kilobytes.
The results of our evaluation are reported in Table II.
For each distribution, the table reports the total number of
executables analyzed, the percentage of position dependent
executables, the percentage of executables with writable GOT,
the percentage of executables vulnerable to the GOT deref-
erencing attack, the percentage of executables vulnerable to
the GOT overwriting attack, and the percentage of executables
vulnerable to any of the two attacks. All three tested Linux dis-
tributions support PIE and non-writable GOT. Unfortunately,
our results testify that these mitigation techniques are not yet
widely used. As the table shows, the large majority of the
executables for x86 are predisposed to at least one of the two
variants of the attack. The second variant has much larger
applicability, because the requested code chunks are more
common. The attack is not as effective on x86-64 executa-
bles, but still, more than half of the tested executables are
predisposed to it. With the exception of OpenBSD executables
(where PIE is not available), all the executables found in the
other distribution would not be predisposed to the attack if
they were PIE. Furthermore, considering that the number of
programs predisposed to the GOT dereferencing attack is much
smaller that the percentage of programs predisposed to at least
one of the two attacks, the read-only GOT protection would
give non-negligible beneﬁts.
It
is worth noting that
the a vulnerability found in an
executable predisposed to our attack might not be exploitable.
For example, the vulnerability might not expose a large enough
portion of the stack, or it might not provide the needed stack
manipulation operations (e.g.,
to inject null bytes). These
67
Executables
non-PIE
Writable GOT
Attack 1
Attack 2
Any attack
Debian (x86) Debian (x86-64)
333
97.3%
100%
17.8%
57.4%
58.3%
509
95.7%
99.8%
64.0%
96.1%
96.3%
Fedora (x86) OpenBSD (x86-64)
174
100%
100%
58.6%
68.4%
68.4%
590
85.8%
99.0%
49.5%
95.0%
95.0%
EXPERIMENTAL EVALUATION OF THE EFFECTIVENESS OF THE ATTACK ON X86 AND X86-64 EXECUTABLES
TABLE II
PIE
Encrypted GOT
bc
10.55%
0.21%
bogofilter
3.46%
15.49%
bzip2
0%
0.63%
clamscan
0.12%
0.11%
convert
grep
0% 1.41%
0.32% 4.54%
oggenc
tar
Avg.
0.16% 0.12% 1.98%
0.02% 0.20% 2.69%
OVERHEAD INTRODUCED BY PIE AND BY OUR PROTECTION (THE BASELINE FOR COMPARISON ARE THE NON-PIE EXECUTABLES)
TABLE III
situations are not considered a limitation of our attack but
rather a limitation of the vulnerability itself.
B. Evaluation of the proposed defense
We evaluated the efﬁcacy our encrypted GOT protection, as
well as the overhead it imposes. Our results demonstrate the
effectiveness of our solution at stopping both attack variations,
as with a small runtime overhead (about 2.69%).
To evaluate the effectiveness of the proposed mitigation
strategy we tested the two exploits constructed with the help
of our tool against the vulnerable version of Ghostscript, with
our GOT protection, W⊕X, and ASLR enabled. Both exploits
failed to work. The vulnerable process terminated with a page
fault exception caused by an access to an invalid memory page.
We evaluated the overhead introduced by our protection and
compared with the overhead introduced by PIE. For the evalu-
ation we used the following applications: bc, bogofilter,
bzip2, clamscan , convert, grep, oggenc, and tar.
These applications are CPU-bound and make frequent use of
functions in shared libraries. Experiments were performed on
an x86 system running GNU/Linux 2.6.27. As our protection
works entirely in user-space, for each application we measured
the user-time requested to complete a batch job, averaged
over multiple runs, in three different conﬁgurations: (I) with
a version of the executable compiled with default options
(position dependent executables), (II) with a version of the
executable complied with the default options as PIE, and (III)
with the ﬁrst version of the executable but with our runtime
protection enabled. Table III reports the overhead measured
with each application and the average. The percentages in the
table represent the relative increment of user-time, with respect
to conﬁguration (I). From these results we can draw two main
conclusions. First, the average overhead introduced by PIE
is very small, 1.98%, and a maximum of 10.55% with bc,
and can be further reduced with more aggressive compilers
optimizations (e.g., by omitting the frame pointer). Second,
the overhead introduced by our encrypted GOT protection is
also very small and comparable to that introduced by PIE.
The average overhead observed was 2.69% and a maximum of
15.49% with bogofilter, which invokes library functions
with a very high frequency. The small overhead implies
practical adoption of our protection on both end-users and
production systems.
VI. RELATED WORK
Since the traditional
technique for exploiting stack-based
buffer overﬂows was ﬁrst disclosed [17], several other exploit-
ing techniques have been invented and classes of vulnerabili-
ties have been discovered. The techniques mostly related to our
work have been already presented in great detail in the main
sections of the paper. The most important vulnerabilities to
mention instead are heap-based overﬂows [18], format string
vulnerabilities [19] and integer overﬂows [20].
We observed a parallel development of techniques to protect
applications from memory error exploits. In Section IV we
discussed the main attack mitigation strategies related to our
work, such as W⊕X, ASLR, the various protections exten-
sions to ASRL and the protections for the GOT. Aside from
these techniques, other approaches have been proposed. Stack-
Guard [21] is a compile-time solution that protects programs
from stack-based overﬂows by placing canary values between
a function’s local variables and its return address. Canaries
are used to detect corruptions of the stack. ProPolice extends
StackGuard by reordering functions and local variables and
relocating code pointers in the stack items preceding dan-
gerous buffers to impede overwrites [22]. PointGuard uses
encryption to protect pointers [23]. As in the protection for the
GOT we propose, pointers are decrypted at dereference time.
StackShield uses a shadow stack to save the return addresses
and to check that they have not been tampered at function
returns. For a survey of traditional mitigation techniques, the
interested reader can refer to [24].
A completely different approach to detect memory cor-
ruptions is the N-Variant system [25]. The idea is to run n
different instances of the same program with diverse memory
layouts, obtained using ASLR. Any successful attack will
work only on one of the instances and will cause all the other
instances to crash because the attack must be tailored to a
particular process layout. This idea has been further extended
in [26].
68
VII. CONCLUSIONS
We presented a new attack against programs vulnerable to
stack-based buffer overﬂows that bypasses two of the most
widely adopted protection techniques, namely write or execute
only (W⊕X) and address space layout randomization (ASLR).
With our attack we extract from the address space of the
vulnerable process information about the random base address
at which a library is loaded and then use this information
to mount a return-to-lib(c) attack. Contrary to the state-of-
the-art attack for this scenario, which is based on brute-
force and requires a number of attempts proportional to the
size of the address space, using our attack the vulnerable
program can be subverted in a single shot. We analyzed
the executables found in different UNIX distributions and
observed that the attack would be successful on the majority
of them. We also analyzed several existing protections that
can be combined with W⊕X and ASLR. Our ﬁnding was
that ASLR is effective against our attack only when used
in combination with position independent executables (PIE).
Unfortunately the latter approach is not yet very popular and
requires recompilation. We proposed a new runtime protection
that impedes our attack without having to recompile programs
and introduces a small overhead.
REFERENCES
[1] E. H. Spafford, “The Internet Worm Program: an Analysis,” SIGCOMM
Computer Communication Review, vol. 19, no. 1, pp. 17–57, 1989.
[2] The PaX Team, “PaX non-executable pages.” [Online]. Available:
http://pax.grsecurity.net/docs/noexec.txt
[3] ——, “Address space layout
randomization.” [Online]. Available:
http://pax.grsecurity.net/docs/aslr.txt
[4] H. Shacham, M. Page, B. Pfaff, E. Goh, N. Modadugu, and D. Boneh,
“On the Effectiveness of Address-Space Randomization,” in Proceedings
of the 11th ACM Conference on Computer and Communications Security
(CCS), 2004, pp. 298–307.
[5] S. Designer, “”return-to-libc” attack,” Bugtraq, 1997.
[6] “grsecurity.” [Online]. Available: http://grsecurity.net
[7] A. van de Ven, “New Security Enhancements in Red Hat Enterprise
Linux v.3, update 3,” Aug. 2004.
[8] T. Durden, “Bypassing PaX ASLR protection,” Jul. 2002.
[9] S. Krahmer, “x86-64 buffer overﬂow exploits and the borrowed code
chunks exploitation technique,” 2005.
[10] H. Shacham, “The Geometry of Innocent Flesh on the Bone: Return-
into-libc without Function Calls (on the x86),” in Proceedings of the 14th
ACM Conference on Computer and Communications Security (CCS),
Oct. 2007, pp. 552–561.
[11] J. Levine, Linkers and Loaders. Morgan Kaufmann, 2000.
[12] S. Bhatkar, D. C. DuVarney, and R. Sekar, “Address Obfuscation:
an Efﬁcient Approach to Combat a Broad Range of Memory Error
Exploits,” in Proceedings of the 12th USENIX Security Symposium,
2003, pp. 105–120.
[13] J. Xu, Z. Kalbarczyk, and R. Iyer, “Transparent Runtime Randomization
for Security,” University of Illinois at Urbana-Champaign, Tech. Rep.
UILU-ENG-03-2207, May 2003.
[14] “GNU binutils,” http://www.gnu.org/software/binutils/.
[15] S. Bhatkar, R. Sekar, and D. C. DuVarney, “Efﬁcient Techniques for
Comprehensive Protection from Memory Error Exploits,” in Proceedings
of the 14th USENIX Security Symposium, Aug. 2005.
[16] CVE-2008-0411, “Ghostscript zseticcspace() Function Buffer Overﬂow
Vulnerability.”
zine, vol. 7, no. 49, 1996.
[17] Aleph One, “Smashing The Stack For Fun And Proﬁt,” Phrack Maga-
[18] Michel Kaempf, “Smashing The Heap For Fun And Proﬁt,” Phrack
Magazine, vol. 11, no. 57, 2001.
[19] Scut, Team Teso, “Exploiting Format String Vulnerabilities,” March
2001.
[20] blexim, “Basic Integer Overﬂows,” Phrack Magazine, vol. 11, no. 60,
2002.
[21] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier,
P. Wagle, Q. Zhang, and H. Hinton, “StackGuard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks,” in Proceedings of
the 7th USENIX Security Symposium, 1998, pp. 63–78.
[22] H. Etoh, “GCC extension for protecting applications from stack-
[Online]. Available: http:
smashing attacks
(ProPolice),” 2003.
//www.trl.ibm.com/projects/security/ssp/
[23] C. Cowan, S. Beattie, J. Johansen, and P. Wagle, “PointGuard: Protecting
Pointers from Buffer Overﬂow Vulnerabilities,” in Proceedings of the
12th Usenix Security Symposium, 2003.
[24] C. Cowan, P. Wagle, C. Pu, S. Beattie, and J. Walpole, “Buffer overﬂows:
Attacks and defenses for the vulnerability of the decade,” in Proceedings
of the DARPA Information Survivability Conference and Exposition, Jan.
2000, pp. 11–19.
[25] B. Cox, D. Evans, A. Filipi, J. Rowanhill, W. Hu, J. Davidson, J. Knight,
A. Nguyen-Tuong, and J. Hiser, “N-Variant Systems: A Secretless
Framework for Security through Diversity,” in Proceedings of the 15th
USENIX Security Symposium, 2006, pp. 105–120.
[26] D. Bruschi, L. Cavallaro, and A. Lanzi, “Diversiﬁed Process Replicae
for Defeating Memory Error Exploits,” in Proceedings of
the 3rd
International Workshop on Information Assurance, 2007, pp. 434–441.
69