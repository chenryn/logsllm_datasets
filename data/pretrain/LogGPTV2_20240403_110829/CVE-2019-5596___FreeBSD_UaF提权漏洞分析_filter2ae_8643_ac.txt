    2569          while (buf_dirty_count_severe()) {
    2570              bdirtywait = 1;
    2571              msleep(&bdirtywait, &bdirtylock, (PRIBIO + 4),
    2572                  "flswai", 0);
    2573          }
    2574          mtx_unlock(&bdirtylock);
    2575      }
    2576  }
    2577  
    2578  /*
    2579   * Return true if we have too many dirty buffers.
    2580   */
    2581  int
    2582  buf_dirty_count_severe(void)
    2583  {
    2584  
    2585      return (!BIT_EMPTY(BUF_DOMAINS, &bdhidirty));
    2586  }
最值得注意的是第2571行的`msleep()`函数。函数手册中提到，sleep()函数会使线程在没有超时的情况下进入休眠状态。通过查看唤醒的通道`bdirtywait`可以发现,线程将被`vfs_bio.c`中`buf_daemon()`调用的`bdirtywakeup()`函数唤醒。
调用`msleep()`的条件和`buf_daemon()`的目的是关联的：如果内核持有太多脏缓冲区（即等待写入的缓冲区），则`buf_dirty_count_severe()`返回1并且唤醒`buf_daemon()`函数执行刷新操作以减少计数的值。之后，调用`bdirtywakeup()`来唤醒在第2571行等待的所有写操作。
有两个内核变量用作监视是否有`lodirtybuffers`和`hidirtybuffers`这两个脏缓冲区的标志。这些变量是在程序启动时设置的，取决于RAM（调用sysctl
vfs.hidirtybuffers和sysctl
vfs.lodirtybuffers以显示特定系统的值）。如果脏缓冲区的数量大于`hidirtybuffers`，则设置`bdhidirty`位（第2585行）同时`buf_dirty_count_severe`返回1，从而调用`msleep()`。
因此，需要一种快速增加脏缓冲区数量的技术。经过尝试后，很快就找到了一种简单的方法：用exploit打开大量的引用同一个文件的文件流。但是，在使用fopen()打开文件流后，在下次调用fopen()之前，应当先取消相应文件的链接。如果exploit尝试并行写入这些文件流，脏缓冲区的数量就会增加。
可以在`test_dirty.c`中找到此技术的演示。
目前的exploit的工作原理如下：一旦脏缓冲区的数量足够，另一个线程就会获得一个信号，尝试写入先前打开的随机的可写文件。同时，向另一个线程发送触发UaF的信号并打开只读文件。通过关闭用于准备UaF场景的文件描述符和重复的场景（请记住此时`f_count`等于2）来触发UaF。现在打开只读文件将导致struct文件对象的转换。
为了提高exploit赢得条件竞争的概率，尽可能让UaF触发线程和写入线程在不同的核上运行，并且让UaF延迟几微秒触发。如前文所述，如果写入线程的操作没有完成，那么exploit可能会导致内核崩溃，因为free之后的use发生得太快，`_fdrop()`会触发崩溃。
可以在`arbitary_file_write`中找到任意写入的概念验证。应该注意，`hammer`线程是同步的。否则继续创建线程并触发漏洞会导致攻击不可靠。此外，同步写入会更快地触发`msleep()`条件。  
完成最终的exploit还有两个挑战：获取root权限并防止内核崩溃。
后者可以通过使用导致参考计数器溢出的语句来实现。崩溃的原因是程序试图关闭它认为打开的所有文件描述符。然而，UaF使参考计数器很小，导致前面提到的`_fdrop()`中的判断失败了。
因为在写操作时被利用的struct文件的`f_count`被UaF和后面的open()置为1，所以在最后调用`fdrop()`时`write()`将再次释放文件对象。因此，需要第三次调用`open()`来获取损坏的struct文件的文件描述符。之后，引用计数器增加语句可增加f_count的值，防止内核崩溃。
kingcope于2005年发布了[FreeBSD root exploit](https://www.exploit-db.com/exploits/1230)，使权限提升变得很容易，该文件将导致写入`/etc/libmap.conf`文件。如果程序启动，此配置文件可用于挂钩加载的动态库。因此，该exploit创建了一个动态库，它将`/bin/sh`复制到另一个文件并为该副本设置suid位。钩子库是`libutil`，可以由su调用。因此，用户对su的调用将导致`/bin/sh`副本的执行，实现sudi（对于其他测试系统，可能需要调分支、线程和文件的值。此exploit中提供的数字适用于具有2GB内存和双核的VM系统）。
最终的exploit可以在`heavy_cyber_weapon.sh`中找到。
## 0x06 结论及下步打算
本文介绍了在FreeBSD中利用的一个简单但易被忽视的漏洞。
虽然UaF触发器的开发非常简单，但研究利用漏洞的方法需要付出很多的努力。写这篇文章的主要原因是研究内核代码的合理工程（the reasonable good
engineering of the kernel code ）以及FreeBSD漏洞write-up的稀缺。作者希望这篇文章对以后的研究工作做出贡献，或者在他们自己的研究中确实有所帮助。
据本文作者所知，本文首次描述了此漏洞的工作原理，并首次描述了所需的技术。
在可以在Files区域触发UaF的类似情况下，开发技术应该派上用场。应该留存没有做大更改的内核代码。
此外，在其他安装程序甚至CPU架构使用此exploit时，逻辑漏洞的优势就突显出来了。该漏洞已在ARM处理器上成功测试。
最后，应该提一下下步打算：
>
> 1.目前，漏洞利用技术仅适用于UFS。虽然这是过去的标准文件系统，现在ZFS被FreeBSD安装程序广泛运用。但是由于脏缓冲机制不同（如果它存在的话），该技术并不适用于ZFS。因此，不会触发msleep()，这会导致竞争条件不可靠。必须找到另一种延迟机制。  
>  2.通过执行大量的并行写入来创建脏缓冲区从而使竞争条件可靠的代码不够优化。也许有另一种方法来创建写延迟，但这是目前为止最快的方法。  
>
> 3.可能有完全不同的方式来利用此漏洞。例如，可以考虑欺骗suid程序从不想读取的文件中读取（例如，从用户提供的文件而不是/etc/pam.d/su中读取su）。
## 0x00 附录：环境设置
为了测试和调试漏洞和bug，选择了[VirtualBox](https://www.virtualbox.org/)。此外，可以应用一些内核补丁来加速uAf条件的准备。
###  1.VirtualBox设置
目前已经有可以为FreeBSD内核调试创建测试环境的指导书，例如[argp](https://argp.github.io/2009/07/02/freebsd-kernel-debugging/)。  
这是指南的最新更新，以及设置的说明。
> 1.从这里获取FreeBSD-12-RELEASE disc1  
>  2.将所有内容安装到新的VirtualBox VM中
>
>> 使用UFS  
>  暂时不要施加任何硬化  
>  安装源（/usr/src)、SSH和调试功能
>
> 3.安装后重新启动，不要忘记“弹出”光盘映像  
>  4.配置SSH、用户等  
>  5.使用pkg安装gdb：`pkg install gdb`  
>  6.按以下方式编译自定义内核
>
>> `cd /usr/src/sys/amd64/conf`  
>  创建一个名为DEBUG的新文件，并添加以下内容
>>  
>>  
>>     include GENERIC
>>     ident DEBUG
>>     makeoptions DEBUG=-g
>>     options DDB
>>     options GDB
>>     options KDB
>>     - Create /etc/make.conf with CFLAGS=-pipe -O0for the content
>>     - Change all-O2to-O0in /usr/src/sys/conf/kern.pre.mk
>>     - Execute cd /usr/src
>>     - Execute make buildkernel
>>     -j8 KERNCONF=DEBUG
>>     - Execute make installkernel
>>     KERNCONF=DEBUG
>>     - Execute reboot`
>>  
>
> 7.执行`sysctl debug.kdb.enter = 1`以检查是否可以进入调试模式
>
>> 注意，调试器在VM窗口中启动，而不是在SSH会话中启动
>
> 8.克隆机器，使用专家模式创建链接克隆，然后保留其余部分  
>  9.克隆机器是目标，而原始机器是调试器主机  
>  10.对于目标，在VM设置中激活串口COM1作为主机管道
>
>> 请勿选中与管道连接的框  
>  路径可以是`/tmp/fbsdpipe`
>
> 11.对调试器执行相同操作
>
>> 选中与管道连接的框，使用与目标相同的路径
>
> 12首先启动目标主机  
>  13.如果需要，更改主机名  
>  14.在`/boot/device.hints`中将`hint.uart.0.flags`更改为0x90  
>  15.重新启动目标  
>  16.启动调试器  
>  17.切换到目标中的调试模式并在调试器会话中执行gdb  
>  18.在调试器中执行：
>  
>  
>     cd /usr/obj/usr/src/amd64.amd64/sys/DEBUG
>     kgdb -b 38400 kernel.debug
>     kgdb> target remote / dev / cuau0
>  
>
> 19.应该看到kgdb中目标的调试器会话
###  2.内核补丁
为了简化漏洞利用测试并避免每次运行等待很长时间，`m_dispose_extcontrolm()`中的补丁是一种可能的解决方案。需要在函数末尾添加以下内容：
    1618    }
    1619    if (fp->f_count == 1234) fp->f_count = 0xfffffff2;
    1620  }
这种方法还需要替换所有代码文件中的for循环，使用以下代码准备UaF（基于减少i的上限并且一次只发送一个文件描述符）：
    for (i = 0; i f_type == DTYPE_VNODE &&
    565      (fp->f_vnread_flags & FDEVFS_VNODE) == 0) {
    566      bwillwrite();
    567      if (fd == 16000)
    568          pause("", 100);
    569  }
需要在所有代码文件中改变对open（）的调用为一下内容，以便打开临时文件：
    do {
      if ((fd = open_tmp()) == -1) {
        perror("open_tmp");
        exit(1);
      }
    } while(fd != 16000);
`test_rd_only_write.c`还需要使用最后一个内核补丁。`sys/kern/sys_generic`中,在函数`kern_writev()`调用`fget_write()`之后，需要以下补丁：
    491  if (fd == 22)
    492    __asm__("int3");
这产生了一个断点，允许更换struct文件对象，如概念验证所述。