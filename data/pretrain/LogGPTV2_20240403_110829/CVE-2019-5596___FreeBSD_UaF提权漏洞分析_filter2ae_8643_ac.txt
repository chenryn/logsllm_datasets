### 优化后的文本

#### 代码段
```c
2569 while (buf_dirty_count_severe()) {
2570     bdirtywait = 1;
2571     msleep(&bdirtywait, &bdirtylock, (PRIBIO + 4), "flswai", 0);
2572 }
2573 mtx_unlock(&bdirtylock);
2574 }

2578 /*
2579 * Return true if we have too many dirty buffers.
2580 */
2581 int
2582 buf_dirty_count_severe(void)
2583 {
2584     return (!BIT_EMPTY(BUF_DOMAINS, &bdhidirty));
2585 }
```

#### 关键点解释
最值得注意的是第2571行的`msleep()`函数。根据函数手册，`sleep()`函数会使线程进入休眠状态，直到被唤醒。通过检查唤醒通道`bdirtywait`可以发现，线程将由`vfs_bio.c`中的`buf_daemon()`调用的`bdirtywakeup()`函数唤醒。

`msleep()`的调用条件与`buf_daemon()`的目的相关联：如果内核持有过多脏缓冲区（即等待写入的缓冲区），则`buf_dirty_count_severe()`返回1，并唤醒`buf_daemon()`执行刷新操作以减少脏缓冲区数量。之后，调用`bdirtywakeup()`来唤醒在第2571行等待的所有写操作。

有两个内核变量`lodirtybuffers`和`hidirtybuffers`用于监控脏缓冲区的数量。这些变量在程序启动时设置，取决于RAM大小（可以通过`sysctl vfs.hidirtybuffers`和`sysctl vfs.lodirtybuffers`查看特定系统的值）。如果脏缓冲区数量超过`hidirtybuffers`，则设置`bdhidirty`位（第2585行），并使`buf_dirty_count_severe()`返回1，从而触发`msleep()`。

为了快速增加脏缓冲区数量，一种简单的方法是打开大量引用同一文件的文件流。在使用`fopen()`打开文件流后，在下次调用`fopen()`之前应先取消相应文件的链接。如果exploit尝试并行写入这些文件流，脏缓冲区数量将增加。此技术的演示可以在`test_dirty.c`中找到。

当前exploit的工作原理如下：一旦脏缓冲区数量足够，另一个线程会收到信号，尝试写入先前打开的随机可写文件。同时，向另一个线程发送触发UaF的信号并打开只读文件。通过关闭用于准备UaF场景的文件描述符并重复该场景（此时`f_count`等于2）来触发UaF。现在打开只读文件将导致struct文件对象的转换。

为了提高exploit赢得竞争条件的概率，尽可能让UaF触发线程和写入线程在不同的CPU核心上运行，并且让UaF延迟几微秒触发。如果写入线程的操作未完成，exploit可能会导致内核崩溃，因为`_fdrop()`会在free之后立即触发崩溃。

任意写入的概念验证可以在`arbitrary_file_write`中找到。需要注意的是，`hammer`线程必须同步，否则继续创建线程并触发漏洞会导致攻击不可靠。此外，同步写入会更快地触发`msleep()`条件。

#### 完成最终exploit的挑战
- **获取root权限**：kingcope于2005年发布的[FreeBSD root exploit](https://www.exploit-db.com/exploits/1230)使权限提升变得容易。该exploit通过写入`/etc/libmap.conf`文件实现权限提升。
- **防止内核崩溃**：崩溃的原因是程序试图关闭它认为打开的所有文件描述符，但UaF使引用计数器很小，导致`_fdrop()`中的判断失败。解决方法是通过第三次调用`open()`来获取损坏的struct文件的文件描述符，并增加`f_count`的值，防止内核崩溃。

#### 结论及下一步打算
本文介绍了在FreeBSD中利用的一个简单但易被忽视的漏洞。虽然UaF触发器的开发非常简单，但研究利用漏洞的方法需要付出很多努力。主要目的是研究内核代码的合理工程以及FreeBSD漏洞write-up的稀缺性。据作者所知，这是首次详细描述此漏洞的工作原理和技术。

下一步打算：
1. 目前，漏洞利用技术仅适用于UFS。由于ZFS的脏缓冲机制不同，该技术不适用于ZFS，因此需要找到另一种延迟机制。
2. 通过执行大量的并行写入来创建脏缓冲区的代码不够优化，可能有其他方法来创建写延迟。
3. 可能有完全不同的方式来利用此漏洞，例如欺骗suid程序从用户提供的文件中读取数据。

#### 附录：环境设置
为了测试和调试漏洞，选择了VirtualBox。以下是详细的设置步骤：

##### VirtualBox设置
1. 从这里获取FreeBSD-12-RELEASE disc1。
2. 将所有内容安装到新的VirtualBox VM中，使用UFS，暂时不要施加任何硬化，安装源、SSH和调试功能。
3. 安装后重新启动，配置SSH、用户等。
4. 使用pkg安装gdb：`pkg install gdb`。
5. 按以下方式编译自定义内核：
   ```sh
   cd /usr/src/sys/amd64/conf
   创建一个名为DEBUG的新文件，并添加以下内容：
   include GENERIC
   ident DEBUG
   makeoptions DEBUG=-g
   options DDB
   options GDB
   options KDB
   创建/etc/make.conf文件，内容为CFLAGS=-pipe -O0。
   修改/usr/src/sys/conf/kern.pre.mk中的-O2为-O0。
   执行cd /usr/src
   执行make buildkernel -j8 KERNCONF=DEBUG
   执行make installkernel KERNCONF=DEBUG
   执行reboot
   ```
6. 执行`sysctl debug.kdb.enter = 1`以检查是否可以进入调试模式。
7. 克隆机器，使用专家模式创建链接克隆，然后保留其余部分。
8. 对目标和调试器主机进行相应的串口设置。
9. 启动目标主机，更改主机名，修改`/boot/device.hints`，重启目标。
10. 启动调试器，切换到目标中的调试模式并在调试器会话中执行gdb。

##### 内核补丁
为了简化漏洞利用测试，可以在`m_dispose_extcontrolm()`中添加补丁：
```c
if (fp->f_count == 1234) fp->f_count = 0xfffffff2;
```
还需要替换所有代码文件中的for循环，使用以下代码准备UaF：
```c
for (i = 0; i < f_type == DTYPE_VNODE && (fp->f_vnread_flags & FDEVFS_VNODE) == 0) {
    bwillwrite();
    if (fd == 16000)
        pause("", 100);
}
```
需要在所有代码文件中改变对`open()`的调用：
```c
do {
    if ((fd = open_tmp()) == -1) {
        perror("open_tmp");
        exit(1);
    }
} while(fd != 16000);
```
`test_rd_only_write.c`还需要在`sys/kern/sys_generic`中添加断点：
```c
if (fd == 22)
    __asm__("int3");
```

这样可以产生一个断点，允许更换struct文件对象，如概念验证所述。