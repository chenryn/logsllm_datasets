In the last ten years, several approaches have been proposed
to mitigate the exploits of these errors.
Watchdog [32] and its successor WatchdogLite [29] both
leverage hardware supports to store and check allocation meta-
data to prevent use-after-free vulnerabilities. Softbound [30]
and CETS [31] are software-based approaches that aim to
prevent memory-corruption errors at compile-time. Softbound
enforces spatial memory safety by storing base and bound
information as metadata for every pointer, while CETS enforces
temporal memory safety by storing unique identifiers for each
object, which are then used to check if the object is still
allocated upon pointer dereferences. Notably, although these
memory safety techniques claim full memory safety, they
currently do not cover uninitialized use as a prevention target. In
contrast to these metadata-based approaches, DieHard [4] and
its successor, DieHarder [34] both focus on randomizing the
location of heap objects to make dangling-pointer dereferences
hard to exploit. Since both techniques focus on heap objects,
they cannot detect and prevent uninitialized-use errors on the
stack. StackArmor [10] also adopts randomization to achieve
the memory safety for stack. All these randomization-based
memory-safety techniques are probabilistic.
IX. DISCUSSION
In this section, we discuss the potential limitations of
targeted stack-spraying and corresponding defenses. We also
discuss the requirements to port targeted stack-spraying to other
programs such as web browsers.
A. Exploitability of Uninitialized-Use Vulnerabilities
Not all uninitialized-use vulnerabilities are exploitable. First,
in order to benefit from targeted stack-spraying, the execution
path that triggers an uninitialized-use vulnerability must not
overwrite the prepared malicious data. Otherwise, the targeted
stack-spraying technique will lose control of the uninitialized
memory thus cannot exploit this uninitialized-use vulnerability.
13
To verify if the prepared data persists until triggering the
uninitialized-use vulnerability, attackers can obtain the address
of the instruction using the uninitialized memory and use
kprobes to intercept the instruction to verify if the prepared
data persists. Second, our current deterministic stack spraying
does not consider the case in which the preparation of the
malicious data occurs in the same syscall that also triggers
the uninitialized-use vulnerability. We ensure only that the
prepared malicious data persists until the entry point of the
syscall triggering the uninitialized-use vulnerability.
B. Porting to Other Programs
To port the deterministic stack spraying technique to other
programs such as the JavaScript engine in web browsers, we
need interface definition (e.g. the JavaScript API), a targeted
symbolic execution engine (e.g Kudzu [39]), and a fuzzer
(e.g. jsfunfuzz [1]). Test suites are usually available for well-
maintained programs, which can be used to automatically
generate the test cases needed for symbolic execution and
fuzzing. When these resources are available, the deterministic
stack spraying technique can be conveniently ported to support
other programs. To port the exhaustive spraying technique
to other programs, we only need to provide the function for
allocating large memory and the size of available memory.
C. Improving Mitigation and Other Defenses
As mentioned in §VII, we can efficiently mitigate
uninitialized-use exploits by zero-initializing all pointer-type
fields for which the compiler cannot prove that they are properly
initialized before reaching a sink (i.e., they are used). This
lightweight approach works for most cases. However, false
negatives cannot be fully excluded: If a pointer is modified
by (or depends on) an uninitialized non-pointer value, zero-
initializing this pointer cannot effectively prevent the exploits
because the resulting pointer is still controllable by attackers if
they can control the non-pointer value. Therefore, one possible
improvement for our proposed defense is to zero-initialize non-
pointer values as well. Two approaches that already offer a
broader defense in this respect are PaX’s STACKLEAK [46]
and split kernel [20] (see §VIII for details). Both approaches
provide strong security to prevent uninitialized-use exploits,
but come at the cost of a significant runtime overhead [26].
As such, a sophisticated inter-procedural and field-sensitive
analysis is necessary to filter out safe allocations. We leave
this challenging problem for future work.
Another defense direction is to defeat
targeted stack-
spraying. A mitigation against the deterministic stack spraying
technique is to randomly adjust the stack base upon syscall
entry so that the malicious data prepared in the previous syscall
may not overlap the uninitialized variable in the vulnerable
syscall. Since the kernel stack has only 8KB or 16KB, the
entropy of such a randomization is limited. To detect the
exhaustive memory spraying technique, systems can monitor a
large amount of process creations or large memory allocations.
However, this spraying technique can be stealthy by reducing
the amount of process creations and the size of memory
allocations, and probing more times.
14
X. CONCLUSION
Using uninitialized variables (uninitialized use) constitutes
a common type of memory error in the Linux kernel. Reliably
exploiting uninitialized uses on the kernel stack has been
considered infeasible since the code executed prior to triggering
the vulnerability must leave an attacker-controlled pattern on the
stack. As a consequence, uninitialized uses are widely tolerated
as undefined behaviors, and full memory safety techniques
such as SoftBound+CETS therefore exclude uninitialized use
as a prevention target. Moreover, uninitialized uses are even
intentionally used as a randomness source by popular systems
such as OpenSSL.
We have shown in this paper that uninitialized use consti-
tutes a severe attack vector that future memory safety techniques
should seriously defend against. We have proposed the fully
automated targeted stack-spraying approach, which includes
a deterministic stack spraying technique and an exhaustive
memory spraying technique. While exhaustive memory spray-
ing reliably controls 89% of the kernel stack on average,
deterministic stack spraying controls 32% of the frequently
used stack region, which cannot be reached by exhaustive
memory spraying. Therefore, attackers can use the targeted
stack-spraying approach to readily exploit an uninitialized-
use vulnerability for a privilege escalation attack. To mitigate
uninitialized use exploits, we have proposed a compiler-based
mechanism, which initializes potentially unsafe pointer-type
fields with almost no performance overhead.
ACKNOWLEDGMENT
We thank Chengyu Song, Taesoo Kim, Insu Yun, and the
anonymous reviewers for their valuable feedback. This work
was supported by the German Federal Ministry for Education
and Research (BMBF) through funding for the Center for
IT-Security, Privacy and Accountability (CISPA). Kangjie Lu
and Wenke Lee were supported in part by the NSF award
CNS-1017265, CNS-0831300, CNS-1149051, CNS-1563848
and DGE-1500084, by the ONR under grant N000140911042
and N000141512162, by the DHS under contract N66001-
12-C-0133, by the United States Air Force under contract
FA8650-10-C-7025, by the DARPA Transparent Computing
program under contract DARPA-15-15-TC-FP-006, by the
ETRI MSIP/IITP[B0101-15-0644]. Any opinions, findings,
conclusions or recommendations expressed in this material
are those of the authors and do not necessarily reflect the
views of the BMBF, NSF, ONR, DHS, United States Air Force,
DARPA or MSIP.
REFERENCES
[1] jsfunfuzz: a JavaScript-based fuzzer, 2016.
https://github.com/
MozillaSecurity/funfuzz.
[2] Kernel Probes, 2016. https://www.kernel.org/doc/Documentation/kprobes.
txt.
kvm.org/page/Virtio.
[3] Virtio: Paravirtualized drivers for kvm/Linux, 2016. http://www.linux-
[4] E. D. Berger and B. G. Zorn. Diehard: probabilistic memory safety for
unsafe languages. In Acm sigplan notices, volume 41, pages 158–168.
ACM, 2006.
[5] E. Bosman, K. Razavi, H. Bos, , and C. Giuffrida. Dedup est machina:
Memory deduplication as an advanced exploitation vector. In Proceedings
of the 37th IEEE Symposium on Security and Privacy (Oakland), San
Jose, CA, USA, May 2016. IEEE.
[6] D. Bruening and Q. Zhao. Practical memory checking with dr. memory.
In Proceedings of the 2004 International Symposium on Code Generation
and Optimization (CGO), Washington, DC, Mar. 2011.
[7] C. Cadar, D. Dunbar, and D. Engler. Klee: Unassisted and automatic
generation of high-coverage tests for complex systems programs.
In
Proceedings of the 8th USENIX Symposium on Operating Systems Design
and Implementation (OSDI), San Diego, CA, Dec. 2008.
[8] Chen. Hey Man, Have You Forgotten To Initialize Your Memory?, 2015.
URL https://www.blackhat.com/docs/eu-15/materials/eu-15-Chen-Hey-
Man-Have-You-Forgotten-To-Initialize-Your-Memory.pdf.
[9] H. Chen, Y. Mao, X. Wang, D. Zhou, N. Zeldovich, and M. F. Kaashoek.
Linux kernel vulnerabilities: State-of-the-art defenses and open problems.
In Proceedings of the Second Asia-Pacific Workshop on Systems, page 5.
ACM, 2011.
[10] X. Chen, A. Slowinska, D. Andriesse, H. Bos, and C. Giuffrida.
StackArmor: Comprehensive Protection from Stack-based Memory Error
Vulnerabilities for Binaries. In Proceedings of the 2015 Annual Network
and Distributed System Security Symposium (NDSS), San Diego, CA,
Feb. 2015.
[11] V. Chipounov, V. Kuznetsov, and G. Candea. S2e: A platform for in-vivo
multi-path analysis of software systems. In Proceedings of the Sixteenth
International Conference on Architectural Support for Programming
Languages and Operating Systems, 2011.
[12] K. Cook.
Kernel Exploitation Via Uninitialized Stack.
2011.
https://www.defcon.org/images/defcon-19/dc-19-presentations/Cook/
DEFCON-19-Cook-Kernel-Exploitation.pdf.
[13] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen, A.-R. Sadeghi,
S. Brunthaler, and M. Franz. Readactor: Practical code randomization
resilient to memory disclosure. In 2015 IEEE Symposium on Security
and Privacy, pages 763–780. IEEE, 2015.
[14] Y. Ding, T. Wei, T. Wang, Z. Liang, and W. Zou. Heap taichi: exploiting
memory allocation granularity in heap-spraying attacks. In Proceedings
of the 26th Annual Computer Security Applications Conference, pages
327–336. ACM, 2010.
[15] M. Egele, P. Wurzinger, C. Kruegel, and E. Kirda. Defending browsers
against drive-by downloads: Mitigating heap-spraying code injection
In International Conference on Detection of Intrusions and
attacks.
Malware, and Vulnerability Assessment, pages 88–106. Springer, 2009.
[16] H. Flake. Attacks on Uninitialized Local Variables. 2006. http://www.
blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf.
[17] M. "j00ru" Jurczyk. The story of CVE-2011-2018 exploitation, 2012. URL
http://j00ru.vexillium.org/blog/20_05_12/cve_2011_2018.pdf. [Online;
accessed 16-Aug-2016].
[18] D. Jones. Trinity: A Linux System call fuzz tester, 2015.
http:
//codemonkey.org.uk/projects/trinity.
[19] V. P. Kemerlis, G. Portokalidis, and A. D. Keromytis. kguard: Lightweight
kernel protection against return-to-user attacks. In Proceedings of the
21st USENIX Security Symposium (Security), Bellevue, WA, Aug. 2012.
[20] A. Kurmus and R. Zippel. A tale of two kernels: Towards ending kernel
In Proceedings of the 2014 ACM
hardening wars with split kernel.
SIGSAC Conference on Computer and Communications Security, pages
1366–1377. ACM, 2014.
[21] J. Lee, H. Ham, I. Kim, and J. Song. Poster: Page table manipulation
attack. In Proceedings of the 22nd ACM SIGSAC Conference on Computer
and Communications Security, pages 1644–1646. ACM, 2015.
[22] T. Lengauer and R. E. Tarjan. A fast algorithm for finding dominators
in a flowgraph. ACM Trans. Program. Lang. Syst., 1(1), Jan. 1979.
[23] LLVM. LLVM Alias Analysis Infrastructure, 2016. http://llvm.org/docs/
org/index.php/Main_Page.
[26] K. Lu, C. Song, T. Kim, and W. Lee. UniSan: Proactive Kernel Memory
Initialization to Eliminate Data Leakages. In Proceedings of the 23rd
ACM Conference on Computer and Communications Security (CCS),
Vienna, Austria, Oct. 2016.
[27] L. W. McVoy and C. Staelin. Lmbench: Portable tools for performance
analysis. In USENIX Annual Technical Conference, 1996.
[28] D. J. Musliner, S. E. Friedman, M. Boldt, J. Benton, M. Schuchard,
P. Keller, and S. McCamant. Fuzzbomb: Autonomous cyber vulnerability
detection and repair. In Fourth International Conference on Communica-
tions, Computation, Networks and Technologies (INNOV 2015), 2015.
[29] S. Nagarakatte, M. M. K. Martin, and S. Zdancewic. Watchdoglite:
Hardware-accelerated compiler-based pointer checking. In Proceedings of
the 2014 International Symposium on Code Generation and Optimization
AliasAnalysis.html.
[24] LLVM. The LLVM Compiler Infrastructure, 2016. http://llvm.org/.
[25] LLVMLinux. The LLVMLinux Project, 2016. http://llvm.linuxfoundation.
(CGO).
[30] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. SoftBound:
In
Highly compatible and complete spatial memory safety for C.
Proceedings of the 2009 ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), Dublin, Ireland, June
2009.
[31] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. CETS: compiler
enforced temporal safety for C. In International Symposium on Memory
Management, 2010.
[32] S. Nagarakatte, M. M. Martin, and S. Zdancewic. Watchdog: Hardware for
safe and secure manual memory management and full memory safety. In
ACM SIGARCH Computer Architecture News, volume 40, pages 189–200.
IEEE Computer Society, 2012.
[33] V. Nossum. Getting Started With kmemcheck, 2015. https://www.kernel.
org/doc/Documentation/kmemcheck.txt.
[34] G. Novark and E. D. Berger. Dieharder: securing the heap. In Proceedings
of the 17th ACM conference on Computer and communications security,
pages 573–584. ACM, 2010.
[35] J. Obdrzalek and M. Trtik. Efficient loop navigation for symbolic
In Proceedings of the 9th International Conference on
execution.
Automated Technology for Verification and Analysis, ATVA’11, 2011.
[36] S. Özkan. CVE Details: Linux kernel security vulnerabilities - gain privi-
lege, 2016. URL https://www.cvedetails.com/vulnerability-list/vendor_id-
33/product_id-47/opgpriv-1/Linux-Linux-Kernel.html. [Online; accessed
12-Aug-2016].
[37] S. Özkan. CVE Details: Linux kernel security vulnerabilities - overview,
2016. URL https://www.cvedetails.com/product/47/Linux-Linux-Kernel.
html?vendor_id=33l. [Online; accessed 15-Aug-2016].
[38] P. Ratanaworabhan, V. B. Livshits, and B. G. Zorn. Nozzle: A defense
In USENIX Security
against heap-spraying code injection attacks.
Symposium, pages 169–186, 2009.
[39] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song.
A symbolic execution framework for javascript. In Proceedings of the
31th IEEE Symposium on Security and Privacy (Oakland), Oakland, CA,
May 2010.
[40] M. Seaborn and T. Dullien. Exploiting the dram rowhammer bug to gain
kernel privileges. Black Hat, 2015.
[41] J. Seward and N. Nethercote. Using Valgrind to detect undefined value
errors with bit-precision. In Proceedings of the 2004 USENIX Annual
Technical Conference (ATC), Anaheim, CA, June–July 2005.
[42] C. Song, C. Zhang, T. Wang, W. Lee, and D. Melski. Exploiting and
protecting dynamic code generation. In NDSS, 2015.
[43] J. Song and J. Alves-Foss. The darpa cyber grand challenge: A
competitor’s perspective. IEEE Security & Privacy, 13(6):72–76, 2015.
[44] E. Stepanov and K. Serebryany. MemorySanitizer: fast detector of unini-
tialized memory use in C++. In Proceedings of the 2015 International
Symposium on Code Generation and Optimization (CGO).
[45] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna. Driller: Augmenting fuzzing
through selective symbolic execution. In Proceedings of the Network
and Distributed System Security Symposium, 2016.
[46] P. Team. PaX - gcc plugins galore, 2015. URL https://pax.grsecurity.
net/docs/PaXTeam-H2HC13-PaX-gcc-plugins.pdft. [Online; accessed
15-Aug-2016].
[47] H. A. Thanassis, C. S. Kil, and B. David. Aeg: Automatic exploit
generation. In ser. Network and Distributed System Security Symposium,
2011.
[48] L. Torvalds. Linux Kernel Git Repository, 2016. URL git://git.kernel.
org/pub/scm/linux/kernel/git/torvalds/linux.git. [Online; accessed 5-Aug-
2016].
[49] X. Wang, H. Chen, A. Cheung, Z. Jia, N. Zeldovich, and M. F. Kaashoek.
Undefined behavior: What happened to my code? In Proceedings of the
3rd Asia-Pacific Workshop on Systems (APSys), Seoul, South Korea, July
2012.
[50] T. Wei, T. Wang, L. Duan, and J. Luo. Secure dynamic code generation
against spraying. In Proceedings of the 17th ACM conference on Computer
and communications security, pages 738–740. ACM, 2010.
[51] W. Xu, J. Li, J. Shu, W. Yang, T. Xie, Y. Zhang, and D. Gu. From collision
to exploitation: Unleashing use-after-free vulnerabilities in linux kernel.
In Proceedings of the 22nd ACM SIGSAC Conference on Computer and
Communications Security, pages 414–425. ACM, 2015.
[52] D. Ye, Y. Sui, and J. Xue. Accelerating dynamic detection of uses of
undefined values with static value-flow analysis. In Proceedings of the
2014 International Symposium on Code Generation and Optimization
(CGO).
15