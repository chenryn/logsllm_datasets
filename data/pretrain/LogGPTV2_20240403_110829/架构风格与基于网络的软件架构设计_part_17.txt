第6章 经验与评估 59
6.2.5 REST在URI中的不匹配
就像大多数真实世界中的系统一样，并非所有已部署的Web架构的组件都服从Web架
构设计中给出的每一个约束。REST既被用来作为一个定义架构改进的方法，也被用来识别
架构的不匹配。当由于无知或者疏忽，一个软件实现以违反架构约束的方式来部署时，就会
发生不匹配。尽管不匹配通常无法避免，但是有可能在它们定型之前识别出它们。
尽管URI的设计与REST的标识符的架构概念相匹配，单单依靠语法却不足以迫使命名
权威按照资源模型来定义他们自己的URI。一种形式的滥用是在由一个超媒体响应形式的表
述（a hypermedia response representation）所引用的所有的URI中包括标识当前用户的信息。
这样内嵌的用户id能够被用来维护服务器端会话的状态，通过记录用户的动作来跟踪他们
的行为，或者跨多个动作携带用户的首选项（例如Hyper-G网关[84]）。尽管如此，由于违
反了REST的约束，这些系统会导致共享缓存变得效率低下，这降低了服务器的可伸缩性，
并且在一个用户与其他用户共享那些引用时会导致不希望的结果。
另一个与REST的资源接口的冲突发生在当软件试图将Web看作一个分布式文件系统
的时候。因为文件系统暴露出了它们的信息的实现，有工具能够跨越多个站点对这些信息做
镜象，来作为一种负载均衡和使内容以更接近用户的方式重新分布的方法。然而，他们能够
这样做仅仅是因为文件拥有一组固定的语义（一个命名的字节序列），能够很容易地被复制。
与之相反，试图将一个Web服务器的内容以文件的形式做镜象将会失败，因为资源接口并
非总是匹配一个文件系统的语义，而且资源的表述中同时包括有数据和元数据（这对于一个
表述的语义来说是非常重要的）。Web服务器的内容能够在远程站点上被复制，但是应该仅
仅复制完整的服务器机制和配置，或者有选择地仅仅复制那些其表述已知为静态的资源（例
如，与Web站点相联系的缓存网络通过将特定的资源表述复制到整个Internet的边缘，以降
低延迟和减轻来源的服务器的负担）。
6.3 将REST应用于HTTP
超文本转移协议（HTTP）在Web架构中有一个特殊的角色，既作为在Web组件之间通
信的主要的应用级协议，也作为特别为转移资源的表述而设计的唯一的协议。与URI不同，
需要做大量的修改才能使HTTP能够支持现代的Web架构。HTTP实现的开发者对于采纳提
议的增强很保守，因此在对HTTP的扩展能够被部署之前，需要对扩展加以证实，并且要受
到对于标准的评论的影响。REST被用来识别出现有的HTTP实现的问题，指定一个能够与
HTTP/1.0协议[19]互操作的协议子集，分析提议的HTTP/1.1[42]的扩展，并且提供部署
HTTP/1.1的动机和驱动因素。
由REST识别出的在HTTP中的关键问题领域包括：为新协议版本的部署制订计划、将
对消息的解析与HTTP的语义以及底层的传输层（TCP）分离开、明确区分权威的和非权威
的响应、对于缓存的细粒度的控制、以及协议的各种无法自描述的方面。REST也被用来为
基于HTTP的Web应用的性能建模，并且预测作为持久连接和内容协商的这些扩展对Web
应用产生的影响。最后，REST被用来对标准化的HTTP扩展的范围加以限制，仅限于那些
适合于此架构模型的扩展，而不是允许误用HTTP的应用也同样地对标准产生影响。
6.3.1 可扩展性
REST的一个主要的目标是在一个已部署的架构中支持逐渐的和片段的修改。我们对
HTTP做了修改，通过引入版本控制的需求，并且扩展每个协议的语法元素的规则来支持这
个目标。
第6章 经验与评估 60
6.3.1.1 协议版本控制
HTTP是一个协议家族，通过主的和次的版本号来区分。该家族成员共享“HTTP”这个
名称，这主要是因为当与一个基于“http”这个URI名字空间的服务直接通信时，它对应于期
待的协议。一个连接器必须服从包括于每一个消息[90]中的HTTP-version协议元素之上的约
束。
一个消息的HTTP-version代表了发送者对于协议的支持能力，以及正在发送的消息的
总的兼容性（主版本号）。这允许客户端使用一个简化的（HTTP/1.0）功能子集发送一个正
常的HTTP/1.1请求，同时向接收者表明它有能力支持完全的HTTP/1.1通信。换句话说，它
提供了一个在HTTP协议范围内进行试探性的协议协商的形式。一个请求/响应链之上的每
一个连接都能够在它所支持的最佳协议级别上执行操作，而不管作为这个链条一部分的某些
客户端或服务器。
协议的意图是服务器应该总是使用它能够理解的协议的最高次版本，以及与客户端的请
求消息相同的主版本来作出响应。其限制就是服务器不能使用那些高级别协议的可选功能，
这些功能是禁止被发送给一个旧版本的客户端的。协议中不存在无法与相同主版本的所有其
他次版本共同使用的必需功能（译者注：协议的功能分为必需功能和可选功能两类，必需功
能是相同的主版本必须要支持的），否则将是一种对于协议所作的不兼容（incompatible）
的改变，从而要求通信的双方不得不改变协议的主版本。能够依赖于次版本号改变的HTTP
功能，仅限于那些被通信中的直接邻居解释的功能，因为HTTP并不要求整个请求/响应链
中的所有中间组件都使用相同的版本。
这些规则的存在协助了多个协议修订版的部署，并且防止了HTTP架构师遗忘掉协议的
部署是其设计的一个重要方面。这些规则是通过使得对于协议兼容的改变和不兼容的改变容
易区别来做到这一点的。兼容的改变很容易部署，对于协议接受能力的差异能够在协议流
（protocol stream）中进行沟通。不兼容的改变难以部署，因为它们在协议流能够开展通信
之前，必须做一些工作来确定协议的接受能力。
6.3.1.2 可扩展的协议元素
HTTP包括了很多单独的名字空间，每一个都有不同的约束，但是不能限制可扩展性是
所有名字空间的共同需求。一些名字空间由单独的Internet标准来管理，并且由多个协议共
享（例如，URI模式（URI schemes）[21]、媒体类型（media types）[48]、MIME头信息字
段名（MIME header field names）[47]、字符集值（charset values）、语言标签（language
tags））。而其他的名字空间由HTTP来管理，包括：方法名称、响应状态码、非MIME头
信息字段名、以及在标准的HTTP头信息字段中的值。既然早期的HTTP没有为在这些名字
空间中的改变如何来部署定义一组一致的规则，这就成为了规范工作需要面对的头等问题之
一。
HTTP请求的语义通过请求方法的名称来表示。任何时候当一组可标准化的语义能够被
客户端、服务器和任何它们之间的中间组件共享时，则允许对方法进行扩展。不幸的是，早
期的HTTP扩展，明确地说，即HEAD方法，使得对于一个HTTP响应消息的解析依赖于要
知道请求方法的语义。这导致了部署上的困难：如果接收者需要在一个方法能够被一个中间
组件安全地转发之前知道它的语义，那么所有的中间组件都必须在新的方法能够被部署之前
进行更新（译者注：中间组件需要进行更新以理解新的方法，无法简单地将其转发）。
通过将解析和转发HTTP消息的规则与新的HTTP协议元素的相关语义分离开，这个部
署问题得到了解决。例如，只有在HEAD方法中Content-Length头信息字段才能够表示消息
体长度之外的含义，没有新的方法能够改变对消息长度的计算。GET和HEAD也是仅有的
两个方法，在其中有条件的请求头信息字段具有刷新缓存的语义，而对于所有其他的方法，
第6章 经验与评估 61
请求头信息字段的含义是需要满足的一个前提（a precondition）。
同样地，HTTP需要一个通用的规则来解释新的响应状态码，这样新的响应能够进行部
署而不会严重损害老的客户端。因此我们扩大了这个规则，规定每个状态码属于一个类别，
通过三位十进制数的第一位数字来表示：100-199表示消息中包含一个临时的信息响应，
200-299表示请求成功，300-399表示请求需要被重定向到另一个资源，400－499表示客户
端发生了一个不应该重复的错误，500-599表示服务器端遇到了一个错误，但是客户端稍后
可以得到一个更好的响应（或者通过某个其他服务器）。如果接收者不理解一个消息中的状
态码的特定语义，那么它们必须将该状态码按照与同一类别中状态码为x00时相同的方式来
处理。就像是方法名称的规则一样，这个可扩展性的规则在当前的架构上添加了一个需求，
这样架构就能够预见到未来的改变。改变因此能够被部署在一个现有架构之上，而无须害怕
出现不利的组件反应（adverse component reactions）。
6.3.1.3 升级
在HTTP/1.1中新增的Upgrade头信息字段，通过允许客户端在一个旧的协议流中表达
它希望使用一个更好的协议，从而减少了部署不兼容的改变的难度。Upgrade就是特别设计
来支持有选择地将HTTP/1.x替换为其他的，可能对一些任务更有效率的未来的协议。这样，
HTTP不仅仅支持内部的可扩展性，也可以在一个活跃的连接期间完全将其自身替换为其他
的协议。如果服务器支持改进的协议，并且希望进行切换，它简单地响应一个101状态码并
且继续，就好像请求是在那个升级的协议中接收到的一样。
6.3.2 自描述的消息
组件之间的REST约束的消息（REST constrains messages）是自描述的，以便支持中间
组件对于交互的处理。然而，早期HTTP的一些方面并不是自描述的，包括缺乏在请求中对
于主机的标识，无法依照语法来区分消息控制数据和表述元数据，无法区分仅仅想要立即与
对方连接的控制数据和想要发送给所有接收者的元数据，缺乏对于必需扩展（mandatory
extensions）和使用分层的编码来描述表述的元数据的支持。
6.3.2.1 主机
早期HTTP设计中一个最糟糕的错误是，决定不发送作为一个请求消息的目标的完整的
URI，而是仅仅发送那些没有用于建立连接的部分。其所做的假设是：一个服务器将基于连
接的IP地址和TCP端口得知它自己的命名权威。然而，这个假设没有预测到多个命名权威
可能存在于单个服务器上，随着Web和域名（http的URL名字空间中命名权威的基础）以
指数的速率增长，远远超出了新的IP地址的供应量，这成为了一个非常紧急的问题。
为HTTP/1.0和HTTP/1.1而定义和部署的解决方案是：在一个请求消息的Host头信息
字段中包括目标URL的主机信息。部署这个功能被认为是如此重要，以至于HTTP/1.1规范
要求服务器拒绝任何没有包括一个Host字段的HTTP/1.1请求。得到的结果就是：现在存在
很多大型的ISP服务器，可以在单个IP地址上运行数以万计的基于名字的虚拟主机网站。
6.3.2.2 分层的编码
HTTP为了描述表述的元数据，继承了多用途Internet邮件扩展（MIME）[47]的语法。
MIME没有定义分层的媒体类型，而是倾向于在Content-Type字段值中仅仅包括最外层媒体
类型的标签。然而，这妨碍了一个接收者在不对该层次进行解码的情况下确定一个已编码消
息的性质。一个早期的HTTP扩展通过在Content-Encoding字段中分别列出外层媒体类型的
第6章 经验与评估 62
编码，并且将最内层媒体类型的标签放在Content-Type中解决了这个问题。这是一个糟糕的
设计决策，因为它改变了Content-Type的语义却没有改变它的字段名称，当旧的用户代理遇
到这个扩展时会导致产生混淆。
一种更好的方案是继续将Content-Type看作是最外层的媒体类型，并且在那种类型中使
用一个新的字段来描述内嵌的类型。不幸的是，在第一个扩展的缺点被识别出之前，它已经
被部署了。
REST确实识别出了另外一层编码的需求：将那些编码通过一个连接器添加到一个消息
上，从而改善了消息在网络上的可转移性（transferability）。这个新的层叫做一个转移编码