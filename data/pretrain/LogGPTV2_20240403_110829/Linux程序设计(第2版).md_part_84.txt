虽然因特网上的名字指的总是联网的机器，但它们都将转换为底层的IP地址。比如说，
人们把它称做“四点数”。当一个客户通过套接字做跨网络连接的时候，就需要用到服务器计算
机的IP地址。
服务器计算机上可能有好几个服务项目。客户可以通过一个IP端口来指定一台联网机器上的
某项服务。在系统的内部，确定一个端口的办法是给它分配一个独一无二的16位整数：而在系
始通信之前必须被绑定到一个端口去。
服务器在特定的端口上等待连接的到来。那些常用服务所分配到的端口号在一切UNIX机器
上都是一致的。它们通常（但不总是如此）是一些小于1024的数字。这些端口号包括打印机缓
冲队列（515）、rlogin（513）、ftp（21）和httpd（80）等。其中最后一个就是World Wide Web
（万维网，简称WWW网）用的服务器。在一般情况下，编号小子1024的端口都是为系统服务保
加入jaVa编程群：524621833
---
## Page 443
第14章套接字425
留的，提供相关服务的也只能是具有超级用户权限的进程。X/Open技术规范在netdb.h文件里定
义了一个常数IPPORT_RESERVED，它代表着保留端口号的最大值。
因为标准服务都有标准的端口号，所以计算机就可以在不需要建立正确的端口号的前提下
被此接通。本地服务可以使用非标准的端口地址我们第一个例子里的域就是UNIX文件系统的
域AF_UNIX，即使一台没有联网的计算机上的套接字也可以使用这个域。这个域的底层协议就
是文件的输人/输出，而它的地址就是绝对文件名、我们服务器套接字使用的地址是
server_socket，我们在运行这个程序的时候可以看到它出现在当前子目录里：
其他可供使用的域还包括：按ISO标准中的有关协议组建的网络使用的AF_ISO域和施乐网
络系统（XeroxNetworkSystem）使用的AF_NS等：但这些都不在我们这里的讨论范围之内。
2.套接字类型
一个套接字域可以有多种不同的通信方式，而每种通信方式义有其不同的特性。但
域能够用来构建网络，我们就需要对它的底层网络的特性多加注意。
因特网协议提供了两种截然不同的服务：流（stream）和数据图（datagram）。
流式服务（有点类似于标准的输人/输出流）提供的是-个有序的可靠的双向字节流。也就
是说，被发送的数据不会被丢失、复制或者先后次序被弄乱；错误会被白动纠正而不是报告给
用户。大块消息将被拆分、传输、再重新组合。这很象是一个接收了大量的数据但需要以较小
的数据块来把它写到底层磁盘上去的文件流。流式套接字的行为是可以预见的。
流式套接字被定义为SOCK_STREAM类型，它们是在AF_INET域里通过TCP/IP连接实现的。
它们也是AF_UNIX域里最常见的套接字类型。我们在这一章里的学习将主要集中在
SOCK_STREAM套接字方面，因为它们是人们在编写网络软件时最常用的：
TCP/IP指的是“Transmission Control Protocol/InternetProtocol”（传输控制协议/
因特网协议。IP协议是数据包使用的底层协议，它提供了一台计算机穿过网络到达另
一台计算机的路由安接。TCP协议提供了顺序安排、流控制和再传输功能，保证大数据
传输能够到达目的地。
与此形成鲜明对照的是被定义为SOCK_DGRAM类型的数据图套接字，它不需要建立和维
持一个连接。对数据图的发送长度也有限制。它在网络中传输时不会被拆分，一个数据图就是
一条网络消息，它可能会被丢失、复制或者不按先后次序到达目的地。
数据图套接字是在AF_INET域里通过UDP/IP连接实现的、它提供的是一种无序的非可靠服
务。但因为不需要维持网络连接，所以从资源角度看它们的开销相对要小一些。而且因为不需
要花费时间去建立相关的连接，所以它们也更快。UDP代表着“UserDatagramProtocol”（用户
数据图协议）。
数据图适用于信息服务中的“单击”查询，主要用来提供日常状态信息或者用来完成低优
先级的日志记录操作。它们的优点是服务器的“死亡”不要求客户重新启动。因为基于数据
图的服务器通常不保存与连接有关的信息，所以它们可以在不打扰其客户的前提下停止并重
新启动。
加入jaVva编程群：524621833
---
## Page 444
426Linux程序设计
3.套接字协议
只要底层的传输机制允许不止一个协议来提供要求的套接字类型，我们就可以为套接字挑
选一个特定的协议。在这一章里，我们将把注意力集中在UNIX的网络套接字和文件系统套接字
I.，你可以直接使用其缺省值，不需要再挑选一个协议。
14.2.2创建一个套接字
socket系统调用的作用是创建一个套接字并返回一个能够用来访问该套接字的描述符。它的
定义情况如下所示：
#include 
#include 
int socket(int domain,int type,int pzotocol);
创建出来的套接字是一条通信线路的一个端点。domain参数负责指定地址族，type参数负责
指定与这个套接字一起使用的通信类型，而protocol参数负责指定所使用的协议。
domain参数可以使用的域如表14-1所示：
表14-1
AF_UNIX
UNIX内部（文件系统套接字）
Af_INET
ARPA因特网协议（UNIX网络套接字）
AF_IS0
ISO标准协议
AF_NS
施乐网络系统协议
AF_IPX
NovellIPX协议
AP_APPLETALK
Appletalk DDS
最常用的套接字城是AF_UNIX和AF_INET，前者用于通过UNIX文件系统实现的本地套接
字，后者用于UNIX的网络套接字。AF_INET套接字可以用在穿过包括因特网在内的各种
TCP/IP网络面进行通信的程序里。微软Windows使用的WinSock接口也提供了对这个套接字域
的访问功能。
套接字参数type指定了与新套接字对应的通信特性。它的可取值包括SOCK_STREAM和
SOCK_DGRAM。
SOCK_STREAM是一个有序的、可靠的、基于连接的双向字节流。对一个AF_INET城的套
接字来说，如果在两个流式套接字的两端之间建立的是一个TCP连接，连接时缺省提供的就是这
种类型的套接字。数据可以沿着套接字连接双向传递。TCP协议里所提供的工具能够对长消息进
行拆分和重新组装：并且，如果有数据丢失在网络里，它还能重新发送它。
SOCK_DGRAM是一个数据图服务。我们可以用它来发送最大长度是一个固定值（通常不
太大）的消息，但消息是否会被送达或者消息的先后次序是否会在网络中被重新安排并没有保
证。对AF_INET域的套接字来说，这种类型的通信是由UDP数据图提供的。
通信所用的协议通常是由套接字的类型和套接字的城来决定的，一般不再有可供挑选的余
地：如果还能挑选，就需要用到protocol参数了。“0”选择缺省的协议，我们将在本章所有的例
子里都这样做。
加入jaVa编程群：524621833
---
## Page 445
第14章套接字427
socket系统调用返回的是--个描述符，它在许多方面都类似于一个底层的文件描述符。当这
个套接字和通信线路另一端的套接字连接好以后，我们就可以用read和write系统调用加上这个
描述符在这个套接字上收发数据了。结束一个套接字连接要使用close系统调用。
14.2.3套接字地址
每个套接字域都有它自己的地址格式。对一个AF_UNIX套接字来说，它的地址是由~个定
义在sys/un.h头文件里的sockaddr_un结构描述的
struct sockaddr_un(
char
na_family_t
sun_fanily:
/AY_UNIX*/
sun_path[];
/" pathnane */
因为不间类型的地址都需要传递到对套接字进行处理的系统调用里去，所以定义各种地址
格式时使用的结构也都很相似，每个结构的开始都是一个定义地址类型（即套接字城）的数据
项（即上面的sun_family）。在AF_UNIX域里，套接字的地址是用sockaddr_un结构里sun_path数
据项中的文件名指定的。
sun_family_t是由X/Open技术规范定义的，在现时期的Linux系统上，它被声明为一个short
短整数。此外，sun_path给出的路径名的长度也是有限制的（Linux的规定是108个字符，其他系
统可能会使用灵活性好一点的常数UNIX_MAX_PATH）。因为地址结构在长度方面是不周定的，
所以许多套接字调用都要用到或输出一个用来复制特定地址结构的长度值。
AF_INET域里的套接字地址是由一个定义在netinet/in.h头文件里的sockaddr_in结构确定的，
它至少应该包含如下所示的几个成员：
struct sockaddr_in {
unsigned short int
short fnt
sin_fanily:/AF_INzr*/
struct in_addr
sin_port;
/Interoet address */
/* Port nusber */
)1
sin_addr;
IP地址结构in_addr被定义为：
struct in_addr (
unsigned long int
8_addr;
IP地址中的四个字节组成一个32位的二进制数值。一个AF_INET套接字完全可以由它的域、
IP地址和端口号确定下来。从应用程序的角度看、各种套接字的行为就象是文件描述符，用一
个独一无二的整数就可以把它们表示出来。
14.2.4给套接字起名字
要想让socker调用创建的-个套接字能够被其他进程使用，服务器程序就必须给该套接字起
个名字。因此，AF_UNIX套接字就会关联到一个文件系统的路径名上去，就象我们在server1例
子里看到的那样。AF_INET套接字将关联到一个IP端门号上去。
#include 
int bind(int sockat,const struct sockaddr *address,sise_t address_len)1
加入jaVa编程群：524621833
---
## Page 446
428
Linux程序设计
bind系统调用的作用是把参数address中给出的地址赋值给与文件描述符socket相关联的未命
名套接字。地址结构的长度是通过address_len参数传递的。
地址的长度和类型取决于地址族。bind调用需要用一个与之对应的地址结构指针指向真正的
地址类型（即上面定义里的“struct sockaddr*”）
bind在调用成功时将返回“0”：如果失败，就返回“-1”并把errmo设置为表14-2中的某个值
表14-2
EBADF
该文件描述符无效
FNOTSOCK
该文件述符代表的不是一个套接字
EINVAL
该文件插述符代表的是一个已经命名的套接宁
EADORNOTAVAIL
该地址不可用
EADDRINUSE
该地址已经绑定有一个套接字了
AF_UNIX套接字还多出两个错误代码值见表14-3
表14-3
EACCESS
权限不足，不能创建文件系统中使用的名字
ENOTDIR, ENANETOOLONG
选用的文件名不好
14.2.5创建套接字队列
为了能够在套接字上接受接人的连接，服务器程序必须创建一个队列来保存到达的请求。
这个工作是由listen系统调用完成的。
#include 
Int lieten(int socket,int backlog)1
一台UNIX系统可能会对队列里能够容纳的排队连接的最大个数有限制。在这个最大值的范
围内，listen将把队列长度设置为backlog个连接。在套接字上排队的接人连接个数最多不能超过
这个数字，冉往后的连接将被拒绝，客户的连接请求将会失败。这是listen提供的一个机制，在
服务器程序紧张地处理着上一个客户的时候，后来的连接将被放到队列里排队等候。backlog常
用的值是5。
listen函数在成功时会返回“o"，失败时返回“-1”。它的错误情况包括EBADF、EINVAL和
ENOTSOCK，含义同bind系统调用的有关代码。
14.2.6接受连接
服务器程序创建好命名套接字之后，就可以通过accept系统调用等待客户来建立对该套接字
的连接了。
#include
int accept(int socket, struct sockaddr *address, size_t *address_len);
accept系统调用会等到有客户程序试图连接到由socket参数指定的套接字时才返回。该客户
加入jaVa编程群：524621833
---
## Page 447
第14章套楼字429
就是套接字队列里排在第一位的连接。accept函数将创建出一个新的套接字来与该客户进行通信，
返回的是与之对应的文件描述符。新套接字的类型与服务器监听套接字的类型是样的。
套接字必须事先用一个bind调用进行过命名，并且还要有一个由listen调用分配的连接队列。
调用者客户的地址将被放在address指向的sockaddr结构里：如果我们不关心客户的地址，可以在
这里使用一个空指针。
参数address_len给出了客户结构的长度。如果客户地址的长度超过了这个值，就会被截短，
在调用accept之前，必须把address_len设置为预期的地址长度。当这个调用返回时，address_len
将被设置为调用者客户的地址结构的实际长度
如果套接字队列里没有排队等候的连接，accept将阻塞（程序就不会继续执行了）到有客户
建立连接为止。这个行为可以用O_NONBLOCK标志改变，方法是对这个套接字文件描述符调用
fcntl函数，如下所示：
int flags fcntl（socket,r_GzTrL,0）;
fcnt1(socket,F_SETTL, O_MONBLOCK|flag=):
如果有排队等候的客户连接，accepu函数将返同一个新的套接字文件描述符，否则它将返回
“-1"。其错误原因除类似于bind调用和listen调用中的情况之外，还多出有一个EWOULDBLOCK，
如果前面指定了O_NONBLOCK标志，但队列里没有排队的连接，就会出现这个错误。如渠进程
阻塞在accetp调用里的时候执行被中断了，就会出现EINTR错误。
14.2.7请求连接
当客户想要连接到服务器的时候，它会尝试在--个未命名套接字和服务器的监听套接字之
间建立一个连接。它们用调用connect函数来完成这一工作。
include 
int connect(int socket, const struct sockaddr *address,wize_t address_len):
参数socket指定的套接字将连接到参数address指定的服务器套接字上去，服务器套接字的长
度由参数address_len指定。套接字必须是通过socket调用获得的一个有效的文件描述符。
如果操作成功，connect将返回“0”；如果失败，就返回“-1”。这个调用可能出现的错误
情况见表14-4：
泰14-4
EBADF
传递到socket里的文件件描述符无效
EALREADY
该套接字上已经有了一个正在使用的连接
ETIMEDOUT
连接操作超时
ECONNREFUSED
连接请求被服务器拒绝
如果连接不能立刻建立起来，connect会阻塞-段不确定的倒计时时间，这段倒计时时间结
束后，这次连接就会流产，connect调用失败。但如果connect调用是被一个信号中断的，副这个
加入jaVa编程群：524621833
---
## Page 448
430Linux程序设计
信号又得到了处理，connect还是会失败（errno将被设置为EINTR），可这次连接尝试却不会流
产，它会以异步方式继续尝试。
类似于accept，connect的阻塞特性可以用置位该文件描述符的O_NONBLOCK标志的办法米
改变。在这种情况下，如果连接不能立刻建立起来，connect会失败并把errno设置为
EINPROGRESS，而连接将以异步方式维续尝试。
异步连接的处理是比较困难的，而我们可以在套接字文件描述符上用一个sclect调用来表明
该套接字已经处于写就绪状态。select将本章后面的内容里介绍。
14.2.8关闭一个套接字