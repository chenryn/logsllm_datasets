GKR protocol. The GKR protocol provides sublinear communica-
tion and efficiently verifiable proofs for low-depth polynomial-time
computations. It has been extended to the case of NP statements by
Zhang et al. [56] using polynomial commitment schemes, and sev-
eral GKR-based zero-knowledge argument schemes are proposed in
subsequent works [52, 54, 57]. The most relevant work in this line
is a recent scheme by Zhang et al. [55], where a new polynomial
Session 6E: Zero Knowledge CCS '20, November 9‚Äì13, 2020, Virtual Event, USA2026commitment scheme based on symmetric cryptographic primitives
without trusted setup is proposed. The zero knowledge argument
scheme in [55] falls into the model of IOP where their underlying
implementation relies on the FRI protocol of [20]. The communica-
tion complexity of all GKR-based schemes grows linearly with the
depth of the circuit and they only support layered circuits.
Based on the MPC-in-the-head approach, ZKBoo [32] introduce
linear proof size in the verification circuit. Followup works [27,
42] optimize the communication cost for post-quantum signature
schemes, where the latter uses preprocessing-based MPC. Following
the work of [38, 39, 44], Gennaro et al. [31] introduced Quadratic
Arithmetic Programs (QAPs) which form the basis of a sequence
of protocols [19, 22, 23, 28, 48, 51]. While the proof size of these
protocols is constant and the verification time depends on input
size, the prover‚Äôs running time is much higher and a separate setup
phase is required. Another line of works is based on the hardness of
discrete log [10, 25, 26, 37]. Among these, Bulletproof [26] generates
a logarithmic proof size but has high prover and verifier times due
to a number of cryptographic operations per gate.
Our zero-knowledge proof scheme proposed in this paper is
based on IOP. We mainly compared the properties with other IOP-
based schemes. Please refer to [52, 54, 55] for more details on the
performance and comparisons of other ZKP schemes.
2 PRELIMINARIES
We use negl(¬∑) to denote the negligible function, where for each
positive polynomial ùëì (¬∑), negl(ùëò) <
1
ùëì (ùëò) for sufficiently large
integer ùëò. ùúÜ denotes the security parameter and ‚ÄúPPT‚Äù standards
for probabilistic polynomial time. We use lower-case letters such
as ùëé, ùëè, ùë•, ùë¶ to represent vectors, and ùë•ùëñ denotes the ùëñ-th element in
vector ùë•. We use capital letters such as ùê¥, ùêµ to represent matrices. ùê¥ùëñ
denotes the ùëñ-th row, ùê¥[ ùëó] denotes the ùëó-th column and ùê¥ùëñ ùëó denotes
the (ùëñ, ùëó)-th element of matrix ùê¥.
Merkle hash tree. Merkle hash tree is a primitive proposed by
Ralph Merkle [46] to commit a vector and open it at an index with
a logarithmic-size proof. It consists of three algorithms:
‚Ä¢ rootùëê ‚Üê MT.Commit(ùëê)
‚Ä¢ (ùëêùëñ, ùúãùëñ) ‚Üê MT.Open(ùëñ, ùëê)
‚Ä¢ (1, 0) ‚Üê MT.Verify(rootùëê, ùëñ, ùëêùëñ, ùúãùëñ)
2.1 Coding Notations
For a code ùê∂ ‚äÜ Œ£ùëõ and vector ùë£ ‚àà Œ£ùëõ, denote by ùëë(ùë£, ùê∂) the minimal
distance of ùë£ from ùê∂, namely the number of positions in which
ùë£ differs from the closest codeword in ùê∂, and by Œî(ùë£, ùê∂) the set
of positions in which ùë£ differs from such a closest codeword (in
case of ties, take the lexicographically first closest codeword), and
by Œî(ùëâ , ùê∂) =ùë£‚ààùëâ {Œî(ùë£, ùê∂)}. We further denote by ùëë(ùëâ , ùê∂) the
minimal distance between a vector set ùëâ and a code ùê∂, namely
ùëë(ùëâ , ùê∂) = minùë£‚ààùëâ {ùëë(ùë£, ùê∂)}.
Reed-Solomon code. For a linear code C ‚äÜ Œ£ùëõ and vector ùë£ ‚àà Œ£ùëõ,
we use ùëë(C, ùë£) to denote the minimal distance of ùë£ from C. Formally
ùëë(C, ùë£) = minùëê‚ààC ‚Ñé(ùëê, ùë£), where ‚Ñé(ùëê, ùë£) is the hamming distance
between ùëê and ùë£.
Definition 2.1 (Reed-Solomon Code). For positive integers ùëõ, ùëò,
field F and vector ùúÇ = (ùúÇ0, ..., ùúÇùëõ‚àí1) ‚àà Fùëõ of distinct field elements,
the Reed-Solomon (RS) code ùëÖùëÜF,ùëõ,ùëò,ùúÇ is the [ùëõ, ùëò, ùëõ ‚àí ùëò + 1] linear
code over F that consists of all ùëõ-tuples (ùëù(ùúÇ0), ùëù(ùúÇ1), ..., ùëù(ùúÇùëõ‚àí1))
where ùëù is a polynomial of degree < ùëò over F.
Definition 2.2 (Encoded message). Let ùêø = ùëÖùëÜF,ùëõ,ùëò,ùúÇ be an RS
code and ùúÅ = (ùúÅ1, ..., ùúÅùëò) be a sequence of distinct elements in
F. For a codeword ùë¢ ‚àà ùêø, we define the message ùê∑ùëíùëêùúÅ (ùë¢) to be
(ùëùùë¢(ùúÅ1), ..., ùëùùë¢(ùúÅùëò)), where ùëùùë¢ is the polynomial (of degree < ùëò)
corresponding to ùë¢. For ùëà ‚àà ùêøùëö with rows ùë¢1, ..., ùë¢ùëö ‚àà ùêø, we let
ùê∑ùëíùëêùúÅ (ùëà) be the length-ùëöùëò vector ùë• = (ùë•11, ..., ùë•1ùëò, ..., ùë•ùëö1, ..., ùë•ùëöùëò)
such that (ùë•ùëñ1, ..., ùë•ùëñùëò) = ùê∑ùëíùëêùúÅ (ùë¢ùëñ), ùëñ ‚àà [ùëö]. Finally we say that ùëà
encodes ùë• if ùë• = ùê∑ùëíùëêùúÅ (ùëà), we use ùê∑ùëíùëê(ùëà) when ùúÅ is clear from the
context.
In our protocol, we set ùúÇùëñ = ùúîùëñ where ùúî is a generator of a multi-
plicative group in field F. We can evaluate (ùëù(ùúÇ0), ùëù(ùúÇ1), ..., ùëù(ùúÇùëõ‚àí1))
using the fast Fourier transform (FFT), which takes ùëÇ(ùëõ log ùëõ) field
operations. We use RS(ùëé) to denote the RS encoding of message ùëé.
2.2 Zero-knowledge Arguments
A zero-knowledge argument system for an NP relationship R is
a protocol between a computationally-bounded prover P and a
verifier V. At the end of the protocol, V is convinced by P that
there exists a witness ùë§ such that (ùë•; ùë§) ‚àà R for some input ùë•, and
learns nothing beyond that. We focus on arguments of knowledge
which have the stronger property that if the prover convinces the
verifier of the statement validity, then the prover must know ùë§. We
use G to represent the generation phase of the public parameters
pp. Formally, consider the definition below, where we assume R is
known to P and V.
Definition 2.3. Let R be an NP relation. A tuple of algorithm
(G, P,V) is an argument of knowledge for R if the following holds.
‚Ä¢ Correctness. For every pp output by G(1ùúÜ) and (ùë•, ùë§) ‚àà ùëÖ,
‚ü®P(pp, ùë§),V(pp)‚ü©(ùë•) = 1
‚Ä¢ Soundness. For any PPT prover P, there exists a PPT extractor ùúÄ
such that for every pp output by G(1ùúÜ) and any ùë•, the following
probability is negl(ùúÜ):
Pr[‚ü®P(ùë§),V‚ü©(pp, ùë•) = 1 ‚àß (ùë•, ùë§) ‚àâ R|ùë§ ‚Üê ùúÄP(pp, ùë•)]
It is a zero-knowledge argument of knowledge it additionally
satisfies:
‚Ä¢ Zero knowledge. There exists a PPT simulator S such that for
any PPT algorithm V‚àó, auxiliary input ùëß ‚àà {0, 1}‚àó, (ùë•; ùë§) ‚àà R,
pp output by G(1ùúÜ), it holds that
View(‚ü®P(ùë§),V‚àó‚ü©(pp, ùë•, ùëß)) ‚âà SV‚àó(pp, ùë•, ùëß)
Here ùúÄP denotes that the extractor ùúÄ has access to the entire execut-
ing process and the randomness of P. SV‚àó denotes that the simula-
tor S sees the randomness from a polynomial-size space of V‚àó. We
say that (G, P,V) is a succinct argument system if the total com-
munication between P and V (proof size) are poly(ùúÜ, |ùë•|, log |ùë§|).
2.3 Interactive Oracle Proofs
Interactive Oracle Proofs (IOP) [21, 49] is a type of proof system that
combines the aspects of Interactive Proofs (IP) [8, 35] along with
Probabilistic Checkable Proofs (PCP) [6, 7, 9] as well generalizes
Session 6E: Zero Knowledge CCS '20, November 9‚Äì13, 2020, Virtual Event, USA2027Interactive PCPs (IPCP) [41]. In this model, like the PCP model,
the verifier does not need to read the whole proof and instead can
query the proof at some random locations while similar to IP model,
the prover and verifier interact over several rounds.
A k-round IOP has k rounds of interaction. In the ùëñùë°‚Ñé round
of interaction, the verifier sends a uniform public message ùëöùëñ to
the prover and the prover generates ùúãùëñ. After running k rounds of
interaction, the verifier makes some queries to the proofs via oracle
access and will either accept it or reject it.
Definition 2.4. Let R(ùë•, ùúî) be an NP relation corresponding to
an NP language L. An IOP system for a relation R with round
complexity ùëò and soundness ùúñ is a pair of PPT algorithms (P,V)
if it satisfies the following properties:
‚Ä¢ Syntax: On common input ùë• and prover input ùúî, P and V run
an interactive protocol of ùëò rounds. In each round i, V sends a
message ùëöùëñ and P generates ùúãùëñ. Here the V has oracle access to
{ùúã1, ùúã2, . . . , ùúãùëò}. We can express ùúã = (ùúã1, ùúã2, . . . , ùúãùëò). Based on
the queries from these oracles, V accepts or rejects.
‚Ä¢ Completeness: If (ùë•, ùúî) ‚àà R then,
Pr[(P(ùë•, ùúî),Vùúã (ùë•)) = 1] = 1
‚Ä¢ Soundness: For every ùë• ‚àâ L, every unbounded algorithm P‚àó and
proof Àúùúã
Pr[(P‚àó,V Àúùúã) = 1] ‚â§ negl(ùúÜ)
The notion of IOP can be extended to provide zero-knowledge
property as well. Next we define the definition of zero-knowledge
IOP.
Definition 2.5. Let ‚ü®P,V‚ü© be an IOP for R. We say that ‚ü®P,V‚ü© is
a (honest verifier) zero-knowledge IOP if there exists a PPT simula-
tor S, such that for any (ùë•, ùúî) ‚àà R, the output of S(ùë•) is distributed
identically to the view of V in the interaction (P(ùë•, ùúî),V(ùë•)).
2.4 Inner Product Arguments
Inner product arguments (IPA) allow a verifier to validate the inner
product of a committed vector from the prover and a public vector.
Our protocols use the inner product arguments recently proposed
by Zhang et al. in [55] as a building block. The scheme is a Reed-
Solomon encoded interactive oracle proof based on the work of
Aurora[20], and does not require a trusted setup. Let ùë¶ = ‚ü®ùëé, ùëè‚ü©
be the inner product of two vectors. The scheme consists of the
following algorithms:
‚Ä¢ pp ‚Üê IPA.KeyGen(1ùúÜ),
‚Ä¢ comùëé ‚Üê IPA.Commit(ùëé, pp),
‚Ä¢ (ùë¶, ùúã) ‚Üê IPA.Prove(ùëé, ùëè, pp),
‚Ä¢ {0, 1} ‚Üê IPA.Verify(pp, ùë¶, comùëé, ùëè, ùúã)
Theorem 2.6 ([55]). There exists an inner product argument scheme
satisfying the following properties:
‚Ä¢ Completeness. For any private vector ùëé ‚àà Fùëõ, public vector ùëè ‚àà Fùëõ,
pp ‚Üê IPA.KeyGen(1ùúÜ), com ‚Üê IPA.Commit(ùëé, pp), {ùë¶, ùúã} ‚Üê
IPA.Prove(ùëé, ùëè, pp), it holds that
Pr [IPA.Verify(pp, ùë¶, comùëé, ùëè, ùúã) = 1] = 1
‚Ä¢ Soundness. For any PPT adversary A, pp ‚Üê IPA.KeyGen(1ùúÜ),
(cid:35)
: com‚àó = IPA.Commit(ùëé‚àó, pp)
‚àß ‚ü®ùëé‚àó, ùëè‚ü© ‚â† ùë¶‚àó
the following probability is negligible in ùúÜ:
(cid:34)(ùëé‚àó, com‚àó, ùëè, ùë¶‚àó, ùúã‚àó) ‚Üê A(1ùúÜ, pp)
IPA.Verify(pp, ùë¶‚àó, com‚àó, ùëè, ùúã‚àó) = 1
Pr
Complexity. Let the size of the vectors be ùëõ. The running time of
ùê∂ùëúùëöùëöùëñùë° and Prove is ùëÇ(ùëõ log ùëõ) time for the prover, and the running
time of Verify is ùëÇ(ùëõ) for the verifier. The proof size is ùëÇ(log2 ùëõ).
In particular, in the commitment of the IPA in [55], ùëé is encoded
into RS(ùëé), and committed by setting comùëé = MT.Commit(RS(ùëé)).
2.5 Ligero
Our construction follows the general structure of Ligero [5], and
we highlight the idea of the construction here. Ligero is a zero
knowledge argument protocol for NP based on the MPC in the
head method. It allows the prover to convince the verifier that a
statement is valid in zero knowledge.
We use arithmetic circuits to model our computation as done
in Ligero. We use prime fields in our construction. Our technique
is explained here for arithmetic circuits but can be extended to
boolean circuits as well.
At a very high level, the Ligero prover arranges the circuit wire
values in an matrix. It then encodes each row using the Reed-
Solomon code. The verifier challenges the prover to reveal the
linear combinations of the entries of the matrix, and randomly
checks ùë° entries of the revealed combination, by asking the prover
for the corresponding columns. Therefore the total communication
is one row and ùë° columns. By setting the dimensions of the matrix
to be a ‚àö
‚àö
ùê∂ √ó ‚àö
ùê∂).
Moreover, the prover needs to encode each row, thus the overall
encode time is ùëÇ(‚àö
ùê∂ log ùê∂) = ùëÇ(ùê∂ log ùê∂). One simple way to
reduce this complexity is by reducing the row size. Nevertheless,
this will increase the proof size since the prover needs to transfer
ùë° columns. It is a major challenge in our paper to reduce both the
computation time and the communication size.
ùê∂ matrix, the overall communication is ùëÇ(ùë°
ùê∂ √ó ‚àö
3 OUR CONSTRUCTION
In this section, we present our main construction, a zero-knowledge
argument protocol for NP relations expressed as R1CS. Similar to [5],
the construction consists of three components: testing interleaved
linear code, testing linear constraints and testing quadratic con-
straints. We present these components in Section 3.1-3.3, followed
by the whole protocol in Section 3.4. Finally, we show how to turn
the protocol into zero-knowledge in Section 3.5.
3.1 Testing Interleaved Linear Code
We start with our protocol for testing interleaved linear code. The
purpose of this protocol is to check that each row of a matrix ùëà
constructed by the prover is an RS code. Formally speaking, let
ùêø ‚äÇ Fùëõ be an [ùëõ, ùëò, ùëë] linear code over F, the [ùëõ, ùëöùëò, ùëë] interleaved