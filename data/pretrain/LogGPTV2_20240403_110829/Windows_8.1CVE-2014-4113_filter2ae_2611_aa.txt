# Windows 8.1内核利用—CVE-2014-4113漏洞分析
|
##### 译文声明
本文是翻译文章，文章来源：bluefrostsecurity
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
**1. 情况简介：**
**  
**
2014年10月14日，[CrowdStrike](http://blog.crowdstrike.com/crowdstrike-discovers-use-64-bit-zero-day-privilege-escalation-exploit-cve-2014-4113-hurricane-panda/)和[FireEye](https://www.fireeye.com/blog/technical/targeted-attack/2014/10/two-targeted-attacks-two-new-zero-days.html)两家IT公司各自发布了一篇博文，在其中都不约而同地介绍了一个基于Windows系统的新型内核权限提升漏洞。CrowdStrike公司在文章中提到：他们是在追踪一个名叫Hurricane
Panda（飓风熊猫）的黑客组织的过程中，发现并证实该漏洞的。该漏洞在Internet上至少已经活跃了5个月的时间了。
据报道，这个漏洞是由CrowdStrike和FireEye同时发现并提交给微软公司（Microsoft）的，随后，微软就将其命名为了：MS14-058，同时提供了修复补丁。在漏洞提交后不久，很多安全研究人员也在各自的博文中提到了这个漏洞，并介绍了其中的一些细节。在撰写本文时，我曾阅读了多篇关于介绍CVE-2014-4113漏洞的文章，了解了多位作者的[分析思路](https://www.codeandsec.com/CVE-2014-4113-Detailed-Vulnerability-and-Patch-Analysis)。在其中的一篇文章中，作者从基于二进制与Metasploit渗透框架结合的角度出发，详细分析了该漏洞。这个分析思路适用于除Windows
8和Windows 8.1之外的，所有Windows 32位和64位操作系统。
[微软公司表示](https://technet.microsoft.com/en-us/library/security/ms14-058.aspx)，CVE-2014-4113漏洞影响了多个版本的Windows操作系统，其中就包括Windows
8.1。有趣的是，FireEye公司在文章中提到：在Windows 8、Windows Server
2012以及之后的版本中，却并不存在该漏洞。这个漏洞的利用程序是黑客组织Hurricane Panda率先发布的，并且该程序只对Windows
7和Windows 8系统有效。
因此，我非常好奇的是：这个漏洞是如何在多个版本的Windows系统中得到体现并加以利用的。在下文中，我将向读者介绍我对这个漏洞的分析过程，以及在Windows
8和Windows 8.1系统上实现利用的步骤。
**2. ****漏洞详情：**
**  
**
我所使用的分析测试环境是Windows
7（64位）系统。在分析过程中，我还会给读者分享一些有价值的信息。这些经过分析测试的shellcode代码具有MD5校验能力。
由于之前的[很多文章](http://blog.trendmicro.com/trendlabs-security-intelligence/an-analysis-of-a-windows-kernel-mode-vulnerability-cve-2014-4113/)都详细地介绍过该漏洞的整体情况，因而，在这里，我更多是关注该漏洞的一些具体细节。CVE-2014-4113漏洞存在的原因是：在Win
32K.sys驱动程序中，代码出现缺少返回值校验的情况。Win
32K.sys驱动程序负责管理Windows系统的内核模式，处理Windows系统的资源管理以及提供图形编程驱动接口以及处理内核的其他事务。
利用user 32！模块中的TrackPopupMenu函数，可以引发一个用户模式下的安全漏洞。在内核中负责处理API的函数是：Win
32K！xxxHandleMenuMessages，该函数能够调用Win 32K！xxxMNFindWindowsFromPoint API函数。Win
32K！xxxMNFindWindowsFromPoint
API函数的返回值是一个win32k！tagWND结构的指针。然而，在调用失败时，该函数会返回错误代码-1和-5。而调用程序在检查返回值的时候，只检查了-1，而没有检查-5，从而出现了执行出错。同时由于系统本身也没有发现该错误，进而使得该函数将继续默认-5为正确值，同时继续提供一个有效的win32k！tagWND结构的指针；实际上，该函数一直使用的都是错误代码-5（0xfffffffb）。这个代码在执行时，会将-5作为参数传递给Win
32K！xxxSendMessage函数。而该函数正好是Win32K！xxxSendMessageTimeout的一个轻量级封装函数。（在Windows
8.1上名叫：win32k!xxxSendTransformableMessageTimeout）。
该漏洞通用的利用规则是：在用户模式地址为0xfffffffb的地方，用ZwAllocateVirtualMemoryAPI函数分配内存空间，并在这个地方存储一个win32k！tagWND结构指针。在内核中，以用户模式访问该结构时，便会引发该漏洞。而win32k！tagWND结构指针也已经准备就绪，之后便会执行win32k！tagWND结构里的函数。该函数的指针指向了一个简单的内核权限shellcode，这个shellcode覆盖了原始的函数返回地址。该函数就是一个EPROCESS结构函数，具有在系统权限下运行的能力。
**3. ****Windows 8.1** **内核的利用**
**  
**
这个漏洞的公开利用程序并不直接适用于Windows
8系统，这是因为SMEP（管理模式执行保护机制）将会保护用户模式下的shellcode的执行过程。这个执行过程其实是在内核的上下文中进行的。当CPU在win32k!xxxSendTransformableMessageTimeout函数中执行指令时，这种被错误使用的shellcode在Windows
8系统中依然存在。而Windows 8.1则完全替代了那段代码，同时更加注重对于数组边界的检查。
因此，在Windows
8.1中，系统就不会在程序流中继续使用调用指令。然而，正如我们看到的那样，在下一个区段中，使用一个经过精心设计的win32k！tagWND结构函数能够成功地达到利用该漏洞的目的。