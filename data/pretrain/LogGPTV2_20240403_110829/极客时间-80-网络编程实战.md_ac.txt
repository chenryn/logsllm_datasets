# define _POSIX_CHOWN_RESTRICTED /* only root can do a chown (I think..) */ /* #define _POSIX_NO_TRUNC*/ /* pathname truncation (but see in kernel) */ 
# define _POSIX_VDISABLE '\0' /* character to disable things like ^C */ /*#define _POSIX_SAVED_IDS */ /* we'll get to this yet */ /*#define _POSIX_JOB_CONTROL */ /* we aren't there quite yet. Soon hopefully */POSIX 相当于给大厦画好了图纸，给 Linux的发展提供了非常好的指引。这也是为什么我们的程序在 Mac OS 和 Linux可以兼容运行的原因，因为大家用的都是一张图纸，只不过制造商不同，程序当然可以兼容运行了。
### Minix 操作系统刚才提到了 UNIX 操作系统不开源的问题，那么有没有一开始就开源的 UNIX操作系统呢？这里就要提到 Linux 发展的第三个机遇，Minix操作系统，它在早期是 Linux发展的重要指引。这个操作系统是由一个叫做安迪·塔能鲍姆（AndyTanenbaum）的教授开发的，他的本意是用来做 UNIX 教学的，甚至有人说，如果Minix 操作系统也完全走社区开放的道路，那么未必有现在的 Linux操作系统。当然，这些话咱们就权当做是马后炮了。Linux 早期从 Minix中借鉴了一些思路，包括最早的文件系统等。
### GNULinux 操作系统得以发展还有一个非常重要的因素，那就是 GNU（GNU's NOTUNIX），它的创始人就是鼎鼎大名的理查·斯托曼（RichardStallman）。斯托曼的想法是设计一个完全自由的软件系统，用户可以自由使用，自由修改这些软件系统。GNU 为什么对 Linux 的发展如此重要呢？事实上，GNU 之于 Linux是要早很久的，GNU 在 1984 年就正式诞生了。最开始，斯托曼是想开发一个类似UNIX 的操作系统的。> From> CSvax:pur-ee:inuxc!ixn5c!ihnp4!houxm!mhuxi!eagle!mit-vax!mit-eddie!RMS@> MIT-OZ\> From: RMS% MIT-OZ@ mit-eddie\> Newsgroups: net.unix-wizards,net.usoft\> Subj ect: new UNIX implementation\> Date: Tue, 27-Sep-83 12:35:59 EST\> Organization: MIT AI Lab, Cambridge, MA\> Free Unix!\> Starting this Thanksgiving I am going to write a complete> Unix-compatible software system called GNU (for Gnu's Not Unix), and> give it away free to everyone who can use it. Contributions of> time,money, programs and equipment are greatly needed.\> To begin with, GNU will be a kernel plus all the utilities needed to> write and run C programs: editor, shell, C compiler, linker,> assembler, and a few other things. After this we will add a text> formatter, a YACC, an Empire game, a spreadsheet, and hundreds of> other things. We hope to supply, eventually, everything useful that> normally comes with a Unix system, and anything else useful, including> on-line and hardcopy documentation.\> ...在这个设想宏大的 GNU计划里，包括了操作系统内核、编辑器、shell、编译器、链接器和汇编器等等，每一个都是极其难啃的硬骨头。不过斯托曼可是个牛人，单枪匹马地开发出世界上最牛的编辑器Emacs，继而组织和成立了自由软件基金会（the Free Software Foundation -FSF）。GNU 在自由软件基金会统一组织下，相继续推出了编译器 GCC、调试器 GDB、BashShell 等运行于用户空间的程序。正是这些软件为 Linux操作系统的开发创造了一个合适的环境，比如编译器 GCC、Bash Shell 就是Linux 能够诞生的基础之一。你有没有发现，GNU 独缺操作系统核心？实际上，1990 年，自由软件基金会开始正式发展自己的操作系统 Hurd，作为 GNU项目中的操作系统。不过这个项目再三耽搁，1991 年，Linux 出现，1993年，FreeBSD 发布，这样 GNU 的开发者开始转向于 Linux 或FreeBSD，其中，Linux 成为更常见的 GNU 软件运行平台。斯托曼主张，Linux 操作系统使用了许多 GNU 软件，正式名应为GNU/Linux，但没有得到 Linux 社群的一致认同，形成著名的 GNU/Linux命名争议。GNU 是这么解释为什么应该叫 GNU/Linux 的："大多数基于 Linux内核发布的操作系统，基本上都是 GNU 操作系统的修改版。我们从 1984年就开始编写 GNU 软件，要比 Linus开始编写它的内核早许多年，而且我们开发了系统的大部分软件，要比其它项目多得多，我们应该得到公平对待。"从这段话里，我们可以知道 GNU 和 GNU/Linux 互相造就了对方，没有 GNU当然没有 Linux，不过没有 Linux，GNU 也不可能大发光彩。在开源的世界里，也会发生这种争名夺利的事情，我们也不用觉得惊奇。
## 操作系统对 TCP/IP 的支持讲了这么多操作系统的内容，我们再来看下面这张图。图中展示了 TCP/IP在各大操作系统的演变历史。可以看到，即使是大名鼎鼎的 Linux 以及 90年代大发光彩的 Windows 操作系统，在 TCP/IP网络这块，也只能算是一个后来者。![](Images/918019e43bc40a27721dd48fa8a75a71.png){savepage-src="https://static001.geekbang.org/resource/image/0f/e1/0f783e74927d70794421cf5983f22ae1.png"}
## 总结这是我们专栏的第一讲，我没有直接开始讲网络编程，而是对今天互联网技术的基石，TCP和 Linux进行了简单的回顾。通过这样的回顾，熟悉历史，可以指导我们今后学习的方向，在后面的章节中，我们都将围绕Linux 下的 TCP/IP 程序设计展开。最后你不妨思考一下，Linux TCP/IP 网络协议栈最初的实现"借鉴"了多少 BSD的实现呢？Linux 到底是不是应该被称为 GNU/Linux 呢？欢迎你在评论区写下你的思考，我会和你一起讨论这些问题。如果这篇文章帮你厘清了TCP/IP 和 Linux 的发展脉络，欢迎把它分享给你的朋友或者同事。![](Images/5a282807b2a1ff091b7f803e8cef3429.png){savepage-src="https://static001.geekbang.org/resource/image/bf/25/bfc96ae0d8f839919b9d9866cfb8b025.jpg"}
# 02 \| 网络编程模型：认识客户端-服务器网络模型的基本概念你好，我是盛延敏。上一讲我们学习了 TCP/IP 的创建和历史，以及 Linux操作系统的建立和发展，相信你对网络编程这棵大树已经有了一个宏观上的认识，那么今天我们再往前走几步，近距离看看这棵大树的细枝末节到底是怎样的。从哪里开始呢？从网络编程的基本概念开始说起吧。
## 客户端 - 服务器网络编程模型在谈论网络编程时，我们首先需要建立一个概念，也就是我们今天的主题"客户端 -服务器"。拿我们常用的网络购物来说，我们在手机上的每次操作，都是作为客户端向服务器发送请求，并收到响应的例子。这个过程具体阐释如下：![](Images/75c5feb93e96c6fd0b166b8df4b5aaaa.png){savepage-src="https://static001.geekbang.org/resource/image/78/83/78e415180d2946c418485d30f3f78f83.png"}1.  当一个客户端需要服务时，比如网络购物下单，它会向服务器端发送一个请求。注意，这个请求是按照双方约定的格式来发送的，以便保证服务器端是可以理解的；2.  服务器端收到这个请求后，会根据双方约定的格式解释它，并且以合适的方式进行操作，比如调用数据库操作来创建一个购物单；3.  服务器端完成处理请求之后，会给客户端发送一个响应，比如向客户端发送购物单的实际付款额，然后等待客户端的下一步操作；4.  客户端收到响应并进行处理，比如在手机终端上显示该购物单的实际付款额，并且让用户选择付款方式。在网络编程中，具体到客户端 - 服务器模型时，我们经常会考虑是使用 TCP 还是UDP，其实它们二者的区别也很简单：TCP 中连接是谁发起的，在 UDP中报文是谁发送的。在 TCP通信中，建立连接是一个非常重要的环节。区别出客户端和服务器，本质上是因为二者编程模型是不同的。``{=html}服务器端需要在一开始就监听在一个众所周知的端口上，等待客户端发送请求，一旦有客户端连接建立，服务器端就会消耗一定的计算机资源为它服务，服务器端是需要同时为成千上万的客户端服务的。如何保证服务器端在数据量巨大的客户端访问时依然能维持效率和稳定，这也是我们讲述高性能网络编程的目的。客户端相对来说更为简单，它向服务器端的监听端口发起连接请求，连接建立之后，通过连接通路和服务器端进行通信。**还有一点需要强调的是，无论是客户端，还是服务器端，它们运行的单位都是进程（process），而不是机器**。一个客户端，比如我们的手机终端，同一个时刻可以建立多个到不同服务器的连接，比如同时打游戏，上知乎，逛天猫；而服务器端更是可能在一台机器上部署运行了多个服务，比如同时开启了SSH 服务和 HTTP 服务。
## IP 和端口正如寄信需要一个地址一样，在网络世界里，同样也需要地址的概念。在 TCP/IP协议栈中，IP 用来表示网络世界的地址。前面我们提到了，在一台计算机上是可以同时存在多个连接的，那么如何区分出不同的连接呢？这里就必须提到端口这个概念。我们拿住酒店举例子，酒店的地址是唯一的，每间房间的号码是不同的，类似的，计算机的IP 地址是唯一的，每个连接的端口号是不同的。端口号是一个 16 位的整数，最多为65536。当一个客户端发起连接请求时，客户端的端口是由操作系统内核临时分配的，称为临时端口；然而，前面也提到过，服务器端的端口通常是一个众所周知的端口。一个连接可以通过客户端 - 服务器端的 IP和端口唯一确定，这叫做套接字对，按照下面的四元组表示：    （clientaddr:clientport, serveraddr: serverport)下图表示了一个客户端 - 服务器之间的连接：![](Images/97b6b0dd617dde18e1dffbc98dcb346b.png){savepage-src="https://static001.geekbang.org/resource/image/54/2a/543b5488f9422558069df507cfaa462a.png"}