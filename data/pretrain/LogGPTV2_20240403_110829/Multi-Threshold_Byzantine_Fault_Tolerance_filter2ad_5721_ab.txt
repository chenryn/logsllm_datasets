(3) We present a framework to convert existing partially synchro-
nous or asynchronous BFT SMR protocols to additionally enjoy
optimal synchronous safety fault tolerance (Section 5).
2 MULTI-THRESHOLD BFT
2.1 Preliminaries
Reliable broadcast (RBC). In reliable broadcast (RBC), a desig-
nated sender ğ‘Ÿğ‘  looks to broadcast an input value ğ‘ğ‘–ğ‘› to a set of ğ‘›
replicas, and each replica outputs a value. A RBC protocol needs to
achieve the following safety and liveness properties.
(1) Safety.
(a) Consistency. If two honest replicas output values ğ‘ and ğ‘â€²,
(b) Integrity. If the designated sender is honest, no honest replica
respectively, then ğ‘ = ğ‘â€².
outputs a value ğ‘ â‰  ğ‘ğ‘–ğ‘›.
(2) Liveness.
(a) Validity. If the designated sender is honest, then all honest
replicas output some value.
Session 6A: Consensus and Attacks CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1687(b) Totality. If an honest replica commits a value, all honest repli-
cas output some value.
0, ğ‘¡ğ‘¥â€²
We remark that the standard RBC validity property says â€œif the
designated sender is honest, all honest replicas output the senderâ€™s
valueâ€. It has both safety and liveness components, so we separate it
into integrity and validity following [17]. While this separation may
look verbose at first glance, it follows the convention that safety
captures â€œnothing bad happensâ€ and liveness captures â€œsomething
happensâ€.
State machine replication (SMR). The problem we are more in-
terested in is the state machine replication (SMR) problem [14, 45].
A SMR protocol uses a number of servers, called replicas, to provide
an abstraction of a single non-faulty server . A SMR protocol or-
ders transactions from clients into a totally ordered list that grows
in length, called a log. Replicas and clients repeatedly output new
transactions at increasing positions of the log. Since a SMR protocol
ultimately services clients, it needs to provide public verifiability.
Namely, there is a predefined Boolean function Verify; a replica or a
client outputs a log of transactions log = [ğ‘¡ğ‘¥0, ğ‘¡ğ‘¥1, ...ğ‘¡ğ‘¥ ğ‘—] if and only
if there is a publicly verifiable proof ğœ‹ such that Verify(log, ğœ‹) = 1.
A SMR protocol then provides the following safety and liveness:
(1) Safety. If [ğ‘¡ğ‘¥0, ğ‘¡ğ‘¥1, ..., ğ‘¡ğ‘¥ ğ‘—] and [ğ‘¡ğ‘¥â€²
ğ‘—â€²] are output by
two honest replicas or clients, then ğ‘¡ğ‘¥ğ‘– = ğ‘¡ğ‘¥â€²
ğ‘– for all ğ‘– â‰¤
min( ğ‘—, ğ‘—â€²).
(2) Liveness. If a transaction ğ‘¡ğ‘¥ is input to at least one honest
replica, then every honest replica eventually outputs a log con-
taining ğ‘¡ğ‘¥.
Although some prior works [2, 47] do not explicitly mention
the public verifiability property in their SMR definitions, they all
implicitly achieve it. A typical way to achieve it is to have a client
collect signatures on the log from ğ‘“ + 1 replicas, which serve as a
publicly verifiable proof for the log.
1, ..., ğ‘¡ğ‘¥â€²
It is easy to see that a SMR protocol solves RBC by outputting
a transaction signed by the sender that resides at the smallest log
height. We will elaborate on this in Section 4.1. Therefore, an im-
possibility result for RBC applies to SMR as well.
Timing model. The three most common network timing models
in distributed computing are synchrony, asynchrony, and partially
synchrony. In a synchronous network, every message sent by an
honest replica will be received by the recipient within a known up-
per bound Î”. If there is no such bound on the communication delay,
the network is said to be asynchronous. A partially synchronous
network has both synchronous and asynchronous periods. For con-
venience, it is usually assumed that the network is asynchronous
at first, but becomes synchronous after an unknown time called
global stabilization time (GST) denoted ğ‘‡ğ‘” [22].
Even in the synchronous model, our protocols do not assume any
synchronized clocks across replicas, which is commonly assumed
in lock-step synchronous protocols such as Blum et al. where all
replicas do each operation at the same time. We only assume that
each replicaâ€™s locally measured Î” time is a correct upper bound for
the network delay.
Fault model. We assume Byzantine faults that can behave arbitrary.
All protocols presented in this paper tolerate adaptive corruption
that can happen anytime during the protocol execution. A replica
that is not faulty throughout the execution is said to be honest and
faithfully execute the protocol.
Other assumptions. We assume the use of digital signatures and
public-key infrastructure (PKI) for the set of replicas, i.e., the public-
keys of all replicas are known to all replicas and clients. We use the
notation âŸ¨ğ‘¥âŸ©ğ‘Ÿ to denote a message ğ‘¥ signed by a replica ğ‘Ÿ. We also
assume a cryptographic hash function ğ». As is commonly done in
BFT protocols, we abstract away the details of cryptography and
assume they are ideal.
2.2 Multi-Threshold BFT
We introduce multi-threshold BFT (MT-BFT), a generalized defi-
nition of the BFT problem that separates the fault tolerance for
safety and liveness under synchrony and asynchrony (or partially
synchrony), and capture the trade-offs between them. To elaborate,
a multi-threshold BFT protocol is parameterized by four thresholds
0  ğ›½ means replicas are allowed to
make progress in a unsafe manner (e.g., output conflicting values).
It may make sense if the protocol has some notion of â€œrecoveringâ€
capability where unsafe decisions are eventually resolved, but we
have not seen a clear formalization for such a notion and we leave
it as future work.
When we consider asynchrony together with synchrony, we
refer to the dual timing model as the async-sync model; likewise,
when we consider partial synchrony together with synchrony, we
refer to the dual timing model as the psync-sync model. Existing
asynchronous [26, 38] (or partially synchronous [14, 47]) BFT proto-
cols are already MT-BFT protocols in the async-sync (or psync-sync)
model with ğ›½ğ‘ = ğ›¾ğ‘ = ğ›½ğ‘  = ğ›¾ğ‘   0, its threshold parameters satisfy ğ›½ğ‘ + 2ğ›¾ğ‘  â‰¥ ğ‘›.
Proof. Suppose for the sake of contradiction that there exists
a MT-BFT RBC protocol whose fault threshold parameters satisfy
ğ›½ğ‘ + 2ğ›¾ğ‘  = ğ‘› (the proof can be easily extended to ğ›½ğ‘ + 2ğ›¾ğ‘  > ğ‘›). We
consider a network with three partitions ğ‘ƒ, ğ‘„, and ğ‘…, with sizes
|ğ‘ƒ| = |ğ‘…| = ğ›¾ğ‘  > 0 and |ğ‘„| = ğ›½ğ‘ > 0. The designated sender ğ‘Ÿğ‘  is in
ğ‘„. Consider the three executions below.
In the first execution (W1), the network is synchronous and all
messages are instantly delivered. All replicas in ğ‘ƒ crash, i.e., do
not send any message to other replicas. The sender ğ‘Ÿğ‘  has an input
value ğ‘1. Since the protocol achieves liveness in the presence of ğ›¾ğ‘ 
faults, all replicas in ğ‘… output ğ‘1 at some time ğ‘‡1.
The second execution (W2) is symmetric to the first one. The
network is synchronous, all messages are instantly delivered, and
all replicas in ğ‘… crash. The sender ğ‘Ÿğ‘  has an input value ğ‘2 â‰  ğ‘1.
Since the protocol achieves liveness in the presence of ğ›¾ğ‘  faults, all
replicas in ğ‘ƒ output ğ‘2 at some time ğ‘‡2.
In the third execution (W3), the network is partially synchronous
and ğ‘‡ğ‘” > max{ğ‘‡1,ğ‘‡2}. All replicas in ğ‘„ are Byzantine. ğ‘„ behave
towards ğ‘… and ğ‘ƒ as in W1 and W2, respectively. All messages
between ğ‘ƒ and ğ‘… are delayed by ğ‘‡ğ‘”, but all other messages are
instantly delivered. Then, replicas in ğ‘… cannot distinguish W1 and
W3 by ğ‘‡1 < ğ‘‡ğ‘”, and they output ğ‘1 as in W1. Similarly, replicas in
ğ‘ƒ cannot distinguish W2 and W3 by ğ‘‡2 < ğ‘‡ğ‘”, and they they output
ğ‘2 â‰  ğ‘1 as in W2. This violates the supposition that the protocol
achieve consistency against |ğ‘„| = ğ›½ğ‘ Byzantine faults.
â–¡
As mentioned, the bound above is a straightforward general-
ization of the bound proven by Blum et al [7, 8], which shows
no protocol can tolerate ğ‘“ğ‘ Byzantine faults under asynchrony
(i.e., ğ‘“ğ‘ = ğ›½ğ‘ = ğ›¾ğ‘) and ğ‘“ğ‘  Byzantine faults under synchrony (i.e.,
ğ‘“ğ‘  = ğ›½ğ‘  = ğ›¾ğ‘ ) if ğ‘“ğ‘ + 2ğ‘“ğ‘  â‰¥ ğ‘›. But once we separate fault tolerance
for safety and liveness, an interesting and crucial observation is
that ğ›½ğ‘ and ğ›½ğ‘  do not constrain each other. This means we may
achieve a higher synchronous safety tolerance independent of the
asynchronous safety tolerance.
3.2 A MT-BFT RBC Protocol with Optimal
Fault Tolerance
We present a MT-BFT RBC protocol with optimal fault tolerance
in the async-sync model. The protocol supports any parameter
choices within the feasible region. Namely, a protocol designer can
first pick ğ›¾ğ‘  < ğ‘›/2. Then, other parameters are determined as
(1) ğ›½ğ‘ = ğ‘› âˆ’ 2ğ›¾ğ‘  âˆ’ 1
(2) ğ›½ğ‘  = ğ‘› âˆ’ 1
(3) ğ›¾ğ‘ = min{ğ›½ğ‘, ğ›¾ğ‘ }
This is optimal given Theorem 3.1 and also establishes the tightness
of Theorem 3.1.
Protocol description and intuition. The protocol is given in Fig-
ure 1. The protocol follows the common quorum-based design. An
available quorum of honest replicas vote for a proposal ğ‘ from the
sender, forming a quorum-certificate C(ğ‘). As our protocol requires
a quorum availability under both synchrony and asynchrony, we
naturally use a quorum of |C| = ğ‘› âˆ’ğ›¾ğ‘  (note that ğ›¾ğ‘  â‰¥ ğ›¾ğ‘). This eas-
ily achieves validity property of the protocol. The integrity property
is also easily achieved by checking a senderâ€™s signature on the value.
The core of the protocol combines respective techniques of purely
asynchronous and purely synchronous protocols and make them
work with the optimal thresholds above to achieve consistency and
totality. We elaborate more in detail below.
Asynchronous quorum intersection. Existing asynchronous
protocols rely on a quorum intersection argument to achieve con-
sistency. In short, two quorums of 2ğ‘“ + 1 replicas out of ğ‘› = 3ğ‘“ + 1
intersect at at least ğ‘“ + 1 replicas. This rules out conflicting quorum
certificates. Then, totality is achieved by having replicas forward
certificates to make other replicas output the same value.
As can be expected from the proof, the quorum intersection
argument works in the optimal thresholds ğ›½ğ‘ = ğ‘› âˆ’ 2ğ›¾ğ‘  âˆ’ 1. Two
quorums of ğ‘›âˆ’ğ›¾ğ‘  replicas intersect at 2(ğ‘›âˆ’ğ›¾ğ‘ )âˆ’ğ‘› = ğ›½ğ‘ +1 replicas,
ruling out conflicting certificates. This guarantees both consistency
and totality under asynchrony.
Synchronous equivocation-checking. The common approach
for synchronous BFT protocols to achieve consistency under minor-
ity corruption is equivocation-checking. In short, replicas, before
outputting, forward the senderâ€™s proposal and wait for Î” to rule out
sender equivocation [4]. Our protocol builds on this technique to
achieve consistency. But we need a little tweak for liveness. A sim-