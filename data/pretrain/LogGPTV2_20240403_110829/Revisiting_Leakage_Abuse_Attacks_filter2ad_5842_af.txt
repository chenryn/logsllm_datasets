Impact of
the composition of
the query space. We
considered two cases: entire or partial query space. For the
former, the query space consists of the keywords in the entire
dataset, while for the latter the query space is composed of
the keywords in the known dataset. We believe that the partial
case is more realistic for unstructured data but we included
both. For structured data (e.g., a medical database) the values
of all attributes are often public (e.g., the possible ages, illness
codes etc.) so entire or partial knowledge of the data does not
matter in this case.
Impact of indexing. Indexing is a parameter that we,
unfortunately, did not
investigate much in this work. We
performed our evaluations using an “aggressive” indexing
strategy where we used porter stemming before indexing all
the keywords in the dataset. If the adversary is not aware of
the stemming algorithm, it could end up with a completely
different query space than the user which would impact the
recovery rate.
Impact of the composition of the dataset. Among all
the parameters, we believe dataset composition is the one that
has the least impact on the recovery date. Our results show that
any reasonable dataset composition of the Enron datasets or
the TREC 2007 Public Corpus dataset leads to similar
results.
Results on chosen-data attacks. Since our injection
attacks always succeed we do not evaluate their success rate
empirically. We report, however, that in order to succeed we
set the size of the keyword universe W to 500. Also, for the
Decoding attack, one has to inject between 4 and 16 KBytes to
recover one keyword depending on the type of the document
collection and the keyword selectivity. For the Binary attack,
the adversary has to inject around 8 KBytes for all document
collections and this holds independently of the selectivity of
the keyword. We provide more details about our evaluation in
Appendix D.
11
(a) (cid:63) = high selectivity, (cid:5) = partial
(c) (cid:63) = high selectivity, (cid:5) = partial
(e) (cid:63) = high selectivity, (cid:5) = partial
(b) (cid:63) = low selectivity, (cid:5) = partial
(d) (cid:63) = low selectivity, (cid:5) = partial
(f) (cid:63) = low selectivity, (cid:5) = partial
Figure 1: SU dataset (Figures 1a and 1b: 150 keywords queried u.a.r. from 500 (cid:63) keywords in the (cid:5) dataset. SU dataset (Figures 1c and 1d): 150 keywords
queried u.a.r. from 5000 (cid:63) keywords in the (cid:5) dataset. M-MU dataset (Figures 1e and 1f): 150 keywords queried u.a.r. from 500 (cid:63) keywords in the (cid:5) dataset.
Figure 2: 150 keywords queried u.a.r. from 500
pseudo-low selectivity keywords in SU.
Figure 3: PBS brute-force attack.
Figure 4: Number of matches in PBS brute-
force attack.
VI. TAKEAWAYS
In this work we revisited leakage abuse and injection
attacks against ESAs. In particular, we argued that the often-
cited IKK and Count attacks are mostly of theoretical interest
due to the following limitations and assumptions:
• high known-data rates: both the IKK and Count attack
require high known-data rates to achieve reasonable re-
covery rates and it is not clear whether such rates are
realistic;
• known queries: in addition to relying on known-data, the
• suppressable leakage: the IKK and Count attacks rely on
the co-occurrence pattern which can be easily hidden at
the cost of additional storage using our OPQ construction.
• experimental evaluation: the experimental evaluations of
the IKK and Count attack were not conducted in all
settings of interest. This includes, for example, querying
Count v.1 attack also relies on known queries;
low-selectivity keywords or keywords that are not in the
adversary’s known dataset.
New attacks. To address these limitations, we intro-
duced four new known-data attacks and two new injection
attacks. We believe our known-data attacks are of practical
interest since they work with low known-data rates and do
not rely on any known queries. Most surprisingly, our attacks
make use of only volumetric leakage and therefore apply, not
only to structured ESAs, but also to oblivious ESAs.
We implemented our attacks and evaluated them empiri-
cally in various settings and using different kinds of queries.
We hope that our study provides useful insights that may
help the community better understand the real-world impact
of leakage abuse attacks. In the following, we list our main
takeaways, sometimes referencing the constructions described
in Section II and Appendix A:
12
 0 0.2 0.4 0.6 0.8 1 0 10 20 30 40 50 60 70 80 90 100Recovery ratePartial Knowledge in %Count-OnlyVolAnSelVolAnSubgraphIDSubgraphVL 0 0.2 0.4 0.6 0.8 1 0 10 20 30 40 50 60 70 80 90 100Recovery ratePartial Knowledge in %Count-OnlyVolAnSelVolAnSubgraphIDSubgraphVL 0 0.2 0.4 0.6 0.8 1 0 10 20 30 40 50 60 70 80 90 100Recovery ratePartial Knowledge in %Count-OnlyVolAnSelVolAnSubgraphIDSubgraphVL 0 0.2 0.4 0.6 0.8 1 0 10 20 30 40 50 60 70 80 90 100Recovery ratePartial Knowledge in %Count-OnlyVolAnSelVolAnSubgraphIDSubgraphVL 0 0.2 0.4 0.6 0.8 1 0 10 20 30 40 50 60 70 80 90 100Recovery ratePartial Knowledge in %Count-OnlyVolAnSelVolAnSubgraphIDSubgraphVL 0 0.2 0.4 0.6 0.8 1 0 10 20 30 40 50 60 70 80 90 100Recovery ratePartial Knowledge in %Count-OnlyVolAnSelVolAnSubgraphIDSubgraphVL 0 0.2 0.4 0.6 0.8 1 0 10 20 30 40 50 60 70 80 90 100Recovery ratePartial Knowledge in %Count-OnlyVolAnSelVolAnSubgraphIDSubgraphVL 0 0.2 0.4 0.6 0.8 1 1 2 3 4 5 6Recovery rateQuery Sequence Lengthhigh selectivitylow selectivity 1 4 16 64 256 1024 4096 16384123456Number of MatchesQuery Sequence LengthHigh selectivityLow selectivitypseudo-low-selectivity keywords;
• None of the attacks worked against
low-selectivity or
• When querying high-selectivity keywords, the rid and vol
patterns (which are respectively leaked by the BSL and
SMI constructions) can be exploited by our Subgraph
attacks with very low known-data rates (as low as 5%).
Note that high recovery rates are maintained across dif-
ferent settings. In addition, we believe our attacks would
do even better on larger data collections. For example,
on collections on the order of gigabytes we estimate
that relatively high recovery rates could still be achieved
with known-data rates as low as 1%. We conclude that,
for high-selectivity keywords, there are practical attacks
against leakage proﬁles that include rid and vol.
• When querying high-selectivity keywords, the total vol-
ume pattern (which is leaked by OPQ and FLL) seems
resistant to our attacks for δ ≤ .8.
• The total volume pattern tvol can be successfully attacked
with our injection attacks (though in the case of the Binary
Search attack only if the target query has a unique total
volume).
• Structured and oblivious ESAs seem to provide the same
level of security against both our known-data (i.e., leakage
abuse) and chosen-data (i.e., injection) attacks.
VII. COUNTERMEASURES
Our study revealed two settings in which our attacks could
be practical. The ﬁrst is using our Subgraph attacks to exploit
the rid and vol patterns on high-selectivity keywords and the
second is using our volumetric injection attacks to exploit the
total volume pattern. For all other settings, we do not believe
any countermeasures are required though they are certainly
available.
High-selectivity keywords. For high-selectivity key-
words, one should simply use a scheme that does not leak
rid or vol like the PBS construction of [45] (see Appendix A
for a brief overview of PBS) or the OPQ or FLL constructions
described in Appendix A. These schemes have the following
leakage proﬁles
and ΛOPQ =(cid:0)(cid:63), (keq, tvol)(cid:1)
ΛPBS =(cid:0)(cid:63), (qeq, svol)(cid:1)
svol(D, w1, . . . , wt) =
|D|w.
i=1
D∈D(w)
Our experiments suggest that for δ ≤ .8 either OPQ or FLL
can be used but that for δ > .8 one should use PBS. Note that
the sequence volume pattern seems to be a very “low leakage”
pattern in the sense that even a “brute-force” attack that simply
tries to match keywords to the sequence volume leakage does
not work on our dataset. We provide more details below.
Brute force. We assume the adversary has full knowl-
edge of the client’s data, i.e., δ = 1. Given the sequence
volume pattern of a query sequence of length λ drawn uni-
formly at random from a set of 500 either low- or high-
selectivity keywords, the attack ﬁnds all possible sequences of
13
and,
ΛFLL =(cid:0)(cid:63), (rlen, tvol)(cid:1),
(cid:88)
t(cid:88)
where svol is the sequence volume pattern,
λ keywords that have sequence volume leakage equal to the
given/observed leakage. If there is only a single such sequence,
the attack returns it as its output otherwise it fails.
Note that
this is the best possible attack against
the
sequence volume pattern (not taking efﬁciency into account).
We deﬁne the attack’s success rate as the fraction of its output
that is correct; that is, the number of keywords in its output
sequence (assuming it outputs a sequence) that are indeed
in the client sequence over the size of the sequence. We
ran the attack for high- and low-selectivity keywords, with
λ ranging from 1 to 6 and found that when λ ≥ 4 the
attack stopped working. More precisely, in the case of low-
selectivity keywords its success rate was 0 and in the case of
high-selectivity keywords it was 0.02. Figure 3 describes these
results in detail.
Note that the success rate of the brute-force attack does
not capture partial knowledge since it only accounts for the
case where the attack ﬁnds a single “matching” sequence. For
example, the success rate could be 0 even though the attack
found just 2 matching sequences. To address this, we ran an
additional experiment that computes the number of matching
sequences found by the attack. The results are described in
Figure 4 which shows that the average number of matches
grows exponentially as a function of the sequence length (this
holds independently of the selectivity of the keywords in the
sequence). For example, for λ = 5, there are 385 matching
sequences even when the keyword space space is as small
as 100.11 Notice that increasing the number of keywords will
signiﬁcantly increase the number of matches.
On the cost of OPQ, FLL, and PBS. The cost of OPQ
and FLL is described in Section II so we focus on PBS [45].
This construction uses a response-hiding multi-map encryption
scheme so the query overhead is comparable to BSL and OPQ.
However, it does introduce additional latency which is not
incurred by previous constructions. That is, while PBS’s query
algorithm is very efﬁcient (for the server) the user might need
to wait until it makes additional queries to retrieve the complete
response of a query. The latency can be tuned to be smaller
but this requires some knowledge about the underlying dataset.
Note however that for applications where the user issues a
batch of queries all at once, PBS does not incur much latency.
In addition, we showed in the previous paragraph that batch
sizes as small as ﬁve can be safe. Additionally, the user could
make dummy queries instead of batching queries, in which
case latency will not be a factor.
Volumetric attacks. Recently, Kamara and Moataz [44]
proposed the ﬁrst volume-hiding encrypted multi-maps that do
not rely on na´ıve padding. The two constructions, VLH and
AVLH, achieve different trade-offs between storage efﬁciency,
query efﬁciency and lossiness and can be used to protect
against volumetric attacks. We refer the reader to Appendix A
for more details.
Note that VLH is lossy and can return false negatives.
The lossiness/false negatives, however, are tunable and can
be traded-off for additional storage. Depending on the choice
of parameters, VLH can be as efﬁcient as BSL and OPQ.
11For this experiment we had to reduce the size of the keyword space from
500 to 100 keywords, because the former results in an extremely large number
of sequences to check, i.e.,(cid:0)500
(cid:1) (cid:39) 2 · 1013
6
AVLH, on the other hand, has no false negatives but
its
query complexity is the maximum response length (over the
keyword space). The storage overhead of AVLH is comparable
to the overhead of BSL. Recent volume-hiding results by Patel,
Persiano, Yeo and Yung [61] show how to get even better query
complexity and storage overhead.
Another approach to protecting against volumetric attacks
is to use padding techniques. Na¨ıve padding (adding dummy
values to ensure the volume of every query response is of the
same size) will protect against volumetric attacks but incurs a
large storage overhead. More efﬁcient padding techniques were
proposed by Bost and Fouque [12]. While these techniques
seem to make attacks harder,
is not clear if they can
completely mitigate them.
it
ACKNOWLEDGMENT
We would like to thank the authors of [13] for answering
our questions about the Count attack, for sharing the code of
the Count attack with us, and for useful feedback on this work.
REFERENCES
“Apache lucene,” 1999, http://lucene.apache.org.
[1]
[2] R. Agrawal, J. Kiernan, R. Srikant, and Y. Xu, “Order preserving en-
cryption for numeric data,” in ACM SIGMOD International Conference
on Management of Data, 2004, pp. 563–574.
[3] G. Amjad, S. Kamara, and T. Moataz, “Breach-resistant structured
encryption,” Proceedings on Privacy Enhancing Technologies, vol.
2019, no. 1, pp. 245–265, 2019.
[4] G. Asharov, M. Naor, G. Segev, and I. Shahaf, “Searchable
symmetric encryption: Optimal
locality in linear space via two-
dimensional balanced allocations,” in ACM Symposium on Theory
of Computing (STOC ’16),
ser. STOC ’16. New York, NY,
USA: ACM, 2016, pp. 1101–1114.
[Online]. Available: http:
//doi.acm.org/10.1145/2897518.2897562
[5] G. Asharov, T. H. Chan, K. Nayak, R. Pass, L. Ren, and E. Shi,
“Oblivious computation with data locality,” ePrint IACR, 2017.
J.-P. Aumasson, “Cryptanalysis vs. reality,” in Black Hat (Abu Dhabi),
2011.
[6]
[7] M. Bellare, A. Boldyreva, and A. O’Neill, “Deterministic and efﬁciently
searchable encryption,” in Advances in Cryptology – CRYPTO ’07, ser.
Lecture Notes in Computer Science, A. Menezes, Ed. Springer, 2007,
pp. 535–552.
[8] A. Boldyreva, N. Chenette, Y. Lee, and A. O’neill, “Order-preserving
symmetric encryption,” in Advances in Cryptology - EUROCRYPT
2009, 2009, pp. 224–241.
[9] D. Boneh, A. Sahai, and B. Waters, “Functional encryption: Deﬁnitions
and challenges,” in Theory of Cryptography Conference (TCC ’11), ser.
Lecture Notes in Computer Science, vol. 6597.
Springer, 2011, pp.
253–273.
[10] R. Bost, “Sophos - forward secure searchable encryption,” in ACM
Conference on Computer and Communications Security (CCS ’16),
20016.
[11] R. Bost, B. Minaud, and O. Ohrimenko, “Forward and backward private
searchable encryption from constrained cryptographic primitives,” in
ACM Conference on Computer and Communications Security (CCS
’17), 2017.
[12] R. Bost and P.-A. Fouque, “Thwarting leakage abuse attacks against
searchable encryption – a formal approach and applicaitons to database
padding,” IACR Cryptology ePrint Archive, Tech. Rep. 2017/1060,
2017.
[13] D. Cash, P. Grubbs, J. Perry, and T. Ristenpart, “Leakage-abuse attacks
against searchable encryption,” in ACM Conference on Communications
and Computer Security (CCS ’15). ACM, 2015, pp. 668–679.
14
[14] D. Cash, S. Jarecki, C. Jutla, H. Krawczyk, M. Rosu, and M. Steiner,
“Highly-scalable searchable symmetric encryption with support for
boolean queries,” in Advances in Cryptology - CRYPTO ’13. Springer,
2013.
[15] D. Cash and S. Tessaro, “The locality of searchable symmetric encryp-