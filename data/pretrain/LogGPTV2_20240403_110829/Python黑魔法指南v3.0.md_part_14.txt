>>> c=bool()
>>> c
False
因为 defaultdict 可以这样子用。
>>> import collections
>>> profile=collections.defaultdict(int)
>>> profile
defaultdict(, {})
>>> profile["age"]
0
>>> profile=collections.defaultdict(str)
>>> profile
defaultdict(, {})
>>> profile["name"]
''
当然既然是工厂方法，你也可以使用 lambda 匿名函数来实现自定义的效果，比如我们使用 str 就
会设置一个空字符串，但这并不是我想要的，我想要的是设置一个其他字符串，你就可以像下面这
样子。
>>> info=collections.defaultdict(lambda: "default value")
>>> info
defaultdict( at 0x10ff10488>, {})
>>>
>>> info["msg"]
'default value'
5.22 如何实现函数的连续调用？
现在我想写一个函数可以实现把所有的数进行求和，并且可以达到反复调用的目的。
比如这样子。
>>> add(2)(3)(4)(5)(6)(7)
27
当只调用一次时，也必须适用。
>>> add(2)
2
每次调用的返回结果都是一个 int 类型的实例，要实现将一个实例看做一个函数一样调用，那就不
得不使用到 __call__ 这个魔法方法。
>>> class AddInt(int):
... def __call__(self, x):
... print("calling __call__ function")
... return AddInt(self.numerator + x)
...
>>>
>>> age = AddInt(18)
>>> age
18
>>> age(1)
calling __call__ function
19
有了上面的铺垫，可以再 AddInt 外层再加一层封装即可。
>>> def add(x):
... class AddInt(int):
... def __call__(self, x):
... return AddInt(self.numerator + x)
... return AddInt(x)
...
>>> add(2)
2
>>> add(2)(3)(4)(5)(6)(7)
27
>>>
5.23 如何实现字典的多级排序
在一个列表中，每个元素都是一个字典，里面的每个字典结构都是一样的。
里面的每个字典会有多个键值对，根据某个 key 或 value 的值大小，对该列表进行排序，使用 sort
函数就可以轻松实现。
>>> students = [{'name': 'Jack', 'age': 17, 'score': 89}, {'name': 'Julia', 'age': 1
7, 'score': 80}, {'name': 'Tom', 'age': 16, 'score': 80}]
>>> students.sort(key=lambda student: student['score'])
>>> students
[{'age': 17, 'score': 80, 'name': 'Julia'}, {'age': 16, 'score': 80, 'name': 'Tom'},
{'age': 17, 'score': 89, 'name': 'Jack'}]
如果两名同学的成绩一样，那谁排在前面呢？
那就再额外再定个第二指标呗，成绩一样，就再看年龄，年龄小的，成绩还能一样，那不是更历害
嘛 。
规则定下了：先按成绩降序，如果成绩一致，再按年龄降序。
问题来了，这样的规则，代码该如何实现呢？
用字典本身的 sort 函数也能实现，方法如下：
>>> students = [{'name': 'Jack', 'age': 17, 'score': 89}, {'name': 'Julia', 'age': 1
7, 'score': 80}, {'name': 'Tom', 'age': 16, 'score': 80}]
>>> students.sort(key=lambda student: (student['score'], student['age']))
>>> students
[{'age': 16, 'score': 80, 'name': 'Tom'}, {'age': 17, 'score': 80, 'name': 'Julia'},
{'age': 17, 'score': 89, 'name': 'Jack'}]
那如果一个降序，而另一个是升序，那又该怎么写呢？
很简单，只要在对应的 key 上，前面加一个负号，就会把顺序给颠倒过来。
还是以上面为例，我现在要实现先按成绩降序，如果成绩一致，再按年龄升序。可以这样写
>>> students = [{'name': 'Jack', 'age': 17, 'score': 89}, {'name': 'Julia', 'age': 1
7, 'score': 80}, {'name': 'Tom', 'age': 16, 'score': 80}]
>>> students.sort(key=lambda student: (student['score'], -student['age']))
>>> students
[{'age': 17, 'score': 80, 'name': 'Julia'}, {'age': 16, 'score': 80, 'name': 'Tom'},
{'age': 17, 'score': 89, 'name': 'Jack'}]
5.24 对齐字符串的两种方法
第一种：使用 format
左对齐
>>> "{:>>
右对齐
>>> "{:>10}".format("a")
' a'
>>>
居中
>>> "{:^10}".format("a")
' a '
>>>
当你不指定  、 ^ 时，默认就是左对齐
>>> "{:10}".format("a")
'a '
>>>
有了上面的铺垫，写一个整齐的 1-10 的平方、立方表就很容易了。
>>> for x in range(1, 11):
... print('{:2d} {:3d} {:4d}'.format(x, x*x, x*x*x))
...
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000
对齐的思想其实就是在不足的位自动给你补上空格。
如果不想使用空格，可以指定你想要的字符进行填充，比如下面我用 0 来补全。
>>> for x in range(1, 11):
... print('{:02d} {:03d} {:04d}'.format(x, x*x, x*x*x))
...
01 001 0001
02 004 0008
03 009 0027
04 016 0064
05 025 0125
06 036 0216
07 049 0343
08 064 0512
09 081 0729
10 100 1000
第二种：使用 ljust, rjust
左对齐
>>> "a".ljust(10)
'a '
>>>
右对齐
>>> "a".rjust(10)
' a'
>>>
居中
>>> "a".center(10)
' a '
>>>
同样写一个整齐的 1-10 的平方、立方表
>>> for x in range(1, 11):
... print(' '.join([str(x).ljust(2), str(x * x).ljust(3), str(x * x * x).ljust(4
)]))
...
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000
如果不想使用空格，而改用 0 来补齐呢？可以这样
>>> for x in range(1, 11):
... print(' '.join([str(x).rjust(2, "0"), str(x*x).rjust(3, "0"), str(x*x*x).rju
st(4, "0")]))
...
01 001 0001
02 004 0008
03 009 0027
04 016 0064
05 025 0125
06 036 0216
07 049 0343
08 064 0512
09 081 0729
10 100 1000
5.25 将位置参数变成关键字参数
在 Python 中，参数的种类，大概可以分为四种：
1.  ，也叫  ，调用函数时一定指定的参数，并且在传参的时候必须按函数定义时的
顺序来
2.  ，也叫  ，调用函数时，可以指定也可以不指定，不指定就默认的参数值来。
3.  ，就是参数个数可变，可以是 0 个或者任意个，但是传参时不能指定参数名，通常使
用 *args 来表示。
4.  ，就是参数个数可变，可以是 0 个或者任意个，但是传参时必须指定参数名，通常
使用 **kw 来表示
使用单独的 * ，可以后面的位置参数变成关键字参数，关键字参数在你传参时，必须要写参数
名，不然会报错。
>>> def demo_func(a, b, *, c):
... print(a)
... print(b)
... print(c)
...
>>>
>>> demo_func(1, 2, 3)
Traceback (most recent call last):
File "", line 1, in 
TypeError: demo_func() takes 2 positional arguments but 3 were given
>>>
>>> demo_func(1, 2, c=3)
1
2
3
5.26 如何获取一个函数设定的参数
在 Python 中有一个叫 inspect 的库，非常的好用，利用它可以获取一些数据，这在写一些框架时
非常有用。
比如有下面这样一个函数
def demo(name, age, gender="male", *args, **kw):
pass
使用 inspect 可以直接获取
>>> from inspect import signature
>>>
>>> sig = signature(demo) # # 
>>> sig
利用 inspect 还可以检查传参是否匹配签名
>>> sig.bind("", 27)
>>>
>>> sig.bind("")
Traceback (most recent call last):
File "", line 1, in 
File "/usr/lib64/python3.6/inspect.py", line 2997, in bind
return args[0]._bind(args[1:], kwargs)
File "/usr/lib64/python3.6/inspect.py", line 2912, in _bind
raise TypeError(msg) from None
TypeError: missing a required argument: 'age'
5.27 如何进行版本的比较
使用 distutils
distutils 是 Python 的内置模块，它做为最古老的 python 分发工具，本身也实现了版本的比较
与检查的功能。
>>> from distutils.version import LooseVersion, StrictVersion
>>> LooseVersion("2.3.1") >> StrictVersion("2.3.1") >> from packaging import version
>>> version.parse("2.3.1") >> version.parse("1.3.a4") 0:
print(w[0].message)
运行后，效果如下
## 5.29 如何禁止对象深拷贝?
当你使用 copy 模块的 deepcopy 拷贝一个对象后，会创建出来一个全新的的对象。
>>> from copy import deepcopy
>>>
>>> profile = {"name": "wangbm"}
>>> id(profile)
21203408
>>>
>>> new_profile = deepcopy(profile)