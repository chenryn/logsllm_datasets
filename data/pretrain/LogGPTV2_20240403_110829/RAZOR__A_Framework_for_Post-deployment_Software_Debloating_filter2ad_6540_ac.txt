### Immediate Instrumentation Removal
To minimize unnecessary overhead, we remove the instrumentation immediately after its first execution. Similarly, we eliminate the instrumentation of conditional branches once that branch has been taken. However, we retain the instrumentation for indirect call and jump instructions, as the complete set of targets is unknown.

### Efficient Tracing with Hardware Features
Given the overhead associated with software instrumentation, we have developed an efficient Tracer using Intel Processor Trace (Intel PT) [20]. Intel PT records flow information in a highly compressed format: the TNT packet indicates whether a conditional branch is taken or not, while the TIP packet records the target of indirect branches, such as indirect calls and returns. Since Intel PT writes traces directly to physical memory without interacting with the page table or memory cache, it provides the most efficient tracing. Our Tracer decodes these traces to extract necessary control-flow information. Other hardware features, such as Branch Trace Store (BTS) on Intel CPUs or Program Flow Trace (PTM) on ARM CPUs, can also be used to implement efficient tracers on different platforms.

### 4.2 Update ELF Exception Handler
ELF binaries generated by GCC and Clang use table-based exception handling [46] to provide stack unwind and exception handler information. Specifically, the .eh_frame_hdr section contains a table with one entry per function, each pointing to a frame description entry (FDE) in the .eh_frame section. The FDE further specifies the location of the language-specific data area (LSDA), which includes the concrete addresses of exception handlers, known as landingpads.

We must replace the old landingpad values in the .gcc_except_table with new ones. The challenge lies in the fact that the values in .gcc_except_table are encoded in LEB128 format, a variable-length encoding that can result in different lengths for different values. Updating the old address with a new one may increase the byte count, making it impossible to fit into the original location. To address this, we update the binary's section layout to create more space for the new addresses. We shrink the table in the .eh_frame_hdr section to exclude entries for non-executed functions, as only the functionalities triggered by the given test cases will be included in the debloated binary. We then shift the .eh_frame and .gcc_except_table sections to accommodate the updated landingpad values.

### 5 Evaluation
In this section, we conduct extensive evaluations to understand RAZOR in the following aspects:
- **Code Reduction:** How much code can RAZOR reduce?
- **Functionality:** Does the debloated binary support the functionalities specified in the given test cases? (§5.2) How effective is PathFinder in finding complementary code? (§5.3)
- **Security:** Does RAZOR reduce the attack surface of the debloated binaries? (§5.4)
- **Performance:** What is the overhead introduced by RAZOR in the debloated binary? (§5.5)
- **Practicality:** Is RAZOR applicable to commonly used software in real-world scenarios? (§5.6)

#### Experiment Setup
We set up three sets of benchmarks to evaluate RAZOR:
- 29 SPEC CPU2006 benchmarks, including 12 C programs, 7 C++ programs, and 10 Fortran programs.
- 10 coreutils programs from the CHISEL paper [15].
- The web browser Firefox and the closed-source PDF reader FoxitReader.

For SPEC and CHISEL benchmarks, we used software-based tracing tools relying on DynamoRIO and Pin to collect execution traces. For complex programs like Firefox and FoxitReader, we used a hardware-based tracing tool (Intel PT) to ensure execution speed and avoid abnormal behaviors. All experiments were conducted on a 64-bit Ubuntu 16.04 system with an Intel Core i7-6700K CPU (eight 4.0GHz cores) and 32 GB RAM.

### 5.1 Code Reduction
We applied RAZOR to SPEC CPU2006 and CHISEL benchmarks to measure code size reduction. For SPEC benchmarks, we used the train dataset as the user-provided test cases. For CHISEL benchmarks, we obtained test cases from the paper's authors. No path-finding heuristics were applied in this evaluation. Since RAZOR operates on binaries, we compared the size of the executable memory region before and after debloating, specifically focusing on program segments with executable permissions.

On average, RAZOR achieved a 68.19% code reduction for SPEC benchmarks and 78.8% for CHISEL benchmarks. Notably, for dealII, hmmer, gamess, and tar, RAZOR removed over 90% of the original code. For bwaves, zeusmp, and GemsFDTD, RAZOR achieved less than 30% code reduction. These exceptions were due to the relatively small size of the programs and the train datasets triggering most of the code.

CHISEL achieved an 83.4% code reduction on CHISEL benchmarks. For seven programs, CHISEL reduced more code than RAZOR, while RAZOR outperformed CHISEL for the other three. CHISEL tends to remove more code as long as the execution result remains the same. For example, variable initialization code at the beginning of a function is always executed; CHISEL removes it if the variable is unused, whereas RAZOR retains it. Although CHISEL slightly outperforms RAZOR in code reduction, the debloated binaries from CHISEL suffer from robustness and security issues (§5.2, §5.4).

Other reduction metrics include basic blocks (Figure 7a) and instructions (Figure 7b). On average, RAZOR removed 53.1% of basic blocks and 63.3% of instructions, while CHISEL reduced 66.0% of basic blocks and 88.5% of instructions. This result aligns with the code size reduction, where RAZOR reduces less code because it cannot remove executed-but-unnecessary blocks or instructions and does not aggressively optimize the debloated code.

### 5.2 Functionality Validation
We ran the debloated binaries from CHISEL benchmarks against the given test cases to assess their robustness. For each benchmark, we compiled the original source code to get the original binary and the debloated source code from CHISEL to get the CHISEL binary. We then used RAZOR to debloat the original binary with the given test cases, generating the RAZOR binary. We ran the original, CHISEL, and RAZOR binaries with the test cases and examined the results to ensure the required functionalities were retained.

Table 2 shows the validation results. RAZOR binaries produced the same results as the original binaries for all test cases, demonstrating their robustness. Surprisingly, CHISEL binaries passed the tests for only three programs (chown, sort, and uniq) and exhibited unexpected behaviors for the other seven programs. We identified four common issues:
- **Wrong Operation:** The debloated program performs unexpected operations. For example, bzip2 should decompress the file when the -d option is specified, but the CHISEL-debloated binary always decompresses the file regardless of the option.
- **Infinite Loop:** CHISEL may remove loop condition checks, leading to infinite loops. For instance, gzip fails a test case due to an infinite loop caused by the removal of the condition check.
- **Crashes:** The debloated binary crashes during execution. For example, date crashes three test cases because CHISEL removes the NULL check for strcmp parameters.
- **Missed Output:** CHISEL removes code for printing to stdout and stderr, leading to missed results. For example, grep fails six test cases because it does not print any output even though it finds matched strings.

### 5.3 Effectiveness of Path Finding
We evaluated the effectiveness of PathFinder in finding related code for required functionalities using two sets of experiments. First, we used RAZOR to debloat programs with different heuristics, from no heuristic to the most aggressive zFunc heuristic, to find the least aggressive heuristic for each program. Second, we performed N-fold cross-validation to assess the robustness of our heuristics. In this subsection, we focus on the first experiment, and the N-fold cross-validation is discussed in §5.6.1.

We tested RAZOR on CHISEL benchmarks as follows:
1. Designed training and testing inputs that cover the same functionalities.
2. Applied RAZOR with different heuristics to debloat the programs.
3. Measured the code reduction and the number of crashes for each heuristic.

Figure 8 shows the results of path finding on CHISEL benchmarks with different heuristics. The top part displays code reduction, and the bottom part shows the number of crashes. 'none' indicates no heuristic was used.