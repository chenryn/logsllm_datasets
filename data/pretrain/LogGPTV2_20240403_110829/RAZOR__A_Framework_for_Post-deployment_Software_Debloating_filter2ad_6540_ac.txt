immediately after its first execution to avoid unnecessary over-
head. Similarly, we remove the instrumentation of conditional
branches once that branch has been taken. However, we keep
the instrumentation of indirect call and jump instructions, as
we do not know the complete set of targets.
Tracing with hardware feature. Considering the overhead
of software instrumentation, we provide an efficient Tracer
built on Intel Processor Trace (Intel PT) [20]. Intel PT
records the change of flow information in a highly compressed
manner: the TNT packet describes whether one conditional
branch is taken or non-taken; the TIP packet records the tar-
get of indirect branches, like indirect call and return. As
Intel PT directly writes the trace to physical memory with-
out touching the page table or memory cache, it achieves the
most efficient tracing. Our Tracer decodes the traces from
Intel PT to get necessary control-flow information. We can
use other hardware features available on different platforms
to implement efficient Tracer, like branch trace store (BTS)
on Intel CPUs or program flow trace (PTM) on ARM CPUs.
4.2 Update ELF Exception Handler
ELF binaries generated by gcc and clang adopt the table-
based exception handling [46] to provide stack unwind and
exception handler information. Specifically, ELF keeps a
table in the .eh_frame_hdr section, one entry per function.
Each entry indicates the location of a frame description en-
try (FDE) in the .eh_frame section, which further specifies
the location of the language-specific data area (LSDA). The
LSDA region in the .gcc_except_table section contains the
concrete address of exception handlers, called landingpad.
We have to replace the old value of all landingpads in
.gcc_except_table with the new ones. However, the chal-
lenge is that the value in .gcc_except_table is encoded in
the LEB128 format – a variable-length encoding that may
have different lengths for different values. Since we update
the old address with a different one, the encoding of the
new address may take more bytes and thus cannot be put
into the original location. To solve this problem, we update
the section layout of the binary to create more space for the
new address. Specifically, we shrink the table inside the
.eh_frame_hdr section to exclude entries of non-executed
functions. Recall that the given test cases only trigger part of
the functionalities, and the non-executed functions will not
be included in the debloated binary. Then we shift .eh_frame
and .gcc_except_table sections to get more space for our
update of landingpad values.
5 Evaluation
from the original bloated binary? (§5.1)
In this section, we perform extensive evaluation in order to
understand RAZOR regarding the following aspects:
• Code reduction. How much code can RAZOR reduce
• Functionality. Does the debloated binary support the
functionalities in given test cases? (§5.2) How effective
is PathFinder in finding complementary code? (§5.3)
• Security. Does RAZOR reduce the attack surface of the
debloated binaries? (§5.4)
1740    28th USENIX Security Symposium
USENIX Association
100%
80%
60%
40%
20%
0%
Razor
Chisel
bzip2
chown
date
grep
gzip
mkdir
rm
sort
tar
(a) basic blocks
uniq
AVERAGE
100%
80%
60%
40%
20%
0%
Razor
Chisel
bzip2
chown
date
grep
gzip
mkdir
rm
sort
tar
(b) instructions
uniq
AVERAGE
100%
80%
60%
40%
20%
0%
Razor
Chisel
bzip2
chown
date
grep
gzip
mkdir
rm
sort
tar
(c) ROP gadgets
uniq
AVERAGE
Figure 7: Reduction of basic blocks, instructions, and ROP gadgets, debloated by RAZOR and CHISEL from CHISEL benchmarks.
• Performance. How much overhead does RAZOR intro-
• Practicality. Does RAZOR work on commonly used
duce into the debloated binary? (§5.5)
software in the real world? (§5.6)
Experiment setup. We set up three sets of benchmarks to
evaluate RAZOR: 29 SPEC CPU2006 benchmarks, including
12 C programs, seven C++ programs, and 10 Fortran pro-
grams; 10 coreutils programs used in the CHISEL paper1 [15];
the web browser Firefox and the close-source PDF reader
FoxitReader. We use the software-based tracing tools that
rely on Dynamorio and Pin to collect the execution traces
of SPEC and CHISEL benchmarks, to get accurate results;
for the complicated programs Firefox and FoxitReader, we
use the hardware-based tracing tool (relying on Intel PT) to
guarantee the execution speed to avoid abnormal behaviors.
We ran all the experiments on a 64-bit Ubuntu 16.04 system
equipped with Intel Core i7-6700K CPU (with eight 4.0GHz
cores) and 32 GB RAM.
5.1 Code Reduction
We applied RAZOR on SPEC CPU2006 benchmarks and
CHISEL benchmarks to measure the code size reduction. For
SPEC benchmarks, we treated the train dataset as the user-
given test cases. For CHISEL benchmarks we obtained test
cases from the paper’s authors. We did not apply any heuris-
tics of path finding for this evaluation. As RAZOR works
on binaries, we cannot measure the reduction of source code
lines. Instead, we compare the size of the executable mem-
ory region before and after the debloating, specifically, the
program segments with the executable permission. Figure 6a
shows the code reduction of SPEC benchmarks debloated
by RAZOR. Figure 6b shows the code reduction of CHISEL
benchmarks, debloated by CHISEL and RAZOR.
On average, RAZOR achieves 68.19% code reduction for
SPEC benchmarks and 78.8% code reduction for CHISEL
benchmarks. Especially for dealII, hmmer, gamess, and tar,
RAZOR removes more than 90% of the original code. For
bwaves, zeusmp, and GemsFDTD, RAZOR achieves less than
30% code reduction. We investigated these exceptions and
found that these programs are relatively small and the train
1We appreciate the help of CHISEL authors for sharing the source code
and their benchmarks.
datasets already trigger most of the code.
Meanwhile, CHISEL achieves 83.4% code reduction on
CHISEL benchmarks. For seven programs, CHISEL reduces
more code than RAZOR, while RAZOR achieves higher code
reduction than CHISEL for the other three programs. CHISEL
tends to remove more code as long as the execution result
remains the same. For example, variable initialization code
always gets executed at the function beginning. CHISEL will
remove it if the variable is not used in the execution, while
RAZOR will keep it in the debloated binary. Although CHISEL
performs slightly better than RAZOR on code reduction, we
find that the debloated binaries from CHISEL suffer from
robustness issues (§5.2) and security issues (§5.4).
Other reduction metrics. We also measured RAZOR’s ef-
fectiveness on reducing basic blocks (Figure 7a) and instruc-
tions (Figure 7b) from CHISEL benchmarks and compared
these results with those achieved by CHISEL. On average,
RAZOR removes 53.1% of basic blocks and 63.3% of in-
structions from the original programs, while CHISEL reduces
66.0% of basic blocks and 88.5% of instructions from the
same set of programs. This result is consistent with the code
size reduction, where RAZOR reduces less code, as it can
neither remove any executed-but-unnecessary blocks or in-
structions, nor utilize compiler to aggressively optimize the
debloated code.
5.2 Functionality Validation
We ran the debloated binaries in CHISEL benchmarks against
given test cases to understand their robustness. For each
benchmark, we compiled the original source code to get the
original binary and compiled the debloated source code from
CHISEL to get the CHISEL binary. Then, we used RAZOR to
debloat the original binary with given test cases, generating
the RAZOR binary. Next, we ran the original binary, the
CHISEL binary, and the RAZOR binary again with the test
cases. We examine the execution results to see whether the
required functionalities are retained in the debloated binaries.
Table 2 shows the validation result. RAZOR binaries pro-
duce the same results as those from the original binaries for
all test cases of all programs (the last column), showing the
robustness of the debloated binaries. Surprisingly, CHISEL
binaries only pass the tests of three programs (i.e., chown,
USENIX Association
28th USENIX Security Symposium    1741
Failed by Chisel
Failed
Program Version
bzip2
chown
date
grep
gzip
mkdir
rm
sort
tar
uniq
1.0.5
8.2
8.21
2.19
1.2.4
5.2.1
8.4
8.16
1.14
8.16
# of
Tests W I
–
–
–
–
1
–
–
–
–
–
6
14
50
26
5
13
4
112
26
16
2
–
5
–
–
–
2
–
3
–
C M by Razor
2
–
3
–
–
–
–
–
–
–
– (zLib)
– (zFunc)
– (zLib)
– (zLib)
– (zLib)
– (zLib)
– (zFunc)
– (zCall)
– (zCall)
– (zCall)
–
–
–
6
–
1
–
–
4
–
Table 2: Failed test cases by RAZOR binaries and CHISEL binaries.
CHISEL failed some tests with different reasons: Wrong operations,
Infinite loop, Crashes, and Missing output. For RAZOR binaries, we
show the heuristic that makes the program pass all tests.
sort, and uniq) and trigger some unexpected behaviors for
the other seven programs. Considering that CHISEL verifies
the functionality of the debloating binary, such a low pass-
ing rate is confusing. We checked these failed cases and
the verification process of CHISEL and found four common
issues.
Wrong operation. The debloated program performs unex-
pected operations. For examples, bzip2 should decompress
the given file when the test case specifies the -d option. How-
ever, the binary debloated by CHISEL always decompresses
the file regardless of what option is used. We suspect that
CHISEL only uses one test case of decompression to debloat
the program and thus removes the code that parses command
line options.
Infinite loop. CHISEL may remove loop condition checks,
leading to infinite loops. For example, gzip fails one test case
because it falls into a loop in which CHISEL drops the condi-
tion check. We believe the reason is that the test case used by
CHISEL only iterates the loop one time. The verification step
of CHISEL should identify this problem. However, we found
that the verification script adopts a small timeout (e.g., 0.1s)
and treats any timeout as a successful verification. Therefore,
it cannot detect any infinite loops.
Crashes. The debloated binary crashes during execution.
For example, date crashes three test cases because CHISEL
removes the check on whether the parameters of strcmp are
NULL. bzip2 crashes three test cases for the same reason.
Missed output. CHISEL removes code for printing out on
stdout and stderr, leading to missed results. For example,
grep fails six test cases, as the binary does not print out any
result even through it successfully finds matched strings. We
find that in the verification script of CHISEL, all output of
the debloated binaries is redirected to the /dev/null device.
Therefore, it cannot detect any missing or inconsistent output.
e
t
a
r
n
o
i
t
c
u
d
e
r
>
—
<
#
h
s
a
r
c
100%
80%
60%
40%
20%
0%
10
20
30
40
none
zCode
gzip
zCall
zLib
sort
rm
zFunc
bzip2
date
grep
cho w n
A V G
Figure 8: Path finding on CHISEL benchmarks with different heuris-
tics. The top part is the code reduction, while the bottom part is the
number of crashes. ‘none’ means no heuristic is used.
m kdir
tar
uniq
5.3 Effectiveness of Path Finding
We use two sets of experiments to evaluate the effectiveness
of PathFinder on finding the related-code of required func-
tionalities. First, we use RAZOR to debloat programs with
different heuristics, from the empty heuristic to the most ag-
gressive zFunc heuristic, aiming to find the least aggressive
heuristic for each program. Second, we perform N-fold cross
validation to understand the robustness of our heuristic. In
this subsection, we focus on the first experiment and leave
the N-fold cross validation in §5.6.1.
We tested RAZOR on CHISEL benchmarks as follows: (1)
design training inputs and testing inputs that cover the same