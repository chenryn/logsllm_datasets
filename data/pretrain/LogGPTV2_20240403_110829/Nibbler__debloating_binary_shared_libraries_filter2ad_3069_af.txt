### References

1. **Ulrich Drepper. [n.d.]. ELF Symbol Versioning.**
   - https://www.akkadia.org/drepper/symbol-versioning

2. **Isaac Evans, Fan Long, Ulziibayar Otgonbaatar, Howard Shrobe, Martin Rinard, Hamed Okhravi, and Stelios Sidiroglou-Douskos. 2015. Control Jujutsu: On the Weaknesses of Fine-Grained Control Flow Integrity. In Proc. of ACM CCS. 901–913.**

3. **Michael Franz and Thomas Kistler. 1997. Slim Binaries. Commun. ACM 40, 12 (Dec. 1997), 87–94.**

4. **Cristiano Giuffrida, Anton Kuijsten, and Andrew S. Tanenbaum. 2012. Enhanced Operating System Security Through Efficient and Fine-grained Address Space Randomization. In Proc. of USENIX SEC. 475–490.**

5. **Enes Göktas, Elias Athanasopoulos, Herbert Bos, and Georgios Portokalidis. 2014. Out of Control: Overcoming Control-Flow Integrity. In Proc. of IEEE S&P. 575–589.**

6. **J. Hamilton and S. Danicic. 2009. An Evaluation of Current Java Bytecode Decompilers. In Proc. of IEEE SCAM. 129–136.**

7. **Kihong Heo, Woosuk Lee, Pardis Pashakhanloo, and Mayur Naik. 2018. Effective Program Debloating via Reinforcement Learning. In Proc. of ACM CCS. 380–394.**

8. **Hex-Rays. 2016. The IDA Pro Disassembler and Debugger.**
   - https://www.hex-rays.com/products/ida/

9. **Patrick Horgan. [n.d.]. Linux x86 Program Start Up.**
   - http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

10. **Intel. 2013. System V Application Binary Interface.**
    - https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf

11. **Y. Jiang, D. Wu, and P. Liu. 2016. JRed: Program Customization and Bloatware Mitigation Based on Static Analysis. In Proc. of IEEE COMPSAC. 12–21.**

12. **Y. Jiang, C. Zhang, D. Wu, and P. Liu. 2016. Feature-Based Software Customization: Preliminary Analysis, Formalization, and Methods. In Proc. of IEEE HASE. 122–131.**

13. **JoeDog. 2017. Siege – an HTTP load tester and benchmarking utility.**
    - https://github.com/JoeDog/siege

14. **Johannes Kinder and Helmut Veith. 2010. Precise Static Analysis of Untrusted Driver Binaries. In Proc. of FMCAD. 43–50.**

15. **Hyungjoon Koo, Seyedhamed Ghavamnia, and Michalis Polychronakis. 2019. Configuration-Driven Software Debloating. In Proceedings of the 12th European Workshop on Systems Security. ACM, 9.**

16. **Anil Kurmus, Reinhard Tartler, Daniela Dorneanu, Bernhard Heinloth, Valentin Rothberg, Andreas Ruprecht, Wolfgang Schröder-Preikschat, Daniel Lohmann, and Rüdiger Kapitza. 2013. Attack Surface Metrics and Automated Compile-Time OS Kernel Tailoring. In Proc. of NDSS.**

17. **Jason Landsborough, Stephen Harding, and Sunny Fugate. 2015. Removing the Kitchen Sink from Software. In Proc. of ACM GECCO. 833–838.**

18. **John R. Levine. 1999. Linkers and Loaders (1st ed.). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.**

19. **Linux Programmer’s Manual. 2018. rtld-audit – auditing API for the dynamic linker.**
    - http://man7.org/linux/man-pages/man7/rtld-audit.7.html

20. **LLVM Project. 2018. LLVM Link Time Optimization: Design and Implementation.**

21. **Gregory Malecha, Ashish Gehani, and Natarajan Shankar. 2015. Automated Software Winnowing. In Proc. of ACM SAC. 1504–1511.**

22. **Microsoft. 2015. Control Flow Guard. Windows Dev Center.**
    - https://msdn.microsoft.com/en-us/library/windows/desktop/mt637065(v=vs.85).aspx

23. **Microsoft. 2017. Symbols and Symbol Files. Microsoft Developer Network.**
    - https://msdn.microsoft.com/en-us/library/ff558825.aspx

24. **Ghassan Misherghi and Zhendong Su. 2006. HDD: Hierarchical Delta Debugging. In Proc. of ICSE. 142–151.**

25. **Shachee Mishra and Michalis Polychronakis. 2018. Shredder: Breaking Exploits through API Specialization. In Proc. of ACSAC. ACM, 1–16.**

26. **Collin Mulliner and Matthias Neugschwandtner. 2015. Breaking Payloads with Runtime Code Stripping and Image Freezing.**
    - https://www.blackhat.com/us-15/briefings.html#breaking-payloads-with-runtime-code-stripping-and-image-freezing

27. **Gail C. Murphy, David Notkin, William G. Griswold, and Erica S. Lan. 1998. An Empirical Study of Static Call Graph Extractors. ACM Trans. Softw. Eng. Methodol. 7, 2 (April 1998), 158–191.**

28. **National Security Agency. 2019. Ghidra. nsa.gov.**
    - https://www.nsa.gov/resources/ghidra/

29. **Ben Niu and Gang Tan. 2015. Per-Input Control-Flow Integrity. In Proc. of ACM PLDI. 577–587.**

30. **PaX Team. 2003. Address Space Layout Randomization (ASLR).**
    - https://pax.grsecurity.net/docs/aslr.txt

31. **Anh Quach, Aravind Prakash, and Lok Yan. 2018. Debloating Software through Piece-Wise Compilation and Loading. In 27th USENIX Security Symposium. USENIX Association, Baltimore, MD, 869–886.**

32. **Nguyen Anh Quynh. 2014. Capstone: Next-Gen Disassembly Framework. In BHUSA.**

33. **John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, and Xuejun Yang. 2012. Test-case Reduction for C Compiler Bugs. In Proc. of PLDI. 335–346.**

34. **Jonathan Salwan. 2011. ROPgadget - Gadgets finder and auto-roper.**
    - http://shell-storm.org/project/ROPgadget/

35. **Sascha Schirra. 2014. Ropper - rop gadget finder and binary information tool.**
    - https://scoding.de/ropper/

36. **Felix Schuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi, Ahmad-Reza Sadeghi, and Thorsten Holz. 2015. Counterfeit Object-oriented Programming: On the Difficulty of Preventing Code Reuse Attacks in C++ Applications. In Proc. of IEEE S&P. 745–762.**

37. **Edward J. Schwartz, Thanassis Avgerinos, and David Brumley. 2011. Q: Exploit Hardening Made Easy. In Proc. of USENIX SEC. 25–41.**

38. **Hovav Shacham. 2007. The Geometry of Innocent Flesh on the Bone: Return-into-libc Without Function Calls (on the x86). In Proc. of ACM CCS. 552–561.**

39. **Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar. 2018. TRIMMER: Application Specialization for Code Debloating. In Proc. of ACM/IEEE ASE. ACM, 329–339.**

40. **Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino, Audrey Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel, and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis. In IEEE Symposium on Security and Privacy. 138–157.**

41. **Kevin Z. Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko, Christopher Liebchen, and Ahmad-Reza Sadeghi. 2013. Just-In-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization. In Proc. of IEEE S&P. 574–588.**

42. **Khanh Nguyen and Guoqing Xu. 2013. Cachetor: Detecting Cacheable Data to Remove Bloat. In Proc. of ACM ESEC/FSE. 268–278.**

43. **Ben Niu and Gang Tan. 2014. Modular Control-Flow Integrity. In Proc. of ACM CCS. 914–926.**

44. **Raoul Strackx, Yves Younan, Pieter Philippaerts, Frank Piessens, Sven Lachmund, and Thomas Walter. 2009. Breaking the Memory Secrecy Assumption. In Proc. of EuroSec. 1–8.**

45. **Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su. 2018. Perses: Syntax-guided Program Reduction. In Proc. of ICSE. 361–371.**

46. **t0x0sh. 2014. A tool to help you write binary exploits.**
    - https://github.com/t00sh/rop-tool

47. **The Chromium Projects. 2018. Testing and infrastructure.**
    - https://www.chromium.org/developers/testing

48. **Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, Úlfar Erlingsson, Luis Lozano, and Geoff Pike. 2014. Enforcing Forward-edge Control-Flow Integrity in GCC & LLVM. In Proc. of USENIX SEC. 941–955.**

49. **TIS Committee. 1995. Tool Interface Standard (TIS)– Executable and Linking Format (ELF)– Specification– Version 1.2.**
    - http://refspecs.linuxbase.org/elf/elf.pdf

50. **Trail of Bits. 2019. McSema. GitHub.**
    - https://github.com/trailofbits/mcsema

51. **Victor van der Veen, Dennis Andriesse, Enes Göktaş, Ben Gras, Lionel Sambuc, Asia Slowinska, Herbert Bos, and Cristiano Giuffrida. 2015. Practical Context-Sensitive CFI. In Proc. of ACM CCS. 927–940.**

52. **Gregor Wagner, Andreas Gal, and Michael Franz. 2011. “Slimming” a Java Virtual Machine by Way of Cold Code Removal and Optimistic Partial Program Loading. Sci. Comput. Program. 76, 11 (Nov. 2011), 1037–1053.**

53. **Shuai Wang, Pei Wang, and Dinghao Wu. 2015. Reassembleable Disassembling. In 24th USENIX Security Symposium (USENIX Security). 627–642.**

54. **Zhe Wang, Chenggang Wu, Jianjun Li, Yuanming Lai, Xiangyu Zhang, Wei-Chung Hsu, and Yueqiang Cheng. 2017. ReRanz: A Light-Weight Virtual Machine to Mitigate Memory Disclosure Attacks. In Proc. of ACM VEE. 143–156.**

55. **Richard Wartell, Yan Zhou, Kevin W. Hamlen, Murat Kantarcioglu, and Bhavani Thuraisingham. 2011. Differentiating Code from Data in x86 Binaries. In Proc. of ECML-PKDD. 522–536.**

56. **David Williams-King, Graham Gobieski, Kent Williams-King, James P. Blake, Xinhao Yuan, Patrick Colp, Michelle Zheng, Vasileios P. Kemerlis, Junfeng Yang, and William Aiello. 2016. Shuffler: Fast and Deployable Continuous Code Re-Randomization. In USENIX OSDI. 367–382.**

57. **Windows Dev Center. 2018. PE Format.**
    - https://msdn.microsoft.com/library/windows/desktop/ms680547(v=vs.85).aspx

58. **Patrick Wollgast, Robert Gawlik, Behrad Garmany, Benjamin Kollenda, and Thorsten Holz. 2016. Automated Multi-Architectural Discovery of CFI-Resistant Code Gadgets. In Proc. of ESORICS. 602–620.**

59. **Guoqing Xu. 2012. Finding Reusable Data Structures. In Proc. of ACM OOPSLA.**

60. **Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-Inducing Input. IEEE Trans. Softw. Eng. 28, 2 (February 2002), 183–200.**

61. **Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, Laszlo Szekeres, Stephen McCamant, Dawn Song, and Wei Zou. 2013. Practical Control Flow Integrity and Randomization for Binary Executables. In Proc. of IEEE S&P. 559–573.**

62. **Mingwei Zhang and R. Sekar. 2013. Control Flow Integrity for COTS Binaries. In Proc. of USENIX SEC. 337–352.**

### Gadget Collection

Given an x86-64 ELF binary as input, our tool identifies its executable sections by parsing the respective ELF header(s) and proceeds as follows:

1. It pinpoints all byte sequences in the identified executable sections that correspond to RET, indirect JMP, and CALL instructions. The location of each such instruction is marked as `GAD_END` because it indicates the end of a gadget. The type of the instruction (RET, JMP, CALL) specifies the type of the gadget (i.e., ROP, JOP, or COP).

2. `GAD_BEGIN` is set to `GAD_END - 1`, and Capstone is used to linearly disassemble the region `[GAD_BEGIN, GAD_END]`. Every resulting code snippet is, by definition, a gadget (as it ends with an indirect branch instruction). The type of the instruction that starts at `GAD_BEGIN` is used to further classify the whole gadget.

3. The process is repeated recursively for `GAD_BEGIN = GAD_END - 2`, `GAD_BEGIN = GAD_END - 3`, ..., `GAD_BEGIN = GAD_END - k`, where `k` (bytes) is an input parameter, typically set to 10, in accordance with modern automated gadget finding tools like ROPgadget, Ropper, xrop, and rop-tool.

(We developed our own analysis framework, as none of the aforementioned gadget finding tools is intended for quantitative analyses [78].) This procedure discovers instruction subsequences of size 1, 2, ..., k bytes, which are prefixes of an indirect branch, thereby constituting gadgets. For example, the sequence `mov (%rdi), %rax; pop r14; pop r15; pop rbp; ret` will be accounted as 4 separate ROP gadgets:
- `pop rbp; ret`
- `pop r15; pop rbp; ret`
- `pop r14; pop r15; pop rbp; ret`
- `mov (%rdi), %rax ... ret`

Gadgets (a) – (c) will be classified as loading a register with a value from the stack, whereas (d) will be classified as a memory load. Gadgets that include invalid instruction sequences, such as privileged instructions (HLT, IN/OUT, RDMSR/WRMSR, etc.), instructions that access non-general-purpose registers (DR#, CR#), and vendor-specific ISA extensions (MMX, SSE, AVX, TSX), are filtered out.

### Gadget Reduction Without CFI

Table 6 summarizes our findings regarding conventional gadgets. Similar to the previous case, the reduction of gadgets is analogous to the achieved code reduction. Nibbler seems to be very effective on certain gadget classes, like Branch, where the achieved gadget reduction is (on average) slightly higher than the respective code reduction. Similarly, Stack Pivot and Stack Lift gadgets, in certain real-world applications such as Coreutils and MySQL, are reduced considerably (again on average) or eliminated completely (e.g., libdl in Coreutils). Our results indicate that although Nibbler does not entirely protect against code reuse, it significantly raises the bar for an attacker trying to automatically stitch together code snippets to mount a ROP/JOP/COP attack [16, 56, 57, 59], and it achieves this with practically zero run-time performance overhead.

### Static Linking

We argued that shared libraries have numerous advantages over static ones in real-world deployments. Nevertheless, static linking, especially with the addition of link-time optimization (LTO), has the potential to eliminate even more code. We compare Nibbler with static linking to highlight its debloating capabilities and the large overhead associated with static linking. We statically linked all applications and compared the total size of the statically-linked applications against the dynamically-linked ones, after applying Nibbler. Figure 5 shows the total size of each application set. On average, static linking reduces the size of the application by 50.32%, while Nibbler reduces it by 55.29%, indicating that our code elimination techniques approximate what can be achieved through recompilation and static linking. If we look at the total code in the system, the first (statically-linked) take 78.57 MB, while the latter (nibbled) only 14.34 MB.

**Effect of LTO.** LTO corresponds to inter-procedural optimizations performed during linking, which may eliminate even more code. To measure its effect, we built Nginx with LLVM/Clang (its LTO implementation is more mature than GCC's). We found that LTO does not significantly eliminate code when compared to static linking without LTO. Table 7 summarizes the debloating effects on library code. We notice that LTO does not significantly eliminate code, as code attributed to libraries is reduced only by 2.1% compared to conventional static linking. Interestingly, certain libraries may require additional functions/code when they are built statically, allowing Nibbler to achieve better results than static linking with LTO in such cases (see libc and libcrypt in Table 7). In general, both types of static linkage result in ≈10% less library code than Nibbler's thinned libraries, indicating that our code elimination techniques approximate the "optimal" reduction rates sufficiently.

### Real-World Exploits

We evaluated Nibbler against pre-compiled, real-world core-reuse exploits. Specifically, we replicated:
1. A ROP-based exploit against Nginx (CVE-2013-20283)
2. A ROP/ret2libc-based exploit against mcrypt (CVE-2012-44094)
3. A ret2libc-based exploit against Tinyproxy/glibc (CVE-2015-75475)

Next, we nibbled the libraries of the applications and re-tested the exploits. In all cases, Nibbler managed to stop the attack by removing gadgets required by the exploits or whole (libc) functions. Note that the attacker can still attempt to bypass these protections, but the bar is significantly raised.

- **CVE-2013-20283:** https://github.com/danghvu/nginx-1.4.0
- **CVE-2012-44094:** https://www.exploit-db.com/exploits/22928/
- **CVE-2015-75475:** https://researchcenter.paloaltonetworks.com/2016/05/how-cve-2015-7547-glibc-getaddrinfo-can-bypass-aslr/

### Figure 5: Comparison of Total App. Size

| Application | Dynamic + Nibbler (KB) | Static (KB) | Code Reduction (%) |
|-------------|------------------------|-------------|--------------------|
| Coreutils   | 4504.62                | 9009.24     | 50.67              |
| SPEC        | 5492.85                | 11125.70    | 51.24              |
| MySQL       | 5449.57                | 6463.14     | 15.64              |
| Nginx       | 1740.07                | 3380.14     | 48.41              |
| All         | 1679.26                | 3380.14     | 50.32              |

**Note:** The hatched bars correspond to the average code reduction and standard deviation of total app. size across a set—bottom x-axis.