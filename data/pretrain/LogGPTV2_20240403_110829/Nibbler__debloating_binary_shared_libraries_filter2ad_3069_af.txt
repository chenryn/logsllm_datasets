[21] Ulrich Drepper. [n.d.]. ELF Symbol Versioning.
https://www.akkadia.org/
drepper/symbol-versioning.
[22] Isaac Evans, Fan Long, Ulziibayar Otgonbaatar, Howard Shrobe, Martin Rinard,
Hamed Okhravi, and Stelios Sidiroglou-Douskos. 2015. Control Jujutsu: On
the Weaknesses of Fine-Grained Control Flow Integrity. In Proc. of ACM CCS.
901–913.
[23] Michael Franz and Thomas Kistler. 1997. Slim Binaries. Commun. ACM 40, 12
(Dec. 1997), 87–94.
mona.
[24] Cristiano Giuffrida, Anton Kuijsten, and Andrew S. Tanenbaum. 2012. Enhanced
Operating System Security Through Efficient and Fine-grained Address Space
Randomization. In Proc. of USENIX SEC. 475–490.
[25] Enes Göktas, Elias Athanasopoulos, Herbert Bos, and Georgios Portokalidis.
2014. Out of Control: Overcoming Control-Flow Integrity. In Proc. of IEEE S&P.
575–589.
[26] J. Hamilton and S. Danicic. 2009. An Evaluation of Current Java Bytecode
Decompilers. In Proc. of IEEE SCAM. 129–136.
[27] Kihong Heo, Woosuk Lee, Pardis Pashakhanloo, and Mayur Naik. 2018. Effective
Program Debloating via Reinforcement Learning. In Proc. of ACM CCS. 380–394.
[28] Hex-Rays. 2016. The IDA Pro Disassembler and Debugger. https://www.hex-
rays.com/products/ida/
[29] Patrick Horgan. [n.d.]. Linux x86 Program Start Up. http://dbp-consulting.com/
tutorials/debugging/linuxProgramStartup.html.
[30] Intel. 2013. System V Application Binary Interface. https://software.intel.com/
sites/default/files/article/402129/mpx-linux64-abi.pdf.
[31] Y. Jiang, D. Wu, and P. Liu. 2016. JRed: Program Customization and Bloatware
Mitigation Based on Static Analysis. In Proc. of IEEE COMPSAC. 12–21.
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
I. Agadakos, D. Jin, D. Williams-King, V. P. Kemerlis, and G. Portokalidis
[32] Y. Jiang, C. Zhang, D. Wu, and P. Liu. 2016. Feature-Based Software Customization:
Preliminary Analysis, Formalization, and Methods. In Proc. of IEEE HASE. 122–
131.
[33] JoeDog. 2017. Siege – an http load tester and benchmarking utility.
https:
//github.com/JoeDog/siege.
[34] Johannes Kinder and Helmut Veith. 2010. Precise Static Analysis of Untrusted
Driver Binaries. In Proc. of FMCAD. 43–50.
[35] Hyungjoon Koo, Seyedhamed Ghavamnia, and Michalis Polychronakis. 2019.
Configuration-Driven Software Debloating. In Proceedings of the 12th European
Workshop on Systems Security. ACM, 9.
[36] Anil Kurmus, Reinhard Tartler, Daniela Dorneanu, Bernhard Heinloth, Valentin
Rothberg, Andreas Ruprecht, Wolfgang Schröder-Preikschat, Daniel Lohmann,
and Rüdiger Kapitza. 2013. Attack Surface Metrics and Automated Compile-Time
OS Kernel Tailoring. In Proc. of NDSS.
[37] Jason Landsborough, Stephen Harding, and Sunny Fugate. 2015. Removing the
Kitchen Sink from Software. In Proc. of ACM GECCO. 833–838.
[38] John R. Levine. 1999. Linkers and Loaders (1st ed.). Morgan Kaufmann Publishers
Inc., San Francisco, CA, USA.
[39] Linux Programmer’s Manual. 2018. rtld-audit – auditing API for the dynamic
linker. http://man7.org/linux/man-pages/man7/rtld-audit.7.html
[40] LLVM Project. 2018. LLVM Link Time Optimization: Design and Implementation.
[41] Gregory Malecha, Ashish Gehani, and Natarajan Shankar. 2015. Automated
Software Winnowing. In Proc. of ACM SAC. 1504–1511.
[42] Microsoft. 2015. Control Flow Guard. Windows Dev Center. https://msdn.
microsoft.com/en-us/library/windows/desktop/mt637065(v=vs.85).aspx
[43] Microsoft. 2017. Symbols and Symbol Files. Microsoft Developer Network.
https://msdn.microsoft.com/en-us/library/ff558825.aspx
[44] Ghassan Misherghi and Zhendong Su. 2006. HDD: Hierarchical Delta Debugging.
In Proc. of ICSE. 142–151.
[45] Shachee Mishra and Michalis Polychronakis. 2018. Shredder: Breaking Exploits
through API Specialization. In Proc. of ACSAC. ACM, 1–16.
[46] Collin Mulliner and Matthias Neugschwandtner. 2015.
loads with Runtime Code Stripping and Image Freezing.
https://www.blackhat.com/us-15/briefings.html#breaking-payloads-with-
runtime-code-stripping-and-image-freezing
[47] Gail C. Murphy, David Notkin, William G. Griswold, and Erica S. Lan. 1998. An
Empirical Study of Static Call Graph Extractors. ACM Trans. Softw. Eng. Methodol.
7, 2 (April 1998), 158–191.
[48] National Security Agency. 2019. Ghidra. nsa.gov. https://www.nsa.gov/resources/
Breaking Pay-
BHUSA.
[51] Ben Niu and Gang Tan. 2015. Per-Input Control-Flow Integrity. In Proc. of ACM
[52] PaX Team. 2003. Address Space Layout Randomization (ASLR). https://pax.
grsecurity.net/docs/aslr.txt
[53] Anh Quach, Aravind Prakash, and Lok Yan. 2018. Debloating Software through
Piece-Wise Compilation and Loading. In 27th USENIX Security Symposium.
USENIX Association, Baltimore, MD, 869–886.
[54] Nguyen Anh Quynh. 2014. Capstone: Next-Gen Disassembly Framework. In
BHUSA.
[55] John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, and Xuejun
Yang. 2012. Test-case Reduction for C Compiler Bugs. In Proc. of PLDI. 335–346.
[56] Jonathan Salwan. 2011. ROPgadget - Gadgets finder and auto-roper. http://shell-
storm.org/project/ROPgadget/.
https://scoding.de/ropper/.
[57] Sascha Schirra. 2014. Ropper - rop gadget finder and binary information tool.
[58] Felix Schuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi, Ahmad-Reza
Sadeghi, and Thorsten Holz. 2015. Counterfeit Object-oriented Programming:
On the Difficulty of Preventing Code Reuse Attacks in C++ Applications. In Proc.
of IEEE S&P. 745–762.
[59] Edward J. Schwartz, Thanassis Avgerinos, and David Brumley. 2011. Q: Exploit
Hardening Made Easy. In Proc. of USENIX SEC. 25–41.
[60] Hovav Shacham. 2007. The Geometry of Innocent Flesh on the Bone: Return-
into-libc Without Function Calls (on the x86). In Proc. of ACM CCS. 552–561.
[61] Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar. 2018.
TRIMMER: Application Specialization for Code Debloating. In Proc. of ACM/IEEE
ASE. ACM, 329–339.
[62] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Audrey Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive Techniques
in Binary Analysis. In IEEE Symposium on Security and Privacy. 138–157.
[63] Kevin Z. Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko, Christopher
Liebchen, and Ahmad-Reza Sadeghi. 2013. Just-In-Time Code Reuse: On the
Effectiveness of Fine-Grained Address Space Layout Randomization. In Proc. of
IEEE S&P. 574–588.
[49] Khanh Nguyen and Guoqing Xu. 2013. Cachetor: Detecting Cacheable Data to
1017–1034.
Remove Bloat. In Proc of ACM ESEC/FSE. 268–278.
[50] Ben Niu and Gang Tan. 2014. Modular Control-Flow Integrity. In Proc. of ACM
everyone/ghidra/
PLDI. 577–587.
CCS. 914–926.
rop-tool.
[64] Raoul Strackx, Yves Younan, Pieter Philippaerts, Frank Piessens, Sven Lachmund,
and Thomas Walter. 2009. Breaking the Memory Secrecy Assumption. In Proc. of
EuroSec. 1–8.
[65] Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su. 2018.
Perses: Syntax-guided Program Reduction. In Proc. of ICSE. 361–371.
[66] t0x0sh. 2014. A tool to help you write binary exploits. https://github.com/t00sh/
[67] The Chromium Projects. 2018. Testing and infrastructure.
https://www.
chromium.org/developers/testing
[68] Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, Úlfar
Erlingsson, Luis Lozano, and Geoff Pike. 2014. Enforcing Forward-edge Control-
Flow Integrity in GCC & LLVM. In Proc. of USENIX SEC. 941–955.
[69] TIS Committee. 1995. Tool Interface Standard (TIS)– Executable and Linking
Format (ELF)– Specification– Version 1.2. http://refspecs.linuxbase.org/elf/elf.
pdf.
[70] Trail of Bits. 2019. McSema. GitHub. https://github.com/trailofbits/mcsema
[71] Victor van der Veen, Dennis Andriesse, Enes Göktaş, Ben Gras, Lionel Sambuc,
Asia Slowinska, Herbert Bos, and Cristiano Giuffrida. 2015. Practical Context-
Sensitive CFI. In Proc. of ACM CCS. 927–940.
[72] Gregor Wagner, Andreas Gal, and Michael Franz. 2011. “Slimming” a Java Virtual
Machine by Way of Cold Code Removal and Optimistic Partial Program Loading.
Sci. Comput. Program. 76, 11 (Nov. 2011), 1037–1053.
[73] Shuai Wang, Pei Wang, and Dinghao Wu. 2015. Reassembleable Disassembling.
In 24th USENIX Security Symposium (USENIX Security). 627–642.
[74] Zhe Wang, Chenggang Wu, Jianjun Li, Yuanming Lai, Xiangyu Zhang, Wei-
Chung Hsu, and Yueqiang Cheng. 2017. ReRanz: A Light-Weight Virtual Machine
to Mitigate Memory Disclosure Attacks. In Proc. of ACM VEE. 143–156.
[75] Richard Wartell, Yan Zhou, Kevin W. Hamlen, Murat Kantarcioglu, and Bhavani
Thuraisingham. 2011. Differentiating Code from Data in x86 Binaries. In Proc. of
ECML-PKDD. 522–536.
[76] David Williams-King, Graham Gobieski, Kent Williams-King, James P. Blake,
Xinhao Yuan, Patrick Colp, Michelle Zheng, Vasileios P. Kemerlis, Junfeng Yang,
and William Aiello. 2016. Shuffler: Fast and Deployable Continuous Code Re-
Randomization. In USENIX OSDI. 367–382.
[77] Windows Dev Center. 2018. PE Format. https://msdn.microsoft.com/library/
windows/desktop/ms680547(v=vs.85).aspx.
[78] Patrick Wollgast, Robert Gawlik, Behrad Garmany, Benjamin Kollenda, and
Thorsten Holz. 2016. Automated Multi-Architectural Discovery of CFI-Resistant
Code Gadgets. In Proc. of ESORICS. 602–620.
[79] Guoqing Xu. 2012. Finding Reusable Data Structures. In Proc. of ACM OOPSLA.
[80] Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-
Inducing Input. IEEE Trans. Softw. Eng. 28, 2 (February 2002), 183–200.
[81] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, Laszlo Szekeres, Stephen Mc-
Camant, Dawn Song, and Wei Zou. 2013. Practical Control Flow Integrity and
Randomization for Binary Executables. In Proc. of IEEE S&P. 559–573.
[82] Mingwei Zhang and R. Sekar. 2013. Control Flow Integrity for COTS Binaries. In
Proc. of USENIX SEC. 337–352.
A GADGET COLLECTION
Given an x86-64 ELF binary as input, our tool identifies its ex-
ecutable sections, by parsing the respective ELF header(s), and
proceeds as follows. First, it pinpoints all the byte sequences (in
the previously-identified executable sections) that correspond to
RET, indirect JMP and CALL instructions; the location of every such
instruction is marked, as GAD_END, because it indicates the end of a
gadget, while the instruction opcode (RET, JMP, CALL) specifies the
type of the gadget (i.e., ROP, JOP, or COP).
Second, GAD_BEGIN is set to GAD_END - 1, and Capstone is used
to linearly disassemble the region [GAD_BEGIN, GAD_END]; every
resulting code snippet is by definition a gadget (as it ends with an
indirect branch instruction), and the type of the instruction that
starts at GAD_BEGIN is used to further classify the whole gadget
(more about this below). Next, GAD_BEGIN is set to GAD_END - 2,
and step 2 is repeated; the process is executed recursively for GAD_-
BEGIN = GAD_END - 3, ..., GAD_BEGIN = GAD_END - k, where
k (bytes) is an input parameter, typically set to 10, in accordance
to modern automated gadget finding tools, like ROPgadget [56],
Ropper [57], xrop [10], and rop-tool [66].
Nibbler: Debloating Binary Shared Libraries
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
(We had to develop our own analysis framework, as none of
the aforementioned gadget finding tools is intended for quanti-
tative analyses [78].) The above procedure discovers instruction
(sub)sequences, of size 1, 2, ..., k bytes, which are prefixes of an
indirect branch, thereby constituting gadgets. For example, |mov
(%rdi), %rax; pop r14; pop r15; pop rbp; ret| will be ac-
counted as 4 separate ROP gadgets: (a) |pop rbp; ret|, (b) |pop
r15; pop rbp; ret|, (c) |pop r14; pop r15; pop rbp; ret|,
and (d) |mov (%rdi), %rax ... ret|. Also, gadgets (a) – (c) will be
classified as loading a register with a value from the stack, whereas
(d) will be classified as a memory load. Lastly, gadgets that include
invalid instructions sequences, like privileged instructions (hlt,
in/out, rdmsr/wrmsr, etc.), instructions that access non-general-
purpose, registers (dr#, cr#), and vendor-specific ISA extensions
(MMX, SSE, AVX, TSX), are all filtered out.
B GADGET REDUCTION WITHOUT CFI
Table 6 summarizes our findings regarding conventional gadgets.
Similar to the previous case, the reduction of gadgets is analogous
to the achieved code reduction. Again, Nibbler seems to be very
effective on certain gadget classes, like Branch, where the achieved
gadget reduction is (on average) a bit higher than the respective
code reduction. Similarly, Stack Pivot and Stack Lift gadgets, in
certain real-world applications, such as Coreutils and MySQL, are
reduced considerably (again on average) or eliminated completely
(e.g., libdl in Coreutils). Our results indicate that although Nibbler
does not entirely protect against code reuse, it raises the bar signifi-
cantly for an attacker that tries to automatically stitch together code
snippets to mount a ROP/JOP/COP attack [16, 56, 57, 59]; and it
achieves this with practically zero run-time performance overhead.
C STATIC LINKING
We argued that shared libraries have numerous advantages over
static ones in real-world deployments. Nevertheless, static linking,
specially with the addition of link-time optimization [40] (LTO), has
the potential to eliminate even more code. We compare Nibbler with
static linking to highlight its debloating capabilities, as well as the
large overhead associated with static linking. We statically linked
all applications, and compared the total size of the statically-linked
applications against the dynamically-linked ones, with all their
required libraries, after we have applied Nibbler. Figure 5 shows the
total size of each application set. On average, static linking reduces
the size of the application by 50.32%, while Nibbler by 55.29%, indi-
cating that our code elimination techniques approximate what can
be achieved through recompilation and static linking. If we, how-
ever, look at the total code in the system, the first (statically-linked)
take 78.57 MB, while the latter (nibbled) only 14.34 MB.
Effect of LTO. LTO corresponds to inter-procedural optimizations,
performed during linking, which may eliminate even more code.
To measure its effect, we built Nginx with LLVM/Clang (its LTO im-
plementation is more mature than GCC’s). We found that LTO does
not significantly eliminate code, when compared to static linking
without LTO. Table 7 summarizes the debloating effects on library
code. We notice that LTO does not significantly eliminate code,
as code attributed to libraries is reduced only by 2.1%, compared
to conventional static linking. Interestingly, certain libraries may
Figure 5: Comparison of total app. size (in KB; binaries +
required libraries), when using Nibbler with dynamically-
linked binaries (shared libraries) vs. statically-linked bina-
ries (library code is duplicated)—top x-axis. The hatched
bars correspond to average code reduction and standard de-
viation of total app. size across a set—bottom x-axis.
require additional functions/code when they are built statically,
allowing Nibbler to achieve better results than static linking with
LTO in such cases (see libc and libcrypt in Table 7). In general,
both types of static linkage result in ≈10% less library code than
Nibbler’s thinned libraries, indicating that our code elimination
techniques approximate the “optimal” reduction rate(s) sufficiently.
D REAL-WORLD EXPLOITS
We evaluated Nibbler against pre-compiled, real-world core-reuse
exploits. Specifically, we replicated: (1) a ROP-based exploit against
Nginx (CVE-2013-20283), (2) a ROP/ret2libc-based exploit against
mcrypt (CVE-2012-44094), and (3) a ret2libc-based exploit against
Tinyproxy/glibc (CVE-2015-75475). Next, we nibbled the libraries
of the applications and re-tested the exploits. In all cases, Nibbler
managed to stop the attack, by removing gadgets, required by the
exploit(s), or whole (libc) functions. Note that the attacker can
3https://github.com/danghvu/nginx-1.4.0
4https://www.exploit-db.com/exploits/22928/
5https://researchcenter.paloaltonetworks.com/2016/05/how-cve-2015-7547-glibc-
getaddrinfo-can-bypass-aslr/
Size (KB)0100002000030000400005000060000700008000090000100000CoreutilsSPEC MySQLNginxAll4504.62 KB5492.85 KB5449.57 KB1740.07 KB14683.43 KB62163.21 KB11597.15 KB5016.08 KB1679.26 KB80455.69 KBCode Reduction (%)0102030405060708090100CoreutilsSPEC MySQLNginxAll50.67%51.24%15.64%48.41%50.32%55.95%52.63%22.35%50.21%55.29%Dynamic+NibblerStaticACSAC ’19, December 9–13, 2019, San Juan, PR, USA
I. Agadakos, D. Jin, D. Williams-King, V. P. Kemerlis, and G. Portokalidis
Table 6: Gadget reduction results. The percentages correspond to removed gadgets (thinned vs. vanilla). Entries marked with
‘N/A’ indicate absence of certain gadget classes in vanilla.
Suite
Total
SPEC
Stack
Pivot
Lift
Load Reg.
Reg.
Stack
Memory
Load Store
Gadget Type
Arithmetic
Reg. Mem.
Logic
Branch
Reg. Mem.
jmp
call
Syscall NOP
libpthread
libm
libc
libgcc
libstdc++
(92.79%)
(39.76%)
(42.01%)
(72.35%)
(48.88%)
96.1% 100.0%
28.6%
48.4%
68.9%
51.8%
75.8%
55.4%
67.4%
63.9%
95.9% 97.8% 99.1% 100.0% 90.2% 93.1%
75.6% 39.4% 54.3%
44.3% 53.5% 30.5%
38.3% 39.5% 53.4%
30.2% 63.5% 68.8%
84.9% 62.9% 53.7%
32.0% 75.5% 83.9%
51.1% 69.3% 72.5%
46.2% 60.4% 67.5%
96.1% 93.3%
47.3% 72.2%
47.1% 59.7%
74.8% 91.0%
68.5% 68.2%
99.2% 96.2% 80.0%
44.9% 45.9% 55.9%
56.8% 41.0% 57.8%
74.0% 86.2% 14.3%
72.9% 56.5% 52.9%
96.5% 95.8%
71.4% 40.8%
76.6% 48.9%
0.0% 77.7%
50.0% 68.2%
Coreutils
libpthread
libdl
libselinux
libacl