chunk. Instead, we model the new shellcode as a sequence
of instructions. It is not necessary to keep these instructions
contiguous; we could insert jmp instructions to “hop” from
one shellcode instruction in one symbolic buffer to another
instruction in another buffer. Thus, we attempt to ﬁt pieces
of the shellcode (plus any necessary jump instructions) into
previously-identiﬁed symbolic buffers.
Algorithm 1 and Algorithm 2 shows the algorithms for
Layout Remediation. The system invokes function Locate,
and function Locate calls out to function Hop when needed.
Both functions take ﬁve arguments as input: SH , ST , I, C, i, a,
where SH is the shellcode, ST is the exploitable state, I is
the symbolic buffers, C is the set of constraints for ST , i is
an index into the not-yet-written bytes of the replacement
shellcode, and a is the memory address being currently
considered by the algorithm.
We use the motivating example to demonstrate how the
algorithm works. As mentioned in Section II-B, there will
be three symbolic buffers in this example. Suppose the
ShellSwap system tries to ﬁt the shellcode from Listing 3
to the stack of the exploitable state of the motivating example.
It calls Locate with i = 0 and a = &string, initially trying
:
Input
SH : The new shellcode
ST : The current exploitable program state. ST .mem[j] means the
memory at j in the state ST
I: The symbolic buffers generated by preprocessing
C: The constraints set
i: The index of the instruction of the shellcode
a: The start address that we plan to put SH [i]
Output :
E: A new exploit or Not Found
1 if i > len(SH ) then
// We have successfully put the entire piece
of shellcode to the exploitable state.
2
E ← Solve(C);
return E;
3
4 end
5 else if i < 0 then
// We cannot successfully put the entire piece
of shellcode to the exploitable state if we
put SH[i] at a.
return Not Found;
if I has enough space after a then
// Construct the new constraint asserting
the memory at a concretize to the i-th
byte of the replacement shellcode.
← C + c;
c ← (ST.mem[a : a + len(SH[i])] == SH[i]);
C (cid:2)
if Solve(C’) has solution then
← a new state with
ST (cid:2)
ST.mem[a : a + len(SH[i])] = SH[i];
← Next(I, a + len(SH[i]));
a(cid:2)
return Locate(SH, ST (cid:2), I, C (cid:2), i + 1, a(cid:2));
end
else
// We cannot put SH[i] at a. Instead, we
need to find another location for
SH[i] and hop to the location.
if Hop(SH, ST, I, C, i, a) == Not Found then
return Not Found;
end
else
end
end
ST (cid:2), a(cid:2), C (cid:2)
← Hop(SH, ST, I, C, i, a);
return Locate(SH, ST (cid:2), I, C (cid:2), i + 1, a(cid:2));
end
else
end
return Not Found
6
7 end
8 else
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30 end
Algorithm 1: The algorithm of the Locate function.
to put the ﬁrst instruction of the replacement shellcode at the
beginning of the buffer string.
The layout remediation process is shown in Figure 5. As
the ﬁrst 6 instructions of the replacement shellcode satisfy the
constraints in memory, the process will continue adding new
instructions until the 7th instruction (Figure 5b). At this point,
the system fails to add the 7th instruction (because len is in
the way), so it calls function Hop, trying to jump over len
and place the 7th instruction to into the next symbolic buffer
(Figure 5c). In function Hop, it successfully ﬁnds a location
for the 7th instruction. However, the jmp instruction cannot
ﬁt after the ﬁrst 6 instructions (Figure 5d, so we roll back and
call Hop to re-locate the 6th instruction (Figure 5e). Since the
jmp instruction still covers len, this rollback occurs again,
829
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
Exploitable State 
Replacement 
Shellcode 
Path Constraints 
New Exploitable State 
& 
New Path Constraints 
Preprocessing 
Layout Remediation 
Path Kneading 
Two-Stage 
Fallback 
Modified Exploit 
Fig. 4: The phases of the Shellcode Transplant step.
:
Input
SH: The new shellcode
ST : The current exploitable program state. ST.mem[j] means the
memory at j in the state ST
I: The symbolic buffers generated by preprocessing
C: The constraints set
i: The index of the instruction of the shellcode. SH[i] means the bytes
for the i-th instruction of the shellcode SH.
a: The start address that we plan to put SH[i]
Output :
ST (cid:2): The updated exploitable program state, with the jump instruction
and SH[i] in the memory.
C (cid:2): The updated constraints set
a(cid:2): The start address for the next instruction
1 if i < 0 then
// We cannot successfully hop SH[i].
return Not Found;
2
3 end
4 else
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25 end
← None;
// find an address to put SH[i]
a(cid:2)
at ← Next(I, a + lenjmp));
while at is not None do
c ← (ST.mem[at : at + len(SH[i])] == SH[i]);
C (cid:2)
if Solve(C’) has solution then
← C + c;
// SH[i] can be put at ST.mem[at]
cjmp ← jump instruction constraint;
C (cid:2)(cid:2)
if Solve(C (cid:2)(cid:2)) has solution then
← C (cid:2) + cjmp;
// The jump instruction can be put
at ST.mem[a]
← a new state with SH[i] and jump instruction;
ST (cid:2)
a(cid:2)
return ST (cid:2), a(cid:2), C (cid:2);
← Next(I, at + len(SH[i]));
end
at ← Next(I, at));
end
else
end
end
// We cannot hop to an address with SH[i]
after address a. Then we roll back and hop
to the previous instruction.
ST (cid:2), a(cid:2), C (cid:2)
return Hop(SH, ST (cid:2), I, C (cid:2), i − 1, a(cid:2));
← Rollback(SH, ST, C, I, a);
Algorithm 2: The algorithm for the Hop function.
830
until the 5th instruction ends up relocated, and a jmp inserted
after the 4th instruction to the 5th instruction. In the end, this
is repeated until the full shellcode is placed in memory, split
into three parts as shown in Figure 5f.
C. Path Kneading
If the system cannot ﬁnd a new exploit for the new shellcode
using the exploitable state of the original exploit, we need to
diagnose the cause of conﬂict and tweak the path to generate
new exploitable states and new path constraints. To diagnose
the cause of conﬂict, we ﬁrst identify the conﬂicting path
constraints and then check which instructions generated them.
Since shellcode is placed to the exploitable state instruction
by instruction, we can retrieve the smallest set of shellcode
constraints that cause a path conﬂict as soon as Locate
terminates unsuccessfully. Let c be the constraint for locating
the current instruction, and let C be the set of path constraints
set of the current state. We already know that c and C are
conﬂicted (otherwise, a location for the last instruction would
have been found), which implies that c ∧ C = False. To
understand the cause of the conﬂict, we ﬁnd the smallest set
of path constraints S such that: S ⊆ C, such that:
c ∧ S = False and c ∧ (S − C) = True.
After ﬁnding the conﬂict subset, ShellSwap identiﬁes the
source of each constraint in this subset by checking the
execution history for when it was introduced. If the conﬂicting
constraint was introduced by condition branch, ShellSwap
will tweak the path to avoid the path constraints in the
conﬂict subset. The intuition for this is as follows: if the
shellcode constraint contradicts a path constraint, then the
shellcode constraint does not contradict the negation of that
path constraint. For path constraints created by conditional
branches, our idea is to negate the conﬂict path constraints by
selecting the other branch in the program. In this way, if the
program executes along the path with the opposite branch, the
new path constraints will contain the negation of the previously-
conﬂicting path constraint, and the new path constraints will
not conﬂict with the shellcode constraint c.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
\x00\x00\x00\x00 
\x00\x00\x00\x00 
\x00\x00\x00\x00 
\x00\x00\x00\x00 
\x00\x00\x00\x00 
Saved(cid:1)%eip
Saved(cid:1)%ebp
Saved(cid:1)%esi
int ret
int len
Saved(cid:1)%eip
Saved(cid:1)%ebp
Saved(cid:1)%esi
int ret
shellcode1[7]
int len
Saved(cid:1)%eip
Saved(cid:1)%ebp
Saved(cid:1)%esi
shellcode1[7]
int ret
jmp
int len
Saved(cid:1)%eip
Saved(cid:1)%ebp
Saved(cid:1)%esi
shellcode1[6]
int ret
int len
jmp
char string[20]
(20 Bytes) 
shellcode1[0:7]
char string[20]
(20 Bytes) 
shellcode1[0:7]
char string[20]
(20 Bytes) 
char string[20]
shellcode1[0:6]
(20 Bytes) 
High
h
s
s
e
r
d
d
a
Low
Saved(cid:1)%eip
Saved(cid:1)%ebp
Saved(cid:1)%esi
shellcode1[4]
int ret
int len
jmp
char string[20]
(20 Bytes) 
shellcode1[0:4]
… 
… 
… 
… 
… 
(a) The initial stack.
(b) Locate, i = 7,
a = &string + 24
(c) Hop, i = 7,
(d) Hop, i = 6,
(e) Hop, i = 4,
a = &string + 24
a = &string + 21
a = &string + 14
shellcode1[7]
shellcode1[6]
shellcode1[5]
jmp
shellcode1[4]
Saved(cid:1)%eip
Saved(cid:1)%ebp
Saved(cid:1)%esi
int ret
int len
jmp
shellcode1[0:4]
char string[20]
(20 Bytes) 