# An Empirical Study of Textual Key-Fingerprint Representations

## Authors
- Sergej Dechand, University of Bonn
- Dominik Schürmann, Technische Universität Braunschweig
- Karoline Busse, University of Bonn
- Yasemin Acar and Sascha Fahl, Saarland University
- Matthew Smith, University of Bonn

**Link to the Paper:**
[https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/dechand](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/dechand)

This paper is included in the Proceedings of the 25th USENIX Security Symposium, August 10–12, 2016, Austin, TX. ISBN 978-1-931971-32-4. Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX.

---

## Abstract
Many security protocols still rely on manual fingerprint comparisons for authentication. The most well-known and widely used key-fingerprint representation is the hexadecimal string, as seen in various security tools. With the introduction of end-to-end security in WhatsApp and other messengers, there is a renewed interest in how best to represent key-fingerprints for users.

We conducted a study with 1,047 participants to evaluate six different textual key-fingerprint representations in terms of their performance and usability. We focused on textual fingerprints as they are the most robust and deployable representation.

Our findings indicate that the currently used hexadecimal representation is more susceptible to partial preimage attacks compared to other alternatives. Based on our results, we recommend adopting two alternative representations. The highest attack detection rate and best usability perception were achieved with a sentence-based encoding. If language-based representations are not acceptable, a simple numeric approach still outperforms the hexadecimal representation.

---

## 1. Introduction
Public key cryptography is a common method for authentication in secure end-to-end communication and has been a part of the Internet for over two decades [7, 11]. While security breaches have shown that systems based on centralized trusted third parties, such as Certificate Authorities and Identity-Based Private Key Generators, are vulnerable to targeted attacks [42], decentralized approaches like Web of Trust and Namecoin struggle with adoption due to usability issues [7, 13, 30]. Certificate transparency systems, such as CONIKS and others [24, 39, 27], aim to address some of these issues by providing an auditable directory of all user keys. However, manual key verification, i.e., linking public keys to entities such as hostnames or people, remains a challenge, especially in decentralized systems without predefined authorities, such as SSH, OpenPGP, and secure messaging [12, 41].

Many traditional authentication systems still rely on manual key-fingerprint comparisons [17]. These fingerprints are generated by encoding the (hashed) public key material into a human-readable format, typically in hexadecimal representation. Various alternatives, such as QR Codes, visual fingerprints, Near Field Communication (NFC), and Short Authentication Strings (SAS), have been proposed. While these systems offer specific benefits, e.g., QR codes and NFC do not require users to compare strings, they also come with specific disadvantages, such as requiring hardware and software support on all devices. Despite these advances, text-based representation remains the dominant form in most applications.

The recent surge in secure messaging tools has reignited the debate on how to best represent and evaluate textual fingerprints, with many active discussions among security experts [28, 33]. In April 2016, WhatsApp, serving over one billion users, enabled end-to-end encryption by default using the Signal protocol. Key verification is optional and can be done via QR codes or comparing numeric representations, specifically 60-digit numbers [43]. However, it is unclear whether their solution is more usable than traditional representations.

In this paper, we present an evaluation of different textual key-fingerprint representation schemes to aid in the secure messenger discussion. The requirements for developers include:

- **Offline Support and Asynchronous Operation:** Fingerprints should work offline and asynchronously, as they are often printed on business cards or exchanged by third parties.
- **Audio Transferability:** Fingerprints should be transferable via audio channels, allowing comparison over the phone.
- **Technical Inclusivity:** No special hardware or software should be required to verify the fingerprints.
- **User Inclusivity:** The representation should exclude as few people with sensory impairments (visual, color, audio, etc.) as possible.

These requirements exclude many proposed representation schemes, explaining why they have not seen adoption outside academia. Therefore, we focus exclusively on textual fingerprint representations in our study. Textual key-fingerprints do not require hardware support and work in both synchronous and asynchronous scenarios, such as being compared via voice or printed on business cards. Depending on the scheme, they can even be recalled from memory and exchanged over a voice channel.

This paper presents our study testing the usability of various textual key-fingerprint representation schemes. Our study consists of two parts: (1) an experiment measuring the speed and accuracy of participants for different schemes, and (2) a survey about their perception and sentiment, including a direct comparison between the representations.

Our findings suggest that the most adopted alphanumeric approaches, such as Hexadecimal and Base32, perform worse than other alternatives. Under a realistic threat model, more than 10% of users failed to detect attacks targeting Hexadecimal representations, whereas our best system had failure rates of less than 3%. While the most accurate system is not the fastest, it received the highest usability rating and is preferred by users.

In the following sections, we discuss related work, analyze current implementations of in-persona key-fingerprint representation techniques, and describe our evaluated representation schemes. We then detail our experiment evaluating text-based key-fingerprint verification techniques in terms of attack-detection accuracy and speed. Our experiment was conducted online with 1,047 participants recruited via the Amazon Mechanical Turk (MTurk) platform. We consider the scenario where a user compares two key-fingerprint strings encoded by different representation schemes. In addition to implicit measurements of accuracy and speed, we also evaluate self-reported user perception to gather feedback on which systems are preferred by end users. Finally, we present our results, discuss their implications, and conclude our work.

---

## 2. Related Work
Various key-fingerprint representations have been proposed in academia and industry. Many cryptographic protocol implementations still rely on manual fingerprint comparisons, with the hexadecimal representation being the most common. However, previous work suggests that fingerprint verifications are seldom performed in practice [17, 37].

### 2.1 Key-Fingerprint Representations
Previous studies have shown that users struggle with comparing long and seemingly "meaningless" fingerprints and may perform poorly in this task [19]. Most previous work has focused on visual fingerprints [35, 32, 19, 10], but to our knowledge, none have focused on the differences between various textual fingerprint representations.

Hsiao et al. conducted a study comparing some textual and visual representation methods for hash verification [19]. They compared Base32 and simple word list representations with various algorithms for visual fingerprints and hash representation using Asian character sets (a subset of Chinese, Japanese Hiragana, and Korean Hangul). A within-subjects online study with 436 participants revealed that visual fingerprints score very well in both accuracy and speed, along with the Base32 text representation. Hsiao et al. concluded that, depending on available computational power and display size, either Base32 or one of the visual fingerprinting schemes should be used. They explicitly did not evaluate hexadecimal representation or digits "because that scheme is similar to Base32 and known to be error-prone" [19]. However, our work shows that numeric representations actually perform significantly better than Base32 and are less error-prone. Additionally, our results suggest that language-based schemes, such as generated sentences, achieve excellent results comparable to visual schemes. Textual approaches are also more flexible (can be read out loud) and do not exclude people with sensory impairments.

Another study by Olembo et al. focused mainly on visual fingerprints [32]. They developed a new family of visual fingerprints and compared them against a Base32 representation. The Base32 strings were twelve characters long and displayed without chunking. Participants performed better with visual fingerprints than with Base32 in both accuracy and speed. Olembo et al. concluded that the Base32 representation is far from optimal for manual key-fingerprint verification. We test this claim by comparing Base32 representation with other textual key-fingerprint representations and ultimately prove it wrong.

Regarding chunking, Miller et al. published "The Magical Number Seven, Plus or Minus Two," which shows that most people can recall 7±2 items from their short-term memory [29]. More recent studies have shown that human working memory easily remembers up to 6 digits, 5.6 letters, and 5.2 words [1, 6, 8]. Adjusting chunk sizes to these numbers can help users when comparing hashes.

While the above studies offer interesting insights into different (mainly visual) fingerprint representations, to the best of our knowledge, there is no work focusing on which textual representation performs the best. This knowledge is crucial for the current debate in the secure messaging community. The representations currently being proposed and implemented are far from optimal, and the results of our study can help improve the accuracy and usability of fingerprint representations. Unlike the above studies, we conduct our study with a more realistic attacker strength, as presented in subsection 4.1.

### 2.2 Passwords and Passphrases
A passphrase is essentially a password consisting of a series of words rather than characters. In academic literature, passphrases are often considered a potentially more memorable and secure alternative to passwords and are often recommended by system administrators [23, 40]. In contrast to most passphrase-based systems, key-fingerprints cannot be chosen by the end-user and are more related to the system-assigned passphrases field. Bonneau et al. have shown that users can memorize 56-bit passwords [4]. miniLock [1] and its commercial successor Peerio [2] use system-assigned passphrases to generate cryptographic key pairs, easing key backup and synchronization among multiple devices.

Contrary to widespread expectations, Shay et al. found no significant recall differences between system-assigned passphrases and system-assigned passwords [40]. However, they reported reduced usability due to longer submission times due to typing.

Similar to passphrases, the usage of language-based key-fingerprint representations is claimed to provide better memorability than an arbitrary series of character strings, despite the lack of empirical evidence. In our study, we measure the performance of different approaches and collect perception and feedback from end users.

---

## 3. Background
In recent years, various textual key-fingerprint representations have been proposed. In this section, we analyze currently practiced in-persona key verification techniques in well-known applications. For comparison, Table 1 lists the approaches we used in our evaluation, generated from the same hash value.

Only applications requiring manual key-fingerprint verification are considered. In mechanisms like S/MIME or X.509, fingerprints play a secondary role because certificates are verified via certificate chains.

In the following, SHA-1(x)16 defines the execution of 16 rounds of nested SHA-1 on x, a truncation to the left-most 16 bits is defined by x[0, ..., 16], and pk is used as an abbreviation for the values of a public key (differs for RSA, DSA, or ECC).

### 3.1 Numeric
Numeric representation describes the notation of data using only numeric digits (0-9). The primary advantage of such a system is that Arabic numerals are universally understood, and numeric key-fingerprints show a similarity to phone numbers. The encoding is achieved by splitting a binary hash into chunks of equal length and expressing each chunk as a decimal number, e.g., by simply switching the representation base from 2 to 10.

The messaging and data exchange application SafeSlinger [3] implements this as a fallback scheme for unsupported languages. A 24-bit SAS in SafeSlinger (cf. Figure 2a) can be expressed by three decimal-encoded 8-bit numbers.

In the messaging platform WhatsApp, a fingerprint is calculated by SHA-256(pk)5200[0, ..., 240]. This fingerprint is split into six chunks, where each chunk is represented by a five-digit number modulo 100,000 [43]. Concatenating this fingerprint with the fingerprint of the communication partner results in the displayed representation, e.g.:
```
77658 87428 72099 51303
34908 23247 95615 27317
09725 59699 62543 54320
```

### 3.2 Alphanumeric
Alphanumeric approaches use numbers and letters to represent data. Depending on the representation type and its parameters, the letters can be presented in lower-case or upper-case. The string can be chunked into groups of characters, usually of equal length. Chunking does not alter the information contained, while changing lower-case letters to upper-case letters (and vice versa) may, depending on the coding scheme. Commonly used representations are Hexadecimal, Base32, and Base64.

#### 3.2.1 Hexadecimal
Hexadecimal digits use the letters A-F in addition to numerical digits and are a common representation for key-fingerprints, primarily used in SSH and OpenPGP. Note that the case of the letters does not make any difference. Regarding chunking, both spaces (cf. Figure 1b) and colons (cf. Figure 1a) are commonly used as separation characters.

Key fingerprints in OpenPGP version 4 are defined in RFC 4880 [7] by:
```
Hex(SHA-1(0x99 || len || 4 || creation time || algo || pk))
```
where `len` is the length of the packet, `creation time` is the time the key was created, and `algo` is a unique identifier for the public-key algorithm. While the inclusion of creation time ensures that even two keys with the same key material have different fingerprints, it allows an attacker to iterate through possible past times to generate similar fingerprints, skipping the key generation step [5]. The actual representation of OpenPGP fingerprints is not defined in RFC 4880, but most implementations choose to encode them in hexadecimal form, e.g., GnuPG displays them in uppercase in 16-bit blocks separated by whitespaces.