| at noon              | 计划在当天中午运行                     |
| at noon June 25      | 计划于6月25日中午开始运行              |
| at tomorrow          | 计划明天运行                           |
| at now + 20 minutes  | 计划从当前时间起20分钟内运行           |
| at now + 10 hours    | 计划从当前时间起10小时内运行           |
| at now + 5 days      | 计划从当前日期起五天内运行             |
| at now + 3 weeks     | 计划从当前日期起三周内运行             |
| At 7:20pm 06/25/2019 | 计划于2019年6月25日晚上7点20分开始运行 |
当您使用指定的时间进入**at**守护进程时，进入交互模式时，您会看到at\>提示符。您可以在此处输入要在指定时间执行的命令：
kali \>at 7:20am
at \>/root/myscanningscript
此代码片段将安排myscanningscript今天上午7:20执行。
### 总结
管理Linux中的进程是每个Linux用户和黑客的技能。您必须能够查看，查找，终止，确定优先级并让进程以最佳方式运行。黑客通常需要在他们想要杀死的目标上找到进程，例如防病毒软件或防火墙。他们还需要管理攻击中的多个进程并确定其优先级。
7
-
管理用户环境变量
----------------
MANAGING USER ENVIRONMENT VARIABLES
![](media/451fdbee142e8cd4684d71b24707d050.jpg)
为了充分利用Linux来入侵系统，您需要了解环境变量，并熟练地管理它们，以获得最佳的性能、便利性，甚至是隐匿性。然而，在Linux新手发现有问题的领域中，管理用户环境变量可能是最难掌握的。从技术上讲，有两种类型的变量：**shell**和环境变量。环境变量是构建在系统和接口中的系统范围的变量，它们控制用户对系统的外观、行为和“感觉”，并且它们由任何子shell或进程继承。另一方面，Shell变量通常以小写形式列出，并且只在它们所设置的Shell中有效。为了避免过度解释，我在这一章中只介绍了环境变量和shell变量的一些最基本和有用的技巧，并没有深入讨论它们之间的区别。
变量只是键值对中的字符串。通常，每一对看起来都像KEY=value。在有多个值的情况下，它们看起来像KEY=value1:value2。与Linux中的大多数东西一样，如果值中有空格，则需要包含在引号中。在Kali
Linux中，您的环境就是您的bash
shell。每个用户，包括根用户，都有一组默认的环境变量，这些环境变量决定了系统的外观、行为和感觉。您可以更改这些变量的值，使您的系统更有效地工作，调整您的工作环境以最好地满足您的个人需求，如果需要，还可以覆盖您的痕迹。
### 查看和修改环境变量
您可以查看所有默认的环境变量，方法是在终端的任意目录下输入**env**，如下所示:
kali \>env
XDG_VTNR=7
SSHAGENT_PID=922
XDG_SESSION_ID=2
XDG_GREETER_DATA_DIR=/var/lib/lightdm/data/root
GLADE_PIXMAP_PATH=:echo
TERM=xterm
SHELL=/bin/bash
­­snip­­
USER=root
­­snip­­
PATH=/usr/local/sbin :usr/local/bin:/usr/sbin:/sbin/bin
­­snip­­
HOME=/root
­­snip­­
环境变量总是大写的，如HOME、PATH、SHELL等等。这些只是系统上的默认环境变量。用户还可以创建自己的变量，正如您将看到的，我们需要一个不同的命令来在输出中包含这些变量。
#### *查看所有环境变量*
要查看所有环境变量，包括shell变量、本地变量和shell函数(如任何用户定义的变量和命令别名)，请使用**set**命令。此命令将列出系统特有的所有环境变量，在大多数情况下，这些变量将给出很长的一串输出，因此您无法在单个屏幕上查看所有这些变量。您可以使用**set**请求以更容易访问的方式逐行查看每个变量，并将其传递到**more**命令，如下所示:
kali \>set \| more
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdlist:complete_fullquote:expand_aliases:extglob.....
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
­­snip­­
现在，变量列表将一行一行地填充一个屏幕，然后停止。当你按回车键时，终端会转到下一行，带你进入下一个变量，因此，您可以通过按下或按住回车键滚动。你可以回想在第二章，当你使用更多的输出指令时，您可以输入**q**来quit(或者exit)并返回到命令提示符。
#### *特定变量的过滤*
虽然使用**set**
和**more**可以提供比单独设置的大量变量名称更容易管理的结果，但如果你正在寻找一个特定的变量，它仍然会相当繁琐。相反，您可以使用过滤命令**grep**来查找您感兴趣的变量。
我们以变量HISTSIZE为例。此变量包含命令历史记录文件存储的最大命令数。这些命令是您之前在此会话中键入命令提示符的任意命令，可以使用向上和向下键来调用。请注意，HISTSIZE不会存储命令本身，只存储可以存储的命令数。
用grep管道你的set输出来找到HISTSIZE变量，如下所示：
kali \>set \| grep HISTSIZE
HISTSIZE=1000
如您所见，此命令查找变量HISTSIZE并显示其值。此变量的默认值可能在您的系统上设置为1000。这表示终端默认存储最后1,000条命令。
#### *更改会话的变量值*
现在让我们看看如何更改变量的值。如上所述，HISTSIZE变量包含要存储在历史文件中的命令数的值。
有时，您不希望系统保存过去的命令 -
可能是因为您不希望在自己的系统或目标系统上留下任何活动证据。
在这种情况下，您可以将HISTSIZE变量设置为0，这样系统就不会存储您以前的任何命令。由于此变量具有单个值，因此要更改它，请按照清单7-1中所示的熟悉方式为其分配新值。
kali \>HISTSIZE=0
*清单7-1：更改HISTSIZE的值*
现在，当您尝试使用向上和向下箭头键来调用命令时，没有任何反应，因为系统不再存储它们。这是隐秘的，虽然它可能不方便。
#### *使变量值永久更改*
当你改变一个环境变量,变化只发生在特定的环境;在本例中,环境是bash
shell会话。这意味着，当您关闭终端时，您所做的任何更改都将丢失，并将值设置回默认值。如果你想要永久更改,你需要使用**export**命令。这个命令将把当前环境(bash
shell)中的新值导出到系统的其余部分，使其在每个环境中都可用，直到您更改并再次导出它为止。
变量是字符串，所以如果您在谨慎的情况下运行，在修改变量之前将其内容保存到文本文件中并不是一个坏主意。例如，由于我们将要更改**PS1**变量，它控制您在提示符中显示的信息，所以首先运行以下命令，将现有值保存到当前用户的主目录中的文本文件中:
kali \>echo \$HISTSIZE\> \~/valueofHISTSIZE.txt
这样，您总是可以撤消更改。如果你想更谨慎地创建一个文本文件，使用所有当前设置，你可以将**set**命令的输出保存到一个文本文件中，命令如下:
kali \>set\> \~/valueofALLon01012017.txt
如清单7-1所示，在您更改了一个变量之后，您可以通过输入**export**，然后输入您更改的变量的名称来永久更改，如下所示:
kali \>export HISTSIZE
现在，当您离开这个环境并进入另一个环境时，HISTSIZE变量仍然被设置为0。如果您想重置HISTSIZE变量为1000，只需输入以下内容:
kali \>HISTSIZE=1000
kali \>export HISTSIZE
这段代码将把HISTSIZE变量的值设置为1,000，并将其导出到所有环境中。
### 更改SHELL提示符
shell提示符是另一个环境变量，它为您提供有用的信息，例如您正在操作的用户和当前工作的目录。Kali中的默认shell提示符采用以下格式:
username\@hostname:current_directory
如果您是根用户，这将转换为以下默认提示符:
root\@kali:current_directory
您可以通过设置**PS1**变量的值来更改默认shell提示符中的名称。**PS1**变量有一组占位符，用于显示希望在提示符中显示的信息，包括以下内容:
\\u  当前用户的名称
\\h  主机名
\\W  当前工作目录的基本名称
如果您恰好在多个系统上有shell，或者作为多个帐户登录，这将非常有用。通过为不同的shell或帐户设置不同的\\u和\\h值，您可以一眼看出您是谁以及您当前的系统是什么。
让我们找点乐子，更改一下终端中的提示符。例如，您可以输入以下内容:
kali \>PS1="World's Best Hacker: \#"
World's Best Hacker: \#
现在，每次你使用这个终端，你都会被提醒你是“世界上最好的黑客”。但是，您打开的任何后续终端仍然会有默认的命令提示符，因为**PS1**变量只保存您的终端会话的值。记住，在导出变量之前，它只适用于该会话。如果你真的喜欢这个新的命令提示符，并希望在每个终端都能看到它，你需要将它导出，如下所示:
kali \>export PS1
这将使更改在所有会话中永久保存。
再来点乐子怎么样?假设您真的希望您的终端看起来像一个Windows
cmd提示符。在本例中，您可以将提示符名称更改为C:并保留\\w以让提示符显示当前目录，如清单7-2所示。
kali \>export PS1='C:\\w\> '
C:/tmp\>
*清单7-2:更改提示并显示当前目录*
提示符显示当前目录通常是有用的，特别是对于初学者，所以在更改PS1变量时要考虑这一点。
### 改变你的PATH
在您的环境中，最重要的变量之一是PATH变量，它控制您的shell将在系统的哪个位置查找您输入的命令，比如cd、ls和echo，大多数命令位于sbin或bin子目录中，比如/usr/local/sbin或usr/local/bin。如果bash
shell没有在PATH变量中的某个目录中找到该命令，它将返回“未找到错误”命令，即使该命令确实存在于路径之外的目录中。
你可以找到哪些目录存储在你的路径变量使用echo的内容，如:
kali \>echo \$PATH
/usr/local/sbin:usr/local/bin:/usr/sbin:/sbin/bin
这些是您的终端将搜索任何命令的目录。例如，当您输入**ls**时，系统知道在这些目录中查找ls命令，当它找到ls时，系统就执行它。
每个目录由冒号(:)分隔，不要忘记将\$ content符号添加到PATH中。
#### *添加到PATH变量*
可以看出为什么知道PATH变量中的内容很重要:如果您下载并安装了一个新工具（比方说newhackingtool）到/root/newhackingtool目录中，您只能在该目录中使用该工具的命令，因为该目录不在PATH变量中。每次您想使用该工具时，首先必须导航到/root/newhackingtool，如果您想经常使用该工具，这有点不方便。
要从任何目录中使用此新工具，您需要将包含此工具的目录添加到PATH变量中。
要向PATH变量添加newhackingtool，请输入以下命令:
kali \>PATH=\$PATH:/root/newhackingtool
这将原始路径变量加上/root/newhackingtool目录分配给新路径变量，因此该变量包含它之前所做的所有事情，以及新工具目录。
如果再次检查PATH变量的内容，应该会看到这个目录已经被添加到PATH的末尾，如下所示:
kali \>echo \$PATH
/usr/local/sbin:usr/local/bin:/usr/sbin:/sbin/bin:/root/newhackingtool
现在，您可以在系统的任何位置执行newhackingtool应用程序，而不必导航到它的目录。bash
shell将在为您的新工具列出的所有目录中查找!
![](media/dbe9da136b68e46a69a46917a5877cf1.png)
#### *如何不添加PATH变量*
新Linux用户经常犯的一个错误是，以这种方式将一个新目录(如/root/newhackingtool)直接分配给PATH变量:
kali \>PATH=/root/newhackingtool
kali \>echo \$PATH
/root/newhackingtool
如果您使用这个命令，您的PATH变量将只包含/root/newhackingtool目录，而不再包含包含诸如/bin、/sbin等包含关键命令的系统二进制目录。然后，当您使用任何系统命令时，您将收到未找到的错误命令，如下所示，除非您在执行该命令时首先导航到系统二进制目录: