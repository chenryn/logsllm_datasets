### 优化后的文本

#### 设置指定偏移
首先，设置指定偏移。然后调用 `ReadFile` 函数，成功将数据读取到地址 `009A0000`。接着，使用 F8 单步执行，直到遇到 `ret` 指令，结束当前函数。

#### 回到IDA进行分析
回到 IDA 中，检查之前看到的两个函数。这两个函数没有实际功能，可以直接跳过。在函数底部，发现存在堆栈不平衡的错误。为了解决这个问题，我们返回到 OllyDbg (OD) 中查看具体运行情况。

#### 在OllyDbg中进一步分析
果然，在 OD 中可以看到，两个 `call` 指令执行完毕后，程序并未如 IDA 所示退出函数，而是继续向下执行，并在 `00438FF2` 和 `00438FFD` 处分别执行了两个新的 `call` 指令。

我们使用 F7 跟进到 `0043911c` 函数，发现该函数通过动态解密的方式执行，且包含一个大循环，代码可读性极差。结合之前的分析（即 `ReadFile` 读取的数据被存储在 `VirtualAlloc` 分配的空间中），可以推测该函数可能在解密这些数据。

重新运行程序并在该处设置断点，使用 F8 单步执行并对比 `009A0000` 内存区域的数据。确实发现 `009A0000` 的值发生了变化，说明我们的推断是正确的。但遗憾的是，我们仍无法确定解密后的内容。

#### 进一步调试
双击第二个 `call` 指令，可以看到它实际上是一个 `call dword ptr ss:[ebp-0x10]`。因此，我们在内存窗口中查看 `ebp - 0x10` 处的值，发现它指向 `009A0000`。这意味着程序通过第一个 `call` 解密了 `009A0000` 处的数据，然后通过第二个 `call` 跳转到 `009A0000` 继续执行。

由于 `009A0000` 是动态解密出来的，我们无法直接在 IDA 中进行静态分析。但我们可以通过将这段二进制数据导出并使用 IDA 加载来识别其内容。选中这一段数据，右键选择“保存到数据文件”，然后通过 IDA 加载即可。不过，这种方法仍然会导致代码可读性较差，因此我们选择在 OD 中继续调试。

#### 系统API调用
回到 OD 中，可以看到 IDA 未识别的一些系统 API 调用，包括 `SetErrorMode`、`GetSysColor`、`GetSystemDefaultLangID` 和 `GetAtomName`。通过这些 API 可以判断当前操作系统的环境，如系统颜色和默认语言等。

#### 进入特定函数
选中 `call 009A0B60` 并回车进入该函数。该函数首先对 `ebp - 0x1x` 的地址进行赋值。这里直接查看十六进制 ASCII 不太直观，我们可以借助 IDA 查看相关信息。获取两个字符串 `%AppData%` 和 `systemprofile`，然后调用 `expandenvironmentstrings` 函数扩展环境变量。

#### 环境变量扩展
直接 F4 跑到该函数，查看参数值。可以看到，该函数执行后，`?` 将代表环境变量 `%AppData%`。接着程序调用 `0090340`，参数分别是 `%Appdata%` 和 `systemprofile`。为了节省时间，我们直接进入该函数，发现其中有两个 `call` 指令，都是简单的循环加法计算。

#### 获取模块句柄
接下来，程序解出一个字符串并使用 `GetModuleHandle` 获取 `User32.dll` 的句柄，然后通过 `GetProcAddress` 获取 `GetRawInputDeviceList` 函数指针。通过该函数枚举连接到系统的原始输入设备。如果成功获取到原始输入设备，则结束函数；否则退出进程。

#### 分配新内存
继续调试，发现又有一个 `VirtualAlloc` 调用，分配大小为 `CCC00` 的内存。F8 单步执行，可以看到 `eax` 中的新内存起始地址为 `009B0000`。接着，再次调用 `GetModuleFileNameA` 和 `CreateFile` 打开当前文件的句柄，设置新的偏移点并读取数据。

#### 解密PE文件
根据经验，返回后应该会对这片内存进行解密。返回后的两个 `call` 没有实际功能，可以直接 F8 跳过。接下来的 `call 009A01C0` 包含许多跳转指令，应该是循环解密的地方。F4 运行过来，注意观察 `009B0000` 的值。F8 执行该函数，成功解密出一个 PE 文件。

#### 导出并分析PE文件
我们将解密出的 PE 文件导出并保存为 `dump_.exe.bin`。将其拷贝到真实机器上并通过 PowerShell 计算 MD5 值：
```powershell
Get-FileHash -Algorithm md5 .\dump_.exe.bin
```
得到哈希值：`4F8091A5513659B2980CB53578D3F798`。通过 Systrace 监控行为，发现与最初监控原始文件的行为一致，确认这是一个 Dropper 样本，用于在内存中加载恶意样本。VirusTotal 上有 62 家杀毒引擎报毒，进一步证实了这一点。

#### 最终步骤
OD 中还有一些未分析的恶意代码，但基本可以确定后续步骤是加载并执行该样本。最后一个 `call` 指向 `VirtualAlloc`，参数为 `004000`，显然是为了在内存中加载并执行解密出的 PE 文件。接着，`VirtualAlloc` 分配 `00A80000` 地址，将解密出的 PE 文件复制到该地址，并调用 `009A0710` 函数进行节区信息检查。最终，通过 `LoadLibrary` 加载 `Kernel32.dll`，并调用 `00A83870` 正式转入第二个 PE 文件执行。

#### 总结
本文分析了一个被修改了 CRT 的 Dropper 样本，根据奇安信去年年底的报告，此样本可能是 Lazarus 攻击印度核电厂的 Dropper 样本。通过详细分析，我们揭示了非常规的攻击套路。至此，恶意样本分析的基础系列完成，感谢大家的支持！接下来的文章将继续分享更多有趣的样本和分析手法。