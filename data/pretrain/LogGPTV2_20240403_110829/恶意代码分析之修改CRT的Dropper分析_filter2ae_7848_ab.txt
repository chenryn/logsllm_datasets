设置指定偏移：
然后调用ReadFile，成功将数据读取到009A0000
然后我们继续F8，执行到ret，结束该函数。
回到IDA中，看了下之前看到的那两个函数，都和之前看到的一样，没有实际功能，可以直接跳过。
且我们注意到，函数底部，出现了堆栈不平衡的错误。我们直接回到OD中，看具体运行到这里是怎样的。
果然，我们可以看到，两个call执行完之后，程序并没有像是IDA中看到的那样退出函数，而是接着往下运行，又分别在00438FF2和00438FFD这里执行了两个call指令。
我们F7跟进到0043911c函数中之后发现，该函数的指令通过动态解密的方式执行，且在执行一个大循环，代码可读性极差，经验告诉我们，这种不断的循环应该是在解密，结合我们之前分析到的read了片数据到VirtualAlloc分配的空间中，我们可以猜测该函数应该是在解密我们看到的数据。
于是我们重新运行程序，断点跑到这里，然后F8跑过去，对比一下函数执行后009A0000内存的数据：
诶 009A0000的值的确改变了，说明我们的推算是正确的，但是遗憾的是，这里我们还是没有看出来，解密后的内容是什么。只能继续往下走了。
我们双击第二个call ，可以知道这里指令实际上是call dword ptr ss:[ebp-0x10]
所以我们可以在内存窗口中看看ebp – 0x10 处的值是什么
跳转过来之后可以发现这里居然就是009A0000
也就是说程序通过第一个call解密了009A0000处的数据，然后通过call，跳转到009A0000处继续执行：
由于这里的009A0000是动态解密出来的，此时我们就没有办法在IDA中进行静态分析了，其实也可以，我们现在已经知道了009A0000这里是一个大函数，我们可以把这段二进制数据dump出来，使用IDA加载，就可以识别到一个函数。
我们选中这一大段数据，然后鼠标右键，选择保存到数据文件
然后通过IDA加载即可：
但是这里这样做的话，代码可读性还是比较差。
所以我们还是直接在od中边调试边看吧~ 我们回到OD中，可以看到，IDA没有识别出来的call，od已经自动识别出了一些系统API调用，
分别是SetErrorMode、GetSysColor、GetSystemDefaultLangID、GetAtomName  
通过这几个API我们可以知道，这里是在对当前的操作系统环境进行一个初步判断，包括系统颜色、系统默认语言等
我们直接选中call 009A0B60这一行，然后回车进入该函数(不影响程序的EIP)：
009A0B60进来之后，可以看到首先是对ebp – 0x1x 的地址进行赋值。
这里直接看十六进制的ASCII看不出来，我选择看看IDA是否有可用信息，你猜怎么着，IDA中很方便看
这里首先是获取来两个字符串：
%AppData%
systemprofile
然后调用一个call，我们在od中可以看到该call是expandenvironmentstrings，该函数可以扩展环境变量，使用当前用户定义的值来替换对应的环境变量字符串。
我们直接F4跑到这个函数，看一下参数的值。
从图中可以看到，该函数执行之后，? 将会代表环境变量%AppData%
接着程序call 0090340 ，参数分别是%Appdata%和systemprofile
同样的，为了节约分析时间，我们可以直接选中函数，然后回车进入到函数
进来之后有两个call，我们也选中第一个call，然后回车进去，就只是一个循环add计算。
按esc回到上一层，然后选中第二个函数，回车进来，发现和第一个call很相似
然后esc回到上层，往下滑动，发现没有其他call
了，就是一些跳转指令进行赋值的，所以我们可以直接按*号键，回到当前EIP，直接F8步过该函数，就不跟进进去了。
然后又解出一个字符串，使用GetModuleHandle获取Handle
通过IDA我们可以知道这里是获取User32.dll
然后通过GetProcAddres获取GetRawInputDeviceList，通过该函数，可以枚举连接到系统的原始输入设备。
然后调用GetRawInputDeviceList，成功获取到原始输入设备之后结束函数，如果获取失败则退出进程。
该函数执行完了之后，继续在后面一个call 009A00B0这一行回车进去：
进来之后发现又有一个VirtualAlloc，于是我们直接在VirtualAlloc这一行F4跑过来：
这次分配的的内存大小是CCC00
F8单步往下执行，eax中会出现新内存的起始地址：009B0000
继续往下走，又是熟悉的GetModuleFileNameA和CreateFile
打开的还是当前文件的句柄：
设置一个新的偏移点：
和之前一样的方式Read：
Read成功：
然后关闭句柄，然后退出函数。
根据之前的经验，返回出去之后，应该就会对这片内存进行解密了。
返回出来的两个call，通过快速分析发现没有什么功能，可以直接F8步过。
然后再下面的009A008C这里的call 009A01C0，回车进去可以看到有很多跳转指令，应该就是循环解密的地方了
我们F4运行过来，注意下面内存窗口汇总009B0000的值：
然后F8执行这个函数，不出意外就会成功解密：
惊喜来了，这里解密出了一个PE文件。
我们还是把这个PE文件dump出来并保存为dump_.exe.bin
我们将该程序拷贝到真实机器上，然后通过powershell计算该文件的MD5：
Get-FileHash -Algorithm md5 .dump_.exe.bin
得到hahs：4F8091A5513659B2980CB53578D3F798
然后我们尝试通过Systrace对该程序进行行为监控，神奇的事情再度出现，这里的行为，居然跟我们最开始对原始文件监控的时候，行为一模一样。这里说明，我们目前分析的这个样本的确是个Dropper。用于在内存中加载一个恶意样本。
然后发现有VT上有62家报毒。说明此文件就是我们分析样本Drop出的真实恶意样本。
od中还有一点点恶意代码么有分析完，但是我们基本可以知道，后面是用于加载执行该样本了。
这里只剩下最后一个call，我们直接回车进去，然后F4跑过
第三次VirtualAlloc，这里需要注意，这里的参数是004000，在VirtualAlloc中使用这样的参数，可以制作一个PE加载到自己内存中执行，很明显这里是为了加载执行Drop出来的文件做准备了。
然后又是VirtualAlloc分配00A80000
然后再下面执行一个call，将之前解密出来的PE赋值到00A80000中：
然后call 009A0710 这里需要注意，call的时候，push了eax作为参数，而eax==00A80000
所以该函数很有可能比较关键，我们F7跟进进去
然后发现是在循环判断节区信息，以确定是预设的PE文件
每次执行完之后，通过jmp跳转到开头执行
我们直接F4执行到retn处，执行完成本次的检查。然后F8退出函数。
然后紧接着的一个call，又将00A80000放在ecx中作为参数进行调用，没办法，我们只能继续跟进
通过LoadLibrary加载Kernel32.dll
然后又是一个查找，然后在call 009A07E0处对比，看样子应该还是用于检查将要加载的程序是否是预期程序。
所以我们还是直接在retn处F4，然后退出该函数。
继续往下看，又看到一个如下的函数调用，参数是00A80000
且后面有一个call eax，然后就释放内存，结束函数了。
说以这个call eax肯定是关键函数，且eax 的值就来源于我们看到的call 009A09E0
我们直接F4到 call eax，然后F7进去
这里面函数有点多，我们还是根据之前的方法快速分析，跟参数无关的call
直接F8运行过去，然后观察参数和eax的值即可。这里需要注意，我们通过此方法调试的时候请设置好快照，因为这样的调试方法经常会让程序跑飞，设置断点可以很好定位到跑飞点，然后定位到关键代码。
最后发现这里 call 00A83870，程序从这里，正式转入到了第二个PE文件中执行。
而第二个PE文件是标准VC编译的，无壳无混淆，非常好分析，有兴趣的读者可以试着继续跟进分析一下。
## 0x04 总结
在本小节中，主要是分析了一个被修改了CRT的Dropper样本。根据奇安信去年年底的报告来看，此样本应该是作为Lazarus攻击印度核电厂的Dropper样本。但是在报告中却一句话带过了，并没有详细的分析该样本的具体功能。所以本节中也以此样本为例，管中窥豹，学习学习非常规的攻击套路。
至此，恶意样本分析的基础系列算是完成，感谢大家的支持~
接下来的文章，将会分享一些更有特点的样本和分析手法。