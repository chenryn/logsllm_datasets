1)a[i] = b
练习8.5.5：扩展算法8.7，使之可以处理如下的三地址语句（原文为three-statements-
练习 8.5.4：为图 8-9 中的块 B的代码构造 DAG。
练习8.5.3：为图 8-9 中的块 Bg的代码构造 DAG。请不要忘记包含比较指令i≤10。
2）α、b、c在基本块的出口处活跃。
1）只有α在基本块的出口处活跃。
练习8.5.2：分别按照下列两种假设简化练习8.5.1的三地址代码。
练习8.5.1：为下面的基本块构造DAG。
）
寄存器中。
给出这个基本块的三地址语句(每个语句只做一次加法)。
a[j]
b*
b*
+
q5
第8章
译
---
## Page 365
指令中给出的第二个寄存器中，而绝不会是第三个寄存器。可以按照下面的方法来改进算法：只
机器指令。因此，我们没有利用+的交换性。这样，当我们实现这个运算时，Y的值必须在 ADD
8.6.2代码生成算法
可以是由这些位置组成的--个集合。这个信息可以存放在这个变量名字对应的符号表条目中。
将存放零个或多个变量名字的值。
我们可以假设在开始时所有的寄存器描述符都是空的。随着代码生成过程的进行，每个寄存器
当前值存放在此寄存器内。因为我们仅仅考虑那些用于存放一个基本块内的局部值的寄存器
哪个或哪些寄存器里面。我们还需要知道当前存放在一个给定变量的内存位置上的值是否就是
放人一个内存位置，它还会生成相应的保存指令。
算分量加载进寄存器。在生成加载指令之后，它开始生成运算代码。然后，如果有必要把结果存
8.6.1寄存器和地址描述符
闲的寄存器足以完成任何三地址运算。
给
置
个数据结构具有下列描述符：
这
器
令
理。我们假设基本块已经通过诸如公共子表达式合并这样的转换而变成了我们希望的三地址指
器集合不包括机器的所有寄存器，因为有些寄存器专门用于存放全局变量或者用于对栈进行管
在一个形如×=Y+z 的三地址指令中，我们将把+当作一般的运算符，而 ADD 当作等价的
数还可能需要获取一些有用的数据流信息，比如哪些变量在基本块出口处活跃。我们将首
选择寄存器。函数 getReg 可以访问这个基本块的所有变量对应的寄存器和地址描述符。这
1）每个可用的寄存器都有一个寄存器描述符（register descriptor)。它用来跟踪有哪些变量白
个变量的正确值。因为变量的新值可能已经在寄存器中计算出来但还没有存放到内存中。这
我们的代码生成算法依次考虑了各个三地址指令，并决定需要哪些加载指令来把必需的运
中的所需的运算分量进行运算，并把结果存放在一个寄存器中。机器指令的形式如下：
序列。我们进--步假设对每个运算符有且只有--个对应的机器指令。这个指令对存放在寄存
代码生成
2）每一个程序变量都有一个地址描述符（address descriptor）。它用来跟踪记录在哪个或哪些位
为了做出这些必要的决定，我们需要一个数据结构来说明哪些程序变量的值当前被存放在
 OP reg, reg, reg.
@ LD reg, mem
本节的算法假设有一组寄存器可以用来存放在基本块内使用的值。通常情况下，这个寄存
因为可用寄存器的数量是有限的，这些需求之间有相互竞争的关系。
·寄存器用来存放在一个基本块中计算而在另一个基本块中使用的（全局)值。比如，循环
·寄存器很适合做临时变量，即在计算－-个大表达式时存放其子表达式的值。或者更一般
?寄存器经常用来帮助进行运行时刻的存储管理。比如，管理运行时刻栈包括栈指针的维
护，栈顶元素也可能被存放在寄存器中。
地讲，寄存器适合用于存放只在单个基本块内使用的变量的值。
ST mem,reg
下标的值，每次循环都对该值作增量运算，并在循环体中多次被使用。
349
先
个
---
## Page 366
例8.16
载指令并(按照规则1)像处理所有的加载指令那样处理完各个描述符之后，再进行下面的处理：;
存位置。
修改的规则如下：
们必须生成指令 ST，R，其中R是在基本块的结尾处存放值的寄存器。
那种情况下，对于每个变量x，如果它的地址描述符表明它的值没有存放在的内存位置上，我
跃，或者我们不知道哪些变量在出口处活跃，那么就必须假设这个变量的值会在以后被用到。在
们可以忘记这些临时变量的值并假设这些寄存器是空的。但如果一-个变量在基本块的出口处活
做任何事情。我们只需要修改 R，的寄存器描述符，表明 R，中也存放了的值。
器
存放y的内存位置之--(y'可以根据的地址描述符得到)。
中。
比较好的代码序列。
要+是一个满足交换律的运算符，算法同时为×=Y+z 和×=Z+Y 生成代码；随后再选择-一-个
②修改×的地址描述符，使得它只包含唯--的位置 R。
当代码生成算法生成加载、保存和其他机器指令时，它必须同时更新寄存器和地址描述符。
350
①把x加人到R，的寄存器描述符中。
4）当我们处理复制语句=y时，如果有必要生成把y加载人 R，的加载指令，那么在生成加
③从任何不同于的变量的地址描述符中删除 Rx。
②改变x的地址描述符使得它只包含位置R。注意，现在x的地址描述符中不包含x的内
③从任何不同于x的变量的地址描述符中删除 R。（原文缺--条—-译者注。)
②修改×的地址描述符，把寄存器R作为新增位置加入到x的位置集合中。
1）对于指令“LD R，x"：
管理寄存器和地址描述符
如果这个变量是一个只在基本块内部使用的临时变量，那就没有问题；当基本块结束时，我
我们描述算法时表明，在代码结束的时候，基本块中使用的变量可能仅存放在某个寄存器
如果y没有在寄存器R,中，那么生成机器指令LD R，，Y。如果y已经在R，中，我们不需要
形如x=y的三地址指令是一个重要的特例。我们假设 getReg 总是为α和y选择同一个寄存
4）生成指令“ADD R，Ry，R"。
3）类似地，如果z不在R内，生成一个指令“LD R，"，其中z是存放z的位置之一。
n
①改变
2）对于指令 ST×，R，修改x的地址描述符，使之包含自己的内存位置。
①修改寄存器R的寄存器描述符，使之只包含x。
基本块的收尾处理 
复制语句的机器指令 
2）如果（根据R，的寄存器描述符)y不在R,中，那么生成一个指令“LD Ry，y"，其中y'是
3）
1）使用 getReg(x=y+z)来为α、y、z选择寄存器。我们把这些寄存器称为 R、R,和 R。
对每个形如=y+z的三地址指令，完成下列步骤：
运算的机器指令
1
11
11
让我们把由下列三地址语句组成的基本块翻译成代码。
变R的寄存器描述符，使之只包含。
C
b
第8章
---
## Page 367
令的结果。
存放在该寄存器中的c的值在该基本块内不再使用，且在自己的内存位置上也存放了这个值。
内存位置中。
放结果u。请注意，我们改变了a 的地址描述符，以表明它已经不在 R1 中，但是还在称为 a 的
从a 的内存位置上获取(因为a 的值也在它自己的内存位置上)。因此，我们还可以复用R1 来存
寄存器 R1 中的 a 的值在该基本块中不再被用到，而且如果在基本块之外需要使用 a 的值，可以
getReg 做出。
么我们将不得不先把 R2 中的值保存到 b。假如我们需要 R2，那么生成指令 ST b R2 的决定将由
为预设了b 在基本块的出口处活跃，假如(b 的地址描述符表明)b 不在它自己的内存位置上，
意，我们可以使用 R2 来存放t 是因为原先存放于 R2 中的b 的值在该基本块内不再被使用。
因此，我们看到a 和b 被加载到寄存器 R1 和 R2 中，而t 的值生成后存放于寄存器 R2 中。注
之后的寄存器和地址描述符的情况。
个临时变量的所有使用都已经处理完了），我们就复用这个寄存器。
可用。但是当一个寄存器中存放的值不再有用时（比如，它只存放了--个临时变量的值，且对这
因为我们还没有讨论函数 getReg 是如何工作的，所以将简单地假设当需要时总有足够的寄存器
图8-16 显示了算法生成的所有机器代码指令。该图还显示了在翻译每个三地址指令之前和
代码生成
复制指令 a=α 需要一个指令来加载d，因为α 不在寄存器中。图中显示寄存器 R2 的描述
第三个指令=t+u只需要一个加法指令。而且，我们可以用 R3 来存放结果v，因为原先
第二个指令u=a－c 不需要加载 a 的指令，因为 a 已经存放在寄存器 R1 中。原来存放不
exit
t=
图8-16生成的指令以及寄存器和地址描述符的改变过程
6
R2,
2R
d1 a 1 v a R2. b c  d.R1 l R3
day]
[ua,d ] <]
[u| tc]
巴
R2
R2blcR1
R2 1 b 1 cd. R2 1 R1  R3 ]
a I b c. R3 d I R2 Ri1 
ar1 blca R2 l?
al bel al Il.
 R3
351
---
## Page 368
8.6. 4 8. 6 节的练习
择 Ry，然后是让R=Ry
R,仅仅保存了的值，那么R,同时也可以用作 Rx。对z和R,也有类似选择。
相同。
使×就是y或z之一，这个语句仍然成立，因为我们的机器指令允许一个指令中的两个寄存器
出其中的区别。
之一)
骤。最后，R的“得分”是我们需要生成的保存指令的个数。选择一个具有最低得分的寄存器（或
已的内存位置上去。这个操作称为溢出操作(spill)。
出口处活跃，那么的值必然在基本块中被重新计算），那么我们就完成了任务。
用，因此我们可以忽略它。
中的z)，那么我们就完成了任务。其原因是在这种情况下，我们知道×的当前值决不会再次被使
么我们还可以到别的地方获取v的值。可能的情况包括：
R 的寄存器描述符表明的已位于R中的变量。我们需要保证要么的值已经不会被再次使用，
个可行的寄存器，并且必须保证复用这个寄存器是安全的。设R是一-个候选寄存器，且假设v是
题是相同的，因此我们将集中考虑为y选择寄存器R，的方法。选择规则如下：
+z作为一般性的例子。首先，我们必须为和z分别选择--个寄存器。这两次选择所面临的间
变量的值而导致生成错误代码。我们用处理--个运算指令的步骤来开始我们的讨论，还是用x=
很多种方法，当然也存在一些绝对不可以选择的方法。这些错误方法会因丢失一个或多个活跃
8.6.3函数 getReg 的设计
的变量a 和d的值保存回它们的内存位置。这就是图中的最后两个指令的工作。
存位置上。因为这个原因，我们需要为基本块的机器代码增加－-个“尾声”：它把在出口处活跃
在它自已的内存位置上。对于a 也是同样的情况，a 的值只存放在 R2 中，而不在被称为 a 的内
被使用，所以我们选择复用它的寄存器 R1 来存放 á 的新值。请注意，d 现在只存放在 R1 中，不
-个机器指令来把y加载到这个寄存器。
需要特别考虑的最后一个问题是当1是复制指令×=y时的情况。我们用上面描述的方法选
2）如果(像上面对变量u的描述那样)y在指令I之后不再使用，且(在必要时加载y之后)
1）因为×的一个新值正在被计算，因此只存放了的值的寄存器对R，来说总是可接受。即
现在考虑寄存器 R的选择。其中的难点和可选项几乎和选择 R，时的一样，因此我们只给
④ 如果前面的三个条件都不满足，我们就需要生成保存指令STu，R来把的值复制到它自
练习8.6.1：为下面的每个C语言赋值语句生成三地址代码
③否则，如果不会在此之后被使用(即在指令I之后不会再次使用，且如果在基本块的
1）如果当前就在-个寄存器中，则选择--个已经包含了的寄存器作为R。不需要生成
最后，让我们考虑如何针对--个三地址指令1实现函数 getReg(I)。实现这个函数可以选择
第五个指令α=V+u使用两个存放在寄存器中的值。因为u是--个临时变量且它的值不再
352
因为在那个时刻R可能存放了多个变量的值，所以我们需要对每个这样的变量u重复上述步
②如果是x，即由指令I计算的变量，且×不同时是指令I的运算分量之--（比如这个例子
① 如果的地址描述符说还保存在 R之外的其他地方，我们就完成了任务。
3）比较困难的情况是y不在寄存器中且当前也没有空寄存器。无论如何，我们需要选择-
2）如果y不在寄存器中，但是当前存在一个空寄存器，那么选择这个空寄存器作为Ry。
第8章
强
一
---