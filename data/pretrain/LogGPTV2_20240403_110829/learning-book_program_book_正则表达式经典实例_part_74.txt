## Page 399
盘符、UNC和相对路径
警告
这些正则表达式可以匹配空字符串。更多细节请参考后面的“讨论”小节，
其中还会介绍一种可替代的解决方案。
\A
(?[a-z]:/\\[a-z0-9_.]+\\[a-20-9_.$]+\\\\?)
(?(?:[^\\/:*?"<>|\r\n]+\\)*)
(?[\\/:*?"<>/\r\n] *)
\z
正则选项：宽松排列、不区分大小写
正则流派：.NET、PCRE7、Per15.10、Ruby1.9
\A
(?P[a-z]:\\1\\\[a-z0-9_.$]+\\[a-z0-9_,$]+\\/\\？)
(?P(？:[^\\/:*?"<>/\r\n}+\\)*)
(?P[^\\/:*?"<>|\r\n]*)
\Z
正则选项：宽松排列、不区分大小写
正则流派：PCRE4及更高版本、Per15.10、Python
\A
([a-z]:/[a-z0-9_.]+\\[a-z0-9_.]+\？)
（+（\\+[u\x\1<>+：/\\]:））
([\\/:*?"<>1\r\n]*)
\Z
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
（[a-z]:\\\[a-20-9_.]+\[a-z0-9_.]+\\²)
S（[u\x\1<>：/\\]）（（\\+[u\x\1<>：/\\]:）)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
讨论
在本实例中的正则表达式与上一个实例中的正则式非常类似。下面的讨论会假设你已
经阅读并且理解了上一个实例中的讨论部分。
盘符路径
与前一个实例相比，在匹配盘符路径的正则表达式中只做了一处改动。我们添加
了3个捕获分组，从而可以用它们来提取路径中的不同组成部分：（drive）、（folder>
和（file)。如果你的正则流派支持命名捕获（实例2.11），那么就可以使用这些名称。
否则，你就只好对这些捕获分组使用它们的编号进行引用，也就是1、2和3。要
想了解在你喜欢的编程语言中如何获得命名和/或编号的分组所匹配到的文本，请
URL、路径和Internet地址
383
www.TopSage.com
---
## Page 400
参考实例3.9。
盘符和UNC路径
在匹配UNC路径的正则表达式中，我们添加了相同的3个捕获分组。
盘符、UNC和相对路径
如果我们还想支持相对路径，那么机会变得相对更加复杂。在上一个实例中，我
们只需要在正则式的驱动器部分添加第3个选择分支，匹配相对路径的并始部分。
但在这里我们却不能这样做。因为对于相对路径来说，用于驱动器的捕获分组应
该是空的。
这里的解决方案中，在“盘符和UNC路径”小节内的正则式中驱动器使用的捕获分组
之后的字面上的反斜杠被移动到了捕获分组中。我们把它添加到了盘符选择分支和网
络共享的结尾。对于可能会以反斜杠开始的相对路径，我们还添加了第3个选择分支
来匹配一个可选的反斜杠。因为第3个选择分支是可选的，所以用于驱动器的整个分
组实质上也就是可选的。
这样得到的正则表达式可以正确地匹配所有的Windows路径。然而问题是因为把驱动
器部分变为了可选，我们现在就得到一个任何内容都是可选的一个正则式。在只支持
绝对路径的正则表达式中，文件夹和文件部分已经是可选了。换句话说：我们的正则
表达式会匹配空字符串。
如果想要确保这个正则式不会匹配到空字符事，那么我们就不得不再添加额外的选择
分支来处理指定了文件夹的相对路径（此时文件名是可选的），以及没有指定文件夹的
相对路径（此时文件名是必需的）：
\A
(?:
(?[a=z] :1\\\\[a-z0-9_.S]+\\[a-z0-9_.$]+)\\
(?(?:[^\\/:*?"<>|\r\n]+\\) *)
(?[\\/:*?"<>|\r\n] *)
1(?\\?(?:[^\\/:*?"<>|\r\n]+\\)+)
(?[^\\/:*?"<>|\r\n] *)
1(?[^\\/:*?"<>I\r\n]+)
\Z
正则选项：宽松排列、不区分大小写
正则流派：.NET、PCRE 7、Per15.10、Ruby1.9
\A
(?P[a-z]:/\\\[a-z0-9_.$}+\\(a-z0-9_.$]+)\\
(?P(?:[^\\/:*?"<>|\r\n]+\\)*)
(?P[^\\/:*?"<>|\r\n]*)
384第7章
www.TopSage.com
---
## Page 401
(?P\\?(?:[^\\/:*?"<>1\r\n]+\\)+)
(?P[^\\/:*?"<>1\r\n]*)
(?P[^\\/:*?"<>1\r\n}+)
\2
正则选项：宽松排列、不区分大小写
正则流派：PCRE4及更高版本、Per15.10、Python
\A
:)
（[a-z]：1\\\\[a-20-9_.$]+\\[a-20-9_.$]+)\\
（(?：[\\/:*?"<>1\r\n]+\1)*)
([^\\/:*?"<>1\r\n]*)
(\\？(?:[\\/:*?"<>|\\n]+\\)+)
([\\/:*？"<>|\r\n]*)
([^\\/:*?"<>|\r\n]+)
）
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
(？:（[a-z]:1\11\[a-z0-9_.$]+\\[a-z0-9_.$]+)\\（(？:[\\/:*？"<>1\r\n]+\\)
*)
([\\/:*?"<>J\r\n]*) 1(\\?(?：[\\/:*?"<>|\r\n]+\\)+)([\\/:*?"<>/\r\n]*
)1
([^\\/:*?"<>|\r\n]+))$
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
为了排除长度为0的字符串，我们付出的代价是现在要使用6个捕获分组来匹配该路
径的3种不同组成部分。现在有必要检查一下你使用这个正则表达式的具体情形，来
判断是在使用该正则式之前额外检查空字符串容易，还是多花点儿时间在一个匹配找
到之后处理多个捕获分组更容易。
如果使用的是.NET正则流派，那么你可以赋给多个命名分组同样的名称。.NET是唯一
把多个相同命名的分组当作一个捕获分组来使用的正则流派。有了.NET中的这个正则
式，你就可以获得文件夹或文件分组的匹配，而不用担心是这2个文件夹分组或3个
文件分组中的哪一个实际上参与了正则匹配：
\A
:)
(?[a-z]:1\\\\[a-z0-9_.$]+\\[a-z0-9_.$]+)\
(?(?:[^\\/:*?"<>|\r\n]+\\) *)
(?[\\/:*?"<>1\r\n]*)
1(?\\?(?：[\\/:*?"<>|\r\n]+\\)+)
(?[\\/:*?"<>|\r\n] *)
(?[^\\/:*?"<>1\r\n] +)
)
URL、路径和Internet地址
385
www.TopSage.com
---
## Page 402
正则选项：宽松排列、不区分大小写
正则流派：.NET
参见
实例2.9、实例2.11、实例3.9和实例7.18。
7.20从Windows路径中抽取盘符
问题描述
你有一个学符事，其中包含了一个指向WindowsPC或网络上的文件或文件夹的（语法
上）合法的路径。你想要从路径中抽取其中的盘符（如果存在)。例如，你想要从路径
c:folder\file.ext中抽取盘符c。
解决方案
^([a=z]):
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
从已知包含合法路径的字符事中抽取盘符是很简单的，即使你不知道该路径实际上是
否会以盘符作为开始。路径也可以是一个相对路径或者UNC路径。
在Windows路径中，冒号只能用来作为盘符的分隔符，否则就是不合法的字符。因此，
如集在字符事的并始包含一个字母后面跟着冒号，那么我们就可以确定该字母是一个
盘符。
定位符（会匹配字符事的开始（实例2.5）。在Ruby中，虽然脱字符同样可以匹配内
嵌的换行，但是这也不会带来问题，因为在合法的Windows路径中不会包含换行。字
符类[a-z)会被用来匹配单个字母（实例2.3)。我们把字符类放到一对圆括号之间（这
样会构成一个捕获分组），因此你可以只得到盘符，而不会把正则表达式也匹配到的字
面冒号包含进来。我们把冒号添加到正则表达式是为了确保我们抽取的是盘符，而不
是某个相对路径中的第一个字母。
参见
实例2.9会告诉你关于捕获分组的一切。
要了解如何在你喜欢的编程语言中获取捕获分组匹配到的文本，请参考实例3.9。
如果你事先不能确定字符串中是否包含了合法的Windows路径，那么需要先按照实
386第7章
www.TopSage.com
---
## Page 403
例7.19进行判断。
7.21从UNC路径中抽取服务器和共享名
问题描述
你有一个字符串，其中包含了一个指向WindowsPC或网络上的文件或文件夹的（语法
上）合法的路径。如果该路径是-个UNC路径，那么你想要从其中抽取网络服务器的
名称和该路径在服务器上指向的共享名。例如，你想要从路径\lserver\share\folderlfile.ext
中抽取出server和share。
解决方案
\\([a-z0-9_.$]+)\\（[a-z0-9_.$]+)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
从已知包含合法路径的字符串中抽取网络服务器和共享名称是很简单的，即使你不知
道该路径实际上是一个UNC路径。路径也可以是-一个相对路径或署使用盘符。
UNC路径会以两个反斜杠作为开始。在Windows路径中，两个连续的反斜杠只能用来
作为UNC路径的开始，否则一定是不允许的。因此，如果一个已知是合法的路径以两
个反斜杠作为开始，那么我们就可以确定之后跟着的是服务器和共享名称。
定位符（>会匹配字符串的开始（实例2.5)。在Ruby中，虽然脱字符同样可以匹配内
嵌的换行，但是这也不会带来问题，因为在合法的Windows路径中不会包含换行。ll)
会匹配两个字面的反斜杠。因为在正则表达式中反斜杠是元字符，因此如果我们想要
把它作为字面字符来匹配，就必须使用另外一个反斜杠对它进行转义。其中的第一个
字符类会匹配网络服务器的名称。而在另外一个字面反斜杠之后的第二
个字符类则会匹配共享名称。我们把两个字符类分别放到一对圆括号之间，这样就会
构成一个捕获分组。使用这种方式，你可以从第一个捕获分组中获得服务器名称，而
在第二个捕获分组中获得共享名称。总的正则匹配将会是\server\share。
参见
实例2.9会告诉你关于捕获分组的一切。
要了解如何在你喜欢的编程语言中获取捕获分组匹配到的文本，请参考实例3.9。
如果你事先不能确定字符串中是否包含了合法的Windows路径，那么需要先按照实
例7.19进行判断。
URL、路径和Internet地址387
www.TopSage.com
---
## Page 404
7.22从Windows路径中抽取文件夹
问题描述
你有一个字符事，其中包含了一个指向WindowsPC或网络上的文件或文件夹的（语法
上）合法的路径，你想要从路径中抽取其中的文件夹。例如，你想要从路径
c:\folderlsubfolderifile.ext或者\serverlshare\folderlsubfolder\file.ext中抽取出其中的
folder\subfolder\。
解决方案
([a-z]:[\\[a-z0-9_.$]+\\[a-z0-9_.$]+)？((？:\1)
(?:[^\\/:*?"<>|\r\n]+\\) +)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
如果我们想要支持UNC路径，那么从一个Windows路径中抽取文件夹就会有些复杂，
因为我们无法简单从反斜杠之间抓取路径中的组成部分。如果这样做，就会同时抓取
到UNC中的服务器和共享名称。
正则式的第-个部分（^([a-z]:/\1\[a-z0-9_.$]+\\[a-z0-9_.$]+)？）会略过位于路径开始
的盘符或网络服务器与网络共享名称。这部分正则式中包含一个带2个选择分支的
捕获分组。第一个选择分支会匹配盘符（参考实例7.20），而第二个选择分支会匹