到这里，已经分析清楚漏洞数据的传递过程。接下来的问题是，类型混淆究竟是如何发生的？到底是什么和什么之间产生了类型混淆？
既然上面怀疑漏洞是标签没有正常闭合导致，现在就来构造一个带的正常样本，方法很简单，创建一个新的docx文档，随便写入一些数据，保存后将后缀名改为.zip，用压缩软件将原文档中的document.xml替换为增加了的漏洞文件，如下图：
打开后文件果然没有崩溃，看来就是这个问题导致的。接下来在windbg里面打开修复后的文档，再下一遍上面的断点，对比正常文档和漏洞文档调试输出的不同处。
首先对比两个文档在解析各标签时的公式计算结果，由下图对比发现两者在解析idmap时的level级别不同，正常文档解析idmap的level级别是5，而漏洞文档为6：
再检查两个文档在传递漏洞数据时的不同，windbg打开正常文档，对崩溃函数首部下断点。在解析到OLEObject标签时，用一样的公式计算出地址，并对该地址设定内存写入断点，发现正常文档在漏洞触发点前的某个地方再次触发了内存写入断点，而前面调试漏洞文档时并没有在此处触发该断点，如下：
发现该处地址位于漏洞函数内，在IDA的反汇编视图中看到该处正位于崩溃点之前：
进一步调试发现sub_3127F3FB(基址调为0后为sub_3F3FB)函数内部也调用了计算地址的sub_9DA0函数。有意思的是，和上图相比，这里调用时对同一个值减去了1，而上图中可以看到崩溃点是减2，且该值正是当前解析标签的level值。正常情况下，当解析OLEObject标签时，level_OLEObject
= 4，level_idmap =
5，解析OLEObject时在上图中的修改点将4-1=3对应的值设定到指定地址处，在解析idmap时，崩溃点拿到的是5-2=3对应的值，这正是它的父标签OLEObject设定的值；而在漏洞触发时，解析OLEObject时同样将4-1=3对应的值设定到指定地址处，但在解析idmap时，崩溃点拿到的是6-2=4对应的值，那么4对应的值是谁设置的呢？应该是level_5对应的标签设置的，而level_5对应的标签正是font，在父函数对font的解析逻辑里也调用了sub_9DA0对5-1=4处的地址进行了设定，此过程还读入了font的name属性对应的数据。
在没有闭合标签的情况下，在解析完font后索引值并没有减1，导致idmap在解析时，理应获取OLEObject设置的数据，却获取了font设置的数据，在后面解析数据时，用OLEObject对应的数据结构解析了font所提供的数据，从而造成类型混淆。只要精心构造font所提供的数据，就可以劫持特定的函数指针，达到控制执行流的目的。
**  
**
**利用编写**
****
分析到这里，已经知道了漏洞的触发原理，下面尝试构造一个exploit，使用这个漏洞弹出一个计算器。
由于该漏洞的利用方式和CVE-2015-1641及CVE-2016-7193非常像，所以如果构造过前两个漏洞的exp的话，构造这个漏洞的exp几乎不需要多少时间。
**步骤如下：**
1\. 写一段Python脚本修改原有的axtiveX1.bin文件，构造所需要的rop-gadgets和弹计算器的shellcode;
2\. 再写一段Python脚本，利用生成的axtiveX1.bin文件作为输入生成堆喷射docx文档;
3\. 用压缩软件打开生成的堆喷射docx文件，将里面的activeX1.bin手动删除，再手动放入，目的是为了减小文档体积(可以显著减小体积);
4\. 新建一个空白rtf文档，将3中生成的堆喷射docx手动拖入文档内，保存;
5\. 用notepad++打开4中生成的rtf文档，提取出{object…}闭合的部分;
6\. 将bypass-aslr所需用到的内容拷贝到新的rtf文档中，原始样本加载的是一个新的模块，我这里为了实验直接用了otkloadr.WRAssembly，具体步骤也可参照维一零的文章;
7\. 从原文档中提取出漏洞触发的部分，和5中类似;
8\. 新建一个文本文档，按堆喷射在前、加载bypass aslr模块在中，漏洞触发在后的顺序构造exp文件，保存成一个rtf文档;
整个利用布局如下：
将构造好的exp在调试环境下打开，可以顺利弹出计算器（如果不想看到crash，可以把shellcode编写得优雅点）
这里给出一下生成activeX.bin的脚本和替换activeX控件的Python脚本：
**动态检测**
****
由上面的分析可知，该漏洞是个典型的类型混淆漏洞，所以合理的检测方案是比较正确的指针和混淆后的指针。在崩溃函数写入对象指针的位置做一个拦截，在解析标签等于"OLEObject"的时候，保存v15的值，即eax的值，供后面对比使用：
在混淆前的sub_9DA0(即上图中的sub_31249DA0，上图中的基址没有设为0)函数调用完成后也做一个拦截，取sub_9DA0函数的返回值，也即eax，将这个值与上面的值做比较，如果两者不同，则说明触发了漏洞。
**结语**
****
整个分析来看，这是一个典型的 **类型混淆漏洞** ，无论在漏洞原理上还是利用方式上都 **堪称CVE-2015-1641的姊妹漏洞**
，如果在原样本中将劫持地址和堆喷地址由0x88888f0稍微调高一点，利用的稳定性就会好很多。
**该漏洞触发非常稳定，可能会在不久的将来取代CVE-2015-1641，成为下一个被滥用的漏洞，需要引起高度警惕** 。
**致谢**
****
特别感谢《CVE-2017-11826 样本分析》这篇文章。
PS. 原始样本在利用成功后释放Payload以达到持久驻存的方式用到了《Persisting with Microsoft Office:Abusing
Extensibility Options》这篇paper里面讲到的方法。
**参考链接**
《最新Office
0day漏洞(CVE-2017-11826)在野攻击通告》[http://blogs.360.cn/blog/office_0day_cve-2017-11826_ch/](http://blogs.360.cn/blog/office_0day_cve-2017-11826_ch/)
《CVE-2017-11826 样本分析》
[https://bbs.pediy.com/thread-221995.htm](https://bbs.pediy.com/thread-221995.htm)
《结合一个野外样本构造一个cve-2016-7193弹计算器的利用》[https://bbs.pediy.com/thread-221792.htm](https://bbs.pediy.com/thread-221792.htm)
《the-curious-case-of-the-document-exploiting-an-unknown-vulnerability-part-1》
[http://blog.fortinet.com/2015/08/20/the-curious-case-of-the-document-exploiting-an-unknown-vulnerability-part-1](http://blog.fortinet.com/2015/08/20/the-curious-case-of-the-document-exploiting-an-unknown-vulnerability-part-1)
《Spraying the heap in seconds using ActiveX controls in Microsoft Office》
[https://www.greyhathacker.net/?p=911](https://www.greyhathacker.net/?p=911)
《Bypassing Windows ASLR in Microsoft Office using ActiveX controls》
[https://www.greyhathacker.net/?p=894](https://www.greyhathacker.net/?p=894)
《手把手教你如何构造office漏洞EXP（第四期）》[http://bobao.360.cn/learning/detail/3246.html](http://bobao.360.cn/learning/detail/3246.html)
《Attacking Interoperability》
[https://www.blackhat.com/docs/us-15/materials/us-15-Li-Attacking-Interoperability-An-OLE-Edition.pdf](https://www.blackhat.com/docs/us-15/materials/us-15-Li-Attacking-Interoperability-An-OLE-Edition.pdf)
《Persisting with Microsoft Office:Abusing Extensibility
Options》