### 一、前言
我们在前文讲述了许多区块链这几年发展演进过来的共识机制。在之前的内容中，我们讲述的共识多属于区块链1.o与2.0的知识。这次，我们着重讲述下区块链3.0时代的HyperLedger
Fabric中的共识机制以及相关特性。而今，比特币与以太坊多用于币圈的应用，然而根据行业的发现现状来看，超级账本的未来发展更倾向于商业落地项目，所以对这类机制的深入研究对我们后续的发展大有裨益。
Fabric是Hyperledger项目组的一个项目。从区块链的演进过程中看，Fabric属于区块链3.0的技术范畴内。但是其用时具有区块链1.0与2.0系统的特性，比如其可以共享账本、具有智能合约，可以通过共识算法确保数据的安全。但是作为一个典型的区块链3.0技术平台，Fabric中存在和其他区块链不同的技术来保证更适合项目的落地。
### 二、Fabric共识机制
在Fabric中不同的会员发起的交易是按照一定的顺序写入区块链中的，区块链之间连接起来之后形成区块链。在交易排序的过程中需要防止恶意篡改。对于比特币而已，其采用了Pow，并解决了这个问题。而对于Fabric而言，它支持Solo（单节点共识）、Kafka（分布式队列）以及SBFT（简单拜占庭容错）三种共识方式。而前两种已经被应用于Fabric中，第三种会在未来被应用实践。
在Fabric中，共识过程意味着多个Peer节点对于某一批交易的发生顺序、合法性以及它们对账本状态的更新达成一致的观点。
要想真正的了解Fabric共识是如何协作的，我们就要了解其中各个组成部分。在Fabric中，共识是通过 **背书、排序和验证** 三个环节的保障。
**背书过程** ：背书节点对收到的来自客户端的请求（交易提案）按照自身的逻辑进行检查，以决策是否予以支持的过程。
对于调用某个链码的交易来讲，它需要获得一定条件的背书才被认为合法。例如，必须是来自某些特定身份成员的一致同意；或者某个组织中超过一定数目的成员的支持等等；这些背书策略可以由链码在实例化之前来指定。
**排序过程** ：对一段时间内的一批交易达成一个网络内全局一致的顺序。  
Fabric中，采用可插拔式的架构，solo模式、Kafka在内的CFT类型后端、BFT类型后端。
**验证过程** ：对排序后的一批交易进行提交到账本之前最终检查的过程。  
验证过程包括验证交易结构自身完整性，背书签名是否满足背书策略，交易的读写集是否满足多版本并发控制等。
而其中最重要的当属排序服务
。在Fabric中所有交易在交付给Committer进行验证接受之前，需要先经过排序服务进行全局排序。排序服务提供了原子广播排序功能。
只有经过了排序，各个交易才有其顺序，任务才能被合理的执行。
#### 1 Solo模式
Solo方法是指在单个节点中完成的排序算法，这种模式的安全性和稳定性都比较差，如果单点出现问题，那么整个区块链系统将无法正常运行。因此Solo也就是被用在演示系统与本机开发中。
Solo机制是一个非常容易部署的非生产环境的共识排序节点。它只有一个客户服务端单节点，所以不需要进行“共识”。因为其有中央权威机构，所以相应的其并不具备高可用性或可扩展性。order-solo模式作为单节点通信模式，所有从peer收到的消息都在本节点进行排序与生成数据块。
#### 2 Kafka模式
Kafka是一种高吞吐的分布式发布订阅消息系统。在Fabric的Kafka模式中，排序节点从kafka集群中获取了相应的topic数据，用以保证交易的有序性。借助Kafka的特性，排序节点还可以进行集群化处理，能够有效的避免单点因故障而导致整个网络的崩溃问题。具体来说，其是一种支持多通道分区的集群时序服务，可以容忍部分节点失效（crash），但不能容忍恶意节点，其基于zookeeper进行Paxos算法选举，支持2f+1节点集群，f代表失效节点个数。即kafka可以容忍少于半数的共识节点失效。
具体过程分为以下两步，①在任务下发后，节点向endorser节点发送背书请求。节点针对身份、签名和读写集的验证后标记其为正确信息。而背书节点会预先执行一遍相关任务，包括验证任务是否合法，模拟任务执行后的结果等。之后我们进入第二步。②之后任务会下发到orderer节点中，而在单节点的solo中，此orderer只有一个，所以不涉及集群的协作排序。但是kafka中涉及到了多个orderer节点，所以其核心作用就是将全局的tx（通过背书请求后的）作为输入，在集群内形成统一的、唯一的、确定的、经过排序的tx输出。
具体的内容可以参考[Kafka共识机制剖析](https://cloud.tencent.com/developer/news/306930)
### 三、Fabric技术详情
#### 1 账本特性
在Fabric诞生之前的区块链平台均只有一个账本，所有的记录均在一个账本中。这存在许多弊端，例如这会导致这个账本存储量十分巨大，例如现在的比特币账本已经有160G。随着时间的推移，这种设计是有很大的问题的。在Fabric中，我们又私有链、联盟链与公有链。对于公有链而言，其弊端与比特币系统一致，但是对于其他链的模式而言，Fabric采用了多账本的设计模式。
在Fabric中有通道的概念。而一个通道包含若干成员，这些成员共享同一个账本并且共享账本数据以及维护账本。对于不同的通道，其账本的数据格式是不同的。在Fabric中，账本的存储方式被设计成插件的模式，不同的会员可以根据情况选择不同的存储方式。
其有如下特点：
  * 1 使用了键值对查询，包括范围查询以及复合键查询来更新账本。
  * 2 使用丰富的查询语句（CouchDB）。
  * 3 拥有只读的历史查询——实现数据追溯。
  * 4 交易被打包排序成区块，并通过通道从共识节点传递至对等节点。然后包含背书节点，机器提交至排序节点进行签名。
  * 5 通道包含了会员服务提供商，因此加密证书能传递到不同的证书颁发机构。
#### 2 Fabric 智能合约
Fabric中的智能合约被称为链码（Chaincode），而Chaincode是一段使用计算机语言编写的程序。其运行在容器中，Fabric通过调用链码来读取和修改账本的数据，同时将交易的日志保存在状态数据库。其可以使用Go、java、node.js进行开发。
下面向读者展示下使用GO语言所编写的链码。
    GO的包的引入
    package main
    import (
    //"bytes"
    "encoding/json"
    "fmt"
    "strconv"
    //"strings"
    "github.com/hyperledger/fabric/core/chaincode/shim"
    pb "github.com/hyperledger/fabric/protos/peer"
    "time"
    )
    这些是经常用的包
    Main
    main是入口
    // SimpleChaincode example simple Chaincode implementation
    type SimpleChaincode struct {
    }
    // ===================================================================================
    // Main
    // ===================================================================================
    func main() {
    err := shim.Start(new(SimpleChaincode))
    if err != nil {
    fmt.Printf("Error starting Simple chaincode: %s", err)
    }
    }
    Init
    chaincode 包含一个Init和一个Invoke函数。
    Init是初始化的地方，还需要注意以后版本升级时能够通用