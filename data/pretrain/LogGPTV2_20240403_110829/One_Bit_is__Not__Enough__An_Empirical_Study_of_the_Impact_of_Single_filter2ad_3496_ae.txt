1.2%
0.6%
14.6%
25.6%
23.6%
48.1%
3.1%
0.0%
7.7%
10.7%
5.2%
2.9%
1.1%
Tran. I
0.6%
0.4%
0.1%
0.9%
0.8%
4.1%
3.6%
0.6%
0.2%
2.2%
0.2%
0.8%
0.2%
14.9%
0.1%
Tran. II
58.3%
29.5%
4.1%
0.8%
34.6%
23.4%
26.0%
81.8%
2.9%
0.0%
15.7%
19.2%
19.6%
2.1%
1.5%
especially with the inject-on-read technique. Therefore, we
can prune the multiple bit-ﬂip error space by excluding those
locations that would result in the Detection category or an
SDC under the single bit-ﬂip model. In fact according to the
results presented in Fig. 1, these locations include around 50-
100% of the inject-on-read and 27-100% of the inject-on-write
single bit-ﬂip experiments, which is a signiﬁcant reduction in
the error space. However, there is much more variation when
it comes to the likelihood of Transition II, and its value ranges
from 0% to 81%, and hence these locations cannot be ignored.
RQ5-Answer: We can prune the multiple bit-ﬂip error space by
injecting the ﬁrst error of each experiment only into locations
that if targeted by a single bit-ﬂip error they would result in
Benign outcomes, as these are the locations that would add to
the number of SDCs under multiple bit-ﬂips.
V. SUMMARY AND IMPLICATIONS
Our goal was to study the impact of multiple-bit errors in
programs and to ﬁnd ways to reduce the multiple-bit fault
injection space (error space). This is important as previous
studies [4], [5], [6] have shown that soft errors often manifest
as multiple-bit errors at the software level, and hence we need
efﬁcient methods to inject multiple-bit errors in software and
evaluate their effects. Prior work had considered at most two
bit-ﬂips, and did not cover the entire space of multiple-bit er-
rors. We performed a comprehensive analysis of the parameter
space of multiple bit-ﬂips to identify which parameters affect
the SDCs for a program. Our ﬁndings are:
with a few exceptions. This holds regardless of whether
the multiple-bit injections are in the same register or in
different registers.
• With that said, the single bit-ﬂip model is not sufﬁcient to
establish conservative upper bounds on the SDC results
(i.e., pessimistic percentages of SDCs) under multiple-
bit errors. However, for most programs, the pessimistic
percentage of SDCs for the multiple-bit error model is
achieved under relatively few multiple-bit errors (2 errors
with the inject-on-read technique, and 3 errors with the
inject-on-write technique).
• The dynamic window size parameter value does not
matter much when the inject-on-read technique is used,
but it matters when the inject-on-write technique is used.
In the latter case, the highest percentage of SDCs is
achieved when the window size is low, i.e., less than 5
dynamic instructions in most cases.
• Only a very small fraction of single bit-ﬂip errors that
result in Detection lead to SDCs under multiple bit-ﬂips
in which the starting location is the same as the single
bit-ﬂip error. Therefore, to maximize the SDCs uncovered
by multiple bit-ﬂip injections, one needs to inject only
into the program locations in which single bit-ﬂip error
injections led to benign outcomes.
Taken together, these results suggest that the multiple bit-
ﬂip error space can be considerably pruned if one is interested
in obtaining conservative upper-bounds on SDCs. In fact, in
many cases, the single bit-ﬂip fault injection results already
give reasonably close SDC results to the multiple bit-ﬂip
injection results. If more accuracy is needed, then injecting a
small number of multiple bit-ﬂip errors (at most 3) is sufﬁcient.
Furthermore, the multiple fault injections need to be only a few
(dynamic) instructions apart, to get conservative upper bounds
on the percentage of SDCs. This further helps to prune the
error space. Finally, we can leverage the results from the single
bit-ﬂip fault injections to choose the locations for multiple bit-
ﬂip injections to get conservative SDC results.
In summary, we can conclude that multiple bit-ﬂip errors do
not cause as much difference in the SDC results of experiments
conducted using single bit-ﬂip errors as some researchers have
speculated [4]. Therefore, the single bit-ﬂip fault model may
be sufﬁcient for evaluating the coverage of error resilience
techniques in most cases. If more accuracy is desired, we need
to only consider a limited range of multiple bit-ﬂip errors,
which lead to only a modest increase in the error space.
Take-away: The single bit-ﬂip model continues to be a valid
approximation for resilience studies, albeit with the above
caveats, and hence one bit is often enough.
• The SDC results of the single bit-ﬂip model are close
to the results for the multiple bit-ﬂip model (except for
2% of multiple bit-ﬂip campaigns which result in more
than 5 percentage points of higher percentage of SDCs)
across the majority of programs and parameter values,
As future work, we plan to extend this study to multiple-bit
faults in memory (that are not detected by ECC), as well as
consider larger applications. Another potential direction is to
consider speciﬁc fault tolerance techniques, and measure their
coverage with the single and multiple-bit fault models.
ACKNOWLEDGMENT
This work was supported in part by the Natural Sciences
and Engineering Research Council of Canada (NSERC), the
Canada Foundation for Innovation (CFI),
the EU funded
HiPEAC (High Performance and Embedded Architectures and
Compilers) Network of Excellence and the Ericsson Research
Foundation. We thank Risat Mahmud Pathan, the members
of the Dependable Systems Lab at UBC, and the anonymous
reviewers of the DSN 2017 conference for their comments,
which have helped us to improve this paper.
REFERENCES
[1] S. Borkar, “Designing reliable systems from unreliable components:
the challenges of transistor variability and degradation,” IEEE Micro,
vol. 25, no. 6, pp. 10–16, 2005.
[2] G. A. Reis, J. Chang, N. Vachharajani, R. Rangan, and D. I. August,
“SWIFT: Software implemented fault tolerance,” in Proceedings of the
3rd International Symposium on Code Generation and Optimization, ser.
CGO ’05.
IEEE Computer Society, 2005, pp. 243–254.
[3] M. Rebaudengo, M. S. Reorda, and M. Violante, “A new approach to
software-implemented fault tolerance,” Journal of Electronic Testing,
vol. 20, no. 4, pp. 433–437, 2004.
[4] H. Cho, S. Mirkhani, C.-Y. Cher, J. A. Abraham, and S. Mitra,
“Quantitative evaluation of soft error injection techniques for robust
system design,” in Proceedings of the 50th ACM/EDAC/IEEE Design
Automation Conference, ser. DAC ’13. ACM, 2013, pp. 1–10.
[5] G. A. Kanawati, N. A. Kanawati, and J. A. Abraham, “EMAX: An
automatic extractor of high-level error models,” in Proceedings of the
9th AIAA Computing in Aerospace Conference, 1993, pp. 1297–1306.
[6] J. F. Ziegler et al., “IBM experiments in soft fails in computer electronics
(1978-1994),” IBM Journal of Research and Development, vol. 40, no. 1,
pp. 3–18, 1996.
[7] W. G. Bouricius, W. C. Carter, and P. R. Schneider, “Reliability modeling
techniques for self-repairing computer systems,” in Proceedings of the
24th National Conference, ser. ACM ’69. ACM, 1969, pp. 295–309.
[8] T. F. Arnold, “The concept of coverage and its effect on the reliability
model of a repairable system,” IEEE Transactions on Computers, vol.
C-22, no. 3, pp. 251–254, 1973.
[9] B. Fang, Q. Lu, K. Pattabiraman, M. Ripeanu, and S. Gurumurthi,
“ePVF: An enhanced program vulnerability factor methodology for
cross-layer resilience analysis,” in 46th Annual IEEE/IFIP International
Conference on Dependable Systems and Networks (DSN), 2016, pp.
168–179.
[10] Q. Lu, M. Farahani, J. Wei, A. Thomas, and K. Pattabiraman, “LLFI:
An intermediate code-level fault injection tool for hardware faults,” in
2015 IEEE International Conference on Software Quality, Reliability
and Security, 2015, pp. 11–16.
[11] F. Ayatolahi, B. Sangchoolie, R. Johansson, and J. Karlsson, “A study
of the impact of single bit-ﬂip and double bit-ﬂip errors on program
execution,” in Proceedings of the 32nd International Conference on
Computer Safety, Reliability, and Security, ser. SAFECOMP 2013.
Springer-Verlag New York, Inc., 2013, pp. 265–276.
[12] F. Adamu-Fika and A. Jhumka, “An investigation of the impact of double
bit-ﬂip error variants on program execution,” in Proceedings of the 15th
International Conference on Algorithms and Architectures for Parallel
Processing. Springer International Publishing, 2015, pp. 799–813.
[13] E. Touloupis, J. A. F. Member, V. A. Chouliaras, and D. D. Ward,
“Study of the effects of SEU-induced faults on a pipeline protected
microprocessor,” IEEE Transactions on Computers, vol. 56, no. 12, pp.
1585–1596, 2007.
[14] S. K. S. Hari, S. V. Adve, H. Naeimi, and P. Ramachandran, “Relyzer:
Exploiting application-level fault equivalence to analyze application
resiliency to transient faults,” in Proceedings of the 17th International
Conference on Architectural Support for Programming Languages and
Operating Systems, ser. ASPLOS XVII. ACM, 2012, pp. 123–134.
[15] R. Venkatagiri, A. Mahmoud, S. K. S. Hari, and S. V. Adve, “Approxi-
lyzer: Towards a systematic framework for instruction-level approximate
computing and its application to hardware resiliency,” in 49th Annual
IEEE/ACM International Symposium on Microarchitecture (MICRO),
2016, pp. 1–14.
[16] R. Barbosa, J. Vinter, P. Folkesson, and J. Karlsson, “Assembly-level pre-
injection analysis for improving fault injection efﬁciency,” in Proceed-
ings of the 5th European Dependable Computing Conference. Springer
Berlin Heidelberg, 2005, pp. 246–262.
[17] C. Lattner and V. Adve, “LLVM: A compilation framework for lifelong
program analysis & transformation,” in Proceedings of the International
Symposium on Code Generation and Optimization, ser. CGO ’04.
IEEE
Computer Society, 2004, pp. 75–86.
[18] W. Gu, Z. Kalbarczyk, and R. K. Iyer, “Error sensitivity of the linux
kernel executing on PowerPC G4 and Pentium 4 processors,” in 2004
IEEE/IFIP International Conference on Dependable Systems and Net-
works, 2004, pp. 887–896.
[19] D. Skarin, R. Barbosa, and J. Karlsson, “GOOFI-2: A tool for ex-
perimental dependability assessment,” in 2010 IEEE/IFIP International
Conference on Dependable Systems Networks, 2010, pp. 557–562.
[20] M. de Kruijf, S. Nomura, and K. Sankaralingam, “Relax: An ar-
chitectural framework for software recovery of hardware faults,” in
Proceedings of the 37th Annual International Symposium on Computer
Architecture, ser. ISCA ’10. ACM, 2010, pp. 497–508.
[21] S. Feng, S. Gupta, A. Ansari, and S. Mahlke, “Shoestring: Probabilistic
soft error reliability on the cheap,” in Proceedings of the 15th Interna-
tional Conference on Architectural Support for Programming Languages
and Operating Systems, ser. ASPLOS XV. ACM, 2010, pp. 385–396.
[22] D. S. Khudia and S. Mahlke, “Harnessing soft computations for low-
budget fault tolerance,” in Proceedings of the 47th Annual IEEE/ACM
International Symposium on Microarchitecture, ser. MICRO-47.
IEEE
Computer Society, 2014, pp. 319–330.
[23] B. Sangchoolie, F. Ayatolahi, R. Johansson, and J. Karlsson, “A compar-
ison of inject-on-read and inject-on-write in ISA-level fault injection,” in
11th European Dependable Computing Conference, 2015, pp. 178–189.
[24] A. Thomas and K. Pattabiraman, “LLFI: An intermediate code level
fault injector for soft computing applications,” in Workshop on Silicon
Errors in Logic System Effects (SELSE), 2013.
[25] J. Pan, “The dimensionality of failures - a fault model for characterizing
software robustness,” in Proceedings of the International Symposium on
Fault-Tolerant Computing, 1999.
[26] J. Pan, P. Koopman, and D. Siewiorek, “A dimensionality model
approach to testing and improving software robustness,” in Proceedings
of the 1999 IEEE AUTOTESTCON, 1999, pp. 493–501.
[27] L. Rashid, K. Pattabiraman, and S. Gopalakrishnan, “Characterizing the
impact of intermittent hardware faults on programs,” IEEE Transactions
on Reliability, vol. 64, no. 1, pp. 297–310, 2015.
[28] H. Madeira and J. G. Silva, “Experimental evaluation of the fail-silent
behavior in computers without error masking,” in Proceedings of the
24th IEEE International Symposium on Fault-Tolerant Computing, 1994,
pp. 350–359.
[29] P. Yuste, J. C. Ruiz, L. Lemus, and P. Gil, “Non-intrusive software-
implemented fault injection in embedded systems,” in Proceedings of the
1st Latin-American Symposium on Dependable Computing.
Springer
Berlin Heidelberg, 2003, pp. 23–38.
[30] H. Schirmeier, M. Hoffmann, R. Kapitza, D. Lohmann, and O. Spinczyk,
“Fail*: Towards a versatile fault-injection experiment framework,” in
ARCS Workshops, 2012, pp. 1–5.
[31] H. Schirmeier, C. Borchert, and O. Spinczyk, “Avoiding pitfalls in fault-
injection based comparison of program susceptibility to soft errors,”
in 45th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks, 2015, pp. 319–330.
[32] P. Racunas, K. Constantinides, S. Manne, and S. S. Mukherjee,
“Perturbation-based fault screening,” in Proceedings of the 13th IEEE
International Symposium on High Performance Computer Architecture,
ser. HPCA ’07.
IEEE Computer Society, 2007, pp. 169–180.
[33] M. R. Guthaus, J. S. Ringenberg, D. Ernst, T. M. Austin, T. Mudge, and
R. B. Brown, “MiBench: A free, commercially representative embedded
benchmark suite,” in Proceedings of the 4th Annual IEEE International
Workshop on Workload Characterization, ser. WWC-4, 2001, pp. 3–14.
[34] J. A. Stratton, C. Rodrigues, I.-J. Sung, N. Obeid, L.-W. Chang,
N. Anssari, G. D. Liu, and W.-m. W. Hwu, “Parboil: A revised
benchmark suite for scientiﬁc and commercial throughput computing,”
Center for Reliable and High-Performance Computing, vol. 127, 2012.