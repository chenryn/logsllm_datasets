### 基于事件的程序设计: GUI、Web事件驱动的好处是占用资源少，效率高，可扩展性强，是支持高性能高并发的不二之选。如果你熟悉 GUI 编程的话，你就会知道，GUI 设定了一系列的控件，如Button、Label、文本框等，当我们设计基于控件的程序时，一般都会给 Button的点击安排一个函数，类似这样：    // 按钮点击的事件处理void onButtonClick(){  }这个设计的思想是，一个无限循环的事件分发线程在后台运行，一旦用户在界面上产生了某种操作，例如点击了某个Button，或者点击了某个文本框，一个事件会被产生并放置到事件队列中，这个事件会有一个类似前面的onButtonClick回调函数。事件分发线程的任务，就是为每个发生的事件找到对应的事件回调函数并执行它。这样，一个基于事件驱动的GUI 程序就可以完美地工作了。``{=html}还有一个类似的例子是 Web 编程领域。同样的，Web 程序会在 Web界面上放置各种界面元素，例如 Label、文本框、按钮等，和 GUI程序类似，给感兴趣的界面元素设计 JavaScript回调函数，当用户操作时，对应的 JavaScript回调函数会被执行，完成某个计算或操作。这样，一个基于事件驱动的 Web程序就可以在浏览器中完美地工作了。在第 24 讲中，我们已经提到，通过使用 poll、epoll 等 I/O分发技术，可以设计出基于套接字的事件驱动程序，从而满足高性能、高并发的需求。事件驱动模型，也被叫做反应堆模型（reactor），或者是 Event loop模型。这个模型的核心有两点。第一，它存在一个无限循环的事件分发线程，或者叫做 reactor 线程、Eventloop 线程。这个事件分发线程的背后，就是 poll、epoll 等 I/O分发技术的使用。第二，所有的 I/O操作都可以抽象成事件，每个事件必须有回调函数来处理。acceptor上有连接建立成功、已连接套接字上发送缓冲区空出可以写、通信管道 pipe上有数据可以读，这些都是一个个事件，通过事件分发，这些事件都可以一一被检测，并调用对应的回调函数加以处理。
## 几种 I/O 模型和线程模型设计任何一个网络程序，所做的事情可以总结成下面几种：-   read：从套接字收取数据；-   decode：对收到的数据进行解析；-   compute：根据解析之后的内容，进行计算和处理；-   encode：将处理之后的结果，按照约定的格式进行编码；-   send：最后，通过套接字把结果发送出去。这几个过程和套接字最相关的是 read 和 send这两种。接下来，我们总结一下已经学过的几种支持多并发的网络编程技术，引出我们今天的话题，使用poll 单线程处理所有 I/O。
### fork第 25 讲中，我们使用 fork来创建子进程，为每个到达的客户连接服务。文稿中的这张图很好地解释了这个设计模式，可想而知的是，随着客户数的变多，fork的子进程也越来越多，即使客户和服务器之间的交互比较少，这样的子进程也不能被销毁，一直需要存在。使用fork 的方式处理非常简单，它的缺点是处理效率不高，fork 子进程的开销太大。![](Images/b2ad4388320db83983087486737f6268.png){savepage-src="https://static001.geekbang.org/resource/image/f1/1c/f1045858bc79c5064903c25c6388051c.png"}
### pthread第 26 讲中，我们使用了 pthread_create创建子线程，因为线程是比进程更轻量级的执行单位，所以它的效率相比 fork的方式，有一定的提高。但是，每次创建一个线程的开销仍然是不小的，因此，引入了线程池的概念，预先创建出一个线程池，在每次新连接达到时，从线程池挑选出一个线程为之服务，很好地解决了线程创建的开销。但是，这个模式还是没有解决空闲连接占用资源的问题，如果一个连接在一定时间内没有数据交互，这个连接还是要占用一定的线程资源，直到这个连接消亡为止。![](Images/024376afe016dab4546df1aefc1cf665.png){savepage-src="https://static001.geekbang.org/resource/image/1c/2c/1c07131ab6ca03d3a5a9092ef20e0b2c.png"}
### single reactor thread前面讲到，事件驱动模式是解决高性能、高并发比较好的一种模式。为什么呢？因为这种模式是符合大规模生产的需求的。我们的生活中遍地都是类似的模式。比如你去咖啡店喝咖啡，你点了一杯咖啡在一旁喝着，服务员也不会管你，等你有续杯需求的时候，再去和服务员提（触发事件）,服务员满足了你的需求，你就继续可以喝着咖啡玩手机。整个柜台的服务方式就是一个事件驱动的方式。我在文稿中放了一张图解释了这一讲的设计模式。一个 reactor线程上同时负责分发 acceptor 的事件、已连接套接字的 I/O 事件。![](Images/a0a5e4d27c59460766b0ccca0c8cebae.png){savepage-src="https://static001.geekbang.org/resource/image/b8/33/b8627a1a1d32da4b55ac74d4f0230f33.png"}
### single reactor thread + worker threads但是上述的设计模式有一个问题，和 I/O事件处理相比，应用程序的业务逻辑处理是比较耗时的，比如 XML文件的解析、数据库记录的查找、文件资料的读取和传输、计算型工作的处理等，这些工作相对而言比较独立，它们会拖慢整个反应堆模式的执行效率。所以，将这些 decode、compute、enode型工作放置到另外的线程池中，和反应堆线程解耦，是一个比较明智的选择。我在文稿中放置了这样的一张图。反应堆线程只负责处理I/O相关的工作，业务逻辑相关的工作都被裁剪成一个一个的小任务，放到线程池里由空闲的线程来执行。当结果完成后，再交给反应堆线程，由反应堆线程通过套接字将结果发送出去。![](Images/8c51417d669d99ce281eda310a0899cc.png){savepage-src="https://static001.geekbang.org/resource/image/7e/23/7e4505bb75fef4a4bb945e6dc3040823.png"}
## 样例程序从今天开始，我们会接触到为本课程量身定制的网络编程框架。使用这个网络编程框架的样例程序已经放到文稿中：    #include #include "lib/common.h"#include "lib/event_loop.h"#include "lib/tcp_server.h" char rot13_char(char c) {    if ((c >= 'a' && c = 'A' && c = 'n' && c = 'N' && c name);    printf("%s", input->data);     struct buffer *output = buffer_new();    int size = buffer_readable_size(input);    for (int i = 0; i `{=html}![](Images/7478f8c085ba8258e5dfa879e26f2466.png){savepage-src="https://static001.geekbang.org/resource/image/92/2a/9269551b14c51dc9605f43d441c5a92a.png"}\我来解释一下这张图，我们的主反应堆线程一直在感知连接建立的事件，如果有连接成功建立，主反应堆线程通过accept方法获取已连接套接字，接下来会按照一定的算法选取一个从反应堆线程，并把已连接套接字加入到选择好的从反应堆线程中。主反应堆线程唯一的工作，就是调用 accept获取已连接套接字，以及将已连接套接字加入到从反应堆线程中。不过，这里还有一个小问题，主反应堆线程和从反应堆线程，是两个不同的线程，如何把已连接套接字加入到另外一个线程中呢？更令人沮丧的是，此时从反应堆线程或许处于事件分发的无限循环之中，在这种情况下应该怎么办呢？我在这里先卖个关子，这是高性能网络程序框架要解决的问题。在实战篇里，我将为这些问题一一解开答案。
## 主 - 从 reactor+worker threads 模式如果说主 - 从 reactor 模式解决了 I/O 分发的高效率问题，那么 work threads就解决了业务逻辑和 I/O分发之间的耦合问题。把这两个策略组装在一起，就是实战中普遍采用的模式。大名鼎鼎的Netty，就是把这种模式发挥到极致的一种实现。不过要注意 Netty 里面提到的worker 线程，其实就是我们这里说的从 reactor线程，并不是处理具体业务逻辑的 worker 线程。下面贴的一段代码就是常见的 Netty 初始化代码，这里 Boss Group 就是acceptor 主反应堆，workerGroup就是从反应堆。而处理业务逻辑的线程，通常都是通过使用 Netty的程序开发者进行设计和定制，一般来说，业务逻辑线程需要从 workerGroup线程中分离，以便支持更高的并发度。    public final class TelnetServer {    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8992" : "8023"));     public static void main(String[] args) throws Exception {        // 产生一个 reactor 线程，只负责 accetpor 的对应处理        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        // 产生一个 reactor 线程，负责处理已连接套接字的 I/O 事件分发        EventLoopGroup workerGroup = new NioEventLoopGroup(1);        try {           // 标准的 Netty 初始，通过 serverbootstrap 完成线程池、channel 以及对应的 handler 设置，注意这里讲 bossGroup 和 workerGroup 作为参数设置            ServerBootstrap b = new ServerBootstrap();            b.group(bossGroup, workerGroup)             .channel(NioServerSocketChannel.class)             .handler(new LoggingHandler(LogLevel.INFO))             .childHandler(new TelnetServerInitializer(sslCtx));             // 开启两个 reactor 线程无限循环处理            b.bind(PORT).sync().channel().closeFuture().sync();        } finally {            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        }    }}![](Images/45f574933ab56c1addacd9858ba644b5.png){savepage-src="https://static001.geekbang.org/resource/image/1e/b4/1e647269a5f51497bd5488b2a44444b4.png"}\这张图解释了主 - 从反应堆下加上 worker 线程池的处理模式。主 - 从反应堆跟上面介绍的做法是一样的。和上面不一样的是，这里将decode、compute、encode 等 CPU 密集型的工作从 I/O线程中拿走，这些工作交给 worker线程池来处理，而且这些工作拆分成了一个个子任务进行。encode之后完成的结果再由 sub-reactor 的 I/O 线程发送出去。
## 样例程序    #include #include "lib/common.h"#include "lib/event_loop.h"#include "lib/tcp_server.h" char rot13_char(char c) {    if ((c >= 'a' && c = 'A' && c = 'n' && c = 'N' && c name);    printf("%s", input->data);     struct buffer *output = buffer_new();    int size = buffer_readable_size(input);    for (int i = 0; i name);    printf("%s", input->data);    // 取出一个线程来负责 decode、compute 和 encode    struct buffer *output = thread_handle(input);    // 处理完之后再通过 reactor I/O 线程发送数据    tcp_connection_send_buffer(tcpConnection, output);    return 
## 样例程序结果我们启动这个服务器端程序，你可以从服务器端的输出上看到使用了 poll作为事件分发方式。多打开几个 telnet 客户端交互，main-thread只负责新的连接建立，每个客户端数据的收发由不同的子线程Thread-1、Thread-2、Thread-3 和 Thread-4 来提供服务。这里由于使用了子线程进行 I/O处理，主线程可以专注于新连接处理，从而大大提高了客户端连接成功率。    $./poll-server-multithreads[msg] set poll as dispatcher[msg] add channel fd == 4, main thread[msg] poll added channel fd==4[msg] set poll as dispatcher[msg] add channel fd == 7, main thread[msg] poll added channel fd==7[msg] event loop thread init and signal, Thread-1[msg] event loop run, Thread-1[msg] event loop thread started, Thread-1[msg] set poll as dispatcher[msg] add channel fd == 9, main thread[msg] poll added channel fd==9[msg] event loop thread init and signal, Thread-2[msg] event loop run, Thread-2[msg] event loop thread started, Thread-2[msg] set poll as dispatcher[msg] add channel fd == 11, main thread[msg] poll added channel fd==11[msg] event loop thread init and signal, Thread-3[msg] event loop thread started, Thread-3[msg] set poll as dispatcher[msg] event loop run, Thread-3[msg] add channel fd == 13, main thread[msg] poll added channel fd==13[msg] event loop thread init and signal, Thread-4[msg] event loop run, Thread-4[msg] event loop thread started, Thread-4[msg] add channel fd == 5, main thread[msg] poll added channel fd==5[msg] event loop run, main thread[msg] get message channel i==1, fd==5[msg] activate channel fd == 5, revents=2, main thread[msg] new connection established, socket == 14connection completed[msg] get message channel i==0, fd==7[msg] activate channel fd == 7, revents=2, Thread-1[msg] wakeup, Thread-1[msg] add channel fd == 14, Thread-1[msg] poll added channel fd==14[msg] get message channel i==1, fd==14[msg] activate channel fd == 14, revents=2, Thread-1get message from tcp connection connection-14fasfas[msg] get message channel i==1, fd==14[msg] activate channel fd == 14, revents=2, Thread-1get message from tcp connection connection-14fasfasasfa[msg] get message channel i==1, fd==5[msg] activate channel fd == 5, revents=2, main thread[msg] new connection established, socket == 15connection completed[msg] get message channel i==0, fd==9[msg] activate channel fd == 9, revents=2, Thread-2[msg] wakeup, Thread-2[msg] add channel fd == 15, Thread-2[msg] poll added channel fd==15[msg] get message channel i==1, fd==15[msg] activate channel fd == 15, revents=2, Thread-2get message from tcp connection connection-15afasdfasf[msg] get message channel i==1, fd==15[msg] activate channel fd == 15, revents=2, Thread-2get message from tcp connection connection-15afasdfasfsafsafa[msg] get message channel i==1, fd==15[msg] activate channel fd == 15, revents=2, Thread-2[msg] poll delete channel fd==15connection closed[msg] get message channel i==1, fd==5[msg] activate channel fd == 5, revents=2, main thread[msg] new connection established, socket == 16connection completed[msg] get message channel i==0, fd==11[msg] activate channel fd == 11, revents=2, Thread-3[msg] wakeup, Thread-3[msg] add channel fd == 16, Thread-3[msg] poll added channel fd==16[msg] get message channel i==1, fd==16[msg] activate channel fd == 16, revents=2, Thread-3get message from tcp connection connection-16fdasfasdf[msg] get message channel i==1, fd==14[msg] activate channel fd == 14, revents=2, Thread-1[msg] poll delete channel fd==14connection closed[msg] get message channel i==1, fd==5[msg] activate channel fd == 5, revents=2, main thread[msg] new connection established, socket == 17connection completed[msg] get message channel i==0, fd==13[msg] activate channel fd == 13, revents=2, Thread-4[msg] wakeup, Thread-4[msg] add channel fd == 17, Thread-4[msg] poll added channel fd==17[msg] get message channel i==1, fd==17[msg] activate channel fd == 17, revents=2, Thread-4get message from tcp connection connection-17qreqwrq[msg] get message channel i==1, fd==16[msg] activate channel fd == 16, revents=2, Thread-3[msg] poll delete channel fd==16connection closed[msg] get message channel i==1, fd==5[msg] activate channel fd == 5, revents=2, main thread[msg] new connection established, socket == 18connection completed[msg] get message channel i==0, fd==7[msg] activate channel fd == 7, revents=2, Thread-1[msg] wakeup, Thread-1[msg] add channel fd == 18, Thread-1[msg] poll added channel fd==18[msg] get message channel i==1, fd==18[msg] activate channel fd == 18, revents=2, Thread-1get message from tcp connection connection-18fasgasdg^C