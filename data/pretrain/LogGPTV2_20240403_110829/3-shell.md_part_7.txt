# 2 案例2：字符串初值的处理
通过\${var:-word}判断变量是否存在，决定变量的初始值。
> 1）只取值，\${var:-word}
>
> 若变量var已存在且非Null，则返回 \$var
> 的值；否则返回字串"word"，原变量var的值不受影响。
\[root@server0 4day\]# a=123456
\[root@server0 4day\]# \${a:-123456}
bash: 123456: 未找到命令\...
\[root@server0 4day\]# a=123 #定义了a=123
\[root@server0 4day\]# echo \${a:-123456} #定义a的初值为:123456并输出
123 #输出a为123
\[root@server0 4day\]# a= #定义a= 空值
\[root@server0 4day\]# echo \${a:-123456} #定义a的初值为:123456并输出
123456 #输出a为初值123456
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
#! /bin/bash
read -p \"请输入用户名:\" n
useradd \$n
read -p \"请输入\$n 的密码:\" p
echo \${p:-123456} \|passwd \--stdin \$n
#如没有输入密码,将会把123456设置为用户密码
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
echo \${a:} 截取
echo \${a/} 替换
> 1）只替换第1个子串 格式：\${变量名/old/new}
>
> 2）替换全部子串 格式：\${变量名//old/new}
echo \${a#} 掐头
echo \${a%} 去尾
echo \${a:-} 定义初值
例:用来从键盘读入一个正整数x，求从1到x的和；当用户未输入值（直接回车）时，为了避免执行出错，应为x赋初值1
。
# 3 案例3：expect预期交互
expect可以为交互式过程（比如FTP、SSH等登录过程）自动输送预先准备的文本或指令，而无需人工干预。触发的依据是预期会出现的特征提示文本。
> 步骤一：准备expect及SSH测试环境
>
> 1）安装expect工具
\-\-\-\-\-\--脚本使用SSH登录远程主机并创建文件再退出\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
\[root@svr5 \~\]# vim expect_ssh.sh
#! /bin/bash
expect \ #创建交互进程
expect \"password:\" { send \"redhat\\r\" }
#出现"passwd:"发送密码,并回车
expect \"#\" { send \"touch /tmp111.txt\\r\" }
#发现"#"发送创建命令并回车
expect \"#\" { send \"exit\\r\" } #发现"#"发送"exit"并回车"\\r:"
默认不执行
EOF
注意事项：
expect脚本的最后一行默认不执行
如果不希望ssh时出现yes/no的提示，远程时使用如下选项:
> \# ssh -o StrictHostKeyChecking=no server0
**数组:**
\[root@server0 4day\]# w=(11 22)
\[root@server0 4day\]# echo \${w\[0\]} \# 显示第一个元素 0为下标
11
\[root@server0 4day\]# echo \${w\[1\]}
22
\[root@server0 4day\]# echo \${w\[@\]} #显示所有元素
11 22
\[root@server0 4day\]# w\[2\]=33 #增加第三个元素
\[root@server0 4day\]# w\[3\]=33 #增加第四个元素
\[root@server0 4day\]# echo \${w\[@\]}
11 22 33 33
\[root@server0 4day\]# echo
\${w\[@\]:1:2}#截取数组元素1为起始下标,2为元素个数
22 33
# 4 案例4：使用正则表达式
**正则表达式:**使用"一串符号"来描述有共同属性的数据
**基本正则列表:**
![table001](media/image3.png){width="3.9159722222222224in"
height="2.3041666666666667in"}
\^\$ 组合,表示空行
**扩展正则列表:**
![table002](media/image4.png){width="3.8784722222222223in"
height="1.4972222222222222in"}
grep 只能使用基本正则,如要使用扩展正则需要加 -E ,egrep -E 0
egrep 即可使用基本正则,又可以使用扩展正则
\[root@server0 4day\]# grep -E \"\^root\|\^daemon\" /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
\[root@server0 4day\]# egrep \"\^root\|\^daemon\" /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
**grep -q** #使用 -q 选项表示quiet(静默)的效果与使用 **&\>
/dev/null的效果类似。**
\[root@ver0 4day\]# grep -q \"\^127.0.0.1\" /etc/hosts && echo
\"YES\"\|\|echo \"NO\"
YES
\[root@ver0 4day\]# grep \"\^127.0.0.1\" /etc/hosts && echo \"YES\" \|\|
echo \"NO\"
127.0.0.1 localhost localhost.localdomain localhost4
localhost4.localdomain4
YES
egrep -m10 #-m10仅在文件的前10行中过滤，后面的行不再过滤。
\[root@server0 4day\]# egrep -m10 \"/sbin/nologin\$\" /etc/passwd
**egrep -c** #使用 -c 选项可输出匹配行数，这与通过管道再 wc
-l的效果是相同的
\[root@server0 4day\]# egrep -c \"/bin/bash\$\" /etc/passwd
17
\[root@server0 4day\]# egrep \"/bin/bash\$\" /etc/passwd \|wc -l
17
3）基本元字符 \^、\$ ------ 匹配行首、行尾
4.  基本元字符 . ------ 匹配任意单个字符
> \* ------ 匹配任意单个字符 匹配前一个字符的任意次数,不允许单独使用
\[root@server0 4day\]# egrep \".\*\" xyz
aaaaaaaaaethe
thebbbbbbbaaaaaaaa
aaaaaaa the bbbbbb
dddddddddcccccccccaaaaaaaaa
a
\# ".\*" 将此行空行也筛选出来了
\[root@server0 4day\]# egrep \".\" xyz
aaaaaaaaaethe #"." 输出xyz文件内至少包括一个字符的行(\\n换行符除外)
thebbbbbbbaaaaaaaa
aaaaaaa the bbbbbb
dddddddddcccccccccaaaaaaaaa
a
输出/etc/rc.local文件内的空行（用 --v 选项将条件取反）：
\[root@server0 4day\]# egrep -v \".\" xyz #与"\^\$"效果类似
\[root@server0 4day\]# egrep \"\^\$\" xyz #与 -v "." 类似
5.  基本元字符 +、?、\* ------ 目标出现的次数
\[root@server0 4day\]# egrep \"a?\" xyz \# "a?"最多匹配一次,包括零次
aaaaaaaaaethe
thebbbbbbbaaaaaaaa
aaaaaaa the bbbbbb
dddddddddcccccccccaaaaaaaaa
a
#此行空行,包括零次
\[root@server0 4day\]# egrep \"a\*\" xyz
#匹配前面一个字符任意次数,包括零次
aaaaaaaaaethe
thebbbbbbbaaaaaaaa
aaaaaaa the bbbbbb
dddddddddcccccccccaaaaaaaaa
a
> #此行空行,包括零次
\[root@server0 4day\]# egrep \"a+\" xyz #匹配前面一个字符最少一次,可超过
aaaaaaaaaethe
thebbbbbbbaaaaaaaa
aaaaaaa the bbbbbb
dddddddddcccccccccaaaaaaaaa
a
输出/etc/passwd文件内"t"开头且以"a"结尾的用户记录，即中间可以是任意字符：
\[root@server0 4day\]# egrep \"\^t.\*a\$\" xyz
thebbbbbbbaaaaaaaa
6）元字符 {} ------ 限定出现的次数范围
\[root@server0 4day\]# cat xya #先查看实验内容
dedef abab ghighi
cdcd ababab
Hello abababab World \>xya
aabbccaabbcc
aaabbbcccdddeee
\[root@server0 4day\]# egrep \"a{1}\" xya #a连续出现1次
dedef abab ghighi
cdcd ababab
Hello abababab World \>xya
aabbccaabbcc
aaabbbcccdddeee
\[root@server0 4day\]# egrep \"a{2}\" xya #a连续出现2次
aabbccaabbcc
aaabbbcccdddeee
\[root@server0 4day\]# egrep \"a{3}\" xya #a连续出现3次
aaabbbcccdddeee
\[root@server0 4day\]#
\[root@server0 4day\]# egrep \"a{2,4}\" xya #a连续出现2-4次
aabbccaabbcc
aaabbbcccdddeee
\[root@server0 4day\]#
7）元字符 \[\] ------ 匹配范围内的单个字符
\[root@server0 4day\]# egrep \"\[Hc\]\" xya #只要含有\[\]内的行都会显示
cdcd ababab
Hello abababab World \>xya
aabbccaabbcc
aaabbbcccdddeee
\[root@server0 4day\]# egrep \"\[A-Z\]\" xya
#使用\[A-Z\]匹配连续范围,全大写
Hello abababab World \>xya
**\[\^\] 对集合内取反**, \"\[\^a-z\]\"除了小写,其余全匹配,包括空格
\[root@server0 4day\]# egrep \"\[\^a-z\]\" xya \#
dedef abab ghighi #有空隔
cdcd ababab #有空隔
Hello abababab World \>xya
**8）单词边界匹配"\\b**"
\[root@server0 4day\]# egrep \"\\bab\" xya #匹配含有ab开头的单词的行
dedef abab ghighi
cdcd ababab
Hello abababab World \>xya
\[root@server0 4day\]# egrep \"f\\b\" xya #匹配含有f结尾的单词的行
dedef abab ghighi
9）多个条件的组合
\[root@server0 4day\]# egrep -i \"d\|h\" xya
#查找含有d与h的行,且不区分大小写
dedef abab ghighi
cdcd ababab
Hello abababab World \>xya
aaabbbcccdddeee
# NSD SHELL DAY05
案例1：sed基本用法
案例2：使用sed修改系统配置
案例3：sed多行文本处理
案例4：sed综合脚本应用
sed(流式编辑器)工具概述:
-   非交互式,基于模式匹配过滤及修改文本
-   逐行处理,并将结果输出到屏幕
-   可实现对文本的输出,删除,替换,复制,剪切,导入,导出等各种操作
-   与vim文本处理工具的区别,vim交互式,sed非交互式
# sed文本处理工具的用法：
用法1：前置命令 \| sed \[选项\] \'条件指令\' #管道
用法2：sed \[选项\] \'条件指令\' 文件.. ..
-   条件指令含"\[地址符\]处理动作"
-   地址符含"\[地址1,\[地址2\]\]"
-   条件可以是行号或者/正则/
-   没有条件时，默认为所有条件
-   指令可以是增、删、改、查等指,必须有
-   默认sed会将所有输出的内容都打印出来，可以使用-n屏蔽默认输出
-   选项中可以使用-r选项，让sed支持扩展正则
## sed命令的常用选项如下： 
-n（屏蔽默认输出，默认sed会输出读取文档的全部内容）
\[root@client50 \~\]# sed -n \'1p\' 1.txt
\> bb
-r（让sed支持扩展正则）,默认支持基本正则
-i（sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响）
\[root@client50 \~\]#sed -i \'1d\' 1.txt
## sed 命令的 指令 选项
**p 打印**
> \]# sed -n \'1p\' 1.txt
>
> \]# sed -n \'2,4p\' /opt/abcdef #显示第2到4行,加了-n
>
> \]# sed -n \'2p;4p\' /opt/abcdef #显示第2和第4行
>
> \]# sed -n \'2,+2p\' /opt/abcdef #从第2行开始,再打印后面2行,
>
> \]# sed -n \'1\~2p\' /opt/abcdef #从第一行开始,每跨2行打印,奇数
>
> \]# sed -n \'\$=\' /opt/abcdef #显示最后一行的行数
>
> \]# sed -n \'\$p\' /opt/4day/xyz #显示最后一行的内容
>
> \]# sed -n \'=\' /opt/4day/xyz #显示行号
**d 删除**
> \# sed \'1d\' 1.txt #删除第一行
**s 替换 （s/旧内容/新内容/选项）**
> \]# sed \'s/the/xyz/\' /opt/4day/xyz #替换每行第一个the为xyz
>
> \]# sed \'s/the/xyz/2\' /opt/4day/xyz #替换每行第二个the为xyz
>
> \]# sed \'s/the/xyz/g\' /opt/4day/xyz #替换每行所有的the为xyz
>
> \]# sed \'1s/the/xyz/\' /opt/4day/xyz #替换第1行的第一个the为xyz
>
> \]# sed \'2s/a/x/\' /opt/4day/xyz #第2行第一个a替换成x
>
> \]# sed \'2,5s/a/x/\' /opt/4day/xyz #第二行到第五行第一个a替换成x
>
> \]# sed \'s/\^the/xyz/\' /opt/4day/xyz #将以the开头的替换为xyz
>
> \]# sed \'s/\^the/xyz/\' /opt/4day/xyz #将以the开头的替换为xyz
i： 在指定的行之前插入文本
a：在指定的行之后追加文本
c：替换指定的行