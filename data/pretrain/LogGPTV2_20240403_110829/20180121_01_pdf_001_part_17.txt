• https://github.com/digoal/blog/blob/master/201
306/20130628_01.md
• 用途
– 加速空闲页查找
– 降低热点页
结构
VM
• 结构
– 每个HEAP PAGE，2个比特位
– /* Flags for bit map */
– #define VISIBILITYMAP_ALL_VISIBLE 0x01
– #define VISIBILITYMAP_ALL_FROZEN 0x02
– #define VISIBILITYMAP_VALID_BITS 0x03 /* OR of all valid visibilitymap
– * flags bits */
• 用途
– index only scan
– vacuum 跳过all visible，all frozen页
– vacuum freeze跳过all frozen页
思考、问题
• 如何访问数据
• 每种访问方法的原理
• 数据库如何选择扫描方法、依据是什么
扫描方法介绍
• seqscan
• index only scan
• index scan
• bitmap scan
• ctid scan
seqscan
表大小超过SB/4, 加TAG
从0号数据块开始扫 BAS_BULKREAD
,优先淘汰
shared
buffer
分批处理，并不会把shared buffer塞满
seqscan+synchronize_seqscans=on
表大小超过SB/4, 加TAG
可能从中间开始扫，
WRAP BAS_BULKREAD
,优先淘汰
shared
buffer
多会话并行扫描单表，优化，尽量步调一致，一个BLOCK一次IO（尽量）
分批处理，并不会把shared buffer塞满
https://github.com/digoal/blog/blob/master/201804/20180414_02.md
index only scan
VM
源于INDEX没有版本信息
①
②
查看VM后，发现对应HEAP PAGE有脏数据才需要回表。
index scan
index skip scan
• https://github.com/digoal/blog/blob/master/201803/20180323_03.md
• 从 150多毫秒，降低到了 0.256毫秒
create table t (
sex int,
name text
);
insert into t select random(),
md5(random()::text) from
generate_series(1,10000000);
create index idx_t on t(sex,name);
select * from t where name='abc';
index skip scan
bitmap scan
1、multi-index combine OR internal combine(GIN)
2、消除离散、重复读HEAP
bitmap index
scan
sort heap block
ID
sorted
block id scan
recheck index
Cond
bitmap scan
• index scan -> sort heap blockid -> scan heap block
-> recheck index Cond.
• 优化器参考指标，相关性
• IO 放大问题消除
• SQL例子
– https://github.com/digoal/blog/blob/master/201804/
20180402_01.md
bitmap scan
bitmap scan
• 离散扫描，每个BLOCK几乎都被重复扫描了140次，一个BLOCK刚好存储140条记录，说明这
140条记录在顺序上完全离散。
• postgres=# explain (analyze,verbose,timing,costs,buffers) select * from corr_test where c2 between
1 and 10000000;
• QUERY PLAN
• --------------------------------------------------------------------------
• Index Scan using idx_corr_test_2 on public.corr_test (cost=0.43..36296.14 rows=50000 width=8)
(actual time=0.029..6563.525 rows=9999999 loops=1)
• Output: c1, c2
• Index Cond: ((corr_test.c2 >= 1) AND (corr_test.c2 = 1) AND (corr_test.c2  Bitmap Index Scan on idx_corr_test_2 (cost=0.00..2842200.75 rows=10000032 width=0) (actual
time=681.488..681.488 rows=9999998 loops=1)
• Index Cond: ((corr_test.c2 >= 1) AND (corr_test.c2  Gather (cost=86811.85..86811.86 rows=32 width=8)
• Workers Planned: 32
• -> Partial Aggregate (cost=86811.85..86811.86 rows=1 width=8)
• -> Parallel Index Only Scan using a_pkey on a (cost=0.43..86030.60 rows=312500 width=0)
• (5 rows)
思考、问题
• Oracle发现索引有膨胀怎么办？
• 发现数据膨胀，高水位，如何处理？
• 如何做到加列不堵塞 DML？
• 如何实现 DELETE,UPDATE limit
• 什么时候建议使用批量 SQL
• 什么时间建议使用 COPY
索引维护
• PostgreSQL支持重复索引（例如一个字段，
可以创建多个一样的索引）
– 在线新建索引
– 删除旧索引
在线创建索引 不堵塞
( dml)
• https://www.postgresql.org/docs/devel/static/sql-createindex.html
• Command: CREATE INDEX 并发创建索引
• Description: define a new index 不堵塞DML的方法
• Syntax:
• CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] name ] ON
table_name [ USING method ]
• ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ]
[ NULLS { FIRST | LAST } ] [, ...] )
• [ WITH ( storage_parameter = value [, ... ] ) ]
• [ TABLESPACE tablespace_name ]
• [ WHERE predicate ]
在线加列
• 不要加默认值
• 如果有默认值，建议后台分批更新
在线回收空间
• https://github.com/reorg/pg_repack/
• https://github.com/digoal/blog/blob/master/
201610/20161030_02.md
批量
DML
• https://github.com/digoal/blog/blob/master/201704/2017
0424_05.md
• 批量插入
– insert into tbl values (),(),...();
– copy
• 批量更新
– update tbl from tmp set x=tmp.x where tbl.id=tmp.id;
• 批量删除
– delete from tbl using tmp where tmp.id=tbl.id;
DELETE\UPDATE limit
• delete from tbl where ctid=any(array(
• select ctid from tbl where xxxx limit n
• ));
• update from tbl set xx=xx where ctid=any(array(
• select ctid from tbl where xxxx limit n
• ));
思考、问题
• 如何分析性能瓶颈
数据库优化
• 擒贼先擒王（TOP SQL）
• SQL执行计划分析、优化
• 数据库内核代码层瓶颈分析
• 慢SQL定位、优化
• 数据库活动信息跟踪参数
• 锁等待问题定位
• 等待事件透视
• 全面健康报告
• 9种索引接口的适应场景与选择
• 复合索引顺序
• 非驱动列扫描优化
• 优化器开关介绍（因子、开关）
• HINT的使用
性能分析利器 参数优化
0 -
• 操作系统、文件系统参数
– https://github.com/digoal/blog/blob/master/201710/20171018
_01.md
– https://github.com/digoal/blog/blob/master/201611/20161121
_01.md
– https://github.com/digoal/blog/blob/master/201809/20180919
_01.md
• 数据库参数
– https://github.com/digoal/blog/blob/master/201812/20181203
_01.md
经典问题案例
• 大量长连接 + big shared buffer，page table 膨胀
– https://github.com/digoal/blog/blob/master/201803/20180325_02.md
• 会话级缓存 - 长连接（access relations cache）内存霸占
– https://github.com/digoal/blog/blob/master/201607/20160709_01.md
• 分区表分区过多-会话缓存所有表元数据，内存占用过大
– 社区已有patch, 或者使用pg_pathman
• 递归查询死循环
– 临时空间跑满
– https://github.com/digoal/blog/blob/master/201607/20160723_01.md
性能分析利器
1 - TOP SQL
pg_stat_statements
插件
性能分析利器
1 - TOP SQL
• https://github.com/digoal/blog/blob/master/201704/20170424_06.md
• create extension pg_stat_statements;
• 最耗时SQL (整体数据库优化，建议以此结果逐条优化，效果立竿见影)
• 总最耗时SQL TOP 5
• select dbid, query from pg_stat_statements order by total_time desc limit 5;
• 其他
– 最耗IO SQL
– 总最耗IO SQL TOP 5
– select dbid, query from pg_stat_statements order by (blk_read_time+blk_write_time) desc limit 5;
– 响应时间抖动最严重SQL
– select dbid, query from pg_stat_statements order by stddev_time desc limit 5;
– 最耗共享内存SQL
– select dbid, query from pg_stat_statements order by (shared_blks_hit+shared_blks_dirtied) desc limit 5;
– 最耗临时空间SQL
– select dbid, query from pg_stat_statements order by temp_blks_written desc limit 5;
性能分析利器
2 - explain
• https://www.postgresql.org/docs/10/static/sql-explain.html
• https://github.com/digoal/blog/blob/master/201704/20170424_06.md
• HDB PG
• https://github.com/digoal/blog/blob/master/201712/20171204_02.md