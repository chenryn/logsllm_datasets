â€¢ Build ğ‘†ğµ := âŸ¨Commitment, VSS. (cid:174)ğ¶, ğ‘’, ğ‘§ğ‘ ğ‘’ âŸ©ğ¿ğ‘’ , the sharing block which consists of commitments VSS. (cid:174)ğ¶ := {VSS.C1, . . . , VSS.Cğ‘›} to the ğ‘› random numbers
generated by running (VSS.(cid:174)ğ‘†ğ‘–, VSS. (cid:174)ğ‘Šğ‘–, VSS.Cğ‘–) â† VSS.ShGen(ğ‘ ğ‘–) for ğ‘– âˆˆ {1, . . . , ğ‘›}, where VSS.(cid:174)ğ‘†ğ‘–
:=
â€¢ Build the share vector VSS.(cid:174)ğ‘† ğ‘— := {VSS.s1 â† VSS.(cid:174)ğ‘†1,ğ‘— , . . . , VSS.sğ‘› â† VSS.(cid:174)ğ‘†ğ‘›,ğ‘— } and the witness vector VSS. (cid:174)ğ‘Šğ‘— := {VSS.ğœ‹1 â† VSS. (cid:174)ğ‘Š1,ğ‘— , . . . , VSS.ğœ‹ğ‘› â†
VSS. (cid:174)ğ‘Šğ‘›,ğ‘— } for node ğ‘ ğ‘— using ğ‘—ğ‘¡â„ share and witness from VSS.(cid:174)ğ‘†ğ‘– and VSS. (cid:174)ğ‘Šğ‘– for random number ğ‘ ğ‘–.
â€¢ Send VSS.(cid:174)ğ‘† ğ‘— , VSS. (cid:174)ğ‘Šğ‘— , and ğ‘†ğµ to every node ğ‘ ğ‘— âˆˆ P.
2. Blame/Forward. If epoch-timerğ‘’âˆ’1 â‰¥ 8Î” and node ğ‘ğ‘– receives valid share vector VSS.(cid:174)ğ‘†ğ‘–, witness vector VSS. (cid:174)ğ‘Šğ‘– and commitment ğ‘†ğµ :=
âŸ¨Commitment, VSS. (cid:174)ğ¶, ğ‘’, ğ‘§ğ‘ ğ‘’ âŸ©ğ¿ğ‘’ , then invoke Deliver(Commitment, ğ‘†ğµ, ğ‘§ğ‘ ğ‘’, ğ‘’). If no shares has been received within 3Î” time while in epoch ğ‘’ âˆ’ 1, broadcast
a blame âŸ¨blame, ğ‘’âŸ©ğ‘– to all nodes.
3. Request open. Wait until epoch-timerğ‘’âˆ’1 â‰¥ 5Î”. Collect all blames received so far. If up to ğ‘¡ blames are received so far, forward the blames to ğ¿ğ‘’. If no
blames or equivocation by ğ¿ğ‘’ has been detected, send âŸ¨ack, ğ» (ğ‘†ğµ), ğ‘’âŸ©ğ‘– to ğ¿ğ‘’.
4. Private open. ğ¿ğ‘’ sends valid share VSS.(cid:174)ğ‘† ğ‘— and witness VSS. (cid:174)ğ‘Šğ‘— to node ğ‘ğ‘–, for every blame âŸ¨blame, ğ‘’âŸ©ğ‘— received from node ğ‘ğ‘–.
5. Ack. Upon receiving valid share VSS.(cid:174)ğ‘† ğ‘— and witness VSS. (cid:174)ğ‘Šğ‘— for every âŸ¨blame, ğ‘’âŸ©ğ‘— it forwarded and detects no equivocation, send âŸ¨ack, ğ» (ğ‘†ğµ), ğ‘’âŸ©ğ‘– to ğ¿ğ‘’.
6. (Non-blocking) Equivocation. Broadcast equivocating hashes signed by ğ¿ğ‘’ and stop performing any operations.
Forward share VSS.(cid:174)ğ‘† ğ‘— and witness VSS. (cid:174)ğ‘Šğ‘— to node ğ‘ ğ‘— for every âŸ¨blame, ğ‘’âŸ©ğ‘— it received.
Figure 8: Block validation protocol.
â€¢ Setup. Set ğ‘’ = 1. All nodes agree upon and fill Q(ğ‘ğ‘–) with ğ‘š = ğ‘› + ğ‘¡ tuples âˆ€ğ‘ğ‘– âˆˆ P. Set Pğ‘Ÿ â† âˆ…. Run VSS.Setup and agree on the public parameters
â€¢ Blocks. While in epoch ğ‘’ âˆ’ 1, leader ğ¿ğ‘’ starts the block validation protocol (refer Figure 8) with {ğ‘ 1, . . . , ğ‘ ğ‘›}, where the secrets are chosen randomly
Let VSS be the VSS scheme used, ğ‘’ be the current epoch and ğ¿ğ‘’ be the leader of epoch ğ‘’. Node ğ‘ğ‘– âˆˆ P augments SMR protocol in Figure 1 as follows:
VSS.pp. Set ğ¿ğ‘’ â† ğ‘1.
ğ‘ ğ‘– â†$ {0, 1}ğœ… for 1 â‰¤ ğ‘– â‰¤ ğ‘›.
In epoch ğ‘’, ğ¿ğ‘’ proposes block ğµâ„ with ğ‘â„ := (ğ» (ğ‘†ğµ), ACğ‘’ (ğ‘†ğµ)) where ACğ‘’ (ğ‘†ğµ) is an ack certificate for commitment ğ‘†ğµ.
â€¢ Update. When epoch-timerğ‘’ expires, if ğ¿ğ‘’âˆ’ğ‘¡ proposed a valid block ğµğ‘™ in epoch ğ‘’ âˆ’ ğ‘¡ and ğµğ‘™ has been committed by epoch ğ‘’, update Q(ğ¿ğ‘’âˆ’ğ‘¡) with ğ‘›
tuples with each tuple containing secret shares, witnesses and commitments shared in epoch ğ‘’ âˆ’ ğ‘¡. Otherwise, remove ğ¿ğ‘’âˆ’ğ‘¡ from future proposals i.e.,
Pğ‘Ÿ â† Pğ‘Ÿ âˆª {ğ¿ğ‘’âˆ’ğ‘¡ }.
(1) Get (VSS.(cid:174)ğ‘†, VSS. (cid:174)ğ‘Š , VSS. (cid:174)ğ¶) :=(cid:8)Dequeue(Q(ğ‘ ğ‘—)) |ğ‘ ğ‘— âˆ‰ Pğ‘Ÿ(cid:9).
â€¢ Reconstruct. When epoch-timerğ‘’ expires, do the following:
(2) Build homomorphic sum share ğ‘†ğ‘‰ğ‘–, witness VSS.ğœ‹ğ‘–, and commitment VSS.Cğ‘’ using all shares from VSS. (cid:174)ğ¶. Send ğ‘†ğ‘‰ğ‘– and VSS.ğœ‹ğ‘– to all the nodes.
(3) Upon receiving share ğ‘†ğ‘‰ğ‘— and witness VSS.ğœ‹ ğ‘— for VSS.Cğ‘’, ensure that VSS.ShVrfy(ğ‘†ğ‘‰ğ‘— , VSS.ğœ‹ ğ‘— , VSS.Cğ‘’) = 1.
(4) Upon receiving (ğ‘¡ + 1) valid homomorphic sum shares in ğ‘†ğ‘‰ , obtain ğ‘…ğ‘’ â† VSS.Recon(ğ‘†ğ‘‰).
â€¢ Output. Compute and output Oğ‘’ â† ğ» (ğ‘…ğ‘’).
Figure 9: RandPiper â€“ BRandPiper beacon protocol.
and commitments shared in epoch ğ‘’ âˆ’ ğ‘¡. If no epoch ğ‘’ âˆ’ ğ‘¡ block
was committed, it removes ğ¿ğ‘’âˆ’ğ‘¡ from future proposals, i.e., Pğ‘Ÿ â†
Pğ‘Ÿâˆª{ğ¿ğ‘’âˆ’ğ‘¡}. It is important to note that the SMR protocol guarantees
all honest nodes commit proposed blocks in ğ‘¡ + 1 epochs. Thus, all
honest nodes either update Q(ğ¿ğ‘’âˆ’ğ‘¡) or remove ğ¿ğ‘’âˆ’ğ‘¡ in epoch ğ‘’.
Reconstruct. At the end of epoch ğ‘’, all the nodes perform the op-
eration Dequeue(Q(ğ‘ ğ‘—)), âˆ€ğ‘ ğ‘— âˆ‰ Pğ‘Ÿ , to fetch ğ‘› secret shares (one
from each node) and corresponding witnesses. The nodes compute
the homomorphic sum of shares and witnesses and broadcast it to
all other nodes.
Output. From the above discussion, it is clear that all honest nodes
send homomorphic sum of shares for common commitments and
all honest nodes will receive at least ğ‘¡ + 1 valid homomorphic
shares. When a node ğ‘ğ‘– receives ğ‘¡ + 1 homomorphic shares, it
reconstructs the randomness ğ‘…ğ‘’ using VSS.Recon primitive and
computes Oğ‘’ â† ğ»(ğ‘…ğ‘’).
Due to space constraints, we analyze security in Appendix B.3.
5 PERFORMANCE EVALUATION
In this section, we evaluate the performance of RandPiper, and
compare it with the performance of related works.
Implementation. We implement BRandPiper protocol in Rust [11,
Performance Evaluation], due to its strong support for correctness
in concurrency, and compile-time memory safety guarantees. Our
implementation is lock-free and uses message passing to ensure
efficiency. We provide the setup parameters for every node in the
config files. Our code is event driven, and reacts to various timeouts
and messages from the network. We use ED25519 for digital signa-
tures. We use the BLS-12-381 [9] curve and use implementations of
SCRAPE [17] over this curve as the PVSS scheme, Pedersen-based
eVSS and Polycommit [32] over this curve as the VSS and bilinear
accumulator scheme.
Optimizations. We perform some system-level optimizations. In
particular, we do the following: (1) We generate random shares
before the propose step (this can be done using extra cores, an
external node supplying the shares) and use it during the propose
12
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3513BRandPiper. Our beacon produces a value every 11Î”. We measure
the smallest value of Î” for which our beacon produces outputs
without any of the ğ‘› correct nodes blaming/reporting malicious
behavior in the logs. Using this, we measure the metric: number of
beacons produced per minute for BRandPiper protocol, and present
them in Figure 10. We run our beacon for 100 rounds, thereby giving
a strong confidence that the Î” used is viable, provided the network
conditions stay the same.
Drand. For Drand, we measure the parameter time discrepancy,
which is a value output by Drand by every node. It reports the
time (in ms) between obtaining the beacon value and the time at
which the epoch started. This time accounts for the synchronization
losses, network delays as well as the computations. The beacon
continues to produce values every period seconds. However, the
time discrepancy parameter defines the lowest period we can set
to ensure continuous beacon output. We give the benefit of the
doubt to Drand here as there is no guarantee that setting such low
values for Î” does not overwhelm the system. We allow the beacon
to run for 100 epochs, and measure the 99.9ğ‘¡â„ percentile of the
time discrepancies observed in the logs of all the nodes over all the
epochs, and present their growth in Figure 10. For 100 percentile, we
observe that we are always better than Drand. In our experiments,
when ğ‘› = 65, we observed that the DKG initialization in Drand
results in all the nodes aborting, even after setting large values for
period.
HydRand. We use the public implementation [42]. It consists of
three rounds: propose, acknowledge and vote, timeouts for which
can be configured. We find the smallest such configuration that
allows the system to work and report the numbers in Figure 10.
HydRand on its own offers ğ‘¡ + 1-absolute unpredictability where
ğ‘¡ < ğ‘›/3 along with the bias-resistance property. However, Drand
and BRandPiper are both 1-absolute unpredictable, and in that sense,
HydRand is not unpredictable.
From Figure 10, we can clearly see that the Merkle tree based
BRandPiper is quantitatively as practical as the state-of-the-art
practical random beacon protocol: Drand. Drand uses a leader to
coordinate the DKG and reconfiguration protocols. There is no de-
scription on how to recover if the leader was Byzantine. Addition-
ally, in Drand, the synchronization for the reconfigured instance is
via the coordinator (the leader). It is not clear how the protocol will
recover if the leader becomes Byzantine. Therefore, qualitatively,
we use much clearer and formal network assumptions and allow
efficient and secure reconfiguration, including synchronization for
the incoming nodes, without pausing the protocol, unlike Drand,
and therefore can conclude that BRandPiper protocol is not just
theoretically interesting, but also practical.
ACKNOWLEDGEMENTS
We would like to thank our shepherd Alin Tomescu, Sourav Das and
the anonymous reviewers for their insightful feedback to improve
this draft. This work has been partially supported by research gift
grants from VMware Research and Novi, the Army Research Labo-
ratory (ARL) under grant W911NF-20-2-0026, the National Institute
of Food and Agriculture (NIFA) under grant 2021-67021-34251, and
the National Science Foundation (NSF) under grant CNS-1846316.
13
Figure 10: Overview of the beacons produced per minute for the
various protocols. Among the compared implementations, HydRand
is only bias-resistant but does not offer 1-absolute unpredictability
step, so that the share generation does not block the critical path.
(2) We take advantage of the Tokio library [48] and futures in Rust to
run concurrently without spawning threads. (3) We implement both
the accumulator libraries: the bilinear accumulator and the Merkle
tree accumulator. We observe that the computational performance
of the Merkle tree accumulator is much better in practice in general.
Setup. All our experiments were conducted on t2.micro AWS in-
stances from ohio region, which have 1 GB RAM, 8 GB hard disk,
1 vCPU running at up to 3.3 GHz. The advertised bandwidth for
these instances is 60-80 MBits/s.
Baselines. We compared the performance of our implementation
with two baselines which are the current state-of-the-art public im-
plementations: Drand [25] and HydRand [42, 44]. We chose Drand
because it is a practically deployed system implementing Cachin
et al. [16] and evaluating our performance against it justifies our
practicality. We chose HydRand as our second baseline because, it is
theoretically related to our work: HydRand requires 2/3 honest ma-
jority as compared to the optimal 1/2 honest majority necessary for
us. Note that the basic HydRand protocol and implementation [42]
only offers bias-resistance but no unpredictability: an adversary
may correctly predict a random beacon in ğ‘¡ + 1 epochs in advance.
Micro-Benchmarks. We measure the efficiency of the primitives
used in our protocol. Concretely, we measure the run times for
(1) accumulator share generation, verification and reconstruction
for the bilinear accumulator as well as the Merkle tree accumulator,
(2) PVSS share generation, verification, and reconstruction, (3) eVSS
share generation, verification, and reconstruction, and (4) the size of
the various messages used in the protocol. The details are provided
in [11]. We observe that the Merkle tree accumulator for our small
scales has smaller message sizes and very efficient run times. We
also observe that eVSS operations in general perform much better
than its PVSS counterparts.
We build communication-efficient random beacon protocols with
comparable or better performance than the state-of-the-art solu-
tions. Thus, the key metric we compare is the number of beacon
values that can be produced in a minute. In addition, compared
to Drand, we have the advantage of reconfigurability and weaker
network assumptions, and compared to HydRand, we can tolerate
more faults. The methodology is to run protocols at appropriate
values of Î”, which in turn depends on the computation and com-
munication costs. We provide additional micro benchmarks in the
full online version [10].
010203040506070NumberofNodes(n)0100200300400500BeaconsperminuteDrand(99.9)Drand(100)HydRand(nounpred.)BRandPiper(Bilinear)BRandPiper(MerkleTree)Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3514REFERENCES
[1] Ittai Abraham, Srinivas Devadas, Danny Dolev, Kartik Nayak, and Ling Ren.
2019. Synchronous Byzantine Agreement with Expected ğ‘‚(1) Rounds, Expected
ğ‘‚(ğ‘›2) Communication, and Optimal Resilience. In Financial Cryptography and
Data Security, Ian Goldberg and Tyler Moore (Eds.). Springer International Pub-
lishing, Cham, 320â€“334.
[2] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, and Ling Ren. 2018. Dfinity Con-
sensus, Explored. IACR Cryptol. ePrint Arch. 2018 (2018), 1153.
[3] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Maofan Yin. 2020.
Sync HotStuff: Simple and Practical Synchronous State Machine Replication.
In 2020 IEEE Symposium on Security and Privacy (SP). IEEE, Oakland, 106â€“118.
https://doi.org/10.1109/SP40000.2020.00044
[4] Ittai Abraham, Dahlia Malkhi, and Alexander Spiegelman. 2019. Asymptotically
Optimal Validated Asynchronous Byzantine Agreement. In Proceedings of the 2019
ACM Symposium on Principles of Distributed Computing (Toronto ON, Canada)
(PODC â€™19). Association for Computing Machinery, New York, NY, USA, 337â€“346.
[5] Ittai Abraham, Kartik Nayak, Ling Ren, and Zhuolun Xiang. 2021.
Good-case Latency of Byzantine Broadcast: a Complete Categorization.
arXiv:2102.07240 [cs.DC]
[6] Michael Backes, Aniket Kate, and Arpita Patra. 2011. Computational Verifiable Se-
cret Sharing Revisited. In Advances in Cryptology â€“ ASIACRYPT 2011, Dong Hoon
Lee and Xiaoyun Wang (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg,
590â€“609.
[7] Shehar Bano, Mathieu Baudet, Avery Ching, Andrey Chursin, George Danezis,
FranÃ§ois Garillot, Zekun Li, Dahlia Malkhi, Oded Naor, Dmitri Perelman, et al.
2020. State machine replication in the Libra Blockchain.
[8] Niko BariÄ‡ and Birgit Pfitzmann. 1997. Collision-Free Accumulators and Fail-Stop
Signature Schemes Without Trees. In Advances in Cryptology â€” EUROCRYPT â€™97,
Walter Fumy (Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 480â€“494.
[9] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. 2002. Constructing Elliptic
Curves with Prescribed Embedding Degrees. Cryptology ePrint Archive, Report
2002/088. https://eprint.iacr.org/2002/088.
[10] Adithya Bhat, Nibesh Shrestha, Aniket Kate, and Kartik Nayak. 2020. RandPiper
â€“ Reconfiguration-Friendly Random Beacons with Quadratic Communication.
Cryptology ePrint Archive, Report 2020/1590. https://eprint.iacr.org/2020/1590.
[11] Adithya Bhat, Nibesh Shrestha, Aniket Kate, and Kartik Nayak. 2020. RandPiper-
Reconfiguration-Friendly Random Beacons with Quadratic Communication.
IACR Cryptol. ePrint Arch. 2020 (2020), 1590.
[12] Dan Boneh, Joseph Bonneau, Benedikt BÃ¼nz, and Ben Fisch. 2018. Verifiable
Delay Functions. In Advances in Cryptology â€“ CRYPTO 2018, Hovav Shacham and
Alexandra Boldyreva (Eds.). Springer International Publishing, Cham, 757â€“788.
[13] Dan Boneh and Xavier Boyen. 2008. Short Signatures Without Random Oracles
and the SDH Assumption in Bilinear Groups. J. Cryptol. 21, 2 (2008), 149â€“177.
[14] Ethan Buchman, Jae Kwon, and Zarko Milosevic. 2019. The latest gossip on BFT
consensus. arXiv:1807.04938 [cs.DC]
[15] Vitalik Buterin and Virgil Griffith. 2019. Casper the Friendly Finality Gadget.
arXiv:1710.09437 [cs.CR]