IMM32
(deferred)
00007ffc`203e0000 00007ffc`205cd000
ntdll
(pdb symbols)
c:\symbols\ntd\
ll.pdb\E7EEB80BFAA91532B88FF026DC6B9F341\ntdll.pdb
The list of modules shows all modules (DLLs and the EXE) loaded into the debugged process at this time.
You can see the start and end virtual addresses into which each module is loaded. Following the module
name you can see the symbol status of this module (in parenthesis). Possible values include:
• deferred - the symbols for this module were not needed in this debugging session so far, and so
are not loaded at this time. The symbols will be loaded when needed (for example, if a call stack
contains a function from that module). This is the default value.
• pdb symbols - proper public symbols have been loaded. The local path of the PDB file is displayed.
• private pdb symbols - private symbols are available. This would be the case for your own modules,
compiled with Visual Studio. For Microsoft modules, this is very rare (at the time of writing,
combase.dll is provided with private symbols). With private symbols, you have information about
local variables and private types.
• export symbols - only exported symbols are available for this DLL. This typically means there are
no symbols for this module, but the debugger is able to use the exported sysmbols. It’s better than
no symbols at all, but could be confusing, as the debugger will use the closet export it can find, but
the real function is most likely different.
• no symbols - this module’s symbols were attempted to be located, but nothing was found, not even
exported symbols (such modules don’t have exported symbols, as is the case of an executable or
driver files).
You can force loading of a module’s symbols using the following command:
Chapter 5: Debugging and Tracing
81
.reload /f modulename.dll
This will provide definitive evidence to the availability of symbols for this module.
Symbol paths can also be configured in the debugger’s settings dialog.
Open the File / Settings menu and locate Debugging Settings. You can then add more paths for symbol
searching. This is useful if debugging your own code, so you would like the debugger to search your
directories where relevant PDB files may be found (see figure 5-3).
Figure 5-3: Symbols and source paths configuration
Make sure you have symbols configured correctly before you proceed. To diagnose any issues, you can
enter the !sym noisy command that logs detailed information for symbol load attempts.
Back to the thread list - notice that one of the threads has a dot in front of its data. This is the current
thread as far as the debugger is concerned. This means that any command issued that involves a thread,
where the thread is not explicitly specified, will work on that thread. This “current thread” is also shown
in the prompt - the number to the right of the colon is the current thread index (3 in this example).
Enter the k command, that shows the stack trace for the current thread:
0:003> k
# Child-SP
RetAddr
Call Site
00 00000001`224ffbd8 00007ffc`204aef5b ntdll!DbgBreakPoint
01 00000001`224ffbe0 00007ffc`1f647974 ntdll!DbgUiRemoteBreakin+0x4b
02 00000001`224ffc10 00007ffc`2044a271 KERNEL32!BaseThreadInitThunk+0x14
03 00000001`224ffc40 00000000`00000000 ntdll!RtlUserThreadStart+0x21
Chapter 5: Debugging and Tracing
82
How can you tell that you don’t have proper symbols except using the lm command? If you see
very large offsets from the beginning of a function, this is probably not the real function name
- it’s just the closest one the debugger knows about. “Large offsets” is obviously a relative term,
but a good rule of thumb is that a 4-hex digit offset is almost always wrong.
You can see the list of calls made on this thread (user-mode only, of course). The top of the call stack in the
above output is the function DbgBreakPoint located in the module ntdll.dll. The general format of
addresses with symbols is modulename!functionname+offset. The offset is optional and could be
zero if it’s exactly the start of this function. Also notice the module name is without an extension.
In the output above, DbgBreakpoint was called by DbgUiRemoteBreakIn, which was called by
BaseThreadInitThunk, and so on.
This thread, by the way, was injected by the debugger in order to break into the target forcefully.
To switch to a different thread, use the following command: ∼ns where n is the thread index. Let’s switch
to thread 0 and then display its call stack:
0:003> ~0s
win32u!NtUserGetMessage+0x14:
00007ffc`1c4b1164 c3
ret
0:000> k
# Child-SP
RetAddr
Call Site
00 00000001`2247f998 00007ffc`1d802fbd win32u!NtUserGetMessage+0x14
01 00000001`2247f9a0 00007ff7`5382449f USER32!GetMessageW+0x2d
02 00000001`2247fa00 00007ff7`5383ae07 notepad!WinMain+0x267
03 00000001`2247fb00 00007ffc`1f647974 notepad!__mainCRTStartup+0x19f
04 00000001`2247fbc0 00007ffc`2044a271 KERNEL32!BaseThreadInitThunk+0x14
05 00000001`2247fbf0 00000000`00000000 ntdll!RtlUserThreadStart+0x21
This is Notepad’s main (first) thread. The top of the stack shows the thread waiting for UI messages
(win32u!NtUserGetMessage). The thread is actually waiting in kernel mode, but this is invisible from
a user-mode debugger’s view.
An alternative way to show the call stack of another thread without switching to it, is to use the tilde and
thread number before the actual command. The following output is for thread 1’s stack:
Chapter 5: Debugging and Tracing
83
0:000> ~1k
# Child-SP
RetAddr
Call Site
00 00000001`2267f4c8 00007ffc`204301f4 ntdll!NtWaitForWorkViaWorkerFactory+0x14
01 00000001`2267f4d0 00007ffc`1f647974 ntdll!TppWorkerThread+0x274
02 00000001`2267f7c0 00007ffc`2044a271 KERNEL32!BaseThreadInitThunk+0x14
03 00000001`2267f7f0 00000000`00000000 ntdll!RtlUserThreadStart+0x21
The above call stack is very common, and indicates a thread that is part of the thread pool.
TppWorkerThread is the thread entry point for thread pool threads (Tpp is short for “Thread
Pool Private”).
Let’s go back to the list of threads:
.
0
Id: 874c.18068 Suspend: 1 Teb: 00000001`2229d000 Unfrozen
1
Id: 874c.46ac Suspend: 1 Teb: 00000001`222a5000 Unfrozen
2
Id: 874c.152cc Suspend: 1 Teb: 00000001`222a7000 Unfrozen
#
3
Id: 874c.bb08 Suspend: 1 Teb: 00000001`222ab000 Unfrozen
Notice the dot has moved to thread 0 (current thread), revealing a hash sign (#) on thread 3. The thread
marked with a hash (#) is the one that caused the last breakpoint (which in this case was our initial debugger
attach).
The basic information for a thread provided by the ∼ command is shown in figure 5-4.
Figure 5-4: Thread information for the ∼ command
Most numbers reported by WinDbg are hexadecimal by default. To convert a value to decimal, you can
use the ? (evaluate expression) command.
Type the following to get the decimal process ID (you can then compare to the reported PID in Task
Manager):
Chapter 5: Debugging and Tracing
84
0:000> ? 874c
Evaluate expression: 34636 = 00000000`0000874c
You can express decimal numbers with the 0n prefix, so you can get the inverse result as well:
0:000> ? 0n34636
Evaluate expression: 34636 = 00000000`0000874c
The 0y prefix can be used in WinDbg to specify binary values. For example, using 0y1100 is
the same as 0n12 as is 0xc. You can use the ? command to see the converted values.
You can examine the TEB of a thread by using the !teb command. Using !teb without an address shows
the TEB of the current thread:
0:000> !teb
TEB at 000000012229d000
ExceptionList:
0000000000000000
StackBase:
0000000122480000
StackLimit:
000000012246f000
SubSystemTib:
0000000000000000
FiberData:
0000000000001e00
ArbitraryUserPointer: 0000000000000000
Self:
000000012229d000
EnvironmentPointer:
0000000000000000
ClientId:
000000000000874c . 0000000000018068
RpcHandle:
0000000000000000
Tls Storage:
000001c93676c940
PEB Address:
000000012229c000
LastErrorValue:
0
LastStatusValue:
8000001a
Count Owned Locks:
0
HardErrorMode:
0
0:000> !teb 00000001`222a5000
TEB at 00000001222a5000
ExceptionList:
0000000000000000
StackBase:
0000000122680000
StackLimit:
000000012266f000
SubSystemTib:
0000000000000000
FiberData:
0000000000001e00
ArbitraryUserPointer: 0000000000000000
Self:
00000001222a5000
Chapter 5: Debugging and Tracing
85
EnvironmentPointer:
0000000000000000
ClientId:
000000000000874c . 00000000000046ac
RpcHandle:
0000000000000000
Tls Storage:
000001c936764260
PEB Address:
000000012229c000
LastErrorValue:
0
LastStatusValue:
c0000034
Count Owned Locks:
0
HardErrorMode:
0
Some data shown by the !teb command is relatively known or easy to guess:
• StackBase and StackLimit - user-mode current stack base and stack limit for the thread.
• ClientId - process and thread IDs.
• LastErrorValue - last Win32 error code (GetLastError).
• TlsStorage - Thread Local Storage (TLS) array for this thread (full explanation of TLS is beyond the
scope of this book).
• PEB Address - address of the Process Environment Block (PEB), viewable with the !peb command.
• LastStatusValue - last NTSTATUS value returned from a system call.
• The !teb command (and similar commands) shows parts of the real data structure behind the
scenes, in this case _TEB. You can always look at the real structure using the dt (display type)
command:
0:000> dt ntdll!_teb
+0x000 NtTib
: _NT_TIB
+0x038 EnvironmentPointer : Ptr64 Void
+0x040 ClientId
: _CLIENT_ID
+0x050 ActiveRpcHandle
: Ptr64 Void
+0x058 ThreadLocalStoragePointer : Ptr64 Void
+0x060 ProcessEnvironmentBlock : Ptr64 _PEB
...
+0x1808 LockCount
: Uint4B
+0x180c WowTebOffset
: Int4B
+0x1810 ResourceRetValue : Ptr64 Void
+0x1818 ReservedForWdf
: Ptr64 Void
+0x1820 ReservedForCrt
: Uint8B
+0x1828 EffectiveContainerId : _GUID
Notice that WinDbg is not case sensitive when it comes to symbols. Also, notice the structure name starting
with an underscore; this the way most structures are defined in Windows (user-mode and kernel-mode).
Using the typedef name (without the underscore) may or may not work, so always using the underscore
is recommended.
Chapter 5: Debugging and Tracing
86
How do you know which module defines a structure you wish to view? If the structure
is documented, the module would be listed in the docs for the structure. You can also try
specifying the structure without the module name, forcing the debugger to search for it.
Generally, you “know” where the structure is defined with experience and sometimes context.
If you attach an address to the previous command, you can get the actual values of data members:
0:000> dt ntdll!_teb 00000001`2229d000
+0x000 NtTib
: _NT_TIB
+0x038 EnvironmentPointer : (null)
+0x040 ClientId
: _CLIENT_ID
+0x050 ActiveRpcHandle
: (null)
+0x058 ThreadLocalStoragePointer : 0x000001c9`3676c940 Void
+0x060 ProcessEnvironmentBlock : 0x00000001`2229c000 _PEB
+0x068 LastErrorValue
: 0
...
+0x1808 LockCount
: 0
+0x180c WowTebOffset
: 0n0
+0x1810 ResourceRetValue : 0x000001c9`3677fd00 Void
+0x1818 ReservedForWdf
: (null)
+0x1820 ReservedForCrt
: 0
+0x1828 EffectiveContainerId : _GUID {00000000-0000-0000-0000-000000000000}
Each member is shown with its offset from the beginning of the structure, its name, and its value. Simple
values are shown directly, while structure values (such as NtTib above) are shown with a hyperlink.
Clicking this hyperlink provides the details of the structure.
Click on the NtTib member above to show the details of this data member:
0:000> dx -r1 (*((ntdll!_NT_TIB *)0x12229d000))
(*((ntdll!_NT_TIB *)0x12229d000))
[Type: _NT_TIB]
[+0x000] ExceptionList
: 0x0 [Type: _EXCEPTION_REGISTRATION_RECORD *]
[+0x008] StackBase
: 0x122480000 [Type: void *]
[+0x010] StackLimit
: 0x12246f000 [Type: void *]
[+0x018] SubSystemTib
: 0x0 [Type: void *]
[+0x020] FiberData
: 0x1e00 [Type: void *]
[+0x020] Version
: 0x1e00 [Type: unsigned long]
[+0x028] ArbitraryUserPointer : 0x0 [Type: void *]
[+0x030] Self
: 0x12229d000 [Type: _NT_TIB *]
The debugger uses the newer dx command to view data. See the section “Advanced Debugging with
WinDbg” later in this chapter for more on the dx command.
Chapter 5: Debugging and Tracing
87
If you don’t see hyperlinks, you may be using a very old WinDbg, where Debugger Markup Language
(DML) is not on by default. You can turn it on with the .prefer_dml 1 command.
Now let’s turn our attention to breakpoints. Let’s set a breakpoint when a file is opened by notepad.
• Type the following command to set a breakpoint in the CreateFile API function:
0:000> bp kernel32!createfilew
Notice the function name is in fact CreateFileW, as there is no function called CreateFile. In code,
this is a macro that expands to CreateFileW (wide, Unicode version) or CreateFileA (ASCII or Ansi
version) based on a compilation constant named UNICODE. WinDbg responds with nothing. This is a good
thing.
The reason there are two sets of functions for most APIs where strings are involved is a historical
one. In any case, Visual Studio projects define the UNICODE constant by default, so Unicode is
the norm. This is a good thing - most of the A functions convert their input to Unicode and call
the W function.
You can list the existing breakpoints with the bl command:
0:000> bl
0 e Disable Clear
00007ffc`1f652300
0001 (0001)
0:**** KERNEL32!CreateFileW
You can see the breakpoint index (0), whether it’s enabled or disabled (e=enabled, d=disabled), and you
get DML hyperlinks to disable (bd command) and delete (bc command) the breakpoint.
Now let notepad continue execution, until the breakpoint hits:
Type the g command or press the Go button on the toolbar or hit F5:
You’ll see the debugger showing Busy in the prompt and the command area shows Debuggee is running,
meaning you cannot enter commands until the next break.
Notepad should now be alive. Go to its File menu and select Open…. The debugger should spew details of
module loads and then break:
Chapter 5: Debugging and Tracing
88