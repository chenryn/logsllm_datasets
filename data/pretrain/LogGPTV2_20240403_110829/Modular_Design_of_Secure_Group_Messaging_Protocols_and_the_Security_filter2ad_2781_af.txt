// Store Key Bundle of a Contact
Get-KB(ID′, kb)
(wpk, spk, sig) ← kb
req spk ∈ CL-S[ID′]
req S-Ver(spk, wpk, sig)
CL-KB[ID′].enq((wpk, spk))
// Set Caller’s ID
ME ← ID
// Stored Sig. Keys
SK-sk[.] ← 𝜀
// Stored Wel. Keys
WK-wk[.] ← 𝜀
// Contact List
CL-KB[.] ← 𝜀
//
– Group Specific State –
// Buffered Props
s.Props[.] ← 𝜀
// Roster
s.G ← [.]
// CGKA State
s.𝛾 ← 𝜀
// PRF-PRG State
s.𝜎 ← 𝜀
// FS-GAEAD States
s.𝑣[.] ← 𝜀
// Current Epoch ID
s.C-epid ← 𝜀
// My Sig. Key
s.C-ssk ← 𝜀
// Verif. Keys
s.Ep-SPK[., .] ← 𝜀
s.km ← 𝜀
// MAC Key
Figure 6: The SGM Construction : Initialization and PKI Algo-
rithms.
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1474// Determines if authenticity of epoch vid compromised
*auth-compr(vid)
return ¬*PP-secure(vid, *Proj-PP(SGM-Data))
// Determines if ID’s signature key is compromised in epoch vid
*SK-compr(vid, ID)
chk HG.getSKIDs(vid, ID) ∩ SK-Lk = ∅
// Privacy Predicate
*AM-sec (vid, S, 𝑖)
if *PP-secure(vid, *Proj-PP(SGM-Data))
return *FS-sec((S, 𝑖), *Proj-FS(SGM-Data, vid))
return false
// Project History Graph to PRF-PRNG Game
*Proj-PP (SGM-Data = (V, P, V-Lk, AM-Lk, BR, WK-Lk))
for (vid, orig, data, pid) ∈ V
for vid ∈ V′
return (V′, V-Lk, BI)
V′ +← vid
BI[vid] ← ¬*CGKA-priv(vid′, *Proj-CGKA(SGM-Data))
// Project History Graph to CGKA Game
*Proj-CGKA (SGM-Data = (V, P, V-Lk, AM-Lk, BR, WK-Lk))
for (vid, orig, data, pid) ∈ V
V′ +← (vid, orig, pid)
for 𝑝 = (pid, vid, orig, op, data) ∈ V
if op = add
let data = (ID′, wkid′, skid′)
data′ ← (ID′, wkid′)
𝑝′ ← (pid, vid, op, orig, data′)
if op = rem
𝑝′ ← 𝑝
if op = upd
𝑝′ ← ⊥
P′ +← 𝑝′
return (V′, P′, V-Lk, BR, WK-Lk)
// Project History Graph to FS-GAEAD Game
*Proj-FS (SGM-Data = (V, P, V-Lk, AM-Lk, BR, WK-Lk), vid)
for (vid, ID, AM-Rcvd[ID], AM-Tr[ID]) ∈ AM-Lk
AM-Lk′ +← (ID, AM-Rcvd[ID], AM-Tr[ID])
return AM-Lk′
Figure 8: Safety oracles and safety predicate of the security
game for SGM schemes.
// Process a proposal
Proc-PM(P)
(P′, 𝑡, sig) ← P
(., epid, ID, ., .) ← P′
req epid = s.C-epid
spk ← s.Ep-SPK[epid, ID]
req M-Ver(s.km, P′, 𝑡)
req S-Ver(spk, (P′, 𝑡), sig)
s.Props +← P′
return *get-propInfo(P′)
// Send A Message
Send(𝑎, 𝑚)
𝐸 ← s.C-epid
(s.𝑣[𝐸], ¯𝑒) ← F-Send(s.𝑣[𝐸], (𝐸, 𝑎), 𝑚)
𝑒′ ← (𝐸, 𝑎, ¯𝑒)
sig ← S-Sign(s.C-ssk, 𝑒′)
return (𝑒′, sig)
// Process Commit Message
Proc-CM(T)
// Call CGKA
(T′, 𝑡, sig) ← T
(., epid, ID, h, ¯T) ← T′
// Matching Epochs?
req epid = s.C-epid
spk ← s.Ep-SPK[epid, ID]
req S-Ver(spk, (T′, 𝑡), sig)
P ← s.Props[h]
(s.𝛾, GI, 𝐼) ← K-Proc-Com(s.𝛾, ¯T)
(s.𝜎, 𝑘𝑒 , s.km, s.C-epid) ← PP(s.𝜎, 𝐼 , H(T′))
req M-Ver(s.km, T′, 𝑡)
s.G ← GI.G
𝑝𝑜𝑠 ← *roster-pos(ME, s.G)
s.𝑣[s.C-epid] ← F-Init(𝑘𝑒 , |s.G| , 𝑝𝑜𝑠)
s.Ep-SPK[s.C-epid, .] ←
*new-spks(s.Ep-SPK[epid, ·], P)
spk ← s.Ep-SPK[s.C-epid, ME]
s.C-ssk ← SK-sk[spk]
return GI
// Join a Group
Proc-WM(W)
// Start FS-GAEAD
(W′, 𝑡, sig) ← W
(., ID𝑠 , ., v,𝑊pub,𝑊priv, 𝑒, wpk, spk) ←
W′
spk ← spk[ID𝑠 ]
req
spk ∈ CL-S[ID𝑠 ] ∧ S-Ver(spk, W′, sig)
(esk, isk) ← WK-wk[wpk]
s.𝜎 ← E-Dec(esk, 𝑒)
(s.𝛾, GI, 𝐼) ← K-Join(ME, ID𝑠 ,𝑊pub,𝑊priv, isk)
(s.𝜎, 𝑘𝑒 , s.km, s.C-epid) ← PP(s.𝜎, 𝐼 , v)
req M-Ver(s.km, (W′, s.C-epid), 𝑡)
s.G ← GI.G
𝑝𝑜𝑠 ← *roster-pos(ME, s.G)
s.𝑣[s.C-epid] ← F-Init(𝑘𝑒 , |s.G| , 𝑝𝑜𝑠)
s.Ep-SPK[s.C-epid, .] ← spk
spk ← s.Ep-SPK[s.C-epid, ME]
s.C-ssk ← SK-sk[spk]
s.Props ← 𝜀
// Create a group
Create(spk, wpk; 𝑟)
s.G ← [ME]
wsk ← WK-wk[wpk]
(·, isk) ← wsk
(s.𝛾, 𝐼) ← K-Create(ME, isk; 𝑟)
(s.𝜎, 𝑘𝑒 , s.km, s.C-epid) ← PP(0, 𝐼 , 0)
s.Ep-SPK[s.C-epid, ME] ← spk
s.𝑣[s.C-epid] ← F-Init(𝑘𝑒 , 1, ME)
// Add proposal
Add(ID𝑎)
kb′ ← CL-KB[ID𝑎]
((epk, ipk), spk) ← kb′
(s.𝛾, ¯P) ← K-Add(s.𝛾, ID𝑎, ipk)
P′ ← ("add", s.C-epid, ME, (ID𝑎, kb′), ¯P)
𝑡 ← M-Tag(s.km, P′)
sig ← S-Sign(s.C-ssk, (P′, 𝑡))
return (P′, 𝑡, sig)
// Remove proposal
Remove(ID𝑟 )
(s.𝛾, ¯P) ← K-Remove(s.𝛾, ID𝑟 )
P′ ← ("rem", s.C-epid, ME, ID𝑟 , ¯P)
𝑡 ← M-Tag(s.km, P′)
sig ← S-Sign(s.C-ssk, (P′, 𝑡))
return (P′, 𝑡, sig)
// Update proposal
Update(spk; 𝑟)
req SK-sk[spk] ̸= 𝜀
(s.𝛾, ¯P) ← K-Update(s.𝛾; 𝑟)
P′ ← ("upd", s.C-epid, ME, spk, ¯P)
𝑡 ← M-Tag(s.km, P′)
sig ← S-Sign(s.C-ssk, (P′, 𝑡))
return (P′, 𝑡, sig)
// Receive A Message
Rcv(𝑎, 𝑒)
(𝑒′, sig) ← 𝑒
(epid, 𝑎, ¯𝑒) ← 𝑒′
(s.𝑣[epid], ID𝑠 , 𝑖, 𝑚) ← F-Rcv(s.𝑣[epid], (epid, 𝑎), ¯𝑒)
req ID𝑠 ̸= ⊥
spk ← s.Ep-SPK[epid, ID𝑠 ]
req S-Ver(spk, 𝑒′, sig)
return (epid, ID𝑠 , 𝑖, 𝑚)
// Commit
Commit(P; 𝑟)
//
// Commit Message
// Get CGKA Proposals
// New MAC Key & Epoch ID
– Prepare Commit Message –
req P ⊆ s.Props
¯P ← P.¯P
(s.𝛾,𝑊pub, WPrv, ¯T, 𝐼) ← K-Commit(s.𝛾, ¯P; 𝑟)
T′ ← ("com", s.C-epid, ME, H(P), ¯T)
v ← H(T′)
(., ., 𝑘𝑚, epid) ← PP(s.𝜎, 𝐼 , v)
𝑡 ← M-Tag(𝑘𝑚, T′)
sig ← S-Sign(s.C-ssk, (T′, 𝑡))
T ← (T′, 𝑡, sig)
(ID, wpk) ← *added(P)
spk ←
*new-spks(s.Ep-SPK[s.C-epid, ·], P)
for 𝑖 ∈ ID
𝑒 ← E-Enc(wpk[𝑖].epk, s.𝜎)
W′ ←
("wel", ME, ID[𝑖], v,𝑊pub, . . .
. . . , WPrv[𝑖], 𝑒, wpk[𝑖], spk)
𝑡 ← M-Tag(𝑘𝑚, (W′, epid))
sig ← S-Sign(spk[ME], (W′, 𝑡))
W[𝑖] ← (W′, 𝑡, sig)
– Prepare Welcome Messages –
// Welcome Message
//
return (epid, W, T)
Figure 7: The SGM Construction: main algorithms.
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1475REFERENCES
[1] J. Alwen, M. Capretto, M. Cueto, C. Kamath, K. Klein, G. Pascual-Perez, K. Pietrzak,
and M. Walter. Keep the dirt: Tainted treekem, an efficient and provably secure
continuous group key agreement protocol. IACR Cryptol. ePrint Arch., 2019:1489,
2019.
[2] J. Alwen, S. Coretti, and Y. Dodis. The double ratchet: Security notions, proofs,
and modularization for the Signal protocol. In Y. Ishai and V. Rijmen, editors,
EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 129–158. Springer, Hei-
delberg, May 2019.
[3] J. Alwen, S. Coretti, Y. Dodis, and Y. Tselekounis. Security analysis and improve-
ments for the IETF MLS standard for group messaging. In D. Micciancio and
T. Ristenpart, editors, CRYPTO 2020, Part I, volume 12170 of LNCS, pages 248–277.
Springer, Heidelberg, Aug. 2020.
[4] J. Alwen, S. Coretti, Y. Dodis, and Y. Tselekounis. Modular design of secure group
messaging protocols and the security of mls. Cryptology ePrint Archive, Report
2021/1083, 2021. https://ia.cr/2021/1083.
[5] J. Alwen, S. Coretti, D. Jost, and M. Mularczyk. Continuous group key agreement
[6] J. Alwen, D. Jost, and M. Mularczyk. On the insider security of MLS. IACR Cryptol.
[7] R. Barnes. Subject: [MLS] Remove without double-join (in TreeKEM), 2018.
with active security. In R. Pass and K. Pietrzak, editors, TCC 2020, 2020.
ePrint Arch., 2020:1327, 2020.
https://mailarchive.ietf.org/arch/msg/mls/Zzw2tqZC1FCbVZA9LKERsMIQXik.
[8] R. Barnes, B. Beurdouche, J. Millican, E. Omara, K. Cohn-Gordon, and R. Robert.
Internet-Draft draft-ietf-mls-
The Messaging Layer Security (MLS) Protocol.
protocol-11, Internet Engineering Task Force, Dec. 2020. Work in Progress.
[9] K. Bhargavan, B. Beurdouche, and P. Naldurg. Formal Models and Verified
Protocols for Group Messaging: Attacks and Proofs for IETF MLS. Research
report, Inria Paris, Dec. 2019.
[10] A. Bienstock, Y. Dodis, and P. Rösler. On the price of concurrency in group
[11] C. Brzuska, E. Cornelissen, and K. Kohbrok. Cryptographic security of the mls
ratcheting protocols. In R. Pass and K. Pietrzak, editors, TCC, 2020.
rfc, draft 11. Cryptology ePrint Archive, Report 2021/137, 2021.
[12] R. Canetti, J. A. Garay, G. Itkis, D. Micciancio, M. Naor, and B. Pinkas. Multicast
security: A taxonomy and some efficient constructions. In IEEE INFOCOM’99,
pages 708–716, New York, NY, USA, Mar. 21–25, 1999.
[13] K. Cohn-Gordon, C. Cremers, L. Garratt, J. Millican, and K. Milner. On ends-to-
ends encryption: Asynchronous group messaging with strong security guarantees.
In D. Lie, M. Mannan, M. Backes, and X. Wang, editors, ACM CCS 2018, pages
1802–1819. ACM Press, Oct. 2018.
[14] K. Cohn-Gordon, C. J. F. Cremers, B. Dowling, L. Garratt, and D. Stebila. A
formal security analysis of the signal messaging protocol. In 2017 IEEE European
Symposium on Security and Privacy, EuroS&P 2017, pages 451–466, 2017.
[15] C. Cremers, B. Hale, and K. Kohbrok. Revisiting post-compromise security
guarantees in group messaging. IACR Cryptol. ePrint Arch., 2019:477, 2019.
[16] Y. Dodis and N. Fazio. Public key broadcast encryption for stateless receivers. In
J. Feigenbaum, editor, Digital Rights Management, pages 61–80, Berlin, Heidelberg,
2002. Springer Berlin Heidelberg.
[17] E. Eaton, D. Jao, , and C. Komlo. Towards post-quantum updatable public-key
encryption via supersingular isogenies. Cryptology ePrint Archive, Report
2020/1593, 2020. https://eprint.iacr.org/2020/1593.
[18] A. Fiat and M. Naor. Broadcast encryption. In D. R. Stinson, editor, CRYPTO’93,
volume 773 of LNCS, pages 480–491. Springer, Heidelberg, Aug. 1994.
[19] Z. Jafargholi, C. Kamath, K. Klein, I. Komargodski, K. Pietrzak, and D. Wichs. Be
adaptive, avoid overcommitting. In J. Katz and H. Shacham, editors, CRYPTO 2017,
Part I, volume 10401 of LNCS, pages 133–163. Springer, Heidelberg, Aug. 2017.
[20] D. Jost, U. Maurer, and M. Mularczyk. Efficient ratcheting: Almost-optimal guar-
antees for secure messaging. In Y. Ishai and V. Rijmen, editors, EUROCRYPT 2019,
Part I, volume 11476 of LNCS, pages 159–188. Springer, Heidelberg, May 2019.
[21] Y. Kim, A. Perrig, and G. Tsudik. Group key agreement efficient in communication.
IEEE Trans. Computers, 53(7):905–921, 2004.
[22] H. Krawczyk. Cryptographic extraction and key derivation: The HKDF scheme.
In T. Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 631–648. Springer,
Heidelberg, Aug. 2010.
[23] Matthew A. Weidner. Group Messaging for Secure Asynchronous Collaboration.
Dissertation, 2019. https://mattweidner.com/acs-dissertation.pdf.
[30] C. K. Wong, M. Gouda, and S. S. Lam. Secure group communications using key
graphs. IEEE/ACM Transactions on Networking, 8(1):16–30, Feb. 2000.
Master’s thesis, University of Cambridge, June 2019.
[24] S. Mittra. Iolus: A framework for scalable secure multicasting. In Proceedings of
ACM SIGCOMM, pages 277–288, Cannes, France, Sept. 14–18, 1997.
[25] S. Panjwani. Tackling adaptive corruptions in multicast encryption protocols.
In S. P. Vadhan, editor, TCC 2007, volume 4392 of LNCS, pages 21–40. Springer,