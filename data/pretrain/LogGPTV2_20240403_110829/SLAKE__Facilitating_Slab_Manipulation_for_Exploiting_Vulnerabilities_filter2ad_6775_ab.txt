repeatedly adopted across vulnerabilities as well as their corre-
sponding system calls. From the perspective of adversaries, this not
only restricts the ways to perform exploitation but more impor-
tantly leads vulnerabilities unexploitable. From the viewpoint of
defenders, repeatedly-used data objects provide security analysts
with an opportunity to build intrusion signatures and thus ease
their identification for the potential intrusion.
❸ How to systematically adjust system calls to obtain the
desired slab layout? In fact, even if an adversary tracks down the
system calls for a particular object, it is still difficult for him to obtain
the desired memory layout. This is because, when allocating the
target object, in addition to the object of interest, the system calls
identified also allocate or deallocate other kernel objects, resulting
in unexpected variation in memory layout. Take the aforementioned
OOB case for example again. The OOB vulnerability provides an
adversary with the ability to overwrite critical data in its neighbor
object. Using a set of system calls, an adversary could allocate a
victim object containing a function or object pointer on the target
slab. However, along with the allocation of the victim object, the
system calls at the first place might allocate irrelevant kernel objects,
which makes the victim object turn out to be at an unexpected spot.
When this situation occurs, adversaries typically look for alternative
system calls or adjust memory layout in an ad-hoc manner. In
practice, there is no guarantee to find a memory layout through
these two approaches. As a result, the side effect involved by system
calls further reduces the number of system calls available and even
jeopardizes the exploitability of that vulnerability.
3 OBJECT & SYSCALL IDENTIFICATION
To tackle the aforementioned challenges ❶ and ❷, an instinct re-
action is to extensively enumerate system calls through a large
corpus of test cases or fuzz testing and, at the same time, observe
the change of objects on slab as well as keep track of function
pointer dereference. In this way, one could easily correlate the sys-
tem calls to the objects of his interest as well as corresponding
function pointer dereference. For the following two reasons, this
approach is however not suitable for our problem, even though a
similar idea has already been applied to explore memory layout
manipulation in the userland exploitation [15].
First, the code space of a Linux kernel is typically significantly
larger than that of a userland application. It is impossible for an
adversary to use regular test cases to identify all the sites where the
objects of his interest are (de)allocated and corresponding function
pointers are dereferenced. Second, Linux kernel contains hundreds
of system calls, each of which takes as input various arguments.
This makes it very inefficient to perform fuzz testing against various
system calls. As we will show in Section 6, even by using a state-
of-the-art kernel fuzzing tool, it is still difficult to track down the
objects of interest in an effective and efficient fashion.
In this section, we propose a new technical approach to tackle
the challenges ❶ and ❷ mentioned in the section above. At the
high level, our approach first identifies object types of our interest
by using static analysis. Using the type information and a set of
heuristics, our approach further pinpoints the objects of our in-
terest as well as the sites of our interest (i.e., the sites where the
objects are (de)allocated or corresponding pointers can be poten-
tially dereferenced). Along with this procedure, we record the name
of the object type, object size and the cache that holds the object.
In addition, we store the offset of function/object pointers in each
object. With these designs, we can obtain the basic information
for kernel objects. To be able to track down the system calls that
could (de)allocate and dereference the objects of our interest, our
approach performs kernel fuzzing under the guidance of a kernel
call graph. More specifically, we first perform reachability analysis
over the call graph and preserve only those system calls that could
potentially reach to the sites of our interest. With this, we can
reduce the number of system calls needed to explore and thus im-
prove the effectiveness and efficiency of system call identification.
For each site of our interest, we then perform fuzz testing using the
results of reachability analysis, exploring the actual path towards
that site. In this way, our approach can identify the arguments and
context needed for the system calls to (de)allocate and dereference
the object of our interest. In the following, we present the detail of
this approach.
3.1 Identifying Objects & Sites of Interest
In a Linux kernel, there are thousands of objects. However, they
are not equally critical for kernel exploitation. In the following, we
first introduce how we identify the kernel objects critical for ex-
ploitation. Then, we describe how we track down the sites at which
kernel (de)allocates these critical data objects. Finally, we discuss
how we identify the dummy sites where kernel could potentially
dereference a function pointer through an object of our interest (or
more precisely speaking a victim object).
3.1.1 Critical kernel objects. Given a kernel vulnerability, there
are two kinds of objects critical for the success of kernel exploita-
tion. One is the victim object typically used for exploiting OOB
and double free vulnerabilities. The other is the spray object gen-
erally used for facilitating the exploitation of UAF or double free
vulnerabilities.
Victim object. A victim object typically contains a function or an
object pointer. As is specified in Section 2.2.2, by overlaying this
object on a vulnerable object freed twice or placing this object adja-
cent to an object overflowed, an adversary might be able to leverage
the capability of the vulnerability to overwrite the pointer residing
in the object and thus obtain the control over kernel execution. In
this work, we, therefore, pinpoint victim objects by examining the
object types. To be specific, for each structure and union type in
kernel code, we examine whether it contains a function or an object
pointer. For those with a function pointer enclosed, we deem them
as victim objects. For those with an object pointer included, we track
down the type of the object that the pointer refers to by following
the dereference chain defined in each data object (e.g., objA->objB->
֒→ objC->...). We deem an object as a victim object if, through its
enclosed object pointers, we could perform multi-step dereference
and eventually identify a function pointer dereference (e.g.,objA->
֒→ objB->objC->fptr). It should be noted that, when identifying a
victim object by using multi-step dereference, we exclude struct
fields indicating a linked list (e.g., struct list_head) because such
dereference chain forms a circle which could cause our approach
to enter an unterminated procedure.
Spray object. The usages of a spray object include ❶ taking over
the slot of a freed object ś still referenced by a dangling pointer
ś as well as ❷ overwriting the content of that freed object. As a
result, a spray object does not have to contain a function or object
pointer but provides an adversary with the ability to copy arbitrary
data from userland to kernel slab. In this work, we follow this
characteristic and track down spray objects in kernel source code
as follows. First, we retrieve the argument dst of the kernel function
copy_from_user(void *dst, void *src, unsigned long length). Then, we
examine if the pointer dst is the return value of a slab allocation
function such as kmalloc() and kmem_cache_alloc().
3.1.2 Allocation and deallocation sites. In kernel exploitation,
we usually allocate and free critical objects on the slab. In order
to identify the system calls that can truly allocate or free a critical
object, we first pinpoint the sites of (de)allocation in the kernel
code source.
Allocation sites. For the functions taking the responsibility of
allocation (e.g., kmalloc()), their return value is typically of type
łvoid*ž. By looking at the site of a function call, it is therefore
difficult to know whether that allocation site ties to an object of
our interest (e.g., a victim or spray object). In order to solve this
problem, we examine the def-use chain of the return value for each
allocation function and deem the site of an allocation call as a site
of allocation if and only if that return value is cast to the type
identified.
Deallocation sites. For the kernel functions associated with deal-
location (e.g., kfree()), they typically take as input the pointer of
an object. Similar to the way to pinpoint allocation sites, we can,
therefore, track down the deallocation sites tied to victim object by
looking at the type of the object pointer passed to the deallocation
function.
3.1.3 Dummy dereference sites. For many kernel exploitation
methods, an adversary needs to dereference a function pointer
through a victim object. This typically means two different situa-
tions. One is to dereference a function pointer residing in a victim
object, and the other is to dereference a function pointer through a
multi-step dereference chain (e.g., the example shown in Figure 1a).
Technically, it is challenging to pinpoint these dereference sites in
the kernel source code through a static interprocedural data flow
analysis. On the one hand, this is because a static interprocedural
data flow analysis needs to be performed on a control flow graph
(CFG) and it is difficult to build an accurate kernel CFG. On the other
hand, this is because Linux kernel has a soft interrupt mechanism
such as Read-Copy Update (RCU), which deallocates an object and
thus dereferences a function pointer in an asynchronous fashion.
To address the problem above, we first define and identify dummy
dereference sites in Linux kernel source code. Then, we use a fuzz
testing and a dynamic data flow analysis to track down the true
dereference sites along with the corresponding system calls. In
this paper, we describe our dynamic analysis and fuzz testing in
Section 3.2.2. In the following, we describe how we define and iden-
tify dummy dereference sites. Regarding the function dereference
through an RCU mechanism, we deem the statements pertaining
to the RCU free (e.g., kfree_call_rcu() and call_rcu_sched()) as the
dummy dereference sites. This is because when these kernel func-
tions are invoked to deallocate a corresponding victim object, in an
asynchronous manner, the Linux kernel will invoke the function
referred by the function pointer residing in that victim object. With
respect to non-RCU-related dereference, we treat the dereference
of the enclosed pointer as our dummy dereference site. For exam-
ple, given a victim object A containing a pointer ptr, we deem the
dereference of the pointer ptr as our dummy dereference site.
3.2 Finding System Calls
The aforementioned static analysis approach gives us the ability
to identify at which sites a particular type of objects could be
(de)allocated (or at which sites pointers in those objects could be
dereferenced). However, it does not provide us with the information
of what system calls and their arguments we should use to inter-
act with these objects and pointers. To address this problem, one
instinctive reaction is to directly perform kernel fuzzing, through
which we could explore the system calls pertaining to the sites of
our interest. However, such an approach is not sufficiently helpful
for exploit development. As we will describe in Section 4, in order
to perform a successful kernel exploitation, an adversary usually
needs to free an object intentionally allocated for obtaining a de-
sired memory layout. In addition, he needs to dereference a function
pointer in an intentionally-allocated victim object. By simply using
kernel fuzzing, an adversary could identify the system calls and
their arguments that could deallocate the type of objects we are
interested in (or dereference the pointers of our interest). However,
this approach neither guarantees we truly deallocate the objects
we intentionally allocate nor ensure we actually dereference the
function pointer in the intentionally-allocated victim object. For
example, using the aforementioned static analysis technique, we
identify one type of object that could be potentially helpful for
exploitation. By using a sequence of system calls, we can allocate
an object A in that type to a target slot. In the memory, there have
already been multiple objects that share the same data structure as
the object A. When using fuzz testing to explore the deallocation
sites of our interest and expect the deallocation of that object A,
we might encounter a situation where the fuzz testing hits the site
of the deallocation (identified through static analysis) but actually
free a different object sharing the same type as the object A. To
tackle this issue, we develop an alternative approach that employs
an under-context fuzzing approach along with dynamic data flow
analysis to identify the system calls and corresponding arguments.
In the following, we provide the detail of this approach.
3.2.1 Panic Anchors Setup. To be able to determine whether
a system call triggers a site of our interest through fuzz testing,
we instrument kernel source code and insert panic anchors (i.e.,
customized kernel panic functions) right behind each site of our
interest. With these anchors, when kernel execution reaches the
site of our interest, we can terminate kernel execution and trace
back to the system calls and their arguments tied to corresponding
sites. However, such a trivial approach inevitably introduces false
positives. Linux kernel is a highly complex system. At the runtime,
in addition to system calls under a user’s control, many other ker-
nel routines could also trigger execution to our anchor sites, e.g.,
exception signals from processes, interrupt signals from peripheral
devices, and other kernel threads or userland processes. Without an
ability to distinguish these irrelevant kernel routines, we inevitable
introduce false positives (i.e., identifying the system calls not truly
pertaining to object (de)allocation or pointer dereference).
In order to address this issue, we therefore augment our panic
anchors with the ability to eliminate false positives. To be spe-
cific, inside each panic anchor, we first examine the kernel variable
system_state, representing the state of the kernel execution. The
panic anchor performs termination only if the value of this variable
is equal to SYSTEM_RUNNING. This is because this value indicates the
kernel is currently processing a system call requested from the
userland but not responding to other kernel routines. In addition to
the examination of kernel execution state, we check the field comm
in the data structure task_struct. The value of this field specifies the
userland program that triggers the current system call. By checking
this value, we can easily determine whether the site of the interest
is reached through the system call invoked by our fuzzing program
and thus prevent the situation where the site of our interest is hit
through other userland programs. In addition to the examination
above, we store the addresses of the objects allocated. As we will
specify in Section 3.2.2, along with under-context fuzzing, these
addresses could help us pinpoint the system calls that truly free or
dereference the objects we intentionally allocate.
3.2.2
Syscall Identification. As is mentioned above and evalu-
ated in Section 6, when identifying system calls for object (de)allocation
and pointer dereference, it is very ineffective and inefficient to ex-
haustively test various system call combinations. In this work, we
address this problem by using the method below. First, we build
a kernel call graph and perform reachability analysis from our
target (de)allocation and dereference sites. Based on the result of
reachability analysis, we then preserve only the system calls, which
could potentially reach the sites of our interests and do not require
the administrative privilege (i.e., CAP_SYS_ADMIN). In this work, we
perform fuzzing against kernel by using a system call sequence
produced from these identified system calls based on dependency
information for object (de)allocation and pointer dereference. In
the following, we provide the detail of our system call identification
method.
Syscalls for allocation. To identify the system calls tied to critical
object allocation, we perform fuzz testing against a Linux kernel.
When a test case triggers an anchor site tied to object allocation, we
profile each of the system calls by recording the kernel objects that
every individual system call (de)allocates on the slab. In addition,
we log the system calls in the test case and record their arguments
accordingly. In this work, we construct a database to store these
pieces of information. They are used for facilitating the manipula-
tion of slab layout and under-context fuzzing. In the Appendix, we
provide more details about the information stored in our database.
Syscalls for deallocation. When exploring the system calls tied
to object deallocation, we first allocate a target kernel object by
using the system calls identified through our fuzz testing. Under
this context, we then log the address of that target object and
perform fuzz testing. When a deallocation site is triggered by a test
case generated by kernel fuzzer, we check whether the address of
that deallocation object matches the address logged previously, and
preserve the corresponding system calls only if a match is identified.
With this design, we can ensure the system calls identified can
truly deallocate the object that we intentionally allocate previously.
Similarly, in addition to storing system calls and their arguments,
we profile the system calls in the test case and store corresponding
information in our database.
Syscalls for dereference. To identify the system calls that could
dereference a function pointer through a target victim object, we
first allocate that target victim object through the system calls
identified. Under that context, we then perform kernel fuzzing
and explore the system calls that can reach to the corresponding
dummy dereference site. When a test case generated by kernel
fuzzer triggers the dummy dereference site, we continue kernel
execution and record each of the statements executed (i.e., execution
trace) until kernel execution exits the current function. Using the
execution trace, we build a use-define chain on which we identify
all the function pointer dereferences, trace back through the chain
and examine whether the dereference comes through the victim
object that we allocate. Again, after confirming the dereference, we
archive system calls and their arguments in our database.
4 LAYOUT MANIPULATION
The aforementioned database provides an attacker with the fa-
cilitation of identifying the system calls tied to the kernel object
(de)allocation as well as the way to dereference corresponding func-
tion pointers. However, the kernel exploitation still lacks the ability
to systematically adjust system calls so that one could obtain the de-
sired memory layout (i.e., the challenge ❸ mentioned in Section 2.3).
To address this issue, we first seek through the aforementioned
database, matching a vulnerability capability with corresponding
objects. For each vulnerability and object pair, we then manipulate
slab by using a layout adjustment approach and thus obtain the
desired layout for kernel exploitation. In the following, we describe
the technical details.
4.1 Matching Vulnerability Capability
Recall that Section 2.2.2 describes four approaches commonly adopted
in Linux kernel exploitation. When using these approaches, an at-
tacker has to not only (de)allocate kernel objects but, more impor-
tantly, ensure the vulnerability gives him the ability to overwrite
critical data. In order to pinpoint the kernel objects from the data-
base that matches the capability of a vulnerability, we first model
the capability of a vulnerability as well as the property of a data ob-
ject. Guided by our modeling, we then design a technical approach
to pairing objects with corresponding vulnerabilities.
4.1.1 Modeling Vulnerability and Object. Given a vulnerability,
we describe the capability of that vulnerability by using the array
Ar [m]. This array contains m elements, each of which specifies
a memory region under an attacker’s control. As is depicted in
Figure 2a, each element contains a pair (l , h). It indicates the start
and end offsets corresponding to the base address of a victim or
spray object. In between the offsets, an attacker could overwrite
data freely. As we can see from the figure, the element in the array
has no overlaps (i.e., ∀i, j, 1 ≤ i, j ≤ m, i , j, Ar [i].h < Ar [j].l or
Ar [j].h < Ar [i].l).
In addition to the capability of a vulnerability, we describe the
property of a kernel object by using the array Ap [n]. This array
consists of n elements and each of them specifies the memory region
where critical data (i.e., pointers and metadata) are actually located.
As is illustrated in Figure 2b, each element in Ap [n] represents an
offset corresponding to the base address of a victim object. Through
the offset along with the word size2 w, we can easily pinpoint the
memory area (Ap [i] ∼ Ap [i] + w) at which the it h pointer is stored.
2The word sizes are 8 and 4 bytes for a 64-bit and 32-bit machine, respectively.
4.1.2 Pairing Vulnerability with Object. For various kernel vul-
nerabilities, we design different criteria and automated approaches
to pair kernel objects with the capability of a kernel vulnerability.
In the following, we describe the criteria. Due to the space limit,
we leave the automated approach in Appendix.
OOB write. Given a vulnerability with an OOB write capability,
there are two approaches to performing slab manipulation. One
is to directly overwrite the metadata of a freed object and then
allocate a victim object to a memory region under an attacker’s
control. The other is to place a victim object adjacent to the vul-
nerable object with the expectation of overwriting critical data
(data or function pointers) residing in the victim object. For the
first approach, the selection of victim objects is straightforward.
The victim object could be any object that shares the same cache
with the vulnerable object and encloses a pointer. For the second
approach, the selection of victim objects is slightly complicated.
To select the victim objects suitable for exploitation, we examine
whether a memory region in the array Ap [n] is included within one
of the memory regions indicated by the array Ar [m]. We select data
objects and the corresponding system calls from the database for
memory layout manipulation based on the following two criteria.
First, the object of our selection must be capable of being allocated
at the cache same as the vulnerable object. Second, we must be able
to identify an overlap successfully (see the example in Figure 3a).
Use After Free. Given a UAF vulnerability, there are also two
typical approaches to performing slab manipulation. One approach
is to leverage the power of that vulnerability to modify metadata
and then allocate an arbitrary victim object to the target address
specified by that tampered metadata. The other approach is to
overlay a spray object on top of a vulnerable object, overwrite
that pointer and dereference that pointer for exploitation. For the
first approach, the selection criterion of data objects is to simply
have the selected victim data object share the same cache as the
vulnerable object. For the second approach, the selection of data
objects could be viewed as the identification of the spray objects.
The criteria of spray object selection are to ❶ guarantee the spray
object could be allocated in the same cache as the vulnerable object
and ❷ ensure at least one field in the array Ap [n] overlaps one of
the memory regions indicated by the array Ar [m] (see the example
in Figure 3b).
Double Free. For vulnerabilities in double free, similar to the afore-
mentioned two vulnerability types, there are also two approaches to
manipulate slab. One is to overlay a victim and then a spray object
on top of the vulnerable object with the expectation of overwriting
a pointer residing in that victim object. The other is to overlay
a spray object on the vulnerable object with the expectation of
overwriting the metadata of that vulnerable object. With respect to
the first approach, the selection of data objects is to find a victim
object and then pair it with a spray object. Similar to the UAF, this
must follow two criteria. First, victim, spray and vulnerable objects
all have to share the same cache. Second, after we align all three
objects, the spray object must cover at least one memory region
indicated by an element of the array Ap [n]. Regarding the second
approach, the selection task can be viewed as the identification of
spray object, which has to follow the criteria ś ❶ both vulnerable
and spray objects share the same cache and ❷ the metadata field
of the vulnerable object must overlap the spray object.