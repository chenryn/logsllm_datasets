3.  如果您想要对部署进行更改，比如通过将`replicas`的编号更改为`2`，您将首先修改`deployment.yaml`文件:
    ```
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: busybox
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: busybox
      template:
        metadata:
          labels:
            app: busybox
        spec:
          containers:
            - name: main
              image: busybox
              args:
                - sleep
                - infinity
    ```
4.  You would then apply the change with `kubectl apply`:
    ```
    kubectl apply -f deployment.yaml
    ```
    运行该命令后，Kubernetes 会将提供的部署声明应用于之前应用的`deployment`。此时，应用将从`1`的`replica`值扩展到`2`。
5.  当涉及到删除一个应用时，Kubernetes 文档实际上建议以一种命令式的方式这样做；也就是说，使用`delete`子命令代替`apply` :
    ```
    kubectl delete -f deployment.yaml
    ```
6.  通过传入`-f`标志和文件名，可以将`delete`子命令变得更加声明性。这给了`kubectl`要删除的资源的名称，该名称在一个特定的文件中声明，并且它允许开发人员使用声明性的 YAML 文件继续管理资源。
了解了 Kubernetes 资源是如何创建的，现在让我们讨论一下资源配置中涉及的一些挑战。
# 资源配置挑战
在前一节中，我们介绍了 Kubernetes 如何有两种不同的配置方法——命令式和声明式。需要考虑的一个问题是，当使用命令式和声明式方法创建 Kubernetes 资源时，用户需要意识到哪些挑战？
让我们讨论一些最常见的挑战。
## 库伯内特资源的多种类型
首先，Kubernetes 有很多、*很多*不同的资源。以下是开发人员应该了解的资源的简短列表:
*   部署
*   StatefulSet
*   服务
*   进入
*   ConfigMap(配置地图)
*   机密
*   存储类
*   PersistentVolumeClaim
*   请参阅〈t0 服务帐户〉
*   作用
*   角色绑定
*   命名空间
开箱即用，在 Kubernetes 上部署应用并不像按一个标有`Deploy`的红色大按钮那么简单。开发人员需要能够确定部署他们的应用需要哪些资源，并且他们需要在足够深的层次上理解这些资源，以便能够适当地配置它们。这需要大量的平台知识和培训。虽然理解和创建资源听起来已经是一个很大的障碍，但这实际上只是许多不同运营挑战的开始。
## 保持实时状态和本地状态同步
我们鼓励的一种配置 Kubernetes 资源的方法是在源代码管理中维护它们的配置，供团队编辑和共享，这也允许源代码管理存储库成为真理的来源。源代码管理中定义的配置(称为“本地状态”)然后通过将它们应用于 Kubernetes 环境来创建，资源变为“活动”或进入所谓的“活动状态”这听起来很简单，但是当开发人员需要对他们的资源进行更改时会发生什么呢？正确的答案应该是修改本地文件，并应用这些更改来同步本地状态和活动状态，以努力更新真相的来源。然而，这并不是通常会发生的事情。短期内，用`kubectl patch`或`kubectl edit`就地修改实时资源，完全跳过修改本地文件，往往更简单。这导致了本地状态和活动状态之间的状态不一致，这种行为使得 T4 很难在 Kubernetes 上进行缩放。
## 应用生命周期难以管理
生命周期管理是一个负载术语，但是在这个上下文中，我们将它称为安装、升级和回滚应用的概念。在 Kubernetes 世界中，安装会创建资源来部署和配置应用。初始安装将创建我们在这里称之为应用的`version 1`。
因此，升级可以被认为是对一个或多个 Kubernetes 资源的编辑或修改。每一次`batch`的编辑都可以被认为是一次升级。开发人员可以修改单个服务资源，这将把版本号提升到`version 2`。开发人员然后可以修改部署、配置图和服务，将版本计数调整到`version 3`。
随着较新版本的应用继续在 Kubernetes 上推出，跟踪已经发生的变化变得更加困难。在大多数情况下，Kubernetes 没有保存变化历史的固有方式。虽然这使得升级更难跟踪，但也使得恢复应用的早期版本更加困难。假设一个开发人员先前对某个特定资源进行了不正确的编辑。团队如何知道回滚到哪里？`n-1`的情况特别容易解决，因为那是最近的版本。然而，如果最新的稳定版本是五个版本之前，会发生什么？团队最终通常会争先恐后地解决问题，因为他们无法快速识别以前有效的最新稳定配置。
## 资源文件是静态的
这是一个挑战，主要影响应用 YAML 资源的声明性配置风格。遵循声明性方法的一部分困难是 Kubernetes 资源文件不是为参数化而设计的。资源文件在很大程度上被设计成在被应用之前被完全写出，并且在文件被修改之前，内容仍然是真实的来源。与 Kubernetes 打交道时，这可能是一个令人沮丧的现实。一些 API 资源可能很长，包含许多不同的可定制字段，完整地编写和配置 YAML 资源可能会非常麻烦。
静态文件容易变成样板文件。样板表示在不同但相似的上下文中基本保持一致的文本或代码。如果开发人员管理多个不同的应用，他们可能会管理多个不同的部署资源、多个不同的服务等等，这就成为一个问题。在比较不同应用的资源文件时，您可能会发现它们之间有大量相似的 YAML 配置。
下图描述了两个资源之间具有重要样板配置的示例。蓝色文本表示样板行，而红色文本表示唯一的行:
![Figure 1.5: An example of two resources with boilerplate ](img/Figure_1.5.jpg)
图 1.5 -带有样板文件的两个资源的例子
请注意，在本例中，每个文件几乎完全相同。当管理与此类似的文件时，样板文件成为以声明方式管理应用的团队的主要难题。
# 掌舵救援！
随着时间的推移，Kubernetes 社区发现创建和维护 Kubernetes 资源来部署应用是很困难的。这促使开发了一个简单而强大的工具，允许团队克服在 Kubernetes 上部署应用带来的挑战。创建的工具称为 Helm。Helm 是一个开源工具，用于在 Kubernetes 上打包和部署应用。它通常被称为**Kubernetes 包管理器**，因为它与您在最喜欢的操作系统上找到的任何其他包管理器相似。Helm 在整个 Kubernetes 社区广泛使用，是一个 CNCF 毕业的项目。
鉴于 Helm 与传统包管理器的相似之处，让我们首先回顾包管理器是如何工作的，从而开始探索 Helm。
## 了解包装经理
包管理器用于简化安装、升级、恢复和删除系统应用的过程。这些应用是以单位定义的，称为**包**，其中包含目标软件及其依赖关系的元数据。
包管理器背后的过程很简单。首先，用户传递软件包的名称作为参数。然后，包管理器对包存储库执行查找，以查看该包是否存在。如果找到，包管理器会将包定义的应用及其依赖项安装到系统上的指定位置。
包管理器使得管理软件变得非常容易。举个例子，假设你想在一台 Fedora 机器上安装`htop`，一个 Linux 系统监视器。安装它就像键入一个命令一样简单:
```
dnf install htop --assumeyes	
```
这指示自 2015 年以来的 Fedora 包管理器`dnf`在 Fedora 包存储库中找到`htop`并安装。`dnf`还负责安装`htop`包的依赖项，因此您不必担心事先安装它的需求。在`dnf`从上游存储库中找到`htop`包后，它会询问您是否确定要继续。`--assumeyes`标志自动回答`yes`这个问题以及`dnf`可能提出的任何其他提示。
随着时间的推移，`htop`的更新版本可能会出现在上游存储库中。`dnf`和其他软件包管理器允许用户高效地升级到软件的新版本。允许用户使用`dnf`升级的子命令是升级:
```
dnf upgrade htop --assumeyes
```
这指示`dnf`将`htop`升级到最新版本。它还将其依赖项升级到包元数据中指定的版本。
虽然向前移动通常更好，但包管理器也允许用户向后移动，并在必要时将应用恢复到以前的版本。`dnf`使用`downgrade`子命令执行此操作:
```
dnf downgrade htop --assumeyes
```