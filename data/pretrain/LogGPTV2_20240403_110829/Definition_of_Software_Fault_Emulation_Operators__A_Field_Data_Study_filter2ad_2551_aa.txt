# Definition of Software Fault Emulation Operators: A Field Data Study

**Authors:**
- João Durães, Polytechnic Institute of Coimbra; ISEC; CISUC, Coimbra, Portugal (Email: [PI:EMAIL])
- Henrique Madeira, University of Coimbra; DEI; CISUC, Coimbra, Portugal (Email: [PI:EMAIL])

## Abstract
Residual faults in Commercial Off-The-Shelf (COTS) components can pose a significant risk of system outages. This paper introduces a set of operators for software fault emulation through low-level code mutations. The development of these operators was based on the analysis of a comprehensive collection of real software faults. Using the Orthogonal Defect Classification (ODC) as a starting point, we classified faults in detail according to the high-level constructs where they occur and their effects on the program. We observed that a large percentage of faults fall into well-defined classes, allowing for precise emulation through a small set of mutation operators. These operators closely emulate a wide range of common programmer mistakes. Additionally, since the mutation is performed directly at the executable code level, software faults can be injected into targets for which the source code is not available.

## 1. Introduction
Software faults are recognized as the primary cause of computer system failures, as evidenced by several research studies [14, 22, 28]. As systems become more complex, it becomes increasingly challenging to avoid these faults, leading to a greater impact on overall system dependability. It is now widely accepted that deployed software products often contain hidden defects, which, when activated, can have unforeseen consequences.

Eliminating all software faults during the development stages is extremely difficult due to both intrinsic technical challenges and external pressures such as tight deadlines. A recent trend in the industry is the increased use of COTS components, which are not specifically designed for a particular application. However, the strong interaction between COTS components and other parts of a larger system can exacerbate the problem.

The emulation of software fault effects through fault injection has been recognized as a powerful tool to improve software reliability [6, 31]. This technique can be used to:
- Predict worst-case scenarios and assess risks.
- Validate fault-tolerant mechanisms.
- Establish dependability benchmarks.

However, emulating software faults presents several technical challenges, particularly in achieving accurate fault emulation. The ODC provides a basis for understanding and classifying software faults, but it relates faults to how they are corrected. For accurate fault emulation, a closer examination of the exact nature of the faults is necessary.

Field data on real software faults is a valuable resource, but such data is not commonly available, and research using real faults is relatively rare. This paper presents the results of an analysis of over 500 real software faults, providing insights into important fault properties and their relationship with high-level language structures and program execution. We propose the emulation of the most frequently observed faults through a set of fault emulation operators that inject faults directly into the target executable code. Our operators differ from traditional mutation operators in that they work directly on the executable code and aim to emulate residual software faults rather than identify the best sets of test cases.

The remainder of this paper is organized as follows: Section 2 presents related research; Section 3 details the collected faults and their analysis; Section 4 discusses how these faults can be emulated using a low-level code mutation injection technique; and Section 5 concludes the paper.

## 2. Related Work
Most research on software faults focuses on the development phase, with many studies aiming to mitigate the problem of residual faults through software reliability modeling and risk analysis [23, 25]. Fault history, operational profiles, and other process measures have been used in reliability models to estimate software reliability and predict faults for risk assessment [15, 20, 25].

Significant studies on software dependability in Tandem systems [14, 22] and the impact of software defects on the availability of large IBM systems [28] highlight the importance of understanding and mitigating software faults. An early study [17] investigated the effect of workload on the reliability of an IBM operating system based on field data.

The idea that mutations and actual software faults produce similar error patterns and program behavior is supported by [8], where 85% of the errors generated by mutations were also produced by real faults. This suggests that improving the accuracy of fault emulation can bridge the gap between emulated and real faults.

Fault injection has become a popular approach for experimentally evaluating fault handling mechanisms and assessing the impact of faults on systems. Tools like Ferrari [18], FTAPE [29], Xception [4], and Goofi [1] are examples, but they are primarily designed for hardware fault emulation and have limited potential for emulating software faults.

Other techniques inject faults by corrupting API call parameters [13, 21], but they do not directly emulate software faults. Emulation of common programmer mistakes has been recognized as a good approach for software fault emulation [26, 27], and such faults were used in a study of operating system robustness [10].

Works more directly related to our study include [6, 7, 24, 9]. The study in [6] proposed rules for injecting errors that emulate software faults based on field data, but these rules require the availability of field data on real faults found in the target system, which is often not available. In our work, we generalized the analysis of field data to define general-purpose fault emulation operators, removing the need for specific field data. Furthermore, our operators can be used on executable software modules without access to the source code.

Previous works from our group [7, 24] evaluated the possibilities of emulating software faults using classical fault injection tools. However, these methods are intrusive and cannot fully emulate complex software faults. A technique for emulating software faults using low-level code mutation, named G-SWFIT (Generic Software Fault Injection Technique), was presented in [9]. G-SWFIT modifies the executable code of the target to recreate the effects of a given software fault in the high-level source code. Because the target code modification is done prior to execution, intrusiveness is not an issue, and complex code mutations can be performed, allowing the emulation of complex software faults. The accuracy of G-SWFIT compared to high-level mutation was experimentally shown to be good [9].

The analysis of field software faults in the first part of this paper is independent of any specific fault emulation technique, while the subsequent elaboration on how such faults can be emulated is aimed at G-SWFIT and extends our previous work [9].

## 3. Field Study and Software Fault Classification
We obtained real faults from a large set of patch and diff files of several open-source programs written in C (see Table 1). The source code in these files was analyzed to understand and classify the faults. A total of 532 faults were analyzed, covering a broad range of program types, including user programs (both interactive and command line) and operating system code.

### 3.1 Fault Classification Methodology
Our approach to classifying and analyzing the faults was as follows:
1. **Initial Classification:** We classified the faults according to ODC. Using a general and well-accepted fault classification allows us to make our results available to the research community and compare them with previous field studies.
2. **Grouping by Nature of Defect:** We grouped the faults according to the nature of the defect, defined from a building block programming perspective. For each ODC class, a software fault is characterized by one programming language construct that is missing, incorrect, or superfluous.
3. **Final Classification:** Faults were further refined and classified into specific types. This final classification is used to define fault emulation operators.

### 3.2 ODC Classification and General Analysis
The following fault types in ODC are directly related to the code, describing software faults as defined in this context:
- **Assignment:** Values assigned incorrectly or not assigned at all.
- **Checking:** Missing or incorrect validation of data or incorrect loop or conditional statements.
- **Interface:** Interaction errors among components, modules, device drivers, call statements, or parameter lists.
- **Timing/Serialization:** Missing or incorrect serialization of shared resources.
- **Algorithm:** Incorrect or missing implementation that can be fixed by (re)implementing an algorithm or data structure without a design change.
- **Function:** Affects a sizeable amount of code and refers to capabilities that are either implemented incorrectly or not implemented at all.

Since the field data available to us did not include information on timing or serialization properties, we did not consider the Timing/serialization type. Table 2 presents the distribution of faults across the five ODC fault types addressed in this work.

#### Table 2 - Fault Distribution Across ODC Types
| ODC Type       | Number of Faults | ODC Class Distribution (%) |
|----------------|------------------|----------------------------|
| Assignment     | 118              | 22.1 (21.98)               |
| Checking       | 137              | 25.7 (17.48)               |
| Interface      | 43               | 8.0 (8.17)                 |
| Algorithm      | 198              | 37.2 (43.41)               |
| Function       | 36               | 6.7 (8.74)                 |

We compared our fault distribution with the one presented in [6] because it is the most closely related work. Since that work included Time/Serialization faults, we normalized all percentages, leaving out that fault type to allow for a direct comparison. The values presented in [6] are those inside the parentheses in Table 2.

It is noteworthy that both our fault distribution and that presented in [6] show the same trend in the fault distribution across ODC fault types. The fact that independent research works obtained a similar fault distribution suggests that this distribution is representative of programs in general. Furthermore, the programs analyzed in [6] were quite different from those used in our study, indicating that this fault distribution over ODC types is reasonably independent of the nature of the program, programming language, and processor. Although more field studies are required to consolidate this conclusion, it seems reasonable that faultloads designed to emulate software faults should take this fault trend into account.

The fault distribution observed for each individual program is presented in Table 3. We observed that programs with a significant number of faults show a similar ODC fault distribution, reinforcing the suggestion that software faults follow a clear pattern of distribution across ODC types.

#### Table 3 - Fault Distribution Across ODC Types by Program
| ODC Type →→→→ | Assign. | Check. | Interf. | Alg. | Func. | Programs # Faults |
|----------------|---------|--------|---------|------|-------|-------------------|
| CDEX           | 0.0%    | 40.0%  | 18.2%   | 18.2%| 54.5% | 9.1%              |
| Vim            | 21.3%   | 22.5%  | 6.4%    | 44.6%| 5.2%  | 11.3%             |
| FCiv           | 13.2%   | 7.5%   | 52.8%   | 15.1%| 11.3% | 13.2%             |
| Pdf2h          | 5.0%    | 55.0%  | 0.0%    | 52.2%| 4.3%  | 26.1%             |
| GAIM           | 13.0%   | 4.3%   | 25.6%   | 44.9%| 14.1% | 15.4%             |
| Joe            | 0.0%    | 0.0%   | 0.0%    | 33.3%| 0.0%  | 0.0%              |
| ZSNES          | 0.0%    | 0.0%   | 0.0%    | 0.0% | 0.0%  | 0.0%              |
| Bash           | 0.0%    | 0.0%   | 0.0%    | 0.0% | 0.0%  | 0.0%              |
| LKernel        | 0.0%    | 0.0%   | 0.0%    | 0.0% | 0.0%  | 0.0%              |
| Total          | 11      | 249    | 53      | 20   | 23    | 78                |

This detailed analysis of real software faults provides valuable insights into the nature and distribution of faults, enabling the development of more accurate and effective fault emulation operators.