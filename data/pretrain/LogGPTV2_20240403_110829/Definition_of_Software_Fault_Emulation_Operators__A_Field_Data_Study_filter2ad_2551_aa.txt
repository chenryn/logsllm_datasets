title:Definition of Software Fault Emulation Operators: A Field Data Study
author:João Durães and
Henrique Madeira
Definition of Software Fault Emulation Operators: a Field Data Study 
Polytechnic Institute of Coimbra; ISEC; CISUC 
João Durães 
Coimbra, Portugal 
PI:EMAIL
Henrique Madeira 
University of Coimbra; DEI; CISUC 
Coimbra, Portugal 
PI:EMAIL
Abstract
residual faults in COTS components may cause a serious 
risk of system outage. 
through 
This paper proposes a set of operators for software fault 
emulation 
low-level  code  mutations.  The 
definition of these operators was based on the analysis of 
an  extensive  collection  of  real  software  faults.  Using  the 
Orthogonal  Defect  Classification  as  a  starting  point, 
faults  were  classified  in  a  detailed  manner  according  to 
the high-level constructs where the faults reside and their 
effects  in  the  program.  We  observed  that  a  large 
percentage  of  faults  fall  in  well-defined  classes  and  can 
be characterized in a very precise way, allowing accurate 
emulation through a small set of mutation operators. The 
resulting  operators  closely  emulate  a  broad  range  of 
common  programmer  mistakes.  Furthermore,  as  the 
mutation  is  performed  directly  at  the  executable  code, 
software faults can be injected in targets for which source 
code is not available. 
1. Introduction
faults  become  more  difficult 
Software  faults  are  recognized  as  the  major  cause  of 
computer  systems 
failures.  This  predominance  of 
software  faults  is  clearly  shown  in  several  research 
studies  [14,  22,  28].  As  systems  grow  more  complex, 
software 
to  avoid. 
Consequently,  the  weight  of  software  faults  on  overall 
system  dependability  will  tend  to  increase.  It  is  now 
commonly  accepted  that  software  products  do  contain 
hidden  defects  after  deployment.  When  activated,  those 
software defects may have an impact that normally cannot 
be entirely foreseen. 
Practical  elimination  of  all  software  faults  during 
development  stages  is  very  difficult  to  achieve.  In 
addition  to  the  intrinsic  technical  difficulties  of  software 
development  and  testing  process  [23,  25],  external 
pressures  such  as  shrinking  deadlines  contribute  to  the 
situation of defective software being deployed.  
A  recent  trend  in  industry  shows  an  ever-growing 
usage  of  components-of-the-shelf  (COTS),  i.e.,  software 
modules  not  specifically  designed  for  a  particular 
application. However, because of the strong interaction of 
COTS  components  with  other  parts  of  a  larger  system, 
The emulation of the effects of software faults through 
the  use  of  fault  injection  has  been  recognized  as  a 
powerful tool to improve software reliability [6, 31]. The 
emulation  of  the  effects  of  real  software  faults  can  be 
used to achieve the following goals: 
•  Prediction  of  worst  case  scenarios  and  risk 
assessment. The emulation of software faults can be used 
as  a  way  to  quantify  the  impact  of  software  faults  from 
the  user  point  of  view  and  get  a  quantitative  idea  of  the 
potential risk represented by residual faults [30, 31].  
•  Validation of fault tolerant mechanisms. As typical 
software  faults  left  in  deployed  systems  are  rarely 
triggered, the validation of fault tolerant mechanisms can 
be  achieved  by  accelerating  the  software  fault  activation 
through the emulation of software faults. 
•  Dependability  benchmarking.  One  recent  research 
effort  is  centered  on  the  definition  of  dependability 
benchmarks  [3,  19].  As  one  key  component  of  dependa-
bility  benchmark  will  be  the  experimental  evaluation, 
techniques to emulate software faults are essential. 
Emulation of software faults presents several technical 
problems.  The  accuracy  of  the  emulated  faults  is  clearly 
the  most  difficult  problem,  not  only  because  the  exact 
nature of software faults is difficult to understand but also 
because  it  is  difficult  to  establish  a  relationship  between 
faulty program behavior and a particular fault.
The  Orthogonal  Defect  Classification  (ODC)  [5] 
provides  an  important  basis  to  understand  and  classify 
software  faults.  However,  ODC  relates  faults  to  the  way 
they are corrected. Given the fact that the same faults can 
be corrected in different ways, a closer look into the exact 
nature  of  the  faults  is  necessary  for  accurate  fault 
emulation. 
Field  data  on  real  software  faults  is  a  very  useful 
resource  to  understand  software  faults.  Unfortunately, 
data  on  real  software  faults  is  not  commonly  available 
and  research  works  using  real  faults  are  relatively  rare 
(some examples are [14, 22, 6, 24]). 
This paper presents the results of the analysis of a set 
of  more  than  500  real  software  faults.  The  detailed 
analysis  of  these  faults  provides  valuable  insight  of 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:30 UTC from IEEE Xplore.  Restrictions apply. 
important  fault properties, such as  fault relationship  with 
common  high-level  language  structures  and  fault  effects 
for  a  better 
on  program  execution.  This  allows 
understanding  of  how  faults  may  occur  and 
the 
relationship  between  high-level  language  constructs  and 
specific  faults.  Statistics  about  fault  occurrence  per  fault 
type  have  also  been  collected.  This  helps  to  establish 
guidelines on how faultloads for software fault emulation 
should be defined.  
We  propose  the  emulation  of  the  most  frequently 
observed faults through a set of fault emulation operators 
that inject the faults directly in the target executable code. 
In  some  sense,  our  operators  are  similar  to  mutation 
operators [12] but they have two fundamental differences: 
1) our operators work directly in the executable code and 
not at the high-level source code; and 2) the main goal of 
our  operators  is  to  emulate  residual  software  faults,  and 
not the identification of the best sets of test cases.
The  remainder  of  this  paper  is  organized  as  follows: 
Section 2 presents the related research; Section 3 presents 
the faults collected and their analysis; Section 4 discusses 
how these  faults can be emulated using a  low-level code 
mutation  injection  technique  presented  in  [9].  Section  5 
presents some final conclusions. 
2. Related work
Most of the works on software faults are related to the 
software  development  phase. Many  studies  have  tried  to 
mitigate  the  problem  of  residual  faults  with  particular 
emphasis  on  software 
reliability 
modeling  and  software  reliability  risk  analysis  [23,  25]. 
The  fault  history  during  the  development  phase,  the 
operational profile, and other process measures have also 
been  used  in  reliability  models  to  estimate  the  reliability 
of  software  and  to  predict  software  faults  for  risk 
assessment [15, 20, 25]. 
testing,  software 
Two  significant  studies  of  software  dependability  in 
Tandem systems are presented in [14, 22]. The impact of 
software defects on the availability of a large IBM system 
is presented in [28]. An early study [17] investigated the 
effect  of  the  workload  on  the  reliability  of  an  IBM 
operating system based on data collected from field. 
The  idea  that  mutations  and  actual  software  faults 
produce  similar  error  patterns  and  program  behavior  is 
supported by the results presented in [8]; in fact, 85% of 
the errors generated by  mutations  were also produced by 
real faults. This suggests that if we improve the accuracy 
of  the  fault  emulation,  we  will  be  able  to  fill  the  gap 
between emulated faults and real faults. 
Fault  injection  has  become  an  attractive  approach  for 
experimental  evaluation  of  fault  handling  mechanisms 
and  assessment  of  the  impact  of  faults  in  systems.  Fault 
injection  can  also  help  in  the  estimation  fault  tolerant 
system  measures  [2,  17].  Some  examples  of  fault 
injection  tools  are  Ferrari  [18],  FTAPE  [29],  Xception 
[4],  and  Goofi  [1].  However,  all  these  tools  have  been 
proposed  for  the  emulation  of  hardware  faults  and  their 
potential in what concerns the emulation of more complex 
faults such as software faults is very limited. 
Other techniques inject faults by corrupting parameters 
of  API  calls  [13,  21].  Although  the  faults  injected  by 
these 
techniques  can  be  considered  as  a  possible 
consequence of software faults, they do not try to directly 
emulate software faults. 
 Emulation of common programmer mistakes has been 
recognized as a good approach for emulation of software 
faults  (some  examples  are  [26,  27]). Faults  that  emulate 
typical programmer mistakes were also used in a study of 
operating system robustness [10]. 
The  works  more  directly  related  to  the  present  work 
are [6, 7, 24, 9]. The work presented in [6] proposed a set 
of  rules  for  the  injection  of  errors  that  emulate  software 
faults  based  on  field  data  about  discovered  software 
faults. However, these emulation rules always require the 
availability of field data on real faults found in the target 
system,  which is normally not available. In our  work  we 
generalized  the  analysis  of  field  data  in  order  to  define 
general purpose fault emulation operators and remove the 
need  of  having  field  data  as  a  pre-condition  to  use  the 
operators.  Furthermore,  our  operators  for  fault  emulation 
can be used in executable software modules for which the 
source code is not available.  
Previous  works  from  our  group  [7,  24]  evaluate  the 
possibilities  of  emulation  of  software  faults  using 
classical  fault  injection  tools.  However,  because  the 
injection  is  done  while  the  target  is  actually  being 
executed, 
is  high  and  some 
intrusiveness  exists.  Furthermore,  complex  software 
faults  require  more  elaborate  alteration  to  the  program 
execution and cannot be entirely emulated this way. 
instrumentation 
level 
A technique for the emulation of software faults using 
low-level  code  mutation  was  presented  in  [9].  This 
technique,  named  G-SWFIT  (Generic  Software  Fault 
Injection  Technique),  emulates  faults  by  modifying 
(mutating) the executable code of the target in a way that 
recreates  the  code  (or  its  effects)  that  would  have  been 
generated  by  the  compiler  if  a  given  software  fault  were 
present  in  the  high-level  source  code.  Because  the  target 
code  modification 
its  execution, 
intrusiveness is not an issue.  Furthermore, complex code 
mutations  can  be  done,  allowing  the  emulation  of 
complex software faults. The accuracy of G-SWFIT when 
compared  to  high-level  mutation  was  experimentally 
shown to be good in [9]. 
is  done  prior 
to 
The  analysis  of  field  software  faults  presented  in  the 
first  part  of  this  paper  is  independent  from  any  specific 
fault  emulation  technique  while  the  subsequent  elabora-
tion  on  how  such  faults  can  be  emulated  is  aimed  for 
G-SWFIT and extends our previous work [9]. 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:30 UTC from IEEE Xplore.  Restrictions apply. 
Table 1 - Programs used as software fault sources.
Programs 
CDEX 
Vim 
FreeCiv 
pdf2h 
GAIM 
Joe 
ZSNES 
Bash 
LKernel 
Total faults collected
Source location 
http://sourceforge.net/projects/cdexos/ 
http://www.vim.org 
http://www.freeciv.org 
http://sourceforge.net/projects/pdftohtml/ 
http://sourceforge.net/projects/gaim/ 
http://sourceforge.net/projects/joe-editor/ 
http://sourceforge.net/projects/zsnes/ 
http://cnswww.cns.cwru.edu/~chet/bash/bashtop.html 
http://www.kernel.org 
Description 
CD Digital audio data extractor. 
Improved version of the UNIX vi editor. 
Multiplayer strategy game.  
pdf to html format translator. 
All-in-one multi-protocol IM client. 
Text editor similar to Wordstar® 
SNES/Super Famicom emulator for x86. 
GNU Project's Bourne Again SHell. 
Linux kernels 2.0.39 and 2.2.22 
# faults 
11
249
53
20
23
78
3
2
93
532
or 
incorrect 
3. Field study and software fault classification 
We have obtained the real faults used in our work from 
a  large  set  of  patch  and  diff  files  of  several  open  source 
programs  written  in  C  (see  Table  1).  The  source  code 
provided  in  those  files  was  analyzed  to  understand  and 
classify the faults. A total of 532 faults were analyzed. It 
is  worth  noting  that  the  programs  used  cover  a  broad 
range  of  program  types:  both  user  programs  (interactive 
and command line) and operating system code were used.
3.1 Fault classification methodology 
The approach used to classify and to analyze the faults 
was the following: 
• 
In  a  first  step  we  classified  the  faults  according  to 
ODC.  The  use  of  general  and  well  accepted  fault 
classification  is  the  best  way  to  make  our  results 
available for the research community and it allows us 
to compare our results with previous field studies.  
In  a  second  step  we  grouped  the  faults  according  to 
the  nature  of  the  defect,  defined  from  a  building 
block  programming  point  of  view.  That  is,  for  each 
ODC  class  a  software  fault  is  characterized  by  one 
programming  language  construct  that  is  missing,
wrong or superfluous.
In  the  last  step,  faults  were  further  refined  and 
classified in specific types. This final classification is 
the one used to define fault emulation operators. 
• 
• 
3.2. ODC classification and general analysis 
The  following  fault  types  in  ODC  are  directly  related 
to  the  code,  thus  describing  software  faults  as  defined  in 
the context of the present work: 
•  Assignment:  values(s)  assigned  incorrectly  or  not 
assigned at all. 
•  Checking:  missing or incorrect validation of data or 
• 
incorrect loop or conditional statements. 
among 
Interface: 
components, modules, device drivers, call statements, 
or parameter lists. 
interaction 
errors 
the 
in 
•  Timing/serialization:  missing 
serialization of shared resources. 
•  Algorithm: incorrect or missing implementation that 
can  be  fixed  by  (re)implementing  an  algorithm  or 
data structure without the need of a design change. 
Function:  affects  a  sizeable  amount  of  code  and 
refers 
implemented 
incorrectly or not implemented at all. 
to  capability 
is  either 
that 
• 
As  the  field  data  available  to  us  does  not  include  any 
information  on  timing  or  serialization  properties,  we  did 
not  consider  the  Timing/serialization  type.  Table  2 
presents  the  distribution  of  faults  across  the  five  ODC 
fault types addressed in this work 
to  our  own.  Because 
 We  compared  our  fault  distribution  with  the  one 
presented in [6] because that work is the one most closely 
related 
included 
Time/Serialization  faults,  we  had 
to  normalize  all 
percentages  leaving  out  that  fault  type  so  that  a  direct 
comparison  could  be  made.  Values  presented  in  [6]  are 
those inside parenthesis on Table 2. 
that  work 
Table 2 - Fault distribution across ODC types.
ODC Type  Number of faults  ODC class distribution (%)
Assignment 
Checking 
Interface 
Algorithm 
Function 
22.1  (21.98) 
25.7  (17.48) 
8.0  (8.17) 
37.2  (43.41) 
6.7  (8.74) 
118 
137 
43 
198 
36 
suggests 
It  is  worth  noting  that  both  our  fault  distribution  and 
that  presented  in  [6]  show  the  same  trend  in  the  fault 
distribution  across  ODC  fault  types.  The  fact  that 
independent  research  works  obtained  a  similar  fault 
distribution 
is 
representative  of  programs  in  general.  Furthermore,  the 
programs  analyzed  in  [6]  were  quite  different  from  the 
ones  used  in  our  study,  which  suggests  that  this  fault 
distribution  over  ODC  types  is  reasonably  independent 
from  the  nature  of  the  program  (and  maybe  from  the 
programming  language  and  processor).  Although  more 
field studies are required to consolidate this conclusion, it 
distribution 
that 
this 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:30 UTC from IEEE Xplore.  Restrictions apply. 
seems  reasonable  that  faultloads  designed  to  emulate 
software faults should take this fault trend into account. 
The  fault  distribution  observed  for  each  individual 
program  is  presented  in  table  3.  We  observed  that  the 
programs  with  a  significant  number  of  faults  show  a 
similar  ODC  fault  distribution.  This  reinforces  the 
suggestion that software faults do follow a clear pattern of 
distribution across ODC types. 
Table 3 – Fault distribution across ODC types by program
ODC Type →→→→
Assign.  Check. 
Interf. 
Alg. 
Func. 
Programs # faults
CDEX 
Vim 
FCiv 
Pdf2h 
GAIM 
Joe 
ZSNES 
Bash 
LKernel 
Total 
11 
249 
53 
20 
23 
78 
3 
2 
93 
532 
0.0%  40.0% 
18.2%  18.2%  54.5%  9.1% 
0.0% 
21.3%  22.5%  6.4%  44.6% 
5.2% 
11.3%  13.2%  7.5%  52.8%  15.1%
5.0% 
55.0% 
0.0% 
52.2%  4.3%  26.1%  13.0%
4.3% 
25.6%  44.9%  14.1%  15.4% 
0.0% 
0.0% 
0.0%  33.3% 