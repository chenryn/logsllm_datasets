总是会匹配成功。而在几乎所有其他正则表达式流派中，得到的结果都是恰好相反
的：它们永远不可能匹配成功，而结果是它们会迫使正则引擎回溯，直到整个匹配
失败，或者它们引用的分组参与了匹配，从而就有可能让所有的向后引用都最终匹
配成功。
JavaScript流派的第二个区别是嵌套在-个重复的外层分组（例如((a)(b))+>）中的捕
获分组所记住的取值。对于大多数正则流派来说，在一个重复分组中的捕获分组所记
住的取值是该分组上一次参与到匹配中时所匹配到的内容。因此，在?:(a)(b))+>被用
来匹配ab之后，向后引用#1中的值是a。然而，根据JavaScript规范的说明，到嵌套
分组中的向后引用的值在每次外层分组重复时都会被重置。因此，《(?：(a(b))+还是会
匹配ab，只不过在匹配完成之后，向后引用#1指向的是一个未参与匹配的捕获分组，
而在JavaScript中它会在正则式中匹配一个空字符串，并且在调用它的方法（例如
RegExp.prototype.exec）所返回的数组中返回undefined。
根据我们上面的讲解，读者会发现在JavaScript正则流派中会遇到的这两种行为所造成
的区别都会使我们无法使用空捕获分组来模拟条件判断。
多个单词、彼此之间可以是任意距离
如果你只是想要检查在一个目标字符事中是否能找到一个单词列表，而不用管它们之
间是否接近，那么可以在一个查找操作中使用肯定型顺序环视来完成这个任务。
在许多情况下，对你要查找的每个目标单词进行分别查找，然后跟踪判
\A（?=.*?\bword1\b)(?=.*?\bword2\b）.*\z
正则选项：不区分大小写、点号匹配换行符
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
(?=[\s\S]*?\bword1\b)(?=[\s\S] *？\bword2\b)[\s\S] *$
正则选项：不区分大小写（“^和$匹配换行处”必须关闭）
正则流派：JavaScript
如果你要的所有目标单词都能在目标字符串中找到，那么这些正则表达式会匹配整个
字符串；否则，它们不会找到任何匹配。JavaScript程序员不能使用第一种形式，因为
你可以根据实例3.6中的代码来实现这些正则表达式。只需要把其中的占位符（wordl>
和（word2>替换为你要查找的单词。如果需要检查超过两个单词，那么你可以在正则式
的前面根据需要添加更多的顺序环视。例如，A（？=.*?\bword1\b)（？=.*?bword2\b)（？=.*？
bword3\b).*Z>就可以查找3个单词。
292第5章
www.TopSage.com
---
## Page 309
参见
实例5.5和实例5.6。
5.8查找重复单词
问题描述
重复单词的时候不必在意大小写的区别，例如是“Thethe”。你同样还要允许在单
词之间出现任意数量的空白，这样，即使会造成两个单词出现在不同的行中也可以
找到。
解决方案
向后引用会匹配一些前面匹配过的内容，因此也就为这个实例提供了关键的组成成分：
b([A-2] +) \s+\1\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
如果你想要使用这个正则表达式来保留第一个单词，但去掉随后的重复单词，就需要
把所有匹配都替换为向后引用#1。另外一种方式是对匹配到的内容进行突出显示，比
容易识别它们。实例3.15讲解了如何在替代文本中使用向后引用，而在实现前面提到
的这两种方式的时候都会用到。
如果你只是想要找到重复单词，从而可以手动检查它们是否需要被更正，那么可以使
用实例3.7中的代码。一个文本编辑器或类似grep这样的工具，例如在第1章中“使
用正则表达式的工具”一节中提到的那些工具，也会在查找董复单词的时候帮助你提
供所需的上下文，从而可以决定有问题的单词是否真的使用正确。
讨论
捕获分组和向后引用都需要匹配先前匹配过的内容。把你想要匹配多于一次的内容放
到一个捕获分组中，然后使用向后引用来再次匹配它。这同简单地使用量词来重复一
个记号或分组的工作原理是不一样的。我们来考虑一下两个简单正则表达式w1>和
w{2}>之间的区别。第-个正则式使用一个捕获分组和向后引[用来两次匹配相同的单
词字符，而后者则使用一个量词来匹配任意两个单词字符。实例2.10中更加深入地讨
论了向后引用的用法。
再回到我们这里的问题。这个实例只找到由字母A~Z和a～z组成的重复单词（因
为应用了不区分大小写的选项）。如果要在单词中充许出现含读音符号的字母和其
单词、文本行和特殊字符293
www.TopSage.com
---
## Page 310
他字母表中的字母，那么如果在你的正则流派中支持，可以使用Unicode中的Letter
属性（）。更多信息请参考实例2.7中的“Unicode属性或类别”小节中的
讲解。
在捕获分组和向后引用之间，s+）会匹配任意的空白字符，例如空格、制表符或者换
行符。如果你想要把可以分隔重复单词的字符限制为水平空白（也就是说不包含换行)，
那么可以把s>替换为[^S\rn]>。这样会避免匹配跨多行出现的重复单词。PCRE7和
Perl5.10中都包含简写字符类h>，你在这里也可以用它来实现，因为它就是被设计来
匹配水平空白符号的。最后，在正则表达式开始和结尾的单词边界会确保它不会匹配
其他单词中的一部分，例如是“thisthistle”。
要注意使用重复单词并不总是错误的，因此如果不做进一步审查就简单删除重复单词
常是可以接受的。同形异义词、姓名、拟声词（例如“oinkoink”或者“haha”），以
及其他一些结构也会偶尔造成有意重复的单词。因此，在大多数情况下，你需要人工
对每个匹配进行检查。
参见
实例2.10中深入讨论了向后引用。
实例5.9中讲解如何匹配重复的文本行。
5.9删除重复的文本行
问题描述
你要处理一个日志文件、数据库查询输出或者是其他一些类型的文件或字符串，其中
复的文本行，只保留其中一个。
解决方案
各种不同的软件（包括Unix命令行工具uniq和WindowsPowerShell命令行Get-Unique）
都可以帮助你删除文件或字符串中的内容重复的文本行。下面的小节中包含3种基于
正则式的解决方案，它们都比较适合用于在一个不支持脚本的文本编辑器中使用正则
表达式的查找和替换支持来完成这个任务。
在编程的时候，应当避免使用方法2和方法3，因为相对其他可选方案（例如使用一个
hash对象来记录所有不重复的文本行）来说，它们的效率较低。然而，第一种方法（它
要求首先对所有文本行进行排序，除非你只想删除相邻的重复文本行）会是一种可以
接受的方案，因为它不仅速度快而且使用简便。
294第5章
www.TopSage.com
---
## Page 311
方法1：先对文本行排序然后删除相邻的重复行
如果能够对要处理的文件或字符事中的所有文本行进行排序，从而可以让所有重复的
文本行都出现在相邻位置，那么除非你一定要保留每行原来的顺序，否则，都应该这
样做。这个方法会允许你使用更简单与更高效的查找与替换操作来删除其中的重复，
如果不排序，就不可能这样做。
在对所有文本行排序之后，使用下面的正则式和替代字符串就可以删除重复行：
(.*)(？:(？:\r？\n1\r)\1)+$
正则选项：和S匹配换行处（“点号匹配换行符"必须关闭）
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
替换为：
$1
替代文本流派：.NET、Java、JavaScript、Perl、PHP
\1
替代文本流派：Python、Ruby
这个正则表达式使用了一个捕获分组和一个向后引用（以及其他组成部分）来匹配两
个或多个连续的重复行。在替代文本中使用一个向后引用，把第一行放回到目标文本
中。读者可以通过修改实例3.15中所给的代码示例来实现这个正则表达式。
方法2：在未排序的文件中保留每个重复行的最后一次出现
如果你使用的文本编辑器没有内置的功能来对文本行进行排序，或者是有必要保留原
来的文本行顺序，那么下面的解决方案可以帮助你在没有进行排序的情况下，对不连
续的重复行实施删除：
（[\r\n]*）（？:\r？\n∣\r）（？=.*\1S)
正则选项：点号匹配换行符、和S匹配换行处
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
要想构造-一个JavaScript兼容的正则表达式，可以保留上面的正则式，只要去掉“点号
匹配换行符”的选项就可以了：
（.*）（？:\r?\n]\r）（？=[\s\S]*\1$）
正则选项：^和$匹配换行处（“点号匹配换行符”必须关闭）
正则流派：JavaScript
替换为：
（空字符串，也就是替换为空）
替代文本流派：N/A
方法3：在未排序的文件中保留每个重复行的第一次出现
如果想要保留每个重复行的第一次出现，那么你就需要使用稍微不同的方式。首先，
单词、文本行和特殊字符295
www.TopSage.com
---
## Page 312
下面是我们要使用的正则表达式和替代字符串：
+（\（x\1u\\：）：）（)（[u\\]）
正则选项：点号匹配换行符、和S匹配换行处
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
与JavaScript流派兼容，那么就需要做一些改动。
(. *) $([\s\S]*?)(?:(?:\r?\nI\r)\1$)+
正则选项：和S匹配换行处（“点号匹配换行符”必须关闭）
正则流派：JavaScript
替换为：
$1$2
替代文本流派：.NET、Java、JavaScript、Perl、PHP
\1\2
替代文本流派：Python、Ruby
与方法1和方法2中的正则式不同，这个版本不能采用一次查找和替换操作就删除所
有的董复行。你需要持续应用“全部替换”，直到正则式无法在字符事中找到匹配，也
就意味着所有重复行都已经被删除了。更多细节请参考本实例随后的“讨论”小节。
讨论
方法1：对文本行排序然后删除相邻的董复行
这个正则表达式删除了除第一个之外的所有相邻的董复行。它并不会删除被其他文本
行分隔的重复行。我们来分步骤看一下这个过程。
首先，在正则表达式开始的脱字符（）会匹配一行的开头。通常它只会匹配目标字
符事的并始，因此你就需要保证应用了让和S可以匹配换行处的选项（关于如何设
置正则选项，请参考实例3.4中的讲解）。接下来，在捕获圆括号之内的（.*会匹配一
行的所有内容（包括空行），匹配到的结果被保存到向后引用#1中。要想让这里能正
确工作，就一定不能设置“点号匹配换行符”的选项：否则，点号加星号的组合会一
直匹配到字符串的结束。
在外层的非捕获分组中，我们使用了(?:r?\nr)来匹配在Windows（）、Unix/Linux
OSX（会尝试匹配我们刚才匹配到的那行内容。如果在这个位置没有找到同样一
行，那么匹配尝试会失败，然后正则引擎会继续执行。如果它匹配成功，那么我们会
使用量词（+>来重复这个分组（由换行序列和向后引用#1组成），以尝试匹配更多的重
复行。
最后，在正则表达式结尾的美元符号会判断一行的结束位置。这会确保我们只匹配完
296第5章
www.TopSage.com
---
## Page 313
全相同的文本行，而不是以前面一行的内容作为开头的文本行。
因为我们在做的操作是查找和替换，所以每个整体匹配（包括原来的文本行与行分隔
符）都会从字符串中删除。然后我们会用向后引用#1把原来的文本行再替换回来。
方法2：在未排序的文件中保留每个重复行的最后一次出现
与方法1中只能找到相邻重复行的正则表达式相比，这个正则式做了几处改动。首先，
在方法2正则式的非JavaScript版本中，捕获分组中的点号被替换为了[^rin]>（除换行
之外的任意字符），而且还设置了“点号匹配换行符”的选项。这是因为点号会在这个
正则式的后面用来匹配任意字符，其中也包括换行符。其次，这个正则式添加了一个
顺序环视来继续在字符串中的任何位置搜索可能的重复行。因为顺序环视并不会消费
任何字符，所以该正则式匹配到的文本总是出现在字符串稍后部位的一行内容（包括
它之后的换行符）。把所有匹配替换为空串就会删除重复行，从而把每组重复行的最后
一次出现保留在字符事中。
方法3：在为排序的文件中保留每个重复行的第一次出现
因为逆序环视并没有得到像顺序环视一样广泛的支持（而且即使在支持它的时候，也
致)，而是要匹配一行内容、在字符串后面与该行重复的另外一行以及在二者之间的所
有文本行。最初的那行内容被保存为向后引用#1，在二者之间（如果有的话）的内容
要的内容放回去，而同时删除最后的重复行以及它前面的换行。
这种方法也存在一些问题。首先，因为每个重复行的匹配集合中可能会包含其他行，所
以就有可能会在你匹配到的文本中包含其他的重复行，而这些重复行会在进行“全部替
换”操作的过程中被忽略。其次，如果一行被重复超过两次的话，那幺正则式会首先匹
配重复行1和2，但是在此之后，当继续遍历字符串剩余部分的时候，还需要一对重复
行才能使这个正则式产生匹配。因此，只是一次“全部替换”动作最多只能删除任意特
定行的每两次重复中的一次。为了解决上述两个问题，并确保所有重复行都可以被删除，
你就需要继续在目标字符串之上应用查找和替换操作，直到正则表达式不会在其中找到
匹配为止。我们来看一个例子，假设把上述正则表达式应用到下面的目标字符串之上：
value1
value2
value2
value3
value3
value1
value2
单词、文本行和特殊字符297
www.TopSage.com
---
## Page 314
从这个字符串中删除所有重复行需要执行3遍替换。表5-1展示了每遍操作之后的结果。
表5-1每遍替换之后的结果