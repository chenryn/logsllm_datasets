    ntdll!_LIST_ENTRY
       +0x000 Flink            : Ptr64 _LIST_ENTRY
       +0x008 Blink            : Ptr64 _LIST_ENTRY
在Windbg中，使用!list可以遍历遍历_LIST_ENTRY结构组成的链表。!lis
-x可以用于为每个位置的元素指定一个命令。我们用它去解析_PEB_LDR_DATA结构中的0x20偏移量，并通过_LIST_ENTRY元素进行解析。
将列出所有InMemoryOrderModule链表并显示相关的_LDR_DATA_TABLE_ENTRY
    0:000> dt _LDR_DATA_TABLE_ENTRY
    ntdll!_LDR_DATA_TABLE_ENTRY
       +0x000 InLoadOrderLinks : _LIST_ENTRY
       +0x010 InMemoryOrderLinks : _LIST_ENTRY
       +0x020 InInitializationOrderLinks : _LIST_ENTRY
       +0x030 DllBase          : Ptr64 Void
       +0x038 EntryPoint       : Ptr64 Void
       +0x040 SizeOfImage      : Uint4B
       +0x048 FullDllName      : _UNICODE_STRING
       +0x058 BaseDllName      : _UNICODE_STRING
       +0x068 Flags            : Uint4B
       +0x06c LoadCount        : Uint2B
       +0x06e TlsIndex         : Uint2B
       +0x070 HashLinks        : _LIST_ENTRY
       +0x070 SectionPointer   : Ptr64 Void
       +0x078 CheckSum         : Uint4B
       +0x080 TimeDateStamp    : Uint4B
       +0x080 LoadedImports    : Ptr64 Void
       +0x088 EntryPointActivationContext : Ptr64 _ACTIVATION_CONTEXT
       +0x090 PatchInformation : Ptr64 Void
       +0x098 ForwarderLinks   : _LIST_ENTRY
       +0x0a8 ServiceTagLinks  : _LIST_ENTRY
       +0x0b8 StaticLinks      : _LIST_ENTRY
       +0x0c8 ContextInformation : Ptr64 Void
       +0x0d0 OriginalBase     : Uint8B
       +0x0d8 LoadTime         : _LARGE_INTEGER
在_LDR_DATA_TABLE_ENTRY结构中，InLoadOrderLinks指向下一个模块结构，DllBase是模块的基地址，FullDllName是它模块名称的Unicode字符串。
因为我们知道kenel32.dll是第三个模块
    0:000> !list -t ntdll!_LIST_ENTRY.Flink  -x "dt _LDR_DATA_TABLE_ENTRY @$extret" 002b3270
    ---CUT
    ntdll!_LDR_DATA_TABLE_ENTRY
       +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000000`002b3830 - 0x00000000`002b3260 ]
       +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000000`002b4980 - 0x00000000`002b3840 ]
       +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00000000`77970000 - 0x00000000`77985ea0 ]
       +0x030 DllBase          : 0xbaadf00d`0011f000 Void
       +0x038 EntryPoint       : 0x00000000`00420040 Void
       +0x040 SizeOfImage      : 0x2b35c0
       +0x048 FullDllName      : _UNICODE_STRING "kernel32.dll"
       +0x058 BaseDllName      : _UNICODE_STRING "ꩀ矌"
       +0x068 Flags            : 0x77ccaa40
       +0x06c LoadCount        : 0
       +0x06e TlsIndex         : 0
       +0x070 HashLinks        : _LIST_ENTRY [ 0xbaadf00d`4ce7c78b - 0x00000000`00000000 ]
       +0x070 SectionPointer   : 0xbaadf00d`4ce7c78b Void
       +0x078 CheckSum         : 0
       +0x080 TimeDateStamp    : 0
       +0x080 LoadedImports    : (null) 
       +0x088 EntryPointActivationContext : 0x00000000`002b4d20 _ACTIVATION_CONTEXT
       +0x090 PatchInformation : 0x00000000`002b4d20 Void
       +0x098 ForwarderLinks   : _LIST_ENTRY [ 0x00000000`002b36e8 - 0x00000000`002b36e8 ]
       +0x0a8 ServiceTagLinks  : _LIST_ENTRY [ 0x00000000`002b3980 - 0x00000000`002b3750 ]
       +0x0b8 StaticLinks      : _LIST_ENTRY [ 0x00000000`77c95124 - 0x00000000`78d20000 ]
       +0x0c8 ContextInformation : 0x01d00f7c`80e29f8e Void
       +0x0d0 OriginalBase     : 0xabababab`abababab
       +0x0d8 LoadTime         : _LARGE_INTEGER 0xabababab`abababab
       ---CUT
现在知道加载的模块基地址在_LDR_DATA_TABLE_ENTRY的0x30偏移处。
a.通过访问[gs:60h]找到PEB
b.通过在PEB中偏移0x18进入LDR链表。
c.偏移0x20是InMemoryOrderModuleList。
d.InMemoryOrderModuleList中的第3个元素是Kernel32，0x30th offset是模块的基地址。
e.我们要调用ExitProcess，这实际上是来自ntdll.dll的RtlExitUserProcess。Ntdll.dll是InMemoryOrderModuleList中的第二个条目，我也将获取它的基地址并将其存储在r15中供以后使用。我发现这个方法比依靠Kernel32在ntdll中正确执行一个函数更容易和更可靠
从dependency walker中可以看出ExitProcess指向Ntdll.RtlExitUserProcess。
**  
**
**开始编写汇编代码**
    mov r12, [gs:60h]       ;peb
    mov r12, [r12 + 0x18]   ;Peb --> LDR
    mov r12, [r12 + 0x20]   ;Peb.Ldr.InMemoryOrderModuleList
    mov r12, [r12]          ;2st entry
    mov r15, [r12 + 0x20]   ;ntdll.dll base address!
    mov r12, [r12]          ;3nd entry
    mov r12, [r12 + 0x20]   ;kernel32.dll base address! We go 20 bytes in here as we are already 10 bytes into the _LDR_DATA_TABLE_ENTRY from the InMemoryOrderModuleList
这里将Kernel32的地址放入r12寄存器(r12寄存器不是Clobber寄存器),在shellcode执行期间需要已知保留Kernel32的地址。现在找到了kernel32模块的地址，可以通过kernel32加载其他模块和获取其他函数的地址。
    HMODULE WINAPI LoadLibrary(
    _In_  LPCTSTR lpFileName
    );
LoadLibraryA用于将其他dll模块加载到当前进程，因为shellcode需要与地址无关，不能依赖任何已经在目标进程中的dll。在本例中需要加载user32.dll。  
为了使用LoadLibraryA函数，它必须在kernel32.dll中找它的地址，这就需要GetProcAddress函数了。
    FARPROC WINAPI GetProcAddress(
    _In_  HMODULE hModule,
    _In_  LPCSTR lpProcName
    );
GetProcAddress需要两个参数，需要获得的函数模块句柄以及函数名。
    ;find address of loadLibraryA from kernel32.dll which was found above. 
    mov rdx, 0xec0e4e8e  ;lpProcName (loadLibraryA hash from ror13)
    mov rcx, r12         ;hModule
    call GetProcessAddress
一旦我们知道LoadLibraryA的地址，我们可以使用它来加载user32.dll。
&ldquo;0xec0e4e8e&rdquo;为函数名称的hash,将该hash赋值给rdx作为函数名参数。
0xec0e4e8e是LoadLibraryA的每个字母ROR
0x13相加所得的总和。这在Shellcode中是常见的，在MetaSploit等项目使用。我写了一个简单的C程序来用来计算这些hash。
    #./rot13.exe LoadLibraryA
    LoadLibraryA
    ROR13 of LoadLibraryA is: 0xec0e4e8e
现在加载user32.dll
    ;import user32
    lea rcx, [user32_dll]
    call rax                ;load user32.dll
    user_32dll: db 'user32.dll', 0
现在可以获得MessageBox函数的地址了
    mov rdx, 0xbc4da2a8     ;hash for MessageBoxA from rot13
    mov rcx, rax
    call GetProcessAddress
然后执行MessageBox
    ;messageBox
    xor r9, r9            ;uType
    lea r8, [title_str]   ;lpCaptopn
    lea rdx, [hello_str]  ;lpText
    xor rcx, rcx          ;hWnd
    call rax              ;display message box  
    title_str:  db  '0xdeadbeef',   0
    hello_str:  db  'This is fun!', 0
最后使用ExitProcess函数结束进程
    VOID WINAPI ExitProcess(
    _In_  UINT uExitCode
    );
需要注意的是ExitProcess是kernel32所导出的函数，但是这里使用RtlExitUserProcess。
    ;ExitProcess
    mov rdx, 0x2d3fcd70             
    mov rcx, r15            ;base address of ntdll
    call GetProcessAddress
    xor  rcx, rcx           ;uExitCode
    call rax
完整的shellcode与GetProcess函数实现如下:
这里使用call/pop指令实现&rdquo;lea&rdquo;指令
    bits 64
    section .text
    global start
    start: