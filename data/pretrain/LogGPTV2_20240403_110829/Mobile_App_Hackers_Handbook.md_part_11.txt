versions may be negotiated. Avoid the use of this constant.
kTLSProtocol12—This configuration specifies that TLSv1.2 is preferred by the application but lower versions
may be negotiated. This is the preferred configuration.
kDTLSProtocol1—This configuration specifies that DTLSv1.0 is preferred by the application. Avoid the use of
this constant.
Cipher Suite Negotiation
The cipher suite is the combination of authentication, encryption, message authentication code (MAC), and key
exchange algorithms that are used to negotiate a secure network connection using SSL/TLS. A wide range of
cipher suites with differing levels of security are available.
The choice of cipher suites affects iOS applications; both the Secure Transport and CFNetwork APIs allow a
developer to explicitly configure the cipher suite to use for an SSL/TLS session. This means that through a lack
of awareness, a developer can configure an application to use a cipher suite that is not cryptographically secure.
The full list of available cipher suites is extensive; the suites supported by CFNetwork and the Secure Transport
API all have entries in the SSLCipherSuite enum, which is documented by Apple at the following URL:
https://developer.apple.com/library/ios/documentation/security/Reference/
secureTransportRef/index.html#//apple_ref/c/tdef/SSLCipherSuite. For details on ciphers that are
considered to be strong you should again refer to the documentation from OWASP
(https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet#Rule_-
_Only_Support_Strong_Cryptographic_Ciphers).
To configure an SSL/TLS session that supports only a single cipher suite, you might find an application with
code similar to the following:
SSLCipherSuite *ciphers = (SSLCipherSuite *)malloc(1 * \
sizeof(SSLCipherSuite));
ciphers[0] = SSL_RSA_WITH_RC4_128_MD5;
SSLSetEnabledCiphers(sslContext, ciphers, 1);
In this example, the application supports only the SSL_RSA_WITH_RC4_128_MD5 cipher suite, which has known
weaknesses associated with its use.
Without the source code for an application, determining the cipher suites being negotiated is still possible using
the standard methodology that would apply to any SSL/TLS-enabled client. Using Wireshark or an equivalent
packet capture tool you can capture and dissect the client “hello” packet to reveal the list of negotiable ciphers,
as shown in Figure 3.3.
Figure 3.3 Capturing cipher suites using Wireshark
Intercepting Encrypted Communications
In the previous section you learned about the types of vulnerabilities that can affect the security of an SSL/TLS
session. However, sometimes the security of the SSL/TLS session has not been undermined and you need to
intercept encrypted communications. For example, if an application communicates with a web service over
HTTPS you may want to intercept the communications to comprehensively assess the security of the web
service. In this scenario you may configure your mobile device to use a proxy as has been detailed in the
previous section, but you see no HTTPS traffic because the application rejects the certificate presented by your
proxy; the certificate is likely self-signed and therefore untrusted by the device. Fear not; assuming the
application is not using certificate pinning, intercepting encrypted traffic is still possible by installing your
proxy’s certificate into your device’s certificate store.
To install a certificate on your device, using Burp Suite as the intercepting proxy app, perform the following
steps:
1. After ensuring your local firewall is disabled, start a proxy on your workstation and have it listen on the
external network interface, as shown in Figure 3.1, which uses the Burp Suite proxy as an example.
2. Configure your device to use a proxy (General WiFi. Select your wireless network and choose HTTP Proxy
Manual) and set the IP address and port of your proxy to be those of your workstation as per Figure 3.2.
3. In MobileSafari browse to http://burp and select the CA Certificate option as shown in Figure 3.4.
4. The Install Profile window should load, presenting the PortSwigger CA certificate as shown Figure 3.5. Click
the Install button and then select Install Now to trust this CA.
Figure 3.4 Installing the Burp certificate on your device
Figure 3.5 Install profile view
If this process is successful it will cause the PortSwigger CA profile to be installed on your device and be marked
as trusted. At this stage you should be able to intercept any HTTPS communications via your Burp Suite proxy.
DANGERS OF INSTALLING PROFILES
You should be aware that making a profile such as the PortSwigger CA trusted means that any host that
presents a certificate signed by this CA is potentially able to perform man-in-the-middle communications
to and from your device.
When you have finished testing, you should remove the profile from your device (Settings General
Profiles) if you plan to use the device on a day-to-day basis or on untrusted networks.
Bypassing Certificate Pinning
If you followed the steps described in the previous section “Intercepting Encrypted Communications” and you
find that you’re still unable to intercept HTTPS traffic, there is a very good chance that the application in
question is using certificate pinning. Certificate pinning is when an application disregards the public certificate
hierarchy and explicitly associates, or “pins,” an x509 or public key to a particular host. This process involves
embedding the expected public key or x509 certificate within the application and validating it against the
certificate presented by the server to see whether they match.
If someone is trying to intercept the traffic communicated in this encrypted channel, this can obviously pose a
problem, because even if you mark your proxy’s certificate as trusted on the device, it would still be refused by
the application’s certificate pinning code. If you are using a non-jailbroken device then unfortunately you will
not be able to progress any further and inspect the encrypted traffic. If you are using a jailbroken device,
however, overriding the APIs used to perform trust evaluation on certificates is possible by setting the
kSSLSessionOptionBreakOnServerAuth option whenever the SSLSetSessionOption() function is called by the OS.
You can implement such an attack using a substrate tweak to effectively disable certificate validation across the
device in a similar way to the one described at an application layer earlier in this chapter in the “Certificate
Validation” section. A blog post by Alban Diquet describes this process (https://nabla-
c0d3.github.io/blog/2013/08/20/ios-ssl-kill-switch-v0-dot-5-released/).
At least two implementations of substrate tweaks exist that you can use to bypass certificate pinning when using
a jailbroken device:
iOS SSL Kill Switch (https://github.com/iSECPartners/ios- ssl-kill-switch)
iOS TrustMe (https://github.com/intrepidusgroup/trustme)
For details on how to use and install these tweaks consult the preceding links.
DANGERS OF INSTALLING TRUST BYPASS TOOLS
By installing either iOS SSL Kill Switch or iOS TrustMe, you are effectively disabling certificate validation
on your device. If you use this device for personal or corporate data you are potentially allowing an
attacker to man-in-the-middle any SSL/TLS or HTTPS connection your device makes.
Identifying Insecure Storage
A key concept in mobile application security is that data should not be persistently stored to the device unless it
is absolutely necessary. Due to the nature of mobile phones, devices are frequently lost or stolen and it’s
conceivable that your device may find itself in the hands of an adversary who wants to extract data for malicious
purposes. Some mitigation is in place when a user has a complex passcode on his device but it is not
inconceivable to think that a device could be stolen while unlocked or depending on the sophistication of your
adversary, the Touch ID sensor bypassed (http://www.ccc.de/en/updates/2013/ccc-breaks- apple-touchid).
The attack surface for content stored on the device does not end there, but in fact extends to remote
compromise through exploitation, default credentials on jailbroken devices, devices not having a passcode,
physical attacks such as pairing with malicious devices (http://2013.hackitoergosum.org/presentations/Day3-
04.Hacking%20apple%20accessories%20to%20pown%20iDevices%20%E2%80%93%20Wake%20up%20Neo!%20Your%20phone%20got%20pwnd%20!%20by%20Mathieu%20GoToHack%20RENARD.pdf
or exploitation of elements within the secure boot chain. With these considerations in mind you should assume
that any data stored to the device could potentially be compromised. In many cases, an application may actually
need to persistently store content and data to the device, and in these circumstances developers should take
appropriate measures to protect that content.
Generally you should look for four things when searching for content that is insecurely stored by an application,
although more than one can apply to individual files:
Sensitive content directly stored by the application in plaintext
Sensitive content directly stored by the application that is encrypted using a custom encryption
implementation but using an insecure encryption key or in an otherwise easily reversible format
Sensitive content directly stored by the application but not in a suitable data protection class
Sensitive content inadvertently stored by the application by virtue of iOS
This section focuses on the third possibility and describes how to identify the data protection classes that are
applied to individual files or keychain items on your device. Chapter 4 covers the fourth possibility and the first
two possibilities are application specific and are broadly covered within other areas of this book. In Chapter 2
you learned how iOS applications could take advantage of the Data Protection API to protect individual files or
keychain items on the device. If you did not read this chapter it is recommended that you go back and review
“Understanding the Data Protection API,” because it provides the fundamental background knowledge for this
section.
Although the Data Protection API is an extremely useful method of securing content on iOS and the default
protection class affords a reasonable level of assurance, be aware that the protection classes can be applied on
per-file or per-keychain-item basis. With this in mind, your methodology should include a review of every file or
keychain item stored by an application. Content stored using protection class D (NSFileProtectionNone or
kSecAttrAccessibleAlways) is of particular concern and is not suitable to protect sensitive data at rest. The use
of protection class C (NSFileProtectionCompleteUntilFirstUserAuthentication or
kSecAttrAccessibleAfterFirstUnlock and default since iOS 7) is also discouraged for particularly sensitive data.
To determine the protection class applied to individual files or keychain items, you need to use a mixture of
static and dynamic techniques.
Identifying the protection classes used by individual files without dynamic analysis can be somewhat
problematic; however, provided that the file is stored in a location that is backed up, you should be able to
determine the protection class using an iTunes backup file and the ios-dataprotection tool
(https://github.com/ciso/ios-dataprotection). To do this you should first back up your device by connecting
it to your workstation, running iTunes, and selecting the Back Up Now option for your device. After your device
has been backed up you will be able to parse the backup files using ios-dataprotection. Here is a simple
example:
$ java -jar build/ios-dataprotection.jar
(c) Stromberger 2012, IAIK Graz University of Technology
[1] MDSecPhone (22.10.2014 16:44)
[2] user?s iPad (04.08.2014 01:41)
Choose a backup: 1
Okay, we will store it to /Users/user/Desktop/analysis.csv
Extracting and decrypting your backup
Creating output file in csv format
5357/5357 Files extracted
Finished
After the backup has been parsed, ios-dataprotection creates an analysis .csv file on the desktop, which
contains a listing of files within the backup and the associated protection class for each file:
$ grep mdsec ~/Desktop/analysis.csv
com.mdsec.lab1-1a,1,NSFileProtectionComplete,Library/Preferences/
com.mdsec.lab1-1a.plist,101
The limitation of using this technique is that it is restricted only to files that can be backed up; protection
classes on files stored in other locations, such as the tmp directory, cannot be assessed in this way. You will
discover how you can find the protection class used for these files using dynamic analysis later in this section.
Also be aware that the Data Protection API can not only be used to protect individual files, but also to protect
keychain items.
Determining the protection class applied to individual keychain items is possible using the keychain_dump
(https://code.google.com/p/iphone-dataprotection/downloads/detail?name=keychain_dump) tool that was
referenced in Chapter 2. To retrieve all the keychain items on your device run keychain_dump as root with the
device unlocked (that is, after entering the PIN or passcode). Having the device unlocked allows you to access
keychain items in class A (kSecAttrAccessibleWhenUnlocked) that would otherwise be inaccessible if the screen
lock was active. Here is a sample output of running keychain_dump:
MDSecPhone:~ root# ./keychain_dump
Writing 26 passwords to genp.plist
Writing 14 internet passwords to inet.plist
Writing 5 certificates to cert.plist
Writing 15 keys to keys.plist
MDSecPhone:~ root#
You will find that keychain_dump has created a number of plist files in your current working directory. These
plist files represent the content extracted from the device’s keychain as name-value pairs and contain
information about the protection class that the keychain item is stored using; for example:
acct
mdsecadmin
agrp
com.mdsec.lab1-1d
cdat
2014-09-09T10:55:08Z
data
letmein
desc
gena
lab1.1d
labl
mdat
2014-09-09T10:55:08Z
pdmn
ak
protection_class
WhenUnlocked
rowid
26
svce
sync
0
tomb
0
v_Data
bGV0bWVpbg==
The protection_class key stores the value for the protection class applied to the keychain item. In this case, it
is class A (kSecAttrAccessibleWhenUnlocked).
Up to now you will have a good understanding of how to obtain the protection class applied to all keychain items
and files that are stored in iTunes backups. This does not, however, account for all eventualities, because files
that do not get backed up may not be properly assessed. Performing dynamic analysis, examining the class that
is applied to files as they are created, is therefore important. The simplest way to perform dynamic analysis on
an application is to instrument it using a runtime manipulation framework such as Cydia Substrate.
Instrumentation of the iOS runtime is covered later in this chapter; however, for the moment be aware that you
do not need to implement this yourself. Indeed, a multipurpose tool named Snoop-it
(https://code.google.com/p/snoop-it/) that instruments the iOS runtime for the purpose of inspecting the
APIs used for keychain and filesystem access has already been implemented and can be used to retrieve the data
protection class applied when an artifact is created. Figure 3.6 shows Snoop-it being used to monitor filesystem
access in an application.
Figure 3.6 Snoop-it filesystem monitoring
Patching iOS Applications with Hopper
The subject of software “cracking” is not a new one and was well documented long before iOS applications even
existed. Cracking often has practical uses when you’re conducting a security assessment of iOS applications. In
Chapter 2 you learned that iOS applications are compiled to native code for the ARM architecture, and it should
come as no surprise that by modifying the compiled executable code it is possible to directly manipulate the
behavior of the application. This chapter does not cover the subject in great depth because it is beyond the scope
of this book. Instead, we offer a very brief introduction and walk-through of the processes that a tester would
need to go through to “patch” an iOS application. Although not essential, a basic understanding of ARM
assembler will certainly aid in your learning. If you are not familiar with ARM or assembler in general, review
the “Introduction to ARM” training course that is freely available at
http://opensecuritytraining.info/IntroARM.html.
To demonstrate how to modify the behavior of an iOS application by patching the compiled executable, this
section details a step-by-step analysis of how to defeat a jailbreak detection check within a sample application
and with a jailbroken device. You should be aware that this process only applies to applications running on
jailbroken devices, because modifying an application will invalidate its code signature. The steps outlined in this
process are described next.
When the sample application is run, a jailbreak detection check is performed and a UIAlertView is shown (see
Figure 3.7) if the device is found to be jailbroken (closing the UIAlertView causes the application to exit).
Although this example may seem contrived, it mimics the checks and behavior typical of many simple jailbreak
detection routines. The objective of this walk-through is to bypass this check and allow the application to run.
Figure 3.7 Jailbreak check in sample application
The first step in reverse engineering and patching an iOS application is to obtain the compiled binary. You can
do this by copying the binary off your device, or if you downloaded it using iTunes, by unzipping the IPA and
using the binary contained in the Payload/Application.app folder. If your application is an App Store
application, you will need to remove Apple’s DRM encryption, as detailed in Chapter 2.
After locating the binary, identify the architectures that it contains and if necessary “thin” the binary to the
architecture that best matches your device. Chapter 2 covers this process and the architectures supported by
each device were detailed in the “Reverse Engineering iOS Binaries” section of the same chapter. In this
instance, however, the application is not a fat binary and contains only an armv7 slice:
$ lipo -info Lab3.4a
Non-fat file: Lab3.4a is architecture: armv7
Perhaps the greatest weapon in a reverse engineer’s arsenal is the disassembler, which can be used to translate
the compiled machine code into assembler. To reverse engineer an application you can use any disassembler;
however, this demonstration makes use of the professional version of the Hopper disassembler
(http://www.hopperapp.com/). Be aware that much of the functionality detailed in this walk-through is available
in the demo version of this software, with the exception of the “Produce New Executable” menu item that is
used to create a new binary with the relevant patches applied. You can use the following steps to patch the
sample application and defeat the jailbreak detection routine.
1. Load the binary into Hopper using the File Read Executable to Disassemble menu item and browsing to the
location of the compiled application. This causes Hopper to disassemble the application and provides a view,
as shown in Figure 3.8.
2. Locate the jailbreak functionality within the compiled binary. Referring to Figure 3.7, you can see that the
UIAlertView displays the string “This device is jailbroken; please remove the jailbreak and try again.”
Working backwards from where this string is used may be a good methodology for identifying the jailbreak
detection. To locate a string resource in Hopper, click the Strings button. You can also use the search
function to find the strings quickly, as shown in Figure 3.9.
3. In this case the string is located in the __cstring segment of the binary. To locate where a string is used in
Hopper you can use the Is Referenced By option from the right-hand navigation window as shown in Figure
3.10.
4. Double-click on the cross-reference to move to where the string is referenced. In iOS applications NSString
objects are represented as CFString constants and will be located in the __cfstring segment. Following the
cross-reference to the CFString constant leads to where the string is used in the application; in this case, in
the [ViewController viewDidLoad] method, as shown in Figure 3.11.