title:Pseudorandom Black Swans: Cache Attacks on CTR_DRBG
author:Shaanan Cohney and
Andrew Kwong and
Shahar Paz and
Daniel Genkin and
Nadia Heninger and
Eyal Ronen and
Yuval Yarom
2020 IEEE Symposium on Security and Privacy
Pseudorandom Black Swans:
Cache Attacks on CTR_DRBG
Shaanan Cohney1, Andrew Kwong2, Shahar Paz3, Daniel Genkin2, Nadia Heninger4, Eyal Ronen5, Yuval Yarom6
1University of Pennsylvania, 2University of Michigan, 3Tel Aviv University, 4University of California, San Diego,
5Tel Aviv University and COSIC (KU Leuven), 6University of Adelaide and Data61
Abstract—Modern cryptography requires the ability to se-
curely generate pseudorandom numbers. However, despite
decades of work on side-channel attacks, there is little discussion
of their application to pseudorandom number generators (PRGs).
In this work we set out to address this gap, empirically evaluating
the side-channel resistance of common PRG implementations.
We ﬁnd that hard-learned lessons about side-channel leakage
from encryption primitives have not been applied to PRGs, at
all abstraction levels. At the design level, the NIST-recommended
CTR_DRBG does not have forward security if an attacker is
able to compromise the state (e.g., via a side-channel). At the
primitive level, popular implementations of CTR_DRBG such
as OpenSSL’s FIPS module and NetBSD’s kernel use leaky
T-table AES as their underlying cipher, enabling cache side-
channel attacks. Finally, we ﬁnd that many implementations
make parameter choices that enable an attacker to fully exploit
side-channels and recover secret keys from TLS connections.
We empirically demonstrate our attack in two scenarios.
First, we carry out a cache attack that recovers the private
state from vulnerable CTR_DRBG implementations when the
TLS client connects to an attacker-controlled server. We then
subsequently use the recovered state to compute the client’s
long-term authentication keys, thereby allowing the attacker to
impersonate the client. In the second scenario, we show that an
attacker can exploit the high temporal resolution provided by
Intel SGX to carry out a blind attack to recover CTR_DRBG’s
state within three AES encryptions, without viewing output, and
thus decrypt passively collected TLS connections from the victim.
I . I N T R O D U C T I O N
It
is a truth universally acknowledged,
that a securely
implemented cryptographic primitive must be in want of a
cryptographically secure pseudorandom number generator [3].
Modern cryptography relies on randomness to prevent an
attacker from predicting secret values generated by parties in a
cryptographic protocol. Indeed, random values are universally
used to ensure security properties for nearly all cryptographic
data, including secret keys for conﬁdentiality or integrity, secret
keys for public-key encryption, key exchange, signatures, as
well as for protocol nonces to prevent replay attacks. Thus,
a cryptographically secure Pseudorandom Generator (PRG) is
one of the fundamental primitives of modern cryptography.
The simplest theoretical PRG construction is an algorithm
that expands a smaller seed into a longer output sequence
that is computationally indistinguishable from a true sequence
of random bits. However, the practical security demands for
random number generation are somewhat more complex; in
real systems, these pseudorandom number generator construc-
tions are often multi-stage algorithms that collect inputs from
environmental entropy sources or hardware into an “entropy
pool”. The pool is then used to seed a PRG that generates
cryptographically secure output. Real world PRGs must also
meet additional security guarantees, including recovery from
state compromise. A number of academic works and practical
security failures have illustrated the disastrous effects on real-
world cryptography from ﬂawed random number generation
implementations or designs. These have ranged from uninten-
tional ﬂaws such as failure to properly seed PRGs [35, 46, 53,
95], to designs prone to implementation mistakes [20], to a
suspected intentional back door in the now “deprecated and
disgraced” [62] Dual EC DRBG design, which appears to have
been repurposed and exploited in the wild [18, 19].
Since their introduction in the seminal works of [5, 64, 65],
microarchitectural attacks that exploit contention on internal
components to leak information have been used to violate
nearly every security guarantee offered by computer systems.
Indeed, in recent years there have numerous examples of
side-channel attacks with diverse targets and vectors. These
range from attacks that extract cryptographic keys from
keystroke timing via CPU caches [28, 93], attacks that exploit
transient execution for breaking fundamental OS isolation
guarantees [16, 17, 47, 52, 82, 86], and even attacks that exploit
limitations in memory hardware to change or read the contents
of data [14, 43, 45, 48, 49]. Side-channel resistance is among
the key security properties demanded of implementations.
Much less is known, however, about the security of PRGs
in the presence of side-channel leakage. While backtracking
resistance and prediction resistance are stated to be among the
main security goals of the designs in NIST’s PRG recommen-
dations (NIST SP 800-90A), the standard does not consider
the impact of side-channel attacks on these goals. Although
some preliminary evidence [98] indicates the possibility of
exploiting side-channel vulnerabilities in PRG seeding, there
has been no systematic exploration of side-channel leakage
from PRG implementations. Thus, we explore these questions:
Are common PRG designs susceptible to microarchitectural
side-channel attacks? What are the security implications of
such leakage? Can an attacker exploit them, and if so, how?
A. Our Contribution
Unfortunately, in this paper we give a positive answer to
the above questions. Speciﬁcally, we focus on CTR_DRBG,
which is the most popular PRG design out of those rec-
ommended in NIST SP 800-90A, and is supported by 68%
© 2020, Andrew Kwong. Under license to IEEE.
DOI 10.1109/SP40000.2020.00046
1241
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
of validated implementations in NIST’s Cryptographic Mod-
ule Validation Program (CMVP). On the ﬁrst question, we
show that CTR_DRBG is vulnerable to state compromise
attacks because some popular implementations still use a
non-side-channel-resistant implementation of the underlying
block cipher. On the second question, we show that several
popular CTR_DRBG implementations fail to properly reseed
the PRG in many situations, enabling feasible attacks against
prediction resistance. Furthermore, we demonstrate that using
the PRG within Intel SGX permits a very strong blind state
recovery attack in as few as three encryptions, without the
attacker having access to PRG output. We demonstrate end-
to-end attacks on the CTR_DRBG implementations used by
OpenSSL’s FIPS module, NetBSD, and FortiOS, allowing an
attacker targeting TLS connections to recover session secrets
and long-term ECDSA keys used for client authentication. For
SGX enclaves, we go a step further, showing an attacker that
is capable of passively decrypting TLS connections.
The Use of T-Table AES.
T-table AES is a performance-
oriented AES implementation that uses table lookups to com-
pute the state transitions between individual encryption rounds.
Unfortunately, because these lookups are key-dependent, T-
table AES has become the canonical example of cache side-
channel leakage [10, 58, 64].
While the threat of side channels and the availability of
AES-NI hardware have resulted in declining usage of T-table
AES for encryption and decryption operations, similar lessons
do not seem to have been learned for the case of random
number generation. Remarkably, even after more than a decade
of attacks, [5, 13, 32, 57, 64] we show that unprotected and
leaky T-tables are still used for encrypting the counter inside
CTR_DRBG by the following popular implementations:
• The OpenSSL 1.0.2 FIPS Module. Using this library is
one of a small number of ways to obtain U.S. government
certiﬁcation for a cryptographic module without submitting
to the expensive and time-consuming validation process.
• The NetBSD kernel, which uses CTR_DRBG with T-Table
AES as the system-wide random number generator.
• The FortiOSv5 network device operating system uses the
same vulnerable CTR_DRBG implementation as NetBSD.
• The mbedTLS-SGX port [96] of the popular mbedTLS
cryptography library to SGX.
• The nist_rng library [40], which is a library for random
number generation used by open source projects such as
libuntu (a C implementation of NTRUEncrypt), the XMHF
hypervisor, and others.
CTR_DRBG State Recovery. We adapt previous work
[58] on side-channel attacks on AES encryption to the PRG
setting, and extend the work of Woodage and Shumow [87]
to show how an attacker who observes CTR_DRBG’s cache
access patterns can recover the PRG state using about 2000
bytes of output. We then empirically demonstrate how a client
connecting to a malicious TLS sever can be coerced to provide
enough PRG output that an attacker who concurrently observes
the PRG’s cache access patterns is capable of recovering the
PRG state used during the TLS handshake. We show that
NetBSD’s kernel, OpenSSL’s FIPS module, and FortiOS fail
to reseed the PRG with enough entropy. Thus, by using a
moderate amount of brute forcing for the client entropy, the
attacker can wind forward the client’s PRG and recover the
ECDSA nonce used by the client to authenticate herself to
the malicious TLS server. Finally, using the recovered ECDSA
nonce and the signature produced by the client during the
TLS handshake, the attacker can recover the client’s long
term authentication keys, which would allow the attacker to
impersonate the client in future TLS connections.
State Recovery Without a Malicious TLS Server. The above
attack on TLS requires the victim client to connect to a mali-
cious TLS server. The the attacker then obtains the output from
the client’s CTR_DRBG implementation while simultaneously
observing the client’s cache access patterns across many AES
encryption operations. Tackling this limitation, we perform
a novel “blind” differential cryptanalysis attack exploiting
side-channel leakage from T-table based CTR_DRBG running
inside an SGX enclave. This attack leverages the fact that
CTR_DRBG encrypts an incrementing counter, and is capable
of extracting the PRG’s state from only three AES encryption
operations, without requiring the attacker to observe the PRG’s
output. Thus, we eliminate the need for the TLS client to
connect to an attacker-controlled server. We also note that this
type of attack may be applicable to other settings with similar
constraints, such as GCM-SIV [31].
TLS Decryption with High-Entropy PRG Reseeding. Fi-
nally, we note that any call to CTR_DRBG for random byte
generation must use at least three AES encryption operations,
producing the cache access information required by our dif-
ferential cryptanalysis state-recovery technique. As this vector
does not require the TLS client to connect to an attacker-
controlled server, the attacker can recover the PRG state on any
request for random bytes, regardless of how the implementation
reseeds the PRG. We demonstrate recovery of the premaster
secret, master secret, and symmetric encryption keys for any
TLS connection made by mbedTLS-SGX (a port of mbedTLS
to SGX [96]) to any TLS server. In particular, we are able
to passively decrypt the session by observing cache access
patterns made by mbedTLS-SGX.
Summary of Contributions.
In this work we study
the implications of side-channel analysis on random number
generation. Our contributions can be summarized as follows:
• We present the ﬁrst security analysis of CTR_DRBG in
the presence of side-channel leakage, demonstrating a cache
attack that achieves PRG state recovery against many popular
implementations (Section V).
• We show that PRG reseeding algorithms in popular im-
plementations are sometimes insecure. By combining these
ﬂaws with the above state recovery attack, we empirically
demonstrate an end-to-end attack on TLS that recovers long-
term client authentication keys if the TLS client connects to
an attacker-controlled TLS server (Section VI).
• We present a novel differential cryptanalysis technique that
exploits side-channel leakage from CTR_DRBG running
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1242
inside an SGX enclave to recover the PRG state within three
AES encryption operations (Section VII-B).
that
• We demonstrate an end-to-end attack on an enclaved TLS
client
is capable of passively decrypting the TLS
connections regardless of PRG reseeding (Section VII-C).
• Finally, we evaluate CTR_DRBG’s popularity by scraping
NIST’s Cryptographic Module Validation Program database.
We show that CTR_DRBG was the most popular design,
supported by 68% of implementations (Section VIII).
B. Coordinated Disclosure
We disclosed the vulnerabilities we discovered to the security
teams of OpenSSL, Fortinet, and NetBSD in May 2019.
OpenSSL responded that these attacks are outside their threat
model. NetBSD has since replaced the PRG with Hash_DRBG.
FortiOS assigned the ﬂaw CVE-2019-15703, and has plans to
remediate the problem.
I I . B A C K G R O U N D
A. Pseudorandom Generators
The term “DRBG” does not seem to be widely used outside
of the government context, so for the purposes of this paper,
we will use the term pseudorandom generator (PRG). We
begin by providing basic background regarding pseudorandom
generators and their security properties. Informally, a PRG is
an algorithm that, given an initial seed, produces a stream
of random bits such that an attacker cannot distinguish the
produced stream from a truly uniform random bit stream with
probability better than some negligible bound.
PRG Deﬁnition.
Following [22, 87], a PRG with in-
put is a triplet of polynomial time deterministic algorithms
{instantiate, generate, reseed}. The PRG is instantiated by call-
ing instantiate on an entropy sample I and a nonce N, and
outputs initial state S0. Next, generate gets as input a state S, a
number of bits to output nbits, and additional input addin, and
outputs new state S(cid:2) and bits R ∈ {0, 1}nbits. Finally, reseed
gets as input a state S, an entropy sample I, an additional input
addin, and outputs a new state S(cid:2).
Random Number Generation. The PRG is instantiated by
a single call to instantiate. A user can then repeatedly request
up to r random bits through a call to generate, which also
outputs a new state for the PRG. Finally, both the user and
the generate function can also call update, which updates the
state of the PRG to a new state.
PRG Security. Woodage and Shumow [87] deﬁne three
security properties for a PRG: robustness, backtracking resis-
tance, and prediction resistance. Backtracking resistance is the
property that if the generator is compromised at time t1, an
adversary remains unable to distinguish outputs generated prior