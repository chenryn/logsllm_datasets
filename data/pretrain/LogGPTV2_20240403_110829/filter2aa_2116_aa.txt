The Proxy Era of 
Microsoft Exchange Server
Orange Tsai
Orange Tsai
â€¢ Orange Tsai, focusing on Web and Application 0-day research
â€¢ Principal Security Researcher of DEVCORE
â€¢ Captain of HITCON CTF Team
â€¢ Speaker of Security Conferences
â€¢ Black Hat USA & ASIA / DEFCON / HITB / HITCON â€¦
â€¢ Selected Awards and Honors:
â€¢ 2017 - 1st place of Top 10 Web Hacking Techniques
â€¢ 2018 - 1st place of Top 10 Web Hacking Techniques
â€¢ 2019 - Winner of Pwnie Awards "Best Server-Side Bug"
â€¢ 2021 - Champion and "Master of Pwn" of Pwn2Own
â€¢ 2021 - Winner of Pwnie Awards "Best Server-Side Bug"
Why Target Exchange Server?
1.
Mail servers always keep confidential secrets and Exchange Server is 
the most well-known mail solution for enterprises and governments 
worldwide
2. Has been the target for Nation-sponsored hackers for a long time 
(Equation GroupðŸ˜‰)
3. More than 400,000 Exchange servers exposed on the Internet 
according to our survey
Our Works
â€¢ We focus on the Exchange architecture and discover a new attack surface 
that no one proposed before. That's why we can pop 0days easily!
â€¢ We discovered 9 vulnerabilities that covered server-side, client-side, and 
crypto bugs through this new attack surface, and chained into 4 attacks:
1.
ProxyLogon: The most well-known pre-auth RCE chain
2.
ProxyOracle: A plaintext-password recovery attacking chain
3.
ProxyShell: The pre-auth RCE chain we demonstrated at Pwn2Own 2021
4.
ProxyRelay: A pre-auth authentication bypass to read all the victim's mails
The Proxy Era of MS Exchange
ProxyLogon
â€¢ CVE-2021-26855
â€¢ CVE-2021-27065
ProxyNotFound
â€¢ CVE-2021-28480
â€¢ CVE-2021-28481
ProxyToken
â€¢ CVE-2021-33766
ProxyOracle
â€¢ CVE-2021-31195
â€¢ CVE-2021-31196
ProxyRelay
â€¢ CVE-2021-33768
â€¢ CVE-2021-TBA
ProxyShell
â€¢ CVE-2021-34473
â€¢ CVE-2021-34523
â€¢ CVE-2021-31207
Exchange Architecture
Backend Server
Frontend Server
2000/2003
Mailbox Role
Client Access Role
Hub Transport 
Role
Unified Messaging 
Role
Edge Transport 
Role
2007/2010
Mailbox Role
Client Access Role
Edge Transport 
Role
2013
Edge Transport 
Role
2016/2019
Mailbox Role
Mailbox Service
Client Access 
Service
Where to Focus?
â€¢ We focus on the Client Access Service (CAS)
â€¢ CAS is a fundamental protocol handler in Microsoft Exchange Server. 
The Microsoft official documentation also indicates:
"Mailbox servers contain the Client Access Services that accept client 
connections for all protocols. These frontend services are responsible for 
routing or proxying connections to the corresponding backend services"
where we focus on
Client Access Service in IIS
Two websites?
Client Access Service in IIS
Exchange Architecture
â€¢ Applications in Frontend include the ProxyModule
â€¢ Parse incoming HTTP requests, apply protocol specified settings, and 
forward to the Backend
â€¢ Applications in Backend include the BackendRehydrationModule
â€¢ Receive and populate HTTP requests from the Frontend
â€¢ Applications synchronizes the internal information between the 
Frontend and Backend by HTTP headers
IIS
IIS
Remote
PowerShell
RPC 
Proxy
EWS, OWA
ECP, OABâ€¦
Mailbox Database
FrontEnd Service
BackEnd Service
HTTP/HTTPS
IIS Modules
Validation
Module
Logging
Module
IIS Modules
Filter
Module
FBA
Module
Oauth
Module
â€¦
Rehydration
Module
RoutingUpdate
Module
RBAC
Module
HTTP Proxy Module
Our Ideas
Could we access the Backend intentionally?
\ProxyRequestHandler.cs
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
Copy Client Headers
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
HTTP Header Blacklists
protected virtual bool ShouldCopyHeaderToServerRequest(string headerName) {
return !string.Equals(headerName, "X-CommonAccessToken", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "X-IsFromCafe", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "X-SourceCafeServer", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "msExchProxyUri", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "X-MSExchangeActivityCtx", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "return-client-request-id", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "X-Forwarded-For", OrdinalIgnoreCase) 
&& (!headerName.StartsWith("X-Backend-Diag-", OrdinalIgnoreCase) 
|| this.ClientRequest.GetHttpRequestBase().IsProbeRequest());
}
HttpProxy\ProxyRequestHandler.cs
Copy Client Cookies
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Add Special Headers
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Clone User Identity
if (this.ClientRequest.IsAuthenticated) {
CommonAccessToken commonAccessToken = AspNetHelper.FixupCommonAccessToken(
this.HttpContext, this.AnchoredRoutingTarget.BackEndServer.Version);
if (commonAccessToken != null) {
headers["X-CommonAccessToken"] = commonAccessToken.Serialize(
new int?(HttpProxySettings.CompressTokenMinimumSize.Value));
}
} else if (this.ShouldBackendRequestBeAnonymous()) {
headers["X-CommonAccessToken"] = new CommonAccessToken(9).Serialize();
}
HttpProxy\ProxyRequestHandler.cs
Calculate Backend URL
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Create New HTTP Client
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Attach Authorization Header
if (this.ProxyKerberosAuthentication) {
// use origin Kerberos Authentication
} else if (this.AuthBehavior.AuthState == AuthState.BackEndFullAuth || this.
ShouldBackendRequestBeAnonymous() || (HttpProxySettings.TestBackEndSupportEnabled.Value
&& !string.IsNullOrEmpty(this.ClientRequest.Headers["TestBackEndUrl"]))) {
// unauthenticated
} else {
serverRequest.Headers["Authorization"] = KerberosUtilities.GenerateKerberosAuthHeader(
serverRequest.Address.Host, this.TraceContext, 
ref this.authenticationContext, ref this.kerberosChallenge);
}
HttpProxy\ProxyRequestHandler.cs
1
Generate Kerberos Ticket
1
internal static string GenerateKerberosAuthHeader(string host, int traceContext, ref
AuthenticationContext authenticationContext, ref string kerberosChallenge) {
// â€¦
authenticationContext = new AuthenticationContext();
authenticationContext.InitializeForOutboundNegotiate(AuthenticationMechanism.Kerberos,
"HTTP/" + host, null, null);
SecurityStatus securityStatus = authenticationContext.NegotiateSecurityContext(inputBuffer, 
out bytes);
return "Negotiate " + Encoding.ASCII.GetString(bytes);
}
HttpProxy\KerberosUtilities.cs
The Actual Request Sent to 
Backend
Get Backend Response
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Copy Response to Client
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Backend Rehydration Module
â€¢ IIS has implicitly done the Authentication and set 
the User.Identity to current HttpContext object
private void OnAuthenticateRequest(object source, 
EventArgs args) {
if (httpContext.Request.IsAuthenticated) {
this.ProcessRequest(httpContext);
}
}
private void ProcessRequest(HttpContext httpContext) {
CommonAccessToken token;
if (this.TryGetCommonAccessToken(httpContext, out token))
// â€¦
}
\BackendRehydrationModule.cs
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
1
Restore Frontend User Identity
2
3
private bool TryGetCommonAccessToken(HttpContext httpContext, out 
CommonAccessToken token) {
string text = httpContext.Request.Headers["X-CommonAccessToken"];
flag = this.IsTokenSerializationAllowed(httpContext.User.Identity
as WindowsIdentity);
if (!flag)
throw new BackendRehydrationException(â€¦)
token = CommonAccessToken.Deserialize(text);
httpContext.Items["Item-CommonAccessToken"] = token;
Security\Authentication\BackendRehydrationModule.cs
1
Is Token Serialization Allowed?
2
private bool TryGetCommonAccessToken(HttpContext httpContext, out 
CommonAccessToken token) {
string text = httpContext.Request.Headers["X-CommonAccessToken"];
flag = this.IsTokenSerializationAllowed(httpContext.User.Identity
as WindowsIdentity);
if (!flag)
throw new BackendRehydrationException(â€¦)
token = CommonAccessToken.Deserialize(text);
httpContext.Items["Item-CommonAccessToken"] = token;
Security\Authentication\BackendRehydrationModule.cs
Check AD Extended Rights
private bool IsTokenSerializationAllowed(WindowsIdentity windowsIdentity) {
flag2 = LocalServer.AllowsTokenSerializationBy(clientSecurityContext);
return flag2;
}
private static bool AllowsTokenSerializationBy(ClientSecurityContext clientContext) {
return LocalServer.HasExtendedRightOnServer(clientContext, 
WellKnownGuid.TokenSerializationRightGuid);  // ms-Exch-EPI-Token-Serialization
}
Security\Authentication\BackendRehydrationModule.cs
Auth-Flow in Summary
1.
Frontend IIS authenticates the request (Windows or Basic authentication) and serializes the 
current Identity to X-CommonAccessToken HTTP header
2.
Frontend generates a Kerberos ticket by its HTTP SPN to Authorization HTTP header
3.
Frontend proxies the HTTP request to Backend
4.
Backend IIS authenticates the request and check the authenticated user has TokenSerialization right
5.
Backend rehydrates the user from X-CommonAccessToken HTTP header
HTTP/HTTPS
CAS Backend
Module
F
Rehydration
Module
Module
D
Module
E
CAS Frontend
HttpProxy
Module
Module A
Module B
Module C
HTTP/HTTPS
Let's Start the Hack!
ProxyLogon
â€¢ The most well-known Exchange Server vulnerability in the worldðŸ˜©
â€¢ An unauthenticated attacker can execute arbitrary codes on Microsoft Exchange 
Server through an only exposed 443 port!
â€¢ ProxyLogon is chained with 2 bugs:
â€¢ CVE-2021-26855 - Pre-auth SSRF leads to Authentication Bypass
â€¢ CVE-2021-27065 - Post-auth Arbitrary-File-Write leads to RCE
Where ProxyLogon Begin?