2～4 篇的总页数为 755 页，占全书篇幅的 70%。因此阅读和消化这三篇的内容是读
懂这本书的主要任务。把这三篇内容搞懂了，就掌握了软件调试技术的基础和核心，同时
也可以把对 CPU、操作系统、编译器这三大核心的理解提高到一个新的水准。以后，我
会分别介绍每一篇的构思，给出一些阅读建议。但读到这里，读者应该清楚，全书的重心
在 2-4 篇。在重心之下，是第 1 篇，即绪论，这是其它 5 篇完成后，最后写的一篇，目的
是把读者带进门。 
第 5 篇可调试性，尽管很短，只有短短的两章，总共 52 页，但是它的“思想地位”非
常高。高效调试是学习和研究软件调试技术的初衷。如何实现高效调试呢？答案是调试过
程中涉及的每一个部件都要大力支援、积极配合，至少不要抵触和反抗。2-4 篇介绍了计
算机系统中的三大核心的调试支持，但如果被调试程序不配合，那么调试效率也会大打折
扣。因此第 5 篇的第一个目的是探讨被调试软件的可调试性，介绍在软件设计和开发过程
中就要考虑可调试性，未雨绸缪。第 5 篇的另一个目的是彰显可调试性这一主题，任何精
心设计的系统都应该考虑可调试性，对于 CPU、操作系统、编译器这样的基础设施，不
仅要考虑自身的可调试性，还要考虑如何支持应用软件的可调试性。 
如果说，第 1 篇是全书内容的第一轮循环，2-5 篇是第二轮循环，那么第 6 篇便是第
3 轮循环，它以调试器为视角，在介绍调试器的实现方法和使用方法的同时，将前面 5 篇
的内容“复习”了一遍。 
调试器是软件调试的最核心工具，是每个软件高手必备的武器，深谙调试器兵法是《软
件调试》这本书的核心目标，有人可能想，为什么不直接按照调试器来组织内容呢？我的
确考虑过在第 1 篇就详细介绍调试器。但是后来没有这么做，原因有二。第一，对于今天
的大多数调试器来说，它是与系统密切耦合的，夸张一点说，它只不过是底层调试功能的
一个用户接口。因此即使把一个调试器的所有代码都分析一遍，那么还有很多东西搞不清
楚。以 Windows 系统的用户态调试为例，调试器是建立在调试 API 之上的（《软件调试》
第 18 章），很多调试功能不过是一个 API 调用就进入到系统代码了。以内核调试为例，
WinDBG 不过是内核调试引擎（KD）的一个客户端（《软件调试》第 18 章）。第二，调
试器有很多种，如果正面围绕调试展开，那么选择哪种调试器呢？如果选 WinDBG，那么
整本书就变为《WinDBG 调试器 XXX》，这是我不希望的，不符合写作这本书的一般性
原则。 
在现在的架构中，调试器被安排在最后一篇，并不是降低它的地位，而是让其坐享前
面的基础。对于读者，有了前面的基础再理解调试器会觉得很自然，有水到渠成之感。对
于作者，写作这一篇时，也非常轻松，不时感觉到前面发散的内容在这里收敛了。另外，
把调试器安排在其它 5 篇的上面也与它的“接口”身份更吻合。 
归纳一下，《软件调试》的架构经历了三个版本。第一个版本侧重系统调试，书名为
ASD。第二个版本将写作范围扩大，书名推而广之为《软件调试》，内容划分为基础、开
发、工具四篇。第三个版本提高第二版本中基础篇的位置，将重心明确在一般原理和具有
共性的知识技巧上，缩减开发篇、工具和实践篇的内容。纵观这三个版本，版本 1 到版本
《软件调试》补编 
- 137 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
2 是扩张，版本 2 到版本 3 是精选和淘汰，前两个版本中的核心内容被细化，非原理性和
适用面狭窄的内容被去掉了。特别是实践篇被去除了，其中的有些内容被融入到其它篇中，
比如蓝屏崩溃被放入到第 3 篇，纳入到错误提示机制中讨论；栈溢出和内存泄漏被放入到
第 4 篇，与编译器的有关支持一起讨论。而目标读者较窄的 RPC 调试和 ACPI 调试只好放
弃了。放弃这些内容的一个长远规划是，在完成《软件调试》后，分专题写一系列实战性
的短篇，自称为调试战役系列。概而言之，《软件调试》的着眼点是软件调试的一般原理，
其目标是为所有喜欢调试技术的读者打下一个宽广而且坚实的基础，这个基础对于做调试
是有用的，对于做开发也是有用的，对于解决迫在眉睫的问题有用，对于长远的职业发展
也有用。为了实现通用性，那么只能多写具有共性的基础内容，舍弃细枝末节和具体问题，
让读者掌握这些基础后，自己来举一反三，也就是常说的“授之以渔”。希望读者阅读《软
件调试》时，能想起作者的这一良苦用心，这将有助于您理解书中的内容。 
《软件调试》补编 
- 138 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
《软件调试》导读之绪论篇  
《软件调试》的第 1 篇名为“绪论”，只包含一章，共 26 页，是全书最短的一篇。 
第一篇要实现的几个目标是： 
1）介绍基本概念和术语，为后面各篇打基础和做铺垫。比如，1.1.1 节给出了 Bug 和
Debug 的定义，1.6 节详细的讨论了 BUG，1.4 节介绍了常见的软件调试型态。  
2）浏览本书要介绍的主要调试技术，比如，1.5 节分 10 个专题（三级小节）浏览了
本后后面要深入讨论重要调试技术。 
3）突显软件调试技术的关键特征和重要性，1.2 节（基本特征）和 1.7 节（与软件工
程的关系）都是服务于这个目的的。 
读者在阅读第 1 篇时，建议认真阅读以下几个内容： 
1.1.2 节（P5）中的软件调试基本过程。这一内容虽然很基本，但是很重要。熟悉和
遵循这个基本过程是对调试高手的最起码要求。如果不遵循这个基本过程，有时候就会白
白浪费很多时间。比如，有些人没有在自己的调试环境下重现问题就开始跟踪代码，跟踪
了几个小时后才发现原来问题根本不会在这个系统中发生，或者跟踪的版本就不对。 
1.2 节中的软件调试基本特征。在写作这一内容时，我列出了很多个特征，然后进行
筛选和提炼，最终归纳为三大特征：难度大、难以估计完成时间和广泛的关联性。理解软
件调试的这三个特征对于学习软件调试和在实践中解决软件问题都很重要。因为软件调试
技术与其它技术有着广泛的关联性，所以学习软件调试时必须本着海纳百川的心态去博
学，而不能期望要用什么就学什么。因为“难以估计完成时间”，所以大家在工程实践中，
面对一个软件调试问题时，不能轻易“拍胸脯”，不到有十足把握时，不能下断言。 
1.3 节中的软件调试简要历史。两年前，某本杂志在做软件调试专题时，想找人写篇
文章介绍软件调试的历史，找到我，我说深知这个内容不好写，而且当时没有时间，便推
迟了，编辑很有信心的去找别人，但是始终没有找到。的确，还没有人仔细为软件调试编
写历史，很多调试技术是何时出现的还没有定论。考虑到了解历史的重要性，《软件调试》
有意做了很多努力，1.2 节介绍了断点、跟踪和分支监视的历史，28 章介绍了调试器的历
史，第 29 章介绍了 WinDBG 的发展历史，另外，在书中的其它章节中，也尽可能给出所
介绍技术或者工具的时间信息。《软件调试》的这些历史性内容在其他书中是很少见的。
阅读这些内容，有利于更深入的理解调试技术。 
从写作时间角度来看，第一篇是在后面 5 篇大局已定后才写的，不过在考虑篇章结构
时早已经预留好这一篇。 
概而言之，第一篇是很容易理解和阅读的，对于初学者来说，应该完整阅读全篇的内
容，特别是 1.1 节和 1.5 节。对于其它读者，那么建议仔细阅读 1.2（特征）、1.3（历史）、
1.6（对“错误与缺欠”的思考）和 1.7 节（关联性），浏览其它各节。 
《软件调试》补编 
- 139 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
《软件调试》导读之 CPU 篇 
《软件调试》的第 2 篇是 CPU 的调试支持，由第 2～7 章组成，共有 136 页，是全书
的第一个核心部分。写作和阅读这一篇的主要目标有如下几个： 
10. 介绍大多数软件工程师需要补充的 CPU 基础。  
11. CPU 对软件调试核心功能的支持。  
12. CPU 对软件调试扩展功能的支持。  
13. CPU 中用于调试系统故障和自身问题的设施。  
14. 现代 CPU 和集成芯片所使用的硬件调试方案。 
针对以上目标，第 2、3 章是满足目标 1 的，4～7 章依次是满足另外四个目标的。下
面对各部分的重点内容分别略作介绍。 
一、介绍一个调试高手应该掌握的 CPU 层的基础知识。第 2 章和第 3 章是专门服务
于这一目的的。调试好比行医看病，病人是计算机系统，要能看懂这个系统的毛病然后再
对其施以治疗或者手术，那么必须了解其五丈六腑的结构，血脉流通的路线，生息运转的
机理。要做到这一点，深刻理解计算机系统中硬件部分的核心——CPU——很重要。有人
说，CPU 是重要，但有什么必要在一本《软件调试》的书中写这个呢？调试高手还需要
数学基础和语文基础呢，怎么不开两章讲讲呢？这一拮问不是没有道理，因此作者考虑到
这一点，慎重选择了要讲的内容，并严格控制了篇幅。入选的内容要符合三个条件：一是
够重要，二是够常用，三是与调试密切相关。于是，《软件调试》最后选择如下一些内容： 
指令集的概念
指令集的概念
指令集的概念
指令集的概念（
（
（
（2.1 节
节
节
节）
）
）
）：有几次面试年轻的程序员时，我询问：“你熟悉哪种 CPU
架构和指令集呢？”不止一次，有人不能理解这个问题。“CPU 还有很多种（架构）吗？”x86
太成功了！指令是 CPU 的语言，理解指令集是为构筑软件知识大厦打下一块不可少的基
石。 
IA-32 处理器
处理器
处理器
处理器（
（
（
（2.2 节
节
节
节）
）
）
）：这也是一个备受胡略和误解的重要概念。有人说都进入 64
位时代了，还学 IA-32 干吗？殊不知，今天大多数 PC 使用的 x64 架构只是原有 32 位架构
中的一种新的操作模式（e.g. IA-32e）。要理解 x64，还需要先理解 32 位的情况。或者说，
如果有扎实的 32 位基础，那么可以很容易理解 64 位，反方向则很难走通。因为长达三十
多年的广泛应用（从 1985 年 80386 的推出算起），IA-32 架构对计算机的影响太深入了，
甚至超出了 CPU，影响到了系统总线和外设的设计。2.2 节使用 4 页半的篇幅全面浏览了
已经推出的每一代 IA-32 CPU，从 386 到今天的 Core 2 系列。 
CPU 的操作模式（2.3 节）：经常遇到的重要概念，扼要介绍。 
寄存器（2.4 节）：将 IA CPU 的所有寄存器分为五类做了介绍：通用寄存器、标志
寄存器、MSR 寄存器、控制寄存器和其它寄存器。除了介绍概念外，这一小节还有一个
目的是用作“调试手册”，我在调试时，时常还翻到这几页内容，查寄存器的位定义。 
保护模式（2.5-2.7 节）：这几乎是我做面试时必问的一个概念。深刻理解这个概念，
才能深刻理解今天的计算机系统在如何求解计算机领域的一个永恒课题——多任务。保护
《软件调试》补编 
- 140 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
数据是保护模式的一个主要任务，虚拟内存是目前实现这一任务的主要方法。页机制是今
天所有的商业操作系统都依赖的一种机制。理解虚拟内存和页机制对于软件调试也非常重
要。因为如果搞不清楚这些概念，那么就会被虚拟地址、线性地址、物理地址、IO 地址
这些概念所搞晕。也不容易建立起计算机世界的空间概念——内存空间、进程空间等。 
中断和异常（第 3 章）：这两个概念有联系，又不同。有时又被混用，所以不少程序
员对其模棱两可。IA-32 架构将异常分为三种，这更是很多人闻所未闻。记得有个陌生的
青年写 EMAIL 给我，对《软件调试》76 页的说法“当 CPU 产生异常时，其程序指针是指
向导致异常的下一条指令的”提出质疑： 
 “CPU 产生异常时，其程序指针不是指向原来那条指令吗？” 
我回信解释说“因为异常不同，异常发生时程序指针的取值是不同的”，他更加困惑： 
“我还是不能理解，难道异常还有两种吗？” 
我知道了他迷惑的根本原因，把表 3-1“异常分类”发给了他，这下他彻底清楚了。是
啊，如此重要的概念，我们的大学教育（包括计算机科学的研究生）里根本没有，也不能
完全怪个人。 
另外，3.4 节的“中断和异常优先级”是写给高水平读者的较难内容。 
二、CPU 对软件调试核心功能的根本支持，即第 4 章。这是全书的核心内容之一，
深入介绍了断点指令、调试寄存器和支持单步执行的陷阱标志。这三大支持是构筑今日调
试技术的三大基石，很多至关重要的调试功能都是建立在这三个基础之上的，包括设置断
点、变量监视、各种各样的跟踪执行、调试信息输出、内核调试等等。这一章共有 32 页，
读者应该认真阅读每一页。4.4 节的实模式调试器例析也值得仔细读，最好是把 Tim 
Paterson
先 生 所 写 的 汇 编 代 码 打 印 出 来 对 照 阅 读 （ 链 接 为 ：
http://www.patersontech.com/dos/Docs/Mon_86_1.4a.pdf），同时又可以学习汇编和欣赏大
师的“手笔”。 
三、CPU 对软件调试扩展功能的硬件支持，即第 5 章。第 4 章介绍的根本支持是从
80386 开始就定形了的东西。软件在不断发展，调试支持明显跟不上速度。因此今天的调
试技术很多时候很乏力。第 5 章介绍的分支记录和性能监视机制可以说是从奔腾开始的新
一代处理器引入的最重要调试支持。它是今天的大多数软件分析（profiling）和性能调优
（performance tune）工具所依赖的基础设施。 
四、机器检查机制（第 6 章）。这是奔腾 CPU 引入的一个旨在报告硬件问题的错误
记录和报告机制。这一机制对很多软件工程师可能都很陌生。了解这一机制，不仅可以学
到这样一个 CPU 层的基础知识，而且有助于建立“可调试性”的思想，也就是第 5 篇重点
讨论的东西。 
五、硬件调试方案（第 7 章）。软件问题是千变万化的，甚至可以说，很难找到两个
负责的软件问题是一模一样的。因此，不同的调试工具和调试技术都有它的适用范围，不
是无所不能的。比如有些问题，就适合用用户态调试会话来跟踪，有些问题使用内核调试
比较合适，有些问题只使用单纯的软件调试器可能根本不行。这时就要使用硬件调试工具
来帮忙。JTAG 是 CPU 和其它大规模集成芯片普遍使用的测试和调试方案，广泛用于调试
芯片自身、系统软件、固件和特殊复杂的软件问题。从某种程度上讲，基于 JTAG 技术的
硬件工具只是为调试器访问调试目标提供了一种“硬件化”的通信方法。在大多数情况下，
还是要依赖软件调试器这样的软件工具来实现各种调试。或者说，大多时候是把这种调试
方式统一到纯软件的调试方案架构中，这样调试者就可以使用熟悉的调试功能来实现调
《软件调试》补编 
- 141 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
试。比如，INTEL 的 ITP 工具就以 COM 组件方式为 WinDBG 提供了服务，使 WinDBG
可
以
通
过
ITP
工
具
进
行
内
核
调
试
，
参
见
http://advdbg.com/blogs/advdbg_system/articles/903.aspx。 
最后想提一下 2.8 节——系统概貌。这一节用一页的篇幅介绍了今天 PC 系统的硬件
架构，也就是图 2-13。在脑海中能有这样一幅图对于理解计算机系统很有好处。这里介绍
了一系列常用的术语，比如南桥、北桥、总线、芯片组等。CPU、北桥和南桥是目前主板
上的三颗最重要芯片。即将推向市场的下一代芯片组将把北桥的功能整合到 CPU 和南桥
中，即所谓的“双芯片架构”，不过这仍不影响基本的概念，比如内存控制器（memory 
controller）依然存在，只不过是移到 CPU 内部。 
总体来说，第 2 篇的内容都比较好理解，篇幅也不是很长。稍微用点毅力就可以将其
通读一遍。希望读者看过后能对 CPU 的认识有一个明显的提高，使自己的硬件基础更扎
实些。当然重中之重是调试支持，后面几篇还会接着讲...... 
《软件调试》补编 
- 142 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
《软件调试》导读之操作系统篇  
在今天的计算机架构中，操作系统是整个系统的统治者，它指挥着系统中的软硬件。
如果拿人类社会来类比，那么操作系统好比是国家机器，应用软件是公民，操作系统的各
个执行体是国家机构。从这个角度来看，操作系统与应用软件之间是统治与被统治的关系。 
对于最终用户来说，他们需要的是应用软件，大多用户说不清什么是操作系统，只知
道没有它不行。用户之所以肯掏出钱买操作系统是因为有了它才能跑自己需要的应用软
件。从这个角度来说，应用软件是操作系统从用户那里拿到钱的资本，应用软件是前台唱
戏的主角，操作系统是藏在后面的支持者。 