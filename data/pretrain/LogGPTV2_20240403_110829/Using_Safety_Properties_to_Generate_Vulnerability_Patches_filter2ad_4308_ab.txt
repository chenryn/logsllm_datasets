that results from a offset from a base pointer is less than the
upper bound of the buffer the base pointer is pointing to. While
such a vulnerability may occur for a variety of reasons, it
541
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
as the candidate location for the patch. Because not every
program operation affects safety properties, Senx checks safety
properties only for the set of operations that can affect them.
For example, Senx checks for overﬂow only on integers that
affect the size of for memory allocations. The execution trace
is transformed into expressions for synthesizing a source-
level patch. Since we aim to patch the source code, these
expressions must conform to the syntax of the programming
language of the target program.
Second, in predicate generation, Senx takes the violated
safety property, which also implies the type of the vulnerabil-
ity, and the source code expressions generated by vulnerability
identiﬁcation, and outputs a predicate required to prevent the
safety violation. Predicate generation maps the safety property
identiﬁed in the previous step to concrete expressions over
variables and function calls in the source code of the program.
Thus, the resulting predicate represents the safety property in
terms of source code expressions suitable for synthesizing the
source level patch.
Third, during patch placement, Senx uses the vulnerability
point found in vulnerability identiﬁcation and the predicate
produced in predicate generation to ﬁnd a program location
to insert the patch. This step solves the problem of ﬁnding a
program location where all necessary variables in the predicate
are in scope. Senx uses expression translation, described in
Section IV-D,
to translate all necessary variables into the
common scope. For check-and-error patches, Senx requires
the current scope to have some error handling code to call. It
uses Talos [19] to ﬁnd and select the error handling code.
Finally, in patch synthesis, Senx takes the patch location
and the instantiated predicate to generate the patch code.
Currently the only vulnerability class for which a repair patch
can be generated are integer overﬂows. In all other cases,
Senx generates a check-and-error patch that checks the patch
predicate and calls the error handling code if the predicate
evaluates to true.
B. Vulnerability Identiﬁcation
The concolic execution engine Senx uses during vulner-
ability identiﬁcation is based on KLEE [7]. Senx executes
the program in LLVM IR instructions with the vulnerability-
triggering input until a safety property is violated. It labels this
point the vulnerability point. The main output of this phase is
the vulnerability point, the violated safety property, and a set
of symbolic expressions that represent the symbolic values of
the variables in the executed program.
We modiﬁed KLEE’s LLVM IR execution engine to extract
expressions that retain enough information to be easily trans-
lated back into source code. For the most part, this involves
storing the source code symbol names along with the LLVM
IR instructions.
Senx also extends KLEE with support for complex data
types such as C/C++ structs, making it possible to translate
symbolic expressions back into source-code syntax for patch
generation. For example, a ﬁeld of a struct must be attached to
its parent object, and the generated syntax changes depending
Fig. 1: Workﬂow of Senx: each rounded rectangle represents
a step in Senx’s patch generation, each rectangle with vertical
bars represents a component of Senx.
is most often caused when a programmer mistakenly casts
a pointer to a type that is incompatible with the object the
pointer points to. This safety property can prevent both bad
casts for simple structs and objects, as well as nested structs
and objects.
Integer overﬂows. An integer overﬂow occurs when a vari-
able is assigned a value larger or smaller than what can be
represented in the variable. A vulnerability from an integer
overﬂow can occur if the result of an overﬂow is then used
to allocate a buffer, resulting in a buffer that is far smaller
than expected. As a result, the corresponding safety property
checks that value used in a memory allocation is not the result
of an integer overﬂow.
As a prototype, we have started with only these three vul-
nerability classes. Nevertheless, they are representative enough
to capture a good percentage of CVE vulnerabilities. We
conducted an informal analysis on the CVEs reported in 2018
[15]. At the time of our analysis, 8,507 vulnerabilities have
been reported and the most popular vulnerability categories are
denial of service, code execution, and overﬂow. By randomly
examining 100 CVE reports for each of the three vulnerability
categories, we ﬁnd that 25% of CVE vulnerabilities fall into
buffer overﬂow, bad cast, and integer overﬂow. We believe the
principles behind Senx can be extended to other vulnerability
classes, which we intend to do in future work.
A. Overview
IV. DESIGN
The goal of Senx is to generate source code patches that
can be easily veriﬁed and adopted by developers. Senx gener-
ates patches in four distinct steps: vulnerability identiﬁcation,
predicate generation, patch placement, and patch synthesis, as
illustrated in Figure 1.
First, during vulnerability identiﬁcation, Senx takes a pro-
gram and an input that can trigger a vulnerability, and outputs
the vulnerability point [4] in
the violated safety property,
the program, and the source code expressions for the ex-
ecution trace. Senx leverages concolic execution using the
vulnerability-triggering input to generate the execution trace
for the input. Senx then checks the execution trace to identify
which safety property is violated and the point at which safety
property is violated, the vulnerability point, which also serves
542
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
programinputpatchVulnerability IdentificationPredicate GenerationPatch PlacementPatch SynthesisLoop CloningAccess Range AnalysisExpression Translationon whether the parent object is referenced using a pointer or
with a variable holding the actual object. Arrays and structs
can also be nested and the proper syntax must be used to
denote the level of nesting relative to the top level object.
Senx has its own IR that records these relationships so a
value can be converted back to a source code expression that
contains the parent struct or array’s name and not just the ﬁeld
name or array index. In this way, Senx can recover the full
expression for a variable such as foo→f.bar[10], where
as without these extensions, Senx would only know that the
variable corresponds to the 10th element in an array.
C. Predicate Generation
The objective of predicate generation is to take the abstract
boolean expression of the violated safety property identiﬁed
in the previous phase and map it to concrete expressions in
the program source code. Senx uses the variables that violated
the safety property at the vulneraility point as a starting point
for generating the predicate.
The case of the integer overﬂow property is the simplest.
In this case, the property is violated when an integer that has
overﬂown is used to determine the size of a buffer allocation.
As a result, Senx generates a predicate that would prevent
the integer variable from overﬂowing. There are two possible
causes for such a vulnerability. In the ﬁrst case, the program
assigns the result of an overﬂowed operation into a variable
whose size is larger than the size of the operation (e.g.,
assigning the result of an overﬂowed 32-bit multiplication into
a 64-bit variable). In this case, Senx generates a repair patch
by modifying the type of the operation so that the overﬂow
does not happen (e.g., changing the 32-bit multiplication into
a 64-bit multiplication). In the second case, there is no such
assignment. So Senx generates a check-and-error predicate
that checks whether the result is smaller than expected (for
example, if the result of an addition is smaller than either of
its inputs).
A predicate to detect a bad cast takes the form
(mem_access > buﬀer_upper||mem_access  buﬀer_upper
mem_access_lower 
rows * ( c o l s + 1 ) + 1 )
return −1;
char * o u t p u t = f o o _ m a l l o c ( rows ,
i f
( ! o u t p u t )
return −1;
s i z e ,
c o l s , o u t p u t ) ;
c o l s + 1 ) ;
i f
foo ( char * i n p u t ) {
1 char * f o o _ m a l l o c ( x , y ) {
2
3 }
4
5 i n t
6 +
7 +
8 +
9
10
11
12
13
14 }
15
16 void b a r ( char * s r c , i n t
17
18
19
b a r ( p ,
return 0 ;
s i z e , i n t
c o l s , char * d e s t ) {
char *p = d e s t ; char *q = s r c ;
while ( q < s r c + s i z e )
f o r ( unsigned j = 0 ;
{
j < c o l s ;
j ++)
20
21
22
23
24 }
* ( p ++) = * ( q ++) ;
* ( p ++) = ' \ n ' ;
}
*p = ' \ 0 ' ;
Listing 2: A buffer overﬂow CVE-2012-0947 with a patch
(preﬁxed with ’+’).
enclosing a memory access instruction inst in function F,
starting with the innermost loop and iterating to the outermost,
accumulating increments and decrements on the loop induction
variables including the pointer used by inst.
We use the loop in bar of Listing 2 as an example of
how Algorithm 1 can be applied to a nested loop. In this
case, bar is function F and inst is the memory write using
pointer p at line 42. For each loop, Sen retrieves the loop
iterator variable and the bounds of it by calling helper function
find_loop_bounds. Senx also gets the list of induction
variables of the loop and their update, which is the ﬁxed
amount that an induction variable is increased or decreased
by on each loop iteration by calling another helper function
find_loop_updates. In our example, we have iter =
j, initial = 0, end = cols and j (cid:55)→ 1, p (cid:55)→ 1, q (cid:55)→ 1 in
updates for the innermost for loop from lines 19-20.
Algorithm 1 then symbolically accumulates the update to
each induction variable to a data structure referred to by acc,
which maps each induction variable to an expression denoting
the accumulated update to the induction variable. As for the
example, it will store j (cid:55)→ 1, p (cid:55)→ 1, q (cid:55)→ 1 into acc for the
innermost for loop. After that, it synthesizes the expression
to denote the total number of iterations for the loop. At line
16 of the algorithm, we will have count = cols which is
simpliﬁed from (cols-0)/1.
Having the total number of iterations,
it multiplies the
accumulated update for each induction variable by the total
number of iterations. So acc will have j (cid:55)→ cols, p (cid:55)→
cols, q (cid:55)→ cols after the loop from line 18 to 19 in
Algorithm 1.
Once this is done, it moves on to analyze the next loop
enclosing inst, which in Listing 2 is the while loop en-
closing the inner for loop. As a consequence, we will have
544
Algorithm 1 Finding the access range of a memory access.
Input: F : a function
inst: a memory access instruction in F
Output: acc_initial: initial address acccessed by inst
l as count
acc_end: end address accessed by inst
1: procedure ANALYZE_ACCESS_RANGE
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
(cid:46) acc: accumulated updates to induction variables
acc ← ∅
innermost_loop ← innermost_loop(inst)
outermost_loop ← outermost_loop(inst)
visited ← ∅
for l ∈ [innermost_loop, outermost_loop] do
iter, initial, end ←ﬁnd_loop_bounds(F, l)
updates, visited ←ﬁnd_loop_updates(l, visited)
(cid:46) Symbolically add up induction updates
for var, upd ∈ updates do
acc{var} ← sym_add(acc{var}, upd)
end for
(cid:46) Symbolically denote the number of iterations of
upd_iter ← updates{iter}
count ←sym_div(sym_sub(end, initial), upd_iter))
(cid:46) Symbolically multiply induction updates by the
number of iterations of l
for var, upd ∈ acc do
if ¬is_initialized_in_last_loop(var) then
acc{var} ←sym_mul(acc{var}, count)
end if
end for
end for
ptr ←get_pointer(inst)
f irst_inst ←loop_head_instruction(outermost_loop)
(cid:46) Find the deﬁnition of ptr that reaches f irst_inst
acc_initial ←reaching_deﬁnition(F, f irst_inst, ptr)
acc_end ←sym_add(acc_initial, acc{p})
return acc_initial, acc_end
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30: end procedure
15:
16:
17:
iter = q, initial = src, end = src+size and p (cid:55)→ 1
in updates at line 10 of the algorithm, j (cid:55)→ cols, p (cid:55)→
cols + 1, q (cid:55)→ cols in acc and count = size/cols
at line 17 of the algorithm, and ﬁnally j (cid:55)→ cols, p (cid:55)→
(cols+1)*(size/cols), q (cid:55)→ size in acc. Note that
the algorithm will not multiply the number of iterations of the
loop to j because j is always initialized in the last analyzed
loop, the innermost for loop.
After analyzing all
the loops enclosing inst,
the algo-
rithm gets the pointer ptr used by inst and performs
reaching deﬁnition dataﬂow analysis to ﬁnd the deﬁnition
that reaches the beginning of the outermost
loop. As for
the example, we will have ptr = p and the assignment
p=dest at line 16 of bar as the reaching deﬁnition for
p. From this reaching deﬁnition, it extracts the initial value
of p, acc_initial = dest. Finally it gets the end value
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 