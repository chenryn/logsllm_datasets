**简介**
ja3 是为特定客户端与服务器之间的加密通信提供了具有更高的识别度的指纹，是 TLS 协商的指纹。
ja3 由 `ClientHello 的版本`、`可接受的加密算法`、`扩展列表中的每一个 type 值`、`支持的椭圆曲线`和`支持的椭圆曲线格式` 生成
ja3s 由 `Server Hello 版本`、`可接受的加密算法`和`扩展列表中的每一个 type 值`生成
**相关文章**
- [JA3(S)，简单而有效的 TLS 指纹](https://www.tr0y.wang/2020/06/28/ja3/)
- [TLS Fingerprinting with JA3 and JA3S](https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967/)
    - [利用JA3和JA3S实现TLS指纹识别](https://xz.aliyun.com/t/3889)
- [Demystifying JA3: One Handshake at a Time](https://infosecwriteups.com/demystifying-ja3-one-handshake-at-a-time-c80b04ccb393)
- [JA3/S SIGNATURES AND HOW TO AVOID THEM](https://www.bc-security.org/post/ja3-s-signatures-and-how-to-avoid-them/)
- [深度剖析ja3指纹及突破](https://mp.weixin.qq.com/s/-QaoaQj4cKH-wcAc3Ha60g)
- [Impersonating JA3 Fingerprints](https://medium.com/cu-cyber/impersonating-ja3-fingerprints-b9f555880e42)
- [python完美突破tls/ja3](https://mp.weixin.qq.com/s/GU2AgushvIEtLHtYR7BQzg)
- [云沙箱流量识别技术剖析](https://www.anquanke.com/post/id/277431)
- [CURL’S TLS FINGERPRINT](https://daniel.haxx.se/blog/2022/09/02/curls-tls-fingerprint/)
- [用Go构建你专属的JA3指纹](https://juejin.cn/post/7073264626506399751)
- [反向探测互联网扫描器](https://mp.weixin.qq.com/s/Cha_hTGOh-GGVkaZRdFujw)
- [反爬虫SSL TLS指纹识别和绕过JA3算法](https://blog.csdn.net/god_zzZ/article/details/123010576)
- [TLS握手指纹初探](https://bjun.tech/blog/xphp/138)
- [TLS中的GREASE机制](https://zhuanlan.zhihu.com/p/343562875)
- [关于TLS握手指纹 JA3的一些发现](https://bjun.tech/blog/xphp/140)
- [nginx获取ja3指纹](https://www.bbmax.cc/index.php/archives/80/)
- [Java获取SSL/TLS指纹（JA3）](https://www.bbmax.cc/index.php/archives/41/)
**如何计算ja3值**
```bash
git clone https://github.com/salesforce/ja3
cd ja3/python
python3 ja3.py test.pcap
```
**快速查看自己当前的 ja3 指纹**
- https://ja3er.com/json
**相关工具**
- [Macr0phag3/ja3box](https://github.com/Macr0phag3/ja3box) - ja3(s) 提取工具
    ```bash
    pip3 install scapy colorama cryptography
    git clone https://github.com/Macr0phag3/ja3box.git
    cd ja3box
    python3 ja3box.py -i eth0 --json
    ```
- [fooinha/nginx-ssl-ja3](https://github.com/fooinha/nginx-ssl-ja3) - nginx module for SSL/TLS ja3 fingerprint.
- [lafaspot/ja3_4java](https://github.com/lafaspot/ja3_4java)
**ja3 检测绕过**
- [Danny-Dasilva/CycleTLS](https://github.com/Danny-Dasilva/CycleTLS) - Spoof TLS/JA3 fingerprints in GO and Javascript
- [CUCyber/ja3transport](https://github.com/CUCyber/ja3transport) - Impersonating JA3 signatures
    - https://mp.weixin.qq.com/s/cX7-kHuIWebDH6r6UQ2I4w
- [wangluozhe/requests](https://github.com/wangluozhe/requests) - 用于快速请求 HTTP 或 HTTPS，并支持修改 ja3 指纹
    - https://mp.weixin.qq.com/s/fichyYFlR9noBIX3AeRmmg
- [lwthiker/curl-impersonate](https://github.com/lwthiker/curl-impersonate) - A special build of curl that can impersonate Chrome & Firefox
**指纹库**
- https://sslbl.abuse.ch/ja3-fingerprints/
- https://github.com/salesforce/ja3/tree/master/lists
- https://ja3er.com/getAllUasJson
### jarm
- https://github.com/salesforce/jarm
**相关文章**
- [Easily Identify Malicious Servers on the Internet with JARM](https://engineering.salesforce.com/easily-identify-malicious-servers-on-the-internet-with-jarm-e095edac525a/)
- [A Red Teamer Plays with JARM](https://www.cobaltstrike.com/blog/a-red-teamer-plays-with-jarm/)
- [利用JARM指纹进行TLS服务端标记](https://www.anquanke.com/post/id/225627)
- [JARM指纹随机化技术实现](https://www.anquanke.com/post/id/276546)
**jarm 规避**
- [netskopeoss/jarm_randomizer](https://github.com/netskopeoss/jarm_randomizer)
### TLS Poison
**相关资源**
- [jmdx/TLS-poison](https://github.com/jmdx/TLS-poison)
**相关文章**
- [When TLS Hacks You](https://i.blackhat.com/USA-20/Wednesday/us-20-Maddux-When-TLS-Hacks-You.pdf)
- [BlackHat2020 议题分析之“When TLS Hacks You”](https://mp.weixin.qq.com/s/GT3Wlu_2-Ycf_nhWz_z9Vw)
- [基于 A 和 AAAA 记录的一种新 DNS Rebinding 姿势–从西湖论剑2020 Web HelloDiscuzQ 题对 Blackhat 上的议题做升华](https://www.zhaoj.in/read-6681.html)
- [BlackHat2020 议题 “When TLS Hacks You” 复现](https://xz.aliyun.com/t/9177)
- [一篇文章带你读懂 TLS Poison 攻击](https://blog.zeddyu.info/2021/04/20/tls-poison/)
- [TLS-Poison 攻击方式在 CTF 中的利用实践](https://blog.zeddyu.info/2021/05/19/tls-ctf/)
**描述**
当客户端和服务器端初次建立 TLS 握手时（例如浏览器访问 HTTPS 网站），需要双方建立一个完整的 TLS 连接，该过程为了保证数据的传输具有完整性和机密性，需要做很多事情，如密钥协商出会话密钥，数字签名身份验证，消息验证码 MAC 等。这个过程是非常消耗资源的，而且当下一次客户端访问同一个 HTTPS 网站时，这个过程需要再重复一次，这无疑会造成大量的资源消耗。
为了提高性能，TLS/SSL 提供了会话恢复的方式，允许客户端和服务端在某次关闭连接后，下一次客户端访问时恢复上一次的会话连接。会话恢复有两种，一种是基于 session ID 恢复，一种是使用 Session Ticket 的 TLS 扩展。
**基于 session ID 的会话恢复**
每一个会话都由一个 Session ID 标识符标识，当建立一个 TLS 连接时，服务器会生成一个 session ID 给客户端，服务端保留会话记录，重新连接的客户端可以在 clientHello 消息期间提供此会话 ID，并重新使用此前建立的会话密钥，而不需要再次经历秘钥协商等过程。
TLS session id 在 RFC-5077 中有着详细描述，基本所有数据都可以用作会话标志符，包括换行符。
Session ticket 和 session id 作用类似，在客户端和服务端建立了一次完整的握手后，服务端会将本次的会话数据加密，但是 session ticket 将会话记录保存在客户端，而且与 session id 32 字节的大小不同，session ticket 可提供 65k 的空间，这就能为我们的 payload 提供足够的空间。
**攻击思路**
session id 是服务器提供给客户端的，如果我们构建一个恶意的 tls 服务器，然后将我们的恶意 session id 发送给客户端，然后通过 dns rebinding，将服务器域名的地址指向内网 ip 应用，例如 memcache，客户端在恢复会话时就会带上恶意的 session id 去请求内网的 memcache，从而攻击了内网应用。
大致流程如下：
1. 利用受害者服务器向攻击者准备的 TLS Server 发起一个 HTTPS 请求
2. 当受害者打开这个页面后，受害者客户端会查询相应的 DNS 记录，最终会在攻击者准备的 DNS 服务器查询到攻击者提供的解析记录
3. 攻击者的 DNS 服务器回应一个 TTL 为 0 的结果，指向攻击者的 TLS Server 服务器。
4. 客户端发送 Client Hello 消息
5. 服务端返回 Server Hello 消息，并在响应包中设置 session_id 为 payload
6. 进行后续的TLS握手
7. 握手完成后进行 http 通信时，攻击者 TLS Server 返回 301 跳转
8. 受害者客户端接收跳转，这次跳转时由于前面那一次 DNS 解析的结果为 TTL 0，则会再次发起一次解析请求
此时攻击者让 DNS 服务器返回解析结果为 SSRF 攻击的目标（例如本地的 memcache 数据库）,且 TTL 为 0
9. 因为请求和跳转时的域名都没有变更，本次跳转会带着之前服务端返回的精心构造过的 SessionID 进行(TLS 会话重用)，发送到目标的那个端口上。
10. payload 被发送至 SSRF 攻击的目标,达到目的，成功 SSRF，但是因为会话重用失败，受害者客户端会得到一个 TLS Error 的错误。至此完成所有攻击步骤。
**通过对 curl 解析 AAAA 和 A 记录的顺序进行利用(未复现成功)**
> 出自文章 [基于 A 和 AAAA 记录的一种新 DNS Rebinding 姿势–从西湖论剑2020 Web HelloDiscuzQ 题对 Blackhat 上的议题做升华](https://www.zhaoj.in/read-6681.html)
在 CURL 中，对于一个域名，如果同时具有 A 记录和 AAAA 记录，那么 CURL 会去优先请求 AAAA 或者 A 记录所指向的地址，如果这些地址无法连接，则会尝试连接同时得到的 A 记录或者 AAAA 记录。
在某些情况下，会出现：
- AAAA 记录地址不通，会连接到 A 记录地址上。
- A记录地址不通，会连接到 AAAA 记录地址上。
第一个地址不通，则会尝试第二个地址。
那么我们可以这样做：
1. 第一次让 CURL 去访问恶意的 HTTPS 服务器，拿到一个恶意的 SessionID，然后使恶意的 HTTPS 服务器无法接收新的连接
2. 这时恶意的 HTTPS 给出第一次返回的结果，使其进行同域名跳转
3. 目标跳转时会尝试进行新连接，目标发现恶意的HTTPS 服务器无法连接，则会尝试连接这个域名下的其他记录所指向的地址，并带上 SessionID
复现环境
- https://github.com/glzjin/tlslite-ng
- https://gitee.com/wendell_tong/tls_poison_study
**双 A 记录**
> 出自文章 [一篇文章带你读懂 TLS Poison 攻击#The Optimization Method OF DNS Rebinding](https://blog.zeddyu.info/2021/04/20/tls-poison/#the-optimization-method-of-dns-rebinding)
默认配置下，可以通过 0.0.0.0:11211 这个地址与 memcached 通信,对于返回的双 A 记录，一个配置为 TLS VPS IP ，另一个为 0.0.0.0 ，curl 每次都会优先使用 TLS VPS IP ，如果不能通信才会接着使用 0.0.0.0:11211
根据已知信息，我们可以让 curl 第一次建立链接，拿到我们分配的 payload 后，断开连接，让其第二次连接不通而去选择另外一个 IP
复现环境
- https://github.com/ZeddYu/TLS-poison
**TLS 1.2 Session Ticket**
- https://blog.zeddyu.info/2021/04/20/tls-poison/#use-the-optimization-method-to-deal-with-tls-12-session-ticket
- https://blog.zeddyu.info/2021/04/20/tls-poison/#curl-session-ticket
**TLS 1.2 Session ID**
- https://blog.zeddyu.info/2021/04/20/tls-poison/#use-the-optimization-method-to-deal-with-tls-12-session-id
---
### Shadow-TLS
- https://github.com/ihciah/shadow-tls
**相关文章**
- [Shadow-TLS隐蔽加密通道工具技术分析](https://www.viewintech.com/html/articledetails.html?newsId=23)
---
## UPNP
**相关工具**
- [nccgroup/UPnP-Pentest-Toolkit](https://github.com/nccgroup/UPnP-Pentest-Toolkit)
**CVE-2020-12695**
- POC | Payload | exp
    - [yunuscadirci/CallStranger](https://github.com/yunuscadirci/CallStranger)
---
## VNC
**相关文章**
- [VNC攻击](https://b404.xyz/2017/10/16/attack-vnc/)
**未授权访问漏洞**
- 概述
    VNC 是虚拟网络控制台 Virtual Network Console 的英文缩写。它是一款优秀的远程控制工具软件由美国电话电报公司 AT&T 的欧洲研究实验室开发。VNC 是基于 UNXI 和 Linux 的免费开源软件由 VNC Server 和 VNC Viewer 两部分组成。VNC 默认端口号为 5900、5901。VNC 未授权访问漏洞如被利用可能造成恶意用户直接控制 target 主机。
- [vncviewer](https://www.realvnc.com/en/connect/download/viewer/)
    ```bash
    # kali 自带
    vncviewer [ip]
    ```
- MSF 模块
    ```bash
    use auxiliary/scanner/vnc/vnc_none_auth
    set rhosts [ip]
    set threads 50
    run
    ```
**暴力破解**
- MSF 模块
    ```bash
    use auxiliary/scanner/vnc/vnc_login
    set RHOSTS [ip]
    set RPORT [port]
    set pass_file /root/Desktop/pass.txt
    run
    ```
**密码破解**
- 相关文章
    - [破解vnc密码](https://blog.51cto.com/darren/587007)
- 相关工具
    - [k8vncpwd](https://github.com/k8gege/K8tools/blob/master/k8vncpwd.exe)
    - [K8fuckVNC](https://github.com/k8gege/K8tools/blob/master/K8fuckVNC.rar)
---
## Other
### Ripple20
**描述**
安全研究人员在由 Treck 开发的 TCP/IP 协议栈中发现了多个漏洞，这一系列漏洞统称为 Ripple20。这些漏洞广泛存在于嵌入式和物联网设备中，影响了多个行业领域（包括医疗、运输、能源、电信、工业控制、零售和商业等），涉及了众多供应商（包括 HP、Schneider Electric、Intel、Rockwell Automation、Caterpillar、Baxter 等）。
这些漏洞源于 Ripple20 的多个协议（包括 IPv4、ICMPv4、IPv6、IPv6OverIPv4、TCP、UDP、ARP、DHCP、DNS 或以太网链路层）在处理网络报文发送时存在缺陷，其中包括四个严重漏洞，它们的 CVE 编号分别为 CVE-2020-11896、CVE-2020-11898、CVE-2020-11910、CVE-2020-11911。CVE-2020-11896（CVSS 评分 10）可导致远程执行代码，CVE-2020-11897（CVSS 评分 10）可导致越界写入，CVE-2020-11901（CVSS 评分 9）可导致远程执行代码，CVE-2020-11898（CVSS 评分 9.1）可导致泄露敏感信息。其它 15 个 Ripple20 漏洞的严重程度各异，CVSS 评分分别从 3.1 到 8.2。
**相关文章**
- [Ripple20：Treck TCP/IP协议栈漏洞分析与验证（附视频）](https://paper.seebug.org/1262/)
- [关于 CVE-2020-11896和CVE-2020-11898 的学习笔记](https://bestwing.me/Ripple20-overview.html)
- [Treck TCP/IP协议库“Ripple20”漏洞分析及解决方案](https://mp.weixin.qq.com/s/njG6V6y4OdpGJWZ8UCTMGg)
**相关资源**
- [corelight/ripple20](https://github.com/corelight/ripple20) - 用于检测 Ripple20 漏洞的 Zeek 脚本
**POC | Payload | exp**
- [jiansiting/ripple20-poc](https://github.com/jiansiting/ripple20-poc)
### AMNESIA33
**描述**
安全研究人员在多个被广泛使用的开源 TCP/IP 协议栈发现了多个漏洞，这一系列漏洞统称为 AMNESIA33。这些漏洞广泛存在于嵌入式和物联网设备中，影响了多个行业领域（包括医疗、运输、能源、电信、工业控制、零售和商业等），目前已知范围内涉及了超 150 家供应商以及数以百万计的设备。与 URGEN11 和 Ripple20 不同的是，AMNESIA33 影响的是多个开源 TCP/IP 协议栈，因此这些漏洞可以悄无声息地影响到无数个代码库、开发团队与各个公司的产品。目前已知的漏洞涉及到了智能家居、工厂 PLC、SCADA 设备与工控交换机，电力监控等设备。
这些漏洞存在于 uIP、FNET、picoTCP 和 Nut/Net 等开源协议栈上，影响 TCP/IP 协议栈的多个组件，包括 DNS、IPv6、IPv4、TCP、ICMP、LLMNR 和 mDNS 等。其中包括多个严重漏洞，它们的 CVE 编号分别为 CVE-2020-17437、CVE-2020-17443、CVE-2020-24338、CVE-2020-24336、CVE-2020-25111。
CVE-2020-17437（CVSS 评分 8.2）、CVE-2020-17443（CVSS 评分 8.2）可导致设备拒绝服务。CVE-2020-24338、CVE-2020-24336、CVE-2020-25111（这三个 CVSS 评分均为 9.8）都可导致远程代码执行 (RCE)。其它 28 个漏洞的严重程度各异，CVSS 评分分别从 4 到 8.2。
由于 IoT、OT、IT 设备供应链的特性，漏洞影响的设备众多，影响范围广且持续时间长，漏洞修复的实施较困难。同时，由于 uIP、picoTCP 开源协议栈已经不再维护，所以部分漏洞没有补丁，很多产品只能寻找替代技术方案或者是增加防范措施。
**相关文章**
- [AMNESIA33：开源TCP/IP协议栈系列漏洞分析与验证](https://mp.weixin.qq.com/s/UWeFBK3E1Zs4cTcMl4UU3A)
### NAT Slipstreaming
> https://github.com/samyk/slipstream/ - NAT Slipstreaming allows an attacker to remotely access any TCP/UDP services bound to a victim machine, bypassing the victim’s NAT/firewall, just by the victim visiting a website
**相关文章**
- [NAT Splitstreamming v1 浅析](https://forum.butian.net/share/88)