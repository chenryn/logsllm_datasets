Independent of the forward secrecy aspect, in the case of key-dependent security, setting the relevant
key states to revealed for some stage i is done by internally invoking Reveal(label, i), ignoring the
response and also the restriction that a call with i > stage would immediately return ⊥. This
ensures that follow-up revocations of keys that depend on the revoked keys are carried out correctly.
• Test(label, i): Tests the session key of stage i in the session with label label. In the security game
i, but st0
exec, stage0, sid0, cid0, K0, st0
key, tested0) (for label
key, tested0) in ListS with sidi = sid0
this oracle is given a uniformly random test bit btest as state which is ﬁxed throughout the game.
If there is no tuple (label, U, V, role, auth, kidU , kidV , stexec, stage, sid, cid, K, stkey, tested) in ListS or if
label.stexec 6= acceptedi, return ⊥. If there is a tuple (label0, V, U, role0, auth0, kidV , kidU , st0
exec, stage0,
exec 6= acceptedi, set the ‘lost’ ﬂag to lost ←
sid0, cid0, K0, st0
true. This ensures that keys can only be tested if they have just been accepted but not used yet,
including ensuring any partnered session that may have already established this key has not used it.
If label.authi = unauth or if label.authi = unilateral and label.role = responder, but there is no tuple
6= label0) in ListS
(label0, V, U, role0, auth0, kidV , kidU , st0
i, then set lost ← true. This ensures that having an honest contributive partner is a
with cidi = cid0
prerequisite for testing responder sessions in an unauthenticated or unilaterally authenticated stage
and for testing an initiator session in an unauthenticated stage.9
If label.testedi = true, return Ki, ensuring that repeated queries will be answered consistently.
Otherwise, set label.testedi to true. If the test bit btest is 0, sample label.Ki ←$ D at random from the
session key distribution D. This means that we substitute the session key by a random and indepen-
dent key which is also used for future deployments within the key exchange protocol. Moreover, if
there is a tuple (label0, V, U, role0, auth0, kidV , kidU , st0
key, tested0) in ListS with
i ← true to ensure consistency in the special
sidi = sid0
case that both label and label0 are in state acceptedi and, hence, either of them can be tested ﬁrst.
Return label.Ki.
exec, stage0, sid0, cid0, K0, st0
i, also set label0.K0
i ← label.Ki and label0.tested0
Secret compromise paradigm. We follow the paradigm of the Bellare–Rogaway model [BR94], fo-
cusing on the leakage of long-term secret inputs and session key outputs of the key exchange, but not
on internal values within the execution of a session. This contrasts to some extent with the model by
Canetti and Krawczyk [CK01] resp. LaMacchia et al. [LLM07] which include a “session state reveal” resp.
“ephemeral secret reveal” query that allows accessing internal variables of the session execution.
In the context of the TLS 1.3 drafts, this means we consider the leakage of:
• long-term / static secret keys (such as the signing key of the server or client): allowed since long-term
values have the potential to be compromised, and necessary to model forward secrecy; modeled by
the Corrupt query.
• session keys (such as tkhs, tkapp, RMS, and EMS): allowed since these are outputs of the session and
are used outside the key exchange for encryption, later resumption, or exporting of keying material;
modeled by the Reveal query.
9Note that ListS entries are only created for honest sessions, i.e., sessions generated by NewSession queries.
17
We do not permit the leakage of:
exponent): disallowed since TLS is not designed to be secure if these values are compromised.
• ephemeral secret keys (such as the randomness in the signature algorithm or the Diﬃe–Hellman
• internal values / session state (such as ES, SS, master secrets): disallowed since TLS is not designed
• semi-static secret keys (such as s in draft-dh): disallowed in the model in this paper because the
security of the full draft-dh handshake does not depend on the secrecy of s; however, an analysis of
the 0-RTT handshake should include a consideration of the leakage of semi-static secret keys.
to be secure if these values are compromised.
4.5 Security of Multi-Stage Key Exchange Protocols
The security properties for multi-stage key exchange protocols are split in two games, following Fischlin
et al. [FG14] and Brzuska et al. [BFWW11, Brz13]. On the one hand, Match security ensures that the
session identiﬁers sid eﬀectively match the partnered sessions. On the other hand, Multi-Stage security
ensures Bellare–Rogaway-like key secrecy.
4.5.1 Match Security
Our notion of Match security—extended beyond [FG14] to cover diﬀerent levels of key authenticity and
soundness of the newly introduced contributive identiﬁers—ensures that the session identiﬁers sid eﬀectively
match the partnered sessions which must share the same view on their interaction in the sense that
1. sessions with the same session identiﬁer for some stage hold the same key at that stage,
2. sessions with the same session identiﬁer for some stage agree on that stage’s authentication level,
3. sessions with the same session identiﬁer for some stage share the same contributive identiﬁer at that
stage,
4. sessions are partnered with the intended (authenticated) participant,
5. session identiﬁers do not match across diﬀerent stages, and
6. at most two sessions have the same session identiﬁer at any stage.
The Match security game GMatch
KE,A thus is deﬁned as follows.
Definition 4.1 (Match security). Let KE be a key exchange protocol and A a PPT adversary interacting
with KE via the queries deﬁned in Section 4.4 in the following game GMatch
KE,A :
Setup. The challenger generates long-term public/private-key pairs for each participant U ∈ U.
Query. The adversary A receives the generated public keys and has access to the queries NewSession,
Send, NewTempKey, Reveal, and Corrupt.
Stop. At some point, the adversary stops with no output.
We say that A wins the game, denoted by GMatch
KE,A = 1, if at least one of the following conditions hold:
1. There exist two distinct labels label, label0 such that label.sidi = label0.sidi 6= ⊥ for some stage i ∈
{1, . . . , M}, label.stexec 6= rejectedi, and label0.stexec 6= rejectedi, but label.Ki 6= label0.Ki. (Diﬀerent
session keys in some stage of partnered sessions.)
2. There exist two distinct labels label, label0 such that label.sidi = label0.sidi 6= ⊥ for some stage i ∈
{1, . . . , M}, but label.authi 6= label0.authi. (Diﬀerent authentication types in some stage of partnered
sessions.)
3. There exist two distinct labels label, label0 such that label.sidi = label0.sidi 6= ⊥ for some stage i ∈
{1, . . . , M}, but label.cidi 6= label0.cidi or label.cidi = label0.cidi = ⊥. (Diﬀerent or unset contributive
identiﬁers in some stage of partnered sessions.)
4. There exist two distinct labels label, label0 such that label.sidi = label0.sidi 6= ⊥ for some stage i ∈
{1, . . . , M}, label.authi = label0.authi ∈ {unilateral, mutual}, label.role = initiator, and label0.role =
18
responder, but label.V 6= label0.U or (only if label.authi = mutual) label.U 6= label0.V . (Diﬀerent
intended authenticated partner.)
5. There exist two (not necessarily distinct) labels label, label0 such that label.sidi = label0.sidj 6= ⊥ for
some stages i, j ∈ {1, . . . , M} with i 6= j. (Diﬀerent stages share the same session identiﬁer.)
6. There exist three distinct labels label, label0, label00 such that label.sidi = label0.sidi = label00.sidi 6= ⊥
for some stage i ∈ {1, . . . , M}. (More than two sessions share the same session identiﬁer.)
We say KE is Match-secure if for all PPT adversaries A the following advantage function is negligible in
the security parameter:
KE,A := Prh
KE,A = 1i
GMatch
AdvMatch
.
:
Multi-Stage,D
KE,A
Multi-Stage,D
KE,A
deﬁnes Bellare–Rogaway-like key secrecy in the multi-stage setting as
4.5.2 Multi-Stage Security
The security game G
follows.
Definition 4.2 (Multi-Stage security). Let KE be a key exchange protocol with key distribution D and
authenticity properties AUTH, and A a PPT adversary interacting with KE via the queries deﬁned in
Section 4.4 within the following game G
Setup. The challenger generates long-term public/private-key pairs for each participant U ∈ U, chooses
Query. The adversary A receives the generated public keys and has access to the queries NewSession,
Guess. At some point, A stops and outputs a guess b.
Finalize. The challenger sets the ‘lost’ ﬂag to lost ← true if there exist two (not necessarily distinct) labels
label, label0 and some stage i ∈ {1, . . . , M} such that label.sidi = label0.sidi, label.stkey,i = revealed,
and label0.testedi = true. (Adversary has tested and revealed the key in a single session or in two
partnered sessions.)
Send, NewTempKey, Reveal, Corrupt, and Test. Note that such queries may set lost to true.
the test bit btest ←$ {0, 1} at random, and sets lost ← false.
Multi-Stage,D
KE,A
We say that A wins the game, denoted by G
= 1, if b = btest and lost = false. Note that the
winning conditions are independent of key dependency, forward secrecy, and authentication properties of
KE, as those are directly integrated in the aﬀected (Reveal and Corrupt) queries and the ﬁnalization step of
the game; for example, Corrupt is deﬁned diﬀerently for non-forward-secrecy versus stage-j forward secrecy.
We say KE is Multi-Stage-secure in a key-dependent resp. key-independent and non-forward-secret resp.
stage-j-forward-secret manner with concurrent authentication types AUTH if KE is Match-secure and for
all PPT adversaries A the following advantage function is negligible in the security parameter:
AdvMulti-Stage,D
KE,A
Multi-Stage,D
KE,A
G
:= Prh
= 1i − 1
2 .
5 Security of the draft-05 Handshake
We can now analyze the handshake as speciﬁed in TLS 1.3 draft-05 [Res15a].
First, we deﬁne the session identiﬁers for the two stages deriving the handshake traﬃc key tkhs and
the application traﬃc key tkapp to be the unencrypted messages sent and received excluding the ﬁnished
messages:
sid1 = (ClientHello, ClientKeyShare, ServerHello, ServerKeyShare)
sid2 = (ClientHello, ClientKeyShare, ServerHello, ServerKeyShare, EncryptedExtensions∗,
and
ServerCertificate∗, CertificateRequest∗, ServerCertificateVerify∗,
ClientCertificate∗, ClientCertificateVerify∗).
19
Here, starred (∗) components are not present in all authentication modes. We moreover capture the
derivation of the resumption premaster secret RMS in a further stage 3 for which we deﬁne the session
identiﬁer to be sid3 = (sid2, “RMS”).
We stress that deﬁning session identiﬁers over the unencrypted messages is necessary to obtain key-
independent Multi-Stage security. Otherwise, we would need to either resort to key dependence, or guar-
antee that an adversary is not able to re-encrypt a sent message into a diﬀerent ciphertext even if it knows
the handshake traﬃc key tkhs used (due to a Reveal query)—a property generally not to be expected from
a (potentially randomized) encryption scheme.
Concerning the contributive identiﬁers, we let the client (resp. server) on sending (resp. receiving) the
ClientHello and ClientKeyShare messages set cid1 = (CH, CKS) and subsequently, on receiving (resp.
sending) the ServerHello and ServerKeyShare messages, extend it to cid1 = (CH, CKS, SH, SKS). The
other contributive identiﬁers are set to cid2 = sid2 and cid3 = sid3 by each party on sending its respective
Finished message.
As draft-05’s handshake does not involve semi-static keys (other than the parties’ long-term keys)
shared between multiple sessions, there are no temporary keys in the notation of our model. We can hence
ignore NewTempKey queries in the following analysis.
Theorem 5.1 (Match security of draft-05). The draft-05 full handshake is Match-secure:
eﬃcient adversary A we have
for any
AdvMatch
draft-05,A ≤ n2
s · 1/q · 2−|nonce|,
where ns is the maximum number of sessions, q is the group order, and |nonce| = 256 is the bit-length of
the nonces.
Match security follows from the way the session identiﬁers are chosen (to include all unencrypted
messages), in particular guaranteeing that partnered sessions derive the same key, authenticity, and con-
tributive identiﬁers. The given security bound takes into account the probability that two honest session
choose the same nonce and group element.
Proof. We need to show the six properties of Match security.
1. Sessions with the same session identiﬁer for some stage hold the same session key.
For the ﬁrst stage this follows as the session identiﬁer contains the parties’ Diﬃe–Hellman contribu-
tions gx and gy, which uniquely identify the Diﬃe–Hellman key, as well as all data entering the key
derivation step. Hence, equal session identiﬁers imply that both parties compute the same handshake
master secret and the same session key on the ﬁrst stage. For the second and third stage note that
the identiﬁer sid2 (and hence also sid3) contains the full sid1, implying that the parties have also
computed the same handshake master secret. Since the key derivation for the stages 2 and 3 is only
based on this secret value and data from sid2, it follows that the session keys must be equal, too.
2. Sessions with the same session identiﬁer for some stage agree on the authenticity of the stage.
Observe that, for the ﬁrst stage, the only admissible authenticity by design of TLS 1.3 is auth1 =
unauth on which, hence, all sessions will agree. For the other stages, the exchanged messages (except
for the ﬁnished messages) contained in the session identiﬁer sid2 (and hence also sid3) uniquely
determines the authenticity property for these stages. More precisely, according to the proto-
col speciﬁcation, both sessions will agree on sid2 = (ClientHello, ClientKeyShare, ServerHello,
ServerKeyShare, EncryptedExtensions∗) (where EncryptedExtensions∗ is optional) if and only if
both have auth2 = unauth. If sid2 additionally contains ServerCertificate and ServerCertificateVerify,
they agree on auth2 = unilateral. If it moreover contains CertificateRequest, ClientCertificate,
and ClientCertificateVerify, the sessions agree on mutual authentication. Moreover, auth2 =
auth3 always holds hence same identiﬁers also imply agreement on authenticity.
20
3. Sessions with the same session identiﬁer for some stage share the same contributive identiﬁer.
This holds since the contributive identiﬁer value is ﬁnal once the session identiﬁer is set.
4. Sessions are partnered with the intended partner.
First of all observe that this case only applies to unilaterally or mutually authenticated stages,
hence the stages 2 and 3 only.
In TLS 1.3, the client obtains the server’s identity within the
ServerCertificate message and vice versa the server obtains the client’s identity (in case of mu-
tual authentication) within the ClientCertificate message. Moreover, honest clients and servers
will not send a certiﬁcate attesting an identity diﬀerent from their own. Hence, as both messages
are contained in the session identiﬁers of stages 2 and 3 (in the respective authentication mode),