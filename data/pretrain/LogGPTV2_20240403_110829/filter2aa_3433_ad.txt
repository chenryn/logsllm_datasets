8	
  cache	
  entries	
  for	
  the	
  frame	
  header	
– 
Uses	
  a	
  Least	
  Used	
  Replacement	
  Algorithm	
  (_Unwind_IteratePhdr_Callback())	
– 
Most	
  recently	
  used	
  is	
  the	
  head	
  of	
  the	
  list	
• 
In	
  the	
  test	
  environment,	
  the	
  frame_hdr_cache	
  was	
  at	
  0x6e0	
  bytes	
  from	
  the	
  oﬀset	
  of	
  the	
  writable	
data	
  segment	
  of	
  libgcc	
• 
This	
  is	
  the	
  aforemen'oned	
  array,	
  with	
  48	
  bytes	
  in	
  size	
• 
The	
  executable	
  itself	
  is	
  the	
  3rd	
  element	
  of	
  the	
  array	
  (the	
  ﬁrst	
  two	
  are	
  the	
  libgcc	
  and	
  libstdc++)	
• 
The	
  oﬀset	
  for	
  the	
  writable	
  data	
  segment	
  of	
  libgcc	
  can	
  be	
  found	
  in	
  this	
  way	
  (based	
  in	
  what	
  we	
know):	
– 
0x6e0+48*2=0x740	
• 
The	
  entry	
  p_eh_frame_hdr	
  that	
  we	
  want	
  to	
  overwrite	
  is	
  at	
  24	
  bytes	
  of	
  this	
  structure.	
Example	
•  Together	
  with	
  the	
  paper/presenta'on,	
  we	
release	
  a	
  demo	
  program	
  for	
  the	
  exploita'on.	
Those	
  are	
  the	
  test	
  characteris'cs	
  we	
  see:	
–  0x7ﬀﬀ760e000	
  -­‐>	
  libgcc	
  loading	
  address	
–  0x220000	
  -­‐>	
  oﬀset	
  for	
  the	
  writable	
  data	
  segment	
(star'ng	
  from	
  the	
  lib	
  base	
  address)	
–  0x6e0	
  -­‐>	
  oﬀset	
  for	
  the	
  cache	
  elements	
  (star'ng	
  from	
the	
  writable	
  data	
  segment)	
–  48	
  bytes	
  is	
  the	
  size	
  of	
  the	
  structure	
–  2	
  entries	
  before	
  ours	
  (readelf	
  –d)	
–  24	
  bytes	
  inside	
  the	
  structure	
  is	
  what	
  we	
  want	
  to	
overwrite	
Exploi'ng	
•  To	
  simplify	
  the	
  exploita'on,	
  it	
  is	
  interes'ng	
  to	
align	
  the	
  structures	
  in	
  known	
  oﬀsets/
controlled	
  oﬀsets:	
– .eh_frame	
  in	
  the	
  example	
  aligned	
  to	
  start	
  exactly	
at	
  0x50	
  bytes	
  from	
  the	
  start	
  of	
  the	
  .eh_frame_hdr	
– .gcc_except_table	
  aligned	
  to	
  start	
  exactly	
  at	
  0x200	
bytes	
  from	
  the	
  start	
  of	
  the	
  .eh_frame	
Memleak	
• 
We	
  need	
  the	
  value	
  of	
  EBP,	
  so	
  we	
  going	
  to	
  use	
  a	
  memleak.	
  It	
  can	
  be	
  achieved	
  in	
  diﬀerent	
  ways,	
depending	
  on	
  the	
  target	
  program	
  (e.g.:	
  overwri'ng	
  parameters	
  to	
  prin‡-­‐like	
  func'ons,	
  or	
  if	
  the	
vulnerability	
  is	
  a	
  format	
  string,	
  which	
  is	
  our	
  sample	
  case)	
• 
To	
  calculate	
  the	
  EBP_PREVIOUS	
  we	
  use	
  %llx	
  (format	
  string),	
  so	
  we	
  use	
  4	
  bytes	
  of	
  space	
  in	
  the	
  buﬀer	
and	
  advance	
  the	
  stack	
  pointer	
  in	
  8	
  bytes	
  (so	
  the	
  premise	
  for	
  exploi'ng	
  the	
  sample	
  program	
  is	
  to	
manage	
  to	
  leak	
  the	
  EBP):	
...	
#to	
  get	
  the	
  value	
  of	
  ebp_previous	
instr=r"%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx
%llx%llx%x%x"	
proc.sendline(instr)	
proc.expect("unknown	
  command:	
  [0-­‐9a-­‐f]*	
  ([0-­‐9a-­‐f]*).*")	
ebp_previous=int(proc.match.group(1),16)	
info("\nfound	
  ebp_previous	
  =	
  0x%x"	
  %	
  ebp_previous)	
Heuris'cs	
•  We	
  know	
  the	
  size	
  of	
  the	
  previous	
  frame	
(disassembling),	
  so	
  we	
  are	
  capable	
  of	
  calculate	
the	
  EBP	
  of	
  our	
  frame:	
– ebp=ebp_previous-­‐PREV_FRAME_SIZE	
•  With	
  our	
  frame	
  address,	
  we	
  can	
  calculate	
  the	
address	
  of	
  libgcc,	
  since	
  we	
  know	
  the	
  oﬀsets:	
– libgcc_reveal_loca'on=ebp-­‐
LIBGCC_REVEAL_EBP_OFFSET;	
More	
  Heuris'cs	
•  The	
  value	
  that	
  reveals	
  the	
  .text	
  loca'on	
  of	
  the	
  libgcc	
  is	
  at	
0xﬀﬀc798	
  (discovered	
  in	
  the	
  previous	
  slide),	
  and	
  it	
  is	
  0x679	
above	
  ESP	
  and	
  0x750	
  above	
  EBP	
•  The	
  libgcc	
  base	
  is	
  calculated	
  using	
  the	
  previously	
  revealed	
address	
  and	
  masking	
  the	
  3	
  low	
  nibbles.	
  We	
  also	
  use	
  a	
  ﬁxed	
value	
  to	
  adjust	
  the	
  result	
  (found	
  thru	
  disassembly):	
–  libgcc_base=(libgcc_revealed	
  &	
  0xFFFFF000)	
  -­‐	
LIBGCC_REVEAL_ADJUST	
•  The	
  separa'on	
  between	
  .text	
  and	
  .data	
  segments	
  in	
  libgcc	
is	
  0x19000	
  (x86):	
–  libgcc_data_base=libgcc_base+LIBGCC_DATA_OFFSET	
Finalizing	
•  Finally,	
  we	
  ﬁnd	
  the	
  frame_hdr_cache	
  and	
  the	
respec've	
  p_eh_frame_hdr	
  from	
  the	
libgcc_data_base,	
  as	
  previously	
  described:	
– frame_hdr_cache=libgcc_data_base
+CACHE_LIBGCC_OFFSET	
– p_eh_frame_hdr=frame_hdr_cache
+CACHE_ENTRY_SIZE*PREVIOUS_CACHE_ENTRIES
+OFFSET_IN_CACHE_ENTRY	
In	
  the	
  demo	
  case	
•  With	
  all	
  the	
  values,	
  we	
  redirect	
  the	
  execu'on:	
–  Func'on	
  doWork	
  starts	
  at	
  0x0804936a	
–  Throw	
  is	
  at	
  0x08049634	
–  Distance:	
  0x2ca	
  (call	
  site	
  14	
  in	
  the	
  dict_mod.dws	
  for	
  the	
  demo)	
–  We	
  force	
  the	
  execu'on	
  of	
  the	
  I_am_never_called	
  that	
  is	
  at	
0x08049842	
  (oﬀset	
  of	
  0x4d8	
  from	
  doWork)	
•  The	
  Dwarf	
  payload	
  is	
  injected	
  in	
  the	
  dic'onary	
  been	
  readed	
  by	
  the	
target	
  program	
  (instead	
  of	
  using	
  a	
  shellcode).	
  We	
  ﬁnd	
  the	
  pointers,	
overwrite	
  the	
  caching	
  target	
  address	
  and	
  the	
  desired	
  catch	
  block	
  is	
executed.	
Other	
  possibili'es	
•  If	
  you	
  have	
  a	
  Write	
  N	
  you	
  can	
  overwrite	
the	
  .eh_frame	
  en'rely	
  (if	
  it	
  is	
  +W,	
  what	
  is	
  not	
normal	
  in	
  new	
  systems)	
•  You	
  can	
  overwrite	
  the	
  .eh_frame	
  using	
  a	
shellcode	
•  You	
  can	
  use	
  a	
  stagered	
  ret-­‐into-­‐lib	
  to	
  remap	
the	
  .eh_frame	
  as	
  +W	
  and	
  then	
  overwrite	
  it	
THE	
  END!	
  Really	
  is	
  !?	
James	
  Oakley	
  (Electron)	
Electron100	
  *noSPAM*	
  gmail.com	
Rodrigo	
  Rubira	
  Branco	
  (@BSDaemon)	
rodrigo	
  *noSPAM*	
  kernelhacking.com	
Sergey	
  Bratus	
  (Sbratus)	
Sergey	
  *noSPAM*	
  cs.dartmouth.edu