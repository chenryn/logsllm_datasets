测试应用 | wget  
---|---  
版本号 | 1.19.1  
fuzz工具 | afl  
调试工具 | gdb  
交互功能实现 | preeny  
#### wget编译安装
首先wget下载源码,并使用afl-clang-fast进行安装
    wget https://ftp.gnu.org/gnu/wget/wget-1.19.1.tar.gz
    tar zxvf wget-1.19.1.tar.gz
    cd wget-1.19.1
    CXX=afl-clang-fast++ CC=afl-clang-fast ./configure --prefix=/home/mortywget
    AFL_USE_ASAN=1 make
    make install
验证
    root@c7c87f16a29d:/home/mortywget/bin# ./wget --version
    GNU Wget 1.19.1 built on linux-gnu.
### preeny
Preeny项目重写了一些交互的函数,我们可以通过`LD_PRELOAD`预加载机制,对程序中的交互进行修改,例如将socket相关函数改写为从用户输入输出(stdin,stdout)进行交互,从而方便我们使用afl进行fuzz
项目下载地址
    https://github.com/zardus/preeny
此处省略安装过程…
#### 验证preeny是否安装成功
预加载`desock.so`文件,并启动一个socket交互程序wget,若输入的字符串成功当作wget请求的返回值 ,则表明preeny安装配置成功
    root@c7c87f16a29d:~# LD_PRELOAD="/root/preeny/x86_64-linux-gnu/desock.so" wget localhost:6666 -q -O result , maxtime=, wait_for=) at connect.c:714
    #2  0x00000000004c34b2 in sock_poll (fd=0x4, timeout=, wait_for=0x1) at connect.c:801
    #3  poll_internal (fd=, info=0x0, wf=0x1, timeout=) at connect.c:914
    #4  fd_read (fd=0x4, buf=0x7fffffffcd00 "gfedcbazzzzffffgggghhhhiiiiddddeeeeffffccccccccbbbbbbb", 'a' , "bbb", 'a' , 'A' ..., 
        bufsize=0xff, timeout=) at connect.c:933
    #5  0x000000000052723c in skip_short_body (fd=, contlen=, chunked=) at http.c:989
    #6  0x0000000000519a95 in gethttp (u=, original_url=, hs=, dt=, proxy=, iri=, 
        count=) at http.c:3524
    #7  0x0000000000512aa7 in http_loop (u=, original_url=, newloc=0x7fffffffe310, local_file=, referer=, dt=, 
        proxy=, iri=) at http.c:4193
    #8  0x00000000005556aa in retrieve_url (orig_parsed=, origurl=0x60300000e080 "http://localhost:6666", file=, newloc=, refurl=, 
        dt=, recursive=, iri=, register_status=) at retr.c:817
    #9  0x000000000053c77b in main (argc=, argv=0x7fffffffe3f0, argv@entry=0x7fffffffe738) at main.c:2081
    #10 0x00007ffff64f5830 in __libc_start_main (main=0x538f70 , argc=0x2, argv=0x7fffffffe738, init=, fini=, rtld_fini=, 
        stack_end=0x7fffffffe728) at ../csu/libc-start.c:291
    #11 0x00000000004bf659 in _start ()
在确定卡住位置之后,修改其源码,使其强制断开连接,退出程序
在`http.c`的如下位置中分别添加`exit(0)`:
    tms = datetime_str (time (NULL));
          /* Get the new location (with or without the redirection).  */
          if (hstat.newloc)
            *newloc = xstrdup (hstat.newloc);
          switch (err)
            {
            case HERR: case HEOF: case CONSOCKERR:
            case CONERROR: case READERR: case WRITEFAILED:
            case RANGEERR: case FOPEN_EXCL_ERR: case GATEWAYTIMEOUT:
              /* Non-fatal errors continue executing the loop, which will
                 bring them to "while" statement at the end, to judge
                 whether the number of tries was exceeded.  */
              exit(0); //手动添加
              printwhat (count, opt.ntry);
              continue;
            case FWRITEERR: case FOPENERR:
              /* Another fatal error.  */
              logputs (LOG_VERBOSE, "\n");
              logprintf (LOG_NOTQUIET, _("Cannot write to %s (%s).\n"),
                         quote (hstat.local_file), strerror (errno));
            case HOSTERR: case CONIMPOSSIBLE: case PROXERR: case SSLINITFAILED:
            case CONTNOTSUPPORTED: case VERIFCERTERR: case FILEBADFILE:
            case UNKNOWNATTR:
    if (statcode == HTTP_STATUS_UNAUTHORIZED)
        {
          /* Authorization is required.  */
          uerr_t auth_err = RETROK;
          bool retry;
          /* Normally we are not interested in the response body.
             But if we are writing a WARC file we are: we like to keep everyting.  */
          if (warc_enabled)
            {
              int _err;
              type = resp_header_strdup (resp, "Content-Type");
              _err = read_response_body (hs, sock, NULL, contlen, 0,
                                        chunked_transfer_encoding,
                                        u->url, warc_timestamp_str,
                                        warc_request_uuid, warc_ip, type,
                                        statcode, head);
              xfree (type);
              if (_err != RETRFINISHED || hs->res  0 || chunked)
        {
          int ret;
          if (chunked)
            {
              if (remaining_chunk_size == 0)
                {
                  char *line = fd_read_line (fd);
                  char *endl;