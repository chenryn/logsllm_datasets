      kNumberOrOddball,    // Inputs were Number or Oddball, output was Number.
    };
当且仅当操作数类型为 `NumberOperationHint::kSignedSmall` 或
`NumberOperationHint::kSigned32`时，当前减法才会被视为是 Safe 的，因此创建
SpeculativeSafeIntegerSubtract 结点；否则创建保守的 SpeculativeNumberSubtract 结点。
  * 最后附带说明一下 **部分数字类型的范围** ：  
> 参照源码 src/compiler/types.h
    * 一些基础类型 
      * OtherNumber（ON）：$(-\infin, -2^{31}) \cup [2^{32}, \infin)$
      * OtherSigned32（OS32） ：$[-2^{31}, -2^{30})$
      * Negative31（N31）：$[-2^{30}, 0)$
      * Unsigned30（U30）: $[0, 2^{30})$
      * OtherUnsigned31（OU31）: $[2^{30}, 2^{31})$
      * OtherUnsigned32（OU32）: $[2^{31}, 2^{32})$
                  ON    OS32     N31     U30     OU31    OU32     ON
        ______[_______[_______[_______[_______[_______[_______
            -2^31   -2^30     0      2^30    2^31    2^32
  * Integral32：$[-2^{31}, 2^{32})$
  * PlainNumber：任何浮点数，不包括 $-0$
  * Number：任何浮点数，包括 $-0$、$NaN$
  * Numeric：任何浮点数，包括 $-0$、$NaN$ 以及 $BigInt$
## 四、漏洞利用
> 尽管理论上可以通过该漏洞构造 **越界读取原语** ，但实际利用起来仍然存在一个无法解决的问题。
>
> 即便如此，我们仍然可以在尝试构造漏洞利用中加深对 turboFan 的理解。
初始 Poc 如下
    function foo(trigger) {
        var idx = Object.is((trigger ? -0 : 0) - 0, -0);
        return idx;
    }
    console.log(foo(false));
    %OptimizeFunctionOnNextCall(foo);
    console.log(foo(true)); // expected: true, got: false
从 turbolizer 中可以看到，不管传入函数的参数是什么，最后都将会把 SameValue 结点 **直接优化** 为
HeapConstant\，同时 **运行时 idx 值也是 false** ，两个结果相同，因此无法利用漏洞。
为什么运行时 idx 值也是 false 呢？因为当生成了 HeapConstant\之后，turboFan 就会直接优化变量 idx
的计算过程，直接取结果值 false：
我们 **希望** ，传入 -0 时（即传入参数 true），编译时 **SameValue 结点类型为 false，但运行时的结果为 true**
，这样就会有一个范围差，我们便可以利用它来计算出错误的范围。换句话说，我们需要让 turboFan 认为 **编译时** 的 SameValue 结点值为
0，但 **运行时** 的值是 1，这样我们才可以利用这个差值搭配乘法进行数组越界。
> **编译时** 的值：turboFan 执行 type 时所确认的值/范围，即静态分析时确定的数值。
>
> **运行时** 的值，终端调用 v8 执行 JS 程序时最终计算出的值。
因此，我们就必须 **禁止 turboFan 为 SameValue 结点生成 HeapConstant\
结点**，也就是说我们就必须在执行 simplified lowering 前的所有 ConstantFoldingReducer 时，
**不精确计算出** SameValue 的类型，即推迟该节点被 type 为 HeapConstant 的时机至 **执行完所有
ConstantFoldingReducer 之后** 。否则一旦出现 HeapConstant，则 **运行时** 的 idx 变量值就固定为该
HeapConstant，不会再重新计算。
那么，我们该让 SameValue 在什么时候被精确 type 呢？我们先看一下整个 pipeline 中运行 typer 的地方有哪些：
  * TyperPhase 阶段
  * LoadEliminationPhase 阶段中的 TypeNarrowingReducer 函数
  * SimplifiedLoweringPhase 阶段中的 UpdateFeedbackType 函数
> 后两种是通过以下宏定义来调用 typer（咋一看还没认出来）：
>  
>  
>     switch (node->opcode()) {
>     #define DECLARE_CASE(Name)                               \
>       case IrOpcode::k##Name: {                              \
>         new_type = op_typer_.Name(input0_type, input1_type); \
>         break;                                               \
>       }
>           SIMPLIFIED_NUMBER_BINOP_LIST(DECLARE_CASE)
>     #undef DECLARE_CASE
>       // ...
>     }
>  
而 ConstantFoldingReducer 出现在 `TypedLoweringPhase` 和
`LoadEliminationPhase`。因此我们只能让 SameValue 在 **SimplifiedLoweringPhase** 阶段被精确
type。
但需要注意的是，TypedOptimization in TypedLoweringPhase 将会对 SameValue 进行一次 reduce
操作。我们必须阻止它将 SameValue 结点优化成 ObjectIsMinusZero 结点，因为该结点将不会在
simplifedLoweringPhase 中进行 type（只会进行节点替换，替换成 Int32Constant）。
综合上面的要求，我们不能让 turboFan 在 EscapeAnalysisPhase 之前的 Phase 中，确认出 SameValue 的第二个
操作数类型为 MinusZero。因此，就需要引入一点点 EscapeAnalysis 的内容 （完整内容请查阅 [Escape-Analysis-in-V8](https://www.jfokus.se/jfokus18/preso/Escape-Analysis-in-V8.pdf)）：
简单来说，EscapeAnalysis 可以但不限于 **将一个 LoadField 操作转换成一个栈变量读取操作** 。这样，在
EscapeAnalysisPhase 之前的 Phase，由于 LoadField 结点的存在，自然就无法获取到对应值的类型。因此笔者一开始将 Poc
修改为如下：
    function foo(trigger) {
        let obj = { a: -0 }; // Escape Analysis 特供1
        let wrongNum = (trigger ? -0 : 0) - 0;
        let idx = Object.is(wrongNum, obj.a);
        return idx + 1;
    }
    // Escape Analysis 特供2
    for(let a = 0; a  需要注意的是，Escape Analysis 对函数的 type feedback有一定的要求。如果目标函数只运行了 **一次** ，那么 escape
> analysis 分析效果非常的差，基本上无法分析出任何有用的东西，包括刚刚说的 LoadField
> 替换也无法完成。因此必须在优化前多执行几次目标函数。
>
> 同时，Escape Analysis 的目标对象，必须有个修饰符 let / var，否则无法替换 LoadField
> 结点，这其中主要是因为作用域的关系。
但实际调试发现， LoadField 结点的替换将会被 LoadElimination（ 位于 LoadEliminationPhase）
截胡。也就是说，在 LoadEliminationPhase 时，obj.a 就会被替换成 -0。相关代码如下：
    Reduction LoadElimination::ReduceLoadField(Node* node) {
      FieldAccess const& access = FieldAccessOf(node->op());
      Node* object = NodeProperties::GetValueInput(node, 0);
      Node* effect = NodeProperties::GetEffectInput(node);
      Node* control = NodeProperties::GetControlInput(node);
      AbstractState const* state = node_states_.Get(effect);
      if (state == nullptr) return NoChange();
      if (access.offset == HeapObject::kMapOffset &&
          access.base_is_tagged == kTaggedBase) {
        // ...
      } else {
        int field_index = FieldIndexOf(access);
        if (field_index >= 0) {
          if (Node* replacement = state->LookupField(object, field_index)) {
            // Make sure we don't resurrect dead {replacement} nodes.
            if (!replacement->IsDead()) {
              // Introduce a TypeGuard if the type of the {replacement} node is not
              // a subtype of the original {node}'s type.
              if (!NodeProperties::GetType(replacement)
                       .Is(NodeProperties::GetType(node))) {
                Type replacement_type = Type::Intersect(
                    NodeProperties::GetType(node),
                    NodeProperties::GetType(replacement), graph()->zone());
                // 建立新结点
                replacement = effect =
                    graph()->NewNode(common()->TypeGuard(replacement_type),
                                     replacement, effect, control);
                // type 设置
                NodeProperties::SetType(replacement, replacement_type);
              }
              // 结点替换
              ReplaceWithValue(node, replacement, effect);
              return Replace(replacement);
            }
          }
          state = state->AddField(object, field_index, node, access.name, zone());
        }
      }
      // ...
      return UpdateState(node, state);
    }
但 LoadEliminationPhase 中存在 ConstantFoldingReducer，因此最终 SameValue 结点还是会被替换成
HeapConstant。所以我们还是必须想办法绕过 LoadElimination 的优化，进入 EscapeAnalysis 中的优化。
折腾了相当长的时间，终于找到了绕过的方法，以下是修改后的 PoC，与之前相比，加了一行略微奇怪的 console.log 函数调用：
> 这个绕过方法是蒙出来的，把代码改复杂一点有时可以非常玄学的绕过某些优化。
    function foo(trigger) {
        let obj = { a: -0 }; // Escape Analysis 特供1
        let wrongNum = (trigger ? -0 : 0) - 0;
        console.log(obj.a = -0 );     // 绕过 LoadElimination 特供
        let idx = Object.is(wrongNum, obj.a);
        return idx + 1;
    }
    // Escape Analysis 特供2
    for(let a = 0; a  Builtin_SameValue 的函数调用规范：%rdx 和 %rax 分别为左右两个操作数。
看上去应该可以成功越界读取，但实际执行时发现读取出的仍然是索引值为0的数组元素（心态崩了TAT）。
笔者动态调试了一下编译后 JS 函数的汇编代码，发现变量 wrongNum **被截断成整型** ，之后与 0x1 进行比较：
> 使用 `--trace-turbo` 参数 结合 turbolizer ，即时查看编译后函数的内存地址；同时搭配内置函数
> `%SystemDebug()`，便于调试。
而这实际上是 ChangeInt31ToTaggedSigned 结点的锅：
由于这个 ChangeInt31ToTaggedSigned 结点在 Simplified Lowering 阶段中生成，不可优化，因此 exp
编写就没办法继续下去，只能就此终止。
## 五、后记
  * 该漏洞补丁的详细信息请查阅[此处](https://chromium.googlesource.com/v8/v8.git/+/e3c923962677908c183121644c945777cdb31570)
        Type OperationTyper::SpeculativeSafeIntegerSubtract(Type lhs, Type rhs) {
      Type result = SpeculativeNumberSubtract(lhs, rhs);
      // If we have a Smi or Int32 feedback, the representation selection will
      // either truncate or it will check the inputs (i.e., deopt if not int32).
      // In either case the result will be in the safe integer range, so we
      // can bake in the type here. This needs to be in sync with
      // SimplifiedLowering::VisitSpeculativeAdditiveOp.
    -  return result = Type::Intersect(result, cache_.kSafeInteger, zone());
    +  return Type::Intersect(result, cache_.kSafeIntegerOrMinusZero, zone());
    }
        void VisitSpeculativeIntegerAdditiveOp(Node* node, Truncation truncation,
                                             SimplifiedLowering* lowering) {
       // ...
       Type left_feedback_type = TypeOf(node->InputAt(0));
         Type right_feedback_type = TypeOf(node->InputAt(1));
         // Handle the case when no int32 checks on inputs are necessary (but
         // an overflow check is needed on the output). Note that we do not
    -    // have to do any check if at most one side can be minus zero.
    -    if (left_upper.Is(Type::Signed32OrMinusZero()) &&
    +    // have to do any check if at most one side can be minus zero. For
    +    // subtraction we need to handle the case of -0 - 0 properly, since
    +    // that can produce -0.
    +    Type left_constraint_type =
    +        node->opcode() == IrOpcode::kSpeculativeSafeIntegerAdd
    +            ? Type::Signed32OrMinusZero()
    +            : Type::Signed32();
    +    if (left_upper.Is(left_constraint_type) &&
             right_upper.Is(Type::Signed32OrMinusZero()) &&
             (left_upper.Is(Type::Signed32()) || right_upper.Is(Type::Signed32()))) {
           VisitBinop(node, UseInfo::TruncatingWord32(),
                     MachineRepresentation::kWord32, Type::Signed32());
         } else {
         // ...
         }
         // ...
    }
  * 漏洞修复后，原先 Poc 执行的 turbolizer 视图如下：
可以看到，SpeculativeSafeIntegerSubtra 的 Type 包含了 MinusZero 这种类型，因此下面的 SameValue
的类型也不再固定为 false， 而是 **不确定** 的 Boolean。
## 六、参考
  * [Issue 913296: Security: V8: Incorrect type information on SpeculativeSafeIntegerSubtract](https://bugs.chromium.org/p/chromium/issues/detail?id=913296)
  * [Exploiting the Math.expm1 typing bug in V8 – 0x41414141 in ??()](https://abiondo.me/2019/01/02/exploiting-math-expm1-v8/)
  * [Escape-Analysis-in-V8](https://www.jfokus.se/jfokus18/preso/Escape-Analysis-in-V8.pdf)
  * [v8-math-expm1-类型错误导致的漏洞](https://cy2cs.top/2020/05/07/v8-math-expm1-%e7%b1%bb%e5%9e%8b%e9%94%99%e8%af%af%e5%af%bc%e8%87%b4%e7%9a%84%e6%bc%8f%e6%b4%9e/)