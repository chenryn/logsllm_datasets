attack utilizes an Intent scheme with Twitter’s package name.
Twitter’s WebView activity does not contain any title bar and
other UI widget, and therefore can be easily converted into a fake lo-
gin page. This activity is placed at the top of Twitter’s task stack, so
once the app is launched again, the login page will first be displayed.
To hide this state change, as soon as the attack content is loaded
into the Twitter WebView, the script running there immediately
sends out a navigation request through the scheme googlechrome://
(reserved by Chrome) to Chrome, bringing its WebView to the fore-
ground. A problem here is that a WebView in Twitter will be auto-
matically closed after it issues a scheme. Therefore, the attack web
page in the WebView needs to invoke another Twitter WebView in-
stance with the attack link, together with the navigation request for
Chrome, before it is terminated. In our attack, actually, the infected
WebView opens Twitter’s scheme multiple times before triggering
Chrome’s scheme. In this way, several Phishing pages will be put
on Twitter’s task stack before the foreground is handed over to
Chrome. Once the user later launches the Twitter, not only will she
see the Phishing page, but she will continue to be presented the
same one if she touches the back button.
The RDP happens when the Twitter is in the login state. As a
result, after the user enters her user ID and password to the fake
login page, the remote adversary immediately instructs the infected
WebView to switch to Twitter’s main activity. The whole process,
therefore, becomes indistinguishable from a real login. All the view
switching in the attack happens almost instantly and is hard to
notice by humans, as demonstrated in our online video [1]. We
summarize the whole attack in Figure 3.
Faking my UI. Unlike Twitter, Facebook has a URL bar on its ac-
tivity, which discloses the source of the web content in its WebView
and therefore cannot be used to serve a Phishing page. The remote
adversary, therefore, needs to find an accomplice app that can work
with the infected Facebook to fake its login page. Obviously, the
Twitter app can serve this purpose. In our research, we built an
RDP in which Chrome infects the Facebook app, and whenever
Facebook is launched, it further triggers Twitter to cover its inter-
face. Through this coordinated attack, the remote adversary again
can show to the user a realistically-looking attack page.
Specifically, a Facebook WebView can be invoked by the URL
with the scheme fb://. For example, the link fb://webview/?url=http:
//www.attack.com in Chrome, once clicked by the user, brings Face-
book to www.attack.com. Once infected, Facebook sends a URL
scheme googlechrome:// to switch back to Chrome’s WebView,
without being noticed by the user. What we want to do here is
that whenever Facebook is launched again, it instantly infects and
invokes a Twitter WebView to display a fake Facebook login UI. To
this end, the script dispatched to the Facebook WebView runs a loop,
making continuous effort to trigger the infected Twitter activity.
Actually, a Facebook WebView is suspended in the background and
therefore the Intent scheme it tries to deliver to Twitter is blocked.
However, immediately after it gets to the foreground (after the user
invokes the app from the launcher or “recent apps”), the scheme is
delivered, causing the Twitter Phishing page to show up. Further,
if the user clicks on Android’s back button, the system rolls back
to the infected Facebook WebView, which again fires Twitter to
impersonate its official login view. Also similar to the Twitter attack,
after the user enters her password, the infected Twitter WebView
Session D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA834Figure 3: The Phishing attack on Twitter. Note that there are multiple instances of Twitter’s WebView during Phishing, so once
the back button is clicked, another instance of Twitter’s WebView with a Phishing page is displayed.
launches Facebook’s main activity, which presents the user’s ac-
count information when the attack takes place in the logged-in
state. This attack is found to work smoothly, as summarized in
Figure 4 and shown in our demo [1].
Inviting for hijacking. Actually, on the target device if there are
apps with activities running in the standard mode, UI impersonation
could become easier. Specifically, for the Facebook app, another
popular app that can become its accomplice is PicsArt, whose activ-
ity operates in the standard mode. Such an activity, once launched
by Facebook, will be automatically added to its task stack. So later
on, when Facebook is opened, PicsArt’s activity always shows on
the top.
an alarm whenever a new activity is not initiated by the foreground
app, and notifies the user whether the order of activities in the
background has been rearranged after a new activity is launched.
In our RDP attacks, however, all the new activities are launched
by a foreground app and the order of the background activities
will not change. Fundamentally, our new attacks are caused by the
collusion between the app being impersonated and the perpetrator,
since they are all infected by the attack web content and turned
into the same remote master’s zombies. This makes our attack
completely different from what has been seen today, rendering
WindowGuard ineffective.
3.3 Remote Privilege Escalation
In addition to remote deep Phishing, powerful XAWI attacks can
be built to escalate the adversary’s privilege on a device. Here,
we elaborate two prominent examples in which the remote ad-
versary acquires the capabilities to silently install apps and send
out messages without the user’s consent. An additional example
is presented in Appendix A, in which the remote adversary can
stealthily gather device information (e.g., app installed), monitor
how the phone is used and change the device state (such as adding
calendars) and even automatically install apps.
Unauthorized app install. We found that the Amazon Appstore
app can be exploited by the remote adversary to silently install any
third-party app on a mobile device without its owner’s consent.
The attack leverages the Appstore’s powerful WebView, whose JS
interface provides the object IntentBridge for app installation.
However, the WebView is closely guarded and does not expose
any UI for the user to navigate to non-Amazon domains. Also,
through analyzing its code, we found that the app forcefully affixes
the domain https://mas-ssr.amazon.com to any URL its WebView is
asked to visit, thereby confining the app just to the Amazon domain.
Another challenge is that the activity hosting the WebView has
not registered any Intent filter and thus cannot be triggered by an
Intent scheme.
In our research, we come up with a coordinated attack that starts
from a Chrome browser running attack web content. The browser
propagates the infection to the Amazon Shopping app through nav-
igating its WebView to the attack domain, and further acquires the
control of Amazon Appstore’s WebView through the Shopping app
(see our demo [1]). Here, Amazon Shopping serves as a stepping
stone since the attack content hosted by Chrome can only issue
an implicit or Intent scheme, not the deep link capable of invoking
Amazon Appstore’s unregistered activity. The Shopping app, how-
ever, allows its WebView to issue a deep link, that is, converting the
In our research, again, we run Chrome to infect Facebook’s
WebView, which then sends a scheme picsart:// to PicsArt, invok-
ing its WebView and most importantly adding the related activ-
ity WebViewActivity to the Facebook’s task stack. Then PicsArt
can invoke Chrome to hide itself. After that, PicsArt hijacks Face-
book’s task and always shows on top of its UI. Further, the in-
fected PicsArt can also gain control on Android’s back button.
Specifically, the app overrides the onBackPressed method and
launches the most recent page once the button is clicked. This
feature is then leveraged in our attack, which loads the attack page
http://attacker.com/phishing.html that redirects the WebView to
http://attacker.com/phishing.html#123. Once the button is pushed,
PicsArt moves the WebView to phishing.html, which automatically
goes back to phishing.html#123. In the meantime, after the user in-
puts her Facebook login credentials, the Phishing page will launch
Facebook’s main activity. The attack is summarized in Figure 5.
Against known defense. Compared with today’s mobile Phishing
attacks, RDP is unique in its complete reliance on the web content to
control local apps and the cross-app coordination it can orchestrate.
These features make existing defense less effective. Specifically, a
prominent solution proposed in the prior research [4] utilizes a
indicator in the system navigation bar to inform users which app
they are interacting with. This protection is meant to defeat the UI
overlay attack [19, 26, 29, 36] (the legitimate app’s UI covered by
an attack activity). However, it does not work on the RDP in which
the infected WebView impersonates the UI in the same app. In our
Twitter attack, all the user can see from the indicator is that the
Twitter app is running on the top, which actually convinces her of
the authenticity of the UI she provides login credentials.
Most recently, a technique called WindowGuard [30] has been
proposed to enforce an Android Window Integrity (AWI) model,
which defines the legitimacy of GUI system states in the user’s
interactions with apps. Particularly, it prompts a dialog and raises
State ChangeUser clicks a link in Chromeinvokeunnoticeable ChromeChrome loads a new pageinvokePhishingUser opens TwitterThe Phishing page is displayed by TwitterTwitter’s main activity is displayedUser logininvokeForegroundBackgroundTwitter’s infected WebViewTwitter’s WebView with a Phishing pageChromeChromeTwitter’s WebView with a Phishing pageTwitter’s main activityTwitter’s WebView with a Phishing pageTwitter’s WebView with a Phishing pageSession D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA835Figure 4: The Phishing attack on Facebook. Note that once the back button is clicked when a Phishing page is displayed, Face-
book’s WebView is resumed and will immediately invoke Twitter’s WebView to display a Phishing page again.
Figure 5: Hijack Facebook’s Task. Note that the Phishing page can leverage the capability of Picsart’s WebView to hijack the back
button.
URI like intent:.attacker.com#Intent;package=com.amazon.venezia;
component=com.amazon.venezia/com.amazon.venezia.Venezia;end;
into an explicit Intent for the package com.amazon.venezia and
the activity com.amazon.venezia.Venezia. Also Amazon Shop-
ping registers the scheme URI com.amazon.mobile.shopping.web:
//domain/path, which Chrome can use to navigate the app’s Web-
View to the adversary’s domain attack.com. During each attack step,
a newly infected WebView is always switched to the background,
as mentioned earlier (Section 3.1)
A complexity, however, comes from Amazon Shopping’s domain
control: the app verifies every URL to be loaded into its WebView
and only proceeds with those from “amazon.com”. In our research,
we carefully studied this protection and found that the app uses
Android API Uri.getHost to get the domain name of a URL. How-
ever, this API does not handle complicated URLs well1: for example,
the domain of the URL https://a:PI:EMAIL:PI:EMAIL
is reported as test.amazon.com by the API, while when it is parsed
in WebView, its domain is considered to be attack.com. Exploiting
this discrepancy, our infected Chrome was able to load attack.com
into Amazon Shopping, making it an accomplice of the attack. This
newly discovered vulnerability was reported to Amazon.
Once the Shopping app is infected, its WebView can trigger
the deep link to navigate Amazon Appstore’s WebView. To move
Figure 6: Unauthorized app install
the WebView to attack.com, we found that the adversary can sim-
ply create a sub-domain mas-ssr.amazon.com.attack.com. The pro-
tection on the Appstore side fails to append the URL affix https:
//mas-ssr.amazon.com with ‘/’ and therefore can be circumvented
by a carefully crafted navigation request: here, the request is to
navigate to .attack.com, which is issued by the infected WebView
in Amazon Shopping. As a result, attack.com gains control of all
three apps and the privilege of silent app install. The process is
summarized in Figure 6.
Stealthy messaging. In addition to directly escalating the privilege
of a malicious website, XAWI can also help the remote adversary to
exploit a vulnerability that originally can only be attacked locally,
in the presence of a malicious app installed on the target device. A
1Another researcher reported this vulnerability in Uri.getHost to Google earlier than
us. We independently discovered it and reported it to Google when the vulnerability
was not fixed.
State ChangeUser clicks a link in ChromeinvokeFacebook’s WebView is displayed with blank content for a very short timeChrome loads a new pageinvokePhishingUser opens FacebookFacebook is not displayed and invokes Twitter immediately. ForegroundBackgroundThe Phishing page is displayed by TwitterUser logininvokeFacebook’s main activity is displayedinvokeChromeFacebook’s infected WebViewChromeChromeFacebook’s infected WebViewFacebook’s infected WebViewFacebook’s infected WebViewFacebook’s main activityTwitter’s WebView with a Phishing pageState ChangeUser clicks a link in ChromeinvokeFacebook’s WebView is displayed with blank content for a very short timeChrome loads a new pagePicsArt’s WebView is displayed with blank content for a very short timeinvokePhishingUser opens FacebookA Phishing page is displayed by PicsArt in the Facebook’s task with back button hijackedFacebook’s main Activity is displayedUser logininvokeinvokeForegroundBackgroundChromeChromeFacebook’s TaskFacebook’s infected WebViewPicsArt’s infected WebViewFacebook’s TaskFacebook’s infected WebViewChromeFacebook’s TaskFacebook’s infected WebViewPicsArt’s WebView with a Phishing pageChromeFacebook’s TaskFacebook’s infected WebViewPicsArt’s WebView with a Phishing pageFacebook’s TaskFacebook’s main activity1. The user visits the malicious website in the Chrome12. The content in Chrome issues a scheme to infect the Amazon Shopping’s WebView233. The content in Amazon Shopping issues a deep link to infect the Amazon Appstore’s WebView44. The content in Amazon Appstore opens another app (chrome) to hide the Amazon apps5The malicious content in Amazon Appstore silently installs a malware in the backgroundSession D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA836simple example is the Intent Spoofing attack [9], which requires
that on-device malware sends a crafted Intent to unprotected com-
ponents (e.g, broadcast receivers, activities and services). Using
XAWI, the adversary can now utilize a malicious website to infect
the WebView of a different app on the same target device and then
command it to send that Intent to the vulnerable app. Specifically,
in our research, we found that Facebook is one such app, which
exposes an interface that can be attacked by a local adversary to
cause it to send unauthorized messages through Facebook Messen-
ger. The challenge here, however, is to execute this attack remotely,
without running any malicious code on the target. Here we explain
how this is done. Our attack has been acknowledged by Facebook,
which awarded us $7500 for our findings.
Specifically, Facebook Messenger has an activity SecureIntent
HandlerActivity (see Figure 9 in Appendix), which upon receiv-
ing an Intent with the scheme fb-messenger-secure:// will send
out a message. However, this activity is protected by a permis-
sion FB_APP_COMMUNICATION, a signature one only given to Face-
book’s products. We found that the authorized Facebook app can
serve as a stepping stone to deliver the message-sending Intent
to Facebook Messenger. Facebook has a unique interface (activity
IntentUriHandler) to interpret a Facebook deep link (called ap-
plink [16]) and generate an Intent to trigger the Messenger app’s
protected activity. This interface can be easily exploited by a local
adversary, which can send an Intent to activate IntentUriHandler.
The content of the Intent will then be used by Facebook to generate
the scheme fb-messenger-secure:// to the Messenger. As a result, a
message will be issued upon the local adversary’s request.
However, exploiting this vulnerability remotely is much more
difficult. A trouble here is that IntentUriHandler does not register
any Intent filter for the applink scheme fbrpc://. As a result, it cannot
be accessed by both implicit and explicit (Intent) schemes supported
by Chrome. Further, after the vulnerability is exploited, the chatting
UI of Facebook Messenger will show up in the foreground, exposing
the attack to the user. Therefore to make the attack stealthy, the
chatting UI should be switched to background after an unauthorized
message is sent out.
Our technique, again, is to find a stepping-stone app with the ca-
pability to issue a deep link and run in the background. An example
for such an app is Amazon Shopping. In our research, we utilized
a Chrome WebView running attack scripts to spread the infection
to a WebView instance in Amazon Shopping, which then issues a
deep link directly to IntentUriHandler, like what happens in the
app install attack, with an applink fbrpc:// in its data field. This
applink causes the Facebook app to send an Intent to protected
Facebook Messenger, leading to unauthorized messaging. During
the attack, Amazon Appstore acts as the commander, automati-
cally switching Chrome to the foreground as soon as it triggers
IntentUriHandler.
Alternatively, we exploited a selector Intent weakness in IntentU
riHandler to let Chrome directly talk to IntentUriHandler. Specif-
ically, we found that IntentUriHandler registers an Intent filter
for the scheme fb://. This allows us to construct a selector In-
tent scheme, which is a combination of two schemes, with fb://
in the selector field for determining the recipient activity and
fbrpc://[payload] in the data field (Figure 7). This scheme, once
triggered, causes Chrome to fire an Intent to IntentUriHandler
intent ://[ payload ]# Intent ;scheme=fbrpc; action = android .
intent . action . VIEW ;SEL;scheme=fb; action = android . intent
. action . VIEW ; end ;
Figure 7: Selector Intent scheme
Figure 8: Attack Facebook Messenger
based upon fb://. When interpreting the Intent, however, the activity
will receive a fbrpc:// URL, in the format of an applink, from the OS.
This triggers the operations within IntentUriHandler to convert
the URL into the Intent for Facebook Messenger, causing an unau-
thorized message to be sent out. A trouble here, however, is that
Chrome’s WebView cannot operate in the background and we need
a commander to control app switching in the background, so as to
hide the execution of Facebook Messenger. To this end, we utilized
Twitter’s WebView to coordinate the whole attack. Specifically, the
malicious web content in Chrome’s WebView first infects Twitter’s
WebView, which then brings Chrome to the foreground to trig-
ger the Facebook’s vulnerability. After the unauthorized message
is sent out, Twitter’s WebView in the background again invokes
Chrome (waiting for 2 seconds after it is navigated to the attack site)
to cover the Messenger app. The attack is summarized in Figure 8.
4 TARGET FINDING AND PROTECTION
In this section, we present ViewFinder, a technique for automatic
discovering vulnerable apps. Also, we present an OS-level solu-
tion to mitigate the threat, through controlling navigation requests
across apps.
4.1 Automatic XAWI Analysis
Key to the identification of a XAWI-susceptible app is to determine
whether any of its WebView instances is exposed to the public and
can further be invoked remotely through a URL (implicit, explicit
schemes or deep links). Although such public activities can be
easily found from an Android app’s manifest, it is hard to be certain
whether they can be navigated to a domain given by the adversary.
Static analysis alone does not provide a solution. Data flow analysis
tools [3] could help determine whether input data is propagated to
a WebView, but they usually fail to provide any clue about the input
that exploits the target vulnerability. Symbolic execution could be
used to analyze all the constraints between app’s entry point and
the WebView before resolving them to generate the input, which,
1.1.1 Chrome sends a scheme to infect Amazon Shopping1.1.11.2.1 Chrome sends a scheme to infect Twitter’s WebView1.2.11.2.21.2.2 Twitter launches Chrome1.1.2 Malicious content in Amazon Shopping issues an Intent to Facebook 1.2.31.1.21.1.3 Malicious content in Chrome issues a selector Intent to Facebook Alternative approach to steps 1.1.1-1.1.22 Facebook sends an Intent to Facebook Messenger, causing a message sent without user consent23 The malicious content in an infected WebView (e.g., Amazon, Twitter) launch another app to cover the Facebook Messenger.3Session D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA837however, is a process known to be complicated, expensive and easy
to fail.
In our research, we went down the dynamic path and devel-
oped a simple fuzzing system, ViewFinder, which scans apps for
remotely-controllable WebView instances. This approach is efficient