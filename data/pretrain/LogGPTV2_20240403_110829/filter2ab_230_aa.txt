.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "PG_RESTORE" "1" "2003-11-02" "Application" "PostgreSQL Client Applications"
.SH NAME
pg_restore \- 从一个由 pg_dump 创建的备份文件中恢复 PostgreSQL 数据库。
.SH SYNOPSIS
.sp
\fBpg_restore\fR\fR [ \fR\fB\fIoption\fB\fR...\fB \fR\fR]\fR\fR [ \fR\fB\fIfilename\fB \fR\fR]\fR
.SH "DESCRIPTION  描述"
.PP
\fBpg_restore\fR 是一种用于恢复由 \fBpg_dump\fR(1)  创建的任何非纯文本输出格式中的 PostgreSQL 数据库的应用。 它将发出必要的命令来重新构造数据库，以便于把它恢复成保存它的时候的样子。 归档（备份）文件还允许pg_restore 有选择地进行恢复， 甚至在恢复前重新排列条目的顺序。归档的文件设计成可以在不同的硬件体系之间移植。
.PP
\fBpg_restore\fR 可以以两种模式操作：如果声明了数据库名字， 那么归档是直接恢复到数据库里。大对象只能用直接数据库联接进行恢复。 否则，先创建一个包含重建数据库所必须的 SQL 命令的脚本（并且写入到一个文件或者标准输出）， 类似 pg_dump 输出纯文本格式的时候创建的那种脚本。 因此，一些控制脚本输出的选项就是摹拟 pg_dump 的操作。
.PP
显然，\fBpg_restore\fR 无法恢复那些不存在归档文件中的信息； 比如，如果归档是用"把数据转储为 INSERT命令"选项制作的， 那么 pg_restore 将不能使用 COPY 语句装载数据。
.SH "OPTIONS 选项"
.PP
\fBpg_restore\fR 接受下列命令行参数。
.TP
\fB\fIfilename\fB\fR
 声明要恢复的备份文件的位置。如果没有声明，则使用标准输入。
.TP
\fB-a\fR
.TP
\fB--data-only\fR
 只恢复数据，而不恢复表模式（数据定义）。
.TP
\fB-c\fR
.TP
\fB--clean\fR
 创建数据库对象前先清理（删除）它们。
.TP
\fB-C\fR
.TP
\fB--create\fR
 在恢复数据库之前先创建它。（如果出现了这个选项，和 \fB-d\fR  在一起的数据库名只是用于发出最初的 CREATE DATABASE 命令。 所有数据都恢复到名字出现在归档中的数据库中去。）
.TP
\fB-d \fIdbname\fB\fR
.TP
\fB--dbname=\fIdbname\fB\fR
 与数据库 dbname 联接并且直接恢复到该数据库中。
.TP
\fB-f \fIfilename\fB\fR
.TP
\fB--file=\fIfilename\fB\fR
 声明生成的脚本的输出文件，或者出现 \fB-l\fR 选项时用于列表的文件，缺省是标准输出。
.TP
\fB-F \fIformat\fB\fR
.TP
\fB--format=\fIformat\fB\fR
 声明备份文件的格式。因为pg_restore 会自动判断格式，所以如果声明了，它可以是下面之一：
.RS
.TP
\fBt\fR
 备份是一个 tar 归档。 使用这个格式允许在恢复数据库的时候重新排序和/或把表模式元素排除出去。 同时还可能在恢复的时候限制装载的数据。
.TP
\fBc\fR
 备份的格式是来自 pg_dump 的客户化格式。 这是最灵活的格式，因为它允许重新对数据排序，也允许重载表模式元素。 缺省时这个格式是压缩的。
.RE
.PP
.TP
\fB-i\fR
.TP
\fB--ignore-version\fR
 忽略数据库版本检查。
.TP
\fB-I \fIindex\fB\fR
.TP
\fB--index=\fIindex\fB\fR
 只恢复命名的索引。
.TP
\fB-l\fR
.TP
\fB--list\fR
 列出备份的内容。这个操作的输出可以用 -L 选项限制和重排所恢复的项目。
.TP
\fB-L \fIlist-file\fB\fR
.TP
\fB--use-list=\fIlist-file\fB\fR
 只恢复在 list-file 里面的元素，以它们在文件中出现的顺序。 你可以移动各个行并且也可以通过在行开头放 ';' 的方式注释。（见下文获取例子。）
.TP
\fB-N\fR
.TP
\fB--orig-order\fR
 以最初在 pg_dump 里生成的转储顺序恢复项目。 这个选项没有什么实际的用途，因为 pg_dump 会以自己方便的顺序生成项， 这个顺序不可能是恢复这些数据的安全顺序。 （这个顺序不是项最后在归档的内容列表中列出的顺序。） 又见 -r。
.TP
\fB-o\fR
.TP
\fB--oid-order\fR
 以 OID 顺序恢复项目。这个选项用处很小， 因为 OID 只是最初创建顺序的一个近似指示。 如果还声明了 -N，那么这个选项还覆盖它。又见 -r。
.TP
\fB-O\fR
.TP
\fB--no-owner\fR
 不要输出设置对象的权限，以便与最初的数据库匹配的命令。 缺省时，pg_restore 发出 \fBSET SESSION AUTHORIZATION\fR 语句设置创建出来的模式元素的所有者权限。 如果最初的数据库连接不是由超级用户（或者是拥有所有创建出来的对象的同一个用户）发起的，那么这些语句将失败。 使用 -O，那么任何用户都可以用于初始的连接，并且这个用户将拥有所有创建出来的对象。
.TP
\fB-P \fIfunction-name(argtype [, ...])\fB\fR
.TP
\fB--function=\fIfunction-name(argtype [, ...])\fB\fR
 只恢复指定的命名函数。请注意仔细拼写函数名及其参数，应该和转储的内容列表中的完全一样。
.TP
\fB-r\fR
.TP
\fB--rearrange\fR
 以对象类型重排项目（这个发生在以 -N 或者 -o 排序之后）。 重排是为了给出最大可能的性能。
如果没有 \fB-N\fR, \fB-o\fR, 和\fB-r\fR，那么 pg_restore 以项目出现在归档
的内容列表中的顺序恢复他们， 或者按照他们在 list-file 里面的顺序恢复他们
\(em 假如给出了 -L 的话。 -o 和 -r 的组合复制了 pg_dump 在创建归档的内容列表
之前进行的排序， 因此，这个选项通常没必要声明。
.TP
\fB-R\fR
.TP
\fB--no-reconnect\fR
 这个选项已经废弃了，但是为了保持向下兼容仍然接受。
.TP
\fB-s\fR
.TP
\fB--schema-only\fR
 只恢复表结构（数据定义）。不恢复数据，序列值将重置。
.TP
\fB-S \fIusername\fB\fR
.TP
\fB--superuser=\fIusername\fB\fR
 设置关闭触发器时声明超级用户的用户名。 只有在设置了 \fB--disable-triggers\fR 的时候才有用。
.TP
\fB-t \fItable\fB\fR
.TP
\fB--table=\fItable\fB\fR
 只恢复表指定的表的定义和/或数据。
.TP
\fB-T \fItrigger\fB\fR
.TP
\fB--trigger=\fItrigger\fB\fR
 只恢复指定的触发器。
.TP
\fB-v\fR
.TP
\fB--verbose\fR
 声明冗余模式。
.TP
\fB-x\fR
.TP
\fB--no-privileges\fR