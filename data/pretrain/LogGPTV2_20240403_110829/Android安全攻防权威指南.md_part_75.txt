12.16.1更改personality
禁用缓解机制的第一个方法是使用Linux的personality系统调用，这也是最灵活的方法。
setarch程序就使用了这个功能。它可以对每个进程分别禁用随机化、执行保护以及设置其他一些
标志。最新的GDB中有一个默认启用的disable-randomization设置，也用到了这个
personality系统调用。当前的Linux内核允许禁用随机化，但是不允许将内存映射到零地址。
此外，setarch在x86_64的机器上无法禁用执行保护。不要高兴得太早，在执行set-uid程序时
personality设置会被忽略。本节后面会介绍禁用这些保护措施的其他方法。
在Android的BionicC运行时库中并没有实现personality系统调用函数，不过底层的
Linux内核仍然支持它。因此，可以直接实现对这个系统调用的使用，相关的代码片段如下：
#include 
define SYs_personality 136 /* ARM sysca11 number */
inelude 
int persona:
persona = syscall(Sys_personality, Oxffffffff):
persona |= ADDR_NO_RANDOMIZ8;
syscal1 (Sys_personality, persona) ;
这里使用personality系统调用来禁用该进程的随机化。第一次调用获取了当前的
personality设置：接下来设置好需要的标志，再次执行这个系统调用，使新的persona值生
效。在AndroidNDK的 linux/personality.h文件里可以找到其他可以使用的标志。
---
## Page 339
12.17对抗缓解技术323
12.16.2修改二进制文件
前面介绍过，许多缓解技术由二进制可执行文件中的设置标志位所控制。防止数据执行、基
于PIE（位置无关的可执行文件）的基址随机化和只读重定位表等都依赖于二进制可执行文件中
的标志位。然面，通过修改二进制文件来禁用PIE或relro缓解机制并不容易。幸好，通过刚刚
介绍的personality调用可以禁用PIE随机化，面使用execstack工具则可以禁用防止数据
执行的机制。下面来看如何做到后者：
dev:-/android $ cp cat-gn-takju cat-gn-takju-CLEARED
dev:~/android $ execstack -s cat-gn-takju-CLEARED
dev:~/android $ readelf -a cat-gn-takju-CLEARED 1 grep GNU_STACK
0M00000X000000X000000000X000000000X0000000X0X00LS02
执行上述命令后，cat-gn-takju-CLEARED文件的栈、堆和其他内存区域就都可以执行了。
T- n 1 . dx** . dex6 1sdo/ts/oxd/ /uq/wss/ s/1ptoxpuett
she119android:/ $ cd /data/1oca1/tmp
shel1qandroid:/data/1ocal/tmp $ ./cat /proc/self/maps | grep *..xp •I wc -1
6 cat-gn-takju-CLEARED cat
ZC
可以看到，原来的二进制文件只有9个可执行内存区域；面清除GNU_STACK标志后，可执
行内存区域则增加到了32个。事实上，只有1块内存区城不可执行！
12.16.3调整内核
通过调整内核的可配置参数，也就是所谓的syscu，可以在系统全局范围内禁用许多保护机
制。调整的方法很简单，只需将新的配置值写人proc文件系统中相应的配置项即可。将一个数
值写人proc/sys/vm/mmap_min_addr就可以修改零地址页保护机制：写人0会禁用整个保护；写
人其他数值则会将用户空间程序可以成功映射的最小地址设置为这个指定的值。
/proc/sys/kermel/kptr_restrict用于配置内核指针信息保护：设置为o可以禁用这一保护，输出所有
指针值；设置为1时只允许root用户获得指针值；面设置为2则会将指针完全保护起来。将
/proc/sys/kemel/dmesg_restrict设置为o可以禁用对系统日志输出的限制。通过/proc/sys/kemel/
randomize_va_space可以控制地址空间布局随机化：设置为o时，将在系统全局范围内禁用所有
的随机化；设置为1时，会启用除堆以外所有内存区城的随机化：设置为2时，会告诉内核对
所有内存区域（包括堆）启用随机化。
虽然在学习和探索的过程中手动禁用各类缓解技术很有用，但是假定攻击的目标系统处于这
种脆弱状态是不明智的。要展开成功的攻击，通常需要对抗或者绕过这些缓解技术。
12.17对抗缓解技术
12
随着越来越多的缓解机制被引入系统当中，漏洞利用的开发者必须不断适应这一局面。每当
一种新技术被公布时，安全研究员就会迅速开始思考如何进行对抗。通过深入理解这些技术的特
---
## Page 340
324第12章漏洞利用缓解技术
点并跳出各类局限来思考，他们取得了相当大的成功。因此，对抗堆加固、栈缓冲区保护、执行
保护、ASLR和其他保护技术的方法开始变得广为人知。很多论文、报告、幻灯片、博客、文章
和利用代码都详细地介绍了这些技术。本节将简要介绍对抗栈cookie、ASLR、执行保护和内核
缓解机制的技术，但不会面面俱到。
12.17.1对抗栈保护
我们知道，栈保护技术的工作原理是在函数栈帧里放入cookie值，然后对其进行验证。这种
保护方法存在一些很关键的缺陷。首先，编译器通过启发式方法或者人工干预来决定哪些函数要
使用栈cookie。为了尽可能减少对性能的影响，如果函数中没有存储在栈上的缓冲区，就不会对
其使用这一机制。面且，如果函数使用了包含小数组的结构体或联合体，就可能不会受到保护。
其次，cookie值只在函数返回时才被验证。如果攻击者要在栈中破坏的东西在函数返回前就已经
被用到，则可能会躲开这一保护机制。比如在zergRush漏润利用中，开发者就破坏了栈帧中的
一个局部变量。这个被破坏的变量在存在漏洞的函数返回前就被释放，从面出现了use-after-free
的情况。最后，如果进行足够多的尝试，攻击者还是有可能正确地猜到cookie值。许多不常被考
虑到的情况可能会让这类攻击变得容易，比如cookie的煸很低，或者为每个连接请求fork出网
络服务。因此，虽然栈缓冲区保护机制可以防止一些情况下的漏洞利用，但无法防范所有的情形。
12.17.2对抗ASLR
虽然ASLR让许多漏洞利用的开发变得更具挑战性，不过还是有许多对抗的技巧。此前已经
说过，对抗ASLR最简单的方法是利用尚未被随机化的内存区域。此外，攻击者还可以使用堆喷
射技术，让其控制的数据到达内存中可预测的位置。这个问题在32位处理器的地址空间中更加
严重，尤其是在未启用数据可执行保护机制的情况下。
其次，攻击者可以利用信息泄露漏洞，从面得到进程的地址空间布局。堆喷射技术其实在
ASLR之前就出现了，但是最近才变得流行起来。
最后，攻击者还可以利用这样一种实际情况：当进程启动时，随机化会生效，但如果进程是
由一个程序fork而来，则不会再次随机化。使用fork系统调用后，新进程的地址空间布局会和
原来的进程完全一样。这种范式在Android上的一个例子是Zygote。Zygote利用fork机制来启
动所有应用程序，面这些应用程序拥有一个巨大的、共享的、预先填充的地址空间，让启动过程
的开销变得非常小。由于这样的设计，Android设备上的任何一个应用程序都可以泄露内存地址，
并成功地执行栈上数据。比如，一个惠意的应用程序可以将其内存地址信息发送到远程的网站上，
用于在该设备的浏览器中有效地造成内存破坏并进行利用。尽管会给漏洞利用开发者带来携战，
但这些也是对抗ASLR的有效方法。
12.17.3对抗数据执行保护
虽然阻止数据执行可以让漏洞利用变得更加困难，但其真正的潜力直到与完全的ASLR结合
---
## Page 341
12.18展望未来325
才真正被人们所认识到。要对抗这种保护，通常需要在地址空间中一个可以预测的地址上找到一
块包含可执行数据的内存区域。如果找不到这样一块区域，攻击者还可以利用信息泄露问题找出
可执行代码的位置。接下来，使用第9章中详细介绍的ROP技术，攻击者就可以将代码片段拼接
在一起来达到目标了。总之，这种缓解技术的强大程度取决于与其结合使用的ASLR的强大程度。
12.17.4对抗内核级保护机制
许多内核级保护机制都很容易被绕过，比如kptr_restrict 和dmesg_restrict（用于
针对本地攻击隐藏内核地址空间的最感信息）。还有，Android设备使用了嵌人boot分区中的一
个预编译内核。如果没有内核级的ASLR，要找出关键函数和数据结构的内核地址，只需获得并
分析目标设备的内核镜像文件即可。任何人都可以从官方系统镜像、OTA更新或者自己的设备
中提取出该内核镜像文件。
即使启用了内核级ASLR，这个间题依然存在。此时，如果攻击者找到内核的基地址，将其
与之前从内核镜像文件中获得的数据相结合，就可以找到关键的内核对象：面通过缓存定时攻击
（cachetimingattack）就可以轻松地找出内核基地址。虽然可以使用自定义的内核来修复这个间
题，但这并非一个可以用于所有设备的方案。首先，如果设备的booloader是锁上的，就没办法
在其上运行一个自定义的内核；其次，即便没有该障码，绝大部分消费者也没有意愿、时间和技
能来定制一个内核。因此，由于可以获得并预测内核镜像，对抗内核的地址泄露保护机制是很容
易的。
即便将这些缓解技术都部署到当前的系统中，攻击者也不会就此退缩。将它们结合起来确实
可以让攻击变得更为困难，但攻击者还是会去寻找新的方法来达到目标。不管怎样，这些缓解技
术确实增加了攻击成本，提高了攻击复杂度，甚至完全阻止了许多漏洞被利用。在未来，随着更
多缓解技术的研究、开发和部署，漏润利用可能会变得更加困难。
12.18展望未来
虽然无法确切地预测未来，不过可以确定的是，Android安全团队会为研发和部署漏洞利用
缓解技术投入很多。一些进行中的官方项目很可能会在将来的Android版本发布时被引入。还有
一些加固ARMLinux甚至专门加固Android的工作可能会被采用。此外，Linux和Windows等
PC操作系统中的一些相关技术也有希望得到移植。无论最终采纳哪种缓解技术，都几乎可以肯
定Android中会有越来越多的漏洞利用缓解技术。
12.18.1进行中的官方项目
在研究Android现有的缓解技术时，我们发现一个ticket显示了谷歌可能正在研究更细粒度
12
的沙盒技术。虽然Android已经使用了沙盒机制，但是相当粗糙。这个ticket位于https://code.google
com/p/chromium/issues/detail?id=166704，指向在 Android上对 seccomp-bpf 沙盒的实现。这个沙
盒机制能以进程粒度启用或禁用内核提供的功能，已经被用于ChromeOS和Linux上的Chromium
---
## Page 342
326第12章漏润利用缓解技术
浏览器，但是不清楚是否会被部署到Android上。即便部署，也不清楚是用于Android系统本身，
还是仅用于Android上的Chrome浏览器。
12.18.2社区的内核加固工作
除了谷歌官方的工作，还有许多社区的开源项目致力于进一步加固Linux内核，包括来自上
游Linux内核自身的几个项目，以及来自独立第三方团体的一些项目。尽管不确定这些项目最后
是否会进入官方发布的Android，但在未来不乏可能。
过去几年，KcesCook一直在努力将文件系统链接保护机制加入官方的Linux内核源代码；
但直到最近发布的Linux3.6，这一目标才得以实现。这是一个双重的保护技术。首先，它会检查
所有的符号链接，确保其满足特定的条件。下面摘录Kees在commit中的一段话：
这个方案让符号链接在下列情况下才能被访问：该链接指向一个全局可写的目录；
该符号链接本身的uid和访问者相符；所指向目录的所有者是该符号连接的所有者。
启用这些限制可以防止符号链接攻击，包括被许多Androidroot工具所利用的攻击。其次，
低权限用户再也无法创建硬链接指向非其所有或无法访问的文件。这两个保护机制的结合可以让
许多基于文件系统的攻击无法成功。可惜的是，在写作本书时，还没有Android设备在出厂时使
用3.6版的内核。将来的设备中很可能会包含并启用这一保护方案。
长期以来，Linux内核开发者社区中就一直在讨论对内核ASLR的实现。当前的许多操作系
统都已经使用了这一技术，如Windows、MacOSX和iOS。12.17节谈到，这一技术为对抗本地
攻击提供的保护相对较少；不过它还是可以为远程攻击增加难度。这个保护技术可能会在上游
Linux内核中得以实现，然后进入Android设备。
在PC领域，英特尔最新发布的缓解机制包括基于硬件的管理者模式访问保护技术
（Supervisor Mode Access Protection，SMAP）和管理者模式执行保护技术（Supervisor Mode
ExecutionProtection，SMEP）。这些技术用于防止内核空间的代码访问或内核空间中的数据执行。
当前的ARM处理器包含一些特性，可以实现类似的保护机制。BradSpengler是一位经验丰富的
内核研究人员，也是grsecurity项目的维护者，他开发并在网站上发布了许多对ARMLinux内核
的加固补丁。这些补丁包括UDEREF和PXN两种保护技术，分别类似于SMAP和SMEP。虽然
这些保护机制很重要，但现在还没有迹象表明会将其部署到未来的Android设备中。
还有项工作值得一提。2012年9月，Subreption公司宣布了一项美国国防部高级研究计划署
（DARPA）资助的项目，名为SAFEDROID。该项目的目标包括改进ASLR，加固内核堆，以及
改进内核空间和用户空间的内存保护措施。这些目标虽然显得喀础逼人，但也令人饮佩。它们会
为内核级漏洞利用带来严峻的挑战。可情的是，直到本书写作时，这个项目似乎还未取得成功。
12.18.3一些预测
除了前面提到的项目，还有一些加固措施可能会被实现。iOS使用的强制性代码签名对阻碍
---
## Page 343
12.19小结327
漏润利用代码的开发非常有效。虽然在Android中使用此类严格限制也会产生类似的效果，但是
可能性不大，因为这么做会对Android应用程序开发社区的开放性产生负面影响。另一方面，虽
然Android从一开始就引入了safe_iop库，但并没有广泛使用。Android加固的后续合理动作是进
一步使用这个库。我们无法准确预测Android缓解技术的未来，只有时间能告诉我们将来还有哪
些缓解技术会被加人Android中去。
12.19小结
本章介绍了漏洞利用缓解技术的概念以及在Android系统上的使用方法，然后解释了实现这
些缓解技术需要改动硬件、Linux内核、BionicC库、编译工具链等组件。对于每种缓解技术，
都介绍了其背景情况、实现效果以及Android采用的历史。还给出了一个总结表格，详细列举了
Android支持这些缓解技术的历史发展。接下来，介绍了如何有意禁用这些利用缓解机制，以及
如何进行对抗。最后，对Android上漏洞缓解技术的未来作出了展望。
下一章会讨论如何攻击与Android设备类似的嵌人式系统硬件，介绍用于攻击硬件的工具和
技术，以及这类攻击成功后的情况。
---
## Page 344
第13章
硬件层的攻击
对于各种各样的移动硬件平台，Android有很好的可移植性和通用性，因此在移动领域几乎
无处不在，取得了巨大的成功。Android的可移植性和灵活性还使其成为了不错的嵌入式设备操
作系统。Android开放、可定制性强，更容易快速开发出可视化用户界面，这些优点与其他嵌人
式Linux系统、实时操作系统和私有操作系统相比尤为明显。目前，Android已经成为各类新型
嵌人式设备中操作系统的事实标准，被广泛用于电子书阅读器、机顶盒娱乐系统、飞机机载娱