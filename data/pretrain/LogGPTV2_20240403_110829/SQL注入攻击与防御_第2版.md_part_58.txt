姓名
地址
将所有引号
3.更新选中的
e-mail
4. UPDATE
双重编码
数据项
地址
语句
图7-2更新已存在联系人的信息流
假设将示例中的引号双重编码可以有效防止一阶SQL注入。尽管如此，应用仍然容易受
到二阶SQL注入攻击。要想利用该漏洞，我们首先需要使用某个字段中的攻击有效载荷创建
一个联系人。假设数据库为Microsoft SQLServer，使用下列名称创建一个联系人：
a'+eeversion+'a
输入中的引号被双重编码，最终的INSERT语句如下所示：
使用提交的字面值将联系人姓名安全地保存到数据库中。
接下来关注更新新创建联系人的功能，只需为地址字段提供一个新值（可以是任何能被接
收的数据）即可。进行这些操作时，应用首先使用下列语句检索已经存在的联系人的细节信息：
SELECT · FROM tblUsers WHERE contactId - 123
检索出来的细节信息被保存在内存中。当然，根据姓名字段检索出来的值与最开始提交的
字面值相同，因为它们就是保存在数据库中的内容。应用程序使用新提供的值替换内存中的地
址值，注意将引号标识双重编码。接下来执行下列UPDATE语句，将新信息保存到数据库中：
SET namg=*a*+@@version+'a*, address=*52 Throwley Way*,.**
UPDATE tb1Users
WHERE contactId - 123
到目前为止，攻击已成功执行并颠覆了应用程序的查询。对从数据库检索出来的名称的处
理是不安全的，您可以摆脱查询中的数据语境并修改查询的结构。在这种概念验证攻击中，我
们将数据库版本字符串复制给了联系人姓名。当查看更新过的联系人的细节信息时，它会显示
283
---
## Page 298
SQL注入攻击与防御（第2版）
在屏幕上：
Name: aMicrosoft SQL Server 7.00 - 7.00.623 (Intel X86) Nov 27
199822:20:07 Copyright (c) 1988 - 1998 Microsoft Corporation Desktop
Edition on ￥indows Nr 5.1 (Bui1d 2600:)a
Address: 52 Throwley Way
要想执行更有效的攻击，就需要使用前面介绍注入UPDATE语句时经常使用的技术（请参见
第4章，将攻击先放到一个联系人字段中，然后再通过更新一个不同的字段来触发该漏洞。
寻找二阶漏洞
却在应用程序对另一个请求的处理中执行。那些发现大多数基于输入的漏洞时所使用的核心技
术一一通常使用各种构造好的输入来重复提交独立的请求并监视响应中的异常—并不适用
于发现二阶SQL注入。与上述技术不同，我们需要在一个请求中提交构思好的输入，然后逐
步跟踪应用程序中其他可能使用该输入的功能以便寻我异常。某些情况下，相关输入只有一个
实例（例如，用户的显示名称)，这时测试每个有效载荷可能需要逐步跟踪应用所有的功能。
当今的自动扫描器无法很有效地发现二阶SQL注入。它们通常使用不同的输入来将每个
请求提交多次并监视每个请求的响应。如果接下来搜索应用程序的其他区域并遇到数据库错误
消息，它们便会将这些消息显示给用户，希望用户能够调查并诊断存在的问题。不过，它们无
法将某个位置返回的错误消息与其他位置提交的一些构思好的输入关联起来，有时不存在错误
消息，二阶条件的效果可能被盲目处理。如果只存在单个相关的持久项实例或者让数据项持久
存在于应用程序中需要多个步骤（例如，用户注册操作)，那么此时的问题更严重。所以，当今
的扫描器无法执行一套严格的寻找二阶漏洞的系统方法。
如果无法理解应用程序中数据项的含义和用法，那么检测二阶SQL注入涉及的工作量会
随应用功能的增加呈指数级增长。不过，手动测试人员可以凭借对功能的理解和对经常出错位
置的直觉判断来降低任务的复杂度。大多数情况下，可以使用下面的系统方法来识别二阶漏洞：
（1）在筹划好应用程序的内容和功能后进行复查，寻找所有用户能够控制的数据项，这些数
据项会被应用程序持久保存并被后面的功能重用。单独操作每个数据项并为每个实例执行接下来
的步骤。
(2）在数据项中提交一个简单的值，数据项在SQL查询中被不安全地使用时很可能会引发
问题，例如，单引号或者使用单引号引起来的字母数字型字符串。如有必要，请快速检查所有
包含多个阶段的过程（比如用户注册）以保证数据值完全持久地存在于应用程序中。
(3）如果发现应用程序的输入过滤器阻止了输入，请使用本章前面（7.2.8节“避开输入过滤
器”）介绍的技术以尝试战胜前台输入过滤器。
(4）快速检查应用程序中所有存在显式使用数据项的功能以及可能存在隐式使用数据项的
功能。寻找所有能够表明是由输入引发了问题的异常行为，比如数据库错误消息、HTTP500
状态代码、更隐秘的错误消息、受损的功能、去失或毁坏的数据等。
(5）对于识别出来的每个潜在问题，尝试开发一种概念验证攻击来确认是否存在SQL注入
漏洞。请注意，有缺陷的持久数据可能以间接受到攻击的方式（例如，整型转换错误或后续数
据验证失败）来引发异常条件。尝试使用两个引号标识来提供相同的输入并查看异常是否消失。
尝试使用数据库专用的结构（比如字符申连接函数和版本标识）来确认正在修改SQL查询。如果
284
---
## Page 299
第7章高级话题
异常条件是盲的（例如，不返回查询结果或任何错误消息），请尝试使用时间延迟技术来确认漏
润的存在。
应该意识到，有些二阶SQL注入漏洞是纯盲的，它们不会对应用程序响应的任何内容产
生可识别的影响。例如，如果应用程序的一个函数以不安全方式编写登录的持久数据并且优雅
地处理所有异常，那么使用我们刚刚介绍的步骤可能就无法发现该漏洞。要想检测到这种类型
的缺陷，需要先使用步骤（1)中的各种输入（在SQL查询中不安全地使用这些输入时会触发时间
延迟）来重复上述步藏，之后再监视应用程序所有的功能以发现异常延迟。要想有效实现该目
标，需要使用一种语法，而该语法是当前正在使用的数据库类型和当前正在执行的查询
(SELECT、INSERT等）所专用的。实际上这是一种需要长期练习才能掌握的技能。
工具与陷阱
二阶漏洞的产生原因
二阶SQL注入很常见，这有点儿出人意料。本书作者曾经在很成熟且安全性至关
重要的应用（比如网上银行使用的程序）中遇到过该漏润。这类漏润可以隐藏数年，因为
检测到它们相对比较团难
现在很多（甚至可能是大多数）开发人员已经意识到SQL注入的威胁，他们知道如何
使用参数化查询来将受感染的数据安全地集成到SQL查询中，不过，他们也同样知道写
参数化查询比构造简单的动态查询要花费更多精力，许多开发人员仍然对感染的概念存
在误解，认为在收到用户提供的数据后只需安全地处理即可将它们看作受信任的数据。
编写SQL查询的常见方法是为明显受到感染的数据（比如从当前HTTP请求收到的
内容）使用参数化查询，此外，针对每种情况对该数据是否可以在动态查询中安全地使
用作出判断，这种方法很危险，因为它很容易引发疏忽，错误地对受感染数据进行不安
全处理，受信任的数据源特来可能因为基础代码中其他地方的变化而受到感染，从而在
不知情的情况下引入二阶需润，这种错误的总乘观念（即只有在收到数据后才需进行安
全处理）会导致数据项看起来是值得信任的，但实际上不可信。
要防御二阶漏洞，最健社的方法是为所有数据库访问使用参数化查询并正确地参数
化集成到查询中的每个可变数据项，使用这种方法来寻线真正值得信任的数据虽然需要
花费少量额外的精力，但却可以避免上述错误，采用这种策略还可以使与SQL注入相
关的代码安全性复查更加简单迅速。
请注意，在将数据项分配给它们的占位符之前，有些SQL查询的子部分（比如列和
表名）元法被参数化，因为定义好查询之后由这些子部分构成的结构是固定的，如来要
将用户提供的数据集成到查询的这些子部分中，就应该确定是否可以使用不同的方法来
实现自己的功能。例如，通过将映射的索引号传递给服务器端的表和列名。如果这样不
可行，就应该按照白名单原则（在使用之前）仔细验证用户数据，
7.4客户端SQL注入漏洞
HTML5引入了大量的新特性和新功能，这为新的攻击方式和防御技术创造了可能性。就
285
---
## Page 300
SQL注入攻击与防御（第2版）
SQL注入攻击而言，与之关系最密切的就是HTML5中引入的客户端数据存储这种新机制。
在HTML5中，客户端JavaScript代码可以使用基于SQL的本地数据库来存储和获取任意
数据。应用程序可以将长期的数据持久化存储在客户端，以便更快速地检索数据，甚至当到服
务器的连接不可用时，应用程序可以工作在“离线模式”。
7.4.1访问本地数据库
下面是一个JavaScript代码的例子，它打开了一个本地数据库，创建了一个表并使用一些
数据更新了该表：
var database - openDatabase (*dbStatus*, "1.o*, *Status updates*, 500000);
db.tzansaction (function (tx){
NULL PRIMARY KEY AUTOINCREMENT, date VARCHAR (20), uSer VARCHAR (50),
status VARCHAR (100) )“) ;
tx.executeSql (*INSERT INTO tblUpdates (date, user, status) VALUES
(*1/8/2012', *Me*, 'I am writing a book.*)");
1) ;
在上面的示例脚本代码中，首先打开了一个名为dbStatus 的数据库。在调用openDatabaseO
方法时，指定了数据库的名称、版本号（以便允许应用程序未来的版本使用不同遗留版本的数
据库）、数据库的显示名称以及以字节为单位的最大存储容量。如果之前并不存在该数据库，
openDatabase0方法将自动创建一个数据库。随后的脚本代码执行了标准的 SQL语句，创建一
个表（如果数据库中不存在该表的话），并向该表插入了一行数据。
在上面这个例子中，数据库被用在一个社交网络应用程序中，用于存储用户及其联系人的
状态更新。将这些信息存储在客户端数据库中，应用程序就可以快速访问这些数据面无须从服
务器端检索这些数据。另外，当没有Intermet连接而离线时，用户依然可以更新他们的状态。
随后当Intemet连接可用时，应用程序将把所有离线状态更新同步到服务器。在Web应用程序
中可以高效地使用离线存储技术，其他一些例子还包括：
在离线的情况下，用户也可以快速查看预加载的文章并阅读内容。用户的评论也可以
存储在本地，并异步更新到服务器。
·银行应用程序一可以将交易信息存储在本地，以允许用户离线查看交易信息。
●Web邮件应用程序—可以将电子邮件消息存储在本地数据库中，以便用户快速检索
和查看邮件。以往发送的电子邮件也可以存储在本地，待随后上线后发送。
本地SQL存储提供了很多的可能性，这在移动应用程序中特别有用。在移动应用程序中，
有效的Intermet连接可能是间歇性的、只有较低带宽、存在较高的延迟或者存在执行性能问题。
在这些情况下，使用离线数据库并结合异步的数据同步技术，应用程序就可以提供更加丰富的
用户体验。
7.4.2攻击客户端数据库
正如贯穿本书所讨论的那样，如果攻击者能把由他控制的数据以一种非安全方式插入到
SQL查询中，就会产生SQL注入漏洞。如果基于JavaScript的客户端应用程序使用由攻击者控
制的数据以非安全方式访问本地SQL数据库，那么与之类似，相同类型的各种漏洞就会产生。
286
---
## Page 301
第7章高级话题
主要的差异在于两点，一是用于发送攻击数据时所使用的通道（channel)不同，二是提取所捕获
数据的有效机制不同。
要发送客户端SQL注入攻击，攻击者必须识别出一些他能控制的数据片段，并且应用程
序以非安全方式将这些数据片段存储在其他用户的客户端数据库中。在前面的例子中，社交网
络应用程序使用本地SQL数据库来存储当前用户及其联系人的状态更新。因此，在发生状态
更新时，用户提交的数据将向外扩散，通过服务器到达其他用户的本地数据库。如果该应用程
序没有对这种数据进行消毒处理，并直接将其插入到客户端SQL查询中，那么客户端应用程序
很可能容易受到攻击：
tX,executeSql (*INSERT INTO tblUpdates (date, user, status) VALUES
（*1/8/2012'，‘BadGuy'，*)*)；//不平衡的引号导致一个SQL错误
值得注意的是，应用程序在所有服务器端操作（包括SQL查询）中，可能已经安全地处理了
这些数据。应用程序的服务器端部分可能经过更多的深思熟虑，并进行了更为全面的测试，因
此不会产生任何SQL注入间题。但是如果应用程序的客户端部分在开发过程中没有认真考虑
可能产生的SQL注入问题，那么应用程序依然容易受到攻击。
可用于客户端SQL注入攻击的类型，完全取决于在应用程序中如何使用本地数据库。就
查询结果并不直接返回给攻击者这一方面而言，这些客户端SQL注入攻击显然是“盲注”。
比如，对SELECT查询实施or1-1--这样的攻击，并不会向攻击者直接返回任何信息。此外，
处理SQL盲注条件的那些常用技术，并不能应用于客户端SQL注入攻击，因为对于攻击者而
言，通常没有办法确定是否发生了错误、时间延迟或其他异常。
但是，如果攻击者自己拥有客户端应用程序的实例，他就可以在白盒环境（white-box context)
中与该客户端应用程序完全地进行交互。攻击者可以使用他拥有的客户端应用程序实例来精确
地确定执行了什么样的SQL查询、客户端应用程序中使用了哪些过滤器或其他防御技术。这
样一来，在将攻击数据发给实际的目标应用程序之前，攻击者可以调整好他的攻击。
在客户端代码中，假如没有其他相关漏洞存在（比如动态执行JavaScript代码的注入漏洞)，
那么对客户端SQL注入漏润的利用必须完全在所注入的SQL语句中完成一例如，通过使用
注入的子查询从一个表中选取数据，并将其注入另外一个表中。此外，客户端SQL注入攻击
还常常依赖于应用程序自身处理离线数据同步的机制，以使将捕获的数据推送给服务器，进而
回送给攻击者。下面列出了一些成功的例子，它们使用纯粹的SQL来发送攻击，并成功地利
用了客户端SQL注入漏洞：
·在社交网络应用程序中，攻击者有可能使用注入的SQL语句从本地数据库中检索敏感
信息（例如私信消息的内容)，并将这些信息复制到用户的当前状态（current status)，这样
就可以通过正常方式查看到这些敏感信息。
·在Web邮件应用程序中，攻击者有可能检索用户收件箱中的消息内容，并将这些信息
复制到发件箱消息表的一个条目中，这样就可以向攻击者发送一封包含了敏感数据的
电子邮件。
·在实现拍卖功能的应用程序中，攻击者有可能使用精巧设计的注释语句，在任何用户
可以看到的注释上执行SQL注入，从而导致用户在攻击者选定的项目上（离线）投标。
在客户端SQL存储的典型案例中，在应用程序的普通用户所提交的自由格式的文本数据
中，很可能会包含引号标记和其他SQL元字符一例如在社交网络应用程序中，很有可能必须
287
---
## Page 302
SQL注入攻击与防御（第2版）
支持包含单引号的状态消息，因此，在正常的应用程序可用性测试过程中，最明显的SQL注
入漏洞将被识别出来。出于这样的原因，在下列位置最容易找到客户端SQL注入漏洞：
·攻击者可以控制的基于文本的数据，但这些数据不是屏幕上最初以自由格式输入到应
用程序的文本字段一例如通过表单隐藏域、下拉列表等提交的数据。
●在屏幕上输入的但是受到输入验证程序支配的数据—这些输入验证程序被设计用于
对SQL元字符进行消毒（例如双重引号标记），但是可以用某种方式绕过这些验证程序。
7.5使用混合攻击
混合攻击是指联合使用两种或多种漏洞来攻击应用程序，通常产生的影响比各个子漏洞攻
击之和更大。可以将SQL注入与其他技术以多种方式相结合来实现攻击应用程序的目的。
7.5.1利用捕获的数据
当然，首先可以使用SQL注入来检索用于提升应用程序中权限的敏感数据。例如，可以
读取其他用户的口令并以他们的身份登录。如果口令经过哈希加密并且您知道加密算法，就可
以尝试破解在线蕉获的哈希。与此类假，也可以读取包含最感登录数据的表，其中包含用户名、
会话令牌(session token），甚至是在其他用户请求中提交的参数。
具体来说，如果应用程序包含账户恢复功能，而该功能可以向忘记口令的用户发送一封
e-mail(其中包含可以一次性恢复口令的URL)，就可以读取发送给其他用户的账户恢复令牌的