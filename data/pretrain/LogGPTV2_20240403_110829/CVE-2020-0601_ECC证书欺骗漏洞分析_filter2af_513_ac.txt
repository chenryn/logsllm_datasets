    signed int __fastcall IsRootEntryMatch(int a1, int a2, int a3)
    {
      int v3; // esi
      v3 = 0;
      while ( *(_DWORD *)(a1 + 4 * v3 + 4) == *(_DWORD *)(a2 + 4 * v3) )
      {
        if ( ++v3 == 8 )
        {
          if ( **(_DWORD **)a1 == *(_DWORD *)a3
            && !memcmp(*(const void **)(*(_DWORD *)a1 + 4), *(const void **)(a3 + 4), *(_DWORD *)a3) )
          {
            return 1;
          }
          return 0;
        }
      }
      return 0;
    }
## 漏洞分析
下面从ChainGetSubjectStatus函数开始分析，首先ChainGetSubjectStatus函数中会通过第一个和第三个参数获取pvIssuer和pvSubject，pvSubject和pvIssuer分别存放了证书及其签发者证书的CERT_CONTEXT结构，其中
pbCertEncoded指向了证书编码的缓冲区，cbCertEncoded为其长度。
    0:000> dt cert_context 594980
    combase!CERT_CONTEXT
       +0x000 dwCertEncodingType : 1
       +0x004 pbCertEncoded    : 0x00568408  "0???"
       +0x008 cbCertEncoded    : 0x299
       +0x00c pCertInfo        : 0x00568b98 _CERT_INFO
       +0x010 hCertStore       : 0x0055ee70 Void
CERT_CONTEXT结构偏移0xc处为包含该证书信息的CERT_INFO结构，这个结构中的内容之前讲的证书结构相吻合。
    0:000> dx -r1 ((combase!_CERT_INFO *)0x568b98)
    ((combase!_CERT_INFO *)0x568b98)                 : 0x568b98 [Type: _CERT_INFO *]
        [+0x000] dwVersion        : 0x2 [Type: unsigned long]
        [+0x004] SerialNumber     [Type: _CRYPTOAPI_BLOB]
        [+0x00c] SignatureAlgorithm [Type: _CRYPT_ALGORITHM_IDENTIFIER]
        [+0x018] Issuer           [Type: _CRYPTOAPI_BLOB]
        [+0x020] NotBefore        [Type: _FILETIME]
        [+0x028] NotAfter         [Type: _FILETIME]
        [+0x030] Subject          [Type: _CRYPTOAPI_BLOB]
        [+0x038] SubjectPublicKeyInfo [Type: _CERT_PUBLIC_KEY_INFO]
        [+0x050] IssuerUniqueId   [Type: _CRYPT_BIT_BLOB]
        [+0x05c] SubjectUniqueId  [Type: _CRYPT_BIT_BLOB]
        [+0x068] cExtension       : 0x4 [Type: unsigned long]
        [+0x06c] rgExtension      : 0x568c20 [Type: _CERT_EXTENSION *]
然后函数会调用ChainGetMatchInfoStatus函数判断证书的签发实体是否正确，验证证书的签发者字段（Issuer）和其签发者证书的证书主体字段（Subject
）是否相同。其中，Issuer 和 Subject 均为CRYPTOAPI_BLOB结构，包含cbData（pbData的长度） 和
pbData字段（指向缓冲区）：
    if ( *(_DWORD *)(v12 + 0x18) != *(_DWORD *)(v7 + 0x30)
        || !*(_DWORD *)(v12 + 0x18)
        || memcmp(*(const void **)(v12 + 0x1C), *(const void **)(v7 + 0x34), *(_DWORD *)(v7 + 0x30)) )
      {
        v9 = 2;
        goto LABEL_8;
      }
例：Microsoft ECC Product Root Certificate Authority 2018证书的证书所有者信息的编码数据。
    0:000> dx -r1 (*((combase!_CRYPTOAPI_BLOB *)0x568bb0))
    (*((combase!_CRYPTOAPI_BLOB *)0x568bb0))                 [Type: _CRYPTOAPI_BLOB]
        [+0x000] cbData           : 0x97 [Type: unsigned long]
        [+0x004] pbData           : 0x568437 : 0x30 [Type: unsigned char *]
    0:000> db 0x568437 l97
    00568437  30 81 94 31 0b 30 09 06-03 55 04 06 13 02 55 53  0..1.0   ..U....US
    00568447  31 13 30 11 06 03 55 04-08 0c 0a 57 61 73 68 69  1.0...U....Washi
    00568457  6e 67 74 6f 6e 31 10 30-0e 06 03 55 04 07 0c 07  ngton1.0...U....
    00568467  52 65 64 6d 6f 6e 64 31-1e 30 1c 06 03 55 04 0a  Redmond1.0...U..
    00568477  0c 15 4d 69 63 72 6f 73-6f 66 74 20 43 6f 72 70  ..Microsoft Corp
    00568487  6f 72 61 74 69 6f 6e 31-3e 30 3c 06 03 55 04 03  oration1>0 dd 005e9f48 l88/4
    005e9f48  0000021f 0056840c 00568e80 00000000
    005e9f58  00000000 00000067 005e9f68 00000000
    005e9f68  30026530 d3a62109 ef573e49 c8247932
    005e9f78  7adc3eb3 7b43c0e5 0761b4be d1e40fad
    005e9f88  38d9607b ab746d99 bcbdd35e 48983ede
    005e9f98  a1e9c699 ee003102 33beddd1 dfce2156
    005e9fa8  d6d55979 680ee477 72cdba97 71805f78
    005e9fb8  cd2b929f 3d40d072 fcc9ccac 518420b1
    005e9fc8  b42c99a0 baacc899
    0:000> db 00568e80
    00568e80  31 2e 32 2e 38 34 30 2e-31 30 30 34 35 2e 34 2e  1.2.840.10045.4.
    00568e90  33 2e 32 00 ab ab ab ab-ab ab ab ab 00 00 00 00  3.2.............
然后通过CryptFindOIDInfo函数获取散列算法相关的CRYPT_OID_INFO结构，通过CryptHashCertificate2计算证书的散列值，大小为0x20。
    0:000> gu
    eax=00000001 ebx=005e9f48 ecx=6e81a50e edx=00000001 esi=005e9ff8 edi=00000000
    eip=74fe73ab esp=00cf85dc ebp=00cf8608 iopl=0         nv up ei pl zr na pe nc
    cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
    CRYPT32!I_CryptCNGVerifyCertificateSignedContent+0xcf:
    74fe73ab 85c0            test    eax,eax
    0:000> dd  005e9ff8
    005e9ff8  aa54c5ce 8ef563af 0ccb1ef9 12ce25a1
    005ea008  6510dbbc 96dbbb9b 1aba9a30 532b2e50
然后通过CryptImportPublicKeyInfo函数获取签发者证书的公钥句柄，通过I_CertAllocAndDecodeObject函数以及PkiAsn1ReverseBytes函数解码及调整获取证书中的签名数据，最终调用BCryptVerifySignature函数验证散列值和签名是否匹配。这一流程符合证书的验证流程，即获取证书元数据和数字签名，使用同样的Hash算法计算证书元数据的散列值，使用
Issuer 的公钥对数字签名进行解密，得到解密后的散列值。比较这两个散列值是否相同，相同则通过验证。
    memcpy(&v13[v10 - *(_DWORD *)v8], *(const void **)(v8 + 4), *(_DWORD *)v8);
    v7 = pbSignature;
    memcpy(&pbSignature[cbSignature - *(_DWORD *)(v8 + 8)], *(const void **)(v8 + 12), *(_DWORD *)(v8 + 8));
    v9 = BCryptVerifySignature(hKey, 0, pbHash, cbHash, v7, cbSignature, 0);
如果签名验证成功，就将v13[0x3a]（其实就是v13偏移0xE8）起始的0x10字节的数据复制到v14处（v12偏移0xF8）。经过溯源发现，v12来自*(DWORD
*)a3，也就是证书的CCertObject结构，v13来自*(DWORD
*)a1，也就是签发者证书的CCertObject结构。而通过这两个偏移进行的复制的位置恰好是当证书的CCertObject结构体偏移0x14处的flag中0x2被设置时要比较的位置。这个0x10长度的散列很容易让人联想到MD5，而且这个是从签发者证书结构向证书结构中复制的数据，那会不会就是传说中的证书公钥散列值，这个还需在后面进行分析。
    if ( v11 )
        {
          v12 = v33; 
          CCertObject::SetWeakHash(v33, v27); 
          v13 = v36;
          if ( !(v34 & 1) || (memcmp((char *)v12 + 0xF8, v36 + 0x3A, 0x10u) ? (v19 = -2) : (v19 = v34), !(v19 & 1)) )
          {
            v14 = (_DWORD *)((char *)v12 + 0xF8);
            v29 = 0x10;
            v30 = v14;
            v15 = (char *)pvSubject;
            *v14 = v13[0x3A];
            v14[1] = v13[0x3B];
            v14[2] = v13[0x3C];
            v14[3] = v13[0x3D];
            SetProperty(
              0x18u,
              v15 != 0 ? (unsigned int)(v15 - 48) : 0,
              (struct _CONTEXT_ELEMENT *)0x80000000,
              (unsigned int)&v29,
              0,
              v22,
              (int)v24);
            v12 = v33;
          }
          *((_DWORD *)v12 + 5) |= 3u;
          v6 = v37;
          goto LABEL_11;
        }
随后调用SetProperty函数为证书添加属性，然后将偏移0x14处的flag设置为3，这个标志也是后面要讨论的。证书的属性链在X结构体偏移 0x2c
处（这个结构体还没分析到先叫它X吧），也就是CERT_CONTEXT结构偏移 -4
的位置。每个属性结构的首4字节表明不同的属性，偏移0x8和0xc处分别为该属性的内容及长度。偏移0x10和0x14处分别为该属性结构的前向指针和后向指针。
    0:000> dd ecx
    00568eb0  00000001 00000000 00000000 00000003
    00568ec0  00568eb0 0055ee70 00000000 00568de0
    00568ed0  0055ee70 00000000 00000000 00594788
    00568ee0  00000001 00568408 00000299 00568b98
    00568ef0  0055ee70 abababab abababab 00000000
    0:000> dd 00594788
    00594788  0000005c 80000000 0056b490 00000004
    00594798  005946d8 00000000 abababab abababab
    0:000> dd 005946d8
    005946d8  00000019 80000000 005946b0 00000010
    005946e8  00594650 00594788 abababab abababab
    0:000> dd 00594650
    00594650  00000014 80000000 005942d0 00000014
    00594660  005942a0 005946d8 abababab abababab
    0:000> dd 005942a0
    005942a0  0000000f 80000000 00594268 00000020
    005942b0  00593ef0 00594650 abababab abababab
    0:000> dd 00593ef0