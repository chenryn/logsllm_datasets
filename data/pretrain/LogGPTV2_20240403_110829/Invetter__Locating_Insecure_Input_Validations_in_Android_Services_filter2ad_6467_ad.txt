(only 643 of them (34.48%) are protected by app-level permissions,
and the remaining can be exploited without permission granted).
We randomly select 800 (100 each for 8 system images) of them
and find 71 false positives by manually checking. After manual
inspection, we find that not all branches which return constants
belong to input validations (e.g., some hard code constant returns).
Since our tool recognizes all constant-returning branches as input
validation, we mistakenly report such cases as input validations.
From the 1865 input validations, Invetter finds 749 sensitive input
validations after learning.
After the phase of vulnerability discovery, Invetter locates 103
possibly insecure ones in total by searching for the patterns dis-
cussed in §3. The results are shown in Table 2. We manually verify
these insecure access controls, and find that among these reports, 86
are true positives. Some seemingly sensitive input validations in the
end do not yield any sensitive subsequent actions (e.g., returning a
true/false status). Unfortunately, it is extremely challenging to eval-
uate the completeness (i.e., false negatives) of our approach because
the codebase of Android framework is too huge to inspect manually
(more than 100,000 conditional branches). This is a common limita-
tion of similar static analysis tools (e.g. Kratos [26], AceDroid [33]).
As an empirical evidence from a small scale experiment on 5 An-
droid services (including StatusBarManagerService, MmsService-
Brokers$BinderService, LocationManagerService, TextServiceMan-
agerService, MediaSessionService$SessionManagerImpl) in AOSP
7.1, we manually identify their sensitive input validations as well as
insecure input validations. These results are all successfully identi-
fied by Invetter. Thus, we believe that the coverage is decent.
189
50
Android Framework Android SDK
Category
Verify caller identity
Restrict usage of
sensitive resources
Security irrelevant
validations
Total
Table 3: The categorization of input validations.
258
497
130
232
30
72
6.2 Categorization of Identified Input
Validations
To better understand the input validations of Android framework
and the validations applied to the Android SDK, we conduct a
measurement study in this section of all the manually checked
input validations. Table 3 illustrates their distributions. About 36%
of input validations in Android framework and 12% of validations
in Android SDK are used to verify the caller’s identities such as
uid, package name, or whether it holds a critical permission. Most
of these validations are critical security checks, thus bypassing
them may cause serious consequences. Besides, about 10% of the
input validations in Android framework and 31% of validations in
Android SDK are designed to restrict the usage of sensitive system
resources. For example, check whether the type of a given message
is permitted. Bypassing these checks can also lead to security flaws,
although less likely compared to the identity checks. Thus, in total,
more than 40% of the input validations in Android are used to
ensure the secure usage of sensitive resources.
6.3 Tool Effectiveness
From all the 86 identified insecure sensitive input validations
(true positives mentioned earlier), we further hope to understand
whether these cases are actually exploitable. For our purposes, we
manually investigated them and indeed confirm there exist a large
number of exploitable vulnerabilities. Admittedly we may not have
done an extensive job in analyzing these cases, and there may be
cases that are difficult to trigger but can become exploitable with
more efforts. Therefore our estimate of exploitable vulnerabilities
is only a lower bound.
After our analysis, we confirm at least 20 exploitable vulnera-
bilities, presented in Table 4. They range from privilege escalation,
privacy leakage, to clearance of system files, etc. Among them,
11 input validations incorrectly check the caller’s identity using
app-supplied data. One of them is illustrated in §3, as shown in
Figure 5. Another example is that an app-supplied userId is used to
verify the identity of the caller. Furthermore, for one case, we find
a counterpart of native service which is properly protected, while
its Java-level wrapper service is left unprotected. A regular app di-
rectly accessing the native service will be denied, yet accessing the
Java service allows indirect access to the native service, effectively
a confused deputy example.
Besides, one access control is misplaced only in the Android SDK
(and not in Android services). Interestingly, there are 4 other similar
cases that do not seem exploitable at the moment but nevertheless
it is a potential problem.
Class Name
AOSP
Attack Detail
AccessibilityManagerService
NetworkManagerService
AccessibilityManager
Window ManagerService
AccessibilityManagerService
InputManagerService
MediaSessionService
DropBoxManagerService
Atfwd#
Affected Frameworks
Third Part Rom
XM XM HW HW HW SU
P10 S6
•
•
•
◦
◦
•
•
•
•
•
•
•
•
•
5.0 6.0 7.0 7.1 8.0 N2 M2 M9 P9
•
•
◦
◦
•
•
•
•
•
•
•
•
•
•
•
•
•
•
◦
•
•
•
•
•
•
•
•
◦
•
•
•
•
•
•
•
•
•
◦
•
•
•
•
•
•
◦
•
•
•
•
•
•
◦
•
•
•
•
•
•
◦
•
•
•
•
•
•
◦
•
•
•
•
A1
A1
A1
A1
A1
A1
A1
A2
A1
Vendor
Reply
N
N
N
F
N
N
N
N
N
interrupt all accessibility services
modify VPN configurations
expose all hidden interfaces to user
create phishing toast window
send arbitrary accessibility event
send crafted physical key event
send crafted media key event
clear kernel logs
send arbitrary keyword/touch event,
erase sdcard content,etc.
modify the wifi spot connection policy
do factory reset for the pre-install apps
mute the device
add or remove bluetooth device
modify system white list
delete arbitrary file under system dir
obtain the unique id of mobile device
obtain the cell location of mobile device
obtain the public keys stored on the device
allocate arbitrary memory
store arbitrary MMS on the device
⊗
⊗
⊗
⊗
⊗
⊗
⊗
⊗
A1
A1
A1
A1
A1
A1
A1
A3
A3
A1