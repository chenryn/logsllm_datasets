S
e
n
s
i
t
i
v
e
A
P
I
s
i
n
s
a
d
d
r
A
n
a
l
y
z
e
r
I
n
s
t
r
u
c
t
i
o
n
Code
Injection 
Attack
Code
Reuse 
Attack
Detection 
Result
Fig. 2. The architecture of Xede
Xede: Practical Exploit Early Detection
203
Figure 2 shows the architecture of Xede. Xede can be based on a whole-
system emulator like QEMU or a dynamic binary translation based virtualization
platform, such as VirtualBox and VMware workstation. At run-time, the virtu-
alizer feeds the details of executed instruction to Xede. Xede has four major
components. A dynamic information extractor extracts the run-time informa-
tion of the running system, such as the executed instructions, exceptions, and
the loaded modules. That information is passed to the three exploit detection
engines: exploit exception detector, code injection detector, and code reuse detec-
tor. They try to detect exploits with abnormal exceptions, injected instructions,
and characteristic code-reuse control ﬂow patterns, respectively. In the rest of
this section, we will describe each module.
3.2 Dynamic Information Extractor
Xede is based on a system emulator. This allows Xede to monitor every aspect
of the target system. Xede is particularly interested in the details of certain
executed instructions and critical API calls. The emulator passes the executed
instructions and their operands to Xede. If it is a branch instruction, Xede checks
whether the branch target points to a benign code block to detect injected code.
Moreover, Xede uses the virtual machine introspection technology [24] to recon-
struct the high-level API calls. Xede is interested in three types of API functions:
the functions that load a kernel module or a shared library, the functions that
handle exceptions, and the functions that are often misused by code reuse attacks
(e.g., those that change the memory protection). The parameters and return val-
ues of those API calls allow Xede to identify valid code regions, catch abnormal
exceptions, and detect code reuse attacks.
3.3 Exploit Exception Detector
Most commodity operating systems support two exploit mitigation mechanisms:
DEP and ASLR. The former prevents code from being overwritten and data from
being executed. Accordingly, no injected code can be immediately executed. It
must be made executable ﬁrst. The latter randomizes the layout of a process
to prevent the attacker from locating useful gadgets. Many exploits have severe
compatibility issues. They often trigger exceptions when the target software con-
ﬁgurations change. Because of these issues, exploits are signiﬁcantly harder to
be perfect. On the other hand, popular attack targets, such as Microsoft Oﬃce,
Adobe Acrobat and Flash, and Oracle Java virtual machine, all run fairly stable
under normal operations. An exception in these programs may signify an ongoing
attack. Therefore, Xede tries to detect failed exploits by monitoring the excep-
tions caused by these programs. Most existing exploit detection systems focus
solely on detecting successful exploits. Xede instead can detect both successful
and failed exploits.
There are two challenges to this approach: ﬁrst, a process may cause various
benign exceptions during its execution. For example, the kernel may swap out
a part of the process to relieve the memory pressure. If that part is accessed
204
M. Nie et al.
by the process, an exception will be raised by the hardware. Hence, we must be
able to distinguish these benign exceptions from the ones caused by the attacks.
Second, complex commercial programs like Microsoft Oﬃce often try to handle
exceptions if they can to provide a smooth user experience. There are many
diﬀerent ways to handle an exception. This could confuse the exploit detection
systems. Therefore, we need to have a single uniﬁed method to catch exceptions.
There are 23 diﬀerent exceptions in the Windows operating system roughly in the
following ﬁve categories: memory-related, exception-related, debugging-related,
integer-related, and ﬂoating-point-related. Exceptions caused by exploits most
likely fall into the ﬁrst category. For example, they may read or write invalid
data areas or execute illegal instructions. Memory-related exceptions are handled
by the page fault handler in the kernel (i.e. the MmAccessFault function in
Windows), which may further deliver them to the faulting user process.
To address the ﬁrst challenge, we need to separate benign exceptions from
ones caused by attacks. Programs can cause benign exceptions in the following
two scenarios: ﬁrst, the kernel uses demand paging to reduce memory consump-
tion. For example, it may load a part of the process address space lazily from
the disk, or swaps some memory pages out to the disk if they have not been used
for a long time. Second, the user process itself might use memory-related excep-
tions to implement lazy memory allocation. For example, some programs use
large data containers with an unknown length. The memory is only allocated
when the data is accessed and an exception is raised. Microsoft Power Point
2007 uses this approach to manage Object Linking and Embedding (OLE) data.
Xede has to exclude both cases from the exploit detection otherwise there will
be lots of false positives. The ﬁrst case is rather straightforward to exclude. The
page fault handler (MmAccessFault) recognizes that this page fault is caused
by a valid-but-not-present page. It reads the accessed data from the backing
store and returns STATUS SUCCESS to restart the instruction. Exceptions caused
by attacks instead cause MmAccessFault to return STATUS ACCESS VIOLATION.
However, MmAccessFault also returns STATUS ACCESS VIOLATION for the second
case. To solve this problem, we ﬁrst compare the faulting instruction address
against the list of legitimate code. An alert will be raised by Xede if the instruc-
tion is illegitimate. Otherwise, we record the faulting data address expecting
the program to allocate new memory for it. The next time a new data region is
allocated, we check whether it covers the previous faulting data address. If so,
the exception is considered to be benign.
3.4 Code Injection Detector
Even though modern operating systems like Windows enforce data execution
prevention, code injection is still possible. For example, some (old) programs or
libraries have mixed code and data pages. These pages must be made executable
and writable, violating the DEP principle. If a program can dynamically generate
code, its address space could contain writable and executable pages. Moreover,
the memory protection can also be changed by system calls. Xede accordingly
Xede: Practical Exploit Early Detection
205
has a code inject detector, which builds at run-time a list of legitimate code
regions and checks whether an executed instruction is in the list or not.
Legitimate Code Regions: A process consists of many diﬀerent executable
modules. For example, the kernel inserts the standard dynamic loader into the
process to start a new one. The loader then loads the main program together
with its linked shared libraries. The program itself can load additional dynamic
libraries at run-time. Moreover, other processes, such as the input method edi-
tor (IME), can inject code into the process. Xede needs to identify all these
executable modules. To this end, Xede hooks the API functions that may load
code into a process. Their run-time parameters and return values provide the
necessary information for Xede to locate the loaded executable (the program or
a shared library) and know the base address of the executable. Xede then parses
the executable to ﬁnd the oﬀset and size of its code section. The run-time code
location is the base plus the oﬀset. Correspondingly, we also monitor the API
calls that unload an executable and remove the associated code section from the
list of legitimate code regions. This list is also kept up-to-date with dynamically
generated code.
Dynamically Generated Code: Dynamic code generation is a popular
method to improve program performance. For example, modern browsers rely on
just-in-time compiling to speedup JavaScript programs. This makes it possible
to run large complex applications such as Google Maps in the browser. Xede
requires a simple and generic way to recognize dynamically generated code. To
that end, Xede hooks the related API calls to monitor memory allocations and
memory protection changes.
To generate dynamic code, a process can allocate a block of writable-and-
executable memory and then write the code into it, or it can save the code
in the already-allocated writable memory and calls a system API to make the
memory executable. In either case, Xede hooks the memory allocation and mod-
iﬁcation APIs. If a block of memory is made executable, we add it to the list
of legitimate code region list. Likewise, if a block of memory loses its execution
permission or is freed, we remove it from the code region list. Note that these
two methods can only allocate execute memory in the page granularity (4KB for
x86-32). Nevertheless, there are some unsafe programs that generate code using
the executable heap. That is, the whole heap is made writable and executable. It
is thus unnecessary for these programs to explicitly allocate executable memory
pages. They could just use the ordinary malloc and free functions to man-
age executable memory. A simple solution would add the whole heap section
to the executable code region. This leads to a high false negative rate for Xede
because code injected in the heap is mistaken as benign code. To identify the
exact regions of the generated code, we observe that well-designed programs use
NtFlushInstructionCache to ﬂush the instruction cache if new code is gen-
erated or the existing code is modiﬁed (self-modifying code). Xede thus hooks
this function and adds the memory block speciﬁed in its parameters to the
benign code region list (we merge continuous regions to reduce the list size.) On
architectures with relaxed cache consistency mode, the instruction cache must
206
M. Nie et al.
be ﬂushed for the generated/modiﬁed code to take eﬀect. This is not strictly
necessary for the x86 architecture which provides transparent instruction cache
ﬂushing. However, we expect most commercial programs (i.e., the poplar targets
of attacks) to follow the correct practice to ﬂush the cache because Windows
does support several diﬀerent architectures (e.g., ARM).
Region List
...
00401000    xor  eax, eax
...
00401B34    mov  eax, ebx
00401B36    jmp  eax
00620100    mov  edi, edi
...
0063C274    push ebp
0063C275    mov  ebp, esp
0063C277    sub  esp, 32
0063C27A    pushad
...
00728AFF    call  eax
insert a new region
010A8F00    lea eax, [eax]
...
017B38FE    pop eax
017B38FF    ret
Region List
...
00401000    xor  eax, eax
...
00401B34    mov  eax, ebx
00401B36    jmp  eax
00620100    mov  edi, edi
...
0063C274    push ebp
0063C275    mov  ebp, esp
0063C277    sub  esp, 32
0063C27A    pushad
...
00728AFF    call  eax
010A8F00    lea eax, [eax]
...
017B38FE    pop eax
017B38FF    ret
...
...
Fig. 3. Merge adjacent code regions
Code Injection Detection: Xede detects the injected code by checking
whether an executed instruction lies in the list of benign code regions. How-
ever, it is prohibitively time-consuming to check this for every single instruction.
Xede instead validates this property when the control ﬂow is changed. In other
words, it only checks that the destination of each branch instruction is within
the code region list. This coincides with the concept of basic blocks. Each basic
block is a linear sequence of instructions with only one entry point and one exit
point. To guarantee correctness, we must ensure that each basic block lies within
a single region. The code region list we built should not have problems in this
regard if the program is correct. Figure 3 shows how this requirement is fulﬁlled
by merging adjacent blocks of dynamically generated code. In addition, many
basic blocks target another basic block in the same region. Xede thus veriﬁes
whether a branch target is within the current list, and only falls back to the
whole list if that quick check fails.
3.5 Code Reuse Detector
With the wide-spread deployment of DEP and ASLR, code reuse attacks have
become one of the most popular attack vectors. Fine-grained code reuse attacks
include return-oriented programming (ROP) and jump-oriented programming
Xede: Practical Exploit Early Detection
207
(JOP). ROP uses return instructions to chain gadgets, while JOP uses jump
instructions instead. ROP is often used by attackers to bypass DEP. Xede can
detect both ROP and JOP. Xede detects JOP by identifying sequences of gadget-
like instructions. In this paper, we omit the details of the JOP detection, and
focus on the more practical and more popular ROP attacks instead.
In ROP, each gadget ends with a return instruction. When a gadget returns,
it pops the address of the next gadget oﬀ the stack and “returns” to it. A
typical ROP attack consists of 17 to 30 gadgets [9]. This introduces a sequence of
erratic return-based control ﬂow transfers. For example, unlike legitimate return
instructions that jump to a valid return site (i.e., an instruction preceded by a
call instruction), gadgets often do not mimic a return site. As such, one way to
detect ROP is to check whether the return target is preceded by a call instruction.
Unfortunately, this method can be easily bypassed by call-preceded gadgets [7].
On the other hand, normal program execution has (mostly) balanced call and
return pairs, but ROP causes mismatch between them (more returns than calls).
This provides a more precise and reliable method to detect ROP. Speciﬁcally,
Xede maintains a shadow stack for return addresses. It pushes the return address
to the stack when a call instruction is executed, and pops the return address at
the top of the stack and compares it to the actual return address when a return
instruction is executed. This approach can detect ROP attacks because, when an
ROP attack overwrites the stack with its gadget addresses, these addresses are
not added to the shadow stack. However, it cannot be applied to the Windows
platform due to various erratic behaviors of benign programs. We observe all of
the following cases:
1. The program may replace the return address on stack with a completely
diﬀerent return address, causing the call-return mismatch.
2. The exception handling, setjmp/longjmp, and call/pop sequences introduces
extra call instructions without the matching return instructions. For exam-
ple, a program must be compiled as position-independent executable (PIE)
to beneﬁt from ASLR. PIE uses the PC-relative addressing mode to access
its code and data. However, the x86-32 architecture does not natively sup-
port this addressing mode. Compilers instead emulate it by calling the next
instruction and immediately popping the return address oﬀ the stack.
3. The program may adjust the return address on the stack (for unknown rea-
sons), but usually within a few bytes.
As such, return addresses on the stack might be added, removed, and changed
during the normal program execution. Xede needs to handle all these cases to
reduce false positives.
First, to handle added return addresses, we search the shadow stack top-down
for possible matches. If a match is found, we consider this return benign and
pop the excessive returns above it. Note that this will not conﬂict with recursive
functions whose return addresses might appear on the stack many times because
normal recursive functions have matched call and return pairs. Second, to han-
dle removed return addresses, we observe that normal program often removes
only a single extra return address from the stack at a time. Therefore, Xede
208
M. Nie et al.
only considers it an ROP attack if there are N consecutive mismatched return
addresses. According to our observation, an exploit can be accurately captured
if the enhanced shadow stack captures three consecutive mismatched return
addresses. Therefore, in our prototype, we use three for N. A normal real-world
ROP attack usually uses 17 to 30 gadgets [9], say, to arrange gadgets and store
parameters. Under some rare conditions, the attacker might be able to launch
an ROP attack with two gadgets, one to make the injected shellcode executable
(e.g., with the VirtualProtect function, assuming the parameters to this func-
tion happen to be placed.) and the other to execute the shellcode. To defeat
ROP attacks with a very short gadget sequence, Xede hooks 52 most common
APIs used by ROP attacks and checks whether these functions are “called” by
a return instruction. If so, Xede considers it an ROP attack and raises an alert.
Third, to handle changed return addresses, we analyze a number of common
executables and ﬁnd that return addresses mostly change by less than or equal
to 16 bytes. Therefore, if a return address does not match the return address on
the top of the stack, we check whether they are within 16 bytes of each other. If
so, we consider the return address has been changed by the program itself and
do not raise an alert. In addition, to avoid repeating the above time-consuming
heuristics, we add any detected special cases to a white list and quickly check if
a potential mismatch is discovered.
Xede can also detect ROP attacks that use stack pivoting. Stack pivoting
points esp, the top of the stack, to a buﬀer under the attacker’s control, such
as a maliciously constructed heap area. The fake stack facilitates the attacker to
carry out complex ROP attacks. To detect stack pivoting, we verify whether the
esp register points to a valid stack area when we detect a potential mismatch of
return addresses. We can retrieve the base and length of the stack from the thread
control blocks in the guest operating system, such as the following ﬁelds in the
Windows TEB (thread environment block) structure: teb->NtTib->StackBase
and teb->NtTib->StackLimit.
4 Implementation
We have implemented a prototype of Xede based on QEMU, a generic open-
source emulator. QEMU allows us to ﬂexibly instrument instructions/basic
blocks and introspect the guest memory. However, the design of Xede is not tied
to QEMU. It is equally applicable to other hardware emulators (e.g., Bochs) and
binary-translation based virtualization systems (e.g., VMware workstation and
Oracle VirtualBox).
Figure 4 shows the overall architecture of our QEMU-based prototype.
QEMU parses the guest instructions and further translates them into basic
blocks. Basic blocks may further be linked into super blocks (i.e., transla-
tion blocks of QEMU). As previously mentioned, Xede has four major com-
ponents. The dynamic information extractor retrieves the instruction details
and hooks important API calls. As such, each time a new instruction is parsed,
and its information is passed to this module for bookkeeping. The module also
Xede: Practical Exploit Early Detection
209
Guest Memory
CODE:
4000414d: push ebp
4000414e: mov  ebp, esp
40004150: sub  esp, 32
...
DATA:
40000000: 74 20 62 65 41 FF
QEMU
Guest Registers
struct CPUState {
target_ulong regs[CPU_NB_REGS];
target_ulong eip;
target_ulong eflags;
...
};
fetch
instructions
Translation
Translation
Block(TB)
Execution
v
i
r
t
u
a
l
m
a
c
h
i
n
e
i
n
t
r
o
s
p