# 0x01、前言
群里一位老哥发了一个挺有意思的SQL语句，使用like但是没有使用模糊查询,却匹配出了所有字段  
小菜比感觉很新鲜，所以简单进行了一番学习，在学习过程想起一个检测SQL注入的payload：
    and 1 like 1
但是当时并没有跟进学习，所以应该也不算新技巧了
# 0x02、跟进探索学习
首先从字段值的不同的类型来测试
## 0x02.1、int型
id存在且id=1  
id存在且id=2  
**初识端倪：**  
当字段值类型为int时，字段值=后面的表达式为True，后面的值等于1，即效果为id=1，False则等于0，即效果为id=0，mysql中列值从1开始，因此返回为空  
id=3 ，id不存在；进一步验证猜想  
完全验证前面的猜想
## 0x02.2、字符串型
根据前面的测试，意识到可能存在运算符的优先级问题，like 优先级高于 =, 下面两条语句等价
    select * from admin where name=1 like 2;
    select * from admin where name=(1 like 2)
更直观的演示如下  
当字段值类型为字符串时，字段值=后面的表达式为True，效果为 or 1=0 ，False效果则为or 1=1
# 0x03、其他玩法
下面的测试中新增了两行test数据  
还可以用于判断列名是否存在：  
当列名存在时，可通过赋值排除某一项  
# 0x04、进一步发现
同样还是like语句返回True或False，也就是1和0的问题，在列值为字符串类型时，这里能够实现or
1=1效果（也就是只能应用于列值类型为字符串的时候）  
算是一种新型万能密码吧，可看后面的玩法应用
# 0x05、玩法应用
## 0x05.1、检测SQL注入
此处id的字段值为int型（如前面验证的那样，此用法与注入类型无关，而与字段值类型相关）  
id=1%27%20like%201%23  
id=1%27%20like%200%23  
## 0x05.2、新型万能密码
此处username字段值类型字符串，因此like后面的值是可以随意的，只要构造出(xx' like ...)为Fasle即可，如xx' like 0
、xx' like 2、xx' like “c”....  
**类型1：**  
**类型2：**  
'+False# 有同样效果
## 0x05.3、判断列名是否存在
# 0x06、总结
虽然不算新的东西了，但是能够从中发现一些新玩法也算不错。感觉更多的应用于SQL注入检测、盲注当中吧，脑袋瓜不太好，没有发现更多玩法，有其他玩法的师傅们来带带弟弟可以吗，嘤嘤嘤嘤嘤。。。