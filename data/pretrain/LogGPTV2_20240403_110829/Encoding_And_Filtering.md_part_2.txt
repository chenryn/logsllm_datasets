001000 (8) I 011000 (24) Y 101000 (40) o 111000 (56) 4
001001 (9) J 011001 (25) Z 101001 (41) p 111001 (57) 5
001010 (10) K 011010 (26) a 101010 (42) q 111010 (58) 6
001011 (11) L 011011 (27) b 101011 (43) r 111011 (59) 7
001100 (12) M 011100 (28) c 101100 (44) s 111100 (60) 8
001101 (13) N 011101 (29) d 101101 (45) t 111101 (61) 9
001110 (14) O 011110 (30) e 101110 (46) u 111110 (62) +
001111 (15) P 011111 (31) f 101111 (47) v 111111 (63) /
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.34
1.1.1.3.2 Base 64
Base 64 Encoding Scheme
If the total number of bits is not a multiple of 6, then null bits
need to be added until the total is both a multiple of 6 and the
result length a multiple of 4.
Then, if the latest group is 'null' (000000), the respective
encoding value is = but, if the trailing "null groups" are two they
will be encoded as ==.
Letâ€™s check out some examples.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.35
1.1.1.3.2 Base 64
Base 64 Encoding Scheme
To encode the term "HEY" we have:
â–ˆ1st 6 bits
â–ˆ2nd6 bits
â–ˆ3rd6 bits
â–ˆ4th6 bits
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.36
1.1.1.3.2 Base 64
Base 64 Encoding Scheme
To encode the term "HI" we have:
â–ˆ1st 6 bits
â–ˆ2nd6 bits
â–ˆ3rd6 bits
â–ˆPadding
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.37
1.1.1.3.2 Base 64
Base 64 Encoding Scheme
To encode the char "H" we have:
â–ˆ1st 6 bits
â–ˆ2nd6 bits
â–ˆPadding
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.38
1.1.1.3.2 Base 64
Base 64 Encoding Scheme
Naturally, due to its popularity, there are many encoding /
decoding implementations of Base64 in a variety of
different programming languages.
Letâ€™s see some of them.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.39
1.1.1.3.2 Base 64
Base 64 Encoding Scheme: PHP
PHP uses base64_encode and base64_decode functions to
encode/decode data based on MIME Base 64 implementation:
 //Encode
//Decode
https://www.php.net/base64_encode WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.40
https://www.php.net/base64_decode
1.1.1.3.2 Base 64
Base 64 Encoding Scheme: JavaScript
Many browsers can handle Base64 natively through
functions btoa and atob:
window.btoa('encode this string'); //Encode
window.atob('ZW5jb2RlIHRoaXMgc3RyaW5n'); //Decode
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.41
https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
1.1.1.3.2 Base 64
Base 64 Encoding Scheme
It is important to notice that if we want to handle Unicode
strings, then we should encode them before using Base64
functions. For example, in JavaScript this is possible as
follows:
The escapes and encodings are
required to avoid exceptions with
characters out of range. Learn
more here.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.42
https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
1.1.1.4 Unicode Encoding
Unicode (aka ISO/IEC 10646 Universal Character Set) is
the character encoding standard created to enable people
around the world to use computers in any language. It supports
all the world's writing systems.
Because Unicode contains such a large number of characters,
glyphs, numbers, etc., from a security point of view, it is
fascinating because incorrect usage can expose web
applications to possible security attacks. One such example, is
that it can be useful to bypass filters.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.43
1.1.1.4 Unicode Encoding
We are not going to cover the Unicode specifics,
but if you want to have a better background on the
argument, character sets and related topics, the following
link is a great starting point:
http://www.joelonsoftware.com/articles/Unicode.html
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.44
1.1.1.4 Unicode Encoding
There are three ways to map Unicode character points:
â€¢ UTF-8
â€¢ UTF-16
â€¢ UTF-32
UTF means Unicode Transformation Format and the trailing
number indicates the number of bits to represent code
points.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.45
1.1.1.4 Unicode Encoding
Thus, each UTF has a different representation and it is
important to understand how to handle these in our tests. The
following table shows a sample message encoded in the three
different UTF formats.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.46
1.1.1.4 Unicode Encoding
It is also useful to know how Unicode characters are
handled through different implementations like URLs,
HTML, JavaScript, etc. We can see some of them below.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.47
1.1.1.4 Unicode Encoding
Besides the representation of Unicode characters in
multiple encoding types, another interesting aspect is the
interpretation that humans and different implementations
give to some characters.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.48
1.1.1.4 Unicode Encoding
Homoglyph | Visual Spoofing
"In typography, a Homoglyph is one or two or more
characters, or glyphs, with shapes that either appear
identical or cannot be differentiated by quick visual
inspection." [Wikipedia]
An additional classification is:
HOMOGRAPH > a word that looks the same as another word
HOMOGLIPH > a look-alike character used to create homographs
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.49
http://en.wikipedia.org/wiki/Homoglyph
1.1.1.4 Unicode Encoding
Homoglyph | Visual Spoofing
One of the possible attacks with Unicode is called:
Visual SpoÎ¿fing
U+006F U+03BF
LATIN SMALL GREEK SMALL
LETTER O LETTER OMICRON
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.50
1.1.1.4 Unicode Encoding
Homoglyph | Visual Spoofing
If we analyze the characters code points of the string, the
differences between the o and the Î¿ are evident, but for a
human this is not so obvious.
These kind of characters, also known as a confusable,
received special attention from the Unicode Consortium
(TR39). So much so, that they have provided a utility,
whereby given an input string you can see the combinations
that are confusable with it.
http://www.unicode.org/reports/tr39/ WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.51
http://unicode.org/cldr/utility/confusables.jsp
1.1.1.4 Unicode Encoding
Homoglyph | Visual Spoofing - Example: google.com
U+0065 U+0063 U+043E U+03F2
LATIN SMALL LATIN SMALL CYRILLIC SMALL GREEK LUNATE
LETTER E LETTER C LETTER O SIGMA SYMBOL
google.com VS gÎ¿Ð¾glÐµ.Ï²om
U+006F U+043E
U+0435
U+03BF
LATIN SMALL CYRILLIC SMALL
CYRILLIC SMALL
GREEK SMALL
LETTER O LETTER O
LETTER IE
LETTER OMICRON
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.52
1.1.1.4 Unicode Encoding
Homoglyph | Visual Spoofing
To speed the homographs generation, rather than
searching for look-alike characters in Unicode, there is an
interesting application made by Adrian â€œIrongeekâ€
Crenshaw:
Homoglyph Attack Generator
http://www.irongeek.com/homoglyph-attack-generator.php
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.53
1.1.1.4 Unicode Encoding
Homoglyph | Visual Spoofing
This attack generator tool is part of a really interesting
paper where the author explains the abuse of Unicode
characters in order to obfuscate phishing attacks through
the use of Homoglyph and Punycode.
Punycode and Homoglyph Attacks to Obfuscate URLs for Phishing
http://www.irongeek.com/i.php?page=security/out-of-character-use-of-punycode-and-homoglyph-
attacks-to-obfuscate-urls-for-phishing
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.54
1.1.1.4 Unicode Encoding
Computer Interpretations
Another interesting aspect is related to string and character
"evolutions,â€ which occur during normal software
processes transformations.
An example of this is upper and lower casing
transformations, which are described in the upcoming
slides.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.55
1.1.1.4 Unicode Encoding
Computer Interpretations - Example: Censured Feedback
In a feedback page, the application layer performs a
censorship check before storing data in a DB.
There is an input filter that blocks the term EVIL, then
transform the string to lowercase and store it in DB.
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.56
1.1.1.4 Unicode Encoding
Computer Interpretations - Example: Censured Feedback
The input flow could be as follow:
âž² A user sends the following message:
EvÄ°l intent, as usual!
âž² The filter checks for evil strings, but without success.
EvÄ°l != evil
U+0130 (Ä°)
LATIN CAPITAL LETTER I
WITH DOT ABOVE
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.57
1.1.1.4 Unicode Encoding
Computer Interpretations - Example: Censured Feedback
âž² The casing operation is performed [to lowercase]:
evil intent, as usual!
U+0130(Ä°) to lowercase is
U+0069
LATIN SMALL LETTER I
âž² CENSURED BYPASSED
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.58
1.1.1.4 Unicode Encoding
Computer Interpretations - Example: Censured Feedback
This happened because a casing operation is performed in
the application flow AFTER a security check.
Of course, it also works by upper casing characters like
this:
Å¿ S
to upper case is
U+017F
U+0053
LATIN SMALL LETTER LONG S
LATIN CAPITAL LETTER S
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.59
1.1.1.4 Unicode Encoding
Computer Interpretations- Example: Censured Feedback
It turns out, that this type of vulnerable implementation may
allow an attacker to bypass filters. For example, they can
bypass anti cross-site scripting and SQL injection filters and
so forth.
These are things that never happen in real world!
Check them out here:
Creative usernames and Spotify account hijacking
http://labs.spotify.com/2013/06/18/creative-usernames/
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.60
1.1.1.4 Unicode Encoding
Computer Interpretations
There are other ways in which characters and strings can
be transformed by software processes, such as
normalization, canonicalization, best fit mapping, etc.
These are brilliantly summarized and explained by Chris
Weber in his:
Unicode Security Guide
http://websec.github.io/unicode-security-guide/
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.61
1.1.1.4 Unicode Encoding
Computer Interpretations: Mixed Examples
Normalization:
â““â“¡â“žâ“Ÿ â“£â“â“‘â“›â“” becomes drop table
Canonicalization:
â€¹ (U+2039)
becomes
ï¹¤  URL
A simple scenario could be a URL sent over URL, like the
common URL redirects we see daily for surfing web sites:
FORW-URL?is_ok=yes
http://mywebsite/login.php?redirectURL=
In this case, the forwarding URL will be URL-encoded
in order to respect the URL rules:
FORW-URL%3Fis_ok%3Dyes
http://mywebsite/login.php?redirectURL=
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.65
1.1.2 Multiple (De|En) Codings
Example: URL-Encoding > URL
Of course, even if a parameter sent is not a URL, encoding
is still required:
Iâ™¥ðŸ»
http://mywebsite/login.php?param=
In this case, the parameter contains Unicode characters,
hence the URL-encoding will be:
http://mywebsite/login.php?param=I%E2%99%A5%F0%9F%8D%BB
WAPTXv2: Section 1, Module 1 -Caendra Inc. Â© 2020| p.66
1.1.2 Multiple (De|En) Codings
Example: URL-Encoding > URL
Multiple encodings may also occur if the parameter sent is
previously encoded, like the following: