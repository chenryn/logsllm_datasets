 400 600 800 1000 1200 1400 1600 1800 2000 0 5 10 15 20 25 30 35 40 45 50total time (s)induced network latency (ms)POPE, random queries 0 500 1000 1500 2000 2500 3000 3500 4000 4500 0 2 4 6 8 10 12 14 16 18 20total time (s)induced bandwidth limit (Mbps)POPE, random queries15-D- 0001. Any opinions, ﬁndings, conclusions or recommenda-
tions expressed in this material are those of the author(s) and do not
necessarily reﬂect the views of the Assistant Secretary of Defense
for Research and Engineering.
7. REFERENCES
[1] California public employee payroll data, 2014. Source: Transparent
California, http://transparentcalifornia.com/downloads/.
[2] Alok Aggarwal and Jeffrey Scott Vitter. The I/O complexity of
sorting and related problems. In ICALP 1987, volume 267 of LNCS,
pages 467–478. Springer Berlin Heidelberg, 1987.
[3] Rakesh Agrawal, Jerry Kiernan, Ramakrishnan Srikant, and Yirong
Xu. Order-preserving encryption for numeric data. In ACM SIGMOD
2014, pages 563–574, 2004.
[4] Daniel Apon, Jonathan Katz, Elaine Shi, and Aishwarya
Thiruvengadam. Veriﬁable oblivious storage. In PKC 2014, volume
8383 of LNCS, pages 131–148. Springer, Heidelberg, March 2014.
[5] Lars Arge. The buffer tree: A technique for designing batched
external data structures. Algorithmica, 37(1):1–24, 2003.
[6] Michael Ben-Or, Shaﬁ Goldwasser, and Avi Wigderson.
Completeness theorems for non-cryptographic fault-tolerant
distributed computation (extended abstract). In 20th ACM STOC,
pages 1–10, 1988.
[7] Alexandra Boldyreva, Nathan Chenette, Younho Lee, and Adam
O’Neill. Order-preserving symmetric encryption. In
EUROCRYPT 2009, pages 224–241, 2009.
[8] Alexandra Boldyreva, Nathan Chenette, and Adam O’Neill.
Order-preserving encryption revisited: Improved security analysis
and alternative solutions. In CRYPTO 2011, pages 578–595, 2011.
[9] Dan Boneh, Giovanni Di Crescenzo, Rafail Ostrovsky, and Giuseppe
Persiano. Public key encryption with keyword search. In
EUROCRYPT 2004, volume 3027 of LNCS, pages 506–522.
Springer, Heidelberg, May 2004.
[10] Dan Boneh, Kevin Lewi, Mariana Raykova, Amit Sahai, Mark
Zhandry, and Joe Zimmerman. Semantically secure order-revealing
encryption: Multi-input functional encryption without obfuscation.
In EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages
563–594. Springer, Heidelberg, April 2015.
[11] Dan Boneh and Brent Waters. Conjunctive, subset, and range queries
on encrypted data. In TCC 2007, pages 535–554, 2007.
[12] Christoph Bösch, Pieter H. Hartel, Willem Jonker, and Andreas Peter.
A survey of provably secure searchable encryption. ACM Comput.
Surv., 47(2):18:1–18:51, 2014.
[13] David Cash, Stanislaw Jarecki, Charanjit S. Jutla, Hugo Krawczyk,
Marcel-Catalin Rosu, and Michael Steiner. Highly-scalable
searchable symmetric encryption with support for boolean queries. In
CRYPTO 2013, Part I, pages 353–373, 2013.
[14] Fay Chang, Jeffrey Dean, Sanjay Ghemawat, Wilson C. Hsieh,
Deborah A. Wallach, Michael Burrows, Tushar Chandra, Andrew
Fikes, and Robert Gruber. Bigtable: A distributed storage system for
structured data. In OSDI 2006, pages 205–218, 2006.
[15] Nathan Chenette, Kevin Lewi, Stephen A. Weis, and David J. Wu.
Practical order-revealing encryption with limited leakage. In FSE,
pages 474–493. Springer, 2016.
[16] Reza Curtmola, Juan A. Garay, Seny Kamara, and Rafail Ostrovsky.
Searchable symmetric encryption: improved deﬁnitions and efﬁcient
constructions. In ACM CCS 06, pages 79–88, 2006.
[17] Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, Gunavardhan
Kakulapati, Avinash Lakshman, Alex Pilchin, Swaminathan
Sivasubramanian, Peter Vosshall, and Werner Vogels. Dynamo:
Amazon’s highly available key-value store. In SOSP 2007, pages
205–220, 2007.
[18] Srinivas Devadas, Marten van Dijk, Christopher W. Fletcher, Ling
Ren, Elaine Shi, and Daniel Wichs. Onion ORAM: A constant
bandwidth blowup oblivious RAM. Theory of Cryptography
Conference, TCC ’16, 2016.
[19] Sky Faber, Stanislaw Jarecki, Hugo Krawczyk, Quan Nguyen,
Marcel-Catalin Rosu, and Michael Steiner. Rich queries on encrypted
data: Beyond exact matches. In ESORICS 2015, Part II, volume 9327
of LNCS, pages 123–145. Springer, Heidelberg, September 2015.
[20] Sanjam Garg, Craig Gentry, and Shai Halevi. Candidate multilinear
maps from ideal lattices. In EUROCRYPT 2013, volume 7881 of
LNCS, pages 1–17. Springer, Heidelberg, May 2013.
[21] Sanjam Garg, Steve Lu, Rafail Ostrovsky, and Alessandra Scafuro.
Garbled RAM from one-way functions. In 47th ACM STOC, pages
449–458. ACM Press, June 2015.
[22] Craig Gentry. Fully homomorphic encryption using ideal lattices. In
41st ACM STOC, pages 169–178, 2009.
[23] Eu-Jin Goh. Secure indexes. IACR Cryptology ePrint Archive,
2003:216, 2003.
[24] Oded Goldreich. Towards a theory of software protection and
simulation by oblivious RAMs. In 19th ACM STOC, pages 182–194.
ACM Press, May 1987.
[25] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield
nothing but their validity and a methodology of cryptographic
protocol design (extended abstract). In 27th FOCS, 1986.
[26] Michael T. Goodrich, Michael Mitzenmacher, Olga Ohrimenko, and
Roberto Tamassia. Practical oblivious storage. In ACM CODASPY
’12, pages 13–24, 2012.
[27] Florian Hahn and Florian Kerschbaum. Searchable encryption with
secure and efﬁcient updates. In ACM CCS 14, pages 310–320, 2014.
[28] C. A. R. Hoare. Algorithm 64: Quicksort. Commun. ACM, 4(7):321–,
July 1961.
[29] Florian Kerschbaum. Frequency-hiding order-preserving encryption.
In ACM CCS 15, pages 656–667, 2015.
[30] Florian Kerschbaum and Axel Schröpfer. Optimal
average-complexity ideal-security order-preserving encryption. In
ACM CCS 14, pages 275–286, 2014.
[31] Rui Li, Alex X. Liu, Ann L. Wang, and Bezawada Bruhadeshwar.
Fast range query processing with strong privacy protection for cloud
computing. Proc. VLDB Endow., 7(14):1953–1964, October 2014.
[32] Tarik Moataz, Travis Mayberry, and Erik-Oliver Blass. Constant
communication ORAM with small blocksize. In ACM CCS 15, pages
862–873, 2015.
[33] Muhammad Naveed, Seny Kamara, and Charles V. Wright. Inference
attacks on property-preserving encrypted databases. In ACM CCS 15,
2015.
[34] Vasilis Pappas, Fernando Krell, Binh Vo, Vladimir Kolesnikov, Tal
Malkin, Seung Geol Choi, Wesley George, Angelos D. Keromytis,
and Steve Bellovin. Blind Seer: A scalable private DBMS. In 2014
IEEE Symposium on Security and Privacy, pages 359–374, 2014.
[35] Raluca A. Popa, Frank H. Li, and Nickolai Zeldovich. An
ideal-security protocol for order-preserving encoding. In 2013 IEEE
Symposium on Security and Privacy, pages 463–477, 2013.
[36] Raluca A. Popa, Catherine M. S. Redﬁeld, Nickolai Zeldovich, and
Hari Balakrishnan. CryptDB: protecting conﬁdentiality with
encrypted query processing. In SOSP 2011, pages 85–100, 2011.
[37] Elaine Shi, John Bethencourt, Hubert T.-H. Chan, Dawn Xiaodong
Song, and Adrian Perrig. Multi-dimensional range query over
encrypted data. In 2007 IEEE Symposium on Security and Privacy,
pages 350–364, 2007.
[38] Elaine Shi, T.-H. Hubert Chan, Emil Stefanov, and Mingfei Li.
Oblivious RAM with o((log n)3) worst-case cost. In
ASIACRYPT 2011, volume 7073 of LNCS, pages 197–214. Springer,
Heidelberg, December 2011.
[39] Dawn Xiaodong Song, David Wagner, and Adrian Perrig. Practical
techniques for searches on encrypted data. In 2000 IEEE Symposium
on Security and Privacy, pages 44–55, 2000.
[40] Emil Stefanov, Marten van Dijk, Elaine Shi, Christopher W. Fletcher,
Ling Ren, Xiangyao Yu, and Srinivas Devadas. Path ORAM: an
extremely simple oblivious RAM protocol. In ACM CCS 13, pages
299–310. ACM Press, November 2013.
[41] The Apache Software Foundation. Accumulo.
https://accumulo.apache.org/. Accessed: 2015-09-24.
[42] The Apache Software Foundation. Cassandra.
https://cassandra.apache.org/. Accessed: 2015-09-24.
[43] The Apache Software Foundation. Hbase. http://hbase.apache.org/.
Accessed: 2015-09-24.
[44] Xiao Wang, Hubert Chan, and Elaine Shi. Circuit ORAM: On
tightness of the Goldreich-Ostrovsky lower bound. In ACM CCS 15,
pages 850–861, 2015.
[45] D. Westhoff, J. Girao, and M. Acharya. Concealed data aggregation
for reverse multicast trafﬁc in sensor networks: Encryption, key
distribution, and routing adaptation. Mobile Computing, IEEE
Transactions on, 5(10):1417–1431, Oct 2006.
[46] Andrew Chi-Chih Yao. How to generate and exchange secrets
(extended abstract). In 27th FOCS, pages 162–167, 1986.
8. PROOF OF THEOREM 1
Choose n,  so that L = n > 16. The case of Insert is trivial
to analyze: The server never makes comparison requests. So, we
focus on the case of Search.
An alternative split procedure To simplify our analysis, we in-
troduce an alternative version of the leaf splitting procedure which
discards any split that results in very unbalanced partitions. We ar-
gue that such a split will always (in expectation) be worse than our
original split and thus can be used to bound its costs.
Let z = 2L/ log L. We say that a set of L pivot points is z-
balanced if there are z (out of L) pivots such that partitioning a
node of size k using these z pivots only results in partitions that are
each of size at most 2k/z.
A. As in actual Split, choose L pivots uniformly at random and par-
tition the labels according to these pivots.
B. If the L pivots are not z-balanced, throw out the partition and
recurse on the same node.
C. If these L pivots are z-balanced, promote only the z balanced
pivots (instead of the total L) to the parent, partition the labels
and recurse on the node containing the searched label.
We argue that this procedure is worse than the original split both
in the (expected) number of rounds and the (expected) total band-
width (over all m queries). To see this for the number of rounds,
observe that the alternate procedure chooses its partitions in the
same way as the original, but always drops some (or all) of the
pivot points resulting in larger nodes and a deeper recursion to
reach nodes of size L. For the case of bandwidth most of the cost
comes from streaming labels to the client to partition them when
splitting a leaf, which takes O(k) bandwidth for a node of size k.
Now consider a single label x in the tree. This may get moved be-
tween leaf nodes multiple times during the queries, but each time it
is moved the node it lands in is larger if the alternative split proce-
dure is used as argued above, as compared to the actual Split. Thus,
the total cost of all splits over m queries is larger for the alternative
split as it will require repeatedly streaming these larger nodes to the
client.
For the remainder of this proof, we analyze the alternative pro-
cedure for splitting a leaf to bound the costs of the real one.
Round complexity for a single search. The round complexity for
a search can be computed by considering the round complexity for
splitting at internal nodes (case (i) in Section 3.4) and splitting at a
leaf (case (ii) in Section 3.4).
The round complexity for case (i) is asymptotically the same as
the height of the tree. Since the tree is re-balanced such that each
internal node contains at least L/2 labels, the height of the tree is
O(logL n).
As for case (ii), we ﬁrst need to show that L random pivots are
z-balanced with constant probability, so that there is a successful
split after O(1) many unsuccessful ones. To see this, deﬁne an
imaginary sorted list (X1, . . . , Xz) that contains the k input labels
in sorted order, equally partitioned so each Xi has k/z elements.
Note if each Xi contains at least one pivot (out of the chosen L
pivots), then the pivots must be z-balanced; in particular, one can
ﬁnd such pivots by choosing one from each Xi. By the Coupon
Collector’s Problem, the probability that L pivots hit all the Xis is
constant.
Now, note that, by the deﬁnition of z-balanced, after each suc-
cessful split the size of the largest partition is reduced by a factor of
z/2 = L/ log L. Thus, the total number of successful splits needed
and also the total (expected) recursion depth is O(logL/ log L n),
which simpliﬁes to O(logL n) when n ≥ 16. The total round
complexity of the POPE protocol is therefore O(logL n).
Total bandwidth over m search queries.
Height of the tree. First, we need a tighter analysis on the height
of the POPE tree. For this, we start with counting the total number
of labels in the internal nodes. The total number of Split calls over
all m Search operations is at most O(m logL n), since each search
has O(logL n) recursion depth.
Now, consider the sorted labels in non-leaf nodes of the tree.
Each such label is inserted by a Split operation from a leaf, and
each Split inserts at most z labels. Therefore, the total number
of labels stored in the sorted, non-leaf portion of the tree T is
O(zm logL n), which is O(mL log n). Recall the sorted labels
in the non-leaf nodes of the tree form a B-tree with between L and
L/2 labels per node (after rebalancing). Therefore, the maximum
height of the tree is height(T ) = O(cid:0) logL(mL log n)(cid:1).
Sending sorted labels to client. Recall that the round complexity of
a search is O(logL n). Each round of Search involves uploading at
most L labels to serve as partition indices to the client, incurring a
total bandwidth of B(cid:96) = O(mL logL n).
Sending labels in non-leaf buffers to client. In addition, all the la-
bels in buffers along the search path are sent to the client – some
more than once. Observe that labels in buffers only move to a lower
buffer, or laterally from leaf nodes to leaf nodes during Split op-
erations, which means that any label in non-leaf nodes must be
sent to the client at most height(T ) times. Therefore, the ex-
pected total bandwidth for the labels in non-leaf buffers, across all
Search operations, is Bin = O(n · height(T )) = O(n logL m +
n logL(log n)).
Communication cost of splits. Observe that splitting a leaf node
of size k, through all the recursive calls, takes bandwidth O(k)
since O(k + k/z + k/z2 + . . .) = O(k). So, we consider the
total size of all leaf nodes encountered during Search operations
to compute the costs from splits. The worst-case scenario for the
construction is when all n insertions happen before all m searches,
and each search’s splits land in the largest remaining leaf node(s).
Using the alternative split procedure, the largest possible leaf nodes
the search’s splits will land in (counting only successful splits as
rounds) have the following sizes:
most n, etc.
nodes is at most n.
nodes of size at most n · (2/z).
- (Round 1) 1 node of size n. A split lands on this node, splitting it into
- (Round 2) z nodes of size at most n· (2/z). Note the total size of the
- (Round 3) z2 nodes of size at most n · (2/z)2. The total size is at
i=0 zi ≥ m with w = O(logL m), and m largest
leaf nodes are encountered by round w. Since the total size of the
touched nodes in each round is at most n, the total size of the m
largest leaf nodes is bounded by Bs = nw = O(n logL m).
We have (cid:80)w
By summing up B(cid:96), Bin, Bs, we ﬁnd that the total bandwidth
over all (n + m) operations is at most O(mL logL n + n logL m +
n logL(log n)), and Theorem 1 follows.