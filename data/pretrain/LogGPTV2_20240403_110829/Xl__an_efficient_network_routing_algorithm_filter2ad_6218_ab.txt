Tu
Tuv
Tvu
fv
Tv
u
v
Figure 1: The routing process state for a pair of adjacent nodes. The routing process
of each node maintains the forwarding table (fu and fv), internal view (Tu and Tv),
and, for each neighbor, an external view (Tuv and Tvu). The forwarding table and
internal view are private, while the external view Tuv can be atomically updated by u
and atomically read by v. Similarly, the external view Tvu can be atomically updated
by v and atomically read by u.
e(u, v1), . . . , e(u, vk)
Tv1u, . . . , Tvku
current time τ
Update
Algorithm
fu
Tu, Tuv1, . . . , Tuvk
Figure 2: The update algorithm computes the new forwarding table, internal view,
and external views. The inputs to the algorithm are current incident edge weights,
neighbors’ external views, its previous internal view and external views. The algorithm
also has access to the current time.
4.1
Initial View
internal view containing the most recent edge weight information
available to it. For each neighbor, a node also has an external view,
which contains the edge cost information it wants to share with that
neighbor. We denote the internal view of a node u by Tu and the
external view of u for neighbor v by Tuv. For a pair of nodes u and
v, their external views Tuv and Tvu will normally be the same, as
the algorithm attempts to maintain “consensus” of external views.
In describing the algorithm, we assume that the external view Tuv
can be atomically written by u and atomically read by v. The for-
warding table, internal view, and external views together constitute
the state of the routing process (Figure 1).
Updating an external view incurs a communication cost, since
the update must to be sent to corresponding neighbor. Our goal is
to minimize the frequency of external view updates. To simplify
analysis, we assume that external views can be updated even when
the corresponding link has inﬁnite cost. In practice, such updates
would be queued until the link comes back up.
Formally, a view is a function mapping each edge to an edge da-
tum, which is simply a pair of values p and t, written p @ t, meaning
that the edge had weight p at time t. Furthermore, views must only
have correct information, meaning that the edge in question should
have really had cost p at time t. We call this the view invariant. To
avoid writing each deﬁnition twice, once for the internal views and
once for external views, we will use the placeholder subscript 3 to
mean both u and uv. With this convention, the view invariant is:
T3(x, y) = p @ t ⇒ et(x, y) = p.
(V1)
For convenience, let e3(x, y) = p denote the weight of (x, y) ac-
cording to T3, that is, if T3(x, y) = p @ t. But note that e3 is
distinct from the true weight function e written with no subscript.
We say an edge datum p @ t is more recent than datum p(cid:2) @ t(cid:2)
if
t > t(cid:2)
. We will also use the terms less recent and as recent having
the obvious meanings. Finally, we deﬁne a “most recent” operator
“rec.“ Applied to a set of edge data S, rec S is the most recent
datum in S. Formally, if there exists an edge datum p @ t ∈ S
that is more recent than all other p(cid:2) @ t(cid:2) ∈ S, then rec S = p @ t;
otherwise, rec S is undeﬁned.
Let π3(z, w) be a minimum-cost path2 from z to w in T3. Since
the underlying graph is connected, such a path always exists, al-
though the cost may not always have ﬁnite cost. Deﬁne d3(w) =
(cid:4)π3(u, w)(cid:4)3; as before, 3 stands for both u and uv.
The routing algorithm is structured as an iterated state update
algorithm. The process starts in the initial state deﬁned by the initial
views and then repeatedly executes the update algorithm, which
updates the views and forwarding table. We start by deﬁning the
initial view.
2Ties may be broken arbitrarily, as long as the following consis-
tency property is preserved: if aγb is a subsequence of π3(z, w),
then π3(a, b) = aγb.
The initial view deﬁnes the initial state of the routing process,
before it has determined the incident link costs or communicated
with its neighbors.
In other words, it serves as the “base case”
for the algorithm. The initial view, both internal and external, is
deﬁned as
T3(x, y) = ∞ @ 0.
(5)
To satisfy the view invariant (Equation V1), we also deﬁne e0(x, y)
to be ∞ for all (x, y) ∈ E.
4.2 Update Algorithm
The update algorithm computes a new forwarding table as well
as new internal and external views. The input to the algorithm
consists of the incident link costs, the current external views of its
neighbors, and its own previous internal and external views, as well
as the current time, denoted τ (Figure 2).
For the remainder of this section, ﬁx a node u executing the up-
date algorithm. The XL update algorithm has three phases. In the
ﬁrst phase, the algorithm computes a new internal view of u and the
preliminary external views for its neighbors; in the second phase,
it updates the forwarding table using the new internal view; and in
the last phase, it computes new external views for each neighbor.
We now describe these phases. Table 1 summarizes the notation
used in the description and analysis of the routing algorithm.
4.2.1 Phase I: Internal and Prelim. External Views
τ
Time at the start of the iteration (INPUT).
uv
u(w) Maximum allowed relative error for destination w with re-
spect to u (ALGORITHM PARAMETER).
The internal view and external view for v ∈ N (u), re-
T (cid:2)
u, T (cid:2)
spectively, computed in the last iteration of the update al-
gorithm, or, during the ﬁrst iteration, the initial internal and
external views (INPUT).
The external view of v ∈ N (u) (INPUT).
The internal view and external view for v ∈ N (u), respec-
tively, currently being computed (OUTPUT).
The preliminary external view of v ∈ N (u) (Sec-
tion 4.2.1).
The forwarding table of u, currently being computed
(OUTPUT).
Tvu
Tu, Tuv
T ∗
fu
vu
e(x, y) Weight of edge (x, y) in G.
e3(x, y) Weight of edge (x, y) in T3.
(cid:3)α(cid:3), (cid:3)α(cid:3)3
π3(z, w)
d3(w)
Cost of path α in G and T3, respectively.
Shortest path from z to w in T3, with ties broken as con-
sistently (Sections 4.2.2 and 4.2.3).
Cost of the shortest path from u to w in T3; by deﬁnition,
d3(w) = (cid:3)π3(u, w)(cid:3)3 (Section 4.2.3).
Du(w) Minimum distance proxy from u to w (Section 4.4).
Table 1: Notation used in the description and analysis of the update algorithm. The
symbol 3 represents the possible subscripts u or uv in the deﬁnitions.
The ﬁrst phase is concerned with view bookkeeping. Conceptu-
ally, we would like to have a single shared view for each pair of
neighbors. However since the neighbors operate asynchronously,
this would require a synchronization to ensure that the common
view is updated correctly. Instead, we allow each neighbor to have
its own version of this shared view. Neighbors keep their respec-
tive external views in agreement by only updating them with more
recent information and by maintaining the invariant that a node’s
external view is no older than its neighbors. This ensures that the
pair of views converge to the same single view. Thus ﬁrst step in
Phase I is to make sure the local external view is up to date with
respect to the neighbor’s external view for u. We call this updated
view the preliminary external view. For each edge (x, y), the pre-
liminary external view takes the more recent datum of the previous
external view T (cid:2)
T ∗
uv(x, y) = rec
˘
T (cid:2)
uv(x, y), Tvu(x, y)
uv and the neighbor’s external view Tvu:
¯
(6)
The preliminary external view is what the node and it’s neighbor
already agree on, or will agree on after the neighbor performs an
update. It is the starting point for any updates the algorithm decided
to communicate to its neighbor.
Next, we make the internal view the most recent information
about each edge available to u. For edges incident on u, the most
recent information is available locally and is only updated if the
edge weight changes. Formally, for v ∈ N (u),
Tu(u, v) =
eτ (u, v) @ τ
T (cid:2)
u(u, v)
if eτ (u, v) (cid:6)= e(cid:2)
otherwise,
u(u, v),
(7)
(
where “rec” is the “most recent” operator.
For all other edges, the source of the most recent information are
the external views. We collect the most recent datum for each edge.
For all x and y where x (cid:6)= u,
Tu(x, y) = rec
v
T ∗
uv(x, y).
(8)
The following lemma follows by construction.
Lemma 1. The internal view and preliminary external view are
well-deﬁned and satisfy the view invariant.
4.2.2 Phase II: SPT and Forwarding Table
Having computed the internal view, which is the most recent in-
formation available to u about the state of the network, the update
algorithm now computes a shortest-path tree using the internal view
Tu and sets the forwarding table accordingly. This step is identical
to the standard link-state algorithm.
Recall that πu(u, w) is a minimum-cost path from u to w in
Tu, such that the set of all such paths from u forms a shortest-path
tree. The distance from u to w in this tree is du(w), which may
be inﬁnite if no ﬁnite-cost path exists. The forwarding table is now
set according to the computed shortest-path tree: If du(w)  (1 + u(w))Du(w)
´ ∧
´
.
HOT(x, y) = ∃w
Our approach is to greedily update hot edges until Constraint C1 is
satisﬁed. The complete update procedure in given in Algorithm 1.
It remains to show that Algorithm 1 produces an external view
satisfying the Soundness and Completeness constraints above.
Lemma 2. After executing Algorithm 1 (above) the external view
Tuv satisﬁes the View Invariant V1 and Constraints S1, S2, and C1.
4.3 Analysis
We now show that Constraints S1 and S2 produce a sound for-
warding network conﬁguration and Constraint C1 produces a com-
plete conﬁguration with bounded stretch. For the analysis, we as-
sume that each execution of the update algorithm takes a bounded
amount of time; let Δ be this duration. We will also need the fol-
lowing deﬁnition.
An edge (or set of edges) is coherent at a point in time if its
associated external views are the same at that point in time. That
is, an edge (u, v) is coherent at time t if T t
vu. Also, recall
3In fact, minimizing the number of edges that need to be updated to
satisfy Constraint C1 is a hard problem (reduction from Set Cover).
uv = T t
uv(x, y)
end if
if
´ ∧`
Algorithm 1 PHASE III.
1. for all (x, y) ∈ E do
Tuv(x, y) ← T ∗
2.
if euv(x, y)  Δ. If φt(u, w) is a non-empty path that
is both quiet during time interval [t − Δ, t] and coherent at time
t, then φt(u, w) is a ﬁnite path from u to w and (cid:4)φt(u, w)(cid:4)t ≤
dt
u(w).
Lemma 4. Fix a time t > Δ. Let β be a path from u to w. If β is
(i) quiet during [t − Δ, t], and (ii) coherent at time t, then
u(w) ≤ (1 + )(cid:4)β(cid:4)t,
dt
where  = maxx∈β x(w).
Both Lemmas above are still conditioned on coherence. Here we