fying these patterns facilitates abstracting subgraphs in the
provenance graph that corresponds to container spawning and
initialization activity.
Here, we explain the container initialization patterns for
Docker and rkt. For Docker, the initialization pattern is as
follows:
• After receiving gRPC connection from dockerd,
containerd will start a containerd-shim, which is
responsible for starting a new container.
• This containerd-shim process will invoke several
runC processes for initialization.
• One of those runC processes will invoke the unshare
system call and this marks the beginning of the actual
container initialization.
• The runC process calling unshare will clone several
child processes to ﬁnish several initialization tasks in-
cluding setting up /proc, /rootfs, and the network
stack.
• Finally, it will clone a child process and make it execute
the default container application, e.g., bash and apache.
Unlike centralized container engines like Docker, rkt does
not have a daemon process that is responsible for starting a
container. It has a more complex three-stage initialization pat-
tern that begins once rkt is started with speciﬁed parameters
to create a rkt container.
• Stage 0: It will use several instances of the systemd
process to set up different namespaces including PID,
Mount, Network, IPC and UTS.
• Stage 1: It will generate process inside the container
with namespace restriction set up and call chroot to
create a ﬁlesystem jail for this container.
• Stage 2: Finally, it will run the default application on
this process.
3998    30th USENIX Security Symposium
USENIX Association
2.execve1.readdocker-runcpid=19874.forkbashpid=19875.execve3.readbashpid=29.fork6.forkmake.shpid=1998make.shpid=514.execvecatpid=200310.execve11.readmvpid=2002ctr_pid=4subtype:filepath:/usr/bin/docker-runcmake.shpid=3gccpid=2001subtype:filepath: /bin/bash 8.writesubtype:filepath:/lib/x86_64-linux-gnu/libseccomp.so.2.4.112.renamesubtype:filepath:/bin/good_bash15.write7.execveHostbashpid=1998make.shpid=2003make.shpid=2001make.shpid=20022.execve1.readdocker-runcpid=19874.forkbashpid=1987ctr_pid=15.execve3.readbashpid=1998ctr_pid=213.fork9.fork6.forkmake.shpid=1998ctr_pid=214.execvemake.shpid=2003ctr_pid=5catpid=2003ctr_pid=510.execvemake.shpid=2002ctr_pid=411.read12.writemvpid=2002ctr_pid=4subtype:filepath:/usr/bin/docker-runcmake.shpid=2001ctr_pid=38.writegccpid=2001ctr_pid=3subtype:filepath: /var/lib/docker/overlay2/container_hash/merged/bin/bashctr_path: /bin/bash subtype:filepath:/var/lib/docker/overlay2/container_hash/merged/lib/x86_64-linux-gnu/libseccomp.so.2.4.1ctr_path: /lib/x86_64-linux-gnu/libseccomp.so.2.4.1subtype:filepath:/var/lib/docker/overlay2/container_hash/merged/bin/good_bashctr_path: /bin/good_bash15.write7.execveHostContainer1.Container Start2. Execute maliciousscript make.sh3. Compile themalicious library 4. Move defaultbash binary5. Set up the evilbashmake.shpid=413.fork1.Container Start2. Execute maliciousscript make.sh5. Set up the evilbash4. Move defaultbash binary3. Compile themalicious library (a) 1st start without namespace/container awareness(b) 1st start with namespace/container awarenessWe implement those patterns as a SPADE ﬁlter, and it au-
tomatically ﬁnds the starting point of those initialization pat-
terns and attempts to do a backward traversal so the subgraph
corresponding to initialization will be marked.
5 System Evaluation
In this section, we evaluate CLARION by answering the
following questions.
• Q1. Usefulness: How effective is CLARION in dealing
with real-world container microservice attacks?
• Q2. Generality: Are namespace disambiguation strate-
gies implemented by CLARION for performing prove-
nance tracking generally applicable across different con-
tainer engines?
• Q3. Performance: Does CLARION provide an efﬁ-
cient provenance monitoring solution for real-world mi-
croservice deployments?
5.1 Effectiveness Evaluation
To illustrate the effectiveness of CLARION for container-
based provenance and forensic analysis, we evaluate against
exploits of three recent CVEs affecting Docker. Speciﬁcally,
we generate the provenance graphs with and without names-
pace and container awareness to show the capability of our
solution. Then, we compare between the original provenance
graphs generated by SPADE and CLARION.
The CVEs that we selected include CVE 2019-5736
(runC), CVE 2019-14271 (docker-tar) and CVE 2018-
15664 (docker-cp). The ﬁrst two exploits are particularly
detrimental because they can lead to privilege escalation in the
host machine. The third is a race-condition (time-dependent)
which requires multiple tries and some serendipity for suc-
cessful exploitation.
5.1.1 CVE 2019-5736: runC Exploit
runC through 1.0-rc6 (as used in Docker before 18.09.2 and
other platforms like LXC), allows attackers to overwrite the
host runC binary (and consequently obtain host root access)
by leveraging the ability to execute a command as root within
one of these containers: (1) a new container with an attacker-
controlled image, or (2) an existing container, to which the
attacker previously had write access, that can be attached with
docker exec. This occurs because of ﬁle-descriptor mishan-
dling, related to /proc/self/exe [6]. Overwriting runC can
lead to a privilege escalation attack by replacing runC binary
with a backdoor program. The following four steps are used to
demonstrate a successful exploitation using this vulnerability:
1. Create a container where we have gcc installed.
2. Create three ﬁles in this container with the docker cp
command. Those ﬁles are (1) a script (bad_init.sh)
that overwrites the executable (/proc/self/exe) of
the process running this script; (2) a C program
ﬁle (bad_libseccomp.c) that invokes bad_init.sh;
and (3) a shell script
for compiling
bad_libseccomp.c and setting up the bait for runC.
(make.sh)
3. Start this container and execute make.sh that accom-
plishes two goals: (1) replaces the seccomp module with
bad_libseccomp.c. Here seccomp module is a regu-
lar library which will be automatically loaded when an
Ubuntu container starts; (2) replaces the default start-up
process, i.e., the bash shell in Ubuntu containers, with
/proc/self/exe.
4. If and when this container is restarted, runC on the host
loads the malicious seccomp module leading to execu-
tion of the malicious script (bad_init.sh), which over-
writes the parent process, i.e., runC will be overwritten
with the contents of bad_init.sh.
We illustrate the provenance graphs associated with this
exploit in Figures 10, 11. This exploit consists of two starts
of a malicious container. Figure 10 corresponds to the ﬁrst
start and Figure 11 corresponds to the second start.
We see that in the graphs without namespace aware-
ness, the provenance graph fractures completely. Specif-
ically, subgraphs corresponding to essential exploit steps
are fractured, making it challenging for analysts to do
backward and forward tracking given the attack points on
make.sh and bash. Furthermore, ambiguity exists every-
where in those namespace-unaware graphs. Among many
points exposing ambiguity, the ambiguity between two
/lib/x86_64-linux-gnu/libseccmp.so.2.4.1 ﬁle arti-
facts in the second start is signiﬁcant. If we cannot distinguish
between them, we will not be able to understand that a ma-
licious GNU library inside the container is linked with the
runC instance (/proc/self/exe).
CLARION can successfully restore the connection be-
tween essential exploit steps in the namespace-aware prove-
nance graphs and also resolve the associated ambiguity issues,
making it very clear that a malicious container library is linked
by the runC instance (which is anomalous).
5.1.2 CVE 2019-14271: docker-tar Exploit
Docker 19.03.x (prior to 19.03.1) linked against the GNU C
Library (glibc) is vulnerable to code injection attacks, that
may occur when the nsswitch facility dynamically loads a
library inside the container using chroot 5 [5]. This code
injection can affect the library ﬁles on the host and may be
used to trigger privilege-escalation attacks.
We exploit this privilege-escalation vulnerability using
docker-tar, a helper process spawned by the Docker engine
that obviates the need to manually resolve symlinks in the
container ﬁlesystem. First, docker-tar uses the chroot com-
mand to change its root to the container’s root. This is done
so that all symlinks are resolved relative to the container’s
5The assumption here is that libraries within the containers are untrusted
from the perspective of the host.
USENIX Association
30th USENIX Security Symposium    3999
Figure 11: CVE 2019-5736: Provenance graph for 2nd start without (top) and with (bottom) namespace/container awareness
root, preventing any ambiguities. After running chroot,
docker-tar attempts to link with several standard glibc
libraries, which induces the vulnerability. When docker-tar
attempts to link with these libraries, it will instead link the
library ﬁles inside the container. However, a malicious image
could inject code inside those library ﬁles, such that the mali-
cious code executes as part of the docker-tar process since
they are linked by docker-tar. Speciﬁcally, two steps are
required to demonstrate exploitation of this vulnerability:
1. We modify libnss_files.so in the container image by
a malicious script modify.sh, an example library linked
with docker-tar, using a code injection attack such that
it includes additional code to execute a malicious script,
called breakout.sh, that sets up a backdoor on the host
using netcat.
2. When we then run the docker-tar command from a
container using this image, the docker cp command is
executed within the container that copies the library ﬁle
to the host, leading to an open backdoor on the host.
Provenance graphs for comparison are shown in Figure
12. Similar to the ﬁrst exploit, the namespace-unaware prove-
nance graph is fractured. We see that bash process 2098 forked
a child process but does nothing due to PID namespace frac-
turing. In addition, this graph implies that the libnss library
on the host was compromised, which is incorrect. In contrast,
CLARION eliminates graph fracturing and provides a sound
and clear understanding of how this attack is initiated from
inside the container. Speciﬁcally, (1) CLARION marks the
boundary of containers so we know the starting malicious
script modify.sh is run inside the container; and (2) CLAR-
ION provides the mapped path for the library ﬁle so we know
the compromised libnss_files.so is inside the container.
5.1.3 CVE 2018-15664: Symlink TOCTOU Exploit
In Docker (versions <= 18.06.1-ce-rc2), API endpoints be-
hind the docker cp command are vulnerable to a symlink-
exchange attack with Directory Traversal. This gives attack-
ers arbitrary read-write access to the host ﬁlesystem with
root privileges, because daemon/archive.go does not do
archive operations on a frozen ﬁlesystem (or from within a
chroot) [4].
When docker cp attempts to use a symlink from the con-
tainer directory, it must ﬁnd the absolute pathname ﬁle or di-
rectory in the context of the container ﬁlesystem. Failing to do
so causes the symlink to be resolved in the host’s ﬁlesystem,
which allows symlinks created inside the container to affect
ﬁles outside the container. When a user executes docker cp
on a container ﬁlesystem, the Docker daemon process ﬁrst ex-
ecutes a FollowSymlinkInScope() function, which returns
the non-symlink path to the ﬁle/directory. Only after ﬁnding
the actual path for both source and destination ﬁlenames does
docker cp start copying ﬁles. One problem that arises from
this process is that there is no guarantee that the ﬁlesystem
won’t change between running FollowSymlinkInScope()
and copying the ﬁles. Here, a possible attack utilizing a Time-
of-Check to Time-of-Use (TOCTOU) race condition is to
have a process inside the container apply a symlink right af-
ter Docker veriﬁes the symlink path, and right before docker
begins writing the ﬁle. When docker uses the ﬁlename it re-
solved earlier, it will traverse the symlink to a ﬁle on the host
4000    30th USENIX Security Symposium
USENIX Association
1.read3.execvedocker-runcpid=21994.read2.read6.forkbash(proc/self/exe)pid=21997.execvebashpid=28.forkgood_bashpid=22049.execvegood_bashpid=3bad_initpid=2205subtype:filepath: /usr/bin/docker-runc5.readsubtype:filepath: /bin/bash subtype:filepath: /lib/x86_64-linux-gnu/libseccomp.so.2.4.110.writesubtype:filepath: /proc/exe/fd/3Hostbashpid=2204good_bashpid=22051.read5.read3.execvedocker-runcpid=21992.read6.forkbash(/proc/self/exe)pid=2199ctr_pid=17.execvebashpid=2204ctr_pid=28.forkgood_bashpid=2204ctr_pid=29.execvegood_bashpid=2205ctr_pid=3bad_initpid=2205ctr_pid=3subtype:filepath: /usr/bin/docker-runcinode=261968subtype:filepath: /var/lib/docker/overlay2/container_hash/merged/lib/x86_64-linux-gnu/libseccomp.so.2.4.1ctr_path: /lib/x86_64-linux-gnu/libseccomp.so.2.4.14.readsubtype:filepath: /var/lib/docker/overlay2/container_hash/merged/bin/bashctr_path: /bin/bash subtype:filepath:/lib/x86_64-linux-gnu/libseccomp.so.2.4.110.writesubtype:filepath: /proc/exe/fd/3inode=261968HostContainer1.Container Start, The evil bash is executed2.Trigger bad_init script tomodify /proc/exe (runC binary)(a) 2nd start without namespace/container awareness(b) 2nd start with namespace/container awareness1.Container Start, The evil bash is executed2.Trigger bad_init script to modify /proc/exe (runCbinary)Figure 12: CVE 2019-14271: Provenance graph for the docker-tar exploit without (top) and with (bottom) namespace/container
awareness
machine.
Through this exploit, a container process could potentially
overwrite any ﬁle in the container when the host tries to copy
a ﬁle into that container. This includes crucial system ﬁles
such as password and user records. In our example, we use
the four steps shown below in the order when attackers win
the race condition to reproduce the exploit:
1. Host tries to copy a ﬁle w00t_w00t_im_a_flag from
the container’s ﬁlesystem to the host system by running
docker cp.
2. Docker engine resolves both source and destination ﬁle-
names, traversing any necessary symlinks.
3. Malicious process inside the container creates an-
other directory (stash_path), applies a symlink to
/, and performs a rename exchange of the origi-
nal directory containing w00t_w00t_im_a_flag, i.e.,
totally_safe_path, with stash_path.
4. Docker engine, uses the ﬁlename resolved at Step 2, and
performs a read of the container ﬁlename, and writes the
data to the host ﬁlesystem.
Once the malicious process wins the race condition (Step
3), the symlink will be resolved in the host’s ﬁlesystem and
docker cp ends up copying the w00t_w00t_im_a_flag in
the host, rather than the one inside the container. For this ex-
ploit, the provenance generated by CLARION graph shown
in Figure 13 does not show signiﬁcant difference from the
namespace-unaware graph, because there is only one mali-
cious process which will be run from at container start. Yet,
without namespace awareness, the analyst will not be able to
know that the key malicious process, i.e., symlink_swap, is
running inside a container.
5.2 Cross-container Evaluation
To demonstrate that our solution is generic to several pop-
ular container engines together with deeper insights about
provenance graph statistics, we select LXC (a classical con-
tainer engine), rkt (a container engine with the second highest
market share), Mesos and Docker for evaluation.
5.2.1
We show the provenance graphs for the initialization of a
hello-world container within each container engine in Fig-
ures 14, 15, and 16.
Initialization Graphs
We ﬁnd the initialization provenance graphs for the three
different container engines to be clear and intuitive. They
show that even when varying initialization routines are em-
ployed by different container engines, (e.g., rkt doesn’t start
the container before it ﬁnishes changing root path, while the
other two use the ﬁrst process inside the container), our ini-
tialization patterns always detect them accurately. Moreover,
CLARION successfully summarizes the container boundary
for all three container engines.
5.2.2 Quantitative Provenance Graph Results
We measured the impact of CLARION on provenance graph
statistics to quantitatively assess the implications of names-
pace awareness with various container engines. We selected
ﬁve popular Docker images that cover typical use cases in
microservices including the base OS (ubuntu), a popular
database (redis), a continuous integration server (jenkins) and
a web server (nginx). We ran those images on three popu-
USENIX Association
30th USENIX Security Symposium    4001
1.read8.read5.forkdocker-tarpid=21996.execvedocker-tarpid=22309.execve7.forkbashpid=223010.forkbreakout.shpid=225611.execvebreakout.shpid=228112.acceptncpid=2281subtype:filepath:/var/lib/docker/overlay2/container_hash/merged/lib/x86_64-linux-gnu/libnss_files-2.23.soctr_path: /lib/x86_64-linux-gnu/libnss_files-2.23.sosubtype:filepath: /var/lib/docker/overlay2/container_hash/merged/lib/breakout.shctr_path: /lib/breakout.shHost(10.0.2.15)bashpid=2256ctr_laddr:0.0.0.0ctr_lport:8000host_laddr:10.0.2.5host_lport:8000raddr: N/Arport: N/AContainer4.read8.read5.forkdocker-tarpid=21996.execvedocker-tarpid=22309.execve7.forkbashpid=223010.forkbreakout.shpid=225611.execvebreakout.shpid=228112.acceptncpid=2281subtype:filepath:/lib/x86_64-linux-gnu/libnss_files-2.23.sosubtype:filepath:/lib/breakout.shHost(10.0.2.15)bashpid=2256laddr:0.0.0.0lport:8000raddr: N/Arport: N/A2.Docker-tar loads the malicious gnu library3.Execute breakout.sh 4. Set up backdoor (b) with namespace/container awareness2.Docker-tar loads the malicious gnu library3.Execute breakout.sh 4. Set up backdoor (a) without namespace/container awarenessbashpid=20982.execvebashpid=21233.writemodify.shpid=21231.forkbashpid=31. Make libnss library evilbashpid=2098ctr_pid=1bashpid=21993.write2.execvemodify.shpid=21231.forkmodify.shpid=2123ctr_pid=31. Make libnsslibrary evilFigure 13: CVE2018-15664: docker cp race condition exploit without and with namespace/container awareness. Steps 1 and 2
are attempts to establish the symlink between the stash path inside the container and the root path on the host. Steps 3 and 4
represent the renaming exchange between the symlinked stach path and the path of the ﬁle to be copied. Steps 5-7 show that
dockerd didn’t resolve the correct path and ultimately copies the incorrect ﬁle.
Figure 14: Initialization of a hello-world rkt container
lar container engines: Docker, rkt and Mesos. The results
are reported in Tables 7, 8, and 9, respectively. For each im-
age, we collected the behavior from container initialization
to stable operation. In addition, we used two advanced con-
ﬁgurations for nginx to highlight the effect of namespace
awareness. MT-4 indicates that we ran the nginx server with
worker_process=4, while MC-4 means we ran four nginx con-
tainers concurrently.
We see that in most cases, the total count of vertices and
edges are not signiﬁcantly impacted by the addition of names-
pace awareness. This is because it is possible for namespace
unawareness to add or reduce vertices/edges, depending on the
workload. For example, process cloning leads to more spuri-
ous vertices while false dependencies due to shared ﬁlenames
in the mount namespace results in fewer vertices. Generally
speaking, fewer vertices and more edges will be a better result
because the provenance graph suffers from less fracturing.
Figure 15: Initialization of a hello-world Docker container
Hence, we count the (lost/extra) error vertices/edges in two
common cases, i.e., process creation and ﬁle access, causing
fragmentation and ambiguities. Though this may not cover
all cases causing error vertices/edges, we believe it provides a
useful lower bound to illustrate the severity of the soundness
issue. Finally, in the case of components, we can observe
signiﬁcant differences when namespace awareness is turned
on. Speciﬁcally, in nginx(MC-4) for rkt, we can see the com-
ponents of SPADE are doubled in comparison to CLARION,
meaning the corresponding provenance graph fractures sig-
niﬁcantly. This is because the four-container setting has more
workload inside the containers and so the subgraph inside