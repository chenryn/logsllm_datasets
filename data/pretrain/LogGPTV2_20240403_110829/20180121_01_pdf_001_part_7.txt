• 要求高速响应图式搜索需求
RDS PG
• ltree数据类型
• 多表JOIN
• 递归查询
– CTE
• 数组
– key1:{val1, val2, val3, ...}
– GIN索引
– 包含、相交
– = any(array)
案例 知识图谱
-
点 边,jsonb 点
int int
多边合并到
jsonb
API:
N度搜索；
最短路径；
流式返回；
百亿关系网、
3层关系查询、
2.5毫秒
适用场景
• 广度搜索、深度搜索（不含权重）
• 好友关系系统
• 好友推荐系统
• 陌生人交友
• 知识图谱
不适用
• 风控
AgensGraph
• http://bitnine.net/agensgraph/
• 专业图数据库 base on PG
• pgrouting插件
• http://pgrouting.org/
案例 架构设计、代码、实操手册
-
• 图式搜索 案例链接 (阿里云RDS PG 内置plv8语言)
– https://github.com/digoal/blog/blob/master/201708/20170801_01.md
– https://github.com/digoal/blog/blob/master/201612/20161213_01.md • 数组
– https://github.com/digoal/blog/blob/master/201801/20180102_04.md – https://github.com/digoal/blog/blob/master/201711/20171107_18.md
– https://github.com/digoal/blog/blob/master/201804/20180408_03.md – https://github.com/digoal/blog/blob/master/201711/20171107_19.md
• ltree 树类型 – https://github.com/digoal/blog/blob/master/201711/20171107_20.md
– https://github.com/digoal/blog/blob/master/201105/20110527_01.md
– https://github.com/digoal/blog/blob/master/201709/20170923_01.md
• 递归查询
– https://github.com/digoal/blog/blob/master/201705/20170519_01.md
– https://github.com/digoal/blog/blob/master/201703/20170324_01.md
– https://github.com/digoal/blog/blob/master/201612/20161201_01.md
– https://github.com/digoal/blog/blob/master/201611/20161128_02.md
– https://github.com/digoal/blog/blob/master/201611/20161128_01.md
– https://github.com/digoal/blog/blob/master/201607/20160725_01.md
– https://github.com/digoal/blog/blob/master/201607/20160723_01.md
– https://github.com/digoal/blog/blob/master/201604/20160405_01.md
– https://github.com/digoal/blog/blob/master/201512/20151221_02.md
– https://github.com/digoal/blog/blob/master/201210/20121009_01.md
– https://github.com/digoal/blog/blob/master/201209/20120914_01.md
• JSON, plv8
– https://github.com/plv8/plv8/blob/master/doc/plv8.md#scalar-function-calls
订阅、单元化、容灾、多写
case9( )
• 线上RDS PG
• 逻辑订阅、或物理订阅 到用户端PG
用户端容灾、只读
审计、测试库
全量订阅
内置HA、容灾
数据延迟：ms级
不论事务大小
部分订阅
与大事务相关
全网数据 某个B端相关数据
RDS PostgreSQL 部分数据
案例 架构设计、代码、实操手册
-
• 订阅功能(单元化)
– https://github.com/digoal/blog/blob/master/201702/20170227_01.md
– https://github.com/digoal/blog/blob/master/201707/20170711_01.md
跨域、跨库、
case 10 ( sharding)
• 传统企业数据库上云，突破单库容量限制
– 多库组集群、相互可访问、可写、可同步。
– 功能点：FDW(外部表、远程表)、DBLINK、匿名、逻辑订阅。
PG PG
FDW外部表：
所有DB对等
访问异库表，犹如访问本地表，没有限制。
支持读写、JOIN等，支持PUSHDOWN算子。
APP
偶尔访问的异地数据，采用dblink、或fdw，简化逻辑。
逻辑订阅（单元化）：
经常访问的异地数据，使用订阅功能订阅到本地。
PG
OSS 无限对象存储：
用于冷存储，支持多实例共享访问。
库与库不再孤立，形成整体。
OSS 无限对象存储
sharding1 (FDW)
APP
C库
A库
父表
父表
子表1
子表2 子表3
本地
子表2 子表3
外表 外表 子表1
外表 本地
外表
子表1 子表2 子表3
外表 本地 外表
继承、自动数据路由、支持跨库访问、
B库 父表 PUSH DOWN(JOIN、sort、where、UDF。。。)
sharding2 (Citus)
shard table,
reference table
https://github.com/digoal/blog/blob/master/201808/20180824_02.md
1\choose column
2\choose distribute policy
3\set shard count
4\choose colocate group
5\shard hash value range
6\balance to worker node
sharding2 (citus)
sharding2 (citus)
sharding2 (citus)
案例 架构设计、代码、实操手册
-
• PG Sharding
– https://github.com/digoal/blog/blob/master/201808/20180824_02.md
– https://github.com/digoal/blog/blob/master/201809/20180905_01.md
• FDW
– 总览: https://wiki.postgresql.org/wiki/Fdw
– 文件fdw: https://www.postgresql.org/docs/10/static/file-fdw.html
– PG fdw: https://www.postgresql.org/docs/10/static/postgres-fdw.html
– MySQL fdw: https://github.com/EnterpriseDB/mysql_fdw
– Oracle FDW: https://pgxn.org/dist/oracle_fdw/
– SQL Server FDW: https://pgxn.org/dist/tds_fdw/
• DBLINK
– https://www.postgresql.org/docs/10/static/dblink.html
• 订阅功能(单元化)
– https://github.com/digoal/blog/blob/master/201702/20170227_01.md
– https://github.com/digoal/blog/blob/master/201707/20170711_01.md
流式处理 阅后即焚
case11 ( - )
流式处理 阅后即焚
case11 ( - )
• 流式处理，高并发写入，快速消费处理。
• 处理后的数据被删除。
• 要求：
高效、可靠、流
式、事务
– 数据快速写入
– 数据写入后必须持久化
– 快速消费被写入的记录（例如订阅，或者用于业务
上的流式计算，计算结果保留）
– 消费和计算必须在一个事务完成
流式处理 阅后即焚
-
函数计算:
plpgsql,
plpython,
pljava
物联网数据、
FEED数据
JSON非结构
1、写入确保持久
化
化。
2、消费、处理在
事务中完成
为什么需要流计算
• 实时分析需求
– 大查询的时效性
• 过滤有效数据
– 实时数据清洗
• 预警需求
– 实时数据预警，电子围栏、物联网异常指标、监控
系统
流计算和数据库有关系吗？
流计算原理
PostgreSQL
方法1、pipelineDB (批处理，低延迟，大吞吐，100+万行/s)
方法2、rule、trigger (实时处理，实时，小吞吐，单步写30+万行/s，批量写100+万行/s)
方法3、insert on conflict (实时处理，实时，小吞吐，单步写30+万行/s ，批量写100+万行/s)
方法4、阅后即焚 (批处理，低延迟，大吞吐，100+万行/s)
案例 流式预警
1-
• 根据规则发现数据异常，并通知应用程序
• 传统手段
– 异步查询、实效性较差、重复劳动较多
• 流计算手段
– 实时或异步、异步消息通道
案例 流式预警
1-
monitor
被监控机
agent
有枣没枣打
三杆子
被监控机 select xxx from xxx
agent where 指标字段>=阈值
传统
and xxxx
方法 order by xxx;
问题：
1. 索引巨大、
被监控机
2. 存在大量无用功查询。
agent
案例 流式预警
1-
monitor
被监控机
agent
有枣没枣打
三杆子
被监控机
agent
create index idx on table (字段) where 阈值>xxx;
只有异常数据才建索引。
被监控机 partial index
agent
案例 流式预警
1-
Syntax:
NOTIFY channel [ , payload ]
Syntax: monitor
LISTEN channel listen异常
被监控机
agent
消除索引、
被监控机 消除无用功。
agent
notify异常
内置MQ（消息
队列）功能。
定义规则
被监控机
agent 流式计算
案例 流式预警
1-
• create table tbl(sid int, content jsonb);
• create or replace function monitor(jsonb) returns boolean as $$
• declare
• begin
– if xxx then return true; --条件1
– else if xxx then return true; --条件2，
– else if .....; --条件N
– else return false;
– end if;
• end;
• $$ language plpgsql strict;
• create or replace rule r1 as on insert to tbl do {also|instead} select pg_notify('channel_name', (NEW.content)::text) where
monitor(NEW.content);
– 可落明细、可不落明细、可按需落明细，实时压缩(例如5分钟落一个明细点，其他只落告警点)。
• client:
– listen 'channel_name';
案例 流式预警
1-
传统
吞吐较小、性价比低
方法
百亿+/天 吞吐
案例 流式统计
2 - (avg,count,min,max,sum)
• https://github.com/digoal/blog/blob/master/201711/20171123_02.md
业务举例：
实时报表、实时在线
数、实时大屏监控、
实时UV估算
实时统计
结果
FEED数据
案例 流式统计
2 - (avg,count,min,max,sum)
• https://github.com/digoal/blog/blob/master/201711/20171123_02.md
案例 流式统计
2 - (avg,count,min,max,sum)
• https://github.com/digoal/blog/blob/master/201711/20171123_02.md
分区+批量写入
336万 行/s
案例 流式统计
2 - (avg,count,min,max,sum)
• https://github.com/digoal/blog/blob/master/201711/20171123_02.md
多维流式计算
• 1、定义明细表
• create table tbl(c1 int not null, c2 int not null, c3 int not null, c4 int not null, c5 int not null);
• 2、定义每个维度的目标统计表
• create table cv1_tbl (c1 int primary key, cnt int8 default 1);
• create table cv2_tbl (c2 int, c3 int, c5 int, sum_v float8 default 0, cnt int8 default 1, primary key (c2,c3)) ;
• .....
• 其他维度
• 3、定义维度表的insert on conflict SQL
• insert into cv1_tbl (c1) values (NEW.c1) on conflict (c1) do update set cnt=cv1_tbl.cnt+1;
• insert into cv2_tbl (c2,c3,c5) values (NEW.c2, NEW.c3, NEW.c5) on conflict (c2,c3) do update set cnt=cv2_tbl.cnt+1,
sum_v=case cv2_tbl.cnt when 1 then cv2_tbl.c5+excluded.c5 else cv2_tbl.sum_v+excluded.c5 end;
• 4、定义明细表trigger或rule，顺序调用insert on conflict 写入多个维度表
• create rule r1 as on insert to tbl do {instead|also} insert into cv1_tbl (c1) values (NEW.c1) on conflict (c1) do
update set cnt=cv1_tbl.cnt+1;
• create rule r2 as on insert to tbl do {instead|also} insert into cv2_tbl (c2,c3,c5) values (NEW.c2, NEW.c3, NEW.c5)
on conflict (c2,c3) do update set cnt=cv2_tbl.cnt+1, sum_v=case cv2_tbl.cnt when 1 then cv2_tbl.c5+excluded.c5
else cv2_tbl.sum_v+excluded.c5 end;
并行、多维、流式计算
• 1、定义明细分区表
• 2、定义每个维度的目标统计表
• 3、定义维度表的 insert on conflict SQL
• 4、定义明细分区表 trigger或 rule，顺序调用
写入多个维度表
insert on conflict
案例 流式概率计算
3-
• http://docs.pipelinedb.com/probabilistic.html
– bloom filter: distinct概率判定, select distinct (...) 快速判
断
– count-min sketch: per element's freq 概率 select
col,count(*) group by col 快速统计+判定
– filtered-space saving top-k: element's bucket & freq 概率
– HLL: COUNT(DISTINCT ...)
– T-Digest: Rank base statistic. percentile_cont 水位值.
案例 流式实时估算
3-
• https://github.com/digoal/blog/blob/master/201711/20171123_02.md
• HLL插件
• create extension hll;
• create table tbl (
– grpid int, userid int, dt date,
– cnt int8 default 1,
– hll_userid hll default hll_empty(), -- 估算字段
– primary key (grpid, dt)
– );