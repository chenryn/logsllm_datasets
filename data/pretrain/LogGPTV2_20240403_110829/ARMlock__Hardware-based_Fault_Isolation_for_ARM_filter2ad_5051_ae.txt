SFI is designed to isolate untrusted modules in dedicated sand-
boxes to prevent them from accessing other domains’ memory and
escaping from the conﬁnement. To this end, SFI systems often
statically or dynamically rewrite the untrusted code to insert inline
reference monitors to control the memory accessible. However,
because memory reads are usually far more frequent than writes,
some of these systems check only memory writes, rendering them
unsuitable for applications such as untrusted native browser plug-
ins (e.g., the attacker could search the browser memory for bank
accounts.) The initial SFI system [43] and PittSFIeld [21] reserve
dedicated register(s) for the generated inline monitors. This ap-
proach has its limitation on the 32-bit x86 architecture due to its
very limited number of general registers.
In contrast, NaCl for
x86 [46] and VX32 [9] leverage the hardware segmentation of
x86 to conﬁne memory accesses (segmentation has mostly been
removed from the 64-bit x86 architecture.) ARM does not have
the similar segmentation support. ARMlock instead leverages the
memory domain feature to sandbox both memory read and write.
Binary rewriting based SFI inserts inline reference monitors to con-
ﬁne memory accesses.
It is important to prevent these monitors
from being bypassed by the untrusted code. This requires some
level of control ﬂow integrity [2] so that the untrusted code cannot
jump over the monitor to execute unconﬁned memory access in-
structions. To this end, PittSFIeld and NaCl [33, 46] implement a
chunk-based (coarse-grained) control ﬂow integrity. A chunk con-
tains the monitor and its related memory access instructions. Con-
trol transfer instructions can only target the beginning of a code
chunk. As such, those monitors cannot be bypassed. VX32 is based
on the dynamic binary translation and has a diﬀerent strategy: it in-
tercepts the real jump target at run-time and forbid any attempt to
bypass the monitors. ARMlock does not need to ensure control
ﬂow integrity of the sandboxed code because the processor guar-
antees that it cannot access memory outside its domain. In fact,
ARMlock imposes no constraints on the untrusted module. For
example, the module can use self-modifying code or just-in-time
compiling if necessary.
ARMor [49] and NaCl for ARM [33] are two closely-related sys-
tems. ARMor is a recent system to provide SFI for ARM applica-
tions. It leverages Diablo [27], a link time binary rewriting frame-
work, to insert inline monitors into the untrusted binary. A moni-
tor needs to be inserted for each memory access and control trans-
fer instruction. It thus has a high performance overhead (almost
2x slow-down for computation-intensive tasks). Even though its
performance could be optimized [48], ARMlock has much smaller
performance overhead, particularly for the sandboxed code. NaCl
for ARM [33] uses a customized compiler to mask out high bits of
memory addresses and jump targets so that the accessible memory
is limited to the lower 1GB. This limits the application of NaCl
for ARM to a single sandbox with a ﬁxed address space. Our sys-
tem does not have such limitation and can also support advanced
features such as JIT. Another closely related system is TLR [30],
which leverages ARM TrustZone to build a trusted language run-
time for mobile applications. TLR can signiﬁcantly reduce the
TCB of an open-source .NET implementation. Compared to TLR,
ARMlock is a generic SFI system based on the light-weight mem-
ory domain support in ARM. Moreover, TrustZone provides a se-
cure world in addition to a normal world. It’s a better ﬁt to isolate
diﬀerent applications (as demonstrated in the TLR system [30]) or
OSes than to isolate modules in an application. For example, it
might be diﬃcult for TrustZone to support signals.
Since its introduction [43], SFI has been adopted by many sys-
tems for diﬀerent purposes. Robusta [37] uses SFI to isolate native
code of the Java virtual machine so that vulnerabilities in the na-
tive code cannot compromise the Java VM or the system. Program
Shepherding [17] relies on dynamic binary translation to moni-
tor control ﬂow transfers at run-time and enforce security policies.
There is also a long stream of research to use SFI or similar tech-
nologies to secure device drivers. For example, VINO [34], SFI-
Minix [14], BGI [5], XFI [8] and LXFI [20] leverage SFI to isolate
kernel extensions (or device drivers) from the main kernel. ARM-
lock is a fault isolation system for user-space applications. Cur-
rently, it cannot be used to isolate kernel mode code yet. We leave
it as a future work to extend our system for this purpose.
At last, ARMlock leverages a feature in the page table to split
the address space into several domains. Page table has often been
used for security purposes. For example, Nooks [39] maintains a
copy of kernel page table for device drivers which only grants read
access to the kernel memory so that misbehaving device drivers
cannot directly change kernel data. SIM [36] protects the active
in-VM monitor from the untrusted kernel in a separated address
space enforced by the hypervisor. HyperLock [44] is a system that
isolates the KVM hypervisor from the host kernel. It allocates a
separate page table for KVM that can only be changed by KVM
via explicit requests. A compromised KVM thus cannot modify
the host OS memory or corrupt the whole system. ARMlock does
not use separate page tables for untrusted modules. It instead relies
on a more eﬃcient hardware feature.
7. SUMMARY
In this paper, we have presented the design and implementation
of ARMlock, a hardware-based fault isolation system for the ARM
architecture. ARMlock uniquely leverages the memory domain
feature in the commodity ARM processors to create multiple sand-
boxes for untrusted modules. We have implemented a prototype of
ARMlock on Linux for the ARMv6 and ARMv7 sub-architectures.
Our evaluation shows that the isolation provided by ARMlock is
strong and eﬃcient. For example, ARMlock can eﬀectively isolate
both memory write and memory read, and code running inside a
sandbox executes as fast as that outside it. Moreover, ARMlock
supports advanced features that many other SFI systems cannot or
have diﬃcult to support, such as self-modifying code, just-in-time
compiling, and exception delivery.
Acknowledgements We would like to thank the anonymous re-
viewers for their comments that greatly helped to improve the pre-
sentation of this paper. This work was supported in part by the First
Year Assistant Professor award of Florida State University. The
ﬁrst author of this paper was partially supported by the National
Science Foundation of China under Grant No.61340031. Any opin-
ions, ﬁndings, and conclusions or recommendations expressed in
this material are those of the authors and do not necessarily reﬂect
the views of the FSU and NSFC.
8. REFERENCES
[1] Domain Access Control Register.
http://infocenter.arm.com/help/index.jsp?
topic=/com.arm.doc.ddi0434b/CIHBCBFE.html.
[2] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
Control-Flow Integrity: Principles, Implementations, and
Applications. In Proceedings of the 12th ACM Conference on
Computer and Communications Security, November 2005.
[3] Update from the CEO. http://googleblog.blogspot.
co.uk/2013/03/update-from-ceo.html.
[4] Calxeda. http://www.calxeda.com/.
[5] M. Castro, M. Costa, J.-P. Martin, M. Peinado, P. Akritidis,
A. Donnelly, P. Barham, and R. Black. Fast Byte-Granularity
Software Fault Isolation. In Proceedings of the 22nd ACM
Symposium on Operating Systems Principles, 2009.
[6] M. E. Conway. Design of a Separable Transition-Diagram
Compiler. In Communications of the ACM, 1963.
[7] Linux Foundation Referenced Speciﬁcation.
http://refspecs.linuxbase.org/.
[8] U. Erlingsson, S. Valley, M. Abadi, M. Vrable, M. Budiu,
and G. C. Necula. XFI: Software Guards for System Address
Spaces. In Proceedings of the 7th USENIX Symposium on
Operating Systems Design and Implementation, November
2006.
[9] B. Ford and R. Cox. Vx32: Lightweight User-level
Sandboxing on the x86. In Proceedings of 2008 USENIX
Annual Technical Conference, June 2008.
[10] T. Garﬁnkel. Traps and Pitfalls: Practical Problems in
System Call Interposition Based Security Tools. In
Proceedings of the 20th Annual Network and Distributed
Systems Security Symposium, February 2003.
[11] W. K. Giloi and P. Behr. An IPC Protocol and its Hardware
Realization for a High-speed Distributed Multicomputer
System. In Proceedings of the 8th annual symposium on
Computer Architecture, 1981.
[12] Linux and Chrome OS Sandboxing. https://code.
google.com/p/chromium/wiki/LinuxSandboxing.
[13] gzip. The gzip home page. http://www.gzip.org/.
[14] J. N. Herder, H. Bos, B. Gras, P. Homburg, and A. S.
Tanenbaum. Fault Isolation for Device Drivers. In
Proceedings of the 39th IEEE/IFIP International Conference
on Dependable Systems and Networks, 2009.
[15] Intel. Intel 64 and IA-32 Architectures Software Developer´s
Manual Volume 3: System Programming Guide, Part 1 and
Part 2, 2010.
[16] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering
Code-Injection Attacks with Instruction-Set Randomization.
In Proceedings of the 10th ACM conference on Computer
and communications security, CCS ’03, October 2003.
[17] V. Kiriansky, D. Bruening, and S. Amarasinghe. Secure
Execution Via Program Shepherding. In Proceedings of the
11th USENIX Security Symposium, August 2002.
[18] libpng. libpng home page.
http://libpng.org/pub/png/libpng.html.
[19] LMbench - Tools for Performance Analysis.
http://www.bitmover.com/lmbench/lmbench.html.
[20] Y. Mao, H. Chen, D. Zhou, , X. Wang, N. Zeldovich, and
M. F. Kaashoek. Software fault isolation with API integrity
and multi-principal modules. In Proceedings of the 23rd
ACM Symposium on Operating Systems Principles, October
2011.
[21] S. McCamant and G. Morrisett. Evaluating SFI for a CISC
architecture. In Proceedings of the 15th conference on
USENIX Security Symposium, July 2006.
[22] S. McCanne and V. Jacobson. The BSD Packet Filter:A New
Architecture for User-level Packet Capture. In Proceedings
of the 1993 USENIX conference, 1993.
[23] G. Morrisett, G. Tan, J. Tassarotti, J.-B. Tristan, and E. Gan.
RockSalt: Better, Faster, Stronger SFI for the x86. In
Proceedings of the 33rd ACM SIGPLAN Conference on
Programming Language Design and Implementation, PLDI
’12, june 2012.
[24] Linux/Unix nbench.
http://www.tux.org/~mayer/linux/bmark.html.
[25] National Vulnerability Databasel. http://nvd.nist.gov.
[26] PLT and GOT - the Key to Code Sharing and Dynamic
Libraries. https://www.technovelty.org/linux/plt-
and-got-the-key-to-code-sharing-and-dynamic-
libraries.html.
[27] L. V. Put, D. Chanet, B. D. Bus, B. D. Sutter, and K. D.
Bosschere. DIABLO: a Reliable, Retargetable and
Extensible Link-time Rewriting Framework. In Proceedings
of the 2005 IEEE International Symposium On Signal
Processing And Information Technolog, 2005.
[28] Remote Procedure Call. http:
//en.wikipedia.org/wiki/Remote_procedure_call.
[29] Raspberry Pi, an ARM/GNU Linux Box for $25.
http://www.raspberrypi.org/.
[30] N. Santos, H. Raj, S. Saroiu, and A. Wolman. Using ARM
Trustzone to Build a Trusted Language Runtime for Mobile
Applications. In Proceedings of the 19th International
Conference on Architectural Support for Programming
Languages and Operating Systems, ASPLOS ’14, March
2014.
[31] seccomp. http://lwn.net/Articles/332974/.
[32] Yet another new approach to seccomp.
http://lwn.net/Articles/475043/.
[33] D. Sehr, R. M. Karl, C. Biﬄe, V. Khimenko, E. Pasko,
K. Schimpf, B. Yee, and B. Chen. Adapting Software Fault
Isolation to Contemporary CPU Architectures. In
Proceedings of the 19th USENIX Security Symposium,
August 2010.
[34] M. I. Seltzer, Y. Endo, C. Small, and K. A. Smith. Dealing
With Disaster: Surviving Misbehaved Kernel Extensions. In
Proceedings of the USENIX 2nd Symposium on OS Design
and Implementation, 1996.
[35] H. Shacham, M. Page, B. Pfaﬀ, E.-J. Goh, N. Modadugu,
and D. Boneh. On the Eﬀectiveness of Address-Space
Randomization. In Proceedings of the 11th ACM conference
on Computer and communications security, CCS ’04,
October 2004.
[36] M. Sharif, W. Lee, W. Cui, and A. Lanzi. Secure In-VM
Monitoring Using Hardware Virtualization. In Proceedings
of the 16th ACM Conference on Computer and
Communications Security, November 2009.
[37] J. Siefers, G. Tan, and G. Morrisett. Robusta: Taming the
Native Beast of the JVM. In Proceedings of the 17th ACM
Conference on Computer and Communications Security,
2010.
[38] M. M. Swift, M. Annamalai, B. N. Bershad, and H. M. Levy.
Recovering Device Drivers. December 2004.
[39] M. M. Swift, B. N. Bershad, and H. M. Levy. Improving the
Reliability of Commodity Operating Systems. In
Proceedings of the 19th ACM symposium on Operating
Systems Principles, October 2003.
[40] Tcpdump/Libpcap. http://www.tcpdump.org.
[41] Translation Lookaside Buﬀer. http://en.wikipedia.
org/wiki/Translation_lookaside_buffer.
[42] On vsyscalls and the vDSO.
http://lwn.net/Articles/446528/.
[43] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham.
Eﬃcient Software-based Fault Isolation. In Proceedings of
the 14th ACM Symposium On Operating System Principles,
December 1993.
[44] Z. Wang, C. Wu, M. Grace, and X. Jiang. Isolating
Commodity Hosted Hypervisors with HyperLock. In
Proceedings of the 7th ACM SIGOPS EuroSys Conference,
2012.
[45] R. N. Watson and J. Anderson. Capsicum: Practical
Capabilities for UNIX. In Proceedings of the 2010 USENIX
Annual Technical Conference, June 2010.
[46] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Orm,
S. Okasaka, N. Narula, N. Fullagar, and G. Inc. Native
Client: A Sandbox for Portable, Untrusted x86 Native Code.
In Proceedings of the 30th IEEE Symposium on Security and
Privacy, May 2009.
[47] B. Zeng, G. Tan, and G. Morrisett. Combining Control-ﬂow
Integrity and Static Analysis for Eﬃcient and Validated Data
Sandboxing. In Proceedings of the 18th ACM Conference on
Computer and Communications Security, CCS ’11, October
2011.
[48] B. Zeng, G. Tan, and G. Morrisett. Combining Control-Flow
Integrity and Static Analysis for Eﬃcient and Validated Data
Sandboxing. In Proceedings of the 18th ACM Conference on
Computer and Communication Security, 2011.
[49] L. Zhao, G. Li, B. De Sutter, and J. Regehr. ARMor: Fully
Veriﬁed Software Fault Isolation. In Proceedings of the ninth
ACM international conference on Embedded software,
EMSOFT ’11, October 2011.