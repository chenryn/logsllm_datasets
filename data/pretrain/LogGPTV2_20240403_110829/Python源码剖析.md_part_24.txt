起始位置（也就是栈底）是由f_valuestack维护的，而f_stacktop维护了当前的栈顶。
会深入剖析），而另一部分才是给运行时栈使用的。所以，PyErameobject对象中的栈的
co_freevars、co_cellvars，它们涉及Python中对闭包的实现，在以后考察函数机制时
PyFrame
[frameobject.c]（有删节）
Rrameobject
PyFrameObject中的动态内存空间
第8章Python虚拟机框架
可见，在创建pyFrameObject对象时，额外申请的那部分内存中有一部分是给PyCode-
虽然在图8-1中连续的内存空间到图8-2已经变成了分离的内存空间，但是对比图8-1
7/四那分构成了PyFrameObject维护的动态内存区，其大小由extras确定
nfrees
PyFrameObject
return f；
E-sF_valuestack= f->f_localsplus +extras;
//E_valuestack维护运行时栈的栈底，E_stacktop维护运行时栈的栈顶
extras
/计算初始化时运行时栈的栈项
saiz
Pyobdect
Pyobjeet
New(PyThreadState *tstate,Pycodeobjectcode,Pyobiect *globals,
深度探索动态语言核心技术
cod0->co
code
PyTuple_GET_SIzE(code
extras,
*locals]l
LGC
valuestack
fstackop
Newvar(PyFrameObject,
图8-3新创建的PyFrameObject对象
nlocais
stacksize
ncells,
nfrees,;
ncells+nfree:
_localsplus
ireevars
&PyFrame_Type, ext.ras);
ncelis
extras
PyFrameObject
stack
mfrees;
---
## Page 169
8.1.3
甚至包括函数g的各个名字空间。
def E）
函数的函数的信息：
提供的一个方法能方便地获得当前处于活动状态的frameobject。这个方法就是sys
frameobject，它是对C一级的pyFrameobject的包装。而且，非常幸运的是，Python
是Python 还是提供了某种途径可以访问到pyFrameobject 对象。在Pyhon中，有一种
"value',sys",
caller'sglobalnamespace:
current functlon is 
[caller.py的输出结果]
show()
defshow():
defg(）:
value=3
LmPOtsys
[caller.py]
在Python中访问PyFrameObject对象
有兴趣的读者可能对sys.getframe是如何实现的很感兴趣，
从执行的结果可以看到，从函数中我们完全获得了其调用者
下面是执行caller.py的输出结果：
下面的callet.py 演示了如何利用获得当前活动的frameobject，进而获取调用当前
print"caller's global
尽管pyFrameObject对象是一个用于Python虚拟机实现的极为隐秘的内部对象，
王（）
g（）
caller
print
frame
=frame.f_back
sys._getframe()
namespace
Function iscaller.f_code.co_name
Hame
namespace:
Totar
Ldoc
',frame._code.co_name
Python源码剖析
b:2
8.1
builtins
Python虚拟机中的执行环境
cal
一深度探索动态语言核心技术
fileMshow
下面我们就给出一个
函数的一切信息，
139
但
---
## Page 170
8.2
140
8.2.1
Python源码剖析
达式，每一个py文件被称Python视为一个module。这些module中，有一个主module，
才会被剖析，但是本节将不会涉及函数、module、class在Python中是如何实现的。
这些概念在Pyihon中的实现或作用。
与名字空间这个概念紧密联系着的还有“名字”“作用域”这些概念。本节将深入地介绍
整个Python虚拟机运行的机制与“名字空间”这个概念有非常紧密的联系。在Pyuhon中，
globai名字空间和builti名字空间。名字空间对Pyhon来说，是一个非常核心的概念
种方式：一种是一般module的加载，通过import动作进行动态地加载：一种是主module
动态语言来说，名字的意义远比其对C这样的静态语言的意义大，因为名字是Pyhon在
中，以备日后使用，即实现代码复用：而另一个目的则是为整个系统划分名字空间。
如果你的Pyhon应用程序是通过pythonmain.py启动的，那么这个main.py就是一个主
个Pyhon应用程序总是由多个py文件组成，每一个py文件中包含了多行Python中的表
名字、作用域和名字空间
[frame_getter.py]
运行时能够找到其所对应的东西的唯一途径。
字。名字最终的作用不在于名字本身，而在于名字背后对应的那个事物。对Pyton这类
module.
import sys
在
Python程序的基础结构一
第8章Python虚拟机框架
在本节中，我们将提到函数、module、class等概念。尽管这些部分将在以后的章节中
Python中，一个标识符就是一个名字，比如变量名、函数名、类名等等，这些都是名
现实中的Python程序通常并不会集中在一个巨大的py文件中。相反，一般来说，一
上一节在PyFrameobject中，我们看到了3个独立的名字空间：1oca1名字空间、
在Pyhon中，要使用或执行一个module，必须首先加载一个module。加载可以用两
Pyhon中引入module的概念，其主要目的是将一些逻辑相关的代码放到一个module
get_current_frame():
一个名字（有时也称为符号）就是用于代表某些事物的一个有助于记忆的字符序列。
returml traceback.tb_frame.f_back
1/0
Evpe
一深度探索动态语言核心技术
sys.excinfot)
-module
---
## Page 171
8.2.2
对象（参见剖析module实现的章节）的形式存在。在module对象中，维护着一个名字空
么PyDictobjec简直就是为它量身订做的。
间就是一个PyDictobject对象实现的。约束既然是（name，obj）这样的关联关系，那
反，它会长久地影响程序的行为。约束的容身之处就是名字空间。在Pyhon中，名字空
称为约束。赋值语句就是约束建立的地方。在一个约束被创建之后，它不会立刻消失，相
关联关系，对于这个关联关系，我们采用《程序设计语言一—实践之路》里的术语，将之
后将这个函数对象“赋给”名字。
也是一个赋值语句，它的作用是首先创建一个函数对象（参见剖析函数机制的章节），然
作用是首先创建一个整数对象1，然后将这个对象“赋给”名字a同样地“def《）”
“importabe”这样的语句都是赋值语句，都遵循赋值语句的行为。
语句，原因很简单，它们会影响名字空间。在Apy中，“a=1”是一个赋值语句，它的
句中，有两个特殊的语句，它们被称为“赋值语句”。
必须被执行的表达式，这点与C/C++中的函数完全不同）。在这4个看上去都差不多的语
加载的过程中都会进行一个动作一
的加载，通过pythormain.py这样的方式完成。不管一个module是如何被加载的，在
prinea
def(）
[A.Py]
回到我们的A.py，在一个module被加载到Python中之后，它在内存中以一个module
print a
在赋值语句被执行之后，从概念上讲，我们实际上得到了一个（name，obj）这样的
约束与名字空间
在moduleA被加载时，Python会执行“a=1”、al=1"、“defE（）：”“printa
在Python中，除了在A.py中我们见到的赋值语句外，还有如“classA（object）：”
我们可以总结出Python中赋值语句行为的共同之处：
在Python中，赋值语句（更确切地说，是具有赋值行为的语句）是一类相当特殊的
考虑下面的一个module：
将obj“赋给”一个名字name
创建一个对象obj
一执行module中的表达式。
Python源码剖析
8.2名字、作用域和名字空间141
一深度探索动态语言核心技术
---
## Page 172
Python源码剖析
8.2.3
142
个作用域中，“a=2”这个约束起作用，从而影响代码清单8-1的[3]处的输出：“=2”
些约束都不起作用了。在B.py中，第3行和第4行程序正文就组成了一个作用域，在这
程序正文区域，在这个区域里，可能有很多个约束在起作用，一旦出了这个正文区域，
的“printa”也使用了不同的名字空间中的名字“a”。
5:pr.nta//[41输由结果为1
代码清单8-1
空间存在着一个可见性的问题。我们来考虑下面的例子（见代码清单8-1）。
的行为。在module内部，这样的描述是没错的，但是还不够细致。在module内部，名字
间的使用有着另一套不同的规则。
一个约束起作用的那一段程序正文区域称为这个约束的作用域。而一个作用域则是指一段
招
店
对应的实例对象，也有类似的考量）。
问别的module的名字空间，获得名字对应的对象（注意，对于Python中的class和class
字空间，在另一个modul中，要使用别的module中的名字，只能通过属性引用的方式访
性引用。属性引用就是使用另一个名字空间中的名字，一个module定义了一个独立的名
行为”的语句，我们将访问对象属性这个动作称之为“属性引用”。比如对于Apy，如果
属性的行为”的语句。既然设置了属性，那么Pyhon中还有一类“拥有访问对象属性的
心
中有一类“拥有赋值行为”的语句，从另一个角度来看，实际上它们也是“拥有设置对象
名字空间中。
间（一个dict 对象）。而（a，1）、（，functionobject）这些约束就位于module的
作用域与名字空间
在代码清单8-1的[3]处的输出结果为2，[4]处的输出结果为1，这个结果意味着在代
def：
在一个module内部，可能存在多个名字空间，每一个名字空间都与一个作用域对应
在Python中，module之间的名字空间规则是很清晰的，但在module内部，对名字空
在8.2.2节中，我们提到，约束一旦被创建，就会被放入名字空间中，然后影响程序
第8章Python虚拟机框架
一个对象的名字空间中的所有名字都称为对象的属性。在前面，我们看到了Pyhon
1:7/[10
printa7/31：输出结果为2
a=2//[2]
深度探素动态语言核心技术
---
## Page 173
间），直到到达程序的最外嵌套层次。这个最外嵌套层次就是module自身所定义的那个作
该到直接的外围作用域（名字空间）去查找，并继续向外顺序地检查外围作用域（名字空
里查找。如果在这里找到了对应的约束，它就是与这个名字相关的活动约束。否则，就应
域里是可见（起作用）的，而且在其内部嵌套的每个作用域里也可见，除非它被嵌套于内
产生的就是最内嵌套作用域规则：由一个赋值语句引进的名字在这个赋值语句所在的作用
这样的情况，就称为嵌套作用域。Pyhon的名字引用的行为被它所支持的嵌套作用域影响，
B.py自身就是一个作用域，而B.py中的函数王定义的作用域位于B.py定义的作用域之内，
用域。
部的，引进同样名字的另一条赋值语句所遮蔽。
方案，也就是说，Python支持嵌套作用域。
那么“print a”的行为该如何定义呢？
没有了与名字a相对应的约束。换句话说，
经知道，赋值语句实际上创建了约束，删除第3行代码，意味着在函数王定义的作用域中，
还是考虑B.py，如果我们删除第3行代码，那么第4行代码的输出结果会如何呢？我们己
用“printa”这样的方式就可以了。
要使用“printA.a”的方式：而在B.py中访问自己这个module中的名字a，则直接使
（函数主定义的作用域）之外的名字a，那么输出的结果就该为1。Python选择了第二种
是指不用加上属性引用方式的访问修饰符“”：比如在B.py中访问A.py中的名字a，需
详细介绍。
说，在函数执行时，Pyhon会为主创建一个名字空间，这一点在以后剖析函数机制时会
Pyhon程序运行时就会转化为一个名字空间，一个内存中的pyDictobject对象。也就是
用域）的。而名字空间就是与作用域对应的动态的东西，一个由程序文本定义的作用域在
唯一决定的，而不是在运行时动态决定的。因此，Pyhon是具有静态作用域（也称词法作
2”这个约束不起作用。
这个约束不能影响[4]的输出，因为第5行代码不在函数王所定义的作用域之内，所以“a=
Python中，
为了找到某个给定名字所引用的对象，应该用这个名字在当前的作用域（名字空间）
前面我们提到，module本身关联着一个名字空间，所以module对应的程序正文，即
位于一个作用域中的代码可以直接访问作用域中出现的名字，所谓“直接访问”，
访问名字这样的行为被称为名字引用，名字引用的规则决定了Python程序的行为
对于作用域这个概念，至关重要的是要记住它仅仅是由源程序的文本决定的。在
一种方案是抛出异常，显然，这是非常糟糕的方案；而另一种方案是使用当前作用域
，一个约束在程序正文的某个位置是否起作用，是由该约束在文本中的位置是否
，在调用函数王时，名字空间中没有名字a了。
Python源码剖析
8.2名字、作用域和名字空间143
一深度探索动态语言核心技术
---
## Page 174
8.2.3.2
8.2.3.1
Python源码剖析
144
代码清单8-2
到的最内嵌套作用域规则，如代码清单8-2所示。
就是指向同一个PyDictObject对象了。
上，就是同一个名字空间。更进一步，对应到pyFrameobject中，f_local和E_global
规则，只不过这时的local作用城和global作用域就是同一个作用域了。对应到名字空间
引用的过程：
如果还是找不到，则会到Python自身定义的builtin作用域中查找。图8-4显示了这个名字
好的。如果找不到，
Pyhon首先会在函数定义的作用域中（local作用域）中查找名字a，如果找到当然是最
的顺序查找名字对应的约束。
域规则被称为LGB规则：名字引用动作沿着local作用域、global作用域、builtin作用域
open、range等）。这3个作用域在Python2.2之前就已经存在，所以那时Python的作用
builin作用域（对应于builtin名字空间，在这里定义了Pyhon的builtin函数，比如dir
个local作用域（对应于local名字空间）：Python自身还定义了一个最顶层的作用域一
定义了一个作用域，这个称为global作用域（对应global名字空间）：
象地看一看作用域规则如何影响Pyhon的行为。在Python中，一个module对应的源文件
[C.Dy]
第8章Python虚拟机框架
三
LGB有一些变化的情况，比如对于B.py中的[41（见代码清单8-1），其实也会遵循LGB
还是考虑B.py中的[3]（见代码清单8-1），这里有一个对名字a的引用动作，因此，
从Python2.2开始，Python引入了嵌套函数，
最内嵌套作用域规则看上去很枯燥，所以我们从这一节开始，陆续给出一些例子，形
LGB规则
LEGB规则
深度探索动态语言核心技术
图8-4Python2.2之前的LGB作用域规则
printa
a=2
这时的作用域规则才更接近我们前面提
[buitin]
一个函数定义了一
---
## Page 175
8.2.3.3
内嵌套作用域规则是语言设计时的设计策略，即是形而上的“道”：而闭包则实现语言时
与函数g对应的函数对象捆绑在一起，将捆绑后的结果返回，这个拥绑起来的整体被称为