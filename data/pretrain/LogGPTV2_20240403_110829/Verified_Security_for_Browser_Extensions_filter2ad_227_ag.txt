in IE parlance. The BHO is implemented in F# and hosts our
Fine extensions in an unprivileged AppDomain, a software-
isolated process for .NET. The AppDomain allows us to easily
load and unload extensions while the browser is running, but
is not necessary for security guarantees, which are provided
by Fine’s type system. Although, of course, both the .NET
runtime and the browser itself are part of the TCB.
Google Chrome: porting the content scripts: As discussed
in Section II, Google Chrome’s extension model cannot ade-
quately express least privilege for a large class of extensions.
Using a new JavaScript back-end for Fine, based on the 
software [19], we compile our Fine extensions to ordinary
Chrome extensions by translating them to JavaScript. In ad-
dition, we provide a trivial JavaScript runtime system that
exposes JavaScript’s object-oriented DOM API as functions.
Note that we can afford to only translate the content script
of an extension, leaving the extension core of the extension
running separately, in a different Chrome process. However,
by rewriting extension content scripts in Fine, we gain the
ability to reason and restrict how the extension interacts with
HTML pages in a manner that is more restrictive and ﬁne-
grained than the default extension manifest.
A. C3: A fully-managed hosting platform
C3 is an HTML5 experimentation platform written from
the ground up exclusively in C#. Because C# code ultimately
runs in a memory-managed environment, it is not susceptible
to the memory corruption vulnerabilities that are responsible
for many existing browser attacks. Our extension hosting
architecture leverages this characteristic and beneﬁts from the
added safety.
Hosting architecture: Figure 11 illustrates the architecture we
use to host Fine extensions inside of C3. When C3 initializes, it
creates a new AppDomain, used to host all Fine extensions. C3
then loads a hosting module into the new application domain,
which serves a dual purpose. First, the module searches a
pre-deﬁned directory for .NET assemblies that implement the
interface supported by our Fine extensions. On ﬁnding such an
128
Extension hostC3 browserProxy objectFine APITwitterMiner.NET remotingMagnifyFacePalmProxy objectBrowsing contextBrowsing contextBrowsing contextDOMAppDomainAppDomainassembly, the module loads it into the new application domain,
and invokes its =E function. This process is performed only
once, on browser start-up.
Second, the hosting module acts as a “shim” layer between
the Fine extension API and the internals of C3. This function-
ality is implemented using a .NET proxy object, which is a
type-safe cross-AppDomain communication mechanism. The
proxy object contains one method for each internal C3 method
needed by the API’s, which are then implemented in terms of
methods on the proxy object. When an API function is invoked
by an extension, each subsequent call to a proxy method causes
the CLR to create a remote request to code in C3. Finally,
C3 objects referenced by the proxy object are associated with
integer GUIDs, communicated across AppDomain boundaries
instead of serialized versions of the original objects.
We implemented extension APIs for C3 in about 270 lines
of F#, and the proxy object implementation is 918 lines of F#.
We ﬁnd these requirements to be modest, and the gains due
to the added type safety to be well worth the effort.
IX. LIMITATIONS AND FUTURE WORK
This section discusses several limitations of approach and
considers directions for future work.
Extension evolution and policy inference: Extension code
is closely tied to the structure of the page. A web-site update
can cause the extension to stop functioning properly. To help
with this situation, we plan to investigate tool support
to
help extension authors update their code to account for page
structure changes. In addition to assisting with code changes,
we anticipate making use of weakest pre-condition inference
for reﬁnement types to automatically extract policies from
code, reducing the programmer effort required to produce
veriﬁed IBEX extensions.
Veriﬁed translation to JavaScript: We can deploy our ex-
tensions on various browsers because our compiler has two
backends. To build extensions for Internet Explorer and C3, we
use Fine’s DCIL backend, which was previously proven type
preserving [5]. To build extensions for Chrome and Firefox,
we use Fine’s new JavaScript backend. This paper does not
establish the soundness of compilation to JavaScript; we leave
this for future work.
Information ﬂow: As presented, our extension APIs do not
support non-interference based information ﬂow control. Prior
work shows that non-interference based information ﬂow con-
trol can be enforced in Fine using monadic libraries equipped
with value-indexed types. However, for simplicity, we restrict
ourselves to policies based on taint-tracking, which yields a
weaker security guarantee. In the future, we aim to make use
of type coercions [29] to transform programs to automatically
use monadic information ﬂow controls.
Revocation: Our log-based model of DOM side effects rules
out the possibility of specifying dynamic revocation policies.
Devising a security property and a veriﬁcation methodology
that provides a higher ﬁdelity model of effects, while still
being robust to the effects of untrusted JavaScript is an open
problem which we aim to address in the future.
X. RELATED WORK
Browser extension security: Ter Louw et al. [25] monitor
calls by extensions to a subset of Firefox’s privileged APIs, in
order to secure the extension installation process. While this
establishes a form of access control for extension installation,
the primary extension APIs remain unprotected, so extensions
are still over-privileged. Barth et al. [3] develop the security
model used for Google Chrome extensions. While this is the
ﬁrst extension model with native support for policy enforce-
ment, the policies it supports are signiﬁcantly more coarse-
grained than the examples we presented in this paper. We
survey the policies in use with Chrome extensions, and ﬁnd
many extensions to be needlessly over-privileged. Our survey
results are complemented by recent unpublished work by Felt
et al. [10], who also study the permissions used by Chrome
extensions.
A number of researchers have explored the use of infor-
mation ﬂow for browser extension veriﬁcation. Dhawan et al.
present Sabre [8], a tool that instruments Firefox’s JavaScript
interpreter to track security labels at runtime. Bandhakavi et
al. [2] presented Vex, a tool that statically analyzes Firefox
extensions for a set pre-determined patterns of suspicious
information ﬂows. While not speciﬁcally tied to extensions,
other projects such as Chugh et al. [6] and Guarnieri et
al. [17, 18] present information ﬂow analyses for JavaScript
that look for speciﬁc patterns of suspicious ﬂows. However,
because of the inherently dynamic nature of JavaScript, fully
static approaches are difﬁcult
to apply to large segments
of existing JavaScript code, generating interest
in runtime
enforcement [26]. Our Fine-based approach allows us to stati-
cally and soundly verify authorization and data ﬂow properties
of extensions; and our formal model characterizes safety even
in the presence of unveriﬁed third-party code.
Many have addressed the problems that arise due to browser
plugins, which consist of native code that executes in the
context of the browser. Internet Explorer’s entire extension
model ﬁts into this description, and much recent research
has addressed the problems that arise. In particular, spyware
extensions have received attention [9, 20, 24]; these systems
use binary taint-tracking to ensure that sensitive personal
information does not ﬂow to untrusted parties. Addressing a
more general set of concerns, Janus [12] and Google’s Na-
tive Client [34] considers system-level sandboxing techniques
for browser extensions. The OP [15] and Gazelle [33] web
browsers are constructed to address this issue, but do so by
applying general principles of secure system design to the
architecture of new browsers. In general, all these works target
the enforcement of isolation and memory safety properties, not
the more ﬁne-grained authorization properties we address.
Veriﬁed extensibility: Outside the speciﬁc setting of browser
extensions, the question of providing veriﬁed extension mech-
anisms for system-level code has received much attention.
129
With the SLAM project [1], Ball et al. show that software
model checking is effective at verifying device drivers. More
recently, Zhou et al. explore the use of type safety to provide
ﬁne-grained isolation for drivers [36], and show how to apply
their ﬁndings in a nearly backwards-compatible manner. Our
work is in this tradition of static extension veriﬁcation, but
rather than focusing on system-level properties, we target those
relevant to browser extension functionality.
XI. CONCLUSIONS
This paper proposes a new model for authoring, verifying,
distributing, and deploying safe browser extensions that can
run on all the most popular browser platforms. Our motivation
stems from the fact that even in the case of Chrome, which is,
arguably, the most secure of the browser extension models in
common use, extensions tend to be over-privileged, rendering
many protection mechanisms useless. We propose a ﬁner-
grained access control model for browser extensions, formally
characterize a security property for extensions, and develop
a methodology to enforce safety statically. We evaluate our
approach by developing 17 non-trivial browser extensions,
demonstrating that our approach is viable in practice. It is
our hope that IBEX will pave the way for a static veriﬁcation
mechanism of HTML5-based centrally-distributed browser ex-
tensions and applications on top of the HTML5 platform.
Acknowledgements: We thank Juan Chen, C´edric Fournet,
Ben Lerner, Jean Yang, and the anonymous reviewers for both
useful feedback and assistance with this work.
REFERENCES
[1] T. Ball and S. K. Rajamani. The SLAM project: Debugging
system software via static analysis. In ACM POPL, 2002.
[2] S. Bandhakavi, S. T. King, P. Madhusudan, and M. Winslett.
VEX: Vetting browser extensions for security vulnerabilities.
In USENIX Security, 2010.
[3] A. Barth, A. P. Felt, and P. Saxena. Protecting browsers from
extension vulnerabilities. In NDSS, 2010.
[4] CA Technologies.
Virus details: Win32/clspring family.
DJJFMMM?=?KIIA?KHEJO=@LEIHLEHKIEB
LEHKI=IFN1,"  &, 2006.
[5] J. Chen, R. Chugh, and N. Swamy. Type-preserving compilation
In ACM
of end-to-end veriﬁcation of security enforcement.
PLDI, 2010.
[6] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner. Staged
information ﬂow for JavaScript. In ACM PLDI, 2009.
[7] L. de Moura and N. Bjorner. Z3: An efﬁcient SMT solver. In
TACAS, 2008.
[8] M. Dhawan and V. Ganapathy. Analyzing information ﬂow in
JavaScript-based browser extensions. In ACSAC, 2009.
[9] M. Egele, C. Kruegel, E. Kirda, H. Yin, and D. Song. Dynamic
spyware analysis. In USENIX Security, 2007.
[10] A. P. Felt, K. Greenwood, and D. Wagner. The effectiveness
of install-time permission systems for third-party applications.
Technical report, University of California at Berkeley, 2010.
UCB/EECS-2010-143.
[11] M. Fredrikson and B. Livshits. RePriv: Re-envisioning in-
browser privacy. In IEEE S&P, 2011.
[12] I. Goldberg, D. Wagner, R. Thomas, and E. A. Brewer. A secure
In USENIX
environment for untrusted helper applications.
Security, 1996.
[13] Google Chrome. Popular Google Chrome extensions. DJJF
?DHACCA?ANJAIEIEIJFFK=H, 2010.
[14] A. D. Gordon and A. Jeffrey. Authenticity by typing for security
protocols. Journal of Computer Security, 11, July 2003.
[15] C. Grier, S. Tang, and S. T. King. Secure web browsing with
the OP web browser. In IEEE S&P, 2008.
[16] O. Grumberg and D. E. Long. Model checking and modular
veriﬁcation. ACM TOPLAS, 16, 1994.
[17] S. Guarnieri and B. Livshits. GateKeeper: Mostly static enforce-
ment of security and reliability policies for JavaScript code. In
USENIX Security, 2009.
[18] S. Guarnieri and B. Livshits. Gulfstream: Incremental static
In USENIX
analysis for streaming JavaScript applications.
Conference on Web Application Development, 2010.
[19] A. Guha, C. Saftoiu, and S. Krishnamurthi. The essence of
JavaScript. In ECOOP, 2010.
[20] E. Kirda, C. Kruegel, G. Banks, G. Vigna, and R. A. Kemmerer.
Behavior-based spyware detection. In USENIX Security, 2006.
[21] L. Koved, M. Pistoia, and A. Kershenbaum. Access rights
analysis for Java. In ACM OOPSLA, 2002.
[22] B. Lerner and D. Grossman. Language support for extensible
web browsers. In APLWACA, 2010.
[23] B. Lerner, H. Venter, B. Burg, and W. Schulte. C3: An
experimental extensible, reconﬁgurable platform for HTML-
based applications, 2010. In submission.
[24] L. Li, X. Wang, and J. Y. Choi. SpyShield: Preserving privacy
In Conference on Recent Advances in
from spy add-ons.
Intrusion Detection, 2007.
[25] M. T. Louw, J. S. Lim, and V. N. Venkatakrishnan. Enhancing
web browser security against malware extensions. Journal of
Computer Virology, 4(3), 2008.
[26] L. Meyerovich and B. Livshits. ConScript: Specifying and
enforcing ﬁne-grained security policies for Javascript in the
browser. In oakland, 2010.
[27] Mozilla Foundation.
How many Firefox users use add-
DJJF>CE=?=@@I '&
ons?
DM=OBEHABNKIAHIKIA=@@I, 2009.
[28] Mozilla Foundation. Add-on security vulnerability announce-
DJJF>CE=?=@@I %!
ment.
=@@IA?KHEJO=K?AAJ, 2010.
[29] N. Swamy, M. Hicks, and G. Bierman. A theory of typed
coercions and its applications. In ACM ICFP, 2009.
[30] N. Swamy, J. Chen, and R. Chugh. Enforcing stateful autho-
rization and information ﬂow policies in Fine. In ESOP, 2010.
[31] N. Swamy, J. Chen, C. Fournet, K. Bhargavan, and J. Yang.
Security programming with reﬁnement types and mobile proofs.
Technical report, MSR, 2010. MSR-TR-2010-149.
[32] K. Thomas. Chrome browser acts more like an OS, but security
DJJFMMMF?MH@?>KIEAII?AJAH
is unclear.
=HJE?A  %#$?DHA>HMIAH=?JIHAEA=
I>KJIA?KHEJOEIK?A=HDJ, 2011.
[33] H. Wang, C. Grier, E. Moshcuk, S. T. King, P. Choudhury, and
H. Venter. The multi-principal OS construction of the Gazelle
web browser. In USENIX Security, 2009.
[34] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy,
S. Okasaka, N. Narula, and N. Fullagar. Native client: A
sandbox for portable, untrusted x86 native code. In IEEE S&P,
2009.
[35] L. Zheng and A. C. Myers. Dynamic security labels and
In Workshop on Formal Aspects in Security
noninterference.
and Trust, 2004.
[36] F. Zhou, J. Condit, Z. Anderson, I. Bagrak, R. Ennals, M. Har-
ren, G. Necula, and E. Brewer. SafeDrive: Safe and recoverable
extensions using language-based techniques. In USENIX OSDI,
2006.
130