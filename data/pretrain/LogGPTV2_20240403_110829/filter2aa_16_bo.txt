abort 函数使程序非正常终止。其功能与 raise(SIGABRT)类似。 void exit(int status)
exit 函数使程序正常终止。atexit 函数的调用顺序与登记的顺序相反，这种情况下， 所有已打开的文件缓冲区将被清洗，所有已打开的流将被关闭，控制也将返回给环境。status
的值如何返回给环境要视具体的实现而定，但 0 值表示终止成功。也可使用值 EXIT_SUCCESS
和 EXIT_FAILURE 作为返回值。
int atexit(void (*fcn)(void))
atexit 函数登记函数 fcn，该函数将在程序正常终止时被调用。如果登记失败，则返回 非 0 值。
int system(const char *s)
system 函数将字符串 s 传递给执行环境。如果 s 的值为 NULL，并且有命令处理程序， 则该函数返回非 0 值。如果 s 的值不是 NULL，则返回值与具体的实现有关。
char *getenv(const char *name)
getenv 函数返回与 name 有关的环境字符串。如果该字符串不存在，则返回 NULL。其 细节与具体的实现有关。
void *bsearch(const void *key, const void *base, size_t n, size_t size,
int (*cmp)(const void *keyval, const void *datum))
bsearch 函数在 base[0]...base[n•1]之间查找与*key 匹配的页。在函数 cmp 中， 如果第一个参数(查找关键字)小于第二个参数(表页)，它必须返回一个负值;如果第一个 参数等于第二个参数，它必须返回零;如果第一个参数大于第二个参数，它必须返回一个正 值。数组 base 中的页必须按升序排列。bsearch 函数返回一个指针，它指向一个匹配页， 如果不存在匹配页，则返回 NULL。
void qsort(void *base, size_t n, size_t size, int (*cmp)(const void *, const void *))
qsort 函数对 base[0]...base[n•1]数组中的对象进行升序排序，数组中每个对象的 长度为 size。比较函数 cmp 与 bsearch 函数中的描述相同。
int abs(int n)
abs 函数返回 int 类型参数 n 的绝对值。
long labs(long n)
labs 函数返回 long 类型参数 n 的绝对值。
div_t div(int num, int denom)
div 函数计算 num/denom 的商和余数，并把结果分别保存在结构类型 div_t 的两个 int
类型的成员 quot 和 rem 中。
ldiv_t ldiv(long num, long denom)
idiv 函数计算 num/denom 的商和余数，并把结果分别保存在结构类型 idiv_t 的两个
long 类型的成员 quot 和 rem 中。
B.6 诊断:
assert 宏用于为程序增加诊断功能。其形式如下:
void assert(int expression)
如果执行语句
assert(expression)
时，表达式的值为 0，则 assert 宏将在 stderr 中打印一条消息，比如:
Assertion failed: 表连式, file 源文件名, line 行号
打印消息后，该宏将调用 abort 终止程序的执行。其中的源文件名和行号来自于预处理器宏
FILE 及   LINE__。
如果定义了宏 NDEBUG，同时又包含了头文件，则 assert 宏将被忽略。
B.7 可变参数表:
头文件提供了遍历未知数目和类型的函数参数表的功能。
假定函数 f 带有可变数目的实际参数，lastarg 是它的最后一个命名的形式参数。那么， 在函数 f 内声明一个类型为 va_list 的变量 ap，它将依次指向每个实际参数:
va_list ap;
在访问任何未命名的参数前，必须用 va—start 宏初始化 ap 一次:
va_start(va_list ap, lastarg);
此后，每次执行宏 va_arg 都将产生一个与下一个未命名的参数具有相同类型和数值的值， 它同时还修改 ap，以使得下一次执行 va_arg 时返回下一个参数:
type va_arg(va_list ap, type);
在所有的参数处理完毕之后，且在退出函数 f 之前，必须调用宏 va_end 一次，如下所示:
void va_end(va_list ap);
B.8 非局部跳转:
头文件中的声明提供了一种不同于通常的函数调用和返回顺序的方式，特 别是，它允许立即从一个深层嵌套的函数调用中返回。
int setjmp(jmp_buf env)
setjmp 宏将状态信息保存到 env 中，供 longjmp 使用。如果直接调用 setjmp，则返
回值为 0;如果是在 longjmp 中调用 setjmp，则返回值为非 0。Setjmp 只能用于某些上下 文中，如用于 if 语句、switch 语句、循环语句的条件测试中以及一些简单的关系表达式中。 例如:
if (setjmp(env) == 0)
/* get here on direct call */ else
/* get here by calling longjmp */ void longjmp(jmp_buf env, int val)
longjmp 通过最近一次调用 setjmp 时保存到 env 中的信息恢复状态，同时，程序重新 恢复执行，其状态等同于 setjmp 宏调用刚刚执行完并返回非 0 值 val。包含 setjmp 宏调 用的函数的执行必须还没有终止。除下列情况外，可访问对象的值同调用 longjmp 时的值相 同:在调用 setjmp 宏后，如果调用 setjmp 宏的函数中的非 volatile 自动变量改变了， 则它们将变成未定义状态。
B.9 信号:
头文件提供了一些处理程序运行期间引发的各种异常条件的功能，比如来 源于外部的中断信号或程序执行错误引起的中断信号。
void (*signal(int sig, void (*handler)(int)))(int)
signal 决定了如何处理后续的信号。如果 handler 的值是 SIG_DFL，则采用由实现 定义的默认行为;如果 handler 的值是 SIG_IGN，则忽略该信号;否则，调用 handler 指 向的函数(以信号作为参数)。有效的信号包括:
SIGABRT             异常终止，例如由 abort 引起的终止 SIGFPE             算术运算出错，如除数为 0 或溢出 SIGILL             非法函数映像，如非法指令
SIGINT             用于交互式目的信号，如中断
SIGSEGV             非法存储器访问，如访问不存在的内存单元
SIGTERM             发送给程序的终止请求
对于特定的信号，signal 将返回 handler 的前一个值;如果出现错误，则返回值 SIG_ERR。 当随后碰到信号 sig 时，该信号将恢复为默认行为，随后调用信号处理程序，就好像由
(*handler)(sig)调用的一样。信号处理程序返回后，程序将从信号发生的位置重新开始
执行。
信号的初始状态由具体的实现定义。
int raise(int sig)
raise 向程序发送信号 sig。如果发送不成功，则返回一个非 0 值。
B.10 日期与时间函数:
头文件中声明了一些处理日期与时间的类型和函数。其中的一些函数用于处理 当地时间，因为时区等原同，当地时间与日历时间可能不相同。clock_t 和 time_t 是两个
表示时间的算术类型，struct tm 用于保存日历时间的各个构成部分。结构 tm 中各成员的 用途及取值范围如下所示:
int
tm_sec;
从当前分钟开始经过的秒数(0, 61)
int
tm_min;
从当前小时开始经过的分钟数(0, 59)
int
tm_hour;
从午夜开始经过的小时数(0, 23)
int
tm_mday;
当月的天数(1, 31)
int
tm_mon;
从 1 月起经过的月数(0, 11)
int
tm_year;
从 1900 年起经过的年数
int
tm_wday;
从星期天起经过的天数(0, 6)
int
tm_yday;
从 1 月 1 日起经过的天数(0, 365)
int
tm_isdst;
夏令时标记
使用令时，tm_isdst 的值为正，否则为 0。如果该信息无效，则其值为负。
clock_t clock(void)
clock 函数返回程序开始执行后占用的处理器时间。如果无法获取处理器时间，则返回 值为•1。clock()/CLOCKS_PER_SEC 是以秒为单位表示的时间。
time_t time(time_t *tp)
time 函数返回当前日历时间。如果无法获取日历时间，则返回值为•1。如果 tp 不是 NULL， 则同时将返回值赋给*tp。
double difftime(time_t time2, time_t time1) difftime 函数返回 time2•time1 的值(以秒为单位)。
time_t mktime(struct tm *tp)
mktime 函数将结构*tp 中的当地时间转换为与 time 表示方式相同的日历时间，结构中 各成员的值位于上面所示范围之内。mktime 函数返回转换后得到的日历时间;如果该时间不 能表示，则返回•1。
下面 4 个函数返回指向可被其它调用覆盖的静态对象的指针。
char *asctime(const struct tm *tp)
asctime 函数将结构*tp 中的时间转换为下列所示的字符串形式:
Sun Jan 3 15:14:13 1988\n\0 char *ctime(const time_t *tp)
ctime 函数将结构*tp 中的日历时间转换为当地时间。它等价于下列函数调用:
asctime(localtime(tp))
struct tm *gmtime(const time_t *tp)
gmtime 函数将*tp 中的日历时间转换为协调世界时(UTC)。如果无法获取 UTC，则该 函数返回 NULL。函数名字 gmtime 有一定的历史意义。
struct tm *localtime(const time_t *tp) localtime 函数将结构*tp 中的日历时间转换为当地时间。
size_t strftime(char *s, size_t smax, const char *fmt, const struct tm
*tp)
strftime 函数根据 fmt 中的格式把结构*tp 中的日期与时间信息转换为指定的格式， 并存储到 s 中，其中 fmt 类似于 printf 函数中的格式说明。普通字符(包括终结符'\0') 将复制到 s 中。每个%c 将按照下面描述的格式替换为与本地环境相适应的值。最多 smax 个 字符写到 s 中。strftime 函数返回实际写到 s 中的字符数(不包括字符'\0');如果字符 数多于 smax，该函数将返回值 0。
fmt 的转换说明及其含义如下所示:
%a             一星期中各天的缩写名
%A             一星期中各天的全名
%b             缩写的月份名
%B             月份全名
%c             当地时间和日期表示
%d             一个月中的某一天(01•31)
%H             小时(24 小时表示)(00•23)
%I             小时(12 小时表示)(01•12)
%j             一年中的各天(001—366)
%m             月份(01•12)
%M             分钟(00•59)
%p             与 AM 与 PM 相应的当地时间等价表示方法
%S             秒(00•61)
%U             一年中的星期序号(00•53，将星期日看作是每周的第一天)
%w             一周中的各天(0•6，星期日为 0)
%W             一年中的星期序号(00•53，将星期一看作是每周的第一天)