另一方面，如果作业的工作集大于可用记忆体，则排序方法的优点是可以高效地使用磁碟。这与我们在 “[SSTables 和 LSM 树](ch3.md#SSTables和LSM树)” 中讨论过的原理是一样的：资料块可以在记忆体中排序并作为段档案写入磁碟，然后多个排序好的段可以合并为一个更大的排序档案。归并排序具有在磁碟上执行良好的顺序访问模式。（请记住，针对顺序 I/O 进行最佳化是 [第三章](ch3.md) 中反复出现的主题，相同的模式在此重现）
GNU Coreutils（Linux）中的 `sort` 程式透过溢位至磁碟的方式来自动应对大于记忆体的资料集，并能同时使用多个 CPU 核进行并行排序【9】。这意味著我们之前看到的简单的 Unix 命令链很容易伸缩至大资料集，且不会耗尽记忆体。瓶颈可能是从磁碟读取输入档案的速度。
### Unix哲学
我们可以非常容易地使用前一个例子中的一系列命令来分析日志档案，这并非巧合：事实上，这实际上是 Unix 的关键设计思想之一，而且它直至今天也仍然令人讶异地重要。让我们更深入地研究一下，以便从 Unix 中借鉴一些想法【10】。
Unix 管道的发明者道格・麦克罗伊（Doug McIlroy）在 1964 年首先描述了这种情况【11】：“我们需要一种类似园艺胶管的方式来拼接程式 —— 当我们需要将讯息从一个程式传递另一个程式时，直接接上去就行。I/O 应该也按照这种方式进行 ”。水管的类比仍然在生效，透过管道连线程式的想法成为了现在被称为 **Unix 哲学** 的一部分 —— 这一组设计原则在 Unix 使用者与开发者之间流行起来，该哲学在 1978 年表述如下【12,13】：
1. 让每个程式都做好一件事。要做一件新的工作，写一个新程式，而不是透过新增 “功能” 让老程式复杂化。
2. 期待每个程式的输出成为另一个程式的输入。不要将无关资讯混入输出。避免使用严格的列资料或二进位制输入格式。不要坚持互动式输入。
3. 设计和构建软体时，即使是作业系统，也让它们能够尽早地被试用，最好在几周内完成。不要犹豫，扔掉笨拙的部分，重建它们。
4. 优先使用工具来减轻程式设计任务，即使必须曲线救国编写工具，且在用完后很可能要扔掉大部分。
这种方法 —— 自动化，快速原型设计，增量式迭代，对实验友好，将大型专案分解成可管理的块 —— 听起来非常像今天的敏捷开发和 DevOps 运动。奇怪的是，四十年来变化不大。
`sort` 工具是一个很好的例子。可以说它比大多数程式语言标准库中的实现（它们不会利用磁碟或使用多执行绪，即使这样做有很大好处）要更好。然而，单独使用 `sort` 几乎没什么用。它只能与其他 Unix 工具（如 `uniq`）结合使用。
像 `bash` 这样的 Unix shell 可以让我们轻松地将这些小程式组合成令人讶异的强大资料处理任务。尽管这些程式中有很多是由不同人群编写的，但它们可以灵活地结合在一起。Unix 如何实现这种可组合性？
#### 统一的介面
如果你希望一个程式的输出成为另一个程式的输入，那意味著这些程式必须使用相同的资料格式 —— 换句话说，一个相容的介面。如果你希望能够将任何程式的输出连线到任何程式的输入，那意味著所有程式必须使用相同的 I/O 介面。
在 Unix 中，这种介面是一个 **档案**（file，更准确地说，是一个档案描述符）。一个档案只是一串有序的位元组序列。因为这是一个非常简单的介面，所以可以使用相同的介面来表示许多不同的东西：档案系统上的真实档案，到另一个程序（Unix 套接字，stdin，stdout）的通讯通道，装置驱动程式（比如 `/dev/audio` 或 `/dev/lp0`），表示 TCP 连线的套接字，等等。很容易将这些设计视为理所当然的，但实际上能让这些差异巨大的东西共享一个统一的介面是非常厉害的，这使得它们可以很容易地连线在一起 [^ii]。
[^ii]: 统一介面的另一个例子是 URL 和 HTTP，这是 Web 的基石。一个 URL 标识一个网站上的一个特定的东西（资源），你可以连结到任何其他网站的任何网址。具有网路浏览器的使用者因此可以透过跟随连结在网站之间无缝跳转，即使伺服器可能由完全不相关的组织维护。这个原则现在似乎非常明显，但它却是网路取能取得今天成就的关键。之前的系统并不是那么统一：例如，在公告板系统（BBS）时代，每个系统都有自己的电话号码和波特率配置。从一个 BBS 到另一个 BBS 的引用必须以电话号码和调变解调器设定的形式；使用者将不得不挂断，拨打其他 BBS，然后手动找到他们正在寻找的资讯。直接连结到另一个 BBS 内的一些内容当时是不可能的。
按照惯例，许多（但不是全部）Unix 程式将这个位元组序列视为 ASCII 文字。我们的日志分析示例使用了这个事实：`awk`、`sort`、`uniq` 和 `head` 都将它们的输入档案视为由 `\n`（换行符，ASCII `0x0A`）字元分隔的记录列表。`\n` 的选择是任意的 —— 可以说，ASCII 记录分隔符 `0x1E` 本来就是一个更好的选择，因为它是为了这个目的而设计的【14】，但是无论如何，所有这些程式都使用相同的记录分隔符允许它们互操作。
每条记录（即一行输入）的解析则更加模糊。Unix 工具通常透过空白或制表符将行分割成栏位，但也使用 CSV（逗号分隔），管道分隔和其他编码。即使像 `xargs` 这样一个相当简单的工具也有六个命令列选项，用于指定如何解析输入。
ASCII 文字的统一介面大多数时候都能工作，但它不是很优雅：我们的日志分析示例使用 `{print $7}` 来提取网址，这样可读性不是很好。在理想的世界中可能是 `{print $request_url}` 或类似的东西。我们稍后会回顾这个想法。
尽管几十年后还不够完美，但统一的 Unix 介面仍然是非常出色的设计。没有多少软体能像 Unix 工具一样互动组合的这么好：你不能透过自定义分析工具轻松地将电子邮件帐户的内容和线上购物历史记录以管道传送至电子表格中，并将结果释出到社交网路或维基。今天，像 Unix 工具一样流畅地执行程式是一种例外，而不是规范。
即使是具有 **相同资料模型** 的资料库，将资料从一种资料库汇出再汇入到另一种资料库也并不容易。缺乏整合导致了资料的 **巴尔干化**[^译注i]。
[^译注i]: **巴尔干化（Balkanization）** 是一个常带有贬义的地缘政治学术语，其定义为：一个国家或政区分裂成多个互相敌对的国家或政区的过程。
#### 逻辑与布线相分离
Unix 工具的另一个特点是使用标准输入（`stdin`）和标准输出（`stdout`）。如果你执行一个程式，而不指定任何其他的东西，标准输入来自键盘，标准输出指向萤幕。但是，你也可以从档案输入和 / 或将输出重定向到档案。管道允许你将一个程序的标准输出附加到另一个程序的标准输入（有个小记忆体缓冲区，而不需要将整个中间资料流写入磁碟）。
如果需要，程式仍然可以直接读取和写入档案，但 Unix 方法在程式不关心特定的档案路径、只使用标准输入和标准输出时效果最好。这允许 shell 使用者以任何他们想要的方式连线输入和输出；该程式不知道或不关心输入来自哪里以及输出到哪里。（人们可以说这是一种 **松耦合（loose coupling）**，**晚期系结（late binding）**【15】或 **控制反转（inversion of control）**【16】）。将输入 / 输出布线与程式逻辑分开，可以将小工具组合成更大的系统。
你甚至可以编写自己的程式，并将它们与作业系统提供的工具组合在一起。你的程式只需要从标准输入读取输入，并将输出写入标准输出，它就可以加入资料处理的管道中。在日志分析示例中，你可以编写一个将 Usage-Agent 字串转换为更灵敏的浏览器识别符号，或者将 IP 地址转换为国家程式码的工具，并将其插入管道。`sort` 程式并不关心它是否与作业系统的另一部分或者你写的程式通讯。
但是，使用 `stdin` 和 `stdout` 能做的事情是有限的。需要多个输入或输出的程式虽然可能，却非常棘手。你没法将程式的输出管道连线至网路连线中【17,18】[^iii] 。如果程式直接开启档案进行读取和写入，或者将另一个程式作为子程序启动，或者开启网路连线，那么 I/O 的布线就取决于程式本身了。它仍然可以被配置（例如透过命令列选项），但在 Shell 中对输入和输出进行布线的灵活性就少了。
[^iii]: 除了使用一个单独的工具，如 `netcat` 或 `curl`。Unix 起初试图将所有东西都表示为档案，但是 BSD 套接字 API 偏离了这个惯例【17】。研究用作业系统 Plan 9 和 Inferno 在使用档案方面更加一致：它们将 TCP 连线表示为 `/net/tcp` 中的档案【18】。
#### 透明度和实验
使 Unix 工具如此成功的部分原因是，它们使检视正在发生的事情变得非常容易：
- Unix 命令的输入档案通常被视为不可变的。这意味著你可以随意执行命令，尝试各种命令列选项，而不会损坏输入档案。
- 你可以在任何时候结束管道，将管道输出到 `less`，然后检视它是否具有预期的形式。这种检查能力对除错非常有用。