5.1 分支监视概览
分支监视是跟踪和记录CPU执行路线（history）的基本措施，对软
件优化和软件调试都有着至关重要的作用。在CPU没有集成内部高速缓
存（cache）之前，所有内存读写操作都要通过前端总线进行，因此可
以使用逻辑分析仪等工具监视到CPU的所有内存读写动作，特别是取指
动作（从某一内存地址读取指令）。尤其是在CPU执行分支指令后，可
以通过分析它接下来取指的地址知道CPU执行了哪个分支。也就是说，
对于内部没有高速缓存的传统处理器，可以通过观察前端总线观察CPU
的执行路线。
但对于集成有高速缓存的处理器来说（见图5-1），CPU是成批地
将代码读入高速缓存，而后再从高速缓存中读取指令并解码和执行。这
使得位于前端总线上的调试工具失去了精确观察CPU所有取指操作的能
力，不能像以前那样观察到CPU的执行轨迹。
图5-1 位于前端总线上的调试工具
为了解决以上问题，奔腾处理器引入了一种专门的总线事务（bus
transaction），称为分支踪迹消息（Branch Trace Message，BTM）。在
BTM功能被启用后（后文讨论），CPU在每次执行分支和改变执行路线
时都会发起一个BTM事务，将分支信息发送到前端总线上。这样，调试
工具便可以通过监听和读取BTM消息跟踪CPU的执行路线了。
因为硬件调试工具的价格通常都比较昂贵，而且设置和使用也都比
较麻烦，所以P6处理器引入了通过内部寄存器来记录分支信息的功能。
这样，只要进行必要的设置，CPU便会把分支信息记录到特定的寄存器
中。寄存器可以记录的信息毕竟有限，于是奔腾4处理器引入了通过特
定的内存区域来记录分支信息的功能。后面两节我们将分别讨论这两种
分支监视机制。
5.2 使用寄存器的分支记录
本节先介绍使用MSR寄存器来记录分支的方法。P6处理器最先引入
了这种方法，可以记录最近一次分支的源和目标地址，称为Last Branch
Recording，简称LBR。奔腾4处理器对其做了增强，增加了寄存器个
数，以栈的方式可以保存多个分支记录，称为LBR栈（LBR Stack）。
5.2.1 LBR
P6处理器设计了如下5个MSR寄存器（Machine/Model Specific
Register），用来实现LBR机制。
用来记录分支的LastBranchToIP和LastBranchFromIP寄存器对。
用来记录异常的LastExceptionToIP和LastExceptionFromIP寄存器
对。
一个MSR寄存器来控制新加入的调试功能，称为DebugCtl，其格式
如图5-2所示。
当发生分支时，LastBranchFromIP用来记录分支指令的地址，
LastBranchToIP用来记录这个分支所要转移到的目标地址。
当异常（调试异常除外）或中断发生时，CPU会先把
LastBranchToIP和LastBranch- FromIP中的内容分别复制到
LastExceptionToIP和LastExceptionFromIP寄存器中，然后再把发生异常
或中断时被打断的地址更新到LastBranchFromIP，把异常或中断处理程
序的地址更新到LastBranchToIP寄存器中。
图5-2 DebugCtl MSR（P6处理器）
虽然DebugCtl MSR是一个32位的寄存器，但是只使用了低7位，其
中各个位的含义如下。
LBR位用来启用LBR机制，如果此位被置为1，那么处理器会使用
上面介绍的4个寄存器来记录分支和异常或中断位置。对于P6处理
器，当CPU产生调试异常时，CPU会自动清除此位，以防调试异常
处理函数内部的分支覆盖掉原来的结果。
BTF（Branch Trace Flag）的作用是启用按分支单步执行。如果此
位被置为1，那么CPU会将标志寄存器EFLAGS的TF（陷阱标志）
位看作“single-step on branches（针对分支单步执行）”。换句话
说，当BTF位和TF位都为1时，在CPU执行完下一个分支指令后便
会产生调试异常。我们在4.3节中详细介绍了这一功能。
PB0与CPU上的BP0#（Breakpoint and Performance Monitoring output
pin 0）引脚相对应。如果此位被置为1，那么当CPU检测到
DR0（调试地址寄存器0）所定义的断点条件时会设置BP0#引脚，
以通知硬件调试工具；如果此位被置为0，那么当性能计数器0的值
增加或溢出（由PerfEvtSel0寄存器控制）时，CPU会反转
（toggle）BP0#引脚上的电平。
PB1～PB3与PB0类似，只是与CPU上的BP1#～BP3#引脚和DR1～
DR3寄存器相对应。
TR（Trace message enable）位用来启用（设为1）或禁止向前端总
线（FSB）上发送分支踪迹消息（BTM）。如果此位被置为1，每
当CPU检测到分支、中断或异常时，都会向FSB总线上发送BTM消
息，以通知总线分析仪（bus analyzer）之类的调试工具。启用这项
功能会影响CPU的性能。
5.2.2 LBR栈
P6的LBR机制只可以记录最近一次的分支和异常，奔腾4处理器对
其做了增强，引入了所谓的“最近分支记录堆栈”，简称LBR栈，可以记
录4次或更多次的分支和异常。奔腾M处理器和Core系列处理器也支持
LBR栈。
LBR栈是一个环形栈，由数个用来记录分支地址的MSR寄存器（称
为LBR MSR）和一个表示栈顶（Top Of Stack）指针的MSR寄存器（称
为MSR_LASTBRANCH_TOS）构成。CPU在把新的分支记录放入这个
堆栈前会先把TOS加1，当TOS达到最大值时，会自动归0。
LBR栈的容量因CPU型号的不同而不同，目前产品的可能值为4、
8、16或32。可以通过CPUID指令取得CPU的Family和Model号，再根据
Model号确定LBR MSR的数量。
以奔腾4 CPU为例，Model号为0～2的处理器有4个LBR MSR寄存
器，即MSR_LASTBRANCH_0～MSR_LASTBRANCH_3，每个MSR的
长度是64位，高32位是分支的目标地址（To），低32位是分支指令的地
址（From）。这样，这个堆栈最多可以记录最近4次的分支、中断或异
常。
Model号大于等于3的奔腾4 处理器有32个LBR MSR寄存器，被分为
16对，分别是MSR_LASTBRANCH_0_FROM_LIP～
MSR_LASTBRANCH_15_FROM_LIP和
MSR_LASTBRANCH_0_TO_LIP～MSR_LASTBRANCH_15_TO_LIP，
每个MSR的长度是64位，但高32位保留未用，因此最多可以记录16次最
近发生的分支、中断或异常。
奔腾M处理器定义了8个LBR寄存器， 即MSR_LASTBRANCH_0～
MSR_LASTBRANCH_7，地址为0x40～0x47。这8个寄存器都是64位
的，低32位用来记录From地址，高32位用来记录To地址。
Core微架构的CPU通常有8～64个LBR寄存器，分为4～32对，
MSR_LASTBRANCH_0_FROM_IP～MSR_LASTBRANCH_x_FROM_IP
用来记录分支的源地址，MSR_LASTBRANCH_0_TO_IP～
MSR_LASTBRANCH_x_TO_IP用来记录分支的目标地址。这些寄存器
都是64位的，可以记录最近4～32次分支、中断或异常。
LBR寄存器中内容的含义可能因为CPU型号的不同而不同。在P6处
理器中，4个分支记录寄存器所保存的地址都是相对于当前代码段的偏
移。在Pentium 4处理器中，LBR栈中记录的是线性地址。在Core微架构
的CPU中，可以通过IA32_PERF_CAPABILITIES寄存器的0～5位
（[5:0]，LBR_FMT）的值来进行判断，具体信息请参见IA手册卷3B的
第17～18章。
5.2.3 示例
为了演示如何使用LBR寄存器了解CPU的执行轨迹，我们编写了一
个WinDBG扩展模块（DLL），名为LBR.DLL。执行这个模块的lbr命
令，便可以访问和显示LBR寄存器的内容。清单5-1列出了演示性的源
代码。完整的代码和项目文件在chap05\lbr目录下。
清单5-1 显示LBR栈的WinDBG扩展命令源代码
1    //
2    // WinDBG扩展模型，用于读取LBR寄存器
3    //
4    #define LBR_COUNT 8
5    #define LBR_MSR_START_ADDR 0x40
6    #define MSR_LASTBRANCH_TOS 0x1c9
7    #define MSR_DEBUGCTLB      0x1d9
8    DECLARE_API( lbr )
9    {
10      ULONG64 llDbgCtrl,llLBR;
11      ULONG   ulFrom,ulTo,ulTos;
12      CHAR   szSymbol[MAX_PATH];
13      ULONG   ulDisplacement;
14      int nToRead;
15    
16     Version();
17     ReadMsr(MSR_DEBUGCTLB,&llDbgCtrl);
18     dprintf("MSR_DEBUGCTLB=%x\n", (ULONG)llDbgCtrl);
19     llDbgCtrl&=0xFFFFFFFE;// 清除LBR位,位0
20     WriteMsr(MSR_DEBUGCTLB,llDbgCtrl);
21     dprintf("LBR bit is cleared now.\n");
22    
23     ReadMsr(MSR_LASTBRANCH_TOS,&llLBR);
24     ulTos=llLBR&0xF;
25     dprintf("MSR_LASTBRANCH_TOS=%x\n", ulTos);
26    
27     nToRead=ulTos;
28     for (int i=0; i>32);
33          
34        szSymbol[0] = '!';
35        GetSymbol((PVOID)ulTo, (PUCHAR)szSymbol, &ulDisplacement);
36        dprintf("MSR_LASTBRANCH_%x: [%08lx] %s+%x\n", nToRead, 
37          ulTo,szSymbol,ulDisplacement);
38    
39        szSymbol[0] = '!';
40        GetSymbol((PVOID)ulFrom, (PUCHAR)szSymbol, &ulDisplacement);
41        dprintf("MSR_LASTBRANCH_%x: [%08lx] %s+%x\n", nToRead,
42          ulFrom, szSymbol,ulDisplacement);
43    
44        nToRead--;
45        if(nToRead !lbr.lbr
Access LBR (Last Branch Recording) registers of IA-32 CPU.
Version 1.0.0.2 by Raymond
MSR_DEBUGCTLB=1
LBR bit is cleared now.
MSR_LASTBRANCH_TOS=5