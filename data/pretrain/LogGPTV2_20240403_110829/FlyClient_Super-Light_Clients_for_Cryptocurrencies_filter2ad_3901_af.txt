2 −τ 1+k−1
τ−1
i=− n−k
= Dstart · τ k+τ−(τ +1)τ
τ i +(cid:80)k+ n−k
τ i +(cid:80)k−1
i=k+1
i=0
k+n
k+n
2
2
2
τ−1
i=− n−k
2 +1
τ i)
4) t is at least long enough to cover the required number of
5) If n = k, i.e., all periods are maximally increasing and t ≤
difﬁculty lowering transitions.
f·τ · n
For other scenarios such as k not an integer or k < 0, the
m
calculations are similar.
All of these checks ensure that the difﬁculty transitions of
queried blocks are valid. Furthermore, they ensure that queried
blocks were not affected by an invalid difﬁculty transition.
We formally prove this by saying that an adversary that
uses invalid difﬁculty transitions cannot increase its success
probability. Speciﬁcally, the adversary might as well have used
valid difﬁculty transitions and mined more invalid blocks.
Lemma 4. Let A be an adversary as deﬁned by the variable
backbone model that produces a chain C with non-negligible
probability p such that k blocks are valid as by the deﬁnition.
Then, assuming a collision-resistant hash function, there exists
an adversary A(cid:48) that using the same number of oracle queries
as A respects the retargeting rules and produces a chain C(cid:48)
with probability at least p − negl(λ) that contains the same
valid blocks but respects the retargeting rules.
The proof of Lemma 4 is in Appendix B-E
B. Non-Interactive FlyClient
We present the probabilistic veriﬁcation as an interactive
protocol between a client and a veriﬁer. Note that the client
simply queries random blocks, according to some publicly
known probability distribution. We can therefore transform
the interactive public-coin protocol into a non-interactive ar-
gument using the Fiat-Shamir heuristic [30]. This means that
the randomness used to determine which blocks are sampled is
derived using a secure hash function (say, SHA-3) applied to
the head of the chain. The veriﬁer not only checks the queries
itself but also that the randomness was properly derived.
The Fiat-Shamir heuristic turns the statistical soundness of
the information theoretic sampling protocol into computational
soundness as a prover can receive new samples by recomputing
the ﬁnal block header. On the other hand, recomputing the
1Recall that m
f is the target epoch length, e.g., 2 weeks in Bitcoin
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:03 UTC from IEEE Xplore.  Restrictions apply. 
939
ﬁnal header requires solving a new PoW puzzle, which itself
requires a high number of queries to the hash function. In fact,
our security assumption gives a concrete bound on the number
of PoW puzzles the adversary can solve, which is c · n. Let
pm be the soundness of Protocol 1 and 2−λ be the desired
failure probability (e.g., 2−50). Using the union bound, we
conclude that the non-interactive FlyClient is secure as long as
pm < 2−λ
c·n .
C. FlyClient Security
We ﬁnally prove security of the overall protocol. The
proof uses the security of the information theoretic sampling
protocol along with the security of the cryptographic MMR
that makes the queries veriﬁable and ensures that the proper
difﬁculty rules are followed. We now restate the main Theorem
and prove it.
Theorem 1 (FlyClient). Assuming a variable difﬁculty back-
bone protocol such that all adversaries are limited to be (c, L)-
adversaries as per Assumption 2 and assuming a collision-
resistant hash function H (Deﬁnition 8), the FlyClient protocol
is a secure NIPoPoW protocol in the random oracle model as
per Deﬁnition 3 with all but negligible probability. The proto-
col is succinct with proof size O(L + λ · log1/c(n) · log2(n)).
Proof. The (c, L)-adversary assumption requires that all difﬁ-
culty transitions are honest. Lemma 4 shows that any adversary
that doesn’t follow these transitions is not more successful in
fooling the veriﬁer. The security of the MMR also ensures that
the MMR is position and weight binding with overwhelm-
ing probability. Corollary 2 shows that with O(λ log1/c(n))
queries and a constant number of L blocks being checked at
the end, the probability of an adversary evading the sampling
protocol is negligible. We can make the one-round public
coin protocol non-interactive using the Fiat-Shamir heuristic
which is secure in the random oracle model [34]. The proof
size consists of L successive blocks being revealed plus the
sampled blocks and their MMR paths. This gives a total proof
size of O(L + λ log1/c(n) log2(n)) hashes and blocks.
VII. EVALUATION
Experimental Setup. We implemented FlyClient and evalu-
ated it empirically in two different scenarios. Our comparisons
are focused on the proof size but both creating and verifying
proofs is fast. Even in our unoptimized implementation, it
takes less than a second over all tested parameters.
We evaluate the performance of FlyClient using data from
the Ethereum blockchain which has widely varying difﬁculty.
FlyClient signiﬁcantly outperforms standard SPV clients es-
pecially for longer chains. The evaluation assumes a block
header of size 508 bytes and a hash output of 32 bytes.
Additionally, the MMR nodes contain 16 bytes to store the
time and difﬁculty parameters. Note that Ethereum technically
does not satisfy the deﬁnition of the variable difﬁculty model
as explained in Section III-B. We still evaluate FlyClient on
Ethereum because it has a high block production rate which
makes the evaluation results more interesting. Additionally,
Fig. 3. The plot shows the number of manually checked blocks L and the
number of queried blocks for the Ethereum blockchain and c = 0.5, λ = 50.
Additionally on the secondary axes the plot shows the proof size both without
the MMR proof optimization and without.
it is possible to run FlyClient for Ethereum but only with
heuristic security guarantees. This seems fundamental until the
Ethereum backbone itself has been proven to be secure.
In Appendix C, we also compare FlyClient with NIPoPoW
in the unrealistic scenario that all blocks have the same
difﬁculty. NIPoPoW cannot handle variable difﬁculty chains.
Both NIPoPoW’s and FlyClient’s proofs are logarithmic in
the chain length but FlyClient outperforms NIPoPoW over all
parameters by about 50%. This is mainly due to FlyClient’s
MMR proofs consisting of hashes versus NIPoPoW’s back-
pointers which consist of full block headers.
Implementation and Optimizations. We
implemented
FlyClient as a proof of concept in Python. Our implementation
only supports the production and veriﬁcation of FlyClient
proofs and does not verify state transitions. We assume a
hard fork, i.e., that each block header contains the MMR root
of all previous blocks. We perform several optimizations to
minimize the proof size. First, we optimize for the smallest
proof size by trying different values of δ. The security holds
for arbitrary values of δ so a prover can choose a δ which
minimizes the proof size. Our protocol does this automatically
while ensuring that at least L = λ blocks are checked at the
end.
We also reduce the proof size by not duplicating overlapping
MMR proof elements. The overlaps are fairly common as our
sampling distribution samples late blocks with signiﬁcantly
higher probability. The veriﬁer can easily detect which nodes
in a proof are shared and therefore does not require the
duplicated information. The efﬁciency of this optimization is
displayed in Figure 3. We can see that it reduces the proof
size by around 30%. Moreover, the plot shows the number of
manually checked blocks vs. the number of randomly sampled
blocks. Interestingly, even at a chain length of 7 million, the
protocol only inspects around 600 blocks. We also see that L,
the number of manually inspected blocks, hardly grows with
increased chain length.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:03 UTC from IEEE Xplore.  Restrictions apply. 
940
0100200300400500600700800900020040060080010001200140001,000,0002,000,0003,000,0004,000,0005,000,0006,000,0007,000,000PROOF SIZE IN KBBLOCKS QUERIEDQueriesLProof sizeUnoptimized Proof sizesupported by NSF, SGF, ONR, the Simons Foundation, the
ZCash Foundation and Visa Research
Fig. 4. FlyClient for the Ethereum chain at varying chain lengths n and for
different adversarial powers c. Additionally we display the difﬁculty on the
secondary axis.
A. Ethereum Implementation with Variable Difﬁculty
We implement FlyClient and evaluate it using data from the
Ethereum blockchain. We measure its performance at different
chain lengths, i.e., at different historic data points. Ethereum’s
PoW difﬁculty is not constant but varies widely and has
historically been increasing. Note that technically Ethereum’s
difﬁculty transition function does not fall into the variable
difﬁculty model of [10]. We still use Ethereum data as it is
a popular PoW blockchain with a long (in terms of number
of blocks) chain. Additionally using FlyClient for Ethereum is
possible but only heuristically secure as explained in Section
III-A.
FlyClient is the ﬁrst PoPoW design that achieves succinct
proof sizes for variable difﬁculty chains. We demonstrate
the efﬁciency of FlyClient in Figure 4. For c = 0.5, i.e., the
adversary controls less than a third of the total mining power
the proofs are less than 1 MB even for 7,000,000 Ethereum
blocks. This compares to a 3.4 GB SPV proof size for the
same chain. We additionally plot the mining difﬁculty in the
same ﬁgure. Interestingly, the proof size decreases from 3
to 4 million blocks as the difﬁculty rapidly grows. This is
because, with high difﬁculty growth, the manually-checked
blocks contain a larger fraction of the overall difﬁculty. This
reduces the number of blocks that need to be sampled from
the rest of the chain. From 3 to 4 million blocks, a so-called
difﬁculty bomb [35] resulted in a rapid increase of proof size.
This “bomb” was removed at around 4.3 million blocks which
led to a drastic decrease in difﬁculty and accordingly a slightly
higher proof size.
ACKNOWLEDGEMENTS
We thank the anonymous CCS reviewers for pointing out
Bahack style attacks and problems with the security proof in a
previous version of the paper. We also thank Vladislav Gelfer,
Dionysis Zindros, Matthew Jagielski and Mahnush Movahedi
for helpful comments and discussions. This work was partially
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:03 UTC from IEEE Xplore.  Restrictions apply. 
941
05001,0001,5002,0002,5003,0003,5004,00005001,0001,5002,0002,5003,00001000000200000030000004000000500000060000007000000Proof size in KBNumber of blocks nProof size and difficulty vs Ethereum chain length0.10.20.330.50.70.9WorkDifficulty in units of 10#$REFERENCES
[1] “Top 6 vendors in the wearable payment market from 2016 to 2020:
Technavio — business wire,” https://www.businesswire.com/news/home/
20161118005252/en/Top-6-Vendors-Wearable-Payment-Market-2016,
2018, (Accessed on 11/27/2018).
[2] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008,
available at https://bitcoin.org/bitcoin.pdf.
[3] V. Buterin, “Ethereum’s white paper,” https://github.com/ethereum/wiki/
wiki/White-Paper, 2014.
[4] C. Dwork and M. Naor, “Pricing via processing or combatting junk
mail,” in Advances in Cryptology — CRYPTO’ 92: 12th Annual
International Cryptology Conference Santa Barbara, California, USA
August 16–20, 1992 Proceedings. Springer Berlin Heidelberg, 1993, pp.
139–147. [Online]. Available: http://dx.doi.org/10.1007/3-540-48071-4
10
[5] J. A. Garay, A. Kiayias, and N. Leonardos, “The Bitcoin backbone
protocol: Analysis and applications,” in Advances in Cryptology -
EUROCRYPT 2015, 2015, pp. 281–310.
[6] R. Pass, L. Seeman, and A. Shelat, “Analysis of the blockchain protocol
in asynchronous networks,” in Advances in Cryptology – EUROCRYPT
2017, J.-S. Coron and J. B. Nielsen, Eds.
Springer International
Publishing, 2017, pp. 643–673.
[7] L. Kiffer, R. Rajaraman, and a. shelat, “A better method to analyze
blockchain consistency,” in Proceedings of
the 2018 ACM SIGSAC
Conference on Computer and Communications Security. ACM, 2018,
pp. 729–744.
[8] “Blockchain takes way too long to sync · issue #2394 · ethereum/mist,”
on
https://github.com/ethereum/mist/issues/2394,
11/29/2018).
(Accessed
2017,
[9] A. Kiayias, N. Lamprou, and A.-P. Stouka, Proofs of Proofs of Work with
Sublinear Complexity. Springer Berlin Heidelberg, 2016, pp. 61–78.
[10] J. Garay, A. Kiayias, and N. Leonardos, “The bitcoin backbone protocol
with chains of variable difﬁculty,” in Annual International Cryptology
Conference. Springer, 2017, pp. 291–323.
cross-chain
swaps,”
arXiv
preprint
[11] M. Herlihy,
“Atomic
arXiv:1801.09515, 2018.
[12] “ethereum/btcrelay: Ethereum contract for bitcoin spv,” https://github.
com/ethereum/btcrelay, 2018, (Accessed on 12/14/2018).
[13] A. Back and G. Maxwell, “Transferring ledger assets between
blockchains via pegged sidechains,” Nov 2016, uS Patent App.
15/150,032.
[14] A. Kiayias, A. Miller, and D. Zindros, “Non-interactive proofs of proof-
of-work,” 2017.
[15] A. Kiayias and D. Zindros, “Proof-of-work sidechains,” Cryptology
ePrint Archive, Report 2018/1048, 2018, https://eprint.iacr.org/2018/
1048.
[16] M. Zamani, M. Movahedi, and M. Raykova, “RapidChain: Scaling
blockchain via full sharding,” in 2018 ACM Conference on Computer
and Communications Security (CCS), 2018.
[17] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and
B. Ford, “OmniLedger: A secure, scale-out, decentralized ledger via
sharding,” in 2018 IEEE Symposium on Security and Privacy (S&P),
2018, pp. 19–34. [Online]. Available: doi.ieeecomputersociety.org/10.
1109/SP.2018.000-5
[18] “Open timestamps,” https://opentimestamps.org/, 2018.
[19] “Stampery,” https://stampery.com/, 2018.
[20] “Ethereum blocks,” https://etherscan.io/blocks, July 2019, (Accessed on
07/30/2019).
[21] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller,
A. Poelstra, J. Tim´on, and P. Wuille, “Enabling blockchain innovations
with pegged sidechains.”
[22] “Getting deep into geth: Why syncing ethereum node is slow,” https:
[27] J. Bonneau, “Why buy when you can rent? bribery attacks on bitcoin-
style consensus,” in Proceedings of Financial Cryptography, 2016.
[28] I. Eyal and E. G. Sirer, “Majority is not enough: Bitcoin mining
is vulnerable,” in Financial Cryptography and Data Security: 18th
International Conference, FC 2014, Christ Church, Barbados, March