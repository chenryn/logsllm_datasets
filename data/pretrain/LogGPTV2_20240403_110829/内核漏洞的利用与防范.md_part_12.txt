·准备一个伪造的栈结构来正确返回用户态。事实上，因为没有使用任何指定的内核级
的shellcode（正如前面例子中做的那样），所以需要提供一种方法来从内核态中跳出。
---
## Page 61
52第一部分内核态
这依赖于在第一阶段是如何进入内核的，还可能跟应用程序二进制接口（ABI）有
关系。
在第二种方法中我们简单地描述了代码借用技术。如果您对这些用户态的技术比较感兴趣
（比如，正在寻找一种详细的解释或是进入内核态的更多的理论），可以参考在本章最后的“相
关阅读”部分列出的相应的参考文献。
伪造shellcode
到现在为止，我们已经广泛地讨论了放置shellcode的问题，现在讨论它本身要执行哪些操
作。正如在这部分开始所介绍的，一个好的shellcode需要至少做两件事：获得提升的权限和恢
结构中创建通道来打开稍候可用来修改内核页表的后门，以便在用户态可以直接读取，或改变
用户态帮助程序的执行路径。这里我们将关注最通用的方法：修改存储在进程控制块中的进程
权限标识。
提示当针对一个硬化环境的时候，由于shellcode拥有完全的权限，因此禁止最终
的安全限制（比如，从诸如FreeBSD或是Solaris区域限定环境中跳转出）或安全保
护（如在Linux内核中关闭SELinux）是不错的主意。
提升权限
提升权限是最普通的工作，因为几乎所有本地权限提升均利用执行。权限标识保存在一个
以是简单的识别用户的整型数值，就如传统的UNIX系统中root/普通用户的模式，或表示权限
或安全令牌的一个完整集，正如基于权限的访问控制系统和在适当位置的最小权限模型（令牌
是Windows中的典型权限模型）。不同的操作系统使用不同的认证和授权模型，但是大部分时
候授权或拒绝用户的步骤可以总结为以下几步：
1）用户在系统中认证自己（如通过经典的登录/密码验证机制）。
2）系统给用户一组安全标识。
3）授权子系统使用这些标识来验证用户的某些深入的操作。
在用户成功登录以后（验证阶段），内核动态地创建一系列的数据结构以保存与安全标识
相关的信息。每一个由用户触发的新进程将继承前面提到的这些标识，除非用户明确指定无须
继承（操作系统一直提供一种在进程创建时限制权限集的方式）。一个进程无论何时想要执行
一个操作，内核都会去匹配相应的请求和存储的标识集合并且在进程的开始处执行这个操作或
返回一个错误。
结构存储在进程控制块中，所以在shellcode中获取它们非常简单。鉴别正确值的改变有两个主
要的方式：
·可以使用固定的或是硬编码的偏移量并且在使用之前执行非常简单的安全性检查。比如，
---
## Page 62
第3章成功内核利用进阶53
空间中。
·可以使用一种启发式方法。标识结构在内存中有着精确的布局，并且我们可以知道赋予
这个标识的权限。基于这个基础，可以在内存中执行模式匹配来准确地找到需要改变的
值。在一个结构中的相对偏移地址可能会改变，并且使用这种启发式方法可以在运行时
确定正确的位置。
通常情况下，一个混合的方法可以针对所有内核来使用，通过识别常年不变的偏移量并且
使用或多或少的复杂的启发式方法来推导出其他的偏移量。一个经典并且有效的启发式方法是
寻找一个可以预知的结构成员的特定标签。比如，一个基于进程的引用计数器会有进程个数的
上限值（容易检查），或者在一个混合环境中一个内核地址将始终高于或低于独立的地址（这
取决于内核放置的位置）。
恢复内核状态
在一个机器上获取超级权限是令人兴奋的，但如果由于内核的严重错误在很短时间即失去
这种权限就没那么有趣了。恢复阶段的目标就是持续这种兴奋，并且在您享受获取超级权限的
新鲜感的同时使机器持续流畅地运行。在恢复阶段您需要仔细考虑以下两个问题：
·内核利用可能会干扰有意义的内核结构，并且通常会破坏其他内核路径可能会访问的内
核内存。
·劫持的内核控制路径可能获得了需要释放的锁。
第一个问题主要关注内存破坏bug的问题。遗憾的是，当您利用内存的bug时，所面临的
出区域的大小而使得在目标完成后准确停止。在这种情况下，有两种不同的结构类型来恢复：
栈结构和堆控制结构。
注意在大多数架构或应用程序二进制接口中，过程链和软件陷阱中都在使用栈结
构。虽然我们试图保证接下来的讨论尽量不跟具体架构相关，但是为了看清楚栈恢复
的细节，我们需要关注一个具体架构的实现。因此我们选定的架构是x86-64，接下来
的内容的每个实践部分都是基于x86-64架构的实现。
在基于栈的内存溢出过程中，也许可以回到一个正常的状态。也许不能够。比如，您可能
去改写shellcode以返回到一个漏洞的路径中嵌套的调用函数并且从那里继续执行。
然而，如果跳转的层次太深，将需要结束函数链并且跳回到用户态。正如所指出的，用户
态的进程通过软件陷阱和中断到达内核态。一旦内核执行完成请求服务，就不得不返回控制进
程并且恢复它的状态以便在软件陷入以后从下一条指令继续执行。从中断返回的通用方法是使
用IRETQ指令（在x86架构中是IRET）。在很多情况下这条指令可以用于返回，但是在这里
我们感兴趣的是Intel使用手册中所指的不同权限间的返回，因为我们将从内核态（最高权限）
返回到用户态（最低权限）。
Intel使用手册中IRETQ指令执行的第一条指令是从栈中出栈一组值。
---
## Page 63
54第一部分内核态
tempRIP←Pop():
tempCs-Pop（):
tempEFLAGSPop（）:
tempRSP←Pop():
tempSS←Pop(）;
正如所看到的，可以将RIP（64位指令指针）、CS（代码段寄存器）、EFLAGS（存储各
种状态信息的寄存器）、RSP（64位栈指针）、SS（栈段寄存器）从栈中复制到临时数据中。在
CS段寄存器保存的权限级别与当前的权限级别相比较，依此决定接下来需要对临时数据执行的
检验操作，以及需要如何存储EFLAGS信息。理解验证的重要性对理解架构想要在栈中找到什
么样的数值非常重要。在我们的例子中，CS保存一个低的权限级别标识（返回用户态），所以
在栈中的寄存器内容应该包括以下几种：
·CS、SS分别表示在用户态中使用的代码段和栈段。每种内核都默认这样定义。
·RIP在内核态中指向有效执行区域。在这里最好令它指向用户态漏洞利用中的一个
函数。
·EFLAGS可以是任何有效的用户态数据，在开始开发或利用漏洞时可以简单地利用该
寄存器中的数值。
·RSP指向有效栈的指针，栈可以是足够大小的内存单元，并充许RIP所指向的程序以
较高的权限安全地执行一个本地的脚本。
如果我们为这些寄存器准备的值正确，按IRETQ所期望的顺序复制这些值，并且使内
核栈指针指向前面提到的内存区域，我们就能够执行IRETQ指令并且安全地跳出内核态。因
为栈的内容在每次进入内核态时都要废弃（基本上，栈指针可以重置成一个固定的值，这个
值是为栈分配的页的开始的偏移量，并且认为所有的内容是无效的），这足够安全地保证系统
处于稳定状态。如果内核态或是用户态使用GS段寄存器（如现在的做法），SWAPGS指令需
要在IRETQ指令之前执行。这条指令会将GS寄存器中的内容和保存在一个机器特定寄存器
（Machine-SpecificRegister，MSR）中的值进行简单交换。内核在刚进入的时候执行这种操作，
我们需要在即将离开的时候也执行这种操作。作为一个快速回顾，shellcode的栈恢复阶段的代
码看起来应该如下：
push$SS_USER_VALUE
push$USERLAND_STACK
push$USERLAND_EFLAGS
push$CS_USER_VALUE
push$USERLAND_FUNCTION_ADDRESS
swapgs
iretq
因为堆结构的恢复需要依赖于操作系统的实现而不是底层基础架构，我们将在第4、5、6
章中对其进行详细讨论。然而，就目前来讲这确实是很重要的，除非堆调试的某种顺序是适当
的，重写分配的堆对象不需要很多的恢复操作（通常内核路径使用充分的内核数据模拟值来得
到自由对象）。重写自由对象可能需要更多的处理，因为一些内核堆分配器将段数据存储其中
（如，“next”自由对象）。在那个阶段，能够驱动堆达到一个可预知的状态非常有用，我们将在
---
## Page 64
第3章成功内核利用进阶55
接下来的“触发阶段”继续讨论实现这样一个结果背后用到的理论。
到现在为止，我们关注了漏洞触发后的恢复。几乎没有关注在到达漏洞前内核路径都执行
了哪些操作和如果执行流程没有被劫持将会执行哪些操作。特别地，需要小心地释放已经获取
到的资源锁。对于添加执行块的漏洞，这不是一个问题。一旦shellcode执行，我们将从劫持点
精确地返回并且内核路径将完成执行，清除释放可能锁住的任何资源。
另外，破坏性的劫持如栈溢出，若使用之前描述的IRETQ技术并不能够返回到原始的内核
路径，所以在恢复阶段需要关注shellcode中的锁。操作系统实现了一系列的锁机制，例如：自
旋锁、信号量、条件变量、各种各样的用于多个或单个进程读/写的互斥器等。对这种多样性
不必大惊小怪：锁是一种关键的性能要素，尤其是当很多进程或是子系统竞争一个资源时，可
以把锁的原操作分为两个部分：繁忙等待锁和阻塞锁。当出现繁忙等待锁时内核路径一直徘徊
等待着锁，启动CPU周期并且执行一个小循环直到释放锁。当出现阻塞锁时，如果已经获得
锁，内核路径将进人睡眠状态，迫使重新安排CPU资源并且从不参与竞争直到内核通知资源再
次可用并且唤醒后台进程。
当您写一个漏洞利用程序来中断执行流程时，要做的第一件事就是鉴别内核路径获得了多
少关键锁和如何正确地释放它们。关键锁是系统所依赖的锁（这些在操作系统中只是一小部分
也会执行检查，必须小心避免陷入这些障碍中。所有的关键锁都需要立刻恢复。
另外，非关键锁既可以在稍后阶段间接给予处理（比如，加载外部模块），如果它的效果
仅仅是杀死用户态进程（就如提升当前进程标识一样简单地提升父进程的标识），或者是留下
一些永远不会再用的非关键资源，也可以忽略它。
触发阶段
现在内核中有了shellcode，可以创造条件来到达它，这就是触发阶段的工作。
我们主要的自标是为成功地劫持内核执行流创造条件。先将那些不包括任意代码执行的逻
辑bug放在一边，我们将这个阶段的分析分为2个类别：内存破坏和竞态条件。
内存破坏
正如在第2章所看到的一样，有不同种类的内存破坏，但是我们最终的目标总是覆盖内存
的指针，以便稍候用作指令指针（例如，它将结束CPU的PC/IP指令）。这可以通过覆盖函数
的返回地址直接完成，也可以通过模仿内核态结果直到可以用可控函数指针得到内核路径。我
们在分类时将采用这种区别，接下来介绍内存破坏的三种常见情况：任意内存重写、堆内存破
坏、栈内存破坏。
任意内存重写
任意内存重写在内核态是相当常见的。在这种情况下，可以重写任意内存，不管它们是
（部分）可控数据还是不可控数据。在近代或现代的操作系统体系架构上，只读属性受权限保
---
## Page 65
56第一部分内核态
护而不能直接写。在x86和x86-64结构上，这是WP（写保护）标识的工作，也可以自己设置。
我们的目标是找到一些可写入的地方，一旦修改了，将执行代码。
重写全局结构函数指针
在本章之前，我们讨论了内核结构里可重写函数指针的地方。采用这个方法通常遇到的问
题是，多数这样的结构是动态分配的，我们不知道在内存的哪里能够找到它们。幸运的是，几
乎所有的内核都需要保存一些全局结构。
警告如果声明全局结构为常量（在C里面是用const关键字修饰的），编译器或链
接器会把它们放到只读数据区，如果遵守这个区域的匹配标识，那么它们将不再可修
改。另外，如果需要在运行期修改它们，可以将它们放到可写段里。这就是我们要找
的入口点。
一个典型的用C声明的保存了函数指针的结构体如下所示：
structfile_operations
structmodule*owner;
loff_t（*llseek）（structfile*,1off_t,int);
ssize_t（*read)（structfile*,charuser*,size_t.1off_t*);
ssize_t（*write)(structfile*,constcharuser*,
size_t,1off_t*);
ssize_t（*aio_read)（structkiocb*,conststructiovec*,
unsignedlong.loff_t):
ssize_t（*aio_write)（structkiocb*,conststructiovec*,
unsigned 1ong.1off_t):
int（*readdir）（structfile*，void*，filldir_t）:
unsignedint（*poll)（structfile*，structpoll_table_struct*);
int（*ioctl）（structinode*，structfile*
unsignedint,unsigned 1ong):
[...]
上面的例子来自Linux内核，是用来生成文件系统文档代码和剩下的内核之间的抽象层。
这种方法在现代操作系统中相当常见，它通常为劫持执行流提供了非常好的入口。正如将要在
“信息收集阶段”部分看到的，它可能非常容易（而可靠）地在内存中定位到这些结构。如果
您正在为利用寻找这种结构，只需要在所选操作系统中寻找包含ops或operations名字的类型
标识符。
利用架构
本章以分析架构层开始。除恰当地理解低层次执行细节之外（操作系统的底层细节），架
构也可以变成一种辅助手段并提供新的利用媒介。在前面的内容中提到了中断和异常以及操作
系统注册一个指到它们的处理程序指针表的事实。显然，如果可以修改这些指针，就可以劫持
控制流并使它向自己的shellcode跳转。
作为一个例子，让我们来考虑x86-64架构的中断描述符，图3.4描述了这张表的条目。
这个条目16字节长，由一系列字段组成：
·16位代码段寄存器这表明了内核中断处理程序的代码段寄存器。通常，它保存了内核
---
## Page 66
第3章成功内核利用进阶57
代码段的路径。从根本上说，这个字段表明了调用处理器函数时应该调用哪个寄存器。
·64位指令指针偏移量（RIP）这表明了执行会转移到哪里。自从应用64位以来，它允
许中断服务程序定位到线性地址空间的任意地方。
·3位中断栈表（IST）栈转换机制在权限层次间用到IST。x86-64架构引I进了这个字段，
为特定的中断提供了一种在执行过程中使用好的栈的方法。这对于我们想要修改的中断
并不适用，所以我们可以忽略或使之失效。您可以在本章的“相关阅读”部分找到更多
关于IST、栈转换机制的介绍。
·4位描述描述符类型的字段主要是3种IDT描述符：任务门、中断门、陷阱门。我
外部硬件中断请求使用，而陷阱门通常用于服务异常和软件生成中断（如INT指令
引起的中断）。
·2位DPL（权限描述符）字段这个字段与CPL（CurrentPrivilegeLevel，当前权限）
一起决定是否允许调用者调用这个门。
·1位P（当前）标识表示这个段是否存在。
中断/陷阱门
31
0
保留的
31
偏移量63.32
31
161514131211
87
54
20
偏移量31.16