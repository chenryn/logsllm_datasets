cated to P0 and P1. As mentioned before, shares of a value x
are r and x − r, where r is a appropriately picked uniformly
random value. We observe that since one of the shares is truly
random, it can be computed as the output of a shared PRF
key between P2 and one of the parties, say P0. This cuts
the communication of this step to half. Moreover, since many
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:36:59 UTC from IEEE Xplore.  Restrictions apply. 
342
Protocol
Conv2dm,i,f,o
ShareConvert
ComputeMSB
ReLU
MaxPooln
Communication (SecureNN)
(2q2f 2i + 2f 2oi + q2o)(cid:3)
4(cid:3) log p + 6(cid:3)
4(cid:3) log p + 13(cid:3)
8(cid:3) log p + 24(cid:3)
(8(cid:3) log p + 29(cid:3))(n − 1)
Communication (Porthos)
(2m2i + 2f 2oi + q2o)(cid:3)
3(cid:3) log p + 5(cid:3)
3(cid:3) log p + 9(cid:3)
6(cid:3) log p + 19(cid:3)
(6(cid:3) log p + 24(cid:3))(n − 1)
TABLE III: Communication complexity of protocols; q = m−
f + 1 and log p = 8.
activations are computed in parallel, we can carefully “load-
balance” this optimization between P0 and P1 to reduce the
communication to half on the critical path. We implement
this load-balance optimization and observe that this reduces
the overall communication of ShareConvert, ComputeMSB,
ReLU and MaxPool by 25%.
The revised table with comparison of overall communi-
cation complexity of all protocols with improvements over
SecureNN are provided in Table III. Conv2dm,i,f,o denotes a
convolutional layer with input m×m, i input channels, a ﬁlter
of size f × f, and o output channels. MaxPooln computes the
maximum value out of a list of n elements. p denotes a prime
value strictly larger than 65 (set to 67 in SecureNN), with 8
bits being used to represent elements in Zp (hence log p = 8
in the table).
V. ARAMIS
In this section, we describe Aramis, a general technique to
convert any semi-honest secure MPC protocol into a secure
MPC protocol tolerating malicious corruptions by relying on
secure hardware. The threshold of corrupted parties tolerated
by the semi-honest protocol
is retained in the malicious
secure protocol by our technique.
Threat Model. We consider a strong threat model where not
only does the adversary control the operating system of the
corrupted parties (i.e., the host operating system is outside the
Trusted Computing Base) but also observes the entire state
of their secure hardware. Aramis makes a very minimal trust
assumption of integrity on hardware, namely that of code
attestation (the outputs generated by the hardware are indeed
from the code that it attested to). This implicitly requires the
hardware to possess a trusted component that can produce
signatures and this signature scheme cannot be forged by
the adversary. However, the adversary can see the state (i.e.,
all the code and the user data) of the hardware belonging to
the corrupted parties, i.e., we do not assume conﬁdentiality
of state. Prior works [74], [69], [38], [11], [23], [29], [51],
[32], [77], [83], [44] that combine MPC and hardware (SGX)
make stronger trust assumption on the hardware of both
conﬁdentiality and integrity, and hence, provide security only
in a weaker threat model where the hardware hides the data
residing in it from the adversary.
Overview. At a very high level, Aramis exploits the following
(well-known) observation: in order for a semi-honest protocol
to be made maliciously secure, one must ensure that all
messages sent by every party Pi are computed honestly
according to the speciﬁcation of the semi-honest protocol
consistent with Pi’s input and the transcript so far. The next
observation we make is that if party Pi possesses hardware
whose code can be attested by party Pj (and vice-versa),
then Pj can obtain guarantees on the correctness of protocol
messages sent by Pi as long as these messages are computed
and signed by Pi’s hardware. Using these observations, we
can convert a semi-honest secure protocol into one that is
maliciously secure by having every protocol message of Pi
be computed by the trusted hardware that Pi executes. We
shall now describe our techniques in more detail. We ﬁrst
describe the ideal functionality that is assumed out of the
hardware in Section V-A. We then describe our technique
in Section V-B. Finally, we provide an implementation of
Aramis using Intel SGX as the underlying secure hardware.
We explain how Intel SGX can realize the ideal functionality
in Section V-C and challenges in porting semi-honest MPC
protocols to SGX in Section V-D.
A. The attestation ideal functionality Fattest
Description. We formally deﬁne the ideal functionality for
attested executions in Figure 7. The functionality is parameter-
ized by a signing key pair (vk, sk). Let Signsk(m) denote the
signing algorithm on message m and Verifyvk(m, σ) denote
veriﬁcation of signature σ on message m. At a high level,
this functionality allows users to specify a function g to the
ideal functionality once using the Commit command. The
functionality returns a token Tg generated as Signsk(H(g)),
where H is a collision resistant hash function. Note that
this token is publicly veriﬁable given g and vk. Let statectr
be an internal state that the functionality maintains, indexed
by ctr – this state can be maintained by signing it along
with ctr and verifying the signature of the state on every
input message. When the functionality Fattest is initialized, the
initial state state0 is empty (or, ). Subsequent invocations
of the functionality is done on input wctr using the Compute
command. The function g is a deterministic mapping from
(ctr, wctr, rctr, statectr−1) to (yctr, statectr), where rctr is the
required randomness. The functionality picks randomness rctr,
evaluates g and provide a signature on the function output
yctr using the signing key sk. Furthermore, (yctr, statectr) is
always given to party P such that statectr contains rctr in clear
and this ensures that there is no information hidden from P
and we only assume correct execution of g. That is, the ideal
functionality can evaluate functions and provide signed outputs
and these outputs could have anyway been computed by party
P given knowledge of g, wctr, rctr, ctr, statectr, which are all
known to P . Thereby, we only assume that the functionality
will sign the output of g on the appropriate input and not hide
any data from P . This signiﬁcantly weakens what is assumed
from the trusted hardware.
B. Semi-honest security to malicious security
Our technique takes any semi-honest secure MPC protocol
in
into a malicious secure MPC protocol
and converts it
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:36:59 UTC from IEEE Xplore.  Restrictions apply. 
343
Fattest interacts with a party P .
Functionality F (vk,sk)
attest
(H(g)).
input message
On input message (Commit, g) from P ,
1) Record (Commit, state0), where state0 = ;
2) Send (state0,Tg) to P , where Tg = Signsk
3) Ignore further (Commit, g) messages.
from P ,
On
retrieve
rctr
and
obtain
(yctr, statectr) such that statectr contains (yctr, rctr). Send
(yctr, ctr, Signsk
Fig. 7: The Authentication functionality F (vk,sk)
g(ctr, wctr, rctr, statectr−1)
(yctr||ctr), statectr) to P .
(Compute, wctr)
randomness
statectr−1,
compute
required
pick
to
attest
.
attest
attest
attest
to every other party Pj
the F (vk,sk)
attest −hybrid model. The idea is to have messages
in the
sent by every party Pi
semi-honest protocol be computed by the corresponding
F (vki,ski)
functionality interacting with Pi, where (vki, ski)
are keys used by the functionality. These messages can be
veriﬁed by functionality F (vkj ,skj )
interacting with Pj. We
assume that every F (vki,ski)
knows the veriﬁcation key vkj
used by functionalities of all other parties Pj in a reliable
manner. Later, we show how to achieve this through the use
of remote attestation in the context of Intel SGX. We now set
notation and describe the next message function of any semi-
honest secure MPC protocol and how we modify it for our use.
Next message function. Let π(·) be the next message
function of any semi-honest secure MPC protocol. π(·)
takes the following values as input - two party ids i and
j,
input xi, a round number ctr, randomness ri,j,ctr and
Transcripti, which includes the transcript of all messages
sent and received by the party Pi so far. Given these, π(·)
outputs yi,j
ctr , which is the message that Pi must send to
Pj in round ctr and also updates Transcripti appropriately.
Additionally, π(·) takes message yj,i
ctr sent by Pj to Pi at
round ctr and update Transcripti with this message. We now
(·) to incorporate checks
describe how to modify π(·) to π
to detect malicious behavior.
∗
∗
(·),
Modiﬁed next message function. π
function that builds upon π(·) and we describe it for Pi.
1) For ctr = 1, Let xi be the input of Pi in π(·). Then,
(ctr, xi) is stored as state1 (also called as Transcript1
i )
and sent to Pi.
is the modiﬁed
∗
(·) receives a message M = (yj,i
ctr, ctr, σ) from
party Pj, it runs Verifyvkj ((yj,i
ctr, ctr), σ). If veriﬁcation
succeeds, it appends M to Transcripti. Else, Pi aborts.
(·) on input (ctr, statectr−1, j) computes the next mes-
∗
sage from Pi to Pj as follows: It checks that statectr−1
contains a valid transcript of all messages computed so
far. If it veriﬁes, it picks randomness ri,j,ctr and runs
π(ctr, statectr−1, j, ri,j,ctr) to compute next message yi,j
ctr
and updated state statectr (containing ri,j,ctr). Else it
2) When π
3) π
outputs ⊥. Note that statectr−1 already contains input xi,
the input of party Pi.
attest
with the command Commit using function π
Malicious MPC in the Fattest−hybrid model. The malicious
invokes
MPC protocol works as follows: Each party Pi
F (vki,ski)
(·)
described above and sends the received token T (i)
to other
π∗
parties Pj. It receives similar tokens T (j)
from party Pj and
π∗
veriﬁes it under vkj. Party Pi aborts if any of these veriﬁca-
tions fail. If all veriﬁcations succeed, it proceeds with running
∗
π
as described formally in Figure 8.
(·) inside F (vki,ski)
attest
∗
Protocol Protmalicious(P1,··· , Pn)
(i)
attest
attest
attest
to
on
∗)
(H(π
(Commit, π
on (Compute, xi) to get Transcript1
i
receive
to all parties Pj,
∗),T (j)
π∗ )
π∗ ) and sends T (i)
π∗
π∗ from Pj and runs Verifyvkj
Party Pi with input xi interacts with {Pj}j(cid:2)=i and F (vki,ski)
and does the following:
Invokes F (vki,ski)
0 ,T (i)
(state
j (cid:2)= i.
Receives T (j)
for all j ∈ [n] \ i. Aborts if one of these checks fail.
Invokes F (vki,ski)
containing input xi.
When Pi receives a message M = (yj,i
party Pj, it invokes F (vki,ski)
on (Compute, (yj,i
and receives updated transcript or ⊥ (and aborts).
When Pi needs to send next message to Pj it invokes
F (vki,ski)
ctr , ctr, σ)
along with updated transcript and randomness used.
Here, σ is a signature on (yi,j
ctr , ctr) under ski. It sends
(yi,j
ctr , ctr, σ) to Pj.
When Pi has no more messages to send in π(·),
computes the output of the function from Transcripti.
Fig. 8: Malicious secure MPC Protmalicious(P1,··· , Pn).
on (Compute, j) and receives (yi,j
ctr , ctr, σ) from
ctr , ctr, σ))
attest
attest
it
Functionality F f
mpc(P1,··· , Pn)
mpc interacts with parties {P1,··· , Pn} and the adversary S.
F f
On input message xi from Pi record xi and ignore further
xi from Pi
Upon receiving xi from all Pi, i ∈ [n], compute y =
f (x1,··· , xn) and send to S.
Upon receiving (i, Send) or (i,⊥) from S, send y or ⊥
to Pi.
Fig. 9: The MPC functionality F f
mpc.
Malicious Security. Next, we prove that if π is secure against
semi-honest adversaries, then the protocol described in Fig-
ure 8 is an MPC protocol secure against malicious adversaries
with the same corruption threshold. We prove the following
result using the standard simulation paradigm in Appendix E.
Theorem 1. Let π(·) be a semi-honest
secure MPC
protocol
protocol
securely
realizing
Protmalicious(P1,··· , Pn) described in Figure 8 securely
mpc in the F (vki,ski)
−hybrid model (with i ∈ [n])
realizes F f
against malicious adversaries.
F f
mpc.
Then,
attest
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:36:59 UTC from IEEE Xplore.  Restrictions apply. 
344