the password at runtime.
Download from finelybook PI:EMAIL
1034
Click here to view code image
public partial class AdventureWorksEntities
{
    public AdventureWorksEntities(string password)
        : base("name=AdventureWorksEntities")
    {
        this.Database.Connection.ConnectionString +=
$";Password=";
    }
}
Creating and using a REST web service
You have created an entity model that provides operations to retrieve and
maintain customer information. The next step is to implement a web service
so that a UWP app can access the entity model.
With Visual Studio 2017, you can create a web service in an ASP.NET
web app based directly on an entity model generated by the Entity
Framework. The web service uses the entity model to retrieve data from a
database and update the database. You create a web service by using the Add
Scaffold wizard. This wizard can generate a web service that implements the
REST model, which uses a navigational scheme to represent business objects
and services over a network and the HTTP protocol to transmit requests to
access these objects and services. A client app that accesses a resource
submits a request in the form of a URL, which the web service parses and
processes. For example, Adventure Works might publish customer
information, exposing the details of each customer as a single resource, by
using a scheme similar to this:
Click here to view code image
http://Adventure-Works.com/DataService/Customers/1
Accessing this URL causes the web service to retrieve the data for
customer 1. This data can be returned in a number of formats, but for
portability, the most common formats include XML and JavaScript Object
Notation (JSON). A typical JSON response generated by a REST web service
request issuing the previous query looks like this:
Click here to view code image
{
Download from finelybook PI:EMAIL
1035
    "CustomerID":1,
    "Title":"Mr",
    "FirstName":"Orlando",
    "LastName":"Gee",
    "EmailAddress":"PI:EMAIL",
    "Phone":"245-555-0173"
}
The REST model relies on the app that accesses the data to send the
appropriate HTTP verb as part of the request to access the data. For example,
the simple request shown previously should send an HTTP GET request to
the web service. HTTP supports other verbs as well, such as POST, PUT, and
DELETE, which you can use to create, modify, and remove resources,
respectively. Writing the code to generate the appropriate HTTP requests and
parsing the responses returned by a REST web service all sounds quite
complicated. Fortunately, the Add Scaffold wizard can generate most of this
code for you.
In the following exercise, you will create a simple REST web service for
the AdventureWorks entity model. This web service will make it possible for
a client app to query and maintain customer information.
Create the AdventureWorks web service
1. In Visual Studio, in the AdventureWorksService project, right-click the
Controllers folder, point to Add, and then click New Scaffolded Item.
2. In the Add Scaffold wizard, in the middle pane, click the Web API 2
Controller With Actions, Using Entity Framework template, and then
click Add.
Download from finelybook PI:EMAIL
1036
3. In the Add Controller dialog box, in the Model Class drop-down list,
select Customer  (AdventureWorksService.Models). In the Data Context
Class drop-down list, select AdventureWorksEntities
(AdventureWorksService.Models). Select the Use Async Controller
Actions check box. Verify that the Controller name is set to
CustomersController, and then click Add.
In a web service created by using the ASP.NET Web API template, all
incoming web requests are handled by one or more controller classes,
and each controller class exposes methods that map to the different types
Download from finelybook PI:EMAIL
1037
of REST requests for each of the resources that the controller exposes.
For example, the CustomersController looks like this:
Click here to view code image
public class CustomersController : ApiController
{
    private AdventureWorksEntities db = new
AdventureWorksEntities();
    // GET: api/Customers
    public IQueryable GetCustomers()
    {
        return db.Customers;
    }
    // GET: api/Customers/5
    [ResponseType(typeof(Customer))]
    public async Task GetCustomer(int id)
    {
        Customer customer = await db.Customers.FindAsync(id);
        if (customer == null)
        {
            return NotFound();
        }
        return Ok(customer);
    }
    // PUT: api/Customers/5
    [ResponseType(typeof(void))]
    public async Task PutCustomer(int id,
Customer customer)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }
        if (id != customer.CustomerID)
        {
            return BadRequest();
        }
        db.Entry(customer).State = EntityState.Modified;
        try
        {
            await db.SaveChangesAsync();
        }
Download from finelybook PI:EMAIL
1038
        catch (DbUpdateConcurrencyException)
        {
            if (!CustomerExists(id))
            {
                return NotFound();
            }
            else
            {
                throw;
            }
        }
        return StatusCode(HttpStatusCode.NoContent);
    }
    // POST: api/Customers
    [ResponseType(typeof(Customer))]
    public async Task PostCustomer(Customer
customer)
    {
    }
    // DELETE: api/Customers/5
    [ResponseType(typeof(Customer))]
    public async Task DeleteCustomer(int id)
    {
        ...
    }
    ...
}
The GetCustomers method handles requests to retrieve all customers,
and it satisfies this request by simply returning the entire Customers
collection from the Entity Framework data model that you created
previously. Behind the scenes, the Entity Framework fetches all the
customers from the database and uses this information to populate the
Customers collection. This method is invoked if an app sends an HTTP
GET request to the api/Customers URL in this web service.
The GetCustomer method (not to be confused with GetCustomers) takes
an integer parameter. This parameter specifies the CustomerID of a
specific customer, and the method uses the Entity Framework to find the
details of this customer before returning it. GetCustomer runs when an
app sends an HTTP GET request to the api/Customers/n URL, where n
is the ID of the customer to retrieve.
Download from finelybook PI:EMAIL
1039
The PutCustomer method runs when an app sends an HTTP PUT
request to the web service. The request specifies a customer ID and the
details of a customer, and the code in this method uses the Entity
Framework to update the specified customer with the details. The
PostCustomer method responds to HTTP POST requests and takes the
details of a customer as its parameter. This method adds a new customer
with these details to the database (the details are not shown in the
preceding code sample). Finally, the DeleteCustomer method handles
HTTP DELETE requests and removes the customer with the specified
customer ID.
Note The code generated by the Web API template optimistically
assumes that it will always be able to connect to the database. In
the world of distributed systems, where the database and web
service are located on separate servers, this might not always be
the case. Networks are prone to transient errors and timeouts; a
connection attempt might fail because of a temporary glitch and
succeed if it is retried a short time later. Reporting a temporary
glitch to a client as an error can be frustrating to the user. If
possible, it might be better to silently retry the failing operation as
long as the number of retries is not excessive (you don’t want the
web service to freeze if the database is really unavailable). For
detailed information on this strategy, see “Cloud Service
Fundamentals Data Access Layer-Transient Fault Handling” at
http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-
service-fundamentals-data-access-layer-transient-fault-
handling.aspx.
The ASP.NET Web API template automatically generates code that
directs requests to the appropriate method in the controller classes, and
you can add more controller classes if you need to manage other
resources, such as products or orders.
Download from finelybook PI:EMAIL
1040
Note For detailed information on implementing REST web
services by using the ASP.NET Web API template, see “Web API”
at http://www.asp.net/web-api.
You can also create controller classes manually by using the same
pattern as that shown by the CustomersController class—you do not
have to fetch and store data in a database by using the Entity
Framework. The ASP.Net Web API template contains an example
controller in the ValuesController.cs file that you can copy and augment
with your own code.
4. In the CustomersController class, modify the statement that creates the
AdventureWorksEntities context object to use the constructor that takes a
password as its parameter. As the argument to the constructor, provide
the administrator password that you specified when you created the
database. (In the following code sample, replace the string
YourPassword with your own password.)
Click here to view code image
public class CustomersController : ApiController
{
    private AdventureWorksEntities db = new
AdventureWorksEntities("YourPassword");
    // GET: api/Customers
    public IQueryable GetCustomers()
    {
        return db.Customers;
    }
    ...
}
Note In the real world, you should never hard-code a password in
this way. Instead, you should protect the password by storing it in
an encrypted section of the web.config file for the web service. For
Download from finelybook PI:EMAIL
1041
more information, see Encrypting Configuration Information
Using Protected Configuration at
https://msdn.microsoft.com/library/51cdfe5b-9d82-458c-94ff-
c551c4f38ed1.
5. In the Controllers folder, right-click the ValuesController.cs file, and
then click Delete. In the Message box, click OK to confirm that you
want to delete this file.
You will not be using the example ValuesController class in this
exercise.
6. In Solution Explorer, right-click the AdventureWorksService project,
point to Debug and then click Start New Instance.
This action starts the IISExpress web server which hosts the web
service. You will see the Diagnostic Tools pane in Visual Studio to
indicate that the website is running, but there will be no other
indications; you need to navigate to the website using a browser to
verify that it is functioning correctly.
7. Open Microsoft Edge, and move to the URL
http://localhost:50000/api/Customers. This address should cause the
web service to receive an HTTP Get request for customers, which
should run the GetCustomers method inside your code. The result is a
list of all customers, presented as a JSON array:
Download from finelybook PI:EMAIL
1042
8. Change the URL to http://localhost:50000/api/Customers/5. This
causes the web service to run the GetCustomer (singular) method,
passing it the parameter 5. You should see the details for customer 5
displayed in the browser:
9. Close Microsoft Edge and return to Visual Studio.
10. On the Debug menu, click Stop Debugging.
You can now deploy the web service to Azure. You can do this by using
the Publish Web wizard available with Visual Studio 2017 to create a web
app in the cloud and upload the web service to this app.
Deploy the web service to the cloud
Download from finelybook PI:EMAIL
1043
1. On the View menu, click Server Explorer.
2. In Server Explorer, right-click Azure, and then click Connect to
Microsoft Azure Subscription.
3. In the Sign In To Your Account dialog box, enter the name and
password for your Azure account and log in to Azure.
4. In Solution Explorer, right-click the AdventureWorksService project
and then click Publish.
The Publish Web wizard starts.
5. Under Select A Publish Target, click Microsoft Azure App Service,
click Create New, and then click Publish.
6. In the Create App Service dialog box, accept the default App Name,
select your Subscription, and set the Resource Group to awgroup (you
created this resource group earlier, using the Azure portal). Next to the
App Service Plan box, click New.
Download from finelybook PI:EMAIL
1044
7. In the Configure App Service Plan dialog box, set the Location to your
nearest site, in the Size drop-down list box select Free, and then click
OK.
Download from finelybook PI:EMAIL
1045
The App Service Plan determines the resources available for your API
app in the cloud. Behind the scenes, Microsoft hosts your API app on a
web server, or a web server farm, depending on the size of the plan that
you specify. If you are building a commercial application that is
intended to handle many thousands of requests a second, you will likely
require a plan that provides large-scale resources. However, you will be
charged accordingly. For this application, you should select the Free
plan, which provides limited throughput and memory, but it is fine for
prototyping and building small web services.
Important If you select a size other than Free, you will be charged
for use, and some of the app service plans can cost several hundred
Download from finelybook PI:EMAIL
1046
dollars a month!
8. Back in the Create App Service dialog box, click Create.
The Azure API app should be deployed to the cloud. The browser
should open and display a “getting started” page that provides some
links to documentation about using Azure API apps.
9. Close the web browser and return to Visual Studio.
The next phase of this journey is to connect to the web service from the
Customers UWP app and then use the web service to fetch some data. In the
good old days, this process would involve generating HTTP REST requests,
sending them to the web service, waiting for the results, and then parsing the
data returned so that the app can display it (or handle any errors that might
have occurred). However, one of the beauties of deploying a REST web
service as an Azure API app is that Azure can generate a bunch of metadata
that describes your web service and the operations it provides. You can use
the REST API Client wizard in Visual Studio to query this metadata, and the
wizard will generate an object model that connects to the web service and
sends it requests. You use this object model to insulate your application from
the low-level details required to send and receive data across the web. As
such, you can focus on the business logic that displays and manipulates the
objects published through the web service. You will use these classes in the
following exercise. You will also use the JSON parser implemented by the
Json.NET package. You will have to add this package to the Customers
project.
Important This exercise retrieves the data for every customer. This
approach is fine for systems that utilize a small amount of data, as it
prevents repeated network access. However, in a large-scale system
(such as a multinational e-commerce application), you should be more
selective. If the database contains a large volume of data, you will likely
swamp the user’s device running the application. A better approach is to
use paging, whereby data is fetched in blocks (maybe of 200 records at
Download from finelybook PI:EMAIL
1047
a time). The web service would need to be updated to support this
approach, and the ViewModel in the app would need to manage
fetching blocks of records transparently. This is left as an exercise for
the reader.
Fetch data from the AdventureWorks web service
1. In Solution Explorer, in the Customers project, right-click the
DataSource.cs file and then click Delete. In the message box, click OK
to confirm that you want to delete the file.
This file contained the sample data used by the Customers app. You are
going to modify the ViewModel class to fetch this data from the web
service, so this file is no longer required.
2. Right-click the Customers project, and then click Manage NuGet
Packages.
3. In the NuGet Package Manager: Customers window, make sure that the
Filter drop-down list box is set to All, and then type Json.NET in the
search box.
4. In the pane displaying the search results, select the Newtonsoft.Json
package. In the right pane, set the Action to Install, and then click
Install.
5. In the Preview window, click OK.
6. In the License Acceptance window, review the license information, and
then click I Accept if you wish to continue (if you don’t, the package
won’t be installed and you won’t be able to complete this exercise!).
7. Wait for the package to be installed, and then close the NuGet Package
Manager: Customers window.
8. In Solution Explorer, right-click the Customers project again, point to
Add, and then click REST API Client.
This action starts the wizard that generates the object model that your
application can use to connect to the web service.
Download from finelybook PI:EMAIL
1048
9. In the Add REST API Client window, click Select Azure Asset.
10. In the App Service window, select your Azure subscription. In the
Search box, expand the awgroup resource group, select the web service
that you created in the previous exercise, and then click OK.
11. Back in the Add REST API Client window, click OK.
Visual Studio will connect to Azure and download the metadata for the
web service, and also install several additional NuGet packages
containing libraries required to support the code generated by the
wizard. Wait for the operation to complete.
12. In Solution Explorer, you should see a new folder named after your web
service, AdventureWorksServicennnnnnnnn. Expand this folder, and
also expand the Models folder that this folder contains.
13. In the Models folder, double-click the file Customer.cs to display it in
the Code and Text Editor window. This file contains a class named
Customer, which models the data retrieved from the web service. It
Download from finelybook PI:EMAIL
1049
contains fields and properties for each of the attributes you specified for
the Customer entity when you constructed the web service using the
Entity Framework, together with a constructor that you can use to create
a new Customer object.
14. In the AdventureWorksServicennnnnnnnn folder, double-click the
CustomersOperations.cs file and review it in the Code and Text Editor
window. This file contains the code that interacts with the various REST
operations that your UWP application uses to send and receive data from
the web service. Amongst other things, you should see static methods
named GetCustomersWithHttpMessagesAsync,
PostCustomersWithHttpMessagesAsync,
GetCustomerWithHttpMessagesAsync,
PutCustomerWithHttpMessagesAsync, and
DeleteCustomerWithHttpMessagesAsync. Each of these methods
contains the low-level code required to construct and send HTTP
requests and handle the results. You are welcome to examine this code
in detail, but it is not necessary to understand it, and you should not
change it; if you regenerate the REST web client code by using the
Visual Studio wizard later, any changes you make will be lost.
15. Double-click the CustomersOperationsExtension.cs file and view it in
the Code and Text Editor window. This file contains a series of
extension messages for the CustomerOperations class. Their purpose is
to provide a simplified programmatic API. The
CustomerOperationsExtension class has pairs of methods that wrap the
corresponding operations in the CustomerOperations class and perform
the necessary task handling and cancellation processing. For example,
the CustomerOperationsExtension class has a pair of methods named
GetCustomers, and GetCustomersAsync, both of which invoke the
GetCustomersWithHttpMessagesAsync method in the
CustomerOperations class. The Customers UWP app will make use of
these extension methods.
16. Double-click the AdventureWorksServicennnnnnnnn.cs file and view it
in the Code and Text Editor window. This file implements the
AdventureWorksServicennnnnnnnn class which you use to establish a
connection to the web service. The bulk of this class comprises a series
of pubic and protected constructors, which you can use to specify the
Download from finelybook PI:EMAIL
1050
URL of the web service, security credentials, and other options.
As it stands, the web service does not implement any form of
authentication; anyone who knows the URL of the web service can send
it requests. In a real-world web service exposing company-confidential
information, would be unacceptable. However, for this application, we
will omit this task as the web service only contains sample data.
Although the default configuration for the Azure API App is for
authentication to be disabled (see the sidebar Azure API App Security),
the public constructors for the AdventureWorksServicennnnnnnnn class
expect you to provide details that the web service can use to authenticate
you. The rationale behind this apparent anomaly is that deciding not to
use authentication in an app should be a conscious decision and not just
because you forgot to do so! However, the