  *)v2	
  +	
  4)	
  )	
  { 
  … 
} 
Google	
  Chrome	
The	
  Most	
  Security	
  Browser? 
ASLR	
  in	
  Google	
  Chrome 
VirtualMemory::VirtualMemory(size_t	
  size,	
  size_t	
  alignment)	
  :	
address_(NULL),	
  size_(0)	
  {	
  ASSERT(IsAligned(alignment,	
  staLc_cast(OS::AllocateAlignment())));	
  size_t	
  request_size	
  =	
  RoundUp(size	
  +	
  alignment,	
  staLc_cast(OS::AllocateAlignment()));	
  void*	
  address	
  =	
  ReserveRegion(request_size);	
  if	
  (address	
  ==	
  NULL)	
  return;	
  …	
void*	
  VirtualMemory::ReserveRegion(size_t	
  size)	
  {	
  return	
  RandomizedVirtualAlloc(size,	
  MEM_RESERVE,	
  PAGE_NOACCESS);	
} 
const	
  int	
  kPageSizeBits	
  =	
  20;	
staLc	
  void*	
  RandomizedVirtualAlloc(size_t	
  size,	
  int	
  acLon,	
  int	
protecLon)	
  {	
  if	
  (protecLon	
  ==	
  PAGE_EXECUTE_READWRITE	
  ||	
  protecLon	
  ==	
  PAGE_NOACCESS)	
  {	
  for	
  (size_t	
  arempts	
  =	
  0;	
  base	
  ==	
  NULL	
  &&	
  arempts	
  Predictable	
•  Low	
  Bits 
–  Can’t	
  determine	
  the	
  values 
–  Paged	
  memory	
  management	
–  4KB	
  page 
–  Heap	
  manager	
  -­‐>	
  Performance 
•  Heap	
  spray	
  &	
  heap	
  feng	
  shui	
  -­‐>	
  Useful 
ASLR’s	
  Dilemma	
  1 
Garbage	
  Collect 
•  V8	
  Tagged	
  Pointers	
  GC	
Data	
  Structure 
•  L	
  JSTypedArray	
  length	
–  J	
  IE	
  11	
•  J	
  JSArrayBuﬀer	
  length	
  +	
  JSTypedArray	
  iniTalized	
  =	
  Exploitable	
RUNTIME_FUNCTION(MaybeObject*,	
    RunLme_TypedArrayIniLalize)	
  {	
  …	
  holder-­‐>set_buﬀer(*buﬀer);	
  holder-­‐>set_byte_oﬀset(*byte_oﬀset_object);	
  holder-­‐>set_byte_length(*byte_length_object);	
} 
  FixedArray	
  Start: 
0:000>	
  dd	
  3ﬀ08080	
  L110	
3ﬀ08080	
  0d108121	
  00007ﬀc	
  3ﬀ18aa9	
  3ﬀ18ad1 
3ﬀ08090	
  3ﬀ18af9	
  3ﬀ18b21	
  3ﬀ18b49	
  3ﬀ18b71 
3ﬀ080a0	
  3ﬀ18b99	
  3ﬀ18bc1	
  3ﬀ18be9	
  3ﬀ18c11 
3ﬀ080b0	
  3ﬀ18c39	
  3ﬀ18c61	
  3ﬀ18c89	
  3ﬀ18cb1 
ArrayBuﬀer	
  Start: 
0:006>	
  dd	
  3ﬀ08080+b0000	
3•8080	
  2f20a011	
  3db080a1	
  3db080a1	
  4a4d2800 
3•8090	
  00000080	
  00000000	
  3•8f59	
  214feb7d 
3•80a0	
  00000000	
  00000000	
  |	
  2f20a011	
  3db080a1 
3•80b0	
  3db080a1	
  4a4d1040	
  00000080	
  00000000 
3•80c0	
  3ed1bd19	
  214fdb29	
  00000000	
  00000000	
3•80d0	
  2f20a011	
  3db080a1	
  3db080a1	
  4a4d1080 
3•80e0	
  00000080	
  00000000	
  3•80a9	
  214fdb55 
3•80f0	
  00000000	
  00000000	
  2f20a011	
  3db080a1 
ASLR’s	
  Dilemma	
  2 
•  OOB	
  write	
– Heap	
  feng	
  shui	
  =>	
  Fixed	
  relaTve	
  distance	
– RandomizaTon↑	
  =>	
  Performance↓ 
•  Some	
  objects	
  keep	
  the	
  pointers 
– Object	
  with	
  virtual	
  funcTon 
•  Vtbl	
  address	
– Array 
•  Object	
  address	
– Program	
  =>	
  InformaTon	
  User	
  token	
•  Load	
  external	
  code 
– AcTveX	
– DLL	
Bypass	
  DEP 
•  Data	
  =>	
  Code 
– VirtualProtect	
– VirtualAlloc	
•  Code	
  in	
  memory	
– ROP	
– Ret2libc	
•  Data	
  -­‐-­‐>	
  Code 
– JIT	
  Spray	
– Construct	
  funcTon	
  template	
  in	
  JIT	
  pages	
Bypass	
  DEP	
  in	
  Chrome 
•  L	
  Chrome	
  AcTveX	
•  J	
  V8	
  JIT: Javascript	
  -­‐>	
  Machine	
  code 
OwnPtr	
  scriptData	
  =	
    V8ScriptRunner::precompileScript(code);	
v8::Handle	
  script	
  =	
    V8ScriptRunner::compileScript(code,	
  source.url(),	
    source.startPosiLon(),	
  scriptData.get()); 
result	
  =	
  V8ScriptRunner::runCompiledScript(script,	
  m_frame-­‐>document(),	
  m_isolate); 
JIT	
  Code	
  Read,	
  Wri>en	
  and	
  Executed 
0:007>	
  !address	
  4029540 
Usage:	
Base	
  Address:	
  0400a000 
End	
  Address:	
  04082000 
Region	
  Size:	
  00078000 
State:	
  00001000
  MEM_COMMIT 
Protect:	
  00000040
  PAGE_EXECUTE_READWRITE 
Type:	
  00020000
  MEM_PRIVATE 
AllocaLon	
  Base:	
  04000000 
AllocaLon	
  Protect:	
  00000001
  PAGE_NOACCESS 
Bypass	
  DEP	
  in	
  Chrome 
•  Exploit	
  Idea: 
– Shellcode	
  -­‐>	
  JIT	
  block	
– EIP	
  -­‐>	
  Shellcode 
•  Overwrite	
  the	
  vPtr	
  +	
  call	
  vFunc 
•  JIT	
  block	
  -­‐>	
  Execute	
  in	
  the	
  future	
FuncTon	
  JIT	
  Compile	
  and	
  Run 
//	
  Get	
  the	
  codeEntry	
  stub	
  of	
  funcLon,	
  and	
  then	
  execute	
  the	
  codeEntry	
  stub 
RUNTIME_FUNCTION(MaybeObject*,	
  LoadIC_Miss)	
  { 
  HandleScope	
  scope(isolate);	
  LoadIC	
  ic(IC::NO_EXTRA_FRAME,	
  isolate); 
  Handle	
  receiver	
  =	
  args.at(0); 
  Handle	
  key	
  =	
  args.at(1); 
  ic.UpdateState(receiver,	
  key); 
  return	
  ic.Load(receiver,	
  key);	
} 
//	
  return	
  JSFuncLon 
EAX	
  =	
  31121615 
3E328B5A	
  jmp	
  dword	
  ptr	
  [edi+0Bh] 
EDI	
  =	
  31121615 
jmp	
  JSFuncLon.codeEntry 
//	
  Compile	
  the	
  funcLon 
RUNTIME_FUNCTION(MaybeObject*,	
  RunLme_CompileUnopLmized)	
  { 
  Handle	
  code	
  =	
  Compiler::GetUnopLmizedCode(funcLon); 
  funcLon-­‐>ReplaceCode(*code); 
  return	
  *code; 
}	
JSFuncLon.codeEntry	
  =	
  code	
  +	
  0x3f	
JSFuncLon	
  =	
  31121615 
>dd	
  0x31121614 
0x31121614	
  23014629	
  2fe080a1	
  2fe080a1	
  26262020	
0x31121624	
  3c1080a1	
  31121095	
  31108081	
  2fe080a1	
0x31121634	
  3c108091	
  23008cb1	
  31121615	
  23008cb1	
0x31121644	
  31121615	
  23013021	
  2fe080a1	
  2fe080a1 
EAX	
  =	
  26261FE1 
2422975E	
  lea	
  eax,[eax+3Fh]	
24229761	
  jmp	
  eax	
EAX	
  =	
  26262020 
jmp	
  code	
  +	
  0x3f 
Bypass	
  CFI 
•  Calculate	
  staTc	
  PE	
•  JIT	
  -­‐>	
  Dynamical 
Demo 
JIT	
  MiTgaTon 
•  Chris	
  Evans	
– Captain	
  Google	
  Security?	
– Captain	
  America? 
– “JIT	
  engines	
  are	
  a	
  pain”	
– “Ban	
  syscalls”	
•  W^X	
  can’t	
  help! 
Binary	
  hacker	
  is	
  boring?	
Cross-­‐disciplinary	
  AQack	
跨界攻击 
•  The	
  same-­‐origin	
  policy 
UXSS 
bool	
  SecurityOrigin::canAccess(const	
  SecurityOrigin*	
  other)	
  const	
  { 
… 