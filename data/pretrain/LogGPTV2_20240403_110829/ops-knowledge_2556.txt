User: 请回答以下安全问题为什么Chrome不允许通过扩展来修改这些标题？Chrome WebRequests API提到，onBeforeSendHeaders事件无法使用特定的请求头，这意味着扩展无法读取和/或修改这些头。以下是文档摘录：
以下标头当前未提供给onBeforeSendHeaders事件。这份清单既不能保证完整，也不能保证稳定。
批准
缓存控制
联系
内容长度
主办
如果修改自
如果不匹配
如果范围
部分数据
普拉格玛
代理授权
代理连接
传输编码
是否有安全原因禁止扩展读取或写入这些内容？如果一个扩展可以读取/写入这些值，它怎么会表现出恶意？
澄清：我知道为什么读访问其中一些是个坏主意，尤其是任何具有身份验证数据的标头。然而，其他标题，如主机、连接或内容长度，对我来说完全是个谜。
此外，我不清楚为什么扩展完全无法访问其中的某些标头，而不允许设置值或附加值，即使未授予读取访问权限。

Assistant: 我同意OP的观点，即在安全性方面允许更广泛的数据的同时，仅阻止对这些标头的访问是没有意义的。一个恶意插件在没有它们的情况下可以造成如此多的破坏。
从API文档的阅读来看，似乎不允许访问这些标头的原因不一定是出于安全考虑，而是因为当前的Chrome引擎是如何工作的。听起来Chrome的请求处理管道在API修改完成后仍在继续。其中一个方面是Chrome如何管理网络请求和缓存。由于请求管道中的下游组件可以做出不同的决定并更改这些头，我猜这就是为什么它甚至不允许您读取它们b/c——它不能保证它们保持不变。
这是基于他们在chrome.WebRequest文档中的解释
（*）请注意，web请求API提供了
网络堆栈到扩展。在内部，一个URL请求可以
分成几个HTTP请求（例如获取单个字节
范围从大文件）或可以由网络堆栈处理
而不与网络通信。因此，API可以
不提供发送到网络的最终HTTP报头。对于
例如，所有与缓存相关的头对于
扩大
以下标头当前未提供给
onBeforeSendHeaders事件。此列表不能保证完整
也不稳定。
…OP正在质疑的标题列表。。。。
如果您在页面中进一步阅读，它会对缓存问题进行更多的解释。在我看来，Chrome不喜欢公开请求管道的某些部分（特别是影响网络通信决策的事情，包括缓存），可能是出于一些好的技术原因（可能需要进行重大设计更改）。
由于这些隐藏的管道部分在插件修改完成后可能会做出不同的决定，Chrome不允许您阅读它们，因为下游管道组件可能仍会更改它们。看看它是如何谈论“；在存储器高速缓存中”；对API不可见。这听起来像是Chrome的设计挑战（或者不让插件影响其网络性能的偏好）。所以我得出结论，这不一定是因为安全问题。
缓存：Chrome采用了两种缓存——一种是磁盘上的缓存，另一种是非常快的缓存
内存缓存中。内存中缓存的生存期附加到
渲染过程的生存期，大致对应于选项卡。
从内存中缓存应答的请求对不可见
web请求API。如果请求处理程序更改其行为（对于
例如，请求被阻止的行为）
简单的页面刷新可能不尊重这种已更改的行为。制作
确保行为更改通过，请调用handlerBehaviorChanged（）
以刷新内存中的缓存。但不要经常这样做；冲洗
缓存是一项非常昂贵的操作。你不需要打电话
注册或注销事件后的handlerBehaviorChanged（）
听众。