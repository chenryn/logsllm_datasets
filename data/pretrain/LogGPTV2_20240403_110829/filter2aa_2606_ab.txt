代码了，后来二哥又给提示说，最终的利用链就是 setURI，并且不需要用很复杂的分析技术，
只是看了一些官方的 demo 就复现成功了，这个意料之中又让人惊喜的结果又让我对复现
这个漏洞产生了兴趣。 
二哥所说的官方的 demo 我到现在都没找到，但是却给了我一些提示，单纯的看代码并
不是最高效的解决方案，可以和一些实际 demo 相结合，特别是对于当前调试有一些技术上
障碍的情况下。首先我们明确最终的利用链是 
org.apache.batik.swing.JSVGCanvas-->setURI 
这个方法的功能是设置 SVG 图片的地址，远程加载 SVG 图片。熟悉前端攻防的人其实
对 SVG 是不陌生的，这是一个经常用于特殊场景下 XSS 绕过的标签。如何来利用 SVG 来加
载执行 JAVA 代码呢？这在网上是肯定搜索不到的，但是如何利用 SVG 来加载 Javascript 代
码，这个是很容易找到的，如图 3.3 所示？ 
图 3.3 通过 SVG 来加载 javascript 代码 
这个代码很容易让我们想到，把 JS 的代码按照 ScriptEngineManager 的方式转化为 java
代码是不是可以执行呢，如图 3.4 所示？ 
图 3.4 把 JS 代码转化为 JAVA 代码 
如果我在独立的环境中来执行对应的代码，是可以正常执行，确实是可以弹出计算器的，
如图 3.5 所示。 
图 3.5 本地通过 script 标签来执行 java 代码 
但是把这个代码放在 CS 的环境中来运行，却发现并不能正常运行，如图 3.6 所示。 
图 3.6 在 CS 环境中运行上面的代码报错 
从上面的代码报错可以看出 CS 环境中并没有运行代码所需的 javascript 相关的库，所
有爆了 ClassNotFoundException 的异常，这样当然是没有办法直接利用的。但是这个方式
仍然可以帮助我们在 debug 的时候发现整个利用链中最关键的一个方法调用 
org.apache.batik.bridge.BaseScriptingEnvironment 类的 loadScript 方法，如图 3.7 所示。 
图 3.7loadScripts 方法加载执行代码 
从 上 面 代 码 的 逻 辑 可 以 看 出 通 过 获 取 的 type 来 走 不 通 的 分 支 流 程 ， 默 认 为
text/ecmascript。这种方式可以通过 javascript 库来执行命令，但是由于默认 CSjar 包中并没
有 javascript 库，导致这种方式并不能执行利用，但是从代码中我们可以发现还有一个分支
流程是 type=application/java-archive 的情况，如果进入这个分支流程，会是一个什么逻辑
呢，如图 3.8 所示？ 
图 3.8application/java-archive 分支的代码加载流程 
从代码中可以看出这里逻辑大体上是加载一个远程 URL 地址的 jar 包，然后 loadClass
加载 var13 对应的类。如果整个过程完成可控，那么我们就可以通过 URLClassLoader 来达
到 RCE 的效果，那么我们整个利用链就活了。 
跟踪 getXLinkHref 来看具体的 URL 地址是如何取出的，如图 3.9 所示。 
图 3.9 获取远程待加载的 URL 地址 
从图中可以看出 URL 地址来自于 namespaceURL 为 http://www.w3.org/1999/xlink 的
href 属性。按照相似的办法来构造 SVG 文件的内容，如图 3.10 所示。 
图 3.10 改造后的 SVG 文件内容 
在此之后我们也只是进入了对应的流程中，还需要解决几个对应的条件判断，如图 3.11
所示。 
图 3.11 要最终 RCE 需要满足的条件 
其中条件 1 是 checkCompatibleScriptURL，跟进对应的方法，一直对应的跟下去，就会
发现最终会进入到 DefaultScriptSecurity，如图 3.12 所示。其中 var2 和 var3 分别对应远程
svg 文件地址和远程 jar 包地址，要求这两个地址必须 host 相同，这就很好办到了。 
图 3.12checkCompatibleScriptURL 检查的核心逻辑 
条件 2 和条件 3 可以一直来看，都是检查配置文件 META-INF/MANIFEST.MF 中的配置
项，我下意识的以为 META-INF/MANIFEST.MF 是指 CS 的 jar 包中的配置，所以一直觉得这
里的判断是不可能绕过的，后来才知道原来这个 META-INF/MANIFEST.MF 是指远程 jar 包中
的配置文件，和 CS 无关，属于我们可控的部分，那么整个攻击链就完全打通了。我们需要
修改远程 jar 包中的 META-INF/MANIFEST.MF 文件，配置其中 Script-Handler 的值为需要远
程加载的恶意类的类名，如图 3.13 所示。 
图 3.13 指定要远程加载的恶意类名称 CodeSource 
至于 CodeSource.class 文件，则是经过编译之后的恶意类，只需要在静态代码块或者无
参构造函数中填写对应的恶意代码即可，如图 3.14 所示。 
图 3.14 最终执行的恶意类 CodeSource 
最后我们完整的来总结一下整个利用过程，需要准备好恶意的 SVG 文件和恶意的 jar 包，
jar 包中包含恶意类 CodeSource（其他名字也可以，但是必须和配置文件中的名字对应），
放置在一台服务器上，恶意的 jar 包中需要修改 META-INF/MANIFEST.MF 配置文件。最后我
们来看一下运行的效果，如图 3.15 所示。这里面会有一些报错，但是实际上不影响执行，
要不报错就把恶意类继承 ScriptHandler 就可以了。 
图 3.15 利用 object 标签加载远程加载恶意类 
0x04 回归 
为了保持故事的完整性，我还是继续对 CS 利用部分进行了复现，这部分的内容相对而
言漂亮鼠大佬已经在文章中给出了，我只是简单的说几句。 
大佬给出了两种利用方式，一种是在首页通过 frame 标签来绕过首页 117 个字节的长
度限制。但是我在实际测试的过程中发现无论我怎么写都会在 setParent 方法中报异常转换
的错，如图 4.1 所示。本来想继续死磕一下这个 frame 的原理，但是后来发现另一种方式直
接就成功了，所以这里暂时忽略。 
图 4.1 使用 farme 标签报错 
另外一种方式是通过 hook windows api 的方式来传输恶意 payload，参照大佬的步骤直
接就可以复现了，如图 4.2 所示。 
图 4.2 复现最终 CS RCE 合影留念 
0x04 结论 
这个漏洞号称是脚本小子杀手，喜欢用 CS 的我瑟瑟发抖。复现这个漏洞也是一个很有
意思的事情，让我学到了很多关于 Swing 和 SVG 的知识，再次感谢二哥在复现过程中给予
的支持。 
最后，我还想提出一个观点，java 和 javascript 是什么关系？雷锋和雷峰塔的关系？