Constant blinding
SunSpider
-1.94%
-1.36%
Kraken
Octane
-0.829% -0.404%
2.65%
2.93%
G. Mean
-1.06%
1.39%
SunSpider
Kraken
Octane
1.62% 0.456% 0.265%
1.62%
6.02%
4.39%
Call frame frandomization
-1.68%
-0.199%
0.324%
-0.523%
0.138%
-2.26% -1.05%
Random NOP insertion
-0.762%
2.12%
1.44%
Base offset randomization
-2.38%
-0.207%
-0.846%
0.922%
-1.15%
G. Mean
0.777%
3.99%
-1.06%
1.59%
1.67%
1.76%
1.35%
0.498%
0.302% 0.223%
0.341%
All
1.71%
5.70%
6.33%
4.56%
4.44%
5.48%
4.71%
4.88%
TABLE IV: Estimated relative success probabilities for concrete attacks against single diversiﬁcation defenses. Lower values
indicate better mitigation.
Blazakis 2010 [7] (x86-32)
Lian et al. 2015 [17] (ARM)
ARM V8 gadget chaining (§III-B)
SpiderMonkey self-sustaining ARM payload (§III-C)
Register
randomization
92.9%
1.79%
0.909%
2.51 × 10−5%
Constant
blinding
Call frame
randomization
Random NOP
insertion
Base offset
randomization
6.84 × 10−47%
1.53 × 10−3%
4.15 × 10−461%
100%
100%
100%
6.25%
100%
30.1%
3.74%
3.70%
7.95 × 10−21%
100%
0.391%
0.229%
100%
2 bytes long when XORing against any other register. The
attacker can therefore assume with highest probability that the
XOR opcode will be 2 bytes long and adjust her payload to
skip over a 2-byte intended instruction opcode.
Random NOP insertion provides good protection across the
board by both disrupting the unintended instruction streams
used by Blazakis’ attack and the self-sustaining ARM payload
as well as diversifying the location of useful code gadgets used
by [17] and our new V8 attack. Base offset randomization, on
the other hand, only defends against the latter pair of attacks.
Base offset randomization offers better defense than NOP
insertion against a hypothetical attack in which the attacker
needs to predict the offset of an instruction near the beginning
of a unit of code compilation. If the instruction is one of the
ﬁrst 3729 in a unit of code compilation, the attacker has a
greater probability of predicting the number of random NOPs
inserted before it (and by proxy its offset) than predicting the
base offset randomization of a unit of code compilation.
VI. DISCUSSION
The opportunities for both code corruption and code reuse
made possible by JIT compilers have been shown to be ex-
ploitable against real JIT implementations time and time again
[7], [27], [26], [6], [25], [24], [28], [4], [17]. Unfortunately,
the community developing arguably the most prominent and
vulnerable JITs—those found in web browsers—has been
slow to react
to effectively mitigate these threats in their
JavaScript JITs. SpiderMonkey has taken the lead in code
corruption mitigation by deploying W ⊕ X JIT memory, but it
still lacks effective code reuse mitigations. Similarly, although
Internet Explorer’s Chakra deploys a form of random NOP
9This ﬁgure is a function of the probability of random NOP insertion and
the number of potential base offsets.
insertion, its constant blinding implementation, which does not
blind constants ≤0xffff, can still be bypassed to create ROP
payloads [4]. It is apparent to these authors that crafty attackers
can and will discover and exploit any corners cut in the imple-
mentations of JIT spraying defenses. For this reason, we urge
JIT developers to consider deploying defenses at full strength,
even at the expense of non-trivial performance overhead.
By reducing the predictability of instruction operands and
code layout, JIT code reuse can be mitigated. Rather than
selecting a subset of the diversiﬁcation defenses evaluated in
§ V, we recommend all 5 be deployed simultaneously in order
to leave no stone unturned. If a JIT were to omit a particular
defense, that undiversiﬁed area would eventually become a
valuable piece of a future attack. This observation is merely a
corollary to our assertion in the previous paragraph that partial
implementations of defenses do not go unpunished.
Our measurements in §V indicate that most diversiﬁcation
defenses can be deployed at full strength with only modest
performance and memory overhead. A noteworthy exception
is random NOP insertion for the ARM instruction set. Since
our implementation inserts a NOP between each instruction
with 12.5% probability, and all ARM instructions have the
same size, we observe a ≈12.5% code size increase. The x86-
64 architecture, in contrast, is able to achieve a much lower
memory overhead thanks to its 1-byte NOP instruction encod-
ing and variable-length instructions. JIT developers may wish
to consider carefully lowering the probability of random NOP
insertion on platforms with limited memory and ﬁxed-width
instructions. To establish a lower bound on memory overhead
when random NOP insertion is dialed back, we measured
the memory overhead for ARM32 when all diversiﬁcation
defenses except random NOP insertion are enabled and found
it to be 6.15%.
14
A potential objection to diversiﬁcation defenses is that an
attacker with arbitrary memory read capabilities can avoid
failure by spraying until her payload is emitted as desired.
While this is true, we argue that diversiﬁcation defenses
mitigate the entire class of blind JIT spraying attacks and raise
the bar for malicious reuse of JIT code by mandating that a
memory disclosure accompany the control ﬂow vulnerability.
Very recently-published work [18] demonstrates the cre-
ation of unintended instructions from the offset ﬁeld in x86’s
PC-relative branch and call instructions. To mitigate this threat;
the authors of [18] implemented blinding of the implicit
constants in relative branches. At submission time, our diver-
siﬁcation implementations do not include this new mitigation,
and we recognize that future work will need to correct this ﬂaw.
VII. CONCLUSION
As JIT compilers continue to blanket the landscape of
language runtimes, so do attacks that abuse their predictabil-
ity and unique memory protection model, as evidenced by
the new threats against ARM JITs introduced in this paper.
Implementations of mitigations have appeared in production
JITs, but their potential has been artiﬁcially limited in order to
boost performance, resulting in a failure to provide satisfactory
protection. The empirical evaluations and analyses in this paper
demonstrate that diversiﬁcation defenses are effective and can
be implemented in full with only modest overhead. We en-
courage JIT developers to take our experiences implementing
diversiﬁcation defenses and use them to guide implementations
on their own systems.
ACKNOWLEDGMENT
We would like to thank Eric Rescorla for thoughtful
feedback. We also thank Jan de Mooij, Eric Faust, JF Bastien,
and Michael Stanton for helpful discussions. This material
is based in part upon work supported by the U.S. National
Science Foundation under Grants No. 1228967, 1410031, and
1514435, and by gifts from Mozilla and Google.
REFERENCES
[1] Property cache.
Projects/SpiderMonkey/Internals/Property cache.
November 2015].
https://developer.mozilla.org/en-US/docs/Mozilla/
[Online; accessed 2
[2] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI, J. Control-
ﬂow integrity. In Proceedings of CCS 2005 (2005), ACM, pp. 340–353.
[3] ANSEL, J., MARCHENKO, P., ERLINGSSON, U., TAYLOR, E., CHEN,
B., SCHUFF, D. L., SEHR, D., BIFFLE, C. L., AND YEE, B. Language-
independent sandboxing of just-in-time compilation and self-modifying
code. In Proceedings of PLDI 2011 (New York, NY, USA, 2011).
[4] ATHANASAKIS, M., ATHANASOPOULOS, E., POLYCHRONAKIS, M.,
PORTOKALIDIS, G., AND IOANNIDIS, S. The devil is in the constants:
In Proceedings of NDSS
Bypassing defenses in browser jit engines.
2015 (Feb. 2015).
[5] BANIA, P.
JIT spraying and mitigations.
arXiv preprint
[7] BLAZAKIS, D.
Interpreter exploitation: Pointer inference and JIT
spraying. Presented at BlackHat DC 2010, Feb. 2010.
[8] CARLINI, N., BARRESI, A., PAYER, M., WAGNER, D., AND GROSS,
T. R. Control-ﬂow bending: On the effectiveness of control-ﬂow
integrity. In In Proceedings of USENIX Security 2015 (Aug. 2015).
[6] BECK, P.
JIT Spraying on ARM.
https://prezi.com/ih3ypﬁvoeeq/
arXiv:1009.1038 (2010).
jit-spraying-on-arm/, 2011.
[9] CHEN, P., FANG, Y., MAO, B., AND XIE, L. JITDefender: A defense
In Future Challenges in Security and
against JIT spraying attacks.
Privacy for Academia and Industry. Springer, 2011, pp. 142–153.
[10] CHEN, P., WU, R., AND MAO, B. Jitsafe: a framework against just-in-
time spraying attacks. IET Information Security 7, 4 (2013), 283–292.
[11] DE GROEF, W., NIKIFORAKIS, N., YOUNAN, Y., AND PIESSENS, F.
JITSec: Just-In-Time security for code injection attacks. In Proceedings
of WISSEC 2010 (Nov. 2010), pp. 1–15.
[12] DEUTSCH, L. P., AND SCHIFFMAN, A. M. Efﬁcient implementation of
the smalltalk-80 system. In Proceedings of POPL 1984 (1984).
[16]
[15]
[13] DREPPER, U. SELinux memory protection tests. http://www.akkadia.
org/drepper/selinux-mem.html, Apr. 2009. [Online; accessed 3 Novem-
ber 2015].
[14] HOMESCU, A., BRUNTHALER, S., LARSEN, P., AND FRANZ, M.
Librando: transparent code randomization for just-in-time compilers.
In Proceedings of CCS 2013 (2013), ACM, pp. 993–1004.
JANGDA, A., MISHRA, M., AND DE SUTTER, B. Adaptive just-in-time
code diversiﬁcation. In Proceedings of ACM MTD 2015 (2015).
JAUERNIG, M., NEUGSCHWANDTNER, M., PLATZER, C., AND COM-
PARETTI, P. M. Lobotomy: An architecture for jit spraying mitigation.
In Procedings of ARES 2014 (2014), IEEE, pp. 50–58.
[17] LIAN, W., SHACHAM, H., AND SAVAGE, S. Too LeJIT to Quit:
Extending JIT Spraying to ARM. In Proceedings of NDSS 2015 (2015).
[18] MAISURADZE, G., BACKES, M., AND ROSSOW, C. What Cannot
Be Read, Cannot Be Leveraged? Revisiting Assumptions of JIT-ROP
Defenses. In Proceedings of USENIX Security 2016 (2016).
[19] MAVADDAT, F., AND PARHAMI, B. Urisc: the ultimate reduced in-
struction set computer. International Journal of Electrical Engineering
Education (1988).
[20] MILLIKIN, K. V8: High Performance JavaScript in Google Chrome.
[Online; ac-
https://www.youtube.com/watch?v=lZnaaUoHPhs, 2008.
cessed 2 November 2015].
[21] MOOIJ, J. D. WˆX JIT-code enabled in Firefox. http://jandemooij.nl/
blog/2015/12/29/wx-jit-code-enabled-in-ﬁrefox/, Dec. 2015.
[22] MOZILLA. Bug 506693 - SELinux is preventing JIT from changing
memory segment access. https://bugzilla.mozilla.org/show bug.cgi?id=
506693, 2009. [Online; accessed 3 November 2015].
[23] NIU, B., AND TAN, G. Rockjit: Securing just-in-time compilation using
modular control-ﬂow integrity. In Proceedings of CCS 2014 (2014).
[24] PIE, P. Mobile Pwn2Own Autumn 2013 - Chrome on Android - Exploit
Writeup, 2013.
[25] ROHLF, C., AND IVNITSKIY, Y. Attacking Clientside JIT Com-
http://www.matasano.com/research/Attacking Clientside JIT
pilers.
Compilers Paper.pdf, 2011.
[26] SINTSOV, A.
at
JIT-Spray Attacks & Advanced Shellcode.
Presented
Online:
http://dsecrg.com/ﬁles/pub/pdf/HITB%20-%20JIT-Spray%20Attacks%
20and%20Advanced%20Shellcode.pdf, July 2010.
HITBSecConf
Amsterdam
2010.
[27] SINTSOV, A. Writing JIT Shellcode for fun and proﬁt. Online:
http://dsecrg.com/ﬁles/pub/pdf/Writing%20JIT-Spray%20Shellcode%
20for%20fun%20and%20proﬁt.pdf, Mar. 2010.
[28] SONG, C., ZHANG, C., WANG, T., LEE, W., AND MELSKI, D. Ex-
In Proceedings of
ploiting and protecting dynamic code generation.
NDSS 2015 (2015).
[29] SOTIROV, A. Heap feng shui in javascript. Black Hat Europe (2007).
Introducing SquirrelFish Extreme. https://www.
[30] STACHOWIAK, M.
[Online;
webkit.org/blog/214/introducing-squirrelﬁsh-extreme/, 2008.
accessed 2 November 2015].
[31] W3C. Web workers. http://www.w3.org/TR/workers/, 2015. [Online;
accessed 3 November 2015].
[32] WEI, T., WANG, T., DUAN, L., AND LUO, J. Secure dynamic code
generation against spraying. In Proceedings of CCS 2010 (2010).
[33] WU, R., CHEN, P., MAO, B., AND XIE, L. Rim: A method to defend
from jit spraying attack. In Proceedings of ARES 2012 (2012).
[34] YEE, B., SEHR, D., DARDYK, G., CHEN, J. B., MUTH, R., OR-
MANDY, T., OKASAKA, S., NARULA, N., AND FULLAGAR, N. Native
client: A sandbox for portable, untrusted x86 native code. In Proceed-
ings of IEEE S&P (Oakland) 2009 (2009).
[35] ZHANG, C., NIKNAMI, M., CHEN, K. Z., SONG, C., CHEN, Z., AND
SONG, D. JITScope: Protecting web users from control-ﬂow hijacking
attacks. In Proceedings of INFOCOM 2015 (2015).
15