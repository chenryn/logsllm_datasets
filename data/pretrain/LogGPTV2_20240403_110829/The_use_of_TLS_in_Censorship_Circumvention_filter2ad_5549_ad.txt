fronting, but did not receive any response besides the GitHub
issue being silently deleted.
VI. DEFENSES & LESSONS
While the TLS protocol provides plenty of cover trafﬁc for
circumvention tools, there are many challenging details that
tools must get right in order to successfully evade censorship.
There are two high-level detection evasion strategies that cir-
cumvention tools employ when choosing protocols [59]: ﬁrst,
they may try to mimic one or more existing implementations,
making it difﬁcult to distinguish them and increasing the col-
lateral damage to blocking connections that look like the tool.
Second, tools may try to generate random protocol features,
to prevent censors from being able to identify and block the
tool with a blacklist approach. In this section, we investigate
how these techniques can be applied to TLS implementations
in censorship circumvention tools.
Mimicking Clients that choose to mimic other TLS imple-
mentations face several challenges. First, tools must identify a
popular implementation to mimic, which is typically done by
choosing a popular web browser. However, it may also be done
by choosing a large number of individually less-popular but
collectively popular implementations, and mimicking among
them. Second, the tool must support the cipher suites, exten-
sions, and features present in the popular implementation(s).
For instance, if a tool mimics Chrome and sends but does not
actually support a CHACHA20 cipher suite, the server may
select that cipher suite for the connection, causing the tool to
abort the connection. Not only does this cause compatibility
issues, it gives an observant censor a way to identify users of
a tool.
We note that this problem can be partially mitigated if
the server is controlled by the tool maintainer, as they can
choose to select only cipher suites and extensions that they
know their tool to support. However, this is not the case in tools
that do not control both endpoints, such as domain fronting,
refraction networking7, and tools that generate cover trafﬁc
to other servers. In addition, intricacies of the circumvention
7formerly decoy routing
9
protocol may limit the features that a tool can use, even if
implemented. For example, some domain fronting tools cannot
send the SNI extension to certain CDNs.
Finally, the tool must maintain support, as the popular
implementations they mimic change over time, as do the
features they support due to automated patches and updates.
For example, although meek has been successful at mimick-
ing multiple versions of Firefox, it has lagged behind the
Sisyphean task of keeping pace with updates to the Firefox
TLS implementation.
Randomizing Tools that randomize their generated TLS
Client Hello messages have the advantage that they do not
have to identify or track support for popular implementations.
However, this strategy can only work if there is a sufﬁcient
number of similar-looking connections that prevent the censor
from distinguishing it. For instance, Figure 6 demonstrates
the rate at which new connections would hamper a censor’s
ability to use a whitelist. Censors could also distinguish
randomized Client Hello messages by capturing distributions
or other heuristics that are not properly mimicked by a tool’s
randomized ﬁngerprint. For example, if the tool naively picks
from a set of supported extensions, a censor may notice that no
other implementation supports a particular pair of extensions
simultaneously. When the circumvention tool randomly selects
both extensions in this pair, the censor can identify and block
the user. Thus, the random ﬁngerprint strategy must carefully
mimic the distribution of the global TLS implementation
population.
We note that all tools must implement these features either
by creating their own libraries or using existing ones that are
generally ill-suited to the task of ﬁne-grained control over the
TLS handshake. This challenge is illustrated by Signal’s use
of the okhttp library, which silently removed cipher suites that
Signal speciﬁed. Other TLS libraries may ignore supported
cipher suite order, making it difﬁcult for applications to
produce speciﬁc TLS handshakes. In the following section,
we describe our library that is purpose-built for providing
applications control over their TLS connection.
VII. UTLS
TLS ﬁngerprinting remains a looming threat for anti-
censorship tools, and as we have shown, even tools that attempt
to defend against it can often fall short. Indeed, mimicking
is hard to get right: there are lots of features to keep track
of and implement, the mimicked ﬁngerprint could rapidly go
obsolete, or the tool’s underlying library could silently change
the ﬁngerprint.
There may also be unexpected or complicated dependen-
cies that prevents simply parroting Client Hello messages seen.
For example, GREASE values generated by Google Chrome
used to be deterministic and depend on the value of the Client
Random, but this was changed in favor of random values. In
addition, cipher suites can inﬂuence other parts of the header
(or server response), such as by having a special meaning
(SCSV cipher suites), by deﬁning what TLS version is used,
or triggering the inclusion of an extension. Finally, extensions
may affect each other, for example, the presence and size of
padding extension can depend on the size of the Client Hello.
An implementation that failed to mimic these subtleties could
be identiﬁed by a censor.
To assist censorship circumvention tools, we created a
TLS library8 that aims to protect against TLS ﬁngerprinting
and (among other features) allows developers to easily mimic
arbitrary Client Hello messages. We develop our library as a
fork of Golang’s native TLS library crypto/tls, adding
over 2200 new lines of code.
As of August 2018, three circumvention tools have adopted
uTLS library: Psiphon, Lantern, and TapDance all use uTLS
to allow them greater control over TLS features, and make it
easier to mimic popular implementations.
A. Design
uTLS is designed to be an addition to the standard
crypto/tls library and minimizes changes to core Go ﬁles,
enabling us to easily auto-merge from upstream. This allows us
to keep uTLS up-to-date with the underlying standard library,
and adopt any new features and bug ﬁxes that come in the
future. In addition, this allows us to rely on the performance
and security of crypto/tls: uTLS simply ﬁlls the Client
Hello and leaves execution of the TLS handshake up to the
standard functionality.
Our choice of Golang as the language for uTLS is moti-
vated by several reasons. First, it is a popular language used
in several censorship circumvention tools, including Lantern,
meek, Psiphon, Snowﬂake, and TapDance, allowing easier
integration. For tools that are not written in Go, integration
should still be possible via Go’s language bindings [35].
Second, Golang is memory safe (bounds checked), decreasing
our worry of introducing control ﬂow vulnerabilities into tools
that integrate uTLS, despite containing network serialization
code.
a) Low-level access to the handshake: uTLS provides
write access to any ﬁelds of the Client Hello message, allowing
implementations to specify their own cipher suites, compres-
sion methods, client random, extensions, etc. Developers can
compose a Client Hello using uTLS structures, or by manually
specifying the bytes of a raw Client Hello for uTLS to use. In
addition, uTLS provides structured read access to handshake
state,
including the Server Hello, Master Secret, and key
stream.
b) Mimicry: Users can also select from a set of preset
built-in Client Hello messages. As of August 2018, uTLS
includes defaults for Chrome 64, Firefox 58, and iOS 11, and
we plan to add support for new versions of browsers, operating
systems, and other popular devices. Mimicking could be hard
to get right, but we veriﬁed uTLS’ ability to mimic popular
clients by comparing the ﬁngerprints it generated to those in
our dataset.
c) Randomized ﬁngerprints: Given the long tail dis-
tribution of Client Hello ﬁngerprints in our dataset, uTLS
also supports generating random ﬁngerprints. Although these
are unlikely to correspond to popular implementations and
ﬁngerprints seen, censors may have a hard time constructing a
comprehensive whitelist of TLS ﬁngerprints, making it difﬁcult
to block random ones. Similar techniques have been used by
other randomized protocols for censorship circumvention, such
as obfsproxy [5] and ScrambleSuit [64], which attempt to look
like no protocol at all. Our random ﬁngerprints extends this
idea at the TLS layer, ensuring that packets are valid TLS
messages, but making it difﬁcult for censors to blacklist the
speciﬁc implementation.
d) Using multiple ﬁngerprints: Mimicking multiple ﬁn-
gerprints makes it possible for a circumvention tool to operate
even when a subset of its ﬁngerprints are blocked. To support
this, uTLS can optionally cycle through a popular set of
ﬁngerprints in its handshakes until an unblocked working
one is found. Thus, if uTLS is able to properly mimic even
one implementation, it will be more difﬁcult for a censor to
block this strategy. uTLS automatically retries the latest work-
ing ﬁngerprint when reconnecting to minimize unnecessary
changes to its ﬁngerprint. An example usage may be found
in Appendix, Listing 1.
Automatic code generation While uTLS makes it easy
to manually specify parts of the Client Hello, we provide
an additional feature to make this even easier. Our website
produces automatically-generated code for each ﬁngerprint in
our dataset, allowing developers to simply copy and paste
to conﬁgure uTLS to mimic a given ﬁngerprint. This fea-
ture allows developers to easily keep their tools up-to-date,
and could even allow this to potentially be fully-automated:
continuous integration scripts could watch for changes in
ﬁngerprint popularity, and either alert developers or possibly
automatically pull in new code to use more recent ﬁngerprints.
We note that automated ﬁngerprint code may generate
Client Hellos that uTLS does not yet fully support, potentially
causing the handshake to fail if the server supports those
features. We explicitly identify and warn the developer when
this is the case, as our automated code tracks the features uTLS
supports.
Fake Session Tickets uTLS provides the ability to send
arbitrary session tickets, including fake ones. This is useful
when the tool developer also controls the server, which must
accept the fake session ticket or generate a real one for further
out-of-band distribution. This technique allows servers to save
a round trip time and avoid sending a Certiﬁcate or Key
Exchange message, giving the censor fewer messages and
information to block on. To support mimicking, we track
commonly used Session Ticket sizes on our website9.
B. Measuring feature support
We note that when uTLS mimics a Client Hello of another
implementation, it may potentially advertise support for fea-
tures it does not actually implement. For instance, it may send
a cipher suite that, if selected, uTLS will be unable to use. We
measure this risk in Section VII-B.
To enable mimicking other TLS implementations, uTLS
allows the developer to advertise support for TLS extensions
and cipher suites that are not actually supported by our library.
If the server does not select or use these cipher suites or
extensions, the connection will function normally. However,
8https://github.com/refraction-networking/utls
9https://tlsﬁngerprint.io/session-tickets
10
if the server selects a cipher suite that is not implemented
by uTLS, the connection will visibly break. These risks do
not impact tools that make connections to servers under the
developers’ control, as those unsupported features can be easily
disabled server side.
We measure how many ﬁngerprints in our dataset uTLS
can support without this risk. We classify a ﬁngerprint as
“fully supported” if uTLS is able to handle every feature
in it (e.g. the server could select any cipher suite, curve, or
extension, and the connection would succeed). We classify a
second group of “optionally supported” ﬁngerprints that are
also supported by uTLS but may include weaker ciphers, such
as such as TLS_RSA_WITH_AES_256_CBC_SHA256, that
were disabled by the underlying Golang library. uTLS users
may choose whether to enable those weaker ciphers, or to let
the connections fail if the weaker ciphers are chosen by a
server.
Note that a ﬁngerprint not being fully supported doesn’t
always lead to unsupported feature getting chosen by server:
it might be a low-priority, or not supported by the server either.
Weaker ciphers are only likely to be picked in the wild if the
client communicates with an outdated server.
As of August 2018, uTLS fully supports 21940 ﬁngerprints
(9.3%), which were seen in 5.9% of connections collectively.
The top ranked fully supported ﬁngerprint is the 9th (all-
time) most popular ﬁngerprint
in our dataset, which is a
ﬁngerprint generated by Chrome 61-64. If weaker “optionally
supported” CBC ciphers are allowed,
then uTLS supports
22616 ﬁngerprints (9.6%), which were seen in 37.3% of
collective connections. This includes 30 ﬁngerprints in the top
100, including the 3rd most popular ﬁngerprint (generated by
Outlook 2016). As mentioned, uTLS code for using all of these
ﬁngerprints can be automatically generated by our website,
requiring minimal effort from the developer.
We also use our data to learn which additional features
would give uTLS the most additional coverage in terms of
supported ﬁngerprints, to know which features we might want
to focus on adding to the library next. As of August 2018,
supporting the ChannelID extension alone will allow us to
fully support 245 more ﬁngerprints which would account for
an additional 20% of connections seen. We note that these
ﬁngerprints could be mimicked in uTLS now, as the Channel
ID is unlikely to be supported by servers: only 2.9% of Server
Hello messages used the extension. This extension aims to
secure connections by cryptographically authenticating client
to the server, allowing to bind cookies and tokens to particular
client’s channel, which has to be explicitly implemented and
integrated with the application layer on the server.
C. TLS 1.3
As of March 2018, TLS 1.3 [45] has been standardized and
is being rolled out in major browsers. TLS 1.3 offers several
advantages over previous versions, including decreased net-
work round trips in new connections (improving performance),
and encrypted handshakes (improving privacy).
SNI10 (ESNI) may prove useful for evading censors [23]. Sec-
ond, as popular browsers begin to implement and send TLS 1.3
handshakes, circumvention tools will soon want to mimic them
to continue blending in with popular implementations.
Interestingly, TLS 1.3 Client Hellos look similar to those
in TLS 1.2: in fact, TLS 1.3 still sends a handshake version
corresponding to TLS 1.2 to allow implementations to work
in the presence of buggy middleboxes and servers that cannot
handle other values. TLS 1.3 instead adds functionality via
several new extensions in the Client and Server Hello mes-
sages.
Although our ﬁngerprints already include the presence and
order of all extensions in a given Client Hello, we only parse
and include a handful of extensions’ data in our ﬁngerprint.
This means if many implementations send the same set of
extensions but include different data, we would mistakenly
classify them as the same ﬁngerprint. This is particularly a
concern for TLS 1.3 handshakes, which heavily rely on new
data-carrying extensions. To address this, we reviewed the new
extensions in TLS 1.3, and added the body data of popular
extensions that do not change per-connection. For example,
supported_versions contains a list of supported TLS
versions ordered by preference. As different implementations
can announce different versions they support, we add this
data to our ﬁngerprint. So far, we have observed 40 distinct
values of this extension announcing support for the various
TLS versions and drafts. Table III shows the most popular
extensions we have collected as of December 2018, and
highlights the ones whose data we include in our ﬁngerprint.
Extension
supported groups
server name
signature algorithms
ec point formats
extended master secret
status request
renegotiation info
ALPN
signed certiﬁcate timestamp
SessionTicket
padding
Conns
99.4%