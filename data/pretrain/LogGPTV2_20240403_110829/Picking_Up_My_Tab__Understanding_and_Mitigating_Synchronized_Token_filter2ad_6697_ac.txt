The attack. Again, this payment scheme is vulnerable
to an STLS attack involving audio recording and WiFi
or cellular signal jamming with the device shown in Fig-
ure 7(a). Speciﬁcally, before the payment transaction
starts, a nearby attacker turns on a signal jamming device
to block signals and prevents the merchant from communi-
cating with the payment service provider. When the payer
plays her payment sound to the merchant (mobile vending
machine in Alipay), the attacker records the sound within
a proper distance. Since the transaction is aborted by the
signal jamming, the recorded payment token is not spent.
Then the attacker can replay the recorded sound to make
another purchase. The attack is illustrated in Figure 10.
Figure 10: The attack against audio pay.
We implemented this attack against a real-world vend-
ing machine. The attack demo is posted online [1].
In this attack, the attacker uses a free iOS app called
SpectrumView[35] to record the payment audio signal at
a distance of 30cm from the payer’s phone. 3 With such
low cost, the attacker is still able to successfully launch
the STLS attack. Although the the token has a limited
valid period (90 seconds), our attack demonstration shows
that such time window is sufﬁcient for attackers.
3.3 QR Pay
Figure 9: The process of audio pay.
Alipay has widely adopted audio pay on mobile vend-
ing machines. In this scenario, after the payer selects an
item, the vending machine will ask the payer to play her
payment audio. Upon receiving the audio, the machine
decodes the payment token from the audio and sends it to
the payment service provider through cellular network to
proceed the transaction. To produce the payment audio,
Alipay encodes the payment token into a carrier sound by
AFSK. While the carrier sound can be heard by a human
Mobile payment through QR code is quickly gaining pop-
ularity in recent years. A plenty of retailers (like Walmart
and Starbucks), ﬁnancial organizations (like Chase, Pay-
pal and Alibaba) and social network apps (like WeChat)
have developed or adopted QR payment. So far, three
payment schemes have been proposed to support different
payment scenarios [13]:
3The attack device is small and can be placed stealthily and closely
to merchant device, e.g., within 30cm to a vending machine. Token
recording and transmitting can be fully automated without attacker’s
attendance. Hence, the threat is realistic.
USENIX Association
26th USENIX Security Symposium    599
verification resultpayment token,  trans infopayment audiopayermerchantpayment serverpayment audiopayermerchantpayment serversniffabortspend•Buyer-to-Large retailer transactions (B2L). A QR code
representing the payment token is generated by the payer’s
mobile payment app (like WeChat, ChasePay and AliPay)
and then picked up by payee’s POS scanner and trans-
ferred to service provider (see Figure 11). Since a special
POS scanner has to be deployed by the payee, this scheme
is usually seen in large retailers, like Walmart, Target and
Starbucks.
Figure 11: The work-ﬂow of QR pay.
•Buyer-to-Small business transactions (B2S). The payer
scans the QR code presented by the payee using a mobile
app to get payee’s merchant ID, inputs the right amount
and then authorizes the payment. In this case, the QR
code can be printed on a paper as the merchant ID is
usually permanent.
•Peer-to-Peer transactions (P2P). A user (or payer) with
payment app wants to transfer money to another user (or
payee). The payee generates a QR code to be scanned
by the payer. After the scanning process, the money is
transferred 4.
In this work, we evaluate whether STLS attack can
succeed for the ﬁrst and third transaction scenario, i.e.,
whether the payment token can be stolen at one place and
spared at another place. We skipped the second scenario,
as no payment token is generated by the user (payment
is sent directly to the service provider). We focus on the
off-line mode, for which the token is generated off-line
and no conﬁrmation by the payer is required when the
token is about to be consumed. We discuss the online
payment option in Section 5.
Security analysis of payment app. Different from the
native payment apps, like Samsung Pay and Apple Pay,
which protect the payment token through hardware means
(e.g., Secure Enclave for Apple Pay and KNOX for Sam-
sung Pay), the third-party payment apps, like WeChat
and Alipay, cannot shield the payment token against the
OS-level attack (e.g., malicious app with root privilege).
Though the OS-level attacks can cause devastating conse-
quences, their victim base is usually small.
As a result, the defense employed by the third-party
apps is largely targeting malicious apps with non-root
permissions. For instance, AliPay claims that it can pre-
vent another app from taking screenshot to steal the QR
4Some payment app reverses the scheme (payer shows QR code to
payee). Our attack is valid for both case.
code 5; its payment token is one-time and short-lived; it is
capable of detecting mobile trojan app and phishing QR
code.
Challenges for STLS attack on QR code. Unlike the
MST and audio channels, QR code is a visual sign, which
cannot be jammed and sniffed by the nearby physical de-
vice. Carrying out STLS attack under this scenario seems
impossible at ﬁrst sight, but through a set of novel tech-
niques, we show such attack is completely realistic. Our
only assumption is that a malicious app has been installed
on the payer’s mobile device with camera, bluetooth and
network permissions granted. This app plays a similar
role as the nearby physical device used in MST and audio
attack. More importantly, our app is a non-root app and
does not trigger any abnormal behavior vetted by the
payment app (e.g., taking screenshots of QR code). The
key stage of this attack is stealing the payment token while
halting the ongoing transaction, and we elaborate two ap-
proaches for this step, one attacking the QR scanner of
the POS machine and another attacking the payment app
during P2P transactions.
3.3.1 Attack POS-based Payment
Attack overview. Our attack can be launched when a
user shows the payment QR code to the POS scanner.
In particular, the malicious app attempts to steal the QR
code from the glass reﬂection of the POS scanner when
the payer’s screen is close to it. In the meantime, it dis-
rupts the display of the original QR code to abort the
ongoing transaction, by masking the payer’s screen. The
token (stored in photos captured by the front camera of
payer’s phone ) is exﬁltrated to attacker through network
and spent at another store after unmasking, like MST and
audio attack. To avoid arousing payer’s suspicion, the at-
tack app actively proﬁles the context (e.g., the foreground
app and activity) and the actual attack is initiated when
the context matches the payment context. We elaborate
the four key attack components (sniff, abort, proﬁle and
exﬁltration) below. A demo of this attack can be found
in [1].
Snifﬁng QR code. For the attack app, direct capture of
QR code is not feasible as screen scraping is prevented
by the payment app. However, the reﬂection of the QR
code on other objects cannot be controlled by the payment
app and we exploit this observation to build this attack
component. It turns out the glass window of the POS
scanner can serve our purpose perfectly. As illustrated
in Figure 12, a typical scanner is composed of a glass
window, a camera and a light source. When the screen of
payer’s phone is close enough to the scanner, the reﬂection
5For example, an Android app can set a window ﬂag FLAG_SECURE
when initiating an activity window to avoid screen scraping [15]. AliPay
uses this ﬂag to protect its QR code.
600    26th USENIX Security Symposium
USENIX Association
Trans Info Payment TokenTrans Resultof the QR code will appear on the scanner glass and the
attack app can capture it by taking photos with phone’s
front camera. The scanner glass is an ideal object here
because of its brightness is signiﬁcantly different from
payer’s screen: mobile payment apps always increase
screen brightness to ease the recognition of the QR code
while the light source of the scanner is much darker to
avoid glare. As such, a “one-way mirror” is constructed
for attack app to pick up the QR code.
Figure 12: A QR Scanner.
•Assessment of snifﬁng. Whether QR code can be success-
fully captured by the phone’s front camera depends on
several factors, including the horizontal distance between
the QR code and the front camera (dcq), the side length of
the QR code (lq), the vertical distance between the glass
and the phone screen (dgs), and the front camera’s angle
of view (AOV ). Figure 13 illustrates these factors for the
most common case that the scanner and the phone are
parallel. The ideal approach to assess these factors is to
run experiments by simulating all their possible combina-
tions and check whether the QR code can be recovered,
which cannot be done within reasonable time. Instead, we
compute their theoretical value range for the successful
attack.
Figure 13: The side view of the phone and the QR scanner
during POS-based payment.
In summary, three conditions have to be satisﬁed. First,
the scanner glass should be large enough to reﬂect the
whole QR code. Hence, the minimum side length of the
glass should be dcq/2 +lq− (dcq +lq)/2, or lq/2. Second,
the horizontal position of the glass should be about the
middle point between the QR code and the front camera.
Third, the glass should be vertically far enough so it would
be within front camera’s AOV. In other words, dgs should
be at least (tan(90− AOV /2)× (lq + dcq))/2.
It turns out all the three conditions can be met for the
normal payment scenario. For the tested mobile phone
(MI 3W), lq is 3.2cm and dcq is 5.8cm. For Alipay on
the tested scanners (Symbol DS-6708SR[50] and NLS-
FR40[10]), their glass side lengths are 2.3cm and 4.3cm
respectively, which are much larger than the minimum
requirement lq/2 (1.6cm). Placing the scanner glass in the
middle point is also natural for the payee (as illustrated
in Figure 15). Assume AOV for the front camera is 60 de-
grees, the minimum dgs would be 7.8cm, which is within
the suggested working range of the scanner [50, 10].
Aborting ongoing transaction. Signal jamming cannot
be used here to disrupt the normal payment process. In-
stead, we instruct the malicious app to mask the QR code
for the disruption.
A QR code has to embed three positioning markings
(or PM) at its three corners. They are used to ensure that
a reader can correctly identify the region and direction of
the QR code. If one of these PMs is not displayed, the QR
code will not be readable. Our attack app is developed to
mask one PM. To this end, the app pops up a ﬂoating win-
dow covering one PM only. However, showing ﬂoating
window on top of another app requires a system permis-
sion SYSTEM_ALERT_WINDOW since Android 6.0 [17]. So,
we choose a different approach by commanding the attack
app to create an activity which is transparent except the
PM region (ﬁlled with white pixels) and overlay it on
top of the payment app. Such design yields the similar
visual effect without asking for any additional permission.
When the reﬂected QR code is captured, the attack app
will dismiss the transparent activity and bring back the
original QR code window. Figure 14 illustrates an exam-
ple of the original and masked QR. Figure 15 shows how
the masked QR code is scanned and the reﬂection image
of the masked QR code captured by the malicious app
with front camera.
Inferring payment activity. To keep the snifﬁng and
jamming process stealthy, our attack app actively infers
the running context and moves to the next stage when
the context is matched. We exploit a set of side-channel
information to learn the context, including the foreground
app, its displayed activity and payer’s action. The details
are described below:
•Foreground app. The attack app needs to know when
the foreground app is identical to the targeted payment
app. The information is not directly available due to the
separation between apps. However, it can be inferred by
USENIX Association
26th USENIX Security Symposium    601
glasscameralight sourcescan windowscan windowlight sourcecameraglassHandheld QR scannerDesktop QR scannerQR codeαplane of  reflectionminimum side length of the glasslqdcqdgsfront cameraQR scannerthe reflected image of the phonethe real phonereflected QR code•Payer’s action. We use onboard sensors, including
accelerometer, gyroscope, and magnetometer, to infer
whether the payer is showing her QR code to the mer-
chant. Usually, such action incurs a drastic change of
rotation angle of the phone, therefore we can measure
the change rate to infer it. In particular, we employ the
algorithm in [22] to compute the angles on all axes com-
pared to a ﬁxed position. We begin to monitor the angles
when prior conditions are satisﬁed and record the ﬁrst
observed angle as Ainitial. When the difference between
the current angle and Ainitial exceeds a threshold, the user
is recognized as rotating the phone to show the QR code
to the merchant.
Exﬁltrating QR code. In order to increase the success
rate, a series of photos of the reﬂected QR code are taken
during the scanning process. Recovering the QR code
from the distorted images on the cell phone is time- and
battery-consuming. Therefore, the images are exﬁltrated
to attackers’ server through cellular or WiFi network for
further analysis, i.e., mask removal.
Evaluation. We tested our attacks on Alipay (version
10.0.2) and Wechat (version 6.5.4). The testing phone is
MI 3W with Android 4.4. The testing QR scanners are
Symbol DS-6708SR[50] (hand-held) and NLS-FR40[10]
(desktop). And we are able to carry out STLS attack as
shown in the demo [1]. We further examined the success
rate of our attack by asking 14 users to show the masked
QR code (the QR code is masked for 60s) to a desktop
QR scanner (NLS-FR40). Among them, 6 (43%) are suc-
cessfully attacked, suggesting retrieving payment token
from the reﬂected QR code on the scanner’s glass window
is completely feasible. Some attempts are failed when
the user positioned the phone too close to the scanner.
The average time of the whole attack is 55s. In particular,
the average time to sniff a valid QR code is 16s, and the
average time to exﬁltrate QR code is 39s. The time to
transfer photos to remote server is negligible. Actually,
the validity period of a QR code is conﬁgured to 90s,
based our examination on Alipay and Wechat. This time
is sufﬁcient for the attacker to launch the attack and spend
the QR code in a different transaction.
Since the attack app does not require any system per-
missions or any unique system features, the attack is ap-
plicable to all Android versions. We are working to imple-
ment this attack on other platforms, e.g., iOS. But several
issues have to be addressed a priori, e.g., how to mask
one PM of the QR code and how to infer the foreground
activity, which might need new design of the attack app.
3.3.2 Attack Peer-to-peer Transfer
Attack overview. A user may be attacked even if her
device is not infected with any malware.
In addition
to being used in B2L transaction, a payment QR code
Figure 14: An example of the original and masked QR.
Figure 15: The masked QR code is being scanned and the
reﬂection image of the masked QR code is captured by
the malicious app with front camera.
reading a public Linux procﬁle /proc/net/tcp6 which
logs the opened TCP sockets per app 6. As long as the
targeted payment app is activated , TCP sockets to the
servers will be established and the IP addresses expose
the app’s running status.
•Displayed activity. We use the brightness of the screen
to determine if the payment app is displaying QR code.
Our key observation is that mobile payment apps always
increase the screen brightness (say BQR) to the maximum
level when showing the QR code. BQR is even higher
than the maximum brightness that can be conﬁgured by
the user. As such, we create a FileObserver [14] to
monitor the ﬁle /sys/class/leds/lcd-backlight/
brightness.
If the brightness logged within the ﬁle
reaches BQR, the targeted activity is recognized.
6We did not use /proc/net/tcp since socket information is no