title:Stepwise development of security protocols: a speech act-oriented
approach
author:Phan Minh Dung and
Phan Minh Thang
Stepwise Development of Security Protocols:
A Speech Act-Oriented Approach
PO Box 4, Klong Luang, 12120 Pathumthani,
Thailand
Phan Minh Dung
Asian Institute of Technologies
Computer Science and Information Management
Program
Thailand
PI:EMAIL
ABSTRACT
We propose a novel multi-layers paradigm for the design
of key exchange protocols. In the top layer, protocols are
speciﬁed in a high-level, declarative, formal language using
speech acts as the basic building blocks. The declarative
semantics of speech acts are speciﬁed by their preconditions
and eﬀects like in Hoare logics. A protocol logic, called
ProtoLog, is developed for reasoning about speech act ori-
ented protocols. Using the language of speech acts, protocol
designers could develop their protocols in an modular and
compositional way that are correct from the outset.
High-level speech act-oriented protocols are automatically
translated into lower-level message exchanging protocols by
a ”protocol compiler” that implements speech acts by send-
ing and receiving appropriate encrypted messages.
To demonstrate the applicability of our idea, we apply it
on the class of well-designed key exchange protocols where
a protocol is well-designed if a speech act is executed only
if its preconditions are satisﬁed. We develop a ”protocol
compiler” for the class of well-designed protocols and prove
the soundness and a limited form of completeness of the
protocol logic ProtoLog wrt the translation, implemented
by the compiler, under the Dolev-Yao assumption of perfect
cryptography. An immediate corollary from the soundness
result is the guarantee of the secrecy of exchanged keys (an
essential security requirement of key exchange protocols) in
well-designed protocols.
Categories and Subject Descriptors
D.2.10 [Software Engineering]: Design—Methodologies;
F.3.1 [Logics and Meanings of Programs]: Specifying
and Verifying and Reasoning about Programs—Logics of
programs, Pre- and post-conditions
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
FMSE’04, October 29, 2004, Washington, DC,USA.
Copyright 2004 ACM 1-58113-971-3/04/0010 ...$5.00.
Phan Minh Thang
Asian Institute of Technologies
Acrors Program
PO Box 4, Klong Luang, 12120 Pathumthani,
PI:EMAIL
General Terms
Security, Design, Languages, Veriﬁcation.
Keywords
Security protocols, cryptographic protocols
1.
INTRODUCTION
Security protocols play a pivotal role in information secu-
rity. But despite the commonly recognized fact that infor-
mation security has become a serious concern in commercial
deployment of application and middleware, the development
and deployment of security protocols is still an error-prone
and diﬃcult process [8, 19, 29, 23, 22, 3], done in an ad-hoc
manner, without a formal speciﬁcation of their security re-
quirements. We hence need a process for making a stepwise
transition from high-level security protocol design through
development to code.
In general, security protocols often have structures that
determines the composition of the intention and semantics of
the individual messages. Recognizing these structure could
allow us to create a radically new modular approach to se-
curity protocol development in which high-level security de-
signs are translated stepwise to code. The obtained proto-
cols at all levels are guaranteed to be correct from the outset.
To illustrate this idea, let us look at an example
Hash(K), S}KA
Example 1: Consider a protocol for distributing a fresh
session key K generated by a server S, to two principals A
and B. At the end of the protocol, both A and B are expected
to get K and also to know that the other has got K as well.
(1)A → S : req, newkey, A, Init, S, Server, Na, B
(2)S → A : {rep, newkey, S, Server, A, Init, Na, K, B}KAS
(3)S → B : {inf, newkey, S, Server, B, Resp, K, B, A, S}KBS
(4)B → A : {req, keyconf irm, B, Resp, A, Init, Nb,
(5)A → B : {rep, keyconf irm, A, Init, B, Resp, Nb}KB
(6)B → A : {inf, keyconf irm, B, Resp, A, Init, S}K
Note that KX (resp. KXY ) represents a public (resp.
secret common) key of X (resp. between X and Y). {g}k
denotes the encryption of g using key k. Following the pru-
dent engineering practice of Abadi and Needham [2] each
message is designed to contain explicitly the identity of the
sender, receiver together with their roles in the protocol as
well as the purpose of the message.
The ﬁrst message is a request from A, as initiator, to S,
as server, for a fresh session key with B. The keywords req,
newkey indicate that the message represents a request for a
new key. Na is a fresh nonce.
S replies by sending a newly generated session key K to A
in the second message. The keywords rep, newkey indicate
that the message is a reply to an earlier request for a new
key. After getting the reply message, A knows that K is a
fresh session key between A and B generated by S.
S informs B about key K in the third message (B plays the
role of a responder). The keywords inform, newkey indicate
that the message is intended to inform B about a new key.
After receiving the third message, B could only say that it
has been informed about K without being sure whether K
is fresh or not. This is because B has no knowledge about K
before receiving the third message and hence, B could not
verify whether this message is just sent recently or it has
been replayed by a penetrator.
To verify the information it has just obtained, B requests
A in the fourth message to conﬁrm that A knows that K is
indeed a fresh session key between A and B generated by
S. The keywords req, keyconﬁrm indicate that the message
represents a request for conﬁrming the status of the included
key. Nb is a fresh nonce.
A replies to B by sending the ﬁfth message to conﬁrm
that K is indeed a fresh session key between A and B. The
keywords rep, keyconﬁrm indicate that the message repre-
sents a reply to an earlier request to conﬁrm the status of K.
After getting this message, B knows that what it has been
informed before is correct.
B sends A the sixth message to conﬁrm that B now knows
that K is a secret session key between A and B. The key-
words inform, keyconﬁrm indicate that the intention of the
message is for B, to conﬁrm to A that it knows about K.
The above protocol could be viewed as an implementation
of the following more abstract one using speech acts as the
basic building blocks 1:
S1 : A requests S to generate a new session key for
communication with B
S2 : S replies to A by sending A a newly generated key K
S3 : S informs B that K is a new session key between A and
B generated by S
S4 : B requests A to conﬁrm that K is a fresh session key
between them generated by S
S5 : A replies to B to conﬁrm that K is indeed a fresh session
key between them generated by S
S6 : B informs A to conﬁrm that B knows that K is a fresh
session key between them generated by S
where A,B,S play the roles of initiator, responder and key
server respectively.
The new approach proposed in this paper allows protocol
designers to develop their protocols in an abstract speech
act-oriented language like. A ”protocol compiler” would
translate automatically the abstract protocols into lower-
level ones. 2
In this paper, we propose a multi-layered approach in
the design of security protocols.
In the top layer, proto-
cols are speciﬁed using speech acts as the basic building
blocks. Like in Hoare logics, the declarative semantics of
speech acts are speciﬁed by their preconditions and eﬀects.
High-level protocols are translated automatically into the
1Speech acts have been proposed as the basic primitives for
declarative agent communication language in the AI com-
munity [18]
lower-level message-exchanging protocols by ”protocol com-
pilers” where speech acts are implemented by sending and
receiving appropriate encrypted messages. Like in conven-
tional programming, ”protocol compilers” are developed by
the designers of speech act languages, not by their users.
Ensuring the correctness of ”protocol compilers” is hence a
responsibility of the speech act language designers, not of
the protocol programmers. In the proposed new paradigm,
designers could develop security protocols that are correct
from the outset, in an intuitive, modular and compositional
language of speech acts.
Key exchange protocols form an important and well-studied
class of security protocols. Due to the limited space and to
get the idea of the new approach easier across to the readers,
we focus technically in this paper on key exchange protocols.
We introduce a speech act language for the class of well-
designed key exchange protocols together with a protocol
logic called ProtoLog for reasoning about the mental states
of principals participating in protocol runs where a protocol
is well-designed if a speech act is executed only if its pre-
conditions are satisﬁed. We develop a ”protocol compiler”
for the introduced language and prove the soundness and a
limited form of completeness of the protocol logic ProtoLog
wrt the translation, implemented by the compiler, under the
Dolev-Yao assumption of perfect cryptography. An imme-
diate corollary from the soundness result is the guarantee of
the secrecy of exchanged keys (an essential security require-
ment of key exchange protocols) in well-designed protocols.
The paper is organized as follows. In chapter 2, we present
a language of speech acts, and introduce well-designed pro-
tocols.
In chapter 3, a protocol logic called ProtoLog for
reasoning about the mental states of principals participat-
ing in protocol runs. A ”protocol compiler” is introduced in
chapter 4 and the soundness and completeness of the proto-
col logic ProtoLog wrt the translation implemented by the
compiler are proved in chapter 5. In chapter 6, we conclude
and discuss related works.
2. SPEECH ACTS AND WELL-DESIGNED
PROTOCOLS
We ﬁrst propose a simple logical language for specifying
the mental states of protocol principals. In contrast to BAN-
style logics [6, 27], we do not employ a belief operator. In-
stead we have two operators: ”being informed” and ”know-
ing”. Intuitively, to say that an agent knows something is
to say that the agent’s information about this something is
correct and the agent is also aware about the correctness of
the information while to say that an agent is informed of
something simply indicates that the principal has obtained
a piece of information without giving any hint about the
correctness of the information as well as the awareness of
the agent about it. Jumping ahead, our actual semantic
deﬁnition follows Fagin et all [12] in deﬁning that an agent
knows something if it is true in the current state and true
in every other state in which the agent makes precisely the
same observations.
We assume the existence of pairwise disjoint sets NONCE,
NVAR, KEY, KVAR and PI, PVAR of nonces, nonce
variables, keys, key variables and principals and principal
variables respectively. There is a distinguished identiﬁer
P E ∈ P I denoting the penetrator. A principal that is not
the penetrator is called regular. In security protocols, prin-
cipals often play diﬀerent roles like the roles of initiators,
responders or key servers. The roles of the principals in-
volved in a protocol form an important component in its
semantics. We assume the existence of a ﬁnite set RO of
predeﬁned role identiﬁers. A principal term is either a prin-
cipal from PI, or a principal variable from PVar. Nonce term
and key terms are deﬁned similarly.
Let A,B,C,X,Y,Z be principal terms, n be a nonce term
and K be a key term and ρ be a role. A basic formula has
one of the following forms:
1. GKA,ρ(K, B, C) stating that principal A acting in role
ρ has generated a fresh key K as a session key between
B and C
2. GNA,ρ(n) stating that principal A acting in role ρ has
freshly generated nonce n
3. HNA,ρ(n) stating that principal A acting in role ρ has
nonce n
4. Inf ormedA,ρ(K, X, Y, Z) stating that principal A act-
ing in role ρ has been informed that K is generated
recently by Z as a session key between X,Y.
5. Key(K, A, B, C) stating that K is a session key be-
tween principals A and B generated recently by C.
6. Access(A, K) stating that A has access to key K
A formula is composed from basic formulas using the log-
ical operators ∧,∨,¬, → together with the knowledge oper-
ator KnowA,ρF stating that A acting in the role ρ, knows
that F holds.
One may wonder of whether it is possible to replace the
notion Key(K,A,B,C) by just Key(K,A,B) without mention-
ing explicitly the generator C of K. Example 1 is a case where
an employment of Key(K,A,B) would lead the responder B
to believe in the trustworthiness of K even if S is the pene-
trator and A mistakenly believes S is honest while B is aware
about the true identity of S.
2.1 KPL: A Keys-Principals Association Logic
We introduce now KPL (Keys Principals Association Logic),
a specialized version of the modal logic S5, for reasoning
about keys and its association to principals. The logic is
needed to deﬁne well-designed protocols. Let A,B,C,D be
regular principal identiﬁers and X be a principal identiﬁer.
KPL extends the system S5 in modal logic [17, 12] with the
following axioms:
A1 Key(K, A, B, C) → Key(K, B, A, C)
A2 Inf ormedA,ρ(K, B, C, D) → Inf ormedA,ρ(K, C, B, D)
A3 GKA,ρ(K, B, C) → GKA,ρ(K, C, B)
A4 GNA,ρ(n) → HNA,ρ(n)
A5 GKA,ρ(K, B, C) → Key(K, B, C, A)
A6 F → KnowA,ρF
for all basic formula F of the form
GKA,ρ(K, B, C), GNA,ρ(n), HNA,ρ(n) and
Inf ormedA,ρ(K, B, C, D)
A7 KnowA,ρKey(K, B, C, D) → Inf ormedA,ρ(K, B, C, D)
A8 Inf ormedA,ρ(K, B, C, D) → Access(A, K)
Axioms A1-A5 and A8 follow directly from the intuitions
of the involved basic formulas. The intuition of axiom A6 is
that if a principal is doing something then it is also aware