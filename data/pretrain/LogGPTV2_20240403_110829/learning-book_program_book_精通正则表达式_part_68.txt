失败
失败
RegexObj.Match("May 16,1998", 9, 2)
匹配‘99’
匹配‘99’
匹配‘99”
RegexObj.Matches (target)
Return type:MatchCollection
RegexObj.Matches (target, offset)
Matches方法类似Match方法，只是Matches方法返回一组Match对象，代表目标字符串
中的所有匹配结果，而不是第一次的匹配结果。返回的对象为MatchCollection。
例如，初始化代码如下：
Dim R as New Regex("\w+*)
 =   
下面的程序：
Dim BunchOfMatches as MatchCollection = R.Matches (Target)
Dim I as Integer
For I=0 to BunchOfMatches.Count.-1
Dim MatchObj as Match = BunchOfMatches.Item(I)
Console.WriteLine(*Match: " & MatchObj.Value)
Next
运行结果是：
Match: a
Match:few
Match: words
下面的程序输出同样的结果，它说明，Matchcollection对象可以一次分配整个Match-
Collection。
Dim MatchObj as Match
For Each MatchObj in R.Matches (Target)
Console.WriteLine(*Match:*& MatchObj.Value)
Next
---
## Page 449
核心对象详解
423
作为比较，下面的代码也可以达到同样的效果，使用Match（而不是Matches）方法：
Dim MatchObj as Match = R.Match(Target)
While Matchobj.Success
Console.WriteLine("Match:"& MatchObj.Value)
MatchObj =MatchObj.NextMatch()
End While
RegexObj.Replace(target，replacement)
Return type:String
RegexObj.Replace (target，replacement，count)
RegexObj.Replace(target,replacement,count,offset)
Replace方法会在目标字符串中进行查找-替换，返回（有可能已经变化的）字符串副本。它
应用的是Regex对象的正则表达式，返回的不是Match对象，而是替换的结果。匹配的文
本被什么内容替换，取决于replacement参数。replacement参数可以重载：它可以是·个字
符串，也可以是MatchEvaluator委托（delegate）。如果replacement是一个字符串，它会
按照下一页补充内容的说明进行处理。例如：
Dim R_CapWord as New Regex("\b[A-Z]\w*")
Text =R_CapWord.Replace(Text,"$0")
把每一个大写单词两边加上。
如果设置了count，就只会进行count次替换（默认情况是进行所有的替换）。如果只希望替
换第一次匹配，可以将counr设置为1。如果我们知道只会有一次匹配，把counr明确设置
为1的效率会更高，因为不需要对字符串的其他部分进行查找和处理。把count设置为-1
表示“所有匹配都必须替换”（它等价于没有设置count）。
如果设置了ofset（一个整数），则应用正则表达式时，目标字符串中对应数目的字符会被
忽略。这些忽略的字符会直接被复制到结果中。
例如，这段代码会去掉多余的空白字符（也就是将连续的多个空白字符替换为单个空格）：
Dim AnyWS as New Regex("\s+")
Target =AnywS.Replace(Target,“*)
....
同，只是它会保留行开头任意数目的空白字符。
Dim AnyWSas New Regex("\s+")
Dim LeadingwS as New Regex("^\s+*)
---
## Page 450
424
第9章：.NET
........
换时，它使用LeadingwS匹配文本的长度作为偏移值（就是要跳过的字符数目）。这里用到
了Match对象的简便特性，即LeadingwS.Match（Target）的Length属性（即便失败也没
问题，此时Length的值为0，也就是说我们需要对整个目标字符串应用AnywS）。
特殊的Replacement处理
Regex.Replace方法和Match.Result方法都可以接收能够进行特殊处理的
replacement字符串。下面的字符序列会被匹配的文本所替换：
字符序列
替换内容
$&
整个表达式匹配的文本（等于S0）
$1, $2 .
对应编号的捕获分组匹配的文本
$(name)
对应命名捕获分组匹配的文本
$'
目标字符串中匹配文本之前的文本
$'
目标字符串中匹配文本之后的文本
$S
单个‘S’字符
$_
整个原始目标字符串的副本
$+
见说明
目前，S+几乎是没有用的。它源自Perl中的S+变量，即实际参与匹配的捕获型括号中
编号最大的那个（第202页有一个例子）。而.NET的replacement字符串中的s+只是引
用正则表达式中最靠后的那个捕获型括号匹配的文本。因为捕获型括号会重新编号一
一在使用命名型捕获时，会自动进行这种操作（409），所以它基本没有用。
除了上面的情况之外，任何情况下在replacement字符串中使用‘S’都完全没问题。
使用replacement委托
replacement参数不只能用简单字符串，还可以是委托（delegate，简单说就是函数指针）。
代理函数在每次匹配之后调用，生成作为replacement的文本。因为这个函数能够进行我们
需要的任何处理，这种查找替换的机制功能非常强大。
委托的类型是MatchEvaluator，每次匹配都会调用。它所引l用的函数必须接受Match对
象，进行你所需要的任何处理，返回作为replacement的文本。
---
## Page 451
核心对象详解
425
做个比较，下面两段程序输出同样的结果：
Target =R.Replace(Target,">"))
Function MatchFunc(ByVal M as Match) as String
return M.Result(">")
End Function
Dim Evaluator as MatchEvaluator = New MatchEvaluator (AddressOf MatchFunc)
Target = R.Replace(Target,Evaluator)
两段程序都用>标注匹配的文本。使用委托的好处在于，在计算replacement时我们可
以进行任意复杂的操作。下面的例子把摄氏温度转换为华氏温度：
Function MatchFunc(ByVal M as Match) as String
·从S1获得温度数值，转换为华氏温度
Dim Celsius as Double = Double.Parse (M.Groups (1).Value)
Dim Fahrenheit as Double = Celsius * 9/5 + 32
ReturnFahrenheit&“F"‘添加"F"，然后返回
End Function
Dim Evaluator as MatchEvaluator = New MatchEvaluator (AddressOf MatchFunc)
***
Target = R_Temp.Replace(Target,Evaluator)
如果目标字符串中包含Tempis37C.，它会被替换为Tempis98.6F.。
RegexObj.split (target)Return type: array of String
RegexObj.split (target，count)
RegexObj.split (target,count,offset)
Split方法将自标正则表达式应用于目标字符串，返回由各匹配分隔的字符串数组。如下
面这个例子所示：
Dim R as New Regex(*\.")
Dim Parts as String() = R.Sp1it(*209.204.146.22*)
R.Split返回包含四个字符串的数组（`209’、‘204'、‘146’和‘22'），它们由.在目
标字符串中的三次匹配来分隔。
如果提供了count参数，则至多返回count个字符串（除非使用了捕获型括号，一会儿会说
到这个问题）。如果没有提供count，Split返回所有匹配分隔的字符串。提供counr的意思
是，正则表达式可能在找到最终匹配之前停止应用，若果真如此，数组中最后的元素就是
目标字符串中余下的部分。
Dim R as New Regex(*\.")
Dim Parts as String() = R.Split("209.204.146.22",2)
此时，Parts得到两个字符串，‘209”和“204.146.22。
---
## Page 452
426
第9章：.NET
如果设置了ofset（一个整数），则正则表达式的匹配尝试从对应编号的字符开始。前面的
offset个字符会作为数组的第一个元素返回（如果设置了RegexOptions.RightToLeft，就
会作为最后一个元素)。
在Split中使用捕获型括号
本不会包含）。来看个简单的例子，要拆分字符串“2006-12-31’或是“04/12/2007”，你
可能会使用[-/]：
Dim R as New Regex(*[-/]")
Dim PartS as String() = R.Split (MyDate)
结果包含3个元素（均为字符串）。不过，使用捕获型括号的正则表达式（（-/.1），则会
“-’、‘31’。多出来的‘-’是每次捕获的$1。
如果有多组捕获型括号，它们会按照编号排序（也就是说，所有的命名捕获跟随在未命名
捕获之后409）。
只要实际参与了匹配捕获型括号的捕获型括号，都会包含在Split的结果中。不过，目前
的.NET有一个bug，即如果某组捕获型括号没有参与匹配，它和所有编号更靠后的捕获型
括号都不会包含在返回的结果中。
来看个极端点的例子，如果需要以左右可能出现空白字符的逗号作为分隔，而且空白字符
必须包含在返回结果中。用（\s+）？.（\s+）？i分隔‘this',"that'，得到四个字符串‘this”、
、‘"’和‘that’。但是，如果目标字符串为‘this，"that'，因为第一组捕获型括号
没有参与最终匹配，所有的捕获型括号都不包含在最终结果中，所以只会返回两个字符串
this’和‘that’。无法预知到底会返回多少字符串，是当前版本的.NET的一个重大问
题。
在这个例子中，我们可以使用（\s*），（八s*）绕开这个问题（这样两个分组一定都能参与匹
配）。不过，更复杂的表达式就没这么容易改写了。
9
---
## Page 453
核心对象详解
427
RegexObj.GetGroupNames()
RegexObj.GetGroupNumbers()
RegexObj.GroupNameFromNumber(number)
RegexObj.GroupNumberFromName(name)
这几个方法容许用户查询对应编号（可以用数字，如果是命名捕获，也可以用名字）的捕
获型分组的信息。它们引用的不是特定的匹配内容，只是正则表达式中存在的分组的名字
和编号。下面的补充内容说明了使用方法。
RegexObj.rostring()
RegexObj.RightToLeft
RegexObj.options
这几个方法容许用户查询Regex对象本身（而不是将此对象应用到字符串上）的信息。
ToString（）方法返回正则表达式构造函数接收的字符串。RightToLeft属性返回-一个
Boolean值，表明它是否启用了RegexOptions.RightToLeft选项。Options属性返回与
此正则表达式相关的RegexOptions。下面说明了各个选项的值，把对应选项的值相加，就
得到返回结果。
16
Singleline
1
IgnoreCase
32
IgnorePatternwhitespace
2
Multiline
64
RightToLeft
4 ExplicitCapture
256
ECMAScript
8 Compiled
这里没有128，因为它用于微软内部的调试，没有出现在最终产品中。
补充内容给出了这些方法的应用实例。
使用Match对象
UsingAiatch Objects
有三种方法创建Match对象：Regex的Match方法、静态函数Regex.Match（稍后介绍）
和Match对象自己的NextMatch方法。它封装某个正则表达式的单次应用的所有相关信息。
其属性和方法如下：
MatchObj.Success
返回一个Boolean值，表示匹配是否成功。如果不成功，则返回一个静态的Match.Empty
对象（433）。
MatchObj.value
MatchObj.ToString()
它返回实际匹配文本的副本。
---
## Page 454
428
第9章：.NET
显示Regex对象的信息
这段代码显示了Regex对象R的信息
'显示关于Regex变量R的已知信息
Console.WriteLine("Regex is:"& R.ToString())
Console.WriteLine(*Options are:*& R.Options)
If R.RightToLeft
Console.WriteLine("Is Right-To-Left: True")
Else
Console.WriteLine(*Is Right-To-Left: False")
End If
Dim S as String
For Each S in R.GetGroupNames()
Console.WriteLine(*Name *"*