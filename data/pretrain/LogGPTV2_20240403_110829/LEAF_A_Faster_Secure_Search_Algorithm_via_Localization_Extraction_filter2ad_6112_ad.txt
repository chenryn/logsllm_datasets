0
0
0
0
0
0
1
0
0
AGHL_Step(ğ‘“ ğ‘–ğ‘›)
Step 4
0
1
0
0
0
0
0
0
0
0
0
0
ğ‘œğ‘¢ğ‘¡
0
0
0
0
0
ğ¸ğ‘¥_ğ‘œğ‘¢ğ‘¡
Expension
ğ¸ğ‘¥_ğ‘£
ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘
0
Ã—
0
1
Ã—
0
0
0
1
0
0
Ã— . . .
0
0
. . .
1
1
1
1
0
0
0
1
0
1
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
Figure 7: Reconstruction step: we want to get a pulse array
with the same length as the original array, while the only
1â€™s index is corresponding to the first non-zero term in the
original array.
ğ¸ğ‘¥_ğ‘£[ğ‘–] = Â· Â· Â· = ğ¸ğ‘¥_ğ‘£[ğ‘– + (ğ‘¡ âˆ’ 1)ğ‘˜] = ğ¸ğ‘¥_ğ‘œğ‘¢ğ‘¡[ğ‘–]
Integration: We multiply the expanded array ğ¸ğ‘¥_ğ‘£ by the array
ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘ we got from the previous section to get a new array ğ‘œğ‘¢ğ‘¡,
âˆ€ğ‘– âˆˆ [ğ‘›]:
ğ‘œğ‘¢ğ‘¡[ğ‘–] = ğ¸ğ‘¥_ğ‘£[ğ‘–] Ã— ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘[ğ‘–]
Since the array ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘ is only non-zero in the target interval, the
result of the multiplication is the final reconstructed array.
4.2.4 Transform array to number. This subroutine takes as input
an encrypted array, which consists of a single 1 and multiple 0s for
the rest, and outputs the ciphertext of the index of the non-zero
term in the array.
As a slightly abuse of notation, ğ‘œğ‘¢ğ‘¡ âˆˆ {0, 1}ğ‘› represents a vector
of encrypted bits as input, where ğ‘¥ denotes ğ‘¥â€™s ciphertext. We
obtain the binary representation of the index (of the non-zero term
in ğ‘œğ‘¢ğ‘¡) in encrypted form, i.e., by outputing ğµ Â· ğ‘œğ‘¢ğ‘¡, where ğµ âˆˆ
{0, 1}âŒˆlog(ğ‘›+1)âŒ‰Ã—ğ‘› is a âŒˆlog(ğ‘› + 1)âŒ‰ Ã— ğ‘› matrix whose every ğ‘–-th
column is the binary representation of integer ğ‘– in cleartext.
While the process seemingly involves multiplications, it actually
requires only homomorphic additions since ğµ consists of 0-1 valued
entries in plaintext, and therefore multiplying ğµ with a vector ğ‘œğ‘¢ğ‘¡
of encrypted entries first selects the corresponding ciphertexts in
ğ‘œğ‘¢ğ‘¡ (based on the values in ğµ) and then outputs their encrypted
sum using homomorphic additions. We provide an example below
for ğ‘› = 4 and thus ğµ is a 3 Ã— 4 matrix and we let the encrypted
vector ğ‘œğ‘¢ğ‘¡ = (0, 1, 0, 0)ğ‘‡ . Multiplying ğµ and ğ‘œğ‘¢ğ‘¡ yields:
(cid:169)(cid:173)(cid:171)0
0
1
0
1
0
0
1
1
1
0
0
(cid:170)(cid:174)(cid:172) Â·(cid:169)(cid:173)(cid:173)(cid:173)(cid:171)
(cid:170)(cid:174)(cid:174)(cid:174)(cid:172) =(cid:169)(cid:173)(cid:171) 0
1 + 0
0 + 0
0
1
0
0
(cid:170)(cid:174)(cid:172) =(cid:169)(cid:173)(cid:171)0
(cid:170)(cid:174)(cid:172) ,
1
0
where the result (0, 1, 0)ğ‘‡ corresponds to binary representation
of 2 (i.e., the non-zero termâ€™s index in ğ‘œğ‘¢ğ‘¡).
Core Idea of Our Algorithm: In our algorithm, we use the Local-
ization technique to narrow down the scope of the first 1 entity,
then use the Extraction technique to extract the desired interval, so
that we do not need to apply expansive operations on non-target
Figure 6: Extraction step: we turn elements in the non-target
interval to 0, then add the corresponding position together
to obtain the target interval.
Adding the elements in the corresponding position of each in-
terval, because all the elements in the interval except the interval
with the first 1 are all 0, so the result is the interval with the first
non-zero item. So far, we have completed the goal of extracting the
target interval.
Step 4: After extracting the target interval, we only need to call
AGHL_Step algorithm on this interval to obtain a pulse array, then
we assign the result to array ğ¸ğ‘¥_ğ‘œğ‘¢ğ‘¡. There are two things we want
to point out about AGHL_Step algorithm:
(1) Compared with AGHL algorithm mentioned above, this algo-
rithm (AGHL_Step) eliminates the step of finally converting
pulse array into binary representation;
(2) The parameter selection of RS-OR operation in this algo-
rithm is the same as we mentioned in Section 3.3, which are
all ğ‘ (ğœ€) = âŒˆlog( ğ‘›
ğœ€ )âŒ‰, means that the probability of failure of
all RS-OR operations in this paper is ğœ€
ğ‘›
Compared to the previous algorithm, LEAF algorithm does not need
to apply RS-OR on every elements in the array, instead, we utilize
RS-OR in a coarse-grained manner, that is, we partition the original
array, evaluate only one RS-OR operation in an interval, and replace
the result of the whole interval with this result, so as to determine
the first non-zero element into a smaller interval with less expen-
sive operations. Although the localization and extraction steps bring
extra time overhead, through choosing suitable parameters, we ob-
tained, by analysis, the ascension of the whole performance of the
algorithm will be relatively large. All the way through, we get ap-
proximate interval coordinates of the first non-zero element and the
offset within that interval. In the Reconstruction step, weâ€™ll explain
how to build the final result with the two position information.
4.2.3 Reconstruction. In this step, our goal is to integrate the po-
sition information from the two steps above into one final output.
The process is shown in Figure 7.
Expansion: In this step, we extend the pulse array (ğ¸ğ‘¥_ğ‘œğ‘¢ğ‘¡) ob-
tained by AGHL_Step algorithm to an array with the same length
as the original array (ğ‘£), âˆ€ğ‘– âˆˆ [ğ‘˜]:
ğ‘›âŒ‹, ğ‘˜ = âŒˆ ğ‘›
Algorithm 1 LEAF
1: Input: Array ğ‘£ âˆˆ {0, 1}ğ‘›;
2: Output: ğ‘–âˆ— = ğ‘šğ‘–ğ‘›{ğ‘– âˆˆ [ğ‘›] | ğ‘£[ğ‘–] == 1};
3: Set ğ‘¡ = âŒŠâˆš
ğ‘¡ âŒ‰, pad the input array by ğ‘¡ Ã— ğ‘˜ âˆ’ ğ‘› zero
entries;
4: Create a new array ğ‘–ğ‘›ğ‘‘ âˆˆ {0, 1}ğ‘¡, âˆ€ğ‘– âˆˆ [ğ‘¡], set ğ‘–ğ‘›ğ‘‘[ğ‘–] â†
RS-OR(ğ‘£[1], ğ‘£[2], . . . , ğ‘£[ğ‘– Ã— ğ‘˜]);
5: Create a new array ğ‘“ ğ‘™ğ‘ğ‘” âˆˆ {0, 1}ğ‘¡, âˆ€ğ‘– âˆˆ [2, ğ‘¡] : ğ‘“ ğ‘™ğ‘ğ‘”[ğ‘–] â†
ğ‘–ğ‘›ğ‘‘[ğ‘–] âˆ’ ğ‘–ğ‘›ğ‘‘[ğ‘– âˆ’ 1], ğ‘“ ğ‘™ğ‘ğ‘”[ğ‘¡ + 1] â† 1 âˆ’ ğ‘–ğ‘›ğ‘‘[ğ‘¡];
6: Create a new array ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘ âˆˆ {0, 1}ğ‘›: âˆ€ğ‘— âˆˆ [ğ‘¡],âˆ€ğ‘– âˆˆ
[ğ‘˜] ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘[( ğ‘— âˆ’ 1) Â· ğ‘˜ + ğ‘–] â† ğ‘“ ğ‘™ğ‘ğ‘”[ ğ‘—];
7: âˆ€ğ‘– âˆˆ [ğ‘›], ğ‘£[ğ‘–] â† ğ‘£[ğ‘–] Ã— ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘[ğ‘–];
8: Create a new array ğ‘“ ğ‘–ğ‘› âˆˆ {0, 1}ğ‘˜: âˆ€ğ‘— âˆˆ [ğ‘˜], ğ‘“ ğ‘–ğ‘›[ ğ‘—] â† ğ‘£[ ğ‘—] +
ğ‘£[ğ‘˜ + ğ‘—] + Â· Â· Â· + ğ‘£[(ğ‘¡ âˆ’ 1) Ã— ğ‘˜ + ğ‘—];
9: ğ¸ğ‘¥_ğ‘œğ‘¢ğ‘¡ â† AGHL_Step(ğ‘“ ğ‘–ğ‘›);
10: Create a new array ğ¸ğ‘¥_ğ‘£ âˆˆ {0, 1}ğ‘›: âˆ€ğ‘– âˆˆ [ğ‘˜], ğ¸ğ‘¥_ğ‘£[ğ‘–] =
11: Create a new array ğ‘œğ‘¢ğ‘¡ âˆˆ {0, 1}ğ‘›:âˆ€ğ‘– âˆˆ [ğ‘›], ğ‘œğ‘¢ğ‘¡[ğ‘–] â† ğ¸ğ‘¥_ğ‘£[ğ‘–]Ã—
12: index â† ğµ Â· ğ‘œğ‘¢ğ‘¡, ğ‘“ ğ‘œğ‘Ÿ ğµ âˆˆ {0, 1}âŒˆlog(ğ‘›+1)âŒ‰Ã—ğ‘›;
13: return index;
ğ¸ğ‘¥_ğ‘£[ğ‘– + ğ‘˜] = Â· Â· Â· = ğ¸ğ‘¥_ğ‘£[ğ‘– + (ğ‘¡ âˆ’ 1)ğ‘˜] = ğ¸ğ‘¥_ğ‘œğ‘¢ğ‘¡[ğ‘–];
ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘[ğ‘–];
intervals, significantly reducing the number of multiplication op-
erations. Finally, we use Reconstruction technique to construct the
final output based on the two position information.
The reason why we need to use new techniques to extract the
target interval instead of directly using array index is based on
the fact that the coordinates representing the general range are
homomorphically encrypted, and the server cannot get the general
position of the target items.
Combining the above operations, we get Algorithm 1 (The selec-
tion of ğ‘¡, ğ‘˜ is detailed in Section 5.2).
4.3 Correctness of LEAF Algorithm
In this paper, a low-degree approximation method for OR called
RS-OR is adapted to construct our algorithm, this method can
significantly reduce the degree of the algorithm, but at the same
time introduce some error probability. We will prove that the error
probability of our algorithm can be controlled at a very low level.
As mentioned above, all RS-OR operations in this paper select
the same parameter ğ‘ (ğœ€) = âŒˆlog( ğ‘›
ğœ€ )âŒ‰, according to the proof in
Section 3.3, all RS-OR operations with this parameter has the same
correct probability which is 1 âˆ’ ğœ€
ğ‘› .
In the Localization step, we divide the original array into ğ‘¡ inter-
vals of equal length, so in this step, we calculate RS-OR for a total
of ğ‘¡ times. In our Extraction step, we performed RS-OR for each
element in the target interval with length ğ‘˜, so we calculated a total
of ğ‘˜ times of RS-OR operations in this step. In addition, other parts
of our algorithm did not use RS-OR operation, so our algorithm
used ğ‘¡ + ğ‘˜ times of RS-OR operation, if these operations do not
occur any error, our algorithm will be correct.
Based on the conclusion in Section 5.2, we select the parameter
âˆš
ğ‘› in this paper, so the probability of our algorithm being
ğ‘¡ = ğ‘˜ =
correct is:
ğ‘ƒğ‘ŸLEAF =(cid:0)1 âˆ’ ğœ€
ğ‘›
(cid:1)ğ‘¡+ğ‘˜ =(cid:0)1 âˆ’ ğœ€
(cid:1)2âˆš
ğ‘›
ğ‘›
ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘
ğ‘–ğ‘¡ğ‘’ğ‘šğ‘ 
0
Ã—
?
0
Ã—
?
1
1
1
1
0
0
Ã— . . .
?
?
?
ğ‘‹
?
?
0
?
0
?
0
?
0
?
0
?
0
?
0
?
0
?
. . .
ğ‘¡ğ‘’ğ‘šğ‘1
0
0
0
0
?
ğ‘‹
?
?
0
0
0
0
0
0
0
0
Step 1
?
Ã—
ğ‘¡ğ‘’ğ‘šğ‘2
ğ¸ğ‘¥_ğ‘œğ‘¢ğ‘¡
ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡
0
0
ğ‘‹
Ã—
1