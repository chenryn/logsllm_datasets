### Mitigating Transient Loops

We propose two straightforward techniques to mitigate the occurrence of even transient loops. The first technique involves introducing a small counter, known as the deflection counter, into the shim header. This counter restricts the number of times a packet can switch slices. Given that most packets traverse only about four Autonomous Systems (ASes) [19], most potential loops will be small. Recording the last four ASes traversed by a packet in the packet header and restricting the ASes to which packets are deflected can also prevent interdomain loops.

### AS-Level Forwarding Consistency

In interdomain splicing, traffic might be forwarded along any of the top k best routes for a prefix, but an AS announces only a single best route to its neighbors. Some may view using a route not announced to its neighbors as a violation of protocol semantics. However, we note that an AS will use a non-default path only if the splicing bits in the packet explicitly request this behavior or if the default path has failed. It is also important to note that, even today, the AS-level forwarding path is not guaranteed to match the advertised AS path, and many such violations occur in practice [30].

### Reliability with Splicing

- **Intradomain Splicing:** Using 5 slices achieves near-optimal reliability.
- **Interdomain Splicing:** Only 2 slices achieve near-optimal reliability.

### Fast Recovery with Splicing

An end system can recover from failure in approximately 2 trials when trying splicing bits at random.

### Perturbations and Path Stretch

- **Intradomain Splicing:** Achieves an average stretch of 20% while gaining 80% paths that are different from the original.
- **Interdomain Splicing:** The average hop stretch is only 3.8% when 5% of AS links have failed.

### Comparison with Routing Deflections

Path splicing with just 5 slices can provide better recovery than routing deflections [32] with bounded stretch. Generally, path splicing provides much shorter recovered paths with lower variance in terms of stretch.

### Incremental Deployability

Splicing offers significant benefits even if only a fraction of ASes deploy it.

### Loop Frequency

Forwarding loops are transient and infrequent. In intradomain splicing, we observed only one loop longer than 2 hops, even with 10% of links failed.

### Minimal Disruption to Traffic

Splicing does not significantly disrupt network traffic. Our evaluation using real traffic data on Abilene shows that the total load on links increases by only 4% on average.

### Summary of Results

| Metric | Result |
|--------|--------|
| High Reliability | Intradomain: 5 slices, Interdomain: 2 slices |
| Fast Recovery | 2 trials on average |
| Perturbations | Intradomain: 20% stretch, 80% new paths; Interdomain: 3.8% stretch |
| Better Recovery | Shorter and more consistent recovered paths |
| Incremental Deployability | Significant benefits with partial deployment |
| Loop Frequency | Rare and transient |
| Traffic Disruption | Minimal (4% increase in link load) |

### Evaluation

#### 7.1 High Reliability

##### 7.1.1 Intradomain Splicing

To evaluate the reliability of path splicing under various link-failure scenarios, we implemented a simulator that takes a "base" network topology (with link weights) and outputs different shortest path trees using degree-based perturbations. We simulated link failures by removing each edge with a fixed failure probability. We used the Sprint backbone network topology inferred from Rocketfuel, which has 52 nodes and 84 links [29]. We computed the reliability curves for graphs generated using path splicing and compared them to conventional shortest paths routing and the original underlying graph.

A spliced graph with k slices is constructed by taking the union of the k slices, each generated as a random perturbation. We removed each edge independently with probability p and evaluated the reliability for each k and p. Figure 6 shows the reliability curves for Sprint using degree-based perturbations. Adding just one slice (i.e., increasing k to 2) significantly improves reliability, and adding more slices further enhances it. Even with just a few slices (i.e., 5), the reliability of path splicing approaches that of the original underlying network.

##### 7.1.2 Interdomain Splicing

To evaluate the reliability of interdomain splicing, we used C-BGP [25], an open-source BGP routing solver. C-BGP takes a policy-annotated graph of ASes and calculates the interdomain routes for each AS. For our experiments, we used a 2,500 node policy-annotated AS graph generated by Dimitropoulos et al. [10]. We removed AS edges at random with probability p and checked for connectivity between random pairs of ASes. In cases where the default path was disconnected, we checked if a "spliced" path existed using up to k choices for the next-hop. We repeated this process 50 times for each value of p and k. Figure 7 shows the average fraction of pairs disconnected for a range of values for p and k. Adding just one more slice significantly improves the reliability of the AS graph. The reliability curve for interdomain splicing that respects policy is close to the best possible reliability curve, demonstrating that BGP, even with policy restrictions, has near-optimal path diversity if multiple routes are used.

#### 7.2 Fast Recovery

We demonstrate how an end system or a network node can quickly recover from failures by selecting spliced paths at random. We evaluate two approaches to recovery: end-system recovery, which is network-agnostic and relies on the end system to initiate recovery, and network-based recovery, which assumes that the node can detect a failure and divert traffic to a different slice. We only show results from end-system recovery.

For all disconnected source-destination pairs, we evaluate whether splicing allows nodes to discover working alternate paths. If splicing can recover the path in five or fewer trials, we consider the path recoverable. Figure 8 shows the recovery where the end system controls the spliced path to the destination. In our experiments, we used a header that allows 20 hops to be spliced. For a failed path, a new shim header is constructed by tossing a coin for every hop; if the result is heads, a different slice is selected at random. We check if a failed path can be recovered in fewer than 5 trials. The average number of trials in any case where splicing could recover from the failure was slightly more than 2. Paths were, on average, 1.3 times longer in terms of path cost compared to the shortest path in the "base" topology, and typically used about 50% more hops.