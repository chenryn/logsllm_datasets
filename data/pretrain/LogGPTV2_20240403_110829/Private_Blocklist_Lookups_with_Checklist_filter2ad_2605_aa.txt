title:Private Blocklist Lookups with Checklist
author:Dmitry Kogan and
Henry Corrigan-Gibbs
Private Blocklist Lookups with Checklist
Dmitry Kogan, Stanford University; Henry Corrigan-Gibbs, MIT CSAIL
https://www.usenix.org/conference/usenixsecurity21/presentation/kogan
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.Private Blocklist Lookups with Checklist
Dmitry Kogan
Stanford University
Henry Corrigan-Gibbs
MIT CSAIL
Abstract. This paper presents Checklist, a system for private
blocklist lookups. In Checklist, a client can determine whether
a particular string appears on a server-held blocklist of strings,
without leaking its string to the server. Checklist is the ﬁrst
blocklist-lookup system that (1) leaks no information about
the client’s string to the server, (2) does not require the client
to store the blocklist in its entirety, and (3) allows the server to
respond to the client’s query in time sublinear in the blocklist
size. To make this possible, we construct a new two-server
private-information-retrieval protocol that is both asymptoti-
cally and concretely faster, in terms of server-side time, than
those of prior work. We evaluate Checklist in the context of
Google’s “Safe Browsing” blocklist, which all major browsers
use to prevent web clients from visiting malware-hosting
URLs. Today, lookups to this blocklist leak partial hashes of a
subset of clients’ visited URLs to Google’s servers. We have
modiﬁed Firefox to perform Safe-Browsing blocklist lookups
via Checklist servers, which eliminates the leakage of partial
URL hashes from the Firefox client to the blocklist servers.
This privacy gain comes at the cost of increasing communica-
tion by a factor of 3.3×, and the server-side compute costs by
9.8×. Checklist reduces end-to-end server-side costs by 6.7×,
compared to what would be possible with prior state-of-the-art
two-server private information retrieval.
Introduction
1
This paper proposes a new system for private blocklist lookups.
In this setting, there is a client, which holds a private bitstring,
and a server, which holds a set of blocklisted strings. The
client wants to determine whether its string is on the server’s
blocklist, without revealing its string to the server.
This blocklist-lookup problem arises often in computer
systems:
• Web browsers check public-key certiﬁcates against block-
lists of revoked certiﬁcates [54,60,61].
• Users of Google’s Password Checkup and the “Have I Been
Pwned?” service check their passwords against a blocklist
of breached credentials [51,62,63,82,84].
• Antivirus tools check the hashes of executed binaries
against blocklists of malicious software [26,57,65].
• Browsers and mail clients check URLs against Google’s
Safe Browsing blocklist of phishing sites [9,38,43].
A simple approach for blocklist lookups is to store the
blocklist on the server and have the client send its query string
to the server. However, the string that the client is checking
against the blocklist is often private: the client wants to hide
from the server which websites she is visiting, or which
passwords she is using, or which programs she is running.
Another approach is to store the entire blocklist on the
client [28]. Maintaining a client-side blocklist oﬀers maximal
client privacy, since the server learns nothing about which
strings the client checks against the blocklist. The downside is
that the client must download and store the entire blocklist—
consuming scarce client-side bandwidth and storage. Chrome
uses this approach for its certiﬁcate-revocation blocklist [60].
Unfortunately, client-side resource constraints limit the size
of client-side blocklists: Chrome’s revocation blocklist (as
of May 2021) covers under 1,200 revoked certiﬁcates out of
millions of revoked certiﬁcates on the web [52], and thus
provides suboptimal protection against revoked certiﬁcates.
A hybrid approach is also possible: the client stores a
compressed version of the blocklist, which allows the client
to perform most blocklist lookups locally, at a modest storage
cost. The compressed blocklist, like a Bloom ﬁlter [11], can
return false-positive answers to blocklist queries. When the
local blocklist gives a positive answer, the client queries the
server to check whether a local positive is a true positive. The
Safe Browsing API client uses this technique. The limitation
of this strategy is that the client’s queries to the server still
leak some information about the client’s private string. In
particular, the Safe Browsing client’s queries to the server
allow the server to make a good guess at which URL the client
is visiting [9,38,45,70].
Existing techniques for private blocklist lookups are inad-
equate. Keeping the blocklist on the client in its entirety is
infeasible when the blocklist is large. Querying a server-side
blocklist leaks sensitive client data to the server.
This paper presents the design and implementation of
Checklist, a new privacy-respecting blocklist-lookup system.
Using Checklist is less expensive, in terms of total communi-
cation, than maintaining a client-side blocklist. And, unlike
conventional server-side blocklists, Checklist leaks nothing
about the client’s blocklist queries to the system’s servers. We
achieve this privacy property using a new high-throughput
form of two-server private information retrieval. Checklist
requires only a modest amount of server-side computation:
USENIX Association
30th USENIX Security Symposium    875
𝑂(√
in a blocklist of 𝑛 entries, the amortized server-side cost is
𝑛) work per query. Concretely, a server can answer client
queries to the three-million-entry Safe Browsing blocklist in
under half a core-millisecond per query on average. Our new
PIR scheme reduces the server-side compute costs by 6.7×,
compared with a private-blocklist scheme based on existing
PIR protocols.
To our knowledge, Checklist is the ﬁrst blocklist-lookup
system that (1) leaks no information about the client’s string
to the server, (2) does not require the client to store the
blocklist in its entirety, and (3) achieves per-query server-side
computation that is sublinear in the blocklist size.
√
At the heart of Checklist is a new “oﬄine/online” private-
information-retrieval scheme [12,27,69]. These schemes use
client-speciﬁc preprocessing in an oﬄine phase to reduce the
computation required at query (online) time. On a blocklist
with 𝑛 entries and with security parameter 𝜆 ≈ 128, our
scheme requires the servers to perform work 𝑂(√
𝑛) per query,
on average. This improves the 𝑂(𝜆
𝑛) per-query cost of
schemes from prior work [27] and amounts to a roughly 128-
fold concrete speedup. In addition, prior oﬄine/online schemes
do not perform well when the blocklist/database changes often
(since even a single-entry change to the blocklist requires
rerunning the preprocessing step). By carefully structuring the
blocklist into a cascade of smaller blocklists, we demonstrate
that it is possible to reap the beneﬁts of these fast oﬄine/online
private-information-retrieval schemes even when the blocklist
contents change often. In particular, in a blocklist of 𝑛 entries,
our scheme requires server-side computation 𝑂(log 𝑛) per
blocklist update per client, whereas a straightforward use of
oﬄine/online private-information-retrieval schemes would
yield Ω(𝑛) time per update per client.
Limitations. First, since Checklist builds on a two-server
private-information-retrieval scheme, it requires two inde-
pendent servers to maintain replicas of the blocklist. The
system protects client privacy as long as at least one of these
two servers is honest (the other may deviate arbitrarily from
the prescribed protocol). In practice, two major certiﬁcation
authorities could run the servers for certiﬁcate-revocation
blocklists. Google and Mozilla could run the servers for the
Safe-Browsing blocklist. An OS vendor and antivirus vendor,
such as Microsoft and Symantec, could each run a server for
malware blocklists. Second, while Checklist reduces server-
side CPU costs, compared with a system built on the most
communication-eﬃcient prior two-server PIR scheme [15]
(e.g., by 6.7× when used for Safe Browsing), Checklist in-
creases the client-to-server communication (by 2.7×) relative
to a system based on this earlier PIR scheme. In applications
in which client resources are extremely scarce, Checklist may
not be appropriate. But for applications in which server-side
costs are important, Checklist will dominate. We discuss these
and other deployment considerations in Section 8.
Experimental results. We implemented our private blocklist-
lookup system in 2,481 lines of Go and 497 lines of C. In
addition, we conﬁgure the Firefox web browser to use our
private blocklist-lookup system to query the Safe Browsing
blacklist. (By default Firefox makes Safe-Browsing blocklist
queries to the server via the Safe Browsing v4 API, which leaks
a 32-bit hash of a subset of visited URLs to Google’s servers.)
Under a real browsing workload, our private-blocklisting
system requires 9.4× more servers than a non-private baseline
with the same latency and increases total communication cost
by 3.3×. We thus show that it is possible to eliminate a major
private risk in the Safe Browsing API at a manageable cost.
Contributions. The contributions of this paper are:
• A new two-server oﬄine/online private-information-
retrieval protocol that reduces the servers’ computation by
a factor of the security parameter 𝜆 ≈ 128.
• A general technique for eﬃciently supporting database
updates in private-information-retrieval schemes that use
database-speciﬁc preprocessing.
• A blocklist-lookup system that uses these new private-
information-retrieval techniques to protect client privacy.
• An open-source implementation and experimental valida-
tion of Checklist applied to the Safe Browsing API. (Our
code is available on GitHub [1].)
2 Goals and overview
2.1 Problem statement
In the private-blocklist-lookup problem, there is a client and
one or more blocklist servers. The blocklist B is a set of
strings, of which each server has a copy. We assume, without
loss of generality, that the strings in the blocklist are all of
some common length ℓ (e.g., 256 bits). If the strings are
longer or shorter, we can always hash them to 256 bits using
a collision-resistant hash function, such as SHA256.
Initially, the client may download some information about
the blocklist from the servers. Later on, the client would like
to lookup strings in the blocklist: the client holds a string
𝑋 ∈ {0, 1}ℓ and, after interaction with the servers, the client
should learn whether or not the string 𝑋 is on the servers’
blocklist (i.e., whether 𝑋 ∈ B). In addition, the servers may
add and remove strings from the blocklist over time. We do
not attempt to hide the blocklist from the client, though it is
possible to do so using an extension described in Section 8.2.
The goals of such a system, stated informally, are:
• Correctness. Provided that the client and servers correctly
execute the prescribed protocol, the client should receive
correct answers to its blocklist queries, except with some
negligible failure probability.
• Privacy. In our setting, there are two blocklist servers
and as long as one of these servers executes the protocol
faithfully, an adversary controlling the network and the
other blocklist server learns nothing about the queries
876    30th USENIX Security Symposium
USENIX Association
that the client makes to the blocklist (apart from the total
number of queries).
Formally, the adversarial server should be able to simulate
its view of its interaction with the client and the honest
server, given only the system’s public parameters and the
number of queries that the client makes.
Eﬃciency. In our setting, the two key eﬃciency metrics are:
• Server-side computation: The amount of computation that
the servers need to perform per query.
• Total communication: The number of bits of communica-
tion between the client and blocklist servers.
Since clients typically make many queries to the same blocklist,
we consider both of these costs as amortized over many queries
and many blocklist updates (additions and removals).
Using a client-side blocklist minimizes server-side compu-
tation, but requires communication linear in the number of
blocklist updates. Using standard private-information-retrieval
protocols [15, 24, 39, 59] minimizes communication but re-
quires per-client server-side computation linear in the blocklist
size. Checklist minimizes the server-side computation without
the client having to download and store the entire blocklist.
2.2 Design overview
Checklist consists of two main layers: the ﬁrst layer allows
private lookups to static array-like databases. The second
layer adds support for dynamic dictionaries that allow private
key-value lookups and eﬃcient updates. We now explain the
design of each layer.
Private lookups. A straightforward way to implement private
lookups is to use private information retrieval (PIR) [15,23,24].
With standard PIR schemes, the running time of the server on
each lookup is linear in the blocklist size 𝑛. In contrast, recent
“oﬄine/online” PIR schemes [27] reduce the server’s online
computational cost to 𝜆
𝑛, after the client runs a linear-time
preprocessing phase with the server. During this preprocessing
phase, the client downloads a compressed representation of
the blocklist. These oﬄine/online PIR schemes are well suited
to our setting: the client and server can run the (relatively
expensive) preprocessing step when the client ﬁrst joins Check-
list. Thereafter, the server can answer private blocklist queries
from the client in time sublinear in the blocklist length—much
faster than conventional PIR.
√
√
To instantiate this paradigm, we construct in Section 4 a
new oﬄine/online PIR scheme that achieves a roughly 128-
fold speedup over the state of the art, in terms of server-side
computation. (Asymptotically, our new scheme reduces the
𝑛, where 𝜆 ≈ 128
servers’ online time to roughly
is the security parameter.)
𝑛 from 𝜆
As with many PIR schemes, our protocol requires two
servers, and it protects client privacy as long as at least one
server is honest.
Dynamic dictionaries. Oﬄine/online PIR schemes allow the
server to answer client queries at a low cost after the client and
√
server have run a relatively expensive preprocessing phase.
One hitch in using these schemes in practice is that the client
and server have to rerun the expensive preprocessing step
whenever the server-side blocklist (database) changes. If the
blocklist changes often, then the client and server will have to
rerun the preprocessing phase frequently. The recurring cost
of the preprocessing phase may then negate any savings that
an oﬄine/online PIR scheme would aﬀord.
The second layer of our system, described in detail in
Section 5, reaps the eﬃciency beneﬁts of oﬄine/online PIR
schemes, even in a setting in which the blocklist changes
frequently. Our high-level approach, which follows a classic
idea from the data-structures literature [10] and its applications
in cryptography [20,41,68,77,81], is to divide the length-𝑛
blocklist into 𝑂(log 𝑛) buckets, where the 𝑏th bucket contains
at most 2𝑏 entries. The eﬃciency gains come from the fact that
only the contents of the small buckets, for which preprocessing
is inexpensive, change often. The large buckets, for which
preprocessing is costly, change rarely. We use preexisting
techniques [23] to support key-value lookups to the database,
rather than array-like lookups.
With this strategy, the amortized cost per blocklist update
is 𝑂(log 𝑛). In contrast, a naïve application of oﬄine/online
PIR would lead to Ω(𝑛) amortized cost per update.
√
3 Background
This section summarizes the relevant background on private
information retrieval.
Notation. For a natural number 𝑛, the notation [𝑛] refers to
the set {1, 2, . . . , 𝑛}. All logarithms are base 2. We ignore
integrality concerns and treat expressions like
𝑛, log 𝑛, and
𝑚/𝑛 as integers. The expression negl(·) refers to a function
whose inverse grows faster than any ﬁxed polynomial. For a
ﬁnite set 𝑆, the notation 𝑟 ←R 𝑆 refers to choosing 𝑟 indepen-
dently and uniformly at random from the set 𝑆. For 𝑝 ∈ [0, 1],
the notation 𝑏 ←R Bernoulli( 𝑝) refers to choosing the bit 𝑏
to be “1” with probability 𝑝 and “0” with probability 1 − 𝑝.
For a bit 𝑏 ∈ {0, 1}, we use ¯𝑏 to denote the bit 1 − 𝑏. For two
equal-length bit strings 𝑋, 𝑌 ∈ {0, 1}ℓ, we use 𝑋 ⊕𝑌 ∈ {0, 1}ℓ
to refer to their bitwise XOR.
3.1 Private information retrieval (PIR)
In a private information retrieval (PIR) system [24, 25], a
set of servers holds identical copies of an 𝑛-row database.
The client wants to fetch the 𝑖th row of the database, without
leaking the index 𝑖 of its desired row to the servers. We work
in the two-server setting, in which the client interacts with