创建新的文件描述符需要使用系统调用open。
#include 
include 
Int open（const char *path,Int oflags）)
int open(const char *path, int oflags, mode_t sode);
严格地说，在符合POSIX规范的系统上，在用到open的时候并不是非得把sys/types.h和
sys/stat.h包括进来，但在某些UNIX系统上它们可能是必不可少的。
简单地说，open建立了一条到文件或设备的访问路径。如果操作成功，它将返回一个文件
描述符，后续的read和write等系统调用就将使用该文件描述符对打开的那个文件进行操作，文
件的文件描述符是独一无二的，并且不会与运行中的任何其他程序共享。如果两个程序同时去
打开同一个文件，会导致两个彼此不一样的文件描述符。如果它们都对文件进行写操作，那么
加入jaVa编程群：524621833
---
## Page 93
Linux程序设计
它们会各写各的，分别接着上次离开的位置继续往下写。它们的数据不会交错出现交织在一起，
而是彼此互相覆盖（后写人的内容覆盖掉前面写人的内容）。两个程序对文件的读写位置（偏移
值）有各自的理解，各十各的。为了防止出现这种我们并不希望看的混乱冲突的局面，可以用
上“文件加锁”功能，我们将在第7章里介绍它。
准备打开的文件或设备的名字被当作path参数传递到函数中去，oflags参数用来定义准备对
打开的文件进行的操作动作。
oflags参数是通过把人们要求的文件访问模式与其他可选模式按位OR操作得到的。open调用
必须给出表3-1所列的某个文件访问模式：
表3-1
模式
说明
AINO0α"0
以只读方式打开
XINOEAO
以只写方式打开
O_RDWR
以读写方式打开
open调用还可以在oflags参数中包括下列可选模式的（按位或操作OR）组合：
• O_APPEND
把写人数据追加在文件的未尾。
•O_TRUNC
把文件长度设置为零，丢弃其中现有的内容。
·O_CREAT
按mode中给出的访问模式创建文件。
·O_EXCL
与O_CREAT一起使用，确保调用者创建出文件来。open是一个最小规
模的操作，也就是说，它只完成一个函数调用。而加上这个可选模式可
以防止两个程序同时创建一个文件情况的出现。如果文件已经存在，
open操作将失败。
其他可能出现的oflags值请参考open调用的使用手册页文档，它们出现在该文档的第二小节
（用“man open2”命令查看）。
如果open成功，它会返回一个新的文件描述符（文件描述符永远是一个非负整数）；如果
失败，就返回“-1”，并对全局性的ermo变量进行设置以指明失败的原因。我们将在下一小节对
crrno做进-步讨论。新文件描述符永远取未用描述符的最小值，这在某些情况下是非常有用的。
比如说，如果一个程序关闭了自己的标准输出，然后再次调用open，就会重新使用“1”作为文
件描述符，而标准输出将被重定向到另外一个文件或设备。
POSIX技术规范还标准化了一个creat调用，但它并不常用。这个调用不仅会创建文件，还
会打开它-它的作用相当于以“O_CREAT！O_WRONLY1O_TRUNC”为oflags标志的open
调用。
3.4.4访问权限的初始化值
当我们用open加O_CREAT标志来创建一个文件的时候，必须使用open调用的三个参数格式。
第三个参数mode是几个标志按位OR操作后得到的，这些标志是在头文件/sys/stat.h里定义的，它
们是：
加入jaVa编程群：524621833
---
## Page 94
第3章如何使用和处理文件
75
·S_IRUSR读权限，文件属主。
·S_IWUSR写权限，文件属主。
·S_IXUSR执行权限，文件属主。
·S_IRGRP读权限，文件所在分组。
·S_IWGRP写权限，文件所在分组：
·S_IXGRP执行权限，文件所在分组。
·S_IROTH读权限，其他用户。
·S_IWOTH写权限，其他用户。
·S_IXOTH执行权限，其他用户。
请看下面的例子：
open (*nyfi1e*, O_CREAr, S_IRUSR  S_IXOTH);
它的作用是创建一个名为myfile的文件，文件属主拥有它的读操作权限，其他用户拥有它的
执行权限。也只有这么多权限。
1s-1smyf11e
1 nea1
sofcware
0 Sep 22 08:11 myfi1e*
有几个因素会对文件的访问权限产生影响。首先，只有文件被创建出来以后才能谈及访问
权限。第二，用户掩码（“usermask”，由shell的umask命令设定）会影响到被创建文件的访问权
限。open调用里给出的模式值将在程序运行时与用户掩码的反值做AND操作。举例来说，如果
用户掩码被设置为“001"，open调用给出了S_IXOTH模式标志，那么文件不会被创建为其他用
户拥有执行权限的情况。这是因为用户掩码中规定了不允许向其他用户提供执行权限。因此，
可以说open和creat调用中的标志实际上是设置权限的申请，所申请的权限是否会被设置还要取
决于umask在程序运行时取的值。
3.4.5umask变量
umask是一个系统变量，它的作用是为文件的访问权限设定一个掩码，再把这个掩码用在文
件创建操作中。执行umask命令可以对这个变量进行修改，给它提供一个新值。这是一个由三个
八进制数字组成的值。各数字都是八进制值1、2、4的AND操作结果。这三个数字分别对应着用
户（user）、分组（group）和其他用户（other）的访问权限。请看表3-2：
表3-2
数字
取值
含义
1
0
不禁止任何属主权限
4
禁止属主的读权限
2
禁止属主的写权限
/
禁止属主的执行权限
0
不禁止任何分组权限
4
禁止分组的读权限
2
禁止分组的写权限
禁止分组的执行权限
加入jaVa编程群：524621833
---
## Page 95
76
Linux程序设计
（续）
数
取值
含义
3
0
不禁止任何其他用户权限
4
禁止其他用户的读权限
2
禁止其他用户的写权限
1
禁止其他用户的执行权限
表3-3给出的是禁止了分组写和执行权限，禁止了其他用户写权限情况下的umask掩码：
表3-3
位置
取值
1
0
2
2
1
各位上数字的值将AND在一起；因此第2位数字的值是“2&1”，结果为“3”。最终的
umask结果是“032"。
当我们通过一个open或creat调用创建一个文件的时候，mode参数将与umask进行比较。
mode参数中被置位了的位如果在umask中也被置位了，就会被排除在访问权限的构成之外。打
文件，即使创建该文件的程序提出申请也不行。”但这样做并不会影响某个程序或用户在今后使
用chmod命令（或者在程序中使用chmod系统调用）添加其他的写权限，它确实能够帮助保护用
户的利益，让他们不必费心去检查和设置每一个新文件的访问权限。
3.4.6close系统调用
#include 
int close(int fildes);
我们用close调用终止一个文件描述符fildes与它文件之间的关联。文件描述符被释放并能够
重新使用。如果close操作成功就返回“o"，如果出错就返回“-1"。注意，检查close调用的返回
结果有时十分重要。有的文件系统，特别是网络上的文件系统，可能不会在关闭文件之前报告
文件写操作中出现的错误
对-个运行中的程序来说，能够让它一次打开的文件个数是有上限的。这个限制由文件
limits.h中的OPEN_MAX常数定义，会随着系统的不同面不同；但POSIX技术规范里要求它至少
要等于16个。单就这个上限来说，它还会受到本地计算机上系统全局性限制的影响。
3.4.7ioctl系统调用
#include 
int loctl(int fildes,int cmd,
加入jaVa编程群：524621833
---
## Page 96
第3章如何使用和处理文件
77
ioctl调用有点像是个大麻袋。它提供了一个对设备行为、设备描述符、设备底层服务的配置
工作等方面进行控制的操作界面。终端、文件描述符、套接字、甚至磁带机都可以有为它们定
义的ioctld，具体细节需要查阅各设备通过man命令提供使用手册页。POSIX技术规范只为流式
数据定义了iocu调用，对它的讨论超出了本书的讨论范围。
ioctl对描述符fides指定的对象执行在cmd中给出的操作。根据特定设备所支持的函数的不
同，还可能会有一个可选的第三参数。
动手试试：一个文件拷员程序
在学习了足够多的关于open、read和write系统调用的知识以后，我们来编写一个底层程序
copy_system.c，它的作用是逐个字符地把一个文件拷贝为另外一个文件。
在这一章里，我们将采用多种办法完成这一工作，目的就是比较各种方法的执行效
率、为简单起见，我们将假设输入文件已经存在，输出文件不存在，并且所有的读写操
作都成功了。当然，在实际程序里，我们必须对这些银设是否成主进行检验！
include 
include 
#include 
include 
int main()
char c;
int in, out;
in=open1*file.in*,O_RpoNLY1:
out=open(*fi1e.out*.O_WRONLY]o_CREAT,S_IRUSR|S_IWUSR);
while(read(in,&c,1) z= 1)
write(out,&c.11;
exit (0) ;
注意语句“include”必须最早出现，因为它根据POSIX技水规范定义的标
志将影响到其他的头文件。
首先，我们需要有一个测试用的输人文件，长度大概是1MB字节，取名为filein。
运行这个程序，大致会看到像下面这样的结果：
S1-letile.in tile.out
users
1048576 Sep 17 10:51 file.out
1048576 Sep 17 10:46 fi1e.in
1029 -rw---*
1neil
users
我们在这里用UNIX提供的time工具对这个程序花费的时间进行了测算。可以看到，1MB长
的输人文件file.in被成功地拷贝到file.out，而后者是以只允许属主进行读写的权限创建出来的。
这次拷贝花费了大约两分半钟，并且几乎占用了所有的CPU时间。之所以这么慢是因为它必须
完成超过两百万次的系统调用。
加入jaVa编程群：524621833
---
## Page 97
78
Linux程序设计
我们采用大一些的数据块进行拷贝会改善这一点：请看下面这个改进后的程序copy_block.c，
它每次拷贝长度为1K的数据块，用的还是系统调用：
#incluge 
include 
#include 
#inciude 
int na1r()
char b1ock[1024];
Int in. out:
inr nread;
1n = open(*file.in*. 0_RDONLY);
out = openI*ffle,out*. O_WRONt,Y|O_CREAT, S_IRUSR|S_JWUSRJ;
while ( (nread = read(in, block, sizeof (block))) > 01
writefout,block,nread) :
ext(0);
1
现在来运行这个程序，先删除旧的输出文件：
tine copy_block
S rm file.out
0.011user 1.09systern 0:01.90elapsed 57%CFU
-18 f1le.1nf11a.out
1029
------
1 nei1
1nei1
users
10485~6 Sep 17 10:57 fi1e.out
1048576 Sep 17 10:46 ti1e.in
users
改进后的程序只花费了不到两秒种的时间，因为它只需做大约2000次系统调用就是够了。
当然，这些时间与系统本身的性能有很大的关系，但它们确实已经让我们看出系统调用需要巨
大的开支，值得对它们的用法进行优化。
3.4.8其他与文件管理有关的系统调用
还有许多其他的系统调用能够对这些底层文件描述符进行操作。它们允许程序对文件的使
用方式和返回的状态信息进行控制。我们在这里简单介绍下，以便你可以使用它们。但读者不
一定一眼就喜欢上它们。
1.lseek系统调用