stored
‚Ä¢ First 2 symbols store 4 bits of CRC data
‚Ä¢ Next 2 symbols store 3 bits
‚Ä¢ Next 2: 2 ‚Äì only in odd bits
‚Ä¢ Next 2: 2 ‚Äì only in odd bits
‚Ä¢ Next 2: 1 ‚Äì only in odd bits
‚Ä¢ Only the first 4 symbols can cause a tail of 6 symbol changes
‚Ä¢ Odd bits only changes 1 symbol
‚Ä¢ CRC is stored in 10 symbols total, including the 6-symbol tail of changes from convolution!
‚Ä¢ Wicked smaht
‚Ä¢ Bits are shuffled around, for reasons
‚Ä¢ This is what thwarted CRC Reveng, and my brute force attempts
‚Ä¢ Later tried CRC Reveng with the bits rearranged, and it worked!
CRC Reverse Engineering, Continued
‚Ä¢ Now I can compute a CRC for the 16 data bytes, but I need the mask
‚Ä¢ Originally I guessed randomly at the mask and based all the math off that
‚Ä¢ I think this worked since CRC is built by XOR, with a non-zero base value for an empty 
packet, and I was effectively XORing that base again that with my mask symbols
‚Ä¢ 9 of the bits change one symbol by 4, so that works like XOR
‚Ä¢ 3 bits can cause a trail of 6 changed symbols, which made some packets with those CRC 
values unreliable?
‚Ä¢ I think the CRC doesn‚Äôt protect the Preamble 
‚Ä¢ Tried making packets with a ton of preamble variations, none worked
‚Ä¢ I assumed 16 0s in the data would have a CRC of 0 based the mask off that 
‚Ä¢ It worked! Reliably!
Crafted Packets at Last!
‚Ä¢ With the CRC and mask I can now craft my own 16-byte packet!!!
‚Ä¢ Will release my tools on github
‚Ä¢ But I need a 36 byte packet to overflow the badge‚Ä¶
‚Ä¢ I knew this from the start, hoped I would figure it along the way
‚Ä¢ No field for that in the packet
‚Ä¢ Preamble tinkering was a bust
‚Ä¢ Time to reverse engineer the NFMI firmware
Extracting the NFMI firmware 
‚Ä¢ To use SWD on the NFMI chip, first I had to find the reset line
‚Ä¢ Knew it was on a middle layer
‚Ä¢ Found out which ball it was from
‚Ä¢ Scoured slides to find the line to that ball, then Joe Grand sent me confirmation
Extracting the NFMI firmware 
‚Ä¢ Scratched a layer off the badge circuit board to 
expose a reset line on the middle layer 
‚Ä¢ Cut it and soldered on a wire
‚Ä¢ The trace is about the size of a hair
‚Ä¢ Used a stereo microscope at Artisan‚Äôs Asylum
‚Ä¢ Connecting SWD to an undocumented chip
‚Ä¢ Added pull-ups, pull downs, resoldered everything
‚Ä¢ Then tried settings for random chips until one worked
‚Ä¢ Extracted NFMI memory space 0-0x18000‚Ä¶ 
without the NFMI protocol code
Reversing the NFMI Firmware
‚Ä¢ I extracted the NFMI protocol code from a section of the badge‚Äôs 
firmware, assembled the pieces together and dropped it into Ida Pro
‚Ä¢ Nothing in there indicated a packet length field
‚Ä¢ Coded to drop packets with more than 11 bytes
‚Ä¢ (Later I removed that, but I still don‚Äôt know how to craft a longer packet, and faking the 
length resulted in uninitialized data)
‚Ä¢ But I had seen (and logged) oversize packets occurring spontaneously 
and crashing the badge, what was going on?
B df df df df df df df df df df df df df df df df dd dd dd dd dd dd E -- length = 22
0xFFFFFFFFFFFFFFFF
-> Unique ID: 0xFFFFFFFF
-> Badge Type: Unknown
-> Magic Token: Yes
-> Game Flags: 11111111
B df df df df df df 42 df df df df df df df df df df df df df df df df dd dd dd dd dd dd 42 df df df df df df df df df df df df df df df df dd dd dd dd dd dd E -- length = 52
Welcome to the DEFCON 27 Official Badge
Off By One Bug to the Rescue
‚Ä¢ NFMI sends packet to badge via UART,
‚Ä¢ Badge checks for 2 bytes of space before copying 1 byte at a time to the ring buffer 
‚Ä¢ One-by-one copying allows partial packets, off-by-one allows odd-sized packets
‚Ä¢ If I send the right pattern of packets, I can leave a buffer with 18 free bytes
‚Ä¢ NFMI chip sends ‚ÄòB‚Äô, 16 padded bytes and ‚ÄòE‚Äô to badge MCU via UART
‚Ä¢ Badge writes ‚ÄòB‚Äô and 16 bytes of padded data, sees only 1 byte free so it drops the ‚ÄòE‚Äô
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
B
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
B
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
B
E
Occupied Receive Ring Buffer End
free
Occupied Ring Buffer Start
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
B
Occupied Receive Buffer
freeeeeeeeeeeeeeeeeeeeeeeeeeeeee
free
‚Ä¢
The badge reads packets from the beginning of the ring buffer, freeing more space
‚Ä¢
Write a second packet before the badge empties ring buffer
‚Ä¢ The badge firmware finds the first ‚ÄòB‚Äô then copies the next 33 bytes before finding ‚ÄòE‚Äô
‚Ä¢ B16B16E ‚âà B33E
Off By One Bug, Continued
‚Ä¢ But wait, there‚Äôs more!
‚Ä¢ Keep hammering with the largest size packet, B22E (11 user bytes):
‚Ä¢ Fill the ring buffer so the last entry is:
‚Ä¢ B22
‚Ä¢ 24 bytes read from the front allows 24 added to the end: 
‚Ä¢ B22B22
‚Ä¢ Badge reads faster than we can transmit, so there is lots of space when the next packet 
arrives:
‚Ä¢ B22B22B22E
‚Ä¢ Badge reads that ‚ÄúB‚Äù, then copies 68 bytes to dataBlog buffer before finding the ‚ÄòE‚Äô
‚Ä¢ The dataBlog buffer is only 18-byte long‚Ä¶
‚Ä¢ Might be able to do even more
‚Ä¢ Fill the buffer with tiny packets to make reads take as long as possible
‚Ä¢ Then write larger packets that get truncated and keep the pain train going
Demo: Crash a Def CON 27 Badge via NFMI
‚Ä¢ Now we can crash a stock badge at will!
‚Ä¢ It just takes a while with a 2048-byte buffer
‚Ä¢ 2048 / (a maximum of 24 bytes x 8 bursts / 4.8 seconds) x 2 = a boring demo
‚Ä¢ So I cheated and set the buffer to 72 bytes
‚Ä¢ Process:
‚Ä¢ Initialize the buffer 
‚Ä¢ Might not know where nxhTxIndex and nxhRxIndex are pointing, so completely fill the buffer by blasting it for a 
while 
‚Ä¢
Ring buffer may have unread packets, indexes might be moved by ‚ÄúRO‚Äù or ‚ÄúRC‚Äù after reboot.
‚Ä¢ Stop transmitting
‚Ä¢ Have the badge read packets and completely drain the buffer (Often see B20 for a 72-byte buffer after a reboot)
‚Ä¢ Indexes are now equal
‚Ä¢ Attack the buffer
‚Ä¢ Send 1 packet of total length = LPUART0_RING_BUFFER_SIZE % 24
‚Ä¢
Length 8 or B6E for a 2048 byte buffer, nothing for a 72 byte buffer
‚Ä¢ Blast the buffer full, last entry is B22
‚Ä¢ Have the badge start reading, keep blasting, last entry will grow to B22B22B22E
‚Ä¢ Splat
Can We Do Something More Interesting?
‚Ä¢ dataBlob is 18 bytes but takes up 20 bytes of the stack, then there are 3 
registers on the stack for 12 more bytes, then the LR register
‚Ä¢ We need to overwrite 32 bytes of junk, then up to 4 bytes of the LR
‚Ä¢ LR can only contain 000024CB* when the ring buffer is full
‚Ä¢ 25D7 after 1 packet read failure, 20xx-23xx when updating game state in non-interactive mode
‚Ä¢ Little endian lets us recycle the top bytes
‚Ä¢ One problem: all data is padded with Dx
‚Ä¢ Send 36 bytes: LR = DxDxDxDx: Invalid
‚Ä¢ Send 35 bytes: LR = 00DxDxDx: Invalid
‚Ä¢ Send 34 bytes: LR = 0000DxDx: Data and a BXLR, not helpful
‚Ä¢ Send 33 bytes: LR = 000024Dx: 000024DD may return to waiting for a packet
‚Ä¢ Send 33 bytes: LR = 000025Dx: 000025DF might display ascii art
‚Ä¢ I can crash a stock badge but not run arbitrary code 
* +1 for thumb üëç
Fixing the NFMI Protocol
‚Ä¢ The only way around that was to cheat 
‚Ä¢ Modify the victim badge‚Äôs firmware to modify 
the NFMI firmware at boot up
‚Ä¢ Found code that padded output with 0xDn
‚Ä¢ Removed that padding code 
‚Ä¢ Removed the stupid ‚ÄòB‚Äô and ‚ÄòE‚Äô crap too
‚Ä¢ Original game still works
‚Ä¢ Use 10 user data bytes to send ‚ÄúB‚Äù, data, ‚ÄúE‚Äù
‚ÄúBefore‚Äù
‚ÄúAfter‚Äù
NFMI Proprietary Firmware Format
‚Ä¢ Lastly I had to figure out the bizarre NFMI firmware format
‚Ä¢ 3 sections, each consists of
‚Ä¢ Data Segment
‚Ä¢ CAFEBABE (what is this, Java?)
‚Ä¢ Length
‚Ä¢ Base address
‚Ä¢ CRC-32/POSIX of header
‚Ä¢ Data (Length x 2 bytes)
‚Ä¢ Padding 0xFFFF, if Length is odd
‚Ä¢ Checksum/mixed-up-CRC
‚Ä¢ Additional data segments (optional)
‚Ä¢ End
‚Ä¢ 0 (Length)
‚Ä¢ 0 (Base)
‚Ä¢ Checksum/mixed-up-CRC
‚Ä¢ Put that into the original firmware, time for some fun
10
‚Ä¢ Live Demos of over-the-air remote code execution of arbitrary code
‚Ä¢ Demos that exist so far:
‚Ä¢ I can write an arbitrary string to the debug console, currently ‚ÄúSeth was here!!‚Äù
‚Ä¢ I can write a string from the badge memory to the console, like ‚ÄúGoon‚Äù or ‚ÄúSpeaker‚Äù
‚Ä¢ Demos in progress
‚Ä¢ Play the RickRoll music
‚Ä¢ Play arbitrary sounds, perhaps SOS
‚Ä¢ Do something with the LEDs on the badge.
‚Ä¢ Trigger the ASCII art function in the badge
‚Ä¢ Demo of POC
‚Ä¢ Demo of oversized packet
‚Ä¢ Demo of CRC table?
Oddities
‚Ä¢ First packet data always contains the following in ASCII: ‚Äú0403E045‚Äù
‚Ä¢ 0x45E00304 stored in NXH memory at 17DFC and 17E20 but not referenced by code
‚Ä¢ Might be a output buffer address computed by the NFMI‚Ä¶?
‚Ä¢ Also got error packets with ‚Äú0D047039‚Äù
‚Ä¢ 0x3970040D = ???? 
‚Ä¢ NFMI firmware has the entries:
00C0: 2281A100, ‚Äúrev53481M‚Äù
43E2: 2281A100, ‚Äúrev53481MS‚Äù
‚Ä¢ 2281A100 ‚â° 0x00A18122 = 1058435410 ‚âü 10.584354Mhz? 
‚Ä¢ Or is it the rev values backwards? 1 05 8435 4 backwards?
Remaining Mysteries: Preambles
‚Ä¢ Preamble bytes 0-4 suggest signal could actually be a DD8PSK (DD9PSK?) because 
the differences between the first 20 symbols 4440 4040 2460 0000 6420 are:
‚Ä¢ ?000 4444 2222 0000 6666
‚Ä¢ Preamble bytes 5-7 ‚Äì what do they mean? 
‚Ä¢ Assuming the mask is 0040 0000 0000 (20 00 00), preamble values are:
‚Ä¢ 0040 0000 0000 = 00 00 00
‚Ä¢ 0042 3133 4224 = C0 FF 55
‚Ä¢ 0044 2774 6756 = 80 87 00  the one used in packets
‚Ä¢ Unknown if CRC protects any preamble bytes, or just the data
‚Ä¢ I made packet with the section 2 preambles and all possible CRCs, none worked
‚Ä¢ Tried a lot of versions of the last 3 preambles bytes, 
‚Ä¢ Occasionally one that was close to the original would work, sporadically
‚Ä¢ Probably because noise turned it back into the original preamble
Remaining Mysteries
‚Ä¢ Where does the mask come from?
‚Ä¢ Tried all the first 20 or so PRBS, nada
‚Ä¢ Tried changing endianness, reversing the bits, splitting odd and even bits
‚Ä¢ Haven‚Äôt tried double-diffing or un-diffing the bits
‚Ä¢ Must be an easy way to stream or send longer packets
‚Ä¢ Throughput right now is about 22 bytes per second‚Ä¶
‚Ä¢ What the heck is that convolution?