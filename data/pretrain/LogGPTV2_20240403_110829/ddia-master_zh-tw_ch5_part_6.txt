单主资料库按顺序进行写操作：如果同一个栏位有多个更新，则最后一个写操作将决定该栏位的最终值。
在多主配置中，没有明确的写入顺序，所以最终值应该是什么并不清楚。在 [图 5-7](../img/fig5-7.png) 中，在主库 1 中标题首先更新为 B 而后更新为 C；在主库 2 中，首先更新为 C，然后更新为 B。两种顺序都不比另一种“更正确”。
如果每个副本只是按照它看到写入的顺序写入，那么资料库最终将处于不一致的状态：最终值将是在主库 1 的 C 和主库 2 的 B。这是不可接受的，每个复制方案都必须确保资料最终在所有副本中都是相同的。因此，资料库必须以一种 **收敛（convergent）** 的方式解决冲突，这意味著所有副本必须在所有变更复制完成时收敛至一个相同的最终值。
实现冲突合并解决有多种途径：
* 给每个写入一个唯一的 ID（例如时间戳、长随机数、UUID 或者键和值的杂凑），挑选最高 ID 的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术被称为 **最后写入胜利（LWW, last write wins）**。虽然这种方法很流行，但是很容易造成资料丢失【35】。我们将在本章末尾的 [检测并发写入](#检测并发写入) 一节更详细地讨论 LWW。
* 为每个副本分配一个唯一的 ID，ID 编号更高的写入具有更高的优先顺序。这种方法也意味著资料丢失。
* 以某种方式将这些值合并在一起 - 例如，按字母顺序排序，然后连线它们（在 [图 5-7](../img/fig5-7.png) 中，合并的标题可能类似于 “B/C”）。
* 用一种可保留所有资讯的显式资料结构来记录冲突，并编写解决冲突的应用程式程式码（也许透过提示使用者的方式）。
#### 自定义冲突解决逻辑
解决冲突的最合适的方法可能取决于应用程式，大多数多主复制工具允许使用应用程式程式码编写冲突解决逻辑。该程式码可以在写入或读取时执行：
* 写时执行
  只要资料库系统检测到复制更改日志中存在冲突，就会呼叫冲突处理程式。例如，Bucardo 允许你为此编写一段 Perl 程式码。这个处理程式通常不能提示使用者 —— 它在后台程序中执行，并且必须快速执行。
* 读时执行
  当检测到冲突时，所有冲突写入被储存。下一次读取资料时，会将这些多个版本的资料返回给应用程式。应用程式可以提示使用者或自动解决冲突，并将结果写回资料库。例如 CouchDB 就以这种方式工作。
请注意，冲突解决通常适用于单行记录或单个文件的层面，而不是整个事务【36】。因此，如果你有一个事务会原子性地进行几次不同的写入（请参阅 [第七章](ch7.md)），对于冲突解决而言，每个写入仍需分开单独考虑。
> #### 自动冲突解决
>
> 冲突解决规则可能很容易变得越来越复杂，自定义程式码可能也很容易出错。亚马逊是一个经常被引用的例子，由于冲突解决处理程式而产生了令人意外的效果：一段时间以来，购物车上的冲突解决逻辑将保留新增到购物车的物品，但不包括从购物车中移除的物品。因此，顾客有时会看到物品重新出现在他们的购物车中，即使他们之前已经被移走【37】。
>
> 已经有一些有趣的研究来自动解决由于资料修改引起的冲突。有几项研究值得一提：
>
> * **无冲突复制资料型别（Conflict-free replicated datatypes，CRDT）**【32,38】是可以由多个使用者同时编辑的集合、对映、有序列表、计数器等一系列资料结构，它们以合理的方式自动解决冲突。一些 CRDT 已经在 Riak 2.0 中实现【39,40】。
> * **可合并的持久资料结构（Mergeable persistent data structures）**【41】显式跟踪历史记录，类似于 Git 版本控制系统，并使用三向合并功能（而 CRDT 使用双向合并）。
> * **操作转换（operational transformation）**[42] 是 Etherpad 【30】和 Google Docs 【31】等协同编辑应用背后的冲突解决演算法。它是专为有序列表的并发编辑而设计的，例如构成文字文件的字元列表。
>
> 这些演算法在资料库中的实现还很年轻，但很可能将来它们会被整合到更多的复制资料系统中。自动冲突解决方案可以使应用程式处理多主资料同步更为简单。
#### 什么是冲突？
有些冲突是显而易见的。在 [图 5-7](../img/fig5-7.png) 的例子中，两个写操作并发地修改了同一条记录中的同一个栏位，并将其设定为两个不同的值。毫无疑问这是一个冲突。
其他型别的冲突可能更为微妙而难以发现。例如，考虑一个会议室预订系统：它记录谁订了哪个时间段的哪个房间。应用程式需要确保每个房间在任意时刻都只能被一组人进行预定（即不得有相同房间的重叠预订）。在这种情况下，如果为同一个房间同时建立两个不同的预订，则可能会发生冲突。即使应用程式在允许使用者进行预订之前先检查会议室的可用性，如果两次预订是由两个不同的主库进行的，则仍然可能会有冲突。
虽然现在还没有一个现成的答案，但在接下来的章节中，我们将更好地了解这个问题。我们将在 [第七章](ch7.md) 中看到更多的冲突示例，在 [第十二章](ch12.md) 中我们将讨论用于检测和解决复制系统中冲突的可伸缩方法。
### 多主复制拓扑
**复制拓扑**（replication topology）用来描述写入操作从一个节点传播到另一个节点的通讯路径。如果你有两个主库，如 [图 5-7](../img/fig5-7.png) 所示，只有一个合理的拓扑结构：主库 1 必须把它所有的写入都发送到主库 2，反之亦然。当有两个以上的主库，多种不同的拓扑都是可能的。[图 5-8](../img/fig5-8.png) 举例说明了一些例子。
![](../img/fig5-8.png)
**图 5-8 三种可以在多主复制中使用的拓扑示例。**
最常见的拓扑是全部到全部（all-to-all，如 [图 5-8 (c)](../img/fig5-8.png)），其中每个主库都将其写入传送给其他所有的主库。然而，一些更受限的拓扑也会被使用到：例如，预设情况下 MySQL 仅支援 **环形拓扑（circular topology）**【34】，其中每个节点都从一个节点接收写入，并将这些写入（加上自己的写入）转发给另一个节点。另一种流行的拓扑结构具有星形的形状 [^v]：一个指定的根节点将写入转发给所有其他节点。星形拓扑可以推广到树。
[^v]: 不要与星型模式混淆（请参阅 “[星型和雪花型：分析的模式](ch3.md#星型和雪花型：分析的模式)”），其中描述了资料模型的结构，而不是节点之间的通讯拓扑。
在环形和星形拓扑中，写入可能需要在到达所有副本之前透过多个节点。因此，节点需要转发从其他节点收到的资料更改。为了防止无限复制回圈，每个节点被赋予一个唯一的识别符号，并且在复制日志中，每次写入都会使用其经过的所有节点的识别符号进行标记【43】。当一个节点收到用自己的识别符号标记的资料更改时，该资料更改将被忽略，因为节点知道它已经被处理过。
环形和星形拓扑的问题是，如果只有一个节点发生故障，则可能会中断其他节点之间的复制讯息流，导致它们无法通讯，除非节点被修复。拓扑结构可以重新配置为跳过发生故障的节点，但在大多数部署中，这种重新配置必须手动完成。更密集连线的拓扑结构（例如全部到全部）的容错性更好，因为它允许讯息沿著不同的路径传播，可以避免单点故障。
另一方面，全部到全部的拓扑也可能有问题。特别是，一些网路连结可能比其他网路连结更快（例如由于网路拥塞），结果是一些复制讯息可能 “超越” 其他复制讯息，如 [图 5-9](../img/fig5-9.png) 所示。
![](../img/fig5-9.png)
**图 5-9 使用多主复制时，写入可能会以错误的顺序到达某些副本。**
在 [图 5-9](../img/fig5-9.png) 中，客户端 A 向主库 1 的表中插入一行，客户端 B 在主库 3 上更新该行。然而，主库 2 可以以不同的顺序接收写入：它可能先接收到更新（从它的角度来看，是对资料库中不存在的行的更新），稍后才接收到相应的插入（其应该在更新之前）。
这是一个因果关系的问题，类似于我们在 “[一致字首读](#一致字首读)” 中看到的：更新取决于先前的插入，所以我们需要确保所有节点先处理插入，然后再处理更新。仅仅在每一次写入时新增一个时间戳是不够的，因为时钟不可能被充分地同步，所以主库 2 就无法正确地对这些事件进行排序（见 [第八章](ch8.md)）。