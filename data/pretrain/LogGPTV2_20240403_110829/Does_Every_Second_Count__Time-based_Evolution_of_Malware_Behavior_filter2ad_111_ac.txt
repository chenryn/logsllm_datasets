and droppers, our system detects samples that spawns new
processes based on ﬁles they previously wrote to the disk,
and in this case we restart our timer when a dropped ﬁle is
executed. In a real world scenario dropped ﬁles could be in
principle collected and analyzed separately, which is equivalent
to our solution of restarting the clock for dropped ﬁles. Overall,
our recording system is similar to the one used by Malrec [87]
but we adapted the solution to the new PANDA version 2 while
the current Malrec dataset is available for PANDA 1 only.
We then replayed the recorded execution while running
several plugins dedicated to collect the data required by our
analysis. The plugins collect all system calls that occur in the
context of the monitored processes, all BBs that are translated
and executed by the emulator, as well as a complete memory
dump whenever one of the monitored processes is about to
terminate. From the memory dumps we then extract the content
of the process’ memory and ﬁnally all of its executable basic
blocks.
System Calls Collection – One of our goals is to collect all
system calls invoked by the malware sample under analysis.
PANDA comes with the syscalls2 plugin [4] which pro-
vides callbacks triggered when a system call is called or when
it returns. Based on these callbacks, we implemented our own
plugin that hooks every system call that occurs during the
execution of the malware sample. The plugin logs all system
calls together with the timestamp of their occurrence, the PID
of the process in whose context the call occurs, as well as all
the syscall parameters. However, PANDA only allows us to
monitor the system calls from outside OS and does not make
any high-level information available. Therefore, each argument
or return value is represented by a generic uint32_t value.
While this is ﬁne for integer values, in practice, many argu-
ments to system calls are pointers to structures. Therefore, if
higher-level information is required for further analysis, we
need to parse the memory to retrieve additional information.
Unfortunately, large parts of the Windows OS internals are not
well documented.
We partially solved this problem by extracting information
from Volatility’s offset-tables for Windows 7 Service Pack
1 [39]1. We also used the description provided by Petritsch [76]
on how to retrieve network packets from system calls. Finally,
PANDA’s win7proc plugin [5] infers high-level information
from several system calls related to processes, registry, ﬁle
system, and shared memory. By combining the information
provided by all these sources, our system is able to lift data for
all system calls related to the interaction with the ﬁle system,
the registry, as well as for processes, memory management,
and network-related operations.
Basic Blocks – The PANDA_CB_AFTER_BLOCK_TRANSLATE
callback provides a way to instrument the BB translation,
an operation that the emulator performs right before the ﬁrst
execution of each BB. With this methodology, we collect all
BBs when they are executed for the ﬁrst time in the context
of a process we observe.
it
To estimate the code coverage achieved by a given execu-
tion, we also need to extract all executable BBs belonging to
the malware sample. Since, due to packing and obfuscation
is often impossible to retrieve the program
techniques,
code statically, we resort
to extracting the BBs from the
process’ memory image. It is reasonable to assume that the
maximal amount of code is present in memory right before
the process terminates. While this might not be the case for
packers of type VI (according to the classiﬁcation of Ugarte-
Pedrero et al. [96]), these are extreme, and very inefﬁcient,
forms of packing that are used in only 0.2% – 1.8% of
the samples. Moreover, it is important to note that we only
report the absolute coverage for completeness, while all our
measurements rely on relative metrics, which are not impacted
by packing as they only measure those basic blocks that are
actually executed by the program.
To dump the memory at the end of the process’ execution,
hooking the NtTerminateProcess call was insufﬁcient.
Instead, we found that for all possible ways a process has
to terminate, the ProcessDelete bit (the 3rd bit of Byte
0x270 of the EPROCESS structure) is set to 1 right before
the memory of the process is freed by the Windows kernel. In
contrast, all other bits and timestamps are set after the memory
space has already been freed. Hence, our system checks if this
1Volatility is a popular memory forensics framework and its operations rely
on OS internal details that are retrieved by manually reverse engineering the
target systems.
6
bit is set when the process context changes, thus dumping the
memory before it is freed by the operating system.
We then use the Rekall [6] memory forensics framework
to extract the memory image of the process and analyze the
virtual address descriptor tree of the process’ memory content.
By parsing its output, we can extract all regions which are
marked as executable but do not belong to any named module
(e.g., a shared library). Each one of these regions is then pro-
cessed by SMDA [7], an open source recursive disassembler
optimized for recovering code from memory dumps. SMDA
is based on Nucleus [14], which can detect more functions
in a binary than traditional disassemblers. We also extended
SMDA to better guide it through the code regions within the
address boundaries which have been executed in PANDA, thus
increasing the disassembler’s ability to explore the code.
Recovering Time Information – A problem we encountered
in our analysis is that, during replay, we needed a way
to retrieve the timing information according to the malware
recording. In other words, we wanted to know exactly when
a given system call or basic block was executed during the
sample recording and not during the, much slower, replay.
To
achieve
this
we
goal,
exploited
the
KUSER_SHARED_DATA structure and its SystemTime
ﬁeld at offset 0x14. This ﬁeld stores the current system time
(expressed as an offset since January 1st, 1601 00:00:00 in
100 nanosecond ticks) and its value in memory is regularly
updated. As PANDA records all memory-writes, any update
to SystemTime is also recorded. This allows us to recover
the exact timestamp when each event was performed during
the recording – thus removing the overhead of our system
from the results of our analysis.
Windows API Hooks – Several malware samples intention-
ally delay their malicious activity by sleeping for a certain
amount of time, thus bypassing traditional dynamic analysis
sandboxes. Therefore, we decided to hook the Sleep and
SleepEx functions in Kernel32.dll to detect such cases.
Whenever one of the two functions is called, we add the time
of the sleep to the system time but return immediately. This
allows us to bypass sandbox evasion tricks based on the system
time.
CreateProcessWithLogonW
Furthermore, we hook the functions CreateProcess-
and
InternalW,
and
CreateProcessWithTokenW to inject our dll
install the hooks also into child processes. In case a ﬁle is
dropped by the malware and later executed, we want to extend
the time of our analysis. We therefore collect all written ﬁles
by hooking NtCreateFile.
All events recorded through the API hooking are immedi-
ately transmitted to our analysis framework while the malware
is still running. We collect the time the malware sample sleeps
and the child processes spawned by the sample. We decided
to implement a simple client/server mechanism to share this
information. The client is included in the injected DLL and
sends messages containing the timestamp, the PID, and the
event information to the server running outside PANDA, which
logs the information for the subsequent analysis.
7
TABLE II: Top 10 families in the dataset
Family name Total
4162
sytro
3936
stihat
blackmoon
3911
3574
agen
2821
dinwood
2806
sillyp2p
2682
high
upatre
2613
2505
mira
ulise
2473
V. RESULTS
According to AVClass [86], our dataset contains 806 differ-
ent malware families and 6, 989 samples classiﬁed as singleton
(i.e., for which it was not possible to recognize a common
label). Even though some families are present with higher
frequency than others (Table II reports a ranking of the top
10 families present in the dataset), no family was predominant
and even the largest accounted for only 4K samples – thus
resulting in a well balanced dataset.
Our experiments were conducted in a sandbox running
the 32-bit version of Windows 7 Service Pack 1. We further
conﬁgured the sandbox to have an internet connection and
simulate basic user interaction to enable a realistic execution
of the samples.
According to what we discussed in Section II, each sample
was executed for up to 15 minutes. Then, the execution was
replayed, this time by using our PANDA plugins to collect the
required information. In average, the complete analysis of one
sample took around one hour, resulting in over 4100 days of
CPU time – which in our case were distributed over 80 parallel
virtual machines.
Overall, in our experiments we performed 5.9M minutes
of malware execution, over which we collected 205M system
calls and 84M unique basic blocks.
A. Filtering
As expected, some samples implement
tricks to detect
the presence of the analysis environment or that they were
executed inside an emulator. While currently, the actual amount
of samples that adopt anti-analysis techniques is not known,
one of the last experiments to measure its adoption was
performed by Symantec in 2014. The authors found that anti-
VM techniques were in decline, with only 18% of the samples
that refused to run in a virtual environment [103]. In addition,
some programs also failed to run because of lack of parameters
or missing dependencies.
From one point of view, since our goal is to put ourselves
in the position of a security company that needs to analyze
unknown samples collected by their infrastructure, one may
see these samples that failed to properly executed as “part of
the game”. Since these executables cannot be easily removed
without ﬁrst executing them, the tuning of the sandbox needs
TABLE III: Summary of the dataset
Malicious
Benign
Discard
8,402
1,456
2m & <15m
55,669
10,385
10,658
798
15m
11,290
1,375
Tot
86,019
14,014
to take them into account. On the other hand, we wanted
to avoid polluting our ﬁndings with these cases, since their
actual number may vary depending on the sophistication of
the sandbox and on how realistic the analysis environment is.
Clearly, to obtain a more accurate picture about the malware
analysis, we need to discuss only the running samples, without
including broken binaries, programs that exit because of wrong
parameters or missing dependencies, or malware that detected
the presence of our analysis environment. Therefore, we de-
cided to conservatively ﬁlter out samples that did not show a
sufﬁcient amount of activity during their execution. This has an
important implication for our results, as when we conclude that
a certain percentage of malware shows a certain distribution
in its runtime behavior, we always mean “a percentage of the
malware that successfully executes”. This needs to be kept in
mind when interpreting the results of our analysis.
From a practical standpoint, we applied two conservative
thresholds to the collected data: the ﬁrst over the number of
invoked syscalls, and the second over the number of executed
basic blocks. More speciﬁcally, for the syscalls we deﬁned a
set of functions which capture signs of meaningful activity
(e.g., disk operation or network-related activity) and we then
required that at least 50 of these functions were invoked.
With regards to the basic blocks, we adopted 4, 000 basic
blocks as a minimum threshold for a successful execution.
While these values are somehow arbitrary, our sole goal here
is to be conservative enough to remove samples that did not
execute correctly. In our dataset, these thresholds discarded
8, 402 (10.5%) of the malicious samples and 1, 456 (10.9%) of
the benign ones. Among the remaining samples, the minimum
execution time before a malicious sample terminated was 28
seconds—which is certainly sufﬁcient for a program to show
some of its runtime behavior.
B. Execution Time
The ﬁrst interesting result we observed in our experiments
is that most malware samples terminate their execution before
reaching the sandbox threshold. This is very important because
it means that even if a sandbox is conﬁgured to execute
malware for ten minutes, 81% of the samples that successfully
executed will not reach this threshold, and over half of them
will terminate within the ﬁrst minute. The full cumulative
distribution of the execution time is reported in Figure 2 for
both the benign and the malicious ﬁles. It is interesting to
note that the two curves are remarkably similar, and that both
show that either a program terminates in the ﬁrst three minutes,
or it continues to run for more than thirteen. A complete
breakdown of the entire dataset, divided according to the
samples termination time, is presented in Table III.
This result could be explained by the fact that either a
program performs some actions (e.g., it downloads a second-
Fig. 2: Malware execution times
Fig. 3: Absolute Code Coverage vs Termination Time
stage binary, or it manipulates some data) and then terminates,
or it remains active potentially indeﬁnitely (as in the case
of a botnet or an application that requires user interaction).
By looking closely at the samples that terminated in the ﬁrst
minute, we fetched the system calls related to network opera-
tions (e.g. NtDeviceIOControlFile/DeviceControl)
and we analyzed their input parameters to understand if the
samples were opening a new connection, downloading data, or
sending data. We noted that respectively 51% of the malicious
and 67% of the benign samples exhibited signs of network
activity, thus suggesting that the samples did not simply detect
the presence of the VM. Moreover, the top families reported in
Table II were more prevalent among these short-lived samples