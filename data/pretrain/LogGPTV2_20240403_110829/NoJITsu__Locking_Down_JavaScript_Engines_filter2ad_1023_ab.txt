JIT code cache indicates the instructions generated by the JIT
compiler, including normal JIT code and inline cache stubs.
The JIT compiler data region includes JIT compiler-speciﬁc
intermediate representations of the bytecode (i.e., the MIR and
LIR code in SpiderMonkey’s case) and other data structures
that are used exclusively by the JIT compiler. The JavaScript
objects are all kinds of objects that are backed by a garbage
collector, and are used by both components. Several of these
memory regions have been targeted by control-ﬂow hijacking
attacks in the past. Previously presented exploit mitigations
typically protect either the JIT code cache or the JIT compiler
data, but leave the other regions exposed. In practice, this
was shown to be exploitable via crafted inputs that trigger
type confusion in the engine’s arena allocator [53]. Next, we
will demonstrate that an adversary can construct successful
exploits by attacking the interpreter, bypassing these proposed
mitigations.
C. Our Interpreter Attack Against SpiderMonkey
We present a new attack that leverages the fact that most
of the script engine’s key memory regions remain writable
throughout the execution of the script. A memory-corruption
bug in any of the engine’s components therefore allows us to
manipulate any of the interpreter’s data structures. We also
exploit the extensive use of indirection in the bytecode. Aside
from program variables, JavaScript objects also encapsulate
function information. When one function calls another, the
caller loads the callee’s address from the callee’s function
to point
Fig. 2: Our attack proceeds in three steps: 1 the attacker
locates the JavaScript context object and the function object
for a victim function. 2 the attacker then corrupts the function
object
to an attacker-chosen target function and
injects a command string in the context object. 3 ﬁnally,
the attacker calls the victim function from JavaScript, causing
the interpreter to invoke the target function with the injected
argument string.
object. We show that we can execute arbitrary shell commands
by locating and corrupting these function data objects at run
time.
We successfully tested our exploit against a recent version
of SpiderMonkey 60.0.0. Our attack proceeds in three key
phases, which are illustrated in Figure 2. First, the attacker lo-
cates the JavaScript context object and the JavaScript function
object of a victim function (i.e., any function we can call from
JavaScript). After leaking the locations of these two objects,
the attacker overwrites the function address contained in the
function object with the address of a target function. We used
the C library’s system function as the target function for
our attack. The attacker also overwrites the contents of the
context object to hold a string representation of the path to the
desired program to be executed (e.g., “/bin/sh”). Finally, the
attacker invokes the victim function. The interpreter then loads
the modiﬁed objects onto the stack and launches the program
speciﬁed in the argument string encoded by the corrupted
context object.
1) Implementation Details: We implemented the ﬁrst step
of the attack by exploiting a type confusion bug (CVE-2019-
11707) present in SpiderMonkey versions 60.8.0 and below.
This bug can be weaponized into a full-ﬂedged arbitrary read-
/write primitive, as was shown in related work [12]. Weaponiz-
ing the bug takes four steps. First, the JavaScript program allo-
cates a number of small and consecutive ArrayBuffers on
the heap. We gave all of the ArrayBuffers a size of 32 bytes
in our exploit. Then,
the program creates Uint32Array
and Uint8Array view objects for one of the allocated
ArrayBuffers. Next,
the program triggers a type con-
Fig. 3: Disclosing the locations of the victim JSFunction object
and the JSContext object.
fusion between the two view objects. After triggering the
type confusion, SpiderMonkey allows the program to read-
/write 32 Uint32 elements in the ArrayBuffer. Since the
ArrayBuffer’s size is only 32 bytes,
the program can
now overwrite the metadata stored in one of the adjacent
ArrayBuffers. Finally,
the program overwrites the data
pointer, which is part of the adjacent ArrayBuffer’s meta-
data, with a pointer to a memory location chosen by the at-
tacker. All subsequent accesses to the adjacent ArrayBuffer
now target this attacker-chosen location.
After weaponizing the bug, we leak the locations of
the JSContext and victim JSFunction objects as il-
lustrated in Figure 3. We start by reading the contents
of the NativeObject struct which is embedded in the
ArrayBuffer we just corrupted. From the NativeObject
struct, we follow a pointer chain to the global JSContext
object. Next, we write a reference to the victim JavaScript
function into the NativeObject struct. We then use the
memory vulnerability to read the raw value of this reference,
thus revealing the location of the victim’s JSFunction
object.
We locate the target function itself by reading the cur-
rent value of the native function pointer within the victim
JSFunction object and by recursively disassembling the
native function until we arrive at a call to a PLT entry, which
we disassemble to ﬁnd the start of the PLT. We then ﬁnd the
PLT entry of the target function using a priori knowledge of
the layout of the PLT.
2) Discussion: As a remote attacker, launching an inter-
active shell session from within SpiderMonkey might not be
advantageous. However, the attacker could also inject and pass
a script to the terminal, e.g., by encoding it as a cookie ﬁle,
which would then require passing the relative path to the
cookie ﬁle on to the shell. In our tests, we were able to
corrupt up to 32 bytes of the context object without causing the
interpreter to crash, which leaves plenty of room for storing
useful payloads in memory.
4
BytecodeStackarg&system&Func obj&Arg objObj TableValue: &systemFunc objValue: argArg objsystem(“cmd”)“cmd”cx objLoad functionLoad argumentCall functionInterpreter ①②③Data affected by an attackerNativeObjectgroupslotsObjectGroupcompartment_JSCompartmentruntime_JSRuntimeactiveContext_JSContextJSFunctionnative_Crucially, our new attack cannot be prevented by previously
proposed defenses tailored towards protecting the JIT compiler
data [27], [42] since we attack the interpreter which always
executes before any JIT compilation is invoked.
III. NOJITSU: PROTECTING JIT ENGINES
Motivated by the fact that state-of-the-art JIT defenses fail
to stop attacks that target interpreted bytecode, we designed a
novel defense that provides ﬁne-grained memory protection to
lock down real-world scripting engines. As switching between
interpreted and JIT’ed code happens frequently (i.e., on a per-
function basis) an efﬁcient implementation of this mechanism
is key to overall run-time performance. Hence, we cannot
simply move the interpreter out-of-process as previously pro-
posed for the JIT compiler [42]. Instead, our design leverages
automated dynamic and static analysis to restrict memory-
access permissions within the scripting engine to the bare
minimum. This way, NOJITSU protects against a wide range
of possible attacks, including code-injection, code-reuse, and
data-only attacks. NOJITSU is designed to be compatible
with and usable alongside existing defenses such as constant
blinding [13], constant elimination and code obfuscation [19],
code randomization [32], or control-ﬂow integrity [46].
A. Overview
Our main goal is to enforce ﬁne-grained security policies
for different kinds of data structures in JavaScript. While
limited policies may already be in place for code sections,
current JIT engines do not distinguish between different kinds
of data sections and have naive or no explicit security policies
for them within the application’s address space. In Figure 4,
the JavaScript engine stores the bytecode, object tables, and
JavaScript objects in writable memory regions for their entire
lifetime, even though the engine rarely overwrites these data
structures. This enables an adversary to manipulate the data
structures and change the behavior of the JIT engine at run
time, which can ultimately grant the adversary arbitrary code
execution capabilities. Just-in-time code on the other hand
is usually protected by mapping code regions as readable
and executable, re-mapping it as writable temporarily when
generating new JIT code. Unfortunately, this does not defend
against more sophisticated attacks such as just-in-time code-
reuse attacks that chain gadgets injected into the JIT code.
Our defense neutralizes these threats by deploying ﬁne-
grained security policies to lock down access permissions for
each of the main data regions we identiﬁed based on their
lifetime and usage within the JIT engine. Concretely, we force
the JIT engine to store bytecode, object tables, and JavaScript
objects in read-only memory, and to only grant write access
when, where, and as long as it is needed. We do this by placing
unrelated data structures into different memory domains, and
by activating the write permission of a speciﬁc domain only
when the subsequent code may write to the structures in
that domain, revoking the permission shortly afterward. We
additionally mark JIT code regions as execute-only, meaning
that attacks that involve reading code (such as JIT-ROP) are
no longer possible.
Figure 5 illustrates how our defense works conceptually.
First, we ensure that every data structure is allocated with
the correct memory permissions. We do this by assigning
each type of data structure to a unique memory domain,
and to associate every newly allocated data structure with
the key corresponding to its data type. We also separate
data structures upon allocation so that no memory page ever
contains structures from multiple domains. Second, we infer
the permissions each function in the engine needs based on
the types of data it may access. For example, our design
enforces read-only permission for all JavaScript objects to
avoid adversarial data corruption, but there are times when
the legal program ﬂow requires writing to a data object.
In such a case, we temporarily grant write permissions so
intended program behavior remains intact. To identify the
locations that require such a temporary permission relaxation,
we dynamically analyze possible accesses to each object.
Finally, we insert instrumentation code that sets the appropriate
domain permissions at the locations identiﬁed by our dynamic
analysis.
Fig. 4: Legacy design
Fig. 5: NOJITSU
Figure 6 shows the overall design of our JavaScript engine
protection, NOJITSU, which separates core data structures
of the engine into different protection domains. There are
several challenges we needed to overcome to implement our
design. First, restricting memory access entails the recurring
modiﬁcation of access permissions on data structures, which
can be costly. To solve this problem, we utilize a hardware-
based mechanism that allows us to change access permissions
5
MemoryBytecode Object tableObjectJIT IR(R/W)JIT codeJIT data(R/X)Thread BThread AWriteWritemprotect(W)mprotect(R/X)WriteWriteMemory   Bytecode (R)   Object tables (R)   Sensitive   Object (R)   JIT data (R)   JIT code (X)Key1Key2Key4Key6   JIT IR (R)Key5Key7Thread BThread Aset_pkey(W,key2)set_pkey(R,key2)WriteWriteset_pkey(W,key6)set_pkey(X,key6)WriteWrite   Primitive    Object (R)Key3read-only region such that the JIT code cache is only composed
of executable machine instructions. We carefully design this
data separation to minimize the potential performance impact
(see Section IV-B1). After separating JIT data from JIT code,
we make the code execute-only and the data read-only. This
protects the engine against JIT spraying attacks (which rely on
injecting constants into the JIT code) [13] and JIT-ROP attacks
(which rely on reading code) [56].
Our defense provides clear added value to other counter-
measures against these attacks. Constant blinding, for example,
also defends against JIT spraying attacks, but existing imple-
mentations do not blind small constant values (of less than
three bytes) for performance reasons [40]. JIT spraying attacks
using one- and two-byte constants are, however, feasible in
practice [7]. Similarly, there are several existing implementa-
tions of execute-only memory, but they only apply to statically
generated code [8], [9], [15], [21], [23], [29], [43]. This leaves
these implementations vulnerable to JIT-ROP attacks that only
use gadgets found in the JIT code cache.
2) Static Code: The static code regions include the code
sections of the JavaScript engine itself and the dynamic
libraries that the engine loads into the memory. Unlike the JIT
code region, the attacker cannot inject malicious code into this
static code region by running a malicious script. However, the
static code region consists of a large code base which nearly
always contains an abundance of code-reuse gadgets. Similar
to the JIT code region, we make static code regions execute-
only so the attacker cannot disclose executable memory regions
to chain code-reuse gadgets. We leverage eXecutable-Only
Memory Switch (XOM-Switch) [43] to enforce execute-only
permissions for the static code regions.
3) JIT IR: JIT IR is an intermediate representation used
during compilation of bytecode into JIT code. While this
IR code has a short lifetime, researchers have demonstrated
attacks that exploit race conditions to corrupt the IR code from
another thread [27], [58]. Our defense protects the JIT IR code
by granting write permission only to the thread that compiles
the IR code into machine code. The attacker, therefore, cannot
manipulate JIT IR using another thread unless that thread is
also compiling IR code when the exploit takes place.
4) Bytecode and Object Tables: Similar to the JIT code
cache, the bytecode and object tables should be writable only
when they are generated during compilation. After their gener-
ation, the bytecode and object tables are only read throughout
the remainder of the execution. Thus, we allow write access
to these data structures only when the script parser generates
them and immediately make them non-writable afterwards.
5) JavaScript Objects: Unlike bytecode and object tables,
which must be written only once, data objects can be written
to frequently at any point of the program execution. For
example, a data object that contains a program variable may
be overwritten at any time during the program execution.
Moreover, every JavaScript object contains several kinds of
ﬂags that must be frequently updated, e.g., a reference counter
for the garbage collector. Consequently, identifying all such
locations that require permission changes for data objects is
challenging. We therefore propose a dynamic analysis tech-
nique that automatically identiﬁes permitted write operations
for each data object (see Section IV-C2).
Fig. 6: Design of our script engine protection NOJITSU. Core
data structures in the JIT engine —bytecode, object tables,
objects, JIT IR, JIT code, and JIT data— are separated into
different protection domains. We make the JIT code regions
execute-only and the other data regions read-only. We grant the
write access to the protected regions only when a legitimate
program ﬂow requires write permission. For instance, we
temporarily grant write permission to the JIT code region when
the compiler emits newly generated JIT code.
for individual memory domains without modifying page table
entries or ﬂushing the TLB. Hence, in contrast to traditional
MMU-based protection mechanisms [8], [9], [23], [29], we can
change access permissions without incurring substantial run-
time overhead. Second, existing implementations of execute-
only memory (XoM) do not apply to JIT code. Extending
support to JIT code is not trivial, as the JIT engine might
emit JIT code containing data (such as object tables) that must
remain readable at all times. Our defense separates this data
from the JIT code so that we can safely revoke read access to
all JIT code regions. To the best of our knowledge, we are the
ﬁrst to implement execute-only support for JIT code.
1) JIT Code: The JIT code cache contains dynamically
generated instructions that natively execute on the CPU. To
defend against code injection attacks, it is important to keep
this JIT code cache non-writable except when the instructions
are generated. The JIT code cache also needs to be non-
readable to avoid JIT-ROP attacks which require reading
code regions to discover code-reuse gadgets at run time. In
the original design of the JavaScript engine, however,
the
JIT code cache must be readable because it also contains
readable data such as constant values, which are too wide
to be embedded into instructions as immediate operands, and
target addresses read by a jump table. To make the JIT code
region execute-only, we ﬁrst separate these readable data from
the JIT code region. We move all readable data including
constant values and the jump table targets into a dedicated,
6
InterpreterDispatcherLoad /StoreArithmeticFunction callBytecode (     key1)Instruction fetchObj table(    key2)StackValueLoad / StoreFetch valuesFetch &func, argsPush return valueJIT code (     key6)JIT data (     key7)JIT CompilerBytecode compilerEmit JIT codeJIT IR (     key5)Push resultEmit JIT IREmit BytecodeLoad / StoreCore data in JIT engineRead/ WriteAssigned keyPrimitive Obj(    key3)Sensitive Obj(    key4)We separate JavaScript objects into two protection domains
depending on the types they encapsulate: one for sensitive data
objects and the other for primitive data objects. We consider
an object sensitive if it contains sensitive information such as
function pointers, object shape metadata, scope metadata, or
JIT code. Corrupting a sensitive object allows the attacker to
seize control over the JIT engine immediately. For example,
primitive data objects may contain integers, characters, or
arrays. Corrupting a primitive data object typically does not
sufﬁce to seize control over the engine, but it may be useful to
subsequently corrupt a sensitive object. By separating sensitive
objects from primitive objects, we can ensure those object
classes are not writable at the same time. Thus, the attacker
cannot
type confusion vulnerability to
corrupt sensitive objects using a write operation for primitive
data types. Moreover, we can further narrow down the writable
time windows for each object type.
leverage an object
Note that the objects can also be written during the JIT
code execution. Changing object permissions during the JIT
code execution, however, may introduce substantial run-time
overheads as the JIT code is generated for frequently executed
code, and hence, highly optimized. Therefore, we lift all access