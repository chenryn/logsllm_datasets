Figure 1. Exploration of multiple execution
paths.
For an example on how multiple execution paths of a
program can be explored, consider Figure 1. Note that al-
though this example is shown in C code (to make it eas-
ier to follow), our system works directly on x86 binaries.
When the program is executed, it ﬁrst receives some input
and stores it into variable x (on Line 1). Note that because
x is considered interesting, it is labeled. Assume that in this
concrete run, the value stored into x is 2. On Line 2, it is
compared to 0. At this point, our system detects a compari-
son operation that involves labeled data. Thus, a snapshot of
the current process is created. Then, the process is allowed
to continue. Because the condition is satisﬁed, the if-branch
is taken and we record the fact that x has to be larger than
0. On Line 3, the next check fails. However, because the
comparison again involves labeled data, another snapshot
is created. This time, the process continues on the else-
branch and is about to call exit. Because there are still
unexplored paths (i.e., there exist two states that have not
been visited), the process is reverted to the previous (sec-
ond) state. Our system inspects the comparison at Line 3
and attempts to rewrite x such that the check succeeds. For
this, the additional constraint x > 0 has to be observed.
This yields a solution for x that equals 1. The value of x
is updated to 1 and the process is restarted. This time, the
print statement on Line 4 is invoked. When the process is
about to exit on Line 5, it is reset to the ﬁrst snapshot. This
time, the system searches a value for x that fails the check
on Line 2. Because there are no additional constraints for
x, an arbitrary, non-positive integer is selected and the pro-
cess continues along the else-branch. This time, the call to
exit is permitted, and the analysis process terminates with
a report that indicates that a call to print was found under
the condition that the input x was 1 (but not 0 or 2).
Consistent memory updates. Unfortunately, when
rewriting a certain input value to explore an alternative exe-
cution path, it is typically not sufﬁcient to change the single
memory location that is used by the control ﬂow decision.
Instead, it is necessary to consistently update (or rewrite)
all values in the process address space that are related to
the input. The reason is that the original input value might
have been copied to other memory locations, and even
used by the program as part of some previous calculations.
When only a single instance of the input is modiﬁed, it
is possible that copies of the original value remain in the
program’s data section. This can lead to the execution of
invalid operations or the exploration of impossible paths.
Thus, whenever an input value is rewritten, it is necessary
to keep the program state consistent and appropriately
update all copies of the input, as well as results of previous
operations that involve this value. Also, we might not have
complete freedom when choosing an alternative value for
a certain input. For example, an input might have been
used in previous comparison operations and the resulting
constraints need to be observed when selecting a value that
can revert the control ﬂow decision at a branching point. It
is even possible that no valid alternative value exists that
can lead to the exploration of the alternative path. Thus,
to be able to consistently update and input and its related
values,
it is necessary to keep track of which memory
locations depend on a certain input and how they depend
on this value.
3 Path Exploration
To be able to explore multiple program paths, two main
components are required. First, we need a mechanism to de-
cide when our system should analyze both program paths.
To this end, we track how the program uses data from cer-
tain input sources. Second, when an interesting branching
point is located, we require a mechanism to save the cur-
rent program state and reload it later to explore the alterna-
tive path. The following two subsections discuss these two
components in more detail.
3.1 Tracking Input
In traditional taint-based systems, it is sufﬁcient to know
that a certain memory location depends on one or more in-
put values. To obtain this information, such systems typ-
ically rely on three components: a set of taint sources, a
shadow memory, and extensions to the machine instructions
that propagate the taint information.
Taint sources are used to initially assign labels to certain
memory locations of interest. For example, Vigilante [11]
is a taint-based system that can detect computer worms that
propagate over the network. In this system, the network is
considered a taint source. As a result, each new input byte
that is read from the network card by the operating system
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007receives a new label. The shadow memory is required to
keep track of which labels are assigned to which memory
locations at a certain point in time. Usually, a shadow byte
is used for each byte of physical machine memory. This
shadow byte stores the label(s) currently attached to the
physical memory location. Finally, extensions to the ma-
chine instructions are required to propagate taint informa-
tion when an operation manipulates or moves labeled data.
The most common propagation policy ensures that the re-
sult of an operation receives the union of the labels of the
operation’s arguments. For example, consider an add ma-
chine instruction that adds the constant value 10 to a mem-
ory location M1 and stores the result at location M2. In this
case, the system would use the shadow memory to look up
the label attached to M1 and attach this label to M2. Thus,
after the operation, both locations M1 and M2 share the
same label (although their content is different).
In principle, we rely on a taint-based system as previ-
ously described to track how the program under analysis
processes input values. That is, we have a number of taint
sources that assign labels to input that is read by the pro-
gram, and we use a shadow memory to keep track of the
current label assigned to each memory location (including
the processor registers). Taint sources in our system are
mostly system calls that return information that we con-
sider relevant for the behavior of malicious code. This in-
cludes system calls that access the ﬁle system (e.g., check
for existence of ﬁle, read ﬁle content), the Windows registry,
and the network. Also, system calls that return the current
time or the status of the network connection are interesting.
Whenever a relevant function (or system call) is invoked by
our program, our system automatically assigns a new label
to each memory location that receives this function’s result.
Sometimes, this means that a single integer is labeled. In
other cases, for example, when the program reads from a
ﬁle or the network, the complete return buffer is labeled,
using one unique label per byte.
Inverse mapping.
In addition to the shadow memory,
which maps memory locations to labels, we also require
an inverse mapping. The inverse mapping stores, for each
label, the addresses of all memory locations that currently
hold this label. This information is needed when a process
is reset to a previously stored state and a certain input vari-
able must be rewritten. The reason is that when a memory
location with a certain label is modiﬁed, it is necessary to si-
multaneously change all other locations that have the same
label. Otherwise, the state of the process becomes incon-
sistent. For example, consider the case in which the value
of labeled input x is copied several times before it is even-
tually stored at memory location y. Furthermore, assume
that y is used as argument by a conditional branch. To ex-
plore the alternate execution branch, the content of y must
be changed. However, via a chain of intermediate locations,
this value ultimately depends on x. Thus, all intermediate
locations need to be modiﬁed appropriately. To this end,
a mapping is required that helps us to quickly identify all
locations that currently share the same label.
  0:    ...
  1:    x = read_input();
  2:    check(x);
  3:    printf("%d", x);
  4:    ....
  5:
  6:    void check(int magic) {
  7:        if (magic != 0x1508)
  8:            exit(1);
  9:    }   
Figure 2. Consistent memory updates.
To underline the importance of a consistent memory up-
date, consider the example in Figure 2. Assume that the
function read input on Line 1 is a taint source. Thus,
when the program executes this function, variable x is la-
beled. In our example, the program initially reads the value
0. When the check routine is invoked, the value of vari-
able x is copied into the parameter magic. As part of this as-
signment, the variable magic receives the label of x. When
magic is later used in the check on Line 7, a snapshot of the
current state is taken (because the outcome of a conditional
branch depends on a labeled value). Execution continues
but quickly terminates on Line 8. At this point, the pro-
cess is reverted to the previously stored snapshot and our
system determines that the value of magic has to be rewrit-
ten to 0x1508 to take the if-branch. At this point, the new
value has to be propagated to all other locations that share
the same label (in our case, the variable x). Otherwise, the
program would incorrectly print the value of 0 instead of
0x1508 on Line 3.
Linear dependencies.
In the previous discussion, the ini-
tial input value was copied to new memory locations before
being used as an argument in a control ﬂow decision. In that
case, rewriting this argument implied that all locations that
share the same label had to be updated with the same value.
So far, however, we have not considered the case when the
initial input is not simply copied, but used as operand in
calculations. Using the straightforward taint propagation
mechanism outlined above, the result of an operation with
a labeled argument receives this argument’s label. This also
happens when the result of an operation has a different value
than the argument. Unfortunately, that leads to problems
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007when rewriting a variable at a snapshot point. In particu-
lar, when different memory locations share the same label
but hold different values, one cannot simply overwrite these
memory locations with a single, new value.
We solve this problem by assigning a new label to the re-
sult of any operation (different than copying) that involves
labeled arguments. In addition, we have to record how the
value with the new label depends on the value(s) with the
old label(s). This is achieved by creating a new constraint
that captures the relationship between the old and new la-
bels, depending on the semantics of the operation. The
constraint is then added to a constraint system that is main-
tained as part of the execution state of the process. Consider
the simple example where a value with label l0 is used by
an add operation that increases this value by the constant
10. In this case, the result of the operation receives a new
label l1. In addition, we record the fact that the result of
the operation with l1 is equal to the value labeled by l0 plus
10. That is, the constraint l1 = l0 + 10 is inserted into the
constraint system. The approach works similarly when two
labeled inputs, one with label l 0 and the other with label l1
are summed up. In this case, the result receives a new label
l 2 and we add the constraint l2 = l0 + l1.
In our current system, we can only model linear rela-
tionships between input variables. That is, our constraint
system is a linear constraint system that can store terms in
the form of {cn ∗ ln + cn−1 ∗ ln−1 + . . . + c1 ∗ l1 + c0}
where the ci are constants. These terms can be connected by
equality or inequality operators. To track linear dependen-
cies between labels, the taint propagation mechanism of the
machine instructions responsible for addition, subtraction,
and multiplication had to be extended.
Using the information provided by the linear constraint
system, it is possible to correctly update all memory loca-
tions that depend on an input value x via linear relation-
ships. Consider the case where a conditional control ﬂow
decision uses a value with label ln. To explore the alterna-
tive branch of this decision, we have to rewrite the labeled
value such that the outcome of the condition is reverted. To
do this consistently, we ﬁrst use the linear constraint system
to identify all labels that are related to ln. This provides us
with the information which memory locations have some
connection with ln, and thus, must be updated as well. In a
second step, a linear constraint solver is used to determine
concrete values for these memory locations.
Two labels ls and lt are related either (a) when they ap-
pear together in the same constraint or (b) when there ex-
ists a sequence of labels {li0 , . . . , lin} such that ls = li0,
lt = lin, and li, li+1 ∀n−1
i=0 appear in the same constraint.
More formally, the binary relation related is the transitive
closure of the binary relation appears in the same con-
straint. Thus, when a value with label ln should be rewrit-
ten, we ﬁrst determine all labels that are related to ln in
the constraint system. Then, we extract all constraints that
contain at least one of the labels related to ln. This set of
constraints is then solved, using a linear constraint solver
(we use the Parma Polyhedral Library).
When the constraint system has no solution, the labeled
value cannot be changed such that the outcome of the con-
dition is reverted. In this case, our system cannot explore
the alternative path, and it continues with the next snapshot
stored. When a solution is found, on the other hand, this
solution can be directly used to consistently update the pro-
cess’ state. To this end, we can directly use, for each label,
the value that the solver has determined to update the corre-
sponding memory locations. This works because all (linear)
dependencies between values are encoded by the respective
constraints in the constraint system. That is, a solution of
the constraint system respects the relationships that have
to hold between memory locations. All memory locations
that share the same label receive the same value. However,
as expected, when memory locations have different labels,
they can also receive different values. These values respect
the relationships introduced by the operation previously ex-
ecuted by the process and captured by the corresponding
constraints in the constraint system.
To illustrate the concept of linear dependencies between
values and to show how their dependencies are captured
by the constraint system, consider Figure 3. The example
shows the labels and constraints that are introduced when a
simple atoi function is executed. The goal of this function
is to convert a string into the integer value that this string
represents. For this example, we assume that the function is
executed on a string str with three characters; the ﬁrst two
are the ASCII character equivalent of the number 0 (which
is 30). The third one has the value 0 and terminates the
string. We assume that interesting input was read into the
string; as a result, the ﬁrst character str[0] has label l0 and
str[1] has label l1.
The ﬁgure shows the initial mapping between program
variables and labels. For this initial state, no constraints
have been identiﬁed yet. After the ﬁrst loop iteration, it can
be seen that the variables c and sum are also labeled. This
results from the operations on Line 7 and Line 8, respec-
tively. The relationship between the variables are captured
by the two constraints. Because sum was 0 before this loop
iteration, variables sum and c hold the same value. This is
expressed by the constraint l 3 = l2. Note that this exam-
ple is slightly simpliﬁed. The reason is that the checks per-
formed by the while-statement on Line 5 lead to the creation
of additional constraints that ensure that the values of str[0]
and str[1] are between 30 (ASCII value for ’0’) and 39
(ASCII value for character ’9’). Also, because the checks
operate on labeled data, the system creates snapshots for
each check and attempts to explore additional paths later.
For these alternative paths, the string elements are rewrit-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007Mapping:
Constraints:
Mapping:
Constraints:
l2 = l0 - 30
l3 = l2
str[0]  l0
str[1]  l1
c       l2
sum     l3
State after first loop iteration
 0:   char str[], *p;