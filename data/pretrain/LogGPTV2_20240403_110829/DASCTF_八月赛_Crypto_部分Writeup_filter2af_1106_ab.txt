n`以及`t2 = 0 mod n`，我们对其稍加变化得到`t1 = k1*n`,`t2 =
k2*n`，此时我们对`t1,t2`求解最大公因数，可以得到`n`
或者`k*n`，对于`k*n`我们只需要分解它即可得到`n`。那么我们需要利用连续的`6`个`s[i]`构造出至少两个模`n`同余`0`的整数，然后对其求最大公因数，便可以得到`n`进而得到`a,b,c`
不妨设六个输出分别为`x1,x2,x3,x4,x5,x6`，由于`x[i] = a*x[i-2]+b*x[i-1] +c mod n`，其中 `b =
a+1`,于是有
`x[i] = a*x[i-2] + a*x[i-1] + x[i-1] +c mod n`即`x[i] - x[i-1] = a*x[i-2] +
a*x[i-1] + c mod n`
令`yi`分别为
    y1 = x3-x2 = a(x1+x2)+c
    y2 = x4-x3 = a(x2+x3)+c
    y3 = x5-x4 = a(x3+x4)+c
    y4 = x6-x5 = a(x4+x5)+c
令`zi`分别为
    z1 = y2 - y1 = a(x3-x1)
    z2 = y3 - y2 = a(x4-x2)
    z3 = y4 - y3 = a(x5-x3)
令`ti`分别为
    t1 = z1*(x4-x2) = a(x3-x1)(x4-x2)
    t2 = z2*(x3-x1) = a(x3-x1)(x4-x2)
    t3 = z2*(x5-x3) = a(x5-x3)(x4-x2)
    t4 = z3*(x4-x2) = a(x5-x3)(x4-x2)
求`gcd(t1-t2,t3-t4)`可以的`kn`，幸运的是题目中的数据求出的`k`恰好为`1`。恢复得到`n`后，可以利用`z1`的等式求`a`,同样的可以求得`c`（需要注意的是不能直接用`z1
* inverse(x3-x1) mod n`求`a`，必须将`z1`转换成`(x4+x2-2*x3)`然后求解）
**计算s[target]**
由于`target`过大，我们无法通过递推式直接求解，笔者这里使用了coin师傅的做法，即使用矩阵快速幂快速求解`s[target]`
根据递推关系式有 `s[i] = a*s[i-2]+b*s[i-1]+c mod n` 我们将其转化成矩阵的形式,可以得到
由于是递推的形式，于是有
也就是说，我们只需要将系数矩阵进行`k`次运算便可以得到最终结果的系数矩阵，然后与原始矩阵相乘便可以得到`s[target]`
最终的exp如下：
    from Crypto.Util.number import *
    x1 = 123702839015756050884261730350882737708358949223717439499184803586403380580917033774031115610745320766887583414238651786366942713037837183155670218651008201659397071753885966029204756119524199815830117337679903000409946531282131341544499373725768763177481236458288527526859422459135345981831473247316555618560
    x2 = 53924539754438007029501782029367518619266978487508630921932520518338714507664032847344261722536853774745396939590212348751300654791168048424611586167435934594214127893014772880318410947388412139484910911558913354881832668949036424760411326983813389804113790149675585445672972740198653398937213550096612898644
    x3 = 63167700157587157707659591399396856546372104423703909698033441469110658576803656359757694321232303912965997844863919208184964899691086676221424510238937996039639020372184420079106454203010811220417415790732729673830907444478937628707872186593129029778616120328244635824580198884662150104071084993653737914022
    x4 = 60900060027375388502954968533962551010895369320035053843073456747137873661715722305461794383581233299465108460448730880547665937249092184288347189085393775979063774890144837289588709330708116910722986763529852613180587935929862087569945164722421961012524239918061319269183814829620043095252880283996001514164
    x5 = 67113877662673866233083488077860646719333535770452193680770137339822227232411855308016162556072517267428842392157280102333021460946927124183519015361915428846609475511896652480835848461061078559069446935766782858959584622772958271986367572980550469374057939856055426306880686615182779562168848708759248213327
    x6 = 35321475740169398933875140842714262960904281331750205573172983410230385562745162356815900214941351338686778803036306575637404857858578337229023073873912358708980334069653782813016210177757649710822363593438233897497585809695658043901986740902609804765459645039370188002526182350951413827277418881541889614752
    cipher = 6257754829567986763892047832635830335816090670173191750751645793632788077917375687942054101544041498378086719313412925093077211368386033569497742486801694329756989184534154729709541023134576678323307630303652989589994288555559228966732861033813909078153507299492167442982631897158564781706799632969673086582
    from gmpy2 import *
    y1 = x3-x2
    y2 = x4-x3
    y3 = x5-x4
    y4 = x6-x5
    z1 = y2 - y1
    z2 = y3 - y2
    z3 = y4 - y3
    A = z1*(x2-x4)
    B = z2*(x1-x3)
    C = z2*(x3-x5)
    D = z3*(x2-x4)
    n = gcd(A-B,C-D)
    assert is_prime(n)
    a = (x4+x2-2*x3)*inverse(x3-x1,n)%n
    b = a + 1
    c = (x3-a*x1-b*x2)%n
    assert x4 == (a*x2+b*x3+c)%n
    assert x5 == (a*x3+b*x4+c)%n
    assert x6 == (a*x4+b*x5+c)%n
    target = 2**1024
    def recover(a,c,n,now,pre,limit=301):
        b = a+1
        while limit:
            now,pre = pre,((now-c-b*pre)*inverse(a,n))%n
            limit -= 1
        return int(pre),int(now)
    a0,a1 = recover(a,c,n,x2,x1)
    # 矩阵乘法
    def mul(A,B,n):
        C = [[0,0,0],[0,0,0],[0,0,0]]
        for i in range(3):
            for j in range(3):
                for k in range(3):
                    C[i][j] = (C[i][j]+A[i][k]*B[k][j])%n
        return C
    # 矩阵快速幂
    def matrix_pow(A,k):
        I = [
            [1,0,0],
            [0,1,0],
            [0,0,1]
        ]
        while k>0:
            if k&1:
                I = mul(I,A,n)
            A = mul(A,A,n)
            k //=2
        return I
    # 原始矩阵，这里笔者将初始的s[0],s[1] 恢复了出来
    origin = [
        [a1,a0,1],
        [0,0,0],
        [0,0,0]
    ]
    # 系数矩阵
    coff = [
        [b,1,0],
        [a,0,0],
        [c,0,1]
    ] 
    # 目标的系数矩阵 可以通过矩阵快速求解
    COFF = matrix_pow(coff,target-1)
    # 最终的结果
    RES = mul(origin,COFF,n)
    stream = int(RES[0][0])%n
    flag = cipher^stream
    print(long_to_bytes(flag))
## Game114514
这道题是源自`nsucrypto 2020`上的一道改编题，有兴趣的读者可以自行google。题面如下：
    from Crypto.Util.number import *
    from secret import flag
    def genKey():
        p, q, r = getStrongPrime(512), getStrongPrime(512), getStrongPrime(512)
        n = p * q * r
        N = getRandomNBitInteger(2048) + 114514
        h = pow(11, 2020, N) * (p**2) + pow(45, 2020, N) * (q**2) + pow(14, 2020, N) * (r**2)