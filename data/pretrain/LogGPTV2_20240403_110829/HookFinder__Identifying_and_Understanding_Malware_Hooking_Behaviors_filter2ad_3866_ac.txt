code region generated from the malicious code. If the
conditions are satisﬁed, we identify a hook: the jump
target is the hook entry F , the memory location that EIP
is loaded from is L, and the content in L is H.
The above policy functions properly for identifying
data hooks, but is problematic for code hooks. This is
because a code hook is a piece of code generated by the
malicious code, and thus is treated as malicious code by
the above policy. Therefore when the code hook redi-
rects the execution to the malicious code, the above pol-
icy will not raise an alarm because it sees the execu-
tion being transferred from malicious code to malicious
code. To solve this problem, we extend the above pol-
icy such that the execution transitions from a code hook
region into malicious code will raise an alert.
Then the question is how to distinguish code hook
regions with other self-generated code regions. Self-
generated code usually remains in the module space of
the malicious code, or stays in a region that is not occu-
pied by any module (such as in heap), whereas a code
hook region is a piece of code that overwrites a code re-
gion in a different module. Therefore, during execution,
if the currently executed basic block is marked and from
a different module, and EIP is marked and jumps into
the malicious code, we identify it as a code hook.
3.5 Hook Analyzer
Once a suspicious hook is identiﬁed, the hook ana-
lyzer is able to extract essential information about its
hooking mechanism by performing semantics-aware de-
pendency analysis on the impact trace. The procedure
consists of the following three steps: (1) from the hook
H, perform backward dependency analysis on the im-
pact trace, and generate hardware-level hook graph; (2)
with the OS-level semantics information, transform the
hardware-level hook graph into an OS-level hook graph;
and (3) if necessary, simplify the hook graph by hiding
unnecessary details and merging similar nodes. We de-
tail these steps respectively.
Hardware-level Hook Graph A hook graph repre-
sents dependencies among malware’s instructions that
are used to implant a hook. A node of a hook graph cor-
responds to an instruction involving hooking behavior;
an edge of a hook graph points from an instruction set-
ting an operand to an instruction using the operand as
source.
Recall that each record in the impact trace has de-
pendency information. With the hook H identiﬁed by
our hook detector, we create the ﬁrst node in our hook
graph, representing the instruction that activates H. We
then obtain the hook’s dependency ID IDh, and locate
the record that deﬁnes IDh in the impact trace. Finally,
we search backwards in the impact trace to add depen-
f8ab1ee6: mov 0xf8ab20a0, %edi
f8ab1f59: mov 0xf8ab20b4, %ecx
M[0xf8ab20a0]=0x804dd6e3
M[0xf8ab20b4]=0x80559b80
aries.sys+ee6: mov ZwOpenKey, %edi
aries.sys+f59: mov KeServiceDescriptorTable, %ecx
[aries.sys+10a0]=0x804dd6e3
M[aries.sys+10b4]=0x80559b80
f8ab1f56: mov 0x1(%edi), %eax
f8ab1f5f: mov (%ecx), %ecx
aries.sys+f56: mov 0x1(%edi), %eax
aries.sys+f5f: mov (%ecx), %ecx
Impacted Address
Impacted Address
f8ab1f61: movl $0xf8ab166e, (%ecx,%eax,4)
M[0x804e2efc]=0xf8ab166e
aries.sys+f61: movl aries.sys+66e, (%ecx,%eax,4)
M[ntoskrnl.exe+e2efc]=0xf8ab166e
804df051: mov (%edi,%eax,4), %ebx
ntoskrnl.exe+8051: mov (%edi,%eax,4), %ebx
804df069: call *%ebx
ntoskrnl.exe+8069: call *%ebx
(a) Hardware-level hook graph
(b) OS-level hook graph
Figure 3. Hardware(cid:173)level and OS(cid:173)level hook graphs for a hook in Sony Rootkit.
dency information. Speciﬁcally, for each record R in the
impact trace, if it creates a new dependency ID id that is
used in the hook graph, we added a node N representing
the instruction corresponding R, and add edges from N
to other nodes that uses id as source operands in their
corresponding instructions. We perform this backward
search recursively until we reach the beginning of the
trace. Besides the dependency information, each record
contains detailed information about an instruction, such
as its address and the values of its operands. If the in-
struction is executed under the context of an external
function, the record also contains the entry address of
that external function, and the value of ESP on the entry
of call. We also put these details into the corresponding
nodes. The resultant graph is the hardware-level hook
graph.
Figure 3(a) shows a hardware-level hook graph built
from a hook in Sony Rootkit [27], which employs the
same hooking mechanism as the sample shown in Fig-
ure 1. A rectangle node denotes an instruction propagat-
ing malware’s impacts. A diamond node denotes that its
successor’s destination address is affected by the mal-
ware’s impacts. Note that to save space, we only dis-
play really important information for each node, such
as the instruction address and the disassembled instruc-
tion. For each memory operand, we show its address and
value. If the instruction is executed under the context of
an external function call, we also show the entry of the
function call and the ESP value on the entry.
OS-level Hook Graph With the OS-level semantics
information provided by the semantics extractor, we
can transform a hardware-level hook graph into an OS-
level hook graph. Given the address of an instruc-
tion, we can show which module it belongs to and
its offset to the module base. Similarly for memory
access, we can determine if it falls into any module
space.
If the memory access is to a symbol, we can
even resolve its symbol name. Given the entry ad-
dress of an external function, we can resolve its function
name. Then, the resulting graph is an OS-level hook
graph. Figure 3(b) illustrates the OS-level hook graph
transformed from Figure 3(a). We can see that Fig-
ure 3(b) correctly reﬂects the hook registration proce-
dure shown in Figure 1. That is, symbols ZwOpenKey
and KeServiceDescriptorTable are used to cal-
culate the hook site L (shown in the diamond-shaped
node), and an address (aries.sys+66e) is written into L.
This is the hook H, the address of the hook entry F .
In addition to resolving function names, HookFinder
also extracts function arguments from an impact trace.
Since pushing arguments onto the stack is also part of
the impacts made by a malware sample, the information
about these arguments is already recorded in the impact
trace. To extract a function’s arguments, HookFinder lo-
cates the ﬁrst record R of the activation of the function.
The records preceding R contain function arguments,
but may also contain other non-argument impacts made
by the malware. As the impacts trace has information
about the value of register ESP at the beginning of the
function’s activation, we only include the impacts within
a certain distance to the value of ESP. In the current im-
plementation, we search for up to 10 four-byte words
following the location of ESP as arguments.
Graph Simpliﬁcation The resulting hook graph can
be very complex in some cases. For better readability
and clarity, we simplify it using the following criteria:
(1) if two adjacent nodes belong to the same external
function call, we merge them into a single virtual node;
(2) if two adjacent nodes are direct-copy instructions,
such as mov, push, and pop, we merge them into a sin-
gle node, because these instructions propagate the same
value without modiﬁcation. We apply these two crite-
ria repeatedly on our hook graph until no nodes can be
merged. The result is often a graph much clearer to be
interpreted.
4 Evaluation
In this section, we present details on the experimental
results of HookFinder, by evaluating it with real-world
malware samples. We ﬁrst give a summary of the ex-
perimental results over these samples, and then present
details on two of them. In all our experiments, we run
HookFinder on a Linux machine with a dual-core 3.2
GHz Pentium CPU and 2GB RAM. On top of Hook-
Finder, we install Windows XP Professional SP2 with
512M of allocated RAM as the guest operating system.
4.1 Overview
Our sample set consists of eight malware samples,
which are obtained from public resources (such as [20,
23]) and collaborative researchers. In Table 1, we char-
acterize these samples according to whether they are
packed, whether they are kernel or user threats, and
which categories they belong to. We include Uay back-
door to verify the capability of HookFinder in identify-
ing novel hooks 1.
In the experiment, HookFinder has successfully iden-
tiﬁed hooks for all the samples. We summarize the re-
sults in Table 2. In the second column of Table 2, we list
the elapsed time for each sample. It breaks down into
two parts: the runtime for running the sample in the em-
ulated environment (shown as the ﬁrst number), and the
runtime for generating hook graphs (as the second num-
ber). After executing a sample, we wait for 2-3 minutes
to make sure it has fully started. In order to trigger po-
tential hook behavior, we then perform a series of simple
1Since deepdoor is not released by its author, we cannot include it
in our experiment.
interactions with the emulated system, including listing
a directory, and pinging a remote host, which may cost
another 2 or 3 minutes. The runtime for generating hook
graphs varies from 2 seconds to 33 minutes, depending
on the trace size, the number of hooks, and other factors.
In total, HookFinder spends up to 39 minutes on a sam-
ple during the evaluation, which is efﬁcient compared to
manual malware analysis that can last hours or days.
The third column lists the size of the impact trace for
each sample. As we can see, the maximum size in the
table is 14G, which is acceptable for a complex program
executing millions of instructions.
The fourth and ﬁfth column shows the number of sus-
picious hooks and the total number of identiﬁed hooks,
for each sample. We found some normal hooks regis-
tered by the following functions: EVENT SINK AddRef,
FltDoCompleteProcessingWhenSafe, StartServiceDis-
patcherA, CreateThread, CreateRemoteThread, and
PsCreateSystemThread. Note that our approach does not
distinguish the intent of a hooking behavior. Thus, we
will identify all hooks in the ﬁrst place; then we check
normal hooks by comparing them with our white-list.
The last column gives essential information about
the hooking mechanism. We found that three sam-
ples installed code hooks. All three samples derive
the hook sites by calling GetProcAddress. Vanquish
directly writes the hooks into the hook sites, whereas
AFXRootkit and Hacker Defender call WriteProcess-
Memory and NtWriteVirtualMemory respectively to
achieve it. The other six samples installed data hooks,
four of which call external functions to install
the
hooks.
In particular, CFSD calls FltRegisterFilter,
and Trojan/Keylogg-LF and Troj/Thief call SetWindow-
sHookEx. We also extracted arguments for these func-
tion calls, and we found that Trojan/Keylogg-LF in-
stalled a WH KEYBOARD LL hook, and Trojan/Thief
installed a WH CALLWINDPROC hook. The remain-
ing two samples directly write hooks into hook sites.
The static points are KeServiceDescriptorTable and
NdisRegisterProtocol for Sony Rootkit and Uay Back-
door, respectively.
4.2 Detailed Analysis
Here we present detailed results for two malware
samples: Uay Backdoor and Vanquish.
Uay backdoor HookFinder identiﬁed ﬁve data hooks
in total for this sample. We reviewed the generated hook
graphs, and we found that three of them were installed
by PsCreateSystemThread. This kernel function creates
Sample
Size
Packed?
Kernel/User
Category
Troj/Keylogg-LF
Troj/Thief
AFXRootkit [1]
CFSD [6]
Sony Rootkit [27]
Vanquish [31]
64KB
334KB
24KB
28KB
5.6KB
110KB
Hacker Defender [12]
96KB
Uay Backdoor [30]
212KB
Y
N
Y
N
N
N
N
N
User
User
User
Kernel
Kernel
User
Both
Keylogger
Password Thief
Rootkit
Rootkit
Rootkit
Rootkit
Rootkit
Kernel
Backdoor
Table 1. Malware Samples in Our Experiment
Sample
Runtime
Trace
Hooks
Hooking Mechanism
Total Mal
Troj/Keylogg-LF
6m+9m
3.7G
Troj/Thief
4m+3s
143M
AFXRootkit
6m+33m