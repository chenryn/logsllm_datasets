the previous key as the basis for a new session; this is called session resumption. We can treat the
abbreviated handshake as a separate symmetric-key protocol (modeled in Section 8) with an independent,
modular security analysis (in Section 9), then use our compositional approach to show that the resumption
master secrets output by the full handshake can be safely composed with the abbreviated handshake.
Comments on the design of TLS 1.3. Our results allow us to give insight on some of the design choices
of TLS 1.3, such as the role of the Finished messages and of the new session hash. Those comments follow
in Section 3, immediately after we review the structure of the TLS 1.3 handshakes in the next section.
1.4 Related Work
A signiﬁcant step forward to a comprehensive analysis of TLS 1.2 handshake protocol and its implemen-
tation came with the recent work of Bhargavan et al. [BFK+14], who analyze the TLS 1.2 handshake
protocol in the agile setting, covering the various ciphersuite options in TLS 1.2, and applying the results
to a miTLS implementation [FKS11, BFK+13]. Using epochs and shared states between executions they
also capture resumption and renegotiation in TLS 1.2. We are not aware of extensions of their result to
the TLS 1.3 candidates.
A key point in the cryptographic analysis of Bhargavan et al. [BFK+14] is to overcome the issue that
the session key is already used in the ﬁnal part of the handshake protocol in TLS 1.2, by separating
these steps from the rest of the handshake. They achieve this by using a diﬀerent notion than session
identiﬁers to safely determine partners, called (peer-)exchange variables. While the designers for TLS 1.3
have eliminated the Finished-message problem, avoiding the usage of the session key in the handshake
entirely, the approach of switching to alternative notions of safe partnering turns out to be useful for
our setting, too. We introduce the notion of contributive identiﬁers which can be roughly thought of as
“partial” session identiﬁers. A similar concept was introduced by Cremers and Feltz [CF12] under the term
“origin-sessions” for partnering based on matching conversations. In contrast to [BFK+14] our contributive
4A technical nuisance in this regard is that, for the key independence property to hold, we cannot use the common approach
to deﬁne session partnering via the (here partly encrypted) communication transcript, but need to base session partnering on
the unencrypted key exchange data. This exacerbates for example the application of the hybrid method to go from multiple
tested session keys to a single test queries.
5
identiﬁers resemble much closer the common session identiﬁers (which we also keep in our model to deﬁne
session partners), and we only use contributive identiﬁers for non–mutually authenticated sessions and our
compositional result.
A main diﬀerence to the epoch-based analysis in [BFK+14] is that we use a general composition result
to deal with resumption. That is, we view the resumption step in TLS 1.3 as a special symmetric-
key protocol which follows the handshake. The approach in [BFK+14] is to consider resumption as an
abbreviated handshake protocol variant, executed in a diﬀerent epoch. Finally, let us remark that the
analysis in [BFK+14] extends to the implementation level, whereas our results are purely on the abstract
level.
Concurrently to our work, Kohlweiss et al. [KMO+14] transferred their constructive-cryptography
based analysis of TLS 1.2 to (a modiﬁed version of) the draft-05 version of TLS 1.3, where they assume
that the second-stage messages are actually sent unencrypted. They do not consider the draft-dh draft,
nor do they cover the resumption step. However, our approach of integrating resumption via composition
may also be viable for their model.
1.5 Limitations
Since TLS 1.3 is still a work in progress, our analysis is inevitably limited to the draft speciﬁcations
available at the time of writing, and the actual TLS 1.3 may eventually diﬀer from the draft versions we
have analyzed. Nonetheless, this paper’s analysis can provide insight into the design of the existing drafts.
We believe it is imperative for the cryptographic community to be engaged in the design and analysis of
TLS 1.3 before, rather than after, it is standardized.
One of the aspired design goals of TLS 1.3 is to support the possibility for zero round-trip time (0-RTT)
for the handshake protocol, which would enable transmission of application from the client to the server
on the ﬁrst message ﬂow, saving latency. This unfortunately comes with inherent problems, namely, lack
of forward secrecy and the possibility of replay attacks. draft-05 provides no speciﬁcation for 0-RTT
handshakes; draft-dh introduces an extra “semi-static” public key for this purpose, however at the time of
writing draft-dh does not provide suﬃcient protocol detail to allow a full cryptographic analysis of this.
We do not model leakage of the draft-dh semi-static key at this point as it plays no role (for secrecy) in
our security analysis, but defer carefully crafting reasonable conditions for its exposure until the 0-RTT
handshake is speciﬁed completely.
As noted above, our compositional approach allows for the separate analysis of the full handshake, the
record layer, and the session resumption handshake, and then composition shows that the various keys
output from the handshake can be safely used with the record layer encryption and session resumption.
This suggests the following approach to prove the full TLS protocol suite to be secure: show that session
resumption itself constitutes a secure key exchange protocol (with a pre-shared symmetric key which comes
from the handshake protocol here), compose it securely with the record layer protocol, and then “cascade”
this composed symmetric-key protocol with the compositional handshake protocol. Unfortunately, one
limitation of the current composition frameworks is that composition is only supported between a key
exchange protocol with forward secrecy and an arbitrary symmetric key protocol. This holds here for the
main handshake protocol and allows us to immediately argue secure composition with session resumption
or with the record layer. However, session resumption does not provide forward secrecy (with respect to
corruption of the resumption (pre-)master secrets), so we cannot automatically conclude safe use of the
session keys output by session resumption in the record layer. Extending the composition framework to
support multi-stage key exchange protocols without forward secrecy is left for future work.
6
Client
ClientHello: rc ←$ {0, 1}256
ClientKeyShare: X ← gx
Server
PMS ← Y x
H1 ← H(CHk . . .kSKS)
HMS ← PRF(PMS, label1kH1)
tkhs ← PRF(HMS, label2krskrc)
ServerHello: rs ←$ {0, 1}256
ServerKeyShare: Y ← gy
PMS ← X y
stage 1
{EncryptedExtensions∗}
{ServerCertificate∗}: pkS
{CertificateRequest∗}
{ServerCertificateVerify∗}:
SCV ← Sign(skS, H2)
{ServerFinished}:
SF ← PRF(HMS, label3kH3)
H2 ← H(CHk . . .kCR∗)
H3 ← H(CHk . . .kSCV∗)
Verify(pkS, H2, SCV)
check SF = PRF(HMS, label3kH3)
{ClientCertificate∗}: pkC
{ClientCertificateVerify∗}:
CCV ← Sign(skC, H4)
{ClientFinished}:
CF ← PRF(HMS, label4kH5)
H5 ← H(CHk . . .kCCV∗)
H4 ← H(CHk . . .kCCRT∗)
Verify(pkC, H4, CCV)
check CF = PRF(HMS, label4kH5)
stage 2
stage 3
record layer (application data), using AEAD with key tkapp
MS ← PRF(HMS, label5kH5)
tkapp ← PRF(MS, label2krskrc)
RMS ← PRF(HMS, label6kH5)
PMS
H1
PRF
HMS
H5
PRF
H5
PRF
MS
RMS
rskrc
PRF
rskrc
PRF
tkhs
tkapp
(
r
e
s
u
m
p
t
i
o
n
)
Figure 1: The handshake protocol in TLS 1.3 draft-05 (left) and its key schedule (right). XXX: Y denotes TLS message
XXX containing Y . {XXX} indicates a message XXX encrypted using AEAD encryption with handshake traﬃc key tkhs. XXX∗
indicates a message that is only sent in unilateral or mutual authentication modes. In the key schedule, dotted-line input to
PRF is the input value (omitting the label as additional input).
2 The TLS 1.3 Handshake Protocol
For both draft-05 and draft-dh, the handshake protocol is divided into two phases: the negotiation phase,
where parties negotiate ciphersuites and key-exchange parameters, generate unauthenticated shared key
material, and establish handshake traﬃc keys; and the authentication phase, where parties authenticate
the handshake transcript according to the authentication properties negotiated earlier and output authen-
ticated application traﬃc keys, independent from the previous handshake traﬃc keys.
2.1 draft-05 Handshake
Figure 1 shows the message ﬂow and relevant cryptographic computations as well as the key schedule for
the full handshake in draft-05.
The handshake messages are as follows:
• ClientHello (CH)/ServerHello (SH) contain the supported versions and ciphersuites for negotiation
purposes, as well as random nonces rc resp. rs. SH can contain a session identiﬁer session_id ﬁeld
for future session resumption. Both CH and SH can also include various extension ﬁelds.
• ClientKeyShare (CKS)/ServerKeyShare (SKS) contain the ephemeral Diﬃe–Hellman shares X = gx
7
resp. Y = gy for one or more groups selected by an extension in CH/SH.
Both parties can now compute the premaster secret PMS as the Diﬃe–Hellman shared secretgxy and then
use a pseudorandom function PRF to compute a handshake master secret HMS and handshake traﬃc key
tkhs; both are unauthenticated at this point.
respective party.
All subsequent messages are encrypted using tkhs:
• EncryptedExtensions (EE) contains more extensions.
• ServerCertificate (SCRT)/ClientCertificate (CCRT) contain the public-key certiﬁcate of the
• CertificateRequest (CR) indicates the server requests that the client authenticates using a certiﬁ-
• ServerCertificateVerify (SCV)/ClientCertificateVerify (CCV) contain a digital signature over
the session hash (the hash of all handshakes messages sent and received at that point in the protocol
run).
• ClientFinished (CF)/ServerFinished (SF) contain the PRF evaluation on the session hash keyed
cate.
with HMS.
Both parties can now compute the master secret MS and the application traﬃc key tkapp as well as the
resumption master secret RMS for use in future session resumptions.
2.2 draft-dh Handshake
Figure 2 shows the message ﬂow and cryptographic computations as well as the key schedule for the full
handshake in draft-dh. The main diﬀerence to draft-05 is the ServerParameters message (replacing SCV)
containing the server’s additional semi-static Diﬃe–Hellman share, allowing the application traﬃc keys
to rely on both ephemeral and non-ephemeral secrets. Moreover, key derivation is done using the HKDF
extract-then-expand key derivation function [Kra10], rather than the TLS PRF.
We adopt here the standard notation for the two HKDF functions: HKDF.Extract(XT S, SKM) on
input an (non-secret and potentially ﬁxed) extractor salt XT S and some source key material SKM outputs
a pseudorandom key P RK. HKDF.Expand(P RK, CT Xinf o) on input a pseudorandom key P RK (from
the Extract step) and some (potentially empty) context information CT Xinf o outputs key material KM.5
2.3 Session Resumption
Session resumption in draft-05 has similarly been changed from TLS 1.2 to separate handshake and
application traﬃc keys. As shown in Figure 3, ClientHello includes a preshared-secret identiﬁer (referred
to in the drafts as the “session identiﬁer session_id”) of some previously established session. The client
and server use that previous session’s resumption master secret, which has previously been authenticated,
so they do not exchange key shares or signatures, and fresh nonces rc, rs to derive the new keys.
secret and key computation as well as CF and SF computation (again, H = H(CHkSH)):
The diﬀerences between draft-05 session resumption and draft-dh session resumption are limited to
1. AMS ← HKDF.Extract(0, RMS)
2. tkhs ← HKDF.Expand(AMS, label1kH)
3. FS ← HKDF.Expand(AMS, label2krskrc)
4. SF ← HKDF.Expand(FS, label3kH)
5. CF ← HKDF.Expand(FS, label4kH)
6. MS ← HKDF.Extract(0, AMS)
7. tkapp ← HKDF.Expand(MS, label5kH)
5For simplicity, we omit the original third parameter L in Expand determining its output length and always assume that
L = λ for our security parameter λ.
8
Client
ClientHello
ClientKeyShare
Server
ES ← Y x
SS ← Sx
HMS ← HKDF.Extract(0, ES)
tkhs ← HKDF.Expand(HMS, label1kH1)
ServerHello
ServerKeyShare
ES ← X y
stage 1
{EncryptedExtensions∗}
{ServerCertificate∗}
{CertificateRequest∗}
{ServerParameters∗}:
SP ← S = gs, Sign(skS, gskH2)
SS ← X s