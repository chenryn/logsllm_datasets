title:Authenticity by tagging and typing
author:Michele Bugliesi and
Riccardo Focardi and
Matteo Maffei
Authenticity by Tagging and Typing ∗
Michele Bugliesi Riccardo Focardi Matteo Maffei
Università Ca’Foscari di Venezia
Dipartimento di Informatica
Via Torino 155, 30172 Mestre (VE), Italy
{bugliesi,focardi,maffei}@dsi.unive.it
ABSTRACT
We propose a type and effect system for authentication protocols
built upon a tagging scheme that formalizes the intended seman-
tics of ciphertexts. The main result is that the validation of each
component in isolation is provably sound and fully compositional:
if all the protocol participants are independently validated, then the
protocol as a whole guarantees authentication in the presence of
Dolev-Yao intruders. The highly compositional nature of the anal-
ysis makes it suitable for multi-protocol systems, where different
protocols might be executed concurrently.
Categories and Subject Descriptors
C.2.2 [Computer-Communication Networks]: Network Proto-
cols—Protocol Veriﬁcation; F.3.2 [Logics and Meanings of Pro-
grams]: Semantics of Programming Languages—Program Anal-
ysis; K.6.5 [Management of Computing and Information Sys-
tems]: Security and Protection—Authentication
General Terms
Security, Veriﬁcation
Keywords
Static Analysis, Authentication, Process Calculi
1.
INTRODUCTION
Authentication protocols are security protocols whose purpose
is to enable two entities to achieve mutual (and reliable!) agree-
ment on some piece of information, typically the identity of the
other party, its presence, the origin of a message, its intended des-
tination. Achieving the intended agreement guarantees is subtle
because they typically are the result of the encryption/decryption
of (sequences of) messages composed of different parts, with each
∗
Work partially supported by EU Contract IST-2001-32617 “Mod-
els and Types for Security in Mobile Distributed Systems”
(MyThS).
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
FMSE’04, October 29, 2004, Washington, DC, USA.
Copyright 2004 ACM 1-58113-971-3/04/0010 ...$5.00.
part providing a “piece” of the authentication guarantee. To illus-
trate, consider the following example:
B → A :
A → B :
n
{B, m, n}SignA
Bob, the initiator, sends to Alice a random challenge (i.e., a nonce)
n; Alice, the responder, signs the challenge together with a message
m and Bob’s identiﬁer B; the protocol completes with the equality
check on the nonce performed by B after decrypting the message
with A’s public key. The aim of the protocol is to guarantee to B
that m is authentic from A, i.e., that m has been freshly sent by A to
B. Each message component of the encrypted packet {B, m, n}SignA
has a speciﬁc purpose in the protocol: the nonce n guarantees that
the packet is fresh (it is not a reply of an old protocol session
since n is used only once); the identiﬁer B speciﬁes the intended
receiver of m; the signature guarantees that A is the sender. Collec-
tively, the exchange of the three components provides the following
agreement [18, 23] property: (i) the two participants agree on each
other’s identity, namely, B is guaranteed that its responder is A, as it
appears to be, and dually, A knows that the initiator is indeed B; (ii)
the two parties agree on the origin and destination of the message
m, i.e. that it was originated by A and intended for B.
In [10] we have proposed a static method for the analysis of au-
thentication properties of the kind outlined above. Here, we extend
our results in several ways.
• We make our methodology applicable to a substantially wider
class of protocols, based on both symmetric and asymmet-
ric cryptography, and on diverse challenge-response mecha-
nisms.
• We provide authentication guarantees in the presence of a
wider class of attacks, including attacks based on the oppo-
nent acting as an honest principal. Thus our analysis encom-
passes the case of opponents provided with their own private,
public and long-term keys.
• We extend our analysis to the veriﬁcation of message authen-
tication properties in addition to entity authentication.
• Finally, we formulate our approach in terms of a type-and-
effect system; this provides our system with a more solid
meta-theory, based on consolidated type-theoretic founda-
tions, and enables us to draw more precise comparisons with
related work on the subject, speciﬁcally with the work by
Gordon and Jeffrey [11, 12].
Our present approach is based on the same methodology as the one
proposed by [11, 12], namely: (1) specify properties by annotating
an executable speciﬁcation of the protocol with correspondence as-
sertions; (2) annotate the protocol with suitable types (and tags);
(3) verify the assertions by running a type checker. Technically,
however, the technique we employ is different, as we rely on tags
to annotate the ciphertexts exchanged in the protocol to assist the
typed analysis of the protocol. This is best illustrated with an ex-
ample.
Consider again the simple authentication protocol we illustrated
earlier. As we argued, the authenticity properties of the protocol are
the result of the combined effect of speciﬁc guarantees conveyed by
each of the components of the message {B, m, n}SignA. The system
of [12] captures these guarantees by assigning the following type
to the private key that signs the message:
Key( B : Principal,
m : Payload,
n : Public Response[end A sending m to B]
)
The structure of this dependent type renders the intended depen-
dencies among the message components: in particular, the nonce
type provides a complete speciﬁcation of the role of the nonce in
the protocol. The safety proof for the protocol is then, essentially,
a consequence of the typing rules guaranteeing that the protocol
participants manipulate the nonce according to this intended us-
age. The fairly rich structure of the key and nonce types makes the
approach very ﬂexible, and expressive. On the other hand, there ap-
pear to be trade-offs. First, step (2) of the method (see above) may
become rather complex, for choosing the correct types of nonces
and keys may turn out to be non-trivial. Secondly, the degree of
compositionality of the analysis seems to be slightly undermined
by the very structure of the types, which essentially encode much
of the structure of the protocol itself. As a consequence, it seems
hardly possible to factor the authenticity properties proved for the
protocol into corresponding properties established locally for each
of the principals, independently of the context.
Our approach is different. We render the inter-dependencies
among message components directly on terms (rather than on their
types), by imposing a richer, tagged, structure to our terms. We
identify “minimal” set of authentication patterns (based on cor-
responding forms of nonce handshakes), and make explicit in the
encrypted messages the pattern they correspond to. For example,
message {B, m, n}SignA is tagged as {Id(B), Auth(m), Verif(n)}SignA
to signal that the nonce n is authenticating m to the veriﬁer B. The
tags are dynamically identiﬁed by the recipient of a message, upon
decryption, and employed to achieve/provide authentication guar-
antees. Intuitively, the information associated through dependent
types in the Gordon-Jeffrey type system, is conveyed here in the
more complex structure of our (tagged) terms. This allows us to
use simple types to just enforce the secrecy of keys and secret chal-
lenges, and simple effects to reason about authentication.
The advantages of our approach may be summarized as follows.
It is fully compositional: since the uniform use of tags is im-
posed by the typing rules, each party may be checked in isolation,
i.e., using an independent typing environment. Indeed, all parties
do share the same typing assumptions for keys, but such types only
convey information on the principals holding/sharing the keys and,
more importantly, this information is independent of the speciﬁc
protocol that the entities will be running (hence, we do not need to
include in the type assumptions for keys any information about the
structure of the messages that will be encrypted with such keys).
This is different from the Gordon-Jeffrey approach: as we noted
above, in [12] the types of the shared keys encode information on
the protocol steps, so that different protocols between the same par-
ties require different typings for the same keys (or else, different
keys).
This strong form of compositionality allows us to safely mix dif-
ferent protocols once their sequential components are type-checked;
thus, our tagging discipline naturally scales to multi-protocol set-
tings. Furthermore, the fact that tags correspond to a small set of
a-priori selected patterns, makes the type system quite simple and
easy to use; the human effort required is very small. Finally, even
though the set of authentication patterns we have selected is small,
it seems to be expressive enough to capture many of the protocols
in literature; this gives also new insights on which are the basic
mechanisms for guaranteeing authentication. We remark that our
safety results rely critically on the assumption that the messages
exchanged in the protocol are tagged: hence our tags play a static
as well a dynamic role, and the safety theorem assumes that the se-
mantics of protocols is itself tagged. While this may be seen as a
limitation, our tagging mechanism turns out to be less demanding
than those employed to resolve message ambiguities in many exist-
ing protocol implementations and protocol analysis techniques (cf.
Section 5).
Plan of the paper The rest of the paper is organized as follows:
Section 2 gives a brief outline of the ρ-spi calculus and its opera-
tional semantics. Section 3 summarizes our type and effect system
and its main properties.
In Section 4 we analyze the Splice/AS
Protocol and in Section 5 we conclude with ﬁnal remarks and a
discussion of other related work.
2.
ρ-spi calculus
The ρ-spi calculus , originally proposed in [10], derives from the
spi calculus [2], and inherits many of the features of Lysa [5], a
version of the spi calculus proposed for the analysis of authentica-
tion protocols. ρ-spi differs from both calculi in several respects:
it incorporates the notion of tagged message exchange from [9], it
provides new authentication-speciﬁc constructs, and offers primi-
tives for declaring process identities and keys. In this paper, we
extend the calculus with primitives for asymmetric cryptography
(key declaration, encryption and decryption).
The syntax is reported in Table 1 and described below. We pre-
suppose two countable sets: N of names and V of variables. We
reserve k, m, n for names and x, y, z for variables, with a ranging
over both names and variables. Identities ID are a subset of names
and are ranged over by I and J. Identities are further partitioned
into trusted principals IP , ranged over A and B, and enemies IE ,
ranged over by E. Both names and variables can be tagged, noted
C(a). Tags, denoted by C, are a special category of names. The
pair composed by a public key and the corresponding private one
is noted by Pub(m), Priv(m), similarly to [2]1.
Processes (or protocols), ranged over by P, Q are the parallel
composition of principals. Each principal is a sequential process
associated with an identity I, noted I (cid:2) S. The replicated form I(cid:2)!S
indicates an arbitrary number of copies of I (cid:2) S. In order to allow
the sharing of keys among principals, we provide ρ-spi with let-
bindings: let k = sym-key(I1, I2).P declares (and binds) the long-
term key k shared between I1 and I2 in the scope P. Similarly,
let k = asym-key(I).P declares, and binds in the scope P, the key
pair Pub(k), Priv(k) associated to I.
Sequential processes may never fork into parallel components:
this assumption helps assign unique identities to (sequential) pro-
cesses, and involves no signiﬁcant loss of expressive power as pro-
tocol principals are typically speciﬁed as sequential processes, pos-
sibly sharing some long-term keys. The sequential process 0 is the
null process that does nothing, as usual. Process new(n).S generates
1In the rest of the paper, we will use the following notation con-
vention: Pub = Priv and vice-versa.
Table 1 The syntax of ρ-spi calculus.
Notation: C over tags: {Claim, Claim?, Verif, Verif?, Id, Auth}, a over names and variables.
M ::= Patterns
names
variables
tagged data
key(key ∈ {Pub/Priv})
m, n, k
x, y, z
C(a)
key(a)
P, Q ::= Processes
I (cid:2) S
I(cid:2)!S
P|Q
let k = sym-key(I1, I2).P
let k = asym-key(I).P
(principal)
(replication)
(composition)
(symmetric-key assignment)
(asymmetric-key assignment)
S ::= Sequential processes
0
new(n).S
in(M1, . . . ,Mn).S
out(M1, . . . ,Mn).S
encrypt{M1, . . . ,Mn}
encrypt{|M1, . . . ,Mn|}
decrypt x as {M1, . . . ,Mn}
decrypt x as {|M1, . . . ,Mn|}
run(I1, I2,M ).S
commit(I1, I2,M ).S
M0
(nil)
(restriction)
(input)
(output)
as x.S
(symmetric encryption)
as x.S
(asymmetric encryption)
.S
(symmetric decryption)
M0
.S (asymmetric decryption)
M0
M0
(run)
(commit)
a fresh name n local to S. We presuppose a unique (anonymous)
public channel, the network, from/to which all principals, including
intruders, read/send messages. Similarly to Lysa, our input prim-
itive may (atomically) test part of the message read, by pattern-
matching. If the input message matches the pattern, then the vari-
ables occurring in the pattern are bound to the remaining subpart