was computed as the proportion of the total US population
living there. Intuitively, it seems like the distribution of ZIP
codes in a nationwide database like the FOP dump will be
similar to the distribution of people into ZIP codes because
more populous areas will likely have more police ofﬁcers,
and therefore more FOP members. However, we note that
the two distributions are not particularly well-correlated and
that our attacks below would probably be more effective with
better auxiliary data.
For large, sparse domains like the ones considered here,
it is possible for a target datum to be “un-recoverable”
according to our accuracy metrics for attacks with auxiliary
data, meaning its underlying plaintext does not exist in the
auxiliary data. For birth dates and ZIP codes this is not the
case, but it is for ﬁrst and last names. On average for our
datasets, above 99% of ﬁrst name records are recoverable
but only 91% of unique ﬁrst names are. For last names, only
89% of records and 71% of unique values are recoverable on
average. Below, we will not correct our results to account for
this artiﬁcial cap on attack accuracy, since a real adversary
would likely face this same problem. This is in line with
our very conservative approach to auxiliary data overall.
However, in Section V we will evaluate an attack that does
not require auxiliary data, so this limitation does not apply
there.
IV. THE NON-CROSSING ATTACK
In this section we recall the NKW cumulative attack which
can work against OPE and ORE schemes that leak both
frequency and order. This includes all deterministic OPE
schemes, including [5, 12, 26, 31, 37].
We discuss some limitations both in terms of efﬁciency
and accuracy of their attack, and suggest a new attack that
performs signiﬁcantly better. We call this the non-crossing
attack. It works for any scheme for which the original NKW
cumulative attack works, and it also will be what we build
off in later sections when we take advantage of more leakage
and stronger adversarial models.
Attack setting. In this section, we follow NKW and con-
sider known-ciphertext attacks with auxiliary information,
but no knowledge of any plaintexts. More precisely, an at-
tacker obtains a sequence of ciphertexts C = (c1, . . . , cn)
for ci = EK(mi). Plaintexts may repeat and are drawn
according to some (typically unknown) distribution pm over
a message space M. The attacker additionally has auxiliary
information about pm, which in practice is simply a sequence
Z = (z1, . . . , zψ) of plaintexts that is believed to be drawn
from M using a distribution close to pm. For our datasets, it’s
always the case that n  p. In fact, the NKW attack
violated ordering constraints in every one of our experiments
on real datasets. One can avoid such crossings by labeling
edges with just the square distance of CDFs, but as mentioned
this performs poorly. We therefore seek a way to avoid
violating ordering constraints, while still taking advantage of
the available frequency information.
The non-crossing attack. We introduce what we refer to as
the non-crossing attack. An attacker can avoid crossings in
their solution by solving a max-weight non-crossing bipartite
matching problem on the graph G. Since ordering constraints
are encoded into the matching algorithm, we will not include
any ordering information in our edge labels. Rather, we will
use the L1 distance of frequencies. For ciphertext i and
auxiliary datum j, the labeling function is
w(i, j) = α − |HC(i) − HZ(j)|
where α is a ﬁxed constant parameter that converts a min-
cost problem into a max-weight problem. In our context,
any choice of α > 1 will not change which matchings are
maximum-weight, so the solution to the inference problem
will be the same for any α > 1. Different choices of α will
change what that maximum weight is, but for our purposes
this is inconsequential.
This approach also signiﬁcantly improves computational
performance over NKW: there is a well-known dynamic-
programming approach that runs in time O(nψ) to ﬁnd the
optimal non-crossing matching [32].
Results. We compare the non-crossing and cumulative at-
tacks for our customer record datasets detailed in Section III.
We could not scale the NKW’s use of the Hungarian algo-
rithm to complete in reasonable time for last name, birthdate,
or ZIP code datasets. With the largest last name dataset,
we estimated the NKW attack would have taken roughly
one hundred days to complete a single experiment on the
well-provisioned compute cluster we used for the ﬁrst name
experiments. The Hungarian algorithm is highly nontrivial to
parallelize, compounding its scalability issues. For last name,
birthdate, and ZIP codes, we will compare our non-crossing
attack to the NKW greedy attack. For ﬁrst names, we will
compare the non-crossing attack with the exact Hungarian
algorithm.
Figure 3 compares the success of the two attacks for ﬁrst
names (left bars) and last names (right bars), showing raw
recovery rates for each dataset. The non-crossing attack al-
ways performs strictly better than NKW’s cumulative attack,
and some times substantially so, nearly doubling the average
recovery rate (44% vs. 83%) for ﬁrst names and septupling
(5% vs. 38%) the average recovery rate for last names.
When taken as percentage of the “recoverable” names (those
plaintexts that also appear in the auxiliary data), on average
we recover 84% of ﬁrst names and 42% of last names.
The unusually low performance on the Illinois dataset is
due to its small size — it is only about one-third of the size of
the next smallest dataset. Its small size is problematic because
it impacts the statistical quality of the sample. For example,
the most frequent ﬁrst name only occurs 34 times and the
most frequent last name only occurs 10 times.
Figure 4 shows the average unique recovery rate for high-
frequency ﬁrst and last names. It is cumulative, so the x
axis labels refer to the recovery rate for that number of top
names. For example, the point (40, 95) means the attack
recovered 38 of the top 40 most frequent names, on average.
Our attack is especially accurate for these values. From this,
we can conclude that for almost all datasets no real security
guarantee can be made for high-frequency names. We do not
include a separate graph for unique recovery rates for ﬁrst
and last names, but the overall trend is very similar.
Inference on birthdates and ZIP codes is much less accu-
rate for both attacks: exact recovery rates were less than 2%
across the board. This occurred for two reasons. First, the
auxiliary information available for attackers is not as accurate
a reﬂection of the target data distribution, compared to the
names data. For example, our ZIP code data is not really a
sample from the same distribution as our auxiliary data — the
ZIP code frequencies in our auxiliary data are proportional
to the number of people living there, but the frequencies in
our target dataset are proportional to FOP membership, which
varies state-to-state. Second, the distributions themselves are
661
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:38 UTC from IEEE Xplore.  Restrictions apply. 
e
t
a
R
y
r
e
v
o
c
e
R
100
80
60
40
20
0
IL
NC
TX A M U
O H
IA
NJ
CT
M D
FL
TXCO M
W A
CALC
FOP
NKW (First Names) Non-crossing (First Names) NKW Greedy (Last Names) Non-crossing (Last Names)
Figure 3: Comparison of raw recovery rates of NKW and the non-crossing attack on ﬁrst and last names. The non-crossing attack outperforms
NKW for all target datasets.
ﬂatter and do not have frequency “peaks” which can be easily
recovered by inference attacks.
We do note that partial information is often leaked. The
non-crossing attack’s preﬁx recovery rate was 34% for birth-
dates and 23% for ZIP codes. The corresponding preﬁx
recovery rates for the NKW attack are similar. The non-
crossing attack outperforms the baseline by about ten percent
in overall preﬁx recovery for birth dates: we recovered the
decade of birth for 75% of the unique birth dates in the
database (16,847 out of 22,485). The non-crossing attack also
recovered, on average, the ﬁrst digit of a target ZIP code,
giving the adversary the region of residence of the record
(e.g. eastern seaboard, midwest, southwest). In all cases, the
NKW with greedy heuristic attack performs worse than non-
crossing.
In terms of runtime performance, both the NKW with
greedy heuristic and the non-crossing attack are reasonably
fast. They require at most ten and twelve hours, respectively,
to run to completion on the FOP last name dataset, the
largest of any we examined. It includes n ≈ 116, 000 unique
ciphertexts and ψ ≈ 151, 000 unique values in the auxiliary
data. The induced bipartite graph has around 17.4 billion
edges. The non-crossing attack is slower than the greedy
heuristic due to the need for a backtracking step (similar
to the one used in the classical edit distance algorithm) to
recover the edges of the max-weight matching. It also writes
to two large data structures at each iteration of the inner loop,
which can be slow if the memory layout is not tuned. We
optimized our implementation by exploiting the fact that the
algorithm only needs to examine two rows of the dynamic
programming table at a time: the one currently being written
to, and the previous one. We reuse two ﬁxed-width buffers
for these rows rather than allocating an entire n × ψ matrix
in memory. These two buffers are small enough to ﬁt in the
CPU’s cache, so the number of slow operations on DRAM
100
90
80
d
e
r
e
v
o
c
e
r
s
e
m
a
n
f
o
t
n
e
c
r
e
P
First Names
Last Names
70
20
40
60
80 100 120 140 160 180 200
Number of top names
Figure 4: Average unique recovery rates for high-frequency ﬁrst and
last names for non-crossing attack. The red line with circles is ﬁrst
names. The blue line with squares is last names. Note that the y-axis
starts from 70.
is effectively halved. It also reduces the overall memory
footprint by about 90%.
V. ATTACKING THE BCLO SCHEME
The attacks discussed in the previous section only take ad-
vantage of frequency and order information. While there exist
schemes that leak only this information (or even less), they