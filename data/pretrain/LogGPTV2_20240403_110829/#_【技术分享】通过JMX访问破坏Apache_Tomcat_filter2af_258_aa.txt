# 【技术分享】通过JMX访问破坏Apache Tomcat
|
##### 译文声明
本文是翻译文章，文章来源：nccgroup.trust
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
翻译：[ **myswsun**](http://bobao.360.cn/member/contribute?uid=2775084127)
预估稿费：300RMB
投稿方式：发送邮件至[linwei#360.cn](mailto:PI:EMAIL)，或登陆[网页版](http://bobao.360.cn/contribute/index)在线投稿
**0x00 前言**
本文主要关注Tomcat服务器的一些配置问题，可以将Java管理扩展（JMX）服务暴露到外部网络中，来用于远程监视和管理的目的。
通过使用Java开发工具包（JDK）中的JConsole工具，这些功能可能被攻击者滥用来获得系统的控制权限。
本文的编写是为了来强调这种之前不为作者所知的新的攻击方式，它与Tomcat服务器暴露的JMX接口有关。
希望在这里提供了足够的信息，以利于提出阻止这种利用的有效的缓解措施并且帮助渗透测试团队评估使用这种配置的Tomcat服务器的状态。
本文讨论的这个问题已经提交给Tomcat团队，被分类为程序的已知功能，并且目前没有任何补丁提供。
总而言之，Tomcat指出：
Java JMX访问相当于admin/root访问，其处理方式与对具有admin / root权限的机器的物理访问相同。
其他敏感的信息，比如session IDs，可通过JMX访问，并且隐藏这些信息将严重降低JMX接口的实用性。
Tomcat文档通常不涵盖JMX的主题，但是在其他地方会涵盖它。
任何读者在阅读本文后都应该遵循第九节中的建议。
**0x01 Tomcat的JMX服务**
Apache Tomcat的JMX服务通常被用来通过网络监控和管理远程Tomcat
实例，通过Java远程方法调用（RMI）来与服务器交互。
这个服务默认不开启，与之相反的是其他常见的Java企业版的服务器（比如JBoss）是默认配置开启的。
为了开启Tomcat的JMX服务，需要在setenv.sh/setenv.bat做一些简单的修改，这个脚本是用来设置环境变量和Catalina进程启动时的一些属性。
JMX服务可以配置为支持认证，但是它默认不开启。当认证被开启（总是被推荐），它的授权模型允许访问属于只读或读写角色的两个不同的用户。
网络上关于JMX接口的配置信息很少且过时了。
例如，在下面的URL对应的网页的标题为“监视和管理Tomcat”，但是它的配置指导是基于java 6版本的：
这个指南的第一段开始有一段注释：
“注释：这个配置只在你需要远程监控Tomcat时才开启，如果只是本地监视则不需要开启，且需要使用启动Tomcat相同的用户。”
这个快速指南包括认证未开启的简单配置。然后它建议需要认证时，修改配置来启用上述的两个角色且分配密码。
指南中有意思的一个片段如下：
如果你需要认证，添加并修改这个：
    -Dcom.sun.management.jmxremote.authenticate=true
    -Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password
    -Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access
编辑$CATALINA_BASE/conf/jmxremote.access文件：
    monitorRole readonly
    controlRole readwrite
编辑$CATALINA_BASE/conf/jmxremote.password文件：
    monitorRole tomcat
    controlRole tomcat
提示：密码文件应该是只读的，只能用和运行Tomcat相同的操作系统用户来访问。
如上所见，jmxremote.access文件包含两个用户名（monitorRole和controlRole）和他们相关的角色。在jmxremote.password文件中设置这些用户的密码。
对此服务始终建议启用认证，但快速指南不强调此功能。
这个指南不强调为只读和读写用户设置强密码的重要性。这就是为什么在现场渗透测试期间，这个接口经常被发现没有配置认证或者使用了与指南建议类似的弱密码。
**0x02 决定是否启用Tomcat的JMX接口**
通常需要使用nmap进行扫描，来确认与Tomcat关联的JMX接口是否已启动并在远程服务器上运行。
在这种情况下强烈建议使用–version-all和-A标志，因为它会告诉nmap触发附加探测器来检测非标准端口上JMX接口的存在。
例如，假设使用以下命令行扫描Tomcat服务器：
    >nmap -p- -sV -A 192.168.11.128 -n
    Nmap scan report for 192.168.11.128
    Host is up (0.00028s latency).
    Not shown: 65521 closed ports
    PORT STATE SERVICE VERSION
    ...
    2001/tcp open dc?
    ...
    8009/tcp open ajp13 Apache Jserv (Protocol v1.3)
    |_ajp-methods: Failed to get a valid response for the OPTION request
    8080/tcp open http Apache Tomcat/Coyote JSP engine 1.1
    |_http-favicon: Apache Tomcat
    |_http-open-proxy: Proxy might be redirecting requests
    |_http-server-header: Apache-Coyote/1.1
    |_http-title: Apache Tomcat/8.0.39
    ...
    49222/tcp open unknown
为了简单起见，上面的扫描结果仅包括与Tomcat相关的端口。可以看到，端口2001/tcp和端口49222/tcp未明确标识。
然而，添加–version-all标志将显示更多有趣的信息：
    >nmap -p- -A -sV --version-all 192.168.11.128
    Nmap scan report for 192.168.11.128
    Host is up (0.00032s latency).
    Not shown: 65521 closed ports
    PORT STATE SERVICE VERSION
    ...
    2001/tcp open java-rmi Java RMI Registry
    | rmi-dumpregistry:
    | jmxrmi
    | implements javax.management.remote.rmi.RMIServer,
    | extends
    | java.lang.reflect.Proxy
    | fields
    | Ljava/lang/reflect/InvocationHandler; h
    | java.rmi.server.RemoteObjectInvocationHandler
    | @192.168.11.128:2001
    | extends
    |_ java.rmi.server.RemoteObject
    ...
    8009/tcp open ajp13 Apache Jserv (Protocol v1.3)
    |_ajp-methods: Failed to get a valid response for the OPTION request
    8080/tcp open http Apache Tomcat/Coyote JSP engine 1.1
    |_http-favicon: Apache Tomcat
    |_http-open-proxy: Proxy might be redirecting requests
    |_http-server-header: Apache-Coyote/1.1
    |_http-title: Apache Tomcat/8.0.39
    ...
    49222/tcp open rmiregistry Java RMI
在这种情况下，JMX服务被配置为在非标准端口2001/tcp而不是端口1099/tcp上运行，1099/tcp通常被这种服务的优先选择。
此外，应当注意的是当JMX接口运行时，运行Java RMI的随机端口也可用于Tomcat。从客户端/攻击者角度来看，能够连接此端口也很重要。
也就是说，单独使用nmap无法确定Tomcat JMX接口是否启用认证。
**0x03 使用JConsole连接JMX服务**
如果你使用Windows，JConsole是JDK中的一个小的可执行文件，存储在bin文件夹中。启动后主界面如下图：
图1 – Jconsole主界面
JConsole也在Linux版的JDK中提供，且在Kali中找到如下图：
图2 – Kali中的JConsole
如果逆向远程连接到Tomcat JMX接口，选择Remote Process选项且输入目标的IP地址加端口号。点击Connect按钮：
图3 – 设置目标
JConsole能够检测到SSL是否开启，并且显示如下提示：
图4 – 目标中的SSL没有开启
单击Insecure connection按钮继续。当启用认证，通常会显示以下提示：
图5 – 认证启动的提示
在这种情况下，您应该使用username和password文本框输入一些有效的凭据。请注意，也可能由于其他原因获得连接失败错误。
连接失败的常见原因之一是由于攻击者和服务器之间的防火墙。此防火墙可能配置为阻止传入流量到由Tomcat启动的其他Java
RMI进程使用的端口（例如，上面nmap扫描输出中列出的49222/tcp）。
使用您喜欢的网络嗅探器进行流量捕获，以了解“连接失败”错误是否与认证相关。
在下面的示例中，Tomcat JMX服务器（运行于192.168.11.128）正在返回包含认证失败错误的RMI消息：
图6 – 认证失败-暗示需要认证凭据
请注意，上面的错误包括需要凭据的字符串，表示在JConsole初始屏幕中未指定任何凭据。
在输入一些凭据时返回不同的错误消息：
图7 – 不可靠的用户名和密码
如果未启用认证（这在某些内部网络渗透测试中可能是正确的），显示如下：
图8 – Jconsole连接到远程的Tomcat JMX接口
事情开始变的有趣。
从这一点开始，我们将考虑攻击者能够识别一个监听的Tomcat
JMX接口并可以使用JConsole连接到它的情况。这是可能的，因为认证未启用，或者因为攻击者能够猜到一些有效的凭据。
**0x04 使用JMX读取Tomcat管理器的密码**
假设Tomcat启用了管理器应用程序，但是没有使用任何弱凭据（如admin/admin或tomcat/manager）。假设攻击者试图使用自动脚本来强制一个有效的密码而不成功。
在这里，可能得出没有方法发现管理器密码的结论。
事实上，有一个简单的方法，在忽略密码强度的情况下恢复密码，在写文章的这一刻，这个技术还没有参考。
这个方法是在你的机器上面启动JConsole并且指向远程的Tomcat JMX服务器。选择MBeans选项卡：
图9 – 选择MBeans
之后显示如下：
图10 – Mbeans
展开Users目录，且选择下面的节点：
    Users->User->”manager”->UserDatabase->Attributes
你应该能够看见类似下面的一些东西，这些暗示了凭据：
图11 – 泄漏的Tomcat管理器的用户名和密码
在这里，你能使用发现的凭据来连接到远程Tomcat管理器，以控制服务器。
**0x05 日志循环函数中的目录遍历**
如果你已经看到了这里，你已经有了一个好且简单的方法来访问Tomcat管理器，来破环底层服务器。
执行此操作的典型方法是部署简单的Web应用程序存档（WAR），包括允许执行操作系统（OS）命令的代码，然后调查服务器上的内容。
如果服务器在Windows上运行，则大多数时间它将作为SYSTEM或管理员运行。因此，你的操作系统命令将在最高权限级别运行。
但是，如果由于某些原因Tomcat管理器不在那里怎么办？
虽然在内部网络中部署的服务器则不可能是这种情况，但是仍然有可能，因此我们需要另一种方法来浏览服务器，假设我们仍然能够连接Tomcat JMX接口。
**日志循环函数**
在大量的具有写权限的Tomcat JMX
MBeans操作中，有一个显示了有趣的行为。当JMX服务没有配置支持认证时，这个特别的功能也能访问。下面是它的Java特征：
    boolean rotate(string newFileName)
上面的特征在下面的节点提供：
    Catalina->Valve->localhost->AccessLogValve->Operations
这表明rotate函数用于备份Tomcat访问日志到服务器上的文件中。
为了证明这个，下载了运行Tomcat8.0.39的Bitnami Linux
VM。然后配置服务器来公开JMX端口，以便允许使用JConsole进行连接。最后totate函数用此位置指定文件：
    /tmp/test.log
完成这个过程后，下面的确认消息由服务器返回：
图12 – ‘True’确认消息被执行
可以确认test.log文件在tmp目录中。直到rotate函数被调用，目录的内容是Tomcat访问日志。
    bitnami@ubuntu:/tmp$ cat /tmp/test.log
    192.168.11.1 - - [08/Dec/2016:14:50:42 +0000] "GET /test-log-request HTTP/1.1" 404 1026
    bitnami@ubuntu:/tmp$
**在服务器上面执行OS命令**
正如上一节讨论的，rotate函数允许在服务器的任意目录中存储文件。它还将允许选择该文件的任意扩展。