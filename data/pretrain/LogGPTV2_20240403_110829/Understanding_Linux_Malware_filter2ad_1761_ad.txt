2.31%
1.78%
0.38%
program, or avoid showing unusual names in the list of running
processes.
Overall, we noted that this behavior, already common on
Windows operating systems, is also widespread on Linux-
based malware. Table V shows that over 50% of the samples
assumed different names once in memory, and also reports
the top benign application that are impersonated. In total
we counted more than 4K samples invoking the system call
prctl with request PR_SET_NAME, or simply modifying
the ﬁrst command line argument of the program (the program
name). Out of those, 11% adopted names taken from common
utilities. For example, samples belonging to the Gafgyt family
often disguise as sshd or telnetd. It
is also interesting to
discuss the difference between the two renaming techniques.
The ﬁrst (based on the prctl call) results in a different
process name listed in /proc//status (and used by
tools like pstree), while the second modiﬁes the information
reported in /proc//cmdline (used by ps). Quite
strangely, none of the malware in our dataset combined the
two techniques (and therefore could all be easily detected by
looking for name inconsistencies).
The remaining 88% of the samples either adopted an empty
name, a name of a ﬁctitious (but not existing) ﬁle, or a random-
looking name often seeded by a combination of the current
time and the process PID. This last behavior, implemented by
some of the Mirai samples, results in the fact that the malicious
process assumes a different name at every execution.
D. Required Privileges
Our tests show that the distinction between administrator
(root) and normal user is very important for Linux-based
malware. First, malicious samples can perform different actions
and show a different behavior when they are executed with
super-user privileges. Second, especially when targeting low-
168
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:40 UTC from IEEE Xplore.  Restrictions apply. 
end embedded systems or IoT devices, malware may even be
designed to run as root—and thus fail to execute if analyzed
with more limited privileges.
Therefore, we ﬁrst executed every sample with normal user
privileges. If, during the execution, we detected any attempt
to retrieve the user or group identities (which could be used
by the program to decide the malware’s next actions) or to
access any resource that returned a EPERM or EACCES errors,
we repeated the analysis by running the sample with root
privileges. This was the case for 2637 samples (25% of the
dataset) and in 89% of them we detected differences in the
sample behavior extracted from the two execution traces.
Table VII presents a list of behaviors that were executed
when running as root but were not observed when running
as a normal user. Among these, privileged shell commands
and operations on ﬁles are predominant, with malware using
elevated privileges to create or delete ﬁles in protected folders.
For instance, samples of the Flooder and IoTReaper families
hide their traces by deleting all
log ﬁles in /var/log,
while samples of the Gafgyt family only delete last login
and logout information (/var/log/wtmp). Moreover, in few
cases malware running as root were able to tamper with the
sandboxed execution: we found binaries that, upon detection
of the emulated execution environment, would kill the SSH
daemon or even delete the entire ﬁle system.
We now look in more details at two speciﬁc actions that are
determined by the execution privileges: privileges escalation
exploits and interaction with the OS kernel.
Privileges Escalation. On the one hand, one of the advantages
of using kernel probes for dynamic analysis is its ability to
trace functions in the OS kernel—making possible for us
to detect signs of successful exploitations. For example, by
monitoring commit_creds we can detect when a new set
of credentials has been installed on a running task. On the
other hand, the sandboxes built to host the execution of each
sample were deployed with up-to-date and fully-patched Linux
operating systems—which prevented binaries from exploiting
old vulnerabilities.
According to our trace analysis,
there was no evidence
of samples that successfully elevated their privileges inside
our machines, or that had been able to perform privileged
actions under user credentials. Regarding older (and therefore
unsuccessful) exploits, we developed custom signatures to
identify the ten most common escalation attacks based on
known vulnerabilities in the Linux kernel1, for which an
exploitation proof-of-concept is available to the public. Our
tests revealed that CVE-2016-5195 was the most frequently
used vulnerability, with a total of 52 ELF programs that tried
to exploit it in our sandbox. We also detected ﬁve attempts to
exploit CVE-2015-1328, while the remaining eight checks did
not return any positive match.
Kernel Modules. System calls tracing allows our system to
track attempts to load or unload a kernel module, especially
TABLE VIII
ELF PACKERS
Process name
Vanilla UPX
Custom UPX Variant
- Different Magic
- Modiﬁed UPX strings
- Inserted junk bytes
- All of the previous
Mumblehard Packer
Samples
Percentage
189
188
129
55
126
16
3
1.79%
1.78%
0.03%
when samples are executed with root privileges. Interestingly,
among the 2,637 malware samples we re-executed with root
privileges, only 15 successfully loaded a kernel module and
none of them performed an unload procedure. All these cases
involved the standard ip_tables.ko, necessary to setup IP
packet ﬁlter rules. We also identiﬁed 119 samples, belonging
to the Gates or Elknot families that attempted to load a custom
kernel module but failed as the corresponding .ko ﬁle was not
present during the analysis.2
E. Packing & Polymorphism
Runtime packing is at the same time one of the most com-
mon and one of the most sophisticated obfuscation techniques
adopted by malware writers. If properly implemented, it com-
pletely prevents any attempt to statically analyze the malware
code and it also considerably slows down an eventual manual
reverse engineering effort. While hundreds of commercial, free,
and underground packers exist for Microsoft Windows, things
are different in the Linux world: only a handful of ELF packers
have been proposed so far [15]–[17], and the vast majority
of them are proof-of-concept projects. The only exception is
UPX, a popular open source compression packer introduced in
1998 to reduce the size of benign executables, which is freely
available for many operating systems.
Automatic recognition and analysis of packers is a subtle
problem, and it has been the focus on many academic and
industrial studies [18]–[22]. For our experiment, we relied on
a set of heuristics based on the ﬁle segments entropy and on the
results of the static analysis phase (i.e., number of imported
symbols, percentage of code section correctly disassembled,
and total number of functions identiﬁed) to ﬂag samples that
were likely packed. Moreover, since UPX-like variants seem
to dominate the scene, we decided to add to our pipeline a set
of custom analysis routines to identify possible UPX variants
and a generic multi-architecture unpacker that can retrieve the
original code of samples packed with these techniques.
UPX Variations. Vanilla UPX and its variants are by far the
most prevalent form of packing in our dataset. As shown in Ta-
ble VIII, out of 380 packed binaries only three did not belong
to this category. The table also highlights the modiﬁcations
made to the UPX format with the goal of breaking the standard
1CVE-2017-7308, CVE-2017-6074, CVE-2017-5123, CVE-2017-1000112,
CVE-2016-9793, CVE-2016-8655, CVE-2016-5195, CVE-2016-0728, CVE-
2015-1328, CVE-2014-4699.
2This is a well-known problem affecting dynamic malware analysis systems,
as samples are collected and submitted in isolation and can thus miss external
components that were part of the same attack.
169
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:40 UTC from IEEE Xplore.  Restrictions apply. 
TABLE IX
TOP TEN COMMON SHELL COMMANDS
EXECUTED
Shell command
sh
sed
cp
rm
grep
ps
insmod
chmod
cat
iptables
Samples
Percentage
400
243
223
216
214
131
124
113
93
84
5.13%
3.12%
2.86%
2.77%
2.75%
1.68%
1.59%
1.45%
1.19%
1.08%
TOP TEN PROC FILE SYSTEM ACCESSES BY
TABLE X
MALICIOUS SAMPLES
Path
/proc/net/route
/proc/ﬁlesystems
/proc/stat
/proc/net/tcp
/proc/meminfo
/proc/net/dev
/proc//stat
/proc/cmdline
/proc//cmdline
/proc/cpuinfo
Samples
Percentage
3368
649
515
498
354
346
320
278
259
226
43.22%
8.33%
6.61%
6.39%
4.54%
4.44%
4.11%
3.57%
3.32%
2.90%
UPX unpacking tool. This includes a modiﬁcation to the magic
number (so that the ﬁle does not appear to be packed with UPX
anymore), the modiﬁcation of UPX strings, and the insertion
of junk bytes (to break the UPX utility). However, all these
samples share the same underlying packing structure and the
same compression algorithm—showing that malware writers
simply applied “cosmetic” variations to the open source UPX
code.
Custom packers. Linux does not count on a large variety
of publicly available packers and UPX is usually the main
choice. However, we detected three samples (all belonging
to the Mumblehard family) that implemented some form of
custom packing, where a single unpacking routine is executed
before transferring the control to the unpacked program [23].
In one case, the malware started a separate process running
a perl interpreter and then used the main process to decrypt
instructions and feed them into the interpreter.
F. Process Interaction
This section covers the techniques used by Linux malware to
interact with child processes or other binaries already installed
or running in the system.
Multiple Processes. 25% of our samples consists of a single
process, 9% spawn a new process, 43% involves three pro-
cesses in total (largely due to the “double-fork” pattern used
to daemonize a program), while the remaining 23% created a
higher number of separate processes (up to 1684).
Among the samples that spawn multiple processes we ﬁnd
many popular botnets such as Gafgyt, Tsunami, Mirai, and
XorDDos. For instance, Gafgyt creates a new process for every
attempt to connect to its command and control (C&C) server.
XorDDos, instead, creates parallel DDos attack processes.
Shell Commands. 13% of the samples we analyzed inside
our sandbox executed at least one external shell command.
In total, we registered the execution of 93 unique command-
line tools—the most prevalent of which are summarized in
Table IX. Commands such as sed, cp, and chmod are often
executed to achieve persistence on the target system, while
rm is used to unlink the sample itself or to delete the bash
history ﬁle. Several malware families also try to kill previous
infections of the same malware. Hijami, the counter-malware
to “vaccinate” Mirai, uses iptables to close and open network
ports, while Mirai tries to close vulnerable ports already used
to infect the system.
Process Injection An attacker may want to inject new code
into a running process to change its behavior, make the sample
more difﬁcult to debug, or to hook interesting functions in
order to steal information.
Our system monitors three different techniques a process
can use to write to the memory of another program: 1)
a ptrace syscall that requests the PTRACE_POKETEXT,
PTRACE_POKEDATA, or PTRACE_POKEUSER functionali-
ties; 2) a PTRACE_ATTACH request followed by read/write
operations to /proc//mem; and 3) an in-
vocation to the process_vm_writev system call.
It is important to mention that the Linux kernel has been
hardened against ptrace calls in 2010. Since then it
is
not possible to use ptrace on processes that are not direct
descendant of the tracer process, unless the unprivileged user is
granted the CAP_SYS_PTRACE capability. The same capabil-
ity is required to execute the process_vm_writev call, a
new system call introduced in 2012 with kernel 3.2 to directly
transfer data between the address spaces of two processes.
that uses
technique mentioned above. It
We found a sample performing injection by using the
injects a dynamic li-
ﬁrst
libc (but ex-
brary in every active process
cludes gnome-session, dbus and pulseaudio).
In
the injected payload the malware uses the libc function
__libc_dlopen_mode to load dynamic objects at run-
time. This function is similar to the well-known dlopen,
which is less preferable because implemented in libdl, not
already included in the libc. After the new code is mapped
in memory, the malware issues ptrace requests to backup
the registers values of the victim process, hijack the control
ﬂow to execute its malicious behavior, and restore the original
execution context.
G. Information Gathering
Information gathering is an important step of malware
execution as the collected information can be used to detect
the presence of a sandbox, or to control the execution of the
sample. Data stored on the system can also be exﬁltrated to a
remote location, as it often happens with programs controlled
170
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:40 UTC from IEEE Xplore.  Restrictions apply. 
TOP TEN SYSFS FILE SYSTEM ACCESSES BY MALICIOUS SAMPLES
TABLE XI