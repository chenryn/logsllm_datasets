will run in the insecure ECB mode. Amandroid can verify
these rules by checking the possible values of the parameter
objects in a relevant API call by querying the IDFG.
4. EXPERIMENTATION AND EVALUATION
We extensively experimented with Amandroid in multiple
types of security analyses. We used several sets of apps: 753
popular apps from Google Play (the same dataset used in the
Epicc work [25] and made available by the authors), a sample
malware set (containing 100 apps) from Arbor Networks,
and two benchmarks (hand-crafted apps by other researchers
and us). For brevity, we call the ﬁrst two data sets GPlay
and MAL, respectively.
Our security analysis found multiple crucial problems in
the apps, which we report in this section. Most of our results
were never reported before by other researchers in the liter-
ature; some of the problems detected by Amandroid are in
the same category (but diﬀerent instances) of the previously
reported ones (e.g., password leak), while others are com-
pletely new categories (e.g., OAuth token leak). As Aman-
droid is the only tool which tracks data ﬂows through ICC,
Amandroid is able to ﬁnd sophisticated data leak and data
injection problems as illustrated by the results.
4.1 Performance and Scalability
We perform our experiments on a machine with 2 × 2.26
GHz Quad-Core Xeon and 32GB of RAM.
Amandroid gives options for multiple precision levels. For
instance, the context length k serves as a parameter to set
the trade-oﬀ between precision and performance.
In our
experimentation, we always set k = 1, meaning the static
analyzer tracks up to one calling context. Amandroid also
allows the user to deﬁne the scope of the analysis by exclud-
ing certain third-party libraries, and in our experiment we
excluded a few popular third-party libraries since they are
huge in size and could be separately analyzed, summarized,
Figure 4: Time to Build IDFG
and reused by the analysis of all the apps that include them.
Currently, we use the same modeling techniques as explained
in Section 3.3.2 for the excluded third-party libraries.
The most computational intensive step in Amandroid is
building the IDFG. Once the IDFG is built, the running
times of the subsequent analyses such as building DDG and
running the specialized analyses using IDFG and DDG are
negligible in comparison. Figure 4 presents the time taken
by Amandroid to construct IDFG for 853 apps. This mea-
surement is done on the data-sets GPlay and MAL which
are all real-world apps. During the experiment, we limited
the processing time of each component of an app to 10 min-
utes; Amandroid raised this timeout on 86 of the 853 apps.
For each app, which consists of multiple components, the
median time is 29 seconds; minimum is 2 seconds; and max-
imum is 113 minutes and 29 seconds. The scatter plot shows
both the running time and the size of the app (in number of
byte code instructions).
4.2 Application to Security Analysis
We report experimentation results addressing data leak,
data injection, and misuse of APIs (as discussed in Sec-
tion 3.5). All experiments are done using the GPlay and
MAL datasets (real-world apps).
4.2.1 Data Leak
Password Leaks: We used the following policy to vet apps
for properly handling user passwords: “password should not
be saved in the device (not even when encrypted) and should
be transferred to a remote server only via HTTPS.” (similar
guidelines can be found in, e.g.,
[13]). Amandroid can be
readily used to verify whether the input app obeys such a
policy. The only “to-do” task is to identify which variables
in the app’s code corresponds to a password object (source),
and to deﬁne the potential leaking sinks.
We ﬁnd the TextView item corresponding to a password
(when the inputType attribute’s value is textPassword) in
an app’s layout ﬁle and identify its unique ID. Amandroid
then looks for the usage of this particular ID in method call
Context.getViewbyId(x), which is done through a standard
reaching-deﬁnition analysis on the intra-procedural control-
ﬂow graph7; this method returns an EditText object y, and
y.getText() gives the password object. We can then deﬁne
7If the app’s developer obfuscates the ID through, e.g.,
mathematical manipulation, our reaching-deﬁnition analy-
sis will not be able to return concrete values for the view
914139,	
  6809	
  1	
  10	
  100	
  1000	
  10000	
  1	
  10	
  100	
  1000	
  10000	
  100000	
  1000000	
  Number	
  of	
  Bytecode	
  Instruc2ons	
  in	
  the	
  App	
  Analysis	
  Time	
  (second)	
  this object as the source. We prepare the list of sink APIs
by considering the relevant I/O operations (e.g., Log.i(key,
value), and URL.openconnection()). The rest of the analysis
is the straightforward application of DDG as explained in
Section 3.5.
We found several examples of password leakage. Table 1
shows part of the results. We observe a few interesting pat-
terns: (a) the password is logged in clear text (Case 1 in
Table 1); (b) the password is reaching a Network API over
HTTP channel (Entry 2 in Table 1); and (c) the password
is saved in SharedPreference (Entry 3 in Table 1). Case
2 stems from a third-party library for Twitter. The DDG
and IDFG shows that the app sends the user’s password to
http://api.twitter.com/1 (an HTTP connection). Inter-
estingly, one can see that the URL is not currently working
and only responds with a message “SSL is required.”
Table 1: Password Leakage Case Study
App name (app source)
Case 1: com.datpiﬀ.mobile.apk
(GPlay)
Case 2: com.toystorymusic-
.musicapp.* (MAL)
Case 3: com.snappii.angel invest- Write user password into
ing news v10.apk (GPlay)
App behavior
Get user password, encode
it, then write it into log.
Send password to server
via http.
SharedPreference.
OAuth Token Leaks: OAuth 2.0 [21] is a popular authen-
tication protocol which is frequently used for single-sign-on
(SSO), social sharing, etc. Typically, Google, Facebook, and
other popular services are the Identity Provider (IdP). Thus,
if the OAuth token is stolen, the user’s corresponding IdP
account can be compromised. Similar to password track-
ing, Amandroid can be used to check whether the input app
obeys the OAuth token protection policy. The source of
the potential leak is determined using a simple strategy of
tracking the string literal “access-token” and marking the
related object creation statements as the source. The sinks
are the same as in the password leak detection. We found
several potential OAuth token leakage cases, some of which
are shown in Table 2. We observe a couple of interesting
patterns: (a) The implicit intent carrying the token can pos-
sibly reach a malicious app. (e.g., Case 1 in Table 2), and
(b) A malicious app having Log-read permission can grab
the OAuth token (e.g., Case 1 and Case 2 in Table 2). Note
that the above type of token leakage is very diﬀerent from
the explicit token discoveries reported in a recent work [33].
Table 2: OAuth Token Leakage Case Study
App name (app source)
Case 1: com.skout.android.apk
(GPlay)
Case 2: com.keek.apk
(GPlay)
App behavior
Send OAuth token via implicit
ICC; also write it to Log.i().
Write OAuth token into log
using Log.d().
4.2.2 Data Injection
We found a variety of intent injection problem in our
experiment; Table 3 shows part of the results. We ob-
serve a couple interesting patterns: (a) The attacker con-
trols the “url” string in the TwitterLoginActivity. (Case 1),
and (b) The destination of an ICC depends on an incoming
intent controlled by the attacker (Case 2).
ID. In this case we will conservatively report a possible ma-
licious app, since it is extremely unlikely a benign app will
perform such manipulations on a view ID.
Table 3: Intent Injection Case Study
App behavior
App name (app source)
Case 1: com.fcbh.dbp.Bible- TwitterLoginActivity retrieves
the “url” from incoming intent
SocietyOfPhilippines.apk
and sends it to another Activity
(GPlay)
Start an activity by using the
Case 2: com.kamagames.
notepad.apk (GPlay)
mData of the incoming intent
Table 4: Crypto API Usage Case Study
App name (app source)
Case 1: hu.sanomabp.citromail-
.apk (GPlay)
Case 2: diesel.peko.ninkyodobro-
wser.apk (GPlay)
App behavior
Encrypt OAuth token using
AES ECB mode, then store
it in SharedPreference.
Encrypt the password using
AES ECB mode.
4.2.3 API Misuse
We found several apps that violate the rule on not using
ECB mode for encryption. Table 4 shows part of the results.
The apps encrypt the user credential using the AES cipher
in ECB mode.
4.2.4 What it Takes to Build a New Analysis
The advantage of Amandroid’s approach is that the gen-
eral framework provides a means for building a variety of
further security analyses in a straightforward and easy way.
Each special analysis built on top of Amandroid involves
developing a “plugin” that leverages the IDFG and DDG
from Amandroid’s analysis. Moreover, once the core analy-
sis produces IDFG and DDG for an app, they can be stored
and reused in multiple security analyses. We present the
summary of the plugins used in the above applications in
Table 5, which shows the sizes of the plugin in Scala LOC,
as well as the average running time of each plugin. This can
be compared with the size of the core engine and its average
running time, shown in the last row of the table.
Table 5: Code Size and Running Time (Plugins and Core)
Name
Tracking password plugin
Tracking OAuth Token plugin
Generic Data Leak plugin
Intent Injection plugin
Crypto API check plugin
Core Framework
Approx. Size
(Scala LOC)
120
120
60
70
140
30,000
Avg. Time
50ms
50ms
300ms
50ms
10ms
60s
4.3 Comparison with Existing Tools
We use three benchmark testsuites8 to compare Aman-
droid with two other well-known static analysis tools for
Android: FlowDroid [6, 17] and Epicc [25]. The benchmark
testsuites consist of hand-crafted apps designed to test cer-
tain analysis features. Since those apps are hand-crafted,
the ground truth is known, allowing for computing metrics
such as precisions and recalls. However, one needs to bear
in mind that these metrics are not representative of the real
8Using real-world apps for comparison will be diﬃcult since
there is no easy way to determine the ground truth. For ex-
ample, we have used the GPlay dataset to compare Aman-
droid and Epicc and found much less reachable ICC call
sites than Epicc. This could indicate that Amandroid is
more precise than Epicc (both tools are sound and thus will
not miss a path); however, without ground truth in the apps
it is impossible to test this hypothesis.
performance of the tool on real-world apps. They can only
be used for comparison purposes.
The ﬁrst benchmark is DroidBench, a benchmark testsuite
provided by the FlowDroid team that consists of Android
apps for evaluating information-ﬂow analysis. The version
we used contains 39 apps, including test cases for static anal-
ysis challenges as well as Android-speciﬁc challenges. As
DroidBench does not test any ICC-related capability, we
added another testsuite called ICC-Bench which contains
16 apps for testing various ICC reasoning capabilities. Each
test app has two components where one component sends an
Intent to the other one. The sender component involves a
source API while the receiver contains a sink API. The test
apps are categorized in two parts: Part A involves various
types of intent handling: explicit intent target ﬁnding, im-
plicit intent target ﬁnding (via matching action, categories,
data and type), and dynamically registered component han-
dling, etc.; Part B focuses on the accuracy of the analysis
by including a variety of scenarios where certain informa-
tion ﬂow paths do or do not exist. The list of ICC-Bench
apps can be found in the 1st column of Table 8. The third
testsuite consists of four specially designed test apps (each
with a single component) to test the data injection detection
capability. While the latter two testsuites were designed by
us and not a third party, the apps in these testsuites are not
crafted to favor a particular tool. They represent common
scenarios one will ﬁnd when reasoning about the relevent se-
curity issues. We plan to make both these testsuites publicly
available.
ICC Test
4.3.1
Table 6 summarizes the result of ICC testing using Part A
of ICC-Bench. As discussed in Section 3.3.3, to completely
handle ICC an analysis tool needs to carry out three steps.
Amandroid is able to successfully pass all the tests for the
three steps. Epicc only addresses Step 1 thus did not pass
the tests on Step 2 and 3 (shown as “N/A” in the table).
FlowDroid does not address ICC thus did not pass any of
the tests. For Step 1, Amandroid is able to handle all types
of intents: explicit, implicit, and mixed (either explicit or
implicit depending on execution paths). As discussed in Sec-
tion 3.3.3, an implicit intent can behave in multiple ways de-
pending on which ﬁeld (mAction, mCategories, mData (i.e.,
Uri9), or mType) is used. Amandroid can track each such
ﬁeld and hence can handle all types of implicit ICC. Epicc is
the only existing tool which attempts to solve ICC parame-
ters. However, Epicc does not handle mData or mType ﬁeld
of an intent, and thus failed those tests.
4.3.2 Data Leak
We compare the eﬀectiveness of Amandroid’s data leak de-
tection with the other tools on two benchmarks: DroidBench
and ICC-Bench. The tool is run on each test app to see if
the tool can report the correct data leak paths. The results
are shown in terms of True Positive (O), False Positive (*),
and False Negative (X), if any. If a test app contains mul-
tiple data leak paths, the result is shown for each of them.
Only FlowDroid and Amandroid can perform static taint
analysis to ﬁnd those leak paths; Epicc only outputs infor-
9Uri consists of multiple parts, such as scheme, host, port,
path; a tool must be able to determine the values of each
part to pass the test.
Table 7: DroidBench Test Results. O = True Positive, * =
False Positive, X = False Negative.
App Name
FlowDroid Amandroid Epicc
ArrayAccess1
ArrayAccess2
ListAccess1
AnonymousClass1
Button1
Button2
LocationLeak1
LocationLeak2
MethodOverride1
Arrays and Lists