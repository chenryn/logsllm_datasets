这里的`delegate`就是在`web.xml`被初始化的`MBeanUtilsInitSingleFileServlet`。
接下来以漏洞`URL`为例。
    /css/%252E%252E%252Fconsole.portal
**这里要二次编码的原因是，发过去的时候http会解一次码，也就是说如果我们传的是`/css/%2E%2E%2Fconsole.portal`，那么解码后就是`/css/../console.portal`，这样发到服务端就没办法匹配到静态资源了，直接处理成了`/console.portal`。**
如果`http`解码后的`url`里没有`;`，那么就会继续调用`super.service`，而官方的补丁修复也是在这，通过一个黑名单列表检测路径里的非法字符，不过官方给出的黑名单字符不够完善，能够被绕过。
一路到达`UIServlet#service`，根据请求`method`调用不同的方法，`doGet`最终也会调用到`doPost`。
#### url解码
在`doPost`里调用`createUIContext`。
UIContext会根据请求中的参数作对应属性值的设置，比如后面会说到的`_nfpb`。
创建完之后，会返回一个`UIContext`对象。 这里的`tree`也就是`createUIContext`传入的第三个参数，初始值为`null`。
跟入`UIServletInternal#getTree`，这里会对`requestPattern`解码。
解码后。
#### 请求portal文件，构建控件树
将解码后的`url`传入`processStream`方法。
然后`SingleFileProcessor#getMergedControlFromFile`。
**关于`.portal`的加载方式`singleFile`：简单来说，在访问`.portal`时，是从文件系统加载的而不是数据库中，解析`.portal`文件的`XML`，并将呈现的`.portal`返回到浏览器。**
将请求路径同时当作`file`路径传入，接着创建了`SAXParser`，准备将文件解析。
接着调用下方`getControlFactoryFromFile`，一直跟进，会从本地获取请求的文件.
**在这里目录穿越起了效果** ，获取到的文件也就是`webapp`下的`console.portal`。
并且以`WarSource`对象存入缓存
之后调用`sax`解析`xml`文件`console.portal`，并从中生成控制树，也就是`getTree`返回的`ControlTreeRoot`对象，然后存入`UIContext`。
#### 树的生命周期
控件树被构建后，就会进入生命周期的运行，回到`UIServlet#doPost`，调用`runLifecycle`，运行生命周期。
这里会根据`UIContext`里的两个值来判断执行`runInbound`还是`runOutbound`，后面细说
生命周期可以看作是控件上的一组方法，这些方法按定义的顺序调用。生命周期方法如下
    init()
    loadState()
    handlePostbackData()
    raiseChangeEvents()
    preRender() 
    saveState()
    render()  
    dispose() 
控件的具体解析流程如下
对应了调用栈里的调用，从ROOT开始，第一个子节点是`Desktop`，而接下来:
然后，深度优先遍历子节点。
当然，这个顺序也就是`console.portal`文件里的`xml`嵌套顺序。
因为是深度优先，在`console.portal`里的所有引用的`portal`文件也会按顺序解析，比如
直到所有标签解析完。
### CVE-2020-14883
接下来也就是造成代码执行的点，`com.bea.console.handles.HandleFactory` 要触发`getHandle`方法有两个触发点
#### 触发点一
回到之前创建`UIContext`的时候，有一个`setServletRequest`方法。
如果请求中存在`_nfpb=true`的时候，会把`postback`选项设置为`true`。
那么，之后在运行树的生命周期时，由于`outbound`选项默认`false`，而`postback`为`true`进入判断。
会调用`runInbound`方法，因为`runInbound`会把`types`设置为`_inboundLifecycle`。
`_inboundLifecycle`如下，注意不同的type对应了不同的静态类
当然，如果没有`_nfpb=true`，会调用`runOutbound`，`type`设置为`_outboundNewLifecycle`。
这决定了在深度遍历的时候先调用的方法，上面说过生命周期方法，于是这里就会先调用所有节点的`init`方法。因为在运行生命周期的时候，这里会调用`ControlTreeWalker#walk`方法，第一个参数，也就是`type[0]`，是`init`。
继续跟入`walkRecursive`方法
注意两处：
  1. 如果当前是`Root`节点，那么调用`visitRoot`，这个方法只会调用一次，如果不是，则调用当前`visit`的`visit`方法，当前`visit`也就是`type`里提到的静态类。`init`是`ControlLifecycle$1`，也就是第一个静态类，而这里的control就是当前节点。也就是说，如果当前`type`是`init`，深度解析所有节点的时候，都会把`init`方法调用一次。也就有了漏洞触发点`Portlet#init`。
  2. 调用完之后，如果深度遍历发现还有子节点，那么继续调用`walkRecursive`，重复`1`的步骤，直到所有节点解析完。
当调用到`Portlet`节点的`init`方法时，会一直调用`super.init`。
调用栈：
直到`AdministeredBackableControl#init`，会调用`initializeBackingFile`
最终会调用到`BreadcrumbBacking#init`，而这里会获取请求中的`handle`参数，调用`getHandle`方法。
#### 触发点二
在调用完`init`之后，会根据`type`里的顺序，继续调用生命周期方法（都对应着`ControlLifecycle`里的`visitor`）。
如果是`_nfpb=true`，调用完`runInbound`->`runOutbound`
由于`postback`为`true`。
之后流程类似，不过调用的`visitor`最开始是`ControlLifecycle#preRenderVisitor`
在调用到`StrutsContet`节点的时候，这个是在解析到引用`PortalConfig/contentheader/ContentHeader_messages.portlet`的时候。
这时候会调用`preRenderVisitor#preRender`，`preRenderVisitor`没有该方法，去父类`NetuiContent#preRender`。
并且在文件里会设置`action/refreshAction`为`MessagesAction`。
后续调用栈：
当然，不止`StrutsContet`节点会调用到这里，还有`Book`,`Portlet`节点，而在深度遍历的时候，会有很多`Book`,`Portlet`,`StrutsContet`的子节点，于是就会执行`getHandle`很多次，这也是为什么在使用计算器进行poc测试的时候，会多次弹出的原因。
最终的利用结果如下：
### 总结
  1. 通过静态资源来绕过权限验证，防止被重定向到登陆界面。
  2. 通过请求`.portal`，控制处理的`Servlet`是渲染`UI`的`MBeanUtilsInitSingleFileServlet`。
  3. 通过编码后的`../`，让最终渲染的模版是`console.portal`。
综合起来，才造成了最终的未授权访问。
## 0x05 时间线
**2020-10-21** 360CERT发布Oracle补丁日通告
**2020-10-28** 360CERT监测到POC公开
**2020-10-29** 360CERT发布通告
**2020-11-05** 360CERT发布分析
## 0x06 参考链接
  1. [White Paper: WebLogic Portal Framework](https://docs.oracle.com/cd/E13218_01/wlp/docs81/whitepapers/netix/body.html)
  2. [CVE-2020-14882/14883: Weblogic ConSole HTTP 协议代码执行漏洞POC公开通告](https://cert.360.cn/warning/detail?id=1809357283e3a9bb3af3d8b9cbea70d2)