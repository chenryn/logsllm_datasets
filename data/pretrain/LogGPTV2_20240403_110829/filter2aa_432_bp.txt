低字节在后
带符号整数格式
补码
补码
补码
32 位浮点数
64 位浮点数
支持
支持
支持
支持
浮点数格式
IEEE
IEEE,VAX
IBM 或 Cray
字符类型
ASCII
16 位 NS
ASCII 或
EBCDIC
枚举
结构(记录)
固定长一维数组
变长一维数组
固定长多维数组
变长多维数组
联合
固定长隐含数组
变长隐含数组
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
注：空表示不支持
所有这三种均使用隐含类型，也就是说，通过网络传送的只是变量的值而不是变量的
类型。而成为 ASNI 的 ISO 数据表示技术使用的是显式类型，在发送每个域值的同时也发
送消息中每个数据域的类型，
例如，当 Courier 发送一个 32 位 整数值时，不管是作为一个过程参数还是作为一个过
程的结果，只有该 32 位值在网络上传送。而 ASNI 则会传送一个 8 位字节，指明下一个值
是一个整数，其后所跟的另一个字节说明该整数域的长度（字节数），然后再跟一个，两个，
甚至五个字节的实际整数值。
12.5.2   Sun RPC
这里描述的版本是“ RPCSRC3.9”，实际的 RPC 协议是 Version 2。Sun RPC 由以下几
个部分组成：
Rpcgen，该部分是定义远程过程接口、产生 client stub 和 sever stub 的编译器。
XDR（外部数据表示），是使在不同系统间可移植的方式编码数据的标准方法。
12.5.3   Xerox Courier
Courier 既是协议又是一个说明语言，它主要用于 UNIX 和其他 Xerox 系统通知如 Xerox
打印服务器或 Xerox 文件服务器。
现在使用 Courier 给出前一节中的客户和服务器程序，我们必须编写三段代码：
RPC 说明，用 Courier 语言
客户程序，用 C 语言
服务器程序，用 C  语言
Courier 远程过程以三种方法返回：
常规返回
远程过程拒绝执行的拒绝返回
远程过程产生的中止返回
第十二章  远程过程调用
- 255 -
在上面的例子中是常规返回，拒绝返回和中止返回可由客户程序处理，如果客户程序
不处理这些错误，则会终止客户程序。
我们现在讨论使用 Courier 执行一远程过程的步骤。支持 courier RPC 的任何 UNIX 系
统必须运行一个守护进程以在一公认的 SPP 端口（端口 5）上监听客户进程的连接请求，
在编译和连接了服务器程序之后，我们应当告知 Courier 守护进程某服务器可以被激活，为
此，我们必须在文件 /etc/Courierservices 中增加一项以指明所执行文件的程序号、版本号
和路径名。
Xnscourierd 守护进程通常是在系统启动时启动的，其执行步骤如下：
客户调用 CourierOpen 打开与指定主机的连接，由此建立起与远程主机上端口 5
的 spp 连接，在此端口上 xnscourierd 进程监听客户请求。
守护进程产生一个子进程来处理该连接，子进程从连接上读出前几个字节确认是
一个 Courier 客户后，等待其发出 RPC 请求，指明被调用的程序，版本和过程。
客户调用 Bindate 函数的时候，client stub 向连接写入合适的程序号、版本号和过
程号。
子进程从连接读出这个信息，然后读文件 / etc / Courierservices 以确定执行哪个服
务器程序，接着由子进程执行相应的服务器程序。注意，子进程已经从连接读取了过程号，
在调用服务器程序时必须将此过程号传递给服务器程序，这个过程号是以 exec 命令行中的
形式传递给服务器程序的，由服务器程序中的 server stub 确定要调用哪两个远程过程。
启动 dateserver 程序，由 server stub 的 main 函数处理其命令行参数以确定调用哪
个远程过程，然后调用 BinDate 函数，函数返回时，server stub 将结果转换成 Courier 标准
形式并将它们送回客户。
接着客户进程调用 StrDate 函数。Client stub 通过连接发送程序号、版本号和过程
号，dateserver 进程中的 server stub 职别到程序和版本没有改变，就调用 StrDate 函数，调
用前 server stub 从连接读取参数并将它们从 Courier 格式转化成函数要求的格式；若是一不
同程序或不同版本的请求，server stub 就 必须执行对应的程序来处理这一新的请求。
函数返回 server stub 的时候，它转换返回值并将它们发送回客户，最后由客户调
用 Courier Close 关闭 SPP 连接，服务器进程正常终止。
Courier 为客户和服务器之间的网络连接使用的是 XNS 顺序分组协议（SPP），因为这
是一个面向连接的协议，故对客户和服务器之间交换的数据量没有限制。Courier 使用 SPP
头中的消息结束标志以及数据流类型域。
12.5.4   Apollo RPC
网络计算体系机构（NCA）是 Apollo 的远程计算系统结构，尽管此体系结构已公开发
表，但称之为 NCS （Network Computing System ）的 Apollo 仍是一特权产品。NCS 分为
以下几部分：
NIDL（网络接口定义语言。有一个编译器将此语言转化为 server stub 和 client stub。
NDR （网络数据表示），它定义了传递所支持的数据类型所使用的标准形式。
运行时间库。
NCA RPC 允许任意数目的参数和返回值，我们可以指定每个参数是输入（从客户传递
给服务器），输出（从服务器返回给客户）或既是输入又是输出。
Apollo RPC 运行于非连接的传递协议，通常使用的是 UDP 或 DDS （Appolo 的特权
网络协议）。如果网络消息太长而不能放入一个网络分组中时，Apollo 实现要对网络消息进
行分段和组装，UDP 的上限是 64K 字节，而 Xerox IDP 的上限是 546 字节。
实现使用的是完全的套接字地址，而不只是某个协议的端口号，并且标识特定服务器
的客户句柄含有服务器的整个套接字地址，也就是说能够以与协议无关的方式向客户进程
- 256 -
Linux网络编程
写，因为完全的套接字地址是每个调用的句柄的一部分，客户在将其句柄加载到特定服务
器之前不需要知道正在使用什么传送协议，即便句柄加载的一个服务器，句柄对客户进程
来说也是一个非透明的结构。
12.6  stub 过程简介
在我们将一个传统程序改写成 RPC 程序时，我们为了实现 RPC 而加入程序的附加过
程被称为 stub 过程。理解 stub 过程的最简单的方法是设想一个传统的程序，它被分割成两
个程序，一个已有的过程被转移到一个远程机器中。在远程过程（服务器）一端，stub 过
程取代了调用者。这 stub 实现了远程过程调用所需要的所有的通信。因为 stub 与原来的
调用使用了一样的接口，因此，增加这些 stub 既不要求更改原来的调用过程，也不要求
更改原来的被调用过程。图 12-5 展示了 stub 的概念，它说明了 stub 这个过程是怎样分离
出本地过程和远程部分的。
图 12-5  stib 过程
12.7  rpcgen 简介
因为实现一个 RPC 服务器所需要的多数代码是不变的，例如，如果远程过程过程号与
客户机端 stub 过程之间的映射被保存在一个数据结构中，那么所有的服务器都可以使用相
同的分派进程。与此类似，所有的服务器都可以使用相同的代码来向端口映射器注册。
为了避免不必要的编程，ONC RPC 的实现包含一个工具，它自动生成实现一个分布市
程序所需要的大部分代码。这个工具叫做 rpcgen，它读取一个规格说明文件作为输入，生
成 C 的源程序作为输出。规格说明文件包含常量，全局数据类型，全局数据，以及远程（过
程包括过程参数和结果类型）的声明。Rpcgen 产生的代码包含了实现客户机和服务器（它
提供指明的远程过程调用）程序所需要的大部分源代码。具体的说，rpcgen 为客户机端和
服务器端生成 stub 过程，它包括参数整理，RPC 报文，把调用分配到正确的过程，发送应
答，在参数和结果的外部表示和本地数据表示之间进行转换。Rpcgen 的输出在与一个应用
程序和程序员编写少数文件相结合后，便产生了完整的客户机和服务器程序。
RPC 是一个使用性很广的概念。一个程序远可以使用 RPC 来帮助指明或实现一个分布
式程序。在使用 ONC RPC 时，程序员可以选择各种方式，如，在白手起家构建代码时按
照 RPC 的规格说明进行，使用在 RPC 库中所找到的过程，或者使用一个称为 rpcgen 的程
加入到程序中的 stub 过程实现了一个远程过程调用。因为 stub 与原来的
调用使用了一样的接口，因此，增加这些 stub 既不要求更改原来的调用过
程，也不要求更改原来的被调用过程。
第十二章  远程过程调用
- 257 -
序自动生成工具。
在下面的几节中，我们将通过一个例子来讲解 RPC 的具体使用。
12.8  分布式程序生成的例子
我们下面举一个例子来看看 rpcgen 是如何工作的。
下面的程序是一个简单的查找字典的程序。该字典提供四个基本操作：
初始化（initialize），它初始化数据库（既清除以前存储的所有信息）；
插入（insert），它插入一条新的信息；
删除（delete），它删除一个条目；
查找（look up），它寻找某个条目。
我们假设数据库中的每一个条目都是单个的单词，接着使用数据库来检查新单词，以
便知道没个单词是否在字典中。输入的指令我们定义为每行包含一个单字母的命令，后面
跟着一个单词参数。表 12-2 为我们命令参数的说明表：
表 12-2  命令参数说明
单字母命令
参数
含义
 I
无
通过删除所有单词来初始化数据库
 I
Word
把 word 插入到数据库中
 D
Word
把 word 从数据库中删除
 L
Word
在数据库中查找 word
 Q
无
退出
我们可以通过 I 命令先初始化数据库，然后使用 i 命令来插入几个单词，通过 l 命令来
查找数据库中是否存在。
12.8.1  我们如何能够构造出一个分布式应用程序
作为一个程序员，我们可以按照下面的顺序来编写分布式应用程序：
 构建一个解决该问题的常规应用程序
 选择一组过程，以便将这些过程转移到一个远程机器中，通过这个方法将程序分解。
 为远程过程程序编写一个 rpcgen 规格说明，包括远程过程调用的名字极其编号，还
有对其参数的声明。选择一个远程程序号和一个版本号（通常为 1 ）。
 运行 rpcgen 来检查该规格说明，如何合法，便生成四个源代码文件，这些文件将在
客户机和服务器程序中使用。
 为客户机端和服务器端编写 stub 接口例程。
 编译并连接客户机程序。它主要由四个主要文件构成：最初的应用程序（远程过程
被从中删除了的那个），客户机端的 stub （由 rpcgen 生成），客户机端的接口 stub 以及 XDR
过程（由 rpcgen 生成）。当所有的文件都被编译和连接到一起后，最终的可执行的程序就
是客户机。
 便宜并链接服务器程序。它由四个重要文件构成：由最初的应用程序得来的过程，
他们现在构成了远程程序，服务器端的 stub （由 rpcgen 生成），服务器端的借口 stub 以及
XDR 过程（rpcgen 生成的）。当所有的这些文件被编译和链接到一起后，最终的可执行程
序就是服务器。
 在远程机器上启动服务器，在本地机器上启动客户机。
下面我们将详细的解释每一个步骤。
1．构建一个常规的应用程序
要构建这个字典应用例子，我们首先来写出实现这个字典的常规版本。
/* dict.c 包含 main，initw，netxin，insertw，deletew，lookupw 函数 */
- 258 -
Linux网络编程
#include 
#include 
#include 
#include 
/* 每一个输入的命令的最大长度 */
#define MAXWORD 50
/* 整个字典中可以包含的最多字数 */
#define DICTSIZ 100
/* 字典的数据存取数组 */
char dict[DICTSIZ][MAXWORD+1] ;
/* 字典中字母数 */
int
nwords = 0 ;
int nextin ( char* cmd, char* word) ;
int initw() ;
int insertw ( const char* word ) ;
int deletew ( const char* word ) ;
int lookupw ( const char* word ) ;
/* 主函数,进行各种操作 */
int main ( int argc, char* argv[] )
{
/* 从命令行取得命令的变量 */
char word [ MAXWORD + 1 ] ;
char cmd ;
/* 输入单词的长度 */
int
wrdlen ;
while ( 1 )
{
wrdlen = nextin ( &cmd, word ) ;
if ( wrdlen < 0 )
{
exit ( 0 ) ;
}
switch ( cmd )