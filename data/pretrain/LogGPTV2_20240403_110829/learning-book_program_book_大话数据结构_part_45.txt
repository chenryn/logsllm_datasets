### 斐波那契查找算法详解

#### 8.4 斐波那契查找
斐波那契查找是一种基于斐波那契数列的有序查找算法。它通过将数据集划分为不同的区间，利用斐波那契数列来确定每次查找的中间位置，从而提高查找效率。

##### 8.4.1 查找过程示例
- **图8-4-10**：在某次循环中，`mid = 1 + F[6-1] - 1 = 5`。此时`a[5] = 47`，小于`key`，因此执行第16~17行代码，更新`high = 6`，`k = 4 - 1 = 3`。
- **图8-4-12**：再次循环时，`mid = 6 + F[3-1] - 1 = 6`。此时`a[6] = 59`等于`key`，执行第26~27行代码，返回值为6，程序结束。

如果`key = 99`，第一次循环时`mid = 8`，与上例相同；第二次循环时`mid = 11`。如果`a[11]`不存在，会导致比较失败。为了避免这种情况，第9~10行的代码起到了关键作用。

##### 8.4.2 算法核心
斐波那契查找的核心在于：
1. 当`key == a[mid]`时，查找成功。
2. 当`key < a[mid]`时，新的查找范围是第`m+1`个到第`high`个元素，范围大小为`F[k-2] - 1`。
3. 当`key > a[mid]`时，新的查找范围是第`low`个到第`m-1`个元素，范围大小为`F[k-1] - 1`。

这种划分方法使得每次查找都能有效地缩小范围，提高查找效率。尽管斐波那契查找的时间复杂度为`O(log n)`，但其平均性能通常优于折半查找。然而，在最坏情况下（如`key = 1`），斐波那契查找可能不如折半查找高效。

##### 8.4.3 运算复杂度
- 折半查找：`mid = (low + high) / 2`，涉及加法和除法。
- 插值查找：`mid = low + (high - low) * (key - a[low]) / (a[high] - a[low])`，涉及四则运算。
- 斐波那契查找：`mid = low + F[k-1] - 1`，仅涉及简单的加减法。

对于海量数据，这种细微的运算差异可能会影响最终的查找效率。因此，在实际应用中，应根据数据特点综合考虑选择合适的查找方法。

### 8.5 线性索引查找
线性索引是一种用于加快查找速度的数据结构，特别适用于大型数据集。我们主要介绍三种线性索引：稠密索引、分块索引和倒排索引。

#### 8.5.1 稠密索引
稠密索引是指每个记录都对应一个索引项。例如，家中的物品虽然无序，但通过一个小本子记录每个物品的位置，可以快速找到所需物品。稠密索引的优点是可以使用折半、插值等有序查找算法，提高查找效率。然而，当数据集非常大时，稠密索引会占用大量内存，导致频繁访问磁盘，降低查找性能。

#### 8.5.2 分块索引
分块索引通过将数据集分成若干块，并对每块建立一个索引项来减少索引项的数量。分块索引的特点包括：
- 块内无序，块间有序。
- 每个索引项包含最大关键字、块长和指向块首的指针。

查找过程分为两步：
1. 在分块索引表中查找目标关键字所在的块。
2. 在块内顺序查找目标关键字。

分块索引在保证一定查找效率的同时，减少了索引项的数量，适用于大规模数据集。

#### 8.5.3 倒排索引
倒排索引是一种常用的搜索引擎技术。它通过构建一个单词表，记录每个单词在哪些文档中出现，从而实现高效的文档检索。例如，对于两篇英文文章，我们可以构建一个单词表，记录每个单词在哪些文章中出现。这样，当用户输入查询关键字时，系统可以在单词表中快速定位相关文章。

如果没有倒排索引，系统需要逐篇文档进行扫描，效率极低。倒排索引通过预先处理和存储信息，显著提高了检索速度。

总之，不同的索引方法各有优劣，实际应用中应根据数据特点和需求选择合适的方法。