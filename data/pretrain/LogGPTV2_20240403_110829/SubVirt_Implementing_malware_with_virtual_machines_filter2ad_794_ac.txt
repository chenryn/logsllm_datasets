ence of a VMM. To defeat this detection technique, we
use virtual-machine introspection to emulate the sidt
instruction when it is called by the redpill application.
To emulate this instruction, we interpose on the Win-
dows XP kernel function that maps executable ﬁles into
the address space of a process. When this function ex-
ecutes, we determine if the redpill executable is being
loaded. If it is, we set a breakpoint at the sidt instruc-
tion and emulate it when the target traps to the VMM.
This countermeasure could be defeated by a program
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
that generates the sidt instruction dynamically. Con-
tinuing the arms race, a more advanced countermea-
sure could trace the execution of guest software, using
binary translation techniques, to detect and emulate
all sidt instructions, but this might add overhead to
the system which could be detected. Implementing the
redpill detection countermeasure required adding 104
lines of code to the Virtual PC VMM.
3.4. Maintaining control
To avoid being removed, a VMBR must protect its
state by maintaining control of the system. As long as
the VMBR controls the system, it can thwart any at-
tempt by the target to modify the VMBR’s state. The
VMBR’s state is protected because the target system
has access only to the virtual disk, not the physical
disk.
The only time the VMBR loses control of the system
is in the period of time after the system powers up until
the VMBR starts. Any code that runs in this period
can access the VMBR’s state directly. The ﬁrst code
that runs in this period is the system BIOS. The system
BIOS initializes devices and chooses which medium to
boot from. In a typical scenario, the BIOS will boot
the VMBR, after which the VMBR regains control of
the system. However, if the BIOS boots a program on
an alternative medium, that program can access the
VMBR’s state.
Because VMBRs lose control when the system is
powered oﬀ, they may try to minimize the number
of times full system power-oﬀ occurs. The events
that typically cause power cycles are reboots and shut-
downs. VMBRs handle reboots by restarting the vir-
tual hardware rather than resetting the underlying
physical hardware. By restarting the virtual hardware,
VMBRs provide the illusion of resetting the underlying
physical hardware without relinquishing control. Any
alternative bootable medium used after a target reboot
will run under the control of the VMBR.
In addition to handling target reboots, VMBRs can
also emulate system shutdowns such that the system
appears to shutdown, but the VMBR remains running
on the system. We use ACPI sleep states [3] to emulate
system shutdowns and to avoid system power-downs.
ACPI sleep states are used to switch hardware into a
low-power mode. This low-power mode includes spin-
ning down hard disks, turning oﬀ fans, and placing
the monitor into a power-saving mode. All of these
actions make the computer appear to be powered oﬀ.
Power is still applied to RAM, so the system can come
out of ACPI sleep quickly with all memory state intact.
When the user presses the power button to “power-up”
the system, the computer comes out of the low-power
sleep state and resumes the software that initiated the
sleep. Our VMBR leverage this low-power mode to
make the system appear to be shutdown; when the user
“powers-up” the system by pressing the power button
the VMBR resumes. If the user attempts to boot from
an alternative medium at this point, it will run under
the control of the VMBR. We implemented shutdown
emulation for our VMware-based VMBR.
ACPI sleep states provide a fairly good illusion of
system shutdown, but some systems have visible dif-
ferences while in low-power mode. Speciﬁcally, some
power LEDs behave diﬀerently while in low-power
mode than when the system is shut down.
In all of
the systems we surveyed, the power LED was turned
oﬀ when the system was shutdown. When in low-power
mode, some LEDs turned oﬀ by default, some power
LEDs could be turned oﬀ using BIOS functions, and
others blinked or changed colors. Astute computer
users might notice a diﬀerence in the power LED af-
ter an emulated shutdown, but average computer users
probably would not. Furthermore, many computer
users rarely shutdown their systems.
4. Evaluation
This section evaluates the impact of a VMBR on a
system. We evaluate the disk space used by a VMBR,
the time to install a VMBR, the eﬀect of a VMBR on
the time to boot the target OS, the impact of a VMBR
as viewed by a user, and the eﬀect of the memory space
used by a VMBR.
All experiments for the VMware-based VMBR run
on a Dell Optiplex Workstation with a 2.8 GHz Pen-
tium 4 and 1 GB of RAM. All experiments for the Vir-
tual PC-based VMBR run on a Compaq Deskpro EN
with a 1 GHz Pentium 4 and 256 MB of RAM. Our
VMware-based VMBR compromises a RedHat Enter-
prise Linux 4 target system, and our Virtual PC-based
VMBR compromises a Windows XP target system.
We ﬁrst measure the disk space required to install
the VMBR. Our Virtual PC-based VMBR image is 106
MB compressed and occupies 251 MB of disk space
when uncompressed. Our VMware-based VMBR im-
age is 95 MB compressed and occupies 228 MB of disk
space uncompressed. The compressed VMBR images
take about 4 minutes to download on a 3 Mb/s cable
modem connection and occupy only a small fraction of
the total disk space present on modern systems. We
made some eﬀort to minimize the amount of persis-
tent storage needed for both VMBRs, but we believe
that the images could be made much smaller with ad-
ditional eﬀort. For example, ttylinux [5] is a Linux
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
Target Boot Target Boot
Target Boot
Without
VMBR
Installation
After
Emulated
Reboot
After
Emulated
Shutdown
Host Boot +
Host Boot Target Boot
After
After
Power-Oﬀ
Power-Oﬀ
VMware-Based
VMBR
(Linux Target)
Virtual PC-Based
VMBR
(Windows XP Target)
24
262
53
23
74
54
96
N/A
52
45
145
101
Table 1. VMBR installation and boot times (all times are in seconds). This table shows the installation
and boot times for our Virtual PC-based and VMware-based VMBRs. As a reference point for our boot
time measurements, we boot the system when it was not infected with a VMBR. We then measure
the boot time after installing a VMBR for a number of different scenarios. All measurements are the
average of three runs and have a variance of less than 3%, except for our Virtual PC-based VMBR
install time which had a high variance because the system memory was almost completely used by
the VMBR image. We did not implement shutdown emulation for the Virtual PC-based VMBR.
distribution that occupies only a few megabytes of disk
space, yet still includes device support for a range of
hardware.
We next measure the time it takes to install a VMBR
and the eﬀect of the VMBR on the time to boot a
target system. Table 1 summarizes the results from
our evaluation.
The installation measurements include the time it
takes to uncompress the attack image, allocate disk
blocks, store the attack ﬁles, and modify the system
boot sequence. Installation time for the VMware-based
VMBR is 24 seconds. Installation for the Virtual PC-
based VMBR takes longer (262 seconds) because the
hardware used for this test is much slower and has less
memory. In addition, when installing a VMBR under-
neath Windows XP, we swap the contents of the disk
blocks used to store the VMBR with those in the be-
ginning of the Windows XP disk partition, and these
extra disk reads/writes further lengthen the installa-
tion time.
We next measure boot time, which we deﬁne as the
amount of time it takes for an OS to boot and reach
an initial login prompt. Booting a target Linux system
without a VMBR takes 53 seconds. After installing
the VMware-based VMBR, booting the target system
takes 74 seconds after a virtual reboot and 96 seconds
after a virtual shutdown. It takes longer after a virtual
shutdown than after a virtual reboot because the VMM
must re-initialize the physical hardware after coming
out of ACPI sleep. In the uncommon case that power
is removed from the physical system, the host OS and
VMM must boot before loading the target Linux OS.
The VMware-based VMBR takes 52 seconds to boot
the host OS and load the VMM and another 93 sec-
onds to boot the target Linux OS. We speculate that
it takes longer to boot the target OS after full system
power-down than after a virtual reboot because some
performance optimizations within the VMware VMM
take time to warm up.
Booting a target Windows XP system without a
VMBR takes 23 seconds. After installing the Virtual
PC-based VMBR, booting the target system takes 54
seconds after a virtual reboot.
If power is removed
from the physical system, the Virtual PC-based VMBR
takes 45 seconds to boot the host OS and load the
VMM and another 56 seconds to boot the target Win-
dows XP OS.
Once the target system runs, a user will see few dif-
ferences between a target OS running directly on hard-
ware and a target OS running above a VMBR. Virtual
machines have been shown to have little performance
impact on the system [10], and the video resolution,
user interface, and interactivity of the system are un-
aﬀected by the VMBR. To achieve this level of perfor-
mance, we used specialized drivers within the target
OS. Speciﬁcally, we installed Virtual PC Guest Addi-
tions [34] and VMware Guest Tools [4] as part of our
VMBR installation. Despite using specialized guest
drivers, our current proof-of-concept VMBRs use vir-
tualized video cards which may not export the same
functionality as the underlying physical video card.
Thus, some high-end video applications, like 3D games
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
or video editing applications, may experience degraded
performance.
The physical memory allocated to the VMM and
attack OS is a small percentage of the total memory
on the system (roughly 3%) and thus has little per-
formance impact on a target OS running above the
VMBR. Our VMware-based VMBR presents the target
OS with the same amount of memory as is present on
the physical system, and it uses paging to compensate
for any memory allocated to the attack OS and VMM.
To measure the overhead of this paging mechanism, we
use a benchmark that randomly touches pages within
the target OS. To avoid content-based page sharing [47]
between the attack OS and the target OS, we use dif-
ferent kernel versions for both, and we ﬁll unused pages
within the target OS with random data to avoid shar-
ing zero pages 2. We then randomly access pages within
the target OS, using working set sizes ranging from 10
MB to the entire physical memory of the computer.
Our tests found that the average access time was equal
across all working set sizes; thus we conclude that pag-
ing target OS memory results in minimal performance
impact for our VMware-base VMBR. Our Virtual PC-
based VMBR reserves approximately 100 MB of phys-
ical memory for the attack OS and VMM and presents
the target with less physical memory than is available
on the system.
5. Defending against virtual-machine
based rootkits
In this section, we explore techniques that can be
used to detect the presence of a VMBR. VMBRs are
fundamentally more diﬃcult to detect than traditional
malware because they virtualize the state seen by the
target system and because an ideal VMBR modiﬁes no
state inside the target system. Nonetheless, a VMBR
does leave signs of its presence that a determined in-
trusion detection system can observe. We classify the
techniques that be used to detect a VMBR by whether
the detection system is running below the VMBR, or
whether the detection system is running above the
VMBR (i.e., within the target system).
5.1. Security software below the VMBR
The best way to detect a VMBR (indeed, any mal-
ware) is to run at a layer that is not controlled by the
VMBR. Detectors that run below the VMBR can see
the state of the VMBR because their view of the system
2Zero pages are pages within the OS that are completely ze-
roed out.
does not go through the VMBR’s virtualization layer.
Such detection software can read physical memory or
disk and look for signatures or anomalies that indicate
the presence of a VMBR, such as a modiﬁed boot se-
quence. Other low-level techniques such as secure boot
[9] can ensure the integrity of the boot sequence and
prevent a VMBR from gaining control before the target
OS.
There are various ways to gain control below the
VMBR. One way to gain control below the VMBR is