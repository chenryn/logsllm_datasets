# tracer: nop    
#    
#                              _-----=> irqs-off    
#                             / _----=> need-resched    
#                            | / _---=> hardirq/softirq    
#                            || / _--=> preempt-depth    
#                            ||| /     delay    
#           TASK-PID   CPU
#  ||||    TIMESTAMP  FUNCTION    
#              | |       |   ||||       |         |             systemd-1     [011] .... 17133447.451839: do_sys_open: "/proc/22597/cgroup" 88000 666                bash-4118  [009] .... 17133450.076026: do_sys_open: "/" 98800 0         salt-minion-7101  [010] .... 17133450.478659: do_sys_open: "/etc/hosts" 88000 666     systemd-journal-2199  [011] .... 17133450.487930: do_sys_open: "/proc/6989/cgroup" 88000 666     systemd-journal-2199  [011] .... 17133450.488019: do_sys_open: "/var/log/journal/d4f76e4bf5414ac78e1c534ebe5d0a72" 98800 0     systemd-journal-2199  [011] .... 17133450.488080: do_sys_open: "/proc/6989/comm" 88000 666     systemd-journal-2199  [011] .... 17133450.488114: do_sys_open: "/proc/6989/cmdline" 88000 666     systemd-journal-2199  [011] .... 17133450.488143: do_sys_open: "/proc/6989/status" 88000 666     systemd-journal-2199  [011] .... 17133450.488185: do_sys_open: "/proc/6989/sessionid" 88000 666    …请注意，Tracepoint 是在内核中固定的 hook 点，并不是在所有的函数中都有tracepoint。比如在上面的例子里，我们看到 do_sys_open() 调用到了do_filp_open()，但是 do_filp_open() 函数里是没有 tracepoint的。那如果想看到 do_filp_open() 函数被调用的频率，或者 do_filp_open()在被调用时传入参数的情况，我们又该怎么办呢？这时候，我们就需要用到 kprobe 了。kprobe可以动态地在所有的内核函数（除了 inline 函数）上挂载 probe函数。我们还是结合例子做理解，先看看 perf 和 ftraces 是怎么利用 kprobe来做调试的。比如对于 do_filp_open()函数，我们可以通过`perf probe`添加一下，然后用`perf stat` 看看在 10秒钟的时间里，这个函数被调用到的次数。    
# perf probe --add do_filp_open    
# perf stat -a -e probe:do_filp_open -- sleep 10          Performance counter stats for 'system wide':                         11      probe:do_filp_open               10.001489223 seconds time elapsed我们也可以通过 ftrace 的 tracefs 给 do_filp_open() 添加一个 kprobeevent，这样就能查看 do_filp_open()每次被调用的时候，前面两个参数的值了。这里我要给你说明一下，在写入 kprobe_event的时候，对于参数的定义我们用到了"%di"和"%si"。这是 x86处理器里的寄存器，根据 x86 的Application Binary Interface的文档  slate-object="inline"，在函数被调用的时候，%di 存放了第一个参数，%si存放的是第二个参数。    
# echo 'p:kprobes/myprobe do_filp_open dfd=+0(%di):u32 pathname=+0(+0(%si)):string' > /sys/kernel/debug/tracing/kprobe_event完成上面的写入之后，我们再 enable 这个新建的 kprobe event。这样在trace 中，我们就可以看到每次do_filp_open（）被调用时前两个参数的值了。    