# Link State Routing and Data Packet Forwarding

## Overview
- **E/2, E, B/1, D/2, F/4, F, C/2, E/4, G/1, G, C/5, F/1**

## Data Packets / Unicast
### Traditional Per-Destination Forwarding
- **Traditional per-destination forwarding is not sufficient:**
  - A malicious actor can disrupt the network by frequently changing the state of a link.
  - Handling a path that works for everyone except the source (S) is challenging.

### Conclusion
- The source (S) must choose its own path to ensure reliability.

## Source-Selected Path Setup
- **Source chooses a path:**
  - Sets up the path with a cryptographically signed setup packet, specifying the path.
  - Routers along the path maintain state for each (S, D) pair:
    - Input port
    - Output port
    - Buffers for data packets forwarded on this flow

## Unicast Forwarding
- **No cryptographic verification needed:**
  - Only an additional check to ensure the packet is coming from the expected port.
  - As long as the path is honest, no malicious switch off the path can disrupt the flow.

## Heuristics for Path Selection
- **Simple heuristics for S choosing a working path:**
  - If the path to D works (end-to-end acknowledgments), trust the routers along that path.
  - If the path doesn't work, be suspicious of the routers on that path.
  - Try to eliminate routers one at a time, but this can be expensive if there are many malicious actors.
  - This approach is not highly scalable due to the need for state and visibility of the entire path.

### Scalability Improvements
- **Recent work addresses scalability issues:**
  - Perlman, R., Kaufman, C. "Byzantine Robustness, Hierarchy, and Scalability," IEEE Conference on Communications and Network Security, CNS 2013.

## Resilience
- **Source has control over its fate:**
  - No need for agreement among multiple parties.
  - Malicious trusted nodes (TNs): Use multiple TNs and vote, or reserve resources for any public key advertised. Malicious TNs cannot use more than half the resources and will be quickly detected.

## Example 3: Data Management
- **Making data available when needed and ensuring it is deleted when required.**

## Resilient Expiring Data
- **Paper: "File System Design with Assured Delete"**
  - [Link to Paper](https://www.isoc.org/isoc/conferences/ndss/07/papers/file_system_assured_delete.pdf)

## Expiration Time
- **Metadata includes an optional expiration date:**
  - After the expiration date, the data must be unrecoverable, even though backups may still exist.

### Obvious Approach
- **Encrypt the data and destroy the keys:**
  - To avoid premature data loss, make multiple copies of the keys.
  - Ensuring all copies of expired keys are destroyed is challenging.

### First Concept
- **Encrypt all files with the same expiration date using the same key.**

### File System with Master Keys
- **Master keys:**
  - Secret keys (e.g., AES) generated by the storage system.
  - Delete the key upon expiration.

#### Example
- **Master keys:**
  - S1: Jan 7, 2016
  - S2: Jan 8, 2016
  - S3: Jan 9, 2016
  - ...
  - File: Exp 01/08/16, Encrypted with S2

### Number of Keys
- **If the granularity is one key per day for a maximum of 30 years, 10,000 keys are needed.**

### Backup of Master Keys
- **How to back up master keys?**

### Ephemerizer Service
- **Ephemerizer:**
  - Creates, advertises, protects, and deletes public keys.
  - Storage system "ephemerizes" each master key on backup by encrypting with the ephemerizer's public key.
  - To recover from backup, the storage system asks the ephemerizer to decrypt.

#### Publicly Posted Keys
- **Ephemerizer publicly posts:**
  - Jan 7, 2016: Public key PJan7of2016
  - Jan 8, 2016: Public key PJan8of2016
  - ...

### Backup of Keys
- **Notes:**
  - Only contact the ephemerizer if the hardware with master keys fails and you need to retrieve them from backup.
  - Ephemerizer is highly scalable:
    - Same public keys for all customers.
    - Interaction with customers is infrequent (every few years).

### Potential Issues
- **Ephemerizer can fail in two ways:**
  - Prematurely lose private keys.
  - Fail to delete private keys.

### Solutions
- **Allow the ephemerizer to be flaky and lose keys:**
  - Generate and decrypt keys on a tamper-proof module.
  - An honest ephemerizer should not make copies of its ephemeral private keys.

### Multiple Ephemerizers
- **Use multiple independent ephemerizers:**
  - Different organizations, countries, and continents.
  - Independent public keys.

### Blind Decryption
- **Protocol for blind decryption:**
  - Allows the file system to ask the ephemerizer to decrypt without revealing the content.
  - Efficient and lightweight, requiring minimal computation and communication.

### On-Demand Delete
- **Instead of master keys:**
  - Storage system keeps an "F-table" with a secret key for each expirable piece of data.
  - Adds keys to the F-table when new data is stored.
  - Deletes keys from the F-table when data is assuredly deleted.

### Ephemerizer State
- **For on-demand systems:**
  - Ephemerizer needs to keep two public keys for each customer file system:
    - Current public key (Pn)
    - Previous public key (Pn-1)

### Concerns
- **Suppose you change Pâ€™s every week:**
  - If the file system was corrupted a month ago, and parts of the F-key database were corrupted, you cannot go back.

### Pre-Determined Expiration Time
- **Advantages:**
  - If the file system is not corrupted when a file is created and backed up, unexpired files can be recovered from backup.
  - With on-demand schemes, if the file system gets corrupted, all data can be lost.

### Final Note
- **Three different problems with different solutions:**
  - Think about the case of misbehaving participants.

## Thank You!
- **End of Presentation**