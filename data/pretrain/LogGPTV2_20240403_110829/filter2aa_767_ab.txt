E/2
E
B/1
D/2
F/4
F
C/2
E/4
G/1
G
C/5
F/1
Link State Routing
65
Data Packets/unicast
• “Traditional” per-destination forwarding won’t 
work
– Bad guy can keep network in flux by flipping state 
of a link
– What do you do if path works for everyone but S?
66
Data Packets/unicast
• “Traditional” per-destination forwarding won’t 
work
– Bad guy can keep network in flux by flipping state 
of a link
– What do you do if path works for everyone but S?
• Conclusion:  Source has to choose its own 
path
67
Data packets
• Source chooses a path
• Sets it up with a cryptographically signed setup 
packet, specifying the path
• Routers along the path have to keep per (S,D) pair
– Input port
– Output port
– Buffers for data packet fwd’ed on this flow
68
Unicast Forwarding
• No crypto needed
• Just additional check “is it coming from 
expected port?”
• As long as path is honest, no malicious switch 
off the path can disrupt flow
69
Simple heuristics for S choosing a path 
that works for S
• If path to D works (end-to-end acks), then 
have more trust in routers along that path
• If path doesn’t work, be suspicious of the 
routers on that path
• Try to eliminate routers one at a time, but if 
lots of bad guys, can be really expensive
Note this isn’t too scalable
• Since every path requires state
• And requires source seeing entire path (which 
it can’t in hierarchical network)
• More recent work fixes that
– Perlman, R., Kaufman, C., “Byzantine Robustness, 
Hierarchy, and Scalability”, IEEE Conference on 
Communications and Network Security, CNS 2013.
70
Resilience
• Source has fate in its own hands: no need for 
“agreement”
• Malicious TN: have multiple and vote, or just 
reserve resources for any public key 
advertised (and malicious TN can’t use up 
more than ½ the resources, and will be quickly 
caught)
71
Example 3: Data: Making it be there 
when you want it, and making it go 
away when you want it gone
72
Resilient expiring data
• Paper “File System Design with Assured 
Delete”
https://www.isoc.org/isoc/conferences/ndss/07/papers/fi
le_system_assured_delete.pdf
73
Expiration time
• When create data, put (optional) 
“expiration date” in metadata
• After expiration, data must be 
unrecoverable, even though backups will 
still exist
74
Obvious approach
• Encrypt the data, and then destroy keys
• But to avoid prematurely losing data, you’d 
have to make lots of copies of the keys
• Which means it will be difficult to ensure all 
copies of backups of expired keys are 
destroyed
75
First concept: Encrypt all files with same 
expiration date with the same key
76
File system with Master keys
Master keys
S1 Jan 7, 2016
S2 Jan 8, 2016
S3 Jan 9, 2016
…
file
Exp 01/08/16
Encrypted
With S2
Master keys: Secret keys (e.g., AES)
generated by storage system
Delete key upon expiration
77
File system with Master keys
Master keys
S1 Jan 7, 2016
S2 Jan 8, 2016
S3 Jan 9, 2016
…
file
Exp 01/08/16
{K}S2
Encrypted
With K
Master keys: Secret keys (e.g., AES)
generated by storage system
Delete key upon expiration
78
How many keys?
• If granularity of one per day, and 30 years 
maximum expiration, 10,000 keys
79
So…how do you back up the master keys?
80
Imagine a service: An 
“ephemerizer”
• creates, advertises, protects, and deletes 
public keys
• Storage system “ephemerizes” each master 
key on backup, by encrypting with (same 
expiration date) ephemerizer public key
• To recover from backup: storage system 
asks ephemerizer to decrypt
81
Ephemerizer publicly posts
Jan 7, 2016:  public key PJan7of2016
Jan 8, 2016:  public key PJan8of2016
Jan 9, 2016:  public key PJan9of2016
Jan 10, 2016: public key PJan10of2016
etc
One permanent public key P certified through PKI
Signs the ephemeral keys with P
82
Storage system with Master keys
Master keys
S1 Jan 7, 2016
S2 Jan 8, 2016
S3 Jan 9, 2016
…
file
Exp 01/08/16
{K}S2
Encrypted
With K
Master keys: Secret keys (e.g., AES)
generated by storage system
83
Backup of Master Keys
Master keys
S1 Jan 7, 2016
S2 Jan 8, 2016
S3 Jan 9, 2016
…
Ephemerizer keys
P1 Jan 7, 2016
P2 Jan 8, 2016
P3 Jan 9, 2016
…
{S1}P1, Jan 7, 2016
{S2}P2, Jan 8, 2016
{S3}P3, Jan 9, 2016
…
file
Exp 01/08/16
{K}S2
Encrypted
With K
Encrypted with G
Sysadmin secret
84
Backup of keys
Notes
• Only talk to the ephemerizer if your hardware with 
master keys dies, and you need to retrieve master 
keys from backup
• Ephemerizer really scalable:
– Same public keys for all customers (10,000 keys for 30 
years, one per day)
– Only talk to a customer perhaps every few years…to 
unwrap keys being recovered from backup
85
But you might be a bit annoyed at this 
point
86
But you might be a bit annoyed at this 
point
• Haven’t we simply pushed the problem onto 
the ephemerizer?
• It has to reliably keep private keys until 
expiration, and then reliably delete them
87
Two ways ephemerizer can “fail”
• Prematurely lose private keys
• Fail to forget private keys
88
Two ways ephemerizer can “fail”
• Prematurely lose private keys
• Fail to forget private keys
• Let’s worry about these one at a time…first 
worry about losing keys prematurely
89
Losing keys prematurely
• We will allow an ephemerizer to be flaky, and 
lose keys
• Generate keys, and do decryption, on tamper-
proof module
• An honest ephemerizer should not make 
copies of its ephemeral private keys
• So…wouldn’t it be a disaster if it lost its keys 
when a customer needs to recover from 
backup?
90
Question:  How many copies of private 
keys should ephemerizer keep so you feel 
safe?
• Let’s say 20
91
The reason why it’s not just pushing the 
problem
• You can achieve arbitrary robustness by using 
enough “flaky” ephemerizers!
– Independent ephemerizers
• Different organizations
• Different countries
• Different continents
– Independent public keys
92
Use multiple ephemerizers!
Master keys
S1 Jan 7, 2016
S2 Jan 8, 2016
S3 Jan 9, 2016
…
Ephemerizer keys
P1 Jan 7, 2016
P2 Jan 8, 2016
P3 Jan 9, 2016
…
Q1 Jan 7, 2016
Q2 Jan 8, 2016
Q3 Jan 9, 2016
…
{S1}P1, {S1}Q1 Jan 7, 2016
{S2}P2, {S2}Q2 Jan 8, 2016
{S3}P3, {S3}Q3 Jan 9, 2016
…
file
Exp 01/08/16
{K}S2
Encrypted
With K
Encrypted with G
Sysadmin secret
93
Backup of keys
What if ephemerizer doesn’t destroy 
private key when it should?
• Then the storage system can use a quorum 
scheme (k out of n ephemerizers)
– Break master key into n pieces, such that a 
quorum of k can recover it
– Encrypt each piece with each of the n 
ephemerizers’ public keys
94
So, after disaster, 10,000 decryptions
• Not so bad, but we can do better
95
No reason keys have to be 
independent random numbers
• We could make day n+1 key one-way hash of 
day n key (or store it encrypted with day n’s 
key)
• Then we only need to ask for a single 
decryption after a disaster (the one closest to 
expiration)
• And we can locally derive the rest of the keys
96
Ephemerizer decryption protocol
• Protocol for asking ephemerizer to decrypt
– That doesn’t let the ephemerizer see what it’s 
decrypting
– Doesn’t require authentication of either end
– Super light-weight (can be one IP packet each 
direction, very little computation)
97
I’ll skip over how
• Because I’m sure we’ll be short on time
• But I’m leaving the slides there
98
What we want to accomplish
File system
Ephemerizer
Please decrypt {Si}Pi with key ID i
Si
Has {Si}Pi
use private key i
99
What we want to accomplish
File system
Ephemerizer
Please decrypt {Si}Pi with key ID i
Si
Has {Si}Pi
use private key i
But we don’t want the Ephemerizer to see Si
100
We’ll use “blind decryption”
• FS wants Eph to decrypt {Si}Pi with Eph’s private 
key #i
– … Without Eph seeing what it is decrypting
• FS chooses inverse functions
– “blind/unblind” (B, U)
• encrypts (blinds) with Blind Function, which 
commutes with Eph’s crypto
• Then FS applies U to unblind
101
Using Blind Decryption
File system
Ephemerizer
Please decrypt B{{Si}Pi} with key ID i
B{Si}
Has {Si}Pi
use private key i
File system applies U to get Si
Ephemerizer only sees B{Si}
Invents  functions (B,U) just for this conversation
102
Non-math fans can take a nap
103
For you math fans…
104
Quick review of RSA
• Public key is (e,n).  Private key is (d,n), where e 
and d are “exponentiative inverses mod n”
• That means Xed mod n=X
• Encrypt X with public key (e,n) means 
computing Xe mod n
105
Blind Decryption with RSA, Eph’s 
RSA PK=(e,n), msg=M
File System
Ephemerizer
wants to decrypt Me mod n
chooses R, computes Re mod n
Me Re   mod n
applies (d,n)
MedRed
M R  mod n
divides by R mod n to get plaintext M
106
Properties of our protocol
• Ephemerizer gains no knowledge when it is 
asked to do a decryption
• Protocol is really efficient: one IP packet 
request, one IP packet response
• No need to authenticate either side
• Decryption can even be done anonymously
107
OK, non-math fans can wake up now
108
Because of blind decryption
• The customer does not need to run its own 
Ephemerizers, or really trust the Ephemerizers 
very much
• Ephemeral key management can be 
outsourced
109
General philosophy
• Achieve robustness by lots of can-be-flaky 
components
• Failures are truly independent
– Different organizations
– Different administrators
– Independent clocks
110
In contrast, a non-resilient solution
111
People kept wanting “on-demand” 
delete
• And I kept arguing that it was not useful, and 
wouldn’t be scalable
112
People kept wanting “on-demand” 
delete
• And I kept arguing that it was not useful, and 
wouldn’t be scalable
• But then I realized how to do it
113
People kept wanting “on-demand” 
delete
• And I kept arguing that it was not useful, and 
wouldn’t be scalable
• But then I realized how to do it
• And think it’s a really bad idea
114
People kept wanting “on-demand” 
delete
• And I kept arguing that it was not useful, and 
wouldn’t be scalable
• But then I realized how to do it
• And think it’s a really bad idea
• And it’s useful to see both how to do it, and 
why it’s a bad idea
115
On-demand delete
116
Instead of master keys
• Storage system keeps “F-table”, consisting of a 
secret key for each (expirable) piece of data
• Adds key to F-table when new (expirable) data 
stored
• Deletes key from F-table when (expirable) 
data is assuredly-deleted
117
Ephemerizer state
• In time-based system, ephemerizer didn’t 
need to know its customers
• For the on-demand system, ephemerizer 
needs to keep two public keys for each 
customer file system
– current public key (Pn)
– previous public key (Pn-1)
118
File system with F-table
Volatile storage
F1, F2, F3, F4,
F5, …..
…..Fmillion
file
Ptr to F-table
Encrypted
With F2
F-table
119
File system with F-table
Volatile storage
F1, F2, F3, F4,
F5, …..
…..Fmillion
file
Ptr to F-table
Encrypted
With F2
F-table
Modify F-table when you assure-delete a file
Or create a new file
F-table has key for each file…if a million files, a million keys
120
File system with F-table
Volatile storage
F1, F2, F3, F4,
F5, …..
…..Fmillion
Ephemerizer keys
For client X
Pi-1
Pi
…
For client X
Qi-1
Qi
…
Local NV storage
file
Ptr to F-table
Encrypted
With F2
F-table snapshot encrypted
with Piand Qi
Remote NV storage
Older snapshot encrypted with 
Pi-1 and Qi-1
F-table
121
Sufficiently replicated for
robustness
So what’s wrong?
122
My concern
• Suppose you change P’s every week
• Suppose you find out that the file system 
was corrupted a month ago
• And that parts of the F-key database were 
corrupted, without your knowledge
• You can’t go back
123
Why isn’t pre-determined expiration 
time as scary?
• If file system is not corrupted when a file is 
created, and the file is backed up, and the 
S-table is backed up, you can recover an 
unexpired file from backup
• Whereas with the on-demand scheme, if 
the file system gets corrupted, all data can 
get lost
124
Note
• I’ve shown 3 very different problems, with 
very different solutions
• I’m not sure there is any one piece of advice 
other than “think about the case of 
misbehaving participants”
125
Thank you!
126