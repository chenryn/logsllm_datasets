check all branches in the e-NFA. For example, regex ^’(a+)*’$
contains a vulnerable subexpression (a+)*. Suppose this
subexpression matches a repeated string “aaaaaa...” of length
n, and its next subexpression ’ fails to match the following
symbol ‘b’, the regex engine would perform backtracking on
the already matched string “aaaaaa...”. Each symbol ‘a’ in
the repeated string can be matched with either the subexpression
(a+) of the outer quantifier *, or the subexpression a of the inner
quantifier +. Since the length of the repeated string is n, there
are 2n possible backtracking searches until the engine declares
a failure. In contrast, the NFA-based matching algorithm would
terminate immediately when it fails to match the symbol ‘b’
using linear time.
Nevertheless, only GO and Rust adopt NFA based matching
algorithm while sacrificing the support for some extended
features. Other popular languages, including JavaScript, Python,
Java, C++, C#, PHP, Perl, and Ruby, implement the e-NFA
based regex engines with super-linear worst-case complexity to
support extended regular expressions [11], which makes ReDoS
In general, ReDoS vulnerabilities are caused because the
worst-case time complexity of regex matching algorithm in
modern regex engines is super-linear with the length of input.
1Some extended features like “lookaround” can be simulated in a regular
language by treating its surrounding subexpressions as parts of the language,
so they are not considered as such features.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1469
a common problem.
B. Mitigation of ReDoS Attacks
ReDoS attacks are difficult to prevent because 1) developers
might write vulnerable regex patterns; and 2) regex engines
need to support backtracking and extended features. In practice,
developers lack tools to validate the security of regular expres-
sions they write, and focus on correctness while neglecting the
performance when writing regexes [32]. A survey [23] shows
that only 38% developers are aware of ReDoS attacks, and
even for those that know such problems, there is a lack of tools
or knowledge to help detect such vulnerabilities.
Regex engines can prevent ReDoS attacks by disabling
extended features that cannot be represented by context-free
grammar, but this can significantly limit their functionalities.
Alternatively, some engines limit the number of backtracking
searches (PHP and Perl) or set timeout (the .NET framework)
to stop ReDoS attacks [11]. However, it is difficult to configure
a limit that does not break legitimate regexes.
Recently, researchers focus on detecting vulnerable regexes.
In most of the cases, developers can change the vulnerable regex
to a vulnerability-free one while preserving the functionality. In
some other cases where attack strings that can trigger ReDoS
are under certain patterns (§IV-D), developers can filter such
patterns before sending the input string to the regex. Specifically,
there are two classes of approaches on detecting vulnerable
regexes. We discuss the latest development of them below.
1) Static Analyses: Static analyses detect ReDoS vul-
nerabilities by identifying vulnerable patterns in the regex.
Existing static methods usually build a NFA-based parse
structure, and find vulnerable patterns in the structure. Detecting
vulnerable patterns in NFA has been a theoretically well studied
problem [38]. For extended regular expressions that cannot be
represented by an NFA, researchers try to add support for some
extended features in the parse structure, such as additional
support for “backreferences” [9]; “capture groups” [4]; or
“capture groups”, “greedy quantifiers” and “lazy quantifiers”
[22]. Nevertheless, no parse structure can support all extended
features so far. Further, static analysis approaches usually have
false positives.
2) Dynamic Analyses: Dynamic analyses (or fuzzers) detect
ReDoS vulnerabilities by generating inputs to trigger the
worst-case matching. Such approaches usually do not require
knowledge of the regex structures and are not restricted
by context-free grammars. Therefore, they are able to find
vulnerable extended regular expressions. For example, both
SlowFuzz [28] and ReScue [30] get seeds from the regex
engine and use genetic algorithms to generate inputs.
Fuzzing methods do not work well for finding complex
vulnerabilities. Since vulnerable patterns in e-NFA have not
been well studied, fuzzers usually use only general information
like e-NFA state coverage rate, alphabet strings in regexes, and
the matching steps of a certain input string. Therefore, it is
difficult for these methods to find specially formatted worst-
case inputs for complex vulnerable regexes (e.g., in §VI-C3, the
fuzzing tool ReScue failed to generate the correct prefix, but
all the other static analysis tools succeeded). In addition, while
being effective, fuzzers may spend a lot of time on generating
inputs that cannot trigger the vulnerabilities.
III. PROBLEM STATEMENT
In this section, we first provide the necessary definitions in
our approach (§III-A), then discuss our research goals and the
research challenges (§III-B).
A. Definitions
We present our definition of e-NFA, which was previously
defined in [30] informally. We formalize the common imple-
mentations of modern regex engines, thus support all extended
features naturally. The definition includes the syntax of an
e-NFA (e.g. states, transition functions, etc.), the semantics of
an e-NFA, and the e-NFA match process. We do not formalize
the process that translates a regex to an e-NFA, because our
method depends directly on the e-NFA instead of the specific
translation implementation in a regex engine.
Definition 1 (e-NFA). An e-NFA A is represented by a 6-
tuple (V, Σ, ∆, ∆′, v0, vf ) where V is a finite set of states and
Σ is a finite alphabet of symbols. Let 0 ≤ p ≤ |s| be the
position in the currently processed input string s, and t as a
snapshot of global matching information when the engine runs
to the current state v. A state v includes several attributes: a
set ASv of strings acceptable for a match, its current match
count cv, its minimum required match count cmin
, and its
maximum allowed match count cmax
. The latter two represent
the match count requirements of the state. A state v has also
two corresponding functions: the match function δv in ∆, and
v in ∆′. δv : (s, p, t) → (Sv, p′, t′)
the transition function δ′
produces the status Sv ∈ {0, 1,−1} of state v, and updates
v : (Sv, t) → v′
global information p and t if necessary. δ′
produces the next state to transit to from Sv and t. Here,
v0 ∈ V is the initial state, and vf ∈ V is the only accepting
state.
v
v
1) The e-NFA Semantics: The e-NFA matches a string s
if there exists a sequence of transitions τ = v0 → ··· → vf
that, starting at (v0, p = 0, t = ϵ) and following the transitions
lead to the accepting state. We call τ as a matching path, and
s is a match string of τ. To consume the substring s[pi : pj]
while matching s, the e-NFA takes a sequence of transitions
vi → ··· → vj on the path τ. This sequence of transitions (we
simplify as vi, . . . , vj) represents a (sub-) matching path of the
substring s[pi : pj].
2) The e-NFA Match Process: Regex engines conduct a
match with a stack L that stores a sequence of states v. The
stack starts with the initial state v0, with L0 = {v0} by default.
For each transition v → v′, the engine iteratively computes the
status Sv of the stack’s top element v and pops it if Sv is either 1
(v is matched successfully) or −1 (the match fails). The engine
stops popping when Sv is 0, which indicates that the engine
cannot determine whether v could be matched at this moment,
or v is currently matched but could possibly be backtracked
later. Then, it computes the next state v′ ← δ′
v(Sv, t) and
pushes it onto the stack. The match process ends successfully
when the stack gets cleared and A reaches vf .
We use the regex example ^(.|[^"])*" in Figure 1a to
illustrate the above process. Assume the engine tries to match it
with a string “aa”. ① Before the engine consumes any character
(i.e., from v0 to the branch state v4), it first pops v0, then
pushes v1, v2, v3, v4 without popping any state. When v is v4,
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1470
inclusion transition if the match of v depends on v′ (i.e., the
match substring of v includes that of v′); and is a connection
transition if v and v′ are matched independently.
Formally, each e-NFA state v represents a subexpression in
the input regex r, which we call the subexpression of state v.
Let r[i : j] and r[i′ : j′] represent the subexpressions of v and
v′, respectively. In Figure 1a, the subexpression of the loop
state v2 is (.|[^"])*, which is r[1 : 10]; the subexpression of
the group head state v3 is (, which is r[1 : 2]; the subexpression
of the single string v10 is ", which is r[10 : 11]. The transition
is an inclusion transition if i′ ≥ i ∧ j′ ≤ j, or a connection
transition if i′ ≥ j. There is no case that two subexpressions
partially overlap. There could be many states reached from v
by inclusion transitions, but at most one state reached from
v by a connection transition. The current state v must be
matched for at least cmin
times, before the engine can take
a connection transition to match next subexpressions. It can,
however, take an inclusion transition to help match v as long as
= 1,
cv < cmax
which means it needs to and can be matched only once. When
cv4 = 0, it can be only matched by transiting to v5 or v8 via
inclusion transitions; when cv4 = 1, it has to transit to v6 by a
connection transition. Similarly, the loop state v2 has cmin
= 0
= +∞. It can transit to v3 by an inclusion transition
and cmax
or v10 by a connection transition.
. For instance, branch state v4 has cmin
= cmax
v2
v4
v4
v2
v
v
B. Research Goals and Challenges
We aim to investigate the ReDoS problem in extended
regular expressions. More specifically, we study how to
precisely and efficiently detect extended regular expressions
that are vulnerable to ReDoS attacks. Further, we generate
auxiliary information to help mitigate the vulnerabilities, e.g.,
by highlighting the vulnerable subexpressions. We do not claim
to detect all vulnerable regexes, i.e., our method is not sound.
Rather, we aim to develop a complete method that reports only
true positives.
We face the following challenges in detecting vulnerable
regexes with extended features.
1) Definition of Vulnerable Patterns in e-NFA. To pre-
cisely identify vulnerable regexes, we need a clear specification
of the vulnerable e-NFA patterns. Although the theory of ReDoS
vulnerabilities in NFA has been well established, there exists
no formal definition of vulnerable patterns in e-NFA. Unlike
NFA, e-NFA uses a context-sensitive grammar. It is hard to
define a vulnerable pattern that fits in all contexts.
2) Extended Feature Support. Regular expressions have
been extended with rich features to facilitate powerful string
matching. However, the extensive use of those features also
makes it hard to detect vulnerabilities through static analysis.
For example, “backreferences” allow the same text to be
matched more than once. Without executing the matching algo-
rithm, it is infeasible to know the exact text in backreference.
Further, it is difficult for static analysis methods to support all
extended features, because they usually depend on a dedicated
parser. Therefore, static structural analysis is imprecise and
could miss many vulnerabilities.
3) Attack String Generation. In order to identify true
positives from all vulnerable patterns, we need to construct
attack strings to trigger the timeouts. Precisely and efficiently
(a) The e-NFA implementation in the Java 8 engine.
(b) An E-TREE example.
Fig. 1: An example of regex ^(.|[^”])*”
the engine can select either v5 or v8 as the next state v′. ②
Assume the engine always transits to v5 first by pushing v5.
Its corresponding sub pattern “Dot” matches the first character
‘a’2. Its match function δv5 increments p to 1, and sets its
status Sv5 to 1, which makes the engine pop v5 and push
v6. Since v = v6 is the branch end, the engine pops v6, v4,
and pushes v7. Similarly, it then pops v7 and v3. ③ Now the
loop state v2 is the top element, the engine attempts to match
another repetition of it. With similar steps, it returns to v2 again
with p = 2. ④ The engine cannot find another character to
match either v4 or v10, and has to backtrack by decrementing
p to 1. This time, it transits to v4 and v8 (v5 was marked as
failed), and matches s[1]. After transiting back to v2, it has to
backtrack again by decrementing p to 0. It matches p[0] with
3, and p[1] with first v5 and then v8 in the next backtracking.
v8
The engine can match each ‘a’ with two states. With n ‘a’,
it has to try 2n possible matching paths until it finally fails.
3) The Match Function: δv : (s, p, t) → (Sv, p′, t′) has two
behaviors. First, when the acceptable string set ASv of the
state v (e.g., v10: string, v8: set operation, and v5: the ‘Dot’
feature) includes all strings that v can match, δv matches a
string s[p : p′] and updates p → p′, Sv → 1 if s[p : p′] is
in ASv. Second, when the ASv of the state v is empty, δv
determines the match using the information in t, which includes
the status of other states (e.g., v4 is matched if v5 or v8 is
matched) and strings already matched (i.e., capturing groups4
record matched strings in t for backreferences). Note that the
need of run-time variable t makes e-NFA a context-sensitive
grammar. However, the output of the function δv is determined
by s, p, and t.
4) The Transition Function: δ′
v : (Sv, t) → v′ determines
v′ using the current match count cv (e.g., cv = 0 if state v has
not been matched yet) for each state v stored in t. cv indicates
the current match status of v. The transition from v to v′ is an
2The “Dot” pattern matches any single character.
3It matches any single character except ".
4They include traditional groups “()”, lookarounds, named groups, and
atomic groups.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1471
v0:Begin ^v1:ProLog Loopv2:Loop Loopv3:GroupHead (v5:Dot .v4:Branch |v6:BranchConn BranchEndv7:GroupTail )v8:CharProperty [^”]v9:Node Exitv10:Single ”v11:LastNode Accv0:Begin ^v1:ProLog Loopv2:Loop Loopv3:GroupHead (v5:Dot .v4:Branch |v6:BranchConn BranchEndv7:GroupTail )v8:CharProperty [^”]v10:Single ”v11:LastNode Accgenerating the attack strings, however, is non-trivial. On the
one hand, pure static analysis cannot analyze the meaning of
some extended features and would simply use the literal values
in regexes. For instance, they would use “\s” to represent
a ‘blank’ character, which is apparently incorrect. On the
other hand, dynamic analysis methods, e.g., fuzzers, are usually
inefficient, because they need to search over a huge number of
possible strings.
IV. MODELING REDOS VULNERABILITIES
In this section, we aim to model ReDoS vulnerabilities
by proposing vulnerable e-NFA patterns and corresponding
attack string patterns. We analyze the characteristics of a
critical substring (attack core) in the attack string that would
cause catastrophic backtracking when a match attempt fails
(§IV-A). To define vulnerable e-NFA patterns, we then discuss
the crucial states in an e-NFA that may lead to super-linear
matching behavior (§IV-B). We propose that there are only two
types of such states, and each type can be represented by a
classical feature. Therefore, each vulnerable e-NFA pattern can
be abstracted as a structure composed of these two types of
classical features. Based on the above observations, we propose
different types of vulnerable e-NFA patterns (§IV-C) and attack
string patterns (§IV-D).
A. Attack Core Detection
The attack core is the most crucial part in an attack string.
It has at least two distinct sub-matching paths in the e-NFA,
and the transitions on these paths can be repetitively taken for
matching it. In other words, it is the common match string
of multiple subexpressions and their repetitions. Therefore,
when matching an attack core, the matching algorithm has
multiple traceable options. The repetition of attack core makes
the overall matching complexity super-linear when the engine
backtracks. We propose the following definition of common
match string for subexpressions to help find an attack core.
Definition 2 (Common match string). Several distinct subex-
pressions R = {r0, r1, . . .} have a common match string s if
there exists a string s such that s can match (the repetition of)
each subexpression r ∈ R.
For example, “ab” is a common match string of the two
subexpressions r0 =“(a|b)” and r1 =“ab”. It matches two
repetitions of r0, and (one repetition of) r1.
B. Crucial States in e-NFA
In this section we discuss which states in e-NFA would lead
to super-linear matching behavior. [26] proposes two critical
factors as necessary conditions for repeated backtracking in a