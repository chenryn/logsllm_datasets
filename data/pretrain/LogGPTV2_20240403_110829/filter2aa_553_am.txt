浮点型变量的声明和初始化方式与整型变量相同，下面是一些例子：
float noah, jonah;
double trouble;
float planck = 6.63e-34;
long double gnp;
2.浮点型常量
在代码中，可以用多种形式书写浮点型常量。浮点型常量的基本形式
是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数
表示10的指数。下面是两个有效的浮点型常量：
-1.56E+12
2.87e-3
正号可以省略。可以没有小数点（如，2E5）或指数部分（如，
19.28），但是不能同时省略两者。可以省略小数部分（如，3.E16）或整数
部分（如，.45E-6），但是不能同时省略两者。下面是更多的有效浮点型常
量示例：
3.14159
.2
4e16
.8E-5
100.
145
不要在浮点型常量中间加空格：1.56 E+12（错误！）
默认情况下，编译器假定浮点型常量是double类型的精度。例如，假设
some是float类型的变量，编写下面的语句：
some = 4.0 * 2.0;
通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运
算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会
减慢程序的运行速度。
在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看
作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long 
double类
型，如54.3l和4.32L。注意，建议使用L后缀，因为字母l和数字1很容易混
淆。没有后缀的浮点型常量是double类型。
C99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常
量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和
E，用2的幂代替10的幂（即，p计数法）。如下所示：
0xa.1fp10
十六进制a等于十进制10，.1f是1/16加上15/256（十六进制f等于十进制
15），p10是210或1024。0xa.1fp10表示的值是(10 
+ 
1/16 
+
15/256)×1024（即，十进制10364.0）。
注意，并非所有的编译器都支持C99的这一特性。
3.打印浮点值
printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点
数，用%e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点
数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La
转换说明。给那些未在函数原型中显式说明参数类型的函数（如，printf()）
146
传递参数时，C编译器会把float类型的值自动转换成double类型。程序清单
3.7演示了这些特性。
程序清单3.7 showf_pt.c程序
/* showf_pt.c -- 以两种方式显示float类型的值 */
#include 
int main(void)
{
float aboat = 32000.0;
double abet = 2.14e9;
long double dip = 5.32e-5;
printf("%f can be written %e\n", aboat, aboat);
// 下一行要求编译器支持C99或其中的相关特性
printf("And it's %a in hexadecimal, powers of 2 notation\n", 
aboat);
printf("%f can be written %e\n", abet, abet);
printf("%Lf can be written %Le\n", dip, dip);
return 0;
}
该程序的输出如下，前提是编译器支持C99/C11：
32000.000000 can be written 3.200000e+04
147
And it's 0x1.f4p+14 in hexadecimal, powers of 2 notation
2140000000.000000 can be written 2.140000e+09
0.000053 can be written 5.320000e-05
该程序示例演示了默认的输出效果。下一章将介绍如何通过设置字段宽
度和小数位数来控制输出格式。
4.浮点值的上溢和下溢
假设系统的最大float类型值是3.4E38，编写如下代码：
float toobig = 3.4E38 * 100.0f;
printf("%e\n", toobig);
会发生什么？这是一个上溢（overflow）的示例。当计算导致数字过
大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定
义的，不过现在C语言规定，在这种情况下会给toobig赋一个表示无穷大的
特定值，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内
容）。
当除以一个很小的数时，情况更为复杂。回忆一下，float类型的数以指
数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部
可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数
字。现在把它除以 
2。通常，这个操作会减小指数部分，但是假设的情况
中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第
1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有
效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得
到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫
作下溢（underflow）。C语言把损失了类型全精度的浮点值称为低于正常的
（subnormal）浮点值。因此，把最小的正浮点数除以 2将得到一个低于正常
的值。如果除以一个非常大的值，会导致所有的位都为0。现在，C库已提
148
供了用于检查计算是否会产生低于正常值的函数。
还有另一个特殊的浮点值NaN（not a number的缩写）。例如，给asin()
函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的
值。但是正弦值不能大于1，因此，如果传入的参数大于1，该函数的行为是
未定义的。在这种情况下，该函数将返回NaN值，printf()函数可将其显示为
nan、NaN或其他类似的内容。
浮点数舍入错误
给定一个数，加上1，再减去原来给定的数，结果是多少？你一定认为
是1。但是，下面的浮点运算给出了不同的答案：
/* floaterr.c--演示舍入错误 */
#include 
int main(void)
{
float a,b;
b = 2.0e20 + 1.0;
a = b - 2.0e20;
printf("%f \n", a);
return 0;
}
该程序的输出如下：
149
得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运
算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。
要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按
指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错
误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4
加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。
浮点数表示法
上一个方框中列出了由于计算机使用的系统不同，一个程序有不同的输
出。原因是，根据前面介绍的知识，实现浮点数表示法的方法有多种。为了
尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示
法开发了一套标准。现在，许多硬件浮点单元都采用该标准。2011年，该标
准被ISO/IEC/IEEE 
60559:2011标准收录。该标准作为C99和C11的可选项，
符合硬件要求的平台可开启。floaterr.c程序的第3个输出示例即是支持该浮
点标准的系统显示的结果。支持C标准的编译器还包含捕获异常问题的工
具。详见附录B.5，参考资料V。
3.4.7 复数和虚数类型
许多科学和工程计算都要用到复数和虚数。C99 标准支持复数类型和虚
数类型，但是有所保留。一些独立实现，如嵌入式处理器的实现，就不需要
使用复数和虚数（VCR芯片就不需要复数）。一般而言，虚数类型都是可选
项。C11标准把整个复数软件包都作为可选项。
简而言之，C语言有3种复数类型：float_Complex、double_Complex和
long double _Complex。例如，float _Complex类型的变量应包含两个float类型
的值，分别表示复数的实部和虚部。类似地， 
C语言的3种虚数类型是float
_Imaginary、double _Imaginary和long double _Imaginary。
150
如果包含complex.h头文件，便可用complex代替_Complex，用imaginary
代替_Imaginary，还可以用I代替-1的平方根。
为何 C 标准不直接用 complex 作为关键字来代替_Complex，而要添加
一个头文件（该头文件中把complex定义为_Complex）？因为标准委员会考
虑到，如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部
失效。例如，之前的 C99，许多程序员已经使用 struct complex 定义一个结
构来表示复数或者心理学程序中的心理状况（关键字struct用于定义能储存
多个值的结构，详见第14章）。让complex成为关键字会导致之前的这些代
码出现语法错误。但是，使用struct _Complex的人很少，特别是标准使用首
字母是下划线的标识符作为预留字以后。因此，标准委员会选定_Complex
作为关键字，在不用考虑名称冲突的情况下可选择使用complex。
3.4.8 其他类型
现在已经介绍完C语言的所有基本数据类型。有些人认为这些类型实在
太多了，但有些人觉得还不够用。注意，虽然C语言没有字符串类型，但也
能很好地处理字符串。第4章将详细介绍相关内容。
C语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和
联合。尽管后面章节中会详细介绍这些类型，但是本章的程序示例中已经用
到了指针〔指针（pointer）指向变量或其他数据对象位置〕。例如，在
scanf()函数中用到的前缀&，便创建了一个指针，告诉 scanf()把数据放在何
处。
小结：基本数据类型
关键字：
基本数据类型由11个关键字组成：int、long、short、unsigned、char、
float、double、signed、_Bool、_Complex和_Imaginary。
有符号整型：
151
有符号整型可用于表示正整数和负整数。
int ——系统给定的基本整数类型。C语言规定int类型不小于16位。
short或short 
int 
——最大的short类型整数小于或等于最大的int类型整
数。C语言规定short类型至少占16位。
long或long int ——该类型可表示的整数大于或等于最大的int类型整数。
C语言规定long类型至少占32位。
long long或long long int ——该类型可表示的整数大于或等于最大的long
类型整数。Long long类型至少占64位。
一般而言，long类型占用的内存比short类型大，int类型的宽度要么和
long类型相同，要么和short类型相同。例如，旧DOS系统的PC提供16位的
short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int
和long。
无符号整型：
无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数
比有符号整型的大。在整型类型前加上关键字unsigned表明该类型是无符号
整型：unsignedint、unsigned 
long、unsigned 
short。单独的unsigned相当于
unsignedint。
字符类型：
可打印出来的符号（如A、&和+）都是字符。根据定义，char类型表示
一个字符要占用1字节内存。出于历史原因，1字节通常是8位，但是如果要
表示基本字符集，也可以是16位或更大。
char ——字符类型的关键字。有些编译器使用有符号的char，而有些则
使用无符号的char。在需要时，可在char前面加上关键字signed或unsigned来
指明具体使用哪一种类型。
152
布尔类型：
布尔值表示true和false。C语言用1表示true，0表示false。
_Bool ——布尔类型的关键字。布尔类型是无符号 int类型，所占用的空
间只要能储存0或1即可。
实浮点类型：
实浮点类型可表示正浮点数和负浮点数。
float ——系统的基本浮点类型，可精确表示至少6位有效数字。
double ——储存浮点数的范围（可能）更大，能表示比 float 类型更多
的有效数字（至少 10位，通常会更多）和更大的指数。
long 
long 
——储存浮点数的范围（可能）比double更大，能表示比
double更多的有效数字和更大的指数。
复数和虚数浮点数：
虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构
成：
float _Complex
double _Complex
long double _Complex
float _Imaginary
double _Imaginary
long long _Imaginary
153
小结：如何声明简单变量
1.选择需要的类型。
2.使用有效的字符给变量起一个变量名。
3.按以下格式进行声明：
类型说明符 变量名;
类型说明符由一个或多个关键字组成。下面是一些示例：
int erest;
unsigned short cash;
4.可以同时声明相同类型的多个变量，用逗号分隔各变量名，如下所
示：
char ch, init, ans;
5.在声明的同时还可以初始化变量：
float mass = 6.0E24;
3.4.9 类型大小
如何知道当前系统的指定类型的大小是多少？运行程序清单3.8，会列
出当前系统的各类型的大小。
程序清单3.8 typesize.c程序
//* typesize.c -- 打印类型大小 */
#include 
int main(void)
154
{
/* C99为类型大小提供%zd转换说明 */
printf("Type int has a size of %zd bytes.\n", sizeof(int));
printf("Type char has a size of %zd bytes.\n", sizeof(char));
printf("Type long has a size of %zd bytes.\n", sizeof(long));
printf("Type long long has a size of %zd bytes.\n",
sizeof(long long));
printf("Type double has a size of %zd bytes.\n",
sizeof(double));
printf("Type long double has a size of %zd bytes.\n",