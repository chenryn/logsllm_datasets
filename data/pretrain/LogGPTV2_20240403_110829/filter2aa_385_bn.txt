XOR,amethodforencryptinganddecryptingyourimplanted
data.
EXPLORINGTHEPNGFORMAT
Let’sstartbyreviewingthePNGspecification,whichwill
helpyouunderstandthePNGimageformatandhowto
implantdataintoafile.Youcanfinditstechnicalspecification
athttp://www.libpng.org/pub/png/spec/1.2/PNG-
Structure.html.Itprovidesdetailsaboutthebyteformatofa
binaryPNGimagefile,whichismadeupofrepetitivebyte
chunks.
OpenaPNGfilewithinahexeditorandnavigatethrough
eachoftherelevantbytechunkcomponentstoseewhateach
does.We’reusingthenativehexdumphexeditoronLinux,
butanyhexeditorshouldwork.Youcanfindthesample
imagethatwe’llopenathttps://github.com/blackhat-
go/bhg/blob/master/ch-13/imgInject/images/battlecat.png;
however,allvalidPNGimageswillfollowthesameformat.
TheHeader
Thefirst8bytesoftheimagefile,89504e470d0a1a0a,
highlightedinFigure13-1,arecalledtheheader.
Figure13-1:ThePNGfile’sheader
Thesecond,third,andfourthhexvaluesliterallyreadPNG
whenconvertedtoASCII.Thearbitrarytrailingbytesconsist
ofbothDOSandUnixCarriage-ReturnLineFeed(CRLF).
Thisspecificheadersequence,referredtoasafile’smagic
bytes,willbeidenticalineveryvalidPNGfile.Thevariations
incontentoccurintheremainingchunks,asyou’llsoonsee.
Asweworkthroughthisspec,let’sstarttobuilda
representationofthePNGformatinGo.It’llhelpusexpedite
ourendgoalofembeddingpayloads.Sincetheheaderis8
byteslong,itcanbepackedintoauint64datatype,solet’sgo
aheadandbuildastructcalledHeaderthatwillholdthevalue
(Listing13-1).(Allthecodelistingsattherootlocationof/
existundertheprovidedgithubrepo
https://github.com/blackhat-go/bhg/.)
//HeaderholdsthefirstUINT64(MagicBytes)
typeHeaderstruct{
Headeruint64
}
Listing13-1:Headerstructdefinition(/ch-13/imgInject/pnglib/commands.go)
TheChunkSequence
TheremainderofthePNGfile,showninFigure13-2,is
composedofrepeatingbytechunksthatfollowthispattern:
SIZE(4bytes),TYPE(4bytes),DATA(anynumberofbytes),and
CRC(4bytes).
Figure13-2:Thepatternofthechunksusedfortheremainderoftheimagedata
Reviewingthehexdumpinfurtherdetail,youcanseethat
thefirstchunk—theSIZEchunk—consistsofbytes0x000x00
0x000x0d.ThischunkdefinesthelengthoftheDATAchunk
that’llfollow.ThehexadecimalconversiontoASCIIis13—so
thischunkdictatesthattheDATAchunkwillconsistof13
bytes.TheTYPEchunk’sbytes,0x490x480x440x52,converttoan
ASCIIvalueofIHDRinthiscase.ThePNGspecdefines
variousvalidtypes.Someofthesetypes,suchasIHDR,are
usedtodefineimagemetadataorsignaltheendofanimage
datastream.Othertypes,specificallytheIDATtype,containthe
actualimagebytes.
NextistheDATAchunk,whoselengthisdefinedbytheSIZE
chunk.Finally,theCRCchunkconcludestheoverallchunk
segment.ItconsistsofaCRC-32checksumofthecombined
TYPEandDATAbytes.ThisparticularCRCchunk’sbytesare
0x9a0x760x820x70.Thisformatrepeatsitselfthroughoutthe
entireimagefileuntilyoureachanEndofFile(EOF)state,
indicatedbythechunkoftypeIEND.
JustasyoudidwiththeHeaderstructinListing13-1,builda
structtoholdthevaluesofasinglechunk,asdefinedin
Listing13-2.
//Chunkrepresentsadatabytechunksegment
typeChunkstruct{
Sizeuint32
Typeuint32
Data[]byte
CRCuint32
}
Listing13-2:Chunkstructdefinition(/ch-13/imgInject/pnglib/commands.go)
READINGIMAGEBYTEDATA
TheGolanguagehandlesbinarydatareadsandwriteswith
relativeease,thanksinparttothebinarypackage(whichyou
mayrememberfromChapter6),butbeforeyoucanparse
PNGdata,you’llneedtoopenafileforreading.Let’screatea
PreProcessImage()functionthatwillconsumeafilehandleoftype
*os.Fileandreturnatypeof*bytes.Reader(Listing13-3).
//PreProcessImagereadstobufferfromfilehandle
funcPreProcessImage(dat*os.File)(*bytes.Reader,error){
❶stats,err:=dat.Stat()
iferr!=nil{
returnnil,err
}
❷varsize=stats.Size()
b:=make([]byte,size)
❸bufR:=bufio.NewReader(dat)
_,err=bufR.Read(b)
bReader:=bytes.NewReader(b)
returnbReader,err
}
Listing13-3:ThePreProcessImage()functiondefinition(/ch-
13/imgInject/utils/reader.go)
ThefunctionopensafileobjectinordertoobtainaFileInfo
structure❶usedtograbsizeinformation❷.Immediately
followingareacoupleoflinesofcodeusedtoinstantiatea
Readerinstanceviabufio.NewReader()andthena*bytes.Reader
instanceviaacalltobytes.NewReader()❸.Thefunctionreturnsa
*bytes.Reader,whichpositionsyoutostartusingthebinary
packagetoreadbytedata.You’llfirstreadtheheaderdataand
thenreadthechunksequence.
ReadingtheHeaderData
TovalidatethatthefileisactuallyaPNGfile,usethefirst8
bytes,whichdefineaPNGfile,tobuildthevalidate()method
(Listing13-4).
func(mc*MetaChunk)validate(b*bytes.Reader){
varheaderHeader
iferr:=binary.Read(b,binary.BigEndian,&header.Header)❶;err!=nil{
log.Fatal(err)
}
bArr:=make([]byte,8)
binary.BigEndian.PutUint64(bArr,header.Header)❷
ifstring(bArr[1:4])❸!="PNG"{
log.Fatal("ProvidedfileisnotavalidPNGformat")
}else{
fmt.Println("ValidPNGsoletuscontinue!")
}
}
Listing13-4:ValidatingthatthefileisaPNGfile(/ch-
13/imgInject/pnglib/commands.go)
Althoughthismethodmaynotseemoverlycomplex,it
introducesacoupleofnewitems.Thefirst,andthemost
obviousone,isthebinary.Read()function❶thatcopiesthefirst
8bytesfromthebytes.ReaderintotheHeaderstructvalue.Recall
thatyoudeclaredtheHeaderstructfieldastypeuint64(Listing
13-1),whichisequivalentto8bytes.It’salsonoteworthythat
thebinarypackageprovidesmethodstoreadMostSignificantBit
andLeastSignificantBitformatsviabinary.BigEndianand
binary.LittleEndian,respectively❷.Thesefunctionscanalsobe
quitehelpfulwhenyou’reperformingbinarywrites;for
example,youcouldselectBigEndiantoplacebytesonthewire
dictatingtheuseofnetworkbyteordering.
Thebinaryendiannessfunctionalsocontainsthemethods
thatfacilitatethemarshalingofdatatypestoaliteraldatatype
(suchasuint64).Here,you’recreatingabytearrayoflength8
andperformingabinaryreadnecessarytocopythedataintoa
unit64datatype.Youcanthenconvertthebytestotheirstring
representationsanduseslicingandasimplestringcomparison
tovalidatethatbytes1through4producePNG,indicatingthat
youhaveavalidimagefileformat❸.
ToimprovetheprocessofcheckingthatafileisaPNG
file,weencourageyoutolookattheGobytespackage,asit
containsconveniencefunctionsthatyoucoulduseasa
shortcuttocompareafileheaderwiththePNGmagicbyte
sequencewementionedearlier.We’llletyouexplorethison
yourown.
ReadingtheChunkSequence
OnceyouvalidatedthatyourfileisaPNGimage,youcan
writethecodethatreadsthechunksequence.Theheaderwill
occuronlyonceinaPNGfile,whereasthechunksequence
willrepeattheSIZE,TYPE,DATA,andCRCchunksuntilit
reachestheEOF.Therefore,youneedtobeableto
accommodatethisrepetition,whichyoucandomost
convenientlybyusingaGoconditionalloop.Withthisin
mind,let’sbuildoutaProcessImage()method,whichiteratively
processesallthedatachunksuptotheendoffile(Listing13-
5).
func(mc*MetaChunk)ProcessImage(b*bytes.Reader,c
*models.CmdLineOpts)❶{
//Snipcodeforbrevity(Onlydisplayingrelevantlinesfromcodeblock)
count:=1//Startat1because0isreservedformagicbyte
❷chunkType:=""
❸endChunkType:="IEND"//ThelastTYPEpriortoEOF
❹forchunkType!=endChunkType{
fmt.Println("----Chunk#"+strconv.Itoa(count)+"----")
offset:=chk.getOffset(b)
fmt.Printf("ChunkOffset:%#02x\n",offset)
chk.readChunk(b)
chunkType=chk.chunkTypeToString()
count++
}
}
Listing13-5:TheProcessImage()method(/ch-13/imgInject/pnglib/commands.go)
Youfirstpassareferencetoabytes.Readermemoryaddress
pointer(*bytes.Reader)asanargumenttoProcessImage()❶.The
validate()method(Listing13-4)youjustcreatedalsotooka
referencetoabytes.Readerpointer.Asconventiondictates,
multiplereferencestothesamememoryaddresspointer
locationwillinherentlyallowmutableaccesstothereferenced
data.Thisessentiallymeansthatasyoupassyourbytes.Reader
referenceasanargumenttoProcessImage(),thereaderwillhave
alreadyadvanced8bytesasaresultofthesizeoftheHeader
becauseyou’reaccessingthesameinstanceofbytes.Reader.
Alternatively,hadyounotpassedapointer,thebytes.Reader
wouldhaveeitherbeenacopyofthesamePNGimagedataor
separateuniqueinstancedata.That’sbecauseadvancingthe
pointerwhenyoureadtheheaderwouldnothaveadvanced
thereaderappropriatelyelsewhere.Youwanttoavoidtaking
thisapproach.Forone,passingaroundmultiplecopiesofdata
whenunnecessaryissimplybadconvention.More
importantly,eachtimeacopyispassed,itispositionedatthe
startofthefile,forcingyoutoprogrammaticallydefineand
manageitspositioninthefilepriortoreadingachunk
sequence.
Asyouprogressthroughtheblockofcode,youdefinea
countvariabletotrackhowmanychunksegmentstheimage
filecontains.ThechunkType❷andendChunkType❸areusedas
partofthecomparativelogic,whichevaluatesthecurrent
chunkTypetoendChunkType’sIENDvaluedesignatinganEOF
condition❹.
Itwouldbenicetoknowwhereeachchunksegmentstarts
—orrather,eachchunk’sabsolutepositionwithinthefilebyte
construct,avalueknownastheoffset.Ifyouknowtheoffset
value,itwillbemucheasiertoimplantapayloadintothefile.
Forexample,youcangiveacollectionofoffsetlocationstoa
decoder—aseparatefunctionthatcollectsthebytesateach
knownoffset—thatthenunwindsthemintoyourintended
payload.Togettheoffsetsofeachchunk,you’llcallthe
mc.getOffset(b)method(Listing13-6).
func(mc*MetaChunk)getOffset(b*bytes.Reader){
offset,_:=b.Seek(0,1)❶
mc.Offset=offset
}
Listing13-6:ThegetOffset()method(/ch-13/imgInject/pnglib/commands.go)
Thebytes.ReadercontainsaSeek()methodthatmakesderiving
thecurrentpositionquitesimple.TheSeek()methodmovesthe
currentreadorwriteoffsetandthenreturnsthenewoffset
relativetothestartofthefile.Itsfirstargumentisthenumber
ofbytesbywhichyouwanttomovetheoffsetanditssecond
argumentdefinesthepositionfromwhichthemovewilloccur.
Thesecondargument’soptionalvaluesare0(StartofFile),1
(CurrentPosition),and2(EndofFile).Forexample,ifyou
wantedtoshift8bytestotheleftfromyourcurrentposition,
youwoulduseb.Seek(-8,1).
Here,b.Seek(0,1)❶statesthatyouwanttomoveyouroffset
0bytesfromthecurrentposition,soitsimplyreturnsthe
currentoffset:essentiallyretrievingtheoffsetwithoutmoving
it.
Thenextmethodswedetaildefinehowyoureadtheactual
chunksegmentbytes.Tomakethingsabitmorelegible,let’s
createareadChunk()methodandthencreateseparatemethodsfor
readingeachchunksubfield(Listing13-7).
func(mc*MetaChunk)readChunk(b*bytes.Reader){
mc.readChunkSize(b)
mc.readChunkType(b)
mc.readChunkBytes(b,mc.Chk.Size)❶
mc.readChunkCRC(b)
}
func(mc*MetaChunk)readChunkSize(b*bytes.Reader){
iferr:=binary.Read(b,binary.BigEndian,&mc.Chk.Size);err!=nil{❷
log.Fatal(err)
}
}
func(mc*MetaChunk)readChunkType(b*bytes.Reader){
iferr:=binary.Read(b,binary.BigEndian,&mc.Chk.Type);err!=nil{
log.Fatal(err)
}
}
func(mc*MetaChunk)readChunkBytes(b*bytes.Reader,cLenuint32){
mc.Chk.Data=make([]byte,cLen)❸
iferr:=binary.Read(b,binary.BigEndian,&mc.Chk.Data);err!=nil{
log.Fatal(err)
}
}
func(mc*MetaChunk)readChunkCRC(b*bytes.Reader){
iferr:=binary.Read(b,binary.BigEndian,&mc.Chk.CRC);err!=nil{
log.Fatal(err)
}
}
Listing13-7:Chunk-readingmethods(/ch-13/imgInject/pnglib/commands.go)
ThemethodsreadChunkSize(),readChunkType(),andreadChunkCRC()
areallsimilar.Eachreadsauint32valueintotherespective
fieldoftheChunkstruct.However,readChunkBytes()isabitofan
anomaly.Becausetheimagedataisofvariablelength,we’ll
needtosupplythislengthtothereadChunkBytes()functionsothat
itknowshowmanybytestoread❶.Recallthatthedata
lengthismaintainedintheSIZEsubfieldofthechunk.You
identifytheSIZEvalue❷andpassitasanargumentto
readChunkBytes()todefineasliceofpropersize❸.Onlythencan
thebytedatabereadintothestruct’sDatafield.That’saboutit
forreadingthedata,solet’spressonandexplorewritingbyte
data.
WRITINGIMAGEBYTEDATATO
IMPLANTAPAYLOAD
Althoughyoucanchoosefrommanycomplexsteganography
techniquestoimplantpayloads,inthissectionwe’llfocusona
methodofwritingtoacertainbyteoffset.ThePNGfileformat
definescriticalandancillarychunksegmentswithinthe
specification.Thecriticalchunksarenecessaryfortheimage
decodertoprocesstheimage.Theancillarychunksare
optionalandprovidevariouspiecesofmetadatathatarenot
criticaltoencodingordecoding,suchastimestampsandtext.
Therefore,theancillarychunktypeprovidesanideal
locationtoeitheroverwriteanexistingchunkorinsertanew
chunk.Here,we’llshowyouhowtoinsertnewbyteslicesinto
anancillarychunksegment.
LocatingaChunkOffset
First,youneedtoidentifyanadequateoffsetsomewhereinthe
ancillarydata.Youcanspotancillarychunksbecausethey
alwaysstartwithlowercaseletters.Let’susethehexeditor
onceagainandopenuptheoriginalPNGfilewhileadvancing
totheendofthehexdump.
EveryvalidPNGimagewillhaveanIENDchunktype
indicatingthefinalchunkofthefile(theEOFchunk).Moving
tothe4bytesthatcomebeforethefinalSIZEchunkwill
positionyouatthestartingoffsetoftheIENDchunkandthe
lastofthearbitrary(criticalorancillary)chunkscontained
withintheoverallPNGfile.Recallthatancillarychunksare
optional,soit’spossiblethatthefileyou’reinspectingasyou
followalongwon’thavethesameancillarychunks,oranyfor
thatmatter.Inourexample,theoffsettotheIENDchunkbegins
atbyteoffset0x85258(Figure13-3).
Figure13-3:IdentifyingachunkoffsetrelativetotheIENDposition
WritingByteswiththeProcessImage()Method
Astandardapproachtowritingorderedbytesintoabyte
streamistouseaGostruct.Let’srevisitanothersectionofthe
ProcessImage()methodwestartedbuildinginListing13-5and
walkthroughthedetails.ThecodeinListing13-8calls
individualfunctionsthatyou’llbuildoutasyouprogress
throughthissection.
func(mc*MetaChunk)ProcessImage(b*bytes.Reader,c*models.CmdLineOpts)
❶{
--snip--
❷varmMetaChunk
❸m.Chk.Data=[]byte(c.Payload)
m.Chk.Type=m.strToInt(c.Type)❹
m.Chk.Size=m.createChunkSize()❺
m.Chk.CRC=m.createChunkCRC()❻
bm:=m.marshalData()❼
bmb:=bm.Bytes()
fmt.Printf("PayloadOriginal:%X\n",[]byte(c.Payload))
fmt.Printf("Payload:%X\n",m.Chk.Data)
❽utils.WriteData(b,c,bmb)
}
Listing13-8:WritingbyteswiththeProcessImage()method(/ch-13/imgInject/pnglib
/commands.go)
Thismethodtakesabyte.Readerandanotherstruct,
models.CmdLineOpts,asarguments❶.TheCmdLineOptsstruct,
showninListing13-9,containsflagvaluespassedinviathe
commandline.We’llusetheseflagstodeterminewhat
payloadtouseandwheretoinsertitintheimagedata.Since
thebytesyou’llwritefollowthesamestructuredformatas
thosereadfrompreexistingchunksegments,youcanjust
createanewMetaChunkstructinstance❷thatwillacceptyour
newchunksegmentvalues.
Thenextstepistoreadthepayloadintoabyteslice❸.
However,you’llneedadditionalfunctionalitytocoercethe
literalflagvaluesintoausablebytearray.Let’sdiveintothe
detailsofthestrToInt()❹,createChunkSize()❺,createChunkCRC()❻,
MarshalData()❼,andWriteData()❽methods.
packagemodels
//CmdLineOptsrepresentsthecliarguments
typeCmdLineOptsstruct{
Inputstring
Outputstring
Metabool
Suppressbool
Offsetstring
Injectbool
Payloadstring
Typestring
Encodebool
Decodebool
Keystring
}
Listing13-9:TheCmdLineOptsstruct(/ch-13/imgInject/models/opts.go)
ThestrToInt()Method
We’llstartwiththestrToInt()method(Listing13-10).
func(mc*MetaChunk)strToInt(sstring)❶uint32{
t:=[]byte(s)
❷returnbinary.BigEndian.Uint32(t)
}
Listing13-10:ThestrToInt()method(/ch-13/imgInject/pnglib/commands.go)
ThestrToInt()methodisahelperthatconsumesastring❶as
anargumentandreturnsuint32❷,whichisthenecessarydata
typeforyourChunkstructTYPEvalue.
ThecreateChunkSize()Method
Next,youusethecreateChunkSize()methodtoassigntheChunk
structSIZEvalue(Listing13-11).
func(mc*MetaChunk)createChunkSize()uint32{