o	    | （无）	                | 只使用一次内嵌表达式
`Regexp.new` 方法中的第 2 个参数可用于指定选项常量。只需要 1 个参数时，可不指定第 2 个参数或者直接指定 `nil`。
例如，`/Ruby` 脚本 `/i` 这一正则表达式，可以像下面那样写：
```ruby
Regexp.new("Ruby 脚本"， Regexp::IGNORECASE)
```
另外，我们还可以用 `|` 指定多个选项。这时，`/Ruby` 脚本 `/im` 这一正则表达式就变成了下面这样：
```ruby
Regexp.new("Ruby 脚本",
            Regexp::IGNORECASE | Regexp::MULTILINE)
```
# 捕获
除了检查字符是否匹配外，正则表达式还有另外一个常用功能，甚至可以说是比匹配更加重要的功能——捕获（后向引用）。
所谓捕获，就是从正则表达式的匹配部分中提取其中的某部分。通过“$ 数字”这种形式的变量，就可以获取匹配了正则表达式中的用 `()` 括住的部分的字符串。
```ruby
/(.)(.)(.)/ =~ "abc"
first = $1
second = $2
third = $3
p first     #=> "a"
p second    #=> "b"
p third     #=> "c"
```
在进行匹配的时候，我们只知道是否匹配、匹配第几个字符之类的信息。而使用捕获后，我们就可以知道哪部分被匹配了。因此，通过这个功能，我们就可以非常方便地对字符串进行分析。
我们提到了 `()` 也被用于将多个模式整理为一个。在修改程序中的正则表达式时，如果改变了 `()` 的数量，那么将要引用的部分的索引也会随之改变，有时就会带来不便。这种情况下，我们可以使用 `(?: )` 过滤不需要捕获的模式。
```ruby
/(.)(\d\d)+(.)/ =~ "123456"
p $1    #=> "1"
p $2    #=> "45"
p $3    #=> "6"
/(.)(?:\d\d)+(.)/ =~ "123456"
p $1    #=> "1"
p $2    #=> "6"
```
除了“`$` 数字”这种形式以外，保存匹配结果的变量还有 `$`、`$&`、`$`，分表代表匹配部分前的字符串、匹配部分的字符串、匹配部分后的字符串。为了方便大家快速理解这 3 个变量的含义，我们来看看下面这个例子：
```ruby
/C./ =~ "ABCDEF"
p $`    #=> "AB"
p $&    #=> "CD"
p $'    #=> "EF"
```
这样一来，我们就可以将字符串整体分为匹配部分与非匹配部分，并将其分别保存在 3 个不同的变量中。
# 使用正则表达式的方法
字符串相关的方法中有一些使用了正则表达式，接下来我们就来介绍一下其中的 `sub` 方法、`gsub` 方法、`scan` 方法。
**sub 方法与 gsub 方法**
`sub` 方法与 `gsub` 方法的作用是用指定的字符置换字符串中的某部分字符。
`sub` 方法与 `gsub` 方法都有两个参数。第 1 个参数用于指定希望匹配的正则表达式的模式，第 2 个参数用于指定与匹配部分置换的字符。`sub` 方法只置换首次匹配的部分，而 `gsub` 方法则会置换所有匹配的部分。
```ruby
str = "abc   def  g   hi"
p str.sub(/\s+/,' ')     #=> "abc def  g   hi"
p str.gsub(/\s+/,' ')    #=> "abc def g hi"
```
`/\s+/` 是用于匹配 1 个以上的空白字符的模式。因此在本例中，`sub` 方法与 `gsub` 方法会将匹配的空白部分置换为 1 个空白。`sub` 方法只会置换 `abc` 与 `def` 间的空白，而 `gsub` 方法则会将字符串后面匹配的空白部分全部置换。
`sub` 方法与 `gsub` 方法还可以使用块。这时，程序会将字符串中匹配的部分传递给块，并在块中使用该字符串进行处理。这样一来，块中返回的字符串就会置换字符串中匹配的部分。
```ruby
str = "abracatabra"
nstr = str.sub(/.a/) do |matched|
  ''
end
p nstr    #=> "abcatabra"
nstr = str.gsub(/.a/) do |matched|
  ''
end
p nstr    #=> "abb"
```
在本例中，程序会将字符串 `a` 以及 `a` 之前的字母转换为大写，并用 `<>` 将其括起来。
`sub` 方法与 `gsub` 方法也有带 `!` 的方法。`sub!` 方法与 `gusb!` 方法会直接将作为接受者的对象变换为置换后的字符串。
**scan 方法**
`scan` 方法能像 `gsub` 方法那样获取匹配部分的字符，但不能做置换操作。因此，当需要对匹配部分做某种处理时，可以使用该方法
```ruby
"abracatabra".scan(/.a/) do |matched|
  p matched
end
```
执行示例
```
> ruby scan1.rb
"ra"
"ca"
"ta"
"ra"
```
在正则表达式中使用 `()` 时，匹配部分会以数组的形式返回
```ruby
"abracatabra".scan(/(.)(a)/) do |matched|
  p matched
end
```
执行示例
```
> ruby scan2.rb
["r", "a"]
["c", "a"]
["t", "a"]
["r", "a"]
```
另外，如果指定与 `()` 相等数量的块参数，则返回的结果就不是数组，而是各个元素。
```ruby
"abracatabra".scan(/(.)(a)/) do |a, b|
  p a+"-"+b
end
```
执行示例
```
> ruby scan3.rb
"r-a"
"c-a"
"t-a"
"r-a"
```
如果没有指定块，则直接返回匹配的字符串数组。
```ruby
p "abracatabra".scan(/.a/)    #=> ["ra", "ca", "ta", "ra"]
```
# 正则表达式的例子
接下来我们来看看用正则表达式匹配 URL 的例子。
首先我们需要“找出包含 URL 的行”。创建表示完整的 URL 的正则表达式会非常复杂，不过我们可以稍微变通一下，把目标改为“找出类似于 URL 的字符串”，这时，就可以用如下模式来进行匹配。
```ruby
/http:\/\//
```
这个匹配模式的好处在于便于操作，而且也的确可以匹配 URL。
在此基础上，我们还可以进一步写出“获取类似于 URL 的字符串中的某部分”的正则表达式。例如，获取 HTTP 的 URL 中的服务器地址的模式时，可以像下面这样书写。
```ruby
/http:\/\/([^\/]*)\//
```
`[^\/]*` 表示匹配不含 `/` 的连续字符串。
上述例子中使用了较多 `/`，不便于阅读，这种情况下我们可以使用 `%r` 将其改写成像下面那样：
```ruby
%r|http://([^/]*)/|
```
```ruby
str = "http://www.ruby-lang.org/ja/"
%r|http://([^/]*)/| =~ str
print "server address: ", $1, "\n"
```
执行示例
```
> ruby url_match.rb
server address: www.ruby-lang.org
```
可以发现，的确可以获取服务器地址。
然后，我们再看看获取服务器地址以外部分的正则表达式。
```ruby
%r|^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?|
```
这是在 RFC2396“Uniform Resource Identifiers(URI)”这个定义 URI 语法的文件中使用的正则表达式。
这个正则表达式可以被原封不动地用在 Ruby 中。如果用这个正则表达式进行匹配，则 HTTP 等协议名会被保存在 `$2` 中，服务器地址等会被保存在 `$4` 中，路径名会被保存在 `$5` 中，请求部分会被保存在 `$7` 中，片段（fragment）会被保存在 `$9` 中。
例如，`http://www.example.co.jp/foo/?name=bar#bar` 这个 URI 的情况下，`http` 为通信协议名，`www.example.co.jp` 为服务器地址，`/foo/` 为路径名，`name=bar` 为请求名，`baz` 为片段。
然而，写到这种程度，正则表达式已经变得非常复杂了。如果把正则表达式写成在任何情况下都能匹配的万能模式，就会使得正则表达式变得难以读懂，增加程序的维护成本。相比之下，只满足当前需求的正确易懂的正则表达式则往往更有效率。
例如，匹配邮政编号的正则表达式，可以写成下面这样：
```ruby
/\d\d\d-\d\d\d\d/
```
这样，就不会匹配只有 3 位数字，或者没有 `-` 的邮政编码了。
在不需要太过严格的输入检查时，直接用 `/\d+-?\d*/` 匹配就可以了。