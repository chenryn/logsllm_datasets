然后是调用了strlen、malloc、strcpy等系统函数，在每次使用BLX和BL指令调用这些函数的时候，都发现了一个规律：在调用它们之前一般都是用MOV指令来传递参数值的，比如这里的R5里面存储的就是strlen函数的参数，R0就是is_number函数的参数，如下代码所示。这样分析之后，在后面的动态调试的过程中可以得到函数的入口参数值，这样就能得到一些重要信息。
在每次调用有返回值的函数之后的命令，一般都是比较指令，比如CMP、CBZ，或者是strcmp等，如上面代码最后一行。这里是破解的突破点，因为一般加密再怎么厉害，最后比较的参数肯定是正确的密码（或者是正确的加密之后的密码）和输入的密码（或者是加密之后的输入密码），在这里就可以得到正确密码，或者是加密之后的密码。
到这里就分析完了native层的密码比较函数：Java_cn_wjdiankong_encryptdemo_MainActivity_isEquals。如果觉得上面的ARM指令看的吃力，可以使用F5键，查看它的C语言代码，如下所示：
这里可以看到，有两个函数是核心点。
·is_number函数，这个函数看名字就能猜到是判断是不是数字，可以使用F5键，查看它对应的C语言代码，如下所示：
这里简单一看，主要是看return语句和if判断语句，看到这里有一个循环，然后获取_BYTE*这里地址的值，并且自增加一，然后存到v2中，如果v3为'\0'的话，就结束循环，然后做一次判断，就是v2-48是否大于9，那么这里知道48对应的是ASCII中的数字0，所以这里可以确定：用一个循环遍历_BYTE*这里存的字符串是否为数字串。
·get_encrypt_str函数，这个函数看到名字就可以猜测，它是获取输入的密码加密之后的值，再次使用F5快捷键查看对应的C语言代码，如下所示：
首先是一个if语句，用来判断传递的参数是否为NULL。如果是的话，直接返回；不是的话，使用strlen函数获取字符串的长度保存到v2中，然后使用malloc申请一块堆内存。首指针保存到result，大小是v2+1，也就是传递进来的字符串长度+1，然后就开始进入循环。首指针result，赋值给i指针，开始循环，v3是通过v1-1获取到的，就是函数传递进来字符串的地址，那么v6就是获取传递进来字符串的字符值，然后减去48，赋值给v7。
可以猜到了，这里想做字符转化，把char转化成int类型。继续往下看，如果v6==48的话，v7=1，也就是说这里如果遇到字符'0'，就赋值1。看到上面得到的v7值，被用来取key_src数组中的值，那么这里双击key_src变量，就跳转到了它的值地方。果不其然，这里保存了一个字符数组，看到它的长度正好是18，如下代码所示，那么应该明白了，这里通过传递进来的字符串，循环遍历字符串，获取字符，然后转化成数字，再倒序获取key_src中的字符，保存到result中。然后返回。
这两个重要函数的功能为，一个是判断输入的内容是否为数字字符串，一个是通过输入的内容获取密码内容，然后和正确的加密密码ssBCqpBssP进行比较。
22.3.2 用IDA进行调试设置
本节就用动态调试方法来跟踪传入的字符串值，以及加密之后的值。看到打印log的函数，很难知道具体的参数和寄存器的值，所以这里需要开始调试，得知每个函数执行之后的寄存器的值，在用IDA进行调试so的时候，需要以下准备步骤。
1.获取android_server文件
在IDA安装目录\dbgsrv\android_server，如图22-13所示。
图22-13 android_server文件
这个文件是干嘛的呢？它是怎么运行的呢？下面来介绍一下。在前一章中介绍了关于Android中的调试原理，其实是使用gdb和gdbserver来做到的，gdb和gdbserver在调试的时候，必须注入到被调试的程序进程中。但是非root设备的话，注入别的进程中只能借助于run-as这个命令。也就是说如果要调试一个应用进程的话，必须要注入它内部，那么用IDA调试so文件也是这个原理，需要注入进程才能进行调试。IDA有类似于gdbserver这样的工具，那就是android_server，需要运行在设备中，保证和PC端的IDA进行通信，比如获取设备的进程信息、具体进程的so内存地址、调试信息等。
把android_server保存到设备的/data目录下，修改一下它的运行权限，然后必须在root环境下运行，因为要做注入进程操作，所以必须要root：
注意，这里把它放在了/data目录下，然后是./android_server命令，这里提示了IDA Android 32-bit，所以后面在打开IDA的时候一定要是32位的IDA，不是64位的。IDA在安装之后都是有两个可执行的程序，一个是32位，一个是64位的，如果没打开正确会报这样的错误，如图22-14所示。
图22-14 报错信息
还有一类问题：error：only position independent executables（PIE）are supported这主要是Android 5.0以上的编译选项默认开启了pie，在5.0以下编译的原生应用不能运行，有两种解决办法，一种是用Android 5.0以下的手机进行操作，还有一种就是用IDA6.6+版本即可。
然后开始监听了设备的23946端口，如果想让IDA和这个android_server进行通信，必须让PC端的IDA也连上这个端口，这时候就需要借助于adb的一个命令了：
这里就可以把android_server端口转发出去：
这时候，只要在PC端使用IDA连接上23946这个端口就可以了。到这里会有人好奇，为什么远程端的端口号也是23946呢？因为后面在使用IDA进行连接的时候，发现IDA把这个端口设置死了，就是23946，可使用如下命令修改：android-server-p1234。
可以使用netstat命令查看端口23946的使用情况，看到是ida在使用这个端口
2.IDA获取进程信息
上面准备好了android_server，运行成功，下面就用IDA进行尝试连接，获取信息，进行进程附加注入。这时候需要再打开一个IDA，之前打开一个IDA是用来分析so文件的，一般用于静态分析，要调试so的话，需要再打开一个IDA。这里一般都是需要打开两个IDA，也叫作双开IDA操作，采用动静结合策略，如图22-15所示。
图22-15 双开IDA
这里记得选择Go这个选项，就是不需要打开so文件了，进入一个空白页，如图22-16所示。
在Debugger选项卡中选择Attach，看到有很多debugger，可见IDA工具真的很强大，做到很多debugger的兼容，可以调试很多平台下的程序。这里选择Android debugger，出现页面如图22-17所示。
图22-16 选择Debugger选项
图22-17 设置端口
这里可看到端口是23946，所以上面用adb forward进行端口转发的时候是23946。这里PC本地机就是调试端，所以host就是本机的ip地址：127.0.0.1，点击OK，出现界面如图22-18所示。
图22-18 进程信息列表
可以看到列出了设备中所有的进程信息，其实都是android_server干的事，获取设备进程信息传递给IDA进行展示。
注意，如果当初没有用root身份去运行android_server：
IDA就不会列举出设备的进程信息，如图22-19所示。
图22-19 无进程列表信息
还有一个注意的地方，就是IDA和android_server版本一定要保持一致。
可以用Ctrl+F快捷键搜索需要调试的进程，这里必须运行要调试的进程，不然也是找不到这个进程的，如图22-20所示。
图22-20 搜索进程
双击进程，即可进入调试页面，如图22-21所示。
图22-21 进入调试页面
为什么会断在libc.so中呢？Android系统中libc是c层中最基本的函数库，libc中封装了io、文件、socket等基本系统调用。所有上层的调用都需要经过libc封装层。所以libc.so是最基本的，所以会断在这里。而且一些常用的系统so，比如linker，如图22-22所示。
图22-22 linker文件
这个linker是用于加载so文件的模块，所以后面再分析如何在.init_array处下断点，还有一个就是libdvm.so文件，它包含了dvm中所有的底层加载dex的一些方法，如图22-23所示。
图22-23 libdvm.so文件
在后面动态调试需要dump出加密之后的dex文件，就需要调试这个so文件了。
3.找到函数地址下断点
使用Ctrl+S快捷键找到需要调试so的基地址：74FE4000，如图22-24所示。
图22-24 查找基地址
然后通过另外一个IDA打开so文件，查看函数的相对地址：E9C，如下所示：
那么得到了函数的绝对地址就是：74FE4E9C，使用G键快速跳转到这个绝对地址，如图22-25所示。
图22-25 跳转到绝对地址
跳转这个地址之后，开始下断点，点击最左边的绿色圆点即可下断点，如下所示：
然后点击左上角的绿色三角按钮运行，也可以使用F9键运行程序。
点击程序中的按钮，如图22-26所示。
图22-26 点击程序中的按钮
触发native函数的运行，如下所示：
进入调试阶段了，这时候可以使用F8快捷键进行单步调试，用F7进行单步调试，如下所示：
点击F8进行单步调试，到达is_number函数调用处，看到R0是出入的参数值，可以查看R0寄存器的内容，然后看到是123456，这个就是Java层传入的密码字符串。接着往下走，如下所示：
这里把is_number函数返回值保存到R0寄存中，然后调用CBZ指令，判断是否为0，如果为0就跳转到locret_74FE4EEC处，查看R0寄存器的值不是0，继续往下走，如图22-27所示。
图22-27 查看寄存器值
看到了get_encrypt_str函数的调用，函数的返回值保存在R1寄存器中，查看内容为：zytyrTRA*B，那么看到，上层传递的：123456→zytyrTRA*B，前面静态分析了get_encrypt_str函数的逻辑，继续往下看，如下所示：
这里把上面得到的字符串和ssBCqpBssP作比较，那么ssBCqpBssP就是正确的加密密码了。那么现在的资源是：正确的加密密码为ssBCqpBssP，加密密钥库为zytyrTRA*BniqCPpVs，加密逻辑为get_encrypt_str。
可以写一个逆向的加密方法，去解析正确的加密密码得到值即可。为了给大家一个破解的机会，这里就不公布正确答案了。
加密apk下载地址：
http://download.csdn.net/detail/jiangwei0910410003/9531638
22.3.3 IDA调试的流程总结
到这里，就分析了如何破解apk的流程，下面来总结一下：
1）通过解压apk文件得到对应的so文件，然后使用IDA工具打开so文件，找到指定的native层函数。
2）通过IDA中的一些快捷键：F5、Ctrl+S、Y等，静态分析函数的ARM指令，大致了解函数的执行流程。
3）再次打开一个IDA来进行调试so文件。
4）将IDA目录中的android_server拷贝到设备的指定目录下，修改android_server的运行权限，用root身份运行android_server。
5）使用adb forward进行端口转发，让远程调试端IDA可以连接到被调试端。
6）使用IDA连接上转发的端口，查看设备的所有进程，找到需要调试的进程。
7）通过打开so文件，找到需要调试函数的相对地址，然后在调试页面使用Ctrl+S找到so文件的基地址，相加之后得到绝对地址，使用G键，跳转到函数的地址处，下好断点。点击运行或者点击F9键。
8）触发native层的函数，使用F8和F7快捷键进行单步调试，查看关键的寄存器中的值，比如函数的参数、函数的返回值等信息。
总结：在调试so文件的时候，需要双开IDA，采用动静结合的方式进行分析。
22.4 用IDA解决反调试问题
到这里就结束了本章的破解旅程了？答案是否定的，因为上面的例子其实是自己构建的，先写了一个apk，目的就是为了给大家演示。如何使用IDA来进行动态调试so文件，下面用一个操作动手的案例来讲解，这个案例解决了反调试问题。这是2014年阿里安全挑战赛的第二题：AliCrackme_2。
如图22-28所示，下面来看看破解流程。首先使用aapt命令查看其AndroidManifest.xml文件，得到入口的Activity类，如下所示：
图22-28 破解程序
然后使用dex2jar和jd-gui查看它的源码类com.yaotong.crackme.MainActivity，如下所示：
看到它的判断，securityCheck方法是native层的，所以这时候去解压apk文件，获取它的so文件，使用IDA打开查看native函数的相对地址11A8，如图22-29所示。
图22-29 查看函数的相对地址
这里的ARM指令代码不分析了，大家自行查看即可，直接进入调试即可，再打开一个IDA进行关联调试，如图22-30所示。
图22-30 附加进程
选择对应的调试进程，然后点击OK，如图22-31所示。
图22-31 查找需要调试的so文件
使用Ctrl+S键找到对应so文件的基地址74EA9000，和上面得到的相对地址相加得到绝对地址74EA9000+11A8=74EAA1A8。使用G键直接跳到这个地址，如下所示：
下个断点，然后点击F9运行程序，如图22-32所示。
图22-32 运行程序
这时候会发现IDA退出调试页面了，再次进入调试页面，运行，还是退出调试页面了。似乎没法调试了。
其实这里是阿里做了反调试侦查，如果发现自己的程序被调试，就直接退出程序。那么怎么知道有人调试呢？这里限于篇幅，只是简单介绍一下原理。
前面说到，IDA是使用android_server在root环境下注入到被调试的进程中，那么这里用到一个技术就是Linux中的ptrace，关于ptrace这里也不解释了，大家可以自行的去搜一下ptrace的相关知识。那么Android中如果一个进程被另外一个进程ptrace了之后，在其status文件中有一个字段TracerPid可以标识是被哪个进程trace了，可以使用命令查看到被调试的进行信息status文件在：/proc/[pid]/status，如下所示：
这里的进程被27445进程trace了，在用ps命令看看27445是哪个进程：
果不其然是android_server进程。知道原理了，也大致猜到了阿里在底层做了一个循环检测这个字段如果不为0，那么代表自己进程有人trace，那么就直接停止退出程序，这个反调试技术用在很多安全防护的地方。
那么下面就来看看如何应对这个反调试？刚刚看到，只要一运行程序，就退出了调试界面，说明，这个循环检测程序执行的时机非常早，那么现在知道的最早的两个时机是：一个是.init_array，一个是JNI_OnLoad。
.init_array是一个so最先加载的一个段信息，时机最早，现在一般so解密操作都是在这里做的。JNI_OnLoad是so被System.loadLibrary调用的时候执行，它的时机要早于哪些native方法执行，但是没有.init_array时机早。知道了这两个时机，下面先来看看是不是在JNI_OnLoad函数中做的策略，所以需要先动态调试JNI_OnLoad函数。
既然知道了JNI_OnLoad函数的时机，如果把检测函数放在这里的话，不能用之前的方式去调试了，因为之前的那种方式时机太晚了，只要运行就已经执行了JNI_OnLoad函数，所以就会退出调试页面，幸好这里IDA提供了在so文件load的时机，只需要在Debug Option中设置一下就可以了，在调试页面的Debugger选择Debugger Option选项，如图22-33所示。
然后勾选Suspend on library load/unload即可，如图22-34所示。
图22-33 设置Debugger选项
图22-34 勾选Suspend on library load/unload
这样设置之后，还是不行，因为程序已经开始运行，就在static代码块中加载so文件了，如图22-35所示。static的时机非常早，所以这时候，需要让程序停在加载so文件之前即可。
图22-35 static代码块中加载so文件