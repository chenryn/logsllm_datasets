Demystifying Modern 
Windows Rootkits
Bill Demirkapi
Independent Security Researcher
1
Demystifying Modern Windows Rootkits – DEF CON 28
Who Am I?
▪ 19 years old
▪ Sophomore at the Rochester Institute of Technology
▪
Windows Internals
▪ Mostly self-taught (with guidance)
▪ Strong “Game Hacking” background
2
Demystifying Modern Windows Rootkits – DEF CON 28
What Is This Talk About?
In this talk, we’ll go over…
▪ Loading a rootkit.
▪ Communicating with a rootkit.
▪ Abusing legitimate network communications.
▪ An example rootkit I wrote and the design choices behind it.
▪ Executing commands from kernel.
▪ Tricks to cover up the filesystem trace of your rootkit.
Demystifying Modern Windows Rootkits – DEF CON 28
3
Introduction to 
Windows Rootkits
Demystifying Modern Windows Rootkits – DEF CON 28
4
Windows Rootkits: An Overview
Why would you want to use a rootkit?
▪ Kernel drivers have significant access to the machine.
▪ Same privilege level as a typical kernel anti-virus.
▪ Less mitigations and security solutions targeting kernel malware.
▪ Anti-Virus often have less visibility into operations performed by 
kernel drivers.
▪ Kernel drivers are often ignored by anti-virus.
Demystifying Modern Windows Rootkits – DEF CON 28
5
Example: Treatment by Anti-Virus
Anti-virus tends to treat kernel drivers with significant trust compared 
to user-mode applications.
Demystifying Modern Windows Rootkits – DEF CON 28
6
Excerpt from Carbon Black’s Process/Thread Handle callbacks
Excerpt from Malwarebytes’ Process/Thread Handle callbacks
Loading a Rootkit
Demystifying Modern Windows Rootkits – DEF CON 28
7
Abuse Legitimate Drivers
There are a lot of “vulnerable” drivers. With some reversing 
knowledge, finding a “0-day” in a driver can be trivial.
Examples include…
▪ Capcom’s Anti-Cheat driver
▪ Intel’s NAL Driver
▪ Microsoft themselves!
Demystifying Modern Windows Rootkits – DEF CON 28
8
Abuse Legitimate Drivers
Using legitimate drivers has quite a few benefits too:
▪ You only need a few primitives to escalate privilege.
▪ Finding a “vulnerable” driver is relatively trivial (OEM Drivers ).
▪ Difficult to detect due to compatibility reasons.
Demystifying Modern Windows Rootkits – DEF CON 28
9
Abuse Legitimate Drivers
Abusing legitimate drivers comes with some strong drawbacks too…
▪ Major issue of compatibility across operating system versions 
depending on the primitives you have.
▪ Much more likely to run into stability issues.
▪ The last thing you want is your malware to BSOD a victim.
Demystifying Modern Windows Rootkits – DEF CON 28
10
Just Buy a Certificate!
For some red teamers, buying a legitimate code signing certificate 
might be a good option.
▪ Useful for targeted attacks.
▪ No stability concerns.
But…
▪ Potentially reveals your identity.
▪ Can be blacklisted.
Demystifying Modern Windows Rootkits – DEF CON 28
11
Abuse Leaked Certificates
Instead of buying a certificate yourself, why not just use one from 
someone else?
▪ There are quite a few public leaked certificates available to download.
▪ Almost has all the benefits of buying one without deanonymization.
But…
▪ The leaked certificate you use can be detected in the future.
▪ If the certificate was issued after July 29th, 2015, it won’t work on 
secure boot machines running certain versions of Windows 10.
Demystifying Modern Windows Rootkits – DEF CON 28
12
Abuse Leaked Certificates
In most cases, Windows doesn’t care if your driver has a certificate that 
has expired or was revoked.
Demystifying Modern Windows Rootkits – DEF CON 28
13
Abuse Leaked Certificates
Several leaked certificates are already publicly posted, but it’s not 
impossible to find your own.
Demystifying Modern Windows Rootkits – DEF CON 28
14
Abuse Leaked Certificates
Oh and the best part…. most of them are undetected by the bulk of AV:
Demystifying Modern Windows Rootkits – DEF CON 28
15
Communicating with a Rootkit
Demystifying Modern Windows Rootkits – DEF CON 28
16
Beacon Out to a C2
A tried and true method that comes with some downsides is to “call 
home”.
▪ Firewalls can block or flag outgoing requests to unknown/suspicious 
IP Addresses or ports.
▪ Advanced Network Inspection can catch some exfiltration techniques 
that try to “blend in with the noise”.
Demystifying Modern Windows Rootkits – DEF CON 28
17
Open a Port
Some malware takes the route that the C2 connects to the victim 
directly to control it.
▪ Relatively simple to setup.
But…
▪ Could be blocked off by a firewall.
▪ Difficult to “blend in with the noise”.
Demystifying Modern Windows Rootkits – DEF CON 28
18
Application Specific Hooking
More advanced malware may opt to hook a specific application’s 
communication as a channel of communication.
▪ Difficult to detect, especially if using legitimate protocol.
But…
▪ It’s not very flexible.
▪ A machine might not have that service exposed.
Demystifying Modern Windows Rootkits – DEF CON 28
19
Choosing a Communication Method
What I want…
1. Limited detection vectors.
2. Flexibility for various environments.
My assumptions…
1. Victims machines will have some services exposed.
2. Inbound and outbound access may be monitored.
Demystifying Modern Windows Rootkits – DEF CON 28
20
Choosing a Communication Method
Application Specific Hooking was perfect for my needs, except for the 
flexibility.
Is there anyway we could change Application Specific Hooking to where 
it isn’t dependent on any single application?
Demystifying Modern Windows Rootkits – DEF CON 28
21
Abusing Legitimate Communication
What if instead of hooking an application directly, we…
▪ Hook network communication, similar to tools like Wireshark.
▪ Place a special indicator in “malicious” packets, a “magic” constant.
▪ Send these “malicious” packets to legitimate ports on the victim 
machine.
▪ Search packets for this “magic” constant to pass on data to our 
malware.
Demystifying Modern Windows Rootkits – DEF CON 28
22
Hooking the User-Mode Network Stack
Demystifying Modern Windows Rootkits – DEF CON 28
23
Hooking the Windows Winsock Driver
▪ A significant amount of services on Windows can be found in user-
mode, how can we globally intercept this traffic?
▪ Networking relating to WinSock is handled by Afd.sys, otherwise 
known as the “Ancillary Function Driver for WinSock”.
▪ Reversing a few functions in mswsock.dll revealed that a bulk of 
the communication was done through IOCTLs. If we could intercept 
these requests, we could snoop in on the data being received.
Demystifying Modern Windows Rootkits – DEF CON 28
24
How Do Irps Know Where to Go?
When you call NtDeviceIoControlFile on a file handle to a device, 
how does the kernel determine what function to call?
Demystifying Modern Windows Rootkits – DEF CON 28
25
Standard Methods of Intercepting Irps
There are a few ways we can intercept Irps, but let’s look at two 
common methods.
1. Replace the Major Function you’d like to hook in the driver’s object.
2. Perform a code hook directly on the dispatch handler.
Demystifying Modern Windows Rootkits – DEF CON 28
26
Picking a method
To pick the best method of hooking, here are a few common questions 
you should ask.
▪ How many detection vectors are you potentially exposed to?
▪ How "usable" is the method?
▪ How expensive would it be to detect the method?
Demystifying Modern Windows Rootkits – DEF CON 28
27
Hook a Driver Object
▪ How many detection vectors are you potentially exposed to?
▪ Memory artifacts.
▪ How “usable” is the method?
▪ For stability, by replacing a single function with an interlocked exchange, this 
method should be stable.
▪ For compatibility, driver objects are well-documented and easy to find.
▪ How expensive would it be to detect the method?
▪ Inexpensive, all anti-virus would need to do is enumerate loaded drivers and 
check that the major functions are within the bounds of the driver.
Demystifying Modern Windows Rootkits – DEF CON 28
28
Hook a Driver’s Dispatch Function
▪ How many detection vectors are you potentially exposed to?
▪ Memory artifacts.
▪ How “usable” is the method?
▪ Unless the function is exported, you will need to find the function yourself.
▪ Not all drivers are compatible with this method due to PatchGuard.
▪ HVCI incompatible.
▪ How expensive would it be to detect the method?
▪ Potentially inexpensive and several methods to detect hooking.
Demystifying Modern Windows Rootkits – DEF CON 28
29
Hooking File Objects
I wanted a method that was…
▪ Undocumented.
▪ Stable.
▪ Relatively expensive to detect.
What if instead of hooking the original driver object, we hooked the file 
object instead?
Demystifying Modern Windows Rootkits – DEF CON 28
30
How Do Irps Know Where to Go?
typedef struct _FILE_OBJECT {
CSHORT Type;
CSHORT Size;
PDEVICE_OBJECT DeviceObject;
...
} FILE_OBJECT;
Demystifying Modern Windows Rootkits – DEF CON 28
31
To retrieve the device associated with the Afd driver, the kernel calls 
IoGetRelatedDeviceObject.
What’s stopping us from 
overwriting this pointer?
Hooking File Objects
What we can do is…
1. Create our own device object and driver object.
2. Patch our copy of the driver object.
3. Replace the DeviceObject pointer of our file object with our own 
device.
Let’s talk about how we would go about doing this.
Demystifying Modern Windows Rootkits – DEF CON 28
32
Hooking File Objects
Let’s start by finding a file object to hook. We’re after handles to 
\Device\Afd, but how can we find these objects?
Demystifying Modern Windows Rootkits – DEF CON 28
33
typedef enum _SYSTEM_INFORMATION_CLASS
{
...
SystemHandleInformation,
...
} SYSTEM_INFORMATION_CLASS, 
*PSYSTEM_INFORMATION_CLASS;
Hooking File Objects
The SystemHandleInformation class allows us to query all handles 
on the system, including…
▪ The process ID the handle belongs to.
▪ The kernel pointer of the object associated with the handle.
If we open the Afd device ourselves, we can easily recognize file objects 
that are for the Afd device.
Demystifying Modern Windows Rootkits – DEF CON 28
34
Hooking File Objects
Before we can overwrite the DeviceObject member, we need to create 
our fake objects first. Fortunately, the kernel exports the function it 
uses itself to create these objects.
All we need to do is call ObCreateObject passing the 
IoDriverObjectType or IoDeviceObjectType to create our fake 
objects.
We can copy the existing objects over to contain the same member 
values.
Demystifying Modern Windows Rootkits – DEF CON 28
35
Hooking File Objects
With our fake objects created, we’re almost ready to set the 
DeviceObject of the file object. First though, we need to hook our 
driver object.
We can use the standard “Hook a Driver Object” method, except 
instead of performing it on the original driver object, we’ll use it on a 
fake driver object used exclusively for our hooks.
Demystifying Modern Windows Rootkits – DEF CON 28
36
Hooking File Objects
To prevent race conditions while replacing the device object member, 