# strace -p 15959    strace: Process 15959 attached    restart_syscall() = ?    +++ killed by SIGKILL +++知识详解：信号的两个系统调用我们想要理解刚才的例子，就需要搞懂信号背后的两个系统调用，它们分别是 kill() 系统调用和 signal() 系统调用。这里呢，我们可以结合前面讲过的信号来理解这两个系统调用。在容器 init进程的第一讲里，我们介绍过信号的基本概念了，**信号就是 Linux进程收到的一个通知。**等你学完如何使用这两个系统调用之后，就会更清楚 Linux信号是怎么一回事，遇到容器里信号相关的问题，你就能更好地理清思路了。我还会再给你举个使用函数的例子，帮助你进一步理解进程是如何实现graceful shutdown 的。进程对信号的处理其实就包括两个问题，**一个是进程如何发送信号，另一个是进程收到信号后如何处理。**我们在 Linux 中发送信号的系统调用是kill()，之前很多例子里面我们用的命令 `kill`，它内部的实现就是调用了 kill()这个函数。 下面是 Linux Programmer's Manual 里对 kill()函数的定义。这个函数有两个参数，一个是 `sig`，代表需要发送哪个信号，比如 sig 的值是 15的话，就是指发送 SIGTERM；另一个参数是`pid`，也就是指信号需要发送给哪个进程，比如值是 1的话，就是指发送给进程号是 1的进程。     NAME           kill - send signal to a process    SYNOPSIS           #include            #include            int kill(pid_t pid, int sig);我们知道了发送信号的系统调用之后，再来看另一个系统调用，也就是signal() 系统调用这个函数，它可以给信号注册handler。 下面是 signal() 在 Linux Programmer's Manual 里的定义，参数 `signum`也就是信号的编号，例如数值 15，就是信号 SIGTERM；参数 `handler`是一个函数指针参数，用来注册用户的信号handler。     NAME           signal - ANSI C signal handling    SYNOPSIS           #include            typedef void (*sighandler_t)(int);           sighandler_t signal(int signum, sighandler_t handler);在容器 init 进程的第一讲里，**我们学过进程对每种信号的处理，包括三个选择：调用系统缺省行为、捕获、忽略。**而这里的选择，其实就是程序中如何去调用 signal()这个系统调用。第一个选择就是缺省，如果我们在代码中对某个信号，比如 SIGTERM信号，不做任何 signal()相关的系统调用，那么在进程运行的时候，如果接收到信号SIGTERM，进程就会执行内核中 SIGTERM信号的缺省代码。对于 SIGTERM这个信号来说，它的缺省行为就是进程退出（terminate）。内核中对不同的信号有不同的缺省行为，一般会采用退出（terminate），暂停（stop），忽略（ignore）这三种行为中的一种。那第二个选择捕获又是什么意思呢?捕获指的就是我们在代码中为某个信号，调用 signal() 注册自己的handler。这样进程在运行的时候，一旦接收到信号，就不会再去执行内核中的缺省代码，而是会执行通过signal() 注册的 handler。比如下面这段代码，我们为 SIGTERM 这个信号注册了一个 handler，在handler里只是做了一个打印操作。那么这个程序在运行的时候，如果收到 SIGTERM信号，它就不会退出了，而是只在屏幕上显示出\"receivedSIGTERM\"。     void sig_handler(int signo)    {      if (signo == SIGTERM) {              printf("received SIGTERM\n");      }    }    int main(int argc, char *argv[])    {    ...      signal(SIGTERM, sig_handler);    ...    }我们再来看看第三个选择，如果要让进程"忽略"一个信号，我们就要通过signal() 这个系统调用，为这个信号注册一个特殊的 handler，也就是 `SIG_IGN`。 比如下面的这段代码，就是为 SIGTERM这个信号注册`SIG_IGN`。这样操作的效果，就是在程序运行的时候，如果收到 SIGTERM信号，程序既不会退出，也不会在屏幕上输出log，而是什么反应也没有，就像完全没有收到这个信号一样。    int main(int argc, char *argv[])    {    ...      signal(SIGTERM, SIG_IGN);    ...    }好了，我们通过讲解 signal()这个系统调用，帮助你回顾了信号处理的三个选择：缺省行为、捕获和忽略。这里我还想要提醒你一点，** SIGKILL 和 SIGSTOP信号是两个特权信号，它们不可以被捕获和忽略，这个特点也反映在 signal()调用上。** 我们可以运行下面的这段代码，如果我们用 signal() 为 SIGKILL注册 handler，那么它就会返回SIG_ERR，不允许我们做捕获操作。    
# cat reg_sigkill.c    #include     #include     #include     #include     #include     typedef void (*sighandler_t)(int);    void sig_handler(int signo)    {                if (signo == SIGKILL) {                            printf("received SIGKILL\n");                            exit(0);                }    }         int main(int argc, char *argv[])    {                sighandler_t h_ret;                h_ret = signal(SIGKILL, sig_handler);                if (h_ret == SIG_ERR) {                            perror("SIG_ERR");                }                return 0;    }    
# ./reg_sigkill    SIG_ERR: Invalid argument最后，我用下面这段代码slate-object="inline"来做个小结。这段代码里，我们用 signal() 对 SIGTERM这个信号做了忽略，捕获以及恢复它的缺省行为，并且每一次都用 kill()系统调用向进程自己发送 SIGTERM 信号，这样做可以确认进程对 SIGTERM信号的选择。    #include     #include     typedef void (*sighandler_t)(int);    void sig_handler(int signo)    {            if (signo == SIGTERM) {                    printf("received SIGTERM\n\n");                    // Set SIGTERM handler to default                    signal(SIGTERM, SIG_DFL);            }    }    int main(int argc, char *argv[])    {            //Ignore SIGTERM, and send SIGTERM            // to process itself.            signal(SIGTERM, SIG_IGN);            printf("Ignore SIGTERM\n\n");            kill(0, SIGTERM);            //Catch SIGERM, and send SIGTERM            // to process itself.            signal(SIGTERM, sig_handler);            printf("Catch SIGTERM\n");            kill(0, SIGTERM);                 //Default SIGTERM. In sig_handler, it sets            //SIGTERM handler back to default one.            printf("Default SIGTERM\n");            kill(0, SIGTERM);            return 0;    }我们一起来总结一下刚才讲的两个系统调用：先说说 kill()这个系统调用，它其实很简单，输入两个参数：进程号和信号，就把特定的信号发送给指定的进程了。再说说 signal()这个调用，它决定了进程收到特定的信号如何来处理，SIG_DFL参数把对应信号恢复为缺省 handler，也可以用自定义的函数作为handler，或者用 SIG_IGN参数让进程忽略信号。对于 SIGKILL 信号，如果调用 signal() 函数，为它注册自定义的handler，系统就会拒绝。解决问题我们在学习了 kill() 和 signal()这个两个信号相关的系统调用之后，再回到这一讲最初的问题上，为什么在停止一个容器的时候，容器init 进程收到的 SIGTERM 信号，而容器中其他进程却会收到 SIGKILL信号呢？ 当 Linux 进程收到 SIGTERM 信号并且使进程退出，这时 Linux内核对处理进程退出的入口点就是 do_exit() 函数，do_exit()函数中会释放进程的相关资源，比如内存，文件句柄，信号量等等。Linux 内核对处理进程退出的入口点就是 do_exit() 函数，do_exit()函数中会释放进程的相关资源，比如内存，文件句柄，信号量等等。在做完这些工作之后，它会调用一个 exit_notify()函数，用来通知和这个进程相关的父子进程等。对于容器来说，还要考虑 Pid Namespace 里的其他进程。这里调用的就是zap_pid_ns_processes() 这个函数，而在这个函数中，如果是处于退出状态的init 进程，它会向 Namespace 中的其他进程都发送一个 SIGKILL信号。 整个流程如下图所示。![](Images/919c1923e68406ec62be8bb089495c1d.png)savepage-src="https://static001.geekbang.org/resource/image/c1/a7/c1e81208784d10ef370b9fd753d2c3a7.jpg"}你还可以看一下，内核代码是这样的。        /*             * The last thread in the cgroup-init thread group is terminating.             * Find remaining pid_ts in the namespace, signal and wait for them             * to exit.             *             * Note:  This signals each threads in the namespace - even those that             *        belong to the same thread group, To avoid this, we would have             *        to walk the entire tasklist looking a processes in this             *        namespace, but that could be unnecessarily expensive if the             *        pid namespace has just a few processes. Or we need to             *        maintain a tasklist for each pid namespace.             *             */            rcu_read_lock();            read_lock(&tasklist_lock);            nr = 2;            idr_for_each_entry_continue(&pid_ns->idr, pid, nr) {                    task = pid_task(pid, PIDTYPE_PID);                    if (task && !__fatal_signal_pending(task))                            group_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);            }说到这里，我们也就明白为什么容器 init 进程收到的 SIGTERM信号，而容器中其他进程却会收到 SIGKILL信号了。 前面我讲过，SIGKILL 是个特权信号（特权信号是 Linux 为 kernel和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获）。所以进程收到这个信号后，就立刻退出了，没有机会调用一些释放资源的handler 之后，再做退出动作。而 SIGTERM 是可以被捕获的，用户是可以注册自己的 handler的。因此，容器中的程序在 stop container 的时候，我们更希望进程收到SIGTERM 信号而不是 SIGKILL信号。 那在容器被停止的时候，我们该怎么做，才能让容器中的进程收到 SIGTERM信号呢？ 你可能已经想到了，就是让容器 init 进程来转发 SIGTERM信号。的确是这样，比如 Docker Container 里使用的 tini 作为 init进程，tini 的代码中就会调用 sigtimedwait()这个函数来查看自己收到的信号，然后调用 kill()把信号发给子进程。我给你举个具体的例子说明，从下面的这段代码中，我们可以看到除了SIGCHLD 这个信号外，tini会把其他所有的信号都转发给它的子进程。     int wait_and_forward_signal(sigset_t const* const parent_sigset_ptr, pid_t const child_pid) {            siginfo_t sig;            if (sigtimedwait(parent_sigset_ptr, &sig, &ts) == -1) {                    switch (errno) {    …                    }            } else {                    /* There is a signal to handle here */                    switch (sig.si_signo) {                            case SIGCHLD:                                    /* Special-cased, as we don't forward SIGCHLD. Instead, we'll                                     * fallthrough to reaping processes.                                     */                                    PRINT_DEBUG("Received SIGCHLD");                                    break;                            default:                                    PRINT_DEBUG("Passing signal: '%s'", strsignal(sig.si_signo));                                    /* Forward anything else */                                    if (kill(kill_process_group ? -child_pid : child_pid, sig.si_signo)) {                                            if (errno == ESRCH) {                                                    PRINT_WARNING("Child was dead when forwarding signal");                                            } else {                                                    PRINT_FATAL("Unexpected error when forwarding signal: '%s'", strerror(errno));                                                    return 1;                                            }                                    }                                    break;                    }            }            return 0;    }那么我们在这里明确一下，怎么解决停止容器的时候，容器内应用程序被强制杀死的问题呢？**解决的方法就是在容器的 init进程中对收到的信号做个转发，发送到容器中的其他子进程，这样容器中的所有进程在停止时，都会收到SIGTERM，而不是 SIGKILL信号了。** 重点小结这一讲我们要解决的问题是让容器中的进程，在容器停止的时候，有机会graceful shutdown，而不是收到 SIGKILL信号而被强制杀死。首先我们通过对 kill() 和 signal()这个两个系统调用的学习，进一步理解了进程是怎样处理 Linux信号的，重点是信号在接收处理的三个选择：**忽略，捕获和缺省行为**。通过代码例子，我们知道 SIGTERM 是可以被忽略和捕获的，但是 SIGKILL是不可以被忽略和捕获的。了解这一点以后，我们就找到了问题的解决方向，也就是我们需要在停止容器时，让容器中的应用收到SIGTERM，而不是 SIGKILL。具体怎么操作呢？我们可以在容器的 init进程中对收到的信号做个转发，发送到容器中的其他子进程。这样一来，容器中的所有进程在停止容器时，都会收到SIGTERM，而不是 SIGKILL信号了。 我认为，解决 init进程信号的这类问题其实并不难。我们只需要先梳理一下和这个问题相关的几个知识点，再写个小程序，让它跑在容器里，稍微做几个试验。然后，我们再看一下内核和Docker的源代码，就可以很快得出结论了。思考题请你回顾一下基本概念中最后的这段代码，你可以想一想，在不做编译运行的情况下，它的输出是什么？    #include     #include     typedef void (*sighandler_t)(int);    void sig_handler(int signo)    {            if (signo == SIGTERM) {                    printf("received SIGTERM\n\n");                    // Set SIGTERM handler to default                    signal(SIGTERM, SIG_DFL);            }    }    int main(int argc, char *argv[])    {            //Ignore SIGTERM, and send SIGTERM            // to process itself.            signal(SIGTERM, SIG_IGN);            printf("Ignore SIGTERM\n\n");            kill(0, SIGTERM);            //Catch SIGERM, and send SIGTERM            // to process itself.            signal(SIGTERM, sig_handler);            printf("Catch SIGTERM\n");            kill(0, SIGTERM);                 //Default SIGTERM. In sig_handler, it sets            //SIGTERM handler back to default one.            printf("Default SIGTERM\n");            kill(0, SIGTERM);            return 0;    }欢迎留言和我分享你的想法和疑问。如果读完这篇文章有所收获，也欢迎你分享给自己的朋友，共同学习和进步。
# 05｜容器CPU（1）：怎么限制容器的CPU使用？你好，我是程远。从这一讲开始，我们进入容器 CPU这个模块。 我在第一讲中给你讲过，容器在 Linux 系统中最核心的两个概念是 Namespace和 Cgroups。我们可以通过 Cgroups技术限制资源。这个资源可以分为很多类型，比如CPU，Memory，Storage，Network等等。而计算资源是最基本的一种资源，所有的容器都需要这种资源。那么，今天我们就先聊一聊，怎么限制容器的 CPU使用？ 我们拿 Kubernetes 平台做例子，具体来看下面这个 pod/container 里的spec 定义，在 CPU 资源相关的定义中有两项内容，分别是 **RequestCPU**  和 **LimitCPU**。    apiVersion: v1    kind: Pod    metadata:      name: frontend    spec:      containers:      - name: app        image: images.my-company.example/app:v4        env:        resources:          requests:            memory: "64Mi"            cpu: "1"          limits:            memory: "128Mi"            cpu: "2"    …很多刚刚使用 Kubernetes的同学，可能一开始并不理解这两个参数有什么作用。这里我先给你说结论，在 Pod Spec 里的\"Request CPU\"和\"LimitCPU\"的值，最后会通过 CPU Cgroup 的配置，来实现控制容器 CPU资源的作用。那接下来我会先从进程的 CPU 使用讲起，然后带你在 CPU Cgroup子系统中建立几个控制组，用这个例子为你讲解 CPU Cgroup中的三个最重要的参数\"cpu.cfs_quota_us\"\"cpu.cfs_period_us\"\"cpu.shares\"。相信理解了这三个参数后，你就会明白我们要怎样限制容器 CPU的使用了。 如何理解 CPU 使用和 CPU Cgroup？既然我们需要理解 CPU Cgroup，那么就有必要先来看一下 Linux 里的 CPU使用的概念，这是因为 CPU Cgroup 最大的作用就是限制 CPU使用。 CPU 使用的分类如果你想查看 Linux 系统的 CPU使用的话，会用什么方法呢？最常用的肯定是运行 Top了。 我们对照下图的 Top运行界面，在截图第三行，\"%Cpu(s)\"开头的这一行，你会看到一串数值，也就是\"0.0us, 0.0 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0st\"，那么这里的每一项值都是什么含义呢？![](Images/3b01badf86f310a1d1f10f4b7e9c0381.png)savepage-src="https://static001.geekbang.org/resource/image/a6/c2/a67fae56ce2f4e7078d552c58c9f9dc2.png"}下面这张图里最长的带箭头横轴，我们可以把它看成一个时间轴。同时，它的上半部分代表Linux 用户态（User space），下半部分代表内核态（Kernelspace）。这里为了方便你理解，我们先假设只有一个 CPU吧。 ![](Images/9515e60d11766c6b2e4481af6bd382e8.png)savepage-src="https://static001.geekbang.org/resource/image/7d/99/7dbd023628f5f4165abc23c1d67aca99.jpeg"}我们可以用上面这张图，把这些值挨个解释一下。假设一个用户程序开始运行了，那么就对应着第一个\"us\"框，\"us\"是\"user\"的缩写，代表Linux 的用户态 CPUUsage。普通用户程序代码中，只要不是调用系统调用（SystemCall），这些代码的指令消耗的 CPU就都属于\"us\"。当这个用户程序代码中调用了系统调用，比如说 read()去读取一个文件，这时候这个用户进程就会从用户态切换到内核态。内核态 read() 系统调用在读到真正 disk上的文件前，就会进行一些文件系统层的操作。那么这些代码指令的消耗就属于\"sy\"，这里就对应上面图里的第二个框。\"sy\"是\"system\"的缩写，代表内核态 CPU使用。 接下来，这个 read() 系统调用会向 Linux 的 Block Layer 发出一个 I/ORequest，触发一个真正的磁盘读取操作。这时候，这个进程一般会被置为 TASK_UNINTERRUPTIBLE。而 Linux会把这段时间标示成\"wa\"，对应图中的第三个框。\"wa\"是\"iowait\"的缩写，代表等待I/O 的时间，这里的 I/O 是指 DiskI/O。 紧接着，当磁盘返回数据时，进程在内核态拿到数据，这里仍旧是内核态的CPU使用中的\"sy\"，也就是图中的第四个框。然后，进程再从内核态切换回用户态，在用户态得到文件数据，这里进程又回到用户态的CPU使用，\"us\"，对应图中第五个框。好，这里我们假设一下，这个用户进程在读取数据之后，没事可做就休眠了。并且我们可以进一步假设，这时在这个CPU上也没有其他需要运行的进程了，那么系统就会进入\"id\"这个步骤，也就是第六个框。\"id\"是\"idle\"的缩写，代表系统处于空闲状态。如果这时这台机器在网络收到一个网络数据包，网卡就会发出一个中断（interrupt）。相应地，CPU会响应中断，然后进入中断服务程序。这时，CPU 就会进入\"hi\"，也就是第七个框。\"hi\"是\"hardwareirq\"的缩写，代表 CPU处理硬中断的开销。由于我们的中断服务处理需要关闭中断，所以这个硬中断的时间不能太长。但是，发生中断后的工作是必须要完成的，如果这些工作比较耗时那怎么办呢？Linux中有一个软中断的概念（softirq），它可以完成这些耗时比较长的工作。你可以这样理解这个软中断，从网卡收到数据包的大部分工作，都是通过软中断来处理的。那么，CPU就会进入到第八个框，\"si\"。这里\"si\"是\"softirq\"的缩写，代表 CPU处理软中断的开销。这里你要注意，无论是\"hi\"还是\"si\"，它们的 CPU 时间都不会计入进程的CPU 时间。**这是因为本身它们在处理的时候就不属于任何一个进程。**好了，通过这个场景假设，我们介绍了大部分的 Linux CPU使用。 不过，我们还剩两个类型的 CPU使用没讲到，我想给你做个补充，一次性带你做个全面了解。这样以后你解决相关问题时，就不会再犹豫，这些值到底影不影响CPU Cgroup中的限制了。下面我给你具体讲一下。一个是\"ni\"，是\"nice\"的缩写，这里表示如果进程的 nice值是正值（1-19），代表优先级比较低的进程运行时所占用的CPU。 另外一个是\"st\"，\"st\"是\"steal\"的缩写，是在虚拟机里用的一个 CPU使用类型，表示有多少时间是被同一个宿主机上的其他虚拟机抢走的。综合前面的内容，我再用表格为你总结一下：![](Images/bfff882d1d32e3d1d6b72eae52df2814.png)savepage-src="https://static001.geekbang.org/resource/image/a4/a3/a4f537187a16e872ebcc605d972672a3.jpeg"}CPU Cgroup在第一讲中，我们提到过 Cgroups 是对指定进程做计算机资源限制的，CPUCgroup 是 Cgroups 其中的一个 Cgroups 子系统，它是用来限制进程的 CPU使用的。 对于进程的 CPU 使用, 通过前面的 Linux CPU使用分类的介绍，我们知道它只包含两部分: 一个是用户态，这里的用户态包含了us 和 ni；还有一部分是内核态，也就是sy。 至于 wa、hi、si，这些 I/O 或者中断相关的 CPU 使用，CPU Cgroup不会去做限制，那么接下来我们就来看看 CPU Cgoup是怎么工作的？每个 Cgroups子系统都是通过一个虚拟文件系统挂载点的方式，挂到一个缺省的目录下，CPUCgroup 一般在 Linux 发行版里会放在`/sys/fs/cgroup/cpu`这个目录下。在这个子系统的目录下，每个控制组（Control Group）都是一个子目录，各个控制组之间的关系就是一个树状的层级关系（hierarchy）。比如说，我们在子系统的最顶层开始建立两个控制组（也就是建立两个目录）group1和 group2，然后再在 group2 的下面再建立两个控制组 group3 和group4。 这样操作以后，我们就建立了一个树状的控制组层级，你可以参考下面的示意图。![](Images/d74d6249f9de2cad802fccfeb878c890.png)savepage-src="https://static001.geekbang.org/resource/image/8b/54/8b86bc86706b0bbfe8fe157ee21b6454.jpeg"}那么我们的每个控制组里，都有哪些 CPU Cgroup相关的控制信息呢？这里我们需要看一下每个控制组目录中的内容：     
# pwd    /sys/fs/cgroup/cpu    
# mkdir group1 group2    
# cd group2    
# mkdir group3 group4    
# cd group3    
# ls cpu.*    cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat 考虑到在云平台里呢，大部分程序都不是实时调度的进程，而是普通调度（SCHED_NORMAL）类型进程，那什么是普通调度类型呢？因为普通调度的算法在 Linux 中目前是 CFS （Completely FairScheduler，即完全公平调度器）。为了方便你理解，我们就直接来看 CPU Cgroup和 CFS 相关的参数，一共有三个。第一个参数是 **cpu.cfs_period_us**，它是 CFS 算法的一个调度周期，一般它的值是 100000，以microseconds 为单位，也就100ms。 第二个参数是 **cpu.cfs_quota_us**，它"表示 CFS算法中，在一个调度周期里这个控制组被允许的运行时间，比如这个值为 50000时，就是 50ms。如果用这个值去除以调度周期（也就是 cpu.cfs_period_us），50ms/100ms =0.5，这样这个控制组被允许使用的 CPU 最大配额就是 0.5 个CPU。 从这里能够看出，cpu.cfs_quota_us 是一个绝对值。如果这个值是200000，也就是 200ms，那么它除以 period，也就是200ms/100ms=2。你看，结果超过了 1 个 CPU，这就意味着这时控制组需要 2 个 CPU的资源配额。我们再来看看第三个参数， **cpu.shares**。这个值是 CPU Cgroup 对于控制组之间的 CPU分配比例，它的缺省值是 1024。假设我们前面创建的 group3 中的 cpu.shares 是 1024，而 group4 中的cpu.shares 是 3072，那么group3:group4=1:3。这个比例是什么意思呢？我还是举个具体的例子来说明吧。在一台 4 个 CPU 的机器上，当 group3 和 group4 都需要 4 个 CPU的时候，它们实际分配到的 CPU 分别是这样的：group3 是 1 个，group4 是 3个。 我们刚才讲了 CPU Cgroup里的三个关键参数，接下来我们就通过几个例子来进一步理解一下，代码你可以在这里slate-object="inline"找到。第一个例子，我们启动一个消耗 2 个 CPU（200%）的程序threads-cpu，然后把这个程序的 pid 加入到 group3的控制组里：    ./threads-cpu/threads-cpu 2 &    echo $! > /sys/fs/cgroup/cpu/group2/group3/cgroup.procs 在我们没有修改 cpu.cfs_quota_us 前，用 top 命令可以看到 threads-cpu这个进程的 CPU 使用是 199%，近似 2 个CPU。 ![](Images/648acfbc5c65f5b8c71f97d89f5d57a3.png)savepage-src="https://static001.geekbang.org/resource/image/1e/b8/1e95db3f15fc4cf1573f8ebe22db38b8.png"}然后，我们更新这个控制组里的 cpu.cfs_quota_us，把它设置为150000（150ms）。把这个值除以 cpu.cfs_period_us，计算过程是150ms/100ms=1.5, 也就是 1.5 个 CPU，同时我们也把 cpu.shares 设置为1024。     echo 150000 > /sys/fs/cgroup/cpu/group2/group3/cpu.cfs_quota_us    echo 1024 > /sys/fs/cgroup/cpu/group2/group3/cpu.shares这时候我们再运行 top，就会发现 threads-cpu 进程的 CPU 使用减小到了150%。这是因为我们设置的 cpu.cfs_quota_us 起了作用，限制了进程 CPU的绝对值。 但这时候 cpu.shares 的作用还没有发挥出来，因为 cpu.shares是几个控制组之间的 CPU 分配比例，而且一定要到整个节点中所有的 CPU都跑满的时候，它才能发挥作用。![](Images/1a78305f2b6e82c0af20d0d5ab107150.png)savepage-src="https://static001.geekbang.org/resource/image/3c/7e/3c153bba9d7668c22048602d730d627e.png"}好，下面我们再来运行第二个例子来理解cpu.shares。我们先把第一个例子里的程序启动，同时按前面的内容，一步步设置好group3 里 cpu.cfs_quota_us 和cpu.shares。设置完成后，我们再启动第二个程序，并且设置好 group4 里的cpu.cfs_quota_us 和cpu.shares。group3：     ./threads-cpu/threads-cpu 2 &  
# 启动一个消耗2个CPU的程序    echo $! > /sys/fs/cgroup/cpu/group2/group3/cgroup.procs #把程序的pid加入到控制组    echo 150000 > /sys/fs/cgroup/cpu/group2/group3/cpu.cfs_quota_us #限制CPU为1.5CPU    echo 1024 > /sys/fs/cgroup/cpu/group2/group3/cpu.shares group4：     ./threads-cpu/threads-cpu 4 &  
# 启动一个消耗4个CPU的程序    echo $! > /sys/fs/cgroup/cpu/group2/group4/cgroup.procs #把程序的pid加入到控制组    echo 350000 > /sys/fs/cgroup/cpu/group2/group4/cpu.cfs_quota_us  #限制CPU为3.5CPU    echo 3072 > /sys/fs/cgroup/cpu/group2/group3/cpu.shares 