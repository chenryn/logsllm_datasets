![alt](images/00446.jpeg){.calibre3}
"-E"参数的意思就是让gcc只对main.c进行预处理。这样处理后的结果会直接输出到标准输出，不方便查看。所以我们需要进行输出转向，把输出的内容存进hello_cpp.c文件里。打开这个文件你就会发现，仅仅几行的程序，预处理后变成了800多行！
![alt](images/00011.jpeg){.tpzz}**提示：**[gcc是调用cpp命令来进行预处理，因此也可直接用cpp命令进行预处理，运行以下命令：]{.kai1}
![alt](images/00447.jpeg){.calibre3}
效果与"gcc --E"相同。
这800多行就是因为这段代码包含了stdio.h文件，stdio.h文件又包含了很多其他的.h文件，于是在预处理的时候，cpp就把这些.h文件全部粘贴了进来（但其实都没什么用，我们只用到了其中的printf()函数）。
预编译后的文件大约就是下面这个样子：
![alt](images/00448.jpeg){.calibre3}
当然，这里面省略了很多。我们主要关注的是cpp将我们定义的TOTAL_NUMBER这个宏，替换成了数字18353226了。
这样经过了cpp预处理之后的文件，就该交给gcc去编译了。
【施工第2步------编译】
编译又是什么意思呢？
最初的图纸，也就是没有经过预处理的源代码，那是人写的。一般懂相关语言（比如C语言）的人都能看懂。预处理之后的文件，虽然不那么直观了（TOTAL_NUMBER看着是不是比18353226直观？光写个18353226还以为是谁的QQ号呢），但终究只是做了下替换，还是人类可以看懂的。而经过编译之后的代码是什么样子呢？还以刚才那个hello.c做例子，运行：
![alt](images/00449.jpeg){.calibre3}
"-S"参数就是告诉gcc，只对文件进行预处理和编译的步骤。这样最终会得到一个hello.s文件，这个文件里就是经过了cpp的预处理，并由gcc进行编译之后的代码了，大约是下面的样子：
![alt](images/00450.jpeg){.calibre3}
这样的代码，就不是普通人类可以看懂的源代码，而是只有终极牛人才能读懂的汇编代码了。汇编代码比较贴近底层的机器码，里面描述的都是一些基本的操作，以机器的思维来描述整个程序。
打个比方。就比如描述切黄瓜的过程，用C语言描述出来就像是"将黄瓜切片"，这么一句就搞定了。要是用汇编，那就是："左手扶住黄瓜，右手拿起刀，移动刀到黄瓜顶部，刀落下，刀抬起。刀向黄瓜后部移动3毫米，刀落下，刀抬起。刀再向黄瓜后部移动3毫米，刀再落下，刀再抬起。放下刀，走出厨房，走进卧室，找到创可贴，贴在左手食指上......"总之，汇编是一种面向机器的，很复杂的程序设计语言。gcc的任务就是把C语言的源代码转换成贴近机器语言的汇编代码，为下一步as的工作做好准备。
【施工第3步------汇编】
as拿到汇编代码后，要对这样的代码再进行处理，得到真正的机器码。这个处理的过程，也叫汇编。
如果说进行汇编之前的汇编代码是终极牛人才能看懂的，那么经过as汇编之后，得到的机器码压根就不是人能看懂的了。而且从.c的源码文件一直到汇编之前的.s文件都是文本格式的，进行汇编之后就成为二进制的elf格式了。这就不是普通的文本编辑器可以打开的了，需要用专门的软件将其转换为16进制数据查看。转换过来之后大约就是如图8.1所示的样子。
![alt](images/00451.jpeg){.calibre3}
图8.1 汇编后的文件
如果你想看看汇编后的机器码，那么可以运行命令：
![alt](images/00452.jpeg){.calibre3}
"-c"参数的意思大概您也猜到了，就是告诉gcc，只进行预处理、编译、汇编这3个步骤。这样运行之后会输出一个hello.o文件。如果想查看这个文件，运行：
![alt](images/00453.jpeg){.calibre3}
就可以看到一堆乱七八糟数字的机器码了。汇编程序中至少还有些操作的助记符，比如什么add，mov之类的。寄存器也是有名字的，比如叫eax，叫rbp等。但是到了机器码，这些都没有了，都换成了各种各样的数字，半句人话都没了。还以切黄瓜为例，要是用机器码来描述，就相当于说："用32号设备扶住87号物体，24号设备拿起126号物体，移动126号物体到87号物体顶部，做2635号动作，再做2636号动作......"
【施工第4步------链接】
好了，现在终于得到机器码了，机器码按说就是可以执行的代码了。但是，这时候的程序还是不能直接执行的，为什么？因为还有ld没有出场呢，他的工作叫：链接。
经过预处理、编译、汇编之后的二进制代码，按说已经是机器码了，可以直接运行。但是这里得到的机器码并不完整。就比如刚才说的这个hello.c文件，得到的机器码只是针对这个hello.c文件里面所写的这么点内容的。而这个hello.c里面还调用了printf()函数，这个函数是在系统的标准输入/输出库里面实现的。这部分负责真正向屏幕上打印字符的机器码如果不包含进来，这个程序怎么可能正常地实现功能呢？所以，就需要把这段标准库中的机器码和我们编译出来的机器码"链接"起来。
而且很多时候，一个程序不是一段机器码，而是由很多段机器码组成的。这些机器码分别保存成很多的.o文件，最终也需要把它们都"链接"起来才可以运行。
这时候就需要ld出场了。
ld负责把这些机器码组装起来，并且写明了各段代码的地址、从哪里开始执行之类的标记。就像我们造个机器人，脑袋、胳膊、大腿之类的都做好了，ld就是负责组装的。
经过ld组装的程序，就可以运行了。整个编译过程是不是挺复杂的？不过所幸我们的用户并不需要一步一步地手动做这些步骤，只运行gcc命令就全搞定了。
[8.2 修理工]{.kai}
程序编译出来只是第一步。编译好的程序不一定靠谱，可能会有各种各样的错误，这就需要进行调试。调试有很多方法，但肯定离不开调试工具。这回，懒蜗牛同学就要学习调试工具的使用了。
8.2.1 懒蜗牛的日记B
"2010年9月18日 变天
终于又到周末了。今天在自己的机器上学习编程，逐渐开始入门了。这一阵子最大的收获是学会了自学。通过网络、论坛搜索，也能学到不少有用的东西。像学编程吧，开发环境的搭建、循环结构、文字输入甚至创建进程，都尝试过了。看来编程也不是那么的困难嘛。不过我也知道这只是刚刚入门而已，真的写出个能用的程序和随便写个小程序玩玩还是有很大区别的。
今天写了个程序，不知道为什么，总是运行不起来。以前能够运行的程序可以用printf()函数打印出变量来看看，这个运行不起来的程序怎么调试呢？"
8.2.2 邪恶的程序
今天起床的时间似乎比平时晚了点，全体起床之后，懒蜗牛同学按部就班地叫来OO老先生记录下一些文字，之后又继续去创造他的rubbish系列程序去了。
【19号扰乱秩序】
这一阵子，我们的懒蜗牛真是笔耕不辍------哦，不对，应该是键盘不辍才对------先后制造了18个rubbish程序。不过很多都被蜗牛删除了，只留有几个：一个是8号。因为8号比较憨厚，性格温顺，不爱打架。还有一个16号。16号很安静，不爱多说话，有点冷漠，但是做起事情来一丝不苟，严格地执行命令。再就是17号很厉害，但是很自大，高傲，总跟别人发生矛盾。他好像和18号还有点什么关系，具体的我就不知道了。最后的18号是个美眉，长得很可爱，一头金发，本事也不错，我们大家看她都很顺眼。而现在懒蜗牛正在制造19号。不知道为什么，我总觉得即将到来的19号将是一个邪恶的坏家伙......
没过多长时间，19号出炉了。只见他起床之后，跑进内存，刚说了几句我是rubbish
19号之类的话之后，就开始乱动别人的东西。一会儿要去狐狸的内存空间里拿数据，一会又要往心有灵犀的地盘里存东西。当然，他的这些企图都没有得逞，要是连这样的小流氓都管不了，我还叫内核么。
【内核严明法纪】
我们这个工作间里面的空间管理是很严格的，谁的空间谁用，别人不能乱动。像19号这么目无法纪，影响他人工作的软件是不能容忍的。眼看着这邪恶的19号，和满工作间无辜受害的软件们，我终于忍无可忍！为了工作间的安宁，为了我稳定内核的荣誉，为了爱与正义，为了世界和平，为了部落，我代表月亮，我，我消灭了你！转眼间，手起刀落，只听咔嚓一声------整个世界安静了。19号被我斩为两段，然后我向懒蜗牛汇报：很遗憾，您的程序出现了段错误，就像图8.2显示的这样（因为他被砍成两段了，所以错误了）。
![alt](images/00454.jpeg){.calibre3}
图8.2 程序出现段错误
懒蜗牛似乎有些不明所以，不知道这个段错误是怎么回事（因为太血腥了，所以我没直说是因为被我剁成两段）。于是就赶紧叫来狐狸上网上查去。通过搜索知道了，段错误的情况有很多（很多种不老实的程序都会被我砍成两段），但大致上都是由于内存指针使用不当引起的。比如没有给指针赋值就去使用，或者虽然赋值但是访问越界等。总之就是动了你不该动的内存就会段错误。
可是到底这个19号是如何动了别人的空间的呢？他到底为什么要去访问非法的地址呢？这些情况虽然我们内存里的软件们看得一清二楚，铁证如山，但是懒蜗牛他不知道啊。他没法钻进内存里来看程序是怎么运行的。那么懒蜗牛能有什么办法看清楚19号的一举一动呢？这时候就需要我们的软件修理工GDB闪亮登场了。
8.2.3 GDB的简单使用
GDB是GNU
Debugger的缩写，也就是GNU调试器的意思。它和GCC一样，最初也是由Richard
Stallman设计并实现的。图8.3是GDB的吉祥物------一条鱼（不要问我为什么，问Stallman去）。GDB是一个字符界面的调试工具。用过VC的同学应该知道，在那里面调程序的时候可以进入debug模式，能够查看内存、单步执行之类的。我们Linux中，每个软件秉承着"只做一件事情，但做到最好"的原则，将调试这件事情交给了GDB来完成。
![alt](images/00455.jpeg){.calibre3}
图8.3 GDB的吉祥物
【编译出可被调试的程序】
GCC编译出来的程序可以通过GDB来运行，运行的时候，就可以执行设置断点、单步运行、查看变量、查看堆栈等操作。有了GDB，懒蜗牛同学就可以监视程序在内存里面的一举一动了。
不过GDB并不是像狗仔队那样想监视谁就监视谁。像狐狸啦，gedit这样的成品程序是不能被监视的。要想让某个程序被GDB监视，必须在制造他的时候------也就是编译的时候，留出给GDB控制的接口来，GDB才能监视那个程序的一举一动。您看过黑客帝国么？我们机器里的普通程序，就像是里面正常的自然人。而可以被GDB调试的程序就像Matrix世界中的人一样，脑袋后面有个接口，可以接进去控制。那么怎么给程序装这么个接口呢？很简单，就是在编译的时候加上参数"-g"，类似这样编译：
![alt](images/00456.jpeg){.calibre3}
懒蜗牛运行了这么一句，就创造出了脑袋后面有接口的rubbish
19号。之后就可以叫来GDB去调试他了。
![alt](images/00011.jpeg){.tpzz}**提示：**[没有加"-g"参数编译出来的二进制文件也可以被GDB调用并运行，但由于该文件中没有记录机器码与C语言源码的对应关系，因此无法进行设置断点、查看变量、查看源码等操作。]{.kai1}
【用GDB调试程序】
编译出了可调试的程序后，就要叫来GDB来运行它，像下面这样：
![alt](images/00457.jpeg){.calibre3}
于是，GDB就会接到命令，赶快掏出各种仪器和工具，并把19号拖进内存里（这时候19号可还没醒哦）。然后从一个大机器上抽出一个长长的电缆，插进19号脑袋后面的接口里，一切准备好之后，向懒蜗牛报告："一切准备就绪，可以开始了。"也就是打印出下面这样的信息：
![alt](images/00458.jpeg){.calibre3}