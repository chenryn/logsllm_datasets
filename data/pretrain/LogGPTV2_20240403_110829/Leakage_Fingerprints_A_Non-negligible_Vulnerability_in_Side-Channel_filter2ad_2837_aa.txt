title:Leakage Fingerprints: A Non-negligible Vulnerability in Side-Channel
Analysis
author:Zeyi Liu and
Neng Gao and
Chenyang Tu and
Jian Zhou and
Yuan Ma and
Yuan Zhao
Leakage Fingerprints – A Non-negligible Vulnerability
in Side-Channel Analysis
Zeyi Liu1,2,3, Neng Gao1,2, Chenyang Tu1,2, Jian Zhou1,2
∗
, Yuan Ma1,2, Yuan Zhao1,2,3
1Data Assurance and Communication Security Research Center,
Chinese Academy of Sciences, Beijing, China
2State Key Laboratory of Information Security, Institute of Information Engineering,
Chinese Academy of Sciences, Beijing, China
3University of Chinese Academy of Sciences, Beijing, China
Email: {liuzeyi, gaoneng}@iie.ac.cn, PI:EMAIL
{zhoujian, mayuan, zhaoyuan}@iie.ac.cn
ABSTRACT
Low-entropy masking schemes and shuﬄing technique are t-
wo common countermeasures against traditional side-channel
analysis.
Improved Rotating S-box Masking (RSM) is a
combination of both countermeasures and is implemented
by DPA contest committee to improve the software security
level of AES-128. Compared with the original version,
improved RSM mainly introduces both the oﬀset and shuﬄe
array as security foundations to counteract the existing
attacks.
In this paper, we ﬁrst point out a general
vulnerability referred to as “leakage ﬁngerprints” and make
use of it to successfully crack the oﬀset array with 100%
accuracy, which breaks down the masking countermeasure
in the ﬁrst step. Then, we show that cracking the shuﬄe
array is still feasible but not necessary since several other
vulnerabilities in the implementation level can be exploited
to bypass the shuﬄe countermeasure directly. By selectively
combining all these vulnerabilities, a dozen of attacks can
be put forward, and we perform two of them as examples
to verify their eﬀectiveness. Oﬃcial evaluation results show
that, both attacks submitted by us are practical and feasible,
and also operate with high eﬃciency. In terms of two major
performance metrics, our best scheme requires 4 traces to
reveal the AES master key with 80% Global Success Rate
(GSR) and only 2 traces are enough to reduce the Maximum
Partial Guessing Entropy (PGE) under 10.
Keywords
Side-channel analysis; leakage ﬁngerprints; Euclidean dis-
tance; DPA Contest V4.2; low entropy masking schemes;
shuﬄing
∗This author is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS ’16, May 30-June 03, 2016, Xi’an, China
c(cid:13) 2016 ACM. ISBN 978-1-4503-4233-9/16/05. . . $15.00
DOI: http://dx.doi.org/10.1145/2897845.2897868
1.
INTRODUCTION
Counteracting the power analysis attacks proposed by
Kocher [10] is a must for modern cryptographic devices.
Masking [7, 8, 19] and hiding [14, 21, 24] are two types
of countermeasures widely studied to thwart this kind
of attacks. By introducing random numbers, masking
scheme randomizes the intermediate values being processed,
thus cutting oﬀ the dependency between the sensitive
intermediate value and the power leakage. While hiding
technique usually disorders the instruction sequence in time
dimension or compensates the regularly changed power
consumption in amplitude dimension in order to hide the
actual power ﬂuctuations as stated in [13].
According to the number of mask usage, masking schemes
can be roughly separated into two classes, namely full
entropy masking schemes (FEMS) and low entropy mask-
ing schemes(LEMS). The major drawbacks of FEMS that
restrict its application in resource-constrained devices, such
as microcontrollers or smart cards, are the computation
and storage burden of masked S-box tables (or masking
tables). Taking AES as an example, in FEMS, oﬄine pre-
computation will generate 2562 masking tables in total since
both input and output mask determine a unique table [17],
and each of them needs 256 bytes space for storage which
in total exceeds the volume of most embedded devices with
constrained resources. Online computation used to be an
alternative solution, however recent work in [22] has already
shown the risk it may take due to the mask reuse in
computing masked S-boxes. Because of all these limits and
risks, reducing the entropy of the mask becomes a tendency
and is studied worldwide to achieve the tradeoﬀ between
security and performance overhead [9, 16]. On the other
hand, shuﬄing [24] and DRP (dual-rail pre-charge logic
styles [21]) are two classic hiding methods used in time and
amplitude dimensions respectively. Compared with DRP
which is dedicated in hardware platform, shuﬄing technique,
which means the disorder of the operational sequence, is
more general and can be easily deployed both in software
and hardware platform with the help of random number
generators (RNG). In this article, we mainly focus on the
shuﬄing countermeasure in software implementation.
Improved RSM [3] is a typical example armed with both
LEMS and shuﬄing technique in order to repair the known
807loopholes detected under the original RSM [16]. Its software
implementation and measurement of power consumption on
an ATMega-163 smart-card are provided by DPA contest
v4.2 committee and are available for researchers worldwide
to analyze its security in practice. Compared with the
original version, improved RSM expands one byte random
oﬀset into an array of 16 and meanwhile introduces shuﬄe
array to further improve its security level. Each oﬀset
byte within the array independently determines one mask
index, thus disrupting the sequential relation of mask
usage within each round. By this means, it is impossible
to exploit the obvious diﬀerence of power consumptions
between mask 0xFF and 0x00 for oﬀset recovery [11] and it’s
also impossible to perform two kinds of constructive collision
attacks proposed in the same article. At the same time,
the employment of shuﬄe array disorders the predictable
sequence of masked S-box execution both in the ﬁrst and
last round, thus eliminating the common attacking points
for master key recovery in case of the compromise of oﬀset
array. Besides, the novel and constructive ﬁrst-order attack
proposed in [16] is also taken seriously and prevented in the
implementation layer. By rewriting the implementation in
assembly code and precharging the speciﬁc state registers
before overwritten by new numbers, the exploitation of
hamming distance leakage between the input and output
of masked S-box does not work anymore.
To the best of our knowledge, no article has been pub-
lished yet to systematically analyse the practical security of
RSM2.0 and it’s the ﬁrst article to present in detail most of
the vulnerabilities hidden in RSM2.0. Although some other
schemes have also been submitted to launch attacks, most
of the description about their methods is quite ambiguous.
Judging from both the brief descriptions and their evaluation
results, we believe that most of the pitfalls pointed out in
this article are still unknown and underutilized.
Our contribution mainly lies in the following aspects. We
present a general framework to exploit the proposed leakage
ﬁngerprint which is deﬁned as a series of relevant leakages
corresponding to a unique hidden secret in one encryption
(or decryption) operation. On the basis of this framework,
two schemes are developed to launch the identiﬁcation
process against oﬀset array, one of which indeed makes use
of the feature of RSM structure and repairing it may risks
sharp increase in the performance overhead. Then, some
evaluations are also performed to verify the robustness of
our framework in the possible noise environment.
Besides, we present several attacking points newly found
and demonstrate that, on the completion of cracking oﬀset
array, a traditional power analysis is capable to fetch the
secret key without attacking shuﬄing countermeasure due
to the careless deployment of shuﬄe protection. One step
further, though not necessary, we still show the way to
compromise the shuﬄe defense to further demonstrate the
threats of the proposed leakage ﬁngerprints.
Organization of the Paper. The rest of the paper is
organized as follows. We begin in Sec.2 by reviewing the
detailed process of improved RSM, especially the features
newly added to protect the implementation from some
obvious and known attacks. Afterwards, in Sec.3, we build
the framework for leakage ﬁngerprint exploitation, and show
our attacks to crack both the oﬀset and the shuﬄe array
with only one trace. Besides, the robustness evaluations for
our ﬁngerprint exploitation framework are also done in this
section.
In Sec.4 we analyze the hidden attacking points
which can be used to bypass the shuﬄe countermeasure.
Following on from that, we show more details of our attacks
in Sec.5 together with the oﬃcial evaluation results. Finally,
we conclude our work in the last section of the article.
2.
IMPROVED RSM COUNTERMEASURE
In this section, we recall the detailed process of improved
RSM, including the new features brought in, mask array
newly altered and some other signiﬁcant diﬀerences in
contrast with the original RSM. Notice that, for convenience
of expression, “modulo 16” is omitted after all the addition
operation shown hereafter and RSM2.0 is used as an abbre-
viation for improved RSM.
2.1 RSM2.0 Algorithm Description
Improved RSM is a Boolean masking scheme on the
basis of standard AES-1281 described in NIST FIPS 197
[18]. The security of this improved version against classical
side-channel analysis completely depends on three arrays,
namely, mask array, oﬀset array and shuﬄe array, which are
referred to as M[], O() and Sf[] respectively in this article.
Mask array is ﬁxed and publicly known in the algorithm
design. It consists of sixteen 8-bit values distinct from each
other, and is chosen meticulously with the goal to minimize
the mutual information leakage, as stated in [15]. The array
has been recently updated in July this year due to the
considerations of side-channel Indistinguishability as well as
security [5]. The latest array uses codewords of Hamming
weight {2, 4, 6} instead of the original {0, 4, 8}, and is
deﬁned as follows. Each individual value in M is noted as
M[i], i∈[0,15].
M = {0x03, 0x0c, 0x35, 0x3a, 0x50, 0x5f, 0x66, 0x69,
0x96, 0x99, 0xa0, 0xaf, 0xc5, 0xca, 0xf 3, 0xf c}
Oﬀset array varies in each trace and is kept secret from
attackers.
It contains sixteen values ranging from 0 to
15, and is newly introduced to cooperate with mask array,
providing the practical randomness of mask usage. More
precisely, each oﬀset value, noted as O(i), i∈[0,15], uniquely
determines a speciﬁc mask (namely M[O(i)]) which is later
Xored (bitwise exclusive-or) with the sensitive intermediate
value. Due to the uniform distribution O(i) complies with,
each M[O(i)] is also uniformly distributed among sixteen
alternatives, leading to a low entropy masking scheme of
four-bit entropy.
Shuﬄe array also changes trace by trace and is unknown
to analysts. Unlike oﬀset array, it is a random permutation
of [0,15] and is deployed to disorder the execution of S-boxes.
Actually, there are two separate shuﬄe arrays which are used
respectively on the ﬁrst and last round and are deﬁned as
Sf0[] and Sf10[] by us. That is, sixteen input bytes in round 0
and round 9 individually go through the substitutions layer
in sequence of Sf0[i] and Sf10[i] index respectively, where
i∈[0,15].
With three major arrays described above, ﬁve basic
modules of RSM2.0 can be explained as follows. Among
them, MaskCompensation is newly introduced in order
to get rid of the inﬂuence of masks when going through
1According to the latest version of oﬃcial source code [1],
AES-128 is used as a core algorithm instead of AES-256
which is presented in [3].
808the AES round function and MaskedSubBytes is special
in RSM2.0 with the basic idea of utilizing the masks in a
rotated method.
AddRoundKey(AR): bitwise exclusive-or (Xor) together
the round key and the masked state2 of each encryption
round, the same as the standard one in AES-128.
MaskedSubBytes(MS): as a non-linear layer, it consists
of sixteen masked S-boxes. Each of them derives from
the standard AES S-box to satisfy the traceability of
the output mask. That is to say, the purpose of each
MaskedSubByte is to map a masked intermediate value (like
X ⊕ M ) to an output with new and unique mask (like
X(cid:48)⊕ M(cid:48)). Such target can be met by reconstructing masked
S-boxes in the following form: M askedSubByteMM(cid:48) [X] =
SubByte[X ⊕ M ] ⊕ M(cid:48), where SubByte[ ] represents the
standard S-box in AES-128. Particularly in RSM design,
M and M(cid:48) are restricted to two consecutive values in
the M [], resulting in sixteen masked S-boxes in total,
namely M askedSubByteM [i]M [i+1], i ∈ [0, 15], which is the
origin of the name “Rotating S-boxes Masking (RSM)” .
To further simplify the representation, the ﬁnal form of
sixteen masked S-boxes is deﬁned as M askedSubBytei,
i ∈ [0, 15], where M askedSubBytei is the abbreviation for
M askedSubByteM [i]M [i+1].
ShiftRows(SR): Rotate left the four bytes in the ith row
by i bytes, i ∈[0, 3] which is the same as it does in standard
AES-128.
MixColumns(MC): The basic unit to perform this oper-
ation is a column of four bytes in the AES state. Due to
the linear characteristics of MixColumns layer, the masked
input column would be transformed into the output column
with newly refreshed masks. The following is an example:
M C(X1 ⊕ M 1, X2 ⊕ M 2, X3 ⊕ M 3, X4 ⊕ M 4)T =
M C(X1, X2, X3, X4)T ⊕ M C(M 1, M 2, M 3, M 4)T
where Xi and M i, i ∈ [1, 4] denote four input bytes
and masks respectively. Because of the calculability of the
output masks with input masks known, the following module
MaskCompensation can be properly operated.
MaskCompensation(MCP): as a bridge between suc-
cessive rounds, MaskCompensation takes place after Mix-
Columns layer has ﬁnished. In addition to the construction
of masked S-boxes in a rotating manner, another charac-
teristic of RSM2.0 is the form of input masks used in each
round. Corresponding to the AES state, sixteen input bytes
of round r are designed to be masked with M [O(i) + r],
where i ∈ [0, 15] and r ranges from 0 to 9, thus recycling
sixteen masks among 10 rounds of AES-128. We denote the
state of these input masks in round r as M askr which equals
toM [O(0)+r] M [O(4)+r] M [O(8)+r] M [O(12)+r]
M [O(1)+r] M [O(5)+r] M [O(9)+r] M [O(13)+r]
M [O(2)+r] M [O(6)+r] M [O(10)+r] M [O(14)+r]
M [O(3)+r] M [O(7)+r] M [O(11)+r] M [O(15)+r]
In order to achieve this goal, MaskCompensation operation
can be divided into three steps. First of all, the calculation of
output masks of MixColumns in each round should be done.
Right after that, the required input masks for the next round
are Xored in, obtaining a complete compensation state of
sixteen bytes, which we denote as M askCompensationr (or
2State denotes the basic data unit of 4 by 4 matrix, which
is the same as in standard AES
M CPr for short), where r belongs to [0, 8]:
M CPr = M C(SR(M askr+1)) ⊕ M askr+1
Finally, through the Xor of both the MixColumns output in
round r and M askCompensationr, output masks of Mix-
Columns in the current round are eliminated and replaced
with the input masks of the next round, which are able to
meet the design requirements. The following is a complete
formulas derivation to go through MaskCompensation layer
in round r, where (Xr ⊕ M askr) and Kr represent the
masked input state and the round key individually.
M C(SR(M S(Kr⊕Xr⊕M askr)))⊕Kr+1⊕M CPr
= M C(SR(SubBytes(Kr⊕Xr)⊕M askr+1))⊕Kr+1⊕M CPr
= M C(SR(SubBytes(Kr⊕Xr))) ⊕M C(SR(M askr+1))
⊕Kr+1⊕M C(SR(M askr+1))⊕M askr+1
= M C(SR(SubBytes(Kr ⊕ Xr)))⊕Kr+1 ⊕M askr+1
What calls for special attention is that the MixColumns
layer is excluded in the last encryption round (r = 9),
and also no input masks of the next round are needed
in order to gain the correct AES-128 ciphertext. Thus
M askCompensation9 is diﬀerent from those in the previous
rounds, and is calculated by the following formula:
M askCompensation9 = Shif tRows(M ask10)
Thus, the MaskCompensation of round 9 can be formal-
ized as shown below:
SR(M S(K9⊕X9⊕M ask9))⊕K10⊕M askCompensation9
= SR(SubBytes(K9⊕X9)⊕M ask10))⊕K10⊕SR(M ask10)
= SR(SubBytes(K9 ⊕ X9))⊕K10
= 128 − bit Ciphertext
With all these basic modules explained clearly, the de-
tailed algorithm of RSM-2.0 can be described as in Algo-
rithm1. Special note is that, the description of Algorithm1
complies with the latest version of oﬃcial source code, but
contains a list of diﬀerences as follows compared with the
algorithm description in [3]. First, AES-128 rather than
AES-256 is chosen as the target for protection. Then, the
generation of Shuﬄe0, Shuﬂle10 and Oﬀset array is not
recorded in the form of power consumption, and thus we
regard them as parts of the input parameters. Besides,
at the beginning of each encryption, key expansion is
performed ﬁrst with no protection. Although this kind of
unprotected implementation would lead to attacks like [12]
[23], they are not the main focus of this article, and we only
append this basic step in the description.
3. LEAKAGE FINGERPRINT
In this section, we ﬁrst give a precise deﬁnition of “leakage
ﬁngerprint” in the cryptographic implementation and then
we build a general model to formulate the process of
ﬁngerprint exploitation. Finally, we explain the threats it
would give rise to in RSM2.0.
3.1 Deﬁnition and General Model
As is widely known, the ﬁngerprint embedded in the
human body is a kind of texture feature which can be
used to uniquely identify an individual person. Similarly,
“leakage ﬁngerprint” in this article is deﬁned as a kind
809Algorithm 1 Improved Rotating S-boxes Masking
Input:
16-bytes plaintext X = [X0, X1, ..., X15];
One oﬀset array: O(i), i ∈ [0, 15];
Two shuﬄe arrays: Sf 0[i], Sf 10[i], i ∈ [0, 15];
Output:
16-bytes ciphertext X=[X0,X1,...,X15];
/*All rounds but the last one*/
Xi = M askedSubBytesO(i)+r(Xi)