6.2 Security
To measure the security oﬀered by our approach as com-
pared to the context-insensitive sanitization approach, we
count the number of sinks that would be auto-sanitized cor-
rectly in our 1035 templates. We assume that a context-
insensitive sanitization would supplement the HTML-entity
encoding sanitizer to all sinks, which is the approach adopted
in popular frameworks such as Django [14]. Picking an-
other sanitizer would only give worse results for the context-
596No
Saniti-
zation
Context-
Context-
Sensitive
Insensitive Runtime
Chrome 9.0
FF 3.6
Safari 5.0
Server:Java
# of Sinks
Auto-Prot.
227
395
190
431
0/ 1348
(0%)
234 (3.0%)
433 (9.6%)
195 (2.5%)
431 (0.0%)
982 / 1348
(72%)
Parsing
406 (78.8%)
2074 (425%)
550 (189%)
2972 (510%)
1348 / 1348
(100%)
Our
Approach
234 (3.0%)
433 (9.6%)
196 (3.1%)
431 (0.0%)
1348 / 1348
(100%)
Figure 11: Comparing the security and runtime overhead (ms.)
comparison between our approach and alternative existing ap-
proaches for server-side Java and client-side JavaScript code gen-
erated from our benchmarks. The last line shows the number of
sinks auto-protected by each approach.
Figure 12: Distribution of inserted sanitizers:
inferred contexts
and hence the inserted sanitizer counts vary largely, therefore
showing that context-insenstive sanitization is insuﬃcient.
insensitive scheme— we show that the most widely inserted
sanitizer in auto-sanitization on our benchmarks is also es-
capeHtml, the HTML-entity encoding sanitizer.
The last row in Figure 11 shows the number of sinks auto-
protected by existing approaches. Context-insensitive sani-
tization protects 72% of the total output prints adequately;
the auto-sanitization is insuﬃcient for the remaining 28%
output print opertions. Clearly, context-insensitive saniti-
zation oﬀers better protection than no sanitization strategy.
On the other hand, context-sensitive sanitization has full
protection whether the context-inference is performed dy-
namically or as in our static type inference approach. Fig-
ure 12 shows that the inferred sanitizers varied signiﬁcantly
based on context across the 1348 output points, showing the
inadequacy of context-insensitive sanitization.
6.3 Performance
We measure and compare the runtime overhead incurred
by our context-sensitive auto-sanitization to other approaches
and present the results in Figure 11. Google Closure Tem-
plates can be compiled both to JavaScript as well as Java.
We measure the runtime overhead for both cases. For com-
piled JavaScript functions, we record the time across 10 trial
runs in 3 major web browsers. For compiled Java functions,
we record the time across 10 trial runs under the same in-
puts.
The baseline “no auto-sanitization” approach overhead is
obtained by compiling vanilla templates with no developer’s
manual sanitizers applied. For our approach, we enable our
CSAS auto-sanitization implementation. To compare the
overhead of context-insensitive auto-sanitization, we simply
augment all output points with the escapeHtml sanitizer
during compilation. A direct comparison to Google Au-
toEscape, the only context-sensitive sanitization approach
in templating systems we know of, was not possible be-
cause it does not handle rich language features like if-else
and loops which create context ambiguities and are perva-
sive in our benchmarks; a detailed explanation is provided in
Section 7. To emulate the purely context-sensitive runtime
parsing (CSRP) approach, we implemented this technique
for our templating langauge. For Java, we directly used
an oﬀ-the-shelf parser without modiﬁcations from the open-
source Google AutoEscape implementation in GWT [15].
For JavaScript, since no similar parser was available, we
created a parser implementation mirroring the Java-based
parser. We believe our implementation was close to the
GWT’s public implementation for Java, since the overhead
is in the same ballpark range.
Results. For JavaScript as the compilation target, the time
taken for parsing and rendering the output of all the com-
piled template output (total 782.584 KB) in 3 major web
browsers, averaged over 10 runs, is shown in Figure 11. The
costs lie between 78% and 4.24x for the pure CSRP approach
and our approach incurs between 3− 9.6% overhead over no
sanitization. The primary reason for the diﬀerence between
our approach and CSRP approach is that the latter requires
a parsing of all constant string and context determination
of untrusted data at runtime— a large saving in our static
type inference approach. Our overhead in JavaScript is due
to the application of the sanitizer, which is why our sanitiza-
tion has nearly the same overhead as the context-insensitive
sanitization approach.
For Java, the pure CSRP approach has a 510% overhead,
whereas our approach and context-insensitive approach in-
cur no statistically discernable overhead. In summary, our
approach achieves the beneﬁts of context-sensitive sanitiza-
tion at the overhead comparable to a large fraction of other
widely used frameworks.
We point out that Closure templates capture the HTML
output logic with minimal subsidiary application logic —
therefore our benchmarks are heavy in string concatena-
tions and writes to output buﬀers. As a result, our bench-
marks are highly CPU intensive and the runtime costs eval-
uated here may be amortized in full-blown applications by
other latencies (computation of other logic, database ac-
cesses, network and ﬁle-system operations). For an esti-
mate, XSS-GUARD reports an overhead up to 42% for the
CSRP approach [5]. We believe our benchmarks are apt for
precisely measuring performance costs of the HTML out-
put logic alone. Further performance optimizations can be
achieved for our approach as done in GWT by orthogonal
optimizations like caching which mask disk load latencies.
7. RELATED WORK
Google AutoEscape, the only other context-sensitive sani-
tization approach in templating frameworks we are aware of,
does not handle the rich language constructs we support— it
does not handle conditionals constructs, loops or call opera-
tions [3]. It provides safety in straight-line template code for
which straight-line parsing and context-determination suf-
ﬁce. To improve performace, it caches templates and the
sanitization requirements for untrusted inputs. Templates
can then be included in Java code [15] and C code [3]. As we
outline in this paper, with rich constructs, path-sensitivity
becomes a challenging issue and sanitization requirements
for untrusted inputs vary from one execution path to the
60238023139332715107310100200300400500600700escapeHtmlescapeHtmlAttributefilterNormalizeURI, escapeHtmlescapeJsValuefilterCSSValueescapeJsStringescapeUriescapeHtmlRcdataescapeHtmlAttributeNospacefilterHtmlIdentfilternormalizeURI 597other. AutoEscape’s caching optimization does not directly
extend to code where sanitization requirements vary depend-
ing on executed paths. Our approach, instead, solves the
challenges arising from complex language features represen-
tative of richer templating systems like Closure Templates.
Context-inference and subsequent context-sensitive place-
ment for .NET legacy applications is proposed in our recent
work [43]. The approach proposed therein, though sound,
is a per-path analysis and relies on achieving path coverage
by dynamic testing. In contrast, the type-based approach
in this work achieves full coverage since it is based on static
type inference. The performance improvements in our re-
cent dynamic approach relies heavily on the intuition that
on most execution paths, developers have manually applied
context-sensitive sanitization correctly. The type-based ap-
proach in this work can apply sanitization correctly in code
completely lacking previous developer-supplied sanitization.
A potential drawback of our static approach is that theoret-
ically it may reject benign templates since it reasons about
all paths, even those which may be potentially infeasible. In
our present evaluation we have not seen such cases.
Analysis techniques for ﬁnding scripting vulnerabilities
has been widely researched [1, 2, 6, 18, 24, 27, 31–33, 37, 41,
42, 51, 52]. Defense architectures have targeted three broad
categories:
server-side techniques [5, 32, 43, 49, 52], purely
browser-based techniques [4, 35] and client-server collabo-
rative defenses [19, 26, 36, 46]. Unlike browser-based and
client-server defenses, purely server-side approaches are ap-
plicable to the server code without requiring modiﬁcations
to web browsers. Our techniques are an example of this fact.
Among server-side approaches, strong typing has been
proposed as a XSS defense mechanism in the work by Robert-
son et. al [39]. Our approach signiﬁcantly contrasts theirs in
that it does not require any annotations or changes to the ex-
isting code, does not rely on strong typing primitives in the
base language such as monads and is a mixed static-dynamic
type system for existing web templating frameworks and for
retroﬁtting to existing code.
8. CONCLUSIONS
We present a new auto-sanitization defense to secure web
application code from scripting attacks (such as XSS) by
construction. We introduce context type qualiﬁers, a key
new abstraction, and develop a type system which is directly
applicable to today’s commercial templating languages. We
have implemented the defense in Google Closure Templates,
a state-of-the-art templating system that powers GMail and
Google Docs. We ﬁnd that our mostly static system has
low performance overheads, is precise and requires no addi-
tional annotations or developer eﬀort. We hope that our ab-
stractions and techniques can be extended to other complex
languages and frameworks in the future towards the goal of
eliminating scripting attacks in emerging web applications.
9. ACKNOWLEDGEMENTS
We thank Avik Chaudhuri, David Wagner, Joel Wein-
berger, Devdatta Akhawe, Stephen McCamant, Adrian Met-
tler, Pongsin Poosankam and the anonymous reviewers for
their insightful comments to improve this manuscript. This
material is based upon work partially supported by the NSF
under Grants No.
0311808, 0832943, 0448452, 0842694,
0627511, 0842695, 0831501, and 0424422, by the AFRL un-
der Grant No. P010071555, by the ONR under MURI Grant
No. N000140911081, and by the MURI program under AFO-
SR Grants No. FA9550-08-1- 0352 and FA9550-09-1-0539.
The second author is also supported by the Symantec Re-
search Labs Graduate Fellowship. The third author con-
ducted part of the work as a visiting faculty at Google.
10. REFERENCES
[1] D. Balzarotti, M. Cova, V. Felmetsger, N. Jovanovic, E. Kirda,
C. Kruegel, and G. Vigna. Saner: Composing Static and
Dynamic Analysis to Validate Sanitization in Web
Applications. In Proceedings of the IEEE Symposium on
Security and Privacy, Oakland, CA, May 2008.
[2] S. Bandhakavi, S. T. King, P. Madhusudan, and M. Winslett.
VEX: Vetting browser extensions for security vulnerabilities,
2010.
[3] Google autoescape implementation for ctemplate (c code).
http://google-ctemplate.googlecode.com/svn/trunk/doc/auto_
escape.html.
[4] D. Bates, A. Barth, and C. Jackson. Regular expressions
considered harmful in client-side XSS ﬁlters. In Proceedings of
the 19th international conference on World wide web, WWW
’10, 2010.
[5] P. Bisht and V. N. Venkatakrishnan. XSS-GUARD: Precise
dynamic prevention of cross-site scripting attacks. In Detection
of Intrusions and Malware, and Vulnerability Assessment,
2008.
[6] H. Bojinov, E. Bursztein, and D. Boneh. XCS: Cross channel
scripting and its impact on web applications. In CCS, 2009.
[7] Google Analytics XSS vulnerability. http://spareclockcycles.
org/2011/02/03/google-analytics-xss-vulnerability/.
[8] Google XSS Flaw in Website Optimizer Scripts explained.
http://www.acunetix.com/blog/web-security-zone
/articles/google-xss-website-optimizer-scripts/.
[9] How I met your girlfriend, DEFCON’10.
ohack.us/xss/2010-defcon.ppt.
[10] XSS Attack Identiﬁed and Patch-Twitter. http://status
.twitter.com/post/1161435117/
xss-attack(cid:32)linebreak-identified-and-patched.
[11] ClearSilver: Template Filters.
http://www.clearsilver.net/docs/man_filters.hdf.
[12] CodeIgniter/system/libraries/Security.php.
https://bitbucket.org/ellislab/codeigniter/src/
8af0fb079f90/system/libraries/Security.php.
[13] Ctemplate: Guide to Using Auto Escape. http://google-
ctemplate.googlecode.com/svn/trunk/doc/auto_escape.html.
[14] django: Built-in template tags and ﬁlters.
http://docs.djangoproject.com/en/dev/ref/templates/builtins.
[15] Google autoescape implementation for gwt (java code).
http://code.google.com/p/google-web-toolkit/source/browse/
tools/lib/streamhtmlparser/streamhtmlparser-jsilver-r10/
streamhtmlparser-jsilver-r10-1.5.jar.
[16] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type
qualiﬁers. In Proceedings of the ACM SIGPLAN 2002
Conference on Programming language design and
implementation, PLDI ’02, 2002.
[17] B. Gourdin, C. Soman, H. Bojinov, and E. Bursztein. Towards
secure embedded web interfaces. In Proceedings of the Usenix
Security Symposium, 2011.
[18] A. Guha, S. Krishnamurthi, and T. Jim. Using static analysis
for ajax intrusion detection. In Proceedings of the 18th
international conference on World wide web, WWW ’09.
[19] M. V. Gundy and H. Chen. Noncespaces: using randomization
to enforce information ﬂow tracking and thwart cross-site
scripting attacks. 16th Annual Network & Distributed System
Security Symposium, 2009.
[20] Google Web Toolkit: Developer’s Guide – SafeHtml.
http://code.google.com/webtoolkit/doc/latest/
DevGuideSecuritySafeHtml.html.
[21] R. Hansen. XSS cheat sheet. http://ha.ckers.org/xss.html.
[22] P. Hooimeijer, B. Livshits, D. Molnar, P. Saxena, and
M. Veanes. Fast and precise sanitizer analysis with BEK. In
Proceedings of the Usenix Security Symposium, 2011.
598[23] HTML Puriﬁer : Standards-Compliant HTML Filtering.
http://htmlpurifier.org/.
[24] Y.-W. Huang, F. Yu, C. Hang, C.-H. Tsai, D.-T. Lee, and S.-Y.
D. Song. A Systematic Analysis of XSS Sanitization in Web
Application Frameworks. In Proceedings of the European
Symposium on Research in Computer Security, 2011.
Kuo. Securing web application code by static analysis and
runtime protection. In Proceedings of the 13th international
conference on World Wide Web, WWW ’04.
[51] Y. Xie and A. Aiken. Static detection of security vulnerabilities
in scripting languages. In Proceedings of the Usenix Security
Symposium, 2006.
[25] JiftyManual. http://jifty.org/view/JiftyManual.
[26] T. Jim, N. Swamy, and M. Hicks. BEEP: Browser-enforced
embedded policies. 16th International World World Web
Conference, 2007.
[27] N. Jovanovic, C. Kr¨ugel, and E. Kirda. Pixy: A static analysis
tool for detecting web application vulnerabilities (short paper).
In IEEE Symposium on Security and Privacy, 2006.
[28] Quasis demo - javascript shell 1.4.
http://js-quasis-libraries-and-repl.googlecode.com/svn/
trunk/index.html.
[29] A. Kie˙zun, V. Ganesh, P. J. Guo, P. Hooimeijer, and M. D.
Ernst. HAMPI: A solver for string constraints. In International
Symposium on Software Testing and Analysis, 2009.
[30] kses - PHP HTML/XHTML ﬁlter.