服务请求与执行连线之间的这种相似之处是非常关键的【47】。一次性读取请求只是将请求传过连线运算元，然后请求马上就被忘掉了；而一个订阅请求，则是与连线另一侧过去与未来事件的持久化连线。
记录读取事件的日志可能对于追踪整个系统中的因果关系与资料来源也有好处：它可以让你重现出当用户做出特定决策之前看见了什么。例如在网商中，向客户显示的预测送达日期与库存状态，可能会影响他们是否选择购买一件商品【4】。要分析这种联络，则需要记录使用者查询运输与库存状态的结果。
将读取事件写入持久储存可以更好地跟踪因果关系（请参阅 “[排序事件以捕获因果关系](#排序事件以捕获因果关系)”），但会产生额外的储存与 I/O 成本。最佳化这些系统以减少开销仍然是一个开放的研究问题【2】。但如果你已经出于运维目的留下了读取请求日志，将其作为请求处理的副作用，那么将这份日志作为请求事件源并不是什么特别大的变更。
#### 多分割槽资料处理
对于只涉及单个分割槽的查询，透过流来发送查询与收集响应可能是杀鸡用牛刀了。然而，这个想法开启了分散式执行复杂查询的可能性，这需要合并来自多个分割槽的资料，利用了流处理器已经提供的讯息路由、分割槽和连线的基础设施。
Storm 的分散式 RPC 功能支援这种使用模式（请参阅 “[讯息传递和 RPC](ch11.md#讯息传递和RPC)”）。例如，它已经被用来计算浏览过某个推特 URL 的人数 —— 即，发推包含该 URL 的所有人的粉丝集合的并集【48】。由于推特的使用者是分割槽的，因此这种计算需要合并来自多个分割槽的结果。
这种模式的另一个例子是欺诈预防：为了评估特定购买事件是否具有欺诈风险，你可以检查该使用者 IP 地址，电子邮件地址，帐单地址，送货地址的信用分。这些信用资料库中的每一个都是有分割槽的，因此为特定购买事件采集分数需要连线一系列不同的分割槽资料集【49】。
MPP 资料库的内部查询执行图有著类似的特征（请参阅 “[Hadoop 与分散式资料库的对比](ch10.md#Hadoop与分散式资料库的对比)”）。如果需要执行这种多分割槽连线，则直接使用提供此功能的资料库，可能要比使用流处理器实现它要更简单。然而将查询视为流提供了一种选项，可以用于实现超出传统现成解决方案的大规模应用。
## 将事情做正确
对于只读取资料的无状态服务，出问题也没什么大不了的：你可以修复该错误并重启服务，而一切都恢复正常。像资料库这样的有状态系统就没那么简单了：它们被设计为永远记住事物（或多或少），所以如果出现问题，这种（错误的）效果也将潜在地永远持续下去，这意味著它们需要更仔细的思考【50】。
我们希望构建可靠且 **正确** 的应用（即使面对各种故障，程式的语义也能被很好地定义与理解）。约四十年来，原子性、隔离性和永续性（[第七章](ch7.md)）等事务特性一直是构建正确应用的首选工具。然而这些地基没有看上去那么牢固：例如弱隔离级别带来的困惑可以佐证（请参阅 “[弱隔离级别](ch7.md#弱隔离级别)”）。
事务在某些领域被完全抛弃，并被提供更好效能与可伸缩性的模型取代，但后者有更复杂的语义（例如，请参阅 “[无主复制](ch5.md#无主复制)”）。**一致性（Consistency）** 经常被谈起，但其定义并不明确（请参阅 “[一致性](ch7.md#一致性)” 和 [第九章](ch9.md)）。有些人断言我们应当为了高可用而 “拥抱弱一致性”，但却对这些概念实际上意味著什么缺乏清晰的认识。
对于如此重要的话题，我们的理解，以及我们的工程方法却是惊人地薄弱。例如，确定在特定事务隔离等级或复制配置下执行特定应用是否安全是非常困难的【51,52】。通常简单的解决方案似乎在低并发性的情况下工作正常，并且没有错误，但在要求更高的情况下却会出现许多微妙的错误。
例如，Kyle Kingsbury 的 Jepsen 实验【53】标出了一些产品声称的安全保证与其在网路问题与崩溃时的实际行为之间的明显差异。即使像资料库这样的基础设施产品没有问题，应用程式码仍然需要正确使用它们提供的功能才行，如果配置很难理解，这是很容易出错的（在这种情况下指的是弱隔离级别，法定人数配置等）。
如果你的应用可以容忍偶尔的崩溃，以及以不可预料的方式损坏或丢失资料，那生活就要简单得多，而你可能只要双手合十念阿弥陀佛，期望佛祖能保佑最好的结果。另一方面，如果你需要更强的正确性保证，那么可序列化与原子提交就是久经考验的方法，但它们是有代价的：它们通常只在单个数据中心中工作（这就排除了地理位置分散的架构），并限制了系统能够实现的规模与容错特性。
虽然传统的事务方法并没有走远，但我也相信在使应用正确而灵活地处理错误方面上，事务也不是最后一个可以谈的。在本节中，我将提出一些在资料流架构中考量正确性的方式。
### 资料库的端到端原则
仅仅因为一个应用程式使用了具有相对较强安全属性的资料系统（例如可序列化的事务），并不意味著就可以保证没有资料丢失或损坏。例如，如果某个应用有个 Bug，导致它写入不正确的资料，或者从资料库中删除资料，那么可序列化的事务也救不了你。
这个例子可能看起来很无聊，但值得认真对待：应用会出 Bug，而人也会犯错误。我在 “[状态、流和不变性](ch11.md#状态、流和不变性)” 中使用了这个例子来支援不可变和仅追加的资料，阉割掉错误程式码摧毁良好资料的能力，能让从错误中恢复更为容易。
虽然不变性很有用，但它本身并非万灵药。让我们来看一个可能发生的、非常微妙的资料损坏案例。
#### 正好执行一次操作
在 “[容错](ch11.md#容错)” 中，我们见到了 **恰好一次**（或 **等效一次**）语义的概念。如果在处理讯息时出现问题，你可以选择放弃（丢弃讯息 —— 导致资料丢失）或重试。如果重试，就会有这种风险：第一次实际上成功了，只不过你没有发现。结果这个讯息就被处理了两次。
处理两次是资料损坏的一种形式：为同样的服务向客户收费两次（收费太多）或增长计数器两次（夸大指标）都不是我们想要的。在这种情况下，恰好一次意味著安排计算，使得最终效果与没有发生错误的情况一样，即使操作实际上因为某种错误而重试。我们先前讨论过实现这一目标的几种方法。
最有效的方法之一是使操作 **幂等**（idempotent，请参阅 “[幂等性](ch11.md#幂等性)”）：即确保它无论是执行一次还是执行多次都具有相同的效果。但是，将不是天生幂等的操作变为幂等的操作需要一些额外的努力与关注：你可能需要维护一些额外的元资料（例如更新了值的操作 ID 集合），并在从一个节点故障切换至另一个节点时做好防护（请参阅 “[领导者和锁](ch8.md#领导者和锁)”）。
#### 抑制重复
除了流处理之外，其他许多地方也需要抑制重复的模式。例如，TCP 使用了资料包上的序列号，以便接收方可以将它们正确排序，并确定网路上是否有资料包丢失或重复。在将资料交付应用前，TCP 协议栈会重新传输任何丢失的资料包，也会移除任何重复的资料包。
但是，这种重复抑制仅适用于单条 TCP 连线的场景中。假设 TCP 连线是一个客户端与资料库的连线，并且它正在执行 [例 12-1]() 中的事务。在许多资料库中，事务是系结在客户端连线上的（如果客户端传送了多个查询，资料库就知道它们属于同一个事务，因为它们是在同一个 TCP 连线上传送的）。如果客户端在传送 `COMMIT` 之后并在从资料库伺服器收到响应之前遇到网路中断与连线超时，客户端是不知道事务是否已经被提交的（[图 8-1](../img/fig8-1.png)）。