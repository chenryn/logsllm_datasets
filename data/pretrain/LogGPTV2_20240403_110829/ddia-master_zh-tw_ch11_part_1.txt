# 第十一章：流处理
![](../img/ch11.png)
> 有效的复杂系统总是从简单的系统演化而来。反之亦然：从零设计的复杂系统没一个能有效工作的。
>
> —— 约翰・加尔，Systemantics（1975）
---------------
[TOC]
在 [第十章](ch10.md) 中，我们讨论了批处理技术，它读取一组档案作为输入，并生成一组新的档案作为输出。输出是 **衍生资料（derived data）** 的一种形式；也就是说，如果需要，可以透过再次执行批处理过程来重新建立资料集。我们看到了如何使用这个简单而强大的想法来建立搜寻索引、推荐系统、做分析等等。
然而，在 [第十章](ch10.md) 中仍然有一个很大的假设：即输入是有界的，即已知和有限的大小，所以批处理知道它何时完成输入的读取。例如，MapReduce 核心的排序操作必须读取其全部输入，然后才能开始生成输出：可能发生这种情况：最后一条输入记录具有最小的键，因此需要第一个被输出，所以提早开始输出是不可行的。
实际上，很多资料是 **无界限** 的，因为它随著时间的推移而逐渐到达：你的使用者在昨天和今天产生了资料，明天他们将继续产生更多的资料。除非你停业，否则这个过程永远都不会结束，所以资料集从来就不会以任何有意义的方式 “完成”【1】。因此，批处理程式必须将资料人为地分成固定时间段的资料块，例如，在每天结束时处理一天的资料，或者在每小时结束时处理一小时的资料。
日常批处理中的问题是，输入的变更只会在一天之后的输出中反映出来，这对于许多急躁的使用者来说太慢了。为了减少延迟，我们可以更频繁地执行处理 ——  比如说，在每秒钟的末尾 —— 或者甚至更连续一些，完全抛开固定的时间切片，当事件发生时就立即进行处理，这就是 **流处理（stream processing）** 背后的想法。
一般来说，“流” 是指随著时间的推移逐渐可用的资料。这个概念出现在很多地方：Unix 的 stdin 和 stdout、程式语言（惰性列表）【2】、档案系统 API（如 Java 的 `FileInputStream`）、TCP 连线、透过网际网路传送音讯和影片等等。
在本章中，我们将把 **事件流（event stream）** 视为一种资料管理机制：无界限，增量处理，与上一章中的批次资料相对应。我们将首先讨论怎样表示、储存、透过网路传输流。在 “[资料库与流](#资料库与流)” 中，我们将研究流和资料库之间的关系。最后在 “[流处理](#流处理)” 中，我们将研究连续处理这些流的方法和工具，以及它们用于应用构建的方式。
## 传递事件流
在批处理领域，作业的输入和输出是档案（也许在分散式档案系统上）。流处理领域中的等价物看上去是什么样子的？
当输入是一个档案（一个位元组序列），第一个处理步骤通常是将其解析为一系列记录。在流处理的上下文中，记录通常被叫做 **事件（event）** ，但它本质上是一样的：一个小的、自包含的、不可变的物件，包含某个时间点发生的某件事情的细节。一个事件通常包含一个来自日历时钟的时间戳，以指明事件发生的时间（请参阅 “[单调钟与日历时钟](ch8.md#单调钟与日历时钟)”）。
例如，发生的事件可能是使用者采取的行动，例如检视页面或进行购买。它也可能来源于机器，例如对温度感测器或 CPU 利用率的周期性测量。在 “[使用 Unix 工具的批处理](ch10.md#使用Unix工具的批处理)” 的示例中，Web 伺服器日志的每一行都是一个事件。
事件可能被编码为文字字串或 JSON，或者某种二进位制编码，如 [第四章](ch4.md) 所述。这种编码允许你储存一个事件，例如将其追加到一个档案，将其插入关系表，或将其写入文件资料库。它还允许你透过网路将事件传送到另一个节点以进行处理。
在批处理中，档案被写入一次，然后可能被多个作业读取。类似地，在流处理术语中，一个事件由 **生产者（producer）** （也称为 **释出者（publisher）** 或 **传送者（sender）** ）生成一次，然后可能由多个 **消费者（consumer）** （ **订阅者（subscribers）** 或 **接收者（recipients）** ）进行处理【3】。在档案系统中，档名标识一组相关记录；在流式系统中，相关的事件通常被聚合为一个 **主题（topic）** 或 **流（stream）** 。
原则上讲，档案或资料库就足以连线生产者和消费者：生产者将其生成的每个事件写入资料储存，且每个消费者定期轮询资料储存，检查自上次执行以来新出现的事件。这实际上正是批处理在每天结束时处理当天资料时所做的事情。
但当我们想要进行低延迟的连续处理时，如果资料储存不是为这种用途专门设计的，那么轮询开销就会很大。轮询的越频繁，能返回新事件的请求比例就越低，而额外开销也就越高。相比之下，最好能在新事件出现时直接通知消费者。
资料库在传统上对这种通知机制支援的并不好，关系型资料库通常有 **触发器（trigger）** ，它们可以对变化（如，插入表中的一行）作出反应，但是它们的功能非常有限，并且在资料库设计中有些后顾之忧【4,5】。相应的是，已经开发了专门的工具来提供事件通知。
### 讯息传递系统
向消费者通知新事件的常用方式是使用 **讯息传递系统（messaging system）**：生产者传送包含事件的讯息，然后将讯息推送给消费者。我们之前在 “[讯息传递中的资料流](ch4.md#讯息传递中的资料流)” 中谈到了这些系统，但现在我们将详细介绍这些系统。
像生产者和消费者之间的 Unix 管道或 TCP 连线这样的直接通道，是实现讯息传递系统的简单方法。但是，大多数讯息传递系统都在这一基本模型上进行了扩充套件。特别的是，Unix 管道和 TCP 将恰好一个传送者与恰好一个接收者连线，而一个讯息传递系统允许多个生产者节点将讯息传送到同一个主题，并允许多个消费者节点接收主题中的讯息。
在这个 **释出 / 订阅** 模式中，不同的系统采取各种各样的方法，并没有针对所有目的的通用答案。为了区分这些系统，问一下这两个问题会特别有帮助：
1. **如果生产者传送讯息的速度比消费者能够处理的速度快会发生什么？** 一般来说，有三种选择：系统可以丢掉讯息，将讯息放入缓冲伫列，或使用 **背压**（backpressure，也称为 **流量控制**，即 flow control：阻塞生产者，以免其传送更多的讯息）。例如 Unix 管道和 TCP 就使用了背压：它们有一个固定大小的小缓冲区，如果填满，传送者会被阻塞，直到接收者从缓冲区中取出资料（请参阅 “[网路拥塞和排队](ch8.md#网路拥塞和排队)”）。
   如果讯息被快取在伫列中，那么理解伫列增长会发生什么是很重要的。当伫列装不进记忆体时系统会崩溃吗？还是将讯息写入磁碟？如果是这样，磁碟访问又会如何影响讯息传递系统的效能【6】？
2. **如果节点崩溃或暂时离线，会发生什么情况？ —— 是否会有讯息丢失？** 与资料库一样，永续性可能需要写入磁碟和 / 或复制的某种组合（请参阅 “[复制与永续性](ch7.md#复制与永续性)”），这是有代价的。如果你能接受有时讯息会丢失，则可能在同一硬体上获得更高的吞吐量和更低的延迟。
是否可以接受讯息丢失取决于应用。例如，对于周期传输的感测器读数和指标，偶尔丢失的资料点可能并不重要，因为更新的值会在短时间内发出。但要注意，如果大量的讯息被丢弃，可能无法立刻意识到指标已经不正确了【7】。如果你正在对事件计数，那么它们能够可靠送达是更重要的，因为每个丢失的讯息都意味著使计数器的错误扩大。
我们在 [第十章](ch10.md) 中探讨的批处理系统的一个很好的特性是，它们提供了强大的可靠性保证：失败的任务会自动重试，失败任务的部分输出会自动丢弃。这意味著输出与没有发生故障一样，这有助于简化程式设计模型。在本章的后面，我们将研究如何在流处理的上下文中提供类似的保证。
#### 直接从生产者传递给消费者