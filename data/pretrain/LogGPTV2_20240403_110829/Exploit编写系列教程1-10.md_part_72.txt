或者，你也可以用ntdll中的现有例程（基本上，会做一样的事，并且会为你自动将参数设
置）。
在XP SP3，NtSetInformationProcess()在7C90DC9E（ntdll.dll）
正如早些时候提到的，我已经在教程6中解释了一种用这种技术的可行方法，但是我会在今
天的教程中用另一种方法用这个函数。
VirtualProtect()
http://msdn.microsoft.com/en-us/library/aa366898(VS.85).aspx
VirtualProtect函数改变调用进程的内存保护访问级别。
如果你想用这个函数，你将要在栈上放5个参数：
返回值 指向VirtualProtect()需要返回的地方。这个将会是你的shellcode在栈上的地
址（动态创建的值）
lpAddress 指向需要改变访问保护属性的页区域的基地址。基本上，这会是shellcode
在栈上的基地址（动态创建的值）
dwsize 字节数（动态创建的值，使整个shellcode执行。如果shellcode由于某些原
因要扩展（比如解码），那么这些额外的字节必须考虑进来。
flNewProtect 指定新的保护选项：0x00000040：PAGE_EXECUTE_READWRITE。如果你
的shellcode不会修改自身（如解码器），那么只要0x00000020
（PAGE_EXECUTE_READ）也能成功
lpflOldProtect 获得先前访问保护值的指针变量
注意：VirtualProctect()能用的内存保护常数可以在这里找到
http://msdn.microsoft.com/en-us/library/aa366786(v=VS.85).aspx
在XPSP3，VirtualProtect()在0x7C801AD4（kernel32.dll）
WriteProcessMemory()
http://msdn.microsoft.com/en-us/library/ms681674(VS.85).aspx
SpencerPratt的技术文档：
http://www.packetstormsecurity.org/papers/general/Windows-DEP-WPM.txt
这个函数会允许你复制你的shellcode到另一个（可执行）你能跳到的&可执行的位置。在复
制过程中，WPM()会确认目的位置是标记为可写的。你只需要确认目的位置是可执行的。
返回地址 在它完成后WriteProcessMemory()要返回到的地址
hProcess 当前进程的句柄。-1指向当前进程（静态值0xFFFFFFFF）
lpBaseAddresss 指向你的shellcode需要写入的位置。“返回地址”和
“lpBaseAddress”一样。
lpBuffer 你的shellcode的基地址（动态产生，栈上的地址）
nSize 你需要拷贝到目的位置的字节数目
lpNumberOfBytesWritten 可写位置，字节数将会被写入的位置
在XPSP3，WriteProcessMemory()在0x7C802213（kernel32.dll）
WriteProcessMemory()（缩写成WPM()从这里开始）的一个很好的东西是你能用2中来绕过
DEP。
****WWWWPPPPMMMM技术1111：完整的WWWWPPPPMMMM(((())))调用
你可以将你的shellcode复制/写到一个可执行位置然后跳到那里。这个技术需要所有的
WPM()参数都要正确设置。一个可能的在XPSP3中的例子是给oleaut32.dll打补丁（被很多
应用程序加载）。Oleaut32.dll很可能不会在你的shellcode中要到，因此搞坏它是可以接受的。
如果oleaut32.dll是RE，这.text节从0x77121000并且是7F0000字节长。
这种方法有个问题。由于你要写入一个R+E区域，shellcode不能修改自己。
（WriteProcessMemory调用会暂时将位置标记为可读，但是又去掉这个级别）这意味着，
如果你用编码的shellcode（或者会修改自身的shellcode），将不会成功。由于坏字节这也
是一个问题等等。
当然，你可以试着预先考虑在真正的shellcode里面包含一些小的shellcode来使自己的位
置标记为可读，比如这些小的shellcode会用VirtualProtect()。你可以在“Egghunter”
那节中找到怎么做的例子。
我们需要2个地址：一个用来作为返回地址/目的地址，一个会被用作可写位置（要写入字
节数目写入的地方）。因此一个很好的例子是这样的：
返回地址 0x77121010
hProcess 0xFFFFFFFF
lpBaseAddress 0x77121010
lpBuffer 要产生的
nSize 要产生的
lpNumberOfBytesWritten 0x77121004
（lpNumberOfBytesWritten在目的位置之前，来避免它会在shellcode复制到目的位置后
破坏shellcode）
如果你想用有解码器的shellcode，你要预先考虑在你的shellcode里调用VirtualProtect，
在运行编码后的shellcode之前，来使当前的区域标记为可写/可执行的（取决于你是否写
入一个RE或者RW区域）...
*WPM技术2：给WPM自身打补丁
或者，你也可以给WPM自身打补丁。因此你要将shellcode写入kernel32.dll，覆盖掉WPM
函数的一部分。这可以用编码后的shellcode来解决这个问题（但是它会有一个大小限制，
你会在一会儿看到）
在XP SP3下，WPM函数在0x7C802213
在WPM函数里面，一系列的调用和跳转被用来将栈上的数据（shellcode）复制到目的位置：
●0x7C802222：调用ntdll.ZwProtectVirtualMemory()：这个函数调用会确认使目标位置
变成可读的
●0x7C802271：调用ntdll.ZwWriteVirtualMemory()
●0x7C80228B：调用ntdll.ZwFlushInstructionCache()
●0x7C8022C9: 调用ntdll.ZwWriteVirtualMemory()
在最后一个函数调用之后，数据将会被拷贝到目的位置。
然后，当自身拷贝完，函数将会写入要写的字节数并且返回被指定为一个参数的地址。最后
的例程从7C8022CF开始（就在最后一个调用WriteVirtualMemory()后）
因此我们的第二选择是将shellcode写入代码的顶部，会写入字节数并返回给调用者。我们
不必等代码写完这些字节并返回，因为我们要做的是让shellcode执行。
同时（你可以在下面的反汇编中看到），当WPM函数完成复制进程，它返回到0x7C8022CF。
因此那可以是一个用做目的地址的好位置，因为它在程序的自然流中并且会自动执行。
这会有一些后果：
参数：第一个（返回地址）和最后一个参数（指向lpNumberofBytesWritten的可读地址）是
不重要的。比如你可以将返回地址设成0xFFFFFFFF。虽然SpencerPratt在这篇文章里
http://www.packetstormsecurity.org/papers/general/Windows-DEP-WPM.txt说过
lpNumberOfBytesWritten可以设成任意值（如果你愿意的话设成0xDEADBEEF），似乎这个
地址需要指向一个可读位置来使它有效。除了这个，目的地址（shellcode要写入的地方）指
向WPM函数自身里面。在XPSP3中，这会是0x7C8022CF。
大小：热补丁WPM函数看起来很不错，如果我们写得太远的话但是会破坏kernel32.dll。
Kernel32.dll对shellcode自身很重要。很可能你的shellcode将要用kernel32.dll中的函数。
如果你破坏了kernel32.dll的结构，你的shellcode可能不在运行。因此这个技术在你的
shellcode大小是有限的情况下会成功。
栈布局例子/函数参数：
返回地址 0xFFFFFFFF
hProcess 0xFFFFFFFF
lpBaseAddress 0x7C8022CF
lpBuffer 要产生的
nSize 要产生的
lpNumberOfBytesWritten 用一个（任意的）可写位置，可以是静态的
RRRROOOOPPPPEEEExxxxppppllllooooiiiitttt 的可移植性
当你开始打造ROPexploit时，你很可能在你的exploit里以硬编码函数指针结束。然而，有
很多方法可以避免这么，如果你不得不硬编码指针，你应该知道你的exploit不会在Windows
操作系统的其他版本中利用成功。
因此，如果你已经硬编码了指向windows函数的指针，那么也可以从OSdll中用小配件。
只要我们不需要处理ASLR，一切都是行的。
试着打造一个通用的exploit是不错的，但是说实话-如果你没从OSdll中硬编码任何东西，
你需要避免OSdll的东西。
不管怎样，查实你要用来绕过DEP的函数（如果程序用了），看你能不能用一个程序/模块
指针调用那个函数。这样的话，你依然可以使exploit通用，不用产生函数地址，不用从OS
dll中硬编码地址。
一种可行的方式是你在IDA里看是否能够用一个在程序里面的或者被程序加载的dll
API调用，然后看导入表
例子：在XPSP3中的msvcr71.dll
●7C37A08C：HeapCreate()
●7C37A07C: HeapAlloc()
●7C37A094: VirtualAlloc()
●7C37A140: VirtualProtect()
注意：检验“!pvefindaddr ropcall”，在pvefindaddr v1.34版本
http://redmine.corelan.be:8800/projects/pvefindaddr和更高的版本中
从 EIP 到 ROP
为了使事情明白点，我们还是从基础开始吧。
不管DEP启用与否，溢出一个缓冲区的最初过程和最终获得EIP的控制权是一样的。因此你
直接覆盖EIP，或者你可以尝试覆盖SEH记录然后触发一个访问违例，因此覆盖的SE处理
函数地址会被调用。（还有其他的方法来获得EIP的控制权，但是这超出了文章的范围）
到目前为止，DEP跟这个一点也关系。
Direct Ret
在一个典型的direct RET exploit中，你可以用一个任意值直接覆盖掉EIP（或者，更精
确点，当函数结尾--用一个覆盖掉的保存EIP--被触发时，EIP被覆盖掉。当这个发生时，
你很可能看到你控制了ESP指向的位置的内存数据。因此如果不是DEP，你可以用你最喜欢
的工具（!pvefindaddr j esp)来定位一个指针到“jump esp”然后跳到你的shellcode中。
游戏结束。
当DEP被启用时，我们不能那样做。不是跳到ESP（用一个会跳到esp的指针覆盖掉EIP），
我们不得不调用第一个ROP小配件（也可以直接在EIP中或者使EIP跳到ESP）。那个小配
件必须按特定的方式设置，因此它们会形成一条链然后一个小配件返回到另一个小配件中，
没有直接在栈中执行代码。
怎样才能打造一个ROP exploit将会在后面讨论。
基于 SEH
在一个基于SEH的exploit中，东西是不一样的。你只能在被覆盖的SE处理函数被调用时
才能控制EIP的值（如触发一个访问违例）。早在一个典型的基于SEH exploit中，你将会
用一个指向pop/pop/ret指针覆盖到SEH，这会使你到达下一个SEH，然后在那个位置执行
指令。
当DEP启用时，我们不能这么做。我们能很好地调用p/p/r，但是当它到达时，你将会在栈
上执行代码。然而我们不能在栈上执行代码，记得？我们不得不打造一个ROP链，用这条链
绕过/停用执行保护系统。这条链会放在栈上（作为你的exploit payload的一部分）
所以在一个基于SEH的exploit例子中，我们不得不找一种方法来返回到我们的栈中而不是
调用一个pop pop ret串。
最简单的方法是执行一个所谓的“以栈为轴”的操作。不是用pop pop ret，我们将试着返
回到我们的缓冲区在的栈上的位置。我们可以通过下面的指令中的一个来达到目的：
●add esp，offset+ret
●mov esp,寄存器+ret
●xchg 寄存器，esp+ret
●call 寄存器（如果寄存器指向你能控制的数据）
一样，怎样用这个创建我们的ROP链会在下面讨论。
在我们开始之前
在Dino Dai Zovihttp://trailofbits.files.wordpress.com/2010/04/practical-rop.pdf
的关于ROP的令人敬畏的文章中，它已经将ROP exploit过程部件（39页）形象化得很好。
当打造一个基于ROP的exploit时，你将需要：
●以栈为轴
●用你的小配件来设置栈/寄存器（ROP payload）
●投掷你的常规的shellcode
●使shellcode执行
我们将会在下一章介绍所有的阶段。
DDDDiiiirrrreeeecccctttt RRRReeeetttt--------RRRROOOOPPPP 版本--------VVVViiiirrrrttttuuuuaaaallllPPPPrrrrooootttteeeecccctttt(((())))
到滚动 RRRROOOOPPPP 的时候了
让我们来打造我们的第一个ROPexploit。
我们将会用WindowsXPSP3Professional,English，DEP是OptOut模式。
在这个例子中，我将会试着为EasyRMtoMP3
Conventorhttp://www.rm-to-mp3.net/download.html打造一个基于ROP的exploit，在教程
1http://www.corelan.be:8800/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-ov
erflows/中用到的有弱点的应用程序。
注意：在你的系统上，偏移量和地址可能不一样。不要盲目地从这个教程中复制一切，
但是自己试一下然后需要时调整下地址。
EasyRMtoMP3Conventor在打开一个包含极度长的字符串的m3u文件时会有缓冲区溢出
的弱点。用一个循环的方式，我们发现在26094字节后EIP被覆盖。同时，这是在我的系统
上的偏移量。如果偏移量是不一样的，然后适当地改变脚本。这个偏移量是基于m3u文件
在你的系统上的位置，由于应用程序会预先用文件的全路径来计划缓冲区。你可以用20000
个A+7000字符来计算偏移量。
无论如何，exploit脚本（perl）的骨架看起来是这样的：
如果我们的偏移量是正确的话，EIP会被BBBB（42424242）覆盖...
...并且ESP指向一个包含我们的一连串C的地址。到目前为止，这是一个典型的directRet
覆盖exploit。
它不适用于DEP，我们需要在ESP处放我们的shellcode（而不是一连串C）然后用跳转到
esp的指针覆盖掉EIP。但是我们不能那样做因为由于DEP我们的shellcode不能执行。
因此我们将会用VirtualProctect()（kernel32.dll）函数来创建一个ROP链来改变内存页
（shellcode在的位置）的访问保护级别，因此它会被执行。
为了使这个成功，我们需要传递一些参数给这个函数。在函数被调用时，这些参数需要放在
栈顶。
有一些方法可以做这个。我们可以将需要的值放在寄存器中然后用pushad操作（一次将所
有东西入栈）。另一种技术是将其中的一些参数（静态的/没有null字节的）放在栈上，并且
用一些ROP小配件来计算其他的一些参数，将它们写入栈（用一些sniper技术）。
我们不能在m3u文件中用null字节，因为EasyRMtoMP3Converter会将文件中的数据当
做字符串，然后字符串会被第一个null字节阻断。我们也要记住我们很可能以一些限制性
字符集结束（我们可以简单地创建编码的shellcode来克服这个问题）