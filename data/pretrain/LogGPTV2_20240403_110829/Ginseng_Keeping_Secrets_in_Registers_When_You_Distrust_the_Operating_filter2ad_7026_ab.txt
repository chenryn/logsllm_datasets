Secure world supported by the TrustZone technology. Both the user and kernel
modes are in the Normal world. The gray boxes are our contributions.
A. Design Overview
The basic unit of protection in Ginseng is a function.
Ginseng provides a keyword sensitive for a developer
to declare a local variable, parameter or return value of a
function as sensitive, as shown in Figure 2. Once declared,
we say that this variable and the corresponding function are
sensitive. To ensure the conﬁdentiality and integrity of sensitive
data, Ginseng must ensure the code integrity of the sensitive
functions via a collaboration of static and runtime protections.
In addition to the code integrity, the collaboration also provides
control-ﬂow integrity (CFI) when sensitive data are in registers.
Ginseng implements static protection in its compiler. First,
the register allocator only uses registers for the designated
sensitive variables, never spilling them into the memory. This,
however, is not enough because registers, as the function’s
execution context, can be saved to the memory, i.e., stack,
when execution context changes, due to either function calls or
context switching. Because it is the responsibility of a compiler
to generate context-saving code for function calls, the Ginseng
compiler saves and restores the registers with sensitive data to
and from the secure stack.
Ginseng supports runtime protection with a small, passive
piece of software with a higher privilege,
i.e., running in
the Secure world in ARM. The software, called GService,
serves requests from a sensitive function. When registers with
sensitive data must be saved/restored due to execution con-
text change, GService encrypts/decrypts them before saving
into/restoring from the memory, providing the abstraction of
a secure stack. For the code integrity of a sensitive function,
GService prevents the OS from mapping the function’s code
pages to the kernel address space. The service also ensures
CFI by considering a function pointer as a sensitive variable.
Ginseng provides a small set of APIs for an app and GSer-
vice to communicate with each other bypassing the untrusted
OS.
3
Ginseng ServiceHigher Privilege ModeCode Integrity ManagerCFI ManagerFunctionControl Block   [A]Exception RoutingCall Site ProtectionFunctionControl Block   [B]push (encrypt)pop (decrypt)AppUser ModeSensitive Function [B]Kernel ModeSensitive Function [A]Ginseng LibraryRichOperating SystemSecure StackSensitiveContext[A]SensitiveContext[B]encryptedInsensitiveData and CodeSecure WorldNormal WorldSecure APIs1) Architectural requirements: Ginseng has three architec-
tural requirements:
run GService;
• a higher privilege mode than that of the untrusted OS to
• a direct call from an app to the higher privilege mode to
• a way to trap writes to virtual memory control registers
bypass the OS;
into the higher privilege mode.
We note that both x86 and ARM architectures meet the
requirements. The hypervisor mode of Intel and AMD pro-
cessors is suitable to run GService. A user process can use
the hypervisor call instruction to directly communicate with
GService in the hypervisor mode. It is also possible to trap
modiﬁcations on virtual memory control registers using the
virtual machine control ﬁelds in VMCS (or VMCB in AMD).
For clarity, we will use ARM 64-bit (AArch64) terminol-
ogy to expose the design of Ginseng. We will use Normal
world to refer to the rich OS and software running on top of
it. When necessary, we will subdivide it into EL0 (user mode),
EL1 (kernel mode), and EL2 (hypervisor mode). We will use
Secure world to refer to the higher privilege mode, EL3. We
will use AArch64 ISA and follow its calling convention. We
will use exception to refer to asynchronous, i.e., interrupts,
and synchronous exceptions caused by instructions, e.g., a
permission fault by storing a register to read-only memory.
B. Programming model
Ginseng’s unit of protection is a function. It protects
local variables, parameters, and the return value of a function
marked by developers as sensitive. We next elaborate this
design choice and explain how it affects the programming
model.
To use Ginseng, a programmer will mark a variable of
any type as sensitive as shown in Figure 2. As protection
comes with overhead, the smaller and the fewer sensitive
variables, the more efﬁciently the program will run. Therefore,
the incentive is clear and strong for the programmer to only
mark the absolutely necessary variables. When compiling
the program, the programmer indicates how many registers
can be used for sensitive variables and the compiler will
complain when the marked variables could not ﬁt, which will
be elaborated further in III-C.
The sensitivity of a variable is contagious both within
and between functions. Ginseng’s compiler performs static
taint analysis to identify all variables that may carry the
sensitivity. Because static taint analysis does not have the
semantic information of all sensitivity propagations, it does
so conservatively. For example, the return value of a local
function taking a sensitive variable as a parameter will be
considered sensitive. This may lead to an excessive number of
sensitive variables, hurting performance. Therefore, we allow
the app developer, who has semantic knowledge about the
local function, to stop the sensitivity propagation by marking
a variable as insensitive.
We limit sensitive data to local variables because protecting
global variables is expensive and often unnecessary. To protect
a global variable, the data page containing the variable needs to
be encrypted and decrypted when the CPU enters and exits the
tmp key bottom ;
i n s e n s i t i v e ∗/
v a r i a b l e s are
i n s e n s i t i v e ∗/
l o n g key top ,
l o n g key bottom ,
l o n g key top ,
l o n g key bottom ) {
l o n g tmp key top ,
v a r i a b l e s are
s e n s i t i v e
/∗ a l l o t h e r
/∗ HMAC SHA1 i m p l e m e n t a t i o n ∗/
/∗ a l l o t h e r
/∗ use HAMC SHA1 t o compute 20- b y t e hash ∗/
hmac sha1 ( key top , key bottom ,
1 v o i d hmac sha1 ( s e n s i t i v e
s e n s i t i v e
2
c o n s t u i n t 8 t ∗ d a t a ,
3
u i n t 8 t ∗ r e s u l t ) {
4
5
6
7
8
9 }
10
11 i n t genCode ( s e n s i t i v e
s e n s i t i v e
12
13
14
15
16
17
18
19
20
21
22
23
24
25 }
26
27 v o i d run ( ) {
s e n s i t i v e
28
29
/∗ read a s e c r e t
30
s
31
32
s
33
34
35 }
Figure 2. Simpliﬁed Two-factor Authenticator: a developer uses a keyword
sensitive to mark sensitive variables and parameters.
/∗ t r u n c a t e 20- b y t e hash t o 4- b y t e ∗/
r e s u l t = t r u n c a t e ( r e s u l t F u l l ) ;
p r i n t f ( ”OTP : %06d\n ” ,
r e t u r n r e s u l t ;
r e a d (TKN KEY1 TOP , TKN KEY1 BOTTOM, key top ) ;
r e a d (TKN KEY2 TOP , TKN KEY2 BOTTOM, key bottom ) ;
key from GService or a u s e r ∗/
/ /
/ /
/ /
s e n s i t i v e d a t a
c u r r e n t
( o u t )
f u l l hash
t i m e / 3 0 sec
c h a l l e n g e ,
r e s u l t F u l l ) ;
r e s u l t ) ;
l o n g key top , key bottom ;
genCode ( key top , key bottom ) ;
kernel mode (EL1). For example, trusted software such as the
secure monitor or trusted hypervisor [31] has to intercept all
exceptions so that it can encrypt the data page before entering
the kernel mode. When returning to the app,
the trusted
software has to decrypt the page, too. Because the kernel
running on other cores can access the decrypted data page,
only a single core could be online. Furthermore, TLB ﬂushes
and cache pollution further degrade the performance [50], [66].
On the other hand, using global variables for sensitive data is
not absolutely necessary because a program can load sensitive
data from their source on demand. For example, a program
can load a secret key from the Secure world or a ﬁle system
only when the key is needed. Therefore, Ginseng protects local
variables only.
Example: Figure 2, a snippet of a two-factor authenticator,
reﬂects Ginseng’s design decision. First, only local variables
with sensitive data are protected. In genCode() (line 11-25),
for example, the current time divided by 30 sec, challenge,
and onetime password, result and resultFull, are not
protected. The function declares only the two parameters as
sensitive. We intentionally regard the onetime password as
insensitive because this is refreshed at every 30 sec and not as
important as the 80-bit secret key. Second, not all functions are
sensitive. The bodies of truncate() and printf() called in
line 21 and 23 are not protected because they do not contain
a sensitive variable or parameter.
C. Static Protection
Ginseng extends the compiler to provide static protection
of sensitive variables. The extension includes two parts. First,
the compiler identiﬁes all sensitive variables and keeps them
4
Figure 3. Dynamic Register Sensitivity Example: the sensitivity of a register
follows a variable’s liveness. The dynamic sensitivity enables the compiler to
allocate a register to multiple sensitive or insensitive variables. GService does
not know the true sensitivities of registers at runtime; hence, the service saves
all registers that are potentially sensitive on an exception.
only in registers. Once a register holds the value of a sensitive
variable, it becomes sensitive. Second, on a function call,
the compiler emits instructions sending a request to GService
which in turn encrypts sensitive data and saves them in the
secure stack. Likewise, after the function call, the compiler
emits similar instructions for restoring sensitive data from the
secure stack to sensitive registers.
1) Allocating registers for sensitive variables: The register
allocator of a compiler decides where a variable’s value is
stored: registers, stack or heap; Ginseng’s compiler must keep
sensitive variables in a set of predeﬁned registers. With further
help from the runtime protection (IV), Ginseng keeps sensitive
variables away from memory that the untrusted OS can access.
The optimization goal of Ginseng’s register allocation is
to use as few sensitive registers as possible. This is because
sensitive registers require special care by both the compiler
and runtime so that they do not enter the memory and as a
result, incur performance overhead.
To achieve this goal, Ginseng’s compiler employs two
complementary ideas. First, the sensitivity of a register should
be dynamic, depending on whether it holds a live sensitive
variable. At the variable’s last use, the register loses its sensi-
tivity and becomes free at which point the compiler can reuse
it. Figure 3 shows an example. Register x15 is allocated to a
sensitive variable and becomes sensitive at the beginning of a
function; as it loses sensitivity in the middle, it is allocated to
an insensitive variable and becomes insensitive. The dynamic
sensitivity allows the compiler to assign a register to multiple
(sensitive) variables when their lifetimes do not overlap, e.g.,
x12 in the ﬁgure.
The second idea is to allocate sensitive registers before
others, a two-phase method. The compiler prioritizes sensitive
registers to exclude them from the spillable register list and
avoid unnecessary spills. If it allocates insensitive ones ﬁrst,
the compiler may not ﬁnd a free register for a sensitive
variable and need to introduce extra spills. In the ﬁrst pass,
the allocator allocates registers for sensitive variables and
builds a sensitivity table that records the sensitivity ranges
of registers. The table tells which registers are sensitive at
a certain instruction. The second pass uses this information
not to allocate them for insensitive variables. The call site
protection (III-C2) also uses this information to determine
which registers should be saved to the secure stack at a call
( i d t o p )
( id btm )
l s l #16
l s l #32
l s l #48
l s l #16
l s l #32
l s l #48
x15 and x14 have
s e n s i t i v e d a t a
x 0 , # 0x4e26
x 0 , # 0 x 5 7 7 c ,
x 0 , # 0 x 2 f 9 9 ,
x 0 , # 0 x 4 1 e 4 ,
x 1 , # 0x7cc0
x 1 , # 0 x c f 9 1 ,
x 1 , # 0x2362,
x 1 , # 0 x 8 1 e 2 ,
1 / /
2
3 / / 1 s t argument
4 mov
5 movk
6 movk
7 movk
8
9 / / 2nd argument
10 mov
11 movk
12 movk
13 movk
14
15 / / 3rd argument
16 / /
17 mov
18
19 / / 4 t h argument
20 mov
x 3 , x z r
21 bl
401ee4 
22
23 / / p r e p a r e t h e
24 / /
25 sub
26 add
27 bl
Figure 4. Disassembled Call Site Protection Example: to protect sensitive
data in registers x15 and x14, the Ginseng compiler assigns a call site
identiﬁer, encodes sensitive data hide/move decision, and sends a request to
GService through s_writeMoveV() before calling hmac_sha1().
x 2 , x 2 9 , #24
x 3 ,
s p , #44
400f20 
s e n s i t i v e d a t a h i d e / move e n c o d i n g
x 2 , # 0x2021000000000000
s writeMoveV p r e p a r e d t h e
f i r s t
two ( x0 and x1 ) .
l a s t