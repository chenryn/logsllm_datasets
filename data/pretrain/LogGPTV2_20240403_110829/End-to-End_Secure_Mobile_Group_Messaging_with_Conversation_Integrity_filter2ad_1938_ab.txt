After receiving the setup message, Charlie sends a receipt acknowledging Charlie has accepted the setup message
from Alice. He ﬁrst fetches the long-term public key and a single ephemeral public pre-key for Bob; he already
has the necessary key material for Alice from the setup message. Charlie then uploads a protocol message of the
form:
Sid, “RCP T ”, Charlie, cca, ccb, authcs1, . . . , authcsm
where cc∗ and authc∗ authenticates both the setup message with Alice, Bob, and the providers respectively.
For Bob to send a broadcast message m, Bob uploads a protocol message of the form:
Sid, “M SG”, Bob, c, cba, cbc, authbs1, . . . , authbsm
where c is an authenticated encryption with associated data (AEAD) ciphertext of the message m under a random
key. cba and cbc are AEAD encryptions of random key material that authenticate for Alice and Charlie respectively,
and authb∗ authenticates the message for the providers. The term broadcast is used to indicate this is a group
conversation message that is meant to be displayed to the user, it has no relation to broadcast messaging.
The ﬁnal message type is group update for changing the participants of the conversation. When Alice wishes
to add Dave to the conversation she fetches Dave’s long-term and ephemeral key material and uploads a message
of the form:
Sid, “U pdate”, Alice, P, cab, cac, cad, authas1 , . . . , authasm
where P is the new set of participants and ca∗ and autha∗ authenticates the message for every participant and the
providers. The rules of who is authorized to make participant changes as well as what kind of changes they are
allowed to make are left up to the implementation but must be enforceable by the providers.
5
B. Message Order
We now detail the rules enforcing message order.
1)
A protocol message must be received from all providers before processing. The protocol messages must
also be processed in the order they are received.
All conversations start with a setup message.
2)
3) When Alice sends a receipt, it must acknowledge all setup, broadcast, and group update messages prior
to the receipt that she has not yet acknowledged. Typically they are sent shortly after every message is
received.
Prior to Alice sending a broadcast or group update, Alice must have sent a receipt.
4)
5) When Alice sends a receipt, she acknowledges messages with every participant and the providers separately.
If Bob has just joined the conversation she only acknowledges the messages that she and Bob have in
common.
6) When Alice sends a broadcast or group update message, she must acknowledge the most recent prior
setup, broadcast or group update message. She must also acknowledge all receipts received after that prior
message in order.
If Alice receives an invalid protocol message from the providers she terminates the conversation on her
client and does not process any future messages.
7)
Rule (1) implies that even the author of a message must wait until they have received it from all providers before
processing it. Otherwise, if two users sent a message at the same time, both users would think their message would
come ﬁrst, causing an order inconsistency.
Rule (6) implies strong ordering of setup, broadcast, and group update messages but not receipts. This was a
design choice as requiring receipts to acknowledge receipts would cause signiﬁcant overhead and excess network
trafﬁc. We describe why we made this decision in more detail in Section VI.
Rules (3) and (4) restrict the amount of time a message is vulnerable if the keys used to encrypt it are
compromised. We discuss this more as it relates to forward and backward secrecy in Section IV
C. Primitives
We assume standard cryptographic primitives. Let l be the security level in bits of Mobile CoWPI. All primitives
are assumed to provide at least l bits of security. Let G be a group of prime order p generated by g where the
decisional Difﬁe-Hellman assumption is hard.
We assume a hash function and three key derivation functions:
p
H : {0, 1}l × Zp (cid:55)→ Z∗
KDF1 : S × G × G × G × U × U (cid:55)→ {0, 1}l
KDF2 : {0, 1}l (cid:55)→ {0, 1}l
KDF3 : G (cid:55)→ {0, 1}l
Where H and KDF1 are used for two-party NAXOS [11] key agreements, KDF2 is used to produce a random
symmetric key from an input string, and KDF3 is used for anonymous Difﬁe-Hellman. S is the set of possible
session identiﬁers and U is the set of possible participant identiﬁers. These functions are modeled as random
oracles. We choose NAXOS as it has the property that to distinguish between a random key and a NAXOS key the
distinguisher must know both the long-term and ephemeral secret keys of one of the participants. KDF1 is a minor
modiﬁcation of the NAXOS KDF that also includes the session identiﬁer of the current Mobile CoWPI session.
We assume a symmetric authenticated encryption with associated data (AEAD) scheme. AEAD consists of
two functions, Enck(m, d) (cid:55)→ c, and Deck(c, d) (cid:55)→ m, or ⊥ if c and d do not authenticate with key k. The
AEAD scheme must provide indistinguishable from random chosen-plaintext-attack security (IN D$ − CP A) [17]
and integrity of ciphertext security (IN T − CT XT ) [2]. We choose AES-GCM with random IVs for our AEAD
scheme.
D. Registration
To register with the providers Alice generates a long-term public private key pair:
lska ←R Z∗
lpka ← glska
p
6
She also generates a list of ephemeral pre-keys where i is the id of the pre-key:
eska[i] ←R {0, 1}l
epka[i] ← gH(eska[i],lska)
Alice registers her identity, public long-term key lpka and public ephemeral pre-keys epka with the providers out-
of-band. Alice should generate enough pre-keys to support as many conversations as she expects to start while she
is ofﬂine. She can always upload new pre-keys in the future. Each pre-key may only be used for a single session.
The participants must enforce this rule.
E. Two Party Ciphertext Blocks
All protocol messages contain pairwise ciphertext blocks cab where a is the sender and b is the receiving
participant. These blocks are used to send additional key information and authenticate the protocol message. They
are computed using a simple key ratchet where the initial block uses a pre-key to perform a NAXOS authenticated
key agreement and then utilizes AEAD to encrypt and authenticate the message; All subsequent blocks after the
initial block use ephemeral keys sent in the previous block to derive a new NAXOS key and then encrypt with
AEAD as in the initial block. In this section we describe how to compute these ciphertext blocks in terms of Alice
sending to Bob.
Here we describe how Alice computes the initial ciphertext block cab to send to Bob in session Sid. This
ciphertext block encrypts message m and authenticates associated data d. m is only used when sending broadcast
messages, in which case it is random symmetric key material. When sending setup, receipt, and group update
message m is empty.
First, Alice fetches Bob’s long-term public key lpkb and an ephemeral pre-key epkb from the providers where
idb is the id of epkb. Alice generates a new ephemeral key:
eskab ← {0, 1}l
epkab ← gH(eskab,lpka)
Then Alice computes a symmetric key:
b
ki1 ← epklska
ki2 ← lpkH(epkab,lska)
ki3 ← epkH(epkab,lska)
k ← KDF1(Sid, ki1, ki2, ki3, a, b)
b
b
Alice generates her next ephemeral key pair:
She computes the ciphertext block as:
ab ← 1
id(cid:48)
ab ←R Z∗
esk(cid:48)
ab ← gH(esk(cid:48)
epk(cid:48)
p
ab,lska)
cab ← epkab, idb, Enck((m, id(cid:48)
ab, epk(cid:48)
ab), d)
When Bob receives cab = epkab, idb, c from the providers he ﬁrst fetches Alice’s long-term public key lpka
and looks up the ephemeral secret key eskb associated with idb and computes the symmetric key as:
a
ki1 ← lpkH(eskb,lskb)
ki2 ← epklskb
ki3 ← epkH(epkb,lskb)
k ← KDF1(Sid, ki1, ki2, ki3, a, b)
ab
ab
Then he veriﬁes c and d with k and decrypts:
(m, id(cid:48)
ab, epk(cid:48)
ab) ← Deck(c, d)
7
and stores id(cid:48)
that the message originated from someone with knowledge of Alice’s long-term secret key.
ab for latter use. Note that the implicit authentication of NAXOS key exchange authenticates
ab and epk(cid:48)
All subsequent ciphertext blocks are generated and processed in the same manner as the initial ciphertext block
replacing the pre-keys with the ephemeral keys received in the previous block. The users do not send the ephemeral
public keys in the clear in subsequent ciphertext blocks. That is the ciphertext block has the form:
cab ← id(cid:48)
b, Enck(cid:48)((m, id(cid:48)(cid:48)
ab, epk(cid:48)(cid:48)
ab), d)
Alice and Bob may try to initialize the two-party key ratchet at the same time. If this happens the providers will
enforce an order to the messages and future ciphertext blocks should use the most recently initialized key ratchet.
These ciphertext blocks are what provide message integrity and authentication. This is due to the NAXOS key
agreement implicitly authenticating the symmetric keys.
F. Provider Authentication Block
Every conversation message that Alice sends contains a provider authentication block authaj for every provider
j ∈ S where S is the set of providers. The authentication blocks are necessary since Alice only uploads the message
to the routing provider. The routing provider then forwards the message to the mirror providers. The authentication
blocks allow the providers to verify that the message is from Alice.
These blocks are simple AEAD ciphertexts that authenticate the message d as associated data. When Alice
comes online she simply sends to every provider j ∈ S a symmetric key kaj ←R {0, 1}l. Then when Alice sends
a protocol message d she ﬁrst generates her next key k(cid:48)
aj ←R {0, 1}l, then computes the authentication block:
authaj ← Enckaj (k(cid:48)
Provider j veriﬁes d and decrypts the next symmetric key k(cid:48)
aj.
aj, d)
G. Setup Message
All conversation messages are similar in format. For Alice to setup a conversation she generates a random Sid
and computes the setup message:
data0 ← Sid, Alice, “SET U P ”, P
data1 ← data0, ca0, . . . , can−1
Next, Alice computes the two party ciphertext block cai for every participant i ∈ P \ {Alice} as described in
Section III-E, where data0 is the associated data to authenticate in those ciphertext blocks. Let n = |P| and :
Next, Alice computes the provider authentication block authaj for every provider j ∈ S as described in Section III-F
where data1 is the associated data to authenticate. Alice then sends to the routing provider:
where s = |S|.
data1, autha0, . . . , authas
The routing provider sends to each mirror provider j the message data1, authaj. Each provider can verify the
message data1 is from Alice. Then every provider sends to participant i ∈ P\{Alice} the message Alice, data0, cai.
Every user veriﬁes that data0, cai is from Alice as detailed in Section III-E. The providers send data0 to Alice
and she veriﬁes it is the data0 she sent.
Once a participant has received the setup message from every provider and veriﬁed the message, they setup a
new Mobile CoWPI session with session identiﬁer Sid. All providers must verify Sid is not used for any existing
session before forwarding the message.
8
H. Receipt Message
Participants send receipts after they have accepted any setup, broadcast, or group update message. If multiple
messages are sent while Alice is ofﬂine she sends a single receipt that acknowledges all messages mi with participant
i ∈ P \ {Alice}. The messages to acknowledge depend on the participant they are being acknowledged to. mi is
composed of all protocol message excluding receipts that have not been acknowledge previously and have been
sent after participant i has been added to the conversation. This is because i cannot acknowledge messages they
have not seen. mi should be a list of all data0 blocks from the messages to acknowledge in order. Let m be a list
of all of the unacknowledged setup, broadcast, and group update messages.
A receipt is similar to a setup message. When Alice generates a receipt for messages she computes:
Then she computes the two party ciphertext block cai for every participant i ∈ P {Alice} as detailed in Section III-E
with the associated data to authenticated as data0, mi. Let
data0 ← Sid, Alice, “RCP T ”
data1 ← data0, ca0, . . . , can−1
She then computes the provider authentication blocks as detailed in Section III-F with the associated data as
data1, m. Finally, she sends data1 and the authentication blocks to the routing provider.
The providers can verify that all unacknowledged messages are acknowledged in their respective provider
authentication block. If the receipt does not acknowledge all unacknowledged messages it is dropped. The providers
then send data0, ci to participant i. Every participant can verify all of Alice’s unacknowledged messages with their
respective ciphertext block. Alice veriﬁes data0 is the message she uploaded. If the message does not verify the
conversation is terminated.
I. Broadcast Message
Broadcast messages are similar to receipts except they contain a ciphertext. Let pm be a list of all protocol
messages up-to and including the last setup, broadcast, or group update message in a conversation. When Alice
wants to send the broadcast message m. She ﬁrst generates a random symmetric key input ka ←R {0, 1}l then
computes the symmetric key k ← KDF2(ka). Let
She then generates the ciphertext block cai for every i ∈ P \ {Alice} as detailed in Section III-E with ka as the
message to encrypt and data0, pm as the associated data. Let
data0 ← Sid, Alice, “M SG”, Enck(m)
data1 ← data0, ca0, . . . , can−1
She then computes the provider authentication blocks as detailed in Section III-F with the associated data as
data1, pm. Finally, she sends data1 and the authentication blocks to the routing provider.
Each provider veriﬁes the message and sends data0, cai to participant i. After receiving the message from every
provider each participant veriﬁes and then displays the message. If the message does not verify the conversation is
terminated.
J. Group Update Message
To change the set of participants in a conversation a member of the conversation can send a group update
message. Who is allowed to send the messages as well as what modiﬁcations they are allowed to make is out-of-
scope of this paper. However, group modiﬁcations must be enforceable by the providers since they need to forward
messages.
Group update messages are similar to broadcast messages except that the broadcast message ciphertext is
replaced with a list of participants. Again let pm be a list of all protocol messages up-to and including the last
setup, broadcast, or group update message in the conversation. When Alice wishes to change the participants of a
conversation to P (cid:48) she creates a message:
She then creates the ciphertext block cai for participant i ∈ (P ∪ P (cid:48))\{Alice} as described in Section III-E where
data0, pm is the associated data for the ciphertext blocks. Let
data0 ← Sid, Alice, “U P DT ”, P (cid:48)
data1 ← data0, ca0, . . . , can−1
9
Alice then creates the provider authentication block authaj for provider j ∈ S as detailed in Section III-F with