        i = self.init & self.mask & self.lengthmask 
        output = 0
        while i != 0:
            output ^= (i & 1)
            i = i >> 1
        nextdata ^= output
        self.init = nextdata
        return output
N = 64
mask1 = 17638491756192425134
output = 
'10001011010100011000100101001011100010110111001100001110000111011011100101101101000111
101100010111100011000011111111010101111100101010101100010100000111011010011110111000100
000101100101010110100111100011000101010101011011111011011000001101001011000010000011110
001111001111011100110011111111101000111101001010000110001110111101001001101011101101001
010001101010010110000000000001001101100101011110011010110011010110110011001001111001010
100011110111100100010110111100110010000000010010011110001100000011000001110001000000010
000100100101100000011100000011110101001011010011010100001101000010100100000011001011001
000110000000000111011101000110010110111110010101110010001010001111111000011010000011001
110111001000010011000000111010111100000100010011001111101110110100100011111000111000011
111101010010110011111100010000100101011000001010101111101111001000011101111000111000101
011010111100110001011011100101001010110110110110011100100111100110001101110010100010111
100000110000010110100010001100011011001100100110101110010100011101110110010000010011100
000011100000101010011011111110000100000010001010111011011111110100111100011100011110110
010001011101111001011101010110111001001000111001001111001111110111111100001111100100110
011111110110101000011010111110010001100000111100010011100011010000101010111010101101000
011001110011000000110110110001101100110101110010010111011100110101000110000011001010100
000110000000001110010001010001001101111100001111111011010010011100110010000111010001001
111111110000010101110011010100100101101100111000010110100110010001010110111110011000111
011101110100010000110110110011001011111011111000000000000001110000001000011000110111000
000110100110110001111011111100010010011100101010000111000011111010000001010010011101010
010110011000000001111110000000010111011000010001111000100110101110001000011111001101111
111100011111011001001110000101001101110100111010011011101000110010000001001000001100110
001110101100001000110100100010111101100010100110011111010011100100001101111010000110110
101111111001111011100001101100000001101111100100'
for i in range(1984):
    init1 = int(output[i:i+64],2)
    for j in range(i+64):
        t = init1%2
        init1 = init1 >> 1
        t ^= bin(init1&mask1).count('1')%2
        init1 = (t200:
                break
    else:
        print(i,s,init1)
        break
#661 112 15401137114601469828
l1 = lfsr(init1,mask1,N)
a = []
b = []
for i in range(2048):
SpecialCurve2
    if l1.next()!=int(output[i]):
        a.append(i)
        b.append(int(output[i]))
print(a)
print(b)
from sage.all import *
a = [4, 12, 30, 37, 41, 53, 69, 85, 97, 101, 146, 148, 193, 196, 260, 281, 341, 357, 
390, 407, 428, 431, 438, 477, 520, 523, 529, 539, 541, 566, 607, 613, 619, 623, 640, 
660, 733, 750, 811, 816, 824, 873, 887, 906, 910, 939, 948, 959, 971, 977, 1001, 1026, 
1030, 1046, 1052, 1078, 1082, 1109, 1120, 1126, 1137, 1158, 1163, 1194, 1195, 1222, 
1237, 1244, 1280, 1286, 1311, 1345, 1391, 1401, 1415, 1440, 1456, 1495, 1506, 1518, 
1532, 1535, 1571, 1612, 1619, 1624, 1642, 1646, 1654, 1709, 1718, 1745, 1764, 1792, 
1797, 1834, 1848, 1855, 1861, 1871, 1894, 1901, 1906, 1925, 1950, 1967, 1970, 1979, 
2026, 2027, 2036, 2046]
b = matrix(GF(2),112,[1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 
1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 
1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 
1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 
1, 1, 0])
state = [vector(GF(2),64,[0]*i+[1]+[0]*(63-i)) for i in range(64)]
A = []
for i in range(a[-1]+1):
    mask2 = 14623996511862197922
    nextdata = vector(GF(2),64)
    for j in range(64):
        if mask2%2:
            nextdata += state[-1-j]
        mask2 = mask2 >> 1
    state = state[1:] + [nextdata]
    if i in a:
        A += nextdata
A = matrix(GF(2),112,64,A)
init2 = A.solve_right(b)
init2 = ''.join(str(i[0])for i in init2)
init2 = int(init2, 2)
print(init2)
# 11256716742701089092
from Crypto.Util.number import *
import random
def add(P1,P2):
hardrsa
    x1,y1=P1
    x2,y2=P2
    x3=(x1*x2-y1*y2)%n
    y3=(x1*y2+x2*y1)%n
    return (x3,y3)
def mul(P,k):
    assert k>=0
    Q=(1,0)
    while k>0:
        if k%2:
            k-=1
            Q=add(P,Q)
        else:
            k//=2
            P=add(P,P)
    return Q
'''
discrete log
n = 92916331959725072239888159454032910975918656644816711315436128106147081837990823
y = 
1225348982571480649501200428324593233958863708041772597837722864848672736148168^2*2%n
g = 2
e = int(pari(f"znlog({int(y)},Mod({int(g)},{int(n)}))"))
'''
e = 96564183954285580248216944343172776827819893296479821021220123492652817873253
n = 92916331959725072239888159454032910975918656644816711315436128106147081837990823
C = (44449540438169324776115009805536158060439126505148790545560105884100348391877176, 
73284708680726118305136396988078557189299357177640330968917927635171441710392723)
p = [425886199617876462796191899, 434321947632744071481092243, 
502327221194518528553936039]
phi = (p[0]*p[0]-1)*(p[1]*p[1]-1)*(p[2]*p[2]-1)
d = inverse(e,phi)
M = mul(C,d)
assert mul(M,e)==C
print(long_to_bytes(M[0])+long_to_bytes(M[1]))
from Crypto.Util.number import *
dp = 
379476973158146550831004952747643994439940435656483772269013081580532539640189020020958
796514224150837680366977747272291881285391919167077726836326564473
c = 
572482589459273876735794673481061187470343811907037778614095273362729145596994903533259
066729562735598679414022814386706527109095322613033940450796291461563408019322548390215
741399439334519240628884267263532307572845828639932275927033231332651804143820621325805
266582057162180463662476538817646588913155926071943557332094932396112161931184246025109
641020269986743236851347960185968173932681065837371535166329690416932807252979292777511
360405468302305338985146597147172133716198531372725159670670088055210516131071415557885
168942236548512777853933551781142309290140374367706781311481403983843947164564502695390
650093963119960404228537400495085005402814881712852334457447996800223071804522107939136
14131646875949698079917313572873073033804639877699884489290120302696697425
c1 = 
781001314618722856134262443227375021472194851087991309752024296380428594881369337834982
109143357419407616561375160339264189753637341946610316785168570407235320554486959288206
240944004814649501811266384562346698149824112709856502092456877655954837388769755725212
769631495426591876800759173223085121639044232973816355327716904340165891328761712835963
204356233762834252285361577267815248703486149831164088150882576097885179868106225059615
38812889953185684256469540369809863103948326444090715161
# discrete_log
x = 
437762756288598905752324437943192985519348042134727449270228186967591889019773902669731
727556583961974211394202065498893371179785978831548599652366054525184464486398130551341
335875640454718044478180585715864268958009848055883638558652186908775474191527655121430
952174134773438354739636376924410321361632899647561723162894691595003126305290913506368
084916975530693883883033416230477375535561231420027370599365699311631973645714785095768
163493481462151012508038265906940390960638584244053829507694152721118430397156326558315
942242880996088273453771643759275593381535059914049738885943566643934872498195899158811
78770048740
# from z3 import *
# p=Int('p')
# s = Solver()
# s.add(2019*p**2 + 2020*p**3 + 2021*p**4==x)
# s.check()
# print(s.model())
p = 
121316011657880246350300349210840704700538421129848668210703952817284688050727160024944
27632757418621194662541766157553264889658892783635499016425528807741
print(long_to_bytes(pow(c,dp,p)))
密码⼈集合
脑洞⼀下发现是数独。