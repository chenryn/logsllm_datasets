这篇文章中，比较系统地描述了Windows中基于S.E.H的异常处理原理和大致流程，并用生动
的例子讲解了操作系统是如何使用S.E.H实现_try{)、_except()异常处理机制的。您可以在
从攻击者的角度讲，对异常处理的掌握只要知道改写S.E.H能够劫持进程、植入恶意代码
可能就够了。但是，作为安全技术的研究人员，异常处理机制还是很有研究价值的，而且几乎
所有大师级别的安全专家都对异常处理机制了如指掌。如果您掌握了异常处理的所有细节，那
么突发奇想地创造出一种新的漏洞利用方法也不是没有可能。
本节在总结前人研究的基础上，将对Windows异常处理做一个逐步深入的介绍，希望这些
内容能够在您进行更深层次的调试和研究时，起到一定的指导作用。如果您只是关注漏洞利用
技术本身，可以跳过这里继续后面的章节。
异常处理的最小作用域是线程，每个线程都拥有自己的S.E.H链表。线程发生错误时，首
先将使用自身的S.E.H进行处理。
一个进程中可能同时存在很多个线程。此外，进程中也有一个能够“纵览全局”的异常处
理。当线程自身的S.E.H无法“摆平”错误的时候，进程S.E.H将发挥作用。这种异常处理不
仅仅能影响出错的线程，进程下属的所有线程可能都会受到影响。
除了线程异常处理和进程异常处理之外，操作系统还会为所有程序提供一个默认的异常处
187
---
## Page 213
0
day
理。当所有的异常处理函数都无法处理错误时，这个默认的异常处理函数将被最终调用，其结
安
果一般是显示一个错误对话框（我们经常见到的程序崩溃时的那种对话框）。
全
现在我们可以将前面所给出的最简单的异常处理流程补充如下。
：
·首先执行线程中距离栈顶最近的S.E.H的异常处理函数。
软
件
·若失败，则依次尝试执行S.E.H链表中后续的异常处理函数。
漏
·若S.E.H链中所有的异常处理函数都没能处理异常，则执行进程中的异常处理。
洞
·若仍然失败，系统默认的异常处理将被调用，程序崩溃的对话框将被弹出。
分
本节我们会将这个处理过程继续细化，直到接近操作系统真实的做法。
析
技
（2）线程的异常处理
术
通过前面的实验，相信大家已经理解了线程中通过TEB引用S.E.H链表依次尝试处理异常
（第
的过程。这里，首先需要补充的是异常处理函数的参数和返回值。
线程中的用于处理异常的回调函数有4个参数。
2
·pExcept：指向一个非常重要的结构体EXCEPTION_RECORD。该结构体包含了若干
版
与异常相关的信息，如异常的类型、异常发生的地址等。
●pFrame：指向栈帧中的S.E.H结构体。
·pContext：指向Context结构体。该结构体中包含了所有寄存器的状态。
·pDispatch：未知用途。
在回调函数执行前，操作系统会将上述异常发生时的断点信息压栈。根据这些对异常的描
述，回调函数可以轻松地处理异常。例如，遇到除零异常时，可以把相关寄存器的值修改为非
0：内存访问错误时，可以重新把寄存器指回有效地址等。
这种回调函数返回后，操作系统会根据返回的结果决定下一步应该做什么。异常处理函数
可能返回两种结果。
0（ExceptionContinueExcetution）：代表异常被成功处理，将返回原程序发生异常的地方，
继续执行后续指令。
注意：操作系统是通过传递给回调函数的参数恢复断点信息的，这时的“断点”可能
已经被异常处理函数修改过，例如，若干寄存器的值可能被更改以避免除0异常等。
1（ExceptionContinueSearch）：代表异常处理失败，将顺着S.E.H链表搜索其他可用于异
常处理的函数并尝试处理。
线程的异常处理中还有一个比较神秘的操作叫做unwind操作，这个操作会对我们已经建
立起来的异常处理流程的概念再做一点修改。
系统会将已经追历过的S.E.H中的异常处理函数再调用-遍，这个过程就是所谓的unwind操
作，这第二轮的调用就是unwind调用。
弃”了，请它们立刻清理现场，释放资源，之后这些S.E.H结构体将被从链表中拆除。
unwind操作很好地保证了异常处理机制自身的完整性和正确性。图6.1.11描述的是一个由
188
---
## Page 214
第
于没有使用unwind操作从而导致异常处理机制自身产生错误的例子。
6
章
FS:0
FS:0
NoSEH
Next_S.E.H
FS:0
形
Handler 1
Hae
形
色色的内存攻击技术
Next_S.E.H
N-SEH
NexC3.E.
Handler 2
Ha
Next_S.E.H
Next_S.E.H
Next_S.E.H
Handler 3
Handler 3
Handler 3
.........
程序运行中产生异常，
Handier3所指的异常处
程序继续运行，经过一系
系统在遍历S.EH链表
理函数引导系统回到比
列压栈操作后，前两个
时发现第三个句柄能够
所在的函数中继续执
S.EH被破坏.这时再次发
成功处理错误。
行，这会引起前边的栈
生异常，fs:O所指的S.E.H
帖被简单地抛弃。
此刻为无效数据，异常处
理机制自射将发生错误
图6.1.11unwind操作示意图
unwind操作就是为了避免在进行多次异常处理，甚至进行互相嵌套的异常处理时（执行异
常处理函数中又产生异常），仍能使这套机制稳定、正确地执行而设计的。unwind会在真正处
理异常之前将之前的S.E.H结构体从链表中逐个拆除。当然，在拆除前会给异常处理函数最后
一次释放资源、清理现场的机会，所以我们看到的就是线程的异常处理函数被调用了两次。
异常处理函数的第一轮调用用来尝试处理异常，而在第二轮的unwind调用时，往往执行
的是释放资源等操作。那么，异常回调函数怎么知道自己是被第几次调用的呢？
unwind调用是在回调参数中指明的。对照MSDN，我们回顾一下回调函数的第一个参数
pExcept所指向的EXCEPTION_RECORD结构体。
typedef struct_EXCEPTION_RECORD(
DWORDExceptionCode;
DWORDExceptionFlags；//异常标志位
PVoID ExceptionAddress;
DwORD NumberParameters;
DWORD ExCeptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
}EXCEPTION_RECORD;
当这个结构体中的ExceptionCode被设置为OxC0000027（STATUS_UNWIND），并且
189
---
## Page 215
0
day
ExceptionFlags被设置为2（EH_UNWINDING）时，对回调函数的调用就属于unwind调用。
安
unwind操作通过kemerl.32中的一个导出函数RtlUnwind实现，实际上kermel32.dll会转而
全
再去调用ntdll.dll中的同名函数。MSDN中有对这个函数的描述。
：
软
void RtlUnwind(
件
PVOID TargetFrame,
漏
PVOID TargetIp.
洞
PEXCEPTIoN_RECORDExCeptionRecord,
分
PVOID ReturnValue
析
技
术
最后，还要对栈中的异常处理做最后一点补充：在使用回调函数之前，系统会判断当前是
（第
否处于调试状态，如果处于调试状态，将把异常交给调试器处理。
（3）进程的异常处理
2
所有线程中发生的异常如果没有被线程的异常处理函数或调试器处理掉，最终将交给进程
版
中的异常处理函数处理。
进程的异常处理回调函数需要通过API函数SetUnhandledExceptionFilter来注册，其函数
原型如下。
LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(
LPTOP_LEVEL_EXCEPTION_FILTER1lpTopLevelExceptionFilter
这个函数是kermel32.dll的导出函数，MSDN中有对其的相关描述。
提示：您可以简单地把线程异常处理对应为代码中的_try[）_excepti或者Assert
等语句，把进程的异常处理对应于函数SetUnhandledExceptionFilter。
进程的异常处理函数的返回值有以下3种。
·1（EXCEPTION_EXECUTE_HANDLER）：表示错误得到正确的处理，程序将退出。
·O（EXCEPTION_CONTINUE_SEARCH）：无法处理错误，将错误转交给系统默认的
异常处理。
·-1（EXCEPTION_CONTINUE_EXECUTION）：表示错误得到正确的处理，并将继续
执行下去。类似于线程的异常处理，系统会用回调函数的参数恢复出异常发生时的断
点状况，但这时引起异常的寄存器值应该已经得到了修复。
（4）素统默认的异常处理U.E.F
如果进程异常处理失败或者用户根本没有注册进程异常处理，系统默认的异常处理函数
UnhandledExceptionFilter（）会被调用。看到函数名，顾名思义，这个函数好像一个“筛选器”，
所有无法处理的异常都将被它捕获并处理，不会出现任何漏网之鱼。有时我们会将这个“终极”
异常处理函数简称为U.E.F（UnhandledExceptionFilter）。
190
---
## Page 216
第
注意：MSDN中将U.E.F称为“top-levelexception handler"，即顶层的异常处理，或最后
6
使用的异常处理；将我们所说的用户自定义的进程异常处理SetUnhandledExceptionFilter
章
理解为用户在顶层异常处理之前插入的自定义异常处理“supersedethetop-level
形
exceptionhandler”。不难发现这两种表述的实际内含是一样的，请读者注意本书表述
形
和MSDN中表述的对应关系。
色
色
UnhandledExceptionFilter（）将首先检查注册表HKLM\SOFTWAREMicrosoftiWindowsNT
的
CurrentVersion\AeDebug下的表项，如图6.1.12所示。
内
存
攻
击
技术
REG_DWORD
图6.1.12U.E.F依赖的注册表项
路径下的Auto表项代表是否弹出错误对话框，值为1表示不弹出错误对话框直接结束程
序，其余值均会弹出提示错误的对话框。这个错误对话框您一定不会陌生，图6.1.13和图6.1.14
分别是Windows2000和WindowsXP下这个对话框的样子。
X用作发生用营uno
牌止序，课单出草间
图6.1.13Windows2000下的U.E.F错误提示框
SEHtest.ex
SEH_tost.exe has encounteredaproblem ond noeds to
close. We are sorry lor the inconvenience.
Ilyouwreintdesingilmtonyou
migt belot.
Please lollMicrosoft about this problom
snouuouepuepgupyuoeoda
Debug
图6.1.14WindowsXP下的U.E.F错误提示框
191
---
## Page 217
0
day
注册表的Debugger指明了系统默认的调试器，在错误框弹出后，如果您选择调试，
安
UnhandledExceptionFilter就会按照这里的命令加载相应的调试器。我使用的默认调试器是
全
OllyDbg
：
（5）异常处理流程的总结
软
至此，异常处理的流程已经被扩充地与真实的流程比较接近了，总结出以下几点。
件
漏
·CPU执行时发生并捕获异常，内核接过进程的控制权，开始内核态的异常处理。
洞
●内核异常处理结束，将控制权还给ring3。
分
析
技
·KiUserExceptionDispatcherO首先检查程序是否处于调试状态。如果程序正在被调试，
术
会将异常交给调试器进行处理。
第
·在非调试状态下，KiUserExceptionDispatcherO调用RuDispatchExceptionO函数对线程
的S.E.H链表进行遍历，如果找到能够处理异常的回调函数，将再次遍历先前调用过
2
的S.E.H句柄，即unwind操作，以保证异常处理机制自身的完整性。
版
●如果栈中所有的S.E.H都失败了，且用户曾经使用过SetUnhandledExceptionFilterO函
数设定进程异常处理，则这个异常处理将被调用。
·如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么系
统默认的异常处理UnhandledExceptionFilterO将被调用。U.E.F会根据注册表里的相关
信息决定是默默地关闭程序，还是弹出错误对话框。
以上就是Windows异常处理的基本流程。需要额外注意的是，这个流程是基于Windows
2000平台的，WindowsXP及其以后的操作系统的异常处理流程大致相同，只是
KiUserExceptionDispatcherO在遍历栈顿中的S.E.H之前，会去先尝试一种新加入的异常处理类
型V.E.H（VectoredExceptionHandling）
6.1.5其他异常处理机制的利用思路
1.V.E.H利用
从WindowsXP开始，在仍然全面兼容以前的S.E.H异常处理的基础上，微软又增加了一
种新的异常处理：V.E.H（VectoredExceptionHandler，向量化异常处理）。
在我们已有的异常处理机制的基础上，对于V.E.H还需要知道以下几个要点。
（1）V.E.H和进程异常处理类似，都是基于进程的，而且需要使用API注册回调函数。相
关API如下所示。
PvoID AddVectoredExceptionHandler(
ULoNG FirstHandler,
PVECTORED_EXCEPTION_HANDLERVectoredHandler
（2）MSDN上有对V.E.H结构的描述。
strUCt_VECTORED_EXCEPTION_NODE
192
---
## Page 218
第
6
DWORDm_pNextNode;
章
DWORDm_pPreviousNode;
PVoIDm_pfnVectoredHandler;
形
形
（3）可以注册多个V.E.H，V.E.H结构体之间串成双向链表，因此比S.E.H多了一个前向
色
色
指针。
的
（4）V.E.H处理优先级次于调试器处理，高于S.E.H处理：即KiUserExceptionDispatcherO
内
首先检查是否被调试，然后检查V.E.H链表，最后检查S.E.H链表。
存
（5）注册V.E.H时，可以指定其在链中的位置，不一定像S.E.H那样必须按照注册的顺序
攻
击
压入栈中，因此，V.E.H使用起来更加灵活。
技
（6）V.E.H保存在堆中。
术
（7）最后，unwind操作只对栈顿中的S.E.H链起作用，不会涉及V.E.H这种进程类的异常
处理。
我们已经知道，在WindowsXP以后，微软为Windows加入了V.E.H异常处理，并优先于
S.E.H使用。V.E.H被组织成双向链表的形式，当异常发生时，系统将遍历这个链表并依次使用
V.E.H中的句柄，尝试处理异常。
DavidLitchfield在BlackHat上的演讲“Windowsheapoverflows”（http://www.blackhat.com/
presentations/win-usa-04/bh-win-04-litchfield/bh-win-04-litchfield.ppt）中提出，如果能够利用堆
溢出的DWORDSHOOT修改指向V.E.H头节点的指针，在异常处理开始后，将能够引导程序
去执行shellcode。
David在论文中指出，标识V.E.H链表头节点的指针位于0x77FC3210，并且还为这种利用
方式给出了两段POC代码，有兴趣的朋友可以深入研究这篇文章。
2.攻击TEB中的S.E.H头节点
异常发生时，异常处理机制会遍历S.E.H链表寻找合适的出错函数。前面已经介绍过，
线程的S.E.H链通过TEB的第一个DWORD标识（fs：O)，这个指针永远指向离栈顶最近的那
个S.E.H。如果能够修改TEB中的这个指针，在异常发生时就能将程序引导到shellcode中去
执行。
这种方法最早是由HalvarFlake在BlackHat的著名演讲“ThirdGenerationExploitation”
(http://www.blackhat.com/presentations/win-usa-02/halvarflake-winsec02.ppt）中提出。
HalvarFlake同时也指出了这种利用方法的一些局限性。要理解这种局限性，需要简单了
解一下TEB的知识。
（1）一个进程中可能同时存在多个线程。
（2）每个线程都有一个线程环境块TEB。
（3）第一个TEB开始于地址Ox7FFDE000。
（4）之后新建线程的TEB将紧随前边的TEB，之间相隔0x1000字节，并向内存低址方向
增长。
193
---
## Page 219
0
day
（5）当线程退出时，对应的TEB也被销毁，腾出的TEB空间可以被新建的线程重复使用。
安全
线程环境块位置的预测如图6.1.15所示。
0x7FFDE000:TEB1
O7FFDE000:TEB1
0x7FFDE000:TEB1
**