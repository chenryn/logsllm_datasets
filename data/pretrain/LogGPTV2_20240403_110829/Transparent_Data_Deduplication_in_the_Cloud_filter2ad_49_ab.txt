When a client C wants to download a ﬁle f, it initiates this proto-
col with G and sends the corresponding ﬁle ID FID. The gateway
ﬁrst checks if F contains an entry (FID,CFID ). In the positive
case, it further veriﬁes if C ∈ CFID. If this veriﬁcation passes,
actions are taken such that eventually the client can download the
encrypted ﬁle f∗ from S and decrypt it to f with kFID. Observe
that we do not specify additional tokens to authenticate the client
as we assume the existence of authenticated channels between the
clients and G.
Get
:
[C : FID, kFID ; G : F; S : f
[C : f ; G : ⊥; S : ⊥]
∗
] −→
The Delete Protocol.
This protocol allows a client to delete a ﬁle or, more precisely,
to cancel his registration. To this end, the client sends the ﬁle ID
FID to the gateway who checks if (FID,CFID ) ∈ F for some set
CFID and if C ∈ CFID. If this is not the case, the request is sim-
ply ignored and C receives f = ⊥. Otherwise CFID is updated to
CFID \ {C} at the beginning of the next epoch. If CFID becomes
empty by this action, this means that no user is any longer regis-
tered to this ﬁle. Hence, G can request to S to delete the ﬁle.
Delete
:
[C : FID; G : F; S : f
[C : ⊥; G : F; S : ⊥]
∗
] −→
The Attest Protocol.
The purpose of the Attest procedure, which is executed by the
gateway only, is twofold. On the one hand, it generates a proof of
cardinality for a given ﬁle ID FID and an epoch E that attests an
upper bound for |CFID|—the number of clients registered to this
ﬁle within this epoch. On the other hand, it also includes a proof of
membership for a given client C with respect to CFID. Formally,
we have:
A ← Attest(FID, E,CFID , C).
The proof A, i.e., the output of Attest, contains a claim on an upper
bound of |CFID|, a compact digest for CFID, and possibly additional
information, so that a client C ∈ CFID can use the subsequent
Verify to get convinced of the upper bound of the set CFID and
its own membership. As described in Section 2.2, an upper bound
for |CFID| is sufﬁcient and necessary in our model. Namely, G
does not have incentives to report a larger value of |CFID| since this
results in G under-charging clients and hence a reduction of the
proﬁt. Therefore, to increase its proﬁts, G’s interest is to claim the
smallest possible upper bound at the end of each epoch.
The Verify Protocol.
In ClearBox, customers can verify (using the Verify protocol) the
proof generated by the Attest protocol to conﬁrm that they are part
of the set of ﬁle users, and to verify the upper bound on the total
number of ﬁle users. The Verify algorithm is executed by a client,
and uses the veriﬁcation tag which has been generated during the
Put procedure.
It outputs either accept or reject to indicate whether the proof
is accepted or not.
accept|reject ← Verify(FID, E,A, τ ).
2.2 Security Model
In the sequel, we assume that the communication between a
client and the gateway is authenticated to provide non-repudiation
and, in the case of need, encrypted. As already stated, we assume
that time is divided into a sequence of epochs E1, E2, . . ., where
E ≤ E(cid:48) means that E either took place before epoch E(cid:48) or that
both refer to the same epoch. If not mentioned otherwise, we will
always refer to epochs that happened in the past. Moreover, we
assume that all parties are synchronized. That is, at each point in
time, all parties share the same view on the current epoch (e.g., its
index number if epochs are represented by an increasing counter).
In each epoch, several protocol runs may be executed between
the gateway G and a client. A protocol run is represented by a
quadruple pi = (C, prot, (in), (out)) where C is a client, prot
denotes one of the protocols Put, Get, Delete, in denotes the inputs
of C, and out its outputs. For any past epoch E, we denote by PE
all protocol runs that occurred within this epoch. Here, we restrict
ourselves to full protocol runs, i.e., which have not been aborted.
We assume that these are uniquely ordered within the epoch. That
is for PE = {p1, . . . , p(cid:96)} where (cid:96) denotes the total number of
protocol runs within this epoch, it holds for any p, p(cid:48) ∈ PE with
p (cid:54)= p(cid:48) that either p  bd implies that
P r [accept ← Verify(FID, E,A, τ )|] ≤ ε.
(6)
Observe that it is not in the interest of a rational gateway in our
model to report a larger value for |CFID (E)| as this would allow
the clients to demand further cost reductions.
With respect to the conﬁdentiality of the uploaded data, notice
that standard semantically secure encryption schemes cannot be
used in our context since they effectively prevent the deduplica-
tion of data [14, 25, 42]. Schemes that are suitable for dedupli-
cation produce the same ciphertext for multiple encryptions of the
same message and are referred to as message-locked encryption
(MLE) [13, 15]. The achievable security in our case is therefore
that of MLE schemes.
To describe the security of MLE schemes, we adapt in what fol-
lows the security notion introduced in [15] which guarantees pri-
vacy under chosen distribution attacks.
3We assume the gateway to be curious in this respect.
An MLE scheme consists of a tuple of algorithms (setup, keygen,
enc,dec, tag), where setup generates (public) parameters P , the
key generation keygen generates a key k given P and a message
f; ﬁnally, enc and dec are the algorithms to encrypt and decrypt
f with key k. The tag generation algorithm tag creates a tag for a
ciphertext. This is covered in our model by the unique ﬁle identiﬁer
FID and does not play a role in the privacy notion.
A message space is given by an algorithm M which samples
messages M ∈ {0, 1}∗ according to a distribution and may provide
additional context information. The message sampling must be un-
predictable, i.e., the probability to predict the output of M is neg-
ligible given context information. The security of an MLE scheme
is deﬁned by the following experiment PRV$-CDAA
M LE,M, an un-
predictable sampling algorithm M and an adversary A [15]:
1. The environment randomly generates a parameter set P and
a bit b ← {0, 1}.
2. The environment samples a set of messages M and context
information Z: (M, Z) ← M. As the same message would
result in the same encryption, the restriction here is that all