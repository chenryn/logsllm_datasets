目录的权限称为访问权限，在这里，这些术语实际上是可以互换的。
Linux或类UNIX操作系统中，定义文件权限的术语如下：
·非组成员（简写成o），即不能被分到其他类别中的用户。
·文件所有者（简写成u）。
·组成员（简写成g），即文件所有者所在组的访问控制权限。
以这种互斥的方式对用户进行分组，使用户可以方便地调整谁有权访问指定的
文件。即，我们可以同时按照文件的拥有者，拥有者所在的组和其他所有可能的用
户来指定它的访问权限。
对于每一类用户（组，其他用户和所有者），访问控制权限被定义成如下五种。
·读文件（r）：谁被允许读取文件的内容。
。写文件（w）：决定谁有权增加或修改文件的内容。
·可执行（x）：给定用户组的成员是否可以执行文件中的指令。
·SetGroupID（S）：（拥有这个权限的）文件必须是可执行。它定义了用户的
权限可以提升到出现该标志位的那个组所拥有的权限。此权限可允许低权限
的用户提升他们的权限，以执行特定任务。例如，把某个用户的权限提升到
232
---
## Page 251
第8章原生代码中温洞的利用与分析
root或者任何他想要的用户的权限—当然，我们假设他已经成功登录了！
·SetUserID（s）：这决定了文件所有者的userID及其所有访问控制权限，是
否能被传送给正在执行的进程。
所有这5类权限都是按照描述它的术语的助记符—以缩写的形式—或八进
制编码的位值来定义的，对于初学者来说，这样的描述可能会令人困惑。所以这一
节里给出了一张同时使用二进制和八进制（即，数字的基数为8）来定义这些值的简
表，如表8.1所示。
为什么以8为基数？因为在二进制中基数8里能容纳3个bit位，每一个都能描
述一种访问控制权限的布尔值：1为开（或真），0为关（或假）。
表8.1
描述
二进制值
十进制值
读
100
写
010
2
执行
001
1
如果把这些二进制值加起来。这张表就是如表8.2所示的这个样子。
表8.2
描述
读
写
执行
读
100
4
110
6
101
5
写
010
2
011
3
执行
001
1
每一类用户都会被指定这样一个八进制数，也就是说对每一类用户来说，其中
的一个位就代表一种权限。因为我们把用户分成了三类一
一即，文件所有者，组成员
和非组成员
通常它们就被认为是“整个世界”。权限bit位还包含一个额外的bit
用以定义setuid、setgid和l sticky。
stickybit位规定的也是个访间权限，它只允许文件或目录的所有者对其进行删除
或重命名操作。当它被设为1时，以ls命令显示文件访间权限时，表示它的符号是T。
相应的结构看上去如表8.3所示。
表8.3
Owner
Group
Other
I
/
W
W
233
---
## Page 252
Android安全攻防实战
这差不多是关于文件访间权限的所有基础知识了。如果你已经认真学习了前面
的内容，你应该已经具备了足够的知识，去准确地辨识出因Android原生文件的访问
权限设置问题，而导致的大部分基本缺陷了。
为了正确地认识厂商在设备的操作系统上增添的差异，你需要了解一点“默认
的”或标准的Android文件系统在结构和访问权限设置方面的知识，如图8.1所示。
sh./adbsheld
drwxr-xr-x root
/e-51s/:p
rysten
racte
2013-09-3883:37 acct
rwxrwx
not
root
2013-05-01 11:58 cache
root
-rw-r-
rnot
root
1970-01-01
2013-09-30 83:37 data
root
116
rodto
root
syot
03:37
/etc
rw-r
root
root
189336
911
oot
root
3604
1978-01-01
1970-01-01
82:08 init
oot
root
2344
31254
1970-01-01
00t
15141
1970-01-01
1970-01-01
02:00 init.rc
rnot
6583
82:88
02:00
FMYE
root
1637
1970-01-01
init.trace.rc
o0t
3915
1970-01-01
oot
root
F001
1618
02:00
Lib
rc
dr-xr-xr-x
system
root
root
2013-01-15
root
1970-01-01
2013-09-30
03:37 sdcard
02:00sbin
root
sdcard_r
root
->/storage/sdcarde
vstem
oot
2013-09-30
63:37
root
root
root
3279
1970-01-01
1970-01-01
02:00
oat
rot
3430 1970-01-010
02:60u
图 8.1
这里是我们根据Linux文件系统层次结构和Jelly Bean（Android 4.1的代号）中
的init.rc脚本，对默认的或标准的文件系统中，文件夹及其用途作的一个概述，如表
8.4所示。在下一个教程“检测系统配置”（Inspecting System Configurations）的拓展
阅读部分中，我们还会给出一些其他平台上initrc脚本的参考资料。
234
---
## Page 253
第8章原生代码中漏润的利用与分析
表8.4
文件夹
用途
/acct
cgroup挂载点（mount point），用于CPU资源的监控和计数
/cache
临时存储器，用于存放正在下载内容，也用于存储非必要的数据
/data
存放app以及app中其他文件夹的目录
/dev
设备节点，与经典Linux 系统中的作用一样，尽管一般不会经常用它
来访问设备和硬件驱动程序
/etc
/system/etc/的符号链接，其中含有配置脚本，其中的一些会在系统启
动过程中由 startup 进程运行
/mnt
临时的挂载点，和许多其他传统的Limux系统中的一样
/proc
包含与处理器相关的数据结构和信息，作用类似于它在传统的Linux
或UNIX系统中的作用
/root
般就是个空目录，和传统的Linux/UNIX系统中的一样，它也被用
作 root用户的 home 目录
/sbin
存放执行系统管理任务的重要实用程序（utity）的文件夹
/sdcard
扩展sd卡的挂载点
/sys
sysfs 挂截点，其中含有导出的内核数据结构
/system
系统编译时产生的，不可修改的（只读）二进制可执行文件和脚本，
在许多Android系统中，其中也存放了系统拥有（system-owned）的
应用程序
/vendor
专为俱应商留出的，供其对设备进行扩展的目录，其中会存放二进制
可执行文件、应用程序和配置脚本等
/init
系统启动过程中，在加载了内核之后，就会执行init这个二进制可执
行文件
/init.rc
二进制可执行文件init 的配置脚本
/init[device_name].rc
与设备相关的配置脚本
/uevent.rc
守护进程uevent的配置脚本
/uevent[device_name].rc
供守护进程uevent使用的设备相关的配置脚本
/default.prop
含有系统全局属性（包括设备名称）的配置文件
/config
configfs的挂载点
/storage
Android 4.1及后续版本中新增的目录，被用作扩展存储卡的挂载点
/charger
一个原生的独立应用程序，用来显示电池剩余电量
要记住：不同的厂商为他们的设备专门编译的Android版本之间还会有不同，上
235
---
## Page 254
Android安全攻防实战
面给出的这些仅仅是最基本的，“原教旨”文件系统布局及用途。厂商常会误用使用
其中的一些文件路径，或出于自身目的而改变相关目录的用途。所以，在看待这些
文件夹的作用及其默认访问权限时，还得留个心眼！
本章节不会对文件系统布局进行全面详细的解析，但在拓展阅读部分会介绍一
些很好的有关Android和Linux文件系统中语义、布局和约定的资源。
让我们来看看如何在Android系统上寻找我们所关心的文件或目录。下面的实验
中，假定你已经拥有了做实验的设备上的ADB shell 的权限了。
准备工作
为了能够运行下面示例中使用的命令，你需要安装find这个二进制可执行文件
或forAndroid 版的 Busybox，安装教程在 http://www.busybox.net/，也可以参考本章
怎么做·
按照访问控制权限，搜索相关的文件。只要在你的ADBshell中执行下面这条命