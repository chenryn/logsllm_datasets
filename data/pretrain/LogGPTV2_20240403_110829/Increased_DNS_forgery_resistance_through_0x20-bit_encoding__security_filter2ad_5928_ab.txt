could be used instead. But regardless of the implementation, DNS
servers that use both the ID ﬁeld and source port have ≈ 230 to
≈ 232 possible combinations that an attacker must guess (depend-
ing on how the server handles reserved ports).
Recently, Dan Kaminsky announced a technique to replace NS
records by performing a series of nonce queries [13]. In this tech-
nique, the attacker merely induces a random A? query, and spoofs
answers with appropriate IN A answers as well as an NS update.
If the spoofed attack fails to match the ID ﬁeld, another random
A? query is generated, and another round of spoofed answers is
sent. Eventually (within ≈ 6 seconds on most networks), a match-
ing ID ﬁeld is generated by the attacker, and the attacker uses the
authority section of the winning packet to evict the previous cached
NS record. This innovative approach reduces the attack time from
weeks to seconds, allowing trivial control of DNS cache lines. An
unprecedented multi-vendor response followed [30]. For the most
part, DNS vendors defended against the Kaminsky-class attack by
implementing port randomization to “grow the key space”. DNS
vendors also changed their glue-handling policies to better validate
or reject the rogue NS update.
In the DNS attacker/defender cat-and-mouse game, DNS opera-
tors continually look for additional opportunities to improve trans-
action integrity, and attackers search for weaknesses in implemen-
tations, and other methods to predict transaction tokens.
3. BASIC DNS POISONING MODEL
While others have shown that DNS stub resolvers can be sub-
verted [8], our concern is in protecting the recursive resolver in its
transactions with the authority servers. To do this, we ﬁrst need to
characterize the risk of poisoning to any server.
Many of the basic mechanical steps in DNS poisoning are well-
known to attackers. For example, anticipating when a recursive
server will initiate a DNS query is straightforward. Attackers can
iteratively observe cache values over time (and initiate attacks when
previously valid cached entries time out and are queried again).
Similarly, open recursive servers can be forced to do lookups, e.g., [8].
Additionally, secured DNS servers might be obligated to initiate
lookups for domains that the attacker sends to the attention of pro-
tected networks (e.g., by interacting with mail servers, ﬁrewalls, or
logging webservers, which in turn resolve domains associated with
the sessions).
Without loss of generality, we use the scenario where an at-
tacker identiﬁes and queries open recursive (OR) servers. Without
lets us show the relative improvement in forgery resistance, as dis-
cussed in Section 5. Thus, a threshold of 10% is suitable for our
purposes.
Clearly, the RTT (or delay between the OR and SOA), plays an
important role in the attacker’s chances of success. If △t is large,
the poisoner can send more spoofed packets, one of which might
match the required transactional ID ﬁeld and port numbers. Even
in a Kaminsky-class attack (which is largely bandwidth limited),
the RTT determines the number of spoofed packets one can send.
As noted in Section 2, many DNS vendors have also changed their
glue handling policies so that rogue NS updates are inspected and
re-validated. This means RTT remains one the most important vari-
ables for an attacker.
In practice, the RTT for DNS messaging varies, since recursive
and authority DNS servers could be located anywhere. Fortunately,
there are known techniques to measure the RTT between any tu-
ple of open recursive and authority servers. In [11], Gummadi, et
al., described “King”, a measurement technique that uses repeated
probes of open recursive servers. In general, King uses two queries
to measure the RTT between a recursive and authority server: one
for a nonce record that is not in cache, and a second, duplicate query
that gets answered from the recursive’s newly populated cache. The
time difference between the two is the RTT between the recursive
and authority servers.
To observe variability in RTT, and suggest reasonable bounds for
estimating △t (which in turn determines the number of attack pack-
ets that can be sent) we implemented a larger, expanded version of
King. We followed several steps.
1. First, we obtained lists of open recursive servers, from both
the Measurement Factory’s study, [36], and by contacting the
authors of [8], who measured tens of millions of such servers.
We mapped each open recursive to an Autonomous System
(AS), and randomly selected 5,000 resolvers from ripencc,
arin, apnic and 500 from afrinic servers. We further veriﬁed
the hosts were still open recursive.
2. We then created a domain, created an NS for the domain, and
made sure its NS propagated to the parent zone.
3. We next “primed” each open recursive to make sure they
had cached the root servers, TLDs, and required intermedi-
ate zones. (This avoided measuring the time needed by the
recursive to locate the authority server.)
4. We then used the following probe technique, for hundreds of
random labels within our domain. For each random label,
Ri, we asked from several locations:
• Iteratively asked the OR for the label Ri. I.e., we made
sure it had not somehow cached the answer already. We
recorded the response time as tA.
• Recursively asked the OR for Ri again. I.e., we forced
it to consult the authority server. We knew from previ-
ous steps that the parent zone information and NS for
our zone were already cached. We measured this time
as tB
• Iteratively asked the OR for Ri again. We noted the
time it took as tC .
• Calculate: RT Ti = tC − tB. As a sanity check, we
also veriﬁed that tC −tB ≈ tC −tA. I.e., the difference
between the recursive and any iterative probe should
be the same. (The observed variance, due to inherent
variability in network delays, is reported in Figure 4,
and discussed below.)
Figure 2: The attacker’s time window for a cache poisoning
attack on a DNS server during a iterative query.
a cached record, recursive servers need to start “upstream” itera-
tive queries in order to locate the authoritative servers. As noted in
Section 2, portions of the iterative SOA discovery may be cached
(e.g., the authority server for the TLD may be cached). Figure 2
shows all of the various stages of this iterative process, assuming
no caching takes place.
The x-axis of Figure 2 indicates time. The period between steps
t5 and t6 in the diagram constitutes the vulnerable window for a
DNS poisoning attack. During this △t period, the OR waits for an
answer from the SOA. Attackers can send malicious answers to the
OR, and repeat the process until they guess the appropriate ID ﬁeld,
or the authority ﬁnally responds.
Figure 2 shows (in densely packed arrows) numerous packets
sent by the attacker to the recursive server. The diagram shows a
progression that ﬁnally matches the ID ﬁeld. Each constitutes a
single guess of the required ID ﬁeld and port values. In our model,
we also assume the answer’s TTL (or caching period) is such that,
if the attack fails, the attacker must wait a lengthy period of time
before trying again. (The poisoner is free to try again, of course,
but must wait TTL seconds–assumed to be a very long time.)
Deﬁnition 1. We say a DNS server is forgery resistant where T T L ≫
△t, and the chance of an attack being successful within △t time is
low.
We realize that terms such as “low” are unclear. After all, de-
termined attackers may try an attack, regardless of the chance of
success. We clarify Deﬁnition 1 with the following assumption:
Assumption 1. If attack is not 10% likely to succeed within Tmax,
we deem the DNS server is forgery resistant.
We pick 1 day for Tmax, a time that matches a very commonly
used TTL period (86400 seconds). Further, one day is a reasonable
period of time during which DNS logs could (should) be read by
an administrator, or the poisoning attack otherwise noticed by IDS
equipment.
We also note that, while 10% is clearly arbitrary, it provides us
with a simple means of assessing DNS poison resistance. Absent
protocols such as DNSSEC, all DNS servers are vulnerable to some
level of poisoning attack. The goal is to make the chance of success
as low as possible.
For a particular context, depending on the value of the target,
one can adjust this value, and determine the resistance of a DNS
deployment to poisoning. Note that the purpose of our work is to
demonstrate an improvement in security. Using this assumption
5. After noting the RT Ti for each 1 . . . n round of queries, we
calculated the average RTT between our SOA and the recur-
sive server.
The distribution of RTT times, from the stub resolver’s perspec-
tive, appears in Figure 4(a). A CDF plot of these RTT times is
shown in Figure 4(b). There are several observations one can make.
First, these measurements generally ﬁt the prevailing wisdom of
DNS operators that all DNS messages take anywhere 100 to 400
milliseconds to complete, with a long tail taking much longer due
to drops, timeouts, and other problems (e.g., server failure).
Second, if the domain is cached, then the average query/answer
response time is less than 100 millisecond. On the other hand if the
query was not cached it can take close to 400 milliseconds for the
recursive server to present an answer back to the resolver.
Our small study helps us understand the dimensions of △t. For
a given percentage of queries (say, the RTT for 90% of all lookups
between an OR and SOA tuple), and can estimate the RTT, and
from there determine the number of “guesses” an attacker can make
before the correct authority answer arrives.
Deﬁnition 2. We can therefore state the chance of successfully
poisoning a DNS server, for a single packet:
We assume:
α = Number of Different DNS IDs (universally 216 or 65,535
values)
β = Number of Source Ports (conceptually 216).
γ = Number of Ports excluded (often 1024, or depending on
kernel resources [12].)
θ = Number of authority servers and recursive IPs. Many au-
thority clusters include multiple DNS servers with independent pub-
lic IP addresses (to provide power and geographic diversity). A re-
cursive server normally RTT sorts the servers, and then queries the
closest host. No RFC mandates this, however, and recursives can
also randomly select any authority server θi. Additionally, some
recursive servers are multi-homed, and could select any routable
source address for its query. Thus, θ is the product of all public fac-
ing addresses used by the recursive and authority servers. For such
multi-homed servers, an attacker has to spoof the correct authority
source address, and send this to the correct recursive address.
model. The logscale x-axis depicts the number of attack packets.
Based on the RTT study (and assuming a window of 100ms, with
the attacker using a 100Mb/s connection), some 13,000 packets can
be sent. The linear y-axis shows a range of θ, the combined IPs of
the authority and recursive servers. The logscale z-axis shows the
probability of a successful attack. RFC 1912 recommends a small
number of authority DNS servers, and no more than ≈ 7 [6]. While
not a standard, this advice is general wisdom, and even large enter-
prise zones (e.g., search engines, Fortune 500 companies) have just
three or four public IPs for their authority server farms.
The upper mesh drawn in Figure 3 shows the rate of success
against a DNS server using just ID ﬁeld randomization and a ﬁxed
port. Unless signiﬁcant numbers of additional authority servers are
brought online (in excess of those normally used, and more than
those recommended by RFC 1912), the chance of an attacker suc-
cessfully poisoning a DNS server rises with the number of attack
packets.
In general, Figure 3 shows that IP diversity provides a
linear increase in security, while port randomization provides an
exponential improvement.
The lower mesh in Figure 3 shows a much better resistance to
forgery attempts. One might be tempted to think that port random-
ization has solved DNS poisoning completely. While clearly use-
ful, [28, 29], port randomization can be overcome by determined
attackers able to send large amounts of trafﬁc [20]. We desire addi-
tional means of security for several reasons:
• Not every recursive DNS server can implement port random-
ization, since it poses unique engineering challenges. Poten-
tially, a server using source port randomization might have to
select(2) over thousands of open sockets, opening and
closing them as they are used. For embedded systems, im-
plementers may be left with expensive poll techniques. As
noted in [8], there are likely millions of recursive servers in
embedded systems.
• Some DNS servers are more important targets, (e.g., ISP
DNS servers that could potentially yield millions of victims).
Even if a DNS server used both the ID ﬁeld and port random-
ization, it may still present a tempting target for persistent,
ongoing, low-grade attacks.
Psuccess(1st) =
1
α ∗ (β − γ) ∗ θ
We therefore need additional DNS protection measures, not merely
to increase forgery resistance, but also to provide a diversity of de-
fense options for a variety of platforms.
In the common case of a server employing both ID and source
port randomization, with 3 authority servers, this amounts to:
Psuccess(1st) =
1
216 ∗ (216 − 1024) ∗ 3
≈
1
12.7B
In sending n packets, an attacker may succeed with:
Psuccess(n) =
n
α ∗ (β − γ) ∗ θ
Other parameters of course affect the actual chance of success.
Bandwidth and trafﬁc loss are also critical variables we’ve not in-
cluded in our model. However, with the pervasive availability of
botnets, compromised machines, and proxies, we assume an at-
tacker would not be constrained. A more complex model would
introduce this as a separate constraint. Since network measurement
studies have generally observed that bandwidth correlates positively
to RTT [7], we omitted this parameter in our simpliﬁed model.
Figure 3 shows the chance an attack will be successful against a
variety of defenses, and illustrates the properties of the simpliﬁed
4. DNS-0X20 BIT ENCODING QUERIES
As noted in Section 2, DNS labels are case insensitive, and in
fact no DNS message assigns any meaning to case differences of
letters. Further, even if a zone conﬁguration ﬁle contains a particu-
lar case pattern, e.g., WWW.EXAMPLE.COM, queries using any case
pattern, e.g., www.example.com will be answered. Case for-
matting may be preserved in cache lines, in service of trademarks;
however matching and resolution is entirely case insensitive.
It turns out that, with minor exceptions, all queries are copied
from the initiator’s packet, exactly into the response. Based on the
available open source implementations that exhibit this behavior, it
appears this behavior comes as a side-effect of efﬁcient program-