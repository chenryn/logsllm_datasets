  写程序时有了方便的命令，就可以把程序写得更简短。在上面假想的例子中，高级语言写出来的程序的长度只有机器语言的五分之一。所以，要是你犯错了，现在也更容易发现。
  高级语言还有一个优点，它使得程序更具有可移植性。不同计算机的机器语言都不是完全相同的。所以，你无法将为某一种机型写的机器语言程序放到另一种机型上运行，只有彻底重写才能实现。但是，如果你的程序是用高级语言写的，你只需要重写编译器就可以了。
  编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。
开放源码
  编译器处理的高级语言代码又叫做源码。它经过翻译以后产生的机器码就叫做目标码。顾客购买市场上的商业软件时得到的往往只是目标码。（目标码很难读懂，所以相当于被加密了，可以保护公司的商业秘密。）但是，后来出现另一种潮流：开放源码的软件。你可以得到源码，并且可以不受限制地修改它。
  这两种方式的真正区别在于，开放源码使你对软件有更大的控制权，如果你想理解开源软件如何运行，只要阅读源码就行了。如果愿意，你甚至可以修改软件、重新编译。
  你之所以需要这样做，一个原因可能是为了修正bug。比如，你自己不可能修正Windows的bug，因为你没有源码。（理论上你也许可以破解目标码，但是实际上这是非常难的。另一方面，软件的授权协议一般也不允许你这样做。）这会导致很大的问题。一旦Windows出现新的安全漏洞，只能等待微软公司发布解决方法，这还算是快的。如果bug的危害性不严重，只是偶尔会让你的机器死机，那么可能不得不等到下一次全面升级后问题才会得到解决。
  开放源码的优势还不仅局限于可以自己动手解决bug。这里的关键是所有人都可以参与。所以，开源软件就像一篇经受同行评议的论文。许许多多的聪明人仔细阅读了Linux和FreeBSD这样的开源操作系统的源码，发现并且解决了大量的bug。相比之下，Windows的可靠性只能依赖于大公司自己的质量保证部门了。
  开放源码的拥护者常常被看作反对知识产权的怪人。其中有些人确实如此，但是我本人肯定不反对知识产权。只是如果你要我安装没有源码的软件，我会非常犹豫。普通的消费者也许不需要看到他们使用的文字处理器的源码，但是在非常强调软件可靠的情况下，出于强烈的工程需求的考虑，会要求开放源码。
语言的战争
  绝大多数程序员在绝大多数时候都使用高级语言编程。现在很少有人使用汇编语言。程序员的时间要比计算机的时间昂贵得多，后者已经变得很便宜了，所以几乎不值得非常麻烦地用汇编语言开发软件。只有少数最关键的部分可能还会用到汇编语言，比如开发某个计算机游戏时，你需要在微观水平控制硬件，使得游戏速度得到最大限度的终极提高。Fortran、Lisp、Cobol、Basic、C、Pascal、Smalltalk、C++、Java、Perl和Python，全都是高级语言。它们只是比较出名的几种而已。现在的高级语言大概有几百种之多。不同机器语言的指令集基本相同，但是高级语言就不一样，它们开发程序的模式差别相当大。
  那么，应该使用哪一种语言？嗯，关于这个问题，现在有很多争论。部分原因是，如果你长期使用某种语言，你就会慢慢按照这种语言的思维模式进行思考。所以，后来当你遇到其他任何一种有重大差异的语言，即使那种语言本身并没有任何不对的地方，你也会觉得它极其难用。缺乏经验的程序员对于各种语言优缺点的判断经常被这种心态误导。
  可能因为想炫耀自己见多识广，某些黑客会告诉你所有高级语言基本相似。“所有编程语言我都用过。”某个看上去饱经风霜又酷的黑客往酒吧里一坐，“你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。”
  这当然是一派胡言。各种语言简直是天差地别，比如Fortran I和最新版的Perl就是两种完全不同的语言，而早期版的Perl和最新版的Perl之间的差别也大得惊人。但是，那个夸夸其谈的黑客可能真的相信自己的这番话，的确有可能使用所有不同的语言写出了与用原始的Pascal语言写的差不多的程序。如果你吃过麦当劳，就会知道全世界各地的麦当劳的味道都几乎一样。#（sphinxs 补充：原文为 “ If you only ever eat at McDonald’s, it will seem that food is much the same in every country.” 此处翻译有误）#
  一些黑客只喜欢自己用的语言，反感其他所有的语言。另一些黑客则说所有的语言都一样。事实介于这两个极端之间。语言之间确实有差别，但是很难确定地说明哪—种语言是最好的。这个领域依然还在快速发展。
抽象性
  高级语言比汇编语言更接近人类语言，而某些高级语言又比其他语言更进一步。举例来说，C语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而Lisp语言的层次则是相当高。
  如果高层级语言比汇编语言更有利于编程，你也许会认为语言的层次越高越好。一般情况下确实如此，但不是绝对的。编程语言可以变得很抽象，完全脱离硬件，但也有可能走错了方向。比如，我觉得Prolog语言就有这个问题。它的抽象能力强得不可思议，但是只能用来解决2%的问题，其余时间你苦思冥想、运用这些抽象能力写出来的程序实际上就是Pascal语言的程序。
  另一个你会用到低层次语言的原因就是效率问题。如果你非常关注运行速度，那么最好使用接近机器的语言。大多数操作系统都是用C语言写的，这并非偶然。不过，硬件的运行速度越来越快了，所以使用C这样的低层次语言开发应用程序的必要性正在不断减少，但是大家似乎还是要求操作系统越快越好。（另一种可能是，人们还是希望“缓存区溢出攻击”继续存在下去，以便让大家时时保持警惕）^。
^“最常见的几种入侵计算机的手法都是利用了C语言的某些特点。当你在C语言中为输入的内容分配出一片内存（也叫“缓存”）时，它会被分配在当前运行代码的返回地址旁边。所谓“返回地址”指的是一块特定内存，当前代码运行完毕以后，就要运行这块内存中包含的代码。也就是说，它实标上是计算机下一步要做的事情。
假定有人打算入侵你的计算机，他们猜出你会为某种输入分配256字节的缓存，于是他们就提交多于256字节的内容，目的是覆盖旁边的“返回地址”。那么，当前代码运行完毕之后，程序的控制权就交给了他们指定的内存地址。这个地处通常是缓存的首地址，缓存中是入侵者事前编好的机器码。于是，入侵者的程序就运行在你的计算机上了。
如果使用更抽象的高级语言，上面的事情是不可能发生的。伹是，在C语言中，一旦接受用户输入的时候你没有检奔输入长度，就创造出了一个安全漏洞。利用这种漏洞的攻击行为就被称为“缓冲区溢出攻击”。在这种攻击中，还有其他方法可以控制计算机，但是覆盖返回地址是最经典的一种。
有意思的是，劫持飞机与“缓冲区溢出攻击”有类似之处。在一般飞机上，乘客区与驾驶舱是相通的，就好像C语言中数据区与代码区是相邻的一样。劫机者一且进入驾驶舱，实际上就相当于把自己从数据提升为代码。”
安全带还是手铐？
  语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。Java语言是前一个阵营的代表，perl语言则是后一个阵营的代表。（美国国防部很看中Java也就不足为奇了。）
  自由语言派的信徒嘲笑另一方是“B&D”（奴役和戒律，Bondage and Discipline）语言，很无礼地暗示用那些语言编程的人是下等人。我不知道对方如何反击这些喜欢Perl的自由派，也许他们不喜欢给别人起绰号，因此我就无从知道。
  由于防止程序员做蠢事有好几种方法，所以上面的争论逐渐分化成几个较小的议题。目前最活跃的议题之一就是静态类型语言与动态类型语言之争。在静态类型语言中，写代码时必须知道每个变量的类型。而在动态类型语言中，随便什么时候，你都可以把变量设为任意类型的值。
  静态类型语言的拥护者认为这样可以防止bug，并且帮助编译器生成更快的代码（这两点理由都成立）。动态类型语言的拥护者认为静态类型对程序构成了限制（这点理由也成立）。我本人更喜欢动态类型，痛恨那些限制我的自由的语言。但是，确实有一些很聪明的人看来喜欢用静态类型语言。所以，这个问题依然值得讨论，并没有固定答案。
面向对象编程
  眼下另一个争论的热点则是面向对象编程。它是一种不同的组织程序的方法。假定你要写一个程序，计算二维图形的面积。首先，你必须知道到底是圆形还是正方形。一种解决方法是用一整块的代码判断遇到的是什么图形，然后再用相应的公式计算面积。面向对象编程不是这样，它的方法是写出两个类，一个是圆形类，另一个是正方形类，然后每个类里面用一小块代码（叫做方法）计算该类图形的面积。求面积的时候，你就问要用哪一个类，然后再使用相应的方法得出最后答案。
  这两种不同的计算方法可能听上去很相似，事实上，运行代码后，实际计算面积的运算过程也很相似。（这不奇怪，因为你本来就在解决同一个问题。）但是，代码的形式却是大相径庭。在面向对象编程的方式中，计算圆面积和正方形面积的代码可能分散在不同的文件中。与圆形有关的代码都放在一个文件中，与正方形有关的代码则放在另一个文件中。