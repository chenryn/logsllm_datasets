166
② 作为常量的T和作为类的T，除了刚好具有相同的名字以外没有特别的关系。作为值的T是类SYMBOL的一个直接
① 基于原型的语言是另一种面向对象的语言类型。在这些语言里，JavaScript可能是最流行的例子，它的对象通过克
早期的Lisp对象系统以类似的方式工作，提供了一个特殊函数SEND，用于向特定对象发送消
类通过层次结构组织在一起，形成了所有对象的分类系统。一个类可以定义成另一个类的子
Common Lisp和今天的多数面向对象语言一样都是基于类的，所有对象都是某个特定类的实
面向对象的基本思想在于一种组织程序的强大方式：定义数据类型并将操作关联在那些数据
隆一个原型对象来创建。该克隆可以随后被修改并用作其他对象的原型。
(send object 'foo)
实例，并且只是间接地成为作为类的T的一个实例。
广义函数和类
第16章 
重新审视面向对象：广义函数
www.TopSage.com
---
## Page 184
在广义函数draw中，你可以定义一个方法来特化shape参数，使其用于circle类的实例对象；而
类，它们属于广义函数，其负责在一个特定调用中检测哪个或哪些方法将被运行。
广义函数的实际实现是由方法（method）提供的。每一个方法提供了广义函数用于特定参数类的
本身并不能做任何事。如果你只是定义广义函数，那么无论用什么参数来调用它，它都将会报错。
你可能定义广义函数draw的方式，它将用来在屏幕上绘制不同的形状：
16.2
里，我将向你展示如何定义你自己的类。
到类的情况下谈论广义函数，但目前我将把注意力集中在如何定义和使用广义函数上。在下一章
新的可能性，包括许多在消息传递对象系统中基本无法实现的特性。
类型而将方法和函数统一在一起。广义函数不但解决了上面描述的问题，它还为对象系统开放了
最终，工作在Lisp对象系统上的人们通过创建一种新的称为广义函数（generic function）的函数
而不是 
果一个人想要使用MAPCAR在一个列表的所有元素上调用方法，他不得不写成
而不是
广义函数是Common Lisp对象系统的核心，也是本章其余部分的主题。虽然我不可能在不提
① 这里和其他地方一样，对象意味着任何Lisp数据一
方法通过特化那些由广义函数所定义的必要参数，来表达它们可以处理的参数类型。例如,
广义函数定义了抽象操作，指定了其名字和一个参数列表，但不提供实现。例如，下面就是
(mapcar #'foo objects)
广义函数的广义性至少在理论上体现在，它可以接受任何对象作为参数。“不过，广义函数
(mapcar #:(lambda (object) (send object 'foo)) objects)
更重要的是，由于方法不是函数，它们无法作为参数传递给像MAPCAR这样的高阶函数。如
(defmethod draw ((shape triangle))
(defmethod draw ((shape circle))
我将在下一节里讨论DEFGENERIC的语法，目前只需注意该定义并不含有任何实际代码。
(defgeneric draw (shape)
(foo object)
据类型。Common Lisp中的所有数据都是对象，并且任何对象都是某个类的实例。
··.）
(  n    a m )
广义函数和方法
www.TopSage.com
16.2
广义函数和方法
167
---
## Page 185
类层次关系如下所示：
假设你已有一个bank-account类和它的两个子类checking-account以及savings-account。
跟踪以及事务集成这样的问题。
言特性而不是学习如何实际编写银行软件。例如，这些代码甚至并不打算处理像多种货币、审查
16.3
和DEFMETHOD的一些基础。
计模式。我将很快讨论到这些主题。但首先你需要了解两个用来定义广义函数的宏DEFGENERIC
来控制方法如何组合成有效方法，从而在无须使用大量模板代码的情况下直接支持几种常用的设
多个参数上的方法，提供了一个使多继承更具有可管理性的框架，并且允许你使用声明性的构造
类的组合决定了哪个方法被运行。
参数的结果跟在一个消息传递系统下调用方法的结果非常相似——操作的名字与调用时对象的
一个银行应用，或者说，一个相当幼稚的银行应用的一部分来编写的代码。重点在于观察一些语
是所谓的EQL特化符，其指定了方法所应用的特定对象。
应用在对应参数无论是该特定类的直接实例或是该类的任何子类的实例上。另一种类型的特化符
类的实例也被视为该类的所有基类的实例，因此一个带有特化了某个特定类的参数的方法可以被
随后将被组合起来—我将在16.5节里进行讨论，成为一个有效的（effective）方法来处理该调用。
一个方法是可应用的，并且它将处理该调用。在复杂的情况下，可能有多个方法均可应用，它们
一个triangle实例，那么在triangle上特化了shape的方法将被应用。在简单的情况下，只有
递一个circle的实例，那么在circle类上特化了shape的方法将是可应用的；而如果你传递了
找出可应用（applicable）的方法，即那些特化符与实际参数相兼容的方法。如果你调用draw并传
由于我不准备在下一章之前讨论如何定义新的类，因此目前你可以假设特定的类已经存在了。
尽管如此，相反的方法查找顺序带来了消息传递系统所没有的可能性。广义函数支持特化在
当一个广义函数只具有特化在单一参数上的方法并且所有特化符都是类特化符时，调用广义
你可以用两种方式来特化参数。通常你将指定一个类，其参数必须是该类的实例。由于一个
168
当一个广义函数被调用时，它将那些被传递的实际参数与它的每个方法的特化符进行比较，
为了给你一个关于这些宏和它们所支持的不同功能的大致印象，我将向你展示一些可能作为
DEFGENERIC
第16章重新审视面向对象：广义函数
checking-account
www.TopSage.com
bank-account
savings-account
大家
---
## Page 186
第二个元素是特化符，其要么是类的名字要么是EQL特化符，其形式我将很快讨论到。形参名可
别在于必要形参可以通过将形参名替换成两元素列表来进行特化。其中第一个元素是形参名，而
withdraw方法：
我将在第19章里讨论其进一步的细节。使用这两个函数，你可以像下面这样定义出一个基本的
被用于同SETF（因此也包括DECF）一起来设置余额。函数ERROR是一个用于报错的标准函数，
bank-account类上特化了account参数。你可以假设函数balance返回当前账户的余额并且可
数量的必要和可选参数，并且必须可以接受对应于任何&réat或&key形参的参数。
上的方法都必须刚好有两个必要参数。在更一般的情况下，方法必须带有由广义函数指定的相同
16.4
因此，你可以像下面这样定义withdraw：
该广义函数用途的字符串。由于广义函数是纯抽象的,让用户和实现者了解它的用途将是重要的。
可能含有不同的选项。一个你应当总是带有的选项是:documentation，它提供了一个用来描述
定了那些定义在该广义函数上的所有方法都必须接受的参数。在函数体的位置上，DEFGENERIC
报错并保持余额不变。你可以从通过DEFGENERIC定义该广义函数开始。
除了缺少函数体之外，DEFGENERIC的基本形式与DEFUN相似。DEFGENERIC的形参列表指
① 从技术上来讲，你可以完全跳过DEFGENERIC。如果你用DEFMETHOD定义了一个方法而没有定义相关的广义函
如同这段代码显示的，DEFMETHOD的形式比DEFGENERIC更像是一个DEFUN形式。唯一的区
由于提款的基本操作对于所有账户都是相同的，因此你可以定义一个方法，其在
方法的形参列表必须与它的广义函数保持一致。在本例中，这意味着所有定义在withdraw
现在你开始使用DEFMETHOD来定义实现了withdraw的方法。
Signal an error if the current balance is less than amount."))
(defgeneric withdraw (account amount)
(defmethod withdraw ((account bank-account) amount)
第一个广义函数将是withdraw，它将账户余额减少指定数量。如果余额小于提款量，它将
于带有不同形参列表的方法。
支持诸如C++和Java那样的某些静态类型语言里支持的方法重载（method overloading），在那里相同的名字可被用
这种一-致性规则带来的一个后果是，同一个广义函数上的所有方法将同样带有"致的形参列表。CommonLisp不
广义函数被调用时，任何由广义函数指定的&key参数或任何可应用的方法将被接受。
要的行为。
数，那么广义函数将被自动创建。但是显式地定义广义函数是好的形式，因为它给你一个好的位置来文档化你想
(decf (balance account) amount))
(:documentation "Withdraw the specified amount from the account.
COHLENAEG
(error
"Account 
overdrawn."))
amount)
www.TopSage.com
16.4DEFMETHOD
?
?
169
---
## Page 187
withdraw来特别处理他的账户。
一个特定银行账户的引用，如同其名字显示的，该账户属于该银行的总裁。进一步假设变量
假设该银行应用被部署在某个腐败银行上。假设变量*account-of-bank-president*保存了
设有一个函数proxied-account的方法可以返回代理的账户)：
它并不实际跟踪自己的余额而是将提款请求代理到其他账户，那么你可以写一个如下的方法（假
将负责完全实现你想要的广义函数行为。假如你有一个bank-account的子类proxy-account，
递给下一个方法。
下一个方法将以最初传递给广义函数的参数被调用。它也可以带参数被调用，这些参数随后被传
当从该方法传递到特定于bank-account的方法上。
递过程，然后再让特化在bank-account上的方法接手。这样一个方法如下所示：
透支账户。然后你可以像处理标准的bank-account对象那样进行处理。
些额外的步骤。你必须首先检查提款金额是否大于该账户的当前余额，如果大于，就将差额转给
象
overdraft-account接受checking-account对象并返回代表了关联账户的bank-account对
联，该账户将在现金账户的余额本身无法满足提款需求时被提款。你可以假设函数
amount被隐式特化到T上，而由于所有对象都是T的实例，它不会影响该方法的可应用性。
以是任何东西——它不需要匹配广义函数中使用的名字，尽管经常是使用相同的名字。
因此，你要做的是在withdraw上定义一个特化在checking-account上的方法来处理该传
该方法在每当withdraw的第一个参数是bank-account的实例时被应用。第二个形参
① CALL-NEXT-METHOD大致相当于Java中在super上调用一个方法，或是在Python或C++中使用一个显式的类限定
你不必在每一个方法中调用CALL-NEXT-METHOD。尽管如此，如果你不这样做的话，新的方法
现在假设所有现金账户都带有透支保护。这就是说，每个现金账户都与另一个银行账户相关
170
最后，DEFMETHOD还允许你通过使用EQL特化符来创建特化在一个特定对象上的方法。例如，
这样，相比从标准的bank-account对象中提款，从checking-account对象中提款需要一
(defmethod withdraw ((account (eql *account-of-bank-president*)) amount)
(defmethod withdraw ((proxy proxy-account) amount)
函数CALL-NEXT-METHOD是广义函数机制的一部分，用于组合可应用的方法。它指示控制应
(defmethod withdraw ((account checking-account) amount)
方法或函数名。
(let ((overdraft (- amount (balance account))))
(call-next-method))
(let((overdraft
(when
(withdraw (overdraft-account account) overdraft)
第 16章 
(incf (balance account) overdraft)))
(plusp
重新审视面向对象：广义函数
overdraft)
www.TopSage.com
，“当它不带参数被调用时，就像这里的这样，
---
## Page 188
化了account的方法被认为比在bank-account上特化它的方法是更加相关的。
情况下，命名了子类的特化符将被认为是更加相关的。这就是为什么在checking-account上特
它们的实例。在典型情况下，如果两个类特化符不同，那么其中一个将是另一个的子类。在那种
个方法中第一个不同的特化符将决定它们的顺序，其中带有更加特定的特化符的方法排在前面。
地特化了超过一个形参的方法被称为多重方法（multimethod)。我将在16.8节中讨论它们。
兼容。）一个EQL特化符当且仅当参数和特化符中所指定的对象是同一个时才是兼容的。
该特化符将是兼容的。（再次强调，不带有显式特化符的形参将隐式特化到类T上从而与任何参数
较
产生有效方法。
(specificity）排序。最后，根据排序后列表中的顺序来取出这些方法并将它们的代码组合起来以
可应用的方法列表。其次，这个可应用方法的列表按照它们的参数特化符中的特化程度
息传递完全颠覆了方法的调度过程，使得广义函数而不是类成为了主要推动者。
他们的意识中带有根深蒂固的消息传递模型思想的人们应当尤其注意这点，因为广义函数相比消
支持消息传递系统里所没有的机制的关键。因此，值得更进一步地观察究竟发生了什么。那些在
种通过组合可应用的方法来构造有效方法的概念是广义函数概念的核心，并且是让广义函数可以
制定义，用来在每次广义函数使用的所有应用于特定调用的方法被调用时构造一个有效方法。这
16.5
*account-of-bank-president*的值。随后，改变该变量将不会改变该方法。
bank-president*，其只在DEFMETHOD被求值时求值一次。在定义方法时该方法将特化
②
① 尽管构造有效方法的过程听起来很费时，但在开发快速的Common Lisp实现过程中有相当多的努力被用于使上述
由于只有可应用的方法在排序，你可以看出所有由类特化符命名的类对应的参数实际上都是
在可应用的方法被找到以后，广义函数机制需要在将它们组合成一个有效方法之前对它们进
由于所有参数都将在对应的特化符中被检查，它们都会影响一个方法是否是可应用的。显式
从概念上讲，有效方法由三步构造而成：首先，广义函数基于被传递的实际参数构造一个
在一个方法体之外，CALL-NEXT-METHOD没有任何意义。在一个方法之内，它被广义函数机
当特化符是一个类的名字时，如果该名字是参数的实际类名或是它的一个基类的名字，那么
当且仅当所有特化符均和对应的参数兼容，一个方法便是可应用的。
为了找出可应用的方法，广义函数将实际参数与它的每一个方法中的对应参数特化符进行比
不过需要注意到，EQL特化符中提供了特化对象的形式，在本例中是变量*account-of-
项很少被用到。
事实上，比较特化符的顺序可以通过DEFGENERIC的选项:argument-precedence-order来定制，尽管该选
过程更有效率，一种策略是缓存有效方法以便未来在相同参数类型上的调用可以被直接处理。
方法组合
(call-next-method))
(when (plusp overdraft)
(incf (balance account) (embezzle *bank* overdraft))))