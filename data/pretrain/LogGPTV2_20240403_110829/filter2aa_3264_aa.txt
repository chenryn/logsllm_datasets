Beyond Root
Custom Firmware For Embedded Mobile 
Chipsets
Biography
Christopher Wade
Security Consultant at Pen Test Partners
@Iskuri1
https://github.com/Iskuri
https://www.pentestpartners.com
Project Origin
Smartphones contain a huge amount of closed firmware
This limits the capabilities of even rooted devices
By breaking firmware protections and reverse engineering embedded chipsets, 
smartphones can be used as attack tools
Wi-Fi Monitor Mode
Many smartphones support Wi-Fi Monitor Mode
Activated in Snapdragon chipsets via: 
echo 4 > /sys/module/wlan/parameters/con_mode
Broadcom chipsets can utilise custom firmware
Well known, implemented in modern mobile testing tools
USB Device Emulation
Linux Kernel supports emulating USB devices via 
GadgetFS
This can be used to emulate any standard USB device
Rarely used, but very effective
Debian Chroot
A full Debian Root Filesystem can be generated with qemu-debootstrap
A simple script can provide hardware access and direct SSH connectivity:
mount -o remount,rw /data
mount --bind /proc /data/debian_arm64/proc
mount --bind /sys /data/debian_arm64/sys
mount --bind /dev /data/debian_arm64/dev
mount devpts /data/debian_arm64/dev/pts -t devpts
chroot /data/debian_arm64/ /bin/bash --login -c /usr/sbin/sshd &
NFC On Android – Standard Functionality
NFC on Android is restricted to very specific features:
Generic Reader Modes
Mobile Payments
NDEF Communication
Host-Card Emulation
NFC On Android – Unsupported Functionality
Desired features for an NFC attack tool:
Reader Based Attacks
Raw Tag Emulation
Passive Sniffing
Target Device
Samsung S6 - SM-G920F
Older smartphone – readily available
Allows for OEM unlocking and deployment of Custom ROMs
Found to use a proprietary Samsung Semiconductor NFC 
Controller in non-US versions
NFC Controller – S3FWRN5
Custom chip developed by Samsung Semiconductor
Utilised in non-US Samsung S6, and Note 4 devices
Boasts the ability to securely update firmware
Utilises ARM SC000 SecurCore architecture
Communicated with via I2C and GPIO on phone
Basic Communication – Hardware On Android
Smartphones are essentially embedded Linux devices
GPIO and I2C communication can be performed via files in “/dev/i2c-*” and “/dev/gpio*” 
Samsung’s Kernel abstracts these to custom driver, accessed using device file “/dev/sec-nfc”
File reads, writes and IOCTLs control the chip
NCI Communication
NFC chips communicate via a standard protocol
This abstracts and restricts NFC functionality, to simplify the process
Send and receive packets consist of the following:
GID – Byte containing identifier of functionality group (Core, RF, Vendor Specific)
OID – Byte containing identifier of specific operation
Length – Byte containing the length of parameters
Payload – Data related to the operation
NCI – Non Standard Functionality
Vendor GID (0xf) allows for any non-standard functionality to be implemented
Vendor operations from 0x00-0xff can be enumerated by checking error responses
Vendor defined operations are most likely to contain actionable weaknesses
In addition, configuration and mode operations allow for non-standard functionality
S3FWRN5 – Firmware Updates
S3FWRN5 chip supports firmware updates via I2C
Firmware updates are never implemented via NCI, a custom bootloader is used
Loaded from firmware files are found in vendor partition
Enabling Debug Mode
*.rc configs can be modified in /system/
Debug and forced firmware updates can be enabled
Traces can be pulled from Logcat
Analysis Of Firmware Update Protocol
Update traces can be pulled from Logcat
Utilises four byte header followed by payload:
0x00: Command type
0x01: Command
0x02-0x03: Payload size
0x04-0x100: Payload data
0x80 is added to first byte on alternating sends
Firmware Update Files
Firmware and configs can be found in Android Filesystem
Depending on device version, can be in main system image or hidden Vendor partition
Usually available from publicly available Android images
S3FWRN5 Firmware File Analysis
Basic format: metadata, signature, and full firmware
Payload provides size information about internal memory of device
Firmware Update Files – Identifying Architecture
Simple mnemonics can be used to identify chip 
architectures
Thumb’s “BX LR” operation translates in hex to 
“0x70 0x47”, and in ASCII to “pG”
A high number of instances of this imply Thumb 
code in use
This was identified in the firmware
Implementing Firmware Updates
Dump the Firmware Update protocol command 
sequence
Send dumped IOCTL and commands in 
sequence
Compare received values for each command
Header files from Open Source Kernel drivers 
can aid this: “sec_nfc.h”
Firmware Update Protocol and Sequence
Utilises numbered commands for firmware updates:
0: Reset
1: Boot Info
2: Begin Update
4: Update Sector
5: Complete Update
A numbered command is missing from the sequence
This heavily implied additional hidden commands
Identifying Hidden Bootloader Commands
Commands only work at certain stages of update process
Chip returns error 2 if command is not valid at that stage
Chip returns error 9 if the payload is too small
This can be brute forced through the firmware update protocol
Hidden Bootloader Command 3
Same functionality as command 4
Writes 512-byte blocks instead of 4096
No actionable weaknesses
Hidden Bootloader Command 6
Takes eight bytes of parameters, two 32-bit values
Individual bits were set in parameters and responses 
were checked
Testing showed this allowed for reading of arbitrary 
memory – address and size
This allows for dumping of RAM, the firmware and the 
secure bootloader
Dumping The Bootloader
Memory can be stitched from hidden 
command 6
This showed a standard Cortex-M firmware 
format starting at address 0x00000000 (vector 
table followed by code), with a size of 8KB
This allowed for static analysis and emulation
The firmware contained no strings, drastically 
increasing time to analyse
Analysing Bootloader Binary
Loaded into IDA as ARM Little-endian
Memory Layout:
0x00000000 – Flash Memory
0x20000000 – RAM 
0x40000000/0x50000000 – Hardware Peripherals
0xE0000000 – System
Analysing Bootloader Binary
Bootloader Artefacts
On start-up, the bootloader checks for a magic 
number at address 0x3000: 
0x5AF00FA5
This magic number is only written if the 
signature is valid during upgrade
Attempts to manually write the value were 
unsuccessful – first block must start with 
0xFFFFFFFF
Bootloader Artefacts
Bootloader commands can be swiftly identified for analysis
Bootloader Artefacts
RSA Public Key can be found in memory
0x80 high entropy bytes followed by “00 01 00 01” – 65537 as exponent
Identifying Memory Corruption
Fuzzing any embedded firmware could irreparably damage the chip
Only one phone was available for testing
Debugging and analysis via I2C would be difficult
Emulation of the bootloader was attempted
Emulating Embedded Firmware With Unicorn Engine
Library for emulating architectures and hooking all functionality
Can define architecture, memory mapping, and hardware integration
Emulating Embedded Firmware With Unicorn Engine
Bootloader was loaded at address 0x00000000
Program Counter was set to value in reset vector (0x000002BD)
Memory was mapped for flash, RAM and hardware registers
Emulating Embedded Firmware With Unicorn Engine
Commands are received in infinite loop in main thread, with no interrupts
This meant that emulation would be a simpler task
Emulating Embedded Firmware With Unicorn Engine
Execution was found to cause device resets when 
accessing hardware registers during configuration
The bootloader image was patched to bypass hardware 
initialisation
Static hardware register values were dumped from the 
chip and loaded into Unicorn
Emulating Embedded Firmware With Unicorn Engine
The firmware was allowed to run, until it hit a hardware 
register
This was a read at address 0x40022030
The disassembly showed specific bits were checked
This implied it was a status register for I2C
The read was overridden to return random data
Emulating Embedded Firmware With Unicorn Engine
Next, the firmware continually read bytes from a 
single address - 0x40022038
This implied it was the I2C FIFO buffer
Firmware update commands were sent via this 
register
Responses to commands were sent to address 
0x40022034
This constituted full emulation of the I2C 
communication
Memory Corruption Opportunities
Randomised fuzzing would now be viable
Commands have 16-bit sizes – larger than entire contents of RAM
Some commands send additional data in chunks
Size of hash and signature are defined in initialisation command
Bypassing Signature Checks
Manipulation of the hash and signature sizes allowed for more data to be sent in chunks
Analysis in Unicorn showed that this caused out of bounds memory access
Further analysis showed that this overwrote the stack
Bypassing Signature Checks
Overwriting the stack allowed for 
manipulation of Program Counter
SC000 chipsets cannot execute from RAM
Stack was too small for complex ROP exploits
Program Counter was set to just after 
signature check: 
0x016d  (PC + 1 for Thumb code)
Bypassing Signature Checks
The exploit was performed on the physical 
chip
This booted the main firmware without 
power cycling
The firmware was started and could be 
run, bypassing signature checking
This would allow for custom firmware to be 
developed