16
268
6
83
21
23
40
157
28
-
Unique Crashes
GREYONE-CE
21(-25%)
4(-75%)
127(-52.6%)
0(-100%)
28(-66.3%)
0(-100%)
7(-69.6%)
24(-40%)
28(-82.2%)
22(-21.4%)
-63.2%
GREYONE-BP
25(-10.7%)
7(-56.3%)
225(-16%)
0(-100%)
49(-41%)
7(-66%)
9(-60.9%)
33(-17.5%)
79(-49.7%)
25(-10.7%)
-42.9%
on local program behaviors and are limited to information
ﬂow detection. In fuzzing applications, REDQUEEN [4] uses
random mutation to colorize inputs, to infer taint related to di-
rect copy of inputs. Fairfuzz [24] and ProFuzzer [42] monitor
the pattern of control ﬂow changes among multiple runs, to in-
fer partial type of mutated bytes. None of these solutions have
ever considered the variables’ value changes after mutation,
Thus, they all fail to provide accurate taint information.
In this paper, we propose a fuzzing-driven taint inference
solution FTI. We perform a systematic byte-level mutation
to perform a pilot fuzzing. During fuzzing, we monitor vari-
ables’ value changes and infer taint attributes accordingly.
This solution is automated, lightweight and more accurate.
6.2 Seed Mutation
Many studies [10, 13, 30, 44] have shown that, seed muta-
tion is one of the most hot and hard direction to increase
the efﬁciency and accuracy of fuzzing. Many approaches are
proposed to try to solve how and where to mutate.
a) Static-analysis-based optimization. Steelix [25] and
Laf-intel-pass [1] statically decompose those long constant
comparisons into multiple shorter comparisons. So that the
dumb random fuzzer could satisfy the path constraints with
a much higher probability. However, it brings too many
semantic-equivalent paths to explore, and cannot handle non-
constant comparisons. SYMFUZZ [8] leverages static sym-
bolic analysis to detect dependencies among input bits, and
uses it to compute an optimal mutation ratio. However, this
process is slow, and the calculated dependency between bits
do not show many improvements for mutation.
b) Learning-based model. Rajpal et.al. [29] presents a
RNN-based model to predict best locations to mutate in seeds,
based on the history mutations and their corresponding code
coverage feedback. Konstantin et.al. [7] uses deep reinforce-
ment learning to model the fuzzing loop and choose the best
mutation actions in the following fuzzing iteration. These
solutions are in early stage and have not shown signiﬁcant
improvements yet. NEUZZ [35] identiﬁes the signiﬁcance of
program smoothing and uses an incremental learning tech-
nique to guide mutation.
c) Symbolic-based solution. This type of solutions essen-
tially utilize symbolic execution to solve the complicated path
constraints that are hard to be satisﬁed by mutation-based
fuzzing. Driller [37] periodically picks paths that are stuck in
mutation-based fuzzing, and uses symbolic execution to solve
the constraints of those paths. QSYM [43] ports symbolic
execution to native X86 instructions and relaxes the path con-
straints to solve, providing a better analysis performance and
reducing the speed of constraint solving. DigFuzz [45] de-
signs a probabilistic path prioritization model to quantify each
path’s difﬁculty and prioritize them for concolic execution.
All of these symbolic-based solution cannot scale to large
applications due to the open challenge of constraint solving.
d) Taint-based mutation. Several fuzzers utilize taint to
guide mutations. Dowser [17] and BORG [27] use taint to
locate buffer boundary violations and buffer over-read vul-
nerabilities respectively. BuzzFuzz [15] uses DTA to track
the regions of external seed inputs that affect sensitive library
or system calls. TaintScope [40] leverages ﬁne-grained DTA
to identify checksum branch. VUzzer [30] is able to track
branches that compare variables against constants, e.g., magic
numbers, and guides the mutation accordingly. Angora [10]
performs shape inference and gradient descent computation
based on DTA. These solutions suffer from inaccurate taint,
limiting the efﬁciency in complicated programs.
In addition, the high overhead of DTA greatly limits the
application of DTA in large applications. Among the light-
weight taint-guide mutation solutions, Fairfuzz [24] and Pro-
fuzzer [42] could not obtain accurate taint attributes of vari-
ables, inefﬁcient at exploring hard-to-reach branches. In addi-
tion, they would repeatedly mutate some input bytes, even if
the relevant branches have already been explored, since they
are insensitive to branch states. REDQUEEN [4] focuses on
identifying direct copy of inputs and branches that use them,
unable to handle the prevalent uses of indirect copy of inputs.
Our solution GREYONE utilizes the lightweight and sound
taint inference solution FTI to get more taint attributes (with-
USENIX Association
29th USENIX Security Symposium    2591
out over-taint) as well as the precise relationship between
input offsets and branches, to prioritize which branch to ex-
plore and which bytes to mutate, as well as determine how to
precisely mutate them.
6.3 Seed Updating and Selection
Seed updating and selection could adjust the evolution direc-
tion of fuzzing. A good solution would improve the efﬁciency
of fuzzers in ﬁnding more code and bugs [28] and in moving
towards potentially vulnerable target code [5, 9, 39].
Few works focus on seed updating, but many seed selection
solutions are proposed in the past years. These solutions in
general collect more and more auxiliary control ﬂow informa-
tion to guide the seed selection. At the beginning, AFL [44]
prioritizes those seeds with smaller size and shorter execution
time, to generate more test cases in a given time period. Then,
AFLFAST [6] points out the importance of seed selection,
and prioritizes seeds that are rarely picked to mutate and that
explore cold paths. From then on, kinds of control ﬂow charac-
teristics are used to guide seed selection, e.g., by prioritizing
deeper path [30] or untouched neighbour branches [14].
However, these solutions did not consider any data ﬂow
features, and thus are inefﬁcient at exploring paths with com-
plicated constraints. Honggfuzz [38] and LibFuzzer [32] took
a weak data ﬂow feature to guide seed selection. More specif-
ically, they evaluate the distance between operands of all
branches, and use it to guide seed selection.
GREYONE improves this strategy by evaluating the con-
straint conformance on all tainted untouched branches only.
It also utilizes a novel two-dimension seed queue structure
to provide support for efﬁcient seed updating and selection.
It is able to avoid the local minimum problem faced by the
learning-based solution used in Angora [10]. Further, GREY-
ONE applies a novel on-the-ﬂy mutation rebase to further
accelerate the evolution of fuzzing.
6.4 Performance Optimization
Performance is an important factor of efﬁcient fuzzing. Sev-
eral solutions have been proposed to improve the fuzzing
performance, by boosting the parallel execution [41] or instru-
mentation [18, 36]. The recent work Untracer [36] removes
unnecessary instrumentation in basic blocks that have been
explored and reduces the overhead. GREYONE also optimizes
the instrumentation, to select more light-weight testing mode
on demand, and switch between different fuzzing mode, to
improve the speed of fuzzing.
7 Conclusion
In this paper, we propose a novel data ﬂow sensitive fuzzing
solution GREYONE. It infers taint during the fuzzing process
by monitoring variable value changes, and further guides seed
mutation with the inferred taint. It also applies a data ﬂow fea-
ture conformance to tune the evolution direction of fuzzing,
driving the fuzzer to quickly reach unexplored branches and
trigger potential vulnerabilities. It outperforms various state-
of-the-art fuzzers in terms of both code coverage and vulnera-
bility discovery, while its taint analysis is more lightweight
and accurate than others.
Acknowledgement
We would like to thank the anonymous reviewers for
their insightful and valuable comments. This research
was supported in part by National Nuclear High-Base
Project(2018ZX01028102), National Natural Science Foun-
dation of China under Grant 61772308, 61972224 and
U1736209, and BNRist Network and Software Security
Research Program under Grant BNR2019TD01004 and
BNR2019RC01009.
References
Fuzzing
Transfor-
mations.
https://lafintel.wordpress.com/2016/08/15/
circumventing-fuzzing-roadblocks-with-compiler-transformations/.
https://clang.llvm.org/docs/
Roadblocks
with
Compiler
[1] Circumventing
[2] Dataﬂowsanitizer.
DataFlowSanitizerDesign.html.
[3] Utilities for automated crash sample processing/analysis. https://github.
com/rc0r/afl-utils.
[4] ASCHERMANN, C., SCHUMILO, S., BLAZYTKO, T., GAWLIK, R., AND HOLZ,
T. Redqueen: Fuzzing with input-to-state correspondence. In NDSS (2019). To
appear.
[5] BOHME, M., PHAM, V.-T., NGUYEN, M.-D., AND ROYCHOUDHURY, A. Di-
rected greybox fuzzing. In CCS (2017).
[6] BÖHME, M., PHAM, V.-T., AND ROYCHOUDHURY, A. Coverage-based grey-
box fuzzing as markov chain. In Proceedings of the 2016 ACM SIGSAC Confer-
ence on Computer and Communications Security (2016), ACM, pp. 1032–1043.
[7] BÖTTINGER, K., GODEFROID, P., AND SINGH, R. Deep reinforcement fuzzing.
arXiv preprint arXiv:1801.04589 (2018).
[8] CHA, S. K., WOO, M., AND BRUMLEY, D. Program-adaptive mutational
fuzzing. In Security and Privacy (SP), 2015 IEEE Symposium on (2015), IEEE,
pp. 725–741.
[9] CHEN, H., XUE, Y., LI, Y., CHEN, B., XIE, X., WU, X., AND LIU, Y. Hawk-
eye: towards a desired directed grey-box fuzzer. In Proceedings of the 2018 ACM
SIGSAC Conference on Computer and Communications Security (2018), ACM,
pp. 2095–2108.
[10] CHEN, P., AND CHEN, H. Angora: Efﬁcient fuzzing by principled search. arXiv
preprint arXiv:1803.01307 (2018).
[11] CLAUSE, J., LI, W., AND ORSO, A. Dytan: a generic dynamic taint analysis
In Proceedings of the 2007 international symposium on Software
framework.
testing and analysis (2007), ACM, pp. 196–206.
[12] DOLAN-GAVITT, B., HULIN, P., KIRDA, E., LEEK, T., MAMBRETTI, A.,
ROBERTSON, W., ULRICH, F., AND WHELAN, R. Lava: Large-scale automated
vulnerability addition. In Security and Privacy (SP), 2016 IEEE Symposium on
(2016), IEEE, pp. 110–121.
[13] EDDINGTON, M. Peach fuzzing platform. Peach Fuzzer (2011), 34.
[14] GAN, S., ZHANG, C., QIN, X., TU, X., LI, K., PEI, Z., AND CHEN, Z. Collaﬂ:
Path sensitive fuzzing. In 2018 IEEE Symposium on Security and Privacy (SP)
(2018), IEEE, pp. 679–696.
[15] GANESH, V., LEEK, T., AND RINARD, M. Taint-based directed whitebox
fuzzing. In Proceedings of the 31st International Conference on Software En-
gineering (2009), IEEE Computer Society, pp. 474–484.
[16] GOGUEN, J. A., AND MESEGUER, J. Security policies and security models. In
1982 IEEE Symposium on Security and Privacy (1982), IEEE, pp. 11–11.
[17] HALLER, I., SLOWINSKA, A., NEUGSCHWANDTNER, M., AND BOS, H.
2592    29th USENIX Security Symposium
USENIX Association
Dowsing for overﬂows: a guided fuzzer to ﬁnd buffer boundary violations. In
USENIX Security Symposium (2013), pp. 49–64.
[18] HSU, C.-C., WU, C.-Y., HSIAO, H.-C., AND HUANG, S.-K.
Instrim:
Lightweight instrumentation for coverage-guided fuzzing. In Symposium on Net-
work and Distributed System Security (NDSS), Workshop on Binary Analysis
Research (2018).
[19] KANG, M. G., MCCAMANT, S., POOSANKAM, P., AND SONG, D. Dta++:
dynamic taint analysis with targeted control-ﬂow propagation. In NDSS (2011).
[20] KEMERLIS, V. P., PORTOKALIDIS, G., JEE, K., AND KEROMYTIS, A. D.
In Acm
libdft: Practical dynamic data ﬂow tracking for commodity systems.
Sigplan Notices (2012), vol. 47, ACM, pp. 121–132.
[21] KLEES, G., RUEF, A., COOPER, B., WEI, S., AND HICKS, M. Evaluating fuzz
testing. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security (2018), ACM, pp. 2123–2138.
[22] LATTNER, C. LLVM related publications. Ofﬁcial LLVM web site. Retrieved
on 2010-12-04. http://llvm.org.
[23] LEE, B., SONG, C., KIM, T., AND LEE, W. Type casting veriﬁcation: Stopping
an emerging attack vector. In USENIX Security Symposium (2015), pp. 81–96.
[24] LEMIEUX, C., AND SEN, K. Fairfuzz: A targeted mutation strategy for increas-
ing greybox fuzz testing coverage. In Proceedings of the 33rd ACM/IEEE Inter-
national Conference on Automated Software Engineering (2018), ACM, pp. 475–
485.
[25] LI, Y., CHEN, B., CHANDRAMOHAN, M., LIN, S.-W., LIU, Y., AND TIU, A.
In Proceedings of the 2017 11th
Steelix: program-state based binary fuzzing.
Joint Meeting on Foundations of Software Engineering (2017), ACM, pp. 627–
637.
[26] MATHIS, B., AVDIIENKO, V., SOREMEKUN, E. O., BÖHME, M., AND
In Proceed-
ZELLER, A. Detecting information ﬂow by mutating input data.
ings of the 32nd IEEE/ACM International Conference on Automated Software
Engineering (2017), IEEE Press, pp. 263–273.
[27] NEUGSCHWANDTNER, M., MILANI COMPARETTI, P., HALLER, I., AND BOS,
In Proceedings of
H. The borg: Nanoprobing binaries for buffer overreads.
the 5th ACM Conference on Data and Application Security and Privacy (2015),
ACM, pp. 87–97.
[28] PETSIOS, T., ZHAO, J., KEROMYTIS, A. D., AND JANA, S. Slowfuzz: Auto-
mated domain-independent detection of algorithmic complexity vulnerabilities.
In Conf. on Computer and Communication Security (2017).
[29] RAJPAL, M., BLUM, W., AND SINGH, R. Not all bytes are equal: Neural byte
sieve for fuzzing. CoRR abs/1711.04596 (2017).
[30] RAWAT, S., JAIN, V., KUMAR, A., AND BOS, H. VUzzer: Application-aware
Evolutionary Fuzzing. In Network and Distributed System Security Symposium
(2017).
[31] SEKAR, R. An efﬁcient black-box technique for defeating web application at-
tacks. In NDSS (2009).
[32] SEREBRYANY, K. Continuous fuzzing with libfuzzer and addresssanitizer. In
Cybersecurity Development (SecDev), IEEE (2016), IEEE, pp. 157–157.
[33] SEREBRYANY, K. Oss-fuzz - google’s continuous fuzzing service for open
source software.
[34] SEREBRYANY, K., BRUENING, D., POTAPENKO, A., AND VYUKOV, D. Ad-
dresssanitizer: A fast address sanity checker. In the 2012 USENIX Annual Tech-
nical Conference (2012), pp. 309–318.
[35] SHE, D., PEI, K., EPSTEIN, D., YANG, J., RAY, B., AND JANA, S. Neuzz:
Efﬁcient fuzzing with neural program smoothing. In IEEESP (2019). To appear.
[36] STEFAN NAGY, M. H. Full-speed fuzzing: Reducing fuzzing overhead through
coverage-guided tracing. In IEEESP (2019). To appear.
[37] STEPHENS, N., GROSEN, J., SALLS, C., DUTCHER, A., WANG, R., COR-
BETTA, J., SHOSHITAISHVILI, Y., KRUEGEL, C., AND VIGNA, G. Driller: Aug-
menting fuzzing through selective symbolic execution. In NDSS (2016), vol. 16,
pp. 1–16.
[38] SWIECKI, R. Honggfuzz. Available online a t: http://code. google. com/p/hong-
gfuzz (2016).
[39] WANG, S., CHANG NAM, J., AND TAN, L. Qtep: Qulity-aware test case pri-
oritization. In ESEC/FSE 2017 Proceedings of the 2017 11th Joint Meeting on
Foundations of Software Engineering (2017).
[40] WANG, T., WEI, T., GU, G., AND ZOU, W. Taintscope: A checksum-aware
In IEEE
directed fuzzing tool for automatic software vulnerability detection.
Symposium on Security and Privacy (2010).
[41] XU, W., KASHYAP, S., MIN, C., AND KIM, T. Designing new operating primi-
tives to improve fuzzing performance. In Proceedings of the 2017 ACM SIGSAC
Conference on Computer and Communications Security (New York, NY, USA,
2017), CCS ’17, ACM, pp. 2313–2328.
[42] YOU, W., WANG, X., MA, S., HUANG, J., ZHANG, X., WANG, X., AND
LIANG, B. Profuzzer: On-the-ﬂy input type probing for better zero-day vul-
nerability discovery. In IEEE Security and Privacy (2019), IEEE.
Figure 13: The growth trend of number of unique paths (av-
erage in 5 runs) detected by AFL, CollAFL-br, Angora and
GREYONE.
[43] YUN, I., LEE, S., XU, M., JANG, Y., AND KIM, T. {QSYM}: A practical con-
colic execution engine tailored for hybrid fuzzing. In 27th {USENIX} Security
Symposium ({USENIX} Security 18) (2018), pp. 745–761.
[44] ZALEWSKI, M. American fuzzy lop. http://lcamtuf.coredump.cx/afl/.
[45] ZHAO, L., DUAN, Y., YIN, H., AND XUAN, J. Send hardest problems my way:
Probabilistic path prioritization for hybrid fuzzing. In NDSS (2019). To appear.
[46] ZHENG LEONG CHUA, Y. W. Inferring taint rules without architectural seman-
tics. In NDSS (2019). To appear.
A APPENDIX
Due to the space limit, we present some of the evaluation
results here.
A.1 Growth Trend of Code Coverage
In this section, we present the evaluation result of the code
coverage growth trend and the effects of randomness.
Code Coverage. Figure 13 and Fig. 16 show the average
growth trend of paths and edges detected by each fuzzer in
ﬁve runs. It shows that GREYONE has a stronger growth trend
than other fuzzers in all applications. Unlike other fuzzers,
GREYONE keeps a steady growth trend for a long time.
USENIX Association
29th USENIX Security Symposium    2593
Figure 14: The growth trend of number of unique crashes (5 runs) detected by AFL, CollAFL-br, Angora and GREYONE.
far surpassing Angora ﬁnally.
Among other fuzzer tools, Angora could achieve high code
coverage in a very short time in some applications, e.g.,
readelf and nm It proves that its gradient descent based mu-
tation is effective. However, it may fall into local minimum
soon, leading to very poor code coverage on most applications,
e.g., libwpd, fig2dev, libncurses, abd c++filt.
Randomness. As shown in Fig 15, the randomness in
fuzzing does not affect the conclusion, the worst run of GREY-
ONE still shows better code coverage than the best run of
other fuzzers.
Figure 15: Path randomness.
A.2 Growth Trend of Unique Crashes
In this section, we present the growth trend of unique crashes
and the effects of randomness.
Unique Crashes. As shown in Fig 14, GREYONE has a
strong growth trend on each application. Comparing to other
fuzzers, GREYONE could ﬁnd more unique crashes in almost
all applications. It also ﬁnds crashes faster than other fuzzers
in all applications except readelf. Similar to growth trend
of paths, Angora could ﬁnd more crashes than GREYONE
in earlier stage on the subject readelf, but is surpassed by
GREYONE after 50 hours.
Randomness. The number of unique crashes is more sen-
sitive to randomness than code coverage, because crashes are
rare comparing to program path. However, we can see that
worst run of GREYONE in general still shows better code
coverage than the best run of other fuzzers.
Figure 16: Edge coverage.
For example, in the application readelf, GREYONE fell
behind Angora at the beginning. But it caught up with Angora
at 40 hours, and maintained a strong and steady growth trend,
2594    29th USENIX Security Symposium
USENIX Association