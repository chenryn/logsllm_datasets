    curl_setopt($ch, CURLOPT_TIMEOUT, 120);
    $result = curl_exec($ch);
    global $header;
    if ($result) {
        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
        $header = explode("\r\n", substr($result, 0, $headerSize));
        $body = substr($result, $headerSize);
    }
    if (curl_getinfo($ch, CURLINFO_HTTP_CODE) == '200') {
        return $body;
File_get_contents
vps
    }
    if (curl_getinfo($ch, CURLINFO_HTTP_CODE) == '302') {
        $location = getHeader("Location");
        if (strpos(getHeader("Location"), 'http://') == false) {
            $location = getHost($url) . $location;
        }
        return getHtmlContext($location);
    }
    return NULL;
}
function getHost($url)
{
    preg_match("/^(http:\/\/)?([^\/]+)/i", $url, $matches);
    return $matches[0];
}
function getCss($host, $html)
{
    preg_match_all("//i", 
$html, $matches);
    print_r($matches);
    foreach ($matches[1] as $v) {
        $cssurl = $v;
        if (strpos($v, 'http://') == false) {
            $cssurl = $host . "/" . $v;
        }
        $csshtml = "";
        $html .= $csshtml;
    }
    return $html;
}
if ($url != null) {
    $host = getHost($url);
    echo $host."";
    echo getCss($host, getHtmlContext($url));
}
Crypto
RRSSAA
from Crypto.Util.number import isPrime
from Crypto.Util.number import *
from gmpy2 import next_prime, invert, gcd, jacobi, powmod, iroot
import math
n1 = 
7296833146437859657873621309783663953888975990236533231501856312811032923469834
0288949958887638828272808811489147149910844881732898599415772529999325992095319
1285447232621193626481596558259180977031977971252757217415256081982859724158327
8731544411246154674514626001858732363262751244419415544407653873858309154132440
262888841600498885105451586030156787
os = 
2966384769329081457959929210854946307725303451729041111756565081822209869706734
8470774040638374545482380962278433814588423220351160599355457893703887679991323
47222281376931478665079
n2 = 
8799438599707547810413590252769637047669730373282934937368515093438977181200080
0579489779988597377758155357032119662485786694473083701713238817766110307526481
3548019687916249789646432293683345877522755062343500052761478105552414593635335
7662536280470664112516976033358499330391929435857811788923590666783090016628619
936968367309955759172412259970189158362661969
n3 = 
2450273093965540729254343689738219629751666422727332060239790687869672337224287
7776550446563950867624819352853122033114711732125433588724779869985477495098802
7443444489150326074699546422578258559318722819082323316238297250430318005357394
3213394860744836264120403454658144490440875489203711003120257346339920162581200
5615264689877537231974023870006792196961829162058446662172634212427186470724599
9413528305460437729692977332395186047493666841638137959996257849313751101378051
43337329
c3 = 
2385064917660948806957457681641614888669217960607006360543268900921017481245498
5632639914109186048913143848105334392538145230671686367689762200590281089005923
2311952465790336469770032914545351776909326505271520462587023228820342754515098
3037310876534801548309890853026234248412421497939811385725642492104262954059677
7935387076042051793448841426568428955677950006478374618351793957423993726834602
0827131088465727989353253912189355814302993379490547089912763278011045912220379
6256514
m = 
8122573882816664059905415402318346587067896090676967360535808452919687117442942
7936591822589995476552044227730868809310992934103731850597399114246762836121101
3483010792966639515036880722995423570130933247188509369252659542049736344708361
87733828189312553819810470405246669124171178070485118436102895117354417
men3 = 
2223858574968933504319836040365324804971094330459462393944127171432282147604729
8977043454290592085809700500599520080107736858423927071836758485527270617538166
0452133866799616642403068831262241691836491409291683436342456375784878509459866
8876885795408211613686469658206698800530604510586036849762682266643367887969834
4619056273526837700698315346972423482713305543394110949178233504551465821354514
5351553890871388675765321397392709608232948734978250409638627517729140877418314
03951901
c0 = (pow(invert(m, n3), 3, n3)*men3) % n3
p = gcd(c0 - m**4, n3)
q = n3//p
assert p*q == n3
phi3 = (p-1)*(q-1)
# for s in range(2, 1024):
#     if isPrime(s):
#         if(gcd(s, p-1) == 1):
#             sinv = invert(s, p-1)
#             e = 4*s*sinv+3
#             if(gcd(phi3, e) == 1) and pow(m, e, n3) == men3:
#                 print(e)
#                 break
e = 
1238419093611284584432232492872571809868775483297315378237144063776322395466016
3376160801730552543302364965225321730703720886202083107309525500846264215867190
6878720312050776177834213726024951130777509918099166786617739404924137915186815
43351943
c2 = pow(c3, inverse(e, phi3), n3)
# t = n2//os - os
# def f1(x, y): return pow(x * y - t, 2) - 4 * os * x * y
# def f2(x, y, s): return (t - x * y - s) // (2 * x)
# token = 0
# for x in range(1, 3000):
#     if token == 1:
#         break
#     for y in range(1, 3000):
#         if f1(x, y) >= 0:
#             s, b = iroot(f1(x, y), 2)
#             if b:
#                 if isPrime(f2(x, y, int(s))):
#                     p = f2(x, y, int(s))
#                     token = 1
combinelfsr
 https://xz.aliyun.com/t/4630 z3
#                     print(p)
#                     break
o = 
1676411670285048925942831159178890500305934420821187645050581608997548349732091
194185626951
s = os//o
assert(o*s == os)
t = next_prime(o)
u = next_prime(s)
phi2 = (o-1)*(s-1)*(t-1)*(u-1)
c1 = pow(c2, inverse(65537, phi2), n2)
# factor on https://www.alpertron.com.ar/ECM.HTM
x = 
1532475862559167888089449717098486868564837338169781366942603735389113940567854
981202963
y = 
3218199311374252564987844405906822423986158410156540870579467844317139275192495
4605262593
z = 
1479543829675673344958256023332723030086630911860814739465102996214894567002503
8030648018654063509929678530025486672382773750364459323091677812986032701648425
7850428720933989793
assert x*y*z == n1
phi1 = (x-1)*(y-1)*(z-1)
print(long_to_bytes(pow(c1, inverse(65537, phi1), n1)))
from z3 import *
def lfsr(R,mask):
    output = (R >1
    output^=lastbit
    return (output,lastbit)
def single_round(R1,R1_mask,R2,R2_mask):
rw
aes_baby
aeskeyaarch64 https://github.com/wolfS
SL/wolfssl/blob/master/wolfcrypt/src/port/arm/armv8-aes.c 
    (R1_NEW,x1)=lfsr(R1,R1_mask)
    (R2_NEW,x2)=lfsr(R2,R2_mask)
    # (R3_NEW,x3)=lfsr(R3,R3_mask)
    return (R1_NEW,R2_NEW,(x1*x2)^((x2^1)))
with open("./out") as f:
    cipher = f.read()
R1 = BitVec('a1',20)
R2 = BitVec('a2',20)
R1_mask=0x30517
R2_mask=0x25b74
bin_c = ''
for i in cipher:
    bin_c += bin(ord(i))[2:].rjust(8,'0')
so = Solver()
for i in xrange(192):
    R1,R2,cip = single_round(R1,R1_mask,R2,R2_mask)
    so.add(int(bin_c[i]) == cip)
print(so.check())
print(so.model())
# len1 = 18
# guess(len1, R1_mask) #76.5625 0x1b9cb
# R1 = 0x01b9cb
#guess(len3, R3_mask) #73.4375 0x16b2f3
# R3 = 0x16b2f3
# print brute_force(R1, R3, len2) #0x5979c