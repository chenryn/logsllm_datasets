D. Sehr, C. Bifﬂe, and B. Yee. Language-independent sandboxing of just-
in-time compilation and self-modifying code. In 32nd ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI,
2011.
[6] M. Backes and S. Nürnberger. Oxymoron: Making ﬁne-grained memory
In 23rd USENIX
randomization practical by allowing code sharing.
Security Symposium, 2014.
[7] M. Backes, T. Holz, B. Kollenda, P. Koppe, S. Nürnberger, and J. Pewny.
You can run but you can’t read: Preventing disclosure exploits in
executable code.
In ACM SIGSAC Conference on Computer and
Communications Security, CCS, 2014.
[8] S. Bhatkar and D. C. DuVarney. Efﬁcient techniques for comprehensive
In 14th USENIX Security
protection from memory error exploits.
Symposium, 2005.
[9] A. Bittau, A. Belay, A. J. Mashtizadeh, D. Mazières, and D. Boneh.
Hacking blind. In 35th IEEE Symposium on Security and Privacy, S&P,
2014.
[10] Black Duck Software, Inc. Chromium project on open hub. https:
//www.openhub.net/p/chrome, 2014.
[11] D. Blazakis. Interpreter exploitation: Pointer inference and JIT spraying.
BlackHat DC, 2010.
[12] T. K. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang.
Jump-oriented
programming: a new class of code-reuse attack. In 6th ACM Symposium
on Information, Computer and Communications Security, ASIACCS,
2011.
[13] N. Carlini and D. Wagner. ROP is still dangerous: Breaking modern
defenses. In 23rd USENIX Security Symposium, 2014.
[14] S. Checkoway, L. Davi, A. Dmitrienko, A. Sadeghi, H. Shacham, and
M. Winandy. Return-oriented programming without returns. In ACM
SIGSAC Conference on Computer and Communications Security, CCS,
2010.
[15] X. Chen and D. Caselden. CVE-2013-3346/5065 technical analy-
sis. http://www.ﬁreeye.com/blog/technical/cyber-exploits/2013/12/cve-
2013-33465065-technical-analysis.html, 2013.
[16] X. Chen, D. Caselden, and M. Scott. The dual use exploit: CVE-
2013-3906 used in both targeted attacks and crimeware campaigns.
http://www.ﬁreeye.com/blog/technical/cyber-exploits/2013/11/the-
dual-use-exploit-cve-2013-3906-used-in-both-targeted-attacks-and-
crimeware-campaigns.html, 2013.
[17] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng. ROPecker: A
generic and practical approach for defending against ROP attacks. In
21st Annual Network and Distributed System Security Symposium, NDSS,
2014.
[18] F. B. Cohen. Operating system protection through program evolution.
Computers & Security, 12, 1993.
[19] S. Crane, P. Larsen, S. Brunthaler, and M. Franz. Booby trapping software.
In New Security Paradigms Workshop, NSPW, 2013.
[20] L. Davi, A. Sadeghi, D. Lehmann, and F. Monrose. Stitching the gadgets:
On the ineffectiveness of coarse-grained control-ﬂow integrity protection.
In 23rd USENIX Security Symposium, 2014.
[21] L. Davi, C. Liebchen, A.-R. Sadeghi, K. Z. Snow, and F. Monrose.
Isomeron: Code randomization resilient to (just-in-time) return-oriented
programming. In 22nd Annual Network and Distributed System Security
Symposium, NDSS, 2015.
[22] L. V. Davi, A. Dmitrienko, S. Nürnberger, and A. Sadeghi. Gadge me if
you can: secure and efﬁcient ad-hoc instruction-level randomization for
x86 and ARM. In 8th ACM Symposium on Information, Computer and
Communications Security, ASIACCS, 2013.
[23] I. Evans, S. Fingeret, J. Gonzalez, U. Otgonbaatar, T. Tang, H. Shrobe,
S. Sidiroglou-Douskos, M. Rinard, and H. Okhravi. Missing the point:
On the effectiveness of code pointer integrity. In 36th IEEE Symposium
on Security and Privacy, S&P, 2015.
[24] S. Forrest, A. Somayaji, and D. H. Ackley. Building diverse computer
In The 6th Workshop on Hot Topics in Operating Systems,
systems.
HotOS-VI, 1997.
778
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:24 UTC from IEEE Xplore.  Restrictions apply. 
[25] I. Fratric. ROPGuard: Runtime prevention of return-oriented programming
attacks.
http://www.ieee.hr/_download/repository/Ivan_Fratric.pdf, 2012.
[26] R. Gawlik and T. Holz. Towards automated integrity protection of C++
virtual function tables in binary programs. In 30th Annual Computer
Security Applications Conference, ACSAC, 2014.
[27] J. Gionta, W. Enck, and P. Ning. HideM: Protecting the contents of
userspace memory in the face of disclosure vulnerabilities. In 5th ACM
Conference on Data and Application Security and Privacy, CODASPY,
2015.
[28] C. Giuffrida, A. Kuijsten, and A. S. Tanenbaum. Enhanced operating
system security through efﬁcient and ﬁne-grained address space random-
ization. In 21st USENIX Security Symposium, 2012.
[29] E. Göktas, E. Athanasopoulos, H. Bos, and G. Portokalidis. Out of
control: Overcoming control-ﬂow integrity. In 35th IEEE Symposium on
Security and Privacy, S&P, 2014.
[30] E. Göktas, E. Athanasopoulos, M. Polychronakis, H. Bos, and G. Por-
tokalidis. Size does matter: Why using gadget-chain length to prevent
code-reuse attacks is hard. In 23rd USENIX Security Symposium, 2014.
[31] J. L. Henning. SPEC CPU2006 memory footprint. SIGARCH Computer
Architecture News, 35, 2007.
[32] J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson. ILR:
where’d my gadgets go? In 33rd IEEE Symposium on Security and
Privacy, S&P, 2012.
[33] A. Homescu, S. Brunthaler, P. Larsen, and M. Franz. Librando:
transparent code randomization for just-in-time compilers.
In ACM
SIGSAC Conference on Computer and Communications Security, CCS,
2013.
[34] A. Homescu, S. Neisius, P. Larsen, S. Brunthaler, and M. Franz.
Proﬁle-guided automatic software diversity. In IEEE/ACM International
Symposium on Code Generation and Optimization, CGO, 2013.
[35] Intel. Intel 64 and IA-32 architectures software developer’s manual -
Chapter 28 VMX support for address translation.
http://www.intel.com/content/dam/www/public/us/en/documents/
manuals/64-ia-32-architectures-software-developer-manual-
325462.pdf.
[36] D. Jang, Z. Tatlock, and S. Lerner. SafeDispatch: Securing C++ virtual
In 21st Annual Network and
calls from memory corruption attacks.
Distributed System Security Symposium, NDSS, 2014.
[37] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning. Address space layout
permutation (ASLP): towards ﬁne-grained randomization of commodity
software. In 22nd Annual Computer Security Applications Conference,
ACSAC, 2006.
[38] S. T. King, P. M. Chen, Y. Wang, C. Verbowski, H. J. Wang, and J. R.
Lorch. Subvirt: Implementing malware with virtual machines. In 27th
IEEE Symposium on Security and Privacy, S&P, 2006.
[39] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song.
Code-pointer integrity. In 11th USENIX Symposium on Operating Systems
Design and Implementation, OSDI, 2014.
[40] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz. SoK: Automated
software diversity. In 35th IEEE Symposium on Security and Privacy,
S&P, 2014.
[41] C. Lattner and V. S. Adve. LLVM: A compilation framework for
lifelong program analysis & transformation. In IEEE/ACM International
Symposium on Code Generation and Optimization, CGO, 2004.
[42] Microsoft. Enhanced Mitigation Experience Toolkit.
https://www.microsoft.com/emet, 2015.
[43] Microsoft. Hyper-V.
http://www.microsoft.com/hyper-v, 2015.
[44] V. Mohan, P. Larsen, S. Brunthaler, K. Hamlen, and M. Franz. Opaque
control-ﬂow integrity. In 22nd Annual Network and Distributed System
Security Symposium, NDSS, 2015.
[45] Nergal. The advanced return-into-lib(c) exploits: PaX case study. Phrack
Magazine, 11, 2001.
[46] B. Niu and G. Tan. RockJIT: Securing just-in-time compilation using
modular control-ﬂow integrity. In ACM SIGSAC Conference on Computer
and Communications Security, CCS, 2014.
[47] Open Virtualization Alliance. KVM - kernel based virtual machine.
http://www.linux-kvm.org.
[48] Oracle Corporation. VirtualBox.
http://www.virtualbox.org.
[49] V. Pappas, M. Polychronakis, and A. D. Keromytis. Smashing the
gadgets: Hindering return-oriented programming using in-place code
randomization. In 33rd IEEE Symposium on Security and Privacy, S&P,
2012.
[50] V. Pappas, M. Polychronakis, and A. D. Keromytis. Transparent ROP
exploit mitigation using indirect branch tracing. In 22nd USENIX Security
Symposium, 2013.
[51] PaX Team. Homepage of The PaX Team, 2001. http://pax.grsecurity.net.
[52] A. Prakash, X. Hu, and H. Yin. vfGuard: Strict protection for virtual
In 22nd Annual Network and
function calls in COTS C++ binaries.
Distributed System Security Symposium, NDSS, 2015.
[53] R. Roemer, E. Buchanan, H. Shacham, and S. Savage. Return-oriented
programming: Systems, languages, and applications. ACM Transactions
on Information System Security, 15, 2012.
[54] J. Rutkowska and A. Tereshkin. IsGameOver() anyone? In BlackHat
USA, 2007.
[55] F. Schuster, T. Tendyck, J. Pewny, A. Maaß, M. Steegmanns, M. Contag,
and T. Holz. Evaluating the effectiveness of current anti-ROP defenses.
In 17th International Symposium on Research in Attacks, Intrusions and
Defenses, RAID, 2014.
[56] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and T. Holz.
Counterfeit object-oriented programming: On the difﬁculty of preventing
code reuse attacks in C++ applications. In 36th IEEE Symposium on
Security and Privacy, S&P, 2015.
[57] J. Seibert, H. Okhravi, and E. Söderström. Information leaks without
memory disclosures: Remote side channel attacks on diversiﬁed code. In
ACM SIGSAC Conference on Computer and Communications Security,
CCS, 2014.
[58] H. Shacham. The geometry of innocent ﬂesh on the bone: return-into-libc
without function calls (on the x86). In ACM SIGSAC Conference on
Computer and Communications Security, CCS, 2007.
[59] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and
A. Sadeghi. Just-in-time code reuse: On the effectiveness of ﬁne-grained
address space layout randomization. In 34th IEEE Symposium on Security
and Privacy, S&P, 2013.
[60] C. Song, C. Zhang, T. Wang, W. Lee, and D. Melski. Exploiting and
In 22nd Annual Network and
protecting dynamic code generation.
Distributed System Security Symposium, NDSS, 2015.
[61] R. Strackx, Y. Younan, P. Philippaerts, F. Piessens, S. Lachmund, and
T. Walter. Breaking the memory secrecy assumption. In 2nd European
Workshop on System Security, EUROSEC, 2009.
[62] L. Szekeres, M. Payer, T. Wei, and D. Song. SoK: Eternal war in memory.
In 34th IEEE Symposium on Security and Privacy, S&P, 2013.
[63] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, Ú. Erlingsson,
L. Lozano, and G. Pike. Enforcing forward-edge control-ﬂow integrity
in GCC & LLVM. In 23rd USENIX Security Symposium, 2014.
[64] VMware, Inc. VMware ESX.
http://www.vmware.com/products/esxi-and-esx/overview.
[65] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin. Binary stirring: self-
randomizing instruction addresses of legacy x86 binary code. In ACM
SIGSAC Conference on Computer and Communications Security, CCS,
2012.
[66] Xen Project. Xen.
http://www.xenproject.org.
[67] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant, D. Song,
and W. Zou. Practical control ﬂow integrity and randomization for binary
executables. In 34th IEEE Symposium on Security and Privacy, S&P,
2013.
[68] C. Zhang, C. Song, K. Z. Chen, Z. Chen, and D. Song. VTint: Defending
virtual function tables’ integrity. In 22nd Annual Network and Distributed
System Security Symposium, NDSS, 2015.
[69] M. Zhang and R. Sekar. Control ﬂow integrity for COTS binaries. In
22nd USENIX Security Symposium, 2013.
APPENDIX
Figure A provides a detailed overview of Readactor.
779
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:24 UTC from IEEE Xplore.  Restrictions apply. 
Source 
Code
1
2
  Readactor Compiler
Code diversiﬁcation
Function order
Register allocation
Code-pointer hiding
Trampolines
Code-data separation
Readacted Application
X
1010100110
1011100100
1001000100
0110110101
0011011110
0001010111
0010010100
X
  Trampolines
RW
Data
3
5
4
Readacted Process
X
RW
Code
JUMP func_tramp
…
7
Trampolines
CALL func
jump to call site
Stack
…
Return Address
(pointer to 
trampoline)
6
Operating System
X-only enabled
Application Loader
Thin Hypervisor
Figure A: Overview of Readactor. Components marked in gray are part of Readactor.
Hardware
Memory
Virtualization
read
A
B
Adversary
0
B
EPT
Detect memory
read violation
System Components:
0 Enabling execute-only support: We load a thin hypervisor
to activate memory virtualization and to setup the Extended
Page Table (EPT). The EPT contains two identity mappings
to the physical memory, a normal mapping and a readacted
mapping. The readacted mapping is used by the modiﬁed
operating system to set page permissions to execute-only.
1 Compilation: The compiler takes the source code of an
arbitrary program and creates a binary. The compiler (i) strictly
separates code and data, (ii) applies code diversiﬁcation in the
form of function permutation, register allocation randomization
and save slot reordering, and (iii) implements code-pointer
hiding, by creating a trampoline, as jmp  instruction
for every code pointer (e.g., return address destinations).
2 Binary: The output binary contains different sections for
code, trampolines and data. The linker marks appropriate access
permissions for each section.
3 Loader: The loader reads the size and permissions bits
of each section and allocates the respective memory regions,
protecting them with the requested permissions ( 4 ).
5 Code-pointer hiding: In order to hide code pointers during
runtime, calls are substituted with a jmp instruction to the
corresponding trampoline. The trampoline will then call the
the return address ( 6 ) will not point
original function, which pushes a return address on the stack.
However,
into the
code section, but to the trampoline section. As described in
Section IX, disclosing trampoline pointers will not provide any
knowledge to the adversary about the layout or content of the
code section. Once the called function returns to the trampoline,
control ﬂow is returned to the original call site through another
jmp instruction ( 7 ). We similarly protect function pointers
with jmp trampolines (not shown).
Attack Scenarios:
A Reading data memory: Data regions remain readable and
writable. Hence, the adversary can disclose and modify code
pointers. However, the disclosed code pointers do not provide
any information about the applied code randomization and
can therefore not be used to create a ROP gadget chain (cf.
Section IX).
B Reading code memory: Code regions are set to execute-only.
Any attempt to read these regions causes an EPT exception
which is forwarded to the operating system. An application that
causes an execute-only exception by attempting to read or write
a code region is immediately killed by the operating system.
Since the execute-only permission is enforced in hardware it
cannot be bypassed by software.
780
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:24 UTC from IEEE Xplore.  Restrictions apply.