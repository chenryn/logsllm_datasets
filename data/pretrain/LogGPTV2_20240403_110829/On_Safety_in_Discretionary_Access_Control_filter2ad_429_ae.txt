subjects or objects as their counterparts are not speciﬁed
for the Solworth-Sloan scheme.
For simplicity, we consider an SDCO scheme that
has only three rights own, re, wr. In the Solworth-Sloan
scheme, if two objects o1 and o2 have the same label,
then o1 and o2 always have the same access characteris-
tics. That is, in every state, the set of subjects having a
right r over o1 is the same as the set of subjects having the
right r over o2. In SDCO, one can reach states in which
o1 and o2 have different access characteristics. Therefore,
each object needs to be assigned a distinct label.
Therefore, before creating an object, one has to create
a new label. When creating a new label (cid:99), one has to as-
sign a group to auth((cid:99), own) and a group to auth((cid:99), re);
and a group to auth((cid:99), wr). Each pair h(cid:99), ri determines a
unique access class. Therefore, a distinct group needs to
be created. We use g(o, r) to denote the group that will be
assigned to have the right r over object o.
In order to keep track of which subset of rights a sub-
ject has over an object, we need 8 group tags, one corre-
sponding to each subset of {own, re, wr}, we use tg(o, x),
where x is a 3-bit string to denote these tags.
In order for a subject s to create an object o, s needs to
do the following:
1. Create an NGS e = he.G, e.T g, e.gtag, e.nt g,
e.admin, e.patterns, e.GRSi as follows.
• e.G = {g(o, own), g(o, re), g(o, wr)}
• e.T g = {tg(o, 000), tg(o, 001), tg(o, 010),
tg(o, 011), tg(o, 100), tg(o, 101), tg(o, 110),
tg(o, 111)}.
• e.gtag[s] = tg(o, 100) and e.gtag[s0] =
tg(o, 000) for every s0 ∈ Sγ s.t. s0 6= s.
• e.nt g = tg(o, 000)
• e.admin = e
• e.patterns[g(o, own)] =
{h∗u, tg(o, 100)i,h∗u, tg(o, 101)i,
h∗u, tg(o, 110)i,h∗u, tg(o, 111)i}
e.patterns[g(o, re)] =
{h∗u, tg(o, 010)i,h∗u, tg(o, 011)i,
h∗u, tg(o, 110)i,h∗u, tg(o, 111)i}
e.patterns[g(o, wr)] =
{h∗u, tg(o, 001)i,h∗u, tg(o, 011)i,
h∗u, tg(o, 101)i,h∗u, tg(o, 111)i}
That is, in each tag, the ﬁrst bit corresponds to
own, the second to re, and the third to wr. In the
set of patterns for the group that corresponds to
own, the ﬁrst bit is always set in each tag, and
similarly for the groups that correspond to re
and wr respectively.
• e.GRS =
{Relabel (g(o, b1b2b3), g(o, b01b02b03)) =
g(o, own)
| b1b2b3, b01b02b03 ∈ {0, 1}3 ∧ b1b2b3 and b01b02b03
differ in exactly one bit }
2. Use create label(s,hs, t(o)i, g(o, re), g(o, wr))
create the label (cid:99)(o).
to
3. Use the action create object(s, o,hs, t(o)i) to create
the object o and label it with (cid:99)(o).
To grant or revoke a right, one uses group relabelling.
For instance, suppose s is a subject, and for the NGS,
e, e.gtag[s] = tg(o, 000). Then, we know that s is not
a member of any of the groups g(o, own), g(o, re) or
g(o, wr). The subject would be granted the right re by rela-
belling hs, tg(o, 000)i to the label hs, tg(o, 010)i. The ex-
ecution of this relabelling results in the subject becoming a
member of the group g(o, re), thereby giving him the right
re over the object o. Similarly, the subject would have the
right re revoked by relabelling hs, tg(o, 010)i to the label
hs, tg(o, 000)i. These operations can be carried out only
by a subject that is a member of the group g(o, own).
We make the following observations about the above
mapping.
• The above mapping does not capture the state invari-
ant in SDCO that in every state, there is exactly one
owner for every object that exists. In the Solworth-
Sloan system that results from the above mapping,
one can perform relabelling operations and reach
states in which there are mutiple owners for an ob-
ject, or no owner for an object. For instance, sup-
pose that there already exists a subject s such that
s ∈ membersγ[g(o, own)]. Given the above rela-
belling rules, there is nothing that precludes another
subject from also becoming a member of the group
g(o, own) while s continues to maintain membership
in that group. It is also possible to remove the mem-
bership of s in the group g(o, own) thereby leaving
the object with no owner. It is unclear how we would
prevent such situations from occuring in a system
based on the Solworth-Sloan scheme.
• We are unable to capture destruction of subjects and
objects as such constructs have not been speciﬁed for
the Solworth-Sloan scheme. Destruction of subjects
and objects is generally considered to be an impor-
tant component of any access control system. We
point out that a state-change rule to destroy a subject
or an object in the Solworth-Sloan scheme must be
carefully designed, as there are several components
of the state (such as tags) of which we must keep
track. Therefore, adding such state-change speciﬁca-
tions does not appear to be a trivial task. In particu-
lar, it is unclear how and with what overhead we can
capture in the Solworth-Sloan scheme, the notion of
transfer of ownership over objects owned by a subject
that is being destroyed.
• There is considerable overhead in implementing
a relatively simple DAC scheme (SDCO) in the
Solworth-Sloan scheme. For each object, we need
to create a set of labels whose size is linear in the
number of the subjects in the state. We also need to
create a set of tags whose size is exponential in the
number rights in the system. These tags are used to
deﬁne groups, and the therefore, the number of en-
tries in all the sets of patterns is also exponential in
the number of rights in the system. This is consid-
erable overhead considering the simplicity of SDCO,
and the fact that one can “directly” implement it, with
efﬁciently decidable safety.
Our conclusion is that several of the claims made by
Solworth and Sloan [27] are incorrect. In particular, not
only is the motivation (decidable safety) for the creation
of the new scheme invalid, but it is also not effective in
implementing relatively simple DAC schemes.
6. Conclusions
The focus of this paper is to provide a clear picture of
safety analysis in DAC. We have used a state-transition-
system-based meta-formalism to precisely model access
12
control schemes and systems and have studied safety anal-
ysis in a general DAC scheme from the literature, the
Graham-Denning scheme [8]. We have presented an al-
gorithm for deciding safety with running time O(n3) in
the Graham-Denning scheme, and proved that the algo-
rithm is correct. We have also countered several claims
made by Solworth and Sloan [27]. In particular, we have
countered the claim that the mapping presented there en-
codes all DAC schemes by considering a relatively simple
DAC scheme and demonstrating that the mapping has sev-
eral deﬁciencies. We conclude by asserting that safety in
existing general DAC schemes is decidable and there is no
need to invent new DAC schemes with decidable safety as
the primary goal.
Acknowlegements Portions of this work were sup-
ported by NSF Grants CCR-0325951 and IIS-0430274
and by sponsors of CERIAS.
References
[1] P. Ammann and R. S. Sandhu. Safety analysis for the ex-
tended schematic protection model. In Proceedings of the
1991 IEEE Symposium on Security and Privacy, pages 87–
97, May 1991.
[2] P. Ammann and R. S. Sandhu. The extended schematic
Journal of Computer Security, 1(3-
protection model.
4):335–383, 1992.
[3] E. Bertino, C. Bettini, E. Ferrari, and P. Samarati. An ac-
cess control model supporting periodicity constraints and
temporal reasoning. ACM Transactions on Database Sys-
tems, 23(3):231–285, 1998.
[4] E. Bertino, C. Bettini, and P. Samarati. A temporal au-
thorization model. In Proceedings of the ACM Conference
on Computer and Communications Security (CCS), pages
126–135. ACM Press, 1994.
[5] T. Budd. Safety in grammatical protection systems. Inter-
national Journal of Computer and Information Sciences,
12(6):413–430, 1983.
[6] N. C. S. Center. A guide to understanding discretionary
access control in trusted systems, Sept. 1987. NCSC-TG-
003.
[7] D. D. Downs, J. R. Rub, K. C. Kung, and C. S. Jordan.
Issues in discretionary access control. In Proceedings of
IEEE Symposium on Research in Security and Privacy,
pages 208–218, Apr. 1985.
[8] G. S. Graham and P. J. Denning. Protection — principles
In Proceedings of the AFIPS Spring Joint
and practice.
Computer Conference, volume 40, pages 417–429. AFIPS
Press, May 16–18 1972.
[9] P. P. Grifﬁths and B. W. Wade. An authorization mecha-
nism for a relational database system. ACM Transactions
on Database Systems, 1(3):242–255, 1976.
[10] M. A. Harrison, W. L. Ruzzo, and J. D. Ullman. Protec-
tion in operating systems. Communications of the ACM,
19(8):461–471, Aug. 1976.
[11] A. K. Jones, R. J. Lipton, and L. Snyder. A linear time
In 17th Annual IEEE
algorithm for deciding security.
Symposium on Foundations of Computer Science (FOCS),
pages 33–41, October 1976.
[12] L. Lamport. The temporal logic of actions. ACM Transac-
tions on Programming Languages and Systems (TOPLAS),
16(3):872–923, May 1994.
[13] B. W. Lampson. Protection.
In Proceedings of the 5th
Princeton Conference on Information Sciences and Sys-
tems, 1971. Reprinted in ACM Operating Systems Review,
8(1):18-24, Jan 1974.
[14] N. Li and M. V. Tripunitara. Security analysis in role-
In Proceedings of the Ninth ACM
based access control.
Symposium on Access Control Models and Technologies
(SACMAT 2004), pages 126–135, June 2004.
[15] N. Li and M. V. Tripunitara. On safety in discretionary
access control. Technical Report CERIAS-TR-2005-20,
Center for Education and Research in Information Assur-
ance and Security, Purdue University, Feb. 2005.
[16] N. Li, W. H. Winsborough, and J. C. Mitchell. Beyond
proof-of-compliance: Safety and availability analysis in
In Proceedings of IEEE Symposium
trust management.
on Security and Privacy, pages 123–139. IEEE Computer
Society Press, May 2003.
[17] R. J. Lipton and L. Snyder. A linear time algorithm for
deciding subject security. Journal of the ACM, 24(3):455–
464, 1977.
[18] T. Lunt. Access control policies: Some unanswered ques-
tions. In Proceedings of the 2nd IEEE Computer Security
Foundations Workshop, pages 227–245. IEEE Computer
Society Press, June 1988.
[19] N. H. Minsky. Selective and locally controlled transport
of privileges. ACM Transactions on Programming Lan-
guages and Systems, 6(4):573–602, Oct. 1984.
[20] R. Motwani, R. Panigrahy, V. A. Saraswat, and S. Ven-
tkatasubramanian. On the decidability of accessibility
the
problems (extended abstract).
Thirty-Second Annual ACM Symposium on Theory of
Computing, pages 306–315. ACM Press, May 2000.
In Proceedings of
[21] S. Osborn, R. S. Sandhu, and Q. Munawer. Conﬁguring
role-based access control to enforce mandatory and dis-
cretionary access control policies. ACM Transactions on
Information and System Security, 3(2):85–106, May 2000.
[22] P. Samarati and S. de Capitani di Vimercati. Access con-
trol: Policies, models, and mechanisms. In R. Focardi and
R. Gorrieri, editors, Foundations of Security Analysis and
Design, volume 2171 of Lecture Notes in Computer Sci-
ence, pages 137–196. Springer, 2001.
[23] R. S. Sandhu. The schematic protection model: Its deﬁni-
tion and analysis for acyclic attenuating systems. Journal
of the ACM, 35(2):404–432, 1988.
[24] R. S. Sandhu. Expressive power of the schematic protec-
tion model. Journal of Computer Security, 1(1):59–98,
1992.
[25] R. S. Sandhu. The typed access matrix model. In Proceed-
ings of the 1992 IEEE Symposium on Security and Privacy,
pages 122–136. IEEE Computer Society Press, May 1992.
[26] R. S. Sandhu. Undecidability of the safety problem for the
schematic protection model with cyclic creates. Journal
of Computer and System Sciences, 44(1):141–159, Feb.
1992.
13
[27] J. A. Solworth and R. H. Sloan. A layered design of discre-
tionary access controls with decidable safety properties. In
Proceedings of IEEE Symposium on Research in Security
and Privacy, May 2004.
[28] J. A. Solworth and R. H. Sloan. Security property based
administrative controls. In Proceedings of the Ninth Euro-
pean Symposium on Research in Computer Security (ES-
ORICS 2004), pages 244–259. Springer, Sept. 2004.
[29] M. Soshi. Safety analysis of the dynamic-typed access ma-
trix model. In Proceedings of the Sixth European Sympo-
sium on Research in Computer Security (ESORICS 2000),
pages 106–121. Springer, Oct. 2000.
[30] M. Soshi, M. Maekawa, and E. Okamoto. The dynamic-
typed access matrix model and decidability of the safety
IEICE Transactions on Fundamentals, E87-
problem.
A(1):190–203, Jan. 2004.
14