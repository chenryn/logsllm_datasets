Add a busy indicator to the Customers form
1. Display the ViewModel.cs file in the Code and Text Editor window.
After the LastError property, add the private _isBusy field and public
IsBusy property, as shown here:
Click here to view code image
private bool _isBusy;
public bool IsBusy
{
    get => this._isBusy;
    set
Download from finelybook PI:EMAIL
1075
    {
        this._isBusy = value;
        this.OnPropertyChanged(nameof(IsBusy));
    }
}
2. Modify the SaveAsync method and add the following statements shown
in bold. These statements set and reset the IsBusy indicator while the
method runs:
Click here to view code image
private async void SaveChanges()
{
this.IsBusy = true;
    if (this.ValidateCustomer(this.Current))
    {
    ...
    }
this.IsBusy = false;
}
3. Open the MainPage.xaml file in the Design View window.
4. In the XAML pane, add the ProgressRing control shown in bold in the
following code as the first item in the top-level Grid control:
Click here to view code image
...
Setting the Canvas.ZIndex property to “1” ensures that the
ProgressRing appears in front of the other controls displayed by the
Grid control.
Test the Customers app
1. On the Debug menu, click Start Debugging to build and run the app.
When the Customers form appears, notice that the TextBox and
ComboBox controls are disabled because the view is in Browsing mode.
Download from finelybook PI:EMAIL
1076
2. On the form, verify that both the upper and lower command bars appear.
You can use the First, Next, Previous, and Last buttons in the upper
command bar as before (remember that the First and Previous buttons
will not be enabled until you move away from the first customer). In the
lower command bar, the Add and Edit buttons should be enabled,  but
the Save Changes button and the Undo Changes button should be
disabled because the AddCustomer and EditCustomer commands are
enabled when the ViewModel is in Browsing mode, and the
SaveChanges and DiscardChanges commands are enabled only when
the ViewModel is in Adding or Editing mode.
3. In the bottom command bar, click the Edit Customer button.
4. The buttons in the top command bar become disabled because the
Download from finelybook PI:EMAIL
1077
ViewModel is now in Editing mode. Additionally, the Add and Edit
buttons are also disabled, but the Save Changes and Undo Changes
buttons should now be enabled. Furthermore, the data entry fields on the
form should also be enabled, and the user can modify the details of the
customer.
5. Change the details of the customer: blank out the first name, type Test
for the email address, type Test 2 for the phone number, and then click
Save Changes.
Note You must tab out of the phone number control (or click
another control on the main part of the form, or even click the form
itself) for the binding to copy the data to the view model and report
the illegal phone number. The same is true for any controls on the
form. This is due to the underlying mechanism implemented by
UWP apps; data in a bound control is not copied back to the data
source until the control loses focus. Clicking a button in a
command bar does not cause a change of focus, although tabbing
to a button does.
These changes violate the validation rules implemented by the
ValidateCustomer method. The ValidateCustomer method populates the
LastError property of the ViewModel with validation messages, which
are displayed on the form in the TextBlock that binds to the LastError
property:
Download from finelybook PI:EMAIL
1078
6. Click Undo Changes, and verify that the original data is reinstated on the
form. The validation messages disappear, and the ViewModel reverts to
Browsing mode.
7. Click Add. The fields on the form should be cleared (apart from the ID
field, which displays the value 0). Enter the details for a new customer.
Be sure to provide a first name and last name, a valid email address of
the form PI:EMAIL, and a numeric phone number (you
can also include parentheses, hyphens, and spaces).
8. Click Save Changes. If the data is valid (there are no validation errors),
your data should be saved to the database. You should see the ID
generated for the new customer in the ID field, and the ViewModel
should switch back to Browsing mode.
Download from finelybook PI:EMAIL
1079
9. Experiment with the app by adding and editing more customers. Notice
that you can resize the view to display the columnar layout, and the form
should still work.
Note When you click Save Changes, you might or might not see
the progress ring appear, depending on how quickly the changes
are saved. If you want to simulate the operation running more
slowly, add the following statement near to the end of the
SaveAsync method:
Click here to view code image
private async void SaveChanges()
{
    ...
    await Task.Delay(2000);
    this.IsBusy = false;
}
This code causes a delay of 2 seconds.
10. When you have finished, return to Visual Studio and stop debugging.
Summary
In this chapter, you learned how to use the Entity Framework to create an
entity model that you can use to connect to a SQL Server database. The
database can be running locally or in the cloud. You also saw how to create a
REST web service that a UWP app can use to query and update data in the
database through the entity model, and you learned how to integrate code that
calls the web service into a ViewModel.
You have now completed all the exercises in this book. I hope you are
thoroughly conversant with the C# language and understand how to use
Visual Studio 2017 to build professional apps for Windows 10. However, this
Download from finelybook PI:EMAIL
1080
is not the end of the story. You have cleared the first hurdle, but the best C#
programmers learn from continued experience, and you can gain this
experience only by building C# apps. As you do so, you will discover new
ways to use the C# language and many features in Visual Studio 2017 that I
have not had space to cover in this book. Also, remember that C# is an
evolving language. Back in 2001, when I wrote the first edition of this book,
C# introduced the syntax and semantics necessary to build apps that made
use of Microsoft .NET Framework 1.0. Some enhancements were added to
Visual Studio and .NET Framework 1.1 in 2003, and then in 2005, C# 2.0
emerged with support for generics and .NET Framework 2.0. C# 3.0 added
numerous features, such as anonymous types, lambda expressions, and, most
significantly, LINQ. C# 4.0 extended the language further with support for
named arguments, optional parameters, contravariant and covariant
interfaces, and integration with dynamic languages. C# 5.0 added full support
for asynchronous processing through the async keyword and the await
operator. C# 6.0 provided further tweaks to the language, such as expression-
bodied methods, string interpolation, the nameof operator, exception filters,
and many others. C# 7 includes many additional features, such as Tuples,
local functions in methods, support for expression-bodied members in
properties and other scenarios, pattern matching in switch statements, the
ability to handle and throw exceptions in new ways, enhanced syntax for
defining numeric literals, and a general tidying up of the way in which you
can define and use out variables.
In parallel with the evolution of the C# programming language, the
Windows operating system has changed considerably since the first edition of
this book. Arguably, the changes instigated by Windows 8 onward have been
the most radical in this period, and developers familiar with earlier editions of
Windows now have exciting new challenges to build apps for the modern,
touch-centric, mobile platform that Windows 10 provides. Furthermore,
modern business apps are extending beyond the boundaries of the
organization and out to the cloud, requiring you to implement highly scalable
solutions that might need to support thousands or even millions of concurrent
users. Visual Studio 2017, together with Azure and C# will undoubtedly be
instrumental in assisting you to address these challenges.
Quick reference
Download from finelybook PI:EMAIL
1081
To
Do this
Create an
entity
model by
using the
Entity
Framework
Add a new item to your project by using the ADO.NET Entity
Data Model template. Use the Entity Data Model Wizard to
connect to the database containing the tables that you want to
model and select the tables that your app requires.
In the data model, remove any columns that are not used by your
app (as long as they have default values), if your app is inserting
new items into the database).
Create a
REST web
service that
provides
remote
access to a
database
through an
entity
model
Create an Azure API App using the ASP.NET web Application.
Run the Add Scaffold wizard and select Web API 2 Controller
With Actions, Using Entity Framework. Specify the name of the
appropriate entity class from the entity model as the model class,
and the data context class for the entity model as the data context
class.
Deploy a
REST web
service to
the cloud
as an
Azure API
app
In Visual Studio, connect to your Azure subscription. Then use the
Publish Web wizard to publish your web service as an Azure App
Service. Specify an appropriate service plan that will support the
volume of traffic that your web service expects to handle.
Consume a
REST web
service
published
as an
Azure API
app in a
UWP
application
Run the REST API Client wizard in Visual Studio, and specify the
Azure API app that provides access to your web service. The
wizard downloads the metadata for the web service and creates a
model which it adds to your project.
Retrieve
data from a
Instantiate the connection class defined by the model created by
the REST API Client wizard. Call the appropriate Get method in
Download from finelybook PI:EMAIL
1082
REST web
service in a
UWP app
the Operations object available through the connection class. For
example:
Click here to view code image
AdventureWorksService service = new AdventureWorksService();
var data = service.CustomersOperations.GetCustomers();
Add a new
data item
to a REST
web
service
from a
UWP app
Use the appropriate Post method of the Operations object available
through the connection class. Pass the new data item as the
parameter to this method. If the operation is successful, the value
returned is a copy of the newly created object. For example:
Click here to view code image
AdventureWorksService service = new AdventureWorksService();
var cust = await
service.CustomersOperations.PostCustomerAsync(this.Current);
Update an
existing
item in a
REST web
service
from a
UWP app
Use the appropriate Put method of the Operations object available
through the connection class. Pass the key and the data for the
modified data as parameters. For example:
Click here to view code image
AdventureWorksService service = new AdventureWorksService();
await service.CustomersOperations.PutCustomerAsync
(this.Current.CustomerID, this.Current);
Download from finelybook PI:EMAIL
1083
Index
Symbols
& (ampersand)
& (AND) operator, 365
&& (logical AND) operator, 365
associativity, 99
precedence, 99
short-circuiting, 97–98
syntax, 97
&lt; entity, 109
in XML, 109
 (angle brackets)
>= (greater than or equal to) operator, 96, 99, 112
> (greater than) operator, 96, 99, 112
 (lambda) operator, 64, 425
! (exclamation mark)
!= (inequality) operator, 96, 99, 112, 510
! (NOT) operator, 96
/ (forward slash)
/= (compound division) operator, 116
/ (division) operator, 47
- (hyphen)
-= (compound subtraction) operator, 116, 455, 467, 476
-- (decrement) operator, 56–57, 59, 116, 146, 508–509
- (subtraction) operator, 47
() (parentheses)
in if statements, 100
in method calls, 62, 66
precedence override, 54
% (percent sign)
%= (compound modulus) operator, 116
% (modulus) operator, 48
. (period)
dot notation, 284
dot operator, 316
| (pipe)
|| (logical OR) operator
associativity, 99
precedence, 99
short-circuiting, 97–98
syntax, 97
| (OR) operator, 365
Download from finelybook PI:EMAIL
1085
+ (plus sign)
+ (addition) operator, 47
+= (compound addition) operator, 116, 466, 476
++ (increment) operator, 56–57, 59, 116, 146, 508–509
? (question mark)
indicating nullable types with, 191–192, 210
? (null-conditional) operator, 190–191, 207
" (quotation marks, double), 111
as delimiters, 111
in XML, 109
' (quotation marks, single), 111
; (semicolon)
in enumeration variable declarations, 227
in method declarations, 63
statement termination, 35–36, 38
in structure variable declarations, 227
[ ] (square brackets), 54, 229, 252
~ (tilde)
in destructor declarations, 317, 335
~ (NOT) operator, 365
_ (underscore), 38, 364
A
abstract classes
abstract methods, 306
declaring, 314
defining, 305–306
implementing, 307–311
quick reference, 314
sealed classes, 306–307
sealed methods, 307
Download from finelybook PI:EMAIL
1086
abstract keyword, 306, 313, 314
abstract methods, 306
abstracting tasks, 545–549
Accelerate method, 280
accessibility
of classes, 162–163
of properties, 346
accessor methods, 368–369
indexers, 368
properties, 342–343
Action type, 529, 676
Action delegates, 452
adapter methods, 464–465
Add Controller dialog box, 719
Add Existing Project dialog box, 446
Add method, 413, 419, 421, 423, 432, 455, 737
Add Reference command, 17
Add Scaffold wizard, 718
AddAfter method, 415
AddBefore method, 415
AddCardToHand method, 246, 430
AddCustomer command, 736
AddFirst method, 415
AddItemToLocalCache method, 583
addition (+) operator, 47
AddLast method, 415
AddParticipant method, 596
AddToAccumulator method, 550
addValues method, 51, 62–65, 143
ADO.NET, 709–710
AdventureWorksEntities class, 716–717
AdventureWorksModel class, 712–713
Download from finelybook PI:EMAIL
1087
AdventureWorksService class, 710–712, 731
AdventureWorksService project. See also Customers application
AdventureWorks database
entity model, 709–717
REST web service deployment, 724–726
retrieving data from, 707–709
entity model, creating, 710–717
AdventureWorksEntities, 716–717
AdventureWorksModel, 712–713
AdventureWorksService, 710–712
Entity Data Model Wizard, 712–716
REST web service
adding/editing data with, 733–741
Azure API app security, 729–730
creating, 718–724
deploying to Azure, 724–726
idempotency, 733
PostCustomerWithHttpMessagesAsync method, 742
retrieving data with, 726–732
AggregateException, 562–563, 565
aggregating data, 485–487
Airplane class, 279–280
All method, 491
allocation of memory, asynchronous methods and, 582–583
ampersand (&)
AND (&) operator, 365
logical AND (&&) operator, 365
associativity, 99
precedence, 99
short-circuiting, 97–98
syntax, 97
in XML, 109