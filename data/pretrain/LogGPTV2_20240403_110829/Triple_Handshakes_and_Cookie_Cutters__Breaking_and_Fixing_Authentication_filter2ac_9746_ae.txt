We propose several countermeasures at the TLS level that
prevent our man-in-the-middle attacks at their source with
few or no changes required to application-level mechanisms.
The ideas behind these proposals emerged from discussions
with various implementors and protocol experts and we are
cautiously optimistic about their adoption. Since new protocol
extensions and features can take a long time to propagate, we
also discuss short-term mitigations for various applications.
VII-A A NEW CHANNEL BINDING. In §V-C and §VI-C, we
found that neither the session id, nor the master secret, nor the
tls-unique channel binding served as unique representatives
for a TLS session. Hence, we propose a new TLS channel
binding, called tls-session-hash,
the
negotiated parameters for a session.
that captures all
We deﬁne tls-session-hash for a given TLS session as
the hash of the handshake messages up to and including the
client key exchange message in the original handshake that
created the session. The hash function used depends on the
protocol version. For TLS 1.2, this is the hash function in
the ciphersuite. For SSL3 and earlier versions of TLS, this is
the concatenation of MD5 and SHA1 hashes. We require that
TLS implementations compute and store tls-session-hash
within its session structure and expose it to implementations.
Why this deﬁnition? We only hash messages up to the
client key exchange, because at this point the negotiation is
complete and all the inputs to the master secret are available,
so most TLS implementations will create (but not cache) the
session structure. Notably, the hashed log includes the nonces,
the ciphersuite, key exchange messages, client and server
certiﬁcates, and any identities passed in protocol extensions.
Our deﬁnition of the hash functions matches those used
for the ﬁnished messages in SSL3 and TLS 1.0–1.2; hence,
implementations already keep a running hash of the log and
we just re-use its value. Implementing this channel binding
increases the cached session size by a single hash, and has no
performance impact.
We deﬁne a new hash value instead of reusing the client or
server verify data for three reasons. (1) It is compatible with
stateless servers [50], which must send the session ticket before
the server ﬁnished message, so the server verify data is not
available yet. (2) Being longer than the verify data, the session
hash offers stronger collision resistance. While collisions may
be less problematic for (the usually few) renegotiations on a
single connection, a session can be long-lived and frequently
resumed. (3) We could have reused the input to the client
verify data, but it would not offer any clear advantages, and our
current deﬁnition is more suitable for our proposed extensions.
Recommended Usage We recommend that protocols such as
SCRAM use tls-session-hash rather than tls-unique
for channel binding. To ﬁx Channel ID, we recommend
that
the signature on abbreviated handshakes include the
tls-session-hash of the resumed session. To derive ap-
plication keys from the master secret,
like in PEAP, we
recommend adding tls-session-hash to the PRF.
VII-B CONTEXT BINDING FOR MASTER SECRETS. We pro-
pose a new extension for all versions of TLS and DTLS that
causes negotiated session parameters to be included in the
master secret computation, following the principle of context
binding [21], whereby computed keys should be usage-speciﬁc.
As usual, the extension is signaled in the client and server
hello messages; if both peers support it, the handshake pro-
ceeds as usual, except that the master secret is computed as:
ms = prf(pms, “extended master secret”,
tls-session-hash)
The inclusion of tls-session-hash, instead of just the
pair of nonces, ensures that the resulting master secret depends
on all the negotiated session parameters. The master secret im-
plicitly authenticates these parameters, and different sessions
will have different master secrets, foiling our attacks.
We ﬁnd this solution elegant since it protects all TLS
handshake modes (including RSA and DHE) and protocol
versions, and it allows application-level protocols like PEAP
to safely use the TLS master-secret without any changes. The
idea of including additional materials in the master secret
109
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:56 UTC from IEEE Xplore.  Restrictions apply. 
As in [49],
computation is not new [21, 31, 3] but our proposal merits
more detailed analysis, which we leave for future work.
VII-C SECURE RESUMPTION INDICATION. We propose a
mandatory extension for all versions of TLS and DTLS that
complements the renegotiation indication extension [49] by
also protecting session resumption across multiple connections.
the extension is signaled in the client and
server hello messages (see §IV-C), but only when propos-
ing and accepting resumption, respectively. It contains the
tls-session-hash value of the session being resumed.
Peers supporting the extension must check that
this value
matches the one recorded in their locally stored session before
proceeding with the abbreviated handshake. The exchanged
session hashes are authenticated by the master secret in the
ﬁnished messages of the resumption, cryptographically binding
the new connection to the resumed session. If one of the peers
does not support the extension, the other should refuse session
resumption and may instead offer a full handshake.
VII-D SUMMARY OF MITIGATIONS. We implemented the
session hash channel binding and our two extensions as patches
to OpenSSL and miTLS, and we tested their interoperability
for all versions of TLS and DTLS. Our patches ﬁt well into
the code structure and have no visible effect on performance.
Independently, applications that rely on existing TLS APIs
can mitigate the attacks of this paper by following some con-
servative design principles, at some cost to their functionality.
1) Do not allow the peer to renegotiate its certiﬁcate.
2) Do not use tls-unique after session resumption .
3) To derive application keys from the TLS master secret,
hash the session’s certiﬁcates into the derivation.
4) Buffer application data until its semantics is unambigu-
ous; discard it if the TLS connection is torn down.
5) Do not share secret cookies between HTTP and HTTPS
connections, or between different origins.
VIII. VERIFIED APPLICATION SECURITY OVER TLS
VIII-A MIHTTPS: A BASIC HTTPS CLIENT. To validate
our application-level recommendations and show that one can
indeed achieve transparent application-level security over TLS,
we build and verify an exemplary HTTPS library, at the same
level of abstraction as the CURL library, for example, but with
fewer features. Its client command-line interface is as follows:
$ mihttps --help
Usage: mihttps [options] REQUEST
https server host name
channel identifier
authenticated client name
--host=NAME
--channel=ID
--client=NAME
Our goal is to provide (1) a basic API with strong implicit
security; and (2) a ﬂexible implementation that supports typical
mechanisms available in HTTP (cookies) and TLS (multiple
connections, renegotiation, resumption, late client authentica-
tion). miHTTPS consists of 600 lines of F# coded on top of the
miTLS veriﬁed reference implementation [15]. In particular,
our client automatically processes HTTP 1.0 headers, cookies,
etc, and interoperates with existing, unmodiﬁed web servers.
We tested e.g. authenticated webmail access to Roundcube.
(We refer to the online materials for a more detailed de-
scription of miHTTPS, its code, and its veriﬁcation.)
Secure Channels Our main communication abstraction is a
long-term, stateful channel between a client and a host. Each
client may create any number of channels and use them to
request documents from URLs at different hosts; each channel
supports parallel requests, as required e.g. when loading a
web page that includes numerous resources. Each request may
asynchronously return a document (in any order).
Such channels are not reliable: requests and responses may
get lost or delayed, and their sender have no explicit acknowl-
edgment of peer reception. Instead, responses conﬁrm requests,
and cookies attached to requests conﬁrm prior responses.
In the command line, the host=NAME option indicates
that a new channel should be created and its ID returned,
whereas channel=ID indicates the local
identiﬁer of an
existing channel to reuse. These application-level channels are
not primitive in HTTPS or TLS; they intuitively account for
a series of related requests issued by a client. For example, a
user may have long-lived authenticated channels to every host
she trusts, plus shorter-lived anonymous channels. The server
is always authenticated. The user may use the client=NAME
option, where NAME refers to a valid client certiﬁcate she owns
to be used to authenticate her requests on the channel.
Simpliﬁcations We associate a unique host name to each
channel, treating each host as a separate principal: thus, we
do not deal with related sub-domains, redirects, or wildcards
in certiﬁcate names. We also do not support mixtures of HTTP
and HTTPS. Thus, we avoid many complications with cookies
discussed in §II and §III. (Applications may still multiplex
between hosts and protocols on top of our interface—what
matters is that we do not share private state between channels.)
Client and Server Credentials We rely on the public-key
infrastructure for X.509 certiﬁcates, and require that client and
host names exactly match their certiﬁcates’ common names.
Our threat model does not cover certiﬁcates mis-issued to the
adversary, or issued for different purposes with a common
name that matches an honest principal.
Credentials are associated with the whole channel, once
and for all. The host name cannot be changed, preventing
the renegotiation attack of §VI-A. The client can decide to
authenticate later on an anonymous channel, and from the
server’s viewpoint, this sufﬁces to attribute all requests on the
channel to that client. From the client’s viewpoint, binding her
name to the channel before a particular request guarantees that
the server will only process it after client authentication.
Local State and Cookies Our channels maintain local, private
state, including e.g. open connections, live sessions, cookies,
and the names associated with the channel. Our channels also
buffer request and response fragments, in order to deliver only
whole HTTPS messages to the application—this simply foils
truncation attacks, including those of §III-B.
At the server, we partition incoming requests into sepa-
rate channels and track requests received from each client
by attaching a (locally stored) fresh random cookie to each
response. The set of responses actually received can then be
110
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:56 UTC from IEEE Xplore.  Restrictions apply. 
inferred from the cookies attached to latter requests. (Assum-
ing sufﬁcient cookie storage space and entropy to prevent
collisions, this pattern provides accurate tracking information.)
VIII-B SECURITY GOALS (INFORMAL). We primarily focus
on application-level channel integrity—see the online version
for privacy. We follow the cryptographic model of [15] and
conﬁgure honest clients and servers to only negotiate strong
ciphersuites and algorithms [as deﬁned by 15]. We show that,
with overwhelming probability, the following properties hold:
1) Request Integrity: when an honest server accepts a
request and attributes it to a channel bound to honest
server and client names, the client has indeed sent the
request on that channel, with matching principal names.
2) Response Integrity: when an honest client accepts a
document in reply to a request to an honest server, that
server has indeed sent the document in response to this
request. (This property is sometimes called correlation.)
3) Tracking: when an honest server accepts a request
echoing the cookie of a response on a channel with an
honest client, the client indeed received this response.
Property 1 excludes any mis-attribution of a request to a
client. Properties 1 and 2 apply to whole messages, thereby ex-
cluding truncations. This is achieved by parsing and buffering
message fragments until the whole message has been received,
decrypted, and authenticated.
VIII-C MIHTTPS: SECURE TYPED INTERFACE. We follow
the modular type-based cryptographic veriﬁcation method [26]
that was used to obtain the main security theorem for the
miTLS API [15]. They specify computational security for var-
ious constructions and protocols using precise typed interfaces
(instead of code-based games or ideal functionalities). They
employ an expressive reﬁnement-based type system for F#,
write detailed typed annotations (4,000 lines for miTLS), and
verify their code against
them automatically using F7, an
extended typechecker, coupled with Z3, an SMT solver.
The veriﬁcation effort for miHTTPS consists of specifying
its typed API and letting F7 typecheck its 600 lines of code,
using the lower-level, veriﬁed, precisely-typed API of miTLS.
In the rest of the section, we outline the types we use to capture
the security goals of §VIII-B.
Figure 4 shows fragments of our typed speciﬁcation for
miHTTPS, focusing on the main functions for the client. It
deﬁnes a type for names—plain strings used as common names
in certiﬁcates—and for channels: type (;host:name)chan. This
type is indexed by a value, host, itself of type name, recording
in the type that the channel should be used only for com-
munications with servers with a valid certiﬁcate for host. This
type is also abstract, hiding its representation, so that only our
miHTTPS implementation can access it; applications can just
pass channels as arguments to the API, but they cannot access
their internal states (and so cannot accidentally leak keys) or
modify the host index (and so cannot get confused between
channels to different hosts).
Our API has 3 main modules, and is parameterized by an
application module, Data, provided by the application, that
deﬁnes types for requests (URLs) and responses (documents).
These types are both abstract and indexed. Their indexes
type name = string (∗ common names for both clients & hosts ∗)
type (;host:name) chan
predicate Honest of name (∗ no compromised certiﬁcate ∗)
predicate Client of name ∗ host:name ∗ (;host)chan
type (;host,chan)request
type (;host,chan,request)document
1
2
3
4
5
6 module Data (∗ deﬁned by the application ∗)
7
8
9 module Certiﬁcate (...)
10 module Server (...)
11 module Client
12
13
14
15
16
val create: h:name → (;h) chan
val request: h:name → c:((;h)chan) →
val poll: h:name → c:((;h)chan) →
(a:name{Client(c,a)})option → r:(;h,c)request → unit
(r:(;h,c)request ∗ (;h,c,r)document) option
Fig. 4. miHTTPS interface (excerpt)
specify the host, the channel, and the request (for responses),
so only the application above miHTTPS can create and access
values at those types. They yield strong, information-theoretic
security: provided that the channel is between honest client and
server, type safety ensures that our protocol stack, including
HTTPS, TLS, TCP, and any network adversary, cannot read
their content (except for their size after encryption), tamper
with their content, or move contents from one channel to
another. Essentially, the protocol can only pass requests un-
changed from clients to servers, and similarly for responses.
The Certiﬁcate module manages certiﬁcates. Reﬂecting our
threat model, it has functions for generating certiﬁcates for
Honest names and endorsing keys for dishonest names.
The Server module deﬁnes the API for miHTTPS servers.
The Client module is the actual API used by client appli-
cations, such as our command-line client. It has functions for
creating a new channel towards a ﬁxed host h, for sending
requests (with optional client authentication), and for polling
responses to prior requests. These functions have precise value-
dependent types specifying their pre- and post-conditions. For
instance, request takes 4 parameters: the target host h; an
existing channel c for that host; an optional client name a
authorized by the user for that channel (as indicated by the
predicate Client(c,a)); and a request for that host and channel.
IX.
IMPACT AND LIMITATIONS
We have presented a series of attacks on authentication
mechanisms built within and over TLS. Table II summarizes
these new attacks and compares them to previous attacks, in
terms of their impact and limitations. The table lists precondi-
tions for each attack: what the attacker must be capable of;
how the application (mis-)uses TLS; and whether previous
mitigations block the attack () or not ().
For example, the second row indicates that the cookie cutter
attack of §III-B requires a network attacker and a client
application that processes truncated HTTP headers over TLS
and a server application that allows chosen plaintexts before
the Set-Cookie header. Its advantage over previous TLS
truncation attacks is a higher impact: it enables full HTTPS
session hijacking (by stealing session cookies) between main-
stream web browsers and popular websites such as Google and
Facebook. Conversely, our variant of network-based session
111
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:56 UTC from IEEE Xplore.  Restrictions apply. 
TABLE II.
SUMMARY OF ATTACKS: NOVELTY, IMPACT AND PRECONDITIONS