编写操作系统和驱动程序。
1.4
操作系统做什么
操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件资源。
计算机硬件的能力是有限的，比如一个CPU一秒钟能够执行的指令条数是1亿条或是
IGB的内存能够最多同时存储1GB的数据。无论你是否使用它，资源总是那么多。当然我
们不希望白已花钱买回来的硬件成为摆设，充分挖掘硬件的能力，使得计算机运行得更有效
率，在更短的时间内处理更多的任务，才是我们的目标，这对于早期动辑数百万美元的古董
计算机来说更是如此，人们挖空心思让计算机硬件发挥所有潜能。一个计算机中的资源主要
分CPU、存储器（包括内存和磁盘）和VO设备，我们分别从这三个方面来看看如何挖掘它
们的潜力。
1.4.1不要让CPU打吨
在计算机发展早期，CPU资源十分昂贵，如果个CPU只能运行一个程序，那么当程
序读写磁盘（当时可能是磁带）时，CPU就空闲下米了，这在当时简直就是暴珍天物。于
是人们很快编写了一个监控程序，当某个程序暂时无须使用CPU时，监控程序就把另外的
正在等待CPU资源的程序启动，使得CPU能够充分地利用起来，这种被称为多道程序
（Multiprogramming）的方法看似很原始，但是它当时的确大大提高了CPU的利用事，不
过这种原始的多道程序技术存在最大的问题是程序之间的调度策略太粗糙，对于多道程序来
说，程序之间不分轻重缓急，如果有些程序急需使用CPU来完成一些任务（比如用户交互
的任务），那么很有可能很长时间后才有机会分配到CPU。这对于有些响应时间要求高的程
序来说是很致命的，想象-下你在Windows上面点击鼠标10分钟以后系统才有反应，那该
是多么沮丧的事。
经过稍微改进，程序运行模式变成了一种协作的模式，即每个程序运行一段时间以后都
程序员的自我修养一链接、装载与库
---
## Page 34
1.4操作系统做什么
11
主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一小段时间，这对于一
些交互式的任务尤为重要，比如点击一下鼠标或按下一个键盘按键后，程序所要处理的任务
可能并不多，但是它需要尽快地被处理，使得用户能够立即看到效果，这种程序协作模式叫
做分时系统（Time-SharingSystem），这时候的监控程序已经比多道程序要复杂多了，完
整的操作系统维形已经逐渐形成了，Windows的早期版本（Windows95和WindowsNT之
前），MacOS X之前的 Mac OS版本都是采用这种分时系统的方式来调度程序的。比如在
Windows 3.1中，程序调用 Yield、GetMessage 或PeekMessage 这几个系统调用时，Windows
3.1操作系统会判断是否有其他程序正在等待CPU，如果有，则可能暂停执行当前的程序，
把CPU让出来给其他程序，如果一个程序在进行一个很耗时的计算，一直霸占着CPU不放。
那么操作系统也没办法，其他程序都只有等着，整个系统看过去好像死机了一样。比如一个
程序进入了一个while(1）的死循环，那么整个系统都停止了。
这在现在看来是很荒唐的事，系统中的任何一个程序死循环都会导致系统死机，这是无
法令人接受的。当然当时的PC硬件处理能力本身就很弱，PC上的应用也大多是比较低端
的应用，所以这种分时方式勉强也能应付一下当时的交互式环境了。此前在高端领域，非
PC的大中小型机领域，其实已经在研究一种更为先进的操作系统模式了。这种模式就是我
们现在很熟悉的多任务（Multi-tasking）系统，操作系统接管了所有的硬件资源，并且本身
运行在一个受硬件保护的级别。所有的应用程序都以进程（Process）的方式运行在比操作
系统权限更低的级别，每个进程都有自已独立的地址空间，使得进程之间的地址空间相互隔
离。CPU由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到CPU，
但是，如果运行时间超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他
等待运行的进程。这种CPU的分配方式即所谓的抢占式（Proemptive），操作系统可以强制
剥夺CPU资源并且分配给它认为目前最需要的进程。如果操作系统分配给每个进程的时间
都很短，即CPU在多个进程间快速地切换，从面造成了很多进程都在同时运行的假象。目
前儿乎所有现代的操作系统都是采用这种方式，比如我们熟器的UNIX、Linux、WindowsNT
以及MacOSX等流行的操作系统。
1.4.2设备驱动
操作系统作为硬件层的上层，它是对硬件的管理和抽象。对于操作系统上面的运行库和
应用程序来说，它们希塑看到的是一个统一的硬件访问模式，作为应用程序的开发者，我们
不希望在开发应用程序的时候直接读写硬件端口、处理硬件中断等这些繁项的事情。由于硬
件之间千差万别，它们的操作方式和访问方式都有区别，比如我们希望在显示器上画一条直
线，对于程序员来说，最好的方式是不管计算机使用什么显卡、什么显示器，多少大小多少
分辨率，我们都只要调用一个统一的LineToO函数，具体的实现方式由操作系统来完成。试
想一下如果程序员需要关心具体的硬件，那么结果会是这样：对于A型号的显卡来说，需
程序员的自我修养一链接、装载与库
---
## Page 35
12
第1章温故而知新
要往IO端口0x1001写一个命令0x1111.然后从端口0x1002中读取一个4字节的显存地址，
然后使用DDA（种画直线的图形算法）逐个地在显存上画点…如果是B型号的显卡，
可能完全是另外一种方式，这简直就是灾难，不过在操作系统成熟之前，的确存在这样的情
况，就是应用程序的程序员需要直接跟硬件打交道。
当成熟的操作系统出现以后，硬件逐渐被抽象成了系列概念。在UNIX中，硬件设备
的访问形式跟访问普通的文件形式一样：在Windows系统中，图形硬件被抽象成了GDI，
声音和多媒体设备被抽象成了DirectX对象：磁盘被抽象成了普通文件系统，等等。程序员
逐渐从硬件细节中解放出来，可以更多地关注应用程序本身的开发。这些繁颈的硬件细节全
都交给了操作系统，具体地讲是操作系统中的硬件驱动（DeviceDriver）程序来完成。驱动
程序可以看作是操作系统的一部分，它往往跟操作系统内核一起运行在特权级，但它又与操
作系统内核之间有一定的独立性，使得驱动程序有比较好的灵活性。因为PC的硬件多如牛
毛，操作系统开发者不可能为每个硬件开发一个驱动程序，这些驱动程序的开发工作通常由
硬件生产厂商完成。操作系统开发者为硬件生产厂商提供了一系列接口和框架，凡是按照这
个接口和框架开发的驱动程序都可以在该操作系统上使用。让我们以一个读取文件为例子来
看看操作系统和驱动程序在这个过程中份演了什么样的角色。
提到文件的读取，那么不得不提到文件系统这个操作系统中最为重要的组成部分之“。
文件系统管理着磁盘中文件的存储方式，比如我们在Linux系统下有一个文件
“/home/user/tesLdat”，长度为 8 000个字节。那么我们在创建这个文件的时候，Linux 的 ext3
文件系统有可能将这个文件按照这样的方式存储在磁盘中：文件的前4096字节存储在磁盘
的1000号扇区到1007号扇区，每个扇区512字节，8个扇区刚好4096字节：文件的第4097
个字节到第8000字节共3904个字节，存储在磁盘的2000号扇区到2007号扇区，8个扇
区也是4096字节，只不过只存储了3904个有效的字节，剩下的192个字节无效。如果把
这个文件的存储方式看作是一个链状的结构，它的结构如图1-4所示。
/home/user/test.dat
Sector 1000-1007
Sector 2000-2007
4096 Bytes
3904 Byles
图1-4文件在磁盘中的结构
这里我们先穿括一个关于硬盘的结构介绍，关于硬盘结构可能很多读者已经有一个大
概的了解，那就是硬盘基本存储单位为扇区（Sector），每个扇区一般为512字节。一
程序员的自我修养一链接、装载与库
---
## Page 36
1.4操作系统做什么
13
个硬盘往往有多个盘片，每个盘片分两面，每面按照同心圆划分为若干个磁道，每个
磁道划分为若干个扇区。比如一个硬盘有2个盘片，每个盘面分65536磁道，每个磁
137 438953472字节（128GB1。但是我们可以想象，每个盘面上同心圆的周长不
样，如果按照每个磁道都拥有相同数量的扇区，那么靠近盘面外围的础道密度肯定比
内图更加稀疏，这样是比较浪费空间的。但是如果不同的磁道扇区数又不同，计算起
来就十分麻烦。为了屏藏这些复杂的硬件细节，现代的硬盘善遍使用一种叫做LBA
（Logical Block Address）的方式，即整个硬虚中所有的扇区从O开始编号，一直到
最后一个扇区，这个扇区编号叫做逻辑扇区号。遂辑扇区号抛弃了所有复杂的磁道、
盘面之类的概念。当我们给出一个逻辑的扇区号时，硬盘的电子设备会将其转换成实
际的盘面、磁道等这些位置。
文件系统保存了这些文件的存储结构，负责维护这些数据结构并且保证磁盘中的扇区能
够有效地组织和利用，那么当我们在Linux操作系统中，要读取这个文件的前4096个字节
时，我们会使用一个read的系统调用来实现。文件系统收到read请求之后，判断出文件的
前4096个字节位于磁盘的1000号逻辑扇区到1007号逻辑扇区。然后文件系统就向硬盘驱
动发出一个读取逻辑扇区为1000号开始的8个扇区的请求，磁盘驱动程序收到这个请求以
后就向硬盘发出硬件命令。向硬件发送UO命令的方式有很多种，其中最为常见的一种就是
通过读写IO端口寄存器米实现。在x86平台上，共有65536个硬件端口寄存器，不同的
对硬件端口的读和写。
对IDE接口来说，它有两个通道，分别为IDE0和IDEI，每个通道上可以连接两个设
备，分别为Master 和 Slave，一个PC中最多可以有4个IDE设备。假设我们的文件位于IDE0
的Master硬盘上，这也是正常情况下硬盘所在的位置。在PC中，IDEO通道的LO端口地
址是0x1F0~0xIF7及0x376~0x377.通过读写这些端口地址就能与IDE硬盘进行通信.这
些端口的作用和操作方式十分复杂，我们以实现读取1000号逻辑扇区开始的8个扇区为例：
·第0xIF3~0x1F64个字节的端口地址是用来写入LBA地址的，那么1000号逻辑扇区
的LBA地址为0x000003E8，所以我们需要往0x1F3、0x1F4写入0x00.往0x1F5写入
0x03，往0x1F6 写入0xE8.
·0x1F2这个地址用来写入命令所需要读写的扇区数。比如读取8个扇区即写入8。
·0x1F7这个地址用来写入要执行的操作的命令码，对于读取操作来说，俞令字为0x20，
所以我们要执行的指令为：
out 0×1F3, 0x00
out 0×1F4,
out 0x1F5,
00x0
out 0x1F6, 0xE8
0x03
程序员的自我修养一链接、装载与库
---
## Page 37
14
第1章湿放而知新
out 0x1F2, 0x08
out 0x1F7, 0x20
在硬盘收到这个命令以后，它就会执行相应的操作，并且将数据读取到事先设置好的内
存地址中（这个内存地址也是通过类似的命令方式设置的）。当然这里的例子中只是最简单
的情况，实际情况比这个复杂得多，驱动程序须要考虑硬件的状态（是否忙绿或读取错误）、
调度和分配各个请求以达到最高的性能等。
1.5内存不够怎么办
上面一节中我们提到了进程的概念，选程的总体目标是希梁每个进程从逻辑上来看都可
以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间很好地共享，
从进程的角度看好像是它独占了CPU而不用考虑与其他进程分享CPU的事情。操作系统的
IO抽象模型也很好地实现了VO设备的共享和抽象，那么唯一剩下的就是主存，也就是内
存的分配同题了。
在早期的计算机中，程序是直接运行在物理内存上的，也就是说，程序在运行时所访问
的地址都是物理地址。当然，如果一个计算机同时只运行一个程序，那么只要程序要求的内
存空间不要超过物理内存的大小，就不会有问题。但事实上为了更有效地利用硬件资源，我
们必须同时运行多个程序，正如前面的多道程序、分时系统和多任务中一样，当我们能够同
时运行多个程序时，CPU的利用率将会比较高。那么很明显的一个间题是，如何将计算机
上有限的物理内存分配给多个程序使用。
假设我们的计算机有128MB内存，程序A运行需要10MB，程序B需要100MB，程
序C需要20MB。如果我们需要同时运行程序A和B，那么比较直接的做法是将内存的前
10MB分配给程序A，10MB~110MB分配给B。这样就能够实现A和B两个程序同时运
行，但是这种简单的内存分配策略问题很多。
·地址空间不隔离所有程序都直接访问物理地址，程序所使用的内存空间不是相互隔
离的。恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的：有些非
恶意的、但是有臭虫的程序可能不小心修改了其他程序的数据，就会使其他程序也期
溃，这对于需要安全稳定的计算环境的用户来说是不能容忍的。用户希望他在使用计
算机的时候，其中一个任务失败了，至少不会影响其他任务。
·内存使用效率低由于没有有效的内存管理机制。通常需要一个程序执行时，监控程
序就将整个程序装入内存中然后开始执行。如果我们忽然需要运行程序C，那么这时
内存空间其实已经不够了，这时候我们可以用的一个办法是将其他程序的数据暂时写
到磁盘里面，等到需要用到的时候再读回米。由于程序所需要的空间是连续的，那么
这个例子里面，如果我们将程序A换出到磁盘所释放的内存空间是不够的，所以只能
程序员的自我修养一链接、装载与库
---
## Page 38
1.5内存不够怎么办
15
将B换出到磁盘，然后将C读入到内存开始运行。可以看到整个过程中有大量的数据
在换入换出，导致效率十分低下。
·程序运行的地址不确定因为程序每次需要装入运行时，我们都需要给它从内存中分配
一块足够大的空闲区域，这个空闲区域的位置是不确定的。这给程序的编写造成了一定
的麻烦，因为程序在编写时，它访问数据和指令跳转时的目标地址很多都是固定的，这
涉及程序的重定位问题，我们在第2部分和第3部分还会详细探讨重定位的间题。
解决这儿个问题的思路就是使用我们前文提到过的法宝：增加中间层，即使用一种间接
的地址访问方法。整个想法是这样的，我们把程序给出的地址看作是一种虚拟地址（Virtual
Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。这样，只
要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能
够访间的物理内存区域跟另外个程序相互不重叠，以达到地址空间隔离的效果，
1.5.1关于隔离
让我们回到程序的运行本质上米。用户程序在运行时不希望介入到这些复杂的存储器管
理过程中，作为普通的程序，它需要的是一个简单的执行环境，有一一个单一的地址空间、有
白已的CPU，好像整个程序占有整个计算机而不用关心其他的程序（当然程序间通信的部
分除外，因为这是程序主动要求跟其他程序通信和联系）。所谓的地址空间是个比较抽象的
概念，你可以把它想象成一个很大的数组，每个数组的元素是一个字节，而这个数组大小由
地址空间的地址长度决定，比如32位的地址空间的大小为2^32=429496729字节，即
4GB，地址空间有效的地址是0~4294967295，用十六进制表示就是0x00000000~
OxFFFFFFFF。地址空间分两种：虚拟地址空间（Virtual Address Space）和物理地址空间
（Physical Address Space）。物理地址空间是实实在在存在的，存在于计算机中，而且对于每
一台计算机来说只有唯一的一个，你可以把物理空间想象成物理内存，比如你的计算机用的
是Intel的Pentium4的处理器，那么它是32位的机器，即计算机地址线有32条（实际上是
36条地址线，不过我们暂时认为它只是32条），那么物理空间就有4GB，但是你的计算机
上只装了512MB的内存，那么其实物理地址的真正有效部分只有0x00000000～
0xIFFFFFFF，其他部分都是无效的（实际上还有一些外部VO设备映射到物理空间的，也
是有效的，但是我们暂时无视其存在）。虚拟地址空间是指虚拟的、人们想象出来的地址空
间，其实它并不存在，每个进程都有自己独立的虚拟空间，而且每个进程只能访问白己的地
址空间，这样就有效地做到了进程的隔离。
1.5.2分段（Segmentation）
最开始人们使用的是一种叫做分段（Segmentation）的方法，基本思路是把一段与程
程序员的自我修养一链接、装载与库
---
## Page 39
16
第1章湿故而知新
序所需要的内存空间大小的虚拟空间映射到某个地址空间，比如程序A需要10MB内存，
那么我们假设有一个地址从0x00000000到0x00A00000的10MB大小的一个假象的空间，
也就是虚拟空间，然后我们从实际的物理内存中分配一个相同大小的物理地址，假设是物
理地址0x00100000开始到0x00B00000结束的一块空间。然后我们把这两块相间大小的地
址空间一一映射，即虚拟空间中的每个字节相对应于物理空间中的每个字节，这个映射过
程由软件来设置，比如操作系统来设置这个映射函数，实际的地址转换由硬件完成。比如
当程序A中访问地址0x00001000时，CPU会将这个地址转换成实际的物理地址
0x00101000.那么比如程序A和程序B在运行时，它们的虚拟空间和物理空间映射关系
可能如图1-5所示。
0x06400000 
0x0700000
 Virtual Address
Space of B
Address Space
Physical
100MB
of B
0x00000000
Ox00A000Virtual Addres
0x0OC00000
Ox0000oo L _Space of A_
Physical Address0x00B0000
0x00100000
10MB
0x00000000