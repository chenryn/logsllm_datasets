#ifndef 标识符
elif 部分:
elif 行 文本 elif 部分 opt elif 行:
#elif 常量表达式
else 部分:
else 行 文本
else 行:
#else
附录B 标准库
本附录总结了 ANSI 标准定义的函数库。标准库不是 C 语言本身的构成部分，但是支持 标准 C 的实现会提供该函数库中的函数声明、类型以及宏定义。在这部分内容中，我们省略 了一些使用比较受限的函数以及一些可以通过其它函数简单合成的函数，也省略了多字节字 符的内容，同时，也不准备讨论与区域相关的一些属性，也就星与本地语言、国籍或文化相 关的属性。
标准库中的函数，类型以及宏分别在下面的标准头文件中定义:
可以通过下列方式访问头文件:
#include 
头文件的包含顺序是任意的，并可包含任意多次。头文件必须被包含在任何外部声明或 定义之外，并且，必须在使用头文件中的任何声明之前包含头文件。头文件不一定是一个源 文件。
以下划线开头的外部标识符保留给标准库使用，同时，其它所有以一个下划线和一个大 写字母开头的标识符以及以两个下划线开头的标识符也都保留给标准库使用。
B.1 输入与输出:
头文件中定义的输入和输出函数、类型以及宏的数目几乎占整个标准库的三 分之一。
流(stream)是与磁盘或其它外围设备关联的数据的源或目的地。尽管在某些系统中(如 在著名的 UNIX 系统中)，文本流和二进制流是相同的，但标准库仍然提供了这两种类型的流。 文本流是由文本行组成的序列，每一行包含 0 个或多个字符，并以'\n' 结尾。在某些环境中， 可能需要将文本流转换为其它表示形式(例如把'\n'映射成回车符和换行符)，或从其它表示 形式转换为文本流。二进制流是由未经处理的字节构成的序列，这些字节记录着内部数据， 并具有下列性质:如果在同一系统中写入二进制流，然后再读取该二进制流，则读出和写入 的内容完全相同。
打开一个流，将把该流与一个文件或设备连接起来，关闭流将断开这种连接，打开一个 文件将返回一个指向 FILE 类型对象的指针，该指针记录了控制该流的所有必要信息，在不引 起歧义的情况下，我们在下文中将不再区分"文件指针"和"流"。
程序开始执行时，stdin、stdout 和 stderr 这 3 个流已经处于打开状态。
B.1.1                 文件操作
下列函数用于处理与文件有关的操作。其中，类型 size_t 是由运算符 sizeof 生成的 无符号整型。
FILE *fopen(const char *filename, const char *mode)
fopen 函数打开 filename 指定的文件，并返回一个与之相关联的流。如果打开操作失 败，则返回 NULL。
访问模式 mode 可以为下列合法值之一:
"r"             打开文本文件用于读
"w"             创建文本文件用于写，并删除已存在的内容(如果有的话)
"a"             追加;打开或创建文本文件，并向文件末尾追加内容
"r+"             打开文本文件用于更新(即读和写)
"w+"             创建文本文件用于更新，并删除已存在的内容(如果有的话)
"a+"             追加;打开或创建文本文件用于更新，写文件时追加到文件末尾
后 3 种方式(更新方式)允许对同一文件进行读和写。在读和写的交叉过程中，必须调 用 fflush 函数或文件定位函数。如果在上述访问模式之后再加上 b，如“ rb"或“ w+b"等， 则表示对二进制文件进行操作。文件名 filename 限定最多为 FILENAME_MAX 个字符。一 次最多可打开 FOPEN_MAX 个文件。
FILE *freopen(const char *filename, const char *mode, FILE *stream) freopen 函数以 mode 指定的模式打开 filename 指定的文件，并将该文件关联到
stream 指定的流。它返回 stream;若出错则返回 NULL。Freopen 函数一般用于改变与
stdin、stdout 和 stderr 相关联的文件。
int fflush(FILE *stream)
对输出流来说，fflush 函数将已写到缓冲区但尚未写入文件的所有数据写到文件中。对 输入流来说，其结果是未定义的。如果在写的过程中发生错误，则返回 EOF，否则返回 0。 fflush(NULL)将清洗所有的输出流。
int fclose(FILE *stream)
fclose 函数将所有未写入的数据写入 stream 中，丢弃缓冲区中的所有未读输入数据， 并释放自动分配的全部缓冲区，最后关闭流。若出错则返回 EOF，否则返回 0。
int remove(const char *filename)
remove 函数删除 filename 指定的文件，这样，后续试图打开该文件的操作将失败。 如果删除操作失败，则返回一个非 0 值。
int rename(const char *oldname, const char *newname) rename 函数修改文件的名字。如果操作失败，则返回一个非 0 值。
FILE *tmpfile(void)
tmpfile 函数以模式"wb+"创建一个临时文件，该文件在被关闭或程序正常结束时将被 自动删除。如果创建操作成功，该函数返回一个流;如果创建文件失败，则返回  NULL。
char *tmpnam(char s[L_tmpnam])
tmpnam(NULL)函数创建一个与现有文件名不同的字符串，并返回一个指向一内部静态 数组的指针。tmpnam(S)函数把创建的字符串保存到数组 s 中，并将它作为函数值返回。s 中至少要有 L_tmpnam 个字符的空间。Tmpnam 函数在每次被调用时均生成不同的名字。在 程序执行的过程中，最多只能确保生成 TMP_MAX 个不同的名字。注意，tmpnam 函数只是用 于创建一个名字，而不是创建一个文件。
int setvbuf(FILE *stream, char *buf, int mode, size_t size)
setvbuf 函数控制流 stream 的缓冲。在执行读、写以及其它任何操作之前必须调用此 函数。当 mode 的值为_IOFBF 时，将进行完全缓冲。当 mode 的值为_IOLBF 时，将对文本 文件进行行缓冲，当 mode 的值为_IONBF 时，表示不设置缓冲。如果 buf 的值不是 NULL， 则 setvbuf 函数将 buf 指向的区域作为流的缓冲区，否则将分配一个缓冲区。size 决定缓 冲区的长度。如果 setvbuf 函数出错，则返回个一非 0 值。
void setbuf(FILE *stream, char *buf)
如果 buf 的值为 NULL ， 则关 闭流 stream 的缓冲 ;否 则 setbuf 函数等 价于
(void)setvbuf(stream, buf, _IOFBF, BUFSIZ)。
B.1.2               格式化输出
printf 函数提供格式化输出转换。
int fprintf(FILE *stream, const char *format, ...)
fprintf 函数按照 format 说明的格式对输出进行转换，并写到 stream 流中。返回值 是实际写入的字符数。若出错则返回一个负值。
格式串由两种类型的对象组成:普通字符(将被复制到输出流中)与转换说明(分别决 定下一后续参数的转换和打印)。每个转换说明均以字符%开头，以转换字符结束。在%与转换 字符之间可以依次包括下列内容:
             标志(可以以任意顺序出现)，用于修改转换说明
•             指定被转换的参数在其字段内左对齐
+             指定在输出的数前面加上正负号
空格 如果第一个字符不是正负号，则在其前面加上一个空格
0             对于数值转换，当输出长度小于字段宽度时，添加前导 0 进行填充
#                           指定另一种输出形式。如果为 o 转换，则第一个数字为零;如果为 x 或 X 转换， 则指定在输出的非 0 值前加 0x 或 0X;对于 e、E、f、g 或 G 转换，指定输出 总包括一个小数点;对于 g 或 G 转换，指定输出值尾部无意义的 0 将被保留
             一个数值，用于指定最小字段宽度。转换后的参数输出宽度至少要达到这个数值。 如果参数的字符数小于此数值，则在参数宽边(如果要求左对齐的话则为右边)填
充一些字符。填充字符通常为空格，但是，如果设置了 0 填充标志，则填充字符为 0。
             点号，用于分隔字段宽度和精度。
             表示精度的数。对于字符串，它指定打印的字符的最大个数;对于 e、E 或 f 转换， 它指定打印的小数点后的数字位数;对于 g 或 G 转换，它指定打印的有效数字位数;
对于整型数，它指定打印的数字位数(必要时可加填充位 0  以达到要求的宽度)。
·             长度修饰符 h、l 或 L。h 表示将相应的参数按 short 或 unsigned short 类型输
出。l 表示将相应的参数按 long 或 unsigned long 类型输出;L 表示将相应的参 数按 long double 类型输出。
宽度和精度中的任何一个或两者都可以用*指定，这种情况下，该值将通过转换下一个参 数计算得到(下一个参数必须为 int 类型)。
表 B•1 中列出了这些转换字符及其意义。如果%后面的字符不是转换字符，则其行为没有 定义。
表 B•1   printf 函数的转换字符
 转换字符              参数类型;转换结果
d
,
i             
 int;有符号十进制表示
o
 unsigned int;无符号八进制表示
x
,
X             
 unsigned int;无符号十六进制表示(没有前导 0x 或 0X)，如果是 0x，则使用 abcdef，如果是 0X，则使 用 ABCDEF
u
 int;无符号十进制表示
c
 int;转换为 unsigned char 类型后为一个字符
s
 char *;打印字符串中的字符，直到遇到'\0'或已打印了由精度指定的字符数
f
 double;形式为[•]mmm.ddd 的十进制表示，其中，d 的数目由精度确确定，默认精度为 6。精度为 0 时不输 出小数点
e
,
E             
 double;形式为[•]m.dddddd e ±xx 或[•]m.dddddd E ±xx。d 的数目由精度确定，默认精度为 6。精度为 0 时不 输出小数点
g
,
G             
 double;当指数小于•4 或大于等于精度时，采用%e 或%E 的格式，否则采用%f 的格式。尾部的 0 和小数点 不打印
p
 void *;打印指针值(具体表示方式与实现有关)
n
 int *;到目前为止，此 printf 调用输出的字符的数目将被写入到相应参数中。不进行参数转换
%
 不进行参数转换;打印一个符号%
int printf(const char *format, ...) printf(...)函数等价于 fprintf(stdout, …)。
int sprintf(char *s, const char *format, ...)
sprintf 函数与 printf 函数基本相同，但其输出将被写入到字符串 s 中，并以'\0' 结束。s 必须足够大，以足够容纳下输出结果。该函数返回实际输出的字符数，不包括'\0'。
int vprintf(const char *format, va_list arg)
int vfprintf(FILE *stream, const char *format, va_list arg) int vsprintf(char *s, const char *format, va_list arg)
vprintf、vfprintf、vsprintf 这 3 个函数分别与对应的 printf 函数等价，但它 们用 arg 代替了可变参数表。arg 由宏 va_start 初始化，也可能由 va_arg 调用初始化。 详细信息参见 B.7 节中对头文件的讨论。
B.1.3                格式化输入
scanf 函数处理格式化输入转换。
int fscanf(FILE *stream, const char *format, ...)
fscanf 函数根据格式串 format 从流 stream 中读取输入，并把转换后的值赋值给后 续各个参数，其中的每个参数都必须是一个指针。当格式串 format 用完时，函数返回。如 果到达文件的末尾或在转换输入前出错，该函数返回 EOF;否则，返回实际被转换并赋值的 输入页的数目。
格式串 format 通常包括转换说明，它用于指导对输入进行解释。格式字符串中可以包 含下列页目:
             空格或制表符
             普通字符(%除外)，它将与输入流中下一个非空白字符进行匹配
             转换说明，由一个%、一个赋值屏蔽字符*(可选)、一个指定最大字段宽度的数(可 选)、一个指定目标字段宽度的字符(h、l 或    L)(可选)以及一个转换字符组成。
转换说明决定了下一个输入字段的转换方式。通常结果将被保存在由对应参数指向的变 量中。但是，如果转换说明中包含赋值屏蔽字符*，例如%*s，则将跳过对应的输入字段，并 不进行赋值。输入字段时一个由非空白符字符组成的字符串，当遇到下一个空白符或达到最 大字段宽度(如果有的话)时，对当前输入字段的读取结束。这意味着，scanf 函数可以跨 越行的边界读取输入，因为换行符也是空白符(空白符包括空格、横向制表符、纵向制表符、 换行符、回车符和换页符)。