title:Cache Cookies for Browser Authentication (Extended Abstract)
author:Ari Juels and
Markus Jakobsson and
Tom N. Jagatic
Cache Cookies for Browser Authentication
(Extended Abstract)
Ari Juels
RSA Laboratories and
RavenWhite Inc.
Markus Jakobsson
Indiana University and
RavenWhite Inc.
Tom N. Jagatic
Indiana University
PI:EMAIL
PI:EMAIL
PI:EMAIL
Abstract
Like conventional cookies, cache cookies are data ob-
jects that servers store in Web browsers. Cache cookies,
however, are unintentional byproducts of protocol design
for browser caches. They do not enjoy any explicit inter-
face support or security policies.
In this paper, we show that despite limitations, cache
cookies can play a useful role in the identiﬁcation and
authentication of users. Many users today block conven-
tional cookies in their browsers as a privacy measure.
The cache-cookie tools we propose can help restore lost
usability and convenience to such users while maintain-
ing good privacy. As we show, our techniques can also
help combat online security threats such as phishing and
pharming that ordinary cookies cannot. The ideas we
introduce for cache-cookie management can strengthen
ordinary cookies as well.
The full version of this paper may be referenced at
www.ravenwhite.com.
Keywords: cache cookies, personalization, malware,
pharming, phishing, privacy, Web browser
1
Introduction
A conventional cookie is a piece of data stored in a
specially designated cache in a Web browser. Cookies
can include user-speciﬁc identiﬁers or personal informa-
tion (e.g., this user is over 18 years of age). Servers
typically employ cookies to personalize Web pages. For
example, when Alice visits the Web site X, the domain
server for X might place a cookie in Alice’s browser
that contains the identiﬁer “Alice.” When Alice visits
X again, her browser releases this cookie, enabling the
server to identify her automatically.
A cache cookie, by contrast, is not an explicit browser
feature. It is a form of persistent state in a browser that
a server can access in unintended ways. There are many
different forms of cache cookies; they are byproducts of
the way that browsers maintain various caches and access
their contents.
For example, one type of cache cookie, which we be-
lieve to be new to the literature and focus on here, is based
on Temporary Internet Files (TIFs). TIFs are data objects
– such as images – cached locally in standard browsers.
Their function is to accelerate browsing speeds: If the
browser is to display a data object present as a TIF, it
can access the object locally, rather than pulling it from a
server. TIFs can be turned into cache cookies, i.e., persis-
tent, server-accessible data objects. By caching a particu-
lar TIF X associated with its domain, a server effectively
writes a bit into the browser of a particular user. By caus-
ing a client to display a Web page containing X, and then
seeing whether the client requests X, the server can de-
termine if X is present as a TIF in the client’s browser.
Thus by testing for the presence or absence of TIF X, a
server can read a bit from the browser.
A cache cookie can function very much like an ordi-
nary cookie. It is common for servers to plant cookies
containing secret values in the browsers of users. These
cookies help a server authenticate a user – or, more pre-
cisely, her browser. Cache cookies, as we show, can serve
much the same goal.
1.1 Our work: Cache cookies as authen-
ticators
Cookies were designed not for authentication, but as
a convenient way to pass state. They have been co-opted
in many systems to achieve security goals, chieﬂy as au-
thenticators to supplement passwords. We take the same
approach to cache cookies: We co-opt them for the unin-
tended beneﬁts of user identiﬁcation and authentication.
Because cookies (and similar sharable objects) are
fully accessible by the domain that set them, they are vul-
nerable to pharming. A pharming attack creates an envi-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:52 UTC from IEEE Xplore.  Restrictions apply. 
ronment in which a browser directed to the Web server
legitimately associated with a particular domain instead
connects to a spoofed site. A pharmer can then harvest
the browser-cached objects associated with the attacked
domain. Even SSL offers only modest protection against
such cookie harvesting. A pharmer can use an incorrect
certiﬁcate and simply rely on users’ tendency to disregard
browser warnings.1 But a pharmer can use an incorrect
certiﬁcate and simply rely on the tendency of users to dis-
regard browser warnings.
We show how to use cache cookies in ways that do
not rely on server domains and can therefore resist many
pharming attacks. The basis for our work is a new con-
ceptual framework in which cache cookies underpin a
general, virtual memory structure within a browser. We
refer to this type of structure as cache-cookie memory,
abbreviated CC-memory.
A key feature of CC-memory is that it spans a huge
space.
It is a virtually addressed memory structure,
not a physically addressed one. Thus its size is expo-
nential in the bit-length of browser resource names like
URLs. So large is the space of CC-memory in a browser
that a server can only access a negligible portion, and
an attacker cannot feasibly read more than a negligi-
ble portion of CC-memory. We propose new techniques
for privacy-enhanced identiﬁers and user-authentication
protocols that resist brute-force attacks against browser
caches. Importantly, our techniques require no special-
purpose client-side software.
1.2 Related work
While we emphasize the use of cache cookies for au-
thentication in this paper, most of the literature thus far
has treated cache cookies purely in light of their threat to
privacy.
Felten and Schneider ﬁrst brought the problems of in-
vasive cache cookies to light [2], and indeed ﬁrst coined
the term “cache cookies.” They showed how a server can
detect the presence of a given image ﬁle in a browser
cache, and thus use cached images as cache cookies.
Their techniques are based on timing analysis, however,
and somewhat difﬁcult to implement.
Clover [1], however, brought
to light more eas-
ily manipulated cache cookies based on browser his-
tories. A side-effect in Cascading Style Sheets (CSS)
(a framework for presenting Web content) permits a
server
to embed code in a Web page that deter-
mines whether or not a browser contains a particu-
1It is generally difﬁcult for a pharmer to obtain the private key cor-
responding to a legitimate SSL certiﬁcate for a domain under attack.
Pharmers have been known to obtain fraudulent certiﬁcates, however
[4]. And in principle a pharmer dupe a user to installing an invalid
certiﬁcate in her browser.
lar URL in its history. For example, any server can
determine if Alice has visited the speciﬁc Web page
www.arbitrarysite.com/randompath/index.html. Addi-
tionally, a server can effectively write a URL X into the
browser history of a client by directing the client to the
URL X (in, e.g., an invisible frame). Thus, browser-
history entries can function as cache cookies.
A related, common form of tracking used by mar-
keters today is what is known as a “Web bug,” a client-
speciﬁc HTML link to an (invisible) image in e-mail. By
downloading the image, a client alerts a server to the
opening of the e-mail. Web bugs can also be planted in
Web pages.
More recently, Jackson et al. [3] examine the privacy
impact of cache cookies and related browser features, and
present a uniﬁed view of cross-domain tracking threats
to users. They also identify new facets to cache cook-
ies, such as entity tags (Etags), which we discuss below.
Jackson et al. propose browser extensions to enforce con-
sistent privacy policies across a range of cross-domain
tracking methods.
Again, our emphasis in this paper is on the positive
face of cache cookies. We propose ways to use cache
cookies beneﬁcially without exacerbating existing pri-
vacy problems.
Organization: In section 2, we present our framework
for CC-memory, along with some new implementation
options. We introduce schemes for user identiﬁcation and
authentication in section 3. We present supporting exper-
iments in section 4, and conclude in section 5.
2 Cache-Cookie Memory Management
We now explain how to construct CC-memory struc-
tures. As explained above, CC-memory is a general
read/write memory structure in a user’s browser. We use
cache cookies based on TIFs as an illustrative example,
but the same principles apply straightforwardly to other
types of cache cookies.
A server can, of course, plant any of a wide variety
of TIFs by giving them appropriate URLs. For exam-
ple, a server operating the domain www.arbitrarysite.com
can plant
in a browser a GIF with the URL
“www.arbitrarysite.com/Z.gif,” where Z can be any
URL-compliant string. Thus, a server can create a
CC-memory structure over the space of URLs of the
form, e.g., “www.arbitrarysite.com/Z.gif”, where Z ∈
{0, 1}l+1.
In other words, Z is an index into the CC-
memory space.
In practice, this virtual-memory space
can be enormous – larger than a cryptographic key space.
(Current versions of IE, for instance, support 2048-bit
URL paths.)
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:52 UTC from IEEE Xplore.  Restrictions apply. 
When l is sufﬁciently large – in practice when cache
cookies are 80 or so bits long – CC-memory is large
enough to render brute-force search by browser snifﬁng
impractical. Suppose, for example, that a server plants a
secret, k-bit string x = x0x1 . . . xk into a random loca-
tion in CC-memory of the browser of a given user. It is
infeasible for a second server interacting with the user to
learn x — or even to detect its presence. A server can
thus hide cache cookies from adversaries. As we explain
in the full paper, CC-memory can assume any of a vari-
ety of virtual memory structures, and can support not just
reading and writing, but also erasure and re-writing.
TIF-based cache cookies: As explained above, Tempo-
rary Internet ﬁles (TIFs) are ﬁles containing objects, e.g.,
images embedded in Web pages. Browsers cache these
ﬁles to support faster display when a user revisits a Web
page. TIFs have no associated expiration, but browsers
cap the disk space devoted to TIFs and delete them to
maintain this cap. Thus TIF persistence varies among
users.
To place a TIF X in a browser cache, a server can
serve content that causes downloading of X. It can ver-
ify whether or not a browser contains X in its cache by
displaying a page containing X. If X is not present in
its cache, then the browser will request it; otherwise,
the browser will not pull X, but instead retrieve its local
copy. In order not to change the state of a cache cookie
for whose presence it is testing, a server must in the for-
mer case withhold X. This triggers a “401” error, but
manipulation of TIFs can occur in hidden windows, un-
perceived by users.
Cache cookies based on TIFs restrict read privileges, a
useful privacy feature. When a browser requests a TIF X,
it sends a request to the domain associated with X, not to
the server displaying content containing X. Thus TIF-
based cache cookies are like ﬁrst-party cookies: Only the
site in control of the domain for X can detect the presence
of X in a browser cache. (Cross-domain timing attacks
[2] can undermine the ﬁrst-party property for TIFs, but
are challenging to mount.)
A notable limitation of TIFs is that they cannot be ma-
nipulated over SSL. As a security measure, HTTPS ses-
sions do not cache information on disk.
C-memory: Conventional cookies have optionally as-
sociated paths. A cookie with associated path P is re-
leased only when the browser in which it is resident re-
quests a URL with preﬁx P . For example, a cookie
set with the path “www.arbitrarysite.com/X” would only
be released when the browser visits a URL of the form
“www.arbitrarysite.com/X/...”. Using paths, it is possi-