## eBPF漏洞CVE-2021-3490分析与利用
### 漏洞分析
​
verifier为了跟踪每一个寄存器的边界值（防止越界读写），会对寄存器的每一次运算模拟求解边界值（最大/最小值），由于寄存器是64bits，但是实际参与运算可能是32bits，因此实际会对32/64都进行边界校验，由`adjust_scalar_min_max_vals`和`adjust_reg_min_max_vals`函数完成
    /* WARNING: This function does calculations on 64-bit values, but the actual
     * execution may occur on 32-bit values. Therefore, things like bitshifts
     * need extra checks in the 32-bit case.
     */
    static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
                          struct bpf_insn *insn,
                          struct bpf_reg_state *dst_reg,
                          struct bpf_reg_state src_reg)
    {
        struct bpf_reg_state *regs = cur_regs(env);
        u8 opcode = BPF_OP(insn->code);
        ...
        switch (opcode) {
        case BPF_ADD:
            ret = sanitize_val_alu(env, insn);
            if (ret var_off = tnum_add(dst_reg->var_off, src_reg.var_off);
            break;
        case BPF_SUB:
            ret = sanitize_val_alu(env, insn);
            if (ret var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);
            break;
        case BPF_MUL:
            dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);
            scalar32_min_max_mul(dst_reg, &src_reg);
            scalar_min_max_mul(dst_reg, &src_reg);
            break;
        case BPF_AND:
            dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);
            scalar32_min_max_and(dst_reg, &src_reg);
            scalar_min_max_and(dst_reg, &src_reg);
            break;
        case BPF_OR:
            dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);
            scalar32_min_max_or(dst_reg, &src_reg);
            scalar_min_max_or(dst_reg, &src_reg);
            break;
        case BPF_LSH:
            if (umax_val >= insn_bitness) {
                /* Shifts greater than 31 or 63 are undefined.
                 * This includes shifts by a negative number.
                 */
                mark_reg_unknown(env, regs, insn->dst_reg);
                break;
            }
            if (alu32)
                scalar32_min_max_lsh(dst_reg, &src_reg);
            else
                scalar_min_max_lsh(dst_reg, &src_reg);
            break;
        case BPF_RSH:
            if (umax_val >= insn_bitness) {
                /* Shifts greater than 31 or 63 are undefined.
                 * This includes shifts by a negative number.
                 */
                mark_reg_unknown(env, regs, insn->dst_reg);
                break;
            }
            if (alu32)
                scalar32_min_max_rsh(dst_reg, &src_reg);
            else
                scalar_min_max_rsh(dst_reg, &src_reg);
            break;
        case BPF_ARSH:
            if (umax_val >= insn_bitness) {
                /* Shifts greater than 31 or 63 are undefined.
                 * This includes shifts by a negative number.
                 */
                mark_reg_unknown(env, regs, insn->dst_reg);
                break;
            }
            if (alu32)
                scalar32_min_max_arsh(dst_reg, &src_reg);
            else
                scalar_min_max_arsh(dst_reg, &src_reg);
            break;
        default:
            mark_reg_unknown(env, regs, insn->dst_reg);
            break;
        }
        /* ALU32 ops are zero extended into 64bit register */
        if (alu32)
            zext_32_to_64(dst_reg);
        __update_reg_bounds(dst_reg);
        __reg_deduce_bounds(dst_reg);
        __reg_bound_offset(dst_reg);
        return 0;
    }
漏洞就出现在32bit的`BPF_AND`/`BPF_OR`/`BPF_XOR`运算上
    static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
                     struct bpf_reg_state *src_reg)
    {
        bool src_known = tnum_subreg_is_const(src_reg->var_off);
        bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
        struct tnum var32_off = tnum_subreg(dst_reg->var_off);
        s32 smin_val = src_reg->s32_min_value;
        u32 umax_val = src_reg->u32_max_value;
        /* Assuming scalar64_min_max_and will be called so its safe
         * to skip updating register for known 32-bit case.
         */
        if (src_known && dst_known)
            return;
        ...
    }
上面的代码说明当32bit
源寄存器和目的寄存器的值都是`known`的时候，就不更新32bit的边界值。注释说明在这种情况下`scalar64_min_max_and`会处理。
    static void scalar_min_max_and(struct bpf_reg_state *dst_reg,
                       struct bpf_reg_state *src_reg)
    {
        bool src_known = tnum_is_const(src_reg->var_off);
        bool dst_known = tnum_is_const(dst_reg->var_off);
        s64 smin_val = src_reg->smin_value;
        u64 umax_val = src_reg->umax_value;
        if (src_known && dst_known) {
            __mark_reg_known(dst_reg, dst_reg->var_off.value &
                          src_reg->var_off.value);
            return;
        }
        ...
    }
在64bit边界值校验中，在源和目的寄存器都是`known`的情况下，会调用`__mark_reg_known`函数。
但是这里有一个区别
  * 在scalar32_min_max_and中用的tnum_subreg_is_const校验寄存器的低32位是否是known；
  * 在scalar_min_max_and中用的tnum_is_const校验寄存器的64位是否是known
这里就有一个例外的情况，即一个reg的低32位是`known`，高32位是`unknown`。在这种情况下，__mark_reg32_known函数没有被调用，该函数会将寄存器的低32位设置为常数。
    static void __mark_reg32_known(struct bpf_reg_state *reg, u64 imm)
    {
        reg->var_off = tnum_const_subreg(reg->var_off, imm);
        reg->s32_min_value = (s32)imm;
        reg->s32_max_value = (s32)imm;
        reg->u32_min_value = (u32)imm;
        reg->u32_max_value = (u32)imm;
    }
在adjust_scalar_min_max_vals函数返回前，调用了下面三个函数更新寄存器的边界值
    __update_reg_bounds(dst_reg);
        __reg_deduce_bounds(dst_reg);
        __reg_bound_offset(dst_reg);
        return 0;
它们都有32/64两种实现，漏洞出现在32的实现中，我们只关注这一部分。
__update_reg32_bounds函数根据`reg.var_off`计算边界值
  * 最小值：当前寄存器的最小值/已知的常数值（known）
  * 最大值：当前寄存器的最大值/已知的常数值（known）
    static void __update_reg32_bounds(struct bpf_reg_state *reg)
    {
        struct tnum var32_off = tnum_subreg(reg->var_off);
        /* min signed is max(sign bit) | min(other bits) */
        reg->s32_min_value = max_t(s32, reg->s32_min_value,
                var32_off.value | (var32_off.mask & S32_MIN));
        /* max signed is min(sign bit) | max(other bits) */
        reg->s32_max_value = min_t(s32, reg->s32_max_value,
                var32_off.value | (var32_off.mask & S32_MAX));
        reg->u32_min_value = max_t(u32, reg->u32_min_value, (u32)var32_off.value);
        reg->u32_max_value = min(reg->u32_max_value,
                     (u32)(var32_off.value | var32_off.mask));
    }
使用`signed`的最大/小值订正`unsigned`的边界值；反之也可以
    /* Uses signed min/max values to inform unsigned, and vice-versa */
    static void __reg32_deduce_bounds(struct bpf_reg_state *reg)
    {
        /* Learn sign from signed bounds.
         * If we cannot cross the sign boundary, then signed and unsigned bounds
         * are the same, so combine.  This works even in the negative case, e.g.
         * -3 ss32_min_value >= 0 || reg->s32_max_value s32_min_value = reg->u32_min_value =
                max_t(u32, reg->s32_min_value, reg->u32_min_value);
            reg->s32_max_value = reg->u32_max_value =
                min_t(u32, reg->s32_max_value, reg->u32_max_value);
            return;
        }
        /* Learn sign from unsigned bounds.  Signed bounds cross the sign
         * boundary, so we must be careful.
         */
        if ((s32)reg->u32_max_value >= 0) {
            /* Positive.  We can't learn anything from the smin, but smax
             * is positive, hence safe.
             */
            reg->s32_min_value = reg->u32_min_value;
            reg->s32_max_value = reg->u32_max_value =
                min_t(u32, reg->s32_max_value, reg->u32_max_value);
        } else if ((s32)reg->u32_min_value s32_min_value = reg->u32_min_value =
                max_t(u32, reg->s32_min_value, reg->u32_min_value);
            reg->s32_max_value = reg->u32_max_value;
        }
    }
最后，调用`__reg_bound_offset`更新`var_off`。
    /* Attempts to improve var_off based on unsigned min/max information */
    static void __reg_bound_offset(struct bpf_reg_state *reg)
    {
        struct tnum var64_off = tnum_intersect(reg->var_off,
                               tnum_range(reg->umin_value,
                                  reg->umax_value));
        struct tnum var32_off = tnum_intersect(tnum_subreg(reg->var_off),
                            tnum_range(reg->u32_min_value,
                                   reg->u32_max_value));
        reg->var_off = tnum_or(tnum_clear_subreg(var64_off), var32_off);
    }
  * `tnum_range`根据给定的`[umin_value, umax_value]`范围值，返回一个`tnum`
  * `tnum_intersect`将两个已知的`tnum`合并为1个`tnum`（区间合并，取交集）
这里可以举一个实例以助理解上述过程存在的问题。
    R2.var_off = {mask = 0xffffffff00000000, value = 0x01}; 即低32bits是known, 高32bits unkown.
                    1
    R3.var_off = {mask = 0x0, value = 0x100000002}; 即整个64bits是known的，值为0x100000002;
对于`BPF_AND(R2, R3)`运算，R2的边界值变化如下
  * `tnum_and`
        u64 alpha = r2.mask | r2.value = 0xffffffff00000001
    u64 beta  = r3.mask | r3.value = 0x100000002
    u64 v = r2.value & r3.value
    ret = TNUM(v, alpha & beta & ~v)
    ret = {mask = 0x100000000, value = 0x0}
R2.var_off = {mask = 0x100000000, value = 0x0}
  * `scalar32_min_max_and`不会更改R2的边界值，这是因为R2和R3的低32bit都是`known`
  * `__update_reg32_bounds`
        R2.u32_min_value = R2.u32_max_value = 1;      // 进入函数前的常数值
    // 进入函数之后
    u32_min_value = max_t(u32, reg->u32_min_value, (u32)var32_off.value)
                = max(1, 0) = 1;
    u32_max_value = min(reg->u32_max_value,
                   (u32)(var32_off.value | var32_off.mask));
                = min(1, 0) = 0;
    对于s32_min_value/max_value也是一样的
  * 接下来的`__reg32_deduce_bounds`和`__reg_bound_offset`不会对R2的边界值产生影响
即在这种情况下我们得到的 **R2最小值是1，最大值是0**.
这显然是不合理的，而根本原因就在于在`scalar32_min_max_and`函数中，没有调用`__mark_reg32_known`更新u/s32_min/max_value，这也是后来的[fix方案](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/patch/?id=10d2bb2e6b1d8c4576c56a748f697dbeb8388899)