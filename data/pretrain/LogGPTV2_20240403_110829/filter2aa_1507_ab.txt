• The Hush is based off the NRF528322
• Cortex M4, 512KB flash, 64KB ram
• Basically supercharged NRF58122
• We can easily locate things that weren’t 
on the dongle…
• …and things that were
• The Hush has working SWD test points
• Thanks to this, we can just dump the 
firmware over SWD
Lovense Hush: hardware
Power
Motor
Antenna
Charger port
SWD test points
• Quick RE confirms no JSON parser 
• Only “simple” commands, but a lot of them
• Searching for “DFU” turns up two things
• “DFU;” command handler, as expected
• “DfuTarg” string in bootloader region
• “DfuTarg” is used the same as “LVS-Z001”
• Makes it look like it’s the bootloader’s BLE 
DFU mode
Lovense Hush: firmware
add
r1, pc, #0xe8 ; (adr r1, "DfuTarg")
bic.w
r0, r0, #0xf
adds
r0, r0, #1
bic.w
r0, r0, #0xf0
adds
r0, #0x10
strb.w r0, [sp, #8]
movs
r2, #7
add
r0, sp, #8
svc    0x7c
add
r1, pc, #0x58 ; (adr r1, "LVS-Z001")
bic.w
r0, r0, #0xf
adds
r0, r0, #1
bic.w
r0, r0, #0xf0
adds
r0, #0x10
strb.w r0, [sp, #8]
movs
r2, #8
add
r0, sp, #8
svc 0x7c
0x7D4F6:
0x21646:
Sure enough…
• Can we just modify main.bin, 
recalculate its CRC16 and flash 
it using the Nordic DFU app?
• Yes
Lovense Hush: DFU
firmware.bin
Wireshark
…
BLE
Internet
USB
Lovense compromise map
Computer can compromise dongle over BLE
(from dongle or just any other BLE device)
• on(”data”) does a little processing and passes 
the string to processData
• processData just throws the string into 
JSON.parse…
• We just saw that JSON parser bugs are a thing… 
but realistically V8’s parser is much more robust
• There have been bugs in its JSON engine like CVE-
2015-6764, but in stringify, not parse
• But on(“data”) and processData also call a(), 
seemingly for logging
• How does it work?
• …by dumping the message as HTML into the DOM
• That’s, like, classic trivial XSS
Lovense Remote: incoming 
message handling
t.on("data", function(n) {
e.dongleLiveTime = (new Date).getTime();
a(n.toString());
e.findDongle(n.toString(), t, i);
e.onData(n.toString());
});
...
processData: function(e) {
var t = null, i = this;
try {
t = JSON.parse(e)
} catch (e) {
return void a("data not json")
}
if (t) {
...
}
}
...
function a(e) {
if (!document.getElementById("dongleInfo")) {
var t = document.createElement("div");
t.id = "dongleInfo", t.style.display = "none", ...
document.getElementsByTagName("body")[0].appendChild(t);
}
var i = document.createElement("div");
i.innerHTML = e;
document.getElementById("dongleInfo").appendChild(i);
console.error(e);
}
• We can inject arbitrary HTML into the 
electron app from the dongle
• We can only do it 32 characters at a time
• Is that enough to execute JavaScript?
• Yes
Lovense Remote: incoming 
message handling
Example 30 character payload:
Result when starting the app:
Doesn’t exist, will throw an error
• In practice, there’s a little more work to be 
done to send a larger payload
• We can only execute 10 characters of JavaScript 
at a time
• Because we’re relying on onerror, there’s no 
strong guarantee of which order our payloads 
will be executed in
• Solution: create an array, populate it 
through explicit indices, then join it and 
eval
• Use dummy payloads to serialize when 
necessary
• I’m not a web developer, there’s probably a 
better way to do this ☺
Lovense Remote: incoming 
message handling
...
...
...
Initialize array
Serialization payload (send many)
Populate array
Shorten z.join so we can actually call it
Call z.join(“”)
eval the final, full payload!
BLE
Internet
USB
Lovense compromise map
The compromise now goes both ways: the 
computer can compromise the dongle, and 
the dongle can compromise the computer app
• The dongle basically just packages toy 
messages and forwards them
• So yes, we could put HTML in there
• However, the dongle only receives 20 
byte messages at a time…
• Is 20 characters enough to do XSS?
• No, it doesn’t look like it
• I tried with super short domains and using 
, but default scheme is file://, not 
http://, so it’s still not enough 
• There is a bug here: no null-terminator 
check, so we could append uninitialized 
data to our message
• But couldn’t find a way to control data 
Compromising the app from the Hush
void ble_gattc_on_hvx(ble_evt_t *event, remote_toy_t *remote_toy)
{
char local_buf[20];
if ( remote_toy )
{
if ( ... )
{
uint16_t len = event->len;
zeroset(local_buf, 20);
if ( len >= 20 ) len = 20;
memcpy(local_buf, event->p_data, len);
sendHostMessage_(
"{\"type\":\"toy\",\"func\":\"toyData\",\"data\":{\"id\":"
"\"%02X%02X%02X%02X%02X%02X\",\"data\":\"%s\"}}\n",
remote_toy->mac[0], remote_toy->mac[1], remote_toy->mac[2],
remote_toy->mac[3], remote_toy->mac[4], remote_toy->mac[5],
local_buf);
}
}
}
• We can’t go straight from the toy to the app
• But maybe we can go toy -> dongle -> app
• We saw the dongle firmware doesn’t do much with 
toy messages, just forwards them
• But there’s more code on the dongle than just Lovense’s
• The Application is what Lovense built
• The Bootloader is what handles DFU
• The SoftDevice is a driver for the chip’s hardware
• Closed source, built by Nordic Semiconductor
• For example, includes the implementation of the BLE stack
• So when the Application wants to send a BLE message to a toy, 
it asks the SoftDevice to it (through SVC calls)
Compromising the dongle over BLE
Application 
Flash Region
SoftDevice
Flash Region
0x00000000
0x0001B000
0x000218D8
Unused Flash 
Region
0x0003C000
Bootloader 
Flash Region
0x00040000
• Since we can debug the SoftDevice, 
it’s easy to find where BLE messages 
come from, especially with no ASLR
• setwp is your friend ☺
• After a bit of RE we can find packet 
handlers for various protocols
• On the right: incoming packet handler 
for the GATTC (General Attribute 
Protocol Client) role, which is what the 
dongle is
• Specifically, the handler for Read by 
Type Response packets
Nordic SoftDevice BLE 
vulnerabilities
void ble_gattc_packet_handler_(uint32_t input_len, uint8_t *input_buf,
uint8_t *gattc_event, int conn_handle, uint8_t* status)
{
...
switch(input_buf[0] & 0x3F)
{
...
case 0x09: // GATT Read By Type Response
if ( !(*status & 0x10) || input_len handle = *(u16*)input_buf_cursor;
attribute_data->value_ptr = &input_buf_cursor[2];
input_buf_cursor += attribute_data_length;
input_remaining_len -= attribute_data_length;
num_attributes++;
attribute_data++;
}
*status = 0;
break;
...
}
...
}
• GATT clients can send a “read by type” 
request packet
• Contains a type and a range of handles to 
read from
• Servers then respond with a “read by 
type” response packet
• Returns data associated to handles 
within that range that match that type
• The number of handle/data pairs is 
determined by dividing remaining packet 
length by the handle/data pair length 
field
• That field is supposed to always be 0x7 or 
0x15…
Offset(h) 00 01 02 03 04 05 06 07
00000000  09 06 0D 00 BE BA AD DE
00000008  0E 00 DE C0 AD 0B 0F 00 
00000010  AD FD EE 0B
Ready by Type Response packets
Sample Packet:
09
06
0D 00
: packet type (read by type response)
: handle/data pair length
: handle
BE BA AD DE
: data
switch(input_buf[0] & 0x3F)
{
attributePair_s attribute_array[10];
...
case 0x09: // GATT Read By Type Response
if ( !(*status & 0x10) || input_len handle = *(u16*)input_buf_cursor;
attribute_data->value_ptr = &input_buf_cursor[2];
input_buf_cursor += attribute_data_length;
input_remaining_len -= attribute_data_length;
num_attributes++;
attribute_data++;
}
*status = 0;
break;
...
}
Offset(h) 00 01 02 03 04 05 06 07
00000000  09 06 0D 00 BE BA AD DE
00000008  0E 00 DE C0 AD 0B 0F 00 
00000010  AD FD EE 0B
Sample Packet:
attribute_array:
Offset(h) 00 01 02 03 04 05 06 07
00000000  0D 00 00 00 04 24 00 20
00000008  0E 00 00 00 0A 24 00 20
00000010  0F 00 00 00 10 24 00 20
00000018  00 00 00 00 00 00 00 00
00000020  00 00 00 00 00 00 00 00
00000028  00 00 00 00 00 00 00 00
00000030  00 00 00 00 00 00 00 00
00000038  00 00 00 00 00 00 00 00
00000040  00 00 00 00 00 00 00 00
00000048  00 00 00 00 00 00 00 00
Read by type response handler
switch(input_buf[0] & 0x3F)
{
attributePair_s attribute_array[10];
...
case 0x09: // GATT Read By Type Response
if ( !(*status & 0x10) || input_len < 2 )
return NRF_ERROR_INVALID_PARAM;
num_attributes = 0;
attribute_data_length = input_buf[1];
attribute_data = attribute_array;
input_buf_cursor = &input_buf[2];
input_remaining_len = input_len - 2;
while ( attribute_data_length <= input_remaining_len )
{