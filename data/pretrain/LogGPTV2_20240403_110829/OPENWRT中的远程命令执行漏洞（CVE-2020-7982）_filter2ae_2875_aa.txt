# OPENWRT中的远程命令执行漏洞（CVE-2020-7982）
##### 译文声明
本文是翻译文章，文章原作者 Guido Vranken，文章来源：forallsecure.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
关注[ForALLSecure](https://forallsecure.com/)的人可能知道，我一直在使用Mayhem软件挖掘OpenWRT中的漏洞，挖掘方式一般是：编写自定义框架、在不重新编译的情况下运行该二进制文件以及手工检查源码。
这个漏洞的发现十分偶然，当时我正在为opkg准备一个Mayhem任务。
Mayhem可以处理来自文件或者是socket连接的数据。
opkg从`downloads.openwrt.org`上下载软件包，所以我的计划是让这个域名指向运行有Mayhem服务的`127.0.0.1`地址。
为了测试opkg是否真的会从自定的网络连接上下载软件包，我设置了本地Web服务器并且创建了一个包含任意字节的文件。当我运行opkg安装软件包时，它按照我的预想检索到了该文件，并引发了段错误。
我不明白为什么无效软件包会引发这样的错误，毕竟如果SHA256的哈希值不正确的话，是不会处理该软件包的。
我最初认为，opkg会下载该软件包，解压缩并将其放入一个临时文件夹，之后才会在安装前检查SHA256哈希值，所以我怀疑是不是解压缩程序无法处理异常数据，例如这个来自我的web服务器的含有任意字节的文件。
通过进一步的检查，我发现程序根本没有进行SHA256哈希值检查，而这也是漏洞之所以能够存在的基础。
不过解压缩程序确实存在问题，异常数据会导致各种内存冲突。
确认了opkg会尝试解压缩并安装下载的 _任意_ 软件包后，我就可以通过Mayhem复现这个发现，只需要对opkg进行一些小的修改。
我为`opkg install
attr`设置了一个Mayhem任务（attr是一个小的OpenWRT软件包），通过检测解压缩程序中的内存错误，Mayhem可以发现远程命令执行漏洞。如果OpenWRT中的SHA256验证程序能够按预期工作，opkg就会丢弃异常的软件包，不对其进行处理，那么也就不会发生段错误了。
Mayhem可以在不重新编译和检测的情况下fuzzing二进制文件，我已经按照这样的流程为软件库编写很多自定义框架了（Mayhem支持这样的方式），这让我可以在短短几周内为数十个OpenWRT程序设置目标，从而发现更多漏洞。
在下面各小节中，我会详细介绍自己是如何发现这个漏洞的。
## OpenWRT
[OpenWRT](https://openwrt.org/)是一个基于Linux系统，专门用于嵌入式设备，尤其是路由器的免费操作系统，它已安装在全球数百万台设备上。
## OpenWRT包管理器
可以使用`opkg`程序在OpenWRT系统上安装或更新软件，`opkg`的功能和目的类似于基于Debian的系统上的`apt`程序。
opkg通过未加密的HTTP连接从`downloads.openwrt.org`上获取可安装软件包列表。
软件包列表会进行数字签名，在处理包文件前，程序会验证该文件确实来自OpenWRT，如果验证失败，就丢弃该文件。
一个典型的包条目如下所示：
    Package: attr
    Version: 2.4.48-2
    Depends: libc, libattr
    License: GPL-2.0-or-later
    Section: utils
    Architecture: x86_64
    Installed-Size: 11797
    Filename: attr_2.4.48-2_x86_64.ipk
    Size: 12517
    SHA256sum: 10f4e47bf6b74ac1e49edb95036ad7f9de564e6aba54ccee6806ab7ace5e90a6                                                                                                                              
    Description:  Extended attributes support
     This package provides xattr manipulation utilities
     - attr
     - getfattr
     - setfattr
其中`SHA256sum`字段用于确保下载的软件包未破损或被破坏，程序默认SHA256哈希值是来自OpenWRT的，因为软件包列表中也包含这个哈希值，而软件包列表是通过了签名验证的。
理论上来讲，因为使用了签名，即使传输通道(HTTP)并不安全，软件包列表和软件压缩包也不会被篡改。
关于这部分内容的讨论可以看[这里](https://whydoesaptnotusehttps.com/)。
## 漏洞
在用户通过`opkg install `安装软件包后，`opkg`会首先解析软件包列表。
解析器遍历每个包条目，并根据字段类型执行不同的操作，如果是`SHA256sum`字段，解析器会调用`pkg_set_sha256`：
    312              else if ((mask & PFM_SHA256SUM) && is_field("SHA256sum", line))
    313                      pkg_set_sha256(pkg, line + strlen("SHA256sum") + 1);
`pkg_set_sha256`会尝试将`SHA256sum`字段从十六进制转为二进制，并以内部形式存储：
    244 char *pkg_set_sha256(pkg_t *pkg, const char *cksum)
    245 {
    246      size_t len;
    247      char *p = checksum_hex2bin(cksum, &len);
    248
    249      if (!p || len != 32)
    250              return NULL;
    251
    252      return pkg_set_raw(pkg, PKG_SHA256SUM, p, len);
    253 }
如果解码失败，程序自动结束，并不保存哈希值。
漏洞发生在`checksum_hex2bin`中，这个漏洞很容易被忽略，你能找到它吗？
    234 char *checksum_hex2bin(const char *src, size_t *len)
    235 {
    236      size_t slen;
    237      unsigned char *p;
    238      const unsigned char *s = (unsigned char *)src;
    239      static unsigned char buf[32];
    240
    241      if (!src) {
    242              *len = 0;
    243              return NULL;
    244      }
    245
    246      while (isspace(*src))
    247              src++;
    248
    249      slen = strlen(src);
    250
    251      if (slen > 64) {
    252              *len = 0;
    253              return NULL;
    254      }
    255
    256      for (p = buf, *len = 0;
    257           slen > 0 && isxdigit(s[0]) && isxdigit(s[1]);
    258           slen--, s += 2, (*len)++)
    259              *p++ = hex2bin(s[0]) * 16 + hex2bin(s[1]);
    260
    261      return (char *)buf;
    262 }
最开始，变量`s`和`src`都指向同一地址。
在第246行，变量`src`前进到第一个非空格字符，然而在实际进行解码时，256行的`for`循环是在变量`s`上进行操作，而变量`s`仍旧指向字符串的起始位置。
因此，如果输入的字符串开头有任何空格字符的话，程序就会尝试对空格字符进行解码，而空格字符并不是十六进制字符，所以`isxdigit()`会返回`false`，解码器的循环立即终止，`*len`为`0`。
再次检查解析器，可以看到传递给`pkg_set_sha256`的字符串是”SHA256sum:”后面的部分字符串：
    313                     pkg_set_sha256(pkg, line + strlen("SHA256sum") + 1);
这就意味着这个部分字符串的第一个字符是一个空格。
软件包列表解析完成后，通过HTTP下载软件包。
接下来会进行几个验证步骤。
下载的软件包大小必须等于软件包列表中的指定大小：
    1379      pkg_expected_size = pkg_get_int(pkg, PKG_SIZE);
    1380
    1381      if (pkg_expected_size > 0 && pkg_stat.st_size != pkg_expected_size) {
    1382              if (!conf->force_checksum) {
    1383                      opkg_msg(ERROR,
    1384                               "Package size mismatch: %s is %lld bytes, expecting %lld bytesn",
    1385                               pkg->name, (long long int)pkg_stat.st_size, pkg_expected_size);
    1386                      return -1;
    1387              } else {
    1388                      opkg_msg(NOTICE,
    1389                               "Ignored %s size mismatch.n",
    1390                               pkg->name);
    1391              }
    1392      }