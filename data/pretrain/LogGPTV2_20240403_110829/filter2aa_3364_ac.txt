350
400
Chow #1 (8x)
Chow #2 (8x)
Chow #3 (8x)
Chow #4 (8x)
myspace.com
fastclick.net
evite.com
object_instance
element_instance
escape
eval
string_instance/50
document_write
Feinstein & Peck 
9 
Black Hat USA 2007
m
frig
st
hill
uchmusic.com
photofile.ru
youtube.com
htcatalog.com
ore.yahoo.net
aryclinton.com
There are clear differences between the malicious JavaScript samples and the benign 
JavaScripts collected during the MySpace crawl. The monkey chow statistics were scaled by 
a factor of 8. We anticipated a difference in the scales of the function call counts between 
the malicious samples and the benign samples. The four malicious samples were short 
script fragments; however, the benign samples tended to be large feature‐rich scripts. 
Larger scripts will tend to have higher function call counts simply because they have more 
lines of code. 
It appears that benign scripts make significantly more use of the document.write() 
method while malicious scripts make relatively more use of string instantiation. Our small 
sample of malicious scripting also instantiates relatively more objects than our samples of 
benign JavaScript. Malicious scripts tended to programmatically create DOM elements 
more frequently than the benign scripts. Use of the eval() function is also relatively more 
ommon in the benign scripts than in our sample of malicious scripts. 
c
Caffeine Monkey at Work 
In order to illustrate the utility of the Caffeine Monkey engine, we will now analyze a 
sample of obfuscated JavaScript found in the wild. This sample of JavaScript isn’t truly 
destructive, but offers a useful overview of the time consuming, error prone, and 
potentially dangerous process of manual human analysis.  
F
a
einstein & Peck 
10 
Black Hat USA 2007
Such a script can appear more than a little intimidating at first glance. Considerable manual 
analysis of this sample would be required to determine the scripts functionality. Function 
I() is defined as taking two arguments, mk and G. I() performs lots of bit‐shifting and 
substitution before assigning the result of a call to String.fromCharCode() to the 
function I(mK,G){if(!G){G='Ba,%7(r_)`m?dPSn=3J/@TUc0f:6uMhk;wyHZEs-
^O1N{W#XtKq4F&xV+jbRAi9g';}var R;var TB='';for(var 
e=0;e
>16,(R&65280)>>8,R&255);}eval(TB.substring(0,TB.length-
(arguments.callee.toString().replace(/\s/g,'').length-
537)));}I('friHMU&E6-
=#MV`OMr@^`4K/=&``@(=;/7(S3&Ta3F@i)ZOwMs(40V`Ou_=y)(PJ=4Fy:_3Fu%^X?VMVMq
jOM_Ob6V=#0xdXuV3j6r@XnV`EfHF-mx3X0VTWfUjF?-`EfsTqusTqmquynHtX`q{-
uxPq:caFnyuOSqB;),B;),B;),Bm),B;'); 
Figure 4 
variable TB. The whole mess is then passed to the eval() function. 
The details of how this was accomplished are left as an exercise for the reader, but it all 
boils down to a single function call. 
eval(“document.write('
');”); 
Requesting this URI returns an even uglier piece of obfuscated JavaScript. 
The gory details of decoding this sample are outside the scope of this document, but clearly 
it would present a challenge to either a novice analyst or a time conscious veteran. 
Automating the deobfuscation process allows human analysts to examine the evasion 
techniques being used by attackers, but also yields some additional wisdom that could be 
leveraged in a heuristics based detection system. Low‐interaction client honeypots could 
use the Caffeine Monkey engine to rapidly analyze large collections of JavaScript. Using the 
GNU tool chain’s philosophy, the engine can easily be tied together with other utilities to 
utomate the analyst’s workflow. 
Figure 5 
Feinstein & Peck 
11 
Black Hat USA 2007
Caffeine Monkey JavaScript Engine 
We began developing the Caffeine Monkey engine using the code base of the Mozilla 
SpiderMonkey (JavaScript‐C) Engine, an embeddable open source JavaScript engine 
implemented in the C language. The initial code base offered a rudimentary interpreter and 
had an architecture allowing for easy extensibility. We internally hooked the functions we 
thought most likely to be used in obfuscation and added runtime logging output. Runtime 
logging allowed us to observe the flow of execution without getting into interactive script 
debugging. One of the first methods we wrapped and logged was eval(). By hooking into 
the execution path at the interpreter level, obfuscation is completely avoided as we log the 
actual string passed to eval() and where in the script’s execution the call is made. 
We hooked the string concatenation method, allowing not only a final view of the string, 
but also creating a record of the order and timing of when string concatenations occurred 
during execution. This feature is potentially useful for script fingerprinting, as particular 
obfuscation tools tend to use a similar method to obfuscate the strings each time that are 
run. 
After instrumenting only these two basic functions we were able to produce a very 
informative log. The log served to reduce the obfuscation example above down to a handful 
of log lines that are easily readable by both human and machine. For the sake of disclosure, 
the example above sets a known spyware cookie in the browser and redirect the browser 
to a niche online dating site. 
A full implementation of Document Object Model (DOM) logging is in development at the 
time of this writing, as the original SpiderMonkey code base only provided the basic 
JavaScript methods and objects. 
A more in depth discussion of the Caffeine Monkey engine’s functionality is outside the 
scope of this paper. Documentation will be made available along with the source code to 
our tools. The example above makes it clear that an automated analysis tool working at the 
interpreter level offers the potential to increase efficiency when analyzing scripts using 
ommon obfuscation and evasion techniques. 
c
Directions for Future Research 
There are many areas for improvements and extensions to these tools. The core engine 
could be leveraged in an application proxy setting, removing or flagging potentially 
dangerous JavaScript. With further optimization, Caffeine Monkey and its analytical results 
could be used within Network Intrusion Detection or Prevention Systems. The tool can also 
be simply used as a command‐line utility by attackers testing their obfuscation schemes or 
by security analysts working to reverse the efforts of the attackers.
Feinstein & Peck 
12 
Black Hat USA 2007
R
Mozilla SpiderMonkey (JavaScript‐C) Engine 
eferences 
http://www.mozilla.org/js/spidermonkey/ 
Seifert, C., Welch, I. and Komisarczuk, P., “Taxonomy of Honeypots”, Victoria University of 
Wellington, Wellington, 2006. 
.ac.nz/comp/Publications/index‐byyear‐06.html 
http://www.mcs.vuw
Heritrix web crawler 
http://crawler.archive.org/ 
Baker, N., “Archiving Websites”, HOWTO, University of Michigan, School of Information, 
February 2005. 
http://www.si.umich.edu/mirror/how_to/ 
Japanese language site apparently discussing malicious JavaScript samples 
40516‐1‐5.html 
http://bbs.blueidea.com/thread‐27
The Strider HoneyMonkey Project 
m/honeymonkey/ 
http://research.microsoft.co
MITRE Honeyclient Project 
http://www.honeyclient.org/trac 
Wang, K., “Using Honeyclients to Detect New Attacks”, ToorCon 2005. 
oorCon2005.pdf 
http://www.synacklabs.net/honeyclient/Wang‐Honeyclient‐T
HoneyC – The Low‐Interaction Client Honeypot / Honeyclient 
http://honeyc.sourceforge.net/ 
Caswell, B. and HD Moore, “Thermoptic Camouflage – Total IDS Evasion”, Black Hat USA 
2006. 
ns/bh‐usa‐06/BH‐US‐06‐Caswell.pdf 
http://www.blackhat.com/presentatio
ECMAScript Specification (ECMA‐262) 
ational.org/publications/standards/Ecma‐262.htm 
http://www.ecma‐intern
Month of Browser Bugs 
http://browserfun.blogspot.com/ 
eVade O’ Matic Module for Metasploit 
http://blog.info‐pull.com/2007/01/update‐17th‐october‐2006‐aviv‐posted.html