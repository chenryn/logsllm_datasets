本章提出了万维网的架构需求，以及在设计和评估被提议的对万维网关键通信协议的改
进的过程中所遇到的问题。这里的挑战是：开发一个用来设计架构改进的方法，使得能够在
改进部署之前对它们进行评估。我的方法是使用一种架构风格来定义和改进在Web架构背
后的设计基本原理，使用风格作为严格的测试，在被提议的扩展部署之前，对这些扩展加以
验证，并且通过将修订后的架构直接应用在已经创建了Web基础设施的软件开发项目中，
来部署修订后的架构。
下一章介绍并详细描述了为分布式超媒体系统设计的表述性状态转移（REST）架构风
格，该风格被开发出来，用来代表现代Web应该如何运转的模型。REST提供了一组架构约
束，当作为一个整体来应用时，强调组件交互的可伸缩性、接口的通用性、组件的独立部署、
以及用来减少交互延迟、增强安全性、封装遗留系统的中间组件。
第5章 表述性状态转移（REST） 41
第 5 章 表述性状态转移（REST）
本章介绍并详细描述了为分布式超媒体系统设计的表述性状态转移（REST）架构风格，
描述了指导REST的软件工程原则和选择用来支持这些原则的交互约束，并将它们与其他架
构风格的约束进行了对比。REST是从第3章描述的几种基于网络的架构风格中衍生出来的
一种混合架构风格，并且添加了一些额外的约束，用来定义统一的连接器接口。我使用第1
章中的软件架构框架来定义REST的架构元素，并检查原型架构的过程样本、连接器和数据
视图。
5.1 推导REST
Web架构背后的设计基本原理，能够被描述为由一组应用于架构中元素之上的约束组成
的架构风格。当将每个约束添加到进化中的风格时，会产生一些影响。通过检查这些影响，
我们就能够识别出Web的约束所导致的属性。然后就能够应用额外的约束来形成一种新的
架构风格，这种风格能够更好地反映出现代Web架构所期待的属性。本节通过简述REST作
为架构风格的推导过程，提供了关于REST的总体概览，后面各节将会详细描述组成REST
风格的各种特定约束。
5.1.1 从“空”风格开始
无论是建筑还是软件，人们对架构设计的过程都有着两种常见的观点。第一种观点认为
设计师一切从零开始——一块空的石板、白板、或画板——并使用熟悉的组件建造出一个架
构，直到该架构满足希望的系统需求为止。第二种观点则认为设计师从作为一个整体的系统
需求出发，此时没有任何约束，然后增量地识别出各种约束，并将它们应用于系统的元素之
上，以便对设计空间加以区分，并允许影响到系统行为的力量（forces）与系统协调一致，
自然地流动。第一种观点强调创造性和无限的想象力，而第二种观点则强调限制和对系统环
境的理解。REST是使用后一种过程发展而成的。随着增量地应用一组约束，已应用的约束
会将架构的过程视图区分开，图5-1至5 -8以图形化的方式依次描述了这个过程。
“空”风格（图5-1）仅仅是一个空的约束集合。从架构的观点来看，空风格描述了一个
组件之间没有明显边界的系统。这就是我们描述REST的起点。
WWW
图5-1：“空”风格
5.1.2 客户-服务器
首先被添加到我们的混合风格中的约束来自3.4.1小节描述的客户-服务器架构风格（图
5-2）。客户-服务器约束背后的原则是分离关注点。通过分离用户接口和数据存储这两个关
注点，我们改善了用户接口跨多个平台的可移植性；同时通过简化服务器组件，改善了系统
的可伸缩性。然而，对于 Web来说，最重要的是这种关注点的分离允许组件独立地进化，
从而支持多个组织领域的Internet规模的需求。
第5章 表述性状态转移（REST） 42
Server
Client
图5-2：客户-服务器风格
5.1.3 无状态
我们接下来再为客户-服务器交互添加一个约束：通信必须在本质上是无状态的，如
3.4.3小节中的客户-无状态-服务器（CSS）风格那样，因此从客户到服务器的每个请求都必
须包含理解该请求所必需的所有信息，不能利用任何存储在服务器上的上下文，会话状态因
此要全部保存在客户端。
Server
Client
图5-3：客户-无状态-服务器风格
这个约束导致了可见性、可靠性和可伸缩性三个架构属性。改善了可见性是因为监视系
统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为
它减轻了从局部故障[133]中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保
存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个
请求管理资源的使用。
与大多数架构上抉择一样，无状态这一约束反映出设计上的权衡。其缺点是：由于不能
将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据
（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器
对于一致的应用行为的控制，因为这样一来，应用就得依赖于跨多个客户端版本（译者注：
例如多个浏览器窗口）的语义的正确实现。
5.1.4 缓存
为了改善网络的效率，我们添加了缓存约束，从而形成了3.4.4小节描述的客户-缓存-
无状态-服务器风格（图5-4）。缓存约束要求一个请求的响应中的数据被隐式地或显式地标
记为可缓存的或不可缓存的。如果响应是可缓存的，那么客户端缓存就可以为以后的相同请
求重用这个响应的数据。
第5章 表述性状态转移（REST） 43
$
Server
Client
Client+Cache
$
图5-4：客户-缓存-无状态-服务器风格
添加缓存约束的好处在于，它们有可能部分或全部消除一些交互，从而通过减少一系列
交互的平均延迟时间，来提高效率、可伸缩性和用户可觉察的性能。然而，付出的代价是，
如果缓存中陈旧的数据与将请求直接发送到服务器得到的数据差别很大，那么缓存会降低可
靠性。
早期的Web架构，如图5-5所示[11]，是通过客户-缓存-无状态-服务器的约束集合来定
义的。也就是说，1994年之前的Web架构的设计基本原理聚焦于在Internet上交换静态文档
的无状态的客户-服务器交互。交互的通信协议仅包含了对非共享缓存的初步支持，但是并
没有限定接口要对所有的资源提供一组一致的语义。相反，Web依赖于使用一个公共的客户-
服务器实现库（CERN的libwww）来维护Web应用之间的一致性。
Browsers
dumb PC Mac X NeXT
Addressing scheme + Common protocol + Format negotiation
wayVMSHelpgatewa
sH eT rvT eP seF rT vP G so ep rvh ee rr sN eN rvT eP WAISgatewayXFINDgate
r er r
Internet
News
Servers/Gateways
© 1992 Tim Berners-Lee, Robert Cailliau, Jean-François Groff, C.E.R.N.
图5-5：早期WWW的架构图
第5章 表述性状态转移（REST） 44
Web实现的开发者早已经超越了这种早期的设计。除了静态的文档之外，请求还能够识
别出动态生成响应的服务，例如图像地图（image-maps）[Kevin Hughes]和服务器端脚本
（server-side scripts）[Rob McCool]。人们也以代理[79]和共享缓存[59]的形式开展了对中间
组件的研究，但是为了使中间组件能够可靠地通信，还需要对现有的协议进行扩展。以下几
小节描述了添加到Web架构风格中的约束，以便用来对形成现代Web架构的扩展加以指导。
5.1.5 统一接口
使REST架构风格区别于其他基于网络的架构风格的核心特征是，它强调组件之间要有
一个统一的接口（图5-6）。通过在组件接口上应用通用性的软件工程原则，整体的系统架
构得到了简化，交互的可见性也得到了改善。实现与它们所提供的服务是解耦的，这促进了
独立的可进化性。然而，付出的代价是，统一接口降低了效率，因为信息都使用标准化的形
式来转移，而不能使用特定于应用的需求的形式。REST接口被设计为可以高效地转移大粒
度的超媒体数据，并针对Web的常见情况做了优化，但是这也导致了该接口对于其他形式
的架构交互并不是最优的。
$ orb
$
$
ClientConnector: Client+Cache: $ ServerConnector: Server+Cache: $
图5-6：统一-客户-缓存-无状态-服务器风格
为了获得统一的接口，需要有多个架构约束来指导组件的行为。REST由四个接口约束
来定义：资源的识别（identification of resources）、通过表述对资源执行的操作、自描述的
消息（self-descriptive messages）、以及作为应用状态引擎的超媒体。这些约束将在5.2节中
讨论。
5.1.6 分层系统
为了进一步改善与Internet规模的需求相关的行为，我们添加了分层的系统约束（图5-
7）。正如3.4.2小节中所描述的那样，分层系统风格通过限制组件的行为（即，每个组件只
能“看到”与其交互的紧邻层），将架构分解为若干等级的层。通过将组件对系统的知识限
制在单一层内，为整个系统的复杂性设置了边界，并且提高了底层独立性。我们能够使用层
来封装遗留的服务，使新的服务免受遗留客户端的影响，通过将不常用的功能转移到一个共
享的中间组件中，从而简化组件的实现。中间组件还能够通过支持跨多个网络和处理器的负
载均衡，来改善系统的可伸缩性。
第5章 表述性状态转移（REST） 45
$ $ orb
$
$ $