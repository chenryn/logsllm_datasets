ically creates exploits on smart contracts. TEETHER is a
concurrent work with Erays.
8 Discussion
We have shown the feasibility of reverse engineering
opaque contracts on Ethereum blockchain. Reverse en-
gineering tools like Erays make it easier to reconstruct
high level source code even when none is available. We
envision that reverse engineering may be used by “white
hate” security teams or regulatory bodies in order to carry
out public audits of the Ethereum blockchain. Regardless,
reverse engineering remains expensive, and such audits
would be simpliﬁed if the high-level source were available
in the ﬁrst place. We suggest that the Ethereum commu-
nity should adopt technical mechanisms and conventions
that increase the transparency of smart contract programs.
Etherscan’s veriﬁed source code is a step in the right di-
rection, but more work must be done in order to improve
transparency in the ecosystem.
Why are so many contracts opaque, given the ease
of publishing source code to Etherscan? In some cases,
opacity may be a deliberate decision in order to achieve
security through obscurity. Another explanation is that
publishing Solidity source code is not yet a strong default,
and infrastructure support is only partial. For example,
we are not aware of any other block explorer services
besides Etherscan that provides a Veriﬁed Source code
repository. Although Ethereum features a decentralized
standard called “Swarm” that supports publishing a con-
tract’s Application Bytecode Interface (ABI), including
the method signatures and argument types, this standard
does not include the full source code. This standard
should be extended to support high-level source code
as well.
1382    27th USENIX Security Symposium
USENIX Association
9 Conclusion
Many Ethereum smart contracts on the blockchain are
opaque—they have no easily linkable source code. These
contracts control $3.1 B USD in balance, and are trans-
acted with a total of 12.7 M times. To investigate these
contracts, we introduced Erays, a reverse engineering
tool for EVM. Erays lifts EVM bytecode into higher
level representations suitable for manual analysis. We
ﬁrst showed how Erays can be used to quantify code
complexity, identify code reuse, and reduce opacity in
the smart contract ecosystem. We then applied Erays to
four reverse-engineering case studies: high-value multi-
signature wallets, arbitrage bots, exchange accounts, and
ﬁnally, a popular smart contract game. We identiﬁed that
smart contract developers may be expecting obscurity for
the correct functionality of their contracts, and may be ex-
pecting to achieve “security by obscurity” in withholding
their high level code. We hope Erays will prove useful for
both the security and Ethereum communities in improving
the transparency in Ethereum.
Acknowledgments
This work was supported in part by the National Sci-
ence Foundation under contract CNS-151874, as well as
through gifts from CME Group and Jump Trading. The
work was additionally supported by the U.S. Department
of Homeland Security contract HSHQDC-17-J-00170.
Any opinions, ﬁndings, conclusions, or recommendations
expressed in this material are those of the authors and do
not necessarily reﬂect the views of their employers or the
sponsors.
References
[1] Cryptokitties craze slows down transactions on ethereum. http://
www.bbc.com/news/technology-42237162.
[2] Etherdelta. https://etherdelta.com/.
[3] Etherscan. https://etherscan.io.
[4] Manticore. https://github.com/trailofbits/manticore.
[5] Mythril. https://github.com/ConsenSys/mythril.
[6] Remix. https://github.com/ethereum/remix.
[7] Soldity documentation. https://solidity.readthedocs.io/en/develop/.
[8] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman. Compilers:
Principles, Techniques, and Tools (2Nd Edition). Addison-Wesley
Longman Publishing Co., Inc., Boston, MA, USA, 2006.
[9] F. E. Allen. Control ﬂow analysis. In ACM Sigplan Notices, 1970.
[10] F. E. Allen and J. Cocke. A program data ﬂow analysis procedure.
Commun. ACM, 19(3):137–, Mar. 1976.
[11] N. Atzei, M. Bartoletti, and T. Cimoli. A survey of attacks on
ethereum smart contracts sok. In Proceedings of the 6th Interna-
tional Conference on Principles of Security and Trust - Volume
10204, pages 164–186, New York, NY, USA, 2017. Springer-
Verlag New York, Inc.
[12] G. Balakrishnan and T. Reps. Divine: Discovering variables in
executables. In Proceedings of the 8th International Conference
on Veriﬁcation, Model Checking, and Abstract Interpretation, VM-
CAI’07, pages 1–28, Berlin, Heidelberg, 2007. Springer-Verlag.
[13] M. Bartoletti and L. Pompianu. An empirical analysis of smart
contracts: platforms, applications, and design patterns. In Interna-
tional Conference on Financial Cryptography and Data Security,
pages 494–509. Springer, 2017.
[14] R. Browne.
Accidental bug may have frozen 280 mil-
lion worth of digital coin ether in a cryptocurrency wal-
let. https://www.cnbc.com/2017/11/08/accidental-bug-may-have-
frozen-280-worth-of-ether-on-parity-wallet.html.
[15] M. Chandramohan, Y. Xue, Z. Xu, Y. Liu, C. Y. Cho, and H. B. K.
Tan. Bingo: Cross-architecture cross-os binary search. In Proceed-
ings of the 2016 24th ACM SIGSOFT International Symposium on
Foundations of Software Engineering, FSE 2016, pages 678–689,
New York, NY, USA, 2016. ACM.
[16] T. Chen, X. Li, X. Luo, and X. Zhang. Under-optimized smart
contracts devour your money. In Software Analysis, Evolution and
Reengineering (SANER), 2017 IEEE 24th International Confer-
ence on, pages 442–446. IEEE, 2017.
[17] C. Cifuentes and K. J. Gough. Decompilation of binary programs.
Softw. Pract. Exper., 25(7):811–829, July 1995.
[18] U. F. T. Commission. Know the risks before investing in cryptocur-
rencies. https://www.ftc.gov/news-events/blogs/business-blog/
2018/02/know-risks-investing-cryptocurrencies.
[19] K. Croman, C. Decker, I. Eyal, A. E. Gencer, A. Juels, A. Kosba,
A. Miller, P. Saxena, E. Shi, E. G. Sirer, et al. On scaling decen-
tralized blockchains. In International Conference on Financial
Cryptography and Data Security, pages 106–125. Springer, 2016.
[20] C. Decker and R. Wattenhofer. Information propagation in the
bitcoin network. In Peer-to-Peer Computing (P2P), 2013 IEEE
Thirteenth International Conference on, pages 1–10. IEEE, 2013.
[21] C. Decker and R. Wattenhofer. Bitcoin transaction malleability
and mtgox. In European Symposium on Research in Computer
Security, pages 313–326. Springer, 2014.
[22] M. Dong.
Towards cracking crypto kitties’ genetic
https://medium.com/@montedong/towards-cracking-
code.
crypto-kitties-genetic-code-629fcd37b09b.
[23] Etherscan. Shapeshift exchange account. https://etherscan.io/
address/0x70faa28a6b8d6829a4b1e649d26ec9a2a39ba413.
[24] K. Finley. A 50 million dollar hack just showed that the dao was
all too human. https://www.wired.com/2016/06/50-million-hack-
just-showed-dao-human/, 2016.
[25] R. Fitzgerald, T. B. Knoblock, E. Ruf, B. Steensgaard, and
D. Tarditi. Marmot: An optimizing compiler for java. Softw.
Pract. Exper., 30(3):199–232, Mar. 2000.
[26] E. Foundation. Erc20 token standard. https://theethereum.wiki/w/
index.php/ERC20_Token_Standard.
[27] A. Hegyi. Cryptokitties genescience algorithm. https://medium.
com/@alexhegyi/cryptokitties-genescience-1f5b41963b0d.
[28] O. Kharif. Cryptokitties mania overwhelms ethereum net-
work’s processing. https://www.bloomberg.com/news/articles/
2017-12-04/cryptokitties-quickly-becomes-most-widely-used-
ethereum-app.
[29] J. Krupp and C. Rossow. teether: Gnawing at ethereum to auto-
matically exploit smart contracts. In 27th USENIX Security Sym-
posium (USENIX Security 18), Baltimore, MD, 2018. USENIX
Association.
USENIX Association
27th USENIX Security Symposium    1383
[30] J. Lee, T. Avgerinos, and D. Brumley. Tie: Principled reverse
engineering of types in binary programs. In Proceedings of the
Network and Distributed System Security Symposium, NDSS 2011,
San Diego, California, USA, 6th February - 9th February 2011,
2011.
[31] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor. Making
smart contracts smarter. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security, CCS ’16,
pages 254–269, New York, NY, USA, 2016. ACM.
[32] R. Marvin. Blockchain in 2017: The year of smart con-
https://www.pcmag.com/article/350088/blockchain-in-
tracts.
2017-the-year-of-smart-contracts.
[33] T. J. McCabe. A complexity measure. IEEE Transactions on
software Engineering.
[34] S. Meiklejohn, M. Pomarole, G. Jordan, K. Levchenko, D. McCoy,
G. M. Voelker, and S. Savage. A ﬁstful of bitcoins: characterizing
payments among men with no names. In Proceedings of the 2013
conference on Internet measurement conference, pages 127–140.
ACM, 2013.
[35] J. Miecznikowski and L. Hendren. Decompiling java using staged
encapsulation. In Proceedings of the Eighth Working Conference
on Reverse Engineering (WCRE’01), WCRE ’01, pages 368–,
Washington, DC, USA, 2001. IEEE Computer Society.
[36] A. Miller, J. Litton, A. Pachulski, N. Gupta, D. Levin, N. Spring,
and B. Bhattacharjee. Discovering bitcoin’s public topology and
inﬂuential nodes. et al., 2015.
[37] T. Neudecker, P. Andelﬁnger, and H. Hartenstein. Timing analysis
for inferring the topology of the bitcoin peer-to-peer network.
In Ubiquitous Intelligence & Computing, Advanced and Trusted
Computing, Scalable Computing and Communications, Cloud
and Big Data Computing, Internet of People, and Smart World
Congress (UIC/ATC/ScalCom/CBDCom/IoP/SmartWorld), 2016
Intl IEEE Conferences, pages 358–367. IEEE, 2016.
[38] F. Nielson, H. R. Nielson, and C. Hankin. Principles of Program
Analysis. Springer-Verlag, Berlin, Heidelberg, 1999.
[39] A. Sæbjørnsen, J. Willcock, T. Panas, D. Quinlan, and Z. Su.
Detecting code clones in binary executables. In Proceedings of
the Eighteenth International Symposium on Software Testing and
Analysis, ISSTA ’09, pages 117–128, New York, NY, USA, 2009.
ACM.
[40] s. Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash
system. https://bitcoin.org/bitcoin.pdf.
[41] E. J. Schwartz, J. Lee, M. Woo, and D. Brumley. Native x86
decompilation using semantics-preserving structural analysis and
In Proceedings of the 22Nd
iterative control-ﬂow structuring.
USENIX Conference on Security, SEC’13, pages 353–368, Berke-
ley, CA, USA, 2013. USENIX Association.
[42] B. Schwarz and G. A. Saumya Debray. Disassembly of executable
In 9th IEEE Working Conference on Reverse
code revisited.
Engineering.
[43] U. Securities and E. Commission. Investor bulletin: Initial coin
offerings. https://www.sec.gov/oiea/investor-alerts-and-bulletins/
ib_coinofferings.
[44] M. Sharir. Structural analysis: A new approach to ﬂow analysis
in optimizing compilers. Computer Languages, 5(3-4):141–153,
1980.
[45] Y. Shin and L. Williams. Is complexity really the enemy of soft-
ware security? In 4th ACM workshop on Quality of protection.
[46] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, et al. (state
of) the art of war: Offensive techniques in binary analysis. In
Security and Privacy (SP), 2016 IEEE Symposium on, pages 138–
157. IEEE, 2016.
[47] L. Torczon and K. Cooper. Engineering A Compiler. 2007.
[48] K. Turner. The cryptokitties genome project. https://medium.com/
@kaigani.
[49] R. Vallée-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam, and V. Sun-
daresan. Soot - a java bytecode optimization framework. In 1999
conference of the Centre for Advanced Studies on Collaborative
research.
[50] G. Wood. Ethereum: A secure decentralised generalised transac-
tion ledger.
[51] K. Yakdan, S. Eschweiler, E. Gerhards-Padilla, and M. Smith. No
more gotos: Decompilation using pattern-independent control-
ﬂow structuring and semantic-preserving transformations.
In
22nd Annual Network and Distributed System Security Sympo-
sium, NDSS 2015, San Diego, California, USA, February 8-11,
2015, 2015.
[52] W. Zhao. 30 million: Ether reported stolen due to parity wal-
let breach. https://www.coindesk.com/30-million-ether-reported-
stolen-parity-wallet-breach/.
A Internal Function Identiﬁcation
In our heuristic, an internal function is assumed to
have a single entry and a single exit. Consequently,
there are four basic blocks involved in an internal
call
that we name caller_begin, callee_entry,
callee_exit and caller_end. The caller_begin
issues the call by branching to callee_entry, and even-
tually callee_exit returns to the caller by branching to
caller_end.
We note that callee may have multiple callers. As
a result, for an internal function, there is one pair of
callee_entry and callee_exit, but there may be mul-
tiple pairs of caller_begin and caller_end. Figure
5a illustrates an example callee with two callers.
We start by identifying callee_exit. We observe
that callee_exit would normally end with an indi-
rect branch, where the branch address is produced by
caller_begin. Moreover, callee_exit should have
more than one successors (the caller_ends).
We then correlate each caller_end with its
caller_begin. As mentioned previously, the branch
address produced by caller_begin guides the callee
to caller_end. During the CFG recovery, we keep
track of where each constant is generated, which enables
the correlation. As we identify the caller_begins, the
callee_entry is their common successor.
We then use INTCALL as an abstraction for the callee.
The subgraph for the callee is ﬁrst extracted using the
CFG recovery algorithm. For each caller_begin, we
insert an INTCALL, and also replace its branch from
callee_entry to the corresponding caller_end. The
INTCALL, when “executed”, will transfer the control ﬂow
to the callee. For the callee_exit, we insert an INTRET
to replace its indirect branch to caller_ends. The
INTRET, when “executed”, will transfer the control ﬂow
1384    27th USENIX Security Symposium
USENIX Association
back to the caller. Figure 5b illustrates the transforma-
tions.
To make lifting possible, we also need to determine the
number of items popped off and pushed onto the stack
by INTCALL. In the EVM speciﬁcation, these are referred
to as the delta (δ ) and alpha (α) of an operation. For
an INTCALL, they can be interpreted as the number of
arguments and return values.
We note that a sequence of bytecode instructions can
be viewed as a single operation, thus the delta and alpha
value of the sequence computed in the manner shown in 7.
The stack size is initialized to be zero upon entering the
sequence. When the it becomes negative, the sequence
is reading prepositioned values. Delta is therefore set to
the negation of the minimal stack size. The end stack size
indicates the number of values produced by the sequence,
but we also need to account for the values popped off the
stack. Therefore alpha is the end stack size plus the delta
value.
For an INTCALL, we select a path from callee_entry
to callee_exit, and compute its delta and alpha. We
note that in most cases, the return address is the ﬁrst
argument (at the bottom of the initial stack) and will be
popped off eventually, which allows us to fully exhaust
the function arguments.
(a) before callee is extracted
(b) after callee is extracted
Figure 5
delta, stack_size = 0, 0
for bytecode in sequence:
stack_size -= bytecode.delta
delta = min(delta, stack_size)
stack_size += bytecode.alpha
delta = -delta
alpha = stack_size + delta
Code Block 7: Computing the Delta and Alpha of a
Sequence
USENIX Association
27th USENIX Security Symposium    1385
callee subgraphcaller_begin_0callee_entrycallcaller_begin_1callcallee_exitcaller_end_0returncaller_end_1returncaller_begin_0caller_end_0caller_begin_1caller_end_1