For our experiments, the device is Google’s Nexus One.
The operating system is Android 2.1 (codename eclair ).
While Google’s website
[5] lists the speciﬁcations from a
marketing point of view, Table 2 lists the hardware mod-
ules of the device from the operating system’s point of view:
the second column is the internal device driver names of
the diﬀerent modules. Table 3 provides the MTD (Memory
Technology Device) device partition layout , whereas MTD
is the Linux abstraction layer between the hardware-speciﬁc
device drivers and higher-level applications. How fast we
can ﬂash the device depends on the size of the storage each
speciﬁc device equipped with.
In addition to the NAND
device storage, Google’s Nexus One uses a 4GB sd card as
external storage. This works as separated device in the An-
droid operating system and can be mounted as a USB mass
storage device to the desktop system. We will leverage this
hardware design to launch the Phone-to-Computer attacks.
In the manufacture state, the Google’s Nexus One has only
two logical USB interfaces by default, one is the USB mass
storage while the other is the Android ADB Interface. By
modifying the kernel source code with corresponding kernel
compilation options, we enabled other hidden USB interfaces
in the kernel, show in Figure 1.
3. NOVEL INFECTION VECTORS
3.1 Threat Model
To establish basic communication, the both end of the
USB connection are connected via oﬀ-the-shelf USB cables.
In our threat model, we assume an adversary that is al-
ready in control of one end of the USB connection. This is
true for all our three attack scenarios. For instance, in the
Phone-to-Computer attacking scenario, the phone is fully
under the control of the adversary. Moreover, we assume
that the attacker can manipulate any component of the de-
vice, ranging from applications to programmable hardware
components. The victim, in this case the desktop system,
is assumed to have a basic set of device drivers that come
with the installation of the operating system and support
Human Interface Device (HID) installation. Note that this
is not an additional step required to be accomplished by
the adversary. In the case of Computer-to-Phone infection,
we assume the desktop system is compromised. Put it dif-
ferently, we assume that the adversary has already placed
malicious software that runs alongside with the regular le-
gitimate software. The phone is considered intact and in
the default manufacturer state. We only focus on how the
compromised desktop system could infect the phone and
propagate malware while connected through USB to the de-
vice. How the desktop system became comprised is beyond
the scope of this paper. Such exploitation can be accom-
plished via traditional browser exploitation, email phishing,
or buﬀer overﬂow.
For Phone-to-Phone attacks, the attacking device is ma-
nipulated to take over the innocent victim device. Beyond
the full control of the mobile operating system of the at-
359
Hardware
Qualcomm QSX8250 1Ghz
Qualcomm Mobile Station Modem (MSM) SoC
512 MB
512 MB , partitioned as boot/system/userdata/cache and radio
4GB micro SD
Msm qdsp6 onboard processor
5 MegaPixels Sensor s5k3e2fx
Modules
CPU
Mother board
RAM
ROM
External Storage
Audio Processor
Camera
Wiﬁ+BlueTooth+FM Boardcom BCM 4329, 802.11a/b/g/n
Msm ts touchscreen controller, capella
Touch Screen Input
Msm vibrator on board vibrator
Vibrator
AK8973 compass
Digital Compass
Table 2: Google’s Nexus One Hardware Modules.
Simulate as a HID device
Remount+autorun.inf
Malicious content in Sync
USB connection
Figure 2: The Phone-to-Computer Attacks over the USB Connection.
tacking device, the adversary also has to craft a special USB
cable. This cable is used to place the malicious device into
USB host-mode and establish a connection to the the target
phone device. We explain the necessary USB cable modiﬁ-
cations in Section 3.4. Having established a thread model
and listed our assumptions, we detail the steps to accomplish
USB-borne attacks in the following sections.
3.2 Phone-to-Computer Attacks
Upon connection, USB becomes a bidirectional commu-
nication channel between the host (normally a desktop sys-
tem) and the peripheral device. The established belief that
only the master device (i.e the host computer) is poten-
tially capable of taking over the slave device (i.e. the smart
phone) is incorrect. Indeed, an attacker can launch attacks
and transfer malicious programs from a USB peripheral to
the machine that acts as a host. Launching attacks against
the connected desktop system is a new emerging avenue of
exploitation that can be used to spread malware. We demon-
strate this new infection vector by focusing on two general
classes of attacks which have not been introduced previously.
The ﬁrst class takes advantage of the fact that smart
phones have open source operating systems and can pose as
Human Interface Device (HID) peripherals (also called gad-
gets) and connect to the computer. This new functionality
can be leveraged by an sophisticated adversary to cause more
damage than traditional passive USB devices. The second
class of attacks harnesses the capability of the phone to be
automatically mounted as a USB device and automatically
run content. The process of a USB device being mounted is
not a threat on its own. Even having the possible malware
hidden in sd card partition in the device and mounted on
the computer as a USB stick is not a novel attack. However,
being able to identify the operating system on the other side
of the USB connection and prepare an attack payload selec-
tively is a new attack capability. This is because the phone
can arbitrarily control and repeat this mount and unmount
operation within the device.
To demonstrate ﬁrst class of attacks, we developed a spe-
cial USB gadget driver in addition to existing USB com-
posite interface on the Android Linux kernel using the USB
Gadget API for Linux [8]. The UGAL framework helped
us implement a simple USB Human Interface Driver (HID)
functionality (i.e. device driver) and the glue code between
the various kernel APIs. Using the code provided in:
“drivers/usb/gadget/composite.c”, we created our own gad-
get driver as an additional composite USB interface. This
driver simulates a USB keyboard device. We can also sim-
ulate a USB mouse device sending pre-programmed input
command to the desktop system. Therefore, it is straight-
forward to pose as a normal USB mouse or keyboard device
and send predeﬁned command stealthily to simulate mali-
cious interactive user activities. To verify this functionality,
in our controlled experiments, we send keycode sequences to
perform non-fatal operations and show how such a manipu-
lated device can cause damages In particular, we simulated
a Dell USB keyboard (vendorID=413C, productID=2105)
sending ”CTRL+ESC” key combination and ”U” and ”Enter”
key sequence to reboot the machine. Notice that this only
requires USB connection and can gain the ”current user”
privilege on the desktop system. With the additional local
or remote exploit sent as payload, the malware can escalate
the privilege and gain full access of the desktop system.
Another class of attacks are content exploitations. Such
attacks take advantage of media content to exploit vulner-
able softwares that exist in the victim system. These at-
tacks are not new and have been known for quite some
time (e.g. PDF and Flash exploits). However, we show
360
Unlock
Rooting
Install malware
USB connection
Figure 3: The Computer-to-Phone Attacks over the USB Connection.
a new way to accomplish these attacks using the USB con-
nection. In Android devices, in addition to the NAND de-
vice, an sd card works as external storage. This separated
device can be mounted as a USB mass storage device to
the desktop system. There are system-wide options for the
user to set:1, connecting only for battery charging;2, allow-
ing NAND ROM device available to the desktop system via
USB Android Debugging Bridge driver (adb);3, allowing sd
card device available to the desktop system as a USB mass-
storage device. If the last option is set, the sd card device is
automatically mounted by generic USB mass-storage driver
in major commodity operating systems by default bypass-
ing any restrictions. We leverage this platform-speciﬁc ob-
servation to implement the basic attack against the desktop
system. Our malicious program drops an autorun.inf and
the calc.exe to the sd card partition. The next time when
the user want to transfer ﬁles (e.g. movie, photo, mp3 ﬁle
etc), once the sd card is mounted as a partition, the calc.exe
will be executed in our default conﬁguration Windows XP
system [2].
Moreover, unlike the traditional passive USB stick de-
vices, the CPU powered phone as a USB peripheral device
promotes the attacks in a more intelligent manner. As a
starting point, we (the attacker) wrote the malware on the
phone monitoring the USB connectivity. Once the phone is
connected to a desktop system, we probe and identify the
operating system by looking at the URB (USB Requesting
Block) ID in the USB packets. By doing this, we diﬀeren-
tiate the targeted system and avoid brute force approaches.
After the target system is being identiﬁed, using the com-
putational power on the phone, we enumerate the available
vulnerabilities and change the attacking payload with mul-
tiple runs with diﬀerent content. For example, in our con-
trolled experiments, the targeted desktop system is a Win-
dows XP SP3 with a vulnerable version Adobe PDF software
and fully updated JPG parse engine. Our proof-of-concept
malware on the phone will compose the autorun.inf upon
detecting it is a Windows, and launch Windows Picture and
Fax Viewer program to view the special crafted JPG ﬁle
and the PDF program to view the malicious PDF ﬁle we
dropped. We observed the expected result that the malicious
logic in the crafted PDF ﬁle was executed and the Windows
system is compromised. We acknowledge that this depends
on malware-writer’s knowledge on contemporary vulnerabil-
ities. However, the CPU equipped phone device as a gadget
can help malware-writers generate composite malware and
highly infectious code, to achieve higher successful ratio.
For iPhone devices, the strong coupling between iTunes
software and iPhone devices makes such Phone-to-Computer
attacks even simpler. Once the iPhone connected to the
desktop system, the iPhone/iPod Service installed by iTunes
will detect the device and launch iTunes.
iTunes will scan
the media content on the device and make them available
in the iTunes. Since the attacker has the full control of the
device, it can drop any specially crafted media ﬁle (e.g. jpg,
pdf, mp3, mov etc) to exploit the corresponding processing
engine.
3.3 Computer-to-Phone Attacks
In this section, we detail the steps required to take over
a smart phone device when its connected via the USB port
to a computer. A closer look into the attacking process
reveals that it can be decomposed into a sequence of op-
erations. The phone is not unlocked and in manufacture
out-of-box state in terms of installed software. This is usu-
ally true for most of the end-users. To mount the attack, we
take advantage of the open source program fastboot which
can manipulate the boot-loader of the Android phone de-
vices. By issuing the command fastboot oem unlock, the
device will display a warning page and once we click ”yes”,
it is oﬃcially unlocked and the manufacture warranty also
is voided. However, this is far from being inconspicuous and
requires user input. To achieve fully automation, we crafted
a small program to simulate the clicking of yes action. We
do so by sending the touchscreen input event with the corre-
sponding touchscreen coordinators need be pressed directly
via the USB connection. Upon completion of the unlocking
process, we can replace the system images. This means that
all software including kernel, libraries, utility binaries, and
applications are now under our control. The second step is
to do a full system dump from device, so that we can ex-
ﬁltrate all the programs and user information. This can be
used for phishing purposes in addition to creating a backup
of the applications to prevent the user from noticing any
changes in the device.
The entire unlocking and ﬂashing process takes 4 mins
5 seconds on our device and may vary for diﬀerent devices
due to diﬀerent content sizes. To be more speciﬁc, we ﬂash
the recovery partition using a third party modiﬁed recovery
image which provide the functionality that can do a whole
NAND ﬁle system backup based on the partition informa-
tion in Table 3. Such backup covers boot partition, system
partition, userdata partition, and a hash checksum. We dis-
assemble this boot partition dump boot.img to a raw ker-
nel zimage binary ﬁle and corresponding ram-disk ﬁle. The
boot.img ﬁle is composed with the kernel in zimage format,
the compressed ram-disk in gzip format, and the paddings.
The overall layout of the boot.img ﬁle is listed as follows:
0x0-0x7ﬀ: File Magic:”Android!”,kernel size in bytes, kernel
physical loading address, ram-disk size in bytes, ram-disk
361
Dev
mtd0:
mtd1:
mtd2:
mtd3: