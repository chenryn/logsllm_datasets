E. Cross-browser deployment of extensions
In addition to verifying extensions, our approach allows
extensions to be developed in a platform-independent manner.
Our tools include a new code generator that allows us to
compile extension code either to JavaScript or to .NET. This
allows extensions to be authored once in Fine, and deployed
on multiple browsers, including, via JavaScript, in Chrome and
Firefox; via bindings from .NET to native code for Internet
Explorer; and directly in .NET for C3.
In addition to cross-browser deployment, JavaScript code
generation allows our approach to be used in combination
with existing extension security models. In particular, we show
how to verify authorization properties for Chrome extensions
by partially porting their content scripts (the interface of a
Chrome extension to the DOM) from JavaScript to Fine—the
much larger extension core can remain in JavaScript and inter-
operates with code generated from Fine. While such hybrid
approaches are attractive for the ease of use and migration,
the security guarantee in such a conﬁguration is, of course,
weaker; for instance, unveriﬁed extension cores are free to
violate information ﬂow properties.
119
IV. A LANGUAGE FOR FINE-GRAINED POLICIES
This section introduces our policy language, a Datalog-
based framework for specifying ﬁne-grained data conﬁdential-
ity and integrity policies for browser extensions. We present
our policy visualization tool, and discuss how policies may be
analyzed for robustness.
A. Language design
Distinguishing data from metadata: We take the view that
the structure of web content can be interpreted as security
metadata, and can be used to restrict the privilege of extensions
at a ﬁne granularity. As such, we think of page structure as
inducing a kind of dynamic, data-driven, security labeling [35]
on web content. From this perspective, since the extension’s
behavior depends on the metadata of a page,
is most
convenient if the metadata itself can be considered to be not
security sensitive.
it
Determining which elements of semi-structured web content
constitute metadata is a design decision that involves weighing
several factors. In this work, we view elements’ tag-names
and certain attributes (e.g., styles and identiﬁers) as security
metadata that an extension can freely inspect but not modify.
In contrast, the text, links, images, and all other content on a
web page is considered, by default, to be high conﬁdentiality
(secret) and immutable. Extension-speciﬁc policies must ex-
plicitly grant an extension privileges to access or modify non-
metadata content. Our experience indicates that this choice
represents a good balance of concerns—it leads to a familiar
programming model for extensions, while still providing good
protection for a user’s sensitive web content.
Stability of a security policy and the choice of Datalog: An-
other constraint in the design of our policy language is driven
by the execution model for extensions. Speciﬁcally, JavaScript
that appears on the web page can interact with extensions via
shared state in the DOM. Furthermore, while JavaScript and
extension code share a single thread of control, their execution
can be interleaved arbitrarily. A key property that we wish
for our policy language is that the security policies should be
stable. This notion is spelled out in the next section; intuitively,
stability ensures that a well-behaved extension that is deemed
to comply with a policy will never become insecure because
of the actions of unanticipated JavaScript on the web page.
Accounting for these considerations, we choose to base our
policy language on Datalog. We deﬁne a set of predicates to
use with policies, where these predicates reﬂect the structure of
web content. Importantly, Datalog’s restricted use of negation
ensures that policies are always stable.
Figure 5 shows a selection of the predicates we provide. The
ﬁgure is split into two parts, the top showing the predicates
we use to speak about security metadata; the bottom showing
predicates that grant privileges to extensions. Most of the
predicates listed in the ﬁgure are self-explanatory. However, a
few are worth further discussion. The predicates EltTextValue and
EltAttr appear in the metadata section of the ﬁgure. However,
both the text and attribute content of a web page are, by
Metadata predicate
Description
the document, doc has domain string
the element elt is in the doc
p is the parent-element of elt
DocDomain doc string
EltDoc elt doc
EltParent elt p
EltTagName elt tagName elt’s tag-name is tagName
EltTextValue elt v
EltAttr elt k v
EltStyle elt sty
UrlScheme url s
UrlHost url h
UrlQuery url p
FlowsFrom a b
elt’s text-value is v
elt has an attribute k, with value v
elt’s style is sty
url’s scheme is s (e.g., “http:”, “ftp:”, etc.)
url’s host is h
url’s query parameters are p
a was derived from b
Permission predicate
CanReadSelection doc
CanAppend elt
CanEdit elt
CanReadValue elt
CanWriteValue elt
CanWriteAttr elt k v
CanReadAttr elt k
CanStyle sty
CanRequest str
CanFlowTo a b
CanReadHistory site
CanReadFile ﬁle
the extension can determine user’s selection on doc
the extension can append elements to elt
the extension can modify elt
the extension can read the text value of elt
the extension can write text to elt
the extension can write v to the k-attribute of elt
the extension can read the attribute named k on elt
the extension can modify the style sty
the extension can send HTTP requests to url str
the extension is allowed to write a to b
the extension is allowed to read history on site
the extension is allowed to read the local ﬁle
Fig. 5: A selection of the predicates in our policies
default, considered sensitive information. In order to be able
to access the text values and attributes of an element e, an
extension must be granted explicit CanReadValue and CanReadAttr
privileges on e. We show an example of this shortly. Note also
that we provide predicates FlowsFrom and CanFlowTo, which allow
a policy to impose data ﬂow constraints on extensions—this is
particularly important for controlling access to resources such
as browsing history (Section VII-B).
An example policy: The top of Figure 6 shows part of
the policy we use with FacePalm. The ﬁrst rule grants the
extension the ability to read class attributes on all elements in
the page, i.e., class attributes are considered metadata in this
policy. The second rule states that for all elements e that have
their class attribute set to the value ”label”, the extension has
read access to the text content of their immediate children.
The third rule is the most complicated: it states, roughly, that
for a speciﬁc sub-element website of a node tagged with the
”label” attribute and ”Website:” text value, the extension has the
right to read a link stored in the website node.
B. Understanding policies
Extensions are often designed with speciﬁc websites in
mind, e.g., FacePalm’s code closely tied to the structure of a
Facebook web page. Policies, being an abstraction of the code,
can also be closely tied to the page structure. Such policies
can be hard to understand, unless the reader also understands
the structure of the HTML used on the relevant websites.
We provide a visualization tool to assist users with the task
of understanding security policies. Our idea is to interpret
120
(ࢩ Required to select elements by class (i.e., the ”label” class) ࢩ)
1. ࢘e. CanReadAttr e ”class”
(ࢩ Requires to read the label text ࢩ)
2. ࢘e, child. EltParent child e
(ࢩ Permission to read website links ࢩ)
3. ࢘data, label, labelText, website, parent.
&& EltAttr e ”class” ”label”  CanReadValue child
EltParent data parent && EltParent label parent
&& EltParent website data && EltParent labelText label
&& EltAttr label ”class” ”label” && EltTextValue labelText ”Website:”
 CanReadAttr website ”href”
Fig. 6: FacePalm’s policy and its visualization on a Facebook page
predicates in a policy as XML selectors, and to highlight
elements in a web page for which an extension has read or
write access. Our tool takes the form of an extensions for
Chrome and the bottom of Figure 6 shows a screen-shot of this
extension when applied to FacePalm’s policy. Speciﬁcally, it
highlights the elements accessible to FacePalm on a particular
Facebook proﬁle. Various labels such as “Interests”, “Chat”,
“Music”, and “Website:” are highlighted, since the extension
needs to search through the labels until it ﬁnds “Website:”.
The websites on the proﬁle are highlighted, since they are
the data that FacePalm reads and sends to @AE?EKI?.
Most important, consider the data that is not highlighted—
email addresses, phone numbers, likes and dislikes, etc.—this
data is inaccessible to FacePalm, as advertised. Therefore, we
can be conﬁdent that FacePalm is secure when it runs on this
particular web page.
While helpful, visualization is necessarily imprecise and is
not intended to be a substitute for either manual inspection
or formal analysis of the policy. Visualization only renders
the impact of a policy on a particular web page and, as such,
cannot be used to provide complete coverage since visiting
all Facebook pages is impractical. Second, there are elements
of policies which cannot easily be depicted in visual manner,
e.g., information-ﬂow policies.
Robustness of a policy: Visualization is one tool to assist
with understanding and vetting policies. We envisage building
several other useful tools for policy analysis. An advantage of
using Datalog as the basis of our language is the availability of
tools on which to base such analyses. One obvious analysis is
to check for policies that use speciﬁc undesirable patterns. For
example, a policy should not grant an extension the privilege to
modify a page in a way that allows the extension to grant itself
access to protected resources. The following policy illustrates
this undesirable pattern: the attribute (class) that protects access
to an element is mutable by the extension.
࢘e. CanWriteAttr e ‘‘class’’
࢘e,k. EltAttr e ‘‘class’’ ‘‘readable’’  CanReadValue e
Detecting such situations is relatively straightforward since
Datalog policies can be automatically analyzed to enumerate
the set of attributes over which an extension has write privi-
lege. A simple syntactic check to ensure that none of these
attributes ever appear within a metadata predicate ensures
the integrity of security-sensitive metadata. We leave the
implementation of such an analysis to future work.
V. THE SEMANTICS OF SECURITY POLICIES
This section formalizes a core language and execution
model for browser extensions. The distinctive feature of this
model is that the execution of extension code is interleaved
arbitrarily with JavaScript on the web page. We use this
model to provide a semantics for security policies and deﬁne
a safety property for extensions—safe extensions never cause
runtime security failures. In the following section, we show
how reﬁnement type checking can be used to soundly decide
extension safety.
A. BX: A core calculus for browser extensions
The listing below shows the syntax of BX, a (tiny) lambda
calculus that we use to model extensions and their interactions
with the DOM. We also show a syntax () for a model of the
policy language of the previous section. Both BX and  are
to be understood as minimal core models—we leave out many
elements of our practical implementation, including network
access, event handling, local storage, and browsing history.
Syntax of BX and policies 
const. 
values 
expr.

opers. F
policy 
preds. 
if  then  else  
  ࢯ true ࢯ false ࢯ F ࢯ  (string) ࢯ  (nodes)
  ࢯ  ࢯ    ࢯ 
  ࢯ    ࢯ    ࢯ  ࢯ  
ࢯ
 CAJ)JJH ࢯ IAJ)JJH ࢯ CAJ+DE@HA ࢯ IJH-G
  ࢯ ࢘        ࢯ ߰
 2=HAJ    ࢯ -J)JJH    !
ࢯ
ࢯ
+=4A=@)JJH    ࢯ +=9HEJA)JJH    !
.MI.H    ࢯ +=.M6   
Values in BX include variables , constants , pairs, and
lambda abstractions. Expressions additionally include applica-
tion, projection, and conditional forms. Constants include the
unit value, booleans, identiﬁers  (which we use as abstract
handles to DOM nodes), and string literals (for attributes of
DOM nodes). The primitive operators of BX are the most
interesting parts. These include CAJ)JJH and IAJ)JJH to access
and mutate the attributes of a node; CAJ+DE@HA to traverse
the DOM (modeled as a binary tree of nodes); and IJH-G for
primitive equality on strings.
121
A policy  is a ﬁnite list of Horn clauses. The base predi-
cates  are drawn from the ontology of Figure 5. Importantly,
in order to establish a connection between BX programs and
their policies, the base predicates of  are deﬁned over the
(ﬁrst-order) values of BX.
To relate the syntax of our core language to our other
examples, we reproduce the extension code from Section III-D
below and show its BX version.
(ࢩ In Fine ࢩ)
let extensionCode (e:elt) =
if tagName e = "div" && getAttr e "class" = "website"
then textContent (ﬁrstChild e) else ""
(ࢩ In BXࢩ)
if IJH-GCAJ)JJH “tagName” “div”
then if IJH-GCAJ)JJH “class” “website”
then CAJ)JJHCAJ+DE@HA  “textContent”
else ””
else ””
B. Dynamic semantics of BX
This section presents a dynamic semantics for BX programs
governed by  policies. Our semantics is carefully designed to
account for the possibility of interleavings between untrusted,