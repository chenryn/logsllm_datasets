Internet
Explorer
10.0.9
Firefox
19.0
Chrome
26.0
Safari
5.1.4
Android
Built-in
Browser 4.2
Dolphin
9.1.0
200
199
200
200
200
20
20
200
200
199
20
20
1
0
0
1
0
0
200
200
200
200
200
20
20
198
200
199
20
20
0
2
0
1
0
0
V. COUNTERMEASURES
The most straightforward countermeasure to cache-based
attacks is simply to turn the caching off. This will completely
prevent the attacks, but also incur an unacceptable perfor-
mance penalty. In fact, nearly 60% of HTTP queries are
requests for resources which are cacheable [30]. Obviously,
to turn off caching is an impractical defense approach.
Alternatively, Jackson et al. implemented a Firefox extension
SafeCache to prevent timing attacks by enforcing a same-
origin policy on the browser cache [19]. The extension
overrides the browser’s default caching service such that
the browser cache is partitioned and isolated for different
domains. SafeCache can provide effective defense for both
traditional timing attacks and scriptless timing attacks. But,
unfortunately, it has not been adopted by browser vendors
and is not available for more recent Firefox versions. We
believe that browser vendors should adopt the technique as
a built-in security feature, although it may introduce some
storage overhead.
Our method exploits some CSS features instead of exe-
cuting scripts. By removing the support of the features in
browsers, this scriptless attack can be prevented. However,
abandoning such features completely may be unacceptable
for web application developers and users. A possible tradeoff
is to properly limit the capability of the features. For exam-
ple, for CSS scrollbar customization, we can design a same-
origin policy on the container’s content to block suspicious
requests sent using scrollbar customizations. Speciﬁcally,
the requests are allowed to issue only when they are sent
to the same domains with the contents embedded in the
container. Taking the attack pages in Section III as examples,
if the requests triggered by the increment track pieces can
only are sent to the embedded contents’ original website
(i.e., www.nsf.gov). Consequently, nothing will be leaked to
the attackers. But, unfortunately, for the attacks using CSS
media queries, the defense is ineffective. In fact, there is
not a direct relationship between the media queries used to
send request and the target resource. It is very difﬁcult, if
not impossible, to ﬁnd an appropriate rule to identify the
suspicious requests. Essentially, this kind of attack is relied
on the fact that the browsers load non-cached resources in a
certain order, i.e., the objects placed on the top of the attack
page is often loaded and rendered prior to the other ones. If
we can make the browsers to load non-cached resources in a
random order, the false negative of comparison-based attacks
may be dramatically increased. We think that a feasible
mitigation technique with low overhead could be developed
based on the approach.
VI. DISCUSSION
A natural concern is whether an image query on search
engines, e.g., Google, can introduce false positives. If the
target image is presented in the result page when users
perform an image search, it may be stored in the cache. In
fact, queries against search engines almost do not introduce
false positives in our method. In general, when searching
images, the sample images presented in the result pages
returned from the search engine are not the original images.
For example, the sample images provided by Google are
the thumbnails of original images, which are generated by
Google and stored on their servers. If a user doesn’t view
the original image, it will not be cached by the browser.
Furthermore, attackers can choose some images that are
hardly hit by search engines as the snifﬁng objects, such
as the background images of web pages. Normally,
the
semantic relationship between the background image and the
page content is very weak. In other words, even the users
query images with the keywords related to the target URL,
the background image is very unlikely to be touched.
Older history stealing attacks exploiting browser bugs
could probe tens of thousands of sites within a few minutes,
but now lack effectiveness since these bugs are ﬁxed. As
a timing attack, our method inevitably takes longer time
to probe a target site. However, in many cases, attackers
may just need to know whether the victim has visited a
limited number of sites: a site may only want to inspect
121121121
whether users have visited several competitors’ sites. The
additional experiment shows our approach can probe dozens
of URLs within a few minutes. Our attack approach is
efﬁcient enough for this kind of attack scenario.
Besides,
it should be noted that
there may be some
other browsers’ features which can be exploited to inspect
resources loading and rendering. With more dynamic and
interactive features introduced in browsers at present, we
believe that more exploitable features will be available.
VII. RELATED WORK
History snifﬁng attacks have recently received signiﬁcant
attention. Given the users’ browsing histories, the attacker
can cause extensive damage [20, 31].
The most widespread history snifﬁng technique is the
CSS-based attack that leverage CSS markups to determine
which websites have been visited by users in the past [14].
The attacks have proven effective and efﬁcient. The study of
Janc et al. [21] has shown that this technique can be used to
detect browser history on a large scale. CSS-based history
snifﬁng is documented as bug reports by many browsers,
e.g., Bug 57351 reported in Mozilla Firefox [27]. The history
stealing attacks exploiting browser bugs could probe tens
of thousands of sites within a few minutes, but now lack
effectiveness since these bugs are ﬁxed. To ﬁx these bugs,
Baron of Mozilla Corporation composes a solution [10] that
blocks CSS-based attacks by making the computed style
APIs pretend that all links are unvisited. All mainstream
browsers, including Firefox, Chrome, Safari and IE, have
adopted this solution. As a result, this kind of history snifﬁng
is no longer operational
in the latest versions of these
browsers. As a timing attack, our method may take longer
time to probe a target site. However, in many cases, attackers
may just need to know whether the victim has visited a
limited number of sites: a site may only want to inspect
whether users have visited several competitors. Our attack
approach is efﬁcient enough for this kind of attack scenario.
Another general technique of history snifﬁng is deﬁned
under the umbrella of side channel attacks. These can
be used to leak private information while bypassing the
system’s security policy. They are difﬁcult to ﬁnd and often
cannot be eliminated without destroying other desirable
characteristics of the system [16].
Among all the types of side channel attacks, timing attacks
proposed by Felten and Schneider [15] are the ones most
well-known. The attacks rely on the fact that the load time
of the resource in web page can indicate whether it hits
in browser cache. Because the cache is global, the third-
party website can also acquire knowledge about whether
some sources cache in browsers by measuring the load time.
Similarly, Bortz and Boneh displayed how to use timing
attacks to expose private information from web applications
[11], and Michal presented an attack method that combines
the same-origin policy with cache-based timing attacks [26].
122122122
Brewster has shown another attack approach in his study
[12]. For those sites in which users likely remain logged for
a long period (e.g., Facebook), some resources are usually
only available for those logged-in users. If an attacker can
get one of those resources’ URL, he or she can attempt
to load it and use the JavaScript onerror event to get the
error information. From these errors, it is possible to extract
the information about whether or not a user is logged
in certain websites. Besides utilizing page caching, some
researchers also conduct history snifﬁng by utilizing DNS
caching [17, 23] or cached cookies [15]. For example, the
prefetch DNS technique allows some popular browsers, such
as Firefox and Chrome, to reveal the search entry made by
users [23]. As DNS cache can be shared in local network,
attackers can also get its content by making queries of it
[17]. In addition, timing attacks have also been used in some
other domains. For example, Chen et al. have demonstrated
the side-channel leaks in popular web applications based on
timing attack [13].
Timing attack is by no means the only type of side-
channel attacks. Weinberg et al. discovered that attacker can
utilize users’ webcam to sniff their browsing histories [29].
However, the attack is very difﬁcult to exploit in practice.
They also proposed an approach of stealing browsing history
via user interactions. Compared with it, our method does not
need the users to perform certain operations when browsing
attack pages.
To the best of our knowledge, all the attacks on users’
browsing histories really happened in recent years, including
CSS-based and timing attacks, are script-based. Due to
serious threats posed by client-side scripts, many defense
techniques have been proposed to block the execution of
suspicious scripts in user’s browsers [1, 4, 5, 7, 24, 28].
Recently, Heiderich et al. put forward a new attack tech-
nique called scriptless attack [18], and Zalewski presented
some alternatives to direct script injection [32]. Based on
these studies, the attacker can steal sensitive page contents
without executing scripts via abusing legitimate browser
characteristics, such as some CSS3 features. Our research
is inspired by their studies. The greatest distinction between
our work and the method proposed by Heiderich et al. lies in
we exploit CSS features in different ways and for different
purposes. In our work, CSS features are employed as a
timing measure tool, not a page content extractor. Compared
with their work, we demonstrate that CSS features can be
leveraged to sense out-of-page sensitive information rather
than only the within-page content.
VIII. CONCLUSION
In this paper, we presented a new timing attack method
for snifﬁng users’ browsing histories. What differentiates our
approach from the existing attack methods is a non-reliance
on the execution of client-side scripts and can be applicable
to modern browsers. We found that three CSS features, i.e.,
CSS animation, scrollbar customization, and media queries,
can be exploited to monitor the rendering process of a
resource. This provides an indirect but effective way to
determine whether a resource exists in the browser cache.
Combining these CSS features with selected standard brows-
er features, we have developed three practical attack vectors.
We examined the effectiveness for desktop and mobile
computer systems by applying them to six popular browsers,
including IE, Firefox, and four Webkit-based browsers in
our evaluation. The experiment results show that the three
attack vectors can effectively sniff users’ browsing histories.
Especially by using media queries, the attack vector can
be applied to all six popular browsers with very low false
positive and false negative rates. Our research demonstrated
that browsers are still suffering serious browsing histories’
leakage threats even when they are protected by scripts’
blocking tools.
In the future, we will perform an elaborated investiga-
tion to reveal additional exploitable browser mechanisms.
With more dynamic and interactive features introduced in
browsers in present
times, we have reasons to believe
that more exploitable features will emerge, needing prompt
identiﬁcation and subsequent defense approaches.
ACKNOWLEDGMENT
The authors would like to thank the anonymous review-
ers for their insightful comments. The work is supported
by National Natural Science Foundation of China (NSFC)
under grants 61170240 and 61070192, and the National
Science and Technology Major Project of China under grant
2012ZX01039-004.
REFERENCES
[1] “Content Security Policy,”
http://www.w3.org/TR/2011/
WD-CSP-20111129/.
[2] “CSS,” http://www.w3.org/Style/CSS/.
[3] “CSS3,” http://www.w3.org/Style/CSS/current-work.en.html.
[4] “HTML5
http://www.w3.org/TR/
Sandbox,”
IFrame
2011/WD-html5-20110525/the-IFrame-element.html#
attr-IFrame-sandbox.
[5] “JavaScript Blocker
for Safari,” http://javascript-blocker.
toggleable.com/.
[6] “McDonald’s, CBS, & Microsoft Mine Data from Web Ads,
Class Claims,” http://www.courthousenews.com/2010/12/27/
32877.htm.
[7] “NotScripts
https://chrome.google.com/
webstore/detail/notscripts/odjhifogjcknibkahlpidmdajjpkkcfn.
[8] “Statement by FTC Bureau of Consumer Protection Director
David Vladeck Regarding Judges Approval of Google Safari
Settlement,” http://www.ftc.gov/opa/2012/11/google.shtm.
Chrome,”
for
[9] “YouPorn Sued for Snifﬁng Browser History,” http://news.
cnet.com/8301-30685 3-20024696-264.html.
[10] D. Baron, “Preventing attacks on a user’s history through CSS
:visited selectors,” http://dbaron.org/mozilla/visited-privacy.
[11] A. Bortz and D. Boneh, “Exposing private information by
timing web applications,” in WWW, 2007, pp. 621–628.
[12] K. Brewster, “Patching privacy leaks,” http://kentbrewster.
com/patching-privacy-leaks/.
123123123
[13] S. Chen, R. Wang, X. Wang, and K. Zhang, “Side-channel
leaks in web applications: A reality today, a challenge tomor-
row,” in IEEE Symposium on Security and Privacy, 2010, pp.
191–206.
[14] A. Clover, “CSS visited pages disclosure,” http://seclists.org/
bugtraq/2002/Feb/271.
[15] E. W. Felten and M. A. Schneider, “Timing attacks on web
privacy,” in ACM Conference on Computer and Communica-
tions Security, 2000, pp. 25–32.
[16] V. Gligor, “A guide to understanding covert channel analysis
of trusted systems,” National Computer Security Center, Tech.
Rep., 1993.
[17] L. Grangeia, “DNS cache snooping or snooping the cache
for fun and proﬁt,” SideStep Seguranca Digitial, Tech. Rep.,
2004.
[18] M. Heiderich, M. Niemietz, F. Schuster, T. Holz, and
J. Schwenk, “Scriptless attacks: stealing the pie without
touching the sill,” in ACM Conference on Computer and
Communications Security, 2012, pp. 760–771.
[19] C. Jackson, A. Bortz, D. Boneh, and J. C. Mitchell, “Protect-
ing browser state from web privacy attacks,” in WWW, 2006,
pp. 737–744.
[20] M. Jakobsson and S. Stamm, “Invasive browser snifﬁng and
countermeasures,” in WWW, 2006, pp. 523–532.
[21] A. Janc and L. Olejnik, “Feasibility and real-world implica-
tions of web browser history detection,” in Web 2.0 security
and privacy conference, 2010.
[22] D. Jang, R. Jhala, S. Lerner, and H. Shacham, “An empirical
study of privacy-violating information ﬂows in javascript
web applications,” in ACM Conference on Computer and
Communications Security, 2010, pp. 270–283.
[23] S. Krishnan and F. Monrose, “DNS prefetching and its
privacy implications: when good things go bad,” in USENIX
Conference on Large-scale Exploits and Emergent Threats,
2010.
[24] G. Maone, “NoScript for Mozilla Firefox,” https://addons.
mozilla.org/de/ﬁrefox/addon/722/.
[25] J. R. Mayer and J. C. Mitchell, “Third-party web tracking:
Policy and technology,” in IEEE Symposium on Security and
Privacy, 2012, pp. 413–427.
[26] Michal, “Rapid history extraction through non-destructive
cache timing,” http://lcamtuf.coredump.cx/cachetime/.
[27] J. Ruderman, “CSS on a:visited can load an image and/or
reveal if visitor been to a site,” https://bugzilla.mozilla.org/
57351.
[28] S. Stamm, B. Sterne, and G. Markham, “Reining in the web
with content security policy,” in WWW, 2010, pp. 921–930.
[29] Z. Weinberg, E. Y. Chen, P. R. Jayaraman, and C. Jackson, “I
still know what you visited last summer: Leaking browsing
history via user interaction and side channel attacks,” in IEEE
Symposium on Security and Privacy, 2011, pp. 147–161.
[30] A. Wolman, G. M. Voelker, N. Sharma, N. Cardwell,
M. Brown, T. Landray, D. Pinnel, A. R. Karlin, and H. M.
Levy, “Organization-based analysis of web-object sharing and
caching,” in USENIX Symposium on Internet Technologies
and Systems, 1999.
[31] G. Wondracek, T. Holz, E. Kirda, and C. Kruegel, “A prac-
tical attack to de-anonymize social network users,” in IEEE
Symposium on Security and Privacy, 2010, pp. 223–238.
[32] M. Zalewski, “Postcards from the Post-XSS World,” http://
lcamtuf.coredump.cx/postxss/.