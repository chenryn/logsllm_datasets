3.   The flow that PSP objects to might, under further analysis, not be a threat to
the system.
The definition of PSP and information flow gave a hint at what a security property
is.  The definition of PSP was done by indicating what elements must be present in the low
level equivalent bunch for a low level observation t
security properties:  A security property indicates what traces must be consistent with  a
low level observation t
the low level equivalent bunch of traces.  The security property ensures that certain traces
low.  In other words, the low level user observing t
low.  We can generalize this to cover all
low can determine
are present in this bunch.  Therefore, the low level user cannot distinguish which of these
traces has occurred.
Definition 4.7: Security Properties
A  system  satisfies  a  security  property  if  and  only  if  all  low  level
equivalent bunches satisfy the security property predicate P.  Formally,
- 33 -
e
t:traces(S)|L(cid:215) P(Blow(t ,S))
We will write P(S) to indicate that system S satisfies property P.
A security property will ensure that certain traces are in the low level  equivalent
bunch.    This  is  not  to  imply  that  other  traces  may  not  be  present  in  this  bunch.  For
example, if property P1 implies property P2 and the component is known to satisfy P2, then
it may also satisfy P1, but this is not guaranteed.  The property specifies what must occur.
All other traces are coincidental and can vary from component to component.
For each security property there exists a bunch of traces that are guaranteed to be
consistent with t
the  property  has  been  expressed.    The  following  definition  will  be  used  to  identify  this
low.  As will be shown, constructing this bunch is a simple procedure once
bunch.
Definition 4.8: Guaranteed low level equivalent bunch
We  will  write  GP(t ,S)  to  identify  the  bunch  of  traces  that  property  P
guarantees will be present for trace t  in System S.  We will write Gp(t ) if
the system to which we are referring to is obvious from the context.
This bunch should not be confused with the bunch Blow(t ,S).  Blow(t ,S) gives the
bunch of all traces with the same low level events.  Gp(t ,S) is the bunch of traces that are
required to be present in the set T of the system for the system to satisfy P.  Clearly, if a
system S satisfies a property P, Gp(t ,S) : Blow(t ,S)
We have been deliberately vague about how security properties can be expressed.
Beginning in the next section we examine some of the security properties that have been
presented  in  the  literature.    This  discussion  will  be  used  to  demonstrate  how  security
properties  can  be  expressed.    The  security  properties  that  we  shall  present  here  and
analyze in Chapter 5 are intended to illustrate the power of our framework and how other
frameworks and ad hoc approaches to security fail.
4.4.1. Noninference
Noninference  was  introduced  by  O’Halloran  [O’Halloran90].    It  attempts  to
separate  the  low  level  activity  from  the  high  level  activity.    Informally,  Noninference
- 34 -
"
requires that for any trace of the system removing all high level events results in a trace
that is still valid.
Noninference is too strong for systems that have a high level output without a high
level  input.    As  an  example  consider  a  system  the  only  function  of  which  is  to  keep  a
journal of all low level events on a high level device.   This system is secure.   The low
level user does not know anything  about  what  high  level  users  are  doing.    This  system,
however, does not satisfy the Noninference property.
McLean [McLean94] extends Noninference as follows.  For any trace t , it must be
 has
 and s
possible to find another trace s
no high level inputs.  McLean calls this stronger property Generalized Noninference.
 such that the low level events of t  are equal to s
Consider the following:
:traces(S)|L(cid:215) GN(Blow(t ,S))
GN( B ) ”
 $ t:B(cid:215) t|HI=<>
This satisfies the definition of a security property.  The GN predicate ensures that
the trace without any high level  inputs  is  always  possible  for  any  low  level  observation.
Therefore, for all possible low level observations a trace can be found with the same low
level events but with no high level inputs.
In the chapters that follow it will be required to determine all the traces that  are
guaranteed to be indistinguishable to the low level user. For Generalized Noninference this
bunch can be expressed as:
GGN(t ,S) = §s:traces(S)(cid:215)
(cid:215) s|L = t
|L (cid:217)  s|HI = <>
4.4.2. Noninterference
Noninterference  is  a  security  property  introduced  by  Goguen  and  Meseguer
[Goguen & Meseguer82] [Goguen & Meseguer84].  It captures the attractive notion that
system security is preserved whenever high level users are prevented from influencing the
behaviour  of  low  level  users. 
  Goguen  and  Meseguer’s  original  definition  of
Noninterference  was  only  applicable 
to  deterministic  systems. 
  McCullough
[McCullough87] [McCullough88] extended the definition to encompass non-deterministic
systems.
- 35 -
"
t
McCullough's  definition  of  Generalized  Noninterference  (GNI)  can  be  informally
defined as follows:  Given a trace t , modifying it by inserting or deleting high level inputs
results  in  a  sequence s
,  which  is  not  necessarily  a  valid  trace.    This  is  referred  to  as  a
' from s
perturbation of t .  It must be possible to construct a valid trace t
deleting high level outputs.  This is called a correction to the perturbation.
 by inserting or
We will now formally define Generalized Noninterference.
GNI( A ) ”
 "
:traces(S)|L(cid:215)
t:interleave(HI*,t
(cid:215)  GNI(Blow(t ))
low)(cid:215)
$ s: A(cid:215) t=s|(L¨ HI)
To  simplify  the  presentation  of  the  GNI  predicate,  we  used t
low  to  represent  the
low level trace.  This can be extracted from any member of A.
Once  the  security  predicate  has  been  written  the  bunch  of  traces  that  are
guaranteed to look like a particular trace t
GGNI(t ,S) = §s:traces(S)(cid:215)
low to the low level user can be formed:
|L)(cid:215)  s|(L¨ HI) = t
$ t:interleave(HI*,t
4.4.2.1. Forward Correctability
The  above  definition  of  Generalized  Noninterference 
is  different 
than
McCullough’s  original  definition.    The  above  definition  allows  a  correction  to  a
perturbation to occur at any point in the trace, even before the perturbation.  McCullough
called the possibility of correcting before the perturbation a “violation of causality.”  We
will show in section 7.5.1 that this violation can only occur in a non-deterministic system.
We can also define a causal or Forward Correctable version of GNI where corrections can
only  occur  after  the  perturbation.  Unless  otherwise  specified  when  referring  to
Generalized Noninterference we will refer to the one defined in the previous section.
4.4.3. Non-Deducible Output Security
The previous two examples were of security properties are founded on the notion
of preventing a LLU from deducing anything  about  high  level  inputs.    Our  definition  of
security is not limited to this type of security.  To illustrate a different form of security we
present Guttman and Nadel's Non-Deducible  Output Security [Guttman & Nadel88].  In
this example we start with the formal description of the property and demonstrate how it
can be analyzed.  Non-Deducible Output Security can be expressed as:
- 36 -
"
t
(cid:215)
NDO(A) ”
 "
t:traces(S)(cid:215) t|LI=t
:traces(S)|L(cid:215)
(cid:215) NDO(Blow(t ))
low|LI(cid:222)
s: A (cid:215) s|(H¨ LI)=t|(H¨ LI)
Once again we have used t
low to simplify the notation.  This can be extracted from
any trace of the bunch A.
The analysis of a property begins by writing the security property in a form where
it is obvious which traces look like a trace t  to a LLU.
GNDO(t ,S) = §s:traces(S)(cid:215)
If the LLU sees a trace t
(cid:215) t|LI=t
$ t:traces(S)(cid:215)
low he can determine the bunch Blow(t
 s|L=t|L (cid:217)
|LI (cid:217)
 s|(H¨ LI) = t|(H¨ LI)
low,S).  All of these
traces are indistinguishable to a low level user from a trace s that has the same low level
events as t  but the high level events come from another trace that has the same low level
input  events.    Since  the  low  level  user  cannot  determine  which  high  level  events  were
chosen  the  observation  of  t
outputs.  Furthermore, since the merging was performed arbitrarily, the low observation is
low  gives  the  user  no  new  information  about  high  inputs  or
also compatible with all interleavings and so give no information about which interleaving
occurred.
Output Non-Deducibility cannot be expressed in McLean’s Selective Interleaving
Framework.  This property is not the interleavings of two traces (see section 6.2).
4.4.4. Separability
Separability is an example of perfect security [McLean94].  Separability is perfect
security because no interaction is allowed between high level and low level events.  It is
like having two separate systems, one running the high level processes and one running the
low level processes.  Separability can be defined as follows.  For every pair of traces t 1
and t 2 the trace t  such that t
|H=t 2|H is a valid trace.
|L=t 1|L and t
No matter what the low level user observes, every possible sequence of high level
events is possible.  Therefore, the low level user cannot gain any new information.
This property can be formalized as:
:traces(S)|L(cid:215)
SEPARABILITY( A ) ”
GSEPARABILITY(t ,S) = §s:traces(S)(cid:215)
(cid:215)  SEPARABILITY(Blow(t ))
t:traces(S)|H(cid:215) interleave(t,t
 "
$ t:traces(S)|H(cid:215)
(cid:215) s|L=t
low):A
low(cid:217) s:interleave(t,t
low)
- 37 -
"
t
$
(cid:215)
"
t
(cid:215)
4.5.  Comparing Security Properties
Before  we  can  compare  security  properties  we  must  decide  what  it  means  to
compare them.  Consider any component C1 that satisfies property P1 and any component
C2 that satisfies P2.  We can ask does C1 always satisfy P2?  If it does then property P2 is
4. If neither is true then
weaker than P1.  If C2 always satisfies P1 then P1 is weaker than P2
P1  and  P2  are  not  comparable.    By  performing  the  above  comparison  between  all
properties a partial ordering of properties can be constructed.
Our formalism provides a mechanical method of evaluating the relative strengths of
security properties.  Since we have a logical expression for our properties the comparison
is simple.  To compare properties P and Q evaluate P(cid:222) Q and Q(cid:222) P.  If the first statement
is true then P is stronger then Q.  If the second statement is true then Q is stronger than P.
If both are true the properties are equal and if neither is true they are not comparable.
compare  Generalized  Noninference 
to  Generalized
Example 4.2: We  will 
Noninterference:
We 
reproduce 
Noninterference here:
the  definition  of  Generalized  Noninference  and  Generalized
GNI( B ) ”
 "
GN(B)= $ t:B(cid:215) t|HI=<>
t:interleave(HI*,t
low)(cid:215)
$ s:B(cid:215) t=s|(L¨ HI)
First we will show that GNI implies Generalized Noninference:
= "
:traces(S)|L(cid:215) GNI( Blow(t ,S) )
:traces(S)|L(cid:215)
low)(cid:215)
t:interleave(HI*,t
$ s:Blow(t ,S)(cid:215)
:traces(S)|L(cid:215)
t =s|(L¨ HI)
:traces(S)|L(cid:215)
$ s:Blow(t ,S)(cid:215)
|L = s|L (cid:217)
 t
$ s:Blow(t ,S)(cid:215)
:traces(S)|L(cid:215)
|HI = s|HI
:traces(S)|L(cid:215)
$ s:Blow(t ,S)(cid:215) <> = s|HI
:traces(S)|L(cid:215) GN( Blow(t ,S) )
= "
= "
= "
Now we show that Generalized Noninference does not imply GNI:
Definition of GNI
$ s:Blow(t ,S)(cid:215) t=s|(L¨ HI) Specialization with t=t
Distributive
Definition of Blow(t ,S)
t  has no high level events
Definition of GN
|HI = s|HI
:traces(S)|L(cid:215) GN( Blow(t ,S) ) (cid:222)
 "
:traces(S)|L(cid:215) GNI( Blow(t ,S) )
Definition of GNI & GN
4 
If both cases are true then P1 is equal to P2.
- 38 -
"
t
t
"
(cid:222)
"
t
(cid:222)
"
t
t
t
t
t
t
"
t
t
:traces(S)|L(cid:215)
$ s:Blow(t ,S)(cid:215) s|HI  = <> (cid:222)
:traces(S)|L(cid:215)
t:interleave(HI*,t
low)(cid:215)
$ s:Blow(t ,S)(cid:215) t=s|(L¨ HI)
$ s:Blow(t ,S)(cid:215) s|HI  = <>  (cid:222)
Specialization such that t|HI„ <>
 HI )
Distributive, Definition of Blow(t ,S) and the Specialization condition