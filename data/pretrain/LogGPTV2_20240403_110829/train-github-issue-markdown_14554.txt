### Bug report
**Bug summary**
Details copied from here, as I believe this is a bug:
I understand that `constrained_layout` is still experimental in `matplotlib`,
nevertheless, I found this odd behaviour, which I guess is a bug and I wonder
how to circumvent it.
If you run `re_add_colorbar_axes_as_subplot` with `constrained_layout=False`,
there are no complaints, but if you set `constrained_layout=True`, it raises
`TypeError: int() argument must be a string, a bytes-like object or a number,
not 'Axes'`, which is traced back to the following line in
`matplotlib.axes.SubplotBase`:
    s = str(int(args[0]))
Per the documentation, you can see that `SubplotBase` expected something
completely different:
        *args : tuple (*nrows*, *ncols*, *index*) or int
        The array of subplots in the figure has dimensions ``(nrows,
        ncols)``, and *index* is the index of the subplot being created.
        *index* starts at 1 in the upper left corner and increases to the
        right.
So I wonder what went wrong here by using constrained layout and the axes
auto-generated by the `colorbar`-method, because if you re-add a subplot the
same way, there is no issue.
The reason why I'm going through this trouble is because I would like the
colorbar axes to be added to the figure as a separate `AxesSubplot` instance,
and not just as a 'regular' `Axes` instance. I know you can pass the optional
`cax` argument to the `colorbar`-method which allows you to determine which
axes the colorbar is plotted in, as demonstrated in
`add_another_subplot_fist`, but I don't know how I can get this to look
properly.
**Code for reproduction**
    import matplotlib.pyplot as plt
    import numpy as np
    def re_add_colorbar_axes_as_subplot(image, constrained_layout=False):
        fig, ax = plt.subplots(constrained_layout=constrained_layout)
        image_artist = ax.imshow(image)
        colorbar = fig.colorbar(image_artist)
        colorbar.ax.remove()
        colorbar.ax.figure = fig  # not sure why this is actually necessary either
        fig.add_subplot(colorbar.ax)
        fig.show()
    def use_gridspec_keyword(image, constrained_layout=False):
        fig, ax = plt.subplots(constrained_layout=constrained_layout)
        image_artist = ax.imshow(image)
        colorbar = fig.colorbar(image_artist, ax=ax, use_gridspec=True)
        print(colorbar.ax)  # AxesSubplot instance if constained_layout=False,
        # Axes instance if constrained_layout=True
        fig.show()
    def add_another_subplot_fist(image, constrained_layout=False):
        fig = plt.figure(constrained_layout=constrained_layout)
        ax = fig.add_subplot(121)
        image_artist = ax.imshow(image)
        ax2 = fig.add_subplot(122)
        fig.colorbar(image_artist, cax=ax2)
        # conversely, there is no problem when using constrained layout
        # and re-adding this subplot
        # ax2.remove()
        # ax2.figure = fig
        # fig.add_subplot(ax2)
        fig.show()
    if __name__ == '__main__':
        image = np.random.uniform(0, 1, (100, 100))
        # re_add_colorbar_axes_as_subplot(image, True)
        # add_another_subplot_fist(image, True)
        use_gridspec_keyword(image, True)
**EDIT**
Ok, I just realized that you can pass the `use_gridspec` keyword to the
`colorbar`-method. From the docs:
> If cax is None, a new cax is created as an instance of Axes. If ax is an
> instance of Subplot and use_gridspec is True, cax is created as an instance
> of Subplot using the gridspec module.
But for some reason, this keyword seems to be ignored when using constrained
layout.
**Matplotlib version**
  * Operating system: Windows 10 Home 64bit
  * Matplotlib version: 3.1.3 (via Anaconda)
  * Matplotlib backend: backend_interagg
  * Python version: 3.7.7