Halt failures 
are mainly unlogged, 
i.e., 75.3%. Most 
of them result from (i) the DataWri terlmpl and 
Publisherlmpl DDS modules (16.4%), 
due to the bad 
or filesystem 
5http://download
6http://www
.coflight-efdp.com 
.ociweb.com/OpenDDS/ 
978-1-4244-7501-8/10/$26.00 
©2010 IEEE 
461 
DSN 2010:  Cinque 
et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:05 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFIP 
International 
Conference 
on Dependable 
Systems & Networks (DSN) 
Table 3: Experimental 
F=Failures, 
L=logged, 
Sub=Subscriber) 
results 
(DDS). (Locs=Locations, 
UL=unlogged, 
Pub=Publisher, 
Pub 
Sub 
L UL  L UL 
Fault Locs  F 
516  302 123 179 126 176 
OMFC 
OMIEB  151  115  29 86  79 36 
26  19  I I   8  12 7 
OMLAC 
OMLPA  965  511 202 309 191 320 
OMVAV  307  172  61 I I I  71 101 
I  2 
OWAEP  10 
OW VAV  89  55  14 41  34 21 
OMIA 
223  138  57 81  48 90 
OMIFS  175  97  40 57  41 56 
3 2 
OMLOC 
OMVAE  171  115  37 78  56 59 
OMVI V   122  68  27 41  26 42 
OWPFV  198  105  43 62  30 75 
Total  2,964 1,705 6471,058 718 987 
(0/0) 
I I   5 
2  3 
I  2 
Pub or Sub 
UL 
131 
20 
2 
L 
171 
95 
17 
288 
107 
223 
65 
I 
15 
68 
35 
I 
49 
29 
53 
692 
40.6 
2 
40 
70 
62 
4 
66 
39 
52 
1,013 
59.4 
- 37.9 62.1 42.157.9 
3 
-
100"/0 ,-- -.-,----,---,----
,----,-
80% 
305 
60% 
678 
40% 
20% 
407 
222 
75 
18 
D unlogged 
Dlogged 
halt 
silent content 
(a) Publisher. 
100"/0 ,----.-,----,---,----,-----,-
80% 
60% 
40% 
20% 
467 
433 
433 
279 
87 
D unlogged 
Dlogged 
halt  silent content 
(b) S ubscri ber 
Figure 6: Experiments 
breakup by failure 
class (DDS). 
of the topic of the DDS 
due to the bad manipulation 
message. Unlogged silent 
within (i) the lower DDS transport 
due to the bad manipulation 
Service_Participant 
failures 
DDS module (13%). 
(42.8%) mainly occur 
layer (18%), mainly 
of the send buffer, and (ii) the 
failures 
are delivered 
Content 
messages 
notification. 
We similarly 
analyze 
are mostly un logged (80.7%). 
Corrupted 
to the subscriber 
side without 
any 
the subscriber 
lead to an effective 
side (Table 3). We 
notification 
find that 42.1 % of failures 
in logs vs. the 37.9% of the publisher 
these percentages 
different, 
the experiments 
as described 
are similar, 
broken down by failure 
are partially 
Halt failures 
class. 
side. Although 
the logging behavior 
is 
in the following.  Figure 
6b reports 
logged (48.1 %). As in the pub­
process 
of a bad QoS setup 
most of them (7%) are the result 
DDS module. Further­
is able to log a significant 
lisher, 
within the Service_Participant 
more, the subscriber 
centage 
of halt failures 
side, thus acting as an external 
halt failures 
in the Service_Participant module (12%), which still 
remains 
(51.2%) are mainly due to problems 
(18%) that occurred 
a significant 
Unlogged 
occurring 
at the publisher 
detector. 
failure 
source of un logged halt failures. 
(39.2%) of silent failures 
percentage 
A significant 
are 
per­
related 
is able to log silent 
of topics and headers 
the DDS library 
to bad manipulations 
logged. In particular, 
failures 
of DDS messages, 
occurring 
module (12%). Unlogged silent 
occur (i) in the DataReaderlmpl module (13.5%) due to 
problems 
and (ii) algorithmic 
occurring 
in the DDS lower transport 
layer (II %). 
occurring 
during the topic-subscription 
errors during the message delivery 
in the DataReaderlmpl 
(60.8%) mainly 
failures 
phase, 
Content failures 
corrupted 
problems 
messaged 
occurring 
are mostly un logged (93.5%). A 
is delivered 
to the subscriber 
due to 
in the DDS transport 
layer. 
5.3 MySQL DBMS 
MySQL is a widely used open-source 
7. The experimental 
market share of about 30% according 
studies 
7. It is composed of a MySQL server and a client 
on the same machine, 
log files. MySQL 8 version 
5.1.34 is evaluated 
configuration 
which also hosts the database 
DBMS. It has a 
to several 
market 
is shown in Figure 
running 
in this study. 
and 
The client 
is a SQL testing 
tool, namely MySQL 
Test Run 
work­
by a subset of test cases from the full 
(MTR), shipped with the MySQL  source  code.  The 
load is represented 
MySQL test suite, 
tests actually 
73 test cases in such a way to cover most of the MySQL 
features 
test cases are sequentially executed 
amount of time; all the selected 
during an experiment. 
used by the MySQL developers. 
and regression 
within a limited 
which includes 
functional 
We selected 
manipulation 
of DDS messages 
and (ii) Service_Participant 
during the sending 
DDS module (8.8%). 
phase, 
Silent failures 
are logged in the majority 
of cases 
(57.2%). 
occurring 
and (ii) in the DataWriterlmpl (10%), which are mainly 
The DDS library 
(i) in the DDS lower transport 
is able to log silent failures 
layer (12.5%), 
7http://www.mysql.com/why-mys
8http://dev.mysql.com/downloads/mysql/S.l.html 
ql/marketshare/ 
978-1-4244-7501-8/10/$26.00 
©2010 IEEE 
462 
DSN 2010: Cinque et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:05 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFIP 
International 
Conference 
on Dependable 
Systems & Networks (DSN) 
'---T-- 
/'-'----'----'''- EJ 
Database 
I 
: 1. DBMS setup 
Log files 
.. 
3. Collect 
+ 
results. _ I 
I 
2. Run test cases  I 
I 
- n n n - n  i Test Manager 1-n n 
4. Collect 
log files  I 
n - n 
- nn 
- n
' 
100% 
80% 
60% 
40% 
20% 
0% 
3,573 
715 
8,921 
Dunlogged 
o logged 
1,757 
halt 
silent  content 
Figure 7: MySQL testbed. 
Figure 8: Experiments 
breakup by failure 
class (MySQL). 
to a failure 
can lead 
without 
the Apache parent process 
collect 
data may not be as effective 
error messages 
logging. 
is not specifically 
Unlike mysqld_safe, 
designed 
hence logged 
to 
from child processes; 
as in the case of MySQL. 
of silent and content 
failures 
A significant 
percentage 
sub-components, 
by the mysqld program, 
a further 
such 
The stan­
also includes 
which instantiates 
MySQL server is represented 
which, in turn, is made up of several 
as the MySQL core and the storage engines. 
dard MySQL configuration 
namely mysqld_safe, 
and collects 
in a log file. We targeted 
experiments, 
component; 
connections, 
execution. 
the two leftmost columns of Table 4. 
since it is the largest 
it is responsible 
and for SQL query parsing, 
all error messages 
We identified 
for managing threads 
and 
and 
in 
43,139 fault locations, 
from mysqld to store them 
the MySQL core in fault injection 
and most fundamental 
process, 
the mysqld process, 
optimization, 
detailed 
963 
756 
233 
experiments 
3,932 1,222  259 
4,333  1,628  294  1334 
3,897 1,042  311 
1,496  440  134 
1,238 251  69 
Table 4: Fault injection 
(MySQL). 
Fault Locations Failures logged unlogged 
OMFC 
OMIA 
OMIEB 
OMIFS 
OMLAC 
OMLOC 
OMLPA 
OMYAE 
OMYAY 
OMYI Y  
OWAEP 
OWPFY 
OW YAY 
Total 
(0/0) 
13,436 5,494 2,472  3,022 
5,880 2,263 1,029  1,234 
1,823  340  122 
188  62 
184  59 
3,328 1,512 455 
1,615  305  69 
236 
43,139 15,102 5,376  9,726 
- 35.6  64.4 
41  192 
731 
306 
182 
218 
126 
125 
682 
723 
1,057 
any message in the log. Logged 
operations 
on sockets, 
during thread creation 
to concurrency 
were due 
failures 
(e.g., 
omitted 
allocation 
resource 
or 
thread deallocation 
(10.5%)), 
connection 
on network connections 
(e.g., 
silent 
failures 
(6.0%) include 
(1.5%). Unlogged 
(57.4%)), 
(e.g.,  missing 
occur without leaving 
silent 
invalid 
locks or files (3.5%) as well as errors 
or termination 
to omission 
faults related 
call to lock primitives 
initialization 
and operations 
not opened (9.2%)). 
external  resources 
log messages 
remaining cases, 
and corrupted 
Therefore, 
during the access to logical 
in order to identify 
are involved, 
due to the omission 
data structures, 
mechanisms 
logging 
silent 
resources 
this type of problem. 
failures 
to table corruption 
Logged content 
We observe that even if the OS or 
there can be a lack of 
In the 
of an operation. 
loops 
were related 
to infinite 
failures 
e.g., linked lists (16.8%). 
should be also enforced 
within the program, 
(19.4%) were due, among the 
(1.6%), wrong interactions 
with 
management 
of 
others, 
storage engines (1.4%), and incorrect 
files and sockets 
(1.2%). Un logged content 
due to faults that affected system behavior 
way,  leading 
strings 
a goto instruction), 
manipulation). 
or flags), wrong control 
or wrong output (e.g., 
to a bad state (e.g., 
flow (e.g., 
failures 
were 
in a complex 
incorrectly 
initialized 
a missing 
if with 
missing data 
The two rightmost 
columns of Table 4 show the coverage 
of MySQL logging 
observed 
failures. 
mechanisms 
with respect 
to the 15,102 
Entries 
are produced 
in 35.6% of cases. 
5.4 Apache Web Server: improvement 
(97.9%) are 
it is the parent of 
Figure 8 shows that almost all halt failures 
Experimental 
results 
by the mysqld_safe 
and receives 
of the child 
from the OS. It should be noted that, 
a notification 
process; 
termination 
detected 
the mysqld process 
process 
even if Apache has a similar 
respect 
the Apache parent process 
to halts is lower (46.2%). We hypothesize 
architecture, 
its coverage 
with 
that 
active work, which 
performs 
nisms are far from providing 
the software faults leading 
improvement 
the paths leading 
error propagation 
figured out solely by looking 
is to introduce 
additional 
from a fault to error states 
paths are hard, if not impossible, 
log events within 
[9]. However, 
the injected  fault. 
to be 
Even if 
show that current 
logging 
comprehensive 
to field failures. 
mecha­
insights 
about 
A possible 
978-1-4244-7501-8/101$26.00 
©2010 IEEE 
463 
DSN 2010: Cinque et a!. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:05 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFIP 
International 
Conference 
on Dependable 
Systems & Networks (DSN) 
process 
is deterministic, 
the fault injection 
the exact location/type 
phenomena 
and hard to trace. In most cases, a fault may manifest 
complete 
source code location. 
within the system 
are completely 
of the injected 
i.e., we know 
different 
fault, 
in a 
propagation 
unpredictable 
to 
by placing 
locations, 
ad­
i.e., 
locations 
We identify 
where failures 
for halt and silent 
In this paper log improvement 
are more likely 
memory 
by exploiting 
collected 
failures, 
is achieved 
log events in the most likely failure 
ditional
the source code locations 
surface. 
failure 
dumps, available 
ing the experimental  campaigns. 
failures 
the system without 
ternal 
observer, 
is delivered 
introducing 
feasible 
improvement 
to the user. These failures 
application-dependent 
guidelines. 
i.e., 
in this paper. In this case, errors propagate 
perceivable 
checks;  hence, 
Our proposed 
to define general-enough 
content 
within 
We do not address 
e.g., a bad output, 
until an improper 
of three phases, 
can be logged only by 
consists 
strategy 
any effect 
service 
causing 
it is not 
by an ex­
dur­
Example 
#1: apr_palloc. Figure 9 reports 
most frequently 
executed 
a snippet 
during a 
of 
a high potential 
This function 
(64 locations 
code from the function 
halt failure. 
cations 
experience 
Many injected 
pool pointer. 
to detect the presence 
to produce a specific 
of code 2-6). Additional 
the case of a halt failure, 
for debugging 
prevent 
faults 
A viable solution 
is called in a large number of lo­
within the server source code); thus we 
of error propagation 
the proper initialization 
towards 
it. 
of the 
to log this type of errors is 
of a NULL pointer 
message as shown in Figure 9 (lines 
before its use and 
operations 
e.g., to explicitly 
could be performed 
log information 
in 
or to gracefully 
stop the program. 
size =  APR_ALIGN_DEFAULT(size); 
2 if(pool==NULL) { 
3  log('apr_palloc: 
4  log(' apr_palloc: called by %s', callerO); 
5  gracefu:LstopO; 
6 } 
7 active =  pool->active; 
using NULL pointer'); 
• for each memory dump, we automatically 
extract 
from 
the top of the stack trace the first function 
under analysis, 
failure 
occurred; 
which was being executed 
when the 
of the platform 
• we rank the collected 
functions 
by the number of 
occurrences; 
• we manually 
analyze 
the most failure-prone 
to 
functions 
identify 
failure 
improvement 
locations, 
for the logging 
mechanism. 
as well as to design a suitable 
to improve 
needed and 
Identifying 
failure 
locations 
makes it possible 
code to be written. 
concern, 
since the extended 
only where actually 
the logging mechanism 
to reduce the amount of error-handling 