safely stored in memory. More detail on key formats is found in
Figure 2.
the BIOS itself [48]. Recent work has even demon-
strated attacks against BIOS update mechanisms that re-
quire signed updates [56].
3.4 Platform identity
TPMs provide software attestation, a proof of what soft-
ware is running on a platform when the TPM is invoked.
The proof is given by a certiﬁcate for the current PCR
values, which contain hashes of the initial state of all soft-
ware run on the machine. This certiﬁcate proves to an-
other party that a TPM-including platform is running par-
ticular software. The receiver must be able to verify that
the certiﬁcate comes from a legitimate TPM, or the quoted
measurements or other attestations are meaningless.
A user desiring privacy cannot directly use her plat-
form’s EK for attestation. (EKs are linked to speciﬁc plat-
forms, and additionally multiple EK uses can be corre-
lated.) Instead, she can generate attestation identity keys
(AIKs) that serve as proxies for the EK. An AIK can sign
PCR contents to attest to platform state. However, some-
thing must associate the AIK with the EK.
A trusted privacy certiﬁcate authority (Privacy CA)
provides certiﬁcates to third parties that an AIK corre-
sponds to an EK of a legitimate TPM. While prototype
Privacy CA code exists [27], Privacy CAs appear to be
unused in practice. In our attack, the malware distributor
acts as a Privacy CA and only trusts AIKs that it certiﬁes.
We emphasize that our proposed attack does not require
or beneﬁt from the anonymity guarantees provided by a
Privacy CA. However, the TPM does not permit a user to
directly sign an arbitrary TPM-generated public key with
the EK, so our attack must use an intermediate AIK.
3.5 Using the TPM
Typical uses of the TPM are to manipulate the key hier-
archy, to obtain signed certiﬁcates of PCR contents or of
6
cates for EKs in TPM NVRAM. Inﬁneon gives the most
detail on their EK certiﬁcation policy, in which the cer-
tiﬁcate chain extends back to a new VeriSign TPM root
Certiﬁcate Authority [11]. ST Microelectronics supplies
TPMs used in many workstations from Dell. They state
that their TPMs from 2010 onward contain certiﬁcates [9].
While no certiﬁcates were present on our older machines,
we did ﬁnd certiﬁcates for our newer Dell machines and
manually veriﬁed the legitimacy of the EK certiﬁcate for
one of our TPMs (which we describe further in Section 5).
Protecting AuthData Many uses of the TPM allow Au-
thData to be snooped if not used carefully. For example,
standard use of TPM tools with TrouSerS prompts the
user to enter passwords at the keyboard to use TPM ca-
pabilities. These passwords can be captured by a keylog-
ger if the system is compromised. Thus, despite that TPM
commands may not require AuthData to appear, entry of
this data into the system for usage can be insecure.
4 Malware using cloaked computations
We now describe an architecture and protocol for launch-
ing a TPM-cloaked attack.
Our protocol runs between an Infection Program,
which is malware on the attacked host, and a Malware
Distribution Platform, which is software executed on
hardware that is remote to the attacked host. The goal
of the protocol is for the Infection Program to generate a
key. The Infection Program attests to the Malware Distri-
bution Platform that TPM-based protection ensures only it
can access data encrypted with the key. The Malware Dis-
tribution Platform veriﬁes the attestation, and then sends
an encrypted program to the Infection Program. The In-
fection Program decrypts and executes this payload. This
protocol enables long-lived and pernicious malware, for
example, turning a computer into a botnet member. The
Infection Program can suspend the OS (and all other soft-
ware) through use of processor late launch capabilities to
ensure unobservability when necessary, like when the ma-
licious payload is decrypted and executing.
4.1 Late launch for secure execution
The protocol uses late launch to suspend the OS to allow
decryption and execution of the malicious payload with-
out observation by an analyst. Late launch creates an exe-
cution environment where it is possible to keep code and
data secret from the OS.
Late launch transfers control to a designated block of
user-supplied code in memory and leaves a hash of that
code in TPM PCRs. Speciﬁcally, with Intel’s Trusted Ex-
ecution Technology, a user conﬁgures data structures to
describe the Measured Launch Environment (MLE), the
program to be run (which resides completely in mem-
ory). She then uses the GETSEC[SENTER] instruction
to transfer control to chipset-speciﬁc code, signed by In-
tel, called SINIT that performs pre-MLE setup such as
Pack(data, extra, P K):
1. Generate symmetric key K
2. Asymmetric encrypt K to form Enc(P K, K || extra)
3. Symmetric encrypt data to form EncSym(K, data)
4. Output EncSym(K, data) || Enc(P K, K || extra)
Unpack(EncSym(K, data) || Enc(P K, K || extra), SK):
1. Asymmetric decrypt Enc(P K, K || extra) with SK to
obtain K and extra
2. Symmetric decrypt EncSym(K, data) with K to obtain
data
3. Output data, extra
Figure 4: Subroutines used in main protocol. extra is needed
for TPM ActivateIdentity, and can be empty (φ). Run-
ning Unpack on the TPM uses TPM Unbind.
ensuring correctness of MLE parameters. The exact func-
tionality of SINIT is not known, as its source code is not
public. SINIT then passes control to the MLE. When the
MLE runs, no software may run on any other processor
and hardware interrupts and DMA transfers are disabled.
To exit, the MLE uses the GETSEC[SEXIT] instruction.
4.2 Malware distribution protocol
The Infection Program ﬁrst establishes a proof that it is
using a legitimate TPM. It uses the TPM to generate two
keys. One is a “binding key” that the Malware Distribu-
tion Platform will use to encrypt the malicious payload.
The other is an AIK that the TPM will use in the Privacy
CA protocol, where the Malware Distribution Platform
plays the role of the Privacy CA. The Malware Distribu-
tion Platform will accept its own certiﬁcation that the AIK
is legitimate in a later phase. As stated before, the Privacy
CA protocol enables indirect use of the private EK only
kept by the TPM. A valid private EK cannot be produced
by an analyst; it is generated by a TPM manufacturer and
only accessible to the TPM hardware. This part of the
Infection Program is named “Infection Keygen”.
Our description of the protocol steps will elide lower-
level TPM authorization commands like TPM OIAP and
TPM OSAP that are used to demonstrate knowledge of au-
thorization data and prevent replay attacks on TPM com-
mands.
We use subroutines Pack(data, extra, P K) and
Unpack(data, P K), which use asymmetric keys with in-
termediate symmetric keys. Symmetric keys increase the
efﬁciency of encryption, are required for certain TPM
commands, and circumvent the limits (due to packing
mechanisms) on the length of asymmetrically encrypted
messages. These subroutines are shown in Figure 4 and
the main protocol is in Figure 5.
4.3 Analyzing the resilience of the protocol
A malware analyst can attempt to subvert the protocol by
tampering with data or introducing keys under her control.
We now analyze the possibilities for subversion.
7
Infection Keygen: Generate binding key that Malware Distribution Platform will eventually use to encrypt malicious payload, AIK
that certiﬁes it, and request for Malware Distribution Platform to test AIK legitimacy
1. Create binding keypair (P K, SK)bind under the SRK with
TPM CreateWrapKey(SRK, P CR18 = Extend(0160, H(Infection Payload Loader))) (requires SRK AuthData), store in
memory
2. Create identity key (P K, SK)AIK under SRK in memory as Blob((P K, SK)AIK ) with TPM MakeIdentity (requires
owner AuthData)
3. Retrieve EK certiﬁcate CEK = P KEK || Sign(SKmanuf acturer, H(P KEK)), which certiﬁes that the TPM with that EK is
legitimate (requires owner AuthData to obtain from NVRAM with TPM NV ReadValue from EK index or needs to be on
disk already)
4. Send Mreq ≡ PubBlob((P K, SK)AIK ) || CEK to Malware Distribution Platform as a request to link AIK and EK
Malware Distribution Platform Certiﬁcate Handler: Give Infected Platform credential only decryptable by legitimate TPM
1. Receive Mreq
2. Verify Sign(SKmanuf acturer, H(P KEK)) with manufacturer CA public key
3. Generate hash Haik cert ≡ H(PubBlob((P K, SK)AIK ))
4. Sign Haik cert with SKmalware, a private key known only to the Malware Distribution Platform whose corresponding public
key is known to all, to form Sign(SKmalware, Haik cert). Sign(SKmalware, Haik cert) is a credential of AIK legitimacy.
5. Run Pack(Sign(SKmalware, Haik cert), Haik cert, P KEK) to form
Mreq resp ≡ Enc(P KEK , K2 || Haik cert) || EncSym(K2, Sign(SKmalware, Haik cert)). Mreq resp contains the credential
in a way such that it can only be extracted by a TPM with private EK SKEK when the credential was created for an AIK
stored in that TPM.
6. Send Mreq resp to Infected Platform
Infection Proof: Decrypt credential, assemble certiﬁcate chain from manufacturer certiﬁed EK to binding key (including credential)
1. Receive Mreq resp
2. Load AIK (P K, SK)AIK and binding key (P K, SK)bind with TPM LoadKey2
3. Use TPM ActivateIdentity, which decrypts Enc(P KEK , K2 || Haik cert) and retrieves K2 after comparing Haik cert
to that calculated from loaded AIK located in internal TPM RAM. If comparison fails, abort. (requires owner AuthData)
4. Symmetric decrypt EncSym(K2, Sign(SKmalware, Haik cert)) to retrieve Sign(SKmalware, Haik cert)
5. Certify (P K, SK)bind with TPM CertifyKey to produce
Sign(SKAIK , H(P CRs(PubBlob((P K, SK)bind))) || H(P Kbind)) ≡ Sign(SKAIK , Hbind cert)
6. Send Mproof ≡ Sign(SKmalware, Haik cert) || PubBlob((P K, SK)AIK ) || Sign(SKAIK , Hbind cert) ||
PubBlob((P K, SK)bind), all the evidence needed to verify TPM legitimacy, to Malware Distribution Platform
Malware Distribution Platform Payload Delivery: Verify certiﬁcate chain, respond with encrypted malicious payload if successful
1. Receive Mproof
2. Verify signatures of Haik cert by SKmalware using P Kmalware, of Hbind cert using P KAIK. Check that Hbind cert
corresponds to the binding key by comparing hash of public key, PCRs to PubBlob((P K, SK)bind). Use
PubBlob((P K, SK)bind) to determine if binding key has a proper constraint for P CR18. Abort if veriﬁcation fails or
binding key improperly locked.
3. Hash and sign the payload with SKmalware to form Sign(SKmalware, H(payload)) (only needs to be done once per
payload)
4. Run Pack(payload || Sign(SKmalware, H(payload)), φ, P Kbind) to form
Mpayload ≡ EncSym(K3, payload || Sign(SKmalware, H(payload))) || Enc(P Kbind, K3)
5. Send Mpayload to Infected Platform
Infection Payload Execute: Use late launch to set PCRs to allow use of binding key for decryption and to prevent OS from
accessing this key during use
1. Receive Mpayload
2. Late launch with MLE ≡ Infection Payload Loader
Infection Hidden Execute: Infection Payload Loader decrypts and executes the payload in the late launch environment.
1. Load (P K, SK)bind with TPM LoadKey2
2. Run Unpack(Mpayload, SKbind). This operation can succeed (and only in this program) because in Infection Hidden
Execute, P CR18 = Extend(0160, H(Infection Payload Loader)). Obtain payload || Sign(SKmalware, H(payload)).
3. Verify signature Sign(SKmalware, H(payload)) with P Kmalware. Abort if veriﬁcation fails.
4. Execute payload
5. If return to OS execution is desired, scrub payload from memory and extend random value into PCR18, then exit late launch
Figure 5: The cloaked malware protocol.
8
key blob = TPM CreateWrapKey(parent key, PCR constraints)
key handle = TPM LoadKey2(key blob)
key blob = TPM MakeIdentity()
sym key =
TPM ActivateIdentity( identity key handle, CA response)
(certiﬁcate, signature) =
TPM CertifyKey(certifying key handle, key handle)
value = TPM NV ReadValue(index)
Generate new key with PCR constraints under the par-
ent key in hierarchy. The resultant key may be used for
encryption and decryption, but not signing.
Load a key for further use.
Generate an identity key under SRK that may be used
for signing, but not encryption and decryption.
Verify that asymmetric CA response part corresponds
to identity key. If agreement, decrypt response and re-
trieve enclosed symmetric key.
Produce certiﬁcate of key contents. Sign certiﬁcate with
certifying key.
Retrieve data from TPM NVRAM.
Table 2: Additional functions in the main protocol. Keywords that are in ﬁxed-width font that begin with TPM are TPM commands
deﬁned in the TPM 1.2 speciﬁcation.
The analyst’s goal is to cause the malicious payload to
be encrypted with a key under her control, or to observe a
decrypted payload. She could try to create a binding key
blob during Infection Proof, and certify it with a legiti-
mate TPM. However, the analyst does not know the value
of tpmP roof for any TPM because it is randomly gen-
erated within the TPM and is never present (even in en-
crypted form) outside the TPM. Without tpmP roof , the
analyst cannot generate a key blob that the TPM will cer-
tify, even under a legitimate AIK. This argument relies on
the fact that the encryption system is non-malleable [25]
and chosen ciphertext secure. Otherwise, an attacker
might be able to take a legitimately created ciphertext with
tpmP roof in it and modify it to an illegitimate ciphertext
with tpmP roof in it, without knowing tpmP roof .
The analyst could attempt to modify PCR constraints
on the binding key by tampering with the the public part
of the key. However, the TPM will not load the key in the
modiﬁed blob because a digest of the public portion of the
blob will not match the hash stored in the private portion.
Thus, storing the binding key in the public part of the blob
where it is accessible to the analyst does not compromise
the security of the protocol. If the binding key is a legiti-
mate TPM key with PCR constraints that do not lock it to
being observed only during Infection Hidden Execute,
the Malware Distribution Platform will detect it during
Malware Distribution Platform Payload Delivery, and
the platform will not encrypt the payload with that key.
The analyst could attempt to forge keys at other points
in the hierarchy: she could attempt to certify a binding
key she creates with an AIK that she creates. The Mal-
ware Distribution Platform only obtains the public por-
tions of these key blobs, and so cannot check directly in
Malware Distribution Certiﬁcate Handler that the AIK
is legitimate. The Malware Distribution Platform could
not verify the legitimacy of key blobs even with their pri-
vate portions as the Platform can neither decrypt the pri-
vate portions, nor know the value of tpmP roof for the
Infected Platform. However, it encrypts with the EK a
there is no way to compel
credential that is a signed hash of the AIK it is sent by In-
fection Keygen running on an infected platform. The EK
is proven legitimate by a certiﬁcate of authenticity signed
by the TPM manufacturer’s private key and veriﬁed by the
Malware Distribution Platform. The private EK is only
stored internal to the TPM, and only usable under con-
trolled circumstances like TPM ActivateIdentity;
to our knowledge,
the
TPM to decrypt arbitrary data with the private EK.
TPM ActivateIdentity will only decrypt a public
EK-encrypted blob of the form (K || Haik cert) where
Haik cert is the hash of the public portion of an AIK key
blob where the AIK has been loaded into the TPM (and
thus has not been tampered with). Therefore, K cannot
be recovered for an illegitimate AIK, and the credential
Sign(SKmalware, Haik cert) cannot be recovered. With-
out this credential, the protocol will abort in Malware
Distribution Platform Payload Delivery (step 2). The