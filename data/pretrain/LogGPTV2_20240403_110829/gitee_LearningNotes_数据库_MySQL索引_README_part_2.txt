### 优化器
#### CBO
基于成本的优化
#### RBO
基于规则的优化
![image-20200629110258878](images/image-20200629110258878.png)
## 索引匹配方式
### 全值匹配
全值匹配指的是和索引中所有的列进行匹配
```sql
explain select * from staffs where name = 'July' and age = 23 and pos = 'dev'
```
而我们建立了一个 包含  name、age、pos的组合索引，使用上面的SQL语句，就会进行全值匹配
### 匹配最左前缀
只匹配前面的几列
```sql
explain select * from staffs where name = 'July' and age = 23
```
这个时候，只使匹配了前面两个列，而没有使用第三个列
现在我们使用下面的SQL语句进行验证，但我们输出值只包含ID的时候
```sql
explain select id from staffs where id = 1
```
我们查看其任务计划，在某尾有 Extra字段，如果是Using index 表示是使用了覆盖索引
![image-20200629144438346](images/image-20200629144438346.png)
然后我们在查看下面这条SQL语句
```sql
explain select * from staffs where id = 1
```
通过查看任务计划，发现extra字段是NULL，说明没有使用覆盖索引
![image-20200629145948288](images/image-20200629145948288.png)
### 匹配列前缀
可以匹配某一列值的开头部分
```sql
explain select * from staffs where name = 'J%'
explain select * from staffs where name = '%y'
```
### 匹配范围值
可以查找某个范围的数据
```sql
explain select * from staffs where name > 'Mary'
```
### 精确匹配某一列并范围匹配另外一列
可以查询某一列的全部和第二列的部分
```sql
explain select * from staffs where name = "July" and age > 25
```
### 只访问索引的查询
查询的时候值需要访问索引，不需要访问数据行，本质上就是索引覆盖
```sql
explain select name,age,pos from staffs where name="July" and age=25 and pos = "dev"
```
## 哈希索引
### 概念
基于哈希的实现，只有精确匹配索引所有的列的查询才有效，在mysql中，只有memory的存储引擎显式支持哈希索引，哈希索引自身只需存储对应的hash值，索引索引的结构十分紧凑，这让哈希索引查找的速度非常快。
### 哈希索引的限制
- 哈希索引值包含哈希值和行指针，而不存储字段值。索引不能使用索引中的值来避免读取行
- 哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序
- 哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值
- 哈希索引支持等值比较查询，也不支持任何范围查询
- 访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，知道找到所有符合条件的行
- 哈希冲突比较多的话，维护的代价也会很高
## 聚簇索引和非聚簇索引
### 聚簇索引
InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按每张表的主键构造一棵B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据也，这个特性就决定了索引组织表中的数据也是索引的一部分。
==一句话来说：将索引和数据放在一起的，就称为聚簇索引==
我们日常的工作中，根据实际情况自行添加的索引，都是辅助索引或者称为普通索引，辅助索引就是为了查找主键索引的二级索引，先找到主键索引然后再通过主键索引找数据，但是可能会存在**回表**的问题。
### 聚簇索引的优点
- 数据访问更快，因为聚簇索引将索引和数据保存在一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对主键的排序和范围查找速度非常快
### 聚簇索引的缺点
- 插入速度严重依赖于排序，按照主键的顺序插入是最快的方式，否者会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列作为主键
- 更新主键的代价很高，因为将会导致被更新的行移动，因此，对于InnoDB表，我们一般定义主键不可更新
- 二级索引访问需要两次索引查找，第一次找到主键值，第二次 根据主键值查找行数据，一般我们需要尽量避免出现索引的二次查找，这个时候，用到的就是**索引的覆盖**
### 非聚簇索引
非聚簇索引也被称为辅助索引，辅助索引在我们访问数据的时候总是需要两次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到主键值，然后在通过主键值找到数据行的数据页，在通过数据页中的Page Directory找到数据行。
InnoDB辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了行数据的聚簇索引建。辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在InnoDB中有时也称为辅助索引为二级索引
![image-20200629113413737](images/image-20200629113413737.png)
## 组合索引
当包含多个列为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要
![image-20200629160704401](images/image-20200629160704401.png)
第4个不走索引，是因为不满足最左匹配原则
第5个，因为跨过了b，所以只走a的索引
## 优化细节
- 当使用索引列进行查询的时候，尽量不要使用表达式，把计算放到业务层而不是数据库层
  ```sql
  select actor_id from actor where actor_id = 4
  select actor_id from actor where actor_id+1 = 5
  ```
  第一条语句走索引
  ![image-20200629161629049](images/image-20200629161629049.png)
  而第二条语句没有走主键索引
  ![image-20200629161641522](images/image-20200629161641522.png)
- 尽量使用主键查询，而不是其它索引，因为主键查询不会触发回表操作
- 使用前缀索引
有时候需要索引很长的字符串，这会让索引变得大且满，通常情况下可以使用某个列开始的部分字符串，这样大大的节约了索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T 到 1 之间，索引的选择性越高，则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。
一般情况下，某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOG，TEXT，VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于选择足够长的前缀以保证较高的选择性，通过又不能太长 。
- 使用索引扫描来进行排序
- union、all、in、or都能使用索引，但是推荐使用in
```sql
explain select * from actor where actor_id = 1 union all select * from actor where actor_id = 2
explain select * from actor where actor_id in (1,2);
explain select * from actor where actor_id = 1 or actor_id = 2;
-- 关于or到底走不走索引，必须根据实际情况进行考虑
```
- 范围列可以使用到索引
例如 范围条件是：、>=、between
范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列，所以一般如果我们使用组合索引的时候，最好不要使用范围查找
![image-20200629160704401](images/image-20200629160704401.png)
如倒数第一个所示，因为中间b使用了范围查找，所以后面的c是无法使用索引的，只能是a和b才能使用索引
- 强制类型转换会让索引失效，进行全表查询
例如下面这样一个例子所示，我们对 phone字段进行了强制类型转换
```sql
explain select * from user where phone = 13800001234  -- 不会触发索引（触发了字符串到整型转换）
explain select * from user where phone = '13800001234'  -- 触发索引
```
- 更新十分频繁，数据区分度不高的字段上不宜建立索引
更新会变更B+树，更新 频繁的字段建立索引会大大降低数据库性能
类似于性别这列的区分度不高的字段，建立索引是没有意义的，不能有效的过滤数据
一般区分度在百分80以上的时候，就可以建立索引，区分度可以使用 count(distinct(列名)) / count(*) 来进行计算
- 创建索引的列，不允许为null，可能会得到不符合预期的结果
- 当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致（阿里规约）
  - 允许数据的冗余，从而加快查询的效率
  - 目前是范式和反范式的混合使用
- 能使用limit的时候，尽量使用limit
- 单表索引建议控制在5个以内
- 单索引字段不允许超过5个（组合索引）
- 创建索引的时候应该尽量避免以下错误的概念
索引不是越多越好，不要在不了解系统的情况下进行优化
## 参考
https://www.cnblogs.com/jiawen010/p/11805241.html
https://www.bilibili.com/video/BV1d5411p7MY?from=search&seid=6712050221639355647