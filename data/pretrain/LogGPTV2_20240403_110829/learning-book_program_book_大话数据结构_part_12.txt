/*如果副除不是最后位置*/
for（k=i;klength;k++）/*将删除位置后继元素前移*/
L->data[k-1]=L->data[k];
/
L->length--1
return OK;
现在我们来分析一下，插入和删除的时间复杂度。
先来看最好的情况，如果元素要插入到最后一个位置，或者删除最后一个元素，
此时时间复杂度为0（1)，因为不需要移动元素的，就如同来了一个新人要正常排队，
当然是排在最后，如果此时他又不想排了，那么他一个人离开就好了，不影响任何
人
最坏的情况呢，如果元素要插入到第一个位置或者删除第一个元素，此时时间复
杂度是多少呢？那就意味着要移动所有的元素向后或者向前，所以这个时间复杂度为
O(n).
至于平均的情况，由于元素插入到第i个位置，或删除第i个元素，需要移动n-i
个元素。根据概率原理，每个位置插入或制除元素的可能性是相同的，也就说位置靠
前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的
2
我们前面讨论过时间复杂度的推导，可以得出，平均时间复杂度还是0（n）。
这说明什么？线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间
复杂度都是0（1）；面插入或删除时，时间复杂度都是0（n）。这就说明，它比较适合元
素个数不太变化，而更多是存取数据的应用。当然，它的优缺点还不只这些
3.5.4线性表顺序存储结构的优缺点
线性表的顺序存储结构的优缺点如图3-5-3所示。
54
---
## Page 79
第3章线性表
优点
缺点
·无须为表示表中元素之
·插入和删除操作需要移
间的逻辑关系而增加额
动大量元素
外的存储空间
·当线性表长度变化较大
·可以快速地存取表中任
时，难以确定存储空间
一位置的元素
的容量
造成存储空间的“碎片”
图3-5-3
好了，大家休息一下，我们等会儿接着讲另一个存储结构。
3.6线性表的链式存储结构
3.6.1顺序存储结构不足的解决办法
前面我们讲的线性表的顺序存储结构。它是有缺点的，最大的缺点就是插入和删
除时需要移动大量元素，这显然就需要耗费时间。能不能想办法解决呢？
要解决这个问题，我们就得考虑一下导致这个问题的原因。
为什么当插入和删除时，就要移动大量元素，仔细分析后，发现原因就在于相邻
两元素的存储位置也具有邻居关系。它们编号是1，2，3，，n，它们在内存中的位
置也是挨着的，中间没有空隙，当然就无法快速介入，面删除后，当中就会留出空
隙，自然需要弥补。问题就出在这里。
A同学思路：让当中每个元素之间都留有一个空位置，这样要插入时，就不至于
移动。可一个空位置如何解决多个相同位置插入数据的问题呢？所以这个想法显然不
行。
B同学思路：那就让当中每个元素之间都留足够多的位置，根据实际情况制定空
隙大小，比如10个，这样插入时，就不需要移动了。万一10个空位用完了，再考虑
移动使得每个位置之间都有10个空位置。如果删除，就直接删掉，把位置留空即
可。这样似乎暂时解决了插入和删除的移动数据问题。可这对于超过10个同位置数
据的插入，效率上还是存在问题。对于数据的遍历，也会因为空位置太多面造成判断
55
---
## Page 80
大数据结构
时间上的浪费。而且显然这里空间复杂度还增加了，因为每个元素之间都有若干个空
位置。
C同学思路：我们反正也是要让相邻元素间留有足够余地，那干脆所有的元素都
不要考虑相邻位置了，哪有空位就到哪里，而只是让每个元素知道它下一个元素的位
置在哪里，这样，我们可以在第一个元素时，就知道第二个元素的位置（内存地址），
而找到它；在第二个元素时，再找到第三个元素的位置（内存地址）。这样所有的元素
我们就都可以通过遍历面找到。
好！太棒了，这个想法非常好！C同学，你可惜生晚了几十年，不然，你的想法
对于数据结构来讲就是划时代的意义。我们要的就是这个思路。
3.6.2线性表链式存储结构定义
在解释这个思路之前，我们先来谈另一个话题。前几年，有一本书风廉了全世
界，它叫《达·芬奇密码》，成为世界上最畅销的小说之一，书的内容集合了侦探、惊
悚和阴谋论等多种风格，很好看。
我由于看的时间太过于久远，情节都忘记得差不多了，不过这本书和绝大部分债
探小说一样，都是同一种处理办法。那就是，作者不会让你事先知道整个过程的全
部，面是在一步一步地到达某个环节，才根据现场的信息，获得或推断出下一步是什
么，也就是说，每一步除了对侦破的信息进一步确认外（之前信息也不一定都是对
的，有时就是证明某个信息不正确），还有就是对下一步如何操作或行动的指引。
不过，这个例子也不完全与线性表相符合。
因为案件侦破的线索可能是错综复杂的，有点像
①
9
我们之后要讲到的树和图的数据结构。今天我们
②
要谈的是单线索，无分支的情况。即线性表的链
3
?
式存储结构。
线性表的链式存储结构的特点是用一组任意
8
的存储单元存储线性表的数据元素，这组存储单
元可以是连续的，也可以是不连续的。这就意味
6
着，这些数据元素可以存在内存未被占用的任意
图3-6-1
位置（如图3-6-1所示）。
以前在顺序结构中，每个数据元素只需要存
数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的
56
---
## Page 81
第3章线性表
后继元素的存储地址。
因此，为了表示每个数据元素a与其直接后继数据元素a1之间的逻辑关系，对
数据元素a来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息
（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后
继位置的城称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据
元素ai的存储映像，称为结点（Node）。
n个结点（a的存储映像）链结成一个链表，即为线性表（a，az，，an）的链
式存储结构，因为此链表的每个结点中只包含一个指针城，所以叫做单链表。单链表
正是通过每个结点的指针城将线性表的数据元素按其逻辑次序链接在一起，如图3-6-2
所示。
数据信息结点
指针
00S0
数据域指针域
地址0500
图3-6-2
对于线性表来说，总得有个头有个尾，链表也不例外。我们把链表中第一个结点
的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的
每一个结点，其实就是上一个的后继指针指向的位置。想象一下，最后一个结点，它
的指针指向哪里？
最后一个，当然就意味着直接后继不存在了，所以我们规定，线性链表的最后一
头指针
第一个结点
最后一个结点
0900
0700
NULL
地址0900
指针指向空
图3-6-3
有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一
57
---
## Page 82
大调数据结构
个结点，称为头结点。头结点的数据域可以不存储任何信息，谁叫它是第一个呢，有
这个特权。也可以存储如线性表的长度等附加信息，头结点的指针城存储指向第一个
结点的指针，如图3-6-4所示。
头结点
头指针
第一个结点
最后一个结点
NULL
可存线性表长度等公共数据
地址0900
指针指向空
图3-6-4
3.6.3头指针与头结点的异同
头指针与头结点的异同点，如图3-6-5所示。
头指针
头结点
·头指针是指链表指向第一个结
头结点是为了操作的统一和方
点的指针，若链表有头结点，
便而设立的，放在第一元素的
则是指向头结点的指针
结点之前，其数据城一般无意
头指针具有标识作用，所以常
义（也可存放链表的长度）
用头指针冠以链表的名字
有了头结点，对在第一元素结
·无论链表是否为空，头指针均
点前插入结点和删除第一结点，
不为空。头指针是链表的必要
其操作与其它结点的操作就统
元素
一了
·头结点不一定是链表必须要素
图 3-6-5
3.6.4线性表链式存储结构代码描述
若线性表为空表，则头结点的指针域为“空”，如图3-6-6所示。
头结点头指针
0900
表示空链表
图3-6-6
58
---
## Page 83
第3章线性表
这里我们大概地用图示表达了内存中单链表的存储状态。看着满图的省略号
“"，你就知道是多么不方便。而我们真正关心的：它是在内存中的实际位置吗？
不是的，这只是它所表示的线性表中的数据元素及数据元素之间的逻辑关系。所以我
们改用更方便的存储示意图来表示单链表，如图3-6-7所示。
结点后继指针地址
牛司
a
a
数据元素数据城指针域
图 3-6-7
若带有头结点的单链表，则如图3-6-8所示。
头指针
a
图3-6-8
空链表如图3-6-9所示。
头指针
图 3-6-9
单链表中，我们在C语言中可用结构指针来描述。
/*线性表的单链表存储结构*/
typedef struct Node
ElemType data;
struct Node *next;
1Node;
typedef struct Node*LinkList;/*定义LinkList*/
从这个结构定义中，我们也就知道，结点由存放数据元素的数据域存放后继结点
地址的指针域组成。假设p是指向线性表第1个元素的指针，则该结点a的数据域
我们可以用p->data来表示，p->data的值是一个数据元素，结点a的指针城可以用
p->next来表示，p->next的值是一个指针。p->next指向谁呢？当然是指向第i+1个
元素，即指向ai1的指针。也就是说，如果p->data=ai，那么p->next>data=a1（如图
---
## Page 84
大语数据结构
3-6-10所示）。
p->data
p->next->data
图 3-6-10
3.7单链表的读取
在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置是很容易的。
但在单链表中，由于第1个元素到底在哪？没办法一开始就知道，必须得从头开始
找。因此，对于单链表实现获取第i个元素的数据的操作GetElem，在算法上，相对要
麻烦一些。
获得链表第i个数据的算法思路：
1.声明一个结点p指向链表第一个结点，初始化1从1开始；
2.当next;
/*让P指向链表L的第一个结点*/
-1;
/*j为计数器*/
while（p66jnext：/*让p指向下一个结点*/
60
---
## Page 85
第3章线性表
++j:
if（!p11j>i）
returnERROR；/第i个元素不存在*/
e=p->data1/取第个元素的数据*/
return OK;