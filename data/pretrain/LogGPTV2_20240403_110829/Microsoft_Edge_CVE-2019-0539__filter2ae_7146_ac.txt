    //                      | inline slots |    |              |
    //                      +--------------+    +--------------+
    // The allocation size of inline slots is variable and dependent on profile data for the
    // object. The offset of the inline slots is managed by DynamicTypeHandler.
因此，一个对象只可能有以下三种情况：
  1. 拥有一个`auxSlots`指针、没有内联`slots` （#1）
  2. 拥有一个内联`slots`但没有`auxSlots`指针（#3），
  3. 同时拥有一个`auxSlots`指针、一个内联`slots`（#2）
在[CVE-2019-0539 PoC](https://bugs.chromium.org/p/project-zero/issues/detail?id=1703&desc=2)中，对象`o`以（#3）形式的内存布局开始其生命周期。然后，当JIT代码最后一次调用`OP_InitClass`函数时，对象`o`的内存布局就变更为（#1）。JIT代码在调用`OP_InitClass`函数之前和之后关于`o`的精确内存布局如下：
        Before:                              After:
    +---------------+                   +--------------+   +--->+--------------+
    |    vtable     |                   |    vtable    |   |    |    slot 1    | // o.a
    +---------------+                   +--------------+   |    +--------------+
    |     type      |                   |     type     |   |    |    slot 2    | // o.b
    +---------------+                   +--------------+   |    +--------------+
    | inline slot 1 | // o.a            |   auxSlots   +---+    |    slot 3    |
    +---------------+                   +--------------+        +--------------+
    | inline slot 2 | // o.b            |  objectArray |        |    slot 4    |
    +---------------+                   +--------------+        +--------------+
在`OP_InitClass`调用前，`o.a`位于第一个内联`slot`中；调用后，它位于`slot
1`的`auxSlots`数组中。因此，正如在上述漏洞根源分析中提到的，JIT代码试图用0x1234来更新位于第一个内联`slot`中的`o.a`，但是它并不知道对象的内存布局已经发生了改变，因而它实际覆写了`auxSlots`指针。
现在，为了利用漏洞实现完全读写原语，参照Bruno的研究，我们需要破坏一些其他有用的对象，并以此实现内存中的任意地址读写。首先，我们需要更好地理解该漏洞的利用价值。当我们覆写`DynamicObject`的`auxSlots`指针时，我们就可以“处理”放入`auxSlots`中的内容来作为`auxSlots
array`。因此举例而言，如果我们利用该漏洞将`auxSlots`指向一个`JavascriptArray`，如下所示：
    some_array = [{}, 0, 1, 2];
    ...
    opt(o, cons, some_array); // o->auxSlots = some_array
然后，我们可以通过赋予`o`属性来覆写`some_array
JavascriptArray`对象内存。使用漏洞覆盖后的`auxSlots`内存状态图如下所示：
          o                        some_array
    +--------------+   +--->+---------------------+
    |    vtable    |   |    |       vtable        | // o.a
    +--------------+   |    +---------------------+
    |     type     |   |    |        type         | // o.b
    +--------------+   |    +---------------------+
    |   auxSlots   +---+    |      auxSlots       | // o.c?
    +--------------+        +---------------------+
    |  objectArray |        |     objectArray     | // o.d?
    +--------------+        |- - - - - - - - - - -|
                            |      arrayFlags     |
                            |  arrayCallSiteIndex |
                            +---------------------+
                            |       length        | // o.e??
                            +---------------------+
                            |        head         | // o.f??
                            +---------------------+
                            |    segmentUnion     | // o.g??
                            +---------------------+
                            |        ....         |
                            +---------------------+
因此，理论而言，如果我们想要覆写数组的长度，我们可以通过类似`o.e =
0xFFFFFFFF`的操作，然后使用`some_array[1000]`来从数据基址区访问一些远程地址。但是，这里有几点需要考虑的问题：
  1. 除了`a`和`b`以外的其他属性都未定义。这意味着要想实现右侧`slot`中`o.e`的定义，我们首先需要分配其他的所有属性，这样的操作会破坏更多的内存，导致数组无法使用。
  2. 原始的`auxSlots array`并不够大。它初始仅分配了4个`slots`。如果我们定义更多的属性，`Js::DynamicTypeHandler::AdjustSlots`函数会分配一个新的`slots array`，并将`auxSlots`指向它，而不是我们的`JavascriptArray`对象。
  3. 我们原计划在`JavascriptArray`对象的`length`字段中放入的0xFFFFFFFF数值并不会被如期写入。Chakra使用所谓的标记数字，因此将要写入的数字将会是`boxed`（更多解释请参照[Chartra的文章](https://abchatra.github.io/TaggedFloat/)）
  4. 即便我们能够在避免破坏其余内存的同时，将`length`字段覆写为较大数值。这也只会给我们一个“相对的”读写原语（相对于数组基址），比起完全的读写原语这显然是不够强大的。
  5. 实际上，覆写`JavascriptArray`的`length`字段并不是很有用的，它也不会得到我们期望实现的相对读写原语。在这种特殊情况下需要做的就是破坏`array`的段大小，这里不会详细探讨。尽管如此，让我们假设覆写`length`字段是有用的，因为它很好地展示了漏洞利用的微妙之处。
因此，我们需要一些特殊的技巧来克服上述问题。我们先来讨论问题1和2。首先想到的就是在漏洞触发前，在`o`对象中提前预定义更多的属性。然后，当覆写`auxSlots`指针时，我们已经在正确的`slot`中定义了`o.e`，该`slot`对应于数组的`length`字段。不幸的是，当增加更多的属性时，会发生以下两种情况之一：
  * 我们过早的更改了内存对象布局（#1），从而阻止了漏洞发生，因为不再有机会覆写`auxSlots`指针。
  * 我们创建了更多的内联`slots`，并且在漏洞触发后仍然保持内联。该对象最终布局（#2），有大量的属性位于新的内联`slots`中。因此在所谓的`auxSlots array`即`some_array`对象内存中，我们仍然无法做到多于2个`slot`。
Bruno
Keith在他的演讲中提出了一个巧妙的方法来同时解决问题1和2。我们首先破坏预先准备好的具有多个属性的另一个`DynamicObject`，而不是直接破坏目标对象（我们示例中的`JavascriptArray`），其已经在内存布局中（#1）。
    obj = {}
    obj.a = 1;
    obj.b = 2;  
    obj.c = 3;
    obj.d = 4;
    obj.e = 5;
    obj.f = 6;
    obj.g = 7;
    obj.h = 8;
    obj.i = 9;
    obj.j = 10;
    some_array = [{}, 0, 1, 2];
    ...
    opt(o, cons, obj); // o->auxSlots = obj
    o.c = some_array; // obj->auxSlots = some_array
我们观察一下在执行`o.c = some_array;`前后的内存状态：
    Before:
           o                      obj
    +--------------+   +--->+--------------+        +->+--------------+
    |    vtable    |   |    |    vtable    | //o.a  |  |    slot 1    | // obj.a
    +--------------+   |    +--------------+        |  +--------------+ 
    |     type     |   |    |     type     | //o.b  |  |    slot 2    | // obj.b
    +--------------+   |    +--------------+        |  +--------------+ 
    |   auxSlots   +---+    |   auxSlots   +--------+  |    slot 3    | // obj.c
    +--------------+        +--------------+           +--------------+ 
    |  objectArray |        |  objectArray |           |    slot 4    | // obj.d
    +--------------+        +--------------+           +--------------+ 
                                                       |    slot 5    | // obj.e
                                                       +--------------+ 
                                                       |    slot 6    | // obj.f
                                                       +--------------+ 
                                                       |    slot 7    | // obj.g
                                                       +--------------+
                                                       |    slot 8    | // obj.h
                                                       +--------------+
                                                       |    slot 9    | // obj.i
                                                       +--------------+
                                                       |    slot 10   | // obj.j
                                                       +--------------+
    After:
           o                      obj                        some_array
    +--------------+   +--->+--------------+        +->+---------------------+
    |    vtable    |   |    |    vtable    | //o.a  |  |       vtable        | // obj.a
    +--------------+   |    +--------------+        |  +---------------------+
    |     type     |   |    |     type     | //o.b  |  |        type         | // obj.b
    +--------------+   |    +--------------+        |  +---------------------+
    |   auxSlots   +---+    |   auxSlots   +-//o.c--+  |      auxSlots       | // obj.c
    +--------------+        +--------------+           +---------------------+
    |  objectArray |        |  objectArray |           |     objectArray     | // obj.d
    +--------------+        +--------------+           |- - - - - - - - - - -|
                                                       |      arrayFlags     |
                                                       |  arrayCallSiteIndex |
                                                       +---------------------+
                                                       |       length        | // obj.e
                                                       +---------------------+
                                                       |        head         | // obj.f
                                                       +---------------------+
                                                       |    segmentUnion     | // obj.g
                                                       +---------------------+
                                                       |        ....         |
                                                       +---------------------+
此时，执行`obj.e =
0xFFFFFFFF`实际上会替换`some_array`对象的`length`字段。然而，问题3中提到，这个数值并不会如期原样写入，而是以其`boxed`形式写入。即便我们忽略问题3，问题4和5仍然会导致我们选择的对象失效。因此，我们应该选择另外一个对象进行破坏。Bruno在他的漏洞利用中巧妙地使用了`ArrayBuffer`对象，但不幸的是，在提交cf71a962c1ce0905a12cb3c8f23b6a37987e68df（10月份的1809合并更新）中，`ArrayBuffer`对象的内存布局发生了改变。它没有直接指向数据缓冲区，而是通过`bufferContent`字段指向一个名为`RefCountedBuffer`的中间结构，只有该结构指向实际的数据。因此，需要不同的解决方法。
最终，我们提出破坏`DataView`对象的想法，该对象实际上在内部使用了`ArrayBuffer`。因此，它具备与使用`ArrayBuffer`相同的优点，并且它直接指向`ArrayBuffer`的底层数据缓冲区。这里是被`ArrayBuffer`初始化的`DataView`对象的内存布局（`v
= new DataView(new ArrayBuffer(0x100));`）。