42
Ingredients:
− An (n, t)-DPRF protocol DP := (DP.Setup, DP.Eval, DP.Combine).
− An authenticated encryption scheme
i ∈ [n] and pp := pp(cid:48).
auENC := (auENC.Kgen, auENC.Encrypt, auENC.Decrypt).
Setup(1κ, n, t) →(cid:16)(cid:74)sk(cid:75)[n], pp
(cid:17)
DistEnc((cid:74)sk(cid:75)[n], [j : m, S], pp) → [j : c/⊥]: To encrypt a message m with the help of parties in S:
: Run DP.Setup(1κ, n, t) to get ((rk1, . . . , rkn), pp(cid:48)). Set ski := rki for
− Party j samples a random r and sends it to all parties in S.
− For every i ∈ S, party i runs DP.Eval(ski, j(cid:107)r, pp) to get wi, and sends it to party j.
− Party j runs Combine({(i, wi)}i∈S, pp) to get w or ⊥. In the latter case, it outputs ⊥. Otherwise,
it computes e := auENC.Encryptw(m) and outputs c := (j, r, e).
DistDec((cid:74)sk(cid:75)[n], [j(cid:48) : c, S], pp) → [j(cid:48) : m/⊥]: To decrypt a ciphertext c with the help of parties in S:
− Party j(cid:48) ﬁrst parses c into (j, r, e). Then it sends j(cid:107)r to all the parties in S.
− For i ∈ S, party i receives x and checks if it is of the form j(cid:63)(cid:107)α(cid:63) for some j(cid:63) ∈ [n]. If not, then
it sends ⊥ to party j(cid:48). Else, it runs DP.Eval(ski, x, pp) to get wi, and sends it to party j(cid:48).
− Party j(cid:48) runs Combine({(i, wi)}i∈S, pp) to get w or ⊥.
auENC.Decryptw(e); else, it outputs ⊥.
If it obtains w,
it outputs m :=
Figure 12: Description of the protocol ΠDP+AE
4. Run Combine({(i, zi)}i∈S(cid:63)\C ∪{(i, ˆzi)}i∈S(cid:63)∩C, pp) to get w(cid:63) or ⊥. In the latter case, give
⊥ to A. Otherwise, compute e(cid:63) := PRG(w(cid:63)) ⊕ (mb(cid:107)ρ(cid:63)) and give c(cid:63) := (j(cid:63), α(cid:63), e(cid:63)) to A.
We deﬁne ﬁve hybrids. With every hybrid, we only mention the diﬀerence from the
previous hybrid (consider MsgPriv to be Hyb0).
− Hyb1: Whenever an honest party initiates an encryption session (including the challenge
phase) and generates a commitment that is not unique (among all the commitments
generated so far by honest parties), notify the adversary and stop.
− Hyb2: In Step 4 (see breakdown of challenge phase above), use a randomly chosen w(cid:63) to
compute e(cid:63) (instead of the one obtained through Combine).
− Hyb3: Replace PRG(w(cid:63)) with a randomly chosen string of the same length.
− Hyb4: Set e(cid:63) to be a random string of length |mb| + κ.
− Hyb5: Set α(cid:63) to be a commitment to a random message.
Except with negligible probability, the commitments generated by honest parties are all
unique due to the binding property of Σ (a fresh ρ is chosen every time). Thus MsgPriv
is indistinguishable from Hyb1. Indistinguishability of Hyb2, Hyb3 and Hyb4 is easy to see.
Further, Hyb4 and Hyb5 are indistinguishable due to the hiding property of Σ.
We are only left to show that Hyb1 and Hyb2 are indistinguishable. On the contrary,
suppose there exists a PPT adversary A who can distinguish between Hyb1 and Hyb2 with
43
a non-negligible probability. We use A to build another PPT adversary B who succeeds in
PseudoRand for the DPRF DP (Deﬁnition 5.3) with the same probability.
Let Chal denote the challenger in PseudoRand. B acts as follows:
− Initialization. Get ppDP from Chal and run Σ.Setup(1κ) to get ppcom. Give (ppDP, ppcom)
to A.
− Corruption. Receive the set of corrupt parties C from A, where |C| < t. Pass it on to
Chal. When Chal returns {ski}i∈C, forward them to A.
Suppose
outputs
A
− Pre-challenge
encryption
queries.
(Encrypt, j, m, S), where j ∈ S and |S| ≥ t. There are two possibilities:
− If j is honest, compute α := Com(m, ppcom; ρ) for a randomly chosen ρ.
If α is
not unique among all the commitments generated so far, notify A and stop; else,
send α to it. A responds with a zi for every i ∈ S ∩ C. At the same time, send
(Eval, j(cid:107)α, i) to Chal and get back a response zi for every i ∈ S \ C. Now run
Combine({(i, zi)}i∈S, pp) to get w or ⊥. In the latter case, send ⊥ to A. Otherwise,
compute e := PRG(w) ⊕ (m(cid:107)ρ) and send c := (j, α, e) to A.
− If j is corrupt, A expects the honest parties in S to help compute a DPRF value. For
a message x sent to an honest party j(cid:48) in S, send (Eval, j(cid:107)x, j(cid:48)) to Chal. Forward
Chal’s response to A.
− Pre-challenge indirect decryption queries. Suppose A outputs (Decrypt, j, c, S), where
j ∈ S \ C and |S| ≥ t. If c parses to (j(cid:48), α, e), send j(cid:48)(cid:107)α to A. Ignore any response from
A.
− Challenge. A outputs (Challenge, j(cid:63), m0, m1, S(cid:63)) where |m0| = |m1|, j(cid:63) ∈ S(cid:63) \ C and
|S(cid:63)| ≥ t. Compute α(cid:63) := Com(mb, ppcom; ρ(cid:63)) by picking ρ(cid:63) at random and, based on the
uniqueness of α(cid:63), do the same thing as before. For every i ∈ S(cid:63) ∩ C, A provides a value
ˆzi. Send (Challenge, j(cid:63)(cid:107)α(cid:63), S,{(i, ˆzi)}i∈S(cid:63)∩C) to Chal. If Chal returns ⊥, forward the
same to A. Otherwise, use Chal’s response w(cid:63) to compute e(cid:63) := PRG(w(cid:63)) ⊕ (mb(cid:107)ρ(cid:63)),
and give c(cid:63) := (j(cid:63), α(cid:63), e(cid:63)) to A.
− Post-challenge encryption queries. This is same as the pre-challenge encryption phase.
− Post-challenge indirect decryption queries. This is same as the pre-challenge decryption
phase.
− Guess. Finally, A returns a guess b(cid:48). Output b(cid:48).
B makes an Eval request in the (pre- or post-challenge) encryption phase only. When
j is honest, a request is made only when α is unique. When j is corrupt, j(cid:107)x can not be
equal to j(cid:63)(cid:107)α(cid:63) because j(cid:63) is honest. As a result, B never requests any evaluation on j(cid:63)(cid:107)α(cid:63).
Therefore, the challenge message it sends to Chal is valid. Now it is easy to see that when
w(cid:63) := Combine({(i, zi)}i∈S(cid:63)\C ∪{(i, ˆzi)}i∈S(cid:63)∩C, pp), B perfectly simulates Hyb1, and when w(cid:63)
is random, it perfectly simulates Hyb2.
44
C.2 Proof of Theorem 7.5
We ﬁrst write down the last step of the authenticity game AUTH, forgery, in detail. Recall
that ct counts the total number of times honest parties are contacted in encryption/decryption
protocols initiated by corrupt parties and g captures the minimum number of honest parties
an adversary must contact in order to get enough information to generate one ciphertext.
Let k := (cid:98)ct/g(cid:99).
1. A outputs ((j1, S1, c1), (j2, S2, c2), . . ., (jk+1, Sk+1, ck+1)) s.t. j(cid:96) ∈ S \ C, |S(cid:96)| ≥ t for
(cid:96) ∈ [k + 1] and cu (cid:54)= cv for any u (cid:54)= v ∈ [k + 1]. Let c(cid:96) := (j(cid:96), α(cid:96), e(cid:96)) for (cid:96) ∈ [k + 1].
2. For (cid:96) ∈ [k + 1], compute z(cid:96),i ← DP.Eval(ski, j(cid:96)(cid:107)α(cid:96), pp) for all i ∈ S(cid:96) and w(cid:96)
:=
Combine({(i, z(cid:96),i}i∈S(cid:96), pp). Output 0 if any w(cid:96) = ⊥. Else, compute m(cid:96)(cid:107)ρ(cid:96) := PRG(w(cid:96))⊕e(cid:96)
and check if α(cid:96) = Com(m(cid:96), ppcom; ρ(cid:96)). Output 0 if the check fails for any (cid:96). Else, output
1.
We deﬁne a new authenticity game called AUTH-U (U stands for unique). It diﬀers from
AUTH in the ﬁrst step of forgery:
− A outputs ((j1, S1, c1), (j2, S2, c2), . . ., (jk+1, Sk+1, ck+1)) s.t. j(cid:96) ∈ S \ C, |S(cid:96)| ≥ t for
(cid:96) ∈ [k + 1] and cu (cid:54)= cv for any u (cid:54)= v ∈ [k + 1]. Let c(cid:96) := (j(cid:96), α(cid:96), e(cid:96)) for (cid:96) ∈ [k + 1].
Output 0 if for any u (cid:54)= v, ju = jv and αu = αv.
We show that AUTH is indistinguishable from AUTH-U. Suppose an adversary outputs
k + 1 distinct ciphertexts s.t. there are two ciphertexts cu and cv for which ju = jv and
αu = αv (thus, eu (cid:54)= ev). We show that in this case even AUTH will output 0. Since all the
parties involved in decrypting forged ciphertexts are assumed to behave honestly, wu = wv
with high probability due to the consistency property of DP. Together with eu (cid:54)= ev, this
implies that mu(cid:107)ρu (cid:54)= mv(cid:107)ρv. As a result, Com(mu, ppcom; ρu) (cid:54)= Com(mv, ppcom; ρv) with all
but negligible probability (binding property of Σ).
We now show that if there exists a PPT adversary A such that AUTH-U outputs 1
with probability at least ε, then one can use it to build another PPT adversary B for the
pseudorandomness game PseudoRand (Deﬁnition 5.3) whose advantage is at least ε − negl
for some negligible function negl. Let Chal denote the challenger for the pseudorandomness
game. B acts as follows:
− Initialization. Get ppDP from Chal and run Σ.Setup(1κ) to get ppcom. Give (ppDP, ppcom)
Initialize an ordered list Lp-ctxt := ∅ and a counter ctj,α := 0 for every (j, α).
to A.
(Here, p-ctxt stands for partial ciphertext.)
− Corruption. Receive the set of corrupt parties C from A, where |C| < t. Pass it on to
Chal. When Chal returns {ski}i∈C, forward them to A. Set g := t − |C|.
− Encryption queries. Suppose A outputs (Encrypt, j, m, S), where j ∈ S and |S| ≥ t.
There are two possibilities:
− If j is honest, send α ← Com(m, ppcom; ρ) to A, where ρ is picked at random. Ignore
any response from A. Append (j, α) to Lp-ctxt.
− If j is corrupt, A expects the honest parties in S to help compute a DPRF value. For
a message x sent to an honest party j(cid:48) in S, send (Eval, j(cid:107)x, j(cid:48)) to Chal. Forward
Chal’s response to A and increment ctj,x by 1.
45
− Decryption queries. Suppose A outputs (Decrypt, j(cid:48), c, S), where j(cid:48) ∈ S and |S| ≥ t.
Parse c into (j, α, e). Now:
− If j(cid:48) is honest, send j(cid:107)α to A. Ignore any response from A.
− If j(cid:48) is corrupt, for a message x sent to an honest party j(cid:48)(cid:48) ∈ S by A, check if x is
of the form j(cid:63)(cid:107)α(cid:63) for some j(cid:63) ∈ [n]. If not, return ⊥ to A. Else, send (Eval, x, j(cid:48)(cid:48))
to Chal and forward its response to A. Increment ctj(cid:63),α(cid:63) by 1.
Suppose A outputs
(TargetDecrypt,
j(cid:48), (cid:96), S), where j(cid:48) ∈ S \ C and |S| ≥ t. Let (j, α) be the (cid:96)-th entry of Lp-ctxt. Send
j(cid:107)α to A. Ignore any response from A.
decryption
queries.
− Targeted
− Forgery. A outputs ((j1, S1, c1), (j2, S2, c2), . . ., (jτ , Sτ , cτ )) s.t. j(cid:96) ∈ S \ C, |S(cid:96)| ≥ t for
(cid:96) ∈ [τ ] and cu (cid:54)= cv for any u (cid:54)= v ∈ [τ ]. Let c(cid:96) := (j(cid:96), α(cid:96), e(cid:96)) for (cid:96) ∈ [τ ]. Now:
− If for any u (cid:54)= v, ju = jv and αu = αv, output 1 as the guess and stop.
− Pick
g.
(Challenge,
j(cid:96)(cid:63)(cid:107)α(cid:96)(cid:63), S(cid:96)(cid:63),∅) to Chal. Let w(cid:63) be Chal’s response.
If w(cid:63) = ⊥, output 1; else,
compute m(cid:107)ρ := PRG(w(cid:63)) ⊕ e(cid:96)(cid:63) and check if α(cid:96)(cid:63) = Com(m, ppcom; ρ). If the check
fails, output 1; else, output 0.
ctj(cid:96)(cid:63) ,α(cid:96)(cid:63)
Send
such
that
a
c(cid:96)(cid:63)
<
Note that the sum of ctj,α for all (j, α) is at most ct, the variable in AUTH-U that keeps
track of the number of times honest parties are contacted. In turn, ct must be less than τ · g
as required by AUTH-U. Thus, there must exist a c(cid:96)(cid:63) such that ctj(cid:96)(cid:63) ,α(cid:96)(cid:63) < g. This ensures
that j(cid:96)(cid:63)(cid:107)α(cid:96)(cid:63) is not in the list L maintained by Chal.
B simulates AUTH-U perfectly for A. Let b(cid:48) denote the bit output by B at the end.
Suppose the bit b in PseudoRand is 0. From the third item in the ﬁrst paragraph of this
section, we can see that AUTH-U outputs 1 only if w(cid:96) (cid:54)= ⊥ and α(cid:96) = Com(m(cid:96), ppcom; ρ(cid:96))
succeeds for all (cid:96)—and, in particular, for (cid:96) = (cid:96)(cid:63). We have assumed that AUTH-U outputs 1
with probability at least ε. Thus, Pr[b(cid:48) = 1 | b = 0] ≤ 1 − ε.
On the other hand, when b = 1, w(cid:63) is picked at random, so m(cid:107)ρ is a pseudo-random value.
The probability that α(cid:96)(cid:63) = Com(m, ppcom; ρ) is at most negl for some negligible function negl
due to the binding property of Σ. Therefore, Pr[b(cid:48) = 1 | b = 1] ≥ 1 − negl. So,
(cid:12)(cid:12)Pr[b(cid:48) = 1 | b = 0] − Pr[b(cid:48) = 1 | b = 1](cid:12)(cid:12) ≥ ε − negl.
C.3 Proof of Theorem 7.6
In the case of strong authenticity, we cannot assume anymore that the corrupt parties involved
in decrypting forged ciphertexts behave honestly. As a result, ﬁrst of all, we cannot use the
consistency property of DPRF alone to argue the indistinguishability of AUTH and AUTH-U.
We will need the correctness property too.
We ﬁrst deﬁne a notion called validity for DPRFs which combines both consistency and
correctness. Formally, an (n, t)-DPRF DP := (Setup, Eval, Combine) is valid if for all PPT
adversaries A, there exists a negligible function negl such that the following game outputs 1
with probability at least 1 − negl(κ).
− Initialization. Run Setup(1κ, n, t) to get ((sk1, . . . , skn), pp). Give pp to A.
− Corruption. Receive the set of corrupt parties C from A, where |C| < t. Give the
secret-keys {ski}i∈C of these parties to A.
46
− Evaluation. In response to A’s evaluation query (Eval, x, i) for some i ∈ [n] \ C, return
Eval(ski, x, pp) to A. Repeat this step as many times as A desires.
− Computation. Receive two sets S0, S1 of size at least t, an input x(cid:63), and shares {(i, z(cid:63)
0,i)}i∈S0∩C,
1,i)}i∈S1∩C from A. Let z0,j ← Eval(skj, x(cid:63), pp) for j ∈ S0\C and z1,j ← Eval(skj, x(cid:63), pp)
b := Combine({j, zb,j}j∈Sb\C ∪ {(i, z(cid:63)
1 = ⊥ or z(cid:63)
1; else, output 0.
0 = z(cid:63)
b,i)}i∈Sb∩C, pp) for b ∈ {0, 1}.
{(i, z(cid:63)
for j ∈ S1 \ C. Let z(cid:63)
0 = ⊥ or z(cid:63)
Output 1 if z(cid:63)
Notice that validity is diﬀerent from consistency in the sense that corrupt parties also con-
tribute to DPRF evaluation, and it is diﬀerent from correctness in the sense that both DPRF
evaluations involve corrupt parties (instead of just one).
Fix a PPT adversary A for the validity game deﬁned above. Let Z(cid:63)
1 be random
variables that capture the distribution of z(cid:63)
1 in the game, respectively. Deﬁne two
adversaries A0 and A1 for the correctness game based on A as follows: for b ∈ {0, 1}, Ab runs
A up to the end of the evaluation phase and, when A produces its output for the computation
phase, Ab outputs the b-th part of it (i.e., Sb, x(cid:63) and {(i, z(cid:63)
(cid:63)
b be
random variables that capture the distribution of z (the true DPRF value) and z(cid:63) in the
correctness game with Ab, for b ∈ {0, 1}.
b,i)}i∈Sb∩C). Let Zb and Z
0 and Z(cid:63)
0 and z(cid:63)
On account of DPRF DP being correct, we have that
Pr[Z
(cid:63)
b ∈ {Zb,⊥}] ≥ 1 − εb(κ)
for b ∈ {0, 1} and a negligible function εb. Further, the consistency of DP gives us that
Pr[Z0 = Z1 (cid:54)= ⊥] ≥ 1 − ε
(cid:63)
for some negligible function ε. Now, observe that Z(cid:63)
b for
b ∈ {0, 1} due to the deﬁnition of the validity and correctness games as well as the construction
of A0, A1 from A. Therefore,
b is identically distributed to Z
Pr[Validity game outputs 1] = Pr[Z(cid:63)
(cid:63)
(cid:63)
(cid:20)Z
1 = ⊥ ∨ Z(cid:63)
1 = ⊥ ∨ Z
0 = ⊥ ∨ Z(cid:63)
0 = ⊥ ∨ Z
0 ∈ {Z0,⊥} ∧ Z
∧Z0 = Z1
= Pr[Z
≥ Pr
≥ 1 − (ε0 + ε1 + ε).
(cid:63)
0 = Z(cid:63)
1 ]