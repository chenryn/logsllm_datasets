FORWARD
mangle
FORWARD
第5章深度实践iptables123
angle
发送到网络的
数据包
NF_IP_POST_ROUTING
0101
本地进程
4NF_IP_LOCAL_OUT
---
## Page 140
处理。
nat表都有POSTROUTING链，这些链根据自己向内核注册时的优先级（priority）依次进行
此可见在一个钩子上可能有多个表的不同链需要处理，如图5-13 中的raw表、mangle 表、
如图5-13中5所示的阶段。
5-13中4所示的阶段。
5-13中的③所示的阶段。
②所示的阶段。
在路由决策前即被执行。如图5-13中①所示的阶段。
注册的内核模块将依次被触发。这5个钩子的处理时间分别如下。则
124运维前线：一线运维专家的运维方法、技巧与实践
NF_IP_LOCAL_IN：在路由判断确定了包是发送到本机时执行这个钩子。如图5-13中
NF_IP_PRE_ROUTING：在数据流量进入网络栈后立即被触发，这个钩子上注册的模块
NF_IP_POST_ROUTING：在数据包经过路由判断后即将发送到网络前执行这个钩子。
：NF_IP_FORWARD：在路由判断确定了包需要转发给其他主机时执行这个钩子。如图
通过以上的分析，我们知道netilter只有5个钩子，而iptables 有5个链和5种表，由
NF_IP_LOCAL_OUT：在本机进程产生的网络被送到网络栈上时执行这个钩子，如图
netfilter提供了5个钩子可以供程序去注册。在数据包经过网络栈的时候，这些钩子上
 security表：提供在数据包中加入 SELinux 特性的功能。该表一般用得不多，本章将
口raw表：raw表为 iptables 提供了一种不经过状态追踪的机制，在大流量对外业务的服
口mangle表：mangle表用于修改IP的头部信息，如修改TTL（Time toLive）。
口nat表：顾名思义，这个表是进行网络地址转换用的，如本章5.3节的“网络地址转
口filter表：filter表是iptables 中使用最广泛的表，这个表的作用是进行过滤，也就是由
iptables 中有5种表（table），分别如下。
POSTROUTING：NFIPPOST_ROUTING钩子触发。
OUTPUT：NF_IP_LOCAL_OUT钩子触发。
FORWARD：NF_IP_FORWARD钩子触发
INPUT：NF_IP_LOCAL_IN 钩子触发。
PREROUTING：NF_IP_PRE_ROUTING钩子触发。
iptables 中有5个链（chain），分别如下。
不再叙述这一部分的内容。
换在实践中的案例”所示，可以改变数据包的源地址或目的地址。
这个表来决定一个数据包是否继续它的目的地址，或者被拒绝。
踪”中的案例所示。
务器上使用这个表可以避免状态追踪带来的性能问题。如本章5.1节的“禁用连接追
---
## Page 141
iptables问题时能够参照这个图像进行快速定位。
们给出了iptables 中各种表和链的作用和关系，希望能帮读者形成一个清晰的图像，在分析
iptables 在网络地址转换中的两种经典使用场景进行了配置案例的说明。作为总结部分，我
连接追踪的机制及使用中的注意事项、提出了慎重禁用ICMP协议的论点并进行了分析。对
5.5小结
Linux 中的 iptables 既是强大的网络安全工具，又是网络地址转换工具。本章重点剖析了
第5章深度实践iptables125
---
## Page 142
在启动过程中 systemd和sysVinit 的区别。
还提供了很多进程通信和进程调用的简便用法；这里以CentOS 的发行版本为例来为大家讲解，
它能够从系统的启动过程就开始进程的管控，对非终端依赖型的程序（服务）进行配置，而且
管理员经常用的 service、chkconfig 等命令就是 sysVinit 提供的。但是 systemd与 sysVinit 不同，
6.1systemd和sysVinit之间的关系
日常管理中的使用。
systemd 的影子，它对运维工程师的影响越来越大，这里就为大家介绍一下 systemd在Linux
工程师的视线，从启动过程到服务管理，再到常用的计划任务、日志等日常运维工具都有
服务。
经理等职。在新浪广告、微博广告、西山居大数据平台架构中担任关键角色，并提供咨询
推荐系统和BI相关领域的解决方案。曾历任北京尚观科技高级讲师、新浪研发中心技术
调优经验，擅长高性能和高可用性集群技术。近四年专注于Hadoop 集群、Spark集群在
systemd 是优秀的进程管理工具，在CentOS 5.x版本下管理进程的这类工具称为 sysVinit,
随着 Red Hat Enterprise 7的发布和 Ubuntu系统的普及，systemd 开始逐渐进入到运维
尹会生，金山西山居高级系统工程师。拥有多年的企业集群解决方案培训经验和内核
作者简介
使用systemd管理Linux系统服务
第6章
---
## Page 143
待状态，从而导致系统启动缓慢。而 systemd 可以让A、B、C三个服务并行启动起来，而且
的启动顺序才能正确运行。那么，一旦C服务启动缓慢就会导致B和A这两个服务进人等
务依赖C，以至于更多的依赖关系，Upstart 启动的过程就会要求服务必须按照C→B→A
的 systemd来替代 sysVinit 和Upstart，而且管理命令和启动脚本的编写与 sysVinit 还可以兼
6.1.2systemd 方式下系统的启动特点
系的服务分到相同的组，在组内按照顺序进行引导，以达到并行启动的目的。但是这种方式
开发了Upstart 方式来代替 sysVinit 方式。Upstart 支持分组顺序启动的方式，即将有依赖关
来做各种异常的判断。
机和关机，我们希望能够通过简单的配置就可以绕过这种加载不正常的服务，而不是用Shell
误会导致某些服务在启动的时候“hang住”，操作系统不能继续引导，从而导致无法正常开
便应用程序在系统初始化时完成启动，从而简化运维工作。但是我在长时间的使用中也发现
实际在工作中，很多熟练的运维工程师会使用Shell脚本来编写自己的服务启动脚本，以方
CentOS 6.x了，sysVinit 是Linux 操作系统上非常经典的系统初始化和进程管理工具，甚至在
6.1.1sysVinit方式下系统的启动特点
还可以支持按需启动。
动失败。在真正的启动过程中，会出现更复杂的依赖，即多层依赖，如A服务依赖B，B服
这就需要获得连接到网络接口的IP地址，如果网络服务没有启动，就会导致依赖它的服务启
会有依赖关系的问题，像是Apache、Nginx这类的服务在启动之前要判断端口是否被占用
启动的方式和Upstart不同，不需要用户来解决依赖关系，例如：在系统启动的过程中，都
启动脚本能够无缝迁移到CentOS7上运行。
容，降低了运维工程师的学习成本，所以之前在CentOS5、CentOS6上可以正常运行的服务
依然不是启动速度最快的。
人系统上的问题变得尤为突出，因此另一个重要的桌面发行版Ubuntu操作系统的技术人员，
活，所有的启动服务都要被加载，不够灵活。
一（1）服务只能按照之前编排好的顺序来执行，这会使启动过程变得缓慢，而由于人为失
，那么 systemd 有哪些新的特性呢？其最大的特点就是可以真正地并行启动了。这种并行
为了进一步提升系统启动的速度，以及方便对服务器进行管理，CentOS7采用了更先进
随着Linux的不断发展，越来越多的人将Linux安装到个人设备上，这时sysVinit在个
Upstart 是一个基于事件的init守护进程的替代工具，用于在系统启动时进行程序的管理。由Canonical公
（2）不能根据硬件状态的改变，动态调整服务的启动和停止。无论硬件设备是否被激
运维工程师最熟悉的、也是目前应用最为广泛的生产环境的系统就是CentOS5.x和
司的前雇员ScottJamesRemnant开发，最初用于Ubuntu发行版。
第6章使用systemd管理Linux系统服务127
---
## Page 144
况下会有0～6共7个启动级别，也就是说用户可以定义7种（实际上是5种）不同的启动
己的启动级别（runlevel)，不同的启动级别可用来定义一组不同服务的启动顺序，在默认情
的，它的PID永远为1。
环境，init进程在磁盘的“/sbin/init”这个位置。之后所有的进程都是由它派生（fork）出来
进行引导，用户可以根据界面提示来自由地选择不同版本的内核。
统为例，为大家介绍sysVinit体系下的启动顺序。
5系统上面，该版本也是用于生产环境非常稳定的发行版本。下面我们以典型的CentOS5系
首先我们详细分析一下sysVinit的启动方式。目前我所在的公司还有很多业务运行在CentOS
6.2.1
6.2
在系统底层都做了哪些工作。
过多CPU核心来并行处理，从而缩短了启动的时间。接下来我们来具体分析各种启动方式
中，然后继续启动下一个服务；systemd就是这样让系统启动过程并行运行起来的，最后通
systemd能进行并行启动的原因。
到这个挂载点则触发挂载的系统调用，将真正的目录挂载到事先定义好的挂载点，这就是
采用和 autofs 相同的触发机制，即先创建临时挂载点（一个空目录），一旦有服务程序使用
一旦被依赖的服务程序没有运行，同样会将请求进行缓存直到被依赖的程序运行为止。
务的功能，进一步减少用户的工作量。
为止，这样就解决了端口依赖的问题。而且还很体贴地为用户提供了通过 systemd拉起B服
然后检测B服务是否启动了，如果没有启动则对A服务的请求进行缓存，直到程序B运行
要 systemd先“制作”一个端口，当程序A启动时，systemd 检测到对该端口的 socket 请求，
呢？首先要解决的就是依赖关系，systemd 作者总结出了三种服务依赖关系：
统启动一起被加载的，这样就可以大大缩短启动的时间。这么“神奇”的功能是怎么实现的
128
：（3）init程序运行时会加载配置文件/etc/inittab，在配置文件中根据指定的参数来确定自
（2）内核在引导完成之后，会加载第一个进程init，这时就正式进人了sysVinit 的引导
（1）在Linux系统的启动过程中，首先由 BIOS加电自检，之后将引导功能交给GRUB
既然 systemd由 sysVinit 进化而来，因此为了更好地掌握 systemd的原理和启动过程，
（3）文件系统依赖，除了“/”目录必须串行启动之外，其他被程序依赖的目录都可以
（2）程序通信的依赖，systemd采用了D-Bus 作为程序之间的通信工具，在启动过程中，
有了这三种解决依赖关系的方法之后，可以将启动过程中产生的依赖关系先缓存到内存
（1）端口依赖，即服务A若正常启动，则需要先连接服务B的端口。解决这种依赖需
那么，什么是按需启动呢？按需启动是指服务在没有被其他服务依赖时，是不会随着系
SysVinit 的启动顺序
systemd的原理和启动顺序
运维前线：一线运维专家的运维方法、技巧与实践
---
## Page 145
这一行语句来更改系统默认的运行级别。在配置文件中还有这样的内容：
（2）加载服务又是怎样实现的呢？可以通过设置／etc/inittab配置文件的“id:3:initdefault：
启动时间的浪费。铁
整的启动时间，会发现rc.sysinit脚本的运行时间占用了大部分的启动时间，因为它为后面的
务启动时可能会依赖的功能先运行起来，然后再加载指定级别的服务。如果我们测量一次完
地将主机名、文件系统、swap、SELinux、udev、内核参数、系统时钟、RAID、LVM等服
选项来完成的：
动这组服务程序，init进程会为系统执行初始化动作。这个初始化动作是由/etc/inittab 的下列
过程，但启动效率却很低。
启动过程中都执行了哪些操作，这种简单又直接的启动方式很适合运维工程师去理解启动的
用服务。全部加载完成之后会进人等待用户登录的界面，来完成一次启动过程。
然后加载基础服务，如网络参数、蓝牙、软件raid、LVM逻辑等服务，之后再加载其他的应
启动级别设置为3，其他启动级别的用途将在6.2.2节为大家详细介绍。
方式，以保证用户可以灵活地进行服务启动顺序的设置。默认情况下，在生产环境中我们将
。（4）init程序会按照默认的级别来逐个加载一组服务，首先会加载各个外设的硬件驱动
（1）init 进程加载/etc/inittab 配置文件的部分，获得运行级别后并不会根据级别立即启
这就是 sysVinit 的启动过程，引导过程大量使用了Shell脚本，以方便运维工程师分析
它的含义是在系统启动各个服务程序之前执行/etc/rc.d/rc.sysinit脚本，这个脚本是串行
si::sysinit:/etc/rc.d/rc.sysinit
为了便于对比不同的启动程序之间的差异，下面将更具体地分析下/etc/inittab文件中的内容。
sysVinit 的启动过程如图6-1所示：
不同的内核版本
用户自主选择
2.6.182.6.32
BIOS加电自检
/sbin/init
GRUB
图6-1sysVinit的启动过程
第6章使用systemd管理Linux系统服务129
/etc/rc.svsinit
/etc/inittab
 login
letc/rc3.d
端等待用户登录
服务加载完成之后，加载终
根据运行级别运行特定的服务
运行系统初始化脚本
来确定运行级别
通过读取配置文件
---
## Page 146
过程中，将使用 target（目标）取代 runlevel，这是启动过程中最大的变化。
6.2.2
短启动时间，接下来我们看看 systemd是怎么做的。
可以优化的余地，即rc3.d部分引导服务的时候仍然是串行的，那么我们还可以对这部分缩
准的CentOS6系统要比CentOS5系统快很多。但是我们还发现如果在服务引导的部分还有
然后使用事件（event）机制和其他任务进行通信，这样就缩短了系统初始化时的启动时间。
任务增加一个状态，在启动时制定一些状态，并根据状态来确认每个任务运行到哪一步了
脚本做了大量的优化，它将启动需要做的每一个服务都封装成一个任务（job），并且为每一个
顺序引导的情况，CentOS6采用了Upstart工具来代替sysVinit进行引导，Upstart对rc.sysinit
代计算机（多核并发）的机制产生严重的资源浪费，因为仅有单线程在工作。鉴于上面的这种
完成之前，后面的程序都要等待；利用这种方式启动服务的好处还是简单，但这一过程会让现
号链接开头的 S 或K 标记。而S 或K标记后面的两位数字就是用来确定启动顺序的。
rc6.d下则是大量的以K开头的符号链接。运维工程师通过 chkconfig 命令就可以改变这些符
的 Shell脚本，下面将跟踪/etc/rc.d/rc这个脚本，主要逻辑如下：
前面的wait 标志，会让系统逐个加载服务直到加载完所有的服务后才继续下一步的启动。
2从这个逻辑我们不难发现，服务启动的过程是顺序完成的，而且在前一个服务没有执行
130
：CentOS 5、CentOS 6加载一组服务通常称作runlevel（运行级别）。而在 systemd启动的
有了Upstart之后，我们在同样的硬件环境下进行了启动时间的比较，发现启动一套标
根据 initdefault 给定的级别（这里是级别3），执行相应的服务。系统会执行／etc/rc.d/rc 3
打开/etc/rc1.d到/etc/rc5.d目录会发现大部分服务是以S开头的符号链接，而 rc0.d和
done
#进入
fori
done
#进入
foriin/etc/rc$runlevel.d/K*;do
runlevel="$1"
这里是一个分支，用于保证系统会加载到一组指定的服务，
16:6:wait:/etc/rc.d/rc
15:5:wait:/etc/rc.d/rc
14:4:wait:/etc/rc.d/rc
13:3:wait:/etc/rc.d/rc
12:2:wait:/etc/rc.d/rc
11:1:wait:/etc/rc.d/rc
10:0:wait:/etc/rc.d/rc0
运维前线：一线运维专家的运维方法、技巧与实践
systemd的启动顺序
in/etc/rc$runlevel.d/s*;do
/etc/rc3.d/目录，依次执行以k00～K99开头的程序并增加 stop参数
/etc/rc3.d/目录，依次执行以 s00～ S99开头的程序并增加 start 参数
Sistart
$i stop
6
3
#获取命令的参数
，而不是加载全部的服务。
司
---
## Page 147
器。精简了基本的模式，并转化为英文之后，用户可以更好地区分每个target 的功能；其他
带图形的多用户网络模式；级别5单独使用一个target用于启动时启动X服务，即图形服务
别1为恢复模式；级别2、3、4合并成了一个target，这个target被称作多用户模式，即不
键字来确定依赖关系并进行加载。下面是runlevel和常用的 target 对比：
断，
依赖关系就要管理员自行判断了，例如想要关闭network服务，就需要使用如下命令：
根据自己的业务来调整哪些服务需要在开机时就加载。但是在设置自己的服务过程中一旦有
行级别，通过init命令切换运行级别。
，这点极易造成系统无法正常启动，而且灵活性也较低。
我们可以看到级别0和级别6使用的数字已经转换成了更好识别功能的英文，其中级
而在systemd中，target默认有40多种组成方式，当系统启动时，
sysVinit 运行级别（runlevel） systemd 目标（target）
但其他依赖 network 服务的命令在下次启动的时候会失败，需要管理员根据经验自行判
[user@localhost=~]$ chkconfig --level 3 network off
对于以上的7个级别，我们一般会在生产环境中采用级别3来加载服务，运维工程师会
口级别4为用户自定义。
口级别3是用于生产环境最多的级别，除了KDE、GNOME桌面环境之外的其他级别都
口级别2会在级别1的基础上增加除网络和网络服务之外的其他所有服务，其最初是为
口级别1会在系统启动时加载/etc/rc1.d/S开头的服务，这些服务只包含启动必需的服
口级别0和级别6分别表示关机和重启，它们都会调用/etc/rc$runlevel.d/目录下以K开
默认的runlevel从0～6共7个级别，可以在运行时使用runlevel命令来查询当前的运
会加载。而级别5则是将桌面环境一起启动，普遍用于娱乐图形和终端用户环境中。
现在网络已经成为使用Linux的必备所需，所以级别2很少用于生产环境中。
无网络功能的桌面主机设计的，期望通过减少加载网络的功能，来加快启动速度。但
员（root）密码时的紧急救援工作。
务，只会加载bash 而不进行用户身份的校验，该级别可用于服务器异常或忘记管理
0最后会调用halt命令关机，而级别6会调用reboot命令重启：
头的服务，按照顺序调用 servicestop 来关闭服务；唯一的区别就是级别