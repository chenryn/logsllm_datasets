### CVE-2020-25684
DNSmasq本身限制了转发给上游服务器查询包的数量，通常最大是150条。用户可以自己设定这个值。转发查询使用的是frec(forward
record)结构。每个frec都和TXID相关联。当回复被接受或经过一定时间，这个frecs就会被删除。
通常情况下，用于转发查询的socket数量被限制在64个。每个用于转发的socket和一个随机的端口绑定。
理论上，查询包中TXID和源端口加起来会有32-bit的熵。但是实际上，这个熵要更少一些。因为dnsmasq在同一个端口会多路复用多个TXID，而没有将每个TXID和每个端口设置为一一对应的关系，如下图所示。结果就是，攻击者只需要猜中64个端口中的一个端口还有正确的TXID就可以了，而不用猜中某个特定的端口和特定的TXID。所以这导致实际上只有26位熵值。
### CVE-2020-25685
如果要对DNS转发器进行投毒，除了需要猜对正确的TXID和源端口，攻击者发送伪造的回复还需要匹配已开放的frecs。如果想让frec匹配，那么TXID和问题区都要匹配，换句话说，回复的内容是之前询问过的。
dnsmasq只存放问题区的哈希值，而不是把整个语句存下来。当整个查询提交的时候，这个哈希值会被保存。
如果dnsmasq没有编译DNSSEC支持，那么他默认使用CRC32作为哈希算法。问题就在于CRC32从密码学角度并不是一个安全的算法。可以很轻松的使用类似SMT
solver等工具进行CRC32碰撞，这里原理不做过多介绍。
所以基于这一特性，攻击者可以生成多个查询，每一个查询的CRC32的值都相同，不过查询的是不同的域名，而这些域名最好是不存在的，即没有被缓存的。然后攻击者可以发送一个具有相同CRC32值的伪造的回复。
如下图所示，攻击者控制一台客户端对多个域名发起问询，每一个CRC32的值都是相同的，然后在递归DNS服务器回复之前，回复一个具有相同CRC32值的域名或IP，攻击即有可能成功。
### CVE-2020-25686
dnsmasq的另一个问题就是在同一个域名被查询请求时会粗暴的创建多个frecs。随后会转发所有的请求，如果成功的匹配其中的任意一个，就计入缓存。这个问题导致就算dnsmasq使用安全的哈希算法，也可能成功的实施攻击。
通过以上三个漏洞，导致攻击者伪造恶意回复包的成功率大大提高，后面还需要利用dnsmasq没有对回复包做验证的特性进行攻击。
一般情况下，在递归服务器上会对回复包做一些验证机制，例如bailiwicks。但是在配置dnsmasq的设备上并没有做任何验证，所以可以在用户请求的时候，攻击者可以发送如下回复:
然后这条记录的缓存就会被插入到dnsmasq的设备中。前文介绍过CNAME，所以当用户想访问的时候，会被重定向到被攻击者控制的IP为6.6.6.6的服务器。而配置了类似bailiwicks的设备，会去找权威服务器询问的IP。
## 6 Dnsmasq缓冲区溢出漏洞
### CVE-2020-25681
以下名称以规范的DNS名称顺序排序。最重要的标签是“example”。在此级别上，“example”将首先排序，然后是以“a.example”结尾的名称，然后是以“z.example”结尾的名称。每个级别中的名称以相同的方式排序。如下图所示。
CVE-2020-25681漏洞位于dnssec.c文件的sort_rrset()函数中，该函数负责按照DNSSEC验证过程的要求采用冒泡排序算法将给定的资源记录集合（RRSets）排序为规范顺序。该函数定义如下：
它接受了响应数据包（header）以及数据包长度（plen）。rrset是指向资源记录集合中RR数组的指针，而rrsetidx是集合中的RR数，rr_desc是指向与RRset关联的RR类型的描述符的指针。最后，有两个缓冲区buff1和buff2，它们用作排序例程的工作区缓冲区。这两个缓冲区在程序开始时都是相对分配的，它们是daemon>
workspacename和daemon-> keyname。当dnsmasq开启DNSSEC时，将会分配这两个缓冲区。
MAXDNAME大小为1025，所以workspacename和keyname的大小2050，也是该漏洞发生溢出的缓冲区。
首先启动dnsmasq，并设置参数为：
-p 53535 --no-daemon --log-queries -S 127.0.0.2 --no-hosts --no-resolv -d -q --dnssec --trust-anchor=.,20326,8,2,E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D，构造完恶意DNS查询响应包，使用命令行：dig NS +dnssec @localhost -p 53535 .，命中sort_rrset()函数断点后如下图所示：
在构造资源记录集合（RRSets）时，必须保证记录个数大于1，这样才能保证进入排序循环。
这里构造的rrsetidx为0x3。
正常数据包如下图所示：
Answers块中，p1指向第一个资源记录，p2指向第二个，然后进行排序。
分别跳过Class，Type和TTL，到达RDATA区域。
Data lengh为20，为Name Server的长度。然后进入排序循环。
行315，首先调用get_rdata()函数解析第一个资源记录p1的RDATA域中的NameServer，看下该函数实现。
判断d是否等于-1，这里不等于，不进入if语句，来到如下代码。
然后调用extract_name()函数解析，这里需要保证extract_name()函数解析错误返回0，保证进入get_rdata()函数返回为0，通过设置超长NameServer字符串即可。
进入if语句，行318，计算len1，为end1-p1，即是NameServer的长度。行319，调用memcpy()将p1拷贝到buff1+left1中。
这里len1设置为3550，p1为NameServer，长度RDLENGTH为用户可控。前文已经介绍buff1为daemon>
workspacename，大小为2020，因此发生堆溢出。
## 7 缓解措施
1.升级dnsmasq到最新版本(2.83及以上)，这是目前最有效的方法。
2.如果不必要，配置dnsmasq设备不要在WAN口监听。
3.暂时关闭DNSSEC验证选项。
4.使用为DNS提供传输安全的协议，如DoT或DoH。
## 8 参考链接
[1] 
[2] 
[3] 
[4] 
[5] 
[6] 
[7] 
[8] 
[9] 
[10] 
[11] 
[12] 
[13] 
* * *