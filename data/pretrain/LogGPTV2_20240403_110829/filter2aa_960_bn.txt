Starting from the beginning of the file, we use a Go file Reader u 
instance to read 96 bytes onward in order to confirm the initial binary 
signature v. Recall that the first 2 bytes provide the ASCII value MZ. The 
PE package offers convenience objects to help marshal PE data structures 
into something more easily consumable. It will, however, still require man-
ual binary readers and bitwise functionality to get it there. We perform a 
binary read of the offset value w referenced at 0x3c, and then read exactly 
4 bytes x composed of the value 0x50 0x45 (PE) followed by 2 0x00 bytes. 
Parsing the COFF File Header
Continuing down the PE file structure, and immediately following the DOS 
Stub, is the COFF File Header. Let’s parse the COFF File Header by using 
the code defined in Listing 12-16, and then discuss some of its more inter-
esting properties. 
    // Create the reader and read COFF Header
    u sr := io.NewSectionReader(f, 0, 1<<63-1)
    v _, err := sr.Seek(pe_sig_offset+4, os.SEEK_SET)
    check(err)
    w binary.Read(sr, binary.LittleEndian, &pefile.FileHeader)
Listing 12-16: Parsing the COFF File Header (/ch-12 /peParser/main.go)
We create a new SectionReader u that starts from the beginning of the 
file at position 0 and reads to the max value of an int64. Then the sr.Seek() 
function v resets the position to start reading immediately, following the 
PE signature offset and value (recall the literal values PE + 0x00 + 0x00). 
Finally, we perform a binary read w to marshal the bytes into the pefile 
object’s FileHeader struct. Recall that we created pefile earlier when we 
called pe.Newfile().
The Go documentation defines type FileHeader with the struct defined 
in Listing 12-17. This struct aligns quite well with Microsoft’s documented 
PE COFF File Header format (defined at https://docs.microsoft.com/en-us 
/windows/win32/debug/pe-format#coff-file-header-object-and-image).
type FileHeader struct {
        Machine              uint16
        NumberOfSections     uint16
        TimeDateStamp        uint32
        PointerToSymbolTable uint32
        NumberOfSymbols      uint32
        SizeOfOptionalHeader uint16
        Characteristics      uint16
}
Listing 12-17: The Go PE package’s native PE File Header struct 
The single item to note in this struct outside of the Machine value (in 
other words, the PE target system architecture), is the NumberOfSections 
property. This property contains the number of sections defined within 
Windows System Interaction and Analysis   283
the Section Table, which immediately follows the headers. You’ll need to 
update the NumberOfSections value if you intend to backdoor a PE file by add-
ing a new section. However, other strategies may not require updating this 
value, such as searching other executable sections (such as CODE, .text, and 
so on) for contiguous unused 0x00 or 0xCC values (a method to locate sec-
tions of memory that you can use to implant shellcode), as the number of 
sections remain unchanged. 
In closing, you can use the following print statements to output some of 
the more interesting COFF File Header values (Listing 12-18).
    // Print File Header
    fmt.Println("[-----COFF File Header-----]")
    fmt.Printf("[+] Machine Architecture: %#x\n", pefile.FileHeader.Machine)
    fmt.Printf("[+] Number of Sections: %#x\n", pefile.FileHeader.NumberOfSections)
    fmt.Printf("[+] Size of Optional Header: %#x\n", pefile.FileHeader.SizeOfOptionalHeader)
    // Print section names
    fmt.Println("[-----Section Offsets-----]")
    fmt.Printf("[+] Number of Sections Field Offset: %#x\n", pe_sig_offset+6) u
    // this is the end of the Signature header (0x7c) + coff (20bytes) + oh32 (224bytes)
    fmt.Printf("[+] Section Table Offset: %#x\n", pe_sig_offset+0xF8)
 /* OUTPUT
[-----COFF File Header-----]
[+] Machine Architecture: 0x14c v
[+] Number of Sections: 0x8 w
[+] Size of Optional Header: 0xe0 x
[-----Section Offsets-----]
[+] Number of Sections Field Offset: 0x15e y
[+] Section Table Offset: 0x250 z
*/
Listing 12-18: Writing COFF File Header values to terminal output (/ch-12 /peParser/main.go)
You can locate the NumberOfSections value by calculating the offset of 
the PE signature + 4 bytes + 2 bytes—in other words, by adding 6 bytes. In 
our code, we already defined pe_sig_offset, so we’d just add 6 bytes to that 
value u. We’ll discuss sections in more detail when we examine the Section 
Table structure. 
The produced output describes the Machine Architecture v value of 
0x14c: an IMAGE_FILE_MACHINE_I386 as detailed in https://docs.microsoft.com/en-us 
/windows/win32/debug/pe-format#machine-types. The number of sections w is 
0x8, dictating that eight entries exist within the Section Table. The Optional 
Header (which will be discussed next) has a variable length depending on 
architecture: the value is 0xe0 (224 in decimal), which corresponds to a 32-bit 
system x. The last two sections can be considered more of convenience out-
put. Specifically, the Sections Field Offset y provides the offset to the num-
ber of sections, while the Section Table Offset z provides the offset for the 
location of the Section Table. Both offset values would require modification 
if adding shellcode, for example.
284   Chapter 12
Parsing the Optional Header
The next header in the PE file structure is the Optional Header. An execut-
able binary image will have an Optional Header that provides important 
data to the loader, which loads the executable into virtual memory. A lot 
of data is contained within this header, so we’ll cover only a few items in 
order to get you used to navigating this structure. 
To get started, we need to perform a binary read of the relevant byte 
length based on architecture, as described in Listing 12-19. If you were writing 
more comprehensive code, you’d want to check architectures (for example, x86 
versus x86_64) throughout in order to use the appropriate PE data structures. 
    // Get size of OptionalHeader
    u var sizeofOptionalHeader32 = uint16(binary.Size(pe.OptionalHeader32{}))
    v var sizeofOptionalHeader64 = uint16(binary.Size(pe.OptionalHeader64{}))
    w var oh32 pe.OptionalHeader32
    x var oh64 pe.OptionalHeader64
    // Read OptionalHeader
    switch pefile.FileHeader.SizeOfOptionalHeader {
    case sizeofOptionalHeader32:
        y binary.Read(sr, binary.LittleEndian, &oh32)
    case sizeofOptionalHeader64:
        binary.Read(sr, binary.LittleEndian, &oh64)
    }
Listing 12-19: Reading the Optional Header bytes (/ch-12/peParser/main.go)
In this code block, we’re initializing two variables, sizeOfOptionalHeader32 u 
and sizeOfOptionalHeader64 v, with 224 bytes and 240 bytes, respectively. This 
is an x86 binary, so we’ll use the former variable in our code. Immediately 
following the variable declarations are initializations of pe.OptionalHeader32 w 
and pe.OptionalHeader64 x interfaces, which will contain the OptionalHeader 
data. Finally, we perform the binary read y and marshal it to the relevant 
data structure: the oh32 based on a 32-bit binary. 
Let’s describe some of the more notable items of the Optional Header. 
The corresponding print statements and subsequent output are provided in 
Listing 12-20. 
    // Print Optional Header
    fmt.Println("[-----Optional Header-----]")
    fmt.Printf("[+] Entry Point: %#x\n", oh32.AddressOfEntryPoint)
    fmt.Printf("[+] ImageBase: %#x\n", oh32.ImageBase)
    fmt.Printf("[+] Size of Image: %#x\n", oh32.SizeOfImage)
    fmt.Printf("[+] Sections Alignment: %#x\n", oh32.SectionAlignment)
    fmt.Printf("[+] File Alignment: %#x\n", oh32.FileAlignment)
    fmt.Printf("[+] Characteristics: %#x\n", pefile.FileHeader.Characteristics)
    fmt.Printf("[+] Size of Headers: %#x\n", oh32.SizeOfHeaders)
    fmt.Printf("[+] Checksum: %#x\n", oh32.CheckSum)
    fmt.Printf("[+] Machine: %#x\n", pefile.FileHeader.Machine)
    fmt.Printf("[+] Subsystem: %#x\n", oh32.Subsystem)
    fmt.Printf("[+] DLLCharacteristics: %#x\n", oh32.DllCharacteristics)
Windows System Interaction and Analysis   285
/* OUTPUT
[-----Optional Header-----]
[+] Entry Point: 0x169e682 u
[+] ImageBase: 0x400000 v
[+] Size of Image: 0x3172000 w
[+] Sections Alignment: 0x1000 x
[+] File Alignment: 0x200 y
[+] Characteristics: 0x102
[+] Size of Headers: 0x400
[+] Checksum: 0x2e41078
[+] Machine: 0x14c
[+] Subsystem: 0x2
[+] DLLCharacteristics: 0x8140
*/
Listing 12-20: Writing Optional Header values to terminal output (/ch-12 /peParser/main.go)
Assuming that the objective is to backdoor a PE file, you’ll need to know 
both the ImageBase v and Entry Point u in order to hijack and memory jump 
to the location of the shellcode or to a new section defined by the number of 
Section Table entries. The ImageBase is the address of the first byte of the image 
once it is loaded into memory, whereas the Entry Point is the address of the 
executable code relative to the ImageBase. The Size of Image w is the actual 
size of the image, in its entirety, when loaded into memory. This value will 
need to be adjusted to accommodate any increase in image size, which could 
happen if you added a new section containing shellcode.  
The Sections Alignment x will provide the byte alignment when sec-
tions are loaded into memory: 0x1000 is a rather standard value. The File 
Alignment y provides the byte alignment of the sections on raw disk: 0x200 
(512K) is also a common value. You’ll need to modify these values in order 
to get working code, and you’ll have to use a hex editor and a debugger if 
you’re planning to perform all this manually.
The Optional Header contains numerous entries. Instead of describing 
every single one of them, we recommend that you explore the documentation 
at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header 
-windows-specific-fields-image-only to gain a comprehensive understanding of 
each entry.
Parsing the Data Directory
At runtime, the Windows executable must know important information, 
such as how to consume a linked DLL or how to allow other application 
processes to consume resources that the executable has to offer. The 
binary also needs to manage granular data, such as thread storage. This 
is the primary function of the Data Directory. 
The Data Directory is the last 128 bytes of the Optional Header and 
pertains specifically to a binary image. We use it to maintain a table of 
references containing both an individual directory’s offset address to the 
data location and the size of the data. Exactly 16 directory entries are 
defined within the WINNT.H header, which is a core Windows header file 
286   Chapter 12
that defines various data types and constants to be used throughout the 
Windows operating system.
Note that not all of the directories are in use, as some are reserved or 
unimplemented by Microsoft. The entire list of data directories and details 
of their intended use can be referenced at https://docs.microsoft.com/en-us 
/windows/win32/debug/pe-format#optional-header-data-directories-image-only. 
Again, a lot of information is associated with each individual directory, so 
we recommend you take some time to really research and get familiar with 
their structures. 
Let’s explore a couple of directory entries within the Data Directory by 
using the code in Listing 12-21.
    // Print Data Directory
    fmt.Println("[-----Data Directory-----]")
    var winnt_datadirs = []string{ u
        "IMAGE_DIRECTORY_ENTRY_EXPORT",
        "IMAGE_DIRECTORY_ENTRY_IMPORT",
        "IMAGE_DIRECTORY_ENTRY_RESOURCE",
        "IMAGE_DIRECTORY_ENTRY_EXCEPTION",
        "IMAGE_DIRECTORY_ENTRY_SECURITY",
        "IMAGE_DIRECTORY_ENTRY_BASERELOC",
        "IMAGE_DIRECTORY_ENTRY_DEBUG",
        "IMAGE_DIRECTORY_ENTRY_COPYRIGHT",
        "IMAGE_DIRECTORY_ENTRY_GLOBALPTR",
        "IMAGE_DIRECTORY_ENTRY_TLS",
        "IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG",
        "IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT",
        "IMAGE_DIRECTORY_ENTRY_IAT",
        "IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT",
        "IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR",
        "IMAGE_NUMBEROF_DIRECTORY_ENTRIES",
    }
   for idx, directory := range oh32.DataDirectory { v
        fmt.Printf("[!] Data Directory: %s\n", winnt_datadirs[idx])
        fmt.Printf("[+] Image Virtual Address: %#x\n", directory.VirtualAddress)
        fmt.Printf("[+] Image Size: %#x\n", directory.Size)
    }
/* OUTPUT
[-----Data Directory-----]
[!] Data Directory: IMAGE_DIRECTORY_ENTRY_EXPORT w
[+] Image Virtual Address: 0x2a7b6b0 x
[+] Image Size: 0x116c y
[!] Data Directory: IMAGE_DIRECTORY_ENTRY_IMPORT z
 [+] Image Virtual Address: 0x2a7c81c
 [+] Image Size: 0x12c
--snip--
*/
Listing 12-21: Parsing the Data Directory for address offset and size ( /ch-12/peParser/main.go)
The Data Directory list u is statically defined by Microsoft, meaning 
that the literal individual directory names will remain in a consistently 
ordered list. As such, they are considered to be constants. We will use a 
Windows System Interaction and Analysis   287
slice variable, winnt_datadirs, to store the individual directory entries so we 
can reconcile names to index positions. Specifically, the Go PE package 
implements the Data Directory as a struct object, so we’re required to iter-
ate over each entry to extract the individual directory entries, along with 
their respective address offset and size attributes. The for loop is 0-index 
based, so we just output each slice entry relative to its index position v. 
The directory entries being displayed to standard output are the IMAGE 
_DIRECTORY_ENTRY_EXPORT w, or the EAT, and the IMAGE_DIRECTORY_ENTRY_IMPORT z, 
or  the IAT. Each of these directories maintains a table of exported and 
imported functions, respectively, relative to the running Windows execut-
able. Looking further at IMAGE_DIRECTORY_ENTRY_EXPORT, you will see the virtual 
address x containing the offset of the actual table data, along with the 
size y of the data contained within. 
Parsing the Section Table
The Section Table, the last PE byte structure, immediately follows the Optional 
Header. It contains the details of each relevant section in the Windows execut-
able binary, such as executable code and initialized data location offsets. The 
number of entries matches the NumberOfSections defined within the COFF File 
Header. You can locate the Section Table at the PE signature offset + 0xF8. 
Let’s take a look at this section within a hex editor (Figure 12-8).
Figure 12-8: The Section Table, as observed using a hex editor 
This particular Section Table starts with .text, but it might start with 
a CODE section, depending on the binary’s compiler. The .text (or CODE) 
section contains the executable code, whereas the next section, .rodata, 
contains read-only constant data. The .rdata section contains resource 
data, and the .data section contains initialized data. Each section is at least 
40 bytes in length. 
You can access the Section Table within the COFF File Header. You can 
also access each section individually, using the code in Listing 12-22.
288   Chapter 12
    s := pefile.Section(".text")
    fmt.Printf("%v", *s)
/* Output
{{.text 25509328 4096 25509376 1024 0 0 0 0 1610612768} [] 0xc0000643c0 0xc0000643c0}
*/
Listing 12-22: Parsing a specific section from the Section Table (/ch-12 /peParser/main.go)
The other option is to iterate over the entire Section Table, as shown in 
Listing 12-23. 
    fmt.Println("[-----Section Table-----]")
    for _, section := range pefile.Sections { u
        fmt.Println("[+] --------------------")
        fmt.Printf("[+] Section Name: %s\n", section.Name)
        fmt.Printf("[+] Section Characteristics: %#x\n", section.Characteristics)
        fmt.Printf("[+] Section Virtual Size: %#x\n", section.VirtualSize)
        fmt.Printf("[+] Section Virtual Offset: %#x\n", section.VirtualAddress)
        fmt.Printf("[+] Section Raw Size: %#x\n", section.Size)
        fmt.Printf("[+] Section Raw Offset to Data: %#x\n", section.Offset)
        fmt.Printf("[+] Section Append Offset (Next Section): %#x\n", section.Offset+section.Size)
    }
/* OUTPUT
[-----Section Table-----]
[+] --------------------
[+] Section Name: .text v
[+] Section Characteristics: 0x60000020 w
[+] Section Virtual Size: 0x1853dd0 x
[+] Section Virtual Offset: 0x1000 y
[+] Section Raw Size: 0x1853e00 z
[+] Section Raw Offset to Data: 0x400 {
[+] Section Append Offset (Next Section): 0x1854200 |
[+] --------------------
[+] Section Name: .rodata
[+] Section Characteristics: 0x60000020
[+] Section Virtual Size: 0x1b00
[+] Section Virtual Offset: 0x1855000
[+] Section Raw Size: 0x1c00
[+] Section Raw Offset to Data: 0x1854200
[+] Section Append Offset (Next Section): 0x1855e00
--snip--
*/
Listing 12-23: Parsing all sections from a Section Table (/ch-12/peParser /main.go)
Here, we’re iterating over all the sections within the Section Table u 
and writing the name v, virtual size x, virtual address y, raw size z, and 
raw offset { to standard output. Also, we calculate the next 40-byte off-
set address | in the event that we’d want to append a new section. The 
characteristics value w describes how the section is to behave as part of 
the binary. For example, the .text section provides a value of 0x60000020. 
Windows System Interaction and Analysis   289
Referencing the relevant Section Flags data at https://docs.microsoft.com/en-us 
/windows/win32/debug/pe-format#section-flags (Table 12-2), we can see that 
three separate attributes make up the value. 
Table 12-2: Characteristics of Section Flags
Flag
Value
Description
IMAGE_SCN_CNT_CODE
0x00000020
The section contains executable code.
IMAGE_SCN_MEM_EXECUTE
0x20000000
The section can be executed as code.
IMAGE_SCN_MEM_READ