which an attacker can exploit to perform a classic RILC or
advanced COOP attack [31]. We thwart these function-reuse
attacks by permuting all function tables such as C++ virtual
tables and PLT entries with performance overheads that
allow industry adoption.
Davi et al. [13] recently presented an alternative defensive
technique, Isomeron, which combines ﬁne-grained ASLR with
control-ﬂow randomization. In particular, it maintains two
copies of a program image of which one is diversiﬁed. The
program control ﬂow is randomized at each function call.
However, Isomeron adds signiﬁcant performance overhead
since it leverages dynamic binary instrumentation. In addi-
tion, it provides limited protection against RILC and COOP
attacks because its policies restrict indirect calls to target a
valid function the program links to.
Finally, Mohan et al. [24] present Opaque CFI (O-CFI),
a binary instrumentation-based solution which combines
coarse-grained CFI with code randomization. Similar to
Isomeron, the code layout is no longer a secret. O-CFI works
by identifying a unique set of possible target addresses for
each indirect branch instruction. Afterwards, it leverages the
per-indirect branch set to restrict the target address of the
indirect branch to only its minimal and maximal members.
To further reduce the set of possible addresses, it arranges
basic blocks belonging to an indirect branch set into clusters
(so that they are located nearby to each other), and also
randomizes their location. Unlike Readactor++, the security
of O-CFI relies on the precision of the available CFG. Mohan
et al. use CFGs recovered from binaries which leads to coarse-
grained policies that may allow function-reuse attacks.
Control-Flow Integrity.
To defend against vtable-based attacks, a number of de-
fenses have recently been proposed [16, 20, 27, 38, 40]. The
compiler-based approaches of Tice et al. [38] and Jang et
al. [20] focus on protecting virtual function calls in C++.
Both ensure that an adversary cannot manipulate a vtable
pointer so that it points to an adversary-controlled, fake
vtable. Unfortunately, these schemes do not protect against
classical return-oriented programming attacks which reuse
return instructions. The aforementioned approaches require
the source code of the application which might not be al-
ways readily available. In order to protect binary code, a
number of forward-edge CFI schemes have been presented
recently [16, 27, 40]. Although these approaches require no
access to source code, they are not as ﬁne-grained as their
compiler-based counterparts. In particular, COOP under-
mines the assumptions of these binary instrumentation-based
defenses by invoking a chain of virtual functions through le-
gitimate call sites to induce malicious program behavior [31].
Code-Pointer Integrity.
Recently, Szekeres et al. [37] proposed code pointer in-
tegrity (CPI), and Kuznetsov et al. [21] evaluated several
implementations for x86 and x86-64 systems. CPI separates
code pointers as well as pointers to code pointers from non-
control data by placing them in a safe memory region that
can only be accessed by instructions that are proven to be
safe at compile-time. CPI operates very eﬃciently on C code,
but may incur performance overheads of more than 40% for
C++ applications. With respect to security, CPI relies on the
protection of the safe memory region which is eﬃciently pos-
sible on x86 by leveraging segmentation. However, on x86-64
where segmentation is not fully available, CPI protects the
safe region though information hiding or software-fault isola-
tion. Evans et al. [15] recently demonstrated a weakness in
one of the x86-64 CPI implementations that can be leveraged
to locate and compromise the safe region.
25311. CONCLUSIONS
While ROP-based attacks have received considerable at-
tention from the research community, sophisticated attacks
such as COOP show that whole-function reuse is equally
worrisome. Our paper demonstrates two new ways to con-
struct COOP attacks against C++ code and describes a
minimized yet realistic COOP attack that bypasses DEP. We
also introduce a novel probabilistic defense against COOP
and other attacks that abuse dynamically-bound function
calls. Our techniques are designed to fully resist information
disclosure vulnerabilities. Our evaluation shows that these
techniques provide quantiﬁable and tunable protection, scale
to real-world software, and add an average run-time overhead
of just 1.1%. When combined with execute-only memory
and ﬁne-grained code randomization, the combined overhead
(8.4%) is less than that of a fully comparable CFI solution.
Acknowledgments
We acknowledge Sajo Sunder George’s eﬀorts to implement
PLT randomization and boobytrapping and thank Andrei
Homescu, Stefan Brunthaler, and the anonymous reviewers
for their suggestions and constructive feedback.
This material is based upon work partially supported by
the Defense Advanced Research Projects Agency (DARPA)
under contracts D11PC20024, N660001-1-2-4014, FA8750-15-
C-0124, and FA8750-15-C-0085 as well as gifts from Google,
Mozilla, Oracle, and Qualcomm. Any opinions, ﬁndings, and
conclusions or recommendations expressed in this material
are those of the authors and do not necessarily reﬂect the
views of the Defense Advanced Research Projects Agency
(DARPA), its Contracting Agents, the National Science Foun-
dation, or any other agency of the U.S. Government.
This work has been co-funded by the German Federal
Ministry of Education and Research (BMBF) under support
code 16BP12302 (EUREKA project SASER), the German
Science Foundation as part of project S2 within the CRC 1119
CROSSING, the European Union’s Seventh Framework Pro-
gramme under grant agreement No. 609611 ( project PRAC-
TICE), and the Intel Collaborative Research Institute for
Secure Computing at TU Darmstadt.
Finally we thank the Agency for Innovation by Science
and Technology in Flanders (IWT) for their support.
References
[1] M. Abadi, M. Budiu, ´U. Erlingsson, and J. Ligatti.
Control-ﬂow integrity principles, implementations, and
applications. ACM Transactions on Information
System Security, 13, 2009.
[2] M. Backes and S. N¨urnberger. Oxymoron - making
ﬁne-grained memory randomization practical by
allowing code sharing. In USENIX Security Symposium,
2014.
[3] M. Backes, T. Holz, B. Kollenda, P. Koppe,
S. N¨urnberger, and J. Pewny. You can run but you
can’t read: Preventing disclosure exploits in executable
code. In ACM Conference on Computer and
Communications Security (CCS), 2014.
[4] S. Bhatkar and D. C. DuVarney. Eﬃcient techniques
for comprehensive protection from memory error
exploits. In USENIX Security Symposium, 2005.
[5] S. Bhatkar, D. DuVarney, and R. Sekar. Address
obfuscation: An eﬃcient approach to combat a broad
range of memory error exploits. In USENIX Security
Symposium, 2003.
[6] A. Bittau, A. Belay, A. J. Mashtizadeh, D. Mazi`eres,
and D. Boneh. Hacking blind. In IEEE Symposium on
Security and Privacy (S&P), 2014.
[7] T. K. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang.
Jump-oriented programming: a new class of code-reuse
attack. In ACM Symposium on Information, Computer
and Communications Security (ASIACCS), 2011.
[8] S. Checkoway, L. Davi, A. Dmitrienko, A. Sadeghi,
H. Shacham, and M. Winandy. Return-oriented
programming without returns. In ACM Conference on
Computer and Communications Security (CCS), 2010.
[9] CodeSourcery, Compaq, EDG, HP, IBM, Intel, Red
Hat, and SGI. Itanium C++ Application Binary
Interface (ABI), 2001.
[10] S. Crane, P. Larsen, S. Brunthaler, and M. Franz.
Booby trapping software. In Workshop on New
Security Paradigms (NSPW), 2013.
[11] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen,
A.-R. Sadeghi, S. Brunthaler, and M. Franz. Readactor:
Practical code randomization resilient to memory
disclosure. In IEEE Symposium on Security and
Privacy (S&P), 2015.
[12] T. H. Dang, P. Maniatis, and D. Wagner. The
performance cost of shadow stacks and stack canaries.
In ACM Symposium on Information, Computer and
Communications Security (ASIACCS), 2015.
[13] L. Davi, C. Liebchen, A.-R. Sadeghi, K. Z. Snow, and
F. Monrose. Isomeron: Code randomization resilient to
(just-in-time) return-oriented programming. In
Symposium on Network and Distributed System
Security (NDSS), 2015.
[14] L. V. Davi, A. Dmitrienko, S. N¨urnberger, and
A. Sadeghi. Gadge me if you can: secure and eﬃcient
ad-hoc instruction-level randomization for x86 and
ARM. In ACM Symposium on Information, Computer
and Communications Security (ASIACCS), 2013.
[15] I. Evans, S. Fingeret, J. Gonzalez, U. Otgonbaatar,
T. Tang, H. Shrobe, S. Sidiroglou-Douskos, M. Rinard,
and H. Okhravi. Missing the point: On the
eﬀectiveness of code pointer integrity. In IEEE
Symposium on Security and Privacy (S&P), 2015.
[16] R. Gawlik and T. Holz. Towards Automated Integrity
Protection of C++ Virtual Function Tables in Binary
Programs. In Annual Computer Security Applications
Conference (ACSAC), 2014.
[17] J. Gionta, W. Enck, and P. Ning. HideM: Protecting
the contents of userspace memory in the face of
disclosure vulnerabilities. In ACM Conference on Data
and Application Security and Privacy (CODASPY),
2015.
[18] A. Homescu, S. Brunthaler, P. Larsen, and M. Franz.
Librando: transparent code randomization for
just-in-time compilers. In ACM Conference on
Computer and Communications Security (CCS), 2013.
[19] A. Homescu, S. Neisius, P. Larsen, S. Brunthaler, and
M. Franz. Proﬁle-guided automatic software diversity.
254In IEEE/ACM International Symposium on Code
Generation and Optimization (CGO), 2013.
[20] D. Jang, Z. Tatlock, and S. Lerner. SAFEDISPATCH:
Securing C++ virtual calls from memory corruption
attacks. In Symposium on Network and Distributed
System Security (NDSS), 2014.
[21] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea,
R. Sekar, and D. Song. Code-pointer integrity. In
USENIX Security Symposium, 2014.
[22] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz.
SoK: Automated software diversity. In IEEE
Symposium on Security and Privacy (S&P), 2014.
[23] Z. Lin, R. Riley, and D. Xu. Polymorphing software by
randomizing data structure layout. In Conference on
Detection of Intrusions and Malware & Vulnerability
Assessment (DIMVA), 2009.
[24] V. Mohan, P. Larsen, S. Brunthaler, K. Hamlen, and
M. Franz. Opaque control-ﬂow integrity. In Symposium
on Network and Distributed System Security (NDSS),
2015.
[25] S. Nagarakatte, J. Zhao, M. M. Martin, and
S. Zdancewic. SoftBound: Highly compatible and
complete spatial memory safety for C. In ACM
SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), 2009.
[26] Nergal. The advanced return-into-lib(c) exploits: PaX
case study. Phrack Magazine, 11, 2001.
[27] A. Prakash, X. Hu, and H. Yin. vfGuard: Strict
Protection for Virtual Function Calls in COTS C++
Binaries. In Symposium on Network and Distributed
System Security (NDSS), 2015.
[28] rix. Smashing C++ VPTRS. Phrack Magazine, 56(8),
2000. URL http://phrack.org/issues/56/8.html.
[29] R. Roemer, E. Buchanan, H. Shacham, and S. Savage.
Return-oriented programming: Systems, languages, and
applications. ACM Transactions on Information
System Security, 15, 2012.
[30] F. Schuster, T. Tendyck, J. Pewny, A. Maaß,
M. Steegmanns, M. Contag, and T. Holz. Evaluating
the Eﬀectiveness of Current Anti-ROP Defenses. In
International Symposium on Research in Attacks,
Intrusions and Defenses (RAID), 2014.
[31] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R.
Sadeghi, and T. Holz. Counterfeit Object-oriented
Programming: On the Diﬃculty of Preventing Code
Reuse Attacks in C++ Applications. In IEEE
Symposium on Security and Privacy (S&P), 2015.
[32] F. J. Serna. The info leak era on software exploitation.
In BlackHat USA, 2012.
[33] H. Shacham, M. Page, B. Pfaﬀ, E. Goh, N. Modadugu,
and D. Boneh. On the eﬀectiveness of address-space
randomization. In ACM Conference on Computer and
Communications Security (CCS), 2004.
[34] J. Siebert, H. Okhravi, and E. S¨oderstr¨om. Information
Leaks Without Memory Disclosures: Remote Side
Channel Attacks on Diversiﬁed Code. In ACM
Conference on Computer and Communications Security
(CCS), 2014.
[35] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko,
C. Liebchen, and A. Sadeghi. Just-in-time code reuse:
On the eﬀectiveness of ﬁne-grained address space
layout randomization. In IEEE Symposium on Security
and Privacy (S&P), 2013.
[36] C. Song, C. Zhang, T. Wang, W. Lee, and D. Melski.
Exploiting and protecting dynamic code generation. In
Symposium on Network and Distributed System
Security (NDSS), 2015.
[37] L. Szekeres, M. Payer, T. Wei, and D. Song. SoK:
Eternal war in memory. In IEEE Symposium on
Security and Privacy (S&P), 2013.
[38] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway,
´U. Erlingsson, L. Lozano, and G. Pike. Enforcing
forward-edge control-ﬂow integrity in GCC & LLVM.
In USENIX Security Symposium, 2014.
[39] M. Tran, M. Etheridge, T. Bletsch, X. Jiang, V. W.
Freeh, and P. Ning. On the expressiveness of
return-into-libc attacks. In International Symposium on
Research in Attacks, Intrusions and Defenses (RAID),
2011.
[40] C. Zhang, C. Song, K. Z. Chen, Z. Chen, and D. Song.
VTint: Defending virtual function tables’ integrity. In
Symposium on Network and Distributed System
Security (NDSS), 2015.
APPENDIX
Figures 8–11 below depict excerpts from widely used C++
software resulting in REC-Gs. Each REC-G exists in at least
the x86-64 version of the respective software. In each ﬁgure,
the call sites A and B are marked analogously to Figure 1.
Figure 8: mo_lambda.cpp in the Boost library (version
1.58 and others); causes a side-eﬀect free REC-G on
Ubuntu 14.04 and Windows 10.
Figure 9: qpixmap_blitter.cpp in the Qt library (ver-
sion 5.5 and others); causes a side-eﬀect free REC-G
in libQt5Gui.so on Ubuntu 14.04 and a REC-G with
side eﬀects in Qt5Gui.dll on Windows 10.
Figure 10: agents.h in Microsoft Visual C++ 2013;
causes a side-eﬀect free REC-G in Microsoft’s C++
runtime library msvcp120.dll.
Figure 11: SkComposeShader.cpp in Chromium (ver-
sion 44 and others); causes a side-eﬀect free REC-G
in Chromium.
virtual name *clone() const{    plural_ptr op1_copy(op1->clone());    plural_ptr op2_copy(op2->clone());    return new name(op1_copy, op2_copy);}BAQBlittablePlatformPixmap::    ~QBlittablePlatformPixmap(){#ifdef QT_BLITTER_RASTEROVERLAY    delete m_rasterOverlay;    delete m_unmergedCopy;#endif}BA~_Order_node_base(){    delete _M_pReceiveMessage;    delete _M_pSendMessage;}BAsize_t SkComposeShader::contextSize() const {    return sizeof(ComposeShaderContext)         + fShaderA->contextSize()         + fShaderB->contextSize();}BA255