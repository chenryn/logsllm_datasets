也将它们视为一个长的输人流，且S只应用到最后一个文件的最后一行（GNU的
sed具有一个选项，可使地址分开地应用到每个文件，见其说明文档）。
行编号
可以使用绝对的行编号作为地址。稍后将有介绍。
范围
可指定行的范围，仅需将地址以逗点隔开：
,6/xnnb/zq/e /3vq/*/0o3/. pes
sed -n *10,42p′ f00,xm]
仅打印1.0~42行
仅替换范围内的行
第二个命令为“从含有foo的行开始，再匹配是否有bar的行，再将匹配后的结
果中，有baz的全换成quux”（像ed、ex这类的检阅程序，或是vi内的冒号命
令提示模式下，都认识此语法）。
这种以逗点隔开两个正则表达式的方式称为范围表达式（rangeexpression）。在
sed里，总是需要使用至少两行才能表达，
否定正则表达式
有时，将命令应用于不匹配于特定模式的每一行，也是很有用的。通过将！加在正
则表达式后面就能做到，如下所示：
/used/18/new/wsed/g
将没有used的每个行里所有的new改成used
POSIX标准指出：空白（whitespace）跟随在：之后的行为是“未定义的
（unspecified）”，并建议需提供完整可移植性的应用软件，不要在1之后放置任何
空白字符，这明显是由于某些sed的古董级版本仍无法识别它。
例3-1说明的是使用绝对的行编号作为地址的用法，这里是以sed展现的head程序简
易版。
例3-1：使用 sed的 head命令
u---po 
语法：head N file
count=$1
sed ${count}q *$2*
www.TopSage.com
---
## Page 81
查找与替换
69
当你引l用head10foo.xml之后，sed会转换成sed10qfoo.xm1。q命令要求sed
马上离开，不再读取其他输人，或是执行任何命令。后面的7.6.1节里，我们将介绍如
何让这个脚本看起来更像真正的head命令。
这今为止，我们看到的都是sed以/字符隔开模式以便查找。在这里，我们要告诉你如
何在模式内使用不同的定界符：这通过在字符前面加上一个反斜杠实现：
$grep tolatoy /etc/pasawd
显示原始行
Ssed-n*\:tolstoy:8;TolatoyD′/etc/gasswd
tolstoy:x:2076:10:Leo To1stoy:/home/to1stoy:/bin/baeh
改变定界符
Tolstoy:x:2076:10:Leo To1stoy: /home/to1stoy:/bin/bash
本例中，以督号隔开要查找的模式，而分号则扮演s命令的定界符角色（编辑上的操作
其实不重要，我们的重点是介绍如何使用不同的定界符）。
3.2.10有多少文本会改动
有个问题我们一直还没讨论到：有多少文本会匹配？事实上，这应该包含两个问题。第
二个问题是：从哪儿开始匹配？执行简单的文本查找，例如使用grep或egrep时，则
这两个问题都不重要，你只要知道是否有一行是匹配的，若有，则看看那一行是什么。
至于在这个行里，是从哪儿开始匹配，或者它扩展到哪里，已经不重要了。
但如果你要使用sed执行文本替换，或者要用awk写程序，这两个问题的答案就变得非
常重要了（如果你每天都在文本编辑器内工作，这也算是个重要议题，只是本书的重点
不在文本编辑器）。
这两个问题的答案是：正则表达式匹配可以匹配整个表达式的输入文本中最长的、最左
边的子字符事。除此之外，匹配的空（null）字符串，则被认为是比完全不匹配的还长
（因此，就像我们先前所解释的，正则表达式：ab*c匹配文本ac，而b*则成功地匹配
于a与c之间的nulI字符串）。再者，POSIX标准指出：“完全一致的匹配，指的是自最
左边开始匹配、针对每一个子模式、由左至右，必须匹配到最长的可能字符申”。（子模
式指的是在ERE下圆括号里的部分，为此目的，GNU的程序通常也会在BRE里以
\(...\）提供此功能）。
如果sed要替代由正则表达式匹配的文本，那么确定该正则表达式匹配的字不会太少或
太多就非常重要了，这里有个简单例子：
echoZolatoy writen wel11eed‘8/Toletoy/Cemus/使用图定字符率
Camu8, writee we11
当然，sed可以使用完整的正则表达式，这里就是要告诉你，了解“从最长的最左边
（longestleftmost）规则有多的重要：
www.TopSage.com
---
## Page 82
70
第多常日
$echo Tolstoy is worldly 1sed*8/T.*y/Camus/
试试正则表达式age.com
Cattus
结果呢？
很明显，这里只是要匹配Tolstoy，但由于匹配会扩展到可能的最长长度的文本量，所
以就一直找到worldly的y了1你需要定义的更精确些：
Camus is worldly
通常，当开发的脚本是要执行大量文本剪贴和排列组合时，你会希望谨慎地测试每样东
西，确认每个步骤都是你要的一尤其是当你还在学习正则表达式里的微妙变化的阶
段的时候。
最后，正如我们所见到的，在文本查找时有可能会匹配到null字符串。面在执行文本替
代时，也允许你插入文本：
/t/a/8, pe8 1oqe oqoe s
替代第一个匹配成功的
.5//q/,1qeo
labc
替代所有匹配成功的
lalc1
请留意，b*是如何匹配在abc的前面与结尾的null字符申。
3.2.11行V.S.字符串
了解行（line）与字符串（string）的差异是相当重要的。大部分简易程序都是处理输入
数据的行，像grep与egrep，以及sed大部分的工作（99%）都是这样。在这些情况下，
然而，对可应用正则表达式的程序语言，例如awk、Perl以及Python，所处理的就多半
是字符串。若每个字符串表示的就是独立的一行输人，则与$仍旧可分别表示行的开
头与结尾。不过这些程序语言，其实可以让你使用不同的方式来标明每条输入记录的定
界符，所以有可能单独的输入“行”（记录）里会有内嵌的换行字符。这种情况下，与
$无法匹配内嵌的换行字符：它们只用来表示字符申的开头与结尾。当你开始使用可程
序化的软件工具时，这一点，请牢记在心。
3.3
字段处理
很多的应用程序，会将数据视为记录与字段的结合，以便于处理。一条记录（record）指
的是相关信息的单个集合，例如以企业来说，记录可能含有顾客、供应商以及员工等数
据，以学校机构来说，则可能有学生数据，而字段（field）指的就是记录的组成部分，
例如姓、名或者街道地址。
www.TopSage.com
---
## Page 83
查找与替换
IL
3.3.1文本文件惯例
由于UNIX鼓励使用文本型数据，因此系统上最常见的数据存储类型就是文本了，在文
本文件下，一行表示一条记录。这里要介绍的是在一行内用来分隔字段的两种惯例。首
先是直接使用空白（whitespace），也就是用空格键（space）或制表（tab）键：
S cat myapp.data
unit8 8o1d
23
salesper8on
xj11
r§45
1.2
Jane
Joe
cat6
65
chris
+ + *
本例中，学符起始的行表示注释，可忽略（这是一毅的习惯，注释行的功能相当好用，
不过软件必须可忽略这样的行才行）。各字段都以任意长度的空格（space）或制表（Tab）
字符隔开。第二种惯例是使用特定的定界符来分隔字段，例如冒号：
$ cat myapp.data
# model:units 8o1d:salesperson
xj11:23:jane
r545:12:joe
cat6:65:chris
+ + *
两种惯例都有其优缺点。使用空白作为分隔时，字段内容就最好不要有空白（著你使用
制表字符（Tab）作分隔，字段里有空格是不会有问题的，但这么做视觉上会混淆，因
为你在看文件时，很难马上分辨出它们的不同）。反过来说，若你使用显式的定界符，那
么该定界符也最好不要成为数据内容。请你尽可能小心地选择定界符，让定界符出现在
数据内容里的可能性降到最低或不存在。
注章：这两种方式最明显的不同，便是在处理多个连续重复的定界符之时。使用空白
（whitespace）分隔时，通常多个连续出现的空格或制表字符都将看作一个定界符，然面，若
使用的是特殊字符分隔，则每个定界符都隔开一个字段，例如，在myapp.data的第二个
服本里使用的两个管号字符（“：：）则会分赢出一个空的字段。
以定界符分隔字段最好的例子就是/etc/passwd了，在这个文件里，一行表示系统里
的一个用户，每个字段都以冒号隔开。在本书中，很多地方都会以/etc/passwd为例，
因为在系统管理工作中，很多时候都是在处理这个文件。如下是该文件的典型例子：
tolstoy:x:2076:10:Leo To1atoy1/home/to1atoy:/bin/bash
该文件含有7个字段，分别是：
www.TopSage.com
---
## Page 84
72
第3章
1.
用户名称
2.
加密后的密码（如账号为停用状态，此处为一个星号，或是若加密后的密码文件存
储于另外的/etc/shadow里，则这里也可能是其他字符）。
3.
用户ID编号。
4.
用户组ID编号。
5.
用户的姓名，有时会另附其他相关数据（办公室号码、电话等）。
6.
根目录。
7.
登录的Shell。
某些UNIX工具在处理以空白界定字段的文件时，微得比较好，有些则是以定界符分隔
字段比较好，更有其他的工具两种方式都能处理得当，这部分我们稍后会介绍，
3.3.2使用cut选定字段
cut命令是用来剪下文本文件里的数据，文本文件可以是字段类型或是字符类型。后一
种数据类型在遇到需要从文件里剪下特定的列时，特别方便。请注意：一个制表字符在
此被视为单个字符（注8）。
举例来说，下面的命令可显示系统上每个用户的登录名称及其全名：
$cut-d:-f 1,5/etc/gasawd
取出字段
qo0.1s1oo2
管理者账号
tolstoy:Leo Tolstoy
实际册户
austen:Jane Austen
camus:Albert Camus
通过选择其他字段编号，还可以取出每个用户的根目录：
pneeed/o3o/ 9 }- 1 p- 4no $
/reot
取出视目录
管理账号
/hoe/to1stoy
 +
实际用户
/home/austen
/home/camus
通过字符列表微剪下操作有时是很方便的。例如，你只要取出命令1s-1的输出结果
中的文件权限字段：
注8：
这可通过expand 与 unexpand 改变其定义，见expamd(1)手册页。
www.TopSage.com
---
## Page 85
查找与替换
Cut
用：
语法
cut-clist[file...]
cut-f1ist'['-ddelim]rfile.!.]
用途
从输入文件中选择一或多个字段或者一组字将，配合管道（pipeline），可再
做进一步处理。
主要选项
-c list
以字持为主，执行剪下的操作。1ist为字符编号或一段范围的列表（以
运点隔开），例如1.3，5-12.42
-d delim
通过-f选项，使用delim作为定界持。联认的定界将为制表字符（Tab）。
-f list
以字段为主，作剪下的操作。1ist为字段编号或一段范围的列表（以运
点隔开）
行为模式
剪下输入字符中指定的字段或指定的范固。若处理的是字段，则定界符隔开
的即为各字段，而输出时字段也以给定的定界符隔开。若命令行没有指定文
件，则读取标准输入。见正文中的范例。
营告
于POSIX系统下，cut识别多字节字将，因此，字持（character）”与“字
节（byte）”意义不同，详细内容见cur（1）的手册页，
有些系统对输入行的大小有所限制，尤其是含有多字节字将.（multibyte
characters）时，这点请特别留意。
$1s-11cut-c1-10
total.2878
droxr-xr-x
-rW-r--r--
-r--r--r--
-IW---
不过这种用法比使用字段的风险要大。因为你无法保证行内的每个字段长度总是一样的。
一般来说，我们偏好以字段为基础来提取数据。
www.TopSage.com
---
## Page 86
74
第3章
3.3.3使用join连接字段
join命令可以将多个文件结合在一起，每个文件里的每条记录，都共享一个键值（key），
键值指的是记录中的主字段，通常会是用户名称、个人姓氏、员工编号之类的数据。举
例来说，有两个文件，一个列出所有业务员销售业绩，一个列出每个业务员应实现的业
绩：