3.3 Attacking Other ECSDA Implementations
Attacking OpenSSL on Android Devices. Key-dependent leakage, similar to Figure 2, was
also observed on various Android phones. See Figure 3. We thus conjecture that similar attacks can
be mounted on these devices as well. Demonstrating the feasibility of such a result on an Android
device, Figure 7 shows the extraction of a sequence of elliptic curve double and add operations
from a Sony-Ericsson Xperia X10 smartphone. The signal in the ﬁgure is the result of digital FM
demodulation and ﬁltering.
Attacking CoreBitcoin. Demonstrating the possibility of Bitcoin theft via side-channel from iOS
devices, we have mounted a successful key extraction attack on CoreBitcoin’s low s-value ECDSA
implementation running on iOS. We recorded the leakage of 5000 ECDSA secp256k1 signatures
executed on an Apple iPhone 3GS smartphone. Out of these 5000 traces, 1940 were discarded due
to measurement noise. Out of the remaining 3060 traces, 110 were identiﬁed as having their DA
sequence terminate in at least four elliptic curve double operations with one of these being a false
positive (again, discovered in retrospect). Next, we randomly chose 85 out of the 110 available
traces and applied the lattice attack described in Section 2.3. Repeating the attack 20 times (each
time choosing a random subset containing 85 traces) resulted in a successful key extraction in 4 out
of the 20 attempts. Similar to Section 3.2, all the 20 repetitions of the lattice reduction step were
14
Figure 7: Sequence of double and add operations extracted during a secp256k1 scalar by point
multiplication operation executed on an Sony-Ericsson Xperia X10 smartphone. In this experiment
we replaced the wNAF representation of k with the 256-digit string obtained by repeating the
pattern 10100.
Figure 8: EM measurement (0.2 sec, 0–250 kHz) of four scalar-by-point multiplication operations
using the NIST P-521 curve executed on an iPhone 3GS smartphone running Apple’s Common-
Crypto library. As in Figure 2, the scalar was set to be either a random 521-digit number or a the
521-digit number obtained by repeating the pattern written to the right. In all cases, the same
curve point was used to perform the multiplication.
done oﬄine on the same data base of analog traces. Thus, even a single successful lattice reduction
leads to a successful key-recovery attack.
Attacking Apple’s CommonCrypto ECDSA Implementation. The ECDSA implementa-
tion of Apple’s CommonCrypto library performs the elliptic curve scalar-by-point multiplication
operation using Algorithm 1 with w = 1. Figure 8 shows scalar-dependent leakage, similar to
Figure 2, obtained by measuring an iPhone 3GS when invoking the elliptic curve multiplication
operation as implemented in Apple’s CommonCrypto library.
4 Cheap Attacks
While the results of Section 3 clearly demonstrate the possibility of key extraction via the electro-
magnetic channel using expensive lab equipment, the low bandwidth nature of our attacks allows
for key extraction using a much cheaper experimental setup via both the electromagnetic channel
15
Figure 9: Mounting a cheap power analysis attack on an iPhone 4 through its charging port. This
setup includes a portable battery (bottom, left), a power monitoring probe (bottom, middle) and
an iPhone 4 (bottom, right). The power probe is then connected to the Tracker Pre sound card
(top, middle) and the attacker’s laptop (top, left).
and the power channel.
EM Probe. For the electromagnetic channel we improvised a probe by scavenging a coil from a
Qi wireless charging receiver module ($2 on eBay). See Figure 1.
Power Probe. To monitor the phone’s current draw, we built a simple USB pass-through adapter,
with a 0.33Ω resistance in series with the ground line. We then connected the phone to a portable
USB battery pack through the pass-through adapter, and measured the voltage over the resistor;
see Figure 9.
Digitizer. We connected the improvised EM and power probes into the microphone input of a
Creative Tracker Pre sound card ($50, eBay). This card acts both as an ampliﬁer (60dB gain) and
as a digitizer (192 Ksample/sec).4
Attack Scenario. Small loops of wire acting as EM probes can be easily concealed inside various
objects (such as tabletops, phone cases (especially those containing an extra battery), or even food
items [GPPT15]). See Figure 1. Monitoring the phone’s power consumption can be easily done by
augmenting an aftermarket charger, external battery or battery case with the requisite equipment.
In this context, phone cases which contain an additional battery (and therefore are connected to
the phone’s charging port) are especially dangerous since these can be augmented to monitor both
channels simultaneously, thus obtaining a potentially cleaner signal. We leave this for future work.
Scalar-Dependent Leakage. We measured the EM leakage of an iPhone 4 using our improvised
EM probe connected to the Tracker Pre sound card and concealed beneath a glass tabletop (see
Figure 10). Similarly to Figure 3, Figure 10 (right) presents a spectrogram of ﬁve distinct signature
operations, using the same point P and ﬁve diﬀerent values of the scalar k. Notice that even
though the equipment used to generate Figure 10 is much simpler (and cheaper) than the lab-grade
equipment used in Figure 3, the ﬁve diﬀerent scalars can be easily distinguished from their spectral
signature. Similar results were obtained using the power probe as well (see Figure 10 (left)).
Extracting the DA-Sequence. After observing the scalar dependent leakage using our impro-
vised probes and the Tracker Pre sound card, we proceeded to extract the DA-sequence which
4 Alternatively, one could use an inexpensive USB oscilloscope. However, these are optimized for bandwidth (at
the expense of SNR), and would require an additional ampliﬁer. Sound cards typically oﬀer higher SNR and a built-in
ampliﬁer, and while their bandwidth is much lower, it suﬃces for our attacks.
16
Figure 10: Power (left) and EM (right) measurement (0.2 sec, 0–96 kHz) of ﬁve scalar-by-point
multiplication operations using the NIST P-521 curve executed on an iPhone 4 smartphone running
OpenSSL. As in Figure 2, the scalar was set to be either a random 521-digit number or a the 521-
digit number obtained by repeating the pattern written to the right. In all cases, the same curve
point was used to perform the multiplication.
Figure 11: Extracted DA-sequence obtained from iPhone 3GS during an OpenSSL secp256k1 sig-
nature operation. The leakage was measured using the Tracker Pre sound card and the improvised
EM probe. The double and add operations can clearly be seen.
is required for our attack. Applying our signal processing techniques on an iPhone 3GS run-
ning OpenSSL secp256k1 signature operations, Figure 11 depicts the results of extracting the DA-
sequence using EM leakage from a single signature. Notice that the individual double and add
operations can clearly be seen. Repeating this process for about 5000 signatures should result in a
complete key recovery.
5 Conclusions
In this paper we have demonstrated that despite its speed and randomization, ECDSA signatures
on mobile devices are vulnerable to physical key extraction attacks. Moreover, the attacks can be
mounted cheaply and non-intrusively. Our attack exploits the diﬀerences between point addition
and point doubling to recover the DA-sequence. Two approaches can be used to protect an imple-
mentation from side-channels. The value of the nonce can be decoupled from the DA-sequence using
blinding. Alternatively, the implementation can be modiﬁed to always use the same DA-sequence,
irrespective of the value of the nonce.
17
Nonce Splitting. Clavier and Joye [CJ01] suggest expressing the nonce k as k = k1 + k2, where
k1 is random and then compute [k1]G + [k2]G using a multi-exponentiation algorithm [M¨ol01a].
However, this approach leaks the least signiﬁcant bits of k1 and k2, as well as long, overlapping
sequences of repeating bits in k1 and k2. Splitting the nonce more, i.e., expressing k = k1 +k2 +k3 +
··· , such that all the terms but one are chosen at random, can reduce the probability of overlaps.
However, this approach still leaks the least signiﬁcant bit of k and as [AFG+14] show, leaks of one
bit can be exploitable.
Nonce Blinding. Coron [Cor99] suggests blinding the nonce by choosing a random c and calcu-
lating [k]G + [cn]G where n is the group order. Ciet and Joye [CJ03] note that for groups of order
close to a power of two, this method still leaks information about the high order bits of k, and Van
de Pol et al. [Van de PolSY15] show how to exploit such leaks. Combining the two approaches,
i.e., calculating(cid:80)[ki]G for random ki’s and c such that(cid:80) ki = k + cn, protects from both types
of leaks.
Constant-time Implementations. Constant-time implementations mitigate many side-channel
leaks by ensuring a ﬁxed execution path that does not depend on secret data, to prevent timing
attacks [BB05]. Additionally, a constant memory access pattern is desired to avoid cache-based
attacks [Ber05, Per05, OST06], as well as cache-induced diﬀerences in timing and electromagnetic
behavior. For, EC scalar-by-point multiplication, the scalar can be represented in a regular way
such that the DA-sequence does not depend on the nonce [JT09, M¨ol01b]; Moller [M¨ol01b] notes
that these encodings may leak information when a point is added to itself, yet with a random scalar,
as is the case in ECDSA, the probability of this leak is negligible. A constant-time implementation
for some elliptic curves, on some 64-bit platforms, is included in OpenSSL [K¨as12]. For Bitcoin’s
secp256k1 curve, the libsecp256k1 [Wui] implementation oﬀers a constant-time, constant-memory-
access implementation of ECDSA signing.
Future Work. While this work clearly demonstrates the vulnerability of multiple implementations
of ECDSA signatures running on mobile devices to cheap low-bandwidth key extraction attacks,
much works remains to be done. The vulnerability of other ECDSA implementations, as well
as general cryptographic code running on mobile devices has received much research attention.
Improving the signal quality, thereby increasing the attack range and reducing the number of
required signatures is an intriguing open problem. To that end, we note that the more advanced
lattice techniques of [Van de PolSY15, ABF+15] are of potential use in order to reduce the number
of signatures. However, our signal is too corrupted (due to interrupts) making these techniques
inapplicable without signiﬁcant improvements in signal processing techniques.
Acknowledgments
Daniel Genkin, Lev Pachmanov, Itamar Pipman and Eran Tromer are members of the Check Point
Institute for Information Security. This work was done in part while Eran Tromer was visiting the
Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the
DIMACS/Simons Collaboration in Cryptography through NSF grant #CNS-1523467.
This work was supported by the Blavatnik Interdisciplinary Cyber Research Center; by a Google
Faculty Research Award; by the Israeli Centers of Research Excellence I-CORE program (center
4/11); by the Leona M. & Harry B. Helmsley Charitable Trust; and by NATO’s Public Diplomacy
Division in the Framework of ”Science for Peace”.
18
A Current Status of Targeted Software
This appendix reviews the vulnerability status of the targeted software, at the time of writing. See
also Table 1.
OpenSSL 1.0.x branch. We have conducted most of our experiments on OpenSSL version
1.0.1m which was the latest version at the time of conducting this research. For ARM processors,
all curves over prime ﬁelds in the current versions of OpenSSL (1.0.1r and 1.0.2f) use the same
underlying elliptic curve implementation and thus appear vulnerable to attacks; while we did not
attempt key extraction, scalar-dependent leakage (similar to Figure 2) was empirically observed
from these OpenSSL versions as well. Upon contacting OpenSSL we were notiﬁed that “hardware
side-channel attacks are not in OpenSSL’s threat model”, so no updates are planned to OpenSSL
1.0.x to mitigate our attacks. Note that OpenSSL 1.0.2 will be supported until the year 2020,
OpenSSL 1.1.x branch. OpenSSL 1.1.0 pre-release 3 includes an ARM-speciﬁc constant-time
implementations of the NIST P-256 curve, which is unlikely to be vulnerable to similar attacks.
All other curves over prime ﬁelds, including the secp256k1 curve, still use the vulnerable wNAF
implementation.
iOS 7.1.2–8.3 CommonCrypto. The ECDSA implementation in the CommonCrypto frame-
work of iOS 7.1.2 appears vulnerable, since it exhibits scalar-dependent leakage (see Section 3.3).
Reverse-engineering the code in iOS 8.3 reveals that it uses the same vulnerable implementation
(wNAF with w = 1).
iOS 9.x CommonCrypto. Starting with iOS 9, CommonCrypto uses a new EC implementa-
tion, including side-channel mitigation techniques such as operand-independent control ﬂow and
Montgomery-ladder multiplication.5 Our current attacks are not applicable to this new EC imple-
mentation, and we have no evidence that it is vulnerable.
CoreBitcoin. CoreBitcoin [Cor] (not to be confused with Bitcoin core, below) is currently vul-
nerable, as discussed in Section 3.3.
the CoreBitcoin developers expressed their
intention to switch to the libsecp256k1 library [Wui] in the future. This library oﬀers a constant-
time, constant-memory-access implementation of ECDSA signing, and we have no evidence that it
is vulnerable.
In response.
Bitcoin Core. The Bitcoin core code [Bita] (not to be confused with the CoreBitcoin, above)
has already transitioned to the libsecp256k1 library [Wui] for ECDSA signing, starting from version
v0.10.0 (released in February 2015).6 This library oﬀers a constant-time, constant-memory-access
implementation of ECDSA signing, and we have no evidence that it is vulnerable.
References
[AAF+11]
D. Aboulkassimi, M. Agoyan, L. Freund, J. Fournier, B. Robisson, and A. Tria.
Electromagnetic analysis (EMA) of software AES on Java mobile phones.
In
Workshop on Information Forensics and Security (WIFS) 2011, pages 1–6. IEEE
Computer Society, 2011.
5The relevant code is in the corecrypto library version 337 [App]. The Apple Product Security conﬁrmed that this
is, essentially, the implementation in all iOS 9.x versions, as well as OS X 10.11, and that 77% of the iOS installations
are iOS 9.x, as of February 2016.
6 Bitcoin Git commit fda3fed18a added support for libsecp256k1 ECDSA signing, and commit dffb8f81b8 re-
moved support for OpenSSL ECDSA signing.
19
[AARR02]
[ABC+]
[ABF+15]
[ADMM15]
[AFG+14]
[And08]
[App]
[Arc]
[BB05]
[Ber05]
[BFMRT16a]
[BFMRT16b]
[BGRV15]
[BH09]
[Bita]
[Bitb]
[Bitc]
[BT11]
Dakshi Agrawal, Bruce Archambeault, Josyula R. Rao, and Pankaj Rohatgi. The
EM side-channel(s).
In Workshop on Cryptographic Hardware and Embedded
Systems (CHES) 2002, pages 29–45. Springer, 2002.
M. Albrecht, S. Bai, D. Cad´e, X. Pujol, and D. Stehl´e. fplll-4.0, a ﬂoating-point
LLL implementation. URL: http://perso.ens-lyon.fr/damien.stehle.
Thomas Allan, Billy Bob Brumley, Katrina E. Falkner, Joop van de Pol, and
Yuval Yarom. Amplifying side channels through performance degradation. Cryp-
tology ePrint Archive, Report 2015/1141, 2015. http://ia.cr/2015/1141.
Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz
Mazurek. On the malleability of Bitcoin transactions.
In Financial Cryptog-
raphy and Data Security - FC 2015, pages 1–18, 2015.
Diego F. Aranha, Pierre-Alain Fouque, Benoˆıt G´erard, Jean-Gabriel Kammerer,
Mehdi Tibouchi, and Jean-Christophe Zapalowicz. GLV/GLS decomposition,
power analysis, and attacks on ECDSA signatures with single-bit nonce bias. In
ASIACRYPT 2014, Part I, pages 262–281. Springer, 2014.
Ross J. Anderson. Security Engineering — A Guide to Building Dependable