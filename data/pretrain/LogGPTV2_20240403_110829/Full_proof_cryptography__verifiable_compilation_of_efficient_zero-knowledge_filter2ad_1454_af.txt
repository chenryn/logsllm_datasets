fering differently abstract input languages have been proposed,
e.g., [4, 7, 37, 50]. However, none of those tools supports formal
veriﬁcation.
A number of works have considered applications of formal ver-
iﬁcation to ZK-PoK. Barthe et al. [11] use CertiCrypt to prove
soundness, completeness, and zero-knowledge of Σφ-protocols and
simple And/Or-compositions thereof. Although these results were
constructed by hand and needed to be extended for a wider range of
proof goals and arbitrary Boolean compositions, they are at the gen-
esis of the formal veriﬁcation infrastructure of ZKCrypt. Backes et
al. [3] propose a method for checking that zero-knowledge proofs
are adequately used, and apply their method to the DAA protocol.
9. CONCLUSIONS
ZKCrypt is an experimental high-assurance zero-knowledge
compiler that applies state-of-the-art approaches in veriﬁed and
verifying compilation to the realm of cryptography.
It achieves
an unprecedented level of conﬁdence among cryptographic com-
pilers. The veriﬁcation infrastructure of ZKCrypt is based on the
CertiCrypt platform, and relies on a set of carefully isolated con-
cepts, including a new uniﬁed approach to special soundness and
a novel formal treatment of goal resolution as a compilation step.
We demonstrated that the compiler and the veriﬁcation component
are able to handle a large number of applications using ZK-PoKs.
There are plenty of avenues for future research in the ﬁeld of
cryptographic compilation and veriﬁcation in general, and for the
class of ZK-PoKs in particular. One future task is to verify the last
stage of the compiler chain, code generation, to cover the entire
compilation process. An interesting question is how far veriﬁed
compilation can be extended beyond ZK-PoKs.
10. REFERENCES
[1] ABC4TRUST EU PROJECT. Ofﬁcial Website.
https://abc4trust.eu/, 2011.
[2] ALMEIDA, J. B., BANGERTER, E., BARBOSA, M.,
KRENN, S., SADEGHI, A.-R., AND SCHNEIDER, T. A
Certifying Compiler for Zero-Knowledge Proofs of
Knowledge Based on Σ-Protocols. In ESORICS ’10 (2010),
vol. 6345 of LNCS, Springer.
[3] BACKES, M., HRITCU, C., AND MAFFEI, M.
Type-Checking Zero-Knowledge. In ACM CCS 08 (2008),
ACM, pp. 357–370.
[4] BAIN, A., MITCHELL, J. C., SHARMA, R., STEFAN, D.,
AND ZIMMERMAN, J. A Domain-Speciﬁc Language for
Computing on Encrypted Data (Invited Talk). In FSTTCS
2011 (2011), vol. 13 of LIPIcs, Schloss Dagstuhl, pp. 6–24.
[5] BANGERTER, E., BARZAN, S., KRENN, S., SADEGHI,
A.-R., SCHNEIDER, T., AND TSAY, J.-K. Bringing
zero-knowledge proofs of knowledge to practice. In SPW 09
(2009).
[6] BANGERTER, E., BRINER, T., HENEKA, W., KRENN, S.,
SADEGHI, A.-R., AND SCHNEIDER, T. Automatic
generation of Σ-protocols. In EuroPKI 09 (2009).
[7] BANGERTER, E., KRENN, S., SEIFRIZ, M., AND
ULTES-NITSCHE, U. cPLC - A Cryptographic Programming
Language and Compiler. In ISSA 2011 (2011), IEEE.
498[8] BARTHE, G., GRÉGOIRE, B., AND BÉGUELIN, S. Formal
certiﬁcation of code-based cryptographic proofs. In POPL 09
(2009), pp. 90–101.
[9] BARTHE, G., GRÉGOIRE, B., HERAUD, S., OLMEDO, F.,
AND ZANELLA BÉGUELIN, S. Veriﬁed indifferentiable
hashing into elliptic curves. In POST 2012 (Heidelberg,
2012), LNCS, Springer.
[10] BARTHE, G., GRÉGOIRE, B., HERAUD, S., AND
ZANELLA BÉGUELIN, S. Computer-aided security proofs
for the working cryptographer. In CRYPTO 2011
(Heidelberg, 2011), vol. 6841 of LNCS, Springer, pp. 71–90.
[11] BARTHE, G., HEDIN, D., ZANELLA BÉGUELIN, S.,
GRÉGOIRE, B., AND HERAUD, S. A machine-checked
formalization of Σ-protocols. In CSF 2010 (2010), IEEE.
[12] BARTHE, G., KÖPF, B., OLMEDO, F., AND ZANELLA
BÉGUELIN, S. Probabilistic reasoning for differential
privacy. In POPL 2012 (2012), ACM.
[13] BORISOV, N., GOLDBERG, I., AND BREWER, E.
Off-the-Record Communication, or, why not to use PGP. In
WPES 2004 (2004), ACM, pp. 77–84.
[14] BRANDS, S. An Efﬁcient Off-line Electronic Cash System
Based on the Representation Problem. Tech. Rep. CS-R9323,
CWI, 1993.
[15] BRICKELL, E. F., CAMENISCH, J., AND CHEN, L. Direct
Anonymous Attestation. In ACM CCS 04 (2004), ACM.
[16] BRINER, T. Compiler for zero-knowledge proof-of-
knowledge protocols. Master’s thesis, ETH Zurich, 2004.
[17] CAMENISCH, J., AND HERREWEGHEN, E. V. Design and
Implementation of the idemix Anonymous Credential
System. In ACM CCS 02 (2002), ACM Press, pp. 21–30.
[18] CAMENISCH, J., AND LYSYANSKAYA, A. A Signature
Scheme with Efﬁcient Protocols. In SCN 02 (2002),
vol. 2576 of LNCS, Springer, pp. 268–289.
[19] CAMENISCH, J., AND SHOUP, V. Practical Veriﬁable
Encryption and Decryption of Discrete Logarithms. In
CRYPTO 03 (2003), vol. 2729 of LNCS, Springer.
[20] CAMENISCH, J., AND STADLER, M. Efﬁcient group
signature schemes for large groups. In CRYPTO 97 (1997),
vol. 1294 of LNCS, Springer, pp. 410–424.
[21] CAMENISCH et al., J. Speciﬁcation of the Identity Mixer
Cryptographic Library (Version 2.3.0). Research Report RZ
3730 (#99740), IBM Research, 2010.
[22] CHAUM, D. Security without identiﬁcation: Transaction
systems to make big brother obsolete. Commun. ACM 28, 10
(1985), 1030–1044.
[23] CHAUM, D., AND EVERTSE, J.-H. A secure and
privacy-protecting protocol for transmitting personal
information between organizations. In CRYPTO (1986),
vol. 263 of LNCS, Springer, pp. 118–167.
[24] CRAMER, R. Modular Design of Secure yet Practical
Cryptographic Protocols. PhD thesis, CWI and University of
Amsterdam, 1997.
[25] CRAMER, R., DAMGÅRD, I., AND SCHOENMAKERS, B.
Proofs of partial knowledge and simpliﬁed design of witness
hiding protocols. In CRYPTO 94 (1994), vol. 839 of LNCS,
Springer, pp. 174–187.
[26] DAMGÅRD, I. On Σ-protocols, 2004. Lecture on
Cryptologic Protocol Theory; Faculty of Science, University
of Aarhus.
[27] DAMGÅRD, I., AND FUJISAKI, E. A statistically-hiding
integer commitment scheme based on groups with hidden
order. In ASIACRYPT 02 (2002), vol. 2501 of LNCS,
Springer, pp. 77–85.
[28] DAMGÅRD, I., GEISLER, M., KRØIGAARD, M., AND
NIELSEN, J. B. Asynchronous Multiparty Computation:
Theory and Implementation. In PKC 09 (2009), vol. 5443 of
LNCS, Springer, pp. 160–179.
[29] FIAT, A., AND SHAMIR, A. How to prove yourself:
practical solutions to identiﬁcation and signature problems.
In CRYPTO 86 (1987), vol. 263 of LNCS, Springer.
[30] FUJISAKI, E., AND OKAMOTO, T. Statistical zero
knowledge protocols to prove modular polynomial relations.
In CRYPTO 97 (1997), vol. 1294 of LNCS, Springer.
[31] GOLDBERG, I., USTAOGLU, B., GUNDY, M. V., AND
CHEN, H. Multi-party off-the-record messaging. In ACM
CCS 09 (2009), ACM, pp. 358–368.
[32] GOLDREICH, O. Zero-knowledge twenty years after its
invention. Tech. Rep. TR02-063, Electronic Colloquium on
Computational Complexity, 2002.
[33] GOLDREICH, O., MICALI, S., AND WIGDERSON, A.
Proofs that yield nothing but their validity or all languages in
NP have zero-knowledge proof systems. Journal of the ACM
38, 1 (1991), 691–729.
[34] GOLDWASSER, S., MICALI, S., AND RACKOFF, C. The
knowledge complexity of interactive proof-systems. In STOC
85 (1985), ACM, pp. 291–304.
[35] GONTHIER, G., MAHBOUBI, A., AND TASSI, E. A Small
Scale Reﬂection Extension for the Coq system. Rapport de
recherche RR-6455, INRIA, 2008.
[36] GUILLOU, L., AND QUISQUATER, J.-J. A “paradoxical”
identity-based signature scheme resulting from
zero-knowledge. In CRYPTO 88 (1990), vol. 403 of LNCS,
Springer, pp. 216–231.
[37] KIYOMOTO, S., OTA, H., AND TANAKA, T. A Security
Protocol Compiler Generating C Source Codes. In ISA 08
(2008), IEEE, pp. 20–25.
[38] LAGRANGE, J. L. Œuvres, 1770.
[39] LEROY, X. Formal certiﬁcation of a compiler back-end or:
programming a compiler with a proof assistant. In POPL 06
(2006), ACM Press, pp. 42–54.
[40] LIPMAA, H. On diophantine complexity and statistical
zeroknowledge arguments. In ASIACRYPT 03 (2003),
vol. 2894 of LNCS, Springer, pp. 398–415.
[41] MACKENZIE, P., OPREA, A., REITER, M. Automatic
generation of two-party computations. In ACM CCS 03
(2003), ACM, pp. 210–219.
[42] MALKHI, D., NISAN, N., PINKAS, B., AND SELLA, Y.
Fairplay – Secure two-party computation system. In USENIX
Security Symposium (2004), USENIX Association.
[43] MEIKLEJOHN, S., ERWAY, C., KÜPÇÜ, A., HINKLE, T.,
AND LYSYANSKAYA, A. ZKPDL: A Language-Based
System for Efﬁcient Zero-Knowledge Proofs and Electronic
Cash. In USENIX Security Symposium (2010), USENIX
Association, pp. 193–206.
[44] MICROSOFT. U-Prove.
http://www.microsoft.com/u-prove, 2011.
[45] NECULA, G. C., AND LEE, P. The design and
implementation of a certifying compiler. In PLDI (New
York, NY, USA, 1998), vol. 33, PUB-ACM, pp. 333–344.
[46] NIPKOW, T., AND PAULSON, L. Isabelle web site.
http://isabelle.in.tun.de, 2010.
499[47] RIAL, A., AND DANEZIS, G. Privacy-preserving smart
metering, 2011.
[48] RIVEST, R., SHAMIR, A., AND TAUMAN, Y. How to Leak a
Secret - Theory and Applications of Ring Signatures. In
ASIACRYPT 01 (2001), vol. 2248 of LNCS, Springer.
[49] SCHNORR, C. Efﬁcient signature generation by smart cards.
Journal of Cryptology 4, 3 (1991), 161–174.
[50] SCHRÖPFER, A., KERSCHBAUM, F., BISWAS, D.,
GEISSINGER, S., AND SCHÜTZ, C. L1 - Faster
Development and Benchmarking of Cryptographic
Protocols. In SPEED-CC 09 (2009).
[51] WANG, B., AND SONG, Z. A Non-Interactive Deniable
Authentication Scheme Based on Designated Veriﬁer Proofs.
Information Sciences 179, 6 (2009), 858–865.
[52] ZUCK, L. D., PNUELI, A., GOLDBERG, B., BARRETT,
C. W., FANG, Y., AND HU, Y. Translation and run-time
validation of loop transformations. Formal Methods in
System Design 27, 3 (2005), 335–360.
APPENDIX
A. AN OVERVIEW OF CertiCrypt
CertiCrypt [8, 10] is an automated toolset for proving the se-
curity of cryptographic constructions in the computational model.
It builds upon state-of-the-art veriﬁcation technologies to support
code-based proofs, in which security is cast in terms of equivalence
of probabilistic programs. The core of CertiCrypt is a rich set of
veriﬁcation techniques based on a Relational Hoare Logic for prob-
abilistic programs [8]. A recent extension [9] supports reasoning
about a broad range of quantitative properties, including statistical
distance, which is crucial in our deﬁnition of zero-knowledge.
The CertiCrypt toolset consists of two main components. Both
allow proving that the distributions generated by probabilistic ex-
periments are identical or statistically close, but differ in their de-
gree of automation, ﬂexibility and formal guarantees. The ﬁrst
component, called CertiCrypt, excels in ﬂexibility and is fully for-
malized in the Coq proof assistant; its veriﬁcation methods are
implemented in Coq and proved correct w.r.t. program seman-
tics. The second component, EasyCrypt, delivers a higher de-
gree of automation by relying on SMT solvers and automated the-
orem provers to discharge veriﬁcation conditions arising in proofs.
EasyCrypt generates proof certiﬁcates that can be mechanically
checked in Coq, thus practically reducing the trusted computing
base to that of the ﬁrst component; however, it lacks on generality
as it only exposes a limited set of proof methods. ZKCrypt takes
advantage of both components: it uses the latter to check the cor-
rectness of goal resolution and the former for verifying the compiler
for reference implementations and the equivalence of reference and
optimized implementations. We outline below some of the essen-
tial features of both components.
Language. Programs are written in a procedural, probabilistic im-
perative language that includes deterministic and random assign-
ments, conditional statements and loops. This base language suf-
ﬁces to conveniently express a wide class of cryptographic experi-
ments and security properties. However, to achieve greater ﬂexibil-
ity, the language of deterministic and random expressions is user-
extensible. A program c in the language of CertiCrypt denotes a
function JcK from an initial memory m (a mapping from program
variables to values) to a distribution over ﬁnal memories. We de-
note by Pr [c, S : m] the probability of event S w.r.t to the distri-
bution JcK m. We refer the reader to Barthe et al. [12] for a more
detailed description of the language and its semantics.
Reasoning principles. Proving the (approximate) equivalence of
the distributions generated by two probabilistic programs in Cer-
tiCrypt amounts to deriving valid judgments in an approximate Re-
lational Hoare Logic (apRHL). We restrict our attention in this pa-
per to a fragment of apRHL that captures both perfect and statisti-
cal indistinguishability of distributions generated by programs. We
consider judgments of the form c1 ∼ǫ c2 : Ψ ⇒ Φ where c1 and
c2 are probabilistic programs, Ψ, Φ binary relations over program
memories and ǫ ∈ [0, 1]. Taking Φ as the equality relation on a
subset of observable program variables X, one recovers the usual
deﬁnition of statistical indistinguishability. In particular, given an
event A, represented as a predicate over memories, if A only de-
pends on variables in X, one has
m1 Ψ m2 =⇒ |Pr [c1, m1 : A] − Pr [c2, m2 : A] | ≤ ǫ .
ǫ
We let c1 ≈Ψ,X
c2 denote the validity of c1 ∼ǫ c2 : Ψ ⇒ Φ when
Φ is the equality relation on variables in X; we omit Ψ when it is
the total relation or can be inferred from the context.
B.
INPUT FILE OF THE USE CASE
Figure 6 shows the input (a .zk-ﬁle) for our running exam-
ple. It is obtained by instantiating the template CL(m1, m2) with
the mapping underlying the CL-signature scheme [18] (cf. Equa-
tion 1), as is already done in the identity mixer speciﬁcation. The
rest of the ﬁle describes the algebraic setting and required security
goals.
The ﬁrst two blocks, Declarations and Inputs declare
all variables used in the protocol and the public and private in-
puts of the parties. Typically, variables will be declared as private
if and only if knowledge of these values has to be proved. The
Properties block speciﬁes the security properties and the over-
all structure of the protocol. The KnowledgeError of the gen-
erated protocol shall be at most 2−80, and the statistical distance of
simulated from real protocol runs must be at most 2−SZKParameter .
Inside ZKCrypt, the KnowledgeError parameter is translated
onto a concrete challenge length and SZKParameter gives the
security parameter controlling the tightness of the HVZK property.
The proof goal only consists of a single predicate. It shall be proved
using a SigmaGSP-protocol; the maximum ChallengeLength
that may safely be used for the homomorphism is speciﬁed (this
cannot be computed from phi as it would require to compute the
order of Zmod*(n)). For concrete values of n, i.e., strong RSA
moduli, this parameter implicitly gives the concrete value of d (the
product of all primes smaller than c+ dividing ord H) for which
the proof of knowledge property holds.
:= n, z, R_1, A, S, R_2, b;
Declarations {
Int(2048) n;
Zmod*(n)
z, R_1, R_2, A, S;
Int(1000) m_1, m_2, e, v, b;
}
Inputs {
Public
ProverPrivate := e, m_2, v;
}
Properties {
KnowledgeError
SZKParameter
ProtocolComposition := P_0;
}
SigmaGSP P_0 {
Homomorphism(phi: Z^3 -> Zmod*(n):
:= 80;
:= 80;
(e,m_2,v) |-> (A^e*S^v*R_2^m_2));
ChallengeLength := 80;
Relation(
(z*R_1^(-m_1)) = phi(e,m_2,v) And m_2 >= b); }
Figure 6: .zk-ﬁle specifying Idemix proof goal G.
500