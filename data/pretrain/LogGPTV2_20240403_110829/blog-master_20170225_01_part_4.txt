   l_tax vops_float4 not null,  
   l_returnflag vops_char not null,  
   l_linestatus vops_char not null  
);  
-- Copy data to the projection table  
select populate(destination := 'vops_lineitem'::regclass, source := 'lineitem'::regclass);  
-- For honest comparison creates the same projection without VOPS types  
create table lineitem_projection as (select l_shipdate,l_quantity,l_extendedprice,l_discount,l_tax,l_returnflag::"char",l_linestatus::"char" from lineitem);  
-- Now create mixed projection with partitioning keys:  
create table vops_lineitem_projection(  
   l_shipdate vops_date not null,  
   l_quantity vops_float4 not null,  
   l_extendedprice vops_float4 not null,  
   l_discount vops_float4 not null,  
   l_tax vops_float4 not null,  
   l_returnflag "char" not null,  
   l_linestatus "char" not null  
);  
-- And populate it with data sorted by partitioning key:  
select populate(destination := 'vops_lineitem_projection'::regclass, source := 'lineitem_projection'::regclass, sort := 'l_returnflag,l_linestatus');  
-- Let's measure time  
\timing  
-- Original Q6 query performing filtering with calculation of grand aggregate  
select  
    sum(l_extendedpricel_discount) as revenue  
from  
    lineitem  
where  
    l_shipdate between '1996-01-01' and '1997-01-01'  
    and l_discount between 0.08 and 0.1  
    and l_quantity < 24;  
-- VOPS version of Q6 using VOPS specific operators  
select sum(l_extendedpricel_discount) as revenue  
from vops_lineitem  
where filter(betwixt(l_shipdate, '1996-01-01', '1997-01-01')  
        & betwixt(l_discount, 0.08, 0.1)  
        & (l_quantity < 24));  
-- Yet another vectorized version of Q6, but now in stadnard SQL:  
select sum(l_extendedpricel_discount) as revenue  
from vops_lineitem  
where l_shipdate between '1996-01-01'::date AND '1997-01-01'::date  
   and l_discount between 0.08 and 0.1  
   and l_quantity < 24;  
-- Original version of Q1: filter + group by + aggregation  
select  
    l_returnflag,  
    l_linestatus,  
    sum(l_quantity) as sum_qty,  
    sum(l_extendedprice) as sum_base_price,  
    sum(l_extendedprice(1-l_discount)) as sum_disc_price,  
    sum(l_extendedprice(1-l_discount)(1+l_tax)) as sum_charge,  
    avg(l_quantity) as avg_qty,  
    avg(l_extendedprice) as avg_price,  
    avg(l_discount) as avg_disc,  
    count() as count_order  
from  
    lineitem  
where  
    l_shipdate <= '1998-12-01'  
group by  
    l_returnflag,  
    l_linestatus  
order by  
    l_returnflag,  
    l_linestatus;  
-- VOPS version of Q1, sorry - no final sorting  
select reduce(map(l_returnflag||l_linestatus, 'sum,sum,sum,sum,avg,avg,avg',  
    l_quantity,  
    l_extendedprice,  
    l_extendedprice(1-l_discount),  
    l_extendedprice(1-l_discount)(1+l_tax),  
    l_quantity,  
    l_extendedprice,  
    l_discount)) from vops_lineitem where filter(l_shipdate <= '1998-12-01'::date);  
-- Mixed mode: let's Postgres does group by and calculates VOPS aggregates for each group  
select  
    l_returnflag,  
    l_linestatus,  
    sum(l_quantity) as sum_qty,  
    sum(l_extendedprice) as sum_base_price,  
    sum(l_extendedprice(1-l_discount)) as sum_disc_price,  
    sum(l_extendedprice(1-l_discount)(1+l_tax)) as sum_charge,  
    avg(l_quantity) as avg_qty,  
    avg(l_extendedprice) as avg_price,  
    avg(l_discount) as avg_disc,  
    count() as count_order  
from  
    vops_lineitem_projection  
where  
    l_shipdate <= '1998-12-01'::date  
group by  
    l_returnflag,  
    l_linestatus  
order by  
    l_returnflag,  
    l_linestatus;  
```  
### 测试性能对比  
测试环境和配置如下，数据可以放入整个内存，所以不用考虑IO影响，同时测试了单核与多核并行模式（因为PostgreSQL支持一个QUERY使用多个CPU核）。  
```  
All measurements were performed at desktop with 16Gb of RAM and quad-core i7-4770 CPU @ 3.40GHz processor with enabled hyper-threading.  
Data set for benchmark was generated by dbgen utility included in TPC-H benchmark.  
Scale factor is 100 which corresponds to about 8Gb database.   
It can completely fit in memory, so we are measuring best query execution time for warm data.  
Postgres was configured with shared buffer size equal to 8Gb.  
For each query we measured time of sequential and parallel execution with 8 parallel workers.  
```  
性能对比如下  
Query|	Sequential execution (msec)|	Parallel execution (msec)  
---|---|---  
Original Q1 for lineitem|	38028|	10997  
Original Q1 for lineitem_projection|	33872|	9656  
Vectorized Q1 for vops_lineitem|	3372|	951  
Mixed Q1 for vops_lineitem_projection|	1490|	396  
Original Q6 for lineitem|	16796|	4110  
Original Q6 for lineitem_projection|	4279|	1171  
Vectorized Q6 for vops_lineitem|	875|	284  
### 结论  
从测试结果来看，使用VOPS向量计算后，性能有了10倍的提升，相比LLVM的4倍和3倍，取得了更好的效果。  
同时，使用瓦片式的方法，不需要修改数据库内核，可以以插件的形式装载，适合更多的用户使用。  
```  
As you can see in performance results, VOPS can provide more than 10 times improvement of query speed.  
And this result is achieved without changing something in query planner and executor.  
It is better than any of existed attempt to speed up execution of OLAP queries using JIT (4 times for Q1, 3 times for Q6):  
Speeding up query execution in PostgreSQL using LLVM JIT compiler.  
Definitely VOPS extension is just a prototype which main role is to demonstrate potential of vectorized executor.  
But I hope that it also can be useful in practice to speedup execution of OLAP aggregation queries for existed databases.  
And in future we should think about the best approach of integrating vectorized executor in Postgres core.  
ALL sources of VOPS project can be obtained from this GIT repository.  
Please send any feedbacks, complaints, bug reports, change requests to Konstantin Knizhnik.  
```  
## 小结  
PostgreSQL数据库近年的发展令一些商业数据库汗颜， 除了OLTP领域，在OLAP领域也不断发力，逐渐往HTAP的方向发展。  
从CPU多核并行、GPU加速、JIT、列存储，再到向量计算，在计算能力方面不断的提高。  
同时在分布式方面也已支持 聚合下推、算子下推、WHERE子句下推，SORT\JOIN下推等等一系列的postgres_fdw的完善。  
在垂直行业则推出了类似 图计算、流计算、时序数据的插件。  
另外PostgreSQL生态中，还有基于PG的分布式数据库greenplum, redshift, pgxc, pgxz等等   
PostgreSQL势必要在OLTP和OLAP领域大放异彩。  
## 参考
https://github.com/citusdata/postgres_vectorization_test  
https://github.com/citusdata/cstore_fdw  
https://github.com/knizhnik/imcs  
https://www.monetdb.org/Home  
https://github.com/postgrespro/vops  
https://postgrespro.com/docs/enterprise/10/vops   
[使用fdw将vops用于任意SQL](20170225_01_doc_001.pdf)  
#### [PostgreSQL 许愿链接](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
您的愿望将传达给PG kernel hacker、数据库厂商等, 帮助提高数据库产品质量和功能, 说不定下一个PG版本就有您提出的功能点. 针对非常好的提议，奖励限量版PG文化衫、纪念品、贴纸、PG热门书籍等，奖品丰富，快来许愿。[开不开森](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216").  
#### [9.9元购买3个月阿里云RDS PostgreSQL实例](https://www.aliyun.com/database/postgresqlactivity "57258f76c37864c6e6d23383d05714ea")
#### [PostgreSQL 解决方案集合](https://yq.aliyun.com/topic/118 "40cff096e9ed7122c512b35d8561d9c8")
#### [德哥 / digoal's github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
#### [PolarDB 学习图谱: 训练营、培训认证、在线互动实验、解决方案、生态合作、写心得拿奖品](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
#### [购买PolarDB云服务折扣活动进行中, 55元起](https://www.aliyun.com/activity/new/polardb-yunparter?userCode=bsb3t4al "e0495c413bedacabb75ff1e880be465a")
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")