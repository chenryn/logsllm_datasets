这可能解决了亲和性的问题，但它仍然无法帮助我们找到这些分配。不幸的是，slab缓存在内核引导过程中被分配得相当晚，而且其内容非常“嘈杂”。这意味着猜测slab中的一个地址也是非常困难的，对于远程攻击者而言更甚。但是，使用大分配流的早期分配（即使用__get_free_pages创建的）始终驻于相同的内存地址！也就是只要其在内核初始化期间发生得足够早，因此没有非确定性事件同时发生。
结合这两个事实，我们可以搜索一个大的早期分配。在跟踪大型分配路径并重新引导内核后，似乎确实有很多这样的分配。为了帮助导航此大的踪迹，我们还可以使用一个特殊的GCC插件来编译Linux内核，该插件可输出内核中使用的每个结构的大小。使用这两个踪迹，我们可以快速导航早期大分配，并尝试搜索潜在的匹配。
遍历列表后，我们碰到一个看似有趣的条目：
图18
**汇总**
在bcmdhd驱动程序初始化期间，其调用[wiphy_new](http://lxr.free-electrons.com/source/net/wireless/core.c?v=2.6.25#L182)函数来分配一个wl_priv实例。该实例用于保存与驱动程序操作相关的大部分元数据。但是，还有一点诡异的数据隐藏在该结构中——用于处理传入的事件帧的事件处理函数指针数组。事实上，我们之前讨论的同一表格(evt_handler)存储在该对象中。这将我们引向了利用的直接路径——只需kfree这个对象，然后发送一个SWC事件帧来回收它，然后用我们自己的任意数据填充它。
然而，在我们这样做之前，我们需要确保该对象满足处理函数所要求的约束。也就是说，前四个字节必须为零，我们必须能够修改第7个字节以匹配第6个字节的值。第二个约束根本不构成任何问题，但第一个约束是个大问题。如前所述，前四个字节不为零，但实际上指向与驱动程序相关的一个函数指针块。这是否意味着我们完全不能使用这个对象？
不是的——碰巧，我们还有一个诀窍！事实证明，当kfree一个大的分配时，kfree的代码路径不需要传入的指针指向分配的起始。相反，其只是提取与分配相对应的页面，然后释放它们。这意味着通过指定位于匹配约束的结构中的地址，我们将既能满足处理函数提出的要求，又可以释放基础对象。太棒了。
图19
综合起来，我们现在可以发送一个SWC事件帧，以回收evt_handler函数指针数组，并用我们自己的内容填充它。由于没有KASLR，我们可以在内核映像中搜索一个堆栈枢纽小工具，其可以使我们实现代码执行。出于利用目的，我已选择用堆栈枢纽将WLC_E_SET_SSID的事件处理程序替换为事件帧本身（当执行事件处理程序时存储在R2中）。最后，通过替换专门设计的WLC_E_SET_SSID类型的事件帧中的
ROP栈，我们现在可以控制内核线程的执行，从而可完成我们的利用。
图20
你可以在[此处](https://bugs.chromium.org/p/project-zero/issues/detail?id=1061#c4)找到该漏洞的一个利用示例。其包括一个只调用printk的短ROP链。该利用方法针对使用自定义内核版本的Nexus
5构建。要修改该方法以适用于不同的内核版本，你需要填入适当地符合（symbols.py下）。此外，虽然原语仍然存在于64位设备中，但为了针对那些平台调整利用方法，可能还需要额外的工作。
接下来，让我们转到本文的第二部分。
**第2部分——“较易”方式**
**能有多简单？**
虽然我们已经看到Wi-Fi固件和主机之间的高级别通信协议可能会受到影响，但我们也看到，要编写一个完全有效的利用方法委实不易。实际上，上述利用方法需要有关目标设备的足够信息（比如符号）。此外，利用期间的任何错误都可能导致内核崩溃，这会导致设备重新启动，这要求我们从头再来。这一事实，再加上我们对Wi-Fi SoC的瞬态控制，使这些类型的利用链很难可靠地利用。
也就是说，到目前为止，我们只考虑了固件暴露的高级别攻击面。实际上，我们是将Wi-Fi
SoC和应用处理器作为两个彼此完全独立的不同实体。实际上，没有什么可以远离真相。Wi-Fi SoC和主机不仅物理上彼此接近，还共享物理通信接口。
如前所述，Broadcom生产支持各种接口的SoC，包括SDIO、USB及PCIe。虽然SDIO接口过去很受欢迎，但近年来已不再受移动设备青睐。SDIO“消失”的主要原因是其传输速度有限。Broadcom的BCM4339
SoC支持SDIO 3.0，这是一个相当高级的SDIO版本。尽管如此，其理论最大总线速度仅为104
MB/s。另一方面，802.11ac的理论最大速度为166 MB/s——远超SDIO。
图21
**BCM4339框图**
传输速率的提高使得PCIe成为用于在现代移动设备中连接Wi-Fi
SoC的最流行的接口。与PCI不同，[PCIe](https://en.wikipedia.org/wiki/PCI_Express)是基于点对点拓扑。每个设备都有将自身连接到主机的自己的串行链路。由于这种设计，PCIe的每通道速率远高于PCI上的同等速率（因为总线访问不需要仲裁），PCIe
1.0在单个通道上的吞吐量为250 MB / s（与通道数呈线性关系）。
我们来具体看看现代移动设备中PCIe的采用率。以Nexus手机为例，从Nexus
6开始，所有设备都使用PCIe接口（不再是SDIO）。同样，所有iPhone也从iPhone 6开始使用PCIe。三星旗舰设备Galaxy从
S6开始使用PCIe。
**接口隔离**
那么，为什么该信息与我们的追求有关？PCIe在隔离方面与SDIO和USB显著不同。SDIO在不进入每个接口的内部的情况下就允许串行传输小命令“数据包”（在CMD引脚上），可能伴随数据（在DATA引脚上）。SDIO控制器然后解码命令并相应响应。虽然SDIO可以支持[DMA](https://en.wikipedia.org/wiki/Direct_memory_access)，但该功能不在移动设备上使用，并不是SDIO的固有部分。此外，BCM
SoC上的低级SDIO通信由“SDIOD”内核处理。为了制作特殊的SDIO命令，我们很可能需要先获得对该控制器的访问权。
同样，USB（最高3.1版）不包括对DMA的支持。USB协议由主机的USB控制器进行处理，该控制器执行所需的内存访问。当然，可能可以破坏USB控制器本身，然后将其接口用于内存系统，以获得内存访问权。比如，在Intel
Hub
Architecture上，USB控制器通过能够进行DMA的PCI连接到[PCH](https://en.wikipedia.org/wiki/Platform_Controller_Hub)。但这种攻击也相当复杂，仅限于特定的架构和USB控制器。
与这两个接口相比，PCIe允许通过设计进行DMA。这允许PCIe以极高的速度运行，而不会导致主机的性能下降。一旦数据传输到主机的内存，就会触发一个中断来指示该工作需要完成。
在事务层上，PCIe通过发送小批量的数据（适当命名为“事务层包”（TLP））进行操作。每个TLP可以由交换机网络路由，直到其到达预定外围设备为止。然后外围设备解码数据包并执行请求的内存操作。TLP的header编码这是否是请求的读取或写入操作，其body包含与请求相关的任何伴随数据。
图22
**事务层包（TLP）的结构**
**IOU一个MMU**
虽然PCIe支持通过设计实现DMA，但这并不意味着连接到外围设备的任何PCIe都应该能够自由访问主机上的任何内存地址。事实上，现代架构在将外设连接到主存储器的IO总线上具有额外的内存映射单元（[IOMMU](https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit)），因为具有针对支持DMA的外设的防御能力。
ARM指定其自己的IOMMU版本，称为“[系统内存映射单元](https://developer.arm.com/products/system-ip/system-controllers/system-memory-management-unit)”（SMMU）。使用SMMU的其中一个目的是管理暴露于不同SoC组件的内存视图。简而言之，每个内存事务流都与“流ID”相关联。然后，SMMU执行称为“上下文确定”的一个步骤，以便将流ID转换为相应的内存上下文。
使用内存上下文，SMMU便能够将内存操作与包含请求设备的映射的转换表相关联。很像常规的ARM
MMU，查询转换表是为了将输入地址（虚拟地址或中间物理地址）转换为相应的物理地址。当然，期间SMMU也确保请求的内存操作实际上被允许。如果这些步骤中的任何一个失败，就会产生故障。
图23
虽然这在理论上很好，但并不意味着SMMU实际上在实践中被使用。不幸的是，移动SoC是专有的，因此很难确定SMMU实际上如何和在哪里就位。话虽如此，我们仍然可以从公开的信息中获取一些洞察力。通过查看Linux内核中的IOMMU绑定，我们可以看到，显然，Qualcomm和三星都有自己的SMMU专有实现，有其自己独特的设备树绑定。但是，可疑的是，Broadcom
Wi-Fi芯片的设备树条目似乎缺少这些IOMMU绑定…
相反，Broadcom的主机驱动程序（bcmdhd）也许在每个外围存储器访问之前手动配置SMMU？为了回答这个问题，我们需要仔细看看通过PCIe使用的通信协议的驱动程序实现。Broadcom实现其自己的称为“MSGBUF”的专有协议，以便通过PCIe与Wi-Fi芯片进行通信。主机的协议实现和处理PCIe的代码分别可以在[dhd_msgbuf.c](https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/dhd_msgbuf.c)和[dhd_pcie.c](https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/dhd_pcie.c)下找到。
查看代码后，我们获得了对通信协议的内部工作机制的一些关键了解。首先，与预期一致，驱动程序扫描PCIe接口，访问PCI[配置空间](https://en.wikipedia.org/wiki/PCI_configuration_space)，并将所有共享资源映射到主机的内存中。接下来，主机分配一组“环”。每个环均由DMA相干内存区域支持。MSGBUF协议将四个环用于数据流，一个环用于控制。每个数据路径（RX或TX）都有两个相应的环——一个用于指示请求的提交，另一个用于指示其完成。然而，到目前为止，仍然没有提到驱动程序中的SMMU。也许我们要更深入的挖掘…
那么Wi-Fi芯片如何了解这些环的位置？毕竟，到目前为止，其只是在驱动程序中分配的一堆物理连续的缓冲区。查看驱动程序的代码后可知，主机和芯片似乎拥有共享的结构，[pciedev_shared_t](https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/include/bcmpcie.h#132)，包含所有PCIe相关元数据，包括每个环形缓冲区的位置。主机保持其自己的该结构的副本，但Wi-Fi SoC在何处保持其副本？根据dhdpcie_readshared函数，似乎Wi-Fi芯片在其RAM的最后四个字节中存储了一个指向此结构的指针。
图24
我们来继续看看结构的内容。为了略微简化这个过程，我写了一个使用固件RAM快照（使用dhdutil生成）[小脚本](https://bugs.chromium.org/p/project-zero/issues/detail?id=1046#c8)，从RAM的末端读取指向PCIe共享结构的指针，并转出相关的信息：