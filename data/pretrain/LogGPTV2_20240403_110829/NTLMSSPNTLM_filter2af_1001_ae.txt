  7. 将其空填充到21个字节，得到” 0xff3750bcc2b22412c2265b23734e0dac0000000000 “。
  8. 该值分为三个7字节的三分之三：” 0xff3750bcc2b224 “，” 0x12c2265b23734e “和” 0x0dac0000000000 “。
  9. 这三个值用于创建三个DESKey。使用前面概述的过程，我们的第一个价值是：  
11111111 00110111 01010000 10111100 11000010 10110010
00100100给我们提供经过奇偶校验调整的DESKey：1111111 0 1001101 1 1101010 1 0001011 0 1100110 1
0001010 1 1100100 0 0100100 1（十六进制为” 0xfe9bd516cd15c849 “）。第二个值：00010010
11000010 00100110 01011011 00100011 01110011 01001110
结果的关键：
0001001 1 0110000 1 1000100 1 1100101 1 1011001 1 0001101 0 1100110 1 1001110
1
（” 0x136189cbb31acd9d “）。最后，第三个值：
00001101 10101100 00000000 00000000 00000000 00000000 00000000
给我们：
0000110 1 1101011 0 0000000 1 0000000 1 0000000 1 0000000 1 0000000 1 0000000
1
这是第三个DESKey（” 0x0dd6010101010101 “）。
  10. 三个Key中的每个Key都用于对来自Type 2消息的质询进行DES加密（在我们的示例中为” 0x0123456789abcdef “）。这给出结果” 0xc337cd5cbd44fc97 “（使用第一个键），” 0x82a667af6d427c6d “（使用第二个键）和” 0xe67c20c2d3e77c56 “（使用第三个键）。
  11. 将这三个密文值连接起来以形成24字节LM响应：  
0xc337cd5cbd44fc9782a667af6d427c6de67c20c2d3e77c56
该算法有几个弱点，使其容易受到攻击。尽管在Hertel文本中详细介绍了这些内容，但最突出的问题是：在计算响应之前，密码将转换为大写。
**NTLM响应(The NTLM Response)**
NTLM响应由较新的客户端发送。该方案解决了LM响应中的一些缺陷。但是，它仍然被认为是相当薄弱的。此外，NTLM响应几乎总是与LM响应一起发送。可以利用该算法的弱点来获得不区分大小写的密码，并通过反复试验来找到NTLM响应所采用的区分大小写的密码。
NTLM响应的计算方式如下（有关示例Java实现，请参阅附录D）：
  1. MD4消息摘要算法（在RFC 1320中描述 ）应用于Unicode大小写混合密码。结果为16字节的值-NTLM哈希。
  2. 16字节的NTLM哈希值被空填充为21个字节。
  3. 该值分为三个7字节的三分之二。
  4. 这些值用于创建三个DESKey（每个7字节的三分之一）。
  5. 这些Key中的每一个都用于对来自Type 2消息的质询进行DES加密（产生三个8字节密文值）。
  6. 将这三个密文值连接起来形成一个24字节的值。这是NTLM响应。
注意，只有哈希值的计算与LM方案有所不同；响应计算是相同的。为了说明此过程，我们将其应用到之前的示例（密码为”SecREt01” 的用户，响应Type
2质询” 0x0123456789abcdef “）。
  1. Unicode混合大小写密码为” 0x53006500630052004500740030003100 “（十六进制）；计算出该值的MD4哈希，结果为” 0xcd06ca7c7e10c99b1d33b7485a2ed808 “。这是NTLM哈希。
  2. 将其空填充到21个字节，得到” 0xcd06ca7c7e10c99b1d33b7485a2ed8080000000000 “。
  3. 该值分为三个7字节的三分之三：” 0xcd06ca7c7e10c9 “，” 0x9b1d33b7485a2e “和” 0xd8080000000000 “。
  4. 这三个值用于创建三个DESKey。我们的第一个值：  
11001101 00000110 11001010 01111100 01111110 00010000
11001001得出奇偶校验调整后的Key：1100110 1 1000001 1 1011001 1 0100111 1 1100011 1
1111000 1 0100001 1 1001001 0（十六进制为” 0xcd83b34fc7f14392 “）。第二个值：10011011
00011101 00110011 10110111 01001000 01011010 00101110
给出Key：
1001101 1 1000111 1 0100110 0 0111011 0 0111010 1 0100001 1 0110100 0 0101110
1
（” 0x9b8f4c767543685d “）。我们的第三个价值：
11011000 00001000 00000000 00000000 00000000 00000000 00000000
产生我们的第三个关键：
1101100 1 0000010 0 0000000 1 0000000 1 0000000 1 0000000 1 0000000 1 0000000
1
（十六进制为” 0xd904010101010101 “）。
  5. 这三个Key中的每一个都用于对来自Type 2消息（” 0x0123456789abcdef “）的质询进行DES加密。这将产生结果” 0x25a98c1c31e81847 “（使用第一个Key），” 0x466b29b2df4680f3 “（使用第二个Key）和” 0x9958fb8c213a9cc6 “（使用第三个Key）。
  6. 这三个密文值连接起来形成24字节NTLM响应：  
0x25a98c1c31e81847466b29b2df4680f39958fb8c213a9cc6
**NTLMv2响应**
NTLM版本2（”NTLMv2”）专门用于解决NTLM中存在的安全问题。启用NTLMv2时，NTLM响应将替换为NTLMv2响应，而LM响应将替换为LMv2响应（我们将在下面讨论）。
NTLMv2响应的计算方式如下（有关 Java中的示例实现，请参阅附录D）：
  1. 获取NTLM密码哈希（如前所述，这是Unicode混合大小写密码的MD4摘要）。
  2. Unicode大写用户名与Unicode身份验证目标（在Type 3消息的”Target Name”字段中指定的域或服务器名称）串联在一起。请注意，即使已协商使用OEM编码，此计算也始终使用Unicode表示形式。还请注意，用户名将转换为大写，而身份验证目标（authentication target）区分大小写，并且必须与”Target Name”字段中显示的大小写匹配。使用16字节NTLM哈希作为Key，将HMAC-MD5消息认证代码算法（[RFC 2104](http://www.ietf.org/rfc/rfc2104.txt)）应用于该值。结果为16字节的值-NTLMv2哈希。
  3. 构造一个称为”Blob”的数据块。Hertel text更详细地讨论了这种结构的格式。简要说明如下：| offset | Description | Content |  
| ————— | ————————— | —————————————————————————————————————————————————————— |  
| 0 | Blob Signature | 0x01010000 |  
| 4 | Reserved | long (0x00000000) |  
| 8 | Timestamp | Little-endian, 64-bit signed value representing the number
of tenths of a microsecond since January 1, 1601. |  
| 16 | Client Nonce | 8 bytes |  
| 24 | Unknown | 4 bytes |  
| 28 | Target Information | Target Information block (from the Type 2
message). |  
| (variable) | Unknown | 4 bytes |
  4. 来自Type 2消息的质询与Blob连接在一起。使用16字节NTLMv2哈希（在步骤2中计算）作为Key，将HMAC-MD5消息认证代码算法应用于此值。结果是一个16字节的输出值。
  5. 该值与Blob连接起来形成NTLMv2响应。
让我们来看一个例子。由于我们需要更多信息来计算NTLMv2响应，因此我们将使用前面提供的示例中的以下值：
| 名称 | 值  
---|---|---  
| Target: | DOMAIN |  
| Username: | user |  
| Password: | SecREt01 |  
| Challenge: | 0x0123456789abcdef |  
| Target Information: |
0x02000c0044004f004d00410049004e0001000c005300450052005600450052000400140064006f006d00610069006e002e0063006f006d00030022007300650072007600650072002e0064006f006d00610069006e002e0063006f006d0000000000
|  
  1. Unicode混合大小写密码为” 0x53006500630052004500740030003100 “（十六进制）；计算出该值的MD4哈希，结果为” 0xcd06ca7c7e10c99b1d33b7485a2ed808 “。这是NTLM哈希。
  2. Unicode大写的用户名与Unicode身份验证目标连接在一起，并提供” USERDOMAIN “（或十六进制的” 0x55005300450052004200444f004d00410049004e00 “）。使用上一步中的16字节NTLM哈希作为Key，将HMAC-MD5应用于此值，这将产生” 0x04b8e0ba74289cc540826bab1dee63ae “。这是NTLMv2哈希。
  3. 接下来，构建Blob。时间戳是其中最繁琐的部分，添加11644473600将使我们在1601年1月1日之后获得秒数（12700317600）。乘以10的7次方（10000000）将得到十分之一微秒（127003176000000000）。作为小端64位值，它是” 0x0090d336b734c301 “（十六进制）。  
我们还需要生成一个8字节的随机”客户随机数”；我们将使用不太随机的” 0xffffff0011223344
“。构造其余的Blob很容易；我们只是串联：0x01010000 （blob签名）0x00000000 （保留值）0x0090d336b734c301
（我们的时间戳）0xffffff0011223344 （随机的客户随机数）
0x00000000 （未知，但零将起作用）
0x02000c0044004f00 （我们的目标信息块）  
4d00410049004e00  
01000c0053004500  
5200560045005200  
0400140064006f00  
6d00610069006e00  
2e0063006f006d00  
0300220073006500  
7200760065007200  
2e0064006f006d00  
610069006e002e00  
63006f006d000000  
0000
0x00000000 （未知，但零会起作用）
  4. 我们将Type 2challenge与Blob连接起来：0x0123456789abcdef0101000000000000  
0090d336b734c301ffffff0011223344  
0000000002000c0044004f004d004100  
49004e0001000c005300450052005600  
450052000400140064006f006d006100  
69006e002e0063006f006d0003002200  
7300650072007600650072002e006400  
6f006d00610069006e002e0063006f00  
6d000000000000000000  
使用第2步中的NTLMv2哈希作为Key，将HMAC-MD5应用于该值，即可得到16个字节的值”
0xcbabbca713eb795d04c97abc01ee4983 “。
  5. 此值与Blob串联以获得NTLMv2响应：0xcbabbca713eb795d04c97abc01ee4983  
01010000000000000090d336b734c301  
ffffff00112233440000000002000c00  
44004f004d00410049004e0001000c00  