the slave evaluator processes (Step 5) and start the main
protocol. The arrows show the message ﬂow.
Timing methodology When there is more than one
process on each side, care must be taken in measuring
the timings of the system. The timings reported in this
section are the time required by the root process at each
stage of the system. This was chosen because the root
process will always be the longest running process, as
it must wait for each slave process to run to completion.
Moreover, in addition to doing all the work that the slaves
do, the root processes also perform the input consistency
check and the coin tossing protocol.
Impacts of the Performance Optimization Techniques
We have presented several performance optimization
techniques in Section 4 with theoretical analyses, and
here we demonstrate their empirical effectiveness in Ta-
ble 4. As we have anticipated, the Random Seed Check-
ing reduces the communication cost for the garbled cir-
cuits by 60%, and the Garbled Row Reduction further
reduces by another 25%. In the RS and GRR columns,
the small deviation from the theoretical fraction 40%
and 30%, respectively, is due to certain implementation
needs. Our compiler is designed to reduce the number of
non-XOR gates. In these four circuits, the ratio of non-
XOR gates is less than 43%. So after further applying
the Free-XOR technique, the ﬁnal communication is less
than 13% of that in the baseline approach.
non-XOR
(%)
30.81
29.55
34.44
41.36
Baseline
(MB)
509
4,707
17,928
159,129
RS
(%)
39.97
39.86
39.84
39.84
GRR
(%)
30.03
29.91
29.88
29.87
FX
(%)
9.09
8.88
10.29
12.36
AES
Dot64
4
RSA-32
EDT-255
Table 4: The impact of various optimization techniques:
The Baseline shows the communication cost for 256
copies of the original Yao garbled circuit when k = 80;
RS shows the remaining fraction after Random Seed
technique is applied; GRR shows when Garbled Row Re-
duction is further applied; and FX shows when the previ-
ous two techniques and the Free-XOR are applied. (The
communication costs here only include those in the gen-
eration and evaluation stages.)
Performance Gain by AES-NI On a machine with
2.53 GHz Intel Core i5 processor and 4GB 1067 MHz
DDR3 memory, it takes 784 clock cycles to run a single
SHA-256 (with OpenSSL 1.0.0g), while it needs only
225 cycles for AES-256 (with AES-NI). To measure the
beneﬁts of AES-NI, we use two instantiations to con-
struct various circuits, listed in Table 5, and observe a
consistent 20% saving in circuit construction.3
size
(gate)
49,912
460,018
1,750,787
15,540,196
AES
Dot64
4
RSA-32
EDT-255
AES-NI
(sec)
(sec)
SHA-256
Ratio
(%)
0.12± 1% 0.15± 1% 78.04
1.11±0.4% 1.41±0.5% 78.58
4.53±0.5%
5.9±0.8% 76.78
42.0±0.5% 57.6± 1% 72.92
Table 5: Circuit generation time (for a single copy) with
different instantiations (AES-NI vs SHA-256) of the 2-
circular correlation robust function.
AES We used AES as a benchmark to compare our
compiler to the Fairplay compiler, and as a test circuit
3The reason that saving 500+ cycles does not lead to more improve-
ments is that this encryption operation is merely one of the contributing
factors to generating a garbled gate. Other factors, for example, in-
clude GNU hash map table insertion (∼1,200 cycles) and erase (∼600
cycles).
  14325555EvlGenIP serverfor our system. We tested the full AES circuit, as spec-
iﬁed in FIPS-197 [8].
In the semi-honest model, it is
possible to reduce the number of gates in an AES circuit
by computing the key schedule ofﬂine; e.g. this is one of
the optimizations employed by Huang et al. [13]. In the
malicious model, however, such an optimization is not
possible; the party holding the key could attempt to re-
duce the security level of the cipher by computing a ma-
licious key schedule. So in our experiments we compute
the entire function, including the key schedule, online.
In this experiment, two parties collaboratively com-
pute the function f : (x,y) (cid:55)→ (⊥,AESx(y)), i.e., the cir-
cuit generator holds the encryption key x, while the eval-
uator has the message y to be encrypted. At the end, the
generator will not receive any output, whereas the evalu-
ator will receive the ciphertext AESx(y).
Type
non-XOR
XOR
Fairplay Ours-A Pinkas et al. Ours-B
9,100
15,316
35,084
21,628
15,300
34,228
11,286
22,594
Table 6: The components of the AES circuits from dif-
ferent sources. Ours-A comes from the textbook AES
algorithm, and Ours-B uses an optimized S-box circuit
from [3]. (Sizes do not include input or output wires)
First of all, we demonstrate the performance of our
compiler in Table 6. We have shown in Section 5 that
our compiler is capable of large circuit generation. We
also found in our experiments that our compiler produces
smaller AES circuit than Fairplay. Given the same high-
level description of AES encryption (textbook AES), our
compiler produces a circuit with a smaller gate count and
even fewer non-XOR gates. When applying the compact
S-Box description proposed by Boyar and Parelta [3]
to the high-level description as input to our compiler, a
smaller AES circuit than the hand-optimized one from
Pinkas et al. is generated with less effort.
In Table 7, both the computational and communica-
tion costs for each main stage are listed under the tradi-
tional setting, where there is only one process on each
side. These main stages include oblivious transfer, gar-
bled circuit construction, the generator’s input consis-
tency check, and the circuit evaluation. Each row in-
cludes both the computation and communication time
used. Note that network conditions could vary from set-
ting to setting. Our experiments run in a local area net-
work, and the data can only give a rough idea on how fast
the system could be in an ideal environment. However,
the precise amount of data being exchanged is reported.
We notice in Table 7 that the evaluator spends an un-
reasonable amount of time on communication with re-
spect to the amount of data to be transmitted in both
the oblivious transfer and circuit construction stages.
Gen
(sec)
Eval
(sec)
45.8±0.09% 34.0±0.2%
0.1± 1% 11.9±0.6%
35.6± 0.5%
comp
comm
comp
comm
comp
comm
14.9± 0.6% 32.4±0.4%
comp
3.2±0.8%
comm 18.2± 1%
96.3± 0.3% 68.0±0.2%
comp
comm 18.3± 1% 50.8±0.4%
35.6±0.5%
1.75±0.2%
–
–
–
–
–
Comm
(KB)
5,516
3
266
28,781
34,566
OT
Gen.
Inp.
Chk
Evl.
Total
Table 7: The 95% two-sided conﬁdence intervals of the
computation and communication time for each stage in
the experiment (x,y) (cid:55)→ (⊥,AESx(y)).
This is because the evaluator spends that time waiting
for the generator to ﬁnish computation-intensive tasks.
The same reasoning explains why in the circuit evalu-
ation stage the generator spends more time in commu-
nication than the evaluator. This waiting results from
the fact that both parties need to run the protocol in a
synchronized manner. A generator-evaluator pair can-
not start next communication round while any other pair
has not ﬁnished the current one. This synchronization is
crucial since our protocol’s security is guaranteed only
when each communication round is performed sequen-
tially. While the parallelization of the program intro-
duces high performance execution, it does not and should
not change this essential property. A stronger notion
of security such as universal security will be required if
asynchronous communication is allowed. By using TCP
sockets in “blocking” mode, we enforce this communi-
cation round synchronization.
Note that the low communication during the circuit
construction stage is due to the random seed checking
technique. Also, the fact that the generator spends more
time in the evaluation stage than she traditionally does
comes from the second construction for evaluation cir-
cuits. Recall that only the evaluation circuits need to be
sent to the evaluator. Since only 40% of the garbled cir-
cuits (102 out of 256) are evaluation-circuits, the ratio of
the generator’s computation time in the generation and
evaluation stage is 35.63:14:92 (cid:39) 5:2.
We were unfortunately unable to ﬁnd a cluster of hun-
dreds of nodes that all support AES-NI. Our experimen-
tal results, therefore, do not show the full potential of
all the optimization techniques we have proposed. How-
ever, recall that for certain circuits the running time in
the semi-honest setting is roughly half of that in the
node #
OT
Gen.
Inp. Chk
Evl.
Inter-com
Intra-com
Total time
4
16
64
256
Gen
Evl
Gen
Evl
Gen
Evl
Gen
Evl
–
–
–
–
1.92±0.7%
0.42± 4%
12.56±0.1% 8.41±0.1% 4.06±0.1% 2.13±0.2% 1.96±0.1% 0.58±0.2% 0.64±0.1% 0.19±0.2%
8.18±0.4%
3.3± 4% 7.08± 1% 0.80± 10% 1.58± 4% 0.23± 17% 0.37± 7% 0.12±0.5% 0.05±0.6%
4± 5% 13.2±0.3% 0.93± 10% 4.08±0.8% 0.31± 20% 1.98± 1% 0.11± 40% 0.72±0.2%
0.17± 30% 0.23± 20% 0.18± 8% 0.25± 6% 0.45± 20% 0.48± 15% 0.34± 30% 0.34± 30%
28.3±0.3% 29.4±0.3% 7.90±0.5% 8.17±0.4% 3.45± 2% 3.44± 2%
1.3± 9%
0.10± 10%
0.14± 1%
0.49±0.4%
1.4± 10%
–
–
–
–
–
–