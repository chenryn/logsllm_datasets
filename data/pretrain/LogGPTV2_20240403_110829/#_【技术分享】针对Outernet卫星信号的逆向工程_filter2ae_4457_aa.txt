# 【技术分享】针对Outernet卫星信号的逆向工程
|
##### 译文声明
本文是翻译文章，文章来源：gnuradio
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
******翻译：**[
**twittered**](http://bobao.360.cn/member/contribute?uid=245645961)
**稿费：200RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿**
**前言**
Outernet[1]是一家旨在让访问国际互联网更加方便自由的公司，他们使用卫星来广播维基百科或者其他网站。目前，他们的广播主要使用三颗国际海事卫星[3]的L波段[2]，使其广播覆盖全球，大多数接收机是开源的，可是，他们的关键部分是闭源的，比如二进制的数据分发模式和信号的详细信息。实际上，Outernet可能违反了GPL
，因为他们的sdr100[4]是基于librtl SDR和libmirisdr[5]开发的，而这两个使用了GPL开源协议。
**详情**
最近。我逆向了 Outernet 的信号，并完成了一个完全开源的的解码器，他由一个GNU Radio流图 gr-outernet[6]和python脚本free-outernet[7]组成，前者负责获取信号，后者负责提取出传输的文件。
在这篇文章中，我将描述GNU
Radio是如何工作的还会介绍一些我用来逆向信号的工具和技术。这些技术可以同样应用于其他的类型的信号，特别是用于卫星通讯的信号（逆向结束之后，我才知道它使用了现成的卫星广播通讯方式，Datum
Systems M7[8]），你可以在我的博客[9]中找到更多有关于Outernet的信息和其他项目。
处理射频信号的第一步始终都是调整设备的频率和带宽。即使你不知道怎么解调信号，他在瀑布图上，频率和带宽是很明显的。在这里，我使用Scott
Chapman（K4KDR）[10]从 I-4 F3卫星上获取的I/Q数据信号，它在美国上空的广播频率是1539.8725
MHz，我们可以清楚的看见带宽大概是4.8kHz。如果你运行下面的流图，将会看到输出。
我们如果只看这些，基本对信号一无所知，他看起来像一个4.8khz的宽峰噪音，正如 Phil Karn
（KA9Q）[11]所说：“任何一个先进的通讯方案都无法区别噪音。”因为它是一个窄带卫星信号，我们猜测它使用的是PSK方式调制的，但是采用的BPSK还是QPSK？这两种都是有可能的。有一种简单的方式可以猜测PSK的类型而不用把它恢复到星图。这个方法是：首先，我们把信号功率提升到2倍（源信号乘以本身），如果我们发现了直流成分，那么这个是BPSK信号，如果没有，我们提升到4倍，如果这时产生直流成分，那么是QPSK信号。这也适用于高阶PSK信号（不适用于QAM），对于一个M-PSK信号来说，提升一个整数倍m时，会产生直流成分。
你可以看下面的流程，当提升2倍时，出现来直流脉冲，这表明，Outernet是BPSK信号。
下面的任务是获取信号的波特率，有一种叫循环平稳分析的方法可以用来获取信号的波特率。使用延时之后的信号复共轭相乘。最好的解释方式就是看下面的流图。
循环平稳分析的输出显示来一个特定频率下的波特率频率分量，在下面的图中，我们可以看到在4200hz处有分量，这表明，波特率是4.2kbaud。频率图中的高平均是很重要的，否则4200hz的频率分量是很难看到的。
现在，我们知道了波特率，我们可以把它恢复成星图，发现它确实是BPSk信号，有关于PSK的解调[12]，GNU
Radio入门介绍网页[13]有一篇很好的说明。下面，你可以看到我们的BPSK解调器流图和星图，正如预期，这是一个BPSK信号。
Outernet对外所说比特率约为2
kbps，或为20MB每天，而我们分析得到的比特率是4.2kbaud，所以，很有可能它使用了r=1/2正向纠错编码，参数r被称为速率， R = 1 /
2意味着数据流使用了1/2bits用来在接收器中纠正错误位，实际速率只有我们测得速率的一半，也就是2.1kbps。
对于参数是r=1/2的数据，最流行的是使用国际空间数据系统咨询委员会提出的，r=1/2,卷积码K = 7的协议式。针对这种编码的Viterbi解码器在GNU
radio中有相应的模块，叫做“Decode CCSDS 27”。然而，这种编码允许在几个变量上有所更改。我们可以使用Balint
Seeber[14]的Auto FEC[15]监视Viterbi译码器的误码率并尝试不同的组合参数，直到发现一个可以正常使用的组合。 Auto
FEC也可以删余一些数据（超过1/2的部分）。实际上，你很可能不知道它使用了何种删余率，因为变化太多了。
如果想使用Auto FEC，你需要在GNU Radio上打一个补丁，因为 Viterbi 解码器和 “Decode CCSDS
27”模块需要修改以便输出误码率。在这里[16]，你可以找到一个用于GNU Radio当前版本的补丁（3.7.10.1测试版），同样，Auto
FEC需要输入的是QPSK信号，这有一个补丁[17]可以让他与BPSK 信号工作。
从下面的流图，你可以看到Auto FEC的运行和他的输出，Auto FEC在控制台上打印各种组合，以尝试得到正确的参数。在这个输出中，需要注意的是把
“Viterbi swap”设置为true。他的含义是在CCSDS编码这个特定的环境中，多项式的数值是交换的。通常，A决定第一位，B
决定第二位。而在这里，第一位来自B，而第二位来自A。为了抵消这一点，我们需要交换每对数据，再把他们送入CCSDS协议解码器。
现在，我们实现了一个 Viterbi
译码器并检查了它的工作。“Swap”模块是一个自定义的模块，它交换每一对浮点数。对于BPSK信号，我们要把两个Viterbi译码器放在输入流上，
其中一个比另一个延后一个样本，因为我们不知道刚开始捕获数据的时候，是一对数据的第一个还是第二个。
你可能会看到如下的输出，其中metric变量表示Viterbi解码器的误码率，当误码率很低的时候metric变量很高，而且几乎有一个恒定的数值，相反，如果解码器没有工作，metric值会很低，并具有类似随机的值。当然，两个译码器只有一个正常工作。当BPSK解调错过一个值或者插入来一个值，（样本流多了或者少了一个bit），这两个Viterbi解码器的工作状态（是否工作正常）就会交换，如果信号质量好，不应该发生这种情况，在这个过程中，是由于树木在风中的移动干扰来信号。另外一个有趣的尝试是关闭“Swap”模块，这样的话两个Viterbi解码器都不会正常工作了。
现在，我们对Viterbi译码器是否工作很有信心，我们接下来把数据流放入raster图，观察是否使用了扰频器，如果使用了，数据流会看起来随机化，如果没有，我们会看到一些比特流的特有结构，实际上，我们基本已经确定它使用了扰频器，因为我们之前看到的BPSK信号很像噪声，而不是展现BPSK的特有频谱结构。
正如你下面看到的，比特流的出现是随机的，所以我们还需要一个解扰器。
选择正确的解扰器是很困难的，因为我们没有办法去猜测它的算法，如果您知道它使用来那种卫星调制解调器，请尝试它支持的所有算法，如果您不知道，那就尝试所有流行的算法。这一步通常需要大量的试验和错误。然而，如果选用正确来，效果也是很明显的，你可你看到他的输出比特流结构，如果不对，输出还是随机的。
最常用的一种是G3RUH的复数乘法器（它用于9.6kbaud业余无线电组和几个业余卫星），数据可以使用GNU radio中的 “Descrambler”
模块加扰，它使用0x21作为掩码，长度为16 ，这个模块的参数选择很麻烦，详见我的博客。[18]