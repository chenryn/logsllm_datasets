title:SubVirt: Implementing malware with virtual machines
author:Samuel T. King and
Peter M. Chen and
Yi-Min Wang and
Chad Verbowski and
Helen J. Wang and
Jacob R. Lorch
SubVirt: Implementing malware with virtual machines
Samuel T. King Peter M. Chen
{kingst,pmchen}@umich.edu
Yi-Min Wang Chad Verbowski Helen J. Wang
University of Michigan
Jacob R. Lorch
{ymwang,chadv,helenw,lorch}@microsoft.com
Microsoft Research
Abstract
1. Introduction
Attackers and defenders of computer systems both
strive to gain complete control over the system. To
maximize their control, both attackers and defenders
have migrated to low-level, operating system code. In
this paper, we assume the perspective of the attacker,
who is trying to run malicious software and avoid de-
tection. By assuming this perspective, we hope to help
defenders understand and defend against the threat
posed by a new class of rootkits.
We evaluate a new type of malicious software that
gains qualitatively more control over a system. This
new type of malware, which we call a virtual-machine
based rootkit (VMBR), installs a virtual-machine mon-
itor underneath an existing operating system and hoists
the original operating system into a virtual machine.
Virtual-machine based rootkits are hard to detect and
remove because their state cannot be accessed by soft-
ware running in the target system. Further, VMBRs
support general-purpose malicious services by allowing
such services to run in a separate operating system
that is protected from the target system. We evaluate
this new threat by implementing two proof-of-concept
VMBRs. We use our proof-of-concept VMBRs to sub-
vert Windows XP and Linux target systems, and we
implement four example malicious services using the
VMBR platform. Last, we use what we learn from
our proof-of-concept VMBRs to explore ways to defend
against this new threat. We discuss possible ways to
detect and prevent VMBRs, and we implement a de-
fense strategy suitable for protecting systems against
this threat.
A battle is taking place between attackers and de-
fenders of computer systems. An attacker who man-
ages to compromise a system seeks to carry out ma-
licious activities on that system while remaining in-
visible to defenders. At the same time, defenders ac-
tively search for successful attackers by looking for
signs of system compromise or malicious activities. In
this paper, we assume the perspective of the attacker,
who is trying to run malicious software (malware) and
avoid detection. By assuming this perspective, we hope
to help defenders understand and defend against the
threat posed by a new class of rootkits (tools used to
hide malicious activities) [24].
A major goal of malware writers is control, by which
we mean the ability of an attacker to monitor, inter-
cept, and modify the state and actions of other software
on the system. Controlling the system allows malware
to remain invisible by lying to or disabling intrusion
detection software.
Control of a system is determined by which side oc-
cupies the lower layer in the system. Lower layers can
control upper layers because lower layers implement the
abstractions upon which upper layers depend. For ex-
ample, an operating system has complete control over
an application’s view of memory because the operating
system mediates access to physical memory through
the abstraction of per-process address spaces. Thus,
the side that controls the lower layer in the system has
a fundamental advantage in the arms race between at-
tackers and defenders. If the defender’s security service
occupies a lower layer than the malware, then that se-
curity service should be able to detect, contain, and
remove the malware. Conversely, if the malware occu-
pies a lower layer than the security service, then the
malware should be able to evade the security service
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
and manipulate its execution.
Because of the greater control aﬀorded by lower lay-
ers in the system, both security services and rootk-
its have evolved by migrating to these layers. Early
rootkits simply replaced user-level programs, such as
ps, with trojan horse programs that lied about which
processes were running. These user-level rootkits were
detected easily by user-level intrusion detection sys-
tems such as TripWire [29], and so rootkits moved into
the operating system kernel. Kernel-level rootkits such
as FU [16] hide malicious processes by modifying kernel
data structures [12]. In response, intrusion detectors
also moved to the kernel to check the integrity of the
kernel’s data structures [11, 38]. Recently, researchers
have sought to hide the memory footprint of malware
from kernel-level detectors by modifying page protec-
tions and intercepting page faults [43]. To combat such
techniques, future detectors may reset page protections
and examine the code of the page-fault handler.
Current rootkits are limited in two ways. First,
they have not been able to gain a clear advantage over
intrusion detection systems in the degree of control
they exercise over a system. The battle for control is
evenly matched in the common scenario where attack-
ers and defenders both occupy the operating system. If
both attackers and defenders run at the most-privileged
hardware level (kernel mode), then neither has a funda-
mental advantage over the other; whichever side better
understands and anticipates the design and actions of
the other will win.
Second, current rootkits are faced with a fundamen-
tal tradeoﬀ between functionality and invisibility. Pow-
erful, general-purpose malware leaves more traces of its
activity than simple, single-purpose malware. E.g., a
web server used for phishing leaves numerous signs of
its presence, including open network ports, extra ﬁles
and processes, and a large memory footprint.
Our project, which is called SubVirt, shows how at-
tackers can use virtual-machine technology to address
the limitations of current malware and rootkits. We
show how attackers can install a virtual-machine mon-
itor (VMM) underneath an existing operating system
and use that VMM to host arbitrary malicious soft-
ware. The resulting malware, which we call a virtual-
machine based rootkit (VMBR), exercises qualitatively
more control than current malware, supports general-
purpose functionality, yet can completely hide all its
state and activity from intrusion detection systems run-
ning in the target operating system and applications.
This paper explores the design and implementation
of virtual-machine based rootkits. We demonstrate
that a VMBR can be implemented on commodity hard-
ware and can be used to implement a wide range of ma-
licious services. We show that, once installed, a VMBR
is diﬃcult to detect or remove. We implement proof-
of-concept VMBRs on two platforms (Linux/VMware
and Windows/VirtualPC) and write malicious services
such as a keystroke sniﬀer, a phishing web server, a tool
that searches a user’s ﬁle system for sensitive data, and
a detection countermeasure which defeats a common
VMM detection technique. Finally, we discuss how to
detect and defend against the threat posed by VMBRs
and we implement a defense strategy suitable for pro-
tecting systems against this threat.
2. Virtual machines
This section reviews the technology of virtual ma-
chines and discusses why they provide a powerful plat-
form for building malware.
A virtual-machine monitor (VMM) manages the re-
sources of the underlying hardware and provides an
abstraction of one or more virtual machines [20]. Each
virtual machine can run a complete operating system
and its applications. Figure 1 shows the architecture
used by two modern VMMs (VMware and VirtualPC)
1. Software running within a virtual machine is called
guest software (i.e., guest operating systems and guest
applications). All guest software (including the guest
OS) runs in user mode; only the VMM runs in the most
privileged level (kernel mode). The host OS in Figure
1 is used to provide portable access to a wide variety
of I/O devices [44].
VMMs export hardware-level abstractions to guest
software using emulated hardware. The guest OS in-
teracts with the virtual hardware in the same manner
as it would with real hardware (e.g., in/out instruc-
tions, DMA), and these interactions are trapped by
the VMM and emulated in software. This emulation
allows the guest OS to run without modiﬁcation while
maintaining control over the system at the VMM layer.
A VMM can support multiple OSes on one computer
by multiplexing that computer’s hardware and provid-
ing the illusion of multiple, distinct virtual computers,
each of which can run a separate operating system and
its applications. The VMM isolates all resources of
each virtual computer through redirection. For exam-
ple, the VMM can map two virtual disks to diﬀerent
sectors of a shared physical disk, and the VMM can
map the physical memory space of each virtual ma-
chine to diﬀerent pages in the real machine’s memory.
In addition to multiplexing a computer’s hardware,
VMMs also provide a powerful platform for adding ser-
1The ideas in this paper apply equally well to the other archi-
tectures used to build VMMs, which are called Type I and Type
II [19].
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
host
application
host
application
host operating system
guest
application
guest
application
guest operating system
virtual-machine monitor (VMM)
host hardware
Figure 1. This ﬁgure shows a common structure used in today’s virtual machine monitors. The VMM
provides the abstraction of a virtual machine (dashed lines), each of which can run a complete guest
operating system and a set of guest applications. The host operating system and its host applications are
used to provide convenient access to I/O devices and to run VM services.
vices to an existing system. For example, VMMs have
been used to debug operating systems and system con-
ﬁgurations [30, 49], migrate live machines [40], detect
or prevent intrusions [18, 27, 8], and attest for code
integrity [17]. These VM services are typically imple-
mented outside the guest they are serving in order to
avoid perturbing the guest.
One problem faced by VM services is the diﬃ-
culty in understanding the states and events inside the
guest they are serving; VM services operate at a dif-
ferent level of abstraction from guest software. Soft-
ware running outside of a virtual machine views low-
level virtual-machine state such as disk blocks, net-
work packets, and memory. Software inside the virtual
machine interprets this state as high-level abstractions
such as ﬁles, TCP connections, and variables. This gap
between the VMM’s view of data/events and guest soft-
ware’s view of data/events is called the semantic gap
[13].
Virtual-machine introspection (VMI) [18, 27] de-
scribes a family of techniques that enables a VM ser-
vice to understand and modify states and events within
the guest. VMI translates variables and guest memory
addresses by reading the guest OS and applications’
symbol tables and page tables. VMI uses hardware or
software breakpoints to enable a VM service to gain
control at speciﬁc instruction addresses. Finally, VMI
allows a VM service to invoke guest OS or application
code. Invoking guest OS code allows the VM service
to leverage existing, complex guest code to carry out
general-purpose functionality such as reading a guest
ﬁle from the ﬁle cache/disk system. VM services can
protect themselves from guest code by disallowing ex-
ternal I/O. They can protect the guest data from per-
turbation by checkpointing it before changing its state
and rolling the guest back later.
A virtual-machine monitor is a powerful platform
for malware. A VMBR moves the targeted system into
a virtual machine then runs malware in the VMM or in
a second virtual machine. The targeted system sees lit-
tle to no diﬀerence in its memory space, disk space, or
execution (depending on how completely the machine
is virtualized). The VMM also isolates the malware’s
state and events completely from those of the target
system, so software in the target system cannot see or
modify the malicious software. At the same time, the
VMM can see all state and events in the target sys-
tem, such as keystrokes, network packets, disk state,
and memory state. A VMBR can observe and modify
these states and events—without its own actions be-
ing observed—because it completely controls the vir-
tual hardware presented to the operating system and
applications. Finally, a VMBR provides a convenient
platform for developing malicious services. A malicious
service can beneﬁt from all the conveniences of running
in a separate, general-purpose operating system while
remaining invisible to all intrusion detection software
running in the targeted system. In addition, a mali-
cious service can use virtual-machine introspection to
understand the events and states taking place in the
targeted system.
3. Virtual-machine based rootkit design
and implementation
In this section, we discuss the design and implemen-
tation of a VMBR. Section 3.1 describes how a VMBR
is installed on an existing system.
Section 3.2 de-
scribes the techniques VMBRs use to implement ma-
licious services, and Section 3.3 discusses the exam-
ple malicious services we implemented. Section 3.4 ex-
plains how VMBRs maintain control over the system.
To explore this threat, we implemented two proof-
of-concept VMBRs for the x86 platform using Virtual
PC and VMware Workstation VMMs. Our proof-of-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 