Fp(αi,j , CMPK) = Fp(
αi,j , CMPK),
n(cid:79)
n(cid:77)
i=1
E(j) =
s(j) =
Ei,j =
si,j =
n(cid:79)
n(cid:77)
i=1
n(cid:88)
n(cid:88)
i=1
fs(αi,j , CMPK) = fs(
αi,j , CMPK),
i=1
i=1
i=1
and thus MKVerify(CMPK, E(j), s(j)) = 1 shall hold,
i.e. (mpk(j), msk(j)) is a valid (master public key, master
secret key) pair and has the same distribution as the
ones generated by the original Setup() algorithm. In
addition, we have
E ← n(cid:79)
n(cid:79)
Thus, let mpksys := (E, CMPK), we have that(cid:0)mpksys,
i=1 αi, CMPK)(cid:1)(cid:1) is a valid (master
msksys := (cid:0)fs((cid:80)n
Fp(αi, CMPK) = Fp(
n(cid:88)
αi, CMPK).
Ei =
public key, master secret key) pair and has the same
distribution as the ones generated by Setup(), although
no one knows the value of msksys. In Table 1 we list
the public and secret shares that each party has.
i=1
i=1
i=1
j=1}n
Remark: After ﬁnishing the setup protocol, the PKGs
could wipe oﬀ their secrets {αi}n
i=1, secret shares {{αi,j,
si,j}n
i=1. In particular, Pj (j = 1, . . . , n) will hold
s(j) as its master secret key, while wiping oﬀ the val-
ues of {si,j}n
i=1, and Pi (i = 1, . . . , n) will wipe oﬀ the
values of αi, si, and {αi,j, si,j}n
j=1.
KeyGen: A user with identity id ∈ {0, 1}∗ chooses a min-
imum authorized set at his choice, say {Pj1 , . . . , Pjt}, and
obtains his private key as below.
1. For k = 1,··· , t,
(a) Pjk uses mpk(jk) :=(cid:0)E(jk), CMPK(cid:1) and msk(jk) :=
(cid:0)s(jk)(cid:1) as its master public key and master secret
key respectively, runs the underlying KeyGen al-
gorithm and obtains
(jk)
id ← KeyGen(mpk(jk), msk(jk), id).
SK
(b) Pjk sends the secret key SK
(c) The users checks whether SKVerify(CMPK, E(jk),
) = 1 holds. If not, the user marks Pjk as a
to the user.
(jk)
id
(jk)
id
SK
dishonest PKG.
Remark: Note that E(jk) = Fp((cid:80)n
s(jk) = fs((cid:80)n
i=1 αi,jk , CMPK), we have
i=1 αi,jk , CMPK),
SK
(jk)
id = fu(id,
αi,jk , CMPK, rj,k) for some rj,k ∈ R.
n(cid:88)
i=1
2. The user computes constants
k=1 ← F indLsssConst(A, (M, ρ), {Pj1 , . . . , Pjt}),
{wjk}t
and computes
SKid ← t(cid:75)
k=1
(SK
(jk)
id
(cid:12)wjk .
)
(6)
217P1: E1 = Fp(α1, CP)
(M,ρ)−→ (α1,1, . . . , α1,n)
α1
E1,1 = Fp(α1,1, CP)
s1,1 = fs(α1,1, CP)
P1
.
.
.
Ei,1 = Fp(αi,1, CP)
· · ·
· · ·
.
.
.
· · ·
Pj
E1,j = Fp(α1,j , CP)
s1,j = fs(α1,j , CP)
.
.
.
Ei,j = Fp(αi,j , CP)
· · ·
· · ·
.
.
.
· · ·
Pn
E1,n = Fp(α1,n, CP)
s1,n = fs(α1,n, CP)
.
.
.
Ei,n = Fp(αi,n, CP)
si,1 = fs(αi,1, CP)
si,j = fs(αi,j , CP)
si,n = fs(αi,n, CP)
.
.
.
En,1 = Fp(αn,1, CP)
sn,1 = fs(αn,1, CP)
.
.
.
.
.
.
· · · En,j = Fp(αn,j , CP)
sn,j = fs(αn,j , CP)
.
.
.
.
.
.
· · · En,n = Fp(αn,n, CP)
sn,n = fs(αn,n, CP)
E(1) =(cid:78)n
s(1) =(cid:76)n
i=1 Ei,1
i=1 si,1
· · ·
E(j) =(cid:78)n
s(j) =(cid:76)n
i=1 Ei,j
i=1 si,j
· · ·
E(n) =(cid:78)n
s(n) =(cid:76)n
i=1 Ei,n
i=1 si,n
.
.
.
Pi: Ei = Fp(αi, CP)
(M,ρ)−→ (αi,1, . . . , αi,n)
αi
.
.
.
Pn: En = Fp(αn, CP)
(M,ρ)−→ (αn,1, . . . , αn,n)
αn
E =(cid:78)n
Outputs:
i=1 Ei
1 For simplicity, let CP denote CMPK.
Table 1: Public and Secret Shares
Remark: We have
t(cid:75)
t(cid:75)
k=1
k=1
SKid =
=
protocol. This is a reasonable assumption; otherwise, there
is no security at all as all PKGs are dishonest or malicious.
• Guaranteed by the unforgeability (and thus the unde-
niability) of the underlying signature scheme, each Pi
will honestly execute the protocol and publish a valid
signature on its message ﬁngerprint f pi in Step (2d).
(cid:12)wjk
αi,jk , CMPK, rjk )
(SK
(jk)
id
)
(cid:12)wjk
n(cid:88)
i=1
i=1
k=1
fu(id,
wjk (
n(cid:88)
t(cid:88)
t(cid:88)
n(cid:88)
n(cid:88)
(cid:0)wj1 (cid:0) ··· (cid:0) (rjt )
k=1
i=1
i=1
=fu(id,
αi,jk ), CMPK, r)
=fu(id,
wjk αi,jk , CMPK, r)
=fu(id,
αi, CMPK, r),
(cid:0)wjt ∈ R.
where r = (rj1 )
i.e., SKid
is a valid user private key for identity id under (mas-
ter public key, master secret key) pair (mpksys, msksys),
and has the same distribution as the ones generated by
the KeyGen algorithm using (mpksys, msksys).
Encrypt: Given a message M ∈ M(CMPK) and an iden-
tity id ∈ {0, 1}∗, the encrypting party uses mpksys as the
master public key to run the underling Encrypt algorithm
and outputs a ciphertext
CTid ← Encrypt(mpksys, M, id).
(7)
Decrypt: Given a ciphertext CTid (generated by Equa-
tion (7)) and a private key SKid (generated by Equation (6)),
the decrypting party uses mpksys as the master public key to
run the underling Decrypt algorithm and outputs a message
M ← Decrypt(mpksys, CTid, SKid).
It is easy to see that, for any message M ∈ M(CMPK), any
identity id ∈ {0, 1}∗, and SKid generated by Equation (6),
Decrypt(mpksys, Encrypt(mpksys, M, id), SKid) = M.
4.2 Security Analysis
In this part we analyze the security of the Dealerless Dis-
tributed PKG protocol above. Before the analysis, we as-
sume that there is at least one honest PKG which follows the
– If Pi publishes an invalid signature (σ(1)
, (i, f pi,
pid||1)), it must be complained by some other
Pj(j (cid:54)= i) and be investigated in Step (3a), since
there is at least one honest PKG. The invalid sig-
nature could serve as an evidence of the dishon-
esty of Pi.
i
i
– If Pi publishes a valid signature (σ(1)
, (i, f pi, pid
||1)), no one could frame Pi in Step (3a) by com-
plaining that Pi published an invalid signature,
since anyone can easily verify the signature.
– Since anyone can check the validity of (cid:8){(σ(2)
(i, j, resulti,j , pid||2))}j∈{1,...,n}\{i}(cid:9)n
i,j ,
i=1 and whether
all the resulti,j’s are TRUE, no (dishonest) PKG
would be willing to set the veriﬁcation result of
, (i, f pi, pid||1)) to be FALSE
Pi’s signature (σ(1)
in order to frame Pi.
i
– Finally, once some PKG Pi has been found to be
dishonest, all the PKGs who have “agreed” on the
dishonesty of Pi (by publishing the signed veriﬁ-
cation results) will be investigated as well. Such a
mechanism guarantees that each Pj will honestly
execute the Step (3).
• In Step (4a), each Pi will honestly execute the protocol
using exactly the same values of ({Ei,j}n
j=1, Ei) as in
Step (2c). This is guaranteed by the veriﬁcations in
Step (5).
– If Pi publishes an invalid signature (σ(3)
, ({(i, j,
its dishonesty will be
i
j=1, (i, Ei), pid||3)),
Ei,j)}n
detected in Step (5(a)i).
– If Pi uses ({Ei,j}n
j=1, Ei) that are diﬀerent from
those in Step (2c), it will be found dishonest in
It cannot deny such a complaint
Step (5(a)i).
, (i, f pi, pid||1)) has been
since it signature (σ(1)
veriﬁed by all PKGs in Step (3).
i
218Similarly, if Pi dishonestly executes Step (4a), it will
be complained by some honest PKG. On the other
side, if Pi honestly executes Step (4a), no PKG will
frame Pi at the risk of being investigated. In addition,
i,j , (i, j, resulti,j, pid||5))
as each Pj has to publish (σ(5)
to the public bulletin board as its veriﬁcation result
j=1, (i, Ei), pid||3)), each Pj will
on (σ(3)
honestly execute the Step (5).
Now we can conclude that the values of(cid:8)({Ei,j}n
j=1, Ei)(cid:9)n
, ({(i, j, Ei,j)}n
i
have been ﬁxed at the end of Step (2), and any later attempts
to change them will be detected and complained. The basic
idea is as below.
i=1
1. In the ﬁrst phase, each PKG determines its own shares,
but refrains from sending the shares to other PKGs
immediately. Instead, each PKG publishes a message
ﬁngerprint of its shares, as well as its signature on the
ﬁngerprint.
2. In the second phase, signature on the ﬁngerprint is
veriﬁed, guaranteeing that no PKG could deny the in-
tegrity of the ﬁngerprint in later phases.
3. In the third phase, shares are all sent to other PKGs.
By comparing the ﬁngerprint of the shares and that
published in the ﬁrst phase, one can determine that