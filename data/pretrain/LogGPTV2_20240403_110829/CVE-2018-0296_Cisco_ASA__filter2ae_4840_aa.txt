# CVE-2018-0296 Cisco ASA 拒绝服务漏洞分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：陈千
## 漏洞简介
CVE-2018-0296是思科ASA设备Web服务中存在的一个拒绝服务漏洞，远程未认证的攻击者利用该漏洞可造成设备崩溃重启。该漏洞最初由来自Securitum的安全研究人员Michal
Bentkowski发现，其在[博客](https://sekurak.pl/opis-bledu-cve-2018-0296-ominiecie-uwierzytelnienia-w-webinterfejsie-cisco-asa/)中提到该漏洞最初是一个认证绕过漏洞，上报给思科后，最终被归类为拒绝服务漏洞。据思科发布的[安全公告](https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20180606-asaftd)显示：针对部分型号的设备，该漏洞可造成设备崩溃重启；而针对其他型号的设备，利用该漏洞可获取设备的敏感信息，造成信息泄露。
针对该漏洞，目前已有公开的PoC脚本，可用于获取设备的敏感信息如用户名，或造成设备崩溃重启。经过实际测试，在公开PoC中造成该漏洞的关键url如下。
https://:/+CSCOU+/../+CSCOE+/files/file_list.json?path=/
下面利用思科ASA设备和已有的PoC脚本，对该漏洞的形成原因进行分析。
## 背景知识
在实际对漏洞进行分析的过程中，发现思科ASA设备的lina程序中，存在大量的Lua脚本以及对Lua
api的调用。为了便于理解，下面对Lua脚本的相关知识进行简单介绍。
###  Lua脚本和C/C++交互
Lua是一个小巧的脚本语言，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua脚本可以很容易被C/C++代码调用，也可以反过来调用C/C++的函数，这使得Lua在应用程序中可以被广泛使用。不仅可作为扩展脚本，也可以作为普通的配置文件，代替XML、ini等文件格式，并且更容易理解和维护。
Lua和C/C++通信的主要方式是一个虚拟栈，其特点是后进先出。在Lua中，Lua栈就是一个struct，栈的索引可以是正数也可以是负数，其中正数索引1永远表示栈底，负数索引-1永远表示栈顶，如下图所示。
Lua中的栈在stack_init()函数中创建，其类似于下面的定义。
    TObject stack[BASIC_STACK_SIZE + EXTRA_STACK]
在Lua中，可以往栈上压入字符串、数值、表和闭包等类型，最后统一用Tobject这种数据结构进行保存，如下。TObject结构对应于Lua中所有的数据类型，是一个{值，类型}结构，它将值和类型绑在一起。其中用tt表示value的类型，value是一个联合体，共有4个域，说明如下。
  * p：可以保存一个指针，实际上指向Lua中的light userdata结构
  * n：保存数值，包括int、float等类型
  * b：保存布尔值
  * gc：保存需要内存管理垃圾回收的类型如string、table、closure等
    // lua 数据类型
    #define LUA_TNONE        (-1)
    #define LUA_TNIL         0   // 空值
    #define LUA_TBOOLEAN     1
    #define LUA_TLIGHTUSERDATA  2
    #define LUA_TNUMBER         3
    #define LUA_TSTRING         4
    #define LUA_TTABLE          5
    #define LUA_TFUNCTION       6
    #define LUA_TUSERDATA       7
    #define LUA_TTHREAD         8
###  Lua 栈操作常用api
Lua中提供了一系列与栈操作相关的api，常用的api如下。
    // 压入元素
    void lua_pushnil (lua_State *L);
    void lua_pushboolean (lua_State *L, int bool);
    void lua_pushnumber (lua_State *L, double n);
    void lua_pushlstring (lua_State *L, const char *s, size_t length);
    void lua_pushstring (lua_State *L, const char *s);
    // 检查一个元素是否是一个指定的类型
    int lua_is* (lua_State *L, int index); // *可以是任何类型
    // 获取元素
    int           lua_toboolean (lua_State *L, int index);
    double        lua_tonumber (lua_State *L, int index);
    const char *  lua_tostring (lua_State *L, int index);
    size_t        lua_strlen (lua_State *L, int index);
## 环境准备
###  调试环境搭建
由于该漏洞在不同型号设备上表现的行为不一致，这里分别选取了32位的设备和64位的设备，相关信息如下。其中，前面2个设备用于漏洞分析，设备asav9101用于补丁分析。
  * 真实设备ASA 5505，镜像为asa924-k8.bin ，32bit
  * GNS3仿真设备，镜像为asav962.qcow2，64bit
  * GNS3仿真设备，镜像为asav9101.qcow2，64bit
ASA设备中内置了gdbsever，但默认不启动。为了对设备进行调试，需要修改镜像文件以启动gdbserver。同时，由于ASA设备会对镜像文件进行完整性校验，所以修改后的镜像文件无法直接通过tftp或ASDM工具传入设备。ASA使用CF卡作为存储设备，可以通过用CF卡读卡器直接将镜像写入CF卡中的方式绕过校验，因为ASA没有对CF中的镜像进行校验。
详细的调试环境搭建和镜像修改等内容可以参考nccgroup的系列[博客](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/september/cisco-asa-series-part-one-intro-to-the-cisco-asa/).
###  设备配置
思科ASA设备会在443端口提供Web服务。笔者在进行测试时，对设备的WebVPN功能(Clientless SSL
VPN)进行了配置，使得可以访问Web服务，进而触发该漏洞。详细的配置操作可参考思科[相关文档](https://www.cisco.com/c/en/us/support/docs/security-vpn/webvpn-ssl-vpn/119417-config-asa-00.html)。
## 漏洞分析
环境搭建好后，运行已有的PoC脚本，针对asa924设备，会造成敏感信息泄露，而针对asav962设备，会造成设备崩溃重启。下面基于asav962设备，重点对拒绝服务漏洞进行分析。
###  崩溃分析
运行PoC脚本，在gdb中捕获到如下错误。可以看到，崩溃点在libc.so.6库中的strlen()函数里，由于在0x7ffff497699a处尝试访问一个非法的内存地址0x13，故产生Segmentation
fault错误，而rax的值来源于strlen()函数的参数。
    Thread 2 received signal SIGSEGV, Segmentation fault.
    [Switching to Thread 1677]
    0x00007ffff497699a in strlen () from ***/_asav962.qcow2.extracted/rootfs/lib64/libc.so.6
    (gdb) x/10i $rip
    => 0x7ffff497699a :  movdqu xmm12,XMMWORD PTR [rax]
       0x7ffff497699f :  pcmpeqb xmm12,xmm8
       0x7ffff49769a4 :  pmovmskb edx,xmm12
       0x7ffff49769a9 :  test   edx,edx
       0x7ffff49769ab :  je     0x7ffff49769b1 
       0x7ffff49769ad :  bsf    eax,edx
       0x7ffff49769b0 :  ret
       0x7ffff49769b1 :  and    rax,0xfffffffffffffff0
       0x7ffff49769b5 :  pcmpeqb xmm9,XMMWORD PTR [rax+0x10]
       0x7ffff49769bb :  pcmpeqb xmm10,XMMWORD PTR [rax+0x20]
    (gdb) i r $rax
    rax            0x13     19
    (gdb) bt
    #0  0x00007ffff497699a in strlen () from ***/_asav962.qcow2.extracted/rootfs/lib64/libc.so.6
    #1  0x0000555557ee51ce in lua_pushstring ()
    #2  0x00005555583c87d2 in webvpn_file_name ()
    #3  0x0000555557eec43b in luaD_precall ()
    #4  0x0000555557efc258 in luaV_execute ()
    #5  0x0000555557eeced0 in luaD_call ()
    #6  0x0000555557eebeda in luaD_rawrunprotected ()
    #7  0x0000555557eed323 in luaD_pcall ()
    #8  0x0000555557ee5de6 in lua_pcall ()
    #9  0x0000555557f00821 in lua_dofile ()
    #10 0x000055555822053b in aware_run_lua_script_ns ()
    #11 0x0000555557dc6e3d in ak47_new_stack_call ()
    Backtrace stopped: previous frame inner to this frame (corrupt stack?)
根据栈回溯信息，查看函数lua_pushstring()和webvpn_file_name()，其部分伪代码片段如下。在函数webvpn_file_name()中，将v1
+
0x13这个指针作为参数传递给lua_pushstring()，最终传递给strlen()函数。崩溃点处访问的非法内存地址为0x13，说明v1=0，即在webvpn_file_name()中lua_touserdata()返回值为NULL(也就是0)。
    _DWORD *__fastcall lua_pushstring(__int64 a1, const char *a2)
    {
      size_t v2; // r14
      __int64 v3; // r13
      _DWORD *result; // rax
      if ( a2 )
      {
        v2 = _wrap_strlen(a2);
        // ...
    }
    signed __int64 __fastcall webvpn_file_name(_QWORD *a1)
    {
      signed __int64 v1; // rax
      v1 = lua_touserdata(a1, 1);
      lua_pushstring((__int64)a1, (const char *)(v1 + 0x13));
      return 1LL;
    }