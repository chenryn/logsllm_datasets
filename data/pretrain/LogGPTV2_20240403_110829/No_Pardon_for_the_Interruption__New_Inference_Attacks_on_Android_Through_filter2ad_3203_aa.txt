title:No Pardon for the Interruption: New Inference Attacks on Android Through
Interrupt Timing Analysis
author:Wenrui Diao and
Xiangyu Liu and
Zhou Li and
Kehuan Zhang
2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy
No Pardon for the Interruption:
New Inference Attacks on Android Through
Interrupt Timing Analysis
Wenrui Diao∗, Xiangyu Liu∗, Zhou Li†, and Kehuan Zhang∗
∗Department of Information Engineering, The Chinese University of Hong Kong
Email: {dw013, lx012, khzhang}@ie.cuhk.edu.hk
†IEEE Member
Email: PI:EMAIL
Abstract—Many new specialized hardware components have
been integrated into Android smartphones to improve mobility
and usability, such as touchscreen, Bluetooth module, and NFC
controller. At the system level, the kernel of Android is built
on Linux and inherits its device management mechanisms.
However, the security implications surfaced from the integration
of new hardware components and the tailored Linux kernel
are not fully understood. In this paper, we make the ﬁrst
attempt to evaluate such implications. As a result, we identify a
critical information leakage channel from the interrupt handling
mechanism, which can be exploited to launch inference attacks
without any permission. On Android, all reported interrupts are
counted by Linux kernel and the statistical information is logged
in a system ﬁle /proc/interrupts, which is public to any
process. Such statistical information reveals the running status of
all integrated devices, and could be exploited by attackers to infer
sensitive information passing through them. To assess this new
threat, we propose a general attack approach – interrupt timing
analysis and apply it to interrupt logs. As showcases, we present
two concrete inference attacks against user’s unlock pattern
and foreground app status respectively. Through analyzing the
interrupt
time series produced from touchscreen controller,
attacker’s chance of cracking user’s unlock pattern is increased
substantially. The interrupt time series produced from Display
Sub-System reveals unique UI refreshing patterns and could
be leveraged as ﬁngerprints to identify the app running in the
foreground. Such information can serve as the stepping stone for
the subsequent phishing attacks. The experiment results suggest
our inference attacks are highly effective, and the risks should
be mitigated immediately.
Index Terms—hardware interrupt; timing analysis; procfs;
I. INTRODUCTION
Smartphone plays the important role of personal assistant
and data container in people’s daily life. Different from the
traditional desktop platforms, mobile OSes need to sufﬁce
the new requirements of mobility and usability with limited
computing resources. New specialized hardware components,
e.g., touchscreen and NFC transmitter, are manufactured and
integrated to this end.
Previous research investigated the security threats coming
from particular hardware components, like accelerometer [1],
[2] and camera [3], [4]. These attacks are mainly based on
reading data directly generated by the targeted hardware.
However, none of them looked into the threats introduced
by the highly tailored software components, especially from
the angle of kernel. In this paper, we make the ﬁrst attempt
to evaluate the security implications of the integration of
specialized hardware and tailored kernel on Android.
Hardware Interrupt. As the most popular mobile platform,
Android is built on Linux kernel and enhanced to adapt to the
requirement of mobility. Android also inherits the interrupt
mechanism from Linux, which is designed for the efﬁcient
communication between the CPU and external devices. When
new hardware events (e.g., user touching the screen) come, the
corresponding hardware device (e.g., touchscreen controller)
sends a signal to ask OS for immediate processing. As a
response,
the CPU alters the sequence of instructions in
execution to handle this event with high priority.
Our Findings. All reported interrupts are counted by OS,
and the statistical
information is stored in a system ﬁle
/proc/interrupts (Fig. 2 shows an example), which
is public to any process. Such information reﬂects the real-
time running status of devices and it could be exploited by
attackers to infer information that passes through, including
user’s sensitive data and interactions with the devices. In
this paper, we propose a novel attack approach – interrupt
timing analysis. Through analyzing the time series of interrupts
occurred for a particular device, user’s associated sensitive
information could be inferred by the attacker without any
permission.
The root cause of this new security threat comes from the
ill-conceived integration of specialized hardware components
and tailored kernel. Unlike the traditional desktop platforms,
smartphone is equipped with many peripheral devices, such
as touchscreen, Bluetooth module, NFC controller. These
newly included devices usually interact with the user directly
and bring new kinds of interrupts, which means new attack
channels. However, Android still uses the built-in method of
Linux kernel for interrupt auditing without any change. The
interrupt information channel was once mentioned in previous
work [5], [6], but they doubted that it could be used for
effective attacks and no concrete attack method or result was
given. On Android, we present two concrete inference attacks
2375-1207/16 $31.00 © 2016 IEEE
© 2016, Wenrui Diao. Under license to IEEE.
DOI 10.1109/SP.2016.32
DOI 10.1109/SP.2016.32
414
414
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:05 UTC from IEEE Xplore.  Restrictions apply. 
through interrupt timing analysis, against user’s unlock pattern
and foreground app respectively.
Inferring Unlock Pattern. Touchscreen is an indispensable
component for nearly all smartphones. A lot of user’s sensitive
information passes to the system through the movement on
touchscreen. We use the Android graphical password scheme
– unlock pattern as an example to demonstrate the feasibility
of our proposed interrupt timing analysis. We ﬁnd the ﬁnger
movements on the screen correlates to the amount of interrupt
occurred for touchscreen controller. Speciﬁc to unlock pattern,
the interrupt amount reﬂects the length of swipe line indirectly.
After gathering its time series, we leverage Hidden Markov
Model and probabilistic analysis to infer the possible unlock
patterns. Our experimental study shows, even without any
knowledge about the victim (i.e., the user could select any
pattern from all 389,112 combinations), our attack could
reduce more than 90 % search space for just one guess.
Inferring Foreground App. The information about app run-
ning in the foreground is quite sensitive and should be kept
away from unauthorized apps to prevent phishing attacks.
Starting from Android 5.0, Google has enforced a system-
level permission REAL_GET_TASKS [7] to prevent such
information leaking to third-party apps, which nonetheless can
be bypassed by our attack. We observe that, while launching
an app,
the foreground UI is continuously refreshed. The
refreshing patterns of apps during launching could be used
to identify this app. Also, in the course of UI refreshing, the
interrupts for Display Sub-System (DSS) occur with the same
frequency. It motivates us to model the UI refreshing process
through interrupt time series and detect the foreground app.
Combined with machine learning techniques, we achieve such
attack without any permission, and the result shows an attacker
has 87 % success rate to identify the foreground app from a
set of 100 candidates within one attempt.
Contributions. We summarize this paper’s contributions as
below:
• New Attack Surface and Approach. We discover that the
interrupt log ﬁle (/proc/interrupts) of Android
could leak user’s sensitive information. To exploit such
information, we propose a new general attack approach
– interrupt timing analysis.
• New Inference Attacks. We present two practical inference
attacks to infer user’s unlock pattern and the app running
in the foreground. The attack channels are based on
the interrupt time series for touchscreen controller and
Display Sub-System.
• New Techniques. A set of novel schemes are developed
to model the inference target, including unlock pattern
modeling, gram transition inference, improved time series
similarity calculation, etc.
• Implementation and Evaluation. We implemented the
attack prototype apps and evaluated them under the real-
world settings. Our experimental studies demonstrate that
attacking through interrupt timing side-channel is feasible
and highly effective.
Roadmap. The rest of the paper is organized as follows:
Section II introduces the background of hardware interrupt
and explains why information could be leaked from interrupts
on Android. Section III outlines the high-level ideas of our
two concrete attacks. Section IV shows our attack on inferring
unlock pattern. Inferring the foreground app is introduced in
Section V. In Section VI, we discuss the leaks from other
interrupts and propose some defense solutions. Related works
are reviewed in Section VII. Section VIII concludes this paper.
II. BACKGROUND
Hardware interrupt was introduced as an efﬁcient mech-
anism for the communication between high-speed CPU and
low-speed external devices since the early age of modern
computer. This mechanism is embraced by all mainstream
computing platforms, including the mobile ones like Android.
In this section, we brieﬂy overview the design of hardware
interrupt and Android, and then explain why the leaks from
interrupts on Android could lead to inference attacks.
A. Hardware Interrupt
In modern computing architecture, CPU is responsible for
managing the connected hardware devices and initiating the
handling procedures deﬁned by operating system (OS) for
different hardware events. Hardware interrupt mechanism is
proposed to enable timely event management when one CPU
has to serve many devices (e.g., mouse, keyboard, and network
card). When a device requires immediate attention from OS,
e.g., when the volume key is pressed or keyboard is typed, an
electronic signal will be emitted from the device [8]. Such
electronic signal
is called Interrupt Request (IRQ) and is
passed to the corresponding programmable interrupt controller
(PIC) through IRQ lines. PIC is a hardware circuit which
bridges I/O devices and CPU. When it receives an IRQ, it will
notify CPU to process this IRQ immediately. In response, CPU
will halt the current execution thread, preserve the execution
context, and invoke the registered interrupt handler. Such a
process that alters the sequence of instructions executed by
CPU is called interrupt. When the execution of the interrupt
handler is completed, the preserved context is restored and
halted execution is resumed. This interrupt mechanism is
particularly useful for handling hardware I/O events which
are usually urgent but triggered nondeterministically [9].
B. Android Platform
In this work, we investigate the security issues regarding
hardware interrupt on Android platform. Android system is
built on Linux kernel, and new layers are introduced in
addition to sufﬁce the functionality requirements for mobile
devices [10], [11]. The whole architecture can be sliced into
6 layers, which can be further classiﬁed into two categories
based on their degrees of dependence on hardware. Fig. 1
illustrates the layers of Android system, and the each layer is
brieﬂy described below:
415415
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:05 UTC from IEEE Xplore.  Restrictions apply. 
Hardware 
independent
Hardware 
dependent
Applications
Application Frameworks
Libraries
Hardware Abstraction Layer
Graphics, Audio, Camera, Bluetooth, GPS...
Linux Kernel
Display Driver, Camera Driver, Bluetooth 
Driver, Shared Memory Driver...
Hardware Devices
Touchscreen, LCD Panel, Accelerometer, 
Camera, Light Senser...
Fig. 1. Android layered framework
1) Hardware Dependent Layers:
• Hardware Devices are the physical components of an
Android smartphone, including touchscreen, LCD panel,
camera, etc.
• Linux Kernel
is the foundation of Android system.
Compared with the original Linux kernel, a set of “kernel
enhancements” are patched to provide tailored support for
Android system. For instance, an Android-speciﬁc mech-
anism Binder is integrated into the kernel to facilitate
interprocess communication [12].
• Hardware Abstraction Layer (HAL) deﬁnes the func-
tional interfaces that are required to be implemented by
hardware device drivers. Through this layer, applications
and system libraries can operate hardware devices man-
ufactured by different vendors using uniﬁed APIs.
2) Hardware Independent Layers:
• Libraries layer provides libraries written in native code
(C/C++) that directly access Linux kernel and HAL. In
addition, Android Runtime, including the mobile applica-
tion (app) container Dalvik VM, is implemented within
this layer.
• Application Frameworks include a set of system ser-
vices that can be shared and reused by mobile apps. For
example, Content Provider allows data publishing and
sharing between apps.
• Applications layer stacks the mobile apps. It comprises
both system apps which are shipped together with An-
droid OS and third-party apps installed by user.
Under the Android framework, hardware interrupt is raised
from the hardware devices layer and responded by the Linux
kernel layer. The interrupt ﬂows initiated from speciﬁc devices
are shown in Section IV-A and V-A.
C. Information Leaks from Interrupts on Android
The framework for interrupt processing and auditing on
Android resembles other Linux-based systems. When an IRQ
is issued and handled by CPU, it is logged by a system
counter and the statistical information is stored in a system ﬁle
416416
/proc/interrupts. The access attributes for this ﬁle is
-r--r--r--, which means it can be read by any process, no
matter if it belongs to system apps or third-party apps. Fig. 2
shows the partial content of the ﬁle dumped from Google
Nexus 6 with Android 5.1.1 installed. The ﬁrst column lists
the unique IRQ (line) numbers. Each number is reserved by
OS for one type of event and is associated with one interrupt
handler. The following columns show how many interrupts
have been issued to each CPU core since the starting of system
(power on for Android). Since Google Nexus 6 is equipped
with a 4-core CPU (Qualcomm Snapdragon 805), the interrupt
counts are listed in 4 columns. The number of columns varies
depending on the number of active CPU cores. In general,
Linux kernel prefers to handle interrupts on the ﬁrst CPU core
in order to maximize cache locality [8]. As shown in Fig. 2,
the column CPU0 has the largest interrupt count for most IRQ
numbers. The penultimate column shows the name of PIC
assigned for handling one type of IRQ. One PIC could be
shared by multiple devices for transmitting IRQ. The devices
that send out the speciﬁc IRQ are listed in the last column.
Since the statistical information of interrupt reﬂects the
running status of devices and is also public, it could be abused
by attackers to infer the user’s actions on targeted devices,
causing information leaks. Previous research has mentioned
the potential privacy risks related to interrupt [5], [6], but none
of them presented concrete attacks leveraging this channel.
In particular, Jana et al. [5] stated that “the feasibility of this
attack remains open”. For the traditional desktop environment,
though more than 10 different
types of interrupts can be
monitored, most of the associated devices do not directly
interact with users, e.g., system timer. For the remaining ones,
the information leaked is rather limited. As an example, the
interrupt from audio codec could leak whether an earphone
is plugged, which, however, cannot be used to infer more
sensitive information - the played sounds. What’s more, the
interrupt counter is used globally rather than dedicated to a
single process, which makes the sensitive information hard to
be discerned.
The development of modern mobile phones, however, offers
new alternatives to exploit interrupt information for attacks.
The set of integrated peripheral devices on smartphones keeps
growing to meet user’s new expectations, and each new device
brings in new kind of interrupt (e.g., NFC controller). For
the Google Nexus 6 phone we tested, already more than 100
IRQ numbers are reserved by OS. Most of the newly included
devices directly interact with the user, and the potential attack
surface is signiﬁcantly broadened. Another favorable condition
for attacks is that applications run less parallel in mobile
system than in desktop system. Especially for Android phones,
only one application is allowed to run in the foreground.
Therefore, the signals from user’s actions or applications of
interest are more distinguishable. As shown in our concrete
attacks, inference attack abusing leaks from interrupt is not
only feasible on Android but can also lead to grave security
and privacy issues, i.e., leaks of unlock patterns and applica-
tion running status.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:05 UTC from IEEE Xplore.  Restrictions apply. 
           CPU0       CPU1       CPU2       CPU3        
 20:      29825       9674       8921       8102       GIC  arch_timer 
 25:          0          0          0          0       GIC  MSM_L1 
 33:       2258          0          0          0       GIC  bw_hwmon 
 34:          0          0          0          0       GIC  MSM_L2 
 35:          0          0          0          0       GIC  apps_wdog_bark 
 39:       2722       1754       1635       1389       GIC  arch_mem_timer 
 61:         80          0          0          0       GIC  mxhci_hsic_pwr_evt 
 64:       5573          0          0          0       GIC  xhci-hcd:usb1 
 65:       4519          0          0          0       GIC  kgsl-3d0 
 74:          0          0          0          0       GIC  msm_iommu_nonsecure_irq 
 75:          0          0          0          0       GIC  msm_iommu_secure_irq, msm_iommu_secure_irq 
 76:        548          0          0          0       GIC  msm_vidc 
... (Omit some lines) 
436:          0          0          0          0   msmgpio  bluetooth hostwake 
437:         22          0          0          0  qpnp-int  smb135x_chg_stat_irq 
438:          1          0          0          0   msmgpio  max170xx_battery 
439:        129          0          0          0   msmgpio  atmel_mxt_ts 
440:         48          0          0          0   msmgpio  bcm2079x 
... (Omit some lines) 
The amount of interrupts occurred 
Device name 
IRQ number 
PIC name 
Fig. 2. Example of /proc/interrupts, dumped from Google Nexus 6.
Interrupt on Other Platforms. To fully understand the attack
surface, we also investigate the attack feasibility on other
platforms. In Mac OS X / iOS environment, a similar interrupt
mechanism is implemented, but the statistical information of
interrupts is not exposed to the processes (no public /proc
ﬁlesystem is available due to the different kernel-level imple-
mentation derived from BSD) [13]. On Microsoft Windows
platforms (both desktop and mobile), the design principle of
interrupt handling is similar, but the implementation is quite
different. For instance, the Trap Dispatching mechanism [14]
is incorporated to achieve more ﬂexible interrupt processing.
On the other hand, different from Mac OS X / iOS platforms,
the statistics of interrupt are public. Command-line tools such
as Xperf [15] can be used to retrieve such information, which
is usable for the interrupt attacks.
Software Interrupt. Another kind of interrupt is software
interrupt, which is used by programs for immediate com-
munication with CPU. Software interrupt is triggered under
two scenarios [9]: 1) an exception (or trap) which cannot be
handled by the program alone is raised. 2) special instruction
causing interrupt is executed (e.g., to request data from disk
controller). The corresponding statistics are logged in a public
ﬁle /proc/softirqs. Yet, whether software interrupt can
be used for inference attacks is unclear, since the information
is more coarse-grained (aggregated from all processes) and
less user-centric. Therefore, we focus on hardware interrupt
in this work.
III. ATTACK OVERVIEW
Through examining the interrupt statistics on Android, we
identiﬁed two types of interrupts that are both tied to user’s
behaviors and showing distinguishable patterns according to
different user’s actions. The ﬁrst
type is produced from
touchscreen when pressed and released by the user, while the
second one is generated accompanying with UI refreshing. By
continuously monitoring these interrupt statistics, we show it
is feasible to infer user’s unlock pattern and the app started by
user. In this section, we introduce the mechanisms regarding
unlock pattern and UI refreshing together with the high-level
ideas of our attacks.
A. Inferring Unlock Pattern
Touchscreen becomes an indispensable component
for
nearly all smartphones today. A large amount of user’s sen-
sitive information passes through the touchscreen, including
text messages and unlock pattern. The secrets can be indirectly
inferred from the interrupt emitted from touchscreen, and we
use unlock patterns as an attack showcase.
Android Unlock Pattern. Unlock pattern is incorporated into
Android as an alternative to overcome the usability issue
involving traditional authentication schemes, like text-based
password. When a user intends to unlock her phone, a 3 × 3
matrix (totally 9 dots) is displayed on the screen, and the user
is required to draw her unlock pattern through a series of lines
which connect the dots in a certain order (we call them swipe
lines). Compared to the traditional authentication schemes,
unlock pattern is easier to remember and input. Therefore,
it is widely adopted by customers [16]. Fig. 3 shows the lock
UI on Android 5.1.1 (AOSP) and one unlock pattern.
Each dot in the lock UI is mapped to a number (see Fig. 4),
and the number sequence for an unlock pattern is called
pattern password. For instance, the pattern password of the
unlock pattern illustrated in Fig. 3 is 41235789. For the
same geometric shape of unlock pattern, drawing in different
directions (e.g., 14789 v.s. 98741) results in different pattern
passwords.
A valid pattern lock should satisfy 4 requirements below:
1) At least 4 dots must be used.
2) At most 9 dots can be used.
417417
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:05 UTC from IEEE Xplore.  Restrictions apply. 
y
1
1
4
4
7
7
77
2
5
8
8
3
6
9
9
x
Fig. 3. UI for inputting unlock
pattern on AOSP Android 5.1.1.
Fig. 4. Unlock pattern modeling.
3) No dot can be used more than once.
4) Only straight line is allowed and the dots not visited
before cannot be jumped over.
Even after the above restrictions are applied, there still
exist 389,112 valid combinations [17], making the chance for