title:Automated and Safe Vulnerability Assessment
author:Fanglu Guo and
Yang Yu and
Tzi-cker Chiueh
Article
An Automated Vulnerability Detection and
Remediation Method for Software Security
Jeesoo Jurn, Taeeun Kim and Hwankuk Kim * ID
Korea Internet & Security Agency, 9, Jinheung-gil, Naju-si, Jeollanam-do 58324, Korea; PI:EMAIL (J.J.);
PI:EMAIL (T.K.)
* Correspondence: PI:EMAIL; Tel.: +82-61-820-1272
Received: 6 April 2018; Accepted: 16 May 2018; Published: 21 May 2018
Abstract: As hacking techniques become more sophisticated, vulnerabilities have been gradually
increasing. Between 2010 and 2015, around 80,000 vulnerabilities were newly registered in the
CVE (Common Vulnerability Enumeration), and the number of vulnerabilities has continued to
rise. While the number of vulnerabilities is increasing rapidly, the response to them relies on
manual analysis, resulting in a slow response speed. It is necessary to develop techniques that
can detect and patch vulnerabilities automatically. This paper introduces a trend of techniques
and tools related to automated vulnerability detection and remediation. We propose an automated
vulnerability detection method based on binary complexity analysis to prevent a zero-day attack.
We also introduce an automatic patch generation method through PLT/GOT table modiﬁcation to
respond to zero-day vulnerabilities.
Keywords: security; vulnerability; automation; fuzzing; symbolic execution
1. Introduction
The number of vulnerabilities is increasing rapidly due to the development of new hacking
techniques. Between 2010 and 2015, around 80,000 vulnerabilities were newly registered in the major
database known as the CVE (Common Vulnerability Enumeration) [1]. In recent years, the scope
of security threats has also been expanded; i.e., IoT [2], Cloud [3], etc. The number of zero-day
vulnerabilities has soared to the point that specialists can no longer be relied upon to respond to
vulnerabilities. In order to respond quickly to a zero-day attack, automated vulnerability detection
and automatic patching processes are necessary. In this paper, we propose a technology that performs
fuzzing and symbolic execution based on binary complexity to automatically detect vulnerabilities.
In addition, we propose an automatic patching technique to modify the GOT/PLT table to patch binary
for a quick response to the attack of an automated vulnerability detection. In Section 2, we analyze
trends and techniques for automated vulnerability detection and automated vulnerability remediation.
In Section 3, we introduce our method that automatically detects vulnerability using a hybrid fuzzing
based on binary complexity analysis and automatic patch vulnerability by loading a safe library
through the GOT/PLT table modiﬁcation. In Section 4, our experimental results are presented. Finally,
in Section 5, we discuss our conclusion and future work.
2. Related Works
2.1. Automated Vulnerability Detection
2.1.1. Fuzzing
Fuzzing is a testing method that causes the target software to crash by generating random
inputs. Fuzzing was ﬁrst introduced by the University of Wisconsin’s Professor Miller Project in
Sustainability 2018, 10, 1652; doi:10.3390/su10051652
www.mdpi.com/journal/sustainability
sustainability# &!*-0+/ .Sustainability 2018, 10, 1652
2 of 12
1988 [4]. The project was promoted to test the reliability of Unix utilities by generating random inputs.
The professor in this project conﬁrmed that arbitrary input values were delivered to the computer
under the inﬂuence of the storm while trying to login remotely to his computer. The program was
terminated due to the unintended input value and this experience evolved into the concept of fuzzing,
which injects random input values into software and causes errors.
Fuzzing is divided into dumb fuzzing and smart fuzzing, and is dependent on input modeling
and divided into Mutation Fuzzing and Generation Fuzzing according to the test case generation
method. Dumb fuzzing is the simplest form of fuzzing technology because it generates defects by
randomly changing the input values to the target software [5]. The test case creation speed is fast
because it is simple to change the input value; however, it is difﬁcult to ﬁnd a valid crash because
the code coverage is narrow. Smart Fuzzing is a technology that generates input values suitable for
the format through target software analysis and the generation of errors [6–9]. Smart fuzzing has
the advantage of knowing where errors can occur through a software analysis. A tester can create
a test case for that point to extend code coverage and generate a valid crash. However, there is
a disadvantage in that it requires expert knowledge to analyze the target software, and it takes a long
time to generate a template suitable for software input. Mutation fuzzing is a test technique to modify
the data samples to enter the target software. Generation fuzzing is a technology that models the
format of the input values to be applied to the target software and creates a new test case for that
format. Recently, an evolutionary fuzzing technique has been introduced that generates new input
values by providing feedback on the target software’s response [10,11].
2.1.2. Symbolic Execution
Symbolic execution is a technique that explores feasible paths by setting an input value to
a symbol rather than a real value. The symbolic execution was ﬁrst published in King’s paper in
1975 [12]. This test technique was developed to verify that a particular area of software may be
violated by the input values. The symbolic execution is largely divided into the ofﬂine symbolic
execution and the online symbolic execution. The ofﬂine symbol execution solves by choosing only
one path to create a new input value by resolving the path predicate [13]. The program must be
executed from the beginning to explore other paths, so there are disadvantages because it causes
overhead due to re-execution. The online symbolic execution is the way in which states are replicated
and path predicates are generated at every point where the symbol executor encounters the branch
statement [14,15]. There is no overhead associated with reissuing using the online method, but the
downside is that it requires the storage of all status information and the simultaneous processing of
multiple states, leading to signiﬁcant resource consumption. In order to solve this problem, the hybrid
form symbol is suggested.
The hybrid symbolic execution saves state information through online symbolic execution
whenever a branch statement is executed and proceeds until memory is exhausted [16]. When there is
no more space to save, a switch to the ofﬂine symbolic execution occurs and a path search is performed.
We have solved the memory overﬂow problem of the online symbolic execution by applying the
method of saving the state information and using it later through the hybrid symbolic execution.
In addition, it solves the overhead of the ofﬂine symbolic execution because it does not need to be
executed again from the beginning. In recent years, the concolic execution, which is a method of testing
by substituting an actual value (Concrete Value) and testing a mixture of symbolic executions, has been
proposed. This technique is a technique of actually assigning a concrete input value and generating
a new input value by solving the path expression when the actual input value meets the branching
statement. The reason for executing the actual value is that if the symbolic executor encounters
a difﬁcult problem and it takes a long time or does not solve the problem, the test can no longer be
performed. However, if the actual value is substituted, a deeper path search becomes possible.
Sustainability 2018, 10, 1652
2.1.3. Hybrid Fuzzing
3 of 12
The hybrid fuzzing method is a technique where the automatic exploitation of vulnerabilities
combines the advantages of fuzzing to generate random input values with the concolic execution
to track the program execution path. The hybrid fuzzing solves the fuzzer incompleteness and the
path explosion problem of the concolic execution. Driller is a typical tool for hybrid fuzzing [17].
The driller uses the fuzzer to search for the initial segment of the program. If the process is stopped by
the conditional statement, the concolic engine is used to guide the next section and the fuzzer takes
over again and searches for vulnerabilities in the deep path more quickly. Driller is a hybrid fuzzing
tool using AFL (American Fuzzy Lop) [9] and Angr [18]. AFL is a fuzzer that generates and transforms
input values through a genetic algorithm and Angr is an engine that performs symbol execution by
converting binary codes into Valgrind’s VEX IR, which is also known by Mayhem and S2E [19] as
the most optimized symbol execution engine. The driller performs fuzzing through the AFL and
calls the concolic execution engine Angr for the purpose of ﬁnding a new state transition path, if the
fuzzer is no longer able to ﬁnd additional state transitions. In this case, the main reason that the fuzzer
cannot ﬁnd the additional state transition path is that it cannot generate speciﬁc input values to satisfy
complex conditional statements in the software. The concolic execution engine that receives the control
right at that point generates the input value, satisfying the complex condition by using the constraint
solver. The generated value is passed to the fuzzer’s queue and the control is also passed to the fuzzer
to perform the fuzzing. The driller can perform this process repeatedly to search for a fast and deep
path. An important factor in determining efﬁciency in this analytical ﬂow is the avoidance of the path
explosion, which is a limiting point inherent in the concolic execution. This is because the limited
execution path is analyzed by the input value generated through the fuzzing. The tools and features
related to automated vulnerability detection techniques are shown in the Table 1.
Table 1. Automated Vulnerability Detection Tool Comparison.
Technique
Fuzzing
Symbolic Execution
Hybrid Fuzzing
Tool
Zzuf
AFL
Peach
Angr
KLEE
S2E
Testing
Blackbox
Blackbox
Blackbox
Whitebox
Whitebox
Whitebox
Mayhem Whitebox
Greybox
Driller
Input Generation Strategy
Mutation Algorithm
Genetic Algorithm
Format Modeling
Stepping
Random Path
Search Heuristics
Hybrid
Selective
2.2. Automated Vulnerability Remediation
2.2.1. Binary Hardening
Binary Hardening can be divided into OS-level memory hardening technologies and
Compiler-level binary reinforcement technologies. First, OS-level memory-enhancing technologies
include ASLR (Address Space Layout Randomization), DEP (Data Execution Prevention/Not
Executable), and ASCII—Armor. The ASLR is a technique that provides an Image Base value randomly
when a program is mapped to a virtual memory. It is a security technique that prevents attacks by
making it difﬁcult for attackers to ﬁgure out the memory structure of the target programs. DEP/NX
is a technology to prevent code from being executed in data areas such as stacks and heaps. It limits
the execution authority over the stack or heap area, thereby preventing attacks. ASCII—Armor
is a technology that protects a shared library space from the buffer overﬂow attacks by inserting
NULL(\x00) bytes in the top of its address. The inserted NULL bytes make it impossible to reach
the address.
Sustainability 2018, 10, 1652
4 of 12
The technologies that are applicable to the compilers are PIE (Position Independent Executable),
SSP (Stack Smashing Protector), and RELRO (Relocation Read-Only. First, PIE is a technology that
is similar to the ASLR provided by the operating system to apply the logical addresses during the
compilation so that the addresses mapped to the virtual memory are random each execution time.
The difference with ASLR is that the ASLR applies the random address to the stack, heap, and shared
library space of the memory area and the PIE applies the logical addresses in binary to randomization.
A SSP is a technique to prevent an attack that can overwrite SFP (Saved Frame Pointer) by inserting
a speciﬁc value (Canary) for monitoring into the stack, especially between the buffer and SFP. In case
of a buffer overﬂow attack, to overwrite the SFP, an attacker also overwrites the canary so that the
monitoring modulated canary detects the buffer overﬂow attack. Finally, the RELRO is a technology to
protect memory from being changed by making the ELF binary or data area of the process read-only.
There are two types of methods, partial RELRO and full RELRO, depending on the state of the GOT
domain. Although partial RELRO with a writable GOT domain can consume less resources and
execute faster than full RELRO, it is vulnerable to attacks such as a GOT overwrite. On the other hand,
full RELRO with a read-only GOT domain consumes more resources and is slower than the partial
RELRO, but it could prevent the attack using the GOT domain. Features related to binary hardening
techniques are shown in the Table 2.
Table 2. Binary Hardening technique comparison.
Hardening Level
Hardening Technique
Protected Area
Hardening Method
OS-Level Hardening
Compiler-Level Hardening
ASLR
DEP
ASCII-Armor
PIE
SSP
RELRO
Stack, Heap, Library
Stack, Heap
Library
Randomize image base
Prevent code execution
Insert Null byte
All
Stack
GOT
Randomize logical address
Insert value detecting overﬂow
Create read-only data area
2.2.2. Automatic Patch Generation
A major technology for automatic patch generation is generating patches using genetic algorithms.
Genprog, announced in 2009, is the technology that has had the biggest impact on studies on
automated patching [20]. Genprog a technique to automatically patch C language-based programs.
After converting the source code structure of the target software to AST (Abstract Syntax Tree),
it patches the anomaly node with three modiﬁcations; delete, add, and replace. To modify nodes,
it uses templates for each error. According to the study, 55 of the 105 common bugs were modiﬁed,
and vulnerabilities such as Heap Buffer Overﬂow, Non-Overﬂow Dos, Integer Overﬂow, and Format
String vulnerability were patched.