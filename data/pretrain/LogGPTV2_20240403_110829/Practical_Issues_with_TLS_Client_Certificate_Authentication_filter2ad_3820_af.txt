### 优化后的文本

#### 9. 客户端证书吊销检查
SK颁发的认证证书的有效性可以通过CRL（每12小时发布一次）或通过SK提供的付费OCSP服务进行验证。

为了测试服务提供商是否对由两个SK中间CA颁发的客户端证书执行吊销检查，我们使用了两位作者的两种客户端证书：由SK中间CA ESTEID 2007颁发的身份证证书和由SK中间CA ESTEID 2011颁发的Digi-ID4证书。

- 如果证书被吊销后立即拒绝访问，我们认为该服务提供商使用了OCSP。
- 如果在CRL中出现被吊销证书的序列号后才拒绝访问，我们认为该服务提供商使用了CRL。
- 如果在下一个CRL的`nextUpdate`时间到达后仍能成功认证，我们认为该服务提供商未执行任何吊销检查（标记为“–”）。

对于某些服务提供商网站，我们没有账户，因此无法测试登录后是否在应用层执行吊销检查。在这种情况下，行中标记为问号。

我们在pensionikeskus.ee和emu.ee的服务提供商上观察到一种奇怪的行为：当我们的身份证证书被吊销时，使用Digi-ID证书的访问也被服务提供商拒绝。我们怀疑这些服务提供商使用LDAP而不是OCSP来检查证书吊销状态。根据ESTEID认证策略[38]，SK LDAP目录仅包含有效的未过期证书，因此可以使用LDAP来检查证书状态。然而，这些服务提供商显然在LDAP搜索查询中使用固定的`organizationName`字段来检查是否有任何ID卡认证证书存在，而不比较LDAP中的证书与收到的客户端证书。实际上，更多标记为“OCSP”的服务提供商可能也使用LDAP进行吊销检查。

使用LDAP进行吊销检查除了CRL和OCSP外还有安全优势，因为它不仅验证证书的序列号，还验证整个证书。这允许检测使用合法证书序列号签发的伪造证书，如DigiNotar事件[28]所示。然而，由于SK LDAP流量未受加密保护[39]，它可能受到MITM攻击，因此不可信。

#### 握手超时强制执行测试
在测试握手超时强制执行时，我们观察到apollo.ee、energia.ee、laen.ee、osta.ee和tlu.ee的服务提供商在接近CRL的`nextUpdate`时间之前关闭了TCP连接。显然，这些服务提供商在更新CRL后进行了非优雅的Apache重启。

#### 其他观察
我们没有观察到任何服务提供商使用`window.crypto.logout()`来实现CCA注销功能。

seb.ee是唯一一个在我们注销并尝试重新登录时能够检测到正在使用先前登录建立的TLS CCA会话的服务提供商。然而，该服务提供商仍然无法清除服务器端的TLS会话，并要求用户重启浏览器以重新认证。

我们观察到ehis.ee、g4s.ee、hinnavaatlus.ee、iizi.ee、nordea.ee、ox.ee、parkimine.ee、tbb.ee和ttu.ee的服务提供商不支持TLS重新协商指示扩展[37]，该扩展修复了TLS重新协商漏洞（CVE-2009-3555）。

#### 我们的建议
##### 对于服务提供商
对于部署当前可用选项的TLS CCA的服务提供商，我们建议：
- 确保`SSLCACertificateFile`中没有多余的CA证书。
- 在`SSLCADNRequestFile`中指定直接颁发客户端证书的CA证书。
- 在应用层进行额外检查，以验证客户端证书是否由预期的中间CA颁发（至少验证客户端证书的颁发者名称）。
- 将`SSLVerifyDepth`约束配置为最小值。
- 在目录上下文中指定`SSLVerifyClient`指令，以便在重新协商时执行TLS CCA，从而保护客户端证书的隐私。
- 正确使用Apache模块（如mod_reqtimeout）来强制执行CCA握手超时。
- 执行客户端证书吊销检查，如果使用LDAP，则将客户端证书的完整内容与LDAP目录中的内容进行比较。
- 使用Firefox特定的`window.crypto.logout()`函数和Chrome的工作区来实现CCA注销功能。
- 在mod_ssl提供良好的TLS CCA审计功能之前，禁用提供完美前向保密的密码套件（除非前向保密比审计跟踪更重要），并保存TLS流量的数据包捕获。
- 对于高度敏感的服务，将认证会话绑定到TLS CCA（尽管这会因mod_ssl中的bug而产生负面影响）。

同时，我们鼓励全球的服务提供商实施无PKI的TLS CCA选项，如第三节J部分所述。

##### 对于mod_ssl开发者
作为相对简单的改进，应修复mod_ssl的bug [7]、[8] 和 [13]，并将本文指出的其他未记录问题反映在官方mod_ssl文档[5]中。

接下来，我们建议对mod_ssl进行重新设计，以提供灵活且简单安全的配置，适用于大多数TLS CCA使用场景。我们建议为`SSLVerifyClient`配置指令设置三个值：
- `none` - 不需要CCA（当前`none`行为）
- `require_success` - 要求成功的CCA或TLS握手失败（当前`require`行为）
- `require_any` - 可选地请求任何客户端证书

`SSL_CLIENT_VERIFY_RESULT`环境变量应基于验证结果设置为`NONE`、`SUCCESS`或`FAILED:reason`（验证必须在第一个错误时失败以减少DoS攻击向量）。

此外，证书链构建过程应在信任存储中达到任何加载的证书时成功。这将允许使用特定的中间CA证书进行验证，并通过将它们直接存储在信任存储中来授权特定的客户端证书。

`SSLVerifyClient`值`require_success`对于封闭部署非常有用，在这种部署中不应处理未经身份验证的HTTP请求。另一方面，`require_any`值为应用程序提供了在CCA失败时提供个性化错误消息的机会，同时也允许客户端证书仅用于传输公钥，其真实性通过带外机制（无PKI的CCA）建立。

为了启用TLS CCA重新认证，我们建议引入一个特殊的响应头（例如`X-TLS-Reset`），如果服务器端应用程序设置了该响应头，则mod_ssl将在返回响应后删除关联的TLS会话。

最后，应用层应能够访问指定TLS CCA过程中证明新鲜度的时间戳以及用于验证过程的证书链。如第三节H部分所述，解密的TLS握手消息的日志记录也应实现。

##### 对于浏览器供应商
本研究中分析的浏览器供应商可以通过以下方式轻松提高TLS CCA的安全性和可用性：
- 显示警告信息，告知初始协商时请求客户端证书会导致隐私泄露。
- 如果TLS CCA握手失败，则清除缓存的客户端证书选择（适用于Firefox和IE）。
- 在发送大型HTTP POST请求时使用`Expect: 100-continue`机制。
- 将上次使用的客户端证书作为默认证书选择显示在客户端证书选择窗口中。

更大的挑战是标准化JavaScript API，这可以单独用于：
- 从客户端删除TLS会话缓存，从而支持后台客户端证书重新认证（作为服务器端`X-TLS-Reset`机制的替代方案）。
- 忘记浏览器缓存的客户端证书选择，从而提供TLS CCA注销功能。

此外，我们鼓励扩展HTTP严格传输安全策略[34]机制，以支持强锁定同源策略。

#### 相关工作
Ristic在其SSL Labs研究项目[40]中提出了TLS部署的最佳实践，给出了TLS服务器评级指南，并对互联网上的TLS服务器部署进行了调查。然而，他的工作并未涵盖TLS CCA方面的问题。

Hess等人在[41]中描述了与CCA相关的TLS协议限制。虽然这些问题在特定使用场景中可能是限制因素，但它们并不是日常TLS CCA使用的绊脚石。该研究中列举的一些限制，如客户端证书披露，可以通过本文所述的重新协商轻松解决。

Dietz等人在其工作中[42]列出了TLS CCA在当今网络中不起作用的原因。我们认为，除了可移植性问题外，所有列出的问题都可以通过本文提供的建议来解决。

Fahl等人在[43]和Georgiev等人在[44]中进行了大规模研究，研究了非浏览器软件如何验证TLS服务器证书。相比之下，我们关注的是服务器端软件如何验证证书以认证客户端。

#### 结论
本文描述了与实际使用TLS CCA相关的一些问题，并提供了一份可以在应用层实现而无需更改TLS协议的解决方案列表。尽管本研究表明TLS CCA实现仍有改进空间，但爱沙尼亚的例子表明，建立互联网上的安全用户身份是有解决方案的，并且这一解决方案在实践中是可行的。我们希望本文提供的改进建议能在相关社区得到支持，从而推动TLS CCA的大规模使用。

#### 致谢
我们要感谢Dominique Unruh、Peter Gutmann、Ivan Ristic、Tiit Pikma、Martin Paljak (CERT-EE)和匿名审稿人对本文的反馈。

本研究得到了欧洲区域发展基金通过爱沙尼亚计算机科学卓越中心（EXCS）、爱沙尼亚国家选举委员会和爱沙尼亚信息技术博士学校（IKTDK）的支持。

#### 参考文献
[此处省略参考文献]

希望这些优化使文本更加清晰、连贯和专业。如果有进一步的修改需求，请告诉我！