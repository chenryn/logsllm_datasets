icate is built from two different attribute variables and constants,
e.g., s.cleareance ≥ o.classif ication, s.credit ≥ o.value,
(s, r) ∈ o.acl, where o.acl is the object o’s access control list.
Note that the attributes in a predicate can be from a single subject
or object, or one subject and one object.
2.2.4 Primitive Actions
A protection system evolves by the activities of the subjects, such
as requesting and performing one or a sequence of accesses, which
in turn may generate new objects in the system, or update the val-
ues of attributes corresponding to a set of usage control policies
(deﬁned shortly). Three kinds of primitive actions are deﬁned in
UCONA.
DEFINITION 3. A primitive action (or simply action) is a state
transition of a system. Three primitive actions of UCONA are de-
ﬁned as in the Figure 1, where t = (O, σ) and t(cid:48) = (O(cid:48), σ(cid:48)) are
the states before and after a single primitive action.
A createObject action introduces a new object into the sys-
tem, and requires that the new object not be in the system before
the creation. Each attribute of the newly created object has the
default value of null. Normally a createObject is followed by
updateAttribute actions to assign values to its attributes. The
destroyObject removes an existing object and its attributes from
the system. For simplicity we assume that the identity of an object
is unique during the system’s life cycle, and cannot be reused even
after the object is destroyed. The updateAttribute action updates
the value of an attribute o.a from v to the new value v(cid:48) which can
be a constant, or the result generated by a polynomially computable
function built from the old value v and other attribute values of the
subject and object parameters of the policy.
Although all these primitive actions are actually performed by
the system, they are the results of the accesses performed by sub-
jects. External actions or events of a system are not directly cap-
tured in UCONA. For example, in an online reading application,
the decrease of a credit after a user reads a chapter is an update
action captured by the UCONA model, while the increase of the
user’s total credit amount with a credit card payment is an exter-
nal event, and is not regarded as an action in the system. To capture
these external events, UCONA will need to be extended with an ad-
ministrative model. The safety question investigated in this paper
is therefore in absence of an explicit administrative model.
2.2.5 UCONA Policy
Satisﬁed predicates on attributes in UCONA affect the system
in two ways. First, a set of satisﬁed predicates can authorize a
permission so that a subject can access an object with a particular
right. Second, a set of satisﬁed predicates may authorize the system
to move to a new state with a sequence of actions, e.g., by creating a
new object, or updating attribute values. These actions, in turn, may
make other predicates satisﬁed, and then enable other permissions
and system state changes. The safety analysis of UCONA focuses
on the interactions between these two aspects, e.g, the permissions
authorized by a system state and the state changes caused by the
actions.
Access authorizations and the state transitions are speciﬁed by a
set of pre-deﬁned policies.
DEFINITION 4. A policy of UCONA consists of a name, two
parameter objects, an authorization rule, and a sequence of primi-
tive actions as follows:
policy name(s, o):
p1 ∧ p2 ∧ ··· ∧ pi → permit(s, o, r)
act1; act2; . . . ; actk
Actions
createObject o(cid:48)
Conditions
o(cid:48) /∈ O
destroyObject o
updateAttribute:
o.a = v(cid:48)
o ∈ O
o ∈ O, a ∈ AT T
v(cid:48) ∈ dom(a) ∪ {null}
New States
O(cid:48) = O ∪ {o(cid:48)}
∀o ∈ O, a ∈ AT T, σ(cid:48)(o.a) = σ(o.a)
∀a ∈ AT T, σ(cid:48)(o(cid:48).a) = null
O(cid:48) = O − {o}
O(cid:48) = O
∀ent ∈ O, att ∈ AT T , σ(cid:48)(ent.att) = σ(ent.att) if ent (cid:54)= o and att (cid:54)= a
σ(cid:48)(o.a) = v(cid:48)
Figure 1: Primitive actions in UCONA
where s and o are the subject and object parameters; p1, p2, . . . , pi
are predicates based on s’s and o’s attributes and constants;
permit(s, o, r) is a predicate which indicates that a permission
(s, o, r) is authorized by the system if true; act1, act2, . . . , actk
are primitive actions that are performed on s or o or their at-
tributes.
We assume that s is the active object in a policy, so it is the
subject that attempts an operation requiring the right r on the target
object o.
A policy includes two parts. The ﬁrst part is an authorization
rule consisting of a conjunction of attribute predicates, called the
condition of the policy, followed by a permit predicate implied by
the condition. The second part is a sequence of primitive actions,
called the body of the policy. The ﬁrst part speciﬁes a permission
authorized by the state of the system, while the second part is the
side-effect of executing this permission, thereby changing the state
of the system. Note that there may be policies that have no actions
but only authorization rules, which cause no state transitions. In
any state, a permission that is not permitted explicitly by a policy
is denied by default. In general the UCONA model only considers
positive permissions.
Instead of specifying the individual state changes in a single us-
age process, the policy-based formalization speciﬁes the overall ef-
fects on the system state for a usage process. This approach cap-
tures the essential aspect of system state transitions and permission
propagations caused by the attribute mutability of UCON, while
maintaining the simplicity of policy speciﬁcations.
Note that by the policy deﬁnition we assume that all the autho-
rization predicates in a policy are considered as pre-authorizations,
and all the updates as post-updates. That is, the UCONA model de-
ﬁned in this section is preA3. As all usage processes are serialized
in a UCONA system, and a policy captures the overall effects of
the system state after a usage process, the updates in a policy can
also be considered as pre-updates or ongoing updates, which would
make the model preA1 or preA2, respectively. All safety results in
this paper derived for preA3 also hold for preA1 and preA2. For
the sake of simplicity, we assume, without loss of generality, that
the UCONA model considered in this paper is a preA3 model.
DEFINITION 5. A policy is a creating policy if it contains a
createObject action in its body; otherwise, it is non-creating.
A policy is enforced when an access requested is generated. There-
fore, at least one of its parameters exists in the system before the
request, and a creating policy can contain one createObject ac-
tion at most. Without loss of generality, we assume that in a creat-
ing policy, the ﬁrst parameter s, which is the unique parent object,
must exist before the actions, and o is created as a child object.
Without loss of generality, we can also assume that in a policy,
there is at most one update action for any attribute of an object,
since multiple updates on the same attribute can be reduced to a
single update with the value in the last one. Negation is not explic-
itly required since we can always deﬁne a new predicate equivalent
to a negated one. For example, instead of ¬(s.credit > $1000),
we use (s.credit ≤ $1000). Similarly, disjunction of predicates is
not explicitly required since it can be expressed by a set of individ-
ual policies, one for each component of the disjunction.
A policy is enforced by replacing the two parameters with a pair
of actual subject and object names when the subject generates an
access request on the object with a particular right. If the condi-
tion of the policy and all conditions for each primitive action are
satisﬁed, then the permission is granted, and all the primitive ac-
tions are performed. Otherwise, the permission is not granted, and
the system does not change state. As we assume that all accesses
are serialized, and the enforcement of each policy is atomic, either
an access is granted and all primitive actions are completed, or the
system state does not change.
EXAMPLE 3. Suppose that a document can only be issued by a
scientist (with role sci). For anonymous users, this document can
only be read 10 times. We deﬁne the available times (readT imes)
as an object attribute. Each time an anonymous user is authorized
to read a document, this attribute is updated by decreasing it by
one. The policies in this application are:
create doc(s, doc):
(s.role = sci) → permit(s, doc, create)
createObject doc
updateAttribute: doc.readT imes = 10
read doc(s, doc):
(s.role = anonymous)∧ (doc.readT imes > 0) →
permit(s, doc, read)
updateAttribute:
doc.readT imes = doc.readT imes − 1
The ﬁrst creating policy speciﬁes that a subject with role of sci
can create a new document, and the readT imes attribute of this
new object is set to 10. In the second policy, a subject with role
anonymous can be authorized to read a document if its readT imes
attribute is positive; as a result of this permission, readT imes is
decreased by one.
2
2.2.6 UCONA Protection System
A formal representation of a UCONA system can be deﬁned with
the basic components that we have introduced.
DEFINITION 6. A UCONA scheme is a 4-tuple (AT T, R, P, C),
where AT T is a ﬁnite set of attribute names, R is a ﬁnite set of
rights, P is a ﬁnite set of predicates, and C is a ﬁnite set of poli-
cies. A UCONA protection system (or simply system) is speciﬁed
by a UCONA scheme and an initial state (O0, σ0).
DEFINITION 7. Given a UCONA system, the permission func-
tion of a state t = (O, σ) is ρt : O × O → 2R, and if r ∈ ρt(s, o),
then in the state t, the subject s can access the object o with the
right r.
The function ρt maps a pair (subject, object) to a set of generic
rights, according to their attribute-value assignments in the state t
and the set of policies in the scheme. In a particular state, the value
of ρt(s, o) can be determined by trying each policy in the scheme
with the attribute-value assignments of s and o. With the ﬁnite
number of predicates in a policy and the ﬁnite number of policies
in a scheme, the complexity of computing ρt for each pair (s, o) is
O(|P| × |C|).
DEFINITION 8. For two states (Ot, σt) and (Ot(cid:48) , σt(cid:48) ) of a sys-
tem:
• t 
c t(cid:48) (c ∈ C) if there exist a pair of objects (o1, o2)
(o1 ∈ Ot) such that the policy c(o1, o2) can be enforced in
the state t and the system state changes to t(cid:48);
• t 
C t(cid:48) if there exist a c ∈ C such that, t 
c t(cid:48);
• t C t(cid:48) if there exist a sequence of states t1, t2, . . . , tn such
that t 
C t1 
C t2 ··· 
C tn 
C t(cid:48).
A transition history from state t to state t(cid:48) is denoted as t C t(cid:48),
or simply t  t(cid:48).
3. SAFETY UNDECIDABILITY IN UCONA
In a UCONA system, the safety question asks whether or not,
from an initial state of the system, a subject can obtain a permission
on an object after a sequence of enforced policies, i.e., by updating
attributes and creating/destroying objects. In this section we show
that the safety problem for a general UCONA model is undecidable
by reducing it to the halting problem of a general Turing machine.
THEOREM 1. The safety problem of a UCONA system is unde-
cidable.
Proof Sketch. A general Turing machine with one-directional sin-
gle tape [17] can be simulated with a UCONA system, in which a
particular permission leakage corresponds to the accept state of the
Turing machine. A construction similar to the undecidability proof
of the access matrix model [5] is used. Speciﬁcally, the tape in a
Turing machine is simulated with a set of objects, and a set of ob-
ject attributes is deﬁned to indicate the Turing machine’s state, the
content in each cell, and the cell that the head is scanning. A set of
UCONA policies is deﬁned to simulate the state transition function
of the Turing machine. As for a Turing machine, it is undecidable
to check if its accept state can be reached from the initial state.
Therefore, with the scheme of simulating UCONA, the granting of
the particular permission of a subject to an object is also undecid-
able. This proves the safety undecidability of UCONA. The full
construction is presented in the Appendix.
2
4. SAFETY DECIDABLE UCONA MODELS
Since the safety of the general model is undecidable, in this sec-
tion we study the safety property of UCONA models with some re-
strictions. First we prove that a model with ﬁnite attribute domains
and without creating policies is safety decidable. Then we relax
this restriction by allowing restricted creating policies and obtain a
more general decidable model. Finally we illustrate the expressive
power of these decidable models.
4.1 Safety Analysis of UCONA without Cre-
ation
In a UCONA system, if the value domain for each attribute is
ﬁnite, then each object has a ﬁnite number of attribute-value as-
signments. Furthermore, if the system does not have any creating
policies, then the set of all possible objects in a system state is also
ﬁnite and ﬁxed, and therefore the total number of possible states of
the system is ﬁnite, and the safety problem can be checked in the
ﬁnite set of system states. This leads to the following result.
THEOREM 2. The safety problem of a UCONA system is decid-
able if:
1. the value domain of each attribute is ﬁnite, and
2. there are no creating policies in the scheme.
Proof. The total number of states of the system is ﬁnite and
bounded a-priori since there are no new created objects and each
object has only a ﬁnite number of attribute-value assignments. The
safety problem is reduced to the reachability problem of a ﬁnite
state machine, which is decidable.
Let the system be speciﬁed by a scheme (AT T, R, P, C) and
an initial state t0 = (O0, σ0). We consider the safety check of a
permission (s, o, r) in the following analysis.
A system state t is characterized by a set of attribute assignments
{o.a = v|o ∈ O, a ∈ AT T, v ∈ dom(a) ∪ {null}}, where
O ⊆ O0. (Note that destroy actions are allowed, hence O is a sub-
set of O0.) Since O0 is ﬁnite, and all the domains for the attributes
in AT T are ﬁnite, the set Q of all possible states of the system is
ﬁnite. With this state set, we construct a deterministic ﬁnite au-
tomaton FA = (Q, Σ, δ, q0, Qf ) to show that the safety problem
is decidable. The FA consists of:
• the ﬁnite set of states Q = {t|t = (O, σ), O ⊆ O0}.
• the alphabet Σ = C × O0 × O0.
• the transition function δ : Q × Σ → Q.
• the start state q0 = t0.
• the accept states Qf = {t|r ∈ ρt(s, o)}, a (sub)set of states
in which (s, o, r) is authorized by a policy with the corre-
sponding attribute values of s and o.
The state transition function in FA can be constructed through
the following algorithm:
1. For a state t = (O, σ), an object pair (o1, o2), and a policy
c, if o1 ∈ O and o2 ∈ O, and the all the predicates in c are
true with the attribute-value assignments of o1 and o2 in t
(that means, the permission in c is authorized in this state),
and all the conditions of the actions in c are satisﬁed, do the
following: