2
3
int m;
4
intTR2[MAXSIZE+1];
5
if（s==t)
6
TRL[s]=SR[s];
7
else
8
9
m=（s+t）/2;/*将SR[s..t]平分为SR[8..m]和SR[m+1..t]/
10
MSort（SR，TR2，8，m）;/*通归a将SR[s..m]归并为有序的TR2[s..m]*/
11
MSort（SR，TR2，m+1,t）/*递归将SR[m+1..t]归并为有序TR2[m+1..t]*/
12
Merge（TR2,TR1，s，m,t）:/*将TR2[s..m]和TR2[m+1..t]*/
/*归并到TR1[8..t]*/
13
/
141
1.MSort被调用时，SR与TR1都是{50,10,90,30,70,40,80,60,20}，s=1，t=9，最
终我们的目的就是要将TR1中的数组排好顺序。
2.第5行，显然s不等于t，执行第8~13行语句块。
3.第9行，m=（1+9）/2=5。m就是序列的正中间下标。
4.此时第10行，调用“MSort（SRTR2,1,5）：”的目标就是将数组SR中的第
1~5的关键字归并到有序的TR2（调用前TR2为空数组），第11行，调用
“MSort（SRTR2,6,9）：的目标就是将数组SR中的第6~9的关键字归并到
有序的TR2。也就是说，在调用这两句代码之前，代码已经准备将数组分成了
注”：电可以不用递如实现，后西有提及。
408
---
## Page 433
第9章排序
两组了，如图9-8-2所示。
下标
SR
50
10
TR2
10
903070
40806020
图9-8-2
5.第12行，函数Merge的代码细节一会再讲，调用“Merge（TR2,TR1,1,5,
9）：的目标其实就是将第10和11行代码获得的数组TR2（注意它是下标
为1~5和6~9的关键字分别有序）归并为TR1，此时相当于整个排序就已
经完成了，如图9-8-3所示。
下标
TR2
10
30
70
90
20
TR1
1020304050607080
90
图9-8-3
6.再来看第10行递归调用进去后，s=1，t=5，m=（1+5）/2=3。此时相当于将
5个记录拆分为三个和两个。继续递归进去，直到细分为一个记录填入TR2，
此时s与t相等，递归返回，如图9-8-4的左图所示。每次递归返回后都会执
行当前递归函数的第12行，将TR2归并到TR1中，如图9-8-4的右图所
示，最终使得当前序列有序。
5010903070
501090
3070
10
50
5010
30
70
10
30
70
50
10
103050
70
图 9-8-4
7.同样的第11行也是类似方式，如图9-8-5所示。
409
---
## Page 434
80
40
80
60
20
80
20
60
40
80
60
20
20
40
60
80
图9-8-5
8.此时也就是刚才所讲的最后一次执行第12行代码，将[10.30,50.70,90}与
{20,40,60,80）归并为最终有序的序列。
可以说，如果对递归函数的运行方式理解比较透的话，MSort函数还是很好理解
的。我们来看看整个数据变换示意图，如图9-8-6所示。
下标
1
2
501090307040806020
30
70
40
20
50
3070
40
80
10
90
30
70
80
50
06
80
0
30
102030405060
图9-8-6
现在我们来看看Merge函数的代码是如何实现的。
/将有序的SR[i..m]和SR[m+1..n]归并为有序的rR[i..n]*/
void Merge（int SR[],int TR[1,int i,int m,int n)
2
intj,k,l;
410
---
## Page 435
第9章排序
4
for（j=m+1,k-i:iSR[]，执
411
---
## Page 436
大话
行第9行，TR[k]=TR[2]=20，并且j++，如图9-8-8所示。
下标
SR
TR
20
图 9-8-8
5.再次循环，k++得到k=3，SR[1]=SR[2]=30，SR[]=SR[7]=40，SR[i]length*sizeof（int））：/*中请额外空间*/
intk=l;
while (klength)
6
7
MergePass（L->r,TR,k,L->length);
k=2*k;
1子序列长度加倍·/
9
MergePass（TR,L->r,k,L->length);