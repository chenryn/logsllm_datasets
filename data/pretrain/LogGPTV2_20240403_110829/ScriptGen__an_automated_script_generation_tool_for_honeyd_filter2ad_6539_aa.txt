title:ScriptGen: an automated script generation tool for honeyd
author:Corrado Leita and
Ken Mermoud and
Marc Dacier
ScriptGen: an automated script generation tool for honeyd
Corrado Leita, Ken Mermoud, Marc Dacier
Institut Eurecom
Sophia Antipolis, France
{leita,mermoud,dacier}@eurecom.fr
Abstract
Honeyd [14] is a popular tool developed by Niels Provos
that offers a simple way to emulate services offered by sev-
eral machines on a single PC. It is a so called low interaction
honeypot. Responses to incoming requests are generated
thanks to ad-hoc scripts that need to be written by hand. As
a result, few scripts exist, especially for services handling
proprietary protocols. In this paper, we propose a method
to alleviate these problems by automatically generating new
scripts. We explain the method and describe its limitations.
We analyze the quality of the generated scripts thanks to
two different methods. On the one hand, we have launched
known attacks against a machine running our scripts; on the
other hand, we have deployed that machine on the Internet,
next to a high interaction honeypot during two months. For
those attackers that have targeted both machines, we can
verify if our scripts have, or not, been able to fool them. We
also discuss the various tuning parameters of the algorithm
that can be set to either increase the quality of the script or,
at the contrary, to reduce its complexity.
1 Introduction
Honeypots have recently received a lot of attention in
the research community. They can be used for several pur-
poses, ranging from the capture of zero-day attacks to the
long term gathering of data. Honeyd [14] is one of the
simplest and most popular solutions.
It has been exten-
sively used, for instance, in the Leurre’com project where
dozens of similar platforms have been deployed in the world
[4, 5, 6, 7, 8, 9]. Unfortunately, Honeyd is based on speciﬁc
scripts that are required to emulate the various services lis-
tening to remote requests. Writing these scripts is a tedious
and sometimes impossible task, especially for proprietary
protocols for which no documentation exists. As a result,
there are not so many existing honeyd scripts. This makes
the ﬁngerprinting of honeyd platforms rather simple and
they do not provide as much information as they could. Had
they more services offered, we would learn more about the
attackers. Our approach aims at generating these scripts au-
tomatically, without having to know anything neither about
the daemon implementing the service, nor about the proto-
col.
In the general case, this is probably impossible to do but
we have a much more modest goal. We want to provide
good answers to requests sent to a honeypot by attack tools.
This dramatically simpliﬁes the problem in the sense that
the requests we need to answer to are generated by deter-
ministic automata, the exploits. They represent a very lim-
ited subset of the total possible input space in terms of pro-
tocol data units. They also typically exercise a very limited
number of execution paths in the execution tree of the ser-
vices we want to emulate.
Keeping this very speciﬁc application domain in mind,
we have developed a three steps approach to generate our
scripts:
1. We put a real machine on the Internet, as a honeypot,
and we record all trafﬁc to and from that machine in
a tcpdump ﬁle. If the machine gets compromised, we
stop the experiment and clean it (i.e. reinstall it).
2. We analyze thanks to various techniques the sequences
of message exchanges between clients and servers. We
derive from this analysis a state machine that repre-
sents the observed requests and replies. We have one
state machine per listening port.
3. We derive from that state machine a honeyd script that
is able to recognize incoming packets and provide a
suitable answer.
Of course, as we will see in the paper, such an approach can
only offer an approximation of the real services. However,
for those interested in studying the attacks thanks to honey-
pots, the more packets they can exchange with the attackers,
the more information they have at their disposal to identify
the attack. Therefore, for that speciﬁc application domain,
we believe that the ability to automatically generate scripts
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
1
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:13:11 UTC from IEEE Xplore.  Restrictions apply. 
for all classical services that are targeted by the attackers
constitutes a major improvement to existing low interaction
honeypots such as honeyd.
To present our method, the paper is structured as follows.
Section 2 presents the method as well as the various algo-
rithms designed and implemented to generate the scripts.
Section 3 offers a discussion of the expected quality of the
simulation with respect to the price we are ready to pay in
terms of complexity of the script. Section 4 provides the re-
sults of experiments run during two months to validate the
method. Finally, Section 5 concludes the paper.
2 ScriptGen
2.1 Overview
ScriptGen can be described by four functional modules,
represented in ﬁgure 1:
• Message Sequence factory. This module is respon-
sible for extracting messages exchanged between a
client and a server from the tcpdump ﬁle. A no-
tion of sequence can be given for different protocols
(e.g. UDP, or IP-only based protocols); here we fo-
cus on TCP-based protocols. This module reconstructs
TCP streams, correctly handling retransmissions and
reordering.
• State Machine Builder. These messages are used as
building blocks to build a state machine. At this point,
it can lead to the generation of a very large, redundant
and highly inefﬁcient state machine. It is usually re-
quired to control the complexity growth by deﬁning
thresholds that limit the number of outgoing edges of
each state. In such case, clearly, the execution of the
script may reach a state where it may not be able to
reproduce perfectly the behavior of the real server.
• State Machine Simpliﬁer. This is the core of Script-
Gen. This module is responsible for analyzing the
“raw” state machine and for introducing some sort of
semantics. This is achieved thanks to two distinct al-
gorithms interacting with each other. The ﬁrst one, the
PI algorithm, is taken from [3] and described in Sub-
section 2.4.1. The second one is a novel contribution
of this paper. We call it the Region Analysis algorithm
and we explain it in Subsection 2.4.2. As a result, we
obtain a much simpler state machine where incoming
messages are not recognized as simple sequences of
bytes but instead as sequences of typed regions that
must fulﬁll certain properties.
• Script Generator. This last module is responsible for
creating a honeyd-compatible script from the simpli-
ﬁed state machine.
2.2 Message Sequence Factory
A message sequence is an ordered list of messages. A
message is seen as a piece of the interaction between the
client and the server. More formally, a message is deﬁned
as the longest consecutive set of bytes going in the same
direction (e.g. client to server or vice versa). A TCP ses-
sion can be decomposed into a list of messages. That list
represents the observed dialog between the client and the
server. The length of a sequence is deﬁned as the number of
messages sent either by the client or the server.
Many solutions have been deployed to efﬁciently re-
assemble TCP packets. For instance, responders like iSink
[15] are built as a Click kernel module [11] in order to use
a fast ﬂow reassembler, while another possible solution is
used in [13] and consists in directly using an existent IDS.
We did not use any of those solutions and decided to imple-
ment our own to easily customize it to our needs.
2.2.1 Rebuilding TCP sequences
One of the ﬁrst design problems is to deﬁne an optimized
algorithm to parse the tcpdump ﬁle and rebuild the conver-
sation between clients and server, correctly handling du-
plicated and out-of-order packets. We have to take into
account the fact that the client may not respect the classi-
cal TCP state machine in order, for instance, to implement
IDS evasion techniques. Therefore, ScriptGen rebuilds TCP
ﬂows on the basis of the following assumptions:
• A packet is interesting only if it’s carrying a payload.
Every pure-ACK packet, for instance, is ignored by
ScriptGen. Retransmissions are also ignored. Only
packets containing a TCP payload are considered.
• A TCP session starts with the ﬁrst SYN packet. For
every new SYN packet, ScriptGen allocates all the data
structures necessary to handle the new ﬂow.
• A TCP session ends with the ﬁrst FIN/RST packet en-
countered. When one of the two communicating par-
ties decides to end the conversation, the conversation
is considered ﬁnished.
• The TCP sequence number is used as an index of an
array where we store the payload. This enables Script-
Gen to handle out of order packets as well as retrans-
missions. In that last case, the very ﬁrst packet is ac-
cepted. Following ones are discarded.
We acknowledge the fact that these assumptions may cause
trouble in the general case. For instance, packet checksum
is not computed and therefore transmission errors are not
detected; also, incorrect sequence numbers in the IP header
may lead to the allocation of huge amounts of memory.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
2
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:13:11 UTC from IEEE Xplore.  Restrictions apply. 
t
t
l
P
M
por
oco
ro
F
e
a
s
c
s
t
a
o
T
C
P
D
U
M
P
e
y
g
r
ona
t
l
i
Addi
ers
t
Fil
S
S
R
M
u
e
e
e
e
q
q
q
s
u
u
s
e
e
e
a
s
n
g
n
c
t
e
c
e
e
s
M
S
B
u
i
d
e
l
mum
ax
i
M
y
ex
omp
t
i
l
C
ousparams
ar
M
i
V
S
s
o
res
)
ld
h
(Th
S
C
S
p
o
t
a
m
t
e
e
l
M
x
a
c
h
i
n
e
r
S
S
i
t
m
a
t
i
ﬁ
e
r
l
i
ﬁ
M
e
a
d
c
h
i
n
e
Figure 1. General structure
Nevertheless, based on our experience with several months
of data, they appear to be satisfactory for our speciﬁc needs.
2.3 State Machine Builder
The State Machine Builder creates a complex State Ma-
chine from the message sequences generated by the Mes-
sage Sequence Factory. The state machine is created in an
iterative way, by adding all observed message sequences
one by one.
The State Machine is composed of edges and states. For
a given state, the outgoing edges represent the possible tran-
sitions towards the next future state. Each edge is labeled
with a message representing the client request which will
trigger that transition, while each state is labeled with a
message representing the answer that the server will send
back to the client when entering it. Every edge label has
also a weight. The weight represents the frequency with
which samples have traversed that speciﬁc transition.
It is worth pointing out that if the answer provided by a
server is a function not only of the past exchanges but also
of some external factor, such as, for instance, the time of
the day, then a given state could have more than one label.
In other words, a given exchange of messages may lead to
two, or more, different answers from the server. Therefore,
server labels are maintained in arrays. The frequency of
each label is also kept. The most frequent one is the default
choice when the script has to generate a reply.
In order to avoid overly complex State Machines, two
thresholds are deﬁned: the maximum fan-out of one state
and the maximum number of states. The maximum fan-out
is the maximum allowed number of outgoing edges from
one state.
Figure 2 shows a simple example of State Machine. The
ﬁrst state is labeled with the server message S0. Of course,
i
[
m
S
p
0
l
]
p