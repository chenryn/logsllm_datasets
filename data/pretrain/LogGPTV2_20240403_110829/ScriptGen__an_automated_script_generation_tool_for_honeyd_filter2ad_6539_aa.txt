# ScriptGen: An Automated Script Generation Tool for Honeyd

## Authors
- Corrado Leita
- Ken Mermoud
- Marc Dacier

### Affiliation
Institut Eurecom, Sophia Antipolis, France  
Email: {leita, mermoud, dacier}@eurecom.fr

## Abstract
Honeyd [14] is a widely-used tool developed by Niels Provos that emulates multiple services on a single PC, acting as a low-interaction honeypot. The responses to incoming requests are generated using custom scripts, which must be manually written. This manual process has led to a limited number of available scripts, particularly for services with proprietary protocols. In this paper, we introduce a method to automatically generate these scripts, thereby alleviating the current limitations. We detail our approach and discuss its constraints. To evaluate the quality of the generated scripts, we employed two methods: first, we tested them against known attacks, and second, we deployed a machine running our scripts alongside a high-interaction honeypot for two months. By comparing the behavior of attackers targeting both machines, we could assess whether our scripts effectively deceived them. Additionally, we explore the various parameters that can be adjusted to balance script quality and complexity.

## 1. Introduction
Honeypots have gained significant attention in the research community due to their versatility, from capturing zero-day attacks to long-term data collection. Honeyd [14] is a popular and straightforward solution, extensively used in projects like Leurreâ€™com, where multiple platforms were deployed globally [4, 5, 6, 7, 8, 9]. However, Honeyd relies on specific scripts to emulate services, and writing these scripts is often tedious and challenging, especially for proprietary protocols. This scarcity of scripts makes it easier to fingerprint Honeyd installations, limiting their effectiveness. Our goal is to automate the generation of these scripts without requiring detailed knowledge of the underlying service or protocol.

While fully automating this process for all scenarios may be infeasible, we aim to provide robust responses to requests from attack tools. These requests are typically generated by deterministic automata (exploits), representing a limited subset of possible inputs and execution paths. With this in mind, we developed a three-step approach:

1. **Data Collection**: A real machine is placed on the Internet as a honeypot, and all traffic is recorded in a tcpdump file. If the machine is compromised, the experiment is halted, and the machine is reinstalled.
2. **Traffic Analysis**: The recorded traffic is analyzed to derive state machines representing the observed request-response patterns for each listening port.
3. **Script Generation**: From these state machines, honeyd-compatible scripts are generated to recognize incoming packets and provide appropriate responses.

This approach, while not perfect, significantly enhances the capabilities of low-interaction honeypots like Honeyd by enabling the automatic generation of scripts for commonly targeted services.

## 2. ScriptGen

### 2.1 Overview
ScriptGen consists of four main modules, as illustrated in Figure 1:

- **Message Sequence Factory**: Extracts and reconstructs TCP streams from the tcpdump file, handling retransmissions and out-of-order packets.
- **State Machine Builder**: Constructs a state machine from the extracted message sequences, managing complexity through defined thresholds.
- **State Machine Simplifier**: Analyzes the raw state machine and introduces semantics, using the PI algorithm [3] and a novel Region Analysis algorithm.
- **Script Generator**: Generates honeyd-compatible scripts from the simplified state machine.

### 2.2 Message Sequence Factory
A message sequence is an ordered list of messages exchanged between a client and a server. A message is defined as the longest consecutive set of bytes in one direction. TCP sessions are decomposed into these message sequences.

To efficiently reassemble TCP packets, we implemented a custom solution tailored to our needs. The key assumptions for rebuilding TCP sequences include:
- Only packets with payload are considered; pure-ACK and retransmitted packets are ignored.
- A TCP session starts with the first SYN packet and ends with the first FIN/RST packet.
- The TCP sequence number is used to handle out-of-order packets and retransmissions.

While these assumptions may cause issues in general, they are sufficient for our specific use case based on extensive testing.

### 2.3 State Machine Builder
The State Machine Builder creates a complex state machine from the message sequences. The state machine is built iteratively by adding observed message sequences. Each state has outgoing edges labeled with client requests, and each edge has a weight representing the frequency of that transition. Server responses are stored in arrays, with the most frequent response being the default.

To manage complexity, two thresholds are defined: the maximum fan-out (number of outgoing edges) and the maximum number of states. Figure 2 illustrates a simple example of a state machine.

---

**Note:** The figures and additional details are omitted for brevity. For a complete understanding, please refer to the full paper.