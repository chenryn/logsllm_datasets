### 5. 本地方法栈（Native Method Stack）本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用Java 实现的，而是由 C 语言实现的。
## JVM 的运行原理看到这里，相信你对 JVM内存模型已经有个充分的了解了。接下来，我们通过一个案例来了解下代码和对象是如何分配存储的，Java代码又是如何在 JVM 中运行的。    public class JVMCase { // 常量public final static String MAN_SEX_TYPE = "man"; // 静态变量public static String WOMAN_SEX_TYPE = "woman"; public static void main(String[] args) {Student stu = new Student();stu.setName("nick");stu.setSexType(MAN_SEX_TYPE);stu.setAge(20);JVMCase jvmcase = new JVMCase();// 调用静态方法print(stu);// 调用非静态方法jvmcase.sayHello(stu);}  // 常规静态方法public static void print(Student stu) {System.out.println("name: " + stu.getName() + "; sex:" + stu.getSexType() + "; age:" + stu.getAge()); }  // 非静态方法public void sayHello(Student stu) {System.out.println(stu.getName() + "say: hello"); }} class Student{String name;String sexType;int age;public String getName() {return name;}public void setName(String name) {this.name = name;}public String getSexType() {return sexType;}public void setSexType(String sexType) {this.sexType = sexType;}public int getAge() {return age;}public void setAge(int age) {this.age = age;}}**当我们通过 Java 运行以上代码时，JVM 的整个处理过程如下：**1.JVM 向操作系统申请内存，JVM第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给JVM，接下来 JVM 就进行内部分配。2.JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。3.class文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第21 讲还会详细介绍）。![](Images/43c43c8ee347a9f39d002248247dc446.png){savepage-src="https://static001.geekbang.org/resource/image/d6/b6/d6531847779ba0fb48070397e2915cb6.jpg"}4\. 完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM首先会执行构造器 \ 方法，编译器会在.java 文件被编译成.class文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为\() 方法。![](Images/52f2ced9bb52b33bbf609f3a7184eff1.png){savepage-src="https://static001.geekbang.org/resource/image/a0/80/a00b9a9a3f0501dee5028ace57234f80.jpg"}5\. 执行方法。启动 main 线程，执行 main方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用student 就存放在栈中。![](Images/6940b02ebe603068e5c08253b02de097.png){savepage-src="https://static001.geekbang.org/resource/image/c6/7e/c6702aea3f1aaca60b1cd2e38981ad7e.jpg"}6\. 此时再次创建一个 JVMCase 对象，调用 sayHello 非静态方法，sayHello方法属于对象 JVMCase，此时 sayHello 方法入栈，并通过栈中的 student引用调用堆中的 Student 对象；之后，调用静态方法 print，print静态方法属于 JVMCase 类，是从静态方法中获取，之后放入到栈中，也是通过student 引用调用堆中的 student 对象。![](Images/e06cbf747d4b0ab92879d074504e7794.png){savepage-src="https://static001.geekbang.org/resource/image/b7/23/b7d00191a1d42def9633b8ea8491cf23.jpg"}了解完实际代码在 JVM中分配的内存空间以及运行原理，相信你会更加清楚内存模型中各个区域的职责分工。
## 总结这讲我们主要深入学习了最基础的内存模型设计，了解其各个分区的作用及实现原理。如今，JVM 在很大程度上减轻了 Java开发人员投入到对象生命周期的管理精力。在使用对象的时候，JVM会自动分配内存给对象，在不使用的时候，垃圾回收器会自动回收对象，释放占用的内存。但在某些情况下，正常的生命周期不是最优的选择，有些对象按照 JVM默认的方式，创建成本会很高。比如，我在[第 03讲](https://time.geekbang.org/column/article/97215)讲到的 String对象，在特定的场景使用 String.intern可以很大程度地节约内存成本。[我们可以使用不同的引用类型，改变一个对象的正常生命周期，从而提高JVM 的回收效率，这也是 JVM 性能调优的一种方式。]{.orange}
## 思考题这讲我只提到了堆内存中对象分配内存空间的过程，那如果有一个类中定义了String a=\"b\"和 String c = new String("b")，请问这两个对象会分别创建在JVM 内存模型中的哪块区域呢？期待在留言区看到你的答案。也欢迎你点击"请朋友读"，把今天的内容分享给身边的朋友，邀请他一起讨论。![unpreview](Images/b7c462671ae86891c7f8ac1941814e21.png){savepage-src="https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg"}
# 21 \| 深入JVM即时编译器JIT，优化Java编译你好，我是刘超。说到编译，我猜你一定会想到 .java 文件被编译成 .class文件的过程，这个编译我们一般称为前端编译。Java的编译和运行过程非常复杂，除了前端编译，还有运行时编译。由于机器无法直接运行Java 生成的字节码，所以在运行时，JIT或解释器会将字节码转换成机器码，这个过程就叫运行时编译。类文件在运行时被进一步编译，它们可以变成高度优化的机器代码，由于 C/C++编译器的所有优化都是在编译期间完成的，运行期间的性能监控仅作为基础的优化措施则无法进行，例如，调用频率预测、分支频率预测、裁剪未被选择的分支等，而Java 在运行时的再次编译，就可以进行基础的优化措施。因此，JIT编译器可以说是 JVM 中运行时编译最重要的部分之一。然而许多 Java 开发人员对 JIT编译器的了解并不多，不深挖其工作原理，也不深究如何检测应用程序的即时编译情况，线上发生问题后很难做到从容应对。[今天我们就来学习运行时编译如何实现对Java 代码的优化。]{.orange}
## 类编译加载执行过程在这之前，我们先了解下 Java从编译到运行的整个过程，为后面的学习打下基础。请看下图：![](Images/e0330c361c1f836258a013f142166683.png){savepage-src="https://static001.geekbang.org/resource/image/8d/17/8d4ec9c73ec37d69adb105aa7d052717.jpg"}
### 类编译在编写好代码之后，我们需要将 .java 文件编译成 .class文件，才能在虚拟机上正常运行代码。文件的编译通常是由 JDK 中自带的 Javac工具完成，一个简单的 .java 文件，我们可以通过 javac 命令来生成 .class文件。``{=html}下面我们通过 javap（ [第 12讲](https://time.geekbang.org/column/article/101244) 讲过如何使用 javap反编译命令行）反编译来看看一个 class 文件结构中主要包含了哪些信息：![](Images/1125dae654ad1917765fb019f2d02638.png){savepage-src="https://static001.geekbang.org/resource/image/60/7e/605dbbcfbbfcc09143d7d9e7fed5ac7e.png"}看似一个简单的命令执行，前期编译的过程其实是非常复杂的，包括词法分析、填充符号表、注解处理、语义分析以及生成class文件，这个过程我们不用过多关注。只要从上图中知道，[编译后的字节码文件主要包括常量池和方法表集合这两部分]{.orange}就可以了。常量池主要记录的是类文件中出现的字面量以及符号引用。字面常量包括字符串常量（例如String str="abc"，其中\"abc\"就是常量），声明为 final的属性以及一些基本类型（例如，范围在 -127-128之间的整型）的属性。符号引用包括类和接口的全限定名、类引用、方法引用以及成员变量引用（例如String str="abc"，其中 str 就是成员变量引用）等。方法表集合中主要包含一些方法的字节码、方法访问权限（public、protect、prviate等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM执行指令以及属性集合等。
### 类加载当一个类被创建实例或者被其它对象引用时，虚拟机在没有加载过该类的情况下，会通过类加载器将字节码文件加载到内存中。不同的实现类由不同的类加载器加载，JDK中的本地方法类一般由根加载器（Bootstrp loader）加载进来，JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现加载，而程序中的类文件则由系统加载器（AppClassLoader ）实现加载。在类加载后，class 类文件中的常量池信息以及其它数据会被保存到 JVM内存的方法区中。
### 类连接类在加载进来之后，会进行连接、初始化，最后才会被使用。在连接过程中，又包括验证、准备和解析三个部分。**验证：**验证类符合 Java 规范和 JVM规范，在保证符合规范的前提下，避免危害虚拟机安全。**准备：**为类的静态变量分配内存，初始化为系统的初始值。对于 finalstatic 修饰的变量，直接赋值为用户的定义值。例如，private final staticint value=123，会在准备阶段分配内存，并初始化值为 123，而如果是 privatestatic int value=123，这个阶段 value 的值仍然为 0。**解析：**将符号引用转为直接引用的过程。我们知道，在编译时，Java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。类结构文件的常量池中存储了符号引用，包括类和接口的全限定名、类引用、方法引用以及成员变量引用等。如果要使用这些类和方法，就需要把它们转化为JVM 可以直接获取的内存地址或指针，即直接引用。