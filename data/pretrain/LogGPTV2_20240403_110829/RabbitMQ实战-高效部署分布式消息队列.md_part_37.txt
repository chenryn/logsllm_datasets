topic交换器
topic交换器则完全不同。这是因为存储的路由信息更加复杂。由于路由键可
以包含以点（.）分隔的多个词，所以匹配消息路由键不仅仅是简单字符串的匹配。
因此，RabbitMQ实现了trie数据结构用来存储绑定路由键模式，以支持快速查
询。以下两篇博客详细解释了topic交换器及其性能特点：http://www.rabbitmq.com
1更多有关ETS的信息请参阅http://erlang.org/doc/man/ets.html。
---
## Page 243
11.1对速度的需求
221
blog/2010/09/14/very-fast-and-scalable-topic-routing-part-1/ 和 http://www.rabbitmq.com/
blog/2011/03/28/very-fast-and-scalable-topic-routing-part-2/。在第二篇文章中，你可以
看到RabbitMQ的topic交换器实现，可以在2.3GHz的机器上，以11秒左右的时间，
针对2000个模式匹配1000000个topic。这说明topic交换器对于日常消息通信场
景来说绰绰有余。记住，通常情况下，topic交换器上的绑定相比direct或者fanout
交换器来说，会占用更多的内存。
找到消息的目的地是一回事，投递消息则是另一回事儿。让我们看看在交换器
处理消息路由信息之后发生了什么。
11.1.4投递消息
在交换器找到消息需要路由的目的地之后，它会将目的地列表返回给rabbit
router，并在之后着手将消息的副本投递到每一个目的地（队列或者交换器）。如
果发布的消息中mandatory和immediate标记设置为false的话，那么这个过程
会以异步的方式执行；并且从客户端的角度来看，服务器会变得更快。
事情开始变得有点棘手了，所以我们将该过程用图11.1展现出来。如果消息
投递的目的队列是空的并且消费者准备好接收消息的话，那么该消息会直接发送
给消费者，而不会经过队列这一步。你应该猜到了，这会极大地提升消息投递速
度。下一个问题是消费者是否设置了auto-ack模式。如果消费者在订阅的时候
将no-ack设置为true的话，那么服务器会忽略该消息；否则，该消息会被添加到
pending-acknowledgment列表中用来记录消息。下一个问题是该消息是否路由
到了持久化队列上，以及该消息是否以持久化的方式发布。如果确实如此，那么消
息会写入磁盘，但被标记为已投递（alreadydelivered）。因此当消息暂存队列的时候，
它不会被发送给其他消费者了。
现在让我们回到RabbitMQ检查队列是否为空的那一刻。如果队列不为空的话，
那么该消息就会入队。如果该消息不是持久化的话，那么它会被保存在内存中，当
然前提是有足够的内存来存放消息。如果内存不足的话，那么消息会被写人磁盘，
存放到瞬态存储中。如果是持久化消息的话，它们会被写入磁盘，并同时保存在内
存中以提升消息投递速度。如果发生了内存不足的情况，那么消息会刷出到磁盘。
通过这种方式，服务器既确保了消息的属性（例如持久化的作用），同时仍然尽可
能快地投递消息。
---
## Page 244
222
第11章提升性能，保障安全
路由消息
是
是否设置了
否
同步投递
投递
异步投递
否
队列
是否为空
投递给消费者
人队
是
否
消费者是否
准备就绪
是
消费者处于自
动确认模式？
消费投
持久
递模式
否
消息标记
W
为已投递
将消息添加
瞬态
到等待确认
将消息保存
队列中
在内存中
否
持久化队列
<内存有压力？
是
将消息持久化
到持久存储中
将消息持久化
到瞬态存储中
图11.1消息投递流程
如图11.1所示，当消息路由到了持久化队列的时候，如果它需要写人磁盘的话，
就会进人持久存储；否则就会进人瞬态存储。如果RabbitMQ需要重启并恢复持久
化队列的话，它只需看看持久存储中的内容，同时清除瞬态存储。
请记住，RabbitMQ被优化为尽可能快地向消费者投递消息。如果你制定容量
规划并计算消息的进出速率的话，那么你应该尽可能地让队列保持为空；虽然这不
是最新发现，但它会让你拥有一个快节奏的服务器。但是如果消费者开始滞后，同
---
## Page 245
11.2内存使用率和进程限制
223
时队列开始填满的话，之后在某一时间点上，服务器就会收到内存告警，并开始将
消息刷出到磁盘，而不管当时发布消息时使用的是什么参数。教训是时时刻刻关注
队列大小。
在本节中，你看到了不同的算法和消息发布订阅设置如何影响整个系统的速度，
以及像auto-ack模式标记设定能在很大程度上影响系统性能。在下一节中，我们
将会看到硬件（内存）和Erlang虚拟机施加在RabbitMQ服务器上的硬性限制。
11.2内存使用率和进程限制
当设计应用程序的时候，你通常会有两个基本限制：你选择的技术允许你做什
么，以及当前硬件设定允许你做什么。在上一节中——贯穿本书——我们已经讨论
过第一点了：不同的消息路由和分发算法如何影响设计决策。在本节中，我们会回
顾硬件和Erlang虚拟机施加给RabbitMQ的硬性限制，以便你可以进行预先规划，
同时看一下在单台机器上你可以将RabbitMQ的性能提升多少。举例来说，其中一
个有趣的度量值是RabbitMQ创建的每个AMQP组件，例如队列、交换器和绑定需
要多少内存。另一个需要考量的值是RabbitMQ为这些元素创建的Erlang进程数，
这样你在做容量规划计算的时候就有坚实的基础了。
11.2.1内存使用率
首先要弄明白的是当声明队列的时候到底发生了什么。当声明队列时，
RabbitMQ会在不同的Mnesia表里添加多条记录，这取决于队列的类型。如果队
列的声明中durable为true的话，那么就会在表rabbit_queue和表rabbit_
durable_queue添加队列的记录。否则，只会在表rabbit_queue中存放记录。
以上任何一张表的一条记录会占用大概29个字的大小。那意味着什么呢？在Erlang
中字的大小依赖于你的操作系统。对于32位计算机来说字长为4字节；而在64位
架构中，一个字占8个字节。我们说大约29个字的原因在于记录的大小同时还依
赖于队列声明时采用的名称。以上过程如图11.2所示。
---
## Page 246
224
第11章提升性能，保障安全
队列声明
Mnesia记录
rabbit_queue
约为29字
Mnesia记录
约为29字
是否
品
rabbit_durable_queue
持久化？
否
Mnesia记录
绑定到匿名队列
约为44字
队列声明成功
图11.2队列声明过程
根据AMQP规范，每个队列都会绑定到匿名交换器上。这意味着在队列声明
之后，rabbit_route 表中也会有一条记录来保存队列和交换器之间的绑定。在
其他Mnesia表中也可能会添加记录，这点稍后我们在讨论绑定规则的时候再说。
rabbit_route表中的一条记录会占用大概44个字的大小。
这意味着当你声明队列时，你会在rabbit_queue表中有一条29个字大小
的记录，加上在rabbit_route表中 44个字大小的记录。如果队列是持久化的
（durable）话，那么也会在rabbit_durable_queue表中有一条29个字大小的
记录。此外，在路由表中也会产生更多记录，你马上就会看到。表11.1详细地进行
了解释。
表11.1队列元数据内存使用
rabbit_queue
rabbit_durable_queue
持久化队列
X
X
瞬时队列
X
字/记录
29
29
x用于表示哪些表会为队列声明添加记录；同时，你可以看到这些表格中记录
的字长。
---
## Page 247
11.2内存使用率和进程限制
225
当你声明交换器时，差不多也是这样，但却会更简单一些。当声明了新的交换
器时，RabbitMQ会在rabbit_exchange表创建一条大约占用29个字大小的记录。
如果交换器是持久化的话，rabbit_durable_exchange上也会创建一条记录。请
参见表11.2。
表11.2交换器元数据内存使用
rabbit _exchange
rabbit durable _exchange
持久化交换器
X
瞬时交换器
字/记录
29
29
现在该来看看当你将队列绑定到交换器上的时候会发生什么。有两种情况：一
种是将队列绑定到direct或者fanout交换器上，另一种是将队列绑定到topic交换器
上。后者解释起来相对复杂，因此我们会在最后分析它。
当队列绑定到direct或者fanout交换器上的时候，RabbitMQ会在至少两
张Mnesia表上创建条目来记录绑定信息。这两张表分别是rabbit_route和
rabbit_reverse_route。记录大小为44个字。有几种组合会导致RabbitMQ在
其他表上创建条目。这些组合取决于队列的持久化属性以及用于绑定的交换器。一
个持久化队列绑定到一个瞬时交换器会导致在rabbit_semi_durable_route表
上创建条目。最后，当你将持久化队列绑定到持久化交换器上的话，RabbitMQ会
在rabbit_durable_route表创建条目。这些条目每个大小均为44个字。在表
11.3中你可以看到更详细的内容。
表11.3绑定元数据内存使用情况
rabbit
rabbit
rabbit
rabbit_route
durable_route
_semi_durable_route
_reverse_route
持久化队列绑定到
X
X
X
持久化交换器
持久化队列绑定到
X
X
X
瞬时交换器
瞬时队列绑定到瞬
时交换器
瞬时队列绑定到持
X
X
久化交换器
字/记录
44
44
44
44
---
## Page 248
226
第11章提升性能，保障安全
当绑定到topic交换器的时候，除了需要之前绑定到direct和fanout交换器时
的所有元素外，还有额外的两张Mnesia表：rabbit_topic_trie_binding和
rabbit_topic_trie_edge。顾名思义，绑定会存储在rabbit_topic_trie_
binding表中。表中的一条记录大概占用45个字。topic模式中有多少部分就会决
定有多少条记录插人到rabbit_topic_trie_binding表中。因此像a.b.c.d这
样的模式会在表中创建四条记录，每条占用38个字。
有了这些数据之后，你可以为消息通信应用做容量规划，并能够确定RabbitMQ
使用的内存上限。如你所见，队列、交换器和绑定的内存占用很小。举个例子，在
64位操作系统上，一个持久化队列绑定到一个持久化交换器会在rabbit_queue
和rabbit_durable_queue表中占用58个字，另外会在各个*_route表中总共
占用176个字。一共占用234个字，或者用字节表示是234字×8字节／字，等于
1872字节。
另一个施加在RabbitMQ上的硬性限制是每个Erlang节点的最大Erlang进程数。
让我们来仔细看看吧。
11.2.2Erlang 进程计数
可以在节点启动时指定Erlang节点上能够运行的最大Erlang 进程数。这里指的
是通过调用./sbin/rabbitmq-server-detached来启动 RabbitMQ。RabbitMQ
的默认设置是每个Erlang节点1048576，即2”°，这应该绰绰有余了。
Erlang应用程序在整个生命周期中会多次创建并销毁进程。例如，当RabbitMQ
接收到AMQP客户端的TCP连接时，就会创建一个Erlang进程来管理该连接。同
时，会有许多Erlang进程来处理RabbitMQ消息存储的逻辑。另一些进程会监控子
进程来确保它们正常运作，等等。如果启动RabbitMQ服务器的话，大概会有126
个进程在工作，这对于像RabbitMQ这样的服务器来说是非常少的。但是，如果你
超过了默认的2"限制会怎样？不幸的是，Erlang会崩溃，RabbitMQ也会崩溃。因
此，你必须确保自己设置了合适的进程数。目前，2”个进程对大多数用户来说足够
多了，并且也够用了，但是你的情况会不同。让我们看看什么情景下会使得进程数