+[8~--\6-02-])
#命名的或IPv4主机
1\[[a-z0-9\-._~!$&'()*+,;=：]+\])
#IPv6+主机
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
[a-z][a-z0-9+\-.]*://（[a-z0-9\-,_~g!$&（)*+,=]+@）?([a-z0-9\-._~]+|
\[[a-z0-9\-._~!$（）*+,;=：]+\])
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在对URL做合法性验证的同时抽取主机名
\A
[a-z][a-z0-9+\-.]*://
#通信协议方案
（[a-z0-9\-._~!$()*+,;=]+@）?
#用户名
（[a-20-9\-._~]+
#命名主机
\[[a-f0-9:.]+\]
#IPv6主机
|\[v[a-f0-9][a=z0-9\-._~g!$&'()*+,;=:]+\])
IPvFuture主机
(:[0-9]+)?
口#
（/[a-z0-9\-._~!$&（)*+,;=:@]+)*/?
#路径
(\？[a-z0-9\-._~!$'() *+,;=:@/？]*）？
#查询
（[/:=+（），si~·-\6-0z-]#\)
#片段
\Z
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
^[a-z][a-z0-9+\-.]*://（[a-20-9\-._~1$α（)*+,;=]+@)？（[a-z0-9\-._~]+｜+
\[[a-f0-9：.]+\]1\[v[a-f0-9][a-20-9\-._~g!$&（）*+,;=:]+\]）（:[0-9]+)?
（/[a-z0-9\-._~g!$&（)*+,;=:@]+)*/？（\？[a-z0-9\-._~!$&（)*+,;=:@/？]*)？
S（[/:=+*（），9i~-\6-0z-]#）
352
第7章
www.TopSage.com
---
## Page 369
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
讨论
如果已知目标文本是一个合法的URL，那么从URL中抽取主机名并不难。我们使
用作为定位符把匹配固定到字符串的开头。使用[a-z][a-z0-9+\-.]*:/>跳过通信
协议方案，使用跳过可选的用户名部分。主机名就是
紧随其后的那部分内容。
RFC3986中允许主机有两种不同的标记方式。主机可以指定为域名和IPv4地址，在
两边不需要使用方括号，而如果是IPv6地址和未来的IP地址，就需要用方括号包起
来。因为带方括号的表示法比不带方括号的充许出现更多的标点符号，所以我们需要
对它们进行分别处理。特别是，在方括号之间允许出现冒号，但是域名或IPv4地址
不允许有冒号出现。冒号也可以用来把端口号和（带方括号的和不带方括号的）主机
名分隔开。
可以匹配域名和IPv4地址。处理
IPv6和以后的IP地址版本。我们在一个分组中使用多选结构（实例2.8）将它们组合
在一起。捕获分组也让我们能抽取出主机名。
只有当URL确实指定了主机的时候，本正则式才能找到一个匹配。这个正则式会同时
匹配到通信协议方案、用户和URL中的主机部分。当正则式找到一个匹配时，你可以
提取在第二个捕获分组中匹配到的文本，获得不含分隔符和URL其他部分的主机名。
如果匹配到的是一个IPv6地址，那么在捕获分组中就会包括方括号。关于捕获分组的
知识都可以在实例2.9中找到。关于在你习惯使用的编程语言中如何提取捕获分组匹配
到的文本，可以参看实例3.9。
如果你不清楚目标文本中包含的是否是一个合法的URL，那么可以使用实例7.7中正
则式的一个简化版本。既然我们希望抽取的是主机名，就可以先排除没有指定授权的
URL。这样可以使这个正则表达式简单不少。它和我们在实例7.9中用到的正则式非常
相像。唯一的区别是这次授权中的用户部分也是可选的，这与在实例7.7中是一样的。
正则式还为主机的不同标记方式使用了多选结构，在多选结构之外使用了一个捕获分
组。提取第二个捕获分组所匹配到的文本，就可以获得URL中的主机名。
如果希望这个正则式可以匹配任意的合法URL，其中也包括那些没有指定主机名的
URL，那么你可以选取实例7.7中的-一个正则表达式。假如URL中存在主机名，那么
该实例中的第一个正则式的第4个捕获分组会捕获到主机。
参见
实例2.9、实例3.9和实例7.7。
URL、路径和Internet地址353
www.TopSage.com
---
## Page 370
7.11从URL中抽取端口号
问题描述
你要从一个包含URL的字符串中抽取出其中的端口号。例如，你想要从
http://www.regexcookbook.com:80/中抽取出端口号80。
解决方案
从已知是合法的URL中抽取端口号
\A
[a=z][a-z0-9+\-.]*://
通信协议方案
([a-z0-9\-._~$!$'()*+,;=]+@)?
用户名
（[a-z0-9\-._~g]+
命名的或IPv4主机
1\[[a-20-9\-._~!$（） *+,=：]+\])
IPv6+主机
:(?[0-9]+)
#端口号
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
[a-z][a-z0-9+\-.]*://（[a-z0-9\-._~g!$（)*+,;=]+@)?
([a-20-9\-._~g]+1\[[a-z0-9\-._~!$&()*+,;=:]+\]）:（[0-9]+)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在对URL做合法性验证的同时抽取端口号
\A
[a-z][a-20-9+\-.]*://
#通信协议方案
（[a-z0-9\-._~!$。'()*+,;=]+@）?
#用户名
（[a-z0-9\-._~g]+
#命名主机
1\[[a-f0-9: .]+\]
IPv6主机
1\[v[a-f0-9][a-z0-9\-.
~g！$&*（）*+，=：]+\]）
#IPvFuture.主机
: ([0-9]+)
#端口
（/[a-z0-9\-._~g!$&+（）*+,;=:@]+）*/？
#路径
(\？[a-z0-9\-._~g1$&'()*+,;=:@/?]*）？
#查询
（\#[a-20-9\-._~!$&（）*+,;=:@/？]*）？
#片段
\z
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
[a-2][a-20-9+\-.]*:\/\/（[a-z0-9\-._~1$&（)*+,;=]+@）?
（[a-z0-9\-._~]+1\[[a-f0-9:.]+\]1\[v[a-f0-9][a-z0-9\-.
[：=+（），9Si8~
+\]）:（[0-9]+）（\/[a-20-9\-._~g!$（）*+,;=:@]+)*\/?
（\？[a-z0-9\-._~81$&'()*+,=:@\/？]*)?（#[a-z0-9\-._~!$'（）*+,=:@\/？]*）？$
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
354
第7章
www.TopSage.com
---
## Page 371
讨论
如果已知自标文本是一个合法的URL，那么从URL中抽取端口号并不难。我们使
用或>将匹配定位到字符串的开头。使用[a-z][a-z0-9+\-.]*:/>跳过通信协议方
案，使用跳过可选的用户名部分，并且使
用跳过主机名。
端口号与主机名之间会用一个冒号分隔并来，我们在正则表达式中把冒号作为一个字
面上的字符处理。端口号本身只是个单纯的数字字符串，因此可以简单地用[0-9]+>进
行匹配。
只有在URL中指定了一个端口号时，这个正则式才能找到匹配。这个正则式会同时匹
配URL的通信协议方案、用户名、主机和端口部分。
当正则式找到了一个匹配的时候，你可以提取第3个捕获分组所匹配到的文本，从而
可以获得不含任何分隔号或URL其他部分的端口号。
其他2个分组一个是为了让用户名可选，另一个是为了让主机名的2个选择分支组合
到一起。关于捕获分组的讲解，请参考实例2.9。如果想了解如何在习惯使用的编程语
言中来提取捕获分组所匹配到的文本，请参考实例3.9中的讲解。
如果你尚不清楚自标文本是否是一个合法的URL，那么可以使用实例7.7中正则式的
一个简化版本。既然我们希望抽取的是端口号，那么就可以排除掉不包含授权的URL。
这样可以使正则表达式简单不少。它和我们在实例7.10中用到的正则式非常相像。
在这里的唯一区别是它的端口号不再是可有可无的，并且我们把端口号的捕获分组移
动了位置，排除了把端口号和主机名分隔开来的冒号。捕获分组的序号是第3个。
如果想要用一个正则式来匹配任意合法URL，其中也包括那些没有指定端口号的URL，
那么你可以使用实例7.7中的一个正则式。如果端口号存在，那么该实例中的第一个正
则式的第5个捕获分组中会捕获端口号。
参见
实例2.9、实例3.9和实例7.7。
7.12从URL中抽取路径
问题描述
你想要从一个包含URL的字符串中抽取其中的路径。例如，你想要从
http://www.regexcookbook.com/index.html或者从/index.html#fragment中抽取其中的路
径/index.html。
URL、路径和Internet地址
355
www.TopSage.com
---
## Page 372
解决方案
从一个已知是合法的URL中抽取路径。下面的正则式会匹配所有的URL，其中也包括
不含路径的URL：
\A
#略过通信协议方案和授权（如果有）：
([a-z][a-z0-9+\-.] *:(/ / [/?#]+) ?) ？
#路径
(￥[/:=+（）,9Si~·-\6-0z])
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
([a-z][a-z0-9+\-.] *:(/ /[/?#]+)?) ？([a-z0-9\-._~1$&() *+,;=:@/] *)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
从一个已知是合法的URL中抽取路径。只匹配确实包含路径的URL：
\A
#略过通信协议方案和授权（如果有）
（（+[#/]//）：[-\+6-02-][2-])
路径
(/？[a-z0-9\-._~1$&*() *+,;=@]+(/[a-z0-9\-._~!$'() *+,;=:@]+) */？1/)
查询，信息片段或URL结束
（[#？]I\Z)
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
([a-z][a-z0-9+\-.]*:(/ / [/?#]+) ?) ？(/？[a~z0-9\-._~!$&*() *+,;=@] +
(/[a-z0-9\-._~!$&'() *+,;=:@]+) */?1/)([#？]1S)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
从一个已知是合法的URL中抽取路径。使用原子分组来只匹配实际上包含路径的URL：
\A
#略过通信协议方案和授权（如果有）
（（（+[#/]//）：[-\+6-0z-][z-e]）<）
#路径
([a-z0-9\-._~g!$α'(）*+,;=:@/]+)
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Ruby
讨论
如果已知目标文本是一个合法的URL，那么你就可以使用一个非常简单的正则表达式
抽取路径。根据URL是否会指定通信协议方案和/或授权，实例7.7中的通用正则式有
3种不同的方式可以匹配路径，然而从已知是合法的URL中抽取路径的特定正则式只
需要匹配路径一次。
356
戛/L
www.TopSage.com
---