# Safe-Linking——针对 malloc 安全防护机制
|
##### 译文声明
本文是翻译文章，文章原作者 checkpoint，文章来源：research.checkpoint.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 简介
我们在Check Point
Research从事的每个研究项目的目标之一就是对软件的工作方式深入的分析：它们包含哪些组件？它们是否存在漏洞？攻击者如何利用这些漏洞？更重要的是，我们如何防范此类攻击？
在我们的最新研究中，我们提出了一种称为“Safe-Linking”的安全机制，用来保护malloc()的单向链表不被攻击者篡改。我们已经向核心开源代码库的维护者介绍了我们的方法，现在，它已经集成到最常见的标准库中：glibc（Linux）和uClibc-NG(嵌入式系统)。
需要注意的是，Safe-Linking不是万能的，它可以阻止针对现代堆实现的所有利用尝试。但是，这朝着正确方向迈出了一步。根据我们过去的经验，这种特定的缓解措施会阻止我们多年来展示的几个主要漏洞。
## 背景
在二进制利用的早期，堆内部数据结构就一直是攻击者的主要目标。通过理解堆的malloc()和free()的工作方式，攻击者能够利用堆缓冲区中的早期漏洞，  
如线性缓冲区溢出，将其转变为更强的利用原语如任意写(Arbitrary-Write)。
在2001年的Phrack文章中详细介绍了此示例：[Vudo Malloc
Tricks](http://phrack.org/issues/57/8.html)。本文介绍了多个堆实现的内部原理，并描述了现在的“Unsafe-Unlinking”。修改双向链表的FD和BK指针的攻击可以使用unlink()操作来触发任意写(例如,Small-Bins),从而在目标程序上执行代码。
实际上，2005年的glibc 2.3.6版本对这个的利用进行了修复，称为““Safe-Unlinking”。它在unlink之前先验证了双向链表的完整性，如下图所示：
尽管这一利用在15年前被阻止，但当时没有人提出类似的解决方案来保护单向链表的指针。利用这一点，攻击者将注意力转移到这些未受保护的单向链表上，如Fastbin和TCache。破坏单向链表允许攻击者获得任意Malloc原语，即在任意内存地址中分配一个小的可控地址。
在本文中，我们结合了近20年的安全漏洞，并演示了我们如何创建一种安全机制来保护单向链表。
在深入研究Safe-Unlinking的设计之前，让我们回顾一下针对Fast-Bins的利用。
## Fast-Bin 利用案例 – CVE-2020-6007:
在研究智能灯泡的过程中，我们发现了一个基于堆的缓冲区溢出漏洞：[CVE-2020-6007](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-6007)。在这个漏洞的利用过程中，我们演示了攻击者如何利用未受保护的Fastbin单链表将堆缓冲区溢出转变为更强大的任意写(Arbitrary-Write)。
在我们的测试案例中，堆是dlmalloc实现的，具体的说是编译为32位版本的uClibc。下图显示了堆实现所使用的数据：
1.当分配和使用缓冲区时，前两个字段存储在用户的数据缓冲区之前。
2.当释放缓冲区并将其置入Fast-Bin中时，也会使用第三个字段，并指向Fast-Bin链表中的下一个节点。此字段位于用户缓冲区的前4个字节处。
3.当缓冲区被释放并且没有存入FastBin中时，第三和第四个字段都被用作双链表的一部分。这些字段位于用户缓冲区的前8个字节处。
Fast-Bins
是一个由各种大小的“Bins”组成的数组，每个都包含一个单链表，最多不超过特定大小。最小的bin大小包含0x10字节的缓冲区，下一个包含0x11到0x18字节的缓冲区，依此类推。
###  溢出方案
这个漏洞为我们提供了一个基于堆的缓冲区溢出，我们的计划是溢出FastBin中相邻的空闲缓冲区。下图显示了溢出之前的缓冲区状况:
图3:我们可控缓冲区（蓝色）放置在freed的缓冲区（紫色）之前
溢出后的两个缓冲区：
图4：我们的溢出修改了freed缓冲区的size和ptr字段（以红色显示）
我们希望修改的是FastBin的单链表指针。通过将这个指针更改为我们自己的任意地址，我们可以触发堆，使其认为新释放的chunk现在存储在那里。图5显示了Fast-Bin破坏的单链表，在堆中看起来如下：
图5：红色标记FastBin破坏的单链表
通过触发与FastBin大小相匹配的分配，我们获得Malloc Where原语。
注意：可能很多人会说，我们获得的Malloc-Where原语受到限制，因为“ Free Chunk”应以与当前Fast-Bin匹配的size字段开头。但是，此附加的检查仅在glibc中实现，而在uClibc-NG中却没有。因此，对于我们的Malloc-Where原语，没有任何限制。
## Safe-Linking 介绍
在完成智能灯泡的研究后，在36C3开始之前，我有一些空闲时间，我的计划是解决一些来自最近CTF比赛的pwn挑战。相反，我发现自己在重新思考最近开发的exploit。近十年来，我一直以同样的方式利用基于堆的缓冲区溢出，总是以堆中的单链表为目标。即使在CTF挑战中，我仍然关注TCache易受攻击的单链表。当然，有某种方法可以减轻这种流行的利用原语。
这就是Safe-Linking的出现。Safe-Linking利用了地址随机化（ASLR）中的随机性来“sign”指针，与chunk对齐完整性检查结合使用时，这种新技术可以防止指针被劫持。
我们的解决方案可防止现代漏洞中经常使用的3种常见攻击：
  * 1.部分指针覆盖：修改指针的低字节（Little Endian）。
  * 2.全指针覆盖：劫持指向任意位置的指针。
  * 3.未对齐的chunks：将list指向未对齐的地址。
###  威胁建模
在我们的威胁模型中，攻击者具有以下功能：
  * 1.堆缓冲区上的受控缓冲区上溢/下溢。
  * 2.相对任意写堆缓冲区
需要注意的是，我们的攻击者不知道堆位于何处，因为ASLR将堆的基地址与`mmap_base`一起随机分配。
我们的解决方案提高了门槛并阻止了攻击者基于堆的攻击尝试。一旦部署，攻击者必须以堆泄漏/指针泄漏的形式拥有附加功能。我们保护的一个示例场景是位置相关二进制文件（加载时不带ASLR），它在解析用户输入时有堆溢出。在我们之前的灯泡研究示例中，就是这种情况。
到目前为止，攻击者仅通过依赖二进制文件的固定地址，就能够在不泄漏堆的情况下利用这些目标，并且只对堆的分配进行最小程度的控制。我们可以阻止这种利用尝试，并在将堆分配重定向到目标二进制文件中的固定地址时，利用堆的ASLR获得随机性。
###  保护
在Linux机器上，堆是通过`mmap_base`随机分配的，其逻辑如下:
    random_base = ((1 > PAGE_SHIFT)
根据上面显示的ASLR公式，移位将来自内存地址的第一个随机位定位在掩码的LSBit上。
这就引出了我们的保护方案。我们用P表示单链表指针，方案如下:
  * 1.PROTECT(P) := (L >> PAGE_SHIFT) XOR (P)
  * 2.*L = PROTECT(P)
代码版本：
    #define PROTECT_PTR(pos, ptr, type)  
            ((type)((((size_t)pos) >> PAGE_SHIFT) ^ ((size_t)ptr)))
    #define REVEAL_PTR(pos, ptr, type)   
            PROTECT_PTR(pos, ptr, type)
这样，地址L中的随机位被放置在存储的受保护指针的LSB的顶部，如图6所示：
图6:掩码指针P被随机位覆盖，如红色所示
这个保护层防止攻击者在不知道随机的ASLR位(红色显示)的情况下修改指针到受控制的值。
但是，如果您注意一下，就会很容易发现我们在 Safe-Unlinking
机制方面处于劣势。虽然攻击者不能正确地劫持指针，但是我们也受到限制，因为我们不能检查是否发生了指针修改。这是进行额外检查的地方。
堆中所有已分配的chunk均与已知的固定偏移对齐，该偏移通常在32位上为8个字节，在64位上为16个字节。通过检查每个reveal()ed指针是否对齐，我们添加了两个重要的层:
  * 攻击者必须正确猜测对齐位。
  * 攻击者无法将chunk指向未对齐的内存地址。
在64位机器上，这种保护导致攻击尝试失败16次中的15次。如果我们返回到图6，我们可以看到受保护的指针的值以半字节0x3结尾，否则他将破坏该值并使对齐检查失败。
即使是单独使用，此对齐检查也可以防止已知的利用原语，例如本文中描述的原语，该原语描述了如何将Fast-Bin指向malloc()hook以立即获取代码执行。