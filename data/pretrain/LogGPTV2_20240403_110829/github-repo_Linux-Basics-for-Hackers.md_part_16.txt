/dev/sdb1 32 62498815 62498784 29.8G 7 HPFS/NTFS/exFAT
*清单10-2:使用fdisk列出分区*
如清单10-2所示，设备sda1、sda2和sda5在第一节中列出。这三种设备构成了我的虚拟机的虚拟磁盘，它是一个20GB的驱动器，有三个分区，包括交换分区(sda5)，当RAM容量超过时，它充当虚拟RAM—类似于Windows中的虚拟页面文件。
如果将清单10-2向下扫描到第三节，您将看到指定为sdb
-的第二个设备输出，b标签告诉我们这个驱动器与前三个设备是分开的。这是我的64GB闪存。注意，**fdisk**表示它是HPFS/NTFS/ExFAT文件系统类型。这些文件类型——高性能文件系统(HPFS)、新技术文件系统(NTFS)和扩展文件分配表(exFAT)——不是Linux系统的本机文件，而是macOS和Windows系统的。在进行研究时，能够识别不同系统的原生文件类型是值得的。文件系统可能指出驱动器的格式设置在哪种机器上，这是有价值的信息。Kali能够使用在许多不同操作系统上创建的USB闪存驱动器。
正如您在第1章中看到的，Linux文件系统的结构与Windows和其他专有操作系统有很大的不同。最重要的是，Linux中文件的存储和管理方式也不同。新版本的Windows使用NTFS文件系统，而旧的Windows系统使用文件分配表(FAT)系统。
Linux使用许多不同类型的文件系统，但最常见的是ext2、ext3和ext4。这些都是ext(或扩展的)文件系统的升级版，ext4是最新的。
#### *字符和块设备*
关于/dev目录中设备文件的命名，还需要注意的是，第一个位置包含**c**或**b**。您可以在清单10-1的大多数条目开头看到这一点，它看起来像这样:
crw­­­­­­­ 1 root root 10,175 May 16 12:44 agpgart
这些字母代表设备输入和输出数据的两种方式。**c**代表字符，如您所料，这些设备被称为字符设备。通过逐个字符(如鼠标或键盘)发送和接收数据与系统交互的外部设备是字符设备。
**b**代表第二种类型:块设备。它们以数据块(一次多个字节)进行通信，包括硬盘驱动器和DVD驱动器等设备。这些设备需要更高的数据吞吐量，因此以块(一次多个字符或字节)的形式发送和接收数据。一旦您知道一个设备是字符设备还是块设备，您就可以轻松地获得关于它的更多信息，您将在下面的文章中看到。
#### *使用lsblk列出块设备和信息*
Linux命令**lsblk** (list
block的缩写)列出/dev中列出的每个块设备的一些基本信息。结果类似于**fdisk
-l**的输出，但它也将在一种树型结构中显示具有多个分区的设备，将每个设备的分区显示为分支，并且不需要运行根特权。例如，在清单10-3中，我们看到了sda及其分支sda1、sda2和sda5。
kali \>lsblk
Name MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
fd0 2:0 1 4K 0 disk
sda1 8:0 0 20G 0 disk
\|­sda1 8:1 0 18.7G 0 part /
\|­sda2 8:2 0 1K 0 part
\|­sda5 8:5 0 1.3G 0 part [SWAP]
sdb 8:16 1 29.8G 0 disk
\|­sdb1 8.17 1 29.8G 0 disk /media
sr0 11:0 1 2.7G 0 rom
*清单10-3:使用lsblk列出块设备信息*
输出包括软盘驱动器作为fd0,
DVD驱动器作为sr0，尽管我的系统上没有软盘驱动器，这只是旧系统的遗留。我们还可以在驱动器的挂载点上看到信息——这是驱动器附加到文件系统的位置。请注意，硬盘驱动器sda1安装在/目录和闪存驱动器安装在/media目录。在下一节中，您将更多地了解这一点的重要性。
### 安装和卸载
大多数现代操作系统，包括Linux的大多数新版本，在附加存储设备时自动加载它们，这意味着新的闪存驱动器或硬盘驱动器将自动附加到文件系统。对于Linux新手来说，挂载可能是一个陌生的主题。
存储设备必须首先物理地连接到文件系统，然后逻辑地连接到文件系统，以便使数据对操作系统可用。换句话说，即使设备在物理上与系统相连，它也不一定在逻辑上与操作系统相连并可用。术语mount是计算机早期的遗留问题，当时存储磁带(在硬盘驱动器之前)必须物理地挂载到计算机系统中，想想那些带旋转磁带驱动器的大型计算机，您可能已经看过老式科幻电影了。
如前所述，目录树中附加设备的点称为挂载点。Linux中的两个主要挂载点是/mnt和/media。一般来说，内部硬盘安装在/mnt上，外部USB设备(如闪存驱动器和外部USB硬盘)安装在/media上，但从技术上讲，可以使用任何目录。
#### *自己安装存储设备*
在某些版本的Linux中，您需要手动挂载驱动器才能访问其内容，因此这是一项值得学习的技能。要在文件系统上挂载驱动器，请使用**mount**命令。如果将设备挂载到具有子目录和文件的目录上，则挂载的设备将覆盖该目录的内容，使其不可见且不可用。因此，要将新硬盘sdb1挂载到/mnt目录，需要输入以下命令:
kali \>mount /dev/sdb1 /mnt
然后，应该可以访问该硬盘驱动器。如果您想将闪盘sdc1挂载在/media目录下，请输入:
kali \>mount /dev/sdc1 /media
挂载在系统上的文件系统保存在/etc/fstab(文件系统表的缩写)的文件中，系统在每次启动时读取该文件系统。
#### *卸载与umount*
如果你来自Mac或Windows的实践背景，你可能在不知情的情况下卸载了一个驱动器。在您从系统中删除闪存驱动器之前，您要“弹出”它，以防止对存储在设备上的文件造成损害。“弹出”是unmount的另一种说法。
类似于**mount**命令，您可以通过输入**umount**命令和/dev目录中设备的文件条目(例如/dev/sdb)卸载第二个硬盘驱动器。注意，该命令的拼写不是unmount，而是umount
(no n)。
kali \>umount /dev/sdb1
您无法卸载正在使用中的设备，因此如果系统正在读取或写入此设备，您将只会收到一个错误。
### 监控文件系统
在本节中，我们将研究一些用于监控文件系统状态的命令——这是任何黑客或系统管理员都必须具备的技能。我们将获得一些关于挂载磁盘的信息，然后检查和修复错误。存储设备尤其容易出错，因此值得学习这项技能。
#### *获取挂载磁盘上的信息*
命令**df**(对于空余磁盘)将为我们提供关于任何硬盘或挂载设备(如CD、DVD和闪存驱动器)的基本信息，包括正在使用的空间和可用空间(参见清单10-4)。如果没有任何选项，**df**默认为系统上的第一个驱动器(在本例中是sda)。如果您想检查另一个驱动器，只需使用您想检查的驱动器表示形式(例如，df
sdb)遵循**df**命令即可。
kali \>df
Filesystem 1K­Blocks Used Available Use% Mounted on
rootfs 19620732 17096196 1504788 92% /
udev 10240 0 10240 0% /dev
­­snip­­
/dev/sdb1 29823024 29712544 110480 99% /media/USB3.0
*清单10-4:使用df获取磁盘和挂载设备上的信息*
这里的第一行输出我们得到的信息显示类别标题，磁盘空间以1KB块的形式给出。在第二行，我们看到rootfs有19,620,732个1千字节的块，其中使用了17,096,196个块(约占92%)，剩下1,504,788个可用。**df**命令还告诉我们这个文件系统安装在文件系统/根目录。
在最后一行，你可以看到我的u盘。注意，它被指定为/dev/sdb1，几乎100%已满，挂载在/media/USB3.0。
综上所述，我在这个系统上的虚拟磁盘被指定为sda1，它的信息如下:
sd SATA硬盘
一个硬盘驱动器
驱动器上的第一个分区
我的64GB闪存驱动器指定为sdb1，我的外部驱动器指定为sdc1。
#### *检查错误*
**fsck**命令(文件系统检查的缩写)检查文件系统的错误并修复损坏(如果可能的话)，或者将错误区域放入一个错误块表中，将其标记为错误。要运行**fsck**命令，需要指定文件系统类型(默认为ext2)和要检查的设备文件。重要的是，在运行文件系统检查之前，必须卸载驱动器。如果卸载挂载的设备失败，将收到清单10-5所示的错误消息。
kali \>fsck
fsck from util­linux 2.20.1
e2fsck 1.42.5 (29­Jul­2012)
/dev/sda1 is mounted
e2fsck: Cannot continue, aborting.
*清单10-5:尝试(失败)在挂载的驱动器上运行错误检查*
因此，执行文件系统检查的第一步是卸载设备。在这种情况下，我将卸载我的闪存驱动器做一个文件系统检查:
kali \>umount /dev/sdb1
我可以添加**-p**选项，让fsck自动修复设备的任何问题，如:
kali \>fsck -p /dev/sdb1
在设备卸载后，我现在可以检查设备的任何坏扇区或其他问题，如下:
kali \>fsck -p /dev/sdb1
fsck from util­linux 2.30.2
exfatfsck 1.2.7
Checking file system on /dev/sdb1.
File system version 1.0
Sector size 512 bytes
Cluster size 32 KB
Volume size 7648 MB
Used space 1265 MB
Available space 6383 MB
Totally 20 directories and 111 files.
File system checking finished. No errors found.
### 总结
理解Linux如何设计和管理它的设备对于任何Linux用户和黑客来说都是至关重要的。黑客需要知道哪些设备被连接到一个系统，以及有多少可用空间。由于存储设备经常出现错误，我们可以使用**fsck**检查和修复这些错误。**dd**命令能够创建设备的物理副本，包括任何已删除的文件。
11
--
日志系统
--------
THE LOGGING SYSTEM
![](media/451fdbee142e8cd4684d71b24707d050.jpg)
对于任何Linux用户，了解日志文件的使用是非常重要的。日志文件存储关于操作系统和应用程序运行时发生的事件的信息，包括任何错误和安全警报。您的系统将根据我将在本章中介绍的一系列规则自动记录信息。
作为黑客，日志文件可以跟踪目标的活动和身份。但是它也可以是你自己在别人系统上的活动的踪迹。因此，黑客需要知道他们可以收集什么信息，以及可以收集关于他们自己的行为和方法的什么信息，以便隐藏证据。
另一方面，任何保护Linux系统的人都需要知道如何管理日志记录功能，以确定系统是否受到攻击，然后破译实际发生的事情以及由谁做的。
本章向您展示如何检查和配置日志文件，以及如何删除活动的证据，甚至完全禁用日志记录。首先，我们将查看执行日志记录的守护进程。
### RSYSLOG日志记录守护进程
Linux使用一个名为**syslogd**的守护进程来自动记录计算机上的事件。**syslog**的几个变体，包括rsyslog和syslog-ng，在Linux的不同发行版上使用，尽管它们的操作非常相似，但仍然存在一些细微的差异。由于Kali
Linux是在Debian上构建的，并且Debian默认情况下带有rsyslog，所以我们将在本章重点介绍这个实用程序。如果您想使用其他发行版，那么有必要对它们的日志系统做一些研究。
让我们看看系统上的rsyslog。我们将搜索与rsyslog相关的所有文件。首先，在kali打开一个终端，输入以下内容:
kali \>locate rsyslog
/etc/rsyslog.conf
/etc/rsyslog.d
/etc/default/rsyslog
/etc/init.d/rsyslog
/etc/logcheck/ignore.d.server/rsyslog
/etc/logrotate.d/rsyslog
/etc/rc0.d/K04rsyslog
­­snip­­
如您所见，许多文件都包含关键字rsyslog，其中一些文件比其他文件更有用。我们要检查的是配置文件rsyslog.conf。
#### *rsyslog配置文件*
与Linux中的几乎所有应用程序一样，rsyslog由位于/etc目录下的纯文本配置文件进行管理和配置，这在Linux中通常是这样的。对于rsyslog，配置文件位于/etc/rsyslog.conf。使用任何文本编辑器打开该文件，我们将探索其中的内容(这里，我使用的是Leafpad):
kali \>leafpad /etc/rsyslog.conf
您应该看到代码如清单11-1所示的内容。
/etc/rsyslog.conf Configuration file for rsyslog.
\# For more information see
\# /usr/share/doc/rsyslog­doc/html/rsyslog_conf.html
\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#
\#\#\#\# MODULES \#\#\#\#