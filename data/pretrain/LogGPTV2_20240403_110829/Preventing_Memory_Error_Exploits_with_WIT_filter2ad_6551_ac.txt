which is common for functions that are invoked often.
We also update the color table when heap objects are
allocated or freed. We instrument the code to call wrap-
pers of the allocation functions, for example, malloc and
calloc. These wrappers receive the color of the object be-
ing allocated as an additional argument. They call the cor-
responding allocator and then set the color table entries for
the allocated object to the argument color. They set (cid:2)s/8(cid:3)
color table entries for an object of size s. They also set
the color table entries for the eight-byte slots immediately
before and after the object to color one. These two slots
contain a chunk header maintained by the standard alloca-
tor in Windows. We use these headers as guards. We also
replace calls to free by calls to a wrapper. This wrapper
sets the color table entries of the object being freed to zero
and then invokes free. We use a different color for guards
in the heap to detect some invalid uses of free (as explained
in the next section).
4.4. Instrumenting writes
We only check writes performed by unsafe instructions.
These checks lookup the color of the destination operand in
the color table. Then they compare this color with the color
of the instruction. If the colors are the same, they allow the
write to proceed. Otherwise, they generate an exception.
We insert write checks in the MIR, which makes this instru-
mentation phase independent of the target architecture. For
example, we add the following instrumentation before the
unsafe write in Figure 2:
t300 = SHIFTRIGHT &[t276], 3
t301 = COMPARE(EQ) [t300+40000000h], 3
CONDITIONALBRANCH(True) t301, $L11, $L10
$L10: BREAK
$L11: [t276] = ASSIGN [t278] # unsafe write
where t300 and t301 are fresh temporaries, and the unsafe
write has color 3. Phoenix lowers this into the following
sequence of x86 assembly code:
# 2 bytes
lea edx,[ecx]
shr edx,3
# 3 bytes
cmp byte ptr [edx+40000000h],3 # 7 bytes
# 2 bytes
je $L11
int 3
# 1 byte
$L11: mov byte ptr [ecx],ebx
#unsafe write
where register ecx holds the target address of the unsafe
write and the color table starts at 40000000h. This code se-
quence loads the address of the destination operand into a
register, and shifts the register right by three to obtain the
operand’s index in the color table. Then it compares the
color in the table with the color of the unsafe instruction. If
they are different, it executes int 3. This raises an excep-
tion that invokes the debugger in debugging runs, or termi-
nates execution in production runs. We could easily raise
a different exception but this one is convenient for debug-
ging. The instructions in the write check are encoded in
15 bytes when the table is at address 40000000h but they
require only 11 bytes when the table is at address 0h.
We treat free as an unsafe instruction that writes to the
object pointed to by its argument. The wrapper for free
receives the color computed by the static analysis for the
object being freed. Then it checks if the pointer argument
points to an object with this color, if it is eight-byte aligned,
if it points to user address space, and if the slot before this
object has color one. If this check fails, we raise an excep-
tion. The ﬁrst check prevents double frees because we reset
the color of heap objects to zero when we free them. The
last two checks prevent frees whose argument is a pointer
to a non-heap object or a pointer into the middle of an al-
located object. Recall that color one is reserved for heap
guards and is never assigned to other memory locations.
4.5. Instrumenting indirect calls
We also add checks before each indirect call. These
checks lookup the color of the target function in the color
table and compare this color with the color of the indirect
call instruction. If they do not match, we raise an exception.
This instrumentation phase is also independent of the target
architecture because it works with MIR. For example, we
replace the indirect call call t280 by the following MIR
instruction sequence:
t300 = SHIFTRIGHT t280, 3
t301 = COMPARE(EQ) [t200+40000000h], 20
CONDITIONALBRANCH(True) t301, $L10, $L11
$L11: BREAK
$L10: t302 = SHIFTLEFT t300, 3
CALL t302
# indirect call
where t300, t301, and t302 are fresh temporaries and 20
is the color of the indirect call instruction. Phoenix lowers
this MIR instructions into the following sequence of x86
assembly code:
$L10
$L10: shl edx,3
# 3 bytes
shr edx,3
cmp byte ptr [edx+40000000h], 20 # 7 bytes
# 2 bytes
je
# 1 byte
int 3
# 3 bytes
# indirect call
call edx
where register edx holds the function pointer and the color
table starts at address 40000000h. The ﬁrst instruction shifts
the function pointer right by three to compute the color table
index of the ﬁrst instruction in the target function. The cmp
instruction checks if the color in the table is the color of
allowed targets for this indirect call instruction. If they are
different, WIT raises an exception. If they are equal, the
index is shifted left by three to restore the original function
pointer value and the function is called.
This instruction sequence zeroes the three least signiﬁ-
cant bits of the function pointer value. Since the ﬁrst in-
struction in a function is always 16-byte aligned, this has no
effect if the function pointer value is correct. But it prevents
attacks that cause a control ﬂow transfer into the middle of
the ﬁrst eight-byte slot of an allowed target function. There-
fore, this instruction sequence ensures that the indirect call
transfers control to the ﬁrst instruction of a call target that is
allowed by the static analysis. The checks on indirect calls
are sufﬁcient to enforce control-ﬂow integrity because all
other control data is protected by the write checks.
5. Runtime
WIT has a small runtime that includes an initialization
function and some wrappers for C runtime functions, for
example, for malloc and free. The initialization function
allocates the color table using VirtualAlloc, which re-
serves virtual memory for the table without adding space
overhead for pages that are not accessed. The operating
system zeroes the pages in the table when they are ﬁrst ac-
cessed. The initialization function sets the color table en-
tries for globals an their guard objects, and for the entry
points of indirect call targets. We instrument the C runtime
(libc) start-up function to invoke our initialization.
Since there are many memory errors due to incorrect use
of libc functions, we use a version of libc instrumented
with WIT. If we used the variant of WIT described in the
previous sections, we would require a different libc bi-
nary for each program. Instead we developed a variant of
WIT for libraries. This variant assigns the same well-known
color (different from zero or one) to all unsafe objects al-
located by the library and inserts guards around these ob-
jects. All safe objects used by the library functions have
color zero. Before writes, this variant of WIT checks that
the color of the location being written is greater than one,
that is, that the location is not a safe object or a guard
object. These checks prevent libc functions from violat-
ing control-ﬂow integrity. They also prevent all commmon
buffer overﬂows due to incorrect use of libc functions.
However, they cannot prevent attacks that overwrite an un-
safe object by exploiting format string vulnerabilities with
the %n speciﬁer, but these can be prevented with static anal-
ysis [38, 9] and are disallowed by some implementations.
We still need to write wrappers for libc functions that
are written in assembly (for example, memcpy and strcpy)
and for system calls (for example, recv). These wrappers
receive the colors of destination buffers as extra arguments
and scan the color table entries corresponding to the slots
written by the wrapped function to ensure that they have
the right color. Since the color table is very compact, these
wrappers introduce little overhead. Other techniques re-
quire similar wrappers, e.g., [37, 21].
6. Effectiveness at preventing attacks
WIT can prevent all attacks that violate write integrity
but the number of attacks that violate this property depends
on the precision of the points-to analysis. For example if
two objects have the same color, we may fail to detect at-
tacks that use a pointer to one object to write to the other.
We ran experiments to evaluate the precision of the
points-to analysis and its impact on security. We used WIT
to compile nine programs from the SPEC CPU 2000 bench-
mark suite [40] (gzip, vpr, mcf, crafty, parser, gap, vortex,
bzip2 and twolf). During compilation, we measured the
number of colors used in each benchmark and the number of
memory write instructions with each color. Then we ran the
benchmarks and measured the maximum number of objects
with each color at runtime, where an object is a local vari-
ů
Ɛ
ƌ
Ž
Ž
Đ

Ĩ
Ž

ƌ
Ğ
ď
ŵ
Ƶ
Ŷ
ϭϲϬ
ϭϰϬ
ϭϮϬ
ϭϬϬ
ϴϬ
ϲϬ
ϰϬ
ϮϬ
Ϭ
ŐǌŝƉ
ǀƉƌ ŵĐĨ ĐƌĂĨƚǇ ƉĂƌƐĞƌ ŐĂƉ ǀŽƌƚĞǆ ďǌŝƉϮ ƚǁŽůĨ
Figure 4. Number of colors for SPEC benchmarks.
able, a global variable, or an object allocated dynamically
using malloc, calloc, realloc, or alloca. We com-
bined these measurements to obtain an upper bound on the
number of objects writable by each instruction at runtime.
To compute this upper bound, we assumed a vulnerability
that allows an unsafe instruction to write to any object with
the same color as the instruction. We ignored constraints
imposed by the program code and our guards.
Figure 4 shows the number of colors used by objects and
functions in these benchmarks, and Figure 5 shows a cu-
mulative distribution of the fraction of memory write in-
structions versus the upper bound on the number of objects
writable by each instruction. For example, the ﬁrst graph in
Figure 5 shows that 88% of the memory write instructions
in bzip can write at most one object at runtime, 99.5% can
write at most two objects, and all instructions can write at
most three objects. Therefore, even in this worst case, the
attacker can only use a pointer to one object to write to an-
other in 12% of the write instructions and in 96% of these
instructions it can write to at most one other object. In prac-
tice, the program code and our guards will further reduce
the sets of objects writable by each instruction.
The results in Figure 5 show that the precision of the
points two analysis can vary signiﬁcantly from one applica-
tion to the other. For all applications except mcf and parser,
the attacker cannot make the majority of instructions write
to incorrect objects. For bzip, gap, crafty, and gzip, 93%
of the instructions can write to at most one incorrect ob-
ject in the worst case. The precision is worse for twolf, vpr
and vortex because they allocate many objects dynamically.
However, the fraction of instructions that can write a large
number of objects is relatively small.
It is important to note that WIT can prevent many at-
tacks regardless of the precision of the points-to analysis.
Even when the analysis assigns the same color to all unsafe
objects, our write checks can prevent: attacks that exploit
sequential overﬂows and underﬂows, attacks that overwrite
safe objects or code, and attacks that corrupt heap manage-
ment data structures.
WIT prevents attacks that exploit buffer overﬂows and
underﬂows by writing elements sequentially until an object
boundary is crossed. These attacks are always prevented
ďǌŝƉ
ŐĂƉ
ŵĐĨ
Ϭ
ϱ
ϭϬ
ϭϱ
ƵƉƉĞƌďŽƵŶĚŽŶŶƵŵďĞƌŽĨǁƌŝƚĂďůĞŽďũĞĐƚƐ
ĐƌĂĨƚǇ
ŐǌŝƉ
ƉĂƌƐĞƌ
Ϭ
ϱϬ
ϭϬϬ
ϭϱϬ
ƵƉƉĞƌďŽƵŶĚŽŶŶƵŵďĞƌŽĨǁƌŝƚĂďůĞŽďũĞĐƚƐ
ƚǁŽůĨ
ǀƉƌ
ǀŽƌƚĞǆ
ϭ
Ϭ͘ϵ
Ϭ͘ϴ
Ϭ͘ϳ
Ϭ͘ϲ
Ϭ͘ϱ
Ϭ͘ϰ
Ϭ͘ϯ
Ϭ͘Ϯ
Ϭ͘ϭ
Ϭ
ϭ
Ϭ͘ϵ
Ϭ͘ϴ
Ϭ͘ϳ
Ϭ͘ϲ
Ϭ͘ϱ
Ϭ͘ϰ
Ϭ͘ϯ
Ϭ͘Ϯ
Ϭ͘ϭ
Ϭ
ϭ
Ϭ͘ϵ
Ϭ͘ϴ
Ϭ͘ϳ
Ϭ͘ϲ
Ϭ͘ϱ
Ϭ͘ϰ
Ϭ͘ϯ
Ϭ͘Ϯ
Ϭ͘ϭ
Ϭ
Ɛ
Ŷ
Ž
ŝ
ƚ
Đ
Ƶ
ƌ
ƚ
Ɛ
Ŷ
ŝ


Ğ
ƌ
Ž
ƚ
Ɛ

Ĩ
Ž
Ŷ
Ž
ŝ
ƚ
Đ
Ă
ƌ
Ĩ
Ɛ
Ŷ
Ž
ŝ
ƚ
Đ
Ƶ
ƌ
ƚ
Ɛ
Ŷ
ŝ


Ğ
ƌ
Ž
ƚ
Ɛ

Ĩ