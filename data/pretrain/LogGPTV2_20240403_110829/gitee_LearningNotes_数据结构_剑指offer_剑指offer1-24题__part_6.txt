由上面公式 推导出 n(m+d) = s + d
得到：s = n(m+d) -d；
s = nm + (n-1)(d)
s = m + (n-1)(m+d)
___
## 19.二进制中的1的个数
**输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示**
#### `知识点:`
#### 补码
特性：
1、一个负整数（或原码）与其补数（或补码）相加，和为模。
2、对一个整数的补码再求补码，等于该整数自身。
3、补码的正零与负零表示方法相同
#### 按位取反 ~
~，用法只有一个那就是按位取反，需要注意的是：
- ~的按位取反，包括符号位
- 正数各位取反变为负数，显示时转化为其补码
- 负数本身需要先转换为补码（符号位不变，各位取反再加 1），再对其补码进行各位去反
##### 1. ~5
5 的二进制为 0101，
~5
- （1）各位取反，1010
- （2）变为负数，转化为其补码形式（符号位保持不变），各位取反 1（1101），再加1（1110），也即 -6
```python
>> ~5
>> -6
```
##### 2. ~(-5)
-5 因为是负数，存储时存储的是其补码：
- -5 的补码是：1011，
- ~(-5)将其各位取反（包括符号位），也即 0100（4）
```python
>> ~(-5)
>> 4
```
___
```python
# -*- coding:utf-8 -*-
#第一种：
class Solution:
    def NumberOf1(self, n):
        # write code here
        #补码：正数不变，负数是它的正数的反码 + 1
        # -2 补码： -2 的 1 0000.。。000010，
        #                 1 1111.。。111101 + 1
        #-2 的补码就是    1 1111.。。111110
        #把输入的正数n转化为二进制的数，并把0b 替换掉，计算1的数量，如果输入的值不是正数的话
        #一个负整数（或原码）与其补数（或补码）相加，和为模。2 的32 次方 是模。
        #那么就是 2 的32 次方 然后 + n  这是在取一个负数的补码  就相当于  n & 0xffffffff
        #然后计算 这个数里面 1 的 数量
        return bin(n).replace("0b", "").count("1") if n >= 0 else bin(2 ** 32 + n).replace("0b", "").count("1")
#第二种：
# -*- coding:utf-8 -*-
class Solution2:
    def NumberOf1(self, n):
        # write code here
        # 1 出现的次数为0 次
        count = 0
        #判断 这个数 n 是不是负数，如果是负数的话 求其补码：
        if n > 1右移以为来实现，右移以为相当于 是除以2.
            if numsCount[num] > (numLen >> 1):
                return num
        return 0
        #想要空间复杂度为O（1），时间复杂度为o(n)
#第二种：
        #定义变量 上次出现的数字为0
        last = 0
        #上次出现的数字的数量为0 
        lastCount = 0
		#遍历数组中的数字
        for num in numbers:
            #如果说这个数字出现的次数为0了。
            if lastCount == 0:
                #那么就把上次出现的数字，变为需要保存的那个数字。
                last = num
                #并把次数设置为1 次，出现了这一次。
                lastCount = 1
            else:
                #否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.
                if num == last:
                    lastCount += 1
                #如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；
                else:
                    lastCount -= 1
		#如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉
        if lastCount == 0:
            return 0
        #否则的话，就说明 数组里面 留下了没有抵消掉的数
        else:
            #这种情况是last可能是大于一半的数字
            #这个时候把 记录数字次数的变量 计数 为0 
            lastCount = 0
            #遍历数组中的数
            for num in numbers:
                #如果这个数与我们记录的数相等的话
                if num == last:
                    #让这个计数加1
                    lastCount += 1
			#最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.
            if lastCount > (len(numbers)>> 1):