i (cid:3) k :: st, se ⇒ se(i
(cid:2)) :: , se
T P [i] = getﬁeld f
Handler(i) ↓
k ≤ ﬁeldlevel(f)
se = liftk(se, tregion(i))
i (cid:3) k :: st, se ⇒ (ﬁeldlevel(f) (cid:6) se(i)) :: liftk(st), se
Handler(i) ↑
T P [i] = throw
(se(i) (cid:6) k) = L
i (cid:3) k :: st, se ⇒
T P [i] = throw
Handler(i) = i
i (cid:3) k :: st, se ⇒ se(i
(cid:2)) :: , se
(cid:2)
k ≤ se(i
(cid:2))
Figure 7. Typing rules for instructions in JVM.
rity type satisﬁes all the conditions for typing of a bytecode
program.
First, given a source program SP together with a secu-
rity environment E for it we obtain a security environment
se with which to type the compilation of SP .
Deﬁnition 7 ( se determined by E) We deﬁne se by in-
duction on syntax of source commands. The domain of se is
the set of program points in the compilation W(SP ). Deﬁne
se(i) as E(n) where [c]n is the smallest subcommand of SP
whose compilation contains program point i.
Lemma 7.1 Suppose D ::(cid:3) [c]n : k, k
(cid:2) (intro judgement),
let E be the security environment derived from D, and let se
be determined by E. Then se = liftk(cid:2)(se, tregion(n)).
Now we can show that compilation of a command pre-
serves typing in the intermediate system. The following is
proved by induction on the source program.
Lemma 7.2 Let c be a command in source program SP ,
typed (cid:3) c : E, and let [i..j] be the program points in compi-
lation of c. Let se be the security environment determined by
E. Then, for all st there exists sti+1, .., stj such that if we de-
ﬁne sti = st, we have
– l (cid:3) stl, se ⇒ stl(cid:2) , se, for all l (cid:13)→ l
(cid:2), l ∈ {i..j};
– if c is not a throw command, then stj = st;
– if
a
(cid:2), then stn(cid:2) = se(n
sHandler(n) = n
Finally, putting together Lemma 7.2 and Theorem 5.3
exception-throwing
command with
(cid:2)) :: st
[c]n
is
we obtain the main result.
Theorem 7.3 Suppose, for given Γ and ﬁeldlevel, we have (cid:3)
SP , i.e. this source program is typable in the high level system.
Then (cid:3) W(SP ), i.e., its compilation is typable in the target
system.
Example 7.1 The compilation S(c) of the program intro-
duced in Example 5.1 and its types obtained with the Tar-
get type system is shown below. To construct se for this pro-
gram, we use E from Example 5.1 and Deﬁnition 7 to obtain:
se = {1 (cid:13)→ H, 2 (cid:13)→ H, 3 (cid:13)→ H, 4 (cid:13)→ H, 5 (cid:13)→ H, 6 (cid:13)→ H, 7 (cid:13)→
H, 8 (cid:13)→ H, 9 (cid:13)→ H, 10 (cid:13)→ L, 11 (cid:13)→ L, 12 (cid:13)→ L}.
load yH
push 0
prim =
ifeq 8
load xL
store yH
goto 10
push 1
store yH
1
, se
H :: , se
2
H :: H, se
3
H :: , se
4
5
, se
H :: , se
6
7
, se
8
, se
H :: , se
9
10 new C
, se
11 push 3
L :: , se
12 putﬁeld fL L :: L, se
, se
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 05:58:21 UTC from IEEE Xplore.  Restrictions apply. 
It is easy to corroborate that the constraints of the type
system to apply the transfer rules with the types given
above hold. For the ifeq instruction at program point
4, se = liftH(se, tregion(4)) can be checked using re-
gion {5, 6, 7, 8, 9}, obtained according to Deﬁnition
6.
Region of 12 is empty, since it does not have any succes-
sors.
8. Conclusion
The development and deployment of software that re-
spects an end-to-end conﬁdentiality policy requires a num-
ber of ingredients. First, developers must be able to specify
how interfaces relate with the policy using labels. They need
tools to provide them accurate feedback whether their la-
beling is consistent with the policy. Second, execution plat-
forms must reﬂect the assumptions of the policy (e.g. a low
attacker is not able to directly read channels labeled high),
and must feature security functions that enforce the policy.
Veriﬁcation tools for developers and security functions for
execution platforms have a similar purpose, namely to ver-
ify that the labeling is correct and ensures the policy. Estab-
lishing a formal relation between them, and devising means
to exploit the results of source code veriﬁcation for veriﬁ-
cation of executables is a signiﬁcant step towards the adop-
tion of end-to-end security policies in mobile code.
The focus of this paper is on checking that a program
is noninterferent with respect to a given labeling—that is,
controlling ﬁne-grained ﬂows within a program. The paper
follows a long line of work in this area and makes signiﬁ-
cant progress by showing a formal relation between typa-
bility at source code, and bytecode veriﬁcation for an ex-
tended bytecode veriﬁer that enforces noninterference.
In fact we obtained this relation by deriving the typing
systems for source code from the bytecode system. First, we
establish a correspondence between regions in source code
and regions in bytecode. Then we obtain constraints on a
security environment for source fragment c, in terms of re-
gions, by combining the constraints from the bytecode rules
as applied to the compilation of c. Next, we formulate high
level judgements and a connection between them and the
security environment. Finally, this connection is used to ob-
tain a high level rule for each source code construct, using
the constraints in the construct’s intermediate rule and the
deﬁnition of regions for source code.
We have solved the problem of connecting control de-
pendence between source and target language—even reduc-
ing control dependence to an inductive property amenable
to machine veriﬁcation—and we are conﬁdent that our ap-
proach is robust and can be adapted to more sophisti-
cated settings, including richer languages, more sophisti-
cated policies, and optimizing compilers.
Richer languages. Our language already handles some main
complexities of Java, including exceptions and heap allo-
cated mutable objects. The full version of the article also
considers methods and multiple exceptions. We expect to
treat multiple exceptions in a way similar to JFlow (cor-
responding to our single exception eﬀect, JFlow uses a list
of levels indexed by exception types, called “paths”). We
believe that type preservation can be extended to sequen-
tial Java, provided existing type systems at source code
and bytecode are extended appropriately—in particular, it
is possible to treat JVM subroutines, but not so interest-
ing as they will disappear from Java 1.6. The real challenge
is to understand whether type preservation scales up to con-
current Java, but for the time being there is no information
ﬂow type system that has been proved sound for a concur-
rent fragment of Java source code or bytecode.
More sophisticated policies. Practical end-to-end policies
weaker than full non-interference are often needed, e.g., to
cater for downgrading [16] and to connect ﬂow policy with
access controls (based on stack inspection or execution his-
tory) [3, 5]. Such policies are under active investigation but
several current proposals provide source level type systems
to express and statically enforce speciﬁc policies that en-
able declassiﬁcation. We believe that most of these type
systems can be adapted to bytecode in such a way that
type-preservation will be ensured. For example, it is triv-
ial to extend type preservation to an extension of Java with
a cryptographic API where encryption turns secret data
into public one.
Practical enforcement mechanisms for end-to-end poli-
cies are also likely to combine information ﬂow type systems
with other type systems, e.g. for exception analysis, or with
logical veriﬁcation methods. Extending type-preservation
results to combinations of type systems is thus an inter-
esting topic for future work, as is preservation of typabil-
ity/provability in a framework that combines type systems
and logical reasoning.
Optimizing compilers. Common Java compilers such as
Sun’s javac or IBM’s jikes only perform very limited opti-
mizations such as constant folding, dead code elimination,
and rewriting conditionals whose conditions always evalu-
ate to the same constant. These source-to-source transfor-
mations can easily be shown to preserve information-ﬂow
typing; thus type preservation lifts to standard Java com-
pilers.
More aggressive optimizations may break type preserva-
tion, even though they are semantics preserving, and there-
for security preserving. Of course, if the transformations are
made after bytecode veriﬁcation (as in JIT), type preserva-
tion is not needed (instead transformations become part of
the TCB). For example, applying common subexpression
elimination to the program xH := n1 ∗ n2; yL := n1 ∗ n2,
where n1 and n2 are constant values, will result into the pro-
gram xH := n1 ∗ n2; yL := xH. Assuming that variable xH
is a high variable and yL is a low variable, the original pro-
gram is typable, but the optimized program is not, since
the typing rule for assignment will detect an explicit ﬂow
yL := xH. (A naive solution to recover typability is to cre-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 05:58:21 UTC from IEEE Xplore.  Restrictions apply. 
[12] A.C. Myers.
Jﬂow: Practical mostly-static informa-
tion ﬂow control.
In Proceedings of POPL’99, pages
228–241. ACM Press, 1999. Ongoing development at
http://www.cs.cornell.edu/jif/.
[13] F. Nielson, H. R. Nielson, and C. Hankin. Principles of Pro-
gram Analysis. Springer-Verlag, 1999.
[14] V. P. Ranganath, T. Amtoft, A. Banerjee, M. B. Dwyer, and
J. Hatcliﬀ. A new foundation for control-dependence and slic-
ing for modern program structures. In Mooly Sagiv, editor,
Proceedings of ESOP, pages 77–93, 2005.
[15] A. Sabelfeld and A. C. Myers. Language-based information-
ﬂow security. IEEE J. Selected Areas in Communications,
21(1):5–19, January 2003.
[16] A. Sabelfeld and D. Sands. Dimensions and principles of de-
In Proceedings of CSFW’05, pages 255–269.
classiﬁcation.
IEEE Press, 2005.
[17] R. St¨ark, J. Schmid, and E. B¨orger. Java and the Java Vir-
tual Machine - Deﬁnition, Veriﬁcation, Validation. Springer-
Verlag, 2001.
[18] Q. Sun, A. Banerjee, and D.A. Naumann. Modular and
constraint-based information ﬂow inference for an object-
oriented language. In R. Giacobazzi, editor, Proceedings of
SAS’04, volume 3148 of Lecture Notes in Computer Science,
pages 84–99. Springer-Verlag, 2004.
[19] D. Volpano, G. Smith, and C. Irvine. A sound type system for
secure ﬂow analysis. Journal of Computer Security, 4:167–
187, December 1996.
[20] D. Yu and N. Islam. A typed assembly language for conﬁden-
tiality. In Proceedings of ESOP, 2006.
ate a low auxiliary variable zL in which to store the result
of the computation n1 ∗ n2, and assign zL to xH and yL, i.e.
zL := n1 ∗ n2; xH := zL; yL := zL.) Adapting standard pro-
gram optimizations so that they do not break type preser-
vation is left as future work. We conjecture that most opti-
mizations will only need minor modiﬁcations, provided ad-
vanced features of the type system such as label polymor-
phism are available.
Acknowledgments: We thank Mart´ın Abadi, Anindya
Banerjee, Ricardo Medel, Andrei Sabelfeld and anony-
mous reviewers for providing valuable comments.
References
[1] M. Abadi. Secrecy by typing in security protocols. Journal of
the ACM, 46(5):749–786, 1999.
[2] A. Askarov and A. Sabelfeld. Security-typed languages for
implementation of cryptographic protocols: A case study. In
S. De Capitani di Vimercati, P.F. Syverson, and D. Gollmann,
editors, Proceedings of ESORICS’05, volume 3679 of Lecture
Notes in Computer Science, pages 197–221. Springer-Verlag,
2005.
[3] A. Banerjee and D. Naumann. Stack-based access control for
secure information ﬂow. Journal of Functional Programming,
15:131–177, March 2005. Special Issue on Language-Based
Security.
[4] A. Banerjee and D. A. Naumann. Secure information ﬂow
and pointer conﬁnement in a java-like language. In Proceed-
ings of CSFW’02, pages 253–270. IEEE Computer Society
Press, 2002.
[5] A. Banerjee and D.A. Naumann. History-based access con-
trol and secure information ﬂow.
In G. Barthe, L. Burdy,
M. Huisman, J.-L. Lanet, and T. Muntean, editors, Proceed-
ings of CASSIS’04, volume 3362 of Lecture Notes in Com-
puter Science, pages 27–48. Springer-Verlag, 2004.
[6] G. Barthe, A. Basu, and T. Rezk. Security types preserving
compilation. In B. Steﬀen and G. Levi, editors, Proceedings of
VMCAI’04, volume 2934 of Lecture Notes in Computer Sci-
ence, pages 2–15. Springer-Verlag, 2004.
[7] G. Barthe and T. Rezk. Non-interference for a JVM-like lan-
In M. F¨ahndrich, editor, Proceedings of TLDI’05,
guage.
pages 103–112. ACM Press, 2005.
[8] E. Bonelli, A. Compagnoni, and R. Medel. Information ﬂow
analysis for a typed assembly language with polymorphic
stacks. In G. Barthe et al., editor, Post-proceedings of CAS-
SIS 2005: Construction and Analysis of Safe, Secure and In-
teroperable Smart devices, volume 3956 of Lecture Notes in
Computer Science, pages 37–56. Springer-Verlag, 2005.
[9] G. Boudol and I. Castellani. Noninterference for concurrent
programs and thread systems. Theoretical Computer Science,
281(1):109–130, 2002. Preliminary version available as IN-
RIA Research report 4254.
[10] D. Denning. A lattice model of secure information ﬂow. Com-
munications of the ACM, 19(5):236–242, 1976.
[11] R. Medel, A. Compagnoni, and E. Bonelli. A typed assembly
language for non-interference. In Ninth Italian Conference on
Theoretical Computer Science, volume 3701 of Lecture Notes
in Computer Science, pages 360–374, 2005.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 05:58:21 UTC from IEEE Xplore.  Restrictions apply.