be able to detect such an overﬂow since he knows the num-
ber of infected samples, but it would be better to have a
detection mechanism that invalidates all of the results when
the threshold d is surpassed. Thus, here we show how it can
be achieved. The main idea in our solution is as follows:
Alice will transmit to Bob the number of marked customers
(without revealing which customers are infected). If this is
above the threshold d, then he aborts the protocol. Note
that this reveals slightly more information to Bob in that he
now knows exactly the number of infected customers instead
of an estimate of the number of infected customers (which he
obtained from knowing the number of infected samples). As
to not clutter the exposition, we describe only the changes
to the protocol:
Dj = EB “Pi∈Vj
• In Step 5 of the protocol, Alice also generates a value
j .
She transmits these values to Bob in a randomly per-
muted order (to hide which value corresponds to each
customer).
j” for some random value R0
bj · R0
• In Step 6, Bob decrypts the Dj values from Alice and
counts the number of zeroes. If the number is larger
1. Partition the interval of integers [1, m] into αd2 chunks
of size log n each, let Ik denote the kth such chunk.
Our strategy will be to compute each Z0
j as the sum of
αd2 values Zj,k, 1 ≤ k ≤ αd2, where Zj,k is the con-
tribution to Z0
j coming from the rows in row interval
Ik.
2. For k = 1 to αd2 in turn, compute each of Z1,k, . . . , Zn,k
as follows.
(a) For every one of the subsets of the rows in Ik,
compute the product of the Xi’s that correspond
to the rows of that subset. The number of such
subsets is 2|Ik | = 2log n = n, and the computation
of the products for them can be done in O(n)
time by scheduling them in an order such that
each product is obtained with one additional mul-
tiplication (i.e., multiplying one of the already-
computed products by an Xi).
(b) Store the n products computed in the previous
step in an array of size n, so that the value of
each such product can be read in constant time
from the array.
(c) Read from the array created in the previous step
each of Z1,k, . . . , Zn,k.
The time to compute all of Z1,k, . . . , Zn,k in the above algo-
rithm is O(n), and this must be done for αd2 distinct values
of k, resulting in an overall time complexity of O(d2n) for
the algorithm. For a constant d and/or large n, this com-
pares favorably with the naive algorithm’s O(dn log n) time
complexity.
3.3.3 Better handling of the case d = 1
A particularly eﬃcient (log n + 1)-test deterministic CGT
solution exists for the special case of d = 1 [3]. We ﬁrst
brieﬂy describe it, and then point out how the protocol can
be modiﬁed to implement it.
One of the tests performed is for a mixture of all the blood
samples – it serves to determine whether there is contami-
nation somewhere. The remaining log n tests are for deter-
mining which sample is corrupted, and are as follows. For
j = 1, 2, . . . , log n, the jth test is for the mixture of those
samples i for which the integer i has a 1 in the jth least
signiﬁcant bit of its binary representation. After obtaining
the test results, we need to ﬁnd out which sample is contam-
inated. To determine its number, the binary representation
of such sample is constructed one bit at a time, as follows:
For j = 0, . . . , log n − 1 in turn, if the jth test says “contam-
inated” then the jth bit of i is 1, and if it says “clean” then
the bit is 0.
To illustrate this on an example, consider the case of 2000
samples 1, 2, . . . , 2000, of which only one is contaminated
(assume it is the sample 676).
In that case the test of
the mixture of all the 2,000 samples says “contaminated,”
which indicates that there is a contamination. The other
11 (= log n) auxiliary tests reveal which sample is contam-
inated, as follows. The 11-bit binary representation of 676
is 01010100100, and the sample 676 is therefore a part of
the tests for bit positions 2, 5, 7, 9, and it is not a part of
the tests for bit positions 0, 1, 3, 4, 6, 8, 10. The four tests
that contain 676 will say “contaminated,” whereas the other
seven tests will say “clean.” This implies that the contam-
inated sample i has (i) a 1 in bit positions 2, 5, 7, and 9,
of the 11-bit binary representation of i; and (ii) a 0 in bit
positions 0, 1, 3, 4, 6 ,8, 10.
To modify our protocol to take advantage of this faster
algorithm, all that needs to be done is:
1. Change the Vj sets to reﬂect the way the tests are
perform. In this case, m = log n + 1 and for security
reasons we do not have a special treatment for the ﬁrst
test.
2. In Step 6 of the protocol, change the formula for Zj to
Zj = „Yi∈Vj
EB(bi) ·Yi6∈Vj
EB(1 − bi)«Rj
·EB(rj).
Note that, as before, for an infected mix i bi is set to 0
and bi is set to 1 if the mix is clean. It is not diﬃcult to
verify that the above formula will produce the correct
result for all customers in both cases when there are no
infected customers and when there is a single infected
customer.
4. EXPERIMENTAL PERFORMANCE
EVALUATION
The purpose of this section is to demonstrate the per-
formance and scalability of the protocol of Section 3. Our
2000
548
913
3000
577
961
d = 2
d = 3
n
4000
598
996
5000
614
1023
6000
627
1044
Table 1: The number of tests m necessary for vary-
ing values of n and d.
implementation was built and the experiments were run on
a commodity hardware (a 2.67 GHz computer with 2GB
of memory), which should be viewed as modest resources
for data computing centers A and B. But even with such
resources, our protocol scales well to a large number of cus-
tomers. Also note that the protocol will not be invoked with
high frequency, and a rather high overhead can be tolerated.
Our implementation was built using Paillier homomorphic
encryption scheme [13] with 1024-bit modulus and the GMP
large number library [1] and was written in C. Our Paillier
implementation included an optimization for decryption op-
erations as described in [13].
The results reported correspond to the computation car-
ried out for the entire protocol (i.e., the computation per-
formed by A and the computation performed by B). The
communication is not included in the measurements and
such overhead will depend on the type of communication
link between the participants. We only note that Alice and
Bob exchange O(m+n) values during the protocol (and then
distribute n values each to the customers at the end of or
after the protocol).
In the measurements, we separate computation that can
be performed in advance by Alice or Bob (pre-computation)
from the computation that must be performed during the
actual execution of the protocol. Table 1 shows the values
of m used as a function of n and d. Figure 1 shows the
amount of pre-computation needed for the protocol and the
runtime of the protocol with diﬀerent values of n and d (and
the corresponding values of m). From the graphs we can see
that both pre-computation and running times grow linearly
with the number of customers. This growth is expected,
but it is an interesting and somewhat unexpected result that
increasing the threshold d had only a marginal impact on the
performance (recall that increasing d even by 1 signiﬁcantly
increases m).
5. RELATED WORK
Several researchers have studied combinatorial group test-
ing and its applications to cryptography and information
encoding. The work of Colbourn et al. [2] and Du and
Hwang [4] provide broad surveys. Stinson et al. [14] explored
applications of group testing to key distribution in cryptog-
raphy. The ﬁrst work to use group testing for data integrity
was due to Goodrich et al. [9], which established a connec-
tion between data forensics marking and a new reduced-
randomness construction of a non-adaptive combinatorial
group testing scheme. The present paper’s analyses and ex-
periments use the randomized construction of d-disjunct ma-
trices given in [9]. This is the only overlap we have with [9],
whose main focus was to use the randomized construction it
introduced towards the forensic marking of data structures.
Speciﬁcally, it used it for organizing the indexing structures
of how data is stored so that alterations from an original
version can be detected and the changed values speciﬁcally
)
n
i
m
(
e
m
T
i
)
n
i
m
(
e
m
T
i
 35
 30
 25
 20
 15
 10
 22
 20
 18
 16
 14
 12
 10
 8
 6
d=2
d=3
 2000
 3000
 4000
 5000
 6000
Number of customers
d=2
d=3
 2000
 3000
 4000
 5000
 6000
Number of customers
Figure 1: Pre-computation time (left) and runtime
(right) of the protocol.
identiﬁed. It gave forensic constructions for several funda-
mental data structures, including binary search trees, skip
lists, arrays, linked lists, and hash tables.
Much of the group testing literature is on adaptive group
testing schemes, which generally make fewer total tests, in
terms of d and n, than non-adaptive schemes. For exam-
ple, the best known general-purpose adaptive schemes use
O(d log(n/d)) tests, whereas the number of tests used by
the best known general-purpose non-adaptive schemes is
O(d2 log n) [4]. Adaptive schemes are clearly not applicable
in the context of the present paper (as was the case in [9]).
Another area where non-adaptive group testing schemes are
more applicable is in DNA sequence analysis [11].
Another related area is that of Secure Multi-party Com-
putation (SMC), which deals with computing a function over
private inputs without revealing anything other than what
can be computed from the result and some of the inputs
alone. While there are general results stating that any func-
tion can be computed in such a manner [15, 8], these would
lead to ineﬃcient solutions for the PCGT problem. Our
techniques for using the properties of homomorphic encryp-
tion to build a special purpose protocol is reminiscent of
the techniques used in privacy-preserving protocols for: set
operations [5, 10], scalar product [7], and stream searching
[12].
6. CONCLUSIONS
We gave secure and private protocols for combinatorial
group testing of n customers, where the test samples are
prepared by Alice but the tests are carried out by Bob, and
only the customer learns whether it is infected or not. In
addition to the application areas mentioned in the above
(blood testing, data integrity, event stream anomaly), we
believe our techniques may be useful in providing privacy
in the DNA analysis domain (see [11] for a detailed survey
of the use of group testing in DNA analysis). This, how-
ever, requires further investigation because in DNA analysis
group testing is used as one of many steps. We leave this
exploration of DNA analysis privacy for future work.
7. REFERENCES
[1] The GNU multiple precision (GMP) arithmetic
library. http://gmplib.org.
[2] C. J. Colbourn, J. H. Dinitz, and D. R. Stinson.
Applications of combinatorial designs to
communications, cryptography, and networking. In
Walker, editor, Surveys in Combinatorics, volume 187
of London Mathematical Society Lecture Note Series,
pages 37–100. Cambridge University Press, 1993.
[3] R. Dorfman. The detection of defective members of
large populations. Ann. Math. Statist., 14:436–440,
1943.
[4] D.-Z. Du and F. K. Hwang. Combinatorial Group
Testing and Its Applications. World Scientiﬁc, 2nd
edition, 2000.
[5] M. Freedman, K. Nissim, and B. Pinkas. Eﬃcient
private matching and set intersection. In Proceedings
of Advances in Cryptology - EUROCRYPT ’04,
volume 3027 of Lecture Notes in Computer Science,
pages 1–19, 2004.
[6] M. R. Garey and D. S. Johnson. Computers and
Intractability: A Guide to the Theory of
NP-Completeness. W. H. Freeman, New York, NY,
1979.
[7] B. Goethals, S. Laur, H. Lipmaa, and T. Mielikainen.
On private scalar product computation for
privacy-prerving data mining. In The 7th Annual
International Conference on Information Security and
Cryptology (ICISC 2004), 2004.
[8] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game. In Proceedings of the
nineteenth annual ACM conference on Theory of
computing, pages 218–229. ACM Press, 1987.
[9] M. T. Goodrich, M. J. Atallah, and R. Tamassia.
Indexing information for data forensics. In ACNS,
pages 206–221, 2005.
[10] L. Kissner and D. Song. Privacy-preserving set
operations. In Proceedings of Advances in Cryptology -
CRYPTO ’05, volume 3621 of Lecture Notes in
Computer Science, 2005. Full version appears at
http://www.cs.cmu.edu/~leak/.
[11] H. Ngo and D.-Z. Du. A survey on combinatorial
group testing algorithms with applications to dna
library screening. In Discrete Mathematical Problems
with Medical Applications. DIMACS Series, 55,
American Mathematical Society, 2000.
[12] R. Ostrovsky and W. Skeith. Private searching on
streaming data. In CRYPTO, volume 3621 of Lecture
Notes in Computer Science, pages 223–240, 2005.
[13] P. Paillier. Public key cryptosystem based on
composite degree residue classes. In Advances in
Cryptology – EUROCRYPT’99, volume 1592 of LNCS,
pages 223–238, 1999.
[14] D. R. Stinson, T. van Trung, and R. Wei. Secure
frameproof codes, key distribution patterns, group
testing algorithms and related structures. Journal of
Statistical Planning and Inference, 86:595–617, 2000.
[15] A. C. Yao. How to generate and exchange secrets. In
Proceedings of the 27th Annual IEEE Symposium on
Foundations of Computer Science, pages 162–167,
1986.