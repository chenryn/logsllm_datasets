that make it an ideal foundation for an agent system.  Java 
follows  a  so-called  sandbox  security  model,  used  to 
isolate  memory  and  method  access,  and  maintain 
mutually  exclusive  execution  domains.    Java  enforces 
strong type safety using a variety of mechanisms.  Static 
type checking in the form of byte code verification is used 
to check the safety of downloaded code.  Some dynamic 
checking  is  also  performed  during  runtime.    A  distinct 
name space is maintained for untrusted downloaded code, 
and  linking  of  references  between  modules  in  different 
name  spaces  is  restricted  to  public  methods.    A  security 
manager  mediates  all  accesses  to  system  resources, 
serving in effect as a reference monitor.  
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:07:44 UTC from IEEE Xplore.  Restrictions apply. 
A Java language compiler produces byte codes for an 
abstract computer called the Java Virtual Machine, which 
interprets  the  codes  for  the  host  computer  on  which  it 
executes.    More  than  one  Java  Virtual  Machine  (JVM) 
may  be  operating  simultaneously  on  a  host  computer.  
Typically, a single JVM is used to support the execution 
environment for multiple agents (e.g., Aglets [6]), each as 
an  independent  thread,  rather  than  multiple  JVMs  (e.g., 
Nomads  [7]).    Dynamic  class  loading  and  method 
invocation  features  of  the  JVM  provide  a  simple,  but 
effective way to support agent platform extensions.   
Another  feature  supported  by  Java,  is  the  Java 
Archive (JAR) file format, which is based on the de facto, 
standard  ZIP  archive  format  and  useful  for  managing 
collections  of  Java  class  files  and  resources.    It  is  a 
convenient  way  for  packaging  an  agent’s  classes  for 
initial  distribution  and  subsequent  movement  among 
visited platforms.  The contents of JAR files may also be 
signed 
integrity  protection 
purposes.    Thus,  many  Java-based  mobile  agent  systems 
incorporate  this  format  in  their  design  to  protect  and 
simplify  management  of  an  agent’s  code.    A  special 
password-protected  database  of  private  keys  and  their 
associated  digital  certificates,  called  the  key  store,  is 
supported  by  Java  and  its  contents  used  when  signing 
JAR files.   
for  authentication  and 
JAR File
Agent
Attribute
Certificates
Agent Platform
Policy Engine
Key Store
JVM
Policy
Certificates
Policy
File(s)
Figure 5: A Java-based agent system with 
enhancements 
Java provides a single system-wide policy file and an 
optional user policy  file, as  well as a tool for  specifying 
other policies.  Each entry in a policy file indicates the set 
of permissions authorized for code from a specified code 
source.    Policy  rules  are  expressed  using  a  grant-style 
policy  specification  language,  whereby  all  permissions 
are  denied  unless  explicitly  assigned  to  a  code  source.  
Permissions  represent  authorized  actions  on  system 
objects.    The  loader  uses  the  assigned  permissions  to 
manage the name space and form a protection domain for 
any  loaded  code.    Actions  attempted  by  the  code  are 
checked  against  the  domain  permissions  via  the  security 
manager.  Besides standard Java permissions, developers 
may also define permissions specific to an application.  
Figure 5 illustrates a Java-based mobile agent system 
and  the  needed  enhancements  to  enable  processing  of 
privilege management certificates.  Note that each policy-
setting  principal,  as  a  certificate  issuer,  must  hold  a 
cryptographic public key pair for certificate signing.  In a 
Java-based agent system, this requirement results in a key 
store  entry  for  each  principal.    The  sections  that  follow 
discuss an implementation of the enhancements in detail. 
3.1  Policy Certificates 
For any Java-based agent system, the agent platform 
is  a  specialized  application  that  runs  over  the  JVM.  
Rather  than  inventing  a  solution  for  policy  specification 
and  enforcement,  these  systems  normally  rely  on  the 
security  policy  mechanism  afforded  by  the  JVM  via  the 
policy  authorizations  in  the  standard  Java  policy  file(s).  
As noted earlier, the simplest way to capture extant policy 
information  residing  within  system  files  is  to  have  the 
issuer  of  a  policy  certificate  encapsulate  them  (i.e.,  the 
according  Java  policy  files),  by  reference,  within  the 
certificate.    Besides  encapsulated  policy  files,  the  policy 
certificate  conveys  additional  policy  information  related 
to  policy-setting  principals  and  permissions  conveyed 
externally  with  agents. 
  To  illustrate  the  kind  of 
information  useful  in  policy  processing,  the  following 
features were included in the policy certificate: 
•  The ability to specify a policy hierarchy based on 
the class of policy-setting principal, 
•  The ability to govern certificate occurrence, 
•  The ability to stratify permissions into  mutually 
exclusive sets corresponding to and controlled by 
each class of policy-setting principal, and 
•  The  ability  for  non-hosting  principals  to  both 
lower and raise privilege. 
The  policy  hierarchy  specification  was  augmented 
with  the  ability  to  set  the  minimum  and  maximum 
occurrences of each type of certificate.  This information 
allows  the  policy  engine  to  determine  whether  an  agent 
has  sufficient  certificates  to  begin  processing  and  the 
order in which to apply the policy rules.  For example, the 
1  >> 
hierarchy  specification  –    Hosting1
1    –  indicates  that  policies  issued  by  hosting 
Branding1
principals  dominate  policies  issued  by  using  principals, 
which  in  turn  dominate  policies  issued  by  branding 
principals.    The  subscripts  and  superscripts  respectively 
denote 
certificate 
occurrences  for  the  class  of  principal.    Therefore,  the 
example  specification  also  indicates  that  every  agent 
instance  may  have  zero  (i.e.,  the  minimum)  or  one  (i.e., 
the maximum) certificates issued by a using principal, and 
exactly  one  certificate  issued  by  a  branding  principal.  
and  maximum 
1  >>  Using0
the  minimum 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:07:44 UTC from IEEE Xplore.  Restrictions apply. 
to 
relinquishing 
The  policy  hierarchy  specification  is  conveyed  in  the 
“extensions” element of the policy certificate.  It would be 
possible, of course, to introduce finer granularity into the 
hierarchy specification if required.   
To account for hosting principals needing to maintain 
some  control  over  their  computational  resources,  as 
opposed 
them  wholesale,  hosting 
principals,  by  default,  dominate  other  policy-setting 
principals  in  the  policy  hierarchy.    However,  hosting 
principals  can  perform  selective  allocation  of  privilege 
adjustment  to  other  policy-setting  principals  through  a 
sparse  authorization  matrix  (principals  x  permissions) 
within  the  “attributes”  element  of  the  policy  certificate.  
Each  class  of  policy-setting  principal  can  be  granted 
rights  to  raise  or  lower  an  indicated  permission.    If  that 
right is withheld, any unauthorized attempts to adjust the 
permission are ignored and a security notification issued.  
The  approach  is  flexible  and  allows  the  stratification  of 
privileges  into  mutually  exclusive  sets  for  each  class  of 
policy-setting  principle  to  control.    For  example,  using 
principals  may  be  limited  to  controlling  features  of  the 
agent  system,  while  branding  principals,  such  as 
manufacturers, may be limited to certain virtual machine 
resources.   
The  current  version  of  Java  is  designed  with  a 
number of features that allow controlled modification and 
extension to the runtime environment.  They include the 
ability  to  define  new  security  properties,  to  specify  a 
replacement class for the standard policy class, to define 
new permissions, and to place trusted code in a directory 
where it is treated as part of the virtual machine for class 
loading  and  operations.    These  features  were  used  in 
implementing  our  privilege  management  scheme.    By 
replacing 
the  standard  policy  class,  a  new  policy 
certificate  aware  handler  can  be  instantiated  during 
initialization  of  the  JVM.    By  defining  new  security 
properties,  the  handler  is  able  to  locate,  validate,  and 
translate the appropriate policy certificates into an internal 
form  suitable  for  processing  by  the  policy  engine.    By 
defining  a  new  permission,  the  ability  to  adjustment 
permissions  can  be  controlled  through  a  standard  policy 
entry  (see  discussion  below).    Finally,  by  locating 
privilege  management  components  within  the  virtual 
machine  directory  for  trusted  extensions,  they  obtain 
complete access to system level resources. 
Java  policy  is  by  nature  platform-centric.    Standard 
policy  rules  do  not  take  into  account  any  policy-setting 
principals  except  those  associated  with  the  platform, 
namely  the  system  administrator  and  home  user,  which 
are  often  synonymous.    Under  the  grant-styled  policy 
mechanism  of  Java,  the  most  direct  means  of  having 
external  policy  rules  associated  with  an  agent  accepted 
and  incorporated  at  a  platform  is  to  define  a  permission 
that  allows  the  granting  of  those  external  permissions.  
Such a privilege-adjustment permission allows a platform 
by 
privilege-adjustment 
authority to control the privilege not only with respect to 
a  code  source,  but  also  with  respect  to  a  specific  set  of 
policy-setting  principals  who  issue  one  or  the  other 
variant  of  an  attribute  certificate.    The  information 
conveyed 
permissions 
complements  the  more  detailed  information  within  the 
policy  certificate  regarding  the  specific  permissions  a 
class of policy-setting authority can adjust.  One analogy 
is  that  granting  a  privilege-adjustment  permission  to  an 
agent  opens  the  doorway  to  the  room  where  specific 
permission adjustments may occur. 
The  form  of  the  privilege-granting  permission  we 
used  begins  with 
its  name,  “privilegeAdjustment,” 
followed  by  the  key  store  aliases  of  the  permitted 
certificate  issuers  (may  be  any,  represented  by  “*”),  and 
completed  by  either  of  the  actions,  “sealedBy”  for 
branding principals or “launchedBy” for using principals.  
In  simple  terms,  the  permission  grants  an  agent’s  code 
source the right to gain the privileges expressed within an 
attribute  certificate 
issued  by  some  policy-setting 
principal  to  either  the  agent  or  an  instance  of  the  agent.  
For example, to permit any agent’s code base, sealed by a 
trusted  reviewer  (i.e.,  the  enterprise  security  officer 
(ESO)) and launched by any trusted user (i.e., one having 
an entry in the key store), to adjust its platform privileges 
(i.e., be accepted for privilege adjustment processing), the 
Java policy rule would be  
Grant { 
Thus,  the  standard  Java  policy  mechanisms  can  be 
extended  in  a  manner  suitable  for  meeting  the  security 
policy 
systems.  
Implementing the scheme as described, does not affect the 
syntax or structure of Java policy files, which remain the 
primary means for expressing platform policy.  Instead of 
replacing policy files, policy certificates incorporate their 
contents through reference.  This approach allows policy 
certificates to be issued to any standard Java policy file by 
a policy-setting principal in the same manner as attribute 
certificates  are  issued  to  an  agent  –  via  a  cryptographic 
hash of the contents of the policy file. 
Permission privilegeAdjustment “*”  
Permission privilegeAdjustment “ESO”  
   }; 
        “launchedBy”; 
         “sealedBy”; 
requirements 
of  most 
agent 
3.2  Attribute Certificates 
An  attribute  certificate 
is  an  external  XML 
representation  of  the  policy  rules  assigned  to  an  agent.  
For  a  Java  environment,  the  policy  is  represented  as 
standard 
the 
“attributes”  element  of  the  attribute  certificate.    The 
responsibility 
attribute 
certificates  with  an  agent  as  it  moves  among  platforms 
Java  permissions 
conveyed  within 
for  maintaining 
relevant 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:07:44 UTC from IEEE Xplore.  Restrictions apply. 
Because  of 
to  simplify 
to  a  certificate,  and 
falls  to  the  agent  system.    Java-based  mobile  agent 
systems usually allow movement of mobile code as either 
individual class files or a JAR file.  Because JAR files are 
the  prescribed  means  within  the  Java  framework  for 
signing  and  verifying  code,  most  security-conscious 
designers  incorporate  them  into  the  agent  system.    In 
addition to the archived code, a signed JAR file contains a 
pair of files, a signature instruction and a digital signature 
file, for each signer of one or more of the files contained 
in  the  archive.    These  files  are  maintained  in  a  special 
directory  –  the  META-INF  directory.    Additional  meta-
information, such as the identity certificates of the entity 
that  signed  the  code,  may  also  be  included  within  the 
META-INF  directory 
the  verification 
processing of the JAR contents by a recipient. 
its  flexibility  for  conveying  meta-
information,  an  agent’s  JAR  file  also  makes  a  suitable 
container  for  attribute  certificates  issued  to  the  agent.  
Once  the  agent's  code  resides  within  the  JAR,  it  can  be 
cryptographically  bound 
the 
certificate  placed  within  the  META-INF  directory  for 
subsequent  use. 
can  be 
accommodated  to  support  policies  involving  multiple 
policy-setting principals.  Not confusing the standard Java 
security features regarding signed JAR files with those of 
attribute  certificates  is  important.    In  principle,  they  are 
distinct and can be applied either individually or jointly.  
The  described  JAR  extensions  follow  this  principle.  
However,  some  redundancy  exists  in  situations  where  a 
branding  principal  issues  an  attribute  certificate  for  an 