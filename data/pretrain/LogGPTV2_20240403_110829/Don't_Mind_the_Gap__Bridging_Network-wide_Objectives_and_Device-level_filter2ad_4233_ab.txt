plementation is appealing because X and Y do not need to be
made aware of which preﬁxes are global versus local and IP
address assignment can occur independently, e.g., local ser-
vices can be assigned new preﬁxes without updating those
routers’ conﬁgurations.
However, this implementation has incorrect behavior in
the face of failures. Suppose links X–G and X–H fail. Then,
X will hear announcements for PL* from C and D, having
traversed from G and H to Y to C and D. Per its policy im-
plementation, X will start "leaking" these preﬁxes externally.
Depending on the rationale for local services, this leak could
impact security (e.g., if the services are sensitive) or avail-
ability (e.g., if the PL* preﬁxes are reused for other services
outside of the datacenter). This problem does not manifest
without failures because then X has and prefers paths to PL*
2For scale and policy ﬂexibility, datacenter networks in-
creasingly use BGP internally, with a private AS number per
router [19].
330
through G and H since they are shorter. A similar problem
will occur if links Y–G and Y–H fail. Link failures in dat-
acenters are frequent and it is not uncommon to have many
failed links at a given time [16].
To avoid this problem, the operator may disallow "val-
ley" paths, i.e., those that go up, down, and back up again.
This guard can be implemented by X and Y rejecting paths
through the other. But that creates a different problem in the
face of failures—an aggregation-induced black hole [20]. If
links D–A and X–C fail, X will hear an announcement for
PG2 from D and will thus announce PG externally. This an-
nouncement will bring trafﬁc for PG1 to X as well, but be-
cause valleys are disallowed, X does not have a valid route
for PG1 and will drop all trafﬁc for it despite the fact that a
valid path exists through Y .
Thus, we see that devising a conﬁguration that ensures
policy compliance in the face of failures is complex and
error-prone. Propane lets operators implement their high-
level policy speciﬁcation in a way that guarantees compli-
ance under all failures if possible—otherwise, it generates a
compile-time error. For aggregation, it also provides a lower
bound to operators on the number of failures under which
aggregation will not result in black holes.
4. PROPANE OVERVIEW
Policies for (distributed) control planes differ from data-
plane policies in a few important ways. First, they must ac-
count for all failures at compile time; there is no controller
at runtime, so the routers must be conﬁgured in advance to
handle failures in a compliant manner. In Propane, we en-
able such speciﬁcations through path preferences, with the
semantics that a less-preferred path is taken only when a
higher-preference path is unavailable in the network. Sec-
ond, paths in a control-plane policy may be under-speciﬁed
(e.g., "prefer customer" does not indicate a concrete path).
The Propane compiler treats such under-speciﬁcations as
constraints on the set of allowed paths and automatically
computes valid sets based on the topology.
This section introduces the Propane language using the
examples from the previous section. The next section de-
scribes the complete syntax of the language as well as our
strategy for compiling it to BGP.
4.1 Example 1: The backbone
Propane lets operators conﬁgure the network with the ab-
straction that they have centralized control over routing. Specif-
ically, the operator simply provides a set of high-level con-
straints that describe the paths trafﬁc should—or should not—
take and their relative preferences. Propane speciﬁcations
are written modularly via a series of declarations. For exam-
ple, to begin speciﬁcation of the backbone network from the
previous section, we ﬁrst express the idea that we prefer that
trafﬁc leave the network through R1 over R2 (to Cust) over
Peer over Prov (policy P1 and P3 from Figure 1):
define Prefs = exit(R1 » R2 » Peer » Prov)
This statement deﬁnes a set of ranked paths, which includes
all paths (and only those paths) for which trafﬁc exits our
331
network through either router R1, router R2, Peer, or Prov.
The paths that exit through R1 are preferred (») to those
that exit through R2, which are preferred to those that leave
through Peer and then Prov. As we describe in the next
section, the exit expression, as well as other path expres-
sions used later in this section, is simply a shorthand for a
particular regular expression over paths that is expressible in
our policy language. The preference operator (») is ﬂexible
and can be used between constraints as well as among indi-
vidual routers. For example, the above constraint could have
been written equivalently as exit(R1) ». . . » exit(Prov)
To associate ranked paths with one or more preﬁxes, we
deﬁne a Propane policy. Within a policy, statements with the
form t => p associate the preﬁxes deﬁned by the predicate
t with the set of ranked paths deﬁned by the path expres-
sion p. In general, preﬁx predicates can be deﬁned by ar-
bitrary boolean combinations (and, or, not) of concrete pre-
ﬁxes and community tags. Here, we assume we have already
deﬁned the predicate PCust for the customer preﬁxes. In the
following code, ranked paths are associated with customer
preﬁxes, and all other preﬁxes (true). Policy statements
are processed in order with earlier policy statements taking
precedence over later policy statements. Hence, when the
predicate true follows the statement involving PCust, it is
interpreted as true & !PCust.
define Routing =
{PCust => Prefs & end(Cust)
true
=> Prefs }
Line 2 of this policy restricts trafﬁc destined to known
customer preﬁxes (PCust) to only follow paths that end at
the customer. In addition, it enforces the network-wide pref-
erence that trafﬁc leaves through R1 over R2 over Peer over
Prov. Line 3 applies to any other trafﬁc not matching PCust
and allows the trafﬁc to leave through any direct neighbor
with the usual preference of R1 over R2 over Peer over
Prov. To summarize our progress, the Routing policy im-
plements P1, P3, and P4 from Figure 1.
Since, routing allows transit trafﬁc by default (e.g., trafﬁc
entering from Peer and leaving through Prov), we sepa-
rately deﬁne a policy to enforce P2 and P5 from Figure 1,
using conjunction (&), disjunction (|) and negation (!) of
constraints. First, we create reusable abstractions for de-
scribing trafﬁc that transits our network. In Propane, this
is done by creating a new parameterized deﬁnition.
define transit(X,Y) = enter(X|Y) & exit(X|Y)
define cust-transit(X,Y) = later(X) & later(Y)
Here we deﬁne transit trafﬁc between groups of neighbors
X and Y as trafﬁc that enters the network through some
neighbor in X or Y and then also leaves the network through
some neighbor in either X or Y . Similarly, we deﬁne cus-
tomer transit for customer X and provider Y as trafﬁc that
later goes through both X and Y after leaving our network.
Using these two new abstractions, we can now implement
policies P2 and P5 with the following constraint.
define NoTrans =
{true => !transit(Peer,Prov) &
!cust-transit(Cust,Prov)}
The NoTrans constraint requires that all trafﬁc not follow a
path that transits our network between Peer and Prov. Ad-
ditionally, it prevents trafﬁc from ever following paths that
leave our network and later go through both Prov and Cust.
To implement both Routing and NoTrans simultaneously,
we simply conjoin them: Routing & NoTrans.
Collectively, the constraints above capture the entire pol-
icy. From them, our compiler will generate per-device im-
port and export ﬁlters, local preferences, MED attributes,
and community tags to ensure that the policy is implemented
correctly under all failures.
4.2 Example 2: The datacenter
Our datacenter example network has three main concerns:
(1) trafﬁc for the preﬁx allocated to each top-of-rack router
must be able to reach that router, (2) local services must not
leak outside the datacenter, and (3) aggregation must be per-
formed on global preﬁxes to reduce churn in the network.
Propane allows modular speciﬁcation of each of these
constraints. The ﬁrst constraint is about preﬁx ownership—
we want trafﬁc only for certain preﬁxes to end up at a partic-
ular location. The following deﬁnition captures this intent.
define Ownership =
{PG1 => end(A)
PG2 => end(B)
PL1 => end(E)
PL2 => end(F)
true => end(out)}
This deﬁnition says that trafﬁc for preﬁx PG1 is allowed to
follow only paths that end at router A; trafﬁc for PG2, but not
PG1, must end at router B; and so on. Any trafﬁc destined for
a preﬁx that is not a part of the datacenter should be allowed
to leave the datacenter and end at some external location,
which is otherwise unconstrained. The special keyword out
matches any location outside the datacenter network, while
the keyword in will match any location inside the network.
For the second constraint, we deﬁne another policy:
define Locality =
{PL1 | PL2 => only(in)}
This deﬁnition says that trafﬁc for local preﬁxes only follows
paths that are internal to the network at each hop. This con-
straint guarantees that the services remain accessible only to
locations inside the datacenter.
As in the backbone example, we can logically conjoin
these constraints to specify the network-wide policy. How-
ever, in addition to constraints on the shape of paths, Propane
allows the operator to specify constraints on the BGP con-
trol plane itself. For instance, a constraint on aggregation
is included to ensure that aggregation for global preﬁxes is
performed from locations inside (in) the network to loca-
tions outside (out). In this case, PG1 and PG2 will use the
aggregate PG (which we assume is deﬁned earlier) when ad-
vertised outside the datacenter.
Ownership & Locality & agg(PG, in -> out)
Figure 3: Compilation pipeline stages for Propane.
Once Propane compiles the policy, it is guaranteed to re-
main compliant under all possible failure scenarios, modulo
any aggregation-induced black holes. In the presence of ag-
gregation, the Propane compiler will also efﬁciently ﬁnd a
lower bound on the number of failures required to create an
aggregation-induced black hole.
5. COMPILATION
The examples above use what we call the front end (FE)
of Propane. It simpliﬁes operators’ task of describing pre-
ferred paths, but that simplicity comes at the cost of compila-
tion complexity. The compiler must efﬁciently compute the
sets of paths represented by the intersection of preferences
and topology and ensure policy compliance under all failure
scenarios.
To handle these challenges, we decompose compilation
into multiple stages, shown in Figure 3, and develop efﬁcient
algorithms for the translation between stages. The ﬁrst stage
of the pipeline involves simple rewriting rules and substitu-
tions from the FE to the core Regular Intermediate Represen-
tation (RIR). Policies in RIR are checked well-formedness
(e.g., never constraining trafﬁc that does not enter the net-
work), before being combined with the topology to obtain
the Product Graph Intermediate Representation (PGIR). The
PGIR is a data representation that compactly captures the
ﬂow of BGP announcements subject to the policy and topol-
ogy restrictions. We develop efﬁcient algorithms that op-
erate over the PGIR to ensure policy compliance under fail-
ures, avoid BGP instability, and prevent aggregation-induced
black holes. Once the compiler determines safety, it trans-
lates the PGIR to an abstract BGP (ABGP) representation.
ABGP can then be translated into various vendor-speciﬁc
device conﬁgurations as needed.
5.1 Regular IR (RIR)
The Propane FE is just a thin layer atop the RIR for de-
scribing preference-based path constraints. Figure 4 shows
the RIR syntax. A policy has one or more constraints. The
ﬁrst kind of constraint is a test on the type of route and a cor-
responding set of preferred regular paths. Regular paths are
regular expressions where the base characters are abstract
locations representing either a router or an external AS. Spe-
cial in and out symbols refer to any internal or external
location respectively. In addition, Σ refers to any location.
We also use the standard regular expression abbreviation r+
for r· r∗, a sequence of one or more occurrences of r. Predi-
cates (t) consist of logical boolean connectives (and, or, not)
332
Syntax
Propane Expansions
::= p1, . . . , pn
::= t => r1» . . . »rm | cc
pol
p
x ::= d.d.d.d/d
t
any = out∗ · in+ · out∗
drop = ∅
::= true
|
!t
|
t1|t2
|
t1&t2
|
preﬁx = x
|
comm = d
::= l
∅
|
|
in
|
out
r1 ∪ r2
|
|
r1 ∩ r2
|
r1 · r2
|
!r
|
r∗
::= agg(x, ln) | tag(d, t, ln)
Figure 4: Regular Intermediate Representation (RIR) syntax (left), and Propane language expansions (right).
internal = in+
only(X) = any ∩ X∗
never(X) = any ∩ (!X)∗
through(X) = out∗ · in∗ · X · in∗ · out∗
later(X) = out∗ · (X ∩ out) · out∗ · in+ · out∗
before(X) = out∗ · in+ · out∗ · (X ∩ out) · out∗
end(X) = any ∩ (Σ∗ · X)
start(X) = any ∩ (X · Σ∗)
exit(X) = (out∗ · in∗ · (X ∩ in) · out · out∗)∪
enter(X) = (out∗ · out · (X ∩ in) · in∗ · out∗)∪
link(X, Y ) = any ∩ (Σ∗ · X · Y · Σ∗)
(out∗ · in+ · (X ∩ out) · out∗)
(out∗ · (X ∩ out) · in+ · out∗)
novalley( (cid:126)X) = any ∩
path( (cid:126)X) = any ∩ (Σ∗ · X1 . . . Xn · Σ∗)
!path(X2, X1, X2) ∩ ···∩
!path(Xn, Xn−1, Xn)
policies
constraints
preﬁx
true
negation
disjunction
conjunction
preﬁx test
community test
location
empty set
internal loc
external loc
union
intersection
concatenation
path negation
iteration