title:Automated Behavioral Fingerprinting
author:J&apos;erôme François and
Humberto J. Abdelnur and
Radu State and
Olivier Festor
Automated Behavioral Fingerprinting
J´erˆome Fran¸cois1,2, Humberto Abdelnur1, Radu State3, and Olivier Festor1
1 MADYNES - INRIA Nancy-Grand Est, France
{firstname.lastname}@loria.fr
2 CNRS, Nancy-Universit´e, France
3 University of Luxembourg, Luxembourg
PI:EMAIL
Abstract. This paper addresses the ﬁngerprinting of devices that speak
a common, yet unknown to the ﬁngerprinting engine, protocol. We con-
sider a behavioral approach, where the ﬁngerprinting of an unknown
protocol is based on detecting and exploiting diﬀerences in the observed
behavior from two or more devices. Our approach assumes zero knowl-
edge about the syntax and state machine underlying the protocol. The
main contribution of this paper consists in a two phased method. The
ﬁrst phase identiﬁes the diﬀerent message types using an unsupervised
support vector clustering algorithm. The second phase is leveraging re-
cent advances in tree support kernel in order to learn and diﬀerentiate
diﬀerent implementations of that protocol. The key idea is to represent
behavior in terms of trees and learn the distinctive subtrees that are
speciﬁc to one particular device. Our solution is passive and does not
assume active and stimulus triggered behavior templates. We instanti-
ate our solution to the particular case of a VoIP speciﬁc protocol (SIP)
and validate it using extensive data sets collected on a large size VoIP
testbed.
1 Introduction
Over the past few years, there has been an increased eﬀort in the research com-
munity towards the automated analysis and reverse engineering of network pro-
tocols. The driving forces are multiple and range from practical needs to analyze
network traﬃc generated by malware where the most notorious case is the Storm
bot and up to the development of open source implementation for poorly doc-
umented protocols, as it was the case of the SMB protocol [1] for example. A
related problem is the automated and passive ﬁngerprinting of devices using
an unknown protocol. While some research eﬀorts in this direction have been
recently made in [2] in order to learn the syntax and grammar that generated
the protocol messages, to our knowledge, none until now has addressed the au-
tomated learning of the speciﬁc behavior of a protocol in order to ﬁngerprint
a device or a protocol stack. [3] and [4] are close and complementary works as
they aim to learn an unknown protocol to automatically respond to requests.
E. Kirda, S. Jha, and D. Balzarotti (Eds.): RAID 2009, LNCS 5758, pp. 182–201, 2009.
c(cid:2) Springer-Verlag Berlin Heidelberg 2009
Automated Behavioral Fingerprinting
183
The research challenges that we face are related to learning the relevant protocol
operations/primitives and modeling the protocol message sequences such that
automated learning is possible. If packet captures from an unknown protocol are
given, we aim ﬁrst to automatically discover the unknown types of messages. We
assume furthermore that no learning set with labeled protocol messages exists,
that no encryption is used and that no reverse engineering of the application
using such a protocol is possible. We also assume that the number of diﬀerent
message types is a-priori unknown.
Reverse engineering of network protocols is clearly related to the security
problem since understanding the protocols is a necessary step for detecting pro-
tocol misuse. In addition, ﬁngerprinting is a useful task in the security domain.
For an attacker, ﬁngeprinting is a prior work for performing eﬃcient attacks. For
a network administrator, it is a tool for security assessment and testing.
The two contributions presented in this paper are:
– the automated analysis of protocols with respect to the types of messages
exchanged based on unsupervised learning methods. For instance, if we con-
sider a stripped-oﬀ ICMP version, an ICMP echo request message has to
be answered by an ICMP echo reply message; assuming that a collection of
captured messages is available, our approach should automatically discover
that several types of messages exist (ICMP echo request and ICMP echo
reply). Thus, our technique can be used as an essential preprocessing phase
to the automated learning of the protocol related state machine;
– the learning of the device/stack speciﬁc behavior that results from recon-
structing/reverse engineering a state machine for a device under test. In
the previous example of ICMP for instance, it may be possible to detect a
speciﬁc device by peculiar behavior related features. Although ICMP is a
simple protocol, a large and comprehensive research work [5] (using mostly
manual and tedious tests) showed that reliable ﬁngerprinting is possible. We
address a new and automated research direction that leverages support vec-
tor machines and tree kernels for learning structural behavior features of the
underlying protocol.
The paper is structured as follows: related work is analyzed in the next section;
the SIP protocol that we use as the ﬁrst application case is described in the third
section; the diﬀerent metrics to classify the messages are presented in section 4.
Message types identiﬁcation methods and results are described in section 5.
Section 6 focuses on the behavioral ﬁngerprinting. Finally, the last section con-
cludes the paper and sketches future research directions.
2 Related Works
Automatically recognizing the diﬀerent messages of a protocol without prior
knowledge is a challenging task. This is one part of the reverse protocol engi-
neering goals which also aims to clearly infer the syntax and grammar of messages
i.e., the diﬀerent ﬁelds. Historically, the ﬁrst technique available was hand-based
184
J. Fran¸cois et al.
analysis of dump ﬁles provided by packet sniﬃng software like tcpdump [6]. Ob-
viously, this technique is tedious, limited and very time consuming. Therefore,
new methods appeared. The Protocol Informatics project [7] proposes a solution
which uses well known bioinformatics algorithms and techniques based on se-
quence alignment. Given a set of messages protocols, the program tries to deter-
mine both constant and variable ﬁelds. Several approaches consider the context
semantics i.e., the target computer behavior itself: [2] looks for extracted bytes
in the message to rebuild the diﬀerent ﬁelds; [8] is based on the execution trace
i.e., system calls; [9] proposes a dynamic binary analysis to identify separators
and keywords; [10] introduces a semi-supervised learning method to determine
the message ﬁelds. Closer to our goal, an approach to cluster the messages cap-
tured on the network by types before trying to infer their format is proposed
in [11]. To achieve this clustering, the authors propose to tokenize each message
i.e., to ﬁnd the diﬀerent ﬁelds by considering that each binary bytes is a binary
token and that each text sequence between two binary bytes is a ﬁeld. The tech-
nique proposed in [12] is also based on identifying the diﬀerent ﬁelds thanks to
a delimiter. This is done by instrumenting the protocol application by studying
how the program parses the messages. [13] focuses more on the state machine
construction of multiple ﬂows protocol. Application dialog replay is a very close
domain since its goal is to construct a valid replay dialog by identifying the
contents which need to be modiﬁed thanks to sequence alignment techniques [3]
or by building a model from application inputs and outputs [14]. ScriptGen [4]
is another approach which is able to construct the partial state-machine of a
protocol based on network traces in order to automatically generate responses
to attacker requests sent to a honeypot. Network and service ﬁngerprinting is a
common task is security assessment, penetration testing and intrusion detection.
The key assumption is that subtle diﬀerences due to development choices and/or
incomplete speciﬁcation can trace back the speciﬁc device/protocol stack [15].
There are excellent tools that implement such schemes: p0f [16] uses TCP/IP
ﬁelds to passively identify the signature of a TCP/IP stack, while nmap [17] does
actively follow a stimulus-response test in order to detect the operating system
and service versioning of a remote device. [18] aims to construct automatically
the ﬁngerprints by active probing. The research community has addressed the
ﬁngerprinting of SIP devices [19,20] by automatically constructing message spe-
ciﬁc ﬁngerprints. In [21] and [22], the goal is a little bit diﬀerent because the
authors aim to correctly identify the ﬂow types i.e., the protocols used. In a pre-
vious contribution [23], we have addressed a syntax driven ﬁngerprinting, where
parse trees of captured messages were used to learn distinctive features capable
to perform ﬁngerprinting. In that study, we assumed that BNF [24] speciﬁcations
are available and that individual messages can be used to infer vendor/stack spe-
ciﬁc implementation characteristics. This is diﬀerent from the current approach
where no a-priori knowledge of the syntax is assumed. Secondly, we did not con-
sider until now the behavioral aspects for the ﬁngerprinting task. In this paper
we do consider the latter and we leverage diﬀerences in induced state machines
in order to perform ﬁngerprinting.
3 Session Initiation Protocol (SIP)
Automated Behavioral Fingerprinting
185
SIP [25] is the de-facto signalisation protocol for the management of VoIP com-
munications. Its main features are related to the establishment, tear-down and
negotiation of VoIP sessions and it comprises a rich set of protocol primitives
and options as well as a complex underlying state machine. We consider SIP
to illustrate our approach for several reasons. Firstly, the number of operations
is relatively important (more than 10). Secondly, due to its design, a clear de-
limitation of transport level information and network level information does
not exist, thus making the automated analysis diﬃcult. Thirdly, the distribu-
tion of individual message types is quite unbalanced: some message types ap-
pear very rarely such that small sided and under-represented classes have to
be dealt with. Although a complete overview of SIP is beyond the scope of
this paper, a short introduction is given below. SIP messages are divided into
two categories: requests and responses. Each request begins with one of the fol-
lowing keywords: REGISTER, OPTIONS, INVITE,UPDATE, CANCEL, ACK, BYE,
SUBSCRIBE, NOTIFY, PRACK, PUBLISH, INFO, REFER, MESSAGE. The SIP re-
sponses begin with a numerical code of 3 digits divided into 6 classes identiﬁed
by the ﬁrst digit.
A SIP transaction is illustrated in the ﬁgure 1. It is an usual example when
PI:EMAIL wants to call user2@domain2.com. So user1 initiates the
connection by sending an INVITE request. First, the callee user2 informs that
it receives the request and will try to achieve its by the Trying message. The
Ringing message means that the user is alerted of the incoming call. When user2
decides to accept the call, the OK response is sent. The caller acknowledges
this one and the media session over RTP (Realtime Transport Protocol) [26]
is established. Finally, user2 hangs the phone, a BYE message is sent and the
other party send an OK response to accept the ending of the session. Obviously,
many details are omitted like the negotiation of parameters.
We have built a dataset of 1580 SIP messages, generated using several phones
coming from diﬀerent manufacturers. In our traces we minded 27 diﬀerent kinds
Fig. 1. SIP transaction example
186
J. Fran¸cois et al.
SIP messages distribution
0.25
 0.2
0.15
 0.1
0.05
 0
1-2
0-
0
O
0
1-1
0-
0
TI
0
P
O
1-4
R
E
G
A
0-
0-IN
0
VIT
1
IS
T
0-
N
C
K
1-1
TIF
8
O
E
Y
N
S
E
R
S
A
G
E
1-4
0-
0
0
7
1-5
0-
0-IN
F
1
0
Y
B
E
1-1
1-4
1-5
1-4
1-4
1-2
M
E
8
0
0
4
3
3
8
8
1
6
2
0-
0
1-6
0-
0
R
E
1-4
1-4
0-
1
8
P
1-4
U
A
C
0
5
N
O
S
3
F
E
R
C
E
L
B
8
7
LIS
H
Fig. 2. SIP messages distribution
of message which are the most important and used in VoIP networks. Their
empirical distribution is illustrated in ﬁgure 2.
Regarding SIP as a target protocol, we would like to be able to automatically
identify the 27 types of messages and automatically build tools that can identify
abnormal sequences which are not compliant with the protocol, but can be linked
to a speciﬁc SIP stack and/or vendor. We had to use a known protocol (SIP)
in order to be able to assess the accuracy and precision of our approach but
it can be generalized towards any protocol. One of the key components is the
diﬀerentiation among several method types with appropriate metrics.
4 Metrics and Distances for Protocol Messages
Character distribution. The character distribution d of a message is based on
the statistical distribution of its characters. Intuitively, if two messages ma and
mb are of the same type, their distributions should be similar. The natural and
logical measure is the symmetric relative entropy or Kullback-Leibler divergence:
char dist(ma, mb) =
(cid:2)
i
d(ma)ilog( d(ma)i
d(mb)i
) +
(cid:2)
i
d(mb)ilog( d(mb)i
d(ma)i
)
(1)
where i represents all possible characters.
Relative character distribution. An alternative character distribution can be
constructed to capture the relative character distribution of the message m:
rel char dist. It is based on the distribution of characters but can deal with
simple enciphering schemes like for example the per character XOR encryption.
It uses an ordered distribution [27] of the character frequencies. Thanks to this
metric we have:
rel char dist(m ⊕ k) = rel char dist(m)∀ key k
(2)
Automated Behavioral Fingerprinting
187
Character position. A third metric that can be associated to each message is
the character position. Basically, each message of a protocol has diﬀerent ﬁelds
and each message of the same type usually has common ﬁeld ﬁlled with similar
content. Therefore, the character at a certain position is often the same for a cer-
tain type of message. This metric char pos(m) determines the average position
of each character of the message m:
char pos(m)(c) =
(3)
(cid:3)i=k
i=1 pos(ai)
k
where i is the index of the character c with k occurrences in the message and
pos() the function returning the position of the index of a given character.
Weighted character position. Most protocol messages are formed by a header
containing the type of the message followed by options, arguments and an addi-
tional payload. This comes from good and established protocol design patterns.
The weighted char pos(m) balances more the ﬁrst characters:
(cid:3)i=k
∀ character c occurring k times, p2(m)(c) =
i=1 pos(ai)−1
k
(4)
The key assumption is that messages of the same types should start with similar
headers even if the message contents are totally diﬀerent.
5 Automated Protocol Clustering
Using the previously deﬁned metrics, we derive an unsupervised clustering
method that combines two clustering methods in order to determine the number
of diﬀerent messages types. The ﬁrst technique is a new method relying on unsu-
pervised support vector clustering [28]. The second method is based on the well
known agglomerative nearest neighbor method [29]. This last technique consid-
ers each data point as an individual cluster. The two clusters with the smallest
inter-distance are merged into one. Then, this step is repeated until the smallest
inter-distance is higher than a threshold t.
5.1 Support Vector Clustering
The support vector clustering (SVC) technique has been introduced in [28] and
leverages machine learning paradigms based on support vector machines (SVM)
[30] techniques. Such techniques show good accuracy with a limited overhead in
diﬀerent domains [31]. The initial data points 3(a) are mapped from the input