DM V.address : V oter.address as address,
DV M.address (cid:54)= V oter.address as mixedAddress,
V oter.name (cid:54)= NULL as registered
from DM V left join V oter
on DM V.ID = V oter.ID
stateB = select ...
resultA = select stateA.SSN
stateA.address as addressA
stateB.address as addressB
stateA.registered
stateB.registered
from stateA inner join stateB
on stateA.SSN = stateB.SSN
where (stateA.date < stateB.date and stateA.registered)
or (stateA.registered
and stateB.registered)
resultB = select ...
Figure 10: SQL styled join query for the ERIC voter registration application.
Once the parties construct the tables in Figure 10, state A can query the table
stateA to reveal all IDs and addresses where the mixedAddress attribute is set to
true. This reveals exactly the people who have conï¬‚icting addresses between that
stateâ€™s voter and DMV databases. When comparing voter registration data between
5The hashing originally performed by ERIC can be replaced with the randomized encoding
protocol.
35
1. Pp uniformly samples a bijection Ï€0 : [n] â†’ [n] and let Ï€1 : [n] â†’ [m] s.t. Ï€1â—¦Ï€0 = Ï€.
Parameters: 3 parties denoted as Pp, Ps and Pr. Elements are strings in Î£ := {0, 1}Ïƒ.
An input, output vector size of n, m.
[Permute] Upon the command (Permute, Ï€,A0) from Pp and (Permute,A1)
from Ps. Require that Ï€ : [m] â†’ [n] is injective andA0,A1 âˆˆ Î£n. Then:
2. Ps sends B := (AÏ€0(1)1 âŠ• S1, ...,AÏ€0(n)1 âŠ• Sn) to Pr.
3. Pp sends Ï€1 and T â† Î£m to Pr who outputsA(cid:48)0 := {BÏ€1(1)âŠ•T1, ..., BÏ€1(m)âŠ•Tm}.
Pp outputsA(cid:48)1 := {SÏ€1(1) âŠ• T1 âŠ•AÏ€(1)0, ..., SÏ€1(m) âŠ• Tm âŠ•AÏ€(m)0}.
Pp sends Ï€0 and S â† Î£n to Ps.
Figure 11: The Oblivious Permutation Network protocol Î permute repeated.
Parameters: 3 parties denoted as the Pp, Ps and Pr. Elements are strings in Î£ := {0, 1}Ïƒ.
An input vector size of n and output size of m.
[Permute] Upon
(Permute, Ï€,A0)
from the Pp
and
the
command
(Permute,A1) from the Ps:
3. GenerateA(cid:48) and sendA(cid:48)0 to Pp andA(cid:48)1 to Pr.
1. Interpret Ï€ : [m] â†’ [n] as an injective function and A âˆˆ Î£n.
2. Compute A(cid:48) âˆˆ Î£m s.t. âˆ€i âˆˆ [m], AÏ€(i) = A(cid:48)
i.
Figure 12: The Oblivious Permutation Network ideal functionality Fpermute.
states, state B should deï¬ne stateB in a symmetric manner as stateA. The table
resultA contains all of the records which are revealed to state A and resultB, which
is symmetrically deï¬ned, contains the results for state B. We note that resultA and
resultB can be constructed with only one join.
Both types of these queries can easily be performed in our secure framework.
All of the conditional logic for the select and where clauses are implemented using
a binary circuit immediately after the primary join protocol is performed. This has
the eï¬€ect that overhead of these operation is simply the size of the circuit which
implements the logic times the number of potential rows contained in the output.
B Omitted Proofs
B.1 Permutation Network
We now formally prove that the oblivious permutation network protocol in Figure 5
and repeated in Figure 11 is secure with respect to the Fpermute functionality of
Figure 12.
36
Theorem 1. Protocol Î permute of Figure 11 securely realized the ideal functionality
Fpermute of Figure 12 given at most one party is corrupted in the semi-honest model.
Proof. Correctness follows directly from Ï€1 â—¦ Ï€0 = Ï€ and that the masks cancel out.
With respect to simulation, consider the following three cases:
1. Corrupt Pp: The view of Pp contains no messages and therefore is trivial to
simulation.
2. Corrupt Ps: The view of Pp contains Ï€1, S which are sent by Pp. The simulator
can uniformly sample Ï€1 : [m] â†’ [n] from all such injective functions and
uniformly sample S â† Î£n. Clearly S has the same distribution.
With respect to Ï€1, observe if Ï€1 if ï¬rst ï¬xed uniformly at random then there
are exactly (n âˆ’ m)! ways to choose Ï€0. Moreover, for each choice of Ï€1 there
is a disjoint set of possible Ï€0 values. Therefore, Pp sampling Ï€0 uniformly at
random results in the distribution of Ï€1 also being uniform.
3. Corrupt Pr: The view of Pr contains B := (AÏ€0(1) âŠ• S1, ..., AÏ€0(n) âŠ• Sn) and
Ï€1, T âˆˆ Î£m. Ï€1, T are sampled uniformly and therefore trivial to simulation.
similarly, each Bi = AÏ€0(i)âŠ• Si where Si is uniformly distributed in their view.
Therefore Bi is similarly distributed.
B.2 Duplication Network
We now formally prove that the oblivious duplication network protocol in Figure 5
and repeated in Figure 11 is secure with respect to the Fdup functionality of Fig-
ure 14.
Theorem 2. Protocol Î duplicate of Figure 13 securely realized the ideal functionality
Fduplicate of Figure 14 given at most one party is corrupted in the semi-honest
model.
Proof. Correctness follows an inductive argument. It is easy to verify B1 =A11
Biâˆ’1 =AÏ€(iâˆ’1)1 and we will show that Bi =AÏ€(i)1. Observe that for i âˆˆ [2, n]
and that this is correct since Ï€(1) = 1 by deï¬nition. Inductively let us assume that
Bi0 = M bi
i
= biAi0 âŠ• biBiâˆ’11 âŠ•Bi1 âŠ• W biâŠ•Ï†i
= biAi0 âŠ• biBiâˆ’1 âŠ•Bi1
i
i âŠ• biBiâˆ’10
i âŠ• biBiâˆ’10
âŠ• W Ïi
âŠ• W Ïi
And therefore B = Ï€(A1) and
37
the
command
(Duplicate, Ï€,A0)
Parameters: 3 parties denoted as Pp, Ps and Pr. Elements are strings in Î£ := {0, 1}Ïƒ.
An input, output vector size of n.
[Duplicate] Upon
Ï€(i) âˆˆ {i, Ï€(i âˆ’ 1)} for i âˆˆ [2, n] and A âˆˆ Î£n. Then:
1. Pp computes the vector b âˆˆ {0, 1}m such that b1 = 0 and for i âˆˆ [2, n], bi = 1 if
(Duplicate,A1) from Ps. Require that Ï€ :
2. Ps samplesB1, W 0, W 1 â† Î£n,B10 â† Î£ and Ï† â† {0, 1}n. Ps redeï¬neB11 :=
A11 âŠ•B10. For i âˆˆ [2, n], Ps sends
and
[n] â†’ [n] s.t Ï€(1) = 1 and
Ï€(i) = Ï€(i âˆ’ 1) and 0 otherwise.
from Pp
i :=Ai1 âŠ•Bi1 âŠ• W Ï†i
i :=Biâˆ’11 âŠ•Bi1 âŠ• W Ï†i
i
i
M 0
andB10, Ï† to Pp. Ps sendsB1, W 0, W 1 to Pr.
M 1
3. Pp sends Ï := Ï† âŠ• b, R â† Î£n to Pr who responds with {W Ïi
: i âˆˆ [2, n]}. For
i
i âˆˆ [2, n], Pp deï¬nes
Pp outputsA(cid:48)0 :=B0 âŠ• R âŠ• Ï€(A0) and Pr outputsA(cid:48)1 :=B1 âŠ• R.
i âŠ• W Ïi
Bi0 := M bi
i âŠ• biBiâˆ’10
Figure 13: The Oblivious Duplication Network protocol Î duplicate repeated.
Parameters: 3 parties denoted as the Pp, Ps and Pr. Elements are strings in Î£ := {0, 1}Ïƒ.
An input vector size of n and output size of n.
[Duplicate] Upon the
command (Duplicate, Ï€,A0)
(Duplicate,A1) from the Ps:
from the Pp
and
1. Interpret Ï€ : [n] â†’ [n] as a function s.t. Ï€(1) = 1, Ï€(i) âˆˆ {i, Ï€(iâˆ’ 1)} for i âˆˆ [2, n]
and A âˆˆ Î£n.
2. Compute A(cid:48) âˆˆ Î£m s.t. âˆ€i âˆˆ [n], AÏ€(i) = A(cid:48)
i.
3. GenerateA(cid:48) and sendA(cid:48)0 to Pp andA(cid:48)1 to Pr.
Figure 14: The Oblivious Duplication Network ideal functionality Fduplicate.
38
A(cid:48) =B1 âŠ• R âŠ• Ï€(A0) âŠ•B1 âŠ• R
=B âŠ• Ï€(A0)
=Ï€(A1) âŠ• Ï€(A0)
=Ï€(A)
With respect to simulation, consider the following three cases:
{0, 1}n from Ps and W biâŠ•Ï†i
uniformly and therefore can be simulated as the same.
1. Corrupt Pp: The transcript of Pp contains M 0, M 1 âˆˆ Î£n,B10 âˆˆ Î£, Ï† âˆˆ
from Pr. First observe thatB10, Ï† are sampled
i =... âŠ•Bi1
Next recall that
i
M bi
i =... âŠ• W biâŠ•Ï†i
M bi
i
where Bi1, W biâŠ•Ï†i
i
âˆˆ Î£ are sampled uniformly can not in the view of Pp.
Therefore M 0
i , M 1
i are distributed uniformly.
2. Corrupt Ps: The transcript of Ps contains nothing and therefore is trivial to
simulate. Note that the distribution of the output shares in independent of
Psâ€™s random tape (view) due to Pp, Pr re-randomizing the shares with R â† Î£n.
3. Corrupt Pr: The transcript of Pr containsB11, W 0, W 1 from Ps and Ï from
same. B11 = A1 âŠ•B10 whereB10 is sampled uniformly and not in the
view. ThereforeB11 is distributed uniformly. The same applies to Ï since
Pp. W 0, W 1 are sampled uniformly and therefore can be simulated as the
Ï† is uniform and not in the view.
B.3 Switching Network
We now formally prove that the oblivious switching network protocol in Figure 5
and repeated in Figure 15 is secure with respect to the Fswitch functionality of
Figure 16. In the proof we will replace calls to the Permutaiton and Duplication
protocols of Î Switch with their ideal functionalities (Figure 12, 14).
Theorem 3. Protocol Î Switch of Figure 15 securely realized the ideal functionality
Fswitch of Figure 16 given at most one party is corrupted in the semi-honest model.
39
1. Pp samples an injection Ï€1
:
[m] â†’ [n] s.t.
Parameters: 3 parties denoted as Pp, Ps and Pr. Elements are strings in Î£ := {0, 1}Ïƒ.
An input, output vector size of n, m.
for i âˆˆ image(Ï€) and k =
|preimage(Ï€, i)|, âˆƒj where Ï€1(j) = i and {Ï€1(j + 1), ..., Ï€1(j + k)} âˆ© image(Ï€) = âˆ….
[Switch] Upon the command (Switch, Ï€,A0) from Pp and (Switch,A1) from Ps
where Ï€ : [m] â†’ [n] andA0,A1 âˆˆ Î£n.
Pp sends (Permute, Ï€1,A0) to FPermute and Ps sends (Permute,A1). Pp
receivesB0 âˆˆ Î£m in response and Pr receivesB1 âˆˆ Î£m.
send (Duplicate, Ï€2,B0) and (Duplicate,B1) to FDuplicate. As a result Pp
obtainsC0 âˆˆ Î£m from FDuplicate and Ps obtainsC1 âˆˆ Î£m.
sends (Permute, Ï€3,C0) to FPermute and Ps sends (Permute,C1). Pp receives
S âˆˆ Î£m in response. Pp and Pr respectively receives and outputsA(cid:48)0,A(cid:48)1 âˆˆ Î£m.
3. Pp computes the permutation Ï€3 : [m] â†’ [m] such that for i âˆˆ image(Ï€) and
k = |preimage(Ï€, i)|, {Ï€3((cid:96)) : (cid:96) âˆˆ preimage(Ï€, i)} = {j, ..., j+k} where i = Ï€1(j). Pp
2. Pp deï¬nes Ï€2 : [m] â†’ [m] s.t.
for i âˆˆ image(Ï€) and k := |preimage(Ï€, i)| and
j where Ï€1(j) = i, then Ï€2(j) = ... = Ï€2(j + k) = j. Pp and Pr respectively
Figure 15: The Oblivious Switching Network protocol Î switch repeated.
Parameters: 3 parties denoted as the Pp, Ps and Pr. Elements are strings in Î£ := {0, 1}Ïƒ.
An input vector size of n and output size of m.
[Switch] Upon the command (switch, Ï€,A0) from the Pp and (switch,A1) from
the Ps:
1. Interpret Ï€ : [m] â†’ [n] and A âˆˆ Î£n.
2. Compute A(cid:48) âˆˆ Î£m s.t. âˆ€i âˆˆ [m], AÏ€(i) = A(cid:48)
i.
3. GenerateA(cid:48) and sendA(cid:48)0 to Pp andA(cid:48)1 to Pr.
Figure 16: The Oblivious Switching Network ideal functionality Fswitch repeated.
40
Proof. Correctness follows from the ï¬rst oblivious permutation call rearranges the
input vector such that each output item which appears k times is followed by k âˆ’ 1
items which do not appear in the output. The duplication network then copies each
of these output items into the next k âˆ’ 1 position. The ï¬nal permutation places
these items in the ï¬nal order.
With respect to simulation, the transcript of each party contains their transcripts
of three subprotocols: Permute, Shared-Duplicate and Shared-Permute. By Theo-
rem 1 the Permute subprotocol transcript can be simulated. Similarly, Theorem 1,2
also imply that the other two transcripts can be simulated. Therefore this implies
that the overall protocol can be simulated given that no other communication is
performed.
B.4 Join Protocol
Theorem 4. Protocol Î join of Figure 6 securely realized the ideal functionality Fjoin
of Figure 7 given at most one party is corrupted in the semi-honest FPermute,FSwitch,Fencode-
hybrid model with statistical security parameters Î».
Proof. First we demonstrate the correctness of the protocol. Recall that the set of
non-join keys {(XJ1||...||XJl)[i] | i âˆˆ [n]} are all distinct. The same holds true for
the Y table. As such, P0 receives n uniformly random values from Fencode. As
discussed in 3.2, given that these encodings are of length at least Î» + 2 log2(n) bits,
then with probability 1 âˆ’ 2âˆ’Î» all the encodings are distinct.
Recall that P1 then constructs a cuckoo hash table using the encodings Ey. Given
that cuckoo hash table is parameterized as described in [DRRT18], this succeeds with
overwhelming probability, i.e. 1 âˆ’ 2âˆ’Î».
The correctness of the rest of the protocol is straight forward. The shared table
(cid:74)Y(cid:75) are permuted to form a shared cuckoo hash table(cid:74)T(cid:75). Based on the encodings
Ex, the shares in the table T are mapped to the corresponding row of X. It is easy
to verify that if Y has a matching row then it will have been mapped. Finally, Fmpc
is used to compute the circuit which constructs the output table.
With respect to simulation, consider the following cases:
1. Corrupt P0: The transcript of P0 contains the encodings Ex, the output(cid:98)Y l0
from FSwitch, and the output of Fmpc. Given that the inputs to Fencode are
either set to or all distinct values, the output Ex is uniformly distributed and
therefore can be sample as such by the simulator. Similarly, the output of
FSwitch,Fmpc are both uniform.
2. Corrupt P1: The transcript of P1 contains the encodings Ey, the output(cid:98)T1
from FPermute, the output(cid:98)Y l1 from FSwitch, and the output of Fmpc. All
of these are distributed uniformly. The simulation of this transcript follows
the same as that of P0.
41
3. Corrupt P2: The transcript of P2 contains the output (cid:98)T0 from FPermute,
the output (cid:98)Y l0 from FSwitch, and the output of Fmpc. All of these are
distributed uniformly. The simulation of this transcript follows the same as
that of P0.
42