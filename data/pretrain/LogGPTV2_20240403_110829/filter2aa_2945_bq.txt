    }
}
Other than the statement that accesses the indexer, there are two further
points of interest in this code:
The static String method IsNullOrEmpty is used to determine
whether a string is empty or contains a null value. This is the
preferred method for testing whether a string contains a value. It
returns true if the string contains a null value or it is an empty
Download from finelybook PI:EMAIL
561
string; otherwise, it returns false.
The ? : operator used by the statement that populates the Text
property of the phone- Number text box on the form. Remember
that this operator acts like an inline if…else statement for an
expression. In the preceding code, if the expression
String.IsNullOrEmpty (personsPhoneNumber.Text) is true, no
matching entry was found in the phone book and the text “Not
Found” is displayed on the form; otherwise, the value held in the
Text property of the personsPhoneNumber variable is displayed.
2. Locate the findByPhoneNumberClick method in the MainPage.xaml.cs
file. It is below the findByNameClick method.
The findByPhoneNumberClick method is called when the Find By
Phone Number button is clicked. This method is currently empty apart
from a // TODO: comment. You need to implement it as follows (the
completed code is shown in bold in the example that follows):
a. Read the value of the Text property from the phoneNumber box on the
form. This is a string containing the phone number that the user has
typed.
b. If the string is not empty, use the indexer to search for the name
corresponding to that phone number in the PhoneBook.
c. Write the Text property of the Name structure returned by the indexer
to the name box on the form.
The completed method should look like this:
Click here to view code image
private void findByPhoneNumberClick(object sender,
RoutedEventArgs e)
{
    string text = phoneNumber.Text;
    if (!String.IsNullOrEmpty(text))
    {
        PhoneNumber personsPhoneNumber = new PhoneNumber(text);
        Name personsName = this.phoneBook[personsPhoneNumber];
        name.Text = String.IsNullOrEmpty(personsName.Text) ?
          "Not Found" : personsName.Text;
    }
}
Download from finelybook PI:EMAIL
562
3. On the Build menu, click Build Solution, and then correct any errors that
occur.
Test the application
1. On the Debug menu, click Start Debugging.
2. Type your name and phone number in the appropriate boxes, and then
expand the command bar and click Add. (You can expand the command
bar by clicking the ellipsis.)
When you click the Add button, the Add method stores the information
in the phone book and clears the text boxes so that they are ready to
perform a search.
3. Repeat step 2 several times with some different names and phone
numbers so that the phone book contains a selection of entries. Note that
the application performs no checking of the names and telephone
numbers that you enter, and you can input the same name and telephone
number more than once. For the purposes of this demonstration, to avoid
confusion, be sure that you provide different names and telephone
numbers.
4. Type a name that you used in step 3 into the Name box, and then click
Find By Name.
The phone number you added for this contact in step 3 is retrieved from
the phone book and is displayed in the Phone Number text box.
5. Type a phone number for a different contact in the Phone Number box,
and then click Find By Phone Number.
The contact name is retrieved from the phone book and is displayed in
the Name box.
6. Type a name that you did not enter in the phone book into the Name
box, and then click Find By Name.
This time, the Phone Number box displays the message “Not Found.”
7. Close the form, and return to Visual Studio 2017.
Download from finelybook PI:EMAIL
563
Summary
In this chapter, you saw how to use indexers to provide array-like access to
data in a class. You learned how to create indexers that can take an index and
return the corresponding value by using logic defined by the get accessor, and
you saw how to use the set accessor with an index to populate a value in an
indexer.
If you want to continue to the next chapter, keep Visual Studio 2017
running and turn to  Chapter 17, “Introducing generics.”
If you want to exit Visual Studio 2017 now, on the File menu, click
Exit. If you see a Save dialog box, click Yes and save the project.
Quick reference
To
Do this
Specify an integer value
using binary or
hexadecimal notation
Use the 0b0 (for binary values) or 0x0 (for
hexadecimal values) prefixes. Include “_”
separators to make values easier to read. For
example:
Click here to view code image
uint moreBinData =
0b0_11110000_01011010_11001100_ 00001111;
uint moreHexData = 0x0_F0_5A_CC_0F;
Display an integer value as
its binary or hexadecimal
representation
Use the Convert.ToString method, and specify
2 (for binary) or 16 (for hexadecimal) as the
number base. For example:
Click here to view code image
uint moreHexData = 0x0_F0_5A_CC_0F;
Console.WriteLine($"
{Convert.ToString(moreHexData, 2)}");
// displays
11110000010110101100110000001111
Create an indexer for a
class or structure
Declare the type of the indexer, followed by
the keyword this, and then the indexer
arguments in square brackets. The body of the
Download from finelybook PI:EMAIL
564
indexer can contain a get and/or set accessor.
For example:
Click here to view code image
struct RawInt
{
  ...
  public bool this [ int index ]
  {
      get { ... }
      set { ... }
  }
  ...
}
Define an indexer in an
interface
Define an indexer with the get and/or set
keywords. For example:
Click here to view code image
interface IRawInt
{
    bool this [ int index ] { get; set; }
}
Implement an interface
indexer in a class or
structure
In the class or structure that implements the
interface, define the indexer and implement the
accessors. For example:
Click here to view code image
struct RawInt : IRawInt
{
    ...
    public bool this [ int index ]
    {
      get { ... }
      set { ... }
    }
    ...
}
Implement an indexer
defined by an interface by
using explicit interface
implementation in a class
or structure
In the class or structure that implements the
interface, specify the interface but do not
specify the indexer accessibility. For example:
Click here to view code image
struct RawInt : IRawInt
Download from finelybook PI:EMAIL
565
{
    ...
    bool IRawInt.this [ int index ]
    {
      get { ... }
      set { ... }
    }
    ...
}
Download from finelybook PI:EMAIL
566
CHAPTER 17
Introducing generics
After completing this chapter, you will be able to:
Explain the purpose of generics.
Define a type-safe class by using generics.
Create instances of a generic class based on types specified as type
parameters.
Implement a generic interface.
Define a generic method that implements an algorithm independent of
the type of data on which it operates.
Chapter 8, “Understanding values and references,” shows you how to use
the object type to refer to an instance of any class. You can use the object
type to store a value of any type, and you can define parameters by using the
object type when you need to pass values of any type into a method. A
method can also return values of any type by specifying object as the return
type. Although this practice is very flexible, it puts the onus on the
programmer to remember what sort of data is actually being used. This can
lead to run-time errors if the programmer makes a mistake. In this chapter,
you will learn about generics, a feature that has been designed to help you
prevent this kind of mistake.
The problem: Misusing with the object type
Download from finelybook PI:EMAIL
567
To understand generics, it is worth looking in detail at the problem they are
designed to solve.
Suppose that you need to model a first-in, first-out structure such as a
queue. You could create a class such as the following:
Click here to view code image
class Queue
{
    private const int DEFAULTQUEUESIZE = 100;
    private int[] data;
    private int head = 0, tail = 0;
    private int numElements = 0;
    public Queue()
    {
       this.data = new int[DEFAULTQUEUESIZE];
    }
    public Queue(int size)
    {
       if (size > 0)
       {
           this.data = new int[size];
       }
       else
       {
           throw new ArgumentOutOfRangeException("size", "Must be
greater than zero");
       }
    }
    public void Enqueue(int item)
    {
       if (this.numElements == this.data.Length)
       {
           throw new Exception("Queue full");
       }
       this.data[this.head] = item;
       this.head++;
       this.head %= this.data.Length;
       this.numElements++;
    }
    public int Dequeue()
    {
       if (this.numElements == 0)
       {
           throw new Exception("Queue empty");
       }
Download from finelybook PI:EMAIL
568
       int queueItem = this.data[this.tail];
       this.tail++;
       this.tail %= this.data.Length;
       this.numElements--;
       return queueItem;
    }
}
This class uses an array to provide a circular buffer for holding the data.
The size of this array is specified by the constructor. An application uses the
Enqueue method to add an item to the queue and the Dequeue method to pull
an item from the queue. The private head and tail fields keep track of where
to insert an item into the array and where to retrieve an item from the array.
The numElements field indicates how many items are in the array. The
Enqueue and Dequeue methods use these fields to determine where to store
or retrieve an item and perform some rudimentary error checking. An
application can create a Queue object and call these methods, as shown in the
code example that follows. Notice that the items are dequeued in the same
order in which they are enqueued:
Click here to view code image
Queue queue = new Queue(); // Create a new Queue
queue.Enqueue(100);
queue.Enqueue(-25);
queue.Enqueue(33);
Console.WriteLine($"{queue.Dequeue()}"); // Displays 100
Console.WriteLine($"{queue.Dequeue()}"); // Displays -25
Console.WriteLine($"{queue.Dequeue()}"); // Displays 33
Now, the Queue class works well for queues of ints, but what if you want
to create queues of strings, or floats, or even queues of more complex types
such as Circle (see Chapter 7, “Creating and managing classes and objects”),
or Horse or Whale (see Chapter 12, “Working with inheritance”)? The
problem is that the way in which the Queue class is implemented restricts it
to items of type int, and if you try to enqueue a Horse, you will get a
compile-time error.
Click here to view code image
Queue queue = new Queue();
Horse myHorse = new Horse();
queue.Enqueue(myHorse); // Compile-time error: Cannot convert from
Horse to int
One way around this restriction is to specify that the array in the Queue
Download from finelybook PI:EMAIL
569
class contains items of type object, update the constructors, and modify the
Enqueue and Dequeue methods to take an object parameter and return an
object, such as in the following:
Click here to view code image
class Queue
{
    ...
    private object[] data;
    ...
    public Queue()
    {
       this.data = new object[DEFAULTQUEUESIZE];
    }
    public Queue(int size)
    {
       ...
       this.data = new object[size];
       ...
    }
    public void Enqueue(object item)
    {
       ...
    }
    public object Dequeue()
    {
       ...
       object queueItem = this.data[this.tail];
       ...
       return queueItem;
    }
}
Remember that you can use the object type to refer to a value or variable
of any type. All reference types automatically inherit (either directly or
indirectly) from the System.Object class in the Microsoft .NET Framework
(in C#, object is an alias for System.Object). Now, because the Enqueue and
Dequeue methods manipulate objects, you can operate on queues of Circles,
Horses, Whales, or any of the other classes that you have seen earlier in this
book. However, it is important to notice that you have to cast the value
returned by the Dequeue method to the appropriate type because the compiler
will not perform the conversion from the object type automatically.
Click here to view code image
Download from finelybook PI:EMAIL
570
Queue queue = new Queue();
Horse myHorse = new Horse();
queue.Enqueue(myHorse); // Now legal – Horse is an object
...
Horse dequeuedHorse = (Horse)queue.Dequeue(); // Need to cast object
back to a Horse
If you don’t cast the returned value, you will get the compiler error
“Cannot implicitly convert type ‘object’ to ‘Horse.’” This requirement to
perform an explicit cast degenerates much of the flexibility afforded by the
object type. Furthermore, it is very easy to write code such as this:
Click here to view code image
Queue queue = new Queue();
Horse myHorse = new Horse();
queue.Enqueue(myHorse);
...
Circle myCircle = (Circle)queue.Dequeue(); // run-time error
Although this code will compile, it is not valid and throws a
System.InvalidCastException exception at runtime. The error is caused by
trying to store a reference to a Horse in a Circle variable when it is dequeued,
and the two types are not compatible. This error is not spotted until runtime
because the compiler does not have enough information to perform this check
at compile time. The real type of the object being dequeued becomes
apparent only when the code runs.
Another disadvantage of using the object approach to create generalized
classes and methods is that it can consume additional memory and processor
time if the runtime needs to convert an object to a value type and back again.
Consider the following piece of code that manipulates a queue of int values:
Click here to view code image
Queue queue = new Queue();
int myInt = 99;
queue.Enqueue(myInt); // box the int to an object
...
myInt = (int)queue.Dequeue(); // unbox the object to an int
The Queue data type expects the items it holds to be objects, and object is
a reference type. Enqueueing a value type, such as an int, requires it to be
boxed to convert it to a reference type. Similarly, dequeueing into an int
requires the item to be unboxed to convert it back to a value type. (See the
sections “Boxing” and “Unboxing” in Chapter 8 for more details.) Although
Download from finelybook PI:EMAIL
571
boxing and unboxing happen transparently, they add performance overhead
because they involve dynamic memory allocations. This overhead is small for
each item, but it adds up when a program creates queues of large numbers of
value types.
The generics solution
C# provides generics to remove the need for casting, improve type safety,
reduce the amount of boxing required, and make it easier to create
generalized classes and methods. Generic classes and methods accept type
parameters, which specify the types of objects on which they operate. In C#,
you indicate that a class is a generic class by providing a type parameter in
angle brackets, like this:
class Queue
{
     ...
}
The T in this example acts as a placeholder for a real type at compile time.
When you write code to instantiate a generic Queue, you provide the type
that should be substituted for T (Circle, Horse, int, and so on). When you
define the fields and methods in the class, you use this same placeholder to
indicate the type of these items, like this:
Click here to view code image
class Queue
{
    ...
    private T[] data; // array is of type 'T' where 'T' is the type
parameter
    ...
    public Queue()
    {
       this.data = new T[DEFAULTQUEUESIZE]; // use 'T' as the data
type
    }
    public Queue(int size)
    {
       ...
       this.data = new T[size];
       ...
Download from finelybook PI:EMAIL
572
    }
    public void Enqueue(T item) // use 'T' as the type of the method
parameter
    {
       ...
    }
    public T Dequeue() // use 'T' as the type of the return value
    {
        ...
       T queueItem = this.data[this.tail]; // the data in the array
is of type 'T'