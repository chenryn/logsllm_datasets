case demonstrates FANS’s ability to discover meaningful
bugs. Google has already ﬁxed this vulnerability and assigned
CVE-2019-2088 to us. So we do not give the mitigation here.
5.4.3 Case Study III: Stack Overﬂow Inside ip(6)tables-
restore
Attack An unexpected stack overﬂow bug is found to re-
side in the ip(6)tables-restore binary. As we focus on An-
droid native system services, we do not ﬁnd the vulner-
ability directly. It is found when we fuzz the netd dae-
mon, whose interface ﬁle is generated automatically. We
craft in_ifName with a sufﬁciently long string quoted in
the transaction Call::WAKEUPADDINTERFACE, then it calls
wakeupAddInterface. Finally it triggers the stack overﬂow
vulnerabilities in the add_param_to_argv function.
Figure 7 gives the detailed execution path. However, we
still need to craft in_ifName carefully as the string is de-
serialized from data parcel through readUtf8FromUtf16
which executes many checks. To take the last step towards
successful attack, FANS tags in_ifName with utf8=true
when extracting the interface model. Later FANS uses the
corresponding serialization method writeUtf8AsUtf16 to
serialize in_ifName into data, which can pass the sanity
checks. In contrast, BinderCracker [6] may well miss such
transactions because popular apps rarely use them. Even if it
could get such a transaction input format, it would randomly
mutate the trafﬁc which is likely to fail quickly in the checks
mentioned above.
AttackernetdwakeupAddInterfaceaddInterfaceexecIptablesexecutemainadd_param_to_argvip(6)tables-restoreInsight This vulnerability crosses three processes: attacker
process, netd and ip(6)tables-restore. In other words,
this bug is buried deep. Furthermore, although we mainly
focus on fuzzing Android native system services, we ﬁnd a
vulnerability in a Linux component. It suggests that there is a
close relationship between Android system services and basic
Linux components. In the light of this, we can assert that there
is another way to fuzz Linux components. Besides, these two
bugs are also present in iptable package and can be found
on a regular Linux distribution. They have been ﬁxed by the
netﬁlter team in April 2019 and assigned CVE-2019-11360.
So here we do not give the mitigation. However, at the time
of writing this paper, they have not been ﬁxed in Android.
6 Discussion
We have demonstrated FANS’s effectiveness in excavating
vulnerabilities in the Android native system service. Now we
discuss its limitations and what we will do in the future.
Interface Model Accuracy Although we have tried our
best to extract the interface models, the interface model is
not perfect. For example, we assume that the loop size is the
previous variable before the loop when we can not get the
loop size directly. However, for loop statements that traverse
a linked list, the loop size is undetermined, not as we guess. In
such circumstances, we believe that it is not easy to improve
it. Besides, even if a developer deﬁnes a semantic type some-
where, he might accidentally use the original type instead of
the type alias. Thus we can not get a more semantic variable
type, which would also affect the variable dependency gener-
ation. Other than those mentioned above, the dependency we
got might be incomplete because there might exist speciﬁc
order between the transaction calls as service can be seen as
a state machine. However, as we are fuzzing, if we always
follow the speciﬁed order, we may miss some vulnerabili-
ties. Meanwhile, we have already found some vulnerabilities
caused by incomplete state machine processing in service.
Coverage Guided Fuzzing Nowadays, coverage guided
fuzzing is popular. For FANS, even though we do not use
coverage knowledge of Android native system services, we
ﬁnd many vulnerabilities in system services audited by many
experts. However, to our belief, guided with coverage, FANS
can ﬁnd more vulnerabilities. Moreover, as system service is
state-sensitive, its coverage might be affected by inputs gen-
erated previously or by other applications’ calls. This could
be a challenge when integrating coverage to FANS.
Fuzzing Efﬁciency As some Android system services run
as a daemon or might check the caller’s permission, for conve-
nience, we run fuzzer as root. Nevertheless, the root privilege
is very high, which can change lots of things. During the
experiment, we found that a smartphone can enter into re-
covery mode even just after starting the fuzzer ten minutes.
As a result, we needed to ﬂash the phone manually, which
signiﬁcantly affects the efﬁciency of FANS. We think this can
be solved, either limiting the privilege of fuzzer or ﬁnding a
way to ﬂash the device automatically.
Interface-based Fuzzing in Android In Android 9, there
mainly exists three kinds of services located in different do-
mains: normal domain, vendor domain and hardware domain.
In Pixel series products, applications can access only normal
domain services registered in the service manager. In this pa-
per, we mainly pay attention to the native system services in
normal domain. However, these three kinds of services share
the same architecture in the aspect of communication and in-
terface implementation. Consequently, we could easily trans-
fer the method demonstrated in this paper to other domain
services, even service implemented in Java language. Besides,
there also exist some similar interfaces, i.e., customized in-
terfaces, which do not belong to the parts mentioned above.
These interfaces are designed to be implemented and instan-
tiated by applications and passed to the server-side by the
clients. We can also fuzz these implementations with the
methods proposed in this paper. The major drawback is that
we need to instantiate these interfaces manually.
7 Related Work
IPC and Service Security in Android While the security
of the Android operating system has always been the focus
of academic and industrial research, similar researches for
IPC and system services are deﬁcient. In early times, vul-
nerable Intents were widely exploited in attacking userland
applications. Therefore, the main target of the previous re-
searches [2, 11, 16] on IPC in Android was the Intent.
Gong [7] is the ﬁrst one who paid attention to the Binder
IPC interface. He pointed out Binder is the actual security
boundary of Android system services, and proved it inse-
cure by discovering critical vulnerabilities manually. Wang
et al. [12] further proposed a solution to fuzz Java interfaces
generated from AIDL ﬁles, while Chizpurﬂe [10] targeted
vendor implemented Java services. Further, there are some
researches [3,26] that focus on input validation vulnerabilities
related to Android services. Several other researches [1,8,17]
concentrate on the inconsistency of access control in the An-
droid framework related to Android services.
BinderCracker [6] extends the testing to native services. It
monitors the IPC trafﬁc of several popular user apps, and tries
to understand the input model and transaction dependencies
through the recorded trafﬁc, then generates new test cases
accordingly. However, this solution highly depends on the
diversity of the recorded trafﬁc and is not effective. First, it
cannot systematically recognize all interfaces including multi-
level interfaces to test, and cannot recognize the complete
dependencies between interfaces, either. Second, the interface
model and the transaction dependencies inferred from the
trafﬁc are neither (1) complete, since the trafﬁc may overlook
rarely-used transactions; nor (2) precise, since the inference is
made from data which has lost many information (e.g., types).
Fuzzing for Structured Input Numerous approaches have
been proposed to generate structured input for fuzzing. Gen-
erally, they fall into two categories. Generation-based fuzzers
generates test cases from templates or predeﬁned grammar.
Peach [5] is one of the most popular fuzzer based on tem-
plates. DomFuzz [15] utilized grammar to generate dom
structures for the target program. These methods suffer man-
ual participation and poor scalability. Thus more advanced
researches [9, 20, 22, 23] are proposed to handle this limi-
tation. Mutation-based fuzzers mutate existing test cases to
generate new ones without any input grammar or input model.
VUzzer [14] runs dynamic taint analysis (DTA) to capture
common characteristics of valid inputs. TaintScope [21] uses
DTA to identify the checksum ﬁeld. T-Fuzz [13] also bypasses
sanity checks and fuzzes the guarded codes directly. Some
recent fuzzing tools [18, 24, 27], referred to as hybrid fuzzers,
combine fuzzing with concolic execution. This may be a
promising way of fuzzing programs with structured inputs.
8 Conclusion
In this work, FANS is designed to meet the challenges in
fuzzing Android native system services. Experiments have
validated its ability to automatically generate transactions and
invoke the corresponding interface, which greatly helps to
fuzz Android native system services. Our evaluation shows
that FANS is also capable of inferring the complex depen-
dencies between these interfaces. Moreover, we discover that
the interface model is very complex in three aspects: variable
pattern, type alias and variable dependency. We intermittently
ran FANS on our six smartphones for around 30 days and
reported 30 native vulnerabilities to Google, of which 20 have
been conﬁrmed. These vulnerabilities imply that without a
precise interface model, we could not fuzz Android native sys-
tem services deeply. Surprisingly, 138 Java exceptions were
also exposed, which may deserve further study.
Acknowledgement
We would like to thank all anonymous reviewers and our
shepherd, Dr. Manuel Egele, for their valuable feedback that
greatly helped us improve this paper. Besides, we would like
to thank Xingman Chen, Kaixiang Chen, Zheming Li for
revising the draft of this paper. This work was supported in
part by National Natural Science Foundation of China under
Grant 61772308, 61972224, U1736209 and U1936121, and
BNRist Network and Software Security Research Program
under Grant BNR2019TD01004 and BNR2019RC01009.
References
[1] Yousra Aafer, Jianjun Huang, Yi Sun, Xiangyu Zhang,
Ninghui Li, and Chen Tian. Acedroid: Normalizing
diverse android access control checks for inconsistency
detection. In NDSS, 2018.
[2] Paulo Barros, René Just, Suzanne Millstein, Paul Vines,
Werner Dietl, Michael D Ernst, et al. Static analysis of
implicit control ﬂow: Resolving java reﬂection and an-
droid intents (t). In 2015 30th IEEE/ACM International
Conference on Automated Software Engineering (ASE),
pages 669–679. IEEE, 2015.
[3] Chen Cao, Neng Gao, Peng Liu, and Ji Xiang. Towards
analyzing the input validation vulnerabilities associated
In Proceedings of the
with android system services.
31st Annual Computer Security Applications Confer-
ence, pages 361–370. ACM, 2015.
[4] Peng Chen and Hao Chen. Angora: Efﬁcient fuzzing by
principled search. In 2018 IEEE Symposium on Security
and Privacy (SP), pages 711–725. IEEE, 2018.
[5] Michael Eddington. Peach fuzzing platform. Peach
Fuzzer, 34, 2011.
[6] Huan Feng and Kang G Shin. Understanding and de-
fending the binder attack surface in android. In Pro-
ceedings of the 32nd Annual Conference on Computer
Security Applications, pages 398–409. ACM, 2016.
[7] Guang Gong. Fuzzing android system services by binder
call to escalate privilege. BlackHat USA, 2015, 2015.
[8] Sigmund Albert Gorski, Benjamin Andow, Adwait Nad-
karni, Sunil Manandhar, William Enck, Eric Bodden,
and Alexandre Bartel. Acminer: Extraction and analysis
of authorization checks in android’s middleware.
In
Proceedings of the Ninth ACM Conference on Data and
Application Security and Privacy, pages 25–36, 2019.
[9] HyungSeok Han, DongHyeon Oh, and Sang Kil Cha.
Codealchemist: Semantics-aware code generation to
ﬁnd vulnerabilities in javascript engines. In NDSS, 2019.
[10] Antonio Ken Iannillo, Roberto Natella, Domenico Cotro-
neo, and Cristina Nita-Rotaru. Chizpurﬂe: A gray-box
android fuzzer for vendor service customizations. In
2017 IEEE 28th International Symposium on Software
Reliability Engineering (ISSRE), pages 1–11. IEEE,
2017.
[11] Fauzia Idrees and Muttukrishnan Rajarajan.
Investi-
gating the android intents and permissions for malware
detection. In 2014 IEEE 10th International Conference
on Wireless and Mobile Computing, Networking and
Communications (WiMob), pages 354–358. IEEE, 2014.
[12] Wang Kai, Zhang Yuqing, Liu Qixu, and Fan Dan. A
fuzzing test for dynamic vulnerability detection on an-
droid binder mechanism. In 2015 IEEE Conference on
Communications and Network Security (CNS), pages
709–710. IEEE, 2015.
[13] Hui Peng, Yan Shoshitaishvili, and Mathias Payer. T-
fuzz: fuzzing by program transformation. In 2018 IEEE
Symposium on Security and Privacy (SP), pages 697–
710. IEEE, 2018.
[14] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Co-
jocar, Cristiano Giuffrida, and Herbert Bos. Vuzzer:
Application-aware evolutionary fuzzing. In NDSS, vol-
ume 17, pages 1–14, 2017.
[15] Jesse Ruderman. Releasing jsfunfuzz and domfuzz,
2015.
[16] Raimondas Sasnauskas and John Regehr. Intent fuzzer:
crafting intents of death. In Proceedings of the 2014
Joint International Workshop on Dynamic Analysis
(WODA) and Software and System Performance Test-
ing, Debugging, and Analytics (PERTEA), pages 1–5.
ACM, 2014.
[17] Yuru Shao, Qi Alfred Chen, Zhuoqing Morley Mao,
Jason Ott, and Zhiyun Qian. Kratos: Discovering in-
consistent security policy enforcement in the android
framework. In NDSS, 2016.
[18] Nick Stephens, John Grosen, Christopher Salls, Andrew
Dutcher, Ruoyu Wang, Jacopo Corbetta, Yan Shoshi-
taishvili, Christopher Kruegel, and Giovanni Vigna.
Driller: Augmenting fuzzing through selective symbolic
execution. In NDSS, volume 16, pages 1–16, 2016.
[19] Dmitry Vyukov. Syzkaller, 2015.
IEEE Symposium on Security and Privacy (SP), pages
579–594. IEEE, 2017.
[21] Tielei Wang, Tao Wei, Guofei Gu, and Wei Zou.
Taintscope: A checksum-aware directed fuzzing tool
for automatic software vulnerability detection. In 2010
IEEE Symposium on Security and Privacy, pages 497–
512. IEEE, 2010.
[22] Wei You, Xueqiang Wang, Shiqing Ma, Jianjun Huang,
Xiangyu Zhang, XiaoFeng Wang, and Bin Liang. Pro-
fuzzer: On-the-ﬂy input type probing for better zero-day
vulnerability discovery. In 2019 IEEE Symposium on
Security and Privacy (SP), pages 769–786. IEEE, 2019.
[23] Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang,
Xiaojing Liao, Pan Bian, and Bin Liang. Semfuzz:
Semantics-based automatic generation of proof-of-
In Proceedings of the 2017 ACM
concept exploits.
SIGSAC Conference on Computer and Communications
Security, pages 2139–2154. ACM, 2017.
[24] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and
Taesoo Kim. {QSYM}: A practical concolic execution
engine tailored for hybrid fuzzing. In 27th {USENIX}
Security Symposium ({USENIX} Security 18), pages
745–761, 2018.
[25] Michal Zalewski.
American fuzzy lop.
http://lcamtuf. coredump. cx/aﬂ, 2017.
URL:
[26] Lei Zhang, Zhemin Yang, Yuyu He, Zhenyu Zhang,
Zhiyun Qian, Geng Hong, Yuan Zhang, and Min Yang.
Invetter: Locating insecure input validations in android
In Proceedings of the 2018 ACM SIGSAC
services.
Conference on Computer and Communications Security,
pages 1165–1178. ACM, 2018.
[27] Lei Zhao, Yue Duan, Heng Yin, and Jifeng Xuan. Send
hardest problems my way: Probabilistic path prioritiza-
tion for hybrid fuzzing. In NDSS, 2019.
A Appendix
[20] Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. Sky-
ﬁre: Data-driven seed generation for fuzzing. In 2017
A.1 Full Interface Dependency Graph
h
p
a
r
G
y
c
n
e
d
n
e
p
e
D
e
c
a
f
r
e
t
n
I
l
l
u
F
:
8
e
r
u
g
i
F
LegendICameraRecordingProxyIMediaRecorderIGraphicBufferProducerIResultReceiverIPerfProfdICameraServiceIStatsManagerIIncidentManagerIGpuServiceIAudioPolicyServiceISensorServerICameraServiceListenerICameraICameraDeviceUserIDrmClientIDrmIVoldTaskListenerIVoldIBinderISurfaceComposerClientISurfaceComposerIAppOpsServiceIStatsCompanionServiceIKeystoreServiceIMediaDrmServiceICryptoIApInterfaceEventCallbackIApInterfaceIMediaExtractorServiceIDataSourceIMediaExtractorIMemoryIMediaPlayerIMediaMetadataRetrieverIClientInterfaceIWifiScannerImplISoundTriggerHwServiceISoundTriggerIMemoryHeapIDisplayEventConnectionIAudioFlingerIEffectIAudioTrackIAudioRecordIAppOpsCallbackIResourceManagerClientIResourceManagerServiceIMediaPlayerServiceIMediaCodecListIRemoteDisplayIMediaSourceIInterfaceEventCallbackIWificondIAudioPolicyServiceClientISoundTriggerClientIShellCallbackIMediaHTTPServiceICameraClientIDrmServiceListenerIDrmManagerServiceIVoldListenerIUpdateEngineCallbackIUpdateEngineISensorEventConnectionICameraDeviceCallbacksIAAudioClientIAAudioServiceIIncidentReportStatusListenerIThermalEventListenerIThermalServiceIMediaPlayerClientIAudioFlingerClientIStreamSourceIEffectClientIMediaRecorderClientIScanEventIPnoScanEventIRemoteDisplayClientIProducerListenerUseGenerationLegendICameraRecordingProxyIMediaRecorderIGraphicBufferProducerIResultReceiverIPerfProfdICameraServiceIStatsManagerIIncidentManagerIGpuServiceIAudioPolicyServiceISensorServerICameraServiceListenerICameraICameraDeviceUserIDrmClientIDrmIBinderISurfaceComposerClientISurfaceComposerIAppOpsServiceIStatsCompanionServiceIKeystoreServiceIMediaDrmServiceICryptoIApInterfaceIMediaExtractorServiceIDataSourceIMediaExtractorIMemoryIMediaPlayerIMediaMetadataRetrieverIClientInterfaceIWifiScannerImplISoundTriggerHwServiceISoundTriggerIMemoryHeapIDisplayEventConnectionIAudioFlingerIEffectIAudioTrackIAudioRecordIAppOpsCallbackIMediaPlayerServiceIMediaCodecListIRemoteDisplayIMediaSourceIAudioPolicyServiceClientISoundTriggerClientIShellCallbackIMediaHTTPServiceICameraClientIDrmServiceListenerIDrmManagerServiceIUpdateEngineCallbackIUpdateEngineISensorEventConnectionICameraDeviceCallbacksIAAudioClientIAAudioServiceIIncidentReportStatusListenerIThermalEventListenerIThermalServiceIMediaPlayerClientIAudioFlingerClientIStreamSourceIEffectClientIMediaRecorderClientIScanEventIPnoScanEventIRemoteDisplayClientIProducerListenerUseGeneration