一个重要的因素是了解待搜索的文本。下一章，我们会更详细地考察这个例子。
利
---
## Page 52
26
第1章：正则表达式入门
HTML tag
对egrep这样的工具来说，简单地匹配包含HTMLtag的行并不常见，也没什么用。但是、
探索如何准确匹配一个HTMLtag却是相当有启发的，在下一章深入接触更高级的工具时，
这一点尤其明显。
最直接的想法，但它显然是不对的。的意思是，“先匹配一个‘"”。所以，它无疑能够匹配不止一个tag的内容，例如'thisshort
example’中标记的内容。
也许结果有点出乎你的意料，但是我们目前还只在第1章，对正则表达式的理解也不够深
人。我之所以举这个例子，是想说明正则表达式并不复杂，但是如果你不真正弄懂它们，
可能会被搞得晕头转向。在下面的几章中，我们会学习理解和解决这个问题需要的所有细
节。
表示时刻的文字，例如“9:17am”或者“12:30pm
匹配表示时刻的文字可能有不同的严格程度。
[0-91?[0-9] :[0-9][0-9]·(am|pm) 
能够匹配9：17·am或者12：30·pm，但也能匹配无意义的时刻，如99：99·pm。
首先看小时数，我们知道，如果小时数是一个两位数，第一位只能是1。但是1？{0-9]：
仍然能够匹配19（也能够匹配0)，所以更好的办法应该是把小时部分分为两种情况来处理，
1[012]匹配两位数，（1-9]；匹配一位数，结果就是（1[012]1[1-9]）。
分钟数就简单些。第一位数字应该是[0-5]1，此时第二位数字应该是[0-9】1。综合起来就
是（1[012]1[1-9]):[0-5][0-9]-(am|pm）1
举一反三，你能够处理24小时制的时间吗？多动动脑筋，想想该如何处理以0开头的情况，
比如09：59呢？答案请见下页。
---
## Page 53
基础知识拓展
2
正则表达式术语汇总
Regilar E.xpression Nomenclafure
正则(regex)
就更麻烦。所以，我一般会采用“正则”（regex）的说法。这个单词念起来很流畅（有点像
联邦快递的FedEx，与regular一样，g发重音，而不同于Regina），而且说“如果你写个正
则”，“巧妙的正则”（buddingregexers），甚至是“正则化”（regexification）（注10）（译注4）。
匹配（matching）
一个正则表达式“匹配”一个字符事，其实是指这个正则表达式能在字符串中找到匹配文
本。严格地说，正则表达式'ai不能匹配cat，但是能匹配cat中的a。几乎没人会混淆这
两个概念，但澄清一下还是有必要的。
元字符（metacharacter）
一个字符是否元字符（或者是“元字符序列”（metasequence），这两个概念是相等的），取
决于应用的具体情况。例如，只有在字符组外部并且是在未转义的情况下，*才是一个元
字符。“转义”（escaped）的意思是，通常情况下在这个字符之前有一个反斜线。\*是对*
的转义，而\*则不是（第一个反斜线用来转义第二个反斜线），虽然在两个例子中，星
号之前都有一个反斜线。
正则表达式的流派（flavor）不同，关于字符转义的规定也不相同。第3章对此进行了详细
讨论。
流派（flavor）
我已经说过，不同的工具使用不同的正则表达式完成不同的任务，每样工具支持的元字符
和其他特性各有不同。我们再举单词分界符的例子。某些版本的egrep支持我们曾见过的
表示法。而另-一些版本不支持单独的起始和结束边界，只提供了统一的\b元字符
（这个元字符我们还没见过，下一章才会用到）。还有些工具同时支持这两种表示法，另有
许多工具哪种也不支持。
我用“流派（flavor）”这个词来描述所有这些细微的实现规定。这就好像不同的人说不同的
方言一样。从表面上看，“流派”指的是关于元字符的规定，但它的内容远远不止这些。
注10：你或许会想到那个难看的缩写regexp。我不知道这个词应该如何发音，口齿不清的人读
起来可能会容易一点。
译注4：正则表达式的全名是regularexpression，简写为regex，原著中此处的标题即为regex，
采用中文简称“正则”。
---
## Page 54
28
第1章：正则表达式入门
即使两个程序都支持，它们可能对这两个元字符的意义有不同的理解，对单词的理
解也不相同。在使用具体的工具软件时，这个问题尤其重要。
改进匹配时间的表达式，处理24小时制时间
26页问题的答案
办法有许多种，不过思路和之前差不多。现在我们把问题分为3部分：其一是上午（小
时数从00到09，开头的0可选），其二是白天（小时数从10到19），其三是夜晚（小
时数从20到23）。这样答案就很明显了：0?[0-9]11[0-9]12[0-3]]。
实际上，我们可以合并头两个多选分支，得到[01]？[0-9]12[0-3]1。你可能需要动
点脑筋才能明白这个表达式与上面是完全等价的。下面的图可能有所帮助，它还提供
了另一种思路。阴影部分表示单个多选分支能够匹配的数字。
左图
右图
[[01]2[0-9]|210-3]]
[[01]?[4-9]|012]7[0-3]
0123456789
023456789
00010203040506070809
00010203040506070809
10111213141516171819
10111213141516171819
20|21|22|23
请不要混淆“流派（flavor）”和“工具（tool）”这两个概念。两个人可以说同样的方言，
两个完全不同的程序也可能属于同样的流派。同样，两个名字相同的程序（解决的任务也
相同）所属的流派可能有细微（有时可能并非细微）的差别。有许多程序都叫egrep，它们
所属的流派也五花八门。
由Perl语言的正则表达式开创的流派，在20世纪90年代中期因为其强大的表达能力广为
人们所知，其他语言紧随其后，提供了汲取其中灵感的正则表达式（其中许多为了标明自
已的思想来源，直接给自己贴上“兼容Perl（Perl-Compatible）”的标签）。它们包括PHP、
Python、Java的大量正则包，微软的.NETFramework、Tcl，以及C的各种类库。不过，所
有时候是受了其他语言的正则表达式的刺激）。像往常一样，总的局面变得越来越复杂，让
人困惑。
---
## Page 55
基础知识拓展
29
子表达式（subexpression）
“子表达式”指的是整个正则表达式中的一部分，通常是括号内的表达式，或者是由1分
式。其中的Subject和Datei也算得上子表达式。而且，严格说起来，S、ui、bi、ji这些
字符，都算子表达式。
割的“单元（unit)”。但是，Hi、[1-6]1、*都是‘H[1-6]-*的子表达式。
与多选分支不同的是，量词（星号、加号和问号）作用的对象是它们之前紧邻的子表达式。
所以‘mis+pell;中的+作用的是s，而不是‘misi或者isl。当然，如果量词之前紧邻的是
-一个括号包围的子表达式，整个子表达式（无论多复杂）都被视为一个单元。
字符（character）
“字符”在计算机领域是一个有特殊意义的单词。一个字节所代表的单词取决于计算机如
何解释。单个字节的值不会变化，但这个值所代表的字符却是由解释所用的编码来决定的。
例如，值为64和53的字节，在ASCII编码中分别代表了字符“@”和“5”，但在EBCDIC
编码中，则是完全不同的字符（一个是空格，一个是控制字符）。
另一方面，在流行的日文字符编码中，这两个字节代表一个字符正。如果换一种日文字符
编码，这个字就需要两个完全不同的字节。那两个字节，在通行的Latin-1编码中，表示"Au”，
而在Unicode编码中又表示韩文的“针”（注11)。问题在于，字节如何解释只是视角（称
为“编码”encoding）的问题，我们要做的只是确保自己的视角和正在使用的工具的视角相
同。
注11：关于多字节编码的权威著作是KenLunde的CJKVInformationProcessing，这本书亦由
O'Reilly出版。CJKV表示Chinese、Japanese、Korean和Vietnamese（汉语、日语、韩语
和越南语），这4种语言都必须使用多字节编码。Ken和Adobe热心地提供了本书所需的
特殊宇体。
---
## Page 56
30
第1章：正则表达式入门
一直以来，文本处理软件一般都把数据视为一些ASCII编码的字节，而不考虑使用者期望
采用的字符编码。不过，近来已经有越来越多的系统在内部使用某些格式的Unicode编码来
处理数据（第3章介绍了Unicode，?105）。如果这些系统中的正则表达式子系统的实现方
式正确，使用者通常就不需要在编码的问题上费太多工夫。这个“如果”相当复杂，所以
第3章深人讲解了这个问题。
改进现状
Inproiing on thcStatus Quo
总的来说，正则表达式并不难。但是，如果你与使用过支持正则表达式的程序或语言的人
交流过就会发现，某些人确实“会用”正则表达式，但如果需要解决复杂的问题，或是换
用他们不熟悉的工具，就会出问题。
的表格。给出的例子通常也是无意义的'a*（（ab）*Ib*）1、文本则是“a'xxx'ce'xxxxxx
ci*xxx'd。这些文档大都忽略了细微但重要的知识点，总是声称自己与其他出名的工具属
于同一流派，而忘记提及必然存在的差异。它们缺乏实用价值。
当然，我的意思并不是，本章就能够填补这道鸿沟，让读者掌握所有正则表达式，或是掌
握egrep的正则表达式。相反，这一章只是为本书的其他内容铺垫基础。我希望本书能够为
读者填补这道鸿沟，虽然这期望有点自负。很多读者很满意本书的第一版，我本人也为拓
展这一版的深度和广度付出了艰苦的努力。
或许是因为正则表达式的文档一直都非常欠缺，我感到自己必须做出额外的努力、才能把
知识梳理清楚。因为我希望保证读者能够充分运用正则表达式的潜力，我希望你们能够真
正精通正则表达式。
这既是件好事也是件坏事。
好处在于，你将学会如何以正则表达式的方式来思考问题。你将学习到，在面对属于不同
流派的新工具时，需要注意哪些差异和特性。你还将会学习到，如果某个流派的功能弱小、
特性简陋，该如何表达自己的意图。你将会明白，一个正则表达式的效率优于其他表达式
的原因所在，而且你将能够在复杂性、效率和匹配准确性间进行取舍权衡。
---
## Page 57
基础知识拓展
31
面对特别复杂的任务，你将会知道如何通过程序容许的方式来构建和使用正则表达式。总
的来说、你能够得心应手地使用正则表达式的所有潜能。
向题在于，这种方法的学习曲线非常陡哨，而且还有几大难点：
正则表达式的使用许多程序使用的正则表达式比egrep要复杂。在我们探讨如何构造
真正有用的正则表达式的细节之前，需要知道正则表达式的使用方法。下一章关注这
一问题。
正则表达式的特性（feature）面对问题，选择合适的工具是成功的一半，所以我会在
全书中使用多种工具。不同的程序，甚至是同一个程序的不同版本，支持的特性和元
字符都不·样。在了解使用细节之前，我们必须搞清楚这个问题。这是第3章的主题。
正则表达式的工作原理在我们接触有用（但通常也很复杂）的例子之前，我们必须“揭
开盖子”来了解正则表达式的工作原理。我们将会看到，对某些元字符进行尝试匹配
的次序是一个重要的向题。实际上，正则表达式引擎（regularexpressionengine）不同，
工作原理也不同，所以对于同样的正则表达式，不同的程序会得到不同的结果。我们
将在第4、5、6章中探讨这个复杂的问题。
正则表达式的工作原理是最重要同时也是最难以掌握的知识。研究这个问题有时的确很枯
燥，更糟糕的是，读者在接触真正有趣的内容一一解决实际问题一一-之前，不得不耐着性
子看完它们。然而，弄懂正则表达式的工作原理，才是真正理解的关键。
你或许会想，如果只希望学会开车，是不需要了解汽车运行原理的。但是，学习开车与学
习正则表达式之间并没有多少相似性。我的目的是教会读者如何使用正则表达式一也就
是编写正则表达式一一来解决向题。更合适的比喻是，学习正则表达式就如同学习如何造
车，而不是如何并车。在制造汽车以前，我们必须了解汽车的工作原理。
第2章提供了更多的关于开车的经验。第3章简要回顾了开车的历史，详细考察了正则表
达式流派的主要内容。第4章介绍了正则表达式流派的重要的引擎。第5章展示了些更
复杂的例子，第6章告诉你如何调校某种具体的引擎，之后的各章则是检查具体的产品和
模型。在第4、5、6章中，我们花了大量的篇幅来探讨幕后的原理，所以请务必做好准备。
---
## Page 58
32
第1章：正则表达式入门
总结
Summary
表1-3总结了我们在本章中见过的egrep的元字符。
表1-3：egrep的元字符总结
匹配单个字符的元字符
元字符
匹配对象
点号
匹配单个任意字符
[.. ]
字符组
匹配单个列出的字符
[~.]
排除型字符组
匹配单个未列出的字符
char
若char是元字符，或转义序列无特殊含义时，匹配
转义字符
char对应的普通字符
提供计数功能的元字符
？
问号
容许匹配一次，但非必须
★
星号
可以匹配任意多次，也可能不匹配
+
加号
至少需要匹配一次，至多可能任意多次
{min,max)
区间量词
至少需要min次，至多容许max次
匹配位置的元字符
A
脱字符
匹配一行的开头位置
S
美元符
匹配一行的结束位置
1
单词分界符
匹配单词的结束位置
其他元字符
alternation
匹配任意分隔的表达式