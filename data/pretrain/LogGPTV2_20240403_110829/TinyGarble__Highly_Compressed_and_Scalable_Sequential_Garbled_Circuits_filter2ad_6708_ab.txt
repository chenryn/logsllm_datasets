global minimum, it provides a very close approximation
of the optimal, while the solution is always free from
redundancy. This algorithm has been incorporated as a
standard logic function minimization step in virtually any
contemporary HDL synthesis tool.
Logic optimization takes this minimized format, fur-
ther processes it, and eventually maps it onto the avail-
able basic logic cells or library elements in the target
technology. Mapping is limited by factors such as the
available gates (logic functions or standard cells) in the
technology library, as well as the drive sizes, delay,
power, and area characteristics of each gate.
Newer generations of synthesis programs, referred to
as high level synthesis (HLS) tools, accept other forms
of input in a higher level programming language [12],
[14], [73], e.g., ANSI C, C++, SystemC, or Python.
HLS tools are also available in both open-source and
commercial forms, cf. [16], [19], [59]. The limitation
of the higher level languages is that the behavior of
the function is typically decoupled from the timing. The
HLS tools handle the micro-architecture and transform
the untimed or partially timed functional code into a
fully timed HDL implementation, which in turn can
be compiled by a classic synthesis tool. It
is well-
known that the performance of the circuits resulting from
automatically compiled HLS code into HDL is inferior
to the performance of functions directly written in HDL.
Therefore, the main driver for the development of HLS
tools is user-friendliness and not performance.
III. GLOBAL FLOW
The global Ô¨Çow of TinyGarble is shown in Fig. 1. It
consists of the following four steps:
1) The input to the TinyGarble framework is a Ô¨Åle
that describes a sequential or combinational function
written in an HDL like Verilog or VHDL. The
function can also be written in a high level language
like C/C++ and automatically translated to HDL
using an HLS tool. In the sequential circuit, the
degree of folding is speciÔ¨Åed by the user.
2) A standard HDL synthesis tool compiles the HDL to
generate a netlist Ô¨Åle. The synthesis tool optimizes
the netlist based on the user deÔ¨Åned objectives/con-
straints and a customized library.
3) The netlist is parsed and topologically sorted. If
the circuit is sequential, only its combinational part
is sorted. Then,
is saved in a
format compatible with any given GC framework
e.g., Simple Circuit Description (SCD) compatible
with JustGarble [2].
the sorted netlist
4) The circuit description is provided to both the gar-
bler and evaluator to securely evaluate the function
by the GC framework.
Fig. 2 shows examples of Ô¨Åles at different steps of
TinyGarble‚Äôs Ô¨Çow for the Hamming distance function.
The hamming.c Ô¨Åle contains the description of the func-
tion in the C language. The user inputs this function to
a HLS tool to generate the corresponding description in
Verilog. The resulting Verilog Ô¨Åle is functionally similar
to the hamming.v Ô¨Åle shown in the Ô¨Ågure, but it may
look more complicated and be less efÔ¨Åcient as it
is
generated by an automated tool. A user can also write
the description directly in Verilog to have more control
on the circuit and therefore a more efÔ¨Åcient netlist. The
hamming.v Ô¨Åle is provided to an HDL synthesis tool
along with the TinyGarble custom libraries to generate
netlist hamming netlist.v. The netlist describes the same
414414
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:52 UTC from IEEE Xplore.  Restrictions apply. 
	
	
 !"
$	
%
"
 !"$	
!%'(
 !"
	







	









	
$	




&
#!	!

Fig. 1: Global Ô¨Çow of TinyGarble for both combinational and sequential synthesis. The inputs can be either a C/C++
program (translatable to HDL via a standard HLS tool) or a direct HDL description. TinyGarble is able to provide
circuit description for any given GC framework.

	


	
;	
!"*	
&<  # 
*	
"< 
!# %
&*	
$$
!# 
D
 	
    
 
   
  
 
   
	 



!"# 
!"# !$ %
 	
    
 
   
 
&&&
'(( )
* &'
+ &,-.

&/01 &2 
&&&
345/ 6! &7 &8 &9
: 
474'4 6+! &7
: &8
+ &9
+ 
&&&


Fig. 2: Sample Ô¨Åles at the different steps of TinyGarble‚Äôs Ô¨Çow for Hamming distance function.
function as hamming.c and hamming.v but uses the logic
cells provided in the technology library. The technology
library contains 2-input-1-output logic cells to be com-
patible with front-end garbling tools [2], [54].
IV. GARBLING AND EVALUATING SEQUENTIAL
CIRCUITS
Sequential circuits can be used as a very compact
circuit description. In the following section we Ô¨Årst
describe the concept of sequential circuits (Section IV-A)
using an example and then explain the modiÔ¨Åcations
required to garble/evaluate them.
A. Sequential Circuits
	



	




	



(a) Combinational circuit
(b) Sequential circuit
Fig. 3: (a) Combinational circuit where outputs are
functions of only inputs. (b) Sequential circuit where
outputs are functions of inputs and present states.
415415
Yao‚Äôs GC algorithm allows secure evaluation of a
Boolean circuit, i.e., an acyclic graph of binary gates
(e.g., AND, OR, XOR, etc.). In digital circuit theory,
such a circuit is called combinational circuit and deÔ¨Åned
as a memory-less circuit in which outputs are functions
only of inputs, see Fig. 3a.
Another class of circuits in digital circuit theory are
sequential circuits in which unlike in the combinational
case, circuit outputs are functions of both inputs and
circuit states. Circuit states are kept in memory elements
such as Flip Flops (FF). The states can change at the end
of each clock cycle1.
As seen in Fig. 3b, a sequential circuit can be rep-
resented as an ensemble of a combinational circuit and
feedback loops with memory elements. At each clock
cycle, circuit inputs as well as the present states are fed
to the combinational part. Then, it generates the outputs
and next states which will be stored in the memory
elements for the next cycle. The initial value of the
memory elements are either a known constant value (0
or 1) or determined by an initial input value2.
Fig. 4 demonstrates an example of a combinational
and a sequential implementation for a 4-bit Adder with
1The clock signal oscillates between a low and a high state and its
(rising) edge is typically utilized to coordinate the memory updates.
2In digital hardware, FF initialization is usually done by reset or set
signals. In TinyGarble, we use a new signal for FF that determines the
initial value. It can be connected to a constant value or input wire.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:52 UTC from IEEE Xplore.  Restrictions apply. 




	 
	
	 
	
	 
	


	

	

 
 
 
 




	



	




	
	


	



	

	
Fig. 4: Combinational and sequential design of a 4-bit
Adder. (a) HA circuit. (b) FA circuit. (c) Combinational
4-bit Adder using 1 HA and 3 FAs. (d) Sequential 4-bit
Adder using one FA.
inputs x = x3x2x1x0 and y = y3y2y1y0, producing
sum s = s3s2s1s0. Fig. 4a and 4b show the internal
combinational circuit of a half Adder (HA) and a full
Adder (FA) respectively. In Fig. 4c a combinational
Adder is built by cascading 3 FAs and one HA. Fig. 4d
represents a sequential implementation of a 4-bit Adder
which uses one FA and a one bit FF to save the carry bit
from the previous cycle. The circuit should be evaluated
in 4 cycles. At the Ô¨Årst cycle the carry bit is z0 = 0.
Note that, in the combinational circuit we use three FAs
and one HA whereas in the sequential circuit, we have
to use one FA for 4 sequential cycles. This asymmetry
in the loop of Addition function introduces a very small
overhead in GC computation and communication time as
an HA circuit has fewer gates compared to a FA circuit.
However, the total number of gates for representing
the function is reduced approximately by a factor of 4
when using a sequential circuit (one FA for sequential
compared with three FA and one HA for combinational).
This helps to limit the memory footprint for garbling
and evaluation required for storing circuit description
and wire tokens (k-bit per wire, see Section II-A). In
a sequential circuit, the number of tokens that need to
be stored in memory at any moment is proportional to
the number of gates in the circuit. The wire tokens are
simply over-written at each sequential cycle. Only tokens
corresponding to FFs are kept for the next cycle.
Nearly all commercial circuits used in digital hardware
are designed in sequential format. There are multiple
reasons for preferring sequential circuit description over
combinational
including the reduction in complexity,
area, power, and cost, as well as natural mapping of
Ô¨Ånite state machine control functions into a sequential
format. Some of these reasons also provide a rationale for




	
	
	
	



	
	

Fig. 5: Functionally equivalent unrolled sequential circuit
corresponding to Fig. 3b.
sequential description of a function in GC, including: (i)
reduction in size and memory footprint that is achieved
by introducing the state elements and feedback loop from
output to input; (ii) removing the need to perform costly
compile-time/runtime loop unrolling by embracing loops
within the sequential feedback loop; (iii) providing a
new degree of freedom for folding by the placement
of memory elements in the long combinational paths‚Äì
the placement can be done in accordance with the user‚Äôs
objective.
During the evaluation of a sequential circuit,
the
combinational block is evaluated c times where c is the
number of sequential cycles that the circuit operates. We
can visualize this process as the unrolled combinational
representation of the sequential circuit as shown in Fig. 5.
The inputs of the unrolled circuit are the inputs of the
combinational block in all the cycles. The same holds
for the outputs, too. The present states at each cycle cid,
where 0 ‚â§ cid < c, are equal to the next states at the
previous cycle (cid ‚àí 1). The present states at cid = 0
are equal to the input initial value.
During generation and evaluation of the garbled cir-
cuit, it must be ensured that the encryption tweaks T (see
Section II-A) for each gate is unique because otherwise
security is broken [32, Sect. 3.4]. In TinyGarble,
to
ensure the uniqueness property, we set tweak T for each
gate to be the concatenation of the cycle index (cid)
and the unique gate identiÔ¨Åers (gid) in the combinational
part of the sequential circuit, i.e., T = cid||gid.3 As in
previous work, security and correctness of the GC gar-
bling/evaluation follow from the uniqueness of the tweak
T and the existing proofs of security and correctness, see
[2], [49].
V. HDL SYNTHESIS
As described in Section II-A, Yao‚Äôs protocol requires
the function to be represented as a Boolean circuit.
Previous work like FairPlay [54] and WYSTERIA [63]
used custom-made languages to describe a function and
generate the circuit for GC operations. In our TinyGarble
framework, the user may describe a function in a stan-
dard HDL like Verilog or VHDL. She may also write
3An alternative method would be to use a monotonic counter in the