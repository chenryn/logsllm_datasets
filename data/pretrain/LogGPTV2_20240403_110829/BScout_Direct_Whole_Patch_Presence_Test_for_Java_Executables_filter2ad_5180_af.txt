scalability, Genius [23] converts the whole CFGs into high-
level numeric feature vectors and uses graph embedding to
speed up the searching process. Gemini [45] leverages neural
networks to further improve the generation process of graph
embedding. Centroid [19] is frequently used for calculating
the similarity between Java methods. The methods mentioned
above are hard to be applied to patch presence test because
they extract features from the whole function rather than the
patch itself, which are too coarse-grained to accurately catch
the tiny changes introduced by a patch.
Version Pinning. Since patches may be applied in different
versions of a library, the library version reﬂects patch presence
status. Existing work [17, 21] collects a set of reference
libraries of different versions and use similarity analysis to
pinpoint a test library to the most similar one in the reference
set. Speciﬁcally, OSSPolice [21] utilizes syntactic features
(e.g. string constants, normalized class signatures) in a library,
while LibScout [17] constructs class hierarchy proﬁles that
are more resilient to common obfuscation techniques. Since
coarse-grained features are used, existing work can differ two
library versions where signiﬁcant changes may occur, while
works poorly to test the presence of security patches which
usually introduce slight changes to the whole binary.
8 Conclusion
This paper presents BSCOUT, a tailored approach to reliably,
ﬂexibly and accurately test patch presence for Java executa-
bles. BSCOUT makes non-trivial efforts by proposing two
key techniques: cross-layer line-level correlative analysis
which utilizes feature-based line-level similarity testing to
link Java source code lines to Java bytecode instructions,
and patch-derived differential analysis which gives a reliable
and precise patch presence result by calculating how many
signiﬁcant patch-changed lines are indeed included in the
target executable. We evaluate BSCOUT with 194 CVEs
from the Android framework and third-party libraries and the
results show that BSCOUT is both effective and efﬁcient. With
BSCOUT, we perform an empirical study of patch application
practice with 2,506 real-world Android ROMs, which reveals
several interesting ﬁndings that have not been veriﬁed before
and helps the community to conduct more effective efforts to
ﬁght against vulnerabilities.
Acknowledgements
We would like to thank our shepherd Martina Lindorfer
and anonymous reviewers for their helpful comments. This
work was supported in part by the National Natural Science
Foundation of China (U1636204, U1836210, U1836213,
U1736208, 61972099, 61602123, 61602121), Natural Sci-
ence Foundation of Shanghai (19ZR1404800), and National
Program on Key Basic Research (NO. 2015CB358800). Min
Yang is the corresponding author, and a faculty of Shanghai
Institute of Intelligent Electronics & Systems, Shanghai
Institute for Advanced Communication and Data Science,
and Engineering Research Center of CyberSecurity Auditing
and Monitoring, Ministry of Education, China.
USENIX Association
29th USENIX Security Symposium    1161
References
[1] Android fragmentation: There are now 24,000 devices
https://www.zdnet.com/ar
from 1,300 brands.
ticle/android-fragmentation-there-are-now
-24000-devices-from-1300-brands/. Accessed:
2019-08-14.
[2] Android security bulletins. https://source.android
.com/security/bulletin/. Accessed: 2019-08-14.
[3] Command line tools. https://developer.android.
com/studio/command-line. Accessed: 2019-08-14.
[4] Common vulnerability scoring system calculator version
https://nvd.nist.gov/vuln-metrics/cvss/
2.
v2-calculator. Accessed: 2019-08-14.
[5] Crf++ source code. https://github.com/taku910
/crfpp. Accessed: 2019-11-08.
[6] Dalvik bytecode. https://source.android.com/d
evices/tech/dalvik/dalvik-bytecode. Accessed:
2019-08-14.
[7] Dexlib - android bytecode library. https://code.goo
gle.com/p/smali/. Accessed: 2019-08-14.
[8] F-droid - free and open source android app repository.
https://f-droid.org/en/. Accessed: 2019-08-14.
[9] The java virtual machine speciﬁcation. https://docs
.oracle.com/javase/specs/jvms/se7/html/. Ac-
cessed: 2019-08-14.
[10] Libscout source code. https://github.com/reddr
/LibScout. Accessed: 2019-08-14.
[11] National vulnerability database. https://nvd.nist.g
ov. Accessed: 2019-08-14.
[12] One-way analysis of variance. https://en.wikip
edia.org/wiki/One-way_analysis_of_variance.
Accessed: 2019-11-08.
[13] Osspolice source code. https://github.com/osssa
nitizer/osspolice. Accessed: 2019-08-14.
[14] Security patch for cve-2016-3832. https://android.
googlesource.com/platform/frameworks/base/
+/e7cf91a198d\e995c7440b3b64352effd2e309906.
Accessed: 2019-08-14.
[15] Smali/baksmali tool. https://github.com/JesusFr
eke/smali. Accessed: 2019-08-14.
[17] M. Backes, S. Bugiel, and E. Derr. Reliable Third-
Party Library Detection in Android and its Security
Applications. In CCS’16.
[18] M. Bourquin, A. King, and E. Robbins. Binslayer:
In
accurate comparison of binary executables.
PPREW’13.
[19] K. Chen, P. Liu, and Y. Zhang. Achieving accuracy
and scalability simultaneously in detecting application
clones on android markets. In ICSE’14.
[20] K. Chen, P. Wang, Y. Lee, X. Wang, N. Zhang, H. Huang,
W. Zou, and P. Liu. Finding unknown malice in 10
seconds:mass vetting for new threats at the google-play
scale. In USENIX Security’15.
[21] R. Duan, A. Bijlani, M. Xu, T. Kim, and W. Lee.
Identifying Open-Source License Violation and 1-day
Security Risk at Large Scale. In CCS’17.
[22] T. Dullien and R. Rolles. Graph-based comparison of
executable objects. SSTIC, 5(1):3, 2005.
[23] Q. Feng, R. Zhou, C. Xu, Y. Cheng, B. Testa, and H. Yin.
Scalable graph-based bug search for ﬁrmware images.
In CCS’17.
[24] D. Gao, M. K. Reiter, and D. Song.
Binhunt:
Automatically ﬁnding semantic differences in binary
programs. In ICICS’08.
[25] J. Jang, A. Agrawal, and D. Brumley. ReDeBug
- Finding Unpatched Code Clones in Entire OS
Distributions. In S&P’12.
[26] L.
Jiang, G. Misherghi, Z. Su, and S. Glondu.
DECKARD - Scalable and Accurate Tree-Based
Detection of Code Clones. In ICSE’07.
[27] T. Kamiya, S. Kusumoto, and K. Inoue. CCFinder -
A Multilinguistic Token-Based Code Clone Detection
System for Large Scale Source Code. In TSE’02.
[28] W. M. Khoo, A. Mycroft, and R. J. Anderson.
In
Rendezvous - a search engine for binary code.
MSR’13.
[29] S. Kim, S. Woo, H. Lee, and H. Oh.
VUDDY
- A Scalable Approach for Vulnerable Code Clone
Discovery. In S&P’17.
[30] J. Lafferty, A. McCallum, and F. C. Pereira. Conditional
random ﬁelds: Probabilistic models for segmenting and
labeling sequence data. 2001.
[16] Student’s t-test. https://en.wikipedia.org/wiki/
Student%27s_t-test. Accessed: 2019-11-08.
[31] F. Li and V. Paxson. A large-scale empirical study of
security patches. In CCS’17.
1162    29th USENIX Security Symposium
USENIX Association
[32] Z. Li, S. Lu, S. Myagmar, and Y. Zhou. CP-Miner:
Finding copy-paste and related bugs in large-scale
software code. In TSE’06.
[33] Z. Li, D. Zou, S. Xu, H. Jin, H. Qi, and J. Hu. Vulpecker:
an automated vulnerability detection system based on
code similarity analysis. In ACSAC’16.
[34] Z. Li, D. Zou, S. Xu, X. Ou, H. Jin, S. Wang, Z. Deng,
and Y. Zhong. VulDeePecker: A Deep Learning-Based
System for Vulnerability Detection. In NDSS’18.
[35] D. MacKenzie, P. Eggert, and R. Stallman. Comparing
and merging ﬁles with gnu diff and patch. Network
Theory Ltd, 4, 2002.
[36] E. W. Myers. An o(nd) difference algorithm and its
variations. Algorithmica, 1986.
[37] N. Nguyen and Y. Guo. Comparisons of sequence
labeling algorithms and extensions. In ICML’07.
[38] K. Nohl and J. Lell. Mind the Gap: Uncovering the
Android Patch Gap Through Binary-Only Patch Level
Analysis. In Hitbsecconf’2018.
[39] R. Pawlak, M. Monperrus, N. Petitprez, C. Noguera,
and L. Seinturier. Spoon: A Library for Implementing
Analyses and Transformations of Java Source Code.
Software: Practice and Experience, 2015.
[40] J. Pewny, B. Garmany, R. Gawlik, C. Rossow, and
T. Holz. Cross-architecture bug search in binary
executables. In S&P’15.
[41] J. Ratcliff and D. Metzener. Ratcliff-obershelp pattern
Dictionary of Algorithms and Data
recognition.
Structures, 1998.
[42] H. Sajnani, V. Saini, J. Svajlenko, C. K. Roy, and C. V.
Lopes. SourcererCC - scaling code clone detection to
big-code. In ICSE’16.
[43] E. Sebastian, Y. Khaled, and G. Elmar.
discovre:
Efﬁcient cross-architecture identiﬁcation of bugs in
binary code. In NDSS’16.
[44] P.-N. Tan et al. Introduction to data mining. Pearson
Education India, 2006.
[45] X. Xu, C. Liu, Q. Feng, H. Yin, L. Song, and D. Song.
Neural Network-based Graph Embedding for Cross-
Platform Binary Code Similarity Detection. In CCS’17.
[46] H. Zhang and Z. Qian. Precise and accurate patch
presence test for binaries. In USENIX Security’18.
A CVE Datasets
To evaluate the effectiveness of BSCOUT, we construct two
CVE datasets. The ﬁrst consists of 150 Android framework
vulnerabilities collected from Android Security Bulletin
spanning from August 2015 to July 2019. Table 9 gives an
overview about these CVEs. The second CVE dataset has 44
vulnerabilities from 23 popular Java libraries, as shown in
Table 10.
Table 9: Overview of Android Framework CVE Dataset.
Android Version
# of Affected CVEs
Android 4.*
Android 5.*
Android 6.*
Android 7.*
Android 8.*
Android 9.*
Total
40
69
95
92
50
26
1501
1 Note that a CVE may affect multiple
Android versions.
Table 10: Overview of Third-party Library CVE Dataset.
Library
CVE
jsoup
junrar
okhttp
smack
androidsvg
google-guava
apache-httpclient
apache-jackrabbit-webdav
apache-commons-collections
apache-commons-compress
apache-commons-ﬁleupload
spring-web
lz4-java
batik-all
plexus-utils
netty-codec-http
groovy-all
xalan-java
pdfbox
dom4j
antisamy
jackson-databind
bcprov-jdk15on
CVE-2015-6748
CVE-2018-12418
CVE-2016-2402
CVE-2016-10027
CVE-2017-1000498
CVE-2018-10237
CVE-2013-4366
CVE-2016-6801
CVE-2015-6420
CVE-2018-1324, CVE-2018-11771
CVE-2016-1000031, CVE-2016-3092
CVE-2014-0050
CVE-2013-6429
CVE-2014-4715
CVE-2018-8013, CVE-2017-5662
CVE-2015-0250
CVE-2017-1000487
CVE-2015-2156, CVE-2014-0193
CVE-2016-6814, CVE-2015-3253
CVE-2014-0107
CVE-2016-2175
CVE-2018-1000632
CVE-2017-14735, CVE-2016-10006
CVE-2017-7525, CVE-2017-15095
CVE-2017-17485, CVE-2018-7489
CVE-2018-1000180, CVE-2016-1000352
CVE-2016-1000340, CVE-2016-1000345
CVE-2016-1000346, CVE-2016-1000341
CVE-2016-1000343, CVE-2016-1000342
CVE-2016-1000339, CVE-2015-7940
CVE-2016-1000338,
Patch Characteristics. Different to FIBER [46] which
uses small and localized changes in the patch to generate
binary-level signatures for patch presence test, our work
advocates using the whole patch for testing. Speciﬁcally,
we design patch-derived differential analysis to analyze the
USENIX Association
29th USENIX Security Symposium    1163
whole patch and extract features for further test. For the whole
CVE dataset, we analyze their patches and present the results
in Table 11. From this table, we can ﬁnd BSCOUT utilizes
16.64 features in patch presence test for each CVE on average.
Besides, line addition/deletion/modiﬁcation are common in
patches, rendering the need to leverage both pre-patch and
post-patch source code for patch presence test. Meanwhile,
we also ﬁnd each patch has 12.14 out-of-method lines on
average. Since these lines make limited contributions in ﬁxing
a vulnerability, it is necessary to recognize these lines and
exclude them from the scope of patch presence test.
Table 11: Patch Characteristics for the Whole CVE Dataset
(194 CVEs).
Category
Maximum Average
# of Modiﬁed File
# of Modiﬁed Method
# of Extracted Features
# of In-method Addition Lines
# of In-method Deletion Lines
# of In-method Modiﬁcation Lines
# of Out-method Lines
10
77
117
1443
138
14
806
2.03
3.10
16.64
31.15
11.11
1.24
12.14
1164    29th USENIX Security Symposium
USENIX Association