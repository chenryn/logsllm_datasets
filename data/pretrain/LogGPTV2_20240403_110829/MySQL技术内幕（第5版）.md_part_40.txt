## Page 169
个对比。）因此，在加上那个出错代码之后，枚举成员的最大数目是65536个；而对于它所占
TINYINTUNSIGNED的取值范围和占用2个字节的整数类型SMALLINTUNSIGNED的取值范围作
以表示256个值，2个字节能表示65536个值。（请试着将它们分别与占用1个字节的整数类型
其字符串形式即为一个空串。）ENUM列占用的存储空间大小由枚举值的个数确定。1个字节可
么它们可能会引起混乱。
在字符串环境里使用ENUM和 SET 列，但是希望它们表现得像数字（或者是情况刚好相反)，
意味着，ENUM和SET值可以用在字符串环境里，也可以用在数字环境里。最后还有一点，如果
储形式是数字，并且也可以把它们当作数字来对待。这意味着，ENUM和 SET类型要比其他字符
归类为字符串类型。但是，ENUM和SET类型实际上有点“人格分裂”：它们的成员在内部的存
成员分隔开。这意味着，你不应该把一个包含逗号的字符串用作 SET的成员。
册
SET列的值，
有这样的值。
要的用作馅料的配料，而且可以有多种选择。这时就可以使用SET来表示这些配料：
的，这时就可以使用SET。
以由集合的任何成员构成。如果有一组固定值，但与在ENUM列里的情况不同，它们不是互斥
集合成员列表。SET类型最多允许有64个成员。它与ENUM类型有所不同，其每一个值列都可
MySQL将从1开始依次对ENUM列定义里的成员进行顺序编号。（编号0被保留为出错代码
类型有着更好的处理性能，因为它们可以使用数字操作来代替字符串操作进行处理。同时也
SET列的定义，可以写成以逗号分隔的单个字符串列表，表示所有的集合成员。另一方面，
在创建ENUM和SET类型列时，需要以字符串的形式列出枚举和集合成员，因此它们都被
上面显示的最后那个值（空串）表示的是，顾客在订购时没有选择任何配料。SET列允许
于是，特定的SET值就代表了顾客实际所选择的那些配料：
SET类型与ENUM类型有相似之处，如在创建SET列时，同样需要为它指定一个所允许的
口
口
口
口
在为ENUM或SET列定义合法取值列表时，必须考虑到以下几个因素。
sausage,onions'
'pepperoni,mushrooms'
SET('pepperoni','sausage','mushrooms','onions','ripe olives')
size ENUM('small','medium',large')
onions'
sausage,mushrooms,ripe olives
SET 列定义里的顺序确定。
当MySQL显示某个由多个集合成员构成的SET值时，这些成员的列出顺序由它们在
序，只是关系更为复杂些，因为其列值可能包含多个集合成员。
ENUM 定义里的值的顺序就是排序所用的顺序。SET定义里的值的排序也确定了排序顺
的排序规则时，这种做法就不可行了。
另一方面，的确可以根据成员大小写的不同来区分它们，但是当你使用不区分大小写
必须严格按照列定义里的大小写字母来书写；否则，它们会被服务器当作是非法的。
'N"。如果这个列带有区分大小写的排序规则或二进制排序规则，那么在插入数据时，
ENUM（'Y'，‘N'）列，那么完全可以插入'y'和'n'；但在检索时，它们会显示为'Y和
将按照列定义的合法取值列表里的字母大小写形式来显示。
如果ENUM或SET列带有一个不区分大小写的排序规则，那么在插入合法值时也不用区
这个列表确定了列的所有允许值，之前已经讨论过这一点。
必须是一个字符串。如果这个值由集合里的多个成员构成，则必须用逗号把各个
例如，那个在线比萨饼服务可能会有一组多选框，用于表示顾客想
3.2MySQL数据类型
例如，定义了一
149
那
---
## Page 170
换句话说，SET成员的数字值都是2的幂。空串对应的SET数字值为0。
SET值里的一个二进制位。第一个成员对应于第0位，第二个成员对应于第1位，依此类推。
列时，它会被赋值为出错成员。只有以数字形式检索，才能把列定义里的空串成员区别出来：
误成员，因此它会对应到两个内部数字元素值。在下面的示例里，当把非法枚举值'x·插到ENUM
序号；NULL值没有序号)：
出错成员。（在严格模式下，会产生一个错误。）
定的是65535（而非65536）个成员。当把某个非法值放入ENUM列时，MySQL会赋值为那个
出错代码预留1个位置，并将它作为每一个枚举的隐含成员，所以在ENUM定义里最多能够指
用的存储空间是1个字节还是2个字节，则取决于成员数是否超过256个。因为MySQL需要为
一
150
一个非零值，与该定义里列出的其他成员没什么两样。但是，空串也被用于那个数值为0的错
SET的值都被存储为二进制位值。每个字节对应8个SET成员，所以一个SET列占用的存储
SET 列的数字表示与ENUM 列稍有不同。SET 成员并没有按顺序编号。每个 SET成员对应着
mySql> CREATE TABLE t（e ENUM('a','','b）);
也可以把空串定义为有效的枚举成员，不过这个时候需要多加注意。这个字符串被赋值为
可以按名字或编号来对ENUM成员进行比较：
mysql> CREATE TABLE e_table （e ENUM('jane','fred','will','marcia'）);
下面这个示例演示了以字符串方式和数字方式检索ENUM值的情况（它会显示枚举成员的
在严格模式下，赋值成非法值'x'会导致错误，并且不会存储任何值。
mysql> SELECT e,e+O FROM t;
mySql>INSERT INTOtVALUES('a'),（),（'b'),(x）;
mySql> SELECTe FROM e_table WHERE e=3;
mysql> SELECT e FROM e_table WHERE e='will';
mysql>
mysgl>
will
e
will
e
D
NULL
marcia
will
fred
jane
第3章数据类型
INSERT
e+0
NULL
e+0
INTOe_table
NULL
1e*3
NULL
12
6
---
## Page 171
表面看起来不正确，因为这些值没有按字母顺序显示，但它实际毫无问题：
那么最终是无法找到这行的；必须使用table，chair'来查找才行。
必须按正确的顺序列出各个成员。例如，先插入'chair，table'，然后搜索'chair，table"，
例里，当赋予某个包含‘couch'的值时，会引发一个错误，并且赋值操作也会失败。
掉
SET
形式来显示具体的数值：
应的那些字符串组合而成。
于这样的值可以展开为某种二进制位的组合，因此它也可以由SET定义里与这些二进制位相对
个、17~24个、25~32个、33~64个，那么与之对应的占用字节空间分别为1、2、3、4或8个字节。
空间取决于它的成员个数，最多只能有64个成员。如果SET的成员数量范围分别为1~8个、9~16
ENUM和SET列的排序和索引操作都是按列值的内部值（即数字值）执行的。下面这个示例
MySQL会重排SET列值里的成员，这一事实说明：如果要搜索那些使用字符串的值，那么
下面这个示例演示了SET列的字符串形式与数字形式之间的关系。它会以十进制和二进制
既然一个 SET 可以由一组二进制位表示，那么一个 SET值就可以由多个集合成员组成。由
mysql> SELECT e FROM e_table ORDER BY e;
在严格模式下，使用非法SET成员将导致错误，并且这个值也不会被存储。在前面这个示
如果把·chair，couch，
剩余的子字符串会被赋给这个列。以后检索这个值时，也看不到那些非法子字符串。
不过，在以后的检索操作中，这个成员是按它们在声明里的先后顺序显示的。此外，在给
在对SET列进行赋值时，其中各个子字符串的顺序不用与定义这个列时所用的顺序完全一
列赋值时，如果这个值包含的某些子字符串不属于集合成员，那么这些子字符串会被剔除
当把值·lamp，stool·赋给s列时，MySQL会在其内部把它存储为10（二进制数1010)，
口
mysql>
mysql>
mysql> CREATE TABLE s_table（s SET（table',lamp','chair','stool'）));
NULL
口
NULL
'couch'会
stool
chair
1amp
将来检索这个值时，它将显示为'table，chair'。在检索时，MySQL会按顺序扫描名
MySQL会为每一个值的子字符串确定出与之对应的二进制位，并把它们组合成存储
table
么在检索时也只会看到一个·lamp”。
索结果里也只会出现一次。
符串自动重排。这种重排行为还意味着：即使你把某个值多次赋给一个SET列，它在检
个位，并根据数字值构造出对应的字符串值；同时，还会按照列定义里的顺序对子字
SELECT S,S+O,BIN(s+O) FROM S_table;
INSERT
S+0
NULL
被剔除掉，因为它不是集合成员。之所以如此，是因为在赋值过程中
8
2
INTO s_table
IBIN(S+O)
NULL
10
1
1000
100
table·赋值给s_table表里的s列，那么会发生两件事。
，也就是说，如果把'lamp，lamp，lamp·赋值给SET列，那
3.2MySQL数据类型
151
---
## Page 172
规则。这些默认选项在创建表时能发挥一定作用，稍后即将看到。）
选项，从而改写表的默认选项。（事实上，与服务器一样，每个数据库都有默认的字符集和排序
3.2.5.5字符串数据类型属性
的是字节串，而非字符串。
SET。它们并不适用于二进制串数据类型（BINARY、VARBINARY和 BLOB），因为这些类型包含
指定字符集和排序规则。你可以把它们指定为表自身的默认选项；也可以指定为各个列的单独
符串的转换操作——它会改变这些值的排序特性，从而可以按字符串方式进行排序。
一级，都要遵从以下规则。
转换为一个非ENUM的字符串，然后再对结果进行排序：
顺序输出。
你想要的顺序列出各个枚举成员。然后，在各种排序操作中，这些列值便会自动按事先设定的
锋、接球手、边线防守队员等）进行输出。那么，你可以把这个列定义为ENUM类型的，并按
根据个人的位置来对输出结果进行排序，以便按特定的顺序（如教练、助理教练、四分卫、
特性。即先将这些值表示为某个表里的一个 ENUM列，并在该列的定义里按照你想要的顺序依
，在指定CHARACTER SET和 COLLATION 属性时，不管是在列、表和数据库这三级别中的哪
CHARACTER SET和COLLATION属性适用的数据类型有CHAR、VARCHAR、
字符串数据类型特有的属性有CHARACTER SET（或CHARSET）和COLLATE，它们分别用于
如果想让某个ENUM列按常规的字母表顺序排序，那么可以先用CAST（）函数把这个列的值
口使用的字符集必须是服务器支持的。使用 SHOW CHARACTER SET 语句可以查出当前可用
CAST（）函数并没有更改这些显示值，它在这条语句里的作用只是完成了一个从ENUM到字
mysql> SELECT CAST(e AS CHAR) AS e_str FROM e_table ORDER BY e_str;
如果有一组固定值，而你想按某种顺序对它们进行排序，那么可以利用ENUM类型的排序
mysql> SELECT e, e+O FROM e_table ORDER BY e;
为了更好看清是怎么回事，
NULL
will
marcia
e_str
marcia
will
jane
NULL
e
marcia
fred
wi11
fred
jane
第3章数据类型
NULL
下面同时检索ENUM值的字符串形式和数字形式：
TEXT、ENUM和
跑
---
## Page 173
务器等多个级别进行指定。在MySQL处理字符列的定义时，会依次根据下述原则为它确定使
用何种字符集。
出具体的字符集)：
它没有显示列的排序规则，则表明该列的排序规则与该列的字符集默认排序规则相同。
latinl_german_ci 确定的。
这是字符集latin2的默认排序规则。c3 列的字符集是latin1，它是根据该列的排序规则名
进制串类型，
没有使用表级的字符集和排序规则：因为c2和c3列有它们自己的字符集信息，而c4列有二
表排序规则为utf8字符集的默认排序规则（即 utf8_genaral_ci）。因为c1 列的定义里没有
包
含CHARACTER SET属性和COLLATION 属性，所以它将使用表的默认设置。C2、C3和c4列
前面的讨论只提到了列和表的字符集设置情况，其实字符集还可以在列、表、数据库和服
也可以给 SHOWCOLUMNS语句加上关键字FULL，用于显示排序规则信息（可以根据它推断
|Field|Type
mySql> SHOW FULL COLUMNS FROM mytb1;
如果 SHOWCREATE TABLE 没有显示列的字符集，
Create
如果想要查看某个已有表的字符集信息，那么可以使用 SHOWCREATE TABLE语句：
最终的表将使用utf8作为其默认字符集。
CREATE TABLE mytbl
通过下面这条语句，可以看到上述规则的应用情况。该语句会创建一个使用多种字符集的表。
口如果定义里同时使用了CHARACTER SET和COLLATION 属性，那么它们所代表的字符集
口
口
&
ENGINE=InnoDB DEFAULT CHARSET=utf8
CHARACTER SET utf8;
C4`
C3
3
25
规则名的第一部分来确定。
如果定义里只有COLLATION，而没有CHARACTER SET，那么具体的字符集就要由排序
如果定义里只有CHARACTER SET，而没有COLLATION，则使用默认排序规则。
每一种字符集所支持的排序规则显示出来。
latin2_croatian_ci，但不能使用 latin1_bin。使用 SHOW COLLATION 语句可以把