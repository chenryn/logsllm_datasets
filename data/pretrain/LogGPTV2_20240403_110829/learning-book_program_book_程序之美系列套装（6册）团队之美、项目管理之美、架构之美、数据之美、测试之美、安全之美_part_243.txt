作。在压缩代码中使用浮点数来表示像素数据，这也意味着对于每
个图像，比起16位整数的原始图像表示方式，浮点数占用了其四倍
的内存空间。
第二种压缩方式，也称为Rice无损压缩（RceLossless)或者Rice压
缩，采用了由JetPropulsion实验室的RobertRice开发的一种算法，
该Rice算法可以对图像数据实现几乎2：1的压缩效果，且没有数据
损失。而JIPEG算法在压缩过程中去失了部分数据。Rice压缩方法也
是在图像槽中就地对图像进行压缩。
两种无压缩的缩小图像大小技术或者采用查询表，把12位的像素值
映射到8位的像素值，或者采用位缩小技术，对像素数据向右移动4
位，生成一个每个像素8位的图像。JPEG和Rice压缩函数都接受12
位或者8位的图像数据。
是否采用有损的JPEG压缩方式，通常需要对各种因素进行权衡，比
如数据需要达到的精确度、可用的带宽大小、太空飞行器的主机有
多少可用的“下行"存储空间、有多少时间可用于执行压缩（之前提
1378
---
## Page 1380
过，RAD6000的最高速度是20MHz，因此压缩1M像素的图像数据可
能需要超过1秒钟）。
当使用JPEG压缩方式时，采用的压缩比率是通过命令行参数决定，
该命令行参数指定结果数据在最差情况下的压缩比率。换句话说，
ICS不是指定一个“质量"因子（该因子通常表示JPEG压缩方法需要
达到的压缩级别），而是使用一个可扩展因子，自动计算得出需要
的压缩级别。这是基于全局"图像熵"(iageentropy)的"快查"(qick
1ook分析。图像熵是图像“紧忙"程度的估计值，熵值越高的图像
（在亮度上有很多细节和变化，如有很多鹅卵石的地面，阴影对比
分明）将需要更高的压缩设置来满足最终的目标图像大小限制。对
于熵值低的图像，比如飘着一些云彩的Martian天空，没有太多的细
节和变化，因而只要较少的压缩量就能满足目标图像大小限制。
IPEG压缩算法扩展因子也用于把原始图像划分成不同的分段。这些
分段一次一个地传给JIPEG压缩器，其输出被写回到图像的槽。在执
行"下行"操作之前，图像槽的最终结果是一组小的、自包含的JIPEG
图像，这些图像的全部大小不大于由命令行指定压缩比率的原始图
像大小。
Rice压缩器包含它自已的嵌人式分段方法，而且其“下行"操作是简
单地通过读出压缩数据，这些压缩数据通过小的分包方式，分包大
小适合太空飞行器主机的闪存大小。查询表和减少位的方法的输出
也是简单地读出闪存大小的包，用于“下行"操作。
“下行"或一切都从这里向下传输
太空飞行器的飞行软件处理过程的最后一步是传送图像给“下行”管
理器。一些科学设备可以简单地把数据传给“下行"程序，完成处
理；但是，由于海量的数据以及采用分包的方式，结果是ICS本身
需要完成很多的预处理操作。
对于IPEG数据，这意味着需要分别单独处理每次的图像压缩分段。
数据头。中间分段的头数据大小较小，包含一个图像ID号和序列
号。由于每个分段都是从图像槽读取数据，所以采用了头数据。采
用滑动窗口的方式向外读取数据，使得分段在以闪存大小分包组合
时，可以对分段执行端对端（ed-to-end)地打包。反过来，它允许“下
行"处理器最大化使用临时闪存存储空间，因为如果一部分图像对
1379
---
## Page 1381
应的分段的值很小，那么一些压缩的分段可能比其他的分段小。
实际上，压缩的分段大小区别很大是很常见的，因此对这些分段执
行端对端地打包避免了浪费飞船上任何的闪存资源。
因为数据是由唯一识别的分段组成的，“下行”过程丢失一个分包并
不会导致整个图像毫无用处。在JIPL，地面上的重构和解压缩软件
能够识别出丢失了哪个分段，然后简单地把丢失的那部分图像以全
0像素数据来填充。如果后期获取到丢失的那部分数据（这是可能
的，因为考虑到数据的“下行"过程是非常曲折的），那么这部分数
据就可以用来填充之前去失的那部分像素数据。
一旦发送数据给“下行"处理器，ICS就完成任务，并且释放该图像
数据的插槽。这整个过程（从图像曝光到完成发送给“下行"程序）
需要3～10分钟，这依赖于CPU速度和其他额外必定发生的成像处
理，如自动曝光和寻找光线（这两者本身就非常复杂，所以我们不
在这里讨论）。
结束语
该设备软件所完成的任务要远远多于照相和处理图像数据。它也管
理SSI的三（自由）度运动控制，以及RAC中的聚焦和视角。RAC
还支持多色的LED，包括红、蓝和绿，照亮任何可能在机械臂范围
内的视角，然后生成彩色图片。SSI和RAC都结合了活动的热控
制，这或者是通过使用特定的加热器，或者是故意拖延一个步进电
机来达到自我加热。所有这些操作都包含错误检查和容错恢复。总
之，该设备软件任务非常“繁忙”。如果让我重新设计该软件，我希
望改变的主要方面是，照相机使用的是它们自己的嵌入式处理器，
而不是依赖于太空飞行器的CPU。这样会使所有的操作都变简单得
多。除了这点，我总觉得对于每个设备任务，“挤进”了太多的操
作。换句话说，热控制对于每个照相机本应该是一个独立的任务。
这样就可以极大地减少每个任务的复杂度，虽然其代价是增加全局
任务间通信的复杂度。然而，在刚并始时，没有足够的理由来这么
做，因此当有一些新的加热需求需要对设计做出调整时，该设计已
经很固定了（没有冻结，只是非常不灵活）。
最后，对于选择“心跳"检查方式，我真的是很不支持。我原先不知
道命令消息队列是为了进行“心跳"检查。这种“心跳"检查方式对设
备任务提出了需求，要求每个任务能够放弃任何它们正在做的事，
通过"ping"消息定时检查命令消息队列。我相信更好的方式应该是
1380
---
## Page 1382
让设备注册一个太空飞行器飞行软件回调函数，该函数可通过异步
方式，检查连续更新的计数器变量的值。如果在一定时间后，该值
没有更新，则该设备任务很可能已经崩溃。当时确实对这种实现方
式有很多争议，最后采用ping消息的方式，仅仅是因为这是一种通
用的方式，而且已有的测试系统就是这么设计处理的。因此，即使
系统不是为了需要花费好几分钟来处理的海量图像数据而设计的，
但是该设计方式也不会发生改变。
凤凰号火星着陆探测器的SSI和RAC/OM成像软件在设计、实现和测
试上有很多工作要做，而且在最后，它完成了在其使命的整个生命
周期中应该完成的任务。图3-11是该太空飞行器在火星上的第一
天，即Sol1，从SSI返回的第一批图像之一
(S001EDN896308958_10D28R1M1）。
图3-11：从Sol1的SSI返回的图像（图像来源：NASA/JPL/Arizona
大学）
1381
---
## Page 1383
更多关于凤凰号火星着陆探测器
如果你想对凤凰号火星着陆探测器的使命了解更多，可以查看以下
几个主要来源：
Arizona大学的Phoenix网站：·http：//phoenix.lpl.arizona.edu
Jet PropulsionLaboratory(JPL实验室）的Phoenix网站：
http://www.jpl.nasa.gov/news/phoenix/main.php
NASA的Phoenix网站：
·http://www.nasa.gov/mission_pages/phoenix/main/index.html
在JPL，MIPL为各种任务做了很多图像处理，你可以通过以下站点了
解更多：
JPL的Mission图像处理实验室：·http：//www-mipl.jpl.nasa.gov/
如果你想对RAD6000CPU、图像处理或嵌入式系统了解更多，可以
查阅Wikipedia:http：//www.wikipedia.org。
第4章PNUTShell中的云存储设计
Brian F. Cooper、Raghu RamakrishnanHUtkarsh Srivastava
简介
雅虎公司运营着世界上最受欢迎的多个网站，每月的访问用户有5
亿之多。这些Web站点的后台数据系统存储了种类庞杂的数据，如
用户信息、照片、餐馆点评、博客博文以及大量其他数据。雅虎开
发部署了多套成熟、稳定的数据库体系来支持它的站点，同时这些
架构也为用户提供低延迟的数据访问方式来快速加载页面。
但是，这些系统存在着一些严重的局限性。首先，系统扩容困难。
为了进行系统扩容，通常需要数月的时间来规划和重组数据，并且
在扩容过程中，相关应用的服务质量会受到影响。此外，有些系统
可支持的扩展性具有上限值，即使增加硬件支持也无济于事。其
次，很多早期设计的系统，其设计思想就是基于单一的数据中心。
雅虎已经发展为全球性的品牌，其厂泛的基础用户遍及全世界。为
了提供良好的用户体验，系统需要复制数据到离用户近的数据中
1382
---
## Page 1384
心，这样当用户访问时，页面就可以快速加载。由于数据库系统本
身并没有将全球性数据复制作为内建的功能提供，每个应用需要自
已构建数据复制，这导致复杂的应用逻辑和薄弱的数据基础。部署
一个大规模的、在不同地理空间上都存在数据副本的数据库架构需
要很大投入，因此，在这样的架构上，很难快速地并发新的应用或
在已有的应用上增加新的特性。
PNUTS系统致力于支持雅虎的Web站点和应用平台，并解决上述局
限（Coper等2008）。在设计上，它通过云存储方式，可以有效地处
理租户应用(tnantapplications)中复杂的读写工作，并且支持本地全
球数据复制。和很多其他的分布式系统类似，PNUTS通过水平数据
分区的方式，将数据分布到一组存储服务器阵列上，从而实现高性
能和可扩展性。该系统的核心不是复杂的分析和决策支持工作，而
是从最初设计就把两个属性作为首要特征：
向外扩展(sale-out)
系统通过分区将数据分布式存储到多台服务器上，扩充系统容量犹
如增加新的服务器一样容易，且系统可以平滑地将负载分配到新的
服务器上。
地理空间上的数据复制(go-replication)
在PNUTS系统中，数据可以自动地复制到全世界。一旦并发者告诉
系统在哪个区域（clos，即数据中心）复制数据，系统本身就会自
动地完成诸多细节操作，包括故障处理（如机器、链接甚至整个区
域）的一些细节操作。
PNUTS系统还设置了一些其他的目标，尤其是，我们希望应用并发
者能够专注于应用逻辑本身，而不是操作数据库的具体细节。因此
该系统对数据库采取托管方式，并为并发者提供一个简洁易用的
API来存储和访问这些数据，而不需要他们自己对一大堆参数进行
调优。由于系统采取托管方式，在功能实现上，它能够尽可能达到
目我维护。
尽管这些目标都很重要，而且构建一个能够向外扩展且易于全球性
数据复制的数据库系统是对公司最有吸引力和直接价值的。随着开
始系统设计，我们清楚地发现很多长期普及和使用的数据库系统机
制需要重新考虑（Rmakrishnan和Gehrke2002）。
1383
---
## Page 1385
实现向外扩展和地理空间上数据复制的核心思想是只进行简单廉价
的同步操作，而在后台异步式地实现所有代价高的操作。举个例
子，当一个加州的用户想用一个关键字来标注一张照片，她必定不
愿意等待该系统把该标签提交到在新加坡的标签数据库副本（从加
州到新加坡的网络延迟可能高达1秒）。然而，她还是希望她的新
加坡朋友能够看见该标签，因此需要在后台对新加坡的数据库副本
完成快速（几秒内）、可靠的异步更新。
另一个如何发挥异步作用的例子是诸如聚集查询和连接操作，它们
通常需要在多台服务器上执行数据操作。随着系统规模扩大、负荷
加重，这些服务器出现响应变慢或者崩溃的概率也随之增加，因此
会增加请求延迟。为了解决该问题，我们可以维护实体化视图
(mterializedviews)来重组这些基础数据，这样一些预先设定的复杂