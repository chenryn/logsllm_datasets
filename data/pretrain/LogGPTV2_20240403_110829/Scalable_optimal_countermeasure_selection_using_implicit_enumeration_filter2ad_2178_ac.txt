ğ‘›âˆ‘
ğ‘—=1
ğ‘¥ğ‘— Ã— ğ‘ğ¶ğ‘€ğ‘—
(4)
subject to the same constraint as in Eq. (2) (covered set =
ğ’œ). With the objective function ğ¹2 and the constraint given
above, the optimization problem is still a linear zero-one
integer programming problem. We build a recursion tree of
all possible solutions while computing cover under ğ¹2 in
search of the optimal solution. After the current best solution
is found, the tree is pruned whenever we come across a
solution that is worse than the current best solution. Some
terminology relevant to the branch and bound algorithm are
summarized as follows:
âˆ™ Partial Solution: A partial solution consists of a subset
of the entire solution. Consider the complete solution as
a binary n-vector {ğ‘¥1, ğ‘¥2,..., ğ‘¥ğ‘šâˆ’1, ğ‘¥ğ‘š,... ğ‘¥ğ‘›âˆ’1, ğ‘¥ğ‘›}.
At any stage, we may have a partial solution of the
form P = {ğ‘¥1, ğ‘¥2, ..., ğ‘¥ğ‘šâˆ’1, ğ‘¥ğ‘š}= {1,0,..., 0,1}, with
unassigned values for {ğ‘¥ğ‘š+1,...,ğ‘¥ğ‘›}.
âˆ™ Upper Bound (ğ‘ğ‘ˆ ): This is the value of the objective
function for the best feasible solution found so far. If no
solution has yet been found, upper bound is assumed
to be
âˆ™ Lower Bound (ğ‘ğ¿): For each partial solution, a lower
bound for the value of the objective function of the
solutions within that subset can be computed.
ğ‘—=1 ğ‘ğ¶ğ‘€ğ‘— .
âˆ‘ğ‘›
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:17:10 UTC from IEEE Xplore.  Restrictions apply. 
Algorithm 2 Algorithm for solution with obj. function ğ¹1
OPTCMACT (ACT mincuts from SHARPE) {
1. Initialize ğ’ªğ’«ğ’¯ (optimal set of countermeasures) = ğœ™,
m = âˆ£ğ’œâˆ£ and n = âˆ£ğ’â„³âˆ£.
where, ğ’œ = set of atomic attack events in ACT
2. Initialize the ğ‘š Ã— ğ‘› matrix (T)
for every ğ´ğ‘– âˆˆ ğ’œ
ğ’â„³ = set of all countermeasures
for every ğ¶ğ‘€ğ‘— âˆˆ ğ’â„³
if (atomic attack event ğ´ğ‘– is covered by countermeasure
ğ¶ğ‘€ğ‘—)
set ğ‘¡ğ‘–ğ‘—= 1
else set ğ‘¡ğ‘–ğ‘—= 0
end if
end for
end for
3. If ğ’œ âˆ•= ğ’ğ’±ğ’®, (partial cover with intent)
(where ğ’ğ’±ğ’®=set of atomic attack events to be
covered)
eliminate all rows in T /âˆˆ ğ’ğ’±ğ’®
end if
4. Eliminate any row in T with all zeros (partial cover w/o
intent i.e. this atomic attack event cannot be covered)
5. (ğ’ªğ’«ğ’¯ ,T) = REDUCE (ğ’ªğ’«ğ’¯ ,T) /*matrix reduction*/
6. if (T is a column matrix (ğ¶ğ‘€ğ‘˜))
{ğ¶ğ‘€ğ‘˜} /*greedy solution works*/
ğ’ªğ’«ğ’¯ =ğ’ªğ’«ğ’¯ âˆª
else /*cyclic unate covering problem*/
/*call branch and bound*/
ğ’ªğ’«ğ’¯ =ğ’ªğ’«ğ’¯ âˆª
matrix T is cyclic ğ‘
Zğ‘ˆ =no. of columns in T,ğ‘ğ’â„³={1,1,...,1})ğ‘
B&BACT (ğ’«=ğœ™,T,ğ’ªğ’«ğ’¯ 1=ğœ™,Zğ¿=0,
end if
7. return ğ’ªğ’«ğ’¯
}
âˆ™ Fathoming Tests: A partial solution is said to be fath-
omed if the corresponding subtree in the recursion tree
can be excluded from further consideration. A partial
solution can be fathomed if:
(1) Lower bound of the partial solution exceeds the
current upper bound of the objective function i.e.,
ğ‘ğ¿ â‰¥ ğ‘ğ‘ˆ .
(2) The subset of solutions under this partial solution
contains no feasible solutions. In terms of the matrix
T and partial solution {ğ‘¥1, ğ‘¥2, ..., ğ‘¥ğ‘šâˆ’1, ğ‘¥ğ‘š}, the
test is:
ğ‘šâˆ‘
âˆƒğ´ğ‘– âˆˆ ğ’œ,
ğ‘¡ğ‘–ğ‘— Ã— ğ‘¥ğ‘— +
ğ‘›âˆ‘
ğ‘¡ğ‘–ğ‘—  1
(6)
Algorithm 3 Recursive Branch and Bound algorithm
B&BACT (ğ’«, T, ğ’ªğ’«ğ’¯ , ğ‘ğ¿, ğ‘ğ‘ˆ , cğ¶ğ‘€ ) {
1. /*compute lower bound*/
ğ‘ğ¿=LOWER BOUND(ğ’«, ğ‘ğ¿, cğ¶ğ‘€ )
2. /*is current solution bounded ?*/
if (ğ‘ğ¿ â‰¥Zğ‘ˆ ) /*start Fathoming Test 1*/
else /*end Fathoming Test 1*/
return (ğ’ªğ’«ğ’¯ ,ğ‘ğ‘ˆ ) /*return current optimal*/
/*are there any feasible solutions in this subtree ?*/
for every ğ´ğ‘– âˆˆ ğ’œ /*start Fathoming Test 2*/
3.
sumğ‘–=sumğ‘–+ğ‘¡ğ‘–ğ‘— âˆ— ğ‘¥ğ‘—
sumğ‘–=0
for every ğ‘¥ğ‘— âˆˆ ğ’«
end for
for every ğ‘¥ğ‘— /âˆˆ ğ’« & ğ¶ğ‘€ğ‘— âˆˆ ğ’â„³
end for
if (sumğ‘– = 0) /*current solution is bounded*/
return (ğ’ªğ’«ğ’¯ ,ğ‘ğ‘ˆ ) /*return current optimal*/
sumğ‘–=sumğ‘–+ğ‘¡ğ‘–ğ‘—
end if
end for /*end Fathoming Test 2*/
/*is current ğ’« a feasible solution for this subtree?*/
ï¬‚ag=0 /*start Fathoming Test 3*/
for every ğ´ğ‘– âˆˆ ğ’œ /*for every row*/
sumğ‘–=sumğ‘–+ğ‘¡ğ‘–ğ‘— âˆ— ğ‘¥ğ‘—
sumğ‘–=0
for every ğ‘¥ğ‘— âˆˆ ğ’«
end for
if (sumğ‘– = 0)
ï¬‚ag=1
{ğ‘¥ğ‘˜+1,ğ‘¥ğ‘˜+2,....,ğ‘¥ğ‘›} /*set new optimal*/
âˆª
else /*Fathoming Test 3 failed*/
end if
end for
if (ï¬‚ag = 0) /*found new optimal*/
k=âˆ£ğ’«âˆ£
set all ğ‘¥ğ‘˜+1 to ğ‘¥ğ‘› to 0
ğ’ªğ’«ğ’¯ =P
ğ‘ğ‘ˆ = ğ‘ğ¿ /*set new upper bound = current ğ‘ğ¿*/
return (ğ’ªğ’«ğ’¯ ,ğ‘ğ‘ˆ ) /*return new optimal*/
(ğ’ªğ’«ğ’¯ ,ğ‘ğ‘ˆ )= B&BACT(ğ’«âˆª
ğ‘¥ğ‘˜=1 /*Branch*/
if (ğ’ªğ’«ğ’¯ = P
else /*search the right subtree*/
return (ğ’ªğ’«ğ’¯ ,ğ‘ğ‘ˆ ) /*return current optimal*/
(ğ’ªğ’«ğ’¯ ,ğ‘ğ‘ˆ )= B&BACT (ğ’« âˆª
ğ‘¥ğ‘˜=0
ğ‘ğ‘ˆ ,ğ‘ğ¶ğ‘€ )
return (ğ’ªğ’«ğ’¯ ,ğ‘ğ‘ˆ ) /*return optimal*/
ğ‘¥ğ‘˜) /*skip the right subtree*/
âˆª
ğ‘¥ğ‘˜,T,OPT,ğ‘ğ¿,ğ‘ğ‘ˆ ,ğ‘ğ¶ğ‘€ )
ğ‘¥ğ‘˜, T, ğ’ªğ’«ğ’¯ ,ğ‘ğ¿,
4.
5.
end if
end if
}
âˆ‘
âˆ‘ğ‘›
in the T matrix are removed and placed in the set â„°ğ’®ğ’® and
the sum of the costs of the countermeasures in â„°ğ’®ğ’® is stored
âˆ€ğ¶ğ‘€ğ‘—âˆˆâ„°ğ’®ğ’® ğ‘ğ¶ğ‘€ğ‘— . The call B&BACT (ğ’«=ğœ™, T,
in ğ‘â„°ğ’®ğ’® =
ğ’ªğ’«ğ’¯ =ğœ™, ğ‘ğ¿=0, ğ‘ğ‘ˆ =
ğ‘—=1 ğ‘ğ¶ğ‘€ğ‘— , ğ‘ğ¶ğ‘€ ) to Algorithm 3
returns an optimal countermeasure set (ğ’ªğ’«ğ’¯ ). Set union of
ğ’ªğ’«ğ’¯ and â„°ğ’®ğ’® gives us the optimal solution corresponding
to the objective function ğ¹2 (where ğ‘ğ¶ğ‘€ ={ğ‘ğ¶ğ‘€1,ğ‘ğ¶ğ‘€2 ,...,
ğ‘ğ¶ğ‘€ğ‘›}) and the corresponding optimal value of the objective
function ğ¹2 is obtained by adding ğ‘â„°ğ’®ğ’® to ğ‘ğ‘ˆ .
The recursive branch and bound algorithm [19] for comput-
ing the optimal countermeasure set using the objective func-
tion ğ¹2 is depicted in Algorithm 3. For objective function ğ¹2,
the T matrix for the ACT is generated. The essential columns
The corresponding procedure for computation of lower
bound is shown in Algorithm 4. We obtain the optimal
countermeasure set as {ğ¶ğ‘€1,ğ¶ğ‘€2} using Algorithm 2
on the ACT for TCP Sequence Number attack (shown
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:17:10 UTC from IEEE Xplore.  Restrictions apply. 
in Figure 5) with the objective function ğ¹1. Here one of
the three optimal solutions is selected by the branch and
bound algorithm and the other solutions are bounded under
fathoming test 1 and hence discarded. Using ğ¹2 on the BGP
ACT, an optimal countermeasure set of {ğ¶ğ‘€121,ğ¶ğ‘€2} with
minimum security investment cost = 80$ is returned. The
necessary input parameter values are in Table A.3 and Table
A.4.
Attack success
Attack success
AND
A
AND
D
M
D1
(a)
AND
A
OR
D2
â€¦
Dm
AND
M1
(b)
Attack success
AND
A
AND
Attack event
Detection event
Mitigation Event
OR
â€¦.
M2
Mn
D1
AND
M1
(c)
AND
â€¦
AND
D2
M2
Dn
Mn
Algorithm 4 Computing lower bound for obj. function ğ¹2
LOWER BOUND(ğ’«, ğ‘ğ¿, cğ¶ğ‘€ ) {
1. k=âˆ£ğ’«âˆ£
2. if ğ‘¥ğ‘˜ = 1
ğ‘ğ¿=ğ‘ğ¿ + ğ‘ğ¶ğ‘€ğ‘˜
return ğ‘ğ¿ /*return new lower bound*/
return ğ‘ğ¿ /*return old lower bound*/
else
end if
}
IV. OPTIMAL COUNTERMEASURE SELECTION WITH
PROBABILITY ASSIGNMENTS
In this section, we discuss the selection of optimal
countermeasure set from ACT with probability assignments.
Probability of success of an attack, detection or mitigation
event can be measured using simulation, emulation (like,
DETER testbed [21]), a testbed (in which real security
attack, detection and mitigation events happen) [22], a
honeypot [23] or IDS log information as in [8]. Incorporating
these probability values into our optimization problem, we
can provide more efï¬cient optimal solutions.
A. Quantitative Analysis using probability values
Quantitative analysis using ACT also includes metrics
such as probability of attack, risk and return on investment.
Probability of Attack. Figure 6(a) shows an ACT with
one atomic attack event, one detection event and one mit-
igation event. Eq. (7) is the corresponding expression for
the probability that attack is successful, i.e., either attack
is undetected or the attack is detected but unmitigated (ğ·
represents a detection event and ğ‘€ represents a mitigation
event).
ğ‘ƒğ‘”ğ‘œğ‘ğ‘™ = ğ‘ğ´(1 âˆ’ ğ‘ğ· + ğ‘ğ·(1 âˆ’ ğ‘ğ‘€ ))
= ğ‘ğ´(1 âˆ’ ğ‘ğ· Ã— ğ‘ğ‘€ ))
(7)
Figure 6.
(a) ACT with one attack, one detection and one mitigation event,
(b) one attack, ğ‘š detection and ğ‘› mitigation events and (c) one attack and
multiple pairs of detection and mitigation events
detected. The corresponding expression for ğ‘ƒğ‘”ğ‘œğ‘ğ‘™ is:
ğ‘ƒğ‘”ğ‘œğ‘ğ‘™ = ğ‘ğ´
ğ‘›âˆ
ğ‘–=1
(1 âˆ’ ğ‘ğ·ğ‘–
Ã— ğ‘ğ‘€ğ‘–
))
(9)
Table II enumerates formulae for output probability for
AND, OR gates and k-of-n gates (with identical inputs for
k-of-n gates) in an ACT without repeated events.
Risk Computation. Risk to the system is deï¬ned as the
expected value of the impact. Hence Riskğ‘ ğ‘¦ğ‘  is the product
of the amount of damage an attack scenario can render to
the system (ğ¼ğ‘”ğ‘œğ‘ğ‘™) and probability of attack success (ğ‘ƒğ‘”ğ‘œğ‘ğ‘™):
Riskğ‘ ğ‘¦ğ‘  = ğ‘ƒğ‘”ğ‘œğ‘ğ‘™ Ã— ğ¼ğ‘”ğ‘œğ‘ğ‘™
(10)
ROI Computation. The basic deï¬nition of ğ‘…ğ‘‚ğ¼ğ¶ğ‘€ğ‘—
[4] is the proï¬t obtained by the implementation of ğ¶ğ‘€ğ‘—
(thereby signifying the efï¬cacy of that countermeasure).
ROI for countermeasure ğ¶ğ‘€ğ‘— is a function of the impact
of attack, the decrease in the probability of attack at the
âˆ’ ğ‘ƒgoal with ğ¶ğ‘€ğ‘— ) due to ğ¶ğ‘€ğ‘—
ACT goal (ğ‘ƒgoal without ğ¶ğ‘€ğ‘—
and the security investment cost for ğ¶ğ‘€ğ‘— (ğ‘ğ¶ğ‘€ğ‘— ). Adapting
Sonnenreichâ€™s deï¬nition of Return on Security Investment
[4], we have:
proï¬t from CMğ‘— âˆ’ Cost of implementing CMğ‘—
ğ¼ğ‘”ğ‘œğ‘ğ‘™ Ã— (ğ‘ƒgoal without ğ¶ğ‘€ğ‘—
Cost of implementing CMğ‘—
âˆ’ ğ‘ƒgoal with ğ¶ğ‘€ğ‘—
ROIğ¶ğ‘€ğ‘—
=
) âˆ’ ğ‘ğ¶ğ‘€ğ‘—
ROIğ¶ğ‘€ğ‘—
=
ğ‘ğ¶ğ‘€ğ‘—
(11)
Figure 6(b) shows an ACT with one atomic attack event,
ğ‘š detection events and ğ‘› mitigation events. The correspond-
ing probability of successful attack is:
ğ‘ƒğ‘”ğ‘œğ‘ğ‘™ = ğ‘ğ´(1 âˆ’ (1 âˆ’ ğ‘šâˆ
(1 âˆ’ ğ‘ğ·ğ‘– )) Ã— (1 âˆ’ ğ‘›âˆ
(1 âˆ’ ğ‘ğ‘€ğ‘– )))
(8)
ğ‘–=1
ğ‘–=1
Figure 6(c) shows an ACT with one atomic attack event
and ğ‘› pairs of detection and mitigation events. The nature
of mitigation triggered depends on the nature of intrusion
FORMULAE FOR PROBABILITY OF ATTACK SUCCESS
Table II
Gate type
AND gate
OR gate
k/n gate
Prob. of attack success
âˆğ‘›
ğ‘–=1 ğ‘(ğ‘–)
1 âˆ’ âˆğ‘›
ğ‘–=1(1 âˆ’ ğ‘(ğ‘–))
)
ğ‘ğ‘— âˆ— (1 âˆ’ ğ‘)ğ‘›âˆ’ğ‘—
(
âˆ‘ğ‘›
ğ‘—=ğ‘˜
ğ‘›
ğ‘—
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:17:10 UTC from IEEE Xplore.  Restrictions apply. 
ROI for a set of countermeasures (S) can be deï¬ned simi-
larly. ROIğ‘† is as in Eq. (12) where âˆ£ğ‘†âˆ£=m.
ğ¼ğ‘”ğ‘œğ‘ğ‘™ Ã— (ğ‘ƒgoal without S âˆ’ ğ‘ƒgoal with S) âˆ’ âˆ‘ğ‘›
ğ‘—=1 ğ‘¥ğ‘— Ã— ğ‘ğ¶ğ‘€ğ‘—
ROIğ‘† =
âˆ‘ğ‘›
ğ‘—=1 ğ‘¥ğ‘— Ã— ğ‘ğ¶ğ‘€ğ‘—
(12)
Note that, for any 0  -1.
B. Maximize the proï¬t from implementing a set of counter-
measures
Proï¬t from implementing a set of countermeasures (S) is
the value of the numerator of ROIğ‘†. The objective function
in this case is to select ğ‘¥ğ‘— âˆˆ {0, 1}âˆ€ğ‘— so as to,
max
âˆ€ğ’®âˆˆ2ğ’â„³
ğ¹3 = ğ‘…ğ‘‚ğ¼ğ‘† Ã— ğ‘›âˆ‘
ğ‘¥ğ‘— Ã— ğ‘ğ¶ğ‘€ğ‘—
ğ‘—=1
= ğ¼ğ‘”ğ‘œğ‘ğ‘™ Ã— (ğ‘ƒgoal without S âˆ’ ğ‘ƒgoal with S)
âˆ’ ğ‘›âˆ‘
ğ‘¥ğ‘— Ã— ğ‘ğ¶ğ‘€ğ‘—
(13)
ğ‘—=1
where S={CM1,CM2,...,CMğ‘š} and the constraint (covered
set = ğ’œ) is as in Eq. (2). Since Pğ‘”ğ‘œğ‘ğ‘™ is a non-linear function
of {ğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘›}, the optimization problem is a non-linear
binary integer programming problem. We use Wattersâ€™ [14]
transformation to convert this non-linear integer program-
ming problem into a linear one. The non-linearity in Pğ‘”ğ‘œğ‘ğ‘™
is owing to the product terms of the form xğ‘–1xğ‘–2xğ‘–3...xğ‘–ğ‘
(this being the iğ‘¡â„ product
term). It can be easily seen
that the value of this product term will be one only when
xğ‘–1=xğ‘–2=xğ‘–3=...=xğ‘–ğ‘=1. In all other cases, it is zero. Hence
we can replace the product term by a new binary integer
variable xğ‘„ (where xğ‘„ âˆˆ {0,1}) such that xğ‘„ is one only
when xğ‘–1=xğ‘–2=xğ‘–3=...=xğ‘–ğ‘=1 else zero. This is taken into
account by adding two additional constraints.
ğ‘âˆ‘
ğ‘¥ğ‘–ğ‘š âˆ’ ğ‘¥ğ‘„ â‰¤ ğ‘ âˆ’ 1
ğ‘š=1
âˆ’ ğ‘âˆ‘
ğ‘š=1
ğ‘¥ğ‘–ğ‘š + ğ‘ğ‘¥ğ‘„ â‰¤ 0
(14)
In this way every term in Pğ‘”ğ‘œğ‘ğ‘™ that is a product of binary
integer variables is replaced by a new binary integer variable
with addition of new constraints (as shown in Eq. (14)). Thus
we now have a linear binary integer programming problem
which is solvable by the branch and bound Algorithm 3 with
the additional constraints being added to the fathoming tests.
C. Multiple Objective Functions
This is an approach most likely to be taken by a se-
curity decision maker. Utility theory can be used to in-
corporate multiple objective functions in a single objective
function as in the objective function ğ¹4 (Eq. (15)), where
S={CM1,CM2,...,CMğ‘š} (constraint being full cover of ğ’œ).
In F4, we simultaneously minimize Pğ‘”ğ‘œğ‘ğ‘™ and the security
investment cost with weights attached to each objective
function (the sum of the weights being one) and the objective
is to select ğ‘¥ğ‘— âˆˆ {0, 1}âˆ€ğ‘— so as to minimize
ğ¹4 = ğ›¼ Ã— ğ‘ƒğ‘”ğ‘œğ‘ğ‘™ + (1 âˆ’ ğ›¼) Ã— ğ‘›âˆ‘
ğ‘¥ğ‘— Ã— ğ‘ğ¶ğ‘€ğ‘—
(15)
ğ‘—=1
Î±=0.33 to 0.46 