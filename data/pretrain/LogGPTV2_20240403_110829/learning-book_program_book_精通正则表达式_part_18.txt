的新闻阅读器rn（其中的正则表达式代码来自JamesGosling的Emacs（注6)）。Perl的正
则流派，用当时的标准衡量是很强大的，但功能不如今天那样齐全。它主要的问题在于，
最多只能支持9组括号，9个多选结构，最精糕的是，括号内不容许出现1，也不能进行
不区分大小写的匹配，不支持字符组中的\w（完全不支持\d和\s）。也不支持区间量词（min
max)。
Perl2发布于1988年6月。Larry完全放弃了原有的正则表达式代码，而采用了前面提到过
的HenrySpencer的正则表达式包的增强版。括号的数目仍然只有9个，但是括号中可以使
用了。\d和\s的支持也加了进来，\w现在可以匹配下画线了，从这时开始，\w能够匹
配Perl的变量名中容许出现的字符。此外，字符组之内也可以出现元字符（表示否定的元
字符、\D、\W和\S，也可以支持，但不能使用在字符组内部，而且总在有些情况下无法正
常工作)。很重要的一点是，添加了/i量词，能够进行不区分大小写的匹配。
Perl3发布于一年多以后的1989年10月。它添加了/e量词，这样极大地增强了替换运算
虽然很不幸，这些量词不能保证在任何情况下都可以正常工作。还有，这时候Per的正则
引引擎本不应该停留在只处理8位编码数据的水平，但是面对非ASCII输入时，会产生无法
预料的结果。
Perl4的发布是在一年半以后，1991年3月，在接下来的两年间，Perl4一直在改进，直到
1993年2月发布最终升级。到此时，之前的bug已经修正，原有的限制也被突破（\D之类
可以应用在字符组中，而括号的数目也不再有限制），正则引擎也花了很多功夫来优化，不
过真正的突破是在1994年。
Perl5正式发布于1994年10月。这-一版的Perl经历了全面的修整，在各个方面都比原来强
上许多。就正则表达式来说，它进行了更多的内部优化，添加了少量元字符（\G增强了选
注6：JamesGosling后来去开发他自己的语言Java，Java1.4提供了一个标准的正则表达式包。
第8章详细介绍了Java。
---
## Page 116
90
第3章：正则表达式的特性和流派概览
代匹配的能力130）、非捕获的括号（45）、忽略优先（lazy）的量词（141）、顺序环
视功能（60)，以及/x量词（72）（注7）。
这些薪增功能的意义并不限子功能本身，更重要的是，这些“薪增”的修改使正则表达式
本身成为一种强大的编程语言，并为它提供了进一步的发展空间。
新增的非捕获型括号和顺序环视结构都需要新的表达方式。而（.）、（、<>和（…都已
经有了含义，所以Larry采用了我们今天使用的‘（？’表示法。这个表示法并不好看，不过
在之前的Perl正则表达式中这是不合规则的组合，所以添加起来完全没有障碍。Larry也预
见到，将来可能还需要新增其他的功能，所以他对（？’之后的字符做了限制，这样就能
保留某些字符，用于将来更多的功能。
之后的各版Perl越来越健壮，错误越来越少，内部优化越来越棒，添加了越来越多的新特
性。我相信，本书的第一版也为此做了小小的贡献，因为部人研究和测试了正则表达式相
关的特性，并将结果告知Larry和PerlPorters group，为改进提供了反馈。
后来添加的新特性包括逆序环视功能（60)，“固化”分组（“atomic”grouping°139），
和Unicode支持。新添加的条件判断结构更是把正则表达式提升到了一个新的层次（140），
它容许用户在正则表达式中进行if-then-else的条件判断和控制。如果这些还不够强大的话，
新的结构甚至容许程序员在正则表达式中运行Perl代码，正则表达式和程序代码之间的界
限已经不复存在了（327）。本书中使用的Perl的版本为5.8.8。
流派的部分整合
具有先见之明的Perl5完全契合了互联网革命的节拍。Perl的初衷是文本处理，而Web页
的生成其实正是文本处理，所以Perl迅速成为了开发Web程序的语言。Perl广受欢迎，其
中强大的正则流派也是如此。
其他语言的开发人员当然不会视而不见，最终在某种程度上“兼容Perl”（Perlcompatible）
的正则表达式包出现了。Tcl、Python、.NET、Ruby、PHP、C/C++都有各自的正则表达式
包，Java语言中还有多个正则表达式包。
注7：我写过一篇文章来谈长而复杂的正则表达式，为了保持清断，我对正则表达式进行了“美
观的排版”。Larry见到之后觉得在Perl代码中这样做会很方使，于是就添加了/x。这样说
来，其中还有本人的功劳。
---
## Page 117
在正则的世界中漫步
16
开发了PCRE，这是一套兼容PerI正则表达式的库，PCRE的正则引I擎质量很高，全面仿制
Perl的正则表达式的语法和语义。其他的开发人员可以把PCRE整合到自已的工具和语言
中，为用户提供丰富而且极具表现力（也是众所周知）的各种正则功能。许多流行的软件
都使用了PCRE，例如PHP、Apache2、Exim、Postfix和Nmap（注8）。
本书对应的版本
表3-2列出了本书中使用的工具和库的版本信息。更老的版本可能功能更少，bug更多，新
的版本则会提供更多的特性，并修正之前的bug（当然也可能多出新的bug）。
表3-2：本书中提到的一些工具的版本
GNU awk 3.1
java.uti1.regex (JDK 1.5， 也叫 5.0)
Procmail 3.22
GNU egrep/grep 2.5.1
.NETFramework2.0
Python 2.3.5
GNU Emacs 21.3.1
PCRE 6.6
Ruby 1.8.4
flex 2.5.31
Perl 5.8.8
GNU sed 4.0.7
MySQL 5.1
PHP (preg routine)5.1.4/4.4.3
Tcl 8.4
最初印象
Ata Glance
我们用一张表格来比较常见工具软件在几方面的功能，以便理解仍然存在的差异。表3-3
提供了若干工具软件的正则表达式所属流派在各方面的简要信息。
其他书籍通常在比较各款工具软件时，也会包含表3-3之类的表格。但是，这张表只是冰山
一角一—列出的每一种特性的背后，都有许多重要的知识。
最重要的是程序会不断变化。举例来说，Tcl以前是不支持反向引用和单词分界符的，但是
现在支持。最开始，用来表示单词分界符的是难看的（：：]，至今仍是这样，尽管
这种表示法已经废弃，取代它的是后来添加的\m、\M和\y（单词起始、单词结束，或者两
者皆是)。
同样，grep和egrep并没有单一的作者，只要愿意，任何人都可以开发，也能修改到符合到
作者期望的任何流派。人人都希望按照自己的意愿来，人性就是如此（例如，许多常用工
注8：PCRE在下面的地址有免费提供ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/。
---
## Page 118
92
第3章：正则表达式的特性和流派概览
表3-3：若干常用工具的Flavor的（非常）简要考察
特性
Modern
Modem
GNU Emacs
Tel
Perl
NET
Sun'sJava
grep
egrep
package
*、~、S、[]
？+1
+
1+
? +\1
？ +1
？+
？+1
？+
分组
\ (\)
()
\(\)
(.)
(.)
(..)
 ()
(.)
单词分界符
1
\b、\B
\n、\M、y
\b、\B
\b、
\B
\b、\B
\w、\W
√
反向引用
√
√
√
√
V表示支持
具的GNU版本，比其他版本更强大，也更健壮）。
或许与列出的特性一样重要的是流派之间的许多细微（有些并非细微）差别。从表格来看，
Perl、.NET和Java的正则表达式似乎是一样的，而实际情况却远不是这样。针对表3-3，
读者可能提出的问题包括：
星号之类的量词能否作用于括号之内的子表达式？
点号能否匹配换行符？排除型字符组能否匹配换行符？以上两者能否匹配NUL字
符？
行锚点（lineanchor）是名符其实的吗（例如，他们能否识别目标字符串内部的换行符）？
它们算正则表达式中的基础级别（first-class）的元字符吗？还是只能应用在某些结构
中？
字符组内部能出现转义字符吗？字符组内部还容许或不容许出现哪些字符？
括号能够嵌套吗？如果是，嵌套的深度是否有限制呢（还有个问题是，一共容许出现
多少括号呢）？
如果容许反向引用，在进行不区分大小写的匹配时，反向引用能顺利进行吗？在极端
的情况下，反向引用的“行为”有意义吗？
是否可以出现八进制的转义字符\123？如果是，怎么区分它和反向引用呢？十六进制
的转义字符呢？这种支持是正则引擎提供的，还是由其他工具提供的？
---
## Page 119
正则表达式的注意事项和处理方式
93
）
是否与它们保持一致？它们是按照locale的定义呢，还是支持Unicode？
即使表3-3这样的介绍这样简单，我们仍然必须记得这些问题。如果你能意识到，在看起来
光鲜的外表下面潜藏着许多问题，就容易保持清醒的头脑来应付它们。
在本章开头我们已经提到，许多问题只是语法的差异，但也有许多并非如此。比方说，了
解到egrep的（Ju1IJuly）在GNUEmacs中必须写成（Ju1\IJuly\）之后，你或许会认
为所有的问题都是这样，但事实并非如此。在匹配尝试过程中的语义差异（或者，至少是
看起来是在匹配尝试过程中的）通常被忽视，但极其重要的问题是，它也解释了为什么两
个看起来一样的表达式会获得截然不同的结果：一个总是匹配“Ju1”，即使目标文本是
July。这些着起来毫无区别的语义也解释了，为什么两个顺序相反的正则表达式：
(July|Jul）和（July\IJu1\）能够取得同样的匹配结果。其实，整个下一章都在讲解
这类问题。
当然，一款工具软件能够利用正则表达式实现的功能，通常比它所属的正则流派更重要。
例如，就算Perl的正则表达式功能不及egrep，在使用正则表达式时，Perl所具有的简便性
却更有价值。我们会在本章逐个介绍各种特性，并在后面各章深人讲解几种编程语言。
正则表达式的注意事项和处理方式
Care andHandlingofRegularExpressions
本章并头列出的第二点需要注意的就是：正则表达式的句法规则（syntacticpackaging），它
告诉应用程序：“嘿，这儿有一个正则表达式，我需要你做这些”。egrep是一个简单的例子，
因为正则表达式是作为命令行参数传过去的。其他的“语法诀窍（syntacticsugar）”，例如
我在第1章坚持使用的单引号，是因为考虑到shell，而不是egrep。复杂的系统，例如程序
设计语言中的正则表达式，需要更多的包装，系统才能知道哪些部分是正则表达式，需要
如何处理。
下一步是考察我们能够对匹配结果进行的操作。同样，egrep在这方面很简单，因为它做的
都是同样的事情（显示包含匹配文本的行），但是，我们在前一章的开头已经说过，真正有
---
## Page 120
94
第3章：正则表达式的特性和流派概览
意义的是更复杂的操作。其中最基本的是匹配（检查一个正则表达式是否能匹配一个宇符
串，或者从字符串中提取信息），以及查找和替换，根据匹配的结果修改字符串。这些操作
可以以多种形式进行，不同的语言对此也有不同的规定。
一般来说，程序设计语言有3种处理正则表达式的方式：集成式（integrated）、程序式
(procedural）和面向对象式（object-oriented)。在第一种方式中，正则表达式是直接内建在
语言之中的，Perl就是如此。但是在其他两种方式中，正则表达式不属于语言的低级语法。
相反，普通的函数接收普通的字符事，把它们作为正则表达式进行处理。由不同的函数进
行不同的、关系到一个或多个正则表达式的操作。大多数语言（不包括Perl）采用的都是这
两种方式之一，包括Java、.NET、Tcl、Python、PHP、Emacs、lisp和Ruby。
集成式处理
IntegratedHandlling
我们已经看过Perl的集成式处理方法，例如第55页的例子：
if ($1ine =~m/~Subject:（.*)/i）{
$subject=$1;
）
为清楚起见，我用斜体标注变量名，正则表达式相关的部分则用粗体标注，正则表达式本
身用下画线标注。Perl会把正则表达式^Subject：·（.*）应用到sline保存的文本中，如
果能够匹配，则执行下面的程序段。其中，变量S1代表括号内的子表达式匹配的文本，将
它们赋值给Ssubject。
另一个集成式处理的例子是把正则表达式作为配置文件的一部分，例如procmail（Unix下
的一个邮件处理程序）。在配置文件中，正则表达式用于将邮件信息发布到对应的处理程序
中。这个例子比Perl更简单，因为不需要指明操作对象（邮件信息)。
这两个例子背后的原理要复杂一些。集成式处理方法减轻了程序员的负担，因为它隐藏了
一些工作，例如正则表达式的预处理，准备匹配，应用正则表达式，返回结果。省略这些
操作减轻了常见任务的完成难度，不过我们之后将会看到，有些情况下，这样处理反而更
慢，更复杂。
不过，在深人细节之前，我们先打量打量其他的处理方式，然后再来揭示这些被隐藏的步
---
## Page 121
正则表达式的注意事项和处理方式
95
程序式处理和面向对象式处理
Procedural amnd Object-Oriented Handling
程序式处理和面向对象式处理非常相似。这两种方式下，正则功能不是由内建的操作符来
提供，而是由普通函数（函数式）或构造函数及方法（面向对象式）来提供的。这种情况
下，并没有专属于正则表达式的操作符，只有平常的字符事，普通的函数、构造函数和方
法把这些字符串作为正则表达式来处理。
下面儿节给出了儿个Java、VB.NET、PHP和Python的例子。
Java中的正则处理
现在来看“Subject”例子在Java中的实现方式，使用Sun提供的java.util.regex包（第
8章详细介绍Java)。
importJava.util.regex.*；//这样使用regex包中的类更加容易