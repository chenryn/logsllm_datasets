最高版本的符号，然后把SUNW_1.3记录到app_foo的可执行文件内，
在程序运行时，动态链接器会通过程序内记录的它所依赖的所有共享库的符号集合版本
信息，然后判定当前系统共享库中的符号集合版本是否满足这些被依赖的符号集合，通过这
样的机制，就可以保证那些在高次版本共享库的系统中编译的程序在低次版本共享库中运
行。如果该低次版本的共享库满足符号集合的要求，比如 app_foo在libfoo.so.1次版本号大
于等于3的系统中运行，就没有任何问题：如果低次版本共享库不满足要求，如app_foo在
libfo0.so.1次版本号小于3的系统中运行，动态链接器就会意识到当前系统的共享库次版本
号不满足要求，从面阻止程序运行，以防止造成进一步的损失。
这种符号版本的方法是对SO-NAME机制保证共享库主版本号一致的一种非常好的
补充
程序员的自我修养一链接、装载与库
---
## Page 262
8.2符号版本
239
8.2.3Linux中的符号版本
Linux系统下共享库的符号版本机制并没有被广泛应用，主要使用共享库符号版本机制
的是Gibc软件包中所提供的20多个共享库。这些共享库比较有效地利用了符号版本机制
来表示符号的版本演化及利用范围机制来屏蔽一些不希望暴露给共享库使用者的符号。对于
目前2.6.1的Gibc中的C语言运行库libc-2.6.1.so来说，它的符号版本演化如下；
GLIBC_2.0、GLIBC_2.1、GLIBC_2.1.1、GLIBC_2.1.2、GLIBC_2.1.3、GLIBC_2.2、
GLIBC_2.2.1、GLIBC_2.2.2、GLIBC_2.2.3、GLIBC_2.2.4、GLIBC_2.2.6、GLIBC_2.3、
GLIBC_2.3.2、GLIBC_2.3.3、GLIBC_2.3.4、GLIBC_2.4、GLIBC_2.5、GLIBC_2.6
对于有些像Glibc 中的加密解密库 libcrypt，它目前的共享库版本是libcrypt-2.6.1.so，但
是它内部的符号版本只有GLIBC_2.0.因为它的接口十分稳定，从2.0版本之后就没有改动
样的符号版本，这样的符号版本标记分别用于GCC编译器和GLIBC内部，它提醒共享库的
使用者：最好不要使用这些符号，因为它并不是对外公开的，有可能随着共享库的版本演化
而被删除或改变，总之一句话，后果自负。
GCC对Solaris符号版本机制的扩展
GCC在Solaris系统中的符号版本机制的基础上还提供了两个扩展。第一个扩展是，除
编宏指令来指定符号的版本，这个汇编宏指令可以被用在GAS汇编中，也可以在GCC的
C/C++源代码中以嵌入汇编指令的模式使用。它的用法如下：
a8m(*,8yever add, add9veRs_1.1*):
int add(int a, int b)
return α + b;
版本的同一个符号存在于一个共享库中，也就是说，在链接层面提供了某种形式的符号重载
机制，比如：
asm(* ,symver new_printf, printfeveRS_1.2*) 
asm(* .symver o1d_printf, printfevERs_1.1*1 ;
int old_printf()
程序员的自我修养—链接、装载与库
---
## Page 263
240
第8章Linux共享库的组织
(1guadma 
为什么要提供这种符号多版本重载机制呢？有时候当我们对共享库进行升级的时候，可
能仅仅更改了一个符号的接口或含义，那么，如果仅仅为了这个符号的更改面升级主版本号，
那么将会对系统带来很大的影响。理想的情况是，当共享库发生比较小的变化时，新版的共
享库能够在原来的基础上做些补充，面并不影响旧版的功能，即能完全保持向后兼容性，争
取做到不更改共享库的SO-NAME，即不更改主版本号。
Solaris2.5系统的符号版本方案有一个不足，那就是同一个共享库中，每个函数只能有
一个版本号，也就是说不允许多个版本的同一个函数名存在，只允许该函数的某个版本存在。
比如符号foo要么是VERS_1.0，要么是VERS_1.1，不允许这两个版本同时存在。Linux下
的符号版本机制比Salaris2.5的要先进一些，它允许同一个名称的符号存在多个版本。当某
个符号在新的共享库版本中接口被更改或符号的含义被改变，那么共享库可以保留原来的版
本符号，比如前面例子中导出的 printf 1.1版实际上即为 old_printf：面将新版的 new_printf
导出成printf版本1.2.这样，链接器可以挑选符合某个程序版本号的符号来进行链接，使
用 1.1版 printf 的程序会被链接到 old_printf，而使用 1.2 版的程序会被链接到 new_printf,
所有的程序都可以正确运行，更改函数的接口和含义并不影响旧版程序的运行。
Linux系统中符号版本机制实践
在Linux下，当我们使用Id链接一个共享库时，可以使用“--version-scripx”参数；如
gcc -shared -fPIC 1ib.c -X1inker --version-script 1ib.ver -o lib.so
假设lib.c里面定义了一个foo的函数，而main.c调用了这个函数，如我们使用下面的
符号版本脚本编译一个ib.so：
VERS_1.2(
g1oba1:
loca1 :
foo;
那么很明显，这个版本的 ib.so里面foo的符号版本是VERS_1.2.然后将main.c编译
井且链接到当前版本的ib.so：
gce main.c ./lib.so -o main
于是main程序里面所引用的foo 也是VERS_1.2的。如果把这个main 程序拿到一台只
程序员的自我修养一链接、装载与库
---
## Page 264
8.4共享库查找过程
241
包含低于VERS_1.2的foo的lib.so系统中运行，那么动态链接器就会报运行错误并且退出
程序，防止了符号版本不符所造成额外的损失：
- /main
- /main: ./1lib.so: version *vERs_1.2* not found (required by ,/main)
8.3共享库系统路径
目前大多数包括Linux在内的开源操作系统都遵守-个叫做FHS（FileHierarchy
Standard）的标准，这个标准规定了一个系统中的系统文件应该如何存放，包括各个目录的
结构、组织和作用，这有利于促进各个开源操作系统之间的兼容性。共享库作为系统中重要
的文件，它们的存放方式也被FHS列入了规定范围，FHS规定，一个系统中主要有两个存
放共享库的位置，它们分别如下：
·lib，这个位置主要存放系统最关键和基础的共享库，比如动态链接器、C语言运行库、
数学库等，这些库主要是那些/bin和/sbin下的程序所需要用到的库，还有系统启动时
需要的库。
·Ausr/lib，这个目录下主要保存的是一些非系统运行时所需要的关键性的共享库，主要是
一些开发时用到的共享库，这些共享库一般不会被用户的程序或shell脚本直接用到。
这个月录下面还包含了开发时可能会用到的静态库、目标文件等。
·/usr/local/lib，这个目录用来放置一些跟操作系统本身并不十分相关的库，主要是一些
第三方的应用程序的库。比如我们在系统中安装了python语言的解释器，那么与它相
关的共享库可能会被放到/usr/local/lib/python，而它的可执行文件可能被放到
/usr/local/bin下。GNU 的标准推荐第三方的程序应该默认将库安装到/usr/local/ib下。
所以总体来看，Aib和l/usr/ib是一些很常用的、成熟的，一般是系统本身所需要的库：
而usr/local/ib是非系统所需的第三方程序的共享库。
8.4共享库查找过程
在开源系统中，包括所有的Linux系统在内的很多都是基于Glibc的。我们知道在这些
系统里面，动态链接的ELF可执行文件在启动时同时会启动动态链接器。在Linux系统中，
动态链接器是/lib/ld-linux.so.X（X是版本号），程序所依赖的共享对象全部由动态链接器负
段里面，由DT_NEED类型的项表示，动态链接器对于模块的查找有一定的规则：如果
DT_NEED里面保存的是绝对路径，那么动态链接器就按照这个路径去查找：如果DT_NEED
程序员的自我修养一链接、装载与库
---
## Page 265
242
第8章Linux共享库的组织
里面保存的是相对路径，那么动态链接器会在/lib、fusr/ib和由/etc/ld.so.conf配置文件指定
的目录中查找共享库，为了程序的可移植性和兼容性，共享库的路径往往是相对的。
d.so.conf是一个文本配置文件，它可能包含其他的配置文件，这些配置文件中存放着
目录信息。在我的机器中，由ld.so.conf指定的日录是：
●/usr/local/ib
●/lib/i486-linux-gnu
●/usrlib/i486-linux-gnu
如果动态链接器在每次查找共享库时都去遍历这些目录，那将会非常耗费时间。所以
Linux 系统中都有一个叫微ldconfig 的程序，这个程序的作用是为共享库目录下的各个共享
库创建、删除或更新相应的SO-NAME（即相应的符号链接），这样每个共享库的SO-NAME
就能够指向正确的共享库文件：并H这个程序还会将这些SO-NAME收集起来，集中存故到
fetc/ld.so.cache文件里面，并建立一个 SO-NAME的缓存。当动态链接器要查找共享库时，
它可以直接从etc/ld.so.cache里面查找。而/etc/ld.so.cache的结构是经过特殊设计的，非常适
合查找，所以这个设计大大加快了共享库的查找过程。
如果动态链接器在/etc/ld.so.cache里面没有找到所需要的共享库，那么它还会遍历/ib
和/usr/ib这两个目录，如果还是没找到，就宜告失败。
所以理论上讲，如果我们在系统指定的共享库目录下添加、剩除或更新任何一个共享库，
或者我们更改了/etc/ld.so.conf的配置，都应该运行 ldconfig这个程序，以便调整 SO-NAME
和/etc/d.so.cache。很多软件包的安装程序在往系统里面i安装共享库以后都会调用ldconfig-
不同的系统中，上面的各个文件的名字或路径可能有所不同，比如FreeBSD的
SO-NAME缓存文件是/var/run/ld-elf.so.hints，我们可以通过查看Idconfig 的 man
手册来得知这些信息。
8.5环境变量
LD_LIBRARY_PATH
Linux系统提供了很多方法来改变动态链接器装载共享库路径的方法，通过使用这些方
法，我们可以满足一些特殊的需求，比如共享库的调试和测试、应用程序级别的虚拟等。改
变共享库查找路径最简单的方法是使用LD_LIBRARY_PATH环境变量，这个方法可以临时
改变某个应用程序的共享库查找路径，而不会影响系统中的其他程序。
程序员的自我修养一链接、装载与库
---
## Page 266
8.5环境变量
243
在Linux系统中，LD_LIBRARY_PATH是一个由若干个路径组成的环境变量，每个路
径之间由冒号隔开。默认情况下，LD_LIBRARY_PATH为空。如果我们为某个进程设置了
LD_LIBRARY_PATH，那么进程在启动时，动态链接器在查找共享库时，会首先查找由
LD_LIBRARY_PATH指定的目录。这个环境变量可以很方使地让我们测试新的共享库或使
用非标准的共享库。比如我们希望使用修改过的libc.so.6，可以将这个薪版的libc放到我们
的目录/home/user 中，然后指定LD_LIBRARY_PATH:
$ LD_LIBRARY_PATH=/bome/u8er /bin/18
Linux中还有一种方法可以实现与LD_LIBRARY_PATH类似的功能，那就是直接运行
动态链接器来启动程序，比如：
$/1ib/1d-1inux.8o.2 -1ibrary-path /home/user /bin/1s
就可以达到跟前面一样的效果，有了LD_LIBRARY_PATH之后，再来总结动志链接器查找
共享库的顺序。动态链接器会按照下列顺序依次装载或查找共享对象（目标文件）：
·由环境变量LD_LIBRARY_PATH指定的路径。
·由路径缓存文件/etc/ld.so.cache 指定的路径。
·默认共享库目录，先/usr/ib，然后/lib。
LD_LIBRARY_PATH对于共享库的开发和测试来说十分方便，但是它不应该被滥用。
也就是说，普通用户在正常情况下不应该随意设置LD_LIBRARY_PATH来调整共享库搜索
目录。随意修改LD_LIBRARY_PATH并且将其导出至全局范围，将可能引起其他应用程序
运行出现的问题：LD_LIBRARY_PATH也会影响GCC编译时查找库的路径，它里面包含的
目录相当于链接时GCC的“-L”参数。
有一篇文章“WhyLD_LIBRARY_PATHis bad”专门讨论为什么不要随意使用该环境
变量： http://xaklee.org/UnixResource_dir/_/dpath.lhtml
LD_PRELOAD
系统中另外还有一个环境变最叫做LD_PRELOAD，这个文件中我们可以指定预先装载
的一些共享库甚或是目标文件，在LD_PRELOAD里面指定的文件会在动态链接器按照固定
规则搜索共享库之前装载，它比LD_LIBRARY_PATH里面所指定的目录中的共享库还要优
先。无论程序是否依赖于它们，LD_PRELOAD里面指定的共享库或目标文件都会被装载。
由于全局符号介入这个机制的存在，LD_PRELOAD里面指定的共享库或目标文件中的全
局符号就会覆盖后面加载的同名全局符号，这使得我们可以很方便地微到改写标准C库中的
某个或某儿个函数而不影响其他函数，对于程序的调试或测试非常有用，与LD_LIBRARY_
程序员的自我移养一键接、装载与库
---
## Page 267
244
第8章Linux共享库的组织
PATH一样，正常情况下应该尽量避免使用LD_PRELOAD，比如个发布版本的程序运行
不应该依赖于LD_PRELOAD.
系统配置文件中有一个文件是/etc/ld.so.preload，它的作用与LD_PRELOAD一样。这
个文件里面记录的共享库或目标文件的效果跟LD_PRELOAD里面指定的一样，也会
被提前装载。
LD_DEBUG
另外还有个非常有用的环境变量LD_DEBUG.这个变量可以打开动态链接器的调试
功能，当我们设置这个变量时，动态链接器会在运行时打印出各种有用的信息，对于我们开
发和调试共享库有很大的帮助，比如我们可以将LD_DEBUG设置成“6iles”，并且运行一个
简单动态链接的 HelloWorld：
$LD_Dg8UG=f11es ./He11oWorld.out
12118:
12118 :
12118 :
file=1ibe.so.6 [0]: generating 1ink map
file=1ibc.so.6 [0];
needed by ./Hel1oWor1d.out [0]
:81121
dynanic:0xb7f16d9c
ent:ry: 0xb7de71b0phdr: 0xb7dd1034 phnum1
base:0xb7dd1000
gize:0x00149610
12118 :
12118 :
10
12118 :
12118 :
ca11ing init : /1ib/t18/1686/cmov/1ibc,80, 6
12118 :
12118 :
12118 :
12118:
initialize program: ./He1lowor1d,out
12118 :
12118:
12118 :
transferring control: ./Helloworld,out
He11o wor1d
12118 :
12118 1
calling fini: ./HelloWorld,out [0]
12118 :
12118 :
12118:
12118 :
cal1ing [ini: /1ib/t1s/1686/cmov/1ibc.so.6 [0]
动态链接器打印出了整个装载过程，显示程序依赖于哪个共享库并且按照什么步骤装载
和初始化，共享库装载时的地址等。LD_DEBUG还可以设置成其他值，比如：
·“bindings”显示动态链接的符号绑定过程。
·“libs”显示共享库的查找过程。
·“versions”显示符号的版本依赖关系。
·“reloc”显示重定位过程。
程序员的自我修养一链接、装载与库
---
## Page 268
8.6共享库的创建和安装
245
·“symbols”显示符号表查找过程。