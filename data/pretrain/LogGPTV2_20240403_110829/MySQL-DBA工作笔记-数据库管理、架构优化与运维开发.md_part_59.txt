begin
 create procedure proc_auto_insertdata()
Query
这个过程可能会抛出 table is full 相关的信息，我们可以适当调整参数 tmpdir（修改
然后使用如下的存储过程来导入数据，
engine=memory default charset=UTF8;
user_name
1s
我们尝试使用内存表来优化，
房
所以这个过程虽然是一步到位，但是性能还是差强人意，
insert into users_memory values(init_data,concat('user'
while init_dataload data infile'/u01/testdata/a.lst'
Query OK,
Query OK,
>load
#time sh a.sh
脚本写得很简单，生成数据的过程大概耗时8秒钟，文件有18M 左右。
done > a.lst
shell脚本内容如下：.
方案5：存储过程显式事务提交
整个过程耗时18秒左右，和方案3很相似，但看起来略微复杂或者啰嗦了一些。
然后把内存表的数据导入目标表users。
Records:
首先使用脚本生成数据，还是和方案3一样，估算为9秒钟，导入数据到内存表
方案4结合了以上几种方案的一些特点，当然还不能说它就是最好的。
方案4：使用内存表和外部文件导入混合
所以从方案1的8分钟到方案2的5分钟再到现在的近 20秒，已经是巨大的进步了。
Records:
然后使用 load data 来导入数据，整个过程花费8秒钟左右，所以整个过程的时间在
sys
user
echo
方案 3只是抛砖引玉，你对哪种语言脚本熟悉，就可以用哪种语言来写，只要实现
方案3：使用程序/脚本生成数据，
整个过程下来不到5分钟，和方案1的8分钟相比快了很多。
>insert into users select *from users_memory;
这个过程用时近5分钟，接下来内存表数据导入InnoDB 表很快了，几秒钟即可搞定。
OK
$i,user_$i
0m2.039s
data
0m6.
1000000
1000000
1000000 rows affected (8.05 sec)
1000000
.312s
infile
Deleted:0
Deleted:0
COwS
'/u01/testdata/a.lst'
 Skipped:
Skipped:
批量导入
Warnings:0
 users_memory;
D
Warnings:0
into table users_memory fields
Warnings:
 into table users fields
0
---
## Page 388
366丨MySQLDBA工作笔记：数据库管理、架构优化与运维开发
但是相对来说性能会提升不少，初步的测试结果显示，整个过程耗时在2分钟左右。
照这应该是目前最差的方案了。
整体的进度明显会比方案3要长得多。初步的测试3分钟导入了30万左右数据，所以按
过管道的方式来导入，听起来蛮有新意，我们试一下这种方案的效果。
会大大降低，对此我做了补充测试。
#time mysql test commit;
Query OK,
在这个基础上，我们用100万条数据使用存储过程方式，开启事务做了测试。
Query
我们还是拿10万条数据做了对比测试。
如果不想写代码和脚本，可以通过 sysbench 指定参数来批量生成数据。
方案8：sysbench 工具生成
sys
user
real
单纯生成 insert 语句，耗时在 30 秒左右。按照这个进度，每条语句都会隐式提交,
我们先不使用管道，生成数据（insert 语句），然后导入测试下效果。
donelmysql test
"'("ts "rasn,'" Ts u)sante shasn ozut arasut" ouoa
大体的脚本内容如下：
方案6：批量生成insert 语句使用管道导入
整个耗时在50秒以内，相比原有方案的8分钟，提升的效率是很明显的。
commit;
begin
开启事务之后，代码不做任何改变，
未开启事务的结果，耗时在近50秒左右，如下：
begin;
OK，
0m18.676s
0m13.928s
1m48.088s
0 rows affected (0.27 sec)
0 rows affected (o.o0 sec)
1 row affected (4.42 sec)
，耗时在5秒左右，提升了近10倍，如下。
---
## Page 389
目标是让DBA 做更少的事情完成更高的交付质量。
dual
处理此类方案的 SQL，以作为方案9，供大家参考借鉴。
的设置，除非你自己再定义一个lua 模板，否则额外的属性都是不可定制的。
我对测试的情况也进行了一些推荐补充，也希望在这个方向上大家也能够集思广益，
这是一种极简方案，不同环境的对比测试基本在2秒以内。
Tablecreated.
前面林林总总测试了8种方案，结果如下表 9-1所示。除此之外，我们看下Oracle
方案9：Oracle的极简方案
很明显这不是一种灵活可扩展的方案，在功能测试中是不推荐大家使用的。
这种方案目前不具有完全对等的可比性，主要是 sysbench 的方案对于表结构是统一
connec
使用sysbench
批量生成insert语句显式事务提交
批量生成insert语句使用管道导入
存储过程开启事务
使用 shell脚本生成数据，load data的方式导入内存表，然后导入目标表
使用shell脚本生成数据，使用loaddata的方式导入数据
存储过程批量导入内存表，内存表导入目标表
存储过程批量导入
测试方案
表9-1
未知
2分钟左右
10分钟+
50秒
少于18秒
少于20秒
5分钟
8分钟
时长
第9章MySQL性能测试丨367
推荐指数
不推荐
***
**
***
*
---
## Page 390
数据库会有哪些瓶颈，比如：
中间件能够做什么？要回答这个问题，我们可以反向问一个问题，随着业务需求的变化
场景。
的使用场景，还是能够经受住考验的，注意我在此处说的的使用场景，没有一刀切的
让MySQL 的应用变得非常丰富起来，你说MySQL 能不能做企业级方案，你看看 BAT
MySQL的简单反而成了它的一个优势；在这个基础上，它有非常多的开源方案，这些
估单机的性能和功能，MySQL要落后很多，但是从成本、技术把控、定制层面来看，
记得之前和同事聊，说如果对比一下Oracle和MySQL，让我怎么评价，我说单纯评
分库分表，然后就是分布式。而同时从很多层面来说，行业内的方案真是百花齐放，
这些都是摆在我们面前的问题，这个“我们”也不仅仅是DBA团队。
简单的扩容和添加资源了，我们有时候更需要弹性，需要快速实现，需要更高的性能。
需求的提升必然会在数据量、访问量等方面有更高的要求，而映射到数据库层面就不是
何迁移到MySQL的历程有一些经验可以借鉴。
进行阐述，最后我们会对迁移到 MySQL 的方案进行一个完整案例的回放，让大家对于如
对分库分表和读写分离有一个整体的认识，并对行业里的基于不同业务场景的架构方案
践。本章我们会从MySQL中间件开始，对行业里的中间件方案进行分析和梳理，让我们
求的基础上，更灵活地支撑更多需求，对于DBA 来说，在架构设计上就需要理论联系实
没有最好的方案，只有最合适的方案。
回到正题，MySQL 的中间件其实有很多，包括官方的和开源的。先来说说 MySQL
10.1
所以早期的很多数据库，从一主一从，一主多从的架构，逐步演变到了读写分离
面对互联网业务的快速发展，业务需求也会层出不穷，我们怎么能够在支撑现有需
（1）单台服务器无法承载已有的压力。
数据库技术发展的基础还是在业务推动的背景下，能够实现相关的技术保障。业务
对于 DBA 来说，基于业务的数据库架构设计属于我们进阶的必备之路；简而言之：
在你往上爬的时候，一定要保持梯子的整洁，否则你下来时可能会滑倒。-
MySQL中间件方案
第10章基于业务的数据库架构设计
—蓝斯登原则
---
## Page 391
再之前还有Cobar，已经不维护了。
是一种水平拆分、可平滑扩缩容、读写分离的在线分布式数据库服务。前身为淘宝 TDDL，
库，也是一波好友一起来做得这个事情。
官方链接是：http://www.mycat.io/。
对其进行了优化，增加了一些新的功能特性。
从 github 的情况来看，星级蛮高，维护也很及时。它的设计是在 mysql-proxy 0.8.2 版本的基础上,
主要就是测试版本，所以在很多功能上多多少少还是有些问题的。
“三驾马车”来使用的。而落寞的是MySQL proxy，目前已经无法下载了，自从推出以来
需要做任何的修改，在 MySQL 官方近期推出的 InnoDB Cluster 中 MySQL Router 是作为
需要应用端来适配改造，而MySQL Router 中间件的访问协议与 MySQL一致，应用端不
件，用来实现高可用和扩展性。MySQL Fabric 在驱动层面可以实现高可用和扩展功能，
10.1.1MySQL中间件方案盘点
不仅仅是MySQL中间件能够做什么，还有更多。
YouTube 开发的数据库中间件，集群基于 ZooKeeper 管理，通过 RPC 方式进行数
5.Vitess
阿里分布式关系型数据库服务（Distribute Relational Database Service，简称DRDS）
我比较喜欢它的一个原因是开源，而且源代码是Java。
根据我的了解，Mycat 主要是支持 MySQL，也支持 Oracle、SQLServer 等其他数据
4.DRDS
Mycat也是国内的一个中间件方案，业内比较火，基于阿里开源的Cobar产品而研发，
3.Mycat
这是国内 360公司推出的一个中间件方案，github 地址为：https://github.com/Qiho0360/Atlas;
2.360 Atlas
Fabric 能提供 MySQL 的 HA和 Sharding 方案，MySQL Router 是一个轻量级的中间
1. MySQL Fabric、MySQL Router 和 MySQL Proxy
我们基本上会讨论下面的几个中间件，还有一些会额外补充说明。
市面上的很多数据库中间件主要是分担了以上瓶颈问题的大部分或者一部分的功能点。
带着这些瓶颈问题我们接下来开始中间件方案之旅，旅程结束时，相信你能明白的，
（5）资源的负载没法拆分，或者不易拆分。
（4）资源如果扩容，应用改动较大。
（3）大量的读写需求无法平衡。
（2）数据库单表容量越来越大。
第10章基于业务的数据库架构设计”369
---
## Page 392
370|MySQLDBA工作笔记：数据库管理、架构优化与运维开发
案的思路来说，就是基于表的粒度来拆分的，比如把一张表拆分为 40份，在分布式架构
提升，比如从 2000万增长到 3000万，但是相对来说增长幅度不大，从改造为分布式方
数据量是相对稳定的，数据操作是覆盖型写入的，这类表随着业务的增长会有用户量的
于表的设计是偏重于业务层面的，需要根据业务场景进行拆分设计。”
于表，其中基于数据库的拆分是偏系统层面的，需要明确系统的边界和支撑能力，而对
分。对此我整理了如下图10-1所示的简单图表。
10.1.2
错。github 链接为：https://ithub.com/mariadb-corporation/MaxScale。
据处理；官方网站很简洁：htp://vitess.io/。
“基于数据库层级的拆分，假设目前环境中存在的表有两类，一类是固定表，即表的
其实对分片的规则设置，基本就是两种思路来拆分，
对一套集群环境进行了分布式改造，通过分片规则对原来的大表进行了多粒度的拆
MaxScale 是 Mariadb 研发的，目前版本不支持分库分表，但在其他几个方面都很不
6.Maxscale
分片设计思路
tab_part10
tab_partg
tab_par1
tab_part2
db3
db4
db2
db1
ding
tab _part20
tab_part19
tab_part12
tab_part11
db8
db7
db6
db5
图10-1
tab_part29
tab_part30
tab_part22
tab_part21
db11
db12
db10
db9
narding
一种是基于数据库，一种是基
tab_part39
tab_part40
tab_part32
tab_part31
b16
db14
db13
---
## Page 393