covery from an error but has a high storage cost. Proposals
such as Multiversion memory [16] and ReVive [11] provide
cost-effective implementations of the BER mechanism.
6.3. Recovery with Undo Mechanism
The system can recover from an error if it can be re-
stored to a state where the effects of all the instructions
prior to the error-causing instruction are architecturally vis-
ible and no effects of the error-causing instruction, or any
subsequent instruction, are architecturally visible. The MBI
mechanism allows a unique error recovery technique that
can restore the system to the state of the last error-free in-
struction. Error recovery is performed by undoing the store
operations that were performed during performance mode
after the last error-free instruction. Figure 7(a) shows the
extensions added to the backlog buffer to facilitate error re-
covery.
A
B
C
D
E
F
G
H
I
J
K
L
M
ADDR: VAL
ADDR: VAL
ADDR: VAL
ADDR: VAL
(a)
HEAD−PTR
Instructions D, G, I and L
are store instructions
ADDR: VAL
Represents undo information
for store operations. ADDR is
the address and VAL is the old
value at that address.
TAIL−PTR
A
B
C
D
E
F
G
H
I
J
K
L
M
ERROR
UNDONE
HEAD−PTR
TAIL−PTR
UNDONE
UNDONE
UNDONE
(b)
Figure 7. (a) Extending the backlog buffer to keep track of undo
information for store instructions. (b) An example of error cor-
rection with the undo mechanism.
6.3.1. Structure. The backlog buffer tracks undo infor-
mation for each store instruction. The undo information
consists of the effective address of the store instruction and
the old value at that address. In Figure 7(a), instructions
labeled D, G, I, and L are store instructions and the shaded
regions represent the undo information associated with each
store instruction. The backlog buffer does not contain any
undo information for non-store instructions.
6.3.2. Operation. Error recovery consist of two parts: (1)
recovering the register state, and (2) recovering the mem-
ory state. Recovering the register state is relatively easy
because the register state in introspection mode is updated
only after the instruction is found to be fault-free. Thus,
during introspection mode, the ISPEC ARF register ﬁle al-
ways corresponds to the last instruction that was found to
be correct. When an error is detected, the register state of
ISPEC ARF is copied to PERF ARF.
Recovery of the memory state is more challenging be-
cause, at the time the error is detected, the store instructions
younger than the error-causing instruction have already up-
dated the memory. Therefore, memory updates caused by
these store instructions must be undone. We explain the
undo operation with an example. Figure 7(b) shows the
state of the backlog buffer for the instruction sequence A
to M. Instructions D, G, I, and L are store instructions and
the backlog buffer entries corresponding to the stores con-
tain undo information. While checking the result of instruc-
tion C in introspection mode, an error is detected. To re-
cover the memory state, all stores younger than instruction
C in the backlog buffer (stores D, G, I, and L) must be un-
done. To accomplish this, the backlog buffer is traversed
backwards starting with the TAIL-PTR. Any store instruc-
tion that is encountered during this backward traversal is
undone. The undo operation simply copies the old value
stored in the backlog buffer entry to the memory address
indicated in the backlog buffer entry. Backward traversal
of the backlog buffer continues until the the error-causing
instruction is reached. At that point, no effect of the error-
causing instruction, or any subsequent instruction, is archi-
tecturally visible. Thus the system has recovered from the
error detected at instruction C.
It should be noted that the undo mechanism assumes that
the store values are not read by other devices (such as other
processors if a multiprocessor system is used) before the
undo process takes place. For multiprocessor systems, the
undo mechanism can be used if other processors are not al-
lowed to read the values produced by a store instruction un-
til that instruction is found to be fault-free in introspection
mode. An alternative is to transfer the control to software
so that the processors that have consumed incorrect values
can be recovered to a consistent state. Design requirements
of the undo mechanism in multiprocessor systems is outside
the scope of this paper and is part of our future work.
6.3.3. Error Correction Latency. The duration between
when the error is detected and when the system is restored
to an error-free state is called the error correction latency.
The error correction latency of the undo mechanism is vari-
able and depends on the number of instructions between the
HEAD-PTR and TAIL-PTR. In the worst-case where every
entry in the backlog buffer is a store instruction, the TAIL-
PTR traverses through, and performs undo operation for,
every entry in the backlog buffer. Thus, the worst-case error
correction latency with a backlog buffer containing 2K en-
tries is as high as 2K undo operations. However, this latency
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:10:11 UTC from IEEE Xplore.  Restrictions apply. 
is very low compared to the time between errors and will not
signiﬁcantly affect the availability of the system. For exam-
ple, even with an error rate of 1 error/hour, a 5GHz proces-
sor that can perform 1 undo operation per cycle will have an
availability of 99.99999% (Availability = (TE −TR)/TE,
where TE is the mean time between errors, and TR is the
time the machine is not available due to an error).
7. Related Work
Commercial high reliability systems, such as the Tandem
Computer [2], the Compaq NonStop Himalaya [22], and the
IBM S/390 [17] use lock-step execution for detecting faults
in processors. Fault tolerance in these systems is achieved
at the expense of hardware replication.
An alternative to replication was proposed by Austin in
the form of DIVA [1]. For redundant execution, DIVA uses
a simple checker processor after the retirement stage of the
main processor. The assumption that the instruction fetch
stage and the instruction decode stage of the main proces-
sor are fault-free allows the checker processor to use the
instruction dependency information computed in the main
processor. Unlike DIVA, MBI provides fault coverage for
the entire pipeline, including the fetch and decode stages.
DIVA uses a physically separate processor for redundant
execution and can therefore detect both permanent and tran-
sient faults, whereas MBI provides coverage only for tran-
sient faults and would need to be combined with techniques
like RESO [10] to provide coverage for permanent faults.
The additional processor in DIVA, although simple, re-
quires considerable hardware overhead compared to MBI.
A low hardware overhead is desirable because it provides
the users with a choice to use or not to use the features of
fault tolerance. With MBI, if the user chooses not to have
fault tolerance, then only the hardware solely dedicated to
fault tolerance, which is relatively small, will go unused.
Rotenberg [14] proposed AR-SMT, which provides fault
tolerance by executing the application using two separate
threads. The primary thread inserts its results into a de-
lay buffer and the redundant thread uses these results for
speculative execution and fault detection. Both threads run
concurrently in the processor pipeline and have different
memory images. The approach of using SMT-based ma-
chines for fault tolerance was generalized in [13]. Both [14]
and [13] require a fine-grain multi-threaded machine capa-
ble of concurrently fetching, decoding, and executing from
more than one thread. Redundant execution, in both cases,
halves the fetch bandwidth, reduces the effective size of the
storage structures (e.g. reservation stations, caches) visible
to each thread, and increases the contention for execution
units. In contrast, operation in MBI is in either performance
mode or introspection mode. Therefore, in MBI, redundant
execution does not compete with the primary execution for
hardware resources at a fine-grain level. The MBI design
is also less intrusive than the SMT-based designs because it
does not require widespread modifications throughout the
processor pipeline.
Both MBI and SMT-based techniques target idle pro-
cessing bandwidth for fault tolerance. However, they tar-
get fundamentally different types of idle processing band-
width. SMT leverages the fine-grain idle processing slots
that remain unused due to limited ILP in each cycle. On the
other hand, MBI utilizes the coarse-grain idle processing
bandwidth that remains unused due to long-latency cache
misses. As such, MBI is well suited for memory-intensive
applications. SMT-based techniques, on the other hand, are
well suited for applications that are not significantly limited
in their performance by long-latency cache misses.
Mendelson and Suri proposed O3RS [7], which provides
transient-fault tolerance to only the out-of-order portion of
the processor pipeline. After an instruction is renamed, it
occupies two entries in the reservation stations. The two re-
sults obtained in this manner are compared for fault detec-
tion. The mechanism proposed by Ray et al. [12] replicates
instructions in the rename stage and provides transient-fault
coverage for all stages after the rename stage. Both [7]
and [12] assume fault protection for the stages before the
rename stage and require extra logic in the processor to han-
dle the simultaneous existence of primary and redundant in-
structions.
The related fault tolerance techniques described thus far
are hardware based. Fault tolerance can also be incorpo-
rated with software support. Wu et al. [23] proposed a tech-
nique to arrange the code such that redundant instructions
are statically mapped to use empty slots in execution units.
However, only applications with regular code behavior and
with latencies predictable at compile-time lend themselves
to static scheduling. The mechanism proposed in [9] exe-
cutes two different versions of the same program (with the
same functionality) and compares the outputs to detect tran-
sient and some permanent faults.
A transient fault may or may not cause an error depend-
ing on whether it affects the final outcome of the program.
A study of the effects of transient faults on the performance
of a superscalar processor is provided in [19]. Weaver et
al. [20] describe a mechanism to avoid signaling errors that
occur during the processing of dynamically dead instruc-
tions. All retired instructions are inserted into a FIFO buffer.
A faulty instruction is marked as possibly incorrect before
insertion into the FIFO buffer. Faults in a possibly incor-
rect instruction are ignored if the instruction is found to
be dynamically dead while it is in the FIFO buffer. Cur-
rently, the MBI mechanism detects errors for both dynami-
cally live and dynamically dead instructions. However, the
technique proposed in [20] can easily be incorporated in
the MBI mechanism by making minor modifications to the
backlog buffer.
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:10:11 UTC from IEEE Xplore.  Restrictions apply. 
8. Conclusion and Future Work
Future processors will need on-chip fault tolerance tech-
niques to tolerate the increasing transient fault rate. Future
processors will also be challenged by the speed gap between
the processor and the memory and will waste significant
processing bandwidth waiting for memory. Based on these
observations, this paper makes the following two contribu-
tions:
(1) A transient-fault detection technique, Micro-
architecture-Based Introspection (MBI), which uses the
wasted processing bandwidth during long-latency cache
misses for redundant execution. This technique has small
hardware cost and provides redundant execution coverage
for the entire pipeline (from instruction fetch to retirement).
(2) A fault recovery scheme for MBI that has a negligible
effect on system availability.
The time redundancy of MBI results in an average IPC
reduction of only 7.1% for memory-intensive benchmarks
and an average IPC reduction of 14.5% over the entire
SPEC CPU2000 suite.
MBI can be combined with runahead execution [8] to im-
prove both the reliability and the performance of memory-
intensive applications. MBI can also be combined with
SMT to utilize both fine-grain and coarse-grain idle pro-
cessing bandwidth for redundant execution. Exploring
these hybrid mechanisms is a part of our future work.
Acknowledgments
We thank Pradip Bose for the early discussions and con-
tinued feedback on this work. We also thank Sanjay Patel,
the anonymous reviewers, and the members of the HPS re-
search group for their helpful comments. This work was
supported by gifts from IBM, Intel, and the Cockrell foun-
dation. Moinuddin Qureshi is supported by an IBM fellow-
ship. Onur Mutlu is supported by an Intel fellowship.
References
[1] T. M. Austin. DIVA: A reliable substrate for deep submicron
microarchitecture design.
the 32nd Annual
ACM/IEEE International Symposium on Microarchitecture, pages
196–207, 1999.
In Proceedings of
[2] J. Bartlett, J. Gray, and B. Horst. Fault tolerance in Tandem computer
systems. Technical Report 86.2, Tandem Computers, Mar. 1986.
[3] R. Hankins, T. Diep, M. Annavaram, B. Hirano, H. Eri, H. Nueckel,
and J. Shen. Scaling and characterizing database workloads: Bridg-
ing the gap between research and practice. In Proceedings of the 36th
Annual ACM/IEEE International Symposium on Microarchitecture,
pages 151–163, 2003.
[4] W. W. Hsu, A. J. Smith, and H. C. Young. Characteristics of produc-
tion database workloads and the TPC benchmarks. IBM Journal of
Research and Development, 40(3):781–802, Mar. 2001.
[5] T. Karkhanis and J. E. Smith. A day in the life of a data cache miss.
In Second Annual Workshop on Memory Performance Issues, 2002.
[6] H. Li, Chen-Yong Cher, T. N. Vijaykumar, and K. Roy. VSV: L2-
miss-driven variable supply-voltage scaling for low power. In Pro-
ceedings of the 36th Annual ACM/IEEE International Symposium on
Microarchitecture, pages 19–28, 2003.
[7] A. Mendelson and N. Suri. Designing high-performance and reli-
able superscalar architectures: The out of order reliable superscalar
(o3rs) approach. In Proceedings of the International Conference on
Dependable Systems and Networks, 2000.
[8] O. Mutlu, J. Stark, C. Wilkerson, and Y. N. Patt. Runahead execution:
An alternative to very large instruction windows for out-of-order pro-
cessors. In Proceedings of the Ninth IEEE International Symposium
on High Performance Computer Architecture, pages 129–140, 2003.
[9] N. Oh, S. Mitra, and E. J. McCluskey. ED4I: Error detection by di-
verse data and duplicated instructions. IEEE Transactions on Com-
puters, 51(2):180–199, Feb. 2002.
[10] J. H. Patel and L. Y. Fung. Concurrent Error Detection in ALUs by
REcomputing with Shifted Operands. IEEE Transactions on Com-
puters, 31(7):589–595, July 1982.
[11] M. Prvulovic, Z. Zhang, and J. Torrellas. ReVive: cost-effective ar-
chitectural support for rollback recovery in shared-memory multipro-
cessors. In Proceedings of the 29th Annual International Symposium
on Computer Architecture, pages 111–122, 2002.
[12] J. Ray, J. C. Hoe, and B. Falsaﬁ . Dual use of superscalar datapath
for transient-fault detection and recovery. In Proceedings of the 34th
Annual ACM/IEEE International Symposium on Microarchitecture,
pages 214–224, 2001.
[13] S. K. Reinhardt and S. S. Mukherjee. Transient fault detection via si-
multaneous multithreading. In Proceedings of the 27th Annual Inter-
national Symposium on Computer Architecture, pages 25–36, 2000.
[14] E. Rotenberg. AR-SMT: A microarchitectural approach to fault tol-
erance in microprocessors. In Proceedings of the Twenty-Ninth An-
nual International Symposium on Fault-Tolerant Computing, pages
84–91, 1999.
[15] P. Shivakumar, M. Kistler, S. W. Keckler, D. Burger, and L. Alvisi.
Modeling the effect of technology trends on the soft error rate of
combinational logic. In Proceedings of the International Conference
on Dependable Systems and Networks, pages 389–398, 2002.
[16] D. J. Sorin, M. M. K. Martin, M. D. Hill, and D. A. Wood. Fast
checkpoint/recovery to support kilo-instruction speculation and hard-
ware fault tolerance. In Dept. of Computer Sciences Technical Report
CS-TR-2000-1420, October 2000.
[17] T. J. Slegal et al. IBM’s S/390 G5 Microprocessor Design. IEEE mi-
cro, pages 12–23, Mar. 1999.
[18] J. Tendler, S. Dodson, S. Fields, H. Le, and B. Sinharoy. POWER4
system microarchitecture. IBM Technical White Paper, Oct. 2001.
[19] N. J. Wang, J. Quek, T. M. Rafacz, and S. J. Patel. Characterizing the
effects of transient faults on a high-performance processor pipeline.
In Proceedings of the International Conference on Dependable Sys-
tems and Networks, pages 61–70, 2004.
[20] C. Weaver, J. Emer, S. S. Mukherjee, and S. K. Reinhardt. Tech-
niques to reduce the soft error rate of a high-performance micropro-
cessor. In Proceedings of the 31th Annual International Symposium
on Computer Architecture, pages 264–273, 2004.
[21] M. V. Wilkes. The memory gap and the future of high performance
memories. ACM Computer Architecture News, 29(1):2–7, Mar. 2001.
[22] A. Wood. Data integrity concepts, features, and technology. White
Paper, Tandem division, Compaq Computer Corporation.
[23] K. Wu and R. Karri. Selectively breaking data dependences to im-
prove the utilization of idle cycles in algorithm level re-computing
data paths. IEEE Transactions on Reliability, 52(4):501–511, Dec.
2003.
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:10:11 UTC from IEEE Xplore.  Restrictions apply.