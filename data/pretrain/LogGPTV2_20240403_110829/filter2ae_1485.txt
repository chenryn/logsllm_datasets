签名算法是指数字签名的算法。数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。数字签名是通过一个单向函数，对要传送的信息进行处理得到的用以认证信息来源，并核实信息在传送过程中是否发生变化的一个字母数字串。目前应用最为广泛的三种签名算法是：Rabin签名、DSS签名、RSA签名。  
0x1 抓包分析  
看样子是个md5加密  
0x2 静态分析
直接定位sig到代码区域, 搜出来会有很多个sig,具体是哪一个只能自己分析, 看封包内容就很好分析出来  
看到这里可以知道了  
Arg7.put的几个参数在封包里都是加密的,所以直接跟到generatorSig方法去, 跟进来发现载入了so文件  
同时下面代码可以看见nativeGeneratorSig方法里什么东西都没有,
并且native暗示这些方法是有实现体的,所以一定是从release_sig这个so文件里实现的  
0x2.1 so文件静态分析  
查找函数nativeGeneratorSig  
进入到该函数里再分析,就看见了之前在jeb静态分析的那个方法nativeGeneratorSig,  
之前在jeb里分析看见这个方法里面没有任何算法什么的东西,而是载入的so文件,  
那么在这个so文件里的这个方法里面绝对是有算法的.  
跟进 GeneratorSIG, 之前在看见封包的加密值判断是个md5加密对吧,
追进来这个GeneratorSIG方法果真看见了参数经过MD5_Calculate函数处理后,然后返回  
跟进MD5_Calculate, 传进的参数直接给MD5加密,经过格式化字节流然后返回了加密后的东西  
0x3 动态调试
在md5加密的地方下个断点,这样能断下来未加密的明文  
R0-R3寄存器是传参, R0也可以用作返回的结果,选中R0 右键 jump  
取出来:  
update/h5_zip01108985730222.1.02.2056.9.5MTAccountWebUIqA#QH=M+Ns&q+Z&J1561214990711Tw5AY783H@EU3#XC  
然后现在我们想知道他的密文,那么根据之前静态分析, 密文返回在result中  
然后根据这个在ida中找到相应位置  
并且将sub_77CF4B18重命名为sprintf 方便之后下断点(当然此处下断点是不行的,因为在循环内部,调试会一直在循环里)  
所以将断点打在循环外,免得一直在循环里跳, 直接F9运行到断点处  
然后可以看到加密后的值出来了.  
这里的值取出来 : 7d12ef85fa0c66c7a549d8cd9336f22c  
加密前的明文取出来:  
update/h5_zip01108985730222.1.02.2056.9.5MTAccountWebUIqA#QH=M+Ns&q+Z&J1561214990711Tw5AY783H@EU3#XC  
把加密前的明文拿去md5加密一下  
我们动态调试出来的加密值相同,以上就是对sig加密算法生成过程的全部分析记录