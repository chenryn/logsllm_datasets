    804849F 04 CF:1 = 0x0:1
    804849F 05 OF:1 = 0x0:1
    804849F 06 esp:32 = temp_0.0:32
    80484A2 07 temp_0.0:32 = [(ecx - 0x4:32)]
    80484A2 08 esp:32 = (esp:32 - 0x4)
    80484A2 09 [esp:32] = temp_0.0:32
    80484A5 0A esp:32 = (esp:32 - 0x4:32)
    80484A5 0B [esp:32] = ebp:32
不算太好，但是我还见过更差的，首先虽然这些对于不太熟悉Falcon IL的人来说看起来都很像是赋值，但是其实在里边是有`Assign`, `Store`,
和`Load`的操作类型的。以及由于表达式的存在，我们在这里可以把像`temp_0.0:32 = [(ecx - 0x4:32)]`或者`SF:1 =
trun.1((temp_0.0:32 >> 0x1F:32))`编码到一个操作里，这样我觉得是会提高可读性的。
Falcon IL没有为了可读性变得像Binary Ninja的IL那么长，但是还是做了一些工作让他变得不那么不可读。
### 编码跳转
跳转指令可以分为几种类型，其中比较典型的是直接和间接，一个直接跳转是指目标地址直接被编码在指令里的，比如"跳到地址0x12345"，或者"给当前的指令指针加上-200“，而间接跳转则是指目标地址没有直接被编码进指令，比如”从[0x12345]读取一个值，然后跳到这个值对应的地址“或者”跳到eax寄存器里保存的值这里“。
我们还有”call“和”非call“跳转指令，可能更好描述他们的用词应该是”过程间跳转“和”过程内跳转”。在大多数架构上这个信息都直接在指令助记符里，在x86里我们有`call`（还有`syscall/sysenter`），在mips里有`balr`,
`jalr`和其他`lr`，在有的架构里确实会更奇怪一点，但是这里我们只讨论Falcon支持的架构。
最后跳转操作可以是带条件的，条件跳转就是一些像x86汇编里`je`一样的指令，当一些条件被满足，例如zero标志位为1的时候就进行跳转。
Falcon把过程间跳转，或者说“Call”跳转，以及间接跳转都编码为跳转指令。Falcon把过程内直接跳转，包括带条件的过程内直接跳转隐式的编码为了在控制流图里可选的受保护的边。这意味着`jmp`标签在汇编里存在，但是在Falcon
IL里是没有指令的，而是会建立一条边到跳转目标处。
Falcon IL将过程内间接跳转（大多用于跳转表）简单编码为间接跳转。
## 一开始看起来很美好，之后有了一些改动
一开始Falcon工作的很好。系统调用指令，以及一些其他的有趣的指令都被实现为`Raise`操作，通过这个操作Falcon
IL就可以去符号执行CGC里的一些回文问题，之后我还写了一些静态检测MIPS二进制程序里libc函数传参的一些常见错误。等到我需要lift浮点数指令的时候，我就简单的翻译一个`Raise`操作，这样如果碰到了，我就会停止分析。在我的分析里，我没有碰到这些问题，所以事情看起来都还挺好的。
### Raise变成了Intrinsic
最终，我在符号执行MIPS指令的时候，我碰到了`rdhwr`指令，这条指令在MIPS
ABI里有特殊的处理方法，当指令的`rd`操作数，也就是源操作数是栈指针的时候，TLS的地址被放进了`rt`操作数，也就是目标操作数，这个情况不是我的`Raise`操作可以处理的了。哦豁。
最后我方法是把`Raise`操作换成了更长的，但是也更充分准备的[Intrinsic](https://docs.rs/falcon/0.3.1/falcon/il/struct.Intrinsic.html)操作，这个操作有他自己的操作数，还提供了甚至在操作语义没有完全被记录的时候的分析功能。可能我只是需要知道什么scalar被写进去了？这种情况就被`Intrinsic`所包括。
现在我完全把所有`Raise`出现的地方都换成了intrinsic，然后一切工作正常，我很高兴有这样的一个切换。
### If-Then-Else，或者说ite表达式
状态合并是个问题，[这是一篇文章](https://dslab.epfl.ch/pubs/stateMerging.pdf)，[这是另外一篇](https://users.ece.cmu.edu/~aavgerin/papers/veritesting-icse-2014.pdf)。给出两个具有路径约束的值，例如`A = 1 iff B = 2`和`A = 2 iff B != 2`，我们需要把值合成`A
= 1 iff B = 2 else A =
2`，然后合并状态，在其他东西都没问题的时候的话，但是那就不是这篇文章需要讨论的问题了。看起来相当直接，当然，除非你不知道如何在你的IL里表示if-then-else。
我一开始有意识的在Falcon
IL里剩下了`Ite`表达式，汇编指令里的条件赋值被翻译为了控制流图，条件则被转换为了图里的条件边，赋值指令只在条件保护的边执行为真的时候才会碰到，这样的做法一开始没什么问题，直到后来我要做状态合并。
经过了一段时间，我心软了，现在Falcon有`Ite`表达式了，这个表达式永远不会被lift出来，但是在之后的分析中可以被加上，比如符号执行里的状态合并（或者其他的情况）。
### MIPS，你这个有delay-slot的小恶魔
为了理解这个程序，你需要了解一点关于Falcon IL和MIPS的知识
  * MIPS跳转有一个指令[delay-slot](https://en.wikipedia.org/wiki/Delay_slot)，对于一个跳转指令，比如`beq v0, v1, label`，MIPS将会：
    1. 计算是否跳转条件为真，以及是否会进行跳转
    2. 执行跳转后的指令（以及delay slot）
    3. 进行跳转，如果需要跳转的话
  * Falcon IL的指令，在lift之后，包含lift之前的地址，主要是被翻译器用来计算CFG的边，以及分析找到间接跳转之后的目标
如果在你的IL里没有显式的delay slot的符号（关于这个问题我其实应该再写一篇文章），delay slot就会成为一个完美的大灾难。
我们从指令一开始是怎么实现的开始
假设我们有以下的代码:
    1000: balr 0x123456:32
    1004: addiu $v0, $zero, 1
非常简单，Falcon 以块为单位lift指令，而不是独立的指令，在我们碰到一个带有delay
slot的跳转指令的时候，我们可以简单的把跳转指令lift了，再lift delay slot，之后把delay
slot放在跳转指令之前，块结束的地方，非常简单，所以我们来看看大概长什么样：
    1004 00 $v0:32 = (0x0:32 + 0x1:32)
    1000 01 b 0x123456:32
牛逼极了，任务完成，只是，如果在分析过程中，有另外一个跳转指向0x1000，那么会发生什么问题？好，我们看下，我们就会找到0x1000，然后开始执行，然后
_忽略了delay slot_
。这个问题会导致`ld.so`出现失败，然后让人花好多小时，甚至好多天，我自己都没数来debug么？是的。。所以应该怎么fix呢？
首先我们可以在1004指令前插入指令，这个指令什么也不干，但是分配给他地址1000。我们还是需要跳转指令的地址，因为这是现在lifter的工作方式，现在，Falcon大概会做这样的事情：
    1000 00 nop = 0x0:1
    1004 01 $v0:32 = (0x0:32 + 0x1:32)
    1005 02 b 0x123456:32
哇塞看啊，这样就好了，只是看起来不太漂亮是吧？有时候确实是。。
记住，条件跳转会在delay slot执行之前计算跳转条件，比如这样一个指令序列：
    1000 beq $v0, $zero, label
    1004 addiu $v0, $zero, 1
这就会变成：
    1000 00 nop = 0x0:1
    1004 01 $v0 = (0x0:32 + 0x1:32)
    // outgoing condition on edges is ($v0 == $0x0:32)
我们就弄坏了这个条件跳转，我最后采用的解决方案是把nop换成一个到变量`branch_condition:1`的赋值，这样就成了：
    1000 00 branching_condition:1 = ($v0:32 == 0x0:32)
    1004 01 $v0 = (0x0:32 + 0x1:32)
    // outgoing condition on edges is branching_condition:1
这样就好了，我觉得这个方法对于所有单指令delay slot的架构都适用。
### 缺少跳转指令的情况
我们之前提到了Falcon
IL是怎么完全忽略掉过程内直接跳转的，这些跳转会被隐式转换成CFG内的边。这就有了一个问题：有时候一个分析需要知道跳转指令的地址。最显然的例子就是一个跳转指令跳到了一个过程内直接跳转，如果这个跳转没有一个占位符，我们就完了。
这个问题在MIPS里用上面的丑陋的hack方法解决了，但是在x86里还是存在。我可以继续往IL里添加没用的赋值，就为了解决在某个指令应该在的地址的占位问题，但是这样太丑了，不优雅，而且可能之后会造成更多的问题。例如dead
code elimination（不活跃代码消除）的pass可能会消除一些指令，使得刚才的那些问题在之后又出现了。
我觉得是时候搞一个完备的`nop`操作了，因为我知道`Nop`操作没有有意义的语义，以及我在分析的时候可以跳过，我甚至可以在观察IL的时候忽略（保证了一定程度上的IL可读性）。在我实现dead
code elimination的时候，或者其他的IL变形的时候，我可以不管nop，或者在移除指令后插入nop，保证未来需要依赖到地址的分析工作正常。
## Falcon，以及继续Falcon IL
我不觉得有这么一种IL可以使得所有的分析都非常适合，一个智者曾经告诉我“你可以创建一个IL来适合这个分析，但是另外一种就不行了”。我们从一个提供了不错的基础的IL开始，然后再把它变形为其他的表示方式来更好的使得表示方式适于我们要进行的分析，然而当信息，例如省略掉的跳转指令地址的在一开始的IL就丢了，这样就会有问题了。Falcon
IL依然是我最喜欢的IL，然后我会经常来保证他的完整性。