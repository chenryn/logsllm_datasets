## 小结今天，我们主要讨论线程同步的基本概念以及超越线程同步的技巧。由于线程同步对效率的损害，我们使用线程同步的最高技巧，就是不使用线程同步。如果做不到这一点，在线程同步的处理时间内，做的事情越少越好。线程同步本身非常复杂，它相关的技术也很繁杂。这方面可以参考的书籍和文章也很多。我们不在这里讨论这些同步的技术了。欢迎你在留言区，讨论这些技术，分享你使用这些技术的心得体会，我们一起来学习、精进。
## 一起来动手下面的这段代码，摘录自OpenJDK，我们上次使用过。上一次，我们讨论了它的接口设计问题。代码中 Signature 这个类，不是一个天然的多线程安全的类，它的setParameter()，initSign()，update() 这些方法，都可以改变实例的状态。如果要你去实现一个多线程安全的子类，你会怎么办？如果要你重新设计这个类，包括拆分成几个类，你有没有办法把它设计成一个天然的多线程安全的类？你试试看，能不能解决这些问题。欢迎你把发现的问题，解决的办法，以及优化的接口公布在讨论区，也可以写一下你的解决问题的思路。Signature这个类，是一个有着二十多年历史的，被广泛使用的 Java核心类。说不定，你可以为 OpenJDK社区，提供一个有价值的参考意见或者改进方案。    /* * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved. * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. * *  */ package java.security; import java.security.InvalidAlgorithmParameterException;import java.security.InvalidKeyException;import java.security.PrivateKey;import java.security.PublicKey;import java.security.SignatureException;import java.security.SignatureSpi;import java.security.spec.AlgorithmParameterSpec; /** * The Signature class is used to provide applications the functionality * of a digital signature algorithm. Digital signatures are used for * authentication and integrity assurance of digital data. *  *  *  * @since 1.1 */public abstract class Signature extends SignatureSpi {    // snipped     /**     * Initializes this signature engine with the specified parameter set.     *     * @param params the parameters     *     * @exception InvalidAlgorithmParameterException if the given parameters     * are inappropriate for this signature engine     *     * @see #getParameters     */    public final void setParameter(AlgorithmParameterSpec params)            throws InvalidAlgorithmParameterException {        // snipped    }     /**     * Initializes this object for verification. If this method is called     * again with a different argument, it negates the effect     * of this call.     *     * @param publicKey the public key of the identity whose signature is     * going to be verified.     *     * @exception InvalidKeyException if the key is invalid.     */    public final void initVerify(PublicKey publicKey)            throws InvalidKeyException {        // snipped    }     /**     * Initialize this object for signing. If this method is called     * again with a different argument, it negates the effect     * of this call.     *     * @param privateKey the private key of the identity whose signature     * is going to be generated.     *     * @exception InvalidKeyException if the key is invalid.     */    public final void initSign(PrivateKey privateKey)            throws InvalidKeyException {        // snipped    }     /**     * Updates the data to be signed or verified, using the specified     * array of bytes.     *     * @param data the byte array to use for the update.     *     * @exception SignatureException if this signature object is not     * initialized properly.     */    public final void update(byte[] data) throws SignatureException {        // snipped    }     /**     * Returns the signature bytes of all the data updated.     * The format of the signature depends on the underlying     * signature scheme.     *     * A call to this method resets this signature object to the state     * it was in when previously initialized for signing via a     * call to {@code initSign(PrivateKey)}. That is, the object is     * reset and available to generate another signature from the same     * signer, if desired, via new calls to {@code update} and     * {@code sign}.     *     * @return the signature bytes of the signing operation's result.     *     * @exception SignatureException if this signature object is not     * initialized properly or if this signature algorithm is unable to     * process the input data provided.     */    public final byte[] sign() throws SignatureException {        // snipped    }     /**     * Verifies the passed-in signature.     *     * A call to this method resets this signature object to the state     * it was in when previously initialized for verification via a     * call to {@code initVerify(PublicKey)}. That is, the object is     * reset and available to verify another signature from the identity     * whose public key was specified in the call to {@code initVerify}.     *     * @param signature the signature bytes to be verified.     *     * @return true if the signature was verified, false if not.     *     * @exception SignatureException if this signature object is not     * initialized properly, the passed-in signature is improperly     * encoded or of the wrong type, if this signature algorithm is unable to     * process the input data provided, etc.     */    public final boolean verify(byte[] signature) throws SignatureException {        // snipped    }}![](Images/64444bae3ac90f82cb45ef5f1bc68d94.png){savepage-src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg"}
# 23 \| 怎么减少内存使用，减轻内存管理负担？管理内存，不管是什么编程语言，向来都是一个难题。Java语言能够长期领先的一个重要原因，就是它拥有强大的内存管理能力，并且这种能力还在不断地进化。然而，只依靠Java 内在的内存管理能力，是远远不够的。2018 年 9 月，亚马逊向 OpenJDK社区提交了一个改进请求。这个改进涉及到一个问题，如果一个服务的缓存数量巨大，比如说有10 万个连接会话，Java的垃圾处理器要停滞几分钟，才能清理完这么巨大的缓存。而这几分钟的停滞，是不可忍受的事故。这是一个值得我们关注的细节。缓存的本意，就是为了提高效率。然而，拥有过多的用户，过多的缓存，反而会让效率变低。随着大数据、云计算以及物联网的不断演进，很多技术都面临着巨大的挑战。七八年前（2010年左右），能解决 C10K（同时处理 1万个用户连接）问题，感觉就可以高枕无忧了。现在有不少应用，需要开始考虑C10M（同时处理 1千万个用户连接）问题，甚至是更多的用户连接，以便满足用户需求。很多以前不用担心的问题，也会冒出来算旧账。要想让内存使用得更有效率，我们还需要掌握一些成熟的实践经验。
## 使用更少的内存提高内存使用最有效率的办法，就是使用更少的内存。这听起来像是废话，却也是最简单直接、最有用的办法。减少内存的使用，意味着更少的内存分配、更少的内存填充、更少的内存释放、更轻量的垃圾回收。内存的使用减少一倍，代码的效率会成倍地提升，这不是简单的线性关系。``{=html}减少内存的使用，办法有且只有两个。第一个办法是减少实例的数量。第二个办法是减小实例的尺寸。
## 减少实例数量还记得以前我们用到的，在不同的语言环境下，该怎么打招呼的代码吗？上一次，我们把它改成了不可变的类，避免了线程同步的问题。我把这段代码重新抄录在下面。![](Images/30763dbc64b13611b778b631866d0c59.png){savepage-src="https://static001.geekbang.org/resource/image/7e/ea/7ef80d04c5d8da0aeac59bafac557dea.png"}\这段代码还有个问题，就是内存使用不够友好。对于汉语环境来说，打招呼用"你好"。如果使用上面的设计，那么每次使用汉语环境，调用构造方法，都产生一个不同的实例对象。如果只实例化一次，当然没有什么问题。如果要实例化 10 次，100 次，1000次，10000次，而且每个实例都是固定的汉语加"你好"，这就是很大的浪费了。内存的使用，随着实例的数量线性增长，100个实例，就要使用 100倍的内存。即便实例的产生和废弃都非常迅速，在巨大的实例数量面前，Java的垃圾处理器也会有很大的压力。    HelloWords helloWords = new HelloWords("Chinese", "Ni Hao");...... System.out.prinyln(        "The hello words in Chinese: " + helloWords.getGreeting());如果一种语言环境的打招呼的办法是固定不变的，而且语言环境的数量有限的话，我们就只有必要使用一个实例。如果有了这个意识的话，那么对于这个打招呼的代码，我们就可以很自然地想到使用枚举类型，把它改进成下面的样子。![](Images/0cf694a28b1247a8c97cb94c8a0a0132.png){savepage-src="https://static001.geekbang.org/resource/image/d9/27/d9230afaccf1c0e6d34b5400e35ffa27.png"}\使用了枚举类型后，每一种语言就只有一个实例了。不管使用多少次，对内存的影响，对Java 的垃圾处理器的影响，几乎可以忽略不计。对于数量有限的对象，我们应该优先考虑使用枚举类型，比如交通标志，国家名称等等。其实，枚举类型就是一种常用的数据静态化的范例。我们还会在后面讨论其他类似的数据静态化的处理方式。
### 避免不必要的实例Java语言里，有一些历史遗留的接口设计问题，会无意中导致不必要的实例。我们下面来看看两个例子。第一个例子是应用程序使用了不必要的构造函数。比如，使用 String的构造函数实例化一串字符。![](Images/0fdbd84cb05d8b9fdb1e91aca6d9c8bf.png){savepage-src="https://static001.geekbang.org/resource/image/6a/0d/6a4396ae788969f3ce2d709f22d8cc0d.png"}\上面的反面实例，每次调用都会产生一个实例对象，而这个实例对象需要交给Java 垃圾处理器管理。事实上，由于 String是一个不可变的类，每次调用产生的实例没有任何的区别。如果这样的代码经常使用，比如说被调用了十万次，就会有十万个实例对象产生，Java垃圾处理器就需要管理十万个实例。这是一个很大的，不必要的开销。上面的两个正面案例，使用单实例的编码习惯，无论这段代码被调用了多少次，在Java的运行环境下，都只有一个实例。而且，相同的字符串，即使位于不同的代码空间里，在同一Java 的运行环境下，也都只有一个实例。String类的这个构造函数，是一个接口设计的历史遗留问题，价值小，问题多。Java基础类库里，还有一些类似的历史遗留问题，特别是原始数据类型（primitivetype）对应的类。我们要避免使用它们的构造方法，甚至避免使用这些类。![](Images/b053bc2c44bd23d974c873734e95f3ab.png){savepage-src="https://static001.geekbang.org/resource/image/f1/d0/f111895c74316514bdcd0f019fcaa1d0.png"}\幸运的是，这些原始数据类型对应类的构造方法，从 Java 9开始，就已经被废弃了。但是这些方法依然存在，这些类依然存在。不论在哪里，如果你看到还有代码使用原始数据类型的构造函数，都可以提交一个问题报告。这样的更改，付出少，收益大。
### 避免使用原始数据类通过上面的讨论，我们可以理解，为什么要避免使用原始数据类型的构造方法。可是为什么还要避免使用原始数据类呢？这里涉及到Java 原始数据类型的自动装箱（boxing）与拆箱（unboxing）的类型转换。比如说，下面的代码，就涉及到一个装箱的过程。整数 0 和 2都要先被转换成一个 Long 类的实例，然后才执行赋值操作。![](Images/512a53e7814695dbd7d5cf1d24ad34c4.png){savepage-src="https://static001.geekbang.org/resource/image/2b/46/2bcb06d24ede01daaa2b323114748d46.png"}\这个装箱的过程，就产生了不必要的实例。如果这样的转换数量巨大，就会有明显的性能影响。![](Images/f6083d8f3fe086d39cfe97f96d63f12f.png){savepage-src="https://static001.geekbang.org/resource/image/c5/71/c5d0d51a6643b9afce5d18d990dab871.png"}