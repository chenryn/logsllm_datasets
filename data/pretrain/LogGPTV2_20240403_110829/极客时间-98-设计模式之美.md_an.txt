# 20 \| 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？上几节课中，我们学习了经典的 SOLID原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS原则比较经典，耳熟能详，但 YAGNI你可能没怎么听过，不过它理解起来也不难。理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解KISS原则中"简单"两个字？什么样的代码才算"简单"？怎样的代码才算"复杂"？如何才能写出"简单"的代码？YAGNI原则跟 KISS原则说的是一回事吗？如果你还不能非常清晰地回答出上面这几个问题，那恭喜你，又得到了一次进步提高的机会。等你听完这节课，我相信你很自然就能回答上来了。话不多说，让我们带着这些问题，正式开始今天的学习吧！如何理解"KISS 原则"？KISS原则的英文描述有好几个版本，比如下面这几个。1.  Keep It Simple and    Stupid.    2.  Keep It Short and    Simple.    3.  Keep It Simple and    Straightforward.        不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。KISS原则算是一个万金油类型的设计原则，可以应用在很多场景中。它不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等，比如，冰箱、建筑、iPhone手机的设计等等。不过，咱们的专栏是讲代码设计的，所以，接下来，我还是重点讲解如何在编码开发中应用这条原则。我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而KISS原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug比较难隐藏。即便出现bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码"Simple andStupid"，但并没有讲到，什么样的代码才是"Simple andStupid"的，更没有给出特别明确的方法论，来指导如何开发出"Simple andStupid"的代码。所以，看着非常简单，但不能落地，这就有点像我们常说的"心灵鸡汤"。哦，咱们这里应该叫"技术鸡汤"。所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。代码行数越少就越"简单"吗？我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串ipAddress 是否是合法的 IP地址。 一个合法的 IP地址由四个数字组成，并且通过"."来进行分割。每组数字的取值范围是0\~255。第一组数字比较特殊，不允许为0。对比这三段代码，你觉得哪一段代码最符合 KISS原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。    // 第一种实现方式: 使用正则表达式    public boolean isValidIpAddressV1(String ipAddress) {      if (StringUtils.isBlank(ipAddress)) return false;      String regex = "^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."              + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."              + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."              + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$";      return ipAddress.matches(regex);    }    // 第二种实现方式: 使用现成的工具类    public boolean isValidIpAddressV2(String ipAddress) {      if (StringUtils.isBlank(ipAddress)) return false;      String[] ipUnits = StringUtils.split(ipAddress, '.');      if (ipUnits.length != 4) {        return false;      }      for (int i = 0; i  255) {          return false;        }        if (i == 0 && ipUnitIntValue == 0) {          return false;        }      }      return true;    }    // 第三种实现方式: 不使用任何工具类    public boolean isValidIpAddressV3(String ipAddress) {      char[] ipChars = ipAddress.toCharArray();      int length = ipChars.length;      int ipUnitIntValue = -1;      boolean isFirstUnit = true;      int unitsCount = 0;      for (int i = 0; i  255) return false;          if (isFirstUnit && ipUnitIntValue == 0) return false;          if (isFirstUnit) isFirstUnit = false;          ipUnitIntValue = -1;          unitsCount++;          continue;        }        if (c  '9') {          return false;        }        if (ipUnitIntValue == -1) ipUnitIntValue = 0;        ipUnitIntValue = ipUnitIntValue * 10 + (c - '0');      }      if (ipUnitIntValue  255) return false;      if (unitsCount != 3) return false;      return true;    }第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合KISS原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。一方面，正则表达式本身是比较复杂的，写出完全没有 bug的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS原则。 讲完了第一种实现方式，我们再来看下其他两种实现方式。第二种实现方式使用了 StringUtils 类、Integer类提供的一些现成的工具函数，来处理 IP地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加"简单"，更加符合KISS 原则。 不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对IP地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非isValidIpAddress()函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。代码逻辑复杂就违背 KISS 原则吗？刚刚我们提到，并不是代码行数越少就越"简单"，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背KISS原则呢？在回答这个问题之前，我们先来看下面这段代码：    // KMP algorithm: a, b 分别是主串和模式串；n, m 分别是主串和模式串的长度。    public static int kmp(char[] a, int n, char[] b, int m) {      int[] next = getNexts(b, m);      int j = 0;      for (int i = 0; i  0 && a[i] != b[j]) { // 一直找到 a[i] 和 b[j          j = next[j - 1] + 1;        }        if (a[i] == b[j]) {          ++j;        }        if (j == m) { // 找到匹配模式串的了          return i - m + 1;        }      }      return -1;    }    // b 表示模式串，m 表示模式串的长度    private static int[] getNexts(char[] b, int m) {      int[] next = new int[m];      next[0] = -1;      int k = -1;      for (int i = 1; i  64) {          return false;        }        // contains only lowcase characters        if (!StringUtils.isAllLowerCase(username)) {          return false;        }        // contains only a~z,0~9,dot        for (int i = 0; i = 'a' && c = '0' && c  64) {          return false;        }        // contains only lowcase characters        if (!StringUtils.isAllLowerCase(password)) {          return false;        }        // contains only a~z,0~9,dot        for (int i = 0; i = 'a' && c = '0' && c  255) {          return false;        }        if (i == 0 && ipUnitIntValue == 0) {          return false;        }      }      return true;    }这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了DRY原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP地址是否合法的地方，都统一调用同一个函数。 假设我们不统一实现思路，那有些地方调用了 isValidIp()函数，有些地方又调用了 checkIfIpValid()函数，这就会导致代码看起来很奇怪，相当于给代码"埋坑"，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。 除此之外，如果哪天项目中 IP地址是否合法的判定规则改变了，比如：255.255.255.255不再被判定为合法的了，相应地，我们对 isValidIp()的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid()函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid()函数，这样就会导致有些代码仍然使用老的 IP地址判断逻辑，导致出现一些莫名其妙的bug。 代码执行重复前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService中 login()函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：     public class UserService {      private UserRepo userRepo;// 通过依赖注入或者 IOC 框架注入      public User login(String email, String password) {        boolean existed = userRepo.checkIfUserExisted(email, password);        if (!existed) {          // ... throw AuthenticationFailureException...        }        User user = userRepo.getUserByEmail(email);        return user;      }    }    public class UserRepo {      public boolean checkIfUserExisted(String email, String password) {        if (!EmailValidation.validate(email)) {          // ... throw InvalidEmailException...        }        if (!PasswordValidation.validate(password)) {          // ... throw InvalidPasswordException...        }        //...query db to check if email&password exists...      }      public User getUserByEmail(String email) {        if (!EmailValidation.validate(email)) {          // ... throw InvalidEmailException...        }        //...query db to get user by email...      }    }上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY原则。这是因为代码中存在"执行重复"。我们一块儿来看下，到底哪些代码被重复执行了？ 重复执行最明显的一个地方，就是在 login() 函数中，email的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted()函数的时候，另一次是调用 getUserByEmail()函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo中移除，统一放到 UserService中就可以了。 除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login()函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次getUserByEmail() 函数，从数据库中获取到用户的 email、password等信息，然后跟用户输入的 email、password信息做对比，依次判断是否登录成功。 实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和getUserByEmail() 函数都需要查询数据库，而数据库这类的 I/O操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I/O操作。 按照刚刚的修改思路，我们把代码重构一下，移除"重复执行"的代码，只校验一次email 和password，并且只查询一次数据库。重构之后的代码如下所示：     public class UserService {      private UserRepo userRepo;// 通过依赖注入或者 IOC 框架注入      public User login(String email, String password) {        if (!EmailValidation.validate(email)) {          // ... throw InvalidEmailException...        }        if (!PasswordValidation.validate(password)) {          // ... throw InvalidPasswordException...        }        User user = userRepo.getUserByEmail(email);        if (user == null || !password.equals(user.getPassword()) {          // ... throw AuthenticationFailureException...        }        return user;      }    }    public class UserRepo {      public boolean checkIfUserExisted(String email, String password) {        //...query db to check if email&password exists      }      public User getUserByEmail(String email) {        //...query db to get user by email...      }    }代码复用性（Code Reusability）在专栏的最开始，我们有提到，代码的复用性是评判代码质量的一个非常重要的标准。当时只是点到为止，没有展开讲解，今天，我再带你深入地学习一下这个知识点。什么是代码的复用性？我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。 **首先，"不重复"并不代表"可复用"。**在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY原则跟代码的可复用性讲的是两回事。 **其次，"复用"和"可复用性"关注角度不同。**代码"可复用性"是从代码开发者的角度来讲的，"复用"是从代码使用者的角度来讲的。比如，A同事编写了一个 UrlUtils 类，代码的"可复用性"很好。B同事在开发新功能的时候，直接"复用"A 同事编写的 UrlUtils类。 尽管复用、可复用性、DRY原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug会比从零重新开发要少。 "复用"这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring框架、Google Guava 类库、UI组件等等。 怎么提高代码复用性？实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了7 条，具体如下。 1.  减少代码耦合        对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。1.  满足单一职责原则        我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。1.  模块化        这里的"模块"，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。1.  业务与非业务逻辑分离        越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。1.  通用代码下沉        从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。1.  继承、多态、抽象、封装        在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。1.  应用模板等设计模式        一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部API 那样，去思考它的复用性。辩证思考和灵活应用实际上，编写可复用的代码并不简单。如果我们在编写代码的时候，已经有复用的需求场景，那根据复用的需求去开发可复用的代码，可能还不算难。但是，如果当下并没有复用的需求，我们只是希望现在编写的代码具有可复用的特点，能在未来某个同事开发某个新功能的时候复用得上。在这种没有具体复用需求的情况下，我们就需要去预测将来代码会如何复用，这就比较有挑战了。实际上，除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的YAGNI 原则。除此之外，有一个著名的原则，叫作"Rule ofThree"。这条原则可以用在很多行业和场景中，你可以自己去研究一下。如果把这个原则用在这里，那就是说，我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，"RuleofThree"中的"Three"并不是真的就指确切的"三"，这里就是指"二"。重点回顾今天的内容到此就讲完了。我们一块来回顾一下，你需要重点掌握的内容。**1.DRY 原则**我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY原则。除此之外，代码执行重复也算是违反 DRY原则。 **2. 代码复用性**今天，我们讲到提高代码可复用性的一些方法，有以下 7点。 1.  减少代码耦合        2.  满足单一职责原则        3.  模块化        4.  业务与非业务逻辑分离        5.  通用代码下沉        6.  继承、多态、抽象、封装        7.  应用模板等设计模式        实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部API 一样去思考它的复用性。我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。相比于代码的可复用性，DRY原则适用性更强一些。我们可以不写可复用的代码，但一定不能写重复的代码。课堂讨论除了实现逻辑重复、功能语义重复、代码执行重复，你还知道有哪些其他类型的代码重复？这些代码重复是否违反DRY 原则？ 欢迎在留言区写下你的想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。