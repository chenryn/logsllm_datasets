}
char * s_gets(char * st, int n)
{
char * ret_val;
char * find;
ret_val = fgets(st, n, stdin);
if (ret_val)
{
find = strchr(st, '\n');  // 查找换行符
if (find)        // 如果地址不是 NULL，
*find = '\0';     // 在此处放置一个空字符
else
while (getchar() != '\n')
continue;    // 处理剩余输入行
}
return ret_val;
}
1314
该程序用链表执行两个任务。第 1 个任务是，构造一个链表，把用户输
入的数据储存在链表中。第 2个任务是，显示链表。显示链表的任务比较简
单，所以我们先来讨论它。
1.显示链表
显示链表从设置一个指向第1个结构的指针（名为current）开始。由于
头指针（名为head）已经指向链表中的第1个结构，所以可以用下面的代码
来完成：
current = head;
然后，可以使用指针表示法访问结构的成员：
printf("Movie: %s Rating: %d\n", current->title, current->rating);
下一步是根据储存在该结构中next成员中的信息，重新设置current指针
指向链表中的下一个结构。代码如下：
current = current->next;
完成这些之后，再重复整个过程。当显示到链表中最后一个项时，
current 将被设置为 NULL，因为这是链表最后一个结构中next成员的值。
while (current != NULL)
{
printf("Movie: %s Rating: %d\n", current->title, current->rating);
current = current->next;
}
遍历链表时，为何不直接使用head指针，而要重新创建一个新指针
（current）？因为如果使用head会改变head中的值，程序就找不到链表的开
1315
始处。
2.创建链表
创建链表涉及下面3步：
（1）使用malloc()为结构分配足够的空间；
（2）储存结构的地址；
（3）把当前信息拷贝到结构中。
如无必要不用创建一个结构，所以程序使用临时存储区（input数组）获
取用户输入的电影名。如果用户通过键盘模拟EOF或输入一行空行，将退出
下面的循环：
while (s_gets(input, TSIZE) != NULL && input[0] != '\0')
如果用户进行输入，程序就分配一个结构的空间，并将其地址赋给指针
变量current:
current = (struct film *) malloc(sizeof(struct film));
链表中第1 个结构的地址应储存在指针变量head中。随后每个结构的地
址应储存在其前一个结构的next成员中。因此，程序要知道它处理的是否是
第1个结构。最简单的方法是在程序开始时，把head指针初始化为NULL。然
后，程序可以使用head的值进行判断：
if (head == NULL) /* 第1个结构*/
head = current;
else /* subsequent structures */
prev->next = current;
1316
在上面的代码中，指针prev指向上一次分配的结构。
接下来，必须为结构成员设置合适的值。尤其是，把next成员设置为
NULL，表明当前结构是链表的最后一个结构。还要把input数组中的电影名
拷贝到title成员中，而且要给rating成员提供一个值。如下代码所示：
current->next = NULL;
strcpy(current->title, input);
puts("Enter your rating :");
scanf("%d", &current->rating);
由于s_gets()限制了只能输入TSIZE-1个字符，所以用strcpy()函数把input
数组中的字符串拷贝到title成员很安全。
最后，要为下一次输入做好准备。尤其是，要设置 
prev 
指向当前结
构。因为在用户输入下一部电影且程序为新结构分配空间后，当前结构将成
为新结构的上一个结构，所以程序在循环末尾这样设置该指针：
prev = current;
程序是否能正常运行？下面是该程序的一个运行示例：
Enter first movie title:
Spirited Away
Enter your rating :
9
Enter next movie title (empty line to stop):
The Duelists
1317
Enter your rating :
8
Enter next movie title (empty line to stop):
Devil Dog: The Mound of Hound
Enter your rating :
1
Enter next movie title (empty line to stop):
Here is the movie list:
Movie: Spirited Away Rating: 9
Movie: The Duelists Rating: 8
Movie: Devil Dog: The Mound of Hound Rating: 1
Bye!
3.释放链表
在许多环境中，程序结束时都会自动释放malloc()分配的内存。但是，
最好还是成对调用malloc()和free()。因此，程序在清理内存时为每个已分配
的结构都调用了free()函数：
current = head;
while (current != NULL)
{
current = head;
1318
head = current->next;
free(current);
}
17.2.2 反思
films2.c 程序还有些不足。例如，程序没有检查 malloc()是否成功请求
到内存，也无法删除链表中的项。这些不足可以弥补。例如，添加代码检查
malloc()的返回值是否是NULL（返回NULL说明未获得所需内存）。如果程
序要删除链表中的项，还要编写更多的代码。
这种用特定方法解决特定问题，并且在需要时才添加相关功能的编程方
式通常不是最好的解决方案。另一方面，通常都无法预料程序要完成的所有
任务。随着编程项目越来越大，一个程序员或编程团队事先计划好一切模
式，越来越不现实。很多成功的大型程序都是由成功的小型程序逐步发展而
来。
如果要修改程序，首先应该强调最初的设计，并简化其他细节。程序清
单 17.2 中的程序示例没有遵循这个原则，它把概念模型和代码细节混在一
起。例如，该程序的概念模型是在一个链表中添加项，但是程序却把一些细
节（如，malloc()和 
current->next 
指针）放在最明显的位置，没有突出接
口。如果程序能以某种方式强调给链表添加项，并隐藏具体的处理细节（如
调用内存管理函数和设置指针）会更好。把用户接口和代码细节分开的程
序，更容易理解和更新。学习下面的内容就可以实现这些目标。
1319
17.3 抽象数据类型（ADT）
在编程时，应该根据编程问题匹配合适的数据类型。例如，用int类型代
表你有多少双鞋，用float或 double 类型代表每双鞋的价格。在前面的电影示
例中，数据构成了链表，每个链表项由电影名（C 字符串）和评级（一个int
类型值）。C中没有与之匹配的基本类型，所以我们定义了一个结构代表单
独的项，然后设计了一些方法把一系列结构构成一个链表。本质上，我们使
用 C语言的功能设计了一种符合程序要求的新数据类型。但是，我们的做法
并不系统。现在，我们用更系统的方法来定义数据类型。
什么是类型？类型特指两类信息：属性和操作。例如，int 类型的属性
是它代表一个整数值，因此它共享整数的属性。允许对int类型进行算术操作
是：改变int类型值的符号、两个int类型值相加、相减、相乘、相除、求模。
当声明一个int类型的变量时，就表明了只能对该变量进行这些操作。
注意 整数属性
C的int类型背后是一个更抽象的整数概念。数学家已经用正式的抽象方
式定义了整数的属性。例如，假设N和M是整数，那么N+M=M+N；假设S、
Q也是整数，如果N+M=S，而且N+Q=S，那么M=Q。可以认为数学家提供
了整数的抽象概念，而C则实现了这一抽象概念。注意，实现整数的算术运
算是表示整数必不可少的部分。如果只是储存值，并未在算术表达式中使
用，int类型就没那么有用了。还要注意的是，C并未很好地实现整数。例
如，整数是无穷大的数，但是2字节的int类型只能表示65536个整数。因此，
不要混淆抽象概念和具体的实现。
假设要定义一个新的数据类型。首先，必须提供储存数据的方法，例如
设计一个结构。其次，必须提供操控数据的方法。例如，考虑films2.c程序
（程序清单17.2）。该程序用链接的结构来储存信息，而且通过代码实现了
如何添加和显示信息。尽管如此，该程序并未清楚地表明正在创建一个新类
型。我们应该怎么做？
1320
计算机科学领域已开发了一种定义新类型的好方法，用3个步骤完成从
抽象到具体的过程。
1.提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实
现，也不能依赖特定的编程语言。这种正式的抽象描述被称为抽象数据类型
（ADT）。
2.开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执
行所需操作的函数。例如在 C中，可以提供结构定义和操控该结构的函数原
型。这些作用于用户定义类型的函数相当于作用于 
C基本类型的内置运算
符。需要使用该新类型的程序员可以使用这个接口进行编程。
3.编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无
需了解具体的实现细节。
我们再次以前面的电影项目为例来熟悉这个过程，并用新方法重新完成
这个示例。
17.3.1 建立抽象
从根本上看，电影项目所需的是一个项链表。每一项包含电影名和评
级。你所需的操作是把新项添加到链表的末尾和显示链表中的内容。我们把
需要处理这些需求的抽象类型叫作链表。链表具有哪些属性？首先，链表应
该能储存一系列的项。也就是说，链表能储存多个项，而且这些项以某种方
式排列，这样才能描述链表的第1项、第2项或最后一项。其次，链表类型应
该提供一些操作，如在链表中添加新项。下面是链表的一些有用的操作：
初始化一个空链表；
在链表末尾添加一个新项；
确定链表是否为空；
确定链表是否已满；
1321
确定链表中的项数；
访问链表中的每一项执行某些操作，如显示该项。
对该电影项目而言，暂时不需要其他操作。但是一般的链表还应包含以
下操作：
在链表的任意位置插入一个项；
移除链表中的一个项；
在链表中检索一个项（不改变链表）；
用另一个项替换链表中的一个项；
在链表中搜索一个项。
非正式但抽象的链表定义是：链表是一个能储存一系列项且可以对其进
行所需操作的数据对象。该定义既未说明链表中可以储存什么项，也未指定
是用数组、结构还是其他数据形式来储存项，而且并未规定用什么方法来实
现操作（如，查找链表中元素的个数）。这些细节都留给实现完成。
为了让示例尽量简单，我们采用一种简化的链表作为抽象数据类型。它
只包含电影项目中的所需属性。该类型总结如下：
类型名：    简单链表
类型属性：    可以储存一系列项
类型操作：    初始化链表为空
确定链表为空
确定链表已满
确定链表中的项数
1322
在链表末尾添加项
遍历链表，处理链表中的项
清空链表
下一步是为开发简单链表ADT开发一个C接口。
17.3.2 建立接口
这个简单链表的接口有两个部分。第1部分是描述如何表示数据，第2部
分是描述实现ADT操作的函数。例如，要设计在链表中添加项的函数和报告
链表中项数的函数。接口设计应尽量与ADT的描述保持一致。因此，应该用
某种通用的Item类型而不是一些特殊类型，如int或struct 
film。可以用C的
typedef功能来定义所需的Item类型：
#define TSIZE 45 /* 储存电影名的数组大小 */
struct film
{
char title[TSIZE];
int rating;
};
typedef struct film Item;
然后，就可以在定义的其余部分使用 Item 类型。如果以后需要其他数
据形式的链表，可以重新定义Item类型，不必更改其余的接口定义。
定义了 Item 之后，现在必须确定如何储存这种类型的项。实际上这一
步属于实现步骤，但是现在决定好可以让示例更简单些。在films2.c程序中
用链接的结构处理得很好，所以，我们在这里也采用相同的方法：
1323
typedef struct node
{
Item item;
struct node * next;
} Node;
typedef Node * List;
在链表的实现中，每一个链节叫作节点（node）。每个节点包含形成链
表内容的信息和指向下一个节点的指针。为了强调这个术语，我们把node作
为节点结构的标记名，并使用typedef把Node作为struct node结构的类型名。
最后，为了管理链表，还需要一个指向链表开始处的指针，我们使用typedef
把List作为该类型的指针名。因此，下面的声明：
List movies;
创建了该链表所需类型的指针movies。
这是否是定义List类型的唯一方法？不是。例如，还可以添加一个变量
记录项数：
typedef struct list
{
Node * head; /* 指向链表头的指针 */
int size;   /* 链表中的项数 */
} List;      /* List的另一种定义 */
可以像稍后的程序示例中那样，添加第2 
个指针储存链表的末尾。现
1324
在，我们还是使用 List类型的第1种定义。这里要着重理解下面的声明创建
了一个链表，而不一个指向节点的指针或一个结构：