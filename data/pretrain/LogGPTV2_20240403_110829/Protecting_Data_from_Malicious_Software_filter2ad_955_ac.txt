### Text Optimization

**Original Text:**

As long as an administrator is not executing the malicious code, it will be unable to interfere with any kernel modifications that we make. Additionally, the use of a device driver provides us access to internal operating system functions and data structures not accessible from user mode.

In Windows NT, user applications invoke system services by executing an interrupt instruction. Code in the kernel takes control of the machine in response to the interrupt and performs some activity for the calling process before relinquishing control. A kernel entity known as the dispatcher initially responds to the interrupt request, determines the nature of the interrupt, and calls a function to handle the request. Two tables in kernel memory describe the locations and parameter requirements of all functions available to the dispatcher. One table specifies handlers for user requests; the other specifies handlers for requests originating within the kernel. The calling process places information about the requested system service on the stack along with any parameters required for completing the operation.

Our method of controlling file manipulation relies on our ability to instruct the dispatcher to call a function that we have written when a user process invokes certain system services. This approach requires constructing a device driver that is loaded into the kernel either dynamically or as part of the boot sequence. When our driver is loaded, it modifies an entry in the table that the dispatcher relies on for handling interrupt instructions. In our case, we are interested in intercepting calls to the `ZwCreateFile` function. The modification of the dispatcher’s table results in a call to our function instead of the intended call to `ZwCreateFile`. Our function will be called whenever a user-mode application tries to get a handle to a file. The signature of our function is identical to that of `ZwCreateFile`, so the kernel interface exported to applications is not altered.

Once the dispatcher calls our function, the FileMonster determines whether or not user confirmation will be required. If confirmation is not required, or if confirmation is granted, then we invoke the original `ZwCreateFile` with the same parameters as the calling process. If the user elects to deny the request, then we return a value indicating that the function call has failed and set our flags to indicate that access has been denied. The application will not be able to differentiate between a function failure produced by the FileMonster and a normally occurring error. It will handle this error the same way that it would handle an attempt to access a file by a user that does not have permission to do so. In some cases, this results in an application that attempted to open a file with read/write permission defaulting to trying to open it as a read-only file.

**Optimized Text:**

To ensure that malicious code does not interfere with our kernel modifications, it is crucial that an administrator does not execute such code. Additionally, using a device driver allows us to access internal operating system functions and data structures that are otherwise inaccessible from user mode.

In Windows NT, user applications invoke system services by executing an interrupt instruction. The kernel code takes control of the machine in response to the interrupt, performs the necessary activity for the calling process, and then relinquishes control. A kernel entity known as the dispatcher first responds to the interrupt request, determines the nature of the interrupt, and calls the appropriate function to handle the request. Two tables in kernel memory specify the locations and parameter requirements of all functions available to the dispatcher. One table lists handlers for user requests, while the other lists handlers for requests originating within the kernel. The calling process places information about the requested system service, along with any required parameters, on the stack.

Our method of controlling file manipulation involves instructing the dispatcher to call a function we have written when a user process invokes certain system services. This requires creating a device driver that can be loaded into the kernel either dynamically or during the boot sequence. Once our driver is loaded, it modifies an entry in the table that the dispatcher uses to handle interrupt instructions. Specifically, we intercept calls to the `ZwCreateFile` function. By modifying the dispatcher’s table, we ensure that our function is called instead of `ZwCreateFile` when a user-mode application attempts to get a handle to a file. Our function has the same signature as `ZwCreateFile`, ensuring that the kernel interface remains unchanged for applications.

When the dispatcher calls our function, the FileMonster checks whether user confirmation is required. If no confirmation is needed, or if the user grants confirmation, we call the original `ZwCreateFile` function with the same parameters as the calling process. If the user denies the request, we return a value indicating that the function call has failed and set our flags to indicate that access has been denied. The application cannot distinguish between a function failure caused by the FileMonster and a normal error. It will handle the error as it would for an unauthorized file access attempt. In some cases, this may cause an application that tried to open a file with read/write permissions to default to opening it as a read-only file.