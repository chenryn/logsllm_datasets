3、遍历计算n个类簇中心所在聚类中的所有元素，经过全局排序得到距离最近的k个向量。
• 说明
• 在查询类簇中心点时，会自动排除远离的类簇，加速查询过程，但是无法保证最优的前k个向量全部
在这n个类簇中，因此会有精度损失。您可以通过类簇个数n来控制IVFFlat算法的准确性，n值越大，
算法精度越高，但计算量会越大。
• IVFFlat和IVFADC[2]的第一阶段完全一样，主要区别是第二阶段计算。IVFADC通过积量化来避免遍历
计算，但是会导致精度损失，而IVFFlat是暴力计算，避免精度损失，并且计算量可控。
ivfflat索引参数介绍
hnsw 索引存储结构介绍
hnsw搜索介绍
• 算法流程说明：
• 1、构造多层图，每层图都是下层图的一个缩略，同时构成下层图的跳表，类似高速公路。
2、从顶层随机选中一个点开始查询。
3、第一次搜索其邻居点，把它们按距离目标的远近顺序存储在定长的动态列表中，以后每
一次查找，依次取出动态列表中的点，搜索其邻居点，再把这些新探索的邻居点插入动态
列表，每次插入动态列表需要重新排序，保留前k个。如果列表有变化则继续查找，不断迭
代直至达到稳态，然后以动态列表中的第一个点作为下一层的入口点，进入下一层。
循环执行第3步，直到进入最底层。
• 说明：
• HNSW算法是在NSW算法的单层构图的基础上构造多层图，在图中进行最近邻查找，可以
实现比聚类算法更高的查询加速比。
hnsw索引参数介绍
例子
创建测试表
create table if not exists t_pase_80(
id serial PRIMARY KEY,
vec float4[]
);
创建生成随机float4数组的函数
create or replace function gen_float4_arr(int,int) returns float4[] as $$
select array_agg(trunc(random()*$1)::float4) from generate_series(1,$2);
$$ language sql strict volatile;
例子
写入100万随机80维向量，
insert into t_pase_80 (vec) select gen_float4_arr(10000,80) from generate_series(1,1000000);
创建ivfflat索引。
CREATE INDEX idx_t_pase_80_2 ON t_pase_80
USING
pase_ivfflat(vec)
WITH
(clustering_type = 1, distance_type = 0, dimension = 80, clustering_params = "100,1001");
采样记录数：100万记录乘以100/1000=10万。 中心点：生成1001个中心点
NOTICE: vector dimension is huge, parameter (clustering_sample_ratio) should be set to ensure the clustering count
lower than 983040
NOTICE: parse clustering parameters succeed, clustering_sample_ratio[100], k[1001]
例子
查询一条真实记录，略微修改几个维度
select * from t_pase_80 limit 1;
使用ivfflat索引查询（）
SELECT id,
vec 
'1841,9512,8870,4345,3829,9005,738,2568,2564,6642,2455,7807,1666,4880,9195,6239,788,2804,301,6808,8182,1271,9446,1324,7230,78
68,3294,9092,4189,6227,2400,6029,5739,1271,375,9568,277,1114,2137,2841,7756,4593,649,9422,9473,9844,5662,262,2650,5964,7071,8
31,7235,6518,2156,4466,4386,5450,3558,8576,1677,5959,4606,7417,7230,4981,6985,7508,6095,9123,349,3852,3716,998,3275,3190,843,
8938,3462,3499:0:0'::pase as distance
FROM t_pase_80
ORDER BY
vec 
'1841,9512,8870,4345,3829,9005,738,2568,2564,6642,2455,7807,1666,4880,9195,6239,788,2804,301,6808,8182,1271,9446,1324,7230,78
68,3294,9092,4189,6227,2400,6029,5739,1271,375,9568,277,1114,2137,2841,7756,4593,649,9422,9473,9844,5662,262,2650,5964,7071,8
31,7235,6518,2156,4466,4386,5450,3558,8576,1677,5959,4606,7417,7230,4981,6985,7508,6095,9123,349,3852,3716,998,3275,3190,843,
8938,3462,3499:0:0'::pase
LIMIT 10;
例子
id | distance
--------+-------------
1 | 139
620286 | 6.78452e+08
365838 | 1.62702e+09
365885 | 1.667e+09
988412 | 1.57742e+09
17530 | 1.58652e+09
821096 | 1.57582e+09
820902 | 1.57803e+09
128421 | 1.57324e+09
127295 | 1.80574e+09
(10 rows)
Time: 4.523 ms
目录
• CUBE
• IMGSMLR
• PASE
• 应用场景介绍
多维向量搜索应用场景
• 图像识别、人脸识别、以图搜图
• 精准广告营销系统：相似向量人群扩选、
• 精准广告营销系统：圈选向量取值范围人群
参考资料
• 案例
• MySQL手册
• https://www.mysqltutorial.org/
• https://dev.mysql.com/doc/refman/8.0/en/
• PG 管理、开发规范
• https://github.com/digoal/blog/blob/master/201609/20160926_01.md
• PG手册
• https://www.postgresql.org/docs/current/index.html
• https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-vs-mysql/
• GIS手册
• http://postgis.net/docs/manual-3.0/
一期开课计划(PG+MySQL联合方案)
• - 2019.12.30 19:30 RDS PG产品概览，如何与MySQL结合使用
• - 2019.12.31 19:30 如何连接PG，GUI，CLI的使用
• - 2020.1.3 19:30 如何压测PG数据库、如何瞬间构造海量测试数据
• - 2020.1.6 19:30 MySQL与PG对比学习(面向开发者)
• - 2020.1.7 19:30 如何将MySQL数据同步到PG（DTS）
• - 2020.1.8 19:30 PG外部表妙用 - mysql_fdw, oss_fdw（直接读写MySQL数据、冷热分离）
• - 2020.1.9 19:30 PG应用场景介绍 - 并行计算，实时分析
• - 2020.1.10 19:30 PG应用场景介绍 - GIS
• - 2020.1.13 19:30 PG应用场景介绍 - 用户画像、实时营销系统
• - 2020.1.14 19:30 PG应用场景介绍 - 多维搜索
• - 2020.1.15 19:30 PG应用场景介绍 - 向量计算、图像搜索
• - 2020.1.16 19:30 PG应用场景介绍 - 全文检索、模糊查询
• - 2020.1.17 19:30 PG 数据分析语法介绍
• - 2020.1.18 19:30 PG 更多功能了解：扩展语法、索引、类型、存储过程与函数。如何加入PG技术社群
本课程习题
• 多维向量如何表达？内部使用什么存储？
• 多维向量支持哪几种索引？
• 多维向量支持哪几种距离计算方法？
• 多维向量广泛应用于哪些场景？
• 1000万的多维向量，任意召回最相似的1000条大概需要多久？
技术社群
PG技术交流钉钉群(3600+人)