### 优化后的文本

#### 3. 遍历计算类簇中心及其聚类中的所有元素
- **说明**：
  - 在查询类簇中心点时，会自动排除远离的类簇以加速查询过程。然而，这可能会导致无法保证最优的前k个向量全部位于这些n个类簇中，从而引起一定的精度损失。您可以通过调整类簇数量n来控制IVFFlat算法的准确性：n值越大，算法精度越高，但相应的计算量也会增加。
  - IVFFlat与IVFADC在第一阶段操作相同，主要区别在于第二阶段的处理方式。IVFADC通过积量化避免了遍历计算，但这会导致一定程度的精度损失；而IVFFlat采用暴力计算方法，确保了更高的精度，并且其计算量是可控的。

#### IVFFlat索引参数介绍
- **HNSW索引存储结构及搜索介绍**：
  - **算法流程**：
    1. 构建多层图结构，每一层都是下一层的一个简化版本，并作为下一层的跳表（类似于高速公路）。
    2. 从顶层随机选取一个节点开始进行查询。
    3. 对于每一次查询，首先搜索该节点的邻居节点，并按距离远近将它们存储在一个固定长度的动态列表中。之后每次查找时，依次取出列表中的节点，继续搜索其邻居节点，并将新发现的邻居节点插入到列表中。每次插入后都需要重新排序列表，只保留距离最近的前k个节点。如果列表发生变化，则继续迭代直至达到稳定状态。随后，以列表中的第一个节点作为入口点进入下一层，重复上述步骤直到到达最底层。
  - **说明**：HNSW算法基于单层NSW构图的基础上构建多层图结构，在图中执行最近邻查找，相比传统的聚类算法能够实现更高效的查询加速比。

#### HNSW索引参数介绍
- **示例**：
  - 创建测试表：
    ```sql
    CREATE TABLE IF NOT EXISTS t_pase_80 (
      id SERIAL PRIMARY KEY,
      vec FLOAT4[]
    );
    ```
  - 定义生成随机FLOAT4数组的函数：
    ```sql
    CREATE OR REPLACE FUNCTION gen_float4_arr(int, int) RETURNS FLOAT4[] AS $$
    SELECT ARRAY_AGG(TRUNC(RANDOM()*$1)::FLOAT4) FROM GENERATE_SERIES(1, $2);
    $$ LANGUAGE SQL STRICT VOLATILE;
    ```
  - 插入100万个80维随机向量：
    ```sql
    INSERT INTO t_pase_80 (vec) SELECT GEN_FLOAT4_ARR(10000, 80) FROM GENERATE_SERIES(1, 1000000);
    ```
  - 创建IVFFlat索引：
    ```sql
    CREATE INDEX idx_t_pase_80_2 ON t_pase_80
    USING pase_ivfflat(vec)
    WITH (clustering_type = 1, distance_type = 0, dimension = 80, clustering_params = '100,1001');
    ```
  - 参数解释：采样记录数为100万条乘以100/1000=10万条。生成1001个中心点。
  - 查询一条真实记录并稍微修改几个维度：
    ```sql
    SELECT * FROM t_pase_80 LIMIT 1;
    ```
  - 使用IVFFlat索引进行查询：
    ```sql
    SELECT id, 
           vec <-> '1841,9512,8870,4345,3829,9005,738,2568,2564,6642,2455,7807,1666,4880,9195,6239,788,2804,301,6808,8182,1271,9446,1324,7230,7868,3294,9092,4189,6227,2400,6029,5739,1271,375,9568,277,1114,2137,2841,7756,4593,649,9422,9473,9844,5662,262,2650,5964,7071,831,7235,6518,2156,4466,4386,5450,3558,8576,1677,5959,4606,7417,7230,4981,6985,7508,6095,9123,349,3852,3716,998,3275,3190,843,8938,3462,3499:0:0'::pase AS distance
    FROM t_pase_80
    ORDER BY vec <-> '1841,9512,8870,4345,3829,9005,738,2568,2564,6642,2455,7807,1666,4880,9195,6239,788,2804,301,6808,8182,1271,9446,1324,7230,7868,3294,9092,4189,6227,2400,6029,5739,1271,375,9568,277,1114,2137,2841,7756,4593,649,9422,9473,9844,5662,262,2650,5964,7071,831,7235,6518,2156,4466,4386,5450,3558,8576,1677,5959,4606,7417,7230,4981,6985,7508,6095,9123,349,3852,3716,998,3275,3190,843,8938,3462,3499:0:0'::pase
    LIMIT 10;
    ```

#### 应用场景介绍
- 多维向量搜索应用场景：
  - 图像识别、人脸识别、以图搜图
  - 精准广告营销系统：相似向量人群扩选、圈选向量取值范围人群

#### 参考资料
- 案例
- MySQL手册：[MySQL Tutorial](https://www.mysqltutorial.org/)
- PostgreSQL文档：[PostgreSQL Documentation](https://www.postgresql.org/docs/current/index.html)
- GIS手册：[PostGIS Manual](http://postgis.net/docs/manual-3.0/)

#### 一期开课计划 (PG+MySQL联合方案)
- 2019.12.30 19:30 RDS PG产品概览，如何与MySQL结合使用
- 2019.12.31 19:30 如何连接PG，GUI和CLI的使用
- 2020.1.3 19:30 如何压测PG数据库、如何瞬间构造海量测试数据
- 2020.1.6 19:30 MySQL与PG对比学习（面向开发者）
- 2020.1.7 19:30 如何将MySQL数据同步到PG（DTS）
- 2020.1.8 19:30 PG外部表妙用 - mysql_fdw, oss_fdw（直接读写MySQL数据、冷热分离）
- 2020.1.9 19:30 PG应用场景介绍 - 并行计算，实时分析
- 2020.1.10 19:30 PG应用场景介绍 - GIS
- 2020.1.13 19:30 PG应用场景介绍 - 用户画像、实时营销系统
- 2020.1.14 19:30 PG应用场景介绍 - 多维搜索
- 2020.1.15 19:30 PG应用场景介绍 - 向量计算、图像搜索
- 2020.1.16 19:30 PG应用场景介绍 - 全文检索、模糊查询
- 2020.1.17 19:30 PG数据分析语法介绍
- 2020.1.18 19:30 PG更多功能了解：扩展语法、索引、类型、存储过程与函数。如何加入PG技术社群

#### 本课程习题
- 多维向量如何表达？内部使用什么存储？
- 多维向量支持哪几种索引？
- 多维向量支持哪几种距离计算方法？
- 多维向量广泛应用于哪些场景？
- 1000万的多维向量，任意召回最相似的1000条大概需要多久？

#### 技术社群
- PG技术交流钉钉群 (3600+人)