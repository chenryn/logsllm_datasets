OrderedList()：创建一个新的空有序列表。它返回一个空有序列表并且不需要传递任何参数。
add(item):在保持原有顺序的情况下向列表中添加一个新的元素，新的元素作为参数传递进函数
而函数无返回值。假设列表中原先并不存在这个元素。
remove(item):从列表中删除某个元素。欲删除的元素作为参数，并且会修改原列表。假设原列表
中存在欲删除的元素。
search(item)：在列表中搜索某个元素，被搜索元素作为参数，返回一个布尔值。
isEmpty()：测试列表是否为空，不需要输入参数并且其返回一个布尔值。
size()：返回列表中元素的数量。不需要参数，返回一个整数。
index(item)：返回元素在列表中的位置。需要被搜索的元素作为参数输入，返回此元素的索引
值。假设这个元素在列表中。
pop()：删除并返回列表中的最后一项。不需要参数，返回删除的元素。假设列表中至少有一个
元素。
pop(pos)：删除并返回索引pos指定项。需要被删除元素的索引值作为参数，并且返回这个元
素。假设该元素在列表中。
3.6.4. 实现有序列表
为了实现有序列表，我们必须记住，元素的相对位置取决于某种已经定义了的属性。前文给出
的整数有序列表(54，17，26，31，77，93)可以表示为一个如图3.23所示的链结构。再次看到，节
点和链表结构是示意元素相对位置的理想工具。
图3.23 有序的链表
为了实现OrderedList类,我们将使用在无序列表中使用过的方法。再一次，一个指向None的头
指针将表示一个空的列表。（见代码8）
class OrderedList:
def __init__(self):
self.head = None
代码8
当我们考虑有序列表的方法时,我们应该注意到,isEmpty和size方法的实现和无序列表相同，因
为它们只处理列表中节点的数量而不考虑节点实际的值。同样，remove方法也不需要改动,因为我们
仍然需要找到某个节点然后删除它。但剩下的两个方法：search和add需要一些修改。
为了在一个无序列表中搜索某个节点，我们需要遍历节点直到找到它或者遍历完整个列表
（None）。事实证明，当要搜索的元素在列表中时，可以在有序列表中使用与无序列表中相同的方
法，但当我们要找的元素不在列表中时，我们可以利用有序列表的顺序来尽快结束搜索。
例如,图3.24显示了在有序链表中搜索值45的过程：我们从列表的头开始遍历，首先我们和17
进行比较，因为17不是我们要找的项，我们移动到下一个节点。此时，26依然不是我们要找的，所
以我们接着移动到31，再到54。现在，有序列表将和无序列表有所不同。由于54 不是我们要找的
项，在之前我们会接着移向下一个节点，但现在，由于列表是有序的，我们不必这么做，因为这是
没有必要的。一旦当前节点的值大于我们要找的值，我们就可以停止搜索并返回False，因为这个值
不可能在这个链表中了。
图3.24
代码9显示了完整的搜索方法。通过添加另一个名为stop，初始化为False的布尔变量（第4
行），我们可以很容易的应用于新的情况。当stop的值为False（不停止）时，我们继续在链表中搜
索（第5行）；如果发现任何节点包含的数据大于我们正在需找的值，我们将stop设True（9-10
行）。剩余的操作和无序表一完全相同。
代码9
def search(self, item):
current = self.head
found = False
stop = False
while current != None and not found and not stop:
if current.get_data() == item:
found = True
else:
if current.get_data() > item:
stop = True
else:
current = current.get_next()
return found
改动最大的方法是add。回想一下在无序列表中的add方法，只需要在原列表头加一个新的节
点。这是最简单的方法。不幸的是，这在有序列表中是行不通的。在有序列表中，我们必须将新的
节点添加到原列表某个特定的位置。
假设我们的有序列表中已有：17，26，54，77和93，我们想添加值31，则add方法必须在26
和54之间添加这个新的节点。图17显示了具体做法。正如前面解释的，我们需要遍历链表来寻找
添加新节点的位置。遍历时，当我们遍历完了整个列或者当前节点的值大于我们要添加的值时，我
们就找到了添加新节点的位置。在我们的例子中，找到了值54就停止遍历。
图3.25 向有序链表添加元素
def add(self, item):
current = self.head
previous = None
stop = False
while current != None and not stop:
if current.get_data() > item:
stop = True
else:
previous = current
current = current.get_next()
temp = Node(item)
if previous == None:
temp.set_next(self.head)
self.head = temp
else:
temp.set_next(current)
previous.set_next(temp)
代码10
正如我们在使用无序列表时，需要有一个额外的指针，即previous，因为当前节点不提供对需要修改
的节点（前一个节点）的访问方法。代码10显示了完整的add方法。行2 -3设置指针current和
previous。当current依次遍历整个列表时，行9-10每次都让previous指针指向current当前的节
点。行5的条件只允许current 移向值比要添加的值大的节点，或者遍历完整个列表再添加。在这两
种情况中，我们找到了添加新节点的位置，循环结束。该方法其余的步骤完成了最后的两步过程，
如图3.25所示。当一个新的节点被创建后，唯一剩下的问题是这个节点是应该添加在链表开头还是
添加在链表中间。再一次，判断previous是否为None（行13）可以提供答案。
OrderedList类和迄今为止已经讨论了的方法可以在ActiveCode 1中找到。其余方法留作练习。
当使用有序列表的时候，你应该仔细考虑无序的实现能否使用的问题。
3.6.5. 链表实现算法分析
链表的分析：
当分析链表方法的复杂度时，我们应该考虑它们是否需要遍历链表。考虑一个有n个节点的链
表，isEmpty方法复杂度是O（1），因为它只需要检查链表的头指针是否为None。对于方法size，
则总需要n个步骤，因为除了遍历整个链表以外，没有办法知道链表的节点数。因此，size方法的复
杂度是O（n）。无序列表的add 方法的复杂度是O（1），因为我们永远只需要在链表的头部简单
地添加一个新的节点。但是，search、remove 和在有序列表中的add 方法，需要遍历。尽管在平均
情况下，它们可能只需要遍历一半的节点，但这些方法的复杂度都是O(n)，因为在最糟糕的情况下
需要遍历整个链表。
你可能还注意到，这些方法的实现性能与Python的内置列表list不同，这表明Python中的list
不是这么实现的。实际上，Python 中的列表的实现是基于数组的，我们将在另一章详细讨论。
3.7.小结
线性数据结构以有序的方式维持它们的数据。
栈（Stack）是具有后进先出（LIFO）特性的有序的简单数据结构。
栈（Stack）的基本操作是push，pop和isEmpty。
队列（Queue）是具有先进先出（FIFO）特性的有序的简单数据结构。
队列（Queue）的基本操作是enqueue,dequeue 和isEmpty。
前缀表达式，中缀表达式和后缀表达式都是书写表达式的方式。
栈（Stacks）对于设计算法并求值以及转化表达式非常有效。
栈（Stacks）具有反转的特性。
队列（Queue）可以帮助构建时序仿真。
模拟实验使用随机数生成器来创建一个真实的环境从而使我们回答“假设”类型的问题。
双端队列（Deque）是允许像栈和队列一样的混合行为的数据结构。
双端队列（Deque）的基本操作是addFront, addRear, removeFront, removeRear和isEmpty。
列表（List）是具有相对位置的元素的集合。
链表的实现保持逻辑顺序而不要求数据项依次存放在连续的存储空间。
对链表表头的修改是一种特殊情况。
3.8.关键词（按：依英文原词的词典顺序排列）
匹配括号 数据区 双端队列
先进先出（FIFO） 全括号 表头
中缀 后进先出（LIFO） 线性数据结构
链表 链表遍历 列表
节点 回文序列 后缀
优先级 前缀 队列
模拟实验 栈
表3.4
3.9.问题讨论
1．将下列值通过“除以二”转化为二进制。写出余数的栈。
a) 17
b) 45
c) 96
2．将下列中缀表达式转化为前缀表达式（使用全括号的方法）：
a) (A+B)*(C+D)*(E+F)
b) A+((B+C)*(D+E))
c) A*B*C*D+E+F
3．将上述的中缀表达式转化为后缀表达式（使用全括号的方法）。
4．采用直接的转化算法将上述的中缀表达式转化为后缀表达式。写出转化时栈
的实时变化。
5．计算下列后缀表达式的值。写出当每个操作数和操作符被处理时栈的实时变
化。
a) 2 3 * 4 +
b) 1 2 + 3 + 4 + 5 +
c) 1 2 3 4 5 * + * +
6．队列（Queue）的一种替换实现是使用一个列表使队列的尾在列表的末端。
这样的替换操作会对其大O数量级产生什么样的影响？
7．在链表中，使用add方法时执行顺序相反的结果是什么？参考结果是什么？
可能会什么样的问题？
8．解释当数据项在最后一个节点时链表的remove方法如何实现。
9．解释当数据项是链表中唯一一个节点时链表的remove功能如何实现。
3.10.编程练习
1．修改中缀表达式转为后缀表达式的算法使之能处理错误输入。
2．修改后缀表达式求值的算法使之能处理错误输入。
3．实现一个结合了中缀到后缀的转化法和后缀的求值算法的直接求中缀表达式值的方法。你的
求值法应该从左至右处理中缀表达式中的符号，并且使用两个栈来完成求值，一个存储操作数，一
个存储操作符。
4．将上一题的中缀求值法转化为一个计算器。
5．实现一个Queue，使用一个list使Queue的尾部在list的末端。
6．设计并实现一个实验，对以上两种Queue进行基准比较。你从这个实验中学到了什么？
7．实现一个队列并使它的enqueue和dequeue方法平均时间复杂度都是O(1)。也就是说，在
大多数情况下enqueue和dequeue都是O（1），除了在一种特殊情况下dequeue可能为O（n）。
8. 考虑一个现实生活中的情况。制定一个问题，然后设计一个可以帮助解决问题的模拟实验。
可能的情况包括：
a）洗车店一字排开的汽车
b）在杂货店结账的顾客
C）在跑道起飞、降落的飞机
d）一个银行柜员
一定要解释清楚做的任何假设，并且提供该方案必须包含的和概率有关的数据。
9．修改热土豆模拟实验，采用一个随机选择的数值，使每轮实验不能通过前一
次实验来预测。
10．实现基数排序。十进制的基数排序是一个使用了“箱的集合”（包括一个主箱和10 个数字
箱）的机械分选技术。每个箱像队列（Queue）一样，根据数据项的到达顺序排好并保持它们的值。
算法开始时，将每一个待排序数值放入主箱中。然后对每一个数值进行逐位的分析。每个从主箱最
前端取出的数值，将根据其相应位上的数字放在对应的数字箱中。比如，考虑个位数字，534被放置
在数字箱4，667被放置在数字箱7。一旦所有的数值都被放置在相应的数字箱中，所有数值都按照
从箱0到箱9的顺序，依次被取出，重新排入主箱中。该过程继续考虑十位数字，百位数字，等
等。当最后一位被处理完后，主箱中就包含了排好序的数值。
11．括号匹配问题的另一个例子是超文本标记语言（HTML）。在HTML 中，标记以开始
（opening tag，）和结束（closing tag，）的形式存在，它们必须成对出现来正确地描
述web文档。这个非常简单的HTML文档：
只是为了表明语言中标记的匹配和嵌套结构。写一个程序，它可以检查HTML文档中是否有匹
配的开始和结束标记。
Example
Hello, world