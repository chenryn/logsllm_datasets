等于p（all)
\p(Assigned)
等于\P(Cn）
等于\P（Cn）
等于\P（Cn}
√\p(Unassigned)
√
等于\p（Cn}
等于\p（Cn）
等于\p（Cn）
以V开头的行是新实现方式中推荐的用法（请参考第91页的版本信息）
简单的字符组减法：[[a-z]-[aeiou]]
匹配的字符就是[a-z]能够匹配字符的减去[aeiou]能够匹配的字符，也就是ASCII编
码中小写的非元音字母。
另一个例子是[\p（P}-【\p（Ps）\p{Pe）]]，它能够匹配\p（P}中除[\p（Ps）\p（Pe）]之外
的字符，也就是说，它能匹配除了》和（之类成对的符号之外的所有标点符号。
完整的字符组集合运算：[[a-z]&&[^aeiou]]
Sun的Javaregexpackage中的字符组能够进行完整的集合运算（并、减、交）。它的语法有
别于前一节中简单的字符组减法（尤其是，在Java中匹配小写非元音字母的字符组【[a-z]&&
[^aeiou]1）。在详细介绍减法之前，我们先来看两个简单的集合运算：OR和AND。
OR容许用户以字符组方式在字符组中添加字符：[abcxyz]也可以表示为[[abc][xyz]]、
[abc[xyz]]或【[abc]xyz]等等。OR用来把多个集合合并为新的集合。从概念上说，它
---
## Page 152
126
第3章：正则表达式的特性和流派概览
种简记法，尽管包括排除型字符组在某些情况下更方便。
在两个字符组中添加特殊的字符组元字符&&。例如（\p（InThai）&&\P(Cn）]，它通过对
p（InThai）和\P（Cn）进行交运算（只保留同时属于两个集合的字符），匹配Thai区块中所
有已经赋值的代码点。\P（…}中的‘P’是大写，匹配不具备此属性的字符，所以\P（Cn）
匹配的就是除未赋值的代码点之外的代码点，也就是已经赋值的代码点（要是Sun能够识
别已赋值属性（Assignedquality），就可以用\p（Assigned）替换\P（Cn））。
请不要混淆oR和AND。它们的含义取决于用户的看法。例如[[this][that]]读作“[this]
或者[that]匹配的字符”，其实它的真正意思是“[this]和[that]能够匹配的所有字符”，
这只是对同一个问题的两种看法。
相比之下，AND要清楚一些：[\p（InThai）&&\P（Cn）1读作“只匹配在\p（InThai）和\P(Cn）
中出现的字符”，尽管它有时候也读作“匹配属于\p{InThai）和\P(Cn)的交集中的字符。”
看法的不同可能会造成混乱：我叫做OR和AND的运算，某些人可能叫做AND和
INTERSECTION。
以集合运算符进行字符组的减法\P(Cn）可以写作[^\p（Cn)]，所以在匹配“Thaiblock中
已经赋值的字符”时，[\p（InThai}&&\P（Cn）]也可以写作[\p（InThai）&&[^\p{Cn}]]。
这样的改变并没有多少意义，只是它有助于说明一个通用的模式：“Thaiblock中已赋值字
符”比“所有Thaiblock中的字符，减去未赋值的字符”更好理解，于是我们知道
[p(InThai）&&[\p（Cn]]]表示“p（InThai）减去p(Cn）”。
这样就回到了本节开头[[a-z]&&[^aeiou]]的例子，现在我们知道如何进行字符组的减
法了。其模式为：[this&&[^thar]]表示“[this]减去[thar]”。我发现用&&和[~…]进行双重
否定很难记忆，所以记住模式&&[…]]就够了。
通过环视功能模拟字符组的集合运算如果所使用的程序不支持字符组集合运算，但支持环
---
## Page 153
常用的元字符和特性
127
写成（?!p(Cn)）p（InThai)（注13)。尽管它并不如内建的集合运算有效率，环视仍然
是非常方便的做法。这个例子可以用4种不同的方式来实现（在.NET中需要以IsThai替
换InThai125）。
(?!\p(Cn))\p(InThai)
(?=\P{Cn})\p(InThai}
p(InThai)(?<!\p(Cn})
p(InThai)(?<=\P(Cn))
POSIX“字符组”方括号表示法
我们通常所说的字符组，在POSIX标准中称为方括号表达式（bracketexpression）。POSIX
feature），而我们可以认为它们是Unicode的字符属性的原型。
POSIX字符组是POSIX方括号表达式使用的几种特殊元字符序列之一。比如I：1ower：1表
示当前locale（o87）中的所有小写字母。对英文文本来说，（：lower：等于a-z。因为整
个序列只有在方括号表达式内才是有效的，所以对应的完整的字符组应该是【（：1ower：1]。
这种表示法的确很难看。但是，它比（a-z]更好用，因为它能包含6，之类当前locale
中定义的“小写字母”。
POSIX字符组的详细列表根据locale的变化而变化，但是下面这些通常都能支持：
[:alnum：]字母字符和数字字符。
[:alpha：]字母。
[：blank：]空格和制表符。
[:cntrl：]控制字符。
[:digit：]数字。
[:graph:]
非空字符（即空白字符，控制字符之外的字符）。
[:lower:]
小写字母。
[:print：]
类似[：graph：1，但是包含空白字符。
[:punct：]标点符号。
[:space：]所有的空白符（[：blank：]、换行符、回车符及其他）。
[:upper：]大写字母。
[：xdigit：）十六进制中容许出现的数字（例如0-9a-fA-F)。
注13：实际上，在Perl中，这个例子可能可以写作\p（Thai）s，因为在Perl中\p（Thai）表是
李毒表，它包含未赋值的代码点。Thai字母表和区块之前的其他差异很小。如果要确定
某个字母表或者区块实际包含了哪些字符，最好的办法还是参考文档。在这里，宇母表
其实少了一些区块中包含的特殊宇符。请参考http://unicode.org获得所有细节。
注14：一般来说，本书中的“字符组（characterclass）”和“POSIX括号表达式（POSIXbracket
expression）”是指的同一种结构，而“POSIX字符组”指的是下面介绍的特殊的类似范
围表示法的字符组特性。
111
---
## Page 154
128
第3章：正则表达式的特性和流派概览
支持Unicode属性（121）的系统可能会在Unicode支持中加人这些POSIX结构。Unicode
属性结构更为强大，所以如果可能，这些结构应该有提供。
POSIX“collating序列”方括号表示法：【[.span-11.]]
Local可以包含对应的collating序列，用来决定其中的字符如何排序。例如，在西班牙语中，
）
日尔曼语字母&位于s和t中间，但是排序时类似它等价于两个字母SS。这些规则可能用
collating序列命名来表示，例如，span-11和eszet。
collating序列会把多个实体字符映射到单个逻辑字符，在span-11的例子中，11被视为“--
个字符”，来保持与POSIX正则引擎的兼容。也就是说，[^abc]能够匹配“11’两个字母。
collating序列的元素可以包含在方括号表达式中，使用【..]表示法：torti[[，
span-11.11ai匹配tortilla。单个collating序列可以匹配组合而成的字符。此种情况下，
方括号表达式可以匹配多个实体字符。
POSIX“字符等价类”方括号表示法：【[=n=】]
有的locale定义了字符等价类，表示某些字符在进行排序之类的操作时应视为等价。例如，
某locale可能定义了这样个等价类“n'，包含n和，或者是另一个等价类a，包含a
和a。等价类的表示法类似（：：]，但是用等号取代冒号，我们可以在方括号表达式中引
用这些等价类：[（=n=][=a=]]能够匹配刚才出现的任意一个字符。
如果一个字符等价类的名称只包含一个字母，但没有在locale中定义，则它默认就等于同样
名字的collating序列。local通常包含作为collating序列的普通字符[.a.）、【.b.]、（.c.]
之类如果没有定义特殊的等价类，[[=n=][=a=]]就等于[na]。
Emacs语法类
GNUEmacs不支持传统的w、si之类；相反，它使用特殊的序列来引I用“语法类（syntax
classes)":
Aschar匹配Emacs语法类中char描述的字符。
Aschar匹配不在Emacs语法类中的字符。
---
## Page 155
常用的元字符和特性
129
“\sw匹配“构成单词（wordconstituent）”的字符，而s-i匹配“空白字符”。在其他系统
中，它们分别写作w和sl。
Emacs的特殊之处在于，在Emacs中，这些字符组包含的字符是可以临时更换的，所以，
构成单词的字符组中的字符可以根据所编辑文本的变化而变化。
锚点及其他“零长度断言”
Anchors and Other"Zero-Width Assertions“
锚点和其他“零长度断言”并不会匹配实际的文本，而是寻找文本中的位置。
行/字符串的起始位置：^、\A
脱字符匹配需要搜索的文本的起始位置，如果使用了增强的行锚点匹配模式（112)，
它还能匹配每个换行符之后的位置。在某些系统中，增强模式下还能匹配Unicode的行
终结符（109)。
如果可以使用，则无论在什么匹配模式下，A总是能够匹配待搜索文本的起始位置。
行/字符串的结束位置：$、\z和\z
从下一页的表格3-11可以看出，“行结束位置（endofline)”的概念比行开头位置要复杂。
在不同的工具软件中，$：的意义也不同，不过最常见的意思是匹配目标字符串的末尾，也
可以匹配整个字符串末尾的换行符之前的位置。后一种情况更为常见，它容许sS（匹配“以
s结尾的行”）来匹配‘…"s”，即以s和换行符结尾的行。
s:的另两种常见的意思是，只匹配目标文本的结束位置，或是匹配任何一个换行符之前的
位置。在某些Unicode系统中，这些规则中的换行符会被替换为Unicode的行终结符（109）
(Java为了处理Unicode的行终结符，为'si设定了非常复杂的语意370)。
匹配模式（112）可以改变‘s：的意义，匹配字符串中的任何换行符（或者是Unicode中的
行终结符）。
如果支持，Z通常表示“未指定任何模式下”‘$匹配的字符，通常是字符串的末尾位置，
或者是在字符串末尾的换行符之前的位置。作为补充，z只匹配字符串的末尾，而不考虑
任何换行符。表3-11中列出了少数例外。
---
## Page 156
130
第3章：正则表达式的特性和流派概览
表3-11：脚本语言中的行锚点
条目
Java
Perl
PHP
Python
Ruby
Tcl
.NET
正常情况
匹配字符串起始位置
√
匹配任意换行符
2
S匹配字符串的结束位置
√
S匹配字符串结尾的换行符
S匹配任何换行符
2
提供增强型行锚点模式（112）
√
√
√
在增强型行锚点模式中
匹配宇符串的起始位置
N/A
匹配任何换行符之后的位置
N/A
S匹配字符串的末尾
N/A
S匹配任何换行符之前的位置
N/A
\A总是与普通的一样
√.
√
\Z总是与普通的S一样
's
2总是匹配字符串的末尾
N/A
N/A
√
注：
在这些情况下，Sun的Javaregexpackage支持Unicode的行终结符（109）。
Ruby的S和^能匹配字符串中的换行符，但是\A和\Z则不能。
Python的\Z只能匹配字符串的结束位置。
Ruby的\A与^不同，只能匹配字符串的起始位置。
Ruby的\Z与S不同，可以匹配字符串的结尾位置，或是字符串结尾的换行符之前的位置。
（请参考第91页的版本信息）
匹配的起始位置（或者是上一次匹配的结束位置）：\G
“Gi首先出现在Perl中。在使用/g（51）的匹配中，\G对选代操作非常有用，它能够匹
配上一次匹配结束的位置。在第一次选代时，G匹配字符串的开头，与A一样。
如果匹配不成功，八G的匹配会重新指向字符串的起始位置。这样，如果重复应用某个正则
表达式，例如进行Perl的s///gi操作，或者在其他语言中调用“找出所有匹配（match
all）”函数，在匹配失败的同时，G也会指向字符串的开头位置，这样以后进行其他类型
的匹配操作便不受影响。
根据我的观察，Perl的G有3个值得注意而且很有用的方面：
G的指向位置是每个目标字符串的属性，而不是设定这些位置的正则表达式的属性。
也就是说，多个正则表达式可以依次对同一个字符串进行匹配，都使用上一轮匹配设
定的G
---
## Page 157
常用的元字符和特性
131
·Perl的正则运算符有一个选项（Perl的/c修饰符315)，它规定了，如果匹配失败，
不要重新设定G，而只是保持之前的值不变化。如果结合上面那一点，就可以从某
个位置开始尝试用多个正则表达式进行匹配，直到匹配能够成功，然后在下面的文本
中继续寻找匹配。
改。可能有人希望设定这个位置来“规定”从什么位置开始寻找匹配，以及只从那个
位置开始的匹配。同样，如果语言支持本条功能，而没有直接提供上一条功能，我们
可以用本条功能来模拟。
下页的补充内容中有个例子展示了这些特性的用法。除了这些便捷之外，Perl的G还存在
一个问题，即它必须出现在正则表达式的开头，这样才能正常工作。不过幸运的是，这似
乎是最自然的用法。
之前匹配的结束位置，还是当前匹配的开始位置？
次匹配的结束位置”。在绝大多数情况下，这两者是等价的，所以大多数时候这个问题并不
要紧。但也有些不常见的情况下，它们是有区别的。215贡有个例子说明了这种情况，不过
最容易的还是用一个专门的例子来理解：把'x?应用到‘abcde”。这个表达式能够在“abcde”
匹配成功，但其实它没有匹配任何文本。在进行全局查找-替换时，正则表达式会重复应用，
每次处理上一次操作之后的文本，除非传动装置会做些特别的处理，“上次匹配完成的位置
总是它开始的位置。为了避免无穷循环，在这种情况下传动装置会强行前进到下一个字符
(148)，如果对‘abcde’应用s/x?/!/g，结果就是“！a!b!c!d!e！。
果是这样，问题就来了：\G匹配哪个位置呢？在Perl中，对‘abcde’应用s/\Gx?/!/g
得到！abcde，所以我们知道，在Perl中，\G只匹配上一次匹配的结束位置。如果传动