### Omega 共享调度工作原理Omega使用事务管理状态的设计思想，将集群中资源的使用和任务的调度类似于基于数据库中的一条条事务（Transaction）一样进行管理。显然，数据库是一个共享的状态，对应Omega 中的 CellState，而每个调度器都要根据数据库的信息（即集群的资源信息）去独立完成自己的任务调度策略。接下来，我们就具体看看吧。如下图所示，在一个应用执行的过程中，调度器会将一个 Job 中的所有 Task 与Resource 进行匹配，可以说 Task 与 Resource之间是进行多对多匹配的。其间，调度器会设置多个 Checkpoint 来检测Resource 是否都已经被占用，只有这个 Job 的所有 Task可以匹配到可用资源时，这个 Job 才可以被调度。这里的 Job 相当于一个事务，也就是说，当所有 Task匹配成功后，这个事务就会被成功 Commit，如果存在 Task匹配不到可用资源，那么这个事务需要执行回滚操作，Job 调度失败。![](Images/7bcf60cc112f79cc100c0df73946a47a.png){savepage-src="https://static001.geekbang.org/resource/image/ce/89/ce672cf357f29fceab9d64d9d768cc89.png"}无论事务是否执行成功，调度器都会在事务执行之后，重新从主本那里同步更新本地Cell State的资源状态副本，以保证本地集群信息状态的有效性。若事务未成功执行，则调度器会在必要时重新运行其调度算法并再次尝试申请资源。也就是说，调度器对 Job 的调度是具有原子性的，一个 Job 的所有 Task都是一起调度的，即使部分 Task调度失败了，调度器再次调度时也必须再次调度整个Job。多个调度器可以并行调度，无需等待其他调度器调度结果，若存在冲突时，进行冲突处理，比如根据Job 的优先级，优先级高则获得资源。由此我们可以看到，**Omega 涉及了 Job 并发调度**。针对这一点，Omega采用了传统数据库中的乐观锁（MVCC，Multi-Version ConcurrencyControl，基于多版本的并发访问控制），即每一个应用都发放了所有的可用资源，在更新集群状态时使用乐观并发控制来解决资源冲突问题，来提高Omega 的并发度。不同的 Omega调度器可以实现不同的策略，但有一些调度规则是所有调度器必须达成一致的，比如哪些资源是允许分配的、如何评估作业的优先级等。因此，**Omega调度器将两层调度器中的集中式资源调度模块简化成了一些持久化的共享数据（状态）和针对这些数据的验证代码**。而这里的"共享数据"，实际上就是整个集群的实时资源状态信息，而验证代码就是解决调度冲突的调度规则。
## 知识扩展：单体调度、两层调度和共享调度的区别是什么？现在，我已经带你学习了单体调度、双层调度和共享调度，那么这三种调度的区别是什么呢？接下来，我们就一起回忆并对比下吧。我把这三种调度的架构示意图放到一起，先帮你有一个整体认识。![](Images/f199edbcd4e311f366dbe99321d296d6.png){savepage-src="https://static001.geekbang.org/resource/image/e2/7d/e262616421b8a9437e5f0f183c0ae77d.png"}**单体调度**，是由一个中央调度器去管理整个集群的资源信息和任务调度，也就是说所有任务只能通过中央调度器进行调度。这种调度架构的优点是，中央调度器拥有整个集群的节点资源信息，可以实现全局最优调度。但它的缺点是，无调度并发性，且中央服务器存在单点瓶颈问题，导致支持的调度规模和服务类型受限，同时会限制集群的调度效率。因此，单体调度适用于小规模集群。**两层调度**，是将资源管理和任务调度分为两层来调度。其中，第一层调度器负责集群资源管理，并将可用资源发送给第二层调度；第二层调度接收到第一层调度发送的资源，进行任务调度。这种调度架构的优点是，避免了单体调度的单点瓶颈问题，可以支持更大的服务规模和更多的服务类型。但其缺点是，第二层调度器往往只对全局资源信息有部分可观察性，因此任务匹配算法无法实现全局最优。双层调度适用于中等规模集群。**共享状态调度**，多个调度器，每个调度器都可以看到集群的全局资源信息，并根据这些信息进行任务调度。相较于其他两个调度架构来说，共享状态调度架构适用的集群规模最大。这种调度架构的优点是，每个调度器都可以获取集群中的全局资源信息，因此任务匹配算法可以实现全局最优性。但，也因为每个调度器都可以在全局范围内进行任务匹配，所以多个调度器同时调度时，很可能会匹配到同一个节点，从而造成资源竞争和冲突。虽然 Omega的论文宣称可以通过乐观锁机制，避免冲突。但在工程实践中，如果没有妥善处理资源竞争的问题，则很可能会产生资源冲突，从而导致任务调度失败。这时，用户就需要对调度失败的任务进行处理，比如重新调度、任务调度状态维护等，从而进一步增加了任务调度操作的复杂度。我将单体调度、两层调度、共享状态调度总结在了一张表格中：![](Images/bf5c20bc0afe72e1b86064e29136204f.png){savepage-src="https://static001.geekbang.org/resource/image/84/1e/84553e72142841d5dc776c35e9c3f31e.jpg"}
## 总结今天，我主要与你分享了分布式调度架构设计中的共享状态调度。我们一起来总结下今天的核心知识点吧。首先，我讲述了什么是共享状态调度。概括地说，共享状态调度是将单体调度器分解为多个服务，由多个服务共享集群状态，包括资源状态和任务状态等。接下来，我以 Google 的 Omega集群管理系统为例，和你分享了共享状态调度的架构和工作原理。共享状态调度包含多个调度器，每个调度器都可以看到集群的全局资源信息，并根据这些信息进行任务调度。最后，我要和你说明的是，共享状态调度是乐观并发调度，调度器将其调度的结果以原子的方式提交给资源维护模块，由其决定是否进行本次调度。接下来，我整理一张思维导图来帮助你巩固今天的核心知识点。![](Images/32f46e13efcdd76715468ecde3960c98.png){savepage-src="https://static001.geekbang.org/resource/image/65/df/651b95130de61792b85d958fcc9c7cdf.png"}我想让你知道的是，在分布式领域中，共享状态调度，是 Google号称的下一代集群管理系统 Omega的调度机制，可以解决双层调度无法实现全局最优的问题，同时也避免了单体调度的单点瓶颈问题。但，说到这儿你可能会回想起曾经看到的两句话：1.  为了达到设计目标，Omega 的实现逻辑变得越来越复杂。 在原有的 Borg    共享状态模型已经能满足绝大部分需要的情况下，Omega    的前景似乎没有那么乐观。2.  Omega 系统缺点是，在小集群下没有优势。这里，我再与你解释下，为什么说 Omega 是 Google准备打造的下一代集群管理系统。从调度架构方面来看，Borg无法支持同时存在多种业务类型的场景，并且存在单点瓶颈问题。而 Omega解决了 Borg的这两个问题，但是当多个调度器并行调度时，可能存在资源冲突，当资源申请产生冲突时，会导致大量任务或任务多次调度失败，增加了任务调度失败的故障处理的复杂度，比如需要进行作业回滚、任务状态维护等。因此，设计一个好的冲突避免策略是共享状态调度的关键。对于小规模集群来说，其集群规模、任务数量等都不大，使用单体调度就可以满足其任务调度的需求，避免了考虑复杂的冲突避免策略。也就是说，共享状态调度比较适合大规模、同时存在多种业务类型的场景，不太适合小规模集群。
## 思考题共享状态调度的核心是解决并发冲突，那你认为有没有什么好的方法可以解决冲突呢？我是聂鹏程，感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再会！![](Images/c191f391e2aab7575517a886bbd7a681.png){savepage-src="https://static001.geekbang.org/resource/image/a4/8c/a42a16601611a1a72599ecfca434508c.jpg"}