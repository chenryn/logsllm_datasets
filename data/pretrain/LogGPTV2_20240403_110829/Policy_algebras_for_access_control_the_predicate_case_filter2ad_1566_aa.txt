title:Policy algebras for access control the predicate case
author:Duminda Wijesekera and
Sushil Jajodia
Policy Algebras for Access Control — The Predicate Case∗
Duminda Wijesekera
PI:EMAIL
Sushil Jajodia
PI:EMAIL
Center for Secure Information Systems
George Mason University
Fairfax, VA 22030–4444
ABSTRACT
This paper deals with the algebra used to compose access
control policies of collaborating organizations. To main-
tain a conceptual coherence and to have a common basis
for comparison, we seek a framework that can be viewed
at diﬀerent levels of abstraction. In [21, 22], we presented
a propositional version of the algebra that can support al-
gebraic manipulations of uninterpreted policies. This pa-
per extends the algebra to many sorted ﬁrst order predicate
case. The predicate version can be used to reason about
ﬁrst order properties of security policies from their compo-
nents. We show how to compose and reason about security
properties such as those used in role based access control
models usually speciﬁed using second order (set) quantiﬁers
in languages (see RCL2000 [1]). We also show how diﬀerent
application speciﬁc notions of consistency and completeness
can be formulated as sentences in our many sorted ﬁrst order
logic and propose a Hoare calculus to reason about them.
1.
INTRODUCTION
There has been a renewed interest in security policies and
their compositions during the last couple of years [6, 21,
22]. In [6], Bonatti et al. adopt a set-based approach in-
ﬂuenced by logic programming to propose a comprehensive
framework for composing access control policies.
In [21],
we extended their work adding more operators and allowing
non-determinism [21]. However, the work in [21] was lim-
iting in two ways. First, in [21], atomic policies were taken
to be axiomatic, thereby limiting their ability to witness the
eﬀects of diﬀerent kinds of realistic atomic constructs. Sec-
ond, the reasoning ability about compositions was restricted
to propositional logic, thereby diminishing the ability to dis-
tinguish between general properties satisﬁed by all subjects,
objects or access types and their speciﬁc instances. This
paper removes these limitations by extending [21] to many
sorted ﬁrst-order reasoning.
∗
This work was partially supported by the National Science
Foundation under grant CCR-0113515.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’02, November 17-21, 2002, Washington, DC, USA.
Copyright 2001 ACM 1-58113-385-5/01/0011 ...$5.00.
Categorized as discretionary, mandatory, or role based,
access control policy speciﬁcations are inﬂuenced by under-
lying models [8]. Considering these to be inﬂexible, ﬂexible
authorization models [12, 13] were introduced, where the
ﬂexibility comes from transferring model speciﬁc assump-
tions such as the closed world or the open world assump-
tions, to be speciﬁable by policies. That makes both con-
sistency and completeness application dependent deﬁnitions
respectively as the absence of over and under speciﬁcation.
We show how application speciﬁc notions of consistency and
completeness can be deﬁned as sentences in our many-sorted
ﬁrst order language, thereby facilitating the use of algebraic
identities to reason about them.
Another use of our algebra is its ability to provide ﬁrst-
order reasoning to role based access control (RBAC) poli-
cies. To a role corresponds a set of permissions assigned to
subjects, thereby subjects obtaining all permissions of the
role [18, 19].
In addition, an RBAC policy enforces con-
straints so that only those subject to role and role to per-
mission assignments that satisfy the stated constraints are
considered consistent. That makes the notions of consis-
tency and and completeness of RBAC policies also applica-
tion deﬁnable. RBAC policy speciﬁcation languages such
as RCL2000 [1] specify RBAC policies (therefore applica-
tion speciﬁc notions of consistency and completeness) using
a second-order quantiﬁers. We show that a carefully crafted
many sorted-ﬁrst order language such as ours is suﬃcient
to reason about known RBAC policies, and thereby avoid-
ing well-known problems of incompleteness associated with
full second order reasoning [9, 5]. Speciﬁcally, our notion of
structure given in Deﬁnition 7 shows that it is suﬃcient to
quantify over some but not all sets of permissions to specify
and reason about RBAC policies and their compositions.
When consistency and completeness become application
dependent and deﬁnable as sentences, Floyd-Hoare reason-
ing can be used to derive consistency and completeness of
compositions from their constituents. While our ongoing
research focuses in ﬁnding a fully-abstract and complete
Hoare logic for RBAC speciﬁcations, we show some con-
sistent Hoare style proof rules for some of our algebraic op-
erators.
The rest of the paper is organized as follows. Section 2
describes related work. Section 3 describes the syntax of our
policy algebra, and Section 4 describe the semantics of poli-
cies. Section 5 shows some example policies speciﬁable in
our algebra, and Section 6 addresses consistency and com-
pleteness. Section 7 contains preliminary work on a Hoare
logic for policy compositions, and Section 8 has our conclud-
171ing comments.
2. RELATED WORK
To the best of our knowledge, McLean ﬁrst suggested us-
ing the notion of algebraic (set theoretic) constructs for com-
posing access and information ﬂow control policies [15, 16,
17]. He referred to non-determinism as possibilistic seman-
tics and the sequencing operator as the cascading operator.
Bai and Varadarajan [4] present another logic based model
for access control policies. They model a given state of a se-
curity policy as a collection (C, M ) where C is a ﬁnite set
of ﬁrst order formulas over language consisting of ground
atoms and M is a Herbrand interpretation. They view C as
the non-changeable part of the policy and M as changeable
facts. Their deﬁnition of transformation, syntactically given
as [P re(tran) | P ost(tran)], where P re(tran){h1, . . . , hm},
and P ost(tran){l1, . . . , ln} intuitively means that if the facts
h1, . . . , hm held before the state transformation, then the
transformation is eligible to be applied and that the post
conditions l1, . . . , ln must hold afterwards. Because this
work uses the closed world assumption, each such trans-
formation can have multiple states satisfying the post con-
dition and the invariant part. They suggest some priority
based methods to choose one among such competing states.
Although our work is not based on the closed world assump-
tion and we do not derive states from post conditions, we can
model these state transformations followed by the selection
of the appropriate end state as a composition of policies.
Bonatti et al. [6] present a framework for composing access
control policies. The fundamental diﬀerence between their
modeling and ours is that they formulate an access control
policy as a set of ground terms over an alphabet for (subject,
object, action) terms, whereas we model policies as non-
deterministic transformers (relations) over states. Further,
Bonatti et al. have Horn clause rules to derive consequences
of policies, and the algebra of policies is captured by having
a collection of operators such as union, intersection, closure
under rules, scoping restrictions etc.
In addition, Bonatti
et al. [6] have policy variables for yet to be speciﬁed polices
in policy expressions that can be replaced by a collection of
(subject, object, action) triples supplied by an environment.
[6] does not explicitly support negative authorizations; how-
ever, it is possible to model hybrid policies such as denials
take precedence policy as p+ − p−
contain
positive and negative authorization terms, respectively.
where p+ and p−
Although there are many access control related work based
on automatons, we compare our work with [20]. This work
formulates policies related to access control,
information
ﬂow and resource availability as automatons. An enforce-
able security policy is deﬁned as a safety property and, draw-
ing upon earlier work [2, 3], it is shown how these can be
enforced by reference monitors. This work shows how to
reverse engineer an access control matrix based security en-
forcement mechanism as an automaton, and argues that it
is possible to compose policies by composing automatons,
independent of their implementation mechanisms.
use these sentences as conditions in conditional policies and
statements about their properties.
In addition we deﬁne
atomic policies consisting of granting and revoking permis-
sions, assuming and giving up assumed role by subjects,
adding and deleting subject, objects, actions and roles. N
denotes the set of standard integers.
Definition 1
(Restricted Second Order Syntax).
Terms: There are countable sets of constants for subjects,
objects, signed actions and roles given respectively as Cs =
{si : i ∈ N}, Co = {oi : i ∈ N}, Ca = {+ai : i ∈ N} ∪ {−ai :
i ∈ N} and Cr = {ri : i ∈ N}. There is a countable collec-
tions of set constants Cset = {PLi : i ∈ N}, and two unary
function symbols subPerm and rolePerm whose inputs are
subject and role terms and outputs are sets of (object,action)
pairs. We use countable sets of variables ranging over sub-
jects, objects, actions, roles and sets of (subject,object) pairs
given respectively as Vs = {xsi : i ∈ N}, Vo = {xoi : i ∈ N},
Va = {xai : i ∈ N}, Vr = {xri : i ∈ N} and {Xi : i ∈ N}. We
use abbreviations Ts = Cs ∪ Vs, To = Co ∪ Vo, Ta = Ca ∪ Va
and Tr = Cr ∪ Vr for subject, object, action and role terms
respectively. We use xs, ts for subject variables and terms,
and similar notation for variables and terms of other sorts.
Predicates: There are four unary predicates scopeS, scopeO,
scopeA and scopeR satisﬁed by subject, object, action and
role terms that are in scope, and a binary predicate playsRole
where the ﬁrst and second arguments are respectively subject
and role terms. In addition, there are three partial order-
ing relations ≤S,≤O and ≤R, on subject, object and role
terms respectively. There are three binary predicates conUsr,
conRole and conPerm to model subject-subject, role-role and
permission-permission conﬂicts. The ﬁrst two are binary
and the third one is 4-ary. Both parameters of conUsr are
subject terms and both parameters of conRole are role terms.
The four parameters of conPerm are object, action, object
and action terms respectively.
Formulas and Sentences: We use logical connectives ∨,
∧, →, ¬, individual quantiﬁers ∀, ∃ over all four sorts, set
quantiﬁers ∀X,∃X and the membership symbol ∈ over the
set sort to construct formulas and sentences of our restricted
second order language.
Now we use formulas of our restricted second order lan-
guage to deﬁne policies. First, we deﬁne atomic policies that
use formulas.
Definition 2
(Atomic Polices). Following statements
are called basic constructs:
1. assignP(xsi, xoj, xak), revokeP(xsi, xoj, xak)
2. assignRP(xri, xoj , xak), revokeRP(xri, xoj , xak),
3. assignR(xsi, xrj), revokeR(xsi, xrj )
4. addUsr(xsi), rmUsr(xsi), addRole(xri), rmRole(xri),
addObj(xoi), rmObj(xoi), addAct(xai), rmAct(xai).
We say that (α ← φ) is an atomic construct if α is a basic
construct and φ is a formula whose only free variables are
those that appear in α.
3. SYNTAX
There are four basic sorts of terms, for subjects, objects,
actions, roles and sets of (object,action) pairs. In addition,
we use some predicates, set membership symbol, logical con-
nectives and quantiﬁers to form formulas and sentences. We
As stated in Deﬁnition 2, there are four basic constructs
assignP, assignRP, revokeP and revokeRP for assigning and
revoking permissions from subjects and roles, respectively.
The reason for having two of each kind is to make a distinc-
tion between granting or revoking permissions from subjects
and granting or revoking permissions from roles. assignR
172assigns subjects to roles and revokeR retracts such assign-
ments. There are basic constructs for adding and remov-
ing subjects, objects, roles and actions given respectively
as addUsr, rmUsr, addRole, rmRole, addObj, rmObj, addAct,
and rmAct.
An atomic construct is of the form (Basic Construct ←
Formula) where free variables occurring in the conditional
must appear in the basic construct. The intent of an atomic
construct is that if the condition evaluates to be true in
a state, then the corresponding basic construct is applied.
Notice that due to the absence of a ﬁrst-order language, [21,