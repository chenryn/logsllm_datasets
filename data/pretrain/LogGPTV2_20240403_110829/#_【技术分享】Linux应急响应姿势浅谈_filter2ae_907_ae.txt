**总结：**
应急响应中关于定时任务应该排查的/etc/crontab,/etc/cron.d,/var/spool/cron/{user},然后顺藤摸瓜去看其他调用的目录/etc/cron.hourly,
/etc/cron.daily, /etc/cron.weekly, /etc/cron.monthly，/etc/anacrontab 。
其中容易忽视的就是/etc/anacrontab
在CentOS6下我们做个测试：
编辑/etc/anacrontab
修改RANDOM_DELAY=1
添加1 1 cron.test echo 1 >> /tmp/1.txt
    [root@localhost cron.weekly]# /usr/sbin/anacron -s
等待一分多钟后，可以看到
    [root@localhost cron.weekly]# cat /var/spool/anacron/cron.test 
    20170719
    [root@localhost cron.weekly]# cat /tmp/1.txt 
    1
**0x09 Rootkit**
检查命令替换
1）系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包,有哪些被篡改了,防止rpm也被替换,上传一个安全干净稳定版本rpm二进制到服务器上进行检查。
例如我替换一下/bin/ps，然后使用rpm -qaV查看
    [root@vincenthostname tmp]# rpm -qaV
    S.?....T. /bin/ps
2）比对命令的大小
例如正常的ps和netstat大小
    [root@vincent tmp]# ll /bin/ps
    -rwxr-xr-x 1 root root 87112 11月 15 2012 /bin/ps
    [root@vincent tmp]# ll /bin/netstat
    -rwxr-xr-x 1 root root 128216 5月 10 2012 /bin/netstat
下面是其中有一次应急时的记录
    [root@DataNode110 admin]# ls -alt /bin/ | head -n 10
    total 10836
    -rwxr-xr-x 1 root root 625633 Aug 17 16:26 tawlqkazpu
    dr-xr-xr-x. 2 root root 4096 Aug 17 16:26 .
    -rwxr-xr-x 1 root root 1223123 Aug 17 11:30 ps
    -rwxr-xr-x 1 root root 1223123 Aug 17 11:30 netstat
可以看到ps和netstat是一样大的。
3）查看命令的修改时间，按修改时间排序
    ls -alt /bin/ | head -n 5
4）使用chkrootkit和rkhunter查看
chkrootkit
1、准备gcc编译环境
对于CentOS系统，执行下述三条命令：
    > yum -y install gcc gcc-c++ make glibc*
2、下载chkrootkit源码
chkrootkit的官方网站为 http://www.chkrootkit.org ，下述下载地址为官方地址。为了安全起见，务必在官方下载此程序：
    > [root@www ~]# wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
3、解压下载回来的安装包
    > [root@www ~]# tar zxf chkrootkit.tar.gz
4、编译安装（后文命令中出现的“*”无需替换成具体字符，原样复制执行即可）
    >[root@www ~]# cd chkrootkit-*
    >
    >[root@www ~]# make sense
注意，上面的编译命令为make sense。
5、把编译好的文件部署到/usr/local/目录中，并删除遗留的文件
    >[root@www ~]# cd ..
    >[root@www ~]# cp -r chkrootkit- /usr/local/chkrootkit
    >[root@www ~]# rm -r chkrootkit-
至此，安装完毕。
**使用方法**
安装好的chkrootkit程序位于 /usr/local/chkrootkit/chkrootkit
直接执行
    > root@vm:~# /usr/local/chkrootkit/chkrootkit
rkhunter
在安装了kbeast的系统上测试，发现检测效果不如rkhunter好。
下载地址： 
1）安装
    tar -xvf rkhunter-1.4.0.tar.gz
    cd rkhunter-1.4.0
    ./installer.sh –install
在安装了kbeast的系统上测试，可以成功检测到。
    /usr/local/bin/rkhunter –check -sk
    [19:50:27] Rootkit checks…
    [19:50:27] Rootkits checked : 389
    [19:50:27] Possible rootkits: 1
    [19:50:27] Rootkit names : KBeast Rootkit
**2）在线升级**
rkhunter是通过一个含有rootkit名字的数据库来检测系统的rootkits漏洞, 所以经常更新该数据库非常重要,
你可以通过下面命令来更新该数据库:
执行命令：
    > rkhunter –update
**3）检测最新版本**
让 rkhunter 保持在最新的版本；
执行命令：
    > rkhunter –versioncheck
**0x10 病毒检测**
**0x11 文件权限**
setfacl与getfacl
ACL 全称 Access Control Lists 翻译成中文叫”访问控制列表”,传统的 Linux 文件系统的权限控制是通过
user、group、other 与 r(读)、w(写)、x(执行)
的不同组合来实现的。随着应用的发展，这些权限组合已不能适应现时复杂的文件系统权限控制要求。 例如，目录 /data
的权限为：drwxr-x—，所有者与所属组均为 root，在不改变所有者的前提下，要求用户 tom 对该目录有完全访问权限 (rwx).考虑以下2种办法
(这里假设 tom 不属于 root group)
(1) 给 /data 的 other 类别增加 rwx permission，这样由于 tom 会被归为 other 类别，那么他也将拥有 rwx 权限。
(2) 将 tom 加入到 root group，为 root group 分配 rwx 权限，那么他也将拥有 rwx 权限。
以上 2 种方法其实都不合适
为了解决这些问题，Linux 开发出了一套新的文件系统权限管理方法，叫文件访问控制列表 (Access Control Lists,
ACL)。简单地来说，ACL 就是可以设置特定用户或者用户组对于一个文件的操作权限。
文件的所有者以及有CAP_FOWNER的用户进程可以设置一个文件的acl。（在目前的linux系统上，root用户是唯一有CAP_FOWNER能力的用户）
ACL 有两种:
access ACL
针对文件和目录设置访问控制列表。
一种是default ACL，只能针对目录设置。如果目录中的文件没有设置 ACL，它就会使用该目录的默认 ACL.
**1）getfacl**
获取文件权限
    [root@vincent tmp]# getfacl 1.cap
    # file: 1.cap
    # owner: root
    # group: root
    user::rw-    group::r--    other::r--
**2）setfacl**
Access ACL
比如我设置/tmp/1.sh的other权限为000，然后切换到vinc账户。
    [vinc@vincent tmp]$ cat 1.sh
    cat: 1.sh: 权限不够
然后我们添加ACL
    [root@vincent opt]# setfacl -m u:vinc:rwx /tmp/1.sh
然后我们使用ll查看，发现第一个字段文件权限第十位变成了+号
    [root@vincent tmp]# ll 1.sh
    -rwxrwx---+ 1 root root 512 8月   9 03:21 1.sh
然后我们使用getfacl查看
    [vinc@vincent tmp]$ getfacl 1.sh
    # file: 1.sh
    # owner: root
    # group: root
    user::rwx
    user:vinc:rwx
    group::r-x
    mask::rwx
    other::---
我们切换到vinc账户就可以查看内容了
    [vinc@vincent tmp]$ cat 1.sh
    test
删除这条ACL
    [root@vincent tmp]# setfacl -x u:vinc /tmp/1.sh
取消所有的ACL
    [root@vincent tmp]# setfacl -b /tmp/1.sh
Default ACl
前面所说都是access acl，针对文件而言，而default acl是指对于一个目录进行default
acl设置，并且在此目录下建立的文件都将继承此目录的acl。
    [root@vincent opt]# setfacl -d -m u:hehe:--- 1
来看下目录1的权限
    [root@vincent opt]# getfacl -c 1
    user::rwx
    group::r-x
    other::r-x
    default:user::rwx
    default:user:hehe:---    default:group::r-x
    default:mask::r-x
    default:other::r-x
我们在目录1下新建的文件都将继承这个权限。我们在目录1下新建一个文件，然后查看一下ACL
    [vinc@vincent 1]$ getfacl 222
    # file: 222
    # owner: vinc
    # group: vinc
    user::rw-    user:hehe:---    group::r-x            #effective:r--    mask::r--    other::r--
切换到hehe账户，查看文件，提示权限不够。
    [hehe@vincent 1]$ cat /opt/1/222
    cat: /opt/1/222: 权限不够
    lsattr和chattr
    chattr
修改属性能够提高系统的安全 性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录
a：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性。
i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。
s：保密性地删除文件或目录，即硬盘空间被全部收回。
u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。
例子：
设置/etc/resolv.conf为不可修改
    [root@vincent tmp]# chattr +i /etc/resolv.conf 
    [root@vincent tmp]# lsattr /etc/resolv.conf 
    ----i--------e- /etc/resolv.conf
    [root@vincent tmp]# echo "" > /etc/resolv.conf 
    -bash: /etc/resolv.conf: 权限不够
    lsattr
查看文件权限
    [root@vincent tmp]# lsattr 1.txt 
    -----a-------e- 1.txt