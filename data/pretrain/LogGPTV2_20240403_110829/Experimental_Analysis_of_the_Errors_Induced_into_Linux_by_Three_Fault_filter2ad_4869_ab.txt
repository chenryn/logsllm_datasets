### 实验框架
图2展示了实验框架，该框架基于一个目标机器和一个主机。目标内核安装在目标机器上，并配有注入工具。目标机器的硬件平台基于Pentium III处理器。

#### 故障模拟
可以模拟瞬时故障和永久故障。瞬时故障的模拟是在其首次激活后移除注入的故障，而永久故障则在整个实验结束时才被移除。两个特定模块（无效参数数据库和内部破坏控制器）提供了每种注入技术所需的功能，具体将在下一节中描述。主机通过以太网连接到目标机器，其目的是监控目标机器并在应用程序挂起时重新启动它。

**图2 - 实验框架**
- **目标机器**
  - 工作负载
  - 拦截
  - 注入器
  - API
  - 内核
  - 破坏控制器
  - 无效参数
  - 守护进程
  - 跟踪
- **主机机器**
  - 以太网

### 外部故障注入
我们比较了系统调用参数中的位翻转（如MAFALDA [12]）与无效参数（如Ballista [6]）所引起的错误集。每次实验只破坏一个参数，通过单一位翻转或无效值来实现。图2中的注入器模块通过进行详尽的位翻转（每个参数32次）或将它们替换为无效值来注入故障。针对Linux API中使用的每种数据类型，在单独的文件（图2中的无效参数）中指定了无效值集合。基于Ballista的工作及其在线演示网站，定义了八类无效参数。只有六类用于针对调度组件（见表1）。这些值要么是无效的，要么接近有效域的边界；目的是尽可能对系统施加压力。

### 内部故障注入
这组实验针对的是从API无法访问的内核内部函数。选择的故障模型是在考虑的函数的输入参数中随机注入位翻转。根据正交缺陷分类，这些故障对应于接口故障。

我们将故障插入阶段与故障启用阶段区分开来。故障插入阶段对内核代码进行仪器化，并且是半自动化的。代码仪器化分为两个步骤：
1. 由于并非所有内核内部函数都与我们的研究相关，第一步是根据每个内核调用生成的调用图选择目标函数。通过在这些函数的开始和结束处插入注释来界定它们。
2. 第二步是在编译之前，在基本函数的输入点插入称为破坏者的代码块。

我们开发了一个名为“破坏控制器”的注入控制模块（见图2），以在内核中启用故障。虽然可以插入多个破坏者，但每次实验只能激活一个。每次插入都与一个标志关联，引入的标志集允许破坏控制器控制注入。图2中的注入器通过向破坏控制器模块发出ioctl()来激活故障。

需要注意的是，这种注入技术是侵入性的，只有在源代码可用的情况下才能应用。但在我们进行的受控实验中，这不是问题。这种类型的注入提供了非常准确的损坏[13]。

### 观察策略
故障模式的分类对于得出有意义的见解至关重要。我们区分了五种结果，分为检测和未检测两类。内核通过返回错误代码或处理处理器异常来报告错误。

- 应用程序挂起：4%
- 无信号：30%
- 无信号：27%
- 应用程序挂起：8%
- 内核挂起：12%
- 无信号：53%
- 应用程序挂起：18%
- 异常：13%
- 错误代码：4%

**图3 - 三种注入技术的故障模式率**
- a- API无效参数（507次实验）
  - 错误代码：66%
- b- API参数位翻转（1890次实验）
  - 错误代码：65%
- c- 内部函数参数位翻转（552次实验）
  - 错误代码：4%
  - 异常：13%

由于错误报告的准确性不是我们研究的主要目标，因此我们不区分内核返回不适当错误代码的情况。未检测类别包括以下三种情况：i) 内核挂起，ii) 应用程序挂起，iii) 无信号（即没有观察到任何现象）。我们专注于分析操作系统的反应，因此不对应用程序失败进行详细说明。我们的目标是依靠内核的错误检测机制来研究不同技术引起的错误是否在统计上等效。由于目标系统行为的非确定性和考虑的不同故障，寻找完全匹配的实验是没有意义的。外围卡和内核线程的调度是导致非确定性的主要原因。为了最小化系统的非确定性，我们在系统启动结束后立即执行实验。此外，尽管在实践中并不总是可能，但我们尝试在每次实验活动中禁用相应的驱动程序和一些内核线程。专门设计的跟踪工具在内核中插入断点以监视各种事件（系统调用陷阱、中断处理、上下文切换等），并帮助我们检测系统非确定性的各种原因。

### 结果与分析
上述框架适用于所有内核功能组件。然而，在本文中，我们重点分析调度组件。实验是在Linux内核版本2.4.0上进行的。开发的工作负载以简单的方式激活此组件。我们选择了六个与调度组件相关的内核调用来激活工作负载：i) setpriority, sched_setscheduler 和 wait4 用于进程调度，ii) setitimer 和 nanosleep 用于定时器管理。其他与调度组件相关的系统调用也被工作负载使用，但由于它们没有参数（如fork系统调用），因此与我们的研究无关。

工作负载由三个进程组成：一个主进程创建两个子进程。主进程改变其优先级（setpriority）并创建两个其他进程，然后让出处理器并等待其他进程结束（wait）。其中一个子进程将其调度策略改为FIFO（sched_setscheduler），而另一个子进程睡眠5毫秒（nanosleep）。睡眠进程醒来后发出各种调用（setitimer）以更新其计时器。所有进程在工作负载执行过程中都会发出gettimeofday调用。

图3给出了2949次实验的结果。在内核API注入实验（图3a和3b）中，主要观察结果是返回错误代码（分别为66%和65%）。这表明Linux内核API级别的检查非常有效。注意内核API级别注入和内部函数注入之间生成的故障模式的差异（图3c）。有另外两种在API级别注入时不会出现的故障模式。在内核内部注入时，错误代码的比率很低（4%）。另一方面，13%的故障通过硬件生成的异常检测，这意味着17%的故障导致检测到的错误。12%的注入故障导致内核挂起。

让我们分析内核API级别注入和内部函数注入之间的差异。通常，Linux中的内核调用涉及对内部函数的上层调用，例如sched_setscheduler调用一个完成所需服务的函数（setscheduler）。可以假设在这种类型的内核调用的第二深度级别（如sched_setscheduler, gettimeofday 和 setitimer）注入会导致相同的错误代码。对于sched_setscheduler内核调用，即使在第三层注入，“无效参数”和“不存在的进程”错误代码也会生成。然而，在setitimer内核调用的第二层注入不会触发“坏地址”错误代码，只会触发“无效参数”错误代码。这意味着错误检测机制仅在第一层实现。对底层函数源代码的分析支持这一说法。实际上，只有第一个参数的值在底层基本函数中得到了验证。