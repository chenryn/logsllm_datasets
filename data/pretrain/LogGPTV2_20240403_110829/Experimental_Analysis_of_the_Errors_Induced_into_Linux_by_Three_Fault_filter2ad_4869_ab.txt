-1
Empty
0
0
0
-1
Small (1 Byte)
Far (p + 4 MB)
Negative
NULL
ULONG_MAX
(all bits to 1)
INT_MAX
INT_MAX
NULL
NULL
Random
Non NULL
Low (0x00000010)
INT_MAX
Freed
Negative
Random
Random
Figure  2  illustrates  the  experimental  framework,
which  is  based  on  a  target  and  a  host  separate
machines. The target kernel is  installed on  the  target
machine along  with  the  injection  tool.  The  hardware
platform  of  the  target  machine  is  based  on  a
Pentium III processor.
Both transient and permanent faults  can be simulated.
Simulation  of  a transient fault consists  in  removing
the  injected fault after its  first  activation,  while  it  is
only  removed  at  the  end  of  the  experiment,  if  it
simulates  a  permanent  fault.  Two  specific  modules
(invalid  parameters  database  and  internal  sabotage
controller) provide the capabilities that  are specific to
each kind of  injection  technique described in  the  next
sections.  The aim  of  the  host  machine  (that  is  con-
nected to the target machine through an Ethernet link)
is to monitor the target machine and to  reboot it  with
the adequate options in case of an application hang.
Target machine
Workload
Intercept
Injector
API
Kernel
Sabotage controller
Invalid
parameters
Daemon
Trace
Host machine
Ehternet
Figure 2- Experimental framework
3.1.  Injection  of  external  faults
We  compare  error  sets  caused  by  bit-flips  (as  for
MAFALDA  [12])  into  system  call  parameters  with
those  caused  by  invalid  parameters  (as  for  Ballista
[6]). Only one  parameter is  corrupted per experiment,
by  either  a  single  bit-flip  or  an  invalid  value.  The
injector  module,  shown  in  Figure  2,  injects  faults
into the parameter values by either issuing  exhaustive
bit-flips  (32  per  parameter)  or  replacing  them  with
invalid values.  A  set  of  invalid values for  each  data-
type used in  the  Linux  API  is  specified in  a separate
file  (Invalid  Parameters  in  Figure  2).  Based  on  the
work  related  to  Ballista,  and  especially  its  online
demonstration site, eight classes of invalid parameters
are  defined.  Only  six  of  these  classes,  presented  in
Table 1, are used to target the scheduling component.
These values are either invalid or close to the  limit  of
the  valid  domain;  indeed,  the  goal  is  to  stress  the
system as much as possible.
3.2.  Injection  of  internal  faults
This  set  of  experiments  targets  the  kernel  internal
functions  that  are  not  reachable  from  the  API.  The
selected  fault  model  consists  in  randomly  injecting
bit-flips  in  the  input  parameters  of  the  considered
function. According to  the  Orthogonal Defect Classi-
fication, these faults correspond to interface faults.
We  distinguish  the  fault  insertion  phase  from  the
fault-enabling  phase.  The  fault 
insertion  phase
instruments  the  kernel  code  and  is  semi-automated.
Code instrumentation is achieved in two steps:
1) Since  all  internal functions  of  the  kernel  are  not
relevant  to  our  study,  the  first  step  consists  in
choosing the target functions according to  the  call
graph  generated  for  each  kernel  call.  These
functions  are delimited by  inserting  comments  at
the beginning and at the end.
2)  The  second  step  consists  in 
inserting,  before
compilation,  blocks  of  code,  called  saboteur,  at
the input point of an elementary function.
We  have  developed  an  injection  controller  module,
called sabotage  controller  in  Figure  2,  to  enable
faults  within  the  kernel.  Although  several  saboteurs
can be inserted, only  one is  activated per experiment.
Each insertion  is  associated  with  a  flag.  The  set  of
flags  introduced  permits  the  sabotage  controller  to
control  the  injections.  The  injector  in  Figure  2
enables the activation of  a fault by  issuing  an ioctl()
to the sabotage controller module.
It is worth  noting  that  such  an injection  technique is
intrusive and can only be applied if the  source code is
available. But this is not at  all  a problem in  the  type
of  controlled  experiments  we  are  conducting  here.
This  kind  of 
injection  provide  very  accurate
corruptions [13].
3.3  Observation  strategy
The classification of  failure modes is  a  crucial  issue
to  draw  out  relevant  insights.  We  distinguish  five
outcomes  split 
the  detection  and  the  non-
detection classes. The kernel signals an error by  either
returning  an  error  code  or  by  handling  a  processor
exception.   
into 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:15:42 UTC from IEEE Xplore.  Restrictions apply. 
App. hang
4%
No
signaling
30%
No
signaling
27%
App. hang
8%
Kernel hang
12%
No
signaling
53%
App. hang
18%
Exception
13%
Error code
4%
c-  Bit-flip in internal function parameters
(552 experiments)
Error code
66%
a-  API invalid parameters
(507 experiments)
Error code
65%
b-  Bit-flip in API parameters
(1890 experiments)
Figure 3- Failure mode rates for the three injection techniques
the 
As  the  accuracy of  the  error reports  is  not  the  main
objective  of  our  study,  we  do  not  discriminate  the
cases where the kernel returns inadequate error code.
three
The  non-detection  class  encompasses 
following  outcomes:  i)  kernel  hang,  ii)  application
hang and iii) no signaling (i.e.,  nothing  is  observed).
As  we  concentrate  on  the  analysis  of  the  operating
system  reaction,  we  do  not  detail  application  fails.
We recall that the idea is to rely on the  error detection
mechanisms of the kernel to  study whether the  errors
provoked by using different techniques are statistically
equivalent.  Due  to  the  non-determinism  attached  to
the  behavior  of  the  target  system  and  the  different
faults  that  are  considered,  looking  for  an  exact
matching  of  experiments  would  be 
irrelevant.
Peripheral cards and the  scheduling  of  kernel  threads
are 
the  major  causes  of  non-determinism.  To
minimize  the  system  non-determinism,  we  execute
the  experiments  just  after  the  system  ends  booting.
Also,  we try  to  disable the  corresponding drivers and
some kernel threads for each campaign, though this  is
not always possible in practice as this could divert the
system from its nominal configuration. A  specifically
designed  tracing  tool  inserts  break  points  into  the
kernel  to  monitor  various  events  (system  call  trap,
interrupt handling, context switch…),  and  allows  us
to detect various causes of system non-determinism.
4.  Results  and  analysis
The above framework applies to  all  kernel functional
components.  However,  in  this  paper,  we  focus  the
analysis  on  the  scheduling 
component.  The
experimentation has  been  achieved  on  version  2.4.0
of the Linux kernel. The developed workload activates
the  elementary 
this
component  in  a  simple  way.  We  have  selected  six
the  scheduling
kernel  calls  to  be  activated  by 
component  related  workload: 
i)  setpriority,
sched_setscheduler  and  wait4 
the
setitimer,
process 
functions  associated  with 
scheduling 
and 
ii) 
for 
nanosleep  and  gettimeofday  for  the  timer
management. Other system  calls  associated  with  the
scheduling component are used  by  the  workload  but
are  not  relevant  to  our  study  since  they  have  no
parameters, such as the fork system call.
The workload is composed of  three processes: a main
one  that  creates  two  children.  The  main  process
changes its priority (setpriority) and creates two
other  processes  before  yielding  the  processor  and
waiting  for  the  end  of  the  other  processes  (wait).
One of  them  changes its  scheduling  policy  to  FIFO
(sched_setscheduler),  while  the  other  one
sleeps for 5 ms  (nanosleep). The sleeping process
wakes up  and issues  various  calls  (setitimer)  to
update its  timers.  All  the  processes  issue,  along  the
execution of the workload, the gettimeofday call.
The  results  of  the  2949  experiments  are  given  in
Figure 3. The dominant observation in the kernel API
injection experiments (Figure 3a and 3b)  is  returning
error codes (66% and 65%  respectively).  This  shows
the  effectiveness  of  the  checks  implemented  at  the
Linux  kernel  API  level.  Note  the  difference  in  the
generated failure modes between the  injections  at  the
kernel  API  level  and 
internal  functions
(Figure 3c).  There  are  two  additional  failure  modes
that  do not  appear  when  injecting  at  the  API  level.
The error code rate when injecting inside the  kernel is
low  (4%).  On  the  other  hand,  13%  of  faults  are
detected  by  hardware-generated  exceptions,  which
means that 17% of  faults  lead to  detected errors. 12%
of the injected faults lead to kernel hang.
Let  us  analyze the  reasons  of  the  difference  between
the  injections  at  the  kernel  API  level  and  in  its
internal  functions.  Generally,  the  kernel  calls  in
Linux consist  in  up  calls to  internal functions  as  for
sched_setscheduler  in  Figure 1  for.  It  calls
one  function  (setscheduler),  which  fulfills  the
required service.   One may  assume that  injections  at
the  second  depth  level  of  this  kind  of  kernel  calls
(sched_setscheduler,  gettimeofday  and
its 
in 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:15:42 UTC from IEEE Xplore.  Restrictions apply. 
for 
this 
function 
setitimer)  lead  to  the  same  error  code.  This  is
true  for  the  sched_setscheduler  kernel  call
where    “Invalid  Argument”  and 
  “Non  Existent
Process” error codes are generated even when injecting
in  the  third  level  of  the  kernel  function  call  graph.
However,  injections  in 
the  second  level  of  the
setitimer  kernel  call  do  not  provoke  “Bad
Address”  error  code  and  provoke  only  an  “Invalid
Argument”  error  code.  This  means  that  the  error
detection  mechanisms 
are
implemented only  in  the  first  level.  The  analysis  of
the  source  code  of  the  underlying  function  supports
this  statement.  In  fact  only  the  value  of  the  first
parameter  is  verified  in  the  underlying  elementary