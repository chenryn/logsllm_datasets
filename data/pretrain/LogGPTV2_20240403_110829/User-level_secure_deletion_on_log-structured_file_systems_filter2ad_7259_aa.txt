title:User-level secure deletion on log-structured file systems
author:Joel Reardon and
Claudio Marforio and
Srdjan Capkun and
David A. Basin
Chapter 5
User-Level Secure Deletion on Log-Structured
File Systems
5.1 Introduction
This chapter addresses the problem of secure data deletion on log-structured ﬁle
systems. We focus on YAFFS, a ﬁle system used on Android smartphones that uses
raw ﬂash for the internal memory. We analyze how deletion is performed in YAFFS
and show that log-structured ﬁle systems in general provide no temporal guarantees
on data deletion; the time discarded data persists on a log-structured ﬁle system is
proportional to the size of the storage medium and related to the writing behaviour
of the device using the storage medium. Moreover, discarded data remains stored
indeﬁnitely if the storage medium is not used after the data is marked for deletion.
We propose two user-level solutions for secure deletion in log-structured ﬁle sys-
tems: purging, which provides guaranteed time-bounded deletion of all previously
discarded data by ﬁlling the storage medium, and ballooning, which continuously
reduces the expected time that any discarded data remains on the medium by oc-
cupying a fraction of the capacity. We combine these two solutions into a hybrid,
which guarantees the periodic, prompt secure deletion of data regardless of the stor-
age medium’s size and with acceptable wear of the memory.
As these solutions require only user-level permissions, they enable the user to
securely delete data even if this feature is not supported by the kernel or hardware,
over which users typically do not have control. This, for example, allows mobile
phone users to achieve secure deletion without violating their warranties or requiring
non-trivial technical knowledge to update their ﬁrmware with a customized kernel.
Nevertheless, user-level solutions have a reduced interface to the storage medium
and so cannot be more efﬁcient than solutions with a deeper integration; in the next
chapter we see exactly such a solution that achieves greater efﬁciency.
We implement these solutions on an Android smartphone (Nexus One [65]) and
show that they neither prohibitively reduce the longevity of the ﬂash memory nor no-
ticeably reduce the device’s battery lifetime. We simulate our solutions for phones
with larger storage capacities than the Nexus One, and show that while purging
alone is expensive in time and ﬂash memory wear, when combined with ballooning
© Springer International Publishing Switzerland 2016
J. Reardon, Secure Data Deletion, Information Security and Cryptography,
DOI 10.1007/978-3-319-28778-2_5
57
58
5 User-Level Secure Deletion on Log-Structured File Systems
it becomes feasible and effective. Ballooning provides a trade-off between the dele-
tion latency and the resulting wear on the ﬂash memory. It also substantially reduces
the deletion latency on large, sparsely occupied storage media.
5.2 System and Adversarial Model
The user continually stores, reads, and discards sensitive data on a mobile phone.
We assume that the user has only user-level access to the mobile phone. This means
that the user may not modify the operating system or hardware of the device. The
solution can only interact with the ﬁle system interface to achieve secure deletion.
We assume that there is an unpredictable multiple-access coercive adversary that
can compromise the user’s storage medium. Our adversarial model is a slight mod-
iﬁcation of the main model developed in Chapter 3 in that it is not computationally
bounded.
5.3 YAFFS
Yet Another Flash File System (YAFFS) is a log-structured ﬁle system designed
speciﬁcally for ﬂash memory [69]. It is notably used as the ﬁle system for the in-
ternal memory of some Android mobile phones which store data using raw ﬂash
memory.
YAFFS allocates memory by selecting an unused erase block and sequentially
allocating the numbered pages (which YAFFS calls chunks) in that erase block. An
allocated erase block is freshly erased and therefore devoid of any data. YAFFS
searches for empty erase blocks (i.e., ones that contain no valid data) sequentially
by the erase block number as deﬁned by the physical layout of memory on the
storage medium, wrapping cyclically when necessary. It begins searching from the
most-recently allocated erase block and returns the ﬁrst empty erase block.
YAFFS performs compaction (which YAFFS calls garbage collection) to reclaim
wasted space on partially full erase blocks. As illustrated in Figure 4.2, compaction
copies all valid (i.e., non-discarded) pages from some partially full erase block to
the log’s end; compaction then erases the source erase block, which now contains
no valid data. If there is no erase block that can be compacted, that is, there is not a
single unneeded page stored on the medium, then YAFFS reports the ﬁle system as
full and fails to allocate an erase block.
Compaction in YAFFS is either initiated by a thread that performs system main-
tenance, or takes place during write operations. Usually, a few pages are copied at a
time, thus the work to copy an erase block is amortized over many write operations.
If the ﬁle system contains too few free erase blocks, then a more aggressive com-
paction is performed. In this case, erase blocks with any amount of discarded space
are compacted.
5.4 Data Deletion in Existing Log-Structured File Systems
59
YAFFS selects erase blocks for compaction using a greedy strategy based on the
ratio of discarded pages on an erase block; however, it only searches within a small
moving range of erase blocks with a minimum threshold for discarded pages. This
cyclic and proactive approach to compaction results in a strong cyclic trend in erase
block allocations. When low on free space, YAFFS selects the erase block with the
most wasted space by examining all the storage medium’s erase blocks.
There are currently two major versions of YAFFS, YAFFS1 and YAFFS2, and
among their differences is how ﬁle deletion is performed. In YAFFS1, a special
not-deleted ﬂag in the ﬁle’s header is set to 1; when the ﬁle is deleted the header
is programmed a second time (without ﬁrst erasing it) to contain the same contents
except the ﬂag is set to 0. Note that this technique is similar to Wei et al.’s scrub-
bing [26]. In YAFFS2, this multiple programming is obviated by writing a new ﬁle
header instead; this change is to allow YAFFS to support all ﬂash memories, many
of which do not permit multiple programmings. We used YAFFS2 for all our exper-
iments and henceforth we simply call it YAFFS.
5.4 Data Deletion in Existing Log-Structured File Systems
In this section, we investigate data persistence on log-structured ﬁle systems by ana-
lyzing the internal memory of a Nexus One running Android/YAFFS and simulating
larger storage media. We instrument the ﬁle system at the kernel level to log erase
block allocation information. This provides an upper bound on the deletion latency,
because allocating an erase block for storage implies that it was previously com-
pacted and erased, and therefore all discarded data previously stored on that erase
block is securely deleted.
Figure 5.1 shows four data items stored on two erase blocks, each one with two
pages. Different data items are indicated with different patterns. Each erase block
shows a timeline of what data is stored on which page at which time. Data item cre-
ate and discard events are indicated. Moreover, when an erase block is reallocated,
valid data is copied to another page. The vertically striped data item, for example, is
twice copied before it is discarded. At the bottom is illustrated the lifetime of data
items as well as the time that they are compromisable due to deletion latency. The
time between two erase block reallocations is labelled as the erase block realloca-
tion period. All data discarded within this period has its deletion latency bounded
by it. Observe that the reallocation period is not ﬁxed for all times and erase blocks;
it depends on how the storage medium is used.
In this section we show that modern Android smartphones have large deletion
latency, where deleted data can remain indeﬁnitely on the storage media. This mo-
tivates the secure deletion solutions in Section 5.5.
60
5 User-Level Secure Deletion on Log-Structured File Systems
erase block 1
reallocation
reallocation
page 1
page 2
create
          

          

copy
time
        

        

        

   

   

create
discard
       

       

copy
discard
erase block reallocation period
erase block 2
reallocation
reallocation
create
create
discard
page 1
page 2
       

       

       

       

            

            

copy
    

    

    

copy
discard
erase block reallocation period
data items
data lifetime
compromisable
   

   

   

   

  

  

  

  

  

  

  

  

  

data lifetime
compromisable
data lifetime
compromisable
data lifetime
compromisable
Fig. 5.1 Example timeline of data items stored on two erase blocks. Each erase block is twice
reallocated and the reallocation period for them is indicated. Different data items have different
patterns. The bottom illustrates each data item’s lifetime and compromisable time (i.e., lifetime
plus deletion latency).
5.4.1 Instrumented YAFFS
We built a modiﬁed version of the YAFFS Linux kernel module that logs data about
the writing behaviour of an Android phone. We log the time and number for every
erase block allocation and erasure. This information shows us where YAFFS stores
data written at some point in time and when that data becomes irrecoverable. This
allows us to compute the deletion latency of data in our simulation.
5.4 Data Deletion in Existing Log-Structured File Systems
61
We used the instrumented phone daily for 670 hours, roughly 27.9 days. Through-
out the experiment we recorded 20345 erase block allocations initiated by 73 differ-
ent writers. A writer is any application, including the Android OS itself or one of
its services (e.g., GPS, DHCP, compass, etc.). The experiment’s logs show that the
median time between erase block reallocations is 44.5 hours. The deletion latency is
always less than the reallocation period; this means that the median deletion latency
is upper bounded by this value.
5.4.2 Simulating Larger Storage Media
Log-structured ﬁle systems favour allocating empty erase blocks before compacting
partially empty erase blocks [69, 73]. We hypothesize that the erase block reallo-
cation period—and consequently the deletion latency—is highly dependent on the
ﬁle system’s size. We tested this hypothesis by writing a discrete event simulator to
experiment with the writing behaviour of an Android phone on simulated YAFFS
storage media of various sizes. We ﬁrst describe our experimental setup and then
present our results.
Experimental Procedure.
To experiment with different ﬂash storage medium sizes, we simulated an Android
mobile phone using a ﬂash storage medium in memory. We used our own dis-
crete event simulator that writes, overwrites, and deletes ﬁles on a storage medium.
This medium is a directory on our computer that simulates accessing ﬂash memory
through a ﬂash ﬁle system.
We used the collected statistics from our instrumented phone in Section 5.4.1 to
determine the writing behaviour for our discrete event simulator. We logged every
page that was written to the device for a week, and used this data to compute the
period between successive creations of new ﬁles, and the characteristics of the ﬁles
that are created. The characteristics of ﬁles are the following:
• The ﬁle’s lifetime.
• A distribution over the period of time between opening a ﬁle for write.
• A distribution over the number of pages to write to a ﬁle each time it is opened.
• A distribution over a ﬁle’s pages where the writes occur.
Additionally, we implemented a pattern writer that operated alongside the simu-
lated writers. It periodically writes a one-page pattern, waits until a new erase block
is allocated, and then deletes the pattern. We use the pattern writer to determine the
deletion latency for data written at that particular moment in time, but which remains
stored; it represents the writing of some sensitive data that is later discarded.
62
5 User-Level Secure Deletion on Log-Structured File Systems
1600
1400
1200
1000
800
600
400
200
l
r
e
b