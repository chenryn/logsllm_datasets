# 15 \| 边界：微服务的各种边界在架构演进中的作用？你好，我是欧创新。前几讲我们已经介绍过了，在用 DDD进行微服务设计时，我们可以通过事件风暴来确定领域模型边界，划定微服务边界，定义业务和系统运行边界，从而保证微服务的单一职责和随需而变的架构演进能力。那重点落到边界的时候，总结一下就是，微服务的设计要涉及到逻辑边界、物理边界和代码边界等等。那么这些边界在微服务架构演进中到底起到什么样的作用？我们又该如何理解这些边界呢？这就是我们今天重点要解决的问题。演进式架构在微服务设计和实施的过程中，很多人认为："将单体拆分成多少个微服务，是微服务的设计重点。"可事实真的是这样吗？其实并非如此！Martin Fowler在提出微服务时，他提到了微服务的一个重要特征------演进式架构。那什么是演进式架构呢？演进式架构就是以支持增量的、非破坏的变更作为第一原则，同时支持在应用程序结构层面的多维度变化。那如何判断微服务设计是否合理呢？其实很简单，只需要看它是否满足这样的情形就可以了：随着业务的发展或需求的变更，在不断重新拆分或者组合成新的微服务的过程中，不会大幅增加软件开发和维护的成本，并且这个架构演进的过程是非常轻松、简单的。这也是微服务设计的重点，就是看微服务设计是否能够支持架构长期、轻松的演进。那用 DDD方法设计的微服务，不仅可以通过限界上下文和聚合实现微服务内外的解耦，同时也可以很容易地实现业务功能积木式模块的重组和更新，从而实现架构演进。微服务还是小单体？有些项目团队在将集中式单体应用拆分为微服务时，首先进行的往往不是建立领域模型，而只是按照业务功能将原来单体应用的一个软件包拆分成多个所谓的"微服务"软件包，而这些"微服务"内的代码仍然是集中式三层架构的模式，"微服务"内的代码高度耦合，逻辑边界不清晰，这里我们暂且称它为"小单体微服务"。下面这张图也很好地展示了这个过程。![](Images/3d72a9faa49c84cf6df5f78ee81d2e33.png)savepage-src="https://static001.geekbang.org/resource/image/cc/eb/cc697f4e8eef2629a660d247c8a1eceb.jpg"}而随着新需求的提出和业务的发展，这些小单体微服务会慢慢膨胀起来。当有一天你发现这些膨胀了的微服务，有一部分业务功能需要拆分出去，或者部分功能需要与其它微服务进行重组时，你会发现原来这些看似清晰的微服务，不知不觉已经摇身一变，变成了臃肿油腻的大单体了，而这个大单体内的代码依然是高度耦合且边界不清的。"辛辛苦苦好多年，一夜回到解放前啊！"这个时候你就需要一遍又一遍地重复着从大单体向单体微服务重构的过程。想想，这个代价是不是有点高了呢？其实这个问题已经很明显了，那就是边界。这种单体式微服务只定义了一个维度的边界，也就是微服务之间的物理边界，本质上还是单体架构模式。微服务设计时要考虑的不仅仅只有这一个边界，别忘了还要定义好微服务内的逻辑边界和代码边界，这样才能得到你想要的结果。那现在你知道了，我们一定要避免将微服务设计为小单体微服务，那具体该如何避免呢？清晰的边界人人想要，可该如何保证呢？DDD已然给出了答案。微服务边界的作用你应该还记得 DDD设计方法里的限界上下文和聚合吧？它们就是用来定义领域模型和微服务边界的。我们再来回顾一下 DDD的设计过程。在事件风暴中，我们会梳理出业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出实体等领域对象。根据实体对象之间的业务关联性，将业务紧密相关的多个实体进行组合形成聚合，聚合之间是第一层边界。根据业务及语义边界等因素将一个或者多个聚合划定在一个限界上下文内，形成领域模型，限界上下文之间的边界是第二层边界。为了方便理解，我们将这些边界分为：**逻辑边界、物理边界和代码边界**。**逻辑边界**主要定义同一业务领域或应用内紧密关联的对象所组成的不同聚类的组合之间的边界。事件风暴对不同实体对象进行关联和聚类分析后，会产生多个聚合和限界上下文，它们一起组成这个领域的领域模型。微服务内聚合之间的边界就是逻辑边界。一般来说微服务会有一个以上的聚合，在开发过程中不同聚合的代码隔离在不同的聚合代码目录中。逻辑边界在微服务设计和架构演进中具有非常重要的意义！微服务的架构演进并不是随心所欲的，需要遵循一定的规则，这个规则就是逻辑边界。微服务架构演进时，在业务端以聚合为单位进行业务能力的重组，在微服务端以聚合的代码目录为单位进行微服务代码的重组。由于按照DDD方法设计的微服务逻辑边界清晰，业务高内聚，聚合之间代码松耦合，因此在领域模型和微服务代码重构时，我们就不需要花费太多的时间和精力了。现在我们来看一个微服务实例，在下面这张图中，我们可以看到微服务里包含了两个聚合的业务逻辑，两个聚合分别内聚了各自不同的业务能力，聚合内的代码分别归到了不同的聚合目录下。那随着业务的快速发展，如果某一个微服务遇到了高性能挑战，需要将部分业务能力独立出去，我们就可以以聚合为单位，将聚合代码拆分独立为一个新的微服务，这样就可以很容易地实现微服务的拆分。![](Images/dc8d4c4860f0812c2e9725132d038276.png)savepage-src="https://static001.geekbang.org/resource/image/88/3d/88d709569367264d368b08a7d9658c3d.png"}另外，我们也可以对多个微服务内有相似功能的聚合进行功能和代码重组，组合为新的聚合和微服务，独立为通用微服务。现在你是不是有点做中台的感觉呢？**物理边界**主要从部署和运行的视角来定义微服务之间的边界。不同微服务部署位置和运行环境是相互物理隔离的，分别运行在不同的进程中。这种边界就是微服务之间的物理边界。**代码边界**主要用于微服务内的不同职能代码之间的隔离。微服务开发过程中会根据代码模型建立相应的代码目录，实现不同功能代码的隔离。由于领域模型与代码模型的映射关系，代码边界直接体现出业务边界。代码边界可以控制代码重组的影响范围，避免业务和服务之间的相互影响。微服务如果需要进行功能重组，只需要以聚合代码为单位进行重组就可以了。正确理解微服务的边界从上述内容中，我们知道了，按照 DDD设计出来的逻辑边界和代码边界，让微服务架构演进变得不那么费劲了。微服务的拆分可以参考领域模型，也可以参考聚合，因为聚合是可以拆分为微服务的最小单位的。但实施过程是否一定要做到逻辑边界与物理边界一致性呢？也就是说聚合是否也一定要设计成微服务呢？答案是不一定的，这里就涉及到微服务过度拆分的问题了。微服务的过度拆分会使软件维护成本上升，比如：集成成本、发布成本、运维成本以及监控和定位问题的成本等。在项目建设初期，如果你不具备较强的微服务管理能力，那就不宜将微服务拆分过细。当我们具备一定的能力以后，且微服务内部的逻辑和代码边界也很清晰，你就可以随时根据需要，拆分出新的微服务，实现微服务的架构演进了。当然，还要记住一点，微服务内聚合之间的服务调用和数据依赖需要符合高内聚松耦合的设计原则和开发规范，否则你也不能很快完成微服务的架构演进。总结今天我们主要讨论了微服务架构设计中的各种边界在架构演进中的作用。**逻辑边界：**微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务。**物理边界：**微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。**代码边界：**不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离，方便架构演进时代码的重组。通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。思考题分享一下你们公司目前采用了什么样的方法来实现微服务的架构演进？和 DDD设计方法相比，有何区别，你觉得哪种方式更好呢？可结合业务场景进行分析。期待你的分享，你可以在留言区中畅所欲言，我们一同交流！![](Images/e4872e412bb3131e6dec8a85bb125c27.png)savepage-src="https://static001.geekbang.org/resource/image/7b/33/7b1a917aff0ec923b78a54e81ed90733.jpg"}
# 16 \| 视图：如何实现服务和数据在微服务各层的协作？你好，我是欧创新。 在 DDD分层架构和微服务代码模型里，我们根据领域对象的属性和依赖关系，将领域对象进行分层，定义了与之对应的代码对象和代码目录结构。分层架构确定了微服务的总体架构，微服务内的主要对象有服务和实体等，它们一起协作完成业务逻辑。 那在运行过程中，这些服务和实体在微服务各层是如何协作的呢？今天我们就来解剖一下基于DDD分层架构的微服务，看看它的内部结构到底是什么样的。 服务的协作1. 服务的类型我们先来回顾一下分层架构中的服务。按照分层架构设计出来的微服务，其内部有Facade服务、应用服务、领域服务和基础服务。各层服务的主要功能和职责如下。 **Facade 服务：**位于用户接口层，包括接口和实现两部分。用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将数据传递给应用层。或者在获取到应用层数据后，将DO 组装成DTO，将数据传输到前端应用。 **应用服务：**位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果拼装，对外提供粗粒度的服务。 **领域服务：**位于领域层。领域服务封装核心的业务逻辑，实现需要多个实体协作的核心领域逻辑。它对多个实体或方法的业务逻辑进行组合或编排，或者在严格分层架构中对实体方法进行封装，以领域服务的方式供应用层调用。 **基础服务：**位于基础层。提供基础资源服务（比如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务应用逻辑的影响。基础服务主要为仓储服务，通过依赖倒置提供基础资源服务。领域服务和应用服务都可以调用仓储服务接口，通过仓储服务实现数据持久化。 2. 服务的调用我们看一下下面这张图。微服务的服务调用包括三类主要场景：微服务内跨层服务调用，微服务之间服务调用和领域事件驱动。 ![](Images/5570e12284aa82934e7ec09f1e06fc25.png)savepage-src="https://static001.geekbang.org/resource/image/e5/db/e5d025a6fd69d1f2cf2a1af53253abdb.png"}**微服务内跨层服务调用** 微服务架构下往往采用前后端分离的设计模式，前端应用独立部署。前端应用调用发布在API 网关上的 Facade 服务，Facade定向到应用服务。应用服务作为服务组织和编排者，它的服务调用有这样两种路径： 1.  第一种是应用服务调用并组装领域服务。此时领域服务会组装实体和实体方法，实现核心领域逻辑。领域服务通过仓储服务获取持久化数据对象，完成实体数据初始化。        2.  第二种是应用服务直接调用仓储服务。这种方式主要针对像缓存、文件等类型的基础层数据访问。这类数据主要是查询操作，没有太多的领域逻辑，不经过领域层，不涉及数据库持久化对象。        **微服务之间的服务调用** 微服务之间的应用服务可以直接访问，也可以通过 API网关访问。由于跨微服务操作，在进行数据新增和修改操作时，你需关注分布式事务，保证数据的一致性。 **领域事件驱动** 领域事件驱动包括微服务内和微服务之间的事件（详见 [\[第 06讲\]  slate-object="inline"）。微服务内通过事件总线（EventBus）完成聚合之间的异步处理。微服务之间通过消息中间件完成。异步化的领域事件驱动机制是一种间接的服务访问方式。 当应用服务业务逻辑处理完成后，如果发生领域事件，可调用事件发布服务，完成事件发布。 当接收到订阅的主题数据时，事件订阅服务会调用事件处理领域服务，完成进一步的业务操作。 3. 服务的封装与组合我们看一下下面这张图。微服务的服务是从领域层逐级向上封装、组合和暴露的。 ![](Images/f3590758c7bdef33e6443577dbc7bcab.png)savepage-src="https://static001.geekbang.org/resource/image/2d/1d/2d6a328a9fd8b4b3906bb9f59435ca1d.png"}**基础层** 基础层的服务形态主要是仓储服务。仓储服务包括接口和实现两部分。仓储接口服务供应用层或者领域层服务调用，仓储实现服务，完成领域对象的持久化或数据初始化。 **领域层** 领域层实现核心业务逻辑，负责表达领域模型业务概念、业务状态和业务规则。主要的服务形态有实体方法和领域服务。 实体采用充血模型，在实体类内部实现实体相关的所有业务逻辑，实现的形式是实体类中的方法。实体是微服务的原子业务逻辑单元。在设计时我们主要考虑实体自身的属性和业务行为，实现领域模型的核心基础能力。不必过多考虑外部操作和业务流程，这样才能保证领域模型的稳定性。 DDD提倡富领域模型，尽量将业务逻辑归属到实体对象上，实在无法归属的部分则设计成领域服务。领域服务会对多个实体或实体方法进行组装和编排，实现跨多个实体的复杂核心业务逻辑。 对于严格分层架构，如果单个实体的方法需要对应用层暴露，则需要通过领域服务封装后才能暴露给应用服务。 **应用层** 应用层用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，负责不同聚合之间的服务和数据协调，负责微服务之间的事件发布和订阅。 通过应用服务对外暴露微服务的内部功能，这样就可以隐藏领域层核心业务逻辑的复杂性以及内部实现机制。应用层的主要服务形态有：应用服务、事件发布和订阅服务。 应用服务内用于组合和编排的服务，主要来源于领域服务，也可以是外部微服务的应用服务。除了完成服务的组合和编排外，应用服务内还可以完成安全认证、权限校验、初步的数据校验和分布式事务控制等功能。 为了实现微服务内聚合之间的解耦，聚合之间的服务调用和数据交互应通过应用服务来完成。原则上我们应该禁止聚合之间的领域服务直接调用和聚合之间的数据表关联。 **用户接口层** 用户接口层是前端应用和微服务之间服务访问和数据交换的桥梁。它处理前端发送的Restful请求和解析用户输入的配置文件等，将数据传递给应用层。或获取应用服务的数据后，进行数据组装，向前端提供数据服务。主要服务形态是Facade 服务。 Facade 服务分为接口和实现两个部分。完成服务定向，DO 与 DTO数据的转换和组装，实现前端与应用层数据的转换和交换。 4. 两种分层架构的服务依赖关系现在我们回顾一下 DDD分层架构，分层架构有一个重要的原则就是：每层只能与位于其下方的层发生耦合。 那根据耦合的紧密程度，分层架构可以分为两种：严格分层架构和松散分层架构。在严格分层架构中，任何层只能与位于其直接下方的层发生依赖。在松散分层架构中，任何层可以与其任意下方的层发生依赖。 下面我们来详细分析和比较一下这两种分层架构。 **松散分层架构的服务依赖** 我们看一下下面这张图，在松散分层架构中，领域层的实体方法和领域服务可以直接暴露给应用层和用户接口层。松散分层架构的服务依赖关系，无需逐级封装，可以快速暴露给上层。 但它存在一些问题，第一个是容易暴露领域层核心业务的实现逻辑；第二个是当实体方法或领域服务发生服务变更时，由于服务同时被多层服务调用和组合，不容易找出哪些上层服务调用和组合了它，不方便通知到所有的服务调用方。 ![](Images/30cf6eb78eda20c8c41e1da8a970fdda.png)savepage-src="https://static001.geekbang.org/resource/image/5e/a1/5e901b4f7fa964b349e4d6f344786ea1.png"}我们再来看一张图，在松散分层架构中，实体 A的方法在应用层组合后，暴露给用户接口层 aFacade。abDomainService领域服务直接越过应用层，暴露给用户接口层 abFacade服务。松散分层架构中任意下层服务都可以暴露给上层服务。 ![](Images/ca9010b06ccbdece8d427c85ac0317df.png)savepage-src="https://static001.geekbang.org/resource/image/b3/a0/b35d6fed54e26423c0d61de040ab04a0.jpeg"}**严格分层架构的服务依赖** 我们看一下下面这张图，在严格分层架构中，每一层服务只能向紧邻的上一层提供服务。虽然实体、实体方法和领域服务都在领域层，但实体和实体方法只能暴露给领域服务，领域服务只能暴露给应用服务。 在严格分层架构中，服务如果需要跨层调用，下层服务需要在上层封装后，才可以提供跨层服务。比如实体方法需要向应用服务提供服务，它需要封装成领域服务。 这是因为通过封装你可以避免将核心业务逻辑的实现暴露给外部，将实体和方法封装成领域服务，也可以避免在应用层沉淀过多的本该属于领域层的核心业务逻辑，避免应用层变得臃肿。还有就是当服务发生变更时，由于服务只被紧邻上层的服务调用和组合，你只需要逐级告知紧邻上层就可以了，服务可管理性比松散分层架构要好是一定的。 ![](Images/e52823f924b5e15b1cd5f9b2d525d574.png)savepage-src="https://static001.geekbang.org/resource/image/ab/07/ab304d69ee174b5e69cb63d79864ca07.png"}我们还是看图，A 实体方法需封装成领域服务 aDomainService才能暴露给应用服务 aAppService。abDomainService 领域服务组合和封装 A 和B 实体的方法后，暴露给应用服务abAppService。 ![](Images/5ee89a44a1d648c587226933476de247.png)savepage-src="https://static001.geekbang.org/resource/image/34/f9/348d60eac28c9dbf7d120d1b7159cdf9.png"}数据对象视图在 DDD中有很多的数据对象，这些对象分布在不同的层里。它们在不同的阶段有不同的形态。你可以再回顾一下 [\[第 04讲\]  slate-object="inline"，这一讲有详细的讲解。 我们先来看一下微服务内有哪些类型的数据对象？它们是如何协作和转换的？ 1.  数据持久化对象 PO(Persistent    Object)，与数据库结构一一映射，是数据持久化过程中的数据载体。        2.  领域对象 DO（Domain    Object），微服务运行时的实体，是核心业务的载体。        3.  数据传输对象 DTO（Data Transfer    Object），用于前端与应用层或者微服务之间的数据组装和传输，是应用之间数据传输的载体。        4.  视图对象 VO（View    Object），用于封装展示层指定页面或组件的数据。        我们结合下面这张图，看看微服务各层数据对象的职责和转换过程。 ![](Images/596eb0a19522e1f8417884ca3c37793c.png)savepage-src="https://static001.geekbang.org/resource/image/95/73/95524b08051fcd181e65f825005a4c73.png"}**基础层** 基础层的主要对象是 PO 对象。我们需要先建立 DO 和 PO 的映射关系。当 DO数据需要持久化时，仓储服务会将 DO 转换为 PO对象，完成数据库持久化操作。当 DO数据需要初始化时，仓储服务从数据库获取数据形成 PO 对象，并将 PO 转换为DO，完成数据初始化。 大多数情况下 PO 和 DO 是一一对应的。但也有 DO 和 PO 多对多的情况，在DO 和 PO数据转换时，需要进行数据重组。 **领域层** 领域层的主要对象是 DO 对象。DO是实体和值对象的数据和业务行为载体，承载着基础的核心业务逻辑。通过 DO 和PO转换，我们可以完成数据持久化和初始化。 **应用层** 应用层的主要对象是 DO 对象。如果需要调用其它微服务的应用服务，DO会转换为 DTO，完成跨微服务的数据组装和传输。用户接口层先完成 DTO 到 DO的转换，然后应用服务接收 DO 进行业务处理。如果 DTO 与 DO是一对多的关系，这时就需要进行 DO数据重组。 **用户接口层** 用户接口层会完成 DO 和 DTO的互转，完成微服务与前端应用数据交互及转换。Facade 服务会对多个 DO对象进行组装，转换为 DTO对象，向前端应用完成数据转换和传输。 **前端应用** 前端应用主要是 VO 对象。展现层使用 VO进行界面展示，通过用户接口层与应用层采用 DTO对象进行数据交互。 总结今天我们分析了 DDD分层架构下微服务的服务和数据的协作关系。为了实现聚合之间以及微服务各层之间的解耦，我们在每层定义了不同职责的服务和数据对象。在软件开发过程中，我们需要严格遵守各层服务和数据的职责要求，各据其位，各司其职。这样才能保证核心领域模型的稳定，同时也可以灵活应对外部需求的快速变化。 思考题你知道在微服务内为什么要设计不同的服务和不同的数据对象吗？它体现的是一种什么样的设计思想？ 欢迎留言和我分享你的思考，你也可以把今天所学分享给身边的朋友，邀请他加入探讨，共同进步。 ![](Images/e4872e412bb3131e6dec8a85bb125c27.png)savepage-src="https://static001.geekbang.org/resource/image/7b/33/7b1a917aff0ec923b78a54e81ed90733.jpg"}