Note that 95%, 93%, and 97% of the DLLs were loaded within one second after
launching Internet Explorer, Firefox, and Thunderbird, respectively.
The loading of DLLs results in the most work (and overhead) for Dymo, be-
cause it means that the system has to compute hashes for new code pages. Thus,
Fig. 1. DLL loading over time
the overhead during startup constitutes a worst case. To measure the startup
overhead, we ran Internet Explorer, Firefox, and Thunderbird on the native plat-
form, and we measured the time until each application’s main window responded
to user input with and without Dymo. We used the PassMark AppTimer tool
to do these measurements. Table 1 shows the results. It can be seen that, with
our system running, the startup times for Internet Explorer, Firefox, and Thun-
derbird increased by 80%, 41%, and 31%, respectively. While the overhead for
Internet Explorer seems high at ﬁrst glance, the browser still starts in less than
one second. We feel that this is below the threshold of user awareness; therefore,
it is an acceptable overhead. We speculate that the higher overhead of Internet
Explorer can be attributed to its multi-process, Loosely-Coupled IE (LCIE) ar-
chitecture [23], which results in Dymo duplicating its initialization eﬀorts over
the frame and tab processes.
Table 1. Startup times (in milliseconds)
Application
Without Dymo With Dymo Overhead
Internet Explorer
Firefox
Thunderbird
447
450
799
804
634
1047
80%
41%
31%
In addition to the worst-case overhead during application startup, we were
also interested in understanding the performance penalty due to our modiﬁca-
tions to the memory management routines and, in particular, the page fault
handler. To this end, we wrote a tool that ﬁrst allocated a 2 GB buﬀer in mem-
ory and then stepped through this buﬀer, touching a byte on each consecutive
page. This caused many page faults, and, as a result, it allowed us to measure the
overhead that a memory-intensive application might experience once the code
regions (binary image and libraries) are loaded and the appropriate identity la-
 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.2 0.4 0.6 0.8 1Proportion of DLLsTime (seconds)IEFirefoxThunderbirdbel is computed. We ran this test for 20 iterations and found that Dymo incurs
a modest overhead of 7.09% on average.
6 Security Analysis
In this section, we discuss the security of our proposed identity label mechanism.
In our threat model, we assume that the attacker controls a malicious process
and wants to carry out a security sensitive operation that is restricted to a set
of applications with known, trusted identities (labels). Similarly, the attacker
might want to send a network packet with the label of a trusted process.
The malicious process could attempt to obtain one of the trusted labels. To
this end, the attacker would have to create executable memory regions that hash
to the same values as the memory regions of a trusted process. Because we use
a strong hash function (SHA-1), it is infeasible for the attacker to allocate an
executable region that hashes to a known value. It is also not possible to simply
add code to a trusted program in order to carry out a sensitive operation on the
attacker’s behalf (a kind of confused deputy attack [10]). The reason is that any
added executable region would contribute an additional, unknown hash value to
the identity label, thereby invalidating it.
A malware process could also attempt to tamper with the data of a process
and indirectly modify its operations so that it could carry out malicious activity.
This is a more diﬃcult attack, and its success depends on the normal function-
ality that is implemented by the targeted victim program. The easiest way to
carry out this attack is via a debugger, which allows easy manipulation of the
heap or stack areas of the victim application. We prevent this attack by disabling
access to the Windows debugging API for all user processes when our system is
running. We believe that these APIs are only rarely used by regular users, and
it is reasonable to accept the reduced functionality for non-developers.
Another way to tamper with the execution of an application without in-
jecting additional code is via non-control-data attacks. These attacks modify
“decision-making data” that might be used by the application while carrying
out its computations and interactions. Previous work [4] has shown that these
attacks are “realistic threats,” but they are signiﬁcantly more diﬃcult to per-
form than attacks in which arbitrary code can be injected. Moreover, for these
attacks to be successful, the malware has to ﬁnd an application vulnerability that
can be exploited, and this vulnerability must be suitable to coerce the program
to run the functionality that is intended by the malware author. Our current
system does not speciﬁcally defend against these attacks. However, there are
a number of operating system improvements that make exploits such as these
signiﬁcantly more diﬃcult to launch. For example, address space layout ran-
domization (ASLR) [2] provides a strong defense against attacks that leverage
return-oriented programming (advanced return-into-libc exploits) [22]. Because
our technique is compatible with ASLR, our system directly beneﬁts from it and
will likely also proﬁt from other OS defenses. This makes this class of attacks
less of a concern.
7 Related Work
The goal of our system is to track the run-time identity of executing processes.
This objective is related to previous contributions that focus on identifying local
and remote applications.
Local Identiﬁcation. Patagonix [14] is a hypervisor-based system that tracks
all executing binaries on a host with the goal of detecting the presence of pro-
cesses that may be hidden by a rootkit. The system runs the target host in a
virtual machine and provides a secure channel to identify and list the host’s
running processes in a separate trusted VM.
The technique used by Patagonix to identify executing processes is similar to
ours in that both systems leverage NX hardware support to detect code execu-
tion. However, there are some disadvantages to the Patagonix approach: First,
the hypervisor must bridge a semantic gap. For example, it cannot determine
when processes terminate or when requests are made to change page permis-
sions. To combat this, the system periodically refreshes its state by remarking
all pages as non-executable. This adds more overhead as all subsequent execu-
tions of pages that are already monitored will induce spurious page faults that
will have to be checked. Clearly, there is a trade-oﬀ between this overhead and
the ﬁdelity of Patagonix’s view of the current state of the operating system. Fur-
thermore, the refresh interval oﬀers a potential vulnerability to attack. Second,
Patagonix does not support JIT compiled code. It can detect and report the
presence of the JIT engine, but it ignores the JIT code itself. In contrast, Dymo
handles these issues.
The problems with static code identity that we have described are closely
related to those surrounding data integrity tools, such as Tripwire [12]. This
has led to the development of various program-level anomaly detection systems
that focus on characterizing application behavior, typically by monitoring sys-
tem calls [6] and their arguments [13]. Likewise, work in the area of digital
rights management (DRM) has recognized how brittle static hashing is for con-
tent identiﬁcation purposes, and so more robust hashing mechanisms have been
proposed [8].
Remote Identiﬁcation. Sailer et al. present an approach to integrity measure-
ment that uses a Trusted Platform Module (TPM) to identify applications for
remote attestation [20]. The hashes are computed at application load-time, so
the identity measurements are fundamentally static. Dymo, on the other hand,
implements a dynamic code identity primitive that also measures changes to the
process during run-time. Haldar et al. argue that traditional remote attestation
techniques attest to the (static) identity of a binary, when, in fact, it is an at-
testation to the application’s behavior that is desired. Their proposal, semantic
remote attestation [9], is complementary to ours.
Network access control systems regulate hosts’ access to the network by en-
suring that they abide by a given policy (e.g., the hosts are fully patched and
are running updated antivirus software). Policies are enforced either by agents
on the hosts themselves or in the network [7].
Pedigree [19] is an example of a distributed information ﬂow tracking system
that uses taint sets to record interactions between processes and resources, and
it attaches these taint sets to network packets in order to exchange information
between hosts. Distributed information ﬂow tracking systems are related to our
network extension to Dymo, but the semantics of labels is diﬀerent.
8 Conclusions
This paper presents Dymo, a system that provides a dynamic code identity
primitive that enables tracking of the run-time integrity of a process. Our sys-
tem deploys a host-based monitoring component to ensure that all code that
is associated with the execution of an application is reliably tracked. By dy-
namically monitoring the identity of a process in a trustworthy fashion, Dymo
enables an operating system to enforce precise application-based access control
policies, such as malware detection, application whitelisting, and providing dif-
ferent levels of service to diﬀerent applications. In addition, we implemented
an application that extends Dymo so that network packets are labeled with
information that allows one to determine which program is responsible for the
generation of the traﬃc. We have developed a prototype of our approach for the
Windows XP operating system, and we have evaluated it in a number of realistic
settings. The results show that our system is able to reliably track the identity
of an application while incurring an acceptable performance overhead. Future
work will focus on extending this approach to other platforms (such as Linux)
and on developing sophisticated network-level policy enforcement mechanisms
that take advantage of our identity labels.
Acknowledgments. This work was partially supported by ONR grant N0001-
40911042, ARO grant W911NF0910553, NSF grants CNS-0845559 and CNS-0-
905537, and Secure Business Austria.
References
1. Bayer, U., Habibi, I., Balzarotti, D., Kirda, E., Kruegel, C.: A View on Current
Malware Behaviors. In: 2nd USENIX Workshop on Large-Scale Exploits and Emer-
gent Threats (2009)
2. Bhatkar, S., DuVarney, D., Sekar, R.: Address Obfuscation: An Eﬃcient Approach
to Combat a Broad Range of Memory Error Exploits. In: 12th USENIX Security
Symposium (2003)
3. Blazakis, D.: Interpreter Exploitation. In: 4th USENIX Workshop on Oﬀensive
Technologies (2010)
4. Chen, C., Xu, J., Sezer, E., Gauriar, P., Iyer, R.: Non-Control-Data Attacks Are
Realistic Threats. In: 14th USENIX Security Symposium (2005)
5. Fewer, S.: Reﬂective DLL Injection. Tech. rep., Harmony Security (2008)
6. Forrest, S., Hofmeyr, S.A., Somayaji, A., Longstaﬀ, T.A.: A Sense of Self for UNIX
Processes. In: 17th IEEE Symposium on Security and Privacy (1996)
7. Frias-Martinez, V., Sherrick, J., Stolfo, S.J., Keromytis, A.D.: A Network Access
Control Mechanism Based on Behavior Proﬁles. In: 25th Annual Computer Secu-
rity Applications Conference (2009)
8. Haitsma, J., Kalker, T., Oostveen, J.: Robust Audio Hashing for Content Identi-
ﬁcation. In: 2nd International Workshop on Content-Based Multimedia Indexing
(2001)
9. Haldar, V., Chandra, D., Franz, M.: Semantic Remote Attestation A Virtual Ma-
chine Directed Approach to Trusted Computing. In: 3rd USENIX Virtual Machine
Research and Technology Symposium (2004)
10. Hardy, N.: The Confused Deputy. Operating Systems Review 22(4), 36–38 (1988)
11. Hunt, G., Brubacher, D.: Detours: Binary Interception of Win32 Functions. In: 3rd
USENIX Windows NT Symposium (1999)
12. Kim, G.H., Spaﬀord, E.H.: The Design and Implementation of Tripwire: A File
System Integrity Checker. In: 2nd ACM Conference on Computer and Communi-
cations Security (1994)
13. Kruegel, C., Mutz, D., Valeur, F., Vigna, G.: On the Detection of Anomalous
System Call Arguments. In: 8th European Symposium on Research in Computer
Security (2003)
14. Litty, L., Lagar-Cavilla, H.A., Lie, D.: Hypervisor Support for Identifying Covertly
Executing Binaries. In: 17th USENIX Security Symposium (2008)
15. Mandelin, D.: An Overview of TraceMonkey (July 2009), http://hacks.mozilla.
org/2009/07/tracemonkey-overview/
16. Microsoft Corporation: A detailed description of the Data Execution Prevention
(DEP) feature (September 2006), http://support.microsoft.com/kb/875352
17. Microsoft Corporation: Windows Vista Application Development Requirements for
User Account Control (UAC) (April 2007), http://msdn.microsoft.com/en-us/
library/aa905330.aspx
18. Parno, B., McCune, J.M., Perrig, A.: Bootstrapping Trust in Commodity Com-
puters. In: 31st IEEE Symposium on Security and Privacy (2010)
19. Ramachandran, A., Bhandankar, K., Tariq, M.B., Feamster, N.: Packets with
Provenance. Tech. Rep. GT-CS-08-02, Georgia Institute of Technology (2008)
20. Sailer, R., Zhang, X., Jaeger, T., van Doorn, L.: Design and Implementation of a
TCG-based Integrity Measurement Architecture. In: 13th USENIX Security Sym-
posium (2004)
21. Saltzer, J.H., Schroeder, M.D.: The Protection of Information in Computer Sys-
tems. Proceedings of the IEEE 63(9), 1278–1308 (1975)
22. Shacham, H.: The Geometry of Innocent Flesh on the Bone: Return-into-libc with-
out Function Calls (on the x86). In: 14th ACM Conference on Computer and
Communications Security (2007)
23. Zeigler, A.: IE8 and Loosely-Coupled IE (LCIE) (March 2008), http://blogs.
msdn.com/b/ie/archive/2008/03/11/ie8-and-loosely-coupled-ie-lcie.aspx
24. Zetter, K.: Google Hack Attack Was Ultra Sophisticated, New Details Show (Jan-
uary 2010), http://www.wired.com/threatlevel/2010/01/operation-aurora/