02
. dynamic
0
除了文件的类型与普通程序不同以外，其他几乎与普通程序一样。还有有一点比较不同
的是，动态链接模块的装载地址是从地址0x00000000开始的。我们知道这个地址是无效地
址，并且从上面的进程虚拟空间分布看到，Lib.so的最终装载地址并不是0x00000000，而是
0xb7efc000。从这点我们可以推断，共享对象的最终装载地址在编译时是不确定的，而是
在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给
相应的共享对象。
当然，这仅仅是一个推断，至于为什么要这样做，为什么不将每个共享对象在进程中的
地址固定，或者在真正的系统中是怎么运作的，我们将在下一节进行解释。
7.3地址无关代码
7.3.1固定装载地址的困扰
通过上一节的介绍我们已经基本了解了动态链接的概念，同时，我们也得到了一个问题，
那就是：共享对象在被装载时，如何确定它在进程虚拟地址空间中的位置？
为了实现动态链接，我们首先会遇到的问题就是共享对象地垃的冲突问题，让我们先来
回顾一下第2章提到的，程序模块的指令和数据中可能会包含一些绝对地址的引用，我们在
链接产生输出文件的时候，就要假设模块被装载的目标地址。
很明显，在动态链接的情况下，如果不同的模块目标装载地址都一样是不行的。面对于
单个程序来讲，我们可以手工指定各个模块的地址，比如把0x1000到0x2000分配给模块A，
把地址0x2000到0x3000分配给模块B。但是，如果某个模块被多个程序使用，甚至多个模
块被多个程序使用，那么管理这些模块的地址将是一件无比繁项的事情，比如一个很简单的
情况，一个人制作了一个程序，该程序需要用到模块B，但是不需要用到模块A，所以他以
为地址0x1000到0x2000是空闲的，于是分配给了另外一个模块C.这样C和原先的模块A
的目标地址就冲突了，任何人以后将不能在同一个程序里面使用模块A和C，想象一个有
着成千上万个并且由不同公司和个人开发的共享对象的系统中，采用这种手工分配的方式儿
程序员的自我修养一链接、装载与库
---
## Page 212
7.3地址无关代码
189
乎是不可行的。
不幸的是，早期的确有些系统采用了这样的做法，这种做法叫做静态共享库（Static
Shared Library），请注意，它跟静态库（StaticLibrary）有很明显的区别。静态共享库的做
法就是将程序的各种模块统一交给操作系统来管理，操作系统在某个特定的地址划分出一些
地址块，为那些已知的模块预留足够的空间。
静态共享库的目标地址导致了很多问题，除了上面提到的地址冲突的问题，静态共享
库的升级也很成问题，因为升级后的共享库必须保持共享库中全局函数和变量地址的不
变，如果应用程序在链接时已经绑定了这些地址，一且更改，就必须重新链接应用程序，
否则会引起应用程序的期溃。即使升级静态共享库后保持原来的函数和变量地址不变，只
是增加了一些全局函数或变量，也会受到限制，因为静态共享库被分配到的虚拟地址空间
有限，不能增长太多，否则可能会超出被分配的空间。种种限制和弊端导致了静态共享库
的方式在现在的支持动态链接的系统中已经很少见，面彻底被动态链接取代。我们只有在
一些不支持动态链接的旧系统中还能看到静态共享库的踪影。目前知道的使用静态共享库
的旧系统有：
·UNIX System V Release 3.2 (COFF format)。
● I的) Linux systems (a.out format)。
● BSD/OS derivative of 4.4BSD ( a.out and ELF formats.)。
为了解决这个模块装载地址固定的问题，我们设想是否可以让共享对象在任意地址加
的位置。与此不同的是，可执行文件基本可以确定自已在进程虚拟空间中的起始位置，因为
可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址，比如Linux下。
般都是0x08040000，Windows下一般都是0x0040000。
7.3.2装载时重定位
为了能够使共享对象在任意地址装载，我们首先能想到的方法就是静态链接中的重定
位。这个想法的基本思路就是，在链接时，对所有绝对地址的引用不作重定位，而把这一步
推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有
的绝对地址引用进行重定位。假设函数foobar相对于代码段的起始地址是0x100，当模块被
装载到0x10000000时，我们假设代码段位于模块的最开始，即代码段的装载地址也是
0x10000000，那么我们就可以确定foobar的地址为0x10000100。这时候，系统遍历模块中
的重定位表，把所有对foobar的地址引1用都重定位至0x10000100。
事实上，类似的方法在很早以前就存在。早在没有虚拟存储概念的情况下，程序是直接
程序员的自我修养—链接、装载与库
---
## Page 213
190
第7章动态键接
被装载进物理内存的。当同时有多个程序运行的时候，操作系统根据当时内存空闲情况，动
态分配一块大小合适的物理内存给程序，所以程序被装载的地址是不确定的。系统在装载程
序的时候需要对程序的指令和数据中对绝对地址的引用进行重定位。但这种重定位比前面提
到过的静态链接中的重定位要简单得多，因为整个程序是按照一个整体被加载的，程序中指
令和数据的相对位置是不会改变的，比如一个程序在编译时假设被装载的目标地址为
0x1000，但是在装载时操作系统发现0x1000这个地址已经被别的程序使用了，从0x4000
开始有一块足够大的空间可以容纳该程序，那么该程序就可以被装载至0x4000，程序指令
或数据中的所有绝对引用只要都加上0x3000的偏移量就可以了。
我们前面在静态链接时提到过重定位，那时的重定位叫做链接时重定位（LinkTime
Relocation），面现在这种情况经常被称为装载时重定位（LoadTimeRelocation），在
Windows中，这种装载时重定位又被叫做基址重置（Rebasing），我们在后面将会有专门章
节分析基址重置。
这种情况与我们碰到的问题很相似，都是程序模块在编译时目标地址不确定而需要在装
载时将模块重定位。但是装载时重定位的方法并不适合用来解决上面的共享对象中所存在的
问题。可以想象，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享
的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，
因为指令被重定位后对于每个进程来讲是不同的。当然，动态连接库中的可修改数据部分对
于不同的进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决。
Linux和GCC支持这种装载时重定位的方法，我们前面在产生共享对象时，使用了两
装载时重定位的方法。
7.3.3地址无关代码
那么什么是“-PIC”呢？使用这个参数会有什么效果呢？
装载时重定位是解决动态模块中有绝对地址引用的办法之一，但是它有一个很大的缺点
是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势，我们还
需要有一种更好的方法解决共享对象指令中对绝对地址的重定位问题，其实我们的目的很简
单，希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现
为地址无关代码（PIC,Position-independent Code）的技术。
对于现代的机器来说，产生地址无关的代码并不麻烦。我们先来分析模块中各种类型的
程序员的自我修养——链接、装载与库
---
## Page 214
7.3地址无关代码
191
地址引用方式。这里我们把共享对象模块中的地址引用按照是否为跨模块分成两类：模块内
部引用和模块外部引用：按照不同的引用方式又可以分为指令引用和数据访问，这样我们就
得到了如图7-4中的4种情况。
·第一种是模块内部的函数调用、跳转等。
·第二种是模块内部的数据访问，比如模块中定文的全局变量、静志变量。
·第三种是模块外部的函数调用、跳转等。
·第四种是模块外部的数据访问，比如其他模块中定义的全局变量。
static int ar
extern vold ext (1:
extern int bi
vo1d bar ()
1:
rz = q
void foo()
bsr();
 Type 1, Inner-module call
ext () : *
Type 3, Inter-module cal
图7-44种寻址模式
关于模块内部和模块外部
当编译器在编译pic.c时，它实际上并不能确定变量b和函数extl是模块外部的还是
模块内部的，因为它们有可能被定义在同一个共享对象的其他目标文件中。由于没法
确定，编译器只能把它们都当作模块外部的函数和变量来处理。MSVC编译器提供了
_decispecidllimport编译器扩展来表示一个符号是模块内部的还是模块外部的。
类型一模块内部调用或跳转
这4种情况中，第一种类型应该是最简单的，那就是模块内部调用。因为被调用的函数
与调用者都处于同一个模块，它们之间的相对位置是固定的，所以这种情况比较简单。对于
现代的系统来讲，模块内部的跳转、函数调用都可以是相对地址调用，或者是基于寄存器的
相对调用，所以对于这种指令是不需要重定位的，比如上面例子中foo对bar的调用可能产
生如下代码：
8048344 :
8048344 :
8048345 :
SS
sa 68
push
ebp
mOV
tebp
tesp, $ebp
8048347 :
:8+8+08
PS
pop
程序员的自我修养——链接、装载与库
---
## Page 215
192
第7章动态链接
8048349 :
8048357:
e8 e8 ff ff ff
804835c:
b8 00 00 00 00
nov
cal1
8048344 
$0x0, $eax
+ + 
foo中对bar的调用的那条指令实际上是一条相对地址调用指令，我们在第2部分已经
介绍过相对位移调用指令的指令格式，相对偏移调用指令如图7-5所示。
相对偏移调用指令call的指令码
目的地址相对于下一条指令的偏移
图7-5相对偏移调用指令
0xFFFFFFE8（Little-endian)。0xFFFFFFE8是-24 的补码形式，即 bar 的地址为 0x804835c +
(-24)=0x8048344。那么只要bar和foo的相对位置不变，这条指令是地址无关的。即无论
模块被装载到哪个位置，这条指令都是有效的。这种相对地址的方式对于jmp指令也有效。
这样看起来第一个模块内部调用或跳转很容易解决，但实际上这种方式还有一定的问
问题在后面关于“动态链接的实现”中还会详细介绍。但在这里，可以简单地把它当作相对
地址调用/跳转。
类型二模块内部数据访问
接着来看看第二种类型，模块内部的数据访问。很明显，指令中不能直接包含数据的绝
对地址，那么唯一的办法就是相对寻址。我们知道，一个模块前面一般是若干个页的代码，
后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，也就是说，任何一条指令与
它需要访问的模块内部数据之间的相对位置是固定的，那么只需要相对于当前指令加上固定
的偏移量就可以访问模块内部数据了。现代的体系结构中，数据的相对寻址往往没有相对与
当前指令地址（PC）的寻址方式，所以ELF用了一个很巧妙的办法来得到当前的PC值，
然后再加上一个偏移量就可以达到访问相应变量的目的了。得到PC值的方法很多，我们来
看看最常用的一种，也是现在ELF的共享对象里面用的一种方法：
0000044c :
44c:
4 4d :
55
89 e5
push
$ebp
44f :
00000008
30V
ca11
$esp, $ebp
494
程序员的自我修养一链接、装载与库
---
## Page 216
7.3地址无关代码
193
454 :
81 c1 8c 11 00 00
00000001
add
$0x118c,%ecx
45a:
c7 81 28
$0x1,0x28(%ecx)
// a = 1
461:
464 :
0000
8b 81
00
f8 ff ff ff
mov 0xfffffff8(eecx),seax
470 :
4 6a :
5d
c7
00
02000000
pop
mov1
$0x2, ($eax)
tebp
/ / b =
471:
c3
00000494 1
494 :
497 :
8b 0c 24
ret
moV
(tesp) , Becx
c3
这是对上面的例子中的代码先编译成其享对象然后反汇编的结果，用租体表示的是barO
函数中访问模块内部变量a的相应代码。从上面的指令中可以看到，它先调用了一个叫
“_i686.geL_pc_thunk.cx”的函数，这个函数的作用就是把返回地址的值放到ecx寄存器，
即把call的下一条指令的地址放到ecx寄存器。
我们知道当处理器执行call指令以后，下一条指令的地址会被压到栈项，而esp寄存
器就是始终指向栈项的，那么当“_i686.get_pc_thunk.cx*执行“mov（%espl,%ecx”
的时候，返回地址就被赋值到ecx寄存器了。
接着执行一条add指令和一条mov指令，可以看到变量a的地址是add指令地址（保
存在ecx寄存器）加上两个偏移量0x118c和0x28，即如果模块被装载到0x10000000这个地
址的话，那么变量a的实际地址将是0x10000000+0x454+0x118c+0x28=0x10001608，这