CVE-2022-33891: Apache Spark shell
command injection vulnerability via Spark
UI
影响版本
Apache Spark versions 3.0.3 and earlier, versions 3.1.1 to 3.1.2, and versions 3.2.0 to 3.2.1.
分析
⾸先看到官⽅描述
https://lists.apache.org/thread/p847l3kopoo5bjtmxrcwk21xp6tjxqlc
当中可以根据提⽰找到diff：
https://github.com/apache/spark/pull/36315/files
这⾥没做⽆害处理，直接对命令进⾏拼接造成命令注⼊
如图那么漏洞原理确实很简单，那么接下来就要看如何触发了
⾸先关于配置可以参考：https://spark.apache.org/docs/3.0.3/security.html
⼀个漏洞能利⽤的最简配置，当然不⼀定是和acl相关的最佳配置，毕竟还有其他参数，当然
作为漏洞研究就这样开启就好，其中[]为可选项意思是不⽤加都⾏
分析可以得到调⽤链
org.apache.spark.ui.HttpSecurityFilter.doFilter()
org.apache.spark.SecurityManager.checkUIViewPermissions()
org.apache.spark.SecurityManager.isUserInACL()
org.apache.spark.util.Utils.getCurrentUserGroups()
org.apache.spark.security.ShellBasedGroupsMappingProvider.getGroups()
org.apache.spark.security.ShellBasedGroupsMappingProvider.getUnixGroups()
./bin/spark-shell --conf spark.acls.enable=true --conf spark.ui.port=8099 
--conf spark.ui.view.acls=true [--conf 
spark.user.groups.mapping=org.apache.spark.security.ShellBasedGroupsMappin
gProvider]
这个HttpSecurityFilter，很明显是⼀个filter，其实猜都能猜到既然是和权限校验相关那么肯定
是所有路由都会经过这个filter的，当然也能找到这样的代码⽚段来验证
接着回来我们可以看到它参数来源于doAs
那就很简单了
val securityFilter = new HttpSecurityFilter(conf, securityMgr)
val holder = new FilterHolder(securityFilter)
handler.addFilter(holder, "/*", EnumSet.allOf(classOf[DispatcherType]))