possible attribute values to determine the plaintext of the
attribute values for each users. Such a server can use this
type of data for targeted ad campaigns.
• Honest-but-curious user where the user acts in an ‘hon-
est’ fashion to obtain the correct proﬁle matching results,
but ‘curious’ fashion to obtain other users’ exact proﬁle
attribute data by eavesdropping the communications or
colluding with the untrusted server. Such a user can use
this type of data to impersonate other users at a later time.
• Malicious server where a compromised server does not
follow the designated protocol but returns fake proﬁle
matching results to the user. Similar to the works in the
literature [8], [9], [12], [14], [15], the service provider
would not allow the user outside to access the dataset
or affect the computation results for security reasons and
public reputation reasons.
To address the adversary models above, a privacy-preserving
proﬁle matching scheme for mobile social services is pro-
posed. Our scheme, S-MATCH, achieves security and perfor-
mance guarantees as follows:
• Privacy: The untrusted server does not learn additional
information of the users’ social proﬁles. Speciﬁcally, even
if the server knows that an intercepted ciphertext has
plaintext from a set of known plaintext range, a secure
scheme will prevent
the attacker from extracting the
plaintext. Thus, the scheme is protected from plaintext
recovery attack. Also, each user cannot obtain other
users’ proﬁles.
• Veriﬁcation: The proﬁle matching result that indicates a
match is for users with similar social proﬁles. Fake proﬁle
matching results from the server are detected.
• Performance: The above goals for privacy and veriﬁcation
should be power efﬁcient with low computation overhead
on resource-constrained mobile devices.
VI. S-MATCH: MATCHING PROFILES SECRETLY
In this section, we introduce the details of the proposed
privacy-preserving proﬁle matching scheme after showing the
overview of the system.
A. System Overview
Our proposed scheme has three steps. First, users bootstrap
the privacy proﬁle matching process by increasing the entropy
so that the privacy-preserving proﬁle matching is processed
on the high-entropy attribute chains encrypted by the PPE
scheme. Then, each user commits her proﬁle information
and user ID to the server with authentication information
ciphi. Second, after obtaining the proﬁle matching request
291291291
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:04:56 UTC from IEEE Xplore.  Restrictions apply. 
User Community
Untrusted Server
Au1 Au2 AuN
….
Step 1
Key Generation
Entropy Increase
Attribute Chaining
Make Authentication
Step 2
Query request
( time stamp, 
query ID, user ID )
Step 5
Verify Query Result
Y/N
ciphi
Step 3
Privacy-preserving
Profile Matching
Step 4
Query result
( userID1 ciph1 
…,userIDi, ciphi  )
Query User
Fig. 2. Overview of the PPE-based privacy-preserving proﬁle match-
ing scheme.
Qq =, the untrusted server conducts the efﬁcient
privacy-preserving proﬁle matching process, then returns the
matching result Rq = to
user v, where q is the query ID, t is the time-stamp, IDi is the
identity of matching user i in the mobile social service, and
ciphi is user i’s authentication information for the querying
user to verify the query results. Finally, with the authentication
information ciphi of user i, the querying user v can verify
whether the proﬁle matching result, which states user i is a
match, is correct or not. The overview of S-MATCH is shown
as in Figure 2.
Key Generation. To address the key sharing problem while
guaranteeing correct proﬁle matching using ciphertext, we
propose a fuzzy key generation scheme to generate the keys
for OPE. In our scheme, the users with similar proﬁles will
generate the same key. The fuzzy key generation solves the key
sharing problem and improves the efﬁciency of the privacy-
preserving scheme.
For this, we utilize a cyclic error-correcting decoding func-
tion (e.g., the Reed-Solomon decoding function [32]–[34]) to
generate a proﬁle key, where the users with the Euclidean-
distance close proﬁles will generate the same proﬁle key.
Speciﬁcally,
the proﬁle of user v is decoded by a Reed-
Solomon decoder (RSD) to obtain a fuzzy vector T (v), and
the proﬁle key is generated by the fuzzy vector T (v), i.e.,
Kvp = H(T (v)), where H() is a one-way hash function. With
RSD, the Euclidean-distance close proﬁles (i.e., (cid:7) Au−Av (cid:7)≤
θ, where θ is the threshold of the RS Decoder) will be
transformed to the same fuzzy vector and the users with the
close proﬁles will generate the same proﬁle key. To protect
the key generation scheme from an ofﬂine brute-force attack,
the proﬁle key Kvp is encoded as a pseudo-random number
by OPRF.
Deﬁnition 3: Given the ordered series of user u and user
v’s attribute values, denoted by Au and Av, the Euclidean
distance of the proﬁles between user u and user v is deﬁned
as follows:
(cid:7) Au − Av (cid:7)= M AX{a
(u)
i − a
(v)
i },
(2)
where i ∈ {1, 2 . . . d} and a
u.
(u)
i
is the attribute value of user
The Reed-Solomon cyclic error-correcting codes (RS code)
are constructed using Galois Fields and source symbols are
viewed as coefﬁcients of a polynomial over the Galois Fields.
The RS code we are interested in are (n,d)-codes, where d
is the number of attribute values as the source symbols, and
n = 210 as Galois Field GF (10) is utilized.
Entropy Increase. To reduce the information leakage, the
mobile user increases the entropy of each attribute while
guaranteeing that the probability distributions of the proﬁle
attributes are uniform. The idea behind this technique is to
construct a big-jump mapping of the attribute values with equal
probability, where one proﬁle attribute value is mapped to N
values to increase the uncertainty. For the big-jump mapping
function f, there exists some big jumps f (i + 1) − f (i) ≥
f (i) − f (j), where 1 ≤ j < i − 1. To quantify the privacy
of the scheme, we use a k-bit-binary string to represent the
value of the attribute. In other words, the message space is 2k.
For the proﬁle attribute Ai with ni possible values a
and
j , where j ∈ {1, 2 . . . ni},
the corresponding probability p
(i)
each attribute value a
j Δ binary strings in
2k(j−1)
ni−1 + R] , where Δ is a conﬁgurable
the range [
constant value and the range R < 2k
2ni−1. And, users with
· Δ binary
(i)
attribute value a
j
j Δ as their mapping attribute
strings with equal probability
value. Hence, after mapping, each attribute value is chosen
with equal probability of 1
Δ. The big-jump mapping has three
beneﬁts: First, the entropy of the attribute Ai increases under
the one-to-N mapping. Second, different attributes are uniﬁed
to the same measurement of k bits. Third, even though the
same attribute values are mapped then encrypted with different
ciphertexts, the proﬁle matching results will not change if the
proﬁles are the Euclidean-distance close. We will show the
correct matching rate under different Euclidean-distances in
Section IX.
choose any one of the p
is mapped to p
1
p(i)
(i)
j
2k(j−1)
ni−1 ,
(i)
(i)
j
(i)
j
As an example, assume that the education social attributes
of 100 users have equal weights, with four values (high school
with probability 0.3, B.S. with probability 0.4, M.S. with
probability 0.2, Ph.D. with probability 0.1). To increase the
entropy of the education attribute, the users with attribute value
‘high school’ randomly choose one of 0.3Δ 64-bit binary
strings from the range [1, 6 × 108], the users with attribute
value ‘B.S.’ randomly choose one of 0.4Δ 64-bit binary string
from the range [1.4 × 109, 2 × 109], and so on.
Attribute Chaining. A naive approach to communicate
attribute data to the server is to encrypt each user’s attribute
with the OPE after increasing their entropy and then send them
to the untrusted server. Since the encrypted attribute values
have the order relationships, the untrusted server can compare
the order relationships of each encrypted attribute value to
obtain the proﬁle matching results (e.g., kNN matching [35],
MAX-distance matching [35]).
292292292
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:04:56 UTC from IEEE Xplore.  Restrictions apply. 
However, although it
is feasible to utilize the entropy-
increase technique above to increase the privacy of proﬁle
matching, the ciphertexts still face the landmark node problem
as we mentioned in IV . After the big-jump mapping, the en-
coded attribute values will not have uniform distribution in the
message space, and accordingly, neither will the corresponding
ciphertexts. Thus,
it makes easier for an untrusted server
to detect a landmark and to eventually obtain the plaintext.
Hence, after we increase the entropy of the attributes, they
are chained (i.e., combined) separately in random order. The
randomization is done to prevent an attacker from obtaining
the position of a speciﬁc attribute in the chain. Otherwise, the
attacker does not need to brute-force the entire attribute data
chain, but the speciﬁc string bits to obtain the attribute data
(which has smaller entropy than the entire data chain).
Note that we randomize the orders of proﬁle attributes in
the chain and then the ﬁnal chain is encrypted by OPE on the
mobile device before it is sent it to the server. The format of
the data message sent from user, U, to server, S, is as follows:
u → S : IDu, h(Kup), EKup (A(cid:2)
1)|| . . .||EKup (A(cid:2)
n)
(3)
where Ekup is the OPE with the user’s proﬁle key Kup,
A(cid:2)
1, . . . ,A(cid:2)
n is the entropy-increased attributes with random
order.
Proﬁle Matching. In the proﬁle matching step, the server
receives a proﬁle matching query from user u and tries to
ﬁnd the matching proﬁles for the interested user u. For this,
the server ﬁrst ﬁlters the stored encrypted proﬁles based
on h(Kup), then measures the distance between the stored
encrypted proﬁles and the encrypted proﬁle of the interested
user u.
Deﬁnition 4: The distance of user u and user v in the proﬁle
matching process at the server is deﬁned as follows:
d(u, v) =
d(cid:2)
i=1
O(A(cid:2)(u)
i
) − d(cid:2)
i=1
O(A(cid:2)(v)
i
)
(4)
i
i
where O(A(cid:2)(u)
) is the order of user u’s proﬁle attributes A(cid:2)(u)
.
With the comparable attribute values, the untrusted server
can process proﬁle matching using any matching algorith-
m (e.g., kNN matching and MAX-distance matching). For
instance, assume the users have two attributes: Gender and
Education. The message space is 60. Each user has a random-
order attribute chain. User A (Gender=0, Education=1) has
attribute chain 12|8, user B (Gender=0, Education=2) has
attribute chain 34|2, and user C (Gender=1, Education=3) has
attribute chain 50|48. Then, the order relationship in the server
among users is as follows: user A has order 20 in total, user
B has order 36 in total, and user C has order 98 in total. User
A’s proﬁle is matched with that of user B.
Proﬁle Veriﬁcation. Assume that user u wishes to verify
whether user v’s identity and proﬁle, which was matched
by the server, is similar to hers. In other words, the proﬁle
is exactly matching under the same property-preserving key
and exactly from the user the query results shows. However,
293293293
user v does not want to reveal her proﬁle attribute values.
The intuition behind our veriﬁcation scheme is based on the
reversed fuzzy-commitment [36], where a commitment can be
opened using a set of witnesses, which is close to the original
encoded witness.
For proﬁle veriﬁcation, each user u owns a secret value su
generated by a random value generator. h : G → (0, 1)
∗
is
a one-way hash function and p is a generator of the cyclic
group G. To generate the authentication information ciphv,
user v utilizes the proﬁle key Kvp based on the proﬁle Av to
encrypt the secret value, i.e., ciphv = EKvp (psv||h(psu·IDv )),
where E() is a symmetric encryption scheme (e.g., AES-256).
During the veriﬁcation, user u, whose proﬁle is close (i.e.,
(cid:7) Au − Av (cid:7)≤ θ, where θ is the threshold of the RS Decoder)
to that of user v, is able to decrypt user v’s authentication
by her proﬁle key Kup.
information ciphv = ciph
After obtaining the secret value psv, user v veriﬁes whether
holds. If yes, the
the equation h((ciph
proﬁle matching result, which states that user v is a match, is
considered as trustworthy.
(1)
v )IDv ) = ciph
v ||ciph
(2)
v
(2)
v
(1)
For instance, assume the users have four attributes: Gender,
Education, Interest 1 and Interest 2. User A has attribute chain
1|1|1|1, user B has attribute chain 2|2|2|3, and user C has
attribute chain 2|3|3|2. Let the threshold θ of the RS decoder
be 1, i.e., user B and user C with close Euclidean distance pro-
ﬁles will generate the same proﬁle key kp1 while user A will
generate a different proﬁle key kp2. When user B obtains the
authentication information ciphA and ciphC, she can decrypt
ciphC by her proﬁle key kp1 and obtain t = psC||h(psC·IDC ).
User B checks (psC )IDC equal to the latter part of ciphC
after hashing. In that case, the authentication information of
user C is decrypted by user B, which will not be done in the
authentication information of user A, because psA||h(psA·IDA )
is encrypted by a different proﬁle key kp2 and cannot be
decrypted by user B’s proﬁle key kp1 .
VII. SECURITY ANALYSIS AND PERFORMANCE
In this section, we ﬁrst present the syntax of our scheme
S-MATCH. Then we show the secruity analysis of S-MATCH
by formally deﬁning two attacks: the plaintext recovery under
ordered known plaintext attack and the plaintext recovery
under known key attack. Finally, cost analysis is given.
A. Syntax and Correctness
a
is
of
consists
for mobile
tuple
a
S − M AT CH
Deﬁnition 5: S-MATCH
proﬁle matching scheme
which
(Keygen, InitData, Enc, M atch, Auth, V f ).
privacy-preserving
social networks,
=
• Key generation: Kup ← Keygen(Au). Keygen runs at
the client’s mobile device. The user’s proﬁle data Au
is obtained from the proﬁle interfaces of current social
networks providers.
• Initialize data: Mu ← InitData(Au). InitData runs on
the client’s mobile device, which takes the user’s raw
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:04:56 UTC from IEEE Xplore.  Restrictions apply. 
(u))
Algorithm Keygen(Au)
(u) ← RSD(Au, θ)
1. T
(cid:2) ← H(T
2. K
3. return Kup ← RSA − OP RF (K
Algorithm InitData(Au)
1. Initialize the social proﬁle data by increase the entropy of
social proﬁle dataset.
2. Chain the social proﬁle data together with random order.
3. return Mu
(cid:2))
(2) The user u and the adversary S engage in a polynomial
number of rounds of interaction to recover plaintext M of the
ciphertext C. At round i,
• The adversary S obtains the plaintext-ciphertext pairs
(Mi, Ci).
• The adversary leads the interaction for the ordered search
in the server, with the adversary S observing all the states
of the server.
(3) The adversary S outputs M
of ciphertext C.
(cid:2), its guess for the plaintext
Algorithm Enc(Mu)
1. return OP E.Enc(Kup, Mu)
Algorithm M atch(v, C)
(cid:2) ← EXT RA(h(Kvp), C)
1. C
(cid:2) ← SORT (C
(cid:2))
2. C
3. pos ← F IN D(v, C
2 , pos − 1, ..., pos + 1, pos + k
4. return {pos − k
Algorithm Auth(u)
1. return AES.Enc(Kup, p
su||h(p
su·IDu ))
(cid:2))
2
Algorithm V f (IDv, ciphv, u)
1. t ← AES.Dec(Kup, ciphv)
2. parse t as two parts t1||t2
(cid:2) ← h(t
2. s
(cid:2) == t2) then b ← 1
3. if (s
4. else b ← 0
5. return b
IDv
1
)
We say the adversary S wins the game if its guess is correct
P R−OKP A
(cid:2)
S−M AT CH (S) be the value indicating the
(M
success of the adversary in the above game.
= M ). Let Adv
}
Theorem 1: A proﬁle matching scheme based on OPE is
P R−OCP A
PR-OKPA secure if for all adversaries S Adv
S−M AT CH (S) =
2e−1(2e−1) ≤ 1
ln (2e−2)+0.577
2κ , where κ is the security level parameter,
and e is the entropy of the plaintext.
Deﬁnition 7: PR-KK security game. The security game
between a user u and an adversary S proceeds as follows:
(1) The user u colludes with an adversary S by sharing his
proﬁle key Kup.
(2) The user u and the adversary S engage in a polynomial