例如：
p_system_____p_size
而在一些复杂的函数中，经常会碰到这种情况，读者需要适应。
图 42-21 p_system_____p_size
然后程序将argc也就是参数的数量和2进行比较。也就是可执行文件名称
148
从零开始学IDA逆向 42 函数指针利用
加上另一个参数。如果argc不等于2，程序会跳过下面的内容然后退出这个函
数。
图 42-22 argv
之前论述过argv是一个数组，第一个元素是可执行文件名称字符串保存的
位置而再加上4的话，就是第一个参数的字符串的地址。
图 42-23 argv
然后程序将这个字符串传给atoi函数转换为一个整数。如果转换失败则会
报错。
图 42-24 atoi函数说明
从atoi函数返回后，返回值保存到栈中的局部变量Size。
149
从零开始学IDA逆向 42 函数指针利用
图 42-25 Size变量1
图 42-26 Size变量2
不要将它和 p_system_____p_size 搞混了，p_system_____p_size
保存的是Size变量的地址。
然后程序将 Size 变量和 0x300 进行比较，如果大于这个数，程序将跳过
下面的内容从main函数返回。当然，这个Size变量是有符号数，因为后面的
跳转指令JGE说明了这一点。
150
从零开始学IDA逆向 42 函数指针利用
图 42-27 signed int
由于Size是个有符号数，那么将它赋值为一个负数，然后就会通过小于0
x300的比较。
当然如果 Size 变量作为其它 API 函数的 Size 参数，它会被视作为一个
无符号数，所以可能会导致溢出。例如如果Size等于-1，对于接受无符号数的
API来说它就是最大正整数0xFFFFFFFF。
图 42-28 sub_401010
图 42-28中sub_401010的参数就是Size。现在还不能重命名。需要观
察函数的行为。点击进入。
151
从零开始学IDA逆向 42 函数指针利用
图 42-29 sub_401010内部
由于函数内部有一个gets_s用于获取用户输入，所以作者将函数命名为i
ngreso，英文就是input。
gets_s有一个size参数是无符号数，有可能会导致溢出。
图 42-30 size_t
如图 42-30，gets_s的size参数类型为size_t。
图 42-31 size_t定义
因为size参数是无符号数，所以可以制造缓存区溢出。接下来查看缓存区
的长度。虽然这个程序写得很烂，但它也试图过滤掉size超过0x300得情况，
也许这就是缓存区的长度。
图 42-32 缓存区
152
从零开始学IDA逆向 42 函数指针利用
缓存区位于data区段，而IDA识别出它的长度是0x64，而缓存区的下方
是p_SetDEP和p_system____p_size这两个全局变量。
所以没有错。这个 0x300 的最大值，使得即使不输入负数也能造成这个 0
x64字节的缓存区溢出。只要Size大于0x64就行。
一旦超过 0x64 字节就可以继续向下覆盖 data 区段中缓存区下方的 2 个
指针。
那么程序是否会调用这些指针呢。
图 42-33 p_setDEP引用
从 p_setDEP 的引用来看有一处 call 指令使用了这个函数指针。如果覆
盖了这个指针，那么就可以执行其它的内容。
图 42-34 call p_setDEP
42.4 覆盖函数指针
153
从零开始学IDA逆向 42 函数指针利用
这个调用刚刚好在gets_s函数下方。非常好。接下来编写脚本。
图 42-35 编写脚本
这个脚本和之前使用的基本一致。作者将size设置为-1。这样就能通过比
较。而且作者设置了 0x64 个 A 字符来填充缓存区。然后作者用 0x99989796
来填充这个缓存区下方的指针。
由于 Mypepe.dll 的 ROP 在之前的章节中已经完成，所以可以直接使用。
下面来看看效果如何。
图 42-36 设置断点
执行脚本，并使用 IDA 来附加进程，之后在 gets_s 函数下方设置一个断
点。
154
从零开始学IDA逆向 42 函数指针利用
图 42-37 附加进程
图 42-38 缓存区
缓存区已经填充完毕。转到具体位置。按U键取消定义查看具体字符。检查
目标指针是否已覆盖。
155
从零开始学IDA逆向 42 函数指针利用
图 42-39 取消定义
图 42-40 p_setDEP
按D键直至将其转换为DWORD，发现它已经被目标值覆盖。
图 42-41 DEP状态
从Process Monitor中发现这个进程尚未开启DEP，因为脚本已经覆盖
了SetProcessDEPPolicy这个API函数。所以这里不需要采用ROP。
图 42-42 EAX的值
此时 EAX 指向填充 A 字符的缓存区。所以如果能跳转到这个位置，就能在
156
从零开始学IDA逆向 42 函数指针利用
这里设置shellcode并且执行。
那么在未开启ASLR的mypepe.dll中寻找call EAX指令。作者打开新
版KeyPatch插件并使用SEARCH功能，输入CALL EAX。
图 42-43 搜索CALL EAX
图 42-44 搜索结果
在搜索结果中，有一些属于mypepe.dll。作者从中选了一些。
例如图 42-45。
转到具体位置时，按C 键识别代码，因为这个动态链接库尚未实施反汇编。
157
从零开始学IDA逆向 42 函数指针利用
图 42-45 CALL EAX
那么0x7802C16E就是要寻找的CALL EAX。将它加到脚本当中。
图 42-46 0x7802C16E
作者将 shellcode 放在注入的最前端，因为 call eax 会跳转到缓存区
的最前端。而且为了保持指针前面的字符数不变，作者从 A 的数量中减去了 sh
ellcode的长度。而且不需要ROP，所以作者就删掉了它。
图 42-47 调出计算器
158
从零开始学IDA逆向 42 函数指针利用
所以最后成功调出了计算器。
159
从零开始学IDA逆向 43 堆溢出
43 堆溢出
43.1 new
本章来解决练习文件41b。
图 43-1 new
如果选择显示DEMANGLED NAMES – NAMES，看上去会好一些。如果还是
不显示函数的名称 new 的话，将会显示一个数字地址。new 和 malloc 是类似
的。在源代码中，new 是用于对象，而在 new 的内部本质上是调用 malloc 申
请地址，而且一个 size 参数传递给了 malloc 函数，但在这里没有什么差别。
除了使用 new 来创建类的实例，也可以调用类的构造函数，不需要使用 mallo
c。当然这里没有使用构造函数。
图 43-2 初始化实例
在源代码中使用new关键词创建了一个listeros实例，虽然不知道这个
160
从零开始学IDA逆向 43 堆溢出
类的具体作用，但是 listeros 类型的长度会在底层传给 malloc 函数申请内
存。所以这这个例子中，这两者没有太大区别。
图 43-3 DEMANGLED NAMES – NAMES
图 43-4 malloc
即使不知道它是函数 new，只是 IDA 告诉了用户。同样可以观察到函数内
部将size参数传递给了malloc函数，申请了对应长度的内存空间并且将地址
返回给EAX，如果malloc函数申请成功，将会返回一个非零值，然后函数沿着
图 43-5中红色箭头执行返回。
161
从零开始学IDA逆向 43 堆溢出
图 43-5 成功申请返回
所以在一般情况下，即使不知道它是函数new，而是将它命名为_malloc，
因为函数内部最终就是调用 malloc 函数，也是可以的。如果 IDA 没有识别出
来，那就是申请 0x6C 的内存空间，也就是对象的长度。如果这也不清楚的话，
反正就是申请了0x6C的内存空间。
图 43-6 Dst
162
从零开始学IDA逆向 43 堆溢出
图 43-7 将Dst的值和0进行比较
程序将申请的内存指针保存在 Dst 变量。而且，作者将其重命名为 p_Dst
_Heap，因为它指向了在堆上申请的内存空间。malloc函数就是在堆上申请空
间并且返回地址。
如图 43-7，如果Dst的值不是0，说明申请空间成功，程序会转向绿色的
代码块，然后传递该地址并调用memset函数将堆缓存区清零。
43.2 溢出分析与实现
图 43-8 复制指针
接下来程序将该指针复制到另一个变量，将其重命名为p_Dst_Heap2，当
然不能使用重复的名字。
图 43-9 结构体
如图 43-9，作者怀疑这个new的作用是创建了一个结构体对象，而且对
象指针被存入 Buf 变量。然后 Buf 的值传入 EAX，在申请空间 0x68 的位置写
163
从零开始学IDA逆向 43 堆溢出
入函数system的地址，然后再0x64的位置写入SetProcessDEPPolicy的
地址。所以作者认为这个对象内部存在不同的数据类型，有可能它是一个长度为
0x6C 的结构体，而在 0x64 和 0x68 位置各有一个指针。接下来创建这个结构
体。
struct _listeros{
char Buf[0x64];
void * puntero1;
void * puntero2;};
接下来查看是否正确。这个结构体在起点是一个0x64长度的缓存区，然后
是2个指针字段或者说8个字节。如果没有问题，结构体长度就是0x6C。打开
菜单View-Open subviews-Local types添加这个结构体。
图 43-10 添加结构体
在选项卡中右键单击，选择INSERT，添加该字段。然后，右键单击选择S
YNCRONIZE TO IDB。
图 43-11中EAX和EDX都指向结构体的起点。分别按T键选择lister
os。
结果如图 43-12，当然可以使用更加描述性的名称。由于它是在Local t
ypes选项卡中定义的，重命名的话也必须在那里进行。
164
从零开始学IDA逆向 43 堆溢出
图 43-11 eax和edx
图 43-12 显示字段
图 43-13 setDEP
165
从零开始学IDA逆向 43 堆溢出
在 puntero2 第二处引用按 T 键，它也像上一个练习一样使用这个指针存
储size变量。所以对它进行重命名。
图 43-14 puntero2重命名
这个字段首先保存了system函数的指针，然后再保存size变量，所以用
长下划线分隔开来表明这个字段的用途。
然后和上一章一样，将argc和2进行比较，确定是可执行文件名和第二个
参数一共2个参数。
图 43-15 比较长度
下面的这部分代码和上一章也类似，读取用户输入的参数，然后转换为一个
整数，如果大于0x300，就会直接跳转到main函数结尾返回。
在这个练习中使用了JGE条件跳转，它是考虑符号的。所以输入一个负数，
小于0x300，就通过这个比较。
之后程序会加载mypepe.dll动态链接库。
166
从零开始学IDA逆向 43 堆溢出
图 43-16 sub_1251010
之后程序会调用 sub_1251010 函数，这个函数有 2 个参数，一个是结构
体的起点也就是Buf变量的值，另一个是用户输入的参数转换后的整数。
转到该函数内部。
图 43-17 函数内部
通过 gets_s 函数，程序接收用户输入，由于这个 size 变量可以是负数，
可能会导致溢出。而这边情况是，当程序调用malloc函数的时候，创建了一个
缓存区放置整个结构体。而结构体的内部有一个缓存区来接收用户输入。
如果一切正常，之前的检查能够过滤掉所有负数以及大于 0x64 的整数的
话，就不会存在溢出缓存区，甚至覆盖下方的指针的情况。
struct _listeros
{
char Buf[0x64];
167
从零开始学IDA逆向 43 堆溢出
void * puntero1;
void * puntero2;
};
但是无论如何，这里不仅能够溢出缓存区覆盖这些指针，甚至能够溢出整个
申请的0x6C空间，然后覆盖堆上的其它内容。
再往下就是程序如何利用setDEP这个指针。继续执行。
图 43-18 调用setDEP
为了覆盖这个指针，首先需要用0x64字节填充之前的缓存区导致溢出。
图 43-19 结构体定义
只要对上一个练习的脚本稍微修改，就能够使用了。注入最前面的内容是s
168
从零开始学IDA逆向 43 堆溢出
hellcode，然后再用其它内容填充0x64字节。通过调试查看程序运行。
图 43-20 修改脚本
图 43-21 附加进程
如图 43-22，EAX中就是跳转的指针，而EDX当中是缓存区的起点，也就
是shellcode的起点。
所以需要找到一条JMP EDX，CALL EDX或者PUSH EDX – RET，由于程
169