,result)))
，@body})
(TEST-MATH TEST-ARITHMETIC TEST-*): (=
(TEST-MATH TEST-ARITHMETIC TEST-+):
(TEST-MATH TEST-ARITHMETIC TEST-+):
{TEST-MATH
t "~:[FAIL;pass~]
TEST-MATH
()
TEST-ARITHMETIC TEST-+):
TEST-ARITHMETIC
www.TopSage.com
'check' to run individual test
(*35)15)
(+-1-3)-4)
(+
1
2)3)
9.7
总结
99
---
## Page 117
始探索由函数和数据类型组成的Common Lisp的丰富的标准库了。
出了deftest来抽象代码模式，使一个正常函数变成了一个测试函数。
测试函数，你就会认识到这些函数代表了特殊的一类值得有其自己的抽象方式的函数。因此你写
修复确实简单多了。
在这样构造，但你可以用几行程序写一个出来。在写出了combine-results以后，对check的
接下来你没有立即继续玩弄check，而是停下来沉迷于一个设计巧妙的微型语言。你梦想假如有
务是修正check，使其生成的代码可以返回一个用来指示所有测试用例是否均已通过的布尔值。
report-result的多个调用，从而得到了一个和最初AND版本一样简洁的test-+函数。
据。因此，你写了check宏来自动地正确调用report-result的细节。
生冗长和易错的代码，由于你不得不将测试表达式传递两次，一次作为值而另一次作为引用的数
术开始，将某些代码放进函数report-result中。不幸的是，你发现使用report-result会产
改进汇报结果的方式。
一个非短路的AND构造就好了，这样修复check就会非常简单了。回到现实以后，你认识到不存
至此，你已经掌握了函数、变量和宏的基础知识，有了一点儿使用它们的实践经验，可以开
100
借助deftest所提供的在测试定义和底层机制之间的抽象障碍，你可以无需修改测试函数而
在那一点上唯一剩下的就是对你报告测试结果的方式做一些进一步的改进。一旦你开始修改
在那一点上你调整了check的API，从而你可以开始看到check内部的工作方式。下一个任
 在编写check的时候，你认识到在生成代码的同时，也可以让对check的单一调用生成对
下一步是查看你是否可以将第二个版本重构得跟前面版本一样简洁。你从一个标准的重构技
第9章实践：建立单元测试框架
www.TopSage.com
---
## Page 118
10.1数字
理，同时也是因为某些字符串函数与它们的字符组成部分之间有着紧密的关系。
理该字符串。但我在这里讨论字符串则是因为多数字符串的相关函数会将它们作为单一值来处
真正的标量。字符串是字符的序列，你可以访问单独的字符并使用一个操作在序列上的函数来处
时具体描述不同对象的语法。
成"foo"，将数字写成123、1/23和1.23，以及把列表写成（abc）。我将在描述操作它们的函数
置数据类型都具有Lisp读取器所理解并且Lisp打印器可使用的特殊语法。所以你才能将字符串写
义的。因此为了学习一个数据类型，你只需学会那些与之一起使用的函数就行了。另外，多数内
现细节在很大程度上是隐藏的。从语言用户的角度来看，内置数据类型是由操作它们的函数所定
义对其的操作，并能将它们与内置数据类型集成起来。
你将在后续章节里看到的那样，CommonLisp另外还提供了几种定义新的数据类型的方式，能定
在，并且也因为它们可以跟语言的其余部分紧密集成，从而使其可以更容易地高效实现。但正如
量中，可以作为实参传递，也可以作为返回值返回以及在运行期创建。
植地表示文件名的抽象。函数在Lisp中也是第一类（fist-class）数据类型。它们可以被保存在变
和复数)、字符、字符串、数组（包括多维数组）、列表、哈希表、输入和输出流以及一种可移
现形式是编程的根本。”
本章将介绍内置的“标量”数据类型：数字、字符和字符串。从技术上来讲，字符串并不是
但目前将先从内置数据类型开始讲起。因为Lisp是一种高阶语言，不同的数据类型的具体实
Common Lisp为现代语言中常见的大多数数据类型都提供了内置支持：数字（整数、浮点数
② Mattel's Teen Talk Barbie.
① Fred Brooks，《人月神话》（Boston:Addison-Wesley,1995)，p.103。
正如Barbie所说，数学很难。?虽说Common Lisp并不能使其数学部分变得简单一些，但它确
而这些内置类型仅仅是开始。它们被定义在语言标准中，因此程序员们可以依赖于它们的存
数字、字符和字符串
www.TopSage.com
---
## Page 119
种可能与输入该数字时不同的规范化文本语法被打印出来。例如：
但读取器将把所有这些转化成同一个对象。当数字被打印回来时，比如在REPL中，它们将以一
转化成相同的对象表示。例如，你可以将整数10写成10、20/2、#xA或是其他形式的任何数字，
对于一个给定类型的数字来说，它可以有多种不同的字面表示方式，所有这些都将被Lisp读取器
Lisp求值器之间的分工——读取器负责将文本转化成Lisp对象，而Lisp求值器只处理这些对象。
Lisp标准甚至还指定了复域上无理和超越函数的主值和分支切断。
表达的实现上。“浮点数也被用于表示其真正数学值为无理数的计算结果。
作所得到的速度。因此CommonLisp也提供了几种浮点数，它们可以映射到适当的硬件支持浮点
比值是由成对的任意大小的整数表示的，所以比值可以表示任意精度的分数。?
不是限制在一个机器字的大小上。“而两个整数相除将得到一个确切的比值而非截断的值。并且
是易于在有穷计算机硬件上实现的近似数字。例如，Common Lisp中的整数几乎可以是任意大而
10/4=2。Lisp还曾经多次在高性能数值计算领域与FORTRAN竞争。
符号代数系统也是由Maclisp（一种CommonLisp的前身）写成的。此外，Lisp还一直在MIT这类
学家设计而成的，用作研究数学函数的工具。并且MIT的MAC项目的主要项目之一——Macsyma
实可以比其他编程语言在这方面简单不少，考虑到它的数学传统这并不奇怪。Lisp最初是由一位数
10.2
② 那些对于使用Common Lisp密集的数值计算感兴趣的人们应该注意到，如果单纯比较数值代码的性能，那么和诸
(①很明显，一个具有有限内存的计算机可以表示的数字大小在事实上仍然是有限的。更进一步，特定CommomLisp
最后，Common Lisp支持复数—通过在负数上获取平方根和对数所得到的结果。Common
 另一方面，对于高性能数值编程，你可能想要用有理数的精度来换取使用硬件的底层浮点操
102
③月
CL-USER> 20/2
CL-USER>10
可以用多种方式来书写字面数值，第4章已经介绍了一些例子。但你需要牢记Lisp读取器和
222144的数字。
般大的数字。例如，整个宇宙中原子的数量预计少于2269，而当前的Common Lisp实现可以轻易处理最大或超出
实现中使用的大数的实际表示在其所能表达的数字大小上可能有另外的限制，但这些限制通常会超出“天文数字”
10
作的代码。为这类优化调节数字代码超出了本书的范围，但这确实是可能的。
以使用声明来告诉ComomLisp关于你所使用的数字类型的信息，从而使其生成与C或FORTRAN编译器做相同工
理数和复数的支持，一个看来简单的加法操作比两个已知表达为机器字的数字相加做更多的事。尽管如此，你可
简单的表达式也比其他语言中看起来等价的a+b做更多的事。由于Lisp中动态类型的机制以及对诸如任意精度有
如C或FORTRAN这样的语言比起来，Common Lisp可能会更慢。这是因为在Common Lisp中即便是（+ab）这样
字面数值
第10章数字、字符和字符串
www.TopSage.com
---
## Page 120
的小数点。这个序列可能后接一个代表“计算机科学计数法”“的指数标记。指数标记由单个字
值。更多的比特可以获得更宽的范围和更高的精度。?
型在其表示中可以使用不同数量的比特，这意味着每个子类型可以表示跨越不同范围和精度的
实际类型。CommonLisp定义了四种浮点数子类型：短型、单精度、双精度和长型。每一个子类
面是一些有理数的例子，带有它们对应的规范化十进制表示：
一种进制来书写分母。另外，你可以将整数而非比值写成以十进制小数点结尾的十进制数。?下
注意，这些进制指示符将应用到整个有理数上一
数，其中n代表进制数（一定要以十进制书写）。超过9的附加“数字”从字母A-Z或a-z中获取。
而#X或#x则代表十六进制数（合法数字0-F或o-f）。你可以使用#nR以2到36的其他进制书写有理
二进制来读取，其中0和1是唯一的合法数字。前缀是#0或#o代表一个八进制数（合法数字0-7），
形式。
理数以“简化”形式打印，整数值以整数语法来打印，而比值被打印成分值和分母约分到最简的
数在读取后都被“规范化”，这就是10和20/2都被读成同一个数字的原因，3/4和6/8也是这样，有
符号、一个代表分子的数位序列、一个斜杠（）以及另一个代表分母的数位序列。所有的有理
用十进制以外的进制来书写有理数也是可能的。如果前缀是#B或#b，一个字面有理数将以
①通过改变全局变量*READ-BASE*，也有可能实现无需使用特别的进制标记即可改变读取器在数字上使用的默认
③
②
浮点数的基本格式是一个可选符号后跟一个非空的十进制数字序列，同时可能带有一个嵌入
也可以用多种方式来书写浮点数。和有理数不同，表示浮点数的语法可以影响数字被读取的
#36rABCDEFGHIJKLMNOPQRSTUVWXYZ
#b1010/1011
#b10101
9
-2/3
123.
-123
+123
123
“计算机科学计数法”加引号是因为，尽管其自从FORTRAN时就被广范用在计算机语言里，但它实际上和真正的
由于浮点数的目的是为了有效使用浮点硬件，因此每个Lisp实现都允许将这四种子类型映射到适当的原生浮点类
基数。不过这样可能会导致严重的混乱。
XDADA
10
但其却是一个完全不同的值，约等于54.6。
而进一步产生混淆的是，在真正的科学计数法中字母e代表自然对数的底。因此，1.0×e从表面上看类似于1.0e4
科学计数法很不相同，确切地说，像1.0e4这样的数字代表10000.0，而在真正的科学计数法中它表示为1.0×10。
3
3
www.TopSage.com
→8337503854730415241050377135811259267835
→
→
↑
→-123
→123
→123
L
56026
511
10/11
2
2/3
-2/3
一不可能以一种进制来书写比值的分值，而用另
on.
---
## Page 121
数字。使用超过两个参数来调用这其中的任何一个函数，这种作法将等价于在前两个参数上调用
复数语法写成的数字的例子：
成立的，但其中那些带有零虚部的复数总是一个与代表实部的浮点数不同的对象。下面是一些以
有理的，所以它们将用对应的有理数值来表示。同样的数学论据对于由浮点数所组成的复数也是
个将被提高。
个适当表示的浮点数。类似地，如果实部和虚部是不同表示法的浮点数，使用较小表示法的那一
种类型的复数。
表复数的实部和虚部。事实上因为实部和虚部必须同为有理数或相同类型的浮点数，所以共有五
数上。下面是一些浮点数的例子，带有它们的规范表示形式：
以区别于整数。浮点数中的数字总是以十进制数字来表示一
默认表示方式 （单浮点数)。
d、1（以及它们等价的大写形式）分别代表短型、单精度、双精度以及长型浮点数。字母e代表
母有两重作用：它标记了指数的开始并且指出该数字应当使用的浮点表示方式。指数标记s、f、
母后跟一个可选符号和一个数字序列组成，其代表10的指数用来跟指数标记前的数字相乘。该字
10.3
不过你可以随意书写它们。如果复数被写成由有理数和浮点数组成，该有理数将被转化成-
没有指数标记的数字以默认表示来读取，并且必须含有一个小数点后面还至少有一个数字，
尽管如此，没有复数可以具有一个有理的实部和一-个零的虚部，因为这样的值从数学上讲是
104
基本的算术操作即加法、减法、乘法和除法，通过函数+、-、＊、/支持所有不同类型的Lisp
#c{-6/3
#c(1/2
#c(2)
#c(2/33/4)
#c(2
最后，复数有它们自己的语法，也就是#C或#c跟上一个由两个实数所组成的列表，分别代
123d23
0.123e20 → 1
123E-3
123e-3
.123
0.123
123e0
#c(3.00.0)
#c{3
123.0
1.0
初等数学
第10章数字、字符和字符串
1.0)
1.0)
→1.23d+25
↑