obtain the secret key, which would allow them to decrypt all the passwords. This implies 
that this method is not as secure as it seems.
 Hashed Passwords
Hashing is similar to encryption in the sense that it transforms a password into a random 
string of letters and numbers. However, as already explained, hashing ensures at least 
two things. Firstly, it is infeasible to do the reverse of a hash. It is not possible to take the 
hashed password and run the hashing algorithm backward in order to get the original 
password. Secondly, it is very improbable that two different passwords will produce the 
same output of random string of letters and numbers.
78
Chapter 4 
 password-Based authentiCation
Hashing is, or at least used to be, the most widely used method for storing passwords 
both on a local network and on the Internet. A hash function works by taking a password 
as its input and scrambling it to produce a seemingly random result. Two popular hash 
functions used for storing passwords are MD5 and SHA-1. Examples of what passwords 
look like after being hashed are shown in Table 4-2.
Table 4-2.  Examples of Hashed Passwords
Password MD5
SHA-1
admin
21232f297a57a5a743894a0e4a801fc3
d033e22ae348aeb5660fc2140aec35850c4da997
password
5f4dcc3b5aa765d61d8327deb882cf99
5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8
superman
84d961568a65073a3bcf0eb216b2a576
18c28604dd31094a8d69dae60f1bcd347f1afc5a
d0raem0n
3cd70ea8040d94980c4644d6a3e29b3f
058ded9bbbadf334515454d8030bbff8c50b0f89
MtFbwY
b4e7d9a5aed04ac29736a311433dfde6
73160bfef9d2b95f4fce443d4283a13105279bb8
Hash functions are often used in password systems because instead of storing 
passwords in clear text, only the hash values of the passwords are stored. Since it is 
almost impossible to reverse the hash, the hashing method seems to be a secure way of 
keeping passwords.
When a user logs into a system, the hash value of the entered password is computed 
and compared with the hash in the password database. If they match, the password is 
correct. If not, the user will have to give another attempt. Moreover, since it is said that 
the hashes are unique, it is very likely that the user will only be able to log in with the 
correct password.
Unfortunately, over the past several years, a number of Internet companies found 
that their password databases had been cracked even though their users’ passwords had 
been hashed. The reason that this had occurred is because there is a downside to this 
method, which is a type of attack known as the rainbow table attack.
To go into a little bit more detail, the problem with simple hash functions is that it is 
possible for hackers to precompute hash values of a vast number of passwords and store 
them in a database. This database of precomputed hash values is known as a rainbow 
table. If a password database leaks, with the help of rainbow tables (which is essentially 
a list of billions of different hashes and their matching strings of text), hackers can just 
79
Chapter 4 
 password-Based authentiCation
look up the hashes in the rainbow table. In order to see how this works, just try typing 
5f4dcc3b5aa765d61d8327deb882cf99 into Google. It will quickly be seen that it is the 
MD5 hash for “password”.
If hashes are not found in the rainbow table, it means that they are the hashes for 
long and complex passwords that have not been precomputed yet. This is one reason 
why picking a long and complex password is a good idea, since hackers will not have 
had it already precomputed. In addition, it is a good place to mention a relatively new 
cryptographic hash function known as Argon2, which is actually a recommended 
function to be used for password storing. One special feature that Argon2 has is that it 
is possible to specify memory cost, time cost and hash length so that the hash function 
works in a less predicatable way, which in turn makes it harder to crack.
 Salted Passwords
A way to ease the concerns of the rainbow table is with a component called salt. Salting 
a hash means adding a random string of letters and numbers, called a salt, to the 
beginning or end of a password before hashing it. In other words, instead of just hashing 
a password, H(password), H(salt ‖password), or H(password ‖salt), where ‖ means 
concatenation, is computed.
Suppose a password, “password”, is chosen by a user. A random salt value such as 
“fh90$$PA28” is then generated by the system. Therefore, instead of just computing 
the hash value of “password”, H(password), H(passwordfh90$$PA28) is calculated 
to obtain the hash value 29e20a65f0d0336463b0391174ac74b3 for MD5 or the hash 
value b6ac9606d892f5af75ec9ceb39435a1e5f567dcf for SHA-1. Or if the system opts 
to put the salt value in front of the password, the hash value H( fh90$$PA28password) 
is computed to obtain 191673df9b0770e1a32cfd71ae00052e for MD5 and 
0debe946b686492301fe4ada680161e885ee8c34 for SHA- 1.
In order to illustrate the security of the salting method, the obtained hash values 
could be entered into Google, which acts as a rainbow table. One will see that no results 
are returned, which indicates that no corresponding text has been found. It can be seen 
that even though the original password is a weak password in “password”, the salt value 
can assist in reducing the risk of it being cracked via the rainbow table. Thus, it can be 
claimed that by using the salting method, password storage becomes more secure than 
the normal hashing method. However, the placement of the salt value has only been 
either as a prefix or a suffix of a password. This has raised one important question. That 
is, does the position of the salt value affect the strength of password storing?
80
Chapter 4 
 password-Based authentiCation
 Dynamic Salt Generation and Placement
It can be seen and confirmed with a simple example in the previous section that using a 
salt value as a prefix or a suffix of a password increases the security of password storage. 
However, there has been a study that demonstrates that with repeated experiments, it 
is possible for an attacker to find a fixed point of the salt placement. Once the position 
of the salt was found, the security would be drastically reduced by, again, the use of the 
rainbow table.
Rainbow table has become the main culprit of attacks on passwords. One particular 
reason is how quickly hashes can be computed. For hashing with the MD5 algorithm, 
it was found that to construct a rainbow table for alphanumeric passwords that were 
one to seven characters long, it would take approximately five days. Moreover, it would 
only take around three and a half days to carry out cryptanalysis on all possible hashed 
passwords in the rainbow table.
Fortunately, there is one way that can be used to reduce the risk of being attacked 
by the rainbow table. That is, to dynamically generate salt values and place them at 
appropriate positions so that the passwords become more tolerant to an attack.
It has been studied and revealed that the three factors that can affect the strength of 
the password storage are the quality of the password, the generation of the suitable salt 
value, and the way the salt value is placed into the password.
 Password Quality Adjustment
First of all, it is important to inspect the quality of the password registered by the user, 
before actually storing it. This is done to ensure that it becomes more difficult for an 
adversary to try to compromise it. During the password inspection process, the password 
quality index, explained in the “Quality of a Password” section, can be applied. The 
password quality index requires that a strong password should contain at least eight 
characters, three of which should be special characters, with some numbers to also be 
present.
If the quality of the password being inspected is lower than required, it will be 
adjusted accordingly. This is essentially the dynamic salt generation process. That is, for 
each password being inspected, a different salt value will be generated. Which salt value 
is generated depends on the quality and components of each password.
81
Chapter 4 
 password-Based authentiCation
For example, if the original password lacks special characters, some special 
characters will be added. If the password lacks number, random numbers will be 
generated and added to the password. This will also ensure that the length and quality of 
the password is at least of what is required.
 Suitable Salt Sizes
Speaking of the required length or size, it is necessary to produce a salt value of the 
suitable size for each password. It needs to be reemphasized that the quality of a 
password can be measured by the time taken to crack it. A harder-to-crack password 
should consist of at least eight characters that contain three or more special characters. A 
better password should contain numbers as well.
With the specified criteria, together with the study of rainbow table generation and 
computation of hash values, it is possible to analyze and determine a suitable size of a 
salt value. From previous studies, it has been found that if the input is nine characters 
long or larger, then it is very difficult to generate a complete rainbow table or the 
database with all possible plaintext and hash value pairs. Moreover, the time taken to 
hash any inputs that are 10 to 32 characters long would take approximately the same 
amount of time. Anything longer than 32 characters would take noticeably longer. 
Consequently, it has been claimed that the suitable sizes of a salt value is between 80 
and 256 bits or 10 and 32 characters.
The suitable sizes of a salt are now known. Thus, a salt value can be generated for 
each password. The question is how to integrate the salt value with the original password 
in such a way that the resultant string is strong enough to prevent attacks.
 Salt Placement
Before specifying where the salt value is to be placed in the password, a placement 
pattern needs to be generated. It is to be understood and realized that the placement 
pattern should be dynamic since it depends on the starting password and the chosen 
salt value. That means a different password and different salt value will have a different 
placement pattern. The placement pattern can be determined as follows.
First, the starting password is used as an input to a hash function, such as MD5, to 
obtain its hash value. Second, the password and its hash value are converted into binary. 
The next step is to XOR (⊕) the binary values of the starting password and its own hash 
82
Chapter 4 
 password-Based authentiCation
value. Only the least significant bit (rightmost bit) of each byte is to be XORed, however. 
The obtained value will then be used as the rule for the placement of the salt value. In 
order to make the pattern finding more intuitive, we provide a simple example as follows.
Suppose the starting password is password. The password is input 
into MD5, an example of a hash function, to obtain the hash value of 
5f4dcc3b5aa765d61d8327deb882cf99. For the pattern generation purpose, we will only 
take the first n bytes of the hash value, where n is the number of bytes of the password. In 
this example, password is eight bytes long, so only the first eight bytes of the hash value 
is used, which is 5f4dcc3b5aa765d6. The password and the hash value are converted into 
binary as shown in Table 4-3.
Table 4-3.  Password and Its Hash Value
password
01110000 01100001 01110011 01110011 01110111 01101111 01110010 01100100
hash value 01011111 01001101 11001100 00111011 01011010 10100111 01100101 11010110
Continue with the example, the binary values in Table 4-3 are XORed with one 
another. As stated, only the least significant bit of each resulting byte will be used as 
the placement pattern. Using the preceding example, the value 1010101010 is obtained 
from 0 ⊕ 1, 1 ⊕ 1, 1 ⊕ 0, 1 ⊕ 1, 1 ⊕ 0, 1 ⊕ 1, 0 ⊕ 1, and 0 ⊕ 0, respectively. This is the salt 
placement pattern for this particular password example.
As mentioned, the obtained value represents how the salt value is to be placed 
within the password. As far as the position of the salt value is concerned, it has to be 
noted that putting the salt in front of, in between, and at the back of the password will be 
avoided altogether. This is because having the salt in any of these positions is considered 
and proved insecure. Based on an analysis of a study, the following rule is used to 
determine how the salt value is going to be integrated into the password:
If the bit value of the pattern is 0, no salt is to be placed into the password at 
that position. If there are two consecutive 0 bits in the placement pattern, 
two salt characters are to be placed into the password at the position. If the 
bit value of the pattern is 1, one character of salt is placed into the password 
at that position. If bit values of the pattern run out and there are still unused 
salt  characters,  append  the  rest  of  the  salt  characters  to  the  end  of  the 
password.
83
 password-Based authentiCation
Chapter 4 
 How Does It All Work?
We have seen that in order to dynamically generate a salt value, the password quality has 
to be examined. After a suitable salt value has been generated, a placement pattern is 
determined prior to placing the salt into the password. These steps can be summarized 
in Figure 4-1.
Plaintext Password
Salt Insertion
Password Quality 
Checking
Strong Password 
Hashing
Salt Generation
Hash Value Storing
Salt Placement 
Pattern Generation
Figure 4-1.  Salt Generation and Placement Algorithm
We believe that it is best to explain how every step works together here so that the 
actual dynamic salt generation and placement algorithm can be intuitively followed.
Suppose a user enters a password to be registered on a system in plaintext format. 
The quality of the entered password is evaluated against the required criteria. A salt 
value is then generated in such a way that its size is appropriate for this particular 
password. Note that, with this method, each password will be provided with a different 
salt value. The objective of this step is to ensure that when combining the password with 
the salt value, a stronger password will be obtained before hashing or storing it.
84
Chapter 4 
 password-Based authentiCation
Once an appropriate salt value is acquired, a salt placement pattern will be 
computed. This is done by XORing the least significant bit of each byte of the original 
password with the least significant bit of each byte of its hash value. The next step 
is to insert the salt value into the password. This is done in accordance with the salt 
placement pattern, obtained earlier, and the salt placement rule, stated in the previous 
section.
What will be achieved at the end of this process is what is believed to be a stronger 
password. It will then be input to a one-way hash function. The resultant hash value is 
the value stored in the system’s password database.
 A Working Example
Now that we have seen the concept and steps necessary for dynamically generating and 
placing a salt value into a password in order to create a stronger password and more 
secure method of password storage, a working example is provided in this section. This 
is done in order to ensure that all the steps are understood and carried out correctly.
Suppose the starting password is password. As suggested by the algorithm, the 
password quality is examined. It turns out that the original password does not contain 
any special character or number, which means that it does not meet the strong password 
criteria. Next, a salt value is generated in such a way that when combining with the 
password, a stronger password is achieved. In this case, let us say that the salt value 
%@&03U+ is chosen.
The salt placement pattern can now be computed. This is done by XORing the least 
significant bit of each byte of password with the least significant bit of each byte of the 
first n bytes of its hash value, eight bytes in this case, to obtain 10101010, which is the salt 
placement pattern. Let us now insert the salt into the password. It should be reminded 
that at the moment, we have the original password, password; the salt value, %@&03U+; 
and the salt placement pattern, 10101010.
The salt insertion process begins by looking at the first character of the password, 
password, and the first bit of the placement pattern, whisch is 1. According to the salt 
placement rule, when the placement pattern is 1, a salt value is to be added at this 
position. Therefore, the first character of the salt value is taken and placed behind 
the first character of the password to obtain p%assword. We then look at the second 
character of the password and the second bit of the placement pattern.
85
Chapter 4 
 password-Based authentiCation
The second bit of the placement pattern is 0. According to the salt placement rule, 
when the placement pattern is 0, no salt is added at this position. We next look at the 
third character of the password and the third bit of the placement pattern.
The third bit of the placement pattern is 1. That means to be in accordance with the 
rule, one salt character is to be added at this position. We, therefore, obtain p%as@sword.
The next character and the next bit of the placement pattern are next to be 
considered. The current bit of the placement pattern now has the value of 0, which 
means nothing will be inserted at this position.
We are now at the fifth character of the password and the fifth bit of the salt 
placement pattern. The placement pattern bit has the value of 1. This means one 
character of the salt value will be placed behind the fifth character of the password, 
which now becomes p%as@sw&ord.
The next value of the placement pattern bit is 0, which means that no salt will be 
inserted at the current password position. The seventh bit of the placement pattern is 1. 
Therefore, one salt character will be inserted into the current password position. Thus, 
p%as@sw&or0d is obtained.
At this stage, the final character of the starting password and the final bit of the salt 
placement pattern are reached. Here, the final placement pattern bit has the value of 0, 
which means nothing is to be added. However, the salt placement pattern has now run 
out of bits, but there are still three salt characters left. The placement rule states that if 
this is the case, the remaining salt characters will be appended to the end of the current 
password. We, therefore, have p%as@sw&or0d3U+ as our result.