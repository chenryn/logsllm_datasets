title:Util: : Lookup: Exploiting Key Decoding in Cryptographic Libraries
author:Florian Sieck and
Sebastian Berndt and
Jan Wichelmann and
Thomas Eisenbarth
Util::Lookup: Exploiting Key Decoding in Cryptographic
Libraries
Florian Sieck
PI:EMAIL
University of Lübeck
Institute for IT Security
Germany
Jan Wichelmann
PI:EMAIL
University of Lübeck
Institute for IT Security
Germany
Sebastian Berndt
PI:EMAIL
University of Lübeck
Institute for IT Security
Germany
Thomas Eisenbarth
PI:EMAIL
University of Lübeck
Institute for IT Security
Germany
ABSTRACT
Implementations of cryptographic libraries have been scrutinized
for secret-dependent execution behavior exploitable by microarchi-
tectural side-channel attacks. To prevent unintended leakages, most
libraries moved to constant-time implementations of cryptographic
primitives. There have also been efforts to certify libraries for use
in sensitive areas, like Microsoft CNG and Botan, with specific
attention to leakage behavior.
In this work, we show that a common oversight in these libraries
is the existence of utility functions, which handle and thus pos-
sibly leak confidential information. We analyze the exploitability
of base64 decoding functions across several widely used crypto-
graphic libraries. Base64 decoding is used when loading keys stored
in PEM format. We show that these functions by themselves leak
sufficient information even if libraries are executed in trusted exe-
cution environments. In fact, we show that recent countermeasures
to transient execution attacks such as LVI ease the exploitability
of the observed faint leakages, allowing us to robustly infer suffi-
cient information about RSA private keys with a single trace. We
present a complete attack, including a broad library analysis, a
high-resolution last level cache attack on SGX enclaves, and a fully
parallelized implementation of the extend-and-prune approach that
allows a complete key recovery at medium costs.
CCS CONCEPTS
• Security and privacy → Cryptanalysis and other attacks;
Side-channel analysis and countermeasures.
KEYWORDS
Controlled-channel; constant-time; microarchitectural attacks; RSA
key recovery; SGX; transient execution
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484783
ACM Reference Format:
Florian Sieck, Sebastian Berndt, Jan Wichelmann, and Thomas Eisenbarth.
2021. Util::Lookup: Exploiting Key Decoding in Cryptographic Libraries. In
Proceedings of the 2021 ACM SIGSAC Conference on Computer and Commu-
nications Security (CCS ’21), November 15–19, 2021, Virtual Event, Republic of
Korea. ACM, New York, NY, USA, 18 pages. https://doi.org/10.1145/3460120.
3484783
1 INTRODUCTION
Due to the widespread adoption of cloud-computing and virtual
machines, architectural and microarchitectural attacks exploiting
shared resources have become a major concern for security-critical
applications [38, 51, 83]. Within the last decade, these attacks have
seen great advances [7, 59, 66, 81], culminating in jeopardizing the
security of trusted execution environments, cloud computing, and
finally revealing transient execution bugs in all modern proces-
sors [18, 19, 46, 50].
A popular target of these attacks are cryptographic implementa-
tions, as they contain critical information that is both compact and
used for extensive and often highly optimized computations. As a
result, cryptographic implementations have been analyzed for ex-
ploitable code behavior that leaks information in great detail. This
task has been significantly eased by the development of more auto-
mated analysis techniques, which are offered by tools like CacheAu-
dit [26], DATA [77] or Microwalk [78]. In fact, recent studies have
identified remaining exploitable code sections in cryptographic im-
plementations, with increasingly small leakages [8, 59, 74, 76] and
have resulted in a long stream of CVEs for these libraries. These
remaining leakages are getting smaller and more difficult to find
due to the vast effort that went into the analysis. Some libraries
have even been certified for secure implementation and design:
Microsoft Cryptography API: Next Generation (CNG) is periodically
FIPS-validated [57]; Botan has been extensively audited to be resis-
tant against common side-channel attacks, and is thus authorized
for use in sensitive applications [68].
At the same time, Intel has released numerous mitigations for
transient execution bugs which significantly altered the efficacy of
microarchitectural attacks, in particular in highly protected envi-
ronments such as Intel Software Guard Extensions (SGX). Coun-
termeasures to Foreshadow [18], also known as L1 Terminal Fault,
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2456now prevent L1 Cache attacks on SGX [39], while attacks exploit-
ing Simultaneous Multithreading (SMT) should be prevented by
enclave developers ensuring operation on private cores.
The full code for our attack is available on GitHub at https:
//github.com/UzL-ITS/util-lookup and https://github.com/UzL-ITS/
rsa-key-recovery.
1.1 Our Contribution
In this work, we show that despite the increasingly rigorous analy-
sis of cryptographic libraries, microarchitectural attacks are still a
threat. Our analysis finds that remaining issues are not in the cryp-
tographic routines that have been extensively analyzed by other
publications. Instead, we investigate utility functions, which are a
vital part of cryptographic libraries, but have thus far been ignored
in most studies. Clearly, these functions compute on sensitive data
and are thus potential subject to information leakage. In particular,
we focus on functionality that decodes secret keys from a format
suitable for storage and converts them into binary data used at
runtime. We show how such a functionality can be exploited via a
faint last level cache (LLC) leakage.
More concretely, we investigate RSA keys that are stored in the
popular PEM format, which uses base64 to encode binary data in
printable characters. The decoded information is later processed
in the constant-time cryptographic implementations of the library.
Usually, the leakage of the decoding process is quite faint and ex-
tremely difficult to exploit: Subsequent table accesses during decod-
ing are only few instructions apart and will be executed out-of-order,
resulting in extremely high noise, while featuring only minimal
leakage to begin with. In fact, even a powerful attack that combines
three different microarchitectural attack techniques, the page fault
side channel [80], the single-stepping of SGX-step [20], and a last-
level cache attack for spatial resolution of cache accesses [51] has
problems to distinguish two close cache hits in the LLC due to the
noise. Thus, other studies which already noticed such leakages in
key decoding [77] ignored these findings, likely because they were
not deemed exploitable, and the vulnerable code remained unfixed.
Many of the recent microcode updates render side-channel at-
tacks on SGX more difficult, in particular by flushing the L1 data
cache and reflecting the SMT state in the attestation. However,
it turns out that the recent mitigation against Load Value Injec-
tion (LVI) and the resulting serialization of memory accesses in
SGX enclaves enables us to sample the decoding with significantly
reduced noise and to obtain almost error-free leakage, even from a
single key loading event. To practically exploit the observed leak-
ages, we make use of state-of-the-art cryptanalytic methods.
In summary our contributions are:
• Fine-grained leakage analysis of the base64 decoding func-
tions for several common crypto libraries, including the cer-
tified Botan library.
• A sophisticated microarchitectural attack that manages to
extract the observed leakages from SGX enclaves with a sin-
gle observation, in spite of and because of the microcode and
countermeasures introduced by Intel in response to transient
execution attacks.
• An optimized RSA key recovery method including a highly
scalable implementation that, given medium resources, al-
lows to reconstruct the key from very weak leakages of 5
of the 6 redundant key parameters commonly used for RSA
key storage, as well as a thorough performance analysis.
1.2 Responsible Disclosure
We have informed the maintainers of all studied libraries about our
findings in December 2020.
• Botan: CVE-2021-24115, fixed with version 2.17.3
• GNU Nettle: No response, not yet fixed
• mbedTLS: CVE-2021-24119, fixed with version 2.26.0
• MS CryptoAPI: Declared as not urgent
• NSS: CVE-2021-29992, fixed with version 3.70
• OpenSSL: No response, not yet fixed
• RustSGX: CVE-2021-24117, fix in progress
• wolfSSL: CVE-2021-24116, fixed with version 4.6.0
2 BACKGROUND
2.1 Microarchitectural Attacks
A common approach in microarchitectural attacks is the exploita-
tion of contention in microarchitectural buffers within the CPU,
which are intended to improve performance. The usually unprivi-
leged attacker manipulates the content of a buffer or cache to pro-
voke abnormal behavior, which can be measured as side-channel
information like timing behavior, and leak secrets partially.
2.1.1 Cache attacks. A frequent target are CPU caches, from the
core-specific L1 caches [10, 66], to the unified, inclusive and shared
L3 caches [7, 51]. Many techniques evolved, allowing the adversary
to measure timing differences regarding data or instruction accesses
[17, 32, 64, 81], in order to determine whether the victim code
accessed a certain cache line.
Intel’s processors have a set-associative cache layout, where each
64-byte cache line maps into a specific cache set. Each cache set has
a limited number of ways, which is the number of cache lines it
can contain at any time. The cache sets of the L3 cache are divided
into slices, where the number of slices usually corresponds to the
number of logical cores. The mapping of physical address to slices
is computed by an undocumented hash function.
Prime+Probe [64] determines a victim’s cache access by first
priming a complete cache set with attacker values, the so-called
eviction set, then waiting on the victim’s code execution and finally
probing the complete cache set with the same attacker values. If
the probing access time is below a threshold, all attacker values
were served from the cache and the victim did not access the data
of interest. Otherwise, if the access time is above that threshold, the
victim accessed data that was mapped to the same cache set and
thus evicted some of the attacker’s values. Unlike Flush+Reload [81],
this procedure does not require any shared memory, but it is less
precise and prone to noise, since a complete set is probed instead
of a single cache line. When attacking the sliced L3 cache, it is
advisable to use one eviction set per slice, to reduce noise caused by
the remaining system and its processes. Prime+Probe first requires
to construct eviction set(s), meaning finding 𝑐𝑠𝑖𝑧𝑒 addresses which
map to the cache set that is to be primed, where 𝑐𝑠𝑖𝑧𝑒 specifies the
size of a cache set. Depending on the attacker model, this can be
done using virtual to physical address translation, or through huge
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2457pages usually giving the attacker control over the cache set index
bits [51, 75]. Constructing eviction sets per slice does not require
the knowledge of the address to slice mapping. Instead they can be
derived incrementally from the cache set’s eviction set [51].
2.1.2 Vulnerability Detection. Finding side-channel vulnerabilities
in programs by manually inspecting high level and assembly code
is a cumbersome task and will reveal only a small portion of vulner-
abilities, and has to be repeated each time the code was changed.
Automated vulnerability finding can assist in this endeavor. One
approach to this end is to leverage dynamic binary instrumentation
and analysis combined with input fuzzing, as done by DATA [77]
and Microwalk [78]. These frameworks find non-constant-time be-
havior by instrumenting a piece of code under test and executing it
multiple times with different inputs (secrets), while recording the
execution traces. Deviations between traces suggest secret depen-
dent behavior. The tools quantify the leakages by calculating the
mutual information between input and observed traces.
There also are different approaches like e. g. CacheAudit [26],
which applies static analysis to find cache side channels.
2.2 Intel SGX
Running security relevant software or algorithms processing confi-
dential data in untrusted environments has become quite common.
Intel Software Guard Extensions (SGX) aims to provide a hardware
root of trust, enabling users to run software in isolated environ-
ments, called enclaves, which can perform confidential computa-
tions in the presence of an untrusted operating system (OS) without
leaking secret information [36, 55]. To allow the application devel-
oper to verify the integrity and security of their application, Intel
SGX supports two remote attestation schemes [6, 70].
2.2.1 Memory management. Intel SGX leaves the memory man-
agement to the OS, which is responsible for allocating memory
and mapping physical to virtual memory addresses. This allows
untrusted software to tamper with page table entry (PTE) meta in-
formation like the PTE accessed bit [20]. However, Intel SGX specif-
ically guarantees integrity and confidentiality of the data in RAM.
All data in RAM is protected by memory encryption [33] and kept
in the Enclave Page Cache (EPC), which is inaccessible from out-
side SGX. To counteract manipulations of the address translation,