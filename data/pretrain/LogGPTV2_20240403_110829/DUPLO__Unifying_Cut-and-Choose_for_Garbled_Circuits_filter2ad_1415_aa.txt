title:DUPLO: Unifying Cut-and-Choose for Garbled Circuits
author:Vladimir Kolesnikov and
Jesper Buus Nielsen and
Mike Rosulek and
Ni Trieu and
Roberto Trifiletti
2018 IEEE 31st Computer Security Foundations Symposium
Symbolic security of garbled circuits
Baiyu Li∗, Daniele Micciancio∗
∗University of California, San Diego, USA
E-mail: {baiyu,daniele}@cs.ucsd.edu
Abstract—We present the ﬁrst computationally sound symbolic
analysis of Yao’s garbled circuit construction for secure two party
computation. Our results include an extension of the symbolic
language for cryptographic expressions from previous work
on computationally sound symbolic analysis, and a soundness
theorem for this extended language. We then demonstrate how
the extended language can be used to formally specify not only
the garbled circuit construction, but also the formal (symbolic)
simulator required by the deﬁnition of security. The correctness
of the simulation is proved in a purely syntactical way, within
the symbolic model of cryptography, and then translated into
a concrete computational indistinguishability statement via our
general computational soundness theorem. We also implement
our symbolic security framework and the garbling scheme in
Haskell, and our experiment shows that the symbolic analysis
performs well and can be done within several seconds even for
large circuits that are useful for real world applications.
I. INTRODUCTION
Secure computation protocols [1]–[4], showing that any
function can be evaluated by two or more distrustful parties
in a secure way, are a cornerstone of cryptography, and one
of the most complex security problems ever envisioned and
solved by cryptographers. The complexity of designing and
analyzing (general) secure computation protocols stems in
good part from the fact that they require the construction of
not just a single security application, but of an entire class
of applications, each described by a function speciﬁed in a
(low level, but still general purpose) computational model, e.g.,
that of arbitrary Boolean circuits. So, in a sense, protocols
for secure computation problems are not individual security
applications, but compilers to translate speciﬁcations (e.g.,
circuits to be computed) to secure solutions, often to be
validated with respect to a strong simulation-based deﬁnition
of security. In fact, much work on the implementation of secure
computation (e.g., see [5]–[8]) takes the form of compilers
and execution engines. In this paper, we focus on the two
party secure computation problem and Yao’s garbled circuits
[1], [2], the ﬁrst, and still most popular (in its many variants)
solution to this problem. Even disregarding implementation
issues, it is indicative of the complexity of this problem, that
the ﬁrst proof of security for Yao’s garbled circuit construction
[9] appeared approximately 30 years after the protocol was
originally proposed [1], [2].
Following a line of research initiated by Abadi and Rogaway
[10], we consider the possibility of simplifying and formaliz-
ing the design and analysis of secure (two-party) computation
protocols using a hybrid approach, consisting of the following
steps:
∙ Setting up a symbolic execution model, which provides a
simple language to describe (and analyze) cryptographic
computations without all the details and complications of
concrete (complexity based) computational models.
∙ Proving a general computational soundness result, show-
ing that what can be proved symbolically in this abstract
model of computation, also holds true when the symbolic
language is instantiated with computational cryptographic
functions satisfying standard (computational) notions of
security.
∙ Prove that
the protocol
is secure in a purely sym-
bolic/syntactical way, i.e., within the abstract model.
∙ Conclude, via the computational soundness theorem, that
the standard implementation of the protocol (using a
concrete, computational instantiation of the cryptographic
primitives) satisﬁes the computational indistinguishabil-
ity security properties expected by cryptographers, and
demanded by actual applications.
The usefulness and viability of this computationally sound
symbolic approach to security analysis has been investigated
and demonstrated in a number of papers. Previous work
includes foundational results [10]–[12], and applications to a
number of diﬀerent settings, like key distribution protocols
[13]–[15], access control in XML databases [16], password
guessing attacks [17], and more.
The goal of this paper is to demonstrate the applicability
of this attractive methodology to the analysis of secure com-
putation protocols, and, speciﬁcally, Yao’s protocol for secure
two party computation. Perhaps surprisingly, we are able to
show that a very simple extension of symbolic cryptography
languages already considered in the past are suﬃcient to both
model and analyze this type of protocols. While we focus
on Yao’s protocol in one of its simplest variants, we believe
that there is a general lesson to be learned: computationally
sound symbolic analysis can be a powerful tool to manage the
complexity of high level cryptographic applications.
We believe that the use of these methods is not limited
to the mechanic validation of protocols that are seemingly
too complex to be checked by hand, but it can actually help
to carry out the security analysis at a suﬃciently high (still
precise and computationally meaningful) level of abstraction,
so that formal proofs can be validated (and, most importantly,
understood) by humans. Further extensions of the language
and techniques described in this paper may also oﬀer a basis
to study optimizations and extensions of Yao’s basic protocol,
and, perhaps, even the construction of veriﬁed optimizing
compilers for secure computation that translate between dif-
© 2018, Baiyu Li. Under license to IEEE.
DOI 10.1109/CSF.2018.00018
147
ferent variants of cryptographic constructions, while at the
same time checking that the transformations preserve both
functionality and security.
a) Contributions and Technical Overview: As outlined
above, our goal is to describe Yao’s garbled circuits by simple
“symbolic” cryptographic expressions, e.g., expressions of the
𝖪3 of a pair, consisting of a key 𝖪1 and a random message 𝖪2
encrypted under 𝖪1. Here we are using the compact notation
form⦃(𝖪1,⦃𝖪2⦄𝖪1)⦄𝖪3 , representing the encryption under key
⦃𝑚⦄𝑘, quite common in symbolic cryptography, to represent
important to note that expressions like 𝐸 =⦃(𝖪1,⦃𝖪2⦄𝖪1)⦄𝖪3
the encryption of 𝑚 under 𝑘. (In this introduction we appeal
on the reader’s intuition to interpret the meaning of symbolic
expressions, and refer to Section II for formal deﬁnitions.) It is
do not represent the result of running a set of encryption
algorithms, but they are purely syntactical objects, and can be
manipulated as such. Of course, expressions like these can also
be mapped to probability distributions over bit-strings, once an
appropriate encryption scheme has been chosen to implement
⦃⋅⦄𝑘, and random values are chosen for all the 𝖪𝑖 symbols
used in the expression. The resulting distribution is what an
real adversary would see when the protocol is implemented
and executed in practice.
A simple language of this type was suggested in the pio-
neering work of Abadi and Rogaway [10], which also showed
how to map these expressions to symbolic patterns that capture
the adversary’s view or knowledge of the computation. E.g.,
the expression 𝐸 described above could be mapped to the
this is a cipher-text, but nothing else because it does not
know the encrypting key 𝖪3. More realistically, this expression
pattern ⦃□⦄, representing the fact that the adversary can tell
could be mapped to the pattern ⦃⦇𝕂,⦃𝕂⦄⦈⦄𝖪3 to capture the
reveal information on the “structure” or “shape” ⦇𝕂,⦃𝕂⦄⦈
fact that the standard notion of encryption does not hide the
size of the message being encrypted (and, thereby, it may
of the payload,) and may also reveal partial
information
the encryption key 𝖪3. (Protecting the identity of
about
the recipient key 𝖪3 is an extra security feature, typically
called “anonymous encryption”.) Abadi and Rogaway [10]
also proved a computational soundness result, showing that
the symbolic notion of equivalence induced by these patterns
(i.e., two expressions are equivalent if they map to the same
symbolic pattern, possibly up to variable renaming), matches
precisely the notion of computational indistinguishability (i.e.,
the probability distributions generated by the two expressions
cannot be told apart by any eﬃcient adversary), provided a
certain technical condition of encryption cycles is met.
In this work, we follow the approach of [12], which allows
to bypass the key-cycles technicality by using a co-inductive
deﬁnition of symbolic adversarial knowledge. The language of
[10], [12] allows to use only (arbitrarily nested) encryption,
but it has been extended in [18] to provide a computation-
ally sound treatment of pseudorandom generators. As a ﬁrst
contribution of this work, we further extend the language
(and computational soundness results) of [10], [12], [18]
allows to include also randomly chosen bits, and a controlled-
swap operation 𝜋[𝑏](𝑒0, 𝑒1) that randomly permutes {𝑒0, 𝑒1}
depending on the value of the (randomly chosen) bit 𝑏. (This
is described in Section II.)
Next, we show how this simple extended language is enough
to express Yao’s garbling procedure in a purely symbolic way.
This requires to describe a method to map arbitrary circuits
to symbolic expressions, rather than simply providing a single
expression or sequence of expressions (as used, for example,
in a multi-step protocol.) In turn, this requires a good way
to handle arbitrary circuits within symbolic computations.
The way circuits are typically formalized (as an unstructured
list of gates and wires, similar to representing a graph by
unstructured sets of nodes and edges) is not very convenient.
As a second contribution of this work, we propose an inductive
method and syntax to describe circuits, where larger circuits
are built in a modular way from smaller ones, starting from
the basic case of single gates. (For simplicity, we consider
only two types of gates: a NAND gate mapping two Boolean
inputs to one output, and a “duplicate” gate mapping a single
input to two identical outputs.) This modular description of
circuits supports both the formal deﬁnition of circuit mapping
functions, and associated proofs of security, by structural
induction. We remark that this circuit description language
is by no means new, and it is strongly inspired by similar
ideas used in modern high level programming languages, like
Hughes’ arrows [19], [20].
As a disclaimer, we should note that the arrow syntax used
in this paper is a good match for the mathematical deﬁnition of
circuits, and it is a convenient formalism to specify and analyze
circuit-manipulating programs (like compilers for secure com-