title:DUPLO: Unifying Cut-and-Choose for Garbled Circuits
author:Vladimir Kolesnikov and
Jesper Buus Nielsen and
Mike Rosulek and
Ni Trieu and
Roberto Trifiletti
2018 IEEE 31st Computer Security Foundations Symposium
Symbolic security of garbled circuits
Baiyu Liâˆ—, Daniele Micciancioâˆ—
âˆ—University of California, San Diego, USA
E-mail: {baiyu,daniele}@cs.ucsd.edu
Abstractâ€”We present the ï¬rst computationally sound symbolic
analysis of Yaoâ€™s garbled circuit construction for secure two party
computation. Our results include an extension of the symbolic
language for cryptographic expressions from previous work
on computationally sound symbolic analysis, and a soundness
theorem for this extended language. We then demonstrate how
the extended language can be used to formally specify not only
the garbled circuit construction, but also the formal (symbolic)
simulator required by the deï¬nition of security. The correctness
of the simulation is proved in a purely syntactical way, within
the symbolic model of cryptography, and then translated into
a concrete computational indistinguishability statement via our
general computational soundness theorem. We also implement
our symbolic security framework and the garbling scheme in
Haskell, and our experiment shows that the symbolic analysis
performs well and can be done within several seconds even for
large circuits that are useful for real world applications.
I. INTRODUCTION
Secure computation protocols [1]â€“[4], showing that any
function can be evaluated by two or more distrustful parties
in a secure way, are a cornerstone of cryptography, and one
of the most complex security problems ever envisioned and
solved by cryptographers. The complexity of designing and
analyzing (general) secure computation protocols stems in
good part from the fact that they require the construction of
not just a single security application, but of an entire class
of applications, each described by a function speciï¬ed in a
(low level, but still general purpose) computational model, e.g.,
that of arbitrary Boolean circuits. So, in a sense, protocols
for secure computation problems are not individual security
applications, but compilers to translate speciï¬cations (e.g.,
circuits to be computed) to secure solutions, often to be
validated with respect to a strong simulation-based deï¬nition
of security. In fact, much work on the implementation of secure
computation (e.g., see [5]â€“[8]) takes the form of compilers
and execution engines. In this paper, we focus on the two
party secure computation problem and Yaoâ€™s garbled circuits
[1], [2], the ï¬rst, and still most popular (in its many variants)
solution to this problem. Even disregarding implementation
issues, it is indicative of the complexity of this problem, that
the ï¬rst proof of security for Yaoâ€™s garbled circuit construction
[9] appeared approximately 30 years after the protocol was
originally proposed [1], [2].
Following a line of research initiated by Abadi and Rogaway
[10], we consider the possibility of simplifying and formaliz-
ing the design and analysis of secure (two-party) computation
protocols using a hybrid approach, consisting of the following
steps:
âˆ™ Setting up a symbolic execution model, which provides a
simple language to describe (and analyze) cryptographic
computations without all the details and complications of
concrete (complexity based) computational models.
âˆ™ Proving a general computational soundness result, show-
ing that what can be proved symbolically in this abstract
model of computation, also holds true when the symbolic
language is instantiated with computational cryptographic
functions satisfying standard (computational) notions of
security.
âˆ™ Prove that
the protocol
is secure in a purely sym-
bolic/syntactical way, i.e., within the abstract model.
âˆ™ Conclude, via the computational soundness theorem, that
the standard implementation of the protocol (using a
concrete, computational instantiation of the cryptographic
primitives) satisï¬es the computational indistinguishabil-
ity security properties expected by cryptographers, and
demanded by actual applications.
The usefulness and viability of this computationally sound
symbolic approach to security analysis has been investigated
and demonstrated in a number of papers. Previous work
includes foundational results [10]â€“[12], and applications to a
number of diï¬€erent settings, like key distribution protocols
[13]â€“[15], access control in XML databases [16], password
guessing attacks [17], and more.
The goal of this paper is to demonstrate the applicability
of this attractive methodology to the analysis of secure com-
putation protocols, and, speciï¬cally, Yaoâ€™s protocol for secure
two party computation. Perhaps surprisingly, we are able to
show that a very simple extension of symbolic cryptography
languages already considered in the past are suï¬ƒcient to both
model and analyze this type of protocols. While we focus
on Yaoâ€™s protocol in one of its simplest variants, we believe
that there is a general lesson to be learned: computationally
sound symbolic analysis can be a powerful tool to manage the
complexity of high level cryptographic applications.
We believe that the use of these methods is not limited
to the mechanic validation of protocols that are seemingly
too complex to be checked by hand, but it can actually help
to carry out the security analysis at a suï¬ƒciently high (still
precise and computationally meaningful) level of abstraction,
so that formal proofs can be validated (and, most importantly,
understood) by humans. Further extensions of the language
and techniques described in this paper may also oï¬€er a basis
to study optimizations and extensions of Yaoâ€™s basic protocol,
and, perhaps, even the construction of veriï¬ed optimizing
compilers for secure computation that translate between dif-
Â© 2018, Baiyu Li. Under license to IEEE.
DOI 10.1109/CSF.2018.00018
147
ferent variants of cryptographic constructions, while at the
same time checking that the transformations preserve both
functionality and security.
a) Contributions and Technical Overview: As outlined
above, our goal is to describe Yaoâ€™s garbled circuits by simple
â€œsymbolicâ€ cryptographic expressions, e.g., expressions of the
ğ–ª3 of a pair, consisting of a key ğ–ª1 and a random message ğ–ª2
encrypted under ğ–ª1. Here we are using the compact notation
formâ¦ƒ(ğ–ª1,â¦ƒğ–ª2â¦„ğ–ª1)â¦„ğ–ª3 , representing the encryption under key
â¦ƒğ‘šâ¦„ğ‘˜, quite common in symbolic cryptography, to represent
important to note that expressions like ğ¸ =â¦ƒ(ğ–ª1,â¦ƒğ–ª2â¦„ğ–ª1)â¦„ğ–ª3
the encryption of ğ‘š under ğ‘˜. (In this introduction we appeal
on the readerâ€™s intuition to interpret the meaning of symbolic
expressions, and refer to Section II for formal deï¬nitions.) It is
do not represent the result of running a set of encryption
algorithms, but they are purely syntactical objects, and can be
manipulated as such. Of course, expressions like these can also
be mapped to probability distributions over bit-strings, once an
appropriate encryption scheme has been chosen to implement
â¦ƒâ‹…â¦„ğ‘˜, and random values are chosen for all the ğ–ªğ‘– symbols
used in the expression. The resulting distribution is what an
real adversary would see when the protocol is implemented
and executed in practice.
A simple language of this type was suggested in the pio-
neering work of Abadi and Rogaway [10], which also showed
how to map these expressions to symbolic patterns that capture
the adversaryâ€™s view or knowledge of the computation. E.g.,
the expression ğ¸ described above could be mapped to the
this is a cipher-text, but nothing else because it does not
know the encrypting key ğ–ª3. More realistically, this expression
pattern â¦ƒâ–¡â¦„, representing the fact that the adversary can tell
could be mapped to the pattern â¦ƒâ¦‡ğ•‚,â¦ƒğ•‚â¦„â¦ˆâ¦„ğ–ª3 to capture the
reveal information on the â€œstructureâ€ or â€œshapeâ€ â¦‡ğ•‚,â¦ƒğ•‚â¦„â¦ˆ
fact that the standard notion of encryption does not hide the
size of the message being encrypted (and, thereby, it may
of the payload,) and may also reveal partial
information
the encryption key ğ–ª3. (Protecting the identity of
about
the recipient key ğ–ª3 is an extra security feature, typically
called â€œanonymous encryptionâ€.) Abadi and Rogaway [10]
also proved a computational soundness result, showing that
the symbolic notion of equivalence induced by these patterns
(i.e., two expressions are equivalent if they map to the same
symbolic pattern, possibly up to variable renaming), matches
precisely the notion of computational indistinguishability (i.e.,
the probability distributions generated by the two expressions
cannot be told apart by any eï¬ƒcient adversary), provided a
certain technical condition of encryption cycles is met.
In this work, we follow the approach of [12], which allows
to bypass the key-cycles technicality by using a co-inductive
deï¬nition of symbolic adversarial knowledge. The language of
[10], [12] allows to use only (arbitrarily nested) encryption,
but it has been extended in [18] to provide a computation-
ally sound treatment of pseudorandom generators. As a ï¬rst
contribution of this work, we further extend the language
(and computational soundness results) of [10], [12], [18]
allows to include also randomly chosen bits, and a controlled-
swap operation ğœ‹[ğ‘](ğ‘’0, ğ‘’1) that randomly permutes {ğ‘’0, ğ‘’1}
depending on the value of the (randomly chosen) bit ğ‘. (This
is described in Section II.)
Next, we show how this simple extended language is enough
to express Yaoâ€™s garbling procedure in a purely symbolic way.
This requires to describe a method to map arbitrary circuits
to symbolic expressions, rather than simply providing a single
expression or sequence of expressions (as used, for example,
in a multi-step protocol.) In turn, this requires a good way
to handle arbitrary circuits within symbolic computations.
The way circuits are typically formalized (as an unstructured
list of gates and wires, similar to representing a graph by
unstructured sets of nodes and edges) is not very convenient.
As a second contribution of this work, we propose an inductive
method and syntax to describe circuits, where larger circuits
are built in a modular way from smaller ones, starting from
the basic case of single gates. (For simplicity, we consider
only two types of gates: a NAND gate mapping two Boolean
inputs to one output, and a â€œduplicateâ€ gate mapping a single
input to two identical outputs.) This modular description of
circuits supports both the formal deï¬nition of circuit mapping
functions, and associated proofs of security, by structural
induction. We remark that this circuit description language
is by no means new, and it is strongly inspired by similar
ideas used in modern high level programming languages, like
Hughesâ€™ arrows [19], [20].
As a disclaimer, we should note that the arrow syntax used
in this paper is a good match for the mathematical deï¬nition of
circuits, and it is a convenient formalism to specify and analyze
circuit-manipulating programs (like compilers for secure com-