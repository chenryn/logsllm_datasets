CFStringCompare的函数定义是：
    CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions);
第一个参数是一个命名为theString1的CFStringRef。由于崩溃是对第一个参数(X0，移动到x21)的取消引用，我们现在知道有些东西正在传入theString1参数的空值！
好了，我们已经找到了崩溃的直接原因：传递给CFStringCompare的空字符串。
让我们回顾一下调用堆栈跟踪，找出为什么会错误地传入这样一个空值！
回想一下，CFStringCompare是由地址为0x00000001886b22ec的CoreEmoji.dylib(dyld_shared_cache_arm64_CoreEmoji)中的一个未命名函数调用的。
由于提取的CoreEmoji二进制文件(来自dyld共享缓存)不是符号化的，因此只需从dylib的MacOS版本中删除这个子例程的分解代码就更简单了。
下面是这两个版本的反编译代码(为了说明MacOS和iOS版本中的代码是相同的)：
    //iOS (arm64)
    int _186b5a2ec {
        var_10 = r20;
        stack[-24] = r19;
        r31 = r31 + 0xffffffffffffffe0;
        saved_fp = r29;
        stack[-8] = r30;
        if (*qword_1b1c9baf8 != -0x1) {
                dispatch_once(0x1b37f3af8, 0x1add1a6f8);
        }
        r20 = loc_182938048();
        r19 = loc_1829387c8();
        loc_1829111e8(r20);
        if (*(int8_t *)byte_1b1c9bb00 != 0x0) {
                r0 = 0x0;
        }
        else {
                r0 = loc_182922ec4(r19, 0x1add1ad38, 0x0);
                if (r0 != 0x0) {
                        if (CPU_FLAGS & NE) {
                                r0 = 0x1;
                        }
                }
        }
        return r0;
    }
    //macOS (x64)
    int sub_b9fe() {
        if (*qword_128e8 != -1)
        {
                dispatch_once(qword_128e8, ^ {/* block implemented at sub_ba72 */ } });
        }
        rbx = CFLocaleCopyCurrent();
        r14 = CFLocaleGetValue(rbx, **_kCFLocaleCountryCode);
        CFRelease(rbx);
        if (*(int8_t *)byte_128f0 != 0x0) {
                rax = 0x0;
        }
        else {
                rax = CFStringCompare(r14, @"CN", 0x0);
                rax = rax != 0x0 ? 0x1 : 0x0;
        }
        return rax;
    }
在arm64反编译中，以下行表示对CFStringCompare的调用：
    r0 = loc_182922ec4(r19, 0x1add1ad38, 0x0);
寄存器r19是第一个空参数(theString1)，因此触发了崩溃。
再查找几行，我们可以看到r19被设置为调用loc_1829387c8()的返回值；
    r19 = loc_1829387c8();
多亏了MacOS符号化的反编译，我们可以看到这是对CFLocaleGetValue()的调用。
Apple记录了以下功能：
> CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey
> key)；返回区域设置的键值对的给定键的对应值。
通过反编译，我们可以确定locale是来自CFLocaleCopyCurrent()的返回值，而键是_kCFLocaleCountryCode。
因此，源代码看起来可能如下所示：
    CFLocaleRef locale = CFLocaleCopyCurrent();
    CFStringRef countryCode = CFLocaleGetValue (locale, kCFLocaleCountryCode);
这段代码后面紧接着是对布尔标志的检查(iOS:byte_1b1c9bb00，MacOS:byte_128f0)。
坚持使用符号化的macOS dylib，我们可以找到这个值的交叉引用(x-ref)，以确定它设置在哪里(sub_ba72)：
    void sub_ba72(void * _block) {
        rbx = CFPreferencesCopyValue(@"Country", **_kCFPreferencesAnyApplication, **_kCFPreferencesAnyUser, **_kCFPreferencesCurrentHost);
        if (rbx != 0x0) {
                r14 = CFEqual(rbx, @"CN") != 0x0 ? 0x1 : 0x0;
                CFRelease(rbx);
        }
        else {
                r14 = 0x0;
        }
        *(int8_t *)byte_128f0 = r14;
        return;
    }
这段代码(sub_ba72)确定用户当前的‘国家’首选项。
如果不是中国(“cn”)，则该标志设置为0x1(True)。如果国家是中国，或者CFPreferencesCopyValue()中止并返回NULL，则标志设置为0x0(False)。
我朋友手机的区域和语言没有设置为“cn”，所以这个标志(AFAIK)应该设置为0x1(真)：
[](https://p0.ssl.qhimg.com/t011e70b18925546036.png)
但是，由于代码用了else(反过来调用CFStringCompare()，它将指示该标志必须为0x0。
    //check some flag ('CN')
    if (*(int8_t *)byte_1b1c9bb00 != 0x0) {
        r0 = 0x0;
    }
    //we take this path
    else {
      //call to CFStringCompare() that crashes
      r0 = loc_182922ec4(r19, 0x1add1ad38, 0x0);
      ... 
    }
一种解释是，由于某些原因，对CFPreferencesCopyValue(@“Country”.)调用失败，会将标志设置为0x0。或者代码认为由于某种(未知的)原因，手机的区域设置为“cn”？
无论如何，调用CFStringCompare时，第一个参数(寄存器r19)设置为NULL：
    //call CFStringCompare()
    // first parameter is NULL, and thus crashes
    // second parameter is @"CN"
    r0 = loc_182922ec4(r19, 0x1add1ad38, 0x0);
请注意，只有在对CFLocaleGetValue()的调用失败(即返回NULL)时，r19寄存器才能为空。
一种解释是，对CFLocaleCopyCurrent的调用返回null，这反过来会导致CFLocaleGetValue也返回null(这反过来会将null传递给CFStringCompare()，从而导致崩溃)。
如果我们查看苹果代码中的其他地方，比如它们的CFStringCompareWithOptionsAndLocale函数，可以看到它们在这里检查CFLocaleCopyCurrent()的返回值：
    locale = CFLocaleCopyCurrent();
    langCode = ((NULL == locale) ? NULL : (const uint8_t *)_CFStrGetLanguageIdentifierForLocale(locale));
这意味着CFLocaleCopyCurrent()确实可能失败，并返回NULL(因此应该检查！)
不幸的是，我的理解只到这一点上了。也就是说，我不知道为什么以及在什么条件下：CFLocaleGetValue(CFLocaleCopyCurrent()，kCFLocaleNationalCode)可以返回NULL。但是它可以，而且这是不做检查的！因此，用NULL调用CFStringCompare()，应用程序就会崩溃！
苹果强调：
> 在某些情况下，如果设备的语言/区域设置不正确，即缺少区域代码，则可以返回NULL。若要触发此操作，必须将设备设置为不支持区域的无支持状态。
## 修复
两年多来，她的手机一直无法输入“台湾”，或者每当手机收到台湾旗帜表情符号时，她的手机就会被“远程攻击”，只不过是把这个地区从美国、中国大陆，再回到美国，一目了然。
我不能百分之百地确定为什么(或者如何修复它)，但我猜它要么将‘Country’值设置为‘us’，所以现在boolan标志(在byte_1b1c9bb00处)被设置为0x1，这意味着CFStringCompare()从来没有被调用过,或者，对CFLocaleCopyCurrent()/CFLocaleGetValue()的调用不再返回null，这意味着一个有效的字符串被传递给了CFStringCompare()。
由于我不确定还有多少其他iOS用户受到影响，我也向苹果报告了这个问题。他们给它分配了CVE-2018-4290，并在iOS 11.4.1中对其进行了修复：
[](https://p1.ssl.qhimg.com/t018819459262061cd8.png)
我还没有机会研究苹果的补丁，但我提出以下建议作为一个简单的解决方案：
为了避免这种崩溃，代码应该只检查调用CFLocaleGetValue()的结果，如果调用失败(即返回NULL)，则跳过对CFStringCompare()的调用：
    CFLocaleRef locale = CFLocaleCopyCurrent();
    CFStringRef countryCode = CFLocaleGetValue (locale, kCFLocaleCountryCode);
    //fix!
    // make sure to check this!!
    if(NULL != countryCode)
    {
         CFStringCompare(countryCode, @"CN", 0x0);
    }
    //otherwise handle case where `countryCode` is NULL
    else
    {
      .... 
    }
## 回顾
到目前为止，本文深入研究揭示并解释了一个(远程)iOS崩溃的技术原因。然而，仍然存在一个尚未回答但相当有趣的问题：“不管怎么说，这段代码到底想要完成什么？”
回顾：
  * 这起崩溃事件是由键入台湾或接收任何带有台湾旗帜(🇹🇼)的信息引发的。
  * 导致崩溃的方法(例如，RemoveEmoji)似乎与从接收到的消息中删除表情符号有关。
  * 故障指令之前的各种代码正在检查中国(“CN”)用户设备的语言/地区设置。
  * 传递给CFStringCompare(崩溃的函数)的第二个参数设置为(“cn”)。
这么多中国！嗯，那又有什么用呢！
答案可以在表情包网站上找到，上面写着：
> 此标志隐藏在设置为中国的iOS设备上的表情符号键盘上。中国的iPhone不会显示这个标志，而是会显示一个缺失的字符豆腐(☒)。
[](https://p2.ssl.qhimg.com/t01de2b2a62bdda39e7.png)
## 结论
在本文中，我们找到了远程iOS缺陷的原因。
尽管它的影响仅限于拒绝服务(空指针取消引用)，但它为分析iOS代码提供了一个有趣的案例研究。
审核人：yiwang 编辑：边边