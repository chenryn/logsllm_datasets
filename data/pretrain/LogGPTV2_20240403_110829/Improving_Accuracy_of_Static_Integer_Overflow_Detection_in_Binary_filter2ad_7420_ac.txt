each of the paths identiﬁed in the last step. Thus, if s is satisﬁed when the
program starts, then c is also satisﬁed when the program executes along the
corresponding program path.
4. The STP solver is invoked to solve whether or not s can be satisﬁed. If not,
then the vulnerability is a false positive and hence ﬁltered out.
Improving Accuracy of Static Integer Overﬂow Detection in Binary
257
In addition to the WP calculation, the Vulnerability Filter also implements
a mechanism to validate the paths from overﬂow points to the corresponding
sinks, also known as forward vulnerable paths. The validation of forward vul-
nerable paths is based on a simpliﬁed value-range analysis [21], in which the
values of variables of interest are abstracted as a range over the integer domain.
In particular, the values of all integer variables involved are initialized as the
entire integer domain and continuously updated during forward execution of
the forward vulnerable paths. When conditional jumps are encountered, checks
are conducted to see if the current value ranges of related variables can satisfy
the branch conditions, so that the execution can eventually lead to the target
sinks. If not, the forward vulnerable paths are infeasible, suggesting that the
corresponding vulnerabilities are false positives.
Both the WP calculation and value-range analysis are conservative and do
not introduce false negatives, when applied to reduce false positives (see Sect. 5.4
for details).
4 VIOSE: Vulnerability Validation with Symbolic
Execution
False positives survived from StaticTaint are further examined and eliminated by
VIOSE with its Symbolic Execution Engine (SEE). As illustrated in Fig. 1, the
SEE in VIOSE maintains a virtual machine as the abstract runtime environment
for executing binaries, and its operation is guided by the Vulnerability Validation
module. In particular, the Vulnerability Validation module instructs the SEE on
which program paths to execute, and monitors the execution results of the SEE.
The complexity of symbolic execution, in terms of symbolic states explored
and constraints generated, increases exponentially as the number of symbolic
variables involved or the size of the program path increases [1]. Thus, we intro-
duce two components in VIOSE, the Variable Selection and Path Selection mod-
ules, to improve the scalability and eﬀectiveness of symbolic execution.
4.1 Symbolic Execution in VIOSE
The SEE in VIOSE is constructed on the top of S2E [9], a platform for explor-
ing and analyzing the behavior of binary code. S2E has a variety of notable
features, making it suitable to be used for our analysis: 1. S2E can automati-
cally switch between concretely and symbolically executing the code of interest,
within an emulated OS runtime environment (i.e., a virtual machine); 2. the
virtual machine in S2E oﬀers a real software stack (libraries, OS kernel, drivers,
etc.), rather than abstract models, to emulate the targeted OS environment,
which makes the analysis built upon it closer to the reality; and 3. S2E can exe-
cute binary code in both user and kernel modes, making it applicable to more
binary programs.
258
Y. Zhang et al.
The SEE in VIOSE extends S2E with two features to improve the eﬃciency
of symbolic execution:
1. A plug-in is added to S2E, which guides S2E to only execute, symbolically or
concretely, instructions commanded by the Vulnerability Validation module.
In other words, only instructions relevant to integer overﬂow are executed.
2. A customization is made to the S2E symbolic execution engine, so that:
(a) S2E can introduce symbolic parameters for variables and memory loca-
tions speciﬁed by the user. As a result, instructions involving these vari-
ables and memory locations are forced to be executed symbolically.
(b) When an arithmetic instruction with integer variables is encountered, S2E
automatically generates the constraint for the involved integer variables to
overﬂow. However, such a constraint has already been generated by the Vul-
nerability Filter component of StaticTaint in previous analysis. Thus, the
VIOSEs SEE simply retrieves this constraint instead of re-generating it.
Given an entry point and a sink, S2E explores all program paths connecting
them. For each of such paths, S2E invokes the STP solver to check if the conjunc-
tion of the integer overﬂow constraint and the path constraints collected along the
path is satisﬁable. If STP reports back a solution (i.e. certain evaluation of input
variables enabling the potential overﬂow), S2E stops analyzing the rest paths for
this pair of (entry point, sink), and reports it as a genuine vulnerability to the
Vulnerability Validation module. If the conjunction is found to be unsatisﬁable or
cannot be solved within a pre-deﬁned time limit, S2E continues to analyze the rest
program paths for this pair of (entry point, sink). Only when no solution can be
found for the constraint conjunctions of all program paths connecting the entry
point and the sink, S2E reports the vulnerability as a false positive.
It is worth noting that the S2E platform performs selective symbolic execu-
tion directly on the binary code. Thus, we extend StaticTaint with the feature of
mapping all its vulnerability identiﬁcation results (on the IR level) back to the
original binary level, so that these results can be re-used to guide the symbolic
execution in S2E. Experiments showed that S2E enables INDIO to achieve 76 %
reduction of false positives (see Sect. 5.4).
4.2 Path Pruning and Taint Analysis
As compared to the WP calculation, symbolic execution is more accurate in
validating the feasibility of program paths [25], and hence can detect false posi-
tives that survive from previous analyses. However, symbolic execution is more
computationally expensive than the WP calculation [18], making it a formidable
task to validate all suspicious vulnerabilities with symbolic execution. Consider-
ing this, VIOSE incorporates the Path Selection module to reduce the number
of program paths that symbolic execution needs to explore; and the Variable
Selection module to help reduce the number of symbolic variables to be intro-
duced. As a result, symbolic execution in VIOSE can scale up to analyze more
complex and larger binaries.
Improving Accuracy of Static Integer Overﬂow Detection in Binary
259
The Path Selection module implements a heuristic algorithm that we previ-
ously proposed [5] to identify program instructions and paths irrelevant to inte-
ger overﬂow analysis and remove them from subsequent analysis. The algorithm
is essentially a customized control-ﬂow analysis of the program of interest: if in
the control ﬂow graph an instruction is not on either a path from the program
entry point to an overﬂow point or on any forward vulnerable paths from the over-
ﬂow point to its sink(s), the instruction is deemed as irrelevant and thus pruned
oﬀ. In other words, when symbolic execution is facing more than one branch to
proceed, the Path Selection component instructs symbolic execution to take the
branch leading to the target sinks. Eliminating irrelevant instructions and paths
from symbolic execution can focus the analysis only on the portion of code that
matters to integer overﬂow and consequently improve the analysis eﬃciency.
The Variable Selection module, on the other hand, reduces the number of
symbolic variables introduced during symbolic execution. It is an instance of
classic taint analysis, except that it only tracks the tainted program inputs that
are used as the operands of overﬂow points or can inﬂuence such operands. For
these variables tainted by inputs, the Variable Selection module informs the SEE
to introduce symbolic variables. For input variables decided as irrelevant to inte-
ger overﬂow, the Variable Selection module assigns them with random concrete
values, since their values have no impact to the corresponding vulnerabilities.
Note that typical taint analysis does not consider the information ﬂow caused
by control dependency [18]. Thus, it is possible that variables aﬀecting the con-
trol ﬂow (e.g., those used in the conditions of if statements) might be identiﬁed
as “untainted”, and the Variable Selection module will not introduce symbolic
variables for them. This might result in some branches of if statements being
missed by symbolic execution, and thus aﬀect the result of vulnerability vali-
dation. We leave it as future work to enhance our taint analysis to take into
account control dependency.
5 Evaluation
We have evaluated the eﬀectiveness and eﬃciency of INDIO against a number
of widely-tested Windows applications and libraries. They are listed in Table 2,
among which comctl32.dll and gdi32.dll are both GUI-based libraries and
libpng.dll was deemed as “completely free of undeﬁned integer overﬂows” [10].
We conducted all experiments on a Lenovo desktop with a 2.6 GHz Intel i7 CPU
and 4G memory, and the threshold of the priority ranking algorithm was set
as 30 (see Sect. 5.1 for explanation). Similar to other static analysis tools, all
vulnerabilities reported by INDIO were manually inspected to decide if they
were false positives or represented real security issues.
5.1 Eﬀectiveness: Detection of Known Vulnerabilities
In the ﬁrst set of experiments we applied INDIO to 6 diﬀerent programs, each of
which has a known integer overﬂow vulnerability. INDIO successfully reported
260
Y. Zhang et al.
Table 2. Statistics of detecting known integer overﬂow vulnerabilities.
Program name Program version Advisory ID
Vuln.
Identif.
Priority
ranking
WP
Calc.
Symbolic
execution
Rank
comctl32
5.82.2900.2180
eEye reported
401
5.1.2600.2180
CVE-2007-3034 1029
CVE-2011-3026
525
CVE-2010-1516 2331
CVE-2010-1516 2459
CVE-2008-2430
22
63
93
73
201
176
2
16
10
14
8
8
1
2
1
2
2
2
1
1
10
4
5
5
1
gdi32
libpng
png2swf
jpeg2swf
1.5.13
0.9.1
0.9.1
libwav plugin 0.8.6h
all vulnerabilities contained in these programs. Table 2 summarizes the results,
in which column 3 shows the advisory reports for the known vulnerabilities;
columns 4-7 show the numbers of suspicious vulnerabilities after each of INDIO’s
analysis and optimization modules was applied; and column 8 shows the priorities
computed for the vulnerabilities. It is obvious from Table 2 that our priority
ranking algorithm drastically ﬁlters out false positives generated, while keeping
false negatives at a negligible level in the experiments.
In fact, we used the ﬁrst set of experiments as the “training set” to approach a
reasonable priority threshold for vulnerability ranking. We ﬁrst applied INDIO to
the training set with threshold = 0 and checked if any known vulnerability listed
in Table 2 was missed. The process was repeated by increasing the threshold by
5 each time. The results, illustrated in Fig. 2, showed that the false negatives
occurred when the threshold was 35. Thus we set the threshold as 30 in the
subsequent experiments.
y
t
i
l
i
l
i
i
b
a
r
e
n
u
v
s
u
o
c
p
s
u
s
f
o
r
e
b
m
u
N