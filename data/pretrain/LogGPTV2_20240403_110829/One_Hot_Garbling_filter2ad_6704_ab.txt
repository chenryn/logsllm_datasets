new directions:
(1) Consider more expressive fields. One elegant direction views
a circuit as an object that operates over the Boolean field.
With this perspective, it is natural to consider whether larger
finite fields are also candidates for GC evaluation. [BMR16]
showed that they indeed are candidates, and gave construc-
tions that add/multiply in a small arithmetic field and even
that convert between different fields. Unfortunately, multi-
plication/conversion gates grow linearly in the size of the
considered fields, and so rapidly become impractical. Arith-
metic GCs are, unfortunately, only useful in specific settings.
(2) Consider more expressive functions. Since an improved AND
gate seems unlikely, it is natural to consider more complex
functions. However, such improvements are elusive in GC,
and, to our knowledge, only one has been made: stacked gar-
bling [HK20a, HK21] shows that GC communication can be
improved for functions with exclusive conditional behavior.
Our work falls into the second category.
Non-GC Expressive Functions. In other MPC protocols, it is possi-
ble to improve beyond considering simple XOR/AND or ADD/MUL
gates. For example, other protocols allow (1) efficient lookup-table-
based approaches [IKM+13, DKS+17, KKW17, DNNR17]2, (2) ef-
ficient linear algebra operations, e.g. [HKP20, ADI+17, PSSY20,
RWT+18], or (3) custom designed subprotocols, such as fast field
inverse computation [BIB89]. Our work brings a flavor of such
techniques to GC.
Puncturable PRFs and MPC. Our one-hot outer product construc-
tion uses a well-known puncturable PRF derived from the classic
GGM PRF [GGM84]. This same idea is often applied in MPC, for
example to help achieve efficient OT extension [BCG+19, YWL+20].
Our work shows that this primitive can be directly and elegantly
plugged into GC and that the resulting primitive is powerful.
GC frameworks. Part of our contribution is a framework for build-
ing new GC modules from one-hot outer products. The generally
accepted GC framework, specified by [BHR12], defines garbling
schemes. We clarify that our framework and [BHR12]â€™s framework
achieve different goals. The [BHR12] framework provides an ab-
straction barrier between high level protocols and garbling schemes.
Our framework instead supports new GC modules which are hosted
inside a specific garbling scheme. Indeed, our framework is proved
secure in the [BHR12] framework.
Previous work, e.g., [KNR+17, GLMY16] viewed their circuits as
modules. The similarity between these works and ours is superficial.
They build modular GC components that are individually garbled,
then dynamically stitched together into a full GC for improved
performance. In contrast, our modules enforce scope of private
variables, and facilitate clean security proofs of circuits composed
of our one-hot gates.
2Technically, large lookup tables can be implemented in GC by enumerating garbled
rows, but this is expensive.
3 NOTATION AND ASSUMPTIONS
We list some simple notation here. We elaborate on more involved
notation in the following subsections.
from ğ‘¦.
â€¢ ğœ… is our computational security parameter, e.g. 128.
â€¢ ğº is the GC generator. We refer to ğº by he/him.
â€¢ ğ¸ is the GC evaluator. We refer to ğ¸ by she/her.
â€¢ ğ‘¥ â‰œ ğ‘¦ denotes that ğ‘¥ is equal to ğ‘¦ by definition.
â€¢ ğ‘¥ ğ‘
â€¢ We work with vectors and matrices:
= ğ‘¦ denotes that ğ‘¥ is computationally indistinguishable
â€“ If ğ‘£ is a vector, then ğ‘£ğ‘– denotes the ğ‘–th entry in ğ‘£. If ğ‘š is
a matrix, then ğ‘šğ‘–,ğ‘—, denotes the entry at the ğ‘–th row and
ğ‘—th column. We use zero-based indexing.
drawn from D.
â€“ ğ‘šâŠº denotes the transpose of ğ‘š.
â€“ ğ‘¥ âŠ— ğ‘¦ denotes the outer product of vectors ğ‘¥ and ğ‘¦. The
outer product can be defined as follows: ğ‘¥ âŠ— ğ‘¦ â‰œ ğ‘¥ Â· ğ‘¦âŠº.
â€¢ Let D be a distribution. We write ğ‘¥ â† D to denote that ğ‘¥ is
â€¢ We overload the notion of a circuit wire to hold a matrix of
bits of arbitrary dimension. We sample wires in a natural
manner from general D. Namely, we sample D, encode the
result in binary, then store the result onto the wires.
â€¢ [ğ‘›] denotes the sequence of natural numbers 0, 1, ..., ğ‘› âˆ’ 1.
3.1 One-Hot Encoding and Truth Tables
Recall from Section 1.2 that our central construction computes the
one-hot outer product H(ğ‘) âŠ— ğ‘. Moreover, we apply functions to
one-hot encodings via truth tables. We define appropriate notation:
Definition 3.1 (One-hot encoding). Let ğ‘ âˆˆ {0, 1}ğ‘› be a length-ğ‘›
bitstring. The one-hot encoding of ğ‘ is a length-2ğ‘› bitstring denoted
H(ğ‘) such that for all ğ‘– âˆˆ [ğ‘›]:
H(ğ‘)ğ‘– â‰œ
(cid:40)1
if i = ğ‘
0 otherwise
Definition 3.2 (Truth table). Let ğ‘“ : {0, 1}ğ‘› â†’ {0, 1}ğ‘š be a func-
tion. The truth table for ğ‘“ , denoted T (ğ‘“ ), is a 2ğ‘› Ã— ğ‘š matrix of bits
such that:
That is, the ğ‘–th row of T (ğ‘“ ) is the bitstring ğ‘“ (ğ‘–).
T (ğ‘“ )ğ‘–,ğ‘— â‰œ ğ‘“ (ğ‘–) ğ‘—
We extensively use the following simple lemma that relates truth
tables and one-hot encodings:
Lemma 3.3 (Evaluation by truth table). Let ğ‘“ : {0, 1}ğ‘› â†’
{0, 1}ğ‘š be an arbitrary function. Let ğ‘ âˆˆ {0, 1}ğ‘› be a bitstring:
T (ğ‘“ )âŠº Â· H(ğ‘) = ğ‘“ (ğ‘)
Proof. Straightforward from Definitions 3.1 and 3.2. Informally,
â–¡
the one-hot vector â€œselectsâ€ row ğ‘ of the truth table.
3.2 GC Notation: Garbled Sharings
In this work, we forgo the standard GC notation of garbled labels in
favor of garbled sharings of cleartext values held by ğº and ğ¸. This
will be convenient for handling vectors and matrices of bits. We
stress that the GC mechanism, including communication rounds,
remains completely unchanged.
Session 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea576We use Free XOR style garbled circuit labels [KS08]. In the GC,
ğº and ğ¸ hold sharings of each circuit wire. Each sharing consists of
two shares, one held by ğº and one by ğ¸. ğº samples a uniform value
Î” âˆˆ {0, 1}ğœ…; Î” is a value that is global to all wires in the circuit.
Then, for each wire value ğ‘ âˆˆ {0, 1}, ğº samples a uniform value
ğ´ âˆˆ {0, 1}ğœ…. ğ´ is ğºâ€™s share; ğ¸ holds ğ´ âŠ• ğ‘Î”. Hence, the two parties
together hold an XOR share of ğ‘Î”. We will say that gates â€œoutputâ€ a
sharing. This corresponds to the traditional notation of ğ¸ obtaining
a valid wire label which can be used in continued GC evaluation.
Definition 3.4 (Garbled sharing). Let ğ‘ âˆˆ {0, 1} be a bit. Let ğ´, ğµ âˆˆ
{0, 1}ğœ… be two bitstrings. We say that the pair (ğ´, ğµ) is a garbled
sharing of ğ‘ over (usually implicit) Î” âˆˆ {0, 1}ğœ… if ğ´ âŠ• ğµ = ğ‘Î”. We
denote a garbled sharing of ğ‘ by writing(cid:74)ğ‘(cid:75):
such that ğ´ âŠ• ğµ = ğ‘Î”
(cid:74)ğ‘(cid:75) â‰œ (ğ´, ğµ)
Each of the two elements in the sharing are called shares. In the
GC, ğº holds one share and ğ¸ holds the other. We say that a garbled
sharing is uniform if one share is drawn uniformly from {0, 1}ğœ….
We extend sharing notation to vectors/matrices: a sharing of a
matrix is a matrix of sharings. I.e., for a matrix ğ‘ âˆˆ {0, 1}ğ‘›Ã—ğ‘š:
. . .
. . .
(cid:74)ğ‘0,ğ‘šâˆ’1(cid:75)
(cid:74)ğ‘ğ‘›âˆ’1,ğ‘šâˆ’1(cid:75)
ğ‘0,ğ‘šâˆ’1
(cid:125)(cid:127)(cid:126) â‰œ
(cid:74)ğ‘0,0(cid:75)
...
(cid:74)ğ‘ğ‘›âˆ’1,0(cid:75)
(cid:74)ğ‘(cid:75) âŠ•(cid:74)ğ‘(cid:75) =(cid:74)ğ‘ âŠ• ğ‘(cid:75)
ğ‘ğ‘›âˆ’1,ğ‘šâˆ’1
(cid:117)(cid:119)(cid:118) ğ‘0,0
...
ğ‘ğ‘›âˆ’1,0
(cid:74)ğ‘(cid:75) =
. . .
. . .
Note, XOR is homomorphic over garbled sharings [KS08]:
More generally, we can homomorphically apply arbitrary linear
functions to sharings. Specifically, if ğ‘“ is a linear map, then we
overload function application syntax as follows:
ğ‘“ ((cid:74)ğ‘(cid:75)) = ğ‘“ ((ğ´, ğ´ âŠ• ğ‘Î”)) â‰œ (ğ‘“ (ğ´), ğ‘“ (ğ´ âŠ• ğ‘Î”))
That is, the parties apply (linear) ğ‘“ to a sharing by locally applying
ğ‘“ to their respective shares. This generates a correct output sharing:
Lemma 3.5. Let ğ‘“ be a linear map and let(cid:74)ğ‘(cid:75) be a sharing. Then
ğ‘“ ((cid:74)ğ‘(cid:75)) =(cid:74)ğ‘“ (ğ‘)(cid:75)
Proof.
ğ‘“ ((cid:74)ğ‘(cid:75))
=(cid:74)ğ‘“ (ğ‘)(cid:75)
= ğ‘“ ((ğ´, ğ´ âŠ• ğ‘Î”))
= (ğ‘“ (ğ´), ğ‘“ (ğ´ âŠ• ğ‘Î”))
= (ğ‘“ (ğ´), ğ‘“ (ğ´) âŠ• ğ‘“ (ğ‘)Î”)
Definition 3.4
function application to sharing
ğ‘“ is a linear map
Definition 3.4 â–¡
We apply the above fact often, most notably when applying truth
tables to shared one-hot vectors. Specifically for arbitrary function
ğ‘“ , Lemma 3.3 and Lemma 3.5 together imply the following:
T (ğ‘“ )âŠº Â·(cid:74)H(ğ‘)(cid:75) =(cid:74)ğ‘“ (ğ‘)(cid:75)
3.2.1 ğº constants. It is easy for ğº to inject secret constants into
the GC. Specifically to input a constant ğ‘, ğ¸ takes as her share 0
and ğº takes ğ‘Î”: note that this matches Definition 3.4. We use such
constants to help eliminate introduced masks.
Share colors. GC techniques use garbled shares to decrypt
3.2.2
ciphertexts arranged in tables. The classic point and permute tech-
nique [BMR90] shows that ğ¸ need not try to decrypt each row of a
table, but rather can use share â€œpointer bitsâ€ to directly decrypt the
appropriate row. Per [ZRE15], we refer to these pointers as colors.
Namely, each share has a single distinguished bit that we refer to
as the color. The key property is that on each wire, ğ¸â€™s two possible
shares have different colors, and the color of a share is independent
of the cleartext value that the share represents.
Formally, we ensure that the global value Î” has a one in its least
significant bit. We define a procedure Color that, when given a
bit sharing(cid:74)ğ‘(cid:75), returns to ğº and ğ¸ the least significant bit of their
respective shares. Note the following:
Color((cid:74)ğ‘(cid:75)) = Color((ğ´, ğ´ âŠ• ğ‘Î”))
= (Color(ğ´), Color(ğ´ âŠ• ğ‘Î”)) = (Color(ğ´), Color(ğ´) âŠ• ğ‘)
That is, if both parties compute the color of their respective shares,
the result is an XOR secret share of the cleartext value. We extend
the Color procedure over vectors and matrices: the color of a matrix
of sharings is the matrix of colors of its elements.
3.3 Model and Cryptographic Assumptions
We use the Free XOR technique [KS08] and so we assume a circular
correlation robust hash function ğ» [CKKZ12]. In practice, we can
instantiate ğ» using fixed-key AES [GKWY20, BHKR13].
Formally, we construct a garbling scheme [BHR12], which is a
tuple of algorithms that can be plugged into GC protocols. Thus
we do not need to formally consider a specific threat model, e.g.
semi-honest adversaries. Informally, ğ¸ and ğº can be understood as
semi-honest. Our implementation (see Section 6) uses our garbling
scheme to instantiate a semi-honest protocol.
4 TECHNICAL OVERVIEW
In this section, we present our techniques with sufficient detail
to understand our contribution. Section 5 later presents our con-
structions in formal detail with appropriate theorems and proofs,
and Section 7 shows a number of interesting functions that can be
computed efficiently from our technique.
Let ğ‘ âˆˆ {0, 1}ğ‘› and ğ‘ âˆˆ {0, 1}ğ‘š be two strings. Recall from Sec-
tion 1.2 that our core primitive efficiently computes the following:
(cid:74)ğ‘(cid:75),(cid:74)ğ‘(cid:75) â†¦â†’(cid:74)H(ğ‘) âŠ— ğ‘(cid:75)
To use the primitive, ğ¸ must know in cleartext the value ğ‘. We first
sketch the construction, then show how it can be used.
4.1 Garbled One-Hot Encoding(cid:74)ğ‘(cid:75) â†¦â†’(cid:74)H(ğ‘)(cid:75)
We first describe how to compute(cid:74)ğ‘(cid:75) â†¦â†’(cid:74)H(ğ‘)(cid:75) when ğ¸ knows ğ‘.
The idea marries GC with a well-known puncturable PRF built from
the classic GGM PRF [GGM84]. Puncturable PRFs are useful in a
number of settings, see e.g. [BW13, KPTZ13, BGI14, Ds17, BCG+19,
SGRR19]. The technique is well known, but we nevertheless sketch
it here and emphasize its natural compatibility with GC sharings.
ğº first generates a full binary tree of PRG seeds with 2ğ‘› leaves
in the natural manner. Namely, each nodeâ€™s seed is derived by
evaluating a PRG on its parentâ€™s seed. Let ğ‘†ğ‘–,ğ‘— denote the ğ‘—th seed
Session 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea577on level ğ‘–. Let the root of the overall tree reside in level âˆ’1. Let ğ¿ğ‘—
be a pseudonym for the ğ‘—th leaf seed: ğ¿ğ‘— â‰œ ğ‘†ğ‘›âˆ’1,ğ‘—.
hold garbled shares of(cid:74)ğ‘(cid:75). Let(cid:74)ğ‘ğ‘–(cid:75) = (ğ´ğ‘–, ğ´ğ‘– âŠ• ğ‘ğ‘– Î”) be the shares
Our goal is to deliver to ğ¸ all leaf seeds ğ¿ğ‘—â‰ ğ‘. Recall that ğº and ğ¸
of the individual bits in ğ‘. Recall, ğ¸ knows each ğ‘ğ‘– in cleartext but
does not know Î”. We can use these shares to encrypt values that
help ğ¸ recover each seed in the binary tree, except the seeds along
the path to ğ¿ğ‘.
As a base case, ğº simply defines the seeds on level zero as follows:
ğ‘†0,0 â‰œ ğ´0 âŠ• Î” ğ‘†0,1 â‰œ ğ´0
Thus, ğ¸ trivially obtains exactly one seed on level zero.
Now, consider arbitrary level ğ‘–. Assume ğ¸ has all seeds on level ğ‘–
except for one (along the path to ğ¿ğ‘). By applying a PRG to these
seeds, ğ¸ can recover all seeds in level ğ‘– + 1 save two.
To deliver to ğ¸ the missing seed â€œjust offâ€ the path to ğ¿ğ‘, ğº sends