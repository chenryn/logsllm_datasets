that although nonces and hashes have been available since
2014, they have not gained signiﬁcant popularity over time.
On the ﬂip side, most policies make use of unsafe-inline,
which makes them trivially bypassable by XSS. We argue that
this is due to the complexity of deploying CSP in a secure
fashion. This is evidenced by the fact that more than half of
the Web sites (251/449) which experimented with report-only
never switched to enforcement mode. It is also conﬁrmed by
the notiﬁcation responses, in which operators regularly stated
they had experimented with CSP, but felt it was incompatible
with their application. This anecdotal evidence is supported by
our survey, in which only 2/30 respondents familiar with CSP
claimed their site could deploy it right away without breakage.
In terms of deploying limited whitelists, we saw ample
evidence in our case studies as well as the general uptick in
whitelisted sites that curating such whitelists is challenging.
Moreover, our analysis of the whitelisted sites has indicated
that operators are prone to add typo domains, or leave un-
registered domains in their whitelist, effectively undermining
the provided security guarantees (on approx. 13% of the sites
with content-restricting CSPs). Of the handful of sites which
managed to actually deploy a restricted whitelist, both the case
studies and the feedback from our notiﬁcation indicated that
curating such a list takes months or even years. Hence, the
overall effort of setting up and maintaining a secure policy
seems unbearable to all but the biggest players.
2) CSP for TLS Enforcement: Previous studies mainly
focussed on CSP as a means to restrict script content, treating
TLS enforcement and framing control as side notes. In particu-
lar, Weichselbaum et al. [50] reported that only 3% of policies
were used to enforce TLS, while Calzavara et al. [8] reported
that around 0.5% of the Top 1M used upgrade-insecure-
requests, without providing further details. Our longitu-
dinal analysis showed that CSP is a very valuable tool for
TLS enforcement, being used by about one third of the Web
sites that deployed CSP. Most prominently, we observe that
347 sites make use of the upgrade-insecure-requests
directive to automatically upgrade HTTP resources to HTTPS.
We ﬁnd that this feature is not only used for security purposes
but when investigating those sites that deployed upgrade-
insecure-requests as part of their migration to HTTPS,
we found that 77 of 251 (31%) sites still link HTTP resources
(on their start page). Here, the added beneﬁt of upgrade-
insecure-requests enables browsers to upgrade URLs
before trying to load them,
thereby avoiding mixed con-
tent warnings or blockage. Given the increasing adoption of
HTTPS [35], we argue that Web sites adopting an upgrade-
insecure-requests policy would have an easy migration
to HTTPS, while at the same time not having the burden
of making their applications compliant with a strict content-
restricting CSP (e.g., by removing event handlers). This fact,
however, according to our survey, is less than well-known.
3) CSP for Framing Control: In contrast to previous stud-
ies, our ﬁndings indicate that CSP is becoming increasingly
popular for framing control, now on par with content re-
striction (attempts) and TLS enforcement. At the same time,
the adoption of CSP for framing control is not nearly as
widespread as XFO: CSP with frame-ancestors is used
in 409 Web sites, while XFO is present on 3,253 Web sites
as of December 2018. However, we observe that existing
Web sites are taking advantage of the additional ﬂexibility on
framing control offered by CSP. In fact, out of the 460 sites
using CSP for framing control in all of 2018, 321 sites (70%)
used whitelists not expressible by XFO, which suggests that the
additional expressiveness of CSP for clickjacking protection is
useful in practical cases. Moreover, our notiﬁcations showed
that about two thirds of respondents were not aware of the
added beneﬁt of frame-ancestors. While our notiﬁcations
and the feedback we have received suggest that this can be
easily changed for operators we could reach, the resources
frequently used by the respondents lack crucial information
about this fact. As an example, the Mozilla Developer Network
only explicitly mentions “[..] certain types of attacks, including
Cross Site Scripting (XSS) and data injection attacks” and does
not list framing control as a use case [24].
B. Complex Security Policy?
From both the evidence gathered from our longitudinal
study as well as the insights provided to us through the con-
versations in our notiﬁcation, CSP for script content restriction
seems to be a failing mechanism. Even though modiﬁcations
to CSP should have made it easier for sites to adopt secure
policies (e.g., allowing inline scripts through nonces), we could
not observe any signiﬁcant uptake over time. Moreover, the
responses indicated that operators still shy away from CSP for
content restriction due to its perceived complexity.
One speciﬁc issue that CSP for content restriction has is
the moving target it represents. As an example, google.com
stopped using strict-dynamic on July 17th, 2018 even
though Google engineers originally proposed the new direc-
tive [50]. Given the insights shared by the Google team in a
recent presentation [49], they have since moved away from us-
ing strict-dynamic, favoring the explicit propagation of
trust by having nonced scripts attach the nonce whenever they
add additional scripts. The reasons are seemingly two-fold:
ﬁrst, support for strict-dynamic is not universal (e.g.,
Safari does not support it). Second, using strict-dynamic
yields any control over which resources can be included, and
opens up the potential for Script Gadget attacks [19]. The loss
of control over included resources cannot be addressed through
a nonce-based policy, given that any nonced script could just
use the nonce to add code from elsewhere. The solution, as
also proposed by the Google engineers and at least partially
deployed as of now by Dropbox, is policy composition. There,
a site sets two CSPs, where one carries a nonce and the other
carries a whitelist. Since both have to be fulﬁlled, only scripts
that carry the nonce and are from explicitly whitelisted hosts
can be executed. Given these advances and frequent changes
14
in suggested best practices, it is understandable that operators
feel overwhelmed by the complexity of the mechanism.
At the same time, while CSP appears to be failing as a
means to mitigate XSS, it has become a successful mechanism
to enforce TLS, evidenced by the uptick of this use case.
Moreover, upgrade-insecure-requests allows sites to
seamlessly migrate to HTTPS by upgrading all URLs in-
ﬂight. Notably, out of the 10K sites in our original dataset,
7,675 were archived via HTTPS. We downloaded the ﬁnal
snapshot for each domain from the IA and found that of the
7,328 sites without upgrade-insecure-requests, 435
had a least one HTTP-linked resource (6%). Given the current
implementation of browsers, these sites would at the very least
trigger a mixed content warning. This, in light of the results of
our survey, in which 21/30 respondents claimed to be aware
of the isolated usage of TLS enforcement, shows that sites are
clearly not making use of CSP’s full potential.
Despite the growth of CSP for framing control, unfortu-
nately, it still lags behind the increasing adoption of XFO and
more importantly, the complexity of CSP as such seems to con-
fuse operators. This is evidenced by the fact that in December
2018 we observed 362 Web sites using CSP without frame-
ancestors in combination with XFO. For these Web sites,
it would be trivial to use CSP to enforce the same protection,
but this is not done. Though this might be caused by outdated
CSPs written before framing control support was added, we
observed an interesting phenomenon: a third of the Web sites
which deploy CSP without using frame-ancestors are
making use of upgrade-secure-requests, which was
introduced to CSP only later. This implies that CSP is often
perceived as a complex mechanism to restrict content inclusion
and not as a meaningful mechanism to control framing, which
can even be used without any restriction on included content.
Overall, we ﬁnd that CSP has grown from a mechanism
aimed at restricting content to a multi-use measure to improve
the security of Web applications. Our work has highlighted
that this shows success with respect to TLS enforcement and
framing control but also indicates that operators tend to shy
away from deploying CSP, even though it could in many
cases easily beneﬁt their security. We believe this is caused by
the ever-increasing complexity of the CSP mechanism. Apart
from the already existing directives, new features for content
restriction, such as more involved mechanisms for securing
script code in attributes [32], are being added. In addition,
with features such as navigate-to [31] and the signaling
for Trusted Types [54], CSP is becoming a highly complex,
generic Security Policy. This perceived complexity was also
echoed in the notiﬁcation responses, with operators explicitly
naming complexity as the hurdle towards CSP deployment.
C. Quo Vadis, CSP?
Given our insights regarding CSP’s (in)ability to restrict
script content and the reasons we uncovered through our
analysis, we propose three actionable steps which we believe
can help CSP’s adoption and the security of deployed policies.
1) unsafe-nonced-elements: One major roadblock
to CSP adoption is the inability to use event handlers. While
Chrome has recently added support for unsafe-hashed-
attributes [33],
this only enables operators to make
their hash-based whitelist apply to event handlers. In practice
though, we observed up to 3,344 different event handlers on a
single page. While the median is only at around 5, any update
to the event handlers (for all pages!) needs to be propagated
to the CSP header. Instead, we propose that CSP be extended
to allow for nonced elements, i.e., when an element carries
a nonce, any event handlers are permitted on that element
but not its children. This would remove the need of always
resorting to unsafe-inline. This proposed changes comes
with certain risks, namely nonce-reuse attacks and injections
inside nonced elements. The ﬁrst is acknowledged by the CSP
standard authors, who proposed a ﬁx as follows [1]: if a
script tag is nonced, it will only be executed if within all of
its attributes, no additional opening script tag can be found.
This could be easily extended to check for other elements. To
understand the feasibility of the approach, for all of the 317
sites with unsafe-inline which used event handlers (see
Section VIII-B) we checked each snapshot to gauge whether
an element with an event handler also contained markup in
any of its attributes. Assuming these were to be nonced, but
contain markup, CSP would falsely block the nonced element
from executing the event handlers. This analysis showed that
not a single snapshot had such a case; meaning that our
proposal would likely not cause incompatibilities. Second, an
attacker could abuse an injection inside a nonced element to
add additional event handlers. However, this is a signiﬁcantly
lower attack surface than using unsafe-inline, for which
an injection anywhere in the page is sufﬁcient to allow for an
XSS attack. Hence, we argue that this is a viable option to
make CSP more usable, while not fully sacriﬁcing security.
2) Incorporate CSP into Development Cycle: As our anal-
ysis has highlighted, many operators attempted to deploy
CSP to an existing application, only to either end up with a
trivially bypassable policy or give up on CSP altogether. With
a few exceptions, deploying CSP retroactively to an existing
application does not appear to be a viable strategy. This is
aggravated by the use of third parties, which are known to
dynamically add additional content. Hence, we argue that CSP
must be incorporated into the development cycle. In particular,
we urge IDE vendors to add checks for CSP incompatible
code at development time by, e.g., warning developers to not
add inline scripts or event handlers, but instead proposing
to externalize the desired functionality. In addition, as prior
work has documented, third parties often add (script) content
dynamically. We could conﬁrm that by attributing over half the
detected content violations to third parties. While prior work,
such as Calzavara et al. [7] and Weichselbaum et al. [50], have
proposed means to address this issue, we instead argue that
third parties should be explicit about their dependencies and
their impact on CSP (e.g., if they only add scripts dynamically,
thereby enabling support for strict-dynamic). In this
way, during development, a web developer could decide to
incorporate another similar vendor which provides the same
service with less CSP interference. This could also be incor-
porated into IDEs, which could automatically analyze included
parties and warn the developers about roadblocks for CSP.
3) Updated Informational Material for Developers: In light
of our ﬁndings and survey responses,
the
complexity for script content restriction gives CSP a bad
reputation. Given that this is not counteracted by widely used
resources pointing out the easy-to-deploy use cases of TLS
it appears that
15
enforcement and framing control, we advocate for clear com-
munication of the individual goals in such resources. Likewise,
we argue that browser vendors are in a unique position to
improve upon this situation, by warning developers through the
console about inconsistently implemented mechanisms like X-
Frame-Options, even providing a quick ﬁx for the issue by
deploying CSP. To that end, we have started discussions with
both the Chrome and Firefox team on addressing this issue,
with the hope of allowing more sites to leverage the easy-to-
use capabilities that CSP can offer for better security.
XI. RELATED WORK
1) Large-Scale Analyses of CSP: The CSP deployment in
the wild has undergone at least four authoritative studies as
of now [6, 8, 50, 51]. The ﬁrst investigation was published
by Weissbacher et al. in 2014 and mostly focused on the
challenges of CSP adoption: the authors identiﬁed a slow, sub-
optimal CSP deployment and proposed techniques for semi-
automated policy generation [51]. Weichselbaum et al. in 2016
highlighted that more than 90% of the CSPs in the wild
provided no protection against XSS due to trivial bypasses such
as the use of unsafe-inline or insecure whitelists [50].
The authors then recommended the use of strict-dynamic
to deploy CSP more securely. In the same year, Calzavara et al.
identiﬁed similar issues and performed a longitudinal analysis
of CSP deployment over 4 months, showing that CSPs change
less frequently than needed [6]. Their study was later extended
to 6 months, showing that the fraction of sites mitigating XSS
increased over time due to nonces, but most policy changes in
the wild were not targeted at improving security [8].
Our work improves upon previous analyses of CSP in dif-
ferent ways. First, we present the ﬁrst analysis of the security
impact of typos and expired domains on CSPs, complementing
previous ﬁndings of the insecurity of whitelists [19, 50] with
a new delicate aspect. Moreover, our longitudinal lense from
2012 to 2018 not only provides the most comprehensive study
on CSP deployment to date, but allows us to document the
types of struggles sites face when deploying CSP for content
restriction, detailing insights other works could not uncover.
We then turn our attention to aspects of CSP which have
not been thoroughly evaluated in previous work, namely the
use of CSP for TLS enforcement and framing control, which
we also investigate through hands-on experience enabled by
a notiﬁcation campaign. Finally, we complement all of our
ﬁndings by gathering insights from the ﬁeld based on email
responses to the notiﬁcation and our follow-up survey.
2) Other Work on CSP: Van Acker et al. studied the
inability of CSP to prevent data leaks and proposed mitigation
techniques against speciﬁc attack vectors [44]. Hausknecht et
al. observed that browser extensions may force Web pages into
requesting resources which are not whitelisted by their CSP
and proposed an endorsement mechanism to solve possible
compatibility issues [15]. Som´e et al. identiﬁed a subtle inter-
action between CSP and the Same Origin Policy which allowed
bypasses of the security guarantees offered by CSP [39].
Calzavara et al. [7] proposed Compositional CSP: an extension
of CSP designed to better support the dynamic nature of most
modern Web sites. Finally, several researchers have proposed
automated techniques to synthesize CSPs for existing Web
applications, such as DeDaCoTa [12] or CSPAutoGen [34].
3) Historical Analyses of
the Web: The idea of using
the Internet Archive for historical security analyses was ﬁrst
employed by Lerner et al. who used it to conduct a study on
how Web tracking evolved over the course of 20 years [21].
In 2017, Stock et al. used the same method to investigate
the general evolution of client-side security [41]. In particular,
they investigated the prevalence of client-side threats (such as
Client-Side XSS) and adoption of mitigation techniques. They
also noted an uptake in the usage of CSP since 2014, how-
ever, did not focus on any particular analysis of the security
implications of the deployed policies. Later that year, Lerner
et al. showed that the Internet Archive is prone to attacks that
leverage externally referenced JavaScript resources, effectively
allowing attackers to modify the rendered content [20]. Their
work is the reason why the Archive deployed their own CSP.
XII. CONCLUSION
In this paper, we conducted a longitudinal analysis of the
deployment and evolution of CSP since 2012. Leveraging the
Internet Archive to collect the historical headers for 10,000
highly ranked websites for seven years, we identiﬁed that while
CSP was initially meant as a mitigation for script injection,