## 指纹识别WAF规则：基于时间的侧信道攻击
原文链接：
今天在这篇文章中，我将详细介绍我最近的Web应用防火墙（WAF）实验，重点关注特定类型的侧信道攻击，即时间。
在我看来，这个领域还没有得到深入的研究，结果可能比你期望的更致命。这篇文章写的时间已经很久了，所以让我们马上开始阅读吧。
### 侧信道攻击
维基百科将侧信道攻击定义为：  
基于从计算机系统的实现获得信息的攻击，而不是实现的算法本身的弱点。
现在，我们正在提取/学习敏感信息，这些信息的发掘不是现有众人所熟知的侧信道攻击技术所能实现的。这通常是由于一些容易受到这种枚举攻击的错误业务逻辑而导致的信息泄露。
我们今天要谈的攻击是基于时间的。定时攻击的重点是运行系统或算法的硬件上的CPU/内存中的数据流入和输出，只需观察CPU分析数据所用时间的时间变化，就可以从系统中枚举内部敏感信息。
### Web应用程序防火墙
众所周知，Web应用程序防火墙用于检测和阻止对易受攻击的Web应用程序的攻击，除了阻止恶意请求之外，WAF通常用于“隐藏”包含敏感信息（如错误消息或堆栈跟踪）的传出响应，  
WAF通常通过一组称为过滤规则的正则表达式来区分正常请求和恶意请求。
### 采用的指纹识别规则
我们的目标是找到WAF规则集中的漏洞，因此，基本上通过指纹识别WAF的规则，实际上能够检测出正在使用哪种过滤策略，并且可以以避开WAF的方式调整攻击方法。一旦制定了WAF的特定绕过方式，攻击者就可以进一步利用Web应用程序中的现有漏洞。
在本文中，我使用了一种常见的规则指纹识别方法，称为正则表达式反转，它通常依赖于检查请求的每个单独组件，以了解请求的哪个部分不可以绕过。
### 了解WAF安装程序
通常，WAF部署在以下4种网络拓扑中：
  1. 反向代理：WAF位于客户端和服务器之间，拦截请求。客户端直接连接到WAF，然后WAF将查询（如果正常）传递给服务器。如果请求被阻止，则查询永远不会到达服务器。
  2. Server-Resident：这是在WAF通常安装在它正在保护的服务器上时的设置。这可以进一步分为2种拓扑，第一种是将WAF作为插件安装，而第二种是将WAF作为编程库安装。
  1. Out-of-Band：在这种情况下，WAF通常通过网络设备上的监控端口获取流量的副本。这种实现方式限制了WAF阻止请求的能力，并且只有在检测到恶意查询时才能发送TCP重置数据包以中断流量。
  1. 云部署：此设置包括在提供商的网络云内运行的WAF。工作类似于反向代理设置，但服务器的每个请求都必须通过网络云。
在我的实验中，我采用了两种最常用的WAF实现，即反向代理和基于插件的服务器驻留设置。
### WAF指纹识别的常规方法
通常，通过唯一Headers，Cookie，Responses（如状态代码，响应短语/原因和页面内容）来识别任何WAF。有很多很棒的WAF指纹/bypassing工具，例如:WAFW00F，WAFNinja等。
他们通常利用存储侧通道在WAF内指纹规则（无论请求是否被阻止或接受）并进一步绕过它们。所有这些工具都可以观察到：
**WAF阻止消息：** 表示WAF已标记并将请求阻止为恶意请求。通常，阻止的响应页面或标头定义请求已被阻止。有时，响应状态代码（403
Forbidden）也表示阻止请求。
**Web-App错误消息：**
表示Web应用程序在请求时出错。但是，错误消息会被WAF的自定义阻止页面隐藏。在这种情况下，WAF不会阻止请求，而只是隐藏Web应用程序的错误消息，以防止通过堆栈跟踪等敏感信息泄露。
**正常响应：** 表示请求已明确通过WAF传递到Web服务器。但是，在将请求传递到服务器之前，WAF仍有可能拦截请求并删除了请求的恶意部分。
### 主要缺点
正如你可能刚刚注意到的那样，仅仅通过观察响应，人们无法明确区分传递和阻止的请求（第1和第2点），因为在两种被拒绝的情况下都可以观察到WAF阻止页面请求以及内部Web应用程序错误消息（由WAF隐藏）。
### 什么是时间攻击？
上述缺点的解决方案是基于时间攻击的这种新方法。通过利用时间攻击，可以判断请求是否导致某个响应，即被阻止或被传递;
对于web-app错误消息，由于响应时间远远大于传递的请求，因此它被忽略。我的实验结果统计表明，我们可以精确地指纹阻止并传递请求，准确率超过95％。
### 攻击的想法
#### 原理
这种攻击技术的主要原则是被阻止的恶意请求比响应的正常请求花费更少的时间（以毫秒为单位）。被拒绝的请求比正常传递的请求更早完成，因为丢弃的请求永远不会被服务器处理。
因此，阻塞请求和传递请求之间的时序差等于应用逻辑的处理时间。
假设：这里唯一的假设是我们的WAF阻止请求并在检测到恶意请求后立即返回错误消息。剥离请求的恶意部分并将已清理的请求转发到服务器的其他WAF变体不被考虑在内。
### 检测方法
为了区分被阻止和被传递的请求，我们需要两种不同类型的请求，一个正常的请求，它将毫无困难地通过WAF传递。第二种类型是包含payload字符串的恶意类型``，可以很容易地检测到它。
我们最初解决这个问题的方法是首先将攻击分为两个阶段：
  1. 学习阶段：在此阶段，我们测量并了解在我们的攻击阶段中阻塞和传递的请求可能的响应时间以供进一步参考。
  1. 攻击阶段：在此阶段，我们执行实际测试，即发送恶意请求以获得最终结果并进行进一步的统计分析。
现在，来计算方法。在学习阶段，首先，我们测量的响应时间： **〈Tₙ = t₁, t₂, … tₙ 〉** ，的n被禁止的请求
，并定义一个“标记阈值”。在确定请求是通过还是被阻止时，此标记阈值将作为将来的参考。它可以表示为：
类似地，我们通过获取n个传递的请求来定义“传递阈值”，其中可以通过获取超过未检测到的WAF的请求的所有响应时间的最小值来定义边界。此阈值可表示为：
在两种情况下，δ表示由于可能的网络延迟或噪声，实际的通过/阻塞边界可能略小于测量值的边界。
所以现在理论上，我们的标记和通过边界的时间应该作为阻塞和传递请求的阈值，而实际上由于网络中明显的噪声，这是不可复制的。因此，我们采用阻塞和传递边界的均值来获得绝对边界，该绝对边界可以给出关于被阻塞和被传递的请求的响应时间的实际阈值。
显然，对于请求的任何时序测量 **t ≥ tᵦ** 是一个传递的请求而 **t < tᵦ**是被阻止的请求。但是，响应时间接近边界的任何请求 **tᵦ**
可以表示低噪声的通过请求或具有高噪声的阻塞请求。为了排除这一点，攻击者需要放大这个攻击向量。我们将详细讨论这个问题，继续阅读。
### 进行实验
#### 安装程序
为了实现上述理论，我采用了两种最常用的WAF设置拓扑，即基于反向代理和基于服务器驻留（插件类型）的拓扑。