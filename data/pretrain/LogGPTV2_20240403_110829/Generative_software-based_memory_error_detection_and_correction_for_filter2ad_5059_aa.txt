title:Generative software-based memory error detection and correction for
operating system data structures
author:Christoph Borchert and
Horst Schirmeier and
Olaf Spinczyk
Generative 
Software-based 
Memory Error Detection 
for Operating  System 
and Correction 
Data Structures 
Christoph 
Schirmeier 
Borchert,  Horst 
Department of Computer Science 1 2  
Dortmund, 
Universitat 
Germany 
and Olaf Spinczyk 
Technische 
orchert.ho
e-mail: {christoph.b
rst.schirmeier.olaf.
spinczyk}@tu-dortmu
nd.de 
Abstract-Recent 
studies indicate that the number of system 
measures  are 
much more flexible and can 
for  example using ECC memory, software­
by  main memory errors is much higher than 
failures  caused 
expected. In contrast to the commonly used  hardware-based 
countermeasures, 
based fault-tolerance 
exploit application  knowledge, 
data structures. 
memory 
error protection approach, which we used to harden the eCos 
operating system in a  case study. The  main benefits of our 
approach  are  the 
of easily pluggable error detection  and 
well  as  its 
flexibility 
very low runtime 
%. The implementation 
of 0.09-1.7 
overhead, 
to choose from an extensible 
such as  the criticality 
This paper presents  a 
which totals in a  range 
correction schemes as 
software-based 
is based on  aspect-oriented 
of specific 
toolbox 
programming and exploits the object-oriented 
of  eCos to identify well-suited 
generative fault-tolerance 
measures. 
code  locations  for 
the insertion of 
program  structure 
I .  INTRODUCTION 
hardware 
study [ 1 ]  reports 
of today' s  computer 
Errors in main memory are one of the  primary 
systems [ 1 ] ,  [2], 
that about one third of 
from at least one 
problems for failures 
[3], [4].  A  recent 
all machines 
DRAM error per year. This, already 
problem is expected 
to worsen in the future [5], [6], as VLSI  technologies 
higher chip densities 
sensitivity 
increasing 
and lower  operating 
to electromagnetic 
voltages, 
radiation. 
in Google' s  server fleet  suffer 
severe, 
move to 
dramatically 
hardware, 
correcting 
and double-bit-error 
from word-wise multi-bit 
A remedy to this problem is the use of memory-error 
nowadays common on almost every 
A widespread form of protection  is 
found in 
codes (ECC), such as the 
(SEC­
detecting 
Hamming code [7]. By its very nature, 
this 
errors, which 
to a least 17 % of all DRAM errors in 
protection 
server system. 
memory chips with error-correcting 
single-bit-error 
DED) extended 
code cannot recover 
nonetheless contribute 
practice 
such  multi-bit 
a word to independent 
the cost of reduced performance 
consumption 
that Chipkill 
reliable 
systems, 
paper, cannot afford such advanced 
due to forced narrow-Va configuration 
remains useful solely for very expensive, 
addressed in this 
primarily 
protection. 
DRAM chips. However, 
[3] ,  [4].  IBM's high-end 
and up  to 30 % higher energy 
errors (typically 
systems. Low-cost 
[9], so 
highly 
Chipkill 
this comes at 
solutions 
Hardware-based 
space - the overhead 
even if never used by the software. 
parts of the main memory do  not affect the system's behavior, 
entire memory 
protect the 
is paid for every single bit, 
Often, bit errors in the used 
usually 
of redundancy 
for example if not read 
depends on the application 
system) 
a  partition  into 
critical 
that, as we show in Section 
before the next write access. This highly 
software 
(including 
the operating 
and non-critical 
memory spaces. 
II, can be analyzed 
to find 
For these analyses, we  assume a transient 
holding the program instruct
and 
text 
of the dynamic RAM. The read-only 
ions, is  stored 
in a 
memory used 
ROM. For instance,  Flash 
single-bit 
burst fault  model 
segment, 
far more reliable 
commonly in embedded systems 
less susceptible  to 
radiation than 
is 3-5 orders of magnitude 
DRAM and SRAM [ 1 0] .  
We propose 
a  purely 
the application
software-based 
protec­
of critical 
memory-error 
's knowledge 
memory 
from the software's source code 
by compiler-generated 
is the placement 
runtime 
of the runtime 
that is, to analyze 
tion that exploits 
accesses, 
which are extracted 
at compile time and enforced 
checks.  The greatest 
checks in the control 
which instructions 
general, 
problem. 
analysis on object-oriented 
software, 
becomes solvable 
this an undecidable 
with certain 
challenge 
work on which parts of the memory. In 
we focus our 
Therefore, 
for which this problem 
restrictions 
(see Section 
III). 
flow  of the software, 
In the following 
sections, we  apply 
our software
-based 
operat­
to the embedded Configurable 
in object-oriented 
C++. 
offers great flexibility 
in error 
at 
mechanisms, as it is configurable 
protection 
and correction 
memory-error 
ing system (eCos) [ 11 ] ,  which is written 
Our software-based approach 
detection 
compile time whether errors 
corrected, 
whether single-bit 
detected/corrected, 
are considered. 
each object-oriented 
These decisions 
data structure. 
should be detected 
or additionally 
and whether permanent 
or multi-bit 
errors should be 
or transient 
errors 
can be taken independently 
on 
(Section 
granularity 
system crashes 
the vulnerability 
of the embedded Config­
to memory errors on 
II). It is shown that only 
in a sense that 
urable operating  system  (eCos) 
bit-level 
a small fraction of RAM is susceptible 
the operating 
or misbehave
in large parts of RAM do not affect the operating 
system's stability. We 
memory is aligned 
data structures, such as Scheduler 
However, 
that run on eCos. 
find that  most 
to the operating 
error-susceptible 
system's internal 
this highly depends on the user applications 
and Thread objects. 
s .  Errors 
[8] technique tolerates 
4 adj acent bits) by interleaving 
•  We analyze 
We make three contributi
ons: 
978-1-4799-0181-4/13/$31.00 
©2013 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:00 UTC from IEEE Xplore.  Restrictions apply. 
•  We precisely describe 
a  generative  algorithm 
for 
III and IV) .  This 
can be easily applied 
and correction 
(Section 
offers the flexibility 
software-based error detection 
oriented  data  structures 
approach 
extensible  toolbox 
ample Hamming codes. By exploiting 
programming 
to arbitrary 
inserts 
primary contribution 
the chosen protection 
our algorithm 
C++ software, 
as a compiler 
of this paper. 
[ 1 2] ,  
to choose from an 
codes, for ex­
of error-correcting 
aspect-oriented 
in object­
0 
0 
0 
0 
0 
0 
automatically 
0 
0 
I 
0  2000 
o 
112400 
112200 
112000 
i"  111800 
  111600 
 " 
 -:;; 111400 
" 
111200 
111000 
110800 
(Section V). The likelihood 
we prove the effectiveness and efficiency 
of our 
suite, 
approach 
system fails due to transient 
errors is significantly reduced at a very low total 
points 
runtime 
out the trade-of
codes, showing that a two' s  complement 
checksum 
is very  efficient. 
of 0.09-l.7 %. Our evaluation 
error-correcting 
fs between several 
addition 
that the operating 
and multi-bit 
single-bit 
plus replica 
overhead 
mechanisms. This is the 
•  By applying 
our algorithm 
to  the eCos kernel test 
II. PROBLEM ANALYSIS 
the only DRAM bit errors that cause system 
crashes are those that 
o/memory that is occupied 
[2] 
by kernel code pages." 
occur within the roughly 1.5 % 
4000 
6000 8000 
10000 12008>0' 
t-i) 
Time (Cycles) 
susceptibility: 
Each point denotes 
benchmark run (THREAD 1 ) ,  after injecting 
the outcome 
flip at a specific 
time and data-memory 
coordinate. 
in white areas have no observable 
effect. Blue marks 
memory accesses and jumps. CPU exceptions 
are colored 
Fig. 1 :  eCos fault 
of an independent 
a single-bit 
Injections 
illegal 
red and timeouts 
benchmark 
corruption). 
runs that 
yellow respectively. Green data points show 
finish, but yield wrong output (silent 
data 
We used FAIL * [ 1 7] ,  a versatile 
fault­
(FI) and experimentation 
for an i386 target. 
injection 
bit flip faults (in Section V we additionally 
error fault model) into Bochs, an IA-32 (x86) emulator, 
observe 
a burst­
and to 
the benchmark 
to inject single­
framework, 
behavior 
evaluate 
afterward
s .  
1 
" 
/.' 
" 
of the system -their very small  memory  footprint, 
The fault-inj
ection result 
excerpt i n  Figure 1 shows that  the 
depend on the OS. Surprisingly, 
the operating
and -compared 
piece of software with regard to dependability, 
-system (OS) kernel is the most 
as all 
OS kernels are not equipped 
against 
In general, 
important 
in 
other software components 
spite of their impact on total system  resiliency 
to  the  rest 
state-of-the-art 
based protection 
based fault-tolerance 
potential 
attempts 
from excessive runtime overhead, 
260% [ 1 3] ,  [ 1 4] ,  [ 1 5 ] ,  [ 1 6] .  These studies 
level applicatio
considered 
of general-pur
pose OS. 
to reduce system failures. Unfortunately, 
to apply software-based 
ns; such extreme performance 
for the  OS  layer, 
with software­
memory errors: An efficient software­
offer an enormous 
memory protection 
suffer 
ranging between 30 % and 
only address user­
are 
technique  would 
degradations 
unacceptable 
especially 
most earlier 
in the case 
The key to efficient 
software-based 
memory protection 
is 
on's behavior 
on special-purpose 
and its OS 
embedded systems, 
unchanged 
over a 
Focusing 
knowledge 
on the applicati
to exploit 
usage profile. 
this profile can be assumed to remain largely 
system's lifetime. 
-application-dependent 
"mission 
affect  the 
memory space needs protection, 
highly localized 
recovery 
and faults  in 
system' s  stability. 
application 
mechanisms 
critical", 
calling 
(ERM). 
other parts of memory do not 
Accordingly, 
only the critical 
for a configurable  and 
of error detection 
(EDM) and error­
Our working  hypothesis 
is that only a small 
-subset of the O S ' s  state is  actually 
(horizontally  aligned, 
colored 
of injections have no effect on the benchmark 
coordina
seem to 
particular 
tes): These locations 
often originate 
in the 
address­
the 
benchmark and the 
vast majority 
run (white areas), and that failures 
same memory locations 
space/time 
memory space for  this 
critical 
chosen eCos configuration. 
the top ten program symbols respectively contiguous 
areas that caused the THREAD 1 benchmark 
to fail amount to 
ions. The 
99.87 % of all observed 
address­
MUTEX 1 results 
distribution: 
space clustering, 
As M UTEX 1 
exhibits 
a  different 
a different 
subset of the 
program state is  the 
(in the same table) display 
yet with a different 
OS usage profile, 
most critical. 
program terminat
abnormal 
a similar 
Table I confirms this assumption 
-
represent 
memory 
This baseline assessment reveals  that 
and application 
in the chosen set 
stacks and the 
the  kernel 
kernel data structures 
(thread, scheduler, 
th read, idle_ th read, th read_obj, ... )  are 
of benchmarks, 
scheduler-related 
cyg_libcmain_ 
the most susceptible. 
For  the 
focus on the  scheduler 
nature, 
and shrinking 
stack data  to 
data structures 
remainder 
of this paper, we will 
that are more static 
in 
of dynamically 
growing 
and postpone the protection 
future work. 
A. Baseline 
Assessment: 
eCos Fault Susceptibility 
B. Solution 
Requirements 
To assess the validity 
of this working hypothesis, we 
Our analysis in this section 
shows that, depending 
on the 
the fault resiliency 
examined 
programs  for 
benchmark 
kernel are implemented 
programs, 
eCos by fault-in
of a set of benchmark 
and test 
jection experiments. 
B oth the 
bundled with eCos itself,  and the  eCos 
in object-oriented 
C++, and compiled 
of the OS and the way it is used, the memory space 
"neuralgic 
than the remaining 
data objects that are much more 
only 
memory regions. 
spots", i.e., 
structure 
exhibits 
critical 
these critical 
By protecting 
could improve 
obj ects, a protection 
mechanism 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:00 UTC from IEEE Xplore.  Restrictions apply. 
THREADI 
(39.4%) 
(22.4%) 
Symbol Address  Size  #Failures  (%) 
thread 1,108,640 224  1.008 x 1010 
stack 1,108,864 6,816 5.730 x 109 
1,124,256  64  3.865 x 109 
1,117,760 132  8.537 x 108 
:dsr_lisUail 1,117,744  4  8.530 x 10' 
1,123,328 896  8.530 x 10' 
1,121,536 896  8.530 x 108 
1,108,016  4  8.529 x 10' 
ptl 1,115,684  4  8.528 x 108 
1,117,748  4  7.197 x 10' 
(15.1 %) 
(3.3%) 
(3.3%) 
(3.3%) 
(3.3%) 
CYlLReaITimeClock::rtc 
CYlLScheduler::scheduler 
Cyg_lnterrupt: 
haU nterrupcobjects 
hal_interrupt_handlers 
cYlLscheduler_sched_lock 
MUTEXI 
Symbol Address  Size  #Failures  (%) 
stack 1,109,664 10,224 3,189,208 (19.1 %) 
hal_ vsr_stats 
8 
cvarl 1,109,264 
thread_obj 1,109,312  352  3,107,236 (18.7%) 
1,108,800  256  2,721,620 (16.3%) 
827,282 (5.0%) 
1,121,984  132  764,988 (4.6%) 
761,936 (4.6%) 
546,710 (3.3%) 
523,754 (3.1%) 
508,128 (3.1%) 
499,968 (3.0%) 
8 
m l   1,109,244  12 
rnO  1,109,232  12 
1,121,964  4 
8 
cvarO 1,109,256 
results: 
Top ten fault-susceptible 
memory areas) for the unmodified 
(3.3%) 
CYlLlnterrupt::dsr_list 
(2.8%) 
cvar2 1,109,272 
symbols (or, contiguous 
(3.3%)  CYlLScheduler::scheduler 