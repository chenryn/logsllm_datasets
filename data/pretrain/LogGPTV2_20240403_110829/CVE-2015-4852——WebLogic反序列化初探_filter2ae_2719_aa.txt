# CVE-2015-4852——WebLogic反序列化初探
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
假期，我学习复现并调试分析了WebLogic反序列化漏洞中的CVE-2015-4852。在这个过程中，我学习里一些Java的基础知识，也借鉴了很多网上大牛的分析文章。
## 一、搭建环境
###  1.远程docker
​ 起初在Windows7和Ubuntu上搭建JDK7的环境来进行复现，整个软件搭建过程并不难，在这个过程中遇到一个良心博客，
​ 上面不仅提供了搭建的方法，还提供了WebLogic
10.3.6的网盘链接。搭建过程中我认为有几点需要注意：一是尽量Linux下尽量使用英文系统；二是如果多次遇到“请提供用于接收安全更新的电子邮件地址以启动配置管理器”不妨随便提供一个电子邮箱以完成这一步；三是进行配置时选择Development模式可能会好一些，否则从配置文件中可以看到，需要做额外的改动。
软件搭建好后，开始搭建调试环境，需要修改~/Oracle/Middleware/user_projects/domains/base_domain/bin/setDomainEnv.sh
在上方加入两行debug配置（Windows下为xxx/Oracle/Middleware/user_projects/domains/base_domain/bin/setDomainEnv.cmd，且下面的第一行需要改为set
debugFlag=”true”）
    debugFlag="true" 
    export debugFlag
但在调试过程中遇到了一些问题，
查看AdminServer中的日志，可以看到调用栈，
和下面的内容对比一下，我们会发现这个调用栈已经算是比较完整了，仅仅是最上面的invoke中缺少了entrySet这个元素，导致复现失败。
一时间不知如何解决这个问题，而且自己从头搭建也并非搭建环境的唯一方式，转而选择在Ubuntu上搭建Docker环境进行复现。
下载vulhub-master，经历一些基本操作之后，搭建环境，这里的方法不唯一，也可以不这么复杂。
先切换到合适的目录下，
DockerFile
    FROM vulhub/WebLogic 
    ENV debugFlag true 
    EXPOSE 7001 
    EXPOSE 8453
docker-compose.yml
    version: '2' 
    services: 
    WebLogic: 
    build: . 
    ports: 
    - "7001:7001" 
    - "8453:8453"
接下来执行如下命令以启动容器，
    sudo docker-compose build
    sudo docker-compose up –d
进入容器命令行
    su root
    docker exec -it b7ed /bin/bash
若要关闭容器，
    sudo docker-compose down
###  2.本地 Intellij
下载Intellij，
打开idea，创建一个Java web工程（若如此做则需是专业版），从Linux中把
/root/Oracle/Middleware/modules目录拷出来，在idea中File->Project
Structure里找到Libraries，添加modules，
接下来配置Remote调试，填写远程IP以及端口（setDomainEnv.sh中默认端口为8453），
通过xxx\Oracle\Middleware\user_projects\domains\win_domain\startWebLogic.sh启动wls，
若能看到类似如上的提示，则说明配置正常，
点击IDEA右上的debug按钮，开启调试，
配合网上的payload打一下，
可以成功断下，说明调试环境正常。
## 二、相关基础知识
​
几天的学习过程比较艰难，一方面要理解CVE-2015-4852的成因，一方面还不得不去学习Java的很多基础知识。虽然之前接触过一点PHP反序列化的内容，但学习这个CVE时仍然感到非常吃力。这两者之间虽有较大的相似点，但也有着明显的不同，相同点表现在都是通过一个构造好的链来触发，不同点在于PHP中的POP链更像是Java中链的一个片段，或曰比Java中考虑的要少一些，尤其是Java中寻找合适readObject函数也会花费不小的力气（1.可能是PHP有不少的魔术方法的缘故，2.只是个人理解）。
下面记录一些学习这个CVE过程中记录的比较有价值的基础知识。
###  1.Apache Commons Collections
Apache Commons
Collections是Apache软件基金会的项目，是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。其目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。作为Apache开源项目的重要组件，[Commons
Collections](http://commons.apache.org/proper/commons-collections/)包为Java标准的Collections
API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充，让应用程序在开发的过程中，既保证了性能，也能大大简化代码，故而被广泛应用于各种Java应用的开发。
尽管它的初衷是好的，但其中有一些代码不严谨，导致很多引用了这个库的Java应用程序(如WebLogic、Websphere、Jboss、Jenkin等)会产生RCE漏洞。Apache
Commons Collections的漏洞最初在2015年11月6日由FoxGlove
Security安全团队的[@breenmachine](https://github.com/breenmachine "@breenmachine")
在一篇长博客上阐述，危害面覆盖了大部分的Web中间件，影响十分深远，横扫了WebLogic、WebSphere、JBoss、Jenkins、OpenNMS的最新版。
###  2.反射机制
​
一开始看到反射就联想到反弹shell一类的内容，其实与那些并无干系，反射机制是Java的一种特性，可以理解为在运行中（而非编译期间）获取对象类型信息的操作。传统的编程方法要求程序员在编译阶段决定使用的类型，但是在反射的帮助下，我们可以动态获取这些信息，从而编写更加具有可移植性的代码。当然，反射并非某种编程语言的特性，理论上使用任何一种语言都可以实现反射机制，但是像Java语言本身支持反射，那反射的实现就会方便很多。
​根据网上的资料，JAVA反射机制的功能可以用如下几句话简要描述：  
在运行状态中，判断任意一个对象所属的类；  
在运行状态中，构造任意一个类的对象；  
在运行状态中，获取或修改任意一个类所具有的成员变量和方法；  
在运行状态中，调用任意一个对象的方法；  
另外还可生成动态代理和获取类的其他信息。
​我们知道在Java中一切都是对象，我们一般所使用的对象都直接或间接继承自Object类。Object类中包含一个方法名叫getClass，利用这个方法就可以获得一个实例的类型类。  
需要注意的是，反射机制在运行时只能调用methods或改变fields内容，却无法修改程序结构或变量类型。
###  3.Java Runtime类
​ Runtime类封装了运行时的环境，每个 Java 应用程序都有一个 Runtime
类实例，使应用程序能够与其运行的环境相连接。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。
一般情况下，不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime()
方法获取当前Runtime运行时对象的引用。
Runtime类提供了很多有价值的API，针对CVE-2015-8452用到的主要就是exec(String command)
（即在单独的进程中执行指定的字符串命令）。
###  4.Java 反序列化
​ 序列化就是把对象转换成字节流，便于传输和保存在内存、文件、数据库中；反序列化是序列化的逆过程，即将有结构的字节流还原成对象。
在Java中，java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object
obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。
与之对应，java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。
对象序列化包括如下步骤：
1） 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；
2） 通过对象输出流的writeObject()方法写对象。
对象反序列化的步骤如下：
1） 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；
2） 通过对象输入流的readObject()方法读取对象。
只有实现了Serializable和Externalizable接口的类且所有属性(用transient关键字修饰的属性除外，不参与序列化过程)都是可序列化的对象才能被序列化。在序列化（反序列化）的时候，ObjectOutputStream（ObjectInputStream）会寻找目标类中的重写的writeObject（readObject）方法，赋值给变量writeObjectMethod（readObjectMethod）。
###  5.Java 注解
Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java
语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java
标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容，也支持自定义
Java 标注。
Java 定义了一套注解，Java7之前有 7 个，3个在java.lang中，4个在 java.lang.annotation 中。
作用于代码的注解是如下3个，
[@Override](https://github.com/Override "@Override") –
检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误；
[@Deprecated](https://github.com/Deprecated "@Deprecated") –
标记过时方法。如果使用该方法，会报编译警告；