## 5.漏洞成因
此漏洞是对CVE-2021-1732漏洞的绕过，此处简要介绍下CVE-2021-1732漏洞：
用户调用CreateWindow时，在对应的内核态函数中检查到窗口的cbWndExtra不为0，通过xxxCreateWindowEx->
xxxClientAllocWindowClassExtraBytes->调用回调表第123项用户态函数申请用户态空间，
1027行会调用USER32!_xxxClientAllocWindowClassExtraBytes，EXP在回调函数中调用NtUserConsoleControl修改窗口的dwExtraFlag和pExtraBytes，修改窗口类型为控制台。
Windows修复代码在1039行，检查pExtraBytes是否被修改，此处查看汇编代码更为清晰
rdi+0x140-0x118 =
rdi+0x28，得到tagWNDK，偏移0x128得到pExtraBytes，判断是否不等于0，如果不等于0，1045行代码会跳转，最终释放窗口，漏洞利用失败。
也就是说：CVE-2021-1732的修复方法是在调用xxxClientAllocWindowClassExtraBytes函数后，在父函数CreateWindowEx中判断漏洞是否被利用了，这个修补方法之前是没有问题的。
但是在后续代码更新后，有了新的路径来触发xxxClientAllocWindowClassExtraBytes函数：
在xxxSwitchWndProc函数中调用xxxClientAllocWindowClassExtraBytes后也有检查pExtraBytes是否为0，如果不为0，那么就复制pExtraBytes内存数据到新申请的内存地址中，没有检查dwExtraFlag是否被修改。
> 总结：
> 由于CVE-2021-1732漏洞修补时是在父函数中修复的，虽然当时没有问题，但是当多了xxxClientAllocWindowClassExtraBytes函数的触发路径后，同样的漏洞又存在了，而且
> CVE-2021-1732漏洞触发路径是在xxxCreateWindowEx中，此时窗口句柄还未返回给用户态，漏洞利用时需要更多的技巧，此漏洞利用时已经返回了窗口句柄，利用起来更加简单。
## 6.利用漏洞的流程
本节介绍了漏洞触发的流程，并介绍了触发漏洞及利用漏洞需要的各个知识点。
漏洞触发利用的流程：
要利用这个漏洞，需要以下背景知识：
### 6.1 触发用户态回调
本节描述如何触发用户态回调，使内核回调到USER32!_xxxClientAllocWindowClassExtraBytes。
在IDA中查看xxxClientAllocWindowClassExtraBytes的引用，有多处地方调用到了此函数，
查看xxxSwitchWndProc代码如下：
98行代码有cbWndServerExtra变量赋值，而在调用SetWindowLong时会使用index-cbWndServerExtra，所以我们真正想设置内存区域偏移index位置的变量时，参数2应该传入index+ cbWndServerExtra。
103行代码调用xxxClientAllocWindowClassExtraBytes返回值赋值给了v20变量。
111行代码检查原来的pExtraBytes是否为0，如果不为0，那么就复制内存的数据，还会释放原来的pExtraBytes。
117、123行代码都会将v20变量赋值给pExtraBytes。
而xxxSwitchWndProc函数是可以通过win32u!
NtUserMessageCall函数来触发的，在用户态调用NtUserMessageCall函数会触发内核态函数xxxClientAllocWindowClassExtraBytes，函数调用堆栈如下：
    win32kfull!xxxClientAllocWindowClassExtraBytes  
    win32kfull!xxxSwitchWndProc+0x167  
    win32kfull!xxxWrapSwitchWndProc+0x3c  
    win32kfull!NtUserfnINLPCREATESTRUCT+0x1c4  
    win32kfull!NtUserMessageCall+0x11d    内核态  
    …  
    win32u! NtUserMessageCall             用户态  
在内核态的win32kfull!xxxClientAllocWindowClassExtraBytes函数中，会调用用户态的xxxClientAllocWindowClassExtraBytes函数。win32kfull!xxxClientAllocWindowClassExtraBytes函数如下：
KernelCallbackTable第123项对应_xxxClientAllocWindowClassExtraBytes函数，使用IDA查看函数内容：
此函数中调用RtlAllocateHeap函数来申请
_(a1)大小的内存，内存地址保存在addr变量中，然后调用NtCallbackReturn函数返回到内核态，返回的数据为addr变量的地址，对应在上面win32kfull!xxxClientAllocWindowClassExtraBytes函数中的v7变量，v7为addr变量的地址,_
v7即为上图中的addr。
> 总结：  
>  触发回调函数的路径为：
> Win32u!NtUserMessageCall(用户态)->win32kfull!NtUserMessageCall(内核态)->
> win32kfull!xxxSwitchWndProc(内核态)->
> win32kfull!xxxClientAllocWindowClassExtraBytes(内核态)->
> nt!KeUserModeCallback(内核态)->
> USER32!_xxxClientAllocWindowClassExtraBytes(用户态，HOOK此函数)  
>  本节讲了如何从用户态进入到内核，又回调到USER32!_xxxClientAllocWindowClassExtraBytes函数的方法。
### 6.2 HOOK回调函数
上一小节讲了触发到USER32!_xxxClientAllocWindowClassExtraBytes函数的流程，我们还需要hook此回调函数，在回调函数中触发漏洞。下面代码可以将回调函数表项第123、124分别修改为MyxxxClientAllocWindowClassExtraBytes、MyxxxClientFreeWindowClassExtraBytes。
### 6.3 修改窗口模式为模式1
上一小节讲了如何进入到用户态自定义的函数，本节讲述在自定义的函数中通过用户态未公开函数NtUserConsoleControl修改窗口模式为模式1，本节对NtUserConsoleControl函数进行逆向分析。
函数win32u!
NtUserConsoleControl可以设置模式为内核桌面堆相对寻址模式，此函数有三个参数，第一个参数为功能号，第二个参数为一个结构体的地址，结构体内存中第一个QWORD为窗口句柄，第三个参数为结构体的大小。
NtUserConsoleControl函数会调用到内核态win32kfull模块的NtUserConsoleControl函数，调用堆栈如下：
    win32kfull!NtUserConsoleControl        内核态
    win32k!NtUserConsoleControl+0x16       内核态
    nt!KiSystemServiceCopyEnd+0x25  
    win32u!NtUserConsoleControl+0x14       用户态
    CVE_2022_21882!wmain+0x3f4             用户态  
win32kfull模块NtUserConsoleControl判断参数，然后调用xxxConsoleControl如下：
17行判断参数index不大于6
22行判断参数length小于0x18
26行判断参数2指针不为空且length不为0
以上条件满足时会调用xxxConsoleControl函数，传入参数为index、变量的地址，传入数据的长度，
xxxConsoleControl函数会对index及len进行判断：
110行代码可知，index必须为6，113行代码可知len必须为0x10，115行到119行代码可知，传入参数地址指向的第一个QWORD数据必须为一个合法的窗口句柄，否则此函数会返回。
134、136行判断是否包含0x800属性，如果包含，v23赋值为内核桌面堆基地址+偏移量pExtraBytes，得到的v23为内核地址。
140行代码，如果不包含0x800属性，那么调用DesktopAlloc申请一段cbWndExtra大小的内存保存在v23中。
149到156行代码判断原来的pExtraBytes指针不为空，就拷贝数据到刚申请的内存中，并调用xxxClientFreeWindowClassExtraBytes->USER32!_xxxClientFreeWindowClassExtraBy释放内存。
159、160行代码使用内核地址v23减去内核桌面堆基址得到偏移量v21，将v21赋值给pExtraBytes变量。
使用如下代码可以修改窗口模式为模式1：
    ULONG64 buff[2]={hwnd}；  
    NtUserConsoleControl(6, &buff, sizeof(buff));即可将hwnd对应的窗口模式设置为模式1。  
> 总结：  
>  在自定义回调函数中调用win32u!NtUserConsoleControl可以设置窗口模式为模式1，传入参数需要符合下列要求：
>
>   1. 参数1 index必须为6
>   2. 参数2指向一段缓冲区，缓冲区第一个QWORD必须为一个合法的窗口句柄
>   3. 参数3 len必须为0x10
>
### 6.4 回调返回伪造偏移量
在_xxxClientAllocWindowClassExtraBytes
函数中调用NtCallBackReturn回调函数可以返回到内核态：
伪造一个合适的偏移量Offset，然后应该取Offset地址传给NtCallbackReturn函数，可以将offset赋值给pExtraBytes变量。
由于之前已经切换窗口为模式1，pExtraBytes含义为相对于内核桌面堆基址的偏移，再查看tagWNDK结构体，关注以下字段：
    +0x08   ULONG64 OffsetToDesktopHeap;    //窗口tagWNDK相对桌面堆基址偏移  
    +0xE8   DWORD dwExtraFlag;              //包含0x800即为模式1  
    +0x128  ULONG64 pExtraBytes;            //模式1：内核桌面堆偏移量 模式2：用户态指针  
OffsetToDesktopHeap为窗口本身地址tagWNDK相对于内核桌面堆基址的偏移，可以使用如下方法来伪造合适的偏移量：
  1. 创建多个窗口，如窗口0和窗口2(为了与EXP匹配)，窗口2触发回调函数，返回窗口0的OffsetToDesktopHeap ，赋值给窗口2的pExtraBytes变量。
  2. 对窗口2调用SetWindowLong时，写入的目标地址为：内核桌面堆基址+pExtraBytes+index，此时pExtraBytes为窗口0的地址偏移，对窗口2调用SetWindowLong可以写窗口0的tagWNDK结构数据，这是第一次越界写。
> 总结：  
>
> 调用NtCallbackReturn可以返回到内核中，伪造偏移量为窗口0的OffsetToDesktopHeap，赋值给窗口2的pExtraBytes，当对窗口2调用SetWindowLong时即可修改到窗口0的tagWNDK结构体。  
>  接下来我们需要获取窗口0的OffsetToDesktopHeap。
### 6.5 泄露内核窗口数据结构
上一小节中我们在用户态中要返回窗口0的OffsetToDesktopHeap到内核态，OffsetToDesktopHeap是内核态的数据，要想获取这个数据还需要一些工作。
调用CreateWindow只能返回一个窗口句柄，用户态无法直接看到内核数据，但是系统把tagWNDK的数据在用户态映射了一份只读数据，只需要调用函数HMValidateHandle即可，动态库中没有导出此函数，需要通过IsMenu函数来定位：
定位USER32!HMValidateHandle的代码如下：
定位到USER32!HMValidateHandle函数地址后，传入hwnd即可获取tagWNDK数据地址。
     tagWNDK* p = HMValidateHandle(hwnd)，通过tagWNDK指针即可获取到OffsetToDesktopHeap数据。
### 6.6 如何布局内存
通过上面的知识，我们可以通过窗口2修改窗口0的tagWNDK结构体数据，本节描述如何布局内存，构造写原语。
应该通过NtUserConsoleControl修改窗口0切换到模式1，这样对窗口0调用SetWindowLong即可修改内核数据，但是调用SetWindowLong时index有范围限制，所以通过窗口2将窗口0的tagWNDK.
cbWndExtra修改为0xFFFFFFFF，扩大窗口0可读写的范围。
现在我们开始内存布局：
1.创建窗口0，窗口0切换到模式1，pExtraBytes为扩展内存相对内核桌面堆基址的偏移量
窗口2触发回调后，回调函数中对窗口2调用NtUserConsoleControl，所以窗口2也处于模式1，pExtraBytes为扩展内存相对内核桌面堆基址的偏移量。
2.回调函数中返回窗口0的OffsetToDesktopHeap，此时内存如下：
图中红色线条，此时窗口2的pExtraBytes为窗口0的OffsetToDesktopHeap，指向了窗口0的结构体地址，此时对窗口2调用SetWindowLong即可修改窗口0的内核数据结构
3.通过窗口2修改窗口0的cbWndExtra
SetWindowsLong(窗口2句柄,