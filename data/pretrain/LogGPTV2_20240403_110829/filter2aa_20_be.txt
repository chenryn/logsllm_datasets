执行该脚本后，当前目录名就会通过 pwd 命令显示出来。
在使用了 Perl 的 open
 函数的脚本中，如果外界能够指定文件名，就能通过在文件名的前后加上管道符号 | 来实施 OS 命令注入攻击。
接下来我们就来演示如何发动攻击。以下为一段 CGI 脚本，其作用仅限于打开文件并将其显示。
代码清单 /4b/4b-004.cgi
#!/usr/bin/perl
use strict;
use utf8;
use open ':utf8';  # 将默认字符编码设为 UTF-8
use CGI;
print "Content-Type: text/plain; charset=UTF-8\r\n\r\n";
my $q = new CGI;
my $file = $q->param('file');
open (IN, $file) or die $!;  # 打开文件
print ;       # 显示文件的全部内容
close IN;         # 关闭文件
如果将查询字符串中的 file
 指定如下，/sbin 目录下的文件一览就会被显示在页面上 61
 。
file=ls+/sbin|
执行结果如下图所示。
图 4-101 显示了 /sbin 目录的文件一览
安全隐患的产生原因总结
Web 应用的开发语言中，有些函数的内部实现利用了 Shell。如果开发者使用了这些内部调用 Shell 的函数，就可能会使得意料之外的 OS 命令被执行。这种状态被称为 OS 命令注入漏洞。
OS 命令注入漏洞的形成需要同时满足以下三项条件。
使用了内部调用 Shell 的函数（system
 、open
 等）
将外界传入的参数传递给内部调用 Shell 的函数
参数中 Shell 的元字符没有被转义
60
 详情请参考以下链接：http://technet.microsoft.com/zh-cn/library/cc737438(v=ws.10).aspx
 。
61
 该脚本同时也存在目录遍历漏洞。详情请参考 4.10 节。
对策
为了防范 OS 命令注入漏洞，推荐大家使用下列方法中的任意一项，这里我们将以下四种方法按照推荐度由高到低进行了排序。
选择不调用 OS 命令的实现方法
避免使用内部调用 Shell 的函数
不将外界输入的字符串传递给命令行参数
使用安全的函数对传递给 OS 命令的参数进行转义
在设计阶段决定对策方针
具体选择哪一项对策方法，应当在设计阶段就确定下来。为此，建议在各个设计阶段分别探讨以下内容。
基本设计阶段
围绕代码实现方式的设计进行以下讨论。
决定主要功能的代码实现方针
尽量利用专门的程序库，迫不得已时再使用 OS 命令来实现
详细设计阶段
设计各功能的详细的实现方式时，极力避免使用内部调用 Shell 的函数
只能使用内部调用 Shell 的函数时，讨论决定是将参数固定，还是由标准输入来指定参数
下面我们就来分别看一下各个方法的详情。
选择不调用 OS 命令的实现方法
推荐度最高的方法为不调用 OS 命令，即不利用调用 Shell 的功能。这样一来，既杜绝了 OS 命令注入漏洞混入的可能性，又消除了调用 OS 命令的系统开销，能够从多方面提高应用的性能。
下面是利用 PHP 程序库重写之前的发送邮件脚本（/4b/4b-002.php）的例子。PHP 中发送邮件时可以利用 mb_send_mail
 函数。
代码清单 /4b/4b-002a.php
提问已受理
然而，发送邮件的功能中可能会引入邮件头注入漏洞，详情请参考 4.9 节。后面的一个示例脚本也有同样问题。
避免使用内部调用 Shell 的函数
在不调用 OS 命令就无法实现所需功能的情况下，调用 OS 命令时最好使用不经过 Shell 的函数。由于 PHP 中没有合适的函数 62
 ，因此这里以 Perl 为例进行讲解。而如果只是想了解 PHP 中的对策方法，则可以跳过本小节而直接阅读下一小节。
Perl 中也存在名为 system
 的函数来启动 OS 命令。Perl 的 system
 函数有两种指定命令和参数的方法，即既可以在一个参数中将它们用空格相隔，也可以将它们分别指定为函数的不同参数。下面为 Perl 脚本中启动 grep 命令的示例。
首先是经过 Shell 的调用方法。此调用方法存在 OS 命令注入漏洞。
my $rtn = system("/bin/grep $keyword /var/data/*.txt");
接下来是不经过 Shell 的调用方法。
my $rtn = system('/bin/grep', '--', $keyword, glob('/var/data/*.txt'));
像上面这样分别指定命令名和参数时，由于不经过 Shell，因此 Shell 的元字符（;
 、|
 、`
 等）就会作为命令的参数被直接传递。也就是说，理论上不会产生 OS 命令注入漏洞。
system
 函数的第 2 个参数中指定的 '--'，表示选项（Option）的指定已经结束，后面指定的都是选项以外的参数（Parameter）。如果不这样做，外界就可以通过 -R 等第一个字符为 - 的关键字来任意指定选项。
另外，system
 函数的第 4 个参数中用到了 glob
 函数，它能通过展开通配符（*.txt）来取得所有匹配的文件名（与 PHP 的 glob
 函数相同）。经过 Shell 调用命令时，Shell 会展开通配符，而不经过 Shell 时就需要像本例一样自己手动展开通配符。
在使用之前提到的 Perl 的 open
 函数时，可以采用以下任一方法来避免启动 Shell。
使用 sysopen
 函数来代替 open
 函数
在 open
 函数的第 2 个参数中指定访问模式（如下）
open(FL, '`
读写模式（覆盖）
`>>`
读写模式（追加）
`|-`
打开程序管道
`-|`
从程序或命令的输出中取得数据
比如，下面的例子中指定了 |- 模式。这是 Perl5.8 以后的版本支持的写法。此调用方法不经过 Shell，因此理论上不会产生 OS 命令注入漏洞。
代码清单 /4b/4b-002b.cgi
    #!/usr/bin/perl
    use strict;
    use CGI;
    use utf8;
    use Encode;
    my $q = new CGI;
    my $mail = $q->param('mail');
    # 在不经过 Shell 的情况下将 sendmail 命令作为管道打开
    open (my $pipe, '|-', '/usr/sbin/sendmail', $mail) or die $!;
    # 传入邮件内容
    print $pipe encode('UTF-8', 
    提问已受理
    EndOfHTML
需要注意的一点为，与 system
 函数同样，这里也应该使用多个参数的形式来指定命令与其参数。因为如果使用 /usr/sbin/sendmail $mail
 这种利用空格来区分命令和参数的形式，调用时就会经过 Shell，从而也就会引入 OS 命令注入漏洞。
不将外界输入的字符串传递给命令行参数
只能经过 Shell 调用 OS 命令的函数时，或者不清楚函数的内部实现是否经过 Shell 时，防范 OS 命令注入漏洞的根本性策略就是不将参数传递给命令行。
下面就让我们结合具体例子来看。sendmail 命令指定了 -t 选项后，收件人邮箱地址就不再在命令行中指定，而是变为从邮件的各个消息头 To、Cc、Bcc 中读取。采用这个方法，就可以不用将外界输入的字符串指定给命令行，从而也就消除了 OS 命令注入漏洞。
示例脚本如下。
代码清单 /4b/4b-002c.php
<?php
  $mail = $_POST['mail'];
  $h = popen('/usr/sbin/sendmail -t -i', 'w');
  if ($h === FALSE) {