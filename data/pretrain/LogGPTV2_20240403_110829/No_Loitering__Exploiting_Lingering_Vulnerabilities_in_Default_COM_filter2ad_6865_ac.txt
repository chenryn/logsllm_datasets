realistic to require each application to attempt to main-
tain security policies that can reasonably deal with this
threat.
It is clear that Windows requires an operating
system-level security policy governing the instantiation
of COM objects.
5 Mitigation Architecture
The lack of a central security policy governing the in-
stantiation of COM objects has been identiﬁed as a ma-
jor source of vulnerability in this paper. In this section,
a prototype of a mechanism which we call COMBlocker
is proposed that introduces an operating system-level se-
curity policy with reference monitor-like functionality.
This system will be used to enforce a security policy on
the instantiation of all COM objects.
5.1 Design Goals and Assumptions
The goal of COMBlocker is to provide a system-level
policy for the instantiation of all COM objects. If ev-
ery instantiation is monitored by a central policy, the
issue of transitive trust can be remedied. The design
of COMBlocker assumes that it is attempting to pre-
vent the initial infection vector described in the previ-
ous section.
It is not designed to secure a previously
infected machine. Additionally, the prevention mecha-
nism is designed to secure the instantiation of COM ob-
jects by applications that conform to Microsoft’s design
model. This is not intended to prevent intentionally ma-
licious applications from loading ﬂawed controls. These
assumptions follow a common theme: the goal is to pre-
vent the initial attack.
5.2 High Level Architecture
COMBlocker is designed to interpose itself in the in-
stantiation of all COM objects. In terms of the attack
described in Section 4.2, the COM object loaded by Mi-
crosoft Word would be matched against a security policy
and when that COM object in turn attempts to load an-
other COM object, that subsequent instantiation would
also be checked against the policy.
To create such a policy enforcement system, the in-
stantiation logic must be injected into every process on
the system. This can be accomplished by a number of
methods with varying levels of complexity and com-
pleteness. For reasons detailed later, COMBlocker in-
jects a dynamically-linked library into every running
process. This library contains the logic required to en-
force the security policy. Once the COMBlocker library
is injected into every process, calls to the COM instanti-
ation APIs need to be redirected to the library to verify
any object being loaded. We accomplish this through
binary patching in our prototype. As the COMBlocker
library is loaded, it locates the four COM instantiation
APIs and overwrites the function prolog with a jump to
the policy veriﬁcation code.
With the binary hooks in place, any application that
calls any of the COM instantiation APIs is redirected to
the security interface. This redirection will take place
regardless of the source of the call to the instantiation
API. In other words, the call to load a COM object could
come from a base executable, a library, a different COM
object, or any other type of executable code. Any call
to any of the instantiation APIs is veriﬁed against our
security policy.
Once we can verify the instantiation of an object, a
suitable policy must be deﬁned. For the sake of sim-
plicity our proof of concept starts by allowing the user
to apply the Internet Explorer killbit list to all COM ob-
ject instantiations. From there, a user can create excep-
tions to the killbit list or add disallowed objects on a
per-application or system-wide basis.
5.3 Detailed Architecture
COMBlocker was developed as a third-party add-on
for Microsoft Windows. It is not implemented by chang-
ing the underlying COM architecture or by invoking any
extended APIs. If Microsoft were to implement a simi-
lar system, they could simply change the COM instanti-
ation APIs to always check a central policy. The proof
of concept developed in this research is a prototype of
a system that a third-party could implement to provide
a central COM security policy. With that, the details of
how the solution was implemented are covered for com-
pleteness.
5.3.1 DLL Injection
To introduce the security policy veriﬁcation code into
every running process, COMBlocker uses DLL injec-
tion. This is the process by which an application forces
another application to load a DLL of its choosing. There
are several ways to inject a DLL into another process,
but since our solution requires injection into every pro-
cess, we chose to use the AppInit DLLs registry
key [18]. The operating system will load all DLL’s spec-
iﬁed in this key into every process, thereby providing
comprehensive coverage for all applications.
5.3.2 Binary Hooking
Once the library is injected into every process, control
ﬂow from the COM instantiation APIs must be redi-
rected to the COMBlocker security policy. Our proof
of concept accomplishes this redirection through binary
Figure 5. Hooking Architecture for COMBlocker. Using binary rewriting, we force all COM
objects to be checked against the global policy at their instantiation. Note on the left the policy
check – call AlertCLSID; test eax, eax;
patching. The binary patching used by COMBlocker is
very similar to the Detours API created by Microsoft Re-
search [11]. In the case of COMBlocker, the function
prolog of every COM instantiation API is overwritten
with code that will jump to the security policy veriﬁca-
tion code in our library. As part of the DLLMain() func-
tion, our library will locate the four instantiation APIs
and overwrite the ﬁrst ﬁve bytes of the function prolog
with a jump to the code that implements the policy ver-
iﬁcation. Since the ﬁrst ﬁve bytes of the function have
been overwritten, the ﬁrst few instructions of the policy
veriﬁcation code must reproduce the functionality of the
original API. Once these instructions are executed, the
security policy enforcement can commence. Figure 5
shows the interception of control ﬂow by COMBlocker
to check against a global policy.
5.3.3 Enforcement Logic
Once the control ﬂow has been redirected from the in-
stantiation APIs to our own logic, we then have access
to the arguments to those APIs. This provides us with
the necessary information to create an enforcement pol-
icy. Speciﬁcally, the CLSID of the object being instan-
tiated is passed to the instantiation APIs as the ﬁrst ar-
gument. In our enforcement logic, we retrieve a pointer
to the CLSID from the stack of the instantiation API. If
the CLSID is speciﬁcally blocked by the security policy
in the registry, the enforcement logic simply returns the
error REGDB E CLASSNOTREG to the calling applica-
tion. This returns an invalid handle that the calling appli-
cation cannot use for interacting with the object. All ap-
plications tested gracefully handled this error condition,
but if one did not, it would crash rather than allowing the
exploit to continue.
5.3.4 Policy Deﬁnition
In COMBlocker, we wished to have a simple starting
point to deﬁne the security policy. As such, the Internet
Explorer killbit list can be applied to any application on
the system or to the system as a whole. This is accom-
plished by setting a value in the registry in a location cre-
ated by COMBlocker. The enforcement logic checks to
see if this value is set. If it is, the killbit list is read from
its default location in the registry and used for compar-
ison against the CLSID the application is attempting to
load. It is important to note that this is different than the
security policy currently employed by Microsoft Word.
In Word, the policy is only applied to the objects instan-
tiated by the base executable. In our system, all instan-
tiations are monitored.
Once the killbit list is applied to an application, ex-
emptions or additions to the list can be manually entered.
These modiﬁcations are also set in the COMBlocker reg-
istry hive. For each application, subkeys in the registry
are used to deﬁne by CLSID which objects are speciﬁ-
cally allowed or speciﬁcally denied. This allows the user
Figure 6. COMBlocker Successfully Stopping Instantiation
to create detailed white lists and black lists for every ap-
plication or the system as a whole.
As mentioned in Section 3.3, it is unrealistic for a
user to try to maintain lists of controls that should be
considered secure and insecure. As such, it is the vision
for a system like this to be implemented by Microsoft
or a third party vendor. In these cases, Microsoft (or the
vendor) could keep track of the known ﬂawed controls
and ensure they cannot be instantiated by any applica-
tion except those speciﬁcally requiring them. Addition-
ally, applications could be proﬁled to enumerate only
those controls that should be instantiated under normal
operation. In cases where this is possible, detailed white
lists could also be created.
6 Results and Discussion
6.1 Breadth of Vulnerability
The ﬁrst objective described in this paper was to de-
termine the breadth of the vulnerability. The issue of
transitive trust amongst COM objects was hypothesized
to exist in all COM containers which load content pro-
vided by a third party. This proved to be true for ev-
ery application that was tested. Throughout the research,
the attack described in Section 4 was reproduced in Mi-
crosoft WordPad, Microsoft Excel, Microsoft Power-
point and Adobe Reader. The question of how additional
third party COM containers might behave was also ap-
proximated. Microsoft Visual Studio 6 ships with a util-
ity called the ActiveX Control Test Container. This util-
ity allows developers to test the functionality of COM
objects without having to create their own COM con-
tainer. This loosely represents how a generic COM con-
tainer would behave under normal circumstances. The
attack from Section 4 was also successful in this tool,
meaning that a signiﬁcant number of other third-party
applications are also vulnerable to these attacks.
Each application tested was coerced into loading a
COM object that was in direct violation of its security
policy (where one exists). Generally speaking, these se-
curity policies are used to prevent the instantiation of
COM objects that are known to contain vulnerabilities.
In many cases, these security policies are used in lieu of
ﬁxing the vulnerabilities. With the research presented in
this paper, each of the loitering vulnerabilities in those
controls can be resurrected and used for successful com-
promise.
6.2 Effectiveness of the Solution
We tested COMBlocker’s effectiveness and measured
the overhead it imposes on a standard desktop system.
The ﬁrst step in testing the effectiveness of the solu-
tion was to apply it to each of the applications that were
found to be vulnerable in the section above. For each ap-
plication that was shown to be vulnerable, COMBlocker
presented the user with the dialog box shown in Figure
6. This dialog box shows that the application attempted
to load a control that is speciﬁcally denied by the deﬁned
policy. It also indicates that the instantiation of the ob-
ject was prevented. COMBlocker was successfully able
to prevent the attack described in Section 4 in Microsoft
WordPad, Word, Excel, and PowerPoint as well as the
ActiveX Control Test Container.
Demonstrating the formal completeness of our solu-
tion is difﬁcult. Our mechanism is helped by the fact
that there are only a small number of publicly known
means by which COM objects can be instantiated. In-
jecting COMBlocker at these points should logically
prevent applications from circumventing policy enforce-
ment. However, if applications can instantiate COM ob-
jects through other unknown means such as implement-
ing their own APIs, these interfaces would also need to
be modiﬁed and mediated.
6.3 Performance
A version of COMBlocker was created that logged
the time required for each policy lookup encountered
throughout the operation of an application. The test
build was installed on a typical development worksta-
tion and gathered information for all of the COM object
instantiations that occurred during a single day as part
of a developer’s normal work. The test workstation was
a Windows XP SP3 machine with Ofﬁce 2007, Internet
Explorer 7, Firefox 3, Lotus Notes 8, Visual Studio 6,
and several other commonly installed applications.
During the course of the day, the behavior of the de-
veloper caused over 65,000 COM instantiations. Each of
these recorded an average policy lookup time of 554µs
to complete, with a 95% conﬁdence interval of ±104µs.
The variation in lookup time is largely due to the fact
that consulting the killbit list in the registry is accom-
plished through a linear scan of the subkeys; it is not
indexed. Testing shows that an average application in-
curs less than 10 policy lookups per user action. With
that, each user action generates less than 5ms of delay
due to COMBlocker.
Another data point gathered in this test is that in
general, Ofﬁce applications and web browsers incurred
a lower lookup time than core operating system com-
ponents. When the data set is reduced to only Of-
ﬁce applications and web browsers, the average lookup
time drops to 104µs, with a 95% conﬁdence interval of
±14.2µs. This indicates that if performance were an
issue in implementing a system like COMBlocker, the
scope of the protection could be reduced to only those
applications that are more easily targeted in COM-based
attacks.
6.4 Discussion on Policy Creation
As mentioned in Section 5, the base policy for each
application (or the system as a whole) was the Internet
Explorer killbit list. It appears that over time, several
COM objects required for the normal operation of many
of the applications tested have been killbitted. In other
words, there exist several COM objects that are critical
to the operation of Microsoft Word, Excel, and even In-
ternet Explorer that are in the killbit list. The question
arises: How can COM objects critical to Internet Ex-
plorer end up in the killbit list? The answer is that the
killbit list blocks the instantiation of COM objects by
the IE scripting engines, not the base IE executable. An
example of this occurred when COMBlocker applied the
killbit list to Internet Explorer as a whole, the navigation
bar was prevented from being instantiated.
The takeaway from this result of the testing is that
the killbit list cannot be blindly applied to every appli-
cation or the system as a whole. As policies are created,
the killbit list can be used as a base, but modiﬁcations
are required for each application being monitored. Any
entity choosing to provide a solution like COMBlocker
must take great care to ensure the security policies they
deﬁne will allow for the normal operation of each moni-
tored application while still providing a suitable level of
security.
6.5 Future Enhancements to COMBlocker
As mentioned above, policy creation can be quite
complex. While the killbit list is a good starting point
for a blacklist, it simply does not apply as-is to every
application on the system. A useful enhancement to
COMBlocker (or an accompanying tool) would be one
that allows for the proﬁling of applications under nor-
mal use. This would help to expedite the identiﬁcation
of controls listed in the killbit list that are critical to the
operation of other applications.
Additionally, more research is required to determine
the feasibility of runtime analysis of persistence streams.
It could be possible to analyze data contained in a per-
sistence stream and ﬁlter access to that data based on
policy. For example, one policy could be to ensure that
COM objects may only load simple data types and can-
not load the more complex types, which could force the
instantiation of other objects.
6.6 Comparsion to Microsoft-Issued Patch
On June 8, 2010, Microsoft released Security Bul-
letin MS10-036 in response to our private disclosure of
this vulnerability. This patch attempts to prevent the at-
tacks discovered and demonstrated in this paper. Specif-
ically, this patch extends the killbit list to nested COM
instantiations made by Microsoft Ofﬁce. While this
patch effectively prevents Ofﬁce-generated ﬁles from in-
cluding these attacks, it does not protect any other ap-
plication that takes advantage of the COM infrastruc-
ture. Accordingly, this patch does not provide the se-
curity guarantees of COMBlocker, and therefore means
that Windows-based systems still remain vulnerable to
such attacks through other applications.
7 Conclusion
COM has provided developers with an extremely
ﬂexible and extensible framework for the creation and
use of myriad software components. However, we have
shown in this paper that a lack of central security pol-
icy for the instantiation of COM objects allows a single
ﬂawed control to pose a security threat to all applications