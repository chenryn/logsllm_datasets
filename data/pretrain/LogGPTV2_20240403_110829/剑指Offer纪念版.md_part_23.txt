特殊输入测试（指向后序遍历序列的指针为NULL指针）。
功能测试（输入的后序遍历的序列对应一棵二叉树，包括完全二
子入手，通过分析具体的例子寻找规律。
编码相对而言就简单了。在面试的时候，应聘者可以从一两个例
者是否能找出后序遍历的规律。一旦找到规律了，用递归的代码
考查分析复杂问题的思维能力。
树；输入的后序遍历的序列没有对应一棵二叉树)。
叉树、所有结点都没有左/右子树的二叉树、只有一个结点的二叉
一名企面试官精讲典型编程题（纪念版）
：判断该数组是不是某二叉搜索树的前序遍历的结
，能否解决这道题的关键在于应聘
---
## Page 157
过结点10、12
白白
之和是19。这个和不等于输入的值22，因此不是符合要求的路径。
点也添加到路径中。这个时候已经到达了叶结点，但路径上三个结点的值
两个结点，它们的值分别是10和5。接下来遍历到结点4，我们把这个结
时候，我们都把当前的结点添加到路径中去。到达结点5时，路径中包含
结点的，除非我们把经过的路径上的结点保存下来。每访问到一个结点的
指向父结点的指针，访问到结点5的时候，我们是不知道前面经过了哪些
会访问结点5。从二叉树结点的定义可以看出，在本题的二叉树结点中没有
点的。
在树的前序、中序、后序三种遍历方式中，只有前序遍历是首先访问根结
点，也就是说路径总是以根结点为起始点，
时候我们可以试着从一两个具体的例子入手，找到规律。
聘者而言，这是一个新概念，也就很难一下子想出完整的解题思路。这个
包含结点10、12，第二条路径包含结点10、5和7。
struct BinaryTreeNode
成一条路径。二叉树结点的定义如下：
入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形
面试题25：二叉树中和为某一值的路径
按照前序遍历的顺序遍历图4.7中的二叉树，在访问结点10之后，就
以图4.7的二叉树作为例子来分析。由于路径是从根结点出发到叶结
一般的数据结构和算法的教材都没有介绍树的路径，因此对大多数应
例如输入图4.7中二叉树和整数22，则打印出两条路径，第一条路径
int
题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输
6
国
m_pRight
m_nValue;
mpLert
，因此我们首先需要遍历根结点。
第4章解决面试题的思路143
---
## Page 158
144
6
u
3
2
步骤
剑指Offer-
一致，而递归调用的本质就是一个压栈和出栈的过程。
难看出保存路径的数据结构实际上是一个栈，因为路径要与递归调用状态
的值，以确保返回父结点时路径刚好是从根结点到父结点的路径。我们不
结点。因此我们在函数退出之前要在路径上删除当前结点并减去当前结点
继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父
当前的路径符合要求，我们把它打印出来。如果当前结点不是叶结点，则
值。如果该结点为叶结点并且路径中结点值的和刚好等于输入的整数，则
的方式访问到某一结点时，我们把该结点添加到路径上，并累加该结点的
访问结点12
回到结点10
回到结点5
访问结点7
回到结点5
访问结点4
访问结点5
访问结点10
操作
结点的值之和也是22，因此这也是一条符合条件的路径。
在路径上删除子结点。
5回到结点10。同样，每一次当从子结点回到父结点的时候，我们都需要
时路径中三个结点10、5、7之和刚好是22，是一条符合要求的路径。
路径中删除。接下来访问到结点7的时候，再把该结点添加到路径中。此
时候，由于结点4已经不在前往结点7的路径上了，我们需要把结点4从
回到结点5，再去遍历结点5的右子结点7。值得注意的是，回到结点5的
我们最后要遍历的结点是12。在遍历这个结点之前，需要先经过结点
分析完前面具体的例子之后，我们就找到了一些规律。当用前序遍历
我们可以用表4.5总结上述的分析过程。
我们接着要遍历其他的结点。在遍历下一个结点之前，先要从结点 4
一名企面试官精讲典型编程题（纪念版）
表4.5遍历图4.7中的二叉树的过程
是
是
否
是否叶结点
。最后从结点10到达结点12的时候，路径上的两个
结点10、结点12
结点10
结点10、结点5
结点10、结点5、结点7
结点10、结点5
结点10、结点5、结点4
结点10、结点5
结点10
路径
22
15
6
15
路径结点值的和
---
## Page 159
路径，每一次都用 push_back 在路径的末尾添加结点，用 pop_back 在路径
void FindPath
void FindPath(BinaryTreeNode*pRoot,int expectedSum)
在前面的代码中，我们用标准模板库中的vector实现了一个栈来保存
path.pop_back();
//在返回到父结点之前，在路径上删除当前结点
if(pRoot->m_pRight !=NULL)
if(pRoot->m_pLeft!=NULL)
//如果不是叶结点，则遍历它的子结点
if(currentSum
bool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;
//如果是叶结点，并且路径上结点的和等于输入的值
path.push_back(pRoot->m_nValue);
currentSum
int
std::vector&
int
BinaryTreeNode*
FindPath(pRoot,expectedSum,path,currentSum);
//打印出这条路径
std::vectorpath;
if（pRoot == NULL)
形成了清晰的思路之后，就可以动手写代码了。下面是一段参考代码：
FindPath(pRoot->m_pRight, expectedSum, path, currentSum);
printf("\n");
std::vector::iterator iter =path.begin();
printf("A path is found:");
return;
printf("%d\t"，
+=pRoot->m_nValue;
==expectedSum
1=
path.end();++iter)
currentSum
path,
expectedSum,
pRoot,
*iter);
expectedSum,
&&isLeaf)
第4章
解决面试题的思路145
path，
currentSum);
---
## Page 160
146剑指Offer-
些小问题，那可能也会容易很多。
候，如果能够先把大问题分解成若干个简单的小问题，然后再逐个解决这
战胜小股敌人就容易多了。同样，在面试中当我们遇到复杂的大问题的时
败被分割开来的小部分敌人。要一下子战胜总体很强大的敌人很困难，但
敌我实力悬殊时，我们可以把强大的敌人分割开来，然后集中优势兵力打
分解让复杂问题简单化
选择。
需要得到路径上的所有结点，因此在代码实现的时候 std:stack不是最好的
中的 stack 的原因是在 stack 中只能得到栈顶元素，而我们打印路径的时候
的末尾删除结点，这样就保证了栈的先入后出的特性。这里没有直接用STL
很多读者可能都知道“各个击破”的军事思想，这种思想的精髓是当
我们可以按照解决问题的步骤来分解复杂问题，每一步解决一个小问
本题完整的源代码详见25_PathInTree项目。
本题考点：
测试用例：
源代码：
考查对二叉树的前序遍历的理解。
包含哪些结点，这样就能找出其中的规律，从而想到解决方案。
考查分析复杂问题的思维能力。应聘者遇到这个问题的时候，如果
特殊输入测试（指向二叉树根结点的指针为NULL指针）。
有符合条件的路径）。
功能测试（二叉树中有一条、多条符合条件的路径，二叉树中没
一名企面试官精讲典型编程题（纪念版）
一下子没有思路，不妨从一个具体的例子开始，一步步分析路径上
---
## Page 161
图4.8一个含有5个结点的复杂链表
虚线箭头表示m_pSibling 指针。为简单起见，指向NULL 的指针没有画出。
structComplexListNode
结点的C++定义如下：
向下一个结点外，还有一个m_pSibling指向链表中的任意结点或者NULL
复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指
面试题26：复杂链表的复制
分治法的应用，可以用递归实现。
那么第一个字符之后的字符串的排列就是一个小问题。因此这实际上也是
换，交换之后再求后面所有字符的排列。整个字符串的排列是一个大问题，
一个字符及它后面的所有字符。我们先拿第一个字符和后面的每个字符交
就解决了整个大问题。通常分治法思路都可以用递归的代码实现。
子树两个小问题，然后再把转换左右子树得到的链表和根结点链接起来，
换整个二叉树是一个大问题，我们先把这个大问题分解成转换左子树和右
案结合起来解决大问题。比如面试题27“二叉搜索树与双向链表”中，转
击破的思想。我们把分解之后的小问题各个解决，然后把小问题的解决方
函数完成一个功能，整个过程的逻辑也就非常清晰明了了。
分解成三个步骤。在写代码的时候我们为每一步定义一个函数，这样每个
ComplexListNode*
ComplexListNode
题目：请实现函数ComplexListNode*Clone（ComplexListNode*pHead)
在面试题28“字符串的排列”中，我们把整个字符串分为两部分：第
在计算机领域有一类算法叫分治法，即“分而治之”，采用的就是各个
图4.8是一个含有5个结点的复杂链表。图中实线箭头表示m_pNext指针，
int
m_psibling;
第4章解决面试题的思路147
---
## Page 162
148
?
剑指Offer-
图4.9
结构，如图4.9所示。
N"。这一次，我们把N链接在N的后面。图4.8的链表经过这一步之后的
效率。第三种方法的第一步仍然是根据原始链表的每个结点N创建对应的
O(n²)降低到 O(n)。
个大小为 O(n)的哈希表，也就是说我们以 O(n)的空间消耗把时间复杂度由
用O(1)的时间根据S找到S"。
S，那么在复制链表中，对应的N"应该指向S'。由于有了哈希表，我们可以
上每个结点的m_pSibling。如果在原始链表中结点N的m_pSibling指向结点
时我们把的配对信息放到一个哈希表中。第二步还是设置复制链表
每个结点N创建N’，然后把这些创建出来的结点用m_pNext链接起来。同
在这方面去做优化。我们还是分为两步：第一步仍然是复制原始链表上的
链表头结点开始经过0(n)步才能找到，因此这种方法的总时间复杂度是0(n²)
m_pSibling 指针。
m_pNext 指针s 步。用这种办法我们就可以为复制链表上的每个结点设置
上结点N'的m_pSibling（记为 S"）离复制链表的头结点的距离也是沿着
始链表的头结点开始沿着m_pNext经过s步找到结点S，那么在复制链表
的后面，所以要定位S的位置需要从原始链表的头结点开始找。如果从原
m_pSibling 指向结点S,由于S 的位置在链表中可能在N的前面也可能在N
是设置每个结点的 m_pSibling 指针。假设原始链表中的某个结点 N 的
第一步是复制原始链表上的每一个结点，并用 m_pNext 链接起来；第二步
外，还有指向任意结点的指针（虚线箭头）。
接下来我们再换一种思路，在不用辅助空间的情况下实现O(n)的时间
由于上述方法的时间主要花费在定位结点的m_pSibling上面，我们试着
对于一个含有n个结点的链表，由于定位每个结点的m_pSibling 都需要从
第二种方法相当于用空间换时间。对于有n个结点的链表我们需要一