evaluation)”）。这样，正则表达式、待匹配的文本和匹配速度之间就建立了某种联系。
DFA与NFA：匹配结果的差别
DFA（或者POSIXNFA）返回最左边的最长的匹配文本。传统型NFA可能返回同样的结果，
当然也可能是别的文本。针对某一型具体的引擎，同样的正则表达式，同样的文本，总是
得到同样的结果，在这个意义上来说，它不是“随机”的，但是其他NFA引I擎可能返回不
一样的结果。事实上，我见过的所有传统型NFA返回的结果都是一样的，但并没有任何标
准来硬性规定。
---
## Page 208
182
第4章：表达式的匹配原理
DFA与NFA：能力的差异
NFA引擎能提供些DFA不支持的功能，例如：
捕获由括号内的子表达式匹配的文本。相关的功能是反向引用和后匹配信息（after-
matchinformation），它们描述匹配的文本中每个括号内的子表达式所匹配文本的位置。
坏视，以及其他复杂的零长度确认（注8）（133）。
非匹配优先的量词，以及有序的多选结构。DFA很容易就能支持选择最短的匹配文本
（尽管因为某些原因，这个选项似乎从未向用户提供过），但是它无法实现我们讨论过
的局部的忽略优先性和有序的多选结构。
占有优先量词（142）和固化分组（139）。
兼具DFA的速度和NFA的功能：正则表达式的终极境界
我已经多次说过，DFA不能支持捕获括号和反向引用。这无疑是对的，但这并不是说，
我们不能组合不同的技术，以达到正则表达式的终极境界。180页的补充内容描述了
NFA为了追求更强大的功能，如何脱离了纯理论的道路和限制，DFA的情况也是如此。
受自身结构的限制，DFA进行这种突破更加困难，但并非不可能。
GNUgrep采取了一种简单但有效的策略。它尽可能多地使用DFA，在需要反向引用的
时候，才切换到NFA。GNUaWk的办法也差不多一一在进行“是否匹配”的检查时，
它采用GNUgrep的DFA引擎，如果需要知道具体的匹配文本的内容，就采用不同的
引擎。这里的“不同的引擎”就是NFA，利用白己的gensub函数，GNUawk能够很
方使地提供捕获括号。
Tcl的正则引擎由HenrySpencer（你或许记得，这个人在正则表达式的早期发展和流
行中扮演了重要的角色）开发，它也是混合型的。Tcl引擎有时候像NFA-一它支持
环视、捕获括号、反向引用和忽略优先量词。但是，它也确实能提供POSIX的最左最
长匹配（177），但没有我们将在第6章看到的NFA的问题。这点确实很棒。
注8：lex提供的trailingcontexr等价于正则表达式末尾的零长度肯定环视、但它并不能应用到末
尾之外的环视结构中。
---
## Page 209
总结
183
DFA与NFA：实现难度的差异
尽管存在限制，但简单的DFA和NFA引擎都很容易理解和实现。对效率（包括时间和空间
效率）和增强性能的追求，令实现越来越复杂。
用代码长度来衡量的话，支持NFA正则表达式的edVersion7（1979年1月发布）只有不
到350行的C代码（所以，整个grep只有区区478行代码）。HenrySpencer1986年免费提
供的Version8正则程序差不多有1900行C代码，1992年TomLord的POSIXNFApackage
rx（被GNUsed和其他工具采用）长达9700行。
为了颗合DFA和NFA的优点，GNUegrepVersion2.4.2使用了两个功能完整的引擎（差不
多8900行代码），Tcl的DFA/NFA混合引擎（请看上一页的补充内容）更是长达9500行。
某些实现很简单，但这并不是说它们支持的功能有限。我曾经想要用Pascal的正则表达式
来处理某些文本。从毕业以后我就没用过Pascal了，但是写个简单的NFA引擎并不需要太
多工夫。它并不追求花哨，也不追求速度，但是提供了相对全面的功能，非常实用。
总结
Summary
如果你希望一遍就能读懂本章的所有内容，大概得做点准备。至少，这些东西不那么容易
理解。我花了些时间才理解它，花了更长的时间才真正弄懂。我希望这章简要的讲解能够
降低读者理解的难度。我尝试过简单地解释，同时不要调人太简单的陷阱（不幸的是，太
过直白的解释总是妨碍了真正的理解)。本章有许多这样的陷阱，所以我在其中安排了许多
对其他页的引用，在下面的摘要中，读者可以很快地找到其他的内容。
实现正则表达式匹配引擎有两种常见的技术，一种是“表达式主导的NFA”（153），另一
种是“文本主导的DFA”（155）。它们的全称见第156页。
---
## Page 210
184
第4章：表达式的匹配原理
这两种技术，结合POSIX标准，可以按照实用标准划分3种正则引擎：
·
传统型NFA（汽油驱动，功能强大)。
·
POSIXNFA（汽油驱动、符合标准）。
DFA（不一定符合POSIX）（电力驱动，运转稳定）。
为了对手头的工具有个大致的了解，你需要知道它采用的是什么引擎，以对正则表达式做
相应的调校。最常见的引擎就是传统型NFA，其次是DFA。表4-1（145）列出了若干常
用工具及它们使用的引引擎类型，“测试引擎的类型”（146）给出了测试引擎类型的方法。
对于任何引擎来说，都有一条通用的规则：开始位置靠先的匹配文本优先于开始位置靠后
的匹配文本。因为“传动机构”会从前往后在文本的各个位置展开尝试（148)。
对于从某个位置开始的匹配：
文本主导的DFA引擎：
寻找可能的最长的匹配文本。不再介绍（177）。稳定、速度快（179），讲解起来
很麻烦。
表达式主导的NFA引擎：
匹配过程中可能需要“反复尝试（workthrough）”。NFA匹配的灵魂是回溯（157，
162)。控制匹配过程的元字符：标准量词（星号等等）是匹配优先的（151），其他
量词是忽略优先或者占有优先的（169）。在传统型NFA中，多选结构是有序排列的
(174)，在POSIXNFA中是匹配优先的。
POSIXNFA必须找到最长的匹配文本。但是，匹配并不难理解，只须考虑效率（第6
章的问题）。
传统型NFA控制能力最强的正则引擎，因此使用者可以使用该引擎的表达式主导性质
来精确控制匹配过程。
理解本章的概念和练习是书写正确而高效的正则表达式的基础，这也是接下来两章的主题。
---
## Page 211
章
正则表达式实用技巧
PracticalRegexTecliniques
现在我们已经掌握了编写正则表达式所需的基本知识，我希望在更复杂的环境中应用这些
知识来处理更复杂的问题。每个正则表达式都必须在下面两个方面求得平衡：准确匹配期
望匹配的内容，忽略不期望匹配的字符。我们已经看过许多例子都说明，如果应用得当，
匹配优先非常有用，但如果不够小心，也可能带来麻烦，在本章我们还将看到许多例子。
NFA引擎还需要平衡另外一个因素：效率，这也是下一章的主题。设计糟糕的正则表达式
一即使可以认为没犯错误一也足以让引擎瘫痪。
本章出现的主要是各种实例，我会带领读者循着我的思路去解决各种问题。某些例子或许
对读者并没有现实价值，但我仍然推荐读者阅读这些实例。
例如，即使你的工作不涉及HTML，我仍推荐你从处理HTML的实例中吸取知识。原因在
于，编写巧妙的正则表达式不仅仅是一种手艺（skili）一而且还是一种艺术（art）。它的
教授和学习，不是依靠罗列规则，而是依靠经验，所以，我用这些例子告诉读者，自己在
当然，读者仍然需要自己掌握这些知识，但是研究本章的例子是个好的起点。
---
## Page 212
186
第5章：正则表达式实用技巧
正则表达式的平衡法则
Regex Balancing Act
好的正则表达式必须在这些方面求得平衡：
只匹配期望的文本，排除不期望的文本。
·必须易于控制和理解。
如果使用NFA引擎，必须保证效率（如果能够匹配，必须很快地返回匹配结果，如果
不能匹配，应该在尽可能短的时间内报告匹配失败）。
这些方面常常是与具体文本相关的。如果我只使用命令行，只需要快速地grep某些东西，
可能不会过分关心匹配的准确性，通常也不会花太多精力来调校。我不在乎多花点时间来
手工排查，因为我能够迅速地在输出中找到自己需要的内容。但是，如果处理重要的程序，
就需要花费时间精力来保证正确性：如果需要，正则表达式也可能很复杂。这些因素都需
要权衡。
即使使用同样的程序，效率也是与具体文本相关的。如果是NFA，用^-（display！
geometry|cemap1.|quick24|random|raw)si之类长长的正则表达式来检验命令行参数
的效率就很低，因为多选分支过多，但如果它只用于检验命令行参数（可能只是在程序开
始的时候运行若干次），即使所需时间比正常的长100倍也不要紧，因为这时候效率并不是
问题。但是，如果要逐行检查很大的文件，低效率的程序运行起来会让你痛苦不堪。
若干简单的例子
A Fere Short Examples
匹配连续行（续前）
Continuing oith Contination Lines
继续前一章中匹配连续行的例子（178），我们发现（在传统型NFA中使用\w+=.*（\\\n.
*）*并不能匹配下面的两行文本：
SRC=array.c builtin.c eval.c field.c gawkmisc.c io.c main.c\
missing.c msg.c node.c re.c version.c
问题在于，第-个.*一直匹配到反斜线之后，这样（\n.*)*就不能按照预期匹配反斜
线了。所以，本章出现的第一条经验就是：如果不需要点号匹配反斜线，就应该在正则表
达式中做这样的规定。我们可以把每个点号替换成[^\n\\]：（请注意，\n包含在排除性字
符组中。你应该记得，原来的正则表达式的假设之一就是，点号不会匹配换行符，我们也
不希望它的替代品能够匹配换行符119页）。
---
## Page 213
若干简单的例子
187
于是，我们得到：
(\w+=[~1n1*(111n[~1n11)*
它确实能够匹配连续行，但因此也产生了一个新的问题：这样反斜线就不能出现在一行的
非结尾位置。如果需要匹配的文本中包含其他的反斜线，这个正则表达式就会出问题。现
在我们假设它会包含，所以需要继续改进正则表达式。
迄今为止，我们的思路都是，“匹配一行，如果还有连续行，就继续匹配”。现在换另-一种
思路，这种思路我觉得通常都会奏效：集中关注在特定时刻真正容许匹配的字符。在匹配
一行文本时，我们期望匹配的要么是普通（除反斜线和换行符之外）字符，要么是反斜线
与其他任何字符的结合体。在点号通配模式中，\.能匹配反斜线加换行符的结合体。
所以，正则表达式就变成了^\w+=（[^\n\\]1\\.）*，在点号通配模式下。因为并头是，
如果需要，可能得使用增强的文本行锚点匹配模式（112）。
但是，这个容案仍然不够完美一我们会在下一章讲解效率问题时再次看到它（270）。
匹配IP地址
Matclting uni IP Auldress
来看个复杂点的例子，匹配一个IP（IntermetProtocol，因特网协议）地址：用点号分开的四
个数，例如1.2.3.4。通常情况下，每个数都有三位，例如001.002.003.004。你可能会
中*[6-0]*[6-0][6-0][6-0].
显然不够精致，它甚至会匹配‘andthen…..？"。仔细看看就会发现，这个表达式甚至
不需要匹配任何数字一一一它只需要三个点号（当然也可能包括其间的数字）。
为解决这个问题，我们首先把星号改成加号，因为我们知道，每一段必须有至少一位数字。
为确保整个字符事的内容就是一个IP地址，我们可以在首尾加上...S，于是我们得到：
$+[6-0]·\+[6-0]+[6-0].\+[6-0]
（1）++++6-
但是，这个表达式仍然会捕获一些并非IP地址的数据，例如“1234.5678.9101112.131415
注1：这倒不一定，主要看读者的喜好。我发现，在复杂的正则表达式中，\d比[0-9]1更容易
理解，但是，在某些系统中，这二者并不等同。在支持Unicode的系统中，\di或许能匹配
非ASCII的数字。
---
## Page 214
188
第5章：正则表达式实用技巧
（IP地址的每个字段都在0-255以内）。那么，你可以强行规定每个字段必须包含三位数字，
就是^\d\d\d\.\d\d\d\.\d\d\d\.\d\d\d$)，但这样未免太不灵活（too specific）了。即
使某个字段只有一位或者两位数字（例如1.234.5.67），也应该匹配。如果流派支持区间
量词（min，max），就可以这么写\d（1，3}\.\d{1，3)\.\a（1，3）\.\a{1，3）$。如果不支持，
则可以用d\d?\d?)或者“d（\d\d？)？。这两种方式略有不同，但都能匹配一到三个数字。
现在，正则表达式中的匹配精度可能已经满足需求了。如果要更精确，就必须考虑到，
d（1，3）能够匹配999，而它超过了255，所以它不是一个合法的IP地址。
我们有好几种办法来匹配0和255之间的数字。最笨的办法就是0111213125312541255]。
不过这又不能处理以0开头的数字，所以必须写成01001000111011001)，这样一来，正
则表达式就长得过分了。对于DFA引擎来说，问题还只是它太长太繁杂一但匹配的速度
与其他等价正则表达式是一样的。但对于NFA引擎，太多的多选分支简直就是效率杀手。
实际的解决办法是，关注字段中什么位置可以出现哪些数字。如果一个字段只包含一个或
者两个数字，就无需担心这个字段的值是否合法，所以ad\d就能应付。也不比担心那
些以0或者1开头的三位数，因为000-199都是合法的IP地址。所以我们加上（01）\d\d，
得到dl\d\dl[01]\d\d。你可能觉得这有点像第1章里匹配时间的例子（28），和前一
章中匹配日期的例子（177）
继续看这个正则表达式，以2开头的三位数字，如果小于255就是合法的，所以第二位数
字小于5就代表整个数也是合法的。如果第二位数字是5，第三位数字就必须小于6。这可
以表示为2[0-4]\d125[0-5]]。
现在这个正则表达式有点看不懂了，但分析之后还是能够理解其中包含的思路。结果就是
dl\d\dl[01]\d\dl2[0-4]\dl25[0-5]。其实我们可以合并前面三个多选分支，得到
[01]?\d\d?12[0-4]\d125[0-5]。在NFA中，这样做的效率更高，因为任何多选分支匹
配失败都会导致回溯。请注意，第一个多选分支中用的是d\d?，而不是\d?\d，这样，
如果根本不存在数字，NFA会更快地报告匹配失败。我把这个问题的分析留给读者-一通
过一个简单的验证就能发现二者的区别。我们还可以做些修改进一步提高这个表达式的效
率，不过这要留待下一章讨论了。
---
## Page 215
若干简单的例子
189
现在这个表达式能够匹配0到255之间的数，我们用括号把它包起来，用来取代之前表达
式中的d1，3），就得到：
([01]？\d\d12[0-4]d125[0-5]).([01]\\d？12[0-4]d125[0-5])。
（[01]?\d\d?12[0-4]\d125[0~5])\ . ([01] ?\d\d?12[0-4]\d125[0-5])S
这可真叫复杂！需要这么麻烦吗？这得根据具体需求来决定。这个表达式只会匹配合法的
IP地址，但是它也会匹配一些语意不正确的IP地址，例如0.0.0.0（所有字段都为零的IP
地址是非法的）。使用环视功能（133）可以在后添加'（?！0+\.0+\.0+\.0+$），但是
某些时候，处理各种极端情形会降低成本/收益的比例。某些情况下，更合适的做法就是不
依赖正则表达式完成全部工作。例如，你可以只使用\d（1，3)\.\d（1，3)\.\d（1，3）\，
Ad（1，3}S，用括号把每个字段括起来，把数字变成程序中的$1、$2、$3、$4，这样就可以
用其他程序来验证了。
确定应用场合（context）
这个正则表达式必须借助锚点和'$才能正常工作，认识到这一点很重要。否则，它就可
能匹配ip=72123.3.21.993，如果使用传统型NFA，则可能匹配ip=123.3.21.223。
在第二个例子中，这个表达式甚至连最后的223都无法完整匹配。但是，问题并不在于表
达式本身，因为没有东西（例如分隔符，或者末尾的锚点）强迫它匹配223。最后那个分组
的第一个多选分支[01]？\d\d?，匹配了前面两位数字，如果末尾没有$1，匹配到此就结
束了。在前一章日期匹配的例子中，我们可以安排多选分支的次序来达到期望的目的。现
在我们也把能把匹配三位数字的多选分支放在最前面，这样在匹配两位数的多选分支获得
它们总是返回最长的匹配文本）。
无论是否重新排序，第一个错误仍然不可避免。“响哈！”，你可能会想，“我可以用单词分
界符锚点来解决这个问题。”不幸的是，这也不能奏效，因为这样的正则表达式仍然能够匹
配1.2.3.4.5.6。为了避免匹配这样内嵌的文本，我们必须确保匹配文本两侧至少没有数
字或者点号。如果使用环视，可以在原来表达式的首尾添加（？<！W.]）（？！W.]）来