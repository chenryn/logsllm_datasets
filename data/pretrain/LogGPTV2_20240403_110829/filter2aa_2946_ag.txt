    // 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的
101
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
102
}
103
104
int APIENTRY WinMain(HINSTANCE hInstance,
105
                     HINSTANCE hPrevInstance,
106
                     LPSTR     lpCmdLine,
107
                     int       nCmdShow)
108
{
109
滴水逆向课程笔记  –  Win32
子窗口控件  –  84
    char szOutBuff[0x80];
110
111
    // 1. 定义创建的窗口(创建注册窗口类)
112
    TCHAR className[] = TEXT("My First Window");
113
    WNDCLASS wndClass = {0};
114
    // 设置窗口背景色
115
    wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;
116
    // 设置类名字
117
    wndClass.lpszClassName = className;
118
    // 设置模块地址
119
    gHinstance = hInstance;
120
    wndClass.hInstance = hInstance;
121
    // 处理消息的窗口函数
122
    wndClass.lpfnWndProc = WindowProc; // 不是调用函数，只是告诉操作系统，当前窗口对应的窗口回调函数是什么
123
    // 注册窗口类
124
    RegisterClass(&wndClass);
125
126
    // 2. 创建并显示窗口
127
    // 创建窗口
128
    /*
129
    CreateWindow 语法格式：
130
    HWND CreateWindow(
131
        LPCTSTR lpClassName,  // registered class name 类名字
132
        LPCTSTR lpWindowName, // window name 窗口名字
133
        DWORD dwStyle,        // window style 窗口外观的样式
134
        int x,                // horizontal position of window 相对于父窗口x坐标
135
        int y,                // vertical position of window 相对于父窗口y坐标
136
        int nWidth,           // window width 窗口宽度：像素
137
        int nHeight,          // window height 窗口长度：像素
138
        HWND hWndParent,      // handle to parent or owner window 父窗口句柄
139
        HMENU hMenu,          // menu handle or child identifier 菜单句柄
140
        HINSTANCE hInstance,  // handle to application instance 模块
141
        LPVOID lpParam        // window-creation data  附加数据
142
    );
143
    */
144
    HWND hWnd = CreateWindow(className, TEXT("窗口"), WS_OVERLAPPEDWINDOW, 10, 10, 600, 300, NULL, 
NULL, hInstance, NULL);
145
146
    if (hWnd == NULL) {
147
        // 如果为NULL则窗口创建失败，输出错误信息
148
        sprintf(szOutBuff, "Error: %d", GetLastError());
149
        OutputDebugString(szOutBuff);
150
        return 0;
151
    }
152
153
    // 显示窗口
154
    /*
155
    ShowWindow 语法格式：
156
    BOOL ShowWindow(
157
        HWND hWnd,     // handle to window 窗口句柄
158
        int nCmdShow   // show state 显示的形式
159
    );
160
    */
161
    ShowWindow(hWnd, SW_SHOW);
162
163
    // 3. 接收消息并处理
164
滴水逆向课程笔记  –  Win32
子窗口控件  –  85
运行结果如下：
    /*
165
    GetMessage 语法格式：
166
    BOOL GetMessage(
167
        LPMSG lpMsg,         // message information OUT类型参数，这是一个指针
168
        // 后三个参数都是过滤条件
169
        HWND hWnd,           // handle to window 窗口句柄，如果为NULL则表示该线程中的所有消息都要
170
        UINT wMsgFilterMin,  // first message 第一条信息
171
        UINT wMsgFilterMax   // last message 最后一条信息
172
    );
173
    */
174
    MSG msg;
175
    BOOL bRet;
176
    while( (bRet = GetMessage( &msg, NULL, 0, 0 )) != 0)
177
    { 
178
        if (bRet == -1)
179
        {
180
            // handle the error and possibly exit
181
            sprintf(szOutBuff, "Error: %d", GetLastError());
182
            OutputDebugString(szOutBuff);
183
            return 0;
184
        }
185
        else
186
        {
187
            // 转换消息
188
            TranslateMessage(&msg);
189
            // 分发消息：就是给系统调用窗口处理函数
190
            DispatchMessage(&msg);
191
        }
192
    }
193
194
    return 0;
195
}
196
滴水逆向课程笔记  –  Win32
子窗口控件  –  86
Windows预定义的窗口类可以在MSDN Library的CreateWindow函数下面找到：
滴水逆向课程笔记  –  Win32
虚拟内存与物理内存  –  87
19 虚拟内存与物理内存
19.1 虚拟内存与物理内存的关系
每个进程都有自己的4GB内存，但是这个4GB内存并不是真实存在的，而是一块虚拟内存。
在进程A的0x12345678内存地址中存入一个值，在进程B的0x12345678内存地址中也存入一个值，两者并不会冲
突，而是各自存放各自的。
但是存放的这个值是存放在物理内存上的，所以这里的虚拟内存和物理内存就有一个对应关系，当你真正使用
的时候才会给分配物理内存，不使用的时候则就只有虚拟内存（空头支票）。
每一个物理内存的大小是4KB，按照4KB大小来分页（Page），所以如上图所示，就有物理页这个概念。
19.2 虚拟内存地址划分
每个进程都有4GB的虚拟内存，虚拟内存的地址是如何划分的？首先，我们需要知道一个虚拟内存分为高2G、
低2G。
滴水逆向课程笔记  –  Win32
虚拟内存与物理内存  –  88
如下图所示，用户空间是低2G，内核空间是高2G，对我们来说只能使用低2G的用户空间，高2G内核空间是所
有进程共用的。
但是需要注意的是低2G的用户空间使用还有前64KB的空指针赋值区和后64KB的用户禁入区是我们目前不能使
用的。
术语：线性地址就是虚拟内存的地址
特别说明：线性地址有4G ，但未必都能访问，所以需要记录哪些地方分配了。
19.3 物理内存
19.3.1 可使用的物理内存
为了管理方便，物理内存以4KB大小来分页，那么在系统里面这个物理页的数量是多少呢？我使用的虚拟机是
可以设置内存大小的（从物理上可以理解为这就是一个内存条）：
滴水逆向课程笔记  –  Win32
虚拟内存与物理内存  –  89
比如我现在的是是2GB（2048MB），我们可以在任务管理器清晰的看见物理内存的总数是接近2048*1024的：
那么这一块物理内存能有多少物理页呢？我们可以将总数/4：
滴水逆向课程笔记  –  Win32
虚拟内存与物理内存  –  90
也就是有524138个物理页（十进制），转为十六进制就是0x7FF6A
那么物理页面只有这些不够用该怎么办？这时候操作系统会分配硬盘空间来做虚拟内存。我们可以通过系统属
性来查看、更改当前分配的虚拟内存大小：
滴水逆向课程笔记  –  Win32
虚拟内存与物理内存  –  91
可以看见当前初始大小是2046MB，那么这个是存放在哪的呢？我们可以在C盘下查看（需要显示系统隐藏文
件）pagefile.sys这个文件，它刚好是2046MB这个大小，这个文件就是用来做虚拟内存的：
滴水逆向课程笔记  –  Win32
虚拟内存与物理内存  –  92
19.3.2 可识别的物理内存
32位操作系统最多可以识别物理内存为64G，但是操作系统会进行限制，例如XP这个系统只能识别4G的物理内
存（Windows Server 2003服务器版本可以识别4G以上）。
但是我们可以通过HOOK系统函数来突破XP操作系统的4GB限制。
19.4 物理页的使用
我们知道了进程在使用虚拟内存时，就会分配一块物理内存（物理页），但是有那么多程序，很快就会占满物
理页，操作系统不会这样设计，而是会去看你的程序是否需要频繁的使用物理页，如果不是很频繁就会将你存
储在物理页的内容放在pagefile.sys文件中，然后将这个物理页分配给其他需要的进程；
如果你的程序再次访问物理页的话，就会重新给你分配物理页，然后把数据从pagefile.sys文件中拿出来放到新
的物理页中，这都是操作系统在操作的，写程序是感受不到这样的细节的。
滴水逆向课程笔记  –  Win32
私有内存的申请释放  –  93
1.
2.
20 私有内存的申请释放
物理内存分为两类，一个是私有内存（Private）一个是共享内存（Mapped），私有内存的意思是这块物理内
存（物理页）只有你使用，而共享内存则是多个进程一起用。
20.1 申请内存的两种方式
私有内存通过VirtualAlloc/VirtualAllocEx函数申请，这两个函数在底层实现是没有区别的，但是后者是
可以在其他进程中申请内存。
共享内存通过CreateFileMapping函数映射
20.2 内存申请与释放
申请内存的函数是VirtualAlloc，其语法格式如下：
第三、第四参数可以根据MSDN Library查看系统定义的：
LPVOID VirtualAlloc(
1
  LPVOID lpAddress,        // region to reserve or commit 要分配的内存区域的地址，没有特殊需求通常不指定
2
  SIZE_T dwSize,           // size of region 分配的大小，一个物理页大小是0x1000（4KB），看你需要申请多少个
物理页就乘以多少
3
  DWORD flAllocationType,  // type of allocation 分配的类型，常用的是MEM_COMMIT（占用线性地址，也需要物理
内存）和MEM_RESERVE（占用线性地址，但不需要物理内存）
4
  DWORD flProtect          // type of access protection 该内存的初始保护属性
5
);
6
滴水逆向课程笔记  –  Win32
私有内存的申请释放  –  94
如下代码则表示申请2个物理页，占用线性地址并分配物理内存，该内存可读写：
那么内存申请好了我们不想要了，这时候就需要释放，释放函数为VirtualFree，其语法格式如下：
LPVOID pm = VirtualAlloc(NULL, 0x1000*2, MEM_COMMIT, PAGE_READWRITE);
1
滴水逆向课程笔记  –  Win32
私有内存的申请释放  –  95
所以我们想要释放物理内存，释放线性地址就写如下代码：
20.3 堆与栈
之前我们学习过的malloc或者new申请内存，它们是申请的什么内存呢？其实通过它们申请的内存是假申请，
因为它们是从已经申请好的内存中申请给自己用的，通过它们申请的内存称为堆内存，局部变量称为栈内存。
无论堆内存还是栈内存，都是操作系统启动时操作系统使用VirtualAlloc函数替我们申请好的。
所以堆、栈的本质就是私有内存，也就是通过VirtualAlloc函数申请的。
BOOL VirtualFree(
1
  LPVOID lpAddress,   // address of region 内存区域的地址
2
  SIZE_T dwSize,      // size of region 内存大小
3
  DWORD dwFreeType    // operation type 如何释放，释放的类型，一共有两个类型：MEM_DECOMMIT（释放物理内存，
但线性地址保留）、MEM_RELEASE（释放物理内存，释放线性地址，使用这个设置的时候内存大小就必须为0）
4
);
5
VirtualFree(pm, 0, MEM_RELEASE);
1
int main(int argc, char* argv[])
1
{
2
    int x = 0x12345678; // 栈
3
4
    int* y = (int*)malloc(sizeof(int)*128); // 堆
5
6
    return 0;
7
}
8
滴水逆向课程笔记  –  Win32
共享内存的申请释放  –  96
21 共享内存的申请释放
21.1 共享内存
共享内存通过CreateFileMapping函数映射，该函数语法格式如下：
该函数的作用就是为我们准备好物理内存（物理页），但是创建好了并不代表就可以使用了，我们还需要通过
MapViewOffile函数将物理页与线性地址进行映射，MapViewOffile函数语法格式如下：
示例代码如下：
HANDLE CreateFileMapping( // 内核对象，这个对象可以为我们准备物理内存，还可以将文件映射到物理页
1
  HANDLE hFile,                       // handle to file 文件句柄，如果不想将文件映射到物理页，则不指定该参
数
2
  LPSECURITY_ATTRIBUTES lpAttributes, // security 安全属性，包含安全描述符
3
  DWORD flProtect,                    // protection 保护模式，物理页的属性
4
  DWORD dwMaximumSizeHigh,            // high-order DWORD of size 高32位，在32位计算机里通常设置为空
5
  DWORD dwMaximumSizeLow,             // low-order DWORD of size 低32位，指定物理内存的大小
6
  LPCTSTR lpName                      // object name 对象名字，公用时写，自己使用则可以不指定
7
);
8
LPVOID MapViewOfFile(
1
  HANDLE hFileMappingObject,   // handle to file-mapping object file-mapping对象的句柄
2
  DWORD dwDesiredAccess,       // access mode 访问模式(虚拟内存的限制必须比物理地址更加严格)
3
  DWORD dwFileOffsetHigh,      // high-order DWORD of offset 高32位，在32位计算机里通常设置为空
4
  DWORD dwFileOffsetLow,       // low-order DWORD of offset 低32位，指定从哪里开始映射
5
  SIZE_T dwNumberOfBytesToMap  // number of bytes to map 共享内存的大小，一般与物理页大小一致
6
);
7
滴水逆向课程笔记  –  Win32
共享内存的申请释放  –  97
#include 
1
2
#define MapFileName "共享内存"
3
#define BUF_SIZE 0x1000
4
HANDLE g_hMapFile;
5
LPTSTR g_lpBuff;
6
7
int main(int argc, char* argv[])
8
{
9
    // 内核对象：准备好物理页，无效句柄值-1、物理页可读写、申请一个物理页
10
    g_hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, BUF_SIZE, 
MapFileName);
11
    // 将物理页与线性地址进行映射
12
    g_lpBuff = (LPTSTR)MapViewOfFile(g_hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, BUF_SIZE);
13
14
    // 向物理内存中存储
15
    *(PDWORD)g_lpBuff = 0x12345678;
16
17
    // 关闭映射，关闭映射则表示释放了线形地址，但是物理页还存在
18
    UnmapViewOfFile(g_lpBuff);
19
    // 关闭句柄，这样才能释放物理页，但需要等待物理页使用完毕才会真正的释放，这里只是告诉系统我们当前进程不使用该句
柄（物理页）罢了
20
    CloseHandle(g_hMapFile);
21
    return 0;
22
}