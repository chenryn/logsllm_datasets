timestamp
without time text - implicit in expressions input/output function
zone
record text - implicit in expressions input/output function
boolean text pg_catalog.text implicit in expressions function
bytea text - implicit in expressions input/output function
For information on the column output, see the pg_cast system catalog in the
PostgreSQL core documentation available at:
https://www.postgresql.org/docs/11/static/catalog-pg-cast.html
So for example, data type UUID is not in this list and therefore does not have the implicit
coercion to text. As a result, certain concatenation attempts with a NULL UUID column
results in a truncated text result.
The following table is created for this example with a single row with all NULL column
values.
CREATE TABLE null_concat_types (
boolean_type BOOLEAN,
uuid_type UUID,
char_type CHARACTER
);
INSERT INTO null_concat_types VALUES (NULL, NULL, NULL);
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 240
Database Compatibility for Oracle® Developers
Reference Guide
Columns boolean_type and char_type have the implicit coercion to text while
column uuid_type does not.
Thus, string concatenation with the concatenation operator „||„ against columns
boolean_type or char_type results in the following:
SELECT 'x=' || boolean_type || 'y' FROM null_concat_types;
?column?
----------
x=y
(1 row)
SELECT 'x=' || char_type || 'y' FROM null_concat_types;
?column?
----------
x=y
(1 row)
But concatenation with column uuid_type results in the loss of the x= string:
SELECT 'x=' || uuid_type || 'y' FROM null_concat_types;
?column?
----------
y
(1 row)
However, using explicit casting with ::text prevents the loss of the x= string:
SELECT 'x=' || uuid_type::text || 'y' FROM null_concat_types;
?column?
----------
x=y
(1 row)
Using the CONCAT function also preserves the x= string:
SELECT CONCAT('x=',uuid_type) || 'y' FROM null_concat_types;
?column?
----------
x=y
(1 row)
Thus, depending upon the data type of a NULL column, explicit casting or the CONCAT
function should be used to avoid loss of some text string.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 241
Database Compatibility for Oracle® Developers
Reference Guide
2.4.5 Pattern Matching String Functions
Advanced Server offers support for the REGEXP_COUNT, REGEXP_INSTR and
REGEXP_SUBSTR functions. These functions search a string for a pattern specified by a
regular expression, and return information about occurrences of the pattern within the
string. The pattern should be a POSIX-style regular expression; for more information
about forming a POSIX-style regular expression, please refer to the core documentation
at:
https://www.postgresql.org/docs/11/static/functions-matching.html
2.4.5.1 REGEXP_COUNT
REGEXP_COUNT searches a string for a regular expression, and returns a count of the
times that the regular expression occurs. The signature is:
INTEGER REGEXP_COUNT
(
srcstr TEXT,
pattern TEXT,
position DEFAULT 1
modifier DEFAULT NULL
)
Parameters
srcstr
srcstr specifies the string to search.
pattern
pattern specifies the regular expression for which REGEXP_COUNT will search.
position
position is an integer value that indicates the position in the source string at
which REGEXP_COUNT will begin searching. The default value is 1.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 242
Database Compatibility for Oracle® Developers
Reference Guide
modifier
modifier specifies values that control the pattern matching behavior. The
default value is NULL. For a complete list of the modifiers supported by
Advanced Server, see the PostgreSQL core documentation available at:
https://www.postgresql.org/docs/11/static/functions-matching.html
Example
In the following simple example, REGEXP_COUNT returns a count of the number of times
the letter i is used in the character string 'reinitializing':
edb=# SELECT REGEXP_COUNT('reinitializing', 'i', 1) FROM DUAL;
regexp_count
--------------
5
(1 row)
In the first example, the command instructs REGEXP_COUNT begins counting in the first
position; if we modify the command to start the count on the 6th position:
edb=# SELECT REGEXP_COUNT('reinitializing', 'i', 6) FROM DUAL;
regexp_count
--------------
3
(1 row)
REGEXP_COUNT returns 3; the count now excludes any occurrences of the letter i that
occur before the 6th position.
2.4.5.2 REGEXP_INSTR
REGEXP_INSTR searches a string for a POSIX-style regular expression. This function
returns the position within the string where the match was located. The signature is:
INTEGER REGEXP_INSTR
(
srcstr TEXT,
pattern TEXT,
position INT DEFAULT 1,
occurrence INT DEFAULT 1,
returnparam INT DEFAULT 0,
modifier TEXT DEFAULT NULL,
subexpression INT DEFAULT 0,
)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 243
Database Compatibility for Oracle® Developers
Reference Guide
Parameters:
srcstr
srcstr specifies the string to search.
pattern
pattern specifies the regular expression for which REGEXP_INSTR will search.
position
position specifies an integer value that indicates the start position in a source
string. The default value is 1.
occurrence
occurrence specifies which match is returned if more than one occurrence of
the pattern occurs in the string that is searched. The default value is 1.
returnparam
returnparam is an integer value that specifies the location within the string that
REGEXP_INSTR should return. The default value is 0. Specify:
0 to return the location within the string of the first character that matches
pattern.
A value greater than 0 to return the position of the first character
following the end of the pattern.
modifier
modifier specifies values that control the pattern matching behavior. The
default value is NULL. For a complete list of the modifiers supported by
Advanced Server, see the PostgreSQL core documentation available at:
https://www.postgresql.org/docs/11/static/functions-matching.html
subexpression
subexpression is an integer value that identifies the portion of the pattern
that will be returned by REGEXP_INSTR. The default value of subexpression
is 0.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 244
Database Compatibility for Oracle® Developers
Reference Guide
If you specify a value for subexpression, you must include one (or more) set
of parentheses in the pattern that isolate a portion of the value being searched
for. The value specified by subexpression indicates which set of parentheses
should be returned; for example, if subexpression is 2, REGEXP_INSTR will
return the position of the second set of parentheses.
Example
In the following simple example, REGEXP_INSTR searches a string that contains the a
phone number for the first occurrence of a pattern that contains three consecutive digits:
edb=# SELECT REGEXP_INSTR('800-555-1212', '[0-9][0-9][0-9]', 1, 1) FROM DUAL;
regexp_instr
--------------
1
(1 row)
The command instructs REGEXP_INSTR to return the position of the first occurrence. If
we modify the command to return the start of the second occurrence of three consecutive
digits:
edb=# SELECT REGEXP_INSTR('800-555-1212', '[0-9][0-9][0-9]', 1, 2) FROM DUAL;
regexp_instr
--------------
5
(1 row)
REGEXP_INSTR returns 5; the second occurrence of three consecutive digits begins in the
5th position.
2.4.5.3 REGEXP_SUBSTR
The REGEXP_SUBSTR function searches a string for a pattern specified by a POSIX
compliant regular expression. REGEXP_SUBSTR returns the string that matches the
pattern specified in the call to the function. The signature of the function is:
TEXT REGEXP_SUBSTR
(
srcstr TEXT,
pattern TEXT,
position INT DEFAULT 1,
occurrence INT DEFAULT 1,
modifier TEXT DEFAULT NULL,
subexpression INT DEFAULT 0
)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 245
Database Compatibility for Oracle® Developers
Reference Guide
Parameters:
srcstr
srcstr specifies the string to search.
pattern
pattern specifies the regular expression for which REGEXP_SUBSTR will search.
position
position specifies an integer value that indicates the start position in a source
string. The default value is 1.
occurrence
occurrence specifies which match is returned if more than one occurrence of
the pattern occurs in the string that is searched. The default value is 1.
modifier
modifier specifies values that control the pattern matching behavior. The
default value is NULL. For a complete list of the modifiers supported by
Advanced Server, see the PostgreSQL core documentation available at:
https://www.postgresql.org/docs/11/static/functions-matching.html
subexpression
subexpression is an integer value that identifies the portion of the pattern
that will be returned by REGEXP_SUBSTR. The default value of subexpression
is 0.
If you specify a value for subexpression, you must include one (or more) set
of parentheses in the pattern that isolate a portion of the value being searched
for. The value specified by subexpression indicates which set of parentheses
should be returned; for example, if subexpression is 2, REGEXP_SUBSTR will
return the value contained within the second set of parentheses.
Example
In the following simple example, REGEXP_SUBSTR searches a string that contains a
phone number for the first set of three consecutive digits:
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 246
Database Compatibility for Oracle® Developers
Reference Guide
edb=# SELECT REGEXP_SUBSTR('800-555-1212', '[0-9][0-9][0-9]', 1, 1) FROM
DUAL;
regexp_substr
---------------
800
(1 row)
It locates the first occurrence of three digits and returns the string (800); if we modify the
command to check for the second occurrence of three consecutive digits:
edb=# SELECT REGEXP_SUBSTR('800-555-1212', '[0-9][0-9][0-9]', 1, 2) FROM
DUAL;
regexp_substr
---------------
555
(1 row)
REGEXP_SUBSTR returns 555, the contents of the second substring.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 247
Database Compatibility for Oracle® Developers
Reference Guide
2.4.6 Pattern Matching Using the LIKE Operator
Advanced Server provides pattern matching using the traditional SQL LIKE operator.
The syntax for the LIKE operator is as follows.
string LIKE pattern [ ESCAPE escape-character ]
string NOT LIKE pattern [ ESCAPE escape-character ]
Every pattern defines a set of strings. The LIKE expression returns TRUE if string is
contained in the set of strings represented by pattern. As expected, the NOT LIKE
expression returns FALSE if LIKE returns TRUE, and vice versa. An equivalent expression
is NOT (string LIKE pattern).
If pattern does not contain percent signs or underscore, then the pattern only represents
the string itself; in that case LIKE acts like the equals operator. An underscore (_) in
pattern stands for (matches) any single character; a percent sign (%) matches any string
of zero or more characters.
Some examples:
'abc' LIKE 'abc' true
'abc' LIKE 'a%' true
'abc' LIKE '_b_' true
'abc' LIKE 'c' false
LIKE pattern matches always cover the entire string. To match a pattern anywhere within
a string, the pattern must therefore start and end with a percent sign.
To match a literal underscore or percent sign without matching other characters, the
respective character in pattern must be preceded by the escape character. The default
escape character is the backslash but a different one may be selected by using the
ESCAPE clause. To match the escape character itself, write two escape characters.
Note that the backslash already has a special meaning in string literals, so to write a
pattern constant that contains a backslash you must write two backslashes in an SQL
statement. Thus, writing a pattern that actually matches a literal backslash means writing
four backslashes in the statement. You can avoid this by selecting a different escape
character with ESCAPE; then a backslash is not special to LIKE anymore. (But it is still
special to the string literal parser, so you still need two of them.)
It‟s also possible to select no escape character by writing ESCAPE ''. This effectively
disables the escape mechanism, which makes it impossible to turn off the special
meaning of underscore and percent signs in the pattern.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 248
Database Compatibility for Oracle® Developers
Reference Guide
2.4.7 Data Type Formatting Functions
The Advanced Server formatting functions described in the following table provide a
powerful set of tools for converting various data types (date/time, integer, floating point,
numeric) to formatted strings and for converting from formatted strings to specific data
types. These functions all follow a common calling convention: the first argument is the
value to be formatted and the second argument is a string template that defines the output
or input format.
Table 2-20 Formatting Functions
Return
Function Description Example Result
Type
Convert a date/time
to a string with
TO_CHAR(DATE [, output, format. If TO_CHAR(SYSDATE, 'MM/DD/YYYY 07/25/2007
VARCHAR2
format ]) omitted default HH12:MI:SS AM') 09:43:02 AM
format is DD-MON-
YY.
Convert a timestamp
to a string with
TO_CHAR(TIMESTAMP [, output, format. If TO_CHAR(CURRENT_TIMESTAMP, 08/13/2015
VARCHAR2
format ]) omitted default 'MM/DD/YYYY HH12:MI:SS AM') 08:55:22 PM
format is DD-MON-
YY.
Convert an integer to
TO_CHAR(INTEGER [,
VARCHAR2 a string with output, TO_CHAR(2412, '999,999S') 2,412+
format ])
format
Convert a decimal
TO_CHAR(NUMBER [, TO_CHAR(10125.35,
VARCHAR2 number to a string 10,125.35
format ]) '999,999.99')
with output, format
Convert a floating-
TO_CHAR(DOUBLE point number to a TO_CHAR(CAST(123.5282 AS
VARCHAR2 123.53
PRECISION, format) string with output, REAL), '999.99')
format
Convert a date TO_DATE('2007-07-04
TO_DATE(string [, 04-JUL-07
DATE formatted string to a 13:39:10', 'YYYY-MM-DD
format ]) 13:39:10
DATE data type HH24:MI:SS')
Convert a number
TO_NUMBER(string [, TO_NUMBER('2,412-',
NUMBER formatted string to a -2412
format ]) '999,999S')
NUMBER data type
Convert a timestamp TO_TIMESTAMP('05 Dec 2000
TO_TIMESTAMP(string, 05-DEC-00
TIMESTAMP formatted string to a 08:30:25 pm', 'DD Mon YYYY
format) 20:30:25
TIMESTAMP data type hh12:mi:ss pm')
In an output template string (for TO_CHAR), there are certain patterns that are recognized
and replaced with appropriately-formatted data from the value to be formatted. Any text
that is not a template pattern is simply copied verbatim. Similarly, in an input template
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 249
Database Compatibility for Oracle® Developers
Reference Guide
string (for anything but TO_CHAR), template patterns identify the parts of the input data
string to be looked at and the values to be found there.
The following table shows the template patterns available for formatting date values
using the TO_CHAR and TO_DATE functions.
Table 2-21 Template Date/Time Format Patterns
Pattern Description
HH Hour of day (01-12)
HH12 Hour of day (01-12)
HH24 Hour of day (00-23)
MI Minute (00-59)
SS Second (00-59)
SSSSS Seconds past midnight (0-86399)
Fractional seconds where n is an optional integer from 1 to 9 for the number of digits to
FFn
return. If omitted, the default is 6.
AM or A.M. or PM
Meridian indicator (uppercase)
or P.M.
am or a.m. or pm
Meridian indicator (lowercase)
or p.m.
Y,YYY Year (4 and more digits) with comma
YEAR Year (spelled out)
SYEAR Year (spelled out) (BC dates prefixed by a minus sign)
YYYY Year (4 and more digits)
SYYYY Year (4 and more digits) (BC dates prefixed by a minus sign)
YYY Last 3 digits of year
YY Last 2 digits of year
Y Last digit of year
IYYY ISO year (4 and more digits)
IYY Last 3 digits of ISO year
IY Last 2 digits of ISO year
I Last 1 digit of ISO year
BC or B.C. or AD
Era indicator (uppercase)
or A.D.
bc or b.c. or ad
Era indicator (lowercase)
or a.d.
MONTH Full uppercase month name
Month Full mixed-case month name
month Full lowercase month name
MON Abbreviated uppercase month name (3 chars in English, localized lengths vary)
Mon Abbreviated mixed-case month name (3 chars in English, localized lengths vary)
mon Abbreviated lowercase month name (3 chars in English, localized lengths vary)
MM Month number (01-12)
DAY Full uppercase day name