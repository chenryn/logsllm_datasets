Example: iChat Spy 322
Conclusion 326
References 326
Chapter 12 Rootkits 327
Kernel Extensions 327
Hello Kernel 328
System Calls 330
Hiding Files 332
Hiding the Rootkit 342
Maintaining Access across Reboots 346
Controlling the Rootkit 349
Creating the RPC Server 350
Injecting Kernel RPC Servers 350
Calling the Kernel RPC Server 352
Remote Access 352
Hardware-Virtualization Rootkits 354
Hyperjacking 355
Rootkit Hypervisor 356
Conclusion 358
References 358
Index 367
9955336633ffttoocc..iinndddd xx 11//2255//0099 44::3388::3333 PPMM
Foreword
For better or worse, there are moments in our lives that we can visualize with
startling clarity. Sometimes momentous and other times trivial, we’re able to
completely recall these snippets of our past even if we can’t remember the day
or context. In my life, there’s one moment I’d like to call trivial, but the truth is,
it was likely more central in establishing my eventual technology career than
I care to admit at social gatherings.
I think it was the early 1980s, but that’s mostly irrelevant. My best friend’s parents
recently purchased an Apple II (plus, I think), making my friend the fi rst person I
knew with a computer in his house. One day we noticed a seam on the top of the
plastic case; we slid the bulking green screen monitor to the side and removed
the panel on the top. For the fi rst time, we peered into the inner guts of an actual
working computer. This was defi nitely before the release of WarGames, likely
before I’d ever heard of hacking, and long before “hacker” became synonymous
with “criminal” in the mass media. We lifted that plastic lid and stared at the cop-
per and black components on the fi eld of green circuit boards before us. We were
afraid to touch anything, but for the fi rst time, the walls between hardware and
software shattered for our young minds, opening up a new world of possibilities.
This was something we could touch, manipulate, and, yes, break.
My young computer career began with those early Apples (and Commodores).
We spent countless hours exploring their inner workings; from BASIC to binary
math, and more than our fair share of games (for the record, the Apple joystick
was terrible). Early on I realized I enjoyed breaking things just as much, if not
more than, creating them. By feeling around the seams of software and systems,
learning where they bent, cracked, and failed, I could understand them in ways
just not possible by coloring between the lines.
The very fi rst Mac I could buy was an early Mac Mini I purchased mostly for
research purposes. I quickly realized that Mac OS X was a hacker’s delight of an
operating system. Beautiful and clean compared to my many years on Windows,
xi
9955336633ffllaasstt..iinndddd xxii 11//2255//0099 44::3388::5544 PPMM
xii Foreword
with a Unix terminal a click away. Here was a box I could run Microsoft Offi ce
on that came with Apache by default and still held full man pages. As I delved
into Applescript, plists, DMGs, and the other minutia of OS X, I was amazed
by the capabilities of the operating system, and the breadth and depth of tools
available.
But as I continued to switch completely over to Apple, especially after the
release of Intel Macs, my fi ngers started creeping around for those cracks at the
edges again. I wasn’t really worried about viruses, but, as a security professional,
I started wondering if this was by luck or design. I read the Apple documenta-
tion and realized fairly early that there wasn’t a lot of good information on how
OS X worked from a security standpoint, other than some confi guration guides
and marketing material.
Mac security attitudes have changed a fair bit since I purchased that fi rst
Mac Mini. As Macs increase in popularity, they face more scrutiny. Windows
switchers come with questions and habits, more security researchers use Macs
in their day-to-day work, the press is always looking to knock Apple down a
notch, and the bad guys won’t fail to pounce on any profi table opportunity. But
despite this growing attention, there are few resources for those who want to
educate themselves and better understand the inner workings of the operating
system on which they rely.
That’s why I was so excited when Dino fi rst mentioned he and Charlie were
working on this book. Ripping into the inner guts of Mac OS X and fi nding
those edges to tear apart are the only ways to advance the security of the plat-
form. Regular programming books and system overviews just don’t look at any
operating system from the right perspective; we need to know how something
breaks in order to make it stronger. And, as any child (or hacker) will tell you,
breaking something is the most exhilarating way to learn.
If you are a security professional, this book is one of the best ways to under-
stand the strengths and weaknesses of Mac OS X. If you are a programmer, this
book will not only help you write more secure code, but it will also help you in
your general coding practices. If you are just a Mac enthusiast, you’ll learn how
hackers look at our operating system of choice and gain a better understanding
of its inner workings. Hopefully Apple developers will use this to help harden
the operating system; making the book obsolete with every version. Yes, maybe
a few bad guys will use it to write a few exploits, but the benefi ts of having this
knowledge far outweigh the risks.
For us hackers, even those of us of limited skills, this book provides us with a
roadmap for exploring those edges, fi nding those cracks, and discovering new
possibilities. For me, it’s the literary equivalent of sliding that beige plastic cover
off my childhood friend’s fi rst Apple and gazing at the inner workings.
—Rich Mogull
Security Editor at TidBITS and Analyst at Securosis
9955336633ffllaasstt..iinndddd xxiiii 11//2255//0099 44::3388::5544 PPMM
Introduction
As Mac OS X continues to be adopted by more and more users, it is important
to consider the security (or insecurity) of the devices running it. From a secu-
rity perspective, Apple has led a relatively charmed existence so far. Mac OS
X computers have not had any signifi cant virus or worm outbreaks, making
them a relatively safe computing platform. Because of this, they are perceived
by most individuals to be signifi cantly more secure than competing desktop
operating systems, such as Windows XP or Vista.
Overview of the Book and Technology
Is this perception of security justifi ed, or has Mac OS X simply benefi ted from its
low profi le up to this point? This book offers you a chance to answer this question
for yourself. It provides the tools and techniques necessary to analyze thoroughly
the security of computers running the Mac OS X operating system. It details exactly
what Apple has done right in the design and implementation of its code, as well as
points out defi ciencies and weaknesses. It teaches how attackers look at Mac OS X
technologies, probe for weaknesses, and succeed in compromising the system. This
book is not intended as a blueprint for malicious attackers, but rather as an instru-
ment so the good guys can learn what the bad guys already know. Penetration
testers and other security analysts can and should use this information to identify
risks and secure the Macs in their environments.
Keeping security fl aws secret does not help anybody. It is important to under-
stand these fl aws and point them out so future versions of Mac OS X will be
more secure. It is also vital to understand the security strengths and weaknesses
of the operating system if we are to defend properly against attack, both now
and in the future. Information is power, and this book empowers its readers by
providing the most up-to-date and cutting-edge Mac OS X security research.
xiii
9955336633ffllaasstt..iinndddd xxiiiiii 11//2255//0099 44::3388::5544 PPMM
xiv Introduction
How This Book Is Organized
This book is divided into four parts, roughly aligned with the steps an attacker
would have to take to compromise a computer: Background, Vulnerabilities,
Exploitation, and Post-Exploitation. The fi rst part, consisting of Chapters 1–3,
contains introductory material concerning Mac OS X. It points out what makes
this operating system different from Linux or Windows and demonstrates the
tools that will be needed for the rest of the book. The next part, consisting
of Chapters 4–6, demonstrates the tools and techniques necessary to identify
security vulnerabilities in the operating system and applications running on
it. Chapters 7–10 make up the next part of the book. These chapters illustrate
how attackers can take the weaknesses found in the earlier chapters and turn
them into functional exploits, giving them the ability to compromise vulnerable
machines. Chapters 11 and 12 make up the last part of the book, which deals
with what attackers may do after they have exploited a machine and techniques
they can use to maintain continued access to the compromised machines.
Chapter 1 begins the book with the basics of the way Mac OS X is designed.
It discusses how it originated from BSD and the changes that have been made
in it since that time. Chapter 1 gives a brief introduction to many of the tools
that will be needed in the rest of the book. It highlights the differences between
Mac OS X and other operating systems and takes care to demonstrate how
to perform common tasks that differ among the operating systems. Finally, it
outlines and analyzes some of the security improvements made in the release
of Leopard, the current version of Mac OS X.
Chapter 2 covers some uncommon protocols and fi le formats used by Mac
OS X. This includes a description of how Bonjour works, as well as an inside
look at the Mac OS X implementation, mDNSResponder. It also dissects the
QuickTime fi le format and the RTSP protocol utilized by QuickTime Player.
Chapter 3 examines what portions of the operating system process attacker-
supplied data, known as the attack surface. It begins by looking in some detail
at what services are running by default on a typical Mac OS X computer and
examines the diffi culties in attacking these default services. It moves on to
consider the client-side attack surface, all the code that can be executed if an
attacker can get a client program such as Safari to visit a server the attacker
controls, such as a malicious website.
Chapter 4 dives into the world of debugging in a Mac OS X environment.
It shows how to follow along to see what applications are doing internally. It
covers in some detail the powerful DTrace mechanism that was introduced in
Leopard. It also outlines the steps necessary to capture code-coverage informa-
tion using the Pai Mei reverse-engineering framework.
Chapter 5 demonstrates how to fi nd security weaknesses in Mac OS X soft-
ware. It talks about how you can look for bugs in the source code Apple makes
available or use a black-box technique such as fuzzing. It includes detailed
instructions for performing either of these methods. Finally, it shows some tricks
9955336633ffllaasstt..iinndddd xxiivv 11//2255//0099 44::3388::5544 PPMM
Introduction xv
to take advantage of the way Apple develops its software, which can help fi nd
bugs it doesn’t know about or give early warning of those it does.
Chapter 6 discusses reverse engineering in Mac OS X. Given that most of the
code in Mac OS X is available in binary form only, this chapter discusses how
this software works statically. It also highlights some differences that arise in
reverse engineering code written in Objective-C, which is quite common in Mac
OS X binaries but rarely seen otherwise.
Chapter 7 begins the exploitation part of the book. It introduces the simplest
of buffer-overfl ow attacks, the stack overfl ow. It outlines how the stack is laid
out for both PowerPC and x86 architectures and how, by overfl owing a stack
buffer, an attacker can obtain control of the vulnerable process.
Chapter 8 addresses the heap overfl ow, the other common type of exploit.
This entails describing the way the Mac OS X heap and memory allocations
function. It shows techniques where overwriting heap metadata allows an
attacker to gain complete control of the application. It fi nishes by showing how
to arrange the heap to overwrite other important application data to compro-
mise the application.
Chapter 9 addresses exploit payloads. Now that you know how to get control
of the process, what can you do? It demonstrates a number of different possible
shellcodes and payloads for both PowerPC and x86 architectures, ranging from
simple to advanced.
Chapter 10 covers real-world exploitation, demonstrating a large number of
advanced exploitation topics, including many in-depth example exploits for
Tiger and Leopard on both PowerPC and x86. If Chapters 7–9 were the theory
of attack, then this chapter is the practical aspect of attack.
Chapter 11 covers how to inject code into running processes using Mac
OS X–specifi c hooking techniques. It provides all the code necessary to write
and test such payloads. It also includes some interesting code examples of
what an attacker can do, including spying on iChat sessions and reading
encrypted network traffi c.
Chapter 12 addresses the topic of rootkits, or code an attacker uses to hide
their presence on a compromised system. It illustrates how to write basic kernel-
level drivers and moves on to examples that will hide fi les from unsuspecting
users at the kernel level. It fi nishes with a discussion of Mac OS X–specifi c root-
kit techniques, including hidden in-kernel Mach RPC servers, network kernel
extensions for remote access, and VT-x hardware virtual-machine hypervisor
rootkits for advanced stealth.
Who Should Read This Book
This book is written for a wide variety of readers, ranging from Mac enthusiasts
to hard-core security researchers. Those readers already knowledgeable about
Mac OS X but wanting to learn more about the security of the system may want
9955336633ffllaasstt..iinndddd xxvv 11//2255//0099 44::3388::5544 PPMM
xvi Introduction
to skip to Chapter 4. Conversely, security researchers may fi nd the fi rst few
chapters the most useful, as those chapters reveal how to use the OS X–related
skills they already possess.
While the book may be easier to comprehend if you have some experience
writing code or administering Mac OS X computers, no experience is necessary.
It starts from the very basics and slowly works up to the more-advanced topics.
The book is careful to illustrate the points it is making with many examples,
and outlines exactly how to perform the steps required. The book is unique in
that, although anybody with enthusiasm for the subject can pick it up and begin
reading it, by the end of the book the reader will have a world-class knowledge
of the security of the Mac OS X operating system.
Tools You Will Need
For the most part, all you need to follow along with this book is a computer with
Mac OS X Leopard installed. Although many of the techniques and examples
will work in earlier versions of Mac OS X, they are designed for Leopard.
To perform the techniques illustrated in Chapter 6, a recent version of IDA Pro
is required. This is a commercial tool that must be run in Windows and can
be purchased at http://www.hex-rays.com. The remaining tools either come
on supplemental disks, such as Xcode does, or are freely available online or at
this book’s website.
What’s on the Website
This book includes a number of code samples. The small and moderately sized
examples are included directly in this book. But to save you from having to
type these in yourself, all the code samples are also available for download at
www.wiley.com/go/machackershandbook. Additionally, some long code samples
that are omitted from the book are available on the site, as are any other tools
developed for the book.
Final Note
We invite you to dive right in and begin reading. We think there is something
in this book for just about everyone who loves Mac OS X. I know we learned a
lot in researching and writing this book. If you have comments, questions, hate
mail, or anything else, please drop us a line and we’d be happy to discuss our
favorite operating system with you.
9955336633ffllaasstt..iinndddd xxvvii 11//2255//0099 44::3388::5544 PPMM
Par t
I
Mac OS X Basics
9955336633cc0011..iinndddd 11 11//2255//0099 44::3399::2277 PPMM
9955336633cc0011..iinndddd 22 11//2255//0099 44::3399::2277 PPMM
CHAPTER
1
Mac OS X Architecture
This chapter begins by addressing many of the basics of a Mac OS X system.
This includes the general architecture and the tools necessary to deal with the
architecture. It then addresses some of the security improvements that come
with version 10.5 “Leopard”, the most recent version of Mac OS X. Many of these
security topics will be discussed in great detail throughout this book.
Basics
Before we dive into the tools, techniques, and security of Mac OS X, we need to
start by discussing how it is put together. To understand the details of Leopard,
you need fi rst to understand how it is built, from the ground up. As depicted
in Figure 1-1, Mac OS X is built as a series of layers, including the XNU kernel
and the Darwin operating system at the bottom, and the Aqua interface and
graphical applications on the top. The important components will be discussed
in the following sections.
3
9955336633cc0011..iinndddd 33 11//2255//0099 44::3399::2277 PPMM
4 Part I ■ Mac OS X Basics
Applications Safari, Mail, iCal, etc.
GUI Aqua
Application Environments BSD, X11, Carbon, Cocoa, AWT, Swing
Libraries URL parsing, Networking, Core Audio, HTML rendering, etc.
Kernel BSD (signals, sockets, etc.) Mach (virtual memory, IPC, etc.)
Firmware EFI
Hardware Apple hardware
Figure 1-1: Basic architecture of a Mac OS X system
XNU
The heart of Mac OS X is the XNU kernel. XNU is basically composed of a
Mach core (covered in the next section) with supplementary features provided
by Berkeley Software Distribution (BSD). Additionally, XNU is responsible for
providing an environment for kernel drivers called the I/O Kit. We’ll talk about
each of these in more detail in upcoming sections. XNU is a Darwin package,
so all of the source code is freely available. Therefore, it is completely possible
to install the same kernel used by Mac OS X on any machine with supported
hardware; however, as Figure 1-1 illustrates, there is much more to the user
experience than just the kernel.
From a security researcher’s perspective, Mac OS X feels just like a FreeBSD
box with a pretty windowing system and a large number of custom applications.
For the most part, applications written for BSD will compile and run without
modifi cation on Mac OS X. All the tools you are accustomed to using in BSD are
available in Mac OS X. Nevertheless, the fact that the XNU kernel contains all
the Mach code means that some day, when you have to dig deeper, you’ll fi nd
many differences that may cause you problems and some you may be able to
leverage for your own purposes. We’ll discuss some of these important differ-
ences briefl y; for more detailed coverage of these topics, see Mac OS X Internals:
A Systems Approach (Addison-Wesley, 2006).
Mach
Mach, developed at Carnegie Mellon University by Rick Rashid and Avie Tevanian,
originated as a UNIX-compatible operating system back in 1984. One of its pri-
mary design goals was to be a microkernel; that is, to minimize the amount of
code running in the kernel and allow many typical kernel functions, such as fi le