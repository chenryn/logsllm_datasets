roughly 10% and achieves side-eﬀect-free enforcement.
In the future, we plan to enhance FASE with inference
capabilities, allowing synthesis of functionality constraints
from static analysis of the app and/or dynamic (sandboxed)
monitoring of the app’s execution. We also plan to expand
the concept of functionality-aware security enforcement in
further dimensions beyond information ﬂow, such as access
control.
9. ACKNOWLEDGMENTS
We thank our shepherd Nick Nikiforakis and the anony-
mous reviewers for their valuable feedback. Some of the
icons used in this work are designed by Freepik from Flati-
con.
10. REFERENCES
[1] XPrivacy. www.xprivacy.eu/.
[2] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel,
J. Klein, Y. L. Traon, D. Octeau, and P. McDaniel.
FlowDroid: Precise Context, Flow, Field,
object-sensitive and Lifecycle-aware Taint Analysis for
Android Apps. In PLDI, 2014.
[3] http://asm.ow2.org.
[4] T. H. Austin and C. Flanagan. Multiple Facets for
Dynamic Information Flow. In POPL, 2012.
[5] T. H. Austin, J. Yang, C. Flanagan, and
A. Solar-Lezama. Faceted Execution of Policy-agnostic
Programs. In PLAS, 2013.
[6] C. Brabrand, R. Giegerich, and A. Møller. Analyzing
Ambiguity of Context-free Grammars. In CIAA, 2007.
[7] http://www.brics.dk/grammar/.
481[8] E. Chin and D. Wagner. Eﬃcient Character-level
Taint Tracking for Java. In SWS, 2009.
[9] https://code.google.com/p/dex2jar/.
[10] W. Enck, P. Gilbert, B. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. N. Sheth. TaintDroid: An
Information-ﬂow Tracking System for Real-time
Privacy Monitoring on Smartphones. In OSDI, 2010.
[11] V. Ganesh, A. Kie˙zun, S. Artzi, P. Guo, P. Hooimeijer,
and M. Ernst. HAMPI: A String Solver for Testing,
Analysis and Vulnerability Detection. In CAV. 2011.
[12] M. Gordon, D. Kim, J. Perkins, L. Gilham,
N. Nguyen, and M. Rinard. Information-Flow Analysis
of Android Applications in DroidSafe. In NDSS, 2015.
[13] W. G. J. Halfond, A. Orso, and P. Manolios. Using
Positive Tainting and Syntax-aware Evaluation to
Counter SQL Injection Attacks. In FSE, 2006.
[14] J. Henriksen, J. Jensen, M. Jørgensen, N. Klarlund,
B. Paige, T. Rauhe, and A. Sandholm. Mona:
Monadic second-order logic in practice. In TACAS,
1995.
[15] P. Hooimeijer, B. Livshits, D. Molnar, P. Saxena, and
M. Veanes. Fast and Precise Sanitizer Analysis with
BEK. In USENIX Security, 2011.
[16] P. Hooimeijer and W. Weimer. A Decision Procedure
for Subset Constraints over Regular Languages. In
PLDI, 2009.
[17] J. Hopcroft and J. Ullman. Introduction to Automata
Theory, Languages, and Computation.
Addison-Wesley, 1979.
[18] P. Hornyack, S. Han, J. Jung, S. Schechter, and
D. Wetherall. These Aren’t the Droids You’Re
Looking for: Retroﬁtting Android to Protect Data
from Imperious Applications. In CCS, 2011.
[19] B. Livshits and S. Chong. Towards Fully Automatic
Placement of Security Sanitizers and Declassiﬁers. In
POPL, 2013.
[20] M. Mohri and M. jan Nederhof. Regular
Approximation Of Context-Free Grammars Through
Transformation, 2000.
[21] M.-J. Nederhof. Practical Experiments with Regular
Approximation of Context-free Languages.
Computational Linguistics, 2000.
[22] OWASP Web Application Security Project,
https://www.owasp.org/.
[23] OWASP. Path Traversal Attack.
https://www.owasp.org/index.php/Path Traversal.
[24] OWASP Mobile Security Project, https://www.owasp.
org/index.php/OWASP Mobile Security Project.
[25] S. Rasthofer, S. Arzt, and E. Bodden. A
Machine-learning Approach for Classifying and
Categorizing Android Sources and Sinks. In NDSS,
2014.
[26] S. Rasthofer, S. Arzt, E. Lovat, and E. Bodden.
DroidForce: Enforcing Complex, Data-centric,
System-wide Policies in Android. In ARES, 2014.
[27] Uniform Resource Identiﬁers (URI): Generic Syntax,
http://www.ietf.org/rfc/rfc2396.txt.
[28] P. Saxena, D. Molnar, and B. Livshits. ScriptGard:
Automatic Context-sensitive Sanitization for
Large-Scale Legacy Web Applications. In CCS, 2011.
[29] D. Schreckling, J. Posegga, J. K¨ostler, and M. Schaﬀ.
Kynoid: Real-Time Enforcement of Fine-grained,
User-deﬁned, and Data-centric Security Policies for
Android. In WISTP, 2012.
[30] T. Tateishi, M. Pistoia, and O. Tripp. Path- and
Index-sensitive String Analysis Based on Monadic
Second-order Logic. In ISSTA, 2011.
[31] O. Tripp and J. Rubin. A Bayesian Approach to
Privacy Enforcement in Smartphones. In USENIX
Security, 2014.
[32] J. Yang, K. Yessenov, and A. Solar-Lezama. A
Language for Automatically Enforcing Privacy
Policies. In POPL, 2012.
[33] A. Yip, X. Wang, N. Zeldovich, and M. F. Kaashoek.
Improving Application Security with Data Flow
Assertions. In SOSP, 2009.
[34] Y. Zheng, X. Zhang, and V. Ganesh. Z3-str: A
Z3-based String Solver for Web Application Analysis.
In FSE, 2013.
APPENDIX
A. TEST SUBJECTS DETAILS
In Figure 8 we give statistics about the selected apps. For
each app, we list its number of source and sink APIs, source
and sink call sites, as well as detected sensitive information-
ﬂows.
B. FORMAL SEMANTICS OF THE FASE
DSL
Here we formalize the FASE DSL semantics. We assume
a standard environment Δ ∈ Env : Vars → Objs ∪ Prims
mapping variables to objects (including strings) and primi-
tive values. For readability we do not model the heap, and
we assume that ﬁeld identiﬁers are dereferenced in the stan-
dard way. The labeling τ ∈ Lab : Objs ∪ Prims → P(Labels)
maps objects and primitives to their labels, as described in
Section 3.2. We designate the label l⊥ ∈ Labels to repre-
sents public/trusted data. We overload τ and write τ (x),
where x ∈ Vars is a variable, for τ (Δ(x)), i.e. τ (x) returns
the label assigned to the object/primitive value stored at
x. A state σ = (Δ, τ ) ∈ Env × Lab deﬁnes the current
environment and labeling function.
An application constraint maps a sink snk , a state σ, and a
variable x to a set of strings encoded as a regular expression
r. We deﬁne the derivation ofr below.
Given a state σ and a string v, the relation (cid:16) deﬁnes the
grounding of symbolic regular expressions rsym, i.e. regular
expressions that contain variables and the keyword val, to
concrete regular expressions rconc; see Figure 10. The key-
word val evaluates to the string v, constant strings s eval-
uate to s, and variables x evaluate to Δ(x). Composite
regular expressions are evaluated recursively.
The satisfaction relation |= given in Figure 9 formalizes
the evaluation of conditions for a given state σ.
block (σ, x, l) ⊆ N × N as:
Given a state σ, a variable x, and a label l, we deﬁne
(i, j) ∈ block (σ, x, l)
(cid:17)
τ (x[i, j]) = l ∧ τ (x[i − 1]) (cid:14)= l ∧ τ (x[j + 1]) (cid:14)= l .
A pair (i, j) is contained in block (σ, x, l) iﬀ the substring
x[i, j] is a substring block uniformly labeled with l.
482App Name
Package Name
Source APIs Sink APIs Sources Sinks Sensitive Flows
Candy Crush Saga
Yellow Pages
Paper Toss
Smiley Pops
Coﬀee Finder
Bump
iHeartRadio
SmartTacToe
AccuWeather
Antsmasher
aiMinesweeper
Cat Hair Saloon
Tiny Flashlight
Celebrity Care
Mako Mobile
Video Poker
Check: Bill Pay
Princess Nail Salon
Extreme Droid Jump com.electricsheep.edj
Transparent Screen
49
com.king.candycrushsaga
103
com.avantar.wny
33
com.bfs.papertoss
55
com.boolbalabs.smileypops
80
com.brennasoft.ﬁndastarbucks
com.bumptech.bumpga
51
com.clearchannel.iheartradio.controller2 27
com.dynamix.mobile.SmartTacToe
31
89
com.accuweather
64
com.bestcoolfungames.antsmasher
24
artfulbits.aiMinesweeper
40
com.coolﬁsh.cathairsalon
com.devuni.ﬂashlight
44
44
com.g6677.android.cbaby
91
com.goldtouch.mako
81
com.inﬁmosoft.videopoker
80
com.netgate
44
com.g6677.android.pnailspa.apk
49
61
com.digisoft.TransparentScreen
64
95
54
55
87
67
51
36
87
72
44
60
70
54
95
80
92
54
61
71
250
975
128
578
564
329
117
85
1208
441
110
202
360
279
973
898
948
279
316
286
956
1647
579
667
1505
708
235
160
1683
1060
550
602
499
594
2236
1545
2194
594
906
1139
3
13
10
5
6
1
7
5
18
18
1
10
2
11
23
39
23
15
2
14
Figure 8: Information about the Android apps used in our experiments.
σ |= Cond
bool op(Δ(x1), . . . ,Δ(x k)) (cid:14)= false
(Δ, τ ) |= bool op(x1, . . . , xk)
σ (cid:14)|= c
σ |= c1 σ |= c2
(σ |= c1 and c2)
σ |= (not c)
Not
BOp
And
Figure 9: Satisfaction relation between states and conditions
Let R(cid:2) denote the regular expression that accepts all strings.
We write (x(cid:6)l(cid:7) to r) for (constrain x(cid:6)l(cid:7) to r) to avoid clut-
ter. Given an expression (x(cid:6)l(cid:7) to r), a state σ = (Δ, τ ), a
(cid:4)
(cid:3)
variable x, andp, q ∈ N, we deﬁne α as
(cid:3)
(cid:4)
(cid:3)
(cid:4)
(x(cid:6)l(cid:7) to r), σ, x[p, q]
α
(x(cid:6)l(cid:7) to r), σ, x[p, q]
α
(x(cid:6)l(cid:7) to r), σ, x[p, q]
α
(cid:3)
(cid:4)
where for some (i, j) ∈ block (σ, x, l), we have
(cid:3)
(cid:4)
(x(cid:6)l(cid:7) to r), σ, x[p, i]
,
(x(cid:6)l(cid:7) to r), σ, x[j, q]
= x[p, q]
= R(cid:2)
= r1 · r2 · r3 otherwise
r1 = α
σ, x[i, j] (cid:16) r ⇓ r2, and
r3 = α
if τ (x[p, q]) = l⊥
if τ (x[p, q]) = l
(cid:3) (cid:14)= l
.
(cid:3)
(cid:4)
Here α evaluates a substring x[p, q] to itself if it is not la-
beled, to the accept-all regular expression R(cid:2) if x[p, q] is
a block assigned with a label other than the one in the
constraint, and otherwise it recursively evaluates its labeled
blocks. We write α
as a shorthand for for
α
(cid:3)
(x(cid:6)l(cid:7) to r), σ, x
(x(cid:6)l(cid:7) to r), σ, x[0, len(x)]
+,
(cid:3)
The semantics of a set A of constraints is deﬁned as:
α
(snk if c x(cid:6)l(cid:7) to r) ∈ A ∧ σ |= c
(x(cid:6)l(cid:7) to r), σ, x
[[A]](σ, snk , x) =
(cid:4) |
-
(cid:4)
.
.
[[A]] returns the intersection of all applicable constraints. We
remark that our synthesizer translates the regular expres-
sions into DFAs, and then uses the standard algorithm for
intersecting DFAs; see Section 5.
σ, v (cid:16) rsym ⇓ rconc
σ, v (cid:16) s ⇓ s
Str
(Δ, τ ), v (cid:16) x ⇓ Δ(x)
Var
StrOp
Star
s = str op(Δ(x1), . . . ,Δ(x n))
(Δ, τ ), v (cid:16) str op(x1, . . . , xn) ⇓ s
σ, v (cid:16) r ⇓ rc
σ, v (cid:16) val ⇓ v
σ, v (cid:16) r(cid:2) ⇓ (rc)(cid:2)
Val
(cid:3)
σ, v (cid:16) r ⇓ rc σ, v (cid:16) r
σ, v (cid:16) (r · r
) ⇓ (rc · r
σ, v (cid:16) r ⇓ rc σ, v (cid:16) r
σ, v (cid:16) (r + r
(cid:3) ⇓ r
(cid:3)
c)
(cid:3) ⇓ r
) ⇓ (rc + r
(cid:3)
c)
(cid:3)
(cid:3)
c Conc
(cid:3)
c Alt
Figure 10: Grounding symbolic regular expressions
483