# 【技术分享】 CVE-2017-0290：史上最糟糕的Windows远程执行代码漏洞
|
##### 译文声明
本文是翻译文章，文章来源：0patch.blogspot.jp
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
翻译：[ **shan66**](http://bobao.360.cn/member/contribute?uid=2522399780)
**稿费：240RMB**
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**前言**
像过去一周的许多其他故事一样，本文也要首先从下面的推文开始。
Google Project Zero的Natalie Silvanovich和Tavis
Ormandy在Microsoft恶意软件保护引擎中发现了一个严重的安全漏洞，攻击者可以利用这个漏洞在只要运行了Microsoft任何反恶意软件产品（如Security
Essentials或Windows
Defender）的Windows计算机上执行任意代码，并且攻击方法也很简单，只需设法让该计算机访问一个恶意文件即可。同时，针对这个漏洞的攻击向量也非常多，例如通过电子邮件发送文件，或通过任何其他渠道（如Skype或Messenger）发送，或者将其托管在恶意网站上或将其上传到IIS
Web服务器中，等等。
与过去一周的许多其他故事不同的是，本文不会将读者详述Natalie和Tavis是如何发现这个漏洞、如何向Microsoft报告的。相反，本文将重点关注这个漏洞本身，导致该漏洞的根本原因，以及如何为它编写一个微补丁。
但是，首先你可能会问：我们为什么会想到给这个漏洞编写一个微补丁呢？众所周知，微软在修复这个漏洞方面反应非常及时，在周末就已经提供了更新。此外，恶意软件保护引擎是作为动态加载库mpengine.dll实现的，而微软巧妙地设计了其反恶意软件产品，所以人们无需重新启动计算机：只要卸载旧的DLL，加载新的DLL即可。
那么为什么要写一个微补丁呢？实际上，并不是每台计算机都会自动更新：虽然默认情况下的配置是自动应用更新，但是，如果管理员想要控制何时应用更新的话，管理员就会对这个设置进行修改。重要的是，企业管理员都喜欢这样做，因为如此一来，他们就有机会将这些更新部署到组织中的计算机之前，首先对其进行必要的测试。想象一下，如果更新的mpengine.dll有一个缺陷，就有可能阻止用户访问合法文件。
编写这个微补丁的另一个动机在于学习，因为我们以前没有修补过安全产品，所以希望能够从这件事情中学到新的东西。最后的原因是，向读者介绍分析漏洞方面的知识，以及如何编写微补丁。
**再现CVE-2017-0290**
分析漏洞的第一步是再现漏洞。 Project
Zero报告提供了一个可下载的概念验证文件，虽然具有.zip扩展名，但实际上是一个类HTML文件，其中包含一小段漏洞利用代码和大量的随机HTML内容，以确保引擎会处理该文件。
在64位Windows 8.1上再现这个漏洞其实非常简单：只需下载并保存文件就足以使Windows Defender服务崩溃，如下所示：
然后看到：
崩溃后，应用程序事件日志会记录有关此崩溃的错误事件，显示崩溃的模块是mpengine.dll，并且崩溃位置在偏移0x21745a处。
（Google报告中提供了不同的崩溃地址，因为他们使用的是32位计算机。）
请注意，我正在使用mpengine.dll版本1.1.13701.0，这是修复1.1.13704.0之前的最后一个易受攻击的版本。对最后一个易受攻击的版本进行分析总是很好，以便最小化与固定版本的差异
– 您将在分辨这些版本时感谢自己。
**CVE-2017-0290漏洞分析**
在成功再现这个漏洞之后，我们接下来要做的事情就是对其进行详细的分析。为此，我们可以首先从阅读Google的报告开始，因为Natalie和Tavis已经详细地介绍了相关的情况。
对我来说最重要的细节是，这是一个类型混淆错误，具体来说有一些函数期望接收一个
string对象，但是得到的却是一个number对象（这导致调用一个字符串vtable函数，其中却没有vtable）。
这很重要，因为对于类型混淆漏洞来说，典型的修复方法是添加相应的检查，看看类型是否正确。当观察具有漏洞的代码和修复后的代码之间的差异后，这种修复代码通常很容易识别。
下面该IDA上场了。下图显示了崩溃的函数——确切的访问违例出现在mov
rax，[rcx]指令（见红色框）处，地址为0x75A31745A，距离mpengine.dll默认基地址的偏移为0x21745a。
当厂家提供了相应的补丁后，通过比较具有漏洞的代码和修补后的代码，完美我们不仅能够得到非常有用的信息，还能更好地了解含有漏洞的程序和补丁代码。当然，这项比较的工作可能比较耗时，因为通常会涉及大型的二进制文件（比如mpengine.dll是12MB），所以经常得到很多匹配的函数，并且我们要搞清楚的是代码逻辑的不同之处，而非仅仅代码本身的区别——这可能有点令人沮丧。
所以我分析了两个版本的mpengine.dll：一个含有漏洞的1.1.13701.0版本和修补后的1.1.13704.0版本。其中，共有38440个匹配的函数，看看，这可不是一个小数目。我们要做的事情，就是比较两个版本之间的导致发生崩溃函数。如果我很幸运的话，很快就找到补丁，这样就可以早点回家了。
这两个函数在逻辑上是相同的，这意味着缺陷（和补丁）在调用堆栈的较高位置。这时，可以对所有调用这个函数的函数进行相应的比较，但是这里大约有50个函数，如果所有的函数都被证明是相同的，那么这种方法可能变成一个非常艰巨的任务。
（更不用说IDA可能弄不清楚所有调用方。）
现在考察调用堆栈：你可能已经注意到了，到目前为止我还没有使用调试器，原因是Windows
Defender是受保护的服务，因此会设法保护自己免受篡改。即使您是本地管理员，也不能将调试器附加到受保护的进程。并且即使对不保护受保护的服务做这件事情也不容易：虽然它的保护状态是由LaunchProtected注册表值定义的（在我们的例子为HKLM
SYSTEM CurrentControlSet Services WinDefend），但是，当Windows
Defender正在运行时，你无法修改相应的注册表的值，这是为了防止Windows Defender受到“攻击”。
幸运的是，我们有办法阻止Windows Defender——通过PoC让其崩溃。所以，为了让Windows
Defender崩溃，重命名其LaunchProtected注册表值，重新启动计算机（服务的受保护状态仅在系统启动时被读取），然后配置Windows错误报告以生成崩溃进程的转储文件。
（我只创建了LocalDumps键和DumpFolder值，其中包含“C： dumps”）。
在再次让Windows Defender崩溃之后，我将其转储文件放到C：
dumps中，它包含一个访问违例相关的完整调用堆栈。实际上，我只对mpengine.dll的位置感兴趣：
    mpengine!FreeSigFiles+0x11ea9a 
    mpengine!FreeSigFiles+0x12046f 
    mpengine!FreeSigFiles+0x111e81 
    mpengine!FreeSigFiles+0x111d9e 
    mpengine!FreeSigFiles+0x125eaa 
    mpengine!FreeSigFiles+0x3de1d  
    mpengine!FreeSigFiles+0x3dbf5  
    mpengine!FreeSigFiles+0x125eaa 
    mpengine!FreeSigFiles+0x117ade 
    mpengine!FreeSigFiles+0x120146 
    mpengine!FreeSigFiles+0x113d76 
    mpengine!FreeSigFiles+0xcce7f  
    mpengine+0x54a99               
    mpengine+0x865e1               
    mpengine+0x50f3f               
    mpengine+0x50d1f               
    mpengine+0x8c208               
    mpengine+0x8bf47               
    mpengine!FreeSigFiles+0x174a3  
    mpengine+0x13b7d               
    mpengine!FreeSigFiles+0x1535a  
    mpengine!_rsignal+0x243        
    mpengine!_rsignal+0xe7
对于上面的第一个我们已经有所了解——这是我们刚刚分辨出的发生崩溃的函数出现访问违例的位置。所以，我继续处理第二个地址，FreeSigFiles +