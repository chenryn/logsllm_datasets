• RBA identifies start of redo record
• Fields are
– Log sequence number (0x3666)
– Block number within redo log (0xcf)
– Byte number within block (0x10)
Change Vector
• Describes a change to a single data block
• Can apply to
– undo headers
– undo blocks
– data segment headers
– data blocks
• Is created in PGA before the data block buffer is modified
• Consists of
– header
– array of change record lengths
– array of change records
Change Vector
• For example
Change Header
Length Vector 16
Change Record 1 20
Change Record 2 48
Change Record 3 28
Change Record 4 29
Change Record 5 2
Change Record 6 2
Change Record 7 10
Change Vector Header
• Every change vector has a header e.g.
CHANGE #2 TYP:0 CLS: 1 AFN:5 DBA:0x0144d023 SCN:0x0000.0ac67cce
SEQ: 4 OP:11.5
• Fields include
CHANGE Change number
TYP Change type
CLS Class
AFN Absolute File Number
DBA Relative Database Block
Address
SCN System Change Number
SEQ Sequence Number (relative to
SCN)
OP Operation Code
Transactions
Statements Redo Logs Undo Header
SLOT STATUS
UPDATE t1 Undo Header 5.2
SET c2 = 101 0 190
Undo 5.1
WHERE c1 = 1;
Slot 0 c2 = 100
Undo Block
Redo 11.5
Slot 0 c2 = 101
Undo
Slot 0 c2 = 100
UPDATE t1 Undo 5.1
Undo
SET c2 = 201 Slot 1 c2 = 200
Slot 1 c2 = 200
WHERE c1 = 2;
Redo 11.5
Slot 1 c2 = 201
Data Block
SLOT C1 C2
COMMIT; Commit 5.4
0 1 110001
1 2 220001
Redo Record Data
• For data blocks
INSERT UPDATE DELETE
INSERT INTO score UPDATE score DELETE FROM score
(team, runs, wickets) SET WHERE team = 'AUS';
VALUES runs = 104,
('AUS',100,4); wickets = 5
WHERE team = 'AUS';
Undo
OP 5.1 (11.1) OP 5.1 (11.1) OP 5.1 (11.1)
Delete Row Piece - DRP Update Row Piece - URP Insert Row Piece - IRP
Slot 4: Slot 4: Slot 4:
OP 11.2 c1: 100 c0: 'AUS'
Insert Row Piece - IRP c2: 4 c1: 104
c2: 5
Redo Slot 4: OP 11.5
Update Row Piece - URP OP 11.3
c0: 'AUS'
Delete Row Piece - DRP
c1: 100 Slot 4:
c2: 4 Slot 4:
c1: 104
c2: 5
STOP
Global Temporary Tables
Statements Redo
-- Statement #1
HEADER 5.2
INSERT INTO t1 VALUES (1);
UNDO #1 5.1
REDO #1 11.2
-- Statement #2
UNDO #2 5.1
INSERT INTO t1 VALUES (2);
REDO #2 11.2
-- Statement #3
UNDO #3 5.1
INSERT INTO t1 VALUES (3);
REDO #3 11.2
COMMIT; COMMIT 5.4
Protection against partial writes in disk
• Redo Page Partial Write Protection
• We can configure Oracle to use checksums to verify blocks in the
redo log files.
• If block checking is enabled, Oracle computes a checksum for
each redo log block written to the current log.
• Oracle writes the checksum in the header of the block. Oracle uses
the checksum to detect corruption in a redo log block.
LGWR Process
• The log writer process writes one contiguous portion of the buffer
to disk. LGWR write:
– A commit record when a user process commits a transaction
– Redo log buffers
• Every three seconds
• When the redo log buffer is one-third full
n
• When a DBW process writes modified buffers to disk, if
necessary.
LGWR Process
• In times of high activity, LGWR can write to the redo log file using
group commits.
• For example, when LGWR is writing T-1 Commit operation redo
entries to disk, other users issue COMMIT statements.
• After the first transaction's entries are written to the redo log file,
the entire list of redo entries of waiting transactions (not yet
committed) can be written to disk in one operation, requiring less I/O
than do transaction entries handled individually.
• During flush of Redo log buffer if redo log buffer is partially filled then
the empty space will be wasted in Redo Log File.
REDO Definition
Redo Implementation in PostgreSQL
Key Structures Used in PostgreSQL
Advantages & Disadvantages of PostgreSQL Implementation
Redo Implementation in Oracle
Advantages & Disadvantages of Oracle Implementation
Improvements in PostgreSQL
Detailed method for one of the improvements
Advantages/Disadvantages Of Oracle
Implementation
• Advantages
1. Update has less redo as it writes only changed data.
2. Group commits by LGWR can reduce the overall I/O and improve
performance.
3. Writing in block sizes same as hardware/OS block size gives
benefit.
4. Log writer flushes redo if redo log buffer is 1/3rd full which will
make sure there can never be contention for Redo Log Buffer.
Advantages/Disadvantages Of Oracle
Implementation
• Disadvantages
1. There can be lot of space wastage in Redo log
files during high activity in database.
2. Redo of Insert and Delete SQL statements will be
more as compare to PostgreSQL because it has to write
Redo for Undo data generated as well.
3. Headers size is more compare to PostgreSQL. It
can have multiple headers for one Redo Record. 1st for each
Redo Record then for each Change Vector.
REDO Definition
Redo Implementation in PostgreSQL
Key Structures Used in PostgreSQL
Advantages & Disadvantages of PostgreSQL Implementation
Redo Implementation in Oracle
Advantages & Disadvantages of Oracle Implementation
Improvements in PostgreSQL
Detailed method for one of the improvements
Improvements in PostgreSQL
1. For Update operation the amount of WAL required can be reduced
by writing only changed column values and reconstruct full row
during recovery.
2. Flushing Data page contents during Commit by main user process
is costly, other databases does it in background process.
3. We can introduce a concept similar to Group Commits by WAL
writer which can improve performance during high volume of
transactions.
4. Improve the Tuple visibility logic for setting the transaction status in
a tuple during Asynchronous Commits.
5. To improve the writing of same Redo Block again and again if the
transaction data is small.
REDO Definition
Redo Implementation in PostgreSQL
Key Structures Used in PostgreSQL
Advantages & Disadvantages of PostgreSQL Implementation
Redo Implementation in Oracle
Advantages & Disadvantages of Oracle Implementation
Improvements in PostgreSQL
Detailed method for one of the improvements
Need for WAL reduction for Update
• In most telecom scenario’s, the Update operation updates few
columns out of all used in schema
• For example
CREATE TABLE callinfo ( logtime date not null, updatetime date,
callerno varchar2(20), agentid varchar2(10), status int, i0
int, c0 varchar2(20), i1 int, c1 varchar2(20), i2 int,
c2 varchar2(20), i3 int,c3 varchar2(20),i4 int,c4 varchar2(20),
i5 int,c5 varchar2(20),i6 int,c6 varchar2(20),i7 int,
c7 varchar2(20), i8 int,c8 varchar2(20),i9 int,
c9 varchar2(20),content varchar2(512));
update callinfo set status = status + 1, i0 = i0 + 1 where callerno =
:callerno
Method-1 to reduce WAL for Update op
• Only send the changed data to WAL and reconstruct tuple during
recovery.
• Reconstruction would need the old tuple data and the new tuple
changed data to reconstruct the row at time of recovery.
• After the row is generated it will be inserted in data page.
• It is better to do apply this method when old and new tuple are on
same page, otherwise it need to do I/O during recovery.
• The changed columns are logged in a byte-by-byte instruction set
format using tuple descriptor.
Method-1 Contd..
• Byte-byByte format is used instead of attributes and number of
attribute as we don’t tuple descriptor during recovery.
• The diff instructions allow us to express operations very simply.
For Example,
CREATE TABLE foo (col1 integer, col2 integer, col3 varchar(50),
col4 varchar(50));
INSERT INTO foo values (1, 1, repeat('abc',15), repeat(‘def’,15));
Method-1 Contd..
UPDATE foo SET col2 = 100 WHERE col1 = 1;
will generate diff instructions (assuming 4 byte alignment for now)
COPY 4 (bytes from old to new tuple)
IGNORE 4 (bytes on old tuple)
ADD 4 (bytes from new tuple)
COPY 90 (bytes from old to new tuple)
Method-1 Contd..
• With a terse instruction set the diff format can encode the diff
instructions in a small number of bytes, considerably reducing the
WAL volume.
• The simplicity of the diff algorithm is important because this
introduces
- additional CPU and
- potentially contention also, since the diff is calculated while the
block is locked.
• As a result, it is proposed that the diff would only be calculated
when the new tuple length is in excess of a hard-coded limit
Method-2 to reduce WAL for Update op
• This method of reducing WAL will be applied only if table has fixed
length columns(int,char,float).
• Keep only changed data and offset of it in WAL.
• Reconstruction would need the old tuple data and the new tuple
changed data to reconstruct the row at time of recovery.
• After the row is generated it will be inserted in data page.
• It is better to do apply this method when old and new tuple are on
same page, otherwise it need to do I/O during recovery.
Method-2 Contd..
• log the offset, length, value format for changed data to reconstruct
the row during recovery.
• During recovery with this information the new row can be
constructed without even tuple descriptor.
• As the log format is only for fixed length columns, so during recovery
it can be directly applied at mentioned locations to generate a new
tuple.
• This method can also be optimized such that it will log in described
format if all changed columns are before any variable data type
column.
Method-2 Contd..
• For Example
CREATE TABLE foo (col1 integer, col2 integer, col3 varchar(50),
col4 varchar(50));
INSERT INTO foo values (1, 1, repeat('abc',15), repeat(‘def’,15));
UPDATE foo SET col2 = 100 WHERE col1 = 1;
• will generate log without considering tuple header
old tuple location
Offset: 5, length: 4 value: 100
• offset and length can be stored in 2-3 bytes considering this will be
applied tuples of length less than 2000 bytes.
Comparison for method-1 & method-2
• Method-1 is valid irrespective of data type of columns, whereas
Method-2 is applied only in certain cases depending on datatype.
• In case of Method-2, contention chances will be less as the
information required for logging should be available during tuple
formation.
• Generation of new tuple during recovery can be faster in Method-2
as it needs to make a copy of original tuple and then replace new
values at specified location.
Thank You