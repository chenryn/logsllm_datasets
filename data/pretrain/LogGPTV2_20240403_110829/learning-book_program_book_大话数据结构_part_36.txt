为了清晰地讲解普里姆（Prim）算法，我们首先构造图7-6-1的邻接矩阵，如图7-6-3右图所示。该矩阵表示一个具有9个顶点的图G，其存储结构为MGragh（见本书7.4节）。在邻接矩阵中，我们使用65535来代表无穷大。

### 邻接矩阵
```
0  10  65535 65535 65535 11  65535 65535 65535
10  0  18  16  12  65535 65535 65535 65535
65535 18  0  65535 65535 65535 65535 65535 65535
65535 16  65535 0  22  20  16  65535 65535
65535 12  65535 22  0  18  65535 65535 65535
11  65535 65535 20  18  0  65535 65535 65535
65535 65535 65535 16  65535 65535 0  9  65535
65535 65535 65535 65535 65535 65535 9  0  17
65535 65535 65535 65535 65535 65535 65535 17  0
```

### 普里姆（Prim）算法代码
```c
void MiniSpanTree_Prim(MGraph G) {
    int min, i, j, k;
    int adjvex[MAXVEX]; // 保存相关顶点下标
    int lowcost[MAXVEX]; // 保存相关顶点间边的权值

    // 初始化
    lowcost[0] = 0; // 第一个顶点加入生成树
    adjvex[0] = 0;

    for (i = 1; i < G.numVertexes; i++) {
        lowcost[i] = G.arc[0][i];
        adjvex[i] = 0;
    }

    for (i = 1; i < G.numVertexes; i++) {
        min = INFINITY; // 初始化最小权值为极大值
        j = 1; k = 0;

        while (j < G.numVertexes) {
            if (lowcost[j] != 0 && lowcost[j] < min) {
                min = lowcost[j];
                k = j;
            }
            j++;
        }

        printf("(%d, %d)\n", adjvex[k], k); // 打印当前顶点边中权值最小边
        lowcost[k] = 0; // 当前顶点已加入生成树

        for (j = 1; j < G.numVertexes; j++) {
            if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j]) {
                lowcost[j] = G.arc[k][j];
                adjvex[j] = k;
            }
        }
    }
}
```

### 代码解析
1. **初始化**：
   - 创建两个一维数组 `lowcost` 和 `adjvex`，长度都为顶点个数9。
   - `lowcost[0] = 0` 表示顶点 `v0` 已经被纳入到最小生成树中。
   - `adjvex[0] = 0` 表示从顶点 `v0` 开始。

2. **读取邻接矩阵第一行数据**：
   - 将数值赋值给 `lowcost` 数组，此时 `lowcost` 数组值为 `{0, 10, 65535, 65535, 65535, 11, 65535, 65535, 65535}`，而 `adjvex` 则全部为0。

3. **生成最小生成树**：
   - 循环过程中不断修改 `min` 为当前 `lowcost` 数组中的最小值，并用 `k` 保留此最小值的顶点下标。
   - 打印当前顶点边中权值最小边，并将当前顶点的权值设置为0，表示此顶点已经完成任务。
   - 更新 `lowcost` 和 `adjvex` 数组，确保每次选择的边都是当前最小权值的边。

通过上述步骤，我们可以逐步构建出最小生成树。接下来，我们将介绍另一种生成最小生成树的方法——克鲁斯卡尔（Kruskal）算法。

### 克鲁斯卡尔（Kruskal）算法
克鲁斯卡尔算法直接以边为目标去构建生成树，通过选择最小权值的边并确保不形成环路。以下是边集数组结构的定义：

```c
typedef struct {
    int begin;
    int end;
    int weight;
} Edge;
```

将图7-6-3的邻接矩阵转化为边集数组，并按权值从小到大排序：

| begin | end | weight |
|-------|-----|--------|
| 0     | 1   | 10     |
| 0     | 5   | 11     |
| 1     | 2   | 18     |
| 1     | 3   | 16     |
| 1     | 4   | 12     |
| ...   | ... | ...    |

通过这种思路，我们可以更直观地构建最小生成树。希望这些解释能够帮助你更好地理解这两种算法。