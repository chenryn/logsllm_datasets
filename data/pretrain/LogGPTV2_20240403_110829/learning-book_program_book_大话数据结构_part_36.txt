为了能讲明白这个算法，我们先构造图7-6-1的邻接矩阵，如图7-6-3的右图所
示。
0
10
V
4
11
10
18
：
16
12
0
22
20
16
O0
11
26
0
00
00
90
170
19
00
16
7
190
0128210000∞000
图7-6-3
也就是说，现在我们已经有了一个存储结构为MGragh的G（见本书7.4节邻接矩
阵）。G有9个顶点，它的arc二维数组如图7-6-3的右图所示。数组中的我们用
65535来代表0。
于是普里姆（Prim）算法代码如下，左侧数字为行号。其中INFINITY为权值极大
值，不妨是65535，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我
们自己就是计算机，在调用MiniSpanTree_Prim函数，输入上述的邻接矩阵后，看看
它是如何运行并打印出最小生成树的。
/Prim算法生成最小生成树/
1void MiniSpanTree_Prim（MGraph G)
2
E
intmin,i，j，k;
4
int adjvex[MAxVEX];
/保存相关顶点下标*/
5
int1owcost[MAXVEX]：/·保存相关项点间边的权值·/
6
1oucost[0]-0;
/初始化第一个权值为0.即V加入生成树*/
/1owcost的值为0，在这里就是此下标的顶点已经加入生成树*/
7
adjvex[0]=0;
/·初始化第一个顶点下标为0/
8
for（i-1：i<G.numVertexe8：i++）/*精环除下标为0外的全部项点*/
9
10
1owcost[i]-G.arc[0][1]:/*将v项点与之有造的权值存入数组*/
11
adjvex[1] =0:
/和始化都为V的下称*/
247
---
## Page 272
大语数据结构
12
13
for（i=1;i<G.numVertexes;i++）
14
15
min-INFINITY；/*和始化最小权值为，*/
通常设置为不可能的大数字如32767、65535等*/
16
j=1:k=0;
17
while（j<G.numVertexes）
1循环全部顶点/
18
19
if（1owcost[j]!=0s6locost[3]<min）
20
（/如果权值不为0且权值小于min*/
21
min=lowcost[j];
1则让当前权值成为最小值*/
22
k-j:
/将当前最小值的下标存入k*/
23
24
j++;
25
26
printf（“（%d，ed）"，adjvex[k]，k）:/*打印当前项点边中权值最小边*/
27
1owcost[k]=0:/*将当前顶点的权值设置为0，表示此顶点已经完成任务*/
28
for（j-1:<G.numVertexes;j++）
1德环所有项点/
29
30
if（locost[5]1-0 66G.arc[k]（]<lowcost[j]）
31
（/*若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值*/
32
lowcost[j]-G.arc[k][j]:/*将较小权佳存入lowcost*/
33
adjvex[j]=k;
/·将下标为k的顶点存入adjvex*/
34
35
36
371
1.程序开始运行，我们由第4~5行，创建了两个一维数组bwcost和adjvex，
长度都为顶点个数9。它们的作用我们慢慢细说。
2.第6~7行我们分别给这两个数组的第一个下标位赋值为0，arjvex[0]=0其实
意思就是我们现在从顶点V开始（事实上，最小生成树从哪个顶点开始计算
都无所谓，我们假定从v开始），kwcost[0]=0就表示vo已经被纳入到最小生
成树中，之后凡是bwcost数组中的值被设置为0就是表示此下标的顶点被纳
入最小生成树。
3.第8~12行表示我们读取图7-6-3的右图邻接矩阵的第一行数据。将数值赋值
248
---
## Page 273
第7章图
给bwcost数组，所以此时kowcost数组值为
{0,10,65535,65535,65535,11,65535，65535,65535}，而 arjvex 则全部为0。
此时，我们已经完成了整个初始化的工作，准备开始生成。
4.第13~36行，整个循环过程就是构造最小生成树的过程。
5.第15~16行，将min设置为了一个极大值65535，它的目的是为了之后找到
一定范围内的最小权值。1是用来做顶点下标循环的变量，k是用来存储最小
权值的顶点下标。
6.第17~25行，循环中不断修改min为当前owcost数组中最小值，并用k保
留此最小值的顶点下标。经过循环后，min=10，k=1。注意19行if判断的
bwcost[i]!=0表示已经是生成树的顶点不参与最小权值的查找。
7.第26行，因k=1，adjvex[1]=0，所以打印结果为（0，1），表示vo至v边为
最小生成树的第一条边。如图7-6-4所示。
图7-6-4
8.第27行，此时因k=1我们将kwcost[k]=0就是说顶点v1纳入到最小生成树
中。此时bwcost数组值为{0,0,65535,65535,65535,11,65535,65535,65535}。
9.第28~35行，j循环由1至8，因k=1，查找邻接矩阵的第v行的各个权
值，与kwcost的对应值比较，若更小则修改bwcost值，并将k值存入
adjvex数组中。因第v行有18、16、12均比65535小，所以最终bwcost
数组的值为：{0,0,18,65535.65535,11,16,65535,12}。adjvex数组的值为：
{0,0,1,0,0,0,1,0,1}。这里第30行if判断的kwcost[i]!=0也说明vo和v已经是
生成树的顶点不参与最小权值的比对了。
10.再次循环，由第15行到第26行，此时min=11，k=5，adjvex[5]=0。因此打
249
---
## Page 274
数据结构
印结构为（0，5）。表示vo至vs边为最小生成树的第二条边，如图7-6-5所
示。
图 7-6-5
11.接下来执行到36行，bwcost数组的值为：{0.0,18,65535,26,0,16,65535，
12}。adjvex数组的值为：{0,0,1,0,5,0,1,0,1}。
12.之后，相信大家也都会自已去模拟了。通过不断的转换，构造的过程如图
7-6-6中图1~图6所示。
2
图3
图5
6
图 7-6-6
250
---
## Page 275
有了这样的讲解，再来介绍普里姆（Prim）算法的实现定义可能就容易理解一
些。
假设N=（P（E））是连通网，TE是N上最小生成树中边的集合。算法从U={uo}
（uo∈V），TE=O开始。重复执行下述操作：在所有uEU,vEV-U的边（uv）∈E中
找一条代价最小的边（ueVo）并入集合TE，同时vo并入U，直至U=V为止。此时TE
中必有n-1条边，则T=（V.（TE)）为N的最小生成树。
由算法代码中的循环嵌套可得知此算法的时间复杂度为0（n）。10
7.6.2克鲁斯卡尔（Kruskal）算法
现在我们来换一种思考方式，普里姆（Prim）算法是以某顶点为起点，逐步找各
顶点上最小权值的边来构建最小生成树的。这就像是我们如果去参观某个展会，例如
世博会，你从一个入口进去，然后找你所在位置周边的场馆中你最感兴趣的场馆观
光，看完后再用同样的办法看下一个。可我们为什么不事先计划好，进园后直接到你
最想去的场馆观看呢？事实上，去世博园的观众，绝大多数都是这样做的。
同样的思路，我们也可以直接就以边为目标去构建，因为权值是在边上，直接去
找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环
路而已。此时我们就用到了图的存储结构中的边集数组结构。以下是edge边集数组结
构的定义代码：
/·对过集数组Edge结构的定义*/
typedefstruct
int begin;
int end;
int weight;
rebpal
我们将图7-6-3的邻接矩阵通过程序转化为图7-6-7的右图的边集数组，并且对
它们按权值从小到大排序。
注”：目前这算法只是基本实现最小生成树的构建，算法还可以优化，请参考（算法导论》第六部分图算法的232节有
251
---
## Page 276
大话
数据结构
begin
end
weight
[ojsaapa
4
7
odges[1]
7
2
8
8
codges(2)
0
1
10
dge[3]
0
5
11
odges(4]
、
8
12
edgre[5]
3
7
16
[9]eapo
1
6
16
dge[7]
5
6
17
dge(8]
1
2
18
dge[9]
7
19
odges(10]
4
20
dge[11]
3
8
21
odges(12]
2
3
22
dge[13]
3
6
24
odges(14)
4
5