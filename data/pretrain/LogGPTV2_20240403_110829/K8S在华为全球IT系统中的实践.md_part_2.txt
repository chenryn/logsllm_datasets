## 优化后的文本

### Page 11: 联邦集群控制器与副本集控制器

#### 联邦集群控制器
1. **监视集群变化**：处理集群接入和删除，同步创建、更新、删除操作。
2. **周期性检查集群状态**：收集健康状况和指标，并刷新到API服务器。

#### 副本集控制器
1. **监视集群变化**：刷新本地缓存，包括集群容量、负载等信息，供调度使用。
2. **监视ReplicaSet (RS) 变化**：
   - 过滤出未调度的RS（`destClusters=[]`）并记录在本地缓存中，等待调度。
   - 工作线程从本地缓存中读取并处理RS，根据调度策略选择目标集群，并计算在该集群中创建的RS副本数量。
   - 更新RS调度结果，设置 `destClusters=[{cluster: "foo", replica: 6}, ...]`。

### Page 12: 多集群联邦下的服务发现

1. **创建服务**：通过Kubectl保存对象。
2. **监视服务创建**：创建外部服务并设置Endpoint。
3. **监视所有Pods**：获取Pod IP并刷新iptables。
4. **全局分布式路由**：管理控制请求和业务流量。

### Page 13: 联邦服务控制器

#### 关键机制
1. **监视集群变化**：刷新本地集群集合，供操作集群使用。
2. **监视服务变化**：将任务加入本地任务队列，待处理。
3. **服务控制器工作线程**：
   - `clusterServiceWorker`：处理新增服务任务。
   - `clusterEndpointWorker`：处理服务Endpoint刷新任务。
   - `clusterSyncLoop`：处理新集群接入的服务同步任务。
4. **测试服务连通性**：刷新服务状态。

### Page 14: 应用间的亲和/反亲和调度

- **亲和性**：减少网络消耗，提高可靠性。
- **反亲和性**：减少宕机影响，避免干扰。

### Page 15: 应用间的亲和/反亲和调度

- **示例**：为应用A创建RS，所有Pod在AZ级别互相亲和，在Node级别互相反亲和。
- **支持不同级别的亲和性**：按标签键值对动态分组。

### Page 16: 应用间的亲和/反亲和调度

- **示例**：为应用B创建RS，在Node级别亲和应用A的Pod，反亲和自身的Pod。
- **支持硬性和软性亲和/反亲和**：调度时过滤或评分。

### Page 17: 亲和性调度的对称性考虑

- **问题**：应用B亲和A，但A后于B创建怎么办？
- **解决方案**：对称性设计，调度B时检查B是否被其他应用亲和/反亲和。
- **Pod挂掉的情况**：通常由kubelet重新拉起；只有Node挂掉时，RC/RS才会重新创建Pod。

### Page 18: 亲和性调度的对称性考虑

- **不完全对称**：检查待部署的Pod亲和哪些已存在Pod，同时检查该Pod被哪些已存在Pod亲和。
  - **硬亲和**：不对称，正向为硬，反向为软。
  - **软亲和**：对称，正向反向都为软。
- **完全对称**：检查待部署的Pod反亲和哪些已存在Pod，同时检查该Pod被哪些已存在Pod反亲和。

### Page 19: 未来可用的措施

- **限制异地重启 (Forgiveness)**：Node挂掉时，Pod不被终结，等待Node恢复时原地重启。
- **运行时迁移 (Rescheduling)**：周期性检查集群中Pod的亲和/反亲和性规则，并进行调整。

### Page 20: 后续考虑投入方向

- **调度与重调度**：规模和性能优化，以支撑10万容器的需求。
- **Dedicated Node**：前期主要在控制面，后续将投入数据面分析。
- **集群联邦**：当前社区仅贡献了phase 1，需持续投入。

### Page 21: Kubernetes开源社区贡献

- **贡献**：全球排名第四，国内第一。
- **具体项目**：CentOS k8s集群管理、k8s运维系统对接、Heapster重构及sink扩展、主导设计Ubernetes集群联邦等。

### Page 22: Docker开源社区贡献

- **贡献**：全球排名第四，国内第一。
- **具体项目**：增加关闭容器OOM功能、增强容器重启策略、优化日志格式、增加内存节点限制、安全加固等。

### Page 23: 云容器引擎即将公测

- **邀请体验**：平台共建、市场合作、产品咨询。

### Page 24: Thanks!

---

希望这些优化后的文本能够帮助你更好地传达信息。如果有任何进一步的需求，请随时告知。