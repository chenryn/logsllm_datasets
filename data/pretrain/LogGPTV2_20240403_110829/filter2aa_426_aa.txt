An Analysis of the State of
Electron Security in the
Wild
Bachelor’s Thesis
Benjamin Altpeter
August 1, 2020
supervised by Prof. Dr. Martin Johns
Declaration of Authorship
I hereby declare that the thesis submitted is my own unaided work. All direct or indirect sources used
are acknowledged as references. I am aware that the thesis in digital form can be examined for the use
of unauthorized aid and in order to determine whether the thesis as a whole or parts incorporated in it
may be deemed as plagiarism. For the comparison of my work with existing sources I agree that it shall be
entered in a database. Further rights of reproduction and usage, however, are not granted here. This paper
was not previously presented to another examination board and has not been published.
Braunschweig, on August 1, 2020
Benjamin Altpeter
Contents
1. Introduction
6
2. Background
8
2.1. Electron Architecture
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2.2. A Basic App
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
3. Electron Attack Vectors
11
3.1. Attack Vectors Shared with Web Applications . . . . . . . . . . . . . . . . . . . . . . . . . .
11
3.1.1.
OWASP Top Ten . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
3.1.2.
Additional Attack Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
3.2. Attack Vectors Specific to Electron . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3.2.1.
Not Enabling Security Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
3.2.2.
Opening URLs with shell.openExternal()
. . . . . . . . . . . . . . . . . . . . . . . .
20
3.2.3.
Missing Permission Request Handlers
. . . . . . . . . . . . . . . . . . . . . . . . . .
21
3.2.4.
Insecure Protocol Handlers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
3.2.5.
Introducing Privileged APIs to the Window Object . . . . . . . . . . . . . . . . . . .
22
3.3. Differences in Exploitation Compared to the Browser . . . . . . . . . . . . . . . . . . . . . .
23
4. Documented Vulnerabilities in Electron Applications
24
4.1. XSS and RCE in Leanote Desktop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
4.2. RCE in WordPress.com for Desktop
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
4.3. RCE in Rocket.Chat Desktop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
5. Automated Analysis
32
5.1. Overview
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
5.2. Collecting Electron Apps
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
5.3. Downloading Apps and Source Code Extraction for Closed Source Apps . . . . . . . . . . .
33
5.4. Scanning for Potential Security Problems
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
5.5. Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
6. Manual Analysis
41
6.1. RCE in Jitsi Meet Electron . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
6.2. RCE in Desktop App for CMS
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
6.3. XSS and RCE in Note-taking App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
6.4. RCE in Bug Tracking App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
7. Takeaways
45
7.1. Security-Consciousness in Electron Apps . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
7.2. Recommendations to Electron Developers . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
7.3. Recommendations to App Developers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
8. Related Work
48
8.1. Foundational Research . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
Contents
4
8.2. Research on Electron . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
8.3. Research on Similar Frameworks
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
9. Conclusion
50
9.1. Future Work
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
10.Bibliography
52
A. Appendix
59
A.1. Vulnerabilities That Were Considered
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
A.2. Exposé . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
Abstract
Electron is an open source framework for building cross-platform desktop applications using regular web tech-
nologies like JavaScript, HTML and CSS. Electron apps are getting more and more popular, with thousands
of applications already built using the framework. This new paradigm also requires new security considerations
and a widened threat model: Web applications are strictly isolated from the operating system, running in the
browser’s sandbox and without access to system primitives. Electron apps, however, can be given full access to
the Node.js APIs, breaking open this isolation. Thus, many of the well-known attack vectors of the web still
apply to Electron applications, but they may be a lot more severe given full access to the system.
This thesis will first explore known attacks for Electron apps, comparing their impact there to web apps in
the browser. Then, it will present an analysis of 1,204 open and closed source Electron applications for various
security indicators to give an insight into the state of Electron security in the wild. The results show that while
the situation is improving with more developers becoming aware of the necessary security considerations and
secure defaults starting to be introduced, most apps don’t take advantage of Electron’s security features and
use of dangerous functions is common.
This work is licensed under a Creative Commons “Attribution 4.0 International”
license.
1. Introduction
“It’s easier than you think: If you can build a website, you can build a desktop app.”
Electron is an open source framework for building cross-platform desktop applications using regular web
technologies like JavaScript, HTML and CSS. Its homepage features the above statement, highlighting the
underlying philosophy: Electron strives to not just make developing desktop apps easier but also possible
for people without any experience in this field. And the strategy is working: Electron apps are getting more
and more popular, often replacing previous native ones. There are already thousands of applications built
on Electron, including popular messaging apps like Slack Desktop, Skype, and WhatsApp Desktop, IDEs
like Atom and Visual Studio Code, or even disk image writing utilities like Balena Etcher.
However, despite the apparent benefits, one also has to consider the security aspects of the framework
and the apps made using it. Web applications have long been strictly isolated from the operating system,
running in the browser’s sandbox and without access to system primitives like the file system or the ability
to modify system settings. Desktop applications, on the other hand, often fundamentally rely on this native
access. Electron tries to bridge this gap by introducing additional privileged APIs that can be accessed by
the sites the apps load, breaking open the sandbox mechanism of the underlying browser.
Therefore, the threat model needs to be significantly widened. Many of the well-known attack vectors
of the web still apply to Electron applications, some being more and some being less severe or leading
to different problems compared to the browser. In addition, however, as Electron gives its apps access to
native operating system primitives, additional attacks need to be considered and previous conclusions on
the severity of attacks need to be re-evaluated given the lack of a sandbox. XSS vulnerabilities, where an
attacker is able to inject malicious JavaScript code into a site, are a good example of this. While they are
already severe on the web, allowing the attacker to modify the page and execute the same functions a user
could, they become even more severe if the “browser” the site is running in also has full access to the user’s
computer. Now the attacker can read and write files, execute programs, and install malware, among other
things.
This begs a number of questions: What potential security pitfalls are there when writing Electron ap-
plications? Are they commonly known and well documented? Given that the framework explicitly targets
developers with little to no experience on desktop applications, how security-conscious are Electron app
developers actually? And what can be done to make Electron apps more secure? This thesis will try to
answer these questions in two parts.
The first part will focus on the theoretical background and explore known attacks, comparing their
impact when affecting a web and an Electron application. It will explain the reasons for the differences
in severity and effects. Furthermore, it will describe the steps already being taken to avoid vulnerabilities
and minimize the risks, including, for example, recommendations given by the Electron developers and the
default values of security-relevant settings. Finally, it will look at documented existing vulnerabilities in
Electron apps to get a first insight into the state of Electron security in the wild.
The second part will then try to give a broader picture of this situation in the form of an empirical analysis
of open and closed source applications using Electron. To this end, statistics on security-related practices
of a large number of Electron apps were collected. These statistics include parameters like the Electron
version used, whether security features are enabled and whether the used dependencies contain known
vulnerabilities. From these results, recommendations to both the developers of Electron and individual app
developers will be given on how to make apps more secure.
1. Introduction
7
Contributions In particular, the following contributions are made:
A comprehensive overview of common attack vectors for Electron applications is given with explana-
tions on how these problems can be avoided.
Three actual documented vulnerabilities in large Electron apps and their fixes are explained and
minimal reproducible examples of these vulnerabilities are given.
A series of scripts was written to automatically collect and analyse Electron apps and an open
source security scanner for Electron apps was extended with most changes already contributed back
upstream.
Statistics on the security-related practices of more than 1,200 open and closed source apps are pre-
sented.
From the collected statistics, multiple vulnerabilities in Electron apps were discovered and reported
to the respective projects. Where possible, these findings are also presented in this thesis.
2. Background
Electron is an open source framework for developing desktop applications using web technologies, i.e. us-
ing HTML for the content and structure, CSS for the styling and JavaScript for the functionality. This
allows the resulting apps to be cross-platform, running on Linux, macOS, and Windows with minimal
platform-specific code [1].
It was originally developed for the Atom editor by GitHub as Atom Shell and later renamed to Electron in
April 2015 [2]. Electron’s governance has moved to working groups in March 2019 [3] and since December
2019, the project is hosted by the OpenJS Foundation [4] which also manages projects like jQuery, Node.js
and Esprima [5].
2.1. Electron Architecture
The goal behind Electron is simple: Use web technologies for wide portability and easier development but
also make the app feel like a native program by exposing additional capabilities to the developers [1]. It
does so by combining two existing technologies and adding its own platform helpers on top: Sites are loaded
using the Chromium browser and access to operating system primitives, like the file system and shell, as
well as a vast ecosystem of libraries is provided through the Node.js JavaScript runtime which is meant
for running JavaScript outside of the browser and therefore includes APIs for traditional OS features, and
its corresponding package repository. Electron then adds its own APIs for native platform functions like
menus, notifications, etc.
Electron apps run across multiple processes, namely the main and renderer processes [6, p. 6]. There is
always exactly one main process that controls the application and each page has its own renderer process,
just like tabs in Chromium. The main process has access to all renderer processes while the renderer
processes are isolated and can only control their own page [7]. But while the main process has access to
privileged Electron functions, it cannot access the DOM APIs [8]. Those are only available to the renderer
processes which in turn, depending on the settings, can only access very few or none of the Electron
APIs. The main process and render processes can communicate using inter-process communication (IPC)
messages in JSON format, similar to the postMessage communication between a website and an .
Figure 2.1 illustrates this architecture.
2.2. A Basic App
A Node.js module bundles the JavaScript code of an application with its dependencies, which can be
installed using a package manager like NPM or Yarn, and are saved in the node_modules directory [9, p.
71]. It further contains a package.json file which holds metadata about the module, like its name, version,
and dependencies.
Electron apps are essentially just Node.js modules with the electron package installed as a dependency [10].
They need a JavaScript file that sets up the app, often called main.js, as an entry point that is set through
the main field in the package.json. To distribute the app, it needs to be packaged either by just bundling
it with a prebuilt Electron binary or using a third-party tool like electron-forge1 or electron-builder2 [11].
1https://www.electronforge.io/
2https://www.electron.build/
2.2. A Basic App
9
Figure 2.1.: The architecture of an Electron app. The app’s entry point script main.js runs in the main process which
has full access to the Node.js and privileged Electron platform APIs. It can spawn multiple windows
that will run in separate renderer processes. These always have access to the DOM APIs and depending
on the settings may have access to the Node.js and some Electron APIs. The different processes can
communicate with one another through IPC messages (if available to the renderer processes). In this
figure, the dashed blue parts may not be accessible to a renderer process depending on the settings for
this particular window.
main process
renderer processes
window
window
main.js
window
…
controls
read/write
read/write
privileged Electron 
APIs
some Electron 