title:Using Program Analysis to Synthesize Sensor Spoofing Attacks
author:Ivan Pustogarov and
Thomas Ristenpart and
Vitaly Shmatikov
Using Program Analysis to
Synthesize Sensor Spooﬁng Attacks
Ivan Pustogarov, Thomas Ristenpart, and Vitaly Shmatikov
Cornell Tech
ABSTRACT
In a sensor spooﬁng attack, an adversary modiﬁes the phys-
ical environment in a certain way so as to force an embed-
ded system into unwanted or unintended behaviors. This
usually requires a thorough understanding of the system’s
control logic. The conventional methods for discovering this
logic are manual code inspection and experimentation.
In this paper, we design a directed, compositional sym-
bolic execution framework that targets software for the pop-
ular MSP430 family of microcontrollers. Using our frame-
work, an analyst can generate traces of sensor readings that
will drive an MSP430-based embedded system to a chosen
point in its code. As a case study, we use our system to
generate spoofed wireless signals used as sensor inputs into
AllSee, a recently proposed low-cost gesture recognition sys-
tem. We then experimentally conﬁrm that AllSee recognizes
our adversarially synthesized signals as “gestures.”
1.
INTRODUCTION
The explosion in the popularity of embedded systems is
fueled in large part by their ability to sense, interpret, and
react to physical environments. For example, gesture recog-
nition systems measure signals and interpret them as user
commands [1,2,7,18], cameras that sense motion or light [22]
help autonomous systems navigate, and temperature sensors
inform household HVAC systems.
Software controlling embedded systems is often designed
assuming a benign environment, for example, a device owner
interacting with his own device. In real-world deployments,
however, it is necessary to consider sensor spooﬁng threats.
An attacker with direct or indirect access to the physical en-
vironment can emit physical signals that maliciously force
unwanted or unintended behaviors in the victim software
and, consequently,
in the system controlled by this soft-
ware. Recent examples include disrupting the ﬂight of au-
tonomous drones using sound generated by oﬀ-the-shelf com-
puter speakers [30] or laser pointers [11], injecting bogus
signals into medical devices [20], controlling speech recog-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS ’17, April 02 - 06, 2017, Abu Dhabi, United Arab Emirates
c(cid:13) 2017 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4944-4/17/04. . . $15.00
DOI: http://dx.doi.org/10.1145/3052973.3053038
1
nition interfaces with nonsensical noise [33], and many oth-
ers [24, 25, 29, 34]. These attacks are usually developed by
manual reverse engineering and experimentation.
Synthesizing sensor spooﬁng attacks.
In this pa-
per, we initiate research on software analysis tools that can
help discover and exploit sensor spooﬁng vulnerabilities in
embedded software. We focus on a popular class of em-
bedded systems:
lightweight microcontrollers attached to
one or more sensor components. The sensors convert physi-
cal readings (temperature, light, sound, electromagnetic sig-
nals, etc.) into digital values that are read by the micro-
controller’s software (often called ﬁrmware in this context).
Such systems are ubiquitous in so-called Internet-of-Things
(IoT) applications, autonomous vehicles, and elsewhere.
Sensor spooﬁng attacks involve an adversary generating
malicious inputs in the physical layer to cause certain be-
haviors in the target ﬁrmware. They can be decomposed
into a “software” phase and a “physical” phase.
In the software phase, the adversary infers which digital
inputs to the ﬁrmware will force the behavior the adversary
wants. In the physical phase, the adversary determines the
analog signals that will cause the target sensor to output the
desired digital readings. In this paper, we assume that the
speciﬁcations that describe the sensor’s physical-to-digital
conversion are suﬃcient for signal generation in the physical
phase. Therefore, we focus primarily on the software phase.
Our goal is to build a tool that can automatically discover
sequences of digital sensor readings that drive the ﬁrmware
to an adversarially chosen state. This includes possible se-
quences that the ﬁrmware designers did not expect. As with
other types of vulnerabilities (memory safety errors, race
conditions, etc.), automated analysis tools will in turn help
analysts harden their systems in the face of adversarial be-
havior.
This is a problem well-suited for symbolic execution [19],
given its ability to automatically generate inputs that drive
the program into particular execution paths. Existing sym-
bolic execution tools, however, do not work in our setting.
In contrast to the large body of research on symbolic execu-
tion for traditional architectures such as x86 [3, 5, 12, 16, 23,
27, 28], there are few tools for lower-end embedded architec-
tures [10, 21]. As we will see, even these tools do not per-
form well on the code patterns characteristic of the embed-
ded code that deals with sensor readings. Interrupt-driven
sensor-measurement loops prevent traditional forward sym-
bolic execution from reaching the relevant program points
(e.g., those that cause an embedded system to take actions
in response to certain sensor inputs). These code constructs
757cause path explosion, i.e., the number of feasible paths that
must be considered grows too fast.
Our contributions. We present DrE, the ﬁrst tool specif-
ically engineered to analyze embedded ﬁrmware code with
respect to signal input spooﬁng. To handle the challenges
of analyzing embedded ﬁrmware, DrE uses a modular ap-
proach that takes advantage of both directed and composi-
tional symbolic execution.
Instead of attempting to explore all code paths, directed
symbolic execution [3, 23] starts with a target, i.e., a partic-
ular point of interest in the program. In our context, these
points are (easily identiﬁed) sections of the ﬁrmware code
corresponding to the control actions that the attacker wants
to ﬁrmware to take. The output of a successful directed
symbolic execution is a path, deﬁned as a set of constraints
on inputs (i.e., sensor readings) that, if satisﬁed, will drive
the program to the designated point.
To mitigate path explosion, we devised a modular strategy
to eﬃciently ﬁnd paths to program points of interest. It uses
a combination of call graph and control ﬂow graph analysis
with compositional symbolic execution. DrE starts by ﬁnd-
ing possible call chains from the program’s entry point to
the function containing the target line. It then symbolically
executes the function containing the target point and pro-
ceeds through a call chain backwards. Each function along
the way is (symbolically) executed independently. To gen-
erate inter-procedural path constraints, DrE then stitches
together the execution paths of individual functions. To
do this, DrE collects, rewrites, and propagates the relevant
constraints and performs a forward pass to check them.
For eﬃciency, DrE employs several additional heuristics.
DrE biases state selection towards shorter paths leading to
the target program point and employs a state-pruning strat-
egy [6, 10] to break out of inﬁnite wait loops.
We applied DrE to a recently proposed gesture recogni-
In normal operation, this
tion system called AllSee [18].
MSP430-based system attempts to recognize several hand
gestures by extracting information from ambient wireless
signals (for example, TV or Wi-Fi). We show how to use
DrE with a simple model of the AllSee signal strength sen-
sor to generate spooﬁng attacks. The output of DrE can be
converted by the adversary into a sequence of radio signals
in the appropriate Mhz range using the sensor’s speciﬁca-
tion. These signals trick the ﬁrmware into “recognizing” a
gesture of the adversary’s choosing.
We experimentally demonstrate feasibility of our synthe-
sized spooﬁng attack against the actual AllSee ﬁrmware with
reduced sampling rate connected to an emulated sensor. Us-
ing a software-deﬁned radio to generate spoofed signals, we
were able to successfully spoof all gestures. The spoofed
signals can be used to maliciously control AllSee-equipped
devices without the device owner’s knowledge or consent.
In addition to demonstrating that our approach is capable
of synthesizing non-trivial spooﬁng attacks, our results call
into question the security of unauthenticated wireless ges-
ture recognition.
2. OVERVIEW
MSP430. Our program analysis tool targets the MSP430
family of 16-bit RISC microcontrollers from Texas Instru-
ments. It is one of the most popular microcontrollers [14]
today, used in a wide range of low-powered embedded sys-
2
tems [32]. Among its features are low power consumption,
wide range of peripheral modules, and ease of use.
MSP430 chips have 16-bit-addressable memory, including
peripheral control registers, RAM, and Flash memory (the
exact amount of each kind of memory depends on the chip).
Peripherals are accessed through a set of chip-speciﬁc, pre-
deﬁned memory locations called control registers. The ac-
tual memory layout for a speciﬁc MSP430 chip can usually
be found in its speciﬁcation published by TI. MSP430 pro-
grams are typically written in C and make extensive use of
memory locations related to peripherals.
MSP430 ﬁrmwares are typically interrupt-driven programs.
The ﬁrmware puts the chip into an inﬁnite loop that sleeps
while waiting for inputs from the environment, which are
then handled by interrupt handlers.
Threat model. The general class of attacks we are in-
vestigating is sensor input spooﬁng [9, 11, 20, 24, 25, 29, 30,
33, 34]. In the context of gesture recognition systems (see
Section 5.3), the goal of a spooﬁng attack is to force the sys-
tem to “recognize” gestures that were not actually made by a
human body. To do so, the adversary emits wireless signals
from a nearby device that drive the recognizer’s ﬁrmware
into a code path that ends with the ﬁrmware concluding that
a particular gesture was performed. This can enable the ad-
versary to attack higher-level programs relying on gesture
input.
One plausible strategy for a gesture spooﬁng attack is to
actually generate a signal (i.e., perform the gesture) that
drives the device into the desired state, measure that signal
next to the device, and replay the measured signal to other
devices. In some scenarios, this approach would work well,
but it requires a priori understanding of what signal needs
to be produced in order to drive the device to the desired
state. For more complex systems, this could involve signif-
icant manual analysis even given the device’s source code.
Also, this approach may not work for signals that are diﬃ-
cult to measure precisely in noisy conditions, and it will not
help analysts explore ﬁrmware behavior in the face of signal
sequences not envisioned by the ﬁrmware designer.
In this paper, we show how the adversary can use pro-
gram analysis of the device’s source code to determine what
the signal should “look like” without actually performing
the physical action that generates the signal. Consider a
ﬁrmware that reads values from an analog sensor connected
to the chip through the ADC (analog-to-digital conversion)
port and takes a particular action if it recognizes a prede-
ﬁned pattern in these values. We translate this problem of
signal pattern extraction—how to ﬁnd sensor readings that
cause the program to “believe” that it received a certain sig-
nal—into a program analysis problem, namely, line reacha-
bility.
The attacker ﬁrst identiﬁes the lines in the code where a
pattern-dependent action is taken. By setting each of these
lines in turn as the target, our tool generates input con-
straints necessary to reach the line. These constraints can
then be used together with the physical properties of the
sensor (e.g., the ADC sampling rate) to generate signal pat-
terns that cause the ﬁrmware to perform a given action.
Symbolic execution. When a program is symbolically
executed [19], its inputs are replaced by symbolic values.
Whenever the program’s control ﬂow reaches a branch in-
struction involving a symbolic value, the execution forks into
758two states. Each resulting state is assigned the correspond-
ing path condition on the symbolic variable and the execu-
tion proceeds along both branches. One of the key features
of symbolic execution is that collected path conditions can
be used to generate program inputs for each explored path.
Consider a program with a single input x and a branch in-
struction conditioned on x > 5. At the start of the program,
x is replaced by a symbolic variable α. Symbolic execution
of this program starts with one state and empty path condi-
tions. When the execution reaches the instruction “if( x >
5 )”, it forks and a copy of the initial state is created. The
ﬁrst state proceeds along the true branch and adds α > 5
to its path conditions. The second state proceeds along the
false branch and α ≤ 5 is added to its path conditions. As
the execution goes through more branch instructions, more
states are created; the number of states grows exponentially
with the number of branches involving symbolic values, usu-
ally causing path explosion.
In typical applications of symbolic execution, the goal is
maximum code coverage, i.e., to to cover as many branches
in the execution tree as possible. Most open-source sym-
bolic execution tools are optimized for this goal. Directed
symbolic execution [3, 23], on the other hand, tries to ﬁnd
an input that would steer the program to a target line of
code, exploring as few paths as possible. Since some states
have a higher chance to reach the target line than others
and non-trivial programs have a large number of states, de-
ciding which states to execute next (i.e., the state selection
strategy) plays an important role for directed symbolic exe-
cution.
3. FORWARD SYMBOLIC EXECUTION
Symbolically executing ﬁrmware code for embedded sys-
tems has nuances speciﬁc to microcontrollers:
interrupt-
driven control ﬂow, extensive use of peripheral devices, and
hardware-related memory areas. Consider a common code
pattern1 for MSP430 microcontrollers in Figure 1. This
code poses two problems for conventional tools. First, it
uses symbols peripheral-related memory locations, WDTCTL
and BCSCTL1. Before symbolic execution can start, these
symbols need to be resolved and the corresponding memory
locations initialized (possibly with symbolic values). Sec-
ond, the code snippet includes an interrupt handler. Since
there is no explicit call to the handler, the execution engine
should be “educated” on when to execute it.
We chose the FIE [10] symbolic execution engine as our
basis for DrE since it already provides memory and interrupt
models for MSP430. FIE, in turn, reuses several compo-
nents from an earlier symbolic execution tool for x86 called
KLEE [8]. We started by augmenting FIE with a new state
selection strategy that prefers states closer (in terms of the
number of basic blocks) to the target line in the program’s
ICFG (interprocedural control ﬂow graph). We call this
mode of DrE “Forward Only Mode.” We build the program’s
ICFG path and select states as follows.
Build call chains. We ﬁrst choose k shortest call chains
(fn ← . . . ← f1 ← f0) from the target line to the entry
point. The ﬁrst function in this chain, fn, contains the tar-
get line. In our implementation we use k = 4.
Build interprocedural control ﬂow paths. For each such chain,
1Taken
from
projects/rtc-clock
http://www.simpleavr.com/msp430-
1
2 void main ( void ) {
3
uint8_t pos =0;
WDTCTL = WDTPW + WDTHOLD + WDTNMI + W D T N M I E S ; //
stop WDT , enable NMI hi / lo
BCSCTL1 = C A L B C 1 _ 1 M H Z ;
// Set DCO to 1 MHz
...
_BIS_SR ( GIE ) ;
while (1) {
// enable i n t e r r u p t
4
5
6
7
8
9
10
16
17 }
...
}
11
12 }
13
14 i n t e r r u p t ( P O R T 1 _ V E C T O R ) P O R T 1 _ I S R ( void ) {
15
P1IE &= ~( BIT2 | BIT7 ) ; // disable pin i n t e r r u p t
_ B I C _ S R _ I R Q ( L P M 4 _ b i t s ) ; // wake up , got
k e y p r e s s e d
Figure 1: Simple MSP430 code example.
we build an ICFG path by concatenating the shortest CFG
paths of each fi (from fi’s entry to the callsite of fi+1).
Expand inner calls.
If a CFG path contains an inner call
to g, we (recursively) expand it: ﬁnd g’s shortest path from
its entry to the return statement and replace the call to g
with this path. We then choose the shortest among the k
constructed ICFG paths.
Select state. During execution, DrE chooses the next state
according to the following strategy. First, it prefers states
for which the current instruction is in a function that belongs
to the chosen ICFG path. Among these states, it chooses
the one that is closest to fn (in terms of the number of
functions). If two states belong to the same function, DrE
chooses the one that is closest to the function’s return state-
ment (or a call to the next function in the ICFG) in terms
of the number of basic blocks.
Limitations of FIE’s interrupt model.
In FIE, in-
terrupts can be ﬁred either for each basic block or for each
instruction. Because interrupt ﬁrings cause new states to be
generated (one state in which the interrupt ﬁred and one in
which it did not), this quickly creates a large number of ex-
ecution paths, the vast majority of which are not feasible in
practice because interrupts would not ﬁre on every instruc-
tion (or every basic block) in a real execution. Consider the
code snippet in Figure 2: (1) a read from the ADC port is
followed by (2) some logic consisting of several basic blocks,
and (3) another read from the ADC. During the ADC in-
terrupt, the ADC value is saved and the average of previous
values is computed.
The developer’s intention here is to check if the last ADC
value is bigger than the average after adding exactly this
new value. If the ADC interrupt is called every instruction
or every basic block, the average will contain redundant val-