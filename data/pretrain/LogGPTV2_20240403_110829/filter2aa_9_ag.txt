 完全不懂路由协议。秘书可以服务多名经理，正如TCP层可以支持很多应用层协议。
如果让邮递员包揽秘书的工作，是否也可以呢？说不定也能做到，虽然听上去很滑稽。历史上还真存在过这种情况—TCP和IP刚发明的时候就是合在一层的，后来才拆成两层。那么，如果在经理和秘书之间加个助理，专门负责检查错别字，会有问题吗？与很多官僚作风严重的机构一样，多盖一个章就要多花一些时间。还记得20世纪那场OSI七层模型与TCP/IP模型的竞争吗？最终胜出的就是分层更简单的TCP/IP模型。要知道网络分层的目的并不仅仅是完成任务，而是要用最好的方式来完成。
理解了分层的基本概念，我们再来看看复杂一点的情况。如果这个写操作比较大, 变成8192字节，TCP层又该如何处理？是否也是简单地加上TCP头就交给网络互连层（网络层）呢？答案是否定的。因为网络对包的大小是有限制的，其最大值称为MTU，即“最大传输单元”。大多数网络的MTU是1500字节，但也有些网络启用了巨帧（Jumbo Frame），能达到9000字节。一个8192字节的包进入巨帧网络不会有问题，但到了1500字节的网络中就会被丢弃或者切分。被丢弃意味着传输彻底失败，因为重传的包还会再一次被丢弃。而被切分则意味着传输效率降低。
由于这个原因，TCP不想简单地把8192 字节的数据一口气传给网络互连层，而是根据双方的MTU决定每次传多少。知道自己的MTU容易，但对方的MTU如何获得呢？如图5所示，在TCP连接建立（三次握手）时，双方都会把自己的MSS（Maximum Segment Size）告诉对方。MSS加上TCP头和IP头的长度，就得到MTU了。
图5
在第一个包里，客户端声明自己的MSS是8960，意味着它的MTU就是8960+20（TCP头）+20（IP头）=9000。在第二个包里，服务器声明自己的MSS 是1460，意味着它的MTU就是1460+20+20=1500。图6是TCP连接建立之后的写操作，我们来看看究竟是哪个MTU起了作用。
 客户端在包号46创建了abc.txt，然后通过48、49、51、52、54和55共6个包完成了这个8192字节的写操作。这些包的大小符合接收方的MTU 1500字节（见图6中划线的Total Length: 1500），而不是发送方本身支持的9000字节。也就是说，接收方的MTU起了决定作用。
图6
假如把客户端和服务器的MTU互换一下，这时客户端最大能发出多少字节的包呢？答案还是1500。因为无论接受方的MTU有多大，发送方都不能发出超过自己MTU的包。我们可以得到这样的结论：发包的大小是由MTU较小的一方决定的。
这个例子告诉我们，分层之间的关系还不仅是分工。某些分层的协议，比如TCP，甚至会主动为下一层着想，从而避免很多问题。当然这个方案还不算完美。如果网络路径上存在着一个MTU小于1500的设备，这个包还是可能被丢弃或者切分。正如Wikipedia所说，“There is no simple method to discover the MTU of links”。
一个分层的概念就写了这么多，你或许早就开始纳闷：为什么网络要设计得如此复杂？又是分层又是分组的。其实当我被各种难题搞得焦头烂额的时候，也有过这个想法，但无奈这就是现实—假如没有这么复杂的设计，网络就不会如此强大，也达不到今天的规模。从另一个角度考虑，正是复杂的设计才让我们有了这份工作，感谢祖师爷们赐饭。
TCP的连接启蒙
听说现在的年青人可以用手机摇到妹子，可惜在我们那个年代，手机的主要功能只有两个—电话和短信。人们凭直觉决定该打电话还是发短信，却很少去深究这两者的本质差别。
打电话时要先拨号，等接通之后才开始讲话。如果有人还没拨号就对着电话自言自语，旁人一定会觉得很诡异。而发短信时根本不用考虑对方在干嘛，直接发出去就是了。这两种方式的本质差别就是，打电话时要先“建立连接”（即拨号），而短信不需要。建立连接需要花费一些时间，但也意味着更加可靠。我们可以在电话上确保对方已经听明白。而短信就不行了，发送之后并不知道对方是否及时收到，也不知道有没有产生误解。有一个笑话这样调侃短信所引发的事故—出差的丈夫一大早就给妻子发了条短信“I had a wonderful night, and really wish you were here”。不幸的是，他少打了最后一个“e”，这个误会估计需要一个面对面的连接才能化解。
网络的传输层和手机一样用于传递信息。它也有两种方式—TCP和UDP，其中TCP是基于连接的，而UDP不需要连接。它们各自支持一些应用层协议，但也有些协议是两者都支持的，比如DNS。我们正好可以用DNS来比较TCP和UDP的差别。在我的实验室中，客户端10.32.106.159向DNS服务器10.32.106.103发起一个DNS查询，以期获得paddy_cifs.nas.com所对应的IP地址。
1．DNS默认使用UDP的情况下（见图1）：
图1
 这个过程的所有网络包如图2所示：
图2
2．用set vc强制DNS使用TCP的情况下（见图3）：
图3
这个过程的所有网络包如图4所示：
图4
从这两种情况的截图可以看到，真正起查询作用的只有两个DNS包。
客户端：“paddy_cifs.nas.com的IP是多少啊？”
服务器：“是10.32.106.77。”
在使用UDP的情况下，的确只用这两个包就完成了DNS查询。但在使用TCP时，要先用3个包（包号1、2、3）来建立连接。查询结束后，又用了4个包（包号7、8、9、10）来断开连接。Wireshark把这两种情况的差别完全显示出来了。我们可以从中看到连接的成本远远超过DNS查询本身，这对繁忙的DNS服务器
 来说无疑是巨大的压力。如果你的DNS还在使用TCP，该考虑更改了。
连接当然要付出代价，但带来的好处也很多，这就是为什么多数应用层协议还是基于TCP的原因。在以后的章节里，你将从Wireshark看到TCP的巨大优势，不过在此之前，一定要理解TCP的工作原理。Wireshark上能看到很多TCP参数，理解了它们就是学习TCP最好的开始。图5是10.32.106.159往10.32.106.62传数据的过程。我已经把一些参数用黑框标志出来，以便阅读时参照。
图5
Seq：表示该数据段的序号，如图5中的Seq＝3681。
TCP提供有序的传输，所以每个数据段都要标上一个序号。当接收方收到乱序的包时，有了这个序号就可以重新排序了。我们不一定要知道Seq号的起始值是怎么算出来的，但必须理解它的增长方式。如图6所示，数据段1的起始Seq号为1，长度为1448（意味着它包含了1448个字符），那么数据段2的Seq号就为1+1448=1449。数据段2的长度也是1448，所以数据段3的Seq号为1449+1448=2897。也就是说，一个Seq号的大小是根据上一个数据段的Seq号和长度相加而来的。
图6
图5的Wireshark截屏也显示了相同的情况，51号包的Seq=3681，Len=1448，所以52号包的Seq=3681+1448=5129。这个Seq号是由这两个包的发送方，也就是10.32.106.159维护的。
由于TCP是双向的，在一个连接中双方都可以是发送方，所以各自维护了一个Seq号。53号包和56号包的Seq号是10.32.106.62维护的，由于53号包的Seq=885，Len=0，所以56号包的Seq=885+0=885。
 Len：该数据段的长度，如图5中的Len=1448，注意这个长度不包括TCP头。图5中虽然10.32.106.62发出的两个包Len=0，但其实是有TCP头的。头部本身携带的信息很多，所以不要以为Len=0就没意义。
Ack：确认号，如图5中的Ack＝6577，接收方向发送方确认已经收到了哪些字节。
比如甲发送了“Seq: x Len: y”的数据段给乙，那乙回复的确认号就是x+y，这意味着它收到了x+y之前的所有字节。同样以图5为例，52号包的Seq=5129, Len=1448，所以来自接收方的53号包的Ack=5129+1448=6577，表示收到了6577之前的所有字节。理论上，接收方回复的Ack号恰好就等于发送方的下一个Seq号，所以我们可以看到54号包的Seq也等于5129+1448=6577。
你也许想问51号包为什么没有对应的确认包呢？其实53号包确认6577的时候，表示序号小于6577的所有字节都收到了，相当于把51号发送的字节也一并确认了，也就是说TCP的确认是可以累积的。
在一个TCP连接中，因为双方都可以是接收方，所以它们各自维护自己的Ack号。本例中10.32.106.62没有发送任何字节，所以10.32.106.159发出的Ack号一直不变。
你可能要花些心思来学习这几个参数，不过付出是值得的。因为一旦理解了它们，接下来学习TCP的特性就会水到渠成。比如当包乱序时，接收方只要根据Seq号从小到大重新排好就行了，这样就保证了TCP的有序性。再比如有包丢失时，接收方通过前一个Seq+Len的值与下一个Seq的差，就能判断缺了哪些包，这保证了TCP的可靠性。我们举个例子来说明这两种状况，以下3个包到达了接收方（见表1）：
表1
第一个包
第二个包
第三个包
Seq:301 Len:100
Seq:101 Len:100
Seq:401 Len:100
很明显，从Seq号可见它们的顺序是乱的。重新排序之后应该是下面这个样
 子（见表2）：
表2
Seq:101 Len:100
Seq:301 Len:100
Seq:401 Len:100
排序完之后还是有问题。第一个包的Seq+Len=101+100=201，意味着下一个包本应该是Seq:201，而不是实际收到的Seq:301。由此接收方可以推断，“Seq:201”这个包可能已经丢失了。于是它回复Ack:201给发送方，提醒它重传Seq:201。
除了这几个参数，TCP头还附带了很多标志位，在Wireshark上经常可以看到下面这些。
• SYN：携带这个标志的包表示正在发起连接请求。因为连接是双向的，所以建立连接时，双方都要发一个SYN。
• FIN：携带这个标志的包表示正在请求终止连接。因为连接是双向的，所以彻底关闭一个连接时，双方都要发一个FIN。
• RST：用于重置一个混乱的连接，或者拒绝一个无效的请求。
如图7所示，我故意尝试连接一台Linux服务器的445端口（一般只有Windows上才开启这个端口，Wireshark上把该端口显示为microsoft-ds），结果就被RST了。当然这个实验属于“没事找抽型”，实际环境中的RST往往意味着大问题。如果你在Wireshark中看到一个RST包，务必睁大眼睛好好检查。
图7
了解了这些参数和标志位，我们就可以学习TCP是如何管理连接的了。图8是一个标准的连接建立过程：
图8
 这三个包就是传说中的“三次握手”。事实上，握手时Seq号并不是从0开始的。我们之所以在Wireshark上看到Seq=0，是因为Wireshark启用了Relative Sequence Number。如果你想关闭这个功能，可以在Edit-->Preferences-->protocols-->TCP里设置。
握手过程可以用图9来表示。
图9
如果用文字来表达，过程就是这样的。
客户端：“我能跟你建立连接吗？我的初始发送序号是X。如果你答应就Ack=X+1。”