detect a captive portal. Of the captive portal errors caught by
our human-curated rules (described in Section 4.3.1), 30.1%
were not identified by Chrome. We attribute the high false
negative rate to slow captive portals. According to Chrome
telemetry, only 54% of captive portal probe requests respond
within 3 seconds, which is the maximum amount of time
that Chrome will wait for a probe to respond before drawing
error UI. Moreover, a preliminary survey of captive portals in
Japan suggest that some portals intentionally evade detection
for unknown reasons [20].
Our findings show that using network probes to detect captive
portals is difficult and unreliable. In addition, we believe that we are
missing error reports from many captive portals. A captive portal
typically blocks reports from being sent until the user has logged
in to the portal. Since Chrome did not retry failed report uploads
until very recently, we do not expect to receive reports that were
blocked by captive portals. We only receive such reports when the
portal does not block the upload for some reason, or when the
user authenticates with the portal before the certificate warning
is dismissed. Therefore, we suspect that the fraction of certificate
errors caused by captive portals, as shown in Table 1, significantly
undercounts the problems that they cause.
Of the captive portal reports that we do receive, interestingly, a
large number of them share the same few certificate chains from a
handful of captive portal vendors, as shown in Table 3. This gives
some hope that if a small number of vendors adopted better cap-
tive portal implementations that did not cause spurious certificate
warnings, the problem could be significantly alleviated.
Table 3: The top five most common captive portal vendors
in certificate reports from Sept 13 - Oct 10 2016.
Captive portal vendor Percent of all reports
Aruba Networks
0.95%
0.14%
Orange France
0.12%
AlwaysOn
0.09%
GlobalSuite
AccessNetwork.ru
0.09%
8.2 TLS proxying
Enterprises, schools, and even home networks often have middle-
boxes that intercept TLS connections using their own root certifi-
cates, which are intended to be installed on devices on the network.
These middleboxes introduce many of the same security problems
that consumer anti-virus introduces. As discussed in Section 7.2,
TLS proxies on both the client and the network override Chrome’s
security checks and can introduce bugs that cause error warnings.
We find that missing roots for network middleboxes are a wide-
spread problem. Our pipeline classifies such errors by looking for
several popular middlebox product names in the certificate chain
(as described in Section 4.3.2). Table 1 shows the relative frequency
of this error class. Our classification is conservative; when we re-
viewed unclassified reports (Section 9), we found that many are
due to other TLS proxy products not covered by our rules.
Missing root certificates cause the vast majority of certificate
errors that users of these products encounter. For each of these
products, more than 80% of certificate errors chaining to the prod-
uct’s certificate were caused by a missing root. When a user of one
of these products sees a certificate error, it is very likely to be due
to a missing root rather than any other cause.
In addition to missing roots, we observe by manual review that
TLS proxies introduce spurious certificate warnings by means of
other misconfigurations as well. For example, some middleboxes
use SHA-1 signatures, which Chrome no longer accepts as valid.
9 UNCLASSIFIED ERRORS
Our analysis pipeline does not automatically assign a root cause for
37% of reports. To characterize the unclassified reports, we manually
reviewed a random sample of 100 unclassified reports from May
2017. (We reviewed recent reports that had not yet been stripped of
details, since otherwise it would be difficult to investigate the cause
of a report.) Table 4 shows the results. When the pipeline does not
automatically assign a root cause, it is often because the report is
for a site about which Googlebot has no data (e.g. an intranet site)
or because the error was caused by a TLS proxy or captive portal
that our pipeline does not look for. As described in Section 4.1.5,
our pipeline does not yet attempt to assign root cause for certificate
warnings that are due to SHA-1 signatures, because Chrome had
not yet fully removed SHA-1 support during most of our dataset.
Our manual analysis revealed more client and network mis-
configurations than server misconfigurations. We anticipated this
finding because our automatic analysis shows an even breakdown
between client/network and server misconfigurations, but with a
known under-count of captive portal errors.
Session F5:  Understanding Security FailsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1415Table 4: Manually assigned root causes from a random sam-
ple of 100 reports in May 2017 for which our analysis
pipeline did not automatically assign a root cause.
Error cause from manual inspection
Server errors
Server certificate uses weak signature algorithm
Server certificate has a name mismatch
Insufficient intermediates
Government root certificate that isn’t widely trusted
Intranet IP without valid cert
Server certificate chains to distrusted root
Server certificate has multiple errors
Total
Network errors
Captive portal
Corporate middlebox
School middlebox
Misconfigured home router
Other middlebox
Total
Client errors
Old or corrupted root store
Ad blocker or anti-virus using weak signatures
Expired anti-virus root
Local server
Incorrect clock
Total
Unknown
Count
10
9
5
5
4
2
2
37
22
8
7
4
3
44
2
2
1
1
1
7
12
10 MITIGATIONS
Our ultimate goal is to stop showing unnecessary HTTPS error
warnings. In this section, we propose, discuss, and evaluate mitiga-
tions for many of the misconfigurations that cause Chrome users
to see unnecessary warnings. We expect that these mitigations will
or have already replaced about 25% of certificate errors in Chrome.
When possible, we would like to avoid showing any error UI at
all. Ideally, browsers would be able to automatically correct or work
around the misconfiguration in a way that is invisible to the end user.
When that isn’t possible, we aim to replace certificate warnings with
actionable, non-scary explanations of the error. These explanations
should pinpoint the cause of the error and prompt the user to fix it.
Both approaches require caution because attackers can make their
attacks look like misconfigurations. We therefore must ensure that
our mitigations are not advantageous to attackers.
10.1 Stopping client clock errors
We tackled client clock errors by implementing a special warning to
show when the user’s clock is wrong (Figure 5). To prevent attackers
from leveraging this less-scary UI, users cannot click through –
they have to fix their clocks to get to the site. We built this warning
by using a heuristic based on the build time to guess when the
clock is wrong. We then used our dataset of certificate reports to
investigate the effectiveness of the heuristic. Since its performance
Figure 5: The UI that Chrome shows when it detects that a
certificate error is caused by a client clock error.
was not satisfactory, we built and evaluated a replacement secure
time service.
10.1.1 Build time heuristic. Chrome’s build time heuristic com-
pares the current system time to the binary build time. If the system
time is either one year behind the build timestamp or more than
two days ahead of it, then Chrome will show the clock warning
when it encounters a certificate date error.
We find that the build time heuristic has many false negatives.
We are able to evaluate it post hoc by looking at the client time in
the reports. From April 30 to May 13, 2017, the heuristic only de-
tected 68% of certificate errors that were caused by incorrect client
clocks. For the remainder, Chrome showed the generic certificate
warning. This suggested to us that we needed to improve client
clock detection beyond the build time heuristic.
When the heuristic is able to identify a client clock error, the
UI (Figure 5) proves helpful. In 53% of reports associated with this
UI, the user changed their clock (by at least 6 hours) before the
warning was dismissed. This compares to 3.9% of the time when
Chrome showed a generic certificate warning for client clock errors.
We interpret this to mean that actionable errors are, in fact, more
helpful than generic security warnings.
10.1.2
Secure time. To improve client clock error detection, we
implemented a secure time service that Chrome queries when it
encounters a certificate date error. Upon encountering a certificate
with invalid dates, Chrome queries an update server for the current
time (an HTTP URL, with the response signed by the private key
corresponding to a public key baked into Chrome), and delays
showing a warning for up to three seconds. If the query returns
within three seconds and indicates a timestamp that is significantly
skewed from the local system clock, then Chrome shows the clock
warning from Figure 5.
An analysis of certificate reports from an experimental launch
shows that the secure time service improves detection of client clock
errors to 96%, with 93% of queries to the time service completing in
under three seconds. (Even if a query does not complete within three
seconds, the result — once eventually received — will be cached
Session F5:  Understanding Security FailsCCS’17, October 30-November 3, 2017, Dallas, TX, USA141610.2.1
Shipping known captive portals. Our analysis pipeline
produces a list of candidate captive portal certificates, which we
manually curate each week to produce a list of known captive
portals (Section 8.1). By shipping this list in Chrome and using it to
supplement captive portal detection, we would nearly double the
detection rate of certificate errors caused by captive portals. We
implemented this by putting the captive portal list in a dynamically
updateable Chrome component, so that additions to the list can
be shipped to clients on an ongoing basis (without being tied to
the release cycle). We launched this feature as an experiment on
Chrome’s canary and dev channels. Telemetry from this experiment
shows that 3.8% of name mismatch errors match a captive portal
certificate on the list, and we plan to expand the experiment.
10.2.2 Certificate report retry. We would like to retry report up-
loads, similar to Chrome’s telemetry system, to get better visibility
into captive portals. Retrying would allow us to receive reports
caused by captive portals even if the captive portal prevents them
from being sent until after the user authenticates with the portal.
We implemented report retries using the same logic that Chrome’s
telemetry system uses, though we maintain reports in memory
only and do not persist them to disk. The implementation is not yet
widely deployed enough to report results, but we hope to gain a
more accurate picture of certificate errors caused by captive portals.
It should also help us expand our list of known captive portals.
10.3 AIA fetching on Android
Insufficient intermediates are a large problem on Chrome for An-
droid, accounting for 36% of all certificate warnings on Android.
This happens because the platform does not fetch intermediates as
other platforms do during certificate validation.
To work around this, we implemented AIA fetching in Chrome
for Android. When the platform certificate verifier returns an au-
thority invalid error, Chrome looks at the last certificate for which
there is no issuer in the server-sent chain. If this certificate has
an AIA URL, Chrome fetches it and again attempts a platform cer-
tificate verification. If it again fails, Chrome repeats the process,
until a valid certificate chain has been found or until exhausting a
maximum number of fetches.
AIA fetching is implemented in Chrome 58. Since this feature
launched, the percentage of certificate errors caused by missing
intermediates on Android has steadily declined to 3.0% as of August
2017. The remaining errors are likely due to network flakiness,
which could potentially be improved by retrying failed AIA fetches.
Future work. If the Android certificate verifier directly
supported AIA fetching, then it would likely be more performant
than implementing it in Chrome. Android support for AIA fetching
would also benefit other Android applications besides Chrome.
However, Android update cycles are much slower than Chrome’s,
so Chrome on Android is likely to need to support AIA fetching
for the foreseeable future.
10.3.1
10.4 Redirecting for related name mismatches
Name mismatch errors account for a notable fraction of errors. We
would like for the browser to handle this class of error automatically.
The core idea is to redirect the user to the domain with a valid
Figure 6: The warning that Chrome shows when it detects
that a certificate error is caused by a captive portal.
for use if subsequent certificate date errors are encountered.) The
secure time feature launched to Chrome stable in May 2017.
10.1.3
Future work. We would ultimately like to invisibly cor-
rect client clock errors. To do this, Chrome would need to use the
timestamp fetched from the secure time service for all certificate
validations. This would stop the errors without needing any error
UI. However, the challenges in doing so are twofold:
(1) Chrome relies on the platform’s certificate validation library.
On some platforms, it is not possible to provide a time other
than the system time as input to certificate validation. Using
a timestamp from the secure time service would require
Chrome to implement its own certificate validation.
(2) Even though Chrome could invisibly correct the misconfigu-
ration by using the timestamp fetched from the secure time
service for certificate validation, it might still be desirable
to alert the user to the problem so that they can fix the sys-
tem clock. Other applications on the user’s device might
be functioning incorrectly because of the incorrect system
time. We might want to devise some way to prompt the user
to fix their system clock without interrupting their normal
browsing as the clock error UI currently does.
Another area of future work is to reduce trust in Chrome’s update
server. Instead of using an update server as the secure time service,
Chrome could implement a protocol such as Roughtime [3] for
secure decentralized time synchronization.
10.2 Captive portal detection
Chrome sends network probes to attempt to detect captive portals.