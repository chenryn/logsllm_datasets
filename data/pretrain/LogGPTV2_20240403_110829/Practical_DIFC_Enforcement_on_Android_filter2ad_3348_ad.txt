gal with respect to the policy for the security classes in-
volved in the change, as described in Section 2.3. For
example, to read secret data labeled with label {L1}, a
component instance may raise its label to {L1}, if it has
authorization (e.g., a capability) from the owner of {L1}
(see Section 5.1 for the policy syntax). We now describe
the problem caused by explicit label changes.
Problem of explicit label change: A component in-
stance may establish Binder connections with other in-
stances through the Activity Manager, and then use direct
Binder RPC. When an instance changes its label, its ex-
isting Binder RPC connections (established via indirect
communication, see Section 2.4) may be affected. That
is, its new label may be higher or lower relative to the
instances it is connected to. Hence, it may not be able to
send or receive data on existing connections due to the
strict DIFC check on Binder transactions. An explicit
label change may also make the component instance’s
context inconsistent with its attached storage layer. At
the same time, explicit label changes are unavoidable in
applications that use Weir.
Our solution: Weir provides applications with the in-
tent labeling mechanism, i.e., components can label calls
(i.e., intent messages), before they are sent to the Activ-
ity Manager service, ensuring that the target component
is instantiated with the label set on the intent. In fact, a
component may instantiate itself with the desired secrecy
label by specifying itself as the intent’s target. Intent la-
beling eliminates the need for explicit label changes.
Security of Intent Labeling: Weir does not blindly trust
the label set on the intent, as applications may otherwise
abuse the mechanism for unauthorized declassiﬁcation.
For example, a malicious component with the label {L1}
may add secret data to an intent, and set an empty la-
bel (i.e., {}) on the intent before calling itself with it.
To account for such malicious use cases, Weir checks if
the calling application would be authorized to explicitly
change its current label to the label on the intent, as per
the policy (see Section 5.1). A call with a labeled intent
may proceed only if the caller passes the check.
While we have not encountered use cases that can-
not be expressed using intent labeling, our implemen-
tation allows explicit label changes, mainly for expert
developers who may want to make temporary changes
to their instance labels. Explicit label changes must be
used with caution, as our design does not account for
the problems due to label change after instantiation (e.g.,
dropped Binder calls), since labels do not ﬂoat to existing
Binder connections and ﬁles to prevent label explosion
(explained in Section 3).
4.5 Domain Declassiﬁcation
Problems with traditional network declassiﬁcation are
rooted in the decision to declare trust in the exporting
subject, as discussed in Section 3. More precisely, in an
internet-driven environment, it may be more practical for
the data secrecy enforcement to reason about where the
data is being delivered, rather than who is performing the
export. Weir introduces the alternative of domain declas-
siﬁcation to allow data owners to articulate trust in terms
of the receiver, i.e., the target Web domain. Weir allows
the data owner to associate a set of network domains (tD)
with its security class (t). When the data in context {t}
is to be exported to the network, Weir’s enforcement im-
plicitly declassiﬁes t, if the destination domain is in tD.
The data owner is neither required to explicitly declassify
nor trust the exporting application.
In Section 8, we discuss an example where the en-
terprise only wants data to be exported to a set of en-
terprise domains, irrespective of the application export-
ing it. Such a policy allows the user to use the same
email application for both the personal and work ac-
count, but prevents accidental export of work data to the
personal SMTP server. Domain declassiﬁcation not only
addresses the goal of practical declassiﬁcation in a net-
work driven environment (G4), but also prevents the user
from accidentally exporting data from a trusted applica-
tion, but to an untrusted server.
Weir is not
the ﬁrst IFC system to use domains
for declassiﬁcation, although most prior systems to
do so consider domains as security principals (e.g.,
COWL [41], Bauer et al. [5]). For instance, COWL con-
ﬁnes JavaScript using a declassiﬁcation policy analogous
to the well-known same origin policy (SOP), i.e., code
executes in the context of its origin, and hence possesses
the declassiﬁcation privilege for export to the origin’s
Web domain. In this case, the origin Web domain is a
ﬁrst class security principal, as it has physical presence
on the device in the form of the code running in its con-
text. Thus, in COWL, the declassiﬁcation privilege is
still expressed in terms of the security principal that is
sending the data (i.e., the origin). On Android, there is
USENIX Association  
25th USENIX Security Symposium  1127
no direct correlation between Web domains and appli-
cations; i.e., Web domains do not have code executing
in their context on the device, and hence are not secu-
rity principals. Thus, Weir’s approach of expressing trust
in the receiver of the data (i.e., the Web domain) rather
than the sender is indeed unique among OS-level DIFC
systems where Web domains may not be security prin-
cipals [1, 21, 28, 49]. Hails [15], an IFC web framework
for user privacy, may be closer to Weir’s approach, as it
allows users to declassify their data for speciﬁc domains.
Hails users are prompted to explicitly declassify when
network requests to disallowed domains are ﬁrst made,
which may not be feasible on Android (see Section 3).
Weir’s enforcement is limited to the device, and may
not defeat an adversary controlling the network. While
we leave this aspect relaxed for our threat model, we note
that DNSSEC or IPsec could be used in such scenarios.
Implementation
5
We implemented Weir on Android v5.0.1, and the An-
droid Kernel v3.4. This section describes the essential
aspects of our implementation. The source code can be
found at http://wspr.csc.ncsu.edu/weir/.
5.1 Weir’s DIFC Policy
Weir derives its policy structure from the Flume DIFC
model [21], which consists of tags and labels. A data
owner (O) application deﬁnes a security class for its sen-
sitive data in the form of a secrecy tag (t). A set of tags
forms a secrecy label (S). Weir enforces the IFC secrecy
guarantee, i.e., “no read up, no write down” [6]. Informa-
tion can ﬂow from one label to another only if the latter
dominates, i.e., is a superset of the former. For instance,
data can ﬂow from a process P to a process Q if and only
if SP ✓ SQ. Weir applies this strict DIFC check to direct
Binder communication and ﬁle accesses.
Each tag t has associated capabilities, namely t+ (for
reading) and t− (for declassiﬁcation), which data owners
delegate to speciﬁc apps, or all other apps (i.e., the global
capability set G). At any point of time, a process P has
an effective capability set composed of the capabilities
delegated to its application (CP), and the capabilities in
+ by adding a tag t if
G. P can change its label SP to SP
and only if t+ 2 CP[G. Similarly, P can change its label
SP to SP− by removing a tag t if and only if t− 2 CP [ G.
As the network interface is untrusted, it has an empty
label, i.e. SN = {}. Thus, a process P must have an
empty label (i.e., SP = {}), or the ability to change its
label to SP = {} to create a network connection, i.e.,
8t 2 SP,t− 2 CPtG. Additionally, Weir extends Flume’s
syntax with the domain declassiﬁcation capability tD,
which is a set of trusted Web domains for tag t speci-
ﬁed by the owner O. For a network export to a domain
d 2 tD, t is implicitly declassiﬁed.
5.2 Component Polyinstantiation
When a component calls (i.e., sends an intent message
or queries a content provider), the Activity Manager
resolves the target component to be called using the
static information present in the application manifest.
Weir does not interfere with this intent resolution pro-
cess. Then, the Activity Manager chooses the actual
runtime instance of the resolved component, which is
where Weir’s polyinstantiation takes effect. That is, Weir
controls component instantiation, without modifying the
components themselves. Hence, Weir is compatible with
all developer manifest options, except ones that control
instantiation. Section 7.2 provides a compatibility eval-
uation for such options. For a detailed explanation on
Android’s component startup workﬂow and Weir’s com-
ponent instantiation logic, see Appendix A.
5.3 File-system Layering
We chose OverlayFS [29] over alternatives (e.g., aufs),
as it is in the Linux kernel (since v3.18). As the cur-
rent OverlayFS patch is incompatible with SELinux, we
set SELinux to monitoring mode. This is a tempo-
rary limitation, as OverlayFS developers are working to-
wards full integration [45], which is on SELinux’s Ker-
nel ToDo list as well [10]. Additionally, we could use a
ﬁne-grained block-level copy-on-write ﬁle system (e.g.,
BTRFS [32]). There are advantages to using such ﬁle
systems, as we describe in the trade-offs (Section 9).
Note that while we could get the Android Linux ker-
nel to compile with BTRFS, the build system support
tools that are required to build Android’s sparse-images
for BTRFS (e.g., ext4 utils for ext4) are missing.
Therefore, our prototype opts for OverlayFS, as it does
not require user-space support.
5.4 Process Initialization
On Android, the zygote process forks and prepares new
processes for applications. When a new process is
forked, Weir sets its secrecy label in the kernel, and uses
zygote to mount the appropriate storage layer to the pro-
cess’s mount namespace based on its label. If the pro-
cess has a non-empty label, Weir separates the process’s
mount namespace from the global mount namespace us-
ing the unshare system call, and mounts the appropriate
OverlayFS copy-on-write layer based on the label on top
of the unlabeled ﬁle system. New layers are allocated
when new labels are ﬁrst encountered. Weir maintains
the mapping between a label, its assigned layer and the
speciﬁc copy-on-write directories used for it.
5.5 Kernel Enforcement
Weir uses a Linux security module (LSM) to track the
security contexts of processes and ﬁles in the kernel. We
1128  25th USENIX Security Symposium 
USENIX Association
P
01
{L1}
Q1
{}
Q2
{}
Q
{}
P
01
{L1}
Q1
{L1}
0
Q2
{}
Q
{}
P
01
{L1}
Q1
{L1}
Q2
{}
1
Q
01
{}
(a) Initial State.
(b) P calls Q1
(c) Q2 calls Q
Figure 5: Floating label DIFC system: Q receives 1 and
guesses 0 for every reply not received.
integrated the multi-LSM patch [35] to enable concur-
rent SELinux and Weir enforcement. The security con-
text of a process contains its secrecy label and capabil-
ities, while that of a ﬁle only contains a secrecy label.
We now describe the enforcement for ﬁle access, Binder
communication and network access, as follows:
1. Files: Weir uses the ﬁle permission LSM hook to me-
diate each ﬁle read and write access. The secrecy label
of a ﬁle (stored in the xattrs) is initialized from the label
of the process that ﬁrst writes it.
2. Binder: Weir mediates Binder transactions in the ker-
nel using the Binder LSM hooks. For compatibility, Weir
whitelists Binder communication with Android system
services in the kernel. To prevent apps from misusing
whitelisted services as implicit data channels, we manu-
ally analyzed all system service API, and modiﬁed API
that may be misused, e.g., the Clipboard Manager service
provides label-speciﬁc clipboards in Weir.
3. Network: Weir mediates the socket connect and bind
operations in the kernel. The tags in the calling process’s
label that cannot be declassiﬁed using its capability set
are sent to Weir’s system service in the userspace via
a synchronous upcall, along with the IP address of the
destination server. Weir’s system service then resolves
the domain name from the IP address, which is challeng-
ing, as a reverse DNS lookup may not always resolve to
the same domain used in the initial request. Fortunately,
Android proxies all DNS lookups from applications to
a separate system daemon. We modify the daemon to
notify Weir when a process performs a DNS lookup, in-
cluding the domain name and the IP address returned.
During the domain declassiﬁcation upcall, this mapping
is referenced to identify the destination domain. Weir al-
lows the connection only if all the tags in the upcall can
be declassiﬁed for that domain.
6 Security of Polyinstantiation
Floating labels were ﬁrst predicted to be prone to infor-
mation leaks by Denning [8]. While language-level ﬂoat-
ing label IFC models (e.g., COWL [41] and LIO [40,42])
can mitigate such leaks, securely using ﬂoating labels is
0
P
01
{L1}
Q1
{L1}
Q1
{}
Q2
{}
Q
{}
P
01
{L1}
Q1
{L1}
Q1
{}
Q2
{}
1
1
Q
11
{}
(a) Q1 is polyinstanti-
ated
Figure 6: Weir: Q always receives data “11”
(b) Unlabeled Q1 and
Q2 send 1 to Q.
still a challenge for OS-level DIFC systems (e.g., IX [23]
and Asbestos [44]). We discuss an attack on an OS-
level ﬂoating label DIFC system, described in Krohn and
Tromer’s paper on the non-interference of Flume [20],
and show how Weir is resistant to such data leaks. We
use Android’s terminology to describe the attack.
We describe the attack twice; once in a ﬂoating label
system without polyinstantiation (Figure 5) and once in
Weir (Figure 6). Figure 5a shows the malicious compo-