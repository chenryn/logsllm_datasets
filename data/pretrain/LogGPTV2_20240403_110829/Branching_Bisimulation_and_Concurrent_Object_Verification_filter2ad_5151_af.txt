for verifying linearizability. Most are based on rely-guarantee
reasoning [20], [30], [31], [41], or establishing simulation rela-
tions [4], [5], [27]. These techniques often involve identifying
linearization points which is a manual non-trivial task. For
example, Liang et al. [20] propose a program logic tailored to
rely-guarantee reasoning to verify complex algorithms. This
276
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:24:37 UTC from IEEE Xplore.  Restrictions apply. 
























	






	







	















           MS lock-free Queue
           DGLM Queue
           HW Queue








Lazy List
Optimistic List
FGS List
HM List

























Treiber Stack
Treiber Stack + HP 
RDCSS
CCAS





Fig. 10. State-space reduction using ≈-quotienting.
method is applicable to a wide range of popular non-blocking
algorithms but is restricted to certain types of linearization
points. Challenging algorithms such as [6], [18] fall outside
this method. Our techniques do not require identifying lin-
earization points, and take the ﬁrst step to exploit divergence
stuttering/branching bisimulation equivalences [32], [38] from
concurrency theory to verify concurrent objects (The idea was
ﬁrst proposed in 2014 [39]). As we have shown, for ﬁnite-state
systems, off-the-shelf model checkers can be readily exploited.
This also provides a mechanism for ﬁnding concurrency bugs,
i.e., violations of linearizability and lock-freedom. Although
automated veriﬁcation is not complete, concurrency bugs can
be found by treating two to four threads.
Model checking methods to verify linearizability have been
proposed in e.g., [2], [3], [23], [36]. Liu et al. [23] formalize
linearizability as trace reﬁnement and use partial-order and
277
symmetry reduction techniques to alleviate the state explosion
problem. Their experiments are limited to simple concurrent
data structures such as counters and registers, and the relation
they proposed is not applicable to checking divergence. Our
work has modeled and veriﬁed various practical algorithms,
and can verify both the linearizability and lock-freedom efﬁ-
ciently. Cerny et al. [3] propose method automata to verify lin-
earizability of concurrent linked-list implementations, which
is restricted to two concurrent threads. An experience report
with the model checker SPIN [36] introduces an automated
procedure for verifying linearizability, but the method relies
on manually annotated linearization points. Some other work
(e.g., [2], [42]) employs the stateless model checking method
to verify concurrent programs. In particular, [2] presents the
automated linearizability checker Line-Up based on the model
checker CHESS. Our work uses the branching bisimulation
techniques and can capture the effect of certain intricate exe-
cutions (e.g., LP) of ﬁne-grained concurrent programs (where
the linear-time is not sufﬁcient). To the best of our knowledge,
all existing algorithms (e.g., [14]) need the entire state space
in order to carry out branching bisimulation minimization.
For the veriﬁcation of progress properties, work [12], [21],
[22] recently propose reﬁnement techniques with termination
preservation, which can well distinguish divergence from ﬁnite
traces. However, since reﬁnement notions concern the preﬁx-
closed set of traces, for systems that involve neither divergence
nor return actions, reﬁnement-based notions are hard to pre-
cisely preserve progress properties. In contrast, the theoretical
result of using the notion of divergence-sensitive branching
bisimulation can check a large class of progress properties
that are expressible in CTL∗ (containing LTL) without next. In
practice, our experiments can treat 11 non-blocking algorithms
(ﬁnite instances) and found a lock-freedom violation in the
revised stack [10]. Some formulations of progress properties
using next-free LTL are discussed in [26], [8].
IX. CONCLUSION
In this paper, we exploit branching bisimulation, denoted
by (≈) — a well-established notion in the ﬁeld of con-
currency theory — for proving linearizability and progress
properties of concurrent data structures. A concurrent object
Δ is linearizable w.r.t. a linearizable speciﬁcation Θsp iff their
quotients under ≈ are in a trace reﬁnement relation. Unlike
competitive techniques, this result is independent of the type
of linearization points. If the abstract and concrete object are
divergence-sensitive branching bisimilar, then progress prop-
erties of the — typically much smaller and simpler — abstract
object carry over to the concrete object. This entails that lock-
freedom (in fact all progress properties that can be expressed
in the next-free fragment of CTL∗) can be checked on the
abstract program. Our approaches can be fully automated for
ﬁnite-state systems. We have conducted experiments on 14
popular concurrent data structures yielding promising results.
In particular, the fact that counterexamples can be obtained
in an automated manner is believed to be a useful asset.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:24:37 UTC from IEEE Xplore.  Restrictions apply. 
Our experiments conﬁrmed a known linearizability bug and
revealed a new lock-free property violation.
In addition, due to the precision of branching bisimulation
in characterizing state equivalence of object systems, it has
the potential to analyze complex non-blocking executions. We
have shown that MS lock-free queue can be easily analyzed by
this equivalence notion. In the future, we will investigate the
further results on analysis of concurrent data structures using
branching bisimulation.
ACKNOWLEDGMENT
This research was proposed and done while the ﬁrst author
was at RWTH Aachen University (2013-2015) and supported
by the Alexander von Humboldt Foundation. This work was
also funded in part by the CDZ project CAP (GZ1023) and
NSFC under grant 61100063.
We would like to thank the CONVECS team for the support
in CADP, Qiaowen Jia for revising the model of the HSY
stack, and anonymous referees for their helpful suggestions
on earlier versions of this paper. The ﬁrst author also thanks
Hongfei Fu for his feedback on an earlier version of this work
and Wendelin Serwe for his help during the experiments.
REFERENCES
[1] Christel Baier and Joost-Pieter Katoen. Principles of Model Checking.
MIT Press, 2008.
[2] Sebastian Burckhardt, Chris Dern, Madanlal Musuvathi, and Roy Tan.
Line-up: A Complete and Automatic Linearizability Checker. In PLDI
2010, pages 330–340. ACM, 2010.
[3] Pavol Cern´y, Arjun Radhakrishna, Damien Zufferey, Swarat Chaudhuri,
and Rajeev Alur. Model Checking of Linearizability of Concurrent
List Implementations. In CAV 2010, LNCS vol.6174, pages 465–479.
Springer, 2010.
[4] Robert Colvin, Lindsay Groves, Victor Luchangco, and Mark Moir.
Formal Veriﬁcation of a Lazy Concurrent List-Based Set Algorithm.
In CAV 2006, LNCS vol.4144, pages 475–488. Springer, 2006.
[5] John Derrick, Gerhard Schellhorn, and Heike Wehrheim. Verifying
Linearisability with Potential Linearisation Points. In FM 2011, LNCS
vol.6664, pages 323–337. Springer, 2011.
[6] Mike Dodds, Andreas Haas, and Christoph M. Kirsch. A scalable,
correct time-stamped stack. In POPL 2015, pages 233–246, 2015.
[7] Simon Doherty, Lindsay Groves, Victor Luchangco, and Mark Moir.
In
Formal Veriﬁcation of a Practical Lock-Free Queue Algorithm.
FORTE 2004, LNCS vol.3235, pages 97–114. Springer, 2004.
[8] Brijesh Dongol.
Formalising Progress Properties of Non-Blocking
Programs. In ICFEM 2006, LNCS vol.4260: 284–303. Springer, 2006.
[9] Ivana Filipovic, Peter W. O’Hearn, Noam Rinetzky, and Hongseok
Yang. Abstraction for Concurrent Objects. Theor. Comput. Sci., 411(51-
52):4379–4398, 2010.
[10] Ming Fu, Yong Li, Xinyu Feng, Zhong Shao, and Yu Zhang. Reasoning
about Optimistic Concurrency Using a Program Logic for History. In
CONCUR 2010, LNCS vol.6269, pages 388–402. Springer, 2010.
[11] Hubert Garavel, Fr´ed´eric Lang, Radu Mateescu, and Wendelin Serwe.
CADP 2011: a toolbox for the construction and analysis of distributed
processes. In STTT, 15(2):89–107, 2013.
[12] Alexey Gotsman and Hongseok Yang. Liveness-Preserving Atomicity
Abstraction. In ICALP 2011, LNCS vol.6756: 453–465. Springer, 2011.
[13] Jan Friso Groote and Frits W. Vaandrager. An Efﬁcient Algorithm for
In ICALP 1990,
Branching Bisimulation and Stuttering Equivalence.
LNCS vol.443, pages 626–638. Springer, 1990.
[14] Jan Friso Groote, David N. Jansen, Jeroen J. A. Keiren and Anton
J.Wijs. An O(m\log n) Algorithm for Computing Stuttering Equivalence
and Branching Bisimulation. ACM Trans. on Computational Logic. Vol.
18(2), article No. 13. 2017.
[15] Timothy L. Harris, Keir Fraser, and Ian A. Pratt. A Practical Multi-
Word Compare-and-Swap Operation. In DISC 2002, LNCS vol.2508,
pages 265–279. Springer, 2002.
[16] Steve Heller, Maurice Herlihy, Victor Luchangco, Mark Moir, William
N. Scherer III, and Nir Shavit. A Lazy Concurrent List-Based Set
Algorithm. Parallel Processing Letters, 17(4):411–424, 2007.
[17] Maurice Herlihy and Nir Shavit. The Art of Multiprocessor Program-
ming. Morgan Kaufmann, 2008.
[18] Maurice Herlihy and Jeannette M. Wing. Linearizability: A Correctness
Condition for Concurrent Objects. ACM Trans. Program. Lang. Syst.,
12(3):463–492, 1990.
[19] Leslie Lamport. How to make a multiprocessor computer that correctly
In IEEE Trans. Comput., C-28,9,
executes multiprocessor programs.
690-691. 1979.
[20] Hongjin Liang and Xinyu Feng. Modular Veriﬁcation of Linearizability
In PLDI 2013, pages 459–470.
with Non-Fixed Linearization points.
ACM, 2013.
[21] Hongjin Liang, Xinyu Feng, and Zhong Shao. Compositional Veriﬁca-
tion of Termination-Preserving Reﬁnement of Concurrent Programs. In
CSL-LICS 2014, page 65. ACM, 2014.
[22] Hongjin Liang, Jan Hoffmann, Xinyu Feng, and Zhong Shao. Char-
acterizing Progress Properties of Concurrent Objects via Contextual
Reﬁnements.
In CONCUR 2013, LNCS vol.8052, pages 227–241.
Springer, 2013.
[23] Yang Liu, Wei Chen, Yanhong A. Liu, Jun Sun, Shao Jie Zhang, and
Jin Song Dong. Verifying Linearizability via Optimized Reﬁnement
Checking. IEEE Trans. Software Eng., 39(7):1018–1039, 2013.
[24] Maged M. Michael. Hazard Pointers: Safe Memory Reclamation for
Lock-Free Objects. IEEE Trans. Parallel Distrib. Syst., 15(6):491–504,
2004.
[25] Maged M. Michael and Michael L. Scott. Simple, Fast, and Practical
Non-Blocking and Blocking Concurrent Queue Algorithms. In PODC
1996, pages 267–275, 1996.
[26] Erez Petrank, Madanlal Musuvathi, and Bjarne Steensgaard. Progress
Guarantee for Parallel Programs via Bounded Lock-Freedom. In PLDI
2009, pages 144–154. ACM, 2009.
[27] Gerhard Schellhorn, Heike Wehrheim, and John Derrick. How to Prove
Algorithms Linearisable. In CAV 2012, pages 243–259, 2012.
[28] R.K. Treiber. Systems Programming: Coping with Parallelism. Research
Report RJ 5118. IBM Almaden Research Center, 1986.
[29] Aaron Joseph Turon, Jacob Thamsborg, Amal Ahmed, Lars Birkedal,
and Derek Dreyer. Logical Relations for Fine-Grained Concurrency. In
POPL 2013, pages 343–356. ACM, 2013.
[30] Viktor Vafeiadis. Modular Fine-Grained Concurrency Veriﬁcation. Tech-
nical Report UCAM-CL-TR-726, University of Cambridge, Computer
Laboratory, July 2008.
[31] Viktor Vafeiadis. Automatically Proving Linearizability. In CAV 2010,
LNCS vol.6174, pages 450–464. Springer, 2010.
[32] Rob J. van Glabbeek and W. P. Weijland. Branching Time and
Abstraction in Bisimulation Semantics. J. ACM, 43(3):555–600, 1996.
[33] Xiaoxiao Yang, Joost-Pieter Katoen, Huimin Lin and Hao Wu. Verify-
ing Concurrent Stacks by Divergence-Sensitive Bisimulation. Technical
Report at CoRR abs/1701.06104. 2017.
[34] Robin Milner. Communication and Concurrency. Prentice Hall, London,
England. 1989.
[35] Rocco De Nicola and Frits W. Vaandrager. Action versus State based
Logics for Transition Systems. In Proceedings of the LITP Spring School
on Theoretical Computer Science: Semantics of Systems of Concurrent
Processes, LNCS 469, pages 407-419. Springer, 1990.
[36] Martin T. Vechev, Eran Yahav, and Greta Yorsh. Experience with
Model Checking Linearizability. In SPIN 2009, LNCS vol.5578, pages
261 ˆA¨C278. Springer, 2009.
[37] Danny Hendler, Nir Shavit, and Lena Yerushalmi. A scalable lock-free
stack algorithm. In SPAA 2004, pages 206-215, ACM Press. 2004.
[38] K. S. Namjoshi. A Simple Characterization of Stuttering Bisimulation.
In FSTTCS 1997, LNCS vol.1346, pages 284–296. Springer, 1997.
[39] Xiaoxiao Yang and Joost-Pieter Katoen. Proving Linearizability and
Progress of Concurrent Objects by Bisimulation. Technical Report
ISCAS-SKLCS-14-16. Sep. 2014.
[40] Hao Wu, Xiaoxiao Yang and Joost-Pieter Katoen. Performance Evalu-
ation of Concurrent Data Structures. In SETTA 2016, LNCS vol.9984,
pages 38-49, Springer, 2016.
[41] Artem Khyzha, Mike Dodds, Alexey Gotsman and Matthew Parkinson.
Proving linearizability using partial orders. In ESOP 2017, LNCS 10201:
639-667. Springer, 2017.
[42] Jeff Huang. Stateless Model Checking Concurrent Programs with Max-
imal Causality Reduction. In PLDI’15, Vol. 50 (6): 165-174. 2015.
278
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:24:37 UTC from IEEE Xplore.  Restrictions apply.