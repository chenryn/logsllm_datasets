2
1
1
3
1
0
1
–
1
–
–
1
–
1
–
–
–
1
–
–
1
–
1
0
–
–
1
5
2
–
–
–
1
0
–
–
1
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
1
–
–
–
–
–
–
–
–
–
2
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
m29
m30
m31
m32
m33
m34
m35
m36
m37
m38
m39
m40
m41
m42
m43
m44
m45
m46
m47
m48
m49
m50
m51
m52
m53
m54
m55
m56
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
1
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
0
0
0
1
1
1
1
3
1
1
1
1
1
1
3
1
1
1
1
1
1
1
1
1
0
1
1
2
1
1
1
1
–
–
–
1
1
–
–
–
–
–
1
–
–
1
1
1
–
–
–
1
–
–
–
1
–
–
–
1
–
–
–
–
0
–
–
–
–
–
3
–
–
1
–
1
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
–
1
–
–
–
–
–
3
–
–
–
–
1
–
–
–
–
–
–
–
–
–
–
–
Figure 8: Malware Sample with Multiple Layers of Obfuscations
ms to scan each individual file. Another factor impacting perfor-
mance is that each file is converted into multiple files, each of which
need to be scanned by the underlying detection engine. With an
average of 4 files per malware sample, underlying engine scan times
can take from 40 to 480 ms, on average. The decloaking process
would then be adding 11% to 130% runtime overhead. However,
these times are only applicable for files that include dynamic code
generation. For memory space overhead, counterfactual execution
needs less than 200MB of memory.
6.4 Case Study
We dissect two real-world malware samples that Cubismo reveals
their hidden malicious code to show the effectiveness.
6.4.1 Exposing Multiple Layers of Malware. Fig. 8 shows a zero-
day malware sample with multiple obfuscation layers. Fig. 8-(b)
shows its first deobfuscated layer. Specifically, line 6 in Fig. 8-(a) is
deobfuscated to lines 15-22 in Fig. 8-(b). Note that from a single line,
multiple lines (i.e., lines 15-22) are generated. Then, Fig. 8-(c) repre-
sents another deobfuscated piece of code from Fig. 8-(b). Note that
while Fig. 8-(b) has multiple instances of dynamic constructs (e.g.,
eval()) on lines 16 and 21, only the eval() on line 21 is deobfus-
cated. This obfuscation occurs because eval() on line 16 depends
on an attacker provided input which cannot be resolved. Interest-
ingly, we observed a unique obfuscation technique on lines 41-43 in
Fig. 8-(c). When executed, the malware generates another eval()
function with base64_encoding. We omit the details about sub-
sequent obfuscation layers due to space constraints.
Analysis. We scanned each obfuscated program with VirusTotal
(VT). Note that submissions of the deobfuscated files are done in
parallel within a small time window (i.e., in a few seconds). The
deobfuscated program 1 (Fig. 8-(b)) is flagged as malware by one
tool called bkav [10], showing that resolving obfuscation layers via
Cubismo is effective in practice.
68,Q;';$kCxtOJOjkr= $uERCz('', '8ZfCK ==72-XE08...RA715eZ5M83fSbQ:O');$kCxtOJOjkr();@ini_restore('error_log');@ini_restore('display_errors'); ...4041424344454647484940414243444546(b) DeobfuscatedProgram 1(c) DeobfuscatedProgram 2…Cubismo: Decloaking Server-side Malware via Cubist Program Analysis
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
The deobfuscated program 2 (Fig. 8-(c)), however, is not detected
as malware due to the new code generated from the previous pro-
gram (Fig. 8-(b)), resulting in a different signature. Note that the
deobfuscated program 2 is not flagged while it includes malicious
code from the deobfuscated program 1 which was already detected as
malware. This result essentially shows that the detection accuracy
of the underlying tools is very sensitive to changes in the target
program, suggesting a fundamental limitation of signature based
techniques.
Malware detectors detect the following layers’ deobfuscated code
after the deobfuscated program 2 as malware. It also shows that
on each obfuscated layer, different malicious code and obfuscation
techniques can be used. As malware detectors may only recognize
some of those techniques, analyzing individual deobfuscated layer
independently can increase the chance to detect malware compared
to analyzing the last deobfuscated layer. Note that the deobfuscation
process may remove or alter the program itself. Hence, the last
deobfuscated file may not include all the malicious code.
6.4.2 Handling Variants of Existing Malware.
Fig. 9-(a) shows the one malware sample which has many poly-
morphic variants throughout the data set. The code decompresses a
string that represents a zip stream returned from the base64_decode
function on line 2. Then, the eval function on line 3 dynamically
runs the decompressed string. The size of the original malware
sample is 34 KB, and is simplified in the figure.
Note that an automated tool can easily be used to create the vari-
ants shown in Fig. 9-(b), (c), and (d). The variants are semantically
identical. Each variant has only two polymorphic differences: (1)
the value of $s_pass (lines 10, 20, and 30) which is essentially a
hashed password used by the malware, and (2) the means of split-
ting the string used in eval() (lines 11, 21, and 31). It is trivial
to create a new password hash and to split a string into multiple
substrings with different lengths, which are essentially the only
two changes used to automate this process.
Detecting Malware via Cubismo. Fig. 9-(e) shows the deobfus-
cated malware from the variants decloaked through Cubismo. The
malware contains HTML tags on lines 41-42 (in $buff) as well as
lines 45-48. The malware is a popular webshell called b374k [5],
which provides ssh-like access to the web server via a web interface.
We used VT to scan the original malware and 10 different vari-
ants generated in the same fashion as shown in Fig. 9-(b), (c), and
(d). Only one engine (bkav [10]) detected the original malware.
Consequently, none of the 60 malware detectors in VT were able
to detect any of the polymorphic variants, showing the effective-
ness effective of a simple polymorphic malware variant generation
technique. The deobfuscated result of the malware obtained via
Cubismo, Fig. 9-(e), is detected by 4 engines of VT (Avast [3],
AVG [4], Baidu [6], and bkav), showing Cubismo’s effectiveness in
detecting variants.
7 DISCUSSION
Signature Updates of AV Tools. Once we submit malware sam-
ples to VT, it is possible that AV engines obtain the samples and
analyze them to update their signatures. In fact, we have observed
such updates two weeks after our submission. As we used auto-
mated scripts to submit all samples, during our experiments no
such issues arose. After two weeks, we noticed that several samples
(m2, m17, m27, m33, m40, and m45) are now detected by VT in their
original state. Furthermore, m17, m27, and m50, which remained
undetected even after decloaking in the original experiments, were
still undetected. This result is most likely because the signatures