### Figure 8: Malware Sample with Multiple Layers of Obfuscation

#### Performance Impact
Scanning each individual file for malware can be time-consuming. Additionally, each file is converted into multiple files, which must all be scanned by the underlying detection engine. On average, a malware sample generates about four files, and the underlying engine scan times range from 40 to 480 milliseconds. The decloaking process adds an overhead of 11% to 130% to the runtime. However, these times are only applicable for files that include dynamic code generation. For memory space overhead, counterfactual execution requires less than 200MB of memory.

### 6.4 Case Study

We will dissect two real-world malware samples to demonstrate the effectiveness of Cubismo in revealing hidden malicious code.

#### 6.4.1 Exposing Multiple Layers of Malware

**Figure 8** illustrates a zero-day malware sample with multiple obfuscation layers. **Figure 8-(b)** shows the first deobfuscated layer. Specifically, line 6 in **Figure 8-(a)** is deobfuscated into lines 15-22 in **Figure 8-(b)**. Note that a single line can generate multiple lines (lines 15-22). **Figure 8-(c)** represents another deobfuscated piece of code from **Figure 8-(b)**. While **Figure 8-(b)** contains multiple instances of dynamic constructs (e.g., `eval()`) on lines 16 and 21, only the `eval()` on line 21 is deobfuscated. This is because the `eval()` on line 16 depends on an attacker-provided input, which cannot be resolved. Interestingly, we observed a unique obfuscation technique on lines 41-43 in **Figure 8-(c)**, where the malware generates another `eval()` function with base64 encoding. Due to space constraints, we omit the details of subsequent obfuscation layers.

**Analysis:**
We scanned each obfuscated program using VirusTotal (VT). The deobfuscated program 1 (**Figure 8-(b)**) was flagged as malware by one tool, bkav [10], demonstrating the effectiveness of resolving obfuscation layers via Cubismo.

The deobfuscated program 2 (**Figure 8-(c)**), however, was not detected as malware due to the new code generated from the previous program (**Figure 8-(b)**), resulting in a different signature. This indicates that the detection accuracy of the underlying tools is highly sensitive to changes in the target program, highlighting a fundamental limitation of signature-based techniques.

Subsequent deobfuscated layers were detected as malware, showing that different malicious code and obfuscation techniques can be used at each layer. Analyzing individual deobfuscated layers independently can increase the chance of detecting malware compared to analyzing only the final deobfuscated layer. The deobfuscation process may remove or alter the program, so the last deobfuscated file may not include all the malicious code.

#### 6.4.2 Handling Variants of Existing Malware

**Figure 9-(a)** shows a malware sample with many polymorphic variants. The code decompresses a string that represents a zip stream returned from the `base64_decode` function on line 2. The `eval` function on line 3 then dynamically runs the decompressed string. The original malware sample is 34 KB in size and is simplified in the figure.

Automated tools can easily create the variants shown in **Figures 9-(b), (c), and (d)**. These variants are semantically identical, with only two polymorphic differences: (1) the value of `$s_pass` (lines 10, 20, and 30), which is a hashed password used by the malware, and (2) the method of splitting the string used in `eval()` (lines 11, 21, and 31). It is trivial to create a new password hash and split a string into multiple substrings with different lengths, which are the only changes needed to automate this process.

**Detecting Malware via Cubismo:**
**Figure 9-(e)** shows the deobfuscated malware from the variants decloaked through Cubismo. The malware contains HTML tags on lines 41-42 (in `$buff`) and lines 45-48. The malware is a popular webshell called b374k [5], which provides SSH-like access to the web server via a web interface.

We used VT to scan the original malware and 10 different variants generated in the same fashion as shown in **Figures 9-(b), (c), and (d)**. Only one engine (bkav [10]) detected the original malware. None of the 60 malware detectors in VT were able to detect any of the polymorphic variants, demonstrating the effectiveness of simple polymorphic malware variant generation techniques. The deobfuscated result of the malware obtained via Cubismo, **Figure 9-(e)**, was detected by four engines of VT (Avast [3], AVG [4], Baidu [6], and bkav), showcasing Cubismoâ€™s effectiveness in detecting variants.

### 7. Discussion

**Signature Updates of AV Tools:**
Once malware samples are submitted to VT, it is possible that antivirus (AV) engines obtain the samples and analyze them to update their signatures. We observed such updates two weeks after our submission. During our experiments, no such issues arose because we used automated scripts to submit all samples. After two weeks, several samples (m2, m17, m27, m33, m40, and m45) were detected by VT in their original state. However, m17, m27, and m50, which remained undetected even after decloaking in the original experiments, were still undetected. This result is likely due to the signatures not being updated to cover these specific variants.