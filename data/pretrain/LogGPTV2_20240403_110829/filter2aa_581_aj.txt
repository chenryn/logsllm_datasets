#
When you run the preceding command for the first time, it will take a couple of 
minutes to execute and ends with a command prompt, where you can execute your 
OpenSSL commands to create the keys, which we used toward the end of the previous 
sections. The preceding docker run command starts OpenSSL in a Docker container, with 
a volume mount, which maps ch03/sample01 (or the current directory, which is indicated 
by $(pwd) in the preceding command) directory from the host file system to the /export 
directory of the container file system. This volume mount helps you to share part of the 
host file system with the container file system. When the OpenSSL container generates 
certificates, those are written to the /export directory of the container file system. Since 
Chapter 3  SeCuring apiS with tranSport Layer SeCurity (tLS)
79
we have a volume mount, everything inside the /export directory of the container file 
system is also accessible from the ch03/sample01 directory of the host file system.
To generate a private key and a public key for the cURL client, we use the following 
OpenSSL command.
# openssl genrsa -out /export/privkey.pem 4096
Now, to generate a self-signed certificate, corresponding to the preceding private key 
(privkey.pem), use the following OpenSSL command.
# openssl req -key /export/privkey.pem -new -x509 -sha256 -nodes -out 
client.crt -subj "/C=us/ST=ca/L=sjc/O=zee/OU=bar/CN=client"
 Summary
• 
Transport Layer Security (TLS) is fundamental in securing any API.
• 
Securing APIs with TLS is the most common form of protection we 
see in any API deployment.
• 
TLS protects data in transit for confidentiality and integrity, and 
mutual TLS (mTLS) protects your APIs from intruders by enforcing 
client authentication.
• 
OpenSSL is a commercial-grade toolkit and cryptographic library for 
TLS and available for multiple platforms.
Chapter 3  SeCuring apiS with tranSport Layer SeCurity (tLS)
81
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_4
CHAPTER 4
OAuth 2.0 Fundamentals
OAuth 2.0 is a major breakthrough in identity delegation. It has its roots in OAuth 1.0 
(see Appendix B), but OAuth Web Resource Authorization Profiles (see Appendix B) 
primarily influenced it. The main difference between OAuth 1.0 and 2.0 is that OAuth 1.0 
is a standard protocol for identity delegation, whereas OAuth 2.0 is a highly extensible 
authorization framework. OAuth 2.0 is already the de facto standard for securing APIs 
and is widely used by Facebook, Google, LinkedIn, Microsoft (MSN, Live), PayPal, 
Instagram, Foursquare, GitHub, Yammer, Meetup, and many more. There is one popular 
exception: Twitter still uses OAuth 1.0. 
 Understanding OAuth 2.0
OAuth 2.0 primarily solves the access delegation problem. Let’s say you want a third- 
party application to read your status messages on your Facebook wall. In other words, 
you want to delegate the third-party application the access to your Facebook wall. One 
way to do that is by sharing your Facebook credentials with the third-party application, 
so it can directly access your Facebook wall. This is called access delegation by credential 
sharing. Even though this solves the access delegation problem, once you share your 
Facebook credentials with the third-party application, it can use your credentials to do 
anything it wants, which in turns creates more problems! OAuth 2.0 solves this problem 
in a way you do not need to share your credentials with third-party applications, but 
only share a time-bound temporary token that is only good enough for a well-defined 
82
purpose. Figure 4-1 shows at a high level how access delegation works with OAuth 2.0, 
and the following explains each step in Figure 4-1:
 1. The user visits the third-party web application and wants to let the 
web application publish messages to his/her Facebook wall. To do 
that, the web application needs a token from Facebook, and to get 
the token, it redirects the user to Facebook.
 2. Facebook prompts the user to authenticate (if not authenticated 
already) and requests the consent from the user to give 
permissions to the third-party web application to publish 
messages to his/her Facebook wall.
 3. User authenticates and provides his/her consent to Facebook, so that 
Facebook can share a token with the third-party web application. 
This token is only good enough to publish messages to the Facebook 
wall for a limited period and cannot do anything else. For example, 
the third-party web application cannot send friend requests, delete 
status messages, upload photos, and so on with the token.
 4. The third-party web application gets a token from Facebook. 
To explain what exactly happens in this step, first we need to 
understand how OAuth 2.0 grant types work, and we discuss that 
later in the chapter.
 5. The third-party web application accesses the Facebook API with 
the token provided to it by Facebook in step 4. Facebook API 
makes sure only requests that come along with a valid token can 
access it. Then again later in the chapter, we will explain in detail 
what happens in this step.
Chapter 4  Oauth 2.0 Fundamentals
83
 OAuth 2.0 Actors
OAuth 2.0 introduces four actors in a typical OAuth flow. The following explains the role 
of each of them with respect to Figure 4-1:
 1. Resource owner: One who owns the resources. In our example 
earlier, the third- party web application wants to access the 
Facebook wall of a Facebook user via the Facebook API and 
publish messages on behalf of him/her. In that case, the Facebook 
user who owns the Facebook wall is the resource owner.
 2. Resource server: This is the place which hosts protected resources. 
In the preceding scenario, the server that hosts the Facebook API 
is the resource server, where Facebook API is the resource.
 3. Client: This is the application which wants to access a resource on 
behalf of the resource owner. In the preceding use case, the third-
party web application is the client.
Figure 4-1. OAuth 2.0 solves the access delegation problem by issuing a temporary 
time-bound token to a third-party web application that is only good enough for a  
well- defined purpose
Chapter 4  Oauth 2.0 Fundamentals
84
 4. Authorization server: This is the entity which acts as a security 
token service to issue OAuth 2.0 access tokens to client 
applications. In the preceding use case, Facebook itself acts as the 
authorization server.
 Grant Types
A grant type in OAuth 2.0 defines how a client can obtain an authorization grant from 
a resource owner to access a resource on his/her behalf. The origin of the word grant 
comes from the French word granter which carries the meaning consent to support. 
In other words, a grant type defines a well-defined process to get the consent from the 
resource owner to access a resource on his/her behalf for a well-defined purpose. In 
OAuth 2.0, this well-defined purpose is also called scope. Also you can interpret scope 
as a permission, or in other words, scope defines what actions the client application can 
do on a given resource. In Figure 4-1, the token issued from the Facebook authorization 
server is bound to a scope, where the client application can only use the token to post 
messages to the corresponding user’s Facebook wall.
The grant types in OAuth 2.0 are very similar to the OAuth profiles in WRAP (see 
Appendix B). The OAuth 2.0 core specification introduces four core grant types: the 
authorization code grant type, the implicit grant type, the resource owner password 
credentials grant type, and the client credentials grant type. Table 4-1 shows how OAuth 
2.0 grant types match with WRAP profiles.
Table 4-1. OAuth 2.0 Grant Types vs. OAuth WRAP Profiles
OAuth 2.0
OAuth WRAP
authorization code grant type
Web app profile/rich app profile
Implicit grant type
–
resource owner password credentials grant type
username and password profile
Client credentials grant type
Client account and password profile
Chapter 4  Oauth 2.0 Fundamentals
85
 Authorization Code Grant Type
The authorization code grant type in OAuth 2.0 is very similar to the Web App Profile 
in WRAP. It’s mostly recommended for applications—either web applications or native 
mobile applications—that have the capability to spin up a web browser (see Figure 4- 2).  
The resource owner who visits the client application initiates the authorization code 
grant type. The client application, which must be a registered application at the 
authorization server, as shown in step 1 in Figure 4-2, redirects the resource owner to 
the authorization server to get the approval. The following shows an HTTP request the 
client application generates while redirecting the user to the authorize endpoint of the 
authorization server: 
https://authz.example.com/oauth2/authorize?
                   response_type=code&
                   client_id=0rhQErXIX49svVYoXJGt0DWBuFca&
                   redirect_uri=https%3A%2F%2Fmycallback
The authorize endpoint is a well-known, published endpoint of an OAuth 2.0 
authorization server. The value of response_type parameter must be code. This 
indicates to the authorization server that the request is for an authorization code (under 
the authorization code grant type). client_id is an identifier for the client application. 
Once the client application is registered with the authorization server, the client gets 
a client_id and a client_secret. During the client registration phase, the client 
application must provide a URL under its control as the redirect_uri, and in the initial 
request, the value of the redirect_uri parameter should match with the one registered 
with the authorization server. We also call the redirect_uri the callback URL. The 
URL-encoded value of the callback URL is added to the request as the redirect_uri 
parameter. In addition to these parameters, a client application can also include the 
scope parameter. The value of the scope parameter is shown to the resource owner on 
the approval screen: it indicates to the authorization server the level of access the client 
needs on the target resource/API.
Chapter 4  Oauth 2.0 Fundamentals
86
In step 5 in Figure 4-2, the authorization server returns the requested code to the 
registered callback URL (also known as redirect_uri) of the client application. This 
code is called the authorization code. Each authorization code should have a lifetime.  
A lifetime longer than 1 minute isn’t recommended:
https://callback.example.com/?code=9142d4cad58c66d0a5edfad8952192
The value of the authorization code is delivered to the client application via an HTTP 
redirect and is visible to the resource owner. In the next step (step 6), the client must 
exchange the authorization code for an OAuth access token by talking to the OAuth 
token endpoint exposed by the authorization server.
Note the ultimate goal of any Oauth 2.0 grant type is to provide a token (which 
is known as access token) to the client application. the client application can 
use this token to access a resource. an access token is bound to the resource 
owner, client application, and one or more scopes. Given an access token, the 
authorization server knows who the corresponding resource owner and client 
application and also what the attached scopes are.
Figure 4-2. Authorization code grant type
Chapter 4  Oauth 2.0 Fundamentals
87
The token endpoint in most of the cases is a secured endpoint. The client application 
can generate the token request along with the corresponding client_id (0rhQErXIX49s 
vVYoXJGt0DWBuFca) and the client_secret (eYOFkL756W8usQaVNgCNkz9C2D0a), which 
will go in the HTTP Authorization header. In most of the cases, the token endpoint is 
secured with HTTP Basic authentication, but it is not a must. For stronger security, 
one may use mutual TLS as well, and if you are using the authorization code grant type 
from a single-page app or a mobile app, then you may not use any credentials at all. 
The following shows a sample request (step 6) to the token endpoint. The value of the 
grant_type parameter there must be the authorization_code, and the value of the code 
should be the one returned from the previous step (step 5). If the client application sent 
a value in the redirect_uri parameter in the previous request (step 1), then it must 
include the same value in the token request as well. In case the client application does 
not authenticate to the token endpoint, you need to send the corresponding client_id as 
a parameter in the HTTP body:
Note the authorization code returned from the authorization server acts as an 
intermediate code. this code is used to map the end user or resource owner to the 
Oauth client. the Oauth client may authenticate itself to the token endpoint of the 
authorization server. the authorization server should check whether the code is 
issued to the authenticated Oauth client prior to exchanging it for an access token.
\> curl -v –k -X POST --basic
     -u 0rhQErXIX49svVYoXJGt0DWBuFca:eYOFkL756W8usQaVNgCNkz9C2D0a
     -H "Content-Type:application/x-www-form-urlencoded;charset=UTF-8"
     -d "grant_type=authorization_code&
         code=9142d4cad58c66d0a5edfad8952192&
         redirect_uri=https://mycallback"
         https://authz.example.com/oauth2/token
Note the authorization code should be used only once by the client. If the 
authorization server detects that it’s been used more than once, it must revoke all 
the tokens issued for that particular authorization code.
Chapter 4  Oauth 2.0 Fundamentals
88
The preceding cURL command returns the following response from the 
authorization server (step 7). The token_type parameter in the response indicates the 
type of the token. (The section “OAuth 2.0 Token Types” talks more about token types.) 
In addition to the access token, the authorization server also returns a refresh token, 
which is optional. The refresh token can be used by the client application to obtain a new 
access token before the refresh token expires. The expires_in parameter indicates the 
lifetime of the access token in seconds.
{
      "token_type":"bearer",
      "expires_in":3600,
      "refresh_token":"22b157546b26c2d6c0165c4ef6b3f736",
      "access_token":"cac93e1d29e45bf6d84073dbfb460"
}
Note each refresh token has its own lifetime. Compared to the lifetime of the 
access token, the refresh token’s is longer: the lifetime of an access token is in 
minutes, whereas the lifetime of a refresh token is in days.
 Implicit Grant Type
The implicit grant type to acquire an access token is mostly used by JavaScript clients 
running in the web browser (see Figure 4-3). Even for JavaScript clients now, we do not 
recommend using implicit grant type, rather use authorization code grant type with no 
client authentication. This is mostly due to the inherent security issues in the implicit 
grant type, which we discuss in Chapter 14. The following discussion on implicit grant 
type will help you understand how it works, but never use it in a production deployment.
Chapter 4  Oauth 2.0 Fundamentals
89
Unlike the authorization code grant type, the implicit grant type doesn’t have any 
equivalent profiles in OAuth WRAP. The JavaScript client initiates the implicit grant flow 
by redirecting the user to the authorization server. The response_type parameter in the 
request indicates to the authorization server that the client expects a token, not a code. The 
implicit grant type doesn’t require the authorization server to authenticate the JavaScript 
client; it only has to send the client_id in the request. This is for logging and auditing 
purposes and also to find out the corresponding redirect_uri. The redirect_uri in the 
request is optional; if it’s present, it must match what is provided at the client registration: 
https://authz.example.com/oauth2/authorize?
                  response_type=token&
                  client_id=0rhQErXIX49svVYoXJGt0DWBuFca&
                  redirect_uri=https%3A%2F%2Fmycallback
This returns the following response. The implicit grant type sends the access token as 
a URI fragment and doesn’t provide any refreshing mechanism:
https://callback.example.com/#access_token=cac93e1d29e45bf6d84073dbfb460&ex
pires_in=3600
Unlike the authorization code grant type, the implicit grant type client receives 
the access token in the response to the grant request. When we have something in the 
URI fragment of a URL, the browser never sends it to the back end. It only stays on the 
browser. So when authorization server sends a redirect to the callback URL of the client 
Figure 4-3. Implicit grant type
Chapter 4  Oauth 2.0 Fundamentals
90
application, the request first comes to the browser, and the browser does an HTTP GET 
to the web server that hosts the client application. But in that HTTP GET, you will not 
find the URI fragment, and the web server will never see it. To process the access token 
that comes in the URI fragment, as a response to HTTP GET from the browser, the web 
server of the client application will return back an HTML page with a JavaScript, which 
knows how to extract the access_token from the URI fragment, which still remains in the 
browser address bar. In general this is how single-page applications work.
Note the authorization server must treat the authorization code, access token, 
refresh token, and client secret key as sensitive data. they should never be sent 
over http—the authorization server must use transport layer security (tls). 
these tokens should be stored securely, possibly by encrypting or hashing them.
 Resource Owner Password Credentials Grant Type
Under the resource owner password credentials grant type, the resource owner must 
trust the client application. This is equivalent to the Username and Password Profile in 
OAuth WRAP. The resource owner has to give his/her credentials directly to the client 
application (see Figure 4-4).
The following cURL command talks to the token endpoint of the authorization 
server, passing the resource owner’s username and password as parameters. In addition, 
Figure 4-4. Resource owner password credentials grant type
Chapter 4  Oauth 2.0 Fundamentals
91
the client application proves its identity. In most of the cases, the token endpoint is 
secured with HTTP Basic authentication (but not a must), and the client application 
passes its client_id (0rhQErXIX49svVYoXJGt0DWBuFca) and client_secret 
(eYOFkL756W8usQaVNgCNkz9C2D0a) in the HTTP Authorization header. The value of the 
grant_type parameter must be set to password:
\> curl -v -k -X POST --basic
     -u 0rhQErXIX49svVYoXJGt0DWBuFca:eYOFkL756W8usQaVNgCNkz9C2D0a
     -H "Content-Type:application/x-www-form-urlencoded;charset=UTF-8"
     -d "grant_type=password&
         username=admin&password=admin"
         https://authz.example.com/oauth2/token
This returns the following response, which includes an access token along with a 
refresh token:
{
      "token_type":"bearer",