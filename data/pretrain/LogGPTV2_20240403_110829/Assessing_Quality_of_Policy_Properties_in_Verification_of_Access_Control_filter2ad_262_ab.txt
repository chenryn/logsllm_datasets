original policy may exist. Such mutants and the original
policy produce the same policy decisions for all possible
requests. We leverage a change-impact analysis tool such
as Margrave [9] to detect equivalent mutants by comparing
the original policy and each mutant policy. Note that if a
Given a policy, a set of properties, and a set of mutant
policies, the next step is to determine which properties hold
and which properties do not hold for both the original policy
and each mutant policy as illustrated in Figure 4. We lever-
age Margrave [9] to perform property veriﬁcation. Mar-
grave represents XACML policies as multi-terminal binary
decision diagrams (MTBDDs). MTBDDs are a type of deci-
sion diagram that maps bit vectors over a set of variables to
a ﬁnite set of results. Margrave is implemented on top of the
CUDD package [20], which provides an efﬁcient implemen-
tation of MTBDDs. Margrave can verify various properties
(that are represented in Margrave’s speciﬁc format) against
a given policy. Property P ri in Section 2 can be converted
to Margrave’s speciﬁc format and veriﬁed whether P ri is
satisﬁed by the policy.
To perform property veriﬁcation on a policy using Mar-
grave, a Scheme program is written that leverages the Mar-
grave API. This program must load the policy, optionally
specify any environment constraints, and deﬁne the set of
properties that the policy must satisfy. In order to perform
property veriﬁcation programmatically for each mutant pol-
icy, we generate an executable script and Scheme program
for both the original policy and each mutant policy. We
speciﬁed and generated an EMF1 (Eclipse Modeling Frame-
work) model that encapsulates the necessary information
to generate the executable scripts and Scheme programs.
Given an instance of this EMF model, we use the Model To
Text (M2T2) framework and a set of Java Emitter Templates
1http://www.eclipse.org/modeling/emf/
2http://www.eclipse.org/modeling/m2t/
156166
(JET) to generate executable shell scripts and Scheme pro-
grams for each policy under test and its corresponding set
of mutants. The generated scripts pipe a generated Scheme
program to a command-line Scheme interpreter. The out-
put of the Scheme interpreter is then piped to a trace ﬁle for
further processing. These trace ﬁles contain the information
necessary for determining which properties hold and which
properties do not hold for the original policy and each mu-
tant policy.
4.3. Mutant-Killing Determination
The next step is to compute the mutant-killing ratio. The
mutant-killing ratio is the ratio of the number of mutants
killed to the total number of mutants. This ratio serves as
a metric to quantify the quality of a set of properties with
respect to covering a given policy. A higher mutant-killing
ratio indicates the property set interacts with or covers a
higher number of rules deﬁned in the policy.
The trace ﬁles generated by the property veriﬁcation de-
scribed earlier are parsed in order to divide the property set
into four subsets for each mutant. A property is either true
or false (i.e., the property is satisﬁed or is not satisﬁed) with
respect to a given policy. Let P denote the set of all proper-
ties. Let the set of properties satisﬁed by the original policy
be denoted by OT and let the set of properties not satisﬁed
by the original policy be denoted OF .
P = OT ∪ OF
(1)
Similarly, given a mutant policy M, let the set of properties
satisﬁed by the mutant policy be denoted by MT and the set
of properties not satisﬁed by the mutant policy be denoted
MF and by Equation 2 all properties fall into one of these
sets.
P = MT ∪ MF
(2)
For our case study described in Section 5, all properties are
intended to be satisﬁed by the original policy (i.e., holding
true). A property that holds true for both the original policy
and the mutant policy cannot expose the fault in the mutant
policy because the property does not apply to the portion of
the policy that contains the fault. On the other hand, if at
least one property holds true for the original policy but fails
to hold true for the mutant policy as formalized in Equa-
tion 3, then the mutant is killed.
∃p ∈ P : p ∈ OT ∩ MF
(3)
4.4. Property Generation
To increase property coverage and investigate property
veriﬁcation, we manually generate additional properties for
a given policy. A property P ri is elicited by considering a
157167
Table 1. Policies used in the case-study.
Subject
CONTINUE-A
CONTINUE-B
SIMPLE-POLICY
# Set
111
111
1
# Policy
266
266
2
# Rule
298
306
2
# Property
9
9
3
“living” CRE mutant. Each CRE mutant corresponds to a
speciﬁc policy rule. When a given rule changes effect (e.g.,
deny to permit), the corresponding property P ri may de-
tect a semantic change and by deﬁnition P ri kills the CRE
mutant. To elicit P ri, we manually inspect the rule’s con-
text. Let S, O, and A denote the set of subjects, objects,
and actions in a rule, respectively. A rule is in the form
[S∩O∩A → Ef f ect] where the effect is either P ermit or
Deny. If an effect is P ermit (Deny), we generate a prop-
erty that a subject S can (cannot) take an action A on re-
source O. For a mutant policy, when the effect is changed to
Deny (P ermit), the property may detect a semantic fault
in the mutated policy and cover the not-covered rule being
mutated.
5. Case Study
We have applied our mutation veriﬁcation tool to an ac-
cess control policy for CONTINUE [15]. CONTINUE is a
web-based conference management system that supports
the submission, review, discussion, and notiﬁcation phases
of conferences. The CONTINUE policy was used as a case
study to explore property veriﬁcation and change-impact
analysis for Margrave by Fisler et al. [9]. The conference
management system itself has been used to manage sev-
eral conferences. Table 1 lists the policies used in our case
study. Each row corresponds to a policy and Columns 2,
3, and 4 denote the number of POLICYSET, POLICY, and
RULE elements in each policy, respectively. Column 5 de-
notes the number of properties used for each policy. We
selected these policies in our case study because these poli-
cies are available with their formal properties. The SIM-
PLE policy was presented in Section 2 and CONTINUE-A
and CONTINUE-B are two versions of the CONTINUE pol-
icy. All three policies and property sets are available at the
Margrave web site3.
We divide the case study into two parts: the ﬁrst part per-
forms mutation veriﬁcation with the CRE mutation operator
for property assessment while the second part performs mu-
tation veriﬁcation with several mutation operators and the
additional manually speciﬁed properties for property aug-
mentation.
3http://www.cs.brown.edu/research/plt/software/
margrave/
Table 2. Mutant-killing ratios.
# mutants
298
306
2
Subject mutant-kill ratio
24.16%
24.84%
50.00%
CONTINUE-A
CONTINUE-B
SIMPLE-POLICY
# killed
72
76
1
5.1. Property Assessment
Table 2 shows the results of mutation veriﬁcation using
only the CRE mutation operator, speciﬁcally the number
of mutants (Column 3), number of killed mutants (Column
4), and the mutant-killing ratio (Column 2) for each pol-
icy. As discussed in Section 2, the SIMPLE policy has only
two rules and thus two mutant policies are generated with
the CRE mutation operator. One mutant is killed so the
2 or 50%. The complexity
mutant-killing ratio is simply 1
of the CONTINUE policies makes them far more interest-
ing. Each version of CONTINUE has approximately 300
rules and roughly 1
4 of the mutants generated from these
rules are killed. This result shows that a single property can
cover multiple rules (which can be inferred by comparing
the number of rules to the number of properties).
Figure 5. CONTINUE-A property failures for
each policy-property pair.
To further visualize and discuss the results, let each prop-
erty and each mutant be identiﬁed by an integer number.
For example, let the original policy be denoted P0, each
mutant policy be denoted P1, P2, . . . Pm, and each property
P r0, P r1, . . . P rp−1 where m and p are the number of mu-
tants and properties, respectively. A property-policy pair
(P rx, Py) is mapped to a point (x, y) in Figures 5 and 6.
A data point is plotted on the chart at (x, y) if the property
P rx fails to hold for Policy Py. Therefore, Figures 5 and 6
illustrate all property failures for each property-policy pair.
158168
Figure 6. CONTINUE-B property failures for
each policy-property pair.
More speciﬁcally, each integer value along the horizontal
axis denotes a single property and each integer value along
the vertical axis denotes a single policy. Furthermore, the
policy at y = 0 is the original (un-mutated) policy. These
scatter plots allow us to quickly determine which properties
interact with which rules in the policy.
Property P r0 fails to hold for the original version of
CONTINUE-A indicated by a data point at (P r0, P0) in Fig-
ure 5. As a result, P r0 also fails to hold for any mutant poli-
cies as indicated by the numerous data points along x = 0.
If a property fails to hold for the original policy, then the
property is not expected to (and most likely will not) hold
for any mutant policies. Furthermore, this property is not
capable of killing mutants because in order for a mutant to
be killed by a property, the property must be satisﬁed by
the original policy as described in Section 4. The natural
language for this property is as follows:
P r0 If the subject is a pc-member, it is not the discussion
phase, and unsubmitted for the review for a paper de-
spite being assigned it, then the subject cannot see all
parts of other’s reviews for that paper.
This property fails simply because CONTINUE-A is an ear-
lier version of the policy. All properties including P r0 do
hold for the revised version in Figure 6.
Another readily noticeable peculiarity of both Figures 5
and 6 is the absence of P r8. Recall that nine properties are
veriﬁed against each policy, implying one property, P r8,
does not appear to interact with any rule explicitly deﬁned in
the policy. The natural language for the “missing” property
is:
P r8 No legal request is mapped to Not Applicable, that is
every legal request is decided by either deny or permit.
P r8 is an excellent example of a valid property that is not
explicitly speciﬁed in the policy itself. A policy should cer-
tainly be written such that every legal request returns a deny
or permit response. This property, however, is a generic
property potentially applicable to a wide range of policies.
Although the property is quite relevant, it is not (and ar-
guably should not) be speciﬁed explicitly in the policy it-
self. An argument against its inclusion in the policy itself
is that the property is generic; in particular, it is unrelated
to the access control logic of the system but is rather one
of the best practices. This type of generic property is not
accounted for in this implementation of mutation veriﬁca-
tion. Further investigation is needed to determine how to
incorporate such properties. For instance, mutation opera-
tors that consider not only the policy but also the properties
may account for these types of properties.
The un-mutated CONTINUE-B (P0 in Figure 6) satisﬁes
all properties as indicated by the lack of data points along
P0 = y = 0. Again, P r8 (i.e., x = 8) is not plotted be-
cause this generic property does not interact directly with
any rules speciﬁed in the policy. Properties P r5 and P r7 are
interesting because they fail for only a single rule for both
CONTINUE-A and CONTINUE-B. The natural language for
these properties are:
P r5 If a subject is not a pc-chair or admin, then he/she may
not set the meeting ﬂag.
P r7 If someone is not a pc-chair or admin, then he/she
can never see paper-review-rc for which he/she is con-
ﬂicted.
By manual inspection, we determine that the mutant
killed by P r5 is the same for both versions of the pol-
icy. The killed mutant corresponds to the last rule in the
POLICYSET that speciﬁes access to the meeting ﬂag. More
speciﬁcally, once all permitted combinations of subjects and
actions are speciﬁed, the ﬁnal rule ensures all other requests
for the meeting ﬂag are denied. Because the mutant policy
changed this rule’s decision to permit, the mutant was killed
by P r5. In a similar fashion, the killed mutant for P r7 is
identical for both versions and corresponds to precisely the
rule that ensures the denial of requests for paper reviews
when the isConﬂicted ﬂag is set.
The CONTINUE policy heavily uses the ﬁrst-applicable
combining algorithm. As a result, it is often the case that,
for a given resource, all permitting rules are speciﬁed ﬁrst
followed by more general denying rules. When these types
of denying rules are mutated to permit, the policy leaks
sensitive information (i.e., access is granted when it should
not). A general property for ensuring that sensitive informa-
tion remains protected is effective at identifying these leaks.
For example, properties P r1 in Figure 5 and P r3 in Figure 6
are in fact the same property. This property interacts with a
large number of policy rules indicated by the large number
159169
of data points. This property in natural language states that
if the subject role attribute is empty and the resource class is
not conference info, then return deny. This property effec-
tively identiﬁes information leakage introduced through the
mechanism described earlier. This result indicates that this
property set is effective at identifying information leakage
in the policy.
On the other hand, the mutants that are not killed are
generally those that mutate a permitting rule to deny. For
example, when the rule that allows the admin to read
the pcMember-info-isChairFlag is switched from permit to
deny, no property identiﬁes the restricted access. Similar to
having general properties for ensuring that sensitive infor-
mation remains protected, one also wants to have properties
for ensuring access is granted when appropriate. The fact
that the un-killed mutants are generally of this type indicates
that the property set can be improved by adding properties
for ensuring that access is granted when appropriate.
5.2. Property Augmentation
The low mutant-killing ratios in Section 5.1 imply that
the existing property set can be improved by augmenting
the existing property set. Motivated by these mutation veri-
ﬁcation results, we manually generate properties to kill the
“living” CRE mutants. We do so by creating a property that
mirrors a not-covered rule. Because each mutant created
with the CRE mutation operator is associated with a single
rule in the policy, we can identify which rules in the policy
are not covered by the existing property set. After manu-
ally constructing these properties, we then perform muta-
tion veriﬁcation using various mutation operators to com-
pare the quality of the existing property sets with the aug-
mented property sets (i.e., the existing property set plus the
manually speciﬁed properties).
Unfortunately, the size of the CONTINUE policy makes
manually specifying properties impractical. As a result, for
this case study, we investigate the ﬁrst nine, commonly used
rules in the CONTINUE-A and CONTINUE-B policies. Fur-
thermore, because the difference between the CONTINUE-
A and CONTINUE-B policies is small and the rules that we
consider for manual property generation are identical, the
results are the same for both policies. For brevity, we refer
to the results of both policies simply as CONTINUE.
The manually generated properties are elicited by con-
sidering the “living” CRE mutants since each CRE mutant
corresponds to a single rule in the policy. Since the SIMPLE
policy has only one “living” mutant, only one additional
property is speciﬁed. Furthermore, the property mirrors the
policy rule. For example, the property “A student can write
grades” is generated based on the policy rule “A student is
permitted to write grades”.
Mutants
PSTT
PSTF
PTT
PTF
RTT
RTF
CPC
CRC
CRE
Total
# mutants
0
1
2
2
2
2
0
0
2
11
Table 3. Policy mutation and mutants killed by property sets.
CONTINUE
kill % # new kill
2
3
7
3
0
0
2
0
7
24
new kill % # mutants
2
6
7
9