进程是处理机活动的一个抽象概念。进程使“执行中的程序”这一概念在任何时候都是有意义的，而不论处理机在该时刻是否正在执行该程序的指令。这样，静态的程序和动态的进程便区分开了。
进程概念是20世纪60年代初期，首先由麻省理工学院的MULTICS系统和IBM公司的TSS/360系统引入的。其后，有许多人对进程下过各种定义。下面，仅列举几种比较能反映进程实质的定义。
①进程是这样的计算部分，它是可以和其他计算并行的一个计算。
②进程（有时称为任务）是一个程序与其数据一道通过处理机的执行所发生的活动。
③任务（或称进程）是由一个程序以及与它相关的状态信息（包括寄存器内容、存储区域和链接表）所组成的。
④所谓进程，就是一个程序在给定活动空间和初始环境下，在一个处理机上的执行过程。
根据1978年在庐山召开的全国操作系统会议上关于进程的讨论，结合国外的各种观点，国内对进程这一概念作了如下描述：
进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动。
上述这些对进程的解释从本质上讲是相同的，但各有侧重，这说明进程这一概念至今尚未形成公认的、严格的定义。但是，进程已广泛而成功地被用于许多系统中，成为构造操作系统不可缺少的强有力的工具。
进程和程序是既有联系又有区别的两个概念，它们的区别如下。
（1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态概念。而进程是程序在处理机上的一次执行过程，它是一动态概念。程序可以作为一种软件资料长期保存，而进程则是有一定生命期的，它能够动态地产生和消亡。即进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡。
（2）进程是一个能独立运行的单位，能与其他进程并行地活动。
（3）进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。
进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程一定包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干不同的数据集合上，它将属于若干个不同的进程。或者说，若干不同的进程可以包含相同的程序。这句话的意思是：用同一程序对不同的数据先后或同时加以处理，就对应于好几个进程。例如，系统具有一个C语言编译程序，当它对多个终端用户的C语言源程序进行编译时，就产生了多个编译进程。
读者稍加留心就可以看出：进程和前面提到的计算有相似之处，它们都是程序的动态执行过程，从这一点上讲它们是一样的。但是，由于用进程描述操作系统的内部活动比较准确、清晰，所以都用进程这一概念来设计操作系统。
 4.2.2 进程的类型
系统中同时存在许多进程，它们依性质不同可分为各种不同的类型。
有些进程起着资源管理和控制的作用，称为系统进程；而另一些是为用户算题任务而建立的进程称为用户进程。它们是有区别的。
①系统进程被分配一个初始的资源集合，这些资源可为它所独占，也可以最高优先级的资格优先使用。用户进程通过系统服务请求的手段竞争系统资源。
②用户进程不能做直接I/O操作，而系统进程可以做显示的、直接的I/O操作。
③系统进程在管态下活动，而用户进程在用户态下活动。
另外，进程还可以根据其活动特点来分类。有一类进程在其活动期间，大部分时间是进行计算工作，需要使用CPU，即这类进程的活动是受CPU时间限制的；而另一类进程的活动则受I/O限制，在其活动期间需要进行大量的输入／输出工作，即这类进程的大部分活动时间取决于外设的I/O时间。例如，科学计算任务往往要求较多的CPU时间，但I/O信息较少；而数据处理问题正好相反，要求较少的CPU时间，而要处理大量的I/O信息。
 4.2.3 进程的状态
1．进程的基本状态
前面已介绍过，进程有着“执行—暂停—执行”的活动规律。一般说来，一个进程并不是自始至终连续不停地运行的，它与并发执行中的其他进程的执行是相互制约的。它有时处于运行状态，有时又由于某种原因而暂停运行处于等待状态，当使它暂停的原因消失后，它又进入准备运行状态。所以，在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、等待状态（又称阻塞状态）。
①就绪状态（ready）。当进程获得了除CPU之外所有的资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行，该进程所处的状态为就绪状态。
②运行状态（running）。当进程由调度／分派模块分派后，得到中央处理机控制权，它的程序正在运行，该进程所处的状态为运行状态。
③等待状态（wait）。若一进程正在等待某一事件发生（如等待输入／输出操作的完成）而暂时停止执行，这时，即使给它CPU控制权，它也无法执行，则称该进程处于等待状态，又可称为阻塞状态。
对于一个实际的系统，在进程活动期间至少要区分出就绪、运行、等待这三种状态。原因是：如果系统能为每个进程提供一台处理机，则系统中所有进程都可以同时执行，但实际上处理机的数目总是少于进程数，因此，往往只有少数几个进程（在单处理机系统中，则只有一个进程）可真正获得处理机控制权。通常把那些获得处理机控制权的进程所处的状态称为运行状态；把那些希望获得处理机控制权，但因处理机数目太少而暂时分配不到处理机的进程所处的状态称为就绪状态。虽然所有进程并发执行，但它们之间并不完全独立，而是相互制约的，有的进程因某种原因暂时不能运行而处于等待状态。因此，在任何系统中，必须有这三种基本状态。当然，有的系统较为复杂，还可设置更多的进程状态，且对每一种状态还可进一步细分。例如，等待状态可能包含若干子状态，如主存等待、文件等待或设备等待等。这样细分和设置更多的状态需要增加相关模块的大小，增加系统的复杂性且常常要求大的系统开销。多数实时系统注意简化状态结构，以使调度和分派简单、高效。
2．进程状态变迁图
进程并非固定处于某个状态，它将随着自身的推进和外界条件的变化而发生变化。对于一个系统，可以用一张进程状态变迁图来说明系统中每个进程可能具备的状态，以及这些状态之间变迁的可能原因。在进程状态变迁图中，以结点表示进程的状态，以箭头表示状态的变化。具有进程基本状态的变迁图如图4.8所示。从中可以看出进程状态之间的演变以及它们相互转换的典型理由。
图4.8 具有进程基本状态的变迁图
值得注意的是，运行状态的进程因请求某种服务而变为等待状态，但当该请求完成后，等待状态的进程并不能恢复到运行状态，它通常是先转变为就绪状态，再重新由调度程序来调度。其原因请读者考虑。
上面介绍了进程的三种基本状态及其转换。那么，进程是如何产生和消亡的呢？进程是程序的一次执行过程，它是一个活动。当用户或系统需要一个活动时，可以通过创建进程的方法产生一个进程，进程被创建后进入就绪状态。而当一个进程的任务完成时，可以通过撤销进程的方法使进程消亡，进程转为完成状态。就绪状态、运行状态、等待状态是进程的三种基本状态。进程还有创建和消亡的过程。
在不同类型的操作系统中，进程状态变迁的原因，也不完全相同。如在分时系统中，因采用时间片调度策略，每个进程被调度时，会分得一个时间片，当时间片到时，该进程应该转变为何种状态呢？请读者思考，并画出相应的进程状态变迁图。
 4.2.4 进程的描述——进程控制块
为了适应并发程序设计的需要而引入了进程的概念。进程是程序的一次执行过程。程序是完成该进程操作的算法描述，它是静止的概念。当某程序和别的程序并发执行时，产生了动态特征，并由于并发程序之间的相互制约关系而造成了比较复杂的一个外界环境。为了描述一个进程和其他进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块，称为进程控制块（process control block，PCB）或称为进程描述器（process descriptor）。系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个pcb，然后根据pcb的信息对进程实施控制管理。进程任务完成时，系统撤销它的pcb，进程也随之消亡。
从结构上说，每个进程都由一个程序段（包括数据）和一个进程控制块pcb组成，如图4.9所示。程序和数据描述进程本身应完成的功能；而进程控制块pcb则描述进程的动态特征，进程与其他进程和系统资源的关系。
图4.9 进程的组成
为了对进程作充分的描述，pcb应具有的信息如表4.1所示。
表4.1 pcb的结构
表4.1中各项内容说明如下。
①进程标识符name。每个进程都必须有唯一的标识符，可以用字符或编号表示，在创建一个进程时，由创建者给出进程的标识符。另外，为了便于系统管理，进程还应有一个内部标识符（id号）。
②进程的当前状态status。该项说明本进程目前处于何种状态（运行、就绪、等待），作为进程调度时分配处理机的主要依据。只有当进程处于就绪状态时，才有可能获得处理机。当某个进程处于阻塞状态时，有时要在pcb中说明阻塞的原因。
为了便于对进程实施管理，通常把具有相同状态的进程链在一起，组成各种队列。比如，将所有处于就绪状态的进程链在一起，称为就绪队列。把所有因等待某事件而处于等待状态的进程链在一起就组成各种等待（或阻塞）队列。而运行链在单处理机系统中则只有一个运行指针了（running）。进程当前状态可以用进程所属的当前队列头指针（current_q_start）来表征。如进程正处于运行状态，可用running运行指针来表示；当进程正处于就绪状态，可用就绪队列头指针ready_q_start来表示；若进程因等某事件（设为x）而阻塞，可用wait_x_q_start（等待x事件的队列头指针）来表示。也可以用不同的数字（如0、1、2）或不同的符号（如run、ready、wait）来表示。
③当前队列指针next。该项登记了处于同一状态的下一个pcb的地址，以此将处于同一状态的所有进程链接起来。每个队列有一个队列头，其内容为队列第一个元素的地址。
图4.10描述了一个就绪队列和一个等待打印机队列的结构。
图4.10 就绪队列和等待队列
④总链指针all_q_next。系统中存在着大量的进程，它们依各自的状态分别处于相应的队列中，这便于对进程实施调度控制。但是，当进行某些管理功能，如执行创建新进程的功能时，就感到系统具有所有进程的总链将是十分方便的。因为进程的标识符必须是唯一的，由创建者给出的被创建进程的名字是否会重名，必须先检查系统已有的进程名，但若分别在各个队列去查询将是十分麻烦的，所以应提供一个进程总链结构。进程pcb中的该项内容是指向总链中的下一个pcb地址。
⑤程序开始地址start_addr。该进程的程序将从此地址开始执行。
⑥进程的优先级priority。进程的优先级反映了进程要求CPU的紧迫程度，它通常由用户预先提出或由系统指定。进程将依据其优先级的高低去争夺使用CPU的权利。
⑦CPU现场保护区cpustatus。当进程由于某种原因释放处理机时，CPU现场信息被保存在pcb的该区域中，以便在该进程重新获得处理机后能继续执行。通常被保护的信息有：工作寄存器、指令计数器以及程序状态字等。
⑧通信信息communication information。通信信息是指每个进程在运行过程中与别的进程进行通信时所记录的有关信息。比如，可以包含正等待着本进程接收的消息个数，第一个消息的开始地址等。
⑨家族联系process family。有的系统允许一个进程创建自己的子进程，这样，会组成一个进程家族。在pcb中必须指明本进程与家族的联系，如它的子进程和父进程的标识符。
⑩占有资源清单own_resource。
不同的操作系统所使用的pcb结构是不同的。对于简单系统，pcb结构较小。而在一些较复杂的系统中，pcb所含的内容则比较多，比如，还可能有关于I/O、文件传输等控制信息。但是，一般pcb应包含的最基本内容如表4.1所示。
 4.2.5 线程概念及特点
1．什么是线程
为了进一步提高系统的并行处理能力。在现代操作系统中，例如Windows家族中使用了一个叫线程（threads）的概念。为什么要提出线程的概念？什么是线程？在这一节中作一简单讨论。
多线程的概念首先是在多处理机系统的并行处理中提出来的。传统的多处理机由若干台处理机组成，每台处理机每次运行单个现场，也就是说，每台处理机有一个有限硬件资源的单一控制线索。在这样的多处理机系统中，在进行远程访问期间会出现等待现象，处理机在这段时间间隔内处于空闲。为了提高处理机的并行操作能力，提出了多线程的概念。在每台处理机上建立多个运行现场，这样每台处理机有多个控制线程。在多线程系统结构中，多线程控制为实现隐藏处理机长时间等待提供了一种有效机制。线程可以用一个现场（context）表示，现场由程序计数器、寄存器组和所要求的现场状态字组成。
在操作系统中，为了支持并发活动，引入了进程的概念，在传统的操作系统中，每个进程只存在一条控制线索和一个程序计数器。但在有些现代操作系统中，提供了对单个进程中多条控制线索的支持。这些控制线索通常称为线程（threads），有时也称为轻量级进程（lightweight processes）。
线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条执行路径，即线程。这样，在一个进程内部就有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。
线程可以这样来描述：
①线程是进程中的一条执行路径；
②它有自己私用的堆栈和处理机执行环境（尤其是处理器寄存器）；
③它共享分配给父进程的主存；
④它是单个进程所创建的许多个同时存在的线程中的一个。
进程和线程既有联系又有区别，对于进程的组成，可以高度概括为以下几个方面：
①一个可执行程序，它定义了初始代码和数据；
②一个私用地址空间（address space），它是进程可以使用的一组虚拟主存地址；
③进程执行时所需的系统资源（如文件、信号灯、通信端口等），是由操作系统分配给进程的；
④若系统支持线程运行，那么每个进程至少有一个执行线程。
进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。
线程的应用是很广泛的。如，字处理程序在活动时，可以有一个线程用于显示图形，另一个线程用来读入用户的键盘输入，还有第三个线程在进行拼写和语法检查。又如，网页服务器需要接收用户关于网页、图像、声音等请求。一个网页服务器可能有众多客户的并发访问。为此，网页服务器进程是多线程的。服务器创建一个线程以监听客户请求；当有请求产生时，服务器将创建另一个线程来处理请求。
2．线程的特点与状态
1）线程的特点
相对进程而言，线程的创建与管理的开销要小得多。因为线程可以共享父进程的所有程序和全局数据，这意味着创建一个新线程只涉及最小量的主存分配（线程表），也意味着一个进程创建的多个线程可以共享地址区域和数据。