# Pitou的DGA 虚拟算法分析（一）
|
##### 译文声明
本文是翻译文章，文章原作者 johannesbader，文章来源：johannesbader.ch
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
对一种非常有趣的DGA的分析文章，该DGA使用虚拟机作为保护措施。原文较长，故分为两个部分，第一部分先介绍对虚拟的逆向分析，第二部分介绍DGA的实现。
Pitou的域名生成算法(DGA)是迄今为止我逆向过的最难的DGA，其在内核模式下运行，并受到虚拟机的保护。在引文之后，本文将展示Pitou的虚拟机是如何工作的。之后，将介绍两种对字节码进行逆向的方法。最终，我会从Pitou中将DGA提取出来，用python进行复现
。完这篇文章的附录部分是完整的虚拟指令集的文档。
## 引文
在我看来，域名生成算法是一个恶意软件中最容易被人弄清的部分。对于一个没有加壳的样本，人们通常可以在几个小时内对算法进行逆向。为什么会这样呢？
  1. 大部分DGA通常没有明显的保护措施。
  2. 大部分DGA相对容易本地实现。无论是通过API调用，如DnsQuery和gethostbyname，还是通过模拟，例如add al, 61h 。
  3. 大部分DGA是简洁易懂的。如果使用Hex Rays这样的反编译器，分析更加容易，可以生成非常接近源代码的结果。
  4. DGA的模式基本上是清晰的。例如，组成域名的字母是通过将一个随机数映射到字母a-z的方法在循环中确定的。
Pitou的DGA与一般的DGA有四个不同点：
  1. 整个域名生成算法，包括种子，都是虚拟化的。虚拟机是一种特别有效的代码保护形式，分析起来很有挑战性，或者至少非常耗时。
  2. Pitou是一个具有动态解析API调用的木马(rootkit)。此外，Pitou使用NDIS钩子来隐藏网络通信。由于第1点中给出的原因，使用通常的DGA模式是不可行的。
  3. DGA非常长，对于种子需要进行复杂的基于日期的计算。
  4. DGA有两个严重的错误（bug），这使得它更加难以理解。
这些原因，尤其是第一个原因，使得Pitou成为迄今为止我分析的最难的域名生成算法。
## 前人的工作
这篇博客文章专门分析Pitou的DGA，故不涉及所有其他方面。
2014年8月，F-Secure研究人员发表了一篇关于Pitou的[优秀报告](https://www.f-secure.com/documents/996508/1030745/pitou_whitepaper.pdf)，我强烈建议阅读该报告，以便了解更多关于Pitou的特性。[随附的博客文章](https://www.f-secure.com/weblog/archives/00002738.html)简要回答了关于Pitou的最重要的问题。该报告中有一个关于DGA的专门章节，其中提到了算法的一些属性。但是，没有列出算法本身，也没有列出运行DGA的虚拟机的详细信息。
2016年1月，赛门铁克(Symantec)在其安全中心发布了一篇Pitou的文章。它列出了恶意软件可能连接到的20个域名，但没有提到这些域名仅具有有限的生命周期。
2018年1月，TG
软件研究中心(C.R.A.M.)发布了一篇关于Pitou的博客文章。该文章列出了四个域名，但是没有提到，更没有讨论产生这些域名的域名生成算法。
在这篇博文发布的14天前，Brad Duncan在SANS Internet Storm博客上发表了一篇标题为[Rig Exploit Kit send
Pitou.B
Trojan](https://isc.sans.edu/diary/25068)的日志。他还在自己的[个人博客](https://www.malware-traffic-analysis.net/2019/06/25/index.html)上写了两篇关于另外两个不同的Pitou样本的文章。这表明即使在F-Secure报告的5年后，Pitou和它的DGA仍然是相关的。正如博客文章末尾的表格所示，带有原始种子的DGA仍然在使用，这可能要归功于对DGA的良好保护。
## 域名例子
下面的Wireshark截图显示了2019年6月20日查询的20个域名：
这些域名使用一些不常见的顶级域，如.mobi和.me，尽管这些域名的辅音和元音在某种程度上交替使用，来产生类似可发音的效果，但是依然可以很容易通过人工检查出来。
## 本次分析样本
我对以下文件进行了逆向，它被ESET、Ikarus和Microsoft检测为Pitou。
MD5 | 28060e9574f457f267fab2a6e1feec92  
---|---  
SHA1 | 9529d4e33498dd85140e557961c0b2d2be51db95  
SHA256 | 43483385f68ad88901031ce226df45b217e8ba555916123ab92f63a97aef1d0e  
文件大小 | 522K  
编译时间戳 | 2017-10-31 10:15:25 UTC  
链接 |
[VirusTotal](https://www.virustotal.com/en/file/43483385f68ad88901031ce226df45b217e8ba555916123ab92f63a97aef1d0e/analysis/1509542832/)  
将文件解压缩到二进制文件，解压后Avast、AVG和Fortinet也将其检测为Pitou。
MD5 | 70d32fd5f467b5206126fca4798a2e98  
---|---  
SHA1 | 6561129fd718db686673f70c5fb931f98625a5f0  
SHA256 | f43a59a861c114231ad30d5f9001ebb1b42b0289777c9163f537ac8a7a016038  
文件大小 | 405K  
编译时间戳 | 2017-08-22 10:24:10 UTC  
链接 |
[VirusTotal](https://www.virustotal.com/en/file/f43a59a861c114231ad30d5f9001ebb1b42b0289777c9163f537ac8a7a016038/analysis/)  
上面的可执行文件会在之后删除掉木马。Pitou分别包含一个32位和一个64位模块来支持这两种体系结构。
32-bit
MD5 | 9a7632f3abb80ccc5be22e78532b1b10  
---|---  
SHA1 | 2d964bb90f2238f2640cb0e127ce6374eaa2449d  
SHA256 | ab3b7ffaa05a6d90a228199294aa6a37a29bb42c4257f499b52f9e4c20995278  
文件大小 | 431K  
编译时间戳 | 2017-03-22 01:21:01 UTC  
链接 |
[VirusTotal](https://www.virustotal.com/en/file/ab3b7ffaa05a6d90a228199294aa6a37a29bb42c4257f499b52f9e4c20995278/analysis/)  
64-bit
MD5 | 264a210bf6bdded5b4e35f93eca980c4  
---|---  
SHA1 | 8f6ff0dd9b38c633e6f13bde24ff01ab443191f6  
SHA256 | ddb82094dec1fc7feaa4d987aee9cc0ec0e5d3eb26ba9264bb6ad4aa750ae167  
文件大小 | 478K  
编译时间戳 | 2017-02-27 06:13:41 UTC  
链接 |
[VirusTotal](https://www.virustotal.com/en/file/ddb82094dec1fc7feaa4d987aee9cc0ec0e5d3eb26ba9264bb6ad4aa750ae167/analysis/)  
这里，我只分析了64位版本。
## 虚拟机
这部分介绍保护DGA的虚拟机，以及Pitou组件的其他功能。首先展示虚拟机的主要组成。然后，讨论VM及其字节码的属性。
###  组件
Tim Blazytko和Moritz
Contag的[这段视频](https://youtu.be/TDnAkm6ZTYw?t=690)很好地介绍了虚拟机的主要组件，包括：
  * VM入口/ VM出口
  * VM调度器
  * 处理程序表
**VM入口**
VM入口和出口负责上下文的切换。VM入口将本机上下文(寄存器和标志)复制到虚拟环境。在下面的屏幕截图中展示了进入虚拟机。
根据x64调用约定将四个参数传递给虚拟化的DGA(rcx、rdx、r8和r9中)。在讨论DGA的参数时，我将重新讨论这些参数及其含义。对DGA的调用会在堆栈上产生一个返回值，该值稍后在调用ret退出时用于VM退出，以便在调用DGA之后立即跳回到原来代码处。调用将指向原来代码处：
这个5字节长度的调用，位于VM执行字节码的中间。调用的目的是将接下来地址的地址(用entry_point_bytecode标记)放入堆栈。这个地址是虚拟DGA的入口点，并不在字节码的开头。然后调用跳转到虚拟机的开始。从46个不同的位置可以进行虚拟机的调用，意味着有46个不同的字节码起点，而所有起点可能都实现了Pitou的不同组件，例如：
因为原生代码也可以在字节码的中间，如call指令，所以VM必须能够识别该指令并跳过它。稍后我们将看到这是如何实现的。
VM本身启动如下：
本机上下文被复制到虚拟上下文，通过寄存器rsi进行访问。复制的内容包括：
  * 标志位，通过pushfq
  * 通用寄存器rax、rbx、rcx、rdx、rdi、rsi和r8到r15。寄存器rip、rsp和rbp不会被复制，因为VM本身会使用它们。
  * XMM寄存器，尽管没有任何虚拟指令修改它们。
屏幕截图的最后一行pop rax，从堆栈中删除虚拟代码的入口点。这个入口点也保存在虚拟上下文中：
上面的截图显示了VM
入口如何检查入口点是否在字节码中。我将字节码的最低地址命名为imagebase，将最高地址命名为highest_addr。如果入口点在此范围内，则将虚拟指令指针设置为入口点。这就是VM入口。
**VM调度器（Dispatcher）**
调度器的任务是获取和解码指令。处理程序（handler）通常属于被调用的操作码，Pitou的VM也不例外。同时这个处理程序（handler）还负责更新VM的上下文，特别是指令指针。
下面的截图展示了VM调度器。首先，读取虚拟指令指针(1)。如果设置了控制寄存器CR8，则指令指针转换为从入口点开始的偏移量，并触发软件中断(2)。然后调度器读取指令指针上的字节。如果它指向E8(4)，则VM处于本地调用，用于将入口点传递给VM（详情见VM入口部分）。调用的五个字节被简单地跳过(5)。其他所有字节的值都是有效的字节码。最不重要的6比特对应于操作码，它引用处理程序表中的函数。然后VM跳转到这个函数(6)。
6位可以表示多达64个不同的函数，其中0x28被排除，因为它对应于保留字节0xE8中的操作码部分。然而，只有处理程序表中的前29个条目指向不同的程序。我根据调用它们的主操作码将它们标记为instruction_00到instruction_1C。从操作码0x1D开始，重用之前的函数，例如，0x1D使用操作码0x03的处理程序。一些处理程序函数只由一个操作码访问，而另一些则由多个操作码访问。例如，0x07、0x47、0x87、0xc7都映射到同一个处理程序。
**VM出口**
虚拟jmp/call/ret指令(处理程序0x02)同样控制VM出口。这个处理程序的详细说明在附录部分。下面处理程序的截屏展示了如何从虚拟上下文恢复本地寄存器。退出VM的操作很简单：通过使用堆栈上的地址，处理程序最后只返回VM入口之后的代码。
###  属性
Pitou的虚拟机是基于堆栈的，其执行64位代码。至少64位模块是这样做的，32位的模块可能有32位虚拟指令。接下来说明虚拟机的属性。所有说明的完整列表可在附录中找到。
**寄存器**
VM使用x64通用寄存器和标志的虚拟副本。正如所预料的，它还具有一个虚拟指令指针、一个虚拟堆栈指针和一个虚拟基指针。此外，还有两个状态寄存器可用，被用于跳转:
#####  指令集
虚拟指令的长度从1字节到11字节不等。正如VM调度器部分介绍的，第一个字节的最低6位是代表处理程序函数的操作码。最高的2位可用于选择处理程序中的变量。只有第一个字节是必需的。事实上，许多虚拟指令只有1字节长。通常由前缀的两位之一决定后面跟着一个或两个可选的指定字节。格式因指令而异(例如，它可以包含关于指令使用哪个内存段的信息、或者下面的操作数是否有正负之分，或者指令的大小)。在可选说明符之后，可能会跟着一个可选操作数。
操作数以小端顺序存储，可以是字节（bytes）、字（words）、双字（double-words）或四字（quad-words）。操作数和说明符使用以下密钥进行异或加密：
  * 字节是用0x57加密
  * 字用0x13F1加密
  * 双字用0x69B00B7A加密
  * 四字用0x7EF5142A570C5298加密
例如，操作数AB01加密后值为0x125A (0x01AB
XOR0x13F1)。跳转目标地址相对于虚拟代码的初始地址。例如，如果虚拟代码从0xFFFFF87EC582C000开始，那么带有解密操作数0x123的跳转将把虚拟指令指针设置为0xFFFFF87EC582C123。指令0x01、指令0x04、指令0x06和指令0x18可以使用虚拟代码的相对地址。处理程序0x18指令也可以使用可执行程序初始地址的相对地址。这允许处理程序访问VM外部的内存。DGA使用这个地址来读取静态字符串，比如顶级域列表。这是唯一一条与位置无关的指令，即如果虚拟代码放置在其他位置，则需要重新定位。
看一个例子：如果设置为0，则跳转至地址0xfffff8800586c445的虚拟指令JZ 0xfffff8800586c445编码如下：
  * 条件跳转是处理程序0x06。这个处理程序使用前两个比特位。
  * 第一个比特位决定条件是一元(0)还是二元比较(1)。在我们的例子中，为一元条件。第二个比特位只适用于二元比较。总的来说，第一个字节是0x06。
  * 说明符的前两个比特(最重要的)决定标志如何组合。1 0表示如果设置了所有选中的标志，则满足条件。剩下的6个比特是用作各种标志的比特掩码。JZ指令只需要查看ZF标志，因此比特掩码中只设置了这个位。整个说明符是0xDF，然后用密钥0x57加密它，得到最终的值0x88。
  * 跳转目标地址计算如下：从目标(0xfffffff8800586c445)中减去镜像基址（image base） (0xfffff87EC582C000)，然后对结果进行异或加密(密钥0x7EF5142A570C5298)。
**虚拟栈**
由于虚拟机是基于堆栈的，所以堆栈非常重要。虽然虚拟机模拟64位代码，即它最多处理64位的值，但堆栈宽128位。每个堆栈实体由两个64比特槽位组成。大多数指令只使用存储在较低地址的槽位，显示在堆栈图左侧的部分。我将这个槽位称为值槽或常规存储槽。另一个槽比第一个槽高64位，通常用于存储左槽（值槽）里值的地址。我把这个槽位称为额外槽位。
和正常情况一样，该堆栈遵循“后进先出”原则。它向较小的地址增长，向较大的地址收缩。虚拟堆栈寄存器变量指向堆栈中的最后一项。
## 逆向工程
这部分讨论虚拟机的逆向。起初，我编写了一个反汇编程序，但对它的输出不满意，单独来看还是太复杂了，难以理解。特别是缺少用于用户定义指令的工具，使得分析变得困难。
第二种方法是将虚拟代码变成C代码。这工作得出奇的顺利，最终实现了一个算法，虽然还是很复杂，还有一些错误，但已经很容易理解了。我使用DGA的一部分作为例子来说明算法的四个步骤，选取的这部分对应一个简单的数学语句，可以用C语言写成一行。这应该能让你了解每个步骤的结果有多长，以及它们是多么的难以理解。
###  方法一：反汇编
分析VM的通常步骤如下（更加详细的步骤可以看这本书[[Practical Reverse Engineering: x86, x64, ARM,
Windows Kernel, Reversing Tools, and
Obfuscation](https://www.amazon.com/Practical-Reverse-Engineering-Reversing-Obfuscation/dp/1118787315/)]）: