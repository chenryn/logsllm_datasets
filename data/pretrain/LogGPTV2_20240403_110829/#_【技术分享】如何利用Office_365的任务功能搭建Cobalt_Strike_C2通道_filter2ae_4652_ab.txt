我们可以使用Office 365
EWS服务来创建一个任务，以此为例展示该技术在实际环境中的应用场景。任务的内容由“主题（Subject）”以及“正文（Body）”标签来表示。这两个特征可以用来构建C2通道，如下文所述。我们还使用了“截止日期（DueDate）”标签，其他可用标签的使用方法与该标签类似。任务中包含的许多标签可以用于C2通信，比如，某些标签可以作为信令标志加以使用（例如，我们可以将“非常重要（high
importance）”标签的值设为“启用（enabling）”，以表示C2通道处于阻塞状态）。然而，我们的PoC代码并没有用到所有标签，仅用到了其中的“Subject”以及“Body”标签。
将这个请求发送给Office 365会得到什么结果？这正是本文要介绍的重点。
利用EWS服务，我们可以通过Office
365来创建及删除任务。本文的PoC代码中会覆盖到这两个操作。从攻击角度来看，这些操作的结果是会生成大量流量，发往已知的、合法的且信誉度较高的域名。从防御角度来看，我们很难将这些流量标记为非法流量，特别是当正常业务中Office
365的使用场景越来越普遍时，这些恶意流量会更加难以识别。
**3.2 消息格式**
现在我们已经有办法与Office 365交互，这一节中，我们会讨论如何把这种方法应用于Cobalt Strike
C2通道中，也会探讨实际工具中使用这种方法会遇到的一些困难。
在PoC代码中，我们采用了两个关键设计理念。首先，我们会根据具体的流量模式（即server-to-client（S2C）还是client-to-server（C2S））来使用不同的通信通道，这样控制端及客户端就能快速识别相应的任务以便后续处理。其次，每个通道可以使用多个任务，这样就能提高传输速率。当然我们还可以使用其他可选方法，比如我们可以使用经常修改的一小部分原型任务或者邮件，然而这会大大降低整体性能，也会加大整体复杂性，比如我们需要考虑排队以及信令等复杂情况。根据这两个设计理念，最终我们使用的C2架构如下所示：
对于每个任务，我们将Cobalt
Strike团队服务器或植入体所使用的核心数据载荷（payload）以base64编码形式存储在任务的body区中。每个任务需要包含某些特征字符，以便各自能够相互区分。特征字符包含在任务的subject字段中，以冒号作为分隔符。subject中包含的特征字段如下所示：
1、通道模式（Channel）：表明通信流的方向，为S2C或者C2S。
2、连接标识符（Connection
identifier）：随机生成的包含数字和字母的一个字符串，以标识C2通道上的每个“连接”。PoC代码使用这个字段以支持多客户端功能。客户端和控制端需要在各自的消息中包含这个字段。
3、消息序号（Message sequence number）：一个递增整数，以标识创建的每个任务。这个字段用来确保接收端以正确的顺序处理收到的任务。
4、数据长度（Data length）：一个整数，以表示任务body字段中的数据经过base64解码后所包含的字节数。
5、消息摘要（Message
digest）：用于完整性检查的一个值。我们根据未经base64编码的载荷计算出这个值，接收端收到载荷后，根据base64解码结果计算校验值，再跟原来的值对比。在本文所用的PoC代码中，这个值仅用来验证客户端连接开始时所使用的传输器（staged）植入体是否有效。
根据这些字段，在Office 365中传输的典型C2流量如下所示：
**3.3 C2组件控制流程**
实现这种“External
C2”方案的最大挑战在于如何支持多个客户端连接。原因主要在于我们需要花许多精力来识别并跟踪每个客户端连接的状态，还要确保能够正确发送和接收C2流量。我们在PoC代码中解决了这个难题，在下文中，我们会介绍客户端和控制端的控制流程，这是解决问题的关键点。
客户端的控制流程如下图所示。PoC代码可以支持传输器（staged）载荷（下文使用A来表示）以及完整版的传输器（full
staged）载荷（下文使用B来表示），因此我们需要在流程（1）中识别载荷所使用的具体方法。在流程（2）中，A方法所使用的消息结构与Raphael
Mudge所使用的结构一样，涉及如下四类消息：架构信息（“arch=”）、命名管道的名字（“pipename=”）、“no-op”帧之间间隔的毫秒数（“block=”）以及用来与团队服务器建立连接的一个触发指令（“go”）。这个流程中会随机生成一个包含字母数字的字符串，作为命名管道以及连接的标识符。消息随后会被封装，然后经过Office
365进行传输。在流程（3）中，我们会接收Office
365返回的A类型植入体（大小约200KB），检查该植入体是否完整，如果完整性校验不通过，会再次请求这个植入体。在流程（4）中，我们将植入体载入内存，调用CreateThread()函数启动植入体。B类型客户端会从流程（1）直接跳到流程（4）。在这种情况下，我们需要使用静态管道名，与生成B类型植入体文件所使用的管道名一致。这类植入体会创建一个命名管道，然后客户端会尝试连接这个管道，为了保证稳定性，如果连接失败，我们会使用新的命名管道名称再次发起请求。目前我们的“External
C2”方案尚未完全支持B类型植入体，需要添加其他代码以支持这个功能。为了通过“External
C2”接口收到来自植入体的连接请求，团队服务器必须收到“go”触发指令。简单加载植入体并不能实现与团队服务器的通信。虽然我们可以使用其他参数来单独发送触发信令，但从结果上来看，我们还是会收到使用默认值（如“pipename=externalc2”）的传输器载荷响应。这个响应对我们来说有点多余。
随后，我们会进入一个循环流程。在流程（5）中，客户端检查命名管道上是否有可用数据，如果可用则读取相应数据。流程（6）中，客户端将读取的数据封装成一个任务，然后发给Office
365。流程（7）中，检查并接收Office
365上的可用任务。流程（8）中，对收到的任务进行解封装，识别对应的客户端。流程（9）中，如果有可用任务，会根据控制端消息序号对这些任务进行排序，按顺序处理后再写入命名管道中，最后，从Office
365中删除这些任务。这种循环处理逻辑可以让植入体获得Office 365的轮询时间，因此可以通过“sleep”命令动态控制轮询请求。
控制端的控制流程如下图所示，流程（1）、（2）、（3）、（4）、（5）属于第一段控制流程，流程（6）、（7）、（8）属于第二段控制流程。流程（1）中，检查Offce
365上是否有可用任务用于客户端通信。如果有可用任务，流程（2）中客户端会获取并拆分这些任务。如果任务来自于以前没见过的客户端，流程（3）中会实例化一个类，专门处理客户端的变量及方法。在流程（6）中，生成的对象中包含一个特定方法，负责处理连接到Cobalt
Strike团队服务器的每个客户端TCP套接字。流程（4）中，从Office
365收到的任务会根据序号进行排序。流程（5）中，从正确的客户端对象中识别已建连TCP套接字（每个客户端都应该有自己的套接字连接），通过TCP套接字将解码后的任务发给团队服务器。发送完毕后，从Office
365上删除这些任务。流程（7）中，团队服务器返回响应，使用相应的客户端信息将响应封装成任务，发给Office
365。通过这种工作流程来发送和接收任务，我们可以控制任务轮询速率。第一段控制流程负责接收任务，可以个性化配置，通过批处理方式让所有客户端处理来自Office
365的任务（比如，可以避免定时向服务器发起请求）；在第二段控制流程中，每个客户端可以自动从团队服务器上接收数据，然后根据实际需求将数据以任务形式发送给Office
365。
**3.3 场景演示**
我们搭建了一个演示场景，包含1个控制端以及3个客户，具体操作如下视频所示。在这个场景中，客户端使用的是全功能版的传输器载荷。
从视频中你可以看到，虽然依赖于外部服务，但整体的响应速度还是可以接受，而新增的延迟主要来自于控制端和客户端在请求及响应循环中的处理时间。尽管存在延迟，在不优化性能的情况下，利用这种方法每个客户端还是可以达到每分钟2MB左右的下载速度，主要原因是任务的body字段可以包含大量数据。后续我们可以考虑使用Office
365的其他功能来提升速度，比如，我们可以使用Office 365提供的批量数据上传功能。
**四、总结**
****
本文介绍了Cobalt Strike的“External C2”接口，提供了PoC实现方法，借助Office
365服务中Outlook的“任务（tasks）”功能搭建了一条C2通道。
需要注意的是，尽管本文侧重于Office
365服务，但我们给出的方法适用于使用Exhange服务的其他互联网产品，其中不乏许多商业产品。比如，我们可以将某个目标组织自己搭建的Exchange服务作为C2通道媒介加以使用
。在这种情况下，C2通信的初始阶段（即客户端与Exchange建连阶段）将完全停留在目标网络内部，只有控制端连接到目标组织的Exhcange实例时才会产生外部流量。对攻击者而言，这种方法的缺点在于目标安全团队可以访问Exchange的日志，如果我们使用的是Office
365，目标安全团队就难以做到这一点。
“External C2”接口目前仍处于早期试用阶段，需要解决许多问题才能在在实际生产环境中使用。对进攻发起方而言，“External
C2”接口提供了动态C2通道功能，可以让C2研究工作大放异彩。