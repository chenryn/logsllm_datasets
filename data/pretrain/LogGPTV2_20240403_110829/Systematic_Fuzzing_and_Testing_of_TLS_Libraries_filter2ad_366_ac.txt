p r i v a t e M o d i f i c a t i o n m o d i f i c a t i o n ;
p u b l i c i n t g e t V a l u e ( ) {
(mod != n u l l ) {
r e t u r n m o d i f i c a t i o n . modify ( o r i g V a l u e ) ;
i f
}
r e t u r n o r i g V a l u e ;
}
}
ModifiableInteger contains two variables: a wrapped
origValue and a modification. The origValue is used to
hold the original integer value computed during a program
execution. While accessing the variable over getValue(),
this method is able to execute speciﬁc modiﬁcations before
the original value is returned.
Usage of modiﬁable variables. The best way to present
the functionality of this concept is by means of a simple
example:
M o d i f i a b l e I n t e g e r
i . s e t O r i g i n a l V a l u e ( 3 0 ) ;
i . s e t M o d i f i c a t i o n ( new A d d M o d i f i c a t i o n ( 2 0 ) ) ;
System . ou t . p r i n t l n ( i . g e t V a l u e ( ) ) ;
i = new M o d i f i a b l e I n t e g e r ( ) ;
// 50
In this example, we deﬁne a new ModifiableInteger and
set its value to 30. Next, we deﬁne a new modiﬁcation –
AddModification – which simply returns a sum of two in-
tegers. We set its value to 20.
If we execute the above
program, the result 50 is printed. This is because by ac-
cessing the original integer value, its value gets increased by
20.
A similar concept is applied for all basic data types: in-
tegers, bytes, or byte arrays. ModifiableInteger contains,
for example, these modiﬁcations: add, explicitValue, xor,
shift, or subtract. Similar modiﬁcations are accessible to
other numeric types. ModifiableByteArray is a container
for byte arrays and contains, for example, the following mod-
iﬁcations: delete, insert, or xor. It is worth mentioning
that the modiﬁcations can be concatenated and executed
successively.
Modiﬁable variables in protocol messages. All rele-
vant protocol messages and record data are stored in modiﬁ-
able variables. An example is shown in the following
ClientHello protocol message:
p u b l i c
c l a s s C l i e n t H e l l o M e s s a g e {
M o d i f i a b l e I n t e g e r c o m p r e s s i o n L e n g t h ;
M o d i f i a b l e B y t e A r r a y c o m p r e s s i o n s ;
M o d i f i a b l e I n t e g e r c i p h e r S u i t e L e n g t h ;
M o d i f i a b l e B y t e A r r a y c i p h e r S u i t e s ;
. . .
}
The ClientHello message is used in the TLS protocol ﬂow
and the variable values are computed dynamically. Before
executing the protocol ﬂow, the modiﬁable variables allow
us to set arbitrary variable modiﬁcations or to deﬁne ex-
plicit variable values. The variables are then dynamically
modiﬁed during the protocol execution. For example, the
developer can use 2 cipher suites and set the explicit value
of cipherSuitesLength to 5. TLS-Attacker then uses an
invalid length value while serializing the ClientHello mes-
sage, which could possibly trigger an overﬂow.
14965.2 High-Level Overview
TLS-Attacker is divided into several Maven modules
(cf. Figure 3). The concept of modiﬁable variables is lo-
cated in a separate ModifiableVariable module so that
further applications can proﬁt from its functionality. The
Transport module contains transport handling utilities for
TCP and UDP. The core module is TLS, which contains a
TLS protocol implementation. This is divided into further
packages. The protocol package contains protocol messages
and their handlers. The workflow package contains a ﬂexi-
ble protocol ﬂow implementation which allows one to deﬁne
arbitrary message order. Further relevant packages are de-
picted in Figure 3. The Attacks and Fuzzer modules are
based on the TLS functionalities and deﬁne several TLS at-
tacks and fuzzing techniques. The TestSuite module deﬁnes
an extensible TLS test suite.
TLS-Attacker currently implements the TLS 1.0, 1.1, 1.2
and DTLS 1.2 protocol versions and the client-side func-
tionality, including client-side authentication. Furthermore,
it implements these features:
• Key exchange algorithms: RSA, ECDH(E), DH(E)
• Encryption algorithms: AES-CBC, 3DES-CBC
• Extensions: EC, EC point format [22], Heartbeat [50],
Maximum fragment length [31], Server name indica-
tion [31], Signature and hash algorithms
This allows us to cover the majority of the relevant TLS
attacks. Further features are in development.
5.3 The TLS Module
TLS is the core module of TLS-Attacker. It implements
the complete TLS functionality, using modiﬁable variables
and the transport handlers from the Transport module. It
solely relies on the cryptographic functionality provided by
the standard Java cryptographic providers and the Bouncy
Castle library (version 1.54).
The TLS module is divided into several packages. The
config package contains classes for TLS protocol conﬁgu-
ration. TLS constants (cipher suites, key exchange algo-
rithms, alerts) are deﬁned in the constants package. The
crypto package contains TLS speciﬁc cryptographic func-
tionalities which extend the basic behavior of Java crypto-
graphic providers.
The protocol package implements the TLS protocol mes-
sages and their handlers. Each protocol message is deﬁned
by a handler (responsible for message processing) and a mes-
sage state (representing the current state of the TLS mes-
sage). For example, the handshake package contains the
HandshakeMessageHandler and HandshakeMessage classes
(see Figure 3). The abstract HandshakeMessage class con-
tains general handshake variables used by all handshake
messages, e.g., the handshake message type. ClientHel-
loMessage extends HandshakeMessage and includes Clien-
tHello speciﬁc variables like an array of cipher suites or the
cipher suite length. Note that all these variables are modiﬁ-
able to achieve high ﬂexibility. Processing of handshake mes-
sages is provided by the HandshakeMessageHandler classes.
Each handler implements two functions: prepareMessage
used while sending TLS message and parseMessage used
while parsing incoming messages.
A similar concept of handlers and messages is implemented
for the TLS record handling deﬁned in the record package.
The workflow package contains TLS protocol executors.
The TLS protocol execution solely depends on the deﬁned
TLS messages. A TLS executor takes a list of protocol
messages as an input, searches for proper message handlers,
and lets them process the deﬁned messages. This approach
presents two notable advantages:
1. It makes it very convenient for a TLS-Attacker user to
deﬁne custom TLS protocol ﬂows with arbitrary mes-
sage ordering just by setting speciﬁc TLS messages.
2. The processed TLS protocol ﬂows can be stored for
further analysis or even for a repeatable execution.
5.4 Using TLS-Attacker Interfaces
In the following section we present how TLS-Attacker in-
terfaces can be used to construct a custom protocol message
ﬂow detecting vulnerability to Bleichenbacher’s attack. We
chose this attack as an example since it requires a deep in-
tervention in the TLS protocol functionality, including mod-
iﬁcation of the plain padded premaster secret.
Detecting Bleichenbacher’s oracle with ≈ 10 lines of
code. The design of TLS-Attacker supports simple deﬁni-
tions of new attacks. The following example shows a custom
protocol ﬂow by explicitly setting the plaintext value of a
padded premaster secret. This code can be used to evaluate
the correctness of countermeasures against Bleichenbacher’s
attack [23].
T l s C o n t e x t c o n t e x t = i n i t i a l i z e T l s C o n t e x t ( c o n f i g ) ;
WorkflowExecutor e x e c u t o r =
i n i t i a l i z e W o r k f l o w E x e c u t o r ( c o n t e x t ) ;
// S e t t i n g e x p l i c i t m o d i f i c a t i o n o f
t h e p r e m a s t e r
s e c r e t
RSAClientKeyExchangeMessage r s a = new
RSAClientKeyExchangeMessage ( ) ;
M o d i f i a b l e V a r i a b l e  pms = new
M o d i f i a b l e V a r i a b l e <>() ;
pms . s e t M o d i f i c a t i o n ( new E x p l i c i t V a l u e M o d i f i c a t i o n (
VALUE ) ) ;
r s a . s e t P l a i n P a d d e d P r e m a s t e r S e c r e t ( pms ) ;
// C o n s t r u c t i n g p r o t o c o l message f l o w
L i s t  m = c o n t e x t .
g e t P r o t o c o l M e s s a g e s ( ) ;
m. add ( new C l i e n t H e l l o M e s s a g e ( ) ) ;
m. add ( new S e r v e r H e l l o M e s s a g e ( ) ) ;
m. add ( new C e r t i f i c a t e M e s s a g e ( ) ) ;
m. add ( new S e r v e r H e l l o D o n e M e s s a g e ( ) ) ;
m. add ( r s a ) ;
m. add ( new ChangeCipherSpecMessage ( ConnectionEnd .
CLIENT) ) ;
m. add ( new F i n i s h e d M e s s a g e ( ConnectionEnd . CLIENT) ) ;
m. add ( new A l e r t ( ConnectionEnd .SERVER) ) ;
// P r o t o c o l e x e c u t i o n
e x e c u t o r . e x e c u t eW o r k f l o w ( ) ;
By setting a custom premaster secret, the security en-
gineer enforces TLS-Attacker to execute a TLS handshake
with this custom value. The execution of TLS handshakes
with diﬀerent premaster secret values can trigger diﬀerent
server behaviors and thus reveal an oracle which can be used
to perform Bleichenbacher’s attack.
Note that constructing such a protocol ﬂow with a com-
mon TLS library would need a deep knowledge of the library.
On the other hand, with TLS-Attacker, security engineers
can easily use the TLS-Attacker interfaces to deﬁne new pro-
tocol ﬂows with speciﬁc message modiﬁcations and embed
them into their test suites.
1497Figure 3: TLS-Attacker is divided into several Maven modules. The core module is TLS implementing the
protocol functionality and ﬂexible protocol execution. All protocol messages use modiﬁable variables.
Not only for Java developers. Convenient XML se-
rialization.
It is not necessary to develop Java in order
to construct arbitrary protocol ﬂows with custom modiﬁca-
tions. Instead, we decided to use JAXB (Java Architecture
for XML Binding) [3] for serialization and deserialization of
TLS protocol ﬂows. This allows a developer to deﬁne the
same protocol ﬂow as above using a simple XML document:
CLIENT
NULL
TLS RSA WITH AES 128 CBC SHA
TLS RSA WITH 3DES EDE CBC SHA
. . .
SERVER
SERVER
SERVER
CLIENT
00 02 8B 2B FC 66 ED 21
07 9A F8 5F 92 8E 34 38
. . . .
81 51 B5 91 E6 B3 1D F8 BB 98 48 31 8F 73 A2 CE
60 0A 31 CC 34 D7 0D 42 F6 3F D1 59 20 53 71 5E
CLIENT
CLIENT
SERVER
6. FUZZING WITH TLS-ATTACKER
TLS-Attacker provides a suitable framework for perform-
ing fuzzing attacks. Based on our observations about the
previous TLS attacks and vulnerabilities, we designed an
extensible approach for performing a systematic evaluation
of TLS libraries. Our approach is divided into two stages,
see Figure 4.
In the following sections we ﬁrst describe the basics behind