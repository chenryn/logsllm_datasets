# Chrome Issue 659475（CVE-2016-5168）漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
Issue 659475的漏洞利用过程非常巧妙，结合了String(null)对象完成漏洞利用。本文将介绍这个巧妙的过程。
## 0x01 前置知识
###  String对象结构
在V8中，`String`对象其实就是`JSValue`对象，而决定`JSValue`的值的关键就是它的`value`字段。  
使用如下代码进行调试
    var str = new String("aaaaaaaaaaaaaaa");
    var str2 = new String("aaaaaaaaaaaaaaa");
    var str3 = new String("bbbbbbbbbbbbbb");
    var str4 = new String(null);
    %DebugPrint(str);
    %DebugPrint(str2);
    %DebugPrint(str3);
    %DebugPrint(str4);
    %SystemBreak();
运行结果如下
    DebugPrint: 0x28c3ab48a0f9: [JSValue]
     - map = 0x3bc278906981 [FastProperties]
     - prototype = 0x383e38b978c1
     - elements = 0x1c1ca5f02241  [FAST_STRING_WRAPPER_ELEMENTS]
     - value = 0x383e38baaff9 
     - properties = {
       #length: 0x1c1ca5f56379  (accessor constant)
     }
    DebugPrint: 0x28c3ab48a119: [JSValue]
     - map = 0x3bc278906981 [FastProperties]
     - prototype = 0x383e38b978c1
     - elements = 0x1c1ca5f02241  [FAST_STRING_WRAPPER_ELEMENTS]
     - value = 0x383e38baaff9 
     - properties = {
       #length: 0x1c1ca5f56379  (accessor constant)
     }
    DebugPrint: 0x28c3ab48a139: [JSValue]
     - map = 0x3bc278906981 [FastProperties]
     - prototype = 0x383e38b978c1
     - elements = 0x1c1ca5f02241  [FAST_STRING_WRAPPER_ELEMENTS]
     - value = 0x383e38bab061 
     - properties = {
       #length: 0x1c1ca5f56379  (accessor constant)
     }
    DebugPrint: 0x28c3ab48a159: [JSValue]
     - map = 0x3bc278906981 [FastProperties]
     - prototype = 0x383e38b978c1
     - elements = 0x1c1ca5f02241  [FAST_STRING_WRAPPER_ELEMENTS]
     - value = 0x1c1ca5f02251 
     - properties = {
       #length: 0x1c1ca5f56379  (accessor constant)
     }
从运行结果我们可以发现，`str`和`str2`虽然它们地址不一样，但是它们的字符串值一样，因此它们的`value`字段都指向了同一个地址`0x383e38baaff9`  
查看`value`指向的位置的结构
    pwndbg> x /20gx 0x1b780802aff8
    0x1b780802aff8:    0x00000d92c0a82361    0x000000006548be92
    0x1b780802b008:    0x0000000f00000000    0x6161616161616161
    0x1b780802b018:    0xde61616161616161    0x00000d92c0a82361
value的结构如下
    struct Value {
        Map *map;
        uint32_t hash;
        uint64_t padding;
        uint32_t length;
        char content[length];
    }
对于`String`对象，可以使用`[]`操作符进行字符串中字符的访问，但是不能进行修改。对于`String(null)`，其`value`指向的是一个`null`的对象，其`Value`结构中，`length`字段为0x4，`content`字段为`0xdeadbeed6c6c756e`。
###  property 的存储
有关`property
access`的优化，已经在[前面文章](https://www.anquanke.com/post/id/224765)中详细介绍过，主要就是对于对象的慢属性访问会在JIT时被优化为下标的方式进行访问。对于一开始就是字典类型的对象`var
a = {}`，处理`double`、`SMI`和`Object`类型时，都是直接给对应的字段赋值，其中`SMI`存储使用的是高4字节；  
使用如下代码测试
    var a = {};
    a.x0 = 1.1;
    a.x1 = 0x666666;
    a.x3 = a;
    %DebugPrint(a);
    %SystemBreak();
结果如下
    DebugPrint: 0x3191c908a059: [JS_OBJECT_TYPE]
     - map = 0x38fd4510c3e9 [FastProperties]
     - prototype = 0x3672f7504101
     - elements = 0x3a4833482241  [FAST_HOLEY_ELEMENTS]
     - properties = {
       #x0:  1.1 (data field at offset 0)
       #x1: 6710886 (data field at offset 1)
       #x3: 0x3191c908a059  (data field at offset 2)
     }
     pwndbg> x /20gx 0x3191c908a058
    0x3191c908a058:    0x000038fd4510c3e9    0x00003a4833482241
    0x3191c908a068:    0x00003a4833482241    0x3ff199999999999a
    0x3191c908a078:    0x0066666600000000    0x00003191c908a059
而对于一开始不是字典类型的对象，如`var a = new
Date();`，处理`double`类型的字段赋值时，会将`double`数据先包装为`MutableNumber`，然后将该对象的指针赋值给相应的字段，测试代码如下
    var a = new Date();
    a.x0 = 1.1;
    a.x1 = 0x666666;
    a.x3 = a;
    %DebugPrint(a);
    %SystemBreak();
运行如下
    DebugPrint: 0x1d4cc9e8a061: [JSDate]
     - map = 0x1cbdfe0c3e9 [FastProperties]
     - prototype = 0x3d14b440c2d9
     - elements = 0x20de36302241  [FAST_HOLEY_SMI_ELEMENTS]
     - value = 0x1d4cc9e8a0c1 
     - time = NaN
     - properties = {
       #x0: 0x1d4cc9e8a131  (data field at offset 0)
       #x1: 6710886 (data field at offset 1)
       #x3: 0x1d4cc9e8a061  (data field at offset 2)
     }
    0x1d4cc9e8a110:    0x0000000300000000    0x00001d4cc9e8a131
    0x1d4cc9e8a120:    0x0066666600000000    0x00001d4cc9e8a061
    0x1d4cc9e8a130:    0x000011d70e482eb9    0x3ff199999999999a
从这个特性中思考，如果我们有漏洞能够任意控制属性字段的内存值为某一个地址`addr+0x1`，那么，接下来将一个`double`数据赋值给这个字段时，就可以往`addr+0x8`的地方写入一个`unboxed
double`数据。这意味着就实现了任意地址写。
###  编译器版本
由于本漏洞属于老版本的V8，其V8编译器结构如下
有两种编译器，一个是`Crankshaft`，另一个是`TurboFan`，两者的不同点在于
>
> Crankshaft仅仅可以优化Javascript一部分语言的短板。例如，它并没有通过结构化的异常处理来设计代码，即代码块不能通过try、catch、finally等关键字划分。
    function opt() {
       var a = [1.1,2.2,3.3];
       var b = [2.2,3.3,4.4];
       var c = [a,b];
       return c;
    }
    for (var i=0;i map(HeapObject::cast(cell->value())->map());
    +          // First check that the previous value of the {cell} still has the
    +          // map that we are about to check the new {value} for. If not, then
    +          // the stable map assumption was invalidated and we cannot continue
    +          // with the optimized code.
    +          Handle cell_value(HeapObject::cast(cell->value()));
    +          Handle cell_value_map(cell_value->map());
    +          if (!cell_value_map->is_stable()) {
    +            return Bailout(kUnstableConstantTypeHeapObject);
    +          }
    +          top_info()->dependencies()->AssumeMapStable(cell_value_map);
    +          // Now check that the new {value} is a HeapObject with the same map.
               Add(value);
    -          value = Add(value, map);
    +          value = Add(value, cell_value_map);
               access = access.WithRepresentation(Representation::HeapObject());
               break;
             }
从源码路径可以知道，该漏洞与`crankshaft`编译器有关，patch修复了漏洞，该patch位于`HandleGlobalVariableAssignment`函数，因此，该函数用于处理全局变量的赋值操作。在V8的优化过程中，有一个特点就是，对于`stable
map`的对象，其`checkmap`节点会被移除，patch中最关键的一句是`top_info()->dependencies()->AssumeMapStable(cell_value_map)`。  
其中`AssumeMapStable`源码如下
    void CompilationDependencies::AssumeMapStable(Handle map) {
      DCHECK(map->is_stable());
      // Do nothing if the map cannot transition.
      if (map->CanTransition()) {
        Insert(DependentCode::kPrototypeCheckGroup, map);
      }
    }