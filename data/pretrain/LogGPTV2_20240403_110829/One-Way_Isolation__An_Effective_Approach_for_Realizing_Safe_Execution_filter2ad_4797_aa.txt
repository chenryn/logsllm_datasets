title:One-Way Isolation: An Effective Approach for Realizing Safe Execution
Environments
author:Weiqing Sun and
Zhenkai Liang and
V. N. Venkatakrishnan and
R. Sekar
One-way Isolation: An Effective Approach for
Realizing Safe Execution Environments(cid:3)
Weiqing Sun
Zhenkai Liang
R. Sekar
Department of Computer Science,
Stony Brook University.
V.N. Venkatakrishnany
Department of Computer Science,
University of Illinois at Chicago.
fwsun,zliang,PI:EMAIL
PI:EMAIL
Abstract
1. Introduction
In this paper, we present an approach for realizing a safe ex-
ecution environment (SEE) that enables users to “try out”
new software (or conﬁguration changes to existing soft-
ware) without the fear of damaging the system in any man-
ner. A key property of our SEE is that it faithfully repro-
duces the behavior of applications, as if they were running
natively on the underlying host operating system. This is ac-
complished via one-way isolation: processes running within
the SEE are given read-access to the environment provided
by the host OS, but their write operations are prevented from
escaping outside the SEE. As a result, SEE processes cannot
impact the behavior of host OS processes, or the integrity of
data on the host OS. Our SEE supports a wide range of
tasks, including: study of malicious code, controlled exe-
cution of untrusted software, experimentation with software
conﬁguration changes, testing of software patches, and so
on. It provides a convenient way for users to inspect sys-
tem changes made within the SEE. If the user does not ac-
cept these changes, they can be rolled back at the click of
a button. Otherwise, the changes can be “committed” so
as to become visible outside the SEE. We provide consis-
tency criteria that ensure semantic consistency of the com-
mitted results. We also develop an efﬁcient technique for
implementing the commit operation. Our implementation
results show that most software, including fairly complex
server and client applications, can run successfully within
the SEE. The approach introduces low performance over-
heads, typically below 10%.
(cid:3)This research is supported in part by an ONR grant N000140110967
and an NSF grant CCR-0208877.
yResearch conducted when the author was a graduate student in the
Department of Computer Science, Stony Brook University.
1.1. Motivating Applications
System administrators and desktop users often encounter
situations where they need to experiment with potentially
unsafe software or system changes. A high-ﬁdelity safe
execution environment (SEE) that can support these activ-
ities, while protecting the system from potentially harmful
effects, will be of signiﬁcant value to these users. Applica-
tions of such SEE include:
(cid:15) Running untrusted software. Often, users execute
downloaded freeware/shareware or mobile code. The
risk of damage to the user’s computer system due to
untrusted code is high, yet a signiﬁcant fraction of
users seem to be willing to take this risk in order to
beneﬁt from the functionality offered by such code. An
SEE can minimize security risks without negating the
functionality beneﬁts provided by such software.
(cid:15) Vulnerability testing. System administrators may be
interested in probing whether a system is susceptible to
the latest email virus, worm or other attacks. A high-
ﬁdelity SEE can allow them to perform such testing
without the risk of compromising production systems.
(cid:15) Software updates/patches. Application of security
patches are routinely delayed in large enterprises in or-
der to allow time for compatibility and interoperability
testing. Such testing is typically done after shutting
down production systems for extended periods, and
hence may be scheduled for weekends and holidays.
In contrast, a high-ﬁdelity SEE can allow testing of
updates to be performed without having to shutdown
production systems. These concerns apply more gen-
erally to software upgrades or installations as well.
(cid:15) System reconﬁguration. Administrators may need to
reconﬁgure software systems, and would ideally like
to “test out” these changes before deploying them on
production systems. This is currently accomplished
manually, by saving backup copies of all ﬁles that may
be modiﬁed during reconﬁguration. An SEE will auto-
mate this process, and moreover, avoid pitfalls such as
overlooking to backup some of the modiﬁed ﬁles.
1.2. SEE Requirements and the Need for New Ap-
proach
In order to support the kinds of applications mentioned
above, an SEE must provide the following features:
(cid:15) Conﬁnement without undue restrictions on functional-
ity. The effects of process execution within an SEE
should not “escape” the SEE and become visible to
normal applications running outside. Otherwise, one
cannot rule out the possibility of SEE processes alter-
ing the operation of other applications running on the
same system or elsewhere in the network. Such con-
ﬁnement can be achieved using access control restric-
tions, e.g., by prohibiting all operations that modify
ﬁles or access the network. However, such restrictions
will prevent most applications from executing success-
fully within an SEE.
(cid:15) Accurate environment reproduction. For SEEs to be
useful in the above applications, it is essential that the
behavior of applications be identical, whether or not
they operate within the SEE. Since the behavior of an
application is determined by its environment (contents
of conﬁguration or data ﬁles, executables, libraries,
etc.), it is necessary to reproduce, as accurately as pos-
sible, the same environment within the SEE as the en-
vironment that exists outside SEE.
(cid:15) Ability to commit results.
In many of the above ap-
plications, including untrusted software execution and
software or system updates, a user would like to re-
tain the results of activities that were successful. Thus,
the SEE must provide a mechanism to “commit” the
results of activities that took place within it. A suc-
cessful commit should have the same effect as if all of
the operations carried out within the SEE actually took
place outside.
Most existing approaches for safe execution do not satisfy
these requirements. For instance, sandboxing techniques
achieve conﬁnement, but do so by severely restricting func-
tionality. Virtual machines (VMs) and related approaches
[3, 36] relax access restrictions, but do not offer any support
for environment reproduction or committing. File version-
ing systems [26, 40, 39, 16, 5, 23, 25, 31, 19] can provide
rollback capabilities, but they don’t provide a mechanism to
discriminate among changes made by different processes,
and hence cannot support selective rollback of the effects of
untrusted process execution.
The concept of isolation has been proposed as a way to
address the problem of effect containment for compromised
processes in [8, 13, 28]. [13] developed the concept of one-
way isolation as an effective means to isolate the effects
of running processes from the point they are compromised
(or suspected of being compromised). They also develop
protocols for realizing one-way isolation in the context of
databases and ﬁle systems. However, they only provide a
high-level treatment, and do not address practical issues that
arise in implementing such an approach for COTS applica-
tions running over commodity OSes.
In our previous work [12], we addressed some of these is-
sues and developed a user-level tool for isolating the effects
of COTS applications on the Linux OS. The focus of that ef-
fort was on untrusted software execution, and on a solution
that was realized entirely at the user level. Such a solution
does not require OS changes or even administrative privi-
lege to install or use the tool. However, in order to achieve
a completely user-land solution, [12] compromises on per-
formance as well as generality. In particular, the approach
suffers from high overheads that can be over 100% in some
instances. Moreover, isolation semantics cannot be faith-
fully reproduced for operations that concern ﬁle meta-data
such as permissions and ownership. For directories, isola-
tion is achieved using an ad-hoc approach that is hard to
implement and provides semantics that is inconsistent with
that of ﬁles. Finally, no systematic solution to the commit
problem is provided. The approach developed in this pa-
per addresses all these drawbacks. Moreover, it generalizes
the approach so that isolation can be provided for non-ﬁle
operations, e.g., certain classes of network accesses.
1.3. Approach Overview
The SEEs described in this paper are based on the con-
cept of one-way isolation. Whereas VMs generally employ
two-way isolation between the host environment and the en-
vironment that exists within a VM, one-way isolation makes
the host environment visible within the SEE. In this sense,
the SEE processes can (and do) see the environment of their
host system, and hence accurate reproduction of environ-
ment is assured. However, the effects of SEE processes
are isolated from outside applications, thereby satisfying the
conﬁnement requirement.
In our approach, an SEE is created to run a process whose
effects are to be shielded from the rest of the system. One
or more such SEEs may be active on the host OS. Any
children created by processes within an SEE will also be
conﬁned to that SEE, and will share the same consistent
view of system state. Typically, a user will start a com-
mand shell within a new SEE, and use this shell to carry out
tasks such as running untrusted programs. She may also run
helper applications, such as image or document viewers, or
arbitrary utility applications to examine the resulting sys-
tem state. Finally, if she wants to accept the changes made
within the SEE, she can commit the results. The commit
process causes the system state, as viewed inside the SEE,
to be merged with the state of the host OS. We present con-
sistency criteria aimed at ensuring the correctness of the re-
sults of the commit process.
Our approach is implemented using interposition at the
system call and virtual ﬁle system layers, and hence does
not require any changes to applications that run inside the
SEE. Even complex tasks such as compilation and installa-
tion of large software packages, and execution of complex
client and server applications can be carried out success-
fully within the SEE. This is because our approach places
few restrictions on operations performed by most applica-
tions.
In particular, no restrictions are placed on ﬁle ac-
cesses, except in the case of access to special devices. Net-
work operations that correspond to “read” operations, such
as querying a name server, can be permitted as well. Net-
work accesses that correspond to “write” operations can be
permitted when the target of the communication satisﬁes
one of the following conditions:
(cid:15) it is an application running within an SEE, possibly on
a different host, or
(cid:15) it is a special-purpose “proxy” that is layered between
the application and the service accessed by it, and can
buffer the write actions until commit time.
The key challenge in implementing such proxies is that even
though they buffer certain operations, they should provide
a consistent view of system state to the SEE applications.
Speciﬁcally, if an SEE process “writes” to such a proxy and
subsequently performs a “read” operation, the proxy should
return the result that would have been returned if the write
operation had actually been carried out.
1.4. Paper Organization
The rest of this paper is organized as follows. Section 2
presents an overview of our approach. Section 3 describes
our ﬁle system proxy, namely, the Isolation File System
(IFS). Section 4 discusses the criteria and the procedure for
committing changes made to the ﬁle system. Other aspects
of our approach are discussed in Section 5. Section 6 pro-
vides an evaluation of the functionality as well as the per-
formance of our approach. Related work is discussed in
Section 7, followed by concluding remarks in Section 8.
2. Design of Secure Execution Environment
The two functions of our SEE are (a) to provide one-way
isolation, and (b) to support commit operation. These two
aspects of SEE are described in more detail below.
2.1. Achieving One-way Isolation
The primary goal of isolation in our approach is effect
containment: preventing the effects of SEE processes from
affecting the operation (or outcome) of processes execut-
ing outside the SEE1. This means that any “read” operation
(i.e., one that queries the system state but does not modify
it) may be performed by SEE processes. It also means that
“write” operations should not be permitted to affect system
state. There are two options in this context: one is to re-
strict the operation, i.e., disallow its execution. The second
option is to redirect the operation to a different resource that
is invisible outside the SEE. Once a write operation is redi-
rected, it is important that subsequent read operations on the
same resource be redirected as well.
By restriction, we mean that an operation is prevented
from execution. An error code may be returned to the pro-
cess, or the operation may be silently suppressed and a suc-
cess code returned. In either case, restriction is easy to im-
plement — we need only know the set of operations that
can potentially alter system state. The main drawback of
restriction is that it will likely prevent applications from ex-
ecuting successfully. For instance, if a program writes a
ﬁle, it expects to get back the same content at a later point
in the program when the ﬁle is read. However, an approach
based on restriction cannot do this, and hence most non-
trivial applications will fail to run successfully under such
restriction. For this reason, restriction is a choice of last
resort in our approach.
By redirection, we mean that any operation that modiﬁes
some component of the host environment is instead redi-
rected to a different component that is not accessed by the
host OS processes. For instance, when an SEE process tries
to modify a ﬁle, a copy of the original ﬁle may be created
in a “private” area of the ﬁle system, and the modiﬁcation
operation redirected to this copy. Redirection is intended
to provide a consistent view of system state to a process,
thereby allowing it to run successfully.
Redirection can be static or dynamic. Static redirection
requires the source and target objects to be speciﬁed man-
ually. It is ideal for network operations. For instance, one
may statically specify that operations to bind a socket to a
port p should be redirected to an alternate port p0. Simi-
1Note that we are interested in conﬁnement [11] from the point of view
of system integrity, rather than conﬁdentiality. As such, we do not deal
with with issues such as covert channels.
larly, one may specify that operations to connect to a port
p on host h should be redirected to host h0 (which may
be the same as h) and port p0. By using such redirection,
we can build distributed SEEs, where processes executing
within SEEs on multiple hosts can communicate with each
other. Such distributed SEEs are particularly useful for safe
execution of a network server application, whose testing
would typically require accesses by nonlocal client appli-
cations. (Note, however, that this approach for distributed
SEEs works only when all cross-SEE communications take
place directly between the SEE processes, and not through
other means, e.g., indirect communication through a shared
NFS directory.)
Static redirection becomes infeasible if the number of
possible targets is too large to be enumerated in advance.
For instance, it is hard to predict the ﬁles that may be ac-
cessed by an arbitrary application. Moreover, there are
dependencies among operations on different ﬁle objects,
e.g., an operation to create a ﬁle has the indirect effect of
changing the contents of the directory in which the ﬁle is
created. Simply redirecting an access on the ﬁle, without
correspondingly modifying accesses of the directory, won’t
work. To handle such complexities, our approach supports