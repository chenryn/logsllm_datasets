and should not be interpreted as representing the ofﬁcial policies,
either expressed or implied, of the U.S. Army Research Labora-
tory, the U.S. Government, the U.K. Ministry of Defence, or the
U.K. Government. The U.S. and U.K. Governments are autho-
rized to reproduce and distribute reprints for Government purposes
notwithstanding any copyright notation hereon.
We thank Roberto Tamassia for useful discussions.
7. REFERENCES
[1] https://www.openssl.org/docs/crypto/hmac.html.
[2] http://www.algorithmic-solutions.com/leda/index.htm.
[3] http://www.dis.uniroma1.it/challenge9/.
[4] M. Ajtai. Generating Hard Instances of Lattice Problems
(extended abstract). In STOC, pp. 99–108, 1996.
[5] A. Anagnostopoulos, M. T. Goodrich, and R. Tamassia.
Persistent Authenticated Dictionaries and Their
Applications. In ISC, pp. 379–393. 2001.
[6] G. D. Battista, P. Eades, R. Tamassia, and I. G. Tollis. Graph
Drawing: Algorithms for the Visualization of Graphs.
Prentice Hall PTR, Upper Saddle River, NJ, USA, 1998
[7] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M.
Virza. SNARKs for C: Verifying Program Executions Succin
-ctly and in Zero Knowledge. In CRYPTO, pp. 90–108, 2013.
[8] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct
Non-Interactive Zero Knowledge for a von Neumann
Architecture. In USENIX Security, 2014.
[9] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From
Extractable Collision Resistance to Succinct Non-interactive
Arguments of Knowledge, and Back Again. In ITCS, pp.
326–349, 2012.
[10] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive
Composition and Bootstrapping for SNARKS and
Proof-carrying Data. In STOC, pp. 111–120, 2013.
[11] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and
O. Paneth. Succinct Non-interactive Arguments via Linear
Interactive Proofs. In TCC, pp. 315–333, 2013.
[12] B. Braun, A. J. Feldman, Z. Ren, S. T. V. Setty, A. J.
Blumberg, and M. Walﬁsh. Verifying Computations with
State. In SOSP, pp. 341–357, 2013.
[13] D. Catalano and D. Fiore. Vector Commitments and Their
Applications. In PKC, pp. 55–72, 2013.
[14] K.-M. Chung, Y. T. Kalai, and S. P. Vadhan. Improved
Delegation of Computation Using Fully Homomorphic
Encryption. In CRYPTO, pp. 483–501, 2010.
[15] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein.
Introduction to Algorithms (Vol. 3.). MIT Press, 2009.
[16] J. Fakcharoenphol. Planar Graphs, Negative Weight Edges,
Shortest Paths, and Near Linear Time. In Journal of
Computer and System Sciences, 72(5):868-889, 2006.
[17] E. Fox-Epstein, S. Mozes, P. M. Phothilimthana, and
C. Sommer. Short and Simple Cycle Separators in Planar
Graphs. In ALENEX, pp. 26–40, 2013.
[18] R. Gennaro, C. Gentry, and B. Parno. Non-interactive
Veriﬁable Computing: Outsourcing Computation to
Untrusted Workers. In CRYPTO, pp. 465–482, 2010.
[19] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic
Span Programs and Succinct NIZKs without PCPs. In
EUROCRYPT, pp. 626–645, 2013.
[20] M. T. Goodrich, R. Tamassia, and N. Triandopoulos.
Efﬁcient Authenticated Data Structures for Graph
Connectivity and Geometric Search Problems. Algorithmica,
60(3):505–552, 2011.
[21] A. E. Kosba, D. Papadopoulos, C. Papamanthou, M. F.
Sayed, E. Shi, and N. Triandopoulos. TrueSet: Faster
Veriﬁable Set Computations. In USENIX Security, 2014.
[22] R. J. Lipton and R. E. Tarjan. A Separator Theorem for
Planar Graphs. SIAM Journal on Applied Mathematics,
36(2):177–189, 1979.
[23] R. C. Merkle. A Certiﬁed Digital Signature. In CRYPTO, pp.
218–238, 1990.
[24] S. Micali. Computationally Sound Proofs. SIAM Journal on
Computing, 30(4):1253–1298, 2000.
[25] D. Micciancio and C. Peikert. Hardness of SIS and LWE
with small parameters. In CRYPTO, pp. 21–39, 2013.
[26] D. Micciancio and O. Regev. Lattice-based Cryptography. In
Post-quantum cryptography, pp. 147–191, 2009.
[27] C. Papamanthou, E. Shi, R. Tamassia, and K. Yi. Streaming
Authenticated Data Structures. In EUROCRYPT, pp.
353–370, 2013.
[28] C. Papamanthou and R. Tamassia. Time and Space Efﬁcient
Algorithms for Two-party Authenticated Data Structures. In
ICICS, pp. 1–15, 2007.
[29] C. Papamanthou, R. Tamassia, and N. Triandopoulos.
Optimal Veriﬁcation of Operations on Dynamic Sets. In
CRYPTO, pp. 91–110, 2011.
[30] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio:
Nearly Practical Veriﬁable Computation. In SSP, pp.
238–252, 2013.
[31] R. M. McConnell, K. Mehlhorn, S. Näher, and P. Schweitzer.
Certifying Algorithms. Computer Science Review,
5(2):119–161, 2011.
[32] S. T. V. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and
M. Walﬁsh. Resolving the Conﬂict Between Generality and
Plausibility in Veriﬁed Computation. In EUROSYS, pp.
71–84, 2013.
[33] S. T. V. Setty, R. McPherson, A. J. Blumberg, and
M. Walﬁsh. Making Argument Systems for Outsourced
Computation Practical (sometimes). In NDSS, 2012.
[34] R. Tamassia. Authenticated Data Structures. In ESA, pp. 2–5,
2003.
[35] R. Tamassia and N. Triandopoulos. Certiﬁcation and
Authentication of Data Structures. In AMW, 2010.
[36] V. Vu, S. T. V. Setty, A. J. Blumberg, and M. Walﬁsh. A
Hybrid Architecture for Interactive Veriﬁable Computation.
In SSP, pp. 223–237, 2013.
[37] M. L. Yiu, Y. Lin, and K. Mouratidis. Efﬁcient Veriﬁcation
of Shortest Path Search via Authenticated Hints. In ICDE,
pp. 237–248, 2010.
(dE , s, t, p) :
FG =
∃{[ei = (ui, vi), πei ], [dui , πui ], [dvi , πvi ]}m
(1) 1 ← VE .verify(uin + vi, 1, πei , dE , pk) for i = 1, . . . , m ;
(2) V.digest(S, pk) = dig ;
(3) 1 ← V.verify(ui, dui , πui , dig, pk) and 1 ← V.verify(vi, dvi , πvi , dig, pk) for i = 1, . . . , m ;
(4) S[s] = 0 ∧ S[t] = |p| ;
(5) S[vi] ≤ S[ui] + 1 for i = 1, . . . , m .
i=1 and S and dig such that :
Figure 9: The language for the dynamic updates. To support dynamic updates, we need to build a SNARK for this language instead of 1.
Appendix
.
q
tree T set λ(v) = (cid:80)
Algorithm pk ← genkey(1k, M )
Set N = M · max, where max is the maximum entry that can appear
in vector S. Call {q, m} ← parameters(1k, N ). Set pk = {L, R, q},
where L, R are matrices picked uniformly at random from Zk×m
Algorithm d(S) ← digest(S, pk)
Let T be a binary tree built on top of vector S. For each node v of the
i∈range(v) S[i]Lv(i), where Lv(i) is the partial
label of node v with respect to i and range(v) is the range of node v,
both deﬁned in [27]. Finally set d(S) = λ(), where  is the root of T .
Algorithm d(S) ← update(d(S), i, α, pk)
Set d(S) = d(S) +L(i)(α− S[i]), where L(i) is the partial label of
the root  with respect to i (deﬁned in [27]).
Algorithm {S[i], Πi} ← query(i, S, pk)
Let v(cid:96), . . . , v1 be the path in T from node i to the child v1
of the root  of T . Let also w(cid:96), . . . , w1 be the sibling nodes
of v(cid:96), . . . , v1.
Proof Πi contains the ordered sequence of pairs
{(λ(v(cid:96)), λ(w(cid:96))), (λ(v(cid:96)−1), λ(w(cid:96)−1)), . . . , (λ(v1), λ(w1))}.
Algorithm{1, 0} ← verify(i, S[i], Πi, d(S), pk)
Parse proof Πi as {(λ(v(cid:96)), λ(w(cid:96))), . . . , (λ(v1), λ(w1))}. If λ(v(cid:96)) (cid:54)=
S[i]1 or λ(v(cid:96)), λ(w(cid:96)) (cid:54)= [N ]m, output 0. Otherwise compute the val-
ues y(cid:96)−1, y(cid:96)−2, . . . , y0 as yi = L·λ(vi+1)+R·λ(wi+1) (if vi+1 is vi’s
left child) or yi = R·λ(vi+1)+L·λ(wi+1) (if vi+1 is vi’s right child).
For i = (cid:96) − 1, . . . , 1, if f (λ(vi)) (cid:54)= yi or λ(vi), λ(wi) /∈ [N ]m out-
put 0. If f (d(S)) (cid:54)= y0, output 0 (function f (.) takes as input a radix-2
representation and returns the respective number, see [27]). Output 1.
{q, m} ← parameters(1k, N ).
Let q be a prime and k ∈ N.
min{q, 2
such that q/(cid:112)(cid:100)log q(cid:101) ≥ √
√
0.0086·k log q}. Set m = k(cid:100)log q(cid:101).
Find smallest q and k
2k log q <
2 · N · k0.50001 and
√
Figure 10: The additively-homomorphic veriﬁable vector scheme,
adjusted from [27]. Note that the procedure parameters is called
by algorithm genkey.
DEFINITION 3. We say that a VC scheme for graphs V is cor-
rect if, for all graphs G, for all k ∈ N, for all ekG, vkG output by
algorithm genkey, for all queries q on G and for all πq, α output
by algorithm compute(q, ekG), it is 1 ← verify(πq, q, α, vkG).
We say that a VC scheme V is secure if, for all graphs G, for all
k ∈ N, for all ekG, vkG output by algorithm genkey and for any
PPT adversary Adv it is
 {q, πq, α} ← Adv(ekG, vkG);
1 ← verify(πq, q, α, vkG);
α is incorrect.
Pr
 ≤ neg(k) .
DEFINITION 4
(VECTOR COMMITMENT). A vector commit-
ment scheme V has ﬁve PPT algorithms: (1) pk ← genkey(1k, M ):
On input the security parameter k and the vector size M, it outputs
the public key pk; (2) d(S) ← digest(S, pk): On input vector S and
pk, it outputs the digest d(S); (3) d(S) ← update(d(S), i, α, pk):
On input vector S, (i, α) and pk, it sets S[i] = α and outputs the
new digest d(S); (4) (S[i], Πi) ← query(i, S, pk): On input an in-
dex i and pk, it returns the value S[i], along with a proof Πi (run
by prover); (5) {1, 0} ← verify(i, S[i], Πi, d(S), pk): On input an
index i, a value S[i], a proof Πi, a digest d(S) and pk, it outputs
either 1 or 0 (run by veriﬁer);
We say that a VCS scheme V is correct if, for all k, M ∈ N, for
all pk output by genkey, for all S and for all d(S) output by algo-
rithm digest(S, pk) (or update(d(S), i, α, pk)) and for all S[i], Πi
output by query(i, S, pk), it is 1 ← verify(i, S[i], Πi, d(S), pk).
We say that a VCS scheme is secure if for all k, M ∈ N, for all
pk output by algorithm genkey, for all S and for all d(S) output by
algorithm digest(S, pk) (or algorithm update(d(S), i, α, pk)) and
for any PPT adversary Adv it is
 {i, Π, α} ← Adv(1k, pk);
1 ← verify(i, α, Π, d(S), pk);
S[i] (cid:54)= α.
Pr
 ≤ neg(k) .
DEFINITION 5. We say that a SNARK G is correct if, for all
k ∈ N, for all NP languages L, for all ekL and vkL output by
genkey, for all x ∈ L, it is 1 ← verify(compute(x, ekL), x, vkL).
We say that a SNARK G is secure if, for all k ∈ N, for all NP
languages L, for all ekL and vkL output by algorithm genkey and
for any PPT adversary Adv it is for all x ∈ L, it is
w /∈ RL(x)
Table 7: Proof-computation time (seconds).
Strawman
10
100
1,000
10,000
100,000
200,000
0.01
0.01
0.01
0.01
0.01
0.01
PINOCCHIO
BFS
32.072
21,000∗
2,400,000∗
240,000,000∗
25,000,000,000∗
98,000,000,000∗
Certifying
Algorithm Separator
Planar
0.044
0.477
5.502
56.02
560∗
1120∗
0.853
4.616
11.425
22.223
66.374
93.853
A SNARK should also have an extractor: I.e., for any polynomial-
sized prover Prv, there exists an extractor Ext such that for any
statement x, auxiliary information µ, the following holds:
1 ← verify(πx, x, vkL);
x /∈ L.
 {πx, x} ← Adv(1k, ekL, vkL);
πx ← Prv(ekL, x, µ)
1 ← verify(πx, x, vkL)
w ← Ext(ekL, vkL, x, πx)
{ekL, vkL} ← genkey(1k, L)
∧
 ≤ neg(k) .
 ≤ negl(k) .
Pr
Pr