99.01%
50.36%
36.05%
100%
4.17%
8.23%
99.98%
97.44%
# logs
308,144
602,715
134,859
228,428
238,577
302,545
8,355,045
8,323,800
8,243,034
8,011,739
7,829,530
8,152,629
999,160
1,685
0
8,605
41,769
20,044
4,560
148,885
4,213
80,934
40,344
0
477
867
109
3,951,130
37,363,395
3,951,923
38,344,585
3,951,523
38,344,430
Basic GC
# logs
(%)
Execution Unit
# logs
(%)
Temp ﬁle
Application Logs
# logs
(%)
Data Unit
(%)
26.57%
61.18%
10.14%
11.89%
24.5%
23.75%
96.29%
98.70%
98.68%
90.02%
98.69%
96.37%
30.64%
10.52%
0.00%
18.30%
45.79%
38.62%
62.29%
100%
4.26%
62.95%
50.36%
0%
172,688
197,718
83,595
61,100
1,403
108,470
7,886,531
7,812,483
7,731,299
7,508,254
7,209,876
7,629,688
371,336
5
0
231
970
3,156
684
72
4,191
32,914
40,344
0
# logs
-
-
-
-
14.89%
20.01% 108,172
6.29%
3.18%
0.14%
8.51%
90,668
90.90% 259,139
92.64% 166,968
92.56% 206,786
84.36% 326,705
90.88% 161,523
90.19% 224,224
11.39%
0.03%
0%
0.49%
1.06%
6.08%
9.34%
0.05%
4.24%
25.60%
50.36%
0%
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
(%)
-
10.98%
-
-
-
7.11%
2.99%
1.98%
2.48%
3.67%
2.04%
2.65%
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
1.65%
477
867
109
100%
0.4%
8.23%
99.98%
97.44% 36,865,575
490,023
100%
0.4%
8.23%
12.40%
96.14% 631,115
Table 5: Number of log entries after garbage collection.
Servers
UI
Programs
Applications
Temp
Log
Data unit
Sshd-5.9
Sendmail-8.12.11
Proftpd-1.3.4
Apache-2.2.21
Cherokee-1.2.1
Squid-3.2.6
Gmediaserver-0.13.0
MySQL-5.1.66
Wget-1.13
W3m-0.5.2
Pine-4.64
MidnightCommand-4.6.1
Vim-7.3
Bash-4.2
Firefox-11
Yafc-1.1.1
Pidgin-2.10.6
Xpdf-3.03
Mplayer-1.1
Audacious-2.5.4
N
N
N
N
N
Y
N
Y
N
Y
N
Y
Y
N
Y
N
Y
Y
Y
Y
Y
N
Y
Y
Y
Y
Y
Y
N
Y
N
Y
Y
Y
Y
N
Y
N
N
N
Table 4: Application description
N
N
N
N
N
N
N
Y
N
N
N
N
N
N
N
N
N
N
N
N
6.1 Effectiveness
Regular User Systems. In the ﬁrst experiment, we collect audit
logs from machines of ﬁve different users (with the same system
image). Each log is collected from one day’s execution. The users
have different usage patterns. User1 is a software developer who
used Vim editor and compilers a lot. He also downloaded and in-
stalled several tools during the one-day experiment. User2 ran a
web server and a public ftp server. User3 mostly used Firefox
for web surﬁng and Xpdf to view PDF ﬁles. He also used the
Pidgin chat client to communicate with friends. User4 watched
a set of movies using Mplayer and also used Audacious to
listen to music. User5 used the system in the console mode. He
used text-based applications such as W3m for the Web and pine
for emails.
We ran LogGC at the end of the one-day execution. The re-
sults are presented in Table 5. The third column shows the total
number of log entries in each original audit log. Columns 4 and
5 present the reduced log size (and percentage) when we perform
the basic GC algorithm (Section 2), except that we do not garbage
collect any dead-end event, in order to support forward analysis
(Section 3). The results in the ﬁrst 5 rows show that the basic al-
gorithm is not very effective. It can reduce 35%/40% for the logs
of User1/User5 because they ran short-running applications hence
false dependences, which would unnecessarily prevent garbage col-
lection, are less likely.
Columns 6 and 7 show log reduction when we use execution
partitioning for long running applications on top of the basic algo-
rithm. In the ﬁrst ﬁve rows, we can remove an average of 60.45%
of the audit logs. In columns 8 and 9, we additionally garbage-
collect temporary ﬁle deletions, which also enables collecting the
events that they depend on (Section 3). LogGC reduces an average
of 76.25% of the original log entries. In columns 10 and 11, we re-
move the redundant entries captured in application logs (Section 5).
The results show that LogGC reduces 91.49% of the original logs.
The last two columns show log reduction when we use data unit
partitioning (Section 4.1). Only User2 used mysql as the backend
for his web server. LogGC can reduce half of the remaining entries
for User2. Finally, the average size of the remaining logs (of the
ﬁve users) is only 7.11% of the original size, indicating an order of
magnitude of reduction.
Server Systems. In the next experiment, we focus on evaluating
LogGC on server system logs. We use RUBiS [5] which is an
auction service similar to eBay. We setup the auction site using
the default conﬁguration with apache as frontend and mysql as
backend. In our setup, both apache and mySQL are located in the
same machine. After initialization, we have 9 tables in the database
which contain 33,721 items for sale in 20 categories. This database
is acquired from [5]. Then we use the client emulator that acts as
users (buyers or sellers) of the bidding system. The client emulator
uses 27 pre-deﬁned transitions such as user registration, item reg-
istration, item browsing by category, bidding, buying and leaving
1013comments during execution. We use all 5 different setups for client
emulation provided by RUBiS. Each execution emulates 240 users
performing 60,000 to 70,000 transitions and lasts 20 to 30 minutes.
We acquire the audit log of the bidding server after each execution
and apply LogGC .
The “Web server benchmark” rows in Table 5 show the results.
We can observe that most GC strategies are not as effective as
on user systems. With “execution partitioning”, “temp ﬁle” and
“application log” strategies, we can reduce only 10% of the logs
(columns 10 and 11) even though both apache and mysql have
independent execution units, temporary ﬁles, and application logs.
This is because the executions heavily access the index and data
ﬁles in the database such that most execution units become reach-
able through ﬁle-level dependences. Columns 12 and 13 show the
reduced log size with data unit partitioning. Only 2.65% of the log
entries need to be preserved on average, corresponding to a 37-time
reduction.
Per Application Results. We also present the results for individ-
ual applications. They are aggregated from the aforementioned
user system executions and server executions. We observe that the
events from some applications can be completely garbage-collected
such as Mplayer and Xpdf. Mplayer is a video player and it
interacts with the screen and the sound card. But its execution does
not affect system execution in the future. Similarly, Xpdf only
displays PDF ﬁles on the screen. On the other hand, we cannot
garbage collect any events from Yafc, an ftp client, because the
user downloaded ﬁles using Yafc and kept all the ﬁles in the sys-
tem. Similar explanation applies to W3m and Wget.
6.2 Performance
Table 6 shows the performance of LogGC. The experiments were
performed on an Intel Core i7-3770 CPU with 4GB memory run-
ning Linux 2.6.35. The execution time of LogGC is mainly di-
vided to two parts: the log parsing time and the GC time. The table
shows that LogGC is reasonably efﬁcient. It processes 3GB of logs
in about 2 minutes, with parsing time being the dominant factor.
Table 7 shows the runtime overhead incurred by data unit instru-
mentation, using two popular benchmarks: RUBiS and SysBench.
The results show that the runtime overhead is very low.
Log
User1
User2
User3
User4
User5
Rubis1
Rubis2
Rubis3
Rubis4
Rubis5
Parsing time (s)