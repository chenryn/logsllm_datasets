server {
listen 80;
location / {
proxy_pass http://my_backend;
}
}
}
Discussion
The zone sync module is an NGINX Plus exclusive feature that
enables NGINX Plus to truly cluster. As shown in the configuration,
you must set up a stream server configured as the zone_sync. In the
example, this is the server listening on port 9000. NGINX Plus com‐
municates with the rest of the servers defined by the
zone_sync_server directive. You can set this directive to a domain
name that resolves to multiple IP addresses for dynamic clusters, or
statically define a series of zone_sync_server directives. You should
restrict access to the zone sync server; there are specific SSL/TLS
directives for this module for machine authentication. The benefit of
configuring NGINX Plus into a cluster is that you can synchronize
shared memory zones for rate limiting, sticky learn sessions, and the
key-value store. The example provided shows the sync parameter
tacked on to the end of a sticky learn directive. In this example, a
user is bound to an upstream server based on a cookie named ses
sion. Without the zone sync module if a user makes a request to a
12.5 State Sharing with Zone Sync | 135
different NGINX Plus server, he could lose his session. With the
zone sync module, all of the NGINX Plus servers are aware of the
session and to which upstream server it’s bound.
136 | Chapter 12: High-Availability Deployment Modes
CHAPTER 13
Advanced Activity Monitoring
13.0 Introduction
To ensure that your application is running at optimal performance
and precision, you need insight into the monitoring metrics about
its activity. NGINX Plus offers an advanced monitoring dashboard
and a JSON feed to provide in-depth monitoring about all requests
that come through the heart of your application. The NGINX Plus
activity monitoring provides insight into requests, upstream server
pools, caching, health, and more. This chapter details the power and
possibilities of the NGINX Plus dashboard, the NGINX Plus API,
and the Open Source stub status module.
13.1 Enable NGINX Open Source Stub Status
Problem
You need to enable basic monitoring for NGINX.
Solution
Enable the stub_status module in a location block within a
NGINX HTTP server:
location /stub_status {
stub_status;
allow 127.0.0.1;
deny all;
137
# Set IP restrictions as appropriate
}
Test your configuration by making a request for the status:
$ curl localhost/stub_status
Active connections: 1
server accepts handled requests
1 1 1
Reading: 0 Writing: 1 Waiting: 0
Discussion
The stub_status module enables some basic monitoring of the
Open Source NGINX server. The information that is returned pro‐
vides insight into the number of active connections as well as the
total connections accepted, connections handled, and requests
served. The current number of connections being read, written, or
in a waiting state is also shown. The information provided is global
and is not specific to the parent server where the stub_status
directive is defined. This means that you can host the status on a
protected server. This module provides active connection counts as
embedded variables for use in logs and elsewhere. These variables
are $connections_active, $connections_reading, $connec
tions_writing, and $connections_waiting.
13.2 Enabling the NGINX Plus Monitoring
Dashboard Provided by NGINX Plus
Problem
You require in-depth metrics about the traffic flowing through your
NGINX Plus server.
Solution
Utilize the real-time activity monitoring dashboard:
server {
# ...
location /api {
api [write=on];
# Directives limiting access to the API
# See chapter 7
}
138 | Chapter 13: Advanced Activity Monitoring
location = /dashboard.html {
root /usr/share/nginx/html;
}
}
The NGINX Plus configuration serves the NGINX Plus status moni‐
toring dashboard. This configuration sets up an HTTP server to
serve the API and the status dashboard. The dashboard is served as
static content out of the /usr/share/nginx/html directory. The dash‐
board makes requests to the API at /api/ in order to retrieve and dis‐
play the status in real time.
Discussion
NGINX Plus provides an advanced status monitoring dashboard.
This status dashboard provides a detailed status of the NGINX sys‐
tem, such as number of active connections, uptime, upstream server
pool information, and more. For a glimpse of the console, see
Figure 13-1.
The landing page of the status dashboard provides an overview of
the entire system. Clicking into the Server Zones tab lists details
about all HTTP servers configured in the NGINX configuration,
detailing the number of responses from 1XX to 5XX and an overall
total as well as requests per second and the current traffic through‐
put. The Upstream tab details upstream server status, as if it were in
a failed state, how many requests it has served, and a total of how
many responses have been served by status code, as well as other
statistics such as how many health checks it has passed or failed. The
TCP/UDP Zones tab details the amount of traffic flowing through
the TCP or UDP streams and the number of connections. The
TCP/UDP Upstream tab shows information about how much each
of the upstream servers in the TCP/UDP upstream pools is serving,
as well as health check pass and fail details and response times. The
Caches tab displays information about the amount of space utilized
for cache; the amount of traffic served, written, and bypassed; as
well as the hit ratio. The NGINX status dashboard is invaluable in
monitoring the heart of your applications and traffic flow.
13.2 Enabling the NGINX Plus Monitoring Dashboard Provided by NGINX Plus | 139
Figure 13-1. The NGINX Plus status dashboard
Also See
NGINX Plus Status Dashboard Demo
13.3 Collecting Metrics Using the NGINX Plus
API
Problem
You need API access to the detail metrics provided by the NGINX
Plus status dashboard.
Solution
Utilize the RESTful API to collect metrics. The examples pipe the
output through json_pp to make them easier to read:
$ curl "demo.nginx.com/api/3/" | json_pp
[
"nginx",
"processes",
"connections",
"ssl",
"slabs",
"http",
"stream"
]
140 | Chapter 13: Advanced Activity Monitoring
The curl call requests the top level of the API, which displays other
portions of the API.
To get information about the NGINX Plus server, use the /api/{ver
sion}/nginx URI:
$ curl "demo.nginx.com/api/3/nginx" | json_pp
{
"version" : "1.15.2",
"ppid" : 79909,
"build" : "nginx-plus-r16",
"pid" : 77242,
"address" : "206.251.255.64",
"timestamp" : "2018-09-29T23:12:20.525Z",
"load_timestamp" : "2018-09-29T10:00:00.404Z",
"generation" : 2
}
To limit information returned by the API, use arguments:
$ curl "demo.nginx.com/api/3/nginx?fields=version,build" \
| json_pp
{
"build" : "nginx-plus-r16",
"version" : "1.15.2"
}
You can request connection statistics from the /api/{version}/
connections URI:
$ curl "demo.nginx.com/api/3/connections" | json_pp
{
"active" : 3,
"idle" : 34,
"dropped" : 0,
"accepted" : 33614951
}
You can collect request statistics from the /api/{version}/http/
requests URI:
$ curl "demo.nginx.com/api/3/http/requests" | json_pp
{
"total" : 52107833,
"current" : 2
}
You can retrieve statistics about a particular server zone using
the /api/{version}/http/server_zones/{httpServerZoneName}
URI:
13.3 Collecting Metrics Using the NGINX Plus API | 141
$ curl "demo.nginx.com/api/3/http/server_zones/hg.nginx.org" \
| json_pp
{
"responses" : {
"1xx" : 0,
"5xx" : 0,
"3xx" : 938,
"4xx" : 341,
"total" : 25245,
"2xx" : 23966
},
"requests" : 25252,
"discarded" : 7,
"received" : 5758103,
"processing" : 0,
"sent" : 359428196
}
The API can return any bit of data you can see on the dashboard. It
has depth and follows a logical pattern. You can find links to resour‐
ces at the end of this recipe.
Discussion
The NGINX Plus API can return statistics about many parts of the
NGINX Plus server. You can gather information about the NGINX
Plus server, its processes, connections, and slabs. You can also find
information about http and stream servers running within NGINX,
including servers, upstreams, upstream servers, and key-value
stores, as well as information and statistics about HTTP cache
zones. This provides you or third-party metric aggregators with an
in-depth view of how your NGINX Plus server is performing.
Also See
NGINX HTTP API Module Documentation
NGINX API Swagger UI
142 | Chapter 13: Advanced Activity Monitoring
CHAPTER 14
Debugging and Troubleshooting
with Access Logs, Error Logs, and
Request Tracing
14.0 Introduction
Logging is the basis of understanding your application. With
NGINX you have great control over logging information meaning‐
ful to you and your application. NGINX allows you to divide access
logs into different files and formats for different contexts and to
change the log level of error logging to get a deeper understanding
of what’s happening. The capability of streaming logs to a central‐
ized server comes innately to NGINX through its Syslog logging
capabilities. In this chapter, we discuss access and error logs, stream‐
ing over the Syslog protocol, and tracing requests end to end with
request identifiers generated by NGINX.
14.1 Configuring Access Logs
Problem
You need to configure access log formats to add embedded variables
to your request logs.
Solution
Configure an access log format:
143
http {
log_format geoproxy
'[$time_local] $remote_addr '
'$realip_remote_addr $remote_user '
'$request_method $server_protocol '
'$scheme $server_name $uri $status '
'$request_time $body_bytes_sent '
'$geoip_city_country_code3 $geoip_region '
'"$geoip_city" $http_x_forwarded_for '
'$upstream_status $upstream_response_time '
'"$http_referer" "$http_user_agent"';
...
}
This log format configuration is named geoproxy and uses a num‐
ber of embedded variables to demonstrate the power of NGINX log‐
ging. This configuration shows the local time on the server when the
request was made, the IP address that opened the connection, and
the IP of the client as NGINX understands it per geoip_proxy or
realip_header instructions. $remote_user shows the username of
the user authenticated by basic authentication, followed by the
request method and protocol, as well as the scheme, such as HTTP
or HTTPS. The server name match is logged as well as the request
URI and the return status code. Statistics logged include the pro‐
cessing time in milliseconds and the size of the body sent to the cli‐
ent. Information about the country, region, and city are logged. The
HTTP header X-Forwarded-For is included to show if the request is
being forwarded by another proxy. The upstream module enables
some embedded variables that we’ve used that show the status
returned from the upstream server and how long the upstream
request takes to return. Lastly we’ve logged some information about
where the client was referred from and what browser the client is
using. The log_format directive is only valid within the HTTP con‐
text.
This log configuration renders a log entry that looks like the follow‐
ing:
[25/Nov/2016:16:20:42 +0000] 10.0.1.16 192.168.0.122 Derek
GET HTTP/1.1 http www.example.com / 200 0.001 370 USA MI
"Ann Arbor" - 200 0.001 "-" "curl/7.47.0"
To use this log format, use the access_log directive, providing a
logfile path and the format name geoproxy as parameters:
server {
access_log /var/log/nginx/access.log geoproxy;
144 | Chapter 14: Debugging and Troubleshooting with Access Logs, Error Logs, and Request
Tracing
...
}
The access_log directive takes a logfile path and the format name
as parameters. This directive is valid in many contexts and in each
context can have a different log path and or log format.
Discussion
The log module in NGINX allows you to configure log formats for
many different scenarios to log to numerous logfiles as you see fit.
You may find it useful to configure a different log format for each
context, where you use different modules and employ those mod‐
ules’ embedded variables, or a single, catchall format that provides
all the information you could ever want. It’s also possible to format
the log in JSON or XML. These logs will aid you in understanding
your traffic patterns, client usage, who your clients are, and where
they’re coming from. Access logs can also aid you in finding lag in
responses and issues with upstream servers or particular URIs.
Access logs can be used to parse and play back traffic patterns in test
environments to mimic real user interaction. There’s limitless possi‐
bility for logs when troubleshooting, debugging, or analyzing your
application or market.
14.2 Configuring Error Logs
Problem
You need to configure error logging to better understand issues with
your NGINX server.
Solution
Use the error_log directive to define the log path and the log level:
error_log /var/log/nginx/error.log warn;
The error_log directive requires a path; however, the log level is
optional. This directive is valid in every context except for if state‐
ments. The log levels available are debug, info, notice, warn, error,
crit, alert, or emerg. The order in which these log levels were
introduced is also the order of severity from least to most. The
debug log level is only available if NGINX is configured with the --
with-debug flag.
14.2 Configuring Error Logs | 145
Discussion
The error log is the first place to look when configuration files are
not working correctly. The log is also a great place to find errors
produced by application servers like FastCGI. You can use the error
log to debug connections down to the worker, memory allocation,
client IP, and server. The error log cannot be formatted. However, it
follows a specific format of date, followed by the level, then the mes‐
sage.
14.3 Forwarding to Syslog
Problem
You need to forward your logs to a Syslog listener to aggregate logs
to a centralized service.
Solution
Use the access_log and error_log directives to send your logs to a
Syslog listener:
error_log syslog:server=10.0.1.42 debug;
access_log syslog:server=10.0.1.42,tag=nginx,severity=info
geoproxy;
The syslog parameter for the error_log and access_log directives
is followed by a colon and a number of options. These options
include the required server flag that denotes the IP, DNS name, or
Unix socket to connect to, as well as optional flags such
as facility, severity, tag, and nohostname. The server option
takes a port number, along with IP addresses or DNS names. How‐
ever, it defaults to UDP 514. The facility option refers to the
facility of the log message defined as one of the 23 defined in the
RFC standard for Syslog; the default value is local7. The tag option
tags the message with a value. This value defaults to nginx.
severity defaults to info and denotes the severity of the message
being sent. The nohostname flag disables adding the hostname field
into the Syslog message header and does not take a value.
146 | Chapter 14: Debugging and Troubleshooting with Access Logs, Error Logs, and Request
Tracing
Discussion
Syslog is a standard protocol for sending log messages and collect‐
ing those logs on a single server or collection of servers. Sending
logs to a centralized location helps in debugging when you’ve got
multiple instances of the same service running on multiple hosts.
This is called aggregating logs. Aggregating logs allows you to view
logs together in one place without having to jump from server to
server and mentally stitch together logfiles by timestamp. A com‐
mon log aggregation stack is ElasticSearch, Logstash, and Kibana,
also known as the ELK Stack. NGINX makes streaming these logs to
your Syslog listener easy with the access_log and error_log direc‐
tives.
14.4 Request Tracing
Problem
You need to correlate NGINX logs with application logs to have an
end-to-end understanding of a request.
Solution
Use the request identifying variable and pass it to your application
to log as well:
log_format trace '$remote_addr - $remote_user [$time_local] '