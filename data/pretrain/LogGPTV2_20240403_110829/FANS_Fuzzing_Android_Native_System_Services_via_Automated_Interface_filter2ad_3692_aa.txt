title:FANS: Fuzzing Android Native System Services via Automated Interface
Analysis
author:Baozheng Liu and
Chao Zhang and
Guang Gong and
Yishun Zeng and
Haifeng Ruan and
Jianwei Zhuge
FANS: Fuzzing Android Native System Services
via Automated Interface Analysis
Baozheng Liu1,2∗, Chao Zhang1,2, Guang Gong3,
Yishun Zeng1,2, Haifeng Ruan4, Jianwei Zhuge1,2
1Institute of Network Science and Cyberspace, Tsinghua University PI:EMAIL
2Beijing National Research Center for Information Science and Technology PI:EMAIL
3Alpha Lab, 360 Internet Security Center 4Department of Computer Science and Technology, Tsinghua University
Abstract
1
Introduction
Android native system services provide essential supports and
fundamental functionalities for user apps. Finding vulnerabil-
ities in them is crucial for Android security. Fuzzing is one of
the most popular vulnerability discovery solutions, yet faces
several challenges when applied to Android native system
services. First, such services are invoked via a special inter-
process communication (IPC) mechanism, namely binder,
via service-speciﬁc interfaces. Thus, the fuzzer has to recog-
nize all interfaces and generate interface-speciﬁc test cases
automatically. Second, effective test cases should satisfy the
interface model of each interface. Third, the test cases should
also satisfy the semantic requirements, including variable
dependencies and interface dependencies.
In this paper, we propose an automated generation-based
fuzzing solution FANS to ﬁnd vulnerabilities in Android na-
tive system services. It ﬁrst collects all interfaces in target
services and uncovers deep nested multi-level interfaces to
test. Then, it automatically extracts interface models, includ-
ing feasible transaction code, variable names and types in the
transaction data, from the abstract syntax tree (AST) of target
interfaces. Further, it infers variable dependencies in transac-
tions via the variable name and type knowledge, and infers
interface dependencies via the generation and use relation-
ship. Finally, it employs the interface models and dependency
knowledge to generate sequences of transactions, which have
valid formats and semantics, to test interfaces of target ser-
vices. We implemented a prototype of FANS from scratch and
evaluated it on six smartphones equipped with a recent ver-
sion of Android, i.e., android-9.0.0_r46 , and found 30 unique
vulnerabilities deduplicated from thousands of crashes, of
which 20 have been conﬁrmed by Google. Surprisingly, we
also discovered 138 unique Java exceptions during fuzzing.
∗Part of this work was done during Baozheng Liu’s research internship at
Alpha Lab of 360.
Android has become the most popular mobile operating sys-
tem, taking over 85% markets according to International Data
Corporation1. The most fundamental functions of Android
are provided by Android system services, e.g., the camera
service. Until October 2019, hundreds of vulnerabilities re-
lated to Android system services had been reported to Google,
revealing that Android system services are still vulnerable and
attractive for attackers. A large portion of these vulnerabilities
reside in native system services, i.e., those mainly written in
C++. Vulnerabilities in Android native system services could
allow remote attackers to compromise the Android system,
e.g., performing privilege escalation, by means of launching
IPC requests with crafted inputs from third-party applications.
Finding vulnerabilities in Android native system services is
thus crucial for Android security.
However, to the best of our knowledge, existing researches
paid little attention to Android native system services. Apart
from a non-scalable manual approach [7], two automated
fuzzing solutions have been proposed to discover vulnera-
bilities in Android system services. The ﬁrst one is Binder-
Cracker [6], which captures input models of target services
by recording requests made by 30 popular applications. An
inherent disadvantage of this approach is that it cannot re-
cover precise input semantics, e.g., variable names and types.
Also, it will miss rarely-used or deeply-nested interfaces, due
to the incomplete testing. The other one is Chizpurﬂe [10],
which utilizes Java reﬂection to acquire parameter types of
interfaces to test vendor-implemented Java services. However,
such a method cannot be used to retrieve the input model of
Android native system services.
In Android, system services are registered to the Service
Manager. User apps query the manager to get the target
service’s interface (encapsulated in a proxy Binder object),
then invoke different transactions provided by this interface
via a uniﬁed remote procedure call (RPC) interface named
IBinder::transact(code,data,reply,flags), where,
1https://www.idc.com/promo/smartphone-market-share/os
(1) code determines the target transaction to invoke, and (2)
inputs of the transaction are marshalled into the serialized
parcel object data. Thus, we could utilize this uniﬁed
IPC method to test all system services. To thoroughly
test target services, we could ﬁrst ﬁnd all interfaces and
available transactions, and then invoke them with input data
satisfying service-speciﬁc formats and semantic requirements.
Speciﬁcally, there are three challenges to address:
C1: Multi-Level Interface Recognition. In addition to the
(top-level) interfaces registered in the Service Manager,
there are nested multi-level interfaces, which could be re-
trieved via the top-level interface and invoked by user apps.
For example, the IMeoryHeap interface is buried at the ﬁfth-
level (i.e., invoked via four layers of interfaces). Therefore,
we need to recognize all top-level interfaces and nested multi-
layer interfaces, in order to systematically test Android system
services. Given that many interfaces are deﬁned in Android
Interface Deﬁnition Language (AIDL) rather than C++ and
dynamically generated during compilation, we have to take
them into consideration as well.
C2: Interface Model Extraction. For each interface, we
need to get the list of supported transactions (i.e., code) to
test, and then provide input data to invoke each transaction.
To improve the fuzzing effectiveness, the input data should
follow grammatical requirements of target interfaces. Manu-
ally providing the grammar knowledge is not scalable. Auto-
matically extracting such knowledge from the large volume
of Android source code is also challenging. First, the gram-
mar is speciﬁc to an individual transaction, and thus we have
to recognize all available transactions and extract grammars
for each of them. Second, the grammar requirements co-exist
with the path constraints, e.g., branch conditions, loop condi-
tions and even nested loops, making it hard to be extracted
and represented.
C3: Semantically-correct Input Generation. Android it-
self performs many sanity checks (e.g., size check) on the
input data. Therefore, inputs that do not meet semantic re-
quirements can hardly explore deep states or trigger vulner-
abilities. There are many types of semantic requirements,
including variable names and types, and even dependencies
between variables or interfaces. For instance, a variable named
packageName indicates an existing package’s name is re-
quired; a variable of an enumeration type can only have a
limited set of candidate values; a variable in current transac-
tion may depend on another variable in either the current or
previous transaction, and even an interface may depend on an-
other interface. Recognizing such semantic requirements and
generating inputs accordingly are important but challenging.
Our Approach.
In this paper, we propose a generation-
based fuzzing solution FANS to address the aforementioned
challenges. To address the challenge C1, FANS ﬁrst recog-
nizes all top-level interfaces by scanning service registration
operations, and utilizes the fact that deep interfaces are gener-
ated by invoking the special method writeStrongBinder to
identify multi-level interfaces. For C2, we notice that, Android
system services always use a set of speciﬁc deserialization
methods (e.g., readInt32) to parse input data. By recogniz-
ing the invocation sequence of such methods, we could infer
the grammar of a valid input. To preserve the knowledge of
variables’ names and types, we choose to extract the deserial-
ization sequence (i.e., the input grammar) from abstract syntax
tree (AST). For C3, we will utilize the variable name and type
knowledge extracted from the AST to generate proper inputs
and recognize intra-transaction variable dependency. Further,
we rely on the fact that a dependent transaction will deserial-
ize data serialized by the depended transaction, to recognize
inter-transaction variable dependency. Moreover, we rely on
the generation and use relationship between interfaces to infer
their dependencies.
We implemented a prototype of FANS from scratch, inter-
mittently examined it on six mobile phones equipped with the
recent Android version android-9.0.0_r46 for about 30 days.
FANS has discovered 30 unique vulnerabilities deduplicated
from thousands of crashes. To our surprise, FANS also found
138 unique Java exceptions, yielded by Java applications that
might depend on Android native system services. Besides,
we dig into the code and observe that some Android native
system services would also invoke Java methods. We have
submitted all native bugs to Google, and received 20 con-
ﬁrmations. As for the Java exceptions, we are working on
examining them manually and submitting them to Google.
To facilitate future research, we open source the prototype of
FANS at https://github.com/iromise/fans.
Contributions.
contributions:
In summary, this paper makes the following
• We systematically investigated the dependency between
interfaces in Android native system services, and un-
earthed deeper multi-level interfaces.
• We proposed a solution to automatically extract input
interface model and semantics from AST. This method
can be applied to other interface-based programs.
• We proposed a solution to infer inter-transaction depen-
dencies, by utilizing variable name and type knowledge
in serialization and deserialization pairs in different trans-
actions.
• We implemented a prototype of FANS to systematically
fuzz Android native system services, and have found
30 unique native vulnerabilities and 138 unique Java
exceptions.
2 Background
In this section, we start by introducing the Android system
service. Then we provide the research scope of this paper.
Figure 1: Application-Service Communication Model
2.1 Android System Services
System services are essential parts of Android, providing the
most fundamental and core functionalities.
Systematization of Android System Services. Depend-
ing on the programming language, Android system services
can be divided into two categories: (1) Java system ser-
vices, which are implemented mainly using Java, e.g., activity
manager. (2) native system services, which are implemented
mainly using C++, e.g., camera service. Some Android native
system services run as daemons, e.g., netd. Note that a native
service might sometimes call java code and vice versa.
From another perspective, the services are divided into
three domains since Android 8, including normal domain,
vendor domain and hardware domain. Services in normal do-
main are services directly located in Android Open Source
Project (AOSP), while services inside vendor domain and
hardware domain are related to vendors and hardware respec-
tively.
Application-Service Communication Model. Figure 1 il-
lustrates the workﬂow of the application-service communi-
cation in Android. A service will ﬁrst register itself into the
service manager, and then listen to and handle requests from
applications. On the other hand, an application will query the
service manager to obtain the interface (encapsulated in a
proxy Binder object) of the target service, which is denoted
as a top-level interface. Then, it can utilize the top-level inter-
face to retrieve a multi-level interface or to call transactions
provided by the interface to perform certain actions. Further,
the application could retrieve deeper multi-level interfaces
and invoke corresponding transactions. Apart from the enti-
ties illustrated in the ﬁgure, there is another important entity,
i.e., binder driver, which bridges the communication between
applications and services. However, as the binder driver is not
strictly relevant to our research, we omit it in the ﬁgure.
Interfaces in Android System Services. As mentioned
earlier, apps invoke target transactions in top-level interfaces
via a uniﬁed RPC interface IBinder::transact(code,
data,reply,flags). Therefore, it implies that on the ser-
vice side there is a dispatcher responsible for handling
the request based on the transaction code. This dispatcher
is deﬁned in a uniﬁed method onTransact(code, data,
reply, flags). This dispatcher (or the target transaction)
will then deserialize the input data and perform the action
requested by the client. In general, every service has a set of
methods that can be called through RPC. They are declared
in a base class, but implemented in the client-side proxy and
the server-side stub separately. The binder driver bridges the
proxy and stub objects to communicate.
This mechanism also applies to multi-level interfaces, as
multi-level interfaces share the same architecture with top-
level interfaces. However, unlike top-level interfaces, the
Binder objects corresponding to multi-level interfaces are not
available in the service manager, and could only be retrieved
via top-level interfaces.
Besides, not all interfaces are statically deﬁned in C++, and
some of them are deﬁned in the Android Interface Deﬁnition
Language (AIDL). When building an Android image, AIDL
tools will be invoked to dynamically generate proper C++
code for further compilation.
2.2 Research Scope
In this paper, we focus on discovering vulnerabilities in the
Android native system services, which are registered in the
service manager and belong to the normal domain. To the
best of our knowledge, existing researches have paid little
attention to them. Meanwhile, as all Android system services
share the same architecture in the aspect of communication
and interface implementation, the scheme proposed in this
paper can be applied to other types of services as well.
3 Design
To ﬁnd vulnerabilities in Android native system services,
we propose a generation-based fuzzing solution FANS, and
present its design in this section.
3.1 Design Choices
RPC-centric testing: There are several alternative solutions
to testing Android native system services. A straightforward
solution is to test target transactions by directly injecting
ApplicationServiceService ManagerRegister service, e.g., MediaExtractor ServiceRequest a multi-level interface, e.g., IMediaExtractor, or call other transactionsReturn the interface, or the transaction results Request service, e.g., MediaExtractor ServiceReturn the service interface, i.e., a top-level interfaceFigure 2: Overview of FANS.
service-speciﬁc events to the system, without calling the uni-
ﬁed binder communication interface transact. However,
there are a lot of engineering challenges to address in order
to inject events to different services located in different pro-
cesses. More importantly, vulnerabilities found in this way
are likely to be false alarms, because the adversary in practice
cannot generate arbitrary events. Instead, the adversary has to
interact with target services via the IPC interface, and could
only produce a limited number of events for the following two
reasons: (1) the binder IPC mechanism will perform some
sanity checks, e.g., on packet size; and (2) the data marshalled
into a parcel might depend on some dynamic system states
and are thus not arbitrary. To reduce false positives, we choose
to test target services via the RPC interface, as could be done
by an adversary.
Generation-based fuzzing: In general, there are two types
of fuzzers: mutation-based [4, 25], which generates new
test cases by mutating existing test cases, and generation-
based [5,19]2, which generate test cases according to an input
speciﬁcation. Mutation-based fuzzers are likely to generate
test cases of invalid formats or semantics, which cannot be
correctly deserialized or processed by target services. There-
fore, such fuzzers tend to have low code coverage of target
services and may miss many potential vulnerabilities. To re-
duce false negatives, we choose to test target services with
generation-based fuzzing.
Learn input model from code: Generation-based fuzzers
rely on input model knowledge to generate valid and effec-
tive test cases. A large number of generation-based fuzzers,
including PEACH [5], Skyﬁre [20] and Syzkaller [19], rely
on grammar ﬁles produced by human to generate test cases,
which generally require huge manual efforts and are currently
unavailable for Android services. Another line of works, e.g.,
BinderCracker [6], learn from existing transactions to gener-
ate new inputs. This type of solutions is in general incomplete,
since it relies on the completeness of example transactions and
2Some generation-based fuzzers also utilize mutations to increase the
diversity of test cases.
will probably overlook rarely-used transactions. Moreover,
the input model learned in this way is in general inaccurate,
since only transaction data is given. On the other hand, we
notice that the input model knowledge is buried in the source
code, and choose to analyze Android source code to automat-
ically retrieve the input model.
3.2 Overview
Figure 2 illustrates the design overview of our solution FANS.
First, the interface collector (Section 3.3) collects all inter-
faces in target services, including top-level interfaces and
multi-level interfaces. Then interface model extractor (Sec-
tion 3.4) extracts input and output formats as well as vari-
able semantics, i.e., variable names and types, for each can-
didate transaction in each collected interface. The extractor
also collects deﬁnitions of structures, enumerations and type
aliases that are relevant to variables. Next, the dependency
inferer (Section 3.5) infers interface dependencies, as well as
intra-transaction and inter-transaction variable dependencies.
Finally, based on the above information, the fuzzer engine
(Section 3.6) randomly generates transactions and invokes
corresponding interfaces to fuzz native system services. The
fuzzer engine also has a manager responsible for synchro-
nizing data between the host and the mobile phone being
tested.
3.3
Interface Collector
As demonstrated in Section 2.1, top-level or multi-level in-
terfaces both have the onTransact method to dispatch trans-
actions. Thus, we could utilize this feature to recognize in-
terfaces. We do not directly scan C/C++ ﬁles in the AOSP