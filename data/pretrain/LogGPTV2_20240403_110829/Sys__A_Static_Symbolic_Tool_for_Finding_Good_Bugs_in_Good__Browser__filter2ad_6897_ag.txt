[26] Email correspondence with Gordon Tetlow, Apr. 2019.
[27] E. Aftandilian, R. Sauciuc, S. Priya, and S. Krishnan. Building useful
program analysis tools using an extensible java compiler. In
IWCSCAM, 2012.
[28] P. Akritidis, M. Costa, M. Castro, and S. Hand. Baggy bounds
checking: An efﬁcient and backwards-compatible defense against
out-of-bounds errors. In USENIX Sec, 2009.
[29] B. Anderson, L. Bergstrom, D. Herman, J. Matthews, K. McAllister,
M. Goregaokar, J. Mofﬁtt, and S. Sapin. Experience report:
Developing the Servo web browser engine using Rust.
arXiv:1505.07383, 2015.
[30] A. Arya, O. Chang, M. Moroz, M. Barbella, J. Metzman, and
ClusterFuzz team. Open sourcing ClusterFuzz.
https://opensource.googleblog.com/2019/02/open-
sourcing-clusterfuzz.html, 2019.
[31] K. Ashcraft and D. Engler. Using programmer-written compiler
extensions to catch security holes. In IEEE S&P, 2002.
[32] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. AEG:
Automatic exploit generation. In NDSS, 2011.
[33] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley. Enhancing
symbolic execution with veritesting. In ICSE, 2014.
[34] D. Babi´c, L. Martignoni, S. McCamant, and D. Song. Statically-
directed dynamic automated test generation. In ISSTA, 2011.
[35] J.-J. Bai, J. Lawall, Q.-L. Chen, and S.-M. Hu. Effective static
analysis of concurrency use-after-free bugs in Linux device drivers.
In USENIX ATC, 2019.
[36] R. Baldoni, E. Coppa, D. C. D’elia, C. Demetrescu, and I. Finocchi.
A survey of symbolic execution techniques. ACM Comp. Surv., 51(3),
2018.
[37] C. Barrett, A. Stump, C. Tinelli, et al. The SMT-LIB standard:
Version 2.0. In SMT, 2010.
[38] T. Bergan, D. Grossman, and L. Ceze. Symbolic execution of
multithreaded programs from arbitrary program contexts. In
OOPSLA, 2014.
[39] A. Bessey, K. Block, B. Chelf, A. Chou, B. Fulton, S. Hallem,
C. Henri-Gros, A. Kamsky, S. McPeak, and D. Engler. A few billion
lines of code later: using static analysis to ﬁnd bugs in the real world.
214    29th USENIX Security Symposium
USENIX Association
CACM, 53(2), 2010.
[40] F. Brown, S. Narayan, R. S. Wahby, D. Engler, R. Jhala, and
D. Stefan. Finding and preventing bugs in JavaScript bindings. In
IEEE S&P, 2017.
[41] F. Brown, A. Nötzli, and D. Engler. How to build static checking
systems using orders of magnitude less code. In ASPLOS, 2016.
[42] D. Brumley, C. Hartwig, M. G. Kang, Z. Liang, J. Newsome,
P. Poosankam, D. Song, and H. Yin. Bitscope: Automatically
dissecting malicious binaries. CMU Tech report CS-07-133, 2007.
[43] R. Brummayer and A. Biere. Boolector: An efﬁcient SMT solver for
bit-vectors and arrays. In TACAS, 2009.
[44] S. Bucur, V. Ureche, C. Zamﬁr, and G. Candea. Parallel symbolic
execution for automated real-world software testing. In EuroSys,
2011.
[45] C. Cadar, D. Dunbar, and D. Engler. KLEE: Unassisted and
automatic generation of high-coverage tests for complex systems
programs. In OSDI, 2008.
[46] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler.
Exe: automatically generating inputs of death. TISSEC, 2008.
[47] C. Cadar and K. Sen. Symbolic execution for software testing: three
decades later. CACM, 2013.
[48] C. Calcagno, D. Distefano, J. Dubreil, D. Gabi, P. Hooimeijer,
M. Luca, P. O’Hearn, I. Papakonstantinou, J. Purbrick, and
D. Rodriguez. Moving fast with software veriﬁcation. In NASA
Formal Methods Symposium, 2015.
[49] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing
mayhem on binary code. In IEEE S&P, 2012.
[50] V. Chipounov, V. Kuznetsov, and G. Candea. S2E: A platform for
in-vivo multi-path analysis of software systems. In ASPLOS, 2011.
[51] Chrome vulnerability reward program rules.
https://www.google.com/about/appsecurity/chrome-rewards/.
[52] The Clang static analyzer. https://chromium.googlesource.
com/chromium/src/+/HEAD/docs/clang_static_analyzer.md.
[53] Severity guidelines for security issues.
https://chromium.googlesource.com/chromium/src/+/
master/docs/security/severity-guidelines.md.
[54] Chromium code coverage. https://chromium-coverage.appspot.com/.
[55] Address sanitizer.
https://clang.llvm.org/docs/AddressSanitizer.html.
[56] Memory sanitizer.
https://clang.llvm.org/docs/MemorySanitizer.html.
[57] Undeﬁned behavior sanitizer. https:
//clang.llvm.org/docs/UndefinedBehaviorSanitizer.html.
[58] H. Corrigan-Gibbs. Personal communication, Feb. 2019.
[59] H. Cui, G. Hu, J. Wu, and J. Yang. Verifying systems rules using
rule-directed symbolic execution. In ASPLOS, 2013.
[60] D. Distefano, M. Fähndrich, F. Logozzo, and P. W. O’Hearn. Scaling
static analyses at Facebook. CACM, 2019.
[61] B. Elkarablieh, P. Godefroid, and M. Y. Levin. Precise pointer
reasoning for dynamic test generation. In ISSTA, 2009.
[62] D. Engler, B. Chelf, A. Chou, and S. Hallem. Checking system rules
using system-speciﬁc, programmer-written compiler extensions. In
OSDI, 2000.
[63] D. Engler and D. Dunbar. Under-constrained execution: making
automatic code destruction easy and scalable. In ISSTA, 2007.
[64] Ú. Erlingsson, Y. Younan, and F. Piessens. Low-level software
security by example. In Handbook of Information and
Communication Security. 2010.
[65] D. Evans and D. Larochelle. Improving security using extensible
lightweight static analysis. IEEE Software, 19(1), 2002.
[66] J. Feist, L. Mounier, S. Bardin, R. David, and M.-L. Potet. Finding
the needle in the heap: combining static analysis and dynamic
symbolic execution to trigger use-after-free. In SSPREW, 2016.
[67] ASan nightly project. https://developer.mozilla.org/en-
US/docs/Mozilla/Testing/ASan_Nightly_Project.
[68] https://developer.mozilla.org/en-
US/docs/Mozilla/Projects/NSPR.
[69] https://developer.mozilla.org/en-
US/docs/Mozilla/Projects/NSS.
[70] C. Flanagan, C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson,
J. B. Saxe, and R. Stata. Extended static checking for Java. In PLDI,
2002.
[71] M. R. Gadelha, E. Stefﬁnlongo, L. C. Cordeiro, B. Fischer, and D. A.
Nicole. SMT-based refutation of spurious bug reports in the Clang
static analyzer. arXiv:1810.12041, 2018.
[72] B. Garmany, M. Stoffel, R. Gawlik, and T. Holz. Static detection of
uninitialized stack variables in binary code. In ESORICS, 2019.
[73] A. Y. Gerasimov. Directed dynamic symbolic execution for static
analysis warnings conﬁrmation. Programming and Computer
Software, 44(5), 2018.
[74] P. Godefroid, N. Klarlund, and K. Sen. DART: directed automated
random testing. In PLDI, 2005.
[75] P. Godefroid, S. K. Lahiri, and C. Rubio-González. Statically
validating must summaries for incremental compositional dynamic
test generation. In SAS, 2011.
[76] P. Godefroid, M. Y. Levin, and D. A. Molnar. Automated whitebox
fuzz testing. In NDSS, 2008.
[77] M. Goregaokar. Fearless concurrency in Firefox Quantum.
https://blog.rust-lang.org/2017/11/14/Fearless-
Concurrency-In-Firefox-Quantum.html.
[78] S. Guo, M. Kusano, and C. Wang. Conc-iSE: Incremental symbolic
execution of concurrent software. In ASE, 2016.
[79] S. Guo, M. Kusano, C. Wang, Z. Yang, and A. Gupta. Assertion
guided symbolic execution of multithreaded programs. In FSE, 2015.
[80] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A system and language
for building system-speciﬁc, static analyses. In PLDI, 2002.
[81] I. Haller, A. Slowinska, M. Neugschwandtner, and H. Bos. Dowser: a
guided fuzzer to ﬁnd buffer overﬂow vulnerabilities. In USENIX Sec,
2013.
[82] R. Hastings and B. Joyce. Purify: Fast detection of memory leaks and
access errors. In Winter USENIX Conference, 1991.
[83] R. Helmer, A. Miyaguchi, and E. Rescorla. Testing
privacy-preserving telemetry with prio.
https://hacks.mozilla.org/2018/10/testing-privacy-
preserving-telemetry-with-prio/, 2018.
[84] D. Hovemeyer and W. Pugh. Finding bugs is easy. OOPSLA, 2004.
[85] Joern. https://joern.io/docs/.
[86] S. Y. Kim, S. Lee, I. Yun, W. Xu, B. Lee, Y. Yun, and T. Kim.
CAB-Fuzz: Practical concolic testing techniques for COTS operating
systems. In USENIX ATC, 2017.
[87] T. Kremenek. Finding software bugs with the Clang Static Analyzer.
https://llvm.org/devmtg/2008-
08/Kremenek_StaticAnalyzer.pdf, 2008.
[88] G. Kwong. JavaScript fuzzing in Mozilla, 2017.
https://nth10sd.github.io/js-fuzzing-in-mozilla/.
[89] D. Larochelle and D. Evans. Statically detecting likely buffer
overﬂow vulnerabilities. In USENIX Sec, 2001.
[90] J. Lawall and G. Muller. Coccinelle: 10 years of automated evolution
in the Linux kernel. In USENIX ATC, 2018.
[91] B. Lee, C. Song, Y. Jang, T. Wang, T. Kim, L. Lu, and W. Lee.
Preventing use-after-free with dangling pointers nulliﬁcation. In
NDSS, 2015.
[92] J. Lee, Y. Kim, Y. Song, C.-K. Hur, S. Das, D. Majnemer, J. Regehr,
and N. P. Lopes. Taming undeﬁned behavior in LLVM. PLDI, 2017.
[93] K. Li. Combining Static and Dynamic Analysis for Bug Detection
and Program Understanding. PhD thesis, UMass Amherst, 2016.
[94] The often misunderstood GEP instruction.
https://llvm.org/docs/GetElementPtr.html.
[95] https://llvm.org/docs/LangRef.html#phi-instruction.
[96] https://llvm.org/docs/LangRef.html#undefined-values.
[97] K. Lu, M.-T. Walter, D. Pfaff, S. Nümberger, W. Lee, and M. Backes.
Unleashing use-before-initialization vulnerabilities in the Linux
USENIX Association
29th USENIX Security Symposium    215
kernel using targeted stack spraying. In NDSS, 2017.
[98] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood. Pin: building customized
program analysis tools with dynamic instrumentation. In PLDI, 2005.
[99] K.-K. Ma, K. Y. Phang, J. S. Foster, and M. Hicks. Directed symbolic
execution. In SAS, 2011.
[100] R. Majumdar and K. Sen. Hybrid concolic testing. In ICSE, 2007.
[101] A. Milburn, H. Bos, and C. Giuffrida. Safelnit: Comprehensive and
practical mitigation of uninitialized read vulnerabilities. In NDSS,
2017.
[102] M. Moroz and K. Serebryany. Guided in-process fuzzing of Chrome
components. Google Security Blog, 2016.
[103] Mozilla bug bounty program.
https://www.mozilla.org/en-US/security/bug-bounty/.
[104] Clang static analysis. https://developer.mozilla.org/en-
US/docs/Mozilla/Testing/Clang_static_analysis.
[105] Security severity ratings.
https://wiki.mozilla.org/Security_Severity_Ratings.
[106] N. Nethercote and J. Seward. Valgrind: a framework for heavyweight
dynamic binary instrumentation. In PLDI, 2007.
[107] A. Niemetz, M. Preiner, and A. Biere. Boolector 2.0. JSAT, 9(1),
2015.
[108] B. S. Pak. Hybrid fuzz testing: Discovering software bugs via fuzzing
and symbolic execution. PhD thesis, CMU, 2012.
[109] R. Parvez, P. A. Ward, and V. Ganesh. Combining static analysis and
targeted symbolic execution for scalable bug-ﬁnding in application
binaries. In CASCON, 2016.
[110] C. S. P˘as˘areanu and W. Visser. Veriﬁcation of Java programs using
symbolic execution and invariant generation. In SPIN, 2004.
[111] H. Peng, Y. Shoshitaishvili, and M. Payer. T-fuzz: fuzzing by
program transformation. In IEEE S&P, 2018.
[112] S. Person, G. Yang, N. Rungta, and S. Khurshid. Directed
incremental symbolic execution. In PLDI, 2011.
[113] D. A. Ramos. Under-constrained symbolic execution: correctness
checking for real code. PhD thesis, Stanford University, 2015.
[114] D. A. Ramos. Personal communication, Aug. 2019.
[115] D. A. Ramos and D. Engler. Under-constrained symbolic execution:
Correctness checking for real code. In USENIX Sec, 2015.
[116] J. Regehr. SQLite with a ﬁne-toothed comb.
https://blog.regehr.org/archives/1292.
[117] J. Regehr, A. Reid, and K. Webb. Eliminating stack overﬂow by
abstract interpretation. TECS, 2005.
[118] M. J. Renzelmann, A. Kadav, and M. M. Swift. Symdrive: Testing
drivers without devices. In OSDI, 2012.
[119] T. Ritter. Adding CodeQL and Clang to our bug bounty program.
https://blog.mozilla.org/security/2019/11/14/adding-
codeql-and-clang-to-our-bug-bounty-program/.
[120] N. Rungta, S. Person, and J. Branchaud. A change impact analysis to
characterize evolving program behaviors. In ICSM, 2012.
[121] C. Sadowski, E. Aftandilian, A. Eagle, L. Miller-Cushon, and
C. Jaspan. Lessons from building static analysis tools at Google.
CACM, 61(4), 2018.
[122] C. Sadowski, J. Van Gogh, C. Jaspan, E. Söderberg, and C. Winter.
Tricorder: Building a program analysis ecosystem. In ICSE, 2015.
[123] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and T. Anderson.
Eraser: A dynamic data race detector for multithreaded programs.
TOCS, 15(4), 1997.
[124] E. J. Schwartz, T. Avgerinos, and D. Brumley. All you ever wanted to
know about dynamic taint analysis and forward symbolic execution
(but might have been afraid to ask). In IEEE S&P, 2010.
[125] Security at Mozilla. https://wiki.mozilla.org/security.
[126] Semmle. https://semmle.com/.
[127] K. Sen, D. Marinov, and G. Agha. CUTE: a concolic unit testing
engine for C. In ESE-FSE, 2005.
[128] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov. Address-
Sanitizer: A fast address sanity checker. In USENIX ATC, 2012.
[129] J. Seward and N. Nethercote. Using valgrind to detect undeﬁned
value errors with bit-precision. In USENIX ATC, 2005.
[130] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna.
Firmalice: Automatic detection of authentication bypass
vulnerabilities in binary ﬁrmware. In NDSS, 2015.
[131] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna.
SoK: (State of) The Art of War: Offensive Techniques in Binary
Analysis. In IEEE S&P, 2016.
[132] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G. Kang,
Z. Liang, J. Newsome, P. Poosankam, and P. Saxena. BitBlaze: A new
approach to computer security via binary analysis. In ICISS, 2008.
[133] D. Song, J. Lettner, P. Rajasekaran, Y. Na, S. Volckaert, P. Larsen,
and M. Franz. Sok: Sanitizing for security. In IEEE S&P, 2019.
[134] SQLite Documentation. The virtual table mechanism of SQLite.
https://sqlite.org/vtab.html.
[135] A. Srivastava and A. Eustace. ATOM: A system for building
customized program analysis tools. In PLDI, 1994.
[136] E. Stepanov and K. Serebryany. MemorySanitizer: fast detector of
uninitialized memory use in C++. In CGO, 2015.
[137] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Krügel, and G. Vigna. Driller: Augmenting
fuzzing through selective symbolic execution. In NDSS, 2016.
[138] H. Stuart. Hunting bugs with Coccinelle. Master’s thesis, University
of Copenhagen, 2008.
[139] L. Szekeres, M. Payer, T. Wei, and D. Song. Sok: Eternal war in
memory. In IEEE S&P, 2013.
[140] D. Trabish, A. Mattavelli, N. Rinetzky, and C. Cadar. Chopped
symbolic execution. In ICSE, 2018.
[141] E. Van Der Kouwe, V. Nigade, and C. Giuffrida. Dangsan: Scalable
use-after-free detection. In EuroSys, 2017.
[142] X. Wang, H. Chen, Z. Jia, N. Zeldovich, and M. F. Kaashoek.
Improving integer security for systems with KINT. In OSDI, 2012.
[143] Y. Xie and A. Aiken. Saturn: A SAT-based tool for bug detection. In
CAV, 2005.
[144] Y. Xie and A. Aiken. Scalable error detection using boolean
satisﬁability. In POPL, 2005.
[145] M. Xu, C. Qian, K. Lu, M. Backes, and T. Kim. Precise and scalable
detection of double-fetch bugs in OS kernels. In IEEE S&P, 2018.
[146] H. Yan, Y. Sui, S. Chen, and J. Xue. Spatio-temporal context
reduction: A pointer-analysis-based static approach for detecting
use-after-free vulnerabilities. In ICSE, 2018.
[147] G. Yang, S. Khurshid, S. Person, and N. Rungta. Property
differencing for incremental checking. In ICSE, 2014.
[148] D. Ye, Y. Sui, and J. Xue. Accelerating dynamic detection of uses of
undeﬁned values with static value-ﬂow analysis. In CGO, 2014.
[149] Y. Younan. FreeSentry: protecting against use-after-free
vulnerabilities due to dangling pointers. In NDSS, 2015.
[150] I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim. QSYM: A practical
concolic execution engine tailored for hybrid fuzzing. In USENIX
Sec, 2018.
[151] A. Zaks and J. Rose. How to write a checker in 24 hours. https:
//llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf,
2012.
[152] M. Zalewski. American fuzzy lop.
http://lcamtuf.coredump.cx/afl.
[153] Y. Zhang, Z. Chen, J. Wang, W. Dong, and Z. Liu. Regular property
guided dynamic symbolic execution. In ICSE, 2015.
[154] J.-K. Zinzindohoué, K. Bhargavan, J. Protzenko, and B. Beurdouche.
HACL*: A veriﬁed modern cryptographic library. In ACM CCS,
2017.
216    29th USENIX Security Symposium
USENIX Association