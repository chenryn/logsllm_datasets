R1: OTP Randomness–Use a random value as an OTP for
authentication.
The server needs a cryptographically strong pseudo-random
number generator to generate the OTP value for each lo-
gin session, as an attacker can exploit any detectable non-
randomness in the successive OTPs. Some poor pseudo-
random number generators can be identified from the se-
ries [14], or values in the sequence may appear periodically.
In the worst situation, an implementation of OTP authen-
tication may keep using a static value as the OTP for all
authentication sessions.
R2: OTP Length–Generate an OTP value with at least six
digits.
The official document RFC 4226 [35] points out that “the
value displayed on the token MUST be easily read and entered
by the user.”. It requires that the OTP value should also be
of reasonable length. Particularly, RFC 4226 indicates that
an OTP value of at least six digits could adequately reduce
the probability of a successful brute-force attack. In view of
both usability and security considerations, OTP values with
a length from six to eight digits achieve the required overall
performance.
R3: Retry Attempts–Set a limit on the number of validation
attempts allowed per login.
RFC 4226 [35] recommend a maximum number of possible
attempts for OTP validation. In particular, when the maxi-
mum number of attempts is reached, the server must lock
out the user’s account to defend against a brute-force attack.
R4: OTP Consumption–Only allow each OTP value to be
consumed once.
According to the definition of the OTP authentication pro-
tocol, each OTP should only be valid for one authentication
session.
R5: OTP Expiration–Reject expired OTP values generated
by the TOTP algorithm.
Referring to RFC 6238 [36], the OTP value generated in
the next time step MUST be different. It represents that the
OTP value generated by the TOTP algorithm should only be
valid for a limited time.
R6: OTP Renewal Interval–OTP values generated by the
TOTP algorithm should be valid for at most 30 seconds.
Due to the network latency issue, RFC 6238 [36] recom-
mends that “A validation system SHOULD typically set a
policy for an acceptance OTP transmission delay window for
validation.”; thus, a renewal interval is allowed. For the re-
newal interval, the login validation system achieves a higher
usability by allowing for a longer latency, potentially caused
by human and network operations. To balance the demands
of usability and security, RFC 6238 suggests that the OTP
should be renewed every 30 seconds.
2.2.2 Threats against OTP Authentication. We determine
whether an implementation of the OTP authentication pro-
tocol is secure, in that it should at least meet the following
two requirements:
(1) The authentication protocol should not be vulnerable
(2) The authentication protocol should be secure against
to brute force attacks.
replay attacks.
We observe that if one or more defined OTP rules are
violated, the above two requirements may not be satisfied.
In the following, we discuss how the violation of our defined
OTP rules threats the security of OTP authentication.
• The violation of R1 indicates that an OTP becomes pre-
dictable, and thus the validation systems are vulnerable
to replay attacks, allowing attackers to impersonate
legitimate users.
• The violation of R2 indicates that an OTP is of limited
length, which is vulnerable to brute-force attacks and
may be cracked within a few minutes [11].
• The violation of R3 indicates that an attacker could
easily guess the OTP value through a brute-force attack
if unlimited attempts are allowed.
• The violation of R4 indicates that a validation system
allows an OTP to be used multiple times and thus is
vulnerable to replay attacks.
• The violation of R5 indicates that a validation system
accepts an expired OTP value and thus allows an un-
limited time for an attacker to discover the OTP and
consume it before the legitimate user does.
• The violation of R6 indicates that a validation system
provides a long time window for an attacker to crack
the OTP.
Moreover, we observe that even though the violation of
a single rule might not cause severe security issues, power-
ful attacks could be launched if multiple rules are violated
simultaneously:
(1) Violation of R1 and any of the other rules. A static
OTP value is always vulnerable to replay attacks.
(2) Violation of R2 and R3. For an OTP value with length
less than six, an attacker can easily crack the OTP
value if the number of validation attempts is unlimited
(i.e., vulnerable to brute force attacks).
(3) Violation of R2 and R4. The violation of R4 allows an
attack to reuse current OTP values to launch replay at-
tacks. At the same time, if R2 is also violated, attackers
can easily extract OTP values for further attacks.
An Empirical Study of SMS OTP Authentication in Android Apps
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
(4) Violation of R4 and R5. The OTP validation system
is vulnerable to replay attacks by allowing an OTP to
be used multiple times. In addition, if the validation
system does not set OTP expiration, an attacker is
able to launch replay attacks by providing the same
OTP value. Even though an OTP is encrypted, the
attacker can request for verification by submitting the
encrypted format directly.
(5) Violation of R2, R3, and R6. Similar to situation (2), an
OTP validation with a larger renewal interval provides
an attack enough time to crack an OTP with less than
six digits. It is vulnerable to brute force attacks.
3 OTP AUTHENTICATION IN ANDROID
Analyzing OTP authentication protocols implemented in
real-world servers require addressing several challenges. Be-
low, we describe the challenges, each followed by our ap-
proach to address it.
Challenge 1: How to identify OTP authentication im-
plementations that violation the aforementioned OTP
rules without access to the source code? Static code anal-
ysis is the most popular technique to locate implementation
flaws. However, this technique does not work because server
source code is not publicly available. The other technique is
to identify functionalities supported by servers and interact
with servers. Many attack-based techniques have been pro-
posed based on this approach [25] [27]. However, we cannot
apply this approach in our case for ethical reasons.
Our approach 1: Interacting with servers. We search for
implementation violations via legitimate interactions with
servers. Executing an app triggers the validation functional-
ities of OTP authentication implemented in the app server.
Referring to the OTP rules defined in Section 2, we design ex-
periments to test the functionalities and determine whether
the implemented OTP authentication protocol obeys all the
OTP rules.
Challenge 2: How to locate the app code that triggers
the validation functionalities of OTP authentication?
We perform login by executing Android apps to explore
the functionalities of OTP authentication at remote servers.
Hence, we need to locate OTP login Activities in apps. To
find such Activities, we decompile each app and search for
functions declaring login Activities. However, developers
use a variety of names for these functions, which makes
identification more complicated. While we can recognize the
login functions by matching data- and control-dependencies
with execution patterns, such a strategy does not always
succeed because the code decompilation of an app may be
incomplete. Thus, we need a broader approach to identify
login functions that requires less code information.
Our approach 2: Recognizing OTP login functions se-
mantically. Login Activity declarations, including class in-
formation (i.e., class name and name of the extended class)
and function information (i.e., function name and argument
name) are more complete than other relevant information,
such as control-dependencies and API names. Moreover, lo-
gin Activity declarations reflect which functionalities are
included in the class. Although name recognition is chal-
lenging, we observe that developers prefer to use similar
words to name similar functionalities. This provides a way
to identify login-related functions by applying syntax and
lexical analysis.
Challenge 3: How to perform login Activities to inter-
act with each server? Once the login Activity declarations
are located, we send login requests via the login Activity
in each app, triggering the OTP validation system at the
remote server. We can manually send login requests, but it
does not scale to a large number of apps. To automate the
process, we need to design a system that follows the login
process precisely. Otherwise, irrelevant services might be
triggered, which cause unexpected errors. For example, a
button requesting a password reset might be clicked acci-
dentally, possibly switching from the current login page to a
password reset page.
Our approach 3: Extracting the position of each wid-
get. After app decompilation, there is a file describing all
the involved widgets, including their names, layouts, types,
positions, etc. The widget type information helps to identify
the widgets used for editing texts and clicking buttons. The
widget name implies its purpose, and its layout gives its po-
sition. Through this information we can locate the required
widgets precisely and execute further operations.
Challenge 4: How to parse the received server mes-
sages? Responses from a server are texts containing both
useful information (e.g., valid OTP, its expiration, etc.) and
irrelevant material. Furthermore, OTP authentication pro-
tocols implemented in different servers have different func-
tionalities, which indicates that their responses differ. To
deal with this issue, we need a mechanism to systematically
process these server messages and recognize the fields con-
taining the useful information.
Our approach 4: Examining altered fields in each mes-
sage. We identify fields that are altered by comparing multi-
ple responses. Although OTP authentication protocols with
different functionalities may give different responses, some
essential fields in these responses still follow particular for-
mats. For example, the description of OTP expiration is usu-
ally in the format of a decimal followed by a string as “sec-
ond(s)”, “minute(s)” or “hour(s)”. With some prior informa-
tion like this, we discover the used formats and furthermore
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
Siqi et al.
Activities that were declared by developers (i.e., customized
classes and functions) and then identifies functions that ful-
fill login Activities. The examination steps of how AUTH-EYE
recognizes OTP login Activities in apps are detailed below.
Customized Package Selection. We observe that Activi-
ties commonly exist in customized packages (i.e., declared by
developers) and seldom exist in third-party libraries. There-
fore, AUTH-EYE needs to distinguish customized packages
from the standard packages declared in third-party libraries.
AUTH-EYE adopts a heuristic approach to achieve this target:
it ONLY collects class names of Activities in an app and ana-
lyzes the first two fields in a class name. For example, in the
class name cx.itxxx.usercenter.activity4, the first two
fields, cn.itxxx, indicate the identity of the developer, while
the last part, usercenter.activity, refers to the functions
that are related to an Activity. In one app there often exist
many Activities. AUTH-EYE defines the most frequently ap-
peared first-two-fields prefix as the developer’s information,
and then deems packages with this developer’s information
as customized packages. According to our manual inspection
on 2,210 popular Android apps, 2,153 apps follow this pat-
tern and thus AUTH-EYE could apply this approach to locate
customized packages.
Login Function Identification. Once the customized pack-
ages are identified, AUTH-EYE locates classes and functions
with login Activities. A common strategy for understanding
a function semantically is to search for specific words and
dependency patterns. However, in our case this strategy fails
to extract semantic information effectively for the following
reasons:
• Non-Uniform Representation: Developers often choose
function and variable names arbitrarily. They often use
different names for functions and variables with the
same purpose, such as the AccountLoginActivity
login functions and PhoneLogin. For a matching ap-
proach to succeed, we thus need a dataset with a large
number of potential keywords.
• Vague Explanation: Developers may use identical words
but combine these words in different orders to name
different functions. The meanings of these functions
are significantly different. This makes a simple key-
word comparison inaccurate. For example, the func-
tion LoginPhoneAct refers to the activity of extracting
phone settings, but PhoneLoginAct specifies login via
mobile phone.
• Unclear Expression: Developers often use abbreviations
and colloquial terms (e.g., AccountAct) to declare an
Activity. Moreover, the decompilation replaces some
4We used ‘x’ to conceal the details of this developer
Figure 1: The workflow of AUTH-EYE
find what functionality is implemented by sending multiple
requests to the same server.
4 SYSTEM DESIGN: AUTH-EYE
This section describes our automated system, AUTH-EYE,
which analyzes Android apps and detects violations of the
OTP rules defined in Section 2. AUTH-EYE is built following
the approaches outlined in Section 3 to address the critical
challenges while examining OTP protocol implementations.
AUTH-EYE comprises two components: a Login Code Detec-
tor and an Auth Message Analyzer, and Figure 1 illustrates
the system workflow. We next describe the system in detail.
4.1 Login Code Detector
As mentioned earlier, our focus is on the SMS OTP authenti-
cation protocol. The function of the login code detector is to
analyze a set of apps and generate an OTP List of the apps that
implement SMS OTP login activities. AUTH-EYE achieves this
in two steps: app decompilation and Login Activity locating,
which are detailed as follows.
4.1.1 App Decompilation. AUTH-EYE is built on top of the
JEB Android decompiler [42]. The login code detector first
takes apps as inputs and uses JEB to decompile them into
their java source code.
4.1.2 Login Activity Locating. Since AUTH-EYE only fo-
cuses on OTP authentication, it first needs to distinguish Ac-
tivities of OTP authentication from that of password authen-
tication. However, since both Activities are named similarly
in layout files, it is hard for AUTH-EYE to distinguish OTP
authentication via the layout files only. Therefore, AUTH-EYE
examines the java source code of each app to identify those
which implement login activities. AUTH-EYE first looks for
Login Code DetectorAUTH-EYEAuth Message AnalyzerOTP List①ServersReport②③③④⑤OTP RulesAppsAn Empirical Study of SMS OTP Authentication in Android Apps
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
APIs by using abstract formats, e.g., UserLogin.a. Ab-
breviations and abstract formats like this are more
difficult to recognize through a simple keyword match-
ing.
• Partial Decompilation: We cannot completely decom-
pile apps with protected code snippets. Hence, the
patterns extracted through the data and control depen-
dencies may be inadequate.
To gain a further understanding of these difficulties, we
manually inspected the source code of each app. We found
that class names are usually fully decompiled, and follow
some specific formats. For example, developers use similar
words (e.g., login, auth) with similar formats to name a
login Activity. Therefore, we propose a natural language
processing [33] (NLP) based approach, which is widely used
to evaluate the semantic similarity between a pair of words,
to extract the semantic information from class and function
names and so address the second challenge.
We first manually construct a reference set for similarity
comparison. We collected the login-related class names and
function names from 4,665 repositories posted on Github5,
where open source apps display the code with login Activities.
A context is required for measuring the semantic similarity
between an unknown name and names in the reference set.
Because we compare the semantic similarity of two words
defined in programming code, text corpora such as Wikipedia