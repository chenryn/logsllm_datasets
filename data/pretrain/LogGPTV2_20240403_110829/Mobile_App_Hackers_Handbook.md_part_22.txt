If it is signed with a release key, the APK must be zip-aligned using the zipalign tool, which ensures that the
application resources are aligned optimally for the way that they will be loaded into memory. The benefit of
this is that the amount of RAM consumed when running the application is reduced.
This compilation process is invisible to you as the developer as these tasks are automatically performed by your
IDE but are essential to understanding how code becomes a complete package. When you unzip an APK you see
the final product of all steps listed above. Note also that a very strictly defined folder structure is used by every
APK. The following is a high-level look at this folder structure:
/assets
/res
/lib
/META-INF
AndroidManifest.xml
classes.dex
resources.asrc
Assets—Allows the developer to place files in this directory that they would like bundled with the
application.
Res—Contains all the application activity layouts, images used, and any other files that the developer would
like accessed from code in a structured way. These files are placed in the raw/ subdirectory.
Lib—Contains any native libraries that are bundled with the application. These are split by architecture
under this directory and loaded by the application according to the detected CPU architecture; for example,
x86, ARM, MIPS.
META-INF—This folder contains the certificate of the application and files that hold an inventory list of all
included files in the zip archive and their hashes.
classes.dex—this is essentially the executable file containing the Dalvik bytecode of the application. It is the
actual code that will run on the Dalvik Virtual Machine.
AndroidManifest.xml—the manifest file containing all configuration information about the application and
defined security parameters. This will be explored in detail later in this chapter.
Resources.asrc—Resources can be compiled into this file instead of being put into the res folder. Also
contains any application strings.
Installing Packages
Behind the scenes, the process of downloading an application from the Play Store and installing it is actually
quite a bit more complicated than one would imagine. The simplest way that Google could have implemented
this process is to have the Play Store application visit a website and allow the user to browse through the
application categories. When the user chooses to install an application Google would provide an “install” link
and all that this does is download the APK file over HTTPS from the browser. What is wrong with this approach?
Well, considering this method from a security point of view, how does the OS know that the downloaded
package came from the Play Store and is safe to install? The APK would be treated like every other download
using the browser and therefore no degree of trust can be afforded using this method.
Instead, Google implemented a very modular and robust way to perform installations. When you click the
Install button on the Google Play application or website, functionality to deliver and install the application is
invoked on the device via the GTalkService. This functionality works from a system application on every
Android device and maintains a connection to Google infrastructure via a pinned SSL connection. Various other
services such as the Android Device Manager or Google Cloud Messaging (GCM) make use of the GTalkService.
The installation process via the GTalkService was explored in an excellent blog post by Jon Oberheide at
https://jon.oberheide.org/blog/2010/06/28/a-peek-inside-the-gtalkservice-connection/. The
GTalkService gracefully handles cases where the device on which you are installing an application is offline or
in a low-signal area. It simply queues the message and delivers it when the device comes online. One of the
reasons Android is considered so “open and free” is that so many different ways exist to find and install Android
applications. Google does not force users to make use of its Play Store and users can make use of many other
application stores instead. Some device vendors and phone carriers like to include their own app stores on
devices they sell. A good example of this is the Samsung Apps application that is included on all Samsung
devices. Other such examples of popular alternative app stores include Amazon Appstore, GetJar, SlideMe, F-
Droid, and a number of big players in the Eastern markets.
In addition to these application stores, multiple ways exist to install new applications onto your device by simply
having access to the APK that you would like to install. Making use of an Android SDK tool named ADB
(Android Debug Bridge) is one of the simplest ways to do this. Assuming a correct SDK installation, ADB will be
on your PATH. Issuing the following command will install an APK onto a connected device or emulator:
$ adb install /path/to/yourapplication.apk
TIP
Installing the APK requires USB Debugging to be turned on in the settings and a physical connection from
your device to your computer.
On Android 4.2.2 and later, making an ADB connection may require you to accept a prompt allowing your
computer to connect. The install command of ADB works behind the scenes invoking the package manager on
the device (/system/bin/pm). Package Manager can perform a number of actions, including listing all installed
packages, disabling an application that came with the device that you consider unnecessary “bloatware,” or
obtaining the installed path to a particular application. For all the available options, type the following command
and observe the output:
$ adb shell pm
Another way to install an application could be to host it on a web server. Some application developers choose
not to put their application on any app stores and rather serve it from their website. These sites often check for
Android browser user agent strings and automatically start the download of their APK. A simple method of
hosting the contents of your current folder using Python can be done as follows:
$ python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 ...
10.0.0.100 - - [04/May/2014 22:27:14] "GET /agent.apk HTTP/1.1" 200 -
Browse to http://your_computer_ip:8000 on your device and click on the APK you want to install. You will be
prompted with an installation activity.
NOTE
To install an APK by browsing to it on a web server you must first select the Unknown sources box in your
device settings.
Other techniques may exist to install applications; however, the ones mentioned here are reliable and work on
any device regardless of whether you have root access on it. Other ways may include SSH access to the device or
even other installer desktop applications, but these are non-standard ways to perform installations and require
additional tools.
Using Tools to Explore Android
The best way to learn the internals of Android and become familiar with the way it works is to explore an
emulator or device armed with some basic knowledge about it. By exploring Android and becoming comfortable
with its internals, you will have the ability to investigate features for which no public information exists.
A simple example of this type of exploration is observing—through inspection of the tool or reading the source
code—how some of the standard SDK tools work.
ADB
For instance, when installing an application on the device you may see the following output:
$ adb install application.apk
541 KB/s (156124 bytes in 0.236s)
pkg: /data/local/tmp/application.apk
Success
This output shows that the user who runs adbd (which is typically “shell” on a normal non-rooted device) has
the ability to read, write, and execute files in the /data/local/tmp directory. When exploring a device that is not
rooted, you can use this directory but have insufficient privileges to access the /data parent directory.
ADB is the single most useful SDK tool for exploring Android. The following is a list of common tasks that you
can perform using ADB:
List connected devices—$ adb devices
Get a shell on a device—$ adb shell
Perform a shell command and return—$ adb shell 
Push a file to a device—$ adb push /path/to/local/file /path/on/android/device
Retrieve a file from a device—$ adb pull /path/on/android/device /path/to/local/file
Forward a TCP port on the local host to a port on the device—$ adb forward tcp:
tcp:
View the device logs—$ adb logcat
If more than one device is connected, prepend the ADB command with -s . If you have one
connected device and one emulator, instead of providing their device IDs with the -s argument, you can use -d
(for device) and -e (for emulator).
Some Android devices may come with a very limited set of utilities installed by default, and having additional
tools installed that ease the process of exploring the device is useful.
BusyBox
BusyBox incorporates a large variety of standard Linux utilities into a single binary. A common misconception
about running BusyBox on Android is that it requires root. This is incorrect, and users should be aware that
executing a BusyBox binary runs it under the same user account and privilege context of the calling process. You
can compile BusyBox with the utilities you require or download a pre-compiled binary that includes many
utilities. At the time of this writing, the BusyBox website provided pre-compiled binaries for many architectures
at http://www.busybox.net/downloads/binaries/. This includes ARM, which is the CPU architecture used by
the majority of Android devices. You can download a BusyBox binary for the correct architecture (ARMv7 in this
case) from the site and then upload it to the /data/local/tmp directory on your Android device without the need
for root access using the following command:
$ adb push busybox-armv7l /data/local/tmp
77 KB/s (1109128 bytes in 14.041s)
Get a shell on the device, browse to /data/local/tmp, and mark it executable using the following command:
shell@android:/ $ cd /data/local/tmp
shell@android:/data/local/tmp $ chmod 755 busybox-armv7l
Here is an output of the available tools provided by BusyBox:
shell@android:/data/local/tmp $ ./busybox-armv7l
./busybox-armv7l
BusyBox v1.21.1 (2013-07-08 10:26:30 CDT) multi-call binary.
...
acpid, add-shell, addgroup, adduser, adjtimex, arp, arping, ash,
awk, base64, basename, beep, blkid, blockdev, bootchartd, brctl,
bunzip2, bzcat, bzip2, cal, cat, catv, chat, chattr, chgrp, chmod,
chown, chpasswd, chpst, chroot, chrt, chvt, cksum, clear, cmp, comm,
conspy, cp, cpio, crond, crontab, cryptpw, cttyhack, cut, date, dc, dd,
deallocvt, delgroup, deluser, depmod, devmem, df, dhcprelay, diff,
dirname, dmesg, dnsd, dnsdomainname, dos2unix, du, dumpkmap,
dumpleases, echo, ed, egrep, eject, env, envdir, envuidgid, ether-wake,
expand, expr, fakeidentd, false, fbset, fbsplash, fdflush, fdformat,
fdisk, fgconsole, fgrep, find, findfs, flock, fold, free, freeramdisk,
fsck, fsck.minix, fsync, ftpd, ftpget, ftpput, fuser, getopt, getty,
grep, groups, gunzip, gzip, halt, hd, hdparm, head, hexdump, hostid,
hostname, httpd, hush, hwclock, id, ifconfig, ifdown, ifenslave,
ifplugd, ifup, inetd, init, insmod, install, ionice, iostat, ip,
ipaddr, ipcalc, ipcrm, ipcs, iplink, iproute, iprule, iptunnel,
kbd_mode, kill, killall, killall5, klogd, last, less, linux32, linux64,
linuxrc, ln, loadfont, loadkmap, logger, login, logname, logread,
losetup, lpd, lpq, lpr, ls, lsattr, lsmod, lsof, lspci, lsusb, lzcat,
lzma, lzop, lzopcat, makedevs, makemime, man, md5sum, mdev, mesg,
microcom, mkdir, mkdosfs, mke2fs, mkfifo, mkfs.ext2, mkfs.minix,
mkfs.vfat, mknod, mkpasswd, mkswap, mktemp, modinfo, modprobe, more,
mount, mountpoint, mpstat, mt, mv, nameif, nanddump, nandwrite,
nbd-client, nc, netstat, nice, nmeter, nohup, nslookup, ntpd, od,
openvt, passwd, patch, pgrep, pidof, ping, ping6, pipe_progress,
pivot_root, pkill, pmap, popmaildir, poweroff, powertop, printenv,
printf, ps, pscan, pstree, pwd, pwdx, raidautorun, rdate, rdev,
readahead, readlink, readprofile, realpath, reboot, reformime,
remove-shell, renice, reset, resize, rev, rm, rmdir, rmmod, route, rpm,
rpm2cpio, rtcwake, run-parts, runlevel, runsv, runsvdir, rx, script,
scriptreplay, sed, sendmail, seq, setarch, setconsole, setfont,
setkeycodes, setlogcons, setserial, setsid, setuidgid, sh, sha1sum,
sha256sum, sha3sum, sha512sum, showkey, slattach, sleep, smemcap,
softlimit, sort, split, start-stop-daemon, stat, strings, stty, su,
sulogin, sum, sv, svlogd, swapoff, swapon, switch_root, sync, sysctl,
syslogd, tac, tail, tar, tcpsvd, tee, telnet, telnetd, test, tftp,
tftpd, time, timeout, top, touch, tr, traceroute, traceroute6, true,
tty, ttysize, tunctl, udhcpc, udhcpd, udpsvd, umount, uname, unexpand,
uniq, unix2dos, unlzma, unlzop, unxz, unzip, uptime, users, usleep,
uudecode, uuencode, vconfig, vi, vlock, volname, wall, watch, watchdog,
wc, wget, which, who, whoami, whois, xargs, xz, xzcat, yes, zcat, zcip
This is a huge set of tools, many of which do not come as part of the Android image. Some of these tools are
common utilities used on a desktop or server version of Linux, such as cp and grep, which the Android image
inconveniently left out. Do not expect all the included tools to work fully, because some aspects of Android
simply do not work the same as on conventional Linux systems. You can add BusyBox to the shell’s PATH
environment temporarily without root by entering the following command:
shell@android:/ $ export PATH=$PATH:/data/local/tmp
Standard Android Tools
Some useful tools that are present on Android systems in the /system/bin directory include the following:
pm—This stands for “package manager” and is the command-line package management utility on Android. It
performs all tasks relating to installation, uninstallation, disabling, and information retrieval of installed
packages. Some useful commands are:
List all installed packages—shell@android:/ $ pm list packages
Find the stored APK path of an installed application—shell@android:/ $ pm path
Install a package—shell@android:/ $ pm install /path/to/apk
Uninstall a package—shell@android:/ $ pm uninstall 
Disable an installed application (useful for disabling pesky applications that came with your
device)—shell@android:/ $ pm disable 
logcat—This tool allows you to view system and application logs with flexible filters. This tool can only be
invoked by applications or users on the device that have the associated privilege level to do so.
If you would like to view all logs, simply run—shell@android:/ $ logcat
If you know the name of the tag you are looking for then you can filter by it
using—shell@android:/ $ logcat -s tag
NOTE
You can also use logcat directly from ADB by running adb logcat from a connected computer.
getprop—This tool allows you to retrieve all system properties including verbose hardware and software
information.
dumpsys—This tool displays information about the status of system services. If run without any arguments it
iterates through all system services. You can also find these services by running service list.
drozer
drozer is an Android assessment tool that was released in March 2012 at Blackhat EU under the name Mercury.
Its original intention was to eliminate the need for writing one-use applications that test for a certain issue, and
it has evolved into a full testing suite. It was created because of the need to test each aspect of an Android
application in a dynamic way. Put simply, drozer has two distinct use cases:
Finding vulnerabilities in applications or devices—It allows you to assume the role of an installed
Android application and interact with other apps and the underlying operating system in search of
vulnerabilities.
Providing exploits and useful payloads for known vulnerabilities—It does this by building
malicious files or web pages that exploit known vulnerabilities to install drozer as a remote administration
tool.
Chapter 7 focuses heavily on using drozer to find vulnerabilities, and Chapter 8 delves into the darker side of
drozer and ways of using provided exploits to gain access to Android devices as an attacker.
drozer has two different versions: the community and pro editions. The community edition provides the raw
power of drozer and gives the user access to a command-line interface only. It is also a fully open-source project
that was released under a 3-clause BSD license. The professional version focuses on features that make doing
Android security testing easy for people who do it as a part of their job. It provides a graphical user interface that
makes visualizing the large amount of information that can be collected during the course of a typical security
assessment of an Android device easier. Throughout the following chapters, the community edition of drozer is
used for two reasons: It is free, and it facilitates the learning of Android security better than the pro version,
mainly because it does not shield you from what it is doing under the hood. For more information about the
differences, see the tool’s homepage at https://www.mwrinfosecurity.com/products/drozer/.
How drozer Works
drozer is a distributed system that makes use of some key components:
Agent— A lightweight Android application that runs on the device or emulator being used for testing. There
are two versions of the agent, one that provides a user interface and embedded server and another that does
not contain a graphical interface and can be used as a Remote Administration Tool on a compromised device.
Since version 2.0, drozer supports “Infrastructure mode,” in which the agent establishes a connection
outward to traverse firewalls and NAT. This allows more realistic attack scenarios to be created and requires
a drozer server.
Console—A command-line interface running on your computer that allows you to interact with the device
through the agent.
Server—Provides a central point where consoles and agents can rendezvous, and routes sessions between
them.
These components use a custom protocol named drozerp (drozer protocol) to exchange data. The agent is
somewhat of an empty shell that knows only how to run commands it receives from the console and provide the
result. A very technically brilliant method of using the Java Reflection API facilitates the execution of code from
Python in the console to Java on the agent. This means that from Python code it is possible to instantiate and
interact with Java objects on the connected device.
Installing drozer
To set up drozer, visit https://www.mwrinfosecurity.com/products/drozer/community-edition/ and download
the package that is appropriate for your platform (Linux, Windows, or Mac). For standard application testing
purposes, the tool requires only two parts: an agent application that needs to be installed on your Android device
and a console that is run from your computer. You will require the following to install drozer successfully on
your computer:
Python 2.7
Java Development Kit (JDK) 1.6
Android SDK
ADB on your PATH
Java on your PATH
The drozer agent can be installed on your Android device using ADB. It is included as agent.apk in all download
packages or as a separate package on the download page. To install the agent on your device, perform the
following command:
$ adb install agent.apk
For more verbose information about installing drozer, please refer to the user guide presented on the download
page.
Starting a Session
You must first set up suitable port forwarding from your device or emulator to your computer because the
embedded server in the drozer agent listens on TCP port (31415 by default). Perform the following command to
forward this port to your computer:
$ adb forward tcp:31415 tcp:31415
You can now open the drozer agent on the device and turn on the Embedded Server option as shown in Figure
6.3.
Figure 6.3 The main activity of the drozer agent displaying the embedded server toggle.
On your computer you can now perform the following command to connect to your agent:
$ drozer console connect
You should now see a drozer command prompt that confirms your device ID and looks as follows: