## 总结延伸好了，关于 DMP和存储器的内容，讲到这里就差不多了。希望今天的这一讲，能够让你从Cassandra的数据库实现的细节层面，彻底理解怎么运用好存储器的性能特性和原理。传统的关系型数据库，我们把一条条数据存放在一个地方，同时再把索引存放在另外一个地方。这样的存储方式，其实很方便我们进行单次的随机读和随机写，数据的存储也可以很紧凑。但是问题也在于此，大部分的SQL请求，都会带来大量的随机读写的请求。这使得传统的关系型数据库，其实并不适合用在真的高并发的场景下。我们的 DMP需要的访问场景，其实没有复杂的索引需求，但是会有比较高的并发性。我带你一看了Facebook 开源的 Cassandra 这个分布式 KV 数据库的读写设计。通过在追加写入Commit Log 和更新内存，Cassandra 避开了随机写的问题。内存数据的 Dump和后台的对比合并，同样也都避开了随机写的问题，使得 Cassandra的并发写入性能极高。在数据读取层面，通过内存缓存和 BloomFilter，Cassandra已经尽可能地减少了需要随机读取硬盘里面数据的情况。不过挑战在于，DMP系统的局部性不强，使得我们最终的随机读的请求还是要到硬盘上。幸运的是，SSD硬盘在数据海量增长的那几年里价格不断下降，使得我们最终通过 SSD硬盘解决了这个问题。而 SSD 硬盘本身的擦除后才能写入的机制，正好非常适合 Cassandra的数据读写模式，最终使得 Cassandra 在 SSD 硬盘普及之后得到了更大的发展。
## 推荐阅读今天的推荐阅读，是一篇相关的论文。我推荐你去读一读[Cassandra - ADecentralized Structured StorageSystem](https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf)。读完这篇论文，一方面你会对分布式KV数据库的设计原则有所了解，了解怎么去做好数据分片、故障转移、数据复制这些机制；另一方面，你可以看到基于内存和硬盘的不同存储设备的特性，Cassandra是怎么有针对性地设计数据读写和持久化的方式的。
## 课后思考除了 MySQL 这样的关系型数据库，还有 Cassandra 这样的分布式 KV数据库。实际上，在海量数据分析的过程中，还有一种常见的数据库，叫作列式存储的OLAP的数据库，比如[Clickhouse](https://clickhouse.yandex/)。你可以研究一下，Clickhouse这样的数据库里面的数据是怎么存储在硬盘上的。欢迎把你研究的结果写在留言区，和大家一起分享、交流。如果觉得有帮助，你也可以把这篇文章分享给你的朋友，和他一起讨论、学习。![](Images/79d06107d349635530fbf82aa8dfb625.png){savepage-src="https://static001.geekbang.org/resource/image/28/29/281ca28b90c8aa0aecbb5adc08394f29.jpg"}
# 54 \| 理解Disruptor（上）：带你体会CPU高速缓存的风驰电掣坚持到底就是胜利，终于我们一起来到了专栏的最后一个主题。让我一起带你来看一看，CPU到底能有多快。在接下来的两讲里，我会带你一起来看一个开源项目Disruptor。看看我们怎么利用 CPU和高速缓存的硬件特性，来设计一个对于性能有极限追求的系统。不知道你还记不记得，在[第 37讲](https://time.geekbang.org/column/article/107477)里，为了优化 4毫秒专门铺设光纤的故事。实际上，最在意极限性能的并不是互联网公司，而是高频交易公司。我们今天讲解的Disruptor 就是由一家专门做高频交易的公司 LMAX 开源出来的。有意思的是，Disruptor 的开发语言，并不是很多人心目中最容易做到性能极限的C/C++，而是性能受限于 JVM 的Java。这到底是怎么一回事呢？那通过这一讲，你就能体会到，其实只要通晓硬件层面的原理，即使是像Java 这样的高级语言，也能够把 CPU 的性能发挥到极限。
## Padding Cache Line，体验高速缓存的威力我们先来看看 Disruptor 里面一段神奇的代码。这段代码里，Disruptor 在RingBufferPad 这个类里面定义了 p1，p2 一直到 p7 这样 7 个 long类型的变量。    abstract class RingBufferPad{    protected long p1, p2, p3, p4, p5, p6, p7;}我在看到这段代码的第一反应是，变量名取得不规范，p1-p7这样的变量名没有明确的意义啊。不过，当我深入了解了 Disruptor的设计和源代码，才发现这些变量名取得恰如其分。因为这些变量就是没有实际意义，只是帮助我们进行**缓存行填充**（PaddingCache Line），使得我们能够尽可能地用上 CPU 高速缓存（CPUCache）。那么缓存行填充这个黑科技到底是什么样的呢？我们接着往下看。``{=html}不知道你还记不记得，我们在[35讲](https://time.geekbang.org/column/article/107422)里面的这个表格。如果访问内置在CPU 里的 L1 Cache 或者 L2 Cache，访问延时是内存的 1/15 乃至1/100。而内存的访问速度，其实是远远慢于 CPU的。想要追求极限性能，需要我们尽可能地多从 CPU Cache里面拿数据，而不是从内存里面拿数据。![](Images/1185c366bea6a25742ba34e6901c8b59.png){savepage-src="https://static001.geekbang.org/resource/image/d3/a6/d39b0f2b3962d646133d450541fb75a6.png"}CPU Cache装载内存里面的数据，不是一个一个字段加载的，而是加载一整个缓存行。举个例子，如果我们定义了一个长度为64 的 long 类型的数组。那么数据从内存加载到 CPU Cache里面的时候，不是一个一个数组元素加载的，而是一次性加载固定长度的一个缓存行。我们现在的 64 位 Intel CPU 的计算机，缓存行通常是 64个字节（Bytes）。一个 long 类型的数据需要 8 个字节，所以我们一下子会加载8 个 long 类型的数据。也就是说，一次加载数组里面连续的 8个数值。这样的加载方式使得我们遍历数组元素的时候会很快。因为后面连续 7次的数据访问都会命中缓存，不需要重新从内存里面去读取数据。这个性能层面的好处，我在第37 讲的第一个例子里面为你演示过，印象不深的话，可以返回去看看。但是，在我们不是使用数组，而是使用单独的变量的时候，这里就会出现问题了。在Disruptor 的 RingBuffer（环形缓冲区）的代码里面，定义了一个单独的 long类型的变量。这个变量叫作 INITIAL_CURSOR_VALUE ，用来存放 RingBuffer起始的元素位置。![](Images/dbf902990d813a06e4a4767780531965.png){savepage-src="https://static001.geekbang.org/resource/image/23/f6/23adbbc656243ce85fdb8c7fab42ecf6.jpeg"}CPU在加载数据的时候，自然也会把这个数据从内存加载到高速缓存里面来。不过，这个时候，高速缓存里面除了这个数据，还会加载这个数据前后定义的其他变量。这个时候，问题就来了。Disruptor是一个多线程的服务器框架，在这个数据前后定义的其他变量，可能会被多个不同的线程去更新数据、读取数据。这些写入以及读取的请求，会来自于不同的CPU Core。于是，为了保证数据的同步更新，我们不得不把 CPU Cache里面的数据，重新写回到内存里面去或者重新从内存里面加载数据。而我们刚刚说过，这些 CPU Cache的写回和加载，都不是以一个变量作为单位的。这些动作都是以整个 Cache Line作为单位的。所以，当 INITIAL_CURSOR_VALUE前后的那些变量被写回到内存的时候，这个字段自己也写回到了内存，这个常量的缓存也就失效了。当我们要再次读取这个值的时候，要再重新从内存读取。这也就意味着，读取速度大大变慢了。    ......  abstract class RingBufferPad{    protected long p1, p2, p3, p4, p5, p6, p7;}  abstract class RingBufferFields extends RingBufferPad{    ......}  public final class RingBuffer extends RingBufferFields implements Cursored, EventSequencer, EventSink{    public static final long INITIAL_CURSOR_VALUE = Sequence.INITIAL_VALUE;    protected long p1, p2, p3, p4, p5, p6, p7;    ......![](Images/23b74ce54ddc42a49fed901436d13dd8.png){savepage-src="https://static001.geekbang.org/resource/image/f4/98/f416c28317e71975513b49d05875ab98.jpeg"}面临这样一个情况，Disruptor里发明了一个神奇的代码技巧，这个技巧就是缓存行填充。Disruptor 在INITIAL_CURSOR_VALUE 的前后，分别定义了 7 个 long 类型的变量。前面的 7个来自继承的 RingBufferPad 类，后面的 7 个则是直接定义在 RingBuffer类里面。这 14个变量没有任何实际的用途。我们既不会去读他们，也不会去写他们。而 INITIAL_CURSOR_VALUE又是一个常量，也不会进行修改。所以，一旦它被加载到 CPU Cache之后，只要被频繁地读取访问，就不会再被换出 Cache了。这也就意味着，对于这个值的读取速度，会是一直是 CPU Cache的访问速度，而不是内存的访问速度。
## 使用 RingBuffer，利用缓存和分支预测其实这个利用 CPU Cache 的性能的思路，贯穿了整个 Disruptor。Disruptor整个框架，其实就是一个高速的[生产者 -消费者模型](https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem)（Producer-Consumer）下的队列。生产者不停地往队列里面生产新的需要处理的任务，而消费者不停地从队列里面处理掉这些任务。![](Images/4d9962f96192dc3eae9fb559187f5ddc.png){savepage-src="https://static001.geekbang.org/resource/image/65/56/659082942118e7c69eb3807b00f5f556.jpeg"}如果你熟悉算法和数据结构，那你应该非常清楚，如果要实现一个队列，最合适的数据结构应该是链表。我们只要维护好链表的头和尾，就能很容易实现一个队列。生产者只要不断地往链表的尾部不断插入新的节点，而消费者只需要不断从头部取出最老的节点进行处理就好了。我们可以很容易实现生产者 -消费者模型。实际上，Java 自己的基础库里面就有 LinkedBlockingQueue这样的队列库，可以直接用在生产者 - 消费者模式上。![](Images/2ae1edd316b5b438c9f90d077a5f9f47.png){savepage-src="https://static001.geekbang.org/resource/image/45/0e/45d4c7c8b0cb1f056684199e39660f0e.jpeg"}不过，Disruptor 里面并没有用 LinkedBlockingQueue，而是使用了一个RingBuffer 这样的数据结构，这个 RingBuffer的底层实现则是一个固定长度的数组。比起链表形式的实现，数组的数据在内存里面会存在空间局部性。就像上面我们看到的，数组的连续多个元素会一并加载到 CPU Cache里面来，所以访问遍历的速度会更快。而链表里面各个节点的数据，多半不会出现在相邻的内存空间，自然也就享受不到整个Cache Line 加载后数据连续从高速缓存里面被访问到的优势。除此之外，数据的遍历访问还有一个很大的优势，就是 CPU层面的分支预测会很准确。这可以使得我们更有效地利用了 CPU里面的多级流水线，我们的程序就会跑得更快。这一部分的原理如果你已经不太记得了，可以回过头去复习一下[第25讲](https://time.geekbang.org/column/article/102166)关于分支预测的内容。