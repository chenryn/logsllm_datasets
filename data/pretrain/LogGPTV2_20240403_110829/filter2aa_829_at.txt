The layer data structure also contains a streamAction member, which is 
an FWPS_STREAM_ACTION_TYPE value describing an action that the callout recom-
mends the stream-layer shim take. These include:
Evading EDR (Early Access) © 2023 by Matt Hand
Network Filter Drivers   139
• 
Doing nothing (FWPS_STREAM_ACTION_NONE).
• 
Allowing all future data segments in the flow to continue without 
inspection (FWPS_STREAM_ACTION_ALLOW_CONNECTION).
• 
Requesting more data. If this is set, the callout must populate the  
countBytesRequired member with the number of bytes of stream data 
required (FWPS_STREAM_ACTION_NEED_MORE_DATA).
• 
Dropping the connection (FWPS_STREAM_ACTION_DROP_CONNECTION).
• 
Deferring processing until fwpkclnt!FwpsStreamContinue0() is called. 
This is used for flow control, to slow down the rate of incoming data 
(FWPS_STREAM_ACTION_DEFER).
Don’t confuse this streamAction member with the classifyOut parameter 
passed to the classify function to indicate the result of the filtering operation.
Evading Network Filters
You’re probably interested in evading network filters primarily because 
you’d like to get your command-and-control traffic to the internet, but 
other types of traffic are subject to filtering too, such as lateral movement 
and network reconnaissance.
However, when it comes to evading WFP callout drivers, there aren’t 
many options (at least not compared to those available for other sensor com-
ponents). In a lot of ways, evading network filters is very similar to performing 
a standard firewall rule assessment. Some filters may opt to explicitly permit 
or deny traffic, or they may send the contents off for inspection by a callout.
As with any other type of rule-coverage analysis, the bulk of the work 
comes down to enumerating the various filters on the system, their configu-
rations, and their rulesets. Thankfully, many available tools can make this 
process relatively painless. The built-in netsh command allows you to export 
the currently registered filters as an XML document, an example of which 
is shown in Listing 7-15.
PS > netsh
netsh> wfp
netsh wfp> show filters
Data collection successful; output = filters.xml
netsh wfp> exit
PS > Select-Xml .\filters.xml -XPath 'wfpdiag/filters/item/displayData/name' | 
>> ForEach-Object {$_.Node.InnerXML }
Rivet IpPacket V4 IpPacket Outbound Filtering Layer
Rivet IpPacket V6 Network Outbound Filtering Layer
Boot Time Filter
Boot Time Filter
Rivet IpV4 Inbound Transport Filtering Layer
Rivet IpV6 Inbound Transport Filtering Layer
Rivet IpV4 Outbound Transport Filtering Layer
Rivet IpV6 Outbound Filtering Layer
Evading EDR (Early Access) © 2023 by Matt Hand
140   Chapter 7
Boot Time Filter
Boot Time Filter
Listing 7-15: Enumerating registered filters with netsh
Because parsing XML can cause some headaches, you might prefer to 
use an alternative tool, NtObjectManager. It includes cmdlets for collecting 
information related to WFP components, including sublayer identifiers and 
filters.
One of the first actions you should perform to get an idea of what 
drivers are inspecting traffic on the system is to list all the non-default 
sublayers. You can do this using the commands shown in Listing 7-16.
PS > Import-Module NtObjectManager
PS > Get-FwSubLayer | 
>> Where-Object {$_.Name -notlike ‘WFP Built-in*’} |
>> select Weight, Name, keyname | 
>> Sort-Object Weight -Descending | fl
Weight : 32765
Name  
: IPxlat Forward IPv4 sub layer
KeyName : {4351e497-5d8b-46bc-86d9-abccdb868d6d}
Weight : 4096
Name  
: windefend
KeyName : {3c1cd879-1b8c-4ab4-8f83-5ed129176ef3}
Weight : 256
Name  
: OpenVPN
KeyName : {2f660d7e-6a37-11e6-a181-001e8c6e04a2}
Listing 7-16: Enumerating WFP sublayers using NtObjectManager
The weights indicate the order in which the sublayers will be evaluated 
during filter arbitration. Look for interesting sublayers worth exploring fur-
ther, such as those associated with applications that provide security moni-
toring. Then, using the Get-FwFilter cmdlet, return filters associated with 
the specified sublayer, as shown in Listing 7-17.
PS > Get-FwFilter | 
>> Where-Object {$_.SubLayerKeyName -eq '{3c1cd879-1b8c-4ab4-8f83-5ed129176ef3}'} | 
>> Where-Object {$_.IsCallout -eq $true} |
>> select ActionType,Name,LayerKeyName,CalloutKeyName,FilterId | 
>> fl
ActionType 
: CalloutTerminating
Name 
: windefend_stream_v4
LayerKeyName 
: FWPM_LAYER_STREAM_V4
CalloutKeyName : {d67b238d-d80c-4ba7-96df-4a0c83464fa7}
FilterId 
: 69085
Evading EDR (Early Access) © 2023 by Matt Hand
Network Filter Drivers   141
ActionType 
: CalloutInspection
Name 
: windefend_resource_assignment_v4
LayerKeyName 
: FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4
CalloutKeyName : {58d7275b-2fd2-4b6c-b93a-30037e577d7e}
FilterId 
: 69087
ActionType 
: CalloutTerminating
Name 
: windefend_datagram_v6
LayerKeyName 
: FWPM_LAYER_DATAGRAM_DATA_V6
CalloutKeyName : {80cece9d-0b53-4672-ac43-4524416c0353}
FilterId 
: 69092
ActionType 
: CalloutInspection
Name 
: windefend_resource_assignment_v6
LayerKeyName 
: FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6
CalloutKeyName : {ced78e5f-1dd1-485a-9d35-7e44cc9d784d}
FilterId 
: 69088
Listing 7-17: Enumerating filters associated with a subfilter layer
For our purposes, the most interesting filter in this layer is 
CalloutInspection, as it sends the contents of the network connection to 
the driver, which will determine whether to terminate the connection. 
You can inspect callouts by passing their key names to the Get-FwCallout 
cmdlet. Listing 7-18 shows the process of investigating one of Windows 
Defender’s filters.
PS > Get-FwCallout |
>> Where-Object {$_.KeyName -eq '{d67b238d-d80c-4ba7-96df-4a0c83464fa7}'} |
>> select *
Flags  
: ConditionalOnFlow, Registered
ProviderKey  
: 00000000-0000-0000-0000-000000000000
ProviderData  
: {}
ApplicableLayer  
: 3b89653c-c170-49e4-b1cd-e0eeeee19a3e
CalloutId  
: 302
Key 
: d67b238d-d80c-4ba7-96df-4a0c83464fa7
Name  
: windefend_stream_v4
Description  
: windefend
KeyName  
: {d67b238d-d80c-4ba7-96df-4a0c83464fa7}
SecurityDescriptor : --snip--
ObjectName  
: windefend_stream_v4
NtType  
: Name = Firewall - Index = -1
IsContainer  
: False
Listing 7-18: Using NtObjectManager to inspect WFP filters
This information helps us determine the type of traffic being inspected, 
as it includes the layer for which the callout is registered; a description that 
could make understanding the purpose of the callout more easily identifi-
able; and the security descriptor, which can be audited to find any poten-
tial misconfigurations that would grant excessive control over it. But it still 
doesn’t tell us exactly what the driver is looking for. No two EDR vendors will 
Evading EDR (Early Access) © 2023 by Matt Hand
142   Chapter 7
inspect the same attributes in the same way, so the only way to know what a 
driver is examining is to reverse-engineer its callout routines.
We can, however, assess WFP filters by looking for configuration 
gaps like those found in standard firewalls. After all, why bother reverse-
engineering a driver when we could just look for rules to abuse? One of my 
favorite ways of evading detection is to find gaps that allow the traffic to 
slip through. For example, if a callout only monitors IPv4 traffic, traffic sent 
using IPv6 won’t be inspected.
Because bypasses vary between vendors and environments, try look-
ing for rules that explicitly allow traffic to a certain destination. In my 
experience, these are usually implemented for the particular environment 
in which the EDR is deployed rather than being part of the EDR’s default 
configuration. Some might even be outdated. Say you discover an old rule 
allowing all outbound traffic on TCP port 443 to a certain domain. If the 
domain has expired, you may be able to purchase it and use it as an HTTPS 
command-and-control channel.
Also look for specific filter configurations that you can take advantage 
of. For instance, a filter might clear the FWPM_FILTER_FLAG_CLEAR_ACTION_RIGHT. 
As a result, lower-priority filters won’t be able to override this filter’s deci-
sions. Now say that an EDR explicitly allows traffic to egress to a domain 
and clears the aforementioned flag. Even if a lower-priority filter issues a 
block, the traffic will still be allowed out.
(Of course, as with all things WFP, it’s not exactly that simple. There 
exists a flag, FWPS_RIGHT_ACTION_WRITE, that vetoes this decision if reset prior to 
the evaluation of the filter. This is called a filter conflict, and it causes a few 
things to happen: the traffic is blocked, an audit event is generated, and 
applications subscribed to notifications will receive one, allowing them to 
become aware of the misconfiguration.)
In summary, evading WFP filters is a lot like evading traditional fire-
walls: we can look for gaps in the rulesets, configurations, and inspection 
logic implemented by an EDR’s network filter driver to find ways of getting 
our traffic out. Evaluate the viability of each technique in the context of the 
environment and each EDR’s particular filters. In some cases, this can be as 
simple as reviewing the filtering rules. In others, this may mean a deep dive 
into the driver’s inspection logic to determine what is being filtered and how.
Conclusion
Network filter drivers have the capability to allow, deny, or inspect net-
work traffic on the host. Most relevant to EDR is the inspection function 
facilitated by these drivers’ callouts. When an attacker activity involves the 
network stack, such as command-and-control agent beaconing and lateral 
movement, a network filter driver sitting inline of the traffic can pick out 
indicators of it. Evading these callouts requires understanding the types of 
traffic they wish to inspect and then identifying gaps in coverage, not dis-
similar to a standard firewall rule audit.
Evading EDR (Early Access) © 2023 by Matt Hand
Using the Event Tracing for Windows 
(ETW) logging facility, developers can 
program their applications to emit events, 
consume events from other components, and 
control event-tracing sessions. This allows them to 
trace the execution of their code and monitor or 
debug potential issues. It may be helpful to think of 
ETW as an alternative to printf-based debugging; the 
messages are emitted over a common channel using a 
standard format rather than printed to the console.
In a security context, ETW provides valuable telemetry that wouldn’t 
otherwise be available to an endpoint agent. For example, the common lan-
guage runtime, which is loaded into every .NET process, emits unique events 
using ETW that can provide more insight than any other mechanism into the 
nature of managed code executing on the host. This allows an EDR agent to 
collect novel data from which to create new alerts or enrich existing events.
8
E V E N T  T R ACING FOR W IN DOW S
Evading EDR (Early Access) © 2023 by Matt Hand
144   Chapter 8
ETW is rarely praised for its simplicity and ease of use, thanks in no 
small part to the tremendously complicated technical documentation that 
Microsoft provides for it. Luckily, while ETW’s inner workings and imple-
mentation details are fascinating, you don’t need a full understanding of 
its architecture. This chapter covers the parts of ETW that are relevant to 
those interested in telemetry. We’ll walk through how an agent might col-
lect telemetry from ETW and how to evade this collection.
Architecture
There are three main components involved in ETW: providers, consumers, 
and controllers. Each of these components serves a distinct purpose in an 
event-tracing session. The following overview describes how each compo-
nent fits into the larger ETW architecture.
Providers
Simply put, providers are the software components that emit events. 
These might include parts of the system, such as the Task Scheduler, a 
third-party application, or even the kernel itself. Generally, the provider 
isn’t a separate application or image but rather the primary image associ-
ated with the component.
When this provider image follows some interesting or concerning code 
path, the developer can opt to have it emit an event related to its execution. 
For example, if the application handles user authentication, it might emit 
an event whenever authentication fails. These events contain any data the 
developer deems necessary to debug or monitor the application, ranging 
from a simple string to complex structures.
ETW providers have GUIDs that other software can use to identify them. 
In addition, providers have more user-friendly names, most often defined 
in their manifest, that allow humans to identify them more easily. There 
are around 1,100 providers registered in default Windows 10 installations. 
Table 8-1 includes those that endpoint security products might find helpful.
Table 8-1: Default ETW Providers Relevant to Security Monitoring
Provider name
GUID
Description
Microsoft-Antimalware-
Scan-Interface
{2A576B87-09A7-520E-
C21A-4942F0271D67}
Supplies details about the data 
passed through the Antimalware 
Scan Interface (AMSI)
Microsoft-Windows-
DotNETRuntime
{E13C0D23-CCBC-4E12-
931B-D9CC2EEE27E4}
Provides events related to .NET 
assemblies executing on the local 
host
Microsoft-Windows-
Audit-CVE
{85A62A0D-7E17-485F-
9D4F-749A287193A6}
Provides a mechanism for soft-
ware to report attempts to exploit 
known vulnerabilities
Microsoft-Windows-
DNS-Client
{1C95126E-7EEA-49A9-
A3FE-A378B03DDB4D}
Details the results of domain name 
resolution on the host
Evading EDR (Early Access) © 2023 by Matt Hand
Event Tracing for Windows   145
Provider name
GUID
Description
Microsoft-Windows-
Kernel-Process
{22FB2CD6-0E7B-422B-
A0C7-2FAD1FD0E716}
Provides information related to 
the creation and termination of 
processes (similar to what a driver 
can obtain using a process- creation 
callback routine)
Microsoft-Windows-
PowerShell
{A0C1853B-5C40-4B15-
8766-3CF1C58F985A}
Provides PowerShell script  
block-logging functionality
Microsoft-Windows-RPC
{6AD52B32-D609-4BE9-
AE07-CE8DAE937E39}
Contains information related to 
RPC operations on the local system
Microsoft-Windows-
Security-Kerberos
{98E6CFCB-EE0A-41E0-
A57B-622D4E1B30B1}
Provides information related to 
Kerberos authentication on the host
Microsoft-Windows-
Services
{0063715B-EEDA-4007-
9429-AD526F62696E}
Emits events related to the instal-
lation, operation, and removal of 
services
Microsoft-Windows-
SmartScreen
{3CB2A168-FE34-4A4E-
BDAD-DCF422F34473}
Provides events related to 
Microsoft Defender SmartScreen 
and its interaction with files  
downloaded from the internet
Microsoft-Windows-