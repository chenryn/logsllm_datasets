messages cross the native frame, the native code is instrumented
by the module “Native Code Instrumentation”. Then, by
collecting and analyzing the information generated by above
modules, message senders and receivers can be identiﬁed and
linked together, which is done by the module “Source & Target
Link Generation”. Finally, the “Message Content Collection”
module dumps all content of delivered messages, which are
further analyzed in “Message Origin Analysis” to determine
the existence of OSV.
We next describe the design details of each sub-module.
1) Hybrid postMessage Identiﬁcation:
a) Tester: To trigger WebView and run native code (for
triggering message senders in the native frame), we use a
random UI explorer “Monkey” to simulate users’ behaviors
[18]. Once WebView is started, network activities may occur.
Then, the pre-deﬁned JavaScript fuzzing code is injected into
network trafﬁc based on our threat model (Section II-B), which
is done using the popular proxy tool “mitmproxy” [19]. Please
note that in order to perform network attacks, network links
are crawled to check if a HTTP link can be navigated. For
convenience, we limit the crawl depth as three.
The above injected JavaScript fuzzing code is designed to
drive the test on W→N. Usually, the JavaScript methods that
send messages (e.g., window.postMessage()) are called in all
746
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:50 UTC from IEEE Xplore.  Restrictions apply. 
,ǇďƌŝĚ
ƉƉůŝĐĂƚŝŽŶ
dĞƐƚĞƌ
ŶĂůǇƐŝƐ
/ŶƐƚƌƵŵĞŶƚĂƚŝŽŶ
^ŽƵƌĐĞΘdĂƌŐĞƚ
DĞƐƐĂŐĞŽŶƚĞŶƚ
>ŝŶŬ'ĞŶĞƌĂƚŝŽŶ
ŽůůĞĐƚŝŽŶ
sƵůŶĞƌĂďŝůŝƚŝĞƐ
,dD>ͬ:^
,dD>ͬ:^
EĂƚŝǀĞŽĚĞ/ŶƐƚƌƵŵĞŶƚĂƚŝŽŶ
WŚĂƐĞηϭ͘,ǇďƌŝĚƉŽƐƚDĞƐƐĂŐĞ /ĚĞŶƚŝĨŝĐĂƚŝŽŶ
WŚĂƐĞηϮ͘DĞƐƐĂŐĞKƌŝŐŝŶŶĂůǇƐŝƐ
Figure 6: OSV-Hunter’s Workﬂow
kinds of environments. It is implemented mainly based on
existing work, such as the work of Schwenk et al. [20].
Please note that even when a WebView component is started,
Monkey is still kept running. It is because this is helpful to
trigger as much native code as possible, and thus, message
senders in the native frame may be triggered.
b) HTML/JS Analysis And Instrumentation: When HTML
is going to be loaded in WebView, the HTML content is
analyzed and instrumented as follows. First, the ﬁrst page of
the HTML code and all JavaScript code are cached in local
storage for further instrumentation. Please note that JavaScript
code will be handled by JS Analysis and JS Instrumentation
later. Then, all important remote links in HTML are converted
to local links, such as the link speciﬁed by the “src” attribute of
the element “”. So that the local instrumented content
can be loaded in run-time, instead. To analyze and instrument
the content of nested frames, an extra WebView event handler
implementation of shouldInterceptRequest() (Section II-A) is
imported to handle the nested frame loading event, and control
the content of nested frames.
JavaScript code is analyzed and instrumented as follows.
First, message senders (such as window.postMessage()) are
identiﬁed and handled by inserting extra instructions to print
necessary information (like the origin of the web frame that
the message sender belongs to), and instrumenting the method
parameters, such as inserting ID if ID does not exist.
Then, message handlers are processed. To hook a message
handler method f , a wrapper function f (cid:3), which has the same
function prototype with f , is deﬁned to replace f . In f (cid:3), all
necessary information is printed, such as the web frame’s origin
and the method parameters, and then, f is called and fed with
f (cid:3)’s parameters. In this way, the original semantic of the web
code is kept. To track the message content received by f (cid:3), ID
is injected.
c) Native Code Instrumentation: Native code is instru-
mented to discover all message sending and receiving activities.
To discover a message receiver of W→N, all native functions’
parameters are checked, which is done by instrumenting the
run-time interpreter in Android ART (i.e., DoCall() in the ﬁle
“interpreter_common.cc”). If a parameter is a string, its low-
level object StringObject is retrieved for further analysis, such
as converting it back to a normal string, and checking if ID
exists.
To discover the message sender of N→W , critical APIs
(such as WebView.loadUrl() and WebView.postWebMessage())
are monitored, which is done by instrumenting the Android
framework code to record the parameters of these APIs. Please
note that if the parameters of WebView.loadUrl() are JavaScript
code, the JavaScript code will be analyzed by the sub-module
JS Analysis and Instrumentation. If postWebMessage() is called,
the message content to be sent is also instrumented by inserting
ID.
d) Message Source And Target Link Generation: Guided
by the insight and observation (Section III), message senders
and receivers in both native and web frames can be identiﬁed.
First, all log information that is generated by HTML/JS Analysis
and Instrumentation, and Native Code Instrumentation is
collected. Then, the log is ﬁltered using the special format of ID.
Finally, message senders and receivers can be linked together
by matching ID. Since each ID is unique, the established links
are also unique.
2) Message Origin Analysis:
a) Message Content Collection: To determine the exis-
tence of OSV, the content of all delivered messages are fully
dumped and collected. In the native frame, the content of all
related low level objects (e.g., StringObject) are dumped. In the
web frames, the content of all JavaScript variables is printed. If
a variable is an object, all its ﬁelds (including inherited ﬁelds),
and the corresponding values are logged.
All other critical logs are also gathered, such as the ones
containing origin information of message senders and receivers.
b) Vulnerability Determination: OSV can be determined
based on the deﬁnitions of the four sub-vulnerabilities (Section
II-C). More speciﬁcally, V1 and V4 can be automatically
determined by checking if the origin information is contained
in relevant APIs or delivered messages using the information
collected by the sub-module “Message Content Collection”.
However, for V2 and V3, it is challenging to analyze the origin
information, since the native frame does not have an explicit
origin. Hence, manual efforts may be needed in this phase.
C. Implementation
We implement OSV-Hunter by instrumenting the Android
source code (the 6.0 version). All modules are built from
scratch, except HTML/JavaScript analysis and instrumentation.
The HTML analysis and instrumentation module is built
based on JSoup 1.10.3, and the JavaScript analysis and
instrumentation module relies on Mozilla Rhino 1.7.7. JSoup
and Rhino are written in Java, and added into WebView as
libraries. Please note that Rhino is very powerful, but in OSV-
Hunter, we only statically use it to generate and manipulate
AST (Abstract Syntax Tree) of target JavaScript code, and
convert AST back to new JavaScript code.
747
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:50 UTC from IEEE Xplore.  Restrictions apply. 
IV. STUDY OF HYBRID POSTMESSAGE AND OSV
A. Data Set
To build an appropriate data set for the evaluation, we
crawled 17K most popular free apps from 32 categories (top
540 apps for each category) in Google Play in July 2017.
However, not all apps should be analyzed. For example, some
apps do not even use WebView.
Therefore, to reduce the workload, we establish two qualiﬁ-
cations to narrow down our data set. The ﬁrst one is that apps
must contain at least one WebView instance. Thus, we use the
keyword “WebView” on apps’ disassembled code to statically
ﬁlter apps.
that apps
The other qualiﬁcation is
should contain
postMessage-related code. To avoid potential false negatives,
both regular and hybrid postMessage should be included. For
this purpose, we use the background knowledge (Section
II-A) to establish our static ﬁlter. An expected app should
contain postMessage-related keywords such as: 1) “postMes-
sage”, which is used to send messages; 2) “WebMessage”,
which is frequently contained in ofﬁcial APIs, such as “Web-
View.postWebMessage()”; 3) “onmessage”, which is the global
message handler; 4) “addEventListener("message"”, which is
used to register message handlers.
As a result, 1,104 apps remain as our data set.
B. Results
In our study, we deployed OSV-Hunter in Nexus 5 to identify
apps that contain actual hybrid postMessage implementations.
Each app was tested for 10 minutes. Finally, we identiﬁed 74
apps that implemented hybrid postMessage and we also found
that all these apps were vulnerable.
The results are summarized in Table II. Several popular third-
party frameworks or libraries (like Facebook React Native,
and Google cloud print) suffer from OSV, and may cause
serious consequences, such as remote real-time microphone
monitoring, permanent data race, internal data manipulation,
denial of service (DoS) and so on. Furthermore, several high-
proﬁle apps are impacted. For example, the Google cloud print
service in Adobe Reader and WPS ofﬁce may suffer from DoS
attacks due to the OSV.
As shown in Table II, both N→W and W→N are demanded
and implemented by developers. For N→W , it is supported
in the React Native framework, the EclipseSource app, and
the WebView ofﬁcial API WebView.postWebMessage(). All
the implementations except WebView.postWebMessage() suffer
from V1, since the target origin of the message to be sent
cannot be speciﬁed. All the implementations, including Web-
View.postWebMessage(), may be impacted by V2, as the source
origin is not well provided in the message receiver. More
speciﬁcally, in the React Native framework, the source origin of
N→W is “undeﬁned”. It is because a customized data structure
is designed to carry the delivered message. In the data structure,
the “data” ﬁeld is set to contain the message content. However,
another important ﬁeld “origin” is not deﬁned. Hence, when a
message receiver reads the source origin of a received message,
“undeﬁned” is obtained.
Although we did not ﬁnd a good counter-example to prove
the origin “undeﬁned” is wrong for the native frame (such as
“undeﬁned” may be not unique), “undeﬁned” is meaningless and
hard to manage. As discussed in Section II-C, such meaningless
origins may cause more security issues, such as CSV. A
similar problem is also found in WebView.postWebMessage(),
which provides a meaningless origin (empty string) as the
source origin. It is because in the native layer, the internal
implementation of postWebMessage() does not explicitly deﬁne
the origin of the native frame, and NULL is used at default.
Correspondingly, in the web space, an empty string is treated
as the source origin.
it
For W→N,
Different from the above implementations, the EclipseSource
app provides the source origin. However, the origin may not
be correct. It is because in this app, the JavaScript method
parent.postMessage() is hijacked by a JavaScript Bridge, where
the origin of the top frame is always used as the message source
origin, even when a message is sent from an iframe.
is implemented in all developers’ hy-
brid postMessage implementations. This suggests W→N
is highly demanded, and thus
the ofﬁcial API Web-
View.postWebMessage() that provides the simple functionality
does not meet the requirement (Section I).
However, all W→N implementations are also impacted by
OSV, especially the sub-vulnerability V4. Note that V3 is not
ﬂagged even though the required origin is not transferred. It is
because although in W→N the target origin cannot be speciﬁed,
it is implied in the message-sending methods themselves.
More speciﬁcally, to implement W→N, developers rewrite the
JavaScript method “window.postMessage()” to send a message
to the native frame at default. Hence, if the native frame is
unique, the target origin information should be implied in the
APIs themselves, since the native frame is the sole destination.
In fact, the native frame is unique. “window.open()” may create
a new native frame, but it does not inﬂuence the original native
frame’s uniqueness. It is because the new native frame is totally
independent of the original native frame, and web frames can
only communicate with their corresponding native frames.
V4 exists in all implementations. All source origins are lost
during message delivery. Hence, if malicious code is injected
into WebView, the malicious code can freely access the internal
functionalities inside the message receiver of the native frame.
Section IV-D demonstrates this sub-vulnerability may introduce
serious consequences.
C. Findings
From our study results, we have the following ﬁndings.
• Developers wrongly assume the content loaded in WebView is
trustable: This wrong assumption is reﬂected in developers’
implementations. For instance, in N→W , their implemen-
tations usually do not provide an interface to specify the
target origin. No matter what origin is loaded in the target
web frame, the message will be delivered. In W→N, when
the native frame receives a message, the source origin of
the message is not provided. This indicates that the content
748
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:50 UTC from IEEE Xplore.  Restrictions apply. 
Vulnerability Name
(App or Framework)
Impacted Apps
/ Total Apps
Example App
Vulnerability Type
Native → Web Web → Native
V4
V1
V3
V2
Consequences
Facebook
React Native
Google Print
Eclipse Source
WebView’s
postWebMessage()
Total Vulnerable Apps
/ Total Apps
43/43
30/30
1/1
0/0
74/74
com.altvr.xxx
com.giantfood.xxx
...
com.adobe.xxx
cn.wps.xxx
...
com.eclipsesource.xxx

?

