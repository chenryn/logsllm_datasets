# 错误处理与异常
---
- https://www.kancloud.cn/imxieke/ruby-base/107297
---
# 关于错误处理
在程序执行的过程中，通常会有以下错误发生：
- 数据错误
    在计算家庭收支的时候，若在应该写金额的一栏上填上了商品名，那么就无法计算。此外，HTML 这种格式的数据的情况下，如果存在没有关闭标签等语法错误，也会导致无法处理数据。
- 系统错误
    硬盘故障等明显的故障，或者没把 CD 插入到驱动器等程序无法恢复的问题。
- 程序错误
    因调用了不存在的方法、弄错参数值或算法错误而导致错误结果等，像这样，程序本身的缺陷也可能会导致错误。
    程序在运行时可能会遇到各种各样的错误。如果对这些错误放任不管，大部分程序都无法正常运行，因此我们需要对这些错误做相应的处理。
- 排除错误的原因
    在文件夹中创建文件时，如果文件夹不存在，则由程序本身创建文件夹。如果程序无法创建文件夹，则需要再考虑其他解决方法。
- 忽略错误
    程序有时候也会有一些无伤大雅的错误。例如，假设运行程序时需要读取某个配置文件，如果我们事前已经在程序中准备好了相应配置的默认值，那么即使无法读取该设定文件，程序也可以忽略这个错误。
- 恢复错误发生前的状态
    向用户提示程序发生错误，指导用户该如何进行下一步处理。
- 重试一次
    曾经执行失败的程序，过一段时间后再重新执行可能就会成功。
- 终止程序
    只是自己一个人用的小程序，也许本来就没必要做错误处理。
    而至于实际应该采取何种处理，则要根据程序代码的规模、应用程序的性质来决定，不能一概而论。但是，对于可预期的错误，我们需要留意以下两点：
- 是否破坏了输入的数据，特别是人工制作的数据。
- 是否可以对错误的内容及其原因做出相应的提示。
    覆盖了原有文件、删除了花费大量时间输入的数据等，像这样的重要数据的丢失、破坏可以说是灾难性的错误。另外，如果错误是由用户造成的，或者程序自身不能修复的话，给用户简明易懂的错误提示，会大大提升程序的用户体验。
# 异常处理
在程序执行的过程中，如果程序出现了错误就会发生异常。异常发生后，程序会暂时停止运行，并寻找是否有对应的异常处理程序。如果有则执行，如果没有，程序就会显示类似以下信息并终止运行。
```ruby
> ruby test.rb
test.rb:2:in `initialize': No such file or directory - /no/file(Errno::ENOENT)
        from test.rb:2:in `open'
        from test.rb:2:in `foo'
        from test.rb:2:in `bar'
        from test.rb:9:in `main'
```
该信息的格式如下：
```ruby
文件名: 行号:in 方法名: 错误信息（异常类名）
from 文件名: 行号:in 方法名
    ┊
```
以 `from` 开头的行表示发生错误的位置。
没有异常处理的编程语言的情况下，编程时就需要逐个确认每个处理是否已经处理完毕。在这类编程语言中，大部分程序代码都被花费在错误处理上，因此往往会使程序变得繁杂。
异常处理有以下优点：
- 程序不需要逐个确认处理结果，也能自动检查出程序错误
- 会同时报告发生错误的位置，便于排查错误
- 正常处理与错误处理的程序可以分开书写，使程序便于阅读
# 异常处理的写法
Ruby 中使用 `begin ～ rescue ～ end` 语句描述异常处理。
```ruby
begin
 可能会发生异常的处理
rescue
 发生异常时的处理
end
```
在 Ruby 中，异常及其相关信息都是被作为对象来处理的。在 `rescue` 后指定变量名，可以获得异常对象。
```ruby
begin
 可能会发生异常的处理
rescue => 引用异常对象的变量
 发生异常时的处理
end
```
即使不指定变量名，Ruby 也会把异常对象赋值给变量 `$!`。不过，把变量名明确地写出来会使程序更加易懂。
异常发生时被自动赋值的变量
变量	| 意义
- | -
$!	    | 最后发生的异常（异常对象）
$@	    | 最后发生的异常的位置信息
异常对象的方法
方法名	| 意义
- | -
class	    | 异常的种类
message	    | 异常信息
backtrace	| 异常发生的位置信息（$@ 与 $!.backtrace 是等价的）
下面是 Unix 的 wc 命令的简易版。结果会输出参数中指定的各文件的行数、单词数、字数（字节数），最后输出全部文件的统计结果。
```ruby
ltotal=0                             # 行数合计
wtotal=0                             # 单词数合计
ctotal=0                             # 字数合计
ARGV.each do |file|
  begin
    input = File.open(file)          # 打开文件（A）
    l=0                              # file 内的行数
    w=0                              # file 内的单词数
    c=0                              # file 内的字数
    input.each_line do |line|
      l += 1
      c += line.size
      line.sub!(/^\s+/, "")          # 删除行首的空白符
      ary = line.split(/\s+/)        # 用空白符分解
      w += ary.size
    end
    input.close                      # 关闭文件
    printf("%8d %8d %8d %s\n", l, w, c, file)  # 整理输出格式
    ltotal += l
    wtotal += w
    ctotal += c
  rescue => ex
    print ex.message, "\n"           # 输出异常信息（B）
    end
end
printf("%8d %8d %8d %s\n", ltotal, wtotal, ctotal, "total")
```
执行示例
```
> ruby wc.rb intro.rb sec01.rb sec02.rb
       50       67      1655 intro.rb
       81       92      3455 sec01.rb
      123      162      3420 sec02.rb
      254      321      8520 total
```
在（A）处无法打开文件时，程序会跳到 `rescue` 部分。这时，异常对象被赋值给变量 `ex`，（B）部分的处理被执行。
如果程序中指定了不存在的文件，则会提示发生错误，如下所示。提示发生错误后，并不会马上终止程序，而是继续处理下一个文件。
```
> ruby wc.rb intro.rb sec01.rb sec02.rb sec03.rb
       50       67      1655 intro.rb
       81       92      3455 sec01.rb
      123      188      3729 sec02.rb
No such file or directory - sec03.rb
      254      321      8520 total
```
如果发生异常的方法中没有 `rescue` 处理，程序就会逆向查找调用者中是否定义了异常处理。下面来看看下图这个例子。调用 `foo` 方法，尝试打开一个不存在的文件。若 `File.open` 方法发生异常，那么该异常就会跳过 `foo` 方法以及 `bar` 方法，被更上一层的 `rescue` 捕捉。
然而，并不是说每个方法都需要做异常处理，只需根据实际情况在需要留意的地方做就可以了。在并不特别需要解决错误的情况下，也可以不捕捉异常。当然，不捕捉异常就意味着如果有问题发生程序就会马上终止。
# 后处理
不管是否发生异常都希望执行的处理，在 Ruby 中可以用 `ensure` 关键字来定义。
```ruby
begin
 有可能发生异常的处理
rescue => 变量
 发生异常后的处理
ensure