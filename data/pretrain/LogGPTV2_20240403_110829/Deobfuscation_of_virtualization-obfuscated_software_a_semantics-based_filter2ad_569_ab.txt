instruction appears in the trace. A variable appearing on the right
hand side of an equation (i.e., a variable that is being used) is num-
bered according to the instruction that deﬁned it. These deﬁning
instructions are found by searching backwards through the trace to
identify where the deﬁnition came from.
. . .
/*I10*/ mov ebx, 0x0
/*I11*/
/*I12*/
/*I13*/
/*I14*/
pop eax
add ebx, eax
pop eax
sub ebx, eax
(a)
. . .
ebx10 = 0x0
eax11 = ValueAt(M1000)
esp11 = esp8 + 4
ebx12 = ebx10 + eax11
eﬂags12 = Flag(ebx10 + eax11)
eax13 = ValueAt(M1004)
esp13 = esp11 + 4
ebx14 = ebx12 - eax13
eﬂags14 = Flag(ebx12 - eax13)
(b)
Figure 1: Simple example of translating instructions into equiv-
alent equations.
Consider the example in Figure 1. Figure 1(a) gives a snippet
of x86 assembly code, and Figure 1(b) gives the equivalent equa-
tions generated by our system. We are assuming that the value of
277the stack pointer esp before instruction I10 executes is 1000. We
use the notation “ValueAt(M1000)” to indicate the value stored at
memory location 1000. Notice that the eax used in the equations
for instruction I12 is not the same as the eax used in the equations
for instruction I14, as is indicated by our numbering scheme.
Also notice that we are explicitly handling the setting of the
eﬂags register by generating its own equation. We introduce the
“Flag” operation to indicate the calculation of the ﬂag register value
based on the expression passed as a parameter. So, for instruction
I12, ebx gets the result of adding ebx10 to eax11, and the eﬂags
register gets changed according the result of that same operation.
For our purposes here, we are primarily concerned with the cal-
culation of the target addresses of control ﬂow instructions. Specif-
ically, as described, we need to determine if any component of the
calculation of such a target address is dependent on the value of
some ﬂag calculation. With our equational reasoning system, we
need to generate a simpliﬁed expression for the target address at
the point it is used, then check that expression to see if it contains
any calls to the “Flag” operation.
We must also account for the possibility of additional or trivial
conditional logic added for the purpose of obfuscation. The obfus-
cation routine cannot change the behavior of the original program,
but it can add branch statements that are always true or always false,
to try to confuse analysis. For this reason, we can eliminate any
conditional logic that reduces to a constant boolean value.
Next, we will examine several examples of increasing complex-
ity to show how our system correctly identiﬁes these conditional
dependencies. First, we look at the simple example in Figure 2(a),
where the normal branch instructions are used to implement condi-
tional control ﬂow. We know that the jnz instruction uses the value
of the eﬂags register to decide whether or not to branch, so we add
a new equation at the point of the jnz instruction to represent the
value of the eﬂags register.
. . .
/*I10*/
cmp ebx, eax
/*I11*/ mov ebx, 0x0
/*I12*/ mov eax, 0x10
/*I13*/
jnz 10000
(a)
. . .
eﬂags10 = Flag(ebx7 cmp eax6)
ebx11 = 0x0
eax12 = 0x10
eﬂags13 = eﬂags10
(b)
Figure 2: Identifying control dependencies with branch in-
structions.
As seen in Figure 2(b), when we trace back to ﬁnd the deﬁnition
of the right hand side, we see that it is the value of eﬂags from
instruction I10 that is being used. By substituting the deﬁnition
of eﬂags10, we see that the value of the ﬂags register used by the
conditional jump instrution is “Flag(ebx7 cmp eax6).”
Next, we consider a case where the standard branch instruc-
tions are not used. This case would be anticipated when analyzing
virtualization-obfuscated code, since the dispatch routine typically
handles all control ﬂow. Consider the code snippet in Figure 3(a).
We see that the indirect jump of instruction I16 is indexing into a
table located at address 0x10000. The value of eax indexes into the
table some number of 4-byte values. Instruction I10 sets eax equal
to some index value to be used. Instructions I11 through I15 per-
form some comparison that sets the value of the ﬂags register, then
moves the ﬂag value into the ebx register, and masks the value. The
effect is as follows. If the result of the comparison turned on the
“zero” ﬂag, then the value of the ebx register after instruction I14
is one, otherwise, it is zero. The value in ebx is then added to the
index value stored in eax such that the actual index value used in
the jump depends on the result of the comparison in instruction I11.
In the context of virtualization-obfuscated code, the index value is
the byte code of the next instruction, and the table contains the ad-
dresses of virtual instruction implementations.
. . .
/*I10*/ mov eax, index
/*I11*/
/*I12*/
/*I13*/
/*I14*/
/*I15*/
/*I16*/
cmp ebx, ecx
pushf
pop ebx
and ebx, 0x1
add eax, ebx
jump [eax*4 + 0x10000]
(a)
. . .
eax10 = index
eﬂags11 = Flag(ebx4 cmp ecx3)
esp12 = esp9 - 4
ValueAt(M1000)12 = eﬂags11
ebx13 = ValueAt(M1000)12
ebx14 = ebx13 & 0x1
eax15 = eax10 + ebx14
target16 = eax15 * 4 + 0x10000
(b)
Figure 3: Identifying control dependencies with no branch in-
structions.
To handle this case, we recognize the control ﬂow statement is
an indirect jump and depends on the target address calculation. We
generate an equation for the target address calculation as seen in
Figure 3(b), and simplify it as described before. The result is given
in Figure 4, and shows that the target address depends on the re-
sult of the “Flag” operation. Thus, the indirect jump is acting as a
conditional control ﬂow statement.
target16 = index + (Flag(ebx4 cmp ecx3) & 0x1)
Figure 4: Result of target address simpliﬁcation from Figure 3.
Finally, we examine a case inspired by the conditional control
ﬂow implementation that is used in VMProtect. We begin with
the example in Figure 3, and add the use of indirection.
In the
code snippet of Figure 5(a), two index values are stored to adjacent
locations in memory. The same trick is then used to conditionally
load either the address of the ﬁrst index or the address of the second
index into the esi register. Finally, the value stored at the location in
esi is loaded into the eax register, and the indirect jump calculates
the address in the table to use.
For this example, let’s assume that it was index1 that was used
in the calculation of the target address, and that the value of ad-
dress was 5000. When we simplify our equation for target20, we
will substitute “ValueAt(esi18)” for “eax19.” By our assumption,
we know that esi18 holds the value 5000, so we substitute the value
at memory location 5000 which is index1 from instruction I10. Our
simpliﬁed expression for the target is then “target20 = index1 * 4
+ 0x10000.” From this result, it appears that this jump is not im-
plementing conditional control ﬂow. However, this is wrong. We
know from our analysis of the code that the result of the compare
instruction determines whether index1 or index2 is used to index
into the table. The problem is that the conditional element has been
hidden by a layer of indirection. When we calculate an expression
for the target address, we are only using direct dependencies.
278. . .
/*I10*/ mov [address], index1
/*I11*/ mov [address + 4], index2
/*I12*/ mov esi, address
cmp ebx, ecx
/*I13*/
pushf
/*I14*/
pop ebx
/*I15*/
/*I16*/
and ebx, 0x1
/*I17*/ mul ebx, 0x4
/*I18*/
add esi, ebx
/*I19*/ mov eax, [esi]
/*I20*/
jump [eax*4 + 0x10000]
(a)
. . .
ValueAt(address)10 = index1
ValueAt(address + 4)11 = index2
esi12 = address
eﬂags13 = Flag(ebx4 cmp ecx3)
esp14 = esp9 - 4
ValueAt(M1000)14 = eﬂags13
ebx15 = ValueAt(M1000)14
esp15 = esp14 + 4
ebx16 = ebx15 & 0x1
ebx17 = ebx16 * 0x4
esi18 = esi12 + ebx17
eax19 = ValueAt(esi18)
target20 = eax19 * 4 + 0x10000
(b)
the “Flag” operation, then we know that the target address is in-
directly conditionally dependent. Any memory access simpliﬁed
expression that does not show any conditional dependence can be
discarded because it is irrelevant. Returning to our example in Fig-
ure 5, we calculate all simpliﬁed expressions for memory access
and get the results shown in Figure 7. Here we see the conditional
dependence that we expect, and can mark the indirect jump of in-
struction I20 as implementing conditional control ﬂow.
LOC_500019 = address +((Flag(ebx4 cmp ecx3) & 0x1) *4)
target20 = index1 * 4 + 0x10000
Figure 7: Result of target address simpliﬁcation from Figure 5.
To handle multiple layers of indirection, we must account for
all dependencies. We use an algorithm that propagates information
forward as it scans over the equations in the trace. At each step,
all control ﬂow dependencies, direct and indirect, are collected as
described above and associated with that equation. Later, if that
equation is used in a target address calculation, the complete list of
dependencies is known and can be scanned for conditional depen-
dencies. The algorithm is presented in Figure 8.
Input: List of Equations : EqnList
Output: List of simpliﬁed expressions : SimpEqnList
Figure 5: Example of code using indirection to hide control de-
pendencies.
To resolve this issue, we must account for any number of lay-
ers of indirection. We could analyze the code, as we did here, and
recognizing that it was address 5000 that was used, and not 5004.
However, this requires understanding how the code works at each
step, and will quickly become more difﬁcult as code complexity
increases.
Instead, we add new equations to our set that deﬁne
where the calculation of memory addresses come from. We in-
troduce a new variable for each memory access, named with the
preﬁx “LOC” followed by the actual address that was accessed.
Then a new equation is added that sets the value of that new vari-
able according to how the calculation was done. Each variable is
labeled with the order number as before to guarantee that they are
unique. Figure 6 shows the addition of the memory location equa-
tion (marked *) for the memory access of instruction I19 in Figure
5. In practice, we would add similar equations for all memory ac-
cesses. These are omitted here for the sake of clarity.
Deps = ∅
SimpEqnList = ∅
for each equation in EqnList:
if IsConditional(equation)
then
Deps = Deps ∪ equation
endif
MemAccesses = GetMemoryAccessesForEqn(equation)
for each memAcc in MemAccesses:
Deps = Deps ∪ memAcc→deps
endfor
ExprList = SimpEqnList ∪ equation
for each term in equation:
replacement = FindReplacement(EqnList, term)
if replacement != ∅
then
ReplaceTerm(term, replacement)
Deps = Deps ∪ replacement→deps
endif
equation→deps = Deps
endfor
endfor
return SimpEqnList
. . .
ValueAt(5000)10 = index1
ValueAt(5004)11 = index2
esi12 = 5000
eﬂags13 = Flag(ebx4 cmp ecx3)
esp14 = esp9 - 4
ValueAt(M1000)14 = eﬂags13
ebx15 = ValueAt(M1000)14
esp15 = esp14 + 4
ebx16 = ebx15 & 0x1
ebx17 = ebx16 * 0x4
esi18 = esi12 + ebx17
(*) LOC_500019 = esi18
eax19 = ValueAt(LOC_500019)
target20 = eax19 * 4 + 0x10000
Figure 6: Equations augmented to handle indirection.
Now, for each memory access that is used to calculate the tar-
get address, we can start a new simpliﬁed expression for the ad-
dress calculation. If this calculation shows some dependency on
Figure 8: Pseudocode of simpliﬁed expression and conditional
dependency identiﬁcation
2.4 Relevant Call-Return Control Flow
Functions are important mechanisms for code structuring, and
are often the basic building blocks of a program during the design
phase. Identifying functions during reverse-engineering and deob-
fuscation, then, would be a useful step towards program compre-
hension. In the case of unobfuscated, compiler generated code, this
can often be a very straightforward task. For example, x86 compat-
ible compilers such as gcc will typically use a standard preamble
for functions that saves the base pointer, then points the base pointer
to the top of the stack. Knowing this information, one can search
through the code for these instructions and subsequently identify
the beginning of many functions in the code. However, this tech-
nique is only a convention, and in the case where the code is to be
purposefully obfuscated, it need not be followed. This section dis-
cusses the behavior of function calls and returns in various forms of
279obfuscation, their essential properties, and explains the technique
we propose for identifying them.


	 	  
      

	
  

     





Figure 9: examples of indirect jump
2.4.1 Behavior of Function Calls and Returns
In general, compiler generated, unobfuscated code uses the as-
sembly instructions call and ret for function calls and returns, re-
spectively. However, knowing how these instructions work allows
one to use them for other purposes. For example, the call instruc-
tion pushes the address of the next instruction onto the stack, then
jumps to its target address. The code in Figure 9(a) uses the call to
jump to code at another location, then discards the return address,
effectively implementing an indirect jump. A similar technique is
often used in position independent code (PIC-code) by using a call
instruction with a target address offset of 0. The effect is that the
address of the next instruction is pushed onto the stack. As another
example, the ret statement pops an address off the stack, then jumps
to it. The code in Figure 9(b) pushes a hard-coded value onto the
stack then executes a ret. The effect, as before, is equivalent to that
of an indirect jump.

	      
  

   