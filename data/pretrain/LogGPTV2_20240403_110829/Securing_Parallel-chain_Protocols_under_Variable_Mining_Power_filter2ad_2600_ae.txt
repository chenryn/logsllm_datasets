0.43% 0.07% 0.11% 0.12%
1000
that the pivot chain follows the same difficulty adjustment rule as
Bitcoin, which is proven practical by its real-world deployment. Min-
ing on non-pivot chains uses the same difficulty as the pivot chain,
so there is no additional bookkeeping.
For transaction confirmation, we use Prism as a concrete example
(note that no computation overhead exists in transaction confirma-
tion for OHIE and FruitChains). Under static difficulty, Prism selects
a leader for every level of the proposer tree. With M3, we partition
the proposer tree into real-valued difficulty intervals such that no
interval is partially occupied by any proposer block. We need to
select a leader for each of such intervals (section 3.3). To determine
the overhead, we need to answer: how many more intervals are there
compared to levels?
We simulate the mining process of Prism with 1000 voter chains,
epoch length Φ =2016 blocks, target mining rate f =0.1 block per
second, and found the number of intervals is only 0.12% more than
the number of levels. That is, our scheme incurs a confirmation over-
head of 0.12%. This is expected, because only forks that happen at
the beginning of an epoch will lead to extra intervals, and such a
fork rarely exists with Φ =2016 and f =0.1. Decreasing Φ may cause
the overhead to increase because there are more epochs and it is
more likely to fork at the beginning of an epoch. Table 2 plots the
confirmation overhead for different Φ; we see that even at Φ = 10,
the overhead is smaller than 1%.
8 DISCUSSION
We presented a general methodology by which any parallel chain
protocol can be converted from the fixed difficulty to the variable dif-
ficulty setting. We also proved the safety, liveness, and performance
of the proposed scheme using novel proof method that analyzes the
coupling between the pivot and non-pivot chains. There are several
open directions of research. 1) In our design methodology, we pro-
posed using a single chain as a pivot chain to set the difficulty target
for all blocks. However, if we can use the information (for example,
inter-block arrival times) from all the chains together to determine
the difficulty target, we can get much better statistical averaging.
This can lead to protocols which can adapt to much more aggressive
mining power variation than is possible with a single-chain protocol.
Such a protocol needs to be designed with care since it leads to strong
coupling across all the chains. In particular, every chain needs to
know the state of all other chains in order to check the correctness
of the difficulty target. Since other chains can have forking in the
meanwhile, it may lead to unintended complex interactions. 2) We
analyzed various protocols under the variable difficulty setting. One
new protocol, called Ledger-combiners [10] uses parallel-chains for
robustly combining multiple ledgers as well as for achieving low
latency. Analyzing that protocol in the variable difficulty setting is
an interesting direction for future work.
9 ACKNOWLEDGEMENTS
This research is supported in part by a gift from IOHK Inc., an Army
Research Office grant W911NF1810332 and by the National Science
Foundation under grants CCF 17-05007 and CCF 19-00636.
REFERENCES
[1] Blockchain charts - total hash rate. https://www.blockchain.com/charts/hash-rate.
[2] Christian Badertscher, Peter Gaži, Aggelos Kiayias, Alexander Russell, and Vassilis
Zikas. Ouroboros genesis: Composable proof-of-stake blockchains with dynamic
availability. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security, pages 913–930, 2018.
[3] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath.
Prism: Deconstructing the blockchain to approach physical limits. In Proceedings
of the 2019 ACM SIGSAC Conference on Computer and Communications Security,
pages 585–602, 2019.
[4] Lear Bahack. Theoretical bitcoin attacks with less than half of the computational
power (draft). arXiv preprint arXiv:1312.7013, 2013.
[5] Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A Kroll,
and Edward W Felten. Sok: Research perspectives and challenges for bitcoin and
cryptocurrencies. In 2015 IEEE symposium on security and privacy, pages 104–121.
IEEE, 2015.
[6] T-H. Hubert Chan, Naomi Ephraim, Antonio Marcedone, Andrew Morgan, Rafael
Pass, and Elaine Shi. Blockchain with varying number of players. Cryptology
ePrint Archive, Report 2020/677, 2020. https://eprint.iacr.org/2020/677.
[7] Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed
Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin Gün Sirer, et al. On scaling
decentralized blockchains. In International conference on financial cryptography
and data security, pages 106–125. Springer, 2016.
[8] Devdatt P Dubhashi and Alessandro Panconesi. Concentration of measure for the
analysis of randomized algorithms. Cambridge University Press, 2009.
[9] Ittay Eyal, Adem Efe Gencer, Emin Gün Sirer, and Robbert Van Renesse. Bitcoin-ng:
In 13th {USENIX} symposium on networked
A scalable blockchain protocol.
systems design and implementation ({NSDI} 16), pages 45–59, 2016.
[10] Matthias Fitzi, Peter Gaži, Aggelos Kiayias, and Alexander Russell. Ledger
combiners for fast settlement.
In Theory of Cryptography Conference, pages
322–352. Springer, 2020.
[11] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol:
Analysis and applications. In Annual International Conference on the Theory and
Applications of Cryptographic Techniques, pages 281–310. Springer, 2015.
[12] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol
with chains of variable difficulty. In Annual International Cryptology Conference,
pages 291–323. Springer, 2017.
[13] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. Full analysis of nakamoto
consensus in bounded-delay networks. Cryptology ePrint Archive, Report
2020/277, 2020. https://eprint.iacr.org/2020/277.
[14] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich.
Algorand: Scaling byzantine agreements for cryptocurrencies. In Proceedings
of the 26th Symposium on Operating Systems Principles, pages 51–68, 2017.
[15] Chenxing Li, Peilun Li, Dong Zhou, Wei Xu, Fan Long, and Andrew Yao. Scaling
nakamoto consensus to thousands of transactions per second. arXiv preprint
arXiv:1805.03870, 2018.
[16] Songze Li and David Tse. Taiji: Longest chain availability with bft fast confirmation.
arXiv preprint arXiv:2011.11097, 2020.
internet-level consensus. Stellar Development Foundation, 2015.
report, 2008.
[18] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Technical
The stellar consensus protocol: A federated model for
[17] David Mazieres.
[19] Kevin Alarcón Negy, Peter R Rizun, and Emin Gün Sirer.
Selfish mining
re-examined. In International Conference on Financial Cryptography and Data
Security, pages 61–78. Springer, 2020.
[20] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol
in asynchronous networks. In Annual International Conference on the Theory and
Applications of Cryptographic Techniques, pages 643–673. Springer, 2017.
[21] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. In Proceedings of the
ACM Symposium on Principles of Distributed Computing, pages 315–324, 2017.
[22] Rafael Pass and Elaine Shi. Hybrid consensus: Efficient consensus in the
permissionless model. In 31st International Symposium on Distributed Computing
(DISC 2017). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2017.
[23] David Schwartz, Noah Youngs, Arthur Britto, et al. The ripple protocol consensus
algorithm. Ripple Labs Inc White Paper, 2014.
[24] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in
bitcoin. In International Conference on Financial Cryptography and Data Security,
pages 507–527. Springer, 2015.
[25] Xuechao Wang, Viswa Virinchi Muppirala, Lei Yang, Sreeram Kannan, and
Pramod Viswanath. Securing parallel-chain protocols under variable mining
power. arXiv preprint arXiv:2105.02927, 2021.
[26] Lei Yang, Vivek Bagaria, Gerui Wang, Mohammad Alizadeh, David Tse, Giulia
Fanti, and Pramod Viswanath. Prism: Scaling bitcoin by 10,000 x. arXiv preprint
arXiv:1909.11261, 2019.
[27] Haifeng Yu, Ivica Nikolić, Ruomu Hou, and Prateek Saxena. Ohie: Blockchain
scaling made simple. In 2020 IEEE Symposium on Security and Privacy (SP), pages
90–105. IEEE, 2020.
Session 6A: Consensus and Attacks CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1712APPENDIX
A THE DIFFICULTY RAISING ATTACK
Bitcoin set its target recalculation using a “dampening filter”-like
adjustment (as defined in Definition 6.7). It turns out that this design
is surprisingly foresighted. If we make a relaxation of the adjustment
mechanism by removing the dampening filter, then it is subject to
an attack called difficulty raising attack firstly discovered in [4]. At
a high level, in this attack the adversary mines private blocks with
timestamps in rapid succession, and induce one block with arbitrar-
ily high difficulty in the private chain; via an anti-concentration
argument, a sudden adversarial advance that can break agreement
amongst honest parties cannot be ruled out. In this appendix, we
describe this attack in detail and explain why having a “dampening
filter” in the target recalculation function could resolve it.
A simple attack. As a prelim, we first look at a simple attack if
the protocol lets miners to choose their own difficulty and use the
heaviest chain rule. At a first glance, this rule appears kosher - the
heaviest chain rule seems to afford no advantage to any miner to
manipulate their difficulty. However, this lack of advantage only
holds in expectation, and the variance created by extremely diffi-
cult adversarial blocks can thwart a confirmation rule that confirms
deeply-embedded blocks, no matter how deep, with non-negligible
probability. We give a simple calculation here. For simplicity, we
using the difficulty defined in the genesis block as the difficulty unit
and the expected inter-block time (10 minutes in Bitcoin) as the time
unit. Let n be number of honest queries to the hash function per unit
time and t be the number of adversarial queries per unit time. Then
we know that to mine a block with unit difficulty, each query solves
the PoW puzzle with probability 1/n. We further assume that n and t
don’t change over time and the network delay among honest nodes is
zero. Note that these assumptions only make the adversary weaker.
The goal of the adversary is to double-spend a coin by mining a
heavier chain than the public honest chain from the genesis.
Supposehonestminersareadoptingtheinitialminingdifficultyas
defined in the genesis block, hence on average it take k units of time
to mine a honest chain with k blocks. To mine a heavier chain, the
adversary only needs to mine one block which has difficulty k (See
Figure 15 for illustration), within k unit of time. The adversarial can
maketk queriesink unitsoftime,andeachquerysucceedswithprob-
ability 1/nk. Hence the success probability of this attack would be
P(attack succeeds) =1−(1− 1
)tk ≈1−et/n,
nk
since n and t are large in PoW mining. Note that the success probabil-
ity is a constant independent of k, therefore any k-deep confirmation
rule will fail.
Difficulty raising attack. However, even if we adopts a epoch
based difficulty adjustment rule as in Bitcoin (but without the “damp-
ening filter”), there is still a difficulty raising attack. We using the
difficulty of the first epoch (defined in the genesis block) as the diffi-
culty unit and the expected inter-block time (10 minutes in Bitcoin)
as the time unit. Let Φ be the length of an epoch in number of blocks
(2016 in Bitcoin). And we define n and t the same as above.
Note that the adversary can put any timestamp in its private
blocks, so the difficulty of the second epoch in its private chain can be
arbitrary value as long as the adversary completes the first epoch. Let
B with difficulty X be the first block of the second epoch in the private
Figure 15: A simple attack if allowing miners to choose their
own difficulty. The adversary mines one block which is as
difficult as k honest blocks.
Figure 16: The difficulty raising attack. The adversary raises
the difficulty to extremely high in the second epoch by
faking timestamps.
chain (that is each query solves the PoW puzzle with probability
1/nX), then B has chain difficulty Φ+X. See Figure 16 for illustration.
To mine an honest chain with chain difficulty Φ+X, on average it
takes Φ+X time. On the other hand, it takes on average nΦ/t time
for the adversary to complete the first epoch in its private chain.
Therefore, to succeed in this attack, the adversary needs to mine the
block B within Φ+X −nΦ/t time, which happens with probability:
P(attack succeeds) =1−(1− 1
=1−(1− 1
nX
≈1−et/n,
nX
)(Φ+X−nΦ/t)t
)X t−(n−t)Φ
if X ≫ Φ≫1. Note that the success probability is independent of the
length of the public longest chain, hence any k-deep confirmation
rule will fail.
However, Bitcoin is saved by the dampening filter in the target
recalculation function. As in Definition 6.7, the difficulty can be in-
creasedbyafactorofatmostτ betweentwoconsecutiveepochs(τ =4
in Bitcoin). Then we shall analyze the difficulty raising attack under
the same assumptions made above. Since the epoch size Φ≫1, the
time for the adversary to complete one epoch or mine Φ blocks with
the same difficulty will satisfy the concentration bound of binomial
random variables. Hence if the adversary always rises the difficulty
i =0 τ i Φ time for the
by τ in each epoch, then it takes on average n
t
adversary to complete ℓ epochs in its private chain, and the public
honest chain will on average have difficulty n
i =0 τ i Φ during this
t
i =0 τ i Φ, the gap
of chain difficulties between the public honest chain and the private
ℓ−1
ℓ−1
time. Since the private chain has chain difficultyℓ−1
Session 6A: Consensus and Attacks CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1713chain will be
−1)ℓ−1
i =0
(n
t
τ i Φ =(n
t
−1)τ ℓ−1
τ −1 Φ.
Each block of the (ℓ + 1)-th epoch in the private chain will have
difficulty τ ℓ, hence the adversary still needs to mine approximately
n−t
t(τ−1) Φ blocks in order to catch up the honest chain. As Φ≫1, the
time for the adversary to catch up is still controlled by the concen-
tration bound, and the success probability of this attack will be at
most e−θ(Φ). By setting Φ large enough, the difficulty raising attack
can be ruled out.
While this specific attack could in principle be thwarted, to have
security guarantee we still need to consider all possible attacks in
the presence of a full-blown adversary. A full and beautiful analysis
of Bitcoin rule is provided in [13] and we shall give a proof sketch
in Appendix B.
B BITCOIN
BACKBONE PROPERTIES REVISITED
We will briefly revisit the analysis in [13] because the pivot chain is
identical to the Bitcoin chain.
We will additionally define a stale chain and accuracy related to
timestamps of the blocks.
Definition B.1 (from [13]). A block created at round u is accurate
is it has a timestamp v such that |u−v| ≤ ℓ+2∆. A chain is accurate if
all its blocks are accurate. A chain is stale if for some u ≥ ℓ+2∆ it does
not contain a honest block with timestamp v ≥u−ℓ−2∆.
Recall that we define SP
r as the set of pivot chains that belong to
or have the potential to be adopted by an honest party at round r in
Section 6.3. Now we define a series of useful predicates with respect
to SP
r .
Definition B.2 (from [13]). For a round r,
GoodRounds(r):= “All rounds u ≤ r are good.”
GoodChains(r):= “For all rounds u ≤ r, every chain in SP
NoStaleChains(r) := “For all rounds u ≤ r, there is no stale chain in
SP
u .”
Accurate(r) := “For all rounds u ≤ r, all chains in SP
u are accu-
rate.”
Duration(r):= “For all rounds u ≤ r and durationΛ of an epoch of any
chain in SP
u ,
f ≤ Λ≤ 2(1+δ)γ
2(1+δ)γ 2 m
u is good.”
2 m
f .”
1
The following lemma provides a lower bound on the progress of
the honest parties, which holds irrespective of any adversary.
Lemma B.3 (Chain growth for pivot chain, from [13]). Sup-
pose that at round u of an execution E, an honest party broadcasts a
pivot chain of difficulty d. Then, by roundv, every honest party receives
a chain of difficulty at least d +QP(S), where S ={r :u +∆≤ r ≤v−∆}.
In order to prove properties like common prefix and chain quality
for the pivot chain, we need all rounds in a typical execution to be
good.
LemmaB.4(Allroundsinatypicalexecutionaregood,Theo-
2(1+δ)Φ/f )-
rem 2 from [13]). Consider a typical execution in a(γ ,2γ
respecting environment. If the protocol is initiated such that the first
Figure 17: An induction argument to prove that all rounds in
a typical execution are good.
round it good, and all the conditions 3, 4 and 5 are satisfied, then all
rounds are good.
AP(J) =
i AP(Ji) <