lower increase in runtime overheads (FRAMER: 223%, ASan: 139%),
however, 75% of FRAMER’s overhead of metadata management and
retrieval is consumed for calculation, that can be largely resolved
with new ISA. The rest of overhead comes from bounds checking
using loaded metadata, that can be also implemented as ISA.
SGXBounds. SGXBounds spares 32 bits for a tag among 64
8.1.2
bits, while FRAMER tags only upper spare 16 bits. SGXBounds’s
retrieving an upper bound first, not the base like FRAMER, may save
some overheads if we perform overflow-only checking. However,
using a footer makes systems slightly more vulnerable to metadata
pollution without complete memory safety. For both over/under
underflow checking, we do not consider our derivation of the base,
not the upper bound, as a weakness. In addition, frame encoding
can be easily integrated to SGXBounds’ design.
8.1.3 MPX. In principle, FRAMER could utilize MPX extensions
for performance when used for spatial safety. We showed FRAMER
is more cache-friendly, but it could be made even faster if a single
instruction implemented the complete tag decode operation, split-
ting apart the tagged pointer into an untagged object pointer and
separate header pointer in another register. This would be a fairly
simple, register-to-register instruction, operating on general pur-
pose registers. Since this has not used the D-cache, an enhancement
FRAMER: A Tagged-Pointer Capability System with Memory Safety Applications
would be to compare the pointer against a bounds limit at hard-
coded offset loaded from the header, but the best design requires
further study.
8.2 Hardware Implementation of FRAMER
We believe FRAMER’s encoding is at its best when it is imple-
mented as instruction set extensions. As mentioned in 8.1.3, the
increase in the number of executed instructions for calculation, the
main contributor to slowdown of FRAMER, can be resolved with
new instructions. Tag-cleaning can be supported by hardware [27].
Moreover, generating a tag and deriving a metadata address can be
implemented as a single operation, respectively.
8.3 Additional Optimisations
8.3.1 Utilising More Spare Bits. Currently, we mandate 16-alignment
due to llvm.memset intrinsic function. On this alignment, we have
spare 4 bits at the end of offset for small-framed and another 4 bits
in the pointer. (We already have spare bits for large-framed ones.)
Using the bits, we can perform bounds checking only at pointer
arithmetic and mark out-of-bounds pointers, so that we can report
errors when they are dereferenced. This way, we expect to remove
duplicated runtime checks, since the pointer may be used for mem-
ory access multiple times. Above this, we can utilise them to encode
more information for better performance.
8.3.2 Compiler Optimisation. Redundant runtime checks can be
eliminated using dominator trees. SoftBound [32] reported that their
simple dominator-based redundant check elimination improved
performance by 13% and claimed more advanced elimination [6, 50]
can reduce more overheads.
The penalty of using tagged pointers is that unless individual
memory access is proven safe at static time, we may have to over-
instrument memory access to avoid segmentations fault. Some ap-
proaches can save expensive runtime checks to reduce performance
degradation, bearing false negatives, but it is difficult in approaches
using tagged pointer. We did not run dedicated pointer-analysis
for this version but it can remove over-instrumentation. Loop opti-
misation did not show big impact on reducing overheads, even for
some SPEC benchmarks whose number of hoisted run-time checks
reached hundreds at static time. Our naive optimisation skipping
untagging improved performance more than state-of-the-art loop
hoist pass. Static points-to analysis [43, 44], as long as it does not
assume the absence of memory errors, potentially enables many
tags and bounds checks to be removed at compile time.
9 CONCLUSION
We presented FRAMER, a per-object capability system utilising the
currently unused significant bits of pointers to store a tag. A key
insight is that this tag can be bifurcated using a flag bit so that the
overwhelmingly common case of small-framed objects can be dealt
with efficiently in terms of both time and space. This ultimately
benefits the performance of exceptional large-framed objects too,
because the design can special-case them as well.
We evaluated FRAMER with a case study on spatial memory
safety in C programs. However, we believe its capability design
could benefit the performance of other programming language
security mechanisms as well. Compared to existing approaches,
our frame-based offset encoding is more flexibile both in metadata
association and memory management, while still offering a fairly
simple calculation to map from arbitrary pointers to metadata loca-
tions. In addition, its intrinsic memory and cache-efficiency make
it potentially attractive for direct hardware support.
ACKNOWLEDGMENTS
We thank the anonymous reviewers, as well as Elias Athanasopou-
los, Stephen Kell, Guy Lemieux, Min Hong Yun, Jonathan Woodruff,
and Matt Staats for their valuable comments on the draft, and Chris-
tos Rikoudis for his helpful tips for troubleshooting during ex-
periments. This research was supported by the Next-Generation
Information Computing Development Program through the Na-
tional Research Foundation of Korea (NRF) funded by the Ministry
of Science and ICT (No. 2017M3C4A7083676).
REFERENCES
[1] Mart´ın Abadi, Mihai Budiu, ´Ulfar Erlingsson, and Jay Ligatti. 2005. Control-Flow
Integrity. In Proc. of ACM CCS. 340–353.
[2] Periklis Akritidis. 2010. Cling: A Memory Allocator to Mitigate Dangling Pointers.
In Proceedings of the 19th USENIX Conference on Security (USENIX Security’10).
USENIX Association, Berkeley, CA, USA, 12–12. http://dl.acm.org/citation.cfm?
id=1929820.1929836
[3] Periklis Akritidis, Manuel Costa, Miguel Castro, and Steven Hand. 2009. Baggy
Bounds Checking: An Efficient and Backwards-compatible Defense Against
Out-of-bounds Errors. In Proceedings of the 18th Conference on USENIX Security
Symposium (SSYM’09). USENIX Association, Berkeley, CA, USA, 51–66. http:
//dl.acm.org/citation.cfm?id=1855768.1855772
[4] Todd Austin. Sept. 1995. Pointer-Intensive Benchmark Suite. http://pages.cs.
wisc.edu/∼austin/ptr-dist.html
[5] Todd M. Austin, Scott E. Breach, and Gurindar S. Sohi. 1994. Efficient Detection
of All Pointer and Array Access Errors. In Proceedings of the ACM SIGPLAN
1994 Conference on Programming Language Design and Implementation (PLDI ’94).
ACM, New York, NY, USA, 290–301. https://doi.org/10.1145/178243.178446
[6] Rastislav Bod´ık, Rajiv Gupta, and Vivek Sarkar. 2000. ABCD: Eliminating Array
Bounds Checks on Demand. In Proceedings of the ACM SIGPLAN 2000 Conference
on Programming Language Design and Implementation (PLDI ’00). ACM, New
York, NY, USA, 321–333. https://doi.org/10.1145/349299.349342
[7] Martin C. Carlisle and Anne Rogers. 1995. Software Caching and Computation
Migration in Olden. In Proceedings of the Fifth ACM SIGPLAN Symposium on
Principles and Practice of Parallel Programming (PPOPP ’95). ACM, New York, NY,
USA, 29–38. https://doi.org/10.1145/209936.209941
[8] Winnie Cheng, Qin Zhao, Bei Yu, and Scott Hiroshige. 2006. TaintTrace: Efficient
Flow Tracing with Dynamic Binary Rewriting. In Proceedings of the 11th IEEE
Symposium on Computers and Communications (ISCC ’06). IEEE Computer Society,
Washington, DC, USA, 749–754. https://doi.org/10.1109/ISCC.2006.158
[9] Jack B. Dennis and Earl C. Van Horn. 1965. Programming Semantics for Multi-
programmed Computations.
[10] Joe Devietti, Colin Blundell, Milo M. K. Martin, and Steve Zdancewic. 2008.
Hardbound: Architectural Support for Spatial Safety of the C Programming
Language. SIGPLAN Not. 43, 3 (March 2008), 103–114. https://doi.org/10.1145/
1353536.1346295
[11] D. Dhurjati and V. Adve. 2006. Efficiently Detecting All Dangling Pointer Uses
in Production Servers. In International Conference on Dependable Systems and
Networks (DSN’06). 269–280. https://doi.org/10.1109/DSN.2006.31
[12] Dinakar Dhurjati, Sumant Kowshik, and Vikram Adve. 2006. SAFECode: Enforc-
ing Alias Analysis for Weakly Typed Languages. In Proceedings of the 27th ACM
SIGPLAN Conference on Programming Language Design and Implementation (PLDI
’06). ACM, New York, NY, USA, 144–157. https://doi.org/10.1145/1133981.1133999
[13] Gregory J. Duck and Roland H. C. Yap. 2018. EffectiveSan: Type and Memory
Error Detection Using Dynamically Typed C/C++. In Proceedings of the 39th
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI 2018). ACM, New York, NY, USA, 181–195. https://doi.org/10.1145/3192366.
3192388
[14] Robert Gawlik and Thorsten Holz. 2014. Towards Automated Integrity Protection
of C++ Virtual Function Tables in Binary Programs. In Proc. of ACSAC. 396–405.
[15] Enes G¨oktas¸, Elias Athanasopoulos, Herbert Bos, and Georgios Portokalidis.
2014. Out Of Control: Overcoming Control-Flow Integrity. In Proc. of IEEE S&P.
575–589.
[16] Istv´an Haller, Yuseok Jeon, Hui Peng, Mathias Payer, Cristiano Giuffrida, Her-
bert Bos, and Erik van der Kouwe. 2016. TypeSan: Practical Type Confusion
Detection. In Proceedings of the 2016 ACM SIGSAC Conference on Computer
and Communications Security, Vienna, Austria, October 24-28, 2016. 517–528.
https://doi.org/10.1145/2976749.2978405
[17] Istv´an Haller, Erik van der Kouwe, Cristiano Giuffrida, and Herbert Bos. 2016.
METAlloc: efficient and comprehensive metadata management for software se-
curity hardening. In Proceedings of the 9th European Workshop on System Security,
EUROSEC 2016, London, UK, April 18-21, 2016. 5:1–5:6. https://doi.org/10.1145/
2905760.2905766
[18] John L. Henning. 2006. SPEC CPU2006 Benchmark Descriptions. SIGARCH
Comput. Archit. News 34, 4 (Sept. 2006), 1–17. https://doi.org/10.1145/1186736.
1186737
Introduction to Intel® memory protection exten-
sions. http://software.intel.com/en-us/articles/introduction-to-intel-memory-
protection-extensions.
[19] Intel Corporation. 2013.
[20] Dongseok Jang, Zachary Tatlock, and Sorin Lerner. 2014. SAFEDISPATCH:
Securing C++ Virtual Calls from Memory Corruption Attacks. In Proc. of NDSS.
[21] Yuseok Jeon, Priyam Biswas, Scott A. Carr, Byoungyoung Lee, and Mathias
Payer. 2017. HexType: Efficient Detection of Type Confusion Errors for C++. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security, CCS 2017, Dallas, TX, USA, October 30 - November 03, 2017. 2373–2387.
https://doi.org/10.1145/3133956.3134062
[22] Richard Jones, , Richard W M Jones, and Paul H J Kelly. 1997. Backwards-
, pages
compatible bounds checking for arrays and pointers in C programs.
13–26 pages.
[23] Taddeus Kroes, Koen Koning, Erik van der Kouwe, Herbert Bos, and Cristiano
Giuffrida. 2018. Delta Pointers: Buffer Overflow Checks Without the Checks. In
Proceedings of the Thirteenth EuroSys Conference (EuroSys ’18). ACM, New York,
NY, USA, Article 22, 14 pages. https://doi.org/10.1145/3190508.3190553
[24] Dmitrii Kuvaiskii, Oleksii Oleksenko, Sergei Arnautov, Bohdan Trach, Pramod
Bhatotia, Pascal Felber, and Christof Fetzer. 2017. SGXBOUNDS: Memory Safety
for Shielded Execution. In Proceedings of the Twelfth European Conference on
Computer Systems (EuroSys ’17). ACM, New York, NY, USA, 205–221. https:
//doi.org/10.1145/3064176.3064192
[25] Albert Kwon, Udit Dhawan, Jonathan M. Smith, Thomas F. Knight, Gingko
Bioworks, and Andre Dehon. 2013. Low-fat pointers: compact encoding and
efficient gate-level implementation of fat pointers for spatial safety and capability-
based security. CCS.
[26] Arm Limited. 2018. ARM A64 Instruction Set Architecture. https://static.docs.
arm.com/ddi0596/a/DDI 0596 ARM a64 instruction set architecture.pdf.
[27] Arm Limited. 2018. Armv8.5-A.
https://community.arm.com/developer/ip-
products/processors/b/processors-ip-blog/posts/arm-a-profile-architecture-
2018-developments-armv85a.
[28] llvm team. 2003. LLVM Constant Expression. https://llvm.org/docs/LangRef.
[29] llvm team. 2003. Standard C Library Intrinsics. https://llvm.org/docs/LangRef.
html#constant-expressions.
html#standard-c-library-intrinsics.
[30] llvm team. 2003. The LLVM gold plugin. https://llvm.org/docs/GoldPlugin.html.
[31] Santosh Nagarakatte, Milo M. K. Martin, and Steve Zdancewic. 2015. Ev-
erything You Want to Know About Pointer-Based Checking. In 1st Summit
on Advances in Programming Languages (SNAPL 2015) (Leibniz International
Proceedings in Informatics (LIPIcs)), Thomas Ball, Rastislav Bodik, Shriram Kr-
ishnamurthi, Benjamin S. Lerner, and Greg Morrisett (Eds.), Vol. 32. Schloss
Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany, 190–208. https:
//doi.org/10.4230/LIPIcs.SNAPL.2015.190
[32] Santosh Nagarakatte, Jianzhou Zhao, Milo M.K. Martin, and Steve Zdancewic.
2009. SoftBound: Highly Compatible and Complete Spatial Memory Safety
for C. In Proceedings of the 30th ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI ’09). ACM, New York, NY, USA,
245–258. https://doi.org/10.1145/1542476.1542504
[33] Santosh Nagarakatte, Jianzhou Zhao, Milo M. K. Martin, and Steve Zdancewic.
2010. CETS: Compiler Enforced Temporal Safety for C. SIGPLAN Not. 45, 8,
31–40. https://doi.org/10.1145/1837855.1806657
[34] George C. Necula, Jeremy Condit, Matthew Harren, Scott McPeak, and Westley
Weimer. 2005. CCured: Type-safe Retrofitting of Legacy Software. ACM Trans.
Program. Lang. Syst. 27, 3 (May 2005), 477–526. https://doi.org/10.1145/1065887.
1065892
[35] Ben Niu and Gang Tan. 2014. Modular Control-flow Integrity. In Proceedings
of the 35th ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI ’14). ACM, New York, NY, USA, 577–587. https://doi.org/
10.1145/2594291.2594295
[36] Oleksii Oleksenko, Dmitrii Kuvaiskii, Pramod Bhatotia, Pascal Felber, and Christof
Fetzer. 2018.
Intel MPX Explained: A Cross-layer Analysis of the Intel MPX
System Stack. Proc. ACM Meas. Anal. Comput. Syst. 2, 2, Article 28 (June 2018),
30 pages. https://doi.org/10.1145/3224423
[37] Aravind Prakash, Xunchao Hu, and Heng Yin. 2015. vfGuard: Strict Protection
for Virtual Function Calls in COTS C++ Binaries. In Proc. of NDSS.
[38] F. Qin, C. Wang, Z. Li, H. Kim, Y. Zhou, and Y. Wu. 2006. LIFT: A Low-Overhead
Practical Information Flow Tracking System for Detecting Security Attacks.
Myoung Jin Nam, et al.
In 2006 39th Annual IEEE/ACM International Symposium on Microarchitecture
(MICRO’06). 135–148. https://doi.org/10.1109/MICRO.2006.29
[39] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry
Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In Proceed-
ings of the 2012 USENIX Conference on Annual Technical Conference (USENIX
ATC’12). USENIX Association, Berkeley, CA, USA, 28–28. http://dl.acm.org/
citation.cfm?id=2342821.2342849
[40] Matthew S. Simpson and Rajeev K. Barua. 2013. MemSafe: Ensuring the Spatial
and Temporal Memory Safety of C&#x2009;at Runtime. Softw. Pract. Exper. 43, 1
(Jan. 2013), 93–128. https://doi.org/10.1002/spe.2105
[41] Stacy Simpson. 2014. SAFECode Whitepaper: Fundamental Practices for Secure
Software Development 2nd Edition.. In ISSE, Helmut Reimer, Norbert Pohlmann,
and Wolfgang Schneider (Eds.). Springer, 1–32. http://dblp.uni-trier.de/db/conf/
isse/isse2014.html#Simpson14
[42] Kevin Z. Snow, Lucas Davi, Alexandra Dmitrienko, Christopher Liebchen, Fabian
Monrose, and Ahmad-Reza Sadeghi. 2013. Just-In-Time Code Reuse: On the Ef-
fectiveness of Fine-Grained Address Space Layout Randomization. In Proceedings
of the 34th IEEE Symposium on Security and Privacy.
[43] Bjarne Steensgaard. 1996. Points-to Analysis in Almost Linear Time. In Pro-
ceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Pro-
gramming Languages (POPL ’96). ACM, New York, NY, USA, 32–41. https:
//doi.org/10.1145/237721.237727
[44] Tian Tan, Yue Li, and Jingling Xue. 2017. Efficient and Precise Points-to Analysis:
Modeling the Heap by Merging Equivalent Automata. In Proceedings of the 38th
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI 2017). ACM, New York, NY, USA, 278–291. https://doi.org/10.1145/3062341.
3062360
[45] Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, ´Ulfar
Erlingsson, Luis Lozano, and Geoff Pike. 2014. Enforcing Forward-Edge Control-
Flow Integrity in GCC & LLVM. In Proc. of USENIX SEC. 941–955.
[46] Victor van der Veen, Dennis Andriesse, Enes G¨oktas¸, Ben Gras, Lionel Sambuc,
Asia Slowinska, Herbert Bos, and Cristiano Giuffrida. 2015. Practical Context-
Sensitive CFI. In Proc. of ACM CCS. 927–940.
[47] Victor van der Veen, Enes G¨oktas¸, Moritz Contag, Andre Pawloski, Xi Chen,
Sanjay Rawat, Herbert Bos, Thorsten Holz, Elias Athanasopoulos, and Cristiano
Giuffrida. 2016. A Tough call: Mitigating Advanced Code-Reuse Attacks At
The Binary Level. In Proc. of IEEE S&P. 934–953.
[48] R. N. M. Watson, J. Woodruff, P. G. Neumann, S. W. Moore, J. Anderson, D.
Chisnall, N. Dave, B. Davis, K. Gudka, B. Laurie, S. J. Murdoch, R. Norton, M. Roe,
S. Son, and M. Vadera. 2015. CHERI: A Hybrid Capability-System Architecture
for Scalable Software Compartmentalization. In 2015 IEEE Symposium on Security
and Privacy. 20–37. https://doi.org/10.1109/SP.2015.9
[49] Jonathan Woodruff, Robert N.M. Watson, David Chisnall, Simon W. Moore,
Jonathan Anderson, Brooks Davis, Ben Laurie, Peter G. Neumann, Robert Nor-
ton, and Michael Roe. 2014. The CHERI capability model: revisiting RISC in
an age of risk. In ISCA ’14: Proceeding of the 41st annual international sym-
posium on Computer architecture. IEEE Press, Piscataway, NJ, USA, 457–468.
https://doi.org/10.1145/2678373.2665740
[50] Thomas W¨urthinger, Christian Wimmer, and Hanspeter M¨ossenb¨ock. 2007. Array
Bounds Check Elimination for the Java HotSpotTM Client Compiler. In Proceedings
of the 5th International Symposium on Principles and Practice of Programming in
Java (PPPJ ’07). ACM, New York, NY, USA, 125–133. https://doi.org/10.1145/
1294325.1294343
[51] Wei Xu, Daniel C. DuVarney, and R. Sekar. 2004. An Efficient and Backwards-
compatible Transformation to Ensure Memory Safety of C Programs. In Proceed-
ings of the 12th ACM SIGSOFT Twelfth International Symposium on Foundations of
Software Engineering (SIGSOFT ’04/FSE-12). ACM, New York, NY, USA, 117–126.
https://doi.org/10.1145/1029894.1029913
[52] Yves Younan, Pieter Philippaerts, Lorenzo Cavallaro, R. Sekar, Frank Piessens, and
Wouter Joosen. 2010. PAriCheck: An Efficient Pointer Arithmetic Checker for C
Programs. In Proceedings of the 5th ACM Symposium on Information, Computer
and Communications Security (ASIACCS ’10). ACM, New York, NY, USA, 145–156.
https://doi.org/10.1145/1755688.1755707
[53] Chao Zhang, Scott A. Carr, Tongxin Li, Yu Ding, Chengyu Song, Mathias Payer,
and Dawn Song. 2016. VTrust: Regaining Trust on Virtual Calls. In Proc. of NDSS.
[54] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, L. Szekeres, S. McCamant, D.
Song, and Wei Zou. 2013. Practical Control Flow Integrity & Randomization for
Binary Executables. In Proc. of IEEE S&P. 559–573.
Proc. of USENIX SEC. 337–352.
[55] Mingwei Zhang and R Sekar. 2013. Control Flow Integrity for COTS Binaries. In
FRAMER: A Tagged-Pointer Capability System with Memory Safety Applications
A PROOFS
A.1 Proof 1
Given an object 𝑜 and its wrapper frame 𝑓, let’s assume there exists a
smaller frame 𝑥 that has 𝑜 inside. Since 𝑜 resides in both 𝑓 and 𝑥, we
can conclude that 𝑥 is a subframe of 𝑓. According to the assumption,
the base address of 𝑜 (𝑏𝑎𝑠𝑒𝑜) is within the range of 𝑥, hence, we get
𝑏𝑎𝑠𝑒𝑥 ≤ 𝑏𝑎𝑠𝑒𝑜. Here, 𝑓 is 𝑜’s wrapper frame, so 𝑏𝑎𝑠𝑒𝑜 is placed in
𝑓’s lower subframe. 𝑥 is a subframe of 𝑓, hence 𝑥 must be 𝑓’s lower
subframe. This is resolved to contradiction between the assumption
(𝑥 has 𝑜 inside) and the definition of wrapper function (𝑜’s upper
bound in the upper subframe). Hence, we can conclude that there is
no smaller frame than 𝑜’s wrapper frame; this is actually the unique
wrapper frame, and it can be used as a reference point.
A.2 Proof 2
We prove that for each 𝑁, there exists at most one 𝑁-object mapped
to each entry of a division array, and show 𝑁 identifies an object
mapped to the same division array. To prove this, we assume there
exist two distinctive objects, 𝑥 and 𝑦; both are 𝑁-objects (𝑁 ≥ 16)
mapped to the same division array. Since 𝑥 and 𝑦 are 𝑁-objects,
their wrapper frame (𝑓𝑥 and 𝑓𝑦) is 2𝑁-sized by definition. The
division is the only one that 𝑓𝑥 and 𝑓𝑦 are mapped to as shown
previously, so 𝑓𝑥 and 𝑓𝑦 have the same base address as the division.
In addition, both frames have the same size, so they are identical.
Both base addresses of 𝑥 and 𝑦 (𝑏𝑥, 𝑏𝑦) must be in the lower (𝑁−1)-
subframe of 𝑓𝑥 (or 𝑓𝑦), and end addresses must be in the other
sub-frame. From this, 𝑏𝑥 and 𝑏𝑦 must be smaller than 𝑒𝑥 and 𝑒𝑦.
However, the objects are distinct, so 𝑏𝑥 < 𝑒𝑥 < 𝑏𝑦 < 𝑒𝑦 or
vice versa must hold. The assumption leads to a contraction. We
conclude that for each 𝑁, there is a unique 𝑁-object mapped to
one division array.