### 8.1.2 Comparison with SGXBounds
FRAMER incurs a lower increase in runtime overhead (223%) compared to ASan (139%). However, 75% of FRAMER's overhead is attributed to metadata management and retrieval, which can be significantly reduced with the introduction of new ISA. The remaining overhead is due to bounds checking using loaded metadata, which can also be optimized through ISA enhancements.

SGXBounds reserves 32 bits for a tag within a 64-bit pointer, whereas FRAMER uses only the upper 16 bits. SGXBounds retrieves the upper bound first, unlike FRAMER, which may save some overhead if we perform overflow-only checking. However, using a footer in SGXBounds makes the system slightly more vulnerable to metadata pollution without complete memory safety. For both over/underflow checking, we do not consider the derivation of the base, rather than the upper bound, as a weakness. Additionally, frame encoding can be easily integrated into SGXBounds' design.

### 8.1.3 Comparison with MPX
In principle, FRAMER could leverage MPX extensions for enhanced performance when used for spatial safety. We have shown that FRAMER is more cache-friendly, but it could be even faster if a single instruction implemented the complete tag decode operation, splitting the tagged pointer into an untagged object pointer and a separate header pointer in another register. This would be a straightforward, register-to-register instruction, operating on general-purpose registers. Since this approach does not use the D-cache, an enhancement would be to compare the pointer against a bounds limit at a hardcoded offset loaded from the header. However, the optimal design requires further study.

### 8.2 Hardware Implementation of FRAMER
We believe that FRAMER's encoding is most effective when implemented as instruction set extensions. As mentioned in Section 8.1.3, the increase in the number of executed instructions for calculation, which is the main contributor to the slowdown of FRAMER, can be resolved with new instructions. Tag-cleaning can be supported by hardware [27]. Moreover, generating a tag and deriving a metadata address can be implemented as a single operation, respectively.

### 8.3 Additional Optimizations

#### 8.3.1 Utilizing More Spare Bits
Currently, we mandate 16-byte alignment due to the `llvm.memset` intrinsic function. On this alignment, we have 4 spare bits at the end of the offset for small-framed objects and another 4 bits in the pointer. (We already have spare bits for large-framed objects.) Using these bits, we can perform bounds checking only at pointer arithmetic and mark out-of-bounds pointers, so that errors can be reported when they are dereferenced. This way, we expect to remove duplicated runtime checks, as the pointer may be used for memory access multiple times. Additionally, these bits can be utilized to encode more information for better performance.

#### 8.3.2 Compiler Optimization
Redundant runtime checks can be eliminated using dominator trees. SoftBound [32] reported that their simple dominator-based redundant check elimination improved performance by 13% and claimed that more advanced elimination [6, 50] can reduce more overheads. The penalty of using tagged pointers is that unless individual memory access is proven safe at static time, we may have to over-instrument memory access to avoid segmentation faults. Some approaches can save expensive runtime checks to reduce performance degradation, bearing false negatives, but it is difficult in approaches using tagged pointers. We did not run dedicated pointer analysis for this version, but it can remove over-instrumentation. Loop optimization did not show a significant impact on reducing overheads, even for some SPEC benchmarks whose number of hoisted run-time checks reached hundreds at static time. Our naive optimization skipping untagging improved performance more than state-of-the-art loop hoist passes. Static points-to analysis [43, 44], as long as it does not assume the absence of memory errors, potentially enables many tags and bounds checks to be removed at compile time.

### 9 Conclusion
We presented FRAMER, a per-object capability system that utilizes currently unused significant bits of pointers to store a tag. A key insight is that this tag can be bifurcated using a flag bit, allowing the common case of small-framed objects to be handled efficiently in terms of both time and space. This ultimately benefits the performance of exceptional large-framed objects as well, because the design can special-case them. We evaluated FRAMER with a case study on spatial memory safety in C programs. However, we believe its capability design could benefit the performance of other programming language security mechanisms as well. Compared to existing approaches, our frame-based offset encoding is more flexible in metadata association and memory management, while still offering a fairly simple calculation to map from arbitrary pointers to metadata locations. In addition, its intrinsic memory and cache efficiency make it potentially attractive for direct hardware support.

### Acknowledgments
We thank the anonymous reviewers, as well as Elias Athanasopoulos, Stephen Kell, Guy Lemieux, Min Hong Yun, Jonathan Woodruff, and Matt Staats for their valuable comments on the draft, and Christos Rikoudis for his helpful tips for troubleshooting during experiments. This research was supported by the Next-Generation Information Computing Development Program through the National Research Foundation of Korea (NRF) funded by the Ministry of Science and ICT (No. 2017M3C4A7083676).

### References
[References section remains unchanged]

### A Proofs

#### A.1 Proof 1
Given an object \( o \) and its wrapper frame \( f \), letâ€™s assume there exists a smaller frame \( x \) that contains \( o \). Since \( o \) resides in both \( f \) and \( x \), we can conclude that \( x \) is a subframe of \( f \). According to the assumption, the base address of \( o \) (\( base_o \)) is within the range of \( x \), hence, we get \( base_x \leq base_o \). Here, \( f \) is \( o \)'s wrapper frame, so \( base_o \) is placed in \( f \)'s lower subframe. \( x \) is a subframe of \( f \), hence \( x \) must be \( f \)'s lower subframe. This leads to a contradiction between the assumption (\( x \) has \( o \) inside) and the definition of the wrapper function (\( o \)'s upper bound in the upper subframe). Hence, we can conclude that there is no smaller frame than \( o \)'s wrapper frame; this is actually the unique wrapper frame, and it can be used as a reference point.

#### A.2 Proof 2
We prove that for each \( N \), there exists at most one \( N \)-object mapped to each entry of a division array, and show that \( N \) identifies an object mapped to the same division array. To prove this, we assume there exist two distinct objects, \( x \) and \( y \); both are \( N \)-objects (\( N \geq 16 \)) mapped to the same division array. Since \( x \) and \( y \) are \( N \)-objects, their wrapper frames (\( f_x \) and \( f_y \)) are 2\( N \)-sized by definition. The division is the only one that \( f_x \) and \( f_y \) are mapped to, so \( f_x \) and \( f_y \) have the same base address as the division. Additionally, both frames have the same size, so they are identical. Both base addresses of \( x \) and \( y \) (\( b_x, b_y \)) must be in the lower (\( N-1 \))-subframe of \( f_x \) (or \( f_y \)), and end addresses must be in the other sub-frame. From this, \( b_x \) and \( b_y \) must be smaller than \( e_x \) and \( e_y \). However, the objects are distinct, so \( b_x < e_x < b_y < e_y \) or vice versa must hold. The assumption leads to a contradiction. We conclude that for each \( N \), there is a unique \( N \)-object mapped to one division array.