title:Better Than Advertised: Improved Collision-Resistance Guarantees for
MD-Based Hash Functions
author:Mihir Bellare and
Joseph Jaeger and
Julia Len
Better Than Advertised: Improved Collision-Resistance
Guarantees for MD-Based Hash Functions
University of California San Diego
University of California San Diego
University of California San Diego
Joseph Jaeger†
La Jolla, California
PI:EMAIL
Mihir Bellare∗
La Jolla, California
PI:EMAIL
Julia Len
La Jolla, California
PI:EMAIL
ABSTRACT
The MD transform that underlies the MD and SHA families iterates
a compression function h to get a hash function H. The question we
ask is, what property X of h guarantees collision resistance (CR) of
H? The classical answer is that X itself be CR. We show that weaker
conditions X, in particular forms of what we call constrained-CR,
suffice. This reduces demands on compression functions, to the
benefit of security, and also, forensically, explains why collision-
finding attacks on compression functions have not, historically,
lead to immediate breaks of the corresponding hash functions. We
obtain our results via a definitional framework called RS security,
and a parameterized treatment of MD, that also serve to unify prior
work and variants of the transform.
1 INTRODUCTION
The so-called MD transform [15, 24] iterates a compression function
h to get a hash function H. The question we ask is, what property X
of h guarantees collision resistance (CR) of H? The classical answer
is that X itself be CR [15, 24]. We show that weaker conditions X,
in particular forms of what we call constrained-CR, suffice.
The benefit is that if we ask less of compression functions (as we
can now do), they are less likely to disappoint. Put another way, our
result lowers the bar for the compression function designer, and
raises it for the compression function attacker. It also explains an
historical cryptanalytic phenomenon, namely that collision-finding
attacks on compression functions [16, 30] have not immediately led
to breaks of the corresponding hash functions. (Our explanation
is that the attacks on the compression functions did not break
constrained collision resistance.) In this (second) light, our work
formalizes existing cryptanalytic intuition.
We obtain our results via a broader treatment that also serves
to unify prior work and different variants of the transform, and to
formalize folklore. It involves (1) a definitional framework called
RS security that allows us to formulate both classical and new
∗Supported in part by NSF grants CNS-1526801 and CNS-1717640, ERC Project ERCC
FP7/615074 and a gift from Microsoft corporation.
†Supported in part by grants of first author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’17, October 30-November 3, 2017, Dallas, TX, USA
© 2017 Association for Computing Machinery.
ACM ISBN 978-1-4503-4946-8/17/10...$15.00
https://doi.org/10.1145/3133956.3134087
security goals in a unified way, and (2) a modular treatment of MD
that parameterizes it via a splitting function and a compression
function.
The MD transform was used in the MD series of hash functions
(MD4 [27] and MD5 [26]) and now underlies the most widely used
hash functions in practice, namely the SHA series (SHA-1, SHA-256,
SHA-512) [25]. An improved understanding of its security, as we
provide, is thus of both historical and current interest.
MD framework. We formulate MD in a general, parameterized
way, as a transform taking (1) a compression function h : {0, 1}k ×
({0, 1}µ × {0, 1}σ) → {0, 1}σ , (2) a splitting function Split : D →
({0, 1}µ)∗ and (3) a set S ⊆ {0, 1}σ of starting points (also called
initial vectors) to return a hash function H = MD[h, Split, S] : D
→ {0, 1}σ . The compression function takes a key k and an input
x = (m, c) consisting of a message block m and chaining variable
c, and returns output c′ = hk((m, c)). The domain D is intended
to be large, usually the set of all strings of length up to some big
maximum length. The key (k, s) for H consists of a random key k
for h and a random starting point s from S. The splitting function
breaks the input M to H(k,s) into a sequence m = m[1] . . . m[n]
of µ-bit blocks. To compute H(k,s)(M), set c[1] ← s, iterate the
compression function via
For i = 1, . . . , n do c[i + 1] ← hk((m[i], c[i])),
and return c[n + 1] as the value of H(k,s)(M).
Characterizing CR preservation. We start by revisiting the clas-
sical question of showing that H is CR assuming h is CR (X=CR).
Several works have noted that suffix-freeness of Split is sufficient
for this purpose [1, 5, 17, 18]. (Some of these attribute the result
to [15, 24], but neither paper appears to actually contain such a
claim.) For completeness, we give, in our setting, a formal claim
(suffix-freeness of Split plus CR of h implies CR of H, Theorem 5.3)
together with the (easy) proof. We then complement this with a
novel result: we show that the sufficient condition of suffix-freeness
on Split is also necessary. We do this by showing that given any
Split that is not suffix-free, we can construct a compression func-
tion h and set S such that (1) h is CR but (2) H = MD[h, Split, S] is
not CR. This fully characterizes MD for the (classical) case where
the assumption X made on h is CR.
Unifying variants. Papers, textbooks and standards present vari-
ants of the MD transform that differ in details. We can capture
them as special cases, corresponding to different choices of split-
ting function Split and set S of starting points. Together with our
above-mentioned characterization, this unifies prior work.
To elaborate, a basic version of MD, from Merkle [23], MOV [22]
and KL [20], corresponds to the splitting function that pads the
Session D4:  Crypto PrimitivesCCS’17, October 30-November 3, 2017, Dallas, TX, USA891message M to a multiple of the block length µ and appends a block
encoding the length of M. Stinson’s [31] version corresponds to
the last block encoding the amount of padding rather than the
message length. Damgård’s version [15] starts each block of the
padded message with a 1 bit except the first, which it starts with
a 0 bit, and also appends a block encoding the amount of padding.
The SHA functions [25] use yet another variant where the (padded)
message may spill into the last block so that the latter does not
encode just the message length (cf. Fig. 3). In papers and textbooks
the starting point s is usually 0σ [15, 20, 22, 23, 31], but, in the
SHA series, s differs across hash functions. (For example, for SHA-
256 it is the first 32 bits of the square roots of each of the first 8
primes.) All these MD variants can be captured in our framework
as making particular choices of suffix-free splitting functions Split
and (singleton) spaces S.
CR is not necessary. We would like to show CR of H = MD[h,
Split, S] under an assumption X on the compression function h that
is weaker than CR. We first ask, is this even possible? Or, is CR of
h necessary for CR of H? We show in Section 6 that CR of h is not
necessary. Given a suffix-free Split, we build a compression function
h and set S such that (1) h is not CR, yet (2) H = MD[h, Split, S] is CR.
This opens the door to proving CR of H under relaxed assumptions
on h.
RS security. But what would these assumptions be? Towards find-
ing and formulating them, we step back to give a framework to
define security goals for h. Security is parameterized by a relation
R and a set S. The game gives the adversary Aa random key k for h
and a random point s in S. It returns an object denoted out, and wins
if R, given k, s, out, returns true. Its RS-advantage is the probability
that it wins. Classical X=CR is captured by viewing out as a pair
of strings that R checks are a collision under hk, with s not being
involved, formally S = {ε}. A form of pre-image resistance that we
will use is captured by having R check that out gives a pre-image of
s ∈ S = {0, 1}σ under hk. We can also capture constrained forms
of collision resistance (ccr), so called because extra requirements
are made on the collision, thereby constraining it. In particular, we
define RccrS security. Here winning requires that out contains, not
only a collision (m1, c1),(m2, c2) for hk, but also, for both j = 1, 2,
if cj (cid:44) s, a further pre-image of it under hk. Providing the auxiliary
information in addition to a collision makes the adversary’s job
harder, so X=RccrS security is a weaker assumption on h than CR.
We can define other relaxations of CR as well.
CR from CCR. Theorem 6.4 relaxes the CR assumption, made on
the compression function h in Theorem 5.3, to RccrS security. That
is, we show that if Split is suffix free and h is RccrS secure, then hash
function H = MD[h, Split, S] is CR secure. The first consequence of
this is that the bar is lowered for the compression function designer
(their design only needs to provide RccrS security, which is easier
than providing CR) and raised for the cryptanalyst (their attack
needs to violate RccrS security, which is harder than violating CR).
We now discuss another consequence, namely to (possibly) better
understand some cryptanalytic history.
Already in 1996, Dobbertin had found collisions for the com-
pression function md5 of MD5 [16]. This did not, however, yield
collisions on MD5 itself. This, to us, was an indication that MD
was “better than advertised:” it was (possibly) able to promote a
non-CR compression function to a CR hash function. Our work is
an attempt to capture this intuition formally. Now, it is true that
in this particular case the hope was not realized, meaning MD5
failed to be CR, as shown by direct attack [33, 34]. What that tells
us is that the compression function md5 is even weaker than we
thought: not only is it not CR, it is not even RccrS. In fact, starting
from known MD5 collisions, our reduction will construct collisions,
and accompanying auxiliary information, to violate RccrS security
of md5. The story repeats with SHA-1, where collisions found for
the compression function sha-1 [30] did not immediately yield col-
lisions for SHA-1, but the latter have now been found [29]. Again,
it means sha-1 is not even RccrS. This, in our view, improves our
understanding of compression function security.
Speeding up MD. Suppose the message M = 02µ−1 to be hashed is
a bit short of twice the block length µ. A typical suffix-free encoding
(for example that of SHA-256) will pad M and append an encoding
of the length |M|, to result in a 3-block string m, over which the
compression function is iterated. The compression function is thus
called 3 times. One might hope for better, just 2 calls. More gener-
ally, the savings from dropping one compression function call are
significant since messages in practice are often short. This leads us
to ask why not use a minimal splitting scheme, like just 10∗ pad
the message, which in our example results in m = 02µ−11 being 2
blocks long, so that MD will use only two calls to the compression
function. But this splitting function is not suffix-free, and did we not
show that the suffix-freeness assumption on Split is necessary for
CR of H? Yes, but that was when the assumption on h is CR. Hence
it is of course also true when the assumption is RccrS, since that is
implied by CR, but in Section 7 we show that mere injectivity of
Split (in particular 10∗ padding of the message) does guarantee CR
of H = MD[h, Split, S] under alternative assumptions on h, specif-
ically that it is both ccr and pre-image resistant. The assumption
seems quite plausible compared to CR so the performance gain and
simplicity of the splitting could make this version of MD attractive.
Our result generalizes, formalizes and strengthens folklore un-
derstanding suggested by the following quote from [3]: “It was
already known that the plain Merkle-Damgård iteration (so with-
out length strengthening) preserves collision resistance provided
it is hard to find a pre-image for the initial vector ... the latter is
implied by everywhere pre-image resistance ...” Specifically, our no-
tion of pre-image resistance is weaker than everywhere pre-image
resistance: we assume only CCR, rather than CR, of the compres-
sion function, we allow starting points (initial vectors) chosen from
a distribution, our result applies with any injective Split rather than
just plain Merkle-Damgård (a particular choice of Split), and we
give formal definitions, result statements and proofs.
Reduction complexity. As indicated above, many prior works
have claimed or proved that CR of h implies CR of H, either for par-
ticular choices of Split or assuming the latter is suffix free. It is inter-
esting that, with the exception of a work on formal verification [5],
not only papers [1, 5, 15, 17, 18, 24], but also textbooks [20, 22, 31],
fail to explicitly specify the reduction underlying the proof. This
takes attention away from, and makes it difficult to address, the
important question of the (computational) complexity (efficiency)
of the reduction. Whether in showing CR or CCR of h implies CR of
Session D4:  Crypto PrimitivesCCS’17, October 30-November 3, 2017, Dallas, TX, USA892H, we in contrast are interested in the precise complexity of the re-
duction. We accordingly give explicit, pseudocode reductions. In the
main sections, we give the reductions that emanate naturally from
the proof. Then, in Section 9, we revisit the question of complexity
to give alternative reductions that are more memory-efficient [4].
Discussion and related work. MD-based hash functions are also
used for HMAC [8]. If we contemplate changes in splitting functions,
we want to ensure HMAC security is preserved. However, current
analyses of HMAC security [6, 19] show that suffix-free, and even
injective, splitting functions suffice.
Our focus is on MD as a way to achieve collision resistance. Other
works have looked at it for other ends. Use of MD with prefix-free
(as opposed to suffix-free) encodings has been shown in [7, 9] to
preserve PRF security. Its ability to provide indifferentiability from
a random oracle is studied in [18]. More broadly, MD is one of
many possible domain extension methods, and some works [2, 10]
consider methods that preserve multiple properties.
2 NOTATION AND CONVENTIONS
If m is a vector then |m| denotes its length, m[i] denotes its i-th
coordinate and m[i..j] denotes the vector consisting of coordinates
i through j of m. For example if m = (010, 11, 10, 111) then |m| = 4,