    libnss_nisplus-2.31.so
    libnss_nisplus.so
    libnss_nisplus.so.2
    libnss_systemd.so.2
正常情况下当`sudo`调用到`__nss_lookup_function`情况如下
    In file: /root/glibc/sourceCode/glibc-2.31/nss/nsswitch.c
       408 #endif
       409
       410
       411 void *
       412 __nss_lookup_function (service_user *ni, const char *fct_name)
     ► 413 {
       414   void **found, *result;
       415
       416   /* We now modify global data.  Protect it.  */
       417   __libc_lock_lock (lock);
       418
    ───────────────────[ STACK]─────────
    00:0000│ rsp  0x7fffffffe358 —▸ 0x7ffff7e3713f (internal_getgrouplist+175) ◂— test   rax, rax
    01:0008│      0x7fffffffe360 ◂— 0x25b000000ae
    02:0010│      0x7fffffffe368 ◂— 0xffffff0000007d /* '}' */
    03:0018│      0x7fffffffe370 ◂— 0xffffffffffffffff
    04:0020│      0x7fffffffe378 —▸ 0x7fffffffe380 ◂— 0x1
    05:0028│      0x7fffffffe380 ◂— 0x1
    06:0030│      0x7fffffffe388 ◂— 0xc4e5bb2d41c2d00
    07:0038│      0x7fffffffe390 ◂— 0x0
    ───────────────────[ BACKTRACE ]─────────────────
     ► f 0     7ffff7e9bdf0 __nss_lookup_function
       f 1     7ffff7e3713f internal_getgrouplist+175
       f 2     7ffff7e373ed getgrouplist+109
       f 3     7ffff7f4fe16 sudo_getgrouplist2_v1+198
       f 4     7ffff7c53d63 sudo_make_gidlist_item+451
       f 5     7ffff7c52b0e sudo_get_gidlist+286
       f 6     7ffff7c4c86d runas_getgroups+93
       f 7     7ffff7c39d32 set_perms+1650
    ───────────────────────────────────────────────────────────────
    pwndbg> p *ni
    $1 = {
      next = 0x55555557fc10,
      actions = {NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN},
      library = 0x0,
      known = 0x0,
      name = 0x55555557fc00 "files"
    }
    pwndbg> p *(ni->next)
    $2 = {
      next = 0x0,
      actions = {NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN},
      library = 0x0,
      known = 0x0,
      name = 0x55555557fc40 "systemd"
    }
    pwndbg>
当调用`getgroup`函数的时候，`__nss_lookup_function`会依次加载`files,systemd`这两个`service
name`。而这两个`service name`的信息是存储在堆空间中的。看一下`__nss_lookup_function`函数的具体实现
    void *
    __nss_lookup_function (service_user *ni, const char *fct_name)
    {
      void **found, *result;
      /* We now modify global data.  Protect it.  */
      __libc_lock_lock (lock);
      /* Search the tree of functions previously requested.  Data in the
         tree are `known_function' structures, whose first member is a
         `const char *', the lookup key.  The search returns a pointer to
         the tree node structure; the first member of the is a pointer to
         our structure (i.e. what will be a `known_function'); since the
         first member of that is the lookup key string, &FCT_NAME is close
         enough to a pointer to our structure to use as a lookup key that
         will be passed to `known_compare' (above).  */
      found = __tsearch (&fct_name, &ni->known, &known_compare);
      if (found == NULL)
        /* This means out-of-memory.  */
        result = NULL;
      else if (*found != &fct_name)
        {
          //...
        }
      else
        {
          /* This name was not known before.  Now we have a node in the tree
         (in the proper sorted position for FCT_NAME) that points to
         &FCT_NAME instead of any real `known_function' structure.
         Allocate a new structure and fill it in.  */
          known_function *known = malloc (sizeof *known);
          if (! known)
        {
    //...
        }
          else
        {
          /* Point the tree node at this new structure.  */
          *found = known;
          known->fct_name = fct_name;
    #if !defined DO_STATIC_NSS || defined SHARED
          /* Load the appropriate library.  */
          if (nss_load_library (ni) != 0)
            /* This only happens when out of memory.  */
            goto remove_from_tree;
          //...
      return result;
    }
    libc_hidden_def (__nss_lookup_function)
在调用`nss_lookup_function`的时候一般`fct_name`是固定的字符串，所以这里我们直接进入`nss_load_library`函数
    static int
    nss_load_library (service_user *ni)
    {
      if (ni->library == NULL)
        {
          /* This service has not yet been used.  Fetch the service
         library for it, creating a new one if need be.  If there
         is no service table from the file, this static variable
         holds the head of the service_library list made from the
         default configuration.  */
          static name_database default_table;
          ni->library = nss_new_service (service_table ?: &default_table,
                         ni->name);
          if (ni->library == NULL)
        return -1;
        }
      if (ni->library->lib_handle == NULL)
        {
          /* Load the shared library.  */
          size_t shlen = (7 + strlen (ni->name) + 3
                  + strlen (__nss_shlib_revision) + 1);
          int saved_errno = errno;
          char shlib_name[shlen];
          /* Construct shared object name.  */
          __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
                              "libnss_"),
                        ni->name),
                  ".so"),
            __nss_shlib_revision);
          ni->library->lib_handle = __libc_dlopen (shlib_name);
          if (ni->library->lib_handle == NULL)
        {
          //...
        }
    # ifdef USE_NSCD
          else if (is_nscd)
        {
            //...
          }
      return 0;
    }
    #endif
    static service_library *
    nss_new_service (name_database *database, const char *name)
    {
      service_library **currentp = &database->library;
      while (*currentp != NULL)
        {
          if (strcmp ((*currentp)->name, name) == 0)
        return *currentp;
          currentp = &(*currentp)->next;
        }
      /* We have to add the new service.  */
      *currentp = (service_library *) malloc (sizeof (service_library));
      if (*currentp == NULL)
        return NULL;
      (*currentp)->name = name;
      (*currentp)->lib_handle = NULL;
      (*currentp)->next = NULL;
      return *currentp;
    }
    #endif
从代码中我们可以看出，如果`ni->library=NULL`，那么就会调用`nss_new_service`函数为其分配一个堆块，并对`name,lib_handle,next`赋值，完成之后进入`if
(ni->library->lib_handle ==
NULL)`分支，对`name`进行字符串拼接，也就是`libnss_+name+'.so.2'`，之后就会调用`__libc_dlopen`函数加载动态链接库。
由于`ni`的`service
name`结构体是分配在堆空间中的，而现在我们有存在`user_args`的堆溢出的漏洞，那么如果我们利用堆溢出将`service
name`结构体的除`name`之外的其他成员变量全部覆写为`0`，`name`覆写为`x/x`那么经过字符串拼接之后就会加载`libnss_x/x.so.2`的动态链接库，我们将`getshell`的代码写入`_init`之后编译为动态链接库即可。
接下来就是如何溢出的问题。为了防止溢出过程中覆写中间的关键结构体，`user_args`与`service
name`之间的距离要尽可能的小，最好的方法就是在`service
name`上方人为的释放一个堆块，之后`user_args`再申请该堆块进行溢出。目前分析的`exp`是通过`setlocale`实现的。我们首先来看一下`service_user`的初始化过程
在`sudo.c:191`会调用`get_user_info`函数在获取用户信息的时候需要获取用户的用户名和口令信息，这就需要到了`nss`服务，也就是需要调用`passwd`对应的服务规范。在函数中会调用根据配置文件初始化`file/systemd`等服务规范，调用栈如下
其中关键的逻辑代码如下
    int
    __nss_database_lookup2 (const char *database, const char *alternate_name,
                const char *defconfig, service_user **ni)
    {
      //...
      if (service_table == NULL)
        /* Read config file.  */
        service_table = nss_parse_file (_PATH_NSSWITCH_CONF);
      //...
    }
    static name_database *
    nss_parse_file (const char *fname)
    {
      //...
      fp = fopen (fname, "rce");
      if (fp == NULL)
        return NULL;
      //...
      result = (name_database *) malloc (sizeof (name_database));
      if (result == NULL)
        {
          fclose (fp);
          return NULL;
        }
      result->entry = NULL;
      result->library = NULL;
      do
      {
        name_database_entry *this;
        ssize_t n;
        n = __getline (&line, &len, fp);
        if (n next = this;
          else
            result->entry = this;
          last = this;
        }
      }
      while (!__feof_unlocked (fp));
      //...
    }
    static name_database_entry *
    nss_getline (char *line)
    {
      //...
      result->service = nss_parse_service_list (line);// 处理文件中该行的所有服务规范
      //...
    }
    static service_user *
    nss_parse_service_list (const char *line)// 处理每一个服务规范
    {
      while (1)
      {