Targetori
MFTVCN0
MFTmirror
The MFT clusters (to itself)
MFTbitmap
MFTmirror
Log file
Root directory
security descriptor
Root directory index buffers
$Secure security descriptors
Index of security
descriptors' hash
Index of security
descriptors' ids
Upcase table
A directory's index buffer
A file's data cluster
Table 2. NTFS Disk Pointers. This table presents the
different on-disk pointers used by NTFS.
for NTFS and Linux 2.6.12 for ext3. We run them both
on top of VMWare Workstation for ease of experimenta(cid:173)
tion. The experiments use a separate 2GB IDE virtual disk.
We believe that the use of a VMWare virtual disk does not
change the results; since the corrupter layer is between the
file system and the virtual disk, we observe all disk requests
and responses, and we did not detect any anomaly.
4. NTFS
Although TAPC can be applied to any file system, the
specific pointers to be corrupted and the interesting corrup(cid:173)
tion values depend upon the file system under test. We now
describe how we have applied TAPC to NTFS. We do not
provide ext3 details due to space constraints.
NTFS Data Structures: We provide a brief introduc(cid:173)
tion to NTFS. A detailed description can be found else(cid:173)
where [22]. NTFS, the Windows NT File System, is the
standard file system for Windows NT, 2000, XP and Vista.
It is a j oumaling file system that guarantees the integrity of
its metadata structures on a crash. All user data and meta(cid:173)
data structures in an NTFS volume are contained in files, al(cid:173)
lowing NTFS to flexibly allocate disk space for its metadata.
Table 1 defines important NTFS terms and data structures
that we use in our descriptions and results. For example, a
cluster is the NTFS term for a disk block.
NTFS Pointer Corruption: We corrupt 14 of the 15
different pointer types that NTFS uses on disk. Table 2
summarizes these pointers. We give each pointer a unique
name based on its Targetoriginal, and resolving name
conflicts by prefixing those names with its container.
Note that NTFS replicates important data structures like
Boot and MFT VCN O. Thus, the pointers Boot-MFTO,
Boot-MFTM, MFTO-MFT, MFTBitmap, MFTO-MFTM,
and LogFi 1 e are replicated. Security descriptors are also
replicated and their indexes can be rebuilt; thus, some form
Workload
mount
mount then
CreateFile
mount then
ReadFile
mount then
WriteFile
Pointer
Boot-MFTO, Boot-MFTM,MFTO-MFT,
MFTO-MFTM, LogFile, RootSecDesc,
SDS,SII
MFTBitmap,RootlndxBuf,SDH,
DirlndxBuf
UpCase
FileData
Table 3. NTFS Workloads.
This table presents
the workloads that exercise the disk pointers. mount
enables the file system volume for use;
it consists of
a DeviceIoControl system call with the control
code FSCTL_UNLOCK_VOLUME performed on a previously
Hlocked" volume. CreateFile creates a nel1' file of
size 0, ReadFile reads the first cluster of a file, and
Wri teFile writes the first cluster ofa file.
of redundancy exists for the pointers SDS, SDH, and SII.
To exercise each pointer, we run a specialized workload;
Table 3 indicates the workload used for each ofthe pointers.
Most workloads involves modifications to Targetoriginal,
potentially creating the worst case scenario in case the cor(cid:173)
ruption is not detected. The pointers are corrupted to the
27 different types of values. In addition to using disk loca(cid:173)
tions that belong to all the different NTFS data types (e.g.,
directory index buffer and MFT cluster), we also include
clusters of a certain type that serve a special purpose (e.g.,
MFT VCN 0, MFT mirror), unallocated clusters, and out(cid:173)
of-range values. Table 4 lists the different types of val(cid:173)
ues used as Targetcorrupt.
In most cases, the data struc(cid:173)
ture used as Targetcorrupt is at a specific location, while
for FileData, we create a file and use the location of its
data block as the numerical value for corruption. Thus, we
perform 360 experiments on NTFS, corrupting 14 different
pointers with 27 different values.
5. Results
This section discusses the results. First, we describe
some terminology, then our visual representation of the re(cid:173)
sults. Then, we discuss NTFS behavior as observed by the
experimenter. Our discussion focuses on how NTFS deals
with pointer corruption. Next, we discuss the user-visible
results of NTFS pointer corruption. This view is important
since the primary concern of end users is the observed data
and system reliability. Finally, we present results for ext3.
We organize our results into observations (facets of sys(cid:173)
tem behavior uncovered by TAPC), lessons for corruption(cid:173)
handling techniques, and potential design pitfalls.
5.1. Terminology for System Behavior
Detection: The file system identifies that either the
pointer or the disk block pointed to is corrupt.
Recovery: The file system is able to regenerate the data
lost due to pointer corruption using redundant information,
1-4244-2398-9/08/$20.00 ©2008 IEEE
505
DSN 2008: Bairavasundaram et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:08:01 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
Value
Boot
LogRes
LogResDup
LogData
MFTBitmap
MFTO
MFTI
MFT2
MFTRes
MFTFree
MFT6
MFTOthers
SDS
AttrDef
SDH
SII
MFTMirror
RootIndxBuf
RootSecDesc
VolBitmap
UpCase
DirIndxBuf
FileData
Unalloc
Last-Size+1
LastCluster
Out-of-Bounds
Description
The boot sector (LCN 0)
Log restart area
Copy of Log restart area
Log data cluster
The MFT bitmap
MFTVCNO
MFTVCN 1
MFTVCN2
Contains unused, reserved MFT entries
Unallocated MFT entries
MFTVCN6
Contains user file MFT entries
Security descriptors
File with definitions of file attributes
Index of security descriptor hash
Index of security descriptor ids
The MFT mirror
Root directory index buffer
Root dir security descriptor
Volume bitmap
Upcase table
Any directory index buffer
Any user file data cluster
Unallocated clusters
Data Run ends at last cluster
Boot sector copy
Data Run exceeds disk partition
Table 4. NTFS Pointer Corruption Values. This
table presents the different values used for corrupting disk
pointers used by NTFS, sorted in the order of typical disk
In total, 27 different values are used. Note that
location.
the value Last-Size+1 is applicable only for pointers that
point to data runs oflength > 1.
thereby continuing execution without errors.
Report: The file system informs the application or user
that it has encountered an error.
Retry: The file system repeats the set of disk accesses
needed for the mount operation.
Repair: The file system modifies corrupt data structures
in order to continue execution. The modification does not
necessarily lead to error-free execution.
Detection is essential for the rest of the actions to occur.
Recovery is the ideal action the file system can perform. If
recovery is not possible, repair is an alternative approach
for continuing execution. If a file operation fails due to cor(cid:173)
ruption, the file system is expected to report an error.
5.2. Visualization of Results
We now describe the visualization in Figure 1.
In the
two figures, each row presents the results of corrupting
one pointer (e.g., Boot -MFTO). Every row is divided into
27 columns, each corresponding to different Targetcorrupt
values used to corrupt the pointer (e.g., LogData). Each
cell is marked with a symbol representing our observations
when the pointer for its row is corrupted with the column
value. A dot before pointer name indicates that some form
of redundancy exists for the pointer or for Targetoriginal.
We provide an example from Figure 1a to illustrate the
interpretation of the figures. The results of corrupting
Boot -MFTO is presented in the first row. The first cell
corresponds to the boot sector (Boot). The symbol in the
cell corresponds to "Detects and recovers." This indicates
that when the pointer Boot -MFTO is corrupted to the value
Boot, NTFS detects the corruption and fully recovers from
it, thus continuing normal operation. The value MFTO (col(cid:173)
umn 6) is the correct value for the pointer and hence the
"Not applicable" symbol is used. Note that there is no sim(cid:173)
ilar correct value for pointers like Fi 1eDa t a since we can
use data locations of a different file to corrupt the pointer.
5.3. NTFS Behavior
We discuss the behavior ofNTFS when each of its point(cid:173)
ers are corrupted. The detailed results are presented in Fig(cid:173)
ure 1a and Table 5. Table 6 summarizes these results. This
subsection distills the results into higher-level observations
on system behavior and lessons to be learned. The goal is to
analyze whether NTFS effectively uses its type information
and redundancy, and to understand why NTFS is or is not
able to detect and recover from pointer corruption.
Out of 360 corruption experiments, NTFS detects cor(cid:173)
ruption in 238 cases (66%) and recovers in only 51 cases
(14%). Despite the availability of redundant information
for recovery for most cases, NTFS either simply reports an
error to the user or retries the mount operation. Also, de(cid:173)
spite detecting the corruption, NTFS itself causes further
corruption in 42 cases (12%).
5.3.1. Detection
From our experiments, we find that NTFS uses type check(cid:173)
ing and sanity checking to detect pointer corruption. We
discuss each of these techniques below.
Type checking verifies that a disk cluster conforms to
the requirements for a data type. Typically, type information
for a cluster is encoded in the form ofa "magic" number and
stored in the cluster. In order to perform type checking, the
cluster pointed to should be read.
Sanity checking verifies that certain values in data struc(cid:173)
tures follow constraints. A pointer can be compared with
well-known values, such as locations of metadata like the
boot sector or disk partition size, to ensure that the pointer
is not corrupt. In this case, corruption can be detected even
before the cluster pointed to is read.
Observation 1 NTFS detects corruption errors primarily
through type checking.
We observe that NTFS detects corruption errors af
ter reading Targetcorrupt for many pointers,
including
Boot-MFTO, MFTO-MFT, LogFile, RootlndxBuf,
SII, and DirlndxBuf. An examination of the corre(cid:173)
sponding data structures shows that they contain "magic"
numbers ("FILE" for MFT clusters, "RSTR" for log restart
area, "INDX" for index buffers) that identify the clusters as
a certain data type.
1-4244-2398-9/08/$20.00 ©2008 IEEE
506
DSN 2008: Bairavasundaram et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:08:01 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
(a) NTFS BEHAVIOR
~
~~
m~
j _
~
~~sl
~~~
lii~~;sujl~
oii~~~tt~~t~w~~_~i~ffi~~~1~~~
~jjj~~~~~~~~~~~~~~~~~a~~jjo
1 2 3 4 5 6 7 8 9 1011 12131415161718192021222324252627
1-1-1-1-1-1 1-1-1-1-1-1-1-1-1-1-101-1-1-1-1-1-1-1 10101
1-1-1-1-1-101-1-1-1-1-1-1-1-1-1-1 1-1-1-1-1-1-1-1 10101
10
-I-I
101010101010
-
_ Boot-MFTO
_ Boot-MFTM
_ MFTO-MFT
(b) USER-VISIBLE RESULTS
Ij
~
c3 nl ~
~~mffiO~N~£~O ~
~ ~ ~
~ ~ ~
~£~~~~m~~~~
g~~~~~~~~~~~~~5=~g8~~~~~~~~
~ ~
g~ g i
~ nl
III G)
m~~~~~~~~~~~w~Q~~~~o
1 2 3 4 5 6 7 8 9 1011 1213141516171819202122 23 24 252627
1-1-1-1-1-1 I-I-I-I-I-I-I-I-I-I-M-I-I-I-I-I-I-I •
I-I-I-I-I-M-I-I-I-I-I-I-I-I-I-I 1-1-1-1-1-1-1-1 •
_ Boot-MFTO
_ Boot-MFTM
_ MFTO-MFT
_ MFTBitmap
_ MFTO-MFTM
-
_ LogFile
-I-I
Moioiol 10101010101010101010101010101010101&1 101-1
M-I-I-lol-.-I-.-MoM
Eoe:::a M-I
-I-I
M
RootSecDesc • • • • • • • • • • • • • • • • •
RootIndxBuf • • • • • • • • • • •::::I• • •IJ••
•••••••••••••••••••••••
10101010101010101010101010101 Moioioioioioioiol 10M..
•
Eoe:::a •
DirIndxBuf
FileData M
_ SDS
_ SDH
_ SII
UpCase
[!] Detects and recovers
[Q] Detects, but no recovery
• Detects, but corrupts
• No detection, no recovery
o Not applicable
• Unmountable file system
[!] System works without problems ~ System crash
[Q] Operations fail
§ User data corruption
• Data or metadata loss, operations fail
a Implications are data dependent
0 Not applicable
Legend
Figure 1. NTFS Corruption Behavior and Implications. These figures present (a) the corruption behavior ofNTFS, and
(b) the implications ofthis behavior for the user. Each row (horizontal strip) characterizes the behavior for the given pointer. Each
cell in a row is marked with the corruption behavior/implications observedfor the given pointer when it is corrupted with the value
ofthat column. Ofthe different values, Last-Size+1 denotes Last Cluster - Size ofdata run + 1 and is applicable only for data runs
oflength greater than 1. A large dot next to a pointer name for any row implies that someform ofredundancy exists; in the ideal
case NTFS would be able to recover from any corruption to these pointers. Note that in the case ofunallocated clusters, further