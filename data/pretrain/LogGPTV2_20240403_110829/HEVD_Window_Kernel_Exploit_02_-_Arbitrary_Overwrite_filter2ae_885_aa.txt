# HEVD Window Kernel Exploit 02 - Arbitrary Overwrite
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0\. 前言
作者本人平时学习Windows内核的时候，会按照[HEVD](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)这个教程进行Windows
Kernel Exploit的学习，然而作者懒癌比较严重，装了一台win10 1903 x86的vm却懒得换，所以就硬在这个平台上完成作业。然而在网上发现
**很多该系列的文章讨论的都不是在这个版本上进行的，所以导致很多WP在这个平台上已经不适用了。** 然而现实中，Windows
Kernel的EXP却也依然能够涵盖到非常新的win10版本上，说明即使在最新的win10上，也依然有利用的机会。所以这篇文章想要简单的讨论一下在Win10
1903上，对于这个教程中内核漏洞的利用方式。
关于HEVD，这里简单介绍一下，这个项目其实就是一个故意写了各种漏洞的驱动程序，我们可以通过IOCTL的方式与之交互，从而触发其中的漏洞，对于学习内核来说是一个很棒的项目。关于项目的搭建，网上已经有了很多方案，比如这[这里](http://bobao.360.cn/learning/detail/3448.html)。这篇文章将会直接对其中的`Arbitrary
Overwrite`漏洞进行分析。
## 1\. 漏洞分析
这次我们分析的漏洞叫做`Arbitrary Overwrite`，也就是 **任意地址写** 。这种漏洞的形式通常是
  * 一个 **可以被用户输入控制的指针**
  * 在被用户输入控制后，能够触发 **对指针所指向内容的修改** :
用代码来表示的话就是形如
    int ArbitraryOverWrite(int user_input, int content){
        // some code
        int *ptr = user_input;
        // other code
        *ptr = content;
    }
这种漏洞在用户态的程序中有一些很容易能够想到的利用方法，比如 **修改内存中一些特定的函数指针，从而控制程序流**
。不过在内核中，这个利用可就困难重重了。在之后的分析里，我们将会提到内核对这类思路做出来的防护。
###  漏洞点
比起直接看代码，不如直接逆向驱动，对后续写exp帮助大，所以这边就直接使用IDA检查一下这个有问题的函数:
    int __stdcall ArbitraryOverwriteIoctlHandler(PIRP a1, PIO_STACK_LOCATION a2)
    {
      int v2; // ecx
      v2 = 0xC0000001;
      if ( a2->Parameters.DeviceIoControl.Type3InputBuffer )
        v2 = TriggerArbitraryOverwrite((UserAddr *)a2->Parameters.DeviceIoControl.Type3InputBuffer);
      return v2;
    }
    int __stdcall TriggerArbitraryOverwrite(UserAddr *UserAddress)
    {
      _DWORD *Where_addr; // edi
      _DWORD *What_content; // ebx
      ProbeForRead(UserAddress, 8u, 4u);
      What = (_DWORD *)UserAddress->What;
      Where_addr = (_DWORD *)UserAddress->Where;
      DbgPrint("[+] UserWriteWhatWhere: 0x%p\n", UserAddress);
      DbgPrint("[+] WRITE_WHAT_WHERE Size: 0x%X\n", 8);
      DbgPrint("[+] UserWriteWhatWhere->What: 0x%p\n", What);
      DbgPrint("[+] UserWriteWhatWhere->Where: 0x%p\n", Where_addr);
      DbgPrint("[+] Triggering Arbitrary Overwrite\n");
      *Where_addr = *What;
      return 0;
    }
这个`UserAddr`是一个代码本身定义的一个结构体:
    struct UserAddr
    {
      int Where;
      int What;
    };
套用我们刚刚提到的公式：
  * Where是一个 **能被用户输入控制的指针**
  * Where在被用户控制输入控制后， **用户能控制其写入的内容**
这个就是一个典型的任意地址写，甚至可以写任意的内容。我们将这种漏洞称为`write-what-where`的漏洞。
## 2\. 利用思路
###  2.1 往哪儿写（Win7版本利用思路）
遇到这种漏洞的时候，第一个想到的应该就是 **需要往哪儿写**
。一个常见的套路的是`nt!haldispatchTable`，这是一个`ntokrnl.exe`中一个用来存放`HAL*`函数指针的全局对象。内核中有个很少被调用的API
**NtQueryIntervalProfile** ，这和API在底层会调用`nt!haldispatchTable+4`(64bit 为
`nt!haldispatchTable+8`)中指向的函数。所以当我们往`nt!haldispatchTable+4`写入我们指定的地址，就相当于是劫持了
**NtQueryIntervalProfile** 的调用。而这个API是可以从用户态调用的，那么就相当于我们变相
**从用户态劫持了内核态API的调用**
###  2.2 要写什么（旧思路）
####  shellcode 地址？
第一个直观的想法就是 **将用户态的shellcode地址写上去** 。然而win8开始，就有了SMEP的问题，更何况这边win10
1903，所以直接修改成shellcode的思路是不行的。
####  ExAllocatePool 地址？
这个思路也在网络上看到过，大约就是说通过往这个地址上写入`ExpAllocatePool`这个API的地址，从而让我们call`NtQueryIntervalProfile`这个动作变成call`ExpAllocatePool`。实现在内核中分配shellcode地址。不过由于这个`NtQueryIntervalProfile`传入的参数是会被check的，这边稍微参考一下`ReactOS`的代码
    NTSTATUS NTAPI NtQueryIntervalProfile(    IN KPROFILE_SOURCE     ProfileSource, 
                                            OUT PULONG     Interval)    
    {
         KPROCESSOR_MODE PreviousMode = ExGetPreviousMode();
         ULONG ReturnInterval;
         NTSTATUS Status = STATUS_SUCCESS;
         PAGED_CODE();
         // pass some code
         /* Query the Interval */
         ReturnInterval = (ULONG)KeQueryIntervalProfile(ProfileSource);
可以看到，最后传入`KeQueryIntervalProfile`的只有第一个参数`ProfileSource`，所以我们能控制的变量其实根本不足够去完成一个`ExpAllocatePool`所需要的参数，所以这个思路也是不可行的。
###  2.3 往哪儿写（Win8~Win10 1703之前的版本）
遇到了难题，自己没办法解决的时候只好求助他人了，于是我找到了`wjllz`大师傅的[博客](https://paper.seebug.org/876/)，这里提到说
**将替换API地址改成ROP**
，但是这个方法在我的测试环境上(1903)似乎不能正常work。于是我直接找到了他本人去问。大师傅人很好，给了我很多方向，促使我找到了一篇[blackhat上的文章](https://www.blackhat.com/docs/us-17/wednesday/us-17-Schenk-Taking-Windows-10-Kernel-Exploitation-To-The-Next-Level%E2%80%93Leveraging-Write-What-Where-Vulnerabilities-In-Creators-Update-wp.pdf)，里面提到了一种方法:
这个方法的原理是说，在形如`NtGdiDdDDICreateAllocation`，或者大佬博客里提到的`NtGdiDdDDIGetContextSchedulingPriority`这类和GDI相关的API调用的处理驱动中，有一些函数会从
**win32kbase!gDxgkInterface这个全局对象表中取出自己实际调用的函数地址**
。而这个API是可以接受至少两个参数的，这就让我们替换ExpAllocatePool成为了可能。[这里](https://xz.aliyun.com/t/3134)的分析文章中也提到了，这种攻击是确实可行的。  
然而，看到1903中的形式：  
上图中的`win32k!NtGdiDdDDIGetContextSchedulingPriority`是驱动所在的导出表的位置，我们看过去
    win32k!NtGdiDdDDIGetContextSchedulingPriority:
    93e00689 ff259016e093    jmp     dword ptr [win32k!_imp__NtGdiDdDDIGetContextSchedulingPriority (93e01690)]
    win32k!NtGdiDdDDISetContextSchedulingPriority:
    93e0068f ff258c16e093    jmp     dword ptr [win32k!_imp__NtGdiDdDDISetContextSchedulingPriority (93e0168c)]
    win32k!NtGdiDdDDIGetDeviceState:
    93e00695 ff258816e093    jmp     dword ptr [win32k!_imp__NtGdiDdDDIGetDeviceState (93e01688)]
然而我们顺着找这个`win32k!_imp__NtGdiDdDDIGetContextSchedulingPriority`的地址，可以找到如下内容:
    1: kd> dd win32k!_imp__NtGdiDdDDIGetContextSchedulingPriority
    93e01690  9090f62f 90858cb6 90935941 90935a69
    93e016a0  9082dad0 940dd204 940dcc95 940dc939
    93e016b0  940dbcce 940dbb6f 940dd2af 940dcbd7
这个`9090f62f`正好指向一个实现在`dxgkrnl.sys`的对应函数:
    1: kd> u 9090f62f
    dxgkrnl!DxgkGetContextSchedulingPriority:
    9090f62f 68a8000000      push    0A8h
    9090f634 68a0c17d90      push    offset dxgkrnl!_realffefffffffffffff+0x1e30 (907dc1a0)
    9090f639 e876a5e8ff      call    dxgkrnl!_SEH_prolog4_GS (90799bb4)
    9090f63e 8b7508          mov     esi,dword ptr [ebp+8]
    9090f641 838d58ffffffff  or      dword ptr [ebp-0A8h],0FFFFFFFFh
    9090f648 33db            xor     ebx,ebx
仔细看，好像这个调用过程中 **完全没有经过gDxgkInterface这个全局对象**
？在搜索了一些资料后，终于在[这个网站](https://www.unknowncheats.me/forum/2567493-post86.html)上找到了答案，这边提到了一个很重要的事情：`windows
1903`中，大部分的函数已经 **不使用win32kbase作为proxy，而是直接由dxgkrnl.sys导出函数来调用** 。所以这条路也被封死了。
## 3\. 和Linux kernel pwn的联想（新的思路）
回想以前看过Linux 的kernel
pwn，似乎很少提到说，当获得一个WWW漏洞的时候，一定要通过修改函数指针来提权的，大部分提到的都是修改`cred`这个结构体来实现提权。  
Windows中的`TOKEN`这个结构体起到的作用就和这个`cred`类似，也是类似Windows下的权限控制。而我们可以看到，很多Windows
kernel下的提权攻击最后一步，也就是将system进程的token拷贝到当前进程。那
**我们直接将当前进程的token修改成类似system的token，是不是也能达到一样的效果呢？**
正好前阵子有一个cve分析的文章出来，这个文章里面提到了一个2012年就被提出来的，window kernel
pwn应该做什么的文章这篇文章非常好，其讲述了关于Windows下提权的利用思路，其中有一个思路非常重要，就是
**通过修改TOKEN，直接实现将当前进程的提权** 。
###  3.1 通过修改_TOKEN来进行提权
一个进程中的`TOKEN`结构体如下:
    typedef struct _TOKEN
    {
         TOKEN_SOURCE TokenSource;
         LUID TokenId;
         LUID AuthenticationId;
         LUID ParentTokenId;
         LARGE_INTEGER ExpirationTime;
         PERESOURCE TokenLock;
         LUID ModifiedId;
         SEP_TOKEN_PRIVILEGES Privileges;
         SEP_AUDIT_POLICY AuditPolicy;
         ULONG SessionId;
         ULONG UserAndGroupCount;
         ULONG RestrictedSidCount;
         ULONG VariableLength;
         ULONG DynamicCharged;
         ULONG DynamicAvailable;
         ULONG DefaultOwnerIndex;
         PSID_AND_ATTRIBUTES UserAndGroups;
         PSID_AND_ATTRIBUTES RestrictedSids;
         PVOID PrimaryGroup;