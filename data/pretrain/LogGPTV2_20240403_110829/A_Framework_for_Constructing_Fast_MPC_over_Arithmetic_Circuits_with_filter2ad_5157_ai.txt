because by Equations (9) and (10), the communication is almost
linear in δ. Thus, the number of (cid:27)eld elements sent when δ = 2 is
approximately twice the number of (cid:27)eld elements sent when δ = 1.
Since the size of a single 61-bit (cid:27)eld element is approximately twice
the size of a 31-bit (cid:27)eld element, we have that the communication
is similar. Having said the above, we do observe that the protocol
using a 61-bit (cid:27)eld is slightly better for a small number of parties
(n ≤ 9), whereas the protocol using a 31-bit (cid:27)eld is slightly better
for a larger number of parties (n ≥ 11). This can be explained by
the fact that communication costs are more signi(cid:27)cant for a larger
number of parties, and two times Eq. (9) with δ = 1 is slightly higher
than one times Eq. (9) with δ = 2. Concretely, in van_DN_open
the number of (cid:27)eld elements is t(πmult) = 6, t(Frand) = 2 and
t(open) = n − 1; thus, for n = 11, we have that 46 group elements
are sent with δ = 1 and 86 group elements are sent with δ = 2.
Given that each group element is twice the size for δ = 1, we have
that this is 7% more communication.
Arithmetic or Boolean protocols. It is instructive to compare our 3-
party protocol (that computes at a rate of 1,000,000 multiplications
per second) to the best 3-party protocol with malicious security
for Boolean circuits [1], that computes approximately 73,000,000
AND gates per second on a single core [2]. A back of the envelope
calculation shows that multiplication in our protocol cost about
the same as addition in a Boolean circuit (whereas addition is free
here, but multiplication is very expensive in Boolean circuits). Thus,
for arithmetic-based computation, our protocol is far superior (of
course, in computations that require many comparisons and other
types of operations, the reverse is true).
[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watz-
man and O. Weinstein. Personal communication, May 2017.
[15]
[16]
[9] R. Canetti. Security and Composition of Multiparty Cryptographic Protocols.
[11] D. Chaum, C. Crépeau and I. Damgård. Multi-party Unconditionally Secure
[10] R. Canetti. Universally Composable Security: A New Paradigm for Crypto-
[3] T. Araki, J. Furukawa, Y. Lindell, A. Nof and K. Ohara. High-Throughput Semi-
Honest Secure Three-Party Computation with an Honest Majority. In the 23rd
ACM CCS, pages 805–817, 2016.
[4] D. Beaver. E(cid:28)cient Multiparty Protocols Using Circuit Randomization. In
CRYPTO 1991, Springer (LNCS 576), pages 420–432, 1992.
[5] E. Ben-Sasson, S. Fehr and R. Ostrovsky. Near-Linear Unconditionally-Secure
Multiparty Computation with a Dishonest Minority. In CRYPTO 2012, Springer
(LNCS 7417), pages 663-680, 2012.
[6] Z. Beerliová-Trubíniová and M. Hirt. Perfectly-secure MPC with linear com-
munication complexity. In TCC 2008, Springer (LNCS 4948), pages 213–230,
2008.
[7] M. Ben-Or, S. Goldwasser and A. Wigderson. Completeness Theorems for
Non-Cryptographic Fault-Tolerant Distributed Computation. In 20th STOC,
pages 1–10, 1988.
[8] S.S. Burra, E. Larraia, J.B. Nielsen, P.S. Nordholt, C. Orlandi, E. Orsini, P. Scholl,
and N.P. Smart. High Performance Multi-Party Computation for Binary Cir-
cuits Based on Oblivious Transfer. ePrint Cryptology Archive, 2015/472.
Journal of Cryptology, 13(1):143–202, 2000.
graphic Protocols. In 42nd FOCS, pages 136–145, 2001.
Protocols. In 20th STOC, pages 11–19, 1988.
[12] K. Chida, K. Hamada, D. Ikarashi and R. Kikuchi. Actively Private and Correct
MPC Scheme in t<n/2 from Passively Secure Schemes with Small Overhead.
IACR Cryptology ePrint Archive, report 2014/304, 2014.
[13] R. Cramer, I. Damgård and Y. Ishai, Share Conversion, Pseudorandom Secret-
Sharing and Applications to Secure Computation. In the 2nd TCC, Springer
(LNCS 3378) pages 342–362, 2005.
I. Damgård, M. Geisler, M. Krøigaard and J.B.Nielsen. Asynchronous Multiparty
Computation: Theory and Implementation. In Public Key Cryptography 2009,
Springer (LNCS 5443), pages 160–179, 2009.
I. Damgård and Y. Ishai. Scalable Secure Multiparty Computation. In CRYPTO
2006, Springer (LNCS 4117), pages 501–520, 2006.
I. Damgård, M. Keller, E. Larraia, V. Pastro, P. Scholl, and N.P. Smart. Practical
covertly secure MPC for dishonest majority - or: Breaking the SPDZ limits. In
18th ESORICS, pages 1–18, 2013.
I. Damgård and J. Nielsen. Scalable and unconditionally secure multiparty
computation. In CRYPTO 2007, Springer (LNCS 4622), pages 572–590, 2007.
I. Damgård, V. Pastro, N.P. Smart and S. Zakarias. Multiparty Computation
from Somewhat Homomorphic Encryption. In CRYPTO 2012, pages 643–662,
2012.
J. Furukawa, Y. Lindell, A. Nof and O. Weinstein. High-Throughput Secure
Three-Party Computation for Malicious Adversaries and an Honest Majority
In EUROCRYPT 2017, Springer (LNCS 10211), pages 225–255, 2017.
[20] R.A. Fisher and F. Yates. Statistical Tables for Biological, Agricultural and Medical
Research (3rd ed.), pages 26–27, 1938.
[21] D. Genkin, Y. Ishai, M. Prabhakaran, A. Sahai and E. Tromer. Circuits Resilient
to Additive Attacks with Applications to Secure Computation. In STOC 2014,
pages 495-504, 2014.
[22] D. Genkin, Y. Ishai and A. Polychroniadou. E(cid:28)cient Multi-party Computation:
From Passive to Active Security via Secure SIMD Circuits. In CRYPTO 2015,
Springer (LNCS 9216), pages 721–741, 2015.
[23] M. Hirt and J.B. Nielsen. Robust Multiparty Computation with Linear Commu-
nication Complexity. In CRYPTO 2006, Springer (LNCS 4117), pages 463–482,
2006.
[24] O. Goldreich, S. Micali, and A. Wigderson. How to Play Any Mental Game. In
[14]
19th STOC, pages 218–229, 1987.
[25] R. Gennaro, M. Rabin and T. Rabin. Simpli(cid:27)ed VSS and Fact-Track Multiparty
Computations with Applications to Threshold Cryptography. In 17th PODC,
pages 101–111, 1998.
[26] O. Goldreich. Foundations of Cryptography: Volume 2 – Basic Applications.
[27] S. Goldwasser and Y. Lindell. Secure Computation Without Agreement. In the
Cambridge University Press, 2004.
Journal of Cryptology, 18(3):247–287, 2005.
[28] M. Keller, E. Orsini and P. Scholl. MASCOT: Faster Malicious Arithmetic Secure
Computation with Oblivious Transfer. In the 23rd ACM CCS, pages 830–842,
2016.
[29] E. Kushilevitz, Y. Lindell and T. Rabin. Information-Theoretically Secure Pro-
tocols and Security Under Composition. In the SIAM Journal on Computing,
39(5):2090–2112, 2010.
[30] Y. Lindell and B. Pinkas. Secure Two-Party Computation via Cut-and-Choose
Oblivious Transfer. In the 8th TCC, Springer (LNCS 6597), 329–346, 2011.
[31] P. Mohassel, M. Rosulek and Y. Zhang. Fast and Secure Three-party Compu-
tation: The Garbled Circuit Approach. In ACM Conference on Computer and
[17]
[18]
[19]
Figure 1: A comparison of the 4 di(cid:29)erent Shamir-based protocols
with a 61-bit prime
Figure 2: A comparison of the 4 di(cid:29)erent Shamir-based protocols
with a 61-bit prime, for a small number of partiets
Figure 3: A comparison of the best running-times with 31-bit and
61-bit primes, for Shamir-based instantiations
ACKNOWLEDGEMENTS
We thank the anonymous reviewers and Mike Rosulek for helpful
comments and discussion. We also thank Meital Levy and Hila Da-
hari for the protocol implementation, and Lior Koskas for running
the experiments.
REFERENCES
[1] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watz-
man and O. Weinstein. Optimized Honest-Majority MPC for Malicious Ad-
versaries - Breaking the 1 Billion-Gate Per Second Barrier. In the 38th IEEE
Symposium on Security and Privacy, pages 843–862, 2017.
[32]
Communications Security, pages 591–602, 2015.
J.B. Nielsen, P.S. Nordholt, C. Orlandi and S.S. Burra. A New Approach to
Practical Active-Secure Two-Party Computation. In CRYPTO 2012, Springer
(LNCS 7417), pages 681–700, 2012.
[33] P. Paillier. Public-Key Cryptosystems Based on Composite Degree Residuosity
[34] T. Rabin and M. Ben-Or. Veri(cid:27)able Secret Sharing and Multi-party Protocols
Classes. In EUROCRYPT 1999, Springer (LNCS 1592), pages 223–238, 1999.
with Honest Majority. In 21st STOC, pages 73–85, 1989.
612–613, 1979.
[35] A. Shamir. How to share a secret. Communications of the ACM, 22(11), pages
[36] A. Yao. How to Generate and Exchange Secrets. In the 27th FOCS, pages
162–167, 1986.
A DEFINITION OF SECURITY
The security parameter is denoted κ; negligible functions and com-
putational indistinguishability are de(cid:27)ned in the standard way, with
respect to non-uniform polynomial-time distinguishers.
Ideal versus real model de(cid:27)nition. We use the ideal/real simulation
paradigm in order to de(cid:27)ne security, where an execution in the
real world is compared to an execution in an ideal world where
an incorruptible trusted party computes the functionality for the
parties [9, 26]. We de(cid:27)ne security with abort (and without fairness),
meaning that the corrupted party may receive output while the
honest parties do not. Our de(cid:27)nition does not guarantee unanimous
abort, meaning that some honest party may receive output while the
other does not. It is easy to modify our protocols so that the honest
parties unanimously abort by running a single (weak) Byzantine
agreement at the end of the execution [27]; we therefore omit this
step for simplicity.
Note that with an honest majority, it is possible to achieve fair-
ness (assuming a broadcast channel). Nevertheless, our protocol
does not guarantee this, and we do not know how to modify it to
guarantee fairness without signi(cid:27)cantly sacri(cid:27)cing e(cid:28)ciency,
The real model. In the real model, a n-party protocol π is executed
by the parties. For simplicity, we consider a synchronous network
that proceeds in rounds and a rushing adversary, meaning that the
adversary receives its incoming messages in a round before it sends
its outgoing message.4 The adversary A can be malicious; it sends
all messages in place of the corrupted party, and can follow any
arbitrary strategy. The honest parties follow the instructions of the
protocol.
Let A be a non-uniform probabilistic polynomial-time adversary
controlling t < n2 parties. Let realπ ,A(z),I(x1, . . . , xn, κ) denote
the output of the honest parties and A in an real execution of
π, with inputs x1, . . . , xn, auxiliary-input z for A, and security
parameter κ.
The ideal model. We de(cid:27)ne the ideal model, for any (possibly
reactive) functionality F , receiving inputs from P1, . . . , Pn and
providing them outputs. Let I ⊂ {1, . . . , n} be the set of indices
of the corrupted parties controlled by the adversary. The ideal
execution proceeds as follows:
• Send inputs to the trusted party: Each honest party Pj
sends its speci(cid:27)ed input xj to the trusted party. A corrupted
4This modeling is only for simplicity, since in our protocol, all parties receive and
send messages in each round. Thus, by instructing each party to only send their round
i + 1 messages after receiving all round-i messages, we have that an execution of
the protocol in an asynchronous network is the same as for a rushing adversary in a
synchronous network. Note that we do not guarantee output delivery, so “hanging” of
the protocol is also allowed.
i
or an abort message.
party Pi controlled by the adversary may either send its
speci(cid:27)ed input xi, some other x(cid:48)
• Early abort option: If the trusted party received abort
from the adversary A, it sends ⊥ to all parties and termi-
nates. Otherwise, it proceeds to the next step.
• Trusted party sends output to the adversary: The trusted
party computes each party’s output as speci(cid:27)ed by the func-
tionality F based on the inputs received; denote the output
of Pj by yj. The trusted party then sends {yi}i∈I to the
corrupted parties.
• Adversary instructs trusted party to continue or halt:
For each j ∈ {1, . . . , n} with j (cid:60) I, the adversary sends the
trusted party either abortj or continuej. For each j (cid:60) I:
– If the trusted party received abortj then it sends Pj
– If the trusted party received continuej then it sends
• Outputs: The honest parties always output the output
value they obtained from the trusted party, and the cor-
rupted parties outputs nothing.
the abort value ⊥ for output.
Pj its output value yj.
Let S be a non-uniform probabilistic polynomial-time adversary
controlling parties Pi for i ∈ I. Let idealF,S(z),I(x1, . . . , xn, κ)
denote the output of the honest parties and S in an ideal execution
with the functionality F , inputs x1, . . . , xn to the parties, auxiliary-
input z to S, and security parameter κ.
Security. Informally speaking, the de(cid:27)nition says that protocol π
securely computes f if adversaries in the ideal world can simulate
executions of the real world protocol. In some of our protocols there
is a statistical error that is not dependent on the computational
security parameter. As in [30], we formalize security in this model
by saying that the distinguisher can distinguish with probability at
most this error plus some factor that is negligible in the security
parameter. This is formally di(cid:29)erent from the standard de(cid:27)nition of
security since the statistical error does not decrease as the security
parameter increases.
De(cid:27)nition A.1. Let F be a n-party functionality, and let π be a
n-party protocol. We say that π securely computes f with abort in
the presence of an adversary controlling t < n2 parties, if for every
non-uniform probabilistic polynomial-time adversary A in the real
world, there exists a non-uniform probabilistic polynomial-time
simulator/adversary S in the ideal model with F , such that for
every I ⊂ {1, . . . , n} with |I| = t,
(cid:8)idealF ,S(z),I(x1, . . . , xn, κ)(cid:9) c≡(cid:8)realπ ,A(z),I(x1, . . . , xn, κ)(cid:9)
where x1, . . . , xn ∈ F∗ under the constraint that |x1| = · · · = |xn|,
z ∈ F∗ and κ ∈ N. We say that π securely computes f with abort
in the presence of one malicious party with statistical error 2−σ if
there exists a negligible function µ(·) such that the distinguishing
probability of the adversary is less than 2−σ + µ(κ).
The hybrid model. We prove the security of our protocols in a
hybrid model, where parties run a protocol with real messages and
also have access to a trusted party computing a subfunctionality for
them. The modular sequential composition theorem of [9] states
that one can replace the trusted party computing the subfunction-
ality with a real secure protocol computing the subfunctionality.
When the subfunctionality is ❕, we say that the protocol works in
the ❕-hybrid model.
Universal Composability [10]. Protocols that are proven secure
in the universal composability framework have the property that
they maintain their security when run in parallel and concurrently
with other secure and insecure protocols. In [29, Theorem 1.5], it
was shown that any protocol that is proven secure with a black-box
non-rewinding simulator and also has the property that the inputs
of all parties are (cid:27)xed before the execution begins (called input
availability or start synchronization in [29]), is also secure under
universal composability. Since the input availability property holds
for all of our protocols and subprotocols, it is su(cid:28)cient to prove
security in the classic stand-alone setting and automatically derive
universal composability from [29]. We remark that this also enables
us to call the protocol and subprotocols that we use in parallel and
concurrently (and not just sequentially), enabling us to achieve
more e(cid:28)cient computation (e.g., by running many executions in
parallel or running each layer of a circuit in parallel).
B PROTOCOLS FOR COMPUTATION BASED
ON SHAMIR’S SECRET SHARING SCHEME
B.1 Protocols For Generating Random Sharings
The PRSS protocol [13]. In this protocol, there is a setup step