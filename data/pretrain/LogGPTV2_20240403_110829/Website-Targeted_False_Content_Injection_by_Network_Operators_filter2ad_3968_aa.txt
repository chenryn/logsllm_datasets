title:Website-Targeted False Content Injection by Network Operators
author:Gabi Nakibly and
Jaime Schcolnik and
Yossi Rubin
Website-Targeted False Content Injection  
by Network Operators
Gabi Nakibly, Rafael—Advanced Defense Systems and Technion—Israel Institute of 
Technology; Jaime Schcolnik, Interdisciplinary Center Herzliya; Yossi Rubin,  
Rafael—Advanced Defense Systems
https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/nakibly 
This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Website-Targeted False Content Injection by Network Operators
Gabi Nakibly1,3, Jaime Schcolnik2, and Yossi Rubin1
1
Rafael – Advanced Defense Systems, Haifa, Israel
2Computer Science Department, Interdisciplinary Center, Herzliya, Israel
3Computer Science Department, Technion, Haifa, Israel
Abstract
It is known that some network operators inject false con-
tent into users’ network trafﬁc. Yet all previous works
that investigate this practice focus on edge ISPs (Internet
Service Providers), namely, those that provide Internet
access to end users. Edge ISPs that inject false content
affect their customers only. However, in this work we
show that not only edge ISPs may inject false content,
but also non-edge network operators. These operators
can potentially alter the trafﬁc of all Internet users who
visit predetermined websites. We expose this practice by
inspecting a large amount of trafﬁc originating from sev-
eral networks. Our study is based on the observation that
the forged trafﬁc is injected in an out-of-band manner:
the network operators do not update the network packets
in-path, but rather send the forged packets without drop-
ping the legitimate ones. This creates a race between the
forged and the legitimate packets as they arrive to the end
user. This race can be identiﬁed and analyzed. Our anal-
ysis shows that the main purpose of content injection is to
increase the network operators’ revenue by inserting ad-
vertisements to websites. Nonetheless, surprisingly, we
have also observed numerous cases of injected malicious
content. We publish representative samples of the injec-
tions to facilitate continued analysis of this practice by
the security community.
1
Introduction
Over the last few years there have been numerous reports
of ISPs that alter or proxy their customers’ trafﬁc, includ-
ing, for example, CMA Communications in 2013 [7],
Comcast in 2012 [19], Mediacom in 2011 [10], WOW!
in 2008 [31], and Rogers in 2007 [36]. Moreover, several
extensive studies have brought the details of this practice
to light [20, 34, 28, 39]. The main motivations of ISPs to
alter trafﬁc are to facilitate caching, inject advertisements
into DNS and HTTP error messages, and compress or
transcode content.
All of these reports and studies found that these traf-
ﬁc alterations were carried out exclusively by edge ISPs,
namely, retail ISPs that sell Internet access directly to end
customers, and are their “ﬁrst hop” to the Internet. This
ﬁnding stems from the server-centric approach the above
studies have taken. In this approach, one or a handful of
servers are deployed to deliver speciﬁc content to users,
after which a large number of clients are solicited to fetch
that content from the servers. Finally, an agent on the
clients – usually a JavaScript delivered by the server it-
self – looks for deviations between the content delivered
by the server and that displayed to the user. Figure 1(a)
illustrates the trafﬁc monitored in this server-centric ap-
proach.
Such an approach can be used to inspect the trafﬁc of
many clients from diverse geographies who are served
by different edge ISPs. The main disadvantage of this
approach is that the content fetched by the clients is very
speciﬁc. All clients fetch the same content from the same
web servers. This allows only the detection of network
entities that aim to modify all of the Internet trafﬁc1 of
a predetermined set of users and are generally oblivious
to the actual content delivered to the user. Such entities
indeed tend to be edge ISPs that target only the trafﬁc of
their customers.
In this work we show that the above approach misses
a substantial portion of the on-path entities that modify
trafﬁc on the Internet. Using extensive observations over
a period of several weeks, we analyzed petabits of In-
ternet trafﬁc carrying varied content delivered by servers
having over 1.5 million distinct IP addresses. We newly
reveal several network operators that modify trafﬁc not
limited to a speciﬁc set of users. Such network operators
alter Internet trafﬁc on the basis of its content, primarily
by the website a user visits. The trafﬁc of every Internet
1In some cases these network entities modify all internet trafﬁc orig-
inating from very popular websites such as google.com, apple.com,
and bing.com or all Internet trafﬁc originating from .com.
USENIX Association  
25th USENIX Security Symposium  227
1
server
monitor
server
server
server
server
monitor
clients
clients
(a) Depiction of monitored trafﬁc in the server-centric
approach (of past works). One server with speciﬁc
content serves many clients in many edge networks.
(b) Depiction of monitored trafﬁc in the client-centric ap-
proach (of the current work). Many servers with varied con-
tent serve many clients in a few edge networks.
Figure 1: Server-centric approach versus client-centric approach to monitoring trafﬁc. The lines between clients and
servers illustrate the monitored trafﬁc.
forged packet
valid packet
client
middle-box
server
(a) In-band alteration of packet by a middle-box. Only a
single packet arrives at the client.
valid packet
tap
client
server
forged packet
injector
(b) Out-of-band injection of a forged packet. Two packets
arrive at the client.
Figure 2: In-band versus out-of-band alteration of con-
tent
user that traverses these network operators is susceptible
to alteration. This is in contrast to the case of edge ISPs
that alter the trafﬁc of their customers only. Although a
primary focus of these network operators is to inject ad-
vertisements into web pages, we also identiﬁed injections
of malicious content.
Our analysis is based on the observation that network
operators alter packets out-of-band: all trafﬁc is pas-
sively monitored, and when the content of a packet needs
to be altered, a forged packet is injected into the connec-
tion between the server and the client. The forged packet
poses as the valid packet.
If the forged packet arrives
at the client before the valid one, the client will accept
the forged packet and discard the valid one. Such an ap-
proach has considerable advantages to the network oper-
ators since it does not introduce new points of failure to
their trafﬁc processing and there is no potential for a per-
formance bottleneck. Figure 2 illustrates the differences
between in-band alteration of trafﬁc and out-of-band al-
teration. Note that both in-band and out-of-band traf-
ﬁc alteration is possible only on unprotected trafﬁc, e.g.,
trafﬁc that is not carried by TLS [12] or authenticated
using TCP authentication [32].
The out-of-band operation has a crucial characteristic
that enables our analysis: the client receives two pack-
ets – the forged one and the valid one – that claim to be
the same response from the server. However, they carry
different content. This characteristic allows us to detect
trafﬁc alteration events while monitoring the trafﬁc at the
edge network. We can thus monitor and analyze trafﬁc in
a client-centric manner in which the trafﬁc is not destined
to a speciﬁc set of servers but to all servers contacted by
the users at the edge network. Figure 1(b) illustrates the
trafﬁc monitored in our work. In this paper we speciﬁ-
cally focus our analysis on alteration of web trafﬁc, i.e.,
HTTP trafﬁc over port 80.
An example of out-of-band injection To illustrate
how content is altered using out-of-band injection, we
describe in the following one of the injections we iden-
tiﬁed during our observations.
In this example the
user’s browser sends the following HTTP GET request to
cnzz.com (a Chinese company that collects users’ statis-
tics):
GET /core.php?show=pic&t=z HTTP/1.1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
Host: c.cnzz.com
Accept-Encoding: gzip
Referer: http://tfkp.com/
In response the user receives two TCP segments having
the same value in the sequence number ﬁeld. The seg-
ments include different HTTP responses. One segment
228  25th USENIX Security Symposium 
USENIX Association
2
carries the legitimate HTTP response that includes the
requested resource (a JavaScript code) from cnzz.com:
3. Thorough analysis of the characteristics of the in-
jections and the purpose of the injecting operators.
HTTP/1.1 200 OK
Server: Tengine
Content-Type: application/javascript
Content-Length: 762
Connection: keep-alive
Date: Tue, 07 Jul 2015 04:54:08 GMT
Last-Modified: Tue, 07 Jul 2015 04:54:08 GMT
Expires: Tue, 07 Jul 2015 05:09:08 GMT
!function(){var p,q,r,a=encodeURIComponent,c=...
The other segment includes a forged response that di-
rects the user via a 302 status code to a different URL
that points to a different JavaScript code:
HTTP/1.1 302 Found
Connection: close
Content-Length: 0
Location: http://adcpc.899j.com/google/google.js
Our analysis shows that this JavaScript redirects the user
through a series of afﬁliate ad networks ending with
Google’s ad network, which serves the user an ad. In this
injection event the forged segment arrived before the le-
gitimate one, which means that the user sees the injected
ad instead of the original content.
Relation to censorship Website-targeted false content
injection is similar in some ways to content blocking for
the purpose of state-sponsored censorship. There is a
substantial body of work that studies the mechanisms and
characteristics of censorship worldwide [33, 37, 22, 9].
In many cases this blocking of content is also website-
targeted. Moreover, blocking is often done by injecting
false trafﬁc segments, which in some cases is done out-
of-band [33, 11, 8]. In contrast to previous works on cen-
sorship, in this work we study the practice of false con-
tent injection by commercial network operators, rather
than state entities. Such injections primarily serve ﬁnan-
cial gains rather than political agenda, with the goal of
altering the web content rather than blocking it. In this
work we study and analyze the practice of ﬁnancially-
motivated false content injection by network operators.
In Section 7 we discuss in more detail related work on
censorship. During this work we observed numerous oc-
currences of censorship-aimed injections. We do not re-
port on them in this paper.
Our contributions can be summarized as follows:
1. The observation that network operators inject false
web content out-of-band.
2. Investigation of the identities of network operators
that practice website-targeted content injection.
The paper’s structure is as follows. In Section 2 we
present technical background pertaining to injection of
forged TCP and HTTP packets. Section 3 details our
methodology for monitoring web trafﬁc and identifying
injections of forged packets. Section 4 details the sources
of trafﬁc we monitored. In Section 5 we present our anal-
ysis of the injection events and our investigation as to the
identities of the network operators behind them. Sec-
tion 6 proposes effective and efﬁcient client-side miti-
gation measures. Section 7 discusses related work and
Section 8 concludes the paper.
2 Background
2.1 Out-of-band TCP Injection
A TCP [27] connection between two end nodes offers
reliable and ordered delivery of byte streams. To facili-
tate this service, every sent byte is designated a sequence
number. Each TCP segment carries a Sequence Number
ﬁeld that indicates the sequence number of the ﬁrst data
byte carried by the segment. The following data bytes in
the segment are numbered consecutively. A third party
that wishes to send a forged TCP segment as part of an
existing TCP connection must correctly set the connec-
tion’s 4-tuple in the IP and TCP header, i.e., the source’s
port number and IP address as well as those of the des-
tination. In addition, for the forged segment to be fully
accepted by the receiver, the sequence numbers of the
forged data bytes must fully reside within the receiver’s
TCP window. Forging such a TCP segment is trivial for
an on-path third party, since it can eavesdrop on the valid
segments of the connection and discover the 4-tuple of
the connection as well as the valid sequence number.
In some circumstances an injected TCP segment may
trigger an undesirable “Ack storm”. An “Ack storm” oc-
curs when the injected segment causes the receiver to
send an acknowledgment for data bytes having sequence
numbers that were not yet sent by the peer. Appendix A
details how an “Ack storm” is formed. Nonetheless, as
long as the injecting third party ensures that the injected
TCP segment is no larger than the valid TCP segment
sent by the peer, no “ACK storm” will be triggered. If
this is not the case, the injector could send a TCP re-
set right after the injection in order to forcibly close the
connection. This will also eliminate the possibility of
an “Ack storm”. The latter option is used only if the
connection is expected to close right after the valid re-
sponse is received. Indeed, in all our observations either
of these alternatives took place and no “Ack storms” were
observed.
USENIX Association  
25th USENIX Security Symposium  229
3
Nonetheless, the fact that the injected TCP segment
aims to displace an already sent or soon to be sent valid
TCP segment poses a different obstacle for the inject-
ing third party. According to the TCP speciﬁcation [27],
the ﬁrst data byte received for a given sequence num-
ber is accepted. A subsequent data byte having the same
sequence number is always discarded as a duplicate re-
gardless of its value. Thus, the injected segment must
arrive at the receiver before the valid TCP segment in or-
der to be accepted. Note that the TCP speciﬁcation does
not consider the receipt of bytes with duplicate sequence
numbers as an error but rather as a superﬂuous retrans-
mission.
2.2 HTTP Injection
In this work we focus in particular on the injection of
false HTTP responses received by a web client. HTTP
[15] is a stateless client-server protocol that uses TCP
as its transport. An HTTP exchange begins by a client
sending an HTTP request, usually to retrieve a resource
indicated by a URI included in the request. After pro-
cessing the request the server sends an HTTP response
with a status code. The status codes we later refer to in
this paper are:
• 200 (Successful): The request was successfully re-
ceived, understood, and accepted. Responses of this
type will usually contain the requested resource.
• 302 (Redirection): The requested resource resides
temporarily under a different URI. Responses of
this type include a Location header ﬁeld containing
the different URI.
An HTTP client will receive only one HTTP response
for a given request even when a false HTTP response
is injected because, as mentioned above, the TCP layer
will only accept the ﬁrst segment that it receives (be it
the false or the valid segment). When the forged re-
sponse is shorter than and arrived before the valid re-
sponse, the client then receives the byte stream that in-
cludes the forged response, followed by the tail of the
valid response. The tail includes the data bytes having
sequence numbers that immediately follow those of the
forged response. By default, the response message body
length is determined by the number of bytes received un-
til the TCP connection is closed. This might be a prob-
lem for the injecting entity as the client will eventually
receive a mixed HTTP response, which might yield un-
intended consequences. To avoid this problem, the in-
jected response will usually include Content-Length or
Transfer-Encoding headers that explicitly determine the
end of the response. Thus, even if the TCP layer delivers
the tail of the valid response to the HTTP layer, it will
not be processed by the client.
traffic
source
  Capture 
Traffic 
pcap files queue 
Worker 
process 
 Dispatcher 
processes 
packets 
Worker 
process 
Worker 
process 
Figure 3: Depiction of the design of the monitoring sys-
tem
3 Methodology
We now describe our methodology for collection and
identiﬁcation of TCP injection events.
3.1 Monitoring System
At the core of the collection of injection events was a
monitoring system that eavesdropped on Internet trafﬁc
and identiﬁed these events. The monitoring system was
deployed at the entry points of large networks (detailed
in Section 4) and analyzed the bidirectional trafﬁc that
ﬂowed in and out of those networks. The monitoring
system was comprised of the following three stages (de-
picted in Figure 3). First, we captured the trafﬁc using
the ’netsniff-ng’ tool [3] along with a Berkeley packet
ﬁlter [25] to capture only HTTP trafﬁc. The tool itera-
tively produced ﬁles comprising 200,000 packets each.
These ﬁles were fed into a queue for processing by the
next stage. To avoid explosion of the queue when the
trafﬁc rate exceeded the throughput of the next stages,
the queue’s length was bounded. Once the queue reached
its limit, the capturing process was halted until the queue
length decreased.
At the next stage each capture ﬁle was processed by
a dispatcher process that read each packet in the ﬁle, re-
moved the Ethernet header, and computed a hash on the
IP addresses and TCP ports in such a way that packets
of the same TCP session would have the same hash re-
sult. A packet’s hash result was then used to choose one
of several worker processes to handle that packet. In this
way all packets of the same session were delivered to the
same worker.
At the ﬁnal stage each worker process grouped the
packets it received into TCP sessions and stored each
session in a data structure. For each received packet a
worker checked all the packets of that session to deter-
mine whether the conditions for a packet race were met
(the conditions are detailed in Section 3.2). If so, the last
30 packets of the session were written to a ﬁle, includ-
ing their payload, for later analysis. See Section 3.3 for
the ethics and privacy issues pertaining to the storage and
analysis of packets.
The packet sessions were stored by each worker in a
230  25th USENIX Security Symposium 
USENIX Association
4
data structure that is a least-recently-used cache with a
ﬁxed size. Once the cache reached the maximum num-
ber of sessions it can store, the session that was idle the
longest was evicted from the cache. To simplify packet
processing we did not use TCP signaling (SYN and FIN
ﬂags) to create a new session in the cache or evict an
existing one. This design choice gave rise to the possi-
bility that a session would be evicted even if still active.
Nonetheless, as our experiments show, the caches were
large enough so that the minimum idle time after which
a session was evicted did not drop below 10 minutes —
long enough to make the occurrences of active session
evictions negligible. Note that even if such an eviction
were to occur, packet races could still be detected in that