最后，我们还必须能够处理表示温度制式的小写字母。简单的办法是直接把小写字母添加
到字符组中，[CFcf]。不过，我更愿意使用另一种办法：
$input =~m/~([-+]?[0-9]+(\.[0-9]*)?)\s*([CF]）S
添加的这个i称作“修饰符（modifier)”，把它放在m/…/结构之后，告诉Perl进行不区分
大小写的匹配。修饰符其实不是正则表达式的一部分，而是m/…/结构的一部分，这个结构
告诉Perl使用者的意图（应用一个正则表达式），以及采用的正则表达式（在斜线之间的部
分)。我们曾看到过这种功能，即egrep的-i参数（r15)。
法并不是“/i”。/i只是在Perl中指定修饰符的办法之一-一在下一章，我们会看到其他
的办法，以及其他语言实现此功能的写法。在本章后面的部分，我们还会看到其他的修饰
符，例如/g（表示“全局匹配（globalmatch）"）以及/x（表示“宽松排列的表达式（free-form
expressions)")。
现在，我们已经做了不少修改了，来看看新的程序：
perl -w convert
Enter a temperature（e.g.,32F,100C):
32 f
0.00 C is 32.00 F
perl-wconvert
Enter a temperature （e.g.,32F,100C):
50c
10.00 C is 50.00 F
哎呀！你是否注意到了，第二次运行时我们输入的是摄氏50度，结果被认成了华氏50度？
看看程序的逻辑，你找出向题了吗？
---
## Page 74
48
第2章：入门示例拓展
再来看程序的片段：
if ($input =~ m/^[-+]?[0-9]+(\.[0-9]*)?)\s*([CF])S/i)
StyDe=S3：#把数据保存到以命名的变量，让程序更易懂
if（Stypeeq"C"）（#‘eq'测试两个字将串是否相等
)else{
虽然我们的正则表达式能够接受小写的f，程序的其他部分却没有相应的修改。在这个程序
里，只有stype是‘c’的时候，才作为摄氏度处理。因为程序同样可以接受小写的c，我
们需要修改stype的判断：
if （$type eq*C"or Stype eq*c"）{
实际上，因为本书是关于正则表达式的，我或许这样做：
if ($type =~m/c/i）{
现在，大小写的情况都能应付了。最终的程序如下所示。这个例子告诉我们，正则表达式
的使用方式，可能会影响到程序的其他部分。
示例2-2：温度转换程序-—最终版本
print “Enter a temperature （e.g.,32F,100c):\n*;
$input = ;
#接收用户输入的一行文本
chomp($input）;
去掉Sinput末尾的换行
if （$input =~m/~([-+]?[0-9]+(\.[0-9]*）?)\s*([CF]）$/i)
{
#如果运行到此，则已经匹配，S1保存数值，S3保存C或者F
SInputNum=S1；#把数据保存到已命名的变量
stype
=S3；#.保证程序的可读性
if （$type =~m/c/i）(#Is it"c"or"C"？
#输入的是氏温度，计算华氏温度
Scelsius = $InputNum;
$fahrenheit=（$celsius*9/5）+32;
)else{
#如果不是"C”，则必定是"F”，所以计算摄氏温度
Sfahrenheit = $InputNum;
Scelsius=（$fahrenheit-32)*5/9;
#现在两个值都有了，输出结果：
printf "$.2fC is .2f F\n",$celsius,$fahrenheit;
)else（
开始的表达式无法匹配、发出警报
print“Expectinganumber followed by\*C\or\*F\*,\n*;
print“so Idon'tunderstand\"$input\".\n*;
---
## Page 75
使用正则表达式匹配文本
49
暂停片刻
Itermission
尽管本章的大部分篇幅是关于熟悉Perl的，但也遇到了许多新的关于正则表达式的知识。
1.许多工具都有自己的正则表达式流派。Perl和egrep可能属于同一个流派，但是Perl的
正则表达式中的元字符更多。许多其他的语言，类似Java、Python、.NET和TCL，它们
的流派类似Perl。
2.Perl用svariable=~m/regex/来判断一个正则表达式是否能匹配某个字符串。m表示“匹
配（match）”，而斜线用来标注正则表达式的边界（它们本身不属于正则表达式）。整个
测试语句作为一个单元，返回true或者false值。
3.元字符—具有特殊意义的字符一—的定义在正则表达式中并不是统一的。之前在关于
shell和双引号引用的字符事的例子中我们讲过，元字符的含义取决于具体的情况。了解
具体情况（shell、正则表达式、字符事），其中的元字符及其作用，对学习和使用Perl、
PHP、Java、Tcl、GNUEmacs、awk、Python或其他高级语言是非常重要的（当然，在
正则表达式内部，学符组有自已的“子语言”，其中的元字符是不同的）。
4.Perl和其他流派的正则表达式提供了许多有用的简记法（shorthands）：
IC制表符
n换行符
r回车符
\S任何“空白”字符（例如空格符、制表符、进纸符等）
\S除\SI之外的任何字持
\w[a-ZA-Z0-9）1（在\w+j中很有用，可以用来匹配一个单词）
\W除\w之外的任何字符，也就是[^a-zA-Z0-9]
\d[0-9]，即数字
\D除\d外的任何字符，即[^0-9]
5./i修饰符表示此测试不区分大小写。尽管写法是“/i”，其实“i”只是跟在表示结尾的
斜线之后。
6.（？：）这个麻烦的写法可以用来分组文本，但并不捕获。
7.匹配成功之后，Perl可以用s1、$2、$3之类的变量来保存相对应的（)括号内的子表
达式匹配的文本。使用这些变量，我们能够用正则表达式从字符串中提取信息（其他的
语言所使用的方式有所不同，我们会在下一章看到例子)。
---
## Page 76
50
第2章：入门示例拓展
子表达式的编号按照开括号的出现先后排序，从1开始。子表达式可以嵌套，例如
(Washington（·DC)?)”。如果只是希望分组，也可以使用（.)，但副作用是，它们捕
获的文本仍然会保存到特殊的变量中。
使用正则表达式修改文本
ModifyingTextwitlhRegular Expressions
到现在，我们遇到的例子都只是从字符串中“提取”信息。现在我们来看Perl和其他许多
语言提供的一个正则表达式特性：警换（substitution，也可以叫“查找和誉换（searchand
replace)")。
我们已经看到，$var~m/regex/尝试用正则表达式来匹配保存在变量中的文本，并返回
表示能否匹配的布尔值。与之类似的结构svar=~B/regex/replacement/则更进一步：如果正
则表达式能够匹配Svar中的某段文本，则将这段匹配的文本替换为replacemenr。其中regex
与之前m/./的用法一样，而replacement（位于第二个和第三个斜线之间）则是作为双引l号
内的字符串。这就是说，在其中可以使用变量一—例如$1、S2-—来引用之前匹配的具体
文本。
所以，使用svar=~B//…/可以改变Svar中的文本（如果没有找到匹配的文本，也就不
会有替换发生)。例如，如果svar包括Jeff·Friedl，运行：
Svar=~s/Jeff/Jeffrey/;
Svar的值就变成Jeffery·Friedl。如果再运行一次，就得到Jeffreyrey·Friedl。要避
免这种情况，也许我们需要添加表示单词分界的元字符。在第1章我们提到过，某些版本
字符八bi来代表这两者：
$var=~s/\bJeff\b/Jeffrey/;
这里有个小测验：与m/…/一样，s/…/…/也可以使用修饰符，例如第47页介绍的/i（将
这个修饰符放在replacement之后）。那么，这个表达式：
$var =~s/\bJeff\b/Jeff/1;
的功能是什么呢？请翻到下页查看答案。
例子：公函生成程序
Example:FormLetter
下面这个有趣的例子展示了文本替换的用途。设想有一个公函系统，它包含很多公函模板，
其中有一些标记，对每一封具体的公函来说，标记部分的值都有所不同。
---
## Page 77
使用正则表达式修改文本
51
这里有一个例子：
Dear =FIRST=,
You have been chosen to win a brand new =TRINKET=! Free!
Could you use another =TRINKET= in the =FAMILY= household?
Yes =SUcKER=,I bet you could!Just respond by.
对特定的接收人，变量的值分别为：
Sgiven ="Tom";
Sfamily ="Cruise*;
Swunderprize =*1o0$ genuine faux diamond";
准备好之后，就可以用下面的语句“填写模板”：
$letter =~s/=FIRST=/$given/g;
$letter =~ s/=FAMILY=/$family/g;
$letter =~s/=SUcKER=/$given $family/g;
$letter =~s/=TRINKET=/fabulous $wunderprize/g;
其中的每个正则表达式首先搜索简单标记，找到之后用指定的文本替换它。用于替换的文
本其实是Perl中的字符串，所以它们能够引用变量，就像上面的程序那样。例如，
Swunderprize”。如果只需要生成一份公函，完全可以不用变量替换，直接照需要的样子
生成就是。但是，使用变量替换能够实现自动化的操作，例如可以从一个清单读入信息。
我们还没介绍过/g“全局替换”（globalreplacement）的修饰符。它告诉s/./../在第次
替换完成之后继续搜索更多的匹配文本，进行更多的替换。如果需要检查的字符串包含多
行需要替换的文本，每条替换规则都对所有行生效，我们就必须使用/g。
结果是可以预见的，不过相当有趣：
Dear Tom,
Youhave been chosen to win a brand newfabulous 1oo$ genuine faux diamond!
Free!Couldyou use another fabulous1oosgenuinefauxdiamondin the Cruise
household?Yes Tom Cruise,I bet you could!Just respond by...
举例：修整股票价格
Example:PrettifyingaStockPrice
另一个例子是，我在使用Perl编写的股票价格软件时遇到的问题。我得到的价格看起来是
这样“9.0500000037272”。这里的价格显然应该是9.05，但是因为计算机内部表示浮点
的原理，Per有时会以没什么用的格式输出这样的结果。我们可以像温度转换例子中的那样
---
## Page 78
52
第2章：入门示例拓展
测验答案
50页的测验的答案
$var=~8/\bJeff\b/Jeff/1实现了什么功能？
这个问题可能让你困惑。如果前面的正则表达式用bJEFF\bi或者bjeff\bi或者是
bjEfF\b可能看得更清楚。因为/i的存在，搜索“Jef”这个词是不区分大小写的。
replacement的文本没有影响，不过第7章讨论的某些修饰符不是如此)。
结果就是，“jeff”这个单词，无论大小写的情况如何，都会被替换为“Jeff”。
用printf来保证只输出两位小数，但是此处并不适用。当时，股价仍然是以分数的形式给
出的，如果某个价格以1/8结尾，则应该输出3位小数（".125"），而不是两位。
我把自己的要求归结为：通常是保留小数点后两位数字，如果第三位不为零，也需要保留，
被修正为“37.50”。这就是我要的结果。
那么，我们该如何做呢？Sprice变量包含了需要修正字符事，让我们用这个表达式：
Sprice =~s/(\.\d\d[1-9]?)\d*/$1/
（提示：49页介绍了d这个元字符，它用来匹配一个数字字符。）
最开始的.匹配小数点。接下来的d\d匹配开头的两位数字。[1-9]？匹配可能跟在后
面的非零数字。到这里，任何匹配的文本都是我们希望保留的，所以我们用括号把它保存
到s1中。然后将s1放入replacement字符事中。如果能够匹配的文本就是S1，我们就用s1
替换S1一这样做没什么意义。但如果在$1的括号之外还有能够匹配的字符，因为它们没
有出现在replacement字符串中，所以会被删除。也就是说，“被删除的”文本是其他多余的
数字，也就是正则表达式末尾八d*匹配的字符。
请记住这个例子，在第4章我们会学习匹配过程背后的重要原理，那时候还会遇到这个例
子。研究它可以学到非常有价值的知识。
Q
---
## Page 79
使用正则表达式修改文本
53
自动的编辑操作
Automated Editing
写作本章时，我遇到了另-个简单但真实存在的例子。当时我需要登录到太平洋对岸的一
台机器上，但是网速非常慢。按下回车得等一分多钟才能见到反应，而我只需要对某个文
件进行一些小的改动，运行一个重要的程序。实际上，我要做的只是将出现的所有sysread
改为read。改动的次数并不多，但因为网络太慢，使用全屏编辑器显然是不可能的。
下面是我的办法：
这条命令中的Perl程序是8/Byeread/read/g（是的，这就是一个完整的Perl程序-一参
数-e表示整个程序接在命令的后面)。参数-p表示对目标文件的每一行进行查找和替换，
而-i表示将替换的结果写回到文件。
请注意，这里没有明确写出查找和替换的目标字符串（就是说，没有$var~.），因为-p
参数就表示对目标文件的每行文本应用这段程序。同样，因为我用了/g这个修饰符，就可
以保证在一行文本中可以进行多次替换。
尽管在这里我只是对一个文件进行操作，但也很容易在命令行中列出多个文件，而Perl会
把替换命令应用到每个文件的每一行文字。这样，只需要一条简单的命令，我就能够编辑
大量的文件。这样简单的编辑方式是Per独有的，但这个例子告诉我们，即使执行的是简
单的任务，作为脚本语言一部分的正则表达式的功能仍然非常强大。
处理邮件的小工具
A Small Moil Lltility
来看另一个小工具的例子。一个文件中保存着E-mail信息，我们需要生成一个用于回复的
文件。在准备过程中，我们需要引用原始的信息，这样就能很容易地把回复插入各个部分。
在生成回复邮件的header时，我们还需要删除原始信息邮件的header中不需要的行。
下一页的补充内容是一个邮件文件的范本。header包含了我们关心的字段：日期、主题等
一但也包括了我们不关注的字段，这些字段需要删除。如果我们的脚本程序叫做mkreply，
而原始的信息保留在king.in中，我们会用下面的命令来生成回复模板：
perl-wmkreplyking.in>king.out
（-w它用来打开Perl的额外警告功能，·38）
---
## Page 80
54
第2章：入门示例拓展
E-mailMessage范本
From elvis Thu Feb 29 11:15 2007
Received: from elvis@localhost by tabloid.org (8.11.3) id KA8CMY
Received: from tabloid.org by gateway.net (8.12.5/2) id N8xBK