Your site here 
LOGO 
移动APP风险防护与安全测评 
Android平台 
Your site here 
LOGO 
移动APP风险防护 
 前言 
 APP面临的安全威胁 
 APP加固 
 APP原理 
 APP反编译保护 
 APP反汇编保护 
 APP防篡改保护 
 APP防调试与注入保护 
 APP脱壳攻击测试 
Your site here 
LOGO 
前言 
Android开发者常常面临的一个问题就是防破解、
防二次打包。现如今，安全问题越来越重要，越来越多
的Android开发者也开始寻求安全的保护方案。 
Your site here 
LOGO 
APP面临的安全威胁 
盗版、数据篡改、山寨 
Your site here 
LOGO 
APP面临的安全威胁 – 盗版 
 代码修改(广告植入、移除) 
 资源修改(界面替换广告页面、链接篡改) 
 破解(解除应用付费) 
 篡改应用数据(游戏金币篡改) 
 挂马、添加恶意代码以及病毒(隐私窃取、交易篡改
等) 
Your site here 
LOGO 
APP面临的安全威胁 – 数据篡改 
 动态注入:数据监听、拦截、窃取、修改 
 本地数据修改、数据库文件修改 
 服务器欺骗、向服务器发送假数据 
Your site here 
LOGO 
APP面临的安全威胁 – 山寨 
 应用名称复制或模仿 
 应用图标复制或模仿 
 应用内容复制或模仿 
Your site here 
LOGO 
APP风险防护技术 – 加固 
为了加强APP安全性，越来越多的开发者选择APP加固方案对
APP进行加固保护来防止二次打包（盗版）、数据篡改等风险 
APP加固基本服务： 
 防止逆向分析 
加密app代码，阻止反编译 
 防止二次打包 
对app完整性校验保护，防止盗版 
 防止调试及注入 
阻止动态调试注入，防止外挂、木马窃取账号密码，修改交易金额等 
 防止应用数据窃取 
加密应用敏感数据，防止泄漏 
 防止木马病毒 
监测设备环境，防止木马、病毒、恶意应用或钓鱼攻击 
Your site here 
LOGO 
APP加固厂商介绍 
目前国内App加固厂商较多，其中以专业从事加固为主打产品
的厂商有:爱加密、娜迦(nagain) 、梆梆、通付盾等 
Your site here 
LOGO 
APP加固技术原理以及发展现状 
目前加固技术主要分为一代和二代 
一代(1.0)加固方案 
1.0的方案是基于类加载的技术，原理:对classes.dex文件进
行完整加密，另存为文件放入资源文件中，通过壳代码(壳dex)进
行载入并解密运行 
二代(2.0)加固方案 
2.0的方案是基于方法替换方式，原理:将原dex中的所有方法
的代码提取出来进行加密，运行时动态劫持Dalvik虚拟机中解析
方法的代码，将解密后的代码交给虚拟机执行引擎 
Your site here 
LOGO 
各厂商APP加固技术 
加固技术 
加固原理 
加固厂商 
类加载技术
(1.0) 
对原classes.dex文件进行完整加
密，另存为文件放入资源文件中，
通过壳代码(壳dex)进行载入并解
密运行 
娜迦、爱加
密、梆梆、
网秦等 
对原dex文件整体压缩加密，保存
在壳代理的dex文件尾部，加载到
内存中解密运行 
360 
方法替换技
术(2.0) 
将原classes.dex中的所有方法的
代码提取出来，单独加密,运行时动
态劫持Dalvik虚拟机中解析方法的
代码，将解密后的代码交给虚拟机
执行引擎 
娜迦、梆梆 
Your site here 
LOGO 
各厂商APP加固识别 
各加固厂商采用的加固保护核心库大致如下（存放在lib目录或
assets目录） 
加固厂商 
加固保护核心库 
娜迦 
1.0(libchaosvmp.so)、2.0(libddog.so、libfdog.so) 
爱加密 
libexec.so、libexecmain.so 
梆梆 
1.0(libsecexe.so、libsecmain.so)2.0(libDexHelper.so) 
360 
libprotectClass.so、libjiagu.so 
通付盾 
libegis.so 
网秦 
libnqshield.so 
百度 
libbaiduprotect.so 
腾讯 
libtup.so 
阿里 
libmobisec.so 
Your site here 
LOGO 
APP加固必要性 
Android平台应用采用Java语言进行开发，由于
Java语言很容易被反编译，反编译后的代码接近源代
码的级别，易读性极高。容易暴露客户端的所有逻辑，
比如与服务端的通讯方式，加解密算法、密钥，转账业
务流程、软键盘技术实现等等。 因此很有必要对Java
代码进行加密保护，即采用加固方案。 
Your site here 
LOGO 
APP加固 – 反编译保护 
JAVA层保护 
Android平台采用使用Java作为原生语言进行开发。在最终的安装包中，
所有的java代码编译并打包到APK中的classes.dex文件中，java代码的
保护的目标就是classes.dex。 
1.0类加载加固技术原理 
对原classes.dex文件进行完整加密，另存为文件放入资源文件中，通过
壳代码(壳dex)进行载入并解密运行 
2.0方法替换加固技术原理 
将原classes.dex中的所有方法的代码提取出来，单独加密，运行时动态
劫持Dalvik虚拟机中解析方法的代码，将解密后的代码交给虚拟机执行引
擎 
实例:某加固应用 
反编译工具:dex2jar(ApkToolkit) jd-gui 等 
反编译结果:无法获取到原dex代码或完整的dex代码 
Your site here 
LOGO 
APP加固 – 反编译保护案例 
Your site here 
LOGO 
APP加固 – 反汇编保护一 
Native层保护 
SO库是采用C/C++语言开发的动态库。SO库的逆向要求攻击者需
要有一定的汇编语言基础，相比Java的反编译，逆向分析的难度更高。 
反汇编原理: 
SO库的加密保护技术与PC领域的加壳技术类似。加壳技术是指利用
特殊的算法，将可执行程序文件或动态链接库文件的编码进行改变，以达
到加密程序编码的目的, 阻止反汇编工具如IDA等的逆向分析 
So加壳技术， 
对SO库中的汇编代码加密保护 
ELF数据信息的隐藏 
对SO库中的动态定位信息，函数地址信息，符号表等ELF数据信息做    
清除隐射隐藏保护。 
Your site here 
LOGO 
APP加固 – 反汇编保护二 
So文件的整体加密 
使用自定义链接器的技术，对SO文件进行整体的加密，完全阻止
IDA等逆向工具的静态分析。 
  代码运行态动态清除 
     解密代码动态清除的技术，防止运行时内存存在完整的解密后代码。 
 AOP技术 
     自实现linker、自定义so文件格式，完全阻止IDA等反汇编工具与内
存dump。 
实例:某加固应用 
 So反汇编工具:IDA 
 反汇编方法:使用IDA打开SO库文件，查看反汇编arm汇编代码 
 反汇编结果:无法正常分析 
Your site here 
LOGO 
APP加固 – 反汇编之AOP技术 
  So采用AOP技术加壳后，已不是一个正常的ELF格式文件，如下图，
IDA无法反汇编分析，也无法采用内存dump方式进行脱壳 
Your site here 
LOGO 
APP加固 – 防篡改保护 
客户端篡改是指对App添加或修改代码，修改资源文件，配置信息，
图标等，重新编译签名为新的APP，可能添加病毒代码、广告SDk，推广
自己的产品；添加恶意代码窃取登录账号密码、支付密码、拦截验证码短
信，修改转账目标账号、金额等等。 
防篡改原理: 
App加固保护后，对加固后的安装包的任何修改，包括代码，资源文
件，配置文件等，运行时非法篡改的客户端将被检测到并终止运行。 
防篡改的技术原理是采用完整性校验技术对安装包自身进行校验，校
验的对象包括原包中所有文件(代码、资源文件、配置文件等)，一旦校验
失败，即认为客户端为非法客户端并阻止运行。 
实例:某加固应用 
APK篡改工具:APK改之理,AndrlidKiller 
防篡改结果:篡改后无法正常运行 
Your site here 
LOGO 
APP加固 – 反动态调试保护 
动态调试攻击指攻击者利用调试器跟踪目标程序运行，查看、修改内
存代码和数据，分析程序逻辑，进行攻击和破解等行为。对于各行业应用
客户端，该风险可修改客户端业务操作时的数据，比如账号、金额等。逆
向分析用户敏感数据，如登录密码、交易密码等 
反调试保护原理: 
阻止附加调试 
通过双向ptrace保护技术，阻止其他进程对本进程进行ptrace操作 
进程调试状态检查 
通过轮询方式，检测进程的状态是否处于调试状态 
信号处理机制 
利用Linux信号机制，检测进程的状态是否处于调试状态 
实例:某加固应用 
动态调试工具:IDA  
动态调试方法:附加应用进程调试, 调试模式启动进程 
调试结果:无法正常动态调试 
Your site here 
LOGO 
APP加固 – 反动态注入保护 
由于Android平台没有禁止用于调试的 ptrace 系统调用， 恶意程序
在拿到root权限的情况下, 可以使用这个 API 对目标进程的内存、寄存器
进行修改,以达到执行 shellcode、注入恶意模块的目的。在注入恶意模
块后，恶意模块就可以动态地获取内存中的各种敏感信息，例如用户的用
户名、密码等。 
反注入原理: 
阻止ptrace注入行为 
通过双向ptrace保护技术，阻止其他注入行为对本进程进行注入操作 
实例: 某加固应用 
注入工具:inject libhooktest.so 
注入方法:获取目标进程名，编译inject ， push注入工具至手机或
模拟器，赋于inject执行权限，运行 
注入结果:无法注入 
Your site here 
LOGO 