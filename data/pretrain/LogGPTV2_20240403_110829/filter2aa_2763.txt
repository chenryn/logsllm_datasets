#BHUSA   @BlackHatEvents 
Crashing Your Way to 
Medium-IL: Exploiting the PDB 
Parser for Privilege Escalation
Gal De Leon (@galdeleon)
Palo Alto Networks
Who am I?
●
Gal De Leon (@galdeleon)
●
Principal security researcher at Palo Alto Networks
●
Interested in fuzzing, vulnerabilities, exploits and mitigations
●
Microsoft MSRC MVSR 2018, 2019, 2020
○
~40 vulnerabilities
2
Agenda
●
What are PDBs?
●
Finding vulnerabilities in PDB parser
●
Attack surfaces
●
Exploit & Demo
3
●
Store debugging info (symbols) about an executable
●
Function names, globals, type info …
●
Created from source ﬁles during build
●
Used by debuggers
What are PDB Files?
4
0:007> .reload /f notepad.exe
0:007> x notepad!*
00007ff7`9b4c4520 notepad!__scrt_uninitialize_thread_safe_statics (void)
00007ff7`9b4a86b0 notepad!ShowOpenSaveDialog (void)
00007ff7`9b4c09e8 notepad!StringLengthWorkerW (void)
00007ff7`9b4c38e0 notepad!initialize_printf_standard_rounding (void)
00007ff7`9b4a1640 notepad!`dynamic initializer for 'szFileName'' (void)
...
The PDB File Format
●
Proprietary ﬁle format by Microsoft
○
Binary
○
Multi Stream Format (MSF)
●
Open sourced for non-MS compilers to produce PDBs
●
Parser implemented in Dbghelp.dll
○
Shipped by default
○
API to debug a process, load PDBs, extract symbols data ...
5
Let’s Fuzz PDB
6
Fuzzing Setup
7
●
Corpus - ~5000 PDBs from several sources
●
Test Harness - A program that loads a PDB ﬁle and parse it 
○
Dbghelp!SymLoadModule
●
WinAFL fuzzer
Corpus
Mutator
Run 
Harness
Crashes
Start
Repeat
8
What is the Attack Surface?
●
Remote symbols servers
●
Attacker controls / MitM symbols server can serve arbitrary PDBs
9
0:007> .sympath srv*http://msdl.microsoft.com/download/symbols
Symbol search path is: 
srv*http://msdl.microsoft.com/download/symbols
Expanded Symbol search path is: 
srv*http://msdl.microsoft.com/download/symbols
0:007> .reload /f notepad.exe
Victim Debugger
Symbol Server
Attacker
(MitM)
Report to Microsoft MSRC
●
18-08-2020 - Initial report to Microsoft MSRC
●
15-09-2020 - Doesn’t meet the bar for security servicing 
○
Attack surface is too complex
11
“... In this case, Microsoft has decided that it will not be ﬁxing this vulnerability 
in the current version and we are closing this case. In order to exploit this an 
attacker would need to control the symbol server or MitM the connection. 
Then the victim would have to load a PDB from the server. At this time, you 
are able to blog about/discuss this case and/or present your ﬁndings publicly 
about the current version. …”
Other Attack Surfaces
●
Other components that use Dbghelp.dll to parse PDBs
○
How about elevation of privileges?
●
Text-search ‘Dbghelp.dll’ in all binaries under C:\Windows
○
Appverif.exe, appverifUI.dll, comsvcs.dll, devinv.dll, taskkill.exe … faultrep.dll, wer.dll
●
WER uses Dbghelp.dll!
○
I already discovered ~15 vulnerabilities in WER... Check out my BlueHatIL talk
12
Windows Error Reporting Recap
●
WER collects info regarding crashes / hangs and reports to Microsoft
●
Process crash -> WerFault.exe worker is launched
13
svchost.exe
(WerSvc)
Process.exe
ALPC
WerFault.exe
Parent: Process.exe
Child: WerFault.exe
CreateProcessAsUser()
How Does WerFault.exe Use Dbghelp.dll?
●
Parse the stacktrace of the crashing thread
●
Add stacktrace hash to error report
○
Allows Microsoft to group crashes by stacktrace
14
long long UtilGetStackTrace(long ProcessId, long ThreadId) {
/* ... */
HANDLE CrashingProc = OpenProcess(
PROCESS_ALL_ACCESS, 0, ProcessId);
SymInitialize(CrashingProc, NULL, fInvadeProcess=TRUE);
/* ... */
for ( ... ) { StackWalk(); }
15
WerFault.exe Permissions
●
Usually WerFault.exe runs with the same privileges of the crashing process
●
One exception: Low-IL crash -> Medium-IL WerFault.exe
16
●
ILs restrict processes running under the same user account
Integrity Levels (IL)
17
●
Low-IL is used for sandboxing
○
E.g. iexplore renderers run under Low-IL
●
Browser exploit chains: renderer RCE -> sandbox escape/EoP
What’s the Game Plan?
18
●
Elevate privileges from Low-IL to Medium-IL
Process.exe
(Low)
 LoadSymbol
 WriteFile
Process.exe
(Low-IL)
WerFault.exe
(Medium-IL)
crash.pdb
●
From Low-integrity process:
○
Write malformed PDB ﬁle to disk
○
Crash my own process (Low-IL)
○
WerFault.exe (Medium-IL) launches
○
WerFault.exe loads malformed PDB ﬁle
■
Exploit PDB parsing bug for EoP
Load PDBs From Arbitrary Paths
●
Cannot write to most paths as Low-IL
○
C:\users\gdeleon\AppData\LocalLow directory (%AppData%\LocalLow)
●
How to get WerFault.exe to load PDB from %AppData%\LocalLow?
●
PdbFilePath in PE / Executable header 
○
Run my own EXE, point PdbFilePath to %AppData%\LocalLow
19
struct CV_INFO_PDB20
{
  CV_HEADER CvHeader;
  DWORD Signature;
  DWORD Age;
  BYTE PdbFilePath[];
};
20
(91c.1024): Access violation - code c0000005 (first chance)
6dd52abe mov     eax,dword ptr [ebx+164h] 
ds:002b:08007e6e=????????
0:000> k
ChildEBP RetAddr  
02b8a4ec 6dd4ac82 dbghelp!ModCache::pbSyms+0xe
...
02b8f7f0 0072ceaf faultrep!WerpInitiateCrashReporting+0x40f
02b8f838 007039cd WerFault!UserCrashMain+0x2b1
02b8f878 007419a0 WerFault!wmain+0x13e
Dbghelp.dll Bug
21
DbgHelp!SymCache::PsymForImodOff
22
int Index = …; /* Read from PDB file */;
/* Certain checks on Index */;
Object* Obj = ObjectsArray[Index - 1];
Obj->VirtualFunctionCall();
DbgHelp!SymCache::PsymForImodOff
●
The bug - Index is allowed to be equal to 0
○
Type confusion
23
int Index = …; /* Read from PDB file */;
/* Certain checks on Index */;
Object* Obj = ObjectsArray[Index - 1];
Obj->VirtualFunctionCall();
-1
0
1
2
??
Obj0
Obj1
Obj2
int Index = 0; /* Read from PDB file */;
/* Certain checks on Index */;
Object* Obj = ObjectsArray[Index - 1];
Obj->VirtualFunctionCall();
What’s on Index -1?
●
ObjectsArray is allocated on the heap
●
There’s a heap header prior to every heap allocation
○
Metadata about the allocation
24
-1
0
1
2
Heap Header
Obj0
Obj1
Obj2
Heap Header Structure (32 bit)
●
8 bytes header prior to every heap allocation
○
Low DWORD part is confused with Object*
25
-2
-1
0
Header High
Header Low
Obj1
0:000> dt -t _HEAP_ENTRY
   +0x000 UnpackedEntry    : _HEAP_UNPACKED_ENTRY
   +0x000 Size             : Uint2B
   +0x002 Flags            : UChar
   +0x003 SmallTagIndex    : UChar
   +0x004 PreviousSize     : Uint2B
   +0x006 SegmentOffset    : UChar
   +0x007 UnusedBytes      : UChar
Heap Encoding
●
‘Security-cookie’ to prevent heap overrun exploits
○
Header XOR random key (_HEAP->Encoding)
●
8-bytes key generated per heap at runtime (ntdll!RtlpCreateHeapEncoding)
●
Part of the key is always set zero!
■
2 high bytes of the second dword
○
Remains cleartext (X ^ 0 = X)
26
0:000> dt -t _HEAP
ntdll!_HEAP
   +0x050 Encoding      
0:000> dd 01360000+50 L2
01360050  18be3a5a 00006ab6
Is the Heap Header Value Predictable?
●
Encoded header example: AAAAAAAA XXYYBBBB
○
XXYYBBBB => Fake Object*
●
MSB (XX) meaning is UnusedBytes
○
Diff between malloc(size) and actual chunk size
○
Remains cleartext (XX ^ 0)
27
●
ObjectArray is a small allocation
○
12 bytes
●
UnsuedBytes is predictable
○
0x18
●
Fake Object* is a low usermode address
○
0x18XXXXXX
0:000> dt -t _HEAP_ENTRY
   +0x000 UnpackedEntry
   +0x000 Size             : Uint2B
   +0x002 Flags            : UChar
   +0x003 SmallTagIndex    : UChar
   +0x004 PreviousSize     : Uint2B
   +0x006 SegmentOffset    : UChar
   +0x007 UnusedBytes      : UChar
28
Heap Header
0
1
2
0x18XXXXXX
Obj0
Obj1
Obj2
Object
VPTR
Func1
Func2
...
Control this value
Control this value
int Index = 0;
Object* Obj = ObjectsArray[0 - 1 = -1];
Obj->Func2();
MOV eax, [ecx] ; Obtain vptr
CALL [eax + 4] ; Call vfunc
29
32Bit Crash? 32Bit WerFault!
●
32bit process crash -> 32bit WerFault.exe
○
Much easier to spray in 32bit
○
Allocators more predictable
Spray Primitive
●
Goal: Spray WerFault.exe address space from crashing process (Low-IL)
●
Dbghelp!SymInitialize loads PDBs for all loaded module
○
PDB #1 - Spray
○
PDB #2 - Trigger vulnerability
●
How to spray from PDB #1?
○
Very large PDB ﬁle
○
Entire PDB is mapped using kernel32!MapViewOfFile
■
kernel32!MapViewOfFile is predictable (64k alignment)
○
Dbghelp doesn’t unmap invalid PDBs
■
When bug is triggered (PDB #2) sprayed memory (PDB #1) is in place
30
Process.exe
(Low-IL)
Spray.pdb
WriteFile
WerFault.exe
(Medium-IL)
0
ffffffff
WerFault.exe Address Space
SymInitialize
Trigger.pdb
Spray.pdb
Spray
Trigger.pdb
Trigger
Heap Header
Objs Array
Obj
Process.exe
(Crashed)
0:000:x86> ub
dbghelp!ModCache::pbSyms+0xe9:
701e2f39 8b8354010000    mov     eax,dword ptr [ebx+154h]
701e2f3f 8bb88c000000    mov     edi,dword ptr [eax+8Ch]
701e2f45 8b07            mov     eax,dword ptr [edi]
701e2f47 8b7078          mov     esi,dword ptr [eax+78h]
701e2f4a 8bce            mov     ecx,esi
701e2f4c ff1568243370    call    dword ptr [dbghelp!__guard_check_icall_fptr]
701e2f52 8bcf            mov     ecx,edi
701e2f54 ffd6            call    esi
0:000:x86> .frame 0
00 006fe2e0 701e2f56 0x0e0e0e0e
33
Where to Call to?
●
Problem: CFG is enabled on WerFault.exe
○
CFI mitigation to prevent ROP/code-reuse attacks
○
Can only call CFG valid call targets
●
kernel32!LoadLibrary is a valid CFG target! 
○
Load DLL from ‘%AppData%\LocalLow’ and run payload for entrypoint
●
ASLR is not an issue
○
DLLs loaded at same address regardless of IL
○
Fetch kernel32!LoadLibrary address at runtime (Low-IL)
■
Write it to spray.pdb
●
How to control kernel32!LoadLibrary argument?
○
Different calling conventions
Dbghelp Gadget (Arguments Reorder)
34
virtual long __thiscall DbhStackServices::GetSegmentDescriptor(..)
mov     edi, edi
push    ebp
mov     ebp, esp
…
mov     edi, ecx   ; Put ‘this’ in edi (‘this’=0x0c0c0c0c)
push    0
push    2Ch ; ','
mov     esi, [edi+0Ch]  ; Get next virtual func address, from ‘edi+0Ch’
mov     ecx, esi       
push    dword ptr [edi+4] ; Push an argument on stack, from ‘edi+4’
call    ds:___guard_check_icall_fptr
call    esi
Demo #1
35
Escape Internet Explorer EPM Sandbox
36
●
Enhanced Protected Mode - Low IL+AppContainer
○
iexplore.exe(Low+AC) -> WerFault.exe(Medium)
●
PDB bug behaves differently
○
Fake Object*/_HEAP_ENTRY points to a kernel-mode address
■
LFH - _HEAP_ENTRY struct is different (ExtendedBlockSignature vs UnusedBytes)
(b00.990): Access violation - code c0000005 (first chance)
dbghelp!ModCache::pbSyms+0xe:
6db12abe 8b8364010000    mov     eax,dword ptr [ebx+164h] ds:002b:880002d8=????????
0:000> dd @edx-4 L4
007306ec  88000174 007076c0 007316f8 00731878
0:000> !heap -x @edx
Entry
        User         Size    PrevSize   Unused    Flags
-----------------------------------------------------------------
007306e8     007306f0        0        -           8    LFH;busy
Escape Internet Explorer EPM Sandbox
●
Process creation is allowed from IE’s sandbox
●
Create a child process and exploit the bug from there
○
iexplore.exe(Low+AC) -> exploit.exe(Low+AC) -> WerFault.exe(Medium)
37
Demo #2
38
Microsoft Fix (CVE-2021-24090 / KB5000802)
39
●
WerFault.exe no longer parses PDB ﬁles
○
dbghelp!SymSetExtendedOption
○
(IMAGEHLP_EXTENDED_OPTIONS)3 = LOAD_SYMBOLS_DISABLED
SymSetExtendedOption(3, TRUE);
v33_Ret = SymInitialize(v11_CrashingProc, NULL, TRUE);
WerFault.exe:
if (SymGetExtendedOption(3)) {
_pwprint(L”load symbols is disabled!\n”);
return 4; }
Dbghelp.dll:
Takeaways
●
Fuzzing is very efﬁcient for the right targets
●
Exploit works despite all mitigations
○
32bit compatibility layer isn’t as strongly mitigated
●
One bug, multiple attack surfaces
40
@galdeleon