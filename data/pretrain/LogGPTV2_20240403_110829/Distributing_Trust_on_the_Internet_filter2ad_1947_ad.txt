can recover a threshold  signature. 
We sketch two applications here and refer to [6] for more 
details; an authentication service and a trusted party  for fair 
exchange are also described there. 
Certification Authority and Directory Service.  A  cer- 
tification authority  (CA) is  a  service  run  by  a  trusted  or- 
ganization  that  verifies  and confirms the  validity  of public 
keys.  The issued cert$cates  usually also confirm  that  the 
real-world  user  defined  in  a certificate  is  in  control of  the 
corresponding private key.  A certificate  is simply a digital 
signature under  the  CA's  private signing key  on  the public 
key and the identity (ID) claimed by the user. 
The CA has published its own public key of a digital sig- 
nature  scheme.  When  a  user  wants  to  obtain  a  certificate 
for his public key, he sends it together with his  ID and cre- 
dentials to the CA. The ID might consist of name, address, 
email, date of birth, and other data to uniquely  identify the 
holder. Then the CA verifies the credentials, produces a cer- 
tificate  if they  pass, and sends the  answer back  to the user. 
The user can verify his certificate  with the public key of the 
CA. For its certificates to be meaningful, the CA must have 
a clearly stated and publicized policy  that it follows for val- 
idating public keys and IDS; this policy might change over 
time. We ignore revocation and other issues for the moment. 
A  secure  directory service  maintains  a  database  of  en- 
tries, processes lookup queries, and returns the answers au- 
thenticated by a signature under its private signing key. The 
corresponding  signature verification key  is available  to all 
clients.  Several examples of secure directories exist in dis- 
tributed  systems today  and more are needed  in  the  future, 
such as DNS authentication. 
Internally,  a  secure  directory  works  much  like  a  CA: 
it  receives  a  query, retrieves  some values  from  the  stored 
database,  generates  a  digital  signature  on  the  result,  and 
sends  both  back  to  the  client.  Additional  functionality  is 
needed for updating the database. 
Both services can be implemented in our distributed sys- 
tem  architecture.  Requests  must  be  delivered  by  atomic 
broadcast to ensure that all servers return the same answers. 
Updates to the database  must  be  treated  in  the  same way. 
The digital  signature scheme  of the  service is replaced  by 
the  corresponding  threshold  signature  scheme,  which  re- 
quires minimal changes to the clients in the case of [33].  In 
the server code, computing the digital  signature is replaced 
by generating a signature share. 
Note  that  atomic broadcast is crucial for delivering any 
request  that  changes  the  global  state;  only  if  a CA  never 
changes its policy and all of its certificates are independent 
of each other does it suffice to use reliable broadcast. 
190 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:07:54 UTC from IEEE Xplore.  Restrictions apply. 
In  its  simplest  form,  a  digital  notary 
Notary  Service. 
service receives documents, assigns  a sequence number to 
them,  and  certifies  this  by  its  signature.  Such  a  service 
could, e.g.,  be  used  for  assigning  Internet  domain  names 
or registering  patent  applications.  A  notary  must  process 
requests  sequentially  and atomically; it  updates its internal 
state for each request. 
In  many  notary  applications,  the  content  of  a  request 
must remain confidential  until  the  notary  processes it  in  a 
single atomic step.  For example, a competitor in the patent 
application scenario might try to file a related  patent appli- 
cation,  have  it processed  first,  and  claim the  invention  for 
himself. 
A  distributed  notary  can  be  realized  readily  using  our 
architecture since it involves a simple state machine to be 
replicated.  Client requests  must be disseminated by  secure 
causal  atomic  broadcast  to  rule  out  any  violation  of  their 
confidentiality.  For if no encryption were used, a corrupted 
server could see the  contents  of  the request  during atomic 
broadcast and  arrange that  the  service  schedules and pro- 
cesses a related request of the adversary before the original 
one.  The same attack is possible  if the cryptosystem is not 
secure against adaptive chosen-ciphertext attacks. 
As the answer of the notary  service is a digitally  signed 
message, clients obtain their receipt  as described before in 
the CA example. 
6  Extensions 
We mention  some extensions and  improvements of  our 
architecture.  Although  we  have  strived  for a  secure  and 
fault-tolerant  system  in  the  given  environment,  the  secu- 
rity  could be strengthened by  using  “proactive”  protocols, 
allowing for dynamic group changes, or using  hybrid  fail- 
ure  structures  (not to  be confused with  generalized  ones). 
Our atomic broadcast protocols involve a considerable over- 
head, in particular for large n, because security has been our 
primary  design  principle.  Among the various possible  op- 
timizations, it seems most promising to design “optimistic” 
protocols,  which  run  very  fast if  no corruptions  occur but 
may fall back to a slower mode if necessary. 
Proactive Protocols.  Proactive  security  is  a  method  to 
protect  threshold-cryptographic  schemes  against  a  mobile 
adversary that can corrupt all parties during the  lifetime of 
the  system,  but  never  more  than  t  at  once  (see  [9]  for  a 
survey).  Proactive  protocols  divide time into epochs.  All 
parties  “reshare”  their  cryptographic secret  keys  between 
two epochs and delete all old key  material.  The model  as- 
sumes an external mechanism for detecting corruptions and 
“cleaning up” a party. Because all secrets that the adversary 
has seen in the past become useless by resharing, the adver- 
sary never knows enough secret information to compromise 
the whole system. 
Proactively  secure  protocols  for our asynchronous sys- 
tem  model  are  currently  not  known.  One  issue  to  be 
addressed  first  is  how  to  integrate  epochs  into  the  asyn- 
chronous system model. 
Dynamic Groups.  The static nature of our system model 
may  pose  a  problem  for  practical  systems.  Real  systems 
evolve over time and grow or shrink together with the orga- 
nizations that use them.  Every such change would require a 
fresh setup of the complete system by a trusted dealer.  Ide- 
ally, a system should reconfigure  itself and dynamically in- 
crease or decrease the group size and the thresholds.  How- 
ever, special care is needed  to ensure the safety of all keys 
during the  changes;  thus,  at  least  some resharing  of  keys 
will be needed as in proactive protocols. 
Note that similar motivation has led to the important idea 
of  view-based  group communication systems that  tolerate 
crash failures.  But dynamically changing the  group seems 
much  harder  in  the  Byzantine model  when  cryptographic 
secrets are involved; this is currently an open problem. 
Hybrid  Failure  Structures.  Another  interesting  direc- 
tion is to treat crash failures separately from corruptions and 
adapt the  protocols  to  such hybrid  failure  structures.  Af- 
ter all, crashes are more likely  to occur than intrusions and 
they are much easier to handle than Byzantine corruptions. 
For coping with transient server outages, the crash-recovery 
model  seems also  plausible  (see  references  in  [IS]).  Pro- 
tocols  in  hybrid  failure  models have  been  investigated  be- 
fore [ 171 so that we expect this to be feasible. 
Optimistic Protocols.  Optimistic protocols run  very  fast 
if no malicious adversary is at work and all messages are de- 
livered promptly. If a problem is detected (typically because 
liveness  is  violated),  they  may  switch  into  a  more  secure 
mode using protocols that guarantee progress.  This idea is 
quite common  in  the  literature  [27, 1 I].  In  our Byzantine 
context, one has to make sure that safety is never violated, 
though.  Kursawe and Shoup [21] recently  designed a pro- 
tocol along these lines. 
Acknowledgments 
This paper reflects  the results  of many  discussions with 
Klaus  Kursawe,  Frank  Petzold,  Jonathan  Poritz,  Victor 
Shoup, and Michael Waidner; I am grateful for all their con- 
tributions. 
This work  was  supported by  the  European IST Project 
MAFTIA (IST-1999-1 1583), but represents the view of the 
191 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:07:54 UTC from IEEE Xplore.  Restrictions apply. 
author. The MAFTIA project is partially funded by the Eu- 
ropean Commission and the Swiss Department for Educa- 
tion and Science. 
References 
R. Baldoni, J.-M. Helary, and M. Raynal, “From crash fault- 
tolerance to arbitrary-fault  tolerance: Towards a modular ap- 
proach,” in Proc. DSN 2000, pp. 273-282,  2000. 
M. Bellare and P. Rogaway, “Random oracles are practical: 
A paradigm  for designing efficient protocols,”  in Proc.  1st 
ACM  CCS, 1993. 
M. Ben-Or, “Another  advantage of free choice:  Completely 
asynchronous  agreement  protocols,”  in  P roc.  2nd  PUDC, 
1983. 
J. Benaloh  and J.  Leichter,  “Generalized secret sharing and 
monotone  functions,”  in  Proc.  CRYPT0  ’88, LNCS 403, 
pp. 27-35,  Springer, 1990. 
G.  Bracha  and  S. Toueg,  “Asynchronous  consensus  and 
broadcast protocols,” J. ACM, vol. 32, pp. 824-840,  1985. 
C. Cachin, ed., Specification  of  Dependable  Trusted  Third 
parties,  Deliverable  D26,  project  M A ~ I A  IST-1999- 
11583, Jan. 2001 (also Report RZ 3318, IBM Research). 
C .  Cachin, K. Kursawe, F. Petzold, and  V.  Shoup, “Secure 
and efficient  asynchronous broadcast protoco~s,~~ 
~~~~~~l~~~ 
ePrint Archive. Reoort 2001/006. 
C. Cachin,  K.  Kursawe,  and  V.  Shoup,  “Random  oracles 
in Constantinople: Practical asynchronous Byzantine agree- 
ment  using  cryptography,”  in Proc.  19th PODC, pp.  123- 
132,2000. 
R. Canetti, R. Gennaro, A. Herzberg, and D. Naor, “Proac- 
tive security: Long-term protection  against break-ins,”  RSA 
Laboratories’ CtyptoBytes, vol. 3, no.  I ,   1997. 
R.  Canetti  and  T.  Rabin,  “Fast  asynchronous  Byzantine 
agreement  with  optimal  resilience,”  in  Proc.  25th  STUC, 
pp. 42-5  I ,   1993. 
M. Castro and  B.  Liskov,  “Practical  Byzantine fault toler- 
ance,” in Proc. Third Symp. OSDI, 1999. 
T.  D.  Chandra  and  S. Toueg,  “Unreliable  failure detectors 
for  reliable  distributed  systems,”  J.  ACM, vol.  43,  no.  2, 
pp. 225-267,  1996. 
R.  Cramer,  1.  B.  Damgird,  and  U. Maurer,  “General  se- 
cure multi-party  computation from any linear secret sharing 
scheme,” in Proc. EUROCRYPT 2000, LNCS 1087,2000. 
A. Doudou, B. Garbinato, and R. Guerraoui,  “Abstractions 
for devising Byzantine-resilient  state machine replication,” 
in Proc. 19th SRDS, pp.  144-152, 2000. 
M. J. Fischer,  N. A. Lynch,  and M. S. Paterson,  “Impossi- 
bility  of  distributed consensus  with one faulty  process,”  J. 
ACM, vol. 32, pp. 374-382,  Apr.  1985. 
M.  Fitzi  and  U.  Maurer,  “Efficient  Byzantine  agreement 
secure  against  general  adversaries,”  in  Proc.  12th  DISC, 
LNCS 1499, pp.  134-148,  1998. 
[I71  J. A. Gamy and K. J. Perry, “A  continuum of failure models 
for distributed computing,” in Proc. 6th WDAG, LNCS 647, 
1992. 
[I81  R.  Guerraoui,  M.  Hurfin,  A.  Mostefaoui,  R.  Oliveira, 
M. Raynal,  and  A.  Schiper,  “Consensus  in  asynchronous 
distributed systems:  A  concise  guided  tour,”  in Advances 
in Distribute2 Systems, LNCS 1752, pp. 3347, 2000. 
1191  M. Hirt and U. Maurer,  ‘‘Ph-r simulation and general  ad- 
versary  structures  in  perfect  multi-party  computation,”  J. 
Cqptology, vol. 13, no.  I ,  pp. 31-60,  2000. 
[201  K.  P.  Kihlstrom,  L.  E.  Moser;  and  P.  M.  Melliar-Smith, 
“The SecureRing protocols for securing group communica- 
tion,” in Proc. 31st Hawaii Intl.  Conf  on System Sciences, 
pp. 317-326,  1998. 
[21]  K. Kursawe and V.  Shoup, “Optimistic asynchronous atomic 
broadcast.” Cryptology ePrint Archive, Report 200 11022. 
[22]  D. Malkhi, M. Merritt, and 0. Rodeh, “Secure reliable mul- 
ticast protocols in a WAN,” Distributed Computing, vol.  13, 
no.  I ,  pp.  19-28,  2000. 
[23]  D. Malkhi and M. K. Reiter, “Byzantine quorum systems,” 
Distributed Computing, vol.  1 I ,  no. 4, pp. 203-213,  1998. 
[24]  D. Malkhi  and  M.  K.  Reiter, “An  architecture for surviv- 
able coordination in large distributed systems,” IEEE Trans. 
Knowl. Data  Eng., vol. 12, no. 2, pp.  187-202,  2000. 
[25]  L. E. Moser and P.  M.  Melliar-Smith,  “Byzantine-resistant 
total  ordering  algorithms,”  Information  and  Computation, 
vol. 150, pp. 75-1  11, 1999. 
[26]  M. Pease, R. Shostak, and L. Lamport, “Reaching agreement 
in  the  presence  of  faults,”  J.  ACM, vol. 27,  pp.  228-234, 
1980. 
[27]  F. Pedone and A. Schiper, “Optimistic atomic broadcast,” in 
Proc. 12th DISC, 1998. 
[28]  D. Powell, “Group communication,” Comm. ACM, vol. 39, 
Apr. 1996. 
[29]  M.  Reiter,  “Secure  agreement  protocols:  Reliable  and 
atomic group multicast in Rampart,” in P roc. 2ndACM CCS, 
1994. 
[30]  M. K. Reiter, “Distributing trust  with the Rampart toolkit,” 
Comm. ACM, vol. 39, pp. 71-74,  Apr.  1996. 
[31]  M.  K.  Reiter  and  K.  P.  Birman,  “How  to  securely  repli- 
cate services,” ACM  Trans. Prog. Lang.  and  Syst., vol.  16, 
pp. 986-1009,  1994. 
[32]  F. B. Schneider, “Implementing fault-tolerant  services using 
the  state machine  approach:  A tutorial,”  ACM  Computing 
Surveys, vol. 22,  1990. 
[33]  V.  Shoup, “Practical threshold signatures,”  in Proc. EURO- 
CRYPT2000, LNCS 1087, pp. 207-220,  2000. 
[34]  V.  Shoup and R. Gennaro, “Securing  threshold  cryptosys- 
tems  against  chosen  ciphertext  attack,”  in  Proc.  EURU- 
CRYPT ’98, LNCS 1403, 1998. 
[35]  P. Ven’ssimo, A. Casimiro, and C. Fetzer, “The timely com- 
puting  base:  Timely  actions  in  the  presence  of  uncertain 
timeliness,” in Proc. DSN 2000, pp. 533-542,  2000. 
192 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:07:54 UTC from IEEE Xplore.  Restrictions apply.