… 
(f) The ﬁnal shellcode layout.
Fig. 5: The layout remediation process for the motivating example with shellcode1.
For example, consider the motivating example and the
replacement shellcode in Listing 5. As we described in
Section II-B, we encounter a path conﬂict because the for
loop in our example, which runs 40 times for the original
shellcode, only runs once for the replacement shellcode. Let E
be the exploit, and let Ei be the i-th byte in E. The symbolic
value of string in the exploitable state is equal to:
Concatenate(E0, E1,... , E18, E40)
which means the string from the 0th to the 40th byte of the
input. In this case, the path constraints include the following:
E0 (cid:4)= ’\x00’ ∧ E1 (cid:4)= ’\x00’ ∧ . . . ∧ E40 (cid:4)= ’\x00’
However, because the second character of the replacement
shellcode is ’\x00’, the shellcode constraints conﬂict with
the path constraints1.
Suppose that ShellSwap identiﬁes this situation while trying
to place the ﬁrst instruction of the replacement shellcode at
1The inquisitive reader might question why the part of the shellcode with
the null byte could not be written after the return address to bypass this loop.
However, a closer look at the replacement shellcode would reveal null bytes
in many other locations as well.
the beginning of string. After analyzing the conﬂicting
constraint subset, we know that the conﬂict stems from the
path constraint E1 (cid:4)= ’\x00’, and this constraint is created
at address 0x080482F3, shown in Figure 6. Speciﬁcally, the
conﬂict constraint occurs at the second iteration of the for loop.
To generate a new path, we negate the conditional jump
associated with the conﬂicting path constraint by modifying the
trace to force an exit from the loop after the second iteration.
However, after this change, we need to merge the diversion back
to the original path. We accomplish this by leveraging static
analysis. First, we ﬁnd the function containing the divergence
point, and build a control ﬂow graph for the speciﬁc function.
Next, we statically ﬁnd the descendants of the diverted node
and see if any of the descendants appear in the original path
after the negated node. For each satisfying descendant, we
attempt to construct a new path that is identical to the original
path until the negated node, followed by the detected detour
back to the descendent node that appears in the original path,
and then ending with the postﬁx from the descendant node to
the end of the original path.
Figure 7 shows the generation of a new path. Suppose node
nc is negated to nc(cid:2) , and node nd is the descendant of node
831
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
…(cid:1)
080482E6
mov     eax, [ebp+var_24]
080482E9
movsx   eax, [ebp+eax+buf]
080482EE
cmp     eax, 0
080482F3
jz      loc_8
08048314
mov     eax, [ebp+len]
08048317
mov     [ebp+ret], eax
…(cid:1)
080482F9
mov     eax, [ebp+len]
080482FC
add     eax, 1
08048301
mov     [ebp+len], eax
08048304
mov     eax, [ebp+var_24]
08048307
add     eax, 1
0804830C
mov     [ebp+var_24], eax
0804830F
jmp     loc_80482E6
Fig. 6: Part of the control ﬂow graph for the motivating example.
nc(cid:2) . For the new path, the basic blocks do not change before
nc(cid:2) or after nd. In between, we insert an intraprocedural path
from nc(cid:2) to nd G(nc(cid:2) , nd), which can be generated using the
control graph of the function. In the best case, the question is
equivalent to ﬁnding a path between two nodes in a directed
graph. However, it is possible that there is no such path to
rejoin the original path, or that the problem reduces to symbolic
exploration (if the divergence is too big). In this case, ShellSwap
falls back on the Two-Stage Fallback.
In the motivating example, as simply exiting the loop already
rejoins the original path, the detour back to the path is trivial: it
is the direct jump to the return site of the example function.
After constructing the new path, the ShellSwap system
generates the new exploitable program state and a new set of
path constraints using the Symbolic Tracing step. Meanwhile,
it also checks if the new program state is still exploitable. If
the new program state is exploitable, our system starts again
from the preprocessing phase to ﬁt the replacement shellcode
into the new exploitable program state. Otherwise, the system
will attempt to construct the other paths and generate the other
program states, falling back on the Two-Stage Fallback if it is
unable to do so.
D. Two-Stage Fallback
If ShellSwap is unable to overcome the memory and path
conﬂicts and ﬁt the replacement shellcode into the exploitable
state, then it falls back on pre-deﬁned a two-stage shellcode
instead of the provided replacement shellcode. The motivation
of this fallback is straightforward: if the provided shellcode
cannot ﬁt the exploitable state, even after Path Kneading, we
try a smaller ﬁrst-stage replacement shellcode that can then
load an arbitrary second-stage shellcode.
There are several options for a ﬁrst-stage shellcode. One
option is a shellcode that reads shell commands from the socket
and executes them. Another, to bypass modern defenses such
as Data Execution Protection, could read a Return Oriented
Programing payload over the stack and initiates a return. For
our prototype, we implemented a stack-based shellcode-loading
ﬁrst-stage payload that reads a second-stage payload onto the
stack and jumps into it. While this is not immune from DEP
techniques, it is only meant as a proof of concept for our
prototype.
Consider the motivating example. The program receives input
by using the DECREE syscall receive() (more information
on DECREE is provided in Section VI), which is a system
call similar to recv() in Unix/Linux. If the new shellcode
is longer than 50 bytes, we cannot generate a new exploit
because the program is able to receive 50 bytes at most. In this
case, we could consider the following template for generating
a two-stage shellcode:
1
2
3
4
5
6
7
8
9
10
11
xor
inc
inc
inc
xor
inc
mov
mov
mov
int
jmp
%eax,%eax
%eax
%eax
%eax
%ebx,%ebx
%ebx
%esp,%ecx
_ ,%edx
_,%esi
$0x80
*%esp
31 c0
40
40
40
31 db
43
89 e1
8b _
8b _
cd 80
ff e4
; %ecx: &dst
; %edx: len
; %esi: &ret
Listing 6: The disassembly of the template for a two-stage
shellcode.
This ﬁrst-stage shellcode reads a string, stores at the bottom
of the stack (%esp) and jumps to the received string. There
are two blanks in the template – we need to ﬁll the receiving
length and the address of return value for register %edx and
%esi, respectively. After completing the template, our system
will restart the layout remediation process with the two-stage
shellcode as the replacement shellcode. If the system cannot
ﬁnd a modiﬁed exploit using the Two-Stage Fallback, it returns
an error indicating that no modiﬁed exploit could be found.
832
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
Original Path 
New Path 
n0 
n0 
n1 
n1 
… 
… 
nc 
nc’ 
nc+1 
nc+2 
nc+3 
G(nc’, nd) 
… 
… 
nd 
nd 
nd+1 
nd+1 
… 
… 
Fig. 7: The generation of a new path. G(x, y) means a path between node x and y found by static analysis.
Although the two-stage shellcode helps to solve the shellcode
transplant problem by increasing the situations in which
ShellSwap can function, we consider this purely as a fallback.
This is because two-stage exploits may be less robust than
the other exploits, as they assume that the victim machine
can receive extra bytes from the attacker. This assumption
does not always hold. For instance, the victim machine may
be protected by other mechanisms which block the message,
such as an external ﬁrewall, or the network connection over
which communication happens might already be closed when
the vulnerability triggers. Therefore, our system prioritizes the
conﬂict resolution approaches, and it will not trigger the Two-
Stage Fallback when the previous layout remediation process
fails.
V. IMPLEMENTATION
ShellSwap is implemented on top of angr [29], a binary
analysis platform. We rely on angr’s symbolic tracing com-
ponent [3], which also leverages the QEMU emulator [1] for
exploit replay and symbolic tracing. The core of our system,
consists of about 2000 lines of Python code.
A. Finding Infeasible Constraint Sets
Finding a minimal subset of infeasible constraints, which
is an essential part of Path Kneading, is not a trivial problem.
The underlying constraint solver Z3, which is used in angr
(and thus in ShellSwap), provides an unsat_core function to
retrieve the smallest subset of an unsatisﬁable set of constraints.
However, in our experiment, we found that unsat_core can
be very time consuming, and sometimes even lead to crashes
of Z3. Since we weren’t able to pinpoint the root cause of
the problem, we further implement a constraint set slimming
method (as described below) to resort to in case unsat_core
fails.
The constraint set slimming is a divide-and-conquer approach.
Given a constraint set A and a constraint c that contradicts A,
constraint set slimming will try to ﬁnd a subset of constraints
in A (but not the smallest subset) that still contradicts c. We
ﬁrst divide A into two subsets and check if any of them is
contradictory to constraint c. If both subsets contradict c, the
ﬁnal infeasible constraint set will include conﬂicting constraints
subsets from the two. If only one subset contradicts c, the other
subset can be safely discarded as the result will only contain
conﬂicting constraints from the contradictory subset. We repeat
this procedure on contradictory subsets recursively until we
ﬁnd the very last contradictory subset, which either contains a
single constraint that contradicts c, or several constraints that
none of which contradicts c if considered individually. The
union of all conﬂicting subsets of constraints represent the
slimmed set of constraints.
B. Optimizations
Much of the execution in symbolic tracing does not involve
symbolic data. To speed up the tracing step, ShellSwap enables
code JIT’ing (through the use of Unicorn Engine [24]) by
default, which allows instructions in the original exploit to be
executed natively instead of being emulated. While it greatly
speed up symbolic tracing, we ﬁnd that this step is still the
bottleneck in ShellSwap: as discussed in Section VI, an average
of 95% of execution time is spent in this step.
To avoid generating an entire control-ﬂow graph in our
path kneading component, we used a fast function detection
approach to pick out the exact function for which to generate
the control ﬂow [9].
In the course of the development of this system, we have
upstreamed many big-ﬁxes and some improvements to angr and
its tracing module. With these ﬁxes, we observed a 1000-times
speed improvement on some samples in our evaluation.
VI. EVALUATION
In this section, we present our evaluation of ShellSwap. We
ﬁrst describe the data set, including all vulnerable programs and
exploits, used in our evaluation (Section VI-A). Then, we show
the experimental setup in Section VI-B. Next, we demonstrate
the effectiveness of our approach in Section VI-C by evaluating
both ShellSwap and a reference implementation of previous
work on 20 original exploits and 5 pieces of replacement
shellcode. There, we show the necessity of ShellSwap in
effectively transplanting shellcode. In the end, we evaluate the
efﬁciency of ShellSwap and display the results in Section VI-D.
A. Data Set
Our evaluation data set contains three parts: 11 vulnerable
binaries, 20 original exploits, and 5 pieces of replacement
shellcode. We present how the data set is constructed below.
1) Vulnerable binaries: We selected 11 vulnerable binaries
(see Table I) from the qualifying event as well as the ﬁnal
event of DARPA Cyber Grand Challenge (CGC). These
binaries are shipped with source code, reference exploits, and
actual exploits generated by other CGC participants, making
them a perfect ﬁt for our evaluation. All of the binaries
are standalone x86 binaries with a special set of system
calls (DECREE syscalls), roughly analogous to the Linux
system calls recv (as DECREE’s receive), send (as
DECREE’s transmit), mmap (as DECREE’s allocate),
munmap (as DECREE’s deallocate), select (as DE-
CREE’s fdwait), get_random (as DECREE’s random),
and exit (as DECREE’s _terminate). Sizes of those
binaries range from 83 KB to 18 MB. Those vulnerable
binaries cover a wide range of subtypes of control ﬂow hijack
833
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
vulnerabilities, including stack overﬂow, heap overﬂow, integer
overﬂow, arbitrary memory access, improper bound checking,
etc.
2) Exploits: As the CGC provides generators for reference
exploits, we generated a few exploits for each vulnerable binary,
for a total of 20 reference exploits (as is shown in Table I). It
is worth noting that exploits (or Proofs of Vulnerability in CGC
terminology) in CGC are special in the sense that each of them
should demonstrate attacker’s ability to fully control values in
two registers: the instruction pointer and one other register. As
a result, some generated exploits do not contain any shellcode.
We manually post-processed all exploits to make sure each
one of them has a piece of shellcode to execute in the end of
the exploitation.
3) Shellcode: As shown in Table II, we collected ﬁve
instances of replacement shellcode from three different sources,
four of which are from CGC ﬁnalists (ForAllSecure and
Shellphish), and one of which is manually crafted by ourselves.
This range of replacement shellcode instances is important: with
the shellcode coming from multiple sources, we can mimic the
setting of cyber attack customization in our experiments. We
refer to these instances as S1 through S5. Therefore, with ﬁve
instances of replacement shellcode for each of the 20 original
exploits in our dataset, we have a total of 100 modiﬁed exploits
for ShellSwap to generate.
B. Experiment Setup
One of the applications of transplanting shellcode is to
automatically reﬂect, or ricochet, an attack coming from a
rival. In this scenario, the victim ﬁrst detects an exploit coming
from the attacker. They then automatically replace the payload
(the shellcode) in the exploit and replay the modiﬁed exploit
against the attacker. We try to simulate such a scenario in our
experiment, where the attacker emits original exploits and the