      "username":"carlos",
      "email":"PI:EMAIL"
    }
## OAuth认证
现如今OAuth已经逐渐成为身份验证的手段，在OAuth身份验证中OAuth返回的数据会用于基于SAML的单点登录(sso)，OAuth身份验证通常这样实现
  * 用户选择使用其社交媒体账户登录的选项，然后客户端应用程序使用社交媒体网站的OAuth服务来请求访问用于标识用户的数据
  * 客户端应用程序收到访问令牌后会调用/userinfo端点向资源服务器请求此数据
  * 客户端应用程序接收到数据后将使用它代替用户名来登录用户，通常使用访问令牌代替
## OAuth身份验证漏洞是怎么产生的？
该漏洞部分是由于OAuth规范在设计上相对模糊且灵活，虽然每种授权类型的基本功能都需要一些强制性组件，但绝大多数实现是完全可选的，这就导致错误的操作会引发不良后果，还有一个原因就是普遍缺乏内置的安全功能，安全性几乎完全依赖于开发人员使用正确的配置选项组合并在顶部实施自己的其他安全性措施，有的授权类型因为全程都经过浏览器，这就导致所有的请求包都可以被拦截到，从而遭到恶意修改
## 识别OAuth认证
如果登录应用程序会重定向到第三方网站进行登录，大概率是使用了OAuth，进一步探测是通过在burp代理中观察经过浏览器的HTTP请求有哪些，无论哪一种授权类型，整个流程的第一个请求都是向/authorization端点发出的请求，其特点为URL中包含了很多OAuth使用的查询参数，值得注意的查询参数有client_id、redirect_uri、response_type，像这样
    GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
    Host: oauth-authorization-server.com
## 信息收集
在观察开启OAuth流程的请求包中有时可以看出使用的是哪一款OAuth服务，并且API也会有详细的文档，这些文档可以提供很多信息，例如端点的名称以及配置选项，当知道授权服务器的主机名以后，向其端点发出GET请求可以得到json格式的配置信息，像这样
    /.well-known/oauth-authorization-server
    /.well-known/openid-configuration
## OAuth认证漏洞的利用
###  OAuth客户端应用程序的漏洞
**隐式流实现不当**
在隐式流中，OAuth服务会将访问令牌以URL查询参数的形式通过浏览器返回给客户端应用程序，但是为了维持会话，客户端应用程序会通过浏览器向OAuth服务发出POST请求提交这个访问令牌，但是OAuth并没有任何验证访问令牌与其标识信息是否匹配的能力，这就是隐式信任由客户端应用程序发送来的身份信息，这就使攻击者可以通过篡改标识信息让指定用户也获得所请求的权限
**配套靶场：OAuth隐式流中的认证绕过**
先用预留的用户登录，发现OAuth流程发起的请求包
从上图来看会重定向到/oauth-callback调用API，然后我们再看看发向/oauth-callback的请求包，我们看看响应中有没有有价值的信息
从响应来看会请求/me去验证访问权限，所以我们接着跟踪到发向/me的请求包的响应
我们发现响应中有一个新的字段，从字面意思来看是邮箱验证通过了，所以后续的请求应该都是默认同意的了，所以我们找到POST请求包/authenticate，修改其中的邮箱即可，因为其中的token是通过授权的，重放包以后我们就可以登录目标用户而不需要知道它的密码了
**有缺陷的CSRF防护**
burp强烈建议非特殊原因不要缺少使用state参数，理想情况下，state参数应包含一个不可预测的值，如开启会话时某些相关信息的hash值，然后这个值以csrf令牌的形式在客户端应用程序和OAuth服务之间来回传递，但是如果整个OAuth流程不包括state参数的话就可以导致类似csrf之类的OAuth的漏洞，例如将用户绑定到属于自己的社交媒体账号上
**配套靶场：强行链接OAuth配置文件**
首先我们登录测试用户，然后进入用户中心，连接社交媒体，然后输入测试社交媒体账号，现在HTTP
History中就有了我们所有的观察样本了，我们来剖析一下，我们找到了发起OAuth流程
我们看到发起OAuth流程的请求中只有访问令牌这一个查询参数，并没有像state一样的防csrf措施，所以我们只要再截获一个有效的含有访问令牌的请求就可以利用csrf将社交媒体账户与受害者账户连接起来，于是我们重新拦截一个这样的请求
为了保持访问令牌的有效性，我们在拦截到包以后将访问令牌暂存然后丢掉这个包，然后我们在Eploit Server中构造payload
然后我们将payload分发给受害者以后，我们重新使用社交媒体账户登录发现登录进来的是管理员账号，我们就可以删除指定用户了
###  缺少授权码和访问令牌
关于OAuth最著名的漏洞可能是OAuth服务本身的配置使攻击者能窃取授权代码或访问与其他用户账户关联的令牌，窃取到有效的授权码或访问令牌后即可访问受害者的数据，甚至可以以受害者身份登录任何使用相同OAuth服务的任何客户端应用程序，一般开启OAuth流程都会由浏览器将授权码或者访问令牌发送到请求授权的redirect_uri参数指定的/callback端点，但是如果OAuth服务没有正确地验证，则攻击者可以篡改redirect_uri参数指定的/callback端点从而诱使受害者将授权码或者访问令牌发送到攻击者指定的端点，在授权码流中，攻击者甚至可以在发起OAuth流程之前获取到授权码，然后再将其发送到OAuth服务进行验证从而访问受害者账户甚至不需要知道访问令牌，只要OAuth服务与受害者之间存在有效对话，客户端应用程序就会代替攻击者完成访问令牌交换的过程，比较安全的做法就是在交换访问令牌的时候也要在请求中包含redirect_uri参数，服务器检查是否与初始授权请求中收到的匹配，如果不匹配则拒绝交换，因为这个过程对浏览器是透明的，所以攻击者无法控制这个过程
###  配套靶场：通过redirect_uri劫持OAuth账户
我们先用测试用户登录，观察HTTP
History发现开启OAuth请求的查询参数中有一个参数redirect_uri，该请求会将授权码等发往这个参数指定的端点，然后我们把这个请求发到repeater中，将这个参数值试着修改成Exploit
Server的域名
我们在Exploit
Server中接收到了由客户端应用程序发来的授权码，说明我们是可以通过篡改参数redirect_uri值来窃取授权码的，于是我们在Exploit
Server构造payload
然后分发给受害者以后我们就能在日志中接收到窃取的授权码，有了授权码以后，将其附在端点/oauth-callback的code参数中，剩下的流程会由客户端应用程序替我们完成的，将响应发到浏览器中，就成功访问目标用户页面，我们就可以删除指定用户了
**有缺陷的redirect_uri验证**
有的OAuth会通过设置redirect_uri白名单来缓解攻击者篡改redirect_uri值的攻击，但是可以通过不断测试以观察出绕过方法
  * 有的缓解方法是通过匹配字符串，所以可以通过对字符串进行删减尝试观察
  * 可以通过将其他域以参数的形式附加在redirect_uri后面可能会因为对URI解析的差异绕过白名单限制，例如`https://default-host.com &[@foo](https://github.com/foo "@foo").evil-user.net#[@bar](https://github.com/bar "@bar").evil-user.net/`
  * 还可以通过提交重复的redirect_uri参数检测是否存在服务端参数污染漏洞
  * 有时候还可能对本地URI放宽审核，以localhost开头的域名可能会轻易通过白名单检测，例如`https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net`
有时候不单单只需要测试redirect_uri参数，可能更改一个参数会影响其他参数的验证
**通过代理页面窃取授权码和访问令牌**
首先要观察是否可以将redirect_uri参数更改为指向白名单域中的其他页面，例如通过目录穿越到达其他子域，例如  
`https://client-app.com/oauth/callback/../../example/path`  
对于授权码流需要找到可以访问查询参数的漏洞，而对于隐式流需要提取URL片段，由此引发的漏洞最常见之一为开放重定向，攻击者可以利用它作为代理，将受害者的授权码或访问令牌发送到攻击者指定的可以托管任何恶意脚本的域，对于隐式流，访问令牌的作用并不仅仅用于登录受害者账户，因为全程经过浏览器，所以还可以调用API获取敏感数据，除了开放重定向，还有其他的漏洞也可以将授权码或者访问令牌发送到其他域，例如
  * 处理查询参数和URL片段的危险js
  * XSS漏洞
  * HTML注入漏洞
**配套靶场1：通过开放重定向窃取OAuth访问令牌**
首先我们登录测试用户，但是我们发现用户中心的API Key是隐藏的，于是我们对HTTP
History中相关的包都搜索一下，发现发向/me的GET请求的响应中有API Key
我们在窃取到访问令牌以后就可以通过重放这个请求包来获取它的API
Key了，于是我们将这个请求发到Repeater中，下面我们探索一下怎么窃取访问令牌，从burp的资料来看，肯定是要寻找开放重定向漏洞点来转发的，我们利用目录穿越以穿越到子域，通过寻找，我们发现Next
Post存在开放重定向
我们看到了仅仅通过修改path查询参数的值就能重定向到任意域，于是我们可以把这个构造到发起OAuth流程中，这里要注意一下，我们不能把初次发起OAuth流程的请求包发到Repeater，因为这时候是还没有有效会话的，要先退出再登录进来
从上图来看拼接到重定向的域名中的符号会被URL编码，所以我们要把这个响应发到浏览器才会正常地跳转，而且我们还发现响应中会包含访问令牌，于是我们在Exploit
Server构造这样的payload
分发给受害者以后我们就能接收到受害者的访问令牌了，于是我们修改之前/me的请求中的Authorization中的访问令牌，就能获得administrator的API
Key了
**配套靶场2：通过代理页面窃取OAuth访问令牌**
通过测试，发现redirect_uri也存在开放重定向漏洞，然后我们发现评论功能有一个/post/comment/comment-form，它会用postMessage方法向window.location.href属性值发送到父窗口
并且允许向任何来源发送，然后我们还发现评论表单会被包含在iframe中
这样我们就可以将结合开放重定向漏洞把发起OAuth流程的URL想办法拼接到iframe中以将访问令牌发送到指定的域，于是我们在Exploit
Server中构造这样的paylaod
分发到受害者以后我们就能在log中看到窃取的访问令牌，然后就能通过之前已知的/me路径查看administrator的API Key
###  有缺陷的范围验证
对于任何OAuth流，用户都必须定义授权的范围，但是存在某些漏洞导致攻击者可以扩大授权的范围，获得更大权限的访问令牌
**扩大范围：授权码缺陷**
在授权码流中，攻击者窃取到授权码，然后攻击者可以在交换授权码或访问令牌的请求中再添加其他的范围值，如果服务器没有对篡改的范围进行验证，则服务器会利用新的范围制作访问令牌并发放给客户端应用程序  
例如，假设攻击者的恶意客户端应用程序最初使用openid电子邮件范围请求访问用户的电子邮件地址。在用户批准此请求后，恶意客户端应用程序会收到一个授权码。当攻击者控制他们的客户端应用程序时，他们可以向包含附加配置文件范围的代码/令牌交换请求添加另一个范围参数，像这样
    POST /token
    Host: oauth-authorization-server.com
    …
    client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8&scope=openid%20 email%20profile
如果服务器没有根据初始授权请求的范围验证这一点，它有时会使用新范围生成访问令牌并将其发送到攻击者的客户端应用程序，像这样
    {
      "access_token": "z0y9x8w7v6u5",
      "token_type": "Bearer",
      "expires_in": 3600,
      "scope": "openid email profile",
      …
    }
然后攻击者可以使用他们的应用程序进行API调用来访问用户的个人资料数据。
**扩大范围：隐式流**
因为隐式流的所有请求都会经过浏览器，所以攻击者可以更轻而易举地在交换访问令牌的请求中添加新的范围值，只要范围值涉及的权限没有超过之前发放的权限则无需用户再次确认即可获得权限
###  未验证的用户注册
当通过OAuth验证用户时，客户端应用程序会隐式信任由OAuth提供的信息是正确的，一些提供OAuth服务的网站允许用户无需验证所有详细信息就能注册账户，包括电子邮件地址，攻击者可以使用与目标用户相同的详细信息向OAuth提供者注册账户，然后客户端应用程序可能会允许攻击者通过该账户以受害者的身份登录
## 使用OpenID Connect扩展OAuth
当用于身份验证时，OAuth通常会拓展一个OpenID Connect层，该层提供了一些与标识和身份验证用户相关的其他功能
###  什么是OpenID Connect？
OpenID