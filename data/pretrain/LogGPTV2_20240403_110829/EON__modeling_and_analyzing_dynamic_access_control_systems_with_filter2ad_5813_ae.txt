cally, let Send(x, z) denote that process x may send a message
to process z. This condition is constrained by the auxiliary con-
ditions Link(x, y, z) and Comm(x, y, z) for some port y, as fol-
lows. Link(x, y, z) requires that x and z are ready for commu-
nication, and y is actually available for communication between x
and z (see below). Comm(x, y, z) is an encoding of the requirement
xS ⊑ zR ⊓ yL for communication, as described in the beginning of
Section 5.2; the rules are generated automatically by scripts. Note
that some of the communication links that we model below turn out
to be redundant, because of taint propagation. (Indeed, some links
allow communication that is dangerous for secrecy.)
Link(x,y,z) :-
Useru(x),PortAny(y),Wu(z),Ready(z).
...
Link(x,y,z) :-
Wu(x),Ready(x),Portu(y),Ready(z).
...
Link(x,y,z) :-
Wu(x),Ready(x),PortAny(y),Wv(z),Ready(z).
...
Link(x,y,z) :-
NETd(x),Ready(x),PortAny(y),Ready(z).
Link(x,y,z) :-
Ready(x),PortDBu(y),DBproxyRu(z).
Link(x,y,z) :-
DBproxyRu(x),PortAny(y),DBproxySu(z).
Link(x,y,z) :-
DBproxySu(x),PortAny(y),Wu(z),Ready(z).
Link(x,y,z) :-
DBproxySu(x),PortAny(y),Wv(z),Ready(z).
...
Send(x,y,z) :- Link(x,y,z), Comm(x,y,z).
Finally, we model the effects of communication. Speciﬁcally,
the clauses below encode the effects of sending a message from
process x to process z, as described in the beginning of Section 5.2:
the label zS is transformed to zS ⊔ (xS ⊓ z⋆
S). For any ﬁeld ℓ, the
security level zS.ℓ does not need to be raised if min(z⋆
S.ℓ, xS.ℓ) ≤
zS.ℓ, that is, if zS.ℓ = ⋆ or xS.ℓ ≤ zS.ℓ. This condition is denoted
by LeqSTARℓ(x, z). Further, the relation Mu is augmented on such
communication. (The rules are generated automatically by scripts.)
next Mu(z) :-
Send(x,z),Mu(x),
LeqSTARut(x,z),LeqSTARvt(x,z).
LeqSTARuc(x,z),LeqSTARvc(x,z).
next Mu(z),
LSvt3(z),!LSvt1(z) :-
Send(x,z),Mu(x),
LeqSTARut(x,z),LSvt1(z),LSvt3(x).
LeqSTARuc(x,z),LeqSTARvc(x,z).
next Mu(z),
LSut3(z),!LSut1(z) :-
Send(x,z),Mu(x),
LSut1(z),LSut3(x),LeqSTARvt(x,z).
LeqSTARuc(x,z),LeqSTARvc(x,z).
next Mu(z),
LSvt3(z),!LSvt1(z),LSut3(z),!LSut1(z) :-
Send(x,z),Mu(x),
LSut1(z),LSut3(x),LSvt1(z),LSvt3(x).
LeqSTARuc(x,z),LeqSTARvc(x,z).
...
We now ask the query SecrecyViolation, which denotes
the existence of a process x that runs on behalf of v, i.e., Userv(x)
or Wv(x), but carries u’s data, i.e., Mu(x).
SecrecyViolation :- Userv(x),Mu(x).
SecrecyViolation :- Wv(x),Mu(x).
? SecrecyViolation.
EON does not ﬁnd any exploits for this query. In other words,
we have the following theorem, automatically proved by EON.
THEOREM 5
(DATA ISOLATION). A user u’s data is never
leaked to any process running on behalf of a different user v.
We conclude by mentioning some statistics that indicate the scale
of this experiment. The whole speciﬁcation of the webserver is
around 250 lines of EON. The translated Datalog program contains
152 recursive clauses over a 46-ary Reachable relation (that is,
over 46-bit atomic states). Our query takes around 90 minutes to
evaluate on a Pentium IV 2.8GHz machine with 2 GB memory—in
contrast, the queries for the other examples take less than a second.
Scripts for all the examples in this section are available in [7].
6. RELATED WORK
It is well-known that the “safety" problem for access control
models (i.e., whether a given access is allowed by a given access
control model) is undecidable in general [13, 9]. Nevertheless,
there are restricted classes of access control models for which this
problem is decidable. Our work may be viewed as a step towards
identifying such classes of models: we design an expressive lan-
guage for dynamic access control systems, in which information-
ﬂow properties remain decidable.
Analyzing access control models with logic programs has a fairly
long history. We focus here only on more closely related work.
Recently Dougherty et al. [10] propose a technique to study the
security properties of access control policies under dynamic envi-
ronments. There, a policy is speciﬁed in a fragment of Datalog
without negation and recursion, and an environment is speciﬁed as
a ﬁnite state machine. The composition of the policy and the envi-
ronment is then analyzed by reduction to ﬁrst-order logic formulae.
While the authors identify some decidable problems in this frame-
work, the lack of recursion and negation limits the expressivity of
both models and queries, and it is not always possible to specify
accurate ﬁnite state machines for environments. Indeed, none of
the dynamic access control models studied in this paper can be an-
alyzed in their framework.
Sarna-Starosta and Stoller [18] study the Security-Enhanced
Linux (SELinux) system in Prolog. The SELinux system enforces
access control policies written in SELinux’s policy language. The
authors describe a tool called PAL that translates such policies into
logic programs, and analyzes them by query evaluation. Prasad
et al. [16] study both SELinux and Windows XP conﬁgurations in
Datalog in a tool called Netra. Unlike PAL, Netra is both sound and
complete, since query evaluation is decidable in Datalog (while in
Prolog is not). However, neither tool can ﬁnd vulnerabilities that
are exploited dynamically. Some of these concerns are addressed
by Stoller et al.’s recent work on policy analysis for administrative
role-based access control [19], which is similar in spirit to ours.
More recently, Becker et al. [2] propose a language called Sec-
PAL that can express authorization policies and ﬁne-grained del-
egation control in decentralized systems. Their speciﬁcations are
compiled down to programs in Datalog, much as in our work. Since
Datalog is a subset of EON, it follows that EON is at least as ex-
pressive as SecPAL. On the other hand, it is not clear whether Sec-
PAL is as expressive as EON; the former is tailored to express au-
thorization and delegation policies, while the latter remains largely
agnostic in that respect. An interesting aspect of SecPAL is that
it allows negations within queries. While EON allows such nega-
tions, the fragment discussed in Section 4 does not. However, we
have checked that this restriction can be lifted from that fragment
without compromising correctness or efﬁciency.
Other relevant work includes Blanchet’s ProVerif [5], which is
a powerful tool that can analyze security protocols written in the
applied pi-calculus. The underlying engine rewrites the protocols
and associated equational theories into Prolog-like rules, and uses
customized resolution procedures to answer queries about secrecy
and authenticity properties. ProVerif is sound but not complete; it
may not terminate on queries, and it may also fail to prove or dis-
prove queries. Indeed, while ProVerif can handle Windows Vista’s
access control model, it does not terminate on our model of As-
bestos’s webserver. In sum, EON is less expressive than ProVerif;
but for models that satisfy our restrictions, EON guarantees sound
and complete results.
Finally, we are not the ﬁrst to propose a dynamic language based
on Datalog. Related languages have been studied, for instance, by
Abadi and Manna [1] and Orgun [17]. However, we seem to be the
ﬁrst to introduce a new operator to Datalog, and show that it can be
reduced to existential quantiﬁcation in Datalog. Such an operator
allows us to express speciﬁcations that quantify over an unbounded
number of processes and objects.
7. CONCLUSIONS
In this paper, we present EON, a logic-programming language
and tool that can be used to model and analyze dynamic access
control systems. Security violations can be modeled as temporal
queries in this language, and query evaluation can be used to ﬁnd
attacks. We show that query evaluation in EON can be reduced to
decidable query satisﬁability in a fragment of Datalog, and under
further restrictions, to efﬁcient query evaluation in Datalog.
Our design of EON requires much care to keep query evaluation
decidable. In particular, we require that any base relation that is in-
troduced or transformed be unary—allowing dynamic binary base
relations easily leads to undecidability [7]. Moreover, we require
transitions to have monotonic guards, and queries to be monotonic.
These restrictions do not prevent us from modeling state-of-the-
art access control models, such as those implemented by Windows
Vista and Asbestos. With unary base relations and new clauses,
we can create and label processes and objects. Further, with next
clauses, we can model runtime effects such as dynamic access con-
trol, communication, and taint propagation. Thus, EON turns out
to be a good ﬁt for modeling dynamic access control systems.
Further, we demonstrate that EON can verify various security
properties of interest. Since our query evaluation strategy is both
sound and complete, EON either ﬁnds bugs or decisively proves the
absence of bugs. We expect that there are other classes of systems
that can be modeled and analyzed using this approach.
8. REFERENCES
[1] M. Abadi and Z. Manna. Temporal logic programming.
Journal of Symbolic Computing, 8(3):277–295, 1989.
[2] M. Becker, C. Fournet, and A. Gordon. Design and semantics
of a decentralized authorization language. In CSF’07:
Computer Security Foundations Symposium. IEEE, 2007.
[3] D. E. Bell and L. J. LaPadula. Secure computer systems:
Mathematical foundations and model. Technical Report
M74-244, MITRE Corp., 1975.
[4] K. J. Biba. Integrity considerations for secure computer
systems. Technical Report TR-3153, MITRE Corp., 1977.
[5] B. Blanchet. An efﬁcient cryptographic protocol veriﬁer
based on prolog rules. In CSFW’01: Computer Security
Foundations Workshop, page 82. IEEE, 2001.
[6] A. Chaudhuri, P. Naldurg, and S. Rajamani. A type system
for data-ﬂow integrity on Windows Vista. In PLAS’08:
Programming Languages and Analysis for Security, pages
89–100. ACM, 2008.
[7] A. Chaudhuri, P. Naldurg, S. Rajamani, G. Ramalingam, and
L. Velaga. EON: Modeling and analyzing dynamic access
control systems with logic programs. Technical Report
MSR-TR-2008-21, Microsoft Research, 2008. See http:
//www.soe.ucsc.edu/~avik/projects/EON/.
[8] M. Conover. Analysis of the windows vista security model.
Symantec Report. Available at www.symantec.com/
avcenter/reference/Windows_Vista_
Security_Model_Analysis.pdf.
[9] D. E. Denning. A lattice model of secure information ﬂow.
Communications of the ACM, 19(5):236–243, 1976.
[10] D. J. Dougherty, K. Fisler, and S. Krishnamurthi. Specifying
and reasoning about dynamic access-control policies. In
IJCAR’06: International Joint Conference on Automated
Reasoning, 2006.
[11] P. Efstathopoulos, M. Krohn, S. VanDeBogart, C. Frey,
D. Ziegler, E. Kohler, D. Mazières, F. Kaashoek, and
R. Morris. Labels and event processes in the Asbestos
operating system. In SOSP’05: Symposium on Operating
Systems Principles, pages 17–30. ACM, 2005.
[12] A. Y. Halevy, I. S. Mumick, Y. Sagiv, and O. Shmueli. Static
analysis in datalog extensions. Journal of the ACM,
48(5):971–1012, 2001.
[13] M. A. Harrison, W. L. Ruzzo, and J. D. Ullman. On
protection in operating systems. In SOSP’75: Symposium on
Operating systems Principles, pages 14–24. ACM, 1975.
[14] B. W. Lampson. Protection. ACM Operating Systems Review,
8(1):18–24, Jan 1974.
[15] P. Loscocco, S. Smalley, P. Muckelbauer, R. Taylor,
J. Turner, and J. Farrell. The inevitability of failure: The
ﬂawed assumption of security in modern computing
environments. Technical report, NSA, 1995.
[16] P. Naldurg, S. Schwoon, S. Rajamani, and J. Lambert. Netra:
seeing through access control. In FMSE’06: Formal Methods
in Security Engineering, pages 55–66. ACM, 2006.
[17] M. A. Orgun. On temporal deductive databases.
Computational Intelligence, 12:235–259, 1996.
[18] B. Sarna-Starosta and S. D. Stoller. Policy analysis for
security-enhanced linux. In WITS’04: Workshop on Issues in
the Theory of Security, 2004. Available at http://www.
cs.sunysb.edu/~stoller/WITS2004.html.
[19] S. D. Stoller, P. Yang, C. Ramakrishnan, and M. I. Gofman.
Efﬁcient policy analysis for administrative role based access
control. In CCS’07: Conference on Computer and
Communications Security. ACM, 2007.
[20] J. D. Ullman. Principles of Database and Knowledge-base
Systems, Volume II: The New Technologies. Computer
Science Press, New York, 1989.
[21] S. Zdancewic and A. C. Myers. Robust declassiﬁcation. In
CSFW’01: Computer Security Foundations Workshop, pages
5–16. IEEE, 2001.