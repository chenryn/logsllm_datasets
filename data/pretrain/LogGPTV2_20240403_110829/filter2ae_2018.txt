先知技术社区独家发表本文，如需要转载，请先联系先知技术社区授权；未经授权请勿转载。先知技术社区投稿邮箱：PI:EMAIL；
## **1分析环境**
​ 操作系统：Window xp sp3  
​ 软件 ：Office 2003
## **2 基本信息**
​ 漏洞类型：栈溢出
​ 影响范围：Microsoft Office 2003 SP3版本、2007 SP2版本和SP3版本、 2010 Gold版本和SP1版本， Office
2003 Web Components SP3版本，SQL Server 2000 SP4版本、2005 SP4版本和2008
SP2版本、SP3版本和R2版本， BizTalk Server 2002 SP1版本，Commerce Server 2002 SP4版本、2007
SP2版本、2009 Gold版本和R2版本，Visual FoxPro 8.0 SP1版本和9.0 SP2版本和Visual Basic 6.0
Runtime版本
## **3漏洞分析**
样本MD5: 6734638ae4183aa634da2026a11e95ba
样本类型：rtf
这个样本是在漏洞利用经典的弹出计算器，在看见计算器的时候，我们知道已经成功利用成功，控制EIP,执行任意指令。
我们可以根据弹出的这个计算器，下一个执行断点，如图所示。
我们成功断到了WinExec这个断点，我们可以发现返回地址是栈地址，可以比较确定这次是栈溢出，我们执行完之后，然后返回到栈地址
这个时候我们用kb可以发现栈函数地址，这里可以用这个地址继续分析，但是我们用了另外一种分析方法，继续进行分析
我们返回到了栈地址，发现了shellcode,但是我们并没有在被覆盖的栈地址上面找到其他模块的返回地址
这个时候我们00127bed下内存写断点的方法，并通过观察内存的变化，来断到是什么操作导致了内存被覆盖，我们看见我们在这个地址下内存写断点是不可以的，提示数据点必须对齐，这个时候我们原地址减一就可以了
我们这个时候下了两个断点，由于在、内存写断点在栈地址空间，写入很频繁，观察栈地址需要无数步，这个时候我们又下个执行断点
我们只要一直按住F5就行了，直到弹出计算器，这个时候我们看看断点记录窗口，我们注意到在WinExec执行断点上面的断点是拷贝，我们重点关注下这个地址
由于MSCOMCTL.OCX模块开始并没有加载到内存中，我们在下一个加载断点
在加载后，我们这个时候在拷贝的地方下个断点，这个时候，看看拷贝的是不是shellcode
经过了几次F5，我们终于看到了拷贝的shellcode,这个时候知道了确实这里导致了溢出
我们返回后，发现拷贝函数是在275c89c7,我们看到这里只分配了0x14h大小的栈空间，我们重点分析下这个函数
我们通过分析这个函数，发现这里会进行两次拷贝，首先拷贝12个字节，这个时候栈中还剩8个字节，再次拷贝的时候，超过8个字节导致溢出
我们这个时候看一下shellcode的什么位置，我们可以看到样本是一个RTF文档，里面有一个objdata对象，我们将这个对象提取出来。
我们将里面的objdata对象提取，可以看到里面是OLE对象
我们将OLE对象提取放到offVIS中进行分析
我们可以清楚的发现其中的shellcode
我们在来看看如何控制复制的大小，下面是第一次复制的12个字节的数据，可以看到正式复制的shellcode上面的数据
可以结合IDA的伪代码进行分析，在拷贝了12个字节后，会对是否为Cobjd对象进行判断，然后对复制的大小进行判断通过动态调试可以发现比较的正是上面的0x008282。
# **总结**
这里我们知道漏洞的原理，主要是对复制数据大小的错误判断导致，本来这里只有8个字节的空间了，但是却判断是否大于等于8个字节，当构造的数据大于8个字节的时候，导致溢出