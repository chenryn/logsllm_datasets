exactly match
range check
exactly match
regular expression combined DFA
length checking
Implementation
balanced binary search tree
balanced binary search tree
trie
balanced binary search tree
Table 2: Typical implementations of different matchers.
4.2.2 Runtime Process
In this section, we ﬁrst illustrate the method to obtain the candi-
date rules for a single matcher. After that, we propose the iterative
approach to combine the candidate rules among multiple matchers.
At last, we analyze the complexity of the algorithm.
Single Matcher Matching: For each matcher (column) in the sig-
nature table, we check the conditions (cells) requiring that matcher
simultaneously by using a searching data structure. For example,
when checking which string in different conditions (cells) is equal
to the string X, we can build a trie in pre-computation and lookup
the string X in the trie simultaneously. As shown in Figure 4, for
matcher 1 (method ==), we look up the string “POST” in the trie,
and decide rule 3 matches based on Table 1. In Table 2, we describe
the example implementations for all types of matchers.
One exception is that, if in a signature the right operand of a
matcher is a protocol ﬁeld (a variable) rather than a constant, we
have to match it separately instead of using the implementations in
Table 2. Nevertheless, we can still add the result to the candidate
set and follow the same candidate selection process (§4.2.2). Fortu-
nately, For the real-world vulnerabilities, those cases are very rare.
Thus, the performance will not degrade much. In such a case, the
right operand ﬁeld has to be buffered beforehand. To our knowl-
Algorithm 2 CandidateSelection_Runtime()
S ← φ; T ← 0;
encode don’t care information into bitmap M AP ;
For M atcheri in AllM atchers
Match M atcheri and get Ai and Bi;
T ← T + |RBi|;
S ← Otimes(S, Ai, M atcheri, M AP );
append Bi to S;
If (S == φ And T == N) Return φ;
Endfor
Return S;
Function Otimes(S,A,M ID,M AP ) //⊗ operator
N S ← φ;
For RuleID in S
If (M AP [RuleID][M ID]==1)
If (RuleID ∈A) add RuldID to N S;
Else
add RuleID to N S;
Endif
Endfor
Return N S;
edge, in all existing cases, the ﬁelds are integers, so the buffer over-
head is not high.
Candidate Selection Process: After matching a matcher, we iter-
atively combine the results with previous matchers’ together efﬁ-
ciently. We deﬁne Ai, Bi and Si as follow. After matching the
arrived protocol ﬁeld against the corresponding matcher Mi, we
obtain the set of candidates as Ai+Bi. Ai is the set of candidates of
Mi from RB1 . . . RBi−1, i.e., the rule blocks shared with previous
matchers. Bi is the set of candidates of Mi from RBi, i.e., the rule
block extended by Mi solely. No candidate is from the rule blocks
later than RBi because Mi has wildcards on those rule blocks. Si
is the set of rule candidates after matching matcher M1 . . . Mi. Si
is only affected by the RB1 . . . RBi, because the rules after RBi
all have wildcards for M1 . . . Mi. S1 can be directly obtained by
matching the arrived protocol ﬁeld against M1 on rule block RB1.
In general, we use the iteration Si = Si−1 ⊗ Ai + Bi to obtain
Si from Si−1. Since Si−1 is also from RB1 . . . RBi−1, we need
to merge Si−1 and Ai by using a special operation ⊗. ⊗ is a “spe-
cial” set intersection with wildcard support. For each element e in
Si−1, two ways lead it to Si−1 ⊗ Ai: either e don’t care Mi (has
a wildcard) or e in Ai. Since Bi and Si−1 ⊗ Ai are from different
rule blocks, they are mutually exclusive. We simply append Bi to
get Si (achieve set union +). In Figure 4, the arrows show how
we obtain the S1 to S5 upon the arrival of the corresponding pro-
tocol ﬁeld. The whole PDU is given at the beginning of the ﬁgure.
For instance, from Table 1 we know, “POST” will match rule 3, so
S1 = {3}. Next, we check “fp40reg.dll” against the second col-
umn (matcher) in Table 1. When it matches RB1, we get A2 = φ,
and when it matches RB2 we get B2 = {6}. Then we calculate
S2 = S1 ⊗ A2 + B2. S1 = {3}, and rule 3 requires M2 but not in
A2; therefore, S1 ⊗ A2 = φ. Finally, we get S2 = {6}.
In Algorithm 2, |RBi| represents the number of rules in RBi.
The bitmap M AP encodes 0 if a cell in the signature table is a
wildcard; otherwise 1. To check whether an element in Ai set can
be achieved in O(1) by hash table or TCAM, or in O(log(|Ai|)) by
balanced binary search tree. One optimization we add is that, if the
candidate set from all signatures (T == N) is already empty, we
stop the matching right away, before applying the other matchers.
Complexity Analysis: We analyze the complexity of Algorithm 2.
In the iteration Si = Si−1 ⊗ Ai + Bi, Ai reduces the size of Si−1
by ﬁltering out some elements, and Bi enlarges the Si−1 to get
Si. Because Si−1 ⊗ Ai and Bi are mutually exclusive, appending
Bi to Si has negligible overhead. This shows another advantage
of our scheme that is to decouple the candidate set addition and
deletion. The main overhead of the iteration comes from Si−1⊗Ai
283j=1
N−j
N−1
j=1 |Bj|, so avg(|Si|) ≤ PN
which is O(|Si−1|). Therefore, we can use the average of |Si|
(i ∈ [1, N − 1]) as the metric to optimize the speed. We denote
it as avg(|Si|). As long as we manage avg(|Si|) to be small, the
overhead will be small. We ﬁnd |Bi| can be used to bound the
avg(|Si|). |Si| ≤ Pi
|Bj|.
The proof is in our tech. report [19]. The bound is not tight, but it
gives us a hint that the matchers at beginning are more crucial since
their |Bi| contribute more to avg(|Si|). In our evaluation (§7.2),
we ﬁnd avg(|Si|)  Buf Len)
ﬁnd Mj in BU F with minimum estmaxB(Mj);
remove Mj from BU F , and append Mj to OrderM;
Endwhile
Endif
EndFor
Return OrderM;
maximum number of vulnerabilities with the same UUID, because
the UUID ﬁeld is required by all the signatures and very selective.
In our evaluation WINRPC ruleset avg(|Si|) ≤ 3. For HTTP, we
ﬁnd no reordering is necessary. Since it is hard to prove a bound for
HTTP, we generate the worst case trafﬁc to evaluate it. It turns out
that to generate the worst case trafﬁc is a NP-Hard problem (proven
in our tech. report [19]). We use a greedy approach to maximize the
|Si| at each step. The result shows that the approximate worst case
trafﬁc can achieve about 68.4% of the throughput of normal traces,
which demonstrates that the CS algorithm works reasonably well
under the worst case trafﬁc.
Stateful NIDSes/NIPSes all subject to state holding attacks.
the key metric is how many connections (states) can
Then,
be sustained.
Including NetShield, most payload inspection
NIDS/NIPSes only create states for successful connections with
application payloads. Thus, IP spooﬁng does not work here. Eval-
uation shows that our design needs on average 28 bytes/connection
for HTTP and 32 bytes/connection for WINRPC. We believe our
design is capable to handle millions of connections and thus is ro-
bust to attacks.
4.4 Algorithm Reﬁnement
Allow a negative condition. A signature may require a negative
condition on a matcher. For example, a signature requires that the
regex “.*abc” cannot be matched on the HTTP ﬁlename ﬁeld. For
such cases, we can put the signature in Si by default, and remove it
if it is matched.
Handle a list of ﬁelds.
In many protocols, protocol ﬁelds may
form arrays or associative arrays. For these cases, the conditions
in signatures may need to use “any” or “all” operators. For exam-
ple, a condition requires that all the lengths of the directories in a
URI be smaller than 100. Another example would be checking if
any of the lengths of directories is larger than 100. “All” can al-
ways be expressed by “not” and “any”. Thus, in our design, we
just model “not” and “any”. The “any” cases are quite common in
the vulnerability signatures. For “any” cases, we check each of the
elements of the array with the matcher to accumulate Ai and Bi.
Some rules may require multiple “any” conditions on the same ar-
ray to be met simultaneously (an AND relationship). In that case,
we just treat each such condition as a separate matcher, and use the
CS algorithm to merge them.
Handle the mutually exclusive ﬁelds. We treat the matchers re-
lated to mutually exclusive ﬁelds as a group. If one of the mutually
284exclusive ﬁelds is present, we know all the other ﬁelds will not ap-
pear. Thus, we can directly delete all the candidates belonging to
them. Then, we skip the whole group of matchers and continue
with the next matcher not in the group.
4.5 Extension to Multiple PDU Matching
Most simple multiple PDU protocols do not have transition loops
in their protocol state machines. We can directly extend the single
PDU CS algorithm to these protocols. Without transition loops, the
ﬁelds arrive sequentially, which is similar to a single PDU case. For
the protocols with transition loops, we need to make an enhance-
ment. Basically for each transition loop, the protocol goes back
to a previous state and resends certain PDUs. We use the concept
of checkpoints to save the scenarios of the candidate selection pro-
cess, so that when it jumps back to an old state, we can restore the
checkpoint and start from there again. What we need to save in
the checkpoints are the candidate set Si of the last matcher of the
previous PDU and the position of the buffer at that instant.
5. AUTOMATIC LIGHTWEIGHT PARS-
ING
We need protocol parsing to recover the protocol ﬁelds for vul-
nerability signature matching. However, manually building proto-
col parsers is tedious and error-prone. We design and implement
UltraPAC, an efﬁcient automated protocol parser generator. Ultra-
PAC generates C++ code for protocol parsing, given a program-like
protocol description. The generated parser is specially designed
for signature matching and is much faster than the state of the art.
Meanwhile, it is general enough to handle all protocol and language
features supported by BinPAC [20].
5.1 Stream Parser For Signature Matching
To clarify the description, we deﬁne some terms as follows: each
PDU corresponds to a protocol parse tree (concrete syntax tree),
which is a hierarchy of protocol ﬁelds. The leaf nodes of the
parse tree correspond to simple data objects, including numbers and
strings. The inner nodes correspond to more complex data objects,
such as arrays of numbers, strings or C-like “struct” or “union”.
We deﬁne the leaf nodes as basic ﬁelds and the inner nodes as com-
pound ﬁelds.
BinPAC [20] and GAPA [9] are two major efforts towards build-
ing yacc-like tools for tree parser generation, i.e., the parser that re-
construct the protocol parse tree. Both use recursive descent parsers
(top-down parsers).
However, we are targeting at the protocol parsing problem solely
for signature matching. The stream parser is sufﬁcient for this
purpose, i.e., the parser that recovers protocol ﬁelds consecutively
from an input stream. We make three important distinctions.
First, a parsed ﬁeld is used once by the matching engine and
never used again. The parser does not have to preserve a copy
of it anywhere. Second, we only need to parse the ﬁelds which
are either directly required by the vulnerability signature matching
(Type-I ﬁelds) or indirectly required for parsing Type-I ﬁelds (Type-
II ﬁelds), e.g., the header.qdcount ﬁeld in DNS protocol that
speciﬁes how many question records the PDU has. Third, Type-
I and Type-II ﬁelds are basic ﬁelds in dominant cases, as shown
in Figure 2. We further validate this observation by studying the
vulnerabilities targeted by Snort and related literature [9, 10, 13,
29].
5.2 Limitations of Existing Work
The BinPAC parser is faster than the GAPA one, so we focus
our analysis on BinPAC. We divide the major overhead into three
parts: (a) buffer management, the cost to copy network trafﬁc into
Variable
Variable
Variable
derive
Figure 5: The building blocks of parsing state machine.
the buffer and expand/shrink buffer at runtime, (b) parse tree traver-
sal, the cost to construct and take down tree nodes and the recursive
descent parsing function calling, and (c) protocol ﬁeld extraction,
the cost to compute the ﬁeld length, record starting and ending po-
sition, update parsing state, etc.
BinPAC is not optimal for our protocol parsing purpose, i.e., for
signature matching. Ideally, overhead (a) should be removed, since
the parser only needs to record and return the starting and ending
position of the protocol ﬁeld, even in the rare case where one ﬁeld
is separated in several packets. Overhead (b) is also unnecessary
because the parser does not need to construct the complete view of