## 前言
如果说一个产品RCE漏洞相对描述是“一语中的”、“一发入魂”的杀气，想必各大厂商在对杀气感知和处理上总是最快最灵敏的，从各大专有SRC对报告的反映速度、修复速度、挖掘难易程度来说，也很好的佐证了这一点。log里保存着任何服务器接收到的数据原文随时溯源当场处理爱憎分明、系统环境在被攻击时的奇怪变化一看便知，一个好的RCE确实是无敌的，至少在被受攻击者审计出来前，高效便捷准确有效。但它一旦被使用，变会在厂商眼皮下留下“挨打痕迹”。
另一对立面的“面向用户攻击”就没RCE那么方便了，比如一个简单的xss或者csrf的利用，虽然可以在不侵入和损坏框架主体的情况下触发，但需要用户少许的参与，增加了攻击的难度和不确定性。but!!话说回来这种不确定性和非侵入性的攻击方式，也正是它的优势所在：在用户主动反馈或者直接以运营方为攻击目标以外，即使发动攻击也极难被察觉或发现痕迹。（这就跟出老千与截胡的区别一样，出千时需要破坏牌的动作或在牌桌上做手脚留下痕迹，而截胡只需要在正常流程前完成攻击即可）
>
> 教挖洞、教blablabla那些真没用，挖bounty真的很靠个人对业务理解和最终实现手法的，所以请注意，本文主要解释遇到利用链瓶颈时，如何合理结合新特性、框架特征、原有逻辑等帮助你提升和完成整个利用，而不会对你怎么快速挖到xss怎么速挖SRC项目有任何帮助，总而言之很明确说就是对新手不友好，很多前期知识得自己去搜。对，我就是懒得写咋的吧。
## 常规csrf-token位置与获取方法
  1. cookie中
  2. form表单
  3. URL参数
首当其冲当然是cookie中的token，看似无解但实际有xss的环境便可，目前并没看到把token做http-only的。如果从cookie中提取再动态构造表单那没法获取了，单是验证cookie内容的话，怎么可能嘛csrf-token毕竟就是防csrf发生的。如果拥有xss肯定容易拿到cookie里的token，当然在其他能发出流量并得到返回值的情况中通过fetch重新获取一个也可以，普通原理这里不做过多说明了。
### form表单中的token
如果碰到token处于input中请莫慌，使用xss自然是很容易拿到标签中的value属性，但是如果一个页面能够注入DOM但无法找到有效的dom-xss-payload时，你就需要一个骚气的泄露token姿势了。
我们来看一个例子：
      secert
      public
    user's note blablabla...
假设你在这个页面找到个DOM类型的self-xss，不过有这样的限制区别：
  * 如果用户提交secert类别的内容，那页面将保留所有原始DOM，但限制仅能自己查看和触发，其他人看不到这条note的内容。
  * 但如果你发布的public文本内容，文本则可以公开给所有人浏览，不过危险的event和用于危险的标签DOM全被waf过滤了。
这时候，如果直接提交个self-xss报告确实略显单薄，官方给个忽略也不过分嘛，毕竟无法造成实质性的对 **其他用户/指定用户**
造成攻击影响（叽己打叽己可木有用啊熊迪）。
那如何将self升级成任意可以触发的xss就是关键拿分点，哪怕也忽略至少你可以让审核都觉得这思路骚暴，武力值+10。
我们来看看html5特性里给表单带来的新玩意儿：  
这个时候思路变逐渐明了，只要尝试劫持表单让用户主动创建一个secert类型的note，就能让self-xss变成thatUser-self-xss了，虽不是任意触发，但我用self-xss一次打一个用户，也算定向攻击嘛。
首先测试一下，构造一个public的payload且只需一行，完成劫持user-edit的表单：
发布后发现，虽然是用户编辑出来的一个input标签，但在其他用户点击的情况下，成功触发了他所在页面的正常表单。要是这个表单是user-delete，那可真就是。。号没了警告.jpg。完成从其他按钮触发页面本来的表单后，我们使用其他`form*`属性来劫持修改表单值：
可见，在用户点击后，我们成功把以上的可控表单内容注入到了本来页面中id为user-edit的表单里，完成劫持主动触发。而GET也好POST也罢，我们都知道只取最后一个同名的传入值，可以测试`echo
$_GET["a"]`然后访问`/?a=1&a=2&a=3`，最终我们只能取到最后一个传入`a=3`，所以不用管表单里原来的内容，通过input属性劫持form我们就能成功直接覆盖原来的值。所以如果还在考虑类型默认是点击在`public`上这种情况？顺理成章我们加一个``把`public`覆盖成`off`即可 :P
再其次，有没有其他触发方式？当然有鸭~我们可以改变`action`直接把所有input的value都带出到外部服务器。
  1. 我们可以先只尝试拿到token，在进行其他操作：
  1. 页面还存在iframe，且iframe的URL里同时拼接了token为query参数，我们也能这样通过iframe内部框架的跳转带来的referrer属性获取token：
比如：
      secert
      public
虽然a标签的行为可能被代理跳转或安全处理了no-referrer属性，但通过找到一个没有sandbox和其他安全限制的iframe来劫持为form的`target`，就成功绕过了URL带出token的referrer限制。
### URL参数中的token
  1. 通过A标签获取
    get_token
通过a标签跳转，我们能轻易从referrer中得到URL里拼接的token，但就目前看来稍有安全意识的开发，绝对会带上no-referrer属性，或者通过safe_jump_url的某些检查方式通过一个没有token的301页面或短链接转化，来脱敏并代为跳转。
那解决方案除了如上所述，通过input劫持我们能在iframe中跳转内部页面巧妙的拿到referrer中的URL，其实还有一个html5的新属性和特殊处理可以利用——ping属性！
好像没找到中文w3c属性介绍，可以看一下freebuf的文章
    ping_leak
通过如上payload，我们能完成用户的行为跟踪。本来吧，这个ping属性就是用来统计点击或者跟踪行为的，但是实际你也可以用来盗取token。我们看看另外一个前端魔法：url-hash
hash在URL中起到的作用是锚点，它会在用户点击后 **滚动页面导航到所在的位置，而不是跳转刷新当前页面**
，因为hash锚点标签，其实只是用户浏览器的行为，并没有影响整个页面也没有新请求流量产生。