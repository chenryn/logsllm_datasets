# chrome sandbox escape case study and plaidctf2020 mojo writeup
## mojo
### Intro to Mojo & Services
#### mojo术语
message
pipe是一对endpoints，对应通信的两端，每个endpoint保存一个传入消息队列，并且在一端写入消息可以有效地传送到另一端，因此message
pipe是双向的。  
一个mojom文件描述一组interfaces，其代表的是强类型的消息集合。  
给定一个mojom接口和一条message
pipe，可以将其中一端指定为Remote，用来发送该接口描述的消息，另一端指定为Recevier，用来接收接口的消息。  
注意:上面的概括有点过于简化。请记住，消息管道仍然是双向的，mojom
message有可能期望得到response，response是从Receiver端点发送的，并由Remote接收。  
Receiver端必须和mojom接口的具体实现(implementation)相绑定，从而将收到的消息分发给对应的接口实现函数。
#### 定义一个新的Frame Interface
假设我们想从render
frame向其对应在browser进程里的RenderFrameHostImpl发送一个“Ping”消息，我们需要去定义一个mojom
interface，创建一个pipe去使用这个interface，然后绑定好pipe的两端以发送和接收消息。
##### 定义一个interface
第一步是去创建一个.mojom文件
    // src/example/public/mojom/ping_responder.mojom
    module example.mojom;
    interface PingResponder {
      // Receives a "Ping" and responds with a random integer.
      Ping() => (int32 random);
    };
对应创建一个build rule去生成c++ bindings
    # src/example/public/mojom/BUILD.gn
    import("//mojo/public/tools/bindings/mojom.gni")
    mojom("mojom") {
      sources = [ "ping_responder.mojom" ]
    }
##### 创建pipe
现在，让我们创建一个消息管道以使用此接口。通常，为了方便起见，在使用Mojo时，接口的client（即remote）通常是创建新pipe的一方。这很方便，因为可以使用Remote来立即发送消息，而无需等待InterfaceRequest端点被绑定到任何地方。
    // src/third_party/blink/example/public/ping_responder.h
    mojo::Remote ping_responder;
    mojo::PendingReceiver receiver =
        ping_responder.BindNewPipeAndPassReceiver();
在此示例中，ping_responder是Remote，并且receiver是PendingReceiver，这是Receiver的前身。BindNewPipeAndPassReceiver是创建消息管道的最常见方法:它产生PendingReceiver作为返回值。  
注意：一个PendingReceiver实际上不执行任何操作。它是单个消息管道端点的惰性持有者。它的存在只是为了使其端点在编译时具有更强的类型，这表明该端点希望被绑定到具体的接口类型。
##### 发送message
最后，我们可以通过Remote调用我们的Ping()方法来发送消息：
    // src/third_party/blink/example/public/ping_responder.h
    ping_responder->Ping(base::BindOnce(&OnPong));
重要说明：如果我们想接收response，则必须保持ping_responder对象处于活动状态直到OnPong被调用。毕竟，ping_responder拥有消息管道端点。如果它被销毁了，那么端点也将被销毁，将没有任何东西可以接收到响应消息。  
我们快完成了！当然，如果一切都这么简单，那么该文档就不需要存在。我们已经解决了将消息从render进程发送到browser进程的难题，并将其转化为一个问题:  
我们只要把上面的receiver object传递给browser进程，就可以让receiver来分发它收到的消息到具体的实现函数里。
##### 发送PendingReceiver给Browser
值得注意的是，PendingReceivers（通常是消息管道端点）也是可以通过mojom消息自由发送的一种对象，将PendingReceiver放置在某处的最常见方法是将其作为方法参数传递给其他已经连接的接口。  
将render里的RenderFrameImpl和其对应的RenderFrameHostImpl连接的interface是BrowserInterfaceBroker  
这个interface是用来获取其他interface的factory，它的GetInterface方法接收一个GenericPendingReceiver（GenericPendingReceiver允许传递任意的interface
receiver）
    interface BrowserInterfaceBroker {
      GetInterface(mojo_base.mojom.GenericPendingReceiver receiver);
    }
由于GenericPendingReceiver可以从任何PendingReceiver隐式构造，所以可以使用之前通过BindNewPipeAndPassReceiver创建的receiver来调用此方法：
    RenderFrame* my_frame = GetMyFrame();
    my_frame->GetBrowserInterfaceBroker().GetInterface(std::move(receiver));
这将传送PendingReceiver到browser进程里，并被BrowserInterfaceBroker接口的具体实现接收和处理。
##### 实现interface
我们需要一个browser-side的PingResponder实现
    #include "example/public/mojom/ping_responder.mojom.h"
    class PingResponderImpl : example::mojom::PingResponder {
     public:
      // impl里保存receiver_
      explicit PingResponderImpl(mojo::PendingReceiver receiver)
          : receiver_(this, std::move(receiver)) {}
      // example::mojom::PingResponder:
      void Ping(PingCallback callback) override {
        // Respond with a random 4, chosen by fair dice roll.
        std::move(callback).Run(4);
      }
     private:
      mojo::Receiver receiver_;
      DISALLOW_COPY_AND_ASSIGN(PingResponderImpl);
    };
RenderFrameHostImpl保存一个BrowserInterfaceBroker的实现，当此实现收到GetInterface方法调用时，它将调用先前为此特定接口注册的处理程序。
    // render_frame_host_impl.h
    class RenderFrameHostImpl
      ...
      void GetPingResponder(mojo::PendingReceiver receiver);
      ...
     private:
      ...
      std::unique_ptr ping_responder_;
      ...
        // BrowserInterfaceBroker implementation through which this
      // RenderFrameHostImpl exposes document-scoped Mojo services to the currently
      // active document in the corresponding RenderFrame.
      BrowserInterfaceBrokerImpl broker_{
          this};
      mojo::Receiver broker_receiver_{
          &broker_};
    };
    // render_frame_host_impl.cc
    // 可以看到GetPingResponder使用receiver构造出了一个PingResponderImpl对象
    void RenderFrameHostImpl::GetPingResponder(
        mojo::PendingReceiver receiver) {
      ping_responder_ = std::make_unique(std::move(receiver));
    }
    // browser_interface_binders.cc
    void PopulateFrameBinders(RenderFrameHostImpl* host,
                              mojo::BinderMap* map) {
    ...
      // Register the handler for PingResponder.
      map->Add(base::BindRepeating(
        &RenderFrameHostImpl::GetPingResponder, base::Unretained(host)));
    }
我们完成了,此设置足以在renderer frame与其browser-side host之间建立新的接口连接！  
假设我们在render中将ping_responder对象保持足够长的生命，我们最终将看到其OnPong回调将以参数4调用，如上面的browser端实现所定义。
### Mojo Basics
#### Interfaces
同上，我们再看一组interface和它的impl  
**Mojo通过callback来返回result，即正常我们看到的是return一个返回值return_value，而mojo则是在最后调用callback(return_value)来返回result**
    module math.mojom;
    interface Math {
      // Adds two int32s and returns the result as an int64 (to avoid
      // overflow issues).
      Add(int32 x, int32 y) => (int64 sum);
    };
    ...
    mojom("mojom") {
      sources = ["math.mojom"]
    }
    ...
    class MathImpl : public math::mojom::Math {
     public:
      explicit MathImpl(mojo::PendingReceiver receiver)
          : receiver_(this, std::move(receiver)) {}
      // math::mojom::Math overrides:
      // Note: AddCallback is a type alias for base::OnceCallback.
      // The parameters to the callback are the reply parameters specified in the
      // Mojo IDL method definition. This is part of the boilerplate generated by
      // Mojo: invoking |reply| will send a reply to the caller.
      void Add(int32_t x, int32_t y, AddCallback reply) override {
        // Note: Mojo always returns results via callback. While it is possible to
        // make a sync IPC which blocks on the reply, the handler will always return
        // the result via callback.
        std::move(reply).Run(static_cast(x) + y);
      }
     private:
      // Wraps a message pipe endpoint that receives incoming messages. See the
      // message pipes section below for more information.
      // wrap消息管道的receiver端
      mojo::Receiver receiver_;
    };
#### Message Pipes
message pipe的两端已经在上面说过了，不再赘述
    // Wraps a message pipe endpoint for making remote calls. May only be used on
    // the sequence where the mojo::Remote was bound.
    mojo::Remote remote_math = ...;
    ...
    // 通常是保存在mojo impl里的一个类成员，wrap message pipe的receiver端，其分发ipc消息到具体的handler（典型的来说，就是发给this,也就是impl)，
    // Usually a class member. Wraps a message pipe endpoint that receives incoming
    // messages. Routes and dispatches IPCs to the handler—typically |this|—on the
    // sequence where the mojo::Receiver was bound.
    mojo::Receiver receiver_;
总之，作为结论，对于某一个interface，sender A可以向receiver
B进行任意数量的call，而B则可以针对A的每一次call发送一个response给A处理，这就体现出了一种有限的双向通信。  
Message Pipes可以使用下述方法创建
##### mojo::Remote::BindNewPipeAndPassReceiver
当sender/caller创建endpoint时使用。保留一个endpoint以发送IPC消息，另一端点作为未绑定的`mojo::PendingReceiver`返回，以便receiver/callee绑定到`mojo::Receiver`
    mojo::Remote remote_math;
    // BindNewPipeAndPassReceiver返回一个mojo::PendingReceiver.
    // 这可以被bound到一个mojo::Receiver去处理来自remote_math的调用
    // BindNewPipeAndPassReceiver() returns a
    // mojo::PendingReceiver. This may be bound to a
    // mojo::Receiver to handle calls received from
    // |remote_math|.
    LaunchAndBindRemoteMath(remote_math.BindNewPipeAndPassReceiver());
    // remote_math可以立刻被使用，Add call消息将在receiving端排队，直到其被bound到一个mojo::Receiver.
    // 例如，被mojom的impl使用其构造receive_字段以隐式绑定或者显式的通过::Bind来绑定。
    // |remote_math| may be immediately used. The Add() call will be buffered by the
    // receiving end and dispatched when mojo::PendingReceiver is
    // bound to a mojo::Receiver.
    remote_math->Add(2, 2, base::BindOnce(...));
##### mojo::Receiver::BindNewPipeAndPassRemote
在receiver/callee创建端点时使用。保留一个端点以接收IPC，另一个端点作为未绑定的`mojo::PendingRemote`返回，以使sender/caller方绑定到`mojo::Remote`。
    class MathImpl : public math::mojom::MathImpl {
      // ...addition to the previous MathImpl definition...
      mojo::PendingRemote GetRemoteMath() {
        // BindNewPipeAndPassRemote() returns a
        // `mojo::PendingRemote`. This may be bound to a
        // `mojo::Remote which can be used to send IPCs that will
        // be handled by |this|.
        return receiver_.BindNewPipeAndPassRemote();
      }
    };
##### mojo::PendingRemote::InitWithNewPipeAndPassReceiver
不太常见，类似于`mojo::Remote::BindNewPipeAndPassReceiver()`
##### mojo::Remote/mojo::Receiver and
mojo::PendingRemote/mojo::PendingReceiver
`mojo::Remote`和`mojo::Receiver`都有相应的未绑定版本:这允许在同一进程中的sequences之间,甚至在IPC上的进程之间传递端点。
    mojo::Remote remote = ...;
    // |pending_remote| 是可移动的，并且可能会被传递。
    // 未绑定时，端点不能用于发送IPC。pending_remote可以传递给mojo::Remote 构造函数或mojo::Remote::Bind()来重新绑定端点。
    // |pending_remote| is movable and may be passed around. While unbound, the
    // endpoint cannot be used to send IPCs. The pending remote may be passed to
    // the mojo::Remote constructor or mojo::Remote::Bind() to rebind the
    // endpoint.
    mojo::PendingRemote pending_remote = remote.Unbind();
    mojo::Receiver receiver = ...;
    // |pending_receiver| is movable and may be passed around. While unbound,
    // received IPCs are buffered and not processed. The pending receiver may be
    // passed to the mojo::Receiver constructor or mojo::Receiver::Bind() to
    // rebind the endpoint.
    mojo::PendingReceiver pending_receiver = receiver.Unbind();
这里的bind和unbind实际上是通过在receiver里保存一个bind
state对象来维护的，具体的不叙，可以参考[具体代码](https://source.chromium.org/chromium/chromium/src/+/master:mojo/public/cpp/bindings/receiver.h)
### Mojo C++ Bindings API
#### Getting Started
    //services/db/public/mojom/db.mojom
    module db.mojom;
    interface Table {
      AddRow(int32 key, string data);
    };
    interface Database {
      CreateTable(Table& table);
    };
    ...
    //services/db/public/mojom/BUILD.gn
    import("//mojo/public/tools/bindings/mojom.gni")
    mojom("mojom") {
      sources = [
        "db.mojom",
      ]
    }
    ...