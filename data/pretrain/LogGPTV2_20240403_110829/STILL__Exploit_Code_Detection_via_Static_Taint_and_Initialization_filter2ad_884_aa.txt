title:STILL: Exploit Code Detection via Static Taint and Initialization
Analyses
author:Xinran Wang and
Yoon-chan Jhi and
Sencun Zhu and
Peng Liu
2008 Annual Computer Security Applications Conference
2008 Annual Computer Security Applications Conference
STILL: Exploit Code Detection via Static Taint and Initialization Analyses
1Xinran Wang
1Yoon-Chan Jhi
1,2Sencun Zhu
2Peng Liu
1Department of Computer Science and Engineering
2College of Information Sciences and Technology
Pennsylvania State University, University Park, PA 16802
{xinrwang, szhu, jhi}@cse.psu.edu; PI:EMAIL
Abstract
We propose STILL, a generic defense based on Static
Taint and InitiaLization anaLyses, to detect exploit code
embedded in data streams/requests targeting at various In-
ternet services such as Web services. STILL ﬁrst blindly dis-
assembles each request, generates a (probably partial) con-
trol ﬂow graph, and then uses novel static taint and initial-
ization analysis algorithms to determine if strong evidence
of self-modifying (including polymorphism) and/or indirect
jump code obfuscation behavior can be collected. If such
evidence exists, STILL will raise an alarm and block the re-
quest; otherwise, STILL will perform another form of static
taint analysis to check whether unobfuscated or other types
of obfuscated exploit code (e.g., metamorphism, etc) is em-
bedded in the request. To the best of our knowledge, com-
pared with existing static analysis approaches developed for
the same purpose, STILL is (a) the ﬁrst one that can de-
tect self-modifying code and indirect jump, and (b) a more
comprehensive static analysis solution in defending against
anti-signature, anti-static-analysis and anti-emulation code
obfuscation (for all the code obfuscation techniques we are
aware of, STILL is robust to all but one).
1 Introduction
Besides triggering human beings to do such unwise
things as opening malicious email attachments, disclosing
their passwords and identities, and visiting fake web sites,
human-intervention-free remote exploit code is a primary
vehicle for attackers to harvest bots and launch various at-
tacks. The most serious vulnerability exploited by binary
exploit code is buffer overﬂow, which exists pervasively
in Internet services (e.g., port 80 Web service), OS ser-
vices (e.g., Windows DCE-RPC or CIFS/SMB), database
services, applications (e.g., browser plug-ins), and so on.
Buffer overﬂow vulnerabilities allow attackers to use a net-
work request to inject a piece of exploit code into the
“body” of a service or application program. Once such ex-
ploit code is executed, the attacker may gain full control
of the victim machine.
In different attacks, exploit code
may be in different forms: a piece of shellcode to break
into a certain type of hosts, an infection vector for Internet
worms such as CodeRed and Slammer, and so on. From
both CERT [1] and Microsoft Security Bulletin [5] we can
clearly see that the majority of vulnerabilities/attacks in the
Microsoft Windows family are buffer-overﬂow based auto-
matic remote code execution.
Network intrusion detection systems (NIDSes) such as
Snort [6] use manually prepared string-matching signa-
tures to detect code-injection attacks. To contain zero-
day attacks, automatic signature generation techniques have
recently been proposed to automatically extract string-
matching signatures from malicious payloads. Some repre-
sentative examples of these techniques are EarlyBird [24],
Polygraph [21], Hamsa [17], and Packet Vaccine [29].
However, a common limitation of string-matching signature
based defenses, whether their signatures are manually pre-
pared or automatically generated, is that they (e.g., [24,27])
or their ﬂow classiﬁers (e.g., [17]) are not very resilient to
code-obfuscation.
To address the limitations of the signature-based defense
mentioned above, researchers have recently proposed sev-
eral static analysis approaches to identify and analyze the
code contained in buffer overﬂow attack packets [8, 15, 28].
These approaches are based on the observation that re-
mote exploits typically contain executables, whereas legiti-
mate client requests never contain executables in most In-
ternet services such as Web services and SQL services.
These static analysis approaches can be divided into two
stages. The ﬁrst stage is to distill instruction sequences
from network packets by disassembly. These instruction
sequences may be real code or random instructions. The
second stage is to analyze the disassembly results by ex-
ploiting control ﬂow [15] or data ﬂow analysis [8, 28] to
discern code/malicious code from data. Compared with
string-matching signature based approaches, static analysis
approaches have two notable advantages. First, they can
1063-9527/08 $25.00 © 2008 IEEE
1063-9527/08 $25.00 © 2008 IEEE
DOI 10.1109/ACSAC.2008.37
DOI 10.1109/ACSAC.2008.37
289
289
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:28 UTC from IEEE Xplore.  Restrictions apply. 
Data Stream
Disassembly and
control flow
generation
Self-modifying or
indirect jump
obfuscation code ?
No
 Plain exploit code,
metamorphic code,
etc ?
No
Pass
Yes
Block/Alert
Yes
Block/Alert
Figure 1. The architecture of STILL
detect new (or zero-day) exploit code for both known and
unknown vulnerabilities. Second, they are more resilient to
polymorphism and metamorphism.
However, by applying some anti-static-analysis obfusca-
tion techniques such as self-modifying and indirect jump
[18, 23], an attacker can evade these static analysis ap-
proaches such as SigFree [28] and [8, 15]. There are two
main techniques to thwart static analysis [23]. One aims at
thwarting disassembly via indirect jump. An indirect jump
instruction transfers control to the address contained in a
register operand and its destination is hard to be statically
determined. The other technique is to thwart control ﬂow
and data ﬂow analyses by self-modifying code. Control
transfer instructions (CTIs) can be dynamically changed to
non-CTIs at runtime by self-modifying code, thus obfuscat-
ing control ﬂows. Data transfer/operation instruction can
be changed to other instructions dynamically at runtime by
self-modifying code, thus obfuscating data ﬂows.
Our Approach We propose STILL, a novel static taint
and initialization analysis based approach, to detect not
only unobfuscated exploit code (without any obfuscation),
traditional polymorphic and metamorphic exploit code, but
also self-modifying and indirect jump obfuscation code.
STILL is based on the same observation as in [8, 15, 28]
that remote exploits typically contain executables, whereas
legitimate client requests never contain executables in most
Internet services.
STILL detects attacks as follows. It works as a proxy-
based blocker in the application layer of clients and/or
servers. When it captures a data stream, it disassembles
the data stream and generates a control ﬂow graph. It an-
alyzes the disassembled result in two stages. First, STILL
detects self-modifying and indirect jump obfuscation code.
Although the real exploit code may be hidden by self-
modifying and indirect jump, the obfuscation code itself
provides some strong evidence of self-modifying and/or in-
direct jump behavior. STILL detects this behavior by static
taint analysis and initialization analysis. Since polymor-
phism is a kind of self-modifying, STILL can also detect
polymorphic code in this stage. Of course, an attacker
might use neither self-modifying nor indirect jump obfus-
cation. Hence, in the second stage, STILL tries to detect the
plain exploit code, which may even have been obfuscated
by metamorphism. STILL also exploits static analysis and
Contributions
initialization analysis in this stage to combat other obfusca-
tion techniques. Figure 1 depicts the architecture of STILL.
The main merits of STILL are as
follows. First, STILL (including static taint analysis and
initialization analysis) is a static analysis technology that
can detect both self-modifying code and indirect jump,
whereas previous static analysis approaches [8,15,28] could
be easily thwarted by these obfuscation techniques. Sec-
ond, STILL is robust to almost all anti-signature, anti-static-
analysis and anti-emulation obfuscation. Third, STILL is a
more comprehensive solution for detecting zero-day exploit
code, regardless of whether the exploit code is obfuscated
or not. Note that although the proposed techniques, like
many intrusion detection systems, somehow look heuristic,
we believe they are very fundamental and greatly raise the
bar for future attacks.
A prototype implementation of STILL has been devel-
oped. Experimental results show that STILL successfully
detected all 12,000 polymorphic shellcode payloads gener-
ated by 10 well-known polymorphic engines, all 34 plain
Linux and Windows shellcodes generated by the Metasploit
framework, and 5 worms (CodeRed I, CodeRed II, Sasser,
Blaster, and Slammer) that are available to us. Moreover,
our large-scale testing shows that STILL has an extremely
low false positive rate.
Organization The rest of the paper is organized as fol-
lows.
In Section 2, we give an overview of exploit code
obfuscation. In Section 3, we show how we disassemble
a data stream and then generate a control ﬂow graph (3.1),
the approach to detecting self-modifying and indirect jump
obfuscation code ( 3.2), and the approach to detecting plain
exploit code ( 3.3). We show the strength of STILL and
discuss the limitations in Section 4. In Section 5, we show
our experimental results. Finally, we summarize the work
related to ours in Section 6 and conclude the paper in Sec-
tion 7.
2 Obfuscation of Exploit Code
In this section, we give a brief overview of the known
techniques for obfuscating exploit code. We classify these
obfuscation techniques into three categories according to
their purposes: anti-signature, anti-static-analysis and anti-
emulation. We show how anti-static-analysis thwarts pre-
290290
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:28 UTC from IEEE Xplore.  Restrictions apply. 
vious static analysis techniques such as SigFree [28] and
others [8, 15]. We will discuss the effectiveness of STILL
in handling these obfuscation techniques in Section 4.
2.1 Anti-signature
Anti-signature obfuscation is the type of obfuscation
techniques for thwarting traditional string-matching signa-
ture based detection. It includes metamorphism and poly-
morphism. Metamorphism is the type of obfuscation tech-
niques which evade signature-based detection by instruction
reordering, register renaming, garbage insertion, instruction
replacement and equivalent functionality. More details of
these techniques can be found in [10, 20].
Polymorphism is a type of obfuscation techniques which
normally rely on encryption to mutate code. Original code
is encrypted and hidden in the payload, and it is decrypted to
its original form during execution. However, a small portion
of it, the decryption routine is left unencrypted. Some poly-
morphic engines further rewrite the unencrypted decryp-
tion routine by metamorphism each time the exploit code
is propagated [12, 19].
2.2 Anti-static-analysis
Anti-static-analysis is the type of obfuscation techniques
for thwarting static analysis.
It can be divided into three
subcategories: anti-disassembly, self-modifying and mem-
ory access obfuscation. Note that some anti-static-analysis
techniques such as self-modifying and indirect jump can
easily thwart previous static analysis techniques [8, 15, 28].
Next, we describe these techniques in slightly more details.
Self-Modifying Self-modifying code is code that mod-
iﬁes itself when being executed.
Self-modifying is a
very powerful technique to thwart static analysis since it
can completely hide the semantics of original instructions.
More speciﬁcally, it may be used to thwart static analysis
in a number of ways. First, it can be used to obfuscate the
control ﬂow graph (CFG) of exploit code, while CFG is the
obligatory input to a static analysis approach. As an exam-
ple, in Figure 2(a) the original loop instruction at address
16 is replaced in Figure 2(b) by a nop instruction at 1d and
an invalid instruction at 1e, and these two instructions will
be modiﬁed back to the loop instruction at runtime by in-
struction 0c in Figure 2(b). Second, it can be used to ob-
fuscate data ﬂow of exploit code to thwart those data ﬂow
analysis based approaches such as SigFree [28] and [8]. For
example, a data transfer instruction can be changed to a nop
instruction dynamically at runtime by self-modifying code,
thus obfuscating data ﬂows. Note that polymorphic code
is also a kind of self-modifying code, which hides original
exploit code. For example, in Figure 2(a) the encrypted pay-
load (encrypted original exploit code) will be decrypted at
runtime and then be executed.
00:
02:
05:
09:
0b:
0c:
13:
16:
18:
00:
02:
05:
09:
0b:
0c:
12:
19:
1d:
1e:
1f:
2BC9
83E9 B0
E8 FFFFFFFF
FFC0
5E
8176 0E DC40D776
83EE FC
E2 F4
(Encrypted payload)
...
(a)
2BC9
83E9 B0
E8 FFFFFFFF
FFC0
5E
668176 0A 7264
8176 0E DC40D776
83EE FC
90
FE
(Encrypted payload)
...
(b)