一个节点上： 2
$ docker run -d --name logger -e affinity:container==front logger
87c4376856a8 3
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NODE NAMES 4
87c4376856a8 nginx:latest "nginx" Less than a second ago
running 192.168.0.42:80->80/tcp node-1 front
963841b138d8 logger:latest "logger" Less than a second ago 5
running
新启动的logger容器将会被部署到node-1节点上。 6
此外，可以通过类同过滤来避免从网络上拉取镜像，这样可以节省启动时间。类同过滤只将
命令指派给那些本地就拥有该容器对应镜像的节点。 7
假如，我们已经运行了下面3条命令：
9
$ docker -H node-1:2375 pull redis
$ docker -H node-2:2375 pull mysql
$ docker -H node-3:2375 pull redis 8
此时就知道node-1和node-3已经拥有了redis镜像，那么当我们新启动redis容器时，可以使
10
用-e affinity:image==redis来保证任务不会被调度到node-2，避免了拉取redis镜像带来的时耗，
具体操作如下：
10
$ docker run -d --name redis1 -e affinity:image==redis redis
$ docker run -d --name redis2 -e affinity:image==redis redis
$ docker run -d --name redis3 -e affinity:image==redis redis 11
$ docker run -d --name redis4 -e affinity:image==redis redis
$ docker run -d --name redis5 -e affinity:image==redis redis
$ docker run -d --name redis6 -e affinity:image==redis redis 13
$ docker run -d --name redis7 -e affinity:image==redis redis
$ docker run -d --name redis8 -e affinity:image==redis redis
$ docker ps 14
CONTAINER ID IMAGE COMMAND CREATED
TATUS PORTS NODE NAMES
87c4376856a8 redis:latest "redis" Less than a second ago 15
running node-1 redis1
1212386856a8 redis:latest "redis" Less than a second ago
running node-1 redis2 16
87c4376639a8 redis:latest "redis" Less than a second ago
running node-3 redis3
1234376856a8 redis:latest "redis" Less than a second ago 17
running node-1 redis4
86c2136253a8 redis:latest "redis" Less than a second ago
running node-3 redis5 18
87c3236856a8 redis:latest "redis" Less than a second ago
238 第18章 Machine+Swarm+Compose
running node-3 redis6
87c4376856a8 redis:latest "redis" Less than a second ago
running node-3 redis7
963841b138d8 redis:latest "redis" Less than a second ago
running
 端口过滤
我们知道如果主机上的端口被一个容器的开放端口绑定后，就不能再被其他容器绑定了。
Swarm中的端口过滤（Port Filter）指的就是当你指定端口的静态映射关系后，Swarm的调度器会
选择尚能够满足你需求的节点来部署容器，如果整个集群都没有满足条件的节点，请求就会失败。
下面我们通过例子说明一下。我们的集群总共有3个节点：node-1、node-2和node-3。首先，
我们绑定主机的80端口到nginx容器的80开放端口：
$ docker run -d -p 80:80 nginx
87c4376856a8
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NODE NAMES
87c4376856a8 nginx:latest "nginx" Less than a second ago
running 192.168.0.42:80->80/tcp node-1 prickly_engelbart
可以看到，容器部署到了node-1节点上。接着，我们继续重复这个过程：
$ docker run -d -p 80:80 nginx
963841b138d8
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NODE NAMES
963841b138d8 nginx:latest "nginx" Less than a second ago
running 192.168.0.43:80->80/tcp node-2 dreamy_turing
87c4376856a8 nginx:latest "nginx" Up About a minute
running 192.168.0.42:80->80/tcp node-1 prickly_engelbart
新的容器被部署到了node-2节点。
继续部署：
$ docker run -d -p 80:80 nginx
963841b138d8
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NODE NAMES
f8b693db9cd6 nginx:latest "nginx" Less than a second ago
running 192.168.0.44:80->80/tcp node-3 stoic_albattani
963841b138d8 nginx:latest "nginx" Up About a minute
running 192.168.0.43:80->80/tcp node-2 dreamy_turing
87c4376856a8 nginx:latest "nginx" Up About a minute
running 192.168.0.42:80->80/tcp node-1 prickly_engelbart
第三个容器被部署到了node-3节点。继续部署：
18.3 Compose 239
$ docker run -d -p 80:80 nginx
1
2014/10/29 00:33:20 Error response from daemon: no resources available to schedule container
产生错误了。因为集群总共就有3个节点，而每次部署都静态绑定80端口，当3个节点的80
2
端口被占用之后，调度就会失败，返回错误。
除了约束过滤、类同过滤和端口过滤外，还有依赖过滤和健康状况过滤等，在此不再展开。 3
下面简要说明调度的策略，主要包含Binpacking和随机调度，其中随机调度就是一个rand()
函数，这里不再赘述。 4
 Binpacking策略
5
Binpacking策略是尽可能紧凑地使用节点资源。它会根据节点的CPU和RAM等资源为节点排
序，并挑选出能够让节点资源不产生空隙、碎片的节点来运行容器，为尚未有任务的节点保留最
6
大的空间。
下面我们通过例子说明该策略。假设集群有两个节点node-1和node-2，它们都具有2GB的 7
RAM存储，我们先部署一个mysql容器，指定占用1GB的内存：
9
$ docker run -d -P -m 1G --name db mysql
f8b693db9cd6
$ docker ps
8
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NODE NAMES
f8b693db9cd6 mysql:latest "mysqld" Less than a second ago
10
running 192.168.0.42:49178->3306/tcp node-1 db
可以看到，节点被部署到node-1，接着我们继续部署一个nginx容器，也占用1GB内存：
10
$ docker run -d -P -m 1G --name frontend nginx
963841b138d8
11
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NODE NAMES
13
963841b138d8 nginx:latest "nginx" Less than a second ago
running 192.168.0.42:49177->80/tcp node-1 frontend
f8b693db9cd6 mysql:latest "mysqld" Up About a minute
14
running 192.168.0.42:49178->3306/tcp node-1 db
结果显示，它也被部署到了node-1，为什么呢？因为在Binpacking策略下，nginx容器可以在
15
node-1中部署，那么就尽量保留node-2，以备后续容器使用。
16
18.3 Compose
诸如前两节所说，Machine用于安装Docker，Swarm用于管理Docker集群，而本节的Compose 17
则是管理Docker容器的应用部署。它所做的工作和Fig类似，都是安排应用部署到哪组容器以及
18
容器之间的关系。事实上，Compose就是由Fig启发而来的，它的设计理念和配置文件都与Fig类
240 第18章 Machine+Swarm+Compose
似。Compose也是采用YAML文件作为配置文件，只要编写好配置文件，一条命令就可以让多个
相关容器跑起来。
下面我们来看看配置文件group.yml：
name: rails_example
containers:
db:
image: postgres:latest
web:
build: .
command: bundle exec rackup -p 3000
volumes:
- .:/myapp
ports:
- "3000:3000"
links:
- db
我们在第15章中见过这个格式，其中name定义了该容器组的名字为rails_example。容器组包
含两个容器：db和web。这是一个典型的Web应用程序，web容器根据当前目录下的Dockerfile文件
构建，将当前目录映射为容器内的/myapp数据卷，将本地的3000端口和容器内的3000端口进行映
射，连接到db容器。定义好配置及相关文件后，只需要执行docker up命令就可以将上面的容器
组跑起来。需要注意的是，目前Docker里面并没有包含Compose组件，所以需要读者自行到
https://github.com/docker/docker/issues/9459下载平台对应的版本，然后替换掉原有的Docker文件，
具体操作如下：
root@micall-ThinkPad:~# curl -LO http://cl.ly/0Q3G1l2t301S/download/docker-1.3.2-dev-linux
root@micall-ThinkPad:~# /etc/init.d/docker stop
root@micall-ThinkPad:~# mv /usr/local/bin/docker ./docker-stable
root@micall-ThinkPad:~# mv ./docker-1.3.2-dev-linux /usr/local/bin/docker
root@micall-ThinkPad:~# chmod +x /usr/local/bin/docker
root@micall-ThinkPad:~# /etc/init.d/docker start
root@micall-ThinkPad:~# docker version
这样就替换掉了原有的Docker，置换成包含Compose组件的Docker。关于Compose的更多用
法和内容，可以访问上述地址，但目前能够看到的资料不多。
Part 4
第四篇
附 录
本 篇 内 容
附录A 常见镜像
附录B Docker API列表
附录C 参考资料
242 附录A 常见镜像
附录 A
常见镜像
本章将介绍一些常用的镜像，主要包含系统镜像、数据库镜像、Web服务镜像以及语言镜像。
A.1 系统镜像
系统镜像主要是提供系统环境或者基本工具集的镜像，例如BusyBox、Ubuntu以及CentOS等。
A.1.1 BusyBox
BusyBox是一个包含一百多个常用Linux命令和工具的工具集，例如常见的ls、cat和echo，
以及更为复杂的grep、find、mount和telnet。若要使用BusyBox，只需要在Docker Hub中搜索
即可：
$ docker search busybox
NAME DESCRIPTION STARS OFFICIAL AUTOMATED
busybox Busybox base image. 126 [OK]
progrium/busybox 33 [OK]
jeanblanchard/busybox-java Minimal Docker image with Java 14 [OK]
jeanblanchard/busybox-tomcat Minimal Docker image with Apache Tomcat 9 [OK]
radial/busyboxplus Full-chain, Internet enabled, 4 [OK]
busybox made...
sequenceiq/busybox 1 [OK]
选择最流行的官方镜像：
$ sudo docker pull busybox
启动BusyBox容器，并运行grep命令：
$ docker run -it busybox
/ # grep
BusyBox v1.22.1 (2014-05-22 23:22:11 UTC) multi-call binary.
Usage: grep [-HhnlLoqvsriwFE] [-m N] [-A/B/C N] PATTERN/-e PATTERN.../-f FILE [FILE]...
Search for PATTERN in FILEs (or stdin)
-H Add 'filename:' prefix
-h Do not add 'filename:' prefix
附录A 常见镜像 243
A.1.2 Ubuntu
1
Ubuntu是非常流行的Linux系统，可以直接在Docker Hub中搜索：
2
$ docker search ubuntu
NAME DESCRIPTION STARS OFFICIAL AUTOMATED
ubuntu Official Ubuntu base image 1233 [OK] 3
dockerfile/ubuntu Trusted automated Ubuntu 41 [OK]
(http://www.ubunt...
ansible/ubuntu14.04-ansible Ubuntu 14.04 LTS with ansible 35 [OK] 4
dockerfile/ubuntu-desktop Trusted automated Ubuntu Desktop 20 [OK]
(LXDE) (h...
ubuntu-upstart Upst 5
选择官方镜像并运行ubuntu容器：
6
$ docker run -ti ubuntu:14.04 /bin/bash
root@a74a37bd4bc0:/# ls
bin dev home lib64 mnt proc run srv tmp var 7
boot etc lib media opt root sbin sys usr
root@a74a37bd4bc0:/# lsb_release -a
No LSB modules are available. 9
Distributor ID: Ubuntu
Description: Ubuntu 14.04.1 LTS
Release: 14.04 8
Codename: trusty
root@a74a37bd4bc0:/#
10
A.1.3 CentOS
10
CentOS是Red Hat企业版源代码再编译的产物，常用于作为服务器，其性能稳定、可靠。在
Docker Hub中可以直接使用其官方提供的镜像，例如使用docker pull centos:6和docker pull
11
centos:7命令分别拉取CentOS 6和CentOS 7。
虽然CentOS 7已经将systemd服务替换为fakesystemd以解决依赖管理，但是有时我们还需要 13
使用systemd组件，例如读取主机的cgroups等。下面简要说明如何集成systemd服务，具体的
Dockerfile如下： 14
FROM centos:7
MAINTAINER "you"  15
ENV container docker
RUN yum -y swap -- remove fakesystemd -- install systemd systemd-libs
RUN yum -y update; yum clean all; \ 16
(cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i ==
systemd-tmpfiles-setup.service ] || rm -f $i; done); \