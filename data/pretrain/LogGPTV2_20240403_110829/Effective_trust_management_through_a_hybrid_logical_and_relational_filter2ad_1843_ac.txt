3: Set)Role* roles = Exec(SELECT CONCAT(owner, ‘.’, role) FROM base_roles WHERE subject = u)
4: Set)String* roleNames = ∅
5: for all A.R ∈ roles do
6:
roleNames.insert(R)
7:
8: // Process our order-sorted list of CTM credentials
9: for all c ∈ cList, where c is of the form A.R ← . . . do
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22: return roles
int count = Exec(SELECT COUNT(*) FROM A_R WHERE subject=‘u’)
if count > 0 then
roles.insert(A.R)
roleNames.insert(R)
// Use the DB to process linking- and aggregate-containment queries
if (c is of the form A.R ← A.R1.R2 ∧ R2 ∈ roleNames) ∨ (c is an aggregate containment) then
// Forward-chain over simple- and intersection-containment credentials
if (c is of the form A.R ← B1.R1 ∩ ··· ∩ Bn.Rn) ∧ ({B1.R1, . . . , Bn.Rn}⊆ roles) then
if A.R /∈ roles then
roles.insert(A.R)
roleNames.insert(R)
4.3 Answering Capability Queries
The hierarchical collection of dynamic views generated by
the compilation procedure described in Section 4.1 is well-
suited for answering proof of compliance and role member-
ship queries precisely because it takes a role-centric view of
the system. That is, views are explicitly created to manage
role memberships. This is a reasonable design choice, since
these types of queries are the most often executed in prac-
tice: proof of compliance queries are issued to check permis-
sions at each resource access request, and role membership
queries can be used to materialize a concrete ACL for a re-
source. Unfortunately, this organization is sub-optimal for
answering capability queries. Speciﬁcally, to determine the
set of roles to which a user A belongs, a proof of compliance
query would need to be issued for each individual role! This
is clearly unacceptable.
To address this issue, we have developed a novel algo-
rithm for answering capability queries that leverages both
the logical ruleset stored by our framework, as well the dy-
namic views maintained within the DBMS. At a high level,
our approach uses the logical ruleset to forward-chain when-
ever possible, while relying on the database to answer role
membership queries that cannot be established eﬃciently
via forward-chaining. This is similar in spirit to, though in-
trinsically diﬀerent than, the bidirectional search algorithm
proposed in [23]. Algorithm 1 illustrates this approach in
detail.
Algorithm 1 takes two parameters: the sorted list of CTM
credentials cList, and a user u. The algorithm begins by
querying the database to gather the base permissions as-
signed to the user u and then populating the roles and
roleNames sets. These sets track the roles that a user is
a member of, and are assumed to be implemented using a
data structure with O(1) insert and lookup (e.g., a Java
HashSet). The algorithm then iterates over cList, skipping
any credentials that deﬁne roles to which the user is already
a member. If the current role c deﬁnes a simple- or intersec-
tion containment, the algorithm forwards chains, using roles
to determine whether the user has the prerequisite roles to
establish membership in the role deﬁned by c.
If so, the
roles and roleNames sets are updated accordingly and the
algorithm moves on to the next credential in cList.
We note that forward chaining cannot be used to establish
membership in roles deﬁned by linking containment creden-
tials without also forward chaining the role memberships of
(potentially) all other principals in the system. For exam-
ple, the linking containment A.R ← A.R1.R2 requires infor-
mation not only about u’s membership in X.R2, but also
about X’s membership in A.R1 (for all such X!). Similarly,
forward chaining cannot be used to aggregate feedback re-
ports. As such, line 16 acts as a guard condition determining
whether the database should be used to process a particular
role membership in a top-down manner. Note that a linking
containment credential A.R ← A.R1.R2 is only processed if
u is a member of some X.R2 as indicated by the roleNames
set: if there is not a member of some X.R2, then they are
certainly not a member of A.R1.R2. Finally, we have the
following theorem:
Theorem 2
(Correctness & Completeness). Let
cList be the set of CTM roles parameterizing the system,
u be a user, and R be the set of roles returned by the func-
tion call CapQuery(cList, u). The set R of roles represents
exactly the set of role memberships held by u.
Proof. (Sketch) By Theorem 1, we know that the query
on line 3 will always return precisely the base set of permis-
sions assigned to u. Given the order-sort invariant imposed
on cList, we can prove by induction that the forward chain-
ing procedure described on lines 12–14 will determine that
u ∈ member(A.R) if and only if u ∈ member(Bi.Ri) for each
prerequisite Bi. Further, Theorem 1 gives us that the top
down processing procedure described on lines 16–20 will al-
ways accurately determine u’s membership in roles deﬁned
by linking or aggregate containment credentials. So for all
A.R deﬁned in cList, u’s membership is accurately assessed
by CapQuery(cList, u).
This combined logical/relational view of a CTM policy
provides us with a signiﬁcant speedup in processing capa-
bility queries, since (i) forward-chaining is extremely eﬃ-
cient and (ii) we can leverage prior knowledge regarding
role membership to issue only those database queries that
have a chance at succeeding. Speciﬁcally, the brute-force
approach to capability review requires O(N ) proof of com-
pliance queries, where N = |cList|. On the other hand, Al-
gorithm 1 requires O(plaN ) queries to the database, where
pla is the percentage of credentials in cList deﬁning linking-
or aggregate containments. As we will see in the next sec-
tion, the eﬃciency gains realized by Algorithm 1 are quite
noteworthy in practice.
5. EXPERIMENTAL EVALUATION
In this section, we discuss the performance overheads as-
sociated with trust management query processing within a
research prototype implementation of our proposed frame-
work. We ﬁrst explore several microbenchmarks that illus-
trate the relative costs of evaluating role membership and
proof of compliance queries over roles deﬁned by each type
of CTM credential. We then present a more detailed virtual
organization scenario, within which we evaluate the costs
proof of compliance, role membership, and capability queries
in a more meaningful setting. Finally, we conclude this sec-
tion by discussing the trade-oﬀs associated with leveraging
materialized, rather than dynamic, views within a DBMS-
based trust management system.
5.1 Experimental Setup
All experiments discussed in this section were carried out
on a machine equipped with a 2.1 GHz AMD Opteron pro-
cessor and 4 GB of RAM, running Red Hat Enterprise Linux
WS release 4. The core components of our framework—
including the policy compiler, logical credential management
facilities, and query processing algorithms—were written in
Java and compiled using the Sun Java JDK version 1.6.0 14.
A stock installation of MySQL version 5.1.35 was used as
our back-end database. All reputation aggregation func-
tions were written as user-deﬁned functions in C and loaded
by MySQL as shared objects.
5.2 Microbenchmarks
To examine the relative costs of evaluating proof of com-
pliance and role membership queries in a controlled setting,
we ﬁrst initialized three databases: small (100 users, 10 feed-
back reports per user), medium (500 users, 20 feedback re-
ports per user), and large (1000 users, 30 feedback reports
per user). We then deﬁned 50 roles in the base_roles table
and made each user a member of each role. When then com-
piled roles deﬁned by the following types of CTM credentials
into dynamic views in each database:
• Linear chains of delegation of up to length 5 speciﬁed
by simple containment credentials.
• Binary trees of up to height 4 speciﬁed by intersection
containment credentials.
• Linking containments of the form A.R1.R2 deﬁned such
that the members of A.R1 could be determined by us-
ing the base_roles table and the X.R2 role is a linear
chain of delegation with height varying from 1 to 5.
• Aggregate containments whose issuer ﬁlter role is spec-
iﬁed by a linear chain of delegation with height varying
from 1 to 5.
The result of our experiments are depicted in Figure 4.
Figure 4(a) shows that the cost of evaluating intersection
containment credentials increases exponentially in the height
of the credential. This is expected, as each increase in height
requires evaluating the member sets of twice as many base
roles. Note that across all database sizes, proof of compli-
ance remained very eﬃcient, despite the increased costs of
enumerating all role members. In Section 5.4, we will dis-
cuss some potential avenues for combating these types of
increases. Figures 4(b) and (c) describe the costs of evalu-
ating queries about linking containment and aggregate con-
tainment roles.
In both cases, the cost does not increase
with the height of the height of the linear delegation used,
as the cost of evaluating linear chains of delegation is neg-
ligible. Further, processing proof of compliance and role
membership queries takes approximately the same amount
of time due to the joins required to process these queries.
5.3 A Virtual Organization Scenario
While the above microbenchmarks illustrate the relative
costs of querying diﬀerent types role deﬁnitions, they say
very little about the costs of analyzing policies containing
large number of credentials, mixed hierarchies of creden-
tials, or roles deﬁned by multiple credentials. To ﬁnd the
answers to these questions, we developed a tool that gener-
ates synthetic hierarchical CTM policies within the context
of a set of collaborating virtual organizations (VOs). The
parameters to our tool are similar to those described in the
role-mining literature (e.g., see [25, 26]), and are described
in Table 1. In this paper, we generate the base role assign-
ments for three companies, and then build four layers VOs
on top of these companies. Each layer contains three VOs,
each of which deﬁnes its roles by generating CTM creden-
tials that reference the roles deﬁned by the three VOs (or
companies) one level below it.
Within this context, we examined the cost of processing
queries across a range of database sizes and CTM rule com-
plexities.
In particular, we considered small (100 users/
company, 10 feedback reports/user), medium (500 users/
company, 20 feedback reports/user), and large (1000 users/
company, 30 feedback reports/user) databases, as well as
low (100% intersection containment), medium (90% inter-
section containment, 5% linking containment, 5% aggregate
containment), and high (70% intersection containment, 15%
linking containment, 15% aggregate containment) complex-
ity rule sets.
In all cases, each company deﬁned 30 roles
using simple memberships, while each VO deﬁned 30 roles
according to the other parameters described in Table 1.
Figure 5(a) describes how the time required to answer
proof of compliance queries varies over medium complexity
databases of various size. Figure 5(b) shows how the cost
of answering proof of compliance queries in a medium sized
database is aﬀected by varying CTM rule complexities. In
both cases, we see that changes to the size or complexity
of the database have an observable—but not tremendous—
impact on query execution time. Rather, the variable that
most inﬂuences query runtime is the height at which a role is
deﬁned: e.g., all queries at levels 2 and below run extremely
quickly, regardless of how big (resp. complex) the underlying
database (resp. CTM ruleset) is, while higher-level queries
)
c
e
s
(
e
m
i
t
e
g
a
r
e
v
A
)
c
e
s
(
e
m
i
t
e
g
a
r
e
v
A
 0.3
 0.25
 0.2
 0.15
 0.1
 0.05
 0
1
Proof of Compliance
RM Small DB
RM Medium DB
RM Large DB
Small DB
Medium DB
Large DB
)
c
e
s
(
e
m
i
t
e
g
a
r
e
v
A
 0.055
 0.05
 0.045
 0.04
 0.035
 0.03
 0.025
 0.02
 0.015
 0.01
2
3
4
1
2
3
4
5
Role Height
Role Height
)
c
e
s
(
e
m
i
t
e
g
a
r
e
v
A
 0.35
 0.3
 0.25
 0.2
 0.15
 0.1
 0.05
 0
1
Small DB
Medium DB
Large DB
2
3
4
5
Role Height
(a) Intersection containment
(b) Linking containment
(c) Aggregate containment
Figure 4: Performance results from microbenchmark scenarios.
Small DB
Medium DB
Large DB
 1.2
 1
 0.8
 0.6
 0.4
 0.2
 0
Low Complexity
Medium Complexity
High Complexity
)
c
e
s
(