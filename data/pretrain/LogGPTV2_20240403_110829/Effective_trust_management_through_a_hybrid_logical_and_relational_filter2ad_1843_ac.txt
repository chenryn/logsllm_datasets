### 3. Role and Role Name Initialization
```java
Set<Role> roles = Exec(SELECT CONCAT(owner, '.', role) FROM base_roles WHERE subject = u);
Set<String> roleNames = new HashSet<>();
for (Role r : roles) {
    roleNames.add(r.getName());
}
```

### 4. Processing Order-Sorted List of CTM Credentials
```java
// Process our order-sorted list of CTM credentials
for (Credential c : cList) {
    if (c.isSimpleOrIntersectionContainment()) {
        // Forward-chain over simple- and intersection-containment credentials
        if (allPrerequisitesMet(c, roles)) {
            Role newRole = c.getDefinedRole();
            roles.add(newRole);
            roleNames.add(newRole.getName());
        }
    } else if (c.isLinkingContainment() || c.isAggregateContainment()) {
        // Use the DB to process linking- and aggregate-containment queries
        if (shouldProcessWithDB(c, roleNames)) {
            int count = Exec(SELECT COUNT(*) FROM A_R WHERE subject = 'u');
            if (count > 0) {
                Role newRole = c.getDefinedRole();
                roles.add(newRole);
                roleNames.add(newRole.getName());
            }
        }
    }
}

return roles;
```

### 4.3. Answering Capability Queries

The hierarchical collection of dynamic views generated by the compilation procedure described in Section 4.1 is well-suited for answering proof of compliance and role membership queries because it takes a role-centric view of the system. Views are explicitly created to manage role memberships, which is a reasonable design choice since these types of queries are frequently executed in practice: proof of compliance queries are issued to check permissions at each resource access request, and role membership queries can be used to materialize a concrete ACL for a resource. However, this organization is sub-optimal for answering capability queries. Specifically, to determine the set of roles to which a user `A` belongs, a proof of compliance query would need to be issued for each individual role, which is clearly unacceptable.

To address this issue, we have developed a novel algorithm for answering capability queries that leverages both the logical ruleset stored by our framework and the dynamic views maintained within the DBMS. At a high level, our approach uses the logical ruleset to forward-chain whenever possible, while relying on the database to answer role membership queries that cannot be established efficiently via forward-chaining. This approach is similar in spirit to, but intrinsically different from, the bidirectional search algorithm proposed in [23]. Algorithm 1 illustrates this approach in detail.

#### Algorithm 1: Capability Query
**Parameters:**
- `cList`: Sorted list of CTM credentials
- `u`: User

1. **Query Base Permissions:**
   ```java
   Set<Role> roles = Exec(SELECT CONCAT(owner, '.', role) FROM base_roles WHERE subject = u);
   Set<String> roleNames = new HashSet<>();
   for (Role r : roles) {
       roleNames.add(r.getName());
   }
   ```

2. **Iterate Over Credentials:**
   ```java
   for (Credential c : cList) {
       if (c.isSimpleOrIntersectionContainment()) {
           // Forward-chain over simple- and intersection-containment credentials
           if (allPrerequisitesMet(c, roles)) {
               Role newRole = c.getDefinedRole();
               roles.add(newRole);
               roleNames.add(newRole.getName());
           }
       } else if (c.isLinkingContainment() || c.isAggregateContainment()) {
           // Use the DB to process linking- and aggregate-containment queries
           if (shouldProcessWithDB(c, roleNames)) {
               int count = Exec(SELECT COUNT(*) FROM A_R WHERE subject = 'u');
               if (count > 0) {
                   Role newRole = c.getDefinedRole();
                   roles.add(newRole);
                   roleNames.add(newRole.getName());
               }
           }
       }
   }
   ```

3. **Return Roles:**
   ```java
   return roles;
   ```

**Theorem 2 (Correctness & Completeness):**
Let `cList` be the set of CTM roles parameterizing the system, `u` be a user, and `R` be the set of roles returned by the function call `CapQuery(cList, u)`. The set `R` of roles represents exactly the set of role memberships held by `u`.

**Proof (Sketch):**
By Theorem 1, the query on line 3 will always return precisely the base set of permissions assigned to `u`. Given the order-sort invariant imposed on `cList`, we can prove by induction that the forward chaining procedure described on lines 12–14 will determine that `u ∈ member(A.R)` if and only if `u ∈ member(Bi.Ri)` for each prerequisite `Bi`. Further, Theorem 1 gives us that the top-down processing procedure described on lines 16–20 will always accurately determine `u`'s membership in roles defined by linking or aggregate containment credentials. Therefore, for all `A.R` defined in `cList`, `u`'s membership is accurately assessed by `CapQuery(cList, u)`.

This combined logical/relational view of a CTM policy provides a significant speedup in processing capability queries, as (i) forward-chaining is extremely efficient, and (ii) we can leverage prior knowledge regarding role membership to issue only those database queries that have a chance of succeeding. Specifically, the brute-force approach to capability review requires `O(N)` proof of compliance queries, where `N = |cList|`. On the other hand, Algorithm 1 requires `O(pla * N)` queries to the database, where `pla` is the percentage of credentials in `cList` defining linking- or aggregate containments. As we will see in the next section, the efficiency gains realized by Algorithm 1 are quite noteworthy in practice.

### 5. Experimental Evaluation

In this section, we discuss the performance overheads associated with trust management query processing within a research prototype implementation of our proposed framework. We first explore several microbenchmarks that illustrate the relative costs of evaluating role membership and proof of compliance queries over roles defined by each type of CTM credential. We then present a more detailed virtual organization scenario, within which we evaluate the costs of proof of compliance, role membership, and capability queries in a more meaningful setting. Finally, we conclude this section by discussing the trade-offs associated with leveraging materialized, rather than dynamic, views within a DBMS-based trust management system.

#### 5.1. Experimental Setup

All experiments discussed in this section were carried out on a machine equipped with a 2.1 GHz AMD Opteron processor and 4 GB of RAM, running Red Hat Enterprise Linux WS release 4. The core components of our framework, including the policy compiler, logical credential management facilities, and query processing algorithms, were written in Java and compiled using the Sun Java JDK version 1.6.0_14. A stock installation of MySQL version 5.1.35 was used as our back-end database. All reputation aggregation functions were written as user-defined functions in C and loaded by MySQL as shared objects.

#### 5.2. Microbenchmarks

To examine the relative costs of evaluating proof of compliance and role membership queries in a controlled setting, we first initialized three databases: small (100 users, 10 feedback reports per user), medium (500 users, 20 feedback reports per user), and large (1000 users, 30 feedback reports per user). We then defined 50 roles in the `base_roles` table and made each user a member of each role. We compiled roles defined by the following types of CTM credentials into dynamic views in each database:
- Linear chains of delegation of up to length 5 specified by simple containment credentials.
- Binary trees of up to height 4 specified by intersection containment credentials.
- Linking containments of the form `A.R1.R2` defined such that the members of `A.R1` could be determined using the `base_roles` table and the `X.R2` role is a linear chain of delegation with height varying from 1 to 5.
- Aggregate containments whose issuer filter role is specified by a linear chain of delegation with height varying from 1 to 5.

The results of our experiments are depicted in Figure 4. Figure 4(a) shows that the cost of evaluating intersection containment credentials increases exponentially with the height of the credential. This is expected, as each increase in height requires evaluating the member sets of twice as many base roles. Note that across all database sizes, proof of compliance remained very efficient, despite the increased costs of enumerating all role members. In Section 5.4, we will discuss some potential avenues for combating these types of increases. Figures 4(b) and (c) describe the costs of evaluating queries about linking containment and aggregate containment roles. In both cases, the cost does not increase with the height of the linear delegation used, as the cost of evaluating linear chains of delegation is negligible. Further, processing proof of compliance and role membership queries takes approximately the same amount of time due to the joins required to process these queries.

#### 5.3. A Virtual Organization Scenario

While the above microbenchmarks illustrate the relative costs of querying different types of role definitions, they say very little about the costs of analyzing policies containing a large number of credentials, mixed hierarchies of credentials, or roles defined by multiple credentials. To find the answers to these questions, we developed a tool that generates synthetic hierarchical CTM policies within the context of a set of collaborating virtual organizations (VOs). The parameters to our tool are similar to those described in the role-mining literature (e.g., see [25, 26]), and are described in Table 1. In this paper, we generate the base role assignments for three companies and then build four layers of VOs on top of these companies. Each layer contains three VOs, each of which defines its roles by generating CTM credentials that reference the roles defined by the three VOs (or companies) one level below it.

Within this context, we examined the cost of processing queries across a range of database sizes and CTM rule complexities. Specifically, we considered small (100 users/company, 10 feedback reports/user), medium (500 users/company, 20 feedback reports/user), and large (1000 users/company, 30 feedback reports/user) databases, as well as low (100% intersection containment), medium (90% intersection containment, 5% linking containment, 5% aggregate containment), and high (70% intersection containment, 15% linking containment, 15% aggregate containment) complexity rule sets. In all cases, each company defined 30 roles using simple memberships, while each VO defined 30 roles according to the other parameters described in Table 1.

Figure 5(a) describes how the time required to answer proof of compliance queries varies over medium complexity databases of various sizes. Figure 5(b) shows how the cost of answering proof of compliance queries in a medium-sized database is affected by varying CTM rule complexities. In both cases, we see that changes to the size or complexity of the database have an observable—but not tremendous—impact on query execution time. Rather, the variable that most influences query runtime is the height at which a role is defined: e.g., all queries at levels 2 and below run extremely quickly, regardless of how big (resp. complex) the underlying database (resp. CTM ruleset) is, while higher-level queries take longer.