that a given module exposes for use by the other modules.
Addresses of such functions are resolved at runtime based on
the actual load address of the dependent modules. There-
fore entries of the relocation table and the export table of a
module together form valid branch targets for a module.
Irrespective of the guest OS being executed, the binary
loader ﬁrst needs to load the entire module binary to mem-
ory before performing relocation ﬁx-ups (if any) and trans-
ferring control to the module. However, when the control
reaches the module entry, it is possible that the guest OS
memory manager has paged out the relocation table from
the memory. To optimize the whitelist extraction, CFIC
ﬁrst tries to retrieve the relocation and export tables corre-
sponding to a module directly from the guest memory. If
the pages corresponding to relocation and export table are
paged out, CFIC accesses the binary ﬁle corresponding to
the module on the guest ﬁle system and extracts the reloca-
tion table and export table from the binary.
For each process in the system, CFIC maintains a sorted
It
array of loaded modules in the process address space.
also maintains a hashtable that maps the base address of a
module to the whitelist corresponding to the module. When
a module is loaded, CFIC ﬁrst checks the whitelist cache
for the whitelist corresponding to the module, only if not
present, it constructs the whitelist for the module and adds
the whitelist to the whitelist cache.
When CFIC encounters an indirect call, jmp instruc-
tion, it performs a binary search for the target address in
the loaded modules array of the process. Here, the binary
search returns a negative insertion point if the search failed.
If the returned search value is an even negative index, then
the target address does not belong to any of the modules
and is treated as a violation of CFI model. However, if the
return value is an odd negative index, the target address
belongs to the module with base address equal to the ad-
dress at index - 1 in the loaded module array. Note that it
is not possible for the return value to be positive since the
target address cannot be equal to the start address or the
end address of a module. Therefore, if the return value is
non-negative, the address is considered not to be present.
The whitelist lookup is performed with a time complexity
of lg(n), where n is the number of modules in the process
address space. Although maintaining a single hash-table for
each process with all the whitelists corresponding to all the
modules in its address space will suﬃce, such an approach
leads to severe memory overhead due to redundancies, be-
cause several common modules (like NTDLL.DLL, KER-
NEL32.DLL, etc.) will be present in every process whitelist.
Whitelist caching. The whitelist for a binary is statically
determined and therefore remains the same across diﬀerent
execution instances. As an optimization, the whitelist is gen-
erated only once per binary ﬁle and the generated whitelist
is stored in the whitelist cache as a [ﬁle’s md5 checksum,
whitelist] pair. When a new ﬁle is loaded, as an optimiza-
tion, Total-CFI ﬁrst checks the whitelist cache to determine
if the whitelist has already been extracted, only if the ﬁle is
being encountered for the ﬁrst time, Total-CFI extracts the
whitelist from the ﬁle and adds the whitelist to the whitelist
cache.
4.2 Shadow Call Stack
To keep track of the call-ret pairs during the execution
of a thread in the guest OS, CFIC maintains two shadow call
stacks per thread - one for user mode execution and one for
kernel mode execution. It relies on PVE component to notify
when a call, ret instruction is executed on the guest CPU
at which time, CFIC ﬁrst identiﬁes the context in which the
instruction was executed. The context constitutes the pro-
cess, thread and the user/kernel mode the instruction was
executed in. From the context, CFIC identiﬁes the appro-
priate shadow call stack using Algorithm 1. Then, if the in-
struction were a call instruction, CFIC pushes the address
of the succeeding instruction on to the identiﬁed shadow
stack. Conversely, if the instruction were a ret instruction,
CFIC pops the target address oﬀ the shadow stack. If the
address is not present in the shadow stack, CFIC reports an
exploit.
Special control ﬂows. Though strict pairing between
call-ret pairs account for a majority of control transfers,
there are certain special control transfers that make CFI
enforcement via shadow call stack monitoring challenging.
Below, we consider such special control ﬂow scenarios.
316void foo(int i)
{
  if(i == 5)
    throw 18;
  return 0;
}
int main()
{
  int i = 0;
  cout > i;
  try
  {
    foo(i);
  }
  catch (int e)
  {
    if(e == 18)
      i = 0;
    cout :
........................
47e9e6:       mov    0x4(%eax),%edx
47e9ee:       jmp    *%edx                               
........................
//Retrieve address of catch 
block (loc_0x401670) from 
exception object, and jump
Shadow Call Stack 
(Stack grows upwards)
0040150c :
........................
401512:       cmpl   $0x5,0x8(%ebp)                  // if(i == 5)
401516:       jne    40153f 
........................
401529:       movl   $0x12,(%eax)
40153a:       call   47e820       // throw 18
40153f:        mov    $0x0,%eax
........................
// Save address of catch 
block in exception object
0040159c :
........................
4015c6:       mov    loc_0x401670, %edx    
4015cb:       mov    %edx, 0x4(%eax)
........................
40163b:       call   40150c             // foo(i)
401640:       add    $0x10,%esp
........................
401670:       mov    %eax,-0x14(%ebp)            //callatch(int e) {
401673:       cmpl   $0x12,-0x14(%ebp)           //  if(e == 18)
401677:       jne    401680 
401679:       movl   $0x0,-0x18(%ebp)             //      i = 0
........................
401726:       ret
........................
2
1
3
40153f
401640
Return address of main
After 40153a: 
call 
401640
Return address of main
After 40163b:       
call   
After 401726:  ret
Figure 2: Shadow Call Stack Behavior During a C++ Exception. Input value is 5.
Handling of Exceptions: Exception handling is a mech-
anism to handle anomalous events that often change the
normal control ﬂow of a program. Figure 2 describes the
handling of such exceptions by Total-CFI. Column 1 lists
the source code of a program that raises and handles an
exception. Column 2 lists the simpliﬁed version of the cor-
responding code in assembly, obtained when the code is com-
piled using the MinGW-g++ cross compiler. The exception
handler or the catch block is relocatable and hence appears
as an entry in the relocation table. During compile time,
the compiler stores the address of such a block in the excep-
tion object. At runtime, when an exception is thrown, the
throw statement translates to a call to
cxa throw, which
in turn retrieves the address of the catch block from the
exception object, rewinds the stack and transfers control to
the catch block via an indirect jump. Column 3 of Figure 2
shows the contents of shadow stack at diﬀerent stages dur-
ing the program execution. On the one hand, during the
jmp instruction, Total-CFI veriﬁes that the branch address
is a part of the program’s whitelist and lets the instruction
pass, but on the other hand, when the main function returns
(stage 4 in Column 3 of Figure 2), the CFIC recognizes that
the return address is not at the top of the shadow stack and
therefore pops all the items up to and including the return
address of main function from the top of the stack.
Handling of setjmp/longjmp: In C and its ﬂavors, setjmp
and longjmp are used to save and restore the CPU envi-
ronment respectively to transfer control to a predetermined
location. During setjmp, the environment including the
contents of the CPU registers are cached in a user pro-
vided buﬀer, and during longjmp, the CPU register contents
are restored from the buﬀer. Upon encountering a setjmp,
Total-CFI records the value of the program counter where
the control will be transferred to during longjmp. When
a longjmp is encountered, Total-CFI veriﬁes the target ad-
dress to be the same as the value of the program counter as
recorded during the previous setjmp in the current execu-
tion context. Mismatch in the target address is ﬂagged as a
potential exploit.
Kernel mode to User mode call backs: Typically, the
control transfers from user mode to kernel mode happen
through the sysenter, int instructions and back from ker-
nel mode to user mode via sysexit, iret instructions re-
spectively. However, in Windows, NTDLL maintains a set
of entry points that are used by the kernel to invoke certain
functionality on behalf of the user mode [31]. Some such NT-
DLL APIs are: KiUserExceptionDispatcher, KiUserApcDis-
patcher, KiRaiseUserExceptionDispatcher and KiUserCall-
backDispatcher. They are used by the kernel as a trampo-
line to invoke functionality in the user mode. Kernel saves
the processor state and alters the thread stack to accom-
plish such a call. When the kernel alters the execution of a
thread and transitions to user mode, the return address may
not coincide with the expected return address at the top of
the stack. To address this problem, for every stack in the
system, CFIC maintains a hash-table wherein, for every ESP
register value encountered during a call instruction as key, it
stores the position of the entry in the stack as value. When
a return instruction is encountered, it ﬁrst checks the ESP
register’s value in the hash-table to ﬁnd the position on the
shadow stack and then, pops all the elements up to the posi-
tion oﬀ the stack. Such an approach is reasonable since the
stack is dictated primarily by the ESP register and a rewind
of the ESP register would imply a clean-up of the stack. If
the ESP register value is not found in the hash-table, the
instruction is ﬂagged as a potential exploit.
4.3 Dynamically generated code
CFIC leverages observation 2 in Section 3.5. Most con-
trol transfers to dynamically generated code happen through
a pre-determined path. Initially, CFIC is trained to accu-
mulate the possible control paths that lead to dynamically
generated code in a particular application. This is done by
recording the shadow stacks for the valid control ﬂows that
lead to dynamically generated code. An intersection of such
31700000a44 :
...................
 a69:   call   9a7
 a6e:   add   $0x1586,%ebx  //Offset of f()
 a74:   call   *%ebx
...................
000009a7 :
 9a7:   mov    (%esp),%ebx
 9aa:   ret
Figure
3:
Position
i686.get pc thunk()
Code.
the
IP from the stack. foo() uses the return address to
calculate address of f()
Independent
retrieves
the value of
paths is used as a signature that is enforced during execu-
tion. Here, it is possible that the dynamic code generation
library is loaded at diﬀerent locations on each instance it
is loaded. Therefore, CFIC maintains the signature as a
[module:oﬀset] pair to validate across load instances.
During normal execution, when CFIC encounters a branch
target that is not in the whitelist, it ﬁrst checks if the target
belongs to dynamically generated code, next it checks the
shadow call stack to check if the shadow call stack satisﬁes
the dynamic code signature for the application.
4.4 Non-relocatable binaries
Though most binaries are relocatable, some legacy code
can be non-relocatable. In such cases, PVE component stat-
ically analyzes the binaries to extract all the statically iden-
tiﬁable addresses - the ones that either occur as constant
address operands in the disassembly or the ones that have a
function prologue. Though this approach includes addresses
which may not be valid targets, such a conservative approach
will reduce false positives.
4.5 Branch Tables or Jump Tables
A jump table is an array of function pointers or an array
of machine code jump instructions. Calls to the functions
(or code blocks) in the array are made through indirect ad-
dressing using the base address of the jump table and the
oﬀset of the desired code block in the table. We make two
key observations about jump tables:
1. The base address of a jump table must be relocatable
and therefore contains an entry in the relocation table.
2. Every entry in the jump table must point to a valid
code block.
Total-CFI takes a liberal approach to handle jump tables.
For every entry in the relocation table, Total-CFI checks if
the content at that address points to code, if so, it treats
it as a potential base address of a jump table. It traverses
the table for consecutive entries that point to code and adds
them to the whitelist.
4.6 Position Independent Code (PIC)
The addressing in PIC does not rely on any particular
position in the program address space. Conceptually, PIC
identiﬁes the current value of Program Counter (PC) and
addresses diﬀerent code blocks as oﬀsets from the PC. Fig-
ure 3 shows a typical example of PIC. The current version
of Total-CFI does not support PIC, however it is possible to
Name
Version
.reloc
present?
Fiber
present?
Calculator
Notepad
Internet Explorer
Firefox
Adobe Reader
Google Talk
Microsoft Paint
Windows Media
Player
XPS viewer
Yahoo Messenger
Apple Quicktime
Apple iTunes
Process Explorer
Filezilla
Google chrome
Windows Messen-
ger
RealPlayer
DivX Player
Winamp
VLC Media Player
Skype
Registry Editor
6.1
6.1
8.0
3.5
8.1.1
1.0.72
6.1
12.0