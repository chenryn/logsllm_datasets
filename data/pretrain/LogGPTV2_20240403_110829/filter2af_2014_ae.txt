    p2_2 = pow(p2, 2)
    delta = pow(p2_2 + p2, 2) - (4 * p2 * (p2_2-M1))
    p1 = (-(p2_2 + p2) + list(gmpy2.iroot(delta,2))[0]) // (2 * p2)
    p3 = (M2 + 2) // (p2_2 + p1*p2) - 1
    N1 = p1*p2*p3
    N2 = n // N1
    N3 = list(gmpy2.iroot(N2,2))[0] + 1
    while True:
        mul = pow(N3,2) - N2
        if(list(gmpy2.iroot(mul,2))[1]):
            M = list(gmpy2.iroot(mul,2))[0]
            p = N3 - M
            q = N3 + M
            break
        N3 += 1
    phi = (p1 - 1) * (p2 - 1) * (p3 - 1) * (p - 1) * (q - 1)
    e = 65537
    d = gmpy2.invert(e,phi)
    print(long_to_bytes(gmpy2.powmod(c,d,n)))
    D0g3{296b680c-7aeb-5272-8b33-7335b411fbcb}
## **strange**
已知m&hint和hint，利用Coppersmith求m|hint
    m|hint = 13420866878657192881981508918368509601760484822510871697454710042290632315733970543259862148639047993224391010676733
恢复m
    from Crypto.Util.number import *
    N = 13002904520196087913175026378157676218772224961198751789793139372975952998874109513709715017379230449514880674554473551508221946249854541352973100832075633211148140972925579736088058214014993082226530875284219933922497736077346225464349174819075866774069797318066487496627589111652333814065053663974480486379799102403118744672956634588445292675676671957278976483815342400168310432107890845293789670795394151784569722676109573685451673961309951157399183944789163591809561790491021872748674809148737825709985578568373545210653290368264452963080533949168735319775945818152681754882108865201849467932032981615400210529003
    c = 8560367979088389639093355670052955344968008917787780010833158290316540154791612927595480968370338549837249823871244436946889198677945456273317343886485741297260557172704718731809632734567349815338988169177983222118718585249696953103962537942023413748690596354436063345873831550109098151014332237310265412976776977183110431262893144552042116871747127301026195142320678244525719655551498368460837394436842924713450715998795899172774573341189660227254331656916960984157772527015479797004423165812493802730996272276613362505737536007284308929288293814697988968407777480072409184261544708820877153825470988634588666018802
    m1 = 13420866878657192881981508918368509601760484822510871697454710042290632315733970543259862148639047993224391010676733
    m2 = 9869907877594701353175281930839281485694004896356038595955883788511764488228640164047958227861871572990960024485992
    hint = 9989639419782222444529129951526723618831672627603783728728767345257941311870269471651907118545783408295856954214259681421943807855554571179619485975143945972545328763519931371552573980829950864711586524281634114102102055299443001677757487698347910133933036008103313525651192020921231290560979831996376634906893793239834172305304964022881699764957699708192080739949462316844091240219351646138447816969994625883377800662643645172691649337353080140418336425506119542396319376821324619330083174008060351210307698279022584862990749963452589922185709026197210591472680780996507882639014068600165049839680108974873361895144
    res = ''
    while m2 > 0:
        a = hint & 1
        b = m2 & 1
        c = m1 & 1
        if a == 0:
            assert b == 0
            res += str(c)
        else:
            res += str(b)
        m1 >>= 1
        m2 >>= 1
        hint >>= 1
    mes = '0' + res[::-1]
    print(long_to_bytes(int(mes,2)).decode())
    =====
    D0g3{R54_f4l1_1n_l0ve_with_CopperSmith_w0wow0!!}
    >>>
## **air encryption**
连上之后给了6次交互机会, 但其中最少有一次需要用来`set key`
有三个选项:
  * set key : 初始化`aes-ctr`的counter
  * guess num: 每猜中一次随机数, 分数+1
  * get flag : 当分数不为4的时候, 发送的为有填充的加密的flag, 分数为4的时候发送明文flag
### 思路
由于题目`set key`没有校验次数, 可以多次重置密钥, 且密钥为每一次连接生成的随机值, 加上`aes-ctr`的特性, 只需要获取到足够长的明文即可
在`guess key`中, 猜对随机数服务端会发送填充加密后的`right`, 猜错随机数会发送填充加密后`wrong`, 实际上, 这里的明文都不够长,
于是这样会出现只能获取到一半flag的情况。
正确是思路的是故意输入不符合要求的命令, 由于`self.send(b'something wrong, check your input')`,
填充和加密操作被内置到了`send`方法里面, 所以这里会发送很长的密文, 重复三次, 去除重合的部分即可得到足够长的密钥流
于是6次机会 = 1次`set key`初始化 + 3次报错`guess num`获取密钥流 + 1次`set key`重置密钥流 + 1次`get
flag`获取加密后的flag
本地解密即可
### exp
    #!/usr/bin/python
    from pwn import *
    from pwnlib.util.iters import mbruteforce
    from hashlib import sha256
    import string
    import time
    import binascii
    context.log_level = 'debug'
    r = remote('happi0.club', 10086)
    def padding( msg):
        return  msg + chr((16 - len(msg)%16)).encode() * (16 - len(msg)%16)