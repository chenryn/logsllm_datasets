execve payload (shown on the right side of Table 1) and gener-
ate a PoC exploit in less than a minute as shown in Table 7.
Assuming that rsi points to some writable address x, BOPC
produces the following (address, value, size) tuples: ($y, $x, 8),
($y +8h, 0, 8), ($x,/bin/sh, 8), ($x +10h, $y, 8), ($x +18h, 0, 8), were
$y is a concrete writable addresses set by BOPC.
7.2 Infinite loop
Here we present a payload that generates a trace that executes
an infinite loop. The infloop payload is a simple infinite loop that
consists of only two statements:
void payload() {
LOOP:
__r1 = 0;
goto LOOP;
}
We set the entry point at the beginning of ngx_signal_handler
function which is a signal handler that is invoked through a func-
tion pointer. Hence, this point is reachable through control-flow
hijacking. The solution synthesized by BOPC is shown in Figure 6.
The box on the top-left corner demonstrates how the memory is
initialized to satisfy the constraints.
Virtual register __r0 was mapped to hardware register r14, so
ngx_signal_handler contains three candidate blocks, marked as
octagons. Exactly one of them is selected to be the functional block
while the others are avoided by the dispatcher blocks. The dis-
patcher finds a path from the entry point to the first functional
block, and then finds a loop to return back to the same functional
block (highlighted with blue arrows). Note that the size of the dis-
patcher block exceeds 20 basic blocks while the functional block
consists of a single basic block.
The oval nodes in Figure 6 indicate basic blocks that are out-
side of the current function. At basic block 0x41C79F, function
ngx_time_sigsafe_update is invoked. Due to the shortest path
heuristic, BOPC, tries to execute as few basic blocks as possible
from this function. In order to do so BOPC sets ngx_time_lock a
non-zero value, thus causing this function to return quickly. BOPC
successfully synthesizes this payload in less than 5 minutes.
7.3 Conditional statements
This case study shows an SPL if-else condition that implements a
logical NOT. That is, if register __r0 is zero, the payload sets __r1 to
one, otherwise __r1 becomes zero. The execution trace starts at the
beginning of ngx_cache_manager_process_cycle. This function
is called through a function pointer. A part of the CFG starting from
Figure 6: CFG of nginx’s ngx_signal_handler and payload
for an infinite loop (blue arrow dispatcher blocks, octagons
functional blocks) with the entry point at the function start.
The top box shows the memory layout initialization for this
loop. This graph was created by BOPC.
41cb6c41cbaa41cae241cafa41ca2741ca2c41cc5f41cc7941cb0b41cb1041c79141c79f41ca5041cb4641ca6041cc4841cc5241c99441c9ac41c9ea41c9fb41ca1841cbac41cbbd41cbe641c91041c91e41c9a141ccc341cce741c9bd41c9e541c78341c78741c90041cb0941cacd41cced41c7bf41c8f241c96d41ca4041ca4b41ca8441ca8f41ca9741ccad41ccb241c7cd41cac841c8f741cc8c41cc9541cb5041cb5b41c7a441c7b141c7c441ca7c4027d041c93f41cc3941ca2241c75041c76540222041c97a41cc7f41ca9b41c77841c79a41c77c41cc0f41cbed41cab041cb3f41cbfe40e10f41cb3641caff41ca7741c79341c956100003840e2231000308 41C765: signals.signo == 0  40E10F: ngx_time_lock != 0  41C7B1: ngx_process ­ 3 > 1  41C9AC: ngx_cycle = $alloc_1           $alloc_1­>log = $alloc_2           $alloc_2­>log_level log_level shared_memory.part.elts = 0           __r0 = r14 = 0  41CC79: ngx_cycle­>shared_memory.part.nelts shared_memory.part.next == 0 In function   Out of function   Functional block   Dispatcher path0x403d1b : conf_ctx->env.elts = &elt (ngx_array_t*)
conf_ctx->env.nelts == 0
0x4050ba : conf_ctx->env.nelts != $alloca_2->env.nalloc
0x40511c : conf_ctx->env.nelts += 1
0x40513a : $ret = conf_ctx->env.elts +
conf_ctx->env.nelts*conf_ctx->env.size
0x403d9c : $ret != 0
0x403da5 : conf_ctx->env.nelts != 0
0x403fb4 : __r1 = r15 = 0
8 DISCUSSION AND FUTURE WORK
Our prototype demonstrates the feasibility and scalability of auto-
matic construction of BOP chains through a high level language.
However, we note some potential optimizations that we will con-
sider for future versions of BOPC.
BOPC is limited by the granularity of basic blocks. That is, a
combination of basic blocks could potentially lead to the execution
of a desired SPL statement, while individual blocks might not. Take
for instance an instruction that sets a virtual register to 1. Assume
that a basic block initializes rcx to 0, while the following block
increments it by 1; a pattern commonly encountered in loops. Al-
though there is no functional block that directly sets rcx to 1, the
combination of the previous two has the desired effect. BOPC can
be expanded to address this issue if the basic blocks are coalesced
into larger blocks that result in a new CFG.
BOPC sets several upper bounds defined by user inputs. These
configurable bounds include the upper limit of (i) SPL payload per-
mutations (P), (ii) length of continuous blocks (L), (iii) of minimum
induced subgraphs extracted from the delta graph (N ), and (iv) dis-
patcher paths between a pair of functional blocks (K). These upper
bounds along with the timeout for symbolic execution, reduce the
search space, but prune some potentially valid solutions. The eval-
uation of higher limits may result in alternate or more solutions
being found by BOPC.
9 CONCLUSION
Despite the deployment of strong control-flow hijack defenses such
as CFI or shadow stacks, data-only code reuse attacks remain pos-
sible. So far, configuring these attacks relies on complex manual
analysis to satisfy restrictive constraints for execution paths.
Our BOPC mechanism automates the analysis of the remain-
ing attack surface and synthesis of exploit payloads. To abstract
complexity from target programs and architectures, the payload
is expressed in a high-level language. Our novel code reuse tech-
nique, Block Oriented Programming, maps statements of the payload
to functional basic blocks. Functional blocks are stitched together
through dispatcher blocks that satisfy the program CFG and avoid
clobbering functional blocks. To find a solution for this NP-hard
problem, we develop heuristics to prune the search space and to
evaluate the most probable paths first.
The evaluation demonstrates that the majority of 13 payloads,
ranging from typical exploit payloads to loops and conditionals
are successfully mapped 81% of the time across 10 programs. Upon
acceptance, we will release the source code of our proof of concept
prototype along with all of our evaluation results. The prototype is
available at https://github.com/HexHive/BOPC.
Figure 7: A delta graph instance for an ifelse payload for ng-
inx. The first node is the entry point. Blue nodes and edges
form the minimum induced subgraph, Hk . Statement #4 is a con-
ditional, execution branches into two statements. Note that
BOPC created this graph.
this function is shown in Appendix D. After trying 4 mappings,
__r0 and __r1 map to rsi and r15 respectively. The resulting delta
graph is the shown in Figure 7.
As we mentioned in Section 5.6, when BOPC encounters a func-
tional block for a conditional statement, it clones the current state of
the symbolic execution and the two clones independently continue
the execution. The constraints up to the conditional jump are the
following:
0x41eb23 : $rdi = ngx_cycle_t* cycle
0x40f709 : *(ngx_event_flags + 1) == 0x2
0x41dfe3 : __r0 = rsi = 0x0
0x403cdb : $r15 = 0x1
ngx_module_t ngx_core_module.index = 0
$alloca_1 = *cycle
ngx_core_conf_t* conf_ctx =
*$alloca_1 + ngx_core_module.index * 8
0x403d06 : test rsi, rsi (__r0 != 0)
0x403d09 : jne 0x403d1b 
If the condition is false and the jump is not taken, the following
constraints are also added to the state.
0x403d0b : conf_ctx->environment != 0
0x403fd9 : __r1 = *($stack - 0x178) = 1;
When the condition is true, the execution trace will follow the
“taken” branch of the trace. In this case the shortest path to the next
functional block is 403d1b → 403d3d → 403d4b → 403d54 →
403d5a → 403f b4 with a total length 6. Unfortunately, this cannot
be used as a dispatcher block, due to an exception that is raised
at 403d4b. The register rsi, is 1 and therefore when we attempt
to execute the following instruction: cmp BYTE PTR [rsi], 54h,
we essentially try to dereference address 1. BOPC is aware of this
exception, so it discards the current path and tries with the second
shortest path. The second shortest path has length 7 and avoids
the problematic block: 403d1b → 403d8b → 4050ba → 40511c →
40513a → 403d9c → 403da5 → 403f b4. This results in a new set
of constraints as shown below:
Statement #12Statement #2Statement #0Statement #4Statement #16Statement #641eb23403d4b8403d6c10404d5a1340788736407a1c4041dfe3441e02a11403cdbINFINFINFINFINF1INF403e4e10403fd92403e4e10403ebb19403fb46403fd92    -1    00000010 ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful com-
ments. This research was supported by ONR awards N00014-17-1-
2513, N00014-17-1-2498, by NSF CNS-1408880, CNS-1513783, CNS-
1801534, CNS-1801601, and a gift from Intel corporation. Any opin-
ions, findings, and conclusions or recommendations expressed in
this material are those of the authors and do not necessarily reflect
the views of our sponsors.
REFERENCES
[1] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti. 2009. Control-flow
integrity principles, implementations, and applications. ACM Transactions on
Information and System Security (TISSEC) (2009).
[2] Thanassis Avgerinos, Sang Kil Cha, Alexandre Rebert, Edward J Schwartz, Mav-
erick Woo, and David Brumley. 2014. Automatic exploit generation. Commun.
ACM 57, 2 (2014), 74–84.
[3] Tyler Bletsch, Xuxian Jiang, Vince W Freeh, and Zhenkai Liang. 2011. Jump-
oriented programming: a new class of code-reuse attack. In Proceedings of the
6th ACM Symposium on Information, Computer and Communications Security.
[4] Nathan Burow, Scott A Carr, Stefan Brunthaler, Mathias Payer, Joseph Nash, Per
Larsen, and Michael Franz. 2018. Control-flow integrity: Precision, security, and
performance. ACM Computing Surveys (CSUR) (2018).
[5] Cristian Cadar, Daniel Dunbar, Dawson R Engler, and others. 2008. KLEE: Unas-
sisted and Automatic Generation of High-Coverage Tests for Complex Systems
Programs.. In OSDI.
[6] Nicholas Carlini, Antonio Barresi, Mathias Payer, David Wagner, and Thomas R
Gross. 2015. Control-Flow Bending: On the Effectiveness of Control-Flow In-
tegrity.. In USENIX Security.
Modern Defenses.. In USENIX Security.
[8] Miguel Castro, Manuel Costa, and Tim Harris. 2006. Securing software by
enforcing data-flow integrity. In Proceedings of the 7th symposium on Operating
systems design and implementation.
[9] Stephen Checkoway, Lucas Davi, Alexandra Dmitrienko, Ahmad-Reza Sadeghi,
Hovav Shacham, and Marcel Winandy. 2010. Return-oriented programming
without returns. In Proceedings of the 17th ACM conference on Computer and
communications security.
[10] Yueqiang Cheng, Zongwei Zhou, Yu Miao, Xuhua Ding, Huijie DENG, and others.
2014. ROPecker: A generic and practical approach for defending against ROP
attack. (2014).
[7] Nicholas Carlini and David Wagner. 2014. ROP is Still Dangerous: Breaking
[11] Thomas H. Cormen, Clifford Stein, Ronald L. Rivest, and Charles E. Leiserson.
2009. Introduction to Algorithms. The MIT press.
[12] Crispan Cowan, Calton Pu, Dave Maier, Jonathan Walpole, Peat Bakke, Steve
Beattie, Aaron Grier, Perry Wagle, Qian Zhang, and Heather Hinton. 1998. Stack-
guard: automatic adaptive detection and prevention of buffer-overflow attacks..
In Usenix Security.
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-3747. (2006).
[13] CVEApache 2006. CVE-2006-3747: Off-by-one error in Apache 1.3.34. https:
[14] CVEnginx 2013. CVE-2013-2028: Nginx http server chunked encoding buffer
overflow 1.4.0. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2028.
(2013).
[15] CVEnullhttpd 2004. CVE-2002-1496: Heap-based buffer overflow in Null HTTP
Server 0.5.0. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1496.
(2004).
[16] CVEopenssh 2001. CVE-2001-0144: Integer overflow in OpenSSH 1.2.27. https:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0144. (2001).
[17] CVEorzhttpd 2009. CVE/bug in OrzHTTPd - Format String. https://www.
exploit-db.com/exploits/10282/. (2009).
[18] CVEproftpd 2006. CVE-2006-5815: Stack buffer overflow in ProFTPD 1.3.0. https:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5815. (2006).
[19] CVEsmbclient 2009. CVE-2009-1886: Format string vulnerability in smbclient
3.2.12. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1886. (2009).
[20] CVEsudo 2012. CVE-2012-0809: Format string vulnerability in SUDO 1.8.3. https:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0809. (2012).
[21] CVEWireshark 2014. CVE-2014-2299: Buffer overflow in Wireshark 1.8.0. https:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2299. (2014).
[22] CVEwuftpd 2001. CVE-2000-0573: Format string vulnerability in wu-ftpd 2.6.0.
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-0573. (2001).
[23] Thurston HY Dang, Petros Maniatis, and David Wagner. 2015. The performance
cost of shadow stacks and stack canaries. In Proceedings of the 10th ACM Sympo-
sium on Information, Computer and Communications Security. ACM, 555–566.
[24] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, and Fabian Monrose. 2014.
Stitching the Gadgets: On the Ineffectiveness of Coarse-Grained Control-Flow
Integrity Protection.. In USENIX Security.
[25] Lucas Davi, Ahmad-Reza Sadeghi, and Marcel Winandy. 2011. ROPdefender: A
detection tool to defend against return-oriented programming attacks. In Proceed-
ings of the 6th ACM Symposium on Information, Computer and Communications
Security.
[26] Solar Designer. 1997. return-to-libc attack. Bugtraq, Aug (1997).
[27] Ren Ding, Chenxiong Qian, Chengyu Song, Bill Harris, Taesoo Kim, and Wenke
Lee. 2017. Efficient Protection of Path-Sensitive Control Security. (2017).
(2002).
[28] Tyler Durden. 2002. Bypassing PaX ASLR protection. Phrack magazine #59
[29] Isaac Evans, Fan Long, Ulziibayar Otgonbaatar, Howard Shrobe, Martin Rinard,
Hamed Okhravi, and Stelios Sidiroglou-Douskos. 2015. Control jujutsu: On the
weaknesses of fine-grained control flow integrity. In Proceedings of the 22nd ACM
SIGSAC Conference on Computer and Communications Security.
[30] Andreas Follner, Alexandre Bartel, Hui Peng, Yu-Chen Chang, Kyriakos Ispoglou,
Mathias Payer, and Eric Bodden. 2016. PSHAPE: Automatically Combining
Gadgets for Arbitrary Method Execution. In International Workshop on Security
and Trust Management.
[31] Enes Göktas, Elias Athanasopoulos, Herbert Bos, and Georgios Portokalidis. 2014.
Out of control: Overcoming control-flow integrity. In Security and Privacy (SP),
2014 IEEE Symposium on.
[32] Andrei Homescu, Michael Stewart, Per Larsen, Stefan Brunthaler, and Michael
Franz. 2012. Microgadgets: size does matter in turing-complete return-oriented
programming. In Proceedings of the 6th USENIX conference on Offensive Technolo-
gies. USENIX Association, 7–7.
[33] Hong Hu, Zheng Leong Chua, Sendroiu Adrian, Prateek Saxena, and Zhenkai
Liang. 2015. Automatic Generation of Data-Oriented Exploits.. In USENIX Secu-
rity.
[34] Hong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong Chua, Prateek Saxena,
and Zhenkai Liang. 2016. Data-oriented programming: On the expressiveness of
non-control data attacks. In Security and Privacy (SP), 2016 IEEE Symposium on.
[35] Emily R Jacobson, Andrew R Bernat, William R Williams, and Barton P Miller.
2014. Detecting code reuse attacks with a model of conformant program execution.
In International Symposium on Engineering Secure Software and Systems.
(1962).
[36] Arthur B Kahn. 1962. Topological sorting of large networks. Commun. ACM
[37] V Katoch. Whitepaper on bypassing aslr/dep. Technical Report. Secfence,
Tech. Rep., September 2011.[Online]. Available: http://www.exploit-db.com/
wp-content/themes/exploit/docs/17914.pdf.
[38] Kil3r and Bulba. 2000. Bypassing StackGuard and StackShield. Phrack magazine
[39] James C King. 1976. Symbolic execution and program testing. Commun. ACM
[40] Volodymyr Kuznetsov, László Szekeres, Mathias Payer, George Candea, R Sekar,
#53 (2000).
(1976).
[41] Microsoft. 2015. Visual Studio 2015 — Compiler Options — Enable Control Flow
and Dawn Song. 2014. Code-Pointer Integrity.. In OSDI, Vol. 14. 00000.
Guard. (2015). https://msdn.microsoft.com/en-us/library/dn919635.aspx.
[42] Tilo Müller. 2008. ASLR smack & laugh reference. Seminar on Advanced Exploita-
tion Techniques (2008).
[43] Urban Müller. 1993. Brainfuck–an eight-instruction turing-complete program-
ming language. Available at the Internet address http://en. wikipedia. org/wik-
i/Brainfuck (1993).
[44] Ben Niu and Gang Tan. 2014. Modular control-flow integrity. ACM SIGPLAN
Notices 49 (2014).
[45] Ben Niu and Gang Tan. 2015. Per-input control-flow integrity. In Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications Security.
[46] Pakt. 2013. ropc: A turing complete ROP compiler. https://github.com/pakt/ropc.
(2013).
[47] Vasilis Pappas. 2012. kBouncer: Efficient and transparent ROP mitigation. tech.
[48] PAX-TEAM. 2003. PaX ASLR (Address Space Layout Randomization). http:
rep. Citeseer (2012).
//pax.grsecurity.net/docs/aslr.txt. (2003).
[49] Mathias Payer, Antonio Barresi, and Thomas R Gross. 2015. Fine-grained control-
flow integrity through binary hardening. In International Conference on Detection
of Intrusions and Malware, and Vulnerability Assessment.
[50] Michalis Polychronakis and Angelos D Keromytis. 2011. ROP payload detection
using speculative code execution. In Malicious and Unwanted Software (MAL-
WARE), 2011 6th International Conference on.
[51] The Chromium Projects. 2018. Control Flow Integrity. https://www.chromium.
org/developers/testing/control-flow-integrity. (2018).
[52] Gerardo Richarte and others. 2002. Four different tricks to bypass stackshield
[53] Jonathan Salwan and Allan Wirth. 2012. ROPGadget. https://github.com/
and stackguard protection. World Wide Web (2002).
JonathanSalwan/ROPgadget. (2012).
[54] Felix Schuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi, Ahmad-Reza
Sadeghi, and Thorsten Holz. 2015. Counterfeit object-oriented programming: On
the difficulty of preventing code reuse attacks in C++ applications. In Security
and Privacy (SP), 2015 IEEE Symposium on.
[55] Edward J Schwartz, Thanassis Avgerinos, and David Brumley. 2011. Q: Exploit
Hardening Made Easy.. In USENIX Security Symposium.
[56] Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: a concolic unit testing
engine for C. In ACM SIGSOFT Software Engineering Notes, Vol. 30. ACM, 263–272.
[57] Hovav Shacham. 2007. The Geometry of Innocent Flesh on the Bone: Return-
into-libc without Function Calls (on the x86). In Proceedings of CCS 2007, Sabrina