keyspacewon’tbeaccountedfor.Yousimplyincreaseyour
stepvaluetoaccountforthisshortage.Youinitializetwo
variables,startandend,tomaintainthebeginningandending
offsetsyoucanusetobreakapartthekeyspace.
Themathtoarriveatyouroffsetsandstepsizeisn’tprecise
byanymeans,anditcouldcauseyourcodetosearchbeyond
theendofthemaximumallowablekeyspace.However,you
fixthatwithinaforloop❹usedtostarteachoftheproducers.
Intheloop,youadjustyourendingstepvalue,end,shouldthat
valuefallbeyondthemaximumallowedkeyspacevalue.Each
iterationoftheloopcallsgenerate()❺,yourproducerfunction,
andpassestoitthestart(start)andend(end)keyspaceoffsets
forwhichtheproducerwilliterate.Youalsopassityourwork
anddonechannels,aswellasyourproducerWaitGroup.After
callingthefunction,youshiftyourstartandendvariablesto
accountforthenextrangeofkeyspacethatwillbepassedtoa
newproducer.Thisishowyoubreakupyourkeyspaceinto
smaller,moredigestibleportionsthattheprogramcanprocess
concurrently,withoutoverlappingeffortsbetweengoroutines.
Afteryourproducersarespunup,youuseaforloopto
createyourworkers❻.Inthiscase,you’recreating30of
them.Foreachiteration,youcallyourdecrypt()function❼,
passingtoittheciphertext,theworkchannel,thedone
channel,andtheconsumerWaitGroup.Thisspinsupyour
concurrentconsumers,whichbegintopullandprocesswork
astheproducerscreateit.
Iteratingthroughtheentirekeyspacetakestime.Ifyou
don’thandlethingscorrectly,themain()functionwillassuredly
exitbeforeyoudiscoverakeyorexhaustkeyspace.So,you
needtomakesuretheproducersandconsumershaveadequate
timetoeitheriteratetheentirekeyspaceordiscoverthe
correctkey.ThisiswhereyourWaitGroupscomein.Youcall
prodWg.Wait()❽toblockmain()untiltheproducershave
completedtheirtasks.Recallthattheproducershave
completedtheirtasksiftheyeitherexhaustthekeyspaceor
explicitlycanceltheprocessviathedonechannel.Afterthis
completes,youexplicitlyclosetheworkchannelsothe
consumerswon’tdeadlockcontinuallywhiletryingtoread
fromit.Finally,youblockmain()againbycallingconsWg.Wait()
❾togiveadequatetimefortheconsumersinyourWaitGroupto
completeanyremainingworkintheworkchannel.
RunningtheProgram
You’vecompletedyourprogram!Ifyourunit,youshouldsee
thefollowingoutput:
$gorunmain.go
2020/07/1214:27:47Startingproducers...
2020/07/1214:27:47Producersstarted!
2020/07/1214:27:47Startingconsumers...
2020/07/1214:27:47Consumersstarted!
2020/07/1214:27:47Nowwewait...
2020/07/1214:27:48Card[4532651325506680]foundusingkey[e612d0bbb6]
2020/07/1214:27:48Brute-forcecomplete
Theprogramstartstheproducersandconsumersandthen
waitsforthemtoexecute.Whenacardisfound,theprogram
displaysthecleartextcardandthekeyusedtodecryptthat
card.Sinceweassumethiskeyisthemagicalkeyforallcards,
weinterruptexecutionprematurelyandcelebrateoursuccess
bypaintingaself-portrait(notshown).
Ofcourse,dependingonthekeyvalue,brute-forcingona
homecomputercantakeasignificantamountoftime—think
daysorevenweeks.Fortheprecedingsamplerun,we
narrowedthekeyspacetofindthekeymorequickly.
However,completelyexhaustingthekeyspaceona2016
MacBookProtakesapproximatelysevendays.Nottoobadfor
aquick-and-dirtysolutionrunningonalaptop.
SUMMARY
Cryptoisanimportanttopicforsecuritypractitioners,even
thoughthelearningcurvecanbesteep.Thischaptercovered
symmetricandasymmetriccrypto,hashing,password
handlingwithbcrypt,messageauthentication,mutual
authentication,andbrute-forcingRC2.Inthenextchapter,
we’llgetintothenitty-grittyofattackingMicrosoftWindows.
12
WINDOWSSYSTEMINTERACTION
ANDANALYSIS
TherearecountlesswaysofdevelopingMicrosoftWindows
attacks—toomanytocoverinthischapter.Insteadof
discussingthemall,we’llintroduceandinvestigateafew
techniquesthatcanhelpyouattackWindows,whetherinitially
orduringyourpost-exploitationadventures.
AfterdiscussingtheMicrosoftAPIdocumentationand
somesafetyconcerns,we’llcoverthreetopics.First,we’lluse
Go’scoresyscallpackagetointeractwithvarioussystem-level
WindowsAPIsbyperformingaprocessinjection.Second,
we’llexploreGo’scorepackagefortheWindowsPortable
Executable(PE)formatandwriteaPEfileformatparser.
Third,we’lldiscusstechniquesforusingCcodewithnative
Gocode.You’llneedtoknowtheseappliedtechniquesin
ordertobuildanovelWindowsattack.
THEWINDOWSAPI’S
OPENPROCESS()FUNCTION
InordertoattackWindows,youneedtounderstandthe
WindowsAPI.Let’sexploretheWindowsAPIdocumentation
byexaminingtheOpenProcess()function,usedtoobtainahandle
onaremoteprocess.YoucanfindtheOpenProcess()
documentationathttps://docs.microsoft.com/en-
us/windows/desktop/api/processthreadsapi/nf-
processthreadsapi-openprocess/.Figure12-1showsthe
function’sobjectpropertydetails.
Figure12-1:TheWindowsAPIobjectstructureforOpenProcess()
Inthisparticularinstance,wecanseethattheobjectlooks
verysimilartoastructtypeinGo.However,theC++struct
fieldtypesdon’tnecessarilyreconcilewithGotypes,and
Microsoftdatatypesdon’talwaysmatchGodatatypes.
TheWindowsdatatypedefinitionreference,locatedat
https://docs.microsoft.com/en-
us/windows/desktop/WinProg/windows-data-types/,canbe
helpfulwhenreconcilingaWindowsdatatypewithGo’s
respectivedatatype.Table12-1coversthetypeconversion
we’lluseintheprocessinjectionexampleslaterinthis
chapter.
Table12-1:MappingWindowsDataTypestoGoDataTypes
WindowsdataType
Godatatype
BOOLEAN
byte
BOOL
int32
BYTE
byte
DWORD
uint32
DWORD32
uint32
DWORD64
uint64
WORD
uint16
HANDLE
uintptr(unsignedintegerpointer)
LPVOID
uintptr
SIZE_T
uintptr
LPCVOID
uintptr
HMODULE
uintptr
LPCSTR
uintptr
LPDWORD
uintptr
TheGodocumentationdefinestheuintptrdatatypeas“an
integertypethatislargeenoughtoholdthebitpatternofany
pointer.”Thisisaspecialdatatype,asyou’llseewhenwe
discussGo’sunsafepackageandtypeconversionslaterin“The
unsafe.PointeranduintptrTypes”onpage266.Fornow,let’s
finishwalkingthroughtheWindowsAPIdocumentation.
Next,youshouldlookatanobject’sparameters;the
Parameterssectionofthedocumentationprovidesdetails.For
example,thefirstparameter,dwDesiredAccess,providesspecifics
regardingthelevelofaccesstheprocesshandleshould
possess.Afterthat,theReturnValuesectiondefinesexpected
valuesforbothasuccessfulandfailedsystemcall(Figure12-
2).
Figure12-2:Thedefinitionfortheexpectedreturnvalue
We’lltakeadvantageofaGetLastErrorerrormessagewhen
usingthesyscallpackageinourupcomingexamplecode,
althoughthiswilldeviatefromthestandarderrorhandling
(suchasiferr!=nilsyntax)eversoslightly.
OurlastsectionoftheWindowsAPIdocument,
Requirements,providesimportantdetails,asshowninFigure
12-3.Thelastlinedefinesthedynamiclinklibrary(DLL),
whichcontainsexportablefunctions(suchasOpenProcess())and
willbenecessarywhenwebuildoutourWindowsDLL
module’svariabledeclarations.Saidanotherway,wecannot
calltherelevantWindowsAPIfunctionfromGowithout
knowingtheappropriateWindowsDLLmodule.Thiswill
becomeclearerasweprogressintoourupcomingprocess
injectionexample.
Figure12-3:TheRequirementssectiondefinesthelibraryrequiredtocalltheAPI.
THEUNSAFE.POINTERAND
UINTPTRTYPES
IndealingwiththeGosyscallpackage,we’llmostcertainly
needtosteparoundGo’stype-safetyprotections.Thereasonis
thatwe’llneed,forexample,toestablishsharedmemory
structuresandperformtypeconversionsbetweenGoandC.
Thissectionprovidesthegroundworkyouneedinorderto
manipulatememory,butyoushouldalsoexploreGo’sofficial
documentationfurther.
We’llbypassGo’ssafetyprecautionsbyusingGo’sunsafe
package(mentionedinChapter9),whichcontainsoperations
thatsteparoundthetypesafetyofGoprograms.Gohaslaid
outfourfundamentalguidelinestohelpusout:
Apointervalueofanytypecanbeconvertedtoanunsafe.Pointer.
Anunsafe.Pointercanbeconvertedtoapointervalueofanytype.
Auintptrcanbeconvertedtoanunsafe.Pointer.
Anunsafe.Pointercanbeconvertedtoauintptr.
WARNING
Keep in mind that packages that import the unsafe package may not be
portable,andthatalthoughGotypicallyensuresGoversion1compatibility,
usingtheunsafepackagebreaksallguaranteesofthis.
Theuintptrtypeallowsyoutoperformtypeconversionor
arithmeticbetweennativesafetypes,amongotheruses.
Althoughuintptrisanintegertype,it’susedextensivelyto
representamemoryaddress.Whenusedwithtype-safe
pointers,Go’snativegarbagecollectorwillmaintainrelevant
referencesatruntime.
However,thesituationchangeswhenunsafe.Pointeris
introduced.Recallthatuintptrisessentiallyjustanunsigned
integer.Ifapointervalueiscreatedusingunsafe.Pointerandthen
assignedtouintptr,there’snoguaranteethatGo’sgarbage
collectorwillmaintaintheintegrityofthereferencedmemory
location’svalue.Figure12-4helpstofurtherdescribethe
issue.
Figure12-4:Apotentiallydangerouspointerwhenusinguintptrandunsafe.Pointer
Thetophalfoftheimagedepictsuintptrwithareference
valuetoaGotype-safepointer.Assuch,itwillmaintainits
referenceatruntime,alongwithausteregarbagecollection.
Thelowerhalfoftheimagedemonstratesthatuintptr,although
itreferencesanunsafe.Pointertype,canbegarbagecollected,
consideringGodoesn’tpreservenormanagepointersto
arbitrarydatatypes.Listing12-1representstheissue.
funcstate(){
varonload=createEvents("onload")❶
varreceive=createEvents("receive")❷
varsuccess=createEvents("success")❸
mapEvents:=make(map[string]interface{})
mapEvents["messageOnload"]=unsafe.Pointer(onload)
mapEvents["messageReceive"]=unsafe.Pointer(receive)❹
mapEvents["messageSuccess"]=uintptr(unsafe.Pointer(success))❺
//Thislineissafe-retainsorginalvalue
fmt.Println(*(*string)(mapEvents["messageReceive"].(unsafe.Pointer)))❻
//Thislineisunsafe-originalvaluecouldbegarbagecollected
fmt.Println(*(*string)(unsafe.Pointer(mapEvents["messageSuccess"].(uintptr))))
❼
}
funccreateEvents(sstring)❽*string{
return&s
}
Listing12-1:Usinguintptrbothsecurelyandinsecurelywithunsafe.Pointer
Thiscodelistingcouldbesomeone’sattemptatcreatinga
statemachine,forexample.Ithasthreevariables,assigned
theirrespectivepointervaluesofonload❶,receive❷,andsuccess
❸bycallingthecreateEvents()❽function.Wethencreatea
mapcontainingakeyoftypestringalongwithavalueoftype
interface{}.Weusetheinterface{}typebecauseitcanreceive
disparatedatatypes.Inthiscase,we’lluseittoreceiveboth
unsafe.Pointer❹anduintptr❺values.
Atthispoint,youmostlikelyhavespottedthedangerous
piecesofcode.AlthoughthemapEvents["messageRecieve"]map
entry❹isoftypeunsafe.Pointer,itstillmaintainsitsoriginal
referencetothereceive❷variableandwillprovidethesame
consistentoutput❻asitdidoriginally.Contrarily,the
mapEvents["messageSuccess"]mapentry❺isoftypeuintptr.This
meansthatassoonastheunsafe.Pointervaluereferencingthe
successvariableisassignedtoauintptrtype,thesuccessvariable❸
isfreetobegarbagecollected.Again,uintptrisjustatype
holdingaliteralintegerofamemoryaddress,notareference
toapointer.Asaresult,there’snoguaranteethattheexpected
output❼willbeproduced,asthevaluemaynolongerbe
present.
Isthereasafewaytouseuintptrwithunsafe.Pointer?Wecando
sobytakingadvantageofruntime.Keepalive,whichcanprevent
thegarbagecollectionofavariable.Let’stakealookatthisby
modifyingourpriorcodeblock(Listing12-2).
funcstate(){
varonload=createEvents("onload")
varreceive=createEvents("receive")
varsuccess❶=createEvents("success")
mapEvents:=make(map[string]interface{})
mapEvents["messageOnload"]=unsafe.Pointer(onload)
mapEvents["messageReceive"]=unsafe.Pointer(receive)
mapEvents["messageSuccess"]=uintptr(unsafe.Pointer(success))❷
//Thislineissafe-retainsorginalvalue
fmt.Println(*(*string)(mapEvents["messageReceive"].(unsafe.Pointer)))
//Thislineisunsafe-originalvaluecouldbegarbagecollected
fmt.Println(*(*string)(unsafe.Pointer(mapEvents["messageSuccess"].(uintptr))))
runtime.KeepAlive(success)❸
}
funccreateEvents(sstring)*string{
return&s
}
Listing12-2:Listing7-2:Usingtheruntime.KeepAlive()functiontopreventgarbage
collectionofavariable
Seriously,we’veaddedonlyonesmalllineofcode❸!
Thisline,runtime.KeepAlive(success),tellstheGoruntimetoensure
thatthesuccessvariableremainsaccessibleuntilit’sexplicitly
releasedortherunstateends.Thismeansthatalthoughthe
successvariable❶isstoredasuintptr❷,itcan’tbegarbage
collectedbecauseoftheexplicitruntime.KeepAlive()directive.
BeawarethattheGosyscallpackageextensivelyuses
uintptr(unsafe.Pointer())throughout,andalthoughcertainfunctions,
likesyscall9(),havetypesafetythroughexception,notallthe
functionsemploythis.Further,asyouhackaboutyourown
projectcode,you’llalmostcertainlyrunintosituationsthat
warrantmanipulatingheaporstackmemoryinanunsafe
manner.
PERFORMINGPROCESSINJECTION
WITHTHESYSCALLPACKAGE
Often,weneedtoinjectourowncodeintoaprocess.This
maybebecausewewanttogainremotecommandlineaccess
toasystem(shell),orevendebugaruntimeapplicationwhen
thesourcecodeisn’tavailable.Understandingthemechanics
ofprocessinjectionwillalsohelpyouperformmore
interestingtasks,suchasloadingmemory-residentmalwareor
hookingfunctions.Eitherway,thissectiondemonstrateshow
touseGotointeractwiththeMicrosoftWindowsAPIsin
ordertoperformprocessinjection.We’llinjectapayload
storedonadiskintoexistingprocessmemory.Figure12-5
describestheoverallchainofevents.
Figure12-5:Basicprocessinjection
Instep1,weusetheOpenProcess()Windowsfunctionto
establishaprocesshandle,alongwiththedesiredprocess
accessrights.Thisisarequirementforprocess-level
interaction,whetherwe’redealingwithalocalorremote
process.
Oncetherequisiteprocesshandlehasbeenobtained,we
useitinstep2,alongwiththeVirtualAllocEx()Windows
function,toallocatevirtualmemorywithintheremoteprocess.
Thisisarequirementforloadingbyte-levelcode,suchas
shellcodeoraDLL,intotheremoteprocesses’memory.
Instep3,weloadbyte-levelcodeintomemorybyusing
theWriteProcessMemory()Windowsfunction.Atthispointinthe
injectionprocess,we,asattackers,gettodecidehowcreative
tobewithourshellcodeorDLL.Thisisalsotheplacewhere
youmightneedtoinjectdebuggingcodewhenattemptingto
understandarunningprogram.
Finally,instep4,weusetheCreateRemoteThread()Windows
functionasameanstocallanativeexportedWindowsDLL
function,suchasLoadLibraryA(),locatedinKernel32.dll,sothat
wecanexecutethecodepreviouslyplacedwithintheprocess
byusingWriteProcessMemory().
Thefourstepswejustdescribedprovideafundamental
processinjectionexample.We’lldefineafewadditionalfiles
andfunctionswithinouroverallprocessinjectionexamplethat
aren’tnecessarilydescribedhere,althoughwe’lldescribethem
indetailasweencounterthem.
DefiningtheWindowsDLLsandAssigning
Variables
ThefirststepistocreatethewinmodsfileinListing12-3.
(Allthecodelistingsattherootlocationof/existunderthe
providedgithubrepohttps://github.com/blackhat-go/bhg/.)
ThisfiledefinesthenativeWindowsDLL,whichmaintains
exportedsystem-levelAPIs,thatwe’llcallbyusingtheGo
syscallpackage.Thewinmodsfilecontainsdeclarationsand
assignmentsofmoreWindowsDLLmodulereferencesthan
requiredforoursampleproject,butwe’lldocumentthemso
thatyoucanleveragethoseinmoreadvancedinjectioncode.
import"syscall"
var(
❶ModKernel32=syscall.NewLazyDLL("kernel32.dll")
modUser32=syscall.NewLazyDLL("user32.dll")
modAdvapi32=syscall.NewLazyDLL("Advapi32.dll")
ProcOpenProcessToken=modAdvapi32.NewProc("GetProcessToken")
ProcLookupPrivilegeValueW=
modAdvapi32.NewProc("LookupPrivilegeValueW")
ProcLookupPrivilegeNameW=
modAdvapi32.NewProc("LookupPrivilegeNameW")
ProcAdjustTokenPrivileges=
modAdvapi32.NewProc("AdjustTokenPrivileges")
ProcGetAsyncKeyState=modUser32.NewProc("GetAsyncKeyState")
ProcVirtualAlloc=ModKernel32.NewProc("VirtualAlloc")
ProcCreateThread=ModKernel32.NewProc("CreateThread")
ProcWaitForSingleObject=ModKernel32.NewProc("WaitForSingleObject")
ProcVirtualAllocEx=ModKernel32.NewProc("VirtualAllocEx")
ProcVirtualFreeEx=ModKernel32.NewProc("VirtualFreeEx")
ProcCreateRemoteThread=ModKernel32.NewProc("CreateRemoteThread")
ProcGetLastError=ModKernel32.NewProc("GetLastError")
ProcWriteProcessMemory=ModKernel32.NewProc("WriteProcessMemory")
❷ProcOpenProcess=ModKernel32.NewProc("OpenProcess")
ProcGetCurrentProcess=ModKernel32.NewProc("GetCurrentProcess")
ProcIsDebuggerPresent=ModKernel32.NewProc("IsDebuggerPresent")
ProcGetProcAddress=ModKernel32.NewProc("GetProcAddress")
ProcCloseHandle=ModKernel32.NewProc("CloseHandle")
ProcGetExitCodeThread=ModKernel32.NewProc("GetExitCodeThread")
)
Listing12-3:Thewinmodsfile(/ch-12/procInjector/winsys/winmods.go)
WeusetheNewLazyDLL()methodtoloadtheKernel32DLL
❶.Kernel32managesmuchoftheinternalWindowsprocess
functionality,suchasaddressing,handling,memory
allocation,andmore.(It’sworthnotingthat,asofGoversion
1.12.2,youcanuseacoupleofnewfunctionstobetterload
DLLsandpreventsystemDLLhijackingattacks:LoadLibraryEx()