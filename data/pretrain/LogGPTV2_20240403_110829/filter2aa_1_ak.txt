     token-based authentication
    system stores this info directly in some sort of token. Instead of storing your information server-side and querying it using a session ID, tokens allow servers to deduce your identity by decoding the token itself. This way, applications won’t have to store and maintain session information server-side.
    在基于会话的身份验证中，服务器会存储您的信息并使用相应的会话ID来验证您的身份，而基于令牌的身份验证系统直接将此信息存储在某种令牌中。与使用会话ID在服务器端存储和查询您的信息不同，令牌允许服务器通过解码令牌本身来推断您的身份。这样，应用程序就不必在服务器端存储和维护会话信息了。
    This system comes with a risk: if the server uses information contained in the token to determine the user’s identity, couldn’t users modify the information in the tokens and log in as someone else? To prevent token forgery attacks like these, some applications encrypt their tokens, or encode the token so that it can be read by only the application itself or other authorized parties. If the user can’t understand the contents of the token, they probably can’t tamper with it effectively either. Encrypting or encoding a token does not prevent token forgery completely. There are ways that an attacker can tamper with an encrypted token without understanding its contents. But it’s a lot more difficult than tampering with a plaintext token. Attackers can often decode encoded tokens to tamper with them.
    该系统存在风险：如果服务器使用令牌中包含的信息来确定用户的身份，那么用户是否能够修改令牌中的信息并作为其他人登录？为了防止此类令牌伪造攻击，一些应用程序会加密其令牌或者将令牌编码，以便只有应用程序本身或其他授权方可以读取。如果用户无法理解令牌的内容，则很可能无法有效篡改它。加密或编码令牌并不能完全防止令牌伪造。攻击者有可能修改加密令牌的内容而不理解其内容，但这比篡改明文令牌要困难得多。攻击者经常可以对编码后的令牌进行解码，以便篡改它们。
    Another more reliable way applications protect the integrity of a token is by signing the token and verifying the token signature when it arrives at the server.
     Signatures
    are used to verify the integrity of a piece of data. They are special strings that can be generated only if you know a secret key. Since there is no way of generating a valid signature without the secret key, and only the server knows what the secret key is, a valid signature suggests that the token is probably not altered by the client or any third party. Although the implementations by applications can vary, token-based authentication works like this:
    应用程序保护令牌完整性的一种更可靠的方法是对令牌进行签名，并在其到达服务器时验证令牌签名。签名用于验证数据的完整性。它们是特殊的字符串，只有如果您知道秘密密钥才能生成。由于没有办法在不知道秘密密钥的情况下生成有效签名，而且只有服务器知道秘密密钥是什么，因此有效的签名表明令牌可能未被客户端或任何第三方更改。虽然应用程序的实现可能会有所不同，但基于令牌的身份验证的工作方式如下：
     The user logs in with their credentials.
     The server validates those credentials and provides the user with a signed token.
     The user sends the token with every request to prove their identity.
     Upon receiving and validating the token, the server reads the user’s identity information from the token and responds with confidential data.
    JSON Web Tokens
    The
     JSON Web Token (
     JWT
     )
    is one of the most commonly used types of authentication tokens. It has three components: a header, a payload, and a signature.
    JSON Web Token（JWT）是最常用的身份验证令牌之一。它有三个组成部分：头部、负载和签名。
    The
     header
    identifies the algorithm used to generate the signature. It’s a base64url-encoded string containing the algorithm name. Here’s what a JWT header looks like:
    头部标识用于生成签名的算法。这是一个base64url编码的字符串，包含算法名称。以下是JWT头的样式：
eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K
    This string is the base64url-encoded version of this text:
    这个字符串是这段文本的base64url编码版本：
{ "alg" : "HS256", "typ" : "JWT" }
    The
     payload
    section contains information about the user’s identity. This section, too, is base64url encoded before being used in the token. Here’s an example of the payload section, which is the base64url-encoded string of
     { "
     user_name
     " : "
     admin
     ", }
    :
    载荷部分包含有关用户身份的信息。在将该部分用于令牌之前，也会进行base64url编码。以下是载荷部分的示例，这是“{“user_name”：“admin”}”的base64url编码字符串：
eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg
    Finally, the
     signature
    section validates that the user hasn’t tampered with the token. It’s calculated by concatenating the header with the payload, then signing it with the algorithm specified in the header, and a secret key. Here’s what a JWT signature looks like:
    最后，签名部分验证用户没有篡改令牌。它通过将头部与有效载荷串联起来，然后使用头部中指定的算法和秘钥进行签名来计算。以下是JWT签名的样式：
4Hb/6ibbViPOzq9SJflsNGPWSk6B8F6EqVrkNjpXh7M
    For this specific token, the signature was generated by signing the string
     eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg
    with the HS256 algorithm using the secret key
     key
    . The complete token concatenates each section (the header, payload, and signature), separating them with a period (
     .
    ):
    该特定令牌的签名是使用HS256算法使用密钥key签名字符串eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg而生成的。完整的令牌将每个部分（标头，载荷和签名）连接起来，用句点（.）隔开：
eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg.4Hb/6ibbViPOzq9SJflsNGPWSk6B8F6EqVrkNjpXh7M
    When implemented correctly, JSON web tokens provide a secure way to identify the user. When the token arrives at the server, the server can verify that the token has not been tampered with by checking that the signature is correct. Then the server can deduce the user’s identity by using the information contained in the payload section. And since the user does not have access to the secret key used to sign the token, they cannot alter the payload and sign the token themselves.
    当 JSON Web Token 被正确实现时，它提供了一种安全的方式来识别用户。当令牌到达服务器时，服务器可以通过检查签名是否正确来验证令牌未被篡改。然后，服务器可以通过使用负载部分所包含的信息来推断用户的身份。由于用户无法访问用于签署令牌的秘钥，因此他们无法更改有效负载并签署令牌。
    But if implemented incorrectly, there are ways that an attacker can bypass the security mechanism and forge arbitrary tokens.
    但是，如果未正确实施，攻击者可以绕过安全机制并伪造任意令牌。
    Manipulating the alg Field
    Sometimes applications fail to verify a token’s signature after it arrives at the server. This allows an attacker to simply bypass the security mechanism by providing an invalid or blank signature.
    有时，应用程序在接收到令牌后无法验证其签名。这使得攻击者可以通过提供无效或空白的签名来轻松绕过安全机制。
    One way that attackers can forge their own tokens is by tampering with the
     alg
    field of the token header, which lists the algorithm used to encode the signature. If the application does not restrict the algorithm type used in the JWT, an attacker can specify which algorithm to use, which could compromise the security of the token.
    攻击者可以通过篡改token头的"alg"字段来伪造自己的令牌。该字段列出用于编码签名的算法。如果应用程序不限制JWT中使用的算法类型，攻击者可以指定要使用的算法，从而危及令牌的安全性。
    JWT supports a
     none
    option for the algorithm type. If the
     alg
    field is set to
     none
    , even tokens with empty signature sections would be considered valid. Consider, for example, the following token:
    JWT支持算法类型中的无选项。如果alg字段设置为none，则即使签名部分为空的令牌也将被视为有效。例如，请考虑以下令牌：
eyAiYWxnIiA6ICJOb25lIiwgInR5cCIgOiAiSldUIiB9Cg.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg.
    This token is simply the base64url-encoded versions of these two blobs, with no signature present:
    这个令牌只是这两个 Blob 的 base64url 编码版本，没有签名。
{ "alg" : "none", "typ" : "JWT" } { "user" : "admin" }
    This feature was originally used for debugging purposes, but if not turned off in a production environment, it would allow attackers to forge any token they want and impersonate anyone on the site.
    该功能最初用于调试目的，但如果在生产环境中未关闭，则会允许攻击者伪造任何令牌并冒充站点上的任何人。
    Another way attackers can exploit the
     alg
    field is by changing the type of algorithm used. The two most common types of signing algorithms used for JWTs are HMAC and RSA. HMAC requires the token to be signed with a key and then later verified with the same key. When using RSA, the token would first be created with a private key, then verified with the corresponding public key, which anyone can read. It is critical that the secret key for HMAC tokens and the private key for RSA tokens be kept a secret.
    攻击者利用alg域的另一种方式是改变使用的算法类型。用于JWT的两种最常见的签名算法类型是HMAC和RSA。HMAC需要使用密钥对令牌进行签名，然后使用相同的密钥进行验证。在使用RSA时，令牌首先会使用私钥创建，然后使用对应的公钥进行验证，任何人都可以读取。重要的是，HMAC令牌的密钥和RSA令牌的私钥必须保密。
    Now let’s say that an application was originally designed to use RSA tokens. The tokens are signed with a private key A, which is kept a secret from the public. Then the tokens are verified with public key B, which is available to anyone. This is okay as long as the tokens are always treated as RSA tokens. Now if the attacker changes the
     alg
    field to HMAC, they might be able to create valid tokens by signing the forged tokens with the RSA public key, B. When the signing algorithm is switched to HMAC, the token is still verified with the RSA public key B, but this time, the token can be signed with the same public key too.
    现在我们假设一个应用程序原本是设计用于使用RSA令牌。令牌使用私钥A进行签名，该私钥被保密不公开。然后使用公钥B进行令牌验证，而该公钥可供任何人使用。只要始终将令牌视为RSA令牌，这是可以的。现在，如果攻击者更改alg字段为HMAC，则可能通过使用RSA公钥B对伪造令牌进行签名来创建有效令牌。当签名算法切换为HMAC时，令牌仍然使用RSA公钥B进行验证，但这次，令牌也可以使用相同的公钥进行签名。
    Brute-Forcing the Key
    It could also be possible to guess, or
     brute-force
    , the key used to sign a JWT. The attacker has a lot of information to start with: the algorithm used to sign the token, the payload that was signed, and the resulting signature. If
    the key used to sign the token is not complex enough, they might be able to brute-force it easily. If an attacker is not able to brute-force the key, they might try leaking the secret key instead. If another vulnerability, like a directory traversal, external entity attack (XXE), or SSRF exists that allows the attacker to read the file where the key value is stored, the attacker can steal the key and sign arbitrary tokens of their choosing. We’ll talk about these vulnerabilities in later chapters.
    攻击者有可能通过猜测或暴力攻击密钥来签名 JWT。攻击者有很多信息可供参考：签名令牌使用的算法、已签名的有效负载以及签名结果。如果用于签名令牌的密钥不够复杂，他们可能很容易地进行暴力攻击。 如果攻击者无法暴力攻击密钥，他们可能会尝试泄露秘密密钥。 如果存在其他漏洞，例如目录遍历、外部实体攻击（XXE）或SSRF，允许攻击者读取密钥值存储的文件，则攻击者可以窃取密钥并签名其选择的任意令牌。我们将在后面的章节中讨论这些漏洞。
    Reading Sensitive Information
    Since JSON web tokens are used for access control, they often contain information about the user. If the token is not encrypted, anyone can base64-decode the token and read the token’s payload. If the token contains sensitive information, it might become a source of information leaks. A properly implemented signature section of the JSON web token provides data integrity, not confidentiality.
    由于JSON Web令牌用于访问控制，因此它们通常包含有关用户的信息。如果令牌未加密，则任何人都可以对其进行base64解码并读取其有效载荷。如果令牌包含敏感信息，则它可能成为信息泄漏的来源。JSON Web令牌的正确实施的签名部分提供了数据完整性，而不是保密性。
    These are just a few examples of JWT security issues. For more examples of JWT vulnerabilities, use the search term
     JWT security issues
    . The security of any authentication mechanism depends not only on its design, but also its implementation. JWTs can be secure, but only if implemented properly.
    这些只是JWT安全问题的一些例子。如果想了解更多JWT漏洞的例子，请使用搜索词JWT安全问题。任何身份验证机制的安全性不仅取决于其设计，还取决于其实施。JWT可以很安全，但前提是必须正确实施。
    The Same-Origin Policy
    The
     same-origin policy (
     SOP)
    is a rule that restricts how a script from one origin can interact with the resources of a different origin. In one sentence, the SOP is this: a script from page A can access data from page B only if the pages are of the same origin. This rule protects modern web applications and prevents many common web vulnerabilities.
    同源策略是一条规则，限制来自一个源的脚本与不同源的资源进行交互。简单来说，同源策略就是这样的：只有当页面A和B的源相同时，页面A的脚本才能访问页面B的数据。该规则保护现代Web应用程序，防止许多常见的Web漏洞。
    Two URLs are said to have the same origin if they share the same protocol, hostname, and port number. Let’s look at some examples. Page A is at this URL:
    如果两个URL共享相同的协议，主机名和端口号，则称它们具有相同的来源。让我们看一些示例。页面A在此URL上：
      https://medium.com/@vickieli
    It uses HTTPS, which, remember, uses port 443 by default. Now look at the following pages to determine which has the same origin as page A, according to the SOP:
    它使用 HTTPS，需要记住，默认使用 443 端口。现在查看以下页面，确定哪个页面与页面 A 拥有相同的来源，遵守 SOP。
      https://medium.com/
      http://medium.com/
      https://twitter.com/@vickieli7
      https://medium.com:8080/@vickieli
    The
     https://medium.com/
    URL is of the same origin as page A, because the two pages share the same origin, protocol, hostname, and port number. The other three pages do not share the same origin as page A.
     http://medium.com/
    is of a different origin from page A, because their protocols differ.
     https://medium.com/
    uses HTTPS, whereas
     http://medium.com/
    uses
    HTTP.
     https://twitter.com/@vickieli7
    is of a different origin as well, because it has a different hostname. Finally,
     https://medium.com:8080/@vickieli
    is of a different origin because it uses port 8080, instead of port 443.
    `https://medium.com/` 和 `page A` 具有相同的源，因为它们共享相同的源、协议、主机名和端口号。其他三个页面与 `page A` 不共享相同的源。`http://medium.com/` 与 `page A` 来源不同，因为它们的协议不同。`https://medium.com/` 使用 HTTPS，而 `http://medium.com/` 使用 HTTP。`https://twitter.com/@vickieli7` 来源也不同，因为它有不同的主机名。最后，`https://medium.com:8080/@vickieli` 来源不同，因为它使用了 8080 端口，而不是 443 端口。
    Now let’s consider an example to see how SOP protects us. Imagine that you’re logged in to your banking site at
     onlinebank.com
    . Unfortunately, you click on a malicious site,
     attacker.com
    , in the same browser.
    现在让我们考虑一个例子，看看SOP如何保护我们。想象你正在onlinebank.com网站登录你的银行账户。不幸的是，你在同一个浏览器中点击了一个恶意网站attacker.com。
    The malicious site issues a GET request to
     onlinebank.com
    to retrieve your personal information. Since you’re logged into the bank, your browser automatically includes your cookies in every request you send to
     onlinebank.com
    , even if the request is generated by a script on a malicious site. Since the request contains a valid session ID, the server of
     onlinebank.com
    fulfills the request by sending the HTML page containing your info. The malicious script then reads and retrieves the private email addresses, home addresses, and banking information contained on the page.
    恶意网站向onlinebank.com发出GET请求，以检索您的个人信息。由于您已登录银行，在您发送到onlinebank.com的每个请求中，您的浏览器会自动包含您的Cookie，即使该请求是由恶意网站上的脚本生成的。由于请求包含有效的会话ID，onlinebank.com的服务器通过发送包含您信息的HTML页面来满足请求。恶意脚本然后读取和检索该页面上包含的私人电子邮件地址、家庭地址和银行信息。
    Luckily, the SOP will prevent the malicious script hosted on
     attacker.com
    from reading the HTML data returned from
     onlinebank.com
    . This keeps the malicious script on page A from obtaining sensitive information embedded within page B.
    幸运的是，SOP可以防止攻击者.com上托管的恶意脚本能阅读来自onlinebank.com的HTML数据，这可以保护页面A上的恶意脚本无法获得嵌入在页面B中的敏感信息。
    Learn to Program
    You should now have a solid background to help you understand most of the vulnerabilities we will cover. Before you set up your hacking tools, I recommend that you learn to program. Programming skills are helpful, because hunting for bugs involves many repetitive tasks, and by learning a programming language such as Python or shell scripting, you can automate these tasks to save yourself a lot of time.
    现在，您应该具备扎实的背景知识，能帮助您理解我们将要涵盖的大部分漏洞。在您设置黑客工具之前，我建议您先学习编程。编程技能非常有帮助，因为寻找漏洞涉及到许多重复性的任务，通过学习 Python 或 shell 脚本等编程语言，您可以自动化这些任务，节省大量时间。
    You should also learn to read JavaScript, the language with which most sites are written. Reading the JavaScript of a site can teach you about how it works, giving you a fast track to finding bugs. Many top hackers say that their secret sauce is that they read JavaScript and search for hidden endpoints, insecure programming logic, and secret keys. I’ve also found many vulnerabilities by reading JavaScript source code.
    你也应当学习阅读 JavaScript，因为大多数网站都是用它编写的。阅读一个网站的 JavaScript 可以让你了解它的工作方式，从而帮助你更快地发现漏洞。许多顶尖的黑客表示，他们的秘密武器就是阅读 JavaScript 并搜索隐藏的端点、不安全的编程逻辑和秘密密钥。我也通过阅读 JavaScript 源代码发现了许多漏洞。
    Codecademy is a good resource for learning how to program. If you prefer to read a book instead,
     Learn Python the Hard Way
    by Zed Shaw (Addison-Wesley Professional, 2013) is a great way to learn Python. And reading
     Eloquent JavaScript
    , Third Edition, by Marijn Haverbeke (No Starch Press, 2019) is one of the best ways to master JavaScript.
    Codecademy是学习编程的好资源。如果你更喜欢阅读书籍，Zed Shaw的《笨办法学Python》(Addison-Wesley Professional，2013)是学习Python的绝佳方式。而阅读Marijn Haverbeke的《JavaScript精解》第三版(No Starch Press，2019)是掌握JavaScript的最佳方式之一。
4
      Environmental Setup and Traffic Interception
    You’ll save yourself a lot of time and headache if you hunt for bugs within a well-oiled lab. In this chapter, I’ll guide you, step-by-step, through setting up your hacking environment. You’ll configure your browser to work with Burp Suite, a web proxy that lets you view and alter HTTP requests and responses sent between your browser and web servers. You’ll learn to use Burp’s features to intercept web traffic, send automated and repeated requests, decode encoded content, and compare requests. I will also talk about how to take good bug bounty notes.
    如果你在一个井然有序的实验室里寻找漏洞，你将会节省很多时间和烦恼。在这一章节中，我将一步一步地为你设置黑客环境。你将会配置你的浏览器与Burp Suite一同工作，Burp Suite是一个网络代理，让你可以查看和更改你的浏览器和网页服务器之间发送的HTTP请求和响应。你将会学习使用Burp的功能来截获网络流量，发送自动化和重复请求，解码编码内容和比较请求。我也会讲解如何记录好的漏洞赏金笔记。
    This chapter focuses on setting up an environment for web hacking only. If your goal is to attack mobile apps, you’ll need additional setup and tools. We’ll cover these in
     Chapter 23
    , which discusses mobile hacking.
    本章重点介绍建立网络黑客环境的步骤。如果你的目标是攻击移动应用程序，你需要额外的设置和工具。我们将在第23章介绍移动黑客，讨论这些内容。
    Choosing an Operating System
    Before we go on, the first thing you need to do is to choose an operating system. Your operating system will limit the hacking tools available to you. I recommend using a Unix-based system, like Kali Linux or macOS, because many open source hacking tools are written for these systems.
     Kali Linux
    is a Linux distribution designed for digital forensics and hacking. It includes many useful bug bounty tools, such as Burp Suite, recon tools like DirBuster and Gobuster, and fuzzers like Wfuzz. You can download Kali Linux from
     https://www.kali.org/downloads/
    .
    在我们继续之前，首先要做的就是选择一个操作系统。你的操作系统将限制可用的黑客工具。我建议使用基于Unix的系统，如Kali Linux或macOS，因为许多开源黑客工具都是为这些系统编写的。Kali Linux是一种专为数字取证和黑客设计的Linux发行版。它包括许多有用的漏洞赏金工具，例如Burp Suite、类似DirBuster和Gobuster的recon工具以及类似Wfuzz的模糊器。可以从https://www.kali.org/downloads/下载Kali Linux。
    If these options are not available to you, feel free to use other operating systems for hacking. Just keep in mind that you might have to learn to use different tools than the ones mentioned in this book.
    如果这些选项对您不可用，可以自由地使用其他操作系统进行黑客攻击。只需记住，您可能需要学习使用不同于本书中提到的工具。
    Setting Up the Essentials: A Browser and a Proxy
    Next, you need a web browser and a web proxy. You’ll use the browser to examine the features of a target application. I recommend using Firefox, since it’s the simplest to set up with a proxy. You can also use two different browsers when hacking: one for browsing the target, and one for researching vulnerabilities on the internet. This way, you can easily isolate the traffic of your target application for further examination.
    接下来，您需要一个网络浏览器和一个网络代理。使用浏览器来检查目标应用程序的功能。建议使用Firefox，因为它是最容易与代理配对的。黑客时，也可以使用两个不同的浏览器：一个用于浏览目标，一个用于在网上研究漏洞。这样，您可以轻松地隔离目标应用程序的流量以进一步检查。
    A
     proxy
    is software that sits between a client and a server; in this case, it sits between your browser and the web servers you interact with. It intercepts your requests before passing them to the server, and intercepts the server’s responses before passing them to you, like this:
    代理是一种软件，它位于客户端和服务器之间；在这种情况下，它位于您的浏览器和您交互的web服务器之间。它在将您的请求传递给服务器之前截获它们，并在将服务器的响应传递给您之前截获它们，就像这样：
     Browser  Proxy  Server
    Using a proxy is essential in bug bounty hunting. Proxies enable you to view and modify the requests going out to the server and the responses coming into your browser, as I’ll explain later in this chapter. Without a proxy, the browser and the server would exchange messages automatically, without your knowledge, and the only thing you would see is the final resulting web page. A proxy will instead capture all messages before they travel to their intended recipient.
    在漏洞赏金猎人的活动中，使用代理是必不可少的。如本章节所述，代理能够让你查看和修改发往服务器和从服务器返回到浏览器的请求和响应。如果没有代理，浏览器和服务器将自动交换信息，你将一无所知，只能看到最终显示的网页。代理将拦截所有信息，而不是让它们直接发送到其预定的接收者那里。
    Proxies therefore allow you to perform recon by examining and analyzing the traffic going to and from the server. They also let you examine interesting requests to look for potential vulnerabilities and exploit these vulnerabilities by tampering with requests.
    代理服务器因此允许您通过检查和分析发送到服务器和从服务器返回的流量来执行侦察。他们还允许您检查有趣的请求，以寻找潜在的漏洞，并通过篡改请求来利用这些漏洞。
    For example, let’s say that you visit your email inbox and intercept the request that will return your email with a proxy. It’s a GET request to a URL that contains your user ID. You also notice that a cookie with your user ID is included in the request:
    例如，假设您访问电子邮件收件箱并使用代理拦截将返回您的电子邮件的请求。这是一个GET请求，包含您的用户ID的URL。您还注意到请求中包含具有您的用户ID的cookie。
GET /emails/USER_ID HTTP/1.1
Host: example.com