methods and inserts them into our data structures, and 3) an enforce-
ment unit that intercepts invocations on JS bridges and invocations
made via HTML5 APIs to ensure that the origin making the request
is granted the access right by the developer and to block the request
otherwise, or to prompt the user for granting permissions. We will
analyze the performance of each component separately. We conduct
all of our experiments on a LG Google Nexus 5 smartphone, which
runs Android 6.0 (Marshmallow) and is equipped with 2.26GHz
quad-core Qualcomm Snapdragon 800 processor and 2GB RAM.
App decompilation and static analysis unit. We ﬁrst require the
decompilation of class ﬁles associated with Draconian policy rules
into smali bytecode. Currently, we are performing this off-line (not
on Android); however, there are existing tools that can decompile
apps on the Android platform. For example, apktool [13] decompiles
Java ObjectChromium IPCInjectionObject queryInjectedObject.myExposedMethod()BrowserRendererV8 Javascript EngineV8 ObjectEnforcementExecutionGin Binding SystemoriginClass nameListing 5: Small, large, semantically large rules for JS interfaces
// small policy rule
mWebView.loadUrl("policyrule;allowjsinterface;
https://mydomain.com;GeoWebViewActivity$JsObject");
// large policy rule
mWebView.loadUrl("policyrule;allowjsinterface;
https://mydomain.com;GeoWebViewActivity$JsObject");
// (semantically) large policy rule
mWebView.loadUrl("policyrule;allowjsinterface;
https://mydomain.com;GeoWebViewActivity$JsObject")
Parsing cost
(1) small policy
(2) large policy
(3) semantically large policy
(1) w/ small permission ﬁle
(1) w/ large permission ﬁle
average (ms)
standard deviation
1.874
2.453
1.633
2.428
8.434
1.248
0.811
0.847
0.820
2.269
Table 3: Runtime for policy rule parsing and insertion on Nexus 5
consider two cases: 1) a small permission ﬁle (created by the static
analysis unit) for a class with ﬁve methods where each method uses
ﬁve or less permissions, 2) a large permission ﬁle with 20 class meth-
ods and ﬁve permissions for each method. We consider the second
case to be not very likely to occur and use it only as an upper bound
on the performance for permission parsing. For both of these cases,
we use a simple policy rule (including 5 methods), with the addition
of the permission list that contains all the ﬁve permissions the app
(without using all tag) grants to the given subject. Table 3 shows
the results of policy parsing (which include permission parsing). As
can be observed from the table, the run times are still in the order
of milliseconds, with the total run time being higher for when the
permission ﬁle that contains many methods that use all of the app
permissions.
Enforcement. It is important for the enforcement to be efﬁcient
since this an action that is expected to be performed frequently
during the lifetime of an app. Thus, any delay can affect the app’s
run time performance and degrade user experience. Here, we take
a closer look at the performance of the enforcement unit for the
JavaScript interface and HTML5 channels. We do not present our
results for the event handler channel since they are intrinsically
similar to those of the JavaScript interface channel. For the former
cases, we report the average time it takes (and standard deviation)
to allow and disallow an origin.
• JavaScript interface channel. We take the same approach as in our
evaluation for policy parsing, and perform enforcement correspond-
ing to small (5 methods), large (15 methods) and semantically large
(all methods) policy rules. For each case, we assume the origin wants
to access the method that is the last method in the provided method
list so that we get an upper bound on the run time (since we perform
linear search in vector that contains the methods associated with a
policy rule). Table 4 shows the results for the JavaScript interface
channel. Evidently, the enforcement overhead is negligible (in the
order of microseconds).
• HTML5 API channel. For the HTML5 API channel, we consider
two cases: 1) an access control decision is made solely by the sys-
tem, and 2) the user is prompted to make a decision on the use of
Enforcement cost
small policy (allow)
small policy (block)
large policy (allow)
large policy (block)
semantically large policy (allow)
average (ms)
standard deviation
0.356
0.243
0.965
0.551
0.146
0.260
0.051
1.214
0.124
0.0252
Table 4: Runtime for enforcement on JavaScript interface channel
on Nexus 5
Enforcement cost
system (allow)
system (block)
user (allow)
user (block)
average (ms)
standard deviation
0.282
0.130
0.326
0.286
0.093
0.029
0.116
0.076
Table 5: Runtime for enforcement on HTML5 channel on Nexus 5
permissions. Table 5 shows the time taken by the system for both
of these cases for the HTML5 API channel. We do not show the
time the user takes to grant or revoke access to permission-protected
resources. Naturally, this will be at least in the order of seconds with
a large variation, and is many orders of magnitude larger than the
purely-system based access control decision. Again we observe sub-
millisecond delays highlighting the efﬁciency of DRS enforcement.
6. RELATED WORK
Previous work has discussed the problem that foreign code gov-
erns the same privileges as the host application in different contexts.
Protecting against third-party libraries and other inter-module
threats. Third-party libraries governing the same permissions as the
host app has been shown to be problematic by the previous work.
Working towards solving this issue, AdSplit [23] suggests separation
of ad components from the core app and running them in their own
processes for protecting against the malicious activities that can be
performed by potentially-malicious ad libraries. In [24], the authors
discuss the vulnerabilities due to the nonexistence of origin-based
protection on the Android system. More speciﬁcally, they show
that third-party libraries make host apps vulnerable to cross-origin
attacks on the app-to-app channels such as intent and the scheme
mechanism. Their solution, Morbs, gives developers a means to
express new policies about how two apps can communicate, and it
labels messages between apps with their origins so that the developer-
written permissions can be enforced at run time. One short-falling
of this solution is that it works for only app-to-app communication
channels. FlexDroid [25] gives developers a way of creating ﬁne-
grained access control policies on the system resources for third-
party libraries based on Android permissions. To enforce the policies,
they examine the Dalvik call stack at run time to identify the origin
of the call and its associated permissions. Case [26] takes another
approach and instruments apps with a module that can mediate
access between the submodules (which can even be in the granularity
of a Java class) of the app. These solutions are not limited to only
app-to-app channels as Morbs and can protect an app against inter-
module threats; however, they do not provide protection against
arbitrary foreign content that can be loaded within a single in-app
module (e.g., via web containers).
Analysis, attacks, and defenses for WebViews. Vulnerability of
WebViews has been extensively discussed by previous work [7, 8, 1,
9, 10]. In [7], the authors present several classes of attacks that can
be launched against apps that use WebViews. Chin et al. present a
static analysis tool that can identify whether an app is vulnerable to
WebView attacks [8]. Mutchler et al. present a large-scale analysis
on mobile web applications, and present the trend of vulnerabilities
in these applications. None of these work implement any defense
mechanism targeting WebViews [1]. In [27], the authors present
an access control mechanism for WebViews. Their approach uses
static analysis to identify the use of security-sensitive APIs in the
exposed Java class, and notiﬁes the user if any such use is found.
The user is then prompted to allow or completely block the binding
of the Java object. The main drawback of this approach is that
after the user allows the binding, they do not provide any origin-
based access control, so all the origins still have the same access
rights. Additionally, their focus is only on the permission-protected
resources.
WebView-related attacks on hybrid frameworks and bringing
origin-based access control. Georgiev et al. discuss the nonex-
istence of origin-based access control in hybrid frameworks and
propose a capability-based approach (NoFrak), where app developer
whitelists origins that are allowed to access system resources [2].
The drawback of their approach is that it works only for the Phone-
gap framework even though the aforementioned problem is not even
speciﬁc to hybrid frameworks. Additionally, the solution is not ﬁne-
grained since a whitelisted origin get access to all resources of the
app. In [3], the authors propose ﬁne-grained access control system
for hybrid apps, which allows developers to add origin permissions
to the manifest ﬁle and associate iframes with permissions, and en-
forces the developer rules in the operating system. One drawback
of this solution is that the web developer has to be compliant and
include the permission tag along with the desired permissions in
the iframes; otherwise, the frame just governs all the permissions
the main page is given to. Furthermore, even though this solution
provides a more ﬁne-grained access control than NoFrak, it focuses
on only protecting permission-protected resources, and hence is not
enough to fully protect the app and its user as we have previously
shown. Moreover, neither of these solutions give developers the
ﬂexibility to consult with the user on how to handle requests. In
[28], the authors present code injection attacks on hybrid apps. Even
though they mainly target hybrid frameworks, the attack shown can
be applied to all mobile web applications in general.
Fixing Web-based system apps. Georgiev et al. show that Web-
based system applications also suffer from similar problems, and
introduce POWERGATE, which provides access control on native
objects in the system by enforcing the policy rules created by the
developer [29]. Here, their focus is on native-access APIs provided
to the application by the platform, and not on the resources exposed
by the use of JavaScript bridges.
7. CONCLUSION AND FUTURE WORK
In this work, we investigate the understudied JavaScript bridge
vulnerabilities for native mobile web applications that use embed-
ded web browsers (WebView) to show content. We show cases
where highly-downloaded vulnerable Android apps inadvertently
expose their internal resources to untrusted web code. By investi-
gating the use of WebView APIs by app developers, we identify
the need for a uniﬁed and ﬁne-grained access control mechanism
on WebView. Hence, we propose Draco, a uniﬁed access control
framework that allows developers to declare access rules for the
exposed resources with ﬁne granularity and enforces these access
policies at runtime. Draco’s declarative policy language can be used
by app developers to create policy rules that specify their trusted or
semi-trusted origins with capabilities deﬁning their access coverage
on the three access channels (JavaScript inteface, event handlers,
HTML5). Draco Runtime System then enforces these policy rules
in an effective and efﬁcient manner. This approach also saves de-
velopers from implementing burdensome programming measures
(i.e., navigation control, multiple WebViews with different levels of
exposure) in an attempt to prevent exposed resources from web do-
mains. Draco is easily deployable since it does not require Android
OS modiﬁcations, but only enhancements in the Android System
WebView app. In future work, we plan to investiage the use of server
credentials for authorization, and explore efﬁcient infrastructures
for credential management, credential distribution and revocation.
Acknowledgments. This work was supported in part by NSF CNS
12-23967, 14-08944, and 15-13939. The views expressed are those
of the authors only.
8. REFERENCES
[1] P. Mutchler, A. Doupé, Kruegel C. Mitchell, J., and G. Vigna. A
large-scale study of mobile web app security. In MoST, 2015.
[2] M. Georgiev, S. Jana, and V. Shmatikov. Breaking and ﬁxing
origin-based access control in hybrid web/mobile application
frameworks. In NDSS, 2014.
[3] X. Jin, L. Wang, T. Luo, and W. Du. Fine-grained access control for
html5-based mobile applications in android. In Information Security.
2015.
[4] Webkit: Open source web browser engine. https://webkit.org/.
[5] The chromium project. https://chromium.org/.
[6] Android open source project. https://source.android.com/.
[7] T. Luo, H. Hao, W. Du, Y. Wang, and H. Yin. Attacks on webview in
the android system. In ACSAC. ACM, 2011.
[8] E. Chin and D. Wagner. Bifocals: Analyzing webview vulnerabilities
in android applications. In Information Security Applications. 2013.
[9] M. Neugschwandtner, M. Lindorfer, and C. Platzer. A view to a kill:
Webview exploitation. In LEET, 2013.
[10] D. Thomas, A. Beresford, T.s Coudray, T. Sutcliffe, and A. Taylor. The
lifetime of android api vulnerabilities: case study on the
javascript-to-java interface. In Security Protocols XXIII. 2015.
[11] Dex2jar. https://github.com/pxb1988/dex2jar.
[12] Jd-gui. http://jd.benow.ca/.
[13] Apktool decompiler. http://ibotpeaches.github.io/Apktool/.
[14] D. McCracken and E. Reilly. Backus-naur form (bnf). In Encyclopedia
of Computer Science.
[15] Eddystone ble beacons. http://bit.ly/1WMaylQ.
[16] Bluetooth low energy. http://bit.ly/1Rw9grs.
[17] 15 companies using beacon technology. http://bit.ly/16qwASy.
[18] The apktool’s failed app list. http://bit.ly/2aUyE9T.
[19] K. Au, Y. Zhou, Z. Huang, and D. Lie. Pscout: analyzing the android
permission speciﬁcation. In CCS, 2012.
[20] Dexdump. http://bit.ly/1NBg7QM.
[21] Cold start times: Analysis of top apps. http://bit.ly/1TFTtb0.
[22] Key takeaways for mobile apps. http://pewrsr.ch/1M4LqyY.
[23] S. Shekhar, M. Dietz, and D. Wallach. Adsplit: Separating smartphone
advertising from applications. In USENIX, 2012.
[24] R. Wang and X.and Chen S. Xing, L.and Wang. Unauthorized origin
crossing on mobile platforms: Threats and mitigation. In CCS, 2013.
[25] J. Seo, D Kim, D Cho, T. Kim, and I. Shin. Flexdroid: Enforcing
in-app privilege separation in android. 2016.
[26] S. Zhu, L. Lu, and K. Singh. Case: Comprehensive application
security enforcement on cots mobile devices. In MobiSys, 2016.
[27] Y. Jing and T. Yamauchi. Access control to prevent malicious
javascript code exploiting vulnerabilities of webview in android os.
IEICE TRANSACTIONS on Information and Systems, 2015.
[28] X. Jin, X. Hu, K. Ying, W. Du, H. Yin, and G. Peri. Code injection
attacks on html5-based mobile apps: Characterization, detection and
mitigation. In CCS, 2014.
[29] M. Georgiev, S. Jana, and V. Shmatikov. Rethinking security of
web-based system applications. In WWW, 2015.