uses this group when running unprivileged helper pro-
cesses for printing, noti(cid:2)cation, and more. If an un-
privileged process is corrupted, an attacker could re-
place the state (cid:2)les by hard or symbolic links and de-
stroy or corrupt a sensitive (cid:2)le.
(cid:15) On Fedora Core 11, a similar latent problem exists
with (cid:2)les under directory /var/log/cups.
(cid:15) During MySQL startup,
the mysqld daemon
opens a (cid:2)le hostname.lower-test with (cid:3)ags
O RDWR|O CREAT as root,
directory
/var/lib/mysql which is owned by the mysql
user. If the mysqld daemon is corrupted later when
it runs with user mysql privileges, an attacker could
replace this (cid:2)le by a hard or symbolic link and corrupt
a sensitive (cid:2)le when MySQL is restarted.
under
(cid:15) The Hardware Abstraction Layer daemon subsystem
opens a (cid:2)le with (cid:3)ags O RDWR|O CREAT as root, in
directory /var/run/hald. This directory is owned
by user haldaemon, who also owns several daemon
processes. Some of these processes listen on a socket
that is accessible to local users.
(cid:15) The Tomcat subsystem opens a (cid:2)le with (cid:3)ags
O WRONLY|O APPEND|O CREAT as root in direc-
tory /var/cache/tomcat6.
This directory is
owned by user tomcat6, who also owns a process
that provides service to remote network clients.
(cid:15) On Fedora Core 11, directory /var/lock is writable
by group lock, which is also the group of a setgid
program /usr/sbin/lockdev.
System start-
up scripts create (cid:147)lock(cid:148) (cid:2)les as root with (cid:3)ags
O WRONLY|O NONBLOCK|O CREAT|O NOCTTY.
If the lockdev program has a vulnerability, an
attacker could replace a lock (cid:2)le by a hard or symbolic
link and corrupt a sensitive (cid:2)le.
(cid:15) XAMPP [24] (an integrated package of Apache,
MySQL, PHP and other components) on Linux opens
(cid:2)les, for error logging, as root in the directory
/opt/lampp/var/mysql which is owned by the
uid nobody. A corrupted process running as nobody
can replace this with a link to any (cid:2)le on the sys-
tem which would then be overwritten. We note that
XAMPP runs a number of daemons providing network
services as the nobody user, including httpd.
In all these cases, our safe name resolution would protect
the system from privilege escalation if the unprivileged pro-
cesses are corrupted.
5.4. Policy violations
During our (cid:148)whole system(cid:148) tests we ran into a surpris-
ingly small number of actual safety policy violations. These
turned out to be speci(cid:2)c to particular platforms, and were
caused by quirks in the way that directory ownership and
permissions were set up:
(cid:15) On FreeBSD 7.2, the man command could trigger pol-
icy violations when a user requested a manual page.
FreeBSD stores pre-formatted manual pages under di-
rectories owned by user man (instead of root as with
many other UNIX systems). According to our policy,
these directories are unsafe for users other than man.
This resulted in policy violations with pre-formatted
manual page (cid:2)les that had multiple hard links.
FreeBSD adopted this approach so that pre-formatted
manual pages can be maintained by a non-root pro-
cess. This limits the impact of vulnerabilities in
document-formatting software. However, we (cid:2)nd
the bene(cid:2)ts of this approach dubious: document-
formatting software still runs with root privileges
when the super-user requests a manual page for soft-
ware that is not part of the base system. By default,
no pre-formatted manual pages exist for this software
category, and this is where the biggest risk would be.
(cid:15) The FreeBSD package manager triggered warnings
about following ‘..’ when removing a temporary
directory tree under /var/tmp; these could be ad-
dressed by a more permissive policy (cf. Section 6.1).
(cid:15) On Fedora Core 11, the Gnome desktop software trig-
gered policy violations that we did not experience with
other systems. The violations happened when a pro-
cess with gdm user and group privileges attempted
to follow symbolic links under directory /var/lib/gdm.
This directory is writable by both owner gdm and
group gdm.
These policy violations can be avoided with a more
sane con(cid:2)guration that uses owner gdm write permis-
sion only. Our (cid:147)live(cid:148) measurements show that group
gdm is used only by processes that run as user gdm.
With a single-member group like gdm, owner gdm per-
mission is suf(cid:2)cient, and group gdm write permission
is unnecessary. (We found similar issues with XAMPP
for Linux, which installs with directories that have
owner nobody and group root with group write per-
mission.)
5.5. A web›server application
Most of our measurements were done on bare-bones sys-
tems that we instantiated speci(cid:2)cally for the purpose of run-
ning the experiments. The only production system that we
had access to was a Debian 5.0 system running an Apache
web server and some other services. On that system we
did not attempt a whole-system measurement, but instead
only run speci(cid:2)c services under our measurement appara-
tus. Also on that system most services did not report any
policy violations, with the notable exception of the web
server.
The web site on that system is managed cooperatively by
several users, where different users are responsible for dif-
ferent parts of the site, and with no attempt for any protec-
tion between these users. As a result, the web-tree is a mesh
of directories with different owners, many of them writable
by the web-administrator group (whose members in-
clude all these different users). Roughly speaking, the entire
web-tree on that system is an UNsafe subtree. Moreover,
some dynamic-content parts of the web site make heavy use
of symbolic links, e.g., for using the same script in different
contexts.
It is clear that our safe-open procedure will break this
web site, but this is more an artifact of our particular choice
of implementation than of the security guarantee that we set
out to ensure. Indeed, in Section 6.1 we describe a more per-
missive implementation of safe-open that still ensures
the same security guarantee, but would not break this web
site. (The idea is that we can follow symbolic links off un-
safe directories, as long as we ensure that the (cid:2)le that we
get to at the end does not have any safe names.)
5.6. Conclusions
Our experiments seem to indicate that our approach to
safe name resolution is both effective and realistic. On
one hand, it (cid:2)xes all 177 symlink-related vulnerabilities re-
ported in CVE since January 2008, and also provides pro-
tection against the (latent) vulnerabilities that we identi(cid:2)ed
in our experiments. On the other hand, most systems will
continue working without a problem even if this safety mea-
sure was implemented. The few that break can be (cid:147)(cid:2)xed(cid:148)
either by implementing a more standard permission struc-
ture for the relevant directories or by implementing the more
permissive variant of safe-open from Section 6.1.
We stress that in our experiments, we did not identify
even a single example where there is a legitimate need to
open (cid:2)les that would be inherently disallowed by our ap-
proach to safe name resolution.
6. Variations and Extensions
6.1. A more permissive safe-open
Our safe-open procedure does not follow symbolic
links off an unsafe directory, but is not hard to see that this
policy is more restrictive than what we really need for our
security guarantee.
Indeed, we only need to ensure that
safe-open fails on an unsafe name if the (cid:2)le to be opened
has any other name that is safe. It turns out that a small
modi(cid:2)cation of safe-open can ensure the same security
guarantee while allowing more names to be opened.
The idea is to keep two safe/unsafe (cid:3)ags rather than one.
Both (cid:3)ags begin in a safe state and switch to unsafe state
when visiting an unsafe directory, but one (cid:3)ag is (cid:147)sticky(cid:148),
in that once in unsafe state it stays in this state until the end
of the name resolution, while the other is reset to the safe
state whenever we are about to follow a symbolic link with
an absolute path. That is, the second (cid:3)ag is reset to safe
state whenever we are about to return to the root directory.
With these two (cid:3)ags, we can follow arbitrary symbolic
links, and can also follow ‘..’ as long as the second (cid:3)ag is
in safe mode. When we (cid:2)nally reach the (cid:2)le to be opened,
we abort the procedure only if (a) the (cid:147)sticky(cid:148) (cid:3)ag is in
unsafe mode and the (cid:2)le has more than one hard link, or (b)
the two (cid:3)ags have different values. (In the second case, the
(cid:147)sticky(cid:148) (cid:3)ag indicates that the given pathname was unsafe,
while the resettable (cid:3)ag indicates that as part of the name
resolution we followed some safe name to arrive at the (cid:2)le.)
The reason that this more permissive procedure works, is
that if a (cid:2)le with only one hard link has any safe names,
then its (cid:147)canonical(cid:148) name (i.e., the one with no symbolic
links) must be safe. Moreover, this name must be the one
followed by the time that the name-resolution arrives at the
(cid:2)le itself.
As we described it, this more permissive version still re-
fuses to follow ‘..’ when the second (cid:3)ag is in unsafe mode.
This can be easily remedied, however: we simply drop the
restriction on following ‘..’, and instead just reset the sec-
ond (cid:3)ag to safe mode after every ‘..’.
6.2. An alternative safe-open using extended at›
tributes
On some systems, a much more direct approach is
also possible. Recall that the problem that we try to ad-
dress is that an adversary without permissions to a (cid:2)le is
able to add names to the (cid:2)lesystem that resolve to that
(cid:2)le.
If the (cid:2)lesystem supports extended attributes, then
we can avoid this problem simply by including with the
(cid:2)le an attribute that lists all the permissible names for that
(cid:2)le. The open procedure, after opening the (cid:2)le, will
look for this extended attribute, and if found it will com-
pare its pathname argument against the list of permissible
names, and will abort if there is a mismatch. For example,
the (cid:2)le sudo in /etc/init.d/ will have a permitted-
names attribute listing the names /etc/init.d/sudo
and /etc/rcS.d/S75sudo, and no program will ever
be able to open it using any other name.
This simple solution looks quite attractive, but it neces-
sitates proper management of the additional attribute.
In
particular, we must decide who may set this attribute (and
under what conditions). For example, when we add to our
(cid:2)lesystem a symbolic link:
/var/spool/mail -> /var/mail
do we need to modify the permitted-name attribute in all the
(cid:2)les under /var/mail/? We leave all these questions to
future work.
6.3. Group permissions
Recall that our safe-open procedure only uses uids
to determine safety of directories, which means in particular
that we treat two processes with the same uid as equal and
do not try to protect one from the other. This leaves open the
possibility of privilege escalation by acquiring group priv-
ileges: namely, an adversarial process may try to trick an-
other process with the same effective uid but more group
privileges into opening a (cid:2)le that the adversarial process it-
self cannot open.
In the work we do not try to protect against such at-
tacks, indeed protection between different processes with
the same effective uid is virtually impossible in most
POSIX systems. We mention that it is not hard to change the
safe-open procedure itself so that it considers the gid
rather than the uid for the purpose of determining direc-
tory safety, but this would require a change in the interface,
since the calling application would need to somehow indi-
cate that it wants to use this gid-based safety check instead
of the default uid-based check.
We note that our approach for safe name resolution is
quite coarse with respect to group permissions, in that group
write permissions always make a directory unsafe for ev-
eryone. This is justi(cid:2)ed when the directory gid is the pri-
mary or secondary gid of multiple UNIX accounts, since
multiple accounts are manipulators. However, contempo-
rary UNIX-es have many gids that are associated with only
one uid (or maybe none at all, e.g. when the gid is only
used by the execution of a setgid program). In general we
cannot anticipate all possible ways that a gid may be ac-
tivated, and hence we consider the directory unsafe in all
these cases. This may trigger spurious policy violations in
some con(cid:2)gurations, but in our experiments we did not (cid:2)nd
con(cid:2)gurations where such policy violations cannot be re-
solved.
We also note that in conjunction with the more permis-
sive variant from above, this behavior lets administrators
bypass much of our safety mechanisms: To forgo most of
our safety protections for some subtree (without otherwise
changing any permissions), it is suf(cid:2)cient to make the root
of that subtree writable, e.g., by the root group. Assum-
ing that only root is a member of this group, this will not
change any real permissions in the system, but will make
that entire subtree unsafe, and therefore permit opening of
the (cid:2)les in it also using other unsafe names, even ones with
symbolic links. (This trick does not help if there are multi-
ple hardlinks, however.)
7. Conclusion
In this paper we considered the problem of privilege es-
calation via manipulation of (cid:2)lesystem pathnames, which
effect name resolution in system calls such as open,
unlink, etc. While many privileged programs take mea-
sures to protect against such attacks, these measures are al-
ways very application speci(cid:2)c. We propose a more general
approach of having safe pathname resolution as part of the
(cid:2)lesystem itself or a system library, thereby protecting all
applications by default.
We introduced the concept of the manipulators of a path-
name, that include anyone who can in(cid:3)uence the outcome
of the pathname resolution. In POSIX these are the users
who either own or can write in any directory visited dur-
ing the pathname resolution. Using this concept, we call a
pathname safe for U if the only manipulators of the path-
name are root and U. We described a general routine
safe-open, ensuring that if a (cid:2)le has safe names then
safe-open will not open that (cid:2)le with an unsafe name,
and demonstrated that this guarantee can be used to thwart
(cid:2)lename-based privilege escalation attacks. This is useful
not only for privileged programs that run in known-to-be
hostile environments, but also for programs written by naive
developers, and programs that are being deployed in unfore-
seen environments with unexpected (cid:2)le permission seman-
tics.
We implemented our safe name resolution routine in a
library, using portable code over the POSIX interface, and
performed extensive experiments to validate the applicabil-
ity of our solution to current operating systems and appli-
cations. We veri(cid:2)ed that this solution uniformly protects
system against the documented cases of applications and
daemons vulnerable to pathname manipulation attacks, as
well as against some new (latent) vulnerabilities that we un-
covered. We also instrumented current versions of Ubuntu
9.04, Fedora Core 11 and FreeBSD 7.2 to run every process
through a program which interposes calls to (cid:2)le manipula-
tion and related calls and checks if the corresponding oper-
ation manipulates a safe pathname. These experiments con-
(cid:2)rmed that very few existing systems break when used over
our safe name resolution, and the handful of cases where
our solution produces false positives can be handled either
by implementing a more standard permission structure for
the relevant directories or by using a more permissive vari-
ant of our solution.
References
[1] M. Bishop. Race Conditions, Files, and Security Flaws; or
the Tortoise and the Hare Redux. Technical Report CSE-95-
8, University of California at Davis, Sep 1995.
[2] M. Bishop and M. Dilger. Checking for race conditions in
(cid:2)le accesses. Computing Systems 9(2), pp. 131(cid:150)152, Spring
1996.
[3] N. Borisov, R. Johnson, N. Sastry, and D. Wagner. Fix-
In 14th
ing races for fun and pro(cid:2)t: how to abuse atime.
USENIX Security Symposium, pp. 303(cid:150)314, Jul 2005.
[4] X. Cai, Y. Gui, R. Johnson. Exploiting Unix File-System
Races via Algorithmic Complexity Attacks In IEEE Sym-
posium on Security and Privacy, Oakland, California May
2009.
[5] R. Canetti. Universally Composable Security: A New
In FOCS, pages
Paradigm for Cryptographic Protocols.
136(cid:150)145, 2001.
[6] R. Canetti, S. Chari, S. Halevi, B. P(cid:2)tzmann, A. Roy, M.
Steiner, W. Venema. Composable Security Analysis of Op-
erating System Services. Technical Report RC24900, IBM