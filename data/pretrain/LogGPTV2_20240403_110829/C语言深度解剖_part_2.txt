6.4.2 不使用任何变量编写strlen 函数 ....................... - 110 -
第七章 文件结构 .................................................. - 112 -
7.1 文件内容的一般规则 ........................................ - 112 -
7.2 文件名命名的规则 .......................................... - 116 -
- 6 -
前 言
我遇到过很多程序员和计算机系毕业的学生，也给很多程序员和计算机系毕业的学生讲
解过《高级C 语言程序设计》。每期班开课前，我总会问学生：你感觉C 语言学得怎么样？
难吗？指针明白吗？数组呢？内存管理呢？往往学生回答说：感觉还可以，C 语言不难，指
针很明白，数组很简单，内存管理也不难。一般我会再问一个问题：通过这个班的学习，你
想达到什么程度？很多学生回答：精通C 语言。我告诉他们：我很无奈，也很无语。因为我
完全在和一群业余者或者是C 语言爱好者在对话。你们大学的计算机教育根本就是在浪费你
们的时间，念了几年大学，连C 语言的门都没摸着。现在大多数学校计算机系都开了C、C++、
Java、C#等等语言，好像什么都学了，但是什么都不会，更可悲的是有些大学居然取消了C
语言课程，认为其过时了。我个人的观点是‚十鸟在林，不如一鸟在手‛，真正把C 语言整
明白了再学别的语言也很简单，如果C 语言都没整明白，别的语言学得再好也是花架子，因
为你并不了解底层是怎么回事。当然我也从来不认为一个没学过汇编的人能真正掌握C 语言
的真谛。
我个人一直认为，普通人用C 语言在3 年之下，一般来说，还没掌握C 语言；5 年之
下，一般来说还没熟悉C 语言；10 年之下，谈不上精通。所以，我告诉我的学生：听完我
的课，远达不到精通的目标，熟悉也达不到，掌握也达不到。那能达到什么目标？-----领
你们进入C 语言的大门。入门之后的造化如何在于你们自己。不过我可以告诉你们一条不是
捷径的捷径：把一个键盘的F10 或F11 按坏，当然不能是垃圾键盘。往往讲到这里，学生
眼里总是透露着疑虑。C 语言有这么难吗？我的回答是：不难。但你就是用不明白。学生说：
以前大学老师讲C 语言，我学得很好。老师讲的都能听懂，考试也很好。平时练习感觉自己
还不错，工作也很轻松找到了。我告诉学生：听明白，看明白不代表你懂了，你懂了不代表
你会用了，你会用了不代表你能用明白，你能用明白不代表你真正懂了！什么时候表明你真
正懂了呢？你站在我这来，把问题给下面的同学讲明白，学生都听明白了，说明你真正懂了。
否则，你就没真正懂，这是检验懂没懂的唯一标准。冰山大家都没见过，但总听过或是电影
里看过吧？如果你连《泰坦尼克》都没看过，那你也算个人物（开个玩笑）。《泰坦尼克》
里的冰山给泰坦尼克造成了巨大的损失。你们都是理工科的，应该明白冰山在水面上的部分
只是总个冰山的1/8。我现在就告诉你们，C 语言就是这座冰山。你们现在仅仅是摸到了水
面上的部分，甚至根本不知道水面下的部分。我希望通过我的讲解，让你们摸到水面下的部
分，让你们知道C 语言到底是什么样子。
从现在开始，除非在特殊情况下，不允许用printf 这个函数。为什么呢？很多学生写
完代码，直接用printf 打印出来，发现结果不对。然后就举手问我:老师，我的结果为什
么不对啊？连调试的意识都没有！大多数学生根本就不会调试，不会看变量的值，内存的值。
只知道printf 出来结果不对，却不知道为什么不对，怎么解决。这种情况还算好的。往往
很多时候printf 出来的结果是对的，然后呢，学生也理所当然的认为程序没有问题。是这
样吗？往往不是，往后看，你能看到例子的。永远给我记住一点：结果对，并不代表程序真
正没有问题。所以，以后尽量不要用printf 函数，要去看变量的值，内存的值。当然，在
我们目前的编译器里，变量的值，内存的值对了就代表你程序没问题吗？也不是，往后，你
也会看到例子的。
这个时候呢，学生往往会莫名其妙。这个老师有问题吧。大学里我们老师都教我们怎么
用printf，告诉我们要经常用printf。这也恰恰是大学教育失败的地方之一。很多大学老
师根本就没真正用C 语言写过几行代码，更别说教学生调试代码了。不调试代码，不按F10
- 7 -
或F11，水平永远也无法提上来，所以，要想学好一门编程语言，最好的办法就是多调试。
你去一个软件公司转转，去看人家的键盘，如果发现键盘上的F10 或F11 铮亮铮亮，毫无
疑问，此机的主人曾经或现在是开发人员（这里仅指写代码的，不上升到架构设计类的开发
人员），否则，必是非开发人员。非常有必要申明，本人并非什么学者或是专家，但本人是
数学系毕业，所以对理论方面比较擅长。讲解的时候会举很多例子来尽量使学生明白这个知
识点，至于这些例子是否恰当则是见仁见智的问题了。但是一条，长期的数学训练使得本人
思维比较严谨，讲解一些知识点尤其是一些概念性原理性的东西时会抠的很细、很严，这一
点相信读者会体会得到的。本书是我平时讲解C 语言的一些心得和经验，其中有很多我个人
的见解或看法。经过多期培训班的实践，发现这样讲解得比较透彻，学生听得明白。很多学
生听完课后告诉我：我有生以来听课从来都没有听得这么透彻，这么明白过。也有业余班的
学生甚至辞掉本职工作来听我的课的。
当然，关于C 语言的这么多经验和心得的积累并非我一人之力。借用一句名言：我只不
过是站在巨人的肩膀上而已。给学生做培训的时候我参考得比较多的书有：Kernighan
&Ritchie 的《The C Programming Language》；Linden 的《Expert C Programming》；
Andrew&oening《C Traps and Pitfalls》； Steve Maguire 的《Write Clean Code》；
Steve McConnell 的《Code Complete. Second Edition》；林锐的《高质量C++/C 编
程指南》。这些书都是经典之作，但却都有着各自的缺陷。读者往往需要同时阅读这些书才
能深刻的掌握某一知识点。
我的讲课的试图时候融各家之长，再加上我个人的见解传授给学生。还好，学生反映还
可以，至少还没有出乱子。这些书饱含着作者的智慧，每读一遍都有不同的收获，我希望读
者能读上十遍。另外，在编写本书时也参考了网上一些无名高手的文章，这些高手的文章见
解深刻，使我受益匪浅。这里要感谢这些大师们，如果不是他们，恐怕我的C 语言的水平也
仅仅是入门而已。学习C 语言，这几本书如果真正啃透了，水平不会差到哪。与其说本书是
我授课的经验与心得，不如说本书是我对这些大师们智慧的解读。本书并不是从头到尾讲解
C 语言的基础知识，所以，本书并不适用于C 语言零基础的人。本书的知识要比一般的C 语
言书说讲的深的多，其中有很多问题是各大公司的面试或笔试题。所以本书的读者应该是中
国广大的计算机系的学生和初级程序员。如果本书上面的问题能真正明白80%，作为一个应
届毕业生，恐怕没有一家大公司会拒绝你。当然，书内很多知识也值得计算机教师或是中高
级程序员参考。尤其书内的一些例子或比方，如果能被广大教师用于课堂，我想对学生来说
是件非常好的事情。有人说电影是一门遗憾的艺术，因为在编辑完成之后总能或多或少的发
现一些本来可以做得更好的缺陷。讲课同样也如此，每次讲完课之后总能发现自己某些地方
或是没有讲到，或是没能讲透彻或是忘了举一个轻浅的例子等等。整理本书的过程也是，为
了尽量精炼，总是犹豫一些东西的去留。限于作者水平，书中难免有些遗漏甚至错误，希望
各位读者能予指教。作者Mail:dissection_c@163.com.
陈正冲
2008 年6 月23 日
- 8 -
第一章 关键字
每次讲关键字之前，我总是问学生：C 语言有多少个关键字？sizeof 怎么用？它是函
数吗？有些学生不知道C 语言有多少个关键字，大多数学生往往告诉我sizeof 是函数，因
为它后面跟着一对括号。当投影仪把这32 个关键字投到幕布上时，很多学生表情惊讶。有
些关键字从来没见过，有的惊讶C 语言关键字竟有32 个之多。更有甚者，说大学老师告诉
他们sizeof 是函数，没想到它居然是关键字！由此可想而知，大学的计算机教育是多么失
败！
表(1.1)C 语言标准定义的32 个关键字
关键字意义
auto 声明自动变量，缺省时编译器一般默认为auto
int 声明整型变量
double 声明双精度变量
long 声明长整型变量
char 声明字符型变量
float 声明浮点型变量
short 声明短整型变量
signed 声明有符号类型变量
unsigned 声明无符号类型变量
struct 声明结构体变量
union 声明联合数据类型
enum 声明枚举类型
static 声明静态变量
switch 用于开关语句
case 开关语句分支
default 开关语句中的‚其他‛分支
break 跳出当前循环
register 声明寄存器变量
const 声明只读变量
volatile 说明变量在程序执行中可被隐含地改变
typedef 用以给数据类型取别名(当然还有其他作用)
下面的篇幅就一一讲解这些关键字。但在讲解之前先明确两个概念：什么是定义？什么
是声明？它们有何区别?
举个例子：
A)int i；
B)extern int i；(关于extern，后面解释)
哪个是定义？哪个是声明？或者都是定义或者都是声明？我所教过的学生几乎没有一
人能回答上这个问题。这个十分重要的概念在大学里从来没有被提起过！
什么是定义：所谓的定义就是(编译器)创建一个对象，为这个对象分配一块内存并给
它取上一个名字，这个名字就是我们经常所说的变量名或对象名。但注意，这个名字一旦和
这块内存匹配起来(可以想象是这个名字嫁给了这块空间，没有要彩礼啊。^_^)，它们就同
生共死，终生不离不弃。并且这块内存的位置也不能被改变。一个变量或对象在一定的区域
- 9 -
内（比如函数内，全局等）只能被定义一次，如果定义多次，编译器会提示你重复定义同一
个变量或对象。
什么是声明：有两重含义，如下：
第一重含义：告诉编译器，这个名字已经匹配到一块内存上了(伊人已嫁，吾将何去何
从？何以解忧，唯有稀粥)，下面的代码用到变量或对象是在别的地方定义的。声明可以出
现多次。
第二重含义：告诉编译器，我这个名字我先预定了，别的地方再也不能用它来作为变量
名或对象名。比如你在图书馆自习室的某个座位上放了一本书，表明这个座位已经有人预订，
别人再也不允许使用这个座位。其实这个时候你本人并没有坐在这个座位上。这种声明最典
型的例子就是函数参数的声明，例如：
void fun(int i, char c);
这样一解释，我们可以很清楚的判断:A)是定义；B)是声明。那他们的区别也很清晰了。
记住，定义声明最重要的区别：定义创建了对象并为这个extern 声明变量是在其他文件正
声明(也可以看做是引用变量)
return 子程序返回语句(可以带参数，也可不带参数)
void 声明函数无返回值或无参数，声明空类型指针
continue 结束当前循环，开始下一轮循环
do 循环语句的循环体
while 循环语句的循环条件
if 条件语句
else 条件语句否定分支(与if 连用)
for 一种循环语句(可意会不可言传)
goto 无条件跳转语句
sizeof 计算对象所占内存空间大小
对象分配了内存，声明没有分配内存(一个抱伊人，一个喝稀粥。^_^)。
1.1 最宽恒大量的关键字----auto
auto：它很宽恒大量的，你就当它不存在吧。编译器在默认的缺省情况下，所有变量
都是auto 的。
1.2 最快的关键字---- register
register：这个关键字请求编译器尽可能的将变量存在CPU 内部寄存器中而不是通过
内存寻址访问以提高效率。注意是尽可能，不是绝对。你想想，一个CPU 的寄存器也就那
么几个或几十个，你要是定义了很多很多register 变量，它累死也可能不能全部把这些变
量放入寄存器吧，轮也可能轮不到你。
1.2.1 皇帝身边的小太监----寄存器
不知道什么是寄存器？那见过太监没有？没有？其实我也没有。没见过不要紧，见过就
麻烦大了。^_^，大家都看过古装戏，那些皇帝们要阅读奏章的时候，大臣总是先将奏章交
- 10 -
给皇帝旁边的小太监，小太监呢再交给皇帝同志处理。这个小太监只是个中转站，并无别的
功能。好，那我们再联想到我们的CPU。CPU 不就是我们的皇帝同志么？大臣就相当于我们
的内存，数据从他这拿出来。那小太监就是我们的寄存器了（这里先不考虑 CPU 的高速缓
存区）。数据从内存里拿出来先放到寄存器，然后CPU 再从寄存器里读取数据来处理，处理
完后同样把数据通过寄存器存放到内存里，CPU 不直接和内存打交道。这里要说明的一点
是:小太监是主动的从大臣手里接过奏章，然后主动的交给皇帝同志，但寄存器没这么自觉，
它从不主动干什么事。一个皇帝可能有好些小太监，那么一个 CPU 也可以有很多寄存器，
不同型号的CPU 拥有寄存器的数量不一样。
为啥要这么麻烦啊？速度！就是因为速度。寄存器其实就是一块一块小的存储空间，只
不过其存取速度要比内存快得多。进水楼台先得月嘛，它离CPU 很近，CPU 一伸手就拿到
数据了，比在那么大的一块内存里去寻找某个地址上的数据是不是快多了？那有人问既然它
速度那么快，那我们的内存硬盘都改成寄存器得了呗。我要说的是：你真有钱！
1.2.2 使用 register 修饰符的注意点
虽然寄存器的速度非常快，但是使用register 修饰符也有些限制的：register 变量
必须是能被CPU 寄存器所接受的类型。意味着register 变量必须是一个单个的值，并且其
长度应小于或等于整型的长度。而且register 变量可能不存放在内存中，所以不能用取址
运算符“&”来获取register 变量的地址。
1.3 最名丌符实的关键字----static
不要误以为关键字static 很安静，其实它一点也不安静。这个关键字在C 语言里主要
有两个作用，C++对它进行了扩展。
1.3.1 修饰变量
第一个作用：修饰变量。变量又分为局部和全局变量，但它们都存在内存的静态区。静
态全局变量，作用域仅限于变量被定义的文件中，其他文件即使用extern 声明也没法使用
他。准确地说作用域是从定义之处开始，到文件结尾处结束，在定义之处前面的那些代码也
不能使用它。想要使用就得在前面再加extern ***。恶心吧？要想不恶心，很简单，直接
在文件顶端定义不就得了。
静态局部变量，在函数体里面定义的，就只能在这个函数里用了，同一个文档中的其他
函数也用不了。由于被static 修饰的变量总是存在内存的静态区，所以即使这个函数运行
结束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值。
static int j;
void fun1（void）
{