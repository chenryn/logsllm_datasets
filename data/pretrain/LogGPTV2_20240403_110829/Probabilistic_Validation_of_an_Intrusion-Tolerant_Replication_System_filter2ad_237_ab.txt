### Initialization and Management of Replicas in the Model

For most studies, the initial setup is sufficient. The next step in model initialization involves starting replicas on hosts. A bit vector, shared across all Replica and Host submodels, indicates the applications for which replicas need to be started by the Host submodels. 

The high-rate activity "start replica" triggers once for each Replica submodel, setting the bit corresponding to the application identifier (app id) in the `replica to start sys` vector. When a host starts some replicas, it updates a globally shared bit vector, `replica started`, with 1s for all applications whose replicas were started. For each such application, the `enable rep` activities are enabled in all relevant Replica submodels, with each activity having an equal chance of firing first.

When an `enable rep` activity fires, it:
1. Increments the `replicas running` marking, which tracks the number of currently active replicas for the application.
2. Sets the `has started` marking, local to the replica, to indicate that the replica is active.
3. Removes the application's bit from `replica started`.

Thus, when a replica of an application is started on a host, one of the Replica submodels associated with the application is randomly chosen to represent the started replica.

### Handling Corrupt Hosts

If a host becomes corrupt, the Host submodel updates a globally shared bit vector, `replicas affected`, with the identifiers of all replicas running on the host. For each affected application, the `prop host corr` activity fires in one of its Replica submodels not already running on a corrupt host. This activity changes the state of the Replica to indicate that its host is corrupt (using the `host corrupt` local place) and resets the bit for this application in `replicas affected`.

### Attack on Replicas

The `attack rep` activity represents a successful attack on a replica. The rate of this activity is higher if the replica is running on a corrupt host, calculated by multiplying the base rate by a constant. For example, a multiplier of 2 implies that a replica running on a compromised host is twice as vulnerable to attacks.

Upon the firing of `attack rep`:
- The `replica attacked` local place is set to 1 to indicate the intrusion.
- The `rep corr undetected` marking, shared across all replicas of the application, is incremented to track the number of yet-undetected corrupt replicas.

The replication group is checked for a Byzantine failure. If the number of undetected corrupt replicas is at least a third of the total number of currently running replicas, the `rep grp failure` marking, shared across all replicas of the application, is set to 1, indicating the unreliability of the application.

### Intrusion Detection and Response

After an intrusion, the `valid ID` activity is enabled, representing two cases: successful detection and failure to detect. Upon successful detection, the `rep corr undetected` marking is decremented, and the `replica detected local` marking is set to 1.

A corrupt replica may exhibit anomalous behavior, detectable by other running replicas if enough of them are correct. This is modeled by the `rep misbehave` activity, which is enabled if the number of running replicas is more than three times the number of undetected corrupt replicas. The `false ID` activity models false alarms generated by the intrusion detection system, enabled whenever the replica has been intruded.

### Propagation and Recovery

Once a replica is marked as corrupted (via valid intrusion detection, false alarm, or detection of misbehavior), the `prop rep detect` activity conveys this information to the host, updating the `rep affected` and `host affected` places. When a host or domain is shut down, all replicas running on it are killed. This information is conveyed through the `replicas killed`, `rep kill reason`, and `reps on corrupt hosts` places.

The `kill replica` activity fires in the appropriate Replica submodels, decrementing the `replicas running` count, resetting local markings, and incrementing the `need recovery` marking to indicate that the management infrastructure must start a new replica for the application.

### Management Algorithm

The Management submodel (Figure 2(c)) models the recovery process by starting new replicas to replace those killed due to domain and host exclusions. The `recovery` activity is enabled if there are replicas to be started (indicated by `need recovery`) and enough good managers in the system. Upon firing, the application's identifier is placed in `replica to start sys`, used by Host SANs to start the replica.

### Host Submodel

The Host submodel (Figure 2(d)) models various activities on a single host, including starting replicas, managing entities, and shutting down the host. The `start manager` and `start replica` activities handle the initiation of managers and replicas, respectively. The `attack host` activity models attacks on the host, with three categories: script-based, exploratory, and innovative, each with decreasing probability.

Intrusion into a host increases the vulnerability of other hosts, especially within the same domain. This is modeled by `propagate domain` and `propagate sys` activities, which increase the attack rates based on the spread effect. The `attack mgmt` activity models attacks on the management entity, increasing in rate if the host is corrupted.

### Intrusion Detection and Exclusion

Activities like `valid ID scp`, `valid ID exp`, and `valid ID inv` represent the detection of different types of attacks, with varying probabilities of successful detection. The `valid ID mgr` activity detects infiltration of the management entity. Upon detection, a response is initiated, and the domain containing the corrupt host is excluded.

False alarms are modeled by the `false ID` activity. When a replica or host is detected as corrupt, the `affect host` and `shut host` activities manage the exclusion and shutdown processes.

### Results and Studies

The MÃ–BIUS tool was used to design the SANs, define intrusion tolerance measures, and conduct studies. Several measures were defined, including unavailability, unreliability, and the number of running replicas. Studies compared the intrusion tolerance for different host distributions and management algorithms.

Parameters used in the studies include:
- Cumulative base attack rate: 3 successful attacks per time unit.
- Cumulative false alarm rate: 2 false alarms per time unit.
- Distribution of attacks on a host: 80% script-based, 15% exploratory, and 5% innovative.

These studies help determine the optimal distribution of hosts and the efficacy of different management strategies.