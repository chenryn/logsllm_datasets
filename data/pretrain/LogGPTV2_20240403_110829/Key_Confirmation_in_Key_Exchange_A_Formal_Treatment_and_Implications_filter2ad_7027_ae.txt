∗
(cid:2)
(cid:2)(cid:2)
(cid:3)
draft-10-nf-m,A(n) = 1
ExpPred
(cid:3)
draft-10-nf-m,A(n) = 1
(cid:2)(cid:2)(cid:2)
ExpPred
(cid:2)
Pr
≤ Pr
+ AdvEUF-CMA
Sig,B2
.
Finally, we can now separately argue along the lines
of the predicates Pred = FullConf(S,C) resp. Pred =
AlmostConf(C,S) as well as Pred = KCIDbind (which is
required as part of almost-full key conﬁrmation):
• For Pred = FullConf(S,C), observe that each accept-
ing server session with a non-corrupted partner obtains,
within the ClientCertificateVerify message, a valid
signature generated by an honest client over the hash of
the transcript ClientHello|| . . .||ClientCertificate,
462462
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:58 UTC from IEEE Xplore.  Restrictions apply. 
which exactly relates to that transcript as no hash colli-
sions occurred. Hence, in particular, for each such server
session that accepts there exists a client session that al-
ready accepted, shares the same transcript, and, therefore,
in particular also holds the same session identiﬁer and
derives the same session key.
• For Pred = AlmostConf(C,S), note that the signature
sent within ServerCertificateVerify is computed
over (the non-colliding hash of) the transcript up to
the ServerCertificate message which, along with
the ServerCertificateVerify message itself forms
the key-conﬁrmation identiﬁer kcid. Therefore, for any
accepting client session (cid:2), there exists an honest server
session (cid:2)(cid:3) sharing the same kcid.
Furthermore, no second honest client will
send a
ClientCertificateVerify message with a signa-
ture over a (hash of a)
transcript containing the
same kcid contents due to unique nonces. Also,
no server obtains a forged signature and no hash
session (cid:2)(cid:3) will
collision occurs. Thus
the server
only accept when receiving this
session’s
client
ClientCertificateVerify message. As the values
signed within ClientCertificateVerify together
with ClientCertificateVerify uniquely determine
the key derivation, session (cid:2)(cid:3) will, if at all, accept with
the same session key.
• For Pred = KCIDbind, the ﬁrst condition that equal ses-
sion identiﬁers imply equal key-conﬁrmation identiﬁers
follows immediately from deﬁning kcid to be a preﬁx of
sid.
The second condition is satisﬁed for the same reasons that
make sessions holding the same kcid in the AlmostConf
predicate derive the same key. Again, kcid contains
the transcript up to the ServerCertificateVerify
message, which is signed by the client within its
ClientCertificateVerify message that no second
honest client will generate (and which can, at this point,
neither be forged nor be derived due to colliding nonces
or hashes). Therefore, if a client accepts (as the ﬁrst
of two sessions sharing the same kcid), it outputs the
only ClientCertificateVerify message server ses-
sion will accept. As ClientCertificateVerify ﬁxes
the complete transcript which fully determines the derived
keys, both sessions will necessarily derive the same key
as required.
FullConf(S,C),
In
other
AlmostConf(C,S),
satisﬁed
always
in ExpPred
(cid:2)
(being
is
(cid:3)
draft-10-nf-m,A(n) = 1
draft-10-nf-m,A(n) and thus
resp. KCIDbind)
ExpPred
words,
Pred
= 0.
Pr
(cid:2)(cid:2)(cid:2)
(cid:2)(cid:2)(cid:2)
Theorem 4.2: The TLS 1.3 draft-10-nf-u handshake for
unilateral authentication without ﬁnished messages satisﬁes
full (C,S)-key conﬁrmation. Formally, for any efﬁcient adver-
463463
sary A against full (C,S)-key conﬁrmation there exist efﬁcient
algorithms B1, B2 such that
(cid:2)
ExpFullConf(C,S)
(cid:3)
draft-10-nf-u,A(n) = 1
Pr
≤ AdvCOLL
+ nu · AdvEUF-CMA
H,B1
Sig,B2
,
where nu is the maximum number of participating parties.
inputs by AdvCOLL
H,B1
Proof: We show that, for unilateral authentication, the
ServerCertificateVerify message obtained by a client
session ensures that the sending server session has already
accepted with the same session key.
Again, we ﬁrst modify the original ExpFullConf(C,S)
draft-10-nf-u,A(n)
experiment
in two steps similar to those in the proof of
Theorem 4.1. First, we identically bound the probability
that
two honest sessions compute a colliding hash value
for an efﬁcient re-
for two different
duction B1. We then ensure that no client session obtains
a ServerCertificateVerify message containing a valid
signature under an honest server’s public key which was
not generated by any honest session (recall that there is no
ClientCertificateVerify message sent as the client does
not authenticate). Similarly to the proof of Theorem 4.1 we
can bound the probability that this happens by the advan-
of an adversary B2, again using its signing
tage AdvEUF-CMA
oracle for the challenged client identity.
Due to these modiﬁcations, we are now assured of uncon-
ditional full (C,S)-key conﬁrmation: the signature sent within
ServerCertificateVerify together with that message itself
fully determines the key derivation and, hence, whenever a
client accepts, the (honest) server session sending sending the
ServerCertificateVerify message already accepted with
the same session identiﬁer and session key.
Sig,B2
B. Key Conﬁrmation with Finished Messages
Coming back to the original TLS 1.3 draft-10 handshake,
it
is easy to see that
the proof in Theorem 4.1 for key
conﬁrmation under mutual authentication in draft-10-nf
immediately carries over to the draft-10 handshake with
mutual authentication (short: draft-10-m). For
re-
call that the ServerFinished and ClientFinished mes-
sage do not
the key derivation, which means
they can essentially be
an “arbitrary bit-
string” attached to the ServerCertificateVerify resp.
ClientCertificateVerify messages. Hence, we can apply
the identical proof to the draft-10 mutually authenticating
handshake to establish the same key conﬁrmation properties.
treated as
enter
this,
Theorem 4.3: The TLS 1.3 draft-10-m handshake for mu-
tual authentication with ﬁnished messages satisﬁes full (S,C)-
key conﬁrmation and almost-full (C,S)-key conﬁrmation. For-
mally, for any efﬁcient adversary A against full (S,C)-key
conﬁrmation resp. almost-full (C,S)-key conﬁrmation there
exist efﬁcient algorithms B1, B2 such that
(cid:2)
(cid:3)
ExpPred
draft-10-m,A(n) = 1
s · 2−|nonce| + AdvCOLL
H,B1
Pr
≤ n2
+ nu · AdvEUF-CMA
Sig,B2
,
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:58 UTC from IEEE Xplore.  Restrictions apply. 
for Pred = FullConf(S,C) resp. Pred = AlmostConf(C,S),
where nu is the maximum number of participating parties, ns
is the maximum number of sessions, and |nonce| = 256 is the
bit-length of the nonces.
Interestingly, when it comes to unilateral authentication,
the ClientFinished messages sent as the single additional
message from the client
to the server changes the order
in which the session key is accepted (the client accepting
ﬁrst here) and, hence, necessarily renders full (C,S)-key
conﬁrmation (as for draft-10-nf-u) unachievable. We can
however show that clients indeed still enjoy almost-full (C,S)-
key conﬁrmation for the unilaterally authenticating draft-10
handshake (draft-10-u).
Theorem 4.4: The TLS 1.3 draft-10-u handshake for uni-
lateral authentication with ﬁnished messages satisﬁes almost-
full (C,S)-key conﬁrmation. Formally, for any efﬁcient adver-
sary A against almost-full (C,S)-key conﬁrmation there exist
efﬁcient algorithms B1, B2 such that
ExpAlmostConf(C,S)
(cid:3)
(cid:2)
Pr
draft-10-u,A
≤ AdvCOLL
H,B1
(n) = 1
+ nu · AdvEUF-CMA
Sig,B2
,
where nu is the maximum number of participating parties.
Proof: We show that the ServerCertificateVerify
message obtained from an honest server ensures this server
agrees on kcid and will, on acceptance, derive the same key.
After excluding hash collisions and signature forgeries
within ServerCertificateVerify again as in the proof
of Theorem 4.2, the (unforged) ServerCertificateVerify
message, computed over (the non-colliding hash of) the tran-
script, ensures the sending server agrees on the same key-
conﬁrmation identiﬁer kcid.
the
kcid
kcid
key10:
Furthermore,
the
derived
value
observe
deter-
uniquely
=
that
mines
ClientHello|| . . .||ServerCertificateVerify
contains
all messages affecting the key derivation as messages
ClientCertificate and ClientCertificateVerify are
not sent and ServerFinished as well as ClientFinished
are not included in the session hashes. Therefore, any two
(accepting) sessions agreeing on the same kcid will derive
the same session key and hence AlmostConf(C,S) as well
KCIDbind are satisﬁed (note that still kcid is a preﬁx of sid).
To summarize, our analysis shows that key conﬁrmation in
the full handshake of the latest draft-10 of TLS 1.3 is already
established through the exchanged CertificateVerify mes-
sages and, hence, the Finished messages included for that
purpose are somewhat redundant. This unveils a potential
misconception that MACs over the transcript (in form of the
Finished messages) are always necessary to achieve key
conﬁrmation.
10This in particular renders requiring unique nonces unnecessary in this
case.
464464
Admittedly, there are however further (non-full) handshake
modes provisioned in draft-10, particularly for key ex-
changes based on a cached server conﬁguration or achieving
zero round-trip time [29, Sections 6.2.2 and 6.2.3]. These
variants do not necessarily exchange CertificateVerify
messages and, hence, rely on the Finished messages to pro-
vide both authentication as well as key conﬁrmation. For the
sake of a uniform protocol design, it therefore seems advisable
to keep Finished messages also in the full handshake, even
though their main purpose, key conﬁrmation, can as well be
achieved through the CertificateVerify messages only.
V. GENERIC TRANSFORM
We next show that the popular transformation of exchanging
MACs over the session identiﬁers at the end of a key exchange
protocol, as for instance advised in [2], [1], actually provides
the strongest form of key conﬁrmation one can expect. Here, a
key-refreshing step should be carried out for generating fresh
MAC keys (one for the client and one for the server) as well
as a separate, new session key via a key derivation function
KDF. In the remainder of the section we assume that the client
always goes last in a protocol Π and the server therefore sends
the ﬁrst MAC in the conclusive transfers.
Below we assume that KDF acts as a secure pseudorandom
generator, i.e., that its output for a random input key key
is indistinguishable from random, and that its output can be
formatted to be used as a session key and MAC keys.
The MAC scheme M = (KGen, MAC, Vf) should be key-
only unforgeable in the sense that the adversary cannot output
a message m∗ with a valid MAC, without even being allowed
to see a MAC for another message. This in particular implies
that for key conﬁrmation, as performed in our transformation
through independent keys for client and for server, it sufﬁces
to output parts of the refreshed key to conﬁrm that one holds
the (refreshed) key part. If both parties use the same key for
message authentication then one needs a one-time unforgeable
MAC scheme, though. We touch this issue at the end of the
section when discussing alternative approaches.
Theorem 5.1: Let KDF be a secure pseudorandom gener-
ator and (KGen, MAC, Vf) be a key-only unforgeable MAC
scheme. If a key exchange protocol Π has Match security
and key secrecy, then the transformation ΠMAC in Figure 4
preserves these properties, and moreover satisﬁes full (S,C)-
key conﬁrmation and almost-full (C,S)-key conﬁrmation. The
protocol ΠMAC also provides the same authentication property
as Π.
Proof: We ﬁrst note that any security property of ΠMAC
deﬁned via the generic experiment in Figure 2 (for one of
our predicates Pred in question), involving some adversary
A, can be perfectly simulated by an adversary A(cid:3) playing
the generic experiment (for Pred) against Π. Adversary A(cid:3)
runs a black-box simulation of A. For this, it always makes
a RevealKey query for any session that accepts (in Π) and
simulates the ﬁnal steps of ΠMAC with the derived key, and
otherwise relays all oracle queries of A in ΠMAC to its oracles.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:58 UTC from IEEE Xplore.  Restrictions apply. 
Client
Server
Protocol Π
output
key key
identiﬁer sid
identiﬁer pid
output
key key
identiﬁer sid