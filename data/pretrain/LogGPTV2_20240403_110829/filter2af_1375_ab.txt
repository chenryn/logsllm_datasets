### 优化后的文本

#### 4.1 利用未初始化Free漏洞

为了利用未初始化Free漏洞，我们需要将`qsg`偏移对应的字段指向堆中一个可控的对象。通过触发该漏洞，我们可以释放一个正在使用的对象，从而导致使用后释放（UAF）漏洞。然而，找到合适的原语并不容易。我们首先需要一个大小为`N*0xa0`的结构体，在其`0x40`偏移处有一个指针，并且该指针必须指向一个用户可控的对象。此外，该对象的分配和使用之间应存在时间窗口，以便在对象被释放后再次使用它。

经过多次尝试，我们未能找到满足这些条件的原语，因为QEMU中的大多数结构不是用户可控的，而且许多设备结构也无法满足要求。例如，NVMe和其他传统设备以及一些复杂设备的结构都不符合需求。

然而，我们在Virtio GPU设备中发现了一个有趣的结构。该设备在`virtio_gpu_create_mapping_iov`函数中分配了一个地址映射表，该表由指针和长度组成。这个结构的大小是可控的，并且包含指针成员，看起来是一个不错的选择。不同的是，这里的指针指向guest空间，是由`dma_memory_map`映射而来的，代表将guest物理内存映射到host的虚拟地址，使得QEMU可以直接在host进程中操作guest内存。

受到Virtio-GPU映射表的启发，或许我们不需要在主机进程中寻找用户可控的读写原语。对于QEMU进程来说，客户机内存和堆内存都是映射出来的地址空间，某种程度上可以将客户机内存视为一种堆内存。客户机内存既映射到QEMU主机进程，也由客户机VM控制，因此可以认为它是主机和客户机之间的共享内存。主机进程对该物理映射区域所做的任何更改都会反映在客户机内存中。同时，客户机可以在任意时间读写自己的内存。那么，如果我们在客户机空间中释放一个伪造的堆块会怎么样呢？

#### 4.2 跨虚拟机内存域攻击

由此，我们提出了跨虚拟机内存域攻击——利用客户机内存来构造任意读写的原语。具体步骤如下：

1. 在本环境中，客户机和主机均为Ubuntu。我们只需在客户机空间进行正常的`malloc`操作即可得到伪造堆块。
2. 预先填充好堆内存，其中指针指向客户机空间的伪造堆块。
3. 申请未初始化的`req`结构体。
4. 触发未初始化Free，这样QEMU进程便会将客户机中的伪造堆块添加到主机堆空间的Freelist中。
5. 由于攻击者在客户机空间具有读写权限，此时对该伪造堆块的操作就能达到UAF的效果。

#### 4.3 完整利用链

现在已经将未初始化Free漏洞转换成UAF漏洞，剩下的就是常规UAF的利用思路。首先，我们需要找到信息泄漏绕过ASLR的方法。然后，操纵堆布局以劫持控制流。最后执行任意命令，在主机上执行代码。

1. **堆喷**
   - 我们需要进行堆喷，以获得稳定的系统堆布局。频繁调用`nvme_init_sq`函数来喷射大量块，清空tcache Freelist。这样可以防止接下来释放的块合并到大块中，从而提高利用的可靠性。

2. **绕过ASLR**
   - 在Guest空间申请一个大小为`0x290`的伪造堆块。
   - 在Host空间申请Virtio-gpu的映射表，其中指针指向伪造堆块。
   - 释放映射表，在堆中留下预先设置好的状态。
   - 申请`io_req`结构体，其中未初始化的域正好指向伪造堆块。
   - 利用漏洞释放掉伪造堆块，主机将把它当作一个正常的堆块，并将其加入tcache bins中。
   - 释放的伪造堆块中将留下主机的堆地址，在客户机中得到堆地址泄漏。
   - 在主机中再次申请一个`0x290`的映射表，这块表将会被分配到客户机中（从tcache bins头部取出）。
   - 客户机再次读该堆块得到physical map地址泄漏。
   - `nvme_init_sq`中存在分配timer的原语，我们重复上述步骤将QEMU timer分配到客户机空间中。
   - 客户机读timer中的cb函数指针得到QEMU binary地址泄漏。

3. **劫持控制流**
   - 根据QEMU binary地址，计算出`system`函数的偏移。
   - 修改timer的cb函数指针为`system`地址，opaque参数为“;gnome-calculator”。
   - 运行定时器，控制RIP。

### 5 总结

与先前的QEMU逃逸相比，Scavenger有三点不同之处：

1. **攻击面**：先前的逃逸漏洞CVE-2020-14364位于USB模块，CVE-2019-14378和CVE-2019-14835位于Slirp模块，CVE-2019-5049位于AMD ATIDXX64.DLL驱动，而Scavenger位于NVMe存储设备。

2. **漏洞类型**：几乎所有已知的漏洞是由于缓冲区溢出或UAF引起的，而Scavenger是错误处理代码中的未初始化Free漏洞，这需要在漏洞利用方面有更多的直觉和技巧。

3. **利用技术**：现有的利用技术几乎都是试图在主机进程上找到可控数据，并构造攻击原语，如任意读写。相反，我们利用客户机内存来辅助主机的内存布局，通过跨hypervisor域操纵内存，为我们提供了读/写原语。

跨虚拟机内存域攻击为我们提供了一个全新的攻击维度。这种技术是通用的，只要攻击者有漏洞可以任意控制要释放的对象，就可以实现远程代码执行（RCE），从而实现虚拟机逃逸。在本环境中，主机和客户机均为Ubuntu，这为我们伪造堆块带来了便利，因为Linux中的基本堆块没有加密。但如果堆头是加密的，例如在Windows中，攻击难度会更大。我们相信这种攻击也会影响其他Hypervisor程序，如VirtualBox、VMware。