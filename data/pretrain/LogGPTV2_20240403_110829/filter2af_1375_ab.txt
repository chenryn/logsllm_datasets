- 将
qsg偏移对应的字段指向在堆中可控的⼀个对象。然后再利⽤漏洞触发未初始化Free，我们就能Free掉⼀个正在使⽤的对象，相当于得到了⼀个UAF。但事实上找到这样的原语并不容易。我们⾸先需要⼀个`N*0xa0`⼤⼩的结构，结构体的`0x40`偏移处有⼀个指针，同时该指针必须指向⼀个⽤户可控的对象。最重要的是，该对象的分配和使⽤之间应该有⼀个时间窗⼝，这样我们才能再对象被释放后再次去使⽤它。
经过多次尝试，我们并没有找到这样的原语，因为上述的限制太过于严苛。例如，我们发现 NVMe和其他传统设备以及⼀些复杂设备的结
构都不能满⾜这⼀要求。QEMU中的⼤多数结构不是⽤户可控的，可以说 QEMU的原语是相当有限的。
然⽽，我们在 Virtio gpu设备中发现了⼀个有趣的结构。该设备在 `virtio_gpu_create_mapping_iov`
函数中分配了⼀个地址映射表。这张表是由指针和⻓度组成的序列。该结构的⼤⼩可控，有指针成员，看起来是⼀个不错的结构。但不同的是，这⾥的指针指向guest空间，是由`dma_memory_map`映射⽽来的，其代表
的是将guest物理内存映射到host的虚拟地址，通过该地址QEMU可以直接在host进程中去操纵guest内存。
由Virtio-gpu的映射表所启发，或许我们不需要在主机进程上寻找⼀个⽤户可控的读写原语。对于QEMU进程来说，客户机内存和堆内存都是map出来的⼀段地址空间，⼀定程度上来说客户机内存也可以视作是⼀种堆内存。客户机内存既映射到QEMU主机进程，也由客户机VM所控制，我们可以认为它是主机和客户机之间的共享内存。
主机进程对该物理映射区域所做的任何更改都会作⽤于客户机内存中。同时对于客户机来说，其本身是可以在任意时间任意读写⾃身内存的。那么如果我们直接在客户机空间中释放⼀个伪造的堆块
会怎么样呢？
## 4.2 跨虚拟机内存域攻击
由此，我们提出了跨虚拟机内存域攻击 - 根据⽤户天然地完全可控客户机内存的特性，利⽤客户机内存来构造任意读写的原语（primitive）。具体步骤如下：
1.在本环境中客户机和主机均为Ubuntu，我们便只需在客户机空间正常malloc操作就能得到伪造堆块；
2.预先填充好堆内存，其中指针指向客户机空间的伪造堆块；
3.申请未初始化的req结构体；
4.触发未初始化Free，这样QEMU进程便会把客户机中的伪造堆块添加到主机堆空间的Freelist中了；
5.由于攻击者在客户机空间天然具有读写权限，此时对该伪造堆块操作就能达到UAF的效果。
## 4.3 完整利用链
现在已经将未初始化Free漏洞利⽤转换成 UAF的漏洞利⽤，剩下的就是常规UAF的利⽤思路了。⾸先，我们需要找到⼀个信息泄漏绕过
ASLR。然后我们需要操纵堆布局来劫持控制流。最后执⾏任意命令，在主机上执⾏代码。
1.堆喷
⾸先，我们需要做⼀些堆喷，以获得稳定的系统堆布局。我们频繁调⽤nvme_init_sq函数来喷 射⼤量的块来清空tcache
Freelist。通过这种⽅式，我们可以防⽌接下来释放的块合并到⼤块中，以得到更可靠的利⽤。
2.绕过ASLR
· Guest空间申请⼀个0x290的伪造堆块；
· Host空间申请Virtio-gpu的映射表，其中对应的指针指向伪造堆块；
· 释放映射表，在堆中留下预先设置好的状态；
· 申请io_req结构体，其中未初始化的域正好指向伪造堆块；
· 利⽤漏洞释放掉伪造堆块，主机将把它当作⼀个正常的堆块，并将其加⼊tcache bins中；
· 释放的伪造堆块中将留下主机的堆地址，在客户机中得到堆地址泄漏；
· 在主机中再次申请⼀个0x290的映射表，这块表将会被分配到客户机中（从 tcache bins头部取出）；
· 客户机再次读该堆块得到physical map地址泄漏；
· nvme_init_sq中存在分配timer的原语，我们重复上述步骤将QEMU timer分配到客户机空间中；
· 客户机读timer中的cb函数指针得到 QEMU binary地址泄漏。
3.劫持控制流
· 根据QEMU binary地址，计算得system函数偏移；
· 修改timer的cb函数指针为system地址，opaque 参数为“;gnome-calculator”；
· 运⾏定时器，控制RIP。
# 05 总结
先前的QEMU逃逸相⽐，Scavenger有三点不同之处。在攻击⾯上，先前的逃逸漏洞CVE-2020-14364位于USB模块，CVE-2019-14378和
CVE-2019-14835位于Slirp模块，CVE-2019-5049位于AMD ATIDXX64.DLL driver，⽽ Scavenger位于
NVMe存储设备。
在漏洞类型上，⼏乎所有已知的漏洞是由于缓冲区溢出或者UAF引起的，然⽽Scavenger是错误处理代码中的未初始化Free漏洞，这需要在漏洞利⽤⽅⾯有更多的直觉和技巧。在漏洞利⽤技术上，现有的利⽤技术⼏乎都是试图在主机进程上找到可控数据，并构造攻击原语，如任意读写。相反，我们利⽤客户机内存来辅助主机的内存布局，通过跨
hypervisor域操纵内存，为我们提供了 读/写原语。
跨虚拟机内存域攻击为我们提供了⼀个全新的攻击维度。这种跨虚拟机内存域攻击技术是通⽤的，只要攻击者有漏洞可以任意控制要Free的对象，那么攻击者就可以达到远程代码执⾏（RCE），实现虚拟机逃逸。在本环境中主机和客户机均为
Ubuntu，这为我们伪造堆块带来了便利，因为 Linux中的基本堆块没有加密。但是如果堆头是加密的，攻击难度就会更⼤⼀些，例如在
Windows中。我们相信这种攻击也会影响其他Hypervisor程序，如 VirtualBox、VMware。
* * *