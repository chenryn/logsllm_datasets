---
## Page 1038
（user,application_id）对为主键。Facebook然后“重新创建"这些
cookie，就像用户向这个应用栈发出后续请求时浏览器所做的一
样。
这个解决方案很简单，在开发者从HTML栈方式转向FBML服务方式
转变时，只需要很少的改变。请注意，当用户决定在这个应用提供
的HTML栈上导航时，这种信息是不能使用的。另一方面，它可以
有效地分离用户在Facebook上的应用体验和在应用的HTML站点上
的应用体验。
6.5.2FBJS
当应用栈作为一个FBMIL服务被使用，而不是直接由用户的浏览器
来使用，Facebook就没有机会执行浏览器端的脚本。直接返回未修
改过的开发者提供的内容（一个不充分的解决方案，这在FBML小
节的一开始就讨论过）可以解决这个问题，但它违反了Facebook在
显示体验上所加的约束。例如，当加载用户的简介页面时，
Facebook不希望在加载事件上触发一个弹出窗口。但是，限制所有
的JavaScript会排除许多有用的功能，如AJAX或在不重新加载的情
况下动态操作页面的内容。
相反，FBML在解释开发者提供的树和其他页面元素的内
容时会考虑到这些约束。在此之上，Facebook提供了一些JavaScript
库，让这些场景容易实现，同时文受到控制。这些修改共同构成了
Facebook的平台JavaScript仿真套件，称为FBJS，它通过以下儿点，
让应用既动态文安全：
重写FBML属性，确保实现虚拟文档范围。
延迟激活脚本内容，直到用户在贞面或元素上发起动作时。
提供一些Facebook库，以受控的方式来实现常见的脚本使用场景。
很清楚，不是所有的实现自有平台的容器站点都需要这些修改，但
FBJS向我们展示了几种解决方案，这样的新Web架构需要这些解决
方案来绕过一些困难。我们在这里只展示了这些解决方案的一般思
想，FBJS的许多部分还需要不断改进，与FBML和可扩展的专有
JavaScript库进行融合。
1037
---
## Page 1039
首先，JavaScript通常可以访问包含它的文档的整个文档对象模型
（DOM）树。但是在平台画布页面中，Facebook包含了许多它自己
的元素，开发者不充许对它们进行修改。解决方案是什么？在用户
提供的HTML元素和JavaScipt符号之前加上前缀，即应用的ID（如
app1234567）。通过这种方式，在开发者的JavaScript中如果试图调
用不允许调用的alert（）函数，就会调用未定义的函数
app1234567_alert，并且只有开发者自己提供的那部分文档的HTML
可以被document.getElementByld这样的JavaScript代码访问。作为
FBJS需要对提供的FBML（包括元素）进行这种转换的
个例子，我们创建了一个简单的FBML页面，实现了AJAX功能，如
例6-30所示。
例6-30：一个使用FBJS的FBML页面
These links demonstrate the Ajax object:
AJAX
Time! 
function do_ajax (type){
var ajax=new Ajax () : //FBJS Ajax library.
ajax.responseType=type:
switch (type){
1038
---
## Page 1040
case Ajax.RAW: ajax.ondone=function (data) {
document.getElementById ('ajaxl*) .setTextValue (data) ;
}：
break;
}：
ajax.post ('http://www.fettermansbooks.com/testajax.php?
t=′+type) :
FBML和我们的FBJS修改动作将这些输入转变成了例6-31中的
HTML。这个例子中的NOTE注释指出了每种需要的转换，不是实际
输出的一部分。
例6-31：HTML和JavaScript输出的例子
These links demonstrate the Ajax object:
AJAX Time! 
var app=new fbjs_sandbox (1234567);
app.validation_vars={};
app.context='b7f9b437d9f7';
app.contextd=;
app.data={"user": 8055, "installed": false, "loggedin";
true”:
app.bootstrap（):
1040
---
## Page 1042
function a1234567_do_ajax (a1234567_type) (
var a1234567_ajax=new a1234567_Ajax (): 
a1234567_ajax.responseType=a1234567_type:
switch (a1234567_type) (
case a1234567_Ajax . RAW:
a1234567_ajax.ondone=function (a1234567_data) (
a1234567_document.getElementById ('ajax1*) .setTextValue (a
1234567_data) :
break;
a1234567_ajax.post ('http://www.fettermansbooks.com/testaja
x.php?t=′+a1234
567_type) :
上
下面是这段代码中的NOTE的解释：
NOTE 1
Facebook需要包含它自己的特殊JavaScript，包括fbjs_sandbox的定
义，目的是渲染并发者的脚本。
NOTE 2
还记得前面FBML初始化流程中的Srewrite_attrs元素吗？FBML会重
写这个列表中的属性，变成Facebook特有的功能；这实际上是FBJS
1041
---
## Page 1043
的一部分。所以这里的onclick会激活这个页面的其他元素，这些元
素在用户执行这个动作之前是非激活的。
NOTE 3
请注意在HTML和脚本中的元素如何加上了该应用的应用ID作为前
缀。这意味着并发者对alert（）的调用将变成对
appl234567_alert（）的调用。如果Facebook的后台JavaScript在这个
上下文中允许这个方法，它将最终转向执行alert（）。如果不允
许，这将是未定义的调用。类似地，这种加前缀的方式实际上为
DOM树提供了命名空间，所以对该文档某些部分的改变只限于并发
者定义的那些部分。类似的沙盒技术也允许并发者提供限制范围的
CSS。
NOTE 4
Facebook提供了一些专门的JavaScript对象，如Ajax和Dialog，目的
是支持（并且常常改进了）常见的使用场景。例如，通过Ajax（）
对象发出的请求实际上能获得FBML作为结果，所以它们被重定向
到Facebook域的一个代理上，在这里Facebook完成在线的FBML到
HTML的转换。
支持FBJS需要对FBML进行改动、专门的JavaScript和AJAX代理这
样的服务器端组件，才能够绕过应用Web架构的一些限制，但结果
是很强大的。开发者因此可以享受绝大多数的JavaScript功能（甚至
改进了这些功能，如支持FBML的AJAX），而且平台确保了应用内
容提供了用户在Facebook上期望的受控体验，这完全是通过技术手
段来实现的。
6.5.3服务改进小结
解决了新的n层社会关系应用的概念带来的剩下一些问题之后，我
们又改进了服务架构，添加了COOKIE和FBJS等项，如图6-6所示。
1042
---
## Page 1044
App服务
App数据
SQL对象
App逻辑层
(obj)
App显示层
$_GET,S_POST
S_COOKIE