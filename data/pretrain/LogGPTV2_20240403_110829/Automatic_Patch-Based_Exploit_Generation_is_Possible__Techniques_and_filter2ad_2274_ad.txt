crash, and at worst, can result in a successful control hi-
jack.
The patch addresses the integer overﬂow by adding
5 additional checks when loading a metaﬁle. The un-
patched version is exploitable when any one of the 5
checks fails.
EBDS took 109 seconds to diff the patch and un-
patched version. The diff identiﬁed the 5 additional
checks. Since an exploit can fail any of the 5 checks,
an exploitable check would be tried immediately using
the least changed heuristic.
Exploit Generated: The exploit we initially gener-
ated caused a denial-of-service. This vulnerability is
similar to DSA SetItem: we can specify what to over-
write in the heap structure, but the location of the heap
structure depends upon the process layout. Thus, a suc-
cessful control hijack required repeatedly launching the
attack. Any φ that detects pointer misuse is appropriate:
we used TEMU [2].
PNG Buffer Overﬂow Vulnerability (MS05-025;
Bugtraq ID#13941; CAN-2005-1211). PNG (Portable
Network Graphics) is a ﬁle format for images utilized by
many programs such as Internet Explorer and Microsoft
Ofﬁce programs. Each PNG image contains a series of
records which specify different properties of the image,
e.g., whether the image is indexed-color or gray-scale,
the alpha channel, etc. In the indexed-color mode, the
record format speciﬁes an additional alpha channel byte
value for each indexed color. A heap-based buffer over-
ﬂow occurs in early Microsoft implementations when
the number of alpha channel bytes exceeds the number
of pre-speciﬁed colors.
The patched version adds additional checks to vali-
date PNG record ﬁelds. To the best of our knowledge,
there are no public exploits for this vulnerability.
The total time to diff the two vulnerable versions was
27.05 seconds. Changes were only reported in the vul-
nerable procedure, with the exploitable check being the
ﬁrst using the least changed heuristic.
Exploit Generated: The exploit we generated ini-
tially caused the program to crash, similar to GDI and
DSA SetItem. Again, we use TEMU [2] to conﬁrm can-
didate exploits, but any φ that detects pointer misuse is
also possible. This attack is on the heap, and also re-
quired us to repeatedly launch the attack to achieve suc-
cessful control hijack.
4.2 Patch-Based Exploit Generation using Dy-
namic Analysis
generated
exploits
successfully
We
the
DSA SetItem, ASPNet Filter, and GDI vulnerabil-
ities using dynamic analysis. For DSA SetItem, we
recorded the execution trace of IE 6 loading a valid
for
DSA SetItem ASPNet Filter GDI
DSA SetItem
GDI
Trace
4.99
Formula
0.52
Solver
Total
0.17
5.68
4.50
0.14
6.93
11.57
9.92
0.41
0.01
10.34
Table 2. Time to generate an exploit us-
ing the dynamic approach. All times are
in seconds.
no opt
opt
no opt
opt
Model Gen
1.35
Formula
2.48
1.45
0.87
3.61
3.45
3.97
1.02
Solver
182.91
81.15
19.61
21.42
Total
186.74
83.47
26.67
26.41
Table 3. Time to generate exploit using the
static approach. All times are in seconds.
webpage that calls the setSlice ActiveX control method,
which in turn calls DSA SetItem. For ASPNet Filter,
we recorded IIS processing an HTTP request from a log
ﬁle. For GDI, we created an image within a PowerPoint
presentation,
then saved the image in the Windows
metaﬁle format. We recorded the execution of a small
GDI application loading the saved ﬁle. All execution
traces were recorded using TEMU [2].
Table 2 shows an overview of our results. All times
in the table are in seconds. The “Trace” row shows the
amount of time it took to generate a trace using TEMU.
The “Formula” row shows the amount of time to lift the
trace to our modeling language and produce the con-
straint formula. The “Solver” row indicates how long
it took the solver to solve the formula.
The total time to generate an exploit after difﬁng
is under 12 seconds in all experiments. If we include
difﬁng time, then the total exploit generation time for
DSA SetItem is 377.58 seconds, ASPNet Filter is 28.17
seconds, and GDI is 119.34 seconds.
We were not able to generate exploits using the dy-
namic approach for the IGMP and PNG vulnerabilities.
For IGMP, we recorded the execution of Windows pro-
cessing the sample IGMP message from [10]. The iden-
tiﬁed new checks were executed. However, the con-
straint formula built was not satisﬁable by any input that
failed the new check. The reason is that the particu-
lar execution path taken was already constrained so the
added check could never fail (i.e., was redundant along
that path). For PNG, we were not able to generate an
exploit for a sample execution trace for the same reason:
the path constraints prevented the new check from ever
failing. In particular, the execution of PNG involves the
calculation of a CRC-32 checksum. There were no other
inputs along the chosen path that satisﬁed the checksum
while failing the new check.
4.3 Patch-Based Exploit Generation using
Static Analysis
We were able to generate exploits for the DSA SetItem
and GDI vulnerabilities using a purely static approach.
For DSA SetItem, the static model included setSlice
and DSA SetItem.
For GDI, the vulnerable proce-
dure GetEvent is reachable by the explored API
CopyMetaFileW. Thus, our static model consisted of
these two functions.
Table 3 shows an overview of our results. All times in
the table are in seconds. We include in this table the time
to generate a model of all static paths to the new check
under the “Model” row. For each vulnerability, we also
consider two cases: with and without the optimization
on the model discussed in Section 3.2.3.
Without optimization, we were able to generate ex-
ploits for DSA SetItem in 186.74 seconds. When we
enable optimizations, the time to generate the model in-
creases, but the subsequent steps are much faster. In par-
ticular, the optimizations for DSA SetItem reduce the
time to generate an exploit from the formula by about
55%. We believe further optimizations would likely fur-
ther reduce the solution time. For GDI, the optimiza-
tions had little effect, saving only .26 seconds overall.
We
enumerated 3 different
the
DSA SetItem vulnerability.
In particular, we enu-
merated both the public exploit, and 2 new exploit
variants.
exploits
for
One way to compare the advantage of the static ap-
proach is to measure the number of paths to the new
check included in the formula. A similar formula us-
ing the dynamic approach alone would require enumer-
ating each path. There are 6 exploitable paths to the new
check for DSA SetItem in the static model we consider.
There are about 1408 total paths in the static model for
the GDI vulnerability.
We were not able to generate exploits statically for
the PNG, IGMP, and ASPNet Filter vulnerabilities. In
the ASPNet Filter vulnerability, there are system calls
153
DSA SetItem IGMP GDI
PNG
Dyn:Static
Formula Size
Solver Time
# Paths
Trace Gen
4.99
Model Gen
1.42
Formula
Solver
Total
0.31
4.79
11.51
10.14
2.58
12.57
3.78
9.92
3.36
.027
0.26
103.28
0.58
0.28
0.14
29.07
13.57
104.28
Table 4. Time to generate an exploit using
the combined approach. All times are in
seconds.
4:1
3:2
2:3
309250
310414
18.94
22.77
496
496
6549513
Out of Mem 10416
Table 5. Results for changing the mix point
at different points in the call path to the
vulnerable procedure. The formula size is
the number of expressions in the formula.
Solver time is in seconds.
not currently supported by our constraint formula gener-
ator. The standard solution is to generate summaries of
the effects [6, 8]. A manual analysis indicates that sim-
ply omitting the various calls would likely still result in
a formula that generates exploits. We leave exploring
such extensions as future work. We could not generate
exploits for all paths statically for the PNG and IGMP
vulnerabilities because the solver ran out of memory try-
ing to solve the generated constraints.
4.4 Patch-Based Exploit Generation using
Combined Analysis
We successfully generated exploits using the combined
approach for DSA SetItem, IGMP, GDI, and PNG. In
our experiments, we use the heuristic to mix at proce-
dure boundaries.
Table 4 show our results when we mix using the dy-
namic trace from Section 4.2 up to the vulnerable pro-
cedure. The static approach generates a formula for the
vulnerable procedure. The two are then spliced together.
The mixed approach works for IGMP and PNG, but
the purely dynamic and purely static approaches do not.
In both cases the purely dynamic approach fails because
the executed path in the trace is not exploitable. In both
cases the static approach also fails because the solver
runs out of memory. The combined approach offers a
way to build a formula for a subset of potentially ex-
ploitable paths without enumerating them individually.
We also measured how mixing reduces the static for-
mula size for the IGMP vulnerability. The shortest call
path to the vulnerable function has length 5: IPRcv-
Packet → DeliverToUserEx → DeliverToUser → IGM-
PRcv → IGMPRcvQuery. We consider mixing at IGM-
PRcvQuery, IGMPRcv, and DeliverToUser, i.e., the for-
mula consists of all paths through 1, 2, and 3 procedures,
and the rest from the dynamic path.
Table 5 shows our results. This table shows that us-
ing the dynamic formula for IPRcvPacket → Deliver-
ToUserEx → DeliverToUser and the static for IGMPRcv
and IGMPRcvQuery is solvable, while adding all paths
for DeliverToUser creates a formula that is too difﬁcult
to solve. It also shows a common behavior when solv-
ing formulas in our experience: they are either solvable
relatively fast, e.g., within a few minutes, or they are not
solvable within a reasonable amount of time.
5 Implications of Automatic Patch-Based
Exploit Generation
Our evaluation demonstrates APEG for several vulnera-
bilities. Since we must conservatively estimate the capa-
bilities of attackers, we conclude APEG should be con-
sidered a realistic attack model. The feasibility of auto-
matic exploit generation has important implications on
the security landscape. One of the most immediate prob-
lems is rethinking today’s patch distribution practices in
light of these results.
In today’s patch distribution practices, vulnerable
systems typically download patches at different times,
creating a time window from when the ﬁrst vulnerable
system downloads a patch to the last. Staggered patch
distribution is attractive because it prevents huge trafﬁc
spikes when a new patch is released. For example, re-
cently Gkantsidis et al. conducted a large scale study of
users of Microsoft Update. Their measurements show
that it takes about 24 hours for Windows Update to see
80% of the unique IPs of hosts checking for a patch
[18].These measurements conﬁrm the intuition that not
everyone will receive a patch at the same time, with gaps
of hours if not longer before even the majority receive
the update.
In our results, we are typically able to create exploits
from the patch in a matter of minutes, and sometimes
seconds. Therefore, APEG could enable those who ﬁrst
received a patch to generate an exploit and compromise
a signiﬁcant fraction of systems before they even had a
chance to download the update. Note this is irrespective
of whether people actually apply the patch; but whether
they even have the opportunity to apply it.
154
There are many approaches to ﬁx staggered patch dis-
tribution. We discuss three directions: 1) make it hard
to ﬁnd new checks (through obfuscation), 2) make it so
everyone can download the update before anyone can
apply it (using encryption), and 3) make it so everyone
can download the patch at the same time (using P2P).
Patch Obfuscation. One approach is to hide what lines
of code changed between P and P ′. In particular, ven-
dors could obfuscate patches such that the difference be-
tween P and P ′ is very large. This approach would be
the easiest to break our particular implementation, since
the results of EBDS [13] would contain too many in-
structions to isolate which checks were added.
The advantage of this approach is obfuscation tech-
niques are widely available. However, there are many
challenges to the obfuscation approach. For example,