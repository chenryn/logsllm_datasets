Illegal 
instr. 
Hang  Assert-
ion 
- 
- 
Register Injections 
Perceived 
Actual 
71.96 ± 0.32 
70.03 ± 0.27 
- 
Recoverry
 Time (s) 
88.81 ± 2.57 
73.42 ± 1.28 
0.70 ± 0.21 
0.71 ± 0.03 
In addition to the system failures described 
above,  three  text-segment  injections  into  the 
Execution  ARMOR  resulted  in  the  restarting  of 
the  texture  analysis  application.    All  three  of 
these  correlated  failures  were  successfully 
recovered. 
0.31 ± 0.04 
0.45 ± 0.08 
recovery. 
Heartbeat  ARMOR 
  The 
Heartbeat  ARMOR  recovered  from  all  register 
errors,  while  text-segment  injections  brought 
about  two  system  failures. 
  Although  no 
corrupted  state  escaped  the  Heartbeat  ARMOR, 
the error prevented the Heartbeat  ARMOR from 
receiving 
the 
Heartbeat ARMOR falsely detected that the FTM 
had  failed,  since  it  did  not  receive  a  heartbeat 
reply from the FTM.  The ARMOR then began to 
initiate recovery of the FTM by (1) instructing 
the  FTM’s  daemon 
the  FTM 
process, and (2) instructing the FTM to restore 
its state from checkpoint after receiving acknowledgment that 
the FTM has been successfully reinstalled. 
incoming  messages. 
1.05 ± 0.33 
0.51 ± 0.05 
to  reinstall 
  Thus, 
0.30 ± 0.01 
0.43 ± 0.04 
As  a  result  of  the  error,  the  Heartbeat  ARMOR  never 
received  the  acknowledgment  in  step  two,  thus  preventing  it 
from  sending  a  follow-up  message  to  restore  the  FTM  state.  
The immediate problem (i.e., causing a situation in which the 
FTM  is  left  unrecovered)  can  be  solved  by  combining  the 
reinstallation  of  the  FTM  and  state  restoration  into  a  single 
operation without the intermediate acknowledgment.  However, 
the underlying problem persists:  the Heartbeat ARMOR suffers 
from  receive  omissions  and  will  continue  to  detect  a  failed 
FTM during subsequent heartbeat rounds. 
To  detect  the  receive  omission  error,  an  element  can  be 
added  to  the  Heartbeat  ARMOR  that  performs  a  series  of  self-
tests on key ARMOR functionality before the heartbeat messages 
Target  Recoveries/
Failures 
Baseline 
- 
Seg. 
fault 
- 
Application 
FTM 
Execution 
ARMOR 
Heartbeat 
ARMOR 
Application 
FTM 
Execution 
ARMOR 
Heartbeat 
ARMOR 
95 / 95 
84 / 84 
77 / 80 
77 / 77 
82 / 82 
84 / 88 
93/ 95 
95 / 97 
71 
58 
56 
62 
41 
53 
45 
53 
- 
4 
6 
6 
6 
23 
28 
31 
33 
20 
16 
15 
8 
0 
4 
3 
1 
90.70 ± 2.57 
75.65 ± 1.54 
76.19 ± 1.82 
73.00 ± 0.22 
Text-segment Injections 
18 
5 
11 
11 
0 
2 
8 
0 
89.47 ± 2.87 
76.47 ± 2.87 
77.48 ± 1.93 
73.23 ± 0.37 
73.56 ± 1.83 
70.66 ± 0.21 
87.49 ± 2.88 
71.00 ± 2.31 
74.83 ± 1.86 
71.21 ± 0.36 
FTM recovery.  Table 4 shows that the FTM successfully 
recovered  from  all  register  injections.    Two  text-segment 
injections  were  detected  through  assertions  on  the  FTM’s 
internal  data  structures,  and  both  of  these  errors  were 
recovered.    The  extent  to  which  assertions  prevent  corrupted 
state  from  escaping  the  process  is  investigated  via  heap 
injections in section 6. 
Table  4  also  shows  that  the  FTM  could  not  recover  from 
four text-segment errors.  In each case, the error corrupted the 
FTM’s  checkpoint  prior  to  crashing.  Because  the  checkpoint 
was corrupted, the FTM crashed shortly after  being recovered.  
This cycle of failure and recovery repeated until the run timed 
out. 
There were seven cases of a correlated failure in which the 
FTM  failed  during  the  application’s  initialization:  three  from 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:44 UTC from IEEE Xplore.  Restrictions apply. 
Table 5: System failures observed through heap injections 
Element
mgr_armor_info.  Stores information 
about subordinate ARMORs such as location 
and element composition. 
exec_armor_info.  Stores information 
about each Execution ARMOR such as status 
of subordinate application. 
app_param.  Stores information about 
application such as executable name, 
command-line arguments, and number of 
times application restarted. 
agr_app_detect.  Used to detect that all 
processes for MPI application have 
terminated and to initiate recovery if 
necessary. 
node_mgmt.  Stores information about the 
nodes, including the resident daemon and 
hostname. 
TOTAL 
Effect on System 
System Failures 
A 
4 
B 
1 
C 
5 
D 
4 
0 
0 
5 
4 
0 
0 
0 
0 
0 
0 
0 
0 
0 
4 
14 
0 
15 
10 
0 
8 
Total 
#2 
#3 
14 
9 
0 
0 
14 
37 
6 
4 
0 
0 
0 
10 
8 
5 
0 
0 
14 
27 
#4 
19 
9 
2 
4 
3 
37 
Runs that led to 
system failure
6
8
19
Runs in which
an assertion fired
Legend (Effect on system): 
(A)  Unable to register daemons. 
(B)  Unable to install Execution ARMORs. 
(C)  Unable to start applications. 
(D)  Unable  to  uninstall  Execution  ARMORs  after 
application completes. 
Legend (System failure/assertion check classification): 
(2) 
(3) 
(4) 
System failure without assertion firing. 
System failure with assertion firing. 
Successful recoveries after assertion fired. 
are  sent.    These  self-tests  generate  a  signature,  which  can  be 
verified by either the local daemon or by the receiving ARMOR.  
Additional error injection experiments can be used to evaluate 
the  coverage  of  these  additional  self-checks  on  ARMOR 
functionality. 
Among the successful recoveries from text-segment errors 
shown in Table 4, four involved corrupted heartbeat messages 
that caused the FTM to fail.  Although faulty data escaped the 
Heartbeat  ARMOR, the corrupted message did not compromise 
the  FTM’s  checkpoint.    Thus,  the  FTM  was  able  to  recover 
from these four failures. 
6  Heap Injections 
Careful  examination  of  the  register  injection  experiments 
showed  that  crash  failures  were  most  often  caused  by  
segmentation  faults  raised  from  dereferencing  a  corrupted 
pointer.  To maximize the chances for error propagation, only 
data  (not  pointers)  were  injected  on  the  heap.    Results  from 
targeted  injections  into  FTM  heap  memory  were  grouped  by 
the element into which the error was injected.  Table 5 shows 
the  number  of  system  failures  observed  from  100  error 
injections  per  element,  classified  as  to  the  their  effect  on  the 
system.    One  hundred  targeted  injections  were  sufficient  to 
observe either escaped or detected errors given the amount of 
state  in  each  element;  overall,  500  heap  injections  were 
conducted on the FTM. 
Many data errors were detectable through assertions within 
the  FTM,  but  not  all  assertions  were  effective  in  preventing 
system  failures.    One  of  four  scenarios  resulted  after  a  data 
error  was  injected  (the  last  three  columns  in  Table  5  are 
numbered to refer to scenarios 2-4): 
1.  The data error was not detected by an assertion and had no 
  The  application  completed 
effect  on 
successfully as if there were no error. 
the  system. 
2.  The data error was not detected by an assertion but led to a 
system failure.  None of the system failures impacted the 
application while it was executing. 
3.  The data error was detected by an assertion check, but only 
after the error had propagated to the FTM’s checkpoint or 
to another process.  Rolling back the FTM’s state in these 
circumstances was ineffective, and system failures resulted 
from  which  the  SIFT  environment  could  not  recover.  
These  cases  show  that  error  latency  is  a  factor  when 
attempting 
in  a  distributed 
environment. 
to  recover  from  errors 
least 
4.  The data error was detected by an assertion check before 
propagating  to  the  FTM’s  checkpoint  or  to  another 
process.  After an assertion fired, the FTM killed itself and 
recovered  as  if  it  had  experienced  an  ordinary  crash 
failure. 
The  injection  results  in  Table  5  show  that  some  state 
information was more sensitive to error propagation than other.  
The 
and 
mgr_app_detect)  were  those  modules  whose  state  was 
substantially read-only after being written early within the run.  
With assertions in place, none of the data errors led to system 
failures.  At the other end of the sensitivity spectrum, 28 errors 
in  two  elements  caused  system  failures.    In  contrast  with  the 
elements 
in 
mgr_armor_info and node_mgmt were repeatedly written 
during the initialization phases of a run.   
(app_param 
causing  no 
the  data 
elements 
sensitive 
failures, 
system 
in 
errors. 
  For 