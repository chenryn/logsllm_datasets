W D task struct
W D task struct
D task struct
R
R
D task struct
W D task struct
Accessing code (c)
ε
ε
ε
ε
ε
ε
ε
ε
ε
ε
ε
ε
read kmem, write kmem R,W D ﬁle
memory lseek
W D ﬁle
do write mem
R,W D ﬁle
ε
ε
ε
ε
ε
ε
ε
ε
R
D module
W D module
W S
W S
W S
W S
W S
W S
generic copy from user W S
W S
W S
ε
ε
sys call table
sys call table
sys call table
sys call table
sys call table
sys call table
sys call table
sys call table
proc root inode operations
Field,Oﬀset (f )
pid
ﬂags
uid, euid, gid, egid
next task
addr limit
suid, fsuid, fsgid
cap eﬀective
cap inheritable
cap permitted
uid
comm
next task, prev task
f pos
f pos
f pos
next
next
# 141
# 2,37,120,220
# 6
# 5
# 3
# 59
# 59
# 39
lookup
Malware behavior
N Rootkits with this behavior
7 Ad1, Ad2, Ad3, hp, knark, linuxfu, kis Reading a process’s ID
Reading a process’s ﬂag
6 Ad1, Ad2, Ad3, SK, superkit, knark
Privilege escalation
5 Ad1, Ad2, Ad3, kbdv3, knark
Listing processes
5 Ad1, Ad2, Ad3, hp, linuxfu
Setting an address space information
4 Ad1, SK, superkit, kis
4 Ad1, Ad2, Ad3, knark
Privilege escalation
Privilege escalation
3 Ad1, Ad2, Ad3
Privilege escalation
3 Ad1, Ad2, Ad3
Privilege escalation
3 Ad1, Ad2, Ad3
Reading a user’s ID
3 Ad1, Ad2, kbdv3
Reading a process’ name
3 Ad1, Ad3, linuxfu
Hiding a process
2
4
Manipulation via /dev/kmem
Manipulation via /dev/kmem
4
Manipulation via /dev/kmem
3
Scanning the kernel module list
4
Hiding a kernel module
3
Hijacking a system-call
4 Ad1, Ad2, knark, Rial
Hijacking a system-call
3 Ad1, Ad2, knark
3 Ad1, Ad2, Rial
Hijacking a system-call
Hijacking a system-call
2 Rial, modhide1
Hijacking a system-call
2
Hijacking a system-call
2
Hijacking a system-call
2
Hijacking a system-call
2 Ad1, Ad2
2 Ad1, Ad2, Ad3
Hijacking a hook on static memory
hp, linuxfu
fuuld, hide lkm, SK, superkit
fuuld, hide lkm, SK, superkit
fuuld, SK, superkit
kis, cleaner, modhide, modhide1
cleaner, modhide, modhide1
knark, Rial
SK, superkit
SK, superkit
type for dynamic data or a variable name for static data;
and the accessed oﬀset(s) (f ). The oﬀset is converted to a
ﬁeld name if it corresponds to a speciﬁc ﬁeld. If the accessed
object is the system-call table, a system-call number (#) is
designated by dividing the oﬀset by the size of a pointer.
The number N and the names of rootkits whose signatures
have this element are listed in the next columns. A short
description of the element is provided in the far right-hand
column by considering the accessed data, oﬀset, and access-
ing code.
Attacks on Process Control Blocks (PCBs).
The
ﬁrst category at the top of Table 4 lists the data behavior
that targets the PCBs (type: task_struct in Linux). This
is a core data structure that maintains administrative infor-
mation about processes. Therefore it is a major target of
rootkits, which aim to manipulate such information.
Table 4 shows that seven rootkits read the process ID
numbers in PCBs during attacks. The ﬂags of the processes
are accessed by six rootkits. Several rootkits, such as the
family of adore rootkits, the kbdv3 rootkit, and the knark
rootkit, provide a back-door that permits the root privi-
lege to an ordinary user. The hp and linuxfu rootkits show
an attack pattern that manipulates the pointers connecting
PCBs. This behavior can hide PCBs from the view inside
the operating system.
Attacks using /dev/kmem.
The second category
shows the rootkit behavior that manipulates kernel mem-
ory by using a memory device (e.g., /dev/kmem). This de-
vice allows a user program to read and write kernel memory
like a ﬁle putting the kernel integrity at risk. The kernel
runs compromised by fuuld, hide_lkm, SucKIT, and superkit
rootkits commonly show unique data behavior that the ker-
nel functions related to memory devices access file kernel
objects.
Attacks on the Kernel Module List.
The next cate-
gory lists rootkit attacks on the kernel module list. The next
pointer ﬁeld of module objects are read or written by the kis,
cleaner, modhide, and modhide1 rootkits. The module objects
constitute the list of kernel modules and they are connected
by this pointer ﬁeld. The rootkit attacks that hide a module
appear as the direct manipulation of this ﬁeld.
Attacks on Static Kernel Objects.
The last category
is the manipulation of static kernel objects. Several rootkits
hijack the system-calls by replacing the system-call table en-
tries with the addresses of malicious functions. This behav-
ior is captured by the manipulation of the system-call table
by several code sites, depending on the attack vector. In the
case of driver-based rootkits, such behavior is captured as
access by the generalized rootkit code, ε. The rootkits based
on memory devices (e.g., /dev/kmem) use legitimate kernel
code for manipulation (e.g., __generic_copy_from_user).
5. DISCUSSION
DataGene is a signature-based approach that detects known
and unknown rootkits based on kernel data access patterns
similar to the signatures of previously analyzed rootkits. If
a rootkit’s attack behavior is not similar to any behavior
in existing signatures or it does not involve kernel data ac-
cesses, such malware is out of coverage of DataGene since
such behavior does not match the DataGene’s signature.
Many existing rootkits that share the attack goals often
exhibit similar data access patterns because essentially these
malicious programs generate a false view by manipulating le-
gitimate kernel data structures relevant to the goals. Our
approach can detect rootkits by focusing on the common at-
tack targets described in the malware signatures even though
such rootkits have diﬀerent functionalities.
Obfuscating data access patterns involves comparatively
more sophistication than code obfuscation because malware
requires to use alternate legal code to access kernel data
beyond the diversiﬁcation of malware’s own code patterns.
Such attack attempts can be detected by employing the de-
fense approaches against control ﬂow anomaly.
DataGene is mainly designed for kernel malware analy-
sis where a potential attack sample is analyzed to determine
whether it is malware based on its data behavior. In such an
analysis/classiﬁcation environment with controlled conﬁgu-
rations, it is possible to produce no false alarms as presented
in our experiments. However, if this technique is further
aimed towards a production environment where a diversity
of workload could be generated, false alarms may occur due
to the foundation of our technique on dynamic execution.
6. RELATED WORK
DataGene introduces a new approach that generates the
signature of kernel malware by using their unique data access
patterns. There are several approaches related to DataGene
in the area of kernel malware analysis and detection.
Malware Defense based on Code Behavior.
There
has been a variety of approaches which characterizes mal-
ware’s behavior by using its control ﬂow (e.g., instruction
sequences and system-call sequences) [2, 3, 9, 14, 15], and
such approaches face the following challenges.
First, malware can obfuscate its execution to elude the
code behavior-based malware analyzers. Several papers de-
scribe obfuscating techniques such as dead code insertion,
code transformation, and instruction substitution [8, 10, 25,
26]. Second, malware’s control ﬂow can vary at runtime
and the detection mechanism using malware’s code behav-
ior should be able to handle such variations.
Complementing these approaches, DataGene uses the pat-
tern of kernel memory accesses, to characterize malware be-
havior. Because this approach avoids using the control ﬂow
of malware, it can be less susceptible to code obfuscation
techniques or variations in the malware’s control ﬂow.
Kernel Malware Defense based on Code Integrity.
The approach based on code integrity [23, 24] allows only au-
thorized kernel code: the kernel text and the kernel modules
on a white list. This approach is eﬀective to prevent kernel
rootkits that introduce their own code. However, advanced
rootkits operate without explicitly injecting malicious code
by using techniques such as kernel memory devices, kernel
bugs, or return-oriented programming; and this approach
cannot handle such cases. DataGene presents a new angle
and detects rootkits based on their unique data behavior.
Thus it could be applied to such challenging rootkits.
Kernel Rootkit Proﬁlers.
Kernel rootkit proﬁlers
[22, 27] provide a variety of aspects of rootkit behavior by
analyzing rootkit activities and examining user space im-
pact. The proﬁling result of these approaches is speciﬁc to
the analyzed malware. In contrast, DataGene uses the mal-
ware’s memory access patterns whose code information is
generalized. Therefore, it has the potential to detect rootkit
variants that are similar in data behavior. Also DataGene
explores common characteristics across multiple rootkits.
Signatures based on Data Structures.
Laika [11]
can determine data structures and classify their unique pat-
terns for malware. This approach is eﬀective for user space
malware (e.g., botnet programs), which has its own mem-
ory space. However, kernel malware’s code and data reside
in kernel memory together with legitimate kernel code and
data. Also kernel malware targets legitimate kernel data
and hijacks kernel hooks in addition to using its own data.
Therefore, the data behavior in the kernel space is the mix-
ture of the kernel and the kernel malware.
Several approaches [7, 12, 16] can detect kernel data struc-
tures based on data properties such as data values and pointer
connections. Based on the discovery of data structures,
these approaches can also detect kernel rootkits that hide
kernel data structures. While the signatures of such ap-
proaches are the properties of the data structures, the sig-
natures of DataGene is the properties of malware. Those are
generated by using unique data access patterns of malware.
SegSlice
Inter-relationship between Code and Data.
[5] is a trapping framework that measures and enforces the
relationships between the program’s code and data units
(called slices) using the x86 segmentation system. These
relationships are deﬁned by the programmer using SegSlice
API. Kernel data access patterns captured by DataGene
reﬂect the relationships between code and data represent-
ing which code is expected to access what types of data.
These access patterns are systematically captured from the
dynamic execution of an operating system kernel by using
virtualization technique.
7. CONCLUSION
We have presented a new approach to characterize the
behavior of kernel malware by using the patterns of kernel
data accesses unique to the malware. The data behavior
signature is constructed after generalizing the malware code
information. This abstracted data behavior does not use
temporal control ﬂow information; therefore, it can match
similar data behavior across rootkits and their variants.
Our experiments show that the signatures of three classic
rootkits can eﬀectively detect the kernel runs compromised
by 16 kernel rootkits and does not trigger any false positives
in benign runs. We observe common data behavior across
the kernel rootkits in the comparison of their signatures. In
addition, we present the details of common data behavior,
which provide an in-depth understanding of popular attack
behavior of kernel rootkits.
8. ACKNOWLEDGEMENT
We would like to thank the anonymous reviewers for their
insightful comments. This research was supported, in part,
by the US Air Force Oﬃce of Scientiﬁc Research (AFOSR)
under Contract FA9550-10-1-0099, the US Air Force Re-
search Laboratory (AFRL) under Contract FA8750-09-1-
0224, and the US National Science Foundation (NSF) under
Grant 0716444. Any opinions, ﬁndings, and conclusions in
this paper are those of the authors only and do not neces-
sarily reﬂect the views of the AFOSR, AFRL, or NSF.
9. REFERENCES
[1] A. Baliga, V. Ganapathy, and L. Iftode. Automatic
Inference and Enforcement of Kernel Data Structure
Invariants. In Proceedings of the 24th Annual Computer
Security Applications Conference (ACSAC’08), December
2008.
[2] D. Balzarotti, M. Cova, C. Karlberger, C. Kruegel,
E. Kirda, and G. Vigna. Eﬃcient Detection of Split
Personalities in Malware. In Proceedings of the 17th Annual
Network and Distributed System Security Symposium
(NDSS’10), 2010.
[3] U. Bayer, P. Milani Comparetti, C. Hlauscheck, C. Kruegel,
and E. Kirda. Scalable, Behavior-Based Malware
Clustering. In 16th Symposium on Network and Distributed
System Security (NDSS’09), 2009.
[4] F. Bellard. QEMU: A Fast and Portable Dynamic
Translator. In Proceedings of the USENIX Annual
Technical Conference, FREENIX Track, pages 41–46, 2005.
[12] B. Dolan-Gavitt, A. Srivastava, P. Traynor, and J. Giﬃn.
Robust Signatures for Kernel Data Structures. In
Proceedings of the 16th ACM conference on Computer and
communications security (CCS’09), 2009.
[13] R. Hund, T. Holz, and F. C. Freiling. Return-Oriented
Rootkits: Bypassing Kernel Code Integrity Protection
Mechanisms. In Proceedings for the 18th USENIX Security
Symposium (Security’09), 2009.
[14] C. Kolbitsch, P. Milani Comparetti, C. Kruegel, E. Kirda,
X. Zhou, and X. Wang. Eﬀective and Eﬃcient Malware
Detection at the End Host. In 18th USENIX Security
Symposium (Security’09), 2009.
[15] C. Kruegel, W. Robertson, and G. Vigna. Detecting
Kernel-Level Rootkits Through Binary Analysis. In
Proceedings of the 20th Annual Computer Security
Applications Conference (ACSAC’04), 2004.
[16] Z. Lin, J. Rhee, X. Zhang, D. Xu, and X. Jiang. SigGraph:
Brute Force Scanning of Kernel Data Structure Instances
Using Graph-based Signatures. In Proceedings of the 18th
Annual Network and Distributed System Security
Symposium (NDSS’11), San Diego, CA, February 2011.
[17] N. L. Petroni, T. Fraser, J. Molina, and W. A. Arbaugh.
Copilot - A Coprocessor-based Kernel Runtime Integrity
Monitor. In Proceedings for the 13th USENIX Security
Symposium (Security’04), August 2004.
[18] N. L. Petroni and M. Hicks. Automated Detection of
Persistent Kernel Control-Flow Attacks. In Proceedings of
the 14th ACM Conference on Computer and
Communications Security (CCS’07), 2007.
[19] N. L. Petroni, Jr., T. Fraser, A. Walters, and W. A.
Arbaugh. An Architecture for Speciﬁcation-Based
Detection of Semantic Integrity Violations in Kernel
Dynamic Data. In Proceedings of the 15th conference on
USENIX Security Symposium (Security’06), 2006.
[20] Phrack Magazine. Linux on-the-ﬂy kernel patching without
LKM.
http://www.phrack.com/issues.html?issue=58&id=7.
[21] J. Rhee, R. Riley, D. Xu, and X. Jiang. Kernel Malware
Analysis with Un-tampered and Temporal Views of
Dynamic Kernel Memory. In Proceedings of the 13th
International Symposium of Recent Advances in Intrusion
Detection (RAID’10), Ottawa, Canada, September 2010.
[22] R. Riley, X. Jiang, and D. Xu. Multi-Aspect Proﬁling of
Kernel Rootkit Behavior. In Proceedings of the 4th
European Conference on Computer Systems (Eurosys’09).
[5] S. Bratus, M. E. Locasto, and B. R. Schulte. SegSlice:
[23] R. Riley, X. Jiang, and D. Xu. Guest-Transparent
Towards a New Class of Secure Programming Primitives for
Trustworthy Platforms. In the 3rd International Conference
on Trust and Trustworthy Computing (TRUST’10), 2010.
[6] J. Butler. DKOM (Direct Kernel Object Manipulation).
http://www.blackhat.com/presentations/win-usa-04/
bh-win-04-butler.pdf.
[7] M. Carbone, W. Cui, L. Lu, W. Lee, M. Peinado, and
X. Jiang. Mapping Kernel Objects to Enable Systematic
Integrity Checking. In Proceedings of the 16th ACM
Conference on Computer and Communications Security
(CCS’09), 2009.
[8] M. Christodorescu and S. Jha. Static Analysis of
Executables to Detect Malicious Patterns. In Proceedings of
the 12th USENIX Security Symposium (Security’03).
[9] M. Christodorescu, C. Kruegel, and S. Jha. Mining
Speciﬁcations of Malicious Behavior. In Proceedings of the
6th Joint Meeting of the European Software Engineering
Conference and the ACM SIGSOFT Symposium on the
Foundations of Software Engineering (ESEC/FSE’07).
[10] C. Collberg, C. Thomborson, and D. Low. Manufacturing
Cheap, Resilient, and Stealthy Opaque Constructs. In
Principles of Programming Languages 1998 (POPL’98).
[11] A. Cozzie, F. Stratton, H. Xue, and S. T. King. Digging
For Data Structures. In Proceedings of the 8th USENIX
Symposium on Operating Systems Design and
Implementation (OSDI’08), 2008.
Prevention of Kernel Rootkits with VMM-based Memory
Shadowing. In Proceedings of 11th International
Symposium on Recent Advances in Intrusion Detection
(RAID’08), 2008.
[24] A. Seshadri, M. Luk, N. Qu, and A. Perrig. SecVisor: A
Tiny Hypervisor to Provide Lifetime Kernel Code Integrity
for Commodity OSes. In Proceedings of 21st Symposium on
Operating Systems Principles (SOSP’07). ACM, 2007.
[25] M. Sharif, A. Lanzi, J. Giﬃn, and W. Lee. Impeding
Malware Analysis Using Conditional Code Obfuscation. In
Proceedings of the 15th Annual Network and Distributed
System Security Symposium (NDSS’08), 2009.
[26] C. Wang, J. Hill, J. C. Knight, and J. W. Davidson.
Protection of Software-Based Survivability Mechanisms. In
Proceedings of the 2001 International Conference on
Dependable Systems and Networks (DSN’01), 2001.
[27] C. Xuan, J. A. Copeland, and R. A. Beyah. Toward
Revealing Kernel Malware Behavior in Virtual Execution
Environments. In Proceedings of 12th International
Symposium on Recent Advances in Intrusion Detection
(RAID’09), 2009.