wi ←$ π
(cid:96)1, . . . , (cid:96)B ←$ Batch(wi)
For j in 1 to B:
τB[ j] ← ((cid:96) j, KV(cid:48)[(cid:96) j])
τ[i] ← τB
b←$ A2(KV(cid:48),τ)
Return b
ROR-CDA0A
q :
KV←$ A1
KV(cid:48) ← /0
For i in 1 to n(cid:48):
(cid:96)i ←${0,1}m
vi ←$ C
KV(cid:48) ← KV(cid:48) ∪{((cid:96)i,vi)}
For j in 1 to B:
For i in 1 to q:
(cid:96)←$ Labels(KV(cid:48))
v ← KV(cid:48)[(cid:96)]
τB[ j] ← ((cid:96),v)
τ[i] ← τB
b←$ A2(KV(cid:48),τ)
Return b
Figure 9: Security game for key value store schemes in the static
distribution case. The threshold α is an implicit parameter of the left
game. The procedures Init and Batch are as deﬁned in Figure 2.
We measure the success of an adversary A in attack-
ing EKV by its ability to distinguish between the games
ROR-CDA1 and ROR-CDA0 as deﬁned in Figure 9. The
game ROR-CDA1 is parameterized by the number of queries
q, the true distribution π and the estimated distribution ˆπ. We
also take α as an implicit parameter. The adversary runs and
chooses a plaintext distribution, then Init is executed followed
by a sequence of queries drawn according to π. A transcript
of accesses is generated by Batch. The adversary runs again
with input the encrypted database and transcript. The two
adversary executions can share state.
In game ROR-CDA0, the adversary sees a randomly gen-
erated encrypted database and queries chosen uniformly at
random. The advantage of A with q queries against EKV is
deﬁned as
Advror-cda
EKV (A) = |Pr[ROR-CDA1A
q ⇒ 1]
− Pr[ROR-CDA0A
q ⇒ 1]| .
Next we state a key result, that PANCAKE achieves
ROR-CDA security assuming estimation is sufﬁciently good.
In particular this shows optimal security should ˆπ = π.
Theorem 1 Let q ≥ 0 and Q = q· B. Let π, ˆπ be distributions.
For any q-query ROR-CDA adversary A against PANCAKE
we give adversaries B, C, D such that
Advror-cda
F (B) +Advror
PANCAKE(A) ≤ Advprf
Q,π,ˆπ(D)
where F and E are the PRF and AE scheme used by PANCAKE.
Adversaries B, C, D each use Q queries and run in time that
of A plus a small overhead linear in Q.
E (C) +Advdist
Proof. We prove Theorem 1 using a series of standard
cryptographic game transitions and reductions. We start with
the game ROR-CDA1, replacing Init and Batch with the al-
gorithms used in PANCAKE (see Figure 2). Game G1 is the
(cid:104)
(cid:12)(cid:12)(cid:12)Pr
(cid:104)
(cid:12)(cid:12)(cid:12)Pr
(cid:105)
(cid:105)
(cid:12)(cid:12)(cid:12) ≤ Advprf
F (B) .
same as ROR-CDA1 except we replace the PRF F with a
truly random function. The difference between the success of
adversary A in these two games can be upper bounded by the
advantage of a PRF adversary B:
ROR-CDA1A
q ⇒ 1
− Pr [G1 ⇒ 1 ]
We then move to game G2, which is the same as G1 except
we replace the authenticated encryption function E with a
random function outputting strings in the ciphertext space.
The difference between the success rate of A in G2 and G1 can
be upper bounded by a real-or-random adversary C against
the encryption scheme E:
|Pr [G1 ⇒ 1 ]− Pr [G2 ⇒ 1 ]| ≤ Advror
E (C) .
Finally we let G3 be the same as G2 except that we replace ˆπ
with π everywhere. A straightforward reduction gives that
(cid:12)(cid:12)(cid:12) ≤ Advdist
Q,π,ˆπ(D) .
ROR-CDA1A
q ⇒ 1
− Pr [G1 ⇒ 1 ]
We now come to the core of the argument, that G3 is identi-
cally distributed to ROR-CDA0. In G3 all labels and values
are random strings. Further, each of the accesses is a uni-
formly random choice from all possible labels.
To see this, observe that each access in a batch is inde-
pendent and sampled from π with probability δ or π f with
probability 1− δ. By construction of the scheme as described
in Equation 1, the probability of any replica being accessed is
the same. Let ˆτ be a random variable representing the output
of Batch on input a sample from π, and ˆτi be the ith access in
the output. Then for all i and any replica (k, j)
Pr[ˆτi = (k, j)] = Pr[ˆτi = (k, j) | qtype = 0]· (1− δ)
+ Pr[ˆτi = (k, j) | qtype = 1]· δ
α−
n(cid:48)α− 1 ·
n(cid:48)α− 1
n(cid:48)α +
1
n(cid:48)α =
π(k)
R(k) ·
π(k)
R(k)
=
1
n(cid:48)
.
The theorem follows by the independence of the ˆτi, and com-
(cid:4)
bining terms.
Security analysis for dynamic distributions. Next we ana-
lyze security for dynamic distributions. First we must extend
the formalization of frequency-smoothing KV schemes from
above to account for the extended semantics. Speciﬁcally the
batch algorithm Batch can now take an optional additional
input ˆπ(cid:48), representing an updated distribution estimate. This
signals to Batch that it must adjust to the new distribution.
We denote running Batch as before when given this addi-
tional input by (cid:96)1, . . . , (cid:96)B ←$ Batch(ˆπ(cid:48),k). Recall that Batch
is stateful and so when it gets a new estimate ˆπ(cid:48), it also has
access to the old estimate ˆπ as well as other state values. For
PANCAKE, the Batch algorithm would use this information
to run MakeReplicaLists and to setup its replica bookkeeping
(refer to the full version for more detail). We now introduce
USENIX Association
29th USENIX Security Symposium    2467
q,π,π(cid:48),ˆπ,ˆπ(cid:48) :
ROR-CDDA1A
(KV,c)←$ A1
(KV(cid:48),π f ,δ)←$ Init(ˆπ, KV,α)
For i in 1 to c:
wi ←$ π
(cid:96)1, . . . , (cid:96)B ←$ Batch(wi)
For j in 1 to B:
τB[ j] ← ((cid:96) j, KV(cid:48)[(cid:96) j])
τ[i] ← τB
For i in c to q:
wi ←$ π(cid:48)
(cid:96)1, . . . , (cid:96)B ←$ Batch(ˆπ(cid:48),wi)
For j in 1 to B:
τB[ j] ← ((cid:96) j, KV(cid:48)[(cid:96) j])
τ[i] ← τB
b←$ A2(KV(cid:48),τ)
Return b
ROR-CDDA0A
q :
(KV,c)←$ A1
n ← supp(π)
KV(cid:48) ← /0 ; KV(cid:48)(cid:48) ← /0
For i in 1 to n(cid:48):
(cid:96)i ←${0,1}m
vi ←$ C
KV(cid:48) ← KV(cid:48) ∪{((cid:96)i,vi)}
For j in 1 to B:
τB[ j]←$ Labels(KV(cid:48))
τ[i] ← τB
b←$ A2(KV(cid:48),τ)
Return b
For i in 1 to q:
Figure 10: Security games for dynamic key value store schemes. The
threshold α is an implicit parameter of the left game.
a security deﬁnition ROR-CDDA or, real-or-random indistin-
guishability under chosen-dynamic-distribution attack. Game
ROR-CDDA1 is now parameterized by the query number and
four distributions π, ˆπ,π(cid:48), ˆπ(cid:48). The adversary runs and can pick
both a plaintext KV store and a change point c ∈ [0,q]. After
the ﬁrst c queries, keys switch from being sampled accord-
ing to π to being sampled according to π(cid:48) and Batch is run
with the additional input ˆπ(cid:48). The ROR-CDDA0 is the same as
ROR-CDA0 except for the syntactic change that A1 outputs
the additional value c. Otherwise the distribution over KV(cid:48) (a
KV store of uniform bit strings) and τ (qB uniform requests)
are the same as before.
The ROR-CDDA advantage of an adversary A against a
scheme EKV is deﬁned as
(cid:104)
(cid:12)(cid:12)(cid:12)Pr
(cid:104)
(cid:105)
(cid:105)(cid:12)(cid:12)(cid:12) .
q,π,π(cid:48),ˆπ,ˆπ(cid:48) ⇒ 1
q ⇒ 1
− Pr
ROR-CDDA0A
Advror-cdda
EKV
(A) =
ROR-CDDA1A
One could easily extend this deﬁnition to handle a longer
sequence of changes: our results extend to this setting as well.
We note that the deﬁnition also implies that the transcript
of queries is indistinguishable from one that is independent
of the change point, meaning this information is hidden by
schemes that meet the deﬁnition.
We now prove the following theorem about the dynamic
version of PANCAKE.
Theorem 2 Let q ≥ 0 and Q = q· B. Let π,π(cid:48), ˆπ, ˆπ(cid:48) be distri-
butions. For any q-query ROR-CDDA adversary A against
PANCAKE we give adversaries B, C, D1, D2 such that
Advror-cdda
PANCAKE(A) ≤ Advprf
F (B) + Advror
+ Advdist
E (C)
Q,π(cid:48),ˆπ(cid:48)(D2)
where F and E are the PRF and AE scheme used by PANCAKE.
Adversaries B, C, D1, D2 each use at most Q queries and run
in time that of A plus a small overhead linear in Q.
Q,π,ˆπ(D1) + Advdist
Proof. Similar to the proof of Theorem 1 above, we use
game hops to replace the PRF labels and AE ciphertexts with
random strings, and upper-bound the difference in advantage
via the PRF and AE adversaries B and C. We also replace
ˆπ with π and ˆπ(cid:48) with π(cid:48) in game hops whose difference is
upper bounded by the appropriate reductions to distinguishers
D1 and D2. This brings us to a game G where labels and ci-
phertexts are random strings, but batches are generated using
Batch with π on input samples from π (before the change) or
with π(cid:48) on input samples from π(cid:48) (after the change).
We claim that the distribution of accesses in game G is
uniformly random, the same as in ROR-CDDA0. Because the
keys accessed in a batch are independent, it sufﬁces to show a
single access of a batch is uniform. Let ˆτi be the ith access of
a batch generated by a query sampled from π(cid:48). Let (k, j) be
any replica. Then to compute Pr[ˆτi = (k, j)], there are a few
cases. First recall that,
Pr[ˆτi = (k, j)] = Pr[ˆτi = (k, j) | qtype = 0]Pr[qtype = 0]
+ Pr[ˆτi = (k, j) | qtype = 1]Pr[qtype = 1]
where qtype = 0 means a fake query and qtype = 1 means a
real query. There are three possible cases:
Case 1: k gained replicas and j is one of its existing replicas.
Then the RHS above is equal to:
(cid:19)
(cid:18)
1−
α(cid:48) − π(cid:48)(k)/R(k)
2nα(cid:48) − 1
1
2nα(cid:48)
+
π(cid:48)(k)
R(k) ·
1
2nα(cid:48)
=
1
2n
Case 2: (k, j) ∈ G. Then,
α(cid:48)
Pr[ˆτi = (k, j)] =
2nα(cid:48) − 1 ·
2nα(cid:48) − 1
2nα(cid:48)
=
α(cid:48)
2nα(cid:48)
=
1
2n .
Case 3: (k, j) is either in L or is any other replica. In this case,
(cid:4)
Pr[ˆτi = (k, j)] = 1/2n follows from Eq. 1.
2468    29th USENIX Security Symposium
USENIX Association