of band. In other words, it has to be established with a prior agreement between two 
parties. In most scenarios, trust between different entities is established through X.509 
certificates. Let’s walk through a sample brokered authentication use case.
Going back to OAuth principles, you need to deal with four entities in a federation 
scenario: the resource owner, the resource server, the authorization server, and the client 
application. All these entities can reside in the same domain or in different ones.
Let’s start with the simplest scenario first. The resource owner (user), resource 
server (API gateway), and authorization server are in a single domain, and the client 
application (web app) is in a different domain. For example, you’re an employee of Foo 
Inc. and want to access a web application hosted by Bar Inc. (see Figure 12-1). Once you 
log in to a web application at Bar Inc., it needs to access an API hosted in Foo Inc. on 
your behalf. Using OAuth terminology, you’re the resource owner, and the API is hosted 
in the resource server. Both you and API are from the Foo domain. The web application 
hosted by Bar Inc. is the OAuth client application.
Figure 12-1 illustrates how brokered authentication works for an OAuth client 
application.
• 
The resource owner (user) from Foo Inc. visits the web application at 
Bar Inc. (step 1).
• 
To authenticate the user, the web application redirects the user 
to the OAuth authorization server at Foo Inc., which is also the 
home domain of the resource owner (step 2). To use the OAuth 
authorization code grant type, the web application also needs to 
pass its client ID along with the authorization code grant request 
during the redirection. At this time, the authorization server won’t 
authenticate the client application but only validates its existence. 
In a federation scenario, the authorization server does not need to 
trust each and every individual application (or OAuth client); rather, 
it trusts the corresponding domain. The authorization server accepts 
authorization grant requests from any client that belongs to a trusted 
domain. This also avoids the cost of client registration. You don’t 
need to register each client application from Bar Inc.—instead, you 
can build a trust relationship between the authorization server from 
Chapter 12  Federating aCCess to apis
260
Foo Inc. and the trust broker from Bar Inc. During the authorization 
code grant phase, the authorization server only needs to record the 
client ID. It doesn’t need to validate the client’s existence.
Note the oauth client identifier (id) isn’t treated as a secret. it’s publicly visible 
to anyone.
• 
Once the client application gets the authorization code from the 
authorization server (step 3), the next step is to exchange it for a valid 
access token. This step requires client authentication.
• 
Because the authorization server doesn’t trust each individual 
application, the web application must first authenticate to its own 
trust broker in its own domain (step 4) and get a signed assertion 
(step 5). This signed assertion can be used as a token of proof against 
the authorization server in Foo Inc.
• 
The authorization server validates the signature of the assertion and, 
if it’s signed by an entity it trusts, returns the corresponding access 
token to the client application (steps 6 and 7).
• 
The client application can use the access token to access the APIs in 
Foo Inc. on behalf of the resource owner (step 8), or it can talk to a 
user endpoint at Foo Inc. to get more information about the user.
Note the definition of assertion, according to the oxford english dictionary, 
is “a confident and forceful statement of fact or belief.” the fact or belief here 
is that the entity that brings this assertion is an authenticated entity at the trust 
broker. if the assertion isn’t signed, anyone in the middle can alter it. once the 
trust broker (or the asserting party) signs the assertion with its private key, no 
one in the middle can alter it. if it’s altered, any alterations can be detected at the 
authorization server during signature validation. the signature is validated using 
the corresponding public key of the trust broker.
Chapter 12  Federating aCCess to apis
261
 Security Assertion Markup Language (SAML)
Security Assertion Markup Language (SAML) is an OASIS standard for exchanging 
authentication, authorization, and identity-related data between interested parties 
in an XML-based data format. SAML 1.0 was adopted as an OASIS standard in 2002, 
and in 2003 SAML 1.1 was ratified as an OASIS standard. At the same time, the Liberty 
Alliance donated its Identity Federation Framework to OASIS. SAML 2.0 became an 
OASIS standard in 2005 by converging SAML 1.1, Liberty Alliance’s Identity Federation 
Framework, and Shibboleth 1.3. SAML 2.0 has four basic elements:
• 
Assertions: Authentication, Authorization, and Attribute 
assertions.
• 
Protocol: Request and Response elements to package SAML 
assertions.
• 
Bindings: How to transfer SAML messages between interested 
parties. HTTP binding and SOAP binding are two examples. If the 
trust broker uses a SOAP message to transfer a SAML assertion, then 
it has to use the SOAP binding for SAML.
• 
Profiles: How to aggregate the assertions, protocol, and bindings to 
address a specific use case. A SAML 2.0 Web Single Sign-On (SSO) 
profile defines a standard way to establish SSO between different 
service providers via SAML.
Note the blog post at http://blog.facilelogin.com/2011/11/depth-
of- saml-saml-summary.html provides a high-level overview of saML.
 SAML 2.0 Client Authentication
To achieve client authentication with the SAML 2.0 profile for OAuth 2.0, you can use the 
parameter client_assertion_type with the value urn:ietf:params:oauth:client- 
assertion- type:saml2-bearer in the access token request (see step 6 in Figure 12-1). 
The OAuth flow starts from step 2.
Chapter 12  Federating aCCess to apis
262
Now let’s dig into each step. The following shows a sample authorization code grant 
request initiated by the web application at Bar Inc.:
GET /authorize?response_type=code
               &client_id=wiuo879hkjhkjhk3232
               &state=xyz
               &redirect_uri=https://bar.com/cb
HTTP/1.1
Host: auth.foo.com
This results in the following response, which includes the requested authorization 
code:
HTTP/1.1 302 Found
Location: https://bar.com/cb?code=SplwqeZQwqwKJjklje&state=xyz
So far it’s the normal OAuth authorization code flow. Now the web application has to 
talk to the trust broker in its own domain to obtain a SAML assertion. This step is outside 
the scope of OAuth. Because this is machine-to-machine authentication (from the web 
application to the trust broker), you can use a SOAP-based WS-Trust protocol to obtain 
the SAML assertion or any other protocol like OAuth 2.0 Token Delegation profile, which 
we discussed in Chapter 9. The web application does not need to do this each time a 
user logs in; it can be one-time operation that is governed by the lifetime of the SAML 
assertion. The following is a sample SAML assertion obtained from the trust broker:
       bar.com
              18982198kjk2121
Chapter 12  Federating aCCess to apis
263
                      https://foo.com/oauth2/token
                    urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified
To use this SAML assertion in an OAuth flow to authenticate the client, it must 
adhere to the following rules:
• 
The assertion must have a unique identifier for the Issuer element, 
which identifies the token-issuing entity. In this case, the broker of 
the Bar Inc.
• 
The assertion must have a NameID element inside the Subject 
element that uniquely identifies the client application (web app). 
This is treated as the client ID of the client application at the 
authorization server.
• 
The SubjectConfirmation method must be set to urn:oasis:names:
tc:SAML:2.0:cm:bearer.
• 
If the assertion issuer authenticates the client, then the assertion 
must have a single AuthnStatement.
Chapter 12  Federating aCCess to apis
264
Note Ws-trust is an oasis standard for soap message security. Ws-trust, which 
is built on top of the Ws-security standard, defines a protocol to exchange identity 
information that is wrapped in a token (saML), between two trust domains. the 
blog post at http://blog.facilelogin.com/2010/05/ws-trust-with- 
fresh-banana-service.html explains Ws-trust at a high level. the latest 
Ws-trust specification is available at http://docs.oasis-open.org/ws-sx/
ws-trust/v1.4/errata01/ws-trust-1.4-errata01-complete.html.
Once the client web application gets the SAML assertion from the trust broker, it has 
to base64url-encode the assertion and send it to the authorization server along with the 
access token request. In the following sample HTTP POST message, client_assertion_
type is set to urn:ietf:params:oauth:client-assertion-type:saml2-bearer, and the 
base64url-encoded (see Appendix E) SAML assertion is set to the client_assertion 
parameter:
POST /token HTTP/1.1
Host: auth.foo.com
Content-Type: application/x-www-form-urlencoded
grant_type=authorization_code&code=SplwqeZQwqwKJjklje
&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:saml2- 
bearer
&client_assertion=HdsjkkbKLew...[omitted for brevity]...OT
Once the authorization server receives the access token request, it validates the 
SAML assertion. If it’s valid (signed by a trusted party), an access token is issued, along 
with a refresh token.
 SAML Grant Type for OAuth 2.0
The previous section explained how to use a SAML assertion to authenticate a client 
application. That is one federation use case that falls under the context of OAuth. There the 
trust broker was running inside Bar Inc., where the client application was running. Let’s 
consider a use case where the resource server (API), the authorization server, and the client 
application run in the same domain (Bar Inc.), while the user is from an outside domain 
(Foo Inc.). Here the end user authenticates to the web application with a SAML assertion 
Chapter 12  Federating aCCess to apis
265
(see Figure 12-2). A trust broker (a SAML identity provider) in the user’s domain issues this 
assertion. The client application uses this assertion to talk to the local authorization server 
to obtain an access token to access an API on behalf of the logged-in user.
Figure 12-2. Brokered authentication with the SAML grant type for OAuth 2.0
Figure 12-2 illustrates how brokered authentication with a SAML grant type for 
OAuth 2.0 works.
• 
The first three steps are outside the scope of OAuth. The resource 
owner first logs in to the web application owned by Bar Inc. via SAML 
2.0 Web SSO.
• 
The SAML 2.0 Web SSO flow is initiated by the web application by 
redirecting the user to the SAML identity provider at Foo Inc. (step 2).
• 
Once the user authenticates to the SAML identity provider, the 
SAML identity provider creates a SAML response (which wraps the 
assertion) and sends it back to the web application (step 3). The web 
application validates the signature in the SAML assertion and, if a 
trusted identity provider signs it, allows the user to log in to the web 
application.
Chapter 12  Federating aCCess to apis
266
• 
Once the user logs in to the web application, the web application has 
to exchange the SAML assertion for an access token by talking to its 
own internal authorization server (steps 4 and 5). The way to do this 
is defined in the SAML 2.0 Profile for OAuth 2.0 Client Authentication 
and Authorization Grants specification (RFC 7522).
The following is a sample POST message from the web application to the 
authorization server. There the value of grant_type must be urn:ietf:params:oauth: 
grant-type:saml2-bearer, and the base64url-encoded SAML assertion is set as the 
value of the assertion parameter:
Note no refresh tokens are issued under the saML Bearer grant type. the 
lifetime of the access token should not exceed the lifetime of the saML bearer 
assertion by a significant amount.
POST /token HTTP/1.1
Host: auth.bar.com
Content-Type: application/x-www-form-urlencoded
grant_type=urn:ietf:params:oauth:grant-type:saml2-bearer
&assertion=QBNhbWxwOl...[omitted for brevity]...OT4
This request is validated at the authorization server. The SAML assertion is 
once again validated via its signature; and, if a trusted identity provider signs it, the 
authorization server issues a valid access token.
The scope of the access token issued under the SAML Bearer grant type should be set 
out of band by the resource owner. Out of band here indicates that the resource owner 
makes a pre-agreement with the resource server/authorization server with respect to 
the scope associated with a given resource when the SAML grant type is being used. The 
client application can include a scope parameter in the authorization grant request, but 
the value of the scope parameter must be a subset of the scope defined out of band by 
the resource owner. If no scope parameter is included in the authorization grant request, 
then the access token inherits the scope set out of band.
Both federation use cases discussed assume that the resource server and the 
authorization server are running in the same domain. If that isn’t the case, the resource 
server must invoke an API exposed by the authorization server to validate the access 
Chapter 12  Federating aCCess to apis
267
token at the time the client tries to access a resource. If the authorization server supports 
the OAuth Introspection specification (discussed in Chapter 9), the resource server can 
talk to the introspection endpoint and find out whether the token is active or not and 
also what scopes are associated with the token. The resource server can then check 
whether the token has the required set of scopes to access the resource.
 JWT Grant Type for OAuth 2.0
The JSON Web Token (JWT) profile for OAuth 2.0, which is defined in the RFC 7523, 
extends the OAuth 2.0 core specification by defining its own authorization grant type and 
a client authentication mechanism. An authorization grant in OAuth 2.0 is an abstract 
representation of the temporary credentials granted to the OAuth 2.0 client by the 
resource owner to access a resource. The OAuth 2.0 core specification defines four grant 
types: authorization code, implicit, resource owner password, and client credentials. 
Each of these grant types defines in a unique way how the resource owner can grant 
delegated access to a resource he/she owns to an OAuth 2.0 client. The JWT grant type, 
which we discuss in this chapter, defines how to exchange a JWT for an OAuth 2.0 access 
token. In addition to the JWT grant type, the RFC 7523 also defines a way to authenticate 
an OAuth 2.0 client in its interactions with an OAuth 2.0 authorization server. OAuth 
2.0 does not define a concrete way for client authentication, even though in most of the 
cases it’s the HTTP Basic authentication with client id and the client secret. The RFC 
7523 defines a way to authenticate an OAuth 2.0 client using a JWT.
The JWT authorization grant type assumes that the client is in possession 
with a JWT. This JWT can be a self-issued JWT or a JWT obtained from an identity 
provider. Based on who signs the JWT, one can differentiate a self-issued JWT from 
an identity provider–issued JWT. The client itself signs a self-issued JWT, while an 
identity provider signs the identity provider–issued JWT. In either case, the OAuth 
authorization server must trust the issuer of the JWT. The following shows a sample 
JWT authorization grant request, where the value of the grant_type parameter is set to 
urn:ietf:params:oauth:grant-type:jwt-bearer.
POST /token HTTP/1.1
Host: auth.bar.com
Content-Type: application/x-www-form-urlencoded
Chapter 12  Federating aCCess to apis
268
grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=
eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.
eyJpc3Mi[...omitted for brevity...].
J9l-ZhwP[...omitted for brevity...]
The Assertion Framework for OAuth 2.0 Client Authentication and Authorization 
Grants specification, which is the RFC 7521, defines the parameters in the JWT 