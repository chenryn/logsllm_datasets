service needed
IRequest
RResponse
IResponse
Result Container
Message
Protocol Result
Constituent Data
PSI type, hop length,
number of friends
supported algorithms, P KI
accepted type, P KR,
PSI protocol speciﬁc payload (RDC)
PSI protocol speciﬁc payload (IDC)
PSI state machine status,
optionally M to send
PSI variant speciﬁc content
PSI ﬁnal result, secret key KIR
Table 5: Parameters in the Common Friends service interface.
(3) do not need to refactor their code if a new PSI or PSI-CA
technique (perhaps more efﬁcient or relying on different as-
sumptions) becomes available, but only update the Common
Friends library.
Framework Description. Fig. 4 illustrates how applications can
use the Common Friends service. Tables 4 and 5 summarize the
details of employed methods and containers. To use the Common
Friends service, application instances on a responder device R and
a initiator device I ﬁrst set up a communication channel between
them. Before starting a PSI instance, I sends a request IReq to R
consisting of (a) I’s Difﬁe-Hellman Public Key P KI and (b) the
type of protocol I wants to run. Currently, we support two different
types: a protocol that only outputs the cardinality of the intersec-
tion, i.e., PSI-CA, and one protocol that outputs the actual intersec-
tion set i.e., BFPSI (for improved efﬁciency compared to traditional
PSI).
R’s application instance can choose to accept or reject the pro-
posed protocol type and send a notiﬁcation to I in either case. On
accept, it starts a protocol run by invoking the StartResponder, with
IReq as an argument. This method performs the ﬁrst step of the PSI
protocol which returns a response in the form of an RRes message.
R sends RRes to I, which starts its Common Friends service engine.
This returns an IRes message that is transported back to R. R in-
vokes the Process method with IRes as the parameter which returns
a ResultContainer object which contains a status ﬁeld that can take
one of two values: done or wait, and an optional message M.
The three protocol messages (IReq, RRes, IRes) are mandatory
for all PSI schemes. Some PSI protocols (e.g., PSI-CA in [14])
contain only three ﬂows. They can be acommodated using the
three messages. Others (e.g., BFPSI) may need more message ex-
changes. To accommodate this variation, Common Friends frame-
work allows the possibility of an optional phase that can be repeated
as many times as needed by the PSI protocol being used.
The application instances determine whether to carry out these
optional exchanges by examining ResultContainer returned by the
PSI protocol engine and performing the following operations:
• If it contains a message M then transfer M to peer.
• If its status component is wait, wait for peer to respond. Oth-
erwise (status is done), call getResult to extract PSI result.
While the optional phase is being executed, the application instances
simply act as conduits for their respective PSI protocol engines to
communicate with each other. Depending on the type of PSI, the
result of PSI may be empty for the initiator. As mentioned before,
KIR can be used for subsequent access control.
Plugging in Bloom ﬁlter based PSI. To plug the BFPSI protocol
(described in Sec. 2.4) into the Common Friends service, we need
to provide BFPSI-speciﬁc implementations of each of the methods
identiﬁed in Table 4. Constructing the Bloom ﬁlter BFI and test-
ing whether elements of RR are present in BFI are implemented
within the StartInitiator and StartResponder methods, respectively.
The creation of the challenge set (to eliminate false positives) is im-
plemented in the Process method on R and the corresponding cre-
ation of the response set is implemented in the ProcessContainer
method on I. The ProcessContainer method on R processes the re-
sponse set and populates the intersection.
4.
IMPLEMENTATION
We now present the implementation of Common Friends on An-
droid, and its integration with an existing tethering application from
our prior work [5].
Framework. We implemented Common Friends (Sec. 3) as a simple
Android service that exposes its interface to third party applications
via Android Interface Deﬁnition Language (AIDL) declarations.
Communication between the service and application uses Android
speciﬁc AIDL interface. (However, the core service is implemented
in standard Java, thus, could be executed on any device equipped
with a Java Virtual Machine). The application instances on I and R
are responsible for setting up a communication channel to exchange
the protocol messages received from the Common Friends Service.
Protocol messages are containers implemented as Parcelable and
Serializable Android classes, and are opaque to the calling applic-
ations. Application instance on R chooses the protocol variant to
use. Currently our implementation supports PSI-CA and BFPSI,
implemented as plugins in Common Friends framework.
165
Developers can embed the Common Friends functionality into
their applications by simply adding the Common Friends Service
AIDL interface declaration to their application source tree, together
with the container classes. The framework can also be extended
with additional PSI protocol engines: abstract class AlgorithmEn-
gine provides basic primitives (methods: StartResponder, StartIni-
tiator, Process, and optionally ProcessContainer) for future exten-
sions with new PSI protocols.
PSI-CA. We implemented the PSI-CA protocol proposed in [14],
using the standard Android cryptography provider (Bouncy Castle).
We used Elliptic Curve Difﬁe-Hellman (ECDH), based on the NIST
P-192 curve [44], to implement both the Difﬁe-Hellman key agree-
ment (needed for integrating PSI-CA into the Common Friends ser-
vice) and the modular arithmetic operations within the PSI-CA pro-
tocol [14].
Bloom Filter based PSI (BFPSI). To implement the BFPSI pro-
toocol (see Sec. 2.4) we selected a ﬁxed false positive probability of
−4, and used Bloom ﬁlter with length calculated according
p = 10
to Equation 1. Difﬁe-Hellman key exchange was as in the case of
PSI-CA. We used HMAC-SHA-1 to instantiate HMAC and SHA-
1 for KDF(·,·). Bloom ﬁlter operations were implemented using
code available from https://github.com/MagnusS/Java-BloomFilter with
SHA-1 as the underlying hash function.
Tethering Application. To demonstrate the applicability of our
techniques to real-world scenarios where access control decisions
are securely made based on the existence of common friends, we
also extended an application for tethering (proposed in our prior
work [5]) by integrating it with our Common Friends service.
The application allows a device to either act as a WiFi tethering
access point, or as a WiFi tethering client. We extend the applic-
ation by allowing a user to choose whether or not to authorize an-
other user to connect to his access point based on whether or not
the two are friends on a given social network or have some common
friends. The device acting as access point is turned into a “hotspot”
using the Android WiFi Manager API, and plays the role of R. It
also opens a Bluetooth socket to listen for incoming tethering re-
quests. Our tethering service is advertised by a speciﬁc Universal
Unique Identiﬁer (UUID), which is used in the service discovery.
The device acting as a tethering client plays the role of I, and ini-
tiates Bluetooth service discovery procedure looking for a suitable
WiFi tethering access point. On successful discovery, both applica-
tions establish a Bluetooth connection in RFCOMM mode and run
BFPSI or PSI-CA to learn which or how many friends are common.
Based on gathered information, R decides whether or not to send
the WiFi SSID and password to I over the secure channel (using the
previously established Difﬁe-Hellman shared key KIR).
Code Availability: Source code of our implementations can be
made available for research use upon request.
5. PERFORMANCE ANALYSIS
This section present an empirical evaluation of the performance
of Common Friends service when using PSI-CA [14] vs. BFPSI
(Sec 2.4). Speciﬁcally, we analyze the computational, communica-
tion and energy consumption costs incurred by them.
Computation and Communication Overhead. To measure run-
ning times and bandwidth overhead, we performed experiments
(over 30 trials) on a Samsung Galaxy Nexus smartphone running
Android 4.2 API 17 and a Samsung Galaxy Tablet GT-P3100 run-
ning Android 4.1.2 API 16, connected over Bluetooth.
Input size
100
200
300
400
500
BFPSI
Comm. [s]
std
avg
0.649
0.061
0.049
0.646
0.086
0.72
0.066
0.811
0.816
0.085
Comp. [s]
std
avg
0.652
0.061
0.062
1.047
0.088
1.33
0.056
1.597
1.968
0.099
PSI-CA
Comm. [s]
std
avg
3.053
0.089
0.373
5.307
0.212
7.904
0.16
10.099
12.543
0.176
Comp. [s]
std
avg
2.999
0.24
0.358
6.401
0.195
13.438
0.799
20.709
26.535
0.69
Table 6: Average values and standard deviations of computa-
tion and communication time (in seconds) for one BFPSI and
PSI-CA protocol transaction for various input set sizes.
Input size
100
200
300
400
500
BFPSI
2,548
3,424
4,292
5,168
6,036
PSI-CA
34,833
67,933
100,399
133,222
166,029
Table 7: Total number of bytes exchanged in a protocol run for
increasingly large sets.
We made the assumption that both parties have the same number
of friends and varied this number in the range {100, 200, 300, 400,
500}. The intersection of the sets was always at 10% of the set size.
Processing time. Total average execution time increases linearly
for both protocols as expected, but at different rates (Fig. 7). In par-
ticular, Table 6 shows that, with 5-fold increases in set sizes, com-
putation time for PSI-CA increases by several seconds, whereas,
with BFPSI it increases by less than half a second.
Communication bandwidth. As shown in Table 7, the total num-
ber of bytes exchanged also increases linearly for both protocols.
However, the amount of data exchange is signiﬁcantly larger for
PSI-CA, by a factor of almost 6 compared to BFPSI.
Power Analysis.
It is well-known that energy consumption for
sending/receiving a message increases with the message size [46,
49]. As a result, the use of BFPSI protocol can have a lower im-
pact on battery life, which is crucial for mobile users. To study
this aspect, we performed a power analysis of the Common Friends
service with input sets of 200 items, using two Samsung Nexus
S devices running the CyanogenMod 9.1.0-crespo Android release
and a laptop running a power analysis tool for Android devices
called Little Eye.1 Currently, the tool is optimized for precise power
analysis measurements only on certain device models, but it can be
used for rough estimates on others as well. (In general, power ana-
lysis on mobile devices at the granularity of applications is known
to be a challenging problem [49], however, our estimates sufﬁce to
provide an intuition of power requirements for continuous execu-
tions of the Common Friends service.)
Fig. 5 and Fig. 6 show power diagrams for BFPSI and PSI-
CA protocols respectively, when executed 5 times (x-axis shows
elapsed time and the peaks correspond to the ﬁve executions). We
also calculated overall energy consumed by Common Friends dur-
ing each test. Measurements include CPU power and communica-
tion, but exclude power consumed by the device screen. According
to our measurements, BFPSI execution required 0.18 mAh, while
PSI-CA utilized 0.55 mAh, thus indicating that BFPSI protocol
consumes approximately 3 times less energy than PSI-CA.
To conﬁrm that observed differences are not induced by the power
consumption characteristics of the device model we used, we re-
1http://www.littleeye.co/
(cid:1)
(cid:1)
(cid:23)
(cid:14)
(cid:22)
(cid:1)
(cid:5)
(cid:9)
(cid:16)
(cid:10)
(cid:11)
(cid:16)
(cid:18)
(cid:4)
(cid:5)
(cid:19)
(cid:5)
(cid:1)
(cid:8)
(cid:11)
(cid:4)
(cid:11)
(cid:15)
(cid:11)
(cid:13)
(cid:2)
(cid:26)(cid:27)(cid:1)
(cid:26)(cid:22)(cid:1)
(cid:25)(cid:27)(cid:1)