title:The Next 700 Policy Miners: A Universal Method for Building Policy
Miners
author:Carlos Cotrini and
Luca Corinzia and
Thilo Weghorn and
David A. Basin
The Next 700 Policy Miners: A Universal Method for Building
Policy Miners
Carlos Cotrini
Department of computer science
ETH Zürich
PI:EMAIL
Thilo Weghorn
Department of computer science
ETH Zürich
PI:EMAIL
Luca Corinzia
Department of computer science
ETH Zürich
PI:EMAIL
David Basin
Department of computer science
ETH Zürich
PI:EMAIL
ABSTRACT
A myriad of access control policy languages have been and continue
to be proposed. The design of policy miners for each such language
is a challenging task that has required specialized machine learning
and combinatorial algorithms. We present an alternative method,
universal access control policy mining (Unicorn). We show how
this method streamlines the design of policy miners for a wide
variety of policy languages including ABAC, RBAC, RBAC with
user-attribute constraints, RBAC with spatio-temporal constraints,
and an expressive fragment of XACML. For the latter two, there
were no known policy miners until now.
To design a policy miner using Unicorn, one needs a policy lan-
guage and a metric quantifying how well a policy fits an assignment
of permissions to users. From these, one builds the policy miner as a
search algorithm that computes a policy that best fits the given per-
mission assignment. We experimentally evaluate the policy miners
built with Unicorn on logs from Amazon and access control ma-
trices from other companies. Despite the genericity of our method,
our policy miners are competitive with and sometimes even better
than specialized state-of-the-art policy miners. The true positive
rates of policies we mined differ by only 5% from the policies mined
by the state of the art and the false positive rates are always below
5%. In the case of ABAC, it even outperforms the state of the art.
CCS CONCEPTS
• Computing methodologies → Supervised learning by clas-
sification; • Security and privacy → Access control.
KEYWORDS
access control; policy mining; security policies; machine learning
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’19, November 11–15, 2019, London, United Kingdom
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-6747-9/19/11...$15.00
https://doi.org/10.1145/3319535.3354196
ACM Reference Format:
Carlos Cotrini, Luca Corinzia, Thilo Weghorn, and David Basin. 2019. The
Next 700 Policy Miners: A Universal Method for Building Policy Miners. In
2019 ACM SIGSAC Conference on Computer and Communications Security
(CCS ’19), November 11–15, 2019, London, United Kingdom. ACM, New York,
NY, USA, 18 pages. https://doi.org/10.1145/3319535.3354196
1 INTRODUCTION
1.1 Motivation and research problem
Numerous access control policy languages have been proposed
over the last decades, e.g., RBAC (Role-Based Access Control) [26],
ABAC (Attribute-Based Access Control) [37], XACML (eXtended
Access-Control Markup Language) [34], and new proposals are
continually being developed, e.g., [7, 10, 16, 57, 78]. To facilitate
the policy specification and maintenance process, policy miners
have been proposed, e.g., [12, 18, 31, 33, 43, 52, 56, 77]. These are
algorithms that receive an assignment of permissions to users and
output a policy that grants permissions to users that match as
closely as possible the given assignment.
Designing a policy miner is challenging and requires sophisti-
cated combinatorial or machine-learning techniques. Moreover, pol-
icy miners are tailor-made for the specific policy language they were
designed for and they are inflexible in that any modification to the
miner’s requirements necessitates its redesign and reimplementa-
tion. For example, miners that mine RBAC policies from access con-
trol matrices [31] are substantially different from those that mine
RBAC policies from access logs [56]. As evidence for the difficulty of
this task, despite extensive work in policy mining, no miner exists
for XACML [34], which is a well-known, standardized language.
Any organization that wishes to benefit from policy mining faces
the challenge of designing a policy miner that fits its own policy
language and its own requirements. This problem, which we exam-
ine in Section 3, is summarized with the following question: is there
a more general and more practical method to design policy miners?
1.2 Contribution
We propose a radical shift in the way policy miners are built. Rather
than designing specialized mining algorithms, one per policy lan-
guage, we propose Unicorn, a universal method for building policy
miners. Using this method, the designers of policy miners no longer
must be experts in machine learning or combinatorial optimization
Session 1D: ForensicsCCS ’19, November 11–15, 2019, London, United Kingdom95Figure 1: Workflow for designing a policy miner using Unicorn.
to design effective policy miners. Our method gives a step-by-step
procedure to build a policy miner from just the policy language
and an objective function that measures how well a policy fits an
assignment of permissions to users.
Let Γ be a policy language. We sketch below and in Figure 1 the
workflow for designing a policy miner for Γ using Unicorn.
Policy language and objective function (Sections 4 and 5). The
miner designer specifies a template formula for Γ in a fragment L
of first-order logic. Template formulas are explained in Section 4.
The designer also specifies an objective function L that measures
how well a policy fits a permission assignment.
Probability distribution (Section 5). From φ and L, we define a
probability distribution P on policies, conditioned on permission
assignments. A permission assignment is a relation between the set
of users and the set of permissions. The policy miner is a program
that receives as input a permission assignment Auth and aims to
compute the most likely policy conditioned on Auth; that is, the
policy I that maximizes P (I | Auth).
Approximation (Section 6). Computing maxI P (I | Auth) takes
time exponential in the size of Auth and I, encoded as strings.
Moreover, the function P (I | Auth) has many local maxima. Hence,
we use deterministic annealing and mean-field approximation [9,
11, 61, 62] to derive an iterative procedure that computes a distri-
bution q on policies that approximates P (I | Auth). Computing
arg maxI q (I) takes time polynomial in the size of Auth and I.
Implementation (Section 7). The policy miner is a procedure that
computes and maximizes q. One need not understand mean-field
approximations or deterministic annealing to implement the policy
miner. We provide a set of rewriting rules and pseudocode that
guide step by step q’s computation and maximization (see Algo-
rithm 1 and Lemma 2).
In summary, designing a policy miner for a policy language pre-
viously required expertise in machine learning and combinatorial
algorithms. Unicorn reduces this to the task of specifying a tem-
plate formula and implementing q’s maximization. We illustrate
how specifying template formulas requires only the background
in first-order logic provided in this paper and how it amounts to
just formalizing the language’s semantics in first order logic, a task
that is substantially simpler than designing a machine-learning or
a combinatorial algorithm.
1.3 Applications and evaluation
Using Unicorn, we have built miners for different policy languages
like RBAC, ABAC, and RBAC with user attributes. Furthermore, we
have built policy miners for RBAC with spatio-temporal constraints
and an expressive fragment of XACML, for which no miner existed
before. We present them in Sections 8 and 9 and in the appendix.
In Section 10, we conduct an extensive experimental evaluation
using datasets from all publicly available real-world case studies
on policy mining. We compare the miners we built with state-of-
the-art miners on both real-world and synthetic datasets. The true
positive rates of the policies mined by our miners are within 5% of
the true positive rates of the policies mined by the state of the art.
For policy languages like XACML or RBAC with spatio-temporal
constraints, the true positive rates are above 75% in all cases and
above 80% in most of them. The false positive rates are always below
5%. For ABAC policies, we mine policies with a substantially lower
complexity and higher precision than those mined by the state of
the art. This demonstrates that with Unicorn we can build a wide
variety of policy miners, including new ones, that are competitive
with or even better than the state of the art.
Unicorn’s effectiveness follows from the wide applicability of
deterministic annealing (DA). This technique has been applied to
different optimization problems like the traveling salesman prob-
lem [61], clustering [62], and image segmentation [36]. DA can also
be applied to policy mining. However, in our case, computing the
distribution P (I | Auth) required by DA is intractable. Hence, we
use mean-field approximation (MFA) to compute a distribution q
that approximates P. This distribution q is much easier to compute.
Moreover, our approach of DA with MFA turns out to generalize to
a wide variety of policy languages.
We examine related work and draw conclusions in Sections 11
and 12. For details on deterministic annealing and mean-field ap-
proximation, we refer to the literature [9, 11, 61, 62].
2 PRELIMINARIES
2.1 Policy mining
Organizations define organizational policies that specify which per-
missions each user in the organization has. Such policies are usually
described in a high-level language. To be machine enforceable, pol-
icy administrators must specify this policy as an (access control)
policy in a machine-readable format. This policy assigns permissions
Session 1D: ForensicsCCS ’19, November 11–15, 2019, London, United Kingdom96to users and is formalized in a policy language. The policy is then en-
forced by mechanisms that intercept each request (a pair consisting
of a user and a permission) and check whether it is authorized.
Organizations are highly dynamic. New users come and existing
users may go. Moreover, groups of users may be transferred to other
organizational units. Such changes induce changes in the access
control policy, which are usually manually implemented, giving rise
to the following problems. First, the policy may become convoluted
and policy administrators no longer have an overview on who
is authorized to do what. Second, policy administrators may have
granted to users more permissions than needed to do their jobs. This
makes the organization vulnerable to abuse by its own users, who
may exploit the additional permissions and harm the organization.
To address these problems, numerous policy miners have been
proposed [12, 18, 31, 33, 43, 52, 56, 77]. We describe some of them in
Section 3.1. Policy miners are algorithms that receive as input the
current permission assignment, which is a relation between the set of
users and the set of permissions. The permission assignment might
be given as an access control matrix or a log of access requests
showing the access decisions previously made for each request.
It describes the organization’s implemented knowledge on which
permissions should be assigned to which users. The miner then
constructs a policy that is as consistent as possible with the per-
mission assignment and can be expressed using the organization’s
policy language.
A policy miner aims to solve the two problems mentioned above.
First, it can mine succinct policies that grant permissions consis-
tent with the given permission assignment. Second, policy miners
can mine policies that assign only those permissions that users
necessarily need. An administrator can then compare the mined
policy with the currently implemented policy in order to detect
permissions that are granted by the current policy, but that are not
being exercised by the users. Policy administrators can then inspect
those permissions and decide if they are necessary for those users.
The problem of policy mining is defined as follows. Given a
permission assignment and an objective function, compute a policy
that minimizes the objective function. Usually, objective functions
measure how well a policy fits a permission assignment and how
complex a policy is. We give examples of objective functions later
in Sections 5 and 8.
2.2 Quality criteria for policy miners
Policy miners can be regarded as machine-learning algorithms.
Therefore, they are evaluated by the quality of the policies they
mine, and here two criteria are used:
Generalization [18, 30, 56]. A mined policy should not only au-
thorize requests consistent with the given permission assignment.
It must also correctly decide what other permissions should be
granted to users who perform similar functions in the organization.
This is particularly important when mining from logs. For example,
if most of students in a university have requested and been granted
access to a computer room, then the mined policy should grant all
students access to the computer room rather than just to those who
previously requested access to it. For a formal definition of gen-
eralization, we refer to previous work and standard references in
machine learning [9, 18, 30]. One popular machine-learning method
to evaluate generalization is cross-validation [9, 32].
Complexity [12, 77]. A mined policy should not be unnecessar-
ily complex, as the policies are usually reviewed and audited by
humans. This is especially important when mining with the goal
of refactoring an existing policy or migrating to a new policy lan-
guage. However, there is no standard formalization of a policy’s
complexity, not even for established policy languages like RBAC or
ABAC. Each previous work has defined its own metrics to quantify
complexity [18, 29, 76, 77]. We discuss some of these metrics in
Section 8 and show how Unicorn is able to work with all of them.
3 THE PROBLEM OF DESIGNING POLICY
MINERS
3.1 Status quo: specialized solutions
Numerous policy languages exist for specifying access control poli-
cies, which fulfill different organizational requirements. Moreover,
new languages are continually being proposed. Some of them for-
mulate new concepts, like extensions of RBAC that can express
temporal and spatial constraints [1, 13, 15, 20, 49, 60, 69]. Other
languages facilitate policy specification in specialized settings such
as distributed systems [34, 70] or social networks [28].
Motivated by the practical problem of maintaining access control
configurations, researchers have proposed policy miners for a vari-
ety of policy languages. Moreover, for some policy languages, these
miners optimize different objectives. For example, initial RBAC min-
ers mined policies with a minimal number of roles [51, 63, 72, 74, 80].
Subsequent miners mined policies that are as consistent as possible
with the user-attribute information [30, 56, 75].
The development of policy miners is non-trivial and generally
requires sophisticated combinatorial and machine-learning algo-
rithms. Recent ABAC miners have used association rule mining [18]
and classification trees [14]. The most effective RBAC miners use
deterministic annealing [30] and latent Dirichlet allocation [56].
The proposed miners are so specialized that it is usually unclear
how to apply them to other policy languages or even to extensions
of the languages for which they were conceived. For example, dif-
ferent extensions of RBAC that support spatio-temporal constraints
have been proposed over the last two decades, e.g., [1, 13, 15, 20, 49,
60, 69]. However, not a single miner has been proposed for these
extensions. Miners have only recently emerged that mine RBAC
policies with constraints, albeit only temporal ones [53, 54, 66].
As a result, if an organization wants to use a specialized policy
language, it must invent its own policy miner, which is challenging
and time-consuming.
3.2 Alternative: A universal method
To facilitate the development of policy miners, we propose a new
method, universal access control policy mining (Unicorn). With this
method, organizations no longer need to spend substantial effort
designing specialized policy miners for their unique and specific
policy languages; they only need to perform the following tasks
(see also Figure 1). First, they specify a template formula φ for the
organization’s policy language. We explain later in Section 4 what
a template formula is. Second, they specify an objective function.
Session 1D: ForensicsCCS ’19, November 11–15, 2019, London, United Kingdom97Finally, they implement the miner as indicated by the algorithm
template in Section 7. We formalize these tasks in the next sections.
4 A UNIVERSAL POLICY LANGUAGE
In order to obtain a universal method, we need a framework for
specifying policy languages. We choose many-sorted first-order
logic [23, 24], which has been used to model and reason about
numerous policy languages, e.g. [3, 19, 40, 71].
Let Γ be a policy language for which we want to design a policy
miner. In this section we explain the first task: the miner designer
must specify a template formula φΓ for Γ. This is a first-order for-
mula that fulfills some conditions that we explain later in Defini-
tion 5. We show how Γ can be identified with φΓ ∈ L and how
policies in Γ can be identified with interpretation functions that
interpret φΓ’s symbols. We thereby reduce the problem of design-
ing a policy miner to designing an algorithm that searches for a
particular interpretation function.
We start by recalling first-order logic (Section 4.1). Then we pro-
vide some intuition on template formulas using RBAC (Section 4.2).
Afterwards, we propose a fragment L of first-order logic that is
powerful enough to contain template formulas for a variety of pol-
icy languages like RBAC, ABAC, and an expressive fragment of
XACML (Section 4.3). We then define template formulas (Section 4.4)
and give an example of a template formula for RBAC (Section 4.5).
4.1 Background in first-order logic
We provide here an overview of basic many-sorted first-order logic
and conventions we employ. The reader familiar with logic can read
this section lightly. We work only with finite first-order structures.
That is, structures whose carrier sets are finite. Later, in our exam-
ples, we will see that finite structures are still powerful enough to
model practical scenarios, as organizations do not need to handle
infinite sets. Even for the case of strings and integers, organizations
often only use a finite subset of them.
Definition 1. A signature is a tuple (S, R, F, V) fulfilling the fol-
lowing, where S is a finite non-empty set of sorts, R is a finite
non-empty set of relation symbols, F is a finite non-empty set of
function symbols, and V is a countable set of variables.
Each relation and each function symbol has an associated type,
which is a sequence of sorts. Furthermore, we assume the exis-
tence of two sorts USERS, PERMS ∈ S, denoting the users and
the permissions in the organization, respectively. We also assume
the existence of the sorts BOOL, INTS, STRS, which represent
□
Boolean values, integers, and strings, respectively.
We denote sorts with CAPITAL BOLD letters, relation symbols
with CAPITAL ITALIC letters, and function symbols and variables
with small italic letters. To agree with standard notation, we write a
relation symbol’s type (S1, . . . , Sk ) as S1×. . .×Sk instead. We write
a function’s symbol’s type (S1, . . . , Sk ) as S1 × . . . × Sk−1 → Sk in-
stead. We allow k = 1 and, in that case, we call function symbols con-
stant symbols. We denote constant symbols with small serif letters.
Definition 2. Let Σ be a signature. We define (first-order) terms
as those expressions built from Σ’s variables and function symbols
in the standard way. We also define (first-order) formulas as those
expressions obtained from terms by using relation symbols, terms,
□
and logical operators in the standard way.
We only allow well-typed terms and formulas and associate to
every term a type in the standard way. In addition, we consider
only quantifier-free formulas. For a formula φ, if {x1, . . . , xn} is
the set of all variables occurring in it, then we sometimes write
φ (x1, . . . , xn ) instead of φ to clarify which variables occur in φ.
Definition 3. Let Σ be a signature. A Σ-structure is a pair K =
(S, I). Here, S is a function mapping each sort S in Σ to a finite
non-empty set SS, called S’s carrier set. S must map BOOL, INTS,
and STRS to the sets of Boolean values, a finite set of integers,
and a finite set of strings, respectively. I is a function mapping
(i) each relation symbol R in Σ of type S1 × . . . × Sk to a relation
RI ⊆ SS
k and (ii) each function symbol f in Σ of type
S1 × . . . × Sk−1 → Sk to a function f I : SS
k . In
particular, a constant symbol of sort S is mapped to an element in
SS. For any symbol W in Σ, we call W I, K’s interpretation of W .
The function I is called an interpretation function.
□
1 × . . . × SS
1 × . . . × SS
k−1 → SS
RBAC
N