д1, д2) ← SetupGrp(1n ) for which the SXDH problem is assumed to
be hard. For our construction, we draw from the following building
blocks (cf. Section 2.2 for informal definitions) which all make use
of SetupGrp as their common group setup algorithm.
, L(2)
pkI
gp , F (2)
gp , and F (3)
, and L(3)
pkI
NIZKs. For proving that a user behaves honestly in the scope
gp -, F (2)
of the Issue, Accum, and Vfy protocol, we make use of F (1)
gp -,
and F (3)
gp -extractable NIZK proof systems, denoted by P1, P2, and
P3, respectively. The functions F (1)
gp depend on the
considered languages L(1)
(defined later), but they
pkI
have the following in common: They behave as the identity function
with respect to group elements and map elements from Zp either
to G1 or G2 (by exponentiation of the basis д1 or д2) depending
on whether these are used as exponents of a G1- or G2-element
in the language. The proof systems share a common reference
string. More precisely, we demand that there is a shared setup algo-
rithm SetupPoK which generates the CRS and also a shared setup
algorithm SetupEPoK that additionally generates a single extrac-
tion trapdoor for P1, P2, and P3. In the following, let us denote
their output by CRSpok ← SetupPoK(gp) and (CRSpok, tdepok) ←
SetupEPoK(gp) respectively. Furthermore, let us denote the prove
and verify algorithms of these proof systems by PX .Prove and
PX .Vfy, for 1 ≤ X ≤ 3. We make use of an SXDH-based instan-
tiation of Groth-Sahai proofs [21] for this purpose. Note that GS
proofs are not always zero-knowledge, but we ensured that they
indeed are for the languages we consider (cf. [22]).
Homomorphic commitments. In order to form a token and
commit to secrets including the user secret key and the token
balance, we make use of an equivocal F ′
gp-binding homomorphic
commitment scheme C for messages from Z4
p. The commitment
space is G2 and decommitment values are elements of G1. The
function F ′
gp maps m := (m1, m2, m3, m4) to M := (д
m3
1 ,
4
), so G
1 is the implicit message space. Moreover, as the user
m4
д
1
needs to be able to prove that she can open a commitment, the
m2
1 , д
m1
1 , д
Session I3:  Personal PrivacyCCS’17, October 30-November 3, 2017, Dallas, TX, USA1934Setup(1n )
gp := (p, G1, G2, GT , e, p, д1, д2) ← SetupGrp(1n )
CRSpok ← SetupPoK(gp)
CRScom ← C.Setup(gp)
(skT , pkT ) ← E.Gen(gp)
CRS := (gp, CRScom, pkT , CRSpok)
td := skT
return (CRS, td)
IGen(CRS)
(pksig, sksig) ← S.Gen(CRS)
return (pkI, skI ) := ((CRS, pksig), sksig)
UGen(CRS)
y ← Zp
(pkU, skU ) := (дy
return (pkU, skU )
1 , y )
U (pkI, pkU, skU )
s′
, u1 ← Zp
, d′
(c′
) := C.Com(CRScom,
(s′
, 0, skU, u1))
x := (c′
, pkU )
wit := (дskU
π := P1.Prove(CRSpok, x, wit)
1 , дs′
, дu1
1 , d′
2
)
I (pkI, skI, pkU )
c′
, π
x := (c′
if P1.Vfy(CRSpok, x, π ) = 0
, pkU )
return 0
s′′ ← Zp
, d′′
(c′′
(s′′
) = C.Com(CRScom,
, 0, 0, 0))
c := c′ · c′′
σ = S.Sgn(sksig, c )
Figure 8: Setup and Key Generation
c, d′′
, σ, s′′
corresponding verification equations must be compatible with our
proof systems. We use a scheme by Abe et al. [2] for this purpose. We
denote the CRS generator, commitment, and opening algorithms by
C.Setup, C.Com, and C.Open, respectively. Furthermore, as CAdd
and DAdd coincide with the multiplication of commitments and
decommitment values, respectively, we denote both operations by
“·”.
Signatures. In our protocol, commitments need to be signed
by the issuer to form a valid token. Moreover, users need to prove
that they know a valid signature without revealing this signature.
Hence, we make use of an EUF-CMA secure signature scheme S
for messages over G2 which is compatible with our proof system.
To instantiate this building block, we make use of the structure-
preserving signature scheme of Abe et al. [1]. We denote the key
generation algorithm, the signing algorithm, and the verification
algorithm by S.Gen, S.Sgn, and S.Vfy, respectively.
Encryption. hid will be a simple encryption of a user’s public
key under a public key contained in the CRS. For this purpose, an
IND-CPA secure encryption scheme E for messages in G1 which
is compatible with our proof system suffices. This building block
can be instantiated with the ElGamal encryption scheme [17]. We
denote the corresponding algorithms by E.Gen, E.Enc, and E.Dec.
4.2 Protocol Description
Figures 8 to 11 summarize the scheme. In the following, we elaborate
on the details of the different protocols and algorithms.
System and user setup. The setup and key generation algo-
rithms are given in Fig. 8. The global CRS CRS generated by Setup
consists of a CRS CRScom for the commitment scheme, a shared CRS
CRSpok for the three proof systems, as well as a public encryption
key pkT to generate the hidden user ID hid. The corresponding
trapdoor td equals the secret key skT to decrypt hidden IDs. Thus,
we have ExtractUID(td, hid) := E.Dec(skT , hid). The key pair of
the issuer is essentially a signature key pair (pksig, sksig). Remem-
ber that the global CRS is included in the public key for convenience,
s := s′ + s′′ mod p
d := d′ · d′′
τ := (c, d, σ, s, u1)
if UVer(pkI, pkU, skU, τ , 0) = 0
return (⊥, 0)
else return (τ , 1)
return 1
Figure 9: Issue protocol
i. e. pkI := (CRS, pksig). The key pair of a user consists of skU = y
and pkU = д
1 , where pkU is used as the user identity and skU to
y
prove this identity in the scope of Issue as well as to prove guilt in
VerifyGuilt.
Issuing tokens. The issue protocol is shown in Fig. 9. Essen-
tially, a valid token consists of a commitment c ∈ G2 on the token
version number s ∈ Zp, the balance w ∈ Zp, the user secret key
skU ∈ Zp, and the randomness u1 ∈ Zp of the double-spending tag,
as well as a signature on c under skI. The token version number
needs to be chosen jointly by U (choosing an additive share s′) and
I (choosing an additive share s′′) to ensure unlinkability on the one
hand and enable double-spending detection on the other hand. The
randomness u1 is chosen by U and is used in the scope of Accum
and Vfy to compute double-spending tags. The fact that it is hidden
from I ensures that the double-spending tag looks random if the
token is used once. The fact that it is bound to the token ensures
that double-spending reveals the user identity. To generate such
a token, U commits to s′, w = 0, skU, and u1. It then computes
a proof showing that the corresponding commitment c′ has been
formed correctly by the owner of pkU. More precisely, P1 is used
to compute a proof π for a statement x from the language L(1)
pkI
defined by
(c′
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
L(1)
pkI
:=
, pkU )
∃ SKU ∈ G2; S′, U1, D′ ∈ G1 :
C.Open(CRScom, (S′, 1, pkU, U1), c′, D′) = 1
e (pkU, д2) = e (д1, SKU)
(7)
Session I3:  Personal PrivacyCCS’17, October 30-November 3, 2017, Dallas, TX, USA1935UVer(pkI, pkU, skU, τ , w )
parse (c, d, σ, s, u1) := τ
if pkU = дskU
if S.Vfy(pksig, σ, c ) = 1
return 1
else return 0
1
∧ C.Open(CRS, (дs1 , дw1 , pkU, дu1
1 ), c, d ) = 1∧
IdentDS(pkI, (s1, z1), (s2, z2))
parse (t, u2) := z1, (t′, u′
if s1 (cid:44) s2 ∨ u2 = u′
2 return ⊥
else skU := (t − t′) · (u2 − u′
return (pkU, skU )
2) := z2
2)−1 mod p, pkU := дskU
1
VerifyGuilt(pkI, pkU, Π)
if дΠ1 = pkU return 1
else return 0
Figure 10: User verification of tokens and double-spending
algorithms
The language depends on public parameters such as gp, CRScom,
CRSpok, pksig which are all subsumed in pkI and remain fixed after
the system has been setup. Note that the second equation in Eq. (7)
(rather than skU itself).10
skU
actually proves the knowledge of д
2
skU
2 without knowing skU (only given pkU)
However, computing д
is assumed to be a hard problem (Co-CDH). Receiving c′ and a
valid proof π, I adds a random s′′ to s′ contained in c′ by using
the homomorphic property of C. This results in the commitment c
which can be opened using the decommitment value d = d′ · d′′.
The commitment c is then signed by I resulting in signature σ.
The values token c, σ, s′′, and d′′ are sent over to U who verifies
the correctness of the new token τ by applying UVer. The UVer
algorithm is shown in Fig. 10. It verifies that c opens correctly, σ is
valid, and skU is the secret key belonging to pkU.
Collecting points. The Accum protocol is depicted in Fig. 11.
Given his current token τ = (c, d, σ , s, u1), U receives a random
challenge u2 from AC to prepare the t-part of the double-spending
tag as t = skUu2 + u1 for this token. Moreover, U prepares the
generation of a fresh token just like in the Issue protocol. To this
end, it computes a commitment c′ containing the same balance
w and user secret key skU as c but a fresh share s′ for a new
token version number and fresh randomness for generating double-
spending tags. Moreover, hid is generated as a fresh encryption of
pkU. Recall that while hid does not fulfill an obvious function, it
is needed for our security definitions. Finally, the user proves that
everything has been computed as claimed: c is a signed commitment;
c′ is just a “new version” of this commitment containing the same
balance w and user secret key skU; t contains skU and the user
randomness u1 (fixed in c) as well as the accumulator’s challenge
u2; and hid contains pkU belonging to skU. More precisely, P2 is
used to compute a proof π for a statement x from the language
U (pkI, pkU, skU, τ , w, v )
AC(pkI, skI, v )
u2 ← Zp
u2
, u′
1 ← Zp
parse (c, d, σ, s, u1) := τ
t := skUu2 + u1 mod p
r, s′
hid := E.Enc(pkT , pkU ; r )
, d′
(c′
) := C.Com(CRScom,
(s′
, w, skU, u′
1))
x := (c′
, (дs1 , t, u2), hid)
wit := (c, σ, дw1 , pkU, дu1
1 , дd1 ,
1 , skU, u1, r )
π = P2.Prove(CRSpok, x, wit)
1 , дu′
дs′
1 , дd′
1
c′
, s, t, π, hid
c∗
, d′′
, σ ∗