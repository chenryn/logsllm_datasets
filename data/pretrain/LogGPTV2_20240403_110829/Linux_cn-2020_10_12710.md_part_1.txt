---
author: Florian Westphal
category: 系统运维
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 9476
date: '2020-10-12 11:41:13'
editorchoice: false
excerpt: 有很多文章出于各种“性能调优”或“安全性”原因，建议禁用 TCP 扩展，本文提供了这些扩展功能的背景，为什么会默认启用，它们之间是如何关联的，以及为什么通常情况下将它们关闭是个坏主意。
fromurl: https://fedoramagazine.org/tcp-window-scaling-timestamps-and-sack/
id: 12710
islctt: true
largepic: /data/attachment/album/202010/12/114050up4695djpw6n4tu9.jpg
permalink: /article-12710-1.html
pic: /data/attachment/album/202010/12/114050up4695djpw6n4tu9.jpg.thumb.jpg
related: []
reviewer: wxy
selector: lujun9972
summary: 有很多文章出于各种“性能调优”或“安全性”原因，建议禁用 TCP 扩展，本文提供了这些扩展功能的背景，为什么会默认启用，它们之间是如何关联的，以及为什么通常情况下将它们关闭是个坏主意。
tags:
- TCP
thumb: false
title: TCP 窗口缩放、时间戳和 SACK
titlepic: true
translator: gxlct008
updated: '2020-10-12 11:41:13'
---
![](/data/attachment/album/202010/12/114050up4695djpw6n4tu9.jpg)
Linux TCP 协议栈具有无数个可以更改其行为的 `sysctl` 旋钮。 这包括可用于接收或发送操作的内存量、套接字的最大数量、可选的特性和协议扩展。
有很多文章出于各种“性能调优”或“安全性”原因，建议禁用 TCP 扩展，比如时间戳或 选择性确认   Selective ACKnowledgments （SACK）。
本文提供了这些扩展功能的背景，为什么会默认启用，它们之间是如何关联的，以及为什么通常情况下将它们关闭是个坏主意。
### TCP 窗口缩放
TCP 可以承受的数据传输速率受到几个因素的限制。其中包括：
*  往返时间   Round trip time （RTT）。
这是数据包到达目的地并返回回复所花费的时间。越低越好。
* 所涉及的网络路径的最低链路速度。
* 丢包频率。
* 新数据可用于传输的速度。
例如，CPU 需要能够以足够快的速度将数据传递到网络适配器。如果 CPU 需要首先加密数据，则适配器可能必须等待新数据。同样地，如果磁盘存储不能足够快地读取数据，则磁盘存储可能会成为瓶颈。
* TCP 接收窗口的最大可能大小。
接收窗口决定了 TCP 在必须等待接收方报告接收到该数据之前可以传输多少数据（以字节为单位）。这是由接收方宣布的。接收方将在读取并确认接收到传入数据时不断更新此值。接收窗口的当前值包含在 [TCP 报头](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure) 中，它是 TCP 发送的每个数据段的一部分。因此，只要发送方接收到来自对等方的确认，它就知道当前的接收窗口。这意味着往返时间（RTT）越长，发送方获得接收窗口更新所需的时间就越长。
TCP 的未确认（正在传输）数据被限制为最多 64KB。在大多数网络场景中，这甚至还不足以维持一个像样的数据速率。让我们看看一些例子。
**理论数据速率**
在往返时间（RTT）为 100 毫秒的情况下，TCP 每秒最多可以传输 640KB。在延迟为 1 秒的情况下，最大理论数据速率降至只有 64KB/s。
这是因为接收窗口的原因。一旦发送了 64KB 的数据，接收窗口就已经满了。发送方必须等待，直到对等方通知它应用程序已经读取了至少一部分数据。
发送的第一个段会把 TCP 窗口缩减去该段的大小。在接收窗口值的更新信息可用之前，需要往返一次。当更新以 1 秒的延迟到达时，即使链路有足够的可用带宽，也会导致 64KB 的限制。
为了充分利用一个具有几毫秒延迟的快速网络，必须有一个比传统 TCP 支持的窗口更大的窗口。“64KB 限制”是协议规范的产物：TCP 头只为接收窗口大小保留了 16 个位。这允许接收窗口最大为 64KB。在 TCP 协议最初设计时，这个大小并没有被视为一个限制。
不幸的是，想通过仅仅更改 TCP 头来支持更大的最大窗口值是不可能的。如果这样做就意味着 TCP 的所有实现都必须同时更新，否则它们将无法相互理解。为了解决这个问题，我们改变了对接收窗口值的解释。
“窗口缩放选项”允许你改变这个解释，同时保持与现有实现的兼容性。
#### TCP 选项：向后兼容的协议扩展
TCP 支持可选扩展。这允许使用新特性增强协议，而无需立即更新所有实现。当 TCP 发起方连接到对等方时，它还会发送一个支持的扩展列表。所有扩展都遵循相同的格式：一个唯一的选项号，后跟选项的长度以及选项数据本身。
TCP 响应方检查连接请求中包含的所有选项号。如果它遇到一个不能理解的选项号，则会跳过 该选项号附带的“长度”字节的数据，并检查下一个选项号。响应方忽略了从答复中无法理解的内容。这使发送方和接收方都够理解所支持的公共选项集。
使用窗口缩放时，选项数据总是由单个数字组成。
### 窗口缩放选项
```
Window Scale option (WSopt): Kind: 3, Length: 3
    +---------+---------+---------+
    | Kind=3  |Length=3 |shift.cnt|
    +---------+---------+---------+
         1         1         1
```
[窗口缩放](https://www.rfc-editor.org/info/rfc7323) 选项告诉对等方，应该使用给定的数字缩放 TCP 标头中的接收窗口值，以获取实际大小。
例如，一个宣告窗口缩放因子为 7 的 TCP 发起方试图指示响应方，任何将来携带接收窗口值为 512 的数据包实际上都会宣告 65536 字节的窗口。增加了 128 倍（2^7）。这将允许最大为 8MB 的 TCP 窗口。
不能理解此选项的 TCP 响应方将会忽略它，为响应连接请求而发送的 TCP 数据包（SYN-ACK）不会包含该窗口缩放选项。在这种情况下，双方只能使用 64k 的窗口大小。幸运的是，默认情况下，几乎每个 TCP 栈都支持并默认启用了此选项，包括 Linux。
响应方包括了它自己所需的缩放因子。两个对等方可以使用不同的因子。宣布缩放因子为 0 也是合法的。这意味着对等方应该如实处理它接收到的接收窗口值，但它允许应答方向上的缩放值，然后接收方可以使用更大的接收窗口。
与 SACK 或 TCP 时间戳不同，窗口缩放选项仅出现在 TCP 连接的前两个数据包中，之后无法更改。也不可能通过查看不包含初始连接三次握手的连接的数据包捕获来确定缩放因子。
支持的最大缩放因子为 14。这将允许 TCP 窗口的大小高达 1GB。
**窗口缩放的缺点**
在非常特殊的情况下，它可能导致数据损坏。但在你禁用该选项之前，要知道通常情况下是不可能损坏的。还有一种解决方案可以防止这种情况。不幸的是，有些人在没有意识到它与窗口缩放的关系的情况下禁用了该解决方案。首先，让我们看一下需要解决的实际问题。想象以下事件序列：
1. 发送方发送段：s\_1、s\_2、s\_3、... s\_n。
2. 接收方看到：s\_1、s\_3、... s\_n，并发送对 s\_1 的确认。
3. 发送方认为 s\_2 丢失，然后再次发送。它还发送了段 s\_n+1 中包含的新数据。
4. 接收方然后看到：s\_2、s\_n+1，s\_2：数据包 s\_2 被接收两次。
当发送方过早触发重新传输时，可能会发生这种情况。在正常情况下，即使使用窗口缩放，这种错误的重传也绝不会成为问题。接收方将只丢弃重复项。
#### 从旧数据到新数据
TCP 序列号最多可以为 4GB。如果它变得大于此值，则该序列会回绕到 0，然后再次增加。这本身不是问题，但是如果这种问题发生得足够快，则上述情况可能会造成歧义。
如果在正确的时刻发生回绕，则序列号 s\_2（重新发送的数据包）可能已经大于 s\_n+1。因此，在最后的步骤（4）中，接收方可以将其解释为：s\_2、s\_n+1、s\_n+m，即它可以将 “旧” 数据包 s\_2 视为包含新数据。
通常，这不会发生，因为即使在高带宽链接上，“回绕”也只会每隔几秒钟或几分钟发生一次。原始数据包和不需要的重传的数据包之间的间隔将小得多。
例如，对于 50MB/s 的传输速度，重复项要迟到一分钟以上才会成为问题。序列号的回绕速度没有快到让小的延迟会导致这个问题。
一旦 TCP 达到 “GB/s” 的吞吐率，序列号的回绕速度就会非常快，以至于即使只有几毫秒的延迟也可能会造成 TCP 无法检测出的重复项。通过解决接收窗口太小的问题，TCP 现在可以用于以前无法实现的网络速度，这会产生一个新的，尽管很少见的问题。为了在 RTT 非常低的环境中安全使用 GB/s 的速度，接收方必须能够检测到这些旧的重复项，而不必仅依赖序列号。
### TCP 时间戳
#### 最佳截止日期
用最简单的术语来说，[TCP 时间戳](https://www.rfc-editor.org/info/rfc7323)只是在数据包上添加时间戳，以解决由非常快速的序列号回绕引起的歧义。如果一个段看起来包含新数据，但其时间戳早于上一个在接收窗口内的数据包，则该序列号已被重新回绕，而“新”数据包实际上是一个较旧的重复项。这解决了即使在极端情况下重传的歧义。
但是，该扩展不仅仅是检测旧数据包。TCP 时间戳的另一个主要功能是更精确的往返时间测量（RTTm）。
#### 需要准确的 RTT 估算
当两个对等方都支持时间戳时，每个 TCP 段都携带两个附加数字：时间戳值和回显时间戳。
```
TCP Timestamp option (TSopt): Kind: 8, Length: 10
+-------+----+----------------+-----------------+
|Kind=8 | 10 |TS Value (TSval)|EchoReply (TSecr)|
+-------+----+----------------+-----------------+
    1      1         4                4
```
准确的 RTT 估算对于 TCP 性能至关重要。TCP 会自动重新发送未确认的数据。重传由计时器触发：如果超时，则 TCP 会将尚未收到确认的一个或多个数据包视为丢失。然后再发送一次。
但是，“尚未得到确认” 并不意味着该段已丢失。也有可能是接收方到目前为止没有发送确认，或者确认仍在传输中。这就造成了一个两难的困境：TCP 必须等待足够长的时间，才能让这种轻微的延迟变得无关紧要，但它也不能等待太久。
**低网络延迟 VS 高网络延迟**
在延迟较高的网络中，如果计时器触发过快，TCP 经常会将时间和带宽浪费在不必要的重发上。
然而，在延迟较低的网络中，等待太长时间会导致真正发生数据包丢失时吞吐量降低。因此，在低延迟网络中，计时器应该比高延迟网络中更早到期。所以，TCP 重传超时不能使用固定常量值作为超时。它需要根据其在网络中所经历的延迟来调整该值。
**往返时间的测量**
TCP 选择基于预期的往返时间（RTT）的重传超时。RTT 事先是未知的。它是通过测量发送的段与 TCP 接收到该段所承载数据的确认之间的增量来估算的。
由于多种因素使其而变得复杂。