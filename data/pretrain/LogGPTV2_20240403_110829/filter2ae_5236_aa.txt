来源：[blog.orange.tw](http://blog.orange.tw/)
作者：[Orange](http://blog.orange.tw/2017/01/bug-bounty-github-enterprise-sql-injection.html)
## 前言
GitHub Enterprise 是一款 [GitHub.com](https://github.com/) 所出品，可将整个 GitHub
服务架设在自身企业内网中的应用软体。 有兴趣的话你可以从
[enterprise.github.com](https://enterprise.github.com) 下载到多种格式的映像档并从网页上取得 45
天的试用授权!
安装完成后，你应该会看到如下的画面:
好!现在我们有整个 GitHub 的环境了，而且是在 VM 里面，这代表几乎有完整的控制权可以对他做更进一步的研究，分析环境、程式码以及架构等等...
## 环境
身为一个骇客，再进行入侵前的第一件事当然是 Port Scanning! 透过 Nmap 扫描后发现 VM 上一共有 6 个端口对外开放:
    $ nmap -sT -vv -p 1-65535 192.168.187.145
    ...
    PORT     STATE  SERVICE
    22/tcp   open   ssh
    25/tcp   closed smtp
    80/tcp   open   http
    122/tcp  open   smakynet
    443/tcp  open   https
    8080/tcp closed http-proxy
    8443/tcp open   https-alt
    9418/tcp open   git
这 6 个端口大致的作用是:
  * `22/tcp` 及 `9418/tcp` 是 `haproxy` 协议，并将收到的连线转发到后段的 `babeld` 服务
  * `80/tcp` 及 `443/tcp` 为 GitHub 主要服务的端口
  * `122/tcp` 就是 SSH 服务
  * `8443/tcp` GitHub Enterprise 的网页管理介面
额外一提的是，GitHub 的网页管理介面需要一组密码以供登入，但如果你有密码的话你可以直接透过管理介面新增自己的 SSH 金钥并登入 `122/tcp`
上的 SSH 所以 **有管理员密码 == 可以远端代码执行** !
使用 SSH 连线进去后，审视一下整个系统发现所有服务的代码皆位于目录 `/data/` 下，大致目录架构如下:
    # ls -al /data/
    total 92
    drwxr-xr-x 23 root              root              4096 Nov 29 12:54 .
    drwxr-xr-x 27 root              root              4096 Dec 28 19:18 ..
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 alambic
    drwxr-xr-x  4 babeld            babeld            4096 Nov 29 12:53 babeld
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 codeload
    drwxr-xr-x  2 root              root              4096 Nov 29 12:54 db
    drwxr-xr-x  2 root              root              4096 Nov 29 12:52 enterprise
    drwxr-xr-x  4 enterprise-manage enterprise-manage 4096 Nov 29 12:53 enterprise-manage
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 failbotd
    drwxr-xr-x  3 root              root              4096 Nov 29 12:54 git-hooks
    drwxr-xr-x  4 git               git               4096 Nov 29 12:53 github
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 git-import
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 gitmon
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 gpgverify
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 hookshot
    drwxr-xr-x  4 root              root              4096 Nov 29 12:54 lariat
    drwxr-xr-x  4 root              root              4096 Nov 29 12:54 longpoll
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 mail-replies
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 pages
    drwxr-xr-x  4 root              root              4096 Nov 29 12:54 pages-lua
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 render
    lrwxrwxrwx  1 root              root                23 Nov 29 12:52 repositories -> /data/user/repositories
    drwxr-xr-x  4 git               git               4096 Nov 29 12:54 slumlord
    drwxr-xr-x 20 root              root              4096 Dec 28 19:22 user
接著随便选取一个目录尝试读取原始码，发现原始码看起来被加密了 :( 加密后的原始码看起来像是:
GitHub 使用客制化的函式库来混淆他们的原始码，如果你在 Google 上搜寻客制化函示酷的名称 `ruby_concealer.so`
你会发现已经有个好心人把写好的解密程式放在 [这份 gist](https://gist.github.com/geoff-codes/02d1e45912253e9ac183) 上了!
解密程式很简单，只是单纯将函示库中的 `rb_f_eval` 替换成 `rb_f_puts` ，所以原本会进行 `eval`
的动作变成直接将解密后的原始码印出来!
但是身为一个骇客，不能只是 Script Kiddie 伸手党只会使用别人的程式，必须要了解它内部原理是如何实现的!
所以我们来打开 IDA Pro 来分析一下 Binary 吧! ๑•̀ㅂ•́)و
从上方的 Hex-Rays 转 C 语言代码可以看到，函示库使用 `Zlib::Inflate::inflate` 先将原始乱码的资料解压缩，接著再使用
XOR 并用下面的金钥进行解密:
    This obfuscation is intended to discourage GitHub Enterprise customers from making modifications to the VM. We know this 'encryption' is easily broken.
了解原理后其实可以很简单的写个小程式去解密它!
    require 'zlib'
    key = "This obfuscation is intended to discourage GitHub Enterprise customers from making modifications to the VM. We know this 'encryption' is easily broken. "
    def decrypt(s)
        i, plaintext = 0, ''
        Zlib::Inflate.inflate(s).each_byte do |c|
            plaintext << (c ^ key[i%key.length].ord).chr
            i += 1
        end
        plaintext
    end
    content = File.open(ARGV[0], "r").read
    content.sub! %Q(require "ruby_concealer.so"\n__ruby_concealer__), " decrypt "
    plaintext = eval content
    puts plaintext
## 代码分析
在反混淆 GitHub 的代码后，终于可以开始我们的原始码审查! 首先，使用 `cloc` 看一下整个专案大致架构组成!
    $ cloc /data/
       81267 text files.
       47503 unique files.
       24550 files ignored.
    http://cloc.sourceforge.net v 1.60  T=348.06 s (103.5 files/s, 15548.9 lines/s)
    -----------------------------------------------------------------------------------    Language                         files          blank        comment           code
    -----------------------------------------------------------------------------------    Ruby                             25854         359545         437125        1838503
    Javascript                        4351         109994         105296         881416
    YAML                               600           1349           3214         289039
    Python                            1108          44862          64025         180400
    XML                                121           6492           3223         125556
    C                                  444          30903          23966         123938
    Bourne Shell                       852          14490          16417          87477
    HTML                               636          24760           2001          82526
    C++                                184           8370           8890          79139
    C/C++ Header                       428          11679          22773          72226
    Java                               198           6665          14303          45187
    CSS                                458           4641           3092          44813
    Bourne Again Shell                 142           6196           9006          35106
    m4                                  21           3259            369          29433
    ...
看一下 `Ruby` 以及 `Rails` 的版本
    $ ./bin/rake about
    About your application's environment
    Ruby version              2.1.7 (x86_64-linux)
    RubyGems version          2.2.5
    Rack version              1.6.4
    Rails version             3.2.22.4
    JavaScript Runtime        Node.js (V8)
    Active Record version     3.2.22.4
    Action Pack version       3.2.22.4
    Action Mailer version     3.2.22.4
    Active Support version    3.2.22.4