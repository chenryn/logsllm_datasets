• 
Alternatively, the stack can be read by the injector process, using a memory read 
primitive (e.g. ReadProcessMemory), and embedded in the payload. 
• 
Pivot to a new memory immediately – this ruins only the return address, and another 
QWORD above it (which is anyway reserved for the leaf function and unused by the 5 
leaf functions mentioned above, hence can be safely overwritten with no need for 
restoration). The payload needs to restore RSP and the return address (only).  
As for restoring registers, the 5 leaf functions do not rely on volatile registers when transferring 
control to the kernel, and thus it is safe to modify the volatile registers, but the non-volatile 
registers must be restored. Keep in mind that calling other (system) functions from the payload 
does not modify the non-volatile registers since they are restored before control is returned to 
the main payload. Thus, if the payload is written to only use volatile registers, it will be safe 
(with no need to restore registers). 
A safe version (including clean-up): 
// payload mustn’t modify non-volatile registers, must copy the saved return 
address to the original tos location (e.g. using memmove)  
// and must restore rsp and control when it’s done, e.g. using GADGET_pivot. 
HANDLE t = OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT | 
THREAD_SUSPEND_RESUME, FALSE, thread_id); 
SuspendThread(t); 
CONTEXT context; 
context.ContextFlags = CONTEXT_ALL; 
GetThreadContext(t, &context) 
DWORD64 orig_tos = (DWORD64)context.Rsp; 
DWORD64 tos = orig_tos-0x2000; // 0x2000 experimentally works… 
// Grow the stack to accommodate the new stack 
for (DWORD64 i = orig_tos - 0x1000; i >= tos; i -= 0x1000) 
{ 
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memset"), (void*)(i), 
(void*)0, 1); 
} 
// Write the new stack 
payload[saved_tos]=orig_tos; 
for (int i = 0; i < sizeof(payload); i++) 
{ 
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memset"), (void*)(tos + i), 
(void*)*(((BYTE*)payload) + i), 1); 
} 
// Save the original return address into the new stack 
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memmove"), 
(void*)(payload[saved_return_address]), (void*)orig_tos, 8); 
// overwrite the original return address with GADGET_pivot 
for (int i = 0; i < sizeof(tos); i++) 
{ 
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memset"), (void*)(orig_tos + 
i), (void*)(((BYTE*)&GADGET_pivot)[i]), 1); 
} 
// overwrite the original tos+8 with the new tos address (we don't need to restore 
this since it's shadow stack and not used by the leaf function!) 
for (int i = 0; i < sizeof(tos); i++) 
{ 
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memset"), (void*)(orig_tos + 
8 + i), (void*)(((BYTE*)&tos)[i]), 1); 
} 
ResumeThread(t); 
Evaluation: 
• 
Prerequisites: Thread must be in alertable state. Target address must be RX (at least) 
• 
Limitations: none 
• 
CFG/CIG-readiness: not affected. 
• 
Control over registers: no 
• 
Stability: since all memory writes are queued, and happen together, atomicity is not an 
issue.  
• 
Cleanup required: yes. The original thread state, stack and non-volatile registers need to 
be restored. 
Shatter-like Techniques 
There are 7 Shatter-like techniques: (WordWarping, Hyphentension, AutoCourgette, Streamception, 
Oleum, ListPLanting, Treepoline) described by Odzhan 
(https://modexp.wordpress.com/2019/04/25/seven-window-injection-methods/). Due to time 
shortage, we’re not providing analysis and PoCs here – this will be included in a future version of the 
paper and PINJECTRA. 
Summary of Techniques 
Memory Allocation 
Allocation Technique 
Memory Access 
CFG-valid? 
Stable? 
VirtualAllocEx 
RWX 
Yes 
Yes 
(allocated memory) 
Image (.data slack), 
Stack, Heap 
RW 
No 
.data slack – Yes, 
Stack/Heap – depends. 
NtMapViewOfSection 
RWX 
Yes 
Yes 
Memory Write 
(boldface APIs are target process oriented) 
Write Technique 
Prerequisites/Limitations Address 
control 
Stable? 
Main APIs used 
WriteProcessMemory None 
Full 
Yes 
OpenProcess, 
WriteProcessMemory 
Existing Shared 
Memory 
Process must have a RW 
Shared Memory section 
None 
May be 
unstable 
OpenFileMapping, 
MapViewOfFile, 
OpenProcess, 
VirtualQueryEx, 
ReadProcessMemory 
Atom Bombing 
Thread must be in 
alertable state 
Full 
Yes 
OpenThread, 
GlobalAtomAdd, 
ntdll!NtQueueApcThread 
NtMapViewOfSection 
Cannot write on allocated 
memory (e.g. Image, 
Stack, Heap) 
N/A 
Yes 
CreateFileMapping, 
MapViewOfFile, 
OpenProcess, 
ntdll!NtMapViewOfSection 
memset/memmove 
Thread must be in 
alertable state 
Full 
Yes 
Execution Techniques 
(boldface APIs are global or target process oriented) 
Execution 
method 
Famil
y 
Prerequisites/
Limitations 
CFG/C
IG 
constr
aints 
Controlled 
registers 
Cleanup/Sta
bility 
Main APIs used 
DLL 
injection via 
CreateRemo
teThread 
DLL 
innje
ction 
(1) DLL on 
disk; (2) DLL 
path in target 
process 
memory; (3) 
Loader lock 
restrictions 
(CIG) 
DLL 
must 
be 
MSFT-
signed
… 
None (N/A 
– runs 
native 
code) 
OpenProcess+ 
CreateRemoteThread
/ 
OpenThread+ 
QueueUserAPC/ 
ntdll!NtQueueApcTh
read 
CreateRemo
teThread 
Target address 
must be RX (at 
least) 
(CFG) 
Target 
addre
ss 
must 
be 
CFG-
valid 
RCX 
OpenProcess, 
CreateRemoteThread 
APC 
(1) Target 
address must 
be RX (at 
least); (2) 
Thread must 
(CFG) 
Target 
addre
ss 
must 
RCX (also 
RDX and R8 
for 
NtQueueAp
cThread) 
OpenThread, 
QueueUserAPC/ 
ntdll!NtQueueApcTh
read 
be in alertable 
state 
be 
CFG-
valid 
Thread 
execution 
hijacking 
Target address 
must be RX (at 
least).  
(CFG) 
RSP (if 
set) 
must 
be 
within 
stack 
limits 
All non 
volatile 
registers, in 
some cases 
also volatile 
registers 
Cleanup 
needed in 
order for the 
original 
thread to 
resume 
execution 
OpenThread, 
SuspendThread, 
ResumeThread, 
SetThreadContext 
Windows 
hook 
DLL 
inject
ion 
(1) DLL on 
disk; (2) target 
process must 
have 
user32.dll 
loaded (and a 
message loop 
thread) 
(CIG) 
DLL 
must 
be 
MSFT-
signed
… 
None (N/A 
– runs 
native 
code) 
SetWindowsHookEx 
Ghost-
writing 
Target address 
must be RX (at 
least) 
None 
All non 
volatile 
registers, in 
some cases 
also volatile 
registers 
Cleanup 
needed in 
order for the 
original 
thread to 
resume 
execution. 
May be 
tricky! 
OpenThread, 
GetThreadContext, 
SetThreadContext, 
SuspendThread, 
ResumeThread 
SetWindow
Long/ 
SetWindow
LongPtr 
Switc
h 
virtua
l 
table 
and 
trigge
r 
(1) A window 
belonging to 
the target 
process, that 
uses the extra 
window bytes 
to store a 
pointer to an 
object with a 
virtual 
function table. 
Specifically, 
explorer’s 
Shell Tray 
Window uses 
the first 8 
extra window 
bytes to store 
a pointer to a 
CTray object; 
(CFG) 
Target 
addre
ss 
must 
be 
CFG-
valid 
None 
Cleanup 
needed: the 
original 
CTray object 
must be 
restored, 
and special 
consideratio
n must be 