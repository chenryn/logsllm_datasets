tributed quicker (and more easily) than patches to indi-
vidual applications. We also note that given the popular-
ity of OpenSSL, it can also behave as a single point of
failure, as with the Heartbleed vulnerability.
Another beneﬁt of centralization is that it vastly sim-
pliﬁes the landscape of security problems we face to-
day. At present, thousands of individual applications
must each be written to use OpenSSL (or other simi-
lar crypto libraries) properly, and experience shows that
there are numerous applications that are at risk due to de-
veloper errors. Under the SSA, developer security ﬂaws
are likely to be less common, due to the simplicity of
invoking the SSA through the POSIX interface and of-
ﬂoading of TLS functionality to the operating system.
Regardless of underlying implementation, the SSA
USENIX Association
27th USENIX Security Symposium    813
should protect its conﬁguration ﬁles from unauthorized
edits. Since conﬁguration can affect the security of TLS
connections globally, only superusers should be allowed
to make modiﬁcations. Developers can still bundle an
SSA conﬁguration proﬁle for their application, which
can be stored in a standard location and assigned appro-
priate permissions during installation. Many software
packages behave similarly already, like Apache web-
server packages, which install protected conﬁguration
ﬁles for editing by administrators.
An existing issue in security is made more apparent by
the SSA. The SSA modiﬁes the responsibilities of net-
work security for administrators, operating systems, and
developers. As such, it remains in question which party
is held accountable when security fails. Implementation
bugs can be attributed to the SSA (just like OpenSSL
bugs), but vulnerabilities due to improper conﬁgurations
can be the fault of any of these parties. While we believe
that administrators should have the ﬁnal word over their
systems, it is foreseeable that some application develop-
ers may want to ensure their own security needs are met,
due to legal or other reasons. In such cases, one solution
is for developers to ship their applications with a notice
that obviates any warranty if the administrator decides to
lower TLS security below a given set of thresholds. This
issue of misaligned developer and administrator security
practices is also present in other security areas, such as
running software as a privileged user unnecessarily, mak-
ing conﬁguration ﬁles globally writable, or using sensi-
tive software from accounts with weak login credentials.
9 Limitations and Future Work
Our exploration has exposed some limitations of our ap-
proach, our implementation, and the SSA itself. Each of
these has also uncovered potential avenues for additional
exploration and expansion of the SSA.
First because we used static analysis of code using
libssl, we could not determine what code is actually
executed during runtime. Performing rigorous symbolic
execution or runtime analysis of such a large corpus of
packages is outside the scope of our study. As a result
we may have overestimated or underestimated the preva-
lence of use of certain OpenSSL functions. However,
static analysis does have the beneﬁt of providing insight
into the code developers are writing, which is what led
us to ﬁnd that many developers were expressing TLS op-
tions through compilation controls. In addition, we lim-
ited our analysis to applications using OpenSSL. The us-
age of GnuTLS and other libraries may differ in ways
that could affect our design recommendations.
Because the SSA targets the POSIX socket API, we
believe implementations very similar to ours can be de-
ployed on operating systems that closely adhere to this
standard, such as Android and MacOS. Windows also
supports this API (with minor deviations), although the
mapping between POSIX functions and system calls is
not as direct as in the other systems. As such, the kernel
module component of our implementation would have to
be adapted accordingly.
One limitation of the SSA itself is that it cannot eas-
ily support asynchronous callbacks. While we did not
ﬁnd a reason why such a feature was strictly needed
for TLS management, it is possible that such a use case
may arise. Hypothetically, to support this, setsockopt
could adopt an option that allowed a function pointer to
be passed as the option value. This function could then
be invoked by the SSA implementation when its corre-
sponding event was triggered. Under kernel implemen-
tations of the SSA, providing arbitrary functions to the
kernel to execute seems like a dangerous proposition. In
addition, invoking a process function from the kernel is
not a natural task and such behavior seems to be limited
to the simplicity of signals and their handlers.
One unexplored path for future work is the suitabil-
ity of the SSA for network security protocols other than
TLS. The QUIC protocol is a prime candidate for exper-
imentation, due to its consolidation of traditionally sepa-
rate network layers, connection multiplexing, and use of
UDP. These features would further test the ﬂexibility of
the POSIX socket API for modern security protocols.
10 Related Work
There is a large body of work that covers the insecurity of
applications using security libraries and methods to im-
prove certiﬁcate validation in particular, some of which
we reference in Section 2. Here we outline related work
that aims at simplifying and securing TLS libraries, and
improving administrator control.
Simpliﬁed TLS libraries: libtlssep is a simpliﬁed
userspace library for TLS that uses privilege separation
to isolate sensitive keys and other data it uses from the
rest of the application, which reduces the payoff for ma-
licious parties exploiting application bugs [1]. This ef-
fort resulted in a signiﬁcant security improvement, but
developers still have to learn and interface with the new
library, which still requires the addition of hundreds of
lines of code for applications. The OpenSSL fork Li-
breSSL [20] contains libtls, a simpliﬁed userspace li-
brary for TLS that also removes vulnerable protocols
such as SSL 3.0. However, nearly a hundred functions
are still exported to developers and the library offers no
advantage over OpenSSL for administrator control. Se-
cure Network Programming (SNP) [25] is an older secu-
rity API that predates OpenSSL and SSL/TLS. This API
814    27th USENIX Security Symposium
USENIX Association
allowed programs to use the GSSAPI to access security
services in a simpliﬁed way that resembled the Berkeley
sockets API (which heavily inﬂuenced the POSIX socket
API). We further this idea by using, rather than emulat-
ing, the POSIX socket API and use it for modern TLS.
Collectively, prior work also largely ignores the suitabil-
ity of their APIs to languages other than C/C++, which
limits their utility to a large amount of developers.
Administrator control over TLS: Fahl et al. [9],
MITHYS [5] and two other solutions, TrustBase [18] and
CertShim [3], provide administrator and operating sys-
tem control over TLS certiﬁcate validation. Under these
systems, an administrator can enforce proper validation
by most, if not all, applications on their machines. With
the latter three, administrators can even customize cer-
tiﬁcate validation by employing plugins that strengthen
validation (e.g., revocation checks, DANE [13], etc.) As
a consequence, these systems remove the burden on de-
velopers to implement correct validation. However, these
systems fall short of providing administrator control over
more than certiﬁcate validation, and all but TrustBase
only function with applications written in speciﬁc lan-
guages. In contrast, the SSA provides administrator con-
trol of numerous other aspects of TLS (version, ciphers,
extensions, sessions, etc.) as well as certiﬁcate valida-
tion (which can use TrustBase behind the scenes). Ap-
ple’s App Transport Security [2] (ATS) is a feature of
iOS 9+ that mandates that applications use modern TLS
standards for their connections. Applications can add
explicit exceptions to this as needed, and even disable
it entirely. The SSA both enforces administrator pref-
erences and provides a means whereby developers can
easily migrate to using modern TLS. While the SSA en-
ables developers to increase security, they are not able to
decrease it.
11 Conclusion
Our work explored TLS library simpliﬁcation and fur-
thering administrator control through the POSIX socket
API. Our analysis of OpenSSL and how applications use
it revealed that developers tend to adopt library defaults,
make mistakes when specifying custom settings, imple-
ment boilerplate functionality that is best implemented
by the operating system, and conﬁgure TLS usage based
on compile-time arguments supplied by administrators.
These ﬁndings informed the design of our API, and
we ﬁnd that TLS usage ﬁts well within the conﬁnes of
the existing POSIX socket API, requiring only the ad-
dition of constant values to three functions (socket,
getsockopt, setsockopt) to support TLS functional-
ity. In our use of the SSA we ﬁnd that it is easy to port
existing secure applications to the SSA and add TLS
support to insecure applications, requiring as little as
one line of code. Our prototype implementation demon-
strates the API in practice, showing good performance
versus OpenSSL. We demonstrate that our implementa-
tion can support additional programming languages eas-
ily, adding support for three other language implementa-
tions with less than twenty lines of code each. We also
ﬁnd that existing applications can be dynamically forced
to use the SSA, enabling greater administrator control.
Overall, we feel that the POSIX socket API is a natural
ﬁt for a TLS API and many avenues are available for fu-
ture work, especially with alternative implementations.
References
[1] AMOUR, L. S., AND PETULLO, W. M.
Improving applica-
In Security, Pri-
tion security through TLS-library redesign.
vacy, and Applied Cryptography Engineering (SPACE). Springer,
2015, pp. 75–94.
[2] APPLE INC. What’s new in iOS.
https://developer.
apple.com/library/archive/releasenotes/General/
WhatsNewIniOS/Articles/iOS9.html#/apple_ref/doc/
uid/TP40016198-SW1. Accessed: 01 June 2018.
[3] BATES, A., PLETCHER, J., NICHOLS, T., HOLLEMBAEK, B.,
TIAN, D., BUTLER, K. R., AND ALKHELAIFI, A. Securing
In ACM
SSL certiﬁcate veriﬁcation through dynamic linking.
Conference on Computer and Communications Security (CCS)
(2014), pp. 394–405.
[4] BRUBAKER, C., JANA, S., RAY, B., KHURSHID, S., AND
SHMATIKOV, V. Using frankencerts for automated adversarial
testing of certiﬁcate validation in SSL/TLS implementations. In
IEEE Symposium on Security and Privacy (SP) (2014), IEEE,
pp. 114–129.
[5] CONTI, M., DRAGONI, N., AND GOTTARDO, S. MITHYS:
Mind the hand you shake-protecting mobile devices from SSL us-
age vulnerabilities. In Security and Trust Management. Springer,
2013, pp. 65–81.
[6] COOPER, D., SANTESSON, S., FARRELL, S., BOEYEN, S.,
HOUSLEY, R., AND POLK, W. Internet X.509 public key infras-
tructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle.
RFC 5280, RFC Editor, May 2008. http://www.rfc-editor.
org/rfc/rfc5280.txt.
[7] EDGE, J. TLS in the kernel. https://lwn.net/Articles/
666509/. Accessed: 15 December 2017.
[8] FAHL, S., HARBACH, M., MUDERS, T., BAUMG ¨ARTNER, L.,
FREISLEBEN, B., AND SMITH, M. Why Eve and Mallory love
In ACM
Android: An analysis of Android SSL (in) security.
Conference on Computer and Communications Security (CCS)
(2012), ACM, pp. 50–61.
[9] FAHL, S., HARBACH, M., PERL, H., KOETTER, M., AND
SMITH, M. Rethinking SSL development in an appiﬁed world.
In ACM Conference on Computer and Communications Security
(CCS) (2013), ACM, pp. 49–60.
[10] FOUNDATION, O. S. 1.0.2 manpages. https://www.openssl.
Accessed:
org/docs/man1.0.2/ssl/SSL_CTX_new.html.
15 December 2017.
[11] GEORGIEV, M.,
IYENGAR, S., JANA, S., ANUBHAI, R.,
BONEH, D., AND SHMATIKOV, V. The most dangerous code in
the world: validating SSL certiﬁcates in non-browser software.
In ACM Conference on Computer and Communications Security
(CCS) (2012), ACM, pp. 38–49.
USENIX Association
27th USENIX Security Symposium    815
[12] HE, B., RASTOGI, V., CAO, Y., CHEN, Y., VENKATAKRISH-
NAN, V., YANG, R., AND ZHANG, Z. Vetting SSL usage in
applications with SSLint. In IEEE Symposium on Security and
Privacy (SP) (2015), IEEE, pp. 519–534.
[13] HOFFMAN, P., AND SCHLYTER, J. The DNS-based authenti-
cation of named entities (DANE) transport layer security (TLS)
protocol: TLSA. Internet Requests for Comments, August 2012.
http://www.rfc-editor.org/rfc/rfc6698.txt.
[14] HOLT, M. Caddy. https://caddyserver.com/. Accessed:
15 April 2018.
[15] MAVROGIANNOPOULOS, N.
Fedora system-wide crypto
http://fedoraproject.org/wiki/Changes/
policy.
CryptoPolicy. Accessed: 15 December 2017.
[16] MAVROGIANNOPOULOS, N., TRMA ˇC, M., AND PRENEEL, B.
A Linux kernel cryptographic framework: decoupling crypto-
graphic keys from applications. In ACM Symposium on Applied
Computing (2012), ACM, pp. 1435–1442.
[17] OLIVEIRA, D., ROSENTHAL, M., MORIN, N., YEH, K.-C.,
CAPPOS, J., AND ZHUANG, Y. It’s the psychology stupid: how
heuristics explain software vulnerabilities and how priming can
illuminate developer’s blind spots. In Annual Computer Security
Applications Conference (ACSAC) (2014), ACM, pp. 296–305.
[18] O’NEILL, M., HEIDBRINK, S., RUOTI, S., WHITEHEAD, J.,
BUNKER, D., DICKINSON, L., HENDERSHOT, T., REYNOLDS,
J., SEAMONS, K., AND ZAPPALA, D. TrustBase: An architec-
ture to repair and strengthen certiﬁcate-based authentication. In
USENIX Security Symposium (2017).
[19] ONWUZURIKE, L., AND DE CRISTOFARO, E. Danger is my
middle name: experimenting with SSL vulnerabilities in Android
apps. In ACM Conference on Security & Privacy in Wireless and
Mobile Networks (WiSec) (2015), ACM, pp. 1–6.
[20] OPENBSD. LibreSSL. https://www.libressl.org/. Ac-
cessed: 12 May 2017.
[21] PROJECTS, T. C. CRLSets. https://dev.chromium.org/
Home/chromium-security/crlsets. Accessed: 23 May
2018.
[22] SANTESSON, S., MYERS, M., ANKNEY, R., MALPANI, A.,
GALPERIN, S., AND ADAMS, C. X.509 internet public key in-
frastructure online certiﬁcate status protocol - OCSP. RFC 6960,
RFC Editor, June 2013. http://www.rfc-editor.org/rfc/
rfc6960.txt.
[23] SOUNTHIRARAJ, D., SAHS, J., GREENWOOD, G., LIN, Z.,
AND KHAN, L. SMV-HUNTER: Large scale, automated detec-
tion of SSL/TLS man-in-the-middle vulnerabilities in Android
In Network and Distributed System Security Symposium
apps.
(NDSS) (2014).
[24] WIKI, U. AppArmor proﬁles. https://wiki.ubuntu.com/
SecurityTeam/KnowledgeBase/AppArmorProfiles. Ac-
cessed: 23 May 2018.
[25] WOO, T. Y., BINDIGNAVLE, R., SU, S., AND LAM, S. S. SNP:
An interface for secure network programming. In USENIX Sum-
mer Technical Conference (1994), pp. 45–58.
[26] YAMAGUCHI, F., GOLDE, N., ARP, D., AND RIECK, K. Mod-
eling and discovering vulnerabilities with code property graphs.
In IEEE Symposium on Security and Privacy (SP) (2014), IEEE,
pp. 590–604.
816    27th USENIX Security Symposium
USENIX Association