# 【技术分享】渗透测试技术之本地文件包含
|
##### 译文声明
本文是翻译文章，文章来源：exploit-db.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
翻译：[pwn_361](http://bobao.360.cn/member/contribute?uid=2798962642)
预估稿费：190RMB
投稿方式：发送邮件至[linwei#360.cn](mailto:PI:EMAIL)，或登陆[网页版](http://bobao.360.cn/contribute/index)在线投稿
**概述**
****
通过加强对本地文件包含(LFI)渗透测试技术的研究，可以帮助渗透测试人员和学生在未来的渗透测试过程中，识别和测试LFI漏洞。在[Web程序渗透测试](https://www.aptive.co.uk/penetration-testing/web-application/)中，利用本文中的技术发现的LFI漏洞是渗透测试中的典型漏洞。此外，在本文中提到有一些技术，在CTF大赛中也经常被利用。
**什么是本地文件包含(LFI)漏洞?**
LFI允许攻击者通过浏览器包含一个服务器上的文件。当一个WEB应用程序在没有正确过滤输入数据的情况下，就有可能存在这个漏洞，该漏洞允许攻击者操纵输入数据、注入路径遍历字符、包含web服务器的其他文件。
**漏洞代码实例**
如下图，这是一个存在本地文件包含漏洞的PHP代码：
**在WEB应用程序中识别LFI**
LFI漏洞很容易被识别和利用。任何一个包含WEB服务器文件的脚本，对于下一步的LIF测试，都是一个很好的切入点，例如：
对于渗透测试人员，可以尝试通过操纵文件位置参数来利用它，就像是这样的：
上面是为了显示出在UNIX或LINUX系统中/etc/passwd文件的内容。
下图是在一个WEB应用程序中，成功利用LFI漏洞的例子：
**PHP封装**
PHP的大量封装经常被滥用，有可能导致绕过输入过滤。
**PHP Expect封装**
PHP的“expect://”允许执行系统命令，不过，PHP expect模块在默认情况下是没有启用的。
**PHP file://封装**
下图是一个带有payload的POST请求：
下图利用php://input攻击DVWA，包含了一个“ls”命令，如下：
攻击后的响应情况如下图：
**PHP php://filter**
PHP
php://filter允许渗透测试人员包含本地文件，并将输出数据用BASE64编码。当然，用BASE64编码的输出数据需要经过解码，还原出原始内容。
攻击实例如下：
运行结果如下：
然后对输出结果进行BASE64解码。
如上所示，已经还原出原始内容。
当然，php://filter也可以在不用BASE64编码(编码应该是为了隐藏目的)的情况下输出结果：
结果如下：
**PHP ZIP封装LFI**
PHP
ZIP封装主要在服务器端处理上传的.zip文件，攻击者可以通过一个存在漏洞的文件上传功能，上传一个ZIP文件，并通过LFI来执行服务器端的ZIP过滤器。一个典型的攻击实例看起来是这样的：
1.创建一个PHP反弹SHELL(SHELL.php)。
2.将其压缩成一个.zip文件。
3.将这个.zip文件上传到远程服务器。
4.利用PHP ZIP封装提取PHP SHELL，使用“php?page=zip://path/to/file.zip%23shell”。
5.上面的命令会将提取的文件存储为名为SHELL.php的文件，如果服务器端没有添加.php后缀，可以通过重命名来添加。
如果文件上传功能不允许上传ZIP文件，可以尝试利用各种方法绕过文件上传限制(参见: OWASP file upload testing document)。
**通过/proc/self/environ执行LFI**
通过本地文件包含漏洞,查看是否可以[包含/proc/self/environ](http://www.thinksaas.cn/topics/0/662/662092.html)文件。然后向User-Agent头中注入PHP代码有可能会攻击成功。如果代码被成功注入到User-Agent头中，本地文件包含漏洞会利用并执行/proc/self/environ，用于重新加载环境变量，最后会执行你的反弹shell。
**空字节技术**
通过在URL编码中增加“空字节”，比如“00%”，在某些情况下能绕过WEB应用程序中的过滤。通常，增加空字符后，后端的WEB应用程序对该输入有可能会放行或不处理，从而可以绕过WEB应用黑名单过滤器。
下面是一些特殊的LFI空字节注入的实例：
**截断LFI绕过**
截断是另一个绕过黑名单的技术，通过向有漏洞的文件包含机制中注入一个长的参数，WEB应用有可能会“砍掉它”(截断)输入的参数，从而有可能绕过输入过滤。
LFI截断实例：
**日志文件污染**
日志文件污染是通过将注入目标系统的代码写入到日志文件中。通常，访问目标系统上的某些对外开放的服务时，系统会自动将访问记录写入到日志文件中，利用这个机制，有可能会将代码写入到日志中。例如，利用一个包含PHP反弹shell的URL访问目标系统时，目标系统会返回一个404页面，并将创建一个apache的访问记录，记录中会包含之前的PHP反弹shell。利用之前已经发现的文件包含漏洞，可以解析apache的日志文件，从而执行日志中的PHP反弹shell。
在将源代码导入到目标系统的日志文件之后，下一步就是确定日志文件的位置。在对WEB服务器进行渗透测试的侦察和发现阶段，通常我们都会通过扫描来收集目标系统的信息，一个好的出发点是查找被识别的操作系统和WEB服务器的默认日志路径。结合“Burp
intruder”和“[FuzzDB的Burp
LFI载荷列表](https://github.com/tennc/fuzzdb/tree/master/dict/BURP-PayLoad/LFI)”，我们可以很快在目标系统中识别出有效的日志文件位置。
下面是一些常用的、在linux或UNIX上对外开放的服务：
    Apache/Nginx
可以使用netcat将代码注入到WEB服务器访问或错误日志中，然后通过之前发现的LFI漏洞，解析本地的日志文件。如果WEB服务器的日志文件太长，执行你的代码可能需要一些时间。
**通过邮件给目标机器发送一个反弹shell**
如果目标机器直接或通过网络上的另一台机器转发电子邮件，并将邮件存储在系统的www-data用户下(或者其它apache的用户)，通过电子邮件给目标发送一个反弹shell是完全有可能的。如果域名不存在MX记录，但是SMTP对外可以访问，那么就有可能连接到目标邮件服务器，并向www-data/apache用户发送邮件。邮件要发送到当前正在运行apache的用户上，这才能确保用户帐户有权限访问到该用户的邮件数据目录，及数据中注入的PHP反弹shell。在该实例中，用户帐户是www-data，邮件目录是/var/spool/mail/www-data。
在实际攻击中，首先使用一个已知的UNIX/LINUX帐户名称列表来对目标系统进行枚举，如下：
如上图：使用smtp-user-enum脚本确认www-data用户帐户存在于系统中。
下面的图片显示通过telnet给www-data用户发送邮件的过程：
下图显示的www-data邮件脱机文件中含有被发送过去的PHP反弹shell代码。
利用netcat监听本地80端口，用于目标系统中PHP反弹SHELL的回连，如下图，PHP SHELL成功反弹：
**参考**
DVWA(用于LFI实例):