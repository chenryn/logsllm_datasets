of ﬁve design choices: (i) centrality measure, (ii) β parameter-
ization, (iii) visited node deletion, (iv) loop removal, and (v) α
parameterization. For each design choice experiment, we run
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 13:01:25 UTC from IEEE Xplore.  Restrictions apply. 
102203
EntropicK-SchedulerDefault0510152025Time (hour)4050607080Feature coverage (k)0510152025Time (hour)2530354045Feature coverage (k)0510152025Time (hour)5678910111213Feature coverage (k)0510152025Time (hour)6810121416Feature coverage (k)0510152025Time (hour)12345678Feature coverage (k)0510152025Time (hour)4.44.64.85.05.25.45.6Feature coverage (k)0510152025Time (hour)293031323334Feature coverage (k)0510152025Time (hour)405060708090100Feature coverage (k)0510152025Time (hour)1314151617Feature coverage (k)0510152025Time (hour)4567891011Feature coverage (k)0510152025Time (hour)2.42.62.83.03.23.4Feature coverage (k)0510152025Time (hour)25303540455055Feature coverage (k)freetype
harfbuzz
openthread
libjpeg
lcms
libpng
re2
sqlite
openssl
vorbis
zlib
libxml2
Fig. 6: The arithmetic mean edge coverage of of AFL-based seed schedulers running for 24 hours and one standard deviation error
bars over 10 runs. Default refers to the default seed scheduler in AFL.
K-Scheduler with Libfuzzer on the 12 Google FuzzBench
programs for 1 hour, repeated 10 times, and compare their
feature coverage. We run for 1 hour because the ﬁrst hour of
a fuzzing run often discovers more coverage than later hours
and hence our results better measure the effect of the design
choices. We also choose feature coverage because it provides
more ﬁne-grained information about a fuzzer’s behavior than
edge coverage. We describe each design choice experiment in
more detail below.
1) Centrality measure: We measure the effect of the cen-
trality measure on seed scheduling in this experiment by
varying the centrality measure used in K-Scheduler. We
compare Eigenvector, Degree, Katz and PageRank central-
ity measures. Table IX shows the feature coverage results.
Enabling Katz centrality improves the feature coverage by
16.54%, 23.69%, and 19.17% in arithmetic mean over the 12
FuzzBench programs, relative to Pagerank, Eigenvector, and
Degree centrality, respectively. These results experimentally
justify our claim from Section II that Katz centrality is most
desirable for seed scheduling. However, these results also show
that for some programs, other forms of centrality are a better
ﬁt such as the superior performance of Pagerank on re2 and
Degree on vorbis.
TABLE IX: Arithmetic mean feature coverage of K-Scheduler
with different centrality metrics.
Programs
freetype
libxml2
lcms
harfbuzz
libjpeg
libpng
openssl
openthread
re2
sqlite
vorbis
zlib
Katz Pagerank Eigenvector Degree
51,184
39,240
2,886
35,017
10,974
5,001
14,520
6,525
31,292
73,532
9,106
2,711
44,394
29,575
2,071
28,563
9,250
4,804
13,035
5,201
32,309
68,328
8,129
2,410
40,723 38,332
28,473 28,014
1,557
2,054
26,253 27,485
10,454
8,713
4,505
4,923
13,385 13,555
5,380
5,298
29,648 29,595
65,538 63,997
9,363
7,470
2,323
2,404
Arithmetic mean coverage gain
Median coverage gain
16.54%
13.89%
23.69% 19.17%
18.99% 19.03%
2) β parameterization: In Section IV, we describe how we
set β based on historical mutation data. In this comparison, we
see the effect of this technique by comparing K-Scheduler
with uniform β against K-Scheduler with non-uniform β.
Table X shows the feature coverage results. The non-uniform β
technique increases feature coverage by 24.19% in arithmetic
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 13:01:25 UTC from IEEE Xplore.  Restrictions apply. 
112204
RarePath-AFLFastK-Scheduler-AFLDefault-AFLNewPath-EcoFuzzRareEdge-FairFuzzSecCov-TortoiseFuzz0510152025Time (hour)90001000011000120001300014000Edge coverage0510152025Time (hour)7500800085009000950010000Edge coverage0510152025Time (hour)50005200540056005800Edge coverage0510152025Time (hour)1600180020002200240026002800Edge coverage0510152025Time (hour)80010001200140016001800200022002400Edge coverage0510152025Time (hour)138014001420144014601480150015201540Edge coverage0510152025Time (hour)52005400560058006000Edge coverage0510152025Time (hour)950010000105001100011500120001250013000Edge coverage0510152025Time (hour)410042004300440045004600470048004900Edge coverage0510152025Time (hour)170018001900200021002200Edge coverage0510152025Time (hour)740750760770780790Edge coverage0510152025Time (hour)60007000800090001000011000Edge coverageTABLE X: Arithmetic mean feature coverage from analyzing
the effect of non-uniform β.
TABLE XIII: Arithmetic mean feature coverage from analyzing
the effect of deleting visited nodes.
Programs
freetype
libxml2
lcms
harfbuzz
libjpeg
libpng
openssl
openthread
re2
sqlite
vorbis
zlib
Non-uniform β
51,184
39,240
2,886
35,017
10,974
5,001
14,520
6,525
31,292
73,532
9,106
2,711
Arithmetic mean coverage gain
Median coverage gain
Uniform β
40,396
31,733
1,506
29,380
8,834
4,761
12,542
5,271
28,263
64,893
7,679
2,305
24.19%
18.88%
Programs
freetype
libxml2
lcms
harfbuzz
libjpeg
libpng
openssl
openthread
re2
sqlite
vorbis
zlib
Original
51,184
39,240
2,886
35,017
10,974
5,001
14,520
6,525
31,292
73,532
9,106
2,711
Deleted
39,892
28,973
1,493
24,667
9,715
4,827
13,121
5,712
29,408
61,609
8,020
2,470
Arithmetic mean coverage gain
Median coverage gain
24.13%
13.89%
TABLE XI: Arithmetic mean feature coverage from analyzing
the effect of α.
Programs
freetype
libxml2
lcms
harfbuzz
libjpeg
libpng
openssl
openthread
re2
sqlite
vorbis
zlib
0.5
51,184
39,240
2,886
35,017
10,974
5,001
14,520
6,525
31,292
73,532
9,106
2,711
0.25
38,369
28,644
1,313
27,250
9,542
4,913
13,420
6,216
29,590
64,175
8,092
2,378
0.75
41,777
29,992
1,552
28,276
10,336
4,929
13,302
5,597
31,885
68,550
8,066
2,282
1
40,723
28,473
1,557
26,253
10,454
4,505
13,385
5,380
29,648
65,538
7,470
2,323
Arithmetic mean coverage gain
Median coverage gain
24.53% 19.47% 23.69%
14.29% 14.74% 18.99%
TABLE XII: Arithmetic mean feature coverage from analyzing
the effect of loop removal.
Programs
freetype
libxml2
lcms
harfbuzz
libjpeg
libpng
openssl
openthread
re2
sqlite
vorbis
zlib
loop removal
51,184
39,240
2,886
35,017
10,974
5,001
14,520
6,525
31,292
73,532
9,106
2,711
Arithmetic mean coverage gain
Median coverage gain
no loop removal
38,646
28,737
1,455
28,849
10,142
4,846
13,300
5,430
31,609
64,560
9,350
2,247
21.70%
17.03%
mean over the 12 FuzzBench programs. These results show
the utility of biasing β.
3) Visited node deletion: In Section IV, we describe why
we remove visited nodes from the edge horizon graph. In
this comparison, we experimentally justify this choice. We
compare K-Scheduler with visited node deletions from the
edge horizon graph against K-Scheduler with no deletions
from the edge horizon graph. Table XIII shows the feature
coverage results. The deleted edge horizon graph improves
feature coverage by 24.13% in arithmetic mean over the
12 FuzzBench programs. Therefore, this result justiﬁes our
deletion of visited nodes.
4) Loop Removal: In Section IV, we introduce our loop
removal transform as a technique to mitigate the effects of
loops on computing centrality. In this experiment, we measure
this effect by comparing K-Scheduler with and without the
loop removal transform. Table XII shows that the loop removal
transform improves edge coverage by 21.70% in arithmetic
mean over the 12 FuzzBench programs, justifying our loop
removal transform.
5) α parameterization: In this design choice experiment,
we study how the choice of α affects the K-Scheduler’s
performance. Table XI summarizes our ﬁndings. As described
in Section IV, α = 1 treats far and close paths with equal
contribution to centrality and its experimental results are worse
compared to distinguishing them, showing the utility of the
multipicative decay effect. We note that α = 1 is equivalent
to Eigenvector centrality as seen by comparing the relevant
column from Table IX. Given α = 0.5 performs best in
arithmetic mean over the 12 FuzzBench programs, we pick
it in our current implementation.
Result 4: Our results empirically support K-Scheduler’s
design choices.
F. RQ5: Utility for non-evolutionary input generation
In this experiment, we show the promise of K-Scheduler
in non-fuzzing settings, we integrate K-Scheduler into
concolic execution seed scheduling. Concolic execution is
known to incur high overhead [61, 42] during path constraint
collection and solving. Hence, in concolic execution, schedul-
ing promising seeds is crucial to its performance [16, 63]. To
perform this experiment, we use the concolic executor from
QSYM’s latest version [61]. QSYM, a hybrid fuzzer, consists
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 13:01:25 UTC from IEEE Xplore.  Restrictions apply. 
122205
edge or path coverage [32, 7, 9, 60] as well as more security-
sensitive metrics such as execution time [41, 33], exploitabil-
ity [57], memory accesses [18, 56, 55], or a combination of
them [52, 53] Another line of work prioritizes seeds based
on call graphs [34]. In contrast, we prioritize seeds based on
the entire inter-procedural CFG. While AFLGo [8] also uses
the entire inter-procedural CFG, it computes the distance over
the CFG for directed fuzzing and assigning a seed’s mutation
budget. In contrast, we approximate the count of reachable
and feasible edges from a seed and use it for coverage-
guided fuzzing. SAVIOR [17] also approximates this count
but uses it for bug-driven hybrid testing. Its approximation
assumes all edges are equally likely to be reachable and
feasible, independent of their distance from a seed’s execution
path, which does not hold true for many real-world programs
as we showed in Section VI. In contrast, we use the mul-
tiplicative decay property of Katz centrality to reﬂect this
behavior in real-world programs and better approximate this
count. Moreover, SAVIOR [17]’s approximation is equivalent
to setting α = 1 (i.e, no multiplicative decay) and our
design choice experiments show this approximation performs
worse than K-Scheduler’s default settings. Nonetheless,
both K-Scheduler and SAVIOR utilize the mutation history
information to improve their approximation.
Seed scheduling has also been a topic in other program
testing techniques aside from fuzzing such as concolic ex-
ecution [16, 63]. Our preliminary experiments suggest that
K-Scheduler can improve seed scheduling for concolic
execution.
VIII. CONCLUSION
In this paper, we introduce a new approach to seed schedul-
ing based on centrality analysis of seeds on the CFG. Central-
ity measures have several desirable properties that make them
a natural ﬁt for the seed scheduling problem. We implement
our approach in K-Scheduler and show its effectiveness
in seed scheduling: increasing feature coverage by 25.89%
compared to Entropic and edge coverage by 4.21% compared
to the next-best AFL-based seed scheduler, in arithmetic mean
on 12 Google FuzzBench programs.