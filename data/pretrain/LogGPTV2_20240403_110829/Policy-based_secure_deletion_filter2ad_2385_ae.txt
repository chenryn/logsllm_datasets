protected accordingly. A ﬁle can be accessed as long as its protec-
tion class is accessible according to the deletion policy.
As shown in Figure 4, three directories are involved in operating
a delfs ﬁlesystem. First, secure_dir contains the master key of delfs
and must be backed by erasable memory. It should be accessible
only to the process running delfs and protected against exposure to
any other entity during operation. In practice, it may be a POSIX-
compatible local ﬁlesystem that supports physical secure deletion
and that is never backed up. The delfs prototype uses a small ext2-
formatted partition on a magnetic disk that supports secure deletion
through in-place updates and free-space ﬁlling [23]. Second, bulk
storage is provided by raw_dir, which represents the non-erasable
memory such as a NAS server or cloud storage; only protected ver-
sions of ﬁles and auxiliary data reside here. Finally, the user stores
and accesses protected ﬁles through mount_dir.
When a delfs directory is mounted for the ﬁrst time, an initializa-
tion ﬁle has to be provided as well, which speciﬁes the initial dele-
tion policy and its attributes. All ﬁles written to mount_dir beneﬁt
from secure deletion. Files can be securely deleted by running a
dedicated delfsctl utility and specifying attributes to delete. This
securely deletes ﬁles according to the deletion policy such that an
adversary can no longer recover them later. The adversary might
obtain the contents of secure_dir afterwards and see all data that
has ever been written to raw_dir, but can no longer infer anything
about the data in the deleted ﬁles.
5.2 Attributes and policy speciﬁcation
In order not to burden the user with specifying a deletion pol-
icy graph that may contain hundreds or thousands of possible at-
tributes, delfs implements only restricted deletion policies com-
pared to the model of Section 2. We argue below that these are
sufﬁcient for practical purposes.
All attributes in delfs are partitioned into attribute types such that
every attribute occurs in one type. Types represent the categories
relevant for secure deletion, such as owners, projects, organiza-
tions, or expiration dates. For each attribute type, many different
attribute values can be speciﬁed through enumeration of strings or
by giving a range for numeric attributes. A range is expanded into
an enumeration. A sample delfs attribute speciﬁcation in the initial-
ization ﬁle might look like this (written in libConfig++ syntax):
types = (
{
{
name = "user";
attributes = ["Alice", "Bob", "Charlie"];
implementation = "simple";
},
name = "project";
268invoked. These are further combined according to the delfs policies
through the policy-graph construction in Section 3.5. The resulting
scheme implements the combined model of Section 3.8.
When delfs is invoked for the ﬁrst time on a particular mount
point, the initial policy must be given. The current policy, some
defaults, and auxiliary state are then stored in a system-wide state
ﬁle in the root of raw_dir. Information speciﬁc to a ﬁle, such as
its attribute values, the applicable policy, and the encrypted ﬁle-
encryption key, are stored together with the ﬁle itself in its extended
attributes.
Once the ﬁlesystem is mounted, every new ﬁle created inside
mount_dir is protected according to the policy. The ﬁle takes its
initial attribute values and policy from a special defaults ﬁle, lo-
cated inside the directory where the ﬁle will reside; note that FUSE
makes it possible to obtain the pathname when creating a ﬁle. If
the defaults ﬁle is not present, parent directories in the path to
mount_dir are searched; if no ﬁle defaults ﬁle is found, the system-
wide initial policy stored in raw_dir is applied. An example delfs
defaults ﬁle may contain:
Figure 5: An illustration of the two delfs policies preferred and
conﬁdential as described in the text. The attribute type expira-
tion uses the tree implementation, indicated by the triangle.
attributes = ["X", "Y", "Z"];
implementation = "simple";
},
{
name = "expiration";
attributes = ["2000", "2099"];
specification = "range",
implementation = "tree";
} );
attributes = ["project=X", "expiration=2013"];
policy = "confidential";
Here, attribute type expiration is speciﬁed as a range, and this
simply maps to an enumeration of the 100 different attributes. The
meaning of implementation is explained in the next section. The
attribute types in delfs model the familiar convention that objects
have typed attributes and that every attribute can have only one
value (for example, attributes of a POSIX ﬁle in the stat structure
or attributes in a tuple of a relational database).
The deletion policy is given as a collection of policies, where
each policy has a name and is represented by a logical expression
over the attribute types, using AND and OR operators. By instanti-
ating every attribute type with all of its possible values, each policy
maps to many different multiple protection classes. Hence, the ex-
act protection class is deﬁned by the policy and the attribute values
associated to a ﬁle. Below is a sample delfs deletion policy from
the initialization ﬁle, as shown in Figure 5:
policies = (
{
{
name = "preferred";
expr = "((user AND project) OR expiration)"; },
name = "confidential";
expr = "(expiration AND project)";
} );
When a ﬁle stored with policy preferred has attributes user =
Bob, project = X, and expiration = 2014, this corresponds to
protection class p5 in the graph of Figure 1. Compared to the dele-
tion policy graph in Section 2, delfs policies support only AND and
OR gates. We discuss how attribute values are associated to ﬁles
below.
5.3 Implementation
delfs implements the constructions of Section 3, with the excep-
tion of threshold gates and the time-tree scheme. The master key
structure M is stored in secure_dir, whereas the auxiliary state S
and all protected data reside in permanent memory under raw_dir.
Every ﬁle stored in delfs is associated to one policy. If more ﬂexi-
bility is required, the policy graph should be extended.
A delfs attribute type with simple implementation corresponds to
a direct secure deletion scheme with one protection class for every
delfs-attribute value according to Section 3.3. For delfs attribute
types with tree implementation, which are typically those with a
large number of attribute values, the construction of Section 3.6 is
The user can perform regular ﬁlesystem operations on the ﬁles
under delfs without affecting their deletion policy, as long as these
operations leave the extended attributes intact.
Deletion-speciﬁc operations are done through a delfsctl admin-
istrative tool. In particular, (1) it performs secure deletion opera-
tions according to one or more given attributes and may update se-
cure_dir during this operation; (2) it can reclaim space in raw_dir
for ﬁles that have been deleted according to the policy and there-
fore have become inaccessible; and (3) it can manipulate the delfs
policy and modify the attributes of existing ﬁles. However, the
policy graph can only be extended. As this is, strictly speaking,
not captured in our cryptographic model, we note that by allowing
only extensions, each subsequent policy contains also the previous
ones; hence, the security analysis for the latest policy captures also
the previous states.
When delfs starts, it reads the master key from a ﬁle in secure_dir
and buffers it in the daemon during operation. For every secure
deletion operation, delfs ﬁrst updates the auxiliary state and writes
it back to raw_dir; then it updates the master key and overwrites
the ﬁle in secure_dir with the changed contents.
Note that the design so far has no provision for securely delet-
ing a directory and all its subdirectories. This can be achieved as
follows. A predeﬁned attribute named PARENT exists and can be
used to formulate policies. The attribute may occur directly in a
deletion policy. It represents the presence, in the ﬁlesystem, of the
parent directory of a ﬁle, such that deleting that directory through
a ﬁlesystem command triggers a secure deletion operation for the
attribute PARENT on the children of the directory. Its implementa-
tion uses the tree construction of Section 3.6 with the topology of
the ﬁlesystem tree and metadata maintained in per-directory state
ﬁles. All delfs operations that modify the directory tree may thus
implicitly modify the auxiliary state.
5.4 Evaluation
The prototype uses AES-256 for secret-key encryption in the
delfs-speciﬁc code and the “standard conﬁguration” of EncFS with
AES-192 encryption. For the policy described in Figure 5, delfs
has a master key composed of 7 encryption keys. The auxiliary
state stores one ciphertext per edge and two ciphertexts per inte-
rior node plus the auxiliary data for the expiration tree, i.e., 201
ciphertexts in total with a binary tree of depth 7; all ciphertexts are
269encryptions of 256-bit AES keys. Every read and write operation
has an overhead of 8 AES operations for the conﬁdential protection
class and of 12 AES operations for the preferred protection class,
whereby all paths leading to the protection class’ node are evalu-
ated in the straightforward manner. In principle, the key-derivation
could be optimized only for the necessary nodes; however, delfs re-
sorts to caching and evaluates the whole graph only once at mount
time. Every delete operation merely removes entries from the mas-
ter key for the direct policies, performs the re-encryptions (in the
auxiliary storage) for each of the 7 levels of the policy tree, and up-
dates the root key stored in the delfs master key. The master key ﬁle
is overwritten with the master key from the cached representation
to complete the deletion operation.
The actual time incurred for secure deletion mainly depends on
the choice of storage medium for the master key. When using
a small ext2-formatted partition, one should also ﬁll the ﬁlesys-
tem with arbitrary data, in order to overwrite any potentially freed
blocks from the master-key ﬁle. Measuring the performance of
reading and writing ﬁles protected with EncFS and delfs shows that
delfs introduces only a negligible overhead, as the encryption and
decryption of the payload dominates the read and write operations.
Acknowledgments
We thank Robert Haas, Alexis Hafner, and Anıl Kurmu¸s for inter-
esting suggestions and discussions about this topic.
This work has been supported in part by the European Union’s
Seventh Framework Programme (FP7/2007–2013), grant number
ICT-257243 TCLOUDS.
6. REFERENCES
[1] M. J. Atallah, M. Blanton, N. Fazio, and K. B. Frikken.
Dynamic and efﬁcient key management for access
hierarchies. ACM Transactions on Information and System
Security, 12(3), 2009.
[2] M. J. Atallah, M. Blanton, and K. B. Frikken. Incorporating
temporal capabilities in existing key management schemes.
In Proc. 12th European Symposium On Research In
Computer Security (ESORICS), volume 4734 of Lecture
Notes in Computer Science, pages 515–530. Springer, 2007.
[3] J. Bethencourt, A. Sahai, and B. Waters. Ciphertext-policy
attribute-based encryption. In Proc. 28th IEEE Symposium
on Security & Privacy, pages 321–334, 2007.
[4] D. Boneh and R. Lipton. A revocable backup system. In
Proc. 6th USENIX Security Symposium, 1996.
[5] J. Crampton. Practical and efﬁcient cryptographic
enforcement of interval-based access control policies. ACM
Transactions on Information and System Security, 14(1),
2011.
[6] J. Crampton, K. M. Martin, and P. R. Wild. On key
assignment for hierarchical access control. In Proc. 19th
IEEE Computer Security Foundations Symposium (CSF),
pages 98–111, 2006.
[7] A. De Santis, A. L. Ferrara, and B. Masucci. Efﬁcient
provably-secure hierarchical key assignment schemes.
Theoretical Computer Science, 412:5684–5699, 2011.
[8] G. Di Crescenzo, N. Ferguson, R. Impagliazzo, and
M. Jakobsson. How to forget a secret. In Proc. 16th
Symposium on Theoretical Aspects of Computer Science
(STACS), volume 1563 of Lecture Notes in Computer
Science, pages 500–509. Springer, 1999.
[9] Electronic Frontier Foundation. Surveillance self-defense
project. https://ssd.eff.org/, 2013.
[10] EncFS. EncFS encrypted ﬁlesystem.
http://www.arg0.net/encfs.
[11] European Parliament and Council. Protection of individuals
with regard to the processing of personal data and on the free
movement of such data. Directive 95/46/EC, 1995.
[12] FUSE. Filesystem in userspace.
http://fuse.sourceforge.net/.
[13] R. Geambasu, T. Kohno, A. A. Levy, and H. M. Levy.
Vanish: Increasing data privacy with self-destructing data. In
Proc. 18th USENIX Security Symposium, 2009.
[14] V. Goyal, O. Pandey, A. Sahai, and B. Waters.
Attribute-based encryption for ﬁne-grained access control of
encrypted data. In Proc. 13th ACM Conference on Computer
and Communications Security (CCS), pages 89–98, 2006.
[15] S. Hohenberger and B. Waters. Attribute-based encryption
with fast decryption. In Public Key Cryptography, pages
162–179, 2013.
[16] N. Joukov, H. Papaxenopoulos, and E. Zadok. Secure
deletion myths, issues, and solutions. In Proc. 3rd
International IEEE Security in Storage Workshop (SISW),
2005.
[17] N. Joukov and E. Zadok. Adding secure deletion to your
favorite ﬁle system. In Proc. 3rd International IEEE Security
in Storage Workshop (SISW), 2005.
[18] H. Krawczyk. Perfect forward secrecy. In Encyclopedia of
Cryptography and Security. 2005.
[19] S. Mitra and M. Winslett. Secure deletion from inverted
indexes on compliance storage. In Proc. Workshop on
Storage Security and Survivability (StorageSS), pages 67–72,
2006.
[20] R. Perlman. File system design with assured delete. In Proc.
Network and Distributed Systems Security Symposium
(NDSS), 2007.
[21] Z. N. J. Peterson, R. Burns, J. Herring, A. Stubbleﬁeld, and
A. D. Rubin. Secure deletion for a versioning ﬁle system. In
Proc. 4th USENIX Conference on File and Storage
Technologies (FAST), pages 143–154, 2005.
[22] J. Reardon, S. Capkun, and D. Basin. Data node encrypted
ﬁle system: Efﬁcient secure deletion for ﬂash memory. In
Proc. 21st USENIX Security Symposium, 2012.
[23] J. Reardon, S. Capkun, and D. Basin. SoK: Secure data
deletion. In Proc. 34th IEEE Symposium on Security &
Privacy, 2013.
[24] A. Sahai and B. Waters. Fuzzy identity-based encryption. In
Proc. EUROCRYPT, volume 3494 of Lecture Notes in
Computer Science, pages 457–473. Springer, 2005.
[25] A. Shamir. How to share a secret. Communications of the
ACM, 22(11):612–613, Nov. 1979.
[26] V. Shoup. Sequences of games: A tool for taming complexity
in security proofs. Cryptology ePrint Archive, Report
2004/332, 2004. http://eprint.iacr.org/.
[27] Y. Tang, P. P. C. Lee, J. C. S. Lui, and R. Perlman. FADE:
Secure overlay cloud storage with ﬁle assured deletion. In
Proc. Securecomm, 2010.
[28] M. Wei, L. M. Grupp, F. E. Spada, and S. Swanson. Reliably
erasing data from ﬂash-based solid state drives. In Proc. 9th
USENIX Conference on File and Storage Technologies
(FAST), 2011.
270