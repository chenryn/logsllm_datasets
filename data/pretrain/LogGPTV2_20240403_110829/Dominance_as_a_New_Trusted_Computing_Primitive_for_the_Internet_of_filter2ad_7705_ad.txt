watchdog timer (eAWDT) using a separate STMicroelec-
tronics Nucleo-L053R8 (NL053R8) board [47], featuring
a 32 MHz STM32L053R8 MCU (ARM Cortex-M0+). The
STM32L053R8 cost less than $3 at volume. We chose the
NL053R8 board to simplify our implementation work. The
hardware cost could be reduced to less than $1 by com-
bining a cryptographic co-processor such as the Microchip
ATECC608A [48] (for nonce generation and signature veriﬁ-
cation) with an 8-bit microcontroller such as the Microchip
ATtiny412 [49] (for control logic and universal asynchronous
receiver/transmitter (UART) communication).
We used 200 lines of C code to implement the three functions
of the AWDT interface (i.e., AWDT_Init, AWDT_GetNonce and
AWDT_PutTicket). In addition, we had to include our crypto
library (3,600 lines of code) for the signature check on the
DeferralTicket. The main board calls these functions by
communicating over the UART interface.
AWDT_Init sets the initial counter value and initiates a
periodic timer interrupt (triggered every 1 s) that executes
a callback function to decrease and check the counter value.
When the value becomes zero, it signals one of the general-
purpose input/output (GPIO) pins of the NL053R8 board. This
pin should be connected to the reset pin of the main board
to reset it from the outside. The eAWDT then resets itself
as well by executing SYSRESETREQ. AWDT_GetNonce uses the
NL053R8’s TRNG to generate cryptographically secure nonce
values.
The simplicity of the AWDT interface provides strong
protection of the AWDT against attacks from the main board
and vice versa.
Software AWDT. As an alternative to the eAWDT, we also
implemented the AWDT in software running in TrustZone
on the HBE and the CM3 and using the Memory Protection
Unit (MPU) on the NL476RG. This software implementation
relies on runtime isolation. However, as the AWDT contains
no secrets and, thus, does not require conﬁdentiality, it is not
subject to known side channel or speculative execution attacks.
Our software implementation uses minor variants of the
200 lines of C code running on the eAWDT. On processors
that support TrustZone, we implemented the AWDT code as a
pseudo trusted application (PTA) on OP-TEE [50] in TrustZone.
Our code programs an existing, regular timer whose control
registers can only be accessed from within TrustZone. On the
NL476RG which lacks TrustZone support, we used the MPU
to isolate our AWDT implementation. Due to space limitations,
the rest of this paper discusses only the eAWDT.
C. SolidRun HummingBoard Edge (HBE)
Our HBE features an NXP i.MX6Quad (ARM Cortex-A9)
quad-core processor running at 1 GHz. This processor supports
a variety of security features, including protected key storage,
a cryptographic accelerator, ARM TrustZone, a TRNG, and a
secure real-time clock. The board also has a gigabit Ethernet
controller, 2 GB of DRAM and an 8 GB Embedded Multi-
Media Card (eMMC).
We integrated our boot code into the U-BOOT [51] Sec-
ondary Program Loader (SPL). U-BOOT is a popular boot
loader. The SPL is a small subset of U-BOOT. Its purpose is to
initialize the hardware to the point that full U-BOOT can run.
The SPL for the HBE has to turn on DRAM and processor
caches, load the full U-BOOT binary from eMMC into DRAM
and transfer control to it. We inserted the CIDER boot code into
the SPL after the end of the hardware initialization but before
the loading of the U-BOOT binary. This freed us from having
to write device-speciﬁc initialization code and provided us
with a basic runtime environment and an MMC storage driver.
Table I displays the line counts. As CIDER’s protections (i.e.,
latches, AWDT) are turned on in the SPL, CIDER is protected
from U-BOOT and any binaries it might load (e.g., Linux).
Networking. For convenience, we built the recovery module
out of a stripped-down version of U-BOOT. U-BOOT contains
a driver for the i.MX6 Ethernet controller and a simple
networking stack, which we augmented to support TCP with a
patch [52]. We removed all unnecessary U-BOOT components.
RWLatch protected key storage. The Cryptographic Accel-
eration and Assurance Module (CAAM) of the HBE’s MCU
(i.MX6) provides conﬁdentiality and integrity protection for
critical data blobs with a key that is only accessible by the
CAAM itself. Critically, use of the key is gated by a RWLatch.
The PRIBLOB bits in the Security Conﬁguration Register (SCGFR)
must be 0 for the key to be readable. Software can set the bits
to 1 at any time. Once set to 1, the PRIBLOB bits will retain this
value until the next reset. We use this mechanism to protect
the device private key. At each boot, the CAAM will decrypt
the private key for CIDER. Gated boot then sets the PRIBLOB
bits to 1, disabling access until the next reset.
WRLatch protected code and data storage. The eMMC
standard supports power-on write protection. This feature
allows software to instruct the eMMC device to make parts of
storage read-only until the next reset. All storage of the eMMC
device can be write-protected in this way at 8 MB granularity.
(cid:18)(cid:21)(cid:19)(cid:19)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:53:35 UTC from IEEE Xplore.  Restrictions apply. 
Unfortunately, the HBE does not couple eMMC reset tightly
to processor reset. Instead, it allows the eMMC reset pin to
be controlled by software via GPIO. We solve this problem
with the help of the SECURE_WP_MODE feature of the
eMMC 5.1 standard that allows power-on write protection to
be locked such that resets do not remove it [53]. The lock
and unlock commands are authenticated with a secret number.
At installation time, CIDER sets this number and keeps an
encrypted copy (using the RWLatch). When setting power-on
write protection, CIDER also issues the lock command to the
eMMC device to guard against spurious resets. When needed,
CIDER removes the power-on write protections by issuing the
unlock command and subsequently resetting the eMMC device
by signaling its reset pin via GPIO.
Authenticated watchdog timer. We connected our eAWDT
board to the mikroBus interface on the HBE. We connected the
eAWDT’s reset wire to the reset pin (RST_n) of the mikroBus.
Furthermore, the HBE exposes the HBE’s UART2 through the
mikroBus which we connect to the eAWDT’s UART interface.
Firmware support. We added CIDER support to Windows
10 IoT Core [54] and Debian [55] ﬁrmware by including an
application in the ﬁrmware that communicates with the AWDT
and obtains BootTickets and DeferralTickets. The applica-
tion is periodically woken up at the desired DeferralTicket
fetch interval. It calls AWDT_GetNonce on the eAWDT, requests
a DeferralTicket from the hub and calls AWDT_PutTicket.
The application runs as part of the untrusted ﬁrmware and is
not part of the CIDER TCB. The Windows IoT version is a
Universal Windows Platform (UWP) application consisting of
750 lines of C# code. The Debian version is a Posix application
comprising about 1,100 lines of C code. In both cases, the
majority of the code supports the network communication with
the hub.
D. Raspberry Pi Compute Module 3 (CM3)
The CM3 board features the Broadcom BCM2837 architec-
ture, including an ARM Cortex-A53 quad-core CPU running at
1.2 GHz and 1 GB DRAM. It also has a 4 GB eMMC storage
device and a TRNG, but lacks a RWLatch. As in the case of
the HBE, we integrated the CIDER boot code into the U-BOOT
SPL.
Networking. The CM3 has no built-in networking hardware,
so we connected a USB Ethernet Adapter (around $1.5) to it.
We reused the networking code from the HBE implementation—
except for a different NIC driver.
RWLatch protected key storage. The CM3 lacks a RWLatch.
To solve this problem, we bought an OPTIGA SLB 9670 chip
which supports the TPM 2.0 speciﬁcation [12] at an extra
cost of $2.09 and connected it to the CM3 IO board through
GPIO pins. We used the internal non-volatile storage of the
TPM to host the device private key. We used the commands
TPM2_NV_ReadLock and TPM2_NV_WriteLock to implement the
RWLatch over the internal storage of the TPM. We could also
have used any other TPM 2.0 chip. For example, the AT97SC*
series from Microchip can be as cheap as $0.85 per chip.
WRLatch protected code and data storage. We use
the power-on write protection feature of the eMMC device.
Unfortunately, the CM3 does not connect the eMMC’s reset
pin RST_n to any reset signal. Instead, RST_n is permanently
connected to a pull-up resistor [56]. The result is that power-on
write protection stays on even after a reset. We solved this
problem by soldering a wire to RST_n and connecting it to the
CM3 IO Board’s RUN pin to let them share the same external
reset signal.
Authenticated watchdog timer. The CM3 IO Board exposes
54 GPIO pins. We programmed GPIO 40 and 41 to carry the
UART’s transmit (Tx) and receive (Rx) signals and connected
the corresponding wires of the eAWDT. We also connected
the eAWDT’s reset wire to the IO Board’s RUN pin, allowing
the eAWDT to reset both the processor and the eMMC device.
Firmware support. We added CIDER support
to both
Raspbian and Buildroot-based ﬁrmware [57, 58] by including
the same ticket fetching application we had used for Debian
on the HBE.
E. STMicroelectronics Nucleo-L476RG (NL476RG)
The NL476RG board features an STM32L476RG MCU
(based on ARM Cortex-M4) running at 80 MHz with 1,024 kB
ﬂash memory and 128 kB SRAM, as well as a TRNG. Since U-
BOOT does not run on the NL476RG board, we wrote CIDER
as a bare-metal application. We modiﬁed the NL476RG’s linker
script to physically separate the ﬂash memory regions for
CIDER and the ﬁrmware, and ﬂashed them independently.
Networking. Since the NL476RG board has no networking
hardware, we connected an ESP8266 ESP-12E Wi-Fi module
(around $1) to the board via the UART interface. The module
includes a stand-alone networking stack that supports TCP/IP.
RWLatch protected key, code and data storage. We used
the STM32L476RG MCU’s ﬁrewall feature [59] as a RWLatch.
The ﬁrewall makes it possible to block all access to speciﬁc
address ranges until the next reset.
Right before transferring control to the ﬁrmware, CIDER
conﬁgures the ﬁrewall to block all access to the ﬂash memory
segment storing its secret keys, code and data. The mechanics
of the ﬁrewall require us to copy the code that enables it to an
unprotected region. Any CIDER data that need to be read by the
ﬁrmware (e.g., the boot-nonce) are also copied to unprotected
storage before the ﬁrewall is enabled. Any attempt to access
the protected region results in a device reset.
Authenticated watchdog timer. The NL476RG provides 47
GPIO pins. We chose PA9 and PA10 which can be used for
UART Tx and Rx, respectively, and connected them to the
eAWDT. The NL476RG also has a pin (NRST) to receive an
external reset signal; we connected this pin to the eAWDT’s
reset wire.
Firmware support. Lacking an operating system, we inserted
the ticket fetching code directly into the target applications
while registering a timer interrupt handler to periodically
execute the code. The code mirrors largely that of the Debian
application.
(cid:18)(cid:21)(cid:19)(cid:20)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:53:35 UTC from IEEE Xplore.  Restrictions apply. 
Software TCB
Boot module
CIDER gated boot
CPU & board init
Device drivers
Crypto lib
Recovery module
CIDER control logic
Networking stack
Networking driver
Crypto lib
eAWDT
CIDER control logic
Crypto lib
Exposed
LoC
2,700 ×
4,700 ×
4,500 ×
3,600 (cid:2)
Defense
Isolation in time, Firewalling
Isolation in time, Firewalling
Isolation in time, Firewalling
Formal veriﬁcation
200 (cid:2)
5,200 (cid:2)
1,600 (cid:2)
3,600 (cid:2)
200 (cid:2)
3,600 (cid:2)
Firewalling, Compartmentalization
Firewalling, Compartmentalization
Firewalling, Compartmentalization
Formal veriﬁcation
Firewalling, Simplicity
Formal veriﬁcation
TABLE I: Software TCB of CIDER and the measures CIDER takes
to secure it. The Line of Code (LoC) count is based on CIDER’s
prototype implementation on HBE.
VII. SECURITY ANALYSIS
In this section, we analyze the software TCB of CIDER. We
enumerate its components and describe the techniques we used
to secure it. For concreteness, we focus the discussion on the
HBE variant of the CIDER implementation.
A. Summary of the Software TCB
The CIDER implementation consists of three discrete mod-
ules: the boot module, the recovery module and the AWDT.
Each module contains the same formally veriﬁed cryptographic
library. Table I lists the main components of each module.
Boot module.
In addition to the core part of CIDER gated
boot, the boot module contains device initialization code and
device drivers from the U-BOOT SPL. This includes code
for initializing DRAM and the CPU caches as well as MMC
storage, UART and GPIO drivers.
Recovery module. The recovery module encapsulates the
U-BOOT networking stack augmented with TCP and the HBE
NIC driver. It also contains the U-BOOT MMC storage driver
and a small amount of CIDER control logic for managing the
interaction with the hub, including DICE attestation.
AWDT. The eAWDT software consists of code implementing
the AWDT control logic as well as low-level code for accessing
the UART and the TRNG.
B. Defending the Software TCB
The need to ensure device availability adds a storage driver, a
networking stack, and device-dependent low-level initialization
code to our TCB. As shown in Table I, these components
add a substantial amount of code to CIDER. Much of the
existing work on trusted computing has excluded this code
from its TCB by making availability a non-goal. In this setting,
a modest amount of cryptography and protocol code (e.g., SSL,
encrypted disks) are sufﬁcient to protect the conﬁdentiality
and integrity of data sent to untrusted storage and network
devices. No attempt is made to ensure that these devices are
functioning.
Rather than attempting to make the entire software TCB bug