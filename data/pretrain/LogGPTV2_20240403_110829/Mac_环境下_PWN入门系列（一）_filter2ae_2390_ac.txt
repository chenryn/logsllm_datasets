>  .text:0000000000400826 var_8 = qword ptr -8  
>  = 用来定义一个一个常量  
>  操作符 x ptr 指明内存单元的长度  
>  byte ptr代表是字节单元  
>  word ptr 代表是字单元(两个字节大小)  
>  dword ptr 代表是双字单元(4个字节大小)  
>  qword ptr 代表是四字单元(8个字节大小)
下面是cannary的重点了.
    .text:0000000000400826                 push    rbp
    .text:0000000000400827                 mov     rbp, rsp
    .text:000000000040082A                 sub     rsp, 20h
    .text:000000000040082E                 mov     rax, fs:28h
> 理解这里,我们先掌握一些小知识  
>  调用函数过程涉及到三个寄存器(寄存器可以理解为一个存放值的盒子)  
>  分别是 sp,bp,ip (16位cpu) esp,ebp,eip(32位cpu) rsp,rbp,rip(64位cpu)  
>  rsp用来存储函数调用栈的栈顶地址,在压栈和退栈时发生变化。  
>  rbp用来存储当前函数状态的基地址，在函数运行时不变，用来索引确定函数的参数或局部变量的位置  
>  rip 用来存储即将执行的程序指令的地址, cpu根据eip的存储内容读取指令并执行(程序控制指令模式)  
>  栈空间增长方式是从高地址到地址的,也就是栈顶的地址值是小于栈底的地址值的
我们可以通过gdb调试画出对应的堆栈图
我们复制下push rbp的指令地址,然后打个断点,然后r(run)
我们可以利用`pwndpg`插件很清楚的看到堆栈信息
我们输入`n`程序执行到下一行 (`n ->next`不进入函数 `s->step` 进入函数 )
接着,左边直接找main函数,然后f5,得到代码
这代码逻辑其实很容易看懂，就是一开始`v5`不能等于1926进入else流程的时候,`v5`等于1926就能输出flag
作为一枚pwn萌新,其实感觉还是有点不可思议的,但是转头想想栈溢出覆盖值的概念,就觉得可以理解了。
我们注意下`else`流程哪里，有个`gets(&v4)` 是char类型的,很明显不对劲嘛,`gets`应该读取的是字符串类型
这样我就可以输入无数个字符,这样可能就会导致栈溢出。
然后我们想想,我们可不可以控制`v4`让其溢出去覆盖`v5`的值呢,下面看我操作吧。
我们首先需要确认下`v4`和`v5`的位置
ida反编译直接双击或者鼠标点到`v4` `v5`可以看到相对esp ebp的位置
> v4 rsp+0h rbp-20h  
>  v5 rsp+8h rbp-18h
所以说我们可以直接写exp了。
    #!/usr/bin/python
    # -*- coding:utf-8 -*-    
    from pwn import *
    c = remote('111.198.29.45', '52808')
    c.sendlineafter('Birth?', '1999')
    c.sendlineafter('Name?','A'*8 + p64(1926))
    c.interactive()
其实画个图很好理解
这里因为不需要栈越界所以`canary`保护就没啥用了,如果栈越界的话,那么就会导致canary存的值发生改变,然后比较改变之后程序就会执行`__stack_chk_fail`函数,从而终止程序,后面遇到bypass
cannary保护我再继续深究下具体流程,目前我们还是继续刷题,巩固下前面的知识先。
####  (3) 参考链接
[Canary保护详解和常用Bypass手段](https://www.anquanke.com/post/id/177832)
[Bit,Byte,Word,Dword,Qword](https://www.cnblogs.com/silva/archive/2009/12/08/1619393.html)
[手把手教你栈溢出从入门到放弃](https://paper.seebug.org/271/)
[gdb查看函数调用栈](https://blog.csdn.net/baidu_24256693/article/details/47297209)
[手把手教你玩转GDB(一)——牛刀小试：启动GDB开始调试](http://www.wuzesheng.com/?p=1327)
###  0x4 hello_pwn
####  (1)题目描述及其考点
> pwn！，segment fault！菜鸡陷入了深思  
>  考点: bss段溢出
####  (4)wp
我们首先把文件下载下来,`checksec`一下
还是老套路找入口函数`main`
然后我会直接双击`sub_400686`查看下函数内容.
这样就很容易明白我们的目标是让等式成立。
.assets/image-20191006222315601.png#alt=image-20191006222315601)
我们可以通过`read`控制`unk_601068` 10个字节。
这里涉及到`bss`段的概念
> bss段主要存放未初始化的全局变量  
>  可以看到上面两个变量都是没有进行初始化的。  
>  bss段数据是向高地址增长的,所以说低地址数据可以覆盖高地址数据
所以我们可以直接写出exp了 两者之间的相差4个字节 `0x6B-0x68=0x4`,我们还可0x10-0x4=12字节,
写入`1853186401`=`0x6E756161`小于int范围4字节足矣
    #!/usr/bin/python
    # -*- coding:utf-8 -*-    
    from pwn import *
    ip, port = '111.198.29.45:44975'.split(':')
    # print(ip, port)
    c = remote(ip, port)
    #接收完这个数据之后再发送.其实不要也行,得看服务端处理速度
    c.recvuntil("lets get helloworld for bof") 
    c.sendline('A'*4 + p64(1853186401))
    c.interactive()
####  0x3 参考链接
BSS段的溢出攻击
[Heap/BSS
溢出机理分析[转]](https://www.cnblogs.com/belie8/archive/2012/02/23/2365281.html)
###  0x5 level0
####  (1)题目描述及其考点
> 菜鸡了解了什么是溢出，他相信自己能得到shell  
>  考点: 栈溢出 **return2libc**
这个题目很经典的栈溢出漏洞利用,通过栈溢出来覆盖返回地址,从而调用恶意函数地址。
而且这个漏洞代码非常简洁,很适合新手去学习。
####  (2)wp
第一步套路看保护:
第二步ida搜索入口函数
看到`vulnerable_function`,显然是个提示。
然后看下函数的代码是啥:
然后我们`shift+f12`看下字符串
发现有个`/bin/sh`,
通过xref确定了后门函数:
所以说如果我们能调用这个函数就可以反弹一个shell了。
这个时候基本就可以猜到是栈溢出了覆盖函数返回地址。
我们具体来分析下:
首先我们查看下`write` and `read`函数的文档说明:
> read(int fd,void _buf,size_t nbyte)  
>  ssize_t write(int fd,const void _buf,size_t nbytes)  
>  fd是文件描述符 0是标准输入 1是标准输出  
>  其实很好理解,第一个函数往1里面写入了`hello
> world`,因为1对应的标准输出对象是屏幕,所以就会在屏幕上输出helloworld，就是一个printf的功能。  
>  同理read也是这样,我们直接在屏幕输入的数据就会被读取到buf里面。
这个题目没开`pie`,也就是地址其实就是固定的,所以我们先确定下那个shell函数的地址(函数开始地址): `0000000000400596`
我们继续分析下`read`的问题:
.assets/image-20191007075530589.png#alt=image-20191007075530589)
这里`buf`应该是`char`类型1字节大小,但是读取的时候竟然可以写入0x200的数据,这里的栈大小是`0x80`字节
那个`0x80`怎么算的呢
> rsp+0h 说明这个位置其实就是rsp的位置  
>  rbp-80h 说明rbp距离rsp是0x80h,那么栈的大小不就是rbp-rsp=+0x80大小吗?
这样我们就可以考虑覆盖read函数的返回地址了。
我们可以画个草图,然后用gdb去调试下这个流程就很容易明白覆盖过程了。
这个题目涉及到一个完整的函数调用流程,这里为了照顾跟我一样的萌新,我再细细地继续从0基础说一次。
重新回顾下:
> ebp 作用就是存储当前函数的基地址,运行时保持不变,用来索引函数参数或者局部变量的位置  
>  esp 用来存储函数调用栈顶地址，在压栈是地址减少，退栈是地址增大  
>  eip 指向程序下一条执行指令。
我们简化下概念:  
假设有函数A 函数B
函数A在第二行调用了函数B,也就是说第一行的时候eip指向的就是执行第二行的指令的地址。
    int function A()
    {
      B();
      printf("123");
    }
那么调用完B之后,eip怎么去指向`printf`函数去执行呢,这里就是函数调用栈的关键啦。
首先我们要明确,栈空间是在当前空间开辟的一个独立空间,而且增长方式与当前空间是相反的。
有了这个概念之后,我们继续分析。
假设第三条指令地址(printf函数)是0x3,也就是说B函数执行完之后,eip应该执行0x3
那么执行第二条指令开辟的栈的流程就是:
> 保护现场
首先把0x3 eip信息压入栈内,保留了eip程序执行流程的信息。
然后把当前ebp寄存器的值(调用函数A的基地址)压入栈内,然后更将ebp寄存器的值更新为当前栈顶的地址。
这样调用函数A的ebp信息可以得到保存,同时ebp被更新为被调用函数b的ebp地址。
> 恢复现场
首先pop ebp,然后恢复了调用函数A时候的ebp。
然后pop eip 退出栈,恢复之前的下一条eip指令
可能有些人就在想为啥要这样做?
eip不变不行吗,为啥要入栈作为返回地址存存起来,这里有个小误区,首先在栈空间里也是需要eip的,所以说栈空间的指令执行的时候eip会发生改变,不作为返回地址存起来的话,那么就会丢失程序流程。
理解之后我们画个堆栈图来理解这个题目
这里是开辟了0x80的栈空间
看下地址:
`0xf0-0x70=0x80`
可以看到数据的增长方向(内存地址是随机化的,每次启动都不同)
如果再继续输入的话,就会把ebp给覆盖了。
我们直接可以写exp了。 因为rbp是占用8字节64位寄存器,0x80+0x8=0x88(覆盖rbp之后继续添加数据就覆盖返回地址了)
    #!/usr/bin/python
    # -*- coding:utf-8 -*-    
    from pwn import *
    ip, port = '111.198.29.45:37260'.split(':')
    # print(ip, port)
    c = remote(ip, port)
    # c.recvuntil("lets get helloworld for bof")
    # p64是小端字节序转换
    c.sendline('A'*0x88 + p64(0x400596))
    c.interactive()
## 0x6 总结
因为自己也是一个萌新,所以文章难免有疏漏或者错误的地方,欢迎师傅给我订正。对于网上的pwn教程我个人觉得对新手真的不是特别友好，造成了pwn入门门槛偏高，希望自己能给一些新手带来一些帮助，也希望有师傅能带带我这个pwn萌新谢谢。
还有。。后面我会花时间填好之前那个java代码审计入门教程的坑的。。。不过还是得先准备下老师的考试。。。。。。我会尽快的。。emmmm。
## 0x7 预期计划
由于自己学的比较零碎,后面还是通过继续做题,最后再来个总结的方式,记录下自己的学习过程。
## 0x8 参考链接
[Linux – Pwn 从入门到放弃](https://www.n0tr00t.com/2017/12/15/Linux-Pwn-Rumen~Fangqi.html)