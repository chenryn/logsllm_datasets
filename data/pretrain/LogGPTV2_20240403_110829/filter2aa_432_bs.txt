#define INITW 1
extern  int * initw_1();
extern  int * initw_1_svc();
#define INSERTW 2
extern  int * insertw_1();
extern  int * insertw_1_svc();
#define DELETEW 3
extern  int * deletew_1();
extern  int * deletew_1_svc();
#define LOOKUPW 4
extern  int * lookupw_1();
extern  int * lookupw_1_svc();
extern int rdictprog_1_freeresult ();
#endif /* K&R C */
#ifdef __cplusplus
}
#endif
#endif /* !_RDICT_H_RPCGEN */
它包含了在规格说明文件中所声明的所有常量和数据类型 C 的合法声明。另外，rpcgen
还增加了对远程过程的定义。在这个例子代码中，rpcgen 定义大写的 INSERTW 为 2，因
为规格说明中声明过程 INSERTW 为远程程序的第二个过程。
这里需要解释一下的是 rdict.h 中的外部过程声明。这个被声明的过程构成了客户机端
的 stub 的接口部分。过程名取自业已声明过的过程名，只是将其全部换为小写，并附加上
一个下画线和程序的版本号。例如，我们的规格说明文件的离子声明：远程程序包含有过
程 DELETEW。于是 rdict.h 含有一个对过程 deletew_1 的外部声明。为了理解为什么 rpcgen
要声明这些接口例程，我们可以回顾 stub 接口的部分目的：它允许 rpcgen 选择自己的调用
约定，而又可以让最初的调用过程保持不变。
作为接口 stub 命名的一个离子，让我们考虑过程 insertw。最初的过程将成为服务器的
一部分，而且将保持不变。这样，服务器将具有一个名为 insertw 的过程，它和最初的应用
程序具有相同的参数。为避免命名冲突，服务器必须为接口 stub 过程使用不同的名字。Rpcgen
第十二章  远程过程调用
- 271 -
让服务器端的通讯 stub 调用一个叫做 insertw_1 的接口 stub 过程。该调用使用 rpcgen 所选
择的参数，而且它允许程序员设计 insertw_1 以便能用正确的参数调用 insertw。
对于我们这个字典程序的例子，rpcgen 产生了文件 rdict_clnt.c，这是一个源程序，它
将成为这个分布式客户机端的通信 stub。
下面我们来看看 rpcgen 生成的客户机代码：
/*  Please do not edit this file.
It was generated using rpcgen. */
#include  /* for memset */
#include “rdict.h”
/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };
int *initw_1(void *argp, CLIENT *clnt)
{
static int clnt_res;
memset((char *)&clnt_res, 0, sizeof(clnt_res));
if (clnt_call (clnt, INITW,
(xdrproc_t) xdr_void, (caddr_t) argp,
(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
TIMEOUT) != RPC_SUCCESS) {
return (NULL);
}
return (&clnt_res);
}
int *
insertw_1(char **argp, CLIENT *clnt)
{
static int clnt_res;
memset((char *)&clnt_res, 0, sizeof(clnt_res));
if (clnt_call (clnt, INSERTW,
(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
TIMEOUT) != RPC_SUCCESS) {
return (NULL);
}
return (&clnt_res);
}
int *deletew_1(char **argp, CLIENT *clnt)
{
static int clnt_res;
memset((char *)&clnt_res, 0, sizeof(clnt_res));
- 272 -
Linux网络编程
if (clnt_call (clnt, DELETEW,
(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
TIMEOUT) != RPC_SUCCESS) {
return (NULL);
}
return (&clnt_res);
}
int *lookupw_1(char **argp, CLIENT *clnt)
{
static int clnt_res;
memset((char *)&clnt_res, 0, sizeof(clnt_res));
if (clnt_call (clnt, LOOKUPW,
(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
TIMEOUT) != RPC_SUCCESS) {
return (NULL);
}
return (&clnt_res);
}
该文件为远程程序中的每一个过程准备好了一个通信 stub 过程。像在服务器中一样，
选择过程名字的时候有意避免了冲突。
现在我们来看最后一个文件：rdict_svc.c。它含有服务器所需要的代码。该文件包含服
务器在开始时要执行的主程序。它包括获得一个协议端口号，向端口影射器注册 RPC 程序，
接着便等待接收 RPC 调用。它将每个调用分派给合适的服务器端的 stub 接口。当被调用的
过程响应时，服务器创建一个 RPC 应答并将它发回客户机。
/*  Please do not edit this file.
It was generated using rpcgen. */
#include “rdict.h”
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif
static void rdictprog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
第十二章  远程过程调用
- 273 -
union {
char *insertw_1_arg;
char *deletew_1_arg;
char *lookupw_1_arg;
} argument;
char *result;
xdrproc_t _xdr_argument, _xdr_result;
char *(*local)(char *, struct svc_req *);
switch (rqstp->rq_proc) {
case NULLPROC:
(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
return;
case INITW:
_xdr_argument = (xdrproc_t) xdr_void;
_xdr_result = (xdrproc_t) xdr_int;
local = (char ()(char *, struct svc_req *)) initw_1_svc;
break;
case INSERTW:
_xdr_argument = (xdrproc_t) xdr_wrapstring;
_xdr_result = (xdrproc_t) xdr_int;
local = (char ()(char *, struct svc_req *)) insertw_1_svc;
break;
case DELETEW:
_xdr_argument = (xdrproc_t) xdr_wrapstring;
_xdr_result = (xdrproc_t) xdr_int;
local = (char ()(char *, struct svc_req *)) deletew_1_svc;
break;
case LOOKUPW:
_xdr_argument = (xdrproc_t) xdr_wrapstring;
_xdr_result = (xdrproc_t) xdr_int;
local = (char ()(char *, struct svc_req *)) lookupw_1_svc;
break;
default:
svcerr_noproc (transp);
return;
}
memset ((char *)&argument, 0, sizeof (argument));
if (!svc_getargs (transp, _xdr_argument, (caddr_t) &argument)) {
svcerr_decode (transp);
return;
}
result = (*local)((char *)&argument, rqstp);
if (result != NULL && !svc_sendreply(transp, _xdr_result, result)) {
- 274 -
Linux网络编程
svcerr_systemerr (transp);
}
if (!svc_freeargs (transp, _xdr_argument, (caddr_t) &argument)) {
fprintf (stderr, “unable to free arguments”);
exit (1);
}
return;
}
int main (int argc, char **argv)
{
register SVCXPRT *transp;
pmap_unset (RDICTPROG, RDICTVERS);
transp = svcudp_create(RPC_ANYSOCK);
if (transp == NULL) {
fprintf (stderr, “cannot create udp service.”);
exit(1);
}
if (!svc_register(transp, RDICTPROG, RDICTVERS, rdictprog_1, IPPROTO_UDP)) {
fprintf (stderr, “unable to register (RDICTPROG, RDICTVERS, udp).”);
exit(1);
}
transp = svctcp_create(RPC_ANYSOCK, 0, 0);
if (transp == NULL) {
fprintf (stderr, “cannot create tcp service.”);
exit(1);
}
if (!svc_register(transp, RDICTPROG, RDICTVERS, rdictprog_1, IPPROTO_TCP)) {
fprintf (stderr, “unable to register (RDICTPROG, RDICTVERS, tcp).”);
exit(1);
}
svc_run ();
fprintf (stderr, “svc_run returned”);
exit (1);
/* NOTREACHED */
}
该文件一旦被生成，就可以被编译成为目标代码的形式。在 Linux 系统下，编译它们
的命令是：
gcc –c rdict_clnt.c
gcc –c rdict_svc.c
每个命令用一个 C 源文件产生一个相应的目标文件。目标文件名用后缀“ .o” 替代“ .c”
后缀。例如，rdict_clnt.c 被编译后的目标文件为 rdict_clnt.o。
5．编写 stub 接口过程
第十二章  远程过程调用
- 275 -
rpcgen 产生的文件并没有构成一个完整的程序。它还要求我们必须编写客户机端和服
务器端的接口例程。在远程程序中的每一个远程过程都必须存放在一个接口过程中。
在客户机端，原来的主应用程序控制着处理的进行。它调用接口过程，而它所使用的
过程名和参数类型与最初的那个程序（非分布式版）调用原过程所于使用的完全一样，在
分布式版本中，原来这些过程业已成为远程的了。每个接口过程都必须要将它的参数转换
为 rpcgen 所使用的形式，还必须接着调用响应的客户机端的通信过程。例如，因为最初的
程序含有一个叫做 insertw 的过程，它使用一个指向字符串的指针作为参数，客户机端接口
必须也含有这样一个过程。该接口过程调用 insertw_1，它是 rpcgen 生成的客户机端的通信
stub。
常规的过程参数与通信 stub 所使用的参数间的主要不同在于，rpcgen 生成的所有过程
的参数都使用间接方式。例如，如果最初的过程有一个整形参数，那么，通信 stub 中该过
程的响应的参数必须是一个指向整数的指针。在字典程序中，多数过程要求一个字符串参
数，它在 c 中用一个字符指针（char*）来声明。在响应的通信 stub 中，都要求它们的参数
是一个指向字符指针的指针（char **）。
文件 rdict_cif.c 展示了接口例程如何将参数转换为 rpcgen 产生的代码所期望的形式。
对程序中的每个远程过程，文件中都包含了一个客户机端口的接口过程。
/* rdict_cif.c  包含 initw, insertw, deletew, lookupw 过程 */
#include 
#include 
#include “rdict.h”
/* Client : 客户读
臃
衿鞯谋淞?*/
extern  CLIENT  *handle ;
/* 为返回数据作临时存储 */
static  int     *ret ;
/*********************************************************
initw  客户端的过程接口,调用 initw_1               *
 *********************************************************/
int initw()
{
ret = initw_1 ( 0, handle ) ;
return ret==0?0:*ret ;
}
/*********************************************************
insertw  客户端的过程接口,调用 insertw_1           *
 *********************************************************/
int insertw ( const char* word )
{
char **arg ;
arg = &word ;