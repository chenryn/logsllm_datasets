title:A3: An Extensible Platform for Application-Aware Anonymity
author:Micah Sherr and
Andrew Mao and
William R. Marczak and
Wenchao Zhou and
Boon Thau Loo and
Matt Blaze
A3: An Extensible Platform for Application-Aware Anonymity
Micah Sherr∗ Andrew Mao† William R. Marczak‡
Wenchao Zhou∗ Boon Thau Loo∗ Matt Blaze∗
∗University of Pennsylvania
†Harvard University
{msherr,wenchaoz,boonloo,blaze}@cis.upenn.edu, PI:EMAIL, PI:EMAIL
‡University of California, Berkeley
Abstract
This paper presents the design and implementation of
Application-Aware Anonymity (A3), an extensible plat-
form for deploying anonymity-based services on the In-
ternet. A3 allows applications to tailor their anonymity
properties and performance characteristics according to
speciﬁc communication requirements.
To support ﬂexible path construction, A3 exposes a
declarative language (A3LOG) that enables applications
to compactly specify path selection and instantiation
policies executed by a declarative networking engine.
We demonstrate that our declarative language is sufﬁ-
ciently expressive to encode novel multi-metric perfor-
mance constraints as well as existing relay selection
algorithms employed by Tor and other anonymity sys-
tems, using only a few lines of concise code. We exper-
imentally evaluate the A3 system using a combination
of trace-driven simulations and deployment on Planet-
Lab. Our experimental results demonstrate that A3 can
ﬂexibly support a wide range of path selection and in-
stantiation strategies at low performance overhead.
1
Introduction
In the past decade, there has been intense research [9,
31, 30, 13, 39, 44, 32, 23, 38, 4, 10, 36, 40, 24] into
designing systems that enable parties to communicate
anonymously in the presence of eavesdroppers. Typ-
ically, these systems achieve anonymity by sending a
message through a path of relays before delivering it to
its ﬁnal destination. Broadly speaking, recent innova-
tions have improved relay selection [8, 40, 24, 36]) –
choosing a path of relays to provide high anonymity and
good performance – and path instantiation – establish-
ing necessary state at each relay to enable anonymous
communication.
Despite the proliferation of proposed techniques, we
note that no one-size-ﬁts-all anonymity system exists.
The appropriate relay selection and path instantiation
strategy can vary according to application requirements,
performance characteristics, and additional constraints
imposed by the underlying network. For example, in
the context of relay selection, an anonymous video con-
ferencing system may be willing to achieve weaker
anonymity in exchange for a path that meets its high-
bandwidth, low-latency performance demands. In con-
trast, an anonymous email system may require very
strong anonymity guarantees while imposing no con-
straints on bandwidth or latency.
Similarly, several path instantiation approaches exist.
Onion Routing [30] and Tor’s telescoping scheme [9]
build paths by recursively encrypting and shipping key
material to their constituent nodes. The former con-
structs anonymous paths that have constant length over
their lifetime, while the latter adds the ability to ex-
tend existing anonymous paths. On the other hand, the
Crowds [31] approach relies on the network to make
routing decisions on behalf of the source. Crowds is
best suited for an environment where source routing is
not available and intermediate relay nodes can be trusted
with the identity of the receiver.
In this paper, we present
the Application-Aware
Anonymity (A3) framework: an anonymity system that
enables tradeoffs between anonymity and performance
through highly customizable relay selection and path in-
stantiation strategies. A3 aims to support a wide range
of anonymity-based networked services with different
application-speciﬁc constraints. Applications can lever-
age A3 in a policy-driven fashion by specifying path in-
stantiation and relay selection techniques that meet their
performance and anonymity requirements.
One important element of A3 is the use of declarative
networking [20, 19], a declarative logic-based frame-
work that can efﬁciently execute a high-level protocol
speciﬁcation using orders of magnitude less code than
an imperative implementation. A3 utilizes a declarative
networking system as a policy engine for specifying and
executing relay selection and path instantiation policies.
Our proposed A3LOG declarative language extends
previous declarative networking languages with con-
structs that are added speciﬁcally to enable the speci-
ﬁcation of anonymity systems. For example, we have
integrated the ability to specify user-deﬁned crypto-
graphic primitives for secure communication. We have
also adapted recently proposed extensions for declara-
tive network composition [22] to enable us to develop
reusable components ideal for specifying and customiz-
ing anonymous routing. We demonstrate how these ex-
tensions enable the concise expression of relay selection
and path instantiation algorithms.
A3 is sufﬁciently extensible to support both tradi-
tional node-based as well as recently proposed link-
based [36, 35] relay selection strategies. Node-based
strategies select relays with desirable node properties
(usually bandwidth), whereas link-based strategies bias
relay selection in favor of link characteristics such as la-
tency, AS hop count, or jitter. We demonstrate that both
link- and node-based relay selection strategies, includ-
ing those used by Tor and other systems, can be con-
cisely represented in a few lines of A3LOG code. We also
show how A3LOG compactly encodes the path instanti-
ation algorithms used by these systems. By providing
a ﬂexible framework for realizing both relay selection
and path instantiation policies, A3 enables the rapid de-
velopment, deployment, and testing of both existing and
novel anonymity protocols.
We experimentally evaluate the A3 system through
both trace-driven simulations and a deployment on Plan-
etLab. Our results demonstrate that the A3 system can
ﬂexibly support a wide range of path selection and in-
stantiation strategies at low performance overhead.
2 Related Work
To support diverse applications, the Internet uses a
simple routing scheme in which packets are forwarded
on a best-effort basis towards their intended destinations.
The end-to-end (e2e) performance of Internet paths is
dictated by policies enforced by routers along the path
from source to sink. With the exception of fragmented
portions of the Internet that support IP quality-of-service
features, applications usually have little control over the
performance aspects of their network connections.
An overlay network built on top of the Internet rout-
ing infrastructure can allow users to exercise greater
control over the manner in which their messages are re-
layed, as forwarding can be based on application layer
information. When combined with source-routing, these
networks allow applications the ability to select paths
that meet their speciﬁc requirements (e.g. RON [2] for
robustness).
Overlay networks may also enable anonymous rout-
For example, Tor [9], Onion
ing on the Internet.
Routing [30], Crowds [31], Tarzan [13], Hordes [39],
JAP [10], and MorphMix [32] (among many others) uti-
lize application-layer overlay routing. These anonymity
systems exploit two features of overlay networks: (i) the
ability to obfuscate the addresses of the initiator (sender)
and responder (receiver) while still providing reliable
message delivery; and (ii) in some instances, the abil-
ity to produce anonymous paths that achieve some de-
sirable property (usually high bandwidth) [9, 13, 40].
This paper is principally concerned with the latter as-
pect: We provide mechanisms that allow anonymity sys-
tems to produce desirable paths.
A large volume of existing literature examines meth-
ods for generating high performance anonymous paths.
Tor [9, 8] attempts to achieve high bandwidth paths by
imposing a probability distribution over the set of po-
tential anonymous relays. The probability of a relay
being selected is proportional to its advertised band-
width. Murdoch and Watson have demonstrated that
such a strategy delivers both performance and strong
anonymity [24]. Snader and Borisov offer reﬁnements
to Tor’s strategy, allowing an initiator to tune the per-
formance (quantiﬁed in their work as bandwidth) of its
anonymous paths [40] by deﬁning the degree to which
relay selection is biased in favor of bandwidth. At
one extreme, initiators consistently choose relays with
the highest bandwidth, achieving very high bandwidth
paths at the expense of allowing a small subset of re-
lays to view a signiﬁcantly disproportionate amount of
anonymous trafﬁc [3, 26, 36]. At the other extreme,
initiators may opt to favor anonymity while disregard-
ing performance by selecting relays uniformly at ran-
dom. Given the bandwidth requirements of the partic-
ular application, Snader’s and Borisov’s technique en-
ables the sender to select a point in this anonymity-
vs-performance spectrum. Similarly, we previously in-
troduced tunable link-based routing [36], where initia-
tors can weigh relay selection based on the expected
e2e cost computed using link performance indicators
such as latency, AS hop count, and jitter. We showed
that biasing selection on link characteristics offers some
anonymity beneﬁts over node-based (i.e., bandwidth-
weighted) techniques, since link-based routing reduces
“hotspot nodes” in the network that appear attractive to
all initiators.
This is the ﬁrst paper of which we are aware that
addresses the related problem of extensible anonymous
routing: given the variety of relay selection algorithms
along with their individual performance and anonymity
properties, how should applications produce anonymous
paths that meet their speciﬁc needs? Rather than provid-
ing hardcoded relay selection policies, our proposed A3
anonymity architecture allows applications to load rout-
ing policies at runtime. We show in Section 5 that ex-
isting anonymous routing techniques – including those
described above – may be compactly represented in a
few lines of declarative code. This allows applications to
tune the degree of anonymity-vs-performance, and to se-
lect (and combine) different relay selection techniques.
This work extends our earlier proposal [38] in which
we introduce the concept of using coordinate embed-
ding systems [6, 5] – decentralized algorithms that efﬁ-
ciently map pairwise network distances into virtual coor-
dinates – to produce anonymous paths with low latency.
In contrast to our proposal, this paper presents a com-
plete implementation of the A3 anonymity system and
describes techniques for combining multiple sources of
information (including coordinate embedding systems)
to form high performance paths. This paper also extends
our recent work in which we introduce link-based rout-
ing [36].
In contrast to that work, the A3 anonymity
infrastructure proposed in this paper combines support
for both node- and link-based relay selection strategies.
Additionally, this work introduces the use of declarative
networking [20] to both represent relay selection poli-
cies as well as instantiate anonymous paths.
3 Background on Declarative Networking
Given our use of declarative networking in A3, we
begin by providing some background. The high level
goal of declarative networking is to enable the construc-
tion of extensible architectures that achieve a good bal-
ance of ﬂexibility, performance, and safety. One speci-
ﬁes a declarative networking protocol as a set of queries
in a high-level language. Because such a speciﬁcation
expresses what a program achieves as opposed to how it
operates (the latter style is referred to as imperative pro-
gramming), declarative queries are a natural and com-
pact way to implement a variety of applications – espe-
cially routing protocols and overlay networks, which of-
ten may be expressed as a set of recursive queries. For
example, path-vector and distance-vector routing proto-
cols can be expressed in only a few lines of code [20],
and the Chord [41] distributed hash table in 47 lines of
code [19]1. When compiled and executed, these declar-
ative speciﬁcations perform efﬁciently relative to imper-
ative implementations.
3.1 Datalog
Our A3LOG declarative language is primarily based
on Datalog [29]. A Datalog program consists of a set of
possibly recursive declarative queries, also referred to
as rules. Each rule has the form q :- p1, p2, ...,
pn., which can be read informally as “p1 and p2 and
... and pn implies q”. Here, q is the head of the rule
and p1, p2, ..., pn is a list of literals that constitutes
the body of the rule. Literals are either predicates (also
called relations) with attributes (variables or constants)
or boolean expressions that involve function symbols
(including arithmetic) applied to attributes. A3LOG ex-
tends Datalog by allowing the speciﬁcation of rules with
multiple head literals, i.e.
rules of the form q1, q2,
..., qm :- p1, p2, ..., pn. A rule of this form is
short-hand for the set of m rules where the ith rule is of
the form qi :- p1, p2, ..., pn. A Datalog program
is said to be recursive if a cycle exists through any pred-
icate – such as when a predicate that appears once in a
rule’s body appears in the head of the same rule. A re-
cursive Datalog program is continuously executed until
a ﬁxpoint is reached, i.e. no new facts are derived.
The order in which the rules are presented in a pro-
gram is semantically immaterial;
likewise, the order
predicates appear in a rule is not semantically mean-
ingful. Conventionally, the names of predicates, func-
tion symbols, and constants begin with a lowercase let-
ter, while variable names begin with an uppercase let-
ter. Function calls are prepended by f . An aggregate
construct, which deﬁnes an operation on multiple results
from the rule body, is represented as a special function
in the rule head with its attribute variables enclosed in
angle brackets (<>). To support anonymous relay se-
lection and path instantiation, A3LOG enhances Data-
log with cryptographic functions, random and ranking
aggregates, and composability. We defer discussion of
these additions to Sections 5- 6.
3.2 First Example: All Pairs Reachability
We illustrate A3LOG using a simple example of two
rules that compute all pairs of reachable nodes in a net-
work.
r1 reachable(S,N) :- neighbor(S,N).
r2 reachable(@N,D) :- neighbor(S,N), reachable(S,D).
1In contrast, MIT’s imperative implementation of Chord is several
orders of magnitude larger.
Rules r1 and r2 specify a distributed transitive clo-
sure computation that derives all pairs of nodes that can
reach each other through paths of neighbors. The rules
take as input a local neighbor table stored at each node
S (each fact in the neighbor(S,N) relation denotes that
N is a neighbor of S). Rule r1 is a regular Datalog rule
(i.e. executed locally at a node to derive local facts);
it computes all pairs of nodes reachable within a single
hop from all input neighbor links. Rule r2 expresses
that “if N is the neighbor of S, and S can reach D, then
N can reach D.” The output of interest is the set of all
reachable(S,D) facts, representing reachable pairs of
nodes from S to D. By modifying this simple example,
we can construct more complex routing protocols, such
as the distance vector and path vector routing protocols.
Rule r2 introduces the location speciﬁer – the argu-
ment preﬁxed with the @ symbol – which denotes the
location of each fact derived by the rule head. In rule
r2, all derived reachable(N,D) facts are exported based
on the address encoded in their ﬁrst attribute, (@N). This
means that the execution of rule r2 results in each node
propagating its reachability information to its neighbors
until a distributed ﬁxpoint (i.e. no new facts being de-
rived) is reached.
A3LOG queries are compiled and executed either lo-