methodology results have been incorporated into a 
modified kern_check program that is now capable of 
detecting both types of kernel level rootkits that we have 
previously discussed.  Our modified kern_check program 
is capable of detecting the SuckIT rootkit. 
5. Methods to detect and classify Kernel 
Level Rootkits 
We have looked at various programs that currently exist 
to detect rootkits.   These programs may indicate that 
some type of rootkit is installed on the target system but in 
most cases they fail to indicate the particular rootkit that is 
installed.  We have developed a methodology that will 
detect the presence of kernel level rootkits that redirect 
the System Call Table and present this methodology.  This 
methodology will also work to detect the presence of 
Kernel Level Rootkits that modify the System Call Table.  
Preliminary research indicates that this methodology will 
work on the Linux 2.6 kernel while existing methods may 
not work.  We expect that this methodology will also work 
on other operating systems. 
5.1 Checking the System Call Table against the 
/boot/System.map file 
Checking the System Call Table in kernel memory 
against the /boot/System.map file has already been 
proposed.  This is the technique that the Samhain program 
kern_check utilizes to detect for instances of kernel level 
rootkits.  However, the kern_check program fails to detect 
rootkits of the SuckIT variety as well as to detect any type 
of rootkits on more recent versions of the Linux kernel.     
Our examination of the SuckIT rootkit revealed to us 
the first difference, or ∇  in functionality between SuckIT 
and the program that it replaces.  SuckIT overwrites a 
location in kernel memory that contains the address of the 
system call table.    SuckIT is able to accomplish this by 
querying a specific register within the processor.   It then 
use this information to find the entry point address within 
the kernel for the system call table and overwrites this 
address with the address of a new system call table 
containing the addresses of some malicious system calls 
that SuckIT also creates.  We present an in depth analysis 
of how SuckIT accomplishes this within the appendix of 
this paper.    
We now have a ∇  consisting of a redirected system 
call table address, a new system call table, and some new 
malicious system calls.  We propose that you can use the 
same method that SuckIT uses to query the processor to 
retrieve the address of the system call table to check and 
see if this address has been changed by a rootkit such as 
SuckIT.  The original address is available when the kernel 
is first compiled and this address is stored in the 
/boot/System.map file.  If these addresses differ then a 
more detailed check can be made of the system call table  
that currently exists in kernel memory in order to develop 
a ∇ between the addresses of the system calls that exist in 
system call table within kernel memory and the addresses 
of the system calls that exist in the /boot/System.map file.   
If the /boot/System.map file is current then differences 
between  it and the system call table within kernel memory 
will indicate that redirection of the system calls is 
occurring on the system  and that the system is infected 
with some type of rootkit.  A preliminary signature can be 
established based on the number of system calls that are 
being redirected on the target system.  If two different 
kernel level rootkits change a different number of system 
calls then we can assume we have two different kernel 
level rootkits.  If these two rootkits change the same 
system calls then we can conduct are more detailed 
analysis of each infected system in order to look for 
differences between the two rootkits.   
If we do not have the rootkit source code available we 
can still look for differences though either the kdb 
program or we can copy segments of kernel memory 
through /dev/kmem and examining this data off-line.  We 
can use kdb to examine the actual machine code of the 
malicious system calls since we will have the actual 
addresses of these malicious system calls within kernel 
memory.  We can also try and disassemble these malicious 
system calls manually or through the kdb program if it is 
installed on the system that we are using to investigate this 
kernel level rootkit.   
In any case, we are now able to detect that redirection 
of the system call table is occurring on the target system.  
We do realize that a hacker may be able to develop a 
kernel level rootkit that could provide false information 
concerning the entry point of the system call table within 
the kernel.   At present, however, we are unaware of any 
kernel level rootkit that is able to do this. 
The following figure shows the results of running the 
modified kern_check program on the target system that we 
have previously infected with the SuckIT rootkit. 
Figure 5 - Modified kern_check  results 
These are the exact results that we would expect based 
on our analysis of the SuckIT source code.  SuckIT 
creates 25 new malicious system calls that subvert the 
original system calls.  SuckIT also redirects system call 
table references to the new system call table that has been 
created in kernel memory by the rootkit.  This is indicated 
by the first line of the modified kern_check program 
output which is the address of this new system call table 
(kaddr = cc1e8000).  This address differs from the address 
of the system call table that is stored in the 
/boot/System.map file, which is the address of the original 
system call table on the target system.  We retrieved this 
address by using the grep command to search the 
/boot/System.map file as indicated in the bottom of the 
above figure.  If we run the modified kern_check program 
against this address, no redirection of the system calls 
would be detected.  However, the address that the kernel 
is using to retrieve system calls from the system call table 
is the malicious address since this is the address that we 
retrieve as a result of querying the processor.   
Even if we did not have the SuckIT source code 
available, we could still use this methodology to detect 
that  a kernel level rootkit targeting system calls is 
installed on this system.  If the address that is retrieved 
from the modified kern_check program matches the 
address  from the /boot/System.map file but the addresses  
of specific system calls differ, then a kernel level rootkit 
that modifies the system call table is installed on the 
system.  If the address retrieved by the modified 
kern_check program does not match the /boot/System.map 
address, then a kernel level rootkit that redirects the 
system call table is installed on the target system.   
The /boot/System.map file is created when a Linux 
kernel is compiled.  It should remain consistent for all 
installations of that kernel on a particular architecture.  If 
this file is not available on a particular system the system 
will still work but debugging will be difficult [21].  One 
should be able to retrieve a copy of the /boot/System.map 
file for a standard Linux installation on a particular 
architecture. 
One 
can 
make 
a 
copy 
of 
the 
/boot/System.map for custom installations (e.g. system 
with patches to a kernel) on any critical system when this 
system is first compiled for future reference.    
It is necessary to have a copy of the /boot/System.map 
file in order to run the kern_check program.  However, it 
is possible to build a customized kern_check program for 
a 
specific 
system 
that 
would 
incorporate 
the 
/boot/System.map file for that system which is created 
when the system is first built.  This program would 
contain the information that is stored within the 
/boot/System.map file.  This version of kern_check can be 
used on that specific custom system or on systems of that 
specific configuration and architecture.   This program 
would have to be rebuilt each time a new kernel is 
installed on the computer.   We have not investigated this 
approach in this research. 
A copy of the modified kern_check  program (available 
under the GPL license) is available a the following 
website: 
http://users.ece.gatech.edu/~owen/ 
under 
research.  You could also construct your own program to 
check the system call table following the methodology 
presented within this paper. 
5.2 Analysis of the zk kernel level rootkit 
involving redirection of the system call table. 
We now follow the methodology presented in this paper 
as applied to another rootkit.  The rootkit that we examine 
next is the zk rootkit developed by zaRwT@zaRwt.net. 
The documentation for this rootkit states that many of the 
features concerning patching of the kernel (/dev/kmem 
“Patching”)  were borrowed from  SuckIT.  Therefore, we 
would expect that it is possible to detect the  zk rootkit 
using the methods that we have just presented.  However,  
the documentation talks about additional features that are 
different from what is contained in SuckIT.  Our 
preliminary belief is that zk is a modification to the 
already existing SuckIT rootkit. 
Figure 6 - SuckIT  install and uninstall 
We set up two systems running the Linux 2.14.18 
kernel to be able to compare both the SuckIT and zk 
rootkits. In order to try and identify  some ∇  between 
these two programs.   
We  were able to install SuckIT successfully.  Running 
the modified kern_check program indicated that the 
system was infected with SuckIT. The next step was to 
uninstall SuckIT.  This was successful as indicated in 
figure 6 below.  Running the modified kern_check 
program indicated that the system was no longer infected.  
At this point the system was back to its original clean 
configuration concerning the system call table and the 
system calls that would be used in kernel memory.   
We had to make some changes to the zk rootkit before 
being able to install it, which was similar to what we had 
to do with SuckIT.  Running the modified kern_check 
program on a system infected with zk results in an 
indication that the same 25 system calls that were 
modified by SuckIT are also being modified by the zk 
rootkit.  The results of running the modified kern_check 
program on the zk infected system is similar to the output 
shown in figure 5 which represents the output of running 
the modified kern_check program on a SuckIt infected 
system.  These are the results that we would expect based 
on the documentation from the zk rootkit. 
We then installed zk successfully and verify this with 
the modified kern_check program.  The program indicated 
that the same 25 system calls were suspect.  However we 
were not able to uninstall the zk rootkit program.  This is 
the first indication that SuckIT and zk are not the same.  
We can now look to try and identify some ∇ between 
these two programs.  One of the first things that we 
noticed is that when we try to run the uninstall command 
on the zk rootkit (# ./zk u),  a usage statement is output to 
the screen and the program does not uninstall as indicated 
in figure 7.  This is not the case with SuckIT, the  uninstall 
program for SuckIT (# ./sk u) is successful  
Figure 7 - zk uninstall 
In order to uninstall the zk rootkit, the usage statement 
indicates that a password must be used.  There in no 
reference to this uninstall password within the zk rootkit 
documentation and there is no indication of how to set this 
password.  We used the zk usage statement to try and 
identify a ∇ . 
 We conducted a grep search for the term ‘password’ 
within the source code directory for the zk rootkit.  The 
results of this search indicate that the term ‘password’ 
exists within the client.c source code file.  A file by the 
same name exists for the SuckIT rootkit.  Comparing 
these two files using the resident diff command indicates 
that these two files do in fact differ.  We then conducted a 
more complete search on the zk client.c file.  We 
identified a password ‘kill me’ within the client.c file  The 
following figure shows the results of this search. 
Figure 8 - Uninstall password for zk rootkit 
We are then able to successfully uninstall the zk rootkit 
by using the following command: # ./zk u kill me.  
Running the modified kern_check program on the system 
indicates that the system is no longer infected. 
Having both rootkits installed on a system allows you to 
continue to identify ∇ ’s, or differences between the two 
rootkits.  The string ‘kill me’ can be used as a signature to 
detect instances of the zk rootkit.     Other potential 
signatures can be identified from both rootkits in a similar 
manner. 
6. Conclusion 
We have presented a methodology to detect and classify 
kernel level rootkits exploits involving redirection of the 
system call table within this paper.  The mathematical 
framework presented will help in determining if an 
identified rootkit is an existing rootkit, a modification to 
an existing rootkit or an entirely new rootkit.   A true 
binary  or kernel rootkit should maintain the original  
functionality of the program or programs that it is 
intended to replace plus some added capability introduced 
by the rootkit developer.   
This added capability can be used to characterize the 
rootkit.  Two rootkits that have the same added 
capabilities are the same rootkits. A rootkit that has 
elements of some previously characterized rootkit is a 
modification to that rootkit and a rootkit that has entirely 
new characteristics is a new rootkit.   
We conducted an in-depth analysis of the SuckIT 
rootkit in order to develop a characterization.  In addition, 
we demonstrated the shortcomings that exist in current 
GPL tools that are available to detect rootkit exploits. Our 
work resulted in a methodology to detect kernel level 
rootkits that attack the system call table that is resident in 
kernel memory.     
We demonstrated the application of this methodology 
against two specific kernel level rootkit exploits.   We 
were able to detect the presence of both of these rootkits 
as well as identify similarities and differences between 
them. This can help to generate rootkit signatures to aid in 
the detection of these types of exploits.    This 
methodology will allow system administrators and the 
security community to react faster to new kernel rootkit 
exploits. 
REFERENCES 
[1] H.  Thimbleby, S. Anderson, p. Cairns,  “A Framework 
for Modeling Trojans and Computer Virus Infections,”  
The Computer Journal, vol. 41, no.7 pp. 444-458, 1998.     
[2] E. Cole, Hackers Beware,  Indianapolis, In: New Riders,  
2002,  pp. 548-553. 
[3] D. Dettrich,  (2002, 5 JAN) “Root Kits” and hiding 
files/directories/processes after a break-in,  http:// 
staff.washington.edu/dittrich/misc/faqs/rootkits.faq  
[4] E. Skoudis, Counter Hack, Upper Saddle River, NJ: 
Prentice Hall PTR: 2002, p. 434.   
[5] A. Silberschatz, P. Galvin, G. Gagne, Applied Operating 
System Concepts, New York, NY: John Wiley & Sons: 
2003, p. 626. 
[6] Samhain Labs,  The Basics– Subverting the Kernel, 
http://la-samha.de/library/rootkits /basics.html, July 2003 
[7] Cohen, F. , “Computer Viruses”, Computers & Secuirty.  
6(1), pp.22-35., 1987. 
[8] http://vx.netlux.org/lib/static/vdat/epvirlib.htm,  Aug 
2003 
[9] Samhain Labs,  Detecting Kernel Rootkits, http://la-
samha.de/library/rootkits/detect.html, July 2003 
[10] S. Northcut, L. Zeltser, S. Winters, K. Kent Fredericks, 
R. Ritchey, Inside Network Perimeter Security. 
Indianapolis, In: New Riders, 2003,  pp. 283-286.    
[11] R. Lehti , “ The Aide Manual”,  www.cs.tut.fi ~rammer 
/aide /manual.html , SEP 2002 
[12] http://www.chkrootkit.org 
[13] Samhain Labs (email, 27 JAN 2003) 
[14]  s.d., devik,   Linux-on-the-flykernel patching without 
LKM, http://www.pharack.org/phrack/58/p58-0x07, 12 
Dec 2002. 
[15] D. Bovet, M. Cesati, Understanding the Linux Kernel, 
Sebastopol, CA: O’Reilly & Associates, 2003, pp304-
306. 
[16] http://www.intel.com/design/intarch/techinfo/pentium/in
strefs.htm#96030, Jul 2003. 
[17] http://www.intel.com/design/intarch/techinfo/pentium, 
Jun 2003 
[18] D. Bovet, M. Cesati, Understanding the Linux Kernel, 
Sebastopol, CA: O’Reilly & Associates, 2003, p 255. 
[19] J. Levine, J. Grizzard, P. Hutto, H. Owen, An Analysis 
of a Kernel Level Rootkit (knark), unpublished. 
[20] http://www.chkrootkit.org 