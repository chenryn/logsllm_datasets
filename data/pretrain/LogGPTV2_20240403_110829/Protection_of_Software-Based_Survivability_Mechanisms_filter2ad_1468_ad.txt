increased  branch  replacement  (see  Figure  10  and  Figure 
11). Go, a branch-intensive program, shows the largest code 
growth with  our transform.  For 80% replacement  of direct 
branches, the executable  size increased by  a factor of 3 for 
Go and Li, and  by  roughly  10% for  Compress.  Compress 
contains  relatively  fewer static branches,  and this  resulted 
in less potential for code growth with the transform. 
We believe that these results are representative of many 
programs. It appears that, on average, replacing 50% of the 
branches  will  result  in  an  increase  of  a  factor  of  4  in  the 
execution speed of the program. At the same time, the pro- 
gram will nearly double in size. 
The  object  size  of  the  three  benchmarks  grew  with 
increased  branch  replacement  (see  Figure  10  and  Figure 
Figure 11: Executable Size (optimized) 
10% 
3 0 %  
5 0 %  
8 0 %  
Percentage of  branches transformed 
10% 
3 0 %  
5 0 %  
8 0 %  
Percentage  of branches transformed 
200 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:00:07 UTC from IEEE Xplore.  Restrictions apply. 
11). Go, a branch-intensive  program, shows the largest code 
growth with  our transform.  For 80% replacement of direct 
branches, the executable size increased by  a factor of 3 for 
Go and  Li, and  by  roughly  10% for  Compress. Compress 
contains relatively  fewer static  branches, and  this resulted 
in less potential for code growth with the transform. 
We believe that these results are representative of many 
programs. It appears that, on average, replacing 50% of the 
branches  will  result  in  an  increase of  a  factor of  4  in  the 
execution speed of the program. At the same time, the pro- 
gram will nearly double in size. 
In  these  experiments, we used  a random  algorithm to 
choose  which  branch  to  transform.  An  obvious  future 
improvement is to employ  intelligence to do the following: 
a)  identify  the  regions  of  the  program  that  require  greater 
protection  from  static  analysis, and b)  selectively  perform 
transformation  on the less-often-executed  branches  for bet- 
ter performance penalty.  Trade-offs  between  these two cri- 
teria need to be considered for the most effective solution. 
7.2. Performance and precision of static analysis 
In this experiment, we test our techniques against exist- 
ing analysis tools and algorithms. The state-of-the-art  anal- 
ysis  tools  include  the  NPIC tool  [13]  and  the  PAF toolkit 
[ 181. They both implement  an inter-procedural, flow-sensi- 
tive  algorithm.  Both  NPIC  and PAF perform control-flow 
analysis  exactly  once  with  no  further  refinement  on  the 
flow graph. 
In  our  experiments, PAF  successfully  analyzed  small 
sample programs (run  to completion) but  failed  to handle 
some of  the  large  programs included  in  the  SPEC bench- 
marks.  The failure characteristics were  inconclusive  as to 
whether the analysis failed due to difficulties  incurred in the 
alias analysis or an inability of handling the size of the orig- 
inal  input  program.  The  test  cases  that  we  successfully 
completed with  PAF included  a wide range of sample pro- 
grams that contain extensive looping constructs and branch- 
ing statements. In each of  these  test cases, PAF terminated 
reporting the  largest possible  number of  aliases in the pro- 
gram; in other words, it reported that any pointer variable is 
possibly  aliased  to every  variable that ever appeared  on the 
left  hand  side of  an  assignment statement. Because of  the 
size  of  the  test  programs,  we  observed  negligible  differ- 
ences in the pre- and post-transformation  analysis time. The 
experience with the PAF tool, albeit with limited test cases, 
indicated  that  PAF failed to resolve aliases across the  flat- 
tened  basic blocks, and that our technique of  making data- 
flow and control-flow co-dependent presents a fundamental 
difficulty that existing analysis algorithms lack the sophisti- 
cation to handle. 
NPIC implements a slightly more aggressive algorithm 
that  includes features  such as function-pointer analysis.  It 
performs  an  iterative  analysis  interleaving  the  inter-and 
intra-procedural analysis. Every time new aliasing informa- 
tion  is generated by  an  intra-procedural  phase,  it  is propa- 
gated  to  its  successor  functions  which  then  repeat  their 
intra-procedural analysis, and so on, until  the alias set con- 
verges.  Unfortunately,  IBM  no  longer  maintains  and  dis- 
tributes  the tool.  The experience with  NPIC was therefore 
limited to analytical experiments with the NPIC algorithm. 
A  limited  number of experiments with  the NPIC algo- 
rithm  were  conducted  on  small  programs.  These  experi- 
ments, to the extent that  a  semi-automated analysis would 
allow, revealed that  little accuracy  was  achieved when  the 
analysis terminates. 
In  a particular  instance  where  index  computation and 
aliasing were used  to compute branch targets, NPIC started 
out  indicating that  the  elements of  the  global  array could 
contain  a number of possible  values. As the iterations went 
on, this  information  was  never  refined.  Rather,  alias rela- 
tions identified  in  later iterations increased the set of possi- 
ble  values  that  the  array  elements  were  deemed  to  have. 
The  algorithm eventually terminated  and  claimed  that  the 
elements  of  the  global  array  were  changed  an  arbitrary 
number of times, and  that they  could contain  arbitrary  val- 
ues.  Computations  involving  the  array  elements  were 
deemed unanalyzable. This in  turn implied  that the indirect 
branching  targets  cannot  be  determined  precisely.  Alias 
information  propagation  among those  blocks therefore  did 
not get easier and alias relations were never refined. 
8.  Conclusion 
The  problem  of  protecting 
trusted  software  from 
untrustworthy  hosts,  is  important  for  many  critical  func- 
tions in modern networks. Consider, as an example, distrib- 
uted  intrusion  detection  systems in  which  parts  of  the  ID 
programs need  to  operate  on  untrustworthy  hosts.  Serious 
consequences will  arise  if  these programs were the  targets 
of malicious attacks and were compromised. 
In  this  paper,  we  considered  one  significant class  of 
attacks, namely  those based on static analysis of the binary 
form of the program.  We presented  a strategy  for defeating 
analysis by  tightly  coupling the  control  flow and  the  data 
flow of the program. Since data-flow analysis of acceptable 
precision  is dependent on the control-flow information, this 
approach  is capable of  expanding analysis time  consider- 
ably  and  reducing  the  precision  of  the  analysis to  useless 
levels.  The  theoretical  bound  that  we  have  established 
shows that analysis of programs that have been transformed 
in this manner is NP hard. 
We  have  developed  a  practical  instantiation  of  the 
transformation  in the form of a compiler for ANSI  C. The 
compiler makes a number of changes to the program source 
including: degeneration  of  the  program  control  Row;  the 
201 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:00:07 UTC from IEEE Xplore.  Restrictions apply. 
systematic and general creation of aliases; and the introduc- 
tion  of data-dependent branches.  We  note  that  these  trans- 
formations  are  not  dependent  on  a  C-like  pointer 
paradigm-they 
can be applied to any  intermediate repre- 
sentation  where explicit memory references exist. 
In  proof-of-concept  experiments  that  we  have  con- 
ducted  on  sample  programs,  the  transformed  versions 
defeat  currently  available  static-analysis  tools.  Although 
such experiments are not and could never be definitive evi- 
dence, we regard these results as promising indications that 
we have a practical  approach to defeat static analysis. 
We  note  that  the  described  transformations  produce 
programs with a considerable level of code diversity (trans- 
forms  are  randomly  chosen  on  a  per  compilation  basis). 
Such programs, when  deployed at  various points in  a net- 
work, are highly  resilient  to class attacks since most class 
attacks exploit common software flaws. 
It is important to note that the purpose of this work is to 
eliminate the possibility  that a static analysis can be used to 
deduce useful information  for software tampering or imper- 
sonation.  In  other  words,  the  optimal  result  is  that  there 
should  be  no  efficient  way  to  analyze  the  program  other 
than  an actual  execution. We also note that  many  forms of 
dynamic program  analysis make  use  of  static  information 
[3, lo], and the  techniques described in  this paper  will  be 
helpful in defending against these forms of analyses. 
Acknowledgments 
The authors want to thank Dr. Jim Cohoon for insight- 
ful  discussions. This  effort  was  sponsored  in  part  by  the 
Defense  Advanced  Research  Projects  Agency  and  Rome 
Laboratory,  Air  Force  Materiel  Command,  USAF,  under 
agreement number F30602-96-1-03 14. The views and con- 
clusions  contained  herein  are  those  of  the  authors  and 
should  not  be  interpreted  as  necessarily  representing  the 
official  policies  or  endorsements,  either  expressed  or 
implied,  of  the  Defense  Advanced  Research  Projects 
Agency, Rome Laboratory or the U.S. Government. 
References 
I 
Aigner, G. er al. “The SUIF2 Compiler Infrastructure”, Doc- 
umentation of  the Computer Systems Laboratory, Stanford Uni- 
versity. 
Aucsmith, D., “Tamper Resistant Software”, Proceeding of 
2 
the 1st information hiding workshop, Cambridge, England, 1996. 
3 
Ball, T.  and J.  R.  Larus. “Optimally Profiling and Tracing 
Programs”, ACM  Transactions on  Programming Languages and 
Systems, Vol  16, No. 4, July  1994, pp1319-1360. 
4  Collberg,  C.,  C.  Thomborson,  and  D.  Low,  “Breaking 
Abstractions and  Unstructuring Data  Structures”, IEEE Interna- 
tional Conference on Computer Languages, Chicago, May  1998. 
Collberg, C., C. Thomborson, and D. Low, “A Taxonomy of 
5 
Obfuscating Transformations”, Techreport  148,  Department  of 
Computer Science, University of  Auckland, July  1997. 
6 
Forrest, S. and A.  Soma, “Building Diverse Computer Sys- 
tems”, in  the  1996 Proceedings  of  the  Hot  Topics of  Operating 
Systenis. 
7 
Hohl,  F.,  “Time  Limited  Blackbox  Security:  Protecting 
Mobile Agents from Malicious Hosts”, in Lecture  Notes in Corn- 
puter Science, vol. 1419, Mobile Agents arid Security. Edited by G .  
Vigna. Springer-Verlag, 1998. 
Hitunen, M.  and  R.  D.  Schlichting, “Adaptive Distributed 
8 
and  Fault-Tolerant Systems” International Journal  of  Computer 
Systems Science and  Engineering, vol.  11, No.  5, pp.  125-133, 
September 1996. 
Knight, J., K. Sullivan, M. Elder, and C. Wang, “Survivabil- 
9 
ity  Architectures:  Issues  and  Approaches”  in  Proceedings: 
DARPA  Information  Survivability Conference  and  Exposition. 
IEEE Computer Society Press. pp.  157-17 I. 
10  Larus, J., “Efficient Program Tracing”, Computer, Vol  26. 
No. 5. May  1993. pp52-61. 
1 1  Muchnick,  S.,  “Advanced  Compiler  Design  Implementa- 
tion”, Morgan Kaufmann, 1997. 
12  Myers, E.,  “A  Precise  Inter-procedural Data  Flow  Algo- 
rithm”,  in the  conference record of  the  Eighth POPL. Williams- 
burg, VA. January,  1981. pp 219-230. 
13  Hind, M., M. Burke, P. Carini and J. Choi, “Inter-procedural 
Pointer  Analysis”,  ACM  Transactions  on  Programming  Lan- 
guages and Systems, Vol. 21, No. 4, July  1999, pp 848-894. 
14  Horwitz, S., “Precise flow-insensitive may-alias analysis is 
NP-Hard”, ACM  Transactions on  Programming Languages and 
Systems, Vol  19. No.1, pp  1-6. 
15  Landi,  W.,  “Interprocedural  Aliasing  in  the  Presence  of 
Pointers”, Ph.D. Dissertation, Rugters University, 1992. 
16  Landi, W.,  “Undecidability of  Static Analysis”, ACM  Let- 
ters  on  Programming  Languages  and  Systems, Vol.  I ,   No.  4 
December 1992, pp 323-337. 
17  Landi, W. and B. Ryders, “A Safe Approximation Algorithm 
for  Interprocedural Pointer Analysis”, Techreport, Rutgers Uni- 
versity, 199 1. 
18  The Prolangs Analysis Framework (PAF). Rutgers Univer- 
sity. htt~://ww.w.nrolan~s.rut~~r.~.edii/~iihlic 
19  Rosen, B.,  “Data flow analysis for  procedural languages”, 
Journal of the ACM, Vol. 26, No. 2, pp 322-344. 
20 
Sander, T.,  and  C.  Tschudin, “Protecting  Mobile  Agents 
Against  Malicious Hosts”, in  the Proceedings of  the  1998 IEEE 
Symposium of  Research in Security and Privacy, Oakland, 1998. 
21  Wang, C., “A Security Architecture for Survivability Mech- 
anisms”, Ph.D. Dissertation, October 2000, University of  Virginia. 
22  Wang, C. Hill.  J, Knight J.  Davidson, J.  “Software Protec- 
tion in  malicous environments”. CS Technical Report. CS-00-12. 
Department of Computer Science, University of  Virginia. 
202 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:00:07 UTC from IEEE Xplore.  Restrictions apply.