以下是经过优化后的文本，使其更加清晰、连贯和专业：

---

**参考文献**

[36] X. Carpent, G. Tsudik, and N. Rattanavipanon, “ERASMUS: 高效的无人值守环境下的自我测量远程证明,” 在欧洲设计、自动化与测试会议 (DATE) 上发表, IEEE, 2018, pp. 1191–1194.

[37] J. K. Zinzindohoué, K. Bhargavan, J. Protzenko, and B. Beurdouche, “Hacl*: 一个经过验证的现代加密库,” 在第24届ACM计算机与通信安全会议 (CCS) 上发表, ACM, 2017, pp. 1789–1806.

[38] J. Protzenko, J.-K. Zinzindohoué, A. Rastogi, T. Ramananandro, P. Wang, S. Zanella-Béguelin, A. Delignat-Lavaud, C. Hritcu, K. Bhargavan, C. Fournet 等, “嵌入在F中的经验证的低级编程,” ACM on Programming Languages, vol. 1, no. ICFP, pp. 1–29, 2017.

[39] S. Underwood, mspgcc: GNU工具到德州仪器MSP430微控制器的移植, http://mspgcc.sourceforge.net/manual/, 2003.

[40] M. Howard 和 S. Lipner, 安全开发生命周期. Microsoft Press Redmond, 2006, vol. 8.

[41] A. Boileau, “被公交车撞了：通过火线进行物理访问攻击,” 演讲, Ruxcon, vol. 3, 2006.

[42] A. T. Markettos, C. Rothwell, B. F. Gutstein, A. Pearce, P. G. Neumann, S. W. Moore, 和 R. N. M. Watson, “Thunderclap: 通过不受信任的外设DMA探索操作系统IOMMU保护的漏洞,” 在第26届年度网络与分布式系统安全研讨会 (NDSS) 上发表, The Internet Society, 2019.

[43] G. Kupfer, “抗IOMMU的DMA攻击,” 硕士论文, 计算机科学系, Technion, 2018.

[44] B. Ruytenberg, “破坏雷电协议安全性: 漏洞报告,” 2020年4月. [在线]. 可用: https://thunderspy.io/assets/reports/breaking-thunderbolt-security-bjorn-ruytenberg-20200417.pdf

[45] M. van Dijk, S. K. Haider, C. Jin, 和 P. H. Nguyen, “高级电源侧信道, 缓存侧信道攻击, DMA攻击,” 演讲, 电气与计算机工程系, 康涅狄格大学, 2017.

[46] D. R. E. Gnad, J. Krautter, 和 M. B. Tahoori, “泄漏噪声: 混合信号物联网设备中的新侧信道攻击向量,” IACR Transactions on Cryptographic Hardware and Embedded Systems, vol. 2019, no. 3, pp. 305–339, 2019.

[47] V. Costan 和 S. Devadas, “Intel SGX详解.” IACR Cryptology ePrint Archive, vol. 2016, no. 086, pp. 1–118, 2016.

[48] Z. Wu, Z. Xu, 和 H. Wang, “超空间中的耳语: 云内的高带宽可靠隐蔽通道攻击,” IEEE/ACM Transactions on Networking, vol. 23, no. 2, pp. 603–615, 2015.

[49] P. Pessl, D. Gruss, C. Maurice, M. Schwarz, 和 S. Mangard, “DRAMA: 利用DRAM寻址进行跨CPU攻击,” 在第25届USENIX安全研讨会上发表, 2016, pp. 565–581.

[50] D. Ustiugov, P. Petrov, M. R. S. Katebzadeh, 和 B. Grot, “破产隐蔽通道: 将网络可预测性转化为漏洞,” 在第14届USENIX攻击技术研讨会 (WOOT), 2020年8月.

[51] Y. Wang, A. Ferraiuolo, 和 G. E. Suh, “共享内存控制器的时间通道保护,” 在2014年IEEE第20届高性能计算机架构国际研讨会上发表, IEEE, 2014, pp. 225–236.

[52] J. Van Bulck, D. Oswald, E. Marin, A. Aldoseri, F. D. Garcia, 和 F. Piessens, “两个世界的传说: 评估屏蔽运行时的安全性,” 在第26届ACM计算机与通信安全会议 (CCS) 上发表, 2019年11月, pp. 1741–1758.

[53] X. Leroy, “现实编译器的形式验证,” Communications of the ACM, vol. 52, no. 7, pp. 107–115, 2009.

[54] A. Guha, C. Saftoiu, 和 S. Krishnamurthi, “JavaScript的本质,” 在ECOOP, 2010.

[55] P. Philippaerts, J. T. Mühlberg, W. Penninckx, J. Smans, B. Jacobs, 和 F. Piessens, “使用VeriFast进行软件验证: 工业案例研究,” Sci. Comput. Program., vol. 82, pp. 77–97, 2014.

[56] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, 和 Y. Yarom, “幽灵攻击: 利用推测执行,” 在第40届IEEE安全与隐私研讨会 (S&P) 上发表, 2019.

[57] X. Yang, Y. Chen, E. Eide, 和 J. Regehr, “在C编译器中发现并理解错误,” 在PLDI, 2011.

[58] D. MacKenzie 和 G. Pottinger, “数学、技术和信任: 形式验证、计算机安全和美国军方,” IEEE Annals of the History of Computing, vol. 19, no. 3, pp. 41–59, 1997.

[59] D. E. Bell 和 L. J. La Padula, “安全计算机系统: 统一阐述和Multics解释,” Mitre Corporation, 技术报告, 1976.

[60] P. A. Karger 和 R. R. Schell, “三十年后: Multics安全评估的教训,” 在第18届年度计算机安全应用会议 (ACSAC) 上发表, IEEE Computer Society, 2002, pp. 119–126.

[61] “信息技术安全评估通用标准,” https://www.commoncriteriaportal.org/, 访问日期: 2021-08-18.

[62] R. J. Anderson, 安全工程 - 构建可靠的分布式系统的指南 (第三版). Wiley, 2020.

[63] S. Goldwasser 和 S. Micali, “概率加密,” Journal of Computer and System Sciences, vol. 28, no. 2, pp. 270–299, 1984.

[64] M. Burrows, M. Abadi, 和 R. M. Needham, “认证逻辑,” 伦敦皇家学会: 数学和物理科学, vol. 426, no. 1871, pp. 233–271, 1989.

[65] G. Lowe, “使用FDR破解并修复Needham-Schroeder公钥协议,” 在国际工具和算法构造及分析研讨会上发表, Springer, 1996, pp. 147–166.

[66] J. P. Degabriele, K. Paterson, 和 G. Watson, “现实世界中的可证明安全性,” IEEE Security & Privacy, vol. 9, no. 3, pp. 33–41, 2010.

[67] N. Koblitz 和 A. Menezes, “对可证明安全性的批判视角: ‘另一种观点’论文的十五年,” Advances in Mathematics of Communications, vol. 13, no. 4, p. 517, 2019.

[68] M. Vanhoef 和 F. Piessens, “密钥重装攻击: 强制WPA2中的nonce重用,” 在第24届ACM计算机与通信安全会议 (CCS) 上发表, 2017, pp. 1313–1328.

[69] M. Barbosa, G. Barthe, K. Bhargavan, B. Blanchet, C. Cremers, K. Liao, 和 B. Parno, “综述: 计算机辅助密码学,” 在第42届IEEE安全与隐私研讨会上发表, 2020.

[70] D. McMorrow, “网络安全科学,” MITRE公司JASON办公室, 技术报告JSR-10-102, 2010年11月.

[71] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish 等, “sel4: 操作系统内核的形式验证,” 在第22届ACM SIGOPS操作系统原理研讨会上发表, 2009, pp. 207–220.

[72] A. Goel, S. Krstic, R. Leslie, 和 M. R. Tuttle, “基于SMT的系统验证与DVF.” 在SMT@IJCAR, 2012, pp. 32–43.

---

**附录**

**A. VRASED的扩展**

已有多篇衍生架构基于开源VRASED研究原型，并以其安全论证为基础。以下是一些重要的扩展：

1. **VRASEDA [15]: 验证者身份验证**: 为了防止攻击者生成大量证明请求以耗尽证明者的计算资源，原始VRASED论文 [15] 提出了对SW-Att的修改。该变体（本文中称为VRASEDA）在开始昂贵的证明过程之前对证明请求进行身份验证。证明请求需要包含一个身份验证令牌，该令牌通过对挑战值和共享主密钥进行HMAC运算得出。因此，在VRASEDA中，没有密钥知识的情况下猜测给定请求的正确身份验证值应该是计算上不可行的。

2. **PURE [19]: 更新、重置和擦除的证明**: 除了VRASED提供的恶意软件检测功能外，PURE还提供了远程擦除设备数据段、更新程序代码和重置设备的能力——这些步骤是在检测到恶意软件或进行软件更新时需要采取的措施。

3. **APEX [20]: 执行证明**: APEX提供经过身份验证的传感器读数和执行结果：证明设备执行了所需的程序（具有新鲜度保证），并且执行结果未被篡改。这旨在解决在证明和执行之间可能发生恶意软件感染的问题。

4. **RATA [21]: TOCTOU避免**: 基于VRASEDA，此扩展更广泛地解决了上述时间检查-时间使用（TOCTOU）问题。它不仅允许在证明的同时执行软件，还能跟踪两次证明之间软件是否被篡改。此外，它还可以提高性能，因为只要软件未被更改，后续证明不需要再次运行HMAC。

5. **Tiny-CFA [22]: 控制流证明**: Tiny-CFA使验证者能够在证明者设备上进行控制流证明。这是唯一一个其附加安全属性未经验证的VRASED扩展。

**B. VRASED假设**

VRASED [15] 明确假设核心实现应满足以下条件：

A1. 程序计数器: PC寄存器包含正在执行指令的地址。

A2. 内存地址: 每当访问内存时，地址总线上包含其地址，并且Wen/Ren信号处于活动状态。

A3. DMA: 每当DMA访问内存时，DMA地址总线上包含访问的内存地址，并且DM Aen信号为高。

A4. MCU复位: 复位处理不能被修改，并且复位期间寄存器被清零。

A5. 中断: 触发中断会设置相应的irq信号。

此外，VRASED还为可信编译器提出了两个额外假设：

A6. 调用者保存寄存器: 函数中使用的所有寄存器在退出前被清除。

A7. 语义保留: 从C编译到MSP430汇编时保持功能正确性。

**C. 其他（不可直接利用的）VRASED缺陷**

本附录列出了一个被证伪的假设和一个未建模的功能，我们在攻击模型中未发现它们是直接可利用的。

1. **编译器不清除脏寄存器值**: 假设A6明确指出编译器应该清除函数中使用的所有寄存器。论文还声称所使用的msp430-gcc编译器满足这一假设。

   a. **被证伪的假设**: 然而，我们发现寄存器r12-r15在msp430-gcc应用程序二进制接口（ABI）中被显式指定为“调用者保存” [39, §寄存器使用]。这意味着它们的值可能被覆盖，编译器不需要在函数结束时恢复或清除它们。
   
   如果HMAC函数使用了这些寄存器来临时保存依赖密钥的值，那么这些值可能会泄露给不可信代码，因为SW-Att也不会手动清理这些寄存器。
   
   b. **攻击**: 我们通过实验确认了调用者保存寄存器在SW-Att执行后确实被覆盖。然而，在我们的实验中，当前HMAC函数和编译器设置下没有敏感数据泄露，但这并不保证在编译器或SW-Att实现发生变化时仍然成立。
   
   c. **缓解措施**: 最直接的解决方案是在SW-Att的可信退出点插入自定义汇编代码，以清除所有可能包含依赖密钥数据的寄存器。这种ABI清理代码类似于现有的安全解决方案和最佳实践，例如在Sancus [16] 和Intel SGX enclave屏蔽运行时 [52] 中防止通过CPU寄存器泄露信息。

2. **通过调试单元读取密钥**: openMSP430架构配备了一个通过UART或I2C连接到核心的调试单元。该单元允许用户读写内存数据、暂停CPU执行并读取寄存器内容。

   a. **未建模的功能**: 尽管论文中未提及调试单元，但在VRASED的开源实现中包含了它。
   
   b. **攻击**: 操作调试单元需要物理访问，严格来说，它超出了VRASED的攻击模型范围。然而，由于调试单元位于VRASED的验证范围之外，它也可以被扩展为由软件控制，而不违反附录B中的任何核心假设（参见第六章-D节的讨论）。具体来说，即使调试单元遵循内存接口（A2）和中断（A5）假设，它仍可以配置为安排断点或简单地读取CPU寄存器以泄露密钥。
   
   c. **缓解措施**: 这个问题突显了开发接口带来的安全风险，特别是那些不在验证范围内的接口。最简单的修复方法是从实现中完全移除调试单元，因为它只会成为潜在的信息泄露源。

**D. 对VRASEDA的时间攻击**

根据第六章-C3节描述的攻击，表III显示了在相同的密钥-挑战对下，SW-Att整个执行过程中不同身份验证令牌所需的时间周期数。对于给定的对，正确的令牌以字节{0x59, 0x76}开头，如执行时间增加所示。通过逐字节猜测，可以在线性时间内提取出完整的VRASEDA身份验证令牌。

| VRF_AUTH[32] | 执行时间（周期） |
|--------------|------------------|
| {0x1}        | 210,641          |
| {0x0}        | 210,641          |
| {0x59}       | 210,654          |
| {0x59, 0x75} | 210,654          |
| {0x59, 0x76} | 210,667          |

**E. 端到端RA安全论证分析**

远程证明的健全性: VRASED的端到端远程证明安全论证 [15] 首先依赖于另一个单独的论证，该论证证明了RA方案的健全性。健全性论证关键依赖于HACL*加密库 [37] 的功能性正确性的证明。然而，没有给出关于未验证的openMSP430核心如何满足HACL*假设的机器模型的论证。特别地，即使经过形式验证的HACL*库也会在执行于某些核心上时失效，例如，将加法操作替换为减法或将jmp指令的方向反转。请注意，没有任何假设禁止这种情况，也没有假设要求核心无错误、无硬件木马，甚至不遵守某种（形式化的）MSP430 ISA规范。因此，证明的健全性和HACL*的保证可以通过一个恶意的核心轻易打破，例如，将加法指令替换为减法指令，反之亦然。

远程证明的安全性: 我们首先概述端到端RA安全属性如何依赖于两个假设，这两个假设进一步分解为子论证。同一级别的枚举项表示其父项的先决条件（所有条件都必须满足）。“”表示给定步骤可以通过满足A1-A5但行为异常的核心绕过。使用从Verilog派生的模型进行证明的步骤以斜体显示。

1. RA健全性 
2. 攻击者无法获知密钥 
   a. 密钥只能通过内存获取 
      i. 密钥只能通过寄存器、内存或SW-Att时间泄露 
      ii. A6禁止SW-Att退出后通过寄存器泄露 
      iii. HACL*防止所有可能的SW-Att时间泄露 
   b. 引理2: 直接读取密钥或SW-Att写入未受保护区域的数据会导致复位 
   c. 复位不会泄露密钥 
   d. 共享的MR区域不能包含密钥 

---

希望这些优化能够帮助你更好地理解和使用这些文献和附录内容。如果有更多需要优化的地方，请随时告诉我！