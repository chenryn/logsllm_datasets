# CVE-2016-5195漏洞分析与复现
## 前言
Dirty Cow(CVE-2016-5195)是一个内核竞争提权漏洞，之前阿里云安全团队在先知已经有一份漏洞报告[脏牛（Dirty
COW）漏洞分析报告——【CVE-2016-5195】](https://xz.aliyun.com/t/450)，这里我对漏洞的函数调用链和一些细节做了补充，第一次分析Linux
kernel CVE,个人对内核的很多机制不太熟，文章有问题的地方恳请各位师傅不吝赐教。
## 环境搭建
复现漏洞用的是一个比较经典的poc，[代码链接](https://github.com/FireFart/dirtycow/blob/master/dirty.c)，内核版本使用的是[linux-4.4.0-31](http://security.ubuntu.com/ubuntu/pool/main/l/linux/linux-image-4.4.0-31-generic_4.4.0-31.50_amd64.deb)，这里是`ubuntu`的官方软件库，里面包含有现成的内核压缩文件，可以直接配合qemu运行，
文件系统是busybox生成的，可以参考[Debug Linux Kernel With
QEMU/KVM](https://sunichi.github.io/2019/02/13/Debug-Linux-Kernel-With-QEMU-KVM/)自己编译一个也可以网上找个kernel pwn的文件系统拿来用。
`busybox`是一个集成了常见linux命令和工具的软件，在这次漏洞复现过程中我们需要使用`su`命令，`su`命令的owner和group都是`root`，因此执行这个命令需要给busybox设置`SUID`位，之后在执行busybox中的命令的时候就能以root的身份去执行一些特权指令。这个标志位最典型的用法就是用`passwd`修改用户自己的密码，正常用户没有权限修改`/etc/shadow`,而有了`SUID`之后就可以以root身份写入自己的新密码。因此在编译busybox之后我们需要使用来设置SUID。否则之后在qemu中没有足够权限去执行`su`。此外busybox是用户编译的情况下,`/etc/passwd`的owner是用户，因此在qemu里可以去编辑，我们同样将其owner和group都设置为`root`
    sudo chown root:root ./bin/busybox
    sudo chmod u+s ./bin/busybox
## 漏洞复现
静态编译漏洞脚本，打包文件系统(-lpthread需要拷贝libc,-pthread是不需要的，这两个参数的差异可以参见[编译参数中-pthread以及-lpthread的区别](https://blog.csdn.net/origin_lee/article/details/42145547))
    ╭─wz@wz-virtual-machine ~/Desktop/DirtyCow/vul_env/files ‹hexo*› 
    ╰─$ ldd ./dirty 
            linux-vdso.so.1 =>  (0x00007ffea5f58000)
            libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fc988780000)
            libcrypt.so.1 => /lib/x86_64-linux-gnu/libcrypt.so.1 (0x00007fc988548000)
            libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc98817e000)
            /lib64/ld-linux-x86-64.so.2 (0x00007fc98899d000)
    ─wz@wz-virtual-machine ~/Desktop/DirtyCow/vul_env/files ‹hexo*› 
    ╰─$ gcc ./dirty.c -static -o dirty -lpthread -lcrypt
    ╭─wz@wz-virtual-machine ~/Desktop/DirtyCow/vul_env ‹hexo*› 
    ╰─$ cp /lib/x86_64-linux-gnu/libpthread.so.0 ./files/lib/ && cp /lib/x86_64-linux-gnu/libcrypt.so.1 ./files/lib/
    ─wz@wz-virtual-machine ~/Desktop/DirtyCow/vul_env/files ‹hexo*› 
    ╰─$ find . -print0 | cpio --null -ov --format=newc > ../rootfs.cpio
启动脚本如下：
    qemu-system-x86_64 \
    -m 256M \
    -kernel ./vmlinuz-4.4.0-31-generic \
    -initrd  ./rootfs.cpio \
    -append "cores=2,threads=1 root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr" \
    -s  \
    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \
    -nographic  \
进入qemu之后执行名为`dirty`的编译好的exp，为新用户设置新密码，`su
xmzyshypnc`切换至这个用户，其uid已被改为0，而`/etc/passwd`这个原本owner为root的特权文件属主也被改为`xmzyshypnc`，我们可以对其进行读写。
## 背景知识
### 写时拷贝
`COW(copy on
write)`技术即写时拷贝技术是linux程序中用的一个技术，在程序`fork`进程时，内核只为子进程创建虚拟空间结构，虚拟空间拷贝父进程的对应段内容，也就是说子进程对应段和父进程指向同一块物理内存，直到父进程/子进程中有改变段内容的操作再为子进程相应段分配物理空间(如exec)。
具体地，如果父/子进程改变了段，但没有exec，则只为子进程的堆栈段分配物理内存，子进程的代码段和父进程对应同一个物理空间；若有exec，则子进程的代码段也分配物理内存，和父进程独立开来。(注:这里的exec并不是一个函数，而是一组函数的统称，包含了`execl()、execlp()、execv()、execvp()`)
写时复制的好处是延迟甚至免除了内存复制，推迟到父进程或子进程向某内存页写入数据之前。传统的fork在子进程创建的时候就把进程数据拷贝给子进程，然而很多时候子进程都会实现自己的功能，调用exec替换原进程，这种情况下刚刚拷贝的数据又会被替换掉，效率低下。有了COW之后再创建新的进程只是复制了父进程的页表给子进程，并无对物理内存的操作，调用exec之后则为子进程的`.text/.data/heap/stack`段分配物理内存。而如果没有exec，也没有改变段内容，相当于只读的方式共享内存。没exec但改变了段内容则子进程和父进程共享代码段，为数据段和堆栈段分配物理内存。
其实现方式可以参见[Copy On
Write机制了解一下](https://juejin.im/post/5bd96bcaf265da396b72f855),基本原理是将内存页标为只读，一旦父子进程要改变内存页内容，就会触发页异常中断，将触发的异常的内存页复制一份(其余页还是同父进程共享)。
在CTF比赛中，这里出过的考点是通过fork出的子进程爆破`canary`，由于父进程和子进程共享内存空间，所以parent和child的canary一样。
### 缺页中断处理
这部分我看了`《深入理解Linux内核》`第九章的内容，缺页中断异常处理的总流程如下图。主要关注COW的条件。引起缺页异常首先要区分出是由于编程错误引起的还是由于缺页引发的错误。如果是缺页引起的错误，再去看引起错误的线性地址是否是合法地址，因为有请求调页和写时复制的机制，我们请求的页最开始是假定不会使用的，因此给的都是`零页`，即全部填充为0的页，并且这个零页不需要我们分配并填充，可以直接给一个现成的并且设置为不可写。当第一次访问这个页的时候会触发缺页中断，进而激活写时复制。
### 用到的一些其他知识
`void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t
offset);`函数的作用是分配一块内存区，可以用参数指定起始地址，内存大小，权限等。我们平时做题一般用不到flags这个参数，它的作用如下(参考manual手册),其中`MAP_PRIVATE`这个标志位被设置时会触发COW(其作用就是建立一个写入时拷贝的私有映射，内存区域的写入不会影响原文件，因此如果有别的进程在用这个文件，本进程在内存区域的改变只会影响COW的那个页而不影响这个文件)。
    The flags argument determines whether updates to the mapping are
           visible to other processes mapping the same region, and whether
           updates are carried through to the underlying file.  This behavior is
           determined by including exactly one of the following values in flags:
    MAP_PRIVATE
                  Create a private copy-on-write mapping.  Updates to the
                  mapping are not visible to other processes mapping the same
                  file, and are not carried through to the underlying file.  It
                  is unspecified whether changes made to the file after the
                  mmap() call are visible in the mapped region.
`int madvise(void *addr, size_t length, int
advice);`这个函数的作用是告诉内核`addr,addr+len`这段区域的映射的内存或者共享内存的使用情况，方便内核以合适方式对其处理，`MADV_DONTNEED`这个表示接下来不再使用这块内存区域，内核可以释放它。
    Conventional advice values
           The advice values listed below allow an application to tell the
           kernel how it expects to use some mapped or shared memory areas, so
           that the kernel can choose appropriate read-ahead and caching
           techniques.  These advice values do not influence the semantics of
           the application (except in the case of MADV_DONTNEED), but may
           influence its performance.  All of the advice values listed here have
           analogs in the POSIX-specified posix_madvise(3) function, and the
           values have the same meanings, with the exception of MADV_DONTNEED.
    MADV_DONTNEED
                  Do not expect access in the near future.  (For the time being,
                  the application is finished with the given range, so the
                  kernel can free resources associated with it.)
                  After a successful MADV_DONTNEED operation, the semantics of
                  memory access in the specified region are changed: subsequent
                  accesses of pages in the range will succeed, but will result
                  in either repopulating the memory contents from the up-to-date
                  contents of the underlying mapped file (for shared file
                  mappings, shared anonymous mappings, and shmem-based
                  techniques such as System V shared memory segments) or zero-                  fill-on-demand pages for anonymous private mappings.
                  Note that, when applied to shared mappings, MADV_DONTNEED
                  might not lead to immediate freeing of the pages in the range.
                  The kernel is free to delay freeing the pages until an
                  appropriate moment.  The resident set size (RSS) of the
                  calling process will be immediately reduced however.
                  MADV_DONTNEED cannot be applied to locked pages, Huge TLB
                  pages, or VM_PFNMAP pages.  (Pages marked with the kernel-                  internal VM_PFNMAP flag are special memory areas that are not
                  managed by the virtual memory subsystem.  Such pages are
                  typically created by device drivers that map the pages into
                  user space.)
`dirty
bit`，这个标志位是Linux中的概念，当处理器写入或修改内存的页，该页就被标记为脏页。这个标志的作用是提醒CPU内存的内容已经被修改了但是还没有被写入到磁盘保存。可以参见[dirty
bit](https://en.wikipedia.org/wiki/Dirty_bit)和[脏页（dirty
page）](https://blog.csdn.net/salted___fish/article/details/95065488)
## CVE-2016-5195漏洞分析
### commit
首先来看下当时漏洞提交的commit,最早在2005年Linus就发现了这个问题，但是当时的修复并不到位，后面新的issue使得这个问题变得突出，直到2016年的新的commit才正式修复了这个漏洞(事实证明这次的fix依然不到位，之后还会有Huge
DirtyCow等待着Linus)。
仅看commit的话我们大概可以知道是`handle_mm_fault`这样一个负责分配一个新页框的函数出了问题
    commit 4ceb5db9757aaeadcf8fbbf97d76bd42aa4df0d6
        Author: Linus Torvalds 
        Date:   Mon Aug 1 11:14:49 2005 -0700
        Fix get_user_pages() race for write access
        There's no real guarantee that handle_mm_fault() will always be able to
        break a COW situation - if an update from another thread ends up
        modifying the page table some way, handle_mm_fault() may end up
        requiring us to re-try the operation.
        That's normally fine, but get_user_pages() ended up re-trying it as a
        read, and thus a write access could in theory end up losing the dirty
        bit or be done on a page that had not been properly COW'ed.
        This makes get_user_pages() always retry write accesses as write
        accesses by making "follow_page()" require that a writable follow has
        the dirty bit set.  That simplifies the code and solves the race: if the
        COW break fails for some reason, we'll just loop around and try again.
        commit 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619
        Author: Linus Torvalds 
        Date:   Thu Oct 13 20:07:36 2016 GMT
        This is an ancient bug that was actually attempted to be fixed once
        (badly) by me eleven years ago in commit 4ceb5db9757a ("Fix
        get_user_pages() race for write access") but that was then undone due to
        problems on s390 by commit f33ea7f404e5 ("fix get_user_pages bug").
        In the meantime, the s390 situation has long been fixed, and we can now
        fix it by checking the pte_dirty() bit properly (and do it better).  The
        s390 dirty bit was implemented in abf09bed3cce ("s390/mm: implement
        software dirty bits") which made it into v3.9.  Earlier kernels will
        have to look at the page state itself.
        Also, the VM has become more scalable, and what used a purely
        theoretical race back then has become easier to trigger.
        To fix it, we introduce a new internal FOLL_COW flag to mark the "yes,
        we already did a COW" rather than play racy games with FOLL_WRITE that
        is very fundamental, and then use the pte dirty flag to validate that
        the FOLL_COW flag is still valid.
### 漏洞触发原理
函数的调用链过于复杂，先大致了解一下漏洞的触发原理。
我们的目的是修改一个只读文件，这样就可以修改一些只有root可写的特权文件比如`/etc/passwd`。
漏洞产生的场景如下。我们使用write系统调用向`/proc/self/mem`这个文件写入内容，内核会调用`get_user_pages`函数，这个函数的作用是根据虚拟内存地址寻找对应的页物理地址。函数内部调用follow_page_mask来寻找页描述符，`follow_page_mask
- look up a page descriptor from a user-virtual address`。
第一次获取页表项会因为缺页失败(请求调度的机制)。`get_user_pages`会调用`faultin_page`以及`handle_mm_fault`来获取一个页框并将映射放到页表中。继续第二次的`follow_page_mask`获取页表符，因为获取到的页表项指向的是一个只读的映射，所以这次获取也会失败。get_user_pages第三次调用follow_page_mask的时候不再要求页表项指向的内存映射有可写权限，因此可以成功获取，获取之后就可以对只读内存进行强制写入操作。
> 上述实现是没有问题的，对/proc/self/mem的写入本来就是无视权限的。在写入操作中：  
>  如果虚拟内存是VM_SHARE的映射，那么mmap能够映射成功(注意映射有写权限)的条件就是进程对该文件有可写权限，因此写入不算越权  
>  如果虚拟内存是VM_PRIVATE的映射，那么会COW创建一个可写副本进行写入操作，所有的update不会更新到原文件中。
但是在上述第二次失败之后如果我们用一个线程调用madvise(addr,len,MADV_DONTNEED),其中addr-addr+len是一个只读文件的VM_PRIVATE的只读内存映射，那映射的页表项就会变为空。这时候如果第三次调用follow_page_mask来获取页表项，就不会用之前COW的页框了(页表项为空了)，而是直接去找原来只读的那个内存页，现在又不要求可写，因此不会再COW，直接写这个物理页就会导致修改了只读文件。
### 漏洞函数基本调用链
本来是想着直接把调用函数都给列一下的，结果发现太多了。。还是先简单讲下调用过程，然后想看细节的师傅可以再看具体函数实现。
[参考dirtyCow的一个官方github
repo](https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails)
第一次去请求调页发现`pte`表项为空，因此调用`do_fault`这个函数去处理各种缺页的情况，因为我们请求的页是只读的，我们希望可以写入这个页，因此会走`do_cow_fault`来用COW创建一个新的page同时设置内存->页框映射，更新页表上的`pte`。在`set_pte`函数中设置页表项，将pte
entry设置为`dirty/present/read`，返回0之后retry调页。
    faultin_page
      handle_mm_fault
        __handle_mm_fault
          handle_pte_fault
            do_fault vm_flags & VM_WRITE))  different thread will now unmap via madvise
    follow_page_mask
      !pte_present && pte_none
    faultin_page
      handle_mm_fault
        __handle_mm_fault
          handle_pte_fault
            do_fault = nr_pages);
            }
            if (!pages)
                /* If it's a prefault don't insist harder */
                return ret;
            if (ret > 0) {
                nr_pages -= ret;
                pages_done += ret;
                if (!nr_pages)
                    break;
            }
            if (*locked) {
                /* VM_FAULT_RETRY didn't trigger */
                if (!pages_done)
                    pages_done = ret;
                break;
            }
            /* VM_FAULT_RETRY triggered, so seek to the faulting offset */
            pages += ret;
            start += ret mmap_sem);
            ret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,
                           pages, NULL, NULL);
            if (ret != 1) {
                BUG_ON(ret > 1);
                if (!pages_done)
                    pages_done = ret;
                break;
            }
            nr_pages--;
            pages_done++;
            if (!nr_pages)
                break;
            pages++;
            start += PAGE_SIZE;
        }
        if (notify_drop && lock_dropped && *locked) {
            /*
             * We must let the caller know we temporarily dropped the lock
             * and so the critical section protected by it was lost.
             */
            up_read(&mm->mmap_sem);
            *locked = 0;
        }
        return pages_done;
    }