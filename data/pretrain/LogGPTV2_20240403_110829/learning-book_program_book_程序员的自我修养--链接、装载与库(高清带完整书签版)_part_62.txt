入口函数最重要的两个部分，堆初始化和I/O初始化，相信读者对程序的启动部分已经有了
较深的理解。不过，入口函数只是冰山一角，它隶属的是一个庞大的代码集合，这个代码集
合叫做运行库。
11.2C/C++运行库
11.2.1C语言运行库
任何一个C程序，它的背后都有一套庞大的代码来进行支撑，以使得该程序能够正常
运行。这套代码至少包括入口函数，及其所依赖的函数所构成的函数集合，当然，它还理应
包括各种标准库函数的实现。
这样的一个代码集合称之为运行时库（RuntimeLibrary）.而C语言的运行库，即被称
为C运行库（CRT）。
如果读者拥有Visual Studio，可以在VC/crt/src里找到一份C语言运行库的源代码。然
面，由于此源代码过于庞大，仅仅c文件就有近千个，并且和C++的STL代码一起毫无组
织地堆放在一起，以至于实际上没有什么仔细阅读的可能性。同样，Linux下的libc源代码
读起米也如同啃砖头。所幸的是，在本章的最后，我们会一起来实现一个简单的运行库，让
大家更直观地了解它。
一个C语言运行库大致包含了如下功能：
·启动与退出：包括入口函数及入口函数所依赖的其他函数等。
·标准函数：出C语言标准规定的C语言标准库所拥有的函数实现。
·VO：IO功能的封装和实现，参见上一节中VO初始化部分，
堆：堆的封装和实现，参见上一节中堆初始化部分。
·语言实现：语言中一些特殊功能的实现。
程序员的自我修养一链接、装载与库
---
## Page 359
336
第11章运行库
调试：实现调试功能的代码。
在这些运行库的组成成分中，C语言标准库占据了主要地位并且大有来头。C语言标准
库是C语言标准化的基础函数库，我们平时使用的 printf、exit等都是标准库中的一部分。
标准库定义了C语言中普遍存在的函数集合，我们可以放心地使用标准库中规定的函数面
不用担心在将代码移植到别的乎台时对应的平台上不提供这个函数。在下一章节里，我们会
介绍C语言标准库的函数集合，并对一些特殊的函数集合进行详细介绍。
标准库的历史
在计算机世界的历史中，C语言在AT&T的贝尔实验室诞生了。初生的C语言在功能
上非常不完善，例如不提供VO相关的函数。因此在C语言的发展过程中，C语言社
区共同意识到建立一个基础函数库的必要性。与此同时，在20世纪70年代C语言变
得非常流行时，许多大学、公司和组织都自发地编写自己的C语言变种和基础函数库，
因此当到了80年代时，C语言已经出现了大量的变种和多种不同的基础函数库，这对
代码迁移等方面造成了巨大的障碍，许多大学、公司和组织在共享代码时为了将代码
在不同的C语言变种之间移植搞得焦头烂额，怨声载道。于是对此惨状忍无可忍的美
国国家标准协会（American National Standards Institute,ANSI）在 1983年成立了—
个委员会，旨在对C语言进行标准化，此委员会所建立的C语言标准被称为ANSIC。
第一个完整的C语言标准建立于1989年，此版本的C语言标准称为C89。在C89标
准中，包含了C语言基础函数库，由C89指定的C语言基础函数库就称为ANSIC标
准运行库（简称标准库）。其后在1995年C语言标准委员会对C89标准进行了一次
修订，在此次修订中，ANSI C标准库得到了第一次扩充，头文件iso646.h、wchar.h
和wctype.h加入了标准库的大家庭。在1999年，C99标准凝生，C语言标准库得到
了进一步的扩充，头文件complex.h、fenv.hinttypes.h、stdbool.h、stdint.h和tgmath.h
进入标准库。自此，C语言标准库的面貌一直延续至今。
11.2.2C语言标准库
在本章节里，我们将介绍C语言标准库的基本函数集合，并对其中一些特殊函数进行
详细的介绍。ANSIC的标准库由24个C头文件组成。与许多其他语言（如Java）的标准
库不同，C语言的标准库非常轻量，它仅仅包含了数学函数、字符/字符串处理，VO等基本
方面，例如：
·标准输入输出（stdio.h）。
·文件操作（stdio.h）。
字符操作（ctype.h）。
字符串操作（string.h）。
程序员的自我修养一链接、装载与库
---
## Page 360
11.2C/C++运行库
337
数学函数（math.h）。
资源管理（stdlib.h）。
格式转换（sidlib.h）。
时间/日期（time.h）。
断言（assert.h）。
各种类型上的常数（limits.h & float.h)。
除此之外，C语言标准库还有一些特殊的库，用于执行一些特殊的操作，例如：
变长参数（stdarg.h）。
非局部跳转（setjmp.h）。
相信常见的C语言函数读者们都已经非常熟悉，因此这里就不再一一介绍，接下来让
我们看看两组特殊函数的细节。
1.变长参数
变长参数是C语言的特殊参数形式，例如如下函数声明：
int printf(const char* format, ...) ;
如此的声明表明，printf函数除了第一个参数类型为constchar*之外，其后可以追加任
意数量、任意类型的参数。·在函数的实现部分，可以使用stdarg.h里的多个宏来访问各个额
外的参数：假设lastarg 是变长参数函数的最后一个具名参数（例如printf里的 format），那
么在函数内部定义类型为va_list的变量：
va_list ap;
该变量以后将会依次指向各个可变参数。ap必须用宏va_start初始化一次，其中lastarg
必须是函数的最后一个具名的参数。
va_start (ap, 1astarg) :
此后，可以使用va_arg宏米获得下一个不定参数（假设已知其类型为type)：
type next = va_arg (ap, type) ;
在函数结束前，还必须用宏va_end来清理现场。在这里我们可以讨论这几个宏的实现细节。
在研究这几个宏之前，我们要先了解变长参数的实现原理，变长参数的实现得益于C语言
默认的cdecl调用惯例的自右向左压栈传递方式。设想如下的函数：
int sum(unsigned num, ..) 
其语文如下：
程序员的自我修养—链接、装载与库
---
## Page 361
338
第11章运行库
第一个参数传递一个整数num，紧接着后面会传递num个整数，返回num个整数的和。
当我们调用：
int n = 5um(3, 16, 38, 53);
参数在栈上会形成如图11-7所示的布局。
10p
53
**
38
16
3
图11-7函数参数在栈上分布
在函数内部，函数可以使用名称num来访问数字3，但无法使用任何名称访间其他的几
个不定参数。但此时由于栈上其他的几个参数实际恰好依序排列在参数num的高地址方向，
因此可以很简单地通过num的地址计算出其他参数的地址。sum函数的实现如下：
int sum(unsigned num, -.*)
int* p = &num + 1;
whi1e (num-)
int ret = 0:
:++d, =+ 191
return ret;
在这里我们可以观察到两个事实：
（1）sum函数获取参数的量仅取决于num参数的值，因此，如果num参数的值不等于
实际传递的不定参数的数量，那么sum函数可能取到错误的或不足的参数。
（2）cdecl调用惯例保证了参数的i正确清除。我们知道有些调用惯例（如 stdcall）是由
被调用方负责清除堆栈的参数，然面，被调用方在这里其实根本不知道有多少参数被传递进
来，所以没有办法清除堆栈。面cdecl恰好是调用方负责清除堆栈，因此没有这个同题。
printf 的不定参数比sum要复杂得多，因为printf的参数不仅数量不定，而且类型也不
定。所以printf需要在格式字符串中注明参数的类型，例如用%d表明是一个整数。printf里
的格式字符串如果将类型描述错误，因为不同参数的大小不同，不仅可能导致这个参数的输
出错误，还有可能导致其后的一系列参数错误。
程序员的自我修养一链接、装载与库
---
## Page 362
11.2C/C++运行库
339
【小实验】
printf 的红乱输出
include 
int main()
printf(*$1f\td\tc\n*, 1, 666,*a′);
F
在这个程序里，printf的第一个输出参数是一个int（4字节），而我们告诉printf它是一
个double（8字节以上），因此printf 的输出会错误，由于printf在读取double 的时候实际造
成了越界，因此后面几个参数的输出也会失败，该程序的实际输出为（根据实际编译器和环
境可能不同）
0.000000
97
下面让我们来看va_ist等宏应该如何实现。
va_list实际是一个指针，用来指向各个不定参数。由于类型不明，因此这个va_list以
void*或char*为最佳选择。
va_start将va_list定义的指针指向函数的最后一个参数后面的位置，这个位置就是第一
个不定参数。
va_arg获取当前不定参数的值，并根据当前不定参数的大小将指针移向下一个参数。
va_end 将指针清 0.
按照以上思路，Va系列宏的一个最简单的实现就可以得到了，如下所示：
#define va_list char*
define va_arg(ap,t)(*(c*) ((ap+=mizeof (t))-sizeof (t) ))
#define va_start (ap, arg) (ap= (va_1ist) &arg+sizeof (arg))
define va_end (ap) (ap= (va_1ist10)
【小提示】
变长参数宏
在很多时候我们希望在定义宏的时候也能够像print一样可以使用变长参数、即宏的参
数可以是任意个，这个功能可以由编译器的变长参数宏实现，在GCC编译器下，变长参数
宏可以使用“”宏字符串连接操作实现，比如：
#Gefine printf (args) fprintf (stdout, ##args)
程序员的自我修养一链接、装载与库
---
## Page 363
340
第11章运行库
邪么printf("%d %s", 123,“hello")就会被展开成：
fprintf (stdout, *&d s*, 123, *hello*)
而在MSVC下，我们可以使用_VA_ARGS_这个编译器内置宏，比如；
define printf (--) fprint f (stdout,_VA_ARGS)
它的效果与前面的GCC下使用##的效果一样。
2.非局部跳转
非局部跳转即使在C语言里也是一个备受争议的机制。使用非局部跳转，可以实现从
一个函数体内向另一个事先登记过的函数体内跳转，面不用担心堆栈混乱，下面让我们来看
一个示例：
#include 
jmp_buf b;
include 
(） PtOA
longjmp (b, 1);
Int main()
if (setjmp (b))
printf(*world!*) :
else
E () 
而事实上的输出是：
Hello Wor1d!
实际上，当 setjmp 正常返回的时候，会返回0.因此会打印出“Hello“的字样，面 longjmp
的作用，就是让程序的执行流回到当初setjmp返回的时刻，并且返回由longjmp指定的返回
值（longjmp的参数2），也就是1.自然接着会打印出“World!”并退出，换句话说，longimp
可以让程序“时光倒流”回setjmp返回的时刻，并改变其行为，以至于改变了未来。
是的，这绝对不是结构化编程。
11.2.3glibc与MSVCCRT
运行库是平台相关的，因为它与操作系统结合得非常紧密。C语言的运行库从某种程度
程序员的自我修养一链接、装载与库
---
## Page 364
11.2C/C++运行库
341
上来讲是C语言的程序和不同操作系统平台之间的抽象层，它将不同的操作系统API抽象
成相同的库函数。比如我们可以在不同的操作系统平台下使用fread来读取文件，而事实上
fread在不同的操作系统平台下的实现是不同的，但作为运行库的使用者我们不需要关心这
一点。虽然各个平台下的C语言运行库提供了很多功能，但很多时候它们毕竞有限，比如
用户的权限控制、操作系统线程创建等都不是属于标准的C语言运行库。于是我们不得不
通过其他的办法，诸如绕过C语言运行库直接调用操作系统API或使用其他的库。Linux和
Windows平台下的两个主要C语言运行库分别为glibe（GNU C Library）和 MSVCRT
（Microsoft Visual C Run-time），我们在下面将会分别介绍它们.
值得注意的是，像线程操作这样的功能并不是标准的C语言运行库的一部分，但是glibc
和MSVCRT 都包含了线程操作的库函数。比如 glibc 有一个可选的pthread库中的
pthread_createO函数可以用来创建线程：而MSVCRT中可以使用_beginthreadO函数来创建线
程。所以glibc和MSVCRT事实上是标准C语言运行库的超集，它们各自对C标准库进行
了一些扩展。
glibc
glibc 即 GNU C Library，是GNU旗下的C标准库。最初由自由软件基金会FSF（Free
SoftwareFoundation）发起开发，目的是为GNU 操作系统开发一个C标准库。GNU操作系
统的最初计划的内核是Hurd，一个微内核的构架系统。Hurd因为种种原因开发进展缓慢，
面Linux因为它的实用性而逐渐风廉，最后取代Hurd成了GNU操作系统的内核，于是glibc
从最初开始支持Hurd到后来渐渐发展成同时支持Hurd和Linux，而且随着Linux的越来越
流行，glibc 也主要关注Linux 下的开发，成为了Linux平台的C 标准库。
20世纪90年代初，在gibc成为Linux下的C运行库之前，Linux的开发者们因为开发
的需要，从Linux内核代码里面分离出了一部分代码，形成了早期Linux下的C运行库，这
个C运行库又被称为Linuxlibc。这个版本的C运行库被维护了很多年，从版本2一直开发
到版本5。如果你去看毕期版本的Linux，会发现/ib目录下面有libc.so.5这样的文件，这个
文件就是第五个版本的 Linux libc。1996年FSF发布了glibe 2.0.这个版本的glibc开始支持
诸多特性，比如它完全支持POSIX标准、国际化、IPv6、64-位数据访间、多线程及改进了
代码的可移植性。在此时Linuxlibc的开发者也认识到单独地维护一份Linux下专用的C运
行库是没有必要的，于是Linux开始采用glibc作为默认的C运行库，并且将2.x版本的glibc
看作是Linux libc的后继版本。于是我们可以看到，glibe在/ib目录下的.so文件为libc.so.6，
即第六个 libc版本，而且在各个Linux发行版中，glibc往往被称为 libc6，glibc在Linux 平
台下占据了主导地位之后，它又被移植到了其他操作系统和其他硬件平台，诸如FreeBSD、
NetBSD等，而且它支持数十种CPU及嵌入式平台，目前最新的glibc版本号是2.8（2008
年4月）。
程序员的自我修养——链接、装载与库
---
## Page 365
342