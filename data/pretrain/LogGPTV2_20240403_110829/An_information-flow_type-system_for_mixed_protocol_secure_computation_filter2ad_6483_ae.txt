7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23 }
y = r e r a n d o m i z e s t r i n g ( y ,
s e n d s t r i n g ( ”7 ” ,
return r ;
e = e n c r y p t s t r i n g (m) ;
s e n d s t r i n g ( ”5 ” ,
b = gcdecrypt ( ” compare ” ,
e = otread ( ”6 ” ,
y = d e c r y p t s t r i n g ( e ) ;
m. c h a r s [ i ] = 0 ;
e l s e
y ) ;
e ) ;
( i n t ) x . l e n , 0 ) ;
( i n t ) b ) ;
r ) ;
Listing 16: Substring: Masking Sender
The masking protocol creates a 0, 1 encrypted string which
is used to mask the local share. Care has to be taken, if the
shares of the length of the substring wrap around the mod-
ulus. Two cases need to be prepared: one in which they do
and one in which they do not wrap around. The correct one
is chosen by oblivious transfer. The condition is computed
by a comparison implemented as a Yao’s protocol. Therefore
we see also these primitives in this protocol.
The masking protocol is executed twice with roles re-
versed. Therefore we implemented each side of the protocol
as a separate function. Listing 16 shows one side and List-
ing 17 the other. Then each side is called with the local
input in the composed protocol (Listing 13 lines 6–9).
f o r ( i n t i = 0 ;
i  b ;
s t r i n g r , q ;
s t r i n g p u b y , e ,
s t r i n g p u b
y = r e c v s t r i n g ( ”5 ”) ;
f [ 0 ] . l e n = x . l e n ;
f [ 1 ] . l e n = x . l e n ;
f o r ( i n t i = 0 ;
1 s t r i n g mask recv ( s t r i n g x ) {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52 }
otsend (
q = r e c v s t r i n g ( ”7 ”) ;
q = add ( q ,
return q ;
( b == 1 ) {
e = f [ 0 ] ;
f [ 0 ] = f [ 1 ] ;
f [ 1 ] = e ;
} ” ,
( i n t ) x . l e n , n ) ;
}
b = gcencrypt (
” b o o l compare ( i n t x ,
modPow( e . c h a r s [ i ] ,
f = rerandomize ( f ,
compare = x < y ;
f [ 0 ] . c h a r s [ i ] =
f [ 1 ] . c h a r s [ i ] =
f o r ( i n t i = 0 ;
i < n ;
i f
}
f ) ;
r ) ;
r ) ;
f [ 0 ] . c h a r s [ i ] ∗ f [ 0 ] . c h a r s [ i ] ;
i ++) {
( i n t ) x . c h a r s [ i ] ) ;
f [ 1 ] . c h a r s [ i ] =
e . c h a r s [ i ] ∗
encrypt ( pubKeyExt , n −1);
modPow( f [ 1 ] . c h a r s [ i ] ,
( i n t ) x . c h a r s [ i ] ) ;
i n t y ) {
Listing 17: Substring: Masking Receiver
8. CONCLUSIONS
In this paper we consider the problem of ensuring semi-
honest security of secure computations implemented in domain-
speciﬁc languages. Currently, either the language is based
on a speciﬁc protocol which has been proven secure or on
a generic language that enables also implementing insecure
protocols. We are the ﬁrst to propose a type system to limit
the implementable protocols to only secure ones, but also
enable the programmer to freely choose the protocol prim-
itives. We prove that any well-typed program is secure in
the semi-honest model of secure computation. This presents
a new trade-oﬀ between security and performance for the
implementation of secure computations. Our type system
enables implementing complex protocols, such as one of our
examples for privacy-preserving string processing.
Future work is to extend the security guarantees to stronger
security models, such as the malicious model. In the ma-
licious model the parties may behave arbitrarily and still
privacy of inputs and correctness of outputs are preserved.
Such a security guarantee can be of practical relevance in
highly sensitive secure computations such as e-voting.
9. REFERENCES
[1] D. Beaver, S. Micali, and P. Rogaway. The Round
Complexity of Secure Protocols. Proceedings of the
22nd ACM Symposium on Theory of Computing, 1990.
[2] A. Ben-David, N. Nisan, and B. Pinkas. FairplayMP:
A System for Secure Multi-Party Computation.
Proceedings of the 15th ACM Conference on Computer
and Communications Security, 2008.
[3] M. Ben-Or, S. Goldwasser, and A. Wigderson.
Completeness Theorems for Non-Cryptographic
Fault-Tolerant Distributed Computation. Proceedings
of the 20th ACM Symposium on Theory of Computing,
1988.
[4] D. Bogdanov, S. Laur, and J. Willemson. Sharemind:
A Framework for Fast Privacy-Preserving
Computations. Proceedings of the 13th European
Symposium on Research in Computer Security, 2008.
[5] D. Bogdanov, R. Talviste, and J. Willemson.
Deploying Secure Multi-Party Computation for
Financial Data Analysis. Proceedings of the 16th
International Conference on Financial Cryptography
and Data Security, 2012.
[14] B. Goethals, S. Laur, H. Lipmaa, and T. Mielik¨ainen.
On Private Scalar Product Computation for
Privacy-Preserving Data Mining. Proceedings of the
7th International Conference on Information Security
and Cryptology, 2004.
[15] O. Goldreich. Secure Multi-party Computation.
Available at
www.wisdom.weizmann.ac.il/˜oded/pp.html, 2002.
[16] S. Goldwasser. Multi-Party Computations: Past and
Present. Proceedings of the 16th ACM Symposium on
Principles of Distributed Computing, 1997.
[17] S. Goldwasser, and S. Micali. Probabilistic Encryption.
Journal of Computer and Systems Science 28(2), 1984.
[18] W. Henecka, S. K¨ogl, A.-R. Sadeghi, T. Schneider,
and I. Wehrenberg. TASTY: Tool for Automating
Secure Two-Party Computations. Proceedings of the
17th ACM Conference on Computer and
Communications Security, 2010.
[19] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster
Secure Two-Party Computation Using Garbled
Circuits. Proceedings of the USENIX Security
Symposium, 2011.
[20] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank.
Extending Oblivious Transfers Eﬃciently. Proceedings
of CRYPTO, 2003.
[21] M. Jensen, and F. Kerschbaum. Towards
Privacy-Preserving XML Transformation. Proceedings
of the 9th IEEE International Conference on Web
Services, 2011.
[6] P. Bogetoft, D. L. Christensen, I. Damg˚ard, M.
[22] F. Kerschbaum. Automatically Optimizing Secure
Geisler, T. P. Jakobsen, M. Krøigaard, J. D. Nielsen,
J. B. Nielsen, K. Nielsen, J. Pagter, M. I.
Schwartzbach, and T. Toft. Secure Multiparty
Computation Goes Live. Proceedings of the 13th
International Conference on Financial Cryptography
and Data Security, 2009.
[7] O. Catrina, and F. Kerschbaum. Fostering the Uptake
of Secure Multiparty Computation in E-Commerce.
Proceedings of the International Workshop on
Frontiers in Availability, Reliability and Security,
2008.
Computation. Proceedings of the 18th ACM
Conference on Computer and Communications
Security, 2011.
[23] F. Kerschbaum, A. Schr¨opfer, A. Zilli, R. Pibernik, O.
Catrina, S. de Hoogh, B. Schoenmakers, S. Cimato,
and E. Damiani. Secure Collaborative Supply Chain
Management. IEEE Computer 44 (9), 2011.
[24] F. Kerschbaum, and A. Sorniotti. RFID-based Supply
Chain Partner Authentication and Key Agreement. In
Proceedings of the 2nd ACM Conference on Wireless
Network Security (WISEC), 2009.
[8] R. Cramer, I. Damg˚ard and U. Maurer. Eﬃcient
[25] V. Kolesnikov, A.-R. Sadeghi, and T. Schneider.
General Secure Multi-Party Computation from any
Linear Secret-Sharing Scheme. Proceedings of
EUROCRYPT, 2000.
[9] I. Damg˚ard, M. Geisler, M. Krøigaard, and J. B.
Nielsen. Asynchronous Multiparty Computation:
Theory and Implementation. Proceedings of the 12th
International Conference on Practice and Theory in
Public Key Cryptography, 2009.
[10] D. Denning. A Lattice Model of Secure Information
Flow. Communications of the ACM 19(5), 1976.
[11] D. Denning, and P. Denning. Certiﬁcation of
Programs for Secure Information Flow.
Communications of the ACM 20(7), 1977.
[12] C. Fournet, J. Planul, and T. Rezk. Information-Flow
Types for Homomorphic Encryptions. Proceedings of
the 18th ACM Conference on Computer and
Communications Security, 2011.
[13] C. Gentry. Fully Homomorphic Encryption using Ideal
Lattices. Proceedings of the 41st ACM Symposium on
Theory of Computing, 2009.
Modular Design of Eﬃcient Secure Function
Evaluation Protocols. Cryptology ePrint Archive
Report 2010/079, 2010.
[26] B. Lampson. A Note on the Conﬁnement Problem.
Communications of the ACM 16(10), 1973.
[27] Y. Lindell, and B. Pinkas. A Proof of Yao’s Protocol
for Secure Two-Party Computation. Journal of
Cryptology 22(2), 2009.
[28] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay
- A Secure Two-party Computation System.
Proceedings of the USENIX Security Symposium, 2004.
[29] A. Myers. JFlow: Practical Mostly-Static Information
Flow Control. Proceedings of the 26th ACM
Symposium on Principles of Programming Languages,
1999.
[30] M. Naor, and B. Pinkas. Eﬃcient Oblivious Transfer
Protocols. Proceedings of the Symposium on Data
Structures and Algorithms, 2001.
[31] D. Naccache, and J. Stern. A New Public-Key
Cryptosystem Based on Higher Residues. Proceedings
of the ACM Conference on Computer and
Communications Security, 1998.
[32] J. D. Nielsen and M. I. Schwartzbach. A
Domain-Speciﬁc Programming Language for Secure
Multiparty Computation. Proceedings of the ACM
Workshop on Programming Languages and Analysis
for Security, 2007.
[33] P. Paillier. Public-Key Cryptosystems Based on
Composite Degree Residuosity Classes. Proceedings of
EUROCRYPT, 1999.
[34] A. Sabelfeld, and A. Myers. Language-Based
Information-Flow Security. IEEE Journal on Selected
Areas in Communications 21(1), 2003.
[35] A. Schr¨opfer, F. Kerschbaum, and G. M¨uller. L1 - An
Intermediate Language for Mixed-Protocol Secure
Computation. Proceedings of the IEEE Computer
Software and Applications Conference, 2011.
[36] D. Volpano, G. Smith, and C. Irvine. A Sound Type
System for Secure Flow Analysis. Journal of
Computer Security 4(3), 1996.
[37] A. Yao. Protocols for Secure Computations.
Proceedings of the IEEE Symposium on Foundations
of Computer Science, 1982.