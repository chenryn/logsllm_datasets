# Robust, Anonymous RFID Authentication with Constant Key-Lookup

**Authors:**
- Mike Burmester
- Breno de Medeiros
- Rossana Motta

## Abstract

A significant number of anonymous RFID authentication schemes have been proposed. However, existing solutions either lack robust security guarantees or face scalability issues when the system involves a large number of tags. This paper addresses these challenges by focusing on approaches that balance robust security and scalability. Specifically, we aim to reduce the complexity of identifying tags by the back-end server in anonymous RFID authentication protocols, which we term the key-lookup problem.

We introduce a compiler that transforms a generic RFID authentication protocol (supporting anonymity) into one that maintains the same security guarantees but with constant key-lookup cost, even for very large numbers of tags (billions and beyond). Our approach leverages a lightweight one-way trapdoor function, making it suitable for current tag architectures. We then explore the minimal assumptions required and demonstrate that one-way trapdoor functions are necessary for achieving highly scalable, robustly secure solutions. Additionally, we relax the requirement of unlinkable anonymity and consider scalable solutions that are provably secure with minimal privacy loss.

**Keywords:** RFID, privacy, availability, scalability, provably secure protocols, unlinkability

## 1. Introduction

Radio-Frequency Identification (RFID) enables objects to be identified using radio waves without physical contact or line-of-sight alignment. The flexibility of this technology holds great promise for novel applications, and RFID tags are increasingly being deployed in scenarios where their proper operation must be assured to a medium or high level of confidence. Examples include using RFID to enhance the security of identification documents and to provide access control to physical resources and secure locations. In addition to authenticity and integrity, it is often desirable and sometimes required that RFID systems provide anonymized identification services to preserve the privacy of the individuals carrying them.

A considerable body of research has been developed to address the anonymous authentication problem in RFID [AO05, BvLdM06, HM04, MSW06, SWE03, Tsu06]. However, currently available solutions either do not provide robust security guarantees or suffer from scalability issues when the number of tags issued by the system is very large. The primary reason for this conflict is the limited circuit footprint available on RFID tags, which has restricted the implementation of cryptography to symmetric-key algorithms. In the anonymous setting, symmetric-key approaches introduce the difficulty that the server must first determine which tag (and corresponding key) should be used to validate the tag's authentication transcript. This difficulty is exacerbated when the system has a large number of tags, leading to vulnerabilities to denial-of-service attacks and potential privacy threats through timing attacks.

In this paper, we focus on the worst-case complexity (time and computation) of identifying tags by searching for matches in the symmetric-key database of the back-end server. Specifically, we consider the ratio between the costs of (1) authenticating the response of a tag against a single tag identity and (2) authenticating the response of a tag in an anonymous interaction (when the identity of the tag is not known a priori). This ratio is referred to as the key-lookup cost. For anonymous RFID authentication, the key-lookup cost is linear in the number of tags in the worst case (the server has to exhaust the symmetric-key database to find a match).

Molnar, Soppera, and Wagner [MSW06] presented an anonymous RFID protocol that achieves logarithmic key-lookup by using a binary tree of symmetric keys (the tree of secrets) and assigning each tag the keys of a root-to-leaf path. The response of a tag is linked to this path, and this link is used to identify the tag (only 2 log T checks are needed, where T is the number of tags). Burmester, van Le, and de Medeiros [BvLdM06] use a different approach, where the key-lookup is constant for tags that have not been previously interrogated by rogue readers (invoked by the adversary), but otherwise, it is linear.

### Organization of the Paper

After this introduction, we discuss the conflict between privacy and availability and the impact of privacy on the scalability of key-lookup in Section 2. In Section 3.2, we describe a compiler that transforms a generic RFID authentication protocol satisfying privacy requirements into one that achieves strong security with constant key-lookup when the number of tags is very large (billions of tags and beyond). This approach uses a lightweight one-way trapdoor function, as described recently by Shamir [Sha07], and produces protocols suitable for deployment into current tag architectures. In Section 4, we show that one-way trapdoor functions are necessary for strongly privacy-preserving RFID authentication that supports constant-cost key-lookup, even for large numbers of tags. Finally, in Section 5, we relax the requirement for unlinkable anonymity and consider provably secure solutions for which the loss of privacy is minimal.

### Main Contributions

- **Compiler for Scalable Key-Lookup:** A compiler that transforms any RFID authentication protocol of a certain form into one that achieves scalability for the back-end server, providing constant key-lookup cost (Section 3.2). This improves on the worst-case cost achieved by the most efficient key-lookup scheme to date, O(log n) by [MSW06].
- **Privacy and Security Guarantees:** The compiler produces new protocols from existing ones without weakening any privacy and authenticity guarantees enjoyed by the original protocols.
- **Higher Security with Constant Key-Lookup:** It can be used to construct schemes with constant key-lookup cost that achieve higher security than the scheme in [MSW06], for instance, by not requiring the use of keys shared by many tags.
- **Lightweight Implementation:** A lightweight implementation of the compiler based on the Shamir adaptation of Rabinâ€™s one-way function (Section 3.3).
- **Security Proof:** A security proof for the compiler (Section 5.4).
- **Necessity of One-Way Trapdoor Functions:** A proof that any RFID authentication protocol that is strongly privacy-preserving with constant key-lookup cost must also employ public-key obfuscation when the number of tags is large (Section 4).
- **Alternative Approach with Minimal Privacy Relaxation:** A more efficient, alternative approach for provably secure RFID authentication that supports constant key-lookup cost, under a minimal relaxation of privacy that allows for limited linkability (Section 5).

## 2. Privacy vs. Availability

Supporting privacy in RFID often conflicts with fundamental requirements such as availability, i.e., the ability of the system to function correctly and continuously throughout its projected lifetime. Attacks against availability work by forcing components of the RFID system into temporary or permanent states where they can no longer fulfill their proper roles.

There are several attack strategies against RFID systems that target availability. For example, jamming attacks seek to overwhelm the communication medium with noise; such attacks can be detected and mitigated by mechanisms at the physical layer [SWE03]. In this paper, we focus on mechanisms that support availability at the protocol level (RFID application layer).

Wireless storms occur when the number of transmissions exceeds the system's capacity to process them, thus restricting availability. These storms are typically linked to design and protocol failures rather than direct adversarial actions. For example, network flooding in a wireless network may cause a storm if the local node density is high. Similarly, in RFID systems, readers may not be able to process all tag responses when the number of tags is large, resulting in some tags not being authenticated.

The adversary may exploit the key-lookup complexity by having a rogue tag make faulty responses on behalf of several "virtual" tags. Such attacks are difficult to detect because they cannot be distinguished from non-adversarial faulty responses. If the back-end server spends more resources trying to disambiguate fake responses than the adversary spends on generating them, the RFID system is inherently flawed. Note that the cost of triggering such an "RFID storm" is limited to the cost of selecting EPC channels [EPC], one for each response, since the faulty response can be generated by simply updating a counter or a similar mechanism. Furthermore, the rogue tag is not subject to the usual tag constraints (e.g., it can have its own power supply). Therefore, it is crucial to design RFID systems with scalable key-lookup, as systems with a large number of tags may require a constant key-lookup cost to achieve resilience against attacks targeting availability (denial-of-service attacks).

At the protocol level, one must also deal with disabling attacks, which target state synchronization requirements. Strong authentication in the symmetric-key setting requires that RFID tags and the back-end server share secrets (e.g., keys and other state information). In privacy-preserving protocols, mutable information (e.g., a changing pseudonym) must be used by the back-end server to recognize the tag in the absence of fixed identification values. These represent shared dynamic states that must be maintained in synchrony by tags and the back-end server. Disabling attacks seek to break this synchronicity.

Among RFID protocols that provide strong privacy guarantees, some have limited ability to tolerate attacks against availability. For example, in [OSK03], the attacker may use invalid timestamps to disable tags temporarily or permanently. Other solutions use hierarchical key structures to speed up lookup time but are consequently more vulnerable to key-exposure threats, as higher-level keys are shared among many tags [MSW06]. Some protocols require a linear search among all issued keys to authenticate a response, an approach that is infeasible for large numbers of tags. An improvement over always requiring an exhaustive search is to employ an optimistic approach [BvLdM06, vLBdM07]. In this case, the server is normally able to recognize the tag in constant time based on a pseudonym value, but when this value becomes desynchronized, the server can recover the tag identity through a linear search among the valid (issued) keys. All protocols that (in some circumstances) require a linear search suffer from scalability issues as the number of tags in the system increases.

## 3. A Scalability-Providing Protocol Compiler

In this section, we provide a high-level description of our approach, a compiler that can transform many challenge-response RFID protocols to achieve scalability, supporting constant cost for RFID key-lookup.

### 3.1. A Generic Challenge-Response RFID Protocol

Figure 1 illustrates a typical challenge-response RFID authentication protocol. In the first pass, the reader produces a challenge \( c \) that could include a timestamp, a random nonce, or other information as specified by the protocol. In the second pass, the tag evaluates and broadcasts the result of computing a function \( f(k, c, r) \) on the challenge and (possibly) on additional input \( r \) generated by the tag. The value \( r \) could embed a tag nonce and either an identifier (if privacy is not a concern) or a (mutable) pseudonym to facilitate tag recognition without leaking its identity. The dotted line in Figure 1 indicates optional passes for added functionality, such as mutual authentication, key-update for forward-security, etc.

The security and efficiency provided by such generic protocols are highly dependent on the choice of the function \( f \), which is keyed with a symmetric key \( k \) unique to the tag and known to the back-end server. Even when focusing only on protocols that provide privacy, there are many possible implementations, providing different security guarantees. For instance, if unlinkable privacy is desired, the outputs of the function \( f \) must be indistinguishable from pseudo-random. Protocols may further differ in the method for pseudonym update and may provide additional features.