title:Robust, anonymous RFID authentication with constant key-lookup
author:Mike Burmester and
Breno de Medeiros and
Rossana Motta
Robust, Anonymous RFID Authentication with Constant
Key-Lookup
Mike Burmester(cid:3), Breno de Medeiros and Rossana Motta
Abstract
A considerable number of anonymous RFID authentication schemes have been proposed. However,
current proposals either do not provide robust security guarantees, or suffer from scalability issues when
the number of tags issued by the system is very large. In this paper, we focus on approaches that reconcile
these important requirements. In particular, we seek to reduce the complexity of identifying tags by the
back-end server in anonymous RFID authentication protocols(cid:151)what we term the key-lookup problem.
We propose a compiler that transforms a generic RFID authentication protocol (supporting anonym-
ity) into one that achieves the same guarantees with constant key-lookup cost even when the number
of tags is very large (billions of tags and beyond). This approach uses a lightweight one-way trapdoor
function and produces protocols that are suitable for deployment into current tag architectures. We then
explore the issue of minimal assumptions required, and show that one-way trapdoor functions are nec-
essary to achieve highly scalable, robustly secure solutions. We then relax the requirement of unlinkable
anonymity, and consider scalable solutions that are provably secure and for which the loss of privacy is
minimal.
Keywords: RFID, privacy, availability, scalability, provably secure protocols, unlinkability
1 Introduction
Radio-Frequency Identi(cid:2)cation (RFID) enables objects to be identi(cid:2)ed by radio waves, without physical
contact and without need for line-of-sight alignment. The (cid:3)exibility of this technology holds great promise
for novel applications, and increasingly RFID tags are being deployed in situations where their proper
operation must be assured to a medium or high level of con(cid:2)dence. Well-known examples are the use of
RFIDs to harden identi(cid:2)cation documents against forgery, or to provide access control to physical resources
and/or secure locations. In addition to the authenticiy and integrity requirements, it is often desirable, and
sometimes required, that RFIDs provide anonymized identi(cid:2)cation services, to preserve the privacy of the
persons that carry them.
A considerable body of research has been developed to provide solutions to the anonymous authentica-
tion problem in RFID [AO05, BvLdM06, HM04, MSW06, SWE03, Tsu06]. However, currently available
solutions either do not provide robust security guarantees, or suffer from scalability issues when the number
of tags issued by the system is very large. The principal reason leading to this con(cid:3)ict between requirements
is the small circuit footprint available on RFID tags, which has so far limited implementation of cryptogra-
phy in tags to symmetric-key algorithms. In the anonymous setting, symmetric-key approaches introduces
(cid:3)Part of this material is based on work supported by the NSF award 0209092, the U.S. Army Research Laboratory, and the U.S.
Research Of(cid:2)ce under grant number DAAD 19-02-1-0235.
1
the dif(cid:2)culty that the server must (cid:2)rst decide which tag (and corresponding key) should be used to validate a
tag’s authentication transcript. This dif(cid:2)culty is worsened if the system has a large number of tags, creating
vulnerabilities to denial-of-service attacks, and potentially raising threats to privacy through timing attacks.
In this paper, we focus on the worst-case complexity (time and computation) of identifying tags, by
searching for matches in the symmetric-key database of the back-end server. More speci(cid:2)cally, consider
the ratio between the costs of (1) authenticating the response of a tag against a single tag identity, and (2)
authenticating the response of a tag in an anonymous interaction (when the identity of the tag is not known
a priori). This ratio we call the key-lookup cost. In the worst case, for anonymous RFID authentication, the
key-lookup cost is linear in the number of tags (the server has to exhaust the symmetric-key database to (cid:2)nd
a match). Molnar, Soppera and Wagner [MSW06] presented an anonymous RFID protocol that achieves
logarithmic key-lookup, by using a binary tree of symmetric-keys (the tree of secrets), and assigning to each
tag the keys of a root-to-leaf path: the response of a tag is then linked to this path, and this link is used to
identify the tag (only 2 log T checks are needed, where T is the number of tags). Burmester, van Le, and de
Medeiros [BvLdM06] use a different approach, in which the key-lookup is constant for tags that have not
been previously interrogated by rogue readers (invoked by the adversary), but otherwise it is linear.
Organization of this paper. After this introduction we discuss, in Section 2, the con(cid:3)ict of privacy and
availability and the impact of privacy on scalability of key-lookup. We then describe in Section 3.2 a
compiler that transforms a generic RFID authentication protocol satisfying privacy requirements into one
that achieves strong security with constant key-lookup when the number of tags is very large (billions of
tags and beyond). This approach uses a lightweight one-way trapdoor function(cid:151)described recently by
Shamir [Sha07](cid:151)and produces protocols that are suitable for deployment into current tag architectures.
In Section 4 we show that one-way trapdoor functions are necessary for strongly privacy-preserving RFID
authentication that supports constant-cost key-lookup, even for large numbers of tags. Finally, in Section 5
we relax the requirement for unlinkable anonymity and consider provably secure solutions for which the
loss of privacy is minimal.
Our main contributions
(cid:15) A compiler that transforms any RFID authentication protocol of a certain form into one that achieves
scalability for the back-end server, providing for constant key-lookup cost (Section 3.2).
(cid:15) This improves on the worst-case cost achieved by the most ef(cid:2)cient key-lookup scheme to date(cid:151)
O(log n) by [MSW06].
The compiler produces new protocols from existing ones, in such a way as not to weaken any privacy and
authenticity guarantees enjoyed by the compilees.
(cid:15) In particular, it can be used to construct schemes with constant key-lookup cost that achieve higher
security than the scheme in [MSW06], for instance by not requiring the use of keys that are shared
by many tags.
(cid:15) A lightweight implementation of the compiler based on the Shamir adaptation of Rabin’s one-way func-
tion (Section 3.3).
(cid:15) A security proof for the compiler (Section 5.4).
(cid:15) A proof that any RFID authentication protocol that is strongly privacy-preserving with constant key-
lookup cost must also employ public-key obfuscation, when the number of tags is large (Section 4).
(cid:15) A more ef(cid:2)cient, alternative approach for provably secure RFID authentication that supports constant
key-lookup cost, under a minimal relaxation of privacy that allows for limited linkability (Section 5).
2
2 Privacy vs Availability
Support of privacy in RFID tends to con(cid:3)ict with fundamental requirements, such as availability, i.e., the
ability of the system to function correctly and continuously, through its projected lifetime. Attacks against
availability work by forcing components of the RFID system into temporary or permanent states from where
they are no longer capable of ful(cid:2)lling their proper roles.
There are several attack strategies against RFID systems that target availability. For instance, jamming
attacks seek to overwhelm the communication medium with noise; such attacks can be detected and miti-
gated by mechanisms at the physical layer [SWE03]. In this paper, we focus instead on mechanisms that
support availability at the protocol level (RFID application layer).
Storms in wireless systems are caused when the number of transmissions exceeds the capacity of the
system to process them, thus restricting availability. Typically storms are linked to design and protocol
failures, and are not caused directly by the adversary. For example, network (cid:3)ooding1 in a wireless network
may cause a storm, if the local node density is high. The same applies for RFID systems: RFID readers may
not be able to process all tag responses, when the number of tags is large. This may result in some tags not
being authenticated.
The adversary may exploit the the lookup complexity by having a rogue tag make faulty responses
on behalf of several (cid:147)virtual(cid:148) tags.
It may not be easy to detect such attacks, because they cannot be
distinguished from non-adversarial faulty responses. If the back-end server spends more resources trying
to disambiguate fake responses than the adversary spends on generating them, then the RFID system is
inherently (cid:3)awed. Note that the cost of triggering such an (cid:147)RFID storm(cid:148) is restricted to the cost of selecting
EPC channels [EPC], one for each response, since the faulty response can be generated by simply updating
a counter (or some similar mechanism). Furthermore the rogue tag is not subject to the usual tag constraints
(e.g., it can have its own power supply). It is therefore important to design RFID systems with scalable key-
lookup, as systems with large number of tags may require a constant cost of key lookup to achieve resilience
against attacks that target availability (denial-of-service attacks).
At the protocol level, one must also deal with a class of attacks against availability, termed disabling
attacks, which target state synchronization requirements. More precisely, strong authentication (in the
symmetric-key setting) requires that RFID tags and the back-end server share secrets (e.g., keys and other
state information).
In the case of privacy-preserving protocols, mutable information (e.g., a changing
pseudonym) must be used by the back-end server to recognize the tag in the absence of (cid:2)xed identi(cid:2)ca-
tion values. These represent shared dynamic states that must be maintained in synchrony by tags and the
back-end server. Disabling attacks seek to break this synchronicity.
Among RFID protocols that provide strong privacy guarantees, some have limited ability to tolerate
attacks against availability. For instance, in [OSK03], the attacker may use invalid timestamps to disable
tags temporarily or permanently. Other solutions use hierarchic key structures to speed up lookup time, but
are consequently more vulnerable to key-exposure threats, as the higher-level keys are shared among many
tags [MSW06]. Yet other protocols require linear search among all issued keys to authenticate a response, an
approach that is infeasible for large numbers of tags. An improvement over always requiring an exhaustive
search is to employ an optimistic approach [BvLdM06, vLBdM07]. In this case, the server is normally
able to recognize the tag in constant time based on a pseudonym value, but when this value becomes de-
synchronized, the server can recover the tag identity through linear search among the valid (issued) keys. All
protocols that (in some circumstances) require a linear search suffer from scalability issues as the number
of tags in the system increases.
1In network (cid:3)ooding all neighbors of a node will re-broadcast a newly received message.
3
Figure 1: A generic challenge-response RFID protocol.
RFID TAG (KEY: k)
(cid:27)
c
r; f (k; c; r)
(cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1)
READER
-
In what follows, we describe how to systematically modify RFID protocols to achieve constant-time
effort to authenticate a tag, resolving scalability issues and reconciling privacy and availability requirements
of RFID applications.
3 A Scalability-Providing Protocol Compiler
In this section, we provide a high-level description of our approach, a compiler that can transform many
challenge-response RFID protocols to achieve scalability, supporting constant cost for RFID key-lookup.
3.1 A Generic Challenge-Response RFID Protocol
Fig. 1 illustrates a typical challenge-response RFID authentication protocol. In the (cid:2)rst pass, the reader
produces a challenge c that could include a timestamp, a random nonce, or other information as speci(cid:2)ed
by the protocol. In the second pass, the tag evaluates and broadcasts the result of computing a function
f (k; (cid:1); (cid:1)) on the challenge and (possibly) on additional input r generated by the tag. The value r could embed
a tag nonce and either an identi(cid:2)er (if privacy is not a concern), or a (mutable) pseudonym to facilitate
tag recognition without leaking its identity. The dotted line in Fig. 1 indicates optional passes for added
functionality, such as mutual authentication, key-update for forward-security, etc.
The security and ef(cid:2)ciency provided by such generic protocols are highly related to the choice of the
function f, which is keyed with a symmetric-key k unique to the tag and known to the back-end server
(not depicted above). Even restricting our attention only to protocols that provide privacy, there are many
possibilities for implementation of the above protocol, providing different security guarantees. For instance,
if unlinkable privacy is desired, the outputs of the function f must be indistinguishable from pseudo-random.
Protocols may further differ on the method for pseudonym update, and may provide for additional features(cid:151)