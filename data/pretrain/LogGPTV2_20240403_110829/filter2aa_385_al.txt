returnres,nil
}
Listing3-17:MetasploitAPIcallsimplementation(/ch-3/metasploit-
minimal/rpc/msf.go)
Youdefinethreemethods:Login()❶,Logout()❸,and
SessionList()❺.Eachmethodusesthesamegeneralflow:create
andinitializearequeststruct,createtheresponsestruct,and
callthehelperfunction❷❹❼tosendtherequestandreceive
thedecodedresponse.TheLogin()andLogout()methods
manipulatethetokenproperty.Theonlysignificantdifference
betweenmethodlogicappearsintheSessionList()method,where
youdefinetheresponseasamap[uint32]SessionListRes❻andloop
overthatresponsetoflattenthemap❽,settingtheIDproperty
onthestructratherthanmaintainingamapofmaps.
Rememberthatthesession.list()RPCfunctionrequiresavalid
authenticationtoken,meaningyouhavetologinbeforethe
SessionList()methodcallwillsucceed.Listing3-18usesthe
Metasploitreceiverstructtoaccessatoken,whichisn’tavalid
valueyet—it’sanemptystring.Sincethecodeyou’re
developinghereisn’tfullyfeatured,youcouldjustexplicitly
includeacalltoyourLogin()methodfromwithintheSessionList()
method,butforeachadditionalauthenticatedmethodyou
implement,you’dhavetocheckfortheexistenceofavalid
authenticationtokenandmakeanexplicitcalltoLogin().This
isn’tgreatcodingpracticebecauseyou’dspendalotoftime
repeatinglogicthatyoucouldwrite,say,aspartofa
bootstrappingprocess.
You’vealreadyimplementedafunction,New(),designedto
beusedforbootstrapping,sopatchupthatfunctiontosee
whatanewimplementationlookslikewhenincluding
authenticationaspartoftheprocess(seeListing3-18).
funcNew(host,user,passstring)(*Metasploit,error)❶{
msf:=&Metasploit{
host:host,
user:user,
pass:pass,
}
iferr:=msf.Login()❷;err!=nil{
returnnil,err
}
returnmsf,nil
}
Listing3-18:InitializingtheclientwithembeddingMetasploitlogin(/ch-
3/metasploit-minimal/rpc/msf.go)
Thepatched-upcodenowincludesanerroraspartofthe
returnvalueset❶.Thisistoalertonpossibleauthentication
failures.Also,addedtothelogicisanexplicitcalltotheLogin()
method❷.AslongastheMetasploitstructisinstantiatedusing
thisNew()function,yourauthenticatedmethodcallswillnow
haveaccesstoavalidauthenticationtoken.
CreatingaUtilityProgram
Nearingtheendofthisexample,yourlasteffortistocreate
theutilityprogramthatimplementsyourshinynewlibrary.
EnterthecodeinListing3-19intoclient/main.go,runit,and
watchthemagichappen.
packagemain
import(
"fmt"
"log"
"github.com/blackhat-go/bhg/ch-3/metasploit-minimal/rpc"
)
funcmain(){
host:=os.Getenv("MSFHOST")
pass:=os.Getenv("MSFPASS")
user:="msf"
ifhost==""||pass==""{
log.Fatalln("MissingrequiredenvironmentvariableMSFHOSTor
MSFPASS")
}
msf,err:=rpc.New(host,user,pass)❶
iferr!=nil{
log.Panicln(err)
}
❷defermsf.Logout()
sessions,err:=msf.SessionList()❸
iferr!=nil{
log.Panicln(err)
}
fmt.Println("Sessions:")
❹for_,session:=rangesessions{
fmt.Printf("%5d%s\n",session.ID,session.Info)
}
}
Listing3-19:Consumingourmsfrpcpackage(/ch-3/metasploit-
minimal/client/main.go)
First,bootstraptheRPCclientandinitializeanewMetasploit
struct❶.Remember,youjustupdatedthisfunctiontoperform
authenticationduringinitialization.Next,ensureyoudoproper
cleanupbyissuingadeferredcalltotheLogout()method❷.
Thiswillrunwhenthemainfunctionreturnsorexits.Youthen
issueacalltotheSessionList()method❸anditerateoverthat
responsetolistouttheavailableMeterpretersessions❹.
Thatwasalotofcode,butfortunately,implementingother
APIcallsshouldbesubstantiallylessworksinceyou’lljustbe
definingrequestandresponsetypesandbuildingthelibrary
methodtoissuetheremotecall.Here’ssampleoutput
produceddirectlyfromourclientutility,showingone
establishedMeterpretersession:
$gorunmain.go
Sessions:
1WIN-HOME\jsmith@WIN-HOME
Thereyouhaveit.You’vesuccessfullycreatedalibrary
andclientutilitytointeractwitharemoteMetasploitinstance
toretrievetheavailableMeterpretersessions.Next,you’ll
ventureintosearchengineresponsescrapinganddocument
metadataparsing.
PARSINGDOCUMENTMETADATA
WITHBINGSCRAPING
WITHBINGSCRAPING
AswestressedintheShodansection,relativelybenign
information—whenviewedinthecorrectcontext—canprove
tobecritical,increasingthelikelihoodthatyourattackagainst
anorganizationsucceeds.Informationsuchasemployee
names,phonenumbers,emailaddresses,andclientsoftware
versionsareoftenthemosthighlyregardedbecausethey
provideconcreteoractionableinformationthatattackerscan
directlyexploitorusetocraftattacksthataremoreeffective
andhighlytargeted.Onesuchsourceofinformation,
popularizedbyatoolnamedFOCA,isdocumentmetadata.
Applicationsstorearbitraryinformationwithinthe
structureofafilesavedtodisk.Insomecases,thiscaninclude
geographicalcoordinates,applicationversions,operating
systeminformation,andusernames.Betteryet,searchengines
containadvancedqueryfiltersthatallowyoutoretrieve
specificfilesforanorganization.Theremainderofthis
chapterfocusesonbuildingatoolthatscrapes—orasmy
lawyercallsit,indexes—Bingsearchresultstoretrievea
targetorganization’sMicrosoftOfficedocuments,
subsequentlyextractingrelevantmetadata.
SettingUptheEnvironmentandPlanning
Beforedivingintothespecifics,we’llstartbystatingthe
objectives.First,you’llfocussolelyonOfficeOpenXML
documents—thoseendinginxlsx,docx,pptx,andsoon.
AlthoughyoucouldcertainlyincludelegacyOfficedatatypes,
thebinaryformatsmakethemexponentiallymore
complicated,increasingcodecomplexityandreducing
readability.ThesamecanbesaidforworkingwithPDFfiles.
Also,thecodeyoudevelopwon’thandleBingpagination,
insteadonlyparsinginitialpagesearchresults.Weencourage
youtobuildthisintoyourworkingexampleandexplorefile
typesbeyondOpenXML.
WhynotjustusetheBingSearchAPIsforbuildingthis,
ratherthandoingHTMLscraping?Becauseyoualreadyknow
howtobuildclientsthatinteractwithstructuredAPIs.There
arepracticalusecasesforscrapingHTMLpages,particularly
whennoAPIexists.Ratherthanrehashingwhatyoualready
know,we’lltakethisasanopportunitytointroduceanew
methodofextractingdata.You’lluseanexcellentpackage,
goquery,whichmimicsthefunctionalityofjQuery,aJavaScript
librarythatincludesanintuitivesyntaxtotraverseHTML
documentsandselectdatawithin.Startbyinstallinggoquery:
$gogetgithub.com/PuerkitoBio/goquery
Fortunately,that’stheonlyprerequisitesoftwareneededto
completethedevelopment.You’llusestandardGopackages
tointeractwithOpenXMLfiles.Thesefiles,despitetheirfile
typesuffix,areZIParchivesthat,whenextracted,contain
XMLfiles.Themetadataisstoredintwofileswithinthe
docPropsdirectoryofthearchive:
$unziptest.xlsx
$tree
--snip--
|---docProps
||---app.xml
||---core.xml
--snip—
Thecore.xmlfilecontainstheauthorinformationaswellas
modificationdetails.It’sstructuredasfollows:
DanKottmann❶
DanKottmann❷
2016-12-06T18:24:42Z
2016-12-06T18:25:32Z
Thecreator❶andlastModifiedBy❷elementsareofprimary
interest.Thesefieldscontainemployeeorusernamesthatyou
canuseinasocial-engineeringorpassword-guessing
campaign.
Theapp.xmlfilecontainsdetailsabouttheapplicationtype
andversionusedtocreatetheOpenXMLdocument.Here’s
itsstructure:
MicrosoftExcel❶
0
false
Worksheets
1
Sheet1
ACME❷
false
false
false
15.0300❸
You’reprimarilyinterestedinjustafewofthoseelements:
Application❶,Company❷,andAppVersion❸.Theversionitself
doesn’tobviouslycorrelatetotheOfficeversionname,suchas
Office2013,Office2016,andsoon,butalogicalmapping
doesexistbetweenthatfieldandthemorereadable,
commonlyknownalternative.Thecodeyoudevelopwill
maintainthismapping.
DefiningthemetadataPackage
InListing3-20,definetheGotypesthatcorrespondtothese
XMLdatasetsinanewpackagenamedmetadataandputthe
codeinafilenamedopenxml.go—onetypeforeachXMLfile
youwishtoparse.Thenaddadatamappingandconvenience
functionfordeterminingtherecognizableOfficeversionthat
correspondstotheAppVersion.
typeOfficeCorePropertystruct{
XMLNamexml.Name`xml:"coreProperties"`
Creatorstring`xml:"creator"`
LastModifiedBystring`xml:"lastModifiedBy"`
}
typeOfficeAppPropertystruct{
XMLNamexml.Name`xml:"Properties"`
Applicationstring`xml:"Application"`
Companystring`xml:"Company"`
Versionstring`xml:"AppVersion"`
}
varOfficeVersions❶=map[string]string{
"16":"2016",
"15":"2013",
"14":"2010",
"12":"2007",
"11":"2003",
}
func(a*OfficeAppProperty)GetMajorVersion()❷string{
tokens:=strings.Split(a.Version,".")❸
iflen(tokens)<2{
return"Unknown"
}
v,ok:=OfficeVersions❹[tokens[0]]
if!ok{
return"Unknown"
}
returnv
}
Listing3-20:OpenXMLtypedefinitionandversionmapping(/ch-3/bing-
metadata/metadata/openxml.go)
AfteryoudefinetheOfficeCorePropertyandOfficeAppProperty
types,defineamap,OfficeVersions,thatmaintainsarelationship
ofmajorversionnumberstorecognizablereleaseyears❶.To
usethismap,defineamethod,GetMajorVersion(),onthe
OfficeAppPropertytype❷.ThemethodsplitstheXMLdata’s
AppVersionvaluetoretrievethemajorversionnumber❸,
subsequentlyusingthatvalueandtheOfficeVersionsmapto
retrievethereleaseyear❹.
MappingtheDatatoStructs
Nowthatyou’vebuiltthelogicandtypestoworkwithand
inspecttheXMLdataofinterest,youcancreatethecodethat
readstheappropriatefilesandassignsthecontentstoyour
structs.Todothis,defineNewProperties()andprocess()functions,
asshowninListing3-21.
funcNewProperties(r*zip.Reader)(*OfficeCoreProperty,*OfficeAppProperty,
error){❶
varcorePropsOfficeCoreProperty
varappPropsOfficeAppProperty
for_,f:=ranger.File{❷
switchf.Name{❸
case"docProps/core.xml":
iferr:=process(f,&coreProps)❹;err!=nil{
returnnil,nil,err
}
case"docProps/app.xml":
iferr:=process(f,&appProps)❺;err!=nil{
returnnil,nil,err
}
default:
continue
}
}
return&coreProps,&appProps,nil
}
funcprocess(f*zip.File,propinterface{})error{❻
rc,err:=f.Open()
iferr!=nil{
returnerr
}
deferrc.Close()
iferr:=❼xml.NewDecoder(rc).Decode(&prop);err!=nil{
returnerr
}
returnnil
}
Listing3-21:ProcessingOpenXMLarchivesandembeddedXMLdocuments(/ch-
3/bing-metadata/metadata/openxml.go)
TheNewProperties()functionacceptsa*zip.Reader,which
representsanio.ReaderforZIParchives❶.Usingthezip.Reader
instance,iteratethroughallthefilesinthearchive❷,
checkingthefilenames❸.Ifafilenamematchesoneofthe
twopropertyfilenames,calltheprocess()function❹❺,passing
inthefileandthearbitrarystructuretypeyouwishtopopulate
—eitherOfficeCorePropertyorOfficeAppProperty.
Theprocess()functionacceptstwoparameters:a*zip.Fileand
aninterface{}❻.SimilartotheMetasploittoolyoudeveloped,
thiscodeacceptsagenericinterface{}typetoallowforthefile
contentstobeassignedintoanydatatype.Thisincreasescode
reusebecausethere’snothingtype-specificwithintheprocess()
function.Withinthefunction,thecodereadsthecontentsof
thefileandunmarshalstheXMLdataintothestruct❼.
SearchingandReceivingFileswithBing
Younowhaveallthecodenecessarytoopen,read,parse,and
extractOfficeOpenXMLdocuments,andyouknowwhatyou
needtodowiththefile.Now,youneedtofigureouthowto
searchforandretrievefilesbyusingBing.Here’stheplanof
actionyoushouldfollow:
1. SubmitasearchrequesttoBingwithproperfilterstoretrievetargetedresults.
2. ScrapetheHTMLresponse,extractingtheHREF(link)datatoobtaindirect
URLsfordocuments.
3. SubmitanHTTPrequestforeachdirectdocumentURL
4. Parsetheresponsebodytocreateazip.Reader
5. Passthezip.Readerintothecodeyoualreadydevelopedtoextractmetadata.
Thefollowingsectionsdiscusseachofthesestepsinorder.
Thefirstorderofbusinessistobuildasearchquery
template.MuchlikeGoogle,Bingcontainsadvancedquery
parametersthatyoucanusetofiltersearchresultson
numerousvariables.Mostofthesefiltersaresubmittedina
filter_type:valueformat.Withoutexplainingalltheavailablefilter
types,let’sinsteadfocusonwhathelpsyouachieveyourgoal.
Thefollowinglistcontainsthethreefiltersyou’llneed.Note
thatyoucoulduseadditionalfilters,butatthetimeofthis
writing,theybehavesomewhatunpredictably.
siteUsedtofiltertheresultstoaspecificdomain
filetypeUsedtofiltertheresultsbasedoffresourcefiletype
instreamsetUsedtofiltertheresultstoincludeonlycertain
fileextensions
Anexamplequerytoretrievedocxfilesfromnytimes.com
wouldlooklikethis:
site:nytimes.com&&filetype:docx&&instreamset:(urltitle):docx
Aftersubmittingthatquery,takeapeekattheresulting
URLinyourbrowser.ItshouldresembleFigure3-1.
Additionalparametersmayappearafterthis,butthey’re
inconsequentialforthisexample,soyoucanignorethem.
NowthatyouknowtheURLandparameterformat,you
canseetheHTMLresponse,butfirstyouneedtodetermine
whereintheDocumentObjectModel(DOM)thedocument
linksreside.Youcandothisbyviewingthesourcecode
directly,orlimittheguessworkandjustuseyourbrowser’s
developertools.ThefollowingimageshowsthefullHTML
elementpathtothedesiredHREF.Youcanusetheelement
inspector,asinFigure3-1,toquicklyselectthelinktoreveal
itsfullpath.
Figure3-1:Abrowserdevelopertoolshowingthefullelementpath
Withthatpathinformation,youcanusegoqueryto
systematicallypullalldataelementsthatmatchanHTML
path.Enoughtalk!Listing3-22putsitalltogether:retrieving,
scraping,parsing,andextracting.Savethiscodetomain.go.
❶funchandler(iint,s*goquery.Selection){
url,ok:=s.Find("a").Attr("href")❷
if!ok{
return