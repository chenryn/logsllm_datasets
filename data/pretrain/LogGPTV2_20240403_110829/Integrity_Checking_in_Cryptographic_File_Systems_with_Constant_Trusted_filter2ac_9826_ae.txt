i
t
d
a
e
R
)
B
M
n
i
(
e
g
a
r
o
t
s
d
e
t
s
u
r
t
n
U
0
1024
2048
4096
Size of cache for Merkle trees (in bytes)
0
1024
2048
4096
Size of cache for Merkle trees (in bytes)
Figure 9: Evaluation for high-entropy ﬁles (image and compressed ﬁles).
Running time relative to AES-Merkle
Average integrity bandwidth relative to AES-Merkle
Total untrusted storage for integrity relative to AES-Merkle
1
0.5
100%
50%
0%
o
i
t
a
R
0
-0.5
-1
MT-EINT
RAND-EINT
COMP-EINT
100%
100%
50%
0%
100%
100%
100%
50%
50%
50%
50%
o
i
t
a
R
0%
0%
0%
0%
1
0.5
0
-0.5
-1
MT-EINT
RAND-EINT
COMP-EINT
100%
100%
100%
100%
50%
50%
50%
50%
0%
0%
0%
0%
100%
100%
50%
50%
0%
0%
1
0.5
0
o
i
t
a
R
MT-EINT
RAND-EINT
COMP-EINT
100%
100%
100%
100%
100%
100%
-0.5
50%
50%
50%
50%
50%
50%
-1
0%
0%
0%
0%
0%
0%
LAIR
DEASNA
Trace
HOME02
LAIR
DEASNA
Trace
HOME02
LAIR
DEASNA
Trace
HOME02
Figure 10: Running time, average integrity bandwidth and storage for integrity of RAND-EINT and COMP-EINT
relative to MT-EINT. Labels on the graphs represent percentage of random-looking blocks.
The amount of additional untrusted storage for integrity
in the DEASNA trace is 2.56 MB for MT-EINT and
only 7 KB for RAND-EINT and COMP-EINT. The
maximum overhead added by both RAND-EINT and
COMP-EINT compared to MT-EINT for high-entropy
blocks is 30.76% for the average integrity bandwidth (in
the HOME02 trace) and 19.14% for the amount of un-
trusted storage for integrity (in the DEASNA trace).
7.3 Discussion
From the evaluation of the three constructions, it follows
that none of the schemes is a clear winner over the others
with respect to all the four metrics considered. Since the
performance of both RAND-EINT and COMP-EINT is
greatly affected by ﬁle block contents, it would be ben-
eﬁcial to know the percentage of high-entropy blocks in
practical ﬁlesystem workloads. To determine statistics
on ﬁle contents, we have performed a user study on sev-
eral machines from our department running Linux. For
each user machine, we have measured the percent of
high-entropy blocks and the percent of blocks that can-
not be compressed enough from users’ home directories.
The results show that on average, 28% percent of ﬁle
blocks have high entropy and 32% percent of ﬁle blocks
cannot be compressed enough to ﬁt a MAC inside.
The implications of our study are that, for crypto-
graphic ﬁle systems that store ﬁles similar to those in
users’ home directories, the new integrity algorithms im-
prove upon Merkle trees with respect to all four metrics
of interest.
In particular, COMP-EINT is the best op-
tion for primarily read-only workloads when minimizing
read latency is a priority, and RAND-EINT is the best
196
16th USENIX Security Symposium
USENIX Association
choice for most other workloads. On the other hand, for
an application in which the large majority of ﬁles have
high-entropy (e.g., a ﬁle sharing application in which
users transfer mostly audio and video ﬁles), the standard
MT-EINT still remains the best option for integrity. We
recommend that all three constructions be implemented
in a cryptographic ﬁle system. An application can choose
the best scheme based on its typical workload.
The new algorithms that we propose can be applied
in other settings in which authentication of data stored
on untrusted storage is desired. One example is check-
ing the integrity of arbitrarily-large memory in a secure
processor using only a constant amount of trusted stor-
age [5, 7]. In this setting, a trusted checker maintains a
constant amount of trusted storage and, possibly, a cache
of data blocks most recently read from the main memory.
The goal is for the checker to verify the integrity of the
untrusted memory using a small bandwidth overhead.
The algorithms described in this paper can be used
only in applications where the data that needs to be au-
thenticated is encrypted. However, the COMP-EINT
integrity algorithm can be easily modiﬁed to ﬁt into a
setting in which data is only authenticated and not en-
crypted, and can thus replace Merkle trees in such ap-
plications. On the other hand, the RAND-EINT integrity
algorithm is only suitable in a setting in which data is en-
crypted with a tweakable cipher, as the integrity guaran-
tees of this algorithm are based on the security properties
of such ciphers.
8 Related Work
We have focused on Merkle trees as our point of compar-
ison, though there are other integrity protections used on
various cryptographic ﬁle systems that we have elided
due to their greater expense in various measures. For
example, a common integrity method used in crypto-
graphic ﬁle systems such as TCFS [6] and SNAD [25] is
to store a hash or message authentication code for each
ﬁle block for authenticity. However, these approaches
employ trusted storage linear in the number of blocks
in the ﬁle (either the hashes or a counter per block). In
systems such as SFS [22], SFSRO [11], Cepheus [10],
FARSITE [1], Plutus [17], SUNDR [20] and IBM Stor-
ageTank [23, 27], a Merkle tree per ﬁle is built and the
root of the tree is authenticated (by either digitally sign-
ing it or storing it in a trusted meta-data server). In SiR-
iUS [13], each ﬁle is digitally signed for authenticity, and
so in addition the integrity bandwidth to update or check
a block in a ﬁle is linear in the ﬁle size. Tripwire [19] is a
user-level tool that computes a hash per ﬁle and stores it
in trusted storage. While this approach achieves constant
trusted storage for integrity per ﬁle, the integrity band-
width is linear in the number of blocks in the ﬁle. For
journaling ﬁle systems, an elegant solution for integrity
called hash logging is provided by PFS [32]. The hashes
of ﬁle blocks together with the ﬁle system metadata are
stored in the ﬁle system log, a protected memory area.
However, in this solution the amount of trusted storage
for integrity for a ﬁle is linear in the number of blocks in
the ﬁle.
Riedel et al. [28] provides a framework for extensively
evaluating the security of storage systems. Wright et
al. [33] evaluates the performance of ﬁve cryptographic
ﬁle systems, focusing on the overhead of encryption.
Two other recent surveys about securing storage systems
are by Sivathanu et al. [31] and Kher and Kimand [18].
9 Conclusion
We have proposed two new integrity constructions,
RAND-EINT and COMP-EINT, that authenticate ﬁle
blocks in a cryptographic ﬁle system using only a con-
stant amount of trusted storage per ﬁle. Our construc-
tions exploit the typical low entropy of block contents
and sequentiality of ﬁle block writes to reduce the addi-
tional costs of integrity protection. We have evaluated
the performance of the new constructions relative to the
widely used Merkle tree algorithm, using ﬁles from a
standard Linux distribution and NFS traces collected at
Harvard university. Our experimental evaluation demon-
strates that the performance of the new algorithms is
greatly affected by ﬁle block contents and ﬁle access
patterns. For workloads with majority low-entropy ﬁle
blocks, the new algorithms improve upon Merkle trees
with respect to all the four metrics considered.
References
[1] A. Adya, W. J. Bolosky, M. Castro, G. Cermak,
R. Chaiken, J. R. Douceur, J. Howell, J. R. Lorch,
M. Theimer, and R. P. Wattenhofer. FARSITE: Feder-
ated, available, and reliable storage for an incompletely
trusted environment. In Proc. 5th Symposium on Operat-
ing System Design and Implementation (OSDI). Usenix,
2002.
[2] Advanced encryption standard. Federal Information Pro-
cessing Standards Publication 197, U.S. Department of
Commerce/National Institute of Standards and Technol-
ogy, National Technical Information Service, Springﬁeld,
Virginia, Nov. 2001.
[3] M. Bellare, R. Canetti, and H. Krawczyk. Keying hash
functions for message authentication.
In Proc. Crypto
1996, volume 1109 of Lecture Notes in Computer Sci-
ence, pages 1–15. Springer-Verlag, 1996.
USENIX Association
16th USENIX Security Symposium
197
[4] J. Black and H. Urtubia. Side-channel attacks on sym-
metric encryption schemes: The case for authenticated
encryption. In Proc. 11th USENIX Security Symposium,
pages 327–338, 2002.
[5] M. Blum, W. S. Evans, P. Gemmell, S. Kannan, and
M. Naor. Checking the correctness of memories. Algo-
rithmica, 12:225–244, 1994.
[6] G. Cattaneo, L. Catuogno, A. D. Sorbo, and P. Persiano.
The design and implementation of a transparent crypto-
graphic ﬁle system for Unix.
In Proc. USENIX Annual
Technical Conference 2001, Freenix Track, pages 199–
212, 2001.
[7] D. E. Clarke, G. E. Suh, B. Gassend, A. Sudan, M. van
Dijk, and S. Devadas. Towards constant bandwidth over-
head integrity checking of untrusted data. In Proc. 26th
IEEE Symposium on Security and Privacy, pages 139–
153, 2005.
[8] DES modes of operation. Federal Information Process-
ing Standards Publication 81, U.S. Department of Com-
merce/National Bureau of Standards, National Technical
Information Service, Springﬁeld, Virginia, 1980.
[9] D. Ellard, J. Ledlie, P. Malkani, and M. Seltzer. Passive
NFS tracing of email and research workloads. In Proc.
Second USENIX Conference on File and Storage Tech-
nologies (FAST), pages 203–216, 2003.
[10] K. Fu. Group sharing and random access in cryptographic
storage ﬁle systems. Master’s thesis, Massachusetts Insti-
tute of Technology, 1999.
[11] K. Fu, F. Kaashoek, and D. Mazieres. Fast and secure
distributed read-only ﬁle system. ACM Transactions on
Computer Systems, 20:1–24, 2002.
[12] FUSE: ﬁlesystem in userspace.
http://fuse.
sourceforge.net.
[13] E. Goh, H. Shacham, N. Modadugu, and D. Boneh. SiR-
In Proc. Net-
iUS: Securing remote untrusted storage.
work and Distributed Systems Security (NDSS) Sympo-
sium 2003, pages 131–145. ISOC, 2003.
[14] V. Gough. EncFS encrypted ﬁlesystem.
http://
arg0.net/wiki/encfs, 2003.
[15] S. Halevi and P. Rogaway. A tweakable enciphering
mode.
In Proc. Crypto 2003, volume 2729 of Lecture
Notes in Computer Science, pages 482–499. Springer-
Verlag, 2003.
[16] S. Halevi and P. Rogaway. A parallelizable enciphering
mode.
In Proc. The RSA conference - Cryptographer’s
track (RSA-CT), volume 2964 of Lecture Notes in Com-
puter Science, pages 292–304. Springer-Verlag, 2004.
[17] M. Kallahalla, E. Riedel, R. Swaminathan, Q. Wang, and
K. Fu. Plutus: Scalable secure ﬁle sharing on untrusted
storage. In Proc. Second USENIX Conference on File and
Storage Technologies (FAST), 2003.
[18] V. Kher and Y. Kim. Securing distributed storage: Chal-
lenges, techniques, and systems. In Proc. First ACM In-
ternational Workshop on Storage Security and Survivabil-
ity (StorageSS 2005), 2005.
[19] G. H. Kim and E. H. Spafford. The design and imple-
mentation of Tripwire: A ﬁlesystem integrity checker. In
Proc. Second ACM Conference on Computer and Com-
munication Security (CCS), pages 18–29, 1994.
[20] J. Li, M. Krohn, D. Mazieres, and D. Shasha. Secure un-
trusted data repository. In Proc. 6th Symposium on Oper-
ating System Design and Implementation (OSDI), pages
121–136. Usenix, 2004.
[21] M. Liskov, R. Rivest, and D. Wagner. Tweakable block
In Proc. Crypto 2002, volume 2442 of Lec-
ciphers.
ture Notes in Computer Science, pages 31–46. Springer-
Verlag, 2002.
[22] D. Mazieres, M. Kaminsky, M. Kaashoek,
and
E. Witchel. Separating key management from ﬁle system
security.
In Proc. 17th ACM Symposium on Operating
Systems Principles (SOSP), pages 124–139. ACM Press,
1999.
[23] J. Menon, D. Pease, R. Rees, L. Duyanovich, and
B. Hillsberg. IBM Storage Tank - a heterogeneous scal-
able SAN ﬁle system. IBM Systems Journal, 42(2), 2003.
[24] R. Merkle. A certiﬁed digital signature. In Proc. Crypto
1989, volume 435 of Lecture Notes in Computer Science,
pages 218–238. Springer-Verlag, 1989.
[25] E. Miller, D. Long, W. Freeman, and B. Reed. Strong
security for distributed ﬁle systems.
In Proc. the First
USENIX Conference on File and Storage Technologies
(FAST), 2002.
[26] A. Oprea, M. K. Reiter, and K. Yang. Space-efﬁcient
block storage integrity. In Proc. Network and Distributed
System Security Symposium (NDSS). ISOC, 2005.
[27] R. Pletka and C. Cachin. Cryptographic security for a
high-performance distributed ﬁle system. Technical Re-
port RZ 3661, IBM Research, Sept. 2006.
[28] E. Riedel, M. Kallahalla, and R. Swaminathan. A frame-
work for evaluating storage system security. In Proc. First
USENIX Conference on File and Storage Technologies
(FAST), pages 15–30, 2002.
[29] P. Rogaway and T. Shrimpton. Cryptographic hash-
function basics: Deﬁnitions, implications, and separa-
tions for preimage resistance, second-preimage resis-
tance, and collision resistance. In Proc. 11th International
Workshop on Fast Software Encryption (FSE 2004), vol-
ume 3017 of Lecture Notes in Computer Science, pages
371–388. Springer-Verlag, 2004.
[30] Secure hash standard. Federal Information Processing
Standards Publication 180-1, U.S. Department of Com-
merce/National Institute of Standards and Technology,
National Technical Information Service, Springﬁeld, Vir-
ginia, Apr. 1995.
[31] G. Sivathanu, C. Wright, and E. Zadok. Ensuring data in-
tegrity in storage: Techniques and applications. In Proc.
ACM Workshop on Storage Security and Survivability,
2005.
[32] C. A. Stein, J. Howard, and M. I. Seltzer. Unifying ﬁle
In Proc. USENIX Annual Technical
system protection.
Conference, pages 79–90, 2001.
[33] C. P. Wright, J. Dave, and E. Zadok. Cryptographic ﬁle
systems performance: What you don’t know can hurt you.
In Proc. Second Intl. IEEE Security in Storage Workhsop
(SISW), 2003.
198
16th USENIX Security Symposium
USENIX Association