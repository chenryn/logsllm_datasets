### 优化后的文本

#### I/O延迟分布
- **256 -> 511**: 25
- **51.2 -> 1023**: 43
- **1024 -> 2047**: 206
- **2048 -> 4095**: 8
- **4096 -> 8191**: 8
- **8192 -> 16383**: 392

**磁盘设备**: `nvme0n1*`

- **0 -> 1**: 0
- **8 -> 15**: 12
- **16 -> 31**: 72
- **128 -> 255**: 74
- **256 -> 511**: 13
- **512 -> 1023**: 4
- **1024 -> 2047**: 23
- **4096 -> 8191**: 63

---

## 第 392 页
### 9.3 BPF 工具
输出显示了两个非常不同的磁盘设备：`nvme0n1`，一个基于闪存的磁盘，I/O 延迟通常在 32 到 127 微秒之间；以及 `sdb`，一个外部 USB 存储设备，其 I/O 延迟分布在毫秒级别，并且是双峰分布。

#### 选项
BCC 的 `biolatency(8)` 还有一个 `-F` 选项，用于以不同的方式打印每组 I/O 标志。例如，使用 `-Fn` 选项来生成毫秒级别的直方图：
```bash
biolatency -Fn
```
输出示例：
- **flags = Bead**
  - **0 -> 1**: 180
  - **2 -> 3**: 519
  - **4 -> 7**: 60
  - **8 -> 15**: 123
  - **16 -> 31**: 6B
  - **32 -> 63**: 0
  - **64 -> 127**: 2
  - **128 -> 255**: 12
  - **256 -> 511**: 0
  - **512 -> 1023**: 1

- **flags = Sync-Krite**
  - **0 -> 1**: 8
  - **2 -> 7**: 37
  - **8 -> 15**: 65
  - **16 -> 31**: 93
  - **128 -> 255**: 0
  - **256 -> 511**: 4
  - **512 -> 1023**: 17

- **flags = Flush**
  - **0 -> 1**: 2

- **flags = Metadata-Resd**
  - **0 -> 1**: 3
  - **8 -> 15**: 1
  - **16 -> 31**: 1

上述输出显示同步写操作具有双峰分布，其中一个较慢的模式在 512 到 1023 毫秒范围内。

这些标志也可以通过块跟踪点的 `rwbs` 字段和单字母编码看到。请参阅本章前面的 `rwbs` 部分，了解该字段的解释。

#### BCC 命令行用法
```bash
biolatency [options] [interval [count]]
```
选项包括：
- `-m`: 以毫秒为单位打印输出（默认是微秒）
- `-Q`: 包括操作系统队列时间
- `-D`: 单独显示每个磁盘
- `-T`: 在输出中包含时间戳

使用间隔为 1 将打印每秒的直方图。此信息可以可视化为延迟热图，其中一整秒作为列，延迟范围作为行，颜色饱和度表示该时间段内的 I/O 数量。

#### bpftrace 版本
以下是 bpftrace 版本的核心功能代码：

```c
BEGIN
{
    printf("Tracing block device I/O..\n");
}
kprobe:blk_account_io_start
{
    @start[arg0] = nsecs;
}
kprobe:blk_account_io_done
/[@start[arg0]]/
{
    @usecs = hist(nsecs - @start[arg0] / 1000);
    delete(@start[arg0]);
}
END
{
    clear(@start);
}
```

此工具需要在每个 I/O 开始时存储时间戳以记录其持续时间（延迟）。然而，多个 I/O 可能会同时进行。单一的全局时间戳变量无法满足需求：必须将时间戳与每个 I/O 关联。在许多其他 BPF 工具中，这个问题通过将时间戳存储在哈希表中并以线程 ID 作为键来解决。但对于磁盘 I/O，由于磁盘 I/O 可能在一个线程上启动而在另一个线程上完成，因此线程 ID 会发生变化。这里的解决方案是使用这些函数的 `arg0`，即 I/O 的 `struct request` 地址，并将其内存地址作为哈希键。只要内核在 I/O 发起和完成之间不改变该内存地址，它就可以作为唯一的 ID 使用。

#### 跟踪点
BCC 和 bpftrace 版本的 `biolatency(8)` 应尽可能使用块跟踪点，但存在一个挑战：`struct request` 指针目前在跟踪点参数中不可用，因此必须使用其他键来唯一标识 I/O。一种方法是使用设备 ID 和扇区号。程序核心可以改为以下内容（`biolatency-tp.bt`）：

```c
tracepoint:block:block_rq_issue
{
    @start[args->dev, args->sector] = nsecs;
}
tracepoint:block:block_rq_complete
/[@start[args->dev, args->sector]]/
{
    @usecs = hist(nsecs - @start[args->dev, args->sector] / 1000);
    delete(@start[args->dev, args->sector]);
}
```

这假设同一设备和扇区没有并发 I/O。这是测量设备时间，不包括操作系统队列时间。

### 9.3.2 biosnoop
以下是在 Hadoop 生产实例上运行的 BCC 的 `biosnoop(8)` 输出示例：

```bash
biosnoop
TIME (s)  COMM   PID  DISK  T SECTOR  BYTES  LAT (ns)
0.000000  java   5136  xvdq  R  980043184  45056  0.35
0.000060  Java   5136  xvdq  R  980043272  45056  0.40
0.000083  java   5136  xvdiqg R  980043360  4096   0.42
...
0.143724  java   5136  xvdy  R  5153784    45056  1.08
0.143755  Java   5136  xvdy  R  5153872    40960  1.10
0.185374  java   5136  xvdn  R  2007186664 45056  0.34
0.189267  Java   5136  xvay  R  979232832  45056  14.00
0.190330  java   5136  xvdy  R  979232920  45056  15.05
0.190376  Java   5136  xvdy  R  979233008  45056  15.09
0.190403  java   5136  ApAx  R  979233096  45056  15.12
0.190409  ava    5136  Apnx  R  979233184  45056  15.12
0.190441  java   5136  ApAx  R  2007186752 45056  15.15
0.190176  Java   5136  xvdn  R  979233272  36864  5.13
0.190231  java   5136  xvdn  R  2007186840 45056  5.18
...
```

此输出显示了进程 ID 为 5136 的 Java 进行了对不同磁盘的读取。有六个读取操作的延迟约为 15 毫秒。仔细观察 `TIME(s)` 列，可以看到这些 I/O 完成时间都在几分之一毫秒内，并且都是针对同一个磁盘 (`xvdy`)。可以得出结论，这些 I/O 是排队在一起执行的：延迟从 14.00 毫秒逐渐增加到 15.15 毫秒，这也是按顺序完成排队 I/O 的线索。扇区偏移也是连续的：45056 字节的读取是 88 个 512 字节的扇区。

#### 示例生产使用
Netflix 的团队经常使用 `biosnoop(8)` 来隔离因预读导致 I/O 密集型工作负载性能下降的问题。Linux 试图智能地将数据预读入操作系统页面缓存，但这可能会导致运行在快速固态驱动器上的数据存储出现严重的性能问题，尤其是在默认预读设置下。在识别出激进的预读后，这些团队会使用适当的 `madvise` 选项、直接 I/O 或将默认预读值更改为较小的值（如 16 KB）来提高性能。有关 I/O 大小的直方图，请参见第 S 章的 `vfssize(8)` 和本章的 `bitesize(8)`；此外，还请参见第 8 章的 `readahead(8)` 工具，该工具是最近创建的，用于分析此问题。

`biosnoop(8)` 的列说明：
- **TIME(s)**: I/O 完成时间（秒）
- **COMM**: 进程名称（如果已缓存）
- **PID**: 进程 ID（如果已缓存）
- **DISK**: 存储设备名称
- **T**: 类型：R 表示读取，W 表示写入
- **SECTOR**: 磁盘上的地址（以 512 字节扇区为单位）
- **BYTES**: I/O 大小
- **LAT(ms)**: 从设备发出到设备完成的 I/O 持续时间

此工具的工作原理与 `biolatency(8)` 相同：跟踪内核块 I/O 函数。未来的版本应切换到块跟踪点。此工具的开销略高于 `biolatency`。

#### 操作系统队列时间
BCC 的 `biosnoop(8)` 中的 `-Q` 选项可用于显示从 I/O 创建到设备发出之间的时间，这段时间主要花费在操作系统队列上，但也可能包括内存分配和锁获取。例如：
```bash
biosnoop -Q
TIME (s)  COMM   PID  DISK  T SECTOR  BYTES  QUE (ns)  LAT (ns)
19.925329 cksun  20405 sdb   R  249631  16384  17.17     1.63
19.933890 cksun  20405 sdb   R  249663  122880 17.81     8.51
19.942442 cksun  20405 sdb   R  249903  122880 26.35     8.51
19.944161 cksun  20405 sdb   R  250143  16384  17.17     1.63
```

希望这些改进使文本更加清晰、连贯和专业。