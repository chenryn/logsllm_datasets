传统的关系资料库不限制事务的持续时间，因为它们是为等待人类输入的互动式应用而设计的。因此，当一个事务需要等待另一个事务时，等待的时长并没有限制。即使你保证所有的事务都很短，如果有多个事务想要访问同一个物件，那么可能会形成一个伫列，所以事务可能需要等待几个其他事务才能完成。
因此，执行 2PL 的资料库可能具有相当不稳定的延迟，如果在工作负载中存在争用，那么可能高百分位点处的响应会非常的慢（请参阅 “[描述效能](ch1.md#描述效能)”）。可能只需要一个缓慢的事务，或者一个访问大量资料并获取许多锁的事务，就能把系统的其他部分拖慢，甚至迫使系统停机。当需要稳健的操作时，这种不稳定性是有问题的。
基于锁实现的读已提交隔离级别可能发生死锁，但在基于 2PL 实现的可序列化隔离级别中，它们会出现的频繁的多（取决于事务的访问模式）。这可能是一个额外的效能问题：当事务由于死锁而被中止并被重试时，它需要从头重做它的工作。如果死锁很频繁，这可能意味著巨大的浪费。
#### 谓词锁
在前面关于锁的描述中，我们掩盖了一个微妙而重要的细节。在 “[导致写入偏差的幻读](#导致写入偏差的幻读)” 中，我们讨论了 **幻读（phantoms）** 的问题。即一个事务改变另一个事务的搜寻查询的结果。具有可序列化隔离级别的资料库必须防止 **幻读**。
在会议室预订的例子中，这意味著如果一个事务在某个时间视窗内搜寻了一个房间的现有预订（见 [例 7-2]()），则另一个事务不能同时插入或更新同一时间视窗与同一房间的另一个预订 （可以同时插入其他房间的预订，或在不影响另一个预定的条件下预定同一房间的其他时间段）。
如何实现这一点？从概念上讲，我们需要一个 **谓词锁（predicate lock）**【3】。它类似于前面描述的共享 / 排它锁，但不属于特定的物件（例如，表中的一行），它属于所有符合某些搜寻条件的物件，如：
```sql
SELECT * FROM bookings
WHERE room_id = 123 AND
      end_time > '2018-01-01 12:00' AND
      start_time < '2018-01-01 13:00';
```
谓词锁限制访问，如下所示：
- 如果事务 A 想要读取匹配某些条件的物件，就像在这个 `SELECT` 查询中那样，它必须获取查询条件上的 **共享谓词锁（shared-mode predicate lock）**。如果另一个事务 B 持有任何满足这一查询条件物件的排它锁，那么 A 必须等到 B 释放它的锁之后才允许进行查询。
- 如果事务 A 想要插入，更新或删除任何物件，则必须首先检查旧值或新值是否与任何现有的谓词锁匹配。如果事务 B 持有匹配的谓词锁，那么 A 必须等到 B 已经提交或中止后才能继续。
这里的关键思想是，谓词锁甚至适用于资料库中尚不存在，但将来可能会新增的物件（幻象）。如果两阶段锁定包含谓词锁，则资料库将阻止所有形式的写入偏差和其他竞争条件，因此其隔离实现了可序列化。
#### 索引范围锁
不幸的是谓词锁效能不佳：**如果活跃事务持有很多锁，检查匹配的锁会非常耗时。** 因此，大多数使用 2PL 的资料库实际上实现了索引范围锁（index-range locking，也称为 **next-key locking**），这是一个简化的近似版谓词锁【41,50】。
透过使谓词匹配到一个更大的集合来简化谓词锁是安全的。例如，如果你有在中午和下午 1 点之间预订 123 号房间的谓词锁，则锁定 123 号房间的所有时间段，或者锁定 12:00~13:00 时间段的所有房间（不只是 123 号房间）是一个安全的近似，因为任何满足原始谓词的写入也一定会满足这种更松散的近似。
在房间预订资料库中，你可能会在 `room_id` 列上有一个索引，并且 / 或者在 `start_time` 和 `end_time` 上有索引（否则前面的查询在大型资料库上的速度会非常慢）：
- 假设你的索引位于 `room_id` 上，并且资料库使用此索引查询 123 号房间的现有预订。现在资料库可以简单地将共享锁附加到这个索引项上，指示事务已搜寻 123 号房间用于预订。
- 或者，如果资料库使用基于时间的索引来查询现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将 12:00~13:00 时间段标记为用于预定。
无论哪种方式，搜寻条件的近似值都附加到其中一个索引上。现在，如果另一个事务想要插入、更新或删除同一个房间和 / 或重叠时间段的预订，则它将不得不更新索引的相同部分。在这样做的过程中，它会遇到共享锁，它将被迫等到锁被释放。
这种方法能够有效防止幻读和写入偏差。索引范围锁并不像谓词锁那样精确（它们可能会锁定更大范围的物件，而不是维持可序列化所必需的范围），但是由于它们的开销较低，所以是一个很好的折衷。
如果没有可以挂载范围锁的索引，资料库可以退化到使用整个表上的共享锁。这对效能不利，因为它会阻止所有其他事务写入表格，但这是一个安全的回退位置。
### 可序列化快照隔离
本章描绘了资料库中并发控制的黯淡画面。一方面，我们实现了效能不好（2PL）或者伸缩性不好（序列执行）的可序列化隔离级别。另一方面，我们有效能良好的弱隔离级别，但容易出现各种竞争条件（丢失更新、写入偏差、幻读等）。序列化的隔离级别和高效能是从根本上相互矛盾的吗？
也许不是：一个称为 **可序列化快照隔离（SSI, serializable snapshot isolation）** 的演算法是非常有前途的。它提供了完整的可序列化隔离级别，但与快照隔离相比只有很小的效能损失。SSI 是相当新的：它在 2008 年首次被描述【40】，并且是 Michael Cahill 的博士论文【51】的主题。
今天，SSI 既用于单节点资料库（PostgreSQL9.1 以后的可序列化隔离级别），也用于分散式资料库（FoundationDB 使用类似的演算法）。由于 SSI 与其他并发控制机制相比还很年轻，还处于在实践中证明自己表现的阶段。但它有可能因为足够快而在未来成为新的预设选项。
#### 悲观与乐观的并发控制
两阶段锁是一种所谓的 **悲观并发控制机制（pessimistic）** ：它是基于这样的原则：如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。这就像互斥，用于保护多执行绪程式设计中的资料结构。
从某种意义上说，序列执行可以称为悲观到了极致：在事务持续期间，每个事务对整个资料库（或资料库的一个分割槽）具有排它锁，作为对悲观的补偿，我们让每笔事务执行得非常快，所以只需要短时间持有 “锁”。
相比之下，**序列化快照隔离** 是一种 **乐观（optimistic）** 的并发控制技术。在这种情况下，乐观意味著，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，资料库检查是否有什么不好的事情发生（即隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。只有可序列化的事务才被允许提交。
乐观并发控制是一个古老的想法【52】，其优点和缺点已经争论了很长时间【53】。如果存在很多 **争用**（contention，即很多事务试图访问相同的物件），则表现不佳，因为这会导致很大一部分事务需要中止。如果系统已经接近最大吞吐量，来自重试事务的额外负载可能会使效能变差。
但是，如果有足够的空闲容量，并且事务之间的争用不是太高，乐观的并发控制技术往往比悲观的效能要好。可交换的原子操作可以减少争用：例如，如果多个事务同时要增加一个计数器，那么应用增量的顺序（只要计数器不在同一个事务中读取）就无关紧要了，所以并发增量可以全部应用且不会有冲突。
顾名思义，SSI 基于快照隔离 —— 也就是说，事务中的所有读取都是来自资料库的一致性快照（请参阅 “[快照隔离和可重复读取](#快照隔离和可重复读)”）。与早期的乐观并发控制技术相比这是主要的区别。在快照隔离的基础上，SSI 添加了一种演算法来检测写入之间的序列化冲突，并确定要中止哪些事务。
#### 基于过时前提的决策
先前讨论了快照隔离中的写入偏差（请参阅 “[写入偏差与幻读](#写入偏差与幻读)”）时，我们观察到一个回圈模式：事务从资料库读取一些资料，检查查询的结果，并根据它看到的结果决定采取一些操作（写入资料库）。但是，在快照隔离的情况下，原始查询的结果在事务提交时可能不再是最新的，因为资料可能在同一时间被修改。
换句话说，事务基于一个 **前提（premise）** 采取行动（事务开始时候的事实，例如：“目前有两名医生正在值班”）。之后当事务要提交时，原始资料可能已经改变 —— 前提可能不再成立。
当应用程式进行查询时（例如，“当前有多少医生正在值班？”），资料库不知道应用逻辑如何使用该查询结果。在这种情况下为了安全，资料库需要假设任何对该结果集的变更都可能会使该事务中的写入变得无效。换而言之，事务中的查询与写入可能存在因果依赖。为了提供可序列化的隔离级别，如果事务在过时的前提下执行操作，资料库必须能检测到这种情况，并中止事务。
资料库如何知道查询结果是否可能已经改变？有两种情况需要考虑：