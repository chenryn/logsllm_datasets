Rooting macOS Big Sur on Apple Silicon
Xinru Chi and Tielei Wang
About us
• Xinru Chi
• Security Researcher in Pangu Lab 
• Extensive experience in macOS/iOS vulnerability research
• Tielei Wang 
• Ph.D from PKU, Research scientist at Georgia Tech from 2011-2014
• Known for releasing jailbreak tools for iOS 7-9
• Organizers of MOSEC (Mobile Security Conference)
The story begins with security contents of iOS 14.2
iOS 14.2, released on Nov 5, 
2020, ﬁxed an in-the-wild exploit 
reported by GP0.
First in-the-wild exploit since iOS 14 (?)
Safari RCE (CVE-2020-27930)
kernel info leak (CVE-2020-27950)
kernel type confusion (CVE-2020-27932)
Let’s diff the kernel
• Apple still maintains iOS 12 for old devices
• Updates for iOS 12.4.9 only have 4 CVEs
• Updates for iOS 14.2 have *26* CVEs
• Of course, difﬁng 12.4.9 vs 12.4.8 is better
Kernel info leak jumps into eyes
Kernel info leak jumps into eyes
• Adds “bzero mach msg trailer” at multiple functions
• Apparently,  it leaks uninitialized kernel memory from mach msg trailers
• Refer to the following links for more analysis
https://www.synacktiv.com/publications/ios-1-day-hunting-uncovering-and-exploiting-cve-2020-27950-kernel-memory-leak.html
https://bugs.chromium.org/p/project-zero/issues/detail?id=2108
Type confusion seems easy too
• host_request_notiﬁcation function adds an extra check on port’s type 
Type confusion seems easy too
• host_request_notiﬁcation function adds an extra check on port’s type 
Take a quick look at port struct
Let’s construct a PoC
• Plan 1: make a special reply port and pass it to host_request_notiﬁcation, it 
may trigger the type confusion
Let’s construct a PoC
• Plan 1: make a special reply port and pass it to host_request_notiﬁcation, it 
may trigger the type confusion
Let’s construct a PoC
• Plan 1: make a special reply port and pass it to host_request_notiﬁcation, it 
may trigger the type confusion
• Unfortunately, no panic. 
• Maybe we should trigger the notiﬁcation or deallocate the port?
Let’s construct a PoC
• Maybe we should trigger the notiﬁcation or deallocate the port?
• Unfortunately, still no panic. 
Let’s construct a PoC
Things get complicated
• We need to understand how a special reply port is different from regular ports
• After reading the XNU source code, we realized that it is very complicated
• A special reply port could be linked to a port, a work loop via a knote, a 
work loop via a knote stash, etc.
• Don’t try to understand these terms, because neither can I :)
Construct 
PoC
Understand 
special 
reply ports
Things get complicated
• In order to understand how a special reply port is different from regular 
ports,  we need to know how a special reply port is used
Construct 
PoC
Understand 
special 
reply ports
Know how 
to use 
special 
reply ports
Luck hasn't run out yet 
• Found a pretty interesting test case in the XNU source code package
• xnu/tests/prioritize_process_launch_helper.c
Construct 
PoC
Understand 
special 
reply ports
Know how 
to use 
special 
reply ports
XNU has a 
test case!!!
A customized send
• Send a mach port msg_port via a complex 
mach message to send_port with reply port 
reply_port
• A few things to note
• msg_port is sent with 
MACH_MSG_TYPE_MOVE_RECEIVE
• mach_msg uses the option  
MACH_SEND_SYNC_OVERRIDE
Let’s construct a PoC again
• Plan 2: make a special reply port, use it in the customized send function, 
pass it to host_request_notiﬁcation, and then deallocate the port
• Yes, this poc triggered a panic!
Let’s construct a PoC again
• Plan 2: make a special reply port, use it in the customized send function, 
pass it to host_request_notiﬁcation, and then deallocate the port
• Please refer to the following links for more analysis and PoC examples
https://bugs.chromium.org/p/project-zero/issues/detail?id=2107
https://worthdoingbadly.com/specialreply/
However things get even more complicated 
• When analyzing the panic, we found more panics, regardless of 
host_request_notiﬁcation
The magical send
dst_port is a regular port that we have “send” and “recv” rights
send a null port to 
dst_port, use 
special_reply_port as 
reply port
send the 
special_reply_port to 
dst_port, no reply port
The magical send
type confusion between turnstile and ipc_kmsg? 
send special_reply_port to 
itself, use itself as reply port
The magical send
send a null port to 
dst_port, use 
special_reply_port as 
reply port
send special_reply_port to 
itself, use itself as reply port
The magical send
No panic!
send a null port to 
dst_port, use 
special_reply_port as 
reply port
send special_reply_port to 
itself, use itself as reply port
The magical send
send special_reply_port to 
itself, use itself as reply port
send a null port to 
dst_port, use 
special_reply_port as 
reply port
receive from dst_port
dst_port became inactive!
Do so many different panics have the 
same root cause?
Root cause analysis
ipc_kmsg_copyin_header
ipc_kmsg_copyin
mach_msg_overwrite_trap
ipc_kmsg_set_qos
Using a special_reply_port as the reply port and 
MACH_SEND_SYNC_OVERRIDE in the mach_msg option will lead to
ipc_port_link_special_reply_port 
Root cause analysis
ipc_port_link_special_reply_port
ipc_kmsg_copyin_header
ipc_kmsg_copyin
mach_msg_overwrite_trap
ipc_kmsg_set_qos
ipc_port_link_special_reply_port
Review the port struct
io_bits indicates the type of a port
io_references is the reference counter of the port
kdata is a union struct
Root cause analysis
ipc_port_link_special_reply_port
kdata.sync_inheritor_port
…
special_reply_port 
io_references
dst_port 
io_bits
io_references
io_bits
Root cause analysis
The second send is very complicated, but there are 
three key steps
Root cause analysis
1.
msg_port is sent with MACH_MSG_TYPE_MOVE_RECEIVE
ipc_kmsg_copyin_body
ipc_kmsg_copyin
mach_msg_overwrite_trap
ipc_kmsg_copyin_port_descriptor
ipc_object_copyin
ipc_right_copyin
special_reply_port’s ip_tempowner is set 1
Hold on, there is an assert!
port->ip_imp_task and port->sync_inheritor_port are the same thing, pointing to dst_port
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
io_bits
io_references
io_bits
ip_tempowner=1
assert is optimized out in release versions!
port->ip_imp_task and port->sync_inheritor_port are the same thing, pointing to dst_port
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
io_bits
io_references
io_bits
ip_tempowner=1
Root cause analysis
2.
sending a port to itself will trigger a circularity check 
the kmsg is set with MACH_MSGH_BITS_CIRCULAR 
ipc_kmsg_copyin_body
ipc_kmsg_copyin
mach_msg_overwrite_trap
ipc_kmsg_copyin_port_descriptor
ipc_port_check_circularity
Root cause analysis
2.
sending a port to itself will trigger a circularity check 
ipc_kmsg_destroy
ipc_kmsg_send
mach_msg_overwrite_trap
the kmsg gets destroyed due to the circularity check
Root cause analysis
3.
destroying the kmsg leads to msg_port destruction
ipc_kmsg_clean_body
ipc_kmsg_clean
ipc_kmsg_destroy
ipc_object_destroy
ipc_port_release_receive
ipc_port_destroy
ipc_port_destroy
• How to destroy the special_reply_port? There is a simpliﬁed version!
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
io_bits
io_references
io_bits
ip_tempowner=1
What happened?
• How to destroy the special_reply_port? There is a simpliﬁed version!
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
io_bits
io_references
io_bits
ip_tempowner=1
ipc_importance_task_release(dst_port)!
ipc_importance_task_release
A type confusion between ipc_port and ipc_importance_task_t!
Consequence of the type confusion
• ipc_importance_task_release leads to iie_bits decrement
io_references
dst_port 
io_bits
iie_made
ipc_importance_task_t 
iie_bits
ipc_importance_task_release(dst_port) leads to decrement of 
dst_port’s io_bits
How the panic happened
IO_BITS_ACTIVE          0x80000000      /* is object alive? */
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
0x80000000
io_references
io_bits
ip_tempowner=0
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
0x80000000
io_references
io_bits
ip_tempowner=1
How the panic happened
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
0x7fffffff
io_references
io_bits
ip_tempowner=1
How the panic happened
destroyed by 
ipc_port_destroy
io_bits decrement due 
to the type confusion
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
0x7fffffff
io_references
io_bits
ip_tempowner=1
How the panic happened
trigger the inactive port panic
io_bits decrement due 
to the type confusion
A short wrap-up
this piece of code will decrease dst_port’s io_bits by 1
Review port’s io_bits 
Review port’s io_bits 
0x80000000
e.g., a regular port’s io_bits
IO_BITS_ACTIVE
Review port’s io_bits 
0x8000081d
e.g., a userclient port’s io_bits
IO_BITS_ACTIVE
IO_BITS_KOBJECT
IKOT_IOKIT_CONNECT
Review port’s io_bits 
0x80000825
e.g., a voucher port’s io_bits
IO_BITS_ACTIVE
IO_BITS_KOBJECT
IKOT_VOUCHER
We can change a port’s type now!
this piece of code will decrease dst_port’s io_bits from from to to.
Q1: what’s the consequence of changing port’s type? 
• It will lead to kobject type confusions and forms a giant attack surface
• From higher types to lower types
• For example, we can change a voucher port to a userclient port, and use it 
as a userclient port
Q2: Does PAC prevent the kobject type confusions?
• Yes or no.
• First, kobject is pac’ed
Q2: Does PAC prevent the kobject type confusions?
• XNU_PTRAUTH_SIGNED_PTR 
generates the pac code using where the 
pointer is stored and pointer’s 
discriminator (ipc_port.kobject)
• As a result, changing port’s io_bits does 
not affect kobject’s pac computation!
Q2: Does PAC prevent the kobject type confusions?
• However, kobject, according to its speciﬁc type, may contain other pac’ed ﬁelds. 
• e.g., vtable pointer in userclient objects
panic due to vtable call “obj-retain()” 
Q2: Does PAC prevent the kobject type confusions?
• PAC does not directly prevent kobject type confusions, but limits the scope 
of the confusions.
Q3: is this issue exploitable?
• Yes,  our talk is entitled “Rooting macOS Big Sur on Apple Silicon”
Exploit type confusion on Big Sur with Apple Silicon
• Big Sur on Apple Silicon = macOS features + iOS like protections
Chose some privileged ports as target
• Some special, privileged ports are only available for root, but now we have 
a chance to forge them through the type confusions
Our choice: change a vm_named_entry to host_security
• Both have a lock struct at the beginning 
Beneﬁt from host_security_t
• We are able to change task tokens through host_security_set_task_token!
host_security_set_task_token
• host_security_set_task_token resets a 
task’s sec_token and audit_token
What is a task token used for?
• Do you still remember the info leak via mach message trailer at the very 
beginning?
• sec_token and audit_token are used to support mach msg audit, containing 
critical information such as pid/uid/gid 
We can forge any sec_token and audit_token
• Sending no-more-sender notiﬁcation?
• Hijacking XPC communications? 
• Breaking the sandbox?
Old-school style
• kuncd is a user space service that is supposed to only handle mach 
message from the kernel to execute user-space tools 
• kuncd checks the audit_token in the mach message trailer so that it only 
handles mach messages from the kernel
Let kuncd start a terminal as root
demo
• Reset our task’s token with kernel audit token, and send a mach message 
to kuncd to launch terminal as root
demo
The whole picture
analysis the patch in 
host_request_notiﬁcation
type confusion between 
ipc_port and 
ipc_importance_task_t
 semi-arbitrary port type 
confusion
type confusion between 
vm_named_entry and 
host_security_port
forge arbitrary audit 
token
kuncd launch terminal
The whole picture
Not covered in the talk
analysis the patch in 
host_request_notiﬁcation
type confusion between 
ipc_port and 
ipc_importance_task_t
 semi-arbitrary port type 
confusion
type confusion between 
vm_named_entry and 
host_security_port
forge arbitrary audit 
token
kuncd launch terminal
other confusions such as 
turnstile and ipc_kmsg 
other kobject type 
confusions
other abuses of
 the audit_token
analysis the patch in 
host_request_notiﬁcation
type confusion between 
ipc_port and 
ipc_importance_task_t
 semi-arbitrary port type 
confusion
type confusion between 
vm_named_entry and 
host_security_port
forge arbitrary audit 
token
kuncd launch terminal
other confusions such as 
turnstile and ipc_kmsg 
other kobject type 
confusions
other abuses of
 the audit_token
The ﬁx
The ﬁx
• Apple added more checks on special reply ports in macOS 11.2
cannot send a special reply port with 
MACH_MSG_TYPE_MOVE_RECEIVE
Conclusion
• Variant analysis brings surprises
• Port type confusion forms a giant attack surface
• Data type confusion survives from PAC, even MTE
Thank you!