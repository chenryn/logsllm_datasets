for DHE cipher suites (as well as for ECDHE ones). So
broadly speaking, Raccoon does not apply to TLS 1.3. Note
that our attack could work on a variant of TLS 1.3, which
explicitly allows key reuse (or even encourages it), called ETS
or eTLS [59]. If ephemeral keys get reused in either variant,
they could lead to micro-architectural side channels.
DTLS. The DTLS KDF [54] is analogous to that of TLS, and
has the same properties with regards to timing. However, an
attacker may not be able to measure the timing difference,
as DTLS does not necessarily send an error message when
sessions are ungracefully terminated: DTLS is UDP-based,
so it does not send TCP FIN or RST packets, and some im-
plementations do not send alert messages at all. An attacker
may be able to overcome these difﬁculties using techniques
similar to [7], but we consider this out of scope for this work.
SSH. In SSH, ephemeral key reuse is far less common than
in TLS (as shown by [64] in 2017). This is probably due to
the more homogeneous deployment of SSH, and the raised
security requirements, as a break in SSH could lead to remote
code execution.
In SSH, the shared secret is encoded as
an mpint, which explicitly removes leading zero bytes. In
contrast to TLS, the shared secret is hashed with the session
transcript to generate the ‘exchange hash’. This essentially
removes the attack prerequisite for a dangerous modulus size.
The attacker can guarantee that the difference of a stripped
zero byte always results in less processed blocks within the
hash function, since attacker-controlled messages with non-
ﬁxed length are included in the computation. To summarize,
USENIX Association
30th USENIX Security Symposium    225
SSH servers which reuse ephemeral DH values are at greater
risk to the attack than TLS servers which do so, but such SSH
servers are rare.
Interestingly, SSH also strips the leading zero bytes of the
shared secret for X25519. RFC 8731 [1] explicitly mentions
that this is a potential problem, as it leaks the leading zero
byte of the shared secret, but decided not to address the issue
for backwards compatibility reasons.
Other protocols. XML Encryption [30] and IPsec [39, Sec-
tion 2.14] preserve leading zero bytes. JSON Web Encryp-
tion [38] only offers ECDH key agreement. The estab-
lished shared secret is processed according to NIST SP 800-
56A [52], which requires leading zero bytes to be preserved.
9 Related Work
Timing side channels caused by hash functions. In 2013,
AlFardan and Paterson showed that tiny timing differences
by processing inputs of different lengths can be used for
the Lucky 13 attack [6]. Albrecht et al. showed that years
later, the same vulnerability was still affecting real-world
implementations and common (but not recommended) miti-
gation techniques are ineffective [5]. Some developers have
changed the interface of HMAC functions to mitigate ﬂaws
like Lucky 13 [53]. These interfaces now also take the max-
imum amount of data that could have been passed to the
HMAC function as an input.
Bleichenbacher’s Attack. Daniel Bleichenbacher was the
ﬁrst to describe a real-world attack on TLS recovering the
premaster secret [15]. His attack relied on a direct oracle
where the server revealed if the decrypted RSA plaintext was
PKCS#1 compliant or not. The primary condition for this
compliance is for the two most signiﬁcant bytes of the plain-
text to take a speciﬁc value, making the attack somewhat
similar to Raccoon. Furthermore, Bleichenbacher’s attack
relies on an attacker choosing a multiplier s and querying
whether m· s starts with these speciﬁc MSBs, where m is the
plaintext the attacker wishes to decrypt. One could therefore
think that Raccoon could be mounted using the same attack
algorithm. However, in Raccoon the attacker cannot choose
the multiplier. Rather, the attacker can only compute grb
for a known r, and query whether grb · gab is compliant; the
ﬁrst multiplier essentially acts as a pseudorandom function
from the attacker’s point of view. Recent work by Ronen et
al. [56] does use lattices and the HNP to perform the attack
in parallel, but most variants of Bleichenbacher’s attack use
ad-hoc algorithms where the attacker carefully chooses values
for s. To conclude, while Raccoon shares some similarities to
Bleichenbacher’s attack, and both can be mounted using HNP
solvers, the latter is often mounted using simpler algorithms.
While the TLS speciﬁcation has described the attack coun-
termeasures already in version 1.0 [26], several works later
showed that this attack was still applicable in different vari-
ants. Klíma et al. discovered a second-level oracle which re-
vealed the same information, but on checking a different value,
namely the TLS version number embedded in the PMS [40].
ROBOT showed that years later, many modern TLS servers
are still vulnerable to variants of the attack [16].
Attacks on export-grade crypto. Another line of attacks ex-
ploited the usage of export-grade cryptography and obsolete
protocols to break TLS. DROWN recovered premaster secrets
from secure TLS-RSA connections by exploiting public-key
reuse and instances of the (deprecated) SSLv2 protocol [10];
DROWN is also an instance of Bleichenbacher’s attack. Log-
jam [2] and FREAK [13] targeted 512-bit key sizes used in
DHE-EXPORT and RSA-EXPORT cipher suites to recover
the PMS based on weak export keys. Raccoon attack does not
rely on the presence of outdated cryptographic mechanisms.
Timing attacks against the TLS handshake. Brumley and
Boneh measured the timing differences in TLS-RSA decryp-
tion on different ciphertexts [20]. From these timing differ-
ences, they were able to compute the private key of the server.
Meyer et al. constructed a Bleichenbacher oracle from timing
differences in the handling of valid and invalid PKCS#1 mes-
sages, which they used to compute the PMS of a previously
recorded TLS-RSA session [46].
Attacks using HNP solvers. The HNP has been applied in
many attacks against DSA, ECDSA with partially known
nonces and signatures in zero-knowledge proofs, using a
variety of side channels [11, 23, 34, 50, 51]. Breitner and
Heninger used a lattice-based HNP solver to compute private
ECDSA signing keys generated by cryptocurrency code [18].
Some previous attacks on the TLS protocols also have
made use of lattice techniques and HNP solvers. Brumley
and Tuveri exploited a timing side channel in the ECDSA
signature generation during the TLS handshake [19].
Attacks against TLS Difﬁe-Hellman. In addition to the
above-mentioned Logjam attack [2], there exist several stud-
ies on the security of TLS Difﬁe-Hellman. Valenta et al.
analyzed the impact of small-subgroup attacks [64]. Dorey et
al. analyzed how plausibly deniable backdoored parameters
could be generated [29]. Additionally, they performed a study
to analyze the prevalence of such parameters.
Proofs on TLS-DH(E). TLS-DHE and TLS-DH have been
proven secure under the PRF-ODH assumption by [36] and
[42], respectively. As this work has shown, this assumption
is not met by current real-world TLS implementations.
10 Conclusions
Beyond the speciﬁcs of the attack, we argue that its existence
can also teach us broader lessons for cryptographic protocols.
Forgoing forward secrecy is dangerous. Forward secrecy
is a well-known security goal for cryptographic protocols and
was intensively analyzed in the context of TLS in [61]. Our
attack exploits the fact that servers may reuse the secret DH
226    30th USENIX Security Symposium
USENIX Association
exponent for many sessions, thus forgoing forward secrecy.
In this context, Raccoon teaches a lesson for protocol secu-
rity: For protocols where some cryptographic secrets can be
continuously queried by one of the parties, the attack surface
is made broader. The Raccoon attack shows that we should
be careful when giving attackers access to such queries.
Secrets should be constant-size. The dangers of non-
constant-time implementations are well-known. For example,
they have been repeatedly demonstrated to break ECDSA as
used in TLS. One of the reasons for these breaks is that the
processing of variable-length secret values within the imple-
mentation usually results in non-constant execution time. We
argue that future protocol designs should make sure that all
their secrets (including intermediate values and their internal
number representation) are of ﬁxed size.
Countermeasures. The most straightforward mitigation
against the attack is to remove support for TLS-DH(E) en-
tirely, as most major client implementations have already
stopped supporting them. Moreover, server operators should
disable DHE key reuse, which completely prevents the practi-
cal attack even if support for DHE cipher suites is prioritized.
Updating the TLS speciﬁcation to preserve leading zero
bytes is impractical. In fact, experience shows that even de-
ployment of new protocol features conforming to the existing
speciﬁcation is hard. This is because many implementations
in the wild only implement a subset of the speciﬁcation, often
in a buggy way; see [12]. Since TLS 1.3 is not vulnerable
to the attack by design, we propose to focus on the TLS 1.3
deployment rather than trying to update the old speciﬁcation.
To prevent timing-based side channels in legacy applica-
tions with length-varying secrets, vendors must ensure that
functions are implemented in constant time. This can be done
as in the Lucky 13 mitigation or by computing the values
for different fake parameters and discarding the fake ones
afterwards. However, one has to be very careful when imple-
menting such mitigations; previous research has shown that
this kind of mitigations adds code complexity and may still
leave the side channel open [5] or introduce even more severe
vulnerabilities [60].
Acknowledgements. Robert Merget and Marcus Brinkmann
were supported by the German Federal Ministry of Eco-
nomics and Technology (BMWi) project “Industrie 4.0 Recht-
Testbed” (13I40V002C). Nimrod Aviram was supported by a
scholarship from The Israeli Ministry of Science and Tech-
nology and a scholarship from The Check Point Institute for
Information Security. In addition, this work was supported
by the Deutsche Forschungsgemeinschaft (DFG, German Re-
search Foundation) under Germany’s Excellence Strategy -
EXC 2092 CASA - 390781972. We thank our anonymous ref-
erees and our shepherd, Zakir Durumeric, for their comments
and for improving the ﬁnal version of the paper.
References
[1] A. Adamantiadis, S. Josefsson, and M. Baushke. Secure
Shell (SSH) Key Exchange Method Using Curve25519 and
Curve448. RFC 8731 (Proposed Standard), February 2020.
[2] David Adrian, Karthikeyan Bhargavan, Zakir Durumeric,
Pierrick Gaudry, Matthew Green, J. Alex Halderman, Na-
dia Heninger, Drew Springall, Emmanuel Thomé, Luke Va-
lenta, Benjamin VanderSloot, Eric Wustrow, Santiago Zanella-
Béguelin, and Paul Zimmermann. Imperfect forward secrecy:
How Difﬁe-Hellman fails in practice. In Indrajit Ray, Ninghui
Li, and Christopher Kruegel, editors, ACM CCS 2015: 22nd
Conference on Computer and Communications Security, pages
5–17, Denver, CO, USA, October 12–16, 2015. ACM Press.
[3] Adi Akavia. Solving hidden number problem with one bit
oracle and advice. In Shai Halevi, editor, Advances in Cryp-
tology – CRYPTO 2009, volume 5677 of Lecture Notes in
Computer Science, pages 337–354, Santa Barbara, CA, USA,
August 16–20, 2009. Springer, Heidelberg, Germany.
[4] Martin R. Albrecht and Kenneth G. Paterson. Lucky microsec-
onds: A timing attack on amazon’s s2n implementation of TLS.
In Marc Fischlin and Jean-Sébastien Coron, editors, Advances
in Cryptology – EUROCRYPT 2016, Part I, volume 9665 of
Lecture Notes in Computer Science, pages 622–643, Vienna,
Austria, May 8–12, 2016. Springer, Heidelberg, Germany.
[5] Martin R. Albrecht and Kenneth G. Paterson. Lucky microsec-
onds: A timing attack on Amazon’s s2n implementation of
TLS. In Advances in Cryptology - EUROCRYPT 2016 - 35th
Annual International Conference on the Theory and Applica-
tions of Cryptographic Techniques, Vienna, Austria, May 8-12,
2016, Proceedings, Part I, pages 622–643, 2016.
[6] Nadhem J. AlFardan and Kenneth G. Paterson. Lucky thirteen:
Breaking the TLS and DTLS record protocols. In 2013 IEEE
Symposium on Security and Privacy, pages 526–540, Berkeley,
CA, USA, May 19–22, 2013. IEEE Computer Society Press.
[7] N.J. AlFardan and K.G. Paterson. Plaintext-Recovery Attacks
Against Datagram TLS. In Network and Distributed System
Security Symposium (NDSS 2012), February 2012.
[8] Gorka Irazoqui Apecechea, Mehmet Sinan Inci, Thomas Eisen-
barth, and Berk Sunar. Lucky 13 strikes back. In Feng Bao,
Steven Miller, Jianying Zhou, and Gail-Joon Ahn, editors,
ASIACCS 15: 10th ACM Symposium on Information, Com-
puter and Communications Security, pages 85–96, Singapore,
April 14–17, 2015. ACM Press.
[9] Diego F. Aranha, Pierre-Alain Fouque, Benoît Gérard, Jean-
Gabriel Kammerer, Mehdi Tibouchi, and Jean-Christophe Za-
palowicz. GLV/GLS decomposition, power analysis, and
attacks on ECDSA signatures with single-bit nonce bias. In
Lecture Notes in Computer Science, pages 262–281. Springer
Berlin Heidelberg, 2014.
[10] Nimrod Aviram, Sebastian Schinzel, Juraj Somorovsky, Nadia
Heninger, Maik Dankel, Jens Steube, Luke Valenta, David
Adrian, J. Alex Halderman, Viktor Dukhovni, Emilia Käsper,
Shaanan Cohney, Susanne Engels, Christof Paar, and Yuval
Shavitt. DROWN: Breaking TLS using SSLv2. In Thorsten
Holz and Stefan Savage, editors, USENIX Security 2016: 25th
USENIX Association
30th USENIX Security Symposium    227
USENIX Security Symposium, pages 689–706, Austin, TX,
USA, August 10–12, 2016. USENIX Association.
[11] Naomi Benger, Joop van de Pol, Nigel P. Smart, and Yuval
Yarom. “ooh aah... just a little bit” : A small amount of side
channel can go a long way. In Advanced Information Systems
Engineering, pages 75–92. Springer Berlin Heidelberg, 2014.
[12] David Benjamin. TLS ecosystem woes, 2018.
[13] Benjamin Beurdouche, Karthikeyan Bhargavan, Antoine
Delignat-Lavaud, Cédric Fournet, Markulf Kohlweiss, Alfredo
Pironti, Pierre-Yves Strub, and Jean Karim Zinzindohoue. A
messy state of the union: taming the composite state machines
In IEEE Symposium on Security & Privacy 2015
of TLS.
(Oakland’15). IEEE, 2015.
[14] Karthikeyan Bhargavan, Cédric Fournet, Markulf Kohlweiss,
Alfredo Pironti, Pierre-Yves Strub, and Santiago Zanella
Béguelin. Proving the TLS handshake secure (as it is).
In
Juan A. Garay and Rosario Gennaro, editors, Advances in
Cryptology – CRYPTO 2014, Part II, volume 8617 of Lecture
Notes in Computer Science, pages 235–255, Santa Barbara,
CA, USA, August 17–21, 2014. Springer, Heidelberg, Ger-
many.
[15] Daniel Bleichenbacher. Chosen ciphertext attacks against
protocols based on the RSA encryption standard PKCS
In Hugo Krawczyk, editor, Advances in Cryptology –
#1.
CRYPTO’98, volume 1462 of Lecture Notes in Computer Sci-
ence, pages 1–12, Santa Barbara, CA, USA, August 23–27,
1998. Springer, Heidelberg, Germany.
[16] Hanno Böck, Juraj Somorovsky, and Craig Young. Return
of bleichenbacher’s oracle threat (ROBOT). In 27th USENIX
Security Symposium (USENIX Security 18), pages 817–849,