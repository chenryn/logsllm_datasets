timestamp used in CT, ULDM merge promises include the
version of the root log as this allows a proof of misbehav-
ior without a trusted source of time. Uncompromised clients
must check the value has been merged later. To prove mis-
behavior when a value is not inserted on time, a client can
present a merge promise along with a signed Map Root Log
head where the corresponding Object Map does not contain
the value and where the version of the head is greater than
that in the promise; i.e., a server would need to stop operat-
ing completely if it wishes to both avoid merging an object
and revealing it is compromised.
5.3 Retrieving Values
To retrieve a value, the client sends the storage server the
Map Root Log version that it received in a previous request,
along with the object identiﬁer it is retrieving (e.g., the hash
of an attestation or revocation commitment). If the object
exists but has not yet been merged, the merge promise will
be returned. There is no guarantee that the storage server
will return a value before its merge promise deadline. If the
object has been merged or doesn’t exist, the server responds
with: (1) the object or nil, (2) a proof that the object existed
or did not exist in the Object Map at the latest map root, (3)
a proof that the latest map root exists in the Map Root Log at
the current Map Root Log head, and (4) a consistency proof
that the current Map Root Log head is an append-only ex-
tension of the version the client passed in its request. This
mechanism allows the client to verify that every map satisfy-
ing their queries is contained in the Map Root Log, and that
the Map Root Log is consistent. Notably, it does not allow
the client to verify that the map was correctly derived from
the Operation Log. This task is performed by the auditors.
5.4 Auditing
An auditor is a party that connects to a storage server and
replays the Operation Log to construct replicas of the Object
Map and check the Map Root Log. Each client reports the
latest Map Root Log head it obtains from the server (signed
by the server along with a version number) to the auditors
with some frequency. As the entries in the ULDM object
map are the hashes of the objects, not the objects themselves,
the map constructed by the auditor is several orders of mag-
nitude smaller than the sum of stored objects. For every entry
in the Map Root Log, the auditor will read the incremental
additions to the map from the Operation Log and apply them
to its own copy. It then ensures the hash of the replica Ob-
ject Map root matches the hash stored in the Map Root Log,
proving that the map is correctly derived from the operation
log (no objects were modiﬁed or removed).
The strength of the ULDM auditing scheme is that a client
can report a single value to an auditor (the client’s Map Root
Log head) and this is sufﬁcient to catch any dishonesty that
might have occurred at any point in the client’s history. With-
out the Map Root Log (such as in [34]), any auditing scheme
would need to make the client report every Object Map root
to the auditor or take the risk that some dishonesty might re-
main undiscovered. To see how this might occur, imagine
that a storage server removes a revocation from the map, an-
swers a query and then re-adds the revocation. Without the
Map Root Log, if the client only reports the ﬁnal map root to
an auditor, it would conclude it is valid. In the ULDM case,
the client would report the Map Root Log head which covers
all prior map versions, enabling the auditor to discover that
the previous query was satisﬁed from an invalid map.
Detecting dishonesty with a single infrequently-reported
value has important scalability implications: as we expect
there to be many clients, it is important that the load placed
on auditors is much less than the query load generated by the
clients, otherwise, only large companies could afford to be
auditors. In the ULDM model, it is sufﬁcient for a client to
contact an auditor rarely (perhaps once a day) to ensure any
prior equivocation is discovered.
We expect clients to periodically check in with a random
auditor from a public list of auditors. This ensures that the
storage server cannot maintain different states for different
auditors as it will be discovered when auditor receives a Map
Root Log head from a client that is inconsistent with the one
received from the storage server directly.
5.5 Security Guarantee
We formalize the security guarantee of a ULDM, as follows.
By honest client, we denote a client that is neither faulty nor
compromised.
Guarantee 2 (ULDM). Let C be a set of honest clients and
S be a ULDM server. Observe that the Merge Promises fol-
lowing insert requests by these clients and Map Root Log
heads sent with retrieval requests by these clients deﬁne a
partial ordering L over all requests received by S. Suppose
that there exists a nonempty set R of requests made by clients
in C, such that there exists no possible history of requests
made to S that is consistent with both L and all of S’s re-
sponses to requests in R. If there exists an auditor A such
that each client in C has sent A a Map Root Log head it re-
ceived from S at least as recent as the one it received for its
latest request in R, then one of the following holds:
1. One or more clients in C will be able to detect the in-
1384    28th USENIX Security Symposium
USENIX Association
consistency by inspecting the responses it received to
requests that it made to S.
2. The auditor A will be able to detect the inconsistency
by inspecting the Map Root Log heads it received from
clients in C and from S.
We provide a proof sketch in Appendix A.
6 Revocation and Naming
With the functionality of RDE and ULDM’s, we can eas-
ily construct a revocation scheme and a PKI-replacing entity
naming scheme.
6.1 Commitment-Based Revocation
When a user creates an attestation, it derives a random re-
vocation secret s from a seed stored with the entity private
keys and includes a cryptographic hash of s, hash(s), called
the revocation commitment, in the attestation. The user then
inserts the attestation into ULDM storage. Later on, the user
can revoke the attestation by publishing the revocation secret
s to the same storage. Revocation of entities works similarly.
An entity must have their private key to perform revocation;
mechanisms such as [53] can be used to ensure this.
When verifying a proof, the WAVE service ensures that
no attestations in the proof have been revoked. To do so, it
queries the storage tier for an object matching the revocation
commitment hash(s) in the attestation. If such an object ex-
ists, the veriﬁer knows that the attestation has been revoked.
If such an object does not exist, the veriﬁer receives a proof
of nonexistence for that hash from the storage tier. WAVE
ensures revocation only after the Merge promise deadline.
The security of this procedure relies on the guarantees of our
ULDM transparency log (§5). Alternatively, the entity form-
ing the proof can include proofs of nonexistence, signed by
the storage tier with a timestamp, with the attestations, so
that the veriﬁer does not have to perform this lookup.
6.2 Secure Lookup of Public Keys
To facilitate looking up entity public keys (to be used as
the subject in an attestation, and for RDE), without relying
on an external PKI, WAVE implements a naming scheme
that extends the proposal in SDSI [49]. The base func-
tionality (shared by WAVE and SDSI) allows an entity to
name another entity by creating a signed name declaration.
These name declarations form a web-of-trust global graph,
similar to that formed by attestations. By traversing this
graph, an entity can resolve hierarchical names. For exam-
ple, consider when an entity representing a company ACME
names an entity representing a department Marketing,
which in turn names an entity held by an employee Alice.
Then, by verifying the identity of a single entity out of
band (the company), an entity can resolve the names of
all employees within the company’s departments, such as
Alice.Marketing.ACME, without having to manually
establish the validity of individual employee entities.
The functionality above, proposed by SDSI, does not
Figure 5: Overview of WAVE’s implementation.
provide a distribution mechanism for entities to discover
the name declarations required to perform resolution, nor
a mechanism to ensure the privacy of declarations so that
only authorized parties may read them. WAVE solves both
of these problems. Firstly, WAVE stores name declara-
tions in the ULDM storage tier (§5) to ensure name decla-
rations are discoverable without compromising on the goals
of the system (especially without requiring on-line partic-
ipants). Secondly, WAVE uses a variation of the encryp-
tion scheme described in §4 to encrypt the name declara-
tions in storage. When creating a name declaration, it is
associated with a resource in a namespace (for example,
acme/directory/marketing) and an entity must be
explicitly granted permission on that resource in order to
gain the keys required to decrypt the name declaration. In
other words, the same attestations that are used to form a
proof of authorization are also used to govern which enti-
ties can read name declarations, without relying on a central
directory server. Resolution of names is done from each en-
tity’s cache of decrypted name declarations, stored alongside
decrypted attestations.
7
WAVE is implemented in Go and released as open source [7].
It runs as a background service and applications connect via
IPC. The service is composed of four logical parts (Fig. 5).
The storage abstraction permits multiple distinct storage
providers operating in parallel. As long as the provider im-
plements the API discussed in §5, WAVE can use it. Each
storage driver is responsible for ensuring the storage is trust-
worthy, e.g. for a ULDM-based storage it must verify the
proofs given by the remote storage server. Attestations can
span storage media, i.e., an entity residing on one server can
grant permissions to an entity on a different server. We im-
plemented the ULDMs using Merkle trees in Trillian [33]
backed by MySQL.
The perspective storage keeps track of the decrypted attes-
tations that form the perspective graph. This is the portion
of the global graph visible from the perspective of the prov-
ing entity. WAVE indexes it to allow efﬁcient key retrieval
Implementation
USENIX Association
28th USENIX Security Symposium    1385
ULDM storageULDM storage IBE/WIBE key storageIndexed decrypted graphAttestation state storagePerspective StorageAttestation state machine(per perspective entity)Compartment decryptionStorage AbstractionStorage multiplexerStorage DriverStorage driverULDM storageStorage DriverExpiry/RevocationProof buildingProof verifyCreate/revoke   entities/attestationsExternal APIAttestation lookup & verifyOperation
Create attestation1
Create entity
Decrypt attestation as veriﬁer
Decrypt attestation as subject
Decrypt delegated attestation
AMD64 ARMv8
43.7
8.9
0.48
3.87
6.22
445
88.5
4.44
44.0
67.9
Table 1: Object operation times [ms].
based on a new attestation and efﬁcient attestation retrieval
based on a new key. The index also allows for efﬁcient proof
building: ﬁnding attestations granted from a given issuer that
match speciﬁc permissions.
The state machine is responsible for transitioning the attes-
tation through the states of decryption following the discov-
ery process described in §4.7.
The external API is a GRPC [31] API that listens for con-
nections from applications and allows them to use the appli-
cation API functions given in Fig. 1b. GRPC can generate
bindings for multiple languages, so we expect that applica-
tions can be written in any language.
The proof builder, when asked to build a proof, begins at
the namespace authority (the entity that created the RTree
namespace) for the resource that permissions are being
proved on, and then performs a shortest path discovery
through the perspective graph terminating at the proving en-
tity. Note that this is the opposite direction that attestations
are traversed during discovery. Only edges granting a super-
set of the required permissions are traversed and the maxi-
mum depth of traversal is limited by the indirections parame-
ter in the traversed attestations. These two ﬁlters make proof
building fast for common cases (see §8.1).
8 Evaluation
Despite relying on cryptography for its security guarantees,
WAVE remains performant, competitive to traditional au-
thentication and authorization systems.
8.1 Microbenchmarks
WAVE’s performance is dominated by the cost of the core
cryptographic operations, shown in Table 1. These are the
times measured by a client using the GRPC application API.
The measurement is on an Intel i7-8650U AMD64 CPU rep-
resentative of a standard modern laptop, and on a Raspberry
Pi 3, indicative of a low-cost IoT-class ARMv8 platform.
The veriﬁer does not perform any WIBE decryption, as it
has the AES veriﬁer key. The subject entity (the direct re-
cipient of the attestation) can skip the IBE decryption of the
partition, but must still perform WIBE decryption. Any other
entity that is interested in the attestation because it lies fur-
ther up the delegation chain must perform IBE decryption,
WIBE decryption, and then AES decryption. These decryp-
tion operations take place only once—when an attestation is
added to the perspective graph—so are a one-off cost of re-
1Create attestation uses multiple cores
(a) Perspective graph update/build time
(b) Proof build/veriﬁcation time
Figure 6: Single core timings for proof operations. Vertical
line in Fig. 6b is the expected maximum proof length for
common applications.
System
LDAP+MySQL
OAuth2 JWT
WAVE 1 attest.
WAVE 3 attest.
Authentication Authorization
6.3ms
0.8ms
0.3ms
1.2ms
3.6ms
Table 2: Latency of LDAP+MySQL, OAuth2 vs. WAVE.
ceiving permissions. The veriﬁer decryption happens once
per unique proof; after that, it is cached so that subsequent
veriﬁcations complete in negligible time.
When decrypting attestations and building the perspective
graph, we also need to index all the obtained keys and store
them on disk. We can see the cost of decryption combined
with indexing by measuring the time taken to update a per-
spective graph, for different sizes of changes to the graph,
as shown in Fig. 6a. This includes the time taken to retrieve
the encrypted ciphertexts from ULDM-based storage. The
dashed vertical line is likely the maximum number of attes-
tations that will be found in a proof as more than ﬁve dele-
gations, although supported, is rare in all our deployments.
8.2 Traditional Authorization Flow
To compare WAVE against a traditional authorization sys-
tem, we benchmark the time taken by a representative back-
end to turn a username and password into an authorization
policy using an OpenLDAP server (which authenticates the
user and yields the groups they are part of) and a MySQL
database (which turns the groups into policy). We also add
the time taken to verify an OAuth2 JWT token containing the
authorization policy in the form of scopes.
The results are shown in Table 2. For a WAVE proof
mirroring the single-delegation structure present
in the
LDAP/OAuth2 case, the proof veriﬁes in a sixth of the time
taken by the traditional LDAP ﬂow. For a case where transi-
tive delegation has been used three times and the proof con-
1386    28th USENIX Security Symposium
USENIX Association
2468101214Newly Discovered Attestations2505007501000Time (ms)Persp. Graph Build251015Proof Length (Attestations)10203040Time (ms)BuildVerifyPUT
2KB
10.7
GET
2KB
10.4
En-
Queue
10.1
Iter-
Queue
10.0
Latency [ms]
Table 3: Average storage operation time (ms/op) under 4 uni-
form loads (≈ 100 requests per second), measured over 30
seconds (≈ 3k requests per type).
sists of three attestations, the WAVE veriﬁcation is about half
the time of the single-delegation LDAP ﬂow.
As in WAVE, OAuth2 offers a bearer token that can be val-
idated without communicating with the server. In this case,
validating a JSON Web Token with a 2048-bit RSA signature