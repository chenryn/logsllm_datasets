> CPU 也会出现类似的情况：如果你在多个执行绪间动态共享每个 CPU 核心，则一个执行绪有时必须在作业系统的执行伫列里等待，而另一个执行绪正在执行，这样每个执行绪都有可能被暂停一个不定的时间长度。但是，与为每个执行绪分配静态数量的 CPU 周期相比，这会更好地利用硬体（请参阅 “[响应时间保证](#响应时间保证)”）。更好的硬体利用率也是使用虚拟机器的重要动机。
>
> 如果资源是静态分割槽的（例如，专用硬体和专用频宽分配），则在某些环境中可以实现 **延迟保证**。但是，这是以降低利用率为代价的 —— 换句话说，它是更昂贵的。另一方面，动态资源分配的多租户提供了更好的利用率，所以它更便宜，但它具有可变延迟的缺点。
>
> 网路中的可变延迟不是一种自然规律，而只是成本 / 收益权衡的结果。
## 不可靠的时钟
时钟和时间很重要。应用程式以各种方式依赖于时钟来回答以下问题：
1. 这个请求是否超时了？
2. 这项服务的第 99 百分位响应时间是多少？
3. 在过去五分钟内，该服务平均每秒处理多少个查询？
4. 使用者在我们的网站上花了多长时间？
5. 这篇文章在何时释出？
6. 在什么时间传送提醒邮件？
7. 这个快取条目何时到期？
8. 日志档案中此错误讯息的时间戳是什么？
[例 1-4](ch1.md) 测量了 **持续时间**（durations，例如，请求传送与响应接收之间的时间间隔），而 [例 5-8](ch5.md) 描述了 **时间点**（point in time，在特定日期和和特定时间发生的事件）。
在分散式系统中，时间是一件棘手的事情，因为通讯不是即时的：讯息透过网路从一台机器传送到另一台机器需要时间。收到讯息的时间总是晚于传送的时间，但是由于网路中的可变延迟，我们不知道晚了多少时间。这个事实导致有时很难确定在涉及多台机器时发生事情的顺序。
而且，网路上的每台机器都有自己的时钟，这是一个实际的硬体装置：通常是石英晶体振荡器。这些装置不是完全准确的，所以每台机器都有自己的时间概念，可能比其他机器稍快或更慢。可以在一定程度上同步时钟：最常用的机制是 **网路时间协议（NTP）**，它允许根据一组伺服器报告的时间来调整计算机时钟【37】。伺服器则从更精确的时间源（如 GPS 接收机）获取时间。
### 单调钟与日历时钟
现代计算机至少有两种不同的时钟：日历时钟（time-of-day clock）和单调钟（monotonic clock）。尽管它们都衡量时间，但区分这两者很重要，因为它们有不同的目的。
#### 日历时钟
日历时钟是你直观地了解时钟的依据：它根据某个日历（也称为 **挂钟时间**，即 wall-clock time）返回当前日期和时间。例如，Linux 上的 `clock_gettime(CLOCK_REALTIME)`[^v] 和 Java 中的 `System.currentTimeMillis()` 返回自 epoch（UTC 时间 1970 年 1 月 1 日午夜）以来的秒数（或毫秒），根据公历（Gregorian）日历，不包括闰秒。有些系统使用其他日期作为参考点。
[^v]: 虽然该时钟被称为实时时钟，但它与实时作业系统无关，如 “[响应时间保证](#响应时间保证)” 中所述。
日历时钟通常与 NTP 同步，这意味著来自一台机器的时间戳（理想情况下）与另一台机器上的时间戳相同。但是如下节所述，日历时钟也具有各种各样的奇特之处。特别是，如果本地时钟在 NTP 伺服器之前太远，则它可能会被强制重置，看上去好像跳回了先前的时间点。这些跳跃以及他们经常忽略闰秒的事实，使日历时钟不能用于测量经过时间（elapsed time）【38】。
历史上的日历时钟还具有相当粗略的解析度，例如，在较早的 Windows 系统上以 10 毫秒为单位前进【39】。在最近的系统中这已经不是一个问题了。
#### 单调钟
单调钟适用于测量持续时间（时间间隔），例如超时或服务的响应时间：Linux 上的 `clock_gettime(CLOCK_MONOTONIC)`，和 Java 中的 `System.nanoTime()` 都是单调时钟。这个名字来源于他们保证总是往前走的事实（而日历时钟可以往回跳）。
你可以在某个时间点检查单调钟的值，做一些事情，且稍后再次检查它。这两个值之间的差异告诉你两次检查之间经过了多长时间。但单调钟的绝对值是毫无意义的：它可能是计算机启动以来的纳秒数，或类似的任意值。特别是比较来自两台不同计算机的单调钟的值是没有意义的，因为它们并不是一回事。
在具有多个 CPU 插槽的伺服器上，每个 CPU 可能有一个单独的计时器，但不一定与其他 CPU 同步。作业系统会补偿所有的差异，并尝试向应用执行绪表现出单调钟的样子，即使这些执行绪被排程到不同的 CPU 上。当然，明智的做法是不要太把这种单调性保证当回事【40】。
如果 NTP 协议检测到计算机的本地石英钟比 NTP 伺服器要更快或更慢，则可以调整单调钟向前走的频率（这称为 **偏移（skewing）** 时钟）。预设情况下，NTP 允许时钟速率增加或减慢最高至 0.05%，但 NTP 不能使单调时钟向前或向后跳转。单调时钟的解析度通常相当好：在大多数系统中，它们能在几微秒或更短的时间内测量时间间隔。
在分散式系统中，使用单调钟测量 **经过时间**（elapsed time，比如超时）通常很好，因为它不假定不同节点的时钟之间存在任何同步，并且对测量的轻微不准确性不敏感。
### 时钟同步与准确性
单调钟不需要同步，但是日历时钟需要根据 NTP 伺服器或其他外部时间源来设定才能有用。不幸的是，我们获取时钟的方法并不像你所希望的那样可靠或准确 —— 硬体时钟和 NTP 可能会变幻莫测。举几个例子：
* 计算机中的石英钟不够精确：它会 **漂移**（drifts，即执行速度快于或慢于预期）。时钟漂移取决于机器的温度。Google 假设其伺服器时钟漂移为 200 ppm（百万分之一）【41】，相当于每 30 秒与伺服器重新同步一次的时钟漂移为 6 毫秒，或者每天重新同步的时钟漂移为 17 秒。即使一切工作正常，此漂移也会限制可以达到的最佳准确度。
* 如果计算机的时钟与 NTP 伺服器的时钟差别太大，可能会拒绝同步，或者本地时钟将被强制重置【37】。任何观察重置前后时间的应用程式都可能会看到时间倒退或突然跳跃。