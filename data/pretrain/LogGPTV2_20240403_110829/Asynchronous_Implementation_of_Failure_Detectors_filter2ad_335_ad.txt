while the lowest one depicts p(2n), for 5 ≤ n ≤ 10). These
curves ﬁrst show how p(x) is related to the session length x.
More interestingly, they also show that, when x ≤ 2n, p(x)
is very close to 1 for n ≥ 7. Intuitively, adding processes
can only create more situations where PR1(S) is satisﬁed.
This is conﬁrmed and measured in Figure 2.(a) that shows
that, when the number n of processes increases, the prob-
ability increases also and becomes very quickly very close
to 1. In all cases, from n = 7, the probability p(x) is very
close to 1. This means that PR1(S) is practically satis-
ﬁed in asynchronous distributed systems made up of n ≥ 7
processes, if the sessions (during which the upper layer ap-
plication uses the failure detector of the class S) are not “too
long”.
Figure 2.(b) provides a complementary view. Its hori-
zontal axis corresponds to the number n of processes, while
its vertical axis corresponds to the length of the observation
period (number x of rounds). Considering a given proba-
bility p, this ﬁgure shows how long an upper layer session
can be (number x of rounds) for an asynchronous system
made up of n processes (5 ≤ n ≤ 14) to satisfy PR1(S)
with the given probability. The lowest curve corresponds to
p = 0.9999, the highest corresponds to p = 0.9900. These
curves show in another way that an asynchronous distribut-
ed system satisﬁes PR1(S) with a very high probability.
Implementing a Failure Detector in P/3P
6
Let us consider the following two behavioral properties:
PR(P)
PR(3P)
def= ∀pi : ∀t : (pi /∈ f t)
⇒ (cid:1)| ∩0≤u≤t
(cid:2)| > f
def= ∃u ∈ T : ∀pi : ∀t(cid:2) ≥ t : (pi /∈ f t(cid:1))
(cid:2)| > f
⇒ (cid:1)| ∩t≤u≤t(cid:1)
i ∪ f u
ru
(cid:1)
i ∪ f u
ru
(cid:1)
(cid:2)
,
(cid:2)
.
Intuitively, PR(P) states that for each process pi, from
the beginning of the execution and until pi possibly crashes,
there is a set Q of (f + 1) processes such that each process
pj ∈ Q receives a response from pi to each of its queries
until it (pj) possibly crashes. PR(3P) states that this be-
havioral property can hold only after a ﬁnite time.
Interestingly, the protocol described in Figure 1 is very
general: without any modiﬁcation, it implements a failure
detector of the class P (resp. 3P) when the underlying
system satisﬁes the property PR(P) (resp. PR(3P)). The
proof is similar to the previous one.
7 Conclusion
This paper has presented a new approach to implemen-
t Chandra-Toueg’s unreliable failures detectors. Different-
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
1
0.95
p(3n/2)
0.9
p(2n)
)
x
(
p
0.85
0.8
0.75
0.7
5
6
9
number of processes (n)
7
8
)
x
(
s
d
n
u
o
r
f
o
r
e
b
m
u
n
50
45
40
35
30
25
20
15
10
5
0
5
6
10
p=0.9900
p=0.9999
8
7
number of processes (n)
9
10 11 12 13 14
(a) p(x) according to n for x = 3n/2 and x = 2n
(b) Fixing a priori a probability p
Figure 2. Measuring “how realistic” is PR1(S)
ly from previous approaches that implement failure detec-
tors, the proposed approach does not rely on additional
synchrony assumptions (e.g., it allows the communication
times to always increase). It is based on a query-response
mechanism and assumes that the query/response messages
exchanged obey a pattern where the responses from some
processes to some process queries always arrive among the
(n − f) ﬁrst ones.
A general protocol that implements failure detectors has
been presented. Interestingly, it works for any value of f.
The particular failure detector it builds (i.e., a failure detec-
tor of the class P, S, 3P or 3S) depends on the property
satisﬁed by the underlying system. Such properties have
been explicitly stated. When f = 1, they boil down to a
simple channel property, namely, eventually there is a pair
of processes (pi, pj) such that the channel connecting them
is never the slowest among the channels connecting pi or pj
to the other processes. A probabilistic analysis has shown
that this requirement is practically relevant.
A particular property involves a subset of the process-
es and a subset of the channels connecting them. Practi-
cally, this means that such a property can be “ensured” by
designing an appropriate cluster of (f + 1) processes. In-
terestingly, the proposed approach could be combined with
the Timely Computing Base (T CB) approach [26] to build
dependable applications (the T CB being used to provide a
cluster of (f + 1) processes).
References
[1] Aguilera M.K., Chen W. and Toueg S., On Quiescen-
t Reliable Communication. SIAM Journal of Computing,
29(6):2040-2073, 2000.
[2] Aguilera M.K., Delporte-Gallet C., Fauconnier H. and
Toueg S., Stable Leader Election. Proc. 15th Symposium
on Distributed Computing (DISC’01), Lisbon (Portugal),
Springer Verlag LNCS #2180, pp. 108-122, 2001.
[3] Anceaume E., Fernandez A., Mostefaoui A. and Raynal
M., A Necessary and Sufﬁcient Condition for Transforming
Limited Accuracy Failure Detectors. Submitted to journal
publication, 2001.
[4] Bertier M., Marin O. and Sens P., Implementation and Per-
formance Evaluation of an Adaptable Failure Detector. Proc.
Int. IEEE Conference on Dependable Systems and Network-
s (DSN’02), IEEE Computer Society Press, pp. 354-363,
Washington D.C., 2002.
[5] Chandra T.D. and Toueg S., Unreliable Failure Detectors
the ACM,
for Reliable Distributed Systems. Journal of
43(2):225-267, 1996.
[6] Chandra T.D., Hadzilacos V. and Toueg S., The Weak-
est Failure Detector for Solving Consensus. Journal of the
ACM, 43(4):685-722, 1996.
[7] Chen W., Toueg S. and Aguilera M.K., On the Quality of
Service of Failure Detectors. IEEE Transactions on Com-
puters, 51(5):561-580, 2002.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
[8] Delporte-Gallet C., Fauconnier H. and Guerraoui R., A Re-
alistic Look at Failure Detectors. Proc. IEEE Inter. Confer-
ence on Dependable Systems and Networks (DSN’02), IEEE
Computer Society Press, pp. 345-352, Washington D.C.,
2002.
[9] Dwork C., Lynch N. and Stockmeyer L., Consensus in
the Presence of Partial Synchrony. Journal of the ACM,
35(2):288-323, 1988.
[10] Fetzer Ch., The Message Classiﬁcation Model. Proc. 17th
ACM Symposium on Principles of Distributed Comput-
ing (PODC’98), ACM Press, pp. 153-162, Puerto Vallarta
(Mexico), 1998.
[11] Fetzer Ch., Raynal M. and Tronel F., An Adaptive Failure
Detection Protocol. Proc. 8th IEEE Paciﬁc Rim Int. Sympo-
sium on Dependable Computing (PRDC’01), IEEE Comput-
er Society Press, pp. 146-153, Seoul (Korea), 2001.
[20] Mostefaoui A., Mourgaya E. and Raynal M., An Introduc-
tion to Oracles for Asynchronous Distributed Systems. Fu-
ture Generation Computer Systems, 18(6):757-767, 2002.
[21] Mostefaoui A. and Raynal M., Unreliable Failure Detec-
tors with Limited Scope Accuracy and an Application to
Consensus. Proc. 19th Int. Conference on Foundations of
Software Technology and Theoretical Computer Science (F-
ST&TCS’99), Springer-Verlag LNCS #1738, pp. 329-340,
Chennai (India), 1999.
[22] Mostefaoui A. and Raynal M., k-Set Agreement and Limit-
ed Accuracy Failure Detectors. Proc. 19th ACM Symposium
on Principles of Distributed Computing (PODC’00), ACM
Press, pp. 143-152, Portland (0R), 2000.
[23] Pease L., Shostak R. and Lamport L., Reaching Agreement
in Presence of Faults. Journal of the ACM, 27(2):228-234,
1980.
[12] Fischer M.J., Lynch N. and Paterson M.S., Impossibility of
Distributed Consensus with One Faulty Process. Journal of
the ACM, 32(2):374-382, 1985.
[24] Raynal M. and Tronel F., Restricted Failure Detectors: Deﬁ-
nition and Reduction Protocols. Information Processing Let-
ters, 72:91-97, 1999.
[25] Raynal M. and Tronel F., Group Membership Failure Detec-
tion: a Simple Protocol and its Probabilistic Analysis. Dis-
tributed Systems Engineering Journal, 6(3):95-102, 1999.
[26] Ver´ıssimo P. and Casimiro A., The Timely Computing Base
Model and Architecture. IEEE Transactions on Computers,
51(8):916-930, 2002.
[27] Ver´ıssimo P. and Raynal M., Time in Distributed Systems:
Models and Algorithms. In “Advances in Distributed Sys-
tems: From Algorithms to Systems”, Springer-Verlag LNCS
#1752, pp. 1-32, 2000.
[28] Yang J., Neiger G. and Gafni E., Structured Derivations
of Consensus Algorithms for Failure Detectors. Proc. 17th
ACM Symposium on Principles of Distributed Computing,
Puerto Vallarta (Mexico), pp.297-308, 1998.
[13] Gafni E., Round-by-Round Fault Detectors: Unifying Syn-
chrony and Asynchrony. Proc. 17th ACM Symposium on
Principles of Distributed Computing (PODC’98), ACM
Press, pp. 143-152, Puerto Vallarta (Mexico), 1998.
[14] Guerraoui R. and Schiper A., Γ-Accurate Failure De-
tectors. Proc. 10th Workshop on Distributed Algorithms
(WDAG’96), Bologna (Italy), Springer Verlag LNCS #1151,
pp. 269-285, 1996.
[15] Gupta I., Chandra T.D. and Goldszmidt G.S., On Scalable
and Efﬁcient Distributed Failure Detectors. Proc. 20th ACM
Symposium on Principles of Distributed Computing (POD-
C’01), ACM Press, pp. 170-179, Newport (RI), 2001.
[16] H´elary J.-M., Hurﬁn M., Mostefaoui A., Raynal M. and
Tronel F., Computing Global Functions in Asynchronous
Distributed Systems with Process Crashes. IEEE Transac-
tions on Parallel and Distributed Systems, 11(9):897-909,
2000.
[17] Hurﬁn M., Mostefaoui A. and Raynal M., A Versatile Fami-
ly of Consensus Protocols Based on Chandra-Toueg’s Unre-
liable Failure Detectors. IEEE Transactions on Computers,
51(4):395-408, 2002.
[18] Larrea M., Ar`evalo S. and Fern´andez A., Efﬁcient Algo-
rithms to Implement Unreliable Failure Detectors in Par-
tially Synchronous Systems. Proc. 13th Symposium on
Distributed Computing (DISC’99), Bratislava (Slovakia),
Springer Verlag LNCS #1693, pp. 34-48, 1999.
[19] Larrea M., Fern´andez A. and Ar`evalo S., Optimal Imple-
mentation of the Weakest Failure Detector for Solving Con-
sensus. Proc. 19th Symposium on Reliable Distributed Sys-
tems (SRDS’00), IEEE Computer Society Press, pp. 52-60,
Nuremberg (Germany), 2000.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE