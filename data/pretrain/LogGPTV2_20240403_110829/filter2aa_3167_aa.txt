CTF培训—PWN(漏洞挖掘与利用)
报告人: 360政企安服-胡晓梦
时间：2019年9月X日
CONTENT
团队介绍和自我介绍
1
PWN介绍
2
PWN基础入门
3
PWN实例讲解与演示
4
PWN解题总结
5
团队介绍和自我介绍
第一部分
团队介绍&自我介绍
待完善优化
讲在前面的话
师傅领进门，修行在个人。
虽然大部分培训只是入门的引领，但这里我们传授的是核心知识体系！
PWN介绍
第二部分
CTF-PWN介绍
Ø 什么是PWN？
PWN 题目主要考察二进制漏洞的挖掘和利用，需要对计算机操作系统底层有一
定的了解。在 CTF 竞赛中，PWN 题目主要出现在 Linux 平台上。
Ø PWN题目形式?
•
一个ip地址和端口号
Example:   
nc 106.75.2.53 60044
1.nc==>即netcat，一个小巧的网络工具（Linux中自带），本题
中用来建立TCP连接
2.连接成功后，目标主机会运行题目文件，通过TCP连接进行交互
•
一个二进制文件
即目标主机会运行的题目文件
换句话说，比赛时可以在二进制层面知道目标主机将会运行什么代码（没有
源代码）
CTF-PWN介绍
Ø PWN题目需要做什么(流程)？
1.分析二进制文件，找到其中的漏洞
利用IDA Pro(目前工业界最先进的反汇编和反编译利器)等工具进行二进
制分析,结合GDB调试找到其中的漏洞
2.通过异常的输入,绕过防护,利用漏洞，执行目标代码
常见的套路是执行system(“/bin/sh”)，打开shell
3.获取flag
flag一般在当前文件夹下
cat ./flag    打开flag文件(一般txt格式)，获得flag(一串字符)
CTF-PWN介绍
Ø PWN入门需要哪些知识？
l 汇编语言基础、函数调用时的栈帧变换
l 逆向基础: IDA静态分析+GDB动态调试,PWN可以看做是REVERSE的升级版
(REVERSE++)
l 软件防护技术(漏洞利用缓解)：
  栈保护：Canary,堆栈不可执行：NX(No-eXecute)
  地址随机化：ASLR(address space layout randomization)/PIE
  . . .
l 各种类型漏洞原理（一般针对Linux系统）
  主要两大类:栈漏洞(溢出), 堆漏洞(更复杂)
  printf 格式化字符串漏洞
  I/O file 漏洞等
l 漏洞利用方法
  ROP(Return-Oriented Programming)技巧(还有JOP, Return To Libc,
  GOT Hook. . .目标劫持控制流)
CTF-PWN介绍
Ø PWN需要使用哪些工具？
l Linux系统(一般使用Ubuntu,Kali linux也可以）
l IDA Pro:反汇编及反编译，同时也是强大的调试器(不过Linux环境下调试文件略麻烦)
l Pwntools:一个用来解题的Python库，内置有很多自动查找地址、自动生成shellcode的函（一
般情况下，不会出现可以直接用pwntools某个函数就能解的题，同时攻击的方法多样，
pwntools一般只是用到远程连接的功能
l GDB： Linux 下 命令行界面的调试器，有一些好用的插件，比如gdb_peda、pwndbg
插件可以在GitHub上找到，开源，易安装
l ROPgadget：用于查找gadget和生成ROP链(之后会再介绍)
l . . . . .
Ø PWN基本解题流程(基于逻辑灵活解题)
逆向工程
漏洞挖掘
漏洞利用&
防护绕过
GetShell(flag)
CTF-PWN介绍
安全保护检查
PWN基础入门
第三部分
PWN基础入门
Ø 汇编基础(参考REVERSE,这里不细述)
Ø 栈溢出
Ø Linux漏洞安全防护机制与绕过
Ø 其他漏洞(整数溢出、格式化字符串等）
Ø 堆漏洞
Ø ……..
PWN攻防一览图 by jacob 
栈溢出(返回地址覆盖)
栈溢出防护
栈防护绕过
返回地址覆盖
NX/DEP
Canar
y
ASLR/PIE
Ret2ShellCode
Ret2ibc
ROP
HijackGOT
函数地址劫持
泄露Canary
Canary
格式化字符串
劫持__stack_chk_fail
爆破Canary(fork)
ssp leak
Ret2ibc
NX/DEP
ASLR/PIE
ROP
return-to-plt
爆破
GOT overwrite
GOT dereference
泄露libc
覆盖GOT
堆溢出(多样、有趣)
组合利用、
灵活解题
partial write
vdso/vsyscall
write、printf
PWN基础入门
Ø 汇编基础(参考REVERSE篇,这里不细述)
Ø 栈溢出
Ø Linux漏洞安全防护机制与绕过
Ø 其他漏洞(整数溢出、格式化字符串等）
Ø 堆漏洞
Ø ……..
PWN基础入门
Ø 栈溢出
在计算机安全领域，缓冲区溢出是个古老而经典的话题。
什么是缓冲区溢出？
将源缓冲区复制到目标缓冲区可能导致溢出:
1、源字符串长度大于目标字符串长度。
2、不进行大小检查。
缓冲区溢出有两种类型：
1、基于栈的缓冲区溢出 - 这里的目标缓冲区位于栈中
2、基于堆的缓冲区溢出 - 这里的目标缓冲区位于堆中
众所周知，计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度
限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。
为了实现栈溢出，要满足两个条件:
第一，程序要有向栈内写入数据的行为；
第二，程序并不限制写入数据的长度。
PWN基础入门
Ø 栈溢出
在介绍如何实现溢出攻击之前，让我们先简单重温一下REVERSE中讲到的函数调用栈的相
关知识。
函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括
函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状
态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，
栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在
内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。
PWN基础入门
Ø 栈溢出
函数状态主要涉及三个重要寄存器－－esp，ebp，eip。esp 用来存储函数调用栈
的栈顶地址，在压栈和退栈时发生变化。ebp 用来存储当前函数状态的基地址，
在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。eip 用来存储
即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之
指向相邻的下一条指令，如此反复，程序就得以连续执行指令。
参数入栈
返回地址入栈
基地址ebp入栈
 局部变量入栈
栈清理(ebp、局部变量、
返回地址出栈)
PWN基础入门
Ø 栈溢出
当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数
调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可
以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 eip
（还记得 eip 的用途吗？），所以我们的目标就是让 eip 载入攻击指令的地址，
即所谓的控制流劫持。
先来看看函数调用结束时，如果要让 eip 指向攻击指令，需要哪些准备？首先，
在退栈过程中，返回地址会被传给 eip，所以我们只需要让溢出数据用攻击指令的
地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，
也可以在内存其他位置寻找可用的攻击指令。
再来看看函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？这时，
eip 会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，不过
我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。
PWN基础入门
Ø 栈溢出
基于控制流劫持的栈缓冲区溢出利用一般有如下4种方式:
•
修改返回地址，让其指向溢出数据中的一段指令（ret2shellcode）
•
修改返回地址，让其指向内存中已有的某个函数（ret2libc）
•
修改返回地址，让其指向内存中已有的一段指令（ROP）
•
修改某个被调用函数的地址，让其指向另一个函数（hijack GOT)
•
. . . 
1.栈溢出利用之ret2shellcode
在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。攻击
指令一般都是用来打开 shell，从而可以获得当前进程的控制权，所以这类指令片
段也被成为“shellcode”。
什么是shellcode？
PWN基础入门
Ø 栈溢出利用之ret2shellcode
payload : padding1 + address of shellcode + padding2 + shellcode
padding1 处的数据可以随意填充（注意如
果利用字符串程序输入溢出数据不要包含 
“\x00” ，否则向程序传入溢出数据时会造
成截断），长度应该刚好覆盖函数的基地址。
address of shellcode 是后面 shellcode 起
始处的地址，用来覆盖返回地址。padding2 
处的数据也可以随意填充，长度可以任意。
shellcode 应该为十六进制的机器码格式。
根据上面的构造，我们要解决两个问题：
1. 返回地址之前的填充数据（padding1）
应该多长？(如何定位精确的返回地址)
2.  shellcode起始地址应该是多少？
PWN基础入门
Ø 栈溢出利用之ret2shellcode
1. 返回地址之前的填充数据（padding1）应该多长？
我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输
入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错),pattern ?
2. shellcode起始地址应该是多少？
我们可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机），参见前
面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境
变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，
解决办法是在 padding2 里填充若干长度的 “\x90”。这个机器码对应的指令是 NOP (No 
Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只
要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这
种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样我们就可以通过增加 NOP 填充来配合
试验 shellcode 起始地址。