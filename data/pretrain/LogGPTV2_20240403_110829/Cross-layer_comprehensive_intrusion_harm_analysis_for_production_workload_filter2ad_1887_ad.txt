shell to download and install the ARK rootkit, which re-
places system binaries (e.g., syslogd, login, sshd, ls, ps, net-
stat, and etc.) with backdoored versions. We rely on IDS to
detect the modiﬁcation of system binaries by integrity check.
By virtue of the backward system call dependency tracking,
all of PEDA, SHELF [19] and Backtracking [11] can iden-
tify ssh as the system-object-level intrusion root. However,
neither SHELF nor Backtracking can locate the malicious
kernel hook modiﬁcation by adore rootkit. Instead, they are
only capable of diagnosing the intrusion infection of ARK
rootkit due to their system call ﬂow auditing. Rather, the
ﬁne-grained intrusion root identiﬁcation of PEDA system
can audit the system calls issued by ssh, and identify the
disk sectors containing the downloaded rootkits adore and
ARK as taint seed. By applying dynamic taint tracking
and semantics reconstruction, PEDA is able to capture not
only the damage identiﬁed by SHELF and Backtracking, but
also the intrusion harm of the kernel hooks modiﬁcation im-
planted by adore rootkit, such as the replaced sys write and
etc.
6. LIMITATIONS
In this section, we discuss the limitations of PEDA sys-
tem. First, the automatic intrusion backtracking is not 100
% accurate, especially at the granularity of memory cell or
disk sector. Our PEDA system relies on intrusion backtrack-
ing to locate the ﬁne-grained intrusion root, which in turn
is provided as taint seed to infection analyzer. To reduce
the false positive on PEDA’s intrusion harm analysis result,
the intrusion backtracking of PEDA involves some human
interference to accurately locate the ﬁne-grained intrusion
root. Second, to replay the execution of a busy server with
signiﬁcantly high workload, the amount of non-deterministic
events to be recorded might be huge. In this case, it may
not be feasible for PEDA to store a history of events that
is much longer than the expected intrusion detection de-
lay. Thus, if the intrusion is detected much later than its
occurrence, the ﬁrst run compromised execution cannot be
completely replayed due to the removal of long time ago
non-deterministic event logs.
Figure 5: Fine-Grained Intrusion Root Identiﬁca-
tion
To show the comprehensiveness and precision of our intru-
sion analysis, we conduct two case studies of real-life intru-
sion. For the page limit, we only show the detailed results of
the ﬁrst case in terms of ﬁne-grained intrusion root identiﬁ-
cation and dynamic taint tracking. For the second case, we
focus on showing the advance of PEDA system over previous
system-call-level intrusion analysis.
5.2.1 Case Study 1
The attack scenario of Case 1 is as follows. The attacker
ﬁrst logs into the server system by ssh using an unprivileged
user account. Then he downloads a Linux NULL pointer
dereference exploit and launches the attack [2] to gain root
privilege. Afterwards, he mails back, examines and modiﬁes
the syslog.conf ﬁle to let the system logs be sent to his email
account. Finally, he deletes all ﬁles under the /var/log/
directory to hide his intrusion “footprint”.
Fine-grained Intrusion Root Identiﬁcation We as-
sume that the IDS detects the maliciously modiﬁed ﬁle sys-
log.conf and the missing ﬁles under the directory /var/log/.
These intrusion symptoms are notiﬁed to the PEDA sys-
tem. Afterwards, we start the intrusion root identiﬁca-
tion from the detected intrusion symptoms, and trace the
automatically-generated dependency graph backward. We
tailor the intrusion ﬂows at the system object level from
the dependency graph, and locate the system-object-level
intrusion root wget. Figure 5 shows the ﬁne-grained intru-
sion root identiﬁcation procedure. We audit system calls
issued by wget to identify the buﬀers containing the intru-
sion packet. Finally, we can obtain the disk sectors used
to store the intrusion packet, which is taken as ﬁne-grained
taint seed for infection diagnosis.
Infection Diagnosis In order to show suﬃcient infor-
mation regarding the intrusion behaviour, and the details of
how the intrusion happens on the server system and what
has been infected by the intrusion propagation, we start a
whole system dynamic taint tracking from the disk sectors
containing the intrusion packet during replay. For the space
limitation, Figure 6 presents only partial outcome of our in-
fection diagnosis. The rectangle denotes memory address
space or disk sectors on the server system. The ellipse at-
tached to each rectangle includes the OS semantics from our
304Figure 6: Whole System Infection Diagnosis
7. RELATED WORK
First, our ﬁne-grained intrusion root identiﬁcation is im-
plemented by integrating backward system-object depen-
dency tracking [11] and forward instruction ﬂow taint anal-
ysis. This is the ﬁrst attempt to bridge the gap between
the forward ﬁne-grained analysis and the backward system-
object intrusion root identiﬁcation. As a general intrusion
analysis tool, PEDA advances existing system-object-level
analysis in terms of intrusion harm comprehensiveness and
precision, as shown in our second case study of evaluation
section. VM replay is a relatively mature technique in the
VM industry (e.g., VMWare) these days. However, the re-
play on another heterogeneous VM is not. Some new issues
exit, such as how to address the device emulation incompati-
bilities. Aftersight [6] is the ﬁrst work that we can ﬁnd talk-
ing about these heterogeneous VM migration issues. The
following we will mainly discuss the diﬀerences between our
work and Aftersight.
Being a generic technology for decoupling dynamic pro-
gram analysis from execution, Aftersight decouples instruc-
tion level analyses from the normal execution (of online
servers) for a spectrum of purposes, including bug ﬁnding
and forensics. Aftersight records program execution and
replays it on a separate analysis platform against a set of
memory safety guarantee policies. Hence, it enables heavy-
weight analysis during replay to ﬁnd serious bugs in large
complex systems such as VMWare ESX Server and Linux.
In contrast, PEDA focuses on the post-mortem intrusion
analysis for production workload servers from intrusion root
identiﬁcation to ﬁne-grained infection diagnosis. Thus, the
problems faced by PEDA are to precisely locate the intrusion
root object to patch the vulnerabilities, and to reasonably
associate the intrusion root object with the ﬁne-grained taint
seed to start comprehensive infection diagnosis. Though Af-
tersight and PEDA share the same idea of decoupling anal-
ysis from normal execution, they aim at diﬀerent types of
analysis, thus dealing with diﬀerent sets of design and im-
plementation issues.
In addition to dealing with diﬀerent analysis, PEDA also
diﬀers from Aftersight in the architecture design. After-
sight migrates guest server system from recording platform
(VMWare Workstation) to analysis platform (Qemu), while
PEDA does it from Xen to Qemu. Since Xen relies on qemu-
dm to emulate majority of devices, PEDA takes the ap-
proach of recording the external inputs to each device and
redelivering them to the corresponding device during the
replay. Because VMWare and Qemu emulate I/O devices
diﬀerently, Aftersight chooses to record all the outputs from
each emulated device to CPU and to redeliver them to CPU
during the replay to “bypass” the device emulation incom-
patibility.
In order to avoid the signiﬁcant runtime over-
head introduced by the large amount of the device output
logging, Aftersight adopts the approach of “replay based re-
play”.
In particular, Aftersight records external inputs to
the device during normal execution, logs the device outputs
to CPU during the ﬁrst replay, and ﬁnally replays the second
recording for analysis. Compared with Aftersight, the de-
vice emulation incompatibility elimination of PEDA is more
straightforward and eﬃcient for production workload server
systems, though less generic.
Several other works exist to help security administrators
to do intrusion analysis, such as Repairable File Service [23],
Intrusion Recovery [22] and Backtracking [11]. All of them
log system calls during execution, and use them to track
305[7] M. Costa, J. Crowcroft, M. Castro, A. Rowstron,
L. Zhou, L. Zhang, and P.Barham. Vigilante
end-to-end containment of internet worms. SOSP,
2005.
[8] G. W. Dunlap, S. T. King, S. Cinar, M. A. Basrai,
and P. M. Chen. Revirt: enabling intrusion analysis
through virtual-machine logging and replay.
Proceedings of the 5th OSDI, pages 211–224, 2002.
[9] A. Ho, M. Fetterman, C. Clark, A. Warﬁeld, and
S. Hand. Practical taint-based protection using
demand emulation. Eurosys, 2006.
[10] X. Jiang, X. Wang, and D. Xu. Stealthy malware
detection through vmm-based “out-of-the-box”
semantic view reconstruction. Proceedings of the 14th
ACM CCS, pages 128–138, 2007.
[11] S. T. King and P. M. Chen. Backtracking intrusions.
SOSP, 2003.
[12] A. Menon, A. L. Cox, and W. Zwaenepoel. Optimizing
network virtualization in xen. USENIX Annual
Technical Conference, 2006.
[13] G. Portokalidis, A. Slowinska, and H. Bos. Argos: an
emulator for ﬁngerprinting zero-day attacks.
EUROSYS, 2006.
[14] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and
T. Anderson. Eraser: A dynamic data race detector
for multithreaded programs. ACM Transactions on
Computer Systems, pages 391–411, 1997.
[15] J. Seward and N. Nethercote. Using valgrind to detect
undeﬁned value errors with bit-precision. USENIX
Annual Technical Conference, 2005.
[16] A. Slowinska and H. Bos. Pointless tainting?:
Evaluating the practicality of pointer tainting.
Eurosys, 2009.
[17] G. E. Suh, J. W. Lee, D. Zhang, and S. Devada.
Secure program execution via dynamic information
ﬂow tracking. ASPLOS, 2004.
[18] Z. Wang, X. Jiang, W. Cui, and X. Wang. Countering
persistent kernel rootkits through systematic hook
discovery. RAID, 2008.
[19] X. Xiong, X. Jia, and P. Liu. Shelf: Preserving
business continuity and availability in an intrusion
recovery system. ACSAC, 2009.
[20] M. Xu, V. Malyugin, J. Sheldon, G. Venkitachalam,
and B. Weissman. Retrace: Collecting execution trace
with virtual machine deterministic replay. MoBS,
2007.
[21] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda.
Panorama: capturing system-wide information ﬂow for
malware detection and analysis. CCS, 2007.
[22] S. Zhang, X. Xiong, X. Jia, and P. Liu.
Availability-sensitive intrusion recovery. VMSec, 2009.
[23] N. Zhu and T. Chiueh. Design, implementation, and
evaluation of repairable ﬁle service. DSN, 2003.
the ﬂow/dependency between system objects. This kind
of coarse-grained dependency tracking typically cannot cap-
ture the whole “footprint” of intrusion, because the attackers
can craft programs with direct memory load/store instruc-
tions that can evade the system call level auditing. Rather,
PEDA applies the ﬁne-grained instruction ﬂow taint track-
ing to capture the intrusion propagation with both com-
prehensiveness and precision. Both Backtracking [11] and
PEDA use backward tracking from detected intrusion symp-
toms to locate the intrusion root. However, Backtracking
only identiﬁes the system-object-level intrusion root, typi-
cally a process. In order to provide the infection analyzer
the ﬁne-grained taint seed, PEDA extends the Backtrack-
ing to “dip” further into the memory cells or disk storage
segments granularity. Thus, PEDA can eﬀectively integrate
the backward system object intrusion root identiﬁcation and
the the forward ﬁne-grained taint analysis.
8. CONCLUSION
PEDA is a systematic approach doing post mortem ﬁne-
grained intrusion analysis for production workload servers.
It helps security technicians swiftly identify the ﬁne-grained
intrusion root “breakin” to the server and precisely pinpoint
the infection propagation throughout the server. PEDA ef-
fectively decouples the analysis work oﬀ the online server
execution by novelly integrating the backward system call
dependency tracking and forward ﬁne-grained taint analysis.
The proposed heterogeneous VM migration signiﬁcantly re-
duces the runtime overhead of online server execution. Our
evaluation demonstrates PEDA’s advance over existing in-
trusion analysis systems in terms of eﬃciency and compre-
hensiveness. We believe that the comprehensive intrusion
analysis functionality of our PEDA system should have a
profound impact on any system recovery framework.
9. ACKNOWLEDGMENTS
We extend thanks to our shepherd, Reiner Sailer, for valu-
able feedback and constructive suggestions. We thank all the
anonymous reviewers for carefully reading the drafts and
providing helpful revision comments. This work was sup-
ported by AFOSR FA9550-07-1-0527 (MURI), ARO W911NF-
09-1-0525 (MURI), NSF CNS-0905131, and AFRL FA8750-
08-C-0137.
10. REFERENCES
[1] Intel i/o apic datasheet.
http://www.intel.com/design/chipsets/datashts/290566.htm.
[2] Linux null pointer dereference.
http://archives.neohapsis.com/archives/fulldisclosure/
2009-08/0174.html.
[3] F. Bellard. Qemu, a fast and portable dynamic
translator. USENIX Annual Technical Conference,
2005.
[4] T. C. Bressoud and F. B. Schneider. Hypervisor-based
fault tolerance. ACM Transactions on Computer
Systems, pages 80–107, 1996.
[5] P. M. Chen and B. D. Noble. When virtual is better
than real. HotOS, 2001.
[6] J. Chow, T. Garﬁnkel, and P. M. Chen. Decoupling
dynamic program analysis from execution in virtual
environments. USENIX Annual Technical Conference,
2008.
306