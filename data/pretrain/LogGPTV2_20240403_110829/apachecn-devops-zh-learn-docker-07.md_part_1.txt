# 七、单主机网络
在最后一章中，我们了解了在处理分布式应用架构时使用的最重要的架构模式和最佳实践。
在本章中，我们将以桥接网络的形式介绍 Docker 容器网络模型及其单主机实现。本章还介绍了软件定义网络的概念以及如何使用它们来保护容器化应用的安全。最后，它展示了容器港口如何向公众开放，从而使容器化的组件可以向外界开放。
本章将包含以下主题:
*   容器网络模型
*   网络防火墙
*   桥接网络
*   主机网络
*   零网络
*   在现有网络命名空间中运行
*   港口管理
完成本模块后，您将能够执行以下操作:
*   起草容器网络模型，以及白板上的所有基本组件
*   创建和删除自定义网桥网络
*   运行连接到自定义网桥网络的容器
*   检查桥接网络
*   通过在不同的桥接网络上运行容器，将它们相互隔离
*   将容器端口发布到您选择的主机端口
# 技术要求
对于本章，您唯一需要的是一个能够运行 Linux 容器的 Docker 主机。您可以使用装有 Docker for Mac 或 Windows 或 Docker 工具箱的笔记本电脑。
# 容器网络模型
到目前为止，我们已经使用了单个容器。但实际上，一个容器化的业务应用由几个容器组成，它们需要协作来实现一个目标。因此，我们需要一种方法让单个容器相互通信。这是通过建立我们可以用来在容器之间来回发送数据包的路径来实现的。这些路径被称为**网络**。Docker 定义了一个非常简单的网络模型，即所谓的**容器网络模型** ( **CNM** )，以指定任何实现容器网络的软件必须满足的要求。以下是 CNM 的图示:
![](img/47049c61-68e9-4492-9f1d-d2183fb9720d.png)
The Docker container network model
CNM 有三个要素——沙箱、端点和网络:
*   **沙盒:**沙盒完美地将一个容器与外界隔离开来。不允许入站网络连接进入沙盒容器。然而，如果绝对不可能与容器通信，那么容器在系统中就不太可能有任何价值。为了解决这个问题，我们有第二个元素，也就是端点。
*   **端点:**端点是从外部世界进入网络沙箱的受控网关，用于屏蔽容器。端点将网络沙箱(而不是容器)连接到模型的第三个元素，即网络。
*   **网络:**网络是将通信实例的数据包从一个端点传输到另一个端点，或者最终从一个容器传输到另一个容器的路径。
需要注意的是，网络沙箱可以有零到多个端点，或者换句话说，网络沙箱中的每个容器要么根本不连接到任何网络，要么可以同时连接到多个不同的网络。在上图中，三个网络沙箱的中间通过各自的端点连接到网络 1 和 2。
这种网络模型非常通用，并且没有指定相互通信的各个容器在网络上的运行位置。例如，所有容器可以在同一个主机(本地)上运行，也可以分布在多个主机(全局)上。
当然，CNM 只是描述容器之间网络如何工作的一个模型。为了能够使用我们的容器联网，我们需要 CNM 的真正实现。对于本地和全球范围，我们有多个 CNM 实现。在下表中，我们简要概述了现有的实现及其主要特征。名单没有特别的顺序:
| **网络** | **公司** | **范围** | **描述** |
| 桥 | Docker | 当地的 | 基于 Linux 网桥的简单网络，允许在单个主机上联网 |
| Macvlan | Docker | 当地的 | 在单个物理主机接口上配置多个第 2 层(即 MAC)地址 |
| 覆盖物 | Docker | 全球的 | 基于**虚拟可扩展局域网** ( **VXLan** )的多节点容器网络 |
| 编织网 | 编织厂 | 全球的 | 简单、灵活、多主机的 Docker 网络 |
| 网络插件 | 加拿大白鲑 | 全球的 | 开源容器网络 |
Docker 不直接提供的所有网络类型都可以作为插件添加到 Docker 主机中。
# 网络防火墙
Docker 一直有“安全第一”的口头禅。这一理念直接影响了如何在单一和多主机 Docker 环境中设计和实现网络。软件定义的网络创建起来既容易又便宜，但是它们完美地防火墙了从其他未连接的容器和外部世界连接到该网络的容器。属于同一个网络的所有容器都可以自由地相互通信，而其他容器则没有这样做的手段:
![](img/983ac77c-705e-45fb-81a5-451051405b36.png)
Docker networks
在上图中，我们有两个网络，分别叫做**前**和**后**。连接到前端网络的有容器 **c1** 和 **c2** ，连接到后端网络的有容器 **c3** 和 **c4** 。 **c1** 和 **c2** 可以自由通信，同样 **c3** 和 **c4** 也可以。但是 **c1** 和 **c2** 无法与 **c3** 或 **c4** 通信，反之亦然。
现在，如果我们有一个由三个服务组成的应用，即 **webAPI** 、**产品目录**和**数据库**，情况会怎样？我们希望 webAPI 能够与 productCatalog 通信，但不能与数据库通信，我们希望 productCatalog 能够与数据库服务通信。我们可以通过将 webAPI 和数据库放在不同的网络上，并将 productCatalog 附加到这两个网络上来解决这种情况，如下图所示:
![](img/a9586c56-bd83-4d79-8b32-3501b5a865aa.png)
Container attached to multiple networks
由于创建 sdn 很便宜，并且每个网络都通过隔离资源以防止未经授权的访问来提供额外的安全性，因此强烈建议您设计和运行应用，以便它们使用多个网络，并且只在绝对需要相互通信的同一网络上运行服务。在前面的例子中，web API 组件绝对不需要直接与数据库服务通信，所以我们将它们放在不同的网络上。如果最坏的情况发生了，黑客破坏了网络应用编程接口，那么如果不首先入侵产品目录服务，他们就无法从那里访问数据库。
# 桥接网络
Docker 桥网络是我们将详细讨论的容器网络模型的第一个实现。这个网络实现是基于 Linux 桥的。当 Docker 守护进程第一次运行时，它会创建一个 Linux 桥并调用它`docker0`。这是默认行为，可以通过更改配置来更改。Docker 然后用这个 Linux 网桥创建一个网络，并调用网桥。我们在 Docker 主机上创建的并且没有显式绑定到另一个网络的所有容器都会导致 Docker 自动连接到该桥接网络。
为了验证我们的主机上确实定义了一个名为`bridge``bridge`类型的网络，我们可以使用以下命令列出主机上的所有网络:
```
$ docker network ls
```
这将提供类似于以下内容的输出:
![](img/529b9e48-203a-4e99-9768-31de774796a9.png)
Listing of all Docker networks available by default
在您的例子中，标识会有所不同，但是输出的其余部分看起来应该是一样的。我们确实有一个名为`bridge`的第一个使用驱动程序`bridge`的网络。`local`的范围只是意味着这种类型的网络仅限于单个主机，不能跨越多个主机。在后面的章节中，我们还将讨论具有全局范围的其他类型的网络，这意味着它们可以跨越整个主机集群。
现在，让我们更深入地了解一下这个桥接网络是怎么回事。为此，我们将使用 Docker `inspect`命令:
```
$ docker network inspect bridge
```
执行时，它会输出一大块关于所讨论网络的详细信息。这些信息应该如下所示:
![](img/87373683-9297-4e75-9d20-be137a52612d.png)
Output generated when inspecting the Docker bridge network
当我们列出所有网络时，我们已经看到了`ID`、`Name`、`Driver`和`Scope`的值，所以这不是什么新鲜事。但是我们来看看**的 IP 地址管理** ( **IPAM** )块。IPAM 是一种软件，用于跟踪计算机上使用的 IP 地址。`IPAM`块中的重要部分是`Config`节点，其值为`Subnet`和`Gateway`。默认情况下，桥接网络的子网定义为`172.17.0.0/16`。这意味着所有连接到该网络的容器将获得一个由 Docker 分配的 IP 地址，该地址取自给定的范围，即`172.17.0.2`到`172.17.255.255`。`172.17.0.1`地址是为该网络的路由器保留的，该路由器在该类型网络中的角色由 Linux 网桥承担。可以预期，Docker 将连接到该网络的第一个容器将获得`172.17.0.2 `地址。所有后续容器将获得更高的编号；下图说明了这一事实:
![](img/0cf8a346-9417-4ffb-9983-f0b7d60507b1.png)
The bridge network
在上图中，我们可以看到主机的网络命名空间，其中包括主机的`eth0`端点，如果 Docker 主机在裸机上运行，则该端点通常是 NIC，如果 Docker 主机是 VM，则是虚拟 NIC。到主机的所有流量都通过`eth0`来。Linux 网桥负责主机网络和网桥网络子网之间的网络流量路由。
默认情况下，只允许来自出口的流量，所有入口都被阻止。这意味着，尽管容器化的应用可以到达互联网，但任何外部流量都无法到达。每个连接到网络的容器都有自己的虚拟以太网与网桥的连接。下图说明了这一点:
![](img/6316fc37-de65-439a-8510-356a1959af42.png)
Details of the bridge network
上图从主人的角度向我们展示了这个世界。我们将在本节的后面部分探讨容器中的情况。
我们不仅仅局限于`bridge`网络，因为 Docker 允许我们定义自己的定制桥接网络。这不仅仅是一个值得拥有的特性，但建议的最佳实践是不要在同一个网络上运行所有容器，而是使用额外的桥接网络来进一步隔离不需要相互通信的容器。要创建名为`sample-net`的自定义网桥网络，请使用以下命令:
```
$ docker network create --driver bridge sample-net
```
如果我们这样做了，我们就可以检查 Docker 为这个新的定制网络创建了什幺子网，如下所示:
```
$ docker network inspect sample-net | grep Subnet
```
这将返回以下值:
```
"Subnet": "172.18.0.0/16",
```
显然，Docker 刚刚为我们新的定制网桥网络分配了下一个空闲的 IP 地址块。如果出于某种原因，我们想在创建网络时指定我们自己的子网范围，我们可以通过使用`--subnet`参数来实现:
```
$ docker network create --driver bridge --subnet "10.1.0.0/16" test-net
```
为了避免因重复的 IP 地址而产生冲突，请确保避免创建子网重叠的网络。
既然我们已经讨论了什么是桥接网络以及如何创建自定义桥接网络，我们想了解如何将容器附加到这些网络。首先，让我们交互式地运行一个 Alpine 容器，而不指定要连接的网络:
```
$ docker container run --name c1 -it --rm alpine:latest /bin/sh
```
在另一个终端窗口，让我们检查`c1`容器:
```
$ docker container inspect c1
```
在大量的输出中，让我们暂时集中在提供网络相关信息的部分。可以在`NetworkSettings`节点下找到。我在以下输出中列出了它:
![](img/68a4d760-6ec1-453f-ae47-6d5a4997235a.png)
Network settings section of the container metadata
在前面的输出中，我们可以看到由于`NetworkID`等于`026e65...`，所以容器确实是附着在`bridge`网络上的，从前面的代码中我们可以看到这是`bridge`网络的 ID。我们还可以看到容器按照预期分配了`172.17.0.4`的 IP 地址，网关在`172.17.0.1`。请注意，该容器还有一个与之相关的`MacAddress`。这很重要，因为 Linux 网桥使用 Mac 地址进行路由。
到目前为止，我们已经从容器网络名称空间的外部着手处理这个问题。现在，让我们看看当我们不仅在容器内，而且在容器的网络命名空间内时的情况。在`c1`容器内部，让我们使用`ip`工具来检查发生了什么。运行`ip addr`命令，观察如下产生的输出:
![](img/12ff4bc7-3267-4294-9b49-03bf69d90dd3.png)
Container namespace as seen by the IP tool
前面输出的有趣部分是数字`19`，即`eth0`端点。Linux 桥在容器命名空间外部创建的`veth0`端点被映射到容器内部的`eth0`。从名称空间内部看，Docker 总是将容器网络名称空间的第一个端点映射到`eth0`。如果网络名称空间附加到附加网络，则该端点将被映射到`eth1`，以此类推。