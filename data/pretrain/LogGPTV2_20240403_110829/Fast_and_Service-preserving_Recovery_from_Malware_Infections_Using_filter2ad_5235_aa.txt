title:Fast and Service-preserving Recovery from Malware Infections Using
CRIU
author:Ashton Webster and
Ryan Eckenrod and
James Purtilo
Fast and Service-preserving Recovery from 
Malware Infections Using CRIU
Ashton Webster, Ryan Eckenrod, and James Purtilo, University of Maryland
https://www.usenix.org/conference/usenixsecurity18/presentation/webster
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
ISBN 978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.Fast and Service-preserving Recovery from Malware Infections Using CRIU
Ashton Webster
University of Maryland
Ryan Eckenrod
University of Maryland
James Purtilo
University of Maryland
Abstract
Once a computer system has been infected with malware,
restoring it to an uninfected state often requires costly
service-interrupting actions such as rolling back to a sta-
ble snapshot or reimaging the system entirely. To of-
fer a fast and service-preserving malware removal tech-
nique, we present CRIU-MR: a mechanism for restoring
an infected server running within a Linux container to an
uninfected state using Checkpoint/Restore in Userspace
(CRIU). We modify the CRIU source code to ﬂexibly
integrate with existing malware detection technologies
so that it can remove suspected malware processes from
within a Linux container using a modiﬁed checkpoint/re-
store event. This allows for an infected container with
a potentially damaged ﬁlesystem to be checkpointed and
subsequently restored on a fresh backup ﬁlesystem while
both removing malware processes and preserving the
state of trusted ones. This method is shown to suc-
ceed quickly with minimal impact on service availability,
restoring active TCP connections and completely remov-
ing several types of malware from infected Linux con-
tainers.
1
Introduction
Malware attacks remain a persistent threat to computer
security from year to year. Symantec alone recorded
over 20 billion malware alerts across customer machines
during 2010-2011, while both botnet infections and par-
ticularly damaging ransomware attacks are growing in
number annually [28, 38]. In response, the security com-
munity continues to develop intrusion prevention tech-
niques meant to stop malware from propagating to new
machines and intrusion detection systems (IDS’s) meant
to detect malicious processes running on computer hosts
[15, 26, 27, 30, 41]. Despite these efforts, many malware
infections go undetected and infect new hosts daily.
Once malware has been detected on a host, remov-
ing the malware and restoring the host to a trustwor-
thy, unharmed state proves challenging. The malware
removal and remediation capabilities of many commer-
cial malware detectors fail to completely erase a malware
program’s effects [34]. Other recovery solutions record
meticulous logs about the processes running on a sys-
tem in order to rollback and then forward restore infected
hosts [25, 33]. However, while these methods are quite
effective at removing and recovering from malware, they
prove slow, memory and monitoring intensive, and are
not known to be used in practice. Compared to log-based
recovery, Virtual Machine (VM) based approaches can
quickly restore an infected host to a known trustworthy
state using snapshots. Unfortunately, restoring a system
using snapshots will lose the state of any computations or
network connections that were running on the host unless
costly logging is implemented as well [18, 35]. Com-
pared to these efforts, we seek to develop a lightweight,
quick malware recovery technique which transparently
preserves the state of trusted services running on an in-
fected host without the overhead of log-based schemes.
We present a malware recovery system which extends
the Checkpoint/Restore In Userspace project (CRIU)
[40] to quickly restore an infected Linux container
(LXC) to a safe state while removing malware and pre-
serving running services in the process. This technique,
which we call CRIU for Malware Recovery (CRIU-MR),
allows CRIU to be ﬂexibly integrated with existing mal-
ware detection systems. When malware is detected on
a Linux container, the container process and its children
are ﬁrst checkpointed with CRIU. Malware processes are
identiﬁed during this step and marked to be ignored dur-
ing the subsequent container restore. The container pro-
cess can then be migrated and restored on a trustworthy
backup ﬁlesystem with CRIU, excluding the identiﬁed
malware processes. We show that CRIU-MR only takes
2.8 seconds to complete on average regardless of mal-
ware infection type across several Linux malware sam-
ples. We ﬁnd CRIU-MR is primarily useful for hosts
USENIX Association
27th USENIX Security Symposium    1199
with ﬁlesystems such as web servers, preserving active
network connections to the host without drastically in-
creasing response latency. By quickly restoring running
services while removing malware from a system, CRIU-
MR presents a lightweight alternative to log-based and
VM-based malware recovery schemes.
2 Related Work
Many techniques for recovering from malware infections
have been proposed over time. We group these works
into the following categories: tradtional, log-based, and
VM-based. We discuss these categories, as well as CRIU
and LXC, which CRIU-MR relies upon.
2.1 Traditional Malware Recovery
The most basic solution to malware remediation is to re-
install the infected host’s operating system and reformat
any disk drives. While this method is sure to remove
the malware and its effects, it is obviously undesirable
as it removes all data and processes on the host. Less
destructive malware remediation techniques have thus
been packaged into the signature-based antivirus pro-
grams typically installed on a computer host. Unfortu-
nately, Passerini et al.
[34] ﬁnd that even when these
programs detect malware, they may fail to remove mal-
ware executables for over 20% of infections. Further-
more, they typically fail to reverse secondary changes to
the infected ﬁlesystem or changes to registry keys in the
case of Windows hosts. While more effective malware
remediation techniques have been developed, these solu-
tions remain the most commonly used.
2.2 Log-Based Malware Recovery
Log-based recovery techniques, long used in database
implementations [32], restore a system’s state to a known
stable state by using log information to undo undesired
operations, correctly reapply valid changes, or both. The
Taser [20] recovery system records all ﬁle, network, and
process operations performed on the system and attempts
to use such logs to undo the effects of a malware pro-
gram once it is ﬂagged by an IDS. However, Taser will
be forced to undo all operations logged on the system if
the intrusion is not caught in a timely manner, and its re-
covery method can take many minutes to run in the worst
cases. Hsu et al. [25] attempt to differentiate trusted and
untrusted applications, logging only untrusted ones in or-
der to rollback their operations if necessary. The down-
side of this method is that untrusted processes are heav-
ily restricted in terms of their ﬁlesystem resources and
ability to interact with other processes, requiring user in-
put in most cases for any program to run successfully. It
additionally incurs signiﬁcant runtime and logging over-
head for each untrusted process.
Palieri et al. [33] develop a technique for automati-
cally generating a remediation executable which can be
run to reverse the effects of a given malware program.
While mostly successful, these executables failed to re-
verse effects in some cases, can accidentally reverse valid
changes, and fail to reverse changes an attacker may
manually make if the malware provides shell access.
2.3 VM-based Malware Recovery
Modern VM hypervisors allow for “snapshots” of a sys-
tem’s ﬁlesystem and process state to be taken at any
time, which can later be reverted to if necessary. If an
older, malware-free snapshot is available, malware can
be quickly removed from an infected VM by restoring
the VM to the prior snapshot. The downside is that the
operations/state of any trusted processes are lost when
the snapshot is restored. While not a VM-based tech-
nique, MalTRAK [39] uses the concept of “views” or
system snapshots in a similar manner to undo the effects
of a malware program.
ExecRecorder [18] is a VM-based recovery method
which also integrates logging to restore a system to a
trusted snapshot before replaying log events for non-
malware processes to restore the system state. The costly
logging process incurs a 4% runtime overhead and pro-
duces an average of over 5GB of logs per hour, and no
analysis of how long the recovery process takes is pro-
vided. The Secom [35] system attempts to avoid such
a logging overhead by ﬁrst writing a process’s changes
to an OS-level VM. It then attempts to remove poten-
tial malware effects by clustering changes according to
higher-level behavioral proﬁles before merging the non-
malware clusters to the VM host. This method is prone
to identifying false positives and still degrades program
performance by intercepting each system call run on the
VM. Finally, the TimeVM [19] system uses a blend of
log-based recovery and live backup VMs in different
time states to quickly identify a backup VM free of a de-
tected malware infection. This VM can then be rapidly
updated to a clean, up-to-date state by replaying the logs
of non-malware processes. The expected recovery time
using this system was still often higher than 30 seconds,
and the effects of a malware process that goes undetected
for a long period of time may still be unable to be re-
versed with this method.
2.4 LXC and CRIU
LXC is an open-source Linux project which aims to al-
low for the virtualization of a Linux system or process
within privilege-constrained containers [6]. These con-
1200    27th USENIX Security Symposium
USENIX Association
tainers are meant to be lightweight alternatives to virtual
machines, allowing for Linux virtualization without em-
ulating system hardware and running a separate kernel.
LXC containers can be run in a privileged or unprivileged
state, and it is generally recommended that containers be
run as unprivileged to minimize potential system dam-
age should an attacker discover a way to “escape” the
container. Given their own recommendation for unprivi-
leged container use, the LXC maintainers do not consider
privileged container escape exploits a serious concern,
stating “as privileged containers are considered unsafe,
we typically will not consider new container escape ex-
ploits to be security issues worthy of a CVE and quick
ﬁx” [8].
Checkpoint/Restore in Userspace (CRIU) is another
open-source project developed for Linux [40]. CRIU al-
lows for individual Linux processes to be checkpointed
during execution, saving their allocated memory and ex-
ecution progress in image ﬁles. These ﬁles can subse-
quently be used by CRIU to restore the process to its
prior state of execution when need be. One attractive fea-
ture of CRIU is that it is able to restore TCP connections
by using the TCP_REPAIR socket option [3]. This feature
prevents interruptions for TCP connections which are es-
tablished before the checkpoint/restore process. While
the more obvious applications of this technology may be
for the live migration of processes between hosts or load
balancing, Araujo et. al previously used CRIU in the
context of security by redirecting attackers attempting to
use known vulnerabilities to dynamically created honey-
pots [14].
CRIU has been incorporated into the LXC project, al-
lowing for an entire container and the processes running
within it to be checkpointed or restored. This is done via
the lxc-checkpoint utility, which directly calls the lo-
cally installed version of CRIU on the container host to
checkpoint or restore running containers.
3 Design Objectives
After considering previous attempts at malware recovery,
we seek to improve on the state of the art in several ways.
To this end, we select ﬁve desirable properties to guide
the design of our solution.
1. Fast: The method should minimize the downtime of
the system.
2. Availability-maximizing: The method should avoid
interruptions to services which are not directly af-
fected by the malicious processes.
3. Flexible: The method should accept alerts from a
variety of sources and make use of the information
provided by them.
4. Information-Gathering: The method should collect
information about the malicious processes to aid in
detecting them more easily and quickly in the fu-
ture.
5. Comprehensive: The method should fully remove
malware traces and record which changes were re-
verted.
With these goals in mind, we constructed CRIU-MR.
In order to achieve these goals, a few simplifying as-
sumptions were required. First, we suppose the ﬁlesys-
tem is “mostly-static”, meaning that updates are rela-
tively infrequent, and when they do occur, they can be
applied to both the real ﬁlesystem and the backups si-
multaneously. This is the case for many web servers, es-
pecially when the data is retrieved from a database on an-
other network node instead of being locally present. This
assumption allows for rapid restoration of the ﬁlesys-
tem, as the backup can be quickly swapped back into
the container root ﬁlesystem location in case of an in-
fection without ﬁle loss. Additionally, because we make
use of Linux container technology, we assume that the
attacker cannot escape from the container to the host ma-
chine. With this assumption, we are able to make use
of an isolated environment which can be independently
checkpointed and restored. In the following sections, we
describe this system and demonstrate its effectiveness
before returning to challenge these assumptions in the
“Discussion and Limitations” section (§6).
4
Implementation and Architecture
The majority of the implementation of our recovery
method exists as modiﬁcations to the CRIU source code.
Our changes are available as a fork of the CRIU repos-
itory on GitHub1. These changes are separated into the
two main actions of CRIU: checkpoint and restore. Over-
all, 659 lines of C code were added to implement these
features.
4.1 Checkpoint
The changes made to the checkpoint process mostly cen-
ter around reading a “policy” ﬁle and using this policy
to build a list of container processes which should not
be restored. The policy is read into CRIU using Pro-
tocol Buffers (also known as protobuf) [21], which is a
binary serialization format developed by Google. Proto-
buf was selected based on its high performance serializ-
ing and deserializing data relative to other formats, such
as XML or JSON [31], and also because it was already
used extensively for the image ﬁles generated by CRIU
1https://github.com/ashtonwebster/criu
USENIX Association
27th USENIX Security Symposium    1201
checkpoints. The policy can be composed of a variety of
user-deﬁned or dynamically generated rules that are used
to omit processes from being restored, including:
• Executable Name Match: Whether the executable
ﬁlename of a process matches a given string
• File Match: Whether any opened ﬁle of a process
matches a given string
• TCP IP Match: Whether the IP address for any es-
tablished TCP connection of a process matches a
given IP address
• Memory Match: Whether the process contains the
speciﬁed ASCII or Hex encoded string
• PID Match: Whether the PID of a process matches
the given PID
• Parent PID Match: Whether the parent PID of a
process matches the given PPID
• Parent Executable Name Match: Whether the par-
ent executable ﬁlename matches the given string
In choosing these rule types, we seek to provide a ﬂex-
ible policy language which can identify malware to omit
during the restore process based upon alerts provided by
various intrusion detection triggers, such as potentially