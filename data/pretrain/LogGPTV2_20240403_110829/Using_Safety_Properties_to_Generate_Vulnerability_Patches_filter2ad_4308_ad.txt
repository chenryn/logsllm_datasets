end for
(cid:46) Substitute the occurrence of each variable with its
nonlocal deﬁnition
nonlocal_expr ←substitute_vars(expr, mapping)
return nonlocal_expr
16:
17:
18: end procedure
It
line 9,
instruction in stack, starting
then iterates each call
from line 9. For each call
instruction,
it substitutes the
parameters in expr with the arguments used in the call
instruction. For
it substitutes x with rows and
y with cols+1, respectively, by calling helper function
substitute_parms_with_args. As a consequence,
“x*y+1” becomes “rows*(cols+1)+1”. Hence it as-
sociates “rows*(cols+1)+1” with function foo and
stores the association in expr_translated, because line 9
exists in function foo. After
tries to convert
“rows*(cols+1)+1” into a nonlocal deﬁnition with respect
to foo. At
it halts because both rows and
cols are assigned with return values of calls to function
extract_int. Otherwise,
it will move on to the next
function on the call stack and continue the translation upwards
the call stack. However, in this case, expression translation is
also able to translate the memory access range expression from
the scope of bar into the scope of foo. Thus, Senx places
the patch predicate in foo. If expression translation fails to
converge the expression, Senx will abort patch generation.
this point,
that,
it
V. IMPLEMENTATION
We have implemented Senx as an extension of the KLEE
LLVM execution engine [7]. Like KLEE, Senx works on
C/C++ programs that are compiled into LLVM bitcode [48].
We re-use the LLVM bitcode execution portion of KLEE,
and as described in Section IV-B, to implement our expression
builder, but do not use any of the constraint collection or
solving parts of KLEE. For simplicity and ease of debugging,
547
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
we represent our expressions as text strings. To support arith-
metic operations and simple math functions on expressions, we
leverage GiNaC, a C++ library designed to provide support for
symbolic manipulations of algebra expressions [1].
We implement a separate LLVM transformation pass to
annotate LLVM bitcode with information on loops such as the
label for loop pre-header and header, which is subsequently
used by access range analysis. This pass relies on LLVM’s
canonicalization of natural loops to normalize loops [8]. We
extend LLVMSlicer [46] for loop cloning. To locate error
handling code, we use Talos [19].
Our memory allocation logger uses KLEE to interpose on
memory allocations and stores the call stack for each memory
allocation. Senx extends KLEE to detect integer overﬂows and
incorporates the existing memory fault detection in KLEE to
trigger our patch generation. For alias analysis, Senx leverages
DSA pointer analysis [22].
Senx is implemented with 2,543 lines of C/C++ source code,
not including the Talos component [19] used to identify error
handling code.
VI. DISCUSSION
Our prototype of Senx supports three vulnerability types:
buffer overﬂow, bad cast, and integer overﬂow. And we believe
that safety properties can be used to produce patches for
many other vulnerability types. Because our goal is to produce
source code patches that can be adopted by developers, this
approach can be applied to any vulnerability type as long as the
safety property for the vulnerability type can be concretized
to program expressions in the source code of target programs.
For example, a safety property can be written for temporal
vulnerabilities such as time-of-check-to-time-of-use vulnera-
bilities with the information on what operations are considered
as a check and what operations are considered as a use. A
safety property can also be written for missing security check
vulnerabilities with information on what operations require
security checks and what API functions are used to perform
those security checks. Although providing such information
can require some effort from the developers, it only needs to
be done for one time.
We note that additional instrumentation in the source code
is needed for certain vulnerabilities. In our evaluation of
Senx on real-world vulnerabilities we found that the most
common reason that prevents Senx from generating a patch
is the inability to ﬁnd a common program scope where all
program expressions required to synthesize a predicate are
available. For such cases, the ability to create function clones
with additional arguments that pass the required expressions
between function scopes would enable Senx to also cover these
cases. We plan to add such capability to Senx in our future
work.
VII. EVALUATION
First, we evaluate the effectiveness of Senx in ﬁxing real-
world vulnerabilities. Second, we evaluate the quality of the
patches generated by Senx. We manually examine all the
App.
autotrace
binutils
libming
libtiff
PHP
sqlite
ytnef
zziplib
jasper
libarchive
potrace
Total
Description
a tool to convert bitmap to vector graphics
a collection of programming tools for
managing and creating binary programs
a library for creating Adobe Flash ﬁles
a library for manipulating TIFF graphic
ﬁles
the ofﬁcial interpretor for PHP program-
ming language
a relational database engine
TNEF stream reader
a library for reading ZIP archives
a codec for JPEG standards
a multi-format archive and compression
library
a tool for tracing bitmap graphics
N/A
SLOC
19,383
2,394,750
88,279
71,434
746,390
189,747
15,512
24,886
30,915
158,017
20,512
3,817,268
TABLE II: Applications for testing real-world vulnerabilities.
produced patches for correctness and compare them to the
developer created patch. For the sake of space, we only
describe two of the patches in detail. Third, we compare
Senx against state-of-art APR tools including Angelix and
SemFix. Last, we measure the applicability of loop cloning,
access range analysis, and expression translation using a larger
dataset.
A. Experiment Setup
We choose vulnerabilities in popular applications for Senx
to attempt to patch by searching online vulnerability databases
[10], [15], [33], software bug report databases, developers’
mailing groups [5], [37], [41], and exploit databases [35]. We
focus on vulnerabilities that fall into one of the three types
of vulnerabilities Senx can currently handle. We then select
vulnerabilities that meet the following three criteria: 1) an
input to trigger the vulnerability is either available or can
be created from the information available, 2) the vulnerable
application can be compiled into LLVM bitcode and executed
correctly by KLEE, and 3) the vulnerable application uses
standard memory allocation functions such as malloc to
allocate memory as Senx currently relies on this to infer the
allocation size of objects. Applications that use custom mem-
ory allocation routines are currently not supported by Senx.
We obtain the vulnerability-triggering inputs or information
about such inputs from the blogs of security researchers, bug
reports, exploit databases, mailing groups for software users,
or test cases attached to patch commits [2], [3], [6], [35], [44],
[56].
From this, we select 42 real-world buffer overﬂow, bad cast,
and integer overﬂow vulnerabilities along with proof of con-
cept exploits to evaluate the effectiveness of Senx in patching
vulnerabilities. The vulnerabilities are from 11 applications
show in Table II, which include 8 media and archive tools and
libraries, PHP, sqlite, and a collection of programming tools
for managing and creating binary programs. The associated
vulnerabilities consist of 19 buffer overﬂows, 13 bad casts,
and 10 integer overﬂows.
All our experiments were conducted directly on these vul-
nerable applications on a desktop with quad-core 3.40GHz
548
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
Intel i7-3770 CPU, 16GB RAM, 3TB SATA hard drive and
64-bit Ubuntu 14.04.
B. How Effective is Senx in Patching Vulnerabilities?
For each vulnerability of an application, we run the corre-
sponding program under Senx with a vulnerability-triggering
input. If Senx generates a patch, we manually examine the
patch for correctness. If Senx aborts patch generation, we
examine what caused Senx to abort.
Our results are summarized in Table III. Column “Type”
indicates whether the vulnerability is a ’B’ buffer overﬂow,
’C’ bad cast, or ’I’ integer overﬂow. Column “Expressions”
shows whether Senx can successfully construct all expressions
that are required to synthesize a patch, as some code constructs
may contain expressions outside of the theories Senx supports
in its symbolic ISA. “Loop Analysis” describes whether loop
cloning or access range analysis (ARA) is used if the vulner-
ability contained a loop. “Patch Placement” lists the type of
patch placement: “Trivial” means that the patch is placed in
the same function as the vulnerability and “Translated” means
that the patch must be translated to a different function. “Data
Access” describes whether or not the patch predicate involves
complex data access such as ﬁelds in a struct or array indices.
Finally, “Patched?” summarizes whether the patch generated
by Senx ﬁxes a vulnerability. The 10 vulnerabilities where
Senx aborts generating a patch are highlighted in red.
Over the 42 vulnerabilities, Senx generates 32 (76.2%)
patches, all of which are correct according to our three criteria.
Of the 13 patched buffer overﬂows, loop analysis is roughly
split between loop cloning and access range analysis (6 and 8
respectively). Senx elects not to use loop cloning mainly due
to two causes. First, due to an imprecise alias analysis that
does not distinguish different ﬁelds of structs correctly, the
program slicing tool utilized by Senx may include instructions
that are irrelevant to computing loop iterations into slices.
Unfortunately these instructions call functions that can have
side-effects so the slices cannot be used by Senx. Second, for
a few cases the entire body of the loops is control dependent
on the result of a call to a function that has side-effects.
For example, the loops involved in CVE-2017-5225 are only
executed when a call to malloc succeeds. Because malloc
can make system calls, Senx also cannot clone the loops.
Senx must place 23.8% of the patches in a function dif-
ferent from where the vulnerability exists. This is particularly
acute for buffer overﬂows (31.6% of cases), which have to
compare a buffer allocation with a memory access range. This
illustrates that expression translation contributes signiﬁcantly
to the patch generation ability of Senx, particularly for buffer
overﬂows, which make up the majority of memory corruption
vulnerabilities. Senx’s handling of complex data accesses is
also used in 48.5% of the patches, indicating this capability is
required to handle a good number of vulnerabilities
Senx aborts patch generation for 10 vulnerabilities. The
dominant cause for these aborts is that Senx is not able to
converge to a function scope where all symbolic variables
in the patch predicate are available. There is also one case
(jasper-CVE-2017-5501) where Senx cannot ﬁnd appropriate
error-handling code to synthesize the patch. In these cases,
the patch requires more signiﬁcant changes to the application
code that are beyond the capabilities of Senx. In other cases,
Senx detects that there are multiple reaching deﬁnitions for
patch predicates that it does not have an execution input for.
Currently, Senx only accepts one execution path executed by
the single vulnerability-triggering input. In the future we plan
to handle these cases by allowing Senx to accept multiple
inputs to cover the paths along which the other reaching deﬁni-
tions exist. Finally, Senx aborts for a couple of vulnerabilities
because both loop cloning and access range analysis fail.
C. What is the Quality of the Produced Patches?
For each patch generated by Senx, we manually examine
the patch for correctness. To determine if a patch is correct,
we apply the three following tests: a) we apply the patch
to the target program and verify that the vulnerability is no
longer triggered by the vulnerability-triggering input, b) we
run the built-in test suite provided by the vendor of the target
program to verify that the entire test suite is passed, c) we
check for semantic equivalence with the ofﬁcial patch released
by the vendor, if available, by manually examining if the patch
generated by Senx affects the behavior of the target program in
the same way as the ofﬁcial patch, and semantic correctness by
analyzing the code manually. We consider a patch is correct
only when all three tests are passed. Our examination ﬁnds
that all produced patches are correct.
Out of the 32 generated patches, we select 2 patches to
describe in detail.
libtiff-CVE-2017-5225. This is a heap buffer overﬂow in
libtiff, which can be exploited via a specially crafted
TIFF image ﬁle. The overﬂow occurs
in a function
cpContig2SeparateByRow that parses a TIFF image into
rows and dynamically allocates a buffer to hold the parsed
image based on the number of pixels per row and bits per
pixel. By using an inconsistent bits per pixel parameter, the
attacker can cause libtiff to allocate a buffer smaller than the
size of the pixel data and cause a buffer overﬂow.
it ﬁrst
the buffer
When Senx captures the buffer overﬂow via running
identiﬁes
libtiff with a crafted TIFF image ﬁle,
that
is allocated using the value of variable
scanlinesizein and the starting address of the buffer is
stored in variable inbuf. Hence it uses [inbuf, inbuf +
scanlinesizein] to denote the buffer range. Senx then
ﬁnds that the buffer overﬂow occurs in a 3-level nested loop
and that the pointer used to access the buffer is dependent on
the loop induction variable. Senx classiﬁes the vulnerability
as a buffer overﬂow.
Loop cloning fails because the loop slice is dependent
on a call
to _TIFFmalloc, which subsequently calls
malloc. Thus, Senx applies access range analysis. Access
range analysis detects that only the outer and inner-most
loops affect the memory access pointer and from the ex-
tracted induction variables, computes the expression [inbuf,
inbuf+spp*imagewidth] to represent the access range.
549
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
App.
sqlite
zziplib
Potrace
libming
libtiff
libarchive
jasper
ytnef
PHP
binutils
autotrace
CVE#
CVE-2013-7443
CVE-2017-13685
CVE-2017-5976
CVE-2017-5974
CVE-2017-5975
CVE-2013-7437
CVE-2016-9264
CVE-2016-9273
CVE-2016-9532
CVE-2017-5225
CVE-2016-10272
CVE-2016-10092
CVE-2016-5102
CVE-2006-2025
CVE-2016-5844
CVE-2016-9387
CVE-2016-9557
CVE-2017-5501
CVE-2017-9471
CVE-2017-9472
CVE-2017-9474
CVE-2011-1938
CVE-2014-3670
CVE-2014-8626
CVE-2017-15020
CVE-2017-9747
CVE-2017-12799
CVE-2017-6965
CVE-2017-9752
CVE-2017-14745
CVE-2017-9151
CVE-2017-9153
CVE-2017-9156
CVE-2017-9157
CVE-2017-9168
CVE-2017-9191
CVE-2017-9161
CVE-2017-9183
CVE-2017-9197
CVE-2017-9198
CVE-2017-9199
CVE-2017-9200
Type
I
I
B
I
I
C
I
B
B
B
B
I
I
C
C
C
C
C
B
B
B
B
B
B
B
B
I
I
I
C