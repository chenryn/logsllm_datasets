### 容器环境中的代理模型

**作者：Lori MacVittie**  
**分类：容器与云**  
**译者：geekpi**  
**校对：wxy**  
**发布日期：2018-04-02**

---

#### 摘要
大多数人都熟悉传统的代理工作方式，但在基于容器的环境中，代理的工作方式有所不同。本文将探讨在容器化环境中，代理模型有哪些变化。

![](/data/attachment/album/201804/02/094024yasbbcasss7bz7cy.jpg)

---

我们过去常使用诸如内联、侧臂、反向和前向等术语来描述网络代理架构布局。如今，虽然容器依然沿用一些这些术语，但它们也引入了一些新的概念。这为我提供了一个机会来详细阐述我最喜爱的主题之一：代理。

云计算的主要驱动力之一（尽管成本控制也是一个重要因素）是可扩展性。在过去五年中，可扩展性在各种调查中经常被提及，有时甚至超过了敏捷性，成为机构在云计算环境中部署应用的主要追求。这主要是因为在数字经济中，应用程序就像实体店的“营业/休息”标志一样重要。一个缓慢或无响应的应用程序就如同一家关灯或没有员工的商店一样。

[![](/data/attachment/album/201804/02/094035ilgbg9uxuqluhyy9.png)](https://devcentral.f5.com/Portals/0/Users/038/38/38/unavailable_is_closed.png?ver=2017-09-12-082118-160)

应用程序需要随时可用并能够满足需求。扩展是实现这一业务目标的技术手段。云计算不仅提供了扩展的能力，还提供了自动扩展的功能。要做到这一点，通常需要一个负载均衡器，因为这是通过代理进行流量/请求负载均衡的方式。

容器在扩展方面与传统方法并没有太大不同。为了扩展容器（并自动扩展），同样需要使用负载均衡器（代理）。如果你使用的是传统的代理机制，那么你可能依赖于基于TCP/UDP的基本负载均衡。然而，基于容器的代理在HTTP或其他应用层协议中并不如传统代理那样灵活，并且无法提供旧式负载均衡（POLB）之外的其他功能。这通常已经足够了，因为容器扩展是在一个克隆的、假设水平扩展的环境中进行的：要扩展一个应用程序，只需添加另一个副本并在其上分发请求。第7层（HTTP）路由功能可以在入口控制器和API网关中找到，并且可以使用尽可能多的应用路由来扩展应用程序。

然而，在某些情况下，这还不够。如果你希望或需要更多以应用程序为中心的扩展或插入其他服务的能力，那么你可以选择更强大的产品，这些产品可以提供可编程性或以应用程序为中心的可伸缩性，或者两者兼而有之。这意味着你需要插入代理。你使用的容器编排环境在很大程度上决定了代理的部署模型，无论是反向代理还是前向代理。更有趣的是，还有第三个模型——挎斗模式，这是由新兴的服务网格实现支持的可扩展性的基础。

#### 反向代理
![](/data/attachment/album/201804/02/094036ymw4ol44o9fwh2ty.jpg)

反向代理最接近于传统模型，在这种模型中，虚拟服务器接受所有传入请求，并将其分发到资源池（服务器中心、集群）中。每个“应用程序”都有一个代理。任何想要连接到应用程序的客户端都连接到代理，代理然后选择并转发请求到适当的实例。如果绿色应用想要与蓝色应用通信，它会向蓝色代理发送请求，蓝色代理会确定蓝色应用的两个实例中的哪一个应该响应该请求。在这个模型中，代理只关心它正在管理的应用程序。蓝色代理不关心与橙色代理关联的实例，反之亦然。

#### 前向代理
[![](/data/attachment/album/201804/02/094037bfxojo441yxuofg0.jpg)](https://devcentral.f5.com/Portals/0/Users/038/38/38/per-node_forward_proxy.jpg?ver=2017-09-14-072419-667)

这种模式更接近传统的出站防火墙模式。在这个模型中，每个容器节点都有一个关联的代理。如果客户端想要连接到特定的应用程序或服务，它将连接到正在运行的客户端所在的容器节点的本地代理。代理然后选择一个适当的应用实例，并转发客户端的请求。橙色和蓝色的应用连接到与其节点相关的同一个代理。代理然后确定所请求的应用实例的哪个实例应该响应。在这个模型中，每个代理必须知道每个应用，以确保它可以将请求转发给适当的实例。

#### 挎斗代理
[![](/data/attachment/album/201804/02/094037r5w5m5y1251bre1l.jpg)](https://devcentral.f5.com/Portals/0/Users/038/38/38/per-pod_sidecar_proxy.jpg?ver=2017-09-14-072424-073)

这种模型也被称为服务网格路由。在这种模型中，每个容器都有自己的代理。如果客户想要连接到一个应用，它将连接到挎斗代理，该代理会选择一个合适的应用程序实例并转发客户端的请求。此行为与*前向代理*模型相同。挎斗代理和前向代理之间的区别在于，挎斗代理不需要修改容器编排环境。例如，为了插入一个前向代理到k8s，你需要代理*和*一个kube-proxy的替代。挎斗代理不需要这种修改，因为应用会自动连接到 “挎斗” 代理而不是通过代理路由。

#### 总结
每种模式都有其优点和缺点。三者共同依赖于环境数据（远程监控和配置变化），以及融入生态系统的需求。有些模型是根据你选择的环境预先确定的，因此需要仔细考虑将来的需求（服务插入、安全性、网络复杂性）在建立模型之前进行评估。

在容器及其在企业中的发展方面，我们还处于早期阶段。随着它们继续延伸到生产环境中，了解容器化环境发布的应用程序的需求以及它们在代理模型实现上的差异是非常重要的。

这篇文章是匆匆写就的。现在就这么多。

---
via: [DZone](https://dzone.com/articles/proxy-models-in-container-environments)  
作者：[Lori MacVittie](https://dzone.com/users/307701/lmacvittie.html)  
译者：[geekpi](https://github.com/geekpi)  
校对：[wxy](https://github.com/wxy)  
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出