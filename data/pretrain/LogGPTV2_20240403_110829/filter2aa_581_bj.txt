business API invocation. In the following sample request, the OAuth client invokes the 
student API with a query parameter. Let’s see how to calculate the base string in this case:
POST /student?name=pavithra HTTP/1.1
Host: server.com
Content-Type: application/x-www-form-urlencoded
Authorization: OAuth realm="simple",
oauth_consumer_key="dsdsddDdsdsds ",
oauth_token="dsdsdsdsdweoio998s",
oauth_signature_method="HMAC-SHA1",
oauth_timestamp="1474343201",
oauth_nonce="rerwerweJHKjhkdsjhkhj",
oauth_signature="bYT5CMsGcbgUdFHObYMEfcx6bsw%3D"
Step 1: Get the uppercase value of the HTTP request header (GET or POST):
POST
APPendix B  OAuTH 1.0
345
Step 2: Get the value of the scheme and the HTTP host header in lowercase. If the 
port has a nondefault value, it needs to be included as well:
http://server.com
Step 3: Get the path and the query components in the request resource URI:
/student?name=pavithra
Step 4: Get all the OAuth protocol parameters, excluding oauth_signature, 
concatenated by & (no line breaks):
oauth_consumer_key="dsdsddDdsdsds"&
oauth_token="dsdsdsdsdweoio998s"&
oauth_signature_method="HMAC-SHA1"&
oauth_timestamp="1474343201"&
oauth_nonce="rerwerweJHKjhkdsjhkhj"
Step 5: Concatenate the output from steps 2 and 3 (no line breaks):
http://server.com/student?name=pavithra
Step 6: Concatenate the output from steps 5 and 4 with & (no line breaks):
http://server.com/student?name=pavithra&
oauth_consumer_key="dsdsddDdsdsds"&
oauth_token="dsdsdsdsdweoio998s"&
oauth_signature_method="HMAC-SHA1"&
oauth_timestamp="1474343201"&
oauth_nonce="rerwerweJHKjhkdsjhkhj"
Step 7: URL-encode the output from step 6 (no line breaks):
http%3A%2F%2Fserver.com%2Fstudent%3Fname%3Dpavithra%26
oauth_consumer_key%3D%22dsdsddDdsdsds%20%22%26
oauth_token%3D%22dsdsdsdsdweoio998s%22%26
oauth_signature_method%3D%22HMAC-SHA1%22%26
oauth_timestamp%3D%221474343201%22%26
oauth_nonce%3D%22rerwerweJHKjhkdsjhkhj%22
APPendix B  OAuTH 1.0
346
Step 8: Concatenate the output from steps 1 and 7 with &. This produces the final 
base string to calculate the oauth_signature (no line breaks):
POST& http%3A%2F%2Fserver.com%2Fstudent%3Fname%3Dpavithra%26
oauth_consumer_key%3D%22dsdsddDdsdsds%20%22%26
oauth_token%3D%22dsdsdsdsdweoio998s%22%26
oauth_signature_method%3D%22HMAC-SHA1%22%26
oauth_timestamp%3D%221474343201%22%26
oauth_nonce%3D%22rerwerweJHKjhkdsjhkhj%22
Once you have the base string, the OAuth signature is calculated in the following 
manner with the HMAC-SHA1 and RSA-SHA1 signature methods. The value of oauth_
token_secret is from the token-credential request phase:
oauth_signature= HMAC-SHA1(consumer_secret&oauth_token_secret,  
base- string)
oauth_signature= RSA-SHA1(RSA private key, base-string)
 Three-Legged OAuth vs. Two-Legged OAuth
The OAuth flow discussed so far involves three parties: the resource owner, the client, 
and the resource server. The client accesses a resource hosted in the resource server on 
behalf of the resource owner. This is the most common pattern in OAuth, and it’s also 
known as three-legged OAuth (three parties involved). In two-legged OAuth, you have 
only two parties: the client becomes the resource owner. There is no access delegation in 
two-legged OAuth.
Note Two-legged OAuth never made it to the ieTF. The initial draft specification 
is available at http://oauth.googlecode.com/svn/spec/ext/consumer_
request/1.0/drafts/2/spec.html.
If the same student API discussed earlier is secured with two-legged OAuth, the 
request from the client looks like the following. The value of oauth_token is an empty 
string. There is no token dance in two-legged OAuth. You only need oauth_consumer_
key and consumer_secret. The HMAC-SHA1 signature is generated using consumer_
secret as the key:
APPendix B  OAuTH 1.0
347
POST /student?name=pavithra HTTP/1.1
Host: server.com
Content-Type: application/x-www-form-urlencoded
Authorization: OAuth realm="simple",
oauth_consumer_key="dsdsddDdsdsds ",
oauth_token="",
oauth_signature_method="HMAC-SHA1",
oauth_timestamp="1474343201",
oauth_nonce="rerwerweJHKjhkdsjhkhj",
oauth_signature="bYT5CMsGcbgUdFHObYMEfcx6bsw%3D"
Note in both HTTP Basic authentication and two-legged OAuth, the resource 
owner acts as the client and directly invokes the APi. With HTTP Basic 
authentication, you pass the credentials over the wire; this must be over TLS. With 
two-legged OAuth, you never pass the consumer_secret over the wire, so it 
need not be on TLS. 
HTTP digest authentication looks very similar to two-legged OAuth. in both cases, 
you never pass credentials over the wire. The difference is that HTTP digest 
authentication authenticates the user, whereas two-legged OAuth authenticates 
the application on behalf of the resource owner. A given resource owner can own 
multiple applications, and each application can have its own consumer key and 
consumer secret.
 OAuth WRAP
In November 2009, a new draft specification for access delegation called Web Resource 
Authorization Profiles (WRAP) was proposed, built on top of the OAuth 1.0 model. 
WRAP was later deprecated in favor of OAuth 2.0.
APPendix B  OAuTH 1.0
348
Note The initial draft of the WRAP profile submitted to the ieTF is available at 
http://tools.ietf.org/html/draft-hardt-oauth-01.
Unlike OAuth 1.0, WRAP didn’t depend on a signature scheme. At a high level, the 
user experience was the same as in OAuth 1.0, but WRAP introduced a new component 
into the access delegation flow: the authorization server. Unlike in OAuth 1.0, all the 
communications with respect to obtaining a token now happens between the client 
and the authorization server (not with the resource server). The client first redirects the 
user to the authorization server with its consumer key and the callback URL. Once the 
user authorized the access rights to the client, the user is redirected back to the callback 
URL with a verification code. Then the client has to do a direct call to the access token 
endpoint of the authorization server with the verification code to get the access token. 
Thereafter, the client only needs to include the access token in all API calls (all API calls 
must be on TLS):
https://friendfeed-api.com/v2/feed/home?wrap_access_token=dsdsdrwerwr
Note in november 2009, Facebook joined the Open Web Foundation, together 
with Microsoft, Google, Yahoo!, and many others, with a commitment to support 
open standards for web authentication. Keeping that promise, in december 2009, 
Facebook added OAuth WRAP support to FriendFeed, which it had acquired a few 
months earlier.
OAuth WRAP was one of the initial steps toward OAuth 2.0. WRAP introduced two 
types of profiles for acquiring an access token: autonomous client profiles and user 
delegation profiles. In autonomous client profiles, the client becomes the resource 
owner, or the client is acting on behalf of itself. In other words, the resource owner is 
the one who accesses the resource. This is equivalent to the two- legged OAuth model 
in OAuth 1.0. In user delegation profiles, the client acts on behalf of the resource 
owner. OAuth 1.0 didn’t have this profile concept, and was limited to a single flow. This 
extensibility introduced by OAuth WRAP later became a key part of OAuth 2.0.
APPendix B  OAuTH 1.0
349
 Client Account and Password Profile
The OAuth WRAP specification introduced two autonomous client profiles: the Client 
Account and Password Profile and the Assertion Profile. The Client Account and 
Password Profile uses the client’s or the resource owner’s credentials at the authorization 
server to obtain an access token. This pattern is mostly used for server-to-server 
authentication where no end user is involved. The following cURL command does 
an HTTP POST to the WRAP token endpoint of the authorization server, with three 
attributes: wrap_name is the username, wrap_password is the password corresponding 
to the username, and wrap_scope is the expected level of access required by the client. 
wrap_scope is an optional parameter:
\> curl –v –k –X POST
     –H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
     –d "wrap_name=admin&
         wrap_password=admin&
         wrap_scope=read_profile"
         https://authorization-server/wrap/token
This returns wrap_access_token, wrap_refresh_token, and wrap_access_token_
expires_in parameters. wrap_access_token_expires_in is an optional parameter that 
indicates the lifetime of wrap_access_token in seconds. When wrap_access_token 
expires, wrap_refresh_token can be used to get a new access token. OAuth WRAP 
introduced for the first time this token-refreshing functionality. The access token refresh 
request only needs wrap_refresh_token as a parameter, as shown next, and it returns 
a new wrap_access_token. It doesn’t return a new wrap_refresh_token. The same 
wrap_refresh_token obtained in the first access token request can be used to refresh 
subsequent access tokens:
\> curl –v –k –X POST
     –H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
     –d "wrap_refresh_token=Xkjk78iuiuh876jhhkwkjhewew"
         https://authorization-server/wrap/token
APPendix B  OAuTH 1.0
350
 Assertion Profile
The Assertion Profile is another profile introduced by OAuth WRAP that falls under 
the autonomous client profiles. This assumes that the client somehow obtains an 
assertion—say, for example, a SAML token—and uses it to acquire a wrap_access_token. 
The following example cURL command does an HTTP POST to the WRAP token 
endpoint of the authorization server, with three attributes: wrap_assertion_format is the 
type of the assertion included in the request in a way known to the authorization server, 
wrap_assertion is the encoded assertion, and wrap_scope is the expected level of access 
required by the client. wrap_scope is an optional parameter:
\> curl –v –k –X POST
     –H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
     –d "wrap_assertion_format=saml20&
         wrap_assertion=encoded-assertion&
         wrap_scope=read_profile"
         https://authorization-server/wrap/token
The response is the same as in the Client Account and Password Profile, except that 
in the Assertion Profile, there is no wrap_refresh_token.
 Username and Password Profile
The WRAP user delegation profiles introduced three profiles: the Username and 
Password Profile, the Web App Profile, and the Rich App Profile. The Username 
and Password Profile is mostly recommended for installed trusted applications. 
The application is the client, and the end user or the resource owner must provide 
their username and password to the application. Then the application exchanges 
the username and password for an access token and stores the access token in the 
application. 
The following cURL command does an HTTP POST to the WRAP token endpoint 
of the authorization server, with four attributes: wrap_client_id is an identifier for the 
application, wrap_username is the username of the end user, wrap_password is the 
APPendix B  OAuTH 1.0
351
password corresponding to the username, and wrap_scope is the expected level of 
access required by the client (wrap_scope is an optional parameter):
\> curl –v –k –X POST
     –H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
     –d "wrap_client_id=app1&
         wrap_username=admin&
         wrap_password=admin&
         wrap_scope=read_profile"
         https://authorization-server/wrap/token
This returns wrap_access_token and wrap_access_token_expires_in parameters. 
wrap_access_token_expires_in is an optional parameter that indicates the lifetime 
of wrap_access_token in seconds. If the authorization server detects any malicious 
access patterns, then instead of sending wrap_access_token to the client application, 
it returns a wrap_verification_url. It’s the responsibility of the client application to load 
this URL into the user’s browser or advise them to visit that URL. Once the user has 
completed that step, the user must indicate to the client application that verification is 
complete. Then the client application can initiate the token request once again. Instead 
of sending a verification URL, the authorization server can also enforce a CAPTCHA 
verification through the client application. There the authorization server sends back 
a wrap_captcha_url, which points to the location where the client application can load 
the CAPTCHA. Once it’s loaded and has the response from the end user, the client 
application must POST it back to the authorization server along with the token request:
\> curl –v –k –X POST
     –H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
     –d "wrap_captcha_url=url-encoded-captcha-url&
         wrap_captch_solution-solution&
         wrap_client_id=app1&
         wrap_username=admin&
         wrap_password=admin&
         wrap_scope=read_profile"
         https://authorization-server/wrap/token
APPendix B  OAuTH 1.0
352
 Web App Profile
The Web App Profile defined under the WRAP user delegation profiles is mostly 
recommended for web applications, where the web application must access a resource 
belonging to an end user on his or her behalf. The web application follows a two-step 
process to acquire an access token: it gets a verification code from the authorization 
server and then exchanges that for an access token. The end user must initiate the 
first step by visiting the client web application. Then the user is redirected to the 
authorization server. The following example shows how the user is redirected to the 
authorization server with appropriate WRAP parameters:
https://authorization-server/wrap/authorize?
        wrap_client_id=0rhQErXIX49svVYoXJGt0DWBuFca&
        wrap_callback=https%3A%2F%2Fmycallback&
        wrap_client_state=client-state&
        wrap_scope=read_profile
wrap_client_id is an identifier for the client web application. wrap_callback is the 
URL where the user is redirected after a successful authentication at the authorization 
server. Both wrap_client_state and wrap_scope are optional parameters. Any value in 
wrap_client_state must be returned back to the client web application. After the end 
user’s approval, a wrap_verification_code and other related parameters are returned to 
the callback URL associated with the client web application as query parameters.
The next step is to exchange this verification code to an access token:
\> curl –v –k –X POST
     –H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
     –d "wrap_client_id=0rhQErXIX49svVYoXJGt0DWBuFca &
         wrap_client_secret=weqeKJHjhkhkihjk&
         wrap_verification_code=dsadkjljljrrer&
         wrap_callback=https://mycallback"
         https://authorization-server/wrap/token
This cURL command does an HTTP POST to the WRAP token endpoint of the 
authorization server, with four attributes: wrap_client_id is an identifier for the 
application, wrap_client_secret is the password corresponding to wrap_client_id,  
wrap_verification_code is the verification code returned in the previous step, and  
wrap_callback is the callback URL where the verification code was sent. This returns 
APPendix B  OAuTH 1.0
353
wrap_access_token, wrap_refresh_token, and wrap_access_token_expires_in 
parameters. wrap_access_token_expires_in is an optional parameter that indicates  
the lifetime of wrap_access_token in seconds. When wrap_access_token expires,  
wrap_refresh_token can be used to get a new access token.
 Rich App Profile
The Rich App Profile defined under the WRAP user delegation profiles is most 
commonly used in scenarios where the OAuth client application is an installed 
application that can also work with a browser. Hybrid mobile apps are the best 
example. The protocol flow is very similar to that of the Web App Profile. The rich client 
application follows a two-step process to acquire an access token: it gets a verification 
code from the authorization server and then exchanges that for an access token. The 
end user must initiate the first step by visiting the rich client application. Then the 
application spawns a browser and redirects the user to the authorization server:
https://authorization-server/wrap/authorize?
        wrap_client_id=0rhQErXIX49svVYoXJGt0DWBuFca&
        wrap_callback=https%3A%2F%2Fmycallback&
        wrap_client_state=client-state&
        wrap_scope=read_profile
wrap_client_id is an identifier for the rich client application. wrap_callback is the 
URL where the user is redirected after a successful authentication at the authorization 
server. Both wrap_client_state and wrap_scope are optional parameters. Any value in 
wrap_client_state is returned back to the callback URL. After the end user’s approval, a 
wrap_verification_code is returned to the rich client application.
The next step is to exchange this verification code for an access token:
\> curl –v –k –X POST
     –H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
     –d "wrap_client_id=0rhQErXIX49svVYoXJGt0DWBuFca&
         wrap_verification_code=dsadkjljljrrer&
         wrap_callback=https://mycallback"
         https://authorization-server/wrap/token
APPendix B  OAuTH 1.0
354
This cURL command does an HTTP POST to the WRAP token endpoint of the 
authorization server, with three attributes: wrap_client_id is an identifier for the 
application, wrap_verification_code is the verification code returned in the previous 
step, and wrap_callback is the callback URL where the verification code was sent. This 
returns wrap_access_token, wrap_refresh_token, and wrap_access_token_expires_in 
parameters. wrap_access_token_expires_in is an optional parameter that indicates  
the lifetime of wrap_access_token in seconds. When wrap_access_token expires,  
wrap_refresh_token can be used to get a new access token. Unlike in the Web App Profile, 