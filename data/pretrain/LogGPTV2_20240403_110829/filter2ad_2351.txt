title:POSTER: PatchGen: Towards Automated Patch Detection and Generation
for 1-Day Vulnerabilities
author:Tianyue Luo and
Chen Ni and
Qing Han and
Mutian Yang and
JingZheng Wu and
Yanjun Wu
Poster: PatchGen: Towards Automated Patch Detection
and Generation for 1-Day Vulnerabilities
Tianyue Luo
General Department
Institute of Software, The
Chen Ni
General Department
Institute of Software, The
Qing Han
General Department
Institute of Software, The
Chinese Academy of Sciences
PI:EMAIL
Chinese Academy of Sciences
PI:EMAIL
Chinese Academy of Sciences
PI:EMAIL
Mutian Yang
General Department
Institute of Software, The
Chinese Academy of Sciences
PI:EMAIL
Jingzheng Wu
General Department, State
Key Laboratory of Computer
Yanjun Wu
General Department, State
Key Laboratory of Computer
Sciences
Sciences
Institute of Software, The
Chinese Academy of Sciences
PI:EMAIL
Institute of Software, The
Chinese Academy of Sciences
PI:EMAIL
ABSTRACT
A large fraction of source code in open-source systems such
as Linux contain 1-day vulnerabilities. The command “patch”
is used to apply the patches to source codes, and return-
s feedback information automatically. Unfortunately, this
operation is not always successful when patching directly,
and two typical error scenarios may occur as follows. 1.
The patch may be applied in wrong place, meaning the ﬁx
location should be adjusted in patch. 2. The patch may
be applied repeatedly, meaning a veriﬁcation should be ex-
ecuted before applying. To resolve the above scenarios, we
propose PatchGen, a new system to quickly detect and gen-
erate patches for 1-day vulnerabilities in OS distributions.
Comparing with the previous works on 1-day vulnerabilities
detection, PatchGen is able to solve the above two error sce-
narios and use a quick, syntax-based approach that scales to
OS distribution-sized code base no matter the code written
in what types of language. We implement the PatchGen pro-
totype, and evaluate it by checking all codes from packages
in Ubuntu Maverick/Oneiric, all SourceForge C and C++
projects, and the Linux kernel source. Speciﬁcally, it takes
less than 10 minutes for PatcheGen to detect 175 1-day vul-
nerabilities and generate 140 patches for Linux Kernel. All
of the results have been manually conﬁrmed and tested in
the real systems.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—In-
formation ﬂow controls
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distribut-
ed for proﬁt or commercial advantage and that copies bear this notice and the full
citation on the ﬁrst page. Copyrights for third-party components of this work must
be honored. For all other uses, contact the Owner/Author(s).Copyright is held by the
owner/author(s).
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
ACM 978-1-4503-3832-5/15/10.
http://dx.doi.org/10.1145/2810103.2810122.
Keywords
Patch; 1-Day Vulnerabilities; Automated Generation; Scal-
ability
1.
INTRODUCTION
In open-source systems such as Linux, developers use patch
to ﬁx bugs. Although the “patch” command can apply a
patch to source code and return feedback information auto-
matically, the execution may not be successfully[3, 2]. That
is, the result is not necessarily true. Here are two error
scenarios when patching directly.
1. The source code need to be changed, but it ﬁxes a
wrong place while patching directly. That means the patch
should be adjusted before patching [1].
2. The source ﬁle has been ﬁxed, but if patched again,
the source code can also be changed. That means the patch
whether has been applied must be detected.
The situations described above is common/can’t be ig-
nored, and we should keep in mind while patching source
code. But if there are a lot of patches should be apply at
the same time, the examination will be a tedious work. This
will be more obverse when the source code is diﬀerent from
the version the patch originally pointed at, especially for
the costumed system based on open-source systems[5, 4].
Above all, batch patching a software code poses two main
challenges: First, whether the source code has the questions
as the patches described must be determined automatically.
Second, typical checks must be performed to make sure the
patches can be patched correctly. Moreover, the result must
be easily comprehended and presented to user friendly.
2. DESIGN OF PATCHGEN
PatchGen has two major functionalities: detecting code
segments that are same with patches in database, then iden-
tifying whether the patches should be patched and adjusting
them. It requires no modiﬁcation to the source code of soft-
ware being analyzed. The following subsections will describe
the design for each functionality. Our method implements a
four-step procedure to solve these problems. This procedure
1656is motivated by the design space goals of: (1) focusing on
unpatched code’s positions, (2) scaling to large and diverse
customized code bases such as a new kernel based Ubuntu,
(3) minimizing false detection. The core of the PatchGen
system is illustrated in Figure 1 and the steps are outlined
in the following:
Figure 1: The Overview Design of PatchGen
1. Patch extraction. PatchGen extracts the related source
ﬁles’information, original code snippets, patched code snip-
pets and position identiﬁers ﬁrstly. As comments are not
considered normal statements in PatchGen, and are thereby
ﬁltered at this step. Farther more, we normalizes each code
snippet by removing the redundant whitespace, curly braces
and non ASCII characters. 2. Source ﬁle grouping. Accord-
ing to the information extracted in the ﬁrst step, PatchGen
divides the source ﬁles and patches into groups, which is con-
sisted of a set of patches and a source ﬁle related to them.
For each source ﬁle related to the patch, PatchGen perform-
s the same normalize operation. 3. Vulnerability scanning.
PatchGen executes this step by group using a Sliding Win-
dow Algorithm, the length n of the window is decided by
the normalized patch ﬁle. Then the source ﬁle is compared
with patch segments, and possible unpatched code positions
are marked at the same time. 4. Pruning False Positives.
As matched code snippets are not necessarily the vulnera-
bility, PatchGen performs a ﬁlter operation on the identiﬁed
unpatched codes, such that the false detections can be re-
duced. 5. Report generation. In order to show the detail of
the detection, a report is generated, which can also help to
accelerate the manual auditing of source code.
2.1 Patch Extraction
Patch is in the form of uniﬁed diﬀs, which always consists
of one or more sequence of diﬀ hunks that contain the line
diﬀerence in the ﬁle. The diﬀ hunk starts with two almost
same lines as header, the only diﬀerence is that the origi-
nal ﬁle is preﬁxed by “—” but the new ﬁle is preﬁxed by
“+++”. The unchanged, contextual lines are preﬁxed by a
space character, added source code lines are preﬁxed by a
plus sign “+”, and deletions are preﬁxed by a minus sign “-”.
PatchGen extracts the original code segment and the patched
code segment from given patch ﬁle respectively. To extrac-
t the original code segment, we reserves the lines started
with the sign“-”, and deletes the ones started with sign “+”.
And we do the reverse operation to obtain the patched code
segment. To remove the inﬂuence caused by code nuance,
PatchGen normalizes each patch ﬁle: removes typical lan-
guage comments, all non-ASCII characters and redundant
whitespace. Position information after identiﬁer “@@” is al-
so extracted for ﬁlter operation described in step4.
2.2 Source File Grouping
In most cases, we can start vulnerability scanning after
extracting useful information from patches, which is similar
with the process of code clones detection. There are many
ways to ﬁnd code clones in amount of source ﬁlesˇcˇnmost
of which search the whole source ﬁles to ﬁnd all code clones
and then check if they are patched. This process always con-
sumes too much time. In consideration that we only want
to identify whether the patch is patched, we can use the
information included in the format context. The two-line
header before diﬀ hunks indicates the source ﬁle the patch
inﬂuenced, so that we can just focus in this ﬁle while doing
bug ﬁnding. Aware of there are many diﬀerent patches in-
ﬂuence the same source ﬁle, PatchGen groups these patches
according to the context format before diﬀ hunk to further
reduce the scanning time. For each source ﬁle related to the
patches, PatchGen performs the same normalize operation
at the same time.
2.3 Unpatched Code Checking
Through the two steps above, we get a sequence of groups,
which is consisted of a set of patch blocks and a source ﬁle
related to them. Each patch block contains the inﬂuenced
source ﬁlename, the original code segment, the patched code
segment and position information. PatchGen uses a string-
based techniques to detect whether the code is patched. By
dividing the normalized source ﬁle in to strings based on the
original code snippet got from the patch block, we preforms
an exact match on each window. The compared window
slips backward until they matched, and the code segments
detected are potential defect code and need future analysis.
2.4 Pruning False Positives
Research shows that code clones is very common in large-
scale software, the matched code segments in step3 may not
be the vulnerability we expected, although we have narrowed
down the detection to the speciﬁed ﬁle. Just as the problem
described in section2, which indicates that a farther pro-
cess should be done to reduce the false positives. The range
information before each diﬀ hunk, which is surrounded by
double-at signs “@”, tells the changed position of the source
ﬁle. However, due to version diﬀerences, this information is
not always accurate. PatchGen use another position infor-
mation after sign“@@”, which tells the heading of the section
or function that the hunk is part of. We check the identiﬁer
after“@@” for each matched diﬀ hunk, then do the subpro-
cess based on the rules described in table1.
If the identiﬁer after “@@” can be found in source ﬁle and
the position of matched code segment is behind the identiﬁer
at the same time, that means the reverse patch detection is
needed. PatchGen uses the patched code snippet extracted
in step1 to do a farther comparison with the source ﬁle.
Diﬀerent from the ﬁrst time detection, we just compare the
code after the position where the identiﬁer ﬁrst appeared.
The origin patch block will be considered as a right one while
1657Table 1: Rules for Subprocess in PatchGen
Situation of
identiﬁer after “@@”
Exist & Can’t be
found in source ﬁle
Exist & The position
of matched code
segmentis before the
identiﬁer
Exit & The position
of matched code
segment is behind
the identiﬁer
Empty
Rule description
The corresponding matched
code segment is false positive
and can be ﬁltered out
The corresponding matched
code segment is false positive
and can be ﬁltered out
Go to reverse patch detection.
That is, PatchGen uses patched
code snippet to compare with
source code. This time we only
compare with part of source ﬁle,
starting from line number where
“@@” locates. No matching
results means that this patch
block is indeed a right one.
Otherwise, go to manual
auditing to conﬁrm whether
this match is false positive.
Go to manual auditing.
none is found this time, otherwise, we should do a manual
auditing to conﬁrm whether the ﬁrst match is false positive.
2.5 Report Generation
Although PatchGen has given a group of adjusted patch-
es which should be patched on the system and made a ﬁlter
operation on the result, a report is still needed to illustrate
the details. A report contains patch blocks, the correspond-
ing detected locations, and the contextual code. This can
assist analysts in deciding whether use the patches, even in
ﬁnding and adjusting a patch for potential vulnerability.
3. EVALUATION
We conducted a 10-versions of Linux Kernel experiment
to test PatchGen.The accumulated detected 1187 1-day vul-
nerabilities and generate 1187 correspondence patches.In the
results, PatchGen has successfully solved the two error sce-
narios in the previously mentioned. Figure2 shows a hunk in
CVE-2014-3153 and parts of its corresponding source code in
the ﬁle /kernel/futex.c of Linux Kernel-3.13.0-24.47. There
are two places can be patched: segment 1 and segment 2.
Wherein segment 1 doesn’t need to patch . PatchGen based
on an analysis to ﬁx segment 2 and it can just change this
segment. However, if the execution of “patch” directly ,ac-
cording to rules, segment 1 is ﬁxed and this patch ﬁxes a
wrong place.
A hunk in CVE-2011-2022 and parts of its corresponding
source code in the ﬁle /kernel/futex.c of Linux Kernel-3.13.0-
24.47. The execution of “patch” command will patch code
segment from line 1087 to line 1091 showed in subgraph b,
and return a successful result. In fact, PatchGen generate
the patch should ﬁx at the code segment from line 1140 to
line 1150.
4. CONCLUSION
We present PatchGen in this poster, which is a system for
quickly generate patch of 1-day vulnerable code. PatchGen
(a) A hunk in CVE-2014-3153
(b) Matched segment 1 and segment 2
Figure 2: A hunk in CVE-2014-5153 and parts of
matched code
represents that uses a quick, syntax-based approach that s-
cales to OS distribution-sized code base that include code
written in many diﬀerent languages. At the same time,
PatchGen has the ability to handle real code, and mini-
mizing false detection of 1-day vulnerabilities. PatchGen
generate 1187 patches, which likely ﬁx real vulnerabilities,
by analyzing more than 2 billion lines of code. We believe
PatchGen can be realistic solution for developers to enhance
the security of their code in the future work.
5. ACKNOWLEDGMENTS
This work is supported by NSFC No.61303057 and Project
No.2012ZX01039-004.
6. REFERENCES
[1] J. Jang, A. Agrawal, and D. Brumley. Redebug:
Finding unpatched code clones in entire OS
distributions. In IEEE Symposium on Security and
Privacy, SP 2012, 21-23 May 2012, San Francisco,
California, USA, pages 48–62, 2012.
[2] E. J¨urgens, F. Deissenboeck, B. Hummel, and
S. Wagner. Do code clones matter? In 31st
International Conference on Software Engineering,
ICSE 2009, May 16-24, 2009, Vancouver, Canada,
Proceedings, pages 485–495, 2009.
[3] Z. Li, S. Lu, S. Myagmar, and Y. Zhou. Cp-miner:
Finding copy-paste and related bugs in large-scale
software code. IEEE Trans. Software Eng.,
32(3):176–192, 2006.
[4] T. Ohta, H. Murakami, H. Igaki, Y. Higo, and
S. Kusumoto. Source code reuse evaluation by using
real/potential copy and paste. In 9th IEEE
International Workshop on Software Clones, IWSC
2015, Montreal, QC, Canada, March 6, 2015, pages
33–39, 2015.
[5] Z. Yin, M. Caesar, and Y. Zhou. Towards
understanding bugs in open source router software.
Computer Communication Review, 40(3):34–40, 2010.
1658